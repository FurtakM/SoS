// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 23020 0 0
// InitNature ;
  19: CALL 19535 0 0
// InitArtifact ;
  23: CALL 20152 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5136 0 0
// PrepareAlliance ;
  44: CALL 1460 0 0
// PrepareArabian ;
  48: CALL 7179 0 0
// PrepareRussian ;
  52: CALL 9486 0 0
// PrepareLegion ;
  56: CALL 7746 0 0
// Action ;
  60: CALL 12458 0 0
// MC_Start ( ) ;
  64: CALL 25200 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked , negotiationWithArabs , omarKilled ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// negotiationWithArabs := LoadVariable ( 13a_negotiationWithArabs , false ) ;
  96: LD_ADDR_EXP 19
 100: PUSH
 101: LD_STRING 13a_negotiationWithArabs
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// omarKilled := false ;
 112: LD_ADDR_EXP 20
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// russianDestroyed := false ;
 120: LD_ADDR_EXP 2
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// legionDestroyed := false ;
 128: LD_ADDR_EXP 3
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// americanDestroyed := false ;
 136: LD_ADDR_EXP 4
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// arabianDestroyed := false ;
 144: LD_ADDR_EXP 5
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// americanCapitulated := false ;
 152: LD_ADDR_EXP 6
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// russianCapitulated := false ;
 160: LD_ADDR_EXP 7
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// legionCapitulated := false ;
 168: LD_ADDR_EXP 8
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// artifactIResearched := false ;
 176: LD_ADDR_EXP 12
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// artifactIIResearched := false ;
 184: LD_ADDR_EXP 13
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// artifactIIIResearched := false ;
 192: LD_ADDR_EXP 14
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// alienSpotted := false ;
 200: LD_ADDR_EXP 10
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// spawnOmar := false ;
 208: LD_ADDR_EXP 11
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 224: LD_ADDR_EXP 16
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// allianceTeam := [ ] ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// arabianAttacked := false ;
 239: LD_ADDR_EXP 18
 243: PUSH
 244: LD_INT 0
 246: ST_TO_ADDR
// end ;
 247: LD_VAR 0 1
 251: RET
// export function CustomInitMacro ( ) ; begin
 252: LD_INT 0
 254: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 255: LD_ADDR_EXP 104
 259: PUSH
 260: LD_INT 26
 262: PUSH
 263: LD_INT 1
 265: PUSH
 266: LD_INT 4
 268: PUSH
 269: LD_INT 8
 271: PUSH
 272: EMPTY
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 278: LD_ADDR_EXP 105
 282: PUSH
 283: LD_INT 27
 285: PUSH
 286: LD_INT 2
 288: PUSH
 289: LD_INT 3
 291: PUSH
 292: LD_INT 7
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 301: LD_INT 1
 303: PPUSH
 304: LD_INT 6
 306: PUSH
 307: LD_INT 7
 309: PUSH
 310: LD_INT 9
 312: PUSH
 313: LD_INT 10
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PUSH
 322: LD_OWVAR 67
 326: ARRAY
 327: PPUSH
 328: LD_INT 28
 330: PPUSH
 331: CALL 46917 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 335: LD_INT 1
 337: PPUSH
 338: LD_INT 10
 340: PUSH
 341: LD_INT 11
 343: PUSH
 344: LD_INT 13
 346: PUSH
 347: LD_INT 15
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: LIST
 354: LIST
 355: PPUSH
 356: CALL 47996 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 29
 365: PUSH
 366: EMPTY
 367: LIST
 368: PPUSH
 369: CALL 48089 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 373: LD_ADDR_EXP 109
 377: PUSH
 378: LD_EXP 109
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: LD_INT 22
 388: PUSH
 389: LD_INT 2
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: PUSH
 396: LD_INT 25
 398: PUSH
 399: LD_INT 15
 401: PUSH
 402: EMPTY
 403: LIST
 404: LIST
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: PPUSH
 410: CALL_OW 69
 414: PPUSH
 415: CALL_OW 1
 419: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 420: LD_INT 1
 422: PPUSH
 423: LD_INT 13
 425: PUSH
 426: LD_INT 2
 428: PUSH
 429: LD_INT 1
 431: PUSH
 432: LD_INT 31
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: PUSH
 441: LD_INT 13
 443: PUSH
 444: LD_INT 2
 446: PUSH
 447: LD_INT 1
 449: PUSH
 450: LD_INT 31
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: PUSH
 459: LD_INT 13
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 1
 467: PUSH
 468: LD_INT 28
 470: PUSH
 471: EMPTY
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 13
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 1
 485: PUSH
 486: LD_INT 28
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: PUSH
 495: LD_INT 13
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 28
 506: PUSH
 507: EMPTY
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 13
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: LD_INT 1
 521: PUSH
 522: LD_INT 28
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_INT 13
 533: PUSH
 534: LD_INT 1
 536: PUSH
 537: LD_INT 2
 539: PUSH
 540: LD_INT 88
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: LIST
 547: LIST
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: CALL 47254 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 4
 567: PPUSH
 568: CALL 47439 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 572: LD_INT 2
 574: PPUSH
 575: LD_INT 10
 577: PUSH
 578: LD_INT 11
 580: PUSH
 581: LD_INT 12
 583: PUSH
 584: LD_INT 14
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PPUSH
 593: CALL 47996 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 597: LD_INT 2
 599: PPUSH
 600: LD_INT 14
 602: PUSH
 603: EMPTY
 604: LIST
 605: PPUSH
 606: CALL 48089 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 610: LD_INT 2
 612: PPUSH
 613: LD_INT 21
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 51
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 22
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 52
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: LD_INT 24
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 3
 747: PUSH
 748: LD_INT 47
 750: PUSH
 751: EMPTY
 752: LIST
 753: LIST
 754: LIST
 755: LIST
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PPUSH
 767: CALL 47254 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 771: LD_INT 2
 773: PPUSH
 774: LD_INT 5
 776: PPUSH
 777: CALL 47439 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 781: LD_INT 2
 783: PPUSH
 784: LD_INT 0
 786: PPUSH
 787: CALL 47869 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 791: LD_INT 3
 793: PPUSH
 794: LD_INT 10
 796: PUSH
 797: LD_INT 12
 799: PUSH
 800: LD_INT 14
 802: PUSH
 803: LD_INT 15
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: PUSH
 812: LD_OWVAR 67
 816: ARRAY
 817: PPUSH
 818: LD_INT 24
 820: PPUSH
 821: CALL 46917 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 825: LD_INT 3
 827: PPUSH
 828: LD_INT 10
 830: PUSH
 831: LD_INT 11
 833: PUSH
 834: LD_INT 13
 836: PUSH
 837: LD_INT 15
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PPUSH
 846: CALL 47996 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 850: LD_INT 3
 852: PPUSH
 853: LD_INT 13
 855: PUSH
 856: EMPTY
 857: LIST
 858: PPUSH
 859: CALL 48089 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 863: LD_ADDR_EXP 109
 867: PUSH
 868: LD_EXP 109
 872: PPUSH
 873: LD_INT 3
 875: PPUSH
 876: LD_INT 22
 878: PUSH
 879: LD_INT 8
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: PUSH
 886: LD_INT 25
 888: PUSH
 889: LD_INT 15
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: PPUSH
 900: CALL_OW 69
 904: PPUSH
 905: CALL_OW 1
 909: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 910: LD_INT 3
 912: PPUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 2
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 31
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 13
 951: PUSH
 952: LD_INT 3
 954: PUSH
 955: LD_INT 2
 957: PUSH
 958: LD_INT 32
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 28
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: PUSH
1039: LD_INT 14
1041: PUSH
1042: LD_INT 1
1044: PUSH
1045: LD_INT 2
1047: PUSH
1048: LD_INT 88
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: LIST
1066: PPUSH
1067: CALL 47254 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1071: LD_INT 3
1073: PPUSH
1074: LD_INT 4
1076: PPUSH
1077: CALL 47439 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 10
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 11
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: EMPTY
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 47996 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 33
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 48089 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 6
1127: PUSH
1128: LD_INT 7
1130: PUSH
1131: LD_INT 9
1133: PUSH
1134: LD_INT 10
1136: PUSH
1137: EMPTY
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 48407 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1148: LD_INT 4
1150: PPUSH
1151: LD_INT 54
1153: PPUSH
1154: LD_INT 85
1156: PPUSH
1157: LD_INT 2
1159: PPUSH
1160: LD_INT 25
1162: PUSH
1163: LD_INT 16
1165: PUSH
1166: LD_INT 17
1168: PUSH
1169: LD_INT 18
1171: PUSH
1172: LD_INT 22
1174: PUSH
1175: EMPTY
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 48201 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 5
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 1
1197: PUSH
1198: LD_INT 7
1200: PUSH
1201: EMPTY
1202: LIST
1203: LIST
1204: LIST
1205: LIST
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 1
1215: PUSH
1216: LD_INT 6
1218: PUSH
1219: EMPTY
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: PUSH
1225: LD_INT 5
1227: PUSH
1228: LD_INT 1
1230: PUSH
1231: LD_INT 1
1233: PUSH
1234: LD_INT 7
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: LD_INT 1
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: LD_INT 6
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: LD_INT 1
1266: PUSH
1267: LD_INT 3
1269: PUSH
1270: LD_INT 12
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: PUSH
1279: LD_INT 3
1281: PUSH
1282: LD_INT 1
1284: PUSH
1285: LD_INT 3
1287: PUSH
1288: LD_INT 13
1290: PUSH
1291: EMPTY
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PUSH
1297: EMPTY
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: LIST
1304: PPUSH
1305: CALL 47254 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1309: LD_INT 4
1311: PPUSH
1312: LD_INT 4
1314: PPUSH
1315: CALL 47439 0 2
// MC_SetTame ( 4 , powellApe ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 11
1324: PPUSH
1325: CALL 47820 0 2
// end ;
1329: LD_VAR 0 1
1333: RET
// every 0 0$1 trigger debug do var i ;
1334: LD_EXP 1
1338: IFFALSE 1436
1340: GO 1342
1342: DISABLE
1343: LD_INT 0
1345: PPUSH
// begin enable ;
1346: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1347: LD_ADDR_VAR 0 1
1351: PUSH
1352: LD_INT 22
1354: PUSH
1355: LD_INT 7
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: LD_INT 21
1367: PUSH
1368: LD_INT 1
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: PUSH
1375: LD_INT 21
1377: PUSH
1378: LD_INT 2
1380: PUSH
1381: EMPTY
1382: LIST
1383: LIST
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: PUSH
1390: LD_INT 3
1392: PUSH
1393: LD_INT 24
1395: PUSH
1396: LD_INT 1000
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PPUSH
1412: CALL_OW 69
1416: PUSH
1417: FOR_IN
1418: IFFALSE 1434
// SetLives ( i , 1000 ) ;
1420: LD_VAR 0 1
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 234
1432: GO 1417
1434: POP
1435: POP
// end ;
1436: PPOPN 1
1438: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1439: LD_EXP 16
1443: PUSH
1444: LD_INT 5
1446: GREATEREQUAL
1447: IFFALSE 1459
1449: GO 1451
1451: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1452: LD_STRING ACH_ARTIFACT
1454: PPUSH
1455: CALL_OW 543
1459: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1460: LD_INT 0
1462: PPUSH
1463: PPUSH
1464: PPUSH
1465: PPUSH
1466: PPUSH
// SetInvulnrability ( alien , true ) ;
1467: LD_INT 1
1469: PPUSH
1470: LD_INT 1
1472: PPUSH
1473: CALL_OW 607
// uc_side := 7 ;
1477: LD_ADDR_OWVAR 20
1481: PUSH
1482: LD_INT 7
1484: ST_TO_ADDR
// tmp := [ ] ;
1485: LD_ADDR_VAR 0 5
1489: PUSH
1490: EMPTY
1491: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1492: LD_ADDR_EXP 21
1496: PUSH
1497: LD_STRING JMM
1499: PPUSH
1500: LD_EXP 1
1504: NOT
1505: PPUSH
1506: LD_STRING 14a_
1508: PPUSH
1509: CALL 53728 0 3
1513: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1514: LD_ADDR_EXP 54
1518: PUSH
1519: LD_STRING Burlak
1521: PPUSH
1522: LD_EXP 1
1526: NOT
1527: PPUSH
1528: LD_STRING 14a_
1530: PPUSH
1531: CALL 53728 0 3
1535: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1536: LD_ADDR_EXP 36
1540: PUSH
1541: LD_STRING Joan
1543: PPUSH
1544: LD_EXP 1
1548: NOT
1549: PPUSH
1550: LD_STRING 13a_
1552: PPUSH
1553: CALL 53728 0 3
1557: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1558: LD_ADDR_EXP 22
1562: PUSH
1563: LD_STRING Roth
1565: PPUSH
1566: LD_EXP 1
1570: NOT
1571: PPUSH
1572: LD_STRING 13a_
1574: PPUSH
1575: CALL 53728 0 3
1579: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1580: LD_ADDR_EXP 40
1584: PUSH
1585: LD_STRING Gossudarov
1587: PPUSH
1588: LD_EXP 1
1592: NOT
1593: PPUSH
1594: LD_STRING 13a_
1596: PPUSH
1597: CALL 53728 0 3
1601: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1602: LD_ADDR_EXP 27
1606: PUSH
1607: LD_STRING Denis
1609: PPUSH
1610: LD_EXP 1
1614: NOT
1615: PPUSH
1616: LD_STRING 13a_
1618: PPUSH
1619: CALL 53728 0 3
1623: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1624: LD_ADDR_EXP 37
1628: PUSH
1629: LD_STRING DeltaDoctor
1631: PPUSH
1632: LD_EXP 1
1636: NOT
1637: PPUSH
1638: LD_STRING 13a_
1640: PPUSH
1641: CALL 53728 0 3
1645: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1646: LD_ADDR_EXP 39
1650: PUSH
1651: LD_STRING Mike
1653: PPUSH
1654: LD_EXP 1
1658: NOT
1659: PPUSH
1660: LD_STRING 13a_
1662: PPUSH
1663: CALL 53728 0 3
1667: ST_TO_ADDR
// if DeltaDoctor then
1668: LD_EXP 37
1672: IFFALSE 1690
// tmp := tmp ^ DeltaDoctor ;
1674: LD_ADDR_VAR 0 5
1678: PUSH
1679: LD_VAR 0 5
1683: PUSH
1684: LD_EXP 37
1688: ADD
1689: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1690: LD_ADDR_EXP 35
1694: PUSH
1695: LD_STRING Simms
1697: PPUSH
1698: LD_EXP 1
1702: NOT
1703: PPUSH
1704: LD_STRING 13a_
1706: PPUSH
1707: CALL 53728 0 3
1711: ST_TO_ADDR
// if Simms then
1712: LD_EXP 35
1716: IFFALSE 1734
// tmp := tmp ^ Simms ;
1718: LD_ADDR_VAR 0 5
1722: PUSH
1723: LD_VAR 0 5
1727: PUSH
1728: LD_EXP 35
1732: ADD
1733: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1734: LD_ADDR_EXP 33
1738: PUSH
1739: LD_STRING Frank
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 13a_
1750: PPUSH
1751: CALL 53728 0 3
1755: ST_TO_ADDR
// if Frank then
1756: LD_EXP 33
1760: IFFALSE 1778
// tmp := tmp ^ Frank ;
1762: LD_ADDR_VAR 0 5
1766: PUSH
1767: LD_VAR 0 5
1771: PUSH
1772: LD_EXP 33
1776: ADD
1777: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1778: LD_ADDR_EXP 41
1782: PUSH
1783: LD_STRING Kirilenkova
1785: PPUSH
1786: LD_EXP 1
1790: NOT
1791: PPUSH
1792: LD_STRING 13a_
1794: PPUSH
1795: CALL 53728 0 3
1799: ST_TO_ADDR
// if Kirilenkova then
1800: LD_EXP 41
1804: IFFALSE 1822
// tmp := tmp ^ Kirilenkova ;
1806: LD_ADDR_VAR 0 5
1810: PUSH
1811: LD_VAR 0 5
1815: PUSH
1816: LD_EXP 41
1820: ADD
1821: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1822: LD_ADDR_EXP 42
1826: PUSH
1827: LD_STRING Titov
1829: PPUSH
1830: LD_EXP 1
1834: NOT
1835: PPUSH
1836: LD_STRING 13a_
1838: PPUSH
1839: CALL 53728 0 3
1843: ST_TO_ADDR
// if Titov then
1844: LD_EXP 42
1848: IFFALSE 1866
// tmp := tmp ^ Titov ;
1850: LD_ADDR_VAR 0 5
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 42
1864: ADD
1865: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1866: LD_ADDR_EXP 43
1870: PUSH
1871: LD_STRING Fadeev
1873: PPUSH
1874: LD_EXP 1
1878: NOT
1879: PPUSH
1880: LD_STRING 13a_
1882: PPUSH
1883: CALL 53728 0 3
1887: ST_TO_ADDR
// if Fadeev then
1888: LD_EXP 43
1892: IFFALSE 1910
// tmp := tmp ^ Fadeev ;
1894: LD_ADDR_VAR 0 5
1898: PUSH
1899: LD_VAR 0 5
1903: PUSH
1904: LD_EXP 43
1908: ADD
1909: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1910: LD_ADDR_EXP 44
1914: PUSH
1915: LD_STRING Dolgov
1917: PPUSH
1918: LD_EXP 1
1922: NOT
1923: PPUSH
1924: LD_STRING 13a_
1926: PPUSH
1927: CALL 53728 0 3
1931: ST_TO_ADDR
// if Dolgov then
1932: LD_EXP 44
1936: IFFALSE 1954
// tmp := tmp ^ Dolgov ;
1938: LD_ADDR_VAR 0 5
1942: PUSH
1943: LD_VAR 0 5
1947: PUSH
1948: LD_EXP 44
1952: ADD
1953: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1954: LD_ADDR_EXP 45
1958: PUSH
1959: LD_STRING Petrosyan
1961: PPUSH
1962: LD_EXP 1
1966: NOT
1967: PPUSH
1968: LD_STRING 13a_
1970: PPUSH
1971: CALL 53728 0 3
1975: ST_TO_ADDR
// if Petrosyan then
1976: LD_EXP 45
1980: IFFALSE 1998
// tmp := tmp ^ Petrosyan ;
1982: LD_ADDR_VAR 0 5
1986: PUSH
1987: LD_VAR 0 5
1991: PUSH
1992: LD_EXP 45
1996: ADD
1997: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1998: LD_ADDR_EXP 46
2002: PUSH
2003: LD_STRING Scholtze
2005: PPUSH
2006: LD_EXP 1
2010: NOT
2011: PPUSH
2012: LD_STRING 13a_
2014: PPUSH
2015: CALL 53728 0 3
2019: ST_TO_ADDR
// if Scholtze then
2020: LD_EXP 46
2024: IFFALSE 2042
// tmp := tmp ^ Scholtze ;
2026: LD_ADDR_VAR 0 5
2030: PUSH
2031: LD_VAR 0 5
2035: PUSH
2036: LD_EXP 46
2040: ADD
2041: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2042: LD_ADDR_EXP 47
2046: PUSH
2047: LD_STRING Oblukov
2049: PPUSH
2050: LD_EXP 1
2054: NOT
2055: PPUSH
2056: LD_STRING 13a_
2058: PPUSH
2059: CALL 53728 0 3
2063: ST_TO_ADDR
// if Oblukov then
2064: LD_EXP 47
2068: IFFALSE 2086
// tmp := tmp ^ Oblukov ;
2070: LD_ADDR_VAR 0 5
2074: PUSH
2075: LD_VAR 0 5
2079: PUSH
2080: LD_EXP 47
2084: ADD
2085: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2086: LD_ADDR_EXP 48
2090: PUSH
2091: LD_STRING Kapitsova
2093: PPUSH
2094: LD_EXP 1
2098: NOT
2099: PPUSH
2100: LD_STRING 13a_
2102: PPUSH
2103: CALL 53728 0 3
2107: ST_TO_ADDR
// if Kapitsova then
2108: LD_EXP 48
2112: IFFALSE 2130
// tmp := tmp ^ Kapitsova ;
2114: LD_ADDR_VAR 0 5
2118: PUSH
2119: LD_VAR 0 5
2123: PUSH
2124: LD_EXP 48
2128: ADD
2129: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2130: LD_ADDR_EXP 49
2134: PUSH
2135: LD_STRING Lipshchin
2137: PPUSH
2138: LD_EXP 1
2142: NOT
2143: PPUSH
2144: LD_STRING 13a_
2146: PPUSH
2147: CALL 53728 0 3
2151: ST_TO_ADDR
// if Lipshchin then
2152: LD_EXP 49
2156: IFFALSE 2174
// tmp := tmp ^ Lipshchin ;
2158: LD_ADDR_VAR 0 5
2162: PUSH
2163: LD_VAR 0 5
2167: PUSH
2168: LD_EXP 49
2172: ADD
2173: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2174: LD_ADDR_EXP 50
2178: PUSH
2179: LD_STRING Petrovova
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13a_
2190: PPUSH
2191: CALL 53728 0 3
2195: ST_TO_ADDR
// if Petrovova then
2196: LD_EXP 50
2200: IFFALSE 2218
// tmp := tmp ^ Petrovova ;
2202: LD_ADDR_VAR 0 5
2206: PUSH
2207: LD_VAR 0 5
2211: PUSH
2212: LD_EXP 50
2216: ADD
2217: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2218: LD_ADDR_EXP 51
2222: PUSH
2223: LD_STRING Kovalyuk
2225: PPUSH
2226: LD_EXP 1
2230: NOT
2231: PPUSH
2232: LD_STRING 13a_
2234: PPUSH
2235: CALL 53728 0 3
2239: ST_TO_ADDR
// if Kovalyuk then
2240: LD_EXP 51
2244: IFFALSE 2262
// tmp := tmp ^ Kovalyuk ;
2246: LD_ADDR_VAR 0 5
2250: PUSH
2251: LD_VAR 0 5
2255: PUSH
2256: LD_EXP 51
2260: ADD
2261: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2262: LD_ADDR_EXP 52
2266: PUSH
2267: LD_STRING Kuzmov
2269: PPUSH
2270: LD_EXP 1
2274: NOT
2275: PPUSH
2276: LD_STRING 13a_
2278: PPUSH
2279: CALL 53728 0 3
2283: ST_TO_ADDR
// if Kuzmov then
2284: LD_EXP 52
2288: IFFALSE 2306
// tmp := tmp ^ Kuzmov ;
2290: LD_ADDR_VAR 0 5
2294: PUSH
2295: LD_VAR 0 5
2299: PUSH
2300: LD_EXP 52
2304: ADD
2305: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2306: LD_ADDR_EXP 53
2310: PUSH
2311: LD_STRING Karamazov
2313: PPUSH
2314: LD_EXP 1
2318: NOT
2319: PPUSH
2320: LD_STRING 13a_
2322: PPUSH
2323: CALL 53728 0 3
2327: ST_TO_ADDR
// if Karamazov then
2328: LD_EXP 53
2332: IFFALSE 2350
// tmp := tmp ^ Karamazov ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 5
2343: PUSH
2344: LD_EXP 53
2348: ADD
2349: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2350: LD_ADDR_EXP 55
2354: PUSH
2355: LD_STRING Belkov
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13a_
2366: PPUSH
2367: CALL 53728 0 3
2371: ST_TO_ADDR
// if Belkov then
2372: LD_EXP 55
2376: IFFALSE 2394
// tmp := tmp ^ Belkov ;
2378: LD_ADDR_VAR 0 5
2382: PUSH
2383: LD_VAR 0 5
2387: PUSH
2388: LD_EXP 55
2392: ADD
2393: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2394: LD_ADDR_EXP 56
2398: PUSH
2399: LD_STRING Gnyevko
2401: PPUSH
2402: LD_EXP 1
2406: NOT
2407: PPUSH
2408: LD_STRING 13a_
2410: PPUSH
2411: CALL 53728 0 3
2415: ST_TO_ADDR
// if Gnyevko then
2416: LD_EXP 56
2420: IFFALSE 2438
// tmp := tmp ^ Gnyevko ;
2422: LD_ADDR_VAR 0 5
2426: PUSH
2427: LD_VAR 0 5
2431: PUSH
2432: LD_EXP 56
2436: ADD
2437: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2438: LD_ADDR_EXP 38
2442: PUSH
2443: LD_STRING Coonie
2445: PPUSH
2446: CALL_OW 25
2450: ST_TO_ADDR
// if not Lisa then
2451: LD_EXP 23
2455: NOT
2456: IFFALSE 2502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2458: LD_ADDR_EXP 23
2462: PUSH
2463: LD_STRING Lisa
2465: PPUSH
2466: LD_EXP 1
2470: NOT
2471: PPUSH
2472: LD_STRING 13a_
2474: PPUSH
2475: CALL 53728 0 3
2479: ST_TO_ADDR
// if Lisa then
2480: LD_EXP 23
2484: IFFALSE 2502
// tmp := tmp ^ Lisa ;
2486: LD_ADDR_VAR 0 5
2490: PUSH
2491: LD_VAR 0 5
2495: PUSH
2496: LD_EXP 23
2500: ADD
2501: ST_TO_ADDR
// end ; if not Donaldson then
2502: LD_EXP 24
2506: NOT
2507: IFFALSE 2553
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2509: LD_ADDR_EXP 24
2513: PUSH
2514: LD_STRING Donaldson
2516: PPUSH
2517: LD_EXP 1
2521: NOT
2522: PPUSH
2523: LD_STRING 13a_
2525: PPUSH
2526: CALL 53728 0 3
2530: ST_TO_ADDR
// if Donaldson then
2531: LD_EXP 24
2535: IFFALSE 2553
// tmp := tmp ^ Donaldson ;
2537: LD_ADDR_VAR 0 5
2541: PUSH
2542: LD_VAR 0 5
2546: PUSH
2547: LD_EXP 24
2551: ADD
2552: ST_TO_ADDR
// end ; if not Bobby then
2553: LD_EXP 25
2557: NOT
2558: IFFALSE 2604
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2560: LD_ADDR_EXP 25
2564: PUSH
2565: LD_STRING Bobby
2567: PPUSH
2568: LD_EXP 1
2572: NOT
2573: PPUSH
2574: LD_STRING 13a_
2576: PPUSH
2577: CALL 53728 0 3
2581: ST_TO_ADDR
// if Bobby then
2582: LD_EXP 25
2586: IFFALSE 2604
// tmp := tmp ^ Bobby ;
2588: LD_ADDR_VAR 0 5
2592: PUSH
2593: LD_VAR 0 5
2597: PUSH
2598: LD_EXP 25
2602: ADD
2603: ST_TO_ADDR
// end ; if not Cyrus then
2604: LD_EXP 26
2608: NOT
2609: IFFALSE 2655
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2611: LD_ADDR_EXP 26
2615: PUSH
2616: LD_STRING Cyrus
2618: PPUSH
2619: LD_EXP 1
2623: NOT
2624: PPUSH
2625: LD_STRING 13a_
2627: PPUSH
2628: CALL 53728 0 3
2632: ST_TO_ADDR
// if Cyrus then
2633: LD_EXP 26
2637: IFFALSE 2655
// tmp := tmp ^ Cyrus ;
2639: LD_ADDR_VAR 0 5
2643: PUSH
2644: LD_VAR 0 5
2648: PUSH
2649: LD_EXP 26
2653: ADD
2654: ST_TO_ADDR
// end ; if not Brown then
2655: LD_EXP 28
2659: NOT
2660: IFFALSE 2706
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2662: LD_ADDR_EXP 28
2666: PUSH
2667: LD_STRING Brown
2669: PPUSH
2670: LD_EXP 1
2674: NOT
2675: PPUSH
2676: LD_STRING 13a_
2678: PPUSH
2679: CALL 53728 0 3
2683: ST_TO_ADDR
// if Brown then
2684: LD_EXP 28
2688: IFFALSE 2706
// tmp := tmp ^ Brown ;
2690: LD_ADDR_VAR 0 5
2694: PUSH
2695: LD_VAR 0 5
2699: PUSH
2700: LD_EXP 28
2704: ADD
2705: ST_TO_ADDR
// end ; if not Gladstone then
2706: LD_EXP 29
2710: NOT
2711: IFFALSE 2757
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2713: LD_ADDR_EXP 29
2717: PUSH
2718: LD_STRING Gladstone
2720: PPUSH
2721: LD_EXP 1
2725: NOT
2726: PPUSH
2727: LD_STRING 13a_
2729: PPUSH
2730: CALL 53728 0 3
2734: ST_TO_ADDR
// if Gladstone then
2735: LD_EXP 29
2739: IFFALSE 2757
// tmp := tmp ^ Gladstone ;
2741: LD_ADDR_VAR 0 5
2745: PUSH
2746: LD_VAR 0 5
2750: PUSH
2751: LD_EXP 29
2755: ADD
2756: ST_TO_ADDR
// end ; if not Cornel then
2757: LD_EXP 31
2761: NOT
2762: IFFALSE 2808
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2764: LD_ADDR_EXP 31
2768: PUSH
2769: LD_STRING Cornel
2771: PPUSH
2772: LD_EXP 1
2776: NOT
2777: PPUSH
2778: LD_STRING 13a_
2780: PPUSH
2781: CALL 53728 0 3
2785: ST_TO_ADDR
// if Cornel then
2786: LD_EXP 31
2790: IFFALSE 2808
// tmp := tmp ^ Cornel ;
2792: LD_ADDR_VAR 0 5
2796: PUSH
2797: LD_VAR 0 5
2801: PUSH
2802: LD_EXP 31
2806: ADD
2807: ST_TO_ADDR
// end ; if not Houten then
2808: LD_EXP 30
2812: NOT
2813: IFFALSE 2859
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2815: LD_ADDR_EXP 30
2819: PUSH
2820: LD_STRING Houten
2822: PPUSH
2823: LD_EXP 1
2827: NOT
2828: PPUSH
2829: LD_STRING 13a_
2831: PPUSH
2832: CALL 53728 0 3
2836: ST_TO_ADDR
// if Houten then
2837: LD_EXP 30
2841: IFFALSE 2859
// tmp := tmp ^ Houten ;
2843: LD_ADDR_VAR 0 5
2847: PUSH
2848: LD_VAR 0 5
2852: PUSH
2853: LD_EXP 30
2857: ADD
2858: ST_TO_ADDR
// end ; if not Gary then
2859: LD_EXP 32
2863: NOT
2864: IFFALSE 2910
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2866: LD_ADDR_EXP 32
2870: PUSH
2871: LD_STRING Gary
2873: PPUSH
2874: LD_EXP 1
2878: NOT
2879: PPUSH
2880: LD_STRING 13a_
2882: PPUSH
2883: CALL 53728 0 3
2887: ST_TO_ADDR
// if Gary then
2888: LD_EXP 32
2892: IFFALSE 2910
// tmp := tmp ^ Gary ;
2894: LD_ADDR_VAR 0 5
2898: PUSH
2899: LD_VAR 0 5
2903: PUSH
2904: LD_EXP 32
2908: ADD
2909: ST_TO_ADDR
// end ; if not Kikuchi then
2910: LD_EXP 34
2914: NOT
2915: IFFALSE 2961
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2917: LD_ADDR_EXP 34
2921: PUSH
2922: LD_STRING Kikuchi
2924: PPUSH
2925: LD_EXP 1
2929: NOT
2930: PPUSH
2931: LD_STRING 13a_
2933: PPUSH
2934: CALL 53728 0 3
2938: ST_TO_ADDR
// if Kikuchi then
2939: LD_EXP 34
2943: IFFALSE 2961
// tmp := tmp ^ Kikuchi ;
2945: LD_ADDR_VAR 0 5
2949: PUSH
2950: LD_VAR 0 5
2954: PUSH
2955: LD_EXP 34
2959: ADD
2960: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2961: LD_ADDR_VAR 0 5
2965: PUSH
2966: LD_VAR 0 5
2970: PUSH
2971: LD_STRING 13a_others
2973: PPUSH
2974: CALL_OW 31
2978: UNION
2979: ST_TO_ADDR
// tmp := tmp diff 0 ;
2980: LD_ADDR_VAR 0 5
2984: PUSH
2985: LD_VAR 0 5
2989: PUSH
2990: LD_INT 0
2992: DIFF
2993: ST_TO_ADDR
// if tmp < 15 then
2994: LD_VAR 0 5
2998: PUSH
2999: LD_INT 15
3001: LESS
3002: IFFALSE 3090
// for i = 15 downto tmp do
3004: LD_ADDR_VAR 0 2
3008: PUSH
3009: DOUBLE
3010: LD_INT 15
3012: INC
3013: ST_TO_ADDR
3014: LD_VAR 0 5
3018: PUSH
3019: FOR_DOWNTO
3020: IFFALSE 3088
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
3022: LD_ADDR_OWVAR 21
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 1
3039: PPUSH
3040: LD_INT 2
3042: PPUSH
3043: CALL_OW 12
3047: ARRAY
3048: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3049: LD_INT 0
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: LD_INT 4
3057: PPUSH
3058: CALL_OW 12
3062: PPUSH
3063: LD_INT 8
3065: PPUSH
3066: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3070: LD_ADDR_VAR 0 5
3074: PUSH
3075: LD_VAR 0 5
3079: PUSH
3080: CALL_OW 44
3084: ADD
3085: ST_TO_ADDR
// end ;
3086: GO 3019
3088: POP
3089: POP
// if not debug then
3090: LD_EXP 1
3094: NOT
3095: IFFALSE 3275
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3097: LD_ADDR_VAR 0 4
3101: PUSH
3102: LD_STRING 
3104: PPUSH
3105: LD_INT 14
3107: PUSH
3108: LD_INT 13
3110: PUSH
3111: LD_INT 12
3113: PUSH
3114: LD_INT 11
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_OWVAR 67
3127: ARRAY
3128: PPUSH
3129: LD_INT 14
3131: PUSH
3132: LD_INT 13
3134: PUSH
3135: LD_INT 12
3137: PUSH
3138: LD_INT 11
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: PUSH
3147: LD_OWVAR 67
3151: ARRAY
3152: PPUSH
3153: LD_INT -5
3155: PUSH
3156: LD_EXP 21
3160: PUSH
3161: LD_EXP 54
3165: PUSH
3166: LD_EXP 22
3170: PUSH
3171: LD_EXP 36
3175: PUSH
3176: LD_EXP 27
3180: PUSH
3181: LD_EXP 40
3185: PUSH
3186: LD_INT -2
3188: PUSH
3189: LD_INT -3
3191: PUSH
3192: LD_INT -5
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: LIST
3203: LIST
3204: LIST
3205: LIST
3206: PUSH
3207: LD_VAR 0 5
3211: ADD
3212: PPUSH
3213: LD_INT 1
3215: PUSH
3216: LD_INT 4
3218: PUSH
3219: LD_INT 2
3221: PUSH
3222: LD_INT 1
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: PUSH
3229: LD_INT 3
3231: PUSH
3232: LD_INT 5
3234: PUSH
3235: LD_INT 0
3237: PUSH
3238: LD_INT 3
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: LIST
3245: PUSH
3246: LD_INT 9
3248: PUSH
3249: LD_INT 0
3251: PUSH
3252: LD_INT 3
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: LIST
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: PPUSH
3268: CALL_OW 42
3272: ST_TO_ADDR
3273: GO 3324
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3275: LD_ADDR_VAR 0 4
3279: PUSH
3280: LD_EXP 42
3284: PUSH
3285: LD_EXP 43
3289: PUSH
3290: LD_EXP 44
3294: PUSH
3295: LD_EXP 45
3299: PUSH
3300: LD_EXP 46
3304: PUSH
3305: LD_EXP 47
3309: PUSH
3310: LD_EXP 48
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: LIST
3319: LIST
3320: LIST
3321: LIST
3322: LIST
3323: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3324: LD_ADDR_EXP 17
3328: PUSH
3329: LD_VAR 0 5
3333: PUSH
3334: LD_VAR 0 4
3338: DIFF
3339: ST_TO_ADDR
// uc_nation := 1 ;
3340: LD_ADDR_OWVAR 21
3344: PUSH
3345: LD_INT 1
3347: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3348: LD_INT 5
3350: PPUSH
3351: LD_INT 3
3353: PPUSH
3354: LD_INT 1
3356: PPUSH
3357: LD_INT 6
3359: PPUSH
3360: LD_INT 100
3362: PPUSH
3363: CALL 58652 0 5
// veh := CreateVehicle ;
3367: LD_ADDR_VAR 0 3
3371: PUSH
3372: CALL_OW 45
3376: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3377: LD_VAR 0 3
3381: PPUSH
3382: LD_INT 7
3384: NEG
3385: PPUSH
3386: CALL_OW 242
// SetDir ( veh , 3 ) ;
3390: LD_VAR 0 3
3394: PPUSH
3395: LD_INT 3
3397: PPUSH
3398: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3402: LD_VAR 0 3
3406: PPUSH
3407: LD_INT 31
3409: PPUSH
3410: LD_INT 0
3412: PPUSH
3413: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3417: LD_EXP 21
3421: PPUSH
3422: LD_VAR 0 3
3426: PPUSH
3427: CALL_OW 52
// if Joan then
3431: LD_EXP 36
3435: IFFALSE 3507
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3437: LD_INT 3
3439: PPUSH
3440: LD_INT 3
3442: PPUSH
3443: LD_INT 1
3445: PPUSH
3446: LD_INT 11
3448: PPUSH
3449: LD_INT 100
3451: PPUSH
3452: CALL 58652 0 5
// veh := CreateVehicle ;
3456: LD_ADDR_VAR 0 3
3460: PUSH
3461: CALL_OW 45
3465: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3466: LD_VAR 0 3
3470: PPUSH
3471: LD_INT 3
3473: PPUSH
3474: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3478: LD_VAR 0 3
3482: PPUSH
3483: LD_INT 30
3485: PPUSH
3486: LD_INT 0
3488: PPUSH
3489: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3493: LD_EXP 36
3497: PPUSH
3498: LD_VAR 0 3
3502: PPUSH
3503: CALL_OW 52
// end ; if Roth then
3507: LD_EXP 22
3511: IFFALSE 3583
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 1
3521: PPUSH
3522: LD_INT 11
3524: PPUSH
3525: LD_INT 100
3527: PPUSH
3528: CALL 58652 0 5
// veh := CreateVehicle ;
3532: LD_ADDR_VAR 0 3
3536: PUSH
3537: CALL_OW 45
3541: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3542: LD_VAR 0 3
3546: PPUSH
3547: LD_INT 3
3549: PPUSH
3550: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3554: LD_VAR 0 3
3558: PPUSH
3559: LD_INT 30
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3569: LD_EXP 22
3573: PPUSH
3574: LD_VAR 0 3
3578: PPUSH
3579: CALL_OW 52
// end ; if Denis then
3583: LD_EXP 27
3587: IFFALSE 3659
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3589: LD_INT 5
3591: PPUSH
3592: LD_INT 3
3594: PPUSH
3595: LD_INT 1
3597: PPUSH
3598: LD_INT 9
3600: PPUSH
3601: LD_INT 100
3603: PPUSH
3604: CALL 58652 0 5
// veh := CreateVehicle ;
3608: LD_ADDR_VAR 0 3
3612: PUSH
3613: CALL_OW 45
3617: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3618: LD_VAR 0 3
3622: PPUSH
3623: LD_INT 3
3625: PPUSH
3626: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3630: LD_VAR 0 3
3634: PPUSH
3635: LD_INT 30
3637: PPUSH
3638: LD_INT 0
3640: PPUSH
3641: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3645: LD_EXP 27
3649: PPUSH
3650: LD_VAR 0 3
3654: PPUSH
3655: CALL_OW 52
// end ; uc_nation := 3 ;
3659: LD_ADDR_OWVAR 21
3663: PUSH
3664: LD_INT 3
3666: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3667: LD_INT 22
3669: PPUSH
3670: LD_INT 3
3672: PPUSH
3673: LD_INT 1
3675: PPUSH
3676: LD_INT 45
3678: PPUSH
3679: LD_INT 100
3681: PPUSH
3682: CALL 58652 0 5
// veh := CreateVehicle ;
3686: LD_ADDR_VAR 0 3
3690: PUSH
3691: CALL_OW 45
3695: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3696: LD_VAR 0 3
3700: PPUSH
3701: LD_INT 7
3703: NEG
3704: PPUSH
3705: CALL_OW 242
// SetDir ( veh , 3 ) ;
3709: LD_VAR 0 3
3713: PPUSH
3714: LD_INT 3
3716: PPUSH
3717: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3721: LD_VAR 0 3
3725: PPUSH
3726: LD_INT 31
3728: PPUSH
3729: LD_INT 0
3731: PPUSH
3732: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3736: LD_EXP 54
3740: PPUSH
3741: LD_VAR 0 3
3745: PPUSH
3746: CALL_OW 52
// if Gossudarov then
3750: LD_EXP 40
3754: IFFALSE 3841
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3756: LD_INT 22
3758: PPUSH
3759: LD_INT 3
3761: PPUSH
3762: LD_INT 1
3764: PPUSH
3765: LD_INT 51
3767: PPUSH
3768: LD_INT 100
3770: PPUSH
3771: CALL 58652 0 5
// veh := CreateVehicle ;
3775: LD_ADDR_VAR 0 3
3779: PUSH
3780: CALL_OW 45
3784: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3785: LD_VAR 0 3
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3797: LD_VAR 0 3
3801: PPUSH
3802: LD_INT 30
3804: PPUSH
3805: LD_INT 0
3807: PPUSH
3808: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3812: LD_EXP 40
3816: PPUSH
3817: LD_VAR 0 3
3821: PPUSH
3822: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3826: LD_VAR 0 3
3830: PPUSH
3831: LD_INT 1
3833: PPUSH
3834: LD_INT 100
3836: PPUSH
3837: CALL_OW 290
// end ; if Mike then
3841: LD_EXP 39
3845: IFFALSE 3862
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3847: LD_EXP 39
3851: PPUSH
3852: LD_INT 30
3854: PPUSH
3855: LD_INT 0
3857: PPUSH
3858: CALL_OW 49
// for i in selected do
3862: LD_ADDR_VAR 0 2
3866: PUSH
3867: LD_VAR 0 4
3871: PUSH
3872: FOR_IN
3873: IFFALSE 4431
// begin uc_nation := GetNation ( i ) ;
3875: LD_ADDR_OWVAR 21
3879: PUSH
3880: LD_VAR 0 2
3884: PPUSH
3885: CALL_OW 248
3889: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3890: LD_VAR 0 2
3894: PUSH
3895: LD_EXP 23
3899: PUSH
3900: LD_EXP 24
3904: PUSH
3905: LD_EXP 26
3909: PUSH
3910: LD_EXP 25
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: LIST
3919: LIST
3920: IN
3921: IFFALSE 3944
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3923: LD_INT 5
3925: PPUSH
3926: LD_INT 3
3928: PPUSH
3929: LD_INT 1
3931: PPUSH
3932: LD_INT 6
3934: PPUSH
3935: LD_INT 100
3937: PPUSH
3938: CALL 58652 0 5
3942: GO 4378
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3944: LD_VAR 0 2
3948: PUSH
3949: LD_EXP 47
3953: PUSH
3954: LD_EXP 52
3958: PUSH
3959: LD_EXP 50
3963: PUSH
3964: LD_EXP 42
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: LIST
3973: LIST
3974: IN
3975: IFFALSE 4006
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3977: LD_INT 24
3979: PPUSH
3980: LD_INT 1
3982: PPUSH
3983: LD_INT 1
3985: PPUSH
3986: LD_INT 46
3988: PPUSH
3989: LD_INT 65
3991: PPUSH
3992: LD_INT 75
3994: PPUSH
3995: CALL_OW 12
3999: PPUSH
4000: CALL 58652 0 5
4004: GO 4378
// if i = Karamazov then
4006: LD_VAR 0 2
4010: PUSH
4011: LD_EXP 53
4015: EQUAL
4016: IFFALSE 4039
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
4018: LD_INT 22
4020: PPUSH
4021: LD_INT 3
4023: PPUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 52
4029: PPUSH
4030: LD_INT 100
4032: PPUSH
4033: CALL 58652 0 5
4037: GO 4378
// if i = Brown then
4039: LD_VAR 0 2
4043: PUSH
4044: LD_EXP 28
4048: EQUAL
4049: IFFALSE 4072
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 3
4056: PPUSH
4057: LD_INT 1
4059: PPUSH
4060: LD_INT 13
4062: PPUSH
4063: LD_INT 100
4065: PPUSH
4066: CALL 58652 0 5
4070: GO 4378
// if uc_nation = nation_american then
4072: LD_OWVAR 21
4076: PUSH
4077: LD_INT 1
4079: EQUAL
4080: IFFALSE 4231
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4082: LD_INT 3
4084: PUSH
4085: LD_INT 5
4087: PUSH
4088: LD_INT 5
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: LIST
4095: PUSH
4096: LD_OWVAR 21
4100: PUSH
4101: LD_INT 3
4103: MOD
4104: PUSH
4105: LD_INT 1
4107: PLUS
4108: ARRAY
4109: PPUSH
4110: LD_INT 1
4112: PUSH
4113: LD_INT 3
4115: PUSH
4116: LD_INT 1
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: LIST
4123: PUSH
4124: LD_OWVAR 21
4128: PUSH
4129: LD_INT 3
4131: MOD
4132: PUSH
4133: LD_INT 1
4135: PLUS
4136: ARRAY
4137: PPUSH
4138: LD_INT 1
4140: PPUSH
4141: LD_INT 11
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: LD_INT 5
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: LIST
4154: PUSH
4155: LD_INT 6
4157: PUSH
4158: LD_INT 7
4160: PUSH
4161: LD_INT 9
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: LIST
4168: PUSH
4169: LD_INT 6
4171: PUSH
4172: LD_INT 9
4174: PUSH
4175: LD_INT 12
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: LIST
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: LIST
4187: PUSH
4188: LD_OWVAR 21
4192: PUSH
4193: LD_INT 3
4195: MOD
4196: PUSH
4197: LD_INT 1
4199: PLUS
4200: ARRAY
4201: PUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 3
4207: PPUSH
4208: CALL_OW 12
4212: ARRAY
4213: PPUSH
4214: LD_INT 65
4216: PPUSH
4217: LD_INT 75
4219: PPUSH
4220: CALL_OW 12
4224: PPUSH
4225: CALL 58652 0 5
// end else
4229: GO 4378
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4231: LD_INT 22
4233: PUSH
4234: LD_INT 23
4236: PUSH
4237: LD_INT 23
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: PUSH
4245: LD_OWVAR 21
4249: PUSH
4250: LD_INT 3
4252: MOD
4253: PUSH
4254: LD_INT 1
4256: PLUS
4257: ARRAY
4258: PPUSH
4259: LD_INT 1
4261: PUSH
4262: LD_INT 3
4264: PUSH
4265: LD_INT 1
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: LIST
4272: PUSH
4273: LD_OWVAR 21
4277: PUSH
4278: LD_INT 3
4280: MOD
4281: PUSH
4282: LD_INT 1
4284: PLUS
4285: ARRAY
4286: PPUSH
4287: LD_INT 1
4289: PPUSH
4290: LD_INT 45
4292: PUSH
4293: LD_INT 43
4295: PUSH
4296: LD_INT 44
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 46
4306: PUSH
4307: LD_INT 45
4309: PUSH
4310: LD_INT 44
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: PUSH
4318: LD_INT 46
4320: PUSH
4321: LD_INT 43
4323: PUSH
4324: LD_INT 45
4326: PUSH
4327: EMPTY
4328: LIST
4329: LIST
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: LIST
4336: PUSH
4337: LD_OWVAR 21
4341: PUSH
4342: LD_INT 3
4344: MOD
4345: PUSH
4346: LD_INT 1
4348: PLUS
4349: ARRAY
4350: PUSH
4351: LD_INT 1
4353: PPUSH
4354: LD_INT 3
4356: PPUSH
4357: CALL_OW 12
4361: ARRAY
4362: PPUSH
4363: LD_INT 65
4365: PPUSH
4366: LD_INT 75
4368: PPUSH
4369: CALL_OW 12
4373: PPUSH
4374: CALL 58652 0 5
// end ; veh := CreateVehicle ;
4378: LD_ADDR_VAR 0 3
4382: PUSH
4383: CALL_OW 45
4387: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4388: LD_VAR 0 3
4392: PPUSH
4393: LD_INT 3
4395: PPUSH
4396: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4400: LD_VAR 0 3
4404: PPUSH
4405: LD_INT 30
4407: PPUSH
4408: LD_INT 0
4410: PPUSH
4411: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4415: LD_VAR 0 2
4419: PPUSH
4420: LD_VAR 0 3
4424: PPUSH
4425: CALL_OW 52
// end ;
4429: GO 3872
4431: POP
4432: POP
// if artifactArCaptured then
4433: LD_EXP 9
4437: IFFALSE 4523
// begin uc_nation := nation_american ;
4439: LD_ADDR_OWVAR 21
4443: PUSH
4444: LD_INT 1
4446: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4447: LD_INT 3
4449: PPUSH
4450: LD_INT 3
4452: PPUSH
4453: LD_INT 3
4455: PPUSH
4456: LD_INT 12
4458: PPUSH
4459: LD_INT 100
4461: PPUSH
4462: CALL 58652 0 5
// veh := CreateVehicle ;
4466: LD_ADDR_VAR 0 3
4470: PUSH
4471: CALL_OW 45
4475: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4476: LD_VAR 0 3
4480: PPUSH
4481: LD_INT 3
4483: PPUSH
4484: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4488: LD_VAR 0 3
4492: PPUSH
4493: LD_INT 198
4495: PPUSH
4496: LD_INT 22
4498: PPUSH
4499: LD_INT 0
4501: PPUSH
4502: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4506: LD_VAR 0 3
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: LD_INT 50
4516: PPUSH
4517: CALL_OW 290
// end else
4521: GO 4542
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4523: LD_INT 4
4525: PPUSH
4526: LD_INT 5
4528: PPUSH
4529: LD_INT 267
4531: PPUSH
4532: LD_INT 226
4534: PPUSH
4535: LD_INT 0
4537: PPUSH
4538: CALL_OW 58
// end ; uc_nation := nation_american ;
4542: LD_ADDR_OWVAR 21
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4550: LD_INT 3
4552: PPUSH
4553: LD_INT 3
4555: PPUSH
4556: LD_INT 3
4558: PPUSH
4559: LD_INT 12
4561: PPUSH
4562: LD_INT 100
4564: PPUSH
4565: CALL 58652 0 5
// veh := CreateVehicle ;
4569: LD_ADDR_VAR 0 3
4573: PUSH
4574: CALL_OW 45
4578: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4579: LD_VAR 0 3
4583: PPUSH
4584: LD_INT 3
4586: PPUSH
4587: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4591: LD_VAR 0 3
4595: PPUSH
4596: LD_INT 218
4598: PPUSH
4599: LD_INT 23
4601: PPUSH
4602: LD_INT 0
4604: PPUSH
4605: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4609: LD_VAR 0 3
4613: PPUSH
4614: LD_INT 4
4616: PPUSH
4617: LD_INT 30
4619: PPUSH
4620: CALL_OW 290
// uc_nation := nation_russian ;
4624: LD_ADDR_OWVAR 21
4628: PUSH
4629: LD_INT 3
4631: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4632: LD_INT 22
4634: PPUSH
4635: LD_INT 3
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 51
4643: PPUSH
4644: LD_INT 100
4646: PPUSH
4647: CALL 58652 0 5
// veh := CreateVehicle ;
4651: LD_ADDR_VAR 0 3
4655: PUSH
4656: CALL_OW 45
4660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4661: LD_VAR 0 3
4665: PPUSH
4666: LD_INT 3
4668: PPUSH
4669: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4673: LD_VAR 0 3
4677: PPUSH
4678: LD_INT 214
4680: PPUSH
4681: LD_INT 20
4683: PPUSH
4684: LD_INT 0
4686: PPUSH
4687: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4691: LD_VAR 0 3
4695: PPUSH
4696: LD_INT 4
4698: PPUSH
4699: LD_INT 40
4701: PPUSH
4702: CALL_OW 290
// end ;
4706: LD_VAR 0 1
4710: RET
// export function AllianceSupport ; var i , veh ; begin
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
// if not allianceTeam then
4716: LD_EXP 17
4720: NOT
4721: IFFALSE 4725
// exit ;
4723: GO 5131
// for i := 1 to 6 do
4725: LD_ADDR_VAR 0 2
4729: PUSH
4730: DOUBLE
4731: LD_INT 1
4733: DEC
4734: ST_TO_ADDR
4735: LD_INT 6
4737: PUSH
4738: FOR_TO
4739: IFFALSE 5035
// begin uc_side := 7 ;
4741: LD_ADDR_OWVAR 20
4745: PUSH
4746: LD_INT 7
4748: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4749: LD_ADDR_OWVAR 21
4753: PUSH
4754: LD_INT 1
4756: PUSH
4757: LD_INT 3
4759: PUSH
4760: EMPTY
4761: LIST
4762: LIST
4763: PUSH
4764: LD_VAR 0 2
4768: PUSH
4769: LD_INT 2
4771: MOD
4772: PUSH
4773: LD_INT 1
4775: PLUS
4776: ARRAY
4777: ST_TO_ADDR
// if uc_nation = 1 then
4778: LD_OWVAR 21
4782: PUSH
4783: LD_INT 1
4785: EQUAL
4786: IFFALSE 4828
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4788: LD_INT 5
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 6
4799: PUSH
4800: LD_INT 7
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: PUSH
4807: LD_INT 1
4809: PPUSH
4810: LD_INT 2
4812: PPUSH
4813: CALL_OW 12
4817: ARRAY
4818: PPUSH
4819: LD_INT 100
4821: PPUSH
4822: CALL 58652 0 5
4826: GO 4866
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4828: LD_INT 23
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 46
4839: PUSH
4840: LD_INT 47
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: LD_INT 1
4849: PPUSH
4850: LD_INT 2
4852: PPUSH
4853: CALL_OW 12
4857: ARRAY
4858: PPUSH
4859: LD_INT 100
4861: PPUSH
4862: CALL 58652 0 5
// if not allianceTeam then
4866: LD_EXP 17
4870: NOT
4871: IFFALSE 4875
// break ;
4873: GO 5035
// veh := CreateVehicle ;
4875: LD_ADDR_VAR 0 3
4879: PUSH
4880: CALL_OW 45
4884: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4885: LD_VAR 0 3
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4897: LD_VAR 0 3
4901: PPUSH
4902: LD_INT 38
4904: PPUSH
4905: LD_INT 0
4907: PPUSH
4908: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4912: LD_EXP 17
4916: PUSH
4917: LD_INT 1
4919: ARRAY
4920: PPUSH
4921: LD_INT 3
4923: PPUSH
4924: CALL_OW 259
4928: PUSH
4929: LD_INT 4
4931: GREATER
4932: IFFALSE 4950
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4934: LD_EXP 17
4938: PUSH
4939: LD_INT 1
4941: ARRAY
4942: PPUSH
4943: LD_INT 3
4945: PPUSH
4946: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4950: LD_EXP 17
4954: PUSH
4955: LD_INT 1
4957: ARRAY
4958: PPUSH
4959: LD_INT 4
4961: PPUSH
4962: CALL_OW 259
4966: PUSH
4967: LD_INT 8
4969: GREATER
4970: IFFALSE 4988
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4972: LD_EXP 17
4976: PUSH
4977: LD_INT 1
4979: ARRAY
4980: PPUSH
4981: LD_INT 4
4983: PPUSH
4984: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4988: LD_EXP 17
4992: PUSH
4993: LD_INT 1
4995: ARRAY
4996: PPUSH
4997: LD_VAR 0 3
5001: PPUSH
5002: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
5006: LD_ADDR_EXP 17
5010: PUSH
5011: LD_EXP 17
5015: PPUSH
5016: LD_INT 1
5018: PPUSH
5019: CALL_OW 3
5023: ST_TO_ADDR
// ComHold ( veh ) ;
5024: LD_VAR 0 3
5028: PPUSH
5029: CALL_OW 140
// end ;
5033: GO 4738
5035: POP
5036: POP
// uc_side := 7 ;
5037: LD_ADDR_OWVAR 20
5041: PUSH
5042: LD_INT 7
5044: ST_TO_ADDR
// uc_nation := 1 ;
5045: LD_ADDR_OWVAR 21
5049: PUSH
5050: LD_INT 1
5052: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5053: LD_INT 5
5055: PPUSH
5056: LD_INT 3
5058: PPUSH
5059: LD_INT 3
5061: PPUSH
5062: LD_INT 11
5064: PPUSH
5065: LD_INT 100
5067: PPUSH
5068: CALL 58652 0 5
// veh := CreateVehicle ;
5072: LD_ADDR_VAR 0 3
5076: PUSH
5077: CALL_OW 45
5081: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5082: LD_VAR 0 3
5086: PPUSH
5087: LD_INT 4
5089: PPUSH
5090: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5094: LD_VAR 0 3
5098: PPUSH
5099: LD_INT 305
5101: PPUSH
5102: LD_INT 218
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 48
// ComHold ( veh ) ;
5112: LD_VAR 0 3
5116: PPUSH
5117: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5121: LD_INT 313
5123: PPUSH
5124: LD_INT 220
5126: PPUSH
5127: CALL_OW 86
// end ; end_of_file
5131: LD_VAR 0 1
5135: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5136: LD_INT 0
5138: PPUSH
5139: PPUSH
5140: PPUSH
5141: PPUSH
5142: PPUSH
5143: PPUSH
5144: PPUSH
5145: PPUSH
5146: PPUSH
5147: PPUSH
5148: PPUSH
// if Difficulty = 1 then
5149: LD_OWVAR 67
5153: PUSH
5154: LD_INT 1
5156: EQUAL
5157: IFFALSE 5195
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
5159: LD_ADDR_VAR 0 2
5163: PUSH
5164: LD_INT 95
5166: PUSH
5167: LD_INT 39
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: PUSH
5179: FOR_IN
5180: IFFALSE 5193
// RemoveUnit ( i ) ;
5182: LD_VAR 0 2
5186: PPUSH
5187: CALL_OW 64
5191: GO 5179
5193: POP
5194: POP
// InitHc ;
5195: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5199: LD_INT 387
5201: PPUSH
5202: LD_STRING sigma
5204: PPUSH
5205: CALL_OW 500
// uc_side := 1 ;
5209: LD_ADDR_OWVAR 20
5213: PUSH
5214: LD_INT 1
5216: ST_TO_ADDR
// uc_nation := 1 ;
5217: LD_ADDR_OWVAR 21
5221: PUSH
5222: LD_INT 1
5224: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5225: LD_ADDR_VAR 0 2
5229: PUSH
5230: LD_INT 22
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 21
5242: PUSH
5243: LD_INT 3
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL_OW 69
5258: PUSH
5259: FOR_IN
5260: IFFALSE 5276
// SetBLevel ( i , 10 ) ;
5262: LD_VAR 0 2
5266: PPUSH
5267: LD_INT 10
5269: PPUSH
5270: CALL_OW 241
5274: GO 5259
5276: POP
5277: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5278: LD_INT 387
5280: PPUSH
5281: CALL_OW 274
5285: PPUSH
5286: LD_INT 1
5288: PPUSH
5289: LD_INT 7500
5291: PPUSH
5292: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5296: LD_INT 387
5298: PPUSH
5299: CALL_OW 274
5303: PPUSH
5304: LD_INT 2
5306: PPUSH
5307: LD_INT 4000
5309: PPUSH
5310: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5314: LD_INT 387
5316: PPUSH
5317: CALL_OW 274
5321: PPUSH
5322: LD_INT 3
5324: PPUSH
5325: LD_INT 50
5327: PPUSH
5328: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5332: LD_INT 476
5334: PPUSH
5335: CALL_OW 274
5339: PPUSH
5340: LD_INT 1
5342: PPUSH
5343: LD_INT 5500
5345: PPUSH
5346: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5350: LD_INT 476
5352: PPUSH
5353: CALL_OW 274
5357: PPUSH
5358: LD_INT 2
5360: PPUSH
5361: LD_INT 4000
5363: PPUSH
5364: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5368: LD_INT 476
5370: PPUSH
5371: CALL_OW 274
5375: PPUSH
5376: LD_INT 3
5378: PPUSH
5379: LD_INT 10
5381: PPUSH
5382: CALL_OW 277
// if LoadVariable ( 12a_PowellKilled , false ) then
5386: LD_STRING 12a_PowellKilled
5388: PPUSH
5389: LD_INT 0
5391: PPUSH
5392: CALL_OW 30
5396: IFFALSE 5423
// begin PrepareHuman ( sex_male , class_soldier , 10 ) ;
5398: LD_INT 1
5400: PPUSH
5401: LD_INT 1
5403: PPUSH
5404: LD_INT 10
5406: PPUSH
5407: CALL_OW 380
// Powell := CreateHuman ;
5411: LD_ADDR_EXP 57
5415: PUSH
5416: CALL_OW 44
5420: ST_TO_ADDR
// end else
5421: GO 5436
// Powell := NewCharacter ( Powell ) ;
5423: LD_ADDR_EXP 57
5427: PUSH
5428: LD_STRING Powell
5430: PPUSH
5431: CALL_OW 25
5435: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5436: LD_EXP 57
5440: PPUSH
5441: LD_INT 387
5443: PPUSH
5444: CALL_OW 52
// tmp := [ ] ;
5448: LD_ADDR_VAR 0 7
5452: PUSH
5453: EMPTY
5454: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5455: LD_ADDR_EXP 23
5459: PUSH
5460: LD_STRING Lisa
5462: PPUSH
5463: LD_EXP 1
5467: NOT
5468: PPUSH
5469: LD_STRING 12p_
5471: PPUSH
5472: CALL 53728 0 3
5476: ST_TO_ADDR
// if Lisa then
5477: LD_EXP 23
5481: IFFALSE 5499
// tmp := tmp ^ Lisa ;
5483: LD_ADDR_VAR 0 7
5487: PUSH
5488: LD_VAR 0 7
5492: PUSH
5493: LD_EXP 23
5497: ADD
5498: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5499: LD_ADDR_EXP 24
5503: PUSH
5504: LD_STRING Donaldson
5506: PPUSH
5507: LD_EXP 1
5511: NOT
5512: PPUSH
5513: LD_STRING 12p_
5515: PPUSH
5516: CALL 53728 0 3
5520: ST_TO_ADDR
// if Donaldson then
5521: LD_EXP 24
5525: IFFALSE 5543
// tmp := tmp ^ Donaldson ;
5527: LD_ADDR_VAR 0 7
5531: PUSH
5532: LD_VAR 0 7
5536: PUSH
5537: LD_EXP 24
5541: ADD
5542: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5543: LD_ADDR_EXP 25
5547: PUSH
5548: LD_STRING Bobby
5550: PPUSH
5551: LD_EXP 1
5555: NOT
5556: PPUSH
5557: LD_STRING 12p_
5559: PPUSH
5560: CALL 53728 0 3
5564: ST_TO_ADDR
// if Bobby then
5565: LD_EXP 25
5569: IFFALSE 5587
// tmp := tmp ^ Bobby ;
5571: LD_ADDR_VAR 0 7
5575: PUSH
5576: LD_VAR 0 7
5580: PUSH
5581: LD_EXP 25
5585: ADD
5586: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5587: LD_ADDR_EXP 26
5591: PUSH
5592: LD_STRING Cyrus
5594: PPUSH
5595: LD_EXP 1
5599: NOT
5600: PPUSH
5601: LD_STRING 12p_
5603: PPUSH
5604: CALL 53728 0 3
5608: ST_TO_ADDR
// if Cyrus then
5609: LD_EXP 26
5613: IFFALSE 5631
// tmp := tmp ^ Cyrus ;
5615: LD_ADDR_VAR 0 7
5619: PUSH
5620: LD_VAR 0 7
5624: PUSH
5625: LD_EXP 26
5629: ADD
5630: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5631: LD_ADDR_EXP 28
5635: PUSH
5636: LD_STRING Brown
5638: PPUSH
5639: LD_EXP 1
5643: NOT
5644: PPUSH
5645: LD_STRING 12p_
5647: PPUSH
5648: CALL 53728 0 3
5652: ST_TO_ADDR
// if Brown then
5653: LD_EXP 28
5657: IFFALSE 5675
// tmp := tmp ^ Brown ;
5659: LD_ADDR_VAR 0 7
5663: PUSH
5664: LD_VAR 0 7
5668: PUSH
5669: LD_EXP 28
5673: ADD
5674: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5675: LD_ADDR_EXP 29
5679: PUSH
5680: LD_STRING Gladstone
5682: PPUSH
5683: LD_EXP 1
5687: NOT
5688: PPUSH
5689: LD_STRING 12p_
5691: PPUSH
5692: CALL 53728 0 3
5696: ST_TO_ADDR
// if Gladstone then
5697: LD_EXP 29
5701: IFFALSE 5719
// tmp := tmp ^ Gladstone ;
5703: LD_ADDR_VAR 0 7
5707: PUSH
5708: LD_VAR 0 7
5712: PUSH
5713: LD_EXP 29
5717: ADD
5718: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5719: LD_ADDR_EXP 30
5723: PUSH
5724: LD_STRING Houten
5726: PPUSH
5727: LD_EXP 1
5731: NOT
5732: PPUSH
5733: LD_STRING 12p_
5735: PPUSH
5736: CALL 53728 0 3
5740: ST_TO_ADDR
// if Houten then
5741: LD_EXP 30
5745: IFFALSE 5763
// tmp := tmp ^ Houten ;
5747: LD_ADDR_VAR 0 7
5751: PUSH
5752: LD_VAR 0 7
5756: PUSH
5757: LD_EXP 30
5761: ADD
5762: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5763: LD_ADDR_EXP 31
5767: PUSH
5768: LD_STRING Cornel
5770: PPUSH
5771: LD_EXP 1
5775: NOT
5776: PPUSH
5777: LD_STRING 12p_
5779: PPUSH
5780: CALL 53728 0 3
5784: ST_TO_ADDR
// if Cornel then
5785: LD_EXP 31
5789: IFFALSE 5807
// tmp := tmp ^ Cornel ;
5791: LD_ADDR_VAR 0 7
5795: PUSH
5796: LD_VAR 0 7
5800: PUSH
5801: LD_EXP 31
5805: ADD
5806: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5807: LD_ADDR_EXP 32
5811: PUSH
5812: LD_STRING Gary
5814: PPUSH
5815: LD_EXP 1
5819: NOT
5820: PPUSH
5821: LD_STRING 12p_
5823: PPUSH
5824: CALL 53728 0 3
5828: ST_TO_ADDR
// if Gary then
5829: LD_EXP 32
5833: IFFALSE 5851
// tmp := tmp ^ Gary ;
5835: LD_ADDR_VAR 0 7
5839: PUSH
5840: LD_VAR 0 7
5844: PUSH
5845: LD_EXP 32
5849: ADD
5850: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5851: LD_ADDR_EXP 34
5855: PUSH
5856: LD_STRING Kikuchi
5858: PPUSH
5859: LD_EXP 1
5863: NOT
5864: PPUSH
5865: LD_STRING 12p_
5867: PPUSH
5868: CALL 53728 0 3
5872: ST_TO_ADDR
// if Kikuchi then
5873: LD_EXP 34
5877: IFFALSE 5895
// tmp := tmp ^ Kikuchi ;
5879: LD_ADDR_VAR 0 7
5883: PUSH
5884: LD_VAR 0 7
5888: PUSH
5889: LD_EXP 34
5893: ADD
5894: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5895: LD_ADDR_VAR 0 7
5899: PUSH
5900: LD_VAR 0 7
5904: PUSH
5905: LD_STRING 12p_others
5907: PPUSH
5908: CALL_OW 31
5912: UNION
5913: ST_TO_ADDR
// InitHc_All ( ) ;
5914: CALL_OW 584
// if tmp < 36 then
5918: LD_VAR 0 7
5922: PUSH
5923: LD_INT 36
5925: LESS
5926: IFFALSE 5993
// for i = 1 to 36 - tmp do
5928: LD_ADDR_VAR 0 2
5932: PUSH
5933: DOUBLE
5934: LD_INT 1
5936: DEC
5937: ST_TO_ADDR
5938: LD_INT 36
5940: PUSH
5941: LD_VAR 0 7
5945: MINUS
5946: PUSH
5947: FOR_TO
5948: IFFALSE 5991
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5950: LD_INT 1
5952: PPUSH
5953: LD_VAR 0 2
5957: PUSH
5958: LD_INT 4
5960: MOD
5961: PUSH
5962: LD_INT 1
5964: PLUS
5965: PPUSH
5966: LD_INT 10
5968: PPUSH
5969: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5973: LD_ADDR_VAR 0 7
5977: PUSH
5978: LD_VAR 0 7
5982: PUSH
5983: CALL_OW 44
5987: ADD
5988: ST_TO_ADDR
// end ;
5989: GO 5947
5991: POP
5992: POP
// p := 0 ;
5993: LD_ADDR_VAR 0 6
5997: PUSH
5998: LD_INT 0
6000: ST_TO_ADDR
// for i in tmp do
6001: LD_ADDR_VAR 0 2
6005: PUSH
6006: LD_VAR 0 7
6010: PUSH
6011: FOR_IN
6012: IFFALSE 6064
// begin p := Inc ( p ) ;
6014: LD_ADDR_VAR 0 6
6018: PUSH
6019: LD_VAR 0 6
6023: PPUSH
6024: CALL 92884 0 1
6028: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
6029: LD_VAR 0 2
6033: PPUSH
6034: LD_INT 62
6036: PPUSH
6037: LD_INT 93
6039: PPUSH
6040: LD_INT 9
6042: PPUSH
6043: LD_INT 0
6045: PPUSH
6046: CALL_OW 50
// if p > 36 then
6050: LD_VAR 0 6
6054: PUSH
6055: LD_INT 36
6057: GREATER
6058: IFFALSE 6062
// break ;
6060: GO 6064
// end ;
6062: GO 6011
6064: POP
6065: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
6066: LD_ADDR_EXP 80
6070: PUSH
6071: LD_EXP 80
6075: PPUSH
6076: LD_INT 4
6078: PPUSH
6079: LD_INT 22
6081: PUSH
6082: LD_INT 1
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: PPUSH
6089: CALL_OW 69
6093: PUSH
6094: LD_EXP 57
6098: DIFF
6099: PPUSH
6100: CALL_OW 1
6104: ST_TO_ADDR
// uc_side := 0 ;
6105: LD_ADDR_OWVAR 20
6109: PUSH
6110: LD_INT 0
6112: ST_TO_ADDR
// uc_nation := 0 ;
6113: LD_ADDR_OWVAR 21
6117: PUSH
6118: LD_INT 0
6120: ST_TO_ADDR
// for i = 1 to 4 do
6121: LD_ADDR_VAR 0 2
6125: PUSH
6126: DOUBLE
6127: LD_INT 1
6129: DEC
6130: ST_TO_ADDR
6131: LD_INT 4
6133: PUSH
6134: FOR_TO
6135: IFFALSE 6166
// begin InitHc ;
6137: CALL_OW 19
// hc_class := class_apeman ;
6141: LD_ADDR_OWVAR 28
6145: PUSH
6146: LD_INT 12
6148: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6149: CALL_OW 44
6153: PPUSH
6154: LD_INT 11
6156: PPUSH
6157: LD_INT 0
6159: PPUSH
6160: CALL_OW 49
// end ;
6164: GO 6134
6166: POP
6167: POP
// end ;
6168: LD_VAR 0 1
6172: RET
// every 6 6$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6173: LD_EXP 4
6177: NOT
6178: IFFALSE 7101
6180: GO 6182
6182: DISABLE
6183: LD_INT 0
6185: PPUSH
6186: PPUSH
6187: PPUSH
6188: PPUSH
// begin enable ;
6189: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6190: LD_INT 22
6192: PUSH
6193: LD_INT 1
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: PUSH
6200: LD_INT 23
6202: PUSH
6203: LD_INT 1
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 30
6212: PUSH
6213: LD_INT 3
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: PPUSH
6225: CALL_OW 69
6229: NOT
6230: IFFALSE 6234
// exit ;
6232: GO 7101
// if Prob ( 40 ) then
6234: LD_INT 40
6236: PPUSH
6237: CALL_OW 13
6241: IFFALSE 6368
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6243: LD_INT 4
6245: PPUSH
6246: LD_INT 5
6248: PUSH
6249: LD_INT 1
6251: PUSH
6252: LD_INT 2
6254: PUSH
6255: LD_INT 7
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 5
6266: PUSH
6267: LD_INT 1
6269: PUSH
6270: LD_INT 2
6272: PUSH
6273: LD_INT 7
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: LIST
6280: LIST
6281: PUSH
6282: LD_INT 5
6284: PUSH
6285: LD_INT 1
6287: PUSH
6288: LD_INT 2
6290: PUSH
6291: LD_INT 7
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_INT 5
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: LD_INT 2
6308: PUSH
6309: LD_INT 6
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: LIST
6317: PUSH
6318: LD_INT 5
6320: PUSH
6321: LD_INT 1
6323: PUSH
6324: LD_INT 2
6326: PUSH
6327: LD_INT 6
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PUSH
6336: LD_INT 5
6338: PUSH
6339: LD_INT 1
6341: PUSH
6342: LD_INT 2
6344: PUSH
6345: LD_INT 6
6347: PUSH
6348: EMPTY
6349: LIST
6350: LIST
6351: LIST
6352: LIST
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: LIST
6360: LIST
6361: PPUSH
6362: CALL 47302 0 2
// end else
6366: GO 6491
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6368: LD_INT 4
6370: PPUSH
6371: LD_INT 5
6373: PUSH
6374: LD_INT 1
6376: PUSH
6377: LD_INT 2
6379: PUSH
6380: LD_INT 7
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: LIST
6387: LIST
6388: PUSH
6389: LD_INT 5
6391: PUSH
6392: LD_INT 1
6394: PUSH
6395: LD_INT 2
6397: PUSH
6398: LD_INT 9
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 5
6409: PUSH
6410: LD_INT 1
6412: PUSH
6413: LD_INT 2
6415: PUSH
6416: LD_INT 9
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: PUSH
6425: LD_INT 5
6427: PUSH
6428: LD_INT 1
6430: PUSH
6431: LD_INT 2
6433: PUSH
6434: LD_INT 6
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: LIST
6441: LIST
6442: PUSH
6443: LD_INT 5
6445: PUSH
6446: LD_INT 1
6448: PUSH
6449: LD_INT 2
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: LIST
6459: LIST
6460: PUSH
6461: LD_INT 5
6463: PUSH
6464: LD_INT 1
6466: PUSH
6467: LD_INT 2
6469: PUSH
6470: LD_INT 6
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: LIST
6477: LIST
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: PPUSH
6487: CALL 47302 0 2
// end ; p := 0 ;
6491: LD_ADDR_VAR 0 4
6495: PUSH
6496: LD_INT 0
6498: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6499: LD_INT 35
6501: PPUSH
6502: CALL_OW 67
// p := Inc ( p ) ;
6506: LD_ADDR_VAR 0 4
6510: PUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 92884 0 1
6520: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6521: LD_INT 4
6523: PPUSH
6524: LD_INT 1
6526: PPUSH
6527: CALL 48720 0 2
6531: PUSH
6532: LD_INT 6
6534: GREATEREQUAL
6535: PUSH
6536: LD_VAR 0 4
6540: PUSH
6541: LD_INT 100
6543: GREATER
6544: OR
6545: IFFALSE 6499
// wait ( 0 0$30 ) ;
6547: LD_INT 1050
6549: PPUSH
6550: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_siberium_rocket ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , us_crane ] ] ] ) diff mc_defender [ 4 ] ;
6554: LD_ADDR_VAR 0 2
6558: PUSH
6559: LD_INT 22
6561: PUSH
6562: LD_INT 1
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: LD_INT 21
6571: PUSH
6572: LD_INT 2
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: PUSH
6579: LD_INT 3
6581: PUSH
6582: LD_INT 34
6584: PUSH
6585: LD_INT 8
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: PUSH
6596: LD_INT 3
6598: PUSH
6599: LD_INT 34
6601: PUSH
6602: LD_INT 12
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: PUSH
6613: LD_INT 3
6615: PUSH
6616: LD_INT 34
6618: PUSH
6619: LD_INT 13
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: PUSH
6626: EMPTY
6627: LIST
6628: LIST
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: LIST
6636: PPUSH
6637: CALL_OW 69
6641: PUSH
6642: LD_EXP 102
6646: PUSH
6647: LD_INT 4
6649: ARRAY
6650: DIFF
6651: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6652: LD_ADDR_EXP 99
6656: PUSH
6657: LD_EXP 99
6661: PPUSH
6662: LD_INT 4
6664: PPUSH
6665: LD_EXP 99
6669: PUSH
6670: LD_INT 4
6672: ARRAY
6673: PUSH
6674: LD_VAR 0 2
6678: DIFF
6679: PPUSH
6680: CALL_OW 1
6684: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6685: LD_ADDR_VAR 0 3
6689: PUSH
6690: LD_INT 0
6692: PPUSH
6693: LD_INT 2
6695: PPUSH
6696: CALL_OW 12
6700: ST_TO_ADDR
// p := 0 ;
6701: LD_ADDR_VAR 0 4
6705: PUSH
6706: LD_INT 0
6708: ST_TO_ADDR
// if target then
6709: LD_VAR 0 3
6713: IFFALSE 6866
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6715: LD_ADDR_VAR 0 2
6719: PUSH
6720: LD_VAR 0 2
6724: PPUSH
6725: LD_INT 24
6727: PUSH
6728: LD_INT 250
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: PPUSH
6735: CALL_OW 72
6739: ST_TO_ADDR
// for i in tmp do
6740: LD_ADDR_VAR 0 1
6744: PUSH
6745: LD_VAR 0 2
6749: PUSH
6750: FOR_IN
6751: IFFALSE 6791
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6753: LD_VAR 0 1
6757: PPUSH
6758: LD_INT 114
6760: PPUSH
6761: LD_INT 108
6763: PPUSH
6764: CALL_OW 297
6768: PUSH
6769: LD_INT 9
6771: GREATER
6772: IFFALSE 6789
// ComMoveXY ( i , 114 , 108 ) ;
6774: LD_VAR 0 1
6778: PPUSH
6779: LD_INT 114
6781: PPUSH
6782: LD_INT 108
6784: PPUSH
6785: CALL_OW 111
6789: GO 6750
6791: POP
6792: POP
// wait ( 0 0$1 ) ;
6793: LD_INT 35
6795: PPUSH
6796: CALL_OW 67
// p := Inc ( p ) ;
6800: LD_ADDR_VAR 0 4
6804: PUSH
6805: LD_VAR 0 4
6809: PPUSH
6810: CALL 92884 0 1
6814: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6815: LD_VAR 0 2
6819: PPUSH
6820: LD_INT 92
6822: PUSH
6823: LD_INT 114
6825: PUSH
6826: LD_INT 108
6828: PUSH
6829: LD_INT 9
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: LIST
6836: LIST
6837: PPUSH
6838: CALL_OW 72
6842: PUSH
6843: LD_VAR 0 2
6847: PUSH
6848: LD_INT 1
6850: MINUS
6851: GREATEREQUAL
6852: PUSH
6853: LD_VAR 0 4
6857: PUSH
6858: LD_INT 30
6860: GREATER
6861: OR
6862: IFFALSE 6715
// end else
6864: GO 7015
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6866: LD_ADDR_VAR 0 2
6870: PUSH
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 24
6878: PUSH
6879: LD_INT 250
6881: PUSH
6882: EMPTY
6883: LIST
6884: LIST
6885: PPUSH
6886: CALL_OW 72
6890: ST_TO_ADDR
// for i in tmp do
6891: LD_ADDR_VAR 0 1
6895: PUSH
6896: LD_VAR 0 2
6900: PUSH
6901: FOR_IN
6902: IFFALSE 6942
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 129
6911: PPUSH
6912: LD_INT 139
6914: PPUSH
6915: CALL_OW 297
6919: PUSH
6920: LD_INT 9
6922: GREATER
6923: IFFALSE 6940
// ComMoveXY ( i , 129 , 139 ) ;
6925: LD_VAR 0 1
6929: PPUSH
6930: LD_INT 129
6932: PPUSH
6933: LD_INT 139
6935: PPUSH
6936: CALL_OW 111
6940: GO 6901
6942: POP
6943: POP
// wait ( 0 0$1 ) ;
6944: LD_INT 35
6946: PPUSH
6947: CALL_OW 67
// p := Inc ( p ) ;
6951: LD_ADDR_VAR 0 4
6955: PUSH
6956: LD_VAR 0 4
6960: PPUSH
6961: CALL 92884 0 1
6965: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6966: LD_VAR 0 2
6970: PPUSH
6971: LD_INT 92
6973: PUSH
6974: LD_INT 129
6976: PUSH
6977: LD_INT 139
6979: PUSH
6980: LD_INT 9
6982: PUSH
6983: EMPTY
6984: LIST
6985: LIST
6986: LIST
6987: LIST
6988: PPUSH
6989: CALL_OW 72
6993: PUSH
6994: LD_VAR 0 2
6998: PUSH
6999: LD_INT 1
7001: MINUS
7002: GREATEREQUAL
7003: PUSH
7004: LD_VAR 0 4
7008: PUSH
7009: LD_INT 30
7011: GREATER
7012: OR
7013: IFFALSE 6866
// end ; repeat wait ( 0 0$1 ) ;
7015: LD_INT 35
7017: PPUSH
7018: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
7022: LD_ADDR_VAR 0 2
7026: PUSH
7027: LD_VAR 0 2
7031: PPUSH
7032: LD_INT 50
7034: PUSH
7035: EMPTY
7036: LIST
7037: PPUSH
7038: CALL_OW 72
7042: ST_TO_ADDR
// for i in tmp do
7043: LD_ADDR_VAR 0 1
7047: PUSH
7048: LD_VAR 0 2
7052: PUSH
7053: FOR_IN
7054: IFFALSE 7092
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
7056: LD_VAR 0 1
7060: PPUSH
7061: LD_INT 81
7063: PUSH
7064: LD_INT 1
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PPUSH
7071: CALL_OW 69
7075: PPUSH
7076: LD_VAR 0 1
7080: PPUSH
7081: CALL_OW 74
7085: PPUSH
7086: CALL_OW 115
7090: GO 7053
7092: POP
7093: POP
// until not tmp ;
7094: LD_VAR 0 2
7098: NOT
7099: IFFALSE 7015
// end ;
7101: PPOPN 4
7103: END
// every 30 30$00 trigger not americanDestroyed do
7104: LD_EXP 4
7108: NOT
7109: IFFALSE 7178
7111: GO 7113
7113: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
7114: LD_INT 63000
7116: PUSH
7117: LD_INT 42000
7119: PUSH
7120: LD_INT 31500
7122: PUSH
7123: LD_INT 21000
7125: PUSH
7126: EMPTY
7127: LIST
7128: LIST
7129: LIST
7130: LIST
7131: PUSH
7132: LD_OWVAR 67
7136: ARRAY
7137: PPUSH
7138: CALL_OW 67
// if americanDestroyed then
7142: LD_EXP 4
7146: IFFALSE 7150
// exit ;
7148: GO 7178
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
7150: LD_INT 4
7152: PPUSH
7153: LD_INT 5
7155: PUSH
7156: LD_INT 3
7158: PUSH
7159: LD_INT 1
7161: PUSH
7162: LD_INT 8
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: PUSH
7171: EMPTY
7172: LIST
7173: PPUSH
7174: CALL 47302 0 2
// end ; end_of_file
7178: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
7179: LD_INT 0
7181: PPUSH
7182: PPUSH
7183: PPUSH
7184: PPUSH
7185: PPUSH
// side := 2 ;
7186: LD_ADDR_VAR 0 5
7190: PUSH
7191: LD_INT 2
7193: ST_TO_ADDR
// InitHc ;
7194: CALL_OW 19
// uc_side := side ;
7198: LD_ADDR_OWVAR 20
7202: PUSH
7203: LD_VAR 0 5
7207: ST_TO_ADDR
// uc_nation := 2 ;
7208: LD_ADDR_OWVAR 21
7212: PUSH
7213: LD_INT 2
7215: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
7216: LD_ADDR_VAR 0 2
7220: PUSH
7221: LD_INT 22
7223: PUSH
7224: LD_INT 2
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: PUSH
7231: LD_INT 21
7233: PUSH
7234: LD_INT 3
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PUSH
7241: EMPTY
7242: LIST
7243: LIST
7244: PPUSH
7245: CALL_OW 69
7249: PUSH
7250: FOR_IN
7251: IFFALSE 7267
// SetBLevel ( i , 10 ) ;
7253: LD_VAR 0 2
7257: PPUSH
7258: LD_INT 10
7260: PPUSH
7261: CALL_OW 241
7265: GO 7250
7267: POP
7268: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7269: LD_ADDR_VAR 0 4
7273: PUSH
7274: LD_INT 22
7276: PUSH
7277: LD_VAR 0 5
7281: PUSH
7282: EMPTY
7283: LIST
7284: LIST
7285: PUSH
7286: LD_INT 30
7288: PUSH
7289: LD_INT 32
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 58
7298: PUSH
7299: EMPTY
7300: LIST
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: LIST
7306: PPUSH
7307: CALL_OW 69
7311: ST_TO_ADDR
// for i = 1 to 10 do
7312: LD_ADDR_VAR 0 2
7316: PUSH
7317: DOUBLE
7318: LD_INT 1
7320: DEC
7321: ST_TO_ADDR
7322: LD_INT 10
7324: PUSH
7325: FOR_TO
7326: IFFALSE 7398
// begin uc_nation := nation_nature ;
7328: LD_ADDR_OWVAR 21
7332: PUSH
7333: LD_INT 0
7335: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7336: LD_ADDR_OWVAR 28
7340: PUSH
7341: LD_INT 15
7343: ST_TO_ADDR
// hc_gallery :=  ;
7344: LD_ADDR_OWVAR 33
7348: PUSH
7349: LD_STRING 
7351: ST_TO_ADDR
// hc_name :=  ;
7352: LD_ADDR_OWVAR 26
7356: PUSH
7357: LD_STRING 
7359: ST_TO_ADDR
// un := CreateHuman ;
7360: LD_ADDR_VAR 0 3
7364: PUSH
7365: CALL_OW 44
7369: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7370: LD_VAR 0 3
7374: PPUSH
7375: LD_VAR 0 4
7379: PUSH
7380: LD_VAR 0 4
7384: PUSH
7385: LD_VAR 0 2
7389: MINUS
7390: ARRAY
7391: PPUSH
7392: CALL_OW 52
// end ;
7396: GO 7325
7398: POP
7399: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7400: LD_INT 503
7402: PPUSH
7403: LD_INT 27
7405: PPUSH
7406: LD_STRING 
7408: PPUSH
7409: LD_INT 8
7411: PUSH
7412: LD_INT 9
7414: PUSH
7415: LD_INT 10
7417: PUSH
7418: LD_INT 10
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: LIST
7425: LIST
7426: PUSH
7427: LD_OWVAR 67
7431: ARRAY
7432: PPUSH
7433: LD_INT 3000
7435: PUSH
7436: LD_INT 500
7438: PUSH
7439: LD_INT 150
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: PPUSH
7447: LD_INT 16
7449: PUSH
7450: LD_INT 6
7452: PUSH
7453: LD_INT 6
7455: PUSH
7456: LD_INT 6
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: LIST
7463: LIST
7464: PPUSH
7465: CALL 62473 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7469: LD_ADDR_EXP 80
7473: PUSH
7474: LD_EXP 80
7478: PPUSH
7479: LD_INT 1
7481: PPUSH
7482: LD_INT 22
7484: PUSH
7485: LD_VAR 0 5
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 23
7496: PUSH
7497: LD_INT 2
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: LD_INT 3
7506: PUSH
7507: LD_INT 21
7509: PUSH
7510: LD_INT 2
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: PUSH
7517: EMPTY
7518: LIST
7519: LIST
7520: PUSH
7521: EMPTY
7522: LIST
7523: LIST
7524: LIST
7525: PPUSH
7526: CALL_OW 69
7530: PPUSH
7531: CALL_OW 1
7535: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7536: LD_INT 216
7538: PPUSH
7539: LD_INT 228
7541: PPUSH
7542: LD_INT 2
7544: PPUSH
7545: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7549: LD_INT 223
7551: PPUSH
7552: LD_INT 241
7554: PPUSH
7555: LD_INT 2
7557: PPUSH
7558: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7562: LD_INT 216
7564: PPUSH
7565: LD_INT 217
7567: PPUSH
7568: LD_INT 2
7570: PPUSH
7571: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7575: LD_INT 233
7577: PPUSH
7578: LD_INT 257
7580: PPUSH
7581: LD_INT 2
7583: PPUSH
7584: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7588: LD_INT 230
7590: PPUSH
7591: LD_INT 199
7593: PPUSH
7594: LD_INT 2
7596: PPUSH
7597: CALL_OW 244
// end ;
7601: LD_VAR 0 1
7605: RET
// export Omar ; export function PrepareOmarAli ; begin
7606: LD_INT 0
7608: PPUSH
// uc_side := 5 ;
7609: LD_ADDR_OWVAR 20
7613: PUSH
7614: LD_INT 5
7616: ST_TO_ADDR
// uc_nation := 2 ;
7617: LD_ADDR_OWVAR 21
7621: PUSH
7622: LD_INT 2
7624: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7625: LD_ADDR_EXP 58
7629: PUSH
7630: LD_STRING Omar
7632: PPUSH
7633: CALL_OW 25
7637: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7638: LD_EXP 58
7642: PPUSH
7643: LD_INT 330
7645: PPUSH
7646: LD_INT 244
7648: PPUSH
7649: LD_INT 0
7651: PPUSH
7652: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7656: LD_EXP 58
7660: PPUSH
7661: LD_INT 252
7663: PPUSH
7664: LD_INT 220
7666: PPUSH
7667: CALL_OW 111
// end ;
7671: LD_VAR 0 1
7675: RET
// export function PrepareOmarAli2 ; begin
7676: LD_INT 0
7678: PPUSH
// uc_side := 5 ;
7679: LD_ADDR_OWVAR 20
7683: PUSH
7684: LD_INT 5
7686: ST_TO_ADDR
// uc_nation := 2 ;
7687: LD_ADDR_OWVAR 21
7691: PUSH
7692: LD_INT 2
7694: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7695: LD_ADDR_EXP 58
7699: PUSH
7700: LD_STRING Omar
7702: PPUSH
7703: CALL_OW 25
7707: ST_TO_ADDR
// PlaceUnitXY ( Omar , 289 , 164 , false ) ;
7708: LD_EXP 58
7712: PPUSH
7713: LD_INT 289
7715: PPUSH
7716: LD_INT 164
7718: PPUSH
7719: LD_INT 0
7721: PPUSH
7722: CALL_OW 48
// ComMoveXY ( Omar , 254 , 166 ) ;
7726: LD_EXP 58
7730: PPUSH
7731: LD_INT 254
7733: PPUSH
7734: LD_INT 166
7736: PPUSH
7737: CALL_OW 111
// end ; end_of_file
7741: LD_VAR 0 1
7745: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7746: LD_INT 0
7748: PPUSH
7749: PPUSH
7750: PPUSH
7751: PPUSH
7752: PPUSH
// side := 8 ;
7753: LD_ADDR_VAR 0 3
7757: PUSH
7758: LD_INT 8
7760: ST_TO_ADDR
// InitHc ;
7761: CALL_OW 19
// uc_side := side ;
7765: LD_ADDR_OWVAR 20
7769: PUSH
7770: LD_VAR 0 3
7774: ST_TO_ADDR
// uc_nation := 2 ;
7775: LD_ADDR_OWVAR 21
7779: PUSH
7780: LD_INT 2
7782: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7783: LD_ADDR_VAR 0 2
7787: PUSH
7788: LD_INT 22
7790: PUSH
7791: LD_VAR 0 3
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: LD_INT 21
7802: PUSH
7803: LD_INT 3
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: PPUSH
7814: CALL_OW 69
7818: PUSH
7819: FOR_IN
7820: IFFALSE 7836
// SetBLevel ( i , 10 ) ;
7822: LD_VAR 0 2
7826: PPUSH
7827: LD_INT 10
7829: PPUSH
7830: CALL_OW 241
7834: GO 7819
7836: POP
7837: POP
// Schulz := NewCharacter ( Schulz ) ;
7838: LD_ADDR_EXP 59
7842: PUSH
7843: LD_STRING Schulz
7845: PPUSH
7846: CALL_OW 25
7850: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7851: LD_ADDR_EXP 61
7855: PUSH
7856: LD_STRING Kaia
7858: PPUSH
7859: CALL_OW 25
7863: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7864: LD_EXP 61
7868: PPUSH
7869: LD_INT 324
7871: PPUSH
7872: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7876: LD_ADDR_EXP 60
7880: PUSH
7881: LD_STRING Kozlov
7883: PPUSH
7884: LD_INT 0
7886: PPUSH
7887: LD_STRING 
7889: PPUSH
7890: CALL 53728 0 3
7894: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7895: LD_EXP 60
7899: PPUSH
7900: LD_INT 22
7902: PUSH
7903: LD_INT 8
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: LD_INT 23
7912: PUSH
7913: LD_INT 3
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: PUSH
7920: LD_INT 30
7922: PUSH
7923: LD_INT 8
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PUSH
7930: EMPTY
7931: LIST
7932: LIST
7933: LIST
7934: PPUSH
7935: CALL_OW 69
7939: PUSH
7940: LD_INT 1
7942: ARRAY
7943: PPUSH
7944: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7948: LD_EXP 60
7952: PPUSH
7953: LD_INT 3
7955: PPUSH
7956: LD_INT 10
7958: PPUSH
7959: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7963: LD_ADDR_VAR 0 5
7967: PUSH
7968: LD_INT 22
7970: PUSH
7971: LD_VAR 0 3
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: PUSH
7980: LD_INT 30
7982: PUSH
7983: LD_INT 32
7985: PUSH
7986: EMPTY
7987: LIST
7988: LIST
7989: PUSH
7990: LD_INT 58
7992: PUSH
7993: EMPTY
7994: LIST
7995: PUSH
7996: EMPTY
7997: LIST
7998: LIST
7999: LIST
8000: PPUSH
8001: CALL_OW 69
8005: ST_TO_ADDR
// for i = 1 to 10 do
8006: LD_ADDR_VAR 0 2
8010: PUSH
8011: DOUBLE
8012: LD_INT 1
8014: DEC
8015: ST_TO_ADDR
8016: LD_INT 10
8018: PUSH
8019: FOR_TO
8020: IFFALSE 8092
// begin uc_nation := nation_nature ;
8022: LD_ADDR_OWVAR 21
8026: PUSH
8027: LD_INT 0
8029: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
8030: LD_ADDR_OWVAR 28
8034: PUSH
8035: LD_INT 15
8037: ST_TO_ADDR
// hc_gallery :=  ;
8038: LD_ADDR_OWVAR 33
8042: PUSH
8043: LD_STRING 
8045: ST_TO_ADDR
// hc_name :=  ;
8046: LD_ADDR_OWVAR 26
8050: PUSH
8051: LD_STRING 
8053: ST_TO_ADDR
// un := CreateHuman ;
8054: LD_ADDR_VAR 0 4
8058: PUSH
8059: CALL_OW 44
8063: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
8064: LD_VAR 0 4
8068: PPUSH
8069: LD_VAR 0 5
8073: PUSH
8074: LD_VAR 0 5
8078: PUSH
8079: LD_VAR 0 2
8083: MINUS
8084: ARRAY
8085: PPUSH
8086: CALL_OW 52
// end ;
8090: GO 8019
8092: POP
8093: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
8094: LD_INT 324
8096: PPUSH
8097: LD_INT 3
8099: PPUSH
8100: LD_STRING 
8102: PPUSH
8103: LD_INT 8
8105: PUSH
8106: LD_INT 9
8108: PUSH
8109: LD_INT 10
8111: PUSH
8112: LD_INT 10
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: LIST
8120: PUSH
8121: LD_OWVAR 67
8125: ARRAY
8126: PPUSH
8127: LD_INT 3000
8129: PUSH
8130: LD_INT 500
8132: PUSH
8133: LD_INT 150
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: LIST
8140: PPUSH
8141: LD_INT 16
8143: PUSH
8144: LD_INT 6
8146: PUSH
8147: LD_INT 6
8149: PUSH
8150: LD_INT 8
8152: PUSH
8153: EMPTY
8154: LIST
8155: LIST
8156: LIST
8157: LIST
8158: PPUSH
8159: CALL 62473 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
8163: LD_ADDR_EXP 80
8167: PUSH
8168: LD_EXP 80
8172: PPUSH
8173: LD_INT 3
8175: PPUSH
8176: LD_INT 22
8178: PUSH
8179: LD_VAR 0 3
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: PUSH
8188: LD_INT 23
8190: PUSH
8191: LD_INT 2
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: PUSH
8198: LD_INT 3
8200: PUSH
8201: LD_INT 21
8203: PUSH
8204: LD_INT 2
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: PUSH
8215: EMPTY
8216: LIST
8217: LIST
8218: LIST
8219: PPUSH
8220: CALL_OW 69
8224: PUSH
8225: LD_EXP 59
8229: DIFF
8230: PPUSH
8231: CALL_OW 1
8235: ST_TO_ADDR
// end ;
8236: LD_VAR 0 1
8240: RET
// export function BuildKozlovBomb ; begin
8241: LD_INT 0
8243: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
8244: LD_INT 332
8246: PPUSH
8247: CALL_OW 302
8251: NOT
8252: PUSH
8253: LD_INT 336
8255: PPUSH
8256: CALL_OW 302
8260: NOT
8261: OR
8262: IFFALSE 8266
// exit ;
8264: GO 8363
// ComChangeProfession ( Kozlov , 4 ) ;
8266: LD_EXP 60
8270: PPUSH
8271: LD_INT 4
8273: PPUSH
8274: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
8278: LD_INT 336
8280: PPUSH
8281: LD_INT 25
8283: PPUSH
8284: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
8288: LD_INT 35
8290: PPUSH
8291: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
8295: LD_INT 25
8297: PPUSH
8298: LD_INT 8
8300: PPUSH
8301: CALL_OW 321
8305: PUSH
8306: LD_INT 2
8308: EQUAL
8309: IFFALSE 8288
// ComExitBuilding ( Kozlov ) ;
8311: LD_EXP 60
8315: PPUSH
8316: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8320: LD_EXP 60
8324: PPUSH
8325: LD_INT 332
8327: PPUSH
8328: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8332: LD_EXP 60
8336: PPUSH
8337: LD_INT 3
8339: PPUSH
8340: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8344: LD_INT 332
8346: PPUSH
8347: LD_INT 23
8349: PPUSH
8350: LD_INT 3
8352: PPUSH
8353: LD_INT 1
8355: PPUSH
8356: LD_INT 48
8358: PPUSH
8359: CALL_OW 125
// end ;
8363: LD_VAR 0 1
8367: RET
// every 5 5$30 + 4 4$00 trigger not legionDestroyed do var i , tmp , target , p ;
8368: LD_EXP 3
8372: NOT
8373: IFFALSE 9380
8375: GO 8377
8377: DISABLE
8378: LD_INT 0
8380: PPUSH
8381: PPUSH
8382: PPUSH
8383: PPUSH
// begin enable ;
8384: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8385: LD_INT 22
8387: PUSH
8388: LD_INT 8
8390: PUSH
8391: EMPTY
8392: LIST
8393: LIST
8394: PUSH
8395: LD_INT 23
8397: PUSH
8398: LD_INT 2
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: LD_INT 30
8407: PUSH
8408: LD_INT 3
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: LIST
8419: PPUSH
8420: CALL_OW 69
8424: NOT
8425: IFFALSE 8429
// exit ;
8427: GO 9380
// if Prob ( 40 ) then
8429: LD_INT 40
8431: PPUSH
8432: CALL_OW 13
8436: IFFALSE 8563
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8438: LD_INT 3
8440: PPUSH
8441: LD_INT 14
8443: PUSH
8444: LD_INT 1
8446: PUSH
8447: LD_INT 2
8449: PUSH
8450: LD_INT 28
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: PUSH
8459: LD_INT 14
8461: PUSH
8462: LD_INT 1
8464: PUSH
8465: LD_INT 2
8467: PUSH
8468: LD_INT 28
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 14
8479: PUSH
8480: LD_INT 1
8482: PUSH
8483: LD_INT 2
8485: PUSH
8486: LD_INT 28
8488: PUSH
8489: EMPTY
8490: LIST
8491: LIST
8492: LIST
8493: LIST
8494: PUSH
8495: LD_INT 14
8497: PUSH
8498: LD_INT 1
8500: PUSH
8501: LD_INT 2
8503: PUSH
8504: LD_INT 28
8506: PUSH
8507: EMPTY
8508: LIST
8509: LIST
8510: LIST
8511: LIST
8512: PUSH
8513: LD_INT 14
8515: PUSH
8516: LD_INT 1
8518: PUSH
8519: LD_INT 2
8521: PUSH
8522: LD_INT 28
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: PUSH
8531: LD_INT 14
8533: PUSH
8534: LD_INT 1
8536: PUSH
8537: LD_INT 2
8539: PUSH
8540: LD_INT 26
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: PUSH
8549: EMPTY
8550: LIST
8551: LIST
8552: LIST
8553: LIST
8554: LIST
8555: LIST
8556: PPUSH
8557: CALL 47302 0 2
// end else
8561: GO 8770
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8563: LD_INT 3
8565: PPUSH
8566: LD_INT 14
8568: PUSH
8569: LD_INT 1
8571: PUSH
8572: LD_INT 2
8574: PUSH
8575: LD_INT 27
8577: PUSH
8578: LD_INT 26
8580: PUSH
8581: LD_INT 26
8583: PUSH
8584: LD_INT 28
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: LIST
8591: LIST
8592: PUSH
8593: LD_OWVAR 67
8597: ARRAY
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: LIST
8603: LIST
8604: PUSH
8605: LD_INT 14
8607: PUSH
8608: LD_INT 1
8610: PUSH
8611: LD_INT 2
8613: PUSH
8614: LD_INT 27
8616: PUSH
8617: LD_INT 26
8619: PUSH
8620: LD_INT 26
8622: PUSH
8623: LD_INT 26
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: LIST
8630: LIST
8631: PUSH
8632: LD_OWVAR 67
8636: ARRAY
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_INT 14
8646: PUSH
8647: LD_INT 1
8649: PUSH
8650: LD_INT 2
8652: PUSH
8653: LD_INT 26
8655: PUSH
8656: LD_INT 26
8658: PUSH
8659: LD_INT 29
8661: PUSH
8662: LD_INT 29
8664: PUSH
8665: EMPTY
8666: LIST
8667: LIST
8668: LIST
8669: LIST
8670: PUSH
8671: LD_OWVAR 67
8675: ARRAY
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: LIST
8681: LIST
8682: PUSH
8683: LD_INT 13
8685: PUSH
8686: LD_INT 1
8688: PUSH
8689: LD_INT 2
8691: PUSH
8692: LD_INT 26
8694: PUSH
8695: LD_INT 29
8697: PUSH
8698: LD_INT 29
8700: PUSH
8701: LD_INT 29
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: LIST
8708: LIST
8709: PUSH
8710: LD_OWVAR 67
8714: ARRAY
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 13
8724: PUSH
8725: LD_INT 1
8727: PUSH
8728: LD_INT 2
8730: PUSH
8731: LD_INT 29
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: LIST
8739: PUSH
8740: LD_INT 14
8742: PUSH
8743: LD_INT 1
8745: PUSH
8746: LD_INT 2
8748: PUSH
8749: LD_INT 26
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: LIST
8756: LIST
8757: PUSH
8758: EMPTY
8759: LIST
8760: LIST
8761: LIST
8762: LIST
8763: LIST
8764: LIST
8765: PPUSH
8766: CALL 47302 0 2
// end ; p := 0 ;
8770: LD_ADDR_VAR 0 4
8774: PUSH
8775: LD_INT 0
8777: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8778: LD_INT 35
8780: PPUSH
8781: CALL_OW 67
// p := Inc ( p ) ;
8785: LD_ADDR_VAR 0 4
8789: PUSH
8790: LD_VAR 0 4
8794: PPUSH
8795: CALL 92884 0 1
8799: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8800: LD_INT 3
8802: PPUSH
8803: LD_INT 1
8805: PPUSH
8806: CALL 48720 0 2
8810: PUSH
8811: LD_INT 6
8813: GREATEREQUAL
8814: PUSH
8815: LD_VAR 0 4
8819: PUSH
8820: LD_INT 100
8822: GREATER
8823: OR
8824: IFFALSE 8778
// wait ( 0 0$30 ) ;
8826: LD_INT 1050
8828: PPUSH
8829: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
8833: LD_ADDR_VAR 0 2
8837: PUSH
8838: LD_INT 22
8840: PUSH
8841: LD_INT 8
8843: PUSH
8844: EMPTY
8845: LIST
8846: LIST
8847: PUSH
8848: LD_INT 21
8850: PUSH
8851: LD_INT 2
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 3
8860: PUSH
8861: LD_INT 34
8863: PUSH
8864: LD_INT 31
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PUSH
8871: EMPTY
8872: LIST
8873: LIST
8874: PUSH
8875: LD_INT 3
8877: PUSH
8878: LD_INT 34
8880: PUSH
8881: LD_INT 32
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: PUSH
8888: EMPTY
8889: LIST
8890: LIST
8891: PUSH
8892: LD_INT 3
8894: PUSH
8895: LD_INT 34
8897: PUSH
8898: LD_INT 88
8900: PUSH
8901: EMPTY
8902: LIST
8903: LIST
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: PUSH
8909: EMPTY
8910: LIST
8911: LIST
8912: LIST
8913: LIST
8914: LIST
8915: PPUSH
8916: CALL_OW 69
8920: PUSH
8921: LD_EXP 102
8925: PUSH
8926: LD_INT 3
8928: ARRAY
8929: DIFF
8930: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8931: LD_ADDR_EXP 99
8935: PUSH
8936: LD_EXP 99
8940: PPUSH
8941: LD_INT 3
8943: PPUSH
8944: LD_EXP 99
8948: PUSH
8949: LD_INT 3
8951: ARRAY
8952: PUSH
8953: LD_VAR 0 2
8957: DIFF
8958: PPUSH
8959: CALL_OW 1
8963: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8964: LD_ADDR_VAR 0 3
8968: PUSH
8969: LD_INT 0
8971: PPUSH
8972: LD_INT 2
8974: PPUSH
8975: CALL_OW 12
8979: ST_TO_ADDR
// p := 0 ;
8980: LD_ADDR_VAR 0 4
8984: PUSH
8985: LD_INT 0
8987: ST_TO_ADDR
// if target then
8988: LD_VAR 0 3
8992: IFFALSE 9145
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8994: LD_ADDR_VAR 0 2
8998: PUSH
8999: LD_VAR 0 2
9003: PPUSH
9004: LD_INT 24
9006: PUSH
9007: LD_INT 250
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: PPUSH
9014: CALL_OW 72
9018: ST_TO_ADDR
// for i in tmp do
9019: LD_ADDR_VAR 0 1
9023: PUSH
9024: LD_VAR 0 2
9028: PUSH
9029: FOR_IN
9030: IFFALSE 9070
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
9032: LD_VAR 0 1
9036: PPUSH
9037: LD_INT 89
9039: PPUSH
9040: LD_INT 71
9042: PPUSH
9043: CALL_OW 297
9047: PUSH
9048: LD_INT 9
9050: GREATER
9051: IFFALSE 9068
// ComMoveXY ( i , 89 , 71 ) ;
9053: LD_VAR 0 1
9057: PPUSH
9058: LD_INT 89
9060: PPUSH
9061: LD_INT 71
9063: PPUSH
9064: CALL_OW 111
9068: GO 9029
9070: POP
9071: POP
// wait ( 0 0$1 ) ;
9072: LD_INT 35
9074: PPUSH
9075: CALL_OW 67
// p := Inc ( p ) ;
9079: LD_ADDR_VAR 0 4
9083: PUSH
9084: LD_VAR 0 4
9088: PPUSH
9089: CALL 92884 0 1
9093: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9094: LD_VAR 0 2
9098: PPUSH
9099: LD_INT 92
9101: PUSH
9102: LD_INT 89
9104: PUSH
9105: LD_INT 71
9107: PUSH
9108: LD_INT 9
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: LIST
9115: LIST
9116: PPUSH
9117: CALL_OW 72
9121: PUSH
9122: LD_VAR 0 2
9126: PUSH
9127: LD_INT 1
9129: MINUS
9130: GREATEREQUAL
9131: PUSH
9132: LD_VAR 0 4
9136: PUSH
9137: LD_INT 30
9139: GREATER
9140: OR
9141: IFFALSE 8994
// end else
9143: GO 9294
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9145: LD_ADDR_VAR 0 2
9149: PUSH
9150: LD_VAR 0 2
9154: PPUSH
9155: LD_INT 24
9157: PUSH
9158: LD_INT 250
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: PPUSH
9165: CALL_OW 72
9169: ST_TO_ADDR
// for i in tmp do
9170: LD_ADDR_VAR 0 1
9174: PUSH
9175: LD_VAR 0 2
9179: PUSH
9180: FOR_IN
9181: IFFALSE 9221
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
9183: LD_VAR 0 1
9187: PPUSH
9188: LD_INT 147
9190: PPUSH
9191: LD_INT 4
9193: PPUSH
9194: CALL_OW 297
9198: PUSH
9199: LD_INT 9
9201: GREATER
9202: IFFALSE 9219
// ComMoveXY ( i , 147 , 4 ) ;
9204: LD_VAR 0 1
9208: PPUSH
9209: LD_INT 147
9211: PPUSH
9212: LD_INT 4
9214: PPUSH
9215: CALL_OW 111
9219: GO 9180
9221: POP
9222: POP
// wait ( 0 0$1 ) ;
9223: LD_INT 35
9225: PPUSH
9226: CALL_OW 67
// p := Inc ( p ) ;
9230: LD_ADDR_VAR 0 4
9234: PUSH
9235: LD_VAR 0 4
9239: PPUSH
9240: CALL 92884 0 1
9244: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9245: LD_VAR 0 2
9249: PPUSH
9250: LD_INT 92
9252: PUSH
9253: LD_INT 147
9255: PUSH
9256: LD_INT 4
9258: PUSH
9259: LD_INT 9
9261: PUSH
9262: EMPTY
9263: LIST
9264: LIST
9265: LIST
9266: LIST
9267: PPUSH
9268: CALL_OW 72
9272: PUSH
9273: LD_VAR 0 2
9277: PUSH
9278: LD_INT 1
9280: MINUS
9281: GREATEREQUAL
9282: PUSH
9283: LD_VAR 0 4
9287: PUSH
9288: LD_INT 30
9290: GREATER
9291: OR
9292: IFFALSE 9145
// end ; repeat wait ( 0 0$1 ) ;
9294: LD_INT 35
9296: PPUSH
9297: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
9301: LD_ADDR_VAR 0 2
9305: PUSH
9306: LD_VAR 0 2
9310: PPUSH
9311: LD_INT 50
9313: PUSH
9314: EMPTY
9315: LIST
9316: PPUSH
9317: CALL_OW 72
9321: ST_TO_ADDR
// for i in tmp do
9322: LD_ADDR_VAR 0 1
9326: PUSH
9327: LD_VAR 0 2
9331: PUSH
9332: FOR_IN
9333: IFFALSE 9371
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
9335: LD_VAR 0 1
9339: PPUSH
9340: LD_INT 81
9342: PUSH
9343: LD_INT 8
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: PPUSH
9350: CALL_OW 69
9354: PPUSH
9355: LD_VAR 0 1
9359: PPUSH
9360: CALL_OW 74
9364: PPUSH
9365: CALL_OW 115
9369: GO 9332
9371: POP
9372: POP
// until not tmp ;
9373: LD_VAR 0 2
9377: NOT
9378: IFFALSE 9294
// end ;
9380: PPOPN 4
9382: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
9383: LD_EXP 60
9387: PPUSH
9388: CALL_OW 302
9392: PUSH
9393: LD_EXP 3
9397: NOT
9398: AND
9399: IFFALSE 9408
9401: GO 9403
9403: DISABLE
// BuildKozlovBomb ;
9404: CALL 8241 0 0
9408: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
9409: LD_INT 22
9411: PUSH
9412: LD_INT 8
9414: PUSH
9415: EMPTY
9416: LIST
9417: LIST
9418: PUSH
9419: LD_INT 34
9421: PUSH
9422: LD_INT 48
9424: PUSH
9425: EMPTY
9426: LIST
9427: LIST
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: PPUSH
9433: CALL_OW 69
9437: IFFALSE 9485
9439: GO 9441
9441: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9442: LD_INT 22
9444: PUSH
9445: LD_INT 8
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PUSH
9452: LD_INT 34
9454: PUSH
9455: LD_INT 48
9457: PUSH
9458: EMPTY
9459: LIST
9460: LIST
9461: PUSH
9462: EMPTY
9463: LIST
9464: LIST
9465: PPUSH
9466: CALL_OW 69
9470: PUSH
9471: LD_INT 1
9473: ARRAY
9474: PPUSH
9475: LD_INT 173
9477: PPUSH
9478: LD_INT 96
9480: PPUSH
9481: CALL_OW 116
// end ; end_of_file
9485: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9486: LD_INT 0
9488: PPUSH
9489: PPUSH
9490: PPUSH
9491: PPUSH
9492: PPUSH
9493: PPUSH
9494: PPUSH
9495: PPUSH
9496: PPUSH
9497: PPUSH
// side := 3 ;
9498: LD_ADDR_VAR 0 6
9502: PUSH
9503: LD_INT 3
9505: ST_TO_ADDR
// InitHc ;
9506: CALL_OW 19
// uc_side := side ;
9510: LD_ADDR_OWVAR 20
9514: PUSH
9515: LD_VAR 0 6
9519: ST_TO_ADDR
// uc_nation := 3 ;
9520: LD_ADDR_OWVAR 21
9524: PUSH
9525: LD_INT 3
9527: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9528: LD_ADDR_VAR 0 2
9532: PUSH
9533: LD_INT 22
9535: PUSH
9536: LD_VAR 0 6
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: PUSH
9545: LD_INT 21
9547: PUSH
9548: LD_INT 3
9550: PUSH
9551: EMPTY
9552: LIST
9553: LIST
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PPUSH
9559: CALL_OW 69
9563: PUSH
9564: FOR_IN
9565: IFFALSE 9581
// SetBLevel ( i , 10 ) ;
9567: LD_VAR 0 2
9571: PPUSH
9572: LD_INT 10
9574: PPUSH
9575: CALL_OW 241
9579: GO 9564
9581: POP
9582: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9583: LD_ADDR_VAR 0 10
9587: PUSH
9588: LD_INT 22
9590: PUSH
9591: LD_VAR 0 6
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: LD_INT 30
9602: PUSH
9603: LD_INT 34
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PPUSH
9614: CALL_OW 69
9618: ST_TO_ADDR
// if teleport then
9619: LD_VAR 0 10
9623: IFFALSE 9644
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9625: LD_VAR 0 10
9629: PUSH
9630: LD_INT 1
9632: ARRAY
9633: PPUSH
9634: LD_INT 123
9636: PPUSH
9637: LD_INT 122
9639: PPUSH
9640: CALL_OW 243
// hc_importance := 0 ;
9644: LD_ADDR_OWVAR 32
9648: PUSH
9649: LD_INT 0
9651: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9652: LD_ADDR_EXP 62
9656: PUSH
9657: LD_STRING Platonov
9659: PPUSH
9660: CALL_OW 25
9664: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9665: LD_ADDR_EXP 63
9669: PUSH
9670: LD_STRING Yakotich
9672: PPUSH
9673: LD_EXP 1
9677: NOT
9678: PPUSH
9679: LD_STRING 09_
9681: PPUSH
9682: CALL 53728 0 3
9686: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9687: LD_ADDR_EXP 64
9691: PUSH
9692: LD_STRING Gleb
9694: PPUSH
9695: CALL_OW 25
9699: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9700: LD_STRING 03_Cornel
9702: PPUSH
9703: CALL_OW 28
9707: IFFALSE 9755
// begin Bierezov := NewCharacter ( Mikhail ) ;
9709: LD_ADDR_EXP 65
9713: PUSH
9714: LD_STRING Mikhail
9716: PPUSH
9717: CALL_OW 25
9721: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9722: LD_EXP 65
9726: PPUSH
9727: LD_INT 197
9729: PPUSH
9730: LD_INT 111
9732: PPUSH
9733: LD_INT 9
9735: PPUSH
9736: LD_INT 0
9738: PPUSH
9739: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9743: LD_EXP 65
9747: PPUSH
9748: LD_INT 3
9750: PPUSH
9751: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9755: LD_EXP 62
9759: PPUSH
9760: LD_INT 126
9762: PPUSH
9763: CALL_OW 52
// if Yakotich then
9767: LD_EXP 63
9771: IFFALSE 9794
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9773: LD_EXP 63
9777: PPUSH
9778: LD_INT 197
9780: PPUSH
9781: LD_INT 111
9783: PPUSH
9784: LD_INT 9
9786: PPUSH
9787: LD_INT 0
9789: PPUSH
9790: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9794: LD_EXP 64
9798: PPUSH
9799: LD_INT 197
9801: PPUSH
9802: LD_INT 111
9804: PPUSH
9805: LD_INT 9
9807: PPUSH
9808: LD_INT 0
9810: PPUSH
9811: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9815: LD_ADDR_VAR 0 5
9819: PUSH
9820: LD_INT 126
9822: PPUSH
9823: LD_INT 2
9825: PPUSH
9826: LD_STRING zhukov
9828: PPUSH
9829: LD_INT 9
9831: PUSH
9832: LD_INT 10
9834: PUSH
9835: LD_INT 10
9837: PUSH
9838: LD_INT 10
9840: PUSH
9841: EMPTY
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: PUSH
9847: LD_OWVAR 67
9851: ARRAY
9852: PPUSH
9853: LD_INT 9000
9855: PUSH
9856: LD_INT 1000
9858: PUSH
9859: LD_INT 300
9861: PUSH
9862: EMPTY
9863: LIST
9864: LIST
9865: LIST
9866: PPUSH
9867: LD_INT 21
9869: PUSH
9870: LD_INT 8
9872: PUSH
9873: LD_INT 13
9875: PUSH
9876: LD_INT 8
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: LIST
9883: LIST
9884: PPUSH
9885: CALL 62473 0 6
9889: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9890: LD_ADDR_EXP 80
9894: PUSH
9895: LD_EXP 80
9899: PPUSH
9900: LD_INT 2
9902: PPUSH
9903: LD_VAR 0 5
9907: PUSH
9908: LD_EXP 63
9912: PUSH
9913: LD_EXP 64
9917: PUSH
9918: LD_EXP 65
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: LIST
9927: UNION
9928: PPUSH
9929: CALL_OW 1
9933: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9934: LD_ADDR_VAR 0 4
9938: PUSH
9939: LD_INT 267
9941: PPUSH
9942: CALL_OW 274
9946: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9947: LD_VAR 0 4
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: LD_INT 5000
9957: PPUSH
9958: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9962: LD_VAR 0 4
9966: PPUSH
9967: LD_INT 2
9969: PPUSH
9970: LD_INT 200
9972: PPUSH
9973: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9977: LD_VAR 0 4
9981: PPUSH
9982: LD_INT 3
9984: PPUSH
9985: LD_INT 200
9987: PPUSH
9988: CALL_OW 277
// for i := 1 to 6 do
9992: LD_ADDR_VAR 0 2
9996: PUSH
9997: DOUBLE
9998: LD_INT 1
10000: DEC
10001: ST_TO_ADDR
10002: LD_INT 6
10004: PUSH
10005: FOR_TO
10006: IFFALSE 10089
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
10008: LD_INT 0
10010: PPUSH
10011: LD_INT 8
10013: PUSH
10014: LD_INT 9
10016: PUSH
10017: LD_INT 10
10019: PUSH
10020: LD_INT 10
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: LIST
10027: LIST
10028: PUSH
10029: LD_OWVAR 67
10033: ARRAY
10034: PPUSH
10035: CALL_OW 381
// un := CreateHuman ;
10039: LD_ADDR_VAR 0 8
10043: PUSH
10044: CALL_OW 44
10048: ST_TO_ADDR
// if i mod 2 = 0 then
10049: LD_VAR 0 2
10053: PUSH
10054: LD_INT 2
10056: MOD
10057: PUSH
10058: LD_INT 0
10060: EQUAL
10061: IFFALSE 10075
// SetClass ( un , class_bazooker ) ;
10063: LD_VAR 0 8
10067: PPUSH
10068: LD_INT 9
10070: PPUSH
10071: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
10075: LD_VAR 0 8
10079: PPUSH
10080: LD_INT 674
10082: PPUSH
10083: CALL_OW 52
// end ;
10087: GO 10005
10089: POP
10090: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
10091: LD_INT 21
10093: PPUSH
10094: LD_INT 3
10096: PPUSH
10097: LD_INT 3
10099: PPUSH
10100: LD_INT 52
10102: PPUSH
10103: LD_INT 100
10105: PPUSH
10106: CALL 58652 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
10110: CALL_OW 45
10114: PPUSH
10115: LD_INT 259
10117: PPUSH
10118: LD_INT 145
10120: PPUSH
10121: LD_INT 3
10123: PPUSH
10124: LD_INT 0
10126: PPUSH
10127: CALL 93663 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
10131: CALL_OW 45
10135: PPUSH
10136: LD_INT 245
10138: PPUSH
10139: LD_INT 139
10141: PPUSH
10142: LD_INT 3
10144: PPUSH
10145: LD_INT 0
10147: PPUSH
10148: CALL 93663 0 5
// behemoths := [ ] ;
10152: LD_ADDR_EXP 66
10156: PUSH
10157: EMPTY
10158: ST_TO_ADDR
// behemothBuilders := [ ] ;
10159: LD_ADDR_EXP 67
10163: PUSH
10164: EMPTY
10165: ST_TO_ADDR
// j := 3 ;
10166: LD_ADDR_VAR 0 3
10170: PUSH
10171: LD_INT 3
10173: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
10174: LD_ADDR_VAR 0 2
10178: PUSH
10179: LD_INT 22
10181: PUSH
10182: LD_INT 3
10184: PUSH
10185: EMPTY
10186: LIST
10187: LIST
10188: PUSH
10189: LD_INT 25
10191: PUSH
10192: LD_INT 3
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: PUSH
10199: EMPTY
10200: LIST
10201: LIST
10202: PPUSH
10203: CALL_OW 69
10207: PUSH
10208: FOR_IN
10209: IFFALSE 10259
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
10211: LD_ADDR_EXP 67
10215: PUSH
10216: LD_EXP 67
10220: PPUSH
10221: LD_VAR 0 2
10225: PPUSH
10226: CALL 91523 0 2
10230: ST_TO_ADDR
// j := j - 1 ;
10231: LD_ADDR_VAR 0 3
10235: PUSH
10236: LD_VAR 0 3
10240: PUSH
10241: LD_INT 1
10243: MINUS
10244: ST_TO_ADDR
// if j = 0 then
10245: LD_VAR 0 3
10249: PUSH
10250: LD_INT 0
10252: EQUAL
10253: IFFALSE 10257
// break ;
10255: GO 10259
// end ;
10257: GO 10208
10259: POP
10260: POP
// end ;
10261: LD_VAR 0 1
10265: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
10266: LD_INT 0
10268: PPUSH
10269: PPUSH
10270: PPUSH
10271: PPUSH
10272: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
10273: LD_ADDR_VAR 0 4
10277: PUSH
10278: LD_INT 209
10280: PUSH
10281: LD_INT 149
10283: PUSH
10284: EMPTY
10285: LIST
10286: LIST
10287: PUSH
10288: LD_INT 219
10290: PUSH
10291: LD_INT 154
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: PUSH
10298: LD_INT 223
10300: PUSH
10301: LD_INT 149
10303: PUSH
10304: EMPTY
10305: LIST
10306: LIST
10307: PUSH
10308: LD_INT 232
10310: PUSH
10311: LD_INT 155
10313: PUSH
10314: EMPTY
10315: LIST
10316: LIST
10317: PUSH
10318: EMPTY
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: ST_TO_ADDR
// if not behemothBuilders then
10324: LD_EXP 67
10328: NOT
10329: IFFALSE 10333
// exit ;
10331: GO 10437
// j := 1 ;
10333: LD_ADDR_VAR 0 3
10337: PUSH
10338: LD_INT 1
10340: ST_TO_ADDR
// for i in behemothBuilders do
10341: LD_ADDR_VAR 0 2
10345: PUSH
10346: LD_EXP 67
10350: PUSH
10351: FOR_IN
10352: IFFALSE 10435
// begin if IsInUnit ( i ) then
10354: LD_VAR 0 2
10358: PPUSH
10359: CALL_OW 310
10363: IFFALSE 10374
// ComExitBuilding ( i ) ;
10365: LD_VAR 0 2
10369: PPUSH
10370: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
10374: LD_VAR 0 2
10378: PPUSH
10379: LD_INT 37
10381: PPUSH
10382: LD_VAR 0 4
10386: PUSH
10387: LD_VAR 0 3
10391: ARRAY
10392: PUSH
10393: LD_INT 1
10395: ARRAY
10396: PPUSH
10397: LD_VAR 0 4
10401: PUSH
10402: LD_VAR 0 3
10406: ARRAY
10407: PUSH
10408: LD_INT 2
10410: ARRAY
10411: PPUSH
10412: LD_INT 0
10414: PPUSH
10415: CALL_OW 230
// j := j + 1 ;
10419: LD_ADDR_VAR 0 3
10423: PUSH
10424: LD_VAR 0 3
10428: PUSH
10429: LD_INT 1
10431: PLUS
10432: ST_TO_ADDR
// end ;
10433: GO 10351
10435: POP
10436: POP
// end ;
10437: LD_VAR 0 1
10441: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10442: LD_INT 3
10444: PPUSH
10445: CALL 91584 0 1
10449: PUSH
10450: LD_INT 22
10452: PUSH
10453: LD_INT 3
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: PUSH
10460: LD_INT 30
10462: PUSH
10463: LD_INT 37
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: PPUSH
10474: CALL_OW 69
10478: NOT
10479: AND
10480: IFFALSE 10666
10482: GO 10484
10484: DISABLE
10485: LD_INT 0
10487: PPUSH
10488: PPUSH
// begin enable ;
10489: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10490: LD_ADDR_VAR 0 2
10494: PUSH
10495: LD_INT 3
10497: PPUSH
10498: CALL 91584 0 1
10502: ST_TO_ADDR
// for i in tmp do
10503: LD_ADDR_VAR 0 1
10507: PUSH
10508: LD_VAR 0 2
10512: PUSH
10513: FOR_IN
10514: IFFALSE 10664
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10516: LD_VAR 0 1
10520: PPUSH
10521: LD_INT 7
10523: PPUSH
10524: CALL_OW 308
10528: PUSH
10529: LD_VAR 0 1
10533: PPUSH
10534: CALL_OW 110
10538: PUSH
10539: LD_INT 2
10541: EQUAL
10542: NOT
10543: AND
10544: IFFALSE 10558
// SetTag ( i , 2 ) ;
10546: LD_VAR 0 1
10550: PPUSH
10551: LD_INT 2
10553: PPUSH
10554: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10558: LD_INT 81
10560: PUSH
10561: LD_INT 3
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: PUSH
10568: LD_INT 91
10570: PUSH
10571: LD_VAR 0 1
10575: PUSH
10576: LD_INT 12
10578: PUSH
10579: EMPTY
10580: LIST
10581: LIST
10582: LIST
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PPUSH
10588: CALL_OW 69
10592: NOT
10593: PUSH
10594: LD_VAR 0 1
10598: PPUSH
10599: CALL_OW 110
10603: PUSH
10604: LD_INT 2
10606: EQUAL
10607: NOT
10608: AND
10609: IFFALSE 10628
// ComAgressiveMove ( i , 64 , 93 ) else
10611: LD_VAR 0 1
10615: PPUSH
10616: LD_INT 64
10618: PPUSH
10619: LD_INT 93
10621: PPUSH
10622: CALL_OW 114
10626: GO 10662
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10628: LD_VAR 0 1
10632: PPUSH
10633: LD_INT 81
10635: PUSH
10636: LD_INT 3
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PPUSH
10643: CALL_OW 69
10647: PPUSH
10648: LD_VAR 0 1
10652: PPUSH
10653: CALL_OW 74
10657: PPUSH
10658: CALL_OW 115
// end ;
10662: GO 10513
10664: POP
10665: POP
// end ;
10666: PPOPN 2
10668: END
// every 6 6$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10669: LD_EXP 2
10673: NOT
10674: IFFALSE 11760
10676: GO 10678
10678: DISABLE
10679: LD_INT 0
10681: PPUSH
10682: PPUSH
10683: PPUSH
10684: PPUSH
10685: PPUSH
// begin enable ;
10686: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10687: LD_INT 22
10689: PUSH
10690: LD_INT 3
10692: PUSH
10693: EMPTY
10694: LIST
10695: LIST
10696: PUSH
10697: LD_INT 30
10699: PUSH
10700: LD_INT 3
10702: PUSH
10703: EMPTY
10704: LIST
10705: LIST
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: PPUSH
10711: CALL_OW 69
10715: NOT
10716: IFFALSE 10720
// exit ;
10718: GO 11760
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10720: LD_ADDR_VAR 0 4
10724: PUSH
10725: LD_INT 22
10727: PUSH
10728: LD_INT 3
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: LD_INT 30
10737: PUSH
10738: LD_INT 34
10740: PUSH
10741: EMPTY
10742: LIST
10743: LIST
10744: PUSH
10745: EMPTY
10746: LIST
10747: LIST
10748: PPUSH
10749: CALL_OW 69
10753: ST_TO_ADDR
// if Prob ( 40 ) then
10754: LD_INT 40
10756: PPUSH
10757: CALL_OW 13
10761: IFFALSE 10888
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10763: LD_INT 2
10765: PPUSH
10766: LD_INT 22
10768: PUSH
10769: LD_INT 3
10771: PUSH
10772: LD_INT 3
10774: PUSH
10775: LD_INT 49
10777: PUSH
10778: EMPTY
10779: LIST
10780: LIST
10781: LIST
10782: LIST
10783: PUSH
10784: LD_INT 22
10786: PUSH
10787: LD_INT 3
10789: PUSH
10790: LD_INT 3
10792: PUSH
10793: LD_INT 49
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: LIST
10800: LIST
10801: PUSH
10802: LD_INT 22
10804: PUSH
10805: LD_INT 3
10807: PUSH
10808: LD_INT 3
10810: PUSH
10811: LD_INT 49
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: LIST
10818: LIST
10819: PUSH
10820: LD_INT 24
10822: PUSH
10823: LD_INT 3
10825: PUSH
10826: LD_INT 3
10828: PUSH
10829: LD_INT 46
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: LIST
10836: LIST
10837: PUSH
10838: LD_INT 24
10840: PUSH
10841: LD_INT 3
10843: PUSH
10844: LD_INT 3
10846: PUSH
10847: LD_INT 46
10849: PUSH
10850: EMPTY
10851: LIST
10852: LIST
10853: LIST
10854: LIST
10855: PUSH
10856: LD_INT 24
10858: PUSH
10859: LD_INT 3
10861: PUSH
10862: LD_INT 3
10864: PUSH
10865: LD_INT 46
10867: PUSH
10868: EMPTY
10869: LIST
10870: LIST
10871: LIST
10872: LIST
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL 47302 0 2
// end else
10886: GO 11011
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10888: LD_INT 2
10890: PPUSH
10891: LD_INT 24
10893: PUSH
10894: LD_INT 3
10896: PUSH
10897: LD_INT 3
10899: PUSH
10900: LD_INT 47
10902: PUSH
10903: EMPTY
10904: LIST
10905: LIST
10906: LIST
10907: LIST
10908: PUSH
10909: LD_INT 24
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: LD_INT 3
10917: PUSH
10918: LD_INT 47
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: LIST
10925: LIST
10926: PUSH
10927: LD_INT 24
10929: PUSH
10930: LD_INT 3
10932: PUSH
10933: LD_INT 3
10935: PUSH
10936: LD_INT 47
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: LIST
10943: LIST
10944: PUSH
10945: LD_INT 24
10947: PUSH
10948: LD_INT 3
10950: PUSH
10951: LD_INT 3
10953: PUSH
10954: LD_INT 46
10956: PUSH
10957: EMPTY
10958: LIST
10959: LIST
10960: LIST
10961: LIST
10962: PUSH
10963: LD_INT 24
10965: PUSH
10966: LD_INT 3
10968: PUSH
10969: LD_INT 3
10971: PUSH
10972: LD_INT 46
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: LIST
10979: LIST
10980: PUSH
10981: LD_INT 24
10983: PUSH
10984: LD_INT 3
10986: PUSH
10987: LD_INT 3
10989: PUSH
10990: LD_INT 46
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: LIST
10997: LIST
10998: PUSH
10999: EMPTY
11000: LIST
11001: LIST
11002: LIST
11003: LIST
11004: LIST
11005: LIST
11006: PPUSH
11007: CALL 47302 0 2
// end ; if Difficulty > 1 then
11011: LD_OWVAR 67
11015: PUSH
11016: LD_INT 1
11018: GREATER
11019: IFFALSE 11049
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
11021: LD_INT 2
11023: PPUSH
11024: LD_INT 24
11026: PUSH
11027: LD_INT 3
11029: PUSH
11030: LD_INT 3
11032: PUSH
11033: LD_INT 47
11035: PUSH
11036: EMPTY
11037: LIST
11038: LIST
11039: LIST
11040: LIST
11041: PUSH
11042: EMPTY
11043: LIST
11044: PPUSH
11045: CALL 47302 0 2
// p := 0 ;
11049: LD_ADDR_VAR 0 5
11053: PUSH
11054: LD_INT 0
11056: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11057: LD_INT 35
11059: PPUSH
11060: CALL_OW 67
// p := Inc ( p ) ;
11064: LD_ADDR_VAR 0 5
11068: PUSH
11069: LD_VAR 0 5
11073: PPUSH
11074: CALL 92884 0 1
11078: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 120 ;
11079: LD_INT 2
11081: PPUSH
11082: LD_INT 1
11084: PPUSH
11085: CALL 48720 0 2
11089: PUSH
11090: LD_INT 6
11092: PUSH
11093: LD_INT 7
11095: PUSH
11096: LD_INT 7
11098: PUSH
11099: LD_INT 7
11101: PUSH
11102: EMPTY
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: PUSH
11108: LD_OWVAR 67
11112: ARRAY
11113: GREATEREQUAL
11114: PUSH
11115: LD_VAR 0 5
11119: PUSH
11120: LD_INT 120
11122: GREATER
11123: OR
11124: IFFALSE 11057
// wait ( 0 0$30 ) ;
11126: LD_INT 1050
11128: PPUSH
11129: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11133: LD_ADDR_VAR 0 2
11137: PUSH
11138: LD_INT 22
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 23
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: LD_INT 21
11160: PUSH
11161: LD_INT 2
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: LD_INT 3
11170: PUSH
11171: LD_INT 34
11173: PUSH
11174: LD_INT 48
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: LD_INT 3
11187: PUSH
11188: LD_INT 34
11190: PUSH
11191: LD_INT 51
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PUSH
11198: EMPTY
11199: LIST
11200: LIST
11201: PUSH
11202: LD_INT 3
11204: PUSH
11205: LD_INT 34
11207: PUSH
11208: LD_INT 52
11210: PUSH
11211: EMPTY
11212: LIST
11213: LIST
11214: PUSH
11215: EMPTY
11216: LIST
11217: LIST
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: PPUSH
11227: CALL_OW 69
11231: PUSH
11232: LD_EXP 102
11236: PUSH
11237: LD_INT 2
11239: ARRAY
11240: DIFF
11241: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11242: LD_ADDR_EXP 99
11246: PUSH
11247: LD_EXP 99
11251: PPUSH
11252: LD_INT 2
11254: PPUSH
11255: LD_EXP 99
11259: PUSH
11260: LD_INT 2
11262: ARRAY
11263: PUSH
11264: LD_VAR 0 2
11268: DIFF
11269: PPUSH
11270: CALL_OW 1
11274: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11275: LD_ADDR_VAR 0 3
11279: PUSH
11280: LD_INT 0
11282: PPUSH
11283: LD_INT 1
11285: PPUSH
11286: CALL_OW 12
11290: ST_TO_ADDR
// p := 0 ;
11291: LD_ADDR_VAR 0 5
11295: PUSH
11296: LD_INT 0
11298: ST_TO_ADDR
// if target then
11299: LD_VAR 0 3
11303: IFFALSE 11456
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11305: LD_ADDR_VAR 0 2
11309: PUSH
11310: LD_VAR 0 2
11314: PPUSH
11315: LD_INT 24
11317: PUSH
11318: LD_INT 250
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: PPUSH
11325: CALL_OW 72
11329: ST_TO_ADDR
// for i in tmp do
11330: LD_ADDR_VAR 0 1
11334: PUSH
11335: LD_VAR 0 2
11339: PUSH
11340: FOR_IN
11341: IFFALSE 11381
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11343: LD_VAR 0 1
11347: PPUSH
11348: LD_INT 139
11350: PPUSH
11351: LD_INT 89
11353: PPUSH
11354: CALL_OW 297
11358: PUSH
11359: LD_INT 9
11361: GREATER
11362: IFFALSE 11379
// ComMoveXY ( i , 139 , 89 ) ;
11364: LD_VAR 0 1
11368: PPUSH
11369: LD_INT 139
11371: PPUSH
11372: LD_INT 89
11374: PPUSH
11375: CALL_OW 111
11379: GO 11340
11381: POP
11382: POP
// wait ( 0 0$1 ) ;
11383: LD_INT 35
11385: PPUSH
11386: CALL_OW 67
// p := Inc ( p ) ;
11390: LD_ADDR_VAR 0 5
11394: PUSH
11395: LD_VAR 0 5
11399: PPUSH
11400: CALL 92884 0 1
11404: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11405: LD_VAR 0 2
11409: PPUSH
11410: LD_INT 92
11412: PUSH
11413: LD_INT 139
11415: PUSH
11416: LD_INT 89
11418: PUSH
11419: LD_INT 9
11421: PUSH
11422: EMPTY
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: PPUSH
11428: CALL_OW 72
11432: PUSH
11433: LD_VAR 0 2
11437: PUSH
11438: LD_INT 1
11440: MINUS
11441: GREATEREQUAL
11442: PUSH
11443: LD_VAR 0 5
11447: PUSH
11448: LD_INT 30
11450: GREATER
11451: OR
11452: IFFALSE 11305
// end else
11454: GO 11623
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11456: LD_VAR 0 2
11460: PPUSH
11461: LD_VAR 0 4
11465: PUSH
11466: LD_INT 1
11468: ARRAY
11469: PPUSH
11470: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11474: LD_ADDR_VAR 0 2
11478: PUSH
11479: LD_VAR 0 2
11483: PPUSH
11484: LD_INT 24
11486: PUSH
11487: LD_INT 250
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: PPUSH
11494: CALL_OW 72
11498: ST_TO_ADDR
// for i in tmp do
11499: LD_ADDR_VAR 0 1
11503: PUSH
11504: LD_VAR 0 2
11508: PUSH
11509: FOR_IN
11510: IFFALSE 11550
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11512: LD_VAR 0 1
11516: PPUSH
11517: LD_INT 124
11519: PPUSH
11520: LD_INT 139
11522: PPUSH
11523: CALL_OW 297
11527: PUSH
11528: LD_INT 9
11530: GREATER
11531: IFFALSE 11548
// ComMoveXY ( i , 124 , 139 ) ;
11533: LD_VAR 0 1
11537: PPUSH
11538: LD_INT 124
11540: PPUSH
11541: LD_INT 139
11543: PPUSH
11544: CALL_OW 111
11548: GO 11509
11550: POP
11551: POP
// wait ( 0 0$1 ) ;
11552: LD_INT 35
11554: PPUSH
11555: CALL_OW 67
// p := Inc ( p ) ;
11559: LD_ADDR_VAR 0 5
11563: PUSH
11564: LD_VAR 0 5
11568: PPUSH
11569: CALL 92884 0 1
11573: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11574: LD_VAR 0 2
11578: PPUSH
11579: LD_INT 92
11581: PUSH
11582: LD_INT 124
11584: PUSH
11585: LD_INT 139
11587: PUSH
11588: LD_INT 9
11590: PUSH
11591: EMPTY
11592: LIST
11593: LIST
11594: LIST
11595: LIST
11596: PPUSH
11597: CALL_OW 72
11601: PUSH
11602: LD_VAR 0 2
11606: PUSH
11607: LD_INT 1
11609: MINUS
11610: GREATEREQUAL
11611: PUSH
11612: LD_VAR 0 5
11616: PUSH
11617: LD_INT 30
11619: GREATER
11620: OR
11621: IFFALSE 11474
// end ; repeat wait ( 0 0$1 ) ;
11623: LD_INT 35
11625: PPUSH
11626: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11630: LD_ADDR_VAR 0 2
11634: PUSH
11635: LD_VAR 0 2
11639: PPUSH
11640: LD_INT 50
11642: PUSH
11643: EMPTY
11644: LIST
11645: PPUSH
11646: CALL_OW 72
11650: ST_TO_ADDR
// for i in tmp do
11651: LD_ADDR_VAR 0 1
11655: PUSH
11656: LD_VAR 0 2
11660: PUSH
11661: FOR_IN
11662: IFFALSE 11751
// begin if GetWeapon ( i ) = ru_time_lapser then
11664: LD_VAR 0 1
11668: PPUSH
11669: CALL_OW 264
11673: PUSH
11674: LD_INT 49
11676: EQUAL
11677: IFFALSE 11715
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11679: LD_VAR 0 1
11683: PPUSH
11684: LD_INT 81
11686: PUSH
11687: LD_INT 3
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: PPUSH
11694: CALL_OW 69
11698: PPUSH
11699: LD_VAR 0 1
11703: PPUSH
11704: CALL_OW 74
11708: PPUSH
11709: CALL_OW 112
11713: GO 11749
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11715: LD_VAR 0 1
11719: PPUSH
11720: LD_INT 81
11722: PUSH
11723: LD_INT 3
11725: PUSH
11726: EMPTY
11727: LIST
11728: LIST
11729: PPUSH
11730: CALL_OW 69
11734: PPUSH
11735: LD_VAR 0 1
11739: PPUSH
11740: CALL_OW 74
11744: PPUSH
11745: CALL_OW 115
// end ;
11749: GO 11661
11751: POP
11752: POP
// until not tmp ;
11753: LD_VAR 0 2
11757: NOT
11758: IFFALSE 11623
// end ;
11760: PPOPN 5
11762: END
// every 30 30$00 trigger not russianDestroyed do
11763: LD_EXP 2
11767: NOT
11768: IFFALSE 11837
11770: GO 11772
11772: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11773: LD_INT 105000
11775: PUSH
11776: LD_INT 84000
11778: PUSH
11779: LD_INT 63000
11781: PUSH
11782: LD_INT 52500
11784: PUSH
11785: EMPTY
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: PUSH
11791: LD_OWVAR 67
11795: ARRAY
11796: PPUSH
11797: CALL_OW 67
// if russianDestroyed then
11801: LD_EXP 2
11805: IFFALSE 11809
// exit ;
11807: GO 11837
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11809: LD_INT 2
11811: PPUSH
11812: LD_INT 23
11814: PUSH
11815: LD_INT 3
11817: PUSH
11818: LD_INT 1
11820: PUSH
11821: LD_INT 48
11823: PUSH
11824: EMPTY
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: PUSH
11830: EMPTY
11831: LIST
11832: PPUSH
11833: CALL 47302 0 2
// end ; end_of_file
11837: END
// export function CustomEvent ( event ) ; begin
11838: LD_INT 0
11840: PPUSH
// end ;
11841: LD_VAR 0 2
11845: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11846: LD_VAR 0 2
11850: PPUSH
11851: LD_VAR 0 3
11855: PPUSH
11856: LD_INT 15
11858: PPUSH
11859: CALL_OW 309
11863: IFFALSE 11872
// YouLost ( MothContaminate ) ;
11865: LD_STRING MothContaminate
11867: PPUSH
11868: CALL_OW 104
// end ;
11872: PPOPN 3
11874: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11875: LD_VAR 0 2
11879: PPUSH
11880: LD_VAR 0 3
11884: PPUSH
11885: LD_INT 15
11887: PPUSH
11888: CALL_OW 309
11892: IFFALSE 11908
// begin wait ( 0 0$6 ) ;
11894: LD_INT 210
11896: PPUSH
11897: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11901: LD_STRING MothContaminateBomb
11903: PPUSH
11904: CALL_OW 104
// end ; end ;
11908: PPOPN 3
11910: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11911: LD_VAR 0 1
11915: PPUSH
11916: CALL 112560 0 1
// if un = JMM then
11920: LD_VAR 0 1
11924: PUSH
11925: LD_EXP 21
11929: EQUAL
11930: IFFALSE 11941
// begin YouLost ( JMM ) ;
11932: LD_STRING JMM
11934: PPUSH
11935: CALL_OW 104
// exit ;
11939: GO 12090
// end ; if un = Omar then
11941: LD_VAR 0 1
11945: PUSH
11946: LD_EXP 58
11950: EQUAL
11951: IFFALSE 11961
// omarKilled := true ;
11953: LD_ADDR_EXP 20
11957: PUSH
11958: LD_INT 1
11960: ST_TO_ADDR
// if GetSide ( un ) = 2 and not arabianAttacked then
11961: LD_VAR 0 1
11965: PPUSH
11966: CALL_OW 255
11970: PUSH
11971: LD_INT 2
11973: EQUAL
11974: PUSH
11975: LD_EXP 18
11979: NOT
11980: AND
11981: IFFALSE 11991
// arabianAttacked := true ;
11983: LD_ADDR_EXP 18
11987: PUSH
11988: LD_INT 1
11990: ST_TO_ADDR
// if un = Powell then
11991: LD_VAR 0 1
11995: PUSH
11996: LD_EXP 57
12000: EQUAL
12001: IFFALSE 12011
// americanDestroyed := true ;
12003: LD_ADDR_EXP 4
12007: PUSH
12008: LD_INT 1
12010: ST_TO_ADDR
// if un = Platonov then
12011: LD_VAR 0 1
12015: PUSH
12016: LD_EXP 62
12020: EQUAL
12021: IFFALSE 12031
// russianDestroyed := true ;
12023: LD_ADDR_EXP 2
12027: PUSH
12028: LD_INT 1
12030: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
12031: LD_VAR 0 1
12035: PUSH
12036: LD_INT 22
12038: PUSH
12039: LD_INT 7
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 21
12048: PUSH
12049: LD_INT 2
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PPUSH
12060: CALL_OW 69
12064: IN
12065: IFFALSE 12081
// vehicleLostCounter := vehicleLostCounter + 1 ;
12067: LD_ADDR_EXP 15
12071: PUSH
12072: LD_EXP 15
12076: PUSH
12077: LD_INT 1
12079: PLUS
12080: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
12081: LD_VAR 0 1
12085: PPUSH
12086: CALL 50744 0 1
// end ;
12090: PPOPN 1
12092: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12093: LD_VAR 0 1
12097: PPUSH
12098: LD_VAR 0 2
12102: PPUSH
12103: CALL 53076 0 2
// end ;
12107: PPOPN 2
12109: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12110: LD_VAR 0 1
12114: PPUSH
12115: CALL 52144 0 1
// end ;
12119: PPOPN 1
12121: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
12122: LD_VAR 0 1
12126: PUSH
12127: LD_INT 22
12129: PUSH
12130: LD_INT 8
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: PUSH
12137: LD_INT 30
12139: PUSH
12140: LD_INT 2
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_INT 23
12149: PUSH
12150: LD_INT 3
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PUSH
12157: EMPTY
12158: LIST
12159: LIST
12160: LIST
12161: PPUSH
12162: CALL_OW 69
12166: IN
12167: IFFALSE 12194
// begin ComUpgrade ( building ) ;
12169: LD_VAR 0 1
12173: PPUSH
12174: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
12178: LD_EXP 60
12182: PPUSH
12183: LD_VAR 0 1
12187: PPUSH
12188: CALL 62012 0 2
// exit ;
12192: GO 12203
// end ; MCE_BuildingComplete ( building ) ;
12194: LD_VAR 0 1
12198: PPUSH
12199: CALL 52385 0 1
// end ;
12203: PPOPN 1
12205: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12206: LD_VAR 0 1
12210: PPUSH
12211: LD_VAR 0 2
12215: PPUSH
12216: CALL 50440 0 2
// end ;
12220: PPOPN 2
12222: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12223: LD_VAR 0 1
12227: PPUSH
12228: LD_VAR 0 2
12232: PPUSH
12233: LD_VAR 0 3
12237: PPUSH
12238: LD_VAR 0 4
12242: PPUSH
12243: LD_VAR 0 5
12247: PPUSH
12248: CALL 50060 0 5
// end ;
12252: PPOPN 5
12254: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
12255: LD_VAR 0 1
12259: PPUSH
12260: LD_VAR 0 2
12264: PPUSH
12265: CALL 112618 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
12269: LD_VAR 0 1
12273: PPUSH
12274: LD_VAR 0 2
12278: PPUSH
12279: CALL 49613 0 2
// end ;
12283: PPOPN 2
12285: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12286: LD_VAR 0 1
12290: PPUSH
12291: LD_VAR 0 2
12295: PPUSH
12296: LD_VAR 0 3
12300: PPUSH
12301: LD_VAR 0 4
12305: PPUSH
12306: CALL 49451 0 4
// end ;
12310: PPOPN 4
12312: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12313: LD_VAR 0 1
12317: PPUSH
12318: LD_VAR 0 2
12322: PPUSH
12323: LD_VAR 0 3
12327: PPUSH
12328: CALL 49226 0 3
// end ;
12332: PPOPN 3
12334: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12335: LD_VAR 0 1
12339: PPUSH
12340: LD_VAR 0 2
12344: PPUSH
12345: CALL 49111 0 2
// end ;
12349: PPOPN 2
12351: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12352: LD_VAR 0 1
12356: PPUSH
12357: LD_VAR 0 2
12361: PPUSH
12362: CALL 53371 0 2
// end ;
12366: PPOPN 2
12368: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
12369: LD_VAR 0 1
12373: PUSH
12374: LD_INT 674
12376: EQUAL
12377: IFFALSE 12399
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
12379: LD_VAR 0 2
12383: PPUSH
12384: LD_INT 227
12386: PPUSH
12387: LD_INT 136
12389: PPUSH
12390: CALL_OW 428
12394: PPUSH
12395: CALL_OW 120
// end ;
12399: PPOPN 2
12401: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12402: LD_VAR 0 1
12406: PPUSH
12407: LD_VAR 0 2
12411: PPUSH
12412: LD_VAR 0 3
12416: PPUSH
12417: LD_VAR 0 4
12421: PPUSH
12422: CALL 53587 0 4
// end ;
12426: PPOPN 4
12428: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12429: LD_VAR 0 1
12433: PPUSH
12434: LD_VAR 0 2
12438: PPUSH
12439: CALL 48920 0 2
// end ;
12443: PPOPN 2
12445: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12446: LD_VAR 0 1
12450: PPUSH
12451: CALL 112602 0 1
// end ; end_of_file
12455: PPOPN 1
12457: END
// export function Action ; begin
12458: LD_INT 0
12460: PPUSH
// InGameOn ;
12461: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
12465: LD_INT 206
12467: PPUSH
12468: LD_INT 11
12470: PPUSH
12471: CALL_OW 86
// wait ( 0 0$1 ) ;
12475: LD_INT 35
12477: PPUSH
12478: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
12482: LD_EXP 21
12486: PPUSH
12487: LD_STRING DStart-JMM-JMM-1
12489: PPUSH
12490: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
12494: LD_EXP 54
12498: PPUSH
12499: LD_STRING DStart-JMM-Bur-1
12501: PPUSH
12502: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
12506: LD_EXP 21
12510: PPUSH
12511: LD_STRING DStart-JMM-JMM-2
12513: PPUSH
12514: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
12518: LD_EXP 54
12522: PPUSH
12523: LD_STRING DStart-JMM-Bur-2
12525: PPUSH
12526: CALL_OW 88
// InGameOff ;
12530: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
12534: LD_STRING MStart
12536: PPUSH
12537: CALL_OW 337
// SaveForQuickRestart ;
12541: CALL_OW 22
// end ;
12545: LD_VAR 0 1
12549: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
12550: LD_INT 7
12552: PPUSH
12553: LD_INT 255
12555: PPUSH
12556: LD_INT 219
12558: PPUSH
12559: CALL_OW 293
12563: IFFALSE 13172
12565: GO 12567
12567: DISABLE
12568: LD_INT 0
12570: PPUSH
// begin wait ( 0 0$3 ) ;
12571: LD_INT 105
12573: PPUSH
12574: CALL_OW 67
// alienSpotted := true ;
12578: LD_ADDR_EXP 10
12582: PUSH
12583: LD_INT 1
12585: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12586: LD_ADDR_VAR 0 1
12590: PUSH
12591: LD_INT 22
12593: PUSH
12594: LD_INT 7
12596: PUSH
12597: EMPTY
12598: LIST
12599: LIST
12600: PUSH
12601: LD_INT 23
12603: PUSH
12604: LD_INT 3
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PUSH
12611: LD_INT 21
12613: PUSH
12614: LD_INT 1
12616: PUSH
12617: EMPTY
12618: LIST
12619: LIST
12620: PUSH
12621: LD_INT 26
12623: PUSH
12624: LD_INT 1
12626: PUSH
12627: EMPTY
12628: LIST
12629: LIST
12630: PUSH
12631: EMPTY
12632: LIST
12633: LIST
12634: LIST
12635: LIST
12636: PPUSH
12637: CALL_OW 69
12641: PUSH
12642: LD_EXP 54
12646: PUSH
12647: LD_EXP 42
12651: PUSH
12652: LD_EXP 44
12656: PUSH
12657: LD_EXP 45
12661: PUSH
12662: LD_EXP 52
12666: PUSH
12667: LD_EXP 51
12671: PUSH
12672: LD_EXP 46
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: DIFF
12686: ST_TO_ADDR
// DialogueOn ;
12687: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12691: LD_INT 255
12693: PPUSH
12694: LD_INT 219
12696: PPUSH
12697: LD_INT 7
12699: PPUSH
12700: LD_INT 20
12702: NEG
12703: PPUSH
12704: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12708: LD_INT 255
12710: PPUSH
12711: LD_INT 219
12713: PPUSH
12714: CALL_OW 86
// if speaker then
12718: LD_VAR 0 1
12722: IFFALSE 12740
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12724: LD_VAR 0 1
12728: PUSH
12729: LD_INT 1
12731: ARRAY
12732: PPUSH
12733: LD_STRING DAlienBase-RSol1-1
12735: PPUSH
12736: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12740: LD_EXP 21
12744: PPUSH
12745: LD_STRING DAlienBase-JMM-1
12747: PPUSH
12748: CALL_OW 88
// if IsOk ( Burlak ) then
12752: LD_EXP 54
12756: PPUSH
12757: CALL_OW 302
12761: IFFALSE 12782
// begin dwait ( 0 0$1 ) ;
12763: LD_INT 35
12765: PPUSH
12766: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12770: LD_EXP 54
12774: PPUSH
12775: LD_STRING DAlienBase-Bur-1
12777: PPUSH
12778: CALL_OW 88
// end ; if IsOk ( Roth ) then
12782: LD_EXP 22
12786: PPUSH
12787: CALL_OW 302
12791: IFFALSE 12805
// Say ( Roth , DAlienBase-Roth-1 ) ;
12793: LD_EXP 22
12797: PPUSH
12798: LD_STRING DAlienBase-Roth-1
12800: PPUSH
12801: CALL_OW 88
// if IsOk ( Gossudarov ) then
12805: LD_EXP 40
12809: PPUSH
12810: CALL_OW 302
12814: IFFALSE 12830
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12816: LD_EXP 40
12820: PPUSH
12821: LD_STRING DAlienBase-Gos-1
12823: PPUSH
12824: CALL_OW 88
12828: GO 12947
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12830: LD_ADDR_VAR 0 1
12834: PUSH
12835: LD_INT 22
12837: PUSH
12838: LD_INT 7
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: PUSH
12845: LD_INT 25
12847: PUSH
12848: LD_INT 4
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: PUSH
12855: LD_INT 21
12857: PUSH
12858: LD_INT 1
12860: PUSH
12861: EMPTY
12862: LIST
12863: LIST
12864: PUSH
12865: LD_INT 26
12867: PUSH
12868: LD_INT 1
12870: PUSH
12871: EMPTY
12872: LIST
12873: LIST
12874: PUSH
12875: EMPTY
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: PPUSH
12881: CALL_OW 69
12885: PUSH
12886: LD_EXP 22
12890: PUSH
12891: LD_EXP 21
12895: PUSH
12896: LD_EXP 54
12900: PUSH
12901: LD_EXP 42
12905: PUSH
12906: LD_EXP 52
12910: PUSH
12911: LD_EXP 51
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: DIFF
12924: ST_TO_ADDR
// if speaker then
12925: LD_VAR 0 1
12929: IFFALSE 12947
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12931: LD_VAR 0 1
12935: PUSH
12936: LD_INT 1
12938: ARRAY
12939: PPUSH
12940: LD_STRING DAlienBase-Sci1-1
12942: PPUSH
12943: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12947: LD_INT 255
12949: PPUSH
12950: LD_INT 219
12952: PPUSH
12953: LD_INT 7
12955: PPUSH
12956: CALL_OW 331
// DialogueOff ;
12960: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12964: LD_INT 35
12966: PPUSH
12967: CALL_OW 67
// until IsSelected ( alien ) ;
12971: LD_INT 1
12973: PPUSH
12974: CALL_OW 306
12978: IFFALSE 12964
// if not artifactIResearched or not artifactIIResearched then
12980: LD_EXP 12
12984: NOT
12985: PUSH
12986: LD_EXP 13
12990: NOT
12991: OR
12992: IFFALSE 13172
// begin if IsOk ( Roth ) then
12994: LD_EXP 22
12998: PPUSH
12999: CALL_OW 302
13003: IFFALSE 13019
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
13005: LD_EXP 22
13009: PPUSH
13010: LD_STRING DAlieBaseNotReady-Roth-1
13012: PPUSH
13013: CALL_OW 88
13017: GO 13172
// if IsOk ( Gossudarov ) then
13019: LD_EXP 40
13023: PPUSH
13024: CALL_OW 302
13028: IFFALSE 13044
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
13030: LD_EXP 40
13034: PPUSH
13035: LD_STRING DAlieBaseNotReady-Gos-1
13037: PPUSH
13038: CALL_OW 88
13042: GO 13172
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13044: LD_ADDR_VAR 0 1
13048: PUSH
13049: LD_INT 22
13051: PUSH
13052: LD_INT 7
13054: PUSH
13055: EMPTY
13056: LIST
13057: LIST
13058: PUSH
13059: LD_INT 23
13061: PUSH
13062: LD_INT 3
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: PUSH
13069: LD_INT 25
13071: PUSH
13072: LD_INT 4
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: PUSH
13079: LD_INT 21
13081: PUSH
13082: LD_INT 1
13084: PUSH
13085: EMPTY
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 26
13091: PUSH
13092: LD_INT 1
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: LIST
13103: LIST
13104: LIST
13105: PPUSH
13106: CALL_OW 69
13110: PUSH
13111: LD_EXP 22
13115: PUSH
13116: LD_EXP 21
13120: PUSH
13121: LD_EXP 54
13125: PUSH
13126: LD_EXP 42
13130: PUSH
13131: LD_EXP 52
13135: PUSH
13136: LD_EXP 51
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: LIST
13148: DIFF
13149: ST_TO_ADDR
// if speaker then
13150: LD_VAR 0 1
13154: IFFALSE 13172
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
13156: LD_VAR 0 1
13160: PUSH
13161: LD_INT 1
13163: ARRAY
13164: PPUSH
13165: LD_STRING DAlieBaseNotReady-RSci1-1
13167: PPUSH
13168: CALL_OW 88
// end ; end ; end ;
13172: PPOPN 1
13174: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
13175: LD_INT 24
13177: PPUSH
13178: LD_INT 7
13180: PPUSH
13181: CALL_OW 321
13185: PUSH
13186: LD_INT 2
13188: EQUAL
13189: IFFALSE 13880
13191: GO 13193
13193: DISABLE
13194: LD_INT 0
13196: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13197: LD_ADDR_VAR 0 1
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 7
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: LD_INT 23
13214: PUSH
13215: LD_INT 3
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: LD_INT 25
13224: PUSH
13225: LD_INT 4
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PUSH
13232: LD_INT 21
13234: PUSH
13235: LD_INT 1
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: LD_INT 26
13244: PUSH
13245: LD_INT 1
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: PUSH
13252: EMPTY
13253: LIST
13254: LIST
13255: LIST
13256: LIST
13257: LIST
13258: PPUSH
13259: CALL_OW 69
13263: PUSH
13264: LD_EXP 22
13268: PUSH
13269: LD_EXP 21
13273: PUSH
13274: LD_EXP 54
13278: PUSH
13279: LD_EXP 42
13283: PUSH
13284: LD_EXP 52
13288: PUSH
13289: LD_EXP 51
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: LIST
13301: DIFF
13302: ST_TO_ADDR
// if not speaker then
13303: LD_VAR 0 1
13307: NOT
13308: IFFALSE 13312
// exit ;
13310: GO 13880
// DialogueOn ;
13312: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
13316: LD_VAR 0 1
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: PPUSH
13325: LD_STRING DArtefTechnology-RSci1-1
13327: PPUSH
13328: CALL_OW 88
// if IsOk ( Burlak ) then
13332: LD_EXP 54
13336: PPUSH
13337: CALL_OW 302
13341: IFFALSE 13355
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
13343: LD_EXP 54
13347: PPUSH
13348: LD_STRING DArtefTechnology-Bur-1
13350: PPUSH
13351: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
13355: LD_VAR 0 1
13359: PUSH
13360: LD_INT 1
13362: ARRAY
13363: PPUSH
13364: LD_STRING DArtefTechnology-RSci1-2
13366: PPUSH
13367: CALL_OW 88
// if Denis then
13371: LD_EXP 27
13375: IFFALSE 13392
// speaker := [ Denis ] else
13377: LD_ADDR_VAR 0 1
13381: PUSH
13382: LD_EXP 27
13386: PUSH
13387: EMPTY
13388: LIST
13389: ST_TO_ADDR
13390: GO 13498
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13392: LD_ADDR_VAR 0 1
13396: PUSH
13397: LD_INT 22
13399: PUSH
13400: LD_INT 7
13402: PUSH
13403: EMPTY
13404: LIST
13405: LIST
13406: PUSH
13407: LD_INT 23
13409: PUSH
13410: LD_INT 1
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: PUSH
13417: LD_INT 25
13419: PUSH
13420: LD_INT 4
13422: PUSH
13423: EMPTY
13424: LIST
13425: LIST
13426: PUSH
13427: LD_INT 21
13429: PUSH
13430: LD_INT 1
13432: PUSH
13433: EMPTY
13434: LIST
13435: LIST
13436: PUSH
13437: LD_INT 26
13439: PUSH
13440: LD_INT 1
13442: PUSH
13443: EMPTY
13444: LIST
13445: LIST
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: PPUSH
13454: CALL_OW 69
13458: PUSH
13459: LD_EXP 22
13463: PUSH
13464: LD_EXP 21
13468: PUSH
13469: LD_EXP 54
13473: PUSH
13474: LD_EXP 42
13478: PUSH
13479: LD_EXP 52
13483: PUSH
13484: LD_EXP 51
13488: PUSH
13489: EMPTY
13490: LIST
13491: LIST
13492: LIST
13493: LIST
13494: LIST
13495: LIST
13496: DIFF
13497: ST_TO_ADDR
// if speaker then
13498: LD_VAR 0 1
13502: IFFALSE 13520
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
13504: LD_VAR 0 1
13508: PUSH
13509: LD_INT 1
13511: ARRAY
13512: PPUSH
13513: LD_STRING DArtefTechnology-Sci1-2
13515: PPUSH
13516: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13520: LD_ADDR_VAR 0 1
13524: PUSH
13525: LD_INT 22
13527: PUSH
13528: LD_INT 7
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: PUSH
13535: LD_INT 23
13537: PUSH
13538: LD_INT 3
13540: PUSH
13541: EMPTY
13542: LIST
13543: LIST
13544: PUSH
13545: LD_INT 25
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PUSH
13555: LD_INT 21
13557: PUSH
13558: LD_INT 1
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PUSH
13565: LD_INT 26
13567: PUSH
13568: LD_INT 1
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: LIST
13579: LIST
13580: LIST
13581: PPUSH
13582: CALL_OW 69
13586: PUSH
13587: LD_EXP 22
13591: PUSH
13592: LD_EXP 21
13596: PUSH
13597: LD_EXP 54
13601: PUSH
13602: LD_EXP 42
13606: PUSH
13607: LD_EXP 52
13611: PUSH
13612: LD_EXP 51
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: DIFF
13625: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13626: LD_VAR 0 1
13630: PUSH
13631: LD_EXP 9
13635: PUSH
13636: LD_EXP 5
13640: OR
13641: AND
13642: IFFALSE 13876
// begin if arabianDestroyed and IsOk ( Burlak ) then
13644: LD_EXP 5
13648: PUSH
13649: LD_EXP 54
13653: PPUSH
13654: CALL_OW 302
13658: AND
13659: IFFALSE 13675
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13661: LD_EXP 54
13665: PPUSH
13666: LD_STRING DArtefTechnology-Bur-2
13668: PPUSH
13669: CALL_OW 88
13673: GO 13687
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13675: LD_EXP 21
13679: PPUSH
13680: LD_STRING DArtefTechnology-JMM-2
13682: PPUSH
13683: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13687: LD_VAR 0 1
13691: PUSH
13692: LD_INT 1
13694: ARRAY
13695: PPUSH
13696: LD_STRING DArtefTechnology-RSci1-3
13698: PPUSH
13699: CALL_OW 88
// if Denis then
13703: LD_EXP 27
13707: IFFALSE 13724
// speaker := [ Denis ] else
13709: LD_ADDR_VAR 0 1
13713: PUSH
13714: LD_EXP 27
13718: PUSH
13719: EMPTY
13720: LIST
13721: ST_TO_ADDR
13722: GO 13830
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13724: LD_ADDR_VAR 0 1
13728: PUSH
13729: LD_INT 22
13731: PUSH
13732: LD_INT 7
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: PUSH
13739: LD_INT 23
13741: PUSH
13742: LD_INT 1
13744: PUSH
13745: EMPTY
13746: LIST
13747: LIST
13748: PUSH
13749: LD_INT 25
13751: PUSH
13752: LD_INT 4
13754: PUSH
13755: EMPTY
13756: LIST
13757: LIST
13758: PUSH
13759: LD_INT 21
13761: PUSH
13762: LD_INT 1
13764: PUSH
13765: EMPTY
13766: LIST
13767: LIST
13768: PUSH
13769: LD_INT 26
13771: PUSH
13772: LD_INT 1
13774: PUSH
13775: EMPTY
13776: LIST
13777: LIST
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: LIST
13783: LIST
13784: LIST
13785: PPUSH
13786: CALL_OW 69
13790: PUSH
13791: LD_EXP 22
13795: PUSH
13796: LD_EXP 21
13800: PUSH
13801: LD_EXP 54
13805: PUSH
13806: LD_EXP 42
13810: PUSH
13811: LD_EXP 52
13815: PUSH
13816: LD_EXP 51
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: LIST
13827: LIST
13828: DIFF
13829: ST_TO_ADDR
// if speaker then
13830: LD_VAR 0 1
13834: IFFALSE 13876
// if alienSpotted then
13836: LD_EXP 10
13840: IFFALSE 13860
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13842: LD_VAR 0 1
13846: PUSH
13847: LD_INT 1
13849: ARRAY
13850: PPUSH
13851: LD_STRING DArtefTechnology-Sci1-3
13853: PPUSH
13854: CALL_OW 88
13858: GO 13876
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13860: LD_VAR 0 1
13864: PUSH
13865: LD_INT 1
13867: ARRAY
13868: PPUSH
13869: LD_STRING DArtefTechnology-Sci1-3a
13871: PPUSH
13872: CALL_OW 88
// end ; DialogueOff ;
13876: CALL_OW 7
// end ;
13880: PPOPN 1
13882: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13883: LD_EXP 12
13887: IFFALSE 14090
13889: GO 13891
13891: DISABLE
13892: LD_INT 0
13894: PPUSH
// begin if Denis then
13895: LD_EXP 27
13899: IFFALSE 13916
// speaker := [ Denis ] else
13901: LD_ADDR_VAR 0 1
13905: PUSH
13906: LD_EXP 27
13910: PUSH
13911: EMPTY
13912: LIST
13913: ST_TO_ADDR
13914: GO 14022
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13916: LD_ADDR_VAR 0 1
13920: PUSH
13921: LD_INT 22
13923: PUSH
13924: LD_INT 7
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: PUSH
13931: LD_INT 23
13933: PUSH
13934: LD_INT 1
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: PUSH
13941: LD_INT 25
13943: PUSH
13944: LD_INT 4
13946: PUSH
13947: EMPTY
13948: LIST
13949: LIST
13950: PUSH
13951: LD_INT 21
13953: PUSH
13954: LD_INT 1
13956: PUSH
13957: EMPTY
13958: LIST
13959: LIST
13960: PUSH
13961: LD_INT 26
13963: PUSH
13964: LD_INT 1
13966: PUSH
13967: EMPTY
13968: LIST
13969: LIST
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: LIST
13977: PPUSH
13978: CALL_OW 69
13982: PUSH
13983: LD_EXP 22
13987: PUSH
13988: LD_EXP 21
13992: PUSH
13993: LD_EXP 54
13997: PUSH
13998: LD_EXP 42
14002: PUSH
14003: LD_EXP 52
14007: PUSH
14008: LD_EXP 51
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: LIST
14017: LIST
14018: LIST
14019: LIST
14020: DIFF
14021: ST_TO_ADDR
// if not speaker then
14022: LD_VAR 0 1
14026: NOT
14027: IFFALSE 14031
// exit ;
14029: GO 14090
// DialogueOn ;
14031: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
14035: LD_VAR 0 1
14039: PUSH
14040: LD_INT 1
14042: ARRAY
14043: PPUSH
14044: LD_STRING DArtefTechnologyAm-Sci1-1
14046: PPUSH
14047: CALL_OW 88
// if IsOk ( Burlak ) then
14051: LD_EXP 54
14055: PPUSH
14056: CALL_OW 302
14060: IFFALSE 14074
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
14062: LD_EXP 54
14066: PPUSH
14067: LD_STRING DArtefTechnologyAm-Bur-1
14069: PPUSH
14070: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
14074: LD_EXP 21
14078: PPUSH
14079: LD_STRING DArtefTechnologyAm-JMM-1
14081: PPUSH
14082: CALL_OW 88
// DialogueOff ;
14086: CALL_OW 7
// end ;
14090: PPOPN 1
14092: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
14093: LD_EXP 13
14097: IFFALSE 14299
14099: GO 14101
14101: DISABLE
14102: LD_INT 0
14104: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14105: LD_ADDR_VAR 0 1
14109: PUSH
14110: LD_INT 22
14112: PUSH
14113: LD_INT 7
14115: PUSH
14116: EMPTY
14117: LIST
14118: LIST
14119: PUSH
14120: LD_INT 23
14122: PUSH
14123: LD_INT 3
14125: PUSH
14126: EMPTY
14127: LIST
14128: LIST
14129: PUSH
14130: LD_INT 25
14132: PUSH
14133: LD_INT 4
14135: PUSH
14136: EMPTY
14137: LIST
14138: LIST
14139: PUSH
14140: LD_INT 21
14142: PUSH
14143: LD_INT 1
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PUSH
14150: LD_INT 26
14152: PUSH
14153: LD_INT 1
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: PUSH
14160: EMPTY
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: PPUSH
14167: CALL_OW 69
14171: PUSH
14172: LD_EXP 22
14176: PUSH
14177: LD_EXP 21
14181: PUSH
14182: LD_EXP 54
14186: PUSH
14187: LD_EXP 42
14191: PUSH
14192: LD_EXP 52
14196: PUSH
14197: LD_EXP 51
14201: PUSH
14202: EMPTY
14203: LIST
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: DIFF
14210: ST_TO_ADDR
// if not speaker then
14211: LD_VAR 0 1
14215: NOT
14216: IFFALSE 14220
// exit ;
14218: GO 14299
// DialogueOn ;
14220: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
14224: LD_VAR 0 1
14228: PUSH
14229: LD_VAR 0 1
14233: ARRAY
14234: PPUSH
14235: LD_STRING DArtefTechnologyRu-RSci1-1
14237: PPUSH
14238: CALL_OW 88
// if IsOk ( Burlak ) then
14242: LD_EXP 54
14246: PPUSH
14247: CALL_OW 302
14251: IFFALSE 14265
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
14253: LD_EXP 54
14257: PPUSH
14258: LD_STRING DArtefTechnologyRu-Bur-1
14260: PPUSH
14261: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
14265: LD_VAR 0 1
14269: PUSH
14270: LD_VAR 0 1
14274: ARRAY
14275: PPUSH
14276: LD_STRING DArtefTechnologyRu-RSci1-2
14278: PPUSH
14279: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
14283: LD_EXP 21
14287: PPUSH
14288: LD_STRING DArtefTechnologyRu-JMM-1
14290: PPUSH
14291: CALL_OW 88
// DialogueOff ;
14295: CALL_OW 7
// end ;
14299: PPOPN 1
14301: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
14302: LD_INT 24
14304: PPUSH
14305: LD_INT 7
14307: PPUSH
14308: CALL_OW 321
14312: PUSH
14313: LD_INT 2
14315: EQUAL
14316: PUSH
14317: LD_INT 1
14319: PPUSH
14320: CALL_OW 255
14324: PUSH
14325: LD_INT 7
14327: EQUAL
14328: AND
14329: IFFALSE 14497
14331: GO 14333
14333: DISABLE
14334: LD_INT 0
14336: PPUSH
// begin if Denis then
14337: LD_EXP 27
14341: IFFALSE 14358
// speaker := [ Denis ] else
14343: LD_ADDR_VAR 0 1
14347: PUSH
14348: LD_EXP 27
14352: PUSH
14353: EMPTY
14354: LIST
14355: ST_TO_ADDR
14356: GO 14464
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14358: LD_ADDR_VAR 0 1
14362: PUSH
14363: LD_INT 22
14365: PUSH
14366: LD_INT 7
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: PUSH
14373: LD_INT 23
14375: PUSH
14376: LD_INT 1
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: PUSH
14383: LD_INT 25
14385: PUSH
14386: LD_INT 4
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PUSH
14393: LD_INT 21
14395: PUSH
14396: LD_INT 1
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: PUSH
14403: LD_INT 26
14405: PUSH
14406: LD_INT 1
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: PUSH
14413: EMPTY
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: PPUSH
14420: CALL_OW 69
14424: PUSH
14425: LD_EXP 22
14429: PUSH
14430: LD_EXP 21
14434: PUSH
14435: LD_EXP 54
14439: PUSH
14440: LD_EXP 42
14444: PUSH
14445: LD_EXP 52
14449: PUSH
14450: LD_EXP 51
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: LIST
14462: DIFF
14463: ST_TO_ADDR
// if not speaker then
14464: LD_VAR 0 1
14468: NOT
14469: IFFALSE 14473
// exit ;
14471: GO 14497
// DialogueOn ;
14473: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
14477: LD_VAR 0 1
14481: PUSH
14482: LD_INT 1
14484: ARRAY
14485: PPUSH
14486: LD_STRING DArtefTechnologyArStart-Sci1-1
14488: PPUSH
14489: CALL_OW 88
// DialogueOff ;
14493: CALL_OW 7
// end ;
14497: PPOPN 1
14499: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
14500: LD_EXP 14
14504: IFFALSE 14785
14506: GO 14508
14508: DISABLE
14509: LD_INT 0
14511: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14512: LD_ADDR_VAR 0 1
14516: PUSH
14517: LD_INT 22
14519: PUSH
14520: LD_INT 7
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: PUSH
14527: LD_INT 23
14529: PUSH
14530: LD_INT 3
14532: PUSH
14533: EMPTY
14534: LIST
14535: LIST
14536: PUSH
14537: LD_INT 25
14539: PUSH
14540: LD_INT 4
14542: PUSH
14543: EMPTY
14544: LIST
14545: LIST
14546: PUSH
14547: LD_INT 21
14549: PUSH
14550: LD_INT 1
14552: PUSH
14553: EMPTY
14554: LIST
14555: LIST
14556: PUSH
14557: LD_INT 26
14559: PUSH
14560: LD_INT 1
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: PPUSH
14574: CALL_OW 69
14578: PUSH
14579: LD_EXP 22
14583: PUSH
14584: LD_EXP 21
14588: PUSH
14589: LD_EXP 54
14593: PUSH
14594: LD_EXP 42
14598: PUSH
14599: LD_EXP 52
14603: PUSH
14604: LD_EXP 51
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: DIFF
14617: ST_TO_ADDR
// if not speaker then
14618: LD_VAR 0 1
14622: NOT
14623: IFFALSE 14627
// exit ;
14625: GO 14785
// DialogueOn ;
14627: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14631: LD_VAR 0 1
14635: PUSH
14636: LD_INT 1
14638: ARRAY
14639: PPUSH
14640: LD_STRING DArtefTechnologyAr-RSci1-1
14642: PPUSH
14643: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14647: LD_EXP 21
14651: PPUSH
14652: LD_STRING DArtefTechnologyAr-JMM-1
14654: PPUSH
14655: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14659: LD_VAR 0 1
14663: PUSH
14664: LD_INT 1
14666: ARRAY
14667: PPUSH
14668: LD_STRING DArtefTechnologyAr-RSci1-2
14670: PPUSH
14671: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14675: LD_EXP 21
14679: PPUSH
14680: LD_STRING DArtefTechnologyAr-JMM-2
14682: PPUSH
14683: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14687: LD_VAR 0 1
14691: PUSH
14692: LD_INT 1
14694: ARRAY
14695: PPUSH
14696: LD_STRING DArtefTechnologyAr-RSci1-3
14698: PPUSH
14699: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14703: LD_EXP 21
14707: PPUSH
14708: LD_STRING DArtefTechnologyAr-JMM-3
14710: PPUSH
14711: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14715: LD_VAR 0 1
14719: PUSH
14720: LD_INT 1
14722: ARRAY
14723: PPUSH
14724: LD_STRING DArtefTechnologyAr-RSci1-4
14726: PPUSH
14727: CALL_OW 88
// if IsOk ( Burlak ) then
14731: LD_EXP 54
14735: PPUSH
14736: CALL_OW 302
14740: IFFALSE 14754
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14742: LD_EXP 54
14746: PPUSH
14747: LD_STRING DArtefTechnologyAr-Bur-4
14749: PPUSH
14750: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14754: LD_EXP 21
14758: PPUSH
14759: LD_STRING DArtefTechnologyAr-JMM-4
14761: PPUSH
14762: CALL_OW 88
// DialogueOff ;
14766: CALL_OW 7
// wait ( 0 0$45 ) ;
14770: LD_INT 1575
14772: PPUSH
14773: CALL_OW 67
// spawnOmar := true ;
14777: LD_ADDR_EXP 11
14781: PUSH
14782: LD_INT 1
14784: ST_TO_ADDR
// end ;
14785: PPOPN 1
14787: END
// every 0 0$1 trigger spawnOmar and negotiationWithArabs do
14788: LD_EXP 11
14792: PUSH
14793: LD_EXP 19
14797: AND
14798: IFFALSE 15177
14800: GO 14802
14802: DISABLE
// begin PrepareOmarAli ;
14803: CALL 7606 0 0
// if not HasTask ( Omar ) then
14807: LD_EXP 58
14811: PPUSH
14812: CALL_OW 314
14816: NOT
14817: IFFALSE 14834
// ComMoveXY ( Omar , 252 , 220 ) ;
14819: LD_EXP 58
14823: PPUSH
14824: LD_INT 252
14826: PPUSH
14827: LD_INT 220
14829: PPUSH
14830: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14834: LD_INT 35
14836: PPUSH
14837: CALL_OW 67
// if omarKilled then
14841: LD_EXP 20
14845: IFFALSE 14849
// exit ;
14847: GO 15177
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14849: LD_EXP 58
14853: PPUSH
14854: CALL_OW 314
14858: NOT
14859: PUSH
14860: LD_EXP 58
14864: PPUSH
14865: LD_INT 252
14867: PPUSH
14868: LD_INT 220
14870: PPUSH
14871: CALL_OW 297
14875: PUSH
14876: LD_INT 6
14878: GREATER
14879: AND
14880: IFFALSE 14897
// ComMoveXY ( Omar , 252 , 220 ) ;
14882: LD_EXP 58
14886: PPUSH
14887: LD_INT 252
14889: PPUSH
14890: LD_INT 220
14892: PPUSH
14893: CALL_OW 111
// until See ( 7 , Omar ) ;
14897: LD_INT 7
14899: PPUSH
14900: LD_EXP 58
14904: PPUSH
14905: CALL_OW 292
14909: IFFALSE 14834
// CenterNowOnUnits ( Omar ) ;
14911: LD_EXP 58
14915: PPUSH
14916: CALL_OW 87
// DialogueOn ;
14920: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14924: LD_EXP 58
14928: PPUSH
14929: LD_STRING DOmar-Omar-1
14931: PPUSH
14932: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14936: LD_EXP 21
14940: PPUSH
14941: LD_STRING DOmar-JMM-1
14943: PPUSH
14944: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14948: LD_EXP 58
14952: PPUSH
14953: LD_STRING DOmar-Omar-2
14955: PPUSH
14956: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14960: LD_EXP 21
14964: PPUSH
14965: LD_STRING DOmar-JMM-2
14967: PPUSH
14968: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14972: LD_EXP 58
14976: PPUSH
14977: LD_STRING DOmar-Omar-3
14979: PPUSH
14980: CALL_OW 88
// if IsOk ( Burlak ) then
14984: LD_EXP 54
14988: PPUSH
14989: CALL_OW 302
14993: IFFALSE 15009
// Say ( Burlak , DOmar-Bur-3 ) else
14995: LD_EXP 54
14999: PPUSH
15000: LD_STRING DOmar-Bur-3
15002: PPUSH
15003: CALL_OW 88
15007: GO 15021
// Say ( JMM , DOmar-JMM-3 ) ;
15009: LD_EXP 21
15013: PPUSH
15014: LD_STRING DOmar-JMM-3
15016: PPUSH
15017: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
15021: LD_EXP 58
15025: PPUSH
15026: LD_STRING DOmar-Omar-4
15028: PPUSH
15029: CALL_OW 88
// case Query ( QAccept ) of 1 :
15033: LD_STRING QAccept
15035: PPUSH
15036: CALL_OW 97
15040: PUSH
15041: LD_INT 1
15043: DOUBLE
15044: EQUAL
15045: IFTRUE 15049
15047: GO 15085
15049: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
15050: LD_EXP 21
15054: PPUSH
15055: LD_STRING DQrAccept#1-JMM-1
15057: PPUSH
15058: CALL_OW 88
// SetSide ( Omar , 7 ) ;
15062: LD_EXP 58
15066: PPUSH
15067: LD_INT 7
15069: PPUSH
15070: CALL_OW 235
// ComStop ( Omar ) ;
15074: LD_EXP 58
15078: PPUSH
15079: CALL_OW 141
// end ; 2 :
15083: GO 15134
15085: LD_INT 2
15087: DOUBLE
15088: EQUAL
15089: IFTRUE 15093
15091: GO 15133
15093: POP
// begin if IsOk ( Burlak ) then
15094: LD_EXP 54
15098: PPUSH
15099: CALL_OW 302
15103: IFFALSE 15119
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
15105: LD_EXP 54
15109: PPUSH
15110: LD_STRING DQrAccept#2-Bur-1
15112: PPUSH
15113: CALL_OW 88
15117: GO 15131
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
15119: LD_EXP 21
15123: PPUSH
15124: LD_STRING DQrAccept#2-JMM-1
15126: PPUSH
15127: CALL_OW 88
// end ; end ;
15131: GO 15134
15133: POP
// DialogueOff ;
15134: CALL_OW 7
// if GetSide ( Omar ) = 7 then
15138: LD_EXP 58
15142: PPUSH
15143: CALL_OW 255
15147: PUSH
15148: LD_INT 7
15150: EQUAL
15151: IFFALSE 15162
// begin SetAchievement ( ACH_OMAR ) ;
15153: LD_STRING ACH_OMAR
15155: PPUSH
15156: CALL_OW 543
// exit ;
15160: GO 15177
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
15162: LD_EXP 58
15166: PPUSH
15167: LD_INT 202
15169: PPUSH
15170: LD_INT 115
15172: PPUSH
15173: CALL_OW 111
// end ;
15177: END
// every 0 0$1 trigger not omarKilled and russianCapitulated and ( ( IsOk ( Omar ) and GetSide ( Omar ) = 7 ) or not negotiationWithArabs ) do var i ;
15178: LD_EXP 20
15182: NOT
15183: PUSH
15184: LD_EXP 7
15188: AND
15189: PUSH
15190: LD_EXP 58
15194: PPUSH
15195: CALL_OW 302
15199: PUSH
15200: LD_EXP 58
15204: PPUSH
15205: CALL_OW 255
15209: PUSH
15210: LD_INT 7
15212: EQUAL
15213: AND
15214: PUSH
15215: LD_EXP 19
15219: NOT
15220: OR
15221: AND
15222: IFFALSE 15740
15224: GO 15226
15226: DISABLE
15227: LD_INT 0
15229: PPUSH
// begin if not negotiationWithArabs and not omarKilled then
15230: LD_EXP 19
15234: NOT
15235: PUSH
15236: LD_EXP 20
15240: NOT
15241: AND
15242: IFFALSE 15248
// PrepareOmarAli2 ;
15244: CALL 7676 0 0
// wait ( 0 0$2 ) ;
15248: LD_INT 70
15250: PPUSH
15251: CALL_OW 67
// SetSide ( Omar , 5 ) ;
15255: LD_EXP 58
15259: PPUSH
15260: LD_INT 5
15262: PPUSH
15263: CALL_OW 235
// if IsInUnit ( Omar ) then
15267: LD_EXP 58
15271: PPUSH
15272: CALL_OW 310
15276: IFFALSE 15287
// ComExitVehicle ( Omar ) ;
15278: LD_EXP 58
15282: PPUSH
15283: CALL_OW 121
// if IsInUnit ( Omar ) then
15287: LD_EXP 58
15291: PPUSH
15292: CALL_OW 310
15296: IFFALSE 15307
// ComExitBuilding ( Omar ) ;
15298: LD_EXP 58
15302: PPUSH
15303: CALL_OW 122
// wait ( 0 0$1 ) ;
15307: LD_INT 35
15309: PPUSH
15310: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15314: LD_EXP 58
15318: PPUSH
15319: LD_INT 203
15321: PPUSH
15322: LD_INT 120
15324: PPUSH
15325: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
15329: LD_INT 35
15331: PPUSH
15332: CALL_OW 67
// if omarKilled then
15336: LD_EXP 20
15340: IFFALSE 15344
// exit ;
15342: GO 15740
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
15344: LD_EXP 58
15348: PPUSH
15349: CALL_OW 306
15353: PUSH
15354: LD_EXP 58
15358: PPUSH
15359: LD_INT 203
15361: PPUSH
15362: LD_INT 120
15364: PPUSH
15365: CALL_OW 297
15369: PUSH
15370: LD_INT 20
15372: LESS
15373: OR
15374: IFFALSE 15329
// DialogueOn ;
15376: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
15380: LD_EXP 58
15384: PPUSH
15385: CALL_OW 250
15389: PPUSH
15390: LD_EXP 58
15394: PPUSH
15395: CALL_OW 251
15399: PPUSH
15400: LD_INT 7
15402: PPUSH
15403: LD_INT 6
15405: NEG
15406: PPUSH
15407: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
15411: LD_EXP 58
15415: PPUSH
15416: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
15420: LD_EXP 21
15424: PPUSH
15425: LD_STRING DOmarContam-JMM-1
15427: PPUSH
15428: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
15432: LD_EXP 58
15436: PPUSH
15437: LD_STRING DOmarContam-Omar-1
15439: PPUSH
15440: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
15444: LD_EXP 21
15448: PPUSH
15449: LD_STRING DOmarContam-JMM-2
15451: PPUSH
15452: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
15456: LD_EXP 58
15460: PPUSH
15461: CALL_OW 250
15465: PPUSH
15466: LD_EXP 58
15470: PPUSH
15471: CALL_OW 251
15475: PPUSH
15476: LD_INT 7
15478: PPUSH
15479: CALL_OW 331
// DialogueOff ;
15483: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
15487: LD_INT 5
15489: PPUSH
15490: LD_INT 7
15492: PPUSH
15493: LD_INT 2
15495: PPUSH
15496: LD_INT 1
15498: PPUSH
15499: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
15503: LD_INT 105
15505: PPUSH
15506: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15510: LD_EXP 58
15514: PPUSH
15515: LD_INT 203
15517: PPUSH
15518: LD_INT 120
15520: PPUSH
15521: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) ;
15525: LD_EXP 58
15529: PPUSH
15530: LD_INT 203
15532: PPUSH
15533: LD_INT 120
15535: PPUSH
15536: CALL_OW 307
15540: IFFALSE 15503
// ComHold ( Omar ) ;
15542: LD_EXP 58
15546: PPUSH
15547: CALL_OW 140
// InGameOn ;
15551: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
15555: LD_INT 203
15557: PPUSH
15558: LD_INT 120
15560: PPUSH
15561: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
15565: LD_INT 203
15567: PPUSH
15568: LD_INT 120
15570: PPUSH
15571: LD_INT 7
15573: PPUSH
15574: LD_INT 30
15576: NEG
15577: PPUSH
15578: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
15582: LD_ADDR_VAR 0 1
15586: PUSH
15587: LD_INT 203
15589: PUSH
15590: LD_INT 120
15592: PUSH
15593: EMPTY
15594: LIST
15595: LIST
15596: PUSH
15597: LD_INT 202
15599: PUSH
15600: LD_INT 125
15602: PUSH
15603: EMPTY
15604: LIST
15605: LIST
15606: PUSH
15607: LD_INT 195
15609: PUSH
15610: LD_INT 117
15612: PUSH
15613: EMPTY
15614: LIST
15615: LIST
15616: PUSH
15617: LD_INT 216
15619: PUSH
15620: LD_INT 123
15622: PUSH
15623: EMPTY
15624: LIST
15625: LIST
15626: PUSH
15627: LD_INT 224
15629: PUSH
15630: LD_INT 131
15632: PUSH
15633: EMPTY
15634: LIST
15635: LIST
15636: PUSH
15637: LD_INT 212
15639: PUSH
15640: LD_INT 133
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: PUSH
15647: EMPTY
15648: LIST
15649: LIST
15650: LIST
15651: LIST
15652: LIST
15653: LIST
15654: PUSH
15655: FOR_IN
15656: IFFALSE 15692
// begin wait ( 0 0$0.5 ) ;
15658: LD_INT 18
15660: PPUSH
15661: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15665: LD_VAR 0 1
15669: PUSH
15670: LD_INT 1
15672: ARRAY
15673: PPUSH
15674: LD_VAR 0 1
15678: PUSH
15679: LD_INT 2
15681: ARRAY
15682: PPUSH
15683: LD_INT 5
15685: PPUSH
15686: CALL_OW 495
// end ;
15690: GO 15655
15692: POP
15693: POP
// KillUnit ( Omar ) ;
15694: LD_EXP 58
15698: PPUSH
15699: CALL_OW 66
// wait ( 0 0$3 ) ;
15703: LD_INT 105
15705: PPUSH
15706: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15710: LD_EXP 21
15714: PPUSH
15715: LD_STRING D16b-JMM-1
15717: PPUSH
15718: CALL_OW 91
// wait ( 0 0$2 ) ;
15722: LD_INT 70
15724: PPUSH
15725: CALL_OW 67
// InGameOff ;
15729: CALL_OW 9
// YouLost ( MothContaminate ) ;
15733: LD_STRING MothContaminate
15735: PPUSH
15736: CALL_OW 104
// end ;
15740: PPOPN 1
15742: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15743: LD_EXP 4
15747: NOT
15748: PUSH
15749: LD_INT 22
15751: PUSH
15752: LD_INT 1
15754: PUSH
15755: EMPTY
15756: LIST
15757: LIST
15758: PUSH
15759: LD_INT 34
15761: PUSH
15762: LD_INT 8
15764: PUSH
15765: EMPTY
15766: LIST
15767: LIST
15768: PUSH
15769: EMPTY
15770: LIST
15771: LIST
15772: PPUSH
15773: CALL_OW 69
15777: AND
15778: IFFALSE 15897
15780: GO 15782
15782: DISABLE
// begin wait ( 0 0$10 ) ;
15783: LD_INT 350
15785: PPUSH
15786: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15790: LD_EXP 57
15794: PPUSH
15795: CALL_OW 302
15799: NOT
15800: PUSH
15801: LD_INT 22
15803: PUSH
15804: LD_INT 1
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PUSH
15811: LD_INT 34
15813: PUSH
15814: LD_INT 8
15816: PUSH
15817: EMPTY
15818: LIST
15819: LIST
15820: PUSH
15821: EMPTY
15822: LIST
15823: LIST
15824: PPUSH
15825: CALL_OW 69
15829: NOT
15830: OR
15831: IFFALSE 15835
// exit ;
15833: GO 15897
// DialogueOn ;
15835: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
15839: LD_EXP 57
15843: PPUSH
15844: LD_STRING DWinAmericans-Pow-1
15846: PPUSH
15847: CALL_OW 94
// if IsOk ( Burlak ) then
15851: LD_EXP 54
15855: PPUSH
15856: CALL_OW 302
15860: IFFALSE 15874
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
15862: LD_EXP 54
15866: PPUSH
15867: LD_STRING DWinAmericans-Bur-1
15869: PPUSH
15870: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
15874: LD_EXP 21
15878: PPUSH
15879: LD_STRING DWinAmericans-JMM-1
15881: PPUSH
15882: CALL_OW 88
// DialogueOff ;
15886: CALL_OW 7
// YouLost ( AmBomb ) ;
15890: LD_STRING AmBomb
15892: PPUSH
15893: CALL_OW 104
// end ;
15897: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
15898: LD_EXP 2
15902: NOT
15903: PUSH
15904: LD_INT 22
15906: PUSH
15907: LD_INT 3
15909: PUSH
15910: EMPTY
15911: LIST
15912: LIST
15913: PUSH
15914: LD_INT 34
15916: PUSH
15917: LD_INT 48
15919: PUSH
15920: EMPTY
15921: LIST
15922: LIST
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: PPUSH
15928: CALL_OW 69
15932: AND
15933: IFFALSE 16052
15935: GO 15937
15937: DISABLE
// begin wait ( 0 0$10 ) ;
15938: LD_INT 350
15940: PPUSH
15941: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
15945: LD_EXP 62
15949: PPUSH
15950: CALL_OW 302
15954: NOT
15955: PUSH
15956: LD_INT 22
15958: PUSH
15959: LD_INT 3
15961: PUSH
15962: EMPTY
15963: LIST
15964: LIST
15965: PUSH
15966: LD_INT 34
15968: PUSH
15969: LD_INT 48
15971: PUSH
15972: EMPTY
15973: LIST
15974: LIST
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: PPUSH
15980: CALL_OW 69
15984: NOT
15985: OR
15986: IFFALSE 15990
// exit ;
15988: GO 16052
// DialogueOn ;
15990: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
15994: LD_EXP 62
15998: PPUSH
15999: LD_STRING DWinRussians-Pla-1
16001: PPUSH
16002: CALL_OW 94
// if IsOk ( Burlak ) then
16006: LD_EXP 54
16010: PPUSH
16011: CALL_OW 302
16015: IFFALSE 16029
// Say ( Burlak , DWinRussians-Bur-1 ) ;
16017: LD_EXP 54
16021: PPUSH
16022: LD_STRING DWinRussians-Bur-1
16024: PPUSH
16025: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
16029: LD_EXP 21
16033: PPUSH
16034: LD_STRING DWinRussians-JMM-1
16036: PPUSH
16037: CALL_OW 88
// DialogueOff ;
16041: CALL_OW 7
// YouLost ( RuBomb ) ;
16045: LD_STRING RuBomb
16047: PPUSH
16048: CALL_OW 104
// end ;
16052: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
16053: LD_INT 7
16055: PPUSH
16056: LD_INT 22
16058: PUSH
16059: LD_INT 7
16061: PUSH
16062: EMPTY
16063: LIST
16064: LIST
16065: PPUSH
16066: CALL_OW 70
16070: PUSH
16071: LD_EXP 4
16075: NOT
16076: AND
16077: IFFALSE 16106
16079: GO 16081
16081: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
16082: LD_EXP 57
16086: PPUSH
16087: LD_STRING DSurrenderAmericans-Pow-1
16089: PPUSH
16090: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
16094: LD_EXP 21
16098: PPUSH
16099: LD_STRING DSurrenderAmericans-JMM-1
16101: PPUSH
16102: CALL_OW 88
// end ;
16106: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
16107: LD_INT 2
16109: PPUSH
16110: LD_INT 22
16112: PUSH
16113: LD_INT 7
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: PPUSH
16120: CALL_OW 70
16124: PUSH
16125: LD_EXP 2
16129: NOT
16130: AND
16131: PUSH
16132: LD_EXP 54
16136: AND
16137: IFFALSE 16166
16139: GO 16141
16141: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
16142: LD_EXP 62
16146: PPUSH
16147: LD_STRING DSurrenderRussians-Pla-1
16149: PPUSH
16150: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
16154: LD_EXP 54
16158: PPUSH
16159: LD_STRING DSurrenderRussians-Bur-1
16161: PPUSH
16162: CALL_OW 88
// end ;
16166: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
16167: LD_EXP 4
16171: IFFALSE 16610
16173: GO 16175
16175: DISABLE
16176: LD_INT 0
16178: PPUSH
16179: PPUSH
16180: PPUSH
// begin MC_Kill ( 4 ) ;
16181: LD_INT 4
16183: PPUSH
16184: CALL 23277 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
16188: LD_INT 1
16190: PPUSH
16191: LD_INT 7
16193: PPUSH
16194: LD_INT 1
16196: PPUSH
16197: LD_INT 1
16199: PPUSH
16200: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
16204: LD_ADDR_VAR 0 3
16208: PUSH
16209: LD_INT 22
16211: PUSH
16212: LD_INT 1
16214: PUSH
16215: EMPTY
16216: LIST
16217: LIST
16218: PUSH
16219: LD_INT 50
16221: PUSH
16222: EMPTY
16223: LIST
16224: PUSH
16225: LD_INT 26
16227: PUSH
16228: LD_INT 1
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: PUSH
16235: LD_INT 23
16237: PUSH
16238: LD_INT 1
16240: PUSH
16241: EMPTY
16242: LIST
16243: LIST
16244: PUSH
16245: EMPTY
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: PPUSH
16251: CALL_OW 69
16255: PUSH
16256: LD_EXP 57
16260: PUSH
16261: LD_EXP 29
16265: PUSH
16266: LD_EXP 26
16270: PUSH
16271: LD_EXP 25
16275: PUSH
16276: LD_EXP 32
16280: PUSH
16281: LD_EXP 30
16285: PUSH
16286: EMPTY
16287: LIST
16288: LIST
16289: LIST
16290: LIST
16291: LIST
16292: LIST
16293: DIFF
16294: ST_TO_ADDR
// if not speaker then
16295: LD_VAR 0 3
16299: NOT
16300: IFFALSE 16340
// begin uc_side := 1 ;
16302: LD_ADDR_OWVAR 20
16306: PUSH
16307: LD_INT 1
16309: ST_TO_ADDR
// uc_nation := 1 ;
16310: LD_ADDR_OWVAR 21
16314: PUSH
16315: LD_INT 1
16317: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16318: LD_INT 1
16320: PPUSH
16321: LD_INT 0
16323: PPUSH
16324: CALL_OW 381
// speaker := CreateHuman ;
16328: LD_ADDR_VAR 0 3
16332: PUSH
16333: CALL_OW 44
16337: ST_TO_ADDR
// end else
16338: GO 16354
// speaker := speaker [ 1 ] ;
16340: LD_ADDR_VAR 0 3
16344: PUSH
16345: LD_VAR 0 3
16349: PUSH
16350: LD_INT 1
16352: ARRAY
16353: ST_TO_ADDR
// DialogueOn ;
16354: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
16358: LD_VAR 0 3
16362: PPUSH
16363: LD_STRING DSurrenderAmericans-Sol1-1a
16365: PPUSH
16366: CALL_OW 94
// DialogueOff ;
16370: CALL_OW 7
// americanCapitulated := true ;
16374: LD_ADDR_EXP 6
16378: PUSH
16379: LD_INT 1
16381: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16382: LD_ADDR_VAR 0 2
16386: PUSH
16387: LD_INT 22
16389: PUSH
16390: LD_INT 1
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PUSH
16397: LD_INT 21
16399: PUSH
16400: LD_INT 1
16402: PUSH
16403: EMPTY
16404: LIST
16405: LIST
16406: PUSH
16407: EMPTY
16408: LIST
16409: LIST
16410: PPUSH
16411: CALL_OW 69
16415: PUSH
16416: LD_INT 22
16418: PUSH
16419: LD_INT 1
16421: PUSH
16422: EMPTY
16423: LIST
16424: LIST
16425: PUSH
16426: LD_INT 21
16428: PUSH
16429: LD_INT 2
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: PUSH
16436: LD_INT 1
16438: PUSH
16439: EMPTY
16440: LIST
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: LIST
16446: PPUSH
16447: CALL_OW 69
16451: ADD
16452: ST_TO_ADDR
// if tmp then
16453: LD_VAR 0 2
16457: IFFALSE 16610
// repeat wait ( 0 0$1 ) ;
16459: LD_INT 35
16461: PPUSH
16462: CALL_OW 67
// for i in tmp do
16466: LD_ADDR_VAR 0 1
16470: PUSH
16471: LD_VAR 0 2
16475: PUSH
16476: FOR_IN
16477: IFFALSE 16559
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16479: LD_VAR 0 1
16483: PPUSH
16484: CALL_OW 310
16488: PUSH
16489: LD_VAR 0 1
16493: PPUSH
16494: CALL_OW 310
16498: PPUSH
16499: CALL_OW 247
16503: PUSH
16504: LD_INT 3
16506: EQUAL
16507: AND
16508: IFFALSE 16519
// ComExitBuilding ( i ) ;
16510: LD_VAR 0 1
16514: PPUSH
16515: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
16519: LD_VAR 0 1
16523: PPUSH
16524: LD_INT 122
16526: PPUSH
16527: LD_INT 242
16529: PPUSH
16530: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
16534: LD_VAR 0 1
16538: PPUSH
16539: LD_INT 35
16541: PPUSH
16542: CALL_OW 308
16546: IFFALSE 16557
// RemoveUnit ( i ) ;
16548: LD_VAR 0 1
16552: PPUSH
16553: CALL_OW 64
// end ;
16557: GO 16476
16559: POP
16560: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16561: LD_INT 22
16563: PUSH
16564: LD_INT 1
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: PUSH
16571: LD_INT 2
16573: PUSH
16574: LD_INT 21
16576: PUSH
16577: LD_INT 1
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: LD_INT 33
16586: PUSH
16587: LD_INT 1
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: EMPTY
16595: LIST
16596: LIST
16597: LIST
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: PPUSH
16603: CALL_OW 69
16607: NOT
16608: IFFALSE 16459
// end ;
16610: PPOPN 3
16612: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
16613: LD_EXP 2
16617: IFFALSE 17066
16619: GO 16621
16621: DISABLE
16622: LD_INT 0
16624: PPUSH
16625: PPUSH
16626: PPUSH
// begin repeat wait ( 0 0$1 ) ;
16627: LD_INT 35
16629: PPUSH
16630: CALL_OW 67
// until IsDead ( Yakotich ) ;
16634: LD_EXP 63
16638: PPUSH
16639: CALL_OW 301
16643: IFFALSE 16627
// MC_Kill ( 2 ) ;
16645: LD_INT 2
16647: PPUSH
16648: CALL 23277 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16652: LD_INT 3
16654: PPUSH
16655: LD_INT 7
16657: PPUSH
16658: LD_INT 1
16660: PPUSH
16661: LD_INT 1
16663: PPUSH
16664: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16668: LD_ADDR_VAR 0 3
16672: PUSH
16673: LD_INT 22
16675: PUSH
16676: LD_INT 3
16678: PUSH
16679: EMPTY
16680: LIST
16681: LIST
16682: PUSH
16683: LD_INT 50
16685: PUSH
16686: EMPTY
16687: LIST
16688: PUSH
16689: LD_INT 26
16691: PUSH
16692: LD_INT 1
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: PUSH
16699: LD_INT 23
16701: PUSH
16702: LD_INT 3
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: PPUSH
16715: CALL_OW 69
16719: PUSH
16720: LD_EXP 62
16724: DIFF
16725: ST_TO_ADDR
// if not speaker then
16726: LD_VAR 0 3
16730: NOT
16731: IFFALSE 16771
// begin uc_side := 3 ;
16733: LD_ADDR_OWVAR 20
16737: PUSH
16738: LD_INT 3
16740: ST_TO_ADDR
// uc_nation := 3 ;
16741: LD_ADDR_OWVAR 21
16745: PUSH
16746: LD_INT 3
16748: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16749: LD_INT 1
16751: PPUSH
16752: LD_INT 0
16754: PPUSH
16755: CALL_OW 381
// speaker := CreateHuman ;
16759: LD_ADDR_VAR 0 3
16763: PUSH
16764: CALL_OW 44
16768: ST_TO_ADDR
// end else
16769: GO 16785
// speaker := speaker [ 1 ] ;
16771: LD_ADDR_VAR 0 3
16775: PUSH
16776: LD_VAR 0 3
16780: PUSH
16781: LD_INT 1
16783: ARRAY
16784: ST_TO_ADDR
// DialogueOn ;
16785: CALL_OW 6
// if IsOK ( Burlak ) then
16789: LD_EXP 54
16793: PPUSH
16794: CALL_OW 302
16798: IFFALSE 16814
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16800: LD_VAR 0 3
16804: PPUSH
16805: LD_STRING DSurrenderRussians-RSol1-1
16807: PPUSH
16808: CALL_OW 94
16812: GO 16826
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16814: LD_VAR 0 3
16818: PPUSH
16819: LD_STRING DSurrenderRussians-RSol1-1a
16821: PPUSH
16822: CALL_OW 94
// DialogueOff ;
16826: CALL_OW 7
// russianCapitulated := true ;
16830: LD_ADDR_EXP 7
16834: PUSH
16835: LD_INT 1
16837: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16838: LD_ADDR_VAR 0 2
16842: PUSH
16843: LD_INT 22
16845: PUSH
16846: LD_INT 3
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PUSH
16853: LD_INT 21
16855: PUSH
16856: LD_INT 1
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PPUSH
16867: CALL_OW 69
16871: PUSH
16872: LD_INT 22
16874: PUSH
16875: LD_INT 3
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PUSH
16882: LD_INT 21
16884: PUSH
16885: LD_INT 2
16887: PUSH
16888: EMPTY
16889: LIST
16890: LIST
16891: PUSH
16892: LD_INT 1
16894: PUSH
16895: EMPTY
16896: LIST
16897: PUSH
16898: EMPTY
16899: LIST
16900: LIST
16901: LIST
16902: PPUSH
16903: CALL_OW 69
16907: ADD
16908: ST_TO_ADDR
// if tmp then
16909: LD_VAR 0 2
16913: IFFALSE 17066
// repeat wait ( 0 0$1 ) ;
16915: LD_INT 35
16917: PPUSH
16918: CALL_OW 67
// for i in tmp do
16922: LD_ADDR_VAR 0 1
16926: PUSH
16927: LD_VAR 0 2
16931: PUSH
16932: FOR_IN
16933: IFFALSE 17015
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16935: LD_VAR 0 1
16939: PPUSH
16940: CALL_OW 310
16944: PUSH
16945: LD_VAR 0 1
16949: PPUSH
16950: CALL_OW 310
16954: PPUSH
16955: CALL_OW 247
16959: PUSH
16960: LD_INT 3
16962: EQUAL
16963: AND
16964: IFFALSE 16975
// ComExitBuilding ( i ) ;
16966: LD_VAR 0 1
16970: PPUSH
16971: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
16975: LD_VAR 0 1
16979: PPUSH
16980: LD_INT 154
16982: PPUSH
16983: LD_INT 1
16985: PPUSH
16986: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
16990: LD_VAR 0 1
16994: PPUSH
16995: LD_INT 36
16997: PPUSH
16998: CALL_OW 308
17002: IFFALSE 17013
// RemoveUnit ( i ) ;
17004: LD_VAR 0 1
17008: PPUSH
17009: CALL_OW 64
// end ;
17013: GO 16932
17015: POP
17016: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17017: LD_INT 22
17019: PUSH
17020: LD_INT 3
17022: PUSH
17023: EMPTY
17024: LIST
17025: LIST
17026: PUSH
17027: LD_INT 2
17029: PUSH
17030: LD_INT 21
17032: PUSH
17033: LD_INT 1
17035: PUSH
17036: EMPTY
17037: LIST
17038: LIST
17039: PUSH
17040: LD_INT 33
17042: PUSH
17043: LD_INT 1
17045: PUSH
17046: EMPTY
17047: LIST
17048: LIST
17049: PUSH
17050: EMPTY
17051: LIST
17052: LIST
17053: LIST
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: PPUSH
17059: CALL_OW 69
17063: NOT
17064: IFFALSE 16915
// end ;
17066: PPOPN 3
17068: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
17069: LD_INT 22
17071: PUSH
17072: LD_INT 8
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PUSH
17079: LD_INT 21
17081: PUSH
17082: LD_INT 1
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: PUSH
17089: LD_INT 23
17091: PUSH
17092: LD_INT 2
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: PUSH
17099: EMPTY
17100: LIST
17101: LIST
17102: LIST
17103: PPUSH
17104: CALL_OW 69
17108: PUSH
17109: LD_INT 18
17111: LESS
17112: PUSH
17113: LD_EXP 60
17117: PPUSH
17118: CALL_OW 301
17122: OR
17123: PUSH
17124: LD_INT 324
17126: PPUSH
17127: CALL_OW 255
17131: PUSH
17132: LD_INT 7
17134: EQUAL
17135: OR
17136: IFFALSE 17149
17138: GO 17140
17140: DISABLE
// legionDestroyed := true ;
17141: LD_ADDR_EXP 3
17145: PUSH
17146: LD_INT 1
17148: ST_TO_ADDR
17149: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
17150: LD_INT 22
17152: PUSH
17153: LD_INT 2
17155: PUSH
17156: EMPTY
17157: LIST
17158: LIST
17159: PUSH
17160: LD_INT 21
17162: PUSH
17163: LD_INT 1
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: PUSH
17170: LD_INT 23
17172: PUSH
17173: LD_INT 2
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: LIST
17184: PPUSH
17185: CALL_OW 69
17189: PUSH
17190: LD_INT 9
17192: LESS
17193: PUSH
17194: LD_INT 503
17196: PPUSH
17197: CALL_OW 301
17201: OR
17202: PUSH
17203: LD_INT 503
17205: PPUSH
17206: CALL_OW 255
17210: PUSH
17211: LD_INT 7
17213: EQUAL
17214: OR
17215: IFFALSE 17228
17217: GO 17219
17219: DISABLE
// arabianDestroyed := true ;
17220: LD_ADDR_EXP 5
17224: PUSH
17225: LD_INT 1
17227: ST_TO_ADDR
17228: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
17229: LD_EXP 5
17233: IFFALSE 17477
17235: GO 17237
17237: DISABLE
17238: LD_INT 0
17240: PPUSH
17241: PPUSH
// begin MC_Kill ( 1 ) ;
17242: LD_INT 1
17244: PPUSH
17245: CALL 23277 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17249: LD_ADDR_VAR 0 2
17253: PUSH
17254: LD_INT 22
17256: PUSH
17257: LD_INT 2
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: PUSH
17264: LD_INT 21
17266: PUSH
17267: LD_INT 1
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: PUSH
17274: EMPTY
17275: LIST
17276: LIST
17277: PPUSH
17278: CALL_OW 69
17282: PUSH
17283: LD_INT 22
17285: PUSH
17286: LD_INT 2
17288: PUSH
17289: EMPTY
17290: LIST
17291: LIST
17292: PUSH
17293: LD_INT 21
17295: PUSH
17296: LD_INT 2
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: PUSH
17303: LD_INT 1
17305: PUSH
17306: EMPTY
17307: LIST
17308: PUSH
17309: EMPTY
17310: LIST
17311: LIST
17312: LIST
17313: PPUSH
17314: CALL_OW 69
17318: ADD
17319: ST_TO_ADDR
// if tmp then
17320: LD_VAR 0 2
17324: IFFALSE 17477
// repeat wait ( 0 0$1 ) ;
17326: LD_INT 35
17328: PPUSH
17329: CALL_OW 67
// for i in tmp do
17333: LD_ADDR_VAR 0 1
17337: PUSH
17338: LD_VAR 0 2
17342: PUSH
17343: FOR_IN
17344: IFFALSE 17426
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17346: LD_VAR 0 1
17350: PPUSH
17351: CALL_OW 310
17355: PUSH
17356: LD_VAR 0 1
17360: PPUSH
17361: CALL_OW 310
17365: PPUSH
17366: CALL_OW 247
17370: PUSH
17371: LD_INT 3
17373: EQUAL
17374: AND
17375: IFFALSE 17386
// ComExitBuilding ( i ) ;
17377: LD_VAR 0 1
17381: PPUSH
17382: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
17386: LD_VAR 0 1
17390: PPUSH
17391: LD_INT 254
17393: PPUSH
17394: LD_INT 268
17396: PPUSH
17397: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
17401: LD_VAR 0 1
17405: PPUSH
17406: LD_INT 34
17408: PPUSH
17409: CALL_OW 308
17413: IFFALSE 17424
// RemoveUnit ( i ) ;
17415: LD_VAR 0 1
17419: PPUSH
17420: CALL_OW 64
// end ;
17424: GO 17343
17426: POP
17427: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17428: LD_INT 22
17430: PUSH
17431: LD_INT 2
17433: PUSH
17434: EMPTY
17435: LIST
17436: LIST
17437: PUSH
17438: LD_INT 2
17440: PUSH
17441: LD_INT 21
17443: PUSH
17444: LD_INT 1
17446: PUSH
17447: EMPTY
17448: LIST
17449: LIST
17450: PUSH
17451: LD_INT 33
17453: PUSH
17454: LD_INT 1
17456: PUSH
17457: EMPTY
17458: LIST
17459: LIST
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: LIST
17465: PUSH
17466: EMPTY
17467: LIST
17468: LIST
17469: PPUSH
17470: CALL_OW 69
17474: NOT
17475: IFFALSE 17326
// end ;
17477: PPOPN 2
17479: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
17480: LD_EXP 3
17484: IFFALSE 17836
17486: GO 17488
17488: DISABLE
17489: LD_INT 0
17491: PPUSH
17492: PPUSH
// begin MC_Kill ( 3 ) ;
17493: LD_INT 3
17495: PPUSH
17496: CALL 23277 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
17500: LD_INT 8
17502: PPUSH
17503: LD_INT 7
17505: PPUSH
17506: LD_INT 1
17508: PPUSH
17509: LD_INT 1
17511: PPUSH
17512: CALL_OW 80
// DialogueOn ;
17516: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
17520: LD_EXP 59
17524: PPUSH
17525: LD_STRING D15-Szulc-1
17527: PPUSH
17528: CALL_OW 94
// DialogueOff ;
17532: CALL_OW 7
// legionCapitulated := true ;
17536: LD_ADDR_EXP 8
17540: PUSH
17541: LD_INT 1
17543: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
17544: LD_ADDR_VAR 0 1
17548: PUSH
17549: LD_INT 22
17551: PUSH
17552: LD_INT 8
17554: PUSH
17555: EMPTY
17556: LIST
17557: LIST
17558: PUSH
17559: LD_INT 21
17561: PUSH
17562: LD_INT 3
17564: PUSH
17565: EMPTY
17566: LIST
17567: LIST
17568: PUSH
17569: LD_INT 23
17571: PUSH
17572: LD_INT 3
17574: PUSH
17575: EMPTY
17576: LIST
17577: LIST
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: LIST
17583: PPUSH
17584: CALL_OW 69
17588: PUSH
17589: FOR_IN
17590: IFFALSE 17606
// SetLives ( i , 3 ) ;
17592: LD_VAR 0 1
17596: PPUSH
17597: LD_INT 3
17599: PPUSH
17600: CALL_OW 234
17604: GO 17589
17606: POP
17607: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17608: LD_ADDR_VAR 0 2
17612: PUSH
17613: LD_INT 22
17615: PUSH
17616: LD_INT 8
17618: PUSH
17619: EMPTY
17620: LIST
17621: LIST
17622: PUSH
17623: LD_INT 21
17625: PUSH
17626: LD_INT 1
17628: PUSH
17629: EMPTY
17630: LIST
17631: LIST
17632: PUSH
17633: EMPTY
17634: LIST
17635: LIST
17636: PPUSH
17637: CALL_OW 69
17641: PUSH
17642: LD_INT 22
17644: PUSH
17645: LD_INT 8
17647: PUSH
17648: EMPTY
17649: LIST
17650: LIST
17651: PUSH
17652: LD_INT 21
17654: PUSH
17655: LD_INT 2
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PUSH
17662: LD_INT 1
17664: PUSH
17665: EMPTY
17666: LIST
17667: PUSH
17668: EMPTY
17669: LIST
17670: LIST
17671: LIST
17672: PPUSH
17673: CALL_OW 69
17677: ADD
17678: ST_TO_ADDR
// if tmp then
17679: LD_VAR 0 2
17683: IFFALSE 17836
// repeat wait ( 0 0$1 ) ;
17685: LD_INT 35
17687: PPUSH
17688: CALL_OW 67
// for i in tmp do
17692: LD_ADDR_VAR 0 1
17696: PUSH
17697: LD_VAR 0 2
17701: PUSH
17702: FOR_IN
17703: IFFALSE 17785
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17705: LD_VAR 0 1
17709: PPUSH
17710: CALL_OW 310
17714: PUSH
17715: LD_VAR 0 1
17719: PPUSH
17720: CALL_OW 310
17724: PPUSH
17725: CALL_OW 247
17729: PUSH
17730: LD_INT 3
17732: EQUAL
17733: AND
17734: IFFALSE 17745
// ComExitBuilding ( i ) ;
17736: LD_VAR 0 1
17740: PPUSH
17741: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17745: LD_VAR 0 1
17749: PPUSH
17750: LD_INT 10
17752: PPUSH
17753: LD_INT 1
17755: PPUSH
17756: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17760: LD_VAR 0 1
17764: PPUSH
17765: LD_INT 32
17767: PPUSH
17768: CALL_OW 308
17772: IFFALSE 17783
// RemoveUnit ( i ) ;
17774: LD_VAR 0 1
17778: PPUSH
17779: CALL_OW 64
// end ;
17783: GO 17702
17785: POP
17786: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17787: LD_INT 22
17789: PUSH
17790: LD_INT 8
17792: PUSH
17793: EMPTY
17794: LIST
17795: LIST
17796: PUSH
17797: LD_INT 2
17799: PUSH
17800: LD_INT 21
17802: PUSH
17803: LD_INT 1
17805: PUSH
17806: EMPTY
17807: LIST
17808: LIST
17809: PUSH
17810: LD_INT 33
17812: PUSH
17813: LD_INT 1
17815: PUSH
17816: EMPTY
17817: LIST
17818: LIST
17819: PUSH
17820: EMPTY
17821: LIST
17822: LIST
17823: LIST
17824: PUSH
17825: EMPTY
17826: LIST
17827: LIST
17828: PPUSH
17829: CALL_OW 69
17833: NOT
17834: IFFALSE 17685
// end ;
17836: PPOPN 2
17838: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
17839: LD_EXP 5
17843: NOT
17844: PUSH
17845: LD_OWVAR 1
17849: PUSH
17850: LD_INT 63000
17852: GREATEREQUAL
17853: AND
17854: PUSH
17855: LD_OWVAR 67
17859: PUSH
17860: LD_INT 3
17862: LESS
17863: AND
17864: IFFALSE 17873
17866: GO 17868
17868: DISABLE
// AllianceSupport ;
17869: CALL 4711 0 0
17873: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or omarKilled or not IsPlaced ( Omar ) ) do var med1 , med2 ;
17874: LD_EXP 4
17878: PUSH
17879: LD_EXP 2
17883: AND
17884: PUSH
17885: LD_EXP 3
17889: AND
17890: PUSH
17891: LD_EXP 5
17895: AND
17896: PUSH
17897: LD_EXP 6
17901: AND
17902: PUSH
17903: LD_EXP 7
17907: AND
17908: PUSH
17909: LD_EXP 8
17913: AND
17914: PUSH
17915: LD_EXP 58
17919: PPUSH
17920: CALL_OW 255
17924: PUSH
17925: LD_INT 5
17927: NONEQUAL
17928: PUSH
17929: LD_EXP 20
17933: OR
17934: PUSH
17935: LD_EXP 58
17939: PPUSH
17940: CALL_OW 305
17944: NOT
17945: OR
17946: AND
17947: IFFALSE 19532
17949: GO 17951
17951: DISABLE
17952: LD_INT 0
17954: PPUSH
17955: PPUSH
// begin wait ( 0 0$5 ) ;
17956: LD_INT 175
17958: PPUSH
17959: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 3 then
17963: LD_INT 22
17965: PUSH
17966: LD_INT 7
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: PUSH
17973: LD_INT 21
17975: PUSH
17976: LD_INT 1
17978: PUSH
17979: EMPTY
17980: LIST
17981: LIST
17982: PUSH
17983: LD_INT 23
17985: PUSH
17986: LD_INT 1
17988: PUSH
17989: EMPTY
17990: LIST
17991: LIST
17992: PUSH
17993: LD_INT 50
17995: PUSH
17996: EMPTY
17997: LIST
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: PPUSH
18005: CALL_OW 69
18009: PPUSH
18010: CALL 55914 0 1
18014: PUSH
18015: LD_INT 3
18017: LESS
18018: IFFALSE 18029
// begin YouLost ( LostVictory ) ;
18020: LD_STRING LostVictory
18022: PPUSH
18023: CALL_OW 104
// exit ;
18027: GO 19532
// end ; music_class := 5 ;
18029: LD_ADDR_OWVAR 72
18033: PUSH
18034: LD_INT 5
18036: ST_TO_ADDR
// music_nat := 5 ;
18037: LD_ADDR_OWVAR 71
18041: PUSH
18042: LD_INT 5
18044: ST_TO_ADDR
// if vehicleLostCounter < 3 then
18045: LD_EXP 15
18049: PUSH
18050: LD_INT 3
18052: LESS
18053: IFFALSE 18062
// SetAchievement ( ACH_ECONOMY ) ;
18055: LD_STRING ACH_ECONOMY
18057: PPUSH
18058: CALL_OW 543
// if tick < 60 60$00 then
18062: LD_OWVAR 1
18066: PUSH
18067: LD_INT 126000
18069: LESS
18070: IFFALSE 18086
// begin wait ( 3 ) ;
18072: LD_INT 3
18074: PPUSH
18075: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
18079: LD_STRING ACH_ASPEED_19
18081: PPUSH
18082: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
18086: LD_EXP 21
18090: PPUSH
18091: CALL_OW 87
// InGameOn ;
18095: CALL_OW 8
// DialogueOn ;
18099: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
18103: LD_EXP 21
18107: PPUSH
18108: LD_STRING DEnd-JMM-JMM-1
18110: PPUSH
18111: CALL_OW 88
// if Joan then
18115: LD_EXP 36
18119: IFFALSE 18135
// Say ( Joan , DEnd-JMM-Joan-1 ) else
18121: LD_EXP 36
18125: PPUSH
18126: LD_STRING DEnd-JMM-Joan-1
18128: PPUSH
18129: CALL_OW 88
18133: GO 18179
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
18135: LD_EXP 23
18139: PUSH
18140: LD_EXP 23
18144: PPUSH
18145: CALL_OW 255
18149: PUSH
18150: LD_INT 7
18152: EQUAL
18153: AND
18154: PUSH
18155: LD_EXP 23
18159: PPUSH
18160: CALL_OW 305
18164: AND
18165: IFFALSE 18179
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
18167: LD_EXP 23
18171: PPUSH
18172: LD_STRING DEnd-JMM-Lisa-1
18174: PPUSH
18175: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
18179: LD_EXP 33
18183: PUSH
18184: LD_EXP 33
18188: PPUSH
18189: CALL_OW 305
18193: AND
18194: IFFALSE 18208
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
18196: LD_EXP 33
18200: PPUSH
18201: LD_STRING DEnd-JMM-Frank-1
18203: PPUSH
18204: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
18208: LD_EXP 26
18212: PUSH
18213: LD_EXP 26
18217: PPUSH
18218: CALL_OW 255
18222: PUSH
18223: LD_INT 7
18225: EQUAL
18226: AND
18227: PUSH
18228: LD_EXP 26
18232: PPUSH
18233: CALL_OW 305
18237: AND
18238: IFFALSE 18252
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
18240: LD_EXP 26
18244: PPUSH
18245: LD_STRING DEnd-JMM-Cyrus-1
18247: PPUSH
18248: CALL_OW 88
// if Burlak then
18252: LD_EXP 54
18256: IFFALSE 18270
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
18258: LD_EXP 54
18262: PPUSH
18263: LD_STRING DEnd-JMM-Bur-1
18265: PPUSH
18266: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
18270: LD_EXP 36
18274: PUSH
18275: LD_EXP 23
18279: AND
18280: PUSH
18281: LD_EXP 23
18285: PPUSH
18286: CALL_OW 255
18290: PUSH
18291: LD_INT 7
18293: EQUAL
18294: AND
18295: PUSH
18296: LD_EXP 23
18300: PPUSH
18301: CALL_OW 305
18305: AND
18306: PUSH
18307: LD_EXP 54
18311: PPUSH
18312: CALL_OW 302
18316: AND
18317: IFFALSE 18331
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
18319: LD_EXP 23
18323: PPUSH
18324: LD_STRING DEnd-Burlak-Lisa-1
18326: PPUSH
18327: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
18331: LD_EXP 55
18335: PUSH
18336: LD_EXP 55
18340: PPUSH
18341: CALL_OW 305
18345: AND
18346: IFFALSE 18360
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
18348: LD_EXP 55
18352: PPUSH
18353: LD_STRING DEnd-JMM-Bel-1
18355: PPUSH
18356: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
18360: LD_EXP 56
18364: PUSH
18365: LD_EXP 56
18369: PPUSH
18370: CALL_OW 305
18374: AND
18375: IFFALSE 18389
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
18377: LD_EXP 56
18381: PPUSH
18382: LD_STRING DEnd-JMM-Gny-1
18384: PPUSH
18385: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
18389: LD_EXP 31
18393: PUSH
18394: LD_EXP 31
18398: PPUSH
18399: CALL_OW 255
18403: PUSH
18404: LD_INT 7
18406: EQUAL
18407: AND
18408: PUSH
18409: LD_EXP 31
18413: PPUSH
18414: CALL_OW 305
18418: AND
18419: IFFALSE 18433
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
18421: LD_EXP 31
18425: PPUSH
18426: LD_STRING DEnd-JMM-Corn-1
18428: PPUSH
18429: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
18433: LD_EXP 24
18437: PUSH
18438: LD_EXP 24
18442: PPUSH
18443: CALL_OW 255
18447: PUSH
18448: LD_INT 7
18450: EQUAL
18451: AND
18452: PUSH
18453: LD_EXP 24
18457: PPUSH
18458: CALL_OW 305
18462: AND
18463: IFFALSE 18477
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
18465: LD_EXP 24
18469: PPUSH
18470: LD_STRING DEnd-JMM-Don-1
18472: PPUSH
18473: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
18477: LD_EXP 25
18481: PUSH
18482: LD_EXP 25
18486: PPUSH
18487: CALL_OW 255
18491: PUSH
18492: LD_INT 7
18494: EQUAL
18495: AND
18496: PUSH
18497: LD_EXP 25
18501: PPUSH
18502: CALL_OW 305
18506: AND
18507: IFFALSE 18521
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
18509: LD_EXP 25
18513: PPUSH
18514: LD_STRING DEnd-JMM-Bobby-1
18516: PPUSH
18517: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
18521: LD_EXP 27
18525: PUSH
18526: LD_EXP 27
18530: PPUSH
18531: CALL_OW 255
18535: PUSH
18536: LD_INT 7
18538: EQUAL
18539: AND
18540: PUSH
18541: LD_EXP 27
18545: PPUSH
18546: CALL_OW 305
18550: AND
18551: IFFALSE 18565
// Say ( Denis , DEnd-JMM-Den-1 ) ;
18553: LD_EXP 27
18557: PPUSH
18558: LD_STRING DEnd-JMM-Den-1
18560: PPUSH
18561: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
18565: LD_EXP 29
18569: PUSH
18570: LD_EXP 29
18574: PPUSH
18575: CALL_OW 255
18579: PUSH
18580: LD_INT 7
18582: EQUAL
18583: AND
18584: PUSH
18585: LD_EXP 29
18589: PPUSH
18590: CALL_OW 305
18594: AND
18595: IFFALSE 18609
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
18597: LD_EXP 29
18601: PPUSH
18602: LD_STRING DEnd-JMM-Glad-1
18604: PPUSH
18605: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18609: LD_EXP 34
18613: PUSH
18614: LD_EXP 34
18618: PPUSH
18619: CALL_OW 255
18623: PUSH
18624: LD_INT 7
18626: EQUAL
18627: AND
18628: PUSH
18629: LD_EXP 34
18633: PPUSH
18634: CALL_OW 305
18638: AND
18639: IFFALSE 18653
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18641: LD_EXP 34
18645: PPUSH
18646: LD_STRING DEnd-JMM-Yam-1
18648: PPUSH
18649: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
18653: LD_EXP 28
18657: PUSH
18658: LD_EXP 28
18662: PPUSH
18663: CALL_OW 255
18667: PUSH
18668: LD_INT 7
18670: EQUAL
18671: AND
18672: PUSH
18673: LD_EXP 28
18677: PPUSH
18678: CALL_OW 305
18682: AND
18683: IFFALSE 18697
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
18685: LD_EXP 28
18689: PPUSH
18690: LD_STRING DEnd-JMM-Brown-1
18692: PPUSH
18693: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
18697: LD_EXP 38
18701: PUSH
18702: LD_EXP 38
18706: PPUSH
18707: CALL_OW 255
18711: PUSH
18712: LD_INT 7
18714: EQUAL
18715: AND
18716: PUSH
18717: LD_EXP 38
18721: PPUSH
18722: CALL_OW 305
18726: AND
18727: IFFALSE 18741
// Say ( Connie , DEnd-JMM-Con-1 ) ;
18729: LD_EXP 38
18733: PPUSH
18734: LD_STRING DEnd-JMM-Con-1
18736: PPUSH
18737: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
18741: LD_EXP 32
18745: PUSH
18746: LD_EXP 32
18750: PPUSH
18751: CALL_OW 255
18755: PUSH
18756: LD_INT 7
18758: EQUAL
18759: AND
18760: PUSH
18761: LD_EXP 32
18765: PPUSH
18766: CALL_OW 305
18770: AND
18771: IFFALSE 18785
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18773: LD_EXP 32
18777: PPUSH
18778: LD_STRING DEnd-JMM-Gary-1
18780: PPUSH
18781: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
18785: LD_EXP 22
18789: PUSH
18790: LD_EXP 22
18794: PPUSH
18795: CALL_OW 305
18799: AND
18800: IFFALSE 18814
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18802: LD_EXP 22
18806: PPUSH
18807: LD_STRING DEnd-JMM-Roth-1
18809: PPUSH
18810: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
18814: LD_EXP 35
18818: PUSH
18819: LD_EXP 22
18823: AND
18824: PUSH
18825: LD_EXP 35
18829: PPUSH
18830: CALL_OW 305
18834: AND
18835: IFFALSE 18849
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18837: LD_EXP 35
18841: PPUSH
18842: LD_STRING DEnd-JMM-Sim-1
18844: PPUSH
18845: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
18849: LD_EXP 30
18853: PUSH
18854: LD_EXP 30
18858: PPUSH
18859: CALL_OW 255
18863: PUSH
18864: LD_INT 7
18866: EQUAL
18867: AND
18868: PUSH
18869: LD_EXP 30
18873: PPUSH
18874: CALL_OW 305
18878: AND
18879: IFFALSE 18893
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
18881: LD_EXP 30
18885: PPUSH
18886: LD_STRING DEnd-JMM-VanH-1
18888: PPUSH
18889: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
18893: LD_EXP 44
18897: PUSH
18898: LD_EXP 44
18902: PPUSH
18903: CALL_OW 305
18907: AND
18908: IFFALSE 18922
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18910: LD_EXP 44
18914: PPUSH
18915: LD_STRING DEnd-JMM-Dol-1
18917: PPUSH
18918: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18922: LD_EXP 34
18926: PUSH
18927: LD_EXP 34
18931: PPUSH
18932: CALL_OW 255
18936: PUSH
18937: LD_INT 7
18939: EQUAL
18940: AND
18941: PUSH
18942: LD_EXP 34
18946: PPUSH
18947: CALL_OW 305
18951: AND
18952: IFFALSE 18966
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18954: LD_EXP 34
18958: PPUSH
18959: LD_STRING DEnd-JMM-Yam-1
18961: PPUSH
18962: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
18966: LD_EXP 48
18970: PUSH
18971: LD_EXP 48
18975: PPUSH
18976: CALL_OW 305
18980: AND
18981: IFFALSE 18995
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18983: LD_EXP 48
18987: PPUSH
18988: LD_STRING DEnd-JMM-Kap-1
18990: PPUSH
18991: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
18995: LD_EXP 51
18999: PUSH
19000: LD_EXP 51
19004: PPUSH
19005: CALL_OW 305
19009: AND
19010: IFFALSE 19024
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
19012: LD_EXP 51
19016: PPUSH
19017: LD_STRING DEnd-JMM-Kov-1
19019: PPUSH
19020: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
19024: LD_EXP 46
19028: PUSH
19029: LD_EXP 46
19033: PPUSH
19034: CALL_OW 305
19038: AND
19039: IFFALSE 19053
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
19041: LD_EXP 46
19045: PPUSH
19046: LD_STRING DEnd-JMM-Sch-1
19048: PPUSH
19049: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
19053: LD_EXP 42
19057: PUSH
19058: LD_EXP 42
19062: PPUSH
19063: CALL_OW 305
19067: AND
19068: PUSH
19069: LD_EXP 54
19073: PPUSH
19074: CALL_OW 302
19078: AND
19079: IFFALSE 19093
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
19081: LD_EXP 42
19085: PPUSH
19086: LD_STRING DEnd-JMM-Tit-1
19088: PPUSH
19089: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
19093: LD_EXP 47
19097: PUSH
19098: LD_EXP 47
19102: PPUSH
19103: CALL_OW 305
19107: AND
19108: IFFALSE 19122
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
19110: LD_EXP 47
19114: PPUSH
19115: LD_STRING DEnd-JMM-Obl-1
19117: PPUSH
19118: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
19122: LD_EXP 49
19126: PUSH
19127: LD_EXP 49
19131: PPUSH
19132: CALL_OW 305
19136: AND
19137: IFFALSE 19151
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
19139: LD_EXP 49
19143: PPUSH
19144: LD_STRING DEnd-JMM-Lip-1
19146: PPUSH
19147: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
19151: LD_EXP 43
19155: PUSH
19156: LD_EXP 43
19160: PPUSH
19161: CALL_OW 305
19165: AND
19166: PUSH
19167: LD_EXP 54
19171: PPUSH
19172: CALL_OW 302
19176: AND
19177: IFFALSE 19191
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
19179: LD_EXP 43
19183: PPUSH
19184: LD_STRING DEnd-Burlak-Fad-1
19186: PPUSH
19187: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
19191: LD_EXP 50
19195: PUSH
19196: LD_EXP 50
19200: PPUSH
19201: CALL_OW 305
19205: AND
19206: IFFALSE 19220
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
19208: LD_EXP 50
19212: PPUSH
19213: LD_STRING DEnd-Burlak-Ptr-1
19215: PPUSH
19216: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
19220: LD_EXP 52
19224: PUSH
19225: LD_EXP 52
19229: PPUSH
19230: CALL_OW 305
19234: AND
19235: IFFALSE 19249
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
19237: LD_EXP 52
19241: PPUSH
19242: LD_STRING DEnd-Burlak-Kuz-1
19244: PPUSH
19245: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
19249: LD_EXP 41
19253: PUSH
19254: LD_EXP 41
19258: PPUSH
19259: CALL_OW 305
19263: AND
19264: PUSH
19265: LD_EXP 54
19269: PPUSH
19270: CALL_OW 302
19274: AND
19275: IFFALSE 19289
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
19277: LD_EXP 41
19281: PPUSH
19282: LD_STRING DEnd-Burlak-Kir-1
19284: PPUSH
19285: CALL_OW 88
// if Joan then
19289: LD_EXP 36
19293: IFFALSE 19307
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
19295: LD_EXP 36
19299: PPUSH
19300: LD_STRING DEnd-Burlak-Joan-1
19302: PPUSH
19303: CALL_OW 88
// if IsOk ( Burlak ) then
19307: LD_EXP 54
19311: PPUSH
19312: CALL_OW 302
19316: IFFALSE 19330
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
19318: LD_EXP 21
19322: PPUSH
19323: LD_STRING DEnd-Burlak-JMM-1
19325: PPUSH
19326: CALL_OW 88
// dwait ( 0 0$2 ) ;
19330: LD_INT 70
19332: PPUSH
19333: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
19337: LD_EXP 59
19341: PPUSH
19342: LD_STRING DEnd-Szulc
19344: PPUSH
19345: CALL_OW 94
// dwait ( 0 0$1 ) ;
19349: LD_INT 35
19351: PPUSH
19352: CALL_OW 68
// if IsLive ( Burlak ) then
19356: LD_EXP 54
19360: PPUSH
19361: CALL_OW 300
19365: IFFALSE 19377
// med1 := 1 else
19367: LD_ADDR_VAR 0 1
19371: PUSH
19372: LD_INT 1
19374: ST_TO_ADDR
19375: GO 19386
// med1 := - 1 ;
19377: LD_ADDR_VAR 0 1
19381: PUSH
19382: LD_INT 1
19384: NEG
19385: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
19386: LD_EXP 12
19390: PUSH
19391: LD_EXP 13
19395: AND
19396: PUSH
19397: LD_EXP 14
19401: AND
19402: IFFALSE 19414
// med2 := 1 else
19404: LD_ADDR_VAR 0 2
19408: PUSH
19409: LD_INT 1
19411: ST_TO_ADDR
19412: GO 19423
// med2 := - 1 ;
19414: LD_ADDR_VAR 0 2
19418: PUSH
19419: LD_INT 1
19421: NEG
19422: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
19423: LD_STRING Hero
19425: PPUSH
19426: LD_INT 1
19428: PPUSH
19429: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
19433: LD_STRING Artefact
19435: PPUSH
19436: LD_VAR 0 2
19440: PPUSH
19441: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
19445: LD_STRING ReconcileBurlak
19447: PPUSH
19448: LD_VAR 0 1
19452: PPUSH
19453: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
19457: LD_OWVAR 67
19461: PUSH
19462: LD_INT 3
19464: GREATEREQUAL
19465: PUSH
19466: LD_VAR 0 1
19470: PUSH
19471: LD_INT 1
19473: EQUAL
19474: AND
19475: PUSH
19476: LD_VAR 0 2
19480: PUSH
19481: LD_INT 1
19483: EQUAL
19484: AND
19485: IFFALSE 19497
// SetAchievementEX ( ACH_AMER , 19 ) ;
19487: LD_STRING ACH_AMER
19489: PPUSH
19490: LD_INT 19
19492: PPUSH
19493: CALL_OW 564
// GiveMedals ( MAIN ) ;
19497: LD_STRING MAIN
19499: PPUSH
19500: CALL_OW 102
// InGameOff ;
19504: CALL_OW 9
// DialogueOff ;
19508: CALL_OW 7
// music_nat := 1 ;
19512: LD_ADDR_OWVAR 71
19516: PUSH
19517: LD_INT 1
19519: ST_TO_ADDR
// music_class := 4 ;
19520: LD_ADDR_OWVAR 72
19524: PUSH
19525: LD_INT 4
19527: ST_TO_ADDR
// YouWin ;
19528: CALL_OW 103
// end ; end_of_file
19532: PPOPN 2
19534: END
// export function InitNature ; begin
19535: LD_INT 0
19537: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
19538: LD_INT 3
19540: PPUSH
19541: LD_INT 3
19543: PPUSH
19544: LD_INT 2
19546: PPUSH
19547: LD_INT 1
19549: PPUSH
19550: LD_INT 1
19552: PPUSH
19553: LD_INT 0
19555: PPUSH
19556: LD_INT 0
19558: PPUSH
19559: LD_INT 17
19561: PPUSH
19562: LD_INT 0
19564: PPUSH
19565: CALL 88200 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
19569: LD_INT 2
19571: PPUSH
19572: LD_INT 1
19574: PPUSH
19575: LD_INT 1
19577: PPUSH
19578: LD_INT 1
19580: PPUSH
19581: LD_INT 1
19583: PPUSH
19584: LD_INT 0
19586: PPUSH
19587: LD_INT 0
19589: PPUSH
19590: LD_INT 18
19592: PPUSH
19593: LD_INT 0
19595: PPUSH
19596: CALL 88200 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
19600: LD_INT 4
19602: PPUSH
19603: LD_INT 1
19605: PPUSH
19606: LD_INT 2
19608: PPUSH
19609: LD_INT 4
19611: PPUSH
19612: LD_INT 2
19614: PPUSH
19615: LD_INT 1
19617: PPUSH
19618: LD_INT 0
19620: PPUSH
19621: LD_INT 19
19623: PPUSH
19624: LD_INT 0
19626: PPUSH
19627: CALL 88200 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
19631: LD_INT 0
19633: PPUSH
19634: LD_INT 0
19636: PPUSH
19637: LD_INT 0
19639: PPUSH
19640: LD_INT 0
19642: PPUSH
19643: LD_INT 0
19645: PPUSH
19646: LD_INT 0
19648: PPUSH
19649: LD_INT 9
19651: PPUSH
19652: LD_INT 0
19654: PPUSH
19655: LD_INT 20
19657: PPUSH
19658: CALL 88200 0 9
// end ; end_of_file
19662: LD_VAR 0 1
19666: RET
// every 0 0$30 do var time ;
19667: GO 19669
19669: DISABLE
19670: LD_INT 0
19672: PPUSH
// begin time := 0 0$30 ;
19673: LD_ADDR_VAR 0 1
19677: PUSH
19678: LD_INT 1050
19680: ST_TO_ADDR
// repeat wait ( time ) ;
19681: LD_VAR 0 1
19685: PPUSH
19686: CALL_OW 67
// if Prob ( 50 ) then
19690: LD_INT 50
19692: PPUSH
19693: CALL_OW 13
19697: IFFALSE 19726
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
19699: LD_INT 1
19701: PPUSH
19702: LD_INT 5
19704: PPUSH
19705: CALL_OW 12
19709: PPUSH
19710: LD_INT 106
19712: PPUSH
19713: LD_INT 89
19715: PPUSH
19716: LD_INT 45
19718: PPUSH
19719: LD_INT 1
19721: PPUSH
19722: CALL_OW 56
// time := time + 0 0$3 ;
19726: LD_ADDR_VAR 0 1
19730: PUSH
19731: LD_VAR 0 1
19735: PUSH
19736: LD_INT 105
19738: PLUS
19739: ST_TO_ADDR
// if Prob ( 30 ) then
19740: LD_INT 30
19742: PPUSH
19743: CALL_OW 13
19747: IFFALSE 19793
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
19749: LD_INT 525
19751: PPUSH
19752: LD_INT 735
19754: PPUSH
19755: CALL_OW 12
19759: PPUSH
19760: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
19764: LD_INT 1
19766: PPUSH
19767: LD_INT 5
19769: PPUSH
19770: CALL_OW 12
19774: PPUSH
19775: LD_INT 21
19777: PPUSH
19778: LD_INT 26
19780: PPUSH
19781: LD_INT 12
19783: PPUSH
19784: LD_INT 1
19786: PPUSH
19787: CALL_OW 56
// end else
19791: GO 19829
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
19793: LD_INT 700
19795: PPUSH
19796: LD_INT 1225
19798: PPUSH
19799: CALL_OW 12
19803: PPUSH
19804: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
19808: LD_INT 1
19810: PPUSH
19811: LD_INT 5
19813: PPUSH
19814: CALL_OW 12
19818: PPUSH
19819: LD_INT 14
19821: PPUSH
19822: LD_INT 1
19824: PPUSH
19825: CALL_OW 55
// end ; if Prob ( 50 ) then
19829: LD_INT 50
19831: PPUSH
19832: CALL_OW 13
19836: IFFALSE 19882
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
19838: LD_INT 700
19840: PPUSH
19841: LD_INT 1050
19843: PPUSH
19844: CALL_OW 12
19848: PPUSH
19849: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
19853: LD_INT 1
19855: PPUSH
19856: LD_INT 5
19858: PPUSH
19859: CALL_OW 12
19863: PPUSH
19864: LD_INT 181
19866: PPUSH
19867: LD_INT 218
19869: PPUSH
19870: LD_INT 16
19872: PPUSH
19873: LD_INT 1
19875: PPUSH
19876: CALL_OW 56
// end else
19880: GO 19954
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
19882: LD_INT 350
19884: PPUSH
19885: LD_INT 525
19887: PPUSH
19888: CALL_OW 12
19892: PPUSH
19893: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
19897: LD_INT 1
19899: PPUSH
19900: LD_INT 5
19902: PPUSH
19903: CALL_OW 12
19907: PPUSH
19908: LD_INT 13
19910: PPUSH
19911: LD_INT 1
19913: PPUSH
19914: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19918: LD_INT 350
19920: PPUSH
19921: LD_INT 700
19923: PPUSH
19924: CALL_OW 12
19928: PPUSH
19929: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
19933: LD_INT 1
19935: PPUSH
19936: LD_INT 5
19938: PPUSH
19939: CALL_OW 12
19943: PPUSH
19944: LD_INT 33
19946: PPUSH
19947: LD_INT 1
19949: PPUSH
19950: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
19954: LD_INT 65
19956: PUSH
19957: LD_INT 62
19959: PUSH
19960: LD_INT 55
19962: PUSH
19963: LD_INT 50
19965: PUSH
19966: EMPTY
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: PUSH
19972: LD_OWVAR 67
19976: ARRAY
19977: PPUSH
19978: CALL_OW 13
19982: IFFALSE 20028
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
19984: LD_INT 525
19986: PPUSH
19987: LD_INT 875
19989: PPUSH
19990: CALL_OW 12
19994: PPUSH
19995: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19999: LD_INT 1
20001: PPUSH
20002: LD_INT 5
20004: PPUSH
20005: CALL_OW 12
20009: PPUSH
20010: LD_INT 294
20012: PPUSH
20013: LD_INT 211
20015: PPUSH
20016: LD_INT 30
20018: PPUSH
20019: LD_INT 1
20021: PPUSH
20022: CALL_OW 56
// end else
20026: GO 20070
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
20028: LD_INT 420
20030: PPUSH
20031: LD_INT 770
20033: PPUSH
20034: CALL_OW 12
20038: PPUSH
20039: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
20043: LD_INT 1
20045: PPUSH
20046: LD_INT 5
20048: PPUSH
20049: CALL_OW 12
20053: PPUSH
20054: LD_INT 294
20056: PPUSH
20057: LD_INT 211
20059: PPUSH
20060: LD_INT 30
20062: PPUSH
20063: LD_INT 1
20065: PPUSH
20066: CALL_OW 56
// end ; if time > 2 2$20 then
20070: LD_VAR 0 1
20074: PUSH
20075: LD_INT 4900
20077: GREATER
20078: IFFALSE 20088
// time := 0 0$50 ;
20080: LD_ADDR_VAR 0 1
20084: PUSH
20085: LD_INT 1750
20087: ST_TO_ADDR
// until false ;
20088: LD_INT 0
20090: IFFALSE 19681
// end ;
20092: PPOPN 1
20094: END
// every 0 0$45 trigger tick < 10 10$00 do
20095: LD_OWVAR 1
20099: PUSH
20100: LD_INT 21000
20102: LESS
20103: IFFALSE 20151
20105: GO 20107
20107: DISABLE
// begin enable ;
20108: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
20109: LD_INT 350
20111: PPUSH
20112: LD_INT 700
20114: PPUSH
20115: CALL_OW 12
20119: PPUSH
20120: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
20124: LD_INT 3
20126: PPUSH
20127: LD_INT 5
20129: PPUSH
20130: CALL_OW 12
20134: PPUSH
20135: LD_INT 181
20137: PPUSH
20138: LD_INT 13
20140: PPUSH
20141: LD_INT 20
20143: PPUSH
20144: LD_INT 1
20146: PPUSH
20147: CALL_OW 56
// end ; end_of_file
20151: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
20152: LD_INT 0
20154: PPUSH
// SetArtifactRes ( 7 , true ) ;
20155: LD_INT 7
20157: PPUSH
20158: LD_INT 1
20160: PPUSH
20161: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
20165: LD_ADDR_EXP 68
20169: PUSH
20170: EMPTY
20171: PUSH
20172: EMPTY
20173: PUSH
20174: EMPTY
20175: PUSH
20176: EMPTY
20177: LIST
20178: LIST
20179: LIST
20180: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
20181: LD_ADDR_EXP 69
20185: PUSH
20186: LD_INT 1050
20188: PUSH
20189: LD_OWVAR 67
20193: MUL
20194: PUSH
20195: LD_INT 2800
20197: PUSH
20198: LD_OWVAR 67
20202: MUL
20203: PUSH
20204: LD_INT 1
20206: NEG
20207: PUSH
20208: EMPTY
20209: LIST
20210: LIST
20211: LIST
20212: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
20213: LD_ADDR_EXP 70
20217: PUSH
20218: LD_INT 10
20220: PUSH
20221: LD_INT 35
20223: PUSH
20224: LD_INT 100
20226: PUSH
20227: EMPTY
20228: LIST
20229: LIST
20230: LIST
20231: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
20232: LD_ADDR_EXP 71
20236: PUSH
20237: LD_INT 0
20239: PUSH
20240: LD_INT 0
20242: PUSH
20243: LD_INT 0
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: LIST
20250: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
20251: LD_ADDR_EXP 73
20255: PUSH
20256: LD_INT 300
20258: PUSH
20259: LD_INT 500
20261: PUSH
20262: LD_INT 800
20264: PUSH
20265: EMPTY
20266: LIST
20267: LIST
20268: LIST
20269: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
20270: LD_ADDR_EXP 74
20274: PUSH
20275: LD_INT 0
20277: PUSH
20278: LD_INT 0
20280: PUSH
20281: LD_INT 0
20283: PUSH
20284: EMPTY
20285: LIST
20286: LIST
20287: LIST
20288: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
20289: LD_ADDR_EXP 75
20293: PUSH
20294: LD_INT 0
20296: PUSH
20297: LD_INT 0
20299: PUSH
20300: LD_INT 0
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: LIST
20307: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
20308: LD_ADDR_EXP 72
20312: PUSH
20313: LD_INT 0
20315: PUSH
20316: LD_INT 0
20318: PUSH
20319: LD_INT 0
20321: PUSH
20322: EMPTY
20323: LIST
20324: LIST
20325: LIST
20326: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
20327: LD_ADDR_EXP 76
20331: PUSH
20332: LD_INT 4
20334: PUSH
20335: LD_INT 3
20337: PUSH
20338: LD_INT 1
20340: PUSH
20341: EMPTY
20342: LIST
20343: LIST
20344: LIST
20345: PUSH
20346: LD_INT 5
20348: PUSH
20349: LD_INT 4
20351: PUSH
20352: LD_INT 2
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: PUSH
20360: LD_INT 6
20362: PUSH
20363: LD_INT 3
20365: PUSH
20366: LD_INT 3
20368: PUSH
20369: EMPTY
20370: LIST
20371: LIST
20372: LIST
20373: PUSH
20374: EMPTY
20375: LIST
20376: LIST
20377: LIST
20378: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
20379: LD_ADDR_EXP 77
20383: PUSH
20384: LD_INT 0
20386: PUSH
20387: LD_INT 0
20389: PUSH
20390: LD_INT 0
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: LIST
20397: ST_TO_ADDR
// end ;
20398: LD_VAR 0 1
20402: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
20403: LD_INT 24
20405: PPUSH
20406: LD_INT 7
20408: PPUSH
20409: CALL_OW 321
20413: PUSH
20414: LD_INT 2
20416: EQUAL
20417: IFFALSE 21343
20419: GO 20421
20421: DISABLE
20422: LD_INT 0
20424: PPUSH
20425: PPUSH
20426: PPUSH
20427: PPUSH
20428: PPUSH
// begin enable ;
20429: ENABLE
// for i = 1 to 3 do
20430: LD_ADDR_VAR 0 1
20434: PUSH
20435: DOUBLE
20436: LD_INT 1
20438: DEC
20439: ST_TO_ADDR
20440: LD_INT 3
20442: PUSH
20443: FOR_TO
20444: IFFALSE 21341
// begin pos := FindArtifact ( i + 2 ) ;
20446: LD_ADDR_VAR 0 2
20450: PUSH
20451: LD_VAR 0 1
20455: PUSH
20456: LD_INT 2
20458: PLUS
20459: PPUSH
20460: CALL_OW 469
20464: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
20465: LD_ADDR_EXP 68
20469: PUSH
20470: LD_EXP 68
20474: PPUSH
20475: LD_VAR 0 1
20479: PPUSH
20480: LD_VAR 0 2
20484: PPUSH
20485: CALL_OW 1
20489: ST_TO_ADDR
// if pos then
20490: LD_VAR 0 2
20494: IFFALSE 21202
// begin case i of 1 :
20496: LD_VAR 0 1
20500: PUSH
20501: LD_INT 1
20503: DOUBLE
20504: EQUAL
20505: IFTRUE 20509
20507: GO 20586
20509: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
20510: LD_ADDR_VAR 0 4
20514: PUSH
20515: LD_INT 22
20517: PUSH
20518: LD_INT 7
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: PUSH
20525: LD_INT 23
20527: PUSH
20528: LD_INT 1
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: LD_INT 2
20537: PUSH
20538: LD_INT 30
20540: PUSH
20541: LD_INT 8
20543: PUSH
20544: EMPTY
20545: LIST
20546: LIST
20547: PUSH
20548: LD_INT 30
20550: PUSH
20551: LD_INT 7
20553: PUSH
20554: EMPTY
20555: LIST
20556: LIST
20557: PUSH
20558: LD_INT 30
20560: PUSH
20561: LD_INT 11
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: PUSH
20568: EMPTY
20569: LIST
20570: LIST
20571: LIST
20572: LIST
20573: PUSH
20574: EMPTY
20575: LIST
20576: LIST
20577: LIST
20578: PPUSH
20579: CALL_OW 69
20583: ST_TO_ADDR
20584: GO 20694
20586: LD_INT 2
20588: DOUBLE
20589: EQUAL
20590: IFTRUE 20594
20592: GO 20671
20594: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
20595: LD_ADDR_VAR 0 4
20599: PUSH
20600: LD_INT 22
20602: PUSH
20603: LD_INT 7
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PUSH
20610: LD_INT 23
20612: PUSH
20613: LD_INT 3
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: PUSH
20620: LD_INT 2
20622: PUSH
20623: LD_INT 30
20625: PUSH
20626: LD_INT 8
20628: PUSH
20629: EMPTY
20630: LIST
20631: LIST
20632: PUSH
20633: LD_INT 30
20635: PUSH
20636: LD_INT 7
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: PUSH
20643: LD_INT 30
20645: PUSH
20646: LD_INT 11
20648: PUSH
20649: EMPTY
20650: LIST
20651: LIST
20652: PUSH
20653: EMPTY
20654: LIST
20655: LIST
20656: LIST
20657: LIST
20658: PUSH
20659: EMPTY
20660: LIST
20661: LIST
20662: LIST
20663: PPUSH
20664: CALL_OW 69
20668: ST_TO_ADDR
20669: GO 20694
20671: LD_INT 3
20673: DOUBLE
20674: EQUAL
20675: IFTRUE 20679
20677: GO 20693
20679: POP
// labs := [ alien ] ; end ;
20680: LD_ADDR_VAR 0 4
20684: PUSH
20685: LD_INT 1
20687: PUSH
20688: EMPTY
20689: LIST
20690: ST_TO_ADDR
20691: GO 20694
20693: POP
// if not labs then
20694: LD_VAR 0 4
20698: NOT
20699: IFFALSE 20703
// continue ;
20701: GO 20443
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
20703: LD_ADDR_VAR 0 5
20707: PUSH
20708: LD_VAR 0 4
20712: PPUSH
20713: LD_EXP 68
20717: PUSH
20718: LD_VAR 0 1
20722: ARRAY
20723: PUSH
20724: LD_INT 1
20726: ARRAY
20727: PPUSH
20728: LD_EXP 68
20732: PUSH
20733: LD_VAR 0 1
20737: ARRAY
20738: PUSH
20739: LD_INT 2
20741: ARRAY
20742: PPUSH
20743: CALL_OW 73
20747: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
20748: LD_VAR 0 5
20752: NOT
20753: PUSH
20754: LD_VAR 0 5
20758: PUSH
20759: LD_EXP 75
20763: PUSH
20764: LD_VAR 0 1
20768: ARRAY
20769: NONEQUAL
20770: OR
20771: IFFALSE 20876
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20773: LD_INT 7
20775: PPUSH
20776: LD_EXP 76
20780: PUSH
20781: LD_VAR 0 1
20785: ARRAY
20786: PUSH
20787: LD_INT 3
20789: ARRAY
20790: PPUSH
20791: LD_INT 0
20793: PPUSH
20794: LD_EXP 75
20798: PUSH
20799: LD_VAR 0 1
20803: ARRAY
20804: PPUSH
20805: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20809: LD_INT 7
20811: PPUSH
20812: LD_EXP 76
20816: PUSH
20817: LD_VAR 0 1
20821: ARRAY
20822: PUSH
20823: LD_INT 1
20825: ARRAY
20826: PPUSH
20827: LD_INT 0
20829: PPUSH
20830: LD_EXP 75
20834: PUSH
20835: LD_VAR 0 1
20839: ARRAY
20840: PPUSH
20841: CALL_OW 468
// if nearestLab then
20845: LD_VAR 0 5
20849: IFFALSE 20876
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
20851: LD_ADDR_EXP 75
20855: PUSH
20856: LD_EXP 75
20860: PPUSH
20861: LD_VAR 0 1
20865: PPUSH
20866: LD_VAR 0 5
20870: PPUSH
20871: CALL_OW 1
20875: ST_TO_ADDR
// end ; if not nearestLab then
20876: LD_VAR 0 5
20880: NOT
20881: IFFALSE 20885
// continue ;
20883: GO 20443
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
20885: LD_VAR 0 5
20889: PPUSH
20890: LD_EXP 68
20894: PUSH
20895: LD_VAR 0 1
20899: ARRAY
20900: PUSH
20901: LD_INT 1
20903: ARRAY
20904: PPUSH
20905: LD_EXP 68
20909: PUSH
20910: LD_VAR 0 1
20914: ARRAY
20915: PUSH
20916: LD_INT 2
20918: ARRAY
20919: PPUSH
20920: CALL_OW 297
20924: PUSH
20925: LD_INT 8
20927: LESS
20928: IFFALSE 21125
// begin if not artifactsResearched [ i ] then
20930: LD_EXP 71
20934: PUSH
20935: LD_VAR 0 1
20939: ARRAY
20940: NOT
20941: IFFALSE 21022
// begin if BuildingStatus ( nearestLab ) = bs_idle then
20943: LD_VAR 0 5
20947: PPUSH
20948: CALL_OW 461
20952: PUSH
20953: LD_INT 2
20955: EQUAL
20956: IFFALSE 20990
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
20958: LD_INT 7
20960: PPUSH
20961: LD_EXP 76
20965: PUSH
20966: LD_VAR 0 1
20970: ARRAY
20971: PUSH
20972: LD_INT 3
20974: ARRAY
20975: PPUSH
20976: LD_INT 2
20978: PPUSH
20979: LD_VAR 0 5
20983: PPUSH
20984: CALL_OW 468
20988: GO 21020
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
20990: LD_INT 7
20992: PPUSH
20993: LD_EXP 76
20997: PUSH
20998: LD_VAR 0 1
21002: ARRAY
21003: PUSH
21004: LD_INT 3
21006: ARRAY
21007: PPUSH
21008: LD_INT 1
21010: PPUSH
21011: LD_VAR 0 5
21015: PPUSH
21016: CALL_OW 468
// end else
21020: GO 21123
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
21022: LD_VAR 0 5
21026: PPUSH
21027: CALL_OW 461
21031: PUSH
21032: LD_INT 2
21034: EQUAL
21035: PUSH
21036: LD_EXP 77
21040: PUSH
21041: LD_VAR 0 1
21045: ARRAY
21046: AND
21047: IFFALSE 21093
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
21049: LD_INT 7
21051: PPUSH
21052: LD_EXP 76
21056: PUSH
21057: LD_VAR 0 1
21061: ARRAY
21062: PUSH
21063: LD_INT 1
21065: ARRAY
21066: PPUSH
21067: LD_EXP 76
21071: PUSH
21072: LD_VAR 0 1
21076: ARRAY
21077: PUSH
21078: LD_INT 2
21080: ARRAY
21081: PPUSH
21082: LD_VAR 0 5
21086: PPUSH
21087: CALL_OW 468
21091: GO 21123
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
21093: LD_INT 7
21095: PPUSH
21096: LD_EXP 76
21100: PUSH
21101: LD_VAR 0 1
21105: ARRAY
21106: PUSH
21107: LD_INT 1
21109: ARRAY
21110: PPUSH
21111: LD_INT 1
21113: PPUSH
21114: LD_VAR 0 5
21118: PPUSH
21119: CALL_OW 468
// end else
21123: GO 21200
// begin if not artifactsResearched [ i ] then
21125: LD_EXP 71
21129: PUSH
21130: LD_VAR 0 1
21134: ARRAY
21135: NOT
21136: IFFALSE 21170
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
21138: LD_INT 7
21140: PPUSH
21141: LD_EXP 76
21145: PUSH
21146: LD_VAR 0 1
21150: ARRAY
21151: PUSH
21152: LD_INT 3
21154: ARRAY
21155: PPUSH
21156: LD_INT 0
21158: PPUSH
21159: LD_VAR 0 5
21163: PPUSH
21164: CALL_OW 468
21168: GO 21200
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
21170: LD_INT 7
21172: PPUSH
21173: LD_EXP 76
21177: PUSH
21178: LD_VAR 0 1
21182: ARRAY
21183: PUSH
21184: LD_INT 1
21186: ARRAY
21187: PPUSH
21188: LD_INT 0
21190: PPUSH
21191: LD_VAR 0 5
21195: PPUSH
21196: CALL_OW 468
// end ; end else
21200: GO 21339
// begin if not artifactsLabs [ i ] then
21202: LD_EXP 75
21206: PUSH
21207: LD_VAR 0 1
21211: ARRAY
21212: NOT
21213: IFFALSE 21217
// continue ;
21215: GO 20443
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
21217: LD_INT 7
21219: PPUSH
21220: LD_EXP 76
21224: PUSH
21225: LD_VAR 0 1
21229: ARRAY
21230: PUSH
21231: LD_INT 3
21233: ARRAY
21234: PPUSH
21235: LD_INT 0
21237: PPUSH
21238: LD_EXP 75
21242: PUSH
21243: LD_VAR 0 1
21247: ARRAY
21248: PPUSH
21249: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
21253: LD_INT 7
21255: PPUSH
21256: LD_EXP 76
21260: PUSH
21261: LD_VAR 0 1
21265: ARRAY
21266: PUSH
21267: LD_INT 1
21269: ARRAY
21270: PPUSH
21271: LD_INT 0
21273: PPUSH
21274: LD_EXP 75
21278: PUSH
21279: LD_VAR 0 1
21283: ARRAY
21284: PPUSH
21285: CALL_OW 468
// if artifactsLabsWorking [ i ] then
21289: LD_EXP 72
21293: PUSH
21294: LD_VAR 0 1
21298: ARRAY
21299: IFFALSE 21339
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
21301: LD_ADDR_EXP 72
21305: PUSH
21306: LD_EXP 72
21310: PPUSH
21311: LD_VAR 0 1
21315: PPUSH
21316: LD_INT 0
21318: PPUSH
21319: CALL_OW 1
21323: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
21324: LD_EXP 75
21328: PUSH
21329: LD_VAR 0 1
21333: ARRAY
21334: PPUSH
21335: CALL_OW 127
// end ; end ; end ;
21339: GO 20443
21341: POP
21342: POP
// end ;
21343: PPOPN 5
21345: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un , base ;
21346: LD_INT 0
21348: PPUSH
21349: PPUSH
21350: PPUSH
21351: PPUSH
21352: PPUSH
21353: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
21354: LD_VAR 0 2
21358: PUSH
21359: LD_EXP 76
21363: PUSH
21364: LD_INT 1
21366: ARRAY
21367: PUSH
21368: LD_INT 3
21370: ARRAY
21371: EQUAL
21372: IFFALSE 21495
// begin lab := artifactsLabs [ 1 ] ;
21374: LD_ADDR_VAR 0 6
21378: PUSH
21379: LD_EXP 75
21383: PUSH
21384: LD_INT 1
21386: ARRAY
21387: ST_TO_ADDR
// if not lab then
21388: LD_VAR 0 6
21392: NOT
21393: IFFALSE 21397
// exit ;
21395: GO 22625
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
21397: LD_VAR 0 6
21401: PPUSH
21402: LD_EXP 73
21406: PUSH
21407: LD_INT 1
21409: ARRAY
21410: PPUSH
21411: LD_INT 1
21413: PPUSH
21414: CALL_OW 486
// if artifactsResProgress [ 1 ] then
21418: LD_EXP 74
21422: PUSH
21423: LD_INT 1
21425: ARRAY
21426: IFFALSE 21446
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
21428: LD_VAR 0 6
21432: PPUSH
21433: LD_EXP 74
21437: PUSH
21438: LD_INT 1
21440: ARRAY
21441: PPUSH
21442: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
21446: LD_ADDR_EXP 72
21450: PUSH
21451: LD_EXP 72
21455: PPUSH
21456: LD_INT 1
21458: PPUSH
21459: LD_INT 1
21461: PPUSH
21462: CALL_OW 1
21466: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
21467: LD_INT 7
21469: PPUSH
21470: LD_EXP 76
21474: PUSH
21475: LD_INT 1
21477: ARRAY
21478: PUSH
21479: LD_INT 3
21481: ARRAY
21482: PPUSH
21483: LD_INT 0
21485: PPUSH
21486: LD_VAR 0 6
21490: PPUSH
21491: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
21495: LD_VAR 0 2
21499: PUSH
21500: LD_EXP 76
21504: PUSH
21505: LD_INT 2
21507: ARRAY
21508: PUSH
21509: LD_INT 3
21511: ARRAY
21512: EQUAL
21513: IFFALSE 21636
// begin lab := artifactsLabs [ 2 ] ;
21515: LD_ADDR_VAR 0 6
21519: PUSH
21520: LD_EXP 75
21524: PUSH
21525: LD_INT 2
21527: ARRAY
21528: ST_TO_ADDR
// if not lab then
21529: LD_VAR 0 6
21533: NOT
21534: IFFALSE 21538
// exit ;
21536: GO 22625
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
21538: LD_VAR 0 6
21542: PPUSH
21543: LD_EXP 73
21547: PUSH
21548: LD_INT 2
21550: ARRAY
21551: PPUSH
21552: LD_INT 1
21554: PPUSH
21555: CALL_OW 486
// if artifactsResProgress [ 2 ] then
21559: LD_EXP 74
21563: PUSH
21564: LD_INT 2
21566: ARRAY
21567: IFFALSE 21587
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
21569: LD_VAR 0 6
21573: PPUSH
21574: LD_EXP 74
21578: PUSH
21579: LD_INT 2
21581: ARRAY
21582: PPUSH
21583: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
21587: LD_ADDR_EXP 72
21591: PUSH
21592: LD_EXP 72
21596: PPUSH
21597: LD_INT 2
21599: PPUSH
21600: LD_INT 1
21602: PPUSH
21603: CALL_OW 1
21607: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
21608: LD_INT 7
21610: PPUSH
21611: LD_EXP 76
21615: PUSH
21616: LD_INT 2
21618: ARRAY
21619: PUSH
21620: LD_INT 3
21622: ARRAY
21623: PPUSH
21624: LD_INT 0
21626: PPUSH
21627: LD_VAR 0 6
21631: PPUSH
21632: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
21636: LD_VAR 0 2
21640: PUSH
21641: LD_EXP 76
21645: PUSH
21646: LD_INT 3
21648: ARRAY
21649: PUSH
21650: LD_INT 3
21652: ARRAY
21653: EQUAL
21654: IFFALSE 21777
// begin lab := artifactsLabs [ 3 ] ;
21656: LD_ADDR_VAR 0 6
21660: PUSH
21661: LD_EXP 75
21665: PUSH
21666: LD_INT 3
21668: ARRAY
21669: ST_TO_ADDR
// if not lab then
21670: LD_VAR 0 6
21674: NOT
21675: IFFALSE 21679
// exit ;
21677: GO 22625
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
21679: LD_VAR 0 6
21683: PPUSH
21684: LD_EXP 73
21688: PUSH
21689: LD_INT 3
21691: ARRAY
21692: PPUSH
21693: LD_INT 1
21695: PPUSH
21696: CALL_OW 486
// if artifactsResProgress [ 3 ] then
21700: LD_EXP 74
21704: PUSH
21705: LD_INT 3
21707: ARRAY
21708: IFFALSE 21728
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
21710: LD_VAR 0 6
21714: PPUSH
21715: LD_EXP 74
21719: PUSH
21720: LD_INT 3
21722: ARRAY
21723: PPUSH
21724: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
21728: LD_ADDR_EXP 72
21732: PUSH
21733: LD_EXP 72
21737: PPUSH
21738: LD_INT 3
21740: PPUSH
21741: LD_INT 1
21743: PPUSH
21744: CALL_OW 1
21748: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
21749: LD_INT 7
21751: PPUSH
21752: LD_EXP 76
21756: PUSH
21757: LD_INT 3
21759: ARRAY
21760: PUSH
21761: LD_INT 3
21763: ARRAY
21764: PPUSH
21765: LD_INT 0
21767: PPUSH
21768: LD_VAR 0 6
21772: PPUSH
21773: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
21777: LD_VAR 0 2
21781: PUSH
21782: LD_EXP 76
21786: PUSH
21787: LD_INT 1
21789: ARRAY
21790: PUSH
21791: LD_INT 1
21793: ARRAY
21794: EQUAL
21795: IFFALSE 22003
// begin lab := artifactsLabs [ 1 ] ;
21797: LD_ADDR_VAR 0 6
21801: PUSH
21802: LD_EXP 75
21806: PUSH
21807: LD_INT 1
21809: ARRAY
21810: ST_TO_ADDR
// base := GetBase ( lab ) ;
21811: LD_ADDR_VAR 0 10
21815: PUSH
21816: LD_VAR 0 6
21820: PPUSH
21821: CALL_OW 274
21825: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
21826: LD_VAR 0 6
21830: PPUSH
21831: CALL_OW 274
21835: PPUSH
21836: CALL 91753 0 1
21840: PUSH
21841: LD_INT 3
21843: ARRAY
21844: PUSH
21845: LD_EXP 70
21849: PUSH
21850: LD_INT 1
21852: ARRAY
21853: LESS
21854: IFFALSE 21868
// begin HintSpec ( ArtifactCost , 2 ) ;
21856: LD_STRING ArtifactCost
21858: PPUSH
21859: LD_INT 2
21861: PPUSH
21862: CALL_OW 338
// exit ;
21866: GO 22625
// end ; SetResourceType ( base , mat_siberit , ( GetResourceType ( base , mat_siberit ) - artifactsSibCost [ 1 ] ) ) ;
21868: LD_VAR 0 10
21872: PPUSH
21873: LD_INT 3
21875: PPUSH
21876: LD_VAR 0 10
21880: PPUSH
21881: LD_INT 3
21883: PPUSH
21884: CALL_OW 275
21888: PUSH
21889: LD_EXP 70
21893: PUSH
21894: LD_INT 1
21896: ARRAY
21897: MINUS
21898: PPUSH
21899: CALL_OW 277
// artifactsReady := Replace ( artifactsReady , 1 , false ) ;
21903: LD_ADDR_EXP 77
21907: PUSH
21908: LD_EXP 77
21912: PPUSH
21913: LD_INT 1
21915: PPUSH
21916: LD_INT 0
21918: PPUSH
21919: CALL_OW 1
21923: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
21924: LD_VAR 0 3
21928: PPUSH
21929: LD_VAR 0 4
21933: PPUSH
21934: LD_INT 7
21936: PPUSH
21937: LD_INT 12
21939: NEG
21940: PPUSH
21941: CALL_OW 330
// wait ( 0 0$30 ) ;
21945: LD_INT 1050
21947: PPUSH
21948: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
21952: LD_VAR 0 3
21956: PPUSH
21957: LD_VAR 0 4
21961: PPUSH
21962: LD_INT 7
21964: PPUSH
21965: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
21969: LD_EXP 69
21973: PUSH
21974: LD_INT 1
21976: ARRAY
21977: PPUSH
21978: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
21982: LD_ADDR_EXP 77
21986: PUSH
21987: LD_EXP 77
21991: PPUSH
21992: LD_INT 1
21994: PPUSH
21995: LD_INT 1
21997: PPUSH
21998: CALL_OW 1
22002: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
22003: LD_VAR 0 2
22007: PUSH
22008: LD_EXP 76
22012: PUSH
22013: LD_INT 2
22015: ARRAY
22016: PUSH
22017: LD_INT 1
22019: ARRAY
22020: EQUAL
22021: IFFALSE 22308
// begin lab := artifactsLabs [ 2 ] ;
22023: LD_ADDR_VAR 0 6
22027: PUSH
22028: LD_EXP 75
22032: PUSH
22033: LD_INT 2
22035: ARRAY
22036: ST_TO_ADDR
// base := GetBase ( lab ) ;
22037: LD_ADDR_VAR 0 10
22041: PUSH
22042: LD_VAR 0 6
22046: PPUSH
22047: CALL_OW 274
22051: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
22052: LD_VAR 0 3
22056: PUSH
22057: LD_INT 81
22059: PUSH
22060: LD_INT 7
22062: PUSH
22063: EMPTY
22064: LIST
22065: LIST
22066: PUSH
22067: LD_INT 2
22069: PUSH
22070: LD_INT 32
22072: PUSH
22073: LD_INT 3
22075: PUSH
22076: EMPTY
22077: LIST
22078: LIST
22079: PUSH
22080: LD_INT 30
22082: PUSH
22083: LD_INT 28
22085: PUSH
22086: EMPTY
22087: LIST
22088: LIST
22089: PUSH
22090: LD_INT 30
22092: PUSH
22093: LD_INT 30
22095: PUSH
22096: EMPTY
22097: LIST
22098: LIST
22099: PUSH
22100: LD_INT 35
22102: PUSH
22103: LD_INT 49
22105: PUSH
22106: EMPTY
22107: LIST
22108: LIST
22109: PUSH
22110: LD_INT 34
22112: PUSH
22113: LD_INT 49
22115: PUSH
22116: EMPTY
22117: LIST
22118: LIST
22119: PUSH
22120: LD_INT 30
22122: PUSH
22123: LD_INT 21
22125: PUSH
22126: EMPTY
22127: LIST
22128: LIST
22129: PUSH
22130: EMPTY
22131: LIST
22132: LIST
22133: LIST
22134: LIST
22135: LIST
22136: LIST
22137: LIST
22138: PUSH
22139: EMPTY
22140: LIST
22141: LIST
22142: PPUSH
22143: CALL_OW 69
22147: IN
22148: NOT
22149: IFFALSE 22153
// exit ;
22151: GO 22625
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
22153: LD_VAR 0 6
22157: PPUSH
22158: CALL_OW 274
22162: PPUSH
22163: CALL 91753 0 1
22167: PUSH
22168: LD_INT 3
22170: ARRAY
22171: PUSH
22172: LD_EXP 70
22176: PUSH
22177: LD_INT 2
22179: ARRAY
22180: LESS
22181: IFFALSE 22195
// begin HintSpec ( ArtifactCost , 2 ) ;
22183: LD_STRING ArtifactCost
22185: PPUSH
22186: LD_INT 2
22188: PPUSH
22189: CALL_OW 338
// exit ;
22193: GO 22625
// end ; SetResourceType ( base , mat_siberit , ( GetResourceType ( base , mat_siberit ) - artifactsSibCost [ 2 ] ) ) ;
22195: LD_VAR 0 10
22199: PPUSH
22200: LD_INT 3
22202: PPUSH
22203: LD_VAR 0 10
22207: PPUSH
22208: LD_INT 3
22210: PPUSH
22211: CALL_OW 275
22215: PUSH
22216: LD_EXP 70
22220: PUSH
22221: LD_INT 2
22223: ARRAY
22224: MINUS
22225: PPUSH
22226: CALL_OW 277
// artifactsReady := Replace ( artifactsReady , 2 , false ) ;
22230: LD_ADDR_EXP 77
22234: PUSH
22235: LD_EXP 77
22239: PPUSH
22240: LD_INT 2
22242: PPUSH
22243: LD_INT 0
22245: PPUSH
22246: CALL_OW 1
22250: ST_TO_ADDR
// KillUnit ( x ) ;
22251: LD_VAR 0 3
22255: PPUSH
22256: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
22260: LD_ADDR_EXP 16
22264: PUSH
22265: LD_EXP 16
22269: PUSH
22270: LD_INT 1
22272: PLUS
22273: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
22274: LD_EXP 69
22278: PUSH
22279: LD_INT 2
22281: ARRAY
22282: PPUSH
22283: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
22287: LD_ADDR_EXP 77
22291: PUSH
22292: LD_EXP 77
22296: PPUSH
22297: LD_INT 2
22299: PPUSH
22300: LD_INT 1
22302: PPUSH
22303: CALL_OW 1
22307: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
22308: LD_VAR 0 2
22312: PUSH
22313: LD_EXP 76
22317: PUSH
22318: LD_INT 3
22320: ARRAY
22321: PUSH
22322: LD_INT 1
22324: ARRAY
22325: EQUAL
22326: IFFALSE 22625
// begin lab := artifactsLabs [ 3 ] ;
22328: LD_ADDR_VAR 0 6
22332: PUSH
22333: LD_EXP 75
22337: PUSH
22338: LD_INT 3
22340: ARRAY
22341: ST_TO_ADDR
// base := GetBase ( lab ) ;
22342: LD_ADDR_VAR 0 10
22346: PUSH
22347: LD_VAR 0 6
22351: PPUSH
22352: CALL_OW 274
22356: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
22357: LD_VAR 0 6
22361: PPUSH
22362: CALL_OW 274
22366: PPUSH
22367: CALL 91753 0 1
22371: PUSH
22372: LD_INT 3
22374: ARRAY
22375: PUSH
22376: LD_EXP 70
22380: PUSH
22381: LD_INT 3
22383: ARRAY
22384: LESS
22385: IFFALSE 22399
// begin HintSpec ( ArtifactCost , 2 ) ;
22387: LD_STRING ArtifactCost
22389: PPUSH
22390: LD_INT 2
22392: PPUSH
22393: CALL_OW 338
// exit ;
22397: GO 22625
// end ; SetResourceType ( base , mat_siberit , ( GetResourceType ( base , mat_siberit ) - artifactsSibCost [ 3 ] ) ) ;
22399: LD_VAR 0 10
22403: PPUSH
22404: LD_INT 3
22406: PPUSH
22407: LD_VAR 0 10
22411: PPUSH
22412: LD_INT 3
22414: PPUSH
22415: CALL_OW 275
22419: PUSH
22420: LD_EXP 70
22424: PUSH
22425: LD_INT 3
22427: ARRAY
22428: MINUS
22429: PPUSH
22430: CALL_OW 277
// SetAreaMapShow ( teleportArea , 1 ) ;
22434: LD_INT 37
22436: PPUSH
22437: LD_INT 1
22439: PPUSH
22440: CALL_OW 424
// time := 0 0$30 ;
22444: LD_ADDR_VAR 0 7
22448: PUSH
22449: LD_INT 1050
22451: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
22452: LD_ADDR_EXP 77
22456: PUSH
22457: LD_EXP 77
22461: PPUSH
22462: LD_INT 3
22464: PPUSH
22465: LD_INT 0
22467: PPUSH
22468: CALL_OW 1
22472: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
22473: LD_ADDR_OWVAR 47
22477: PUSH
22478: LD_STRING #Am15a-1
22480: PUSH
22481: LD_VAR 0 7
22485: PUSH
22486: EMPTY
22487: LIST
22488: LIST
22489: ST_TO_ADDR
// wait ( 0 0$1 ) ;
22490: LD_INT 35
22492: PPUSH
22493: CALL_OW 67
// time := time - 0 0$1 ;
22497: LD_ADDR_VAR 0 7
22501: PUSH
22502: LD_VAR 0 7
22506: PUSH
22507: LD_INT 35
22509: MINUS
22510: ST_TO_ADDR
// until time = 0 0$00 ;
22511: LD_VAR 0 7
22515: PUSH
22516: LD_INT 0
22518: EQUAL
22519: IFFALSE 22473
// display_strings :=  ;
22521: LD_ADDR_OWVAR 47
22525: PUSH
22526: LD_STRING 
22528: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
22529: LD_INT 37
22531: PPUSH
22532: LD_INT 0
22534: PPUSH
22535: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
22539: LD_ADDR_VAR 0 8
22543: PUSH
22544: LD_INT 37
22546: PPUSH
22547: LD_INT 3
22549: PUSH
22550: LD_INT 21
22552: PUSH
22553: LD_INT 3
22555: PUSH
22556: EMPTY
22557: LIST
22558: LIST
22559: PUSH
22560: EMPTY
22561: LIST
22562: LIST
22563: PPUSH
22564: CALL_OW 70
22568: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
22569: LD_VAR 0 3
22573: PPUSH
22574: LD_VAR 0 4
22578: PPUSH
22579: CALL_OW 84
// for un in list do
22583: LD_ADDR_VAR 0 9
22587: PUSH
22588: LD_VAR 0 8
22592: PUSH
22593: FOR_IN
22594: IFFALSE 22623
// TeleportUnit ( un , x , y , 12 , true ) ;
22596: LD_VAR 0 9
22600: PPUSH
22601: LD_VAR 0 3
22605: PPUSH
22606: LD_VAR 0 4
22610: PPUSH
22611: LD_INT 12
22613: PPUSH
22614: LD_INT 1
22616: PPUSH
22617: CALL_OW 483
22621: GO 22593
22623: POP
22624: POP
// end ; end ;
22625: PPOPN 10
22627: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
22628: LD_INT 0
22630: PPUSH
22631: PPUSH
// begin labNum := 0 ;
22632: LD_ADDR_VAR 0 4
22636: PUSH
22637: LD_INT 0
22639: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22640: LD_ADDR_VAR 0 3
22644: PUSH
22645: DOUBLE
22646: LD_INT 1
22648: DEC
22649: ST_TO_ADDR
22650: LD_EXP 75
22654: PUSH
22655: FOR_TO
22656: IFFALSE 22690
// if artifactsLabs [ i ] = lab then
22658: LD_EXP 75
22662: PUSH
22663: LD_VAR 0 3
22667: ARRAY
22668: PUSH
22669: LD_VAR 0 1
22673: EQUAL
22674: IFFALSE 22688
// begin labNum := i ;
22676: LD_ADDR_VAR 0 4
22680: PUSH
22681: LD_VAR 0 3
22685: ST_TO_ADDR
// break ;
22686: GO 22690
// end ;
22688: GO 22655
22690: POP
22691: POP
// if not labNum then
22692: LD_VAR 0 4
22696: NOT
22697: IFFALSE 22701
// exit ;
22699: GO 22779
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
22701: LD_INT 7
22703: PPUSH
22704: LD_EXP 76
22708: PUSH
22709: LD_VAR 0 4
22713: ARRAY
22714: PUSH
22715: LD_INT 3
22717: ARRAY
22718: PPUSH
22719: LD_INT 2
22721: PPUSH
22722: LD_VAR 0 1
22726: PPUSH
22727: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
22731: LD_ADDR_EXP 74
22735: PUSH
22736: LD_EXP 74
22740: PPUSH
22741: LD_VAR 0 4
22745: PPUSH
22746: LD_VAR 0 2
22750: PPUSH
22751: CALL_OW 1
22755: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
22756: LD_ADDR_EXP 72
22760: PUSH
22761: LD_EXP 72
22765: PPUSH
22766: LD_VAR 0 4
22770: PPUSH
22771: LD_INT 0
22773: PPUSH
22774: CALL_OW 1
22778: ST_TO_ADDR
// end ;
22779: PPOPN 4
22781: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
22782: LD_INT 0
22784: PPUSH
22785: PPUSH
// begin labNum := 0 ;
22786: LD_ADDR_VAR 0 3
22790: PUSH
22791: LD_INT 0
22793: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22794: LD_ADDR_VAR 0 2
22798: PUSH
22799: DOUBLE
22800: LD_INT 1
22802: DEC
22803: ST_TO_ADDR
22804: LD_EXP 75
22808: PUSH
22809: FOR_TO
22810: IFFALSE 22844
// if artifactsLabs [ i ] = lab then
22812: LD_EXP 75
22816: PUSH
22817: LD_VAR 0 2
22821: ARRAY
22822: PUSH
22823: LD_VAR 0 1
22827: EQUAL
22828: IFFALSE 22842
// begin labNum := i ;
22830: LD_ADDR_VAR 0 3
22834: PUSH
22835: LD_VAR 0 2
22839: ST_TO_ADDR
// break ;
22840: GO 22844
// end ;
22842: GO 22809
22844: POP
22845: POP
// if not labNum then
22846: LD_VAR 0 3
22850: NOT
22851: IFFALSE 22855
// exit ;
22853: GO 23017
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
22855: LD_INT 7
22857: PPUSH
22858: LD_EXP 76
22862: PUSH
22863: LD_VAR 0 3
22867: ARRAY
22868: PUSH
22869: LD_INT 3
22871: ARRAY
22872: PPUSH
22873: LD_INT 0
22875: PPUSH
22876: LD_VAR 0 1
22880: PPUSH
22881: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
22885: LD_ADDR_EXP 71
22889: PUSH
22890: LD_EXP 71
22894: PPUSH
22895: LD_VAR 0 3
22899: PPUSH
22900: LD_INT 1
22902: PPUSH
22903: CALL_OW 1
22907: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
22908: LD_ADDR_EXP 77
22912: PUSH
22913: LD_EXP 77
22917: PPUSH
22918: LD_VAR 0 3
22922: PPUSH
22923: LD_INT 1
22925: PPUSH
22926: CALL_OW 1
22930: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
22931: LD_ADDR_EXP 72
22935: PUSH
22936: LD_EXP 72
22940: PPUSH
22941: LD_VAR 0 3
22945: PPUSH
22946: LD_INT 0
22948: PPUSH
22949: CALL_OW 1
22953: ST_TO_ADDR
// case labNum of 1 :
22954: LD_VAR 0 3
22958: PUSH
22959: LD_INT 1
22961: DOUBLE
22962: EQUAL
22963: IFTRUE 22967
22965: GO 22978
22967: POP
// artifactIResearched := true ; 2 :
22968: LD_ADDR_EXP 12
22972: PUSH
22973: LD_INT 1
22975: ST_TO_ADDR
22976: GO 23017
22978: LD_INT 2
22980: DOUBLE
22981: EQUAL
22982: IFTRUE 22986
22984: GO 22997
22986: POP
// artifactIIResearched := true ; 3 :
22987: LD_ADDR_EXP 13
22991: PUSH
22992: LD_INT 1
22994: ST_TO_ADDR
22995: GO 23017
22997: LD_INT 3
22999: DOUBLE
23000: EQUAL
23001: IFTRUE 23005
23003: GO 23016
23005: POP
// artifactIIIResearched := true ; end ;
23006: LD_ADDR_EXP 14
23010: PUSH
23011: LD_INT 1
23013: ST_TO_ADDR
23014: GO 23017
23016: POP
// end ; end_of_file
23017: PPOPN 3
23019: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
23020: LD_INT 0
23022: PPUSH
23023: PPUSH
// skirmish := false ;
23024: LD_ADDR_EXP 78
23028: PUSH
23029: LD_INT 0
23031: ST_TO_ADDR
// debug_mc := false ;
23032: LD_ADDR_EXP 79
23036: PUSH
23037: LD_INT 0
23039: ST_TO_ADDR
// mc_bases := [ ] ;
23040: LD_ADDR_EXP 80
23044: PUSH
23045: EMPTY
23046: ST_TO_ADDR
// mc_sides := [ ] ;
23047: LD_ADDR_EXP 106
23051: PUSH
23052: EMPTY
23053: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
23054: LD_ADDR_EXP 81
23058: PUSH
23059: EMPTY
23060: ST_TO_ADDR
// mc_building_repairs := [ ] ;
23061: LD_ADDR_EXP 82
23065: PUSH
23066: EMPTY
23067: ST_TO_ADDR
// mc_need_heal := [ ] ;
23068: LD_ADDR_EXP 83
23072: PUSH
23073: EMPTY
23074: ST_TO_ADDR
// mc_healers := [ ] ;
23075: LD_ADDR_EXP 84
23079: PUSH
23080: EMPTY
23081: ST_TO_ADDR
// mc_build_list := [ ] ;
23082: LD_ADDR_EXP 85
23086: PUSH
23087: EMPTY
23088: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
23089: LD_ADDR_EXP 112
23093: PUSH
23094: EMPTY
23095: ST_TO_ADDR
// mc_builders := [ ] ;
23096: LD_ADDR_EXP 86
23100: PUSH
23101: EMPTY
23102: ST_TO_ADDR
// mc_construct_list := [ ] ;
23103: LD_ADDR_EXP 87
23107: PUSH
23108: EMPTY
23109: ST_TO_ADDR
// mc_turret_list := [ ] ;
23110: LD_ADDR_EXP 88
23114: PUSH
23115: EMPTY
23116: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
23117: LD_ADDR_EXP 89
23121: PUSH
23122: EMPTY
23123: ST_TO_ADDR
// mc_miners := [ ] ;
23124: LD_ADDR_EXP 94
23128: PUSH
23129: EMPTY
23130: ST_TO_ADDR
// mc_mines := [ ] ;
23131: LD_ADDR_EXP 93
23135: PUSH
23136: EMPTY
23137: ST_TO_ADDR
// mc_minefields := [ ] ;
23138: LD_ADDR_EXP 95
23142: PUSH
23143: EMPTY
23144: ST_TO_ADDR
// mc_crates := [ ] ;
23145: LD_ADDR_EXP 96
23149: PUSH
23150: EMPTY
23151: ST_TO_ADDR
// mc_crates_collector := [ ] ;
23152: LD_ADDR_EXP 97
23156: PUSH
23157: EMPTY
23158: ST_TO_ADDR
// mc_crates_area := [ ] ;
23159: LD_ADDR_EXP 98
23163: PUSH
23164: EMPTY
23165: ST_TO_ADDR
// mc_vehicles := [ ] ;
23166: LD_ADDR_EXP 99
23170: PUSH
23171: EMPTY
23172: ST_TO_ADDR
// mc_attack := [ ] ;
23173: LD_ADDR_EXP 100
23177: PUSH
23178: EMPTY
23179: ST_TO_ADDR
// mc_produce := [ ] ;
23180: LD_ADDR_EXP 101
23184: PUSH
23185: EMPTY
23186: ST_TO_ADDR
// mc_defender := [ ] ;
23187: LD_ADDR_EXP 102
23191: PUSH
23192: EMPTY
23193: ST_TO_ADDR
// mc_parking := [ ] ;
23194: LD_ADDR_EXP 104
23198: PUSH
23199: EMPTY
23200: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
23201: LD_ADDR_EXP 90
23205: PUSH
23206: EMPTY
23207: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
23208: LD_ADDR_EXP 92
23212: PUSH
23213: EMPTY
23214: ST_TO_ADDR
// mc_scan := [ ] ;
23215: LD_ADDR_EXP 103
23219: PUSH
23220: EMPTY
23221: ST_TO_ADDR
// mc_scan_area := [ ] ;
23222: LD_ADDR_EXP 105
23226: PUSH
23227: EMPTY
23228: ST_TO_ADDR
// mc_tech := [ ] ;
23229: LD_ADDR_EXP 107
23233: PUSH
23234: EMPTY
23235: ST_TO_ADDR
// mc_class := [ ] ;
23236: LD_ADDR_EXP 121
23240: PUSH
23241: EMPTY
23242: ST_TO_ADDR
// mc_class_case_use := [ ] ;
23243: LD_ADDR_EXP 122
23247: PUSH
23248: EMPTY
23249: ST_TO_ADDR
// mc_is_defending := [ ] ;
23250: LD_ADDR_EXP 123
23254: PUSH
23255: EMPTY
23256: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
23257: LD_ADDR_EXP 114
23261: PUSH
23262: EMPTY
23263: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
23264: LD_ADDR_EXP 124
23268: PUSH
23269: LD_INT 0
23271: ST_TO_ADDR
// end ;
23272: LD_VAR 0 1
23276: RET
// export function MC_Kill ( base ) ; begin
23277: LD_INT 0
23279: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
23280: LD_ADDR_EXP 80
23284: PUSH
23285: LD_EXP 80
23289: PPUSH
23290: LD_VAR 0 1
23294: PPUSH
23295: EMPTY
23296: PPUSH
23297: CALL_OW 1
23301: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23302: LD_ADDR_EXP 81
23306: PUSH
23307: LD_EXP 81
23311: PPUSH
23312: LD_VAR 0 1
23316: PPUSH
23317: EMPTY
23318: PPUSH
23319: CALL_OW 1
23323: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23324: LD_ADDR_EXP 82
23328: PUSH
23329: LD_EXP 82
23333: PPUSH
23334: LD_VAR 0 1
23338: PPUSH
23339: EMPTY
23340: PPUSH
23341: CALL_OW 1
23345: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23346: LD_ADDR_EXP 83
23350: PUSH
23351: LD_EXP 83
23355: PPUSH
23356: LD_VAR 0 1
23360: PPUSH
23361: EMPTY
23362: PPUSH
23363: CALL_OW 1
23367: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23368: LD_ADDR_EXP 84
23372: PUSH
23373: LD_EXP 84
23377: PPUSH
23378: LD_VAR 0 1
23382: PPUSH
23383: EMPTY
23384: PPUSH
23385: CALL_OW 1
23389: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23390: LD_ADDR_EXP 85
23394: PUSH
23395: LD_EXP 85
23399: PPUSH
23400: LD_VAR 0 1
23404: PPUSH
23405: EMPTY
23406: PPUSH
23407: CALL_OW 1
23411: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23412: LD_ADDR_EXP 86
23416: PUSH
23417: LD_EXP 86
23421: PPUSH
23422: LD_VAR 0 1
23426: PPUSH
23427: EMPTY
23428: PPUSH
23429: CALL_OW 1
23433: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23434: LD_ADDR_EXP 87
23438: PUSH
23439: LD_EXP 87
23443: PPUSH
23444: LD_VAR 0 1
23448: PPUSH
23449: EMPTY
23450: PPUSH
23451: CALL_OW 1
23455: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23456: LD_ADDR_EXP 88
23460: PUSH
23461: LD_EXP 88
23465: PPUSH
23466: LD_VAR 0 1
23470: PPUSH
23471: EMPTY
23472: PPUSH
23473: CALL_OW 1
23477: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23478: LD_ADDR_EXP 89
23482: PUSH
23483: LD_EXP 89
23487: PPUSH
23488: LD_VAR 0 1
23492: PPUSH
23493: EMPTY
23494: PPUSH
23495: CALL_OW 1
23499: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23500: LD_ADDR_EXP 90
23504: PUSH
23505: LD_EXP 90
23509: PPUSH
23510: LD_VAR 0 1
23514: PPUSH
23515: EMPTY
23516: PPUSH
23517: CALL_OW 1
23521: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23522: LD_ADDR_EXP 91
23526: PUSH
23527: LD_EXP 91
23531: PPUSH
23532: LD_VAR 0 1
23536: PPUSH
23537: LD_INT 0
23539: PPUSH
23540: CALL_OW 1
23544: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23545: LD_ADDR_EXP 92
23549: PUSH
23550: LD_EXP 92
23554: PPUSH
23555: LD_VAR 0 1
23559: PPUSH
23560: EMPTY
23561: PPUSH
23562: CALL_OW 1
23566: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23567: LD_ADDR_EXP 93
23571: PUSH
23572: LD_EXP 93
23576: PPUSH
23577: LD_VAR 0 1
23581: PPUSH
23582: EMPTY
23583: PPUSH
23584: CALL_OW 1
23588: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23589: LD_ADDR_EXP 94
23593: PUSH
23594: LD_EXP 94
23598: PPUSH
23599: LD_VAR 0 1
23603: PPUSH
23604: EMPTY
23605: PPUSH
23606: CALL_OW 1
23610: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23611: LD_ADDR_EXP 95
23615: PUSH
23616: LD_EXP 95
23620: PPUSH
23621: LD_VAR 0 1
23625: PPUSH
23626: EMPTY
23627: PPUSH
23628: CALL_OW 1
23632: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23633: LD_ADDR_EXP 96
23637: PUSH
23638: LD_EXP 96
23642: PPUSH
23643: LD_VAR 0 1
23647: PPUSH
23648: EMPTY
23649: PPUSH
23650: CALL_OW 1
23654: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23655: LD_ADDR_EXP 97
23659: PUSH
23660: LD_EXP 97
23664: PPUSH
23665: LD_VAR 0 1
23669: PPUSH
23670: EMPTY
23671: PPUSH
23672: CALL_OW 1
23676: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23677: LD_ADDR_EXP 98
23681: PUSH
23682: LD_EXP 98
23686: PPUSH
23687: LD_VAR 0 1
23691: PPUSH
23692: EMPTY
23693: PPUSH
23694: CALL_OW 1
23698: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23699: LD_ADDR_EXP 99
23703: PUSH
23704: LD_EXP 99
23708: PPUSH
23709: LD_VAR 0 1
23713: PPUSH
23714: EMPTY
23715: PPUSH
23716: CALL_OW 1
23720: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23721: LD_ADDR_EXP 100
23725: PUSH
23726: LD_EXP 100
23730: PPUSH
23731: LD_VAR 0 1
23735: PPUSH
23736: EMPTY
23737: PPUSH
23738: CALL_OW 1
23742: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23743: LD_ADDR_EXP 101
23747: PUSH
23748: LD_EXP 101
23752: PPUSH
23753: LD_VAR 0 1
23757: PPUSH
23758: EMPTY
23759: PPUSH
23760: CALL_OW 1
23764: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23765: LD_ADDR_EXP 102
23769: PUSH
23770: LD_EXP 102
23774: PPUSH
23775: LD_VAR 0 1
23779: PPUSH
23780: EMPTY
23781: PPUSH
23782: CALL_OW 1
23786: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23787: LD_ADDR_EXP 103
23791: PUSH
23792: LD_EXP 103
23796: PPUSH
23797: LD_VAR 0 1
23801: PPUSH
23802: EMPTY
23803: PPUSH
23804: CALL_OW 1
23808: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23809: LD_ADDR_EXP 104
23813: PUSH
23814: LD_EXP 104
23818: PPUSH
23819: LD_VAR 0 1
23823: PPUSH
23824: EMPTY
23825: PPUSH
23826: CALL_OW 1
23830: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23831: LD_ADDR_EXP 105
23835: PUSH
23836: LD_EXP 105
23840: PPUSH
23841: LD_VAR 0 1
23845: PPUSH
23846: EMPTY
23847: PPUSH
23848: CALL_OW 1
23852: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23853: LD_ADDR_EXP 107
23857: PUSH
23858: LD_EXP 107
23862: PPUSH
23863: LD_VAR 0 1
23867: PPUSH
23868: EMPTY
23869: PPUSH
23870: CALL_OW 1
23874: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23875: LD_ADDR_EXP 109
23879: PUSH
23880: LD_EXP 109
23884: PPUSH
23885: LD_VAR 0 1
23889: PPUSH
23890: EMPTY
23891: PPUSH
23892: CALL_OW 1
23896: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23897: LD_ADDR_EXP 110
23901: PUSH
23902: LD_EXP 110
23906: PPUSH
23907: LD_VAR 0 1
23911: PPUSH
23912: EMPTY
23913: PPUSH
23914: CALL_OW 1
23918: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23919: LD_ADDR_EXP 111
23923: PUSH
23924: LD_EXP 111
23928: PPUSH
23929: LD_VAR 0 1
23933: PPUSH
23934: EMPTY
23935: PPUSH
23936: CALL_OW 1
23940: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23941: LD_ADDR_EXP 112
23945: PUSH
23946: LD_EXP 112
23950: PPUSH
23951: LD_VAR 0 1
23955: PPUSH
23956: EMPTY
23957: PPUSH
23958: CALL_OW 1
23962: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23963: LD_ADDR_EXP 113
23967: PUSH
23968: LD_EXP 113
23972: PPUSH
23973: LD_VAR 0 1
23977: PPUSH
23978: EMPTY
23979: PPUSH
23980: CALL_OW 1
23984: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23985: LD_ADDR_EXP 114
23989: PUSH
23990: LD_EXP 114
23994: PPUSH
23995: LD_VAR 0 1
23999: PPUSH
24000: EMPTY
24001: PPUSH
24002: CALL_OW 1
24006: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24007: LD_ADDR_EXP 115
24011: PUSH
24012: LD_EXP 115
24016: PPUSH
24017: LD_VAR 0 1
24021: PPUSH
24022: EMPTY
24023: PPUSH
24024: CALL_OW 1
24028: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24029: LD_ADDR_EXP 116
24033: PUSH
24034: LD_EXP 116
24038: PPUSH
24039: LD_VAR 0 1
24043: PPUSH
24044: EMPTY
24045: PPUSH
24046: CALL_OW 1
24050: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24051: LD_ADDR_EXP 117
24055: PUSH
24056: LD_EXP 117
24060: PPUSH
24061: LD_VAR 0 1
24065: PPUSH
24066: EMPTY
24067: PPUSH
24068: CALL_OW 1
24072: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24073: LD_ADDR_EXP 118
24077: PUSH
24078: LD_EXP 118
24082: PPUSH
24083: LD_VAR 0 1
24087: PPUSH
24088: EMPTY
24089: PPUSH
24090: CALL_OW 1
24094: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24095: LD_ADDR_EXP 119
24099: PUSH
24100: LD_EXP 119
24104: PPUSH
24105: LD_VAR 0 1
24109: PPUSH
24110: EMPTY
24111: PPUSH
24112: CALL_OW 1
24116: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24117: LD_ADDR_EXP 120
24121: PUSH
24122: LD_EXP 120
24126: PPUSH
24127: LD_VAR 0 1
24131: PPUSH
24132: EMPTY
24133: PPUSH
24134: CALL_OW 1
24138: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24139: LD_ADDR_EXP 121
24143: PUSH
24144: LD_EXP 121
24148: PPUSH
24149: LD_VAR 0 1
24153: PPUSH
24154: EMPTY
24155: PPUSH
24156: CALL_OW 1
24160: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24161: LD_ADDR_EXP 122
24165: PUSH
24166: LD_EXP 122
24170: PPUSH
24171: LD_VAR 0 1
24175: PPUSH
24176: LD_INT 0
24178: PPUSH
24179: CALL_OW 1
24183: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24184: LD_ADDR_EXP 123
24188: PUSH
24189: LD_EXP 123
24193: PPUSH
24194: LD_VAR 0 1
24198: PPUSH
24199: LD_INT 0
24201: PPUSH
24202: CALL_OW 1
24206: ST_TO_ADDR
// end ;
24207: LD_VAR 0 2
24211: RET
// export function MC_Add ( side , units ) ; var base ; begin
24212: LD_INT 0
24214: PPUSH
24215: PPUSH
// base := mc_bases + 1 ;
24216: LD_ADDR_VAR 0 4
24220: PUSH
24221: LD_EXP 80
24225: PUSH
24226: LD_INT 1
24228: PLUS
24229: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
24230: LD_ADDR_EXP 106
24234: PUSH
24235: LD_EXP 106
24239: PPUSH
24240: LD_VAR 0 4
24244: PPUSH
24245: LD_VAR 0 1
24249: PPUSH
24250: CALL_OW 1
24254: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
24255: LD_ADDR_EXP 80
24259: PUSH
24260: LD_EXP 80
24264: PPUSH
24265: LD_VAR 0 4
24269: PPUSH
24270: LD_VAR 0 2
24274: PPUSH
24275: CALL_OW 1
24279: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
24280: LD_ADDR_EXP 81
24284: PUSH
24285: LD_EXP 81
24289: PPUSH
24290: LD_VAR 0 4
24294: PPUSH
24295: EMPTY
24296: PPUSH
24297: CALL_OW 1
24301: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
24302: LD_ADDR_EXP 82
24306: PUSH
24307: LD_EXP 82
24311: PPUSH
24312: LD_VAR 0 4
24316: PPUSH
24317: EMPTY
24318: PPUSH
24319: CALL_OW 1
24323: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
24324: LD_ADDR_EXP 83
24328: PUSH
24329: LD_EXP 83
24333: PPUSH
24334: LD_VAR 0 4
24338: PPUSH
24339: EMPTY
24340: PPUSH
24341: CALL_OW 1
24345: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
24346: LD_ADDR_EXP 84
24350: PUSH
24351: LD_EXP 84
24355: PPUSH
24356: LD_VAR 0 4
24360: PPUSH
24361: EMPTY
24362: PPUSH
24363: CALL_OW 1
24367: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
24368: LD_ADDR_EXP 85
24372: PUSH
24373: LD_EXP 85
24377: PPUSH
24378: LD_VAR 0 4
24382: PPUSH
24383: EMPTY
24384: PPUSH
24385: CALL_OW 1
24389: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
24390: LD_ADDR_EXP 86
24394: PUSH
24395: LD_EXP 86
24399: PPUSH
24400: LD_VAR 0 4
24404: PPUSH
24405: EMPTY
24406: PPUSH
24407: CALL_OW 1
24411: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
24412: LD_ADDR_EXP 87
24416: PUSH
24417: LD_EXP 87
24421: PPUSH
24422: LD_VAR 0 4
24426: PPUSH
24427: EMPTY
24428: PPUSH
24429: CALL_OW 1
24433: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
24434: LD_ADDR_EXP 88
24438: PUSH
24439: LD_EXP 88
24443: PPUSH
24444: LD_VAR 0 4
24448: PPUSH
24449: EMPTY
24450: PPUSH
24451: CALL_OW 1
24455: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
24456: LD_ADDR_EXP 89
24460: PUSH
24461: LD_EXP 89
24465: PPUSH
24466: LD_VAR 0 4
24470: PPUSH
24471: EMPTY
24472: PPUSH
24473: CALL_OW 1
24477: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
24478: LD_ADDR_EXP 90
24482: PUSH
24483: LD_EXP 90
24487: PPUSH
24488: LD_VAR 0 4
24492: PPUSH
24493: EMPTY
24494: PPUSH
24495: CALL_OW 1
24499: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
24500: LD_ADDR_EXP 91
24504: PUSH
24505: LD_EXP 91
24509: PPUSH
24510: LD_VAR 0 4
24514: PPUSH
24515: LD_INT 0
24517: PPUSH
24518: CALL_OW 1
24522: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
24523: LD_ADDR_EXP 92
24527: PUSH
24528: LD_EXP 92
24532: PPUSH
24533: LD_VAR 0 4
24537: PPUSH
24538: EMPTY
24539: PPUSH
24540: CALL_OW 1
24544: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
24545: LD_ADDR_EXP 93
24549: PUSH
24550: LD_EXP 93
24554: PPUSH
24555: LD_VAR 0 4
24559: PPUSH
24560: EMPTY
24561: PPUSH
24562: CALL_OW 1
24566: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
24567: LD_ADDR_EXP 94
24571: PUSH
24572: LD_EXP 94
24576: PPUSH
24577: LD_VAR 0 4
24581: PPUSH
24582: EMPTY
24583: PPUSH
24584: CALL_OW 1
24588: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
24589: LD_ADDR_EXP 95
24593: PUSH
24594: LD_EXP 95
24598: PPUSH
24599: LD_VAR 0 4
24603: PPUSH
24604: EMPTY
24605: PPUSH
24606: CALL_OW 1
24610: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
24611: LD_ADDR_EXP 96
24615: PUSH
24616: LD_EXP 96
24620: PPUSH
24621: LD_VAR 0 4
24625: PPUSH
24626: EMPTY
24627: PPUSH
24628: CALL_OW 1
24632: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
24633: LD_ADDR_EXP 97
24637: PUSH
24638: LD_EXP 97
24642: PPUSH
24643: LD_VAR 0 4
24647: PPUSH
24648: EMPTY
24649: PPUSH
24650: CALL_OW 1
24654: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
24655: LD_ADDR_EXP 98
24659: PUSH
24660: LD_EXP 98
24664: PPUSH
24665: LD_VAR 0 4
24669: PPUSH
24670: EMPTY
24671: PPUSH
24672: CALL_OW 1
24676: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
24677: LD_ADDR_EXP 99
24681: PUSH
24682: LD_EXP 99
24686: PPUSH
24687: LD_VAR 0 4
24691: PPUSH
24692: EMPTY
24693: PPUSH
24694: CALL_OW 1
24698: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
24699: LD_ADDR_EXP 100
24703: PUSH
24704: LD_EXP 100
24708: PPUSH
24709: LD_VAR 0 4
24713: PPUSH
24714: EMPTY
24715: PPUSH
24716: CALL_OW 1
24720: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
24721: LD_ADDR_EXP 101
24725: PUSH
24726: LD_EXP 101
24730: PPUSH
24731: LD_VAR 0 4
24735: PPUSH
24736: EMPTY
24737: PPUSH
24738: CALL_OW 1
24742: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
24743: LD_ADDR_EXP 102
24747: PUSH
24748: LD_EXP 102
24752: PPUSH
24753: LD_VAR 0 4
24757: PPUSH
24758: EMPTY
24759: PPUSH
24760: CALL_OW 1
24764: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
24765: LD_ADDR_EXP 103
24769: PUSH
24770: LD_EXP 103
24774: PPUSH
24775: LD_VAR 0 4
24779: PPUSH
24780: EMPTY
24781: PPUSH
24782: CALL_OW 1
24786: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
24787: LD_ADDR_EXP 104
24791: PUSH
24792: LD_EXP 104
24796: PPUSH
24797: LD_VAR 0 4
24801: PPUSH
24802: EMPTY
24803: PPUSH
24804: CALL_OW 1
24808: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
24809: LD_ADDR_EXP 105
24813: PUSH
24814: LD_EXP 105
24818: PPUSH
24819: LD_VAR 0 4
24823: PPUSH
24824: EMPTY
24825: PPUSH
24826: CALL_OW 1
24830: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
24831: LD_ADDR_EXP 107
24835: PUSH
24836: LD_EXP 107
24840: PPUSH
24841: LD_VAR 0 4
24845: PPUSH
24846: EMPTY
24847: PPUSH
24848: CALL_OW 1
24852: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
24853: LD_ADDR_EXP 109
24857: PUSH
24858: LD_EXP 109
24862: PPUSH
24863: LD_VAR 0 4
24867: PPUSH
24868: EMPTY
24869: PPUSH
24870: CALL_OW 1
24874: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24875: LD_ADDR_EXP 110
24879: PUSH
24880: LD_EXP 110
24884: PPUSH
24885: LD_VAR 0 4
24889: PPUSH
24890: EMPTY
24891: PPUSH
24892: CALL_OW 1
24896: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24897: LD_ADDR_EXP 111
24901: PUSH
24902: LD_EXP 111
24906: PPUSH
24907: LD_VAR 0 4
24911: PPUSH
24912: EMPTY
24913: PPUSH
24914: CALL_OW 1
24918: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24919: LD_ADDR_EXP 112
24923: PUSH
24924: LD_EXP 112
24928: PPUSH
24929: LD_VAR 0 4
24933: PPUSH
24934: EMPTY
24935: PPUSH
24936: CALL_OW 1
24940: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24941: LD_ADDR_EXP 113
24945: PUSH
24946: LD_EXP 113
24950: PPUSH
24951: LD_VAR 0 4
24955: PPUSH
24956: EMPTY
24957: PPUSH
24958: CALL_OW 1
24962: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24963: LD_ADDR_EXP 114
24967: PUSH
24968: LD_EXP 114
24972: PPUSH
24973: LD_VAR 0 4
24977: PPUSH
24978: EMPTY
24979: PPUSH
24980: CALL_OW 1
24984: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24985: LD_ADDR_EXP 115
24989: PUSH
24990: LD_EXP 115
24994: PPUSH
24995: LD_VAR 0 4
24999: PPUSH
25000: EMPTY
25001: PPUSH
25002: CALL_OW 1
25006: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
25007: LD_ADDR_EXP 116
25011: PUSH
25012: LD_EXP 116
25016: PPUSH
25017: LD_VAR 0 4
25021: PPUSH
25022: EMPTY
25023: PPUSH
25024: CALL_OW 1
25028: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
25029: LD_ADDR_EXP 117
25033: PUSH
25034: LD_EXP 117
25038: PPUSH
25039: LD_VAR 0 4
25043: PPUSH
25044: EMPTY
25045: PPUSH
25046: CALL_OW 1
25050: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
25051: LD_ADDR_EXP 118
25055: PUSH
25056: LD_EXP 118
25060: PPUSH
25061: LD_VAR 0 4
25065: PPUSH
25066: EMPTY
25067: PPUSH
25068: CALL_OW 1
25072: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
25073: LD_ADDR_EXP 119
25077: PUSH
25078: LD_EXP 119
25082: PPUSH
25083: LD_VAR 0 4
25087: PPUSH
25088: EMPTY
25089: PPUSH
25090: CALL_OW 1
25094: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
25095: LD_ADDR_EXP 120
25099: PUSH
25100: LD_EXP 120
25104: PPUSH
25105: LD_VAR 0 4
25109: PPUSH
25110: EMPTY
25111: PPUSH
25112: CALL_OW 1
25116: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
25117: LD_ADDR_EXP 121
25121: PUSH
25122: LD_EXP 121
25126: PPUSH
25127: LD_VAR 0 4
25131: PPUSH
25132: EMPTY
25133: PPUSH
25134: CALL_OW 1
25138: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
25139: LD_ADDR_EXP 122
25143: PUSH
25144: LD_EXP 122
25148: PPUSH
25149: LD_VAR 0 4
25153: PPUSH
25154: LD_INT 0
25156: PPUSH
25157: CALL_OW 1
25161: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
25162: LD_ADDR_EXP 123
25166: PUSH
25167: LD_EXP 123
25171: PPUSH
25172: LD_VAR 0 4
25176: PPUSH
25177: LD_INT 0
25179: PPUSH
25180: CALL_OW 1
25184: ST_TO_ADDR
// result := base ;
25185: LD_ADDR_VAR 0 3
25189: PUSH
25190: LD_VAR 0 4
25194: ST_TO_ADDR
// end ;
25195: LD_VAR 0 3
25199: RET
// export function MC_Start ( ) ; var i ; begin
25200: LD_INT 0
25202: PPUSH
25203: PPUSH
// for i = 1 to mc_bases do
25204: LD_ADDR_VAR 0 2
25208: PUSH
25209: DOUBLE
25210: LD_INT 1
25212: DEC
25213: ST_TO_ADDR
25214: LD_EXP 80
25218: PUSH
25219: FOR_TO
25220: IFFALSE 26320
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
25222: LD_ADDR_EXP 80
25226: PUSH
25227: LD_EXP 80
25231: PPUSH
25232: LD_VAR 0 2
25236: PPUSH
25237: LD_EXP 80
25241: PUSH
25242: LD_VAR 0 2
25246: ARRAY
25247: PUSH
25248: LD_INT 0
25250: DIFF
25251: PPUSH
25252: CALL_OW 1
25256: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
25257: LD_ADDR_EXP 81
25261: PUSH
25262: LD_EXP 81
25266: PPUSH
25267: LD_VAR 0 2
25271: PPUSH
25272: EMPTY
25273: PPUSH
25274: CALL_OW 1
25278: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
25279: LD_ADDR_EXP 82
25283: PUSH
25284: LD_EXP 82
25288: PPUSH
25289: LD_VAR 0 2
25293: PPUSH
25294: EMPTY
25295: PPUSH
25296: CALL_OW 1
25300: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
25301: LD_ADDR_EXP 83
25305: PUSH
25306: LD_EXP 83
25310: PPUSH
25311: LD_VAR 0 2
25315: PPUSH
25316: EMPTY
25317: PPUSH
25318: CALL_OW 1
25322: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
25323: LD_ADDR_EXP 84
25327: PUSH
25328: LD_EXP 84
25332: PPUSH
25333: LD_VAR 0 2
25337: PPUSH
25338: EMPTY
25339: PUSH
25340: EMPTY
25341: PUSH
25342: EMPTY
25343: LIST
25344: LIST
25345: PPUSH
25346: CALL_OW 1
25350: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
25351: LD_ADDR_EXP 85
25355: PUSH
25356: LD_EXP 85
25360: PPUSH
25361: LD_VAR 0 2
25365: PPUSH
25366: EMPTY
25367: PPUSH
25368: CALL_OW 1
25372: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
25373: LD_ADDR_EXP 112
25377: PUSH
25378: LD_EXP 112
25382: PPUSH
25383: LD_VAR 0 2
25387: PPUSH
25388: EMPTY
25389: PPUSH
25390: CALL_OW 1
25394: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
25395: LD_ADDR_EXP 86
25399: PUSH
25400: LD_EXP 86
25404: PPUSH
25405: LD_VAR 0 2
25409: PPUSH
25410: EMPTY
25411: PPUSH
25412: CALL_OW 1
25416: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
25417: LD_ADDR_EXP 87
25421: PUSH
25422: LD_EXP 87
25426: PPUSH
25427: LD_VAR 0 2
25431: PPUSH
25432: EMPTY
25433: PPUSH
25434: CALL_OW 1
25438: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
25439: LD_ADDR_EXP 88
25443: PUSH
25444: LD_EXP 88
25448: PPUSH
25449: LD_VAR 0 2
25453: PPUSH
25454: LD_EXP 80
25458: PUSH
25459: LD_VAR 0 2
25463: ARRAY
25464: PPUSH
25465: LD_INT 2
25467: PUSH
25468: LD_INT 30
25470: PUSH
25471: LD_INT 32
25473: PUSH
25474: EMPTY
25475: LIST
25476: LIST
25477: PUSH
25478: LD_INT 30
25480: PUSH
25481: LD_INT 33
25483: PUSH
25484: EMPTY
25485: LIST
25486: LIST
25487: PUSH
25488: EMPTY
25489: LIST
25490: LIST
25491: LIST
25492: PPUSH
25493: CALL_OW 72
25497: PPUSH
25498: CALL_OW 1
25502: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
25503: LD_ADDR_EXP 89
25507: PUSH
25508: LD_EXP 89
25512: PPUSH
25513: LD_VAR 0 2
25517: PPUSH
25518: LD_EXP 80
25522: PUSH
25523: LD_VAR 0 2
25527: ARRAY
25528: PPUSH
25529: LD_INT 2
25531: PUSH
25532: LD_INT 30
25534: PUSH
25535: LD_INT 32
25537: PUSH
25538: EMPTY
25539: LIST
25540: LIST
25541: PUSH
25542: LD_INT 30
25544: PUSH
25545: LD_INT 31
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: LIST
25556: PUSH
25557: LD_INT 58
25559: PUSH
25560: EMPTY
25561: LIST
25562: PUSH
25563: EMPTY
25564: LIST
25565: LIST
25566: PPUSH
25567: CALL_OW 72
25571: PPUSH
25572: CALL_OW 1
25576: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
25577: LD_ADDR_EXP 90
25581: PUSH
25582: LD_EXP 90
25586: PPUSH
25587: LD_VAR 0 2
25591: PPUSH
25592: EMPTY
25593: PPUSH
25594: CALL_OW 1
25598: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
25599: LD_ADDR_EXP 94
25603: PUSH
25604: LD_EXP 94
25608: PPUSH
25609: LD_VAR 0 2
25613: PPUSH
25614: EMPTY
25615: PPUSH
25616: CALL_OW 1
25620: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
25621: LD_ADDR_EXP 93
25625: PUSH
25626: LD_EXP 93
25630: PPUSH
25631: LD_VAR 0 2
25635: PPUSH
25636: EMPTY
25637: PPUSH
25638: CALL_OW 1
25642: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
25643: LD_ADDR_EXP 95
25647: PUSH
25648: LD_EXP 95
25652: PPUSH
25653: LD_VAR 0 2
25657: PPUSH
25658: EMPTY
25659: PPUSH
25660: CALL_OW 1
25664: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
25665: LD_ADDR_EXP 96
25669: PUSH
25670: LD_EXP 96
25674: PPUSH
25675: LD_VAR 0 2
25679: PPUSH
25680: EMPTY
25681: PPUSH
25682: CALL_OW 1
25686: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
25687: LD_ADDR_EXP 97
25691: PUSH
25692: LD_EXP 97
25696: PPUSH
25697: LD_VAR 0 2
25701: PPUSH
25702: EMPTY
25703: PPUSH
25704: CALL_OW 1
25708: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
25709: LD_ADDR_EXP 98
25713: PUSH
25714: LD_EXP 98
25718: PPUSH
25719: LD_VAR 0 2
25723: PPUSH
25724: EMPTY
25725: PPUSH
25726: CALL_OW 1
25730: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
25731: LD_ADDR_EXP 99
25735: PUSH
25736: LD_EXP 99
25740: PPUSH
25741: LD_VAR 0 2
25745: PPUSH
25746: EMPTY
25747: PPUSH
25748: CALL_OW 1
25752: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
25753: LD_ADDR_EXP 100
25757: PUSH
25758: LD_EXP 100
25762: PPUSH
25763: LD_VAR 0 2
25767: PPUSH
25768: EMPTY
25769: PPUSH
25770: CALL_OW 1
25774: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
25775: LD_ADDR_EXP 101
25779: PUSH
25780: LD_EXP 101
25784: PPUSH
25785: LD_VAR 0 2
25789: PPUSH
25790: EMPTY
25791: PPUSH
25792: CALL_OW 1
25796: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
25797: LD_ADDR_EXP 102
25801: PUSH
25802: LD_EXP 102
25806: PPUSH
25807: LD_VAR 0 2
25811: PPUSH
25812: EMPTY
25813: PPUSH
25814: CALL_OW 1
25818: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
25819: LD_ADDR_EXP 91
25823: PUSH
25824: LD_EXP 91
25828: PPUSH
25829: LD_VAR 0 2
25833: PPUSH
25834: LD_INT 0
25836: PPUSH
25837: CALL_OW 1
25841: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
25842: LD_ADDR_EXP 104
25846: PUSH
25847: LD_EXP 104
25851: PPUSH
25852: LD_VAR 0 2
25856: PPUSH
25857: LD_INT 0
25859: PPUSH
25860: CALL_OW 1
25864: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
25865: LD_ADDR_EXP 92
25869: PUSH
25870: LD_EXP 92
25874: PPUSH
25875: LD_VAR 0 2
25879: PPUSH
25880: EMPTY
25881: PPUSH
25882: CALL_OW 1
25886: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
25887: LD_ADDR_EXP 103
25891: PUSH
25892: LD_EXP 103
25896: PPUSH
25897: LD_VAR 0 2
25901: PPUSH
25902: LD_INT 0
25904: PPUSH
25905: CALL_OW 1
25909: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
25910: LD_ADDR_EXP 105
25914: PUSH
25915: LD_EXP 105
25919: PPUSH
25920: LD_VAR 0 2
25924: PPUSH
25925: EMPTY
25926: PPUSH
25927: CALL_OW 1
25931: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
25932: LD_ADDR_EXP 108
25936: PUSH
25937: LD_EXP 108
25941: PPUSH
25942: LD_VAR 0 2
25946: PPUSH
25947: LD_INT 0
25949: PPUSH
25950: CALL_OW 1
25954: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
25955: LD_ADDR_EXP 109
25959: PUSH
25960: LD_EXP 109
25964: PPUSH
25965: LD_VAR 0 2
25969: PPUSH
25970: EMPTY
25971: PPUSH
25972: CALL_OW 1
25976: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25977: LD_ADDR_EXP 110
25981: PUSH
25982: LD_EXP 110
25986: PPUSH
25987: LD_VAR 0 2
25991: PPUSH
25992: EMPTY
25993: PPUSH
25994: CALL_OW 1
25998: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25999: LD_ADDR_EXP 111
26003: PUSH
26004: LD_EXP 111
26008: PPUSH
26009: LD_VAR 0 2
26013: PPUSH
26014: EMPTY
26015: PPUSH
26016: CALL_OW 1
26020: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
26021: LD_ADDR_EXP 113
26025: PUSH
26026: LD_EXP 113
26030: PPUSH
26031: LD_VAR 0 2
26035: PPUSH
26036: LD_EXP 80
26040: PUSH
26041: LD_VAR 0 2
26045: ARRAY
26046: PPUSH
26047: LD_INT 2
26049: PUSH
26050: LD_INT 30
26052: PUSH
26053: LD_INT 6
26055: PUSH
26056: EMPTY
26057: LIST
26058: LIST
26059: PUSH
26060: LD_INT 30
26062: PUSH
26063: LD_INT 7
26065: PUSH
26066: EMPTY
26067: LIST
26068: LIST
26069: PUSH
26070: LD_INT 30
26072: PUSH
26073: LD_INT 8
26075: PUSH
26076: EMPTY
26077: LIST
26078: LIST
26079: PUSH
26080: EMPTY
26081: LIST
26082: LIST
26083: LIST
26084: LIST
26085: PPUSH
26086: CALL_OW 72
26090: PPUSH
26091: CALL_OW 1
26095: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
26096: LD_ADDR_EXP 114
26100: PUSH
26101: LD_EXP 114
26105: PPUSH
26106: LD_VAR 0 2
26110: PPUSH
26111: EMPTY
26112: PPUSH
26113: CALL_OW 1
26117: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
26118: LD_ADDR_EXP 115
26122: PUSH
26123: LD_EXP 115
26127: PPUSH
26128: LD_VAR 0 2
26132: PPUSH
26133: EMPTY
26134: PPUSH
26135: CALL_OW 1
26139: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
26140: LD_ADDR_EXP 116
26144: PUSH
26145: LD_EXP 116
26149: PPUSH
26150: LD_VAR 0 2
26154: PPUSH
26155: EMPTY
26156: PPUSH
26157: CALL_OW 1
26161: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
26162: LD_ADDR_EXP 117
26166: PUSH
26167: LD_EXP 117
26171: PPUSH
26172: LD_VAR 0 2
26176: PPUSH
26177: EMPTY
26178: PPUSH
26179: CALL_OW 1
26183: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
26184: LD_ADDR_EXP 118
26188: PUSH
26189: LD_EXP 118
26193: PPUSH
26194: LD_VAR 0 2
26198: PPUSH
26199: EMPTY
26200: PPUSH
26201: CALL_OW 1
26205: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
26206: LD_ADDR_EXP 119
26210: PUSH
26211: LD_EXP 119
26215: PPUSH
26216: LD_VAR 0 2
26220: PPUSH
26221: EMPTY
26222: PPUSH
26223: CALL_OW 1
26227: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
26228: LD_ADDR_EXP 120
26232: PUSH
26233: LD_EXP 120
26237: PPUSH
26238: LD_VAR 0 2
26242: PPUSH
26243: EMPTY
26244: PPUSH
26245: CALL_OW 1
26249: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
26250: LD_ADDR_EXP 121
26254: PUSH
26255: LD_EXP 121
26259: PPUSH
26260: LD_VAR 0 2
26264: PPUSH
26265: EMPTY
26266: PPUSH
26267: CALL_OW 1
26271: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
26272: LD_ADDR_EXP 122
26276: PUSH
26277: LD_EXP 122
26281: PPUSH
26282: LD_VAR 0 2
26286: PPUSH
26287: LD_INT 0
26289: PPUSH
26290: CALL_OW 1
26294: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
26295: LD_ADDR_EXP 123
26299: PUSH
26300: LD_EXP 123
26304: PPUSH
26305: LD_VAR 0 2
26309: PPUSH
26310: LD_INT 0
26312: PPUSH
26313: CALL_OW 1
26317: ST_TO_ADDR
// end ;
26318: GO 25219
26320: POP
26321: POP
// MC_InitSides ( ) ;
26322: CALL 26608 0 0
// MC_InitResearch ( ) ;
26326: CALL 26347 0 0
// CustomInitMacro ( ) ;
26330: CALL 252 0 0
// skirmish := true ;
26334: LD_ADDR_EXP 78
26338: PUSH
26339: LD_INT 1
26341: ST_TO_ADDR
// end ;
26342: LD_VAR 0 1
26346: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
26347: LD_INT 0
26349: PPUSH
26350: PPUSH
26351: PPUSH
26352: PPUSH
26353: PPUSH
26354: PPUSH
// if not mc_bases then
26355: LD_EXP 80
26359: NOT
26360: IFFALSE 26364
// exit ;
26362: GO 26603
// for i = 1 to 8 do
26364: LD_ADDR_VAR 0 2
26368: PUSH
26369: DOUBLE
26370: LD_INT 1
26372: DEC
26373: ST_TO_ADDR
26374: LD_INT 8
26376: PUSH
26377: FOR_TO
26378: IFFALSE 26404
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
26380: LD_ADDR_EXP 107
26384: PUSH
26385: LD_EXP 107
26389: PPUSH
26390: LD_VAR 0 2
26394: PPUSH
26395: EMPTY
26396: PPUSH
26397: CALL_OW 1
26401: ST_TO_ADDR
26402: GO 26377
26404: POP
26405: POP
// tmp := [ ] ;
26406: LD_ADDR_VAR 0 5
26410: PUSH
26411: EMPTY
26412: ST_TO_ADDR
// for i = 1 to mc_sides do
26413: LD_ADDR_VAR 0 2
26417: PUSH
26418: DOUBLE
26419: LD_INT 1
26421: DEC
26422: ST_TO_ADDR
26423: LD_EXP 106
26427: PUSH
26428: FOR_TO
26429: IFFALSE 26487
// if not mc_sides [ i ] in tmp then
26431: LD_EXP 106
26435: PUSH
26436: LD_VAR 0 2
26440: ARRAY
26441: PUSH
26442: LD_VAR 0 5
26446: IN
26447: NOT
26448: IFFALSE 26485
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
26450: LD_ADDR_VAR 0 5
26454: PUSH
26455: LD_VAR 0 5
26459: PPUSH
26460: LD_VAR 0 5
26464: PUSH
26465: LD_INT 1
26467: PLUS
26468: PPUSH
26469: LD_EXP 106
26473: PUSH
26474: LD_VAR 0 2
26478: ARRAY
26479: PPUSH
26480: CALL_OW 2
26484: ST_TO_ADDR
26485: GO 26428
26487: POP
26488: POP
// if not tmp then
26489: LD_VAR 0 5
26493: NOT
26494: IFFALSE 26498
// exit ;
26496: GO 26603
// for j in tmp do
26498: LD_ADDR_VAR 0 3
26502: PUSH
26503: LD_VAR 0 5
26507: PUSH
26508: FOR_IN
26509: IFFALSE 26601
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
26511: LD_ADDR_VAR 0 6
26515: PUSH
26516: LD_INT 22
26518: PUSH
26519: LD_VAR 0 3
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PPUSH
26528: CALL_OW 69
26532: ST_TO_ADDR
// if not un then
26533: LD_VAR 0 6
26537: NOT
26538: IFFALSE 26542
// continue ;
26540: GO 26508
// nation := GetNation ( un [ 1 ] ) ;
26542: LD_ADDR_VAR 0 4
26546: PUSH
26547: LD_VAR 0 6
26551: PUSH
26552: LD_INT 1
26554: ARRAY
26555: PPUSH
26556: CALL_OW 248
26560: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
26561: LD_ADDR_EXP 107
26565: PUSH
26566: LD_EXP 107
26570: PPUSH
26571: LD_VAR 0 3
26575: PPUSH
26576: LD_VAR 0 3
26580: PPUSH
26581: LD_VAR 0 4
26585: PPUSH
26586: LD_INT 1
26588: PPUSH
26589: CALL 53875 0 3
26593: PPUSH
26594: CALL_OW 1
26598: ST_TO_ADDR
// end ;
26599: GO 26508
26601: POP
26602: POP
// end ;
26603: LD_VAR 0 1
26607: RET
// export function MC_InitSides ( ) ; var i ; begin
26608: LD_INT 0
26610: PPUSH
26611: PPUSH
// if not mc_bases then
26612: LD_EXP 80
26616: NOT
26617: IFFALSE 26621
// exit ;
26619: GO 26695
// for i = 1 to mc_bases do
26621: LD_ADDR_VAR 0 2
26625: PUSH
26626: DOUBLE
26627: LD_INT 1
26629: DEC
26630: ST_TO_ADDR
26631: LD_EXP 80
26635: PUSH
26636: FOR_TO
26637: IFFALSE 26693
// if mc_bases [ i ] then
26639: LD_EXP 80
26643: PUSH
26644: LD_VAR 0 2
26648: ARRAY
26649: IFFALSE 26691
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
26651: LD_ADDR_EXP 106
26655: PUSH
26656: LD_EXP 106
26660: PPUSH
26661: LD_VAR 0 2
26665: PPUSH
26666: LD_EXP 80
26670: PUSH
26671: LD_VAR 0 2
26675: ARRAY
26676: PUSH
26677: LD_INT 1
26679: ARRAY
26680: PPUSH
26681: CALL_OW 255
26685: PPUSH
26686: CALL_OW 1
26690: ST_TO_ADDR
26691: GO 26636
26693: POP
26694: POP
// end ;
26695: LD_VAR 0 1
26699: RET
// every 0 0$03 trigger skirmish do
26700: LD_EXP 78
26704: IFFALSE 26858
26706: GO 26708
26708: DISABLE
// begin enable ;
26709: ENABLE
// MC_CheckBuildings ( ) ;
26710: CALL 31370 0 0
// MC_CheckPeopleLife ( ) ;
26714: CALL 31531 0 0
// RaiseSailEvent ( 100 ) ;
26718: LD_INT 100
26720: PPUSH
26721: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
26725: LD_INT 103
26727: PPUSH
26728: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
26732: LD_INT 104
26734: PPUSH
26735: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
26739: LD_INT 105
26741: PPUSH
26742: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
26746: LD_INT 106
26748: PPUSH
26749: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
26753: LD_INT 107
26755: PPUSH
26756: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
26760: LD_INT 108
26762: PPUSH
26763: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
26767: LD_INT 109
26769: PPUSH
26770: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
26774: LD_INT 110
26776: PPUSH
26777: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
26781: LD_INT 111
26783: PPUSH
26784: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
26788: LD_INT 112
26790: PPUSH
26791: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
26795: LD_INT 113
26797: PPUSH
26798: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
26802: LD_INT 120
26804: PPUSH
26805: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
26809: LD_INT 121
26811: PPUSH
26812: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
26816: LD_INT 122
26818: PPUSH
26819: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
26823: LD_INT 123
26825: PPUSH
26826: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
26830: LD_INT 124
26832: PPUSH
26833: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
26837: LD_INT 125
26839: PPUSH
26840: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
26844: LD_INT 126
26846: PPUSH
26847: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
26851: LD_INT 200
26853: PPUSH
26854: CALL_OW 427
// end ;
26858: END
// on SailEvent ( event ) do begin if event < 100 then
26859: LD_VAR 0 1
26863: PUSH
26864: LD_INT 100
26866: LESS
26867: IFFALSE 26878
// CustomEvent ( event ) ;
26869: LD_VAR 0 1
26873: PPUSH
26874: CALL 11838 0 1
// if event = 100 then
26878: LD_VAR 0 1
26882: PUSH
26883: LD_INT 100
26885: EQUAL
26886: IFFALSE 26892
// MC_ClassManager ( ) ;
26888: CALL 27284 0 0
// if event = 101 then
26892: LD_VAR 0 1
26896: PUSH
26897: LD_INT 101
26899: EQUAL
26900: IFFALSE 26906
// MC_RepairBuildings ( ) ;
26902: CALL 32116 0 0
// if event = 102 then
26906: LD_VAR 0 1
26910: PUSH
26911: LD_INT 102
26913: EQUAL
26914: IFFALSE 26920
// MC_Heal ( ) ;
26916: CALL 33051 0 0
// if event = 103 then
26920: LD_VAR 0 1
26924: PUSH
26925: LD_INT 103
26927: EQUAL
26928: IFFALSE 26934
// MC_Build ( ) ;
26930: CALL 33473 0 0
// if event = 104 then
26934: LD_VAR 0 1
26938: PUSH
26939: LD_INT 104
26941: EQUAL
26942: IFFALSE 26948
// MC_TurretWeapon ( ) ;
26944: CALL 35107 0 0
// if event = 105 then
26948: LD_VAR 0 1
26952: PUSH
26953: LD_INT 105
26955: EQUAL
26956: IFFALSE 26962
// MC_BuildUpgrade ( ) ;
26958: CALL 34658 0 0
// if event = 106 then
26962: LD_VAR 0 1
26966: PUSH
26967: LD_INT 106
26969: EQUAL
26970: IFFALSE 26976
// MC_PlantMines ( ) ;
26972: CALL 35537 0 0
// if event = 107 then
26976: LD_VAR 0 1
26980: PUSH
26981: LD_INT 107
26983: EQUAL
26984: IFFALSE 26990
// MC_CollectCrates ( ) ;
26986: CALL 36335 0 0
// if event = 108 then
26990: LD_VAR 0 1
26994: PUSH
26995: LD_INT 108
26997: EQUAL
26998: IFFALSE 27004
// MC_LinkRemoteControl ( ) ;
27000: CALL 38185 0 0
// if event = 109 then
27004: LD_VAR 0 1
27008: PUSH
27009: LD_INT 109
27011: EQUAL
27012: IFFALSE 27018
// MC_ProduceVehicle ( ) ;
27014: CALL 38366 0 0
// if event = 110 then
27018: LD_VAR 0 1
27022: PUSH
27023: LD_INT 110
27025: EQUAL
27026: IFFALSE 27032
// MC_SendAttack ( ) ;
27028: CALL 38832 0 0
// if event = 111 then
27032: LD_VAR 0 1
27036: PUSH
27037: LD_INT 111
27039: EQUAL
27040: IFFALSE 27046
// MC_Defend ( ) ;
27042: CALL 38940 0 0
// if event = 112 then
27046: LD_VAR 0 1
27050: PUSH
27051: LD_INT 112
27053: EQUAL
27054: IFFALSE 27060
// MC_Research ( ) ;
27056: CALL 39820 0 0
// if event = 113 then
27060: LD_VAR 0 1
27064: PUSH
27065: LD_INT 113
27067: EQUAL
27068: IFFALSE 27074
// MC_MinesTrigger ( ) ;
27070: CALL 40934 0 0
// if event = 120 then
27074: LD_VAR 0 1
27078: PUSH
27079: LD_INT 120
27081: EQUAL
27082: IFFALSE 27088
// MC_RepairVehicle ( ) ;
27084: CALL 41033 0 0
// if event = 121 then
27088: LD_VAR 0 1
27092: PUSH
27093: LD_INT 121
27095: EQUAL
27096: IFFALSE 27102
// MC_TameApe ( ) ;
27098: CALL 41802 0 0
// if event = 122 then
27102: LD_VAR 0 1
27106: PUSH
27107: LD_INT 122
27109: EQUAL
27110: IFFALSE 27116
// MC_ChangeApeClass ( ) ;
27112: CALL 42631 0 0
// if event = 123 then
27116: LD_VAR 0 1
27120: PUSH
27121: LD_INT 123
27123: EQUAL
27124: IFFALSE 27130
// MC_Bazooka ( ) ;
27126: CALL 43281 0 0
// if event = 124 then
27130: LD_VAR 0 1
27134: PUSH
27135: LD_INT 124
27137: EQUAL
27138: IFFALSE 27144
// MC_TeleportExit ( ) ;
27140: CALL 43479 0 0
// if event = 125 then
27144: LD_VAR 0 1
27148: PUSH
27149: LD_INT 125
27151: EQUAL
27152: IFFALSE 27158
// MC_Deposits ( ) ;
27154: CALL 44126 0 0
// if event = 126 then
27158: LD_VAR 0 1
27162: PUSH
27163: LD_INT 126
27165: EQUAL
27166: IFFALSE 27172
// MC_RemoteDriver ( ) ;
27168: CALL 44751 0 0
// if event = 200 then
27172: LD_VAR 0 1
27176: PUSH
27177: LD_INT 200
27179: EQUAL
27180: IFFALSE 27186
// MC_Idle ( ) ;
27182: CALL 46658 0 0
// end ;
27186: PPOPN 1
27188: END
// export function MC_Reset ( base , tag ) ; var i ; begin
27189: LD_INT 0
27191: PPUSH
27192: PPUSH
// if not mc_bases [ base ] or not tag then
27193: LD_EXP 80
27197: PUSH
27198: LD_VAR 0 1
27202: ARRAY
27203: NOT
27204: PUSH
27205: LD_VAR 0 2
27209: NOT
27210: OR
27211: IFFALSE 27215
// exit ;
27213: GO 27279
// for i in mc_bases [ base ] union mc_ape [ base ] do
27215: LD_ADDR_VAR 0 4
27219: PUSH
27220: LD_EXP 80
27224: PUSH
27225: LD_VAR 0 1
27229: ARRAY
27230: PUSH
27231: LD_EXP 109
27235: PUSH
27236: LD_VAR 0 1
27240: ARRAY
27241: UNION
27242: PUSH
27243: FOR_IN
27244: IFFALSE 27277
// if GetTag ( i ) = tag then
27246: LD_VAR 0 4
27250: PPUSH
27251: CALL_OW 110
27255: PUSH
27256: LD_VAR 0 2
27260: EQUAL
27261: IFFALSE 27275
// SetTag ( i , 0 ) ;
27263: LD_VAR 0 4
27267: PPUSH
27268: LD_INT 0
27270: PPUSH
27271: CALL_OW 109
27275: GO 27243
27277: POP
27278: POP
// end ;
27279: LD_VAR 0 3
27283: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
27284: LD_INT 0
27286: PPUSH
27287: PPUSH
27288: PPUSH
27289: PPUSH
27290: PPUSH
27291: PPUSH
27292: PPUSH
27293: PPUSH
// if not mc_bases then
27294: LD_EXP 80
27298: NOT
27299: IFFALSE 27303
// exit ;
27301: GO 27752
// for i = 1 to mc_bases do
27303: LD_ADDR_VAR 0 2
27307: PUSH
27308: DOUBLE
27309: LD_INT 1
27311: DEC
27312: ST_TO_ADDR
27313: LD_EXP 80
27317: PUSH
27318: FOR_TO
27319: IFFALSE 27750
// begin tmp := MC_ClassCheckReq ( i ) ;
27321: LD_ADDR_VAR 0 4
27325: PUSH
27326: LD_VAR 0 2
27330: PPUSH
27331: CALL 27757 0 1
27335: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
27336: LD_ADDR_EXP 121
27340: PUSH
27341: LD_EXP 121
27345: PPUSH
27346: LD_VAR 0 2
27350: PPUSH
27351: LD_VAR 0 4
27355: PPUSH
27356: CALL_OW 1
27360: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
27361: LD_ADDR_VAR 0 6
27365: PUSH
27366: LD_EXP 80
27370: PUSH
27371: LD_VAR 0 2
27375: ARRAY
27376: PPUSH
27377: LD_INT 2
27379: PUSH
27380: LD_INT 30
27382: PUSH
27383: LD_INT 4
27385: PUSH
27386: EMPTY
27387: LIST
27388: LIST
27389: PUSH
27390: LD_INT 30
27392: PUSH
27393: LD_INT 5
27395: PUSH
27396: EMPTY
27397: LIST
27398: LIST
27399: PUSH
27400: EMPTY
27401: LIST
27402: LIST
27403: LIST
27404: PPUSH
27405: CALL_OW 72
27409: PUSH
27410: LD_EXP 80
27414: PUSH
27415: LD_VAR 0 2
27419: ARRAY
27420: PPUSH
27421: LD_INT 2
27423: PUSH
27424: LD_INT 30
27426: PUSH
27427: LD_INT 0
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PUSH
27434: LD_INT 30
27436: PUSH
27437: LD_INT 1
27439: PUSH
27440: EMPTY
27441: LIST
27442: LIST
27443: PUSH
27444: EMPTY
27445: LIST
27446: LIST
27447: LIST
27448: PPUSH
27449: CALL_OW 72
27453: PUSH
27454: LD_EXP 80
27458: PUSH
27459: LD_VAR 0 2
27463: ARRAY
27464: PPUSH
27465: LD_INT 30
27467: PUSH
27468: LD_INT 3
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PPUSH
27475: CALL_OW 72
27479: PUSH
27480: LD_EXP 80
27484: PUSH
27485: LD_VAR 0 2
27489: ARRAY
27490: PPUSH
27491: LD_INT 2
27493: PUSH
27494: LD_INT 30
27496: PUSH
27497: LD_INT 6
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 30
27506: PUSH
27507: LD_INT 7
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: LD_INT 30
27516: PUSH
27517: LD_INT 8
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: EMPTY
27525: LIST
27526: LIST
27527: LIST
27528: LIST
27529: PPUSH
27530: CALL_OW 72
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: LIST
27539: LIST
27540: ST_TO_ADDR
// for j := 1 to 4 do
27541: LD_ADDR_VAR 0 3
27545: PUSH
27546: DOUBLE
27547: LD_INT 1
27549: DEC
27550: ST_TO_ADDR
27551: LD_INT 4
27553: PUSH
27554: FOR_TO
27555: IFFALSE 27746
// begin if not tmp [ j ] then
27557: LD_VAR 0 4
27561: PUSH
27562: LD_VAR 0 3
27566: ARRAY
27567: NOT
27568: IFFALSE 27572
// continue ;
27570: GO 27554
// for p in tmp [ j ] do
27572: LD_ADDR_VAR 0 5
27576: PUSH
27577: LD_VAR 0 4
27581: PUSH
27582: LD_VAR 0 3
27586: ARRAY
27587: PUSH
27588: FOR_IN
27589: IFFALSE 27742
// begin if not b [ j ] then
27591: LD_VAR 0 6
27595: PUSH
27596: LD_VAR 0 3
27600: ARRAY
27601: NOT
27602: IFFALSE 27606
// break ;
27604: GO 27742
// e := 0 ;
27606: LD_ADDR_VAR 0 7
27610: PUSH
27611: LD_INT 0
27613: ST_TO_ADDR
// for k in b [ j ] do
27614: LD_ADDR_VAR 0 8
27618: PUSH
27619: LD_VAR 0 6
27623: PUSH
27624: LD_VAR 0 3
27628: ARRAY
27629: PUSH
27630: FOR_IN
27631: IFFALSE 27658
// if IsNotFull ( k ) then
27633: LD_VAR 0 8
27637: PPUSH
27638: CALL 55996 0 1
27642: IFFALSE 27656
// begin e := k ;
27644: LD_ADDR_VAR 0 7
27648: PUSH
27649: LD_VAR 0 8
27653: ST_TO_ADDR
// break ;
27654: GO 27658
// end ;
27656: GO 27630
27658: POP
27659: POP
// if e and not UnitGoingToBuilding ( p , e ) then
27660: LD_VAR 0 7
27664: PUSH
27665: LD_VAR 0 5
27669: PPUSH
27670: LD_VAR 0 7
27674: PPUSH
27675: CALL 90155 0 2
27679: NOT
27680: AND
27681: IFFALSE 27740
// begin if IsInUnit ( p ) then
27683: LD_VAR 0 5
27687: PPUSH
27688: CALL_OW 310
27692: IFFALSE 27703
// ComExitBuilding ( p ) ;
27694: LD_VAR 0 5
27698: PPUSH
27699: CALL_OW 122
// ComEnterUnit ( p , e ) ;
27703: LD_VAR 0 5
27707: PPUSH
27708: LD_VAR 0 7
27712: PPUSH
27713: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
27717: LD_VAR 0 5
27721: PPUSH
27722: LD_VAR 0 3
27726: PPUSH
27727: CALL_OW 183
// AddComExitBuilding ( p ) ;
27731: LD_VAR 0 5
27735: PPUSH
27736: CALL_OW 182
// end ; end ;
27740: GO 27588
27742: POP
27743: POP
// end ;
27744: GO 27554
27746: POP
27747: POP
// end ;
27748: GO 27318
27750: POP
27751: POP
// end ;
27752: LD_VAR 0 1
27756: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
27757: LD_INT 0
27759: PPUSH
27760: PPUSH
27761: PPUSH
27762: PPUSH
27763: PPUSH
27764: PPUSH
27765: PPUSH
27766: PPUSH
27767: PPUSH
27768: PPUSH
27769: PPUSH
27770: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
27771: LD_ADDR_VAR 0 2
27775: PUSH
27776: LD_INT 0
27778: PUSH
27779: LD_INT 0
27781: PUSH
27782: LD_INT 0
27784: PUSH
27785: LD_INT 0
27787: PUSH
27788: EMPTY
27789: LIST
27790: LIST
27791: LIST
27792: LIST
27793: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
27794: LD_VAR 0 1
27798: NOT
27799: PUSH
27800: LD_EXP 80
27804: PUSH
27805: LD_VAR 0 1
27809: ARRAY
27810: NOT
27811: OR
27812: PUSH
27813: LD_EXP 80
27817: PUSH
27818: LD_VAR 0 1
27822: ARRAY
27823: PPUSH
27824: LD_INT 2
27826: PUSH
27827: LD_INT 30
27829: PUSH
27830: LD_INT 0
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PUSH
27837: LD_INT 30
27839: PUSH
27840: LD_INT 1
27842: PUSH
27843: EMPTY
27844: LIST
27845: LIST
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: LIST
27851: PPUSH
27852: CALL_OW 72
27856: NOT
27857: OR
27858: IFFALSE 27862
// exit ;
27860: GO 31365
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27862: LD_ADDR_VAR 0 4
27866: PUSH
27867: LD_EXP 80
27871: PUSH
27872: LD_VAR 0 1
27876: ARRAY
27877: PPUSH
27878: LD_INT 2
27880: PUSH
27881: LD_INT 25
27883: PUSH
27884: LD_INT 1
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: LD_INT 25
27893: PUSH
27894: LD_INT 2
27896: PUSH
27897: EMPTY
27898: LIST
27899: LIST
27900: PUSH
27901: LD_INT 25
27903: PUSH
27904: LD_INT 3
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 25
27913: PUSH
27914: LD_INT 4
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: PUSH
27921: LD_INT 25
27923: PUSH
27924: LD_INT 5
27926: PUSH
27927: EMPTY
27928: LIST
27929: LIST
27930: PUSH
27931: LD_INT 25
27933: PUSH
27934: LD_INT 8
27936: PUSH
27937: EMPTY
27938: LIST
27939: LIST
27940: PUSH
27941: LD_INT 25
27943: PUSH
27944: LD_INT 9
27946: PUSH
27947: EMPTY
27948: LIST
27949: LIST
27950: PUSH
27951: EMPTY
27952: LIST
27953: LIST
27954: LIST
27955: LIST
27956: LIST
27957: LIST
27958: LIST
27959: LIST
27960: PPUSH
27961: CALL_OW 72
27965: ST_TO_ADDR
// if not tmp then
27966: LD_VAR 0 4
27970: NOT
27971: IFFALSE 27975
// exit ;
27973: GO 31365
// for i in tmp do
27975: LD_ADDR_VAR 0 3
27979: PUSH
27980: LD_VAR 0 4
27984: PUSH
27985: FOR_IN
27986: IFFALSE 28017
// if GetTag ( i ) then
27988: LD_VAR 0 3
27992: PPUSH
27993: CALL_OW 110
27997: IFFALSE 28015
// tmp := tmp diff i ;
27999: LD_ADDR_VAR 0 4
28003: PUSH
28004: LD_VAR 0 4
28008: PUSH
28009: LD_VAR 0 3
28013: DIFF
28014: ST_TO_ADDR
28015: GO 27985
28017: POP
28018: POP
// if not tmp then
28019: LD_VAR 0 4
28023: NOT
28024: IFFALSE 28028
// exit ;
28026: GO 31365
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
28028: LD_ADDR_VAR 0 5
28032: PUSH
28033: LD_EXP 80
28037: PUSH
28038: LD_VAR 0 1
28042: ARRAY
28043: PPUSH
28044: LD_INT 2
28046: PUSH
28047: LD_INT 25
28049: PUSH
28050: LD_INT 1
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 25
28059: PUSH
28060: LD_INT 5
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: LD_INT 25
28069: PUSH
28070: LD_INT 8
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PUSH
28077: LD_INT 25
28079: PUSH
28080: LD_INT 9
28082: PUSH
28083: EMPTY
28084: LIST
28085: LIST
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: LIST
28091: LIST
28092: LIST
28093: PPUSH
28094: CALL_OW 72
28098: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
28099: LD_ADDR_VAR 0 6
28103: PUSH
28104: LD_EXP 80
28108: PUSH
28109: LD_VAR 0 1
28113: ARRAY
28114: PPUSH
28115: LD_INT 25
28117: PUSH
28118: LD_INT 2
28120: PUSH
28121: EMPTY
28122: LIST
28123: LIST
28124: PPUSH
28125: CALL_OW 72
28129: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
28130: LD_ADDR_VAR 0 7
28134: PUSH
28135: LD_EXP 80
28139: PUSH
28140: LD_VAR 0 1
28144: ARRAY
28145: PPUSH
28146: LD_INT 25
28148: PUSH
28149: LD_INT 3
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PPUSH
28156: CALL_OW 72
28160: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
28161: LD_ADDR_VAR 0 8
28165: PUSH
28166: LD_EXP 80
28170: PUSH
28171: LD_VAR 0 1
28175: ARRAY
28176: PPUSH
28177: LD_INT 25
28179: PUSH
28180: LD_INT 4
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: LD_INT 24
28189: PUSH
28190: LD_INT 251
28192: PUSH
28193: EMPTY
28194: LIST
28195: LIST
28196: PUSH
28197: EMPTY
28198: LIST
28199: LIST
28200: PPUSH
28201: CALL_OW 72
28205: ST_TO_ADDR
// if mc_is_defending [ base ] then
28206: LD_EXP 123
28210: PUSH
28211: LD_VAR 0 1
28215: ARRAY
28216: IFFALSE 28677
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
28218: LD_ADDR_EXP 122
28222: PUSH
28223: LD_EXP 122
28227: PPUSH
28228: LD_VAR 0 1
28232: PPUSH
28233: LD_INT 4
28235: PPUSH
28236: CALL_OW 1
28240: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
28241: LD_ADDR_VAR 0 12
28245: PUSH
28246: LD_EXP 80
28250: PUSH
28251: LD_VAR 0 1
28255: ARRAY
28256: PPUSH
28257: LD_INT 2
28259: PUSH
28260: LD_INT 30
28262: PUSH
28263: LD_INT 4
28265: PUSH
28266: EMPTY
28267: LIST
28268: LIST
28269: PUSH
28270: LD_INT 30
28272: PUSH
28273: LD_INT 5
28275: PUSH
28276: EMPTY
28277: LIST
28278: LIST
28279: PUSH
28280: EMPTY
28281: LIST
28282: LIST
28283: LIST
28284: PPUSH
28285: CALL_OW 72
28289: ST_TO_ADDR
// if not b then
28290: LD_VAR 0 12
28294: NOT
28295: IFFALSE 28299
// exit ;
28297: GO 31365
// p := [ ] ;
28299: LD_ADDR_VAR 0 11
28303: PUSH
28304: EMPTY
28305: ST_TO_ADDR
// if sci >= 2 then
28306: LD_VAR 0 8
28310: PUSH
28311: LD_INT 2
28313: GREATEREQUAL
28314: IFFALSE 28345
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
28316: LD_ADDR_VAR 0 8
28320: PUSH
28321: LD_VAR 0 8
28325: PUSH
28326: LD_INT 1
28328: ARRAY
28329: PUSH
28330: LD_VAR 0 8
28334: PUSH
28335: LD_INT 2
28337: ARRAY
28338: PUSH
28339: EMPTY
28340: LIST
28341: LIST
28342: ST_TO_ADDR
28343: GO 28406
// if sci = 1 then
28345: LD_VAR 0 8
28349: PUSH
28350: LD_INT 1
28352: EQUAL
28353: IFFALSE 28374
// sci := [ sci [ 1 ] ] else
28355: LD_ADDR_VAR 0 8
28359: PUSH
28360: LD_VAR 0 8
28364: PUSH
28365: LD_INT 1
28367: ARRAY
28368: PUSH
28369: EMPTY
28370: LIST
28371: ST_TO_ADDR
28372: GO 28406
// if sci = 0 then
28374: LD_VAR 0 8
28378: PUSH
28379: LD_INT 0
28381: EQUAL
28382: IFFALSE 28406
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
28384: LD_ADDR_VAR 0 11
28388: PUSH
28389: LD_VAR 0 4
28393: PPUSH
28394: LD_INT 4
28396: PPUSH
28397: CALL 90027 0 2
28401: PUSH
28402: LD_INT 1
28404: ARRAY
28405: ST_TO_ADDR
// if eng > 4 then
28406: LD_VAR 0 6
28410: PUSH
28411: LD_INT 4
28413: GREATER
28414: IFFALSE 28460
// for i = eng downto 4 do
28416: LD_ADDR_VAR 0 3
28420: PUSH
28421: DOUBLE
28422: LD_VAR 0 6
28426: INC
28427: ST_TO_ADDR
28428: LD_INT 4
28430: PUSH
28431: FOR_DOWNTO
28432: IFFALSE 28458
// eng := eng diff eng [ i ] ;
28434: LD_ADDR_VAR 0 6
28438: PUSH
28439: LD_VAR 0 6
28443: PUSH
28444: LD_VAR 0 6
28448: PUSH
28449: LD_VAR 0 3
28453: ARRAY
28454: DIFF
28455: ST_TO_ADDR
28456: GO 28431
28458: POP
28459: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
28460: LD_ADDR_VAR 0 4
28464: PUSH
28465: LD_VAR 0 4
28469: PUSH
28470: LD_VAR 0 5
28474: PUSH
28475: LD_VAR 0 6
28479: UNION
28480: PUSH
28481: LD_VAR 0 7
28485: UNION
28486: PUSH
28487: LD_VAR 0 8
28491: UNION
28492: DIFF
28493: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
28494: LD_ADDR_VAR 0 13
28498: PUSH
28499: LD_EXP 80
28503: PUSH
28504: LD_VAR 0 1
28508: ARRAY
28509: PPUSH
28510: LD_INT 2
28512: PUSH
28513: LD_INT 30
28515: PUSH
28516: LD_INT 32
28518: PUSH
28519: EMPTY
28520: LIST
28521: LIST
28522: PUSH
28523: LD_INT 30
28525: PUSH
28526: LD_INT 31
28528: PUSH
28529: EMPTY
28530: LIST
28531: LIST
28532: PUSH
28533: EMPTY
28534: LIST
28535: LIST
28536: LIST
28537: PPUSH
28538: CALL_OW 72
28542: PUSH
28543: LD_EXP 80
28547: PUSH
28548: LD_VAR 0 1
28552: ARRAY
28553: PPUSH
28554: LD_INT 2
28556: PUSH
28557: LD_INT 30
28559: PUSH
28560: LD_INT 4
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: PUSH
28567: LD_INT 30
28569: PUSH
28570: LD_INT 5
28572: PUSH
28573: EMPTY
28574: LIST
28575: LIST
28576: PUSH
28577: EMPTY
28578: LIST
28579: LIST
28580: LIST
28581: PPUSH
28582: CALL_OW 72
28586: PUSH
28587: LD_INT 6
28589: MUL
28590: PLUS
28591: ST_TO_ADDR
// if bcount < tmp then
28592: LD_VAR 0 13
28596: PUSH
28597: LD_VAR 0 4
28601: LESS
28602: IFFALSE 28648
// for i = tmp downto bcount do
28604: LD_ADDR_VAR 0 3
28608: PUSH
28609: DOUBLE
28610: LD_VAR 0 4
28614: INC
28615: ST_TO_ADDR
28616: LD_VAR 0 13
28620: PUSH
28621: FOR_DOWNTO
28622: IFFALSE 28646
// tmp := Delete ( tmp , tmp ) ;
28624: LD_ADDR_VAR 0 4
28628: PUSH
28629: LD_VAR 0 4
28633: PPUSH
28634: LD_VAR 0 4
28638: PPUSH
28639: CALL_OW 3
28643: ST_TO_ADDR
28644: GO 28621
28646: POP
28647: POP
// result := [ tmp , 0 , 0 , p ] ;
28648: LD_ADDR_VAR 0 2
28652: PUSH
28653: LD_VAR 0 4
28657: PUSH
28658: LD_INT 0
28660: PUSH
28661: LD_INT 0
28663: PUSH
28664: LD_VAR 0 11
28668: PUSH
28669: EMPTY
28670: LIST
28671: LIST
28672: LIST
28673: LIST
28674: ST_TO_ADDR
// exit ;
28675: GO 31365
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28677: LD_EXP 80
28681: PUSH
28682: LD_VAR 0 1
28686: ARRAY
28687: PPUSH
28688: LD_INT 2
28690: PUSH
28691: LD_INT 30
28693: PUSH
28694: LD_INT 6
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 30
28703: PUSH
28704: LD_INT 7
28706: PUSH
28707: EMPTY
28708: LIST
28709: LIST
28710: PUSH
28711: LD_INT 30
28713: PUSH
28714: LD_INT 8
28716: PUSH
28717: EMPTY
28718: LIST
28719: LIST
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: LIST
28725: LIST
28726: PPUSH
28727: CALL_OW 72
28731: NOT
28732: PUSH
28733: LD_EXP 80
28737: PUSH
28738: LD_VAR 0 1
28742: ARRAY
28743: PPUSH
28744: LD_INT 30
28746: PUSH
28747: LD_INT 3
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PPUSH
28754: CALL_OW 72
28758: NOT
28759: AND
28760: IFFALSE 28832
// begin if eng = tmp then
28762: LD_VAR 0 6
28766: PUSH
28767: LD_VAR 0 4
28771: EQUAL
28772: IFFALSE 28776
// exit ;
28774: GO 31365
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
28776: LD_ADDR_EXP 122
28780: PUSH
28781: LD_EXP 122
28785: PPUSH
28786: LD_VAR 0 1
28790: PPUSH
28791: LD_INT 1
28793: PPUSH
28794: CALL_OW 1
28798: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
28799: LD_ADDR_VAR 0 2
28803: PUSH
28804: LD_INT 0
28806: PUSH
28807: LD_VAR 0 4
28811: PUSH
28812: LD_VAR 0 6
28816: DIFF
28817: PUSH
28818: LD_INT 0
28820: PUSH
28821: LD_INT 0
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: LIST
28828: LIST
28829: ST_TO_ADDR
// exit ;
28830: GO 31365
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28832: LD_EXP 107
28836: PUSH
28837: LD_EXP 106
28841: PUSH
28842: LD_VAR 0 1
28846: ARRAY
28847: ARRAY
28848: PUSH
28849: LD_EXP 80
28853: PUSH
28854: LD_VAR 0 1
28858: ARRAY
28859: PPUSH
28860: LD_INT 2
28862: PUSH
28863: LD_INT 30
28865: PUSH
28866: LD_INT 6
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 30
28875: PUSH
28876: LD_INT 7
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: PUSH
28883: LD_INT 30
28885: PUSH
28886: LD_INT 8
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: EMPTY
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: PPUSH
28899: CALL_OW 72
28903: AND
28904: PUSH
28905: LD_EXP 80
28909: PUSH
28910: LD_VAR 0 1
28914: ARRAY
28915: PPUSH
28916: LD_INT 30
28918: PUSH
28919: LD_INT 3
28921: PUSH
28922: EMPTY
28923: LIST
28924: LIST
28925: PPUSH
28926: CALL_OW 72
28930: NOT
28931: AND
28932: IFFALSE 29146
// begin if sci >= 6 then
28934: LD_VAR 0 8
28938: PUSH
28939: LD_INT 6
28941: GREATEREQUAL
28942: IFFALSE 28946
// exit ;
28944: GO 31365
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
28946: LD_ADDR_EXP 122
28950: PUSH
28951: LD_EXP 122
28955: PPUSH
28956: LD_VAR 0 1
28960: PPUSH
28961: LD_INT 2
28963: PPUSH
28964: CALL_OW 1
28968: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
28969: LD_ADDR_VAR 0 9
28973: PUSH
28974: LD_VAR 0 4
28978: PUSH
28979: LD_VAR 0 8
28983: DIFF
28984: PPUSH
28985: LD_INT 4
28987: PPUSH
28988: CALL 90027 0 2
28992: ST_TO_ADDR
// p := [ ] ;
28993: LD_ADDR_VAR 0 11
28997: PUSH
28998: EMPTY
28999: ST_TO_ADDR
// if sci < 6 and sort > 6 then
29000: LD_VAR 0 8
29004: PUSH
29005: LD_INT 6
29007: LESS
29008: PUSH
29009: LD_VAR 0 9
29013: PUSH
29014: LD_INT 6
29016: GREATER
29017: AND
29018: IFFALSE 29099
// begin for i = 1 to 6 - sci do
29020: LD_ADDR_VAR 0 3
29024: PUSH
29025: DOUBLE
29026: LD_INT 1
29028: DEC
29029: ST_TO_ADDR
29030: LD_INT 6
29032: PUSH
29033: LD_VAR 0 8
29037: MINUS
29038: PUSH
29039: FOR_TO
29040: IFFALSE 29095
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
29042: LD_ADDR_VAR 0 11
29046: PUSH
29047: LD_VAR 0 11
29051: PPUSH
29052: LD_VAR 0 11
29056: PUSH
29057: LD_INT 1
29059: PLUS
29060: PPUSH
29061: LD_VAR 0 9
29065: PUSH
29066: LD_INT 1
29068: ARRAY
29069: PPUSH
29070: CALL_OW 2
29074: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
29075: LD_ADDR_VAR 0 9
29079: PUSH
29080: LD_VAR 0 9
29084: PPUSH
29085: LD_INT 1
29087: PPUSH
29088: CALL_OW 3
29092: ST_TO_ADDR
// end ;
29093: GO 29039
29095: POP
29096: POP
// end else
29097: GO 29119
// if sort then
29099: LD_VAR 0 9
29103: IFFALSE 29119
// p := sort [ 1 ] ;
29105: LD_ADDR_VAR 0 11
29109: PUSH
29110: LD_VAR 0 9
29114: PUSH
29115: LD_INT 1
29117: ARRAY
29118: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
29119: LD_ADDR_VAR 0 2
29123: PUSH
29124: LD_INT 0
29126: PUSH
29127: LD_INT 0
29129: PUSH
29130: LD_INT 0
29132: PUSH
29133: LD_VAR 0 11
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: LIST
29142: LIST
29143: ST_TO_ADDR
// exit ;
29144: GO 31365
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
29146: LD_EXP 107
29150: PUSH
29151: LD_EXP 106
29155: PUSH
29156: LD_VAR 0 1
29160: ARRAY
29161: ARRAY
29162: PUSH
29163: LD_EXP 80
29167: PUSH
29168: LD_VAR 0 1
29172: ARRAY
29173: PPUSH
29174: LD_INT 2
29176: PUSH
29177: LD_INT 30
29179: PUSH
29180: LD_INT 6
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PUSH
29187: LD_INT 30
29189: PUSH
29190: LD_INT 7
29192: PUSH
29193: EMPTY
29194: LIST
29195: LIST
29196: PUSH
29197: LD_INT 30
29199: PUSH
29200: LD_INT 8
29202: PUSH
29203: EMPTY
29204: LIST
29205: LIST
29206: PUSH
29207: EMPTY
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: PPUSH
29213: CALL_OW 72
29217: AND
29218: PUSH
29219: LD_EXP 80
29223: PUSH
29224: LD_VAR 0 1
29228: ARRAY
29229: PPUSH
29230: LD_INT 30
29232: PUSH
29233: LD_INT 3
29235: PUSH
29236: EMPTY
29237: LIST
29238: LIST
29239: PPUSH
29240: CALL_OW 72
29244: AND
29245: IFFALSE 29979
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
29247: LD_ADDR_EXP 122
29251: PUSH
29252: LD_EXP 122
29256: PPUSH
29257: LD_VAR 0 1
29261: PPUSH
29262: LD_INT 3
29264: PPUSH
29265: CALL_OW 1
29269: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29270: LD_ADDR_VAR 0 2
29274: PUSH
29275: LD_INT 0
29277: PUSH
29278: LD_INT 0
29280: PUSH
29281: LD_INT 0
29283: PUSH
29284: LD_INT 0
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: LIST
29291: LIST
29292: ST_TO_ADDR
// if not eng then
29293: LD_VAR 0 6
29297: NOT
29298: IFFALSE 29361
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
29300: LD_ADDR_VAR 0 11
29304: PUSH
29305: LD_VAR 0 4
29309: PPUSH
29310: LD_INT 2
29312: PPUSH
29313: CALL 90027 0 2
29317: PUSH
29318: LD_INT 1
29320: ARRAY
29321: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
29322: LD_ADDR_VAR 0 2
29326: PUSH
29327: LD_VAR 0 2
29331: PPUSH
29332: LD_INT 2
29334: PPUSH
29335: LD_VAR 0 11
29339: PPUSH
29340: CALL_OW 1
29344: ST_TO_ADDR
// tmp := tmp diff p ;
29345: LD_ADDR_VAR 0 4
29349: PUSH
29350: LD_VAR 0 4
29354: PUSH
29355: LD_VAR 0 11
29359: DIFF
29360: ST_TO_ADDR
// end ; if tmp and sci < 6 then
29361: LD_VAR 0 4
29365: PUSH
29366: LD_VAR 0 8
29370: PUSH
29371: LD_INT 6
29373: LESS
29374: AND
29375: IFFALSE 29563
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
29377: LD_ADDR_VAR 0 9
29381: PUSH
29382: LD_VAR 0 4
29386: PUSH
29387: LD_VAR 0 8
29391: PUSH
29392: LD_VAR 0 7
29396: UNION
29397: DIFF
29398: PPUSH
29399: LD_INT 4
29401: PPUSH
29402: CALL 90027 0 2
29406: ST_TO_ADDR
// p := [ ] ;
29407: LD_ADDR_VAR 0 11
29411: PUSH
29412: EMPTY
29413: ST_TO_ADDR
// if sort then
29414: LD_VAR 0 9
29418: IFFALSE 29534
// for i = 1 to 6 - sci do
29420: LD_ADDR_VAR 0 3
29424: PUSH
29425: DOUBLE
29426: LD_INT 1
29428: DEC
29429: ST_TO_ADDR
29430: LD_INT 6
29432: PUSH
29433: LD_VAR 0 8
29437: MINUS
29438: PUSH
29439: FOR_TO
29440: IFFALSE 29532
// begin if i = sort then
29442: LD_VAR 0 3
29446: PUSH
29447: LD_VAR 0 9
29451: EQUAL
29452: IFFALSE 29456
// break ;
29454: GO 29532
// if GetClass ( i ) = 4 then
29456: LD_VAR 0 3
29460: PPUSH
29461: CALL_OW 257
29465: PUSH
29466: LD_INT 4
29468: EQUAL
29469: IFFALSE 29473
// continue ;
29471: GO 29439
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29473: LD_ADDR_VAR 0 11
29477: PUSH
29478: LD_VAR 0 11
29482: PPUSH
29483: LD_VAR 0 11
29487: PUSH
29488: LD_INT 1
29490: PLUS
29491: PPUSH
29492: LD_VAR 0 9
29496: PUSH
29497: LD_VAR 0 3
29501: ARRAY
29502: PPUSH
29503: CALL_OW 2
29507: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29508: LD_ADDR_VAR 0 4
29512: PUSH
29513: LD_VAR 0 4
29517: PUSH
29518: LD_VAR 0 9
29522: PUSH
29523: LD_VAR 0 3
29527: ARRAY
29528: DIFF
29529: ST_TO_ADDR
// end ;
29530: GO 29439
29532: POP
29533: POP
// if p then
29534: LD_VAR 0 11
29538: IFFALSE 29563
// result := Replace ( result , 4 , p ) ;
29540: LD_ADDR_VAR 0 2
29544: PUSH
29545: LD_VAR 0 2
29549: PPUSH
29550: LD_INT 4
29552: PPUSH
29553: LD_VAR 0 11
29557: PPUSH
29558: CALL_OW 1
29562: ST_TO_ADDR
// end ; if tmp and mech < 6 then
29563: LD_VAR 0 4
29567: PUSH
29568: LD_VAR 0 7
29572: PUSH
29573: LD_INT 6
29575: LESS
29576: AND
29577: IFFALSE 29765
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29579: LD_ADDR_VAR 0 9
29583: PUSH
29584: LD_VAR 0 4
29588: PUSH
29589: LD_VAR 0 8
29593: PUSH
29594: LD_VAR 0 7
29598: UNION
29599: DIFF
29600: PPUSH
29601: LD_INT 3
29603: PPUSH
29604: CALL 90027 0 2
29608: ST_TO_ADDR
// p := [ ] ;
29609: LD_ADDR_VAR 0 11
29613: PUSH
29614: EMPTY
29615: ST_TO_ADDR
// if sort then
29616: LD_VAR 0 9
29620: IFFALSE 29736
// for i = 1 to 6 - mech do
29622: LD_ADDR_VAR 0 3
29626: PUSH
29627: DOUBLE
29628: LD_INT 1
29630: DEC
29631: ST_TO_ADDR
29632: LD_INT 6
29634: PUSH
29635: LD_VAR 0 7
29639: MINUS
29640: PUSH
29641: FOR_TO
29642: IFFALSE 29734
// begin if i = sort then
29644: LD_VAR 0 3
29648: PUSH
29649: LD_VAR 0 9
29653: EQUAL
29654: IFFALSE 29658
// break ;
29656: GO 29734
// if GetClass ( i ) = 3 then
29658: LD_VAR 0 3
29662: PPUSH
29663: CALL_OW 257
29667: PUSH
29668: LD_INT 3
29670: EQUAL
29671: IFFALSE 29675
// continue ;
29673: GO 29641
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29675: LD_ADDR_VAR 0 11
29679: PUSH
29680: LD_VAR 0 11
29684: PPUSH
29685: LD_VAR 0 11
29689: PUSH
29690: LD_INT 1
29692: PLUS
29693: PPUSH
29694: LD_VAR 0 9
29698: PUSH
29699: LD_VAR 0 3
29703: ARRAY
29704: PPUSH
29705: CALL_OW 2
29709: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29710: LD_ADDR_VAR 0 4
29714: PUSH
29715: LD_VAR 0 4
29719: PUSH
29720: LD_VAR 0 9
29724: PUSH
29725: LD_VAR 0 3
29729: ARRAY
29730: DIFF
29731: ST_TO_ADDR
// end ;
29732: GO 29641
29734: POP
29735: POP
// if p then
29736: LD_VAR 0 11
29740: IFFALSE 29765
// result := Replace ( result , 3 , p ) ;
29742: LD_ADDR_VAR 0 2
29746: PUSH
29747: LD_VAR 0 2
29751: PPUSH
29752: LD_INT 3
29754: PPUSH
29755: LD_VAR 0 11
29759: PPUSH
29760: CALL_OW 1
29764: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
29765: LD_VAR 0 4
29769: PUSH
29770: LD_INT 6
29772: GREATER
29773: PUSH
29774: LD_VAR 0 6
29778: PUSH
29779: LD_INT 6
29781: LESS
29782: AND
29783: IFFALSE 29977
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29785: LD_ADDR_VAR 0 9
29789: PUSH
29790: LD_VAR 0 4
29794: PUSH
29795: LD_VAR 0 8
29799: PUSH
29800: LD_VAR 0 7
29804: UNION
29805: PUSH
29806: LD_VAR 0 6
29810: UNION
29811: DIFF
29812: PPUSH
29813: LD_INT 2
29815: PPUSH
29816: CALL 90027 0 2
29820: ST_TO_ADDR
// p := [ ] ;
29821: LD_ADDR_VAR 0 11
29825: PUSH
29826: EMPTY
29827: ST_TO_ADDR
// if sort then
29828: LD_VAR 0 9
29832: IFFALSE 29948
// for i = 1 to 6 - eng do
29834: LD_ADDR_VAR 0 3
29838: PUSH
29839: DOUBLE
29840: LD_INT 1
29842: DEC
29843: ST_TO_ADDR
29844: LD_INT 6
29846: PUSH
29847: LD_VAR 0 6
29851: MINUS
29852: PUSH
29853: FOR_TO
29854: IFFALSE 29946
// begin if i = sort then
29856: LD_VAR 0 3
29860: PUSH
29861: LD_VAR 0 9
29865: EQUAL
29866: IFFALSE 29870
// break ;
29868: GO 29946
// if GetClass ( i ) = 2 then
29870: LD_VAR 0 3
29874: PPUSH
29875: CALL_OW 257
29879: PUSH
29880: LD_INT 2
29882: EQUAL
29883: IFFALSE 29887
// continue ;
29885: GO 29853
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29887: LD_ADDR_VAR 0 11
29891: PUSH
29892: LD_VAR 0 11
29896: PPUSH
29897: LD_VAR 0 11
29901: PUSH
29902: LD_INT 1
29904: PLUS
29905: PPUSH
29906: LD_VAR 0 9
29910: PUSH
29911: LD_VAR 0 3
29915: ARRAY
29916: PPUSH
29917: CALL_OW 2
29921: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29922: LD_ADDR_VAR 0 4
29926: PUSH
29927: LD_VAR 0 4
29931: PUSH
29932: LD_VAR 0 9
29936: PUSH
29937: LD_VAR 0 3
29941: ARRAY
29942: DIFF
29943: ST_TO_ADDR
// end ;
29944: GO 29853
29946: POP
29947: POP
// if p then
29948: LD_VAR 0 11
29952: IFFALSE 29977
// result := Replace ( result , 2 , p ) ;
29954: LD_ADDR_VAR 0 2
29958: PUSH
29959: LD_VAR 0 2
29963: PPUSH
29964: LD_INT 2
29966: PPUSH
29967: LD_VAR 0 11
29971: PPUSH
29972: CALL_OW 1
29976: ST_TO_ADDR
// end ; exit ;
29977: GO 31365
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
29979: LD_EXP 107
29983: PUSH
29984: LD_EXP 106
29988: PUSH
29989: LD_VAR 0 1
29993: ARRAY
29994: ARRAY
29995: NOT
29996: PUSH
29997: LD_EXP 80
30001: PUSH
30002: LD_VAR 0 1
30006: ARRAY
30007: PPUSH
30008: LD_INT 30
30010: PUSH
30011: LD_INT 3
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PPUSH
30018: CALL_OW 72
30022: AND
30023: PUSH
30024: LD_EXP 85
30028: PUSH
30029: LD_VAR 0 1
30033: ARRAY
30034: AND
30035: IFFALSE 30643
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
30037: LD_ADDR_EXP 122
30041: PUSH
30042: LD_EXP 122
30046: PPUSH
30047: LD_VAR 0 1
30051: PPUSH
30052: LD_INT 5
30054: PPUSH
30055: CALL_OW 1
30059: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
30060: LD_ADDR_VAR 0 2
30064: PUSH
30065: LD_INT 0
30067: PUSH
30068: LD_INT 0
30070: PUSH
30071: LD_INT 0
30073: PUSH
30074: LD_INT 0
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: LIST
30081: LIST
30082: ST_TO_ADDR
// if sci > 1 then
30083: LD_VAR 0 8
30087: PUSH
30088: LD_INT 1
30090: GREATER
30091: IFFALSE 30119
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
30093: LD_ADDR_VAR 0 4
30097: PUSH
30098: LD_VAR 0 4
30102: PUSH
30103: LD_VAR 0 8
30107: PUSH
30108: LD_VAR 0 8
30112: PUSH
30113: LD_INT 1
30115: ARRAY
30116: DIFF
30117: DIFF
30118: ST_TO_ADDR
// if tmp and not sci then
30119: LD_VAR 0 4
30123: PUSH
30124: LD_VAR 0 8
30128: NOT
30129: AND
30130: IFFALSE 30199
// begin sort := SortBySkill ( tmp , 4 ) ;
30132: LD_ADDR_VAR 0 9
30136: PUSH
30137: LD_VAR 0 4
30141: PPUSH
30142: LD_INT 4
30144: PPUSH
30145: CALL 90027 0 2
30149: ST_TO_ADDR
// if sort then
30150: LD_VAR 0 9
30154: IFFALSE 30170
// p := sort [ 1 ] ;
30156: LD_ADDR_VAR 0 11
30160: PUSH
30161: LD_VAR 0 9
30165: PUSH
30166: LD_INT 1
30168: ARRAY
30169: ST_TO_ADDR
// if p then
30170: LD_VAR 0 11
30174: IFFALSE 30199
// result := Replace ( result , 4 , p ) ;
30176: LD_ADDR_VAR 0 2
30180: PUSH
30181: LD_VAR 0 2
30185: PPUSH
30186: LD_INT 4
30188: PPUSH
30189: LD_VAR 0 11
30193: PPUSH
30194: CALL_OW 1
30198: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30199: LD_ADDR_VAR 0 4
30203: PUSH
30204: LD_VAR 0 4
30208: PUSH
30209: LD_VAR 0 7
30213: DIFF
30214: ST_TO_ADDR
// if tmp and mech < 6 then
30215: LD_VAR 0 4
30219: PUSH
30220: LD_VAR 0 7
30224: PUSH
30225: LD_INT 6
30227: LESS
30228: AND
30229: IFFALSE 30417
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
30231: LD_ADDR_VAR 0 9
30235: PUSH
30236: LD_VAR 0 4
30240: PUSH
30241: LD_VAR 0 8
30245: PUSH
30246: LD_VAR 0 7
30250: UNION
30251: DIFF
30252: PPUSH
30253: LD_INT 3
30255: PPUSH
30256: CALL 90027 0 2
30260: ST_TO_ADDR
// p := [ ] ;
30261: LD_ADDR_VAR 0 11
30265: PUSH
30266: EMPTY
30267: ST_TO_ADDR
// if sort then
30268: LD_VAR 0 9
30272: IFFALSE 30388
// for i = 1 to 6 - mech do
30274: LD_ADDR_VAR 0 3
30278: PUSH
30279: DOUBLE
30280: LD_INT 1
30282: DEC
30283: ST_TO_ADDR
30284: LD_INT 6
30286: PUSH
30287: LD_VAR 0 7
30291: MINUS
30292: PUSH
30293: FOR_TO
30294: IFFALSE 30386
// begin if i = sort then
30296: LD_VAR 0 3
30300: PUSH
30301: LD_VAR 0 9
30305: EQUAL
30306: IFFALSE 30310
// break ;
30308: GO 30386
// if GetClass ( i ) = 3 then
30310: LD_VAR 0 3
30314: PPUSH
30315: CALL_OW 257
30319: PUSH
30320: LD_INT 3
30322: EQUAL
30323: IFFALSE 30327
// continue ;
30325: GO 30293
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30327: LD_ADDR_VAR 0 11
30331: PUSH
30332: LD_VAR 0 11
30336: PPUSH
30337: LD_VAR 0 11
30341: PUSH
30342: LD_INT 1
30344: PLUS
30345: PPUSH
30346: LD_VAR 0 9
30350: PUSH
30351: LD_VAR 0 3
30355: ARRAY
30356: PPUSH
30357: CALL_OW 2
30361: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30362: LD_ADDR_VAR 0 4
30366: PUSH
30367: LD_VAR 0 4
30371: PUSH
30372: LD_VAR 0 9
30376: PUSH
30377: LD_VAR 0 3
30381: ARRAY
30382: DIFF
30383: ST_TO_ADDR
// end ;
30384: GO 30293
30386: POP
30387: POP
// if p then
30388: LD_VAR 0 11
30392: IFFALSE 30417
// result := Replace ( result , 3 , p ) ;
30394: LD_ADDR_VAR 0 2
30398: PUSH
30399: LD_VAR 0 2
30403: PPUSH
30404: LD_INT 3
30406: PPUSH
30407: LD_VAR 0 11
30411: PPUSH
30412: CALL_OW 1
30416: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30417: LD_ADDR_VAR 0 4
30421: PUSH
30422: LD_VAR 0 4
30426: PUSH
30427: LD_VAR 0 6
30431: DIFF
30432: ST_TO_ADDR
// if tmp and eng < 6 then
30433: LD_VAR 0 4
30437: PUSH
30438: LD_VAR 0 6
30442: PUSH
30443: LD_INT 6
30445: LESS
30446: AND
30447: IFFALSE 30641
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
30449: LD_ADDR_VAR 0 9
30453: PUSH
30454: LD_VAR 0 4
30458: PUSH
30459: LD_VAR 0 8
30463: PUSH
30464: LD_VAR 0 7
30468: UNION
30469: PUSH
30470: LD_VAR 0 6
30474: UNION
30475: DIFF
30476: PPUSH
30477: LD_INT 2
30479: PPUSH
30480: CALL 90027 0 2
30484: ST_TO_ADDR
// p := [ ] ;
30485: LD_ADDR_VAR 0 11
30489: PUSH
30490: EMPTY
30491: ST_TO_ADDR
// if sort then
30492: LD_VAR 0 9
30496: IFFALSE 30612
// for i = 1 to 6 - eng do
30498: LD_ADDR_VAR 0 3
30502: PUSH
30503: DOUBLE
30504: LD_INT 1
30506: DEC
30507: ST_TO_ADDR
30508: LD_INT 6
30510: PUSH
30511: LD_VAR 0 6
30515: MINUS
30516: PUSH
30517: FOR_TO
30518: IFFALSE 30610
// begin if i = sort then
30520: LD_VAR 0 3
30524: PUSH
30525: LD_VAR 0 9
30529: EQUAL
30530: IFFALSE 30534
// break ;
30532: GO 30610
// if GetClass ( i ) = 2 then
30534: LD_VAR 0 3
30538: PPUSH
30539: CALL_OW 257
30543: PUSH
30544: LD_INT 2
30546: EQUAL
30547: IFFALSE 30551
// continue ;
30549: GO 30517
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30551: LD_ADDR_VAR 0 11
30555: PUSH
30556: LD_VAR 0 11
30560: PPUSH
30561: LD_VAR 0 11
30565: PUSH
30566: LD_INT 1
30568: PLUS
30569: PPUSH
30570: LD_VAR 0 9
30574: PUSH
30575: LD_VAR 0 3
30579: ARRAY
30580: PPUSH
30581: CALL_OW 2
30585: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30586: LD_ADDR_VAR 0 4
30590: PUSH
30591: LD_VAR 0 4
30595: PUSH
30596: LD_VAR 0 9
30600: PUSH
30601: LD_VAR 0 3
30605: ARRAY
30606: DIFF
30607: ST_TO_ADDR
// end ;
30608: GO 30517
30610: POP
30611: POP
// if p then
30612: LD_VAR 0 11
30616: IFFALSE 30641
// result := Replace ( result , 2 , p ) ;
30618: LD_ADDR_VAR 0 2
30622: PUSH
30623: LD_VAR 0 2
30627: PPUSH
30628: LD_INT 2
30630: PPUSH
30631: LD_VAR 0 11
30635: PPUSH
30636: CALL_OW 1
30640: ST_TO_ADDR
// end ; exit ;
30641: GO 31365
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
30643: LD_EXP 107
30647: PUSH
30648: LD_EXP 106
30652: PUSH
30653: LD_VAR 0 1
30657: ARRAY
30658: ARRAY
30659: NOT
30660: PUSH
30661: LD_EXP 80
30665: PUSH
30666: LD_VAR 0 1
30670: ARRAY
30671: PPUSH
30672: LD_INT 30
30674: PUSH
30675: LD_INT 3
30677: PUSH
30678: EMPTY
30679: LIST
30680: LIST
30681: PPUSH
30682: CALL_OW 72
30686: AND
30687: PUSH
30688: LD_EXP 85
30692: PUSH
30693: LD_VAR 0 1
30697: ARRAY
30698: NOT
30699: AND
30700: IFFALSE 31365
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
30702: LD_ADDR_EXP 122
30706: PUSH
30707: LD_EXP 122
30711: PPUSH
30712: LD_VAR 0 1
30716: PPUSH
30717: LD_INT 6
30719: PPUSH
30720: CALL_OW 1
30724: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
30725: LD_ADDR_VAR 0 2
30729: PUSH
30730: LD_INT 0
30732: PUSH
30733: LD_INT 0
30735: PUSH
30736: LD_INT 0
30738: PUSH
30739: LD_INT 0
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: LIST
30746: LIST
30747: ST_TO_ADDR
// if sci >= 1 then
30748: LD_VAR 0 8
30752: PUSH
30753: LD_INT 1
30755: GREATEREQUAL
30756: IFFALSE 30778
// tmp := tmp diff sci [ 1 ] ;
30758: LD_ADDR_VAR 0 4
30762: PUSH
30763: LD_VAR 0 4
30767: PUSH
30768: LD_VAR 0 8
30772: PUSH
30773: LD_INT 1
30775: ARRAY
30776: DIFF
30777: ST_TO_ADDR
// if tmp and not sci then
30778: LD_VAR 0 4
30782: PUSH
30783: LD_VAR 0 8
30787: NOT
30788: AND
30789: IFFALSE 30858
// begin sort := SortBySkill ( tmp , 4 ) ;
30791: LD_ADDR_VAR 0 9
30795: PUSH
30796: LD_VAR 0 4
30800: PPUSH
30801: LD_INT 4
30803: PPUSH
30804: CALL 90027 0 2
30808: ST_TO_ADDR
// if sort then
30809: LD_VAR 0 9
30813: IFFALSE 30829
// p := sort [ 1 ] ;
30815: LD_ADDR_VAR 0 11
30819: PUSH
30820: LD_VAR 0 9
30824: PUSH
30825: LD_INT 1
30827: ARRAY
30828: ST_TO_ADDR
// if p then
30829: LD_VAR 0 11
30833: IFFALSE 30858
// result := Replace ( result , 4 , p ) ;
30835: LD_ADDR_VAR 0 2
30839: PUSH
30840: LD_VAR 0 2
30844: PPUSH
30845: LD_INT 4
30847: PPUSH
30848: LD_VAR 0 11
30852: PPUSH
30853: CALL_OW 1
30857: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30858: LD_ADDR_VAR 0 4
30862: PUSH
30863: LD_VAR 0 4
30867: PUSH
30868: LD_VAR 0 7
30872: DIFF
30873: ST_TO_ADDR
// if tmp and mech < 6 then
30874: LD_VAR 0 4
30878: PUSH
30879: LD_VAR 0 7
30883: PUSH
30884: LD_INT 6
30886: LESS
30887: AND
30888: IFFALSE 31070
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
30890: LD_ADDR_VAR 0 9
30894: PUSH
30895: LD_VAR 0 4
30899: PUSH
30900: LD_VAR 0 7
30904: DIFF
30905: PPUSH
30906: LD_INT 3
30908: PPUSH
30909: CALL 90027 0 2
30913: ST_TO_ADDR
// p := [ ] ;
30914: LD_ADDR_VAR 0 11
30918: PUSH
30919: EMPTY
30920: ST_TO_ADDR
// if sort then
30921: LD_VAR 0 9
30925: IFFALSE 31041
// for i = 1 to 6 - mech do
30927: LD_ADDR_VAR 0 3
30931: PUSH
30932: DOUBLE
30933: LD_INT 1
30935: DEC
30936: ST_TO_ADDR
30937: LD_INT 6
30939: PUSH
30940: LD_VAR 0 7
30944: MINUS
30945: PUSH
30946: FOR_TO
30947: IFFALSE 31039
// begin if i = sort then
30949: LD_VAR 0 3
30953: PUSH
30954: LD_VAR 0 9
30958: EQUAL
30959: IFFALSE 30963
// break ;
30961: GO 31039
// if GetClass ( i ) = 3 then
30963: LD_VAR 0 3
30967: PPUSH
30968: CALL_OW 257
30972: PUSH
30973: LD_INT 3
30975: EQUAL
30976: IFFALSE 30980
// continue ;
30978: GO 30946
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30980: LD_ADDR_VAR 0 11
30984: PUSH
30985: LD_VAR 0 11
30989: PPUSH
30990: LD_VAR 0 11
30994: PUSH
30995: LD_INT 1
30997: PLUS
30998: PPUSH
30999: LD_VAR 0 9
31003: PUSH
31004: LD_VAR 0 3
31008: ARRAY
31009: PPUSH
31010: CALL_OW 2
31014: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31015: LD_ADDR_VAR 0 4
31019: PUSH
31020: LD_VAR 0 4
31024: PUSH
31025: LD_VAR 0 9
31029: PUSH
31030: LD_VAR 0 3
31034: ARRAY
31035: DIFF
31036: ST_TO_ADDR
// end ;
31037: GO 30946
31039: POP
31040: POP
// if p then
31041: LD_VAR 0 11
31045: IFFALSE 31070
// result := Replace ( result , 3 , p ) ;
31047: LD_ADDR_VAR 0 2
31051: PUSH
31052: LD_VAR 0 2
31056: PPUSH
31057: LD_INT 3
31059: PPUSH
31060: LD_VAR 0 11
31064: PPUSH
31065: CALL_OW 1
31069: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
31070: LD_ADDR_VAR 0 4
31074: PUSH
31075: LD_VAR 0 4
31079: PUSH
31080: LD_VAR 0 6
31084: DIFF
31085: ST_TO_ADDR
// if tmp and eng < 4 then
31086: LD_VAR 0 4
31090: PUSH
31091: LD_VAR 0 6
31095: PUSH
31096: LD_INT 4
31098: LESS
31099: AND
31100: IFFALSE 31290
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
31102: LD_ADDR_VAR 0 9
31106: PUSH
31107: LD_VAR 0 4
31111: PUSH
31112: LD_VAR 0 7
31116: PUSH
31117: LD_VAR 0 6
31121: UNION
31122: DIFF
31123: PPUSH
31124: LD_INT 2
31126: PPUSH
31127: CALL 90027 0 2
31131: ST_TO_ADDR
// p := [ ] ;
31132: LD_ADDR_VAR 0 11
31136: PUSH
31137: EMPTY
31138: ST_TO_ADDR
// if sort then
31139: LD_VAR 0 9
31143: IFFALSE 31259
// for i = 1 to 4 - eng do
31145: LD_ADDR_VAR 0 3
31149: PUSH
31150: DOUBLE
31151: LD_INT 1
31153: DEC
31154: ST_TO_ADDR
31155: LD_INT 4
31157: PUSH
31158: LD_VAR 0 6
31162: MINUS
31163: PUSH
31164: FOR_TO
31165: IFFALSE 31257
// begin if i = sort then
31167: LD_VAR 0 3
31171: PUSH
31172: LD_VAR 0 9
31176: EQUAL
31177: IFFALSE 31181
// break ;
31179: GO 31257
// if GetClass ( i ) = 2 then
31181: LD_VAR 0 3
31185: PPUSH
31186: CALL_OW 257
31190: PUSH
31191: LD_INT 2
31193: EQUAL
31194: IFFALSE 31198
// continue ;
31196: GO 31164
// p := Insert ( p , p + 1 , sort [ i ] ) ;
31198: LD_ADDR_VAR 0 11
31202: PUSH
31203: LD_VAR 0 11
31207: PPUSH
31208: LD_VAR 0 11
31212: PUSH
31213: LD_INT 1
31215: PLUS
31216: PPUSH
31217: LD_VAR 0 9
31221: PUSH
31222: LD_VAR 0 3
31226: ARRAY
31227: PPUSH
31228: CALL_OW 2
31232: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31233: LD_ADDR_VAR 0 4
31237: PUSH
31238: LD_VAR 0 4
31242: PUSH
31243: LD_VAR 0 9
31247: PUSH
31248: LD_VAR 0 3
31252: ARRAY
31253: DIFF
31254: ST_TO_ADDR
// end ;
31255: GO 31164
31257: POP
31258: POP
// if p then
31259: LD_VAR 0 11
31263: IFFALSE 31288
// result := Replace ( result , 2 , p ) ;
31265: LD_ADDR_VAR 0 2
31269: PUSH
31270: LD_VAR 0 2
31274: PPUSH
31275: LD_INT 2
31277: PPUSH
31278: LD_VAR 0 11
31282: PPUSH
31283: CALL_OW 1
31287: ST_TO_ADDR
// end else
31288: GO 31334
// for i = eng downto 5 do
31290: LD_ADDR_VAR 0 3
31294: PUSH
31295: DOUBLE
31296: LD_VAR 0 6
31300: INC
31301: ST_TO_ADDR
31302: LD_INT 5
31304: PUSH
31305: FOR_DOWNTO
31306: IFFALSE 31332
// tmp := tmp union eng [ i ] ;
31308: LD_ADDR_VAR 0 4
31312: PUSH
31313: LD_VAR 0 4
31317: PUSH
31318: LD_VAR 0 6
31322: PUSH
31323: LD_VAR 0 3
31327: ARRAY
31328: UNION
31329: ST_TO_ADDR
31330: GO 31305
31332: POP
31333: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
31334: LD_ADDR_VAR 0 2
31338: PUSH
31339: LD_VAR 0 2
31343: PPUSH
31344: LD_INT 1
31346: PPUSH
31347: LD_VAR 0 4
31351: PUSH
31352: LD_VAR 0 5
31356: DIFF
31357: PPUSH
31358: CALL_OW 1
31362: ST_TO_ADDR
// exit ;
31363: GO 31365
// end ; end ;
31365: LD_VAR 0 2
31369: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
31370: LD_INT 0
31372: PPUSH
31373: PPUSH
31374: PPUSH
// if not mc_bases then
31375: LD_EXP 80
31379: NOT
31380: IFFALSE 31384
// exit ;
31382: GO 31526
// for i = 1 to mc_bases do
31384: LD_ADDR_VAR 0 2
31388: PUSH
31389: DOUBLE
31390: LD_INT 1
31392: DEC
31393: ST_TO_ADDR
31394: LD_EXP 80
31398: PUSH
31399: FOR_TO
31400: IFFALSE 31517
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
31402: LD_ADDR_VAR 0 3
31406: PUSH
31407: LD_EXP 80
31411: PUSH
31412: LD_VAR 0 2
31416: ARRAY
31417: PPUSH
31418: LD_INT 21
31420: PUSH
31421: LD_INT 3
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 3
31430: PUSH
31431: LD_INT 2
31433: PUSH
31434: LD_INT 30
31436: PUSH
31437: LD_INT 29
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: PUSH
31444: LD_INT 30
31446: PUSH
31447: LD_INT 30
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: LIST
31458: PUSH
31459: EMPTY
31460: LIST
31461: LIST
31462: PUSH
31463: LD_INT 3
31465: PUSH
31466: LD_INT 24
31468: PUSH
31469: LD_INT 1000
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: LIST
31484: PPUSH
31485: CALL_OW 72
31489: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
31490: LD_ADDR_EXP 81
31494: PUSH
31495: LD_EXP 81
31499: PPUSH
31500: LD_VAR 0 2
31504: PPUSH
31505: LD_VAR 0 3
31509: PPUSH
31510: CALL_OW 1
31514: ST_TO_ADDR
// end ;
31515: GO 31399
31517: POP
31518: POP
// RaiseSailEvent ( 101 ) ;
31519: LD_INT 101
31521: PPUSH
31522: CALL_OW 427
// end ;
31526: LD_VAR 0 1
31530: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
31531: LD_INT 0
31533: PPUSH
31534: PPUSH
31535: PPUSH
31536: PPUSH
31537: PPUSH
31538: PPUSH
31539: PPUSH
// if not mc_bases then
31540: LD_EXP 80
31544: NOT
31545: IFFALSE 31549
// exit ;
31547: GO 32111
// for i = 1 to mc_bases do
31549: LD_ADDR_VAR 0 2
31553: PUSH
31554: DOUBLE
31555: LD_INT 1
31557: DEC
31558: ST_TO_ADDR
31559: LD_EXP 80
31563: PUSH
31564: FOR_TO
31565: IFFALSE 32102
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
31567: LD_ADDR_VAR 0 5
31571: PUSH
31572: LD_EXP 80
31576: PUSH
31577: LD_VAR 0 2
31581: ARRAY
31582: PUSH
31583: LD_EXP 109
31587: PUSH
31588: LD_VAR 0 2
31592: ARRAY
31593: UNION
31594: PPUSH
31595: LD_INT 21
31597: PUSH
31598: LD_INT 1
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: PUSH
31605: LD_INT 1
31607: PUSH
31608: LD_INT 3
31610: PUSH
31611: LD_INT 54
31613: PUSH
31614: EMPTY
31615: LIST
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: LD_INT 3
31623: PUSH
31624: LD_INT 24
31626: PUSH
31627: LD_INT 1000
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: LIST
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PPUSH
31647: CALL_OW 72
31651: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
31652: LD_ADDR_VAR 0 6
31656: PUSH
31657: LD_EXP 80
31661: PUSH
31662: LD_VAR 0 2
31666: ARRAY
31667: PPUSH
31668: LD_INT 21
31670: PUSH
31671: LD_INT 1
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: PUSH
31678: LD_INT 1
31680: PUSH
31681: LD_INT 3
31683: PUSH
31684: LD_INT 54
31686: PUSH
31687: EMPTY
31688: LIST
31689: PUSH
31690: EMPTY
31691: LIST
31692: LIST
31693: PUSH
31694: LD_INT 3
31696: PUSH
31697: LD_INT 24
31699: PUSH
31700: LD_INT 250
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: LIST
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PPUSH
31720: CALL_OW 72
31724: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
31725: LD_ADDR_VAR 0 7
31729: PUSH
31730: LD_VAR 0 5
31734: PUSH
31735: LD_VAR 0 6
31739: DIFF
31740: ST_TO_ADDR
// if not need_heal_1 then
31741: LD_VAR 0 6
31745: NOT
31746: IFFALSE 31779
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
31748: LD_ADDR_EXP 83
31752: PUSH
31753: LD_EXP 83
31757: PPUSH
31758: LD_VAR 0 2
31762: PUSH
31763: LD_INT 1
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: PPUSH
31770: EMPTY
31771: PPUSH
31772: CALL 58774 0 3
31776: ST_TO_ADDR
31777: GO 31849
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
31779: LD_ADDR_EXP 83
31783: PUSH
31784: LD_EXP 83
31788: PPUSH
31789: LD_VAR 0 2
31793: PUSH
31794: LD_INT 1
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PPUSH
31801: LD_EXP 83
31805: PUSH
31806: LD_VAR 0 2
31810: ARRAY
31811: PUSH
31812: LD_INT 1
31814: ARRAY
31815: PPUSH
31816: LD_INT 3
31818: PUSH
31819: LD_INT 24
31821: PUSH
31822: LD_INT 1000
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: PPUSH
31833: CALL_OW 72
31837: PUSH
31838: LD_VAR 0 6
31842: UNION
31843: PPUSH
31844: CALL 58774 0 3
31848: ST_TO_ADDR
// if not need_heal_2 then
31849: LD_VAR 0 7
31853: NOT
31854: IFFALSE 31887
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
31856: LD_ADDR_EXP 83
31860: PUSH
31861: LD_EXP 83
31865: PPUSH
31866: LD_VAR 0 2
31870: PUSH
31871: LD_INT 2
31873: PUSH
31874: EMPTY
31875: LIST
31876: LIST
31877: PPUSH
31878: EMPTY
31879: PPUSH
31880: CALL 58774 0 3
31884: ST_TO_ADDR
31885: GO 31919
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
31887: LD_ADDR_EXP 83
31891: PUSH
31892: LD_EXP 83
31896: PPUSH
31897: LD_VAR 0 2
31901: PUSH
31902: LD_INT 2
31904: PUSH
31905: EMPTY
31906: LIST
31907: LIST
31908: PPUSH
31909: LD_VAR 0 7
31913: PPUSH
31914: CALL 58774 0 3
31918: ST_TO_ADDR
// if need_heal_2 then
31919: LD_VAR 0 7
31923: IFFALSE 32084
// for j in need_heal_2 do
31925: LD_ADDR_VAR 0 3
31929: PUSH
31930: LD_VAR 0 7
31934: PUSH
31935: FOR_IN
31936: IFFALSE 32082
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31938: LD_ADDR_VAR 0 5
31942: PUSH
31943: LD_EXP 80
31947: PUSH
31948: LD_VAR 0 2
31952: ARRAY
31953: PPUSH
31954: LD_INT 2
31956: PUSH
31957: LD_INT 30
31959: PUSH
31960: LD_INT 6
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 30
31969: PUSH
31970: LD_INT 7
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: PUSH
31977: LD_INT 30
31979: PUSH
31980: LD_INT 8
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 30
31989: PUSH
31990: LD_INT 0
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: LD_INT 30
31999: PUSH
32000: LD_INT 1
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: PUSH
32007: EMPTY
32008: LIST
32009: LIST
32010: LIST
32011: LIST
32012: LIST
32013: LIST
32014: PPUSH
32015: CALL_OW 72
32019: ST_TO_ADDR
// if tmp then
32020: LD_VAR 0 5
32024: IFFALSE 32080
// begin k := NearestUnitToUnit ( tmp , j ) ;
32026: LD_ADDR_VAR 0 4
32030: PUSH
32031: LD_VAR 0 5
32035: PPUSH
32036: LD_VAR 0 3
32040: PPUSH
32041: CALL_OW 74
32045: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
32046: LD_VAR 0 3
32050: PPUSH
32051: LD_VAR 0 4
32055: PPUSH
32056: CALL_OW 296
32060: PUSH
32061: LD_INT 5
32063: GREATER
32064: IFFALSE 32080
// ComMoveToNearbyEntrance ( j , k ) ;
32066: LD_VAR 0 3
32070: PPUSH
32071: LD_VAR 0 4
32075: PPUSH
32076: CALL 92400 0 2
// end ; end ;
32080: GO 31935
32082: POP
32083: POP
// if not need_heal_1 and not need_heal_2 then
32084: LD_VAR 0 6
32088: NOT
32089: PUSH
32090: LD_VAR 0 7
32094: NOT
32095: AND
32096: IFFALSE 32100
// continue ;
32098: GO 31564
// end ;
32100: GO 31564
32102: POP
32103: POP
// RaiseSailEvent ( 102 ) ;
32104: LD_INT 102
32106: PPUSH
32107: CALL_OW 427
// end ;
32111: LD_VAR 0 1
32115: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
32116: LD_INT 0
32118: PPUSH
32119: PPUSH
32120: PPUSH
32121: PPUSH
32122: PPUSH
32123: PPUSH
32124: PPUSH
32125: PPUSH
// if not mc_bases then
32126: LD_EXP 80
32130: NOT
32131: IFFALSE 32135
// exit ;
32133: GO 33046
// for i = 1 to mc_bases do
32135: LD_ADDR_VAR 0 2
32139: PUSH
32140: DOUBLE
32141: LD_INT 1
32143: DEC
32144: ST_TO_ADDR
32145: LD_EXP 80
32149: PUSH
32150: FOR_TO
32151: IFFALSE 33044
// begin if not mc_building_need_repair [ i ] then
32153: LD_EXP 81
32157: PUSH
32158: LD_VAR 0 2
32162: ARRAY
32163: NOT
32164: IFFALSE 32349
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
32166: LD_ADDR_VAR 0 6
32170: PUSH
32171: LD_EXP 99
32175: PUSH
32176: LD_VAR 0 2
32180: ARRAY
32181: PPUSH
32182: LD_INT 3
32184: PUSH
32185: LD_INT 24
32187: PUSH
32188: LD_INT 1000
32190: PUSH
32191: EMPTY
32192: LIST
32193: LIST
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: LD_INT 2
32201: PUSH
32202: LD_INT 34
32204: PUSH
32205: LD_INT 13
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 34
32214: PUSH
32215: LD_INT 52
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 34
32224: PUSH
32225: LD_INT 88
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: LIST
32236: LIST
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PPUSH
32242: CALL_OW 72
32246: ST_TO_ADDR
// if cranes then
32247: LD_VAR 0 6
32251: IFFALSE 32313
// for j in cranes do
32253: LD_ADDR_VAR 0 3
32257: PUSH
32258: LD_VAR 0 6
32262: PUSH
32263: FOR_IN
32264: IFFALSE 32311
// if not IsInArea ( j , mc_parking [ i ] ) then
32266: LD_VAR 0 3
32270: PPUSH
32271: LD_EXP 104
32275: PUSH
32276: LD_VAR 0 2
32280: ARRAY
32281: PPUSH
32282: CALL_OW 308
32286: NOT
32287: IFFALSE 32309
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32289: LD_VAR 0 3
32293: PPUSH
32294: LD_EXP 104
32298: PUSH
32299: LD_VAR 0 2
32303: ARRAY
32304: PPUSH
32305: CALL_OW 113
32309: GO 32263
32311: POP
32312: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
32313: LD_ADDR_EXP 82
32317: PUSH
32318: LD_EXP 82
32322: PPUSH
32323: LD_VAR 0 2
32327: PPUSH
32328: EMPTY
32329: PPUSH
32330: CALL_OW 1
32334: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
32335: LD_VAR 0 2
32339: PPUSH
32340: LD_INT 101
32342: PPUSH
32343: CALL 27189 0 2
// continue ;
32347: GO 32150
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
32349: LD_ADDR_EXP 86
32353: PUSH
32354: LD_EXP 86
32358: PPUSH
32359: LD_VAR 0 2
32363: PPUSH
32364: EMPTY
32365: PPUSH
32366: CALL_OW 1
32370: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32371: LD_VAR 0 2
32375: PPUSH
32376: LD_INT 103
32378: PPUSH
32379: CALL 27189 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
32383: LD_ADDR_VAR 0 5
32387: PUSH
32388: LD_EXP 80
32392: PUSH
32393: LD_VAR 0 2
32397: ARRAY
32398: PUSH
32399: LD_EXP 109
32403: PUSH
32404: LD_VAR 0 2
32408: ARRAY
32409: UNION
32410: PPUSH
32411: LD_INT 2
32413: PUSH
32414: LD_INT 25
32416: PUSH
32417: LD_INT 2
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 25
32426: PUSH
32427: LD_INT 16
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: LIST
32438: PUSH
32439: EMPTY
32440: LIST
32441: PPUSH
32442: CALL_OW 72
32446: ST_TO_ADDR
// if mc_need_heal [ i ] then
32447: LD_EXP 83
32451: PUSH
32452: LD_VAR 0 2
32456: ARRAY
32457: IFFALSE 32501
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
32459: LD_ADDR_VAR 0 5
32463: PUSH
32464: LD_VAR 0 5
32468: PUSH
32469: LD_EXP 83
32473: PUSH
32474: LD_VAR 0 2
32478: ARRAY
32479: PUSH
32480: LD_INT 1
32482: ARRAY
32483: PUSH
32484: LD_EXP 83
32488: PUSH
32489: LD_VAR 0 2
32493: ARRAY
32494: PUSH
32495: LD_INT 2
32497: ARRAY
32498: UNION
32499: DIFF
32500: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
32501: LD_ADDR_VAR 0 6
32505: PUSH
32506: LD_EXP 99
32510: PUSH
32511: LD_VAR 0 2
32515: ARRAY
32516: PPUSH
32517: LD_INT 2
32519: PUSH
32520: LD_INT 34
32522: PUSH
32523: LD_INT 13
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 34
32532: PUSH
32533: LD_INT 52
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 34
32542: PUSH
32543: LD_INT 88
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: LIST
32554: LIST
32555: PPUSH
32556: CALL_OW 72
32560: ST_TO_ADDR
// if cranes then
32561: LD_VAR 0 6
32565: IFFALSE 32733
// begin for j in cranes do
32567: LD_ADDR_VAR 0 3
32571: PUSH
32572: LD_VAR 0 6
32576: PUSH
32577: FOR_IN
32578: IFFALSE 32731
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
32580: LD_VAR 0 3
32584: PPUSH
32585: CALL_OW 256
32589: PUSH
32590: LD_INT 1000
32592: EQUAL
32593: PUSH
32594: LD_VAR 0 3
32598: PPUSH
32599: CALL_OW 314
32603: NOT
32604: AND
32605: IFFALSE 32671
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
32607: LD_ADDR_VAR 0 8
32611: PUSH
32612: LD_EXP 81
32616: PUSH
32617: LD_VAR 0 2
32621: ARRAY
32622: PPUSH
32623: LD_VAR 0 3
32627: PPUSH
32628: CALL_OW 74
32632: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
32633: LD_VAR 0 8
32637: PPUSH
32638: LD_INT 16
32640: PPUSH
32641: CALL 61739 0 2
32645: PUSH
32646: LD_INT 4
32648: ARRAY
32649: PUSH
32650: LD_INT 10
32652: LESS
32653: IFFALSE 32669
// ComRepairBuilding ( j , to_repair ) ;
32655: LD_VAR 0 3
32659: PPUSH
32660: LD_VAR 0 8
32664: PPUSH
32665: CALL_OW 130
// end else
32669: GO 32729
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
32671: LD_VAR 0 3
32675: PPUSH
32676: CALL_OW 256
32680: PUSH
32681: LD_INT 500
32683: LESS
32684: PUSH
32685: LD_VAR 0 3
32689: PPUSH
32690: LD_EXP 104
32694: PUSH
32695: LD_VAR 0 2
32699: ARRAY
32700: PPUSH
32701: CALL_OW 308
32705: NOT
32706: AND
32707: IFFALSE 32729
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32709: LD_VAR 0 3
32713: PPUSH
32714: LD_EXP 104
32718: PUSH
32719: LD_VAR 0 2
32723: ARRAY
32724: PPUSH
32725: CALL_OW 113
// end ;
32729: GO 32577
32731: POP
32732: POP
// end ; if tmp > 3 then
32733: LD_VAR 0 5
32737: PUSH
32738: LD_INT 3
32740: GREATER
32741: IFFALSE 32761
// tmp := ShrinkArray ( tmp , 4 ) ;
32743: LD_ADDR_VAR 0 5
32747: PUSH
32748: LD_VAR 0 5
32752: PPUSH
32753: LD_INT 4
32755: PPUSH
32756: CALL 91838 0 2
32760: ST_TO_ADDR
// if not tmp then
32761: LD_VAR 0 5
32765: NOT
32766: IFFALSE 32770
// continue ;
32768: GO 32150
// for j in tmp do
32770: LD_ADDR_VAR 0 3
32774: PUSH
32775: LD_VAR 0 5
32779: PUSH
32780: FOR_IN
32781: IFFALSE 33040
// begin if IsInUnit ( j ) then
32783: LD_VAR 0 3
32787: PPUSH
32788: CALL_OW 310
32792: IFFALSE 32803
// ComExitBuilding ( j ) ;
32794: LD_VAR 0 3
32798: PPUSH
32799: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
32803: LD_VAR 0 3
32807: PUSH
32808: LD_EXP 82
32812: PUSH
32813: LD_VAR 0 2
32817: ARRAY
32818: IN
32819: NOT
32820: IFFALSE 32878
// begin SetTag ( j , 101 ) ;
32822: LD_VAR 0 3
32826: PPUSH
32827: LD_INT 101
32829: PPUSH
32830: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
32834: LD_ADDR_EXP 82
32838: PUSH
32839: LD_EXP 82
32843: PPUSH
32844: LD_VAR 0 2
32848: PUSH
32849: LD_EXP 82
32853: PUSH
32854: LD_VAR 0 2
32858: ARRAY
32859: PUSH
32860: LD_INT 1
32862: PLUS
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PPUSH
32868: LD_VAR 0 3
32872: PPUSH
32873: CALL 58774 0 3
32877: ST_TO_ADDR
// end ; wait ( 1 ) ;
32878: LD_INT 1
32880: PPUSH
32881: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
32885: LD_ADDR_VAR 0 7
32889: PUSH
32890: LD_EXP 81
32894: PUSH
32895: LD_VAR 0 2
32899: ARRAY
32900: ST_TO_ADDR
// if mc_scan [ i ] then
32901: LD_EXP 103
32905: PUSH
32906: LD_VAR 0 2
32910: ARRAY
32911: IFFALSE 32973
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
32913: LD_ADDR_VAR 0 7
32917: PUSH
32918: LD_EXP 81
32922: PUSH
32923: LD_VAR 0 2
32927: ARRAY
32928: PPUSH
32929: LD_INT 3
32931: PUSH
32932: LD_INT 30
32934: PUSH
32935: LD_INT 32
32937: PUSH
32938: EMPTY
32939: LIST
32940: LIST
32941: PUSH
32942: LD_INT 30
32944: PUSH
32945: LD_INT 33
32947: PUSH
32948: EMPTY
32949: LIST
32950: LIST
32951: PUSH
32952: LD_INT 30
32954: PUSH
32955: LD_INT 31
32957: PUSH
32958: EMPTY
32959: LIST
32960: LIST
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: LIST
32966: LIST
32967: PPUSH
32968: CALL_OW 72
32972: ST_TO_ADDR
// if not to_repair_tmp then
32973: LD_VAR 0 7
32977: NOT
32978: IFFALSE 32982
// continue ;
32980: GO 32780
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
32982: LD_ADDR_VAR 0 8
32986: PUSH
32987: LD_VAR 0 7
32991: PPUSH
32992: LD_VAR 0 3
32996: PPUSH
32997: CALL_OW 74
33001: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
33002: LD_VAR 0 8
33006: PPUSH
33007: LD_INT 16
33009: PPUSH
33010: CALL 61739 0 2
33014: PUSH
33015: LD_INT 4
33017: ARRAY
33018: PUSH
33019: LD_INT 14
33021: LESS
33022: IFFALSE 33038
// ComRepairBuilding ( j , to_repair ) ;
33024: LD_VAR 0 3
33028: PPUSH
33029: LD_VAR 0 8
33033: PPUSH
33034: CALL_OW 130
// end ;
33038: GO 32780
33040: POP
33041: POP
// end ;
33042: GO 32150
33044: POP
33045: POP
// end ;
33046: LD_VAR 0 1
33050: RET
// export function MC_Heal ; var i , j , tmp ; begin
33051: LD_INT 0
33053: PPUSH
33054: PPUSH
33055: PPUSH
33056: PPUSH
// if not mc_bases then
33057: LD_EXP 80
33061: NOT
33062: IFFALSE 33066
// exit ;
33064: GO 33468
// for i = 1 to mc_bases do
33066: LD_ADDR_VAR 0 2
33070: PUSH
33071: DOUBLE
33072: LD_INT 1
33074: DEC
33075: ST_TO_ADDR
33076: LD_EXP 80
33080: PUSH
33081: FOR_TO
33082: IFFALSE 33466
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
33084: LD_EXP 83
33088: PUSH
33089: LD_VAR 0 2
33093: ARRAY
33094: PUSH
33095: LD_INT 1
33097: ARRAY
33098: NOT
33099: PUSH
33100: LD_EXP 83
33104: PUSH
33105: LD_VAR 0 2
33109: ARRAY
33110: PUSH
33111: LD_INT 2
33113: ARRAY
33114: NOT
33115: AND
33116: IFFALSE 33154
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
33118: LD_ADDR_EXP 84
33122: PUSH
33123: LD_EXP 84
33127: PPUSH
33128: LD_VAR 0 2
33132: PPUSH
33133: EMPTY
33134: PPUSH
33135: CALL_OW 1
33139: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
33140: LD_VAR 0 2
33144: PPUSH
33145: LD_INT 102
33147: PPUSH
33148: CALL 27189 0 2
// continue ;
33152: GO 33081
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
33154: LD_ADDR_VAR 0 4
33158: PUSH
33159: LD_EXP 80
33163: PUSH
33164: LD_VAR 0 2
33168: ARRAY
33169: PPUSH
33170: LD_INT 25
33172: PUSH
33173: LD_INT 4
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PPUSH
33180: CALL_OW 72
33184: ST_TO_ADDR
// if not tmp then
33185: LD_VAR 0 4
33189: NOT
33190: IFFALSE 33194
// continue ;
33192: GO 33081
// if mc_taming [ i ] then
33194: LD_EXP 111
33198: PUSH
33199: LD_VAR 0 2
33203: ARRAY
33204: IFFALSE 33228
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
33206: LD_ADDR_EXP 111
33210: PUSH
33211: LD_EXP 111
33215: PPUSH
33216: LD_VAR 0 2
33220: PPUSH
33221: EMPTY
33222: PPUSH
33223: CALL_OW 1
33227: ST_TO_ADDR
// for j in tmp do
33228: LD_ADDR_VAR 0 3
33232: PUSH
33233: LD_VAR 0 4
33237: PUSH
33238: FOR_IN
33239: IFFALSE 33462
// begin if IsInUnit ( j ) then
33241: LD_VAR 0 3
33245: PPUSH
33246: CALL_OW 310
33250: IFFALSE 33261
// ComExitBuilding ( j ) ;
33252: LD_VAR 0 3
33256: PPUSH
33257: CALL_OW 122
// if not j in mc_healers [ i ] then
33261: LD_VAR 0 3
33265: PUSH
33266: LD_EXP 84
33270: PUSH
33271: LD_VAR 0 2
33275: ARRAY
33276: IN
33277: NOT
33278: IFFALSE 33324
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
33280: LD_ADDR_EXP 84
33284: PUSH
33285: LD_EXP 84
33289: PPUSH
33290: LD_VAR 0 2
33294: PUSH
33295: LD_EXP 84
33299: PUSH
33300: LD_VAR 0 2
33304: ARRAY
33305: PUSH
33306: LD_INT 1
33308: PLUS
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PPUSH
33314: LD_VAR 0 3
33318: PPUSH
33319: CALL 58774 0 3
33323: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
33324: LD_VAR 0 3
33328: PPUSH
33329: CALL_OW 110
33333: PUSH
33334: LD_INT 102
33336: NONEQUAL
33337: IFFALSE 33351
// SetTag ( j , 102 ) ;
33339: LD_VAR 0 3
33343: PPUSH
33344: LD_INT 102
33346: PPUSH
33347: CALL_OW 109
// Wait ( 3 ) ;
33351: LD_INT 3
33353: PPUSH
33354: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
33358: LD_EXP 83
33362: PUSH
33363: LD_VAR 0 2
33367: ARRAY
33368: PUSH
33369: LD_INT 1
33371: ARRAY
33372: IFFALSE 33404
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
33374: LD_VAR 0 3
33378: PPUSH
33379: LD_EXP 83
33383: PUSH
33384: LD_VAR 0 2
33388: ARRAY
33389: PUSH
33390: LD_INT 1
33392: ARRAY
33393: PUSH
33394: LD_INT 1
33396: ARRAY
33397: PPUSH
33398: CALL_OW 128
33402: GO 33460
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
33404: LD_VAR 0 3
33408: PPUSH
33409: CALL_OW 314
33413: NOT
33414: PUSH
33415: LD_EXP 83
33419: PUSH
33420: LD_VAR 0 2
33424: ARRAY
33425: PUSH
33426: LD_INT 2
33428: ARRAY
33429: AND
33430: IFFALSE 33460
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
33432: LD_VAR 0 3
33436: PPUSH
33437: LD_EXP 83
33441: PUSH
33442: LD_VAR 0 2
33446: ARRAY
33447: PUSH
33448: LD_INT 2
33450: ARRAY
33451: PUSH
33452: LD_INT 1
33454: ARRAY
33455: PPUSH
33456: CALL_OW 128
// end ;
33460: GO 33238
33462: POP
33463: POP
// end ;
33464: GO 33081
33466: POP
33467: POP
// end ;
33468: LD_VAR 0 1
33472: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
33473: LD_INT 0
33475: PPUSH
33476: PPUSH
33477: PPUSH
33478: PPUSH
33479: PPUSH
33480: PPUSH
// if not mc_bases then
33481: LD_EXP 80
33485: NOT
33486: IFFALSE 33490
// exit ;
33488: GO 34653
// for i = 1 to mc_bases do
33490: LD_ADDR_VAR 0 2
33494: PUSH
33495: DOUBLE
33496: LD_INT 1
33498: DEC
33499: ST_TO_ADDR
33500: LD_EXP 80
33504: PUSH
33505: FOR_TO
33506: IFFALSE 34651
// begin if mc_scan [ i ] then
33508: LD_EXP 103
33512: PUSH
33513: LD_VAR 0 2
33517: ARRAY
33518: IFFALSE 33522
// continue ;
33520: GO 33505
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
33522: LD_EXP 85
33526: PUSH
33527: LD_VAR 0 2
33531: ARRAY
33532: NOT
33533: PUSH
33534: LD_EXP 87
33538: PUSH
33539: LD_VAR 0 2
33543: ARRAY
33544: NOT
33545: AND
33546: PUSH
33547: LD_EXP 86
33551: PUSH
33552: LD_VAR 0 2
33556: ARRAY
33557: AND
33558: IFFALSE 33596
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
33560: LD_ADDR_EXP 86
33564: PUSH
33565: LD_EXP 86
33569: PPUSH
33570: LD_VAR 0 2
33574: PPUSH
33575: EMPTY
33576: PPUSH
33577: CALL_OW 1
33581: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
33582: LD_VAR 0 2
33586: PPUSH
33587: LD_INT 103
33589: PPUSH
33590: CALL 27189 0 2
// continue ;
33594: GO 33505
// end ; if mc_construct_list [ i ] then
33596: LD_EXP 87
33600: PUSH
33601: LD_VAR 0 2
33605: ARRAY
33606: IFFALSE 33826
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33608: LD_ADDR_VAR 0 5
33612: PUSH
33613: LD_EXP 80
33617: PUSH
33618: LD_VAR 0 2
33622: ARRAY
33623: PPUSH
33624: LD_INT 25
33626: PUSH
33627: LD_INT 2
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PPUSH
33634: CALL_OW 72
33638: PUSH
33639: LD_EXP 82
33643: PUSH
33644: LD_VAR 0 2
33648: ARRAY
33649: DIFF
33650: ST_TO_ADDR
// if not tmp then
33651: LD_VAR 0 5
33655: NOT
33656: IFFALSE 33660
// continue ;
33658: GO 33505
// for j in tmp do
33660: LD_ADDR_VAR 0 3
33664: PUSH
33665: LD_VAR 0 5
33669: PUSH
33670: FOR_IN
33671: IFFALSE 33822
// begin if not mc_builders [ i ] then
33673: LD_EXP 86
33677: PUSH
33678: LD_VAR 0 2
33682: ARRAY
33683: NOT
33684: IFFALSE 33742
// begin SetTag ( j , 103 ) ;
33686: LD_VAR 0 3
33690: PPUSH
33691: LD_INT 103
33693: PPUSH
33694: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33698: LD_ADDR_EXP 86
33702: PUSH
33703: LD_EXP 86
33707: PPUSH
33708: LD_VAR 0 2
33712: PUSH
33713: LD_EXP 86
33717: PUSH
33718: LD_VAR 0 2
33722: ARRAY
33723: PUSH
33724: LD_INT 1
33726: PLUS
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PPUSH
33732: LD_VAR 0 3
33736: PPUSH
33737: CALL 58774 0 3
33741: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33742: LD_VAR 0 3
33746: PPUSH
33747: CALL_OW 310
33751: IFFALSE 33762
// ComExitBuilding ( j ) ;
33753: LD_VAR 0 3
33757: PPUSH
33758: CALL_OW 122
// wait ( 3 ) ;
33762: LD_INT 3
33764: PPUSH
33765: CALL_OW 67
// if not mc_construct_list [ i ] then
33769: LD_EXP 87
33773: PUSH
33774: LD_VAR 0 2
33778: ARRAY
33779: NOT
33780: IFFALSE 33784
// break ;
33782: GO 33822
// if not HasTask ( j ) then
33784: LD_VAR 0 3
33788: PPUSH
33789: CALL_OW 314
33793: NOT
33794: IFFALSE 33820
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
33796: LD_VAR 0 3
33800: PPUSH
33801: LD_EXP 87
33805: PUSH
33806: LD_VAR 0 2
33810: ARRAY
33811: PUSH
33812: LD_INT 1
33814: ARRAY
33815: PPUSH
33816: CALL 62012 0 2
// end ;
33820: GO 33670
33822: POP
33823: POP
// end else
33824: GO 34649
// if mc_build_list [ i ] then
33826: LD_EXP 85
33830: PUSH
33831: LD_VAR 0 2
33835: ARRAY
33836: IFFALSE 34649
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
33838: LD_EXP 85
33842: PUSH
33843: LD_VAR 0 2
33847: ARRAY
33848: PUSH
33849: LD_INT 1
33851: ARRAY
33852: PUSH
33853: LD_INT 1
33855: ARRAY
33856: PPUSH
33857: CALL 61836 0 1
33861: PUSH
33862: LD_EXP 80
33866: PUSH
33867: LD_VAR 0 2
33871: ARRAY
33872: PPUSH
33873: LD_INT 2
33875: PUSH
33876: LD_INT 30
33878: PUSH
33879: LD_INT 2
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: LD_INT 30
33888: PUSH
33889: LD_INT 3
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: LIST
33900: PPUSH
33901: CALL_OW 72
33905: NOT
33906: AND
33907: IFFALSE 34012
// begin for j = 1 to mc_build_list [ i ] do
33909: LD_ADDR_VAR 0 3
33913: PUSH
33914: DOUBLE
33915: LD_INT 1
33917: DEC
33918: ST_TO_ADDR
33919: LD_EXP 85
33923: PUSH
33924: LD_VAR 0 2
33928: ARRAY
33929: PUSH
33930: FOR_TO
33931: IFFALSE 34010
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
33933: LD_EXP 85
33937: PUSH
33938: LD_VAR 0 2
33942: ARRAY
33943: PUSH
33944: LD_VAR 0 3
33948: ARRAY
33949: PUSH
33950: LD_INT 1
33952: ARRAY
33953: PUSH
33954: LD_INT 2
33956: EQUAL
33957: IFFALSE 34008
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
33959: LD_ADDR_EXP 85
33963: PUSH
33964: LD_EXP 85
33968: PPUSH
33969: LD_VAR 0 2
33973: PPUSH
33974: LD_EXP 85
33978: PUSH
33979: LD_VAR 0 2
33983: ARRAY
33984: PPUSH
33985: LD_VAR 0 3
33989: PPUSH
33990: LD_INT 1
33992: PPUSH
33993: LD_INT 0
33995: PPUSH
33996: CALL 58192 0 4
34000: PPUSH
34001: CALL_OW 1
34005: ST_TO_ADDR
// break ;
34006: GO 34010
// end ;
34008: GO 33930
34010: POP
34011: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34012: LD_ADDR_VAR 0 6
34016: PUSH
34017: LD_EXP 80
34021: PUSH
34022: LD_VAR 0 2
34026: ARRAY
34027: PPUSH
34028: LD_INT 2
34030: PUSH
34031: LD_INT 30
34033: PUSH
34034: LD_INT 0
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 30
34043: PUSH
34044: LD_INT 1
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: LIST
34055: PPUSH
34056: CALL_OW 72
34060: ST_TO_ADDR
// for k := 1 to depot do
34061: LD_ADDR_VAR 0 4
34065: PUSH
34066: DOUBLE
34067: LD_INT 1
34069: DEC
34070: ST_TO_ADDR
34071: LD_VAR 0 6
34075: PUSH
34076: FOR_TO
34077: IFFALSE 34647
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
34079: LD_EXP 85
34083: PUSH
34084: LD_VAR 0 2
34088: ARRAY
34089: PUSH
34090: LD_INT 1
34092: ARRAY
34093: PUSH
34094: LD_INT 1
34096: ARRAY
34097: PUSH
34098: LD_INT 0
34100: EQUAL
34101: PUSH
34102: LD_VAR 0 6
34106: PUSH
34107: LD_VAR 0 4
34111: ARRAY
34112: PPUSH
34113: LD_EXP 85
34117: PUSH
34118: LD_VAR 0 2
34122: ARRAY
34123: PUSH
34124: LD_INT 1
34126: ARRAY
34127: PUSH
34128: LD_INT 1
34130: ARRAY
34131: PPUSH
34132: LD_EXP 85
34136: PUSH
34137: LD_VAR 0 2
34141: ARRAY
34142: PUSH
34143: LD_INT 1
34145: ARRAY
34146: PUSH
34147: LD_INT 2
34149: ARRAY
34150: PPUSH
34151: LD_EXP 85
34155: PUSH
34156: LD_VAR 0 2
34160: ARRAY
34161: PUSH
34162: LD_INT 1
34164: ARRAY
34165: PUSH
34166: LD_INT 3
34168: ARRAY
34169: PPUSH
34170: LD_EXP 85
34174: PUSH
34175: LD_VAR 0 2
34179: ARRAY
34180: PUSH
34181: LD_INT 1
34183: ARRAY
34184: PUSH
34185: LD_INT 4
34187: ARRAY
34188: PPUSH
34189: CALL 67248 0 5
34193: OR
34194: IFFALSE 34475
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
34196: LD_ADDR_VAR 0 5
34200: PUSH
34201: LD_EXP 80
34205: PUSH
34206: LD_VAR 0 2
34210: ARRAY
34211: PPUSH
34212: LD_INT 25
34214: PUSH
34215: LD_INT 2
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: PPUSH
34222: CALL_OW 72
34226: PUSH
34227: LD_EXP 82
34231: PUSH
34232: LD_VAR 0 2
34236: ARRAY
34237: DIFF
34238: ST_TO_ADDR
// if not tmp then
34239: LD_VAR 0 5
34243: NOT
34244: IFFALSE 34248
// continue ;
34246: GO 34076
// for j in tmp do
34248: LD_ADDR_VAR 0 3
34252: PUSH
34253: LD_VAR 0 5
34257: PUSH
34258: FOR_IN
34259: IFFALSE 34471
// begin if not mc_builders [ i ] then
34261: LD_EXP 86
34265: PUSH
34266: LD_VAR 0 2
34270: ARRAY
34271: NOT
34272: IFFALSE 34330
// begin SetTag ( j , 103 ) ;
34274: LD_VAR 0 3
34278: PPUSH
34279: LD_INT 103
34281: PPUSH
34282: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
34286: LD_ADDR_EXP 86
34290: PUSH
34291: LD_EXP 86
34295: PPUSH
34296: LD_VAR 0 2
34300: PUSH
34301: LD_EXP 86
34305: PUSH
34306: LD_VAR 0 2
34310: ARRAY
34311: PUSH
34312: LD_INT 1
34314: PLUS
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PPUSH
34320: LD_VAR 0 3
34324: PPUSH
34325: CALL 58774 0 3
34329: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
34330: LD_VAR 0 3
34334: PPUSH
34335: CALL_OW 310
34339: IFFALSE 34350
// ComExitBuilding ( j ) ;
34341: LD_VAR 0 3
34345: PPUSH
34346: CALL_OW 122
// wait ( 3 ) ;
34350: LD_INT 3
34352: PPUSH
34353: CALL_OW 67
// if not mc_build_list [ i ] then
34357: LD_EXP 85
34361: PUSH
34362: LD_VAR 0 2
34366: ARRAY
34367: NOT
34368: IFFALSE 34372
// break ;
34370: GO 34471
// if not HasTask ( j ) then
34372: LD_VAR 0 3
34376: PPUSH
34377: CALL_OW 314
34381: NOT
34382: IFFALSE 34469
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
34384: LD_VAR 0 3
34388: PPUSH
34389: LD_EXP 85
34393: PUSH
34394: LD_VAR 0 2
34398: ARRAY
34399: PUSH
34400: LD_INT 1
34402: ARRAY
34403: PUSH
34404: LD_INT 1
34406: ARRAY
34407: PPUSH
34408: LD_EXP 85
34412: PUSH
34413: LD_VAR 0 2
34417: ARRAY
34418: PUSH
34419: LD_INT 1
34421: ARRAY
34422: PUSH
34423: LD_INT 2
34425: ARRAY
34426: PPUSH
34427: LD_EXP 85
34431: PUSH
34432: LD_VAR 0 2
34436: ARRAY
34437: PUSH
34438: LD_INT 1
34440: ARRAY
34441: PUSH
34442: LD_INT 3
34444: ARRAY
34445: PPUSH
34446: LD_EXP 85
34450: PUSH
34451: LD_VAR 0 2
34455: ARRAY
34456: PUSH
34457: LD_INT 1
34459: ARRAY
34460: PUSH
34461: LD_INT 4
34463: ARRAY
34464: PPUSH
34465: CALL_OW 145
// end ;
34469: GO 34258
34471: POP
34472: POP
// end else
34473: GO 34645
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
34475: LD_EXP 80
34479: PUSH
34480: LD_VAR 0 2
34484: ARRAY
34485: PPUSH
34486: LD_EXP 85
34490: PUSH
34491: LD_VAR 0 2
34495: ARRAY
34496: PUSH
34497: LD_INT 1
34499: ARRAY
34500: PUSH
34501: LD_INT 1
34503: ARRAY
34504: PPUSH
34505: LD_EXP 85
34509: PUSH
34510: LD_VAR 0 2
34514: ARRAY
34515: PUSH
34516: LD_INT 1
34518: ARRAY
34519: PUSH
34520: LD_INT 2
34522: ARRAY
34523: PPUSH
34524: LD_EXP 85
34528: PUSH
34529: LD_VAR 0 2
34533: ARRAY
34534: PUSH
34535: LD_INT 1
34537: ARRAY
34538: PUSH
34539: LD_INT 3
34541: ARRAY
34542: PPUSH
34543: LD_EXP 85
34547: PUSH
34548: LD_VAR 0 2
34552: ARRAY
34553: PUSH
34554: LD_INT 1
34556: ARRAY
34557: PUSH
34558: LD_INT 4
34560: ARRAY
34561: PPUSH
34562: LD_EXP 80
34566: PUSH
34567: LD_VAR 0 2
34571: ARRAY
34572: PPUSH
34573: LD_INT 21
34575: PUSH
34576: LD_INT 3
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PPUSH
34583: CALL_OW 72
34587: PPUSH
34588: EMPTY
34589: PPUSH
34590: CALL 66002 0 7
34594: NOT
34595: IFFALSE 34645
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
34597: LD_ADDR_EXP 85
34601: PUSH
34602: LD_EXP 85
34606: PPUSH
34607: LD_VAR 0 2
34611: PPUSH
34612: LD_EXP 85
34616: PUSH
34617: LD_VAR 0 2
34621: ARRAY
34622: PPUSH
34623: LD_INT 1
34625: PPUSH
34626: LD_INT 1
34628: NEG
34629: PPUSH
34630: LD_INT 0
34632: PPUSH
34633: CALL 58192 0 4
34637: PPUSH
34638: CALL_OW 1
34642: ST_TO_ADDR
// continue ;
34643: GO 34076
// end ; end ;
34645: GO 34076
34647: POP
34648: POP
// end ; end ;
34649: GO 33505
34651: POP
34652: POP
// end ;
34653: LD_VAR 0 1
34657: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
34658: LD_INT 0
34660: PPUSH
34661: PPUSH
34662: PPUSH
34663: PPUSH
34664: PPUSH
34665: PPUSH
// if not mc_bases then
34666: LD_EXP 80
34670: NOT
34671: IFFALSE 34675
// exit ;
34673: GO 35102
// for i = 1 to mc_bases do
34675: LD_ADDR_VAR 0 2
34679: PUSH
34680: DOUBLE
34681: LD_INT 1
34683: DEC
34684: ST_TO_ADDR
34685: LD_EXP 80
34689: PUSH
34690: FOR_TO
34691: IFFALSE 35100
// begin tmp := mc_build_upgrade [ i ] ;
34693: LD_ADDR_VAR 0 4
34697: PUSH
34698: LD_EXP 112
34702: PUSH
34703: LD_VAR 0 2
34707: ARRAY
34708: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
34709: LD_ADDR_VAR 0 6
34713: PUSH
34714: LD_EXP 113
34718: PUSH
34719: LD_VAR 0 2
34723: ARRAY
34724: PPUSH
34725: LD_INT 2
34727: PUSH
34728: LD_INT 30
34730: PUSH
34731: LD_INT 6
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: LD_INT 30
34740: PUSH
34741: LD_INT 7
34743: PUSH
34744: EMPTY
34745: LIST
34746: LIST
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: LIST
34752: PPUSH
34753: CALL_OW 72
34757: ST_TO_ADDR
// if not tmp and not lab then
34758: LD_VAR 0 4
34762: NOT
34763: PUSH
34764: LD_VAR 0 6
34768: NOT
34769: AND
34770: IFFALSE 34774
// continue ;
34772: GO 34690
// if tmp then
34774: LD_VAR 0 4
34778: IFFALSE 34898
// for j in tmp do
34780: LD_ADDR_VAR 0 3
34784: PUSH
34785: LD_VAR 0 4
34789: PUSH
34790: FOR_IN
34791: IFFALSE 34896
// begin if UpgradeCost ( j ) then
34793: LD_VAR 0 3
34797: PPUSH
34798: CALL 65662 0 1
34802: IFFALSE 34894
// begin ComUpgrade ( j ) ;
34804: LD_VAR 0 3
34808: PPUSH
34809: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
34813: LD_ADDR_EXP 112
34817: PUSH
34818: LD_EXP 112
34822: PPUSH
34823: LD_VAR 0 2
34827: PPUSH
34828: LD_EXP 112
34832: PUSH
34833: LD_VAR 0 2
34837: ARRAY
34838: PUSH
34839: LD_VAR 0 3
34843: DIFF
34844: PPUSH
34845: CALL_OW 1
34849: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34850: LD_ADDR_EXP 87
34854: PUSH
34855: LD_EXP 87
34859: PPUSH
34860: LD_VAR 0 2
34864: PUSH
34865: LD_EXP 87
34869: PUSH
34870: LD_VAR 0 2
34874: ARRAY
34875: PUSH
34876: LD_INT 1
34878: PLUS
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PPUSH
34884: LD_VAR 0 3
34888: PPUSH
34889: CALL 58774 0 3
34893: ST_TO_ADDR
// end ; end ;
34894: GO 34790
34896: POP
34897: POP
// if not lab or not mc_lab_upgrade [ i ] then
34898: LD_VAR 0 6
34902: NOT
34903: PUSH
34904: LD_EXP 114
34908: PUSH
34909: LD_VAR 0 2
34913: ARRAY
34914: NOT
34915: OR
34916: IFFALSE 34920
// continue ;
34918: GO 34690
// for j in lab do
34920: LD_ADDR_VAR 0 3
34924: PUSH
34925: LD_VAR 0 6
34929: PUSH
34930: FOR_IN
34931: IFFALSE 35096
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
34933: LD_VAR 0 3
34937: PPUSH
34938: CALL_OW 266
34942: PUSH
34943: LD_INT 6
34945: PUSH
34946: LD_INT 7
34948: PUSH
34949: EMPTY
34950: LIST
34951: LIST
34952: IN
34953: PUSH
34954: LD_VAR 0 3
34958: PPUSH
34959: CALL_OW 461
34963: PUSH
34964: LD_INT 1
34966: NONEQUAL
34967: AND
34968: IFFALSE 35094
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
34970: LD_VAR 0 3
34974: PPUSH
34975: LD_EXP 114
34979: PUSH
34980: LD_VAR 0 2
34984: ARRAY
34985: PUSH
34986: LD_INT 1
34988: ARRAY
34989: PPUSH
34990: CALL 65867 0 2
34994: IFFALSE 35094
// begin ComCancel ( j ) ;
34996: LD_VAR 0 3
35000: PPUSH
35001: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
35005: LD_VAR 0 3
35009: PPUSH
35010: LD_EXP 114
35014: PUSH
35015: LD_VAR 0 2
35019: ARRAY
35020: PUSH
35021: LD_INT 1
35023: ARRAY
35024: PPUSH
35025: CALL_OW 207
// if not j in mc_construct_list [ i ] then
35029: LD_VAR 0 3
35033: PUSH
35034: LD_EXP 87
35038: PUSH
35039: LD_VAR 0 2
35043: ARRAY
35044: IN
35045: NOT
35046: IFFALSE 35092
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
35048: LD_ADDR_EXP 87
35052: PUSH
35053: LD_EXP 87
35057: PPUSH
35058: LD_VAR 0 2
35062: PUSH
35063: LD_EXP 87
35067: PUSH
35068: LD_VAR 0 2
35072: ARRAY
35073: PUSH
35074: LD_INT 1
35076: PLUS
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PPUSH
35082: LD_VAR 0 3
35086: PPUSH
35087: CALL 58774 0 3
35091: ST_TO_ADDR
// break ;
35092: GO 35096
// end ; end ; end ;
35094: GO 34930
35096: POP
35097: POP
// end ;
35098: GO 34690
35100: POP
35101: POP
// end ;
35102: LD_VAR 0 1
35106: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
35107: LD_INT 0
35109: PPUSH
35110: PPUSH
35111: PPUSH
35112: PPUSH
35113: PPUSH
35114: PPUSH
35115: PPUSH
35116: PPUSH
35117: PPUSH
// if not mc_bases then
35118: LD_EXP 80
35122: NOT
35123: IFFALSE 35127
// exit ;
35125: GO 35532
// for i = 1 to mc_bases do
35127: LD_ADDR_VAR 0 2
35131: PUSH
35132: DOUBLE
35133: LD_INT 1
35135: DEC
35136: ST_TO_ADDR
35137: LD_EXP 80
35141: PUSH
35142: FOR_TO
35143: IFFALSE 35530
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
35145: LD_EXP 88
35149: PUSH
35150: LD_VAR 0 2
35154: ARRAY
35155: NOT
35156: PUSH
35157: LD_EXP 80
35161: PUSH
35162: LD_VAR 0 2
35166: ARRAY
35167: PPUSH
35168: LD_INT 30
35170: PUSH
35171: LD_INT 3
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PPUSH
35178: CALL_OW 72
35182: NOT
35183: OR
35184: IFFALSE 35188
// continue ;
35186: GO 35142
// busy := false ;
35188: LD_ADDR_VAR 0 8
35192: PUSH
35193: LD_INT 0
35195: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35196: LD_ADDR_VAR 0 4
35200: PUSH
35201: LD_EXP 80
35205: PUSH
35206: LD_VAR 0 2
35210: ARRAY
35211: PPUSH
35212: LD_INT 30
35214: PUSH
35215: LD_INT 3
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PPUSH
35222: CALL_OW 72
35226: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
35227: LD_ADDR_VAR 0 6
35231: PUSH
35232: LD_EXP 88
35236: PUSH
35237: LD_VAR 0 2
35241: ARRAY
35242: PPUSH
35243: LD_INT 2
35245: PUSH
35246: LD_INT 30
35248: PUSH
35249: LD_INT 32
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 30
35258: PUSH
35259: LD_INT 33
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: LIST
35270: PPUSH
35271: CALL_OW 72
35275: ST_TO_ADDR
// if not t then
35276: LD_VAR 0 6
35280: NOT
35281: IFFALSE 35285
// continue ;
35283: GO 35142
// for j in tmp do
35285: LD_ADDR_VAR 0 3
35289: PUSH
35290: LD_VAR 0 4
35294: PUSH
35295: FOR_IN
35296: IFFALSE 35326
// if not BuildingStatus ( j ) = bs_idle then
35298: LD_VAR 0 3
35302: PPUSH
35303: CALL_OW 461
35307: PUSH
35308: LD_INT 2
35310: EQUAL
35311: NOT
35312: IFFALSE 35324
// begin busy := true ;
35314: LD_ADDR_VAR 0 8
35318: PUSH
35319: LD_INT 1
35321: ST_TO_ADDR
// break ;
35322: GO 35326
// end ;
35324: GO 35295
35326: POP
35327: POP
// if busy then
35328: LD_VAR 0 8
35332: IFFALSE 35336
// continue ;
35334: GO 35142
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
35336: LD_ADDR_VAR 0 7
35340: PUSH
35341: LD_VAR 0 6
35345: PPUSH
35346: LD_INT 35
35348: PUSH
35349: LD_INT 0
35351: PUSH
35352: EMPTY
35353: LIST
35354: LIST
35355: PPUSH
35356: CALL_OW 72
35360: ST_TO_ADDR
// if tw then
35361: LD_VAR 0 7
35365: IFFALSE 35442
// begin tw := tw [ 1 ] ;
35367: LD_ADDR_VAR 0 7
35371: PUSH
35372: LD_VAR 0 7
35376: PUSH
35377: LD_INT 1
35379: ARRAY
35380: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
35381: LD_ADDR_VAR 0 9
35385: PUSH
35386: LD_VAR 0 7
35390: PPUSH
35391: LD_EXP 105
35395: PUSH
35396: LD_VAR 0 2
35400: ARRAY
35401: PPUSH
35402: CALL 64159 0 2
35406: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
35407: LD_EXP 119
35411: PUSH
35412: LD_VAR 0 2
35416: ARRAY
35417: IFFALSE 35440
// if not weapon in mc_allowed_tower_weapons [ i ] then
35419: LD_VAR 0 9
35423: PUSH
35424: LD_EXP 119
35428: PUSH
35429: LD_VAR 0 2
35433: ARRAY
35434: IN
35435: NOT
35436: IFFALSE 35440
// continue ;
35438: GO 35142
// end else
35440: GO 35505
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
35442: LD_ADDR_VAR 0 5
35446: PUSH
35447: LD_EXP 88
35451: PUSH
35452: LD_VAR 0 2
35456: ARRAY
35457: PPUSH
35458: LD_VAR 0 4
35462: PPUSH
35463: CALL 91071 0 2
35467: ST_TO_ADDR
// if not tmp2 then
35468: LD_VAR 0 5
35472: NOT
35473: IFFALSE 35477
// continue ;
35475: GO 35142
// tw := tmp2 [ 1 ] ;
35477: LD_ADDR_VAR 0 7
35481: PUSH
35482: LD_VAR 0 5
35486: PUSH
35487: LD_INT 1
35489: ARRAY
35490: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
35491: LD_ADDR_VAR 0 9
35495: PUSH
35496: LD_VAR 0 5
35500: PUSH
35501: LD_INT 2
35503: ARRAY
35504: ST_TO_ADDR
// end ; if not weapon then
35505: LD_VAR 0 9
35509: NOT
35510: IFFALSE 35514
// continue ;
35512: GO 35142
// ComPlaceWeapon ( tw , weapon ) ;
35514: LD_VAR 0 7
35518: PPUSH
35519: LD_VAR 0 9
35523: PPUSH
35524: CALL_OW 148
// end ;
35528: GO 35142
35530: POP
35531: POP
// end ;
35532: LD_VAR 0 1
35536: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
35537: LD_INT 0
35539: PPUSH
35540: PPUSH
35541: PPUSH
35542: PPUSH
35543: PPUSH
35544: PPUSH
35545: PPUSH
// if not mc_bases then
35546: LD_EXP 80
35550: NOT
35551: IFFALSE 35555
// exit ;
35553: GO 36330
// for i = 1 to mc_bases do
35555: LD_ADDR_VAR 0 2
35559: PUSH
35560: DOUBLE
35561: LD_INT 1
35563: DEC
35564: ST_TO_ADDR
35565: LD_EXP 80
35569: PUSH
35570: FOR_TO
35571: IFFALSE 36328
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
35573: LD_EXP 93
35577: PUSH
35578: LD_VAR 0 2
35582: ARRAY
35583: NOT
35584: PUSH
35585: LD_EXP 93
35589: PUSH
35590: LD_VAR 0 2
35594: ARRAY
35595: PUSH
35596: LD_EXP 94
35600: PUSH
35601: LD_VAR 0 2
35605: ARRAY
35606: EQUAL
35607: OR
35608: PUSH
35609: LD_EXP 103
35613: PUSH
35614: LD_VAR 0 2
35618: ARRAY
35619: OR
35620: IFFALSE 35624
// continue ;
35622: GO 35570
// if mc_miners [ i ] then
35624: LD_EXP 94
35628: PUSH
35629: LD_VAR 0 2
35633: ARRAY
35634: IFFALSE 36015
// begin for j = mc_miners [ i ] downto 1 do
35636: LD_ADDR_VAR 0 3
35640: PUSH
35641: DOUBLE
35642: LD_EXP 94
35646: PUSH
35647: LD_VAR 0 2
35651: ARRAY
35652: INC
35653: ST_TO_ADDR
35654: LD_INT 1
35656: PUSH
35657: FOR_DOWNTO
35658: IFFALSE 36013
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
35660: LD_EXP 94
35664: PUSH
35665: LD_VAR 0 2
35669: ARRAY
35670: PUSH
35671: LD_VAR 0 3
35675: ARRAY
35676: PPUSH
35677: CALL_OW 301
35681: PUSH
35682: LD_EXP 94
35686: PUSH
35687: LD_VAR 0 2
35691: ARRAY
35692: PUSH
35693: LD_VAR 0 3
35697: ARRAY
35698: PPUSH
35699: CALL_OW 257
35703: PUSH
35704: LD_INT 1
35706: NONEQUAL
35707: OR
35708: IFFALSE 35771
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
35710: LD_ADDR_VAR 0 5
35714: PUSH
35715: LD_EXP 94
35719: PUSH
35720: LD_VAR 0 2
35724: ARRAY
35725: PUSH
35726: LD_EXP 94
35730: PUSH
35731: LD_VAR 0 2
35735: ARRAY
35736: PUSH
35737: LD_VAR 0 3
35741: ARRAY
35742: DIFF
35743: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
35744: LD_ADDR_EXP 94
35748: PUSH
35749: LD_EXP 94
35753: PPUSH
35754: LD_VAR 0 2
35758: PPUSH
35759: LD_VAR 0 5
35763: PPUSH
35764: CALL_OW 1
35768: ST_TO_ADDR
// continue ;
35769: GO 35657
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
35771: LD_EXP 94
35775: PUSH
35776: LD_VAR 0 2
35780: ARRAY
35781: PUSH
35782: LD_VAR 0 3
35786: ARRAY
35787: PPUSH
35788: CALL_OW 257
35792: PUSH
35793: LD_INT 1
35795: EQUAL
35796: PUSH
35797: LD_EXP 94
35801: PUSH
35802: LD_VAR 0 2
35806: ARRAY
35807: PUSH
35808: LD_VAR 0 3
35812: ARRAY
35813: PPUSH
35814: CALL_OW 459
35818: NOT
35819: AND
35820: PUSH
35821: LD_EXP 94
35825: PUSH
35826: LD_VAR 0 2
35830: ARRAY
35831: PUSH
35832: LD_VAR 0 3
35836: ARRAY
35837: PPUSH
35838: CALL_OW 314
35842: NOT
35843: AND
35844: IFFALSE 36011
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
35846: LD_EXP 94
35850: PUSH
35851: LD_VAR 0 2
35855: ARRAY
35856: PUSH
35857: LD_VAR 0 3
35861: ARRAY
35862: PPUSH
35863: CALL_OW 310
35867: IFFALSE 35890
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
35869: LD_EXP 94
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: PUSH
35880: LD_VAR 0 3
35884: ARRAY
35885: PPUSH
35886: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
35890: LD_EXP 94
35894: PUSH
35895: LD_VAR 0 2
35899: ARRAY
35900: PUSH
35901: LD_VAR 0 3
35905: ARRAY
35906: PPUSH
35907: CALL_OW 314
35911: NOT
35912: IFFALSE 36011
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
35914: LD_ADDR_VAR 0 7
35918: PUSH
35919: LD_VAR 0 3
35923: PUSH
35924: LD_EXP 93
35928: PUSH
35929: LD_VAR 0 2
35933: ARRAY
35934: PPUSH
35935: CALL 55914 0 1
35939: MOD
35940: PUSH
35941: LD_INT 1
35943: PLUS
35944: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
35945: LD_EXP 94
35949: PUSH
35950: LD_VAR 0 2
35954: ARRAY
35955: PUSH
35956: LD_VAR 0 3
35960: ARRAY
35961: PPUSH
35962: LD_EXP 93
35966: PUSH
35967: LD_VAR 0 2
35971: ARRAY
35972: PUSH
35973: LD_VAR 0 7
35977: ARRAY
35978: PUSH
35979: LD_INT 1
35981: ARRAY
35982: PPUSH
35983: LD_EXP 93
35987: PUSH
35988: LD_VAR 0 2
35992: ARRAY
35993: PUSH
35994: LD_VAR 0 7
35998: ARRAY
35999: PUSH
36000: LD_INT 2
36002: ARRAY
36003: PPUSH
36004: LD_INT 0
36006: PPUSH
36007: CALL_OW 193
// end ; end ; end ;
36011: GO 35657
36013: POP
36014: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
36015: LD_ADDR_VAR 0 5
36019: PUSH
36020: LD_EXP 80
36024: PUSH
36025: LD_VAR 0 2
36029: ARRAY
36030: PPUSH
36031: LD_INT 2
36033: PUSH
36034: LD_INT 30
36036: PUSH
36037: LD_INT 4
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 30
36046: PUSH
36047: LD_INT 5
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 30
36056: PUSH
36057: LD_INT 32
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: LIST
36068: LIST
36069: PPUSH
36070: CALL_OW 72
36074: ST_TO_ADDR
// if not tmp then
36075: LD_VAR 0 5
36079: NOT
36080: IFFALSE 36084
// continue ;
36082: GO 35570
// list := [ ] ;
36084: LD_ADDR_VAR 0 6
36088: PUSH
36089: EMPTY
36090: ST_TO_ADDR
// for j in tmp do
36091: LD_ADDR_VAR 0 3
36095: PUSH
36096: LD_VAR 0 5
36100: PUSH
36101: FOR_IN
36102: IFFALSE 36171
// begin for k in UnitsInside ( j ) do
36104: LD_ADDR_VAR 0 4
36108: PUSH
36109: LD_VAR 0 3
36113: PPUSH
36114: CALL_OW 313
36118: PUSH
36119: FOR_IN
36120: IFFALSE 36167
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
36122: LD_VAR 0 4
36126: PPUSH
36127: CALL_OW 257
36131: PUSH
36132: LD_INT 1
36134: EQUAL
36135: PUSH
36136: LD_VAR 0 4
36140: PPUSH
36141: CALL_OW 459
36145: NOT
36146: AND
36147: IFFALSE 36165
// list := list ^ k ;
36149: LD_ADDR_VAR 0 6
36153: PUSH
36154: LD_VAR 0 6
36158: PUSH
36159: LD_VAR 0 4
36163: ADD
36164: ST_TO_ADDR
36165: GO 36119
36167: POP
36168: POP
// end ;
36169: GO 36101
36171: POP
36172: POP
// list := list diff mc_miners [ i ] ;
36173: LD_ADDR_VAR 0 6
36177: PUSH
36178: LD_VAR 0 6
36182: PUSH
36183: LD_EXP 94
36187: PUSH
36188: LD_VAR 0 2
36192: ARRAY
36193: DIFF
36194: ST_TO_ADDR
// if not list then
36195: LD_VAR 0 6
36199: NOT
36200: IFFALSE 36204
// continue ;
36202: GO 35570
// k := mc_mines [ i ] - mc_miners [ i ] ;
36204: LD_ADDR_VAR 0 4
36208: PUSH
36209: LD_EXP 93
36213: PUSH
36214: LD_VAR 0 2
36218: ARRAY
36219: PUSH
36220: LD_EXP 94
36224: PUSH
36225: LD_VAR 0 2
36229: ARRAY
36230: MINUS
36231: ST_TO_ADDR
// if k > list then
36232: LD_VAR 0 4
36236: PUSH
36237: LD_VAR 0 6
36241: GREATER
36242: IFFALSE 36254
// k := list ;
36244: LD_ADDR_VAR 0 4
36248: PUSH
36249: LD_VAR 0 6
36253: ST_TO_ADDR
// for j = 1 to k do
36254: LD_ADDR_VAR 0 3
36258: PUSH
36259: DOUBLE
36260: LD_INT 1
36262: DEC
36263: ST_TO_ADDR
36264: LD_VAR 0 4
36268: PUSH
36269: FOR_TO
36270: IFFALSE 36324
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
36272: LD_ADDR_EXP 94
36276: PUSH
36277: LD_EXP 94
36281: PPUSH
36282: LD_VAR 0 2
36286: PUSH
36287: LD_EXP 94
36291: PUSH
36292: LD_VAR 0 2
36296: ARRAY
36297: PUSH
36298: LD_INT 1
36300: PLUS
36301: PUSH
36302: EMPTY
36303: LIST
36304: LIST
36305: PPUSH
36306: LD_VAR 0 6
36310: PUSH
36311: LD_VAR 0 3
36315: ARRAY
36316: PPUSH
36317: CALL 58774 0 3
36321: ST_TO_ADDR
36322: GO 36269
36324: POP
36325: POP
// end ;
36326: GO 35570
36328: POP
36329: POP
// end ;
36330: LD_VAR 0 1
36334: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
36335: LD_INT 0
36337: PPUSH
36338: PPUSH
36339: PPUSH
36340: PPUSH
36341: PPUSH
36342: PPUSH
36343: PPUSH
36344: PPUSH
36345: PPUSH
36346: PPUSH
36347: PPUSH
// if not mc_bases then
36348: LD_EXP 80
36352: NOT
36353: IFFALSE 36357
// exit ;
36355: GO 38180
// for i = 1 to mc_bases do
36357: LD_ADDR_VAR 0 2
36361: PUSH
36362: DOUBLE
36363: LD_INT 1
36365: DEC
36366: ST_TO_ADDR
36367: LD_EXP 80
36371: PUSH
36372: FOR_TO
36373: IFFALSE 38178
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
36375: LD_EXP 80
36379: PUSH
36380: LD_VAR 0 2
36384: ARRAY
36385: NOT
36386: PUSH
36387: LD_EXP 87
36391: PUSH
36392: LD_VAR 0 2
36396: ARRAY
36397: OR
36398: IFFALSE 36402
// continue ;
36400: GO 36372
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
36402: LD_EXP 96
36406: PUSH
36407: LD_VAR 0 2
36411: ARRAY
36412: NOT
36413: PUSH
36414: LD_EXP 97
36418: PUSH
36419: LD_VAR 0 2
36423: ARRAY
36424: AND
36425: IFFALSE 36463
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36427: LD_ADDR_EXP 97
36431: PUSH
36432: LD_EXP 97
36436: PPUSH
36437: LD_VAR 0 2
36441: PPUSH
36442: EMPTY
36443: PPUSH
36444: CALL_OW 1
36448: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
36449: LD_VAR 0 2
36453: PPUSH
36454: LD_INT 107
36456: PPUSH
36457: CALL 27189 0 2
// continue ;
36461: GO 36372
// end ; target := [ ] ;
36463: LD_ADDR_VAR 0 7
36467: PUSH
36468: EMPTY
36469: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36470: LD_ADDR_VAR 0 6
36474: PUSH
36475: LD_EXP 80
36479: PUSH
36480: LD_VAR 0 2
36484: ARRAY
36485: PUSH
36486: LD_INT 1
36488: ARRAY
36489: PPUSH
36490: CALL_OW 255
36494: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36495: LD_ADDR_VAR 0 9
36499: PUSH
36500: LD_EXP 80
36504: PUSH
36505: LD_VAR 0 2
36509: ARRAY
36510: PPUSH
36511: LD_INT 2
36513: PUSH
36514: LD_INT 30
36516: PUSH
36517: LD_INT 0
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 30
36526: PUSH
36527: LD_INT 1
36529: PUSH
36530: EMPTY
36531: LIST
36532: LIST
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: LIST
36538: PPUSH
36539: CALL_OW 72
36543: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
36544: LD_ADDR_VAR 0 3
36548: PUSH
36549: DOUBLE
36550: LD_EXP 96
36554: PUSH
36555: LD_VAR 0 2
36559: ARRAY
36560: INC
36561: ST_TO_ADDR
36562: LD_INT 1
36564: PUSH
36565: FOR_DOWNTO
36566: IFFALSE 36811
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
36568: LD_EXP 96
36572: PUSH
36573: LD_VAR 0 2
36577: ARRAY
36578: PUSH
36579: LD_VAR 0 3
36583: ARRAY
36584: PUSH
36585: LD_INT 2
36587: ARRAY
36588: PPUSH
36589: LD_EXP 96
36593: PUSH
36594: LD_VAR 0 2
36598: ARRAY
36599: PUSH
36600: LD_VAR 0 3
36604: ARRAY
36605: PUSH
36606: LD_INT 3
36608: ARRAY
36609: PPUSH
36610: CALL_OW 488
36614: PUSH
36615: LD_EXP 96
36619: PUSH
36620: LD_VAR 0 2
36624: ARRAY
36625: PUSH
36626: LD_VAR 0 3
36630: ARRAY
36631: PUSH
36632: LD_INT 2
36634: ARRAY
36635: PPUSH
36636: LD_EXP 96
36640: PUSH
36641: LD_VAR 0 2
36645: ARRAY
36646: PUSH
36647: LD_VAR 0 3
36651: ARRAY
36652: PUSH
36653: LD_INT 3
36655: ARRAY
36656: PPUSH
36657: CALL_OW 284
36661: PUSH
36662: LD_INT 0
36664: EQUAL
36665: AND
36666: IFFALSE 36721
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
36668: LD_ADDR_VAR 0 5
36672: PUSH
36673: LD_EXP 96
36677: PUSH
36678: LD_VAR 0 2
36682: ARRAY
36683: PPUSH
36684: LD_VAR 0 3
36688: PPUSH
36689: CALL_OW 3
36693: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
36694: LD_ADDR_EXP 96
36698: PUSH
36699: LD_EXP 96
36703: PPUSH
36704: LD_VAR 0 2
36708: PPUSH
36709: LD_VAR 0 5
36713: PPUSH
36714: CALL_OW 1
36718: ST_TO_ADDR
// continue ;
36719: GO 36565
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
36721: LD_VAR 0 6
36725: PPUSH
36726: LD_EXP 96
36730: PUSH
36731: LD_VAR 0 2
36735: ARRAY
36736: PUSH
36737: LD_VAR 0 3
36741: ARRAY
36742: PUSH
36743: LD_INT 2
36745: ARRAY
36746: PPUSH
36747: LD_EXP 96
36751: PUSH
36752: LD_VAR 0 2
36756: ARRAY
36757: PUSH
36758: LD_VAR 0 3
36762: ARRAY
36763: PUSH
36764: LD_INT 3
36766: ARRAY
36767: PPUSH
36768: LD_INT 30
36770: PPUSH
36771: CALL 60038 0 4
36775: PUSH
36776: LD_INT 4
36778: ARRAY
36779: PUSH
36780: LD_INT 0
36782: EQUAL
36783: IFFALSE 36809
// begin target := mc_crates [ i ] [ j ] ;
36785: LD_ADDR_VAR 0 7
36789: PUSH
36790: LD_EXP 96
36794: PUSH
36795: LD_VAR 0 2
36799: ARRAY
36800: PUSH
36801: LD_VAR 0 3
36805: ARRAY
36806: ST_TO_ADDR
// break ;
36807: GO 36811
// end ; end ;
36809: GO 36565
36811: POP
36812: POP
// if not target then
36813: LD_VAR 0 7
36817: NOT
36818: IFFALSE 36822
// continue ;
36820: GO 36372
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
36822: LD_ADDR_VAR 0 8
36826: PUSH
36827: LD_EXP 99
36831: PUSH
36832: LD_VAR 0 2
36836: ARRAY
36837: PPUSH
36838: LD_INT 2
36840: PUSH
36841: LD_INT 3
36843: PUSH
36844: LD_INT 58
36846: PUSH
36847: EMPTY
36848: LIST
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: LD_INT 61
36856: PUSH
36857: EMPTY
36858: LIST
36859: PUSH
36860: LD_INT 33
36862: PUSH
36863: LD_INT 5
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 33
36872: PUSH
36873: LD_INT 3
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: LIST
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 2
36889: PUSH
36890: LD_INT 34
36892: PUSH
36893: LD_INT 32
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: LD_INT 34
36902: PUSH
36903: LD_INT 51
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: LD_INT 34
36912: PUSH
36913: LD_INT 12
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: LIST
36924: LIST
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PPUSH
36930: CALL_OW 72
36934: ST_TO_ADDR
// if not cargo then
36935: LD_VAR 0 8
36939: NOT
36940: IFFALSE 37646
// begin if mc_crates_collector [ i ] < 5 then
36942: LD_EXP 97
36946: PUSH
36947: LD_VAR 0 2
36951: ARRAY
36952: PUSH
36953: LD_INT 5
36955: LESS
36956: IFFALSE 37322
// begin if mc_ape [ i ] then
36958: LD_EXP 109
36962: PUSH
36963: LD_VAR 0 2
36967: ARRAY
36968: IFFALSE 37015
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
36970: LD_ADDR_VAR 0 5
36974: PUSH
36975: LD_EXP 109
36979: PUSH
36980: LD_VAR 0 2
36984: ARRAY
36985: PPUSH
36986: LD_INT 25
36988: PUSH
36989: LD_INT 16
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 24
36998: PUSH
36999: LD_INT 750
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PPUSH
37010: CALL_OW 72
37014: ST_TO_ADDR
// if not tmp then
37015: LD_VAR 0 5
37019: NOT
37020: IFFALSE 37067
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
37022: LD_ADDR_VAR 0 5
37026: PUSH
37027: LD_EXP 80
37031: PUSH
37032: LD_VAR 0 2
37036: ARRAY
37037: PPUSH
37038: LD_INT 25
37040: PUSH
37041: LD_INT 2
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 24
37050: PUSH
37051: LD_INT 750
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PPUSH
37062: CALL_OW 72
37066: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
37067: LD_EXP 109
37071: PUSH
37072: LD_VAR 0 2
37076: ARRAY
37077: PUSH
37078: LD_EXP 80
37082: PUSH
37083: LD_VAR 0 2
37087: ARRAY
37088: PPUSH
37089: LD_INT 25
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 24
37101: PUSH
37102: LD_INT 750
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PPUSH
37113: CALL_OW 72
37117: AND
37118: PUSH
37119: LD_VAR 0 5
37123: PUSH
37124: LD_INT 5
37126: LESS
37127: AND
37128: IFFALSE 37210
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
37130: LD_ADDR_VAR 0 3
37134: PUSH
37135: LD_EXP 80
37139: PUSH
37140: LD_VAR 0 2
37144: ARRAY
37145: PPUSH
37146: LD_INT 25
37148: PUSH
37149: LD_INT 2
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 24
37158: PUSH
37159: LD_INT 750
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: EMPTY
37167: LIST
37168: LIST
37169: PPUSH
37170: CALL_OW 72
37174: PUSH
37175: FOR_IN
37176: IFFALSE 37208
// begin tmp := tmp union j ;
37178: LD_ADDR_VAR 0 5
37182: PUSH
37183: LD_VAR 0 5
37187: PUSH
37188: LD_VAR 0 3
37192: UNION
37193: ST_TO_ADDR
// if tmp >= 5 then
37194: LD_VAR 0 5
37198: PUSH
37199: LD_INT 5
37201: GREATEREQUAL
37202: IFFALSE 37206
// break ;
37204: GO 37208
// end ;
37206: GO 37175
37208: POP
37209: POP
// end ; if not tmp then
37210: LD_VAR 0 5
37214: NOT
37215: IFFALSE 37219
// continue ;
37217: GO 36372
// for j in tmp do
37219: LD_ADDR_VAR 0 3
37223: PUSH
37224: LD_VAR 0 5
37228: PUSH
37229: FOR_IN
37230: IFFALSE 37320
// if not GetTag ( j ) then
37232: LD_VAR 0 3
37236: PPUSH
37237: CALL_OW 110
37241: NOT
37242: IFFALSE 37318
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
37244: LD_ADDR_EXP 97
37248: PUSH
37249: LD_EXP 97
37253: PPUSH
37254: LD_VAR 0 2
37258: PUSH
37259: LD_EXP 97
37263: PUSH
37264: LD_VAR 0 2
37268: ARRAY
37269: PUSH
37270: LD_INT 1
37272: PLUS
37273: PUSH
37274: EMPTY
37275: LIST
37276: LIST
37277: PPUSH
37278: LD_VAR 0 3
37282: PPUSH
37283: CALL 58774 0 3
37287: ST_TO_ADDR
// SetTag ( j , 107 ) ;
37288: LD_VAR 0 3
37292: PPUSH
37293: LD_INT 107
37295: PPUSH
37296: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
37300: LD_EXP 97
37304: PUSH
37305: LD_VAR 0 2
37309: ARRAY
37310: PUSH
37311: LD_INT 5
37313: GREATEREQUAL
37314: IFFALSE 37318
// break ;
37316: GO 37320
// end ;
37318: GO 37229
37320: POP
37321: POP
// end ; if mc_crates_collector [ i ] and target then
37322: LD_EXP 97
37326: PUSH
37327: LD_VAR 0 2
37331: ARRAY
37332: PUSH
37333: LD_VAR 0 7
37337: AND
37338: IFFALSE 37644
// begin if mc_crates_collector [ i ] < target [ 1 ] then
37340: LD_EXP 97
37344: PUSH
37345: LD_VAR 0 2
37349: ARRAY
37350: PUSH
37351: LD_VAR 0 7
37355: PUSH
37356: LD_INT 1
37358: ARRAY
37359: LESS
37360: IFFALSE 37380
// tmp := mc_crates_collector [ i ] else
37362: LD_ADDR_VAR 0 5
37366: PUSH
37367: LD_EXP 97
37371: PUSH
37372: LD_VAR 0 2
37376: ARRAY
37377: ST_TO_ADDR
37378: GO 37394
// tmp := target [ 1 ] ;
37380: LD_ADDR_VAR 0 5
37384: PUSH
37385: LD_VAR 0 7
37389: PUSH
37390: LD_INT 1
37392: ARRAY
37393: ST_TO_ADDR
// k := 0 ;
37394: LD_ADDR_VAR 0 4
37398: PUSH
37399: LD_INT 0
37401: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
37402: LD_ADDR_VAR 0 3
37406: PUSH
37407: LD_EXP 97
37411: PUSH
37412: LD_VAR 0 2
37416: ARRAY
37417: PUSH
37418: FOR_IN
37419: IFFALSE 37642
// begin k := k + 1 ;
37421: LD_ADDR_VAR 0 4
37425: PUSH
37426: LD_VAR 0 4
37430: PUSH
37431: LD_INT 1
37433: PLUS
37434: ST_TO_ADDR
// if k > tmp then
37435: LD_VAR 0 4
37439: PUSH
37440: LD_VAR 0 5
37444: GREATER
37445: IFFALSE 37449
// break ;
37447: GO 37642
// if not GetClass ( j ) in [ 2 , 16 ] then
37449: LD_VAR 0 3
37453: PPUSH
37454: CALL_OW 257
37458: PUSH
37459: LD_INT 2
37461: PUSH
37462: LD_INT 16
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: IN
37469: NOT
37470: IFFALSE 37523
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
37472: LD_ADDR_EXP 97
37476: PUSH
37477: LD_EXP 97
37481: PPUSH
37482: LD_VAR 0 2
37486: PPUSH
37487: LD_EXP 97
37491: PUSH
37492: LD_VAR 0 2
37496: ARRAY
37497: PUSH
37498: LD_VAR 0 3
37502: DIFF
37503: PPUSH
37504: CALL_OW 1
37508: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37509: LD_VAR 0 3
37513: PPUSH
37514: LD_INT 0
37516: PPUSH
37517: CALL_OW 109
// continue ;
37521: GO 37418
// end ; if IsInUnit ( j ) then
37523: LD_VAR 0 3
37527: PPUSH
37528: CALL_OW 310
37532: IFFALSE 37543
// ComExitBuilding ( j ) ;
37534: LD_VAR 0 3
37538: PPUSH
37539: CALL_OW 122
// wait ( 3 ) ;
37543: LD_INT 3
37545: PPUSH
37546: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
37550: LD_VAR 0 3
37554: PPUSH
37555: CALL_OW 314
37559: PUSH
37560: LD_VAR 0 6
37564: PPUSH
37565: LD_VAR 0 7
37569: PUSH
37570: LD_INT 2
37572: ARRAY
37573: PPUSH
37574: LD_VAR 0 7
37578: PUSH
37579: LD_INT 3
37581: ARRAY
37582: PPUSH
37583: LD_INT 30
37585: PPUSH
37586: CALL 60038 0 4
37590: PUSH
37591: LD_INT 4
37593: ARRAY
37594: AND
37595: IFFALSE 37613
// ComStandNearbyBuilding ( j , depot ) else
37597: LD_VAR 0 3
37601: PPUSH
37602: LD_VAR 0 9
37606: PPUSH
37607: CALL 55376 0 2
37611: GO 37640
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37613: LD_VAR 0 3
37617: PPUSH
37618: LD_VAR 0 7
37622: PUSH
37623: LD_INT 2
37625: ARRAY
37626: PPUSH
37627: LD_VAR 0 7
37631: PUSH
37632: LD_INT 3
37634: ARRAY
37635: PPUSH
37636: CALL_OW 117
// end ;
37640: GO 37418
37642: POP
37643: POP
// end ; end else
37644: GO 38176
// begin for j in cargo do
37646: LD_ADDR_VAR 0 3
37650: PUSH
37651: LD_VAR 0 8
37655: PUSH
37656: FOR_IN
37657: IFFALSE 38174
// begin if GetTag ( j ) <> 0 then
37659: LD_VAR 0 3
37663: PPUSH
37664: CALL_OW 110
37668: PUSH
37669: LD_INT 0
37671: NONEQUAL
37672: IFFALSE 37676
// continue ;
37674: GO 37656
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
37676: LD_VAR 0 3
37680: PPUSH
37681: CALL_OW 256
37685: PUSH
37686: LD_INT 1000
37688: LESS
37689: PUSH
37690: LD_VAR 0 3
37694: PPUSH
37695: LD_EXP 104
37699: PUSH
37700: LD_VAR 0 2
37704: ARRAY
37705: PPUSH
37706: CALL_OW 308
37710: NOT
37711: AND
37712: IFFALSE 37734
// ComMoveToArea ( j , mc_parking [ i ] ) ;
37714: LD_VAR 0 3
37718: PPUSH
37719: LD_EXP 104
37723: PUSH
37724: LD_VAR 0 2
37728: ARRAY
37729: PPUSH
37730: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
37734: LD_VAR 0 3
37738: PPUSH
37739: CALL_OW 256
37743: PUSH
37744: LD_INT 1000
37746: LESS
37747: PUSH
37748: LD_VAR 0 3
37752: PPUSH
37753: LD_EXP 104
37757: PUSH
37758: LD_VAR 0 2
37762: ARRAY
37763: PPUSH
37764: CALL_OW 308
37768: AND
37769: IFFALSE 37773
// continue ;
37771: GO 37656
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
37773: LD_VAR 0 3
37777: PPUSH
37778: CALL_OW 262
37782: PUSH
37783: LD_INT 2
37785: EQUAL
37786: PUSH
37787: LD_VAR 0 3
37791: PPUSH
37792: CALL_OW 261
37796: PUSH
37797: LD_INT 15
37799: LESS
37800: AND
37801: IFFALSE 37805
// continue ;
37803: GO 37656
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
37805: LD_VAR 0 3
37809: PPUSH
37810: CALL_OW 262
37814: PUSH
37815: LD_INT 1
37817: EQUAL
37818: PUSH
37819: LD_VAR 0 3
37823: PPUSH
37824: CALL_OW 261
37828: PUSH
37829: LD_INT 10
37831: LESS
37832: AND
37833: IFFALSE 38113
// begin if not depot then
37835: LD_VAR 0 9
37839: NOT
37840: IFFALSE 37844
// continue ;
37842: GO 37656
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
37844: LD_VAR 0 3
37848: PPUSH
37849: LD_VAR 0 9
37853: PPUSH
37854: LD_VAR 0 3
37858: PPUSH
37859: CALL_OW 74
37863: PPUSH
37864: CALL_OW 296
37868: PUSH
37869: LD_INT 6
37871: LESS
37872: IFFALSE 37888
// SetFuel ( j , 100 ) else
37874: LD_VAR 0 3
37878: PPUSH
37879: LD_INT 100
37881: PPUSH
37882: CALL_OW 240
37886: GO 38113
// if GetFuel ( j ) = 0 then
37888: LD_VAR 0 3
37892: PPUSH
37893: CALL_OW 261
37897: PUSH
37898: LD_INT 0
37900: EQUAL
37901: IFFALSE 38113
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
37903: LD_ADDR_EXP 99
37907: PUSH
37908: LD_EXP 99
37912: PPUSH
37913: LD_VAR 0 2
37917: PPUSH
37918: LD_EXP 99
37922: PUSH
37923: LD_VAR 0 2
37927: ARRAY
37928: PUSH
37929: LD_VAR 0 3
37933: DIFF
37934: PPUSH
37935: CALL_OW 1
37939: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
37940: LD_VAR 0 3
37944: PPUSH
37945: CALL_OW 263
37949: PUSH
37950: LD_INT 1
37952: EQUAL
37953: IFFALSE 37969
// ComExitVehicle ( IsInUnit ( j ) ) ;
37955: LD_VAR 0 3
37959: PPUSH
37960: CALL_OW 310
37964: PPUSH
37965: CALL_OW 121
// if GetControl ( j ) = control_remote then
37969: LD_VAR 0 3
37973: PPUSH
37974: CALL_OW 263
37978: PUSH
37979: LD_INT 2
37981: EQUAL
37982: IFFALSE 37993
// ComUnlink ( j ) ;
37984: LD_VAR 0 3
37988: PPUSH
37989: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
37993: LD_ADDR_VAR 0 10
37997: PUSH
37998: LD_VAR 0 2
38002: PPUSH
38003: LD_INT 3
38005: PPUSH
38006: CALL 47757 0 2
38010: ST_TO_ADDR
// if fac then
38011: LD_VAR 0 10
38015: IFFALSE 38111
// begin for k in fac do
38017: LD_ADDR_VAR 0 4
38021: PUSH
38022: LD_VAR 0 10
38026: PUSH
38027: FOR_IN
38028: IFFALSE 38109
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
38030: LD_ADDR_VAR 0 11
38034: PUSH
38035: LD_VAR 0 10
38039: PPUSH
38040: LD_VAR 0 3
38044: PPUSH
38045: CALL_OW 265
38049: PPUSH
38050: LD_VAR 0 3
38054: PPUSH
38055: CALL_OW 262
38059: PPUSH
38060: LD_VAR 0 3
38064: PPUSH
38065: CALL_OW 263
38069: PPUSH
38070: LD_VAR 0 3
38074: PPUSH
38075: CALL_OW 264
38079: PPUSH
38080: CALL 56272 0 5
38084: ST_TO_ADDR
// if components then
38085: LD_VAR 0 11
38089: IFFALSE 38107
// begin MC_InsertProduceList ( i , components ) ;
38091: LD_VAR 0 2
38095: PPUSH
38096: LD_VAR 0 11
38100: PPUSH
38101: CALL 47302 0 2
// break ;
38105: GO 38109
// end ; end ;
38107: GO 38027
38109: POP
38110: POP
// end ; continue ;
38111: GO 37656
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
38113: LD_VAR 0 3
38117: PPUSH
38118: LD_INT 1
38120: PPUSH
38121: CALL_OW 289
38125: PUSH
38126: LD_INT 100
38128: LESS
38129: PUSH
38130: LD_VAR 0 3
38134: PPUSH
38135: CALL_OW 314
38139: NOT
38140: AND
38141: IFFALSE 38170
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
38143: LD_VAR 0 3
38147: PPUSH
38148: LD_VAR 0 7
38152: PUSH
38153: LD_INT 2
38155: ARRAY
38156: PPUSH
38157: LD_VAR 0 7
38161: PUSH
38162: LD_INT 3
38164: ARRAY
38165: PPUSH
38166: CALL_OW 117
// break ;
38170: GO 38174
// end ;
38172: GO 37656
38174: POP
38175: POP
// end ; end ;
38176: GO 36372
38178: POP
38179: POP
// end ;
38180: LD_VAR 0 1
38184: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
38185: LD_INT 0
38187: PPUSH
38188: PPUSH
38189: PPUSH
38190: PPUSH
// if not mc_bases then
38191: LD_EXP 80
38195: NOT
38196: IFFALSE 38200
// exit ;
38198: GO 38361
// for i = 1 to mc_bases do
38200: LD_ADDR_VAR 0 2
38204: PUSH
38205: DOUBLE
38206: LD_INT 1
38208: DEC
38209: ST_TO_ADDR
38210: LD_EXP 80
38214: PUSH
38215: FOR_TO
38216: IFFALSE 38359
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
38218: LD_ADDR_VAR 0 4
38222: PUSH
38223: LD_EXP 99
38227: PUSH
38228: LD_VAR 0 2
38232: ARRAY
38233: PUSH
38234: LD_EXP 102
38238: PUSH
38239: LD_VAR 0 2
38243: ARRAY
38244: UNION
38245: PPUSH
38246: LD_INT 33
38248: PUSH
38249: LD_INT 2
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PPUSH
38256: CALL_OW 72
38260: ST_TO_ADDR
// if tmp then
38261: LD_VAR 0 4
38265: IFFALSE 38357
// for j in tmp do
38267: LD_ADDR_VAR 0 3
38271: PUSH
38272: LD_VAR 0 4
38276: PUSH
38277: FOR_IN
38278: IFFALSE 38355
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
38280: LD_VAR 0 3
38284: PPUSH
38285: CALL_OW 312
38289: NOT
38290: PUSH
38291: LD_VAR 0 3
38295: PPUSH
38296: CALL_OW 256
38300: PUSH
38301: LD_INT 250
38303: GREATEREQUAL
38304: AND
38305: IFFALSE 38318
// Connect ( j ) else
38307: LD_VAR 0 3
38311: PPUSH
38312: CALL 62120 0 1
38316: GO 38353
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
38318: LD_VAR 0 3
38322: PPUSH
38323: CALL_OW 256
38327: PUSH
38328: LD_INT 250
38330: LESS
38331: PUSH
38332: LD_VAR 0 3
38336: PPUSH
38337: CALL_OW 312
38341: AND
38342: IFFALSE 38353
// ComUnlink ( j ) ;
38344: LD_VAR 0 3
38348: PPUSH
38349: CALL_OW 136
38353: GO 38277
38355: POP
38356: POP
// end ;
38357: GO 38215
38359: POP
38360: POP
// end ;
38361: LD_VAR 0 1
38365: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
38366: LD_INT 0
38368: PPUSH
38369: PPUSH
38370: PPUSH
38371: PPUSH
38372: PPUSH
// if not mc_bases then
38373: LD_EXP 80
38377: NOT
38378: IFFALSE 38382
// exit ;
38380: GO 38827
// for i = 1 to mc_bases do
38382: LD_ADDR_VAR 0 2
38386: PUSH
38387: DOUBLE
38388: LD_INT 1
38390: DEC
38391: ST_TO_ADDR
38392: LD_EXP 80
38396: PUSH
38397: FOR_TO
38398: IFFALSE 38825
// begin if not mc_produce [ i ] then
38400: LD_EXP 101
38404: PUSH
38405: LD_VAR 0 2
38409: ARRAY
38410: NOT
38411: IFFALSE 38415
// continue ;
38413: GO 38397
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38415: LD_ADDR_VAR 0 5
38419: PUSH
38420: LD_EXP 80
38424: PUSH
38425: LD_VAR 0 2
38429: ARRAY
38430: PPUSH
38431: LD_INT 30
38433: PUSH
38434: LD_INT 3
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PPUSH
38441: CALL_OW 72
38445: ST_TO_ADDR
// if not fac then
38446: LD_VAR 0 5
38450: NOT
38451: IFFALSE 38455
// continue ;
38453: GO 38397
// for j in fac do
38455: LD_ADDR_VAR 0 3
38459: PUSH
38460: LD_VAR 0 5
38464: PUSH
38465: FOR_IN
38466: IFFALSE 38821
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
38468: LD_VAR 0 3
38472: PPUSH
38473: CALL_OW 461
38477: PUSH
38478: LD_INT 2
38480: NONEQUAL
38481: PUSH
38482: LD_VAR 0 3
38486: PPUSH
38487: LD_INT 15
38489: PPUSH
38490: CALL 61739 0 2
38494: PUSH
38495: LD_INT 4
38497: ARRAY
38498: OR
38499: IFFALSE 38503
// continue ;
38501: GO 38465
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
38503: LD_VAR 0 3
38507: PPUSH
38508: LD_EXP 101
38512: PUSH
38513: LD_VAR 0 2
38517: ARRAY
38518: PUSH
38519: LD_INT 1
38521: ARRAY
38522: PUSH
38523: LD_INT 1
38525: ARRAY
38526: PPUSH
38527: LD_EXP 101
38531: PUSH
38532: LD_VAR 0 2
38536: ARRAY
38537: PUSH
38538: LD_INT 1
38540: ARRAY
38541: PUSH
38542: LD_INT 2
38544: ARRAY
38545: PPUSH
38546: LD_EXP 101
38550: PUSH
38551: LD_VAR 0 2
38555: ARRAY
38556: PUSH
38557: LD_INT 1
38559: ARRAY
38560: PUSH
38561: LD_INT 3
38563: ARRAY
38564: PPUSH
38565: LD_EXP 101
38569: PUSH
38570: LD_VAR 0 2
38574: ARRAY
38575: PUSH
38576: LD_INT 1
38578: ARRAY
38579: PUSH
38580: LD_INT 4
38582: ARRAY
38583: PPUSH
38584: CALL_OW 448
38588: PUSH
38589: LD_VAR 0 3
38593: PPUSH
38594: LD_EXP 101
38598: PUSH
38599: LD_VAR 0 2
38603: ARRAY
38604: PUSH
38605: LD_INT 1
38607: ARRAY
38608: PUSH
38609: LD_INT 1
38611: ARRAY
38612: PUSH
38613: LD_EXP 101
38617: PUSH
38618: LD_VAR 0 2
38622: ARRAY
38623: PUSH
38624: LD_INT 1
38626: ARRAY
38627: PUSH
38628: LD_INT 2
38630: ARRAY
38631: PUSH
38632: LD_EXP 101
38636: PUSH
38637: LD_VAR 0 2
38641: ARRAY
38642: PUSH
38643: LD_INT 1
38645: ARRAY
38646: PUSH
38647: LD_INT 3
38649: ARRAY
38650: PUSH
38651: LD_EXP 101
38655: PUSH
38656: LD_VAR 0 2
38660: ARRAY
38661: PUSH
38662: LD_INT 1
38664: ARRAY
38665: PUSH
38666: LD_INT 4
38668: ARRAY
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: LIST
38674: LIST
38675: PPUSH
38676: CALL 65515 0 2
38680: AND
38681: IFFALSE 38819
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
38683: LD_VAR 0 3
38687: PPUSH
38688: LD_EXP 101
38692: PUSH
38693: LD_VAR 0 2
38697: ARRAY
38698: PUSH
38699: LD_INT 1
38701: ARRAY
38702: PUSH
38703: LD_INT 1
38705: ARRAY
38706: PPUSH
38707: LD_EXP 101
38711: PUSH
38712: LD_VAR 0 2
38716: ARRAY
38717: PUSH
38718: LD_INT 1
38720: ARRAY
38721: PUSH
38722: LD_INT 2
38724: ARRAY
38725: PPUSH
38726: LD_EXP 101
38730: PUSH
38731: LD_VAR 0 2
38735: ARRAY
38736: PUSH
38737: LD_INT 1
38739: ARRAY
38740: PUSH
38741: LD_INT 3
38743: ARRAY
38744: PPUSH
38745: LD_EXP 101
38749: PUSH
38750: LD_VAR 0 2
38754: ARRAY
38755: PUSH
38756: LD_INT 1
38758: ARRAY
38759: PUSH
38760: LD_INT 4
38762: ARRAY
38763: PPUSH
38764: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
38768: LD_ADDR_VAR 0 4
38772: PUSH
38773: LD_EXP 101
38777: PUSH
38778: LD_VAR 0 2
38782: ARRAY
38783: PPUSH
38784: LD_INT 1
38786: PPUSH
38787: CALL_OW 3
38791: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
38792: LD_ADDR_EXP 101
38796: PUSH
38797: LD_EXP 101
38801: PPUSH
38802: LD_VAR 0 2
38806: PPUSH
38807: LD_VAR 0 4
38811: PPUSH
38812: CALL_OW 1
38816: ST_TO_ADDR
// break ;
38817: GO 38821
// end ; end ;
38819: GO 38465
38821: POP
38822: POP
// end ;
38823: GO 38397
38825: POP
38826: POP
// end ;
38827: LD_VAR 0 1
38831: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
38832: LD_INT 0
38834: PPUSH
38835: PPUSH
38836: PPUSH
// if not mc_bases then
38837: LD_EXP 80
38841: NOT
38842: IFFALSE 38846
// exit ;
38844: GO 38935
// for i = 1 to mc_bases do
38846: LD_ADDR_VAR 0 2
38850: PUSH
38851: DOUBLE
38852: LD_INT 1
38854: DEC
38855: ST_TO_ADDR
38856: LD_EXP 80
38860: PUSH
38861: FOR_TO
38862: IFFALSE 38933
// begin if mc_attack [ i ] then
38864: LD_EXP 100
38868: PUSH
38869: LD_VAR 0 2
38873: ARRAY
38874: IFFALSE 38931
// begin tmp := mc_attack [ i ] [ 1 ] ;
38876: LD_ADDR_VAR 0 3
38880: PUSH
38881: LD_EXP 100
38885: PUSH
38886: LD_VAR 0 2
38890: ARRAY
38891: PUSH
38892: LD_INT 1
38894: ARRAY
38895: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38896: LD_ADDR_EXP 100
38900: PUSH
38901: LD_EXP 100
38905: PPUSH
38906: LD_VAR 0 2
38910: PPUSH
38911: EMPTY
38912: PPUSH
38913: CALL_OW 1
38917: ST_TO_ADDR
// Attack ( tmp ) ;
38918: LD_VAR 0 3
38922: PPUSH
38923: CALL 117924 0 1
// exit ;
38927: POP
38928: POP
38929: GO 38935
// end ; end ;
38931: GO 38861
38933: POP
38934: POP
// end ;
38935: LD_VAR 0 1
38939: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
38940: LD_INT 0
38942: PPUSH
38943: PPUSH
38944: PPUSH
38945: PPUSH
38946: PPUSH
38947: PPUSH
38948: PPUSH
// if not mc_bases then
38949: LD_EXP 80
38953: NOT
38954: IFFALSE 38958
// exit ;
38956: GO 39815
// for i = 1 to mc_bases do
38958: LD_ADDR_VAR 0 2
38962: PUSH
38963: DOUBLE
38964: LD_INT 1
38966: DEC
38967: ST_TO_ADDR
38968: LD_EXP 80
38972: PUSH
38973: FOR_TO
38974: IFFALSE 39813
// begin if not mc_bases [ i ] then
38976: LD_EXP 80
38980: PUSH
38981: LD_VAR 0 2
38985: ARRAY
38986: NOT
38987: IFFALSE 38991
// continue ;
38989: GO 38973
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
38991: LD_ADDR_VAR 0 7
38995: PUSH
38996: LD_EXP 80
39000: PUSH
39001: LD_VAR 0 2
39005: ARRAY
39006: PUSH
39007: LD_INT 1
39009: ARRAY
39010: PPUSH
39011: CALL 55598 0 1
39015: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
39016: LD_ADDR_EXP 103
39020: PUSH
39021: LD_EXP 103
39025: PPUSH
39026: LD_VAR 0 2
39030: PPUSH
39031: LD_EXP 80
39035: PUSH
39036: LD_VAR 0 2
39040: ARRAY
39041: PUSH
39042: LD_INT 1
39044: ARRAY
39045: PPUSH
39046: CALL_OW 255
39050: PPUSH
39051: LD_EXP 105
39055: PUSH
39056: LD_VAR 0 2
39060: ARRAY
39061: PPUSH
39062: CALL 55563 0 2
39066: PPUSH
39067: CALL_OW 1
39071: ST_TO_ADDR
// if not mc_scan [ i ] then
39072: LD_EXP 103
39076: PUSH
39077: LD_VAR 0 2
39081: ARRAY
39082: NOT
39083: IFFALSE 39261
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
39085: LD_ADDR_EXP 123
39089: PUSH
39090: LD_EXP 123
39094: PPUSH
39095: LD_VAR 0 2
39099: PPUSH
39100: LD_INT 0
39102: PPUSH
39103: CALL_OW 1
39107: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39108: LD_ADDR_VAR 0 4
39112: PUSH
39113: LD_EXP 80
39117: PUSH
39118: LD_VAR 0 2
39122: ARRAY
39123: PPUSH
39124: LD_INT 2
39126: PUSH
39127: LD_INT 25
39129: PUSH
39130: LD_INT 5
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 25
39139: PUSH
39140: LD_INT 8
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: LD_INT 25
39149: PUSH
39150: LD_INT 9
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: EMPTY
39158: LIST
39159: LIST
39160: LIST
39161: LIST
39162: PPUSH
39163: CALL_OW 72
39167: ST_TO_ADDR
// if not tmp then
39168: LD_VAR 0 4
39172: NOT
39173: IFFALSE 39177
// continue ;
39175: GO 38973
// for j in tmp do
39177: LD_ADDR_VAR 0 3
39181: PUSH
39182: LD_VAR 0 4
39186: PUSH
39187: FOR_IN
39188: IFFALSE 39259
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
39190: LD_VAR 0 3
39194: PPUSH
39195: CALL_OW 310
39199: PPUSH
39200: CALL_OW 266
39204: PUSH
39205: LD_INT 5
39207: EQUAL
39208: PUSH
39209: LD_VAR 0 3
39213: PPUSH
39214: CALL_OW 257
39218: PUSH
39219: LD_INT 1
39221: EQUAL
39222: AND
39223: PUSH
39224: LD_VAR 0 3
39228: PPUSH
39229: CALL_OW 459
39233: NOT
39234: AND
39235: PUSH
39236: LD_VAR 0 7
39240: AND
39241: IFFALSE 39257
// ComChangeProfession ( j , class ) ;
39243: LD_VAR 0 3
39247: PPUSH
39248: LD_VAR 0 7
39252: PPUSH
39253: CALL_OW 123
39257: GO 39187
39259: POP
39260: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
39261: LD_EXP 103
39265: PUSH
39266: LD_VAR 0 2
39270: ARRAY
39271: PUSH
39272: LD_EXP 123
39276: PUSH
39277: LD_VAR 0 2
39281: ARRAY
39282: NOT
39283: AND
39284: PUSH
39285: LD_EXP 102
39289: PUSH
39290: LD_VAR 0 2
39294: ARRAY
39295: NOT
39296: AND
39297: PUSH
39298: LD_EXP 80
39302: PUSH
39303: LD_VAR 0 2
39307: ARRAY
39308: PPUSH
39309: LD_INT 50
39311: PUSH
39312: EMPTY
39313: LIST
39314: PUSH
39315: LD_INT 2
39317: PUSH
39318: LD_INT 30
39320: PUSH
39321: LD_INT 32
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: LD_INT 30
39330: PUSH
39331: LD_INT 33
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: LD_INT 30
39340: PUSH
39341: LD_INT 4
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: PUSH
39348: LD_INT 30
39350: PUSH
39351: LD_INT 5
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: LIST
39362: LIST
39363: LIST
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PPUSH
39369: CALL_OW 72
39373: PUSH
39374: LD_INT 4
39376: LESS
39377: PUSH
39378: LD_EXP 80
39382: PUSH
39383: LD_VAR 0 2
39387: ARRAY
39388: PPUSH
39389: LD_INT 3
39391: PUSH
39392: LD_INT 24
39394: PUSH
39395: LD_INT 1000
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 2
39408: PUSH
39409: LD_INT 30
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 30
39421: PUSH
39422: LD_INT 1
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: LIST
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PPUSH
39438: CALL_OW 72
39442: OR
39443: AND
39444: IFFALSE 39695
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39446: LD_ADDR_EXP 123
39450: PUSH
39451: LD_EXP 123
39455: PPUSH
39456: LD_VAR 0 2
39460: PPUSH
39461: LD_INT 1
39463: PPUSH
39464: CALL_OW 1
39468: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39469: LD_ADDR_VAR 0 4
39473: PUSH
39474: LD_EXP 80
39478: PUSH
39479: LD_VAR 0 2
39483: ARRAY
39484: PPUSH
39485: LD_INT 2
39487: PUSH
39488: LD_INT 25
39490: PUSH
39491: LD_INT 1
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: PUSH
39498: LD_INT 25
39500: PUSH
39501: LD_INT 5
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: LD_INT 25
39510: PUSH
39511: LD_INT 8
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: PUSH
39518: LD_INT 25
39520: PUSH
39521: LD_INT 9
39523: PUSH
39524: EMPTY
39525: LIST
39526: LIST
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: LIST
39532: LIST
39533: LIST
39534: PPUSH
39535: CALL_OW 72
39539: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
39540: LD_ADDR_VAR 0 4
39544: PUSH
39545: LD_VAR 0 4
39549: PUSH
39550: LD_VAR 0 4
39554: PPUSH
39555: LD_INT 18
39557: PPUSH
39558: CALL 89092 0 2
39562: DIFF
39563: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
39564: LD_VAR 0 4
39568: NOT
39569: PUSH
39570: LD_EXP 80
39574: PUSH
39575: LD_VAR 0 2
39579: ARRAY
39580: PPUSH
39581: LD_INT 2
39583: PUSH
39584: LD_INT 30
39586: PUSH
39587: LD_INT 4
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 30
39596: PUSH
39597: LD_INT 5
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: LIST
39608: PPUSH
39609: CALL_OW 72
39613: NOT
39614: AND
39615: IFFALSE 39677
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
39617: LD_ADDR_VAR 0 4
39621: PUSH
39622: LD_EXP 80
39626: PUSH
39627: LD_VAR 0 2
39631: ARRAY
39632: PPUSH
39633: LD_INT 2
39635: PUSH
39636: LD_INT 25
39638: PUSH
39639: LD_INT 2
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 25
39648: PUSH
39649: LD_INT 3
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 25
39658: PUSH
39659: LD_INT 4
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: LIST
39670: LIST
39671: PPUSH
39672: CALL_OW 72
39676: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
39677: LD_VAR 0 2
39681: PPUSH
39682: LD_VAR 0 4
39686: PPUSH
39687: CALL 122633 0 2
// exit ;
39691: POP
39692: POP
39693: GO 39815
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
39695: LD_EXP 103
39699: PUSH
39700: LD_VAR 0 2
39704: ARRAY
39705: PUSH
39706: LD_EXP 123
39710: PUSH
39711: LD_VAR 0 2
39715: ARRAY
39716: NOT
39717: AND
39718: PUSH
39719: LD_EXP 102
39723: PUSH
39724: LD_VAR 0 2
39728: ARRAY
39729: AND
39730: IFFALSE 39811
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39732: LD_ADDR_EXP 123
39736: PUSH
39737: LD_EXP 123
39741: PPUSH
39742: LD_VAR 0 2
39746: PPUSH
39747: LD_INT 1
39749: PPUSH
39750: CALL_OW 1
39754: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
39755: LD_ADDR_VAR 0 4
39759: PUSH
39760: LD_EXP 102
39764: PUSH
39765: LD_VAR 0 2
39769: ARRAY
39770: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39771: LD_ADDR_EXP 102
39775: PUSH
39776: LD_EXP 102
39780: PPUSH
39781: LD_VAR 0 2
39785: PPUSH
39786: EMPTY
39787: PPUSH
39788: CALL_OW 1
39792: ST_TO_ADDR
// Defend ( i , tmp ) ;
39793: LD_VAR 0 2
39797: PPUSH
39798: LD_VAR 0 4
39802: PPUSH
39803: CALL 123229 0 2
// exit ;
39807: POP
39808: POP
39809: GO 39815
// end ; end ;
39811: GO 38973
39813: POP
39814: POP
// end ;
39815: LD_VAR 0 1
39819: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
39820: LD_INT 0
39822: PPUSH
39823: PPUSH
39824: PPUSH
39825: PPUSH
39826: PPUSH
39827: PPUSH
39828: PPUSH
39829: PPUSH
39830: PPUSH
39831: PPUSH
39832: PPUSH
// if not mc_bases then
39833: LD_EXP 80
39837: NOT
39838: IFFALSE 39842
// exit ;
39840: GO 40929
// for i = 1 to mc_bases do
39842: LD_ADDR_VAR 0 2
39846: PUSH
39847: DOUBLE
39848: LD_INT 1
39850: DEC
39851: ST_TO_ADDR
39852: LD_EXP 80
39856: PUSH
39857: FOR_TO
39858: IFFALSE 40927
// begin tmp := mc_lab [ i ] ;
39860: LD_ADDR_VAR 0 6
39864: PUSH
39865: LD_EXP 113
39869: PUSH
39870: LD_VAR 0 2
39874: ARRAY
39875: ST_TO_ADDR
// if not tmp then
39876: LD_VAR 0 6
39880: NOT
39881: IFFALSE 39885
// continue ;
39883: GO 39857
// idle_lab := 0 ;
39885: LD_ADDR_VAR 0 11
39889: PUSH
39890: LD_INT 0
39892: ST_TO_ADDR
// for j in tmp do
39893: LD_ADDR_VAR 0 3
39897: PUSH
39898: LD_VAR 0 6
39902: PUSH
39903: FOR_IN
39904: IFFALSE 40923
// begin researching := false ;
39906: LD_ADDR_VAR 0 10
39910: PUSH
39911: LD_INT 0
39913: ST_TO_ADDR
// side := GetSide ( j ) ;
39914: LD_ADDR_VAR 0 4
39918: PUSH
39919: LD_VAR 0 3
39923: PPUSH
39924: CALL_OW 255
39928: ST_TO_ADDR
// if not mc_tech [ side ] then
39929: LD_EXP 107
39933: PUSH
39934: LD_VAR 0 4
39938: ARRAY
39939: NOT
39940: IFFALSE 39944
// continue ;
39942: GO 39903
// if BuildingStatus ( j ) = bs_idle then
39944: LD_VAR 0 3
39948: PPUSH
39949: CALL_OW 461
39953: PUSH
39954: LD_INT 2
39956: EQUAL
39957: IFFALSE 40145
// begin if idle_lab and UnitsInside ( j ) < 6 then
39959: LD_VAR 0 11
39963: PUSH
39964: LD_VAR 0 3
39968: PPUSH
39969: CALL_OW 313
39973: PUSH
39974: LD_INT 6
39976: LESS
39977: AND
39978: IFFALSE 40049
// begin tmp2 := UnitsInside ( idle_lab ) ;
39980: LD_ADDR_VAR 0 9
39984: PUSH
39985: LD_VAR 0 11
39989: PPUSH
39990: CALL_OW 313
39994: ST_TO_ADDR
// if tmp2 then
39995: LD_VAR 0 9
39999: IFFALSE 40041
// for x in tmp2 do
40001: LD_ADDR_VAR 0 7
40005: PUSH
40006: LD_VAR 0 9
40010: PUSH
40011: FOR_IN
40012: IFFALSE 40039
// begin ComExitBuilding ( x ) ;
40014: LD_VAR 0 7
40018: PPUSH
40019: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40023: LD_VAR 0 7
40027: PPUSH
40028: LD_VAR 0 3
40032: PPUSH
40033: CALL_OW 180
// end ;
40037: GO 40011
40039: POP
40040: POP
// idle_lab := 0 ;
40041: LD_ADDR_VAR 0 11
40045: PUSH
40046: LD_INT 0
40048: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
40049: LD_ADDR_VAR 0 5
40053: PUSH
40054: LD_EXP 107
40058: PUSH
40059: LD_VAR 0 4
40063: ARRAY
40064: PUSH
40065: FOR_IN
40066: IFFALSE 40126
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
40068: LD_VAR 0 3
40072: PPUSH
40073: LD_VAR 0 5
40077: PPUSH
40078: CALL_OW 430
40082: PUSH
40083: LD_VAR 0 4
40087: PPUSH
40088: LD_VAR 0 5
40092: PPUSH
40093: CALL 54668 0 2
40097: AND
40098: IFFALSE 40124
// begin researching := true ;
40100: LD_ADDR_VAR 0 10
40104: PUSH
40105: LD_INT 1
40107: ST_TO_ADDR
// ComResearch ( j , t ) ;
40108: LD_VAR 0 3
40112: PPUSH
40113: LD_VAR 0 5
40117: PPUSH
40118: CALL_OW 124
// break ;
40122: GO 40126
// end ;
40124: GO 40065
40126: POP
40127: POP
// if not researching then
40128: LD_VAR 0 10
40132: NOT
40133: IFFALSE 40145
// idle_lab := j ;
40135: LD_ADDR_VAR 0 11
40139: PUSH
40140: LD_VAR 0 3
40144: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
40145: LD_VAR 0 3
40149: PPUSH
40150: CALL_OW 461
40154: PUSH
40155: LD_INT 10
40157: EQUAL
40158: IFFALSE 40746
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
40160: LD_EXP 109
40164: PUSH
40165: LD_VAR 0 2
40169: ARRAY
40170: NOT
40171: PUSH
40172: LD_EXP 110
40176: PUSH
40177: LD_VAR 0 2
40181: ARRAY
40182: NOT
40183: AND
40184: PUSH
40185: LD_EXP 107
40189: PUSH
40190: LD_VAR 0 4
40194: ARRAY
40195: PUSH
40196: LD_INT 1
40198: GREATER
40199: AND
40200: IFFALSE 40331
// begin ComCancel ( j ) ;
40202: LD_VAR 0 3
40206: PPUSH
40207: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
40211: LD_ADDR_EXP 107
40215: PUSH
40216: LD_EXP 107
40220: PPUSH
40221: LD_VAR 0 4
40225: PPUSH
40226: LD_EXP 107
40230: PUSH
40231: LD_VAR 0 4
40235: ARRAY
40236: PPUSH
40237: LD_EXP 107
40241: PUSH
40242: LD_VAR 0 4
40246: ARRAY
40247: PUSH
40248: LD_INT 1
40250: MINUS
40251: PPUSH
40252: LD_EXP 107
40256: PUSH
40257: LD_VAR 0 4
40261: ARRAY
40262: PPUSH
40263: LD_INT 0
40265: PPUSH
40266: CALL 58192 0 4
40270: PPUSH
40271: CALL_OW 1
40275: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
40276: LD_ADDR_EXP 107
40280: PUSH
40281: LD_EXP 107
40285: PPUSH
40286: LD_VAR 0 4
40290: PPUSH
40291: LD_EXP 107
40295: PUSH
40296: LD_VAR 0 4
40300: ARRAY
40301: PPUSH
40302: LD_EXP 107
40306: PUSH
40307: LD_VAR 0 4
40311: ARRAY
40312: PPUSH
40313: LD_INT 1
40315: PPUSH
40316: LD_INT 0
40318: PPUSH
40319: CALL 58192 0 4
40323: PPUSH
40324: CALL_OW 1
40328: ST_TO_ADDR
// continue ;
40329: GO 39903
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
40331: LD_EXP 109
40335: PUSH
40336: LD_VAR 0 2
40340: ARRAY
40341: PUSH
40342: LD_EXP 110
40346: PUSH
40347: LD_VAR 0 2
40351: ARRAY
40352: NOT
40353: AND
40354: IFFALSE 40481
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
40356: LD_ADDR_EXP 110
40360: PUSH
40361: LD_EXP 110
40365: PPUSH
40366: LD_VAR 0 2
40370: PUSH
40371: LD_EXP 110
40375: PUSH
40376: LD_VAR 0 2
40380: ARRAY
40381: PUSH
40382: LD_INT 1
40384: PLUS
40385: PUSH
40386: EMPTY
40387: LIST
40388: LIST
40389: PPUSH
40390: LD_EXP 109
40394: PUSH
40395: LD_VAR 0 2
40399: ARRAY
40400: PUSH
40401: LD_INT 1
40403: ARRAY
40404: PPUSH
40405: CALL 58774 0 3
40409: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
40410: LD_EXP 109
40414: PUSH
40415: LD_VAR 0 2
40419: ARRAY
40420: PUSH
40421: LD_INT 1
40423: ARRAY
40424: PPUSH
40425: LD_INT 112
40427: PPUSH
40428: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
40432: LD_ADDR_VAR 0 9
40436: PUSH
40437: LD_EXP 109
40441: PUSH
40442: LD_VAR 0 2
40446: ARRAY
40447: PPUSH
40448: LD_INT 1
40450: PPUSH
40451: CALL_OW 3
40455: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
40456: LD_ADDR_EXP 109
40460: PUSH
40461: LD_EXP 109
40465: PPUSH
40466: LD_VAR 0 2
40470: PPUSH
40471: LD_VAR 0 9
40475: PPUSH
40476: CALL_OW 1
40480: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
40481: LD_EXP 109
40485: PUSH
40486: LD_VAR 0 2
40490: ARRAY
40491: PUSH
40492: LD_EXP 110
40496: PUSH
40497: LD_VAR 0 2
40501: ARRAY
40502: AND
40503: PUSH
40504: LD_EXP 110
40508: PUSH
40509: LD_VAR 0 2
40513: ARRAY
40514: PUSH
40515: LD_INT 1
40517: ARRAY
40518: PPUSH
40519: CALL_OW 310
40523: NOT
40524: AND
40525: PUSH
40526: LD_VAR 0 3
40530: PPUSH
40531: CALL_OW 313
40535: PUSH
40536: LD_INT 6
40538: EQUAL
40539: AND
40540: IFFALSE 40596
// begin tmp2 := UnitsInside ( j ) ;
40542: LD_ADDR_VAR 0 9
40546: PUSH
40547: LD_VAR 0 3
40551: PPUSH
40552: CALL_OW 313
40556: ST_TO_ADDR
// if tmp2 = 6 then
40557: LD_VAR 0 9
40561: PUSH
40562: LD_INT 6
40564: EQUAL
40565: IFFALSE 40596
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
40567: LD_VAR 0 9
40571: PUSH
40572: LD_INT 1
40574: ARRAY
40575: PPUSH
40576: LD_INT 112
40578: PPUSH
40579: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
40583: LD_VAR 0 9
40587: PUSH
40588: LD_INT 1
40590: ARRAY
40591: PPUSH
40592: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
40596: LD_EXP 110
40600: PUSH
40601: LD_VAR 0 2
40605: ARRAY
40606: PUSH
40607: LD_EXP 110
40611: PUSH
40612: LD_VAR 0 2
40616: ARRAY
40617: PUSH
40618: LD_INT 1
40620: ARRAY
40621: PPUSH
40622: CALL_OW 314
40626: NOT
40627: AND
40628: PUSH
40629: LD_EXP 110
40633: PUSH
40634: LD_VAR 0 2
40638: ARRAY
40639: PUSH
40640: LD_INT 1
40642: ARRAY
40643: PPUSH
40644: CALL_OW 310
40648: NOT
40649: AND
40650: IFFALSE 40676
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
40652: LD_EXP 110
40656: PUSH
40657: LD_VAR 0 2
40661: ARRAY
40662: PUSH
40663: LD_INT 1
40665: ARRAY
40666: PPUSH
40667: LD_VAR 0 3
40671: PPUSH
40672: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
40676: LD_EXP 110
40680: PUSH
40681: LD_VAR 0 2
40685: ARRAY
40686: PUSH
40687: LD_INT 1
40689: ARRAY
40690: PPUSH
40691: CALL_OW 310
40695: PUSH
40696: LD_EXP 110
40700: PUSH
40701: LD_VAR 0 2
40705: ARRAY
40706: PUSH
40707: LD_INT 1
40709: ARRAY
40710: PPUSH
40711: CALL_OW 310
40715: PPUSH
40716: CALL_OW 461
40720: PUSH
40721: LD_INT 3
40723: NONEQUAL
40724: AND
40725: IFFALSE 40746
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
40727: LD_EXP 110
40731: PUSH
40732: LD_VAR 0 2
40736: ARRAY
40737: PUSH
40738: LD_INT 1
40740: ARRAY
40741: PPUSH
40742: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
40746: LD_VAR 0 3
40750: PPUSH
40751: CALL_OW 461
40755: PUSH
40756: LD_INT 6
40758: EQUAL
40759: PUSH
40760: LD_VAR 0 6
40764: PUSH
40765: LD_INT 1
40767: GREATER
40768: AND
40769: IFFALSE 40921
// begin sci := [ ] ;
40771: LD_ADDR_VAR 0 8
40775: PUSH
40776: EMPTY
40777: ST_TO_ADDR
// for x in ( tmp diff j ) do
40778: LD_ADDR_VAR 0 7
40782: PUSH
40783: LD_VAR 0 6
40787: PUSH
40788: LD_VAR 0 3
40792: DIFF
40793: PUSH
40794: FOR_IN
40795: IFFALSE 40847
// begin if sci = 6 then
40797: LD_VAR 0 8
40801: PUSH
40802: LD_INT 6
40804: EQUAL
40805: IFFALSE 40809
// break ;
40807: GO 40847
// if BuildingStatus ( x ) = bs_idle then
40809: LD_VAR 0 7
40813: PPUSH
40814: CALL_OW 461
40818: PUSH
40819: LD_INT 2
40821: EQUAL
40822: IFFALSE 40845
// sci := sci ^ UnitsInside ( x ) ;
40824: LD_ADDR_VAR 0 8
40828: PUSH
40829: LD_VAR 0 8
40833: PUSH
40834: LD_VAR 0 7
40838: PPUSH
40839: CALL_OW 313
40843: ADD
40844: ST_TO_ADDR
// end ;
40845: GO 40794
40847: POP
40848: POP
// if not sci then
40849: LD_VAR 0 8
40853: NOT
40854: IFFALSE 40858
// continue ;
40856: GO 39903
// for x in sci do
40858: LD_ADDR_VAR 0 7
40862: PUSH
40863: LD_VAR 0 8
40867: PUSH
40868: FOR_IN
40869: IFFALSE 40919
// if IsInUnit ( x ) and not HasTask ( x ) then
40871: LD_VAR 0 7
40875: PPUSH
40876: CALL_OW 310
40880: PUSH
40881: LD_VAR 0 7
40885: PPUSH
40886: CALL_OW 314
40890: NOT
40891: AND
40892: IFFALSE 40917
// begin ComExitBuilding ( x ) ;
40894: LD_VAR 0 7
40898: PPUSH
40899: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40903: LD_VAR 0 7
40907: PPUSH
40908: LD_VAR 0 3
40912: PPUSH
40913: CALL_OW 180
// end ;
40917: GO 40868
40919: POP
40920: POP
// end ; end ;
40921: GO 39903
40923: POP
40924: POP
// end ;
40925: GO 39857
40927: POP
40928: POP
// end ;
40929: LD_VAR 0 1
40933: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
40934: LD_INT 0
40936: PPUSH
40937: PPUSH
// if not mc_bases then
40938: LD_EXP 80
40942: NOT
40943: IFFALSE 40947
// exit ;
40945: GO 41028
// for i = 1 to mc_bases do
40947: LD_ADDR_VAR 0 2
40951: PUSH
40952: DOUBLE
40953: LD_INT 1
40955: DEC
40956: ST_TO_ADDR
40957: LD_EXP 80
40961: PUSH
40962: FOR_TO
40963: IFFALSE 41026
// if mc_mines [ i ] and mc_miners [ i ] then
40965: LD_EXP 93
40969: PUSH
40970: LD_VAR 0 2
40974: ARRAY
40975: PUSH
40976: LD_EXP 94
40980: PUSH
40981: LD_VAR 0 2
40985: ARRAY
40986: AND
40987: IFFALSE 41024
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
40989: LD_EXP 94
40993: PUSH
40994: LD_VAR 0 2
40998: ARRAY
40999: PUSH
41000: LD_INT 1
41002: ARRAY
41003: PPUSH
41004: CALL_OW 255
41008: PPUSH
41009: LD_EXP 93
41013: PUSH
41014: LD_VAR 0 2
41018: ARRAY
41019: PPUSH
41020: CALL 55751 0 2
41024: GO 40962
41026: POP
41027: POP
// end ;
41028: LD_VAR 0 1
41032: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
41033: LD_INT 0
41035: PPUSH
41036: PPUSH
41037: PPUSH
41038: PPUSH
41039: PPUSH
41040: PPUSH
41041: PPUSH
41042: PPUSH
// if not mc_bases or not mc_parking then
41043: LD_EXP 80
41047: NOT
41048: PUSH
41049: LD_EXP 104
41053: NOT
41054: OR
41055: IFFALSE 41059
// exit ;
41057: GO 41797
// for i = 1 to mc_bases do
41059: LD_ADDR_VAR 0 2
41063: PUSH
41064: DOUBLE
41065: LD_INT 1
41067: DEC
41068: ST_TO_ADDR
41069: LD_EXP 80
41073: PUSH
41074: FOR_TO
41075: IFFALSE 41795
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
41077: LD_EXP 80
41081: PUSH
41082: LD_VAR 0 2
41086: ARRAY
41087: NOT
41088: PUSH
41089: LD_EXP 104
41093: PUSH
41094: LD_VAR 0 2
41098: ARRAY
41099: NOT
41100: OR
41101: IFFALSE 41105
// continue ;
41103: GO 41074
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
41105: LD_ADDR_VAR 0 5
41109: PUSH
41110: LD_EXP 80
41114: PUSH
41115: LD_VAR 0 2
41119: ARRAY
41120: PUSH
41121: LD_INT 1
41123: ARRAY
41124: PPUSH
41125: CALL_OW 255
41129: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
41130: LD_ADDR_VAR 0 6
41134: PUSH
41135: LD_EXP 80
41139: PUSH
41140: LD_VAR 0 2
41144: ARRAY
41145: PPUSH
41146: LD_INT 30
41148: PUSH
41149: LD_INT 3
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PPUSH
41156: CALL_OW 72
41160: ST_TO_ADDR
// if not fac then
41161: LD_VAR 0 6
41165: NOT
41166: IFFALSE 41217
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41168: LD_ADDR_VAR 0 6
41172: PUSH
41173: LD_EXP 80
41177: PUSH
41178: LD_VAR 0 2
41182: ARRAY
41183: PPUSH
41184: LD_INT 2
41186: PUSH
41187: LD_INT 30
41189: PUSH
41190: LD_INT 0
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: LD_INT 30
41199: PUSH
41200: LD_INT 1
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: LIST
41211: PPUSH
41212: CALL_OW 72
41216: ST_TO_ADDR
// if not fac then
41217: LD_VAR 0 6
41221: NOT
41222: IFFALSE 41226
// continue ;
41224: GO 41074
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41226: LD_ADDR_VAR 0 7
41230: PUSH
41231: LD_EXP 104
41235: PUSH
41236: LD_VAR 0 2
41240: ARRAY
41241: PPUSH
41242: LD_INT 22
41244: PUSH
41245: LD_VAR 0 5
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 21
41256: PUSH
41257: LD_INT 2
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: LD_INT 3
41266: PUSH
41267: LD_INT 60
41269: PUSH
41270: EMPTY
41271: LIST
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 3
41279: PUSH
41280: LD_INT 24
41282: PUSH
41283: LD_INT 1000
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: PUSH
41294: EMPTY
41295: LIST
41296: LIST
41297: LIST
41298: LIST
41299: PPUSH
41300: CALL_OW 70
41304: ST_TO_ADDR
// for j in fac do
41305: LD_ADDR_VAR 0 3
41309: PUSH
41310: LD_VAR 0 6
41314: PUSH
41315: FOR_IN
41316: IFFALSE 41411
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41318: LD_ADDR_VAR 0 7
41322: PUSH
41323: LD_VAR 0 7
41327: PUSH
41328: LD_INT 22
41330: PUSH
41331: LD_VAR 0 5
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 91
41342: PUSH
41343: LD_VAR 0 3
41347: PUSH
41348: LD_INT 15
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: LIST
41355: PUSH
41356: LD_INT 21
41358: PUSH
41359: LD_INT 2
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: PUSH
41366: LD_INT 3
41368: PUSH
41369: LD_INT 60
41371: PUSH
41372: EMPTY
41373: LIST
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 3
41381: PUSH
41382: LD_INT 24
41384: PUSH
41385: LD_INT 1000
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: LIST
41400: LIST
41401: LIST
41402: PPUSH
41403: CALL_OW 69
41407: UNION
41408: ST_TO_ADDR
41409: GO 41315
41411: POP
41412: POP
// if not vehs then
41413: LD_VAR 0 7
41417: NOT
41418: IFFALSE 41444
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41420: LD_ADDR_EXP 92
41424: PUSH
41425: LD_EXP 92
41429: PPUSH
41430: LD_VAR 0 2
41434: PPUSH
41435: EMPTY
41436: PPUSH
41437: CALL_OW 1
41441: ST_TO_ADDR
// continue ;
41442: GO 41074
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
41444: LD_ADDR_VAR 0 8
41448: PUSH
41449: LD_EXP 80
41453: PUSH
41454: LD_VAR 0 2
41458: ARRAY
41459: PPUSH
41460: LD_INT 30
41462: PUSH
41463: LD_INT 3
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PPUSH
41470: CALL_OW 72
41474: ST_TO_ADDR
// if tmp then
41475: LD_VAR 0 8
41479: IFFALSE 41582
// begin for j in tmp do
41481: LD_ADDR_VAR 0 3
41485: PUSH
41486: LD_VAR 0 8
41490: PUSH
41491: FOR_IN
41492: IFFALSE 41580
// for k in UnitsInside ( j ) do
41494: LD_ADDR_VAR 0 4
41498: PUSH
41499: LD_VAR 0 3
41503: PPUSH
41504: CALL_OW 313
41508: PUSH
41509: FOR_IN
41510: IFFALSE 41576
// if k then
41512: LD_VAR 0 4
41516: IFFALSE 41574
// if not k in mc_repair_vehicle [ i ] then
41518: LD_VAR 0 4
41522: PUSH
41523: LD_EXP 92
41527: PUSH
41528: LD_VAR 0 2
41532: ARRAY
41533: IN
41534: NOT
41535: IFFALSE 41574
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
41537: LD_ADDR_EXP 92
41541: PUSH
41542: LD_EXP 92
41546: PPUSH
41547: LD_VAR 0 2
41551: PPUSH
41552: LD_EXP 92
41556: PUSH
41557: LD_VAR 0 2
41561: ARRAY
41562: PUSH
41563: LD_VAR 0 4
41567: UNION
41568: PPUSH
41569: CALL_OW 1
41573: ST_TO_ADDR
41574: GO 41509
41576: POP
41577: POP
41578: GO 41491
41580: POP
41581: POP
// end ; if not mc_repair_vehicle [ i ] then
41582: LD_EXP 92
41586: PUSH
41587: LD_VAR 0 2
41591: ARRAY
41592: NOT
41593: IFFALSE 41597
// continue ;
41595: GO 41074
// for j in mc_repair_vehicle [ i ] do
41597: LD_ADDR_VAR 0 3
41601: PUSH
41602: LD_EXP 92
41606: PUSH
41607: LD_VAR 0 2
41611: ARRAY
41612: PUSH
41613: FOR_IN
41614: IFFALSE 41791
// begin if GetClass ( j ) <> 3 then
41616: LD_VAR 0 3
41620: PPUSH
41621: CALL_OW 257
41625: PUSH
41626: LD_INT 3
41628: NONEQUAL
41629: IFFALSE 41670
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
41631: LD_ADDR_EXP 92
41635: PUSH
41636: LD_EXP 92
41640: PPUSH
41641: LD_VAR 0 2
41645: PPUSH
41646: LD_EXP 92
41650: PUSH
41651: LD_VAR 0 2
41655: ARRAY
41656: PUSH
41657: LD_VAR 0 3
41661: DIFF
41662: PPUSH
41663: CALL_OW 1
41667: ST_TO_ADDR
// continue ;
41668: GO 41613
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41670: LD_VAR 0 3
41674: PPUSH
41675: CALL_OW 311
41679: NOT
41680: PUSH
41681: LD_VAR 0 3
41685: PUSH
41686: LD_EXP 83
41690: PUSH
41691: LD_VAR 0 2
41695: ARRAY
41696: PUSH
41697: LD_INT 1
41699: ARRAY
41700: IN
41701: NOT
41702: AND
41703: PUSH
41704: LD_VAR 0 3
41708: PUSH
41709: LD_EXP 83
41713: PUSH
41714: LD_VAR 0 2
41718: ARRAY
41719: PUSH
41720: LD_INT 2
41722: ARRAY
41723: IN
41724: NOT
41725: AND
41726: IFFALSE 41789
// begin if IsInUnit ( j ) then
41728: LD_VAR 0 3
41732: PPUSH
41733: CALL_OW 310
41737: IFFALSE 41750
// ComExitBuilding ( j ) else
41739: LD_VAR 0 3
41743: PPUSH
41744: CALL_OW 122
41748: GO 41789
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
41750: LD_VAR 0 3
41754: PPUSH
41755: LD_VAR 0 7
41759: PUSH
41760: LD_INT 1
41762: ARRAY
41763: PPUSH
41764: CALL 93588 0 2
41768: NOT
41769: IFFALSE 41789
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
41771: LD_VAR 0 3
41775: PPUSH
41776: LD_VAR 0 7
41780: PUSH
41781: LD_INT 1
41783: ARRAY
41784: PPUSH
41785: CALL_OW 129
// end ; end ;
41789: GO 41613
41791: POP
41792: POP
// end ;
41793: GO 41074
41795: POP
41796: POP
// end ;
41797: LD_VAR 0 1
41801: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
41802: LD_INT 0
41804: PPUSH
41805: PPUSH
41806: PPUSH
41807: PPUSH
41808: PPUSH
41809: PPUSH
41810: PPUSH
41811: PPUSH
41812: PPUSH
41813: PPUSH
41814: PPUSH
// if not mc_bases then
41815: LD_EXP 80
41819: NOT
41820: IFFALSE 41824
// exit ;
41822: GO 42626
// for i = 1 to mc_bases do
41824: LD_ADDR_VAR 0 2
41828: PUSH
41829: DOUBLE
41830: LD_INT 1
41832: DEC
41833: ST_TO_ADDR
41834: LD_EXP 80
41838: PUSH
41839: FOR_TO
41840: IFFALSE 42624
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
41842: LD_EXP 108
41846: PUSH
41847: LD_VAR 0 2
41851: ARRAY
41852: NOT
41853: PUSH
41854: LD_EXP 83
41858: PUSH
41859: LD_VAR 0 2
41863: ARRAY
41864: PUSH
41865: LD_INT 1
41867: ARRAY
41868: OR
41869: PUSH
41870: LD_EXP 83
41874: PUSH
41875: LD_VAR 0 2
41879: ARRAY
41880: PUSH
41881: LD_INT 2
41883: ARRAY
41884: OR
41885: PUSH
41886: LD_EXP 106
41890: PUSH
41891: LD_VAR 0 2
41895: ARRAY
41896: PPUSH
41897: LD_INT 1
41899: PPUSH
41900: CALL_OW 325
41904: NOT
41905: OR
41906: PUSH
41907: LD_EXP 103
41911: PUSH
41912: LD_VAR 0 2
41916: ARRAY
41917: OR
41918: IFFALSE 41922
// continue ;
41920: GO 41839
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
41922: LD_ADDR_VAR 0 8
41926: PUSH
41927: LD_EXP 80
41931: PUSH
41932: LD_VAR 0 2
41936: ARRAY
41937: PPUSH
41938: LD_INT 25
41940: PUSH
41941: LD_INT 4
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 50
41950: PUSH
41951: EMPTY
41952: LIST
41953: PUSH
41954: LD_INT 3
41956: PUSH
41957: LD_INT 60
41959: PUSH
41960: EMPTY
41961: LIST
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: LIST
41971: PPUSH
41972: CALL_OW 72
41976: PUSH
41977: LD_EXP 84
41981: PUSH
41982: LD_VAR 0 2
41986: ARRAY
41987: DIFF
41988: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41989: LD_ADDR_VAR 0 9
41993: PUSH
41994: LD_EXP 80
41998: PUSH
41999: LD_VAR 0 2
42003: ARRAY
42004: PPUSH
42005: LD_INT 2
42007: PUSH
42008: LD_INT 30
42010: PUSH
42011: LD_INT 0
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 30
42020: PUSH
42021: LD_INT 1
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: LIST
42032: PPUSH
42033: CALL_OW 72
42037: ST_TO_ADDR
// if not tmp or not dep then
42038: LD_VAR 0 8
42042: NOT
42043: PUSH
42044: LD_VAR 0 9
42048: NOT
42049: OR
42050: IFFALSE 42054
// continue ;
42052: GO 41839
// side := GetSide ( tmp [ 1 ] ) ;
42054: LD_ADDR_VAR 0 11
42058: PUSH
42059: LD_VAR 0 8
42063: PUSH
42064: LD_INT 1
42066: ARRAY
42067: PPUSH
42068: CALL_OW 255
42072: ST_TO_ADDR
// dep := dep [ 1 ] ;
42073: LD_ADDR_VAR 0 9
42077: PUSH
42078: LD_VAR 0 9
42082: PUSH
42083: LD_INT 1
42085: ARRAY
42086: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
42087: LD_ADDR_VAR 0 7
42091: PUSH
42092: LD_EXP 108
42096: PUSH
42097: LD_VAR 0 2
42101: ARRAY
42102: PPUSH
42103: LD_INT 22
42105: PUSH
42106: LD_INT 0
42108: PUSH
42109: EMPTY
42110: LIST
42111: LIST
42112: PUSH
42113: LD_INT 25
42115: PUSH
42116: LD_INT 12
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: PPUSH
42127: CALL_OW 70
42131: PUSH
42132: LD_INT 22
42134: PUSH
42135: LD_INT 0
42137: PUSH
42138: EMPTY
42139: LIST
42140: LIST
42141: PUSH
42142: LD_INT 25
42144: PUSH
42145: LD_INT 12
42147: PUSH
42148: EMPTY
42149: LIST
42150: LIST
42151: PUSH
42152: LD_INT 91
42154: PUSH
42155: LD_VAR 0 9
42159: PUSH
42160: LD_INT 20
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: LIST
42167: PUSH
42168: EMPTY
42169: LIST
42170: LIST
42171: LIST
42172: PPUSH
42173: CALL_OW 69
42177: UNION
42178: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
42179: LD_ADDR_VAR 0 10
42183: PUSH
42184: LD_EXP 108
42188: PUSH
42189: LD_VAR 0 2
42193: ARRAY
42194: PPUSH
42195: LD_INT 81
42197: PUSH
42198: LD_VAR 0 11
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PPUSH
42207: CALL_OW 70
42211: ST_TO_ADDR
// if not apes or danger_at_area then
42212: LD_VAR 0 7
42216: NOT
42217: PUSH
42218: LD_VAR 0 10
42222: OR
42223: IFFALSE 42273
// begin if mc_taming [ i ] then
42225: LD_EXP 111
42229: PUSH
42230: LD_VAR 0 2
42234: ARRAY
42235: IFFALSE 42271
// begin MC_Reset ( i , 121 ) ;
42237: LD_VAR 0 2
42241: PPUSH
42242: LD_INT 121
42244: PPUSH
42245: CALL 27189 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42249: LD_ADDR_EXP 111
42253: PUSH
42254: LD_EXP 111
42258: PPUSH
42259: LD_VAR 0 2
42263: PPUSH
42264: EMPTY
42265: PPUSH
42266: CALL_OW 1
42270: ST_TO_ADDR
// end ; continue ;
42271: GO 41839
// end ; for j in tmp do
42273: LD_ADDR_VAR 0 3
42277: PUSH
42278: LD_VAR 0 8
42282: PUSH
42283: FOR_IN
42284: IFFALSE 42620
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
42286: LD_VAR 0 3
42290: PUSH
42291: LD_EXP 111
42295: PUSH
42296: LD_VAR 0 2
42300: ARRAY
42301: IN
42302: NOT
42303: PUSH
42304: LD_EXP 111
42308: PUSH
42309: LD_VAR 0 2
42313: ARRAY
42314: PUSH
42315: LD_INT 3
42317: LESS
42318: AND
42319: IFFALSE 42377
// begin SetTag ( j , 121 ) ;
42321: LD_VAR 0 3
42325: PPUSH
42326: LD_INT 121
42328: PPUSH
42329: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
42333: LD_ADDR_EXP 111
42337: PUSH
42338: LD_EXP 111
42342: PPUSH
42343: LD_VAR 0 2
42347: PUSH
42348: LD_EXP 111
42352: PUSH
42353: LD_VAR 0 2
42357: ARRAY
42358: PUSH
42359: LD_INT 1
42361: PLUS
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PPUSH
42367: LD_VAR 0 3
42371: PPUSH
42372: CALL 58774 0 3
42376: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
42377: LD_VAR 0 3
42381: PUSH
42382: LD_EXP 111
42386: PUSH
42387: LD_VAR 0 2
42391: ARRAY
42392: IN
42393: IFFALSE 42618
// begin if GetClass ( j ) <> 4 then
42395: LD_VAR 0 3
42399: PPUSH
42400: CALL_OW 257
42404: PUSH
42405: LD_INT 4
42407: NONEQUAL
42408: IFFALSE 42461
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
42410: LD_ADDR_EXP 111
42414: PUSH
42415: LD_EXP 111
42419: PPUSH
42420: LD_VAR 0 2
42424: PPUSH
42425: LD_EXP 111
42429: PUSH
42430: LD_VAR 0 2
42434: ARRAY
42435: PUSH
42436: LD_VAR 0 3
42440: DIFF
42441: PPUSH
42442: CALL_OW 1
42446: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42447: LD_VAR 0 3
42451: PPUSH
42452: LD_INT 0
42454: PPUSH
42455: CALL_OW 109
// continue ;
42459: GO 42283
// end ; if IsInUnit ( j ) then
42461: LD_VAR 0 3
42465: PPUSH
42466: CALL_OW 310
42470: IFFALSE 42481
// ComExitBuilding ( j ) ;
42472: LD_VAR 0 3
42476: PPUSH
42477: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
42481: LD_ADDR_VAR 0 6
42485: PUSH
42486: LD_VAR 0 7
42490: PPUSH
42491: LD_VAR 0 3
42495: PPUSH
42496: CALL_OW 74
42500: ST_TO_ADDR
// if not ape then
42501: LD_VAR 0 6
42505: NOT
42506: IFFALSE 42510
// break ;
42508: GO 42620
// x := GetX ( ape ) ;
42510: LD_ADDR_VAR 0 4
42514: PUSH
42515: LD_VAR 0 6
42519: PPUSH
42520: CALL_OW 250
42524: ST_TO_ADDR
// y := GetY ( ape ) ;
42525: LD_ADDR_VAR 0 5
42529: PUSH
42530: LD_VAR 0 6
42534: PPUSH
42535: CALL_OW 251
42539: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
42540: LD_VAR 0 4
42544: PPUSH
42545: LD_VAR 0 5
42549: PPUSH
42550: CALL_OW 488
42554: NOT
42555: PUSH
42556: LD_VAR 0 11
42560: PPUSH
42561: LD_VAR 0 4
42565: PPUSH
42566: LD_VAR 0 5
42570: PPUSH
42571: LD_INT 20
42573: PPUSH
42574: CALL 60038 0 4
42578: PUSH
42579: LD_INT 4
42581: ARRAY
42582: OR
42583: IFFALSE 42587
// break ;
42585: GO 42620
// if not HasTask ( j ) then
42587: LD_VAR 0 3
42591: PPUSH
42592: CALL_OW 314
42596: NOT
42597: IFFALSE 42618
// ComTameXY ( j , x , y ) ;
42599: LD_VAR 0 3
42603: PPUSH
42604: LD_VAR 0 4
42608: PPUSH
42609: LD_VAR 0 5
42613: PPUSH
42614: CALL_OW 131
// end ; end ;
42618: GO 42283
42620: POP
42621: POP
// end ;
42622: GO 41839
42624: POP
42625: POP
// end ;
42626: LD_VAR 0 1
42630: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
42631: LD_INT 0
42633: PPUSH
42634: PPUSH
42635: PPUSH
42636: PPUSH
42637: PPUSH
42638: PPUSH
42639: PPUSH
42640: PPUSH
// if not mc_bases then
42641: LD_EXP 80
42645: NOT
42646: IFFALSE 42650
// exit ;
42648: GO 43276
// for i = 1 to mc_bases do
42650: LD_ADDR_VAR 0 2
42654: PUSH
42655: DOUBLE
42656: LD_INT 1
42658: DEC
42659: ST_TO_ADDR
42660: LD_EXP 80
42664: PUSH
42665: FOR_TO
42666: IFFALSE 43274
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
42668: LD_EXP 109
42672: PUSH
42673: LD_VAR 0 2
42677: ARRAY
42678: NOT
42679: PUSH
42680: LD_EXP 109
42684: PUSH
42685: LD_VAR 0 2
42689: ARRAY
42690: PPUSH
42691: LD_INT 25
42693: PUSH
42694: LD_INT 12
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PPUSH
42701: CALL_OW 72
42705: NOT
42706: OR
42707: IFFALSE 42711
// continue ;
42709: GO 42665
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
42711: LD_ADDR_VAR 0 5
42715: PUSH
42716: LD_EXP 109
42720: PUSH
42721: LD_VAR 0 2
42725: ARRAY
42726: PUSH
42727: LD_INT 1
42729: ARRAY
42730: PPUSH
42731: CALL_OW 255
42735: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
42736: LD_VAR 0 5
42740: PPUSH
42741: LD_INT 2
42743: PPUSH
42744: CALL_OW 325
42748: IFFALSE 43001
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42750: LD_ADDR_VAR 0 4
42754: PUSH
42755: LD_EXP 109
42759: PUSH
42760: LD_VAR 0 2
42764: ARRAY
42765: PPUSH
42766: LD_INT 25
42768: PUSH
42769: LD_INT 16
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PPUSH
42776: CALL_OW 72
42780: ST_TO_ADDR
// if tmp < 6 then
42781: LD_VAR 0 4
42785: PUSH
42786: LD_INT 6
42788: LESS
42789: IFFALSE 43001
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42791: LD_ADDR_VAR 0 6
42795: PUSH
42796: LD_EXP 80
42800: PUSH
42801: LD_VAR 0 2
42805: ARRAY
42806: PPUSH
42807: LD_INT 2
42809: PUSH
42810: LD_INT 30
42812: PUSH
42813: LD_INT 0
42815: PUSH
42816: EMPTY
42817: LIST
42818: LIST
42819: PUSH
42820: LD_INT 30
42822: PUSH
42823: LD_INT 1
42825: PUSH
42826: EMPTY
42827: LIST
42828: LIST
42829: PUSH
42830: EMPTY
42831: LIST
42832: LIST
42833: LIST
42834: PPUSH
42835: CALL_OW 72
42839: ST_TO_ADDR
// if depot then
42840: LD_VAR 0 6
42844: IFFALSE 43001
// begin selected := 0 ;
42846: LD_ADDR_VAR 0 7
42850: PUSH
42851: LD_INT 0
42853: ST_TO_ADDR
// for j in depot do
42854: LD_ADDR_VAR 0 3
42858: PUSH
42859: LD_VAR 0 6
42863: PUSH
42864: FOR_IN
42865: IFFALSE 42896
// begin if UnitsInside ( j ) < 6 then
42867: LD_VAR 0 3
42871: PPUSH
42872: CALL_OW 313
42876: PUSH
42877: LD_INT 6
42879: LESS
42880: IFFALSE 42894
// begin selected := j ;
42882: LD_ADDR_VAR 0 7
42886: PUSH
42887: LD_VAR 0 3
42891: ST_TO_ADDR
// break ;
42892: GO 42896
// end ; end ;
42894: GO 42864
42896: POP
42897: POP
// if selected then
42898: LD_VAR 0 7
42902: IFFALSE 43001
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42904: LD_ADDR_VAR 0 3
42908: PUSH
42909: LD_EXP 109
42913: PUSH
42914: LD_VAR 0 2
42918: ARRAY
42919: PPUSH
42920: LD_INT 25
42922: PUSH
42923: LD_INT 12
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PPUSH
42930: CALL_OW 72
42934: PUSH
42935: FOR_IN
42936: IFFALSE 42999
// if not HasTask ( j ) then
42938: LD_VAR 0 3
42942: PPUSH
42943: CALL_OW 314
42947: NOT
42948: IFFALSE 42997
// begin if not IsInUnit ( j ) then
42950: LD_VAR 0 3
42954: PPUSH
42955: CALL_OW 310
42959: NOT
42960: IFFALSE 42976
// ComEnterUnit ( j , selected ) ;
42962: LD_VAR 0 3
42966: PPUSH
42967: LD_VAR 0 7
42971: PPUSH
42972: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
42976: LD_VAR 0 3
42980: PPUSH
42981: LD_INT 16
42983: PPUSH
42984: CALL_OW 183
// AddComExitBuilding ( j ) ;
42988: LD_VAR 0 3
42992: PPUSH
42993: CALL_OW 182
// end ;
42997: GO 42935
42999: POP
43000: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
43001: LD_VAR 0 5
43005: PPUSH
43006: LD_INT 11
43008: PPUSH
43009: CALL_OW 325
43013: IFFALSE 43272
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
43015: LD_ADDR_VAR 0 4
43019: PUSH
43020: LD_EXP 109
43024: PUSH
43025: LD_VAR 0 2
43029: ARRAY
43030: PPUSH
43031: LD_INT 25
43033: PUSH
43034: LD_INT 16
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: PPUSH
43041: CALL_OW 72
43045: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
43046: LD_VAR 0 4
43050: PUSH
43051: LD_INT 6
43053: GREATEREQUAL
43054: PUSH
43055: LD_VAR 0 5
43059: PPUSH
43060: LD_INT 2
43062: PPUSH
43063: CALL_OW 325
43067: NOT
43068: OR
43069: IFFALSE 43272
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43071: LD_ADDR_VAR 0 8
43075: PUSH
43076: LD_EXP 80
43080: PUSH
43081: LD_VAR 0 2
43085: ARRAY
43086: PPUSH
43087: LD_INT 2
43089: PUSH
43090: LD_INT 30
43092: PUSH
43093: LD_INT 4
43095: PUSH
43096: EMPTY
43097: LIST
43098: LIST
43099: PUSH
43100: LD_INT 30
43102: PUSH
43103: LD_INT 5
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: PUSH
43110: EMPTY
43111: LIST
43112: LIST
43113: LIST
43114: PPUSH
43115: CALL_OW 72
43119: ST_TO_ADDR
// if barracks then
43120: LD_VAR 0 8
43124: IFFALSE 43272
// begin selected := 0 ;
43126: LD_ADDR_VAR 0 7
43130: PUSH
43131: LD_INT 0
43133: ST_TO_ADDR
// for j in barracks do
43134: LD_ADDR_VAR 0 3
43138: PUSH
43139: LD_VAR 0 8
43143: PUSH
43144: FOR_IN
43145: IFFALSE 43176
// begin if UnitsInside ( j ) < 6 then
43147: LD_VAR 0 3
43151: PPUSH
43152: CALL_OW 313
43156: PUSH
43157: LD_INT 6
43159: LESS
43160: IFFALSE 43174
// begin selected := j ;
43162: LD_ADDR_VAR 0 7
43166: PUSH
43167: LD_VAR 0 3
43171: ST_TO_ADDR
// break ;
43172: GO 43176
// end ; end ;
43174: GO 43144
43176: POP
43177: POP
// if selected then
43178: LD_VAR 0 7
43182: IFFALSE 43272
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
43184: LD_ADDR_VAR 0 3
43188: PUSH
43189: LD_EXP 109
43193: PUSH
43194: LD_VAR 0 2
43198: ARRAY
43199: PPUSH
43200: LD_INT 25
43202: PUSH
43203: LD_INT 12
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PPUSH
43210: CALL_OW 72
43214: PUSH
43215: FOR_IN
43216: IFFALSE 43270
// if not IsInUnit ( j ) and not HasTask ( j ) then
43218: LD_VAR 0 3
43222: PPUSH
43223: CALL_OW 310
43227: NOT
43228: PUSH
43229: LD_VAR 0 3
43233: PPUSH
43234: CALL_OW 314
43238: NOT
43239: AND
43240: IFFALSE 43268
// begin ComEnterUnit ( j , selected ) ;
43242: LD_VAR 0 3
43246: PPUSH
43247: LD_VAR 0 7
43251: PPUSH
43252: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
43256: LD_VAR 0 3
43260: PPUSH
43261: LD_INT 15
43263: PPUSH
43264: CALL_OW 183
// end ;
43268: GO 43215
43270: POP
43271: POP
// end ; end ; end ; end ; end ;
43272: GO 42665
43274: POP
43275: POP
// end ;
43276: LD_VAR 0 1
43280: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
43281: LD_INT 0
43283: PPUSH
43284: PPUSH
43285: PPUSH
43286: PPUSH
// if not mc_bases then
43287: LD_EXP 80
43291: NOT
43292: IFFALSE 43296
// exit ;
43294: GO 43474
// for i = 1 to mc_bases do
43296: LD_ADDR_VAR 0 2
43300: PUSH
43301: DOUBLE
43302: LD_INT 1
43304: DEC
43305: ST_TO_ADDR
43306: LD_EXP 80
43310: PUSH
43311: FOR_TO
43312: IFFALSE 43472
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
43314: LD_ADDR_VAR 0 4
43318: PUSH
43319: LD_EXP 80
43323: PUSH
43324: LD_VAR 0 2
43328: ARRAY
43329: PPUSH
43330: LD_INT 25
43332: PUSH
43333: LD_INT 9
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PPUSH
43340: CALL_OW 72
43344: ST_TO_ADDR
// if not tmp then
43345: LD_VAR 0 4
43349: NOT
43350: IFFALSE 43354
// continue ;
43352: GO 43311
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
43354: LD_EXP 106
43358: PUSH
43359: LD_VAR 0 2
43363: ARRAY
43364: PPUSH
43365: LD_INT 29
43367: PPUSH
43368: CALL_OW 325
43372: NOT
43373: PUSH
43374: LD_EXP 106
43378: PUSH
43379: LD_VAR 0 2
43383: ARRAY
43384: PPUSH
43385: LD_INT 28
43387: PPUSH
43388: CALL_OW 325
43392: NOT
43393: AND
43394: IFFALSE 43398
// continue ;
43396: GO 43311
// for j in tmp do
43398: LD_ADDR_VAR 0 3
43402: PUSH
43403: LD_VAR 0 4
43407: PUSH
43408: FOR_IN
43409: IFFALSE 43468
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
43411: LD_VAR 0 3
43415: PUSH
43416: LD_EXP 83
43420: PUSH
43421: LD_VAR 0 2
43425: ARRAY
43426: PUSH
43427: LD_INT 1
43429: ARRAY
43430: IN
43431: NOT
43432: PUSH
43433: LD_VAR 0 3
43437: PUSH
43438: LD_EXP 83
43442: PUSH
43443: LD_VAR 0 2
43447: ARRAY
43448: PUSH
43449: LD_INT 2
43451: ARRAY
43452: IN
43453: NOT
43454: AND
43455: IFFALSE 43466
// ComSpaceTimeShoot ( j ) ;
43457: LD_VAR 0 3
43461: PPUSH
43462: CALL 54759 0 1
43466: GO 43408
43468: POP
43469: POP
// end ;
43470: GO 43311
43472: POP
43473: POP
// end ;
43474: LD_VAR 0 1
43478: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
43479: LD_INT 0
43481: PPUSH
43482: PPUSH
43483: PPUSH
43484: PPUSH
43485: PPUSH
43486: PPUSH
43487: PPUSH
43488: PPUSH
43489: PPUSH
// if not mc_bases then
43490: LD_EXP 80
43494: NOT
43495: IFFALSE 43499
// exit ;
43497: GO 44121
// for i = 1 to mc_bases do
43499: LD_ADDR_VAR 0 2
43503: PUSH
43504: DOUBLE
43505: LD_INT 1
43507: DEC
43508: ST_TO_ADDR
43509: LD_EXP 80
43513: PUSH
43514: FOR_TO
43515: IFFALSE 44119
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
43517: LD_EXP 115
43521: PUSH
43522: LD_VAR 0 2
43526: ARRAY
43527: NOT
43528: PUSH
43529: LD_INT 38
43531: PPUSH
43532: LD_EXP 106
43536: PUSH
43537: LD_VAR 0 2
43541: ARRAY
43542: PPUSH
43543: CALL_OW 321
43547: PUSH
43548: LD_INT 2
43550: NONEQUAL
43551: OR
43552: IFFALSE 43556
// continue ;
43554: GO 43514
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
43556: LD_ADDR_VAR 0 8
43560: PUSH
43561: LD_EXP 80
43565: PUSH
43566: LD_VAR 0 2
43570: ARRAY
43571: PPUSH
43572: LD_INT 30
43574: PUSH
43575: LD_INT 34
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PPUSH
43582: CALL_OW 72
43586: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
43587: LD_ADDR_VAR 0 9
43591: PUSH
43592: LD_EXP 80
43596: PUSH
43597: LD_VAR 0 2
43601: ARRAY
43602: PPUSH
43603: LD_INT 25
43605: PUSH
43606: LD_INT 4
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PPUSH
43613: CALL_OW 72
43617: PPUSH
43618: LD_INT 0
43620: PPUSH
43621: CALL 89092 0 2
43625: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
43626: LD_VAR 0 9
43630: NOT
43631: PUSH
43632: LD_VAR 0 8
43636: NOT
43637: OR
43638: PUSH
43639: LD_EXP 80
43643: PUSH
43644: LD_VAR 0 2
43648: ARRAY
43649: PPUSH
43650: LD_INT 124
43652: PPUSH
43653: CALL 89092 0 2
43657: OR
43658: IFFALSE 43662
// continue ;
43660: GO 43514
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
43662: LD_EXP 116
43666: PUSH
43667: LD_VAR 0 2
43671: ARRAY
43672: PUSH
43673: LD_EXP 115
43677: PUSH
43678: LD_VAR 0 2
43682: ARRAY
43683: LESS
43684: PUSH
43685: LD_EXP 116
43689: PUSH
43690: LD_VAR 0 2
43694: ARRAY
43695: PUSH
43696: LD_VAR 0 8
43700: LESS
43701: AND
43702: IFFALSE 44117
// begin tmp := sci [ 1 ] ;
43704: LD_ADDR_VAR 0 7
43708: PUSH
43709: LD_VAR 0 9
43713: PUSH
43714: LD_INT 1
43716: ARRAY
43717: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
43718: LD_VAR 0 7
43722: PPUSH
43723: LD_INT 124
43725: PPUSH
43726: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
43730: LD_ADDR_VAR 0 3
43734: PUSH
43735: DOUBLE
43736: LD_EXP 115
43740: PUSH
43741: LD_VAR 0 2
43745: ARRAY
43746: INC
43747: ST_TO_ADDR
43748: LD_EXP 115
43752: PUSH
43753: LD_VAR 0 2
43757: ARRAY
43758: PUSH
43759: FOR_DOWNTO
43760: IFFALSE 44103
// begin if IsInUnit ( tmp ) then
43762: LD_VAR 0 7
43766: PPUSH
43767: CALL_OW 310
43771: IFFALSE 43782
// ComExitBuilding ( tmp ) ;
43773: LD_VAR 0 7
43777: PPUSH
43778: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
43782: LD_INT 35
43784: PPUSH
43785: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
43789: LD_VAR 0 7
43793: PPUSH
43794: CALL_OW 310
43798: NOT
43799: PUSH
43800: LD_VAR 0 7
43804: PPUSH
43805: CALL_OW 314
43809: NOT
43810: AND
43811: IFFALSE 43782
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
43813: LD_ADDR_VAR 0 6
43817: PUSH
43818: LD_VAR 0 7
43822: PPUSH
43823: CALL_OW 250
43827: PUSH
43828: LD_VAR 0 7
43832: PPUSH
43833: CALL_OW 251
43837: PUSH
43838: EMPTY
43839: LIST
43840: LIST
43841: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
43842: LD_INT 35
43844: PPUSH
43845: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
43849: LD_ADDR_VAR 0 4
43853: PUSH
43854: LD_EXP 115
43858: PUSH
43859: LD_VAR 0 2
43863: ARRAY
43864: PUSH
43865: LD_VAR 0 3
43869: ARRAY
43870: PUSH
43871: LD_INT 1
43873: ARRAY
43874: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
43875: LD_ADDR_VAR 0 5
43879: PUSH
43880: LD_EXP 115
43884: PUSH
43885: LD_VAR 0 2
43889: ARRAY
43890: PUSH
43891: LD_VAR 0 3
43895: ARRAY
43896: PUSH
43897: LD_INT 2
43899: ARRAY
43900: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
43901: LD_VAR 0 7
43905: PPUSH
43906: LD_INT 10
43908: PPUSH
43909: CALL 61739 0 2
43913: PUSH
43914: LD_INT 4
43916: ARRAY
43917: IFFALSE 43955
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
43919: LD_VAR 0 7
43923: PPUSH
43924: LD_VAR 0 6
43928: PUSH
43929: LD_INT 1
43931: ARRAY
43932: PPUSH
43933: LD_VAR 0 6
43937: PUSH
43938: LD_INT 2
43940: ARRAY
43941: PPUSH
43942: CALL_OW 111
// wait ( 0 0$10 ) ;
43946: LD_INT 350
43948: PPUSH
43949: CALL_OW 67
// end else
43953: GO 43981
// begin ComMoveXY ( tmp , x , y ) ;
43955: LD_VAR 0 7
43959: PPUSH
43960: LD_VAR 0 4
43964: PPUSH
43965: LD_VAR 0 5
43969: PPUSH
43970: CALL_OW 111
// wait ( 0 0$3 ) ;
43974: LD_INT 105
43976: PPUSH
43977: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
43981: LD_VAR 0 7
43985: PPUSH
43986: LD_VAR 0 4
43990: PPUSH
43991: LD_VAR 0 5
43995: PPUSH
43996: CALL_OW 307
44000: IFFALSE 43842
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
44002: LD_VAR 0 7
44006: PPUSH
44007: LD_VAR 0 4
44011: PPUSH
44012: LD_VAR 0 5
44016: PPUSH
44017: LD_VAR 0 8
44021: PUSH
44022: LD_VAR 0 3
44026: ARRAY
44027: PPUSH
44028: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
44032: LD_INT 35
44034: PPUSH
44035: CALL_OW 67
// until not HasTask ( tmp ) ;
44039: LD_VAR 0 7
44043: PPUSH
44044: CALL_OW 314
44048: NOT
44049: IFFALSE 44032
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
44051: LD_ADDR_EXP 116
44055: PUSH
44056: LD_EXP 116
44060: PPUSH
44061: LD_VAR 0 2
44065: PUSH
44066: LD_EXP 116
44070: PUSH
44071: LD_VAR 0 2
44075: ARRAY
44076: PUSH
44077: LD_INT 1
44079: PLUS
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: PPUSH
44085: LD_VAR 0 8
44089: PUSH
44090: LD_VAR 0 3
44094: ARRAY
44095: PPUSH
44096: CALL 58774 0 3
44100: ST_TO_ADDR
// end ;
44101: GO 43759
44103: POP
44104: POP
// MC_Reset ( i , 124 ) ;
44105: LD_VAR 0 2
44109: PPUSH
44110: LD_INT 124
44112: PPUSH
44113: CALL 27189 0 2
// end ; end ;
44117: GO 43514
44119: POP
44120: POP
// end ;
44121: LD_VAR 0 1
44125: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
44126: LD_INT 0
44128: PPUSH
44129: PPUSH
44130: PPUSH
// if not mc_bases then
44131: LD_EXP 80
44135: NOT
44136: IFFALSE 44140
// exit ;
44138: GO 44746
// for i = 1 to mc_bases do
44140: LD_ADDR_VAR 0 2
44144: PUSH
44145: DOUBLE
44146: LD_INT 1
44148: DEC
44149: ST_TO_ADDR
44150: LD_EXP 80
44154: PUSH
44155: FOR_TO
44156: IFFALSE 44744
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44158: LD_ADDR_VAR 0 3
44162: PUSH
44163: LD_EXP 80
44167: PUSH
44168: LD_VAR 0 2
44172: ARRAY
44173: PPUSH
44174: LD_INT 25
44176: PUSH
44177: LD_INT 4
44179: PUSH
44180: EMPTY
44181: LIST
44182: LIST
44183: PPUSH
44184: CALL_OW 72
44188: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44189: LD_VAR 0 3
44193: NOT
44194: PUSH
44195: LD_EXP 117
44199: PUSH
44200: LD_VAR 0 2
44204: ARRAY
44205: NOT
44206: OR
44207: PUSH
44208: LD_EXP 80
44212: PUSH
44213: LD_VAR 0 2
44217: ARRAY
44218: PPUSH
44219: LD_INT 2
44221: PUSH
44222: LD_INT 30
44224: PUSH
44225: LD_INT 0
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 30
44234: PUSH
44235: LD_INT 1
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: LIST
44246: PPUSH
44247: CALL_OW 72
44251: NOT
44252: OR
44253: IFFALSE 44303
// begin if mc_deposits_finder [ i ] then
44255: LD_EXP 118
44259: PUSH
44260: LD_VAR 0 2
44264: ARRAY
44265: IFFALSE 44301
// begin MC_Reset ( i , 125 ) ;
44267: LD_VAR 0 2
44271: PPUSH
44272: LD_INT 125
44274: PPUSH
44275: CALL 27189 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44279: LD_ADDR_EXP 118
44283: PUSH
44284: LD_EXP 118
44288: PPUSH
44289: LD_VAR 0 2
44293: PPUSH
44294: EMPTY
44295: PPUSH
44296: CALL_OW 1
44300: ST_TO_ADDR
// end ; continue ;
44301: GO 44155
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
44303: LD_EXP 117
44307: PUSH
44308: LD_VAR 0 2
44312: ARRAY
44313: PUSH
44314: LD_INT 1
44316: ARRAY
44317: PUSH
44318: LD_INT 3
44320: ARRAY
44321: PUSH
44322: LD_INT 1
44324: EQUAL
44325: PUSH
44326: LD_INT 20
44328: PPUSH
44329: LD_EXP 106
44333: PUSH
44334: LD_VAR 0 2
44338: ARRAY
44339: PPUSH
44340: CALL_OW 321
44344: PUSH
44345: LD_INT 2
44347: NONEQUAL
44348: AND
44349: IFFALSE 44399
// begin if mc_deposits_finder [ i ] then
44351: LD_EXP 118
44355: PUSH
44356: LD_VAR 0 2
44360: ARRAY
44361: IFFALSE 44397
// begin MC_Reset ( i , 125 ) ;
44363: LD_VAR 0 2
44367: PPUSH
44368: LD_INT 125
44370: PPUSH
44371: CALL 27189 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44375: LD_ADDR_EXP 118
44379: PUSH
44380: LD_EXP 118
44384: PPUSH
44385: LD_VAR 0 2
44389: PPUSH
44390: EMPTY
44391: PPUSH
44392: CALL_OW 1
44396: ST_TO_ADDR
// end ; continue ;
44397: GO 44155
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
44399: LD_EXP 117
44403: PUSH
44404: LD_VAR 0 2
44408: ARRAY
44409: PUSH
44410: LD_INT 1
44412: ARRAY
44413: PUSH
44414: LD_INT 1
44416: ARRAY
44417: PPUSH
44418: LD_EXP 117
44422: PUSH
44423: LD_VAR 0 2
44427: ARRAY
44428: PUSH
44429: LD_INT 1
44431: ARRAY
44432: PUSH
44433: LD_INT 2
44435: ARRAY
44436: PPUSH
44437: LD_EXP 106
44441: PUSH
44442: LD_VAR 0 2
44446: ARRAY
44447: PPUSH
44448: CALL_OW 440
44452: IFFALSE 44495
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
44454: LD_ADDR_EXP 117
44458: PUSH
44459: LD_EXP 117
44463: PPUSH
44464: LD_VAR 0 2
44468: PPUSH
44469: LD_EXP 117
44473: PUSH
44474: LD_VAR 0 2
44478: ARRAY
44479: PPUSH
44480: LD_INT 1
44482: PPUSH
44483: CALL_OW 3
44487: PPUSH
44488: CALL_OW 1
44492: ST_TO_ADDR
44493: GO 44742
// begin if not mc_deposits_finder [ i ] then
44495: LD_EXP 118
44499: PUSH
44500: LD_VAR 0 2
44504: ARRAY
44505: NOT
44506: IFFALSE 44558
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
44508: LD_ADDR_EXP 118
44512: PUSH
44513: LD_EXP 118
44517: PPUSH
44518: LD_VAR 0 2
44522: PPUSH
44523: LD_VAR 0 3
44527: PUSH
44528: LD_INT 1
44530: ARRAY
44531: PUSH
44532: EMPTY
44533: LIST
44534: PPUSH
44535: CALL_OW 1
44539: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
44540: LD_VAR 0 3
44544: PUSH
44545: LD_INT 1
44547: ARRAY
44548: PPUSH
44549: LD_INT 125
44551: PPUSH
44552: CALL_OW 109
// end else
44556: GO 44742
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
44558: LD_EXP 118
44562: PUSH
44563: LD_VAR 0 2
44567: ARRAY
44568: PUSH
44569: LD_INT 1
44571: ARRAY
44572: PPUSH
44573: CALL_OW 310
44577: IFFALSE 44600
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
44579: LD_EXP 118
44583: PUSH
44584: LD_VAR 0 2
44588: ARRAY
44589: PUSH
44590: LD_INT 1
44592: ARRAY
44593: PPUSH
44594: CALL_OW 122
44598: GO 44742
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
44600: LD_EXP 118
44604: PUSH
44605: LD_VAR 0 2
44609: ARRAY
44610: PUSH
44611: LD_INT 1
44613: ARRAY
44614: PPUSH
44615: CALL_OW 314
44619: NOT
44620: PUSH
44621: LD_EXP 118
44625: PUSH
44626: LD_VAR 0 2
44630: ARRAY
44631: PUSH
44632: LD_INT 1
44634: ARRAY
44635: PPUSH
44636: LD_EXP 117
44640: PUSH
44641: LD_VAR 0 2
44645: ARRAY
44646: PUSH
44647: LD_INT 1
44649: ARRAY
44650: PUSH
44651: LD_INT 1
44653: ARRAY
44654: PPUSH
44655: LD_EXP 117
44659: PUSH
44660: LD_VAR 0 2
44664: ARRAY
44665: PUSH
44666: LD_INT 1
44668: ARRAY
44669: PUSH
44670: LD_INT 2
44672: ARRAY
44673: PPUSH
44674: CALL_OW 297
44678: PUSH
44679: LD_INT 6
44681: GREATER
44682: AND
44683: IFFALSE 44742
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
44685: LD_EXP 118
44689: PUSH
44690: LD_VAR 0 2
44694: ARRAY
44695: PUSH
44696: LD_INT 1
44698: ARRAY
44699: PPUSH
44700: LD_EXP 117
44704: PUSH
44705: LD_VAR 0 2
44709: ARRAY
44710: PUSH
44711: LD_INT 1
44713: ARRAY
44714: PUSH
44715: LD_INT 1
44717: ARRAY
44718: PPUSH
44719: LD_EXP 117
44723: PUSH
44724: LD_VAR 0 2
44728: ARRAY
44729: PUSH
44730: LD_INT 1
44732: ARRAY
44733: PUSH
44734: LD_INT 2
44736: ARRAY
44737: PPUSH
44738: CALL_OW 111
// end ; end ; end ;
44742: GO 44155
44744: POP
44745: POP
// end ;
44746: LD_VAR 0 1
44750: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
44751: LD_INT 0
44753: PPUSH
44754: PPUSH
44755: PPUSH
44756: PPUSH
44757: PPUSH
44758: PPUSH
44759: PPUSH
44760: PPUSH
44761: PPUSH
44762: PPUSH
44763: PPUSH
// if not mc_bases then
44764: LD_EXP 80
44768: NOT
44769: IFFALSE 44773
// exit ;
44771: GO 45713
// for i = 1 to mc_bases do
44773: LD_ADDR_VAR 0 2
44777: PUSH
44778: DOUBLE
44779: LD_INT 1
44781: DEC
44782: ST_TO_ADDR
44783: LD_EXP 80
44787: PUSH
44788: FOR_TO
44789: IFFALSE 45711
// begin if not mc_bases [ i ] or mc_scan [ i ] then
44791: LD_EXP 80
44795: PUSH
44796: LD_VAR 0 2
44800: ARRAY
44801: NOT
44802: PUSH
44803: LD_EXP 103
44807: PUSH
44808: LD_VAR 0 2
44812: ARRAY
44813: OR
44814: IFFALSE 44818
// continue ;
44816: GO 44788
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
44818: LD_ADDR_VAR 0 7
44822: PUSH
44823: LD_EXP 80
44827: PUSH
44828: LD_VAR 0 2
44832: ARRAY
44833: PUSH
44834: LD_INT 1
44836: ARRAY
44837: PPUSH
44838: CALL_OW 248
44842: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
44843: LD_VAR 0 7
44847: PUSH
44848: LD_INT 3
44850: EQUAL
44851: PUSH
44852: LD_EXP 99
44856: PUSH
44857: LD_VAR 0 2
44861: ARRAY
44862: PUSH
44863: LD_EXP 102
44867: PUSH
44868: LD_VAR 0 2
44872: ARRAY
44873: UNION
44874: PPUSH
44875: LD_INT 33
44877: PUSH
44878: LD_INT 2
44880: PUSH
44881: EMPTY
44882: LIST
44883: LIST
44884: PPUSH
44885: CALL_OW 72
44889: NOT
44890: OR
44891: IFFALSE 44895
// continue ;
44893: GO 44788
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
44895: LD_ADDR_VAR 0 9
44899: PUSH
44900: LD_EXP 80
44904: PUSH
44905: LD_VAR 0 2
44909: ARRAY
44910: PPUSH
44911: LD_INT 30
44913: PUSH
44914: LD_INT 36
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PPUSH
44921: CALL_OW 72
44925: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
44926: LD_ADDR_VAR 0 10
44930: PUSH
44931: LD_EXP 99
44935: PUSH
44936: LD_VAR 0 2
44940: ARRAY
44941: PPUSH
44942: LD_INT 34
44944: PUSH
44945: LD_INT 31
44947: PUSH
44948: EMPTY
44949: LIST
44950: LIST
44951: PPUSH
44952: CALL_OW 72
44956: ST_TO_ADDR
// if not cts and not mcts then
44957: LD_VAR 0 9
44961: NOT
44962: PUSH
44963: LD_VAR 0 10
44967: NOT
44968: AND
44969: IFFALSE 44973
// continue ;
44971: GO 44788
// x := cts ;
44973: LD_ADDR_VAR 0 11
44977: PUSH
44978: LD_VAR 0 9
44982: ST_TO_ADDR
// if not x then
44983: LD_VAR 0 11
44987: NOT
44988: IFFALSE 45000
// x := mcts ;
44990: LD_ADDR_VAR 0 11
44994: PUSH
44995: LD_VAR 0 10
44999: ST_TO_ADDR
// if not x then
45000: LD_VAR 0 11
45004: NOT
45005: IFFALSE 45009
// continue ;
45007: GO 44788
// if mc_remote_driver [ i ] then
45009: LD_EXP 120
45013: PUSH
45014: LD_VAR 0 2
45018: ARRAY
45019: IFFALSE 45406
// for j in mc_remote_driver [ i ] do
45021: LD_ADDR_VAR 0 3
45025: PUSH
45026: LD_EXP 120
45030: PUSH
45031: LD_VAR 0 2
45035: ARRAY
45036: PUSH
45037: FOR_IN
45038: IFFALSE 45404
// begin if GetClass ( j ) <> 3 then
45040: LD_VAR 0 3
45044: PPUSH
45045: CALL_OW 257
45049: PUSH
45050: LD_INT 3
45052: NONEQUAL
45053: IFFALSE 45106
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
45055: LD_ADDR_EXP 120
45059: PUSH
45060: LD_EXP 120
45064: PPUSH
45065: LD_VAR 0 2
45069: PPUSH
45070: LD_EXP 120
45074: PUSH
45075: LD_VAR 0 2
45079: ARRAY
45080: PUSH
45081: LD_VAR 0 3
45085: DIFF
45086: PPUSH
45087: CALL_OW 1
45091: ST_TO_ADDR
// SetTag ( j , 0 ) ;
45092: LD_VAR 0 3
45096: PPUSH
45097: LD_INT 0
45099: PPUSH
45100: CALL_OW 109
// continue ;
45104: GO 45037
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
45106: LD_EXP 99
45110: PUSH
45111: LD_VAR 0 2
45115: ARRAY
45116: PPUSH
45117: LD_INT 34
45119: PUSH
45120: LD_INT 31
45122: PUSH
45123: EMPTY
45124: LIST
45125: LIST
45126: PUSH
45127: LD_INT 58
45129: PUSH
45130: EMPTY
45131: LIST
45132: PUSH
45133: EMPTY
45134: LIST
45135: LIST
45136: PPUSH
45137: CALL_OW 72
45141: PUSH
45142: LD_VAR 0 3
45146: PPUSH
45147: CALL 89127 0 1
45151: NOT
45152: AND
45153: IFFALSE 45224
// begin if IsInUnit ( j ) then
45155: LD_VAR 0 3
45159: PPUSH
45160: CALL_OW 310
45164: IFFALSE 45175
// ComExitBuilding ( j ) ;
45166: LD_VAR 0 3
45170: PPUSH
45171: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
45175: LD_VAR 0 3
45179: PPUSH
45180: LD_EXP 99
45184: PUSH
45185: LD_VAR 0 2
45189: ARRAY
45190: PPUSH
45191: LD_INT 34
45193: PUSH
45194: LD_INT 31
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: PUSH
45201: LD_INT 58
45203: PUSH
45204: EMPTY
45205: LIST
45206: PUSH
45207: EMPTY
45208: LIST
45209: LIST
45210: PPUSH
45211: CALL_OW 72
45215: PUSH
45216: LD_INT 1
45218: ARRAY
45219: PPUSH
45220: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
45224: LD_VAR 0 3
45228: PPUSH
45229: CALL_OW 310
45233: NOT
45234: PUSH
45235: LD_VAR 0 3
45239: PPUSH
45240: CALL_OW 310
45244: PPUSH
45245: CALL_OW 266
45249: PUSH
45250: LD_INT 36
45252: NONEQUAL
45253: PUSH
45254: LD_VAR 0 3
45258: PPUSH
45259: CALL 89127 0 1
45263: NOT
45264: AND
45265: OR
45266: IFFALSE 45402
// begin if IsInUnit ( j ) then
45268: LD_VAR 0 3
45272: PPUSH
45273: CALL_OW 310
45277: IFFALSE 45288
// ComExitBuilding ( j ) ;
45279: LD_VAR 0 3
45283: PPUSH
45284: CALL_OW 122
// ct := 0 ;
45288: LD_ADDR_VAR 0 8
45292: PUSH
45293: LD_INT 0
45295: ST_TO_ADDR
// for k in x do
45296: LD_ADDR_VAR 0 4
45300: PUSH
45301: LD_VAR 0 11
45305: PUSH
45306: FOR_IN
45307: IFFALSE 45380
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
45309: LD_VAR 0 4
45313: PPUSH
45314: CALL_OW 264
45318: PUSH
45319: LD_INT 31
45321: EQUAL
45322: PUSH
45323: LD_VAR 0 4
45327: PPUSH
45328: CALL_OW 311
45332: NOT
45333: AND
45334: PUSH
45335: LD_VAR 0 4
45339: PPUSH
45340: CALL_OW 266
45344: PUSH
45345: LD_INT 36
45347: EQUAL
45348: PUSH
45349: LD_VAR 0 4
45353: PPUSH
45354: CALL_OW 313
45358: PUSH
45359: LD_INT 3
45361: LESS
45362: AND
45363: OR
45364: IFFALSE 45378
// begin ct := k ;
45366: LD_ADDR_VAR 0 8
45370: PUSH
45371: LD_VAR 0 4
45375: ST_TO_ADDR
// break ;
45376: GO 45380
// end ;
45378: GO 45306
45380: POP
45381: POP
// if ct then
45382: LD_VAR 0 8
45386: IFFALSE 45402
// ComEnterUnit ( j , ct ) ;
45388: LD_VAR 0 3
45392: PPUSH
45393: LD_VAR 0 8
45397: PPUSH
45398: CALL_OW 120
// end ; end ;
45402: GO 45037
45404: POP
45405: POP
// places := 0 ;
45406: LD_ADDR_VAR 0 5
45410: PUSH
45411: LD_INT 0
45413: ST_TO_ADDR
// for j = 1 to x do
45414: LD_ADDR_VAR 0 3
45418: PUSH
45419: DOUBLE
45420: LD_INT 1
45422: DEC
45423: ST_TO_ADDR
45424: LD_VAR 0 11
45428: PUSH
45429: FOR_TO
45430: IFFALSE 45506
// if GetWeapon ( x [ j ] ) = ar_control_tower then
45432: LD_VAR 0 11
45436: PUSH
45437: LD_VAR 0 3
45441: ARRAY
45442: PPUSH
45443: CALL_OW 264
45447: PUSH
45448: LD_INT 31
45450: EQUAL
45451: IFFALSE 45469
// places := places + 1 else
45453: LD_ADDR_VAR 0 5
45457: PUSH
45458: LD_VAR 0 5
45462: PUSH
45463: LD_INT 1
45465: PLUS
45466: ST_TO_ADDR
45467: GO 45504
// if GetBType ( x [ j ] ) = b_control_tower then
45469: LD_VAR 0 11
45473: PUSH
45474: LD_VAR 0 3
45478: ARRAY
45479: PPUSH
45480: CALL_OW 266
45484: PUSH
45485: LD_INT 36
45487: EQUAL
45488: IFFALSE 45504
// places := places + 3 ;
45490: LD_ADDR_VAR 0 5
45494: PUSH
45495: LD_VAR 0 5
45499: PUSH
45500: LD_INT 3
45502: PLUS
45503: ST_TO_ADDR
45504: GO 45429
45506: POP
45507: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
45508: LD_VAR 0 5
45512: PUSH
45513: LD_INT 0
45515: EQUAL
45516: PUSH
45517: LD_VAR 0 5
45521: PUSH
45522: LD_EXP 120
45526: PUSH
45527: LD_VAR 0 2
45531: ARRAY
45532: LESSEQUAL
45533: OR
45534: IFFALSE 45538
// continue ;
45536: GO 44788
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
45538: LD_ADDR_VAR 0 6
45542: PUSH
45543: LD_EXP 80
45547: PUSH
45548: LD_VAR 0 2
45552: ARRAY
45553: PPUSH
45554: LD_INT 25
45556: PUSH
45557: LD_INT 3
45559: PUSH
45560: EMPTY
45561: LIST
45562: LIST
45563: PPUSH
45564: CALL_OW 72
45568: PUSH
45569: LD_EXP 120
45573: PUSH
45574: LD_VAR 0 2
45578: ARRAY
45579: DIFF
45580: PPUSH
45581: LD_INT 3
45583: PPUSH
45584: CALL 90027 0 2
45588: ST_TO_ADDR
// for j in tmp do
45589: LD_ADDR_VAR 0 3
45593: PUSH
45594: LD_VAR 0 6
45598: PUSH
45599: FOR_IN
45600: IFFALSE 45635
// if GetTag ( j ) > 0 then
45602: LD_VAR 0 3
45606: PPUSH
45607: CALL_OW 110
45611: PUSH
45612: LD_INT 0
45614: GREATER
45615: IFFALSE 45633
// tmp := tmp diff j ;
45617: LD_ADDR_VAR 0 6
45621: PUSH
45622: LD_VAR 0 6
45626: PUSH
45627: LD_VAR 0 3
45631: DIFF
45632: ST_TO_ADDR
45633: GO 45599
45635: POP
45636: POP
// if not tmp then
45637: LD_VAR 0 6
45641: NOT
45642: IFFALSE 45646
// continue ;
45644: GO 44788
// if places then
45646: LD_VAR 0 5
45650: IFFALSE 45709
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
45652: LD_ADDR_EXP 120
45656: PUSH
45657: LD_EXP 120
45661: PPUSH
45662: LD_VAR 0 2
45666: PPUSH
45667: LD_EXP 120
45671: PUSH
45672: LD_VAR 0 2
45676: ARRAY
45677: PUSH
45678: LD_VAR 0 6
45682: PUSH
45683: LD_INT 1
45685: ARRAY
45686: UNION
45687: PPUSH
45688: CALL_OW 1
45692: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
45693: LD_VAR 0 6
45697: PUSH
45698: LD_INT 1
45700: ARRAY
45701: PPUSH
45702: LD_INT 126
45704: PPUSH
45705: CALL_OW 109
// end ; end ;
45709: GO 44788
45711: POP
45712: POP
// end ;
45713: LD_VAR 0 1
45717: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
45718: LD_INT 0
45720: PPUSH
45721: PPUSH
45722: PPUSH
45723: PPUSH
45724: PPUSH
45725: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
45726: LD_VAR 0 1
45730: NOT
45731: PUSH
45732: LD_VAR 0 2
45736: NOT
45737: OR
45738: PUSH
45739: LD_VAR 0 3
45743: NOT
45744: OR
45745: PUSH
45746: LD_VAR 0 4
45750: PUSH
45751: LD_INT 1
45753: PUSH
45754: LD_INT 2
45756: PUSH
45757: LD_INT 3
45759: PUSH
45760: LD_INT 4
45762: PUSH
45763: LD_INT 5
45765: PUSH
45766: LD_INT 8
45768: PUSH
45769: LD_INT 9
45771: PUSH
45772: LD_INT 15
45774: PUSH
45775: LD_INT 16
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: LIST
45782: LIST
45783: LIST
45784: LIST
45785: LIST
45786: LIST
45787: LIST
45788: IN
45789: NOT
45790: OR
45791: IFFALSE 45795
// exit ;
45793: GO 46653
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
45795: LD_ADDR_VAR 0 2
45799: PUSH
45800: LD_VAR 0 2
45804: PPUSH
45805: LD_INT 21
45807: PUSH
45808: LD_INT 3
45810: PUSH
45811: EMPTY
45812: LIST
45813: LIST
45814: PUSH
45815: LD_INT 24
45817: PUSH
45818: LD_INT 250
45820: PUSH
45821: EMPTY
45822: LIST
45823: LIST
45824: PUSH
45825: EMPTY
45826: LIST
45827: LIST
45828: PPUSH
45829: CALL_OW 72
45833: ST_TO_ADDR
// case class of 1 , 15 :
45834: LD_VAR 0 4
45838: PUSH
45839: LD_INT 1
45841: DOUBLE
45842: EQUAL
45843: IFTRUE 45853
45845: LD_INT 15
45847: DOUBLE
45848: EQUAL
45849: IFTRUE 45853
45851: GO 45938
45853: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
45854: LD_ADDR_VAR 0 8
45858: PUSH
45859: LD_VAR 0 2
45863: PPUSH
45864: LD_INT 2
45866: PUSH
45867: LD_INT 30
45869: PUSH
45870: LD_INT 32
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: PUSH
45877: LD_INT 30
45879: PUSH
45880: LD_INT 31
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: LIST
45891: PPUSH
45892: CALL_OW 72
45896: PUSH
45897: LD_VAR 0 2
45901: PPUSH
45902: LD_INT 2
45904: PUSH
45905: LD_INT 30
45907: PUSH
45908: LD_INT 4
45910: PUSH
45911: EMPTY
45912: LIST
45913: LIST
45914: PUSH
45915: LD_INT 30
45917: PUSH
45918: LD_INT 5
45920: PUSH
45921: EMPTY
45922: LIST
45923: LIST
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: LIST
45929: PPUSH
45930: CALL_OW 72
45934: ADD
45935: ST_TO_ADDR
45936: GO 46184
45938: LD_INT 2
45940: DOUBLE
45941: EQUAL
45942: IFTRUE 45952
45944: LD_INT 16
45946: DOUBLE
45947: EQUAL
45948: IFTRUE 45952
45950: GO 45998
45952: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
45953: LD_ADDR_VAR 0 8
45957: PUSH
45958: LD_VAR 0 2
45962: PPUSH
45963: LD_INT 2
45965: PUSH
45966: LD_INT 30
45968: PUSH
45969: LD_INT 0
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 30
45978: PUSH
45979: LD_INT 1
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: LIST
45990: PPUSH
45991: CALL_OW 72
45995: ST_TO_ADDR
45996: GO 46184
45998: LD_INT 3
46000: DOUBLE
46001: EQUAL
46002: IFTRUE 46006
46004: GO 46052
46006: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
46007: LD_ADDR_VAR 0 8
46011: PUSH
46012: LD_VAR 0 2
46016: PPUSH
46017: LD_INT 2
46019: PUSH
46020: LD_INT 30
46022: PUSH
46023: LD_INT 2
46025: PUSH
46026: EMPTY
46027: LIST
46028: LIST
46029: PUSH
46030: LD_INT 30
46032: PUSH
46033: LD_INT 3
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: LIST
46044: PPUSH
46045: CALL_OW 72
46049: ST_TO_ADDR
46050: GO 46184
46052: LD_INT 4
46054: DOUBLE
46055: EQUAL
46056: IFTRUE 46060
46058: GO 46117
46060: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
46061: LD_ADDR_VAR 0 8
46065: PUSH
46066: LD_VAR 0 2
46070: PPUSH
46071: LD_INT 2
46073: PUSH
46074: LD_INT 30
46076: PUSH
46077: LD_INT 6
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: PUSH
46084: LD_INT 30
46086: PUSH
46087: LD_INT 7
46089: PUSH
46090: EMPTY
46091: LIST
46092: LIST
46093: PUSH
46094: LD_INT 30
46096: PUSH
46097: LD_INT 8
46099: PUSH
46100: EMPTY
46101: LIST
46102: LIST
46103: PUSH
46104: EMPTY
46105: LIST
46106: LIST
46107: LIST
46108: LIST
46109: PPUSH
46110: CALL_OW 72
46114: ST_TO_ADDR
46115: GO 46184
46117: LD_INT 5
46119: DOUBLE
46120: EQUAL
46121: IFTRUE 46137
46123: LD_INT 8
46125: DOUBLE
46126: EQUAL
46127: IFTRUE 46137
46129: LD_INT 9
46131: DOUBLE
46132: EQUAL
46133: IFTRUE 46137
46135: GO 46183
46137: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
46138: LD_ADDR_VAR 0 8
46142: PUSH
46143: LD_VAR 0 2
46147: PPUSH
46148: LD_INT 2
46150: PUSH
46151: LD_INT 30
46153: PUSH
46154: LD_INT 4
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: PUSH
46161: LD_INT 30
46163: PUSH
46164: LD_INT 5
46166: PUSH
46167: EMPTY
46168: LIST
46169: LIST
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: LIST
46175: PPUSH
46176: CALL_OW 72
46180: ST_TO_ADDR
46181: GO 46184
46183: POP
// if not tmp then
46184: LD_VAR 0 8
46188: NOT
46189: IFFALSE 46193
// exit ;
46191: GO 46653
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
46193: LD_VAR 0 4
46197: PUSH
46198: LD_INT 1
46200: PUSH
46201: LD_INT 15
46203: PUSH
46204: EMPTY
46205: LIST
46206: LIST
46207: IN
46208: PUSH
46209: LD_EXP 89
46213: PUSH
46214: LD_VAR 0 1
46218: ARRAY
46219: AND
46220: IFFALSE 46376
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
46222: LD_ADDR_VAR 0 9
46226: PUSH
46227: LD_EXP 89
46231: PUSH
46232: LD_VAR 0 1
46236: ARRAY
46237: PUSH
46238: LD_INT 1
46240: ARRAY
46241: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
46242: LD_VAR 0 9
46246: PUSH
46247: LD_EXP 90
46251: PUSH
46252: LD_VAR 0 1
46256: ARRAY
46257: IN
46258: NOT
46259: IFFALSE 46374
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
46261: LD_ADDR_EXP 90
46265: PUSH
46266: LD_EXP 90
46270: PPUSH
46271: LD_VAR 0 1
46275: PUSH
46276: LD_EXP 90
46280: PUSH
46281: LD_VAR 0 1
46285: ARRAY
46286: PUSH
46287: LD_INT 1
46289: PLUS
46290: PUSH
46291: EMPTY
46292: LIST
46293: LIST
46294: PPUSH
46295: LD_VAR 0 9
46299: PPUSH
46300: CALL 58774 0 3
46304: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
46305: LD_ADDR_EXP 89
46309: PUSH
46310: LD_EXP 89
46314: PPUSH
46315: LD_VAR 0 1
46319: PPUSH
46320: LD_EXP 89
46324: PUSH
46325: LD_VAR 0 1
46329: ARRAY
46330: PUSH
46331: LD_VAR 0 9
46335: DIFF
46336: PPUSH
46337: CALL_OW 1
46341: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
46342: LD_VAR 0 3
46346: PPUSH
46347: LD_EXP 90
46351: PUSH
46352: LD_VAR 0 1
46356: ARRAY
46357: PUSH
46358: LD_EXP 90
46362: PUSH
46363: LD_VAR 0 1
46367: ARRAY
46368: ARRAY
46369: PPUSH
46370: CALL_OW 120
// end ; exit ;
46374: GO 46653
// end ; if tmp > 1 then
46376: LD_VAR 0 8
46380: PUSH
46381: LD_INT 1
46383: GREATER
46384: IFFALSE 46488
// for i = 2 to tmp do
46386: LD_ADDR_VAR 0 6
46390: PUSH
46391: DOUBLE
46392: LD_INT 2
46394: DEC
46395: ST_TO_ADDR
46396: LD_VAR 0 8
46400: PUSH
46401: FOR_TO
46402: IFFALSE 46486
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
46404: LD_VAR 0 8
46408: PUSH
46409: LD_VAR 0 6
46413: ARRAY
46414: PPUSH
46415: CALL_OW 461
46419: PUSH
46420: LD_INT 6
46422: EQUAL
46423: IFFALSE 46484
// begin x := tmp [ i ] ;
46425: LD_ADDR_VAR 0 9
46429: PUSH
46430: LD_VAR 0 8
46434: PUSH
46435: LD_VAR 0 6
46439: ARRAY
46440: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
46441: LD_ADDR_VAR 0 8
46445: PUSH
46446: LD_VAR 0 8
46450: PPUSH
46451: LD_VAR 0 6
46455: PPUSH
46456: CALL_OW 3
46460: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
46461: LD_ADDR_VAR 0 8
46465: PUSH
46466: LD_VAR 0 8
46470: PPUSH
46471: LD_INT 1
46473: PPUSH
46474: LD_VAR 0 9
46478: PPUSH
46479: CALL_OW 2
46483: ST_TO_ADDR
// end ;
46484: GO 46401
46486: POP
46487: POP
// for i in tmp do
46488: LD_ADDR_VAR 0 6
46492: PUSH
46493: LD_VAR 0 8
46497: PUSH
46498: FOR_IN
46499: IFFALSE 46526
// begin if IsNotFull ( i ) then
46501: LD_VAR 0 6
46505: PPUSH
46506: CALL 55996 0 1
46510: IFFALSE 46524
// begin j := i ;
46512: LD_ADDR_VAR 0 7
46516: PUSH
46517: LD_VAR 0 6
46521: ST_TO_ADDR
// break ;
46522: GO 46526
// end ; end ;
46524: GO 46498
46526: POP
46527: POP
// if j then
46528: LD_VAR 0 7
46532: IFFALSE 46550
// ComEnterUnit ( unit , j ) else
46534: LD_VAR 0 3
46538: PPUSH
46539: LD_VAR 0 7
46543: PPUSH
46544: CALL_OW 120
46548: GO 46653
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46550: LD_ADDR_VAR 0 10
46554: PUSH
46555: LD_VAR 0 2
46559: PPUSH
46560: LD_INT 2
46562: PUSH
46563: LD_INT 30
46565: PUSH
46566: LD_INT 0
46568: PUSH
46569: EMPTY
46570: LIST
46571: LIST
46572: PUSH
46573: LD_INT 30
46575: PUSH
46576: LD_INT 1
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PUSH
46583: EMPTY
46584: LIST
46585: LIST
46586: LIST
46587: PPUSH
46588: CALL_OW 72
46592: ST_TO_ADDR
// if depot then
46593: LD_VAR 0 10
46597: IFFALSE 46653
// begin depot := NearestUnitToUnit ( depot , unit ) ;
46599: LD_ADDR_VAR 0 10
46603: PUSH
46604: LD_VAR 0 10
46608: PPUSH
46609: LD_VAR 0 3
46613: PPUSH
46614: CALL_OW 74
46618: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
46619: LD_VAR 0 3
46623: PPUSH
46624: LD_VAR 0 10
46628: PPUSH
46629: CALL_OW 296
46633: PUSH
46634: LD_INT 10
46636: GREATER
46637: IFFALSE 46653
// ComStandNearbyBuilding ( unit , depot ) ;
46639: LD_VAR 0 3
46643: PPUSH
46644: LD_VAR 0 10
46648: PPUSH
46649: CALL 55376 0 2
// end ; end ; end ;
46653: LD_VAR 0 5
46657: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
46658: LD_INT 0
46660: PPUSH
46661: PPUSH
46662: PPUSH
46663: PPUSH
// if not mc_bases then
46664: LD_EXP 80
46668: NOT
46669: IFFALSE 46673
// exit ;
46671: GO 46912
// for i = 1 to mc_bases do
46673: LD_ADDR_VAR 0 2
46677: PUSH
46678: DOUBLE
46679: LD_INT 1
46681: DEC
46682: ST_TO_ADDR
46683: LD_EXP 80
46687: PUSH
46688: FOR_TO
46689: IFFALSE 46910
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
46691: LD_ADDR_VAR 0 4
46695: PUSH
46696: LD_EXP 80
46700: PUSH
46701: LD_VAR 0 2
46705: ARRAY
46706: PPUSH
46707: LD_INT 21
46709: PUSH
46710: LD_INT 1
46712: PUSH
46713: EMPTY
46714: LIST
46715: LIST
46716: PPUSH
46717: CALL_OW 72
46721: PUSH
46722: LD_EXP 109
46726: PUSH
46727: LD_VAR 0 2
46731: ARRAY
46732: UNION
46733: ST_TO_ADDR
// if not tmp then
46734: LD_VAR 0 4
46738: NOT
46739: IFFALSE 46743
// continue ;
46741: GO 46688
// for j in tmp do
46743: LD_ADDR_VAR 0 3
46747: PUSH
46748: LD_VAR 0 4
46752: PUSH
46753: FOR_IN
46754: IFFALSE 46906
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
46756: LD_VAR 0 3
46760: PPUSH
46761: CALL_OW 110
46765: NOT
46766: PUSH
46767: LD_VAR 0 3
46771: PPUSH
46772: CALL_OW 314
46776: NOT
46777: AND
46778: PUSH
46779: LD_VAR 0 3
46783: PPUSH
46784: CALL_OW 311
46788: NOT
46789: AND
46790: PUSH
46791: LD_VAR 0 3
46795: PPUSH
46796: CALL_OW 310
46800: NOT
46801: AND
46802: PUSH
46803: LD_VAR 0 3
46807: PUSH
46808: LD_EXP 83
46812: PUSH
46813: LD_VAR 0 2
46817: ARRAY
46818: PUSH
46819: LD_INT 1
46821: ARRAY
46822: IN
46823: NOT
46824: AND
46825: PUSH
46826: LD_VAR 0 3
46830: PUSH
46831: LD_EXP 83
46835: PUSH
46836: LD_VAR 0 2
46840: ARRAY
46841: PUSH
46842: LD_INT 2
46844: ARRAY
46845: IN
46846: NOT
46847: AND
46848: PUSH
46849: LD_VAR 0 3
46853: PUSH
46854: LD_EXP 92
46858: PUSH
46859: LD_VAR 0 2
46863: ARRAY
46864: IN
46865: NOT
46866: AND
46867: IFFALSE 46904
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
46869: LD_VAR 0 2
46873: PPUSH
46874: LD_EXP 80
46878: PUSH
46879: LD_VAR 0 2
46883: ARRAY
46884: PPUSH
46885: LD_VAR 0 3
46889: PPUSH
46890: LD_VAR 0 3
46894: PPUSH
46895: CALL_OW 257
46899: PPUSH
46900: CALL 45718 0 4
// end ;
46904: GO 46753
46906: POP
46907: POP
// end ;
46908: GO 46688
46910: POP
46911: POP
// end ;
46912: LD_VAR 0 1
46916: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
46917: LD_INT 0
46919: PPUSH
46920: PPUSH
46921: PPUSH
46922: PPUSH
46923: PPUSH
46924: PPUSH
// if not mc_bases [ base ] then
46925: LD_EXP 80
46929: PUSH
46930: LD_VAR 0 1
46934: ARRAY
46935: NOT
46936: IFFALSE 46940
// exit ;
46938: GO 47141
// tmp := [ ] ;
46940: LD_ADDR_VAR 0 6
46944: PUSH
46945: EMPTY
46946: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
46947: LD_ADDR_VAR 0 7
46951: PUSH
46952: LD_VAR 0 3
46956: PPUSH
46957: LD_INT 0
46959: PPUSH
46960: CALL_OW 517
46964: ST_TO_ADDR
// if not list then
46965: LD_VAR 0 7
46969: NOT
46970: IFFALSE 46974
// exit ;
46972: GO 47141
// c := Count ( list [ 1 ] ) ;
46974: LD_ADDR_VAR 0 9
46978: PUSH
46979: LD_VAR 0 7
46983: PUSH
46984: LD_INT 1
46986: ARRAY
46987: PPUSH
46988: CALL 55914 0 1
46992: ST_TO_ADDR
// if amount > c then
46993: LD_VAR 0 2
46997: PUSH
46998: LD_VAR 0 9
47002: GREATER
47003: IFFALSE 47015
// amount := c ;
47005: LD_ADDR_VAR 0 2
47009: PUSH
47010: LD_VAR 0 9
47014: ST_TO_ADDR
// for i := 1 to amount do
47015: LD_ADDR_VAR 0 5
47019: PUSH
47020: DOUBLE
47021: LD_INT 1
47023: DEC
47024: ST_TO_ADDR
47025: LD_VAR 0 2
47029: PUSH
47030: FOR_TO
47031: IFFALSE 47089
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
47033: LD_ADDR_VAR 0 6
47037: PUSH
47038: LD_VAR 0 6
47042: PPUSH
47043: LD_VAR 0 5
47047: PPUSH
47048: LD_VAR 0 7
47052: PUSH
47053: LD_INT 1
47055: ARRAY
47056: PUSH
47057: LD_VAR 0 5
47061: ARRAY
47062: PUSH
47063: LD_VAR 0 7
47067: PUSH
47068: LD_INT 2
47070: ARRAY
47071: PUSH
47072: LD_VAR 0 5
47076: ARRAY
47077: PUSH
47078: EMPTY
47079: LIST
47080: LIST
47081: PPUSH
47082: CALL_OW 1
47086: ST_TO_ADDR
47087: GO 47030
47089: POP
47090: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
47091: LD_ADDR_EXP 93
47095: PUSH
47096: LD_EXP 93
47100: PPUSH
47101: LD_VAR 0 1
47105: PPUSH
47106: LD_VAR 0 6
47110: PPUSH
47111: CALL_OW 1
47115: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
47116: LD_ADDR_EXP 95
47120: PUSH
47121: LD_EXP 95
47125: PPUSH
47126: LD_VAR 0 1
47130: PPUSH
47131: LD_VAR 0 3
47135: PPUSH
47136: CALL_OW 1
47140: ST_TO_ADDR
// end ;
47141: LD_VAR 0 4
47145: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
47146: LD_INT 0
47148: PPUSH
// if not mc_bases [ base ] then
47149: LD_EXP 80
47153: PUSH
47154: LD_VAR 0 1
47158: ARRAY
47159: NOT
47160: IFFALSE 47164
// exit ;
47162: GO 47189
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
47164: LD_ADDR_EXP 85
47168: PUSH
47169: LD_EXP 85
47173: PPUSH
47174: LD_VAR 0 1
47178: PPUSH
47179: LD_VAR 0 2
47183: PPUSH
47184: CALL_OW 1
47188: ST_TO_ADDR
// end ;
47189: LD_VAR 0 3
47193: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
47194: LD_INT 0
47196: PPUSH
// if not mc_bases [ base ] then
47197: LD_EXP 80
47201: PUSH
47202: LD_VAR 0 1
47206: ARRAY
47207: NOT
47208: IFFALSE 47212
// exit ;
47210: GO 47249
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
47212: LD_ADDR_EXP 85
47216: PUSH
47217: LD_EXP 85
47221: PPUSH
47222: LD_VAR 0 1
47226: PPUSH
47227: LD_EXP 85
47231: PUSH
47232: LD_VAR 0 1
47236: ARRAY
47237: PUSH
47238: LD_VAR 0 2
47242: UNION
47243: PPUSH
47244: CALL_OW 1
47248: ST_TO_ADDR
// end ;
47249: LD_VAR 0 3
47253: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
47254: LD_INT 0
47256: PPUSH
// if not mc_bases [ base ] then
47257: LD_EXP 80
47261: PUSH
47262: LD_VAR 0 1
47266: ARRAY
47267: NOT
47268: IFFALSE 47272
// exit ;
47270: GO 47297
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
47272: LD_ADDR_EXP 101
47276: PUSH
47277: LD_EXP 101
47281: PPUSH
47282: LD_VAR 0 1
47286: PPUSH
47287: LD_VAR 0 2
47291: PPUSH
47292: CALL_OW 1
47296: ST_TO_ADDR
// end ;
47297: LD_VAR 0 3
47301: RET
// export function MC_InsertProduceList ( base , components ) ; begin
47302: LD_INT 0
47304: PPUSH
// if not mc_bases [ base ] then
47305: LD_EXP 80
47309: PUSH
47310: LD_VAR 0 1
47314: ARRAY
47315: NOT
47316: IFFALSE 47320
// exit ;
47318: GO 47357
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
47320: LD_ADDR_EXP 101
47324: PUSH
47325: LD_EXP 101
47329: PPUSH
47330: LD_VAR 0 1
47334: PPUSH
47335: LD_EXP 101
47339: PUSH
47340: LD_VAR 0 1
47344: ARRAY
47345: PUSH
47346: LD_VAR 0 2
47350: ADD
47351: PPUSH
47352: CALL_OW 1
47356: ST_TO_ADDR
// end ;
47357: LD_VAR 0 3
47361: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
47362: LD_INT 0
47364: PPUSH
// if not mc_bases [ base ] then
47365: LD_EXP 80
47369: PUSH
47370: LD_VAR 0 1
47374: ARRAY
47375: NOT
47376: IFFALSE 47380
// exit ;
47378: GO 47434
// mc_defender := Replace ( mc_defender , base , deflist ) ;
47380: LD_ADDR_EXP 102
47384: PUSH
47385: LD_EXP 102
47389: PPUSH
47390: LD_VAR 0 1
47394: PPUSH
47395: LD_VAR 0 2
47399: PPUSH
47400: CALL_OW 1
47404: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
47405: LD_ADDR_EXP 91
47409: PUSH
47410: LD_EXP 91
47414: PPUSH
47415: LD_VAR 0 1
47419: PPUSH
47420: LD_VAR 0 2
47424: PUSH
47425: LD_INT 0
47427: PLUS
47428: PPUSH
47429: CALL_OW 1
47433: ST_TO_ADDR
// end ;
47434: LD_VAR 0 3
47438: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
47439: LD_INT 0
47441: PPUSH
// if not mc_bases [ base ] then
47442: LD_EXP 80
47446: PUSH
47447: LD_VAR 0 1
47451: ARRAY
47452: NOT
47453: IFFALSE 47457
// exit ;
47455: GO 47482
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
47457: LD_ADDR_EXP 91
47461: PUSH
47462: LD_EXP 91
47466: PPUSH
47467: LD_VAR 0 1
47471: PPUSH
47472: LD_VAR 0 2
47476: PPUSH
47477: CALL_OW 1
47481: ST_TO_ADDR
// end ;
47482: LD_VAR 0 3
47486: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
47487: LD_INT 0
47489: PPUSH
47490: PPUSH
47491: PPUSH
47492: PPUSH
// if not mc_bases [ base ] then
47493: LD_EXP 80
47497: PUSH
47498: LD_VAR 0 1
47502: ARRAY
47503: NOT
47504: IFFALSE 47508
// exit ;
47506: GO 47573
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
47508: LD_ADDR_EXP 100
47512: PUSH
47513: LD_EXP 100
47517: PPUSH
47518: LD_VAR 0 1
47522: PUSH
47523: LD_EXP 100
47527: PUSH
47528: LD_VAR 0 1
47532: ARRAY
47533: PUSH
47534: LD_INT 1
47536: PLUS
47537: PUSH
47538: EMPTY
47539: LIST
47540: LIST
47541: PPUSH
47542: LD_VAR 0 1
47546: PUSH
47547: LD_VAR 0 2
47551: PUSH
47552: LD_VAR 0 3
47556: PUSH
47557: LD_VAR 0 4
47561: PUSH
47562: EMPTY
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: PPUSH
47568: CALL 58774 0 3
47572: ST_TO_ADDR
// end ;
47573: LD_VAR 0 5
47577: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
47578: LD_INT 0
47580: PPUSH
// if not mc_bases [ base ] then
47581: LD_EXP 80
47585: PUSH
47586: LD_VAR 0 1
47590: ARRAY
47591: NOT
47592: IFFALSE 47596
// exit ;
47594: GO 47621
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
47596: LD_ADDR_EXP 117
47600: PUSH
47601: LD_EXP 117
47605: PPUSH
47606: LD_VAR 0 1
47610: PPUSH
47611: LD_VAR 0 2
47615: PPUSH
47616: CALL_OW 1
47620: ST_TO_ADDR
// end ;
47621: LD_VAR 0 3
47625: RET
// export function MC_GetMinesField ( base ) ; begin
47626: LD_INT 0
47628: PPUSH
// result := mc_mines [ base ] ;
47629: LD_ADDR_VAR 0 2
47633: PUSH
47634: LD_EXP 93
47638: PUSH
47639: LD_VAR 0 1
47643: ARRAY
47644: ST_TO_ADDR
// end ;
47645: LD_VAR 0 2
47649: RET
// export function MC_GetProduceList ( base ) ; begin
47650: LD_INT 0
47652: PPUSH
// result := mc_produce [ base ] ;
47653: LD_ADDR_VAR 0 2
47657: PUSH
47658: LD_EXP 101
47662: PUSH
47663: LD_VAR 0 1
47667: ARRAY
47668: ST_TO_ADDR
// end ;
47669: LD_VAR 0 2
47673: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
47674: LD_INT 0
47676: PPUSH
47677: PPUSH
// if not mc_bases then
47678: LD_EXP 80
47682: NOT
47683: IFFALSE 47687
// exit ;
47685: GO 47752
// if mc_bases [ base ] then
47687: LD_EXP 80
47691: PUSH
47692: LD_VAR 0 1
47696: ARRAY
47697: IFFALSE 47752
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47699: LD_ADDR_VAR 0 3
47703: PUSH
47704: LD_EXP 80
47708: PUSH
47709: LD_VAR 0 1
47713: ARRAY
47714: PPUSH
47715: LD_INT 30
47717: PUSH
47718: LD_VAR 0 2
47722: PUSH
47723: EMPTY
47724: LIST
47725: LIST
47726: PPUSH
47727: CALL_OW 72
47731: ST_TO_ADDR
// if result then
47732: LD_VAR 0 3
47736: IFFALSE 47752
// result := result [ 1 ] ;
47738: LD_ADDR_VAR 0 3
47742: PUSH
47743: LD_VAR 0 3
47747: PUSH
47748: LD_INT 1
47750: ARRAY
47751: ST_TO_ADDR
// end ; end ;
47752: LD_VAR 0 3
47756: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
47757: LD_INT 0
47759: PPUSH
47760: PPUSH
// if not mc_bases then
47761: LD_EXP 80
47765: NOT
47766: IFFALSE 47770
// exit ;
47768: GO 47815
// if mc_bases [ base ] then
47770: LD_EXP 80
47774: PUSH
47775: LD_VAR 0 1
47779: ARRAY
47780: IFFALSE 47815
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47782: LD_ADDR_VAR 0 3
47786: PUSH
47787: LD_EXP 80
47791: PUSH
47792: LD_VAR 0 1
47796: ARRAY
47797: PPUSH
47798: LD_INT 30
47800: PUSH
47801: LD_VAR 0 2
47805: PUSH
47806: EMPTY
47807: LIST
47808: LIST
47809: PPUSH
47810: CALL_OW 72
47814: ST_TO_ADDR
// end ;
47815: LD_VAR 0 3
47819: RET
// export function MC_SetTame ( base , area ) ; begin
47820: LD_INT 0
47822: PPUSH
// if not mc_bases or not base then
47823: LD_EXP 80
47827: NOT
47828: PUSH
47829: LD_VAR 0 1
47833: NOT
47834: OR
47835: IFFALSE 47839
// exit ;
47837: GO 47864
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
47839: LD_ADDR_EXP 108
47843: PUSH
47844: LD_EXP 108
47848: PPUSH
47849: LD_VAR 0 1
47853: PPUSH
47854: LD_VAR 0 2
47858: PPUSH
47859: CALL_OW 1
47863: ST_TO_ADDR
// end ;
47864: LD_VAR 0 3
47868: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
47869: LD_INT 0
47871: PPUSH
47872: PPUSH
// if not mc_bases or not base then
47873: LD_EXP 80
47877: NOT
47878: PUSH
47879: LD_VAR 0 1
47883: NOT
47884: OR
47885: IFFALSE 47889
// exit ;
47887: GO 47991
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47889: LD_ADDR_VAR 0 4
47893: PUSH
47894: LD_EXP 80
47898: PUSH
47899: LD_VAR 0 1
47903: ARRAY
47904: PPUSH
47905: LD_INT 30
47907: PUSH
47908: LD_VAR 0 2
47912: PUSH
47913: EMPTY
47914: LIST
47915: LIST
47916: PPUSH
47917: CALL_OW 72
47921: ST_TO_ADDR
// if not tmp then
47922: LD_VAR 0 4
47926: NOT
47927: IFFALSE 47931
// exit ;
47929: GO 47991
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
47931: LD_ADDR_EXP 112
47935: PUSH
47936: LD_EXP 112
47940: PPUSH
47941: LD_VAR 0 1
47945: PPUSH
47946: LD_EXP 112
47950: PUSH
47951: LD_VAR 0 1
47955: ARRAY
47956: PPUSH
47957: LD_EXP 112
47961: PUSH
47962: LD_VAR 0 1
47966: ARRAY
47967: PUSH
47968: LD_INT 1
47970: PLUS
47971: PPUSH
47972: LD_VAR 0 4
47976: PUSH
47977: LD_INT 1
47979: ARRAY
47980: PPUSH
47981: CALL_OW 2
47985: PPUSH
47986: CALL_OW 1
47990: ST_TO_ADDR
// end ;
47991: LD_VAR 0 3
47995: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
47996: LD_INT 0
47998: PPUSH
47999: PPUSH
// if not mc_bases or not base or not kinds then
48000: LD_EXP 80
48004: NOT
48005: PUSH
48006: LD_VAR 0 1
48010: NOT
48011: OR
48012: PUSH
48013: LD_VAR 0 2
48017: NOT
48018: OR
48019: IFFALSE 48023
// exit ;
48021: GO 48084
// for i in kinds do
48023: LD_ADDR_VAR 0 4
48027: PUSH
48028: LD_VAR 0 2
48032: PUSH
48033: FOR_IN
48034: IFFALSE 48082
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
48036: LD_ADDR_EXP 114
48040: PUSH
48041: LD_EXP 114
48045: PPUSH
48046: LD_VAR 0 1
48050: PUSH
48051: LD_EXP 114
48055: PUSH
48056: LD_VAR 0 1
48060: ARRAY
48061: PUSH
48062: LD_INT 1
48064: PLUS
48065: PUSH
48066: EMPTY
48067: LIST
48068: LIST
48069: PPUSH
48070: LD_VAR 0 4
48074: PPUSH
48075: CALL 58774 0 3
48079: ST_TO_ADDR
48080: GO 48033
48082: POP
48083: POP
// end ;
48084: LD_VAR 0 3
48088: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
48089: LD_INT 0
48091: PPUSH
// if not mc_bases or not base or not areas then
48092: LD_EXP 80
48096: NOT
48097: PUSH
48098: LD_VAR 0 1
48102: NOT
48103: OR
48104: PUSH
48105: LD_VAR 0 2
48109: NOT
48110: OR
48111: IFFALSE 48115
// exit ;
48113: GO 48140
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
48115: LD_ADDR_EXP 98
48119: PUSH
48120: LD_EXP 98
48124: PPUSH
48125: LD_VAR 0 1
48129: PPUSH
48130: LD_VAR 0 2
48134: PPUSH
48135: CALL_OW 1
48139: ST_TO_ADDR
// end ;
48140: LD_VAR 0 3
48144: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
48145: LD_INT 0
48147: PPUSH
// if not mc_bases or not base or not teleports_exit then
48148: LD_EXP 80
48152: NOT
48153: PUSH
48154: LD_VAR 0 1
48158: NOT
48159: OR
48160: PUSH
48161: LD_VAR 0 2
48165: NOT
48166: OR
48167: IFFALSE 48171
// exit ;
48169: GO 48196
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
48171: LD_ADDR_EXP 115
48175: PUSH
48176: LD_EXP 115
48180: PPUSH
48181: LD_VAR 0 1
48185: PPUSH
48186: LD_VAR 0 2
48190: PPUSH
48191: CALL_OW 1
48195: ST_TO_ADDR
// end ;
48196: LD_VAR 0 3
48200: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
48201: LD_INT 0
48203: PPUSH
48204: PPUSH
48205: PPUSH
// if not mc_bases or not base or not ext_list then
48206: LD_EXP 80
48210: NOT
48211: PUSH
48212: LD_VAR 0 1
48216: NOT
48217: OR
48218: PUSH
48219: LD_VAR 0 5
48223: NOT
48224: OR
48225: IFFALSE 48229
// exit ;
48227: GO 48402
// tmp := GetFacExtXYD ( x , y , d ) ;
48229: LD_ADDR_VAR 0 8
48233: PUSH
48234: LD_VAR 0 2
48238: PPUSH
48239: LD_VAR 0 3
48243: PPUSH
48244: LD_VAR 0 4
48248: PPUSH
48249: CALL 89157 0 3
48253: ST_TO_ADDR
// if not tmp then
48254: LD_VAR 0 8
48258: NOT
48259: IFFALSE 48263
// exit ;
48261: GO 48402
// for i in tmp do
48263: LD_ADDR_VAR 0 7
48267: PUSH
48268: LD_VAR 0 8
48272: PUSH
48273: FOR_IN
48274: IFFALSE 48400
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
48276: LD_ADDR_EXP 85
48280: PUSH
48281: LD_EXP 85
48285: PPUSH
48286: LD_VAR 0 1
48290: PPUSH
48291: LD_EXP 85
48295: PUSH
48296: LD_VAR 0 1
48300: ARRAY
48301: PPUSH
48302: LD_EXP 85
48306: PUSH
48307: LD_VAR 0 1
48311: ARRAY
48312: PUSH
48313: LD_INT 1
48315: PLUS
48316: PPUSH
48317: LD_VAR 0 5
48321: PUSH
48322: LD_INT 1
48324: ARRAY
48325: PUSH
48326: LD_VAR 0 7
48330: PUSH
48331: LD_INT 1
48333: ARRAY
48334: PUSH
48335: LD_VAR 0 7
48339: PUSH
48340: LD_INT 2
48342: ARRAY
48343: PUSH
48344: LD_VAR 0 7
48348: PUSH
48349: LD_INT 3
48351: ARRAY
48352: PUSH
48353: EMPTY
48354: LIST
48355: LIST
48356: LIST
48357: LIST
48358: PPUSH
48359: CALL_OW 2
48363: PPUSH
48364: CALL_OW 1
48368: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
48369: LD_ADDR_VAR 0 5
48373: PUSH
48374: LD_VAR 0 5
48378: PPUSH
48379: LD_INT 1
48381: PPUSH
48382: CALL_OW 3
48386: ST_TO_ADDR
// if not ext_list then
48387: LD_VAR 0 5
48391: NOT
48392: IFFALSE 48398
// exit ;
48394: POP
48395: POP
48396: GO 48402
// end ;
48398: GO 48273
48400: POP
48401: POP
// end ;
48402: LD_VAR 0 6
48406: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
48407: LD_INT 0
48409: PPUSH
// if not mc_bases or not base or not weapon_list then
48410: LD_EXP 80
48414: NOT
48415: PUSH
48416: LD_VAR 0 1
48420: NOT
48421: OR
48422: PUSH
48423: LD_VAR 0 2
48427: NOT
48428: OR
48429: IFFALSE 48433
// exit ;
48431: GO 48458
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
48433: LD_ADDR_EXP 119
48437: PUSH
48438: LD_EXP 119
48442: PPUSH
48443: LD_VAR 0 1
48447: PPUSH
48448: LD_VAR 0 2
48452: PPUSH
48453: CALL_OW 1
48457: ST_TO_ADDR
// end ;
48458: LD_VAR 0 3
48462: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
48463: LD_INT 0
48465: PPUSH
// if not mc_bases or not base or not tech_list then
48466: LD_EXP 80
48470: NOT
48471: PUSH
48472: LD_VAR 0 1
48476: NOT
48477: OR
48478: PUSH
48479: LD_VAR 0 2
48483: NOT
48484: OR
48485: IFFALSE 48489
// exit ;
48487: GO 48514
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
48489: LD_ADDR_EXP 107
48493: PUSH
48494: LD_EXP 107
48498: PPUSH
48499: LD_VAR 0 1
48503: PPUSH
48504: LD_VAR 0 2
48508: PPUSH
48509: CALL_OW 1
48513: ST_TO_ADDR
// end ;
48514: LD_VAR 0 3
48518: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
48519: LD_INT 0
48521: PPUSH
// if not mc_bases or not parking_area or not base then
48522: LD_EXP 80
48526: NOT
48527: PUSH
48528: LD_VAR 0 2
48532: NOT
48533: OR
48534: PUSH
48535: LD_VAR 0 1
48539: NOT
48540: OR
48541: IFFALSE 48545
// exit ;
48543: GO 48570
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
48545: LD_ADDR_EXP 104
48549: PUSH
48550: LD_EXP 104
48554: PPUSH
48555: LD_VAR 0 1
48559: PPUSH
48560: LD_VAR 0 2
48564: PPUSH
48565: CALL_OW 1
48569: ST_TO_ADDR
// end ;
48570: LD_VAR 0 3
48574: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
48575: LD_INT 0
48577: PPUSH
// if not mc_bases or not base or not scan_area then
48578: LD_EXP 80
48582: NOT
48583: PUSH
48584: LD_VAR 0 1
48588: NOT
48589: OR
48590: PUSH
48591: LD_VAR 0 2
48595: NOT
48596: OR
48597: IFFALSE 48601
// exit ;
48599: GO 48626
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
48601: LD_ADDR_EXP 105
48605: PUSH
48606: LD_EXP 105
48610: PPUSH
48611: LD_VAR 0 1
48615: PPUSH
48616: LD_VAR 0 2
48620: PPUSH
48621: CALL_OW 1
48625: ST_TO_ADDR
// end ;
48626: LD_VAR 0 3
48630: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
48631: LD_INT 0
48633: PPUSH
48634: PPUSH
// if not mc_bases or not base then
48635: LD_EXP 80
48639: NOT
48640: PUSH
48641: LD_VAR 0 1
48645: NOT
48646: OR
48647: IFFALSE 48651
// exit ;
48649: GO 48715
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
48651: LD_ADDR_VAR 0 3
48655: PUSH
48656: LD_INT 1
48658: PUSH
48659: LD_INT 2
48661: PUSH
48662: LD_INT 3
48664: PUSH
48665: LD_INT 4
48667: PUSH
48668: LD_INT 11
48670: PUSH
48671: EMPTY
48672: LIST
48673: LIST
48674: LIST
48675: LIST
48676: LIST
48677: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
48678: LD_ADDR_EXP 107
48682: PUSH
48683: LD_EXP 107
48687: PPUSH
48688: LD_VAR 0 1
48692: PPUSH
48693: LD_EXP 107
48697: PUSH
48698: LD_VAR 0 1
48702: ARRAY
48703: PUSH
48704: LD_VAR 0 3
48708: DIFF
48709: PPUSH
48710: CALL_OW 1
48714: ST_TO_ADDR
// end ;
48715: LD_VAR 0 2
48719: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
48720: LD_INT 0
48722: PPUSH
// result := mc_vehicles [ base ] ;
48723: LD_ADDR_VAR 0 3
48727: PUSH
48728: LD_EXP 99
48732: PUSH
48733: LD_VAR 0 1
48737: ARRAY
48738: ST_TO_ADDR
// if onlyCombat then
48739: LD_VAR 0 2
48743: IFFALSE 48915
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
48745: LD_ADDR_VAR 0 3
48749: PUSH
48750: LD_VAR 0 3
48754: PUSH
48755: LD_VAR 0 3
48759: PPUSH
48760: LD_INT 2
48762: PUSH
48763: LD_INT 34
48765: PUSH
48766: LD_INT 12
48768: PUSH
48769: EMPTY
48770: LIST
48771: LIST
48772: PUSH
48773: LD_INT 34
48775: PUSH
48776: LD_INT 51
48778: PUSH
48779: EMPTY
48780: LIST
48781: LIST
48782: PUSH
48783: LD_INT 34
48785: PUSH
48786: LD_INT 89
48788: PUSH
48789: EMPTY
48790: LIST
48791: LIST
48792: PUSH
48793: LD_INT 34
48795: PUSH
48796: LD_INT 32
48798: PUSH
48799: EMPTY
48800: LIST
48801: LIST
48802: PUSH
48803: LD_INT 34
48805: PUSH
48806: LD_INT 13
48808: PUSH
48809: EMPTY
48810: LIST
48811: LIST
48812: PUSH
48813: LD_INT 34
48815: PUSH
48816: LD_INT 52
48818: PUSH
48819: EMPTY
48820: LIST
48821: LIST
48822: PUSH
48823: LD_INT 34
48825: PUSH
48826: LD_INT 88
48828: PUSH
48829: EMPTY
48830: LIST
48831: LIST
48832: PUSH
48833: LD_INT 34
48835: PUSH
48836: LD_INT 14
48838: PUSH
48839: EMPTY
48840: LIST
48841: LIST
48842: PUSH
48843: LD_INT 34
48845: PUSH
48846: LD_INT 53
48848: PUSH
48849: EMPTY
48850: LIST
48851: LIST
48852: PUSH
48853: LD_INT 34
48855: PUSH
48856: LD_INT 98
48858: PUSH
48859: EMPTY
48860: LIST
48861: LIST
48862: PUSH
48863: LD_INT 34
48865: PUSH
48866: LD_INT 31
48868: PUSH
48869: EMPTY
48870: LIST
48871: LIST
48872: PUSH
48873: LD_INT 34
48875: PUSH
48876: LD_INT 48
48878: PUSH
48879: EMPTY
48880: LIST
48881: LIST
48882: PUSH
48883: LD_INT 34
48885: PUSH
48886: LD_INT 8
48888: PUSH
48889: EMPTY
48890: LIST
48891: LIST
48892: PUSH
48893: EMPTY
48894: LIST
48895: LIST
48896: LIST
48897: LIST
48898: LIST
48899: LIST
48900: LIST
48901: LIST
48902: LIST
48903: LIST
48904: LIST
48905: LIST
48906: LIST
48907: LIST
48908: PPUSH
48909: CALL_OW 72
48913: DIFF
48914: ST_TO_ADDR
// end ; end_of_file
48915: LD_VAR 0 3
48919: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
48920: LD_INT 0
48922: PPUSH
48923: PPUSH
48924: PPUSH
// if not mc_bases or not skirmish then
48925: LD_EXP 80
48929: NOT
48930: PUSH
48931: LD_EXP 78
48935: NOT
48936: OR
48937: IFFALSE 48941
// exit ;
48939: GO 49106
// for i = 1 to mc_bases do
48941: LD_ADDR_VAR 0 4
48945: PUSH
48946: DOUBLE
48947: LD_INT 1
48949: DEC
48950: ST_TO_ADDR
48951: LD_EXP 80
48955: PUSH
48956: FOR_TO
48957: IFFALSE 49104
// begin if sci in mc_bases [ i ] then
48959: LD_VAR 0 2
48963: PUSH
48964: LD_EXP 80
48968: PUSH
48969: LD_VAR 0 4
48973: ARRAY
48974: IN
48975: IFFALSE 49102
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
48977: LD_ADDR_EXP 109
48981: PUSH
48982: LD_EXP 109
48986: PPUSH
48987: LD_VAR 0 4
48991: PUSH
48992: LD_EXP 109
48996: PUSH
48997: LD_VAR 0 4
49001: ARRAY
49002: PUSH
49003: LD_INT 1
49005: PLUS
49006: PUSH
49007: EMPTY
49008: LIST
49009: LIST
49010: PPUSH
49011: LD_VAR 0 1
49015: PPUSH
49016: CALL 58774 0 3
49020: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
49021: LD_ADDR_VAR 0 5
49025: PUSH
49026: LD_EXP 80
49030: PUSH
49031: LD_VAR 0 4
49035: ARRAY
49036: PPUSH
49037: LD_INT 2
49039: PUSH
49040: LD_INT 30
49042: PUSH
49043: LD_INT 0
49045: PUSH
49046: EMPTY
49047: LIST
49048: LIST
49049: PUSH
49050: LD_INT 30
49052: PUSH
49053: LD_INT 1
49055: PUSH
49056: EMPTY
49057: LIST
49058: LIST
49059: PUSH
49060: EMPTY
49061: LIST
49062: LIST
49063: LIST
49064: PPUSH
49065: CALL_OW 72
49069: PPUSH
49070: LD_VAR 0 1
49074: PPUSH
49075: CALL_OW 74
49079: ST_TO_ADDR
// if tmp then
49080: LD_VAR 0 5
49084: IFFALSE 49100
// ComStandNearbyBuilding ( ape , tmp ) ;
49086: LD_VAR 0 1
49090: PPUSH
49091: LD_VAR 0 5
49095: PPUSH
49096: CALL 55376 0 2
// break ;
49100: GO 49104
// end ; end ;
49102: GO 48956
49104: POP
49105: POP
// end ;
49106: LD_VAR 0 3
49110: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
49111: LD_INT 0
49113: PPUSH
49114: PPUSH
49115: PPUSH
// if not mc_bases or not skirmish then
49116: LD_EXP 80
49120: NOT
49121: PUSH
49122: LD_EXP 78
49126: NOT
49127: OR
49128: IFFALSE 49132
// exit ;
49130: GO 49221
// for i = 1 to mc_bases do
49132: LD_ADDR_VAR 0 4
49136: PUSH
49137: DOUBLE
49138: LD_INT 1
49140: DEC
49141: ST_TO_ADDR
49142: LD_EXP 80
49146: PUSH
49147: FOR_TO
49148: IFFALSE 49219
// begin if building in mc_busy_turret_list [ i ] then
49150: LD_VAR 0 1
49154: PUSH
49155: LD_EXP 90
49159: PUSH
49160: LD_VAR 0 4
49164: ARRAY
49165: IN
49166: IFFALSE 49217
// begin tmp := mc_busy_turret_list [ i ] diff building ;
49168: LD_ADDR_VAR 0 5
49172: PUSH
49173: LD_EXP 90
49177: PUSH
49178: LD_VAR 0 4
49182: ARRAY
49183: PUSH
49184: LD_VAR 0 1
49188: DIFF
49189: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
49190: LD_ADDR_EXP 90
49194: PUSH
49195: LD_EXP 90
49199: PPUSH
49200: LD_VAR 0 4
49204: PPUSH
49205: LD_VAR 0 5
49209: PPUSH
49210: CALL_OW 1
49214: ST_TO_ADDR
// break ;
49215: GO 49219
// end ; end ;
49217: GO 49147
49219: POP
49220: POP
// end ;
49221: LD_VAR 0 3
49225: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
49226: LD_INT 0
49228: PPUSH
49229: PPUSH
49230: PPUSH
// if not mc_bases or not skirmish then
49231: LD_EXP 80
49235: NOT
49236: PUSH
49237: LD_EXP 78
49241: NOT
49242: OR
49243: IFFALSE 49247
// exit ;
49245: GO 49446
// for i = 1 to mc_bases do
49247: LD_ADDR_VAR 0 5
49251: PUSH
49252: DOUBLE
49253: LD_INT 1
49255: DEC
49256: ST_TO_ADDR
49257: LD_EXP 80
49261: PUSH
49262: FOR_TO
49263: IFFALSE 49444
// if building in mc_bases [ i ] then
49265: LD_VAR 0 1
49269: PUSH
49270: LD_EXP 80
49274: PUSH
49275: LD_VAR 0 5
49279: ARRAY
49280: IN
49281: IFFALSE 49442
// begin tmp := mc_bases [ i ] diff building ;
49283: LD_ADDR_VAR 0 6
49287: PUSH
49288: LD_EXP 80
49292: PUSH
49293: LD_VAR 0 5
49297: ARRAY
49298: PUSH
49299: LD_VAR 0 1
49303: DIFF
49304: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
49305: LD_ADDR_EXP 80
49309: PUSH
49310: LD_EXP 80
49314: PPUSH
49315: LD_VAR 0 5
49319: PPUSH
49320: LD_VAR 0 6
49324: PPUSH
49325: CALL_OW 1
49329: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
49330: LD_VAR 0 1
49334: PUSH
49335: LD_EXP 88
49339: PUSH
49340: LD_VAR 0 5
49344: ARRAY
49345: IN
49346: IFFALSE 49385
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
49348: LD_ADDR_EXP 88
49352: PUSH
49353: LD_EXP 88
49357: PPUSH
49358: LD_VAR 0 5
49362: PPUSH
49363: LD_EXP 88
49367: PUSH
49368: LD_VAR 0 5
49372: ARRAY
49373: PUSH
49374: LD_VAR 0 1
49378: DIFF
49379: PPUSH
49380: CALL_OW 1
49384: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
49385: LD_VAR 0 1
49389: PUSH
49390: LD_EXP 89
49394: PUSH
49395: LD_VAR 0 5
49399: ARRAY
49400: IN
49401: IFFALSE 49440
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
49403: LD_ADDR_EXP 89
49407: PUSH
49408: LD_EXP 89
49412: PPUSH
49413: LD_VAR 0 5
49417: PPUSH
49418: LD_EXP 89
49422: PUSH
49423: LD_VAR 0 5
49427: ARRAY
49428: PUSH
49429: LD_VAR 0 1
49433: DIFF
49434: PPUSH
49435: CALL_OW 1
49439: ST_TO_ADDR
// break ;
49440: GO 49444
// end ;
49442: GO 49262
49444: POP
49445: POP
// end ;
49446: LD_VAR 0 4
49450: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
49451: LD_INT 0
49453: PPUSH
49454: PPUSH
49455: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
49456: LD_EXP 80
49460: NOT
49461: PUSH
49462: LD_EXP 78
49466: NOT
49467: OR
49468: PUSH
49469: LD_VAR 0 3
49473: PUSH
49474: LD_EXP 106
49478: IN
49479: NOT
49480: OR
49481: IFFALSE 49485
// exit ;
49483: GO 49608
// for i = 1 to mc_vehicles do
49485: LD_ADDR_VAR 0 6
49489: PUSH
49490: DOUBLE
49491: LD_INT 1
49493: DEC
49494: ST_TO_ADDR
49495: LD_EXP 99
49499: PUSH
49500: FOR_TO
49501: IFFALSE 49606
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
49503: LD_VAR 0 2
49507: PUSH
49508: LD_EXP 99
49512: PUSH
49513: LD_VAR 0 6
49517: ARRAY
49518: IN
49519: PUSH
49520: LD_VAR 0 1
49524: PUSH
49525: LD_EXP 99
49529: PUSH
49530: LD_VAR 0 6
49534: ARRAY
49535: IN
49536: OR
49537: IFFALSE 49604
// begin tmp := mc_vehicles [ i ] diff old ;
49539: LD_ADDR_VAR 0 7
49543: PUSH
49544: LD_EXP 99
49548: PUSH
49549: LD_VAR 0 6
49553: ARRAY
49554: PUSH
49555: LD_VAR 0 2
49559: DIFF
49560: ST_TO_ADDR
// tmp := tmp diff new ;
49561: LD_ADDR_VAR 0 7
49565: PUSH
49566: LD_VAR 0 7
49570: PUSH
49571: LD_VAR 0 1
49575: DIFF
49576: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
49577: LD_ADDR_EXP 99
49581: PUSH
49582: LD_EXP 99
49586: PPUSH
49587: LD_VAR 0 6
49591: PPUSH
49592: LD_VAR 0 7
49596: PPUSH
49597: CALL_OW 1
49601: ST_TO_ADDR
// break ;
49602: GO 49606
// end ;
49604: GO 49500
49606: POP
49607: POP
// end ;
49608: LD_VAR 0 5
49612: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
49613: LD_INT 0
49615: PPUSH
49616: PPUSH
49617: PPUSH
49618: PPUSH
// if not mc_bases or not skirmish then
49619: LD_EXP 80
49623: NOT
49624: PUSH
49625: LD_EXP 78
49629: NOT
49630: OR
49631: IFFALSE 49635
// exit ;
49633: GO 50055
// repeat wait ( 0 0$1 ) ;
49635: LD_INT 35
49637: PPUSH
49638: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
49642: LD_EXP 124
49646: NOT
49647: IFFALSE 49635
// mc_block_vehicle_constructed_thread := true ;
49649: LD_ADDR_EXP 124
49653: PUSH
49654: LD_INT 1
49656: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
49657: LD_ADDR_VAR 0 5
49661: PUSH
49662: LD_VAR 0 1
49666: PPUSH
49667: CALL_OW 255
49671: ST_TO_ADDR
// for i = 1 to mc_bases do
49672: LD_ADDR_VAR 0 4
49676: PUSH
49677: DOUBLE
49678: LD_INT 1
49680: DEC
49681: ST_TO_ADDR
49682: LD_EXP 80
49686: PUSH
49687: FOR_TO
49688: IFFALSE 50045
// begin if factory in mc_bases [ i ] then
49690: LD_VAR 0 2
49694: PUSH
49695: LD_EXP 80
49699: PUSH
49700: LD_VAR 0 4
49704: ARRAY
49705: IN
49706: IFFALSE 50043
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
49708: LD_EXP 102
49712: PUSH
49713: LD_VAR 0 4
49717: ARRAY
49718: PUSH
49719: LD_EXP 91
49723: PUSH
49724: LD_VAR 0 4
49728: ARRAY
49729: LESS
49730: PUSH
49731: LD_VAR 0 1
49735: PPUSH
49736: CALL_OW 264
49740: PUSH
49741: LD_INT 31
49743: PUSH
49744: LD_INT 32
49746: PUSH
49747: LD_INT 51
49749: PUSH
49750: LD_INT 89
49752: PUSH
49753: LD_INT 12
49755: PUSH
49756: LD_INT 30
49758: PUSH
49759: LD_INT 98
49761: PUSH
49762: LD_INT 11
49764: PUSH
49765: LD_INT 53
49767: PUSH
49768: LD_INT 14
49770: PUSH
49771: LD_INT 91
49773: PUSH
49774: LD_INT 29
49776: PUSH
49777: LD_INT 99
49779: PUSH
49780: LD_INT 13
49782: PUSH
49783: LD_INT 52
49785: PUSH
49786: LD_INT 88
49788: PUSH
49789: LD_INT 48
49791: PUSH
49792: LD_INT 8
49794: PUSH
49795: EMPTY
49796: LIST
49797: LIST
49798: LIST
49799: LIST
49800: LIST
49801: LIST
49802: LIST
49803: LIST
49804: LIST
49805: LIST
49806: LIST
49807: LIST
49808: LIST
49809: LIST
49810: LIST
49811: LIST
49812: LIST
49813: LIST
49814: IN
49815: NOT
49816: AND
49817: IFFALSE 49865
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
49819: LD_ADDR_EXP 102
49823: PUSH
49824: LD_EXP 102
49828: PPUSH
49829: LD_VAR 0 4
49833: PUSH
49834: LD_EXP 102
49838: PUSH
49839: LD_VAR 0 4
49843: ARRAY
49844: PUSH
49845: LD_INT 1
49847: PLUS
49848: PUSH
49849: EMPTY
49850: LIST
49851: LIST
49852: PPUSH
49853: LD_VAR 0 1
49857: PPUSH
49858: CALL 58774 0 3
49862: ST_TO_ADDR
49863: GO 49909
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
49865: LD_ADDR_EXP 99
49869: PUSH
49870: LD_EXP 99
49874: PPUSH
49875: LD_VAR 0 4
49879: PUSH
49880: LD_EXP 99
49884: PUSH
49885: LD_VAR 0 4
49889: ARRAY
49890: PUSH
49891: LD_INT 1
49893: PLUS
49894: PUSH
49895: EMPTY
49896: LIST
49897: LIST
49898: PPUSH
49899: LD_VAR 0 1
49903: PPUSH
49904: CALL 58774 0 3
49908: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
49909: LD_ADDR_EXP 124
49913: PUSH
49914: LD_INT 0
49916: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
49917: LD_VAR 0 1
49921: PPUSH
49922: CALL_OW 263
49926: PUSH
49927: LD_INT 2
49929: EQUAL
49930: IFFALSE 49959
// begin repeat wait ( 0 0$3 ) ;
49932: LD_INT 105
49934: PPUSH
49935: CALL_OW 67
// Connect ( vehicle ) ;
49939: LD_VAR 0 1
49943: PPUSH
49944: CALL 62120 0 1
// until IsControledBy ( vehicle ) ;
49948: LD_VAR 0 1
49952: PPUSH
49953: CALL_OW 312
49957: IFFALSE 49932
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
49959: LD_VAR 0 1
49963: PPUSH
49964: LD_EXP 104
49968: PUSH
49969: LD_VAR 0 4
49973: ARRAY
49974: PPUSH
49975: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
49979: LD_VAR 0 1
49983: PPUSH
49984: CALL_OW 263
49988: PUSH
49989: LD_INT 1
49991: NONEQUAL
49992: IFFALSE 49996
// break ;
49994: GO 50045
// repeat wait ( 0 0$1 ) ;
49996: LD_INT 35
49998: PPUSH
49999: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
50003: LD_VAR 0 1
50007: PPUSH
50008: LD_EXP 104
50012: PUSH
50013: LD_VAR 0 4
50017: ARRAY
50018: PPUSH
50019: CALL_OW 308
50023: IFFALSE 49996
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
50025: LD_VAR 0 1
50029: PPUSH
50030: CALL_OW 311
50034: PPUSH
50035: CALL_OW 121
// exit ;
50039: POP
50040: POP
50041: GO 50055
// end ; end ;
50043: GO 49687
50045: POP
50046: POP
// mc_block_vehicle_constructed_thread := false ;
50047: LD_ADDR_EXP 124
50051: PUSH
50052: LD_INT 0
50054: ST_TO_ADDR
// end ;
50055: LD_VAR 0 3
50059: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
50060: LD_INT 0
50062: PPUSH
50063: PPUSH
50064: PPUSH
50065: PPUSH
// if not mc_bases or not skirmish then
50066: LD_EXP 80
50070: NOT
50071: PUSH
50072: LD_EXP 78
50076: NOT
50077: OR
50078: IFFALSE 50082
// exit ;
50080: GO 50435
// repeat wait ( 0 0$1 ) ;
50082: LD_INT 35
50084: PPUSH
50085: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
50089: LD_VAR 0 2
50093: PPUSH
50094: LD_VAR 0 3
50098: PPUSH
50099: CALL_OW 284
50103: IFFALSE 50082
// if GetResourceTypeXY ( x , y ) = mat_artefact then
50105: LD_VAR 0 2
50109: PPUSH
50110: LD_VAR 0 3
50114: PPUSH
50115: CALL_OW 283
50119: PUSH
50120: LD_INT 4
50122: EQUAL
50123: IFFALSE 50127
// exit ;
50125: GO 50435
// for i = 1 to mc_bases do
50127: LD_ADDR_VAR 0 7
50131: PUSH
50132: DOUBLE
50133: LD_INT 1
50135: DEC
50136: ST_TO_ADDR
50137: LD_EXP 80
50141: PUSH
50142: FOR_TO
50143: IFFALSE 50433
// begin if mc_crates_area [ i ] then
50145: LD_EXP 98
50149: PUSH
50150: LD_VAR 0 7
50154: ARRAY
50155: IFFALSE 50266
// for j in mc_crates_area [ i ] do
50157: LD_ADDR_VAR 0 8
50161: PUSH
50162: LD_EXP 98
50166: PUSH
50167: LD_VAR 0 7
50171: ARRAY
50172: PUSH
50173: FOR_IN
50174: IFFALSE 50264
// if InArea ( x , y , j ) then
50176: LD_VAR 0 2
50180: PPUSH
50181: LD_VAR 0 3
50185: PPUSH
50186: LD_VAR 0 8
50190: PPUSH
50191: CALL_OW 309
50195: IFFALSE 50262
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
50197: LD_ADDR_EXP 96
50201: PUSH
50202: LD_EXP 96
50206: PPUSH
50207: LD_VAR 0 7
50211: PUSH
50212: LD_EXP 96
50216: PUSH
50217: LD_VAR 0 7
50221: ARRAY
50222: PUSH
50223: LD_INT 1
50225: PLUS
50226: PUSH
50227: EMPTY
50228: LIST
50229: LIST
50230: PPUSH
50231: LD_VAR 0 4
50235: PUSH
50236: LD_VAR 0 2
50240: PUSH
50241: LD_VAR 0 3
50245: PUSH
50246: EMPTY
50247: LIST
50248: LIST
50249: LIST
50250: PPUSH
50251: CALL 58774 0 3
50255: ST_TO_ADDR
// exit ;
50256: POP
50257: POP
50258: POP
50259: POP
50260: GO 50435
// end ;
50262: GO 50173
50264: POP
50265: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50266: LD_ADDR_VAR 0 9
50270: PUSH
50271: LD_EXP 80
50275: PUSH
50276: LD_VAR 0 7
50280: ARRAY
50281: PPUSH
50282: LD_INT 2
50284: PUSH
50285: LD_INT 30
50287: PUSH
50288: LD_INT 0
50290: PUSH
50291: EMPTY
50292: LIST
50293: LIST
50294: PUSH
50295: LD_INT 30
50297: PUSH
50298: LD_INT 1
50300: PUSH
50301: EMPTY
50302: LIST
50303: LIST
50304: PUSH
50305: EMPTY
50306: LIST
50307: LIST
50308: LIST
50309: PPUSH
50310: CALL_OW 72
50314: ST_TO_ADDR
// if not depot then
50315: LD_VAR 0 9
50319: NOT
50320: IFFALSE 50324
// continue ;
50322: GO 50142
// for j in depot do
50324: LD_ADDR_VAR 0 8
50328: PUSH
50329: LD_VAR 0 9
50333: PUSH
50334: FOR_IN
50335: IFFALSE 50429
// if GetDistUnitXY ( j , x , y ) < 30 then
50337: LD_VAR 0 8
50341: PPUSH
50342: LD_VAR 0 2
50346: PPUSH
50347: LD_VAR 0 3
50351: PPUSH
50352: CALL_OW 297
50356: PUSH
50357: LD_INT 30
50359: LESS
50360: IFFALSE 50427
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
50362: LD_ADDR_EXP 96
50366: PUSH
50367: LD_EXP 96
50371: PPUSH
50372: LD_VAR 0 7
50376: PUSH
50377: LD_EXP 96
50381: PUSH
50382: LD_VAR 0 7
50386: ARRAY
50387: PUSH
50388: LD_INT 1
50390: PLUS
50391: PUSH
50392: EMPTY
50393: LIST
50394: LIST
50395: PPUSH
50396: LD_VAR 0 4
50400: PUSH
50401: LD_VAR 0 2
50405: PUSH
50406: LD_VAR 0 3
50410: PUSH
50411: EMPTY
50412: LIST
50413: LIST
50414: LIST
50415: PPUSH
50416: CALL 58774 0 3
50420: ST_TO_ADDR
// exit ;
50421: POP
50422: POP
50423: POP
50424: POP
50425: GO 50435
// end ;
50427: GO 50334
50429: POP
50430: POP
// end ;
50431: GO 50142
50433: POP
50434: POP
// end ;
50435: LD_VAR 0 6
50439: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
50440: LD_INT 0
50442: PPUSH
50443: PPUSH
50444: PPUSH
50445: PPUSH
// if not mc_bases or not skirmish then
50446: LD_EXP 80
50450: NOT
50451: PUSH
50452: LD_EXP 78
50456: NOT
50457: OR
50458: IFFALSE 50462
// exit ;
50460: GO 50739
// side := GetSide ( lab ) ;
50462: LD_ADDR_VAR 0 4
50466: PUSH
50467: LD_VAR 0 2
50471: PPUSH
50472: CALL_OW 255
50476: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
50477: LD_VAR 0 4
50481: PUSH
50482: LD_EXP 106
50486: IN
50487: NOT
50488: PUSH
50489: LD_EXP 107
50493: NOT
50494: OR
50495: PUSH
50496: LD_EXP 80
50500: NOT
50501: OR
50502: IFFALSE 50506
// exit ;
50504: GO 50739
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
50506: LD_ADDR_EXP 107
50510: PUSH
50511: LD_EXP 107
50515: PPUSH
50516: LD_VAR 0 4
50520: PPUSH
50521: LD_EXP 107
50525: PUSH
50526: LD_VAR 0 4
50530: ARRAY
50531: PUSH
50532: LD_VAR 0 1
50536: DIFF
50537: PPUSH
50538: CALL_OW 1
50542: ST_TO_ADDR
// for i = 1 to mc_bases do
50543: LD_ADDR_VAR 0 5
50547: PUSH
50548: DOUBLE
50549: LD_INT 1
50551: DEC
50552: ST_TO_ADDR
50553: LD_EXP 80
50557: PUSH
50558: FOR_TO
50559: IFFALSE 50737
// begin if lab in mc_bases [ i ] then
50561: LD_VAR 0 2
50565: PUSH
50566: LD_EXP 80
50570: PUSH
50571: LD_VAR 0 5
50575: ARRAY
50576: IN
50577: IFFALSE 50735
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
50579: LD_VAR 0 1
50583: PUSH
50584: LD_INT 11
50586: PUSH
50587: LD_INT 4
50589: PUSH
50590: LD_INT 3
50592: PUSH
50593: LD_INT 2
50595: PUSH
50596: EMPTY
50597: LIST
50598: LIST
50599: LIST
50600: LIST
50601: IN
50602: PUSH
50603: LD_EXP 110
50607: PUSH
50608: LD_VAR 0 5
50612: ARRAY
50613: AND
50614: IFFALSE 50735
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
50616: LD_ADDR_VAR 0 6
50620: PUSH
50621: LD_EXP 110
50625: PUSH
50626: LD_VAR 0 5
50630: ARRAY
50631: PUSH
50632: LD_INT 1
50634: ARRAY
50635: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50636: LD_ADDR_EXP 110
50640: PUSH
50641: LD_EXP 110
50645: PPUSH
50646: LD_VAR 0 5
50650: PPUSH
50651: EMPTY
50652: PPUSH
50653: CALL_OW 1
50657: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
50658: LD_VAR 0 6
50662: PPUSH
50663: LD_INT 0
50665: PPUSH
50666: CALL_OW 109
// ComExitBuilding ( tmp ) ;
50670: LD_VAR 0 6
50674: PPUSH
50675: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
50679: LD_ADDR_EXP 109
50683: PUSH
50684: LD_EXP 109
50688: PPUSH
50689: LD_VAR 0 5
50693: PPUSH
50694: LD_EXP 109
50698: PUSH
50699: LD_VAR 0 5
50703: ARRAY
50704: PPUSH
50705: LD_INT 1
50707: PPUSH
50708: LD_VAR 0 6
50712: PPUSH
50713: CALL_OW 2
50717: PPUSH
50718: CALL_OW 1
50722: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
50723: LD_VAR 0 5
50727: PPUSH
50728: LD_INT 112
50730: PPUSH
50731: CALL 27189 0 2
// end ; end ; end ;
50735: GO 50558
50737: POP
50738: POP
// end ;
50739: LD_VAR 0 3
50743: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
50744: LD_INT 0
50746: PPUSH
50747: PPUSH
50748: PPUSH
50749: PPUSH
50750: PPUSH
50751: PPUSH
50752: PPUSH
50753: PPUSH
// if not mc_bases or not skirmish then
50754: LD_EXP 80
50758: NOT
50759: PUSH
50760: LD_EXP 78
50764: NOT
50765: OR
50766: IFFALSE 50770
// exit ;
50768: GO 52139
// for i = 1 to mc_bases do
50770: LD_ADDR_VAR 0 3
50774: PUSH
50775: DOUBLE
50776: LD_INT 1
50778: DEC
50779: ST_TO_ADDR
50780: LD_EXP 80
50784: PUSH
50785: FOR_TO
50786: IFFALSE 52137
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
50788: LD_VAR 0 1
50792: PUSH
50793: LD_EXP 80
50797: PUSH
50798: LD_VAR 0 3
50802: ARRAY
50803: IN
50804: PUSH
50805: LD_VAR 0 1
50809: PUSH
50810: LD_EXP 87
50814: PUSH
50815: LD_VAR 0 3
50819: ARRAY
50820: IN
50821: OR
50822: PUSH
50823: LD_VAR 0 1
50827: PUSH
50828: LD_EXP 102
50832: PUSH
50833: LD_VAR 0 3
50837: ARRAY
50838: IN
50839: OR
50840: PUSH
50841: LD_VAR 0 1
50845: PUSH
50846: LD_EXP 99
50850: PUSH
50851: LD_VAR 0 3
50855: ARRAY
50856: IN
50857: OR
50858: PUSH
50859: LD_VAR 0 1
50863: PUSH
50864: LD_EXP 109
50868: PUSH
50869: LD_VAR 0 3
50873: ARRAY
50874: IN
50875: OR
50876: PUSH
50877: LD_VAR 0 1
50881: PUSH
50882: LD_EXP 110
50886: PUSH
50887: LD_VAR 0 3
50891: ARRAY
50892: IN
50893: OR
50894: IFFALSE 52135
// begin if un in mc_ape [ i ] then
50896: LD_VAR 0 1
50900: PUSH
50901: LD_EXP 109
50905: PUSH
50906: LD_VAR 0 3
50910: ARRAY
50911: IN
50912: IFFALSE 50951
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
50914: LD_ADDR_EXP 109
50918: PUSH
50919: LD_EXP 109
50923: PPUSH
50924: LD_VAR 0 3
50928: PPUSH
50929: LD_EXP 109
50933: PUSH
50934: LD_VAR 0 3
50938: ARRAY
50939: PUSH
50940: LD_VAR 0 1
50944: DIFF
50945: PPUSH
50946: CALL_OW 1
50950: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
50951: LD_VAR 0 1
50955: PUSH
50956: LD_EXP 110
50960: PUSH
50961: LD_VAR 0 3
50965: ARRAY
50966: IN
50967: IFFALSE 50991
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50969: LD_ADDR_EXP 110
50973: PUSH
50974: LD_EXP 110
50978: PPUSH
50979: LD_VAR 0 3
50983: PPUSH
50984: EMPTY
50985: PPUSH
50986: CALL_OW 1
50990: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
50991: LD_VAR 0 1
50995: PPUSH
50996: CALL_OW 247
51000: PUSH
51001: LD_INT 2
51003: EQUAL
51004: PUSH
51005: LD_VAR 0 1
51009: PPUSH
51010: CALL_OW 110
51014: PUSH
51015: LD_INT 20
51017: EQUAL
51018: PUSH
51019: LD_VAR 0 1
51023: PUSH
51024: LD_EXP 102
51028: PUSH
51029: LD_VAR 0 3
51033: ARRAY
51034: IN
51035: OR
51036: PUSH
51037: LD_VAR 0 1
51041: PPUSH
51042: CALL_OW 264
51046: PUSH
51047: LD_INT 12
51049: PUSH
51050: LD_INT 51
51052: PUSH
51053: LD_INT 89
51055: PUSH
51056: LD_INT 32
51058: PUSH
51059: LD_INT 13
51061: PUSH
51062: LD_INT 52
51064: PUSH
51065: LD_INT 31
51067: PUSH
51068: EMPTY
51069: LIST
51070: LIST
51071: LIST
51072: LIST
51073: LIST
51074: LIST
51075: LIST
51076: IN
51077: OR
51078: AND
51079: IFFALSE 51387
// begin if un in mc_defender [ i ] then
51081: LD_VAR 0 1
51085: PUSH
51086: LD_EXP 102
51090: PUSH
51091: LD_VAR 0 3
51095: ARRAY
51096: IN
51097: IFFALSE 51136
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51099: LD_ADDR_EXP 102
51103: PUSH
51104: LD_EXP 102
51108: PPUSH
51109: LD_VAR 0 3
51113: PPUSH
51114: LD_EXP 102
51118: PUSH
51119: LD_VAR 0 3
51123: ARRAY
51124: PUSH
51125: LD_VAR 0 1
51129: DIFF
51130: PPUSH
51131: CALL_OW 1
51135: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
51136: LD_ADDR_VAR 0 8
51140: PUSH
51141: LD_VAR 0 3
51145: PPUSH
51146: LD_INT 3
51148: PPUSH
51149: CALL 47757 0 2
51153: ST_TO_ADDR
// if fac then
51154: LD_VAR 0 8
51158: IFFALSE 51387
// begin for j in fac do
51160: LD_ADDR_VAR 0 4
51164: PUSH
51165: LD_VAR 0 8
51169: PUSH
51170: FOR_IN
51171: IFFALSE 51385
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
51173: LD_ADDR_VAR 0 9
51177: PUSH
51178: LD_VAR 0 8
51182: PPUSH
51183: LD_VAR 0 1
51187: PPUSH
51188: CALL_OW 265
51192: PPUSH
51193: LD_VAR 0 1
51197: PPUSH
51198: CALL_OW 262
51202: PPUSH
51203: LD_VAR 0 1
51207: PPUSH
51208: CALL_OW 263
51212: PPUSH
51213: LD_VAR 0 1
51217: PPUSH
51218: CALL_OW 264
51222: PPUSH
51223: CALL 56272 0 5
51227: ST_TO_ADDR
// if components then
51228: LD_VAR 0 9
51232: IFFALSE 51383
// begin if GetWeapon ( un ) = ar_control_tower then
51234: LD_VAR 0 1
51238: PPUSH
51239: CALL_OW 264
51243: PUSH
51244: LD_INT 31
51246: EQUAL
51247: IFFALSE 51364
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
51249: LD_VAR 0 1
51253: PPUSH
51254: CALL_OW 311
51258: PPUSH
51259: LD_INT 0
51261: PPUSH
51262: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
51266: LD_ADDR_EXP 120
51270: PUSH
51271: LD_EXP 120
51275: PPUSH
51276: LD_VAR 0 3
51280: PPUSH
51281: LD_EXP 120
51285: PUSH
51286: LD_VAR 0 3
51290: ARRAY
51291: PUSH
51292: LD_VAR 0 1
51296: PPUSH
51297: CALL_OW 311
51301: DIFF
51302: PPUSH
51303: CALL_OW 1
51307: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
51308: LD_ADDR_VAR 0 7
51312: PUSH
51313: LD_EXP 101
51317: PUSH
51318: LD_VAR 0 3
51322: ARRAY
51323: PPUSH
51324: LD_INT 1
51326: PPUSH
51327: LD_VAR 0 9
51331: PPUSH
51332: CALL_OW 2
51336: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
51337: LD_ADDR_EXP 101
51341: PUSH
51342: LD_EXP 101
51346: PPUSH
51347: LD_VAR 0 3
51351: PPUSH
51352: LD_VAR 0 7
51356: PPUSH
51357: CALL_OW 1
51361: ST_TO_ADDR
// end else
51362: GO 51381
// MC_InsertProduceList ( i , [ components ] ) ;
51364: LD_VAR 0 3
51368: PPUSH
51369: LD_VAR 0 9
51373: PUSH
51374: EMPTY
51375: LIST
51376: PPUSH
51377: CALL 47302 0 2
// break ;
51381: GO 51385
// end ; end ;
51383: GO 51170
51385: POP
51386: POP
// end ; end ; if GetType ( un ) = unit_building then
51387: LD_VAR 0 1
51391: PPUSH
51392: CALL_OW 247
51396: PUSH
51397: LD_INT 3
51399: EQUAL
51400: IFFALSE 51803
// begin btype := GetBType ( un ) ;
51402: LD_ADDR_VAR 0 5
51406: PUSH
51407: LD_VAR 0 1
51411: PPUSH
51412: CALL_OW 266
51416: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
51417: LD_VAR 0 5
51421: PUSH
51422: LD_INT 29
51424: PUSH
51425: LD_INT 30
51427: PUSH
51428: EMPTY
51429: LIST
51430: LIST
51431: IN
51432: IFFALSE 51505
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
51434: LD_VAR 0 1
51438: PPUSH
51439: CALL_OW 250
51443: PPUSH
51444: LD_VAR 0 1
51448: PPUSH
51449: CALL_OW 251
51453: PPUSH
51454: LD_VAR 0 1
51458: PPUSH
51459: CALL_OW 255
51463: PPUSH
51464: CALL_OW 440
51468: NOT
51469: IFFALSE 51505
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
51471: LD_VAR 0 1
51475: PPUSH
51476: CALL_OW 250
51480: PPUSH
51481: LD_VAR 0 1
51485: PPUSH
51486: CALL_OW 251
51490: PPUSH
51491: LD_VAR 0 1
51495: PPUSH
51496: CALL_OW 255
51500: PPUSH
51501: CALL_OW 441
// end ; if btype = b_warehouse then
51505: LD_VAR 0 5
51509: PUSH
51510: LD_INT 1
51512: EQUAL
51513: IFFALSE 51531
// begin btype := b_depot ;
51515: LD_ADDR_VAR 0 5
51519: PUSH
51520: LD_INT 0
51522: ST_TO_ADDR
// pos := 1 ;
51523: LD_ADDR_VAR 0 6
51527: PUSH
51528: LD_INT 1
51530: ST_TO_ADDR
// end ; if btype = b_factory then
51531: LD_VAR 0 5
51535: PUSH
51536: LD_INT 3
51538: EQUAL
51539: IFFALSE 51557
// begin btype := b_workshop ;
51541: LD_ADDR_VAR 0 5
51545: PUSH
51546: LD_INT 2
51548: ST_TO_ADDR
// pos := 1 ;
51549: LD_ADDR_VAR 0 6
51553: PUSH
51554: LD_INT 1
51556: ST_TO_ADDR
// end ; if btype = b_barracks then
51557: LD_VAR 0 5
51561: PUSH
51562: LD_INT 5
51564: EQUAL
51565: IFFALSE 51575
// btype := b_armoury ;
51567: LD_ADDR_VAR 0 5
51571: PUSH
51572: LD_INT 4
51574: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
51575: LD_VAR 0 5
51579: PUSH
51580: LD_INT 7
51582: PUSH
51583: LD_INT 8
51585: PUSH
51586: EMPTY
51587: LIST
51588: LIST
51589: IN
51590: IFFALSE 51600
// btype := b_lab ;
51592: LD_ADDR_VAR 0 5
51596: PUSH
51597: LD_INT 6
51599: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
51600: LD_ADDR_EXP 85
51604: PUSH
51605: LD_EXP 85
51609: PPUSH
51610: LD_VAR 0 3
51614: PUSH
51615: LD_EXP 85
51619: PUSH
51620: LD_VAR 0 3
51624: ARRAY
51625: PUSH
51626: LD_INT 1
51628: PLUS
51629: PUSH
51630: EMPTY
51631: LIST
51632: LIST
51633: PPUSH
51634: LD_VAR 0 5
51638: PUSH
51639: LD_VAR 0 1
51643: PPUSH
51644: CALL_OW 250
51648: PUSH
51649: LD_VAR 0 1
51653: PPUSH
51654: CALL_OW 251
51658: PUSH
51659: LD_VAR 0 1
51663: PPUSH
51664: CALL_OW 254
51668: PUSH
51669: EMPTY
51670: LIST
51671: LIST
51672: LIST
51673: LIST
51674: PPUSH
51675: CALL 58774 0 3
51679: ST_TO_ADDR
// if pos = 1 then
51680: LD_VAR 0 6
51684: PUSH
51685: LD_INT 1
51687: EQUAL
51688: IFFALSE 51803
// begin tmp := mc_build_list [ i ] ;
51690: LD_ADDR_VAR 0 7
51694: PUSH
51695: LD_EXP 85
51699: PUSH
51700: LD_VAR 0 3
51704: ARRAY
51705: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51706: LD_VAR 0 7
51710: PPUSH
51711: LD_INT 2
51713: PUSH
51714: LD_INT 30
51716: PUSH
51717: LD_INT 0
51719: PUSH
51720: EMPTY
51721: LIST
51722: LIST
51723: PUSH
51724: LD_INT 30
51726: PUSH
51727: LD_INT 1
51729: PUSH
51730: EMPTY
51731: LIST
51732: LIST
51733: PUSH
51734: EMPTY
51735: LIST
51736: LIST
51737: LIST
51738: PPUSH
51739: CALL_OW 72
51743: IFFALSE 51753
// pos := 2 ;
51745: LD_ADDR_VAR 0 6
51749: PUSH
51750: LD_INT 2
51752: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
51753: LD_ADDR_VAR 0 7
51757: PUSH
51758: LD_VAR 0 7
51762: PPUSH
51763: LD_VAR 0 6
51767: PPUSH
51768: LD_VAR 0 7
51772: PPUSH
51773: CALL 59100 0 3
51777: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
51778: LD_ADDR_EXP 85
51782: PUSH
51783: LD_EXP 85
51787: PPUSH
51788: LD_VAR 0 3
51792: PPUSH
51793: LD_VAR 0 7
51797: PPUSH
51798: CALL_OW 1
51802: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
51803: LD_VAR 0 1
51807: PUSH
51808: LD_EXP 80
51812: PUSH
51813: LD_VAR 0 3
51817: ARRAY
51818: IN
51819: IFFALSE 51858
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
51821: LD_ADDR_EXP 80
51825: PUSH
51826: LD_EXP 80
51830: PPUSH
51831: LD_VAR 0 3
51835: PPUSH
51836: LD_EXP 80
51840: PUSH
51841: LD_VAR 0 3
51845: ARRAY
51846: PUSH
51847: LD_VAR 0 1
51851: DIFF
51852: PPUSH
51853: CALL_OW 1
51857: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
51858: LD_VAR 0 1
51862: PUSH
51863: LD_EXP 87
51867: PUSH
51868: LD_VAR 0 3
51872: ARRAY
51873: IN
51874: IFFALSE 51913
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
51876: LD_ADDR_EXP 87
51880: PUSH
51881: LD_EXP 87
51885: PPUSH
51886: LD_VAR 0 3
51890: PPUSH
51891: LD_EXP 87
51895: PUSH
51896: LD_VAR 0 3
51900: ARRAY
51901: PUSH
51902: LD_VAR 0 1
51906: DIFF
51907: PPUSH
51908: CALL_OW 1
51912: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
51913: LD_VAR 0 1
51917: PUSH
51918: LD_EXP 99
51922: PUSH
51923: LD_VAR 0 3
51927: ARRAY
51928: IN
51929: IFFALSE 51968
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
51931: LD_ADDR_EXP 99
51935: PUSH
51936: LD_EXP 99
51940: PPUSH
51941: LD_VAR 0 3
51945: PPUSH
51946: LD_EXP 99
51950: PUSH
51951: LD_VAR 0 3
51955: ARRAY
51956: PUSH
51957: LD_VAR 0 1
51961: DIFF
51962: PPUSH
51963: CALL_OW 1
51967: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
51968: LD_VAR 0 1
51972: PUSH
51973: LD_EXP 102
51977: PUSH
51978: LD_VAR 0 3
51982: ARRAY
51983: IN
51984: IFFALSE 52023
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51986: LD_ADDR_EXP 102
51990: PUSH
51991: LD_EXP 102
51995: PPUSH
51996: LD_VAR 0 3
52000: PPUSH
52001: LD_EXP 102
52005: PUSH
52006: LD_VAR 0 3
52010: ARRAY
52011: PUSH
52012: LD_VAR 0 1
52016: DIFF
52017: PPUSH
52018: CALL_OW 1
52022: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
52023: LD_VAR 0 1
52027: PUSH
52028: LD_EXP 89
52032: PUSH
52033: LD_VAR 0 3
52037: ARRAY
52038: IN
52039: IFFALSE 52078
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
52041: LD_ADDR_EXP 89
52045: PUSH
52046: LD_EXP 89
52050: PPUSH
52051: LD_VAR 0 3
52055: PPUSH
52056: LD_EXP 89
52060: PUSH
52061: LD_VAR 0 3
52065: ARRAY
52066: PUSH
52067: LD_VAR 0 1
52071: DIFF
52072: PPUSH
52073: CALL_OW 1
52077: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
52078: LD_VAR 0 1
52082: PUSH
52083: LD_EXP 88
52087: PUSH
52088: LD_VAR 0 3
52092: ARRAY
52093: IN
52094: IFFALSE 52133
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
52096: LD_ADDR_EXP 88
52100: PUSH
52101: LD_EXP 88
52105: PPUSH
52106: LD_VAR 0 3
52110: PPUSH
52111: LD_EXP 88
52115: PUSH
52116: LD_VAR 0 3
52120: ARRAY
52121: PUSH
52122: LD_VAR 0 1
52126: DIFF
52127: PPUSH
52128: CALL_OW 1
52132: ST_TO_ADDR
// end ; break ;
52133: GO 52137
// end ;
52135: GO 50785
52137: POP
52138: POP
// end ;
52139: LD_VAR 0 2
52143: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
52144: LD_INT 0
52146: PPUSH
52147: PPUSH
52148: PPUSH
// if not mc_bases or not skirmish then
52149: LD_EXP 80
52153: NOT
52154: PUSH
52155: LD_EXP 78
52159: NOT
52160: OR
52161: IFFALSE 52165
// exit ;
52163: GO 52380
// for i = 1 to mc_bases do
52165: LD_ADDR_VAR 0 3
52169: PUSH
52170: DOUBLE
52171: LD_INT 1
52173: DEC
52174: ST_TO_ADDR
52175: LD_EXP 80
52179: PUSH
52180: FOR_TO
52181: IFFALSE 52378
// begin if building in mc_construct_list [ i ] then
52183: LD_VAR 0 1
52187: PUSH
52188: LD_EXP 87
52192: PUSH
52193: LD_VAR 0 3
52197: ARRAY
52198: IN
52199: IFFALSE 52376
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52201: LD_ADDR_EXP 87
52205: PUSH
52206: LD_EXP 87
52210: PPUSH
52211: LD_VAR 0 3
52215: PPUSH
52216: LD_EXP 87
52220: PUSH
52221: LD_VAR 0 3
52225: ARRAY
52226: PUSH
52227: LD_VAR 0 1
52231: DIFF
52232: PPUSH
52233: CALL_OW 1
52237: ST_TO_ADDR
// if building in mc_lab [ i ] then
52238: LD_VAR 0 1
52242: PUSH
52243: LD_EXP 113
52247: PUSH
52248: LD_VAR 0 3
52252: ARRAY
52253: IN
52254: IFFALSE 52309
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
52256: LD_ADDR_EXP 114
52260: PUSH
52261: LD_EXP 114
52265: PPUSH
52266: LD_VAR 0 3
52270: PPUSH
52271: LD_EXP 114
52275: PUSH
52276: LD_VAR 0 3
52280: ARRAY
52281: PPUSH
52282: LD_INT 1
52284: PPUSH
52285: LD_EXP 114
52289: PUSH
52290: LD_VAR 0 3
52294: ARRAY
52295: PPUSH
52296: LD_INT 0
52298: PPUSH
52299: CALL 58192 0 4
52303: PPUSH
52304: CALL_OW 1
52308: ST_TO_ADDR
// if not building in mc_bases [ i ] then
52309: LD_VAR 0 1
52313: PUSH
52314: LD_EXP 80
52318: PUSH
52319: LD_VAR 0 3
52323: ARRAY
52324: IN
52325: NOT
52326: IFFALSE 52372
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52328: LD_ADDR_EXP 80
52332: PUSH
52333: LD_EXP 80
52337: PPUSH
52338: LD_VAR 0 3
52342: PUSH
52343: LD_EXP 80
52347: PUSH
52348: LD_VAR 0 3
52352: ARRAY
52353: PUSH
52354: LD_INT 1
52356: PLUS
52357: PUSH
52358: EMPTY
52359: LIST
52360: LIST
52361: PPUSH
52362: LD_VAR 0 1
52366: PPUSH
52367: CALL 58774 0 3
52371: ST_TO_ADDR
// exit ;
52372: POP
52373: POP
52374: GO 52380
// end ; end ;
52376: GO 52180
52378: POP
52379: POP
// end ;
52380: LD_VAR 0 2
52384: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
52385: LD_INT 0
52387: PPUSH
52388: PPUSH
52389: PPUSH
52390: PPUSH
52391: PPUSH
52392: PPUSH
52393: PPUSH
// if not mc_bases or not skirmish then
52394: LD_EXP 80
52398: NOT
52399: PUSH
52400: LD_EXP 78
52404: NOT
52405: OR
52406: IFFALSE 52410
// exit ;
52408: GO 53071
// for i = 1 to mc_bases do
52410: LD_ADDR_VAR 0 3
52414: PUSH
52415: DOUBLE
52416: LD_INT 1
52418: DEC
52419: ST_TO_ADDR
52420: LD_EXP 80
52424: PUSH
52425: FOR_TO
52426: IFFALSE 53069
// begin if building in mc_construct_list [ i ] then
52428: LD_VAR 0 1
52432: PUSH
52433: LD_EXP 87
52437: PUSH
52438: LD_VAR 0 3
52442: ARRAY
52443: IN
52444: IFFALSE 53067
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52446: LD_ADDR_EXP 87
52450: PUSH
52451: LD_EXP 87
52455: PPUSH
52456: LD_VAR 0 3
52460: PPUSH
52461: LD_EXP 87
52465: PUSH
52466: LD_VAR 0 3
52470: ARRAY
52471: PUSH
52472: LD_VAR 0 1
52476: DIFF
52477: PPUSH
52478: CALL_OW 1
52482: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52483: LD_ADDR_EXP 80
52487: PUSH
52488: LD_EXP 80
52492: PPUSH
52493: LD_VAR 0 3
52497: PUSH
52498: LD_EXP 80
52502: PUSH
52503: LD_VAR 0 3
52507: ARRAY
52508: PUSH
52509: LD_INT 1
52511: PLUS
52512: PUSH
52513: EMPTY
52514: LIST
52515: LIST
52516: PPUSH
52517: LD_VAR 0 1
52521: PPUSH
52522: CALL 58774 0 3
52526: ST_TO_ADDR
// btype := GetBType ( building ) ;
52527: LD_ADDR_VAR 0 5
52531: PUSH
52532: LD_VAR 0 1
52536: PPUSH
52537: CALL_OW 266
52541: ST_TO_ADDR
// side := GetSide ( building ) ;
52542: LD_ADDR_VAR 0 8
52546: PUSH
52547: LD_VAR 0 1
52551: PPUSH
52552: CALL_OW 255
52556: ST_TO_ADDR
// if btype = b_lab then
52557: LD_VAR 0 5
52561: PUSH
52562: LD_INT 6
52564: EQUAL
52565: IFFALSE 52615
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
52567: LD_ADDR_EXP 113
52571: PUSH
52572: LD_EXP 113
52576: PPUSH
52577: LD_VAR 0 3
52581: PUSH
52582: LD_EXP 113
52586: PUSH
52587: LD_VAR 0 3
52591: ARRAY
52592: PUSH
52593: LD_INT 1
52595: PLUS
52596: PUSH
52597: EMPTY
52598: LIST
52599: LIST
52600: PPUSH
52601: LD_VAR 0 1
52605: PPUSH
52606: CALL 58774 0 3
52610: ST_TO_ADDR
// exit ;
52611: POP
52612: POP
52613: GO 53071
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
52615: LD_VAR 0 5
52619: PUSH
52620: LD_INT 0
52622: PUSH
52623: LD_INT 2
52625: PUSH
52626: LD_INT 4
52628: PUSH
52629: EMPTY
52630: LIST
52631: LIST
52632: LIST
52633: IN
52634: IFFALSE 52758
// begin if btype = b_armoury then
52636: LD_VAR 0 5
52640: PUSH
52641: LD_INT 4
52643: EQUAL
52644: IFFALSE 52654
// btype := b_barracks ;
52646: LD_ADDR_VAR 0 5
52650: PUSH
52651: LD_INT 5
52653: ST_TO_ADDR
// if btype = b_depot then
52654: LD_VAR 0 5
52658: PUSH
52659: LD_INT 0
52661: EQUAL
52662: IFFALSE 52672
// btype := b_warehouse ;
52664: LD_ADDR_VAR 0 5
52668: PUSH
52669: LD_INT 1
52671: ST_TO_ADDR
// if btype = b_workshop then
52672: LD_VAR 0 5
52676: PUSH
52677: LD_INT 2
52679: EQUAL
52680: IFFALSE 52690
// btype := b_factory ;
52682: LD_ADDR_VAR 0 5
52686: PUSH
52687: LD_INT 3
52689: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
52690: LD_VAR 0 5
52694: PPUSH
52695: LD_VAR 0 8
52699: PPUSH
52700: CALL_OW 323
52704: PUSH
52705: LD_INT 1
52707: EQUAL
52708: IFFALSE 52754
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
52710: LD_ADDR_EXP 112
52714: PUSH
52715: LD_EXP 112
52719: PPUSH
52720: LD_VAR 0 3
52724: PUSH
52725: LD_EXP 112
52729: PUSH
52730: LD_VAR 0 3
52734: ARRAY
52735: PUSH
52736: LD_INT 1
52738: PLUS
52739: PUSH
52740: EMPTY
52741: LIST
52742: LIST
52743: PPUSH
52744: LD_VAR 0 1
52748: PPUSH
52749: CALL 58774 0 3
52753: ST_TO_ADDR
// exit ;
52754: POP
52755: POP
52756: GO 53071
// end ; if btype in [ b_bunker , b_turret ] then
52758: LD_VAR 0 5
52762: PUSH
52763: LD_INT 32
52765: PUSH
52766: LD_INT 33
52768: PUSH
52769: EMPTY
52770: LIST
52771: LIST
52772: IN
52773: IFFALSE 53063
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
52775: LD_ADDR_EXP 88
52779: PUSH
52780: LD_EXP 88
52784: PPUSH
52785: LD_VAR 0 3
52789: PUSH
52790: LD_EXP 88
52794: PUSH
52795: LD_VAR 0 3
52799: ARRAY
52800: PUSH
52801: LD_INT 1
52803: PLUS
52804: PUSH
52805: EMPTY
52806: LIST
52807: LIST
52808: PPUSH
52809: LD_VAR 0 1
52813: PPUSH
52814: CALL 58774 0 3
52818: ST_TO_ADDR
// if btype = b_bunker then
52819: LD_VAR 0 5
52823: PUSH
52824: LD_INT 32
52826: EQUAL
52827: IFFALSE 53063
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52829: LD_ADDR_EXP 89
52833: PUSH
52834: LD_EXP 89
52838: PPUSH
52839: LD_VAR 0 3
52843: PUSH
52844: LD_EXP 89
52848: PUSH
52849: LD_VAR 0 3
52853: ARRAY
52854: PUSH
52855: LD_INT 1
52857: PLUS
52858: PUSH
52859: EMPTY
52860: LIST
52861: LIST
52862: PPUSH
52863: LD_VAR 0 1
52867: PPUSH
52868: CALL 58774 0 3
52872: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
52873: LD_ADDR_VAR 0 6
52877: PUSH
52878: LD_EXP 80
52882: PUSH
52883: LD_VAR 0 3
52887: ARRAY
52888: PPUSH
52889: LD_INT 25
52891: PUSH
52892: LD_INT 1
52894: PUSH
52895: EMPTY
52896: LIST
52897: LIST
52898: PUSH
52899: LD_INT 3
52901: PUSH
52902: LD_INT 54
52904: PUSH
52905: EMPTY
52906: LIST
52907: PUSH
52908: EMPTY
52909: LIST
52910: LIST
52911: PUSH
52912: EMPTY
52913: LIST
52914: LIST
52915: PPUSH
52916: CALL_OW 72
52920: ST_TO_ADDR
// if tmp then
52921: LD_VAR 0 6
52925: IFFALSE 52931
// exit ;
52927: POP
52928: POP
52929: GO 53071
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52931: LD_ADDR_VAR 0 6
52935: PUSH
52936: LD_EXP 80
52940: PUSH
52941: LD_VAR 0 3
52945: ARRAY
52946: PPUSH
52947: LD_INT 2
52949: PUSH
52950: LD_INT 30
52952: PUSH
52953: LD_INT 4
52955: PUSH
52956: EMPTY
52957: LIST
52958: LIST
52959: PUSH
52960: LD_INT 30
52962: PUSH
52963: LD_INT 5
52965: PUSH
52966: EMPTY
52967: LIST
52968: LIST
52969: PUSH
52970: EMPTY
52971: LIST
52972: LIST
52973: LIST
52974: PPUSH
52975: CALL_OW 72
52979: ST_TO_ADDR
// if not tmp then
52980: LD_VAR 0 6
52984: NOT
52985: IFFALSE 52991
// exit ;
52987: POP
52988: POP
52989: GO 53071
// for j in tmp do
52991: LD_ADDR_VAR 0 4
52995: PUSH
52996: LD_VAR 0 6
53000: PUSH
53001: FOR_IN
53002: IFFALSE 53061
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
53004: LD_ADDR_VAR 0 7
53008: PUSH
53009: LD_VAR 0 4
53013: PPUSH
53014: CALL_OW 313
53018: PPUSH
53019: LD_INT 25
53021: PUSH
53022: LD_INT 1
53024: PUSH
53025: EMPTY
53026: LIST
53027: LIST
53028: PPUSH
53029: CALL_OW 72
53033: ST_TO_ADDR
// if units then
53034: LD_VAR 0 7
53038: IFFALSE 53059
// begin ComExitBuilding ( units [ 1 ] ) ;
53040: LD_VAR 0 7
53044: PUSH
53045: LD_INT 1
53047: ARRAY
53048: PPUSH
53049: CALL_OW 122
// exit ;
53053: POP
53054: POP
53055: POP
53056: POP
53057: GO 53071
// end ; end ;
53059: GO 53001
53061: POP
53062: POP
// end ; end ; exit ;
53063: POP
53064: POP
53065: GO 53071
// end ; end ;
53067: GO 52425
53069: POP
53070: POP
// end ;
53071: LD_VAR 0 2
53075: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
53076: LD_INT 0
53078: PPUSH
53079: PPUSH
53080: PPUSH
53081: PPUSH
53082: PPUSH
53083: PPUSH
53084: PPUSH
// if not mc_bases or not skirmish then
53085: LD_EXP 80
53089: NOT
53090: PUSH
53091: LD_EXP 78
53095: NOT
53096: OR
53097: IFFALSE 53101
// exit ;
53099: GO 53366
// btype := GetBType ( building ) ;
53101: LD_ADDR_VAR 0 6
53105: PUSH
53106: LD_VAR 0 1
53110: PPUSH
53111: CALL_OW 266
53115: ST_TO_ADDR
// x := GetX ( building ) ;
53116: LD_ADDR_VAR 0 7
53120: PUSH
53121: LD_VAR 0 1
53125: PPUSH
53126: CALL_OW 250
53130: ST_TO_ADDR
// y := GetY ( building ) ;
53131: LD_ADDR_VAR 0 8
53135: PUSH
53136: LD_VAR 0 1
53140: PPUSH
53141: CALL_OW 251
53145: ST_TO_ADDR
// d := GetDir ( building ) ;
53146: LD_ADDR_VAR 0 9
53150: PUSH
53151: LD_VAR 0 1
53155: PPUSH
53156: CALL_OW 254
53160: ST_TO_ADDR
// for i = 1 to mc_bases do
53161: LD_ADDR_VAR 0 4
53165: PUSH
53166: DOUBLE
53167: LD_INT 1
53169: DEC
53170: ST_TO_ADDR
53171: LD_EXP 80
53175: PUSH
53176: FOR_TO
53177: IFFALSE 53364
// begin if not mc_build_list [ i ] then
53179: LD_EXP 85
53183: PUSH
53184: LD_VAR 0 4
53188: ARRAY
53189: NOT
53190: IFFALSE 53194
// continue ;
53192: GO 53176
// for j := 1 to mc_build_list [ i ] do
53194: LD_ADDR_VAR 0 5
53198: PUSH
53199: DOUBLE
53200: LD_INT 1
53202: DEC
53203: ST_TO_ADDR
53204: LD_EXP 85
53208: PUSH
53209: LD_VAR 0 4
53213: ARRAY
53214: PUSH
53215: FOR_TO
53216: IFFALSE 53360
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
53218: LD_VAR 0 6
53222: PUSH
53223: LD_VAR 0 7
53227: PUSH
53228: LD_VAR 0 8
53232: PUSH
53233: LD_VAR 0 9
53237: PUSH
53238: EMPTY
53239: LIST
53240: LIST
53241: LIST
53242: LIST
53243: PPUSH
53244: LD_EXP 85
53248: PUSH
53249: LD_VAR 0 4
53253: ARRAY
53254: PUSH
53255: LD_VAR 0 5
53259: ARRAY
53260: PPUSH
53261: CALL 65331 0 2
53265: IFFALSE 53358
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
53267: LD_ADDR_EXP 85
53271: PUSH
53272: LD_EXP 85
53276: PPUSH
53277: LD_VAR 0 4
53281: PPUSH
53282: LD_EXP 85
53286: PUSH
53287: LD_VAR 0 4
53291: ARRAY
53292: PPUSH
53293: LD_VAR 0 5
53297: PPUSH
53298: CALL_OW 3
53302: PPUSH
53303: CALL_OW 1
53307: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
53308: LD_ADDR_EXP 87
53312: PUSH
53313: LD_EXP 87
53317: PPUSH
53318: LD_VAR 0 4
53322: PUSH
53323: LD_EXP 87
53327: PUSH
53328: LD_VAR 0 4
53332: ARRAY
53333: PUSH
53334: LD_INT 1
53336: PLUS
53337: PUSH
53338: EMPTY
53339: LIST
53340: LIST
53341: PPUSH
53342: LD_VAR 0 1
53346: PPUSH
53347: CALL 58774 0 3
53351: ST_TO_ADDR
// exit ;
53352: POP
53353: POP
53354: POP
53355: POP
53356: GO 53366
// end ;
53358: GO 53215
53360: POP
53361: POP
// end ;
53362: GO 53176
53364: POP
53365: POP
// end ;
53366: LD_VAR 0 3
53370: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
53371: LD_INT 0
53373: PPUSH
53374: PPUSH
53375: PPUSH
// if not mc_bases or not skirmish then
53376: LD_EXP 80
53380: NOT
53381: PUSH
53382: LD_EXP 78
53386: NOT
53387: OR
53388: IFFALSE 53392
// exit ;
53390: GO 53582
// for i = 1 to mc_bases do
53392: LD_ADDR_VAR 0 4
53396: PUSH
53397: DOUBLE
53398: LD_INT 1
53400: DEC
53401: ST_TO_ADDR
53402: LD_EXP 80
53406: PUSH
53407: FOR_TO
53408: IFFALSE 53495
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
53410: LD_VAR 0 1
53414: PUSH
53415: LD_EXP 88
53419: PUSH
53420: LD_VAR 0 4
53424: ARRAY
53425: IN
53426: PUSH
53427: LD_VAR 0 1
53431: PUSH
53432: LD_EXP 89
53436: PUSH
53437: LD_VAR 0 4
53441: ARRAY
53442: IN
53443: NOT
53444: AND
53445: IFFALSE 53493
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
53447: LD_ADDR_EXP 89
53451: PUSH
53452: LD_EXP 89
53456: PPUSH
53457: LD_VAR 0 4
53461: PUSH
53462: LD_EXP 89
53466: PUSH
53467: LD_VAR 0 4
53471: ARRAY
53472: PUSH
53473: LD_INT 1
53475: PLUS
53476: PUSH
53477: EMPTY
53478: LIST
53479: LIST
53480: PPUSH
53481: LD_VAR 0 1
53485: PPUSH
53486: CALL 58774 0 3
53490: ST_TO_ADDR
// break ;
53491: GO 53495
// end ; end ;
53493: GO 53407
53495: POP
53496: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
53497: LD_VAR 0 1
53501: PPUSH
53502: CALL_OW 257
53506: PUSH
53507: LD_EXP 106
53511: IN
53512: PUSH
53513: LD_VAR 0 1
53517: PPUSH
53518: CALL_OW 266
53522: PUSH
53523: LD_INT 5
53525: EQUAL
53526: AND
53527: PUSH
53528: LD_VAR 0 2
53532: PPUSH
53533: CALL_OW 110
53537: PUSH
53538: LD_INT 18
53540: NONEQUAL
53541: AND
53542: IFFALSE 53582
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
53544: LD_VAR 0 2
53548: PPUSH
53549: CALL_OW 257
53553: PUSH
53554: LD_INT 5
53556: PUSH
53557: LD_INT 8
53559: PUSH
53560: LD_INT 9
53562: PUSH
53563: EMPTY
53564: LIST
53565: LIST
53566: LIST
53567: IN
53568: IFFALSE 53582
// SetClass ( unit , 1 ) ;
53570: LD_VAR 0 2
53574: PPUSH
53575: LD_INT 1
53577: PPUSH
53578: CALL_OW 336
// end ;
53582: LD_VAR 0 3
53586: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
53587: LD_INT 0
53589: PPUSH
53590: PPUSH
// if not mc_bases or not skirmish then
53591: LD_EXP 80
53595: NOT
53596: PUSH
53597: LD_EXP 78
53601: NOT
53602: OR
53603: IFFALSE 53607
// exit ;
53605: GO 53723
// if GetLives ( abandoned_vehicle ) > 250 then
53607: LD_VAR 0 2
53611: PPUSH
53612: CALL_OW 256
53616: PUSH
53617: LD_INT 250
53619: GREATER
53620: IFFALSE 53624
// exit ;
53622: GO 53723
// for i = 1 to mc_bases do
53624: LD_ADDR_VAR 0 6
53628: PUSH
53629: DOUBLE
53630: LD_INT 1
53632: DEC
53633: ST_TO_ADDR
53634: LD_EXP 80
53638: PUSH
53639: FOR_TO
53640: IFFALSE 53721
// begin if driver in mc_bases [ i ] then
53642: LD_VAR 0 1
53646: PUSH
53647: LD_EXP 80
53651: PUSH
53652: LD_VAR 0 6
53656: ARRAY
53657: IN
53658: IFFALSE 53719
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
53660: LD_VAR 0 1
53664: PPUSH
53665: LD_EXP 80
53669: PUSH
53670: LD_VAR 0 6
53674: ARRAY
53675: PPUSH
53676: LD_INT 2
53678: PUSH
53679: LD_INT 30
53681: PUSH
53682: LD_INT 0
53684: PUSH
53685: EMPTY
53686: LIST
53687: LIST
53688: PUSH
53689: LD_INT 30
53691: PUSH
53692: LD_INT 1
53694: PUSH
53695: EMPTY
53696: LIST
53697: LIST
53698: PUSH
53699: EMPTY
53700: LIST
53701: LIST
53702: LIST
53703: PPUSH
53704: CALL_OW 72
53708: PUSH
53709: LD_INT 1
53711: ARRAY
53712: PPUSH
53713: CALL 92400 0 2
// break ;
53717: GO 53721
// end ; end ;
53719: GO 53639
53721: POP
53722: POP
// end ; end_of_file
53723: LD_VAR 0 5
53727: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
53728: LD_INT 0
53730: PPUSH
53731: PPUSH
// if exist_mode then
53732: LD_VAR 0 2
53736: IFFALSE 53782
// begin unit := CreateCharacter ( prefix & ident ) ;
53738: LD_ADDR_VAR 0 5
53742: PUSH
53743: LD_VAR 0 3
53747: PUSH
53748: LD_VAR 0 1
53752: STR
53753: PPUSH
53754: CALL_OW 34
53758: ST_TO_ADDR
// if unit then
53759: LD_VAR 0 5
53763: IFFALSE 53780
// DeleteCharacters ( prefix & ident ) ;
53765: LD_VAR 0 3
53769: PUSH
53770: LD_VAR 0 1
53774: STR
53775: PPUSH
53776: CALL_OW 40
// end else
53780: GO 53797
// unit := NewCharacter ( ident ) ;
53782: LD_ADDR_VAR 0 5
53786: PUSH
53787: LD_VAR 0 1
53791: PPUSH
53792: CALL_OW 25
53796: ST_TO_ADDR
// result := unit ;
53797: LD_ADDR_VAR 0 4
53801: PUSH
53802: LD_VAR 0 5
53806: ST_TO_ADDR
// end ;
53807: LD_VAR 0 4
53811: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
53812: LD_INT 0
53814: PPUSH
53815: PPUSH
// if exist_mode then
53816: LD_VAR 0 2
53820: IFFALSE 53845
// unit := CreateCharacter ( prefix & ident ) else
53822: LD_ADDR_VAR 0 5
53826: PUSH
53827: LD_VAR 0 3
53831: PUSH
53832: LD_VAR 0 1
53836: STR
53837: PPUSH
53838: CALL_OW 34
53842: ST_TO_ADDR
53843: GO 53860
// unit := NewCharacter ( ident ) ;
53845: LD_ADDR_VAR 0 5
53849: PUSH
53850: LD_VAR 0 1
53854: PPUSH
53855: CALL_OW 25
53859: ST_TO_ADDR
// result := unit ;
53860: LD_ADDR_VAR 0 4
53864: PUSH
53865: LD_VAR 0 5
53869: ST_TO_ADDR
// end ;
53870: LD_VAR 0 4
53874: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
53875: LD_INT 0
53877: PPUSH
53878: PPUSH
// if not side or not nation then
53879: LD_VAR 0 1
53883: NOT
53884: PUSH
53885: LD_VAR 0 2
53889: NOT
53890: OR
53891: IFFALSE 53895
// exit ;
53893: GO 54663
// case nation of nation_american :
53895: LD_VAR 0 2
53899: PUSH
53900: LD_INT 1
53902: DOUBLE
53903: EQUAL
53904: IFTRUE 53908
53906: GO 54122
53908: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
53909: LD_ADDR_VAR 0 4
53913: PUSH
53914: LD_INT 35
53916: PUSH
53917: LD_INT 45
53919: PUSH
53920: LD_INT 46
53922: PUSH
53923: LD_INT 47
53925: PUSH
53926: LD_INT 82
53928: PUSH
53929: LD_INT 83
53931: PUSH
53932: LD_INT 84
53934: PUSH
53935: LD_INT 85
53937: PUSH
53938: LD_INT 86
53940: PUSH
53941: LD_INT 1
53943: PUSH
53944: LD_INT 2
53946: PUSH
53947: LD_INT 6
53949: PUSH
53950: LD_INT 15
53952: PUSH
53953: LD_INT 16
53955: PUSH
53956: LD_INT 7
53958: PUSH
53959: LD_INT 12
53961: PUSH
53962: LD_INT 13
53964: PUSH
53965: LD_INT 10
53967: PUSH
53968: LD_INT 14
53970: PUSH
53971: LD_INT 20
53973: PUSH
53974: LD_INT 21
53976: PUSH
53977: LD_INT 22
53979: PUSH
53980: LD_INT 25
53982: PUSH
53983: LD_INT 32
53985: PUSH
53986: LD_INT 27
53988: PUSH
53989: LD_INT 36
53991: PUSH
53992: LD_INT 69
53994: PUSH
53995: LD_INT 39
53997: PUSH
53998: LD_INT 34
54000: PUSH
54001: LD_INT 40
54003: PUSH
54004: LD_INT 48
54006: PUSH
54007: LD_INT 49
54009: PUSH
54010: LD_INT 50
54012: PUSH
54013: LD_INT 51
54015: PUSH
54016: LD_INT 52
54018: PUSH
54019: LD_INT 53
54021: PUSH
54022: LD_INT 54
54024: PUSH
54025: LD_INT 55
54027: PUSH
54028: LD_INT 56
54030: PUSH
54031: LD_INT 57
54033: PUSH
54034: LD_INT 58
54036: PUSH
54037: LD_INT 59
54039: PUSH
54040: LD_INT 60
54042: PUSH
54043: LD_INT 61
54045: PUSH
54046: LD_INT 62
54048: PUSH
54049: LD_INT 80
54051: PUSH
54052: LD_INT 82
54054: PUSH
54055: LD_INT 83
54057: PUSH
54058: LD_INT 84
54060: PUSH
54061: LD_INT 85
54063: PUSH
54064: LD_INT 86
54066: PUSH
54067: EMPTY
54068: LIST
54069: LIST
54070: LIST
54071: LIST
54072: LIST
54073: LIST
54074: LIST
54075: LIST
54076: LIST
54077: LIST
54078: LIST
54079: LIST
54080: LIST
54081: LIST
54082: LIST
54083: LIST
54084: LIST
54085: LIST
54086: LIST
54087: LIST
54088: LIST
54089: LIST
54090: LIST
54091: LIST
54092: LIST
54093: LIST
54094: LIST
54095: LIST
54096: LIST
54097: LIST
54098: LIST
54099: LIST
54100: LIST
54101: LIST
54102: LIST
54103: LIST
54104: LIST
54105: LIST
54106: LIST
54107: LIST
54108: LIST
54109: LIST
54110: LIST
54111: LIST
54112: LIST
54113: LIST
54114: LIST
54115: LIST
54116: LIST
54117: LIST
54118: LIST
54119: ST_TO_ADDR
54120: GO 54587
54122: LD_INT 2
54124: DOUBLE
54125: EQUAL
54126: IFTRUE 54130
54128: GO 54356
54130: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
54131: LD_ADDR_VAR 0 4
54135: PUSH
54136: LD_INT 35
54138: PUSH
54139: LD_INT 45
54141: PUSH
54142: LD_INT 46
54144: PUSH
54145: LD_INT 47
54147: PUSH
54148: LD_INT 82
54150: PUSH
54151: LD_INT 83
54153: PUSH
54154: LD_INT 84
54156: PUSH
54157: LD_INT 85
54159: PUSH
54160: LD_INT 87
54162: PUSH
54163: LD_INT 70
54165: PUSH
54166: LD_INT 1
54168: PUSH
54169: LD_INT 11
54171: PUSH
54172: LD_INT 3
54174: PUSH
54175: LD_INT 4
54177: PUSH
54178: LD_INT 5
54180: PUSH
54181: LD_INT 6
54183: PUSH
54184: LD_INT 15
54186: PUSH
54187: LD_INT 18
54189: PUSH
54190: LD_INT 7
54192: PUSH
54193: LD_INT 17
54195: PUSH
54196: LD_INT 8
54198: PUSH
54199: LD_INT 20
54201: PUSH
54202: LD_INT 21
54204: PUSH
54205: LD_INT 22
54207: PUSH
54208: LD_INT 72
54210: PUSH
54211: LD_INT 26
54213: PUSH
54214: LD_INT 69
54216: PUSH
54217: LD_INT 39
54219: PUSH
54220: LD_INT 40
54222: PUSH
54223: LD_INT 41
54225: PUSH
54226: LD_INT 42
54228: PUSH
54229: LD_INT 43
54231: PUSH
54232: LD_INT 48
54234: PUSH
54235: LD_INT 49
54237: PUSH
54238: LD_INT 50
54240: PUSH
54241: LD_INT 51
54243: PUSH
54244: LD_INT 52
54246: PUSH
54247: LD_INT 53
54249: PUSH
54250: LD_INT 54
54252: PUSH
54253: LD_INT 55
54255: PUSH
54256: LD_INT 56
54258: PUSH
54259: LD_INT 60
54261: PUSH
54262: LD_INT 61
54264: PUSH
54265: LD_INT 62
54267: PUSH
54268: LD_INT 66
54270: PUSH
54271: LD_INT 67
54273: PUSH
54274: LD_INT 68
54276: PUSH
54277: LD_INT 81
54279: PUSH
54280: LD_INT 82
54282: PUSH
54283: LD_INT 83
54285: PUSH
54286: LD_INT 84
54288: PUSH
54289: LD_INT 85
54291: PUSH
54292: LD_INT 87
54294: PUSH
54295: LD_INT 88
54297: PUSH
54298: EMPTY
54299: LIST
54300: LIST
54301: LIST
54302: LIST
54303: LIST
54304: LIST
54305: LIST
54306: LIST
54307: LIST
54308: LIST
54309: LIST
54310: LIST
54311: LIST
54312: LIST
54313: LIST
54314: LIST
54315: LIST
54316: LIST
54317: LIST
54318: LIST
54319: LIST
54320: LIST
54321: LIST
54322: LIST
54323: LIST
54324: LIST
54325: LIST
54326: LIST
54327: LIST
54328: LIST
54329: LIST
54330: LIST
54331: LIST
54332: LIST
54333: LIST
54334: LIST
54335: LIST
54336: LIST
54337: LIST
54338: LIST
54339: LIST
54340: LIST
54341: LIST
54342: LIST
54343: LIST
54344: LIST
54345: LIST
54346: LIST
54347: LIST
54348: LIST
54349: LIST
54350: LIST
54351: LIST
54352: LIST
54353: ST_TO_ADDR
54354: GO 54587
54356: LD_INT 3
54358: DOUBLE
54359: EQUAL
54360: IFTRUE 54364
54362: GO 54586
54364: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
54365: LD_ADDR_VAR 0 4
54369: PUSH
54370: LD_INT 46
54372: PUSH
54373: LD_INT 47
54375: PUSH
54376: LD_INT 1
54378: PUSH
54379: LD_INT 2
54381: PUSH
54382: LD_INT 82
54384: PUSH
54385: LD_INT 83
54387: PUSH
54388: LD_INT 84
54390: PUSH
54391: LD_INT 85
54393: PUSH
54394: LD_INT 86
54396: PUSH
54397: LD_INT 11
54399: PUSH
54400: LD_INT 9
54402: PUSH
54403: LD_INT 20
54405: PUSH
54406: LD_INT 19
54408: PUSH
54409: LD_INT 21
54411: PUSH
54412: LD_INT 24
54414: PUSH
54415: LD_INT 22
54417: PUSH
54418: LD_INT 25
54420: PUSH
54421: LD_INT 28
54423: PUSH
54424: LD_INT 29
54426: PUSH
54427: LD_INT 30
54429: PUSH
54430: LD_INT 31
54432: PUSH
54433: LD_INT 37
54435: PUSH
54436: LD_INT 38
54438: PUSH
54439: LD_INT 32
54441: PUSH
54442: LD_INT 27
54444: PUSH
54445: LD_INT 33
54447: PUSH
54448: LD_INT 69
54450: PUSH
54451: LD_INT 39
54453: PUSH
54454: LD_INT 34
54456: PUSH
54457: LD_INT 40
54459: PUSH
54460: LD_INT 71
54462: PUSH
54463: LD_INT 23
54465: PUSH
54466: LD_INT 44
54468: PUSH
54469: LD_INT 48
54471: PUSH
54472: LD_INT 49
54474: PUSH
54475: LD_INT 50
54477: PUSH
54478: LD_INT 51
54480: PUSH
54481: LD_INT 52
54483: PUSH
54484: LD_INT 53
54486: PUSH
54487: LD_INT 54
54489: PUSH
54490: LD_INT 55
54492: PUSH
54493: LD_INT 56
54495: PUSH
54496: LD_INT 57
54498: PUSH
54499: LD_INT 58
54501: PUSH
54502: LD_INT 59
54504: PUSH
54505: LD_INT 63
54507: PUSH
54508: LD_INT 64
54510: PUSH
54511: LD_INT 65
54513: PUSH
54514: LD_INT 82
54516: PUSH
54517: LD_INT 83
54519: PUSH
54520: LD_INT 84
54522: PUSH
54523: LD_INT 85
54525: PUSH
54526: LD_INT 86
54528: PUSH
54529: EMPTY
54530: LIST
54531: LIST
54532: LIST
54533: LIST
54534: LIST
54535: LIST
54536: LIST
54537: LIST
54538: LIST
54539: LIST
54540: LIST
54541: LIST
54542: LIST
54543: LIST
54544: LIST
54545: LIST
54546: LIST
54547: LIST
54548: LIST
54549: LIST
54550: LIST
54551: LIST
54552: LIST
54553: LIST
54554: LIST
54555: LIST
54556: LIST
54557: LIST
54558: LIST
54559: LIST
54560: LIST
54561: LIST
54562: LIST
54563: LIST
54564: LIST
54565: LIST
54566: LIST
54567: LIST
54568: LIST
54569: LIST
54570: LIST
54571: LIST
54572: LIST
54573: LIST
54574: LIST
54575: LIST
54576: LIST
54577: LIST
54578: LIST
54579: LIST
54580: LIST
54581: LIST
54582: LIST
54583: ST_TO_ADDR
54584: GO 54587
54586: POP
// if state > - 1 and state < 3 then
54587: LD_VAR 0 3
54591: PUSH
54592: LD_INT 1
54594: NEG
54595: GREATER
54596: PUSH
54597: LD_VAR 0 3
54601: PUSH
54602: LD_INT 3
54604: LESS
54605: AND
54606: IFFALSE 54663
// for i in result do
54608: LD_ADDR_VAR 0 5
54612: PUSH
54613: LD_VAR 0 4
54617: PUSH
54618: FOR_IN
54619: IFFALSE 54661
// if GetTech ( i , side ) <> state then
54621: LD_VAR 0 5
54625: PPUSH
54626: LD_VAR 0 1
54630: PPUSH
54631: CALL_OW 321
54635: PUSH
54636: LD_VAR 0 3
54640: NONEQUAL
54641: IFFALSE 54659
// result := result diff i ;
54643: LD_ADDR_VAR 0 4
54647: PUSH
54648: LD_VAR 0 4
54652: PUSH
54653: LD_VAR 0 5
54657: DIFF
54658: ST_TO_ADDR
54659: GO 54618
54661: POP
54662: POP
// end ;
54663: LD_VAR 0 4
54667: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
54668: LD_INT 0
54670: PPUSH
54671: PPUSH
54672: PPUSH
// result := true ;
54673: LD_ADDR_VAR 0 3
54677: PUSH
54678: LD_INT 1
54680: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
54681: LD_ADDR_VAR 0 5
54685: PUSH
54686: LD_VAR 0 2
54690: PPUSH
54691: CALL_OW 480
54695: ST_TO_ADDR
// if not tmp then
54696: LD_VAR 0 5
54700: NOT
54701: IFFALSE 54705
// exit ;
54703: GO 54754
// for i in tmp do
54705: LD_ADDR_VAR 0 4
54709: PUSH
54710: LD_VAR 0 5
54714: PUSH
54715: FOR_IN
54716: IFFALSE 54752
// if GetTech ( i , side ) <> state_researched then
54718: LD_VAR 0 4
54722: PPUSH
54723: LD_VAR 0 1
54727: PPUSH
54728: CALL_OW 321
54732: PUSH
54733: LD_INT 2
54735: NONEQUAL
54736: IFFALSE 54750
// begin result := false ;
54738: LD_ADDR_VAR 0 3
54742: PUSH
54743: LD_INT 0
54745: ST_TO_ADDR
// exit ;
54746: POP
54747: POP
54748: GO 54754
// end ;
54750: GO 54715
54752: POP
54753: POP
// end ;
54754: LD_VAR 0 3
54758: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
54759: LD_INT 0
54761: PPUSH
54762: PPUSH
54763: PPUSH
54764: PPUSH
54765: PPUSH
54766: PPUSH
54767: PPUSH
54768: PPUSH
54769: PPUSH
54770: PPUSH
54771: PPUSH
54772: PPUSH
54773: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
54774: LD_VAR 0 1
54778: NOT
54779: PUSH
54780: LD_VAR 0 1
54784: PPUSH
54785: CALL_OW 257
54789: PUSH
54790: LD_INT 9
54792: NONEQUAL
54793: OR
54794: IFFALSE 54798
// exit ;
54796: GO 55371
// side := GetSide ( unit ) ;
54798: LD_ADDR_VAR 0 9
54802: PUSH
54803: LD_VAR 0 1
54807: PPUSH
54808: CALL_OW 255
54812: ST_TO_ADDR
// tech_space := tech_spacanom ;
54813: LD_ADDR_VAR 0 12
54817: PUSH
54818: LD_INT 29
54820: ST_TO_ADDR
// tech_time := tech_taurad ;
54821: LD_ADDR_VAR 0 13
54825: PUSH
54826: LD_INT 28
54828: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
54829: LD_ADDR_VAR 0 11
54833: PUSH
54834: LD_VAR 0 1
54838: PPUSH
54839: CALL_OW 310
54843: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
54844: LD_VAR 0 11
54848: PPUSH
54849: CALL_OW 247
54853: PUSH
54854: LD_INT 2
54856: EQUAL
54857: IFFALSE 54861
// exit ;
54859: GO 55371
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54861: LD_ADDR_VAR 0 8
54865: PUSH
54866: LD_INT 81
54868: PUSH
54869: LD_VAR 0 9
54873: PUSH
54874: EMPTY
54875: LIST
54876: LIST
54877: PUSH
54878: LD_INT 3
54880: PUSH
54881: LD_INT 21
54883: PUSH
54884: LD_INT 3
54886: PUSH
54887: EMPTY
54888: LIST
54889: LIST
54890: PUSH
54891: EMPTY
54892: LIST
54893: LIST
54894: PUSH
54895: EMPTY
54896: LIST
54897: LIST
54898: PPUSH
54899: CALL_OW 69
54903: ST_TO_ADDR
// if not tmp then
54904: LD_VAR 0 8
54908: NOT
54909: IFFALSE 54913
// exit ;
54911: GO 55371
// if in_unit then
54913: LD_VAR 0 11
54917: IFFALSE 54941
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
54919: LD_ADDR_VAR 0 10
54923: PUSH
54924: LD_VAR 0 8
54928: PPUSH
54929: LD_VAR 0 11
54933: PPUSH
54934: CALL_OW 74
54938: ST_TO_ADDR
54939: GO 54961
// enemy := NearestUnitToUnit ( tmp , unit ) ;
54941: LD_ADDR_VAR 0 10
54945: PUSH
54946: LD_VAR 0 8
54950: PPUSH
54951: LD_VAR 0 1
54955: PPUSH
54956: CALL_OW 74
54960: ST_TO_ADDR
// if not enemy then
54961: LD_VAR 0 10
54965: NOT
54966: IFFALSE 54970
// exit ;
54968: GO 55371
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
54970: LD_VAR 0 11
54974: PUSH
54975: LD_VAR 0 11
54979: PPUSH
54980: LD_VAR 0 10
54984: PPUSH
54985: CALL_OW 296
54989: PUSH
54990: LD_INT 13
54992: GREATER
54993: AND
54994: PUSH
54995: LD_VAR 0 1
54999: PPUSH
55000: LD_VAR 0 10
55004: PPUSH
55005: CALL_OW 296
55009: PUSH
55010: LD_INT 12
55012: GREATER
55013: OR
55014: IFFALSE 55018
// exit ;
55016: GO 55371
// missile := [ 1 ] ;
55018: LD_ADDR_VAR 0 14
55022: PUSH
55023: LD_INT 1
55025: PUSH
55026: EMPTY
55027: LIST
55028: ST_TO_ADDR
// if Researched ( side , tech_space ) then
55029: LD_VAR 0 9
55033: PPUSH
55034: LD_VAR 0 12
55038: PPUSH
55039: CALL_OW 325
55043: IFFALSE 55072
// missile := Replace ( missile , missile + 1 , 2 ) ;
55045: LD_ADDR_VAR 0 14
55049: PUSH
55050: LD_VAR 0 14
55054: PPUSH
55055: LD_VAR 0 14
55059: PUSH
55060: LD_INT 1
55062: PLUS
55063: PPUSH
55064: LD_INT 2
55066: PPUSH
55067: CALL_OW 1
55071: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
55072: LD_VAR 0 9
55076: PPUSH
55077: LD_VAR 0 13
55081: PPUSH
55082: CALL_OW 325
55086: PUSH
55087: LD_VAR 0 10
55091: PPUSH
55092: CALL_OW 255
55096: PPUSH
55097: LD_VAR 0 13
55101: PPUSH
55102: CALL_OW 325
55106: NOT
55107: AND
55108: IFFALSE 55137
// missile := Replace ( missile , missile + 1 , 3 ) ;
55110: LD_ADDR_VAR 0 14
55114: PUSH
55115: LD_VAR 0 14
55119: PPUSH
55120: LD_VAR 0 14
55124: PUSH
55125: LD_INT 1
55127: PLUS
55128: PPUSH
55129: LD_INT 3
55131: PPUSH
55132: CALL_OW 1
55136: ST_TO_ADDR
// if missile < 2 then
55137: LD_VAR 0 14
55141: PUSH
55142: LD_INT 2
55144: LESS
55145: IFFALSE 55149
// exit ;
55147: GO 55371
// x := GetX ( enemy ) ;
55149: LD_ADDR_VAR 0 4
55153: PUSH
55154: LD_VAR 0 10
55158: PPUSH
55159: CALL_OW 250
55163: ST_TO_ADDR
// y := GetY ( enemy ) ;
55164: LD_ADDR_VAR 0 5
55168: PUSH
55169: LD_VAR 0 10
55173: PPUSH
55174: CALL_OW 251
55178: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
55179: LD_ADDR_VAR 0 6
55183: PUSH
55184: LD_VAR 0 4
55188: PUSH
55189: LD_INT 1
55191: NEG
55192: PPUSH
55193: LD_INT 1
55195: PPUSH
55196: CALL_OW 12
55200: PLUS
55201: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
55202: LD_ADDR_VAR 0 7
55206: PUSH
55207: LD_VAR 0 5
55211: PUSH
55212: LD_INT 1
55214: NEG
55215: PPUSH
55216: LD_INT 1
55218: PPUSH
55219: CALL_OW 12
55223: PLUS
55224: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55225: LD_VAR 0 6
55229: PPUSH
55230: LD_VAR 0 7
55234: PPUSH
55235: CALL_OW 488
55239: NOT
55240: IFFALSE 55262
// begin _x := x ;
55242: LD_ADDR_VAR 0 6
55246: PUSH
55247: LD_VAR 0 4
55251: ST_TO_ADDR
// _y := y ;
55252: LD_ADDR_VAR 0 7
55256: PUSH
55257: LD_VAR 0 5
55261: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
55262: LD_ADDR_VAR 0 3
55266: PUSH
55267: LD_INT 1
55269: PPUSH
55270: LD_VAR 0 14
55274: PPUSH
55275: CALL_OW 12
55279: ST_TO_ADDR
// case i of 1 :
55280: LD_VAR 0 3
55284: PUSH
55285: LD_INT 1
55287: DOUBLE
55288: EQUAL
55289: IFTRUE 55293
55291: GO 55310
55293: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
55294: LD_VAR 0 1
55298: PPUSH
55299: LD_VAR 0 10
55303: PPUSH
55304: CALL_OW 115
55308: GO 55371
55310: LD_INT 2
55312: DOUBLE
55313: EQUAL
55314: IFTRUE 55318
55316: GO 55340
55318: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
55319: LD_VAR 0 1
55323: PPUSH
55324: LD_VAR 0 6
55328: PPUSH
55329: LD_VAR 0 7
55333: PPUSH
55334: CALL_OW 153
55338: GO 55371
55340: LD_INT 3
55342: DOUBLE
55343: EQUAL
55344: IFTRUE 55348
55346: GO 55370
55348: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
55349: LD_VAR 0 1
55353: PPUSH
55354: LD_VAR 0 6
55358: PPUSH
55359: LD_VAR 0 7
55363: PPUSH
55364: CALL_OW 154
55368: GO 55371
55370: POP
// end ;
55371: LD_VAR 0 2
55375: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
55376: LD_INT 0
55378: PPUSH
55379: PPUSH
55380: PPUSH
55381: PPUSH
55382: PPUSH
55383: PPUSH
// if not unit or not building then
55384: LD_VAR 0 1
55388: NOT
55389: PUSH
55390: LD_VAR 0 2
55394: NOT
55395: OR
55396: IFFALSE 55400
// exit ;
55398: GO 55558
// x := GetX ( building ) ;
55400: LD_ADDR_VAR 0 5
55404: PUSH
55405: LD_VAR 0 2
55409: PPUSH
55410: CALL_OW 250
55414: ST_TO_ADDR
// y := GetY ( building ) ;
55415: LD_ADDR_VAR 0 6
55419: PUSH
55420: LD_VAR 0 2
55424: PPUSH
55425: CALL_OW 251
55429: ST_TO_ADDR
// for i = 0 to 5 do
55430: LD_ADDR_VAR 0 4
55434: PUSH
55435: DOUBLE
55436: LD_INT 0
55438: DEC
55439: ST_TO_ADDR
55440: LD_INT 5
55442: PUSH
55443: FOR_TO
55444: IFFALSE 55556
// begin _x := ShiftX ( x , i , 3 ) ;
55446: LD_ADDR_VAR 0 7
55450: PUSH
55451: LD_VAR 0 5
55455: PPUSH
55456: LD_VAR 0 4
55460: PPUSH
55461: LD_INT 3
55463: PPUSH
55464: CALL_OW 272
55468: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
55469: LD_ADDR_VAR 0 8
55473: PUSH
55474: LD_VAR 0 6
55478: PPUSH
55479: LD_VAR 0 4
55483: PPUSH
55484: LD_INT 3
55486: PPUSH
55487: CALL_OW 273
55491: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55492: LD_VAR 0 7
55496: PPUSH
55497: LD_VAR 0 8
55501: PPUSH
55502: CALL_OW 488
55506: NOT
55507: IFFALSE 55511
// continue ;
55509: GO 55443
// if HexInfo ( _x , _y ) = 0 then
55511: LD_VAR 0 7
55515: PPUSH
55516: LD_VAR 0 8
55520: PPUSH
55521: CALL_OW 428
55525: PUSH
55526: LD_INT 0
55528: EQUAL
55529: IFFALSE 55554
// begin ComMoveXY ( unit , _x , _y ) ;
55531: LD_VAR 0 1
55535: PPUSH
55536: LD_VAR 0 7
55540: PPUSH
55541: LD_VAR 0 8
55545: PPUSH
55546: CALL_OW 111
// exit ;
55550: POP
55551: POP
55552: GO 55558
// end ; end ;
55554: GO 55443
55556: POP
55557: POP
// end ;
55558: LD_VAR 0 3
55562: RET
// export function ScanBase ( side , base_area ) ; begin
55563: LD_INT 0
55565: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
55566: LD_ADDR_VAR 0 3
55570: PUSH
55571: LD_VAR 0 2
55575: PPUSH
55576: LD_INT 81
55578: PUSH
55579: LD_VAR 0 1
55583: PUSH
55584: EMPTY
55585: LIST
55586: LIST
55587: PPUSH
55588: CALL_OW 70
55592: ST_TO_ADDR
// end ;
55593: LD_VAR 0 3
55597: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
55598: LD_INT 0
55600: PPUSH
55601: PPUSH
55602: PPUSH
55603: PPUSH
// result := false ;
55604: LD_ADDR_VAR 0 2
55608: PUSH
55609: LD_INT 0
55611: ST_TO_ADDR
// side := GetSide ( unit ) ;
55612: LD_ADDR_VAR 0 3
55616: PUSH
55617: LD_VAR 0 1
55621: PPUSH
55622: CALL_OW 255
55626: ST_TO_ADDR
// nat := GetNation ( unit ) ;
55627: LD_ADDR_VAR 0 4
55631: PUSH
55632: LD_VAR 0 1
55636: PPUSH
55637: CALL_OW 248
55641: ST_TO_ADDR
// case nat of 1 :
55642: LD_VAR 0 4
55646: PUSH
55647: LD_INT 1
55649: DOUBLE
55650: EQUAL
55651: IFTRUE 55655
55653: GO 55666
55655: POP
// tech := tech_lassight ; 2 :
55656: LD_ADDR_VAR 0 5
55660: PUSH
55661: LD_INT 12
55663: ST_TO_ADDR
55664: GO 55705
55666: LD_INT 2
55668: DOUBLE
55669: EQUAL
55670: IFTRUE 55674
55672: GO 55685
55674: POP
// tech := tech_mortar ; 3 :
55675: LD_ADDR_VAR 0 5
55679: PUSH
55680: LD_INT 41
55682: ST_TO_ADDR
55683: GO 55705
55685: LD_INT 3
55687: DOUBLE
55688: EQUAL
55689: IFTRUE 55693
55691: GO 55704
55693: POP
// tech := tech_bazooka ; end ;
55694: LD_ADDR_VAR 0 5
55698: PUSH
55699: LD_INT 44
55701: ST_TO_ADDR
55702: GO 55705
55704: POP
// if Researched ( side , tech ) then
55705: LD_VAR 0 3
55709: PPUSH
55710: LD_VAR 0 5
55714: PPUSH
55715: CALL_OW 325
55719: IFFALSE 55746
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
55721: LD_ADDR_VAR 0 2
55725: PUSH
55726: LD_INT 5
55728: PUSH
55729: LD_INT 8
55731: PUSH
55732: LD_INT 9
55734: PUSH
55735: EMPTY
55736: LIST
55737: LIST
55738: LIST
55739: PUSH
55740: LD_VAR 0 4
55744: ARRAY
55745: ST_TO_ADDR
// end ;
55746: LD_VAR 0 2
55750: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
55751: LD_INT 0
55753: PPUSH
55754: PPUSH
55755: PPUSH
// if not mines then
55756: LD_VAR 0 2
55760: NOT
55761: IFFALSE 55765
// exit ;
55763: GO 55909
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55765: LD_ADDR_VAR 0 5
55769: PUSH
55770: LD_INT 81
55772: PUSH
55773: LD_VAR 0 1
55777: PUSH
55778: EMPTY
55779: LIST
55780: LIST
55781: PUSH
55782: LD_INT 3
55784: PUSH
55785: LD_INT 21
55787: PUSH
55788: LD_INT 3
55790: PUSH
55791: EMPTY
55792: LIST
55793: LIST
55794: PUSH
55795: EMPTY
55796: LIST
55797: LIST
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: PPUSH
55803: CALL_OW 69
55807: ST_TO_ADDR
// for i in mines do
55808: LD_ADDR_VAR 0 4
55812: PUSH
55813: LD_VAR 0 2
55817: PUSH
55818: FOR_IN
55819: IFFALSE 55907
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
55821: LD_VAR 0 4
55825: PUSH
55826: LD_INT 1
55828: ARRAY
55829: PPUSH
55830: LD_VAR 0 4
55834: PUSH
55835: LD_INT 2
55837: ARRAY
55838: PPUSH
55839: CALL_OW 458
55843: NOT
55844: IFFALSE 55848
// continue ;
55846: GO 55818
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
55848: LD_VAR 0 4
55852: PUSH
55853: LD_INT 1
55855: ARRAY
55856: PPUSH
55857: LD_VAR 0 4
55861: PUSH
55862: LD_INT 2
55864: ARRAY
55865: PPUSH
55866: CALL_OW 428
55870: PUSH
55871: LD_VAR 0 5
55875: IN
55876: IFFALSE 55905
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
55878: LD_VAR 0 4
55882: PUSH
55883: LD_INT 1
55885: ARRAY
55886: PPUSH
55887: LD_VAR 0 4
55891: PUSH
55892: LD_INT 2
55894: ARRAY
55895: PPUSH
55896: LD_VAR 0 1
55900: PPUSH
55901: CALL_OW 456
// end ;
55905: GO 55818
55907: POP
55908: POP
// end ;
55909: LD_VAR 0 3
55913: RET
// export function Count ( array ) ; begin
55914: LD_INT 0
55916: PPUSH
// result := array + 0 ;
55917: LD_ADDR_VAR 0 2
55921: PUSH
55922: LD_VAR 0 1
55926: PUSH
55927: LD_INT 0
55929: PLUS
55930: ST_TO_ADDR
// end ;
55931: LD_VAR 0 2
55935: RET
// export function IsEmpty ( building ) ; begin
55936: LD_INT 0
55938: PPUSH
// if not building then
55939: LD_VAR 0 1
55943: NOT
55944: IFFALSE 55948
// exit ;
55946: GO 55991
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
55948: LD_ADDR_VAR 0 2
55952: PUSH
55953: LD_VAR 0 1
55957: PUSH
55958: LD_INT 22
55960: PUSH
55961: LD_VAR 0 1
55965: PPUSH
55966: CALL_OW 255
55970: PUSH
55971: EMPTY
55972: LIST
55973: LIST
55974: PUSH
55975: LD_INT 58
55977: PUSH
55978: EMPTY
55979: LIST
55980: PUSH
55981: EMPTY
55982: LIST
55983: LIST
55984: PPUSH
55985: CALL_OW 69
55989: IN
55990: ST_TO_ADDR
// end ;
55991: LD_VAR 0 2
55995: RET
// export function IsNotFull ( building ) ; var places ; begin
55996: LD_INT 0
55998: PPUSH
55999: PPUSH
// if not building then
56000: LD_VAR 0 1
56004: NOT
56005: IFFALSE 56009
// exit ;
56007: GO 56037
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
56009: LD_ADDR_VAR 0 2
56013: PUSH
56014: LD_VAR 0 1
56018: PPUSH
56019: LD_INT 3
56021: PUSH
56022: LD_INT 62
56024: PUSH
56025: EMPTY
56026: LIST
56027: PUSH
56028: EMPTY
56029: LIST
56030: LIST
56031: PPUSH
56032: CALL_OW 72
56036: ST_TO_ADDR
// end ;
56037: LD_VAR 0 2
56041: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
56042: LD_INT 0
56044: PPUSH
56045: PPUSH
56046: PPUSH
56047: PPUSH
// tmp := [ ] ;
56048: LD_ADDR_VAR 0 3
56052: PUSH
56053: EMPTY
56054: ST_TO_ADDR
// list := [ ] ;
56055: LD_ADDR_VAR 0 5
56059: PUSH
56060: EMPTY
56061: ST_TO_ADDR
// for i = 16 to 25 do
56062: LD_ADDR_VAR 0 4
56066: PUSH
56067: DOUBLE
56068: LD_INT 16
56070: DEC
56071: ST_TO_ADDR
56072: LD_INT 25
56074: PUSH
56075: FOR_TO
56076: IFFALSE 56149
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
56078: LD_ADDR_VAR 0 3
56082: PUSH
56083: LD_VAR 0 3
56087: PUSH
56088: LD_INT 22
56090: PUSH
56091: LD_VAR 0 1
56095: PPUSH
56096: CALL_OW 255
56100: PUSH
56101: EMPTY
56102: LIST
56103: LIST
56104: PUSH
56105: LD_INT 91
56107: PUSH
56108: LD_VAR 0 1
56112: PUSH
56113: LD_INT 6
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: LIST
56120: PUSH
56121: LD_INT 30
56123: PUSH
56124: LD_VAR 0 4
56128: PUSH
56129: EMPTY
56130: LIST
56131: LIST
56132: PUSH
56133: EMPTY
56134: LIST
56135: LIST
56136: LIST
56137: PUSH
56138: EMPTY
56139: LIST
56140: PPUSH
56141: CALL_OW 69
56145: ADD
56146: ST_TO_ADDR
56147: GO 56075
56149: POP
56150: POP
// for i = 1 to tmp do
56151: LD_ADDR_VAR 0 4
56155: PUSH
56156: DOUBLE
56157: LD_INT 1
56159: DEC
56160: ST_TO_ADDR
56161: LD_VAR 0 3
56165: PUSH
56166: FOR_TO
56167: IFFALSE 56255
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
56169: LD_ADDR_VAR 0 5
56173: PUSH
56174: LD_VAR 0 5
56178: PUSH
56179: LD_VAR 0 3
56183: PUSH
56184: LD_VAR 0 4
56188: ARRAY
56189: PPUSH
56190: CALL_OW 266
56194: PUSH
56195: LD_VAR 0 3
56199: PUSH
56200: LD_VAR 0 4
56204: ARRAY
56205: PPUSH
56206: CALL_OW 250
56210: PUSH
56211: LD_VAR 0 3
56215: PUSH
56216: LD_VAR 0 4
56220: ARRAY
56221: PPUSH
56222: CALL_OW 251
56226: PUSH
56227: LD_VAR 0 3
56231: PUSH
56232: LD_VAR 0 4
56236: ARRAY
56237: PPUSH
56238: CALL_OW 254
56242: PUSH
56243: EMPTY
56244: LIST
56245: LIST
56246: LIST
56247: LIST
56248: PUSH
56249: EMPTY
56250: LIST
56251: ADD
56252: ST_TO_ADDR
56253: GO 56166
56255: POP
56256: POP
// result := list ;
56257: LD_ADDR_VAR 0 2
56261: PUSH
56262: LD_VAR 0 5
56266: ST_TO_ADDR
// end ;
56267: LD_VAR 0 2
56271: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
56272: LD_INT 0
56274: PPUSH
56275: PPUSH
56276: PPUSH
56277: PPUSH
56278: PPUSH
56279: PPUSH
56280: PPUSH
// if not factory then
56281: LD_VAR 0 1
56285: NOT
56286: IFFALSE 56290
// exit ;
56288: GO 56883
// if control = control_apeman then
56290: LD_VAR 0 4
56294: PUSH
56295: LD_INT 5
56297: EQUAL
56298: IFFALSE 56407
// begin tmp := UnitsInside ( factory ) ;
56300: LD_ADDR_VAR 0 8
56304: PUSH
56305: LD_VAR 0 1
56309: PPUSH
56310: CALL_OW 313
56314: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
56315: LD_VAR 0 8
56319: PPUSH
56320: LD_INT 25
56322: PUSH
56323: LD_INT 12
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: PPUSH
56330: CALL_OW 72
56334: NOT
56335: IFFALSE 56345
// control := control_manual ;
56337: LD_ADDR_VAR 0 4
56341: PUSH
56342: LD_INT 1
56344: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
56345: LD_ADDR_VAR 0 8
56349: PUSH
56350: LD_VAR 0 1
56354: PPUSH
56355: CALL 56042 0 1
56359: ST_TO_ADDR
// if tmp then
56360: LD_VAR 0 8
56364: IFFALSE 56407
// begin for i in tmp do
56366: LD_ADDR_VAR 0 7
56370: PUSH
56371: LD_VAR 0 8
56375: PUSH
56376: FOR_IN
56377: IFFALSE 56405
// if i [ 1 ] = b_ext_radio then
56379: LD_VAR 0 7
56383: PUSH
56384: LD_INT 1
56386: ARRAY
56387: PUSH
56388: LD_INT 22
56390: EQUAL
56391: IFFALSE 56403
// begin control := control_remote ;
56393: LD_ADDR_VAR 0 4
56397: PUSH
56398: LD_INT 2
56400: ST_TO_ADDR
// break ;
56401: GO 56405
// end ;
56403: GO 56376
56405: POP
56406: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
56407: LD_VAR 0 1
56411: PPUSH
56412: LD_VAR 0 2
56416: PPUSH
56417: LD_VAR 0 3
56421: PPUSH
56422: LD_VAR 0 4
56426: PPUSH
56427: LD_VAR 0 5
56431: PPUSH
56432: CALL_OW 448
56436: IFFALSE 56471
// begin result := [ chassis , engine , control , weapon ] ;
56438: LD_ADDR_VAR 0 6
56442: PUSH
56443: LD_VAR 0 2
56447: PUSH
56448: LD_VAR 0 3
56452: PUSH
56453: LD_VAR 0 4
56457: PUSH
56458: LD_VAR 0 5
56462: PUSH
56463: EMPTY
56464: LIST
56465: LIST
56466: LIST
56467: LIST
56468: ST_TO_ADDR
// exit ;
56469: GO 56883
// end ; _chassis := AvailableChassisList ( factory ) ;
56471: LD_ADDR_VAR 0 9
56475: PUSH
56476: LD_VAR 0 1
56480: PPUSH
56481: CALL_OW 475
56485: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
56486: LD_ADDR_VAR 0 11
56490: PUSH
56491: LD_VAR 0 1
56495: PPUSH
56496: CALL_OW 476
56500: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
56501: LD_ADDR_VAR 0 12
56505: PUSH
56506: LD_VAR 0 1
56510: PPUSH
56511: CALL_OW 477
56515: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
56516: LD_ADDR_VAR 0 10
56520: PUSH
56521: LD_VAR 0 1
56525: PPUSH
56526: CALL_OW 478
56530: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
56531: LD_VAR 0 9
56535: NOT
56536: PUSH
56537: LD_VAR 0 11
56541: NOT
56542: OR
56543: PUSH
56544: LD_VAR 0 12
56548: NOT
56549: OR
56550: PUSH
56551: LD_VAR 0 10
56555: NOT
56556: OR
56557: IFFALSE 56592
// begin result := [ chassis , engine , control , weapon ] ;
56559: LD_ADDR_VAR 0 6
56563: PUSH
56564: LD_VAR 0 2
56568: PUSH
56569: LD_VAR 0 3
56573: PUSH
56574: LD_VAR 0 4
56578: PUSH
56579: LD_VAR 0 5
56583: PUSH
56584: EMPTY
56585: LIST
56586: LIST
56587: LIST
56588: LIST
56589: ST_TO_ADDR
// exit ;
56590: GO 56883
// end ; if not chassis in _chassis then
56592: LD_VAR 0 2
56596: PUSH
56597: LD_VAR 0 9
56601: IN
56602: NOT
56603: IFFALSE 56629
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
56605: LD_ADDR_VAR 0 2
56609: PUSH
56610: LD_VAR 0 9
56614: PUSH
56615: LD_INT 1
56617: PPUSH
56618: LD_VAR 0 9
56622: PPUSH
56623: CALL_OW 12
56627: ARRAY
56628: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
56629: LD_VAR 0 2
56633: PPUSH
56634: LD_VAR 0 3
56638: PPUSH
56639: CALL 56888 0 2
56643: NOT
56644: IFFALSE 56703
// repeat engine := _engine [ 1 ] ;
56646: LD_ADDR_VAR 0 3
56650: PUSH
56651: LD_VAR 0 11
56655: PUSH
56656: LD_INT 1
56658: ARRAY
56659: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
56660: LD_ADDR_VAR 0 11
56664: PUSH
56665: LD_VAR 0 11
56669: PPUSH
56670: LD_INT 1
56672: PPUSH
56673: CALL_OW 3
56677: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
56678: LD_VAR 0 2
56682: PPUSH
56683: LD_VAR 0 3
56687: PPUSH
56688: CALL 56888 0 2
56692: PUSH
56693: LD_VAR 0 11
56697: PUSH
56698: EMPTY
56699: EQUAL
56700: OR
56701: IFFALSE 56646
// if not control in _control then
56703: LD_VAR 0 4
56707: PUSH
56708: LD_VAR 0 12
56712: IN
56713: NOT
56714: IFFALSE 56740
// control := _control [ rand ( 1 , _control ) ] ;
56716: LD_ADDR_VAR 0 4
56720: PUSH
56721: LD_VAR 0 12
56725: PUSH
56726: LD_INT 1
56728: PPUSH
56729: LD_VAR 0 12
56733: PPUSH
56734: CALL_OW 12
56738: ARRAY
56739: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
56740: LD_VAR 0 2
56744: PPUSH
56745: LD_VAR 0 5
56749: PPUSH
56750: CALL 57108 0 2
56754: NOT
56755: IFFALSE 56814
// repeat weapon := _weapon [ 1 ] ;
56757: LD_ADDR_VAR 0 5
56761: PUSH
56762: LD_VAR 0 10
56766: PUSH
56767: LD_INT 1
56769: ARRAY
56770: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
56771: LD_ADDR_VAR 0 10
56775: PUSH
56776: LD_VAR 0 10
56780: PPUSH
56781: LD_INT 1
56783: PPUSH
56784: CALL_OW 3
56788: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
56789: LD_VAR 0 2
56793: PPUSH
56794: LD_VAR 0 5
56798: PPUSH
56799: CALL 57108 0 2
56803: PUSH
56804: LD_VAR 0 10
56808: PUSH
56809: EMPTY
56810: EQUAL
56811: OR
56812: IFFALSE 56757
// result := [ ] ;
56814: LD_ADDR_VAR 0 6
56818: PUSH
56819: EMPTY
56820: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
56821: LD_VAR 0 1
56825: PPUSH
56826: LD_VAR 0 2
56830: PPUSH
56831: LD_VAR 0 3
56835: PPUSH
56836: LD_VAR 0 4
56840: PPUSH
56841: LD_VAR 0 5
56845: PPUSH
56846: CALL_OW 448
56850: IFFALSE 56883
// result := [ chassis , engine , control , weapon ] ;
56852: LD_ADDR_VAR 0 6
56856: PUSH
56857: LD_VAR 0 2
56861: PUSH
56862: LD_VAR 0 3
56866: PUSH
56867: LD_VAR 0 4
56871: PUSH
56872: LD_VAR 0 5
56876: PUSH
56877: EMPTY
56878: LIST
56879: LIST
56880: LIST
56881: LIST
56882: ST_TO_ADDR
// end ;
56883: LD_VAR 0 6
56887: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
56888: LD_INT 0
56890: PPUSH
// if not chassis or not engine then
56891: LD_VAR 0 1
56895: NOT
56896: PUSH
56897: LD_VAR 0 2
56901: NOT
56902: OR
56903: IFFALSE 56907
// exit ;
56905: GO 57103
// case engine of engine_solar :
56907: LD_VAR 0 2
56911: PUSH
56912: LD_INT 2
56914: DOUBLE
56915: EQUAL
56916: IFTRUE 56920
56918: GO 56958
56920: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
56921: LD_ADDR_VAR 0 3
56925: PUSH
56926: LD_INT 11
56928: PUSH
56929: LD_INT 12
56931: PUSH
56932: LD_INT 13
56934: PUSH
56935: LD_INT 14
56937: PUSH
56938: LD_INT 1
56940: PUSH
56941: LD_INT 2
56943: PUSH
56944: LD_INT 3
56946: PUSH
56947: EMPTY
56948: LIST
56949: LIST
56950: LIST
56951: LIST
56952: LIST
56953: LIST
56954: LIST
56955: ST_TO_ADDR
56956: GO 57087
56958: LD_INT 1
56960: DOUBLE
56961: EQUAL
56962: IFTRUE 56966
56964: GO 57028
56966: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56967: LD_ADDR_VAR 0 3
56971: PUSH
56972: LD_INT 11
56974: PUSH
56975: LD_INT 12
56977: PUSH
56978: LD_INT 13
56980: PUSH
56981: LD_INT 14
56983: PUSH
56984: LD_INT 1
56986: PUSH
56987: LD_INT 2
56989: PUSH
56990: LD_INT 3
56992: PUSH
56993: LD_INT 4
56995: PUSH
56996: LD_INT 5
56998: PUSH
56999: LD_INT 21
57001: PUSH
57002: LD_INT 23
57004: PUSH
57005: LD_INT 22
57007: PUSH
57008: LD_INT 24
57010: PUSH
57011: EMPTY
57012: LIST
57013: LIST
57014: LIST
57015: LIST
57016: LIST
57017: LIST
57018: LIST
57019: LIST
57020: LIST
57021: LIST
57022: LIST
57023: LIST
57024: LIST
57025: ST_TO_ADDR
57026: GO 57087
57028: LD_INT 3
57030: DOUBLE
57031: EQUAL
57032: IFTRUE 57036
57034: GO 57086
57036: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57037: LD_ADDR_VAR 0 3
57041: PUSH
57042: LD_INT 13
57044: PUSH
57045: LD_INT 14
57047: PUSH
57048: LD_INT 2
57050: PUSH
57051: LD_INT 3
57053: PUSH
57054: LD_INT 4
57056: PUSH
57057: LD_INT 5
57059: PUSH
57060: LD_INT 21
57062: PUSH
57063: LD_INT 22
57065: PUSH
57066: LD_INT 23
57068: PUSH
57069: LD_INT 24
57071: PUSH
57072: EMPTY
57073: LIST
57074: LIST
57075: LIST
57076: LIST
57077: LIST
57078: LIST
57079: LIST
57080: LIST
57081: LIST
57082: LIST
57083: ST_TO_ADDR
57084: GO 57087
57086: POP
// result := ( chassis in result ) ;
57087: LD_ADDR_VAR 0 3
57091: PUSH
57092: LD_VAR 0 1
57096: PUSH
57097: LD_VAR 0 3
57101: IN
57102: ST_TO_ADDR
// end ;
57103: LD_VAR 0 3
57107: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
57108: LD_INT 0
57110: PPUSH
// if not chassis or not weapon then
57111: LD_VAR 0 1
57115: NOT
57116: PUSH
57117: LD_VAR 0 2
57121: NOT
57122: OR
57123: IFFALSE 57127
// exit ;
57125: GO 58187
// case weapon of us_machine_gun :
57127: LD_VAR 0 2
57131: PUSH
57132: LD_INT 2
57134: DOUBLE
57135: EQUAL
57136: IFTRUE 57140
57138: GO 57170
57140: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
57141: LD_ADDR_VAR 0 3
57145: PUSH
57146: LD_INT 1
57148: PUSH
57149: LD_INT 2
57151: PUSH
57152: LD_INT 3
57154: PUSH
57155: LD_INT 4
57157: PUSH
57158: LD_INT 5
57160: PUSH
57161: EMPTY
57162: LIST
57163: LIST
57164: LIST
57165: LIST
57166: LIST
57167: ST_TO_ADDR
57168: GO 58171
57170: LD_INT 3
57172: DOUBLE
57173: EQUAL
57174: IFTRUE 57178
57176: GO 57208
57178: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
57179: LD_ADDR_VAR 0 3
57183: PUSH
57184: LD_INT 1
57186: PUSH
57187: LD_INT 2
57189: PUSH
57190: LD_INT 3
57192: PUSH
57193: LD_INT 4
57195: PUSH
57196: LD_INT 5
57198: PUSH
57199: EMPTY
57200: LIST
57201: LIST
57202: LIST
57203: LIST
57204: LIST
57205: ST_TO_ADDR
57206: GO 58171
57208: LD_INT 11
57210: DOUBLE
57211: EQUAL
57212: IFTRUE 57216
57214: GO 57246
57216: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
57217: LD_ADDR_VAR 0 3
57221: PUSH
57222: LD_INT 1
57224: PUSH
57225: LD_INT 2
57227: PUSH
57228: LD_INT 3
57230: PUSH
57231: LD_INT 4
57233: PUSH
57234: LD_INT 5
57236: PUSH
57237: EMPTY
57238: LIST
57239: LIST
57240: LIST
57241: LIST
57242: LIST
57243: ST_TO_ADDR
57244: GO 58171
57246: LD_INT 4
57248: DOUBLE
57249: EQUAL
57250: IFTRUE 57254
57252: GO 57280
57254: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
57255: LD_ADDR_VAR 0 3
57259: PUSH
57260: LD_INT 2
57262: PUSH
57263: LD_INT 3
57265: PUSH
57266: LD_INT 4
57268: PUSH
57269: LD_INT 5
57271: PUSH
57272: EMPTY
57273: LIST
57274: LIST
57275: LIST
57276: LIST
57277: ST_TO_ADDR
57278: GO 58171
57280: LD_INT 5
57282: DOUBLE
57283: EQUAL
57284: IFTRUE 57288
57286: GO 57314
57288: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
57289: LD_ADDR_VAR 0 3
57293: PUSH
57294: LD_INT 2
57296: PUSH
57297: LD_INT 3
57299: PUSH
57300: LD_INT 4
57302: PUSH
57303: LD_INT 5
57305: PUSH
57306: EMPTY
57307: LIST
57308: LIST
57309: LIST
57310: LIST
57311: ST_TO_ADDR
57312: GO 58171
57314: LD_INT 9
57316: DOUBLE
57317: EQUAL
57318: IFTRUE 57322
57320: GO 57348
57322: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
57323: LD_ADDR_VAR 0 3
57327: PUSH
57328: LD_INT 2
57330: PUSH
57331: LD_INT 3
57333: PUSH
57334: LD_INT 4
57336: PUSH
57337: LD_INT 5
57339: PUSH
57340: EMPTY
57341: LIST
57342: LIST
57343: LIST
57344: LIST
57345: ST_TO_ADDR
57346: GO 58171
57348: LD_INT 7
57350: DOUBLE
57351: EQUAL
57352: IFTRUE 57356
57354: GO 57382
57356: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
57357: LD_ADDR_VAR 0 3
57361: PUSH
57362: LD_INT 2
57364: PUSH
57365: LD_INT 3
57367: PUSH
57368: LD_INT 4
57370: PUSH
57371: LD_INT 5
57373: PUSH
57374: EMPTY
57375: LIST
57376: LIST
57377: LIST
57378: LIST
57379: ST_TO_ADDR
57380: GO 58171
57382: LD_INT 12
57384: DOUBLE
57385: EQUAL
57386: IFTRUE 57390
57388: GO 57416
57390: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
57391: LD_ADDR_VAR 0 3
57395: PUSH
57396: LD_INT 2
57398: PUSH
57399: LD_INT 3
57401: PUSH
57402: LD_INT 4
57404: PUSH
57405: LD_INT 5
57407: PUSH
57408: EMPTY
57409: LIST
57410: LIST
57411: LIST
57412: LIST
57413: ST_TO_ADDR
57414: GO 58171
57416: LD_INT 13
57418: DOUBLE
57419: EQUAL
57420: IFTRUE 57424
57422: GO 57450
57424: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
57425: LD_ADDR_VAR 0 3
57429: PUSH
57430: LD_INT 2
57432: PUSH
57433: LD_INT 3
57435: PUSH
57436: LD_INT 4
57438: PUSH
57439: LD_INT 5
57441: PUSH
57442: EMPTY
57443: LIST
57444: LIST
57445: LIST
57446: LIST
57447: ST_TO_ADDR
57448: GO 58171
57450: LD_INT 14
57452: DOUBLE
57453: EQUAL
57454: IFTRUE 57458
57456: GO 57476
57458: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
57459: LD_ADDR_VAR 0 3
57463: PUSH
57464: LD_INT 4
57466: PUSH
57467: LD_INT 5
57469: PUSH
57470: EMPTY
57471: LIST
57472: LIST
57473: ST_TO_ADDR
57474: GO 58171
57476: LD_INT 6
57478: DOUBLE
57479: EQUAL
57480: IFTRUE 57484
57482: GO 57502
57484: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
57485: LD_ADDR_VAR 0 3
57489: PUSH
57490: LD_INT 4
57492: PUSH
57493: LD_INT 5
57495: PUSH
57496: EMPTY
57497: LIST
57498: LIST
57499: ST_TO_ADDR
57500: GO 58171
57502: LD_INT 10
57504: DOUBLE
57505: EQUAL
57506: IFTRUE 57510
57508: GO 57528
57510: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
57511: LD_ADDR_VAR 0 3
57515: PUSH
57516: LD_INT 4
57518: PUSH
57519: LD_INT 5
57521: PUSH
57522: EMPTY
57523: LIST
57524: LIST
57525: ST_TO_ADDR
57526: GO 58171
57528: LD_INT 22
57530: DOUBLE
57531: EQUAL
57532: IFTRUE 57536
57534: GO 57562
57536: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
57537: LD_ADDR_VAR 0 3
57541: PUSH
57542: LD_INT 11
57544: PUSH
57545: LD_INT 12
57547: PUSH
57548: LD_INT 13
57550: PUSH
57551: LD_INT 14
57553: PUSH
57554: EMPTY
57555: LIST
57556: LIST
57557: LIST
57558: LIST
57559: ST_TO_ADDR
57560: GO 58171
57562: LD_INT 23
57564: DOUBLE
57565: EQUAL
57566: IFTRUE 57570
57568: GO 57596
57570: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
57571: LD_ADDR_VAR 0 3
57575: PUSH
57576: LD_INT 11
57578: PUSH
57579: LD_INT 12
57581: PUSH
57582: LD_INT 13
57584: PUSH
57585: LD_INT 14
57587: PUSH
57588: EMPTY
57589: LIST
57590: LIST
57591: LIST
57592: LIST
57593: ST_TO_ADDR
57594: GO 58171
57596: LD_INT 24
57598: DOUBLE
57599: EQUAL
57600: IFTRUE 57604
57602: GO 57630
57604: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
57605: LD_ADDR_VAR 0 3
57609: PUSH
57610: LD_INT 11
57612: PUSH
57613: LD_INT 12
57615: PUSH
57616: LD_INT 13
57618: PUSH
57619: LD_INT 14
57621: PUSH
57622: EMPTY
57623: LIST
57624: LIST
57625: LIST
57626: LIST
57627: ST_TO_ADDR
57628: GO 58171
57630: LD_INT 30
57632: DOUBLE
57633: EQUAL
57634: IFTRUE 57638
57636: GO 57664
57638: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
57639: LD_ADDR_VAR 0 3
57643: PUSH
57644: LD_INT 11
57646: PUSH
57647: LD_INT 12
57649: PUSH
57650: LD_INT 13
57652: PUSH
57653: LD_INT 14
57655: PUSH
57656: EMPTY
57657: LIST
57658: LIST
57659: LIST
57660: LIST
57661: ST_TO_ADDR
57662: GO 58171
57664: LD_INT 25
57666: DOUBLE
57667: EQUAL
57668: IFTRUE 57672
57670: GO 57690
57672: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
57673: LD_ADDR_VAR 0 3
57677: PUSH
57678: LD_INT 13
57680: PUSH
57681: LD_INT 14
57683: PUSH
57684: EMPTY
57685: LIST
57686: LIST
57687: ST_TO_ADDR
57688: GO 58171
57690: LD_INT 27
57692: DOUBLE
57693: EQUAL
57694: IFTRUE 57698
57696: GO 57716
57698: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
57699: LD_ADDR_VAR 0 3
57703: PUSH
57704: LD_INT 13
57706: PUSH
57707: LD_INT 14
57709: PUSH
57710: EMPTY
57711: LIST
57712: LIST
57713: ST_TO_ADDR
57714: GO 58171
57716: LD_INT 92
57718: DOUBLE
57719: EQUAL
57720: IFTRUE 57724
57722: GO 57750
57724: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
57725: LD_ADDR_VAR 0 3
57729: PUSH
57730: LD_INT 11
57732: PUSH
57733: LD_INT 12
57735: PUSH
57736: LD_INT 13
57738: PUSH
57739: LD_INT 14
57741: PUSH
57742: EMPTY
57743: LIST
57744: LIST
57745: LIST
57746: LIST
57747: ST_TO_ADDR
57748: GO 58171
57750: LD_INT 28
57752: DOUBLE
57753: EQUAL
57754: IFTRUE 57758
57756: GO 57776
57758: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
57759: LD_ADDR_VAR 0 3
57763: PUSH
57764: LD_INT 13
57766: PUSH
57767: LD_INT 14
57769: PUSH
57770: EMPTY
57771: LIST
57772: LIST
57773: ST_TO_ADDR
57774: GO 58171
57776: LD_INT 29
57778: DOUBLE
57779: EQUAL
57780: IFTRUE 57784
57782: GO 57802
57784: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
57785: LD_ADDR_VAR 0 3
57789: PUSH
57790: LD_INT 13
57792: PUSH
57793: LD_INT 14
57795: PUSH
57796: EMPTY
57797: LIST
57798: LIST
57799: ST_TO_ADDR
57800: GO 58171
57802: LD_INT 31
57804: DOUBLE
57805: EQUAL
57806: IFTRUE 57810
57808: GO 57828
57810: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
57811: LD_ADDR_VAR 0 3
57815: PUSH
57816: LD_INT 13
57818: PUSH
57819: LD_INT 14
57821: PUSH
57822: EMPTY
57823: LIST
57824: LIST
57825: ST_TO_ADDR
57826: GO 58171
57828: LD_INT 26
57830: DOUBLE
57831: EQUAL
57832: IFTRUE 57836
57834: GO 57854
57836: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
57837: LD_ADDR_VAR 0 3
57841: PUSH
57842: LD_INT 13
57844: PUSH
57845: LD_INT 14
57847: PUSH
57848: EMPTY
57849: LIST
57850: LIST
57851: ST_TO_ADDR
57852: GO 58171
57854: LD_INT 42
57856: DOUBLE
57857: EQUAL
57858: IFTRUE 57862
57860: GO 57888
57862: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
57863: LD_ADDR_VAR 0 3
57867: PUSH
57868: LD_INT 21
57870: PUSH
57871: LD_INT 22
57873: PUSH
57874: LD_INT 23
57876: PUSH
57877: LD_INT 24
57879: PUSH
57880: EMPTY
57881: LIST
57882: LIST
57883: LIST
57884: LIST
57885: ST_TO_ADDR
57886: GO 58171
57888: LD_INT 43
57890: DOUBLE
57891: EQUAL
57892: IFTRUE 57896
57894: GO 57922
57896: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
57897: LD_ADDR_VAR 0 3
57901: PUSH
57902: LD_INT 21
57904: PUSH
57905: LD_INT 22
57907: PUSH
57908: LD_INT 23
57910: PUSH
57911: LD_INT 24
57913: PUSH
57914: EMPTY
57915: LIST
57916: LIST
57917: LIST
57918: LIST
57919: ST_TO_ADDR
57920: GO 58171
57922: LD_INT 44
57924: DOUBLE
57925: EQUAL
57926: IFTRUE 57930
57928: GO 57956
57930: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
57931: LD_ADDR_VAR 0 3
57935: PUSH
57936: LD_INT 21
57938: PUSH
57939: LD_INT 22
57941: PUSH
57942: LD_INT 23
57944: PUSH
57945: LD_INT 24
57947: PUSH
57948: EMPTY
57949: LIST
57950: LIST
57951: LIST
57952: LIST
57953: ST_TO_ADDR
57954: GO 58171
57956: LD_INT 45
57958: DOUBLE
57959: EQUAL
57960: IFTRUE 57964
57962: GO 57990
57964: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
57965: LD_ADDR_VAR 0 3
57969: PUSH
57970: LD_INT 21
57972: PUSH
57973: LD_INT 22
57975: PUSH
57976: LD_INT 23
57978: PUSH
57979: LD_INT 24
57981: PUSH
57982: EMPTY
57983: LIST
57984: LIST
57985: LIST
57986: LIST
57987: ST_TO_ADDR
57988: GO 58171
57990: LD_INT 49
57992: DOUBLE
57993: EQUAL
57994: IFTRUE 57998
57996: GO 58024
57998: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57999: LD_ADDR_VAR 0 3
58003: PUSH
58004: LD_INT 21
58006: PUSH
58007: LD_INT 22
58009: PUSH
58010: LD_INT 23
58012: PUSH
58013: LD_INT 24
58015: PUSH
58016: EMPTY
58017: LIST
58018: LIST
58019: LIST
58020: LIST
58021: ST_TO_ADDR
58022: GO 58171
58024: LD_INT 51
58026: DOUBLE
58027: EQUAL
58028: IFTRUE 58032
58030: GO 58058
58032: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
58033: LD_ADDR_VAR 0 3
58037: PUSH
58038: LD_INT 21
58040: PUSH
58041: LD_INT 22
58043: PUSH
58044: LD_INT 23
58046: PUSH
58047: LD_INT 24
58049: PUSH
58050: EMPTY
58051: LIST
58052: LIST
58053: LIST
58054: LIST
58055: ST_TO_ADDR
58056: GO 58171
58058: LD_INT 52
58060: DOUBLE
58061: EQUAL
58062: IFTRUE 58066
58064: GO 58092
58066: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
58067: LD_ADDR_VAR 0 3
58071: PUSH
58072: LD_INT 21
58074: PUSH
58075: LD_INT 22
58077: PUSH
58078: LD_INT 23
58080: PUSH
58081: LD_INT 24
58083: PUSH
58084: EMPTY
58085: LIST
58086: LIST
58087: LIST
58088: LIST
58089: ST_TO_ADDR
58090: GO 58171
58092: LD_INT 53
58094: DOUBLE
58095: EQUAL
58096: IFTRUE 58100
58098: GO 58118
58100: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
58101: LD_ADDR_VAR 0 3
58105: PUSH
58106: LD_INT 23
58108: PUSH
58109: LD_INT 24
58111: PUSH
58112: EMPTY
58113: LIST
58114: LIST
58115: ST_TO_ADDR
58116: GO 58171
58118: LD_INT 46
58120: DOUBLE
58121: EQUAL
58122: IFTRUE 58126
58124: GO 58144
58126: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
58127: LD_ADDR_VAR 0 3
58131: PUSH
58132: LD_INT 23
58134: PUSH
58135: LD_INT 24
58137: PUSH
58138: EMPTY
58139: LIST
58140: LIST
58141: ST_TO_ADDR
58142: GO 58171
58144: LD_INT 47
58146: DOUBLE
58147: EQUAL
58148: IFTRUE 58152
58150: GO 58170
58152: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
58153: LD_ADDR_VAR 0 3
58157: PUSH
58158: LD_INT 23
58160: PUSH
58161: LD_INT 24
58163: PUSH
58164: EMPTY
58165: LIST
58166: LIST
58167: ST_TO_ADDR
58168: GO 58171
58170: POP
// result := ( chassis in result ) ;
58171: LD_ADDR_VAR 0 3
58175: PUSH
58176: LD_VAR 0 1
58180: PUSH
58181: LD_VAR 0 3
58185: IN
58186: ST_TO_ADDR
// end ;
58187: LD_VAR 0 3
58191: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
58192: LD_INT 0
58194: PPUSH
58195: PPUSH
58196: PPUSH
58197: PPUSH
58198: PPUSH
58199: PPUSH
58200: PPUSH
// result := array ;
58201: LD_ADDR_VAR 0 5
58205: PUSH
58206: LD_VAR 0 1
58210: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
58211: LD_VAR 0 1
58215: NOT
58216: PUSH
58217: LD_VAR 0 2
58221: NOT
58222: OR
58223: PUSH
58224: LD_VAR 0 3
58228: NOT
58229: OR
58230: PUSH
58231: LD_VAR 0 2
58235: PUSH
58236: LD_VAR 0 1
58240: GREATER
58241: OR
58242: PUSH
58243: LD_VAR 0 3
58247: PUSH
58248: LD_VAR 0 1
58252: GREATER
58253: OR
58254: IFFALSE 58258
// exit ;
58256: GO 58554
// if direction then
58258: LD_VAR 0 4
58262: IFFALSE 58326
// begin d := 1 ;
58264: LD_ADDR_VAR 0 9
58268: PUSH
58269: LD_INT 1
58271: ST_TO_ADDR
// if i_from > i_to then
58272: LD_VAR 0 2
58276: PUSH
58277: LD_VAR 0 3
58281: GREATER
58282: IFFALSE 58308
// length := ( array - i_from ) + i_to else
58284: LD_ADDR_VAR 0 11
58288: PUSH
58289: LD_VAR 0 1
58293: PUSH
58294: LD_VAR 0 2
58298: MINUS
58299: PUSH
58300: LD_VAR 0 3
58304: PLUS
58305: ST_TO_ADDR
58306: GO 58324
// length := i_to - i_from ;
58308: LD_ADDR_VAR 0 11
58312: PUSH
58313: LD_VAR 0 3
58317: PUSH
58318: LD_VAR 0 2
58322: MINUS
58323: ST_TO_ADDR
// end else
58324: GO 58387
// begin d := - 1 ;
58326: LD_ADDR_VAR 0 9
58330: PUSH
58331: LD_INT 1
58333: NEG
58334: ST_TO_ADDR
// if i_from > i_to then
58335: LD_VAR 0 2
58339: PUSH
58340: LD_VAR 0 3
58344: GREATER
58345: IFFALSE 58365
// length := i_from - i_to else
58347: LD_ADDR_VAR 0 11
58351: PUSH
58352: LD_VAR 0 2
58356: PUSH
58357: LD_VAR 0 3
58361: MINUS
58362: ST_TO_ADDR
58363: GO 58387
// length := ( array - i_to ) + i_from ;
58365: LD_ADDR_VAR 0 11
58369: PUSH
58370: LD_VAR 0 1
58374: PUSH
58375: LD_VAR 0 3
58379: MINUS
58380: PUSH
58381: LD_VAR 0 2
58385: PLUS
58386: ST_TO_ADDR
// end ; if not length then
58387: LD_VAR 0 11
58391: NOT
58392: IFFALSE 58396
// exit ;
58394: GO 58554
// tmp := array ;
58396: LD_ADDR_VAR 0 10
58400: PUSH
58401: LD_VAR 0 1
58405: ST_TO_ADDR
// for i = 1 to length do
58406: LD_ADDR_VAR 0 6
58410: PUSH
58411: DOUBLE
58412: LD_INT 1
58414: DEC
58415: ST_TO_ADDR
58416: LD_VAR 0 11
58420: PUSH
58421: FOR_TO
58422: IFFALSE 58542
// begin for j = 1 to array do
58424: LD_ADDR_VAR 0 7
58428: PUSH
58429: DOUBLE
58430: LD_INT 1
58432: DEC
58433: ST_TO_ADDR
58434: LD_VAR 0 1
58438: PUSH
58439: FOR_TO
58440: IFFALSE 58528
// begin k := j + d ;
58442: LD_ADDR_VAR 0 8
58446: PUSH
58447: LD_VAR 0 7
58451: PUSH
58452: LD_VAR 0 9
58456: PLUS
58457: ST_TO_ADDR
// if k > array then
58458: LD_VAR 0 8
58462: PUSH
58463: LD_VAR 0 1
58467: GREATER
58468: IFFALSE 58478
// k := 1 ;
58470: LD_ADDR_VAR 0 8
58474: PUSH
58475: LD_INT 1
58477: ST_TO_ADDR
// if not k then
58478: LD_VAR 0 8
58482: NOT
58483: IFFALSE 58495
// k := array ;
58485: LD_ADDR_VAR 0 8
58489: PUSH
58490: LD_VAR 0 1
58494: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
58495: LD_ADDR_VAR 0 10
58499: PUSH
58500: LD_VAR 0 10
58504: PPUSH
58505: LD_VAR 0 8
58509: PPUSH
58510: LD_VAR 0 1
58514: PUSH
58515: LD_VAR 0 7
58519: ARRAY
58520: PPUSH
58521: CALL_OW 1
58525: ST_TO_ADDR
// end ;
58526: GO 58439
58528: POP
58529: POP
// array := tmp ;
58530: LD_ADDR_VAR 0 1
58534: PUSH
58535: LD_VAR 0 10
58539: ST_TO_ADDR
// end ;
58540: GO 58421
58542: POP
58543: POP
// result := array ;
58544: LD_ADDR_VAR 0 5
58548: PUSH
58549: LD_VAR 0 1
58553: ST_TO_ADDR
// end ;
58554: LD_VAR 0 5
58558: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
58559: LD_INT 0
58561: PPUSH
58562: PPUSH
// result := 0 ;
58563: LD_ADDR_VAR 0 3
58567: PUSH
58568: LD_INT 0
58570: ST_TO_ADDR
// if not array or not value in array then
58571: LD_VAR 0 1
58575: NOT
58576: PUSH
58577: LD_VAR 0 2
58581: PUSH
58582: LD_VAR 0 1
58586: IN
58587: NOT
58588: OR
58589: IFFALSE 58593
// exit ;
58591: GO 58647
// for i = 1 to array do
58593: LD_ADDR_VAR 0 4
58597: PUSH
58598: DOUBLE
58599: LD_INT 1
58601: DEC
58602: ST_TO_ADDR
58603: LD_VAR 0 1
58607: PUSH
58608: FOR_TO
58609: IFFALSE 58645
// if value = array [ i ] then
58611: LD_VAR 0 2
58615: PUSH
58616: LD_VAR 0 1
58620: PUSH
58621: LD_VAR 0 4
58625: ARRAY
58626: EQUAL
58627: IFFALSE 58643
// begin result := i ;
58629: LD_ADDR_VAR 0 3
58633: PUSH
58634: LD_VAR 0 4
58638: ST_TO_ADDR
// exit ;
58639: POP
58640: POP
58641: GO 58647
// end ;
58643: GO 58608
58645: POP
58646: POP
// end ;
58647: LD_VAR 0 3
58651: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
58652: LD_INT 0
58654: PPUSH
// vc_chassis := chassis ;
58655: LD_ADDR_OWVAR 37
58659: PUSH
58660: LD_VAR 0 1
58664: ST_TO_ADDR
// vc_engine := engine ;
58665: LD_ADDR_OWVAR 39
58669: PUSH
58670: LD_VAR 0 2
58674: ST_TO_ADDR
// vc_control := control ;
58675: LD_ADDR_OWVAR 38
58679: PUSH
58680: LD_VAR 0 3
58684: ST_TO_ADDR
// vc_weapon := weapon ;
58685: LD_ADDR_OWVAR 40
58689: PUSH
58690: LD_VAR 0 4
58694: ST_TO_ADDR
// vc_fuel_battery := fuel ;
58695: LD_ADDR_OWVAR 41
58699: PUSH
58700: LD_VAR 0 5
58704: ST_TO_ADDR
// end ;
58705: LD_VAR 0 6
58709: RET
// export function WantPlant ( unit ) ; var task ; begin
58710: LD_INT 0
58712: PPUSH
58713: PPUSH
// result := false ;
58714: LD_ADDR_VAR 0 2
58718: PUSH
58719: LD_INT 0
58721: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
58722: LD_ADDR_VAR 0 3
58726: PUSH
58727: LD_VAR 0 1
58731: PPUSH
58732: CALL_OW 437
58736: ST_TO_ADDR
// if task then
58737: LD_VAR 0 3
58741: IFFALSE 58769
// if task [ 1 ] [ 1 ] = p then
58743: LD_VAR 0 3
58747: PUSH
58748: LD_INT 1
58750: ARRAY
58751: PUSH
58752: LD_INT 1
58754: ARRAY
58755: PUSH
58756: LD_STRING p
58758: EQUAL
58759: IFFALSE 58769
// result := true ;
58761: LD_ADDR_VAR 0 2
58765: PUSH
58766: LD_INT 1
58768: ST_TO_ADDR
// end ;
58769: LD_VAR 0 2
58773: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
58774: LD_INT 0
58776: PPUSH
58777: PPUSH
58778: PPUSH
58779: PPUSH
// if pos < 1 then
58780: LD_VAR 0 2
58784: PUSH
58785: LD_INT 1
58787: LESS
58788: IFFALSE 58792
// exit ;
58790: GO 59095
// if pos = 1 then
58792: LD_VAR 0 2
58796: PUSH
58797: LD_INT 1
58799: EQUAL
58800: IFFALSE 58833
// result := Replace ( arr , pos [ 1 ] , value ) else
58802: LD_ADDR_VAR 0 4
58806: PUSH
58807: LD_VAR 0 1
58811: PPUSH
58812: LD_VAR 0 2
58816: PUSH
58817: LD_INT 1
58819: ARRAY
58820: PPUSH
58821: LD_VAR 0 3
58825: PPUSH
58826: CALL_OW 1
58830: ST_TO_ADDR
58831: GO 59095
// begin tmp := arr ;
58833: LD_ADDR_VAR 0 6
58837: PUSH
58838: LD_VAR 0 1
58842: ST_TO_ADDR
// s_arr := [ tmp ] ;
58843: LD_ADDR_VAR 0 7
58847: PUSH
58848: LD_VAR 0 6
58852: PUSH
58853: EMPTY
58854: LIST
58855: ST_TO_ADDR
// for i = 1 to pos - 1 do
58856: LD_ADDR_VAR 0 5
58860: PUSH
58861: DOUBLE
58862: LD_INT 1
58864: DEC
58865: ST_TO_ADDR
58866: LD_VAR 0 2
58870: PUSH
58871: LD_INT 1
58873: MINUS
58874: PUSH
58875: FOR_TO
58876: IFFALSE 58921
// begin tmp := tmp [ pos [ i ] ] ;
58878: LD_ADDR_VAR 0 6
58882: PUSH
58883: LD_VAR 0 6
58887: PUSH
58888: LD_VAR 0 2
58892: PUSH
58893: LD_VAR 0 5
58897: ARRAY
58898: ARRAY
58899: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
58900: LD_ADDR_VAR 0 7
58904: PUSH
58905: LD_VAR 0 7
58909: PUSH
58910: LD_VAR 0 6
58914: PUSH
58915: EMPTY
58916: LIST
58917: ADD
58918: ST_TO_ADDR
// end ;
58919: GO 58875
58921: POP
58922: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
58923: LD_ADDR_VAR 0 6
58927: PUSH
58928: LD_VAR 0 6
58932: PPUSH
58933: LD_VAR 0 2
58937: PUSH
58938: LD_VAR 0 2
58942: ARRAY
58943: PPUSH
58944: LD_VAR 0 3
58948: PPUSH
58949: CALL_OW 1
58953: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
58954: LD_ADDR_VAR 0 7
58958: PUSH
58959: LD_VAR 0 7
58963: PPUSH
58964: LD_VAR 0 7
58968: PPUSH
58969: LD_VAR 0 6
58973: PPUSH
58974: CALL_OW 1
58978: ST_TO_ADDR
// for i = s_arr downto 2 do
58979: LD_ADDR_VAR 0 5
58983: PUSH
58984: DOUBLE
58985: LD_VAR 0 7
58989: INC
58990: ST_TO_ADDR
58991: LD_INT 2
58993: PUSH
58994: FOR_DOWNTO
58995: IFFALSE 59079
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58997: LD_ADDR_VAR 0 6
59001: PUSH
59002: LD_VAR 0 7
59006: PUSH
59007: LD_VAR 0 5
59011: PUSH
59012: LD_INT 1
59014: MINUS
59015: ARRAY
59016: PPUSH
59017: LD_VAR 0 2
59021: PUSH
59022: LD_VAR 0 5
59026: PUSH
59027: LD_INT 1
59029: MINUS
59030: ARRAY
59031: PPUSH
59032: LD_VAR 0 7
59036: PUSH
59037: LD_VAR 0 5
59041: ARRAY
59042: PPUSH
59043: CALL_OW 1
59047: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
59048: LD_ADDR_VAR 0 7
59052: PUSH
59053: LD_VAR 0 7
59057: PPUSH
59058: LD_VAR 0 5
59062: PUSH
59063: LD_INT 1
59065: MINUS
59066: PPUSH
59067: LD_VAR 0 6
59071: PPUSH
59072: CALL_OW 1
59076: ST_TO_ADDR
// end ;
59077: GO 58994
59079: POP
59080: POP
// result := s_arr [ 1 ] ;
59081: LD_ADDR_VAR 0 4
59085: PUSH
59086: LD_VAR 0 7
59090: PUSH
59091: LD_INT 1
59093: ARRAY
59094: ST_TO_ADDR
// end ; end ;
59095: LD_VAR 0 4
59099: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
59100: LD_INT 0
59102: PPUSH
59103: PPUSH
// if not list then
59104: LD_VAR 0 1
59108: NOT
59109: IFFALSE 59113
// exit ;
59111: GO 59204
// i := list [ pos1 ] ;
59113: LD_ADDR_VAR 0 5
59117: PUSH
59118: LD_VAR 0 1
59122: PUSH
59123: LD_VAR 0 2
59127: ARRAY
59128: ST_TO_ADDR
// if not i then
59129: LD_VAR 0 5
59133: NOT
59134: IFFALSE 59138
// exit ;
59136: GO 59204
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
59138: LD_ADDR_VAR 0 1
59142: PUSH
59143: LD_VAR 0 1
59147: PPUSH
59148: LD_VAR 0 2
59152: PPUSH
59153: LD_VAR 0 1
59157: PUSH
59158: LD_VAR 0 3
59162: ARRAY
59163: PPUSH
59164: CALL_OW 1
59168: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
59169: LD_ADDR_VAR 0 1
59173: PUSH
59174: LD_VAR 0 1
59178: PPUSH
59179: LD_VAR 0 3
59183: PPUSH
59184: LD_VAR 0 5
59188: PPUSH
59189: CALL_OW 1
59193: ST_TO_ADDR
// result := list ;
59194: LD_ADDR_VAR 0 4
59198: PUSH
59199: LD_VAR 0 1
59203: ST_TO_ADDR
// end ;
59204: LD_VAR 0 4
59208: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
59209: LD_INT 0
59211: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
59212: LD_ADDR_VAR 0 5
59216: PUSH
59217: LD_VAR 0 1
59221: PPUSH
59222: CALL_OW 250
59226: PPUSH
59227: LD_VAR 0 1
59231: PPUSH
59232: CALL_OW 251
59236: PPUSH
59237: LD_VAR 0 2
59241: PPUSH
59242: LD_VAR 0 3
59246: PPUSH
59247: LD_VAR 0 4
59251: PPUSH
59252: CALL 59630 0 5
59256: ST_TO_ADDR
// end ;
59257: LD_VAR 0 5
59261: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
59262: LD_INT 0
59264: PPUSH
59265: PPUSH
59266: PPUSH
59267: PPUSH
// if not list or not unit then
59268: LD_VAR 0 2
59272: NOT
59273: PUSH
59274: LD_VAR 0 1
59278: NOT
59279: OR
59280: IFFALSE 59284
// exit ;
59282: GO 59625
// result := [ ] ;
59284: LD_ADDR_VAR 0 5
59288: PUSH
59289: EMPTY
59290: ST_TO_ADDR
// for i in list do
59291: LD_ADDR_VAR 0 6
59295: PUSH
59296: LD_VAR 0 2
59300: PUSH
59301: FOR_IN
59302: IFFALSE 59520
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
59304: LD_ADDR_VAR 0 8
59308: PUSH
59309: LD_VAR 0 1
59313: PPUSH
59314: LD_VAR 0 6
59318: PUSH
59319: LD_INT 1
59321: ARRAY
59322: PPUSH
59323: LD_VAR 0 6
59327: PUSH
59328: LD_INT 2
59330: ARRAY
59331: PPUSH
59332: CALL_OW 297
59336: ST_TO_ADDR
// if not Count ( result ) then
59337: LD_VAR 0 5
59341: PPUSH
59342: CALL 55914 0 1
59346: NOT
59347: IFFALSE 59380
// begin result := Join ( result , [ i , tmp ] ) ;
59349: LD_ADDR_VAR 0 5
59353: PUSH
59354: LD_VAR 0 5
59358: PPUSH
59359: LD_VAR 0 6
59363: PUSH
59364: LD_VAR 0 8
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: PPUSH
59373: CALL 91523 0 2
59377: ST_TO_ADDR
// continue ;
59378: GO 59301
// end ; if result [ result ] [ 2 ] <= tmp then
59380: LD_VAR 0 5
59384: PUSH
59385: LD_VAR 0 5
59389: ARRAY
59390: PUSH
59391: LD_INT 2
59393: ARRAY
59394: PUSH
59395: LD_VAR 0 8
59399: LESSEQUAL
59400: IFFALSE 59433
// result := Join ( result , [ i , tmp ] ) else
59402: LD_ADDR_VAR 0 5
59406: PUSH
59407: LD_VAR 0 5
59411: PPUSH
59412: LD_VAR 0 6
59416: PUSH
59417: LD_VAR 0 8
59421: PUSH
59422: EMPTY
59423: LIST
59424: LIST
59425: PPUSH
59426: CALL 91523 0 2
59430: ST_TO_ADDR
59431: GO 59518
// begin for j := 1 to Count ( result ) do
59433: LD_ADDR_VAR 0 7
59437: PUSH
59438: DOUBLE
59439: LD_INT 1
59441: DEC
59442: ST_TO_ADDR
59443: LD_VAR 0 5
59447: PPUSH
59448: CALL 55914 0 1
59452: PUSH
59453: FOR_TO
59454: IFFALSE 59516
// begin if tmp < result [ j ] [ 2 ] then
59456: LD_VAR 0 8
59460: PUSH
59461: LD_VAR 0 5
59465: PUSH
59466: LD_VAR 0 7
59470: ARRAY
59471: PUSH
59472: LD_INT 2
59474: ARRAY
59475: LESS
59476: IFFALSE 59514
// begin result := Insert ( result , j , [ i , tmp ] ) ;
59478: LD_ADDR_VAR 0 5
59482: PUSH
59483: LD_VAR 0 5
59487: PPUSH
59488: LD_VAR 0 7
59492: PPUSH
59493: LD_VAR 0 6
59497: PUSH
59498: LD_VAR 0 8
59502: PUSH
59503: EMPTY
59504: LIST
59505: LIST
59506: PPUSH
59507: CALL_OW 2
59511: ST_TO_ADDR
// break ;
59512: GO 59516
// end ; end ;
59514: GO 59453
59516: POP
59517: POP
// end ; end ;
59518: GO 59301
59520: POP
59521: POP
// if result and not asc then
59522: LD_VAR 0 5
59526: PUSH
59527: LD_VAR 0 3
59531: NOT
59532: AND
59533: IFFALSE 59550
// result := ReverseArray ( result ) ;
59535: LD_ADDR_VAR 0 5
59539: PUSH
59540: LD_VAR 0 5
59544: PPUSH
59545: CALL 86790 0 1
59549: ST_TO_ADDR
// tmp := [ ] ;
59550: LD_ADDR_VAR 0 8
59554: PUSH
59555: EMPTY
59556: ST_TO_ADDR
// if mode then
59557: LD_VAR 0 4
59561: IFFALSE 59625
// begin for i := 1 to result do
59563: LD_ADDR_VAR 0 6
59567: PUSH
59568: DOUBLE
59569: LD_INT 1
59571: DEC
59572: ST_TO_ADDR
59573: LD_VAR 0 5
59577: PUSH
59578: FOR_TO
59579: IFFALSE 59613
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
59581: LD_ADDR_VAR 0 8
59585: PUSH
59586: LD_VAR 0 8
59590: PPUSH
59591: LD_VAR 0 5
59595: PUSH
59596: LD_VAR 0 6
59600: ARRAY
59601: PUSH
59602: LD_INT 1
59604: ARRAY
59605: PPUSH
59606: CALL 91523 0 2
59610: ST_TO_ADDR
59611: GO 59578
59613: POP
59614: POP
// result := tmp ;
59615: LD_ADDR_VAR 0 5
59619: PUSH
59620: LD_VAR 0 8
59624: ST_TO_ADDR
// end ; end ;
59625: LD_VAR 0 5
59629: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
59630: LD_INT 0
59632: PPUSH
59633: PPUSH
59634: PPUSH
59635: PPUSH
// if not list then
59636: LD_VAR 0 3
59640: NOT
59641: IFFALSE 59645
// exit ;
59643: GO 60033
// result := [ ] ;
59645: LD_ADDR_VAR 0 6
59649: PUSH
59650: EMPTY
59651: ST_TO_ADDR
// for i in list do
59652: LD_ADDR_VAR 0 7
59656: PUSH
59657: LD_VAR 0 3
59661: PUSH
59662: FOR_IN
59663: IFFALSE 59865
// begin tmp := GetDistUnitXY ( i , x , y ) ;
59665: LD_ADDR_VAR 0 9
59669: PUSH
59670: LD_VAR 0 7
59674: PPUSH
59675: LD_VAR 0 1
59679: PPUSH
59680: LD_VAR 0 2
59684: PPUSH
59685: CALL_OW 297
59689: ST_TO_ADDR
// if not result then
59690: LD_VAR 0 6
59694: NOT
59695: IFFALSE 59721
// result := [ [ i , tmp ] ] else
59697: LD_ADDR_VAR 0 6
59701: PUSH
59702: LD_VAR 0 7
59706: PUSH
59707: LD_VAR 0 9
59711: PUSH
59712: EMPTY
59713: LIST
59714: LIST
59715: PUSH
59716: EMPTY
59717: LIST
59718: ST_TO_ADDR
59719: GO 59863
// begin if result [ result ] [ 2 ] <= tmp then
59721: LD_VAR 0 6
59725: PUSH
59726: LD_VAR 0 6
59730: ARRAY
59731: PUSH
59732: LD_INT 2
59734: ARRAY
59735: PUSH
59736: LD_VAR 0 9
59740: LESSEQUAL
59741: IFFALSE 59783
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
59743: LD_ADDR_VAR 0 6
59747: PUSH
59748: LD_VAR 0 6
59752: PPUSH
59753: LD_VAR 0 6
59757: PUSH
59758: LD_INT 1
59760: PLUS
59761: PPUSH
59762: LD_VAR 0 7
59766: PUSH
59767: LD_VAR 0 9
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: PPUSH
59776: CALL_OW 2
59780: ST_TO_ADDR
59781: GO 59863
// for j := 1 to result do
59783: LD_ADDR_VAR 0 8
59787: PUSH
59788: DOUBLE
59789: LD_INT 1
59791: DEC
59792: ST_TO_ADDR
59793: LD_VAR 0 6
59797: PUSH
59798: FOR_TO
59799: IFFALSE 59861
// begin if tmp < result [ j ] [ 2 ] then
59801: LD_VAR 0 9
59805: PUSH
59806: LD_VAR 0 6
59810: PUSH
59811: LD_VAR 0 8
59815: ARRAY
59816: PUSH
59817: LD_INT 2
59819: ARRAY
59820: LESS
59821: IFFALSE 59859
// begin result := Insert ( result , j , [ i , tmp ] ) ;
59823: LD_ADDR_VAR 0 6
59827: PUSH
59828: LD_VAR 0 6
59832: PPUSH
59833: LD_VAR 0 8
59837: PPUSH
59838: LD_VAR 0 7
59842: PUSH
59843: LD_VAR 0 9
59847: PUSH
59848: EMPTY
59849: LIST
59850: LIST
59851: PPUSH
59852: CALL_OW 2
59856: ST_TO_ADDR
// break ;
59857: GO 59861
// end ; end ;
59859: GO 59798
59861: POP
59862: POP
// end ; end ;
59863: GO 59662
59865: POP
59866: POP
// if result and not asc then
59867: LD_VAR 0 6
59871: PUSH
59872: LD_VAR 0 4
59876: NOT
59877: AND
59878: IFFALSE 59953
// begin tmp := result ;
59880: LD_ADDR_VAR 0 9
59884: PUSH
59885: LD_VAR 0 6
59889: ST_TO_ADDR
// for i = tmp downto 1 do
59890: LD_ADDR_VAR 0 7
59894: PUSH
59895: DOUBLE
59896: LD_VAR 0 9
59900: INC
59901: ST_TO_ADDR
59902: LD_INT 1
59904: PUSH
59905: FOR_DOWNTO
59906: IFFALSE 59951
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
59908: LD_ADDR_VAR 0 6
59912: PUSH
59913: LD_VAR 0 6
59917: PPUSH
59918: LD_VAR 0 9
59922: PUSH
59923: LD_VAR 0 7
59927: MINUS
59928: PUSH
59929: LD_INT 1
59931: PLUS
59932: PPUSH
59933: LD_VAR 0 9
59937: PUSH
59938: LD_VAR 0 7
59942: ARRAY
59943: PPUSH
59944: CALL_OW 1
59948: ST_TO_ADDR
59949: GO 59905
59951: POP
59952: POP
// end ; tmp := [ ] ;
59953: LD_ADDR_VAR 0 9
59957: PUSH
59958: EMPTY
59959: ST_TO_ADDR
// if mode then
59960: LD_VAR 0 5
59964: IFFALSE 60033
// begin for i = 1 to result do
59966: LD_ADDR_VAR 0 7
59970: PUSH
59971: DOUBLE
59972: LD_INT 1
59974: DEC
59975: ST_TO_ADDR
59976: LD_VAR 0 6
59980: PUSH
59981: FOR_TO
59982: IFFALSE 60021
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
59984: LD_ADDR_VAR 0 9
59988: PUSH
59989: LD_VAR 0 9
59993: PPUSH
59994: LD_VAR 0 7
59998: PPUSH
59999: LD_VAR 0 6
60003: PUSH
60004: LD_VAR 0 7
60008: ARRAY
60009: PUSH
60010: LD_INT 1
60012: ARRAY
60013: PPUSH
60014: CALL_OW 1
60018: ST_TO_ADDR
60019: GO 59981
60021: POP
60022: POP
// result := tmp ;
60023: LD_ADDR_VAR 0 6
60027: PUSH
60028: LD_VAR 0 9
60032: ST_TO_ADDR
// end ; end ;
60033: LD_VAR 0 6
60037: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
60038: LD_INT 0
60040: PPUSH
60041: PPUSH
60042: PPUSH
60043: PPUSH
60044: PPUSH
60045: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
60046: LD_ADDR_VAR 0 5
60050: PUSH
60051: LD_INT 0
60053: PUSH
60054: LD_INT 0
60056: PUSH
60057: LD_INT 0
60059: PUSH
60060: EMPTY
60061: PUSH
60062: EMPTY
60063: LIST
60064: LIST
60065: LIST
60066: LIST
60067: ST_TO_ADDR
// if not x or not y then
60068: LD_VAR 0 2
60072: NOT
60073: PUSH
60074: LD_VAR 0 3
60078: NOT
60079: OR
60080: IFFALSE 60084
// exit ;
60082: GO 61734
// if not range then
60084: LD_VAR 0 4
60088: NOT
60089: IFFALSE 60099
// range := 10 ;
60091: LD_ADDR_VAR 0 4
60095: PUSH
60096: LD_INT 10
60098: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
60099: LD_ADDR_VAR 0 8
60103: PUSH
60104: LD_INT 81
60106: PUSH
60107: LD_VAR 0 1
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: PUSH
60116: LD_INT 92
60118: PUSH
60119: LD_VAR 0 2
60123: PUSH
60124: LD_VAR 0 3
60128: PUSH
60129: LD_VAR 0 4
60133: PUSH
60134: EMPTY
60135: LIST
60136: LIST
60137: LIST
60138: LIST
60139: PUSH
60140: LD_INT 3
60142: PUSH
60143: LD_INT 21
60145: PUSH
60146: LD_INT 3
60148: PUSH
60149: EMPTY
60150: LIST
60151: LIST
60152: PUSH
60153: EMPTY
60154: LIST
60155: LIST
60156: PUSH
60157: EMPTY
60158: LIST
60159: LIST
60160: LIST
60161: PPUSH
60162: CALL_OW 69
60166: ST_TO_ADDR
// if not tmp then
60167: LD_VAR 0 8
60171: NOT
60172: IFFALSE 60176
// exit ;
60174: GO 61734
// for i in tmp do
60176: LD_ADDR_VAR 0 6
60180: PUSH
60181: LD_VAR 0 8
60185: PUSH
60186: FOR_IN
60187: IFFALSE 61709
// begin points := [ 0 , 0 , 0 ] ;
60189: LD_ADDR_VAR 0 9
60193: PUSH
60194: LD_INT 0
60196: PUSH
60197: LD_INT 0
60199: PUSH
60200: LD_INT 0
60202: PUSH
60203: EMPTY
60204: LIST
60205: LIST
60206: LIST
60207: ST_TO_ADDR
// bpoints := 1 ;
60208: LD_ADDR_VAR 0 10
60212: PUSH
60213: LD_INT 1
60215: ST_TO_ADDR
// case GetType ( i ) of unit_human :
60216: LD_VAR 0 6
60220: PPUSH
60221: CALL_OW 247
60225: PUSH
60226: LD_INT 1
60228: DOUBLE
60229: EQUAL
60230: IFTRUE 60234
60232: GO 60812
60234: POP
// begin if GetClass ( i ) = 1 then
60235: LD_VAR 0 6
60239: PPUSH
60240: CALL_OW 257
60244: PUSH
60245: LD_INT 1
60247: EQUAL
60248: IFFALSE 60269
// points := [ 10 , 5 , 3 ] ;
60250: LD_ADDR_VAR 0 9
60254: PUSH
60255: LD_INT 10
60257: PUSH
60258: LD_INT 5
60260: PUSH
60261: LD_INT 3
60263: PUSH
60264: EMPTY
60265: LIST
60266: LIST
60267: LIST
60268: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
60269: LD_VAR 0 6
60273: PPUSH
60274: CALL_OW 257
60278: PUSH
60279: LD_INT 2
60281: PUSH
60282: LD_INT 3
60284: PUSH
60285: LD_INT 4
60287: PUSH
60288: EMPTY
60289: LIST
60290: LIST
60291: LIST
60292: IN
60293: IFFALSE 60314
// points := [ 3 , 2 , 1 ] ;
60295: LD_ADDR_VAR 0 9
60299: PUSH
60300: LD_INT 3
60302: PUSH
60303: LD_INT 2
60305: PUSH
60306: LD_INT 1
60308: PUSH
60309: EMPTY
60310: LIST
60311: LIST
60312: LIST
60313: ST_TO_ADDR
// if GetClass ( i ) = 5 then
60314: LD_VAR 0 6
60318: PPUSH
60319: CALL_OW 257
60323: PUSH
60324: LD_INT 5
60326: EQUAL
60327: IFFALSE 60348
// points := [ 130 , 5 , 2 ] ;
60329: LD_ADDR_VAR 0 9
60333: PUSH
60334: LD_INT 130
60336: PUSH
60337: LD_INT 5
60339: PUSH
60340: LD_INT 2
60342: PUSH
60343: EMPTY
60344: LIST
60345: LIST
60346: LIST
60347: ST_TO_ADDR
// if GetClass ( i ) = 8 then
60348: LD_VAR 0 6
60352: PPUSH
60353: CALL_OW 257
60357: PUSH
60358: LD_INT 8
60360: EQUAL
60361: IFFALSE 60382
// points := [ 35 , 35 , 30 ] ;
60363: LD_ADDR_VAR 0 9
60367: PUSH
60368: LD_INT 35
60370: PUSH
60371: LD_INT 35
60373: PUSH
60374: LD_INT 30
60376: PUSH
60377: EMPTY
60378: LIST
60379: LIST
60380: LIST
60381: ST_TO_ADDR
// if GetClass ( i ) = 9 then
60382: LD_VAR 0 6
60386: PPUSH
60387: CALL_OW 257
60391: PUSH
60392: LD_INT 9
60394: EQUAL
60395: IFFALSE 60416
// points := [ 20 , 55 , 40 ] ;
60397: LD_ADDR_VAR 0 9
60401: PUSH
60402: LD_INT 20
60404: PUSH
60405: LD_INT 55
60407: PUSH
60408: LD_INT 40
60410: PUSH
60411: EMPTY
60412: LIST
60413: LIST
60414: LIST
60415: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
60416: LD_VAR 0 6
60420: PPUSH
60421: CALL_OW 257
60425: PUSH
60426: LD_INT 12
60428: PUSH
60429: LD_INT 16
60431: PUSH
60432: EMPTY
60433: LIST
60434: LIST
60435: IN
60436: IFFALSE 60457
// points := [ 5 , 3 , 2 ] ;
60438: LD_ADDR_VAR 0 9
60442: PUSH
60443: LD_INT 5
60445: PUSH
60446: LD_INT 3
60448: PUSH
60449: LD_INT 2
60451: PUSH
60452: EMPTY
60453: LIST
60454: LIST
60455: LIST
60456: ST_TO_ADDR
// if GetClass ( i ) = 17 then
60457: LD_VAR 0 6
60461: PPUSH
60462: CALL_OW 257
60466: PUSH
60467: LD_INT 17
60469: EQUAL
60470: IFFALSE 60491
// points := [ 100 , 50 , 75 ] ;
60472: LD_ADDR_VAR 0 9
60476: PUSH
60477: LD_INT 100
60479: PUSH
60480: LD_INT 50
60482: PUSH
60483: LD_INT 75
60485: PUSH
60486: EMPTY
60487: LIST
60488: LIST
60489: LIST
60490: ST_TO_ADDR
// if GetClass ( i ) = 15 then
60491: LD_VAR 0 6
60495: PPUSH
60496: CALL_OW 257
60500: PUSH
60501: LD_INT 15
60503: EQUAL
60504: IFFALSE 60525
// points := [ 10 , 5 , 3 ] ;
60506: LD_ADDR_VAR 0 9
60510: PUSH
60511: LD_INT 10
60513: PUSH
60514: LD_INT 5
60516: PUSH
60517: LD_INT 3
60519: PUSH
60520: EMPTY
60521: LIST
60522: LIST
60523: LIST
60524: ST_TO_ADDR
// if GetClass ( i ) = 14 then
60525: LD_VAR 0 6
60529: PPUSH
60530: CALL_OW 257
60534: PUSH
60535: LD_INT 14
60537: EQUAL
60538: IFFALSE 60559
// points := [ 10 , 0 , 0 ] ;
60540: LD_ADDR_VAR 0 9
60544: PUSH
60545: LD_INT 10
60547: PUSH
60548: LD_INT 0
60550: PUSH
60551: LD_INT 0
60553: PUSH
60554: EMPTY
60555: LIST
60556: LIST
60557: LIST
60558: ST_TO_ADDR
// if GetClass ( i ) = 11 then
60559: LD_VAR 0 6
60563: PPUSH
60564: CALL_OW 257
60568: PUSH
60569: LD_INT 11
60571: EQUAL
60572: IFFALSE 60593
// points := [ 30 , 10 , 5 ] ;
60574: LD_ADDR_VAR 0 9
60578: PUSH
60579: LD_INT 30
60581: PUSH
60582: LD_INT 10
60584: PUSH
60585: LD_INT 5
60587: PUSH
60588: EMPTY
60589: LIST
60590: LIST
60591: LIST
60592: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
60593: LD_VAR 0 1
60597: PPUSH
60598: LD_INT 5
60600: PPUSH
60601: CALL_OW 321
60605: PUSH
60606: LD_INT 2
60608: EQUAL
60609: IFFALSE 60626
// bpoints := bpoints * 1.8 ;
60611: LD_ADDR_VAR 0 10
60615: PUSH
60616: LD_VAR 0 10
60620: PUSH
60621: LD_REAL  1.80000000000000E+0000
60624: MUL
60625: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
60626: LD_VAR 0 6
60630: PPUSH
60631: CALL_OW 257
60635: PUSH
60636: LD_INT 1
60638: PUSH
60639: LD_INT 2
60641: PUSH
60642: LD_INT 3
60644: PUSH
60645: LD_INT 4
60647: PUSH
60648: EMPTY
60649: LIST
60650: LIST
60651: LIST
60652: LIST
60653: IN
60654: PUSH
60655: LD_VAR 0 1
60659: PPUSH
60660: LD_INT 51
60662: PPUSH
60663: CALL_OW 321
60667: PUSH
60668: LD_INT 2
60670: EQUAL
60671: AND
60672: IFFALSE 60689
// bpoints := bpoints * 1.2 ;
60674: LD_ADDR_VAR 0 10
60678: PUSH
60679: LD_VAR 0 10
60683: PUSH
60684: LD_REAL  1.20000000000000E+0000
60687: MUL
60688: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
60689: LD_VAR 0 6
60693: PPUSH
60694: CALL_OW 257
60698: PUSH
60699: LD_INT 5
60701: PUSH
60702: LD_INT 7
60704: PUSH
60705: LD_INT 9
60707: PUSH
60708: EMPTY
60709: LIST
60710: LIST
60711: LIST
60712: IN
60713: PUSH
60714: LD_VAR 0 1
60718: PPUSH
60719: LD_INT 52
60721: PPUSH
60722: CALL_OW 321
60726: PUSH
60727: LD_INT 2
60729: EQUAL
60730: AND
60731: IFFALSE 60748
// bpoints := bpoints * 1.5 ;
60733: LD_ADDR_VAR 0 10
60737: PUSH
60738: LD_VAR 0 10
60742: PUSH
60743: LD_REAL  1.50000000000000E+0000
60746: MUL
60747: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
60748: LD_VAR 0 1
60752: PPUSH
60753: LD_INT 66
60755: PPUSH
60756: CALL_OW 321
60760: PUSH
60761: LD_INT 2
60763: EQUAL
60764: IFFALSE 60781
// bpoints := bpoints * 1.1 ;
60766: LD_ADDR_VAR 0 10
60770: PUSH
60771: LD_VAR 0 10
60775: PUSH
60776: LD_REAL  1.10000000000000E+0000
60779: MUL
60780: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
60781: LD_ADDR_VAR 0 10
60785: PUSH
60786: LD_VAR 0 10
60790: PUSH
60791: LD_VAR 0 6
60795: PPUSH
60796: LD_INT 1
60798: PPUSH
60799: CALL_OW 259
60803: PUSH
60804: LD_REAL  1.15000000000000E+0000
60807: MUL
60808: MUL
60809: ST_TO_ADDR
// end ; unit_vehicle :
60810: GO 61638
60812: LD_INT 2
60814: DOUBLE
60815: EQUAL
60816: IFTRUE 60820
60818: GO 61626
60820: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
60821: LD_VAR 0 6
60825: PPUSH
60826: CALL_OW 264
60830: PUSH
60831: LD_INT 2
60833: PUSH
60834: LD_INT 42
60836: PUSH
60837: LD_INT 24
60839: PUSH
60840: EMPTY
60841: LIST
60842: LIST
60843: LIST
60844: IN
60845: IFFALSE 60866
// points := [ 25 , 5 , 3 ] ;
60847: LD_ADDR_VAR 0 9
60851: PUSH
60852: LD_INT 25
60854: PUSH
60855: LD_INT 5
60857: PUSH
60858: LD_INT 3
60860: PUSH
60861: EMPTY
60862: LIST
60863: LIST
60864: LIST
60865: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
60866: LD_VAR 0 6
60870: PPUSH
60871: CALL_OW 264
60875: PUSH
60876: LD_INT 4
60878: PUSH
60879: LD_INT 43
60881: PUSH
60882: LD_INT 25
60884: PUSH
60885: EMPTY
60886: LIST
60887: LIST
60888: LIST
60889: IN
60890: IFFALSE 60911
// points := [ 40 , 15 , 5 ] ;
60892: LD_ADDR_VAR 0 9
60896: PUSH
60897: LD_INT 40
60899: PUSH
60900: LD_INT 15
60902: PUSH
60903: LD_INT 5
60905: PUSH
60906: EMPTY
60907: LIST
60908: LIST
60909: LIST
60910: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
60911: LD_VAR 0 6
60915: PPUSH
60916: CALL_OW 264
60920: PUSH
60921: LD_INT 3
60923: PUSH
60924: LD_INT 23
60926: PUSH
60927: EMPTY
60928: LIST
60929: LIST
60930: IN
60931: IFFALSE 60952
// points := [ 7 , 25 , 8 ] ;
60933: LD_ADDR_VAR 0 9
60937: PUSH
60938: LD_INT 7
60940: PUSH
60941: LD_INT 25
60943: PUSH
60944: LD_INT 8
60946: PUSH
60947: EMPTY
60948: LIST
60949: LIST
60950: LIST
60951: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
60952: LD_VAR 0 6
60956: PPUSH
60957: CALL_OW 264
60961: PUSH
60962: LD_INT 5
60964: PUSH
60965: LD_INT 27
60967: PUSH
60968: LD_INT 44
60970: PUSH
60971: EMPTY
60972: LIST
60973: LIST
60974: LIST
60975: IN
60976: IFFALSE 60997
// points := [ 14 , 50 , 16 ] ;
60978: LD_ADDR_VAR 0 9
60982: PUSH
60983: LD_INT 14
60985: PUSH
60986: LD_INT 50
60988: PUSH
60989: LD_INT 16
60991: PUSH
60992: EMPTY
60993: LIST
60994: LIST
60995: LIST
60996: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
60997: LD_VAR 0 6
61001: PPUSH
61002: CALL_OW 264
61006: PUSH
61007: LD_INT 6
61009: PUSH
61010: LD_INT 46
61012: PUSH
61013: EMPTY
61014: LIST
61015: LIST
61016: IN
61017: IFFALSE 61038
// points := [ 32 , 120 , 70 ] ;
61019: LD_ADDR_VAR 0 9
61023: PUSH
61024: LD_INT 32
61026: PUSH
61027: LD_INT 120
61029: PUSH
61030: LD_INT 70
61032: PUSH
61033: EMPTY
61034: LIST
61035: LIST
61036: LIST
61037: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
61038: LD_VAR 0 6
61042: PPUSH
61043: CALL_OW 264
61047: PUSH
61048: LD_INT 7
61050: PUSH
61051: LD_INT 28
61053: PUSH
61054: LD_INT 45
61056: PUSH
61057: LD_INT 92
61059: PUSH
61060: EMPTY
61061: LIST
61062: LIST
61063: LIST
61064: LIST
61065: IN
61066: IFFALSE 61087
// points := [ 35 , 20 , 45 ] ;
61068: LD_ADDR_VAR 0 9
61072: PUSH
61073: LD_INT 35
61075: PUSH
61076: LD_INT 20
61078: PUSH
61079: LD_INT 45
61081: PUSH
61082: EMPTY
61083: LIST
61084: LIST
61085: LIST
61086: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
61087: LD_VAR 0 6
61091: PPUSH
61092: CALL_OW 264
61096: PUSH
61097: LD_INT 47
61099: PUSH
61100: EMPTY
61101: LIST
61102: IN
61103: IFFALSE 61124
// points := [ 67 , 45 , 75 ] ;
61105: LD_ADDR_VAR 0 9
61109: PUSH
61110: LD_INT 67
61112: PUSH
61113: LD_INT 45
61115: PUSH
61116: LD_INT 75
61118: PUSH
61119: EMPTY
61120: LIST
61121: LIST
61122: LIST
61123: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
61124: LD_VAR 0 6
61128: PPUSH
61129: CALL_OW 264
61133: PUSH
61134: LD_INT 26
61136: PUSH
61137: EMPTY
61138: LIST
61139: IN
61140: IFFALSE 61161
// points := [ 120 , 30 , 80 ] ;
61142: LD_ADDR_VAR 0 9
61146: PUSH
61147: LD_INT 120
61149: PUSH
61150: LD_INT 30
61152: PUSH
61153: LD_INT 80
61155: PUSH
61156: EMPTY
61157: LIST
61158: LIST
61159: LIST
61160: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
61161: LD_VAR 0 6
61165: PPUSH
61166: CALL_OW 264
61170: PUSH
61171: LD_INT 22
61173: PUSH
61174: EMPTY
61175: LIST
61176: IN
61177: IFFALSE 61198
// points := [ 40 , 1 , 1 ] ;
61179: LD_ADDR_VAR 0 9
61183: PUSH
61184: LD_INT 40
61186: PUSH
61187: LD_INT 1
61189: PUSH
61190: LD_INT 1
61192: PUSH
61193: EMPTY
61194: LIST
61195: LIST
61196: LIST
61197: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
61198: LD_VAR 0 6
61202: PPUSH
61203: CALL_OW 264
61207: PUSH
61208: LD_INT 29
61210: PUSH
61211: EMPTY
61212: LIST
61213: IN
61214: IFFALSE 61235
// points := [ 70 , 200 , 400 ] ;
61216: LD_ADDR_VAR 0 9
61220: PUSH
61221: LD_INT 70
61223: PUSH
61224: LD_INT 200
61226: PUSH
61227: LD_INT 400
61229: PUSH
61230: EMPTY
61231: LIST
61232: LIST
61233: LIST
61234: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
61235: LD_VAR 0 6
61239: PPUSH
61240: CALL_OW 264
61244: PUSH
61245: LD_INT 14
61247: PUSH
61248: LD_INT 53
61250: PUSH
61251: EMPTY
61252: LIST
61253: LIST
61254: IN
61255: IFFALSE 61276
// points := [ 40 , 10 , 20 ] ;
61257: LD_ADDR_VAR 0 9
61261: PUSH
61262: LD_INT 40
61264: PUSH
61265: LD_INT 10
61267: PUSH
61268: LD_INT 20
61270: PUSH
61271: EMPTY
61272: LIST
61273: LIST
61274: LIST
61275: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
61276: LD_VAR 0 6
61280: PPUSH
61281: CALL_OW 264
61285: PUSH
61286: LD_INT 9
61288: PUSH
61289: EMPTY
61290: LIST
61291: IN
61292: IFFALSE 61313
// points := [ 5 , 70 , 20 ] ;
61294: LD_ADDR_VAR 0 9
61298: PUSH
61299: LD_INT 5
61301: PUSH
61302: LD_INT 70
61304: PUSH
61305: LD_INT 20
61307: PUSH
61308: EMPTY
61309: LIST
61310: LIST
61311: LIST
61312: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
61313: LD_VAR 0 6
61317: PPUSH
61318: CALL_OW 264
61322: PUSH
61323: LD_INT 10
61325: PUSH
61326: EMPTY
61327: LIST
61328: IN
61329: IFFALSE 61350
// points := [ 35 , 110 , 70 ] ;
61331: LD_ADDR_VAR 0 9
61335: PUSH
61336: LD_INT 35
61338: PUSH
61339: LD_INT 110
61341: PUSH
61342: LD_INT 70
61344: PUSH
61345: EMPTY
61346: LIST
61347: LIST
61348: LIST
61349: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
61350: LD_VAR 0 6
61354: PPUSH
61355: CALL_OW 265
61359: PUSH
61360: LD_INT 25
61362: EQUAL
61363: IFFALSE 61384
// points := [ 80 , 65 , 100 ] ;
61365: LD_ADDR_VAR 0 9
61369: PUSH
61370: LD_INT 80
61372: PUSH
61373: LD_INT 65
61375: PUSH
61376: LD_INT 100
61378: PUSH
61379: EMPTY
61380: LIST
61381: LIST
61382: LIST
61383: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
61384: LD_VAR 0 6
61388: PPUSH
61389: CALL_OW 263
61393: PUSH
61394: LD_INT 1
61396: EQUAL
61397: IFFALSE 61432
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
61399: LD_ADDR_VAR 0 10
61403: PUSH
61404: LD_VAR 0 10
61408: PUSH
61409: LD_VAR 0 6
61413: PPUSH
61414: CALL_OW 311
61418: PPUSH
61419: LD_INT 3
61421: PPUSH
61422: CALL_OW 259
61426: PUSH
61427: LD_INT 4
61429: MUL
61430: MUL
61431: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
61432: LD_VAR 0 6
61436: PPUSH
61437: CALL_OW 263
61441: PUSH
61442: LD_INT 2
61444: EQUAL
61445: IFFALSE 61496
// begin j := IsControledBy ( i ) ;
61447: LD_ADDR_VAR 0 7
61451: PUSH
61452: LD_VAR 0 6
61456: PPUSH
61457: CALL_OW 312
61461: ST_TO_ADDR
// if j then
61462: LD_VAR 0 7
61466: IFFALSE 61496
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
61468: LD_ADDR_VAR 0 10
61472: PUSH
61473: LD_VAR 0 10
61477: PUSH
61478: LD_VAR 0 7
61482: PPUSH
61483: LD_INT 3
61485: PPUSH
61486: CALL_OW 259
61490: PUSH
61491: LD_INT 3
61493: MUL
61494: MUL
61495: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
61496: LD_VAR 0 6
61500: PPUSH
61501: CALL_OW 264
61505: PUSH
61506: LD_INT 5
61508: PUSH
61509: LD_INT 6
61511: PUSH
61512: LD_INT 46
61514: PUSH
61515: LD_INT 44
61517: PUSH
61518: LD_INT 47
61520: PUSH
61521: LD_INT 45
61523: PUSH
61524: LD_INT 28
61526: PUSH
61527: LD_INT 7
61529: PUSH
61530: LD_INT 27
61532: PUSH
61533: LD_INT 29
61535: PUSH
61536: EMPTY
61537: LIST
61538: LIST
61539: LIST
61540: LIST
61541: LIST
61542: LIST
61543: LIST
61544: LIST
61545: LIST
61546: LIST
61547: IN
61548: PUSH
61549: LD_VAR 0 1
61553: PPUSH
61554: LD_INT 52
61556: PPUSH
61557: CALL_OW 321
61561: PUSH
61562: LD_INT 2
61564: EQUAL
61565: AND
61566: IFFALSE 61583
// bpoints := bpoints * 1.2 ;
61568: LD_ADDR_VAR 0 10
61572: PUSH
61573: LD_VAR 0 10
61577: PUSH
61578: LD_REAL  1.20000000000000E+0000
61581: MUL
61582: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
61583: LD_VAR 0 6
61587: PPUSH
61588: CALL_OW 264
61592: PUSH
61593: LD_INT 6
61595: PUSH
61596: LD_INT 46
61598: PUSH
61599: LD_INT 47
61601: PUSH
61602: EMPTY
61603: LIST
61604: LIST
61605: LIST
61606: IN
61607: IFFALSE 61624
// bpoints := bpoints * 1.2 ;
61609: LD_ADDR_VAR 0 10
61613: PUSH
61614: LD_VAR 0 10
61618: PUSH
61619: LD_REAL  1.20000000000000E+0000
61622: MUL
61623: ST_TO_ADDR
// end ; unit_building :
61624: GO 61638
61626: LD_INT 3
61628: DOUBLE
61629: EQUAL
61630: IFTRUE 61634
61632: GO 61637
61634: POP
// ; end ;
61635: GO 61638
61637: POP
// for j = 1 to 3 do
61638: LD_ADDR_VAR 0 7
61642: PUSH
61643: DOUBLE
61644: LD_INT 1
61646: DEC
61647: ST_TO_ADDR
61648: LD_INT 3
61650: PUSH
61651: FOR_TO
61652: IFFALSE 61705
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
61654: LD_ADDR_VAR 0 5
61658: PUSH
61659: LD_VAR 0 5
61663: PPUSH
61664: LD_VAR 0 7
61668: PPUSH
61669: LD_VAR 0 5
61673: PUSH
61674: LD_VAR 0 7
61678: ARRAY
61679: PUSH
61680: LD_VAR 0 9
61684: PUSH
61685: LD_VAR 0 7
61689: ARRAY
61690: PUSH
61691: LD_VAR 0 10
61695: MUL
61696: PLUS
61697: PPUSH
61698: CALL_OW 1
61702: ST_TO_ADDR
61703: GO 61651
61705: POP
61706: POP
// end ;
61707: GO 60186
61709: POP
61710: POP
// result := Replace ( result , 4 , tmp ) ;
61711: LD_ADDR_VAR 0 5
61715: PUSH
61716: LD_VAR 0 5
61720: PPUSH
61721: LD_INT 4
61723: PPUSH
61724: LD_VAR 0 8
61728: PPUSH
61729: CALL_OW 1
61733: ST_TO_ADDR
// end ;
61734: LD_VAR 0 5
61738: RET
// export function DangerAtRange ( unit , range ) ; begin
61739: LD_INT 0
61741: PPUSH
// if not unit then
61742: LD_VAR 0 1
61746: NOT
61747: IFFALSE 61751
// exit ;
61749: GO 61796
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
61751: LD_ADDR_VAR 0 3
61755: PUSH
61756: LD_VAR 0 1
61760: PPUSH
61761: CALL_OW 255
61765: PPUSH
61766: LD_VAR 0 1
61770: PPUSH
61771: CALL_OW 250
61775: PPUSH
61776: LD_VAR 0 1
61780: PPUSH
61781: CALL_OW 251
61785: PPUSH
61786: LD_VAR 0 2
61790: PPUSH
61791: CALL 60038 0 4
61795: ST_TO_ADDR
// end ;
61796: LD_VAR 0 3
61800: RET
// export function DangerInArea ( side , area ) ; begin
61801: LD_INT 0
61803: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
61804: LD_ADDR_VAR 0 3
61808: PUSH
61809: LD_VAR 0 2
61813: PPUSH
61814: LD_INT 81
61816: PUSH
61817: LD_VAR 0 1
61821: PUSH
61822: EMPTY
61823: LIST
61824: LIST
61825: PPUSH
61826: CALL_OW 70
61830: ST_TO_ADDR
// end ;
61831: LD_VAR 0 3
61835: RET
// export function IsExtension ( b ) ; begin
61836: LD_INT 0
61838: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
61839: LD_ADDR_VAR 0 2
61843: PUSH
61844: LD_VAR 0 1
61848: PUSH
61849: LD_INT 23
61851: PUSH
61852: LD_INT 20
61854: PUSH
61855: LD_INT 22
61857: PUSH
61858: LD_INT 17
61860: PUSH
61861: LD_INT 24
61863: PUSH
61864: LD_INT 21
61866: PUSH
61867: LD_INT 19
61869: PUSH
61870: LD_INT 16
61872: PUSH
61873: LD_INT 25
61875: PUSH
61876: LD_INT 18
61878: PUSH
61879: EMPTY
61880: LIST
61881: LIST
61882: LIST
61883: LIST
61884: LIST
61885: LIST
61886: LIST
61887: LIST
61888: LIST
61889: LIST
61890: IN
61891: ST_TO_ADDR
// end ;
61892: LD_VAR 0 2
61896: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
61897: LD_INT 0
61899: PPUSH
61900: PPUSH
61901: PPUSH
// result := [ ] ;
61902: LD_ADDR_VAR 0 4
61906: PUSH
61907: EMPTY
61908: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
61909: LD_ADDR_VAR 0 5
61913: PUSH
61914: LD_VAR 0 2
61918: PPUSH
61919: LD_INT 21
61921: PUSH
61922: LD_INT 3
61924: PUSH
61925: EMPTY
61926: LIST
61927: LIST
61928: PPUSH
61929: CALL_OW 70
61933: ST_TO_ADDR
// if not tmp then
61934: LD_VAR 0 5
61938: NOT
61939: IFFALSE 61943
// exit ;
61941: GO 62007
// if checkLink then
61943: LD_VAR 0 3
61947: IFFALSE 61997
// begin for i in tmp do
61949: LD_ADDR_VAR 0 6
61953: PUSH
61954: LD_VAR 0 5
61958: PUSH
61959: FOR_IN
61960: IFFALSE 61995
// if GetBase ( i ) <> base then
61962: LD_VAR 0 6
61966: PPUSH
61967: CALL_OW 274
61971: PUSH
61972: LD_VAR 0 1
61976: NONEQUAL
61977: IFFALSE 61993
// ComLinkToBase ( base , i ) ;
61979: LD_VAR 0 1
61983: PPUSH
61984: LD_VAR 0 6
61988: PPUSH
61989: CALL_OW 169
61993: GO 61959
61995: POP
61996: POP
// end ; result := tmp ;
61997: LD_ADDR_VAR 0 4
62001: PUSH
62002: LD_VAR 0 5
62006: ST_TO_ADDR
// end ;
62007: LD_VAR 0 4
62011: RET
// export function ComComplete ( units , b ) ; var i ; begin
62012: LD_INT 0
62014: PPUSH
62015: PPUSH
// if not units then
62016: LD_VAR 0 1
62020: NOT
62021: IFFALSE 62025
// exit ;
62023: GO 62115
// for i in units do
62025: LD_ADDR_VAR 0 4
62029: PUSH
62030: LD_VAR 0 1
62034: PUSH
62035: FOR_IN
62036: IFFALSE 62113
// if BuildingStatus ( b ) = bs_build then
62038: LD_VAR 0 2
62042: PPUSH
62043: CALL_OW 461
62047: PUSH
62048: LD_INT 1
62050: EQUAL
62051: IFFALSE 62111
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
62053: LD_VAR 0 4
62057: PPUSH
62058: LD_STRING h
62060: PUSH
62061: LD_VAR 0 2
62065: PPUSH
62066: CALL_OW 250
62070: PUSH
62071: LD_VAR 0 2
62075: PPUSH
62076: CALL_OW 251
62080: PUSH
62081: LD_VAR 0 2
62085: PUSH
62086: LD_INT 0
62088: PUSH
62089: LD_INT 0
62091: PUSH
62092: LD_INT 0
62094: PUSH
62095: EMPTY
62096: LIST
62097: LIST
62098: LIST
62099: LIST
62100: LIST
62101: LIST
62102: LIST
62103: PUSH
62104: EMPTY
62105: LIST
62106: PPUSH
62107: CALL_OW 446
62111: GO 62035
62113: POP
62114: POP
// end ;
62115: LD_VAR 0 3
62119: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
62120: LD_INT 0
62122: PPUSH
62123: PPUSH
62124: PPUSH
62125: PPUSH
62126: PPUSH
62127: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
62128: LD_VAR 0 1
62132: NOT
62133: PUSH
62134: LD_VAR 0 1
62138: PPUSH
62139: CALL_OW 263
62143: PUSH
62144: LD_INT 2
62146: NONEQUAL
62147: OR
62148: IFFALSE 62152
// exit ;
62150: GO 62468
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
62152: LD_ADDR_VAR 0 6
62156: PUSH
62157: LD_INT 22
62159: PUSH
62160: LD_VAR 0 1
62164: PPUSH
62165: CALL_OW 255
62169: PUSH
62170: EMPTY
62171: LIST
62172: LIST
62173: PUSH
62174: LD_INT 2
62176: PUSH
62177: LD_INT 30
62179: PUSH
62180: LD_INT 36
62182: PUSH
62183: EMPTY
62184: LIST
62185: LIST
62186: PUSH
62187: LD_INT 34
62189: PUSH
62190: LD_INT 31
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: PUSH
62197: EMPTY
62198: LIST
62199: LIST
62200: LIST
62201: PUSH
62202: EMPTY
62203: LIST
62204: LIST
62205: PPUSH
62206: CALL_OW 69
62210: ST_TO_ADDR
// if not tmp then
62211: LD_VAR 0 6
62215: NOT
62216: IFFALSE 62220
// exit ;
62218: GO 62468
// result := [ ] ;
62220: LD_ADDR_VAR 0 2
62224: PUSH
62225: EMPTY
62226: ST_TO_ADDR
// for i in tmp do
62227: LD_ADDR_VAR 0 3
62231: PUSH
62232: LD_VAR 0 6
62236: PUSH
62237: FOR_IN
62238: IFFALSE 62309
// begin t := UnitsInside ( i ) ;
62240: LD_ADDR_VAR 0 4
62244: PUSH
62245: LD_VAR 0 3
62249: PPUSH
62250: CALL_OW 313
62254: ST_TO_ADDR
// if t then
62255: LD_VAR 0 4
62259: IFFALSE 62307
// for j in t do
62261: LD_ADDR_VAR 0 7
62265: PUSH
62266: LD_VAR 0 4
62270: PUSH
62271: FOR_IN
62272: IFFALSE 62305
// result := Replace ( result , result + 1 , j ) ;
62274: LD_ADDR_VAR 0 2
62278: PUSH
62279: LD_VAR 0 2
62283: PPUSH
62284: LD_VAR 0 2
62288: PUSH
62289: LD_INT 1
62291: PLUS
62292: PPUSH
62293: LD_VAR 0 7
62297: PPUSH
62298: CALL_OW 1
62302: ST_TO_ADDR
62303: GO 62271
62305: POP
62306: POP
// end ;
62307: GO 62237
62309: POP
62310: POP
// if not result then
62311: LD_VAR 0 2
62315: NOT
62316: IFFALSE 62320
// exit ;
62318: GO 62468
// mech := result [ 1 ] ;
62320: LD_ADDR_VAR 0 5
62324: PUSH
62325: LD_VAR 0 2
62329: PUSH
62330: LD_INT 1
62332: ARRAY
62333: ST_TO_ADDR
// if result > 1 then
62334: LD_VAR 0 2
62338: PUSH
62339: LD_INT 1
62341: GREATER
62342: IFFALSE 62454
// begin for i = 2 to result do
62344: LD_ADDR_VAR 0 3
62348: PUSH
62349: DOUBLE
62350: LD_INT 2
62352: DEC
62353: ST_TO_ADDR
62354: LD_VAR 0 2
62358: PUSH
62359: FOR_TO
62360: IFFALSE 62452
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
62362: LD_ADDR_VAR 0 4
62366: PUSH
62367: LD_VAR 0 2
62371: PUSH
62372: LD_VAR 0 3
62376: ARRAY
62377: PPUSH
62378: LD_INT 3
62380: PPUSH
62381: CALL_OW 259
62385: PUSH
62386: LD_VAR 0 2
62390: PUSH
62391: LD_VAR 0 3
62395: ARRAY
62396: PPUSH
62397: CALL_OW 432
62401: MINUS
62402: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
62403: LD_VAR 0 4
62407: PUSH
62408: LD_VAR 0 5
62412: PPUSH
62413: LD_INT 3
62415: PPUSH
62416: CALL_OW 259
62420: PUSH
62421: LD_VAR 0 5
62425: PPUSH
62426: CALL_OW 432
62430: MINUS
62431: GREATEREQUAL
62432: IFFALSE 62450
// mech := result [ i ] ;
62434: LD_ADDR_VAR 0 5
62438: PUSH
62439: LD_VAR 0 2
62443: PUSH
62444: LD_VAR 0 3
62448: ARRAY
62449: ST_TO_ADDR
// end ;
62450: GO 62359
62452: POP
62453: POP
// end ; ComLinkTo ( vehicle , mech ) ;
62454: LD_VAR 0 1
62458: PPUSH
62459: LD_VAR 0 5
62463: PPUSH
62464: CALL_OW 135
// end ;
62468: LD_VAR 0 2
62472: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
62473: LD_INT 0
62475: PPUSH
62476: PPUSH
62477: PPUSH
62478: PPUSH
62479: PPUSH
62480: PPUSH
62481: PPUSH
62482: PPUSH
62483: PPUSH
62484: PPUSH
62485: PPUSH
62486: PPUSH
62487: PPUSH
// result := [ ] ;
62488: LD_ADDR_VAR 0 7
62492: PUSH
62493: EMPTY
62494: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
62495: LD_VAR 0 1
62499: PPUSH
62500: CALL_OW 266
62504: PUSH
62505: LD_INT 0
62507: PUSH
62508: LD_INT 1
62510: PUSH
62511: EMPTY
62512: LIST
62513: LIST
62514: IN
62515: NOT
62516: IFFALSE 62520
// exit ;
62518: GO 64154
// if name then
62520: LD_VAR 0 3
62524: IFFALSE 62540
// SetBName ( base_dep , name ) ;
62526: LD_VAR 0 1
62530: PPUSH
62531: LD_VAR 0 3
62535: PPUSH
62536: CALL_OW 500
// base := GetBase ( base_dep ) ;
62540: LD_ADDR_VAR 0 15
62544: PUSH
62545: LD_VAR 0 1
62549: PPUSH
62550: CALL_OW 274
62554: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
62555: LD_ADDR_VAR 0 16
62559: PUSH
62560: LD_VAR 0 1
62564: PPUSH
62565: CALL_OW 255
62569: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
62570: LD_ADDR_VAR 0 17
62574: PUSH
62575: LD_VAR 0 1
62579: PPUSH
62580: CALL_OW 248
62584: ST_TO_ADDR
// if sources then
62585: LD_VAR 0 5
62589: IFFALSE 62636
// for i = 1 to 3 do
62591: LD_ADDR_VAR 0 8
62595: PUSH
62596: DOUBLE
62597: LD_INT 1
62599: DEC
62600: ST_TO_ADDR
62601: LD_INT 3
62603: PUSH
62604: FOR_TO
62605: IFFALSE 62634
// AddResourceType ( base , i , sources [ i ] ) ;
62607: LD_VAR 0 15
62611: PPUSH
62612: LD_VAR 0 8
62616: PPUSH
62617: LD_VAR 0 5
62621: PUSH
62622: LD_VAR 0 8
62626: ARRAY
62627: PPUSH
62628: CALL_OW 276
62632: GO 62604
62634: POP
62635: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
62636: LD_ADDR_VAR 0 18
62640: PUSH
62641: LD_VAR 0 15
62645: PPUSH
62646: LD_VAR 0 2
62650: PPUSH
62651: LD_INT 1
62653: PPUSH
62654: CALL 61897 0 3
62658: ST_TO_ADDR
// InitHc ;
62659: CALL_OW 19
// InitUc ;
62663: CALL_OW 18
// uc_side := side ;
62667: LD_ADDR_OWVAR 20
62671: PUSH
62672: LD_VAR 0 16
62676: ST_TO_ADDR
// uc_nation := nation ;
62677: LD_ADDR_OWVAR 21
62681: PUSH
62682: LD_VAR 0 17
62686: ST_TO_ADDR
// if buildings then
62687: LD_VAR 0 18
62691: IFFALSE 64013
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
62693: LD_ADDR_VAR 0 19
62697: PUSH
62698: LD_VAR 0 18
62702: PPUSH
62703: LD_INT 2
62705: PUSH
62706: LD_INT 30
62708: PUSH
62709: LD_INT 29
62711: PUSH
62712: EMPTY
62713: LIST
62714: LIST
62715: PUSH
62716: LD_INT 30
62718: PUSH
62719: LD_INT 30
62721: PUSH
62722: EMPTY
62723: LIST
62724: LIST
62725: PUSH
62726: EMPTY
62727: LIST
62728: LIST
62729: LIST
62730: PPUSH
62731: CALL_OW 72
62735: ST_TO_ADDR
// if tmp then
62736: LD_VAR 0 19
62740: IFFALSE 62788
// for i in tmp do
62742: LD_ADDR_VAR 0 8
62746: PUSH
62747: LD_VAR 0 19
62751: PUSH
62752: FOR_IN
62753: IFFALSE 62786
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
62755: LD_VAR 0 8
62759: PPUSH
62760: CALL_OW 250
62764: PPUSH
62765: LD_VAR 0 8
62769: PPUSH
62770: CALL_OW 251
62774: PPUSH
62775: LD_VAR 0 16
62779: PPUSH
62780: CALL_OW 441
62784: GO 62752
62786: POP
62787: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
62788: LD_VAR 0 18
62792: PPUSH
62793: LD_INT 2
62795: PUSH
62796: LD_INT 30
62798: PUSH
62799: LD_INT 32
62801: PUSH
62802: EMPTY
62803: LIST
62804: LIST
62805: PUSH
62806: LD_INT 30
62808: PUSH
62809: LD_INT 33
62811: PUSH
62812: EMPTY
62813: LIST
62814: LIST
62815: PUSH
62816: EMPTY
62817: LIST
62818: LIST
62819: LIST
62820: PPUSH
62821: CALL_OW 72
62825: IFFALSE 62913
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
62827: LD_ADDR_VAR 0 8
62831: PUSH
62832: LD_VAR 0 18
62836: PPUSH
62837: LD_INT 2
62839: PUSH
62840: LD_INT 30
62842: PUSH
62843: LD_INT 32
62845: PUSH
62846: EMPTY
62847: LIST
62848: LIST
62849: PUSH
62850: LD_INT 30
62852: PUSH
62853: LD_INT 33
62855: PUSH
62856: EMPTY
62857: LIST
62858: LIST
62859: PUSH
62860: EMPTY
62861: LIST
62862: LIST
62863: LIST
62864: PPUSH
62865: CALL_OW 72
62869: PUSH
62870: FOR_IN
62871: IFFALSE 62911
// begin if not GetBWeapon ( i ) then
62873: LD_VAR 0 8
62877: PPUSH
62878: CALL_OW 269
62882: NOT
62883: IFFALSE 62909
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
62885: LD_VAR 0 8
62889: PPUSH
62890: LD_VAR 0 8
62894: PPUSH
62895: LD_VAR 0 2
62899: PPUSH
62900: CALL 64159 0 2
62904: PPUSH
62905: CALL_OW 431
// end ;
62909: GO 62870
62911: POP
62912: POP
// end ; for i = 1 to personel do
62913: LD_ADDR_VAR 0 8
62917: PUSH
62918: DOUBLE
62919: LD_INT 1
62921: DEC
62922: ST_TO_ADDR
62923: LD_VAR 0 6
62927: PUSH
62928: FOR_TO
62929: IFFALSE 63993
// begin if i > 4 then
62931: LD_VAR 0 8
62935: PUSH
62936: LD_INT 4
62938: GREATER
62939: IFFALSE 62943
// break ;
62941: GO 63993
// case i of 1 :
62943: LD_VAR 0 8
62947: PUSH
62948: LD_INT 1
62950: DOUBLE
62951: EQUAL
62952: IFTRUE 62956
62954: GO 63036
62956: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
62957: LD_ADDR_VAR 0 12
62961: PUSH
62962: LD_VAR 0 18
62966: PPUSH
62967: LD_INT 22
62969: PUSH
62970: LD_VAR 0 16
62974: PUSH
62975: EMPTY
62976: LIST
62977: LIST
62978: PUSH
62979: LD_INT 58
62981: PUSH
62982: EMPTY
62983: LIST
62984: PUSH
62985: LD_INT 2
62987: PUSH
62988: LD_INT 30
62990: PUSH
62991: LD_INT 32
62993: PUSH
62994: EMPTY
62995: LIST
62996: LIST
62997: PUSH
62998: LD_INT 30
63000: PUSH
63001: LD_INT 4
63003: PUSH
63004: EMPTY
63005: LIST
63006: LIST
63007: PUSH
63008: LD_INT 30
63010: PUSH
63011: LD_INT 5
63013: PUSH
63014: EMPTY
63015: LIST
63016: LIST
63017: PUSH
63018: EMPTY
63019: LIST
63020: LIST
63021: LIST
63022: LIST
63023: PUSH
63024: EMPTY
63025: LIST
63026: LIST
63027: LIST
63028: PPUSH
63029: CALL_OW 72
63033: ST_TO_ADDR
63034: GO 63258
63036: LD_INT 2
63038: DOUBLE
63039: EQUAL
63040: IFTRUE 63044
63042: GO 63106
63044: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
63045: LD_ADDR_VAR 0 12
63049: PUSH
63050: LD_VAR 0 18
63054: PPUSH
63055: LD_INT 22
63057: PUSH
63058: LD_VAR 0 16
63062: PUSH
63063: EMPTY
63064: LIST
63065: LIST
63066: PUSH
63067: LD_INT 2
63069: PUSH
63070: LD_INT 30
63072: PUSH
63073: LD_INT 0
63075: PUSH
63076: EMPTY
63077: LIST
63078: LIST
63079: PUSH
63080: LD_INT 30
63082: PUSH
63083: LD_INT 1
63085: PUSH
63086: EMPTY
63087: LIST
63088: LIST
63089: PUSH
63090: EMPTY
63091: LIST
63092: LIST
63093: LIST
63094: PUSH
63095: EMPTY
63096: LIST
63097: LIST
63098: PPUSH
63099: CALL_OW 72
63103: ST_TO_ADDR
63104: GO 63258
63106: LD_INT 3
63108: DOUBLE
63109: EQUAL
63110: IFTRUE 63114
63112: GO 63176
63114: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
63115: LD_ADDR_VAR 0 12
63119: PUSH
63120: LD_VAR 0 18
63124: PPUSH
63125: LD_INT 22
63127: PUSH
63128: LD_VAR 0 16
63132: PUSH
63133: EMPTY
63134: LIST
63135: LIST
63136: PUSH
63137: LD_INT 2
63139: PUSH
63140: LD_INT 30
63142: PUSH
63143: LD_INT 2
63145: PUSH
63146: EMPTY
63147: LIST
63148: LIST
63149: PUSH
63150: LD_INT 30
63152: PUSH
63153: LD_INT 3
63155: PUSH
63156: EMPTY
63157: LIST
63158: LIST
63159: PUSH
63160: EMPTY
63161: LIST
63162: LIST
63163: LIST
63164: PUSH
63165: EMPTY
63166: LIST
63167: LIST
63168: PPUSH
63169: CALL_OW 72
63173: ST_TO_ADDR
63174: GO 63258
63176: LD_INT 4
63178: DOUBLE
63179: EQUAL
63180: IFTRUE 63184
63182: GO 63257
63184: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
63185: LD_ADDR_VAR 0 12
63189: PUSH
63190: LD_VAR 0 18
63194: PPUSH
63195: LD_INT 22
63197: PUSH
63198: LD_VAR 0 16
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: PUSH
63207: LD_INT 2
63209: PUSH
63210: LD_INT 30
63212: PUSH
63213: LD_INT 6
63215: PUSH
63216: EMPTY
63217: LIST
63218: LIST
63219: PUSH
63220: LD_INT 30
63222: PUSH
63223: LD_INT 7
63225: PUSH
63226: EMPTY
63227: LIST
63228: LIST
63229: PUSH
63230: LD_INT 30
63232: PUSH
63233: LD_INT 8
63235: PUSH
63236: EMPTY
63237: LIST
63238: LIST
63239: PUSH
63240: EMPTY
63241: LIST
63242: LIST
63243: LIST
63244: LIST
63245: PUSH
63246: EMPTY
63247: LIST
63248: LIST
63249: PPUSH
63250: CALL_OW 72
63254: ST_TO_ADDR
63255: GO 63258
63257: POP
// if i = 1 then
63258: LD_VAR 0 8
63262: PUSH
63263: LD_INT 1
63265: EQUAL
63266: IFFALSE 63377
// begin tmp := [ ] ;
63268: LD_ADDR_VAR 0 19
63272: PUSH
63273: EMPTY
63274: ST_TO_ADDR
// for j in f do
63275: LD_ADDR_VAR 0 9
63279: PUSH
63280: LD_VAR 0 12
63284: PUSH
63285: FOR_IN
63286: IFFALSE 63359
// if GetBType ( j ) = b_bunker then
63288: LD_VAR 0 9
63292: PPUSH
63293: CALL_OW 266
63297: PUSH
63298: LD_INT 32
63300: EQUAL
63301: IFFALSE 63328
// tmp := Insert ( tmp , 1 , j ) else
63303: LD_ADDR_VAR 0 19
63307: PUSH
63308: LD_VAR 0 19
63312: PPUSH
63313: LD_INT 1
63315: PPUSH
63316: LD_VAR 0 9
63320: PPUSH
63321: CALL_OW 2
63325: ST_TO_ADDR
63326: GO 63357
// tmp := Insert ( tmp , tmp + 1 , j ) ;
63328: LD_ADDR_VAR 0 19
63332: PUSH
63333: LD_VAR 0 19
63337: PPUSH
63338: LD_VAR 0 19
63342: PUSH
63343: LD_INT 1
63345: PLUS
63346: PPUSH
63347: LD_VAR 0 9
63351: PPUSH
63352: CALL_OW 2
63356: ST_TO_ADDR
63357: GO 63285
63359: POP
63360: POP
// if tmp then
63361: LD_VAR 0 19
63365: IFFALSE 63377
// f := tmp ;
63367: LD_ADDR_VAR 0 12
63371: PUSH
63372: LD_VAR 0 19
63376: ST_TO_ADDR
// end ; x := personel [ i ] ;
63377: LD_ADDR_VAR 0 13
63381: PUSH
63382: LD_VAR 0 6
63386: PUSH
63387: LD_VAR 0 8
63391: ARRAY
63392: ST_TO_ADDR
// if x = - 1 then
63393: LD_VAR 0 13
63397: PUSH
63398: LD_INT 1
63400: NEG
63401: EQUAL
63402: IFFALSE 63611
// begin for j in f do
63404: LD_ADDR_VAR 0 9
63408: PUSH
63409: LD_VAR 0 12
63413: PUSH
63414: FOR_IN
63415: IFFALSE 63607
// repeat InitHc ;
63417: CALL_OW 19
// if GetBType ( j ) = b_barracks then
63421: LD_VAR 0 9
63425: PPUSH
63426: CALL_OW 266
63430: PUSH
63431: LD_INT 5
63433: EQUAL
63434: IFFALSE 63504
// begin if UnitsInside ( j ) < 3 then
63436: LD_VAR 0 9
63440: PPUSH
63441: CALL_OW 313
63445: PUSH
63446: LD_INT 3
63448: LESS
63449: IFFALSE 63485
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
63451: LD_INT 0
63453: PPUSH
63454: LD_INT 5
63456: PUSH
63457: LD_INT 8
63459: PUSH
63460: LD_INT 9
63462: PUSH
63463: EMPTY
63464: LIST
63465: LIST
63466: LIST
63467: PUSH
63468: LD_VAR 0 17
63472: ARRAY
63473: PPUSH
63474: LD_VAR 0 4
63478: PPUSH
63479: CALL_OW 380
63483: GO 63502
// PrepareHuman ( false , i , skill ) ;
63485: LD_INT 0
63487: PPUSH
63488: LD_VAR 0 8
63492: PPUSH
63493: LD_VAR 0 4
63497: PPUSH
63498: CALL_OW 380
// end else
63502: GO 63521
// PrepareHuman ( false , i , skill ) ;
63504: LD_INT 0
63506: PPUSH
63507: LD_VAR 0 8
63511: PPUSH
63512: LD_VAR 0 4
63516: PPUSH
63517: CALL_OW 380
// un := CreateHuman ;
63521: LD_ADDR_VAR 0 14
63525: PUSH
63526: CALL_OW 44
63530: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63531: LD_ADDR_VAR 0 7
63535: PUSH
63536: LD_VAR 0 7
63540: PPUSH
63541: LD_INT 1
63543: PPUSH
63544: LD_VAR 0 14
63548: PPUSH
63549: CALL_OW 2
63553: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
63554: LD_VAR 0 14
63558: PPUSH
63559: LD_VAR 0 9
63563: PPUSH
63564: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
63568: LD_VAR 0 9
63572: PPUSH
63573: CALL_OW 313
63577: PUSH
63578: LD_INT 6
63580: EQUAL
63581: PUSH
63582: LD_VAR 0 9
63586: PPUSH
63587: CALL_OW 266
63591: PUSH
63592: LD_INT 32
63594: PUSH
63595: LD_INT 31
63597: PUSH
63598: EMPTY
63599: LIST
63600: LIST
63601: IN
63602: OR
63603: IFFALSE 63417
63605: GO 63414
63607: POP
63608: POP
// end else
63609: GO 63991
// for j = 1 to x do
63611: LD_ADDR_VAR 0 9
63615: PUSH
63616: DOUBLE
63617: LD_INT 1
63619: DEC
63620: ST_TO_ADDR
63621: LD_VAR 0 13
63625: PUSH
63626: FOR_TO
63627: IFFALSE 63989
// begin InitHc ;
63629: CALL_OW 19
// if not f then
63633: LD_VAR 0 12
63637: NOT
63638: IFFALSE 63727
// begin PrepareHuman ( false , i , skill ) ;
63640: LD_INT 0
63642: PPUSH
63643: LD_VAR 0 8
63647: PPUSH
63648: LD_VAR 0 4
63652: PPUSH
63653: CALL_OW 380
// un := CreateHuman ;
63657: LD_ADDR_VAR 0 14
63661: PUSH
63662: CALL_OW 44
63666: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63667: LD_ADDR_VAR 0 7
63671: PUSH
63672: LD_VAR 0 7
63676: PPUSH
63677: LD_INT 1
63679: PPUSH
63680: LD_VAR 0 14
63684: PPUSH
63685: CALL_OW 2
63689: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63690: LD_VAR 0 14
63694: PPUSH
63695: LD_VAR 0 1
63699: PPUSH
63700: CALL_OW 250
63704: PPUSH
63705: LD_VAR 0 1
63709: PPUSH
63710: CALL_OW 251
63714: PPUSH
63715: LD_INT 10
63717: PPUSH
63718: LD_INT 0
63720: PPUSH
63721: CALL_OW 50
// continue ;
63725: GO 63626
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
63727: LD_VAR 0 12
63731: PUSH
63732: LD_INT 1
63734: ARRAY
63735: PPUSH
63736: CALL_OW 313
63740: PUSH
63741: LD_VAR 0 12
63745: PUSH
63746: LD_INT 1
63748: ARRAY
63749: PPUSH
63750: CALL_OW 266
63754: PUSH
63755: LD_INT 32
63757: PUSH
63758: LD_INT 31
63760: PUSH
63761: EMPTY
63762: LIST
63763: LIST
63764: IN
63765: AND
63766: PUSH
63767: LD_VAR 0 12
63771: PUSH
63772: LD_INT 1
63774: ARRAY
63775: PPUSH
63776: CALL_OW 313
63780: PUSH
63781: LD_INT 6
63783: EQUAL
63784: OR
63785: IFFALSE 63805
// f := Delete ( f , 1 ) ;
63787: LD_ADDR_VAR 0 12
63791: PUSH
63792: LD_VAR 0 12
63796: PPUSH
63797: LD_INT 1
63799: PPUSH
63800: CALL_OW 3
63804: ST_TO_ADDR
// if not f then
63805: LD_VAR 0 12
63809: NOT
63810: IFFALSE 63828
// begin x := x + 2 ;
63812: LD_ADDR_VAR 0 13
63816: PUSH
63817: LD_VAR 0 13
63821: PUSH
63822: LD_INT 2
63824: PLUS
63825: ST_TO_ADDR
// continue ;
63826: GO 63626
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
63828: LD_VAR 0 12
63832: PUSH
63833: LD_INT 1
63835: ARRAY
63836: PPUSH
63837: CALL_OW 266
63841: PUSH
63842: LD_INT 5
63844: EQUAL
63845: IFFALSE 63919
// begin if UnitsInside ( f [ 1 ] ) < 3 then
63847: LD_VAR 0 12
63851: PUSH
63852: LD_INT 1
63854: ARRAY
63855: PPUSH
63856: CALL_OW 313
63860: PUSH
63861: LD_INT 3
63863: LESS
63864: IFFALSE 63900
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
63866: LD_INT 0
63868: PPUSH
63869: LD_INT 5
63871: PUSH
63872: LD_INT 8
63874: PUSH
63875: LD_INT 9
63877: PUSH
63878: EMPTY
63879: LIST
63880: LIST
63881: LIST
63882: PUSH
63883: LD_VAR 0 17
63887: ARRAY
63888: PPUSH
63889: LD_VAR 0 4
63893: PPUSH
63894: CALL_OW 380
63898: GO 63917
// PrepareHuman ( false , i , skill ) ;
63900: LD_INT 0
63902: PPUSH
63903: LD_VAR 0 8
63907: PPUSH
63908: LD_VAR 0 4
63912: PPUSH
63913: CALL_OW 380
// end else
63917: GO 63936
// PrepareHuman ( false , i , skill ) ;
63919: LD_INT 0
63921: PPUSH
63922: LD_VAR 0 8
63926: PPUSH
63927: LD_VAR 0 4
63931: PPUSH
63932: CALL_OW 380
// un := CreateHuman ;
63936: LD_ADDR_VAR 0 14
63940: PUSH
63941: CALL_OW 44
63945: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63946: LD_ADDR_VAR 0 7
63950: PUSH
63951: LD_VAR 0 7
63955: PPUSH
63956: LD_INT 1
63958: PPUSH
63959: LD_VAR 0 14
63963: PPUSH
63964: CALL_OW 2
63968: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
63969: LD_VAR 0 14
63973: PPUSH
63974: LD_VAR 0 12
63978: PUSH
63979: LD_INT 1
63981: ARRAY
63982: PPUSH
63983: CALL_OW 52
// end ;
63987: GO 63626
63989: POP
63990: POP
// end ;
63991: GO 62928
63993: POP
63994: POP
// result := result ^ buildings ;
63995: LD_ADDR_VAR 0 7
63999: PUSH
64000: LD_VAR 0 7
64004: PUSH
64005: LD_VAR 0 18
64009: ADD
64010: ST_TO_ADDR
// end else
64011: GO 64154
// begin for i = 1 to personel do
64013: LD_ADDR_VAR 0 8
64017: PUSH
64018: DOUBLE
64019: LD_INT 1
64021: DEC
64022: ST_TO_ADDR
64023: LD_VAR 0 6
64027: PUSH
64028: FOR_TO
64029: IFFALSE 64152
// begin if i > 4 then
64031: LD_VAR 0 8
64035: PUSH
64036: LD_INT 4
64038: GREATER
64039: IFFALSE 64043
// break ;
64041: GO 64152
// x := personel [ i ] ;
64043: LD_ADDR_VAR 0 13
64047: PUSH
64048: LD_VAR 0 6
64052: PUSH
64053: LD_VAR 0 8
64057: ARRAY
64058: ST_TO_ADDR
// if x = - 1 then
64059: LD_VAR 0 13
64063: PUSH
64064: LD_INT 1
64066: NEG
64067: EQUAL
64068: IFFALSE 64072
// continue ;
64070: GO 64028
// PrepareHuman ( false , i , skill ) ;
64072: LD_INT 0
64074: PPUSH
64075: LD_VAR 0 8
64079: PPUSH
64080: LD_VAR 0 4
64084: PPUSH
64085: CALL_OW 380
// un := CreateHuman ;
64089: LD_ADDR_VAR 0 14
64093: PUSH
64094: CALL_OW 44
64098: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
64099: LD_VAR 0 14
64103: PPUSH
64104: LD_VAR 0 1
64108: PPUSH
64109: CALL_OW 250
64113: PPUSH
64114: LD_VAR 0 1
64118: PPUSH
64119: CALL_OW 251
64123: PPUSH
64124: LD_INT 10
64126: PPUSH
64127: LD_INT 0
64129: PPUSH
64130: CALL_OW 50
// result := result ^ un ;
64134: LD_ADDR_VAR 0 7
64138: PUSH
64139: LD_VAR 0 7
64143: PUSH
64144: LD_VAR 0 14
64148: ADD
64149: ST_TO_ADDR
// end ;
64150: GO 64028
64152: POP
64153: POP
// end ; end ;
64154: LD_VAR 0 7
64158: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
64159: LD_INT 0
64161: PPUSH
64162: PPUSH
64163: PPUSH
64164: PPUSH
64165: PPUSH
64166: PPUSH
64167: PPUSH
64168: PPUSH
64169: PPUSH
64170: PPUSH
64171: PPUSH
64172: PPUSH
64173: PPUSH
64174: PPUSH
64175: PPUSH
64176: PPUSH
// result := false ;
64177: LD_ADDR_VAR 0 3
64181: PUSH
64182: LD_INT 0
64184: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
64185: LD_VAR 0 1
64189: NOT
64190: PUSH
64191: LD_VAR 0 1
64195: PPUSH
64196: CALL_OW 266
64200: PUSH
64201: LD_INT 32
64203: PUSH
64204: LD_INT 33
64206: PUSH
64207: EMPTY
64208: LIST
64209: LIST
64210: IN
64211: NOT
64212: OR
64213: IFFALSE 64217
// exit ;
64215: GO 65326
// nat := GetNation ( tower ) ;
64217: LD_ADDR_VAR 0 12
64221: PUSH
64222: LD_VAR 0 1
64226: PPUSH
64227: CALL_OW 248
64231: ST_TO_ADDR
// side := GetSide ( tower ) ;
64232: LD_ADDR_VAR 0 16
64236: PUSH
64237: LD_VAR 0 1
64241: PPUSH
64242: CALL_OW 255
64246: ST_TO_ADDR
// x := GetX ( tower ) ;
64247: LD_ADDR_VAR 0 10
64251: PUSH
64252: LD_VAR 0 1
64256: PPUSH
64257: CALL_OW 250
64261: ST_TO_ADDR
// y := GetY ( tower ) ;
64262: LD_ADDR_VAR 0 11
64266: PUSH
64267: LD_VAR 0 1
64271: PPUSH
64272: CALL_OW 251
64276: ST_TO_ADDR
// if not x or not y then
64277: LD_VAR 0 10
64281: NOT
64282: PUSH
64283: LD_VAR 0 11
64287: NOT
64288: OR
64289: IFFALSE 64293
// exit ;
64291: GO 65326
// weapon := 0 ;
64293: LD_ADDR_VAR 0 18
64297: PUSH
64298: LD_INT 0
64300: ST_TO_ADDR
// fac_list := [ ] ;
64301: LD_ADDR_VAR 0 17
64305: PUSH
64306: EMPTY
64307: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
64308: LD_ADDR_VAR 0 6
64312: PUSH
64313: LD_VAR 0 1
64317: PPUSH
64318: CALL_OW 274
64322: PPUSH
64323: LD_VAR 0 2
64327: PPUSH
64328: LD_INT 0
64330: PPUSH
64331: CALL 61897 0 3
64335: PPUSH
64336: LD_INT 30
64338: PUSH
64339: LD_INT 3
64341: PUSH
64342: EMPTY
64343: LIST
64344: LIST
64345: PPUSH
64346: CALL_OW 72
64350: ST_TO_ADDR
// if not factories then
64351: LD_VAR 0 6
64355: NOT
64356: IFFALSE 64360
// exit ;
64358: GO 65326
// for i in factories do
64360: LD_ADDR_VAR 0 8
64364: PUSH
64365: LD_VAR 0 6
64369: PUSH
64370: FOR_IN
64371: IFFALSE 64396
// fac_list := fac_list union AvailableWeaponList ( i ) ;
64373: LD_ADDR_VAR 0 17
64377: PUSH
64378: LD_VAR 0 17
64382: PUSH
64383: LD_VAR 0 8
64387: PPUSH
64388: CALL_OW 478
64392: UNION
64393: ST_TO_ADDR
64394: GO 64370
64396: POP
64397: POP
// if not fac_list then
64398: LD_VAR 0 17
64402: NOT
64403: IFFALSE 64407
// exit ;
64405: GO 65326
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
64407: LD_ADDR_VAR 0 5
64411: PUSH
64412: LD_INT 4
64414: PUSH
64415: LD_INT 5
64417: PUSH
64418: LD_INT 9
64420: PUSH
64421: LD_INT 10
64423: PUSH
64424: LD_INT 6
64426: PUSH
64427: LD_INT 7
64429: PUSH
64430: LD_INT 11
64432: PUSH
64433: EMPTY
64434: LIST
64435: LIST
64436: LIST
64437: LIST
64438: LIST
64439: LIST
64440: LIST
64441: PUSH
64442: LD_INT 27
64444: PUSH
64445: LD_INT 28
64447: PUSH
64448: LD_INT 26
64450: PUSH
64451: LD_INT 30
64453: PUSH
64454: EMPTY
64455: LIST
64456: LIST
64457: LIST
64458: LIST
64459: PUSH
64460: LD_INT 43
64462: PUSH
64463: LD_INT 44
64465: PUSH
64466: LD_INT 46
64468: PUSH
64469: LD_INT 45
64471: PUSH
64472: LD_INT 47
64474: PUSH
64475: LD_INT 49
64477: PUSH
64478: EMPTY
64479: LIST
64480: LIST
64481: LIST
64482: LIST
64483: LIST
64484: LIST
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: LIST
64490: PUSH
64491: LD_VAR 0 12
64495: ARRAY
64496: ST_TO_ADDR
// list := list isect fac_list ;
64497: LD_ADDR_VAR 0 5
64501: PUSH
64502: LD_VAR 0 5
64506: PUSH
64507: LD_VAR 0 17
64511: ISECT
64512: ST_TO_ADDR
// if not list then
64513: LD_VAR 0 5
64517: NOT
64518: IFFALSE 64522
// exit ;
64520: GO 65326
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
64522: LD_VAR 0 12
64526: PUSH
64527: LD_INT 3
64529: EQUAL
64530: PUSH
64531: LD_INT 49
64533: PUSH
64534: LD_VAR 0 5
64538: IN
64539: AND
64540: PUSH
64541: LD_INT 31
64543: PPUSH
64544: LD_VAR 0 16
64548: PPUSH
64549: CALL_OW 321
64553: PUSH
64554: LD_INT 2
64556: EQUAL
64557: AND
64558: IFFALSE 64618
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
64560: LD_INT 22
64562: PUSH
64563: LD_VAR 0 16
64567: PUSH
64568: EMPTY
64569: LIST
64570: LIST
64571: PUSH
64572: LD_INT 35
64574: PUSH
64575: LD_INT 49
64577: PUSH
64578: EMPTY
64579: LIST
64580: LIST
64581: PUSH
64582: LD_INT 91
64584: PUSH
64585: LD_VAR 0 1
64589: PUSH
64590: LD_INT 10
64592: PUSH
64593: EMPTY
64594: LIST
64595: LIST
64596: LIST
64597: PUSH
64598: EMPTY
64599: LIST
64600: LIST
64601: LIST
64602: PPUSH
64603: CALL_OW 69
64607: NOT
64608: IFFALSE 64618
// weapon := ru_time_lapser ;
64610: LD_ADDR_VAR 0 18
64614: PUSH
64615: LD_INT 49
64617: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
64618: LD_VAR 0 12
64622: PUSH
64623: LD_INT 1
64625: PUSH
64626: LD_INT 2
64628: PUSH
64629: EMPTY
64630: LIST
64631: LIST
64632: IN
64633: PUSH
64634: LD_INT 11
64636: PUSH
64637: LD_VAR 0 5
64641: IN
64642: PUSH
64643: LD_INT 30
64645: PUSH
64646: LD_VAR 0 5
64650: IN
64651: OR
64652: AND
64653: PUSH
64654: LD_INT 6
64656: PPUSH
64657: LD_VAR 0 16
64661: PPUSH
64662: CALL_OW 321
64666: PUSH
64667: LD_INT 2
64669: EQUAL
64670: AND
64671: IFFALSE 64836
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
64673: LD_INT 22
64675: PUSH
64676: LD_VAR 0 16
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: PUSH
64685: LD_INT 2
64687: PUSH
64688: LD_INT 35
64690: PUSH
64691: LD_INT 11
64693: PUSH
64694: EMPTY
64695: LIST
64696: LIST
64697: PUSH
64698: LD_INT 35
64700: PUSH
64701: LD_INT 30
64703: PUSH
64704: EMPTY
64705: LIST
64706: LIST
64707: PUSH
64708: EMPTY
64709: LIST
64710: LIST
64711: LIST
64712: PUSH
64713: LD_INT 91
64715: PUSH
64716: LD_VAR 0 1
64720: PUSH
64721: LD_INT 18
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: LIST
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: LIST
64733: PPUSH
64734: CALL_OW 69
64738: NOT
64739: PUSH
64740: LD_INT 22
64742: PUSH
64743: LD_VAR 0 16
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: PUSH
64752: LD_INT 2
64754: PUSH
64755: LD_INT 30
64757: PUSH
64758: LD_INT 32
64760: PUSH
64761: EMPTY
64762: LIST
64763: LIST
64764: PUSH
64765: LD_INT 30
64767: PUSH
64768: LD_INT 33
64770: PUSH
64771: EMPTY
64772: LIST
64773: LIST
64774: PUSH
64775: EMPTY
64776: LIST
64777: LIST
64778: LIST
64779: PUSH
64780: LD_INT 91
64782: PUSH
64783: LD_VAR 0 1
64787: PUSH
64788: LD_INT 12
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: LIST
64795: PUSH
64796: EMPTY
64797: LIST
64798: LIST
64799: LIST
64800: PUSH
64801: EMPTY
64802: LIST
64803: PPUSH
64804: CALL_OW 69
64808: PUSH
64809: LD_INT 2
64811: GREATER
64812: AND
64813: IFFALSE 64836
// weapon := [ us_radar , ar_radar ] [ nat ] ;
64815: LD_ADDR_VAR 0 18
64819: PUSH
64820: LD_INT 11
64822: PUSH
64823: LD_INT 30
64825: PUSH
64826: EMPTY
64827: LIST
64828: LIST
64829: PUSH
64830: LD_VAR 0 12
64834: ARRAY
64835: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
64836: LD_VAR 0 18
64840: NOT
64841: PUSH
64842: LD_INT 40
64844: PPUSH
64845: LD_VAR 0 16
64849: PPUSH
64850: CALL_OW 321
64854: PUSH
64855: LD_INT 2
64857: EQUAL
64858: AND
64859: PUSH
64860: LD_INT 7
64862: PUSH
64863: LD_VAR 0 5
64867: IN
64868: PUSH
64869: LD_INT 28
64871: PUSH
64872: LD_VAR 0 5
64876: IN
64877: OR
64878: PUSH
64879: LD_INT 45
64881: PUSH
64882: LD_VAR 0 5
64886: IN
64887: OR
64888: AND
64889: IFFALSE 65143
// begin hex := GetHexInfo ( x , y ) ;
64891: LD_ADDR_VAR 0 4
64895: PUSH
64896: LD_VAR 0 10
64900: PPUSH
64901: LD_VAR 0 11
64905: PPUSH
64906: CALL_OW 546
64910: ST_TO_ADDR
// if hex [ 1 ] then
64911: LD_VAR 0 4
64915: PUSH
64916: LD_INT 1
64918: ARRAY
64919: IFFALSE 64923
// exit ;
64921: GO 65326
// height := hex [ 2 ] ;
64923: LD_ADDR_VAR 0 15
64927: PUSH
64928: LD_VAR 0 4
64932: PUSH
64933: LD_INT 2
64935: ARRAY
64936: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
64937: LD_ADDR_VAR 0 14
64941: PUSH
64942: LD_INT 0
64944: PUSH
64945: LD_INT 2
64947: PUSH
64948: LD_INT 3
64950: PUSH
64951: LD_INT 5
64953: PUSH
64954: EMPTY
64955: LIST
64956: LIST
64957: LIST
64958: LIST
64959: ST_TO_ADDR
// for i in tmp do
64960: LD_ADDR_VAR 0 8
64964: PUSH
64965: LD_VAR 0 14
64969: PUSH
64970: FOR_IN
64971: IFFALSE 65141
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
64973: LD_ADDR_VAR 0 9
64977: PUSH
64978: LD_VAR 0 10
64982: PPUSH
64983: LD_VAR 0 8
64987: PPUSH
64988: LD_INT 5
64990: PPUSH
64991: CALL_OW 272
64995: PUSH
64996: LD_VAR 0 11
65000: PPUSH
65001: LD_VAR 0 8
65005: PPUSH
65006: LD_INT 5
65008: PPUSH
65009: CALL_OW 273
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
65018: LD_VAR 0 9
65022: PUSH
65023: LD_INT 1
65025: ARRAY
65026: PPUSH
65027: LD_VAR 0 9
65031: PUSH
65032: LD_INT 2
65034: ARRAY
65035: PPUSH
65036: CALL_OW 488
65040: IFFALSE 65139
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
65042: LD_ADDR_VAR 0 4
65046: PUSH
65047: LD_VAR 0 9
65051: PUSH
65052: LD_INT 1
65054: ARRAY
65055: PPUSH
65056: LD_VAR 0 9
65060: PUSH
65061: LD_INT 2
65063: ARRAY
65064: PPUSH
65065: CALL_OW 546
65069: ST_TO_ADDR
// if hex [ 1 ] then
65070: LD_VAR 0 4
65074: PUSH
65075: LD_INT 1
65077: ARRAY
65078: IFFALSE 65082
// continue ;
65080: GO 64970
// h := hex [ 2 ] ;
65082: LD_ADDR_VAR 0 13
65086: PUSH
65087: LD_VAR 0 4
65091: PUSH
65092: LD_INT 2
65094: ARRAY
65095: ST_TO_ADDR
// if h + 7 < height then
65096: LD_VAR 0 13
65100: PUSH
65101: LD_INT 7
65103: PLUS
65104: PUSH
65105: LD_VAR 0 15
65109: LESS
65110: IFFALSE 65139
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
65112: LD_ADDR_VAR 0 18
65116: PUSH
65117: LD_INT 7
65119: PUSH
65120: LD_INT 28
65122: PUSH
65123: LD_INT 45
65125: PUSH
65126: EMPTY
65127: LIST
65128: LIST
65129: LIST
65130: PUSH
65131: LD_VAR 0 12
65135: ARRAY
65136: ST_TO_ADDR
// break ;
65137: GO 65141
// end ; end ; end ;
65139: GO 64970
65141: POP
65142: POP
// end ; if not weapon then
65143: LD_VAR 0 18
65147: NOT
65148: IFFALSE 65208
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
65150: LD_ADDR_VAR 0 5
65154: PUSH
65155: LD_VAR 0 5
65159: PUSH
65160: LD_INT 11
65162: PUSH
65163: LD_INT 30
65165: PUSH
65166: LD_INT 49
65168: PUSH
65169: EMPTY
65170: LIST
65171: LIST
65172: LIST
65173: DIFF
65174: ST_TO_ADDR
// if not list then
65175: LD_VAR 0 5
65179: NOT
65180: IFFALSE 65184
// exit ;
65182: GO 65326
// weapon := list [ rand ( 1 , list ) ] ;
65184: LD_ADDR_VAR 0 18
65188: PUSH
65189: LD_VAR 0 5
65193: PUSH
65194: LD_INT 1
65196: PPUSH
65197: LD_VAR 0 5
65201: PPUSH
65202: CALL_OW 12
65206: ARRAY
65207: ST_TO_ADDR
// end ; if weapon then
65208: LD_VAR 0 18
65212: IFFALSE 65326
// begin tmp := CostOfWeapon ( weapon ) ;
65214: LD_ADDR_VAR 0 14
65218: PUSH
65219: LD_VAR 0 18
65223: PPUSH
65224: CALL_OW 451
65228: ST_TO_ADDR
// j := GetBase ( tower ) ;
65229: LD_ADDR_VAR 0 9
65233: PUSH
65234: LD_VAR 0 1
65238: PPUSH
65239: CALL_OW 274
65243: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
65244: LD_VAR 0 9
65248: PPUSH
65249: LD_INT 1
65251: PPUSH
65252: CALL_OW 275
65256: PUSH
65257: LD_VAR 0 14
65261: PUSH
65262: LD_INT 1
65264: ARRAY
65265: GREATEREQUAL
65266: PUSH
65267: LD_VAR 0 9
65271: PPUSH
65272: LD_INT 2
65274: PPUSH
65275: CALL_OW 275
65279: PUSH
65280: LD_VAR 0 14
65284: PUSH
65285: LD_INT 2
65287: ARRAY
65288: GREATEREQUAL
65289: AND
65290: PUSH
65291: LD_VAR 0 9
65295: PPUSH
65296: LD_INT 3
65298: PPUSH
65299: CALL_OW 275
65303: PUSH
65304: LD_VAR 0 14
65308: PUSH
65309: LD_INT 3
65311: ARRAY
65312: GREATEREQUAL
65313: AND
65314: IFFALSE 65326
// result := weapon ;
65316: LD_ADDR_VAR 0 3
65320: PUSH
65321: LD_VAR 0 18
65325: ST_TO_ADDR
// end ; end ;
65326: LD_VAR 0 3
65330: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
65331: LD_INT 0
65333: PPUSH
65334: PPUSH
// result := true ;
65335: LD_ADDR_VAR 0 3
65339: PUSH
65340: LD_INT 1
65342: ST_TO_ADDR
// if array1 = array2 then
65343: LD_VAR 0 1
65347: PUSH
65348: LD_VAR 0 2
65352: EQUAL
65353: IFFALSE 65413
// begin for i = 1 to array1 do
65355: LD_ADDR_VAR 0 4
65359: PUSH
65360: DOUBLE
65361: LD_INT 1
65363: DEC
65364: ST_TO_ADDR
65365: LD_VAR 0 1
65369: PUSH
65370: FOR_TO
65371: IFFALSE 65409
// if array1 [ i ] <> array2 [ i ] then
65373: LD_VAR 0 1
65377: PUSH
65378: LD_VAR 0 4
65382: ARRAY
65383: PUSH
65384: LD_VAR 0 2
65388: PUSH
65389: LD_VAR 0 4
65393: ARRAY
65394: NONEQUAL
65395: IFFALSE 65407
// begin result := false ;
65397: LD_ADDR_VAR 0 3
65401: PUSH
65402: LD_INT 0
65404: ST_TO_ADDR
// break ;
65405: GO 65409
// end ;
65407: GO 65370
65409: POP
65410: POP
// end else
65411: GO 65421
// result := false ;
65413: LD_ADDR_VAR 0 3
65417: PUSH
65418: LD_INT 0
65420: ST_TO_ADDR
// end ;
65421: LD_VAR 0 3
65425: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
65426: LD_INT 0
65428: PPUSH
65429: PPUSH
// if not array1 or not array2 then
65430: LD_VAR 0 1
65434: NOT
65435: PUSH
65436: LD_VAR 0 2
65440: NOT
65441: OR
65442: IFFALSE 65446
// exit ;
65444: GO 65510
// result := true ;
65446: LD_ADDR_VAR 0 3
65450: PUSH
65451: LD_INT 1
65453: ST_TO_ADDR
// for i = 1 to array1 do
65454: LD_ADDR_VAR 0 4
65458: PUSH
65459: DOUBLE
65460: LD_INT 1
65462: DEC
65463: ST_TO_ADDR
65464: LD_VAR 0 1
65468: PUSH
65469: FOR_TO
65470: IFFALSE 65508
// if array1 [ i ] <> array2 [ i ] then
65472: LD_VAR 0 1
65476: PUSH
65477: LD_VAR 0 4
65481: ARRAY
65482: PUSH
65483: LD_VAR 0 2
65487: PUSH
65488: LD_VAR 0 4
65492: ARRAY
65493: NONEQUAL
65494: IFFALSE 65506
// begin result := false ;
65496: LD_ADDR_VAR 0 3
65500: PUSH
65501: LD_INT 0
65503: ST_TO_ADDR
// break ;
65504: GO 65508
// end ;
65506: GO 65469
65508: POP
65509: POP
// end ;
65510: LD_VAR 0 3
65514: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
65515: LD_INT 0
65517: PPUSH
65518: PPUSH
65519: PPUSH
// pom := GetBase ( fac ) ;
65520: LD_ADDR_VAR 0 5
65524: PUSH
65525: LD_VAR 0 1
65529: PPUSH
65530: CALL_OW 274
65534: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
65535: LD_ADDR_VAR 0 4
65539: PUSH
65540: LD_VAR 0 2
65544: PUSH
65545: LD_INT 1
65547: ARRAY
65548: PPUSH
65549: LD_VAR 0 2
65553: PUSH
65554: LD_INT 2
65556: ARRAY
65557: PPUSH
65558: LD_VAR 0 2
65562: PUSH
65563: LD_INT 3
65565: ARRAY
65566: PPUSH
65567: LD_VAR 0 2
65571: PUSH
65572: LD_INT 4
65574: ARRAY
65575: PPUSH
65576: CALL_OW 449
65580: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65581: LD_ADDR_VAR 0 3
65585: PUSH
65586: LD_VAR 0 5
65590: PPUSH
65591: LD_INT 1
65593: PPUSH
65594: CALL_OW 275
65598: PUSH
65599: LD_VAR 0 4
65603: PUSH
65604: LD_INT 1
65606: ARRAY
65607: GREATEREQUAL
65608: PUSH
65609: LD_VAR 0 5
65613: PPUSH
65614: LD_INT 2
65616: PPUSH
65617: CALL_OW 275
65621: PUSH
65622: LD_VAR 0 4
65626: PUSH
65627: LD_INT 2
65629: ARRAY
65630: GREATEREQUAL
65631: AND
65632: PUSH
65633: LD_VAR 0 5
65637: PPUSH
65638: LD_INT 3
65640: PPUSH
65641: CALL_OW 275
65645: PUSH
65646: LD_VAR 0 4
65650: PUSH
65651: LD_INT 3
65653: ARRAY
65654: GREATEREQUAL
65655: AND
65656: ST_TO_ADDR
// end ;
65657: LD_VAR 0 3
65661: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
65662: LD_INT 0
65664: PPUSH
65665: PPUSH
65666: PPUSH
65667: PPUSH
// pom := GetBase ( building ) ;
65668: LD_ADDR_VAR 0 3
65672: PUSH
65673: LD_VAR 0 1
65677: PPUSH
65678: CALL_OW 274
65682: ST_TO_ADDR
// if not pom then
65683: LD_VAR 0 3
65687: NOT
65688: IFFALSE 65692
// exit ;
65690: GO 65862
// btype := GetBType ( building ) ;
65692: LD_ADDR_VAR 0 5
65696: PUSH
65697: LD_VAR 0 1
65701: PPUSH
65702: CALL_OW 266
65706: ST_TO_ADDR
// if btype = b_armoury then
65707: LD_VAR 0 5
65711: PUSH
65712: LD_INT 4
65714: EQUAL
65715: IFFALSE 65725
// btype := b_barracks ;
65717: LD_ADDR_VAR 0 5
65721: PUSH
65722: LD_INT 5
65724: ST_TO_ADDR
// if btype = b_depot then
65725: LD_VAR 0 5
65729: PUSH
65730: LD_INT 0
65732: EQUAL
65733: IFFALSE 65743
// btype := b_warehouse ;
65735: LD_ADDR_VAR 0 5
65739: PUSH
65740: LD_INT 1
65742: ST_TO_ADDR
// if btype = b_workshop then
65743: LD_VAR 0 5
65747: PUSH
65748: LD_INT 2
65750: EQUAL
65751: IFFALSE 65761
// btype := b_factory ;
65753: LD_ADDR_VAR 0 5
65757: PUSH
65758: LD_INT 3
65760: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65761: LD_ADDR_VAR 0 4
65765: PUSH
65766: LD_VAR 0 5
65770: PPUSH
65771: LD_VAR 0 1
65775: PPUSH
65776: CALL_OW 248
65780: PPUSH
65781: CALL_OW 450
65785: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65786: LD_ADDR_VAR 0 2
65790: PUSH
65791: LD_VAR 0 3
65795: PPUSH
65796: LD_INT 1
65798: PPUSH
65799: CALL_OW 275
65803: PUSH
65804: LD_VAR 0 4
65808: PUSH
65809: LD_INT 1
65811: ARRAY
65812: GREATEREQUAL
65813: PUSH
65814: LD_VAR 0 3
65818: PPUSH
65819: LD_INT 2
65821: PPUSH
65822: CALL_OW 275
65826: PUSH
65827: LD_VAR 0 4
65831: PUSH
65832: LD_INT 2
65834: ARRAY
65835: GREATEREQUAL
65836: AND
65837: PUSH
65838: LD_VAR 0 3
65842: PPUSH
65843: LD_INT 3
65845: PPUSH
65846: CALL_OW 275
65850: PUSH
65851: LD_VAR 0 4
65855: PUSH
65856: LD_INT 3
65858: ARRAY
65859: GREATEREQUAL
65860: AND
65861: ST_TO_ADDR
// end ;
65862: LD_VAR 0 2
65866: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
65867: LD_INT 0
65869: PPUSH
65870: PPUSH
65871: PPUSH
// pom := GetBase ( building ) ;
65872: LD_ADDR_VAR 0 4
65876: PUSH
65877: LD_VAR 0 1
65881: PPUSH
65882: CALL_OW 274
65886: ST_TO_ADDR
// if not pom then
65887: LD_VAR 0 4
65891: NOT
65892: IFFALSE 65896
// exit ;
65894: GO 65997
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65896: LD_ADDR_VAR 0 5
65900: PUSH
65901: LD_VAR 0 2
65905: PPUSH
65906: LD_VAR 0 1
65910: PPUSH
65911: CALL_OW 248
65915: PPUSH
65916: CALL_OW 450
65920: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65921: LD_ADDR_VAR 0 3
65925: PUSH
65926: LD_VAR 0 4
65930: PPUSH
65931: LD_INT 1
65933: PPUSH
65934: CALL_OW 275
65938: PUSH
65939: LD_VAR 0 5
65943: PUSH
65944: LD_INT 1
65946: ARRAY
65947: GREATEREQUAL
65948: PUSH
65949: LD_VAR 0 4
65953: PPUSH
65954: LD_INT 2
65956: PPUSH
65957: CALL_OW 275
65961: PUSH
65962: LD_VAR 0 5
65966: PUSH
65967: LD_INT 2
65969: ARRAY
65970: GREATEREQUAL
65971: AND
65972: PUSH
65973: LD_VAR 0 4
65977: PPUSH
65978: LD_INT 3
65980: PPUSH
65981: CALL_OW 275
65985: PUSH
65986: LD_VAR 0 5
65990: PUSH
65991: LD_INT 3
65993: ARRAY
65994: GREATEREQUAL
65995: AND
65996: ST_TO_ADDR
// end ;
65997: LD_VAR 0 3
66001: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
66002: LD_INT 0
66004: PPUSH
66005: PPUSH
66006: PPUSH
66007: PPUSH
66008: PPUSH
66009: PPUSH
66010: PPUSH
66011: PPUSH
66012: PPUSH
66013: PPUSH
66014: PPUSH
// result := false ;
66015: LD_ADDR_VAR 0 8
66019: PUSH
66020: LD_INT 0
66022: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
66023: LD_VAR 0 5
66027: NOT
66028: PUSH
66029: LD_VAR 0 1
66033: NOT
66034: OR
66035: PUSH
66036: LD_VAR 0 2
66040: NOT
66041: OR
66042: PUSH
66043: LD_VAR 0 3
66047: NOT
66048: OR
66049: IFFALSE 66053
// exit ;
66051: GO 66867
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
66053: LD_ADDR_VAR 0 14
66057: PUSH
66058: LD_VAR 0 1
66062: PPUSH
66063: LD_VAR 0 2
66067: PPUSH
66068: LD_VAR 0 3
66072: PPUSH
66073: LD_VAR 0 4
66077: PPUSH
66078: LD_VAR 0 5
66082: PUSH
66083: LD_INT 1
66085: ARRAY
66086: PPUSH
66087: CALL_OW 248
66091: PPUSH
66092: LD_INT 0
66094: PPUSH
66095: CALL 68120 0 6
66099: ST_TO_ADDR
// if not hexes then
66100: LD_VAR 0 14
66104: NOT
66105: IFFALSE 66109
// exit ;
66107: GO 66867
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
66109: LD_ADDR_VAR 0 17
66113: PUSH
66114: LD_VAR 0 5
66118: PPUSH
66119: LD_INT 22
66121: PUSH
66122: LD_VAR 0 13
66126: PPUSH
66127: CALL_OW 255
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: PUSH
66136: LD_INT 2
66138: PUSH
66139: LD_INT 30
66141: PUSH
66142: LD_INT 0
66144: PUSH
66145: EMPTY
66146: LIST
66147: LIST
66148: PUSH
66149: LD_INT 30
66151: PUSH
66152: LD_INT 1
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: PUSH
66159: EMPTY
66160: LIST
66161: LIST
66162: LIST
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PPUSH
66168: CALL_OW 72
66172: ST_TO_ADDR
// for i = 1 to hexes do
66173: LD_ADDR_VAR 0 9
66177: PUSH
66178: DOUBLE
66179: LD_INT 1
66181: DEC
66182: ST_TO_ADDR
66183: LD_VAR 0 14
66187: PUSH
66188: FOR_TO
66189: IFFALSE 66865
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
66191: LD_ADDR_VAR 0 13
66195: PUSH
66196: LD_VAR 0 14
66200: PUSH
66201: LD_VAR 0 9
66205: ARRAY
66206: PUSH
66207: LD_INT 1
66209: ARRAY
66210: PPUSH
66211: LD_VAR 0 14
66215: PUSH
66216: LD_VAR 0 9
66220: ARRAY
66221: PUSH
66222: LD_INT 2
66224: ARRAY
66225: PPUSH
66226: CALL_OW 428
66230: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
66231: LD_VAR 0 14
66235: PUSH
66236: LD_VAR 0 9
66240: ARRAY
66241: PUSH
66242: LD_INT 1
66244: ARRAY
66245: PPUSH
66246: LD_VAR 0 14
66250: PUSH
66251: LD_VAR 0 9
66255: ARRAY
66256: PUSH
66257: LD_INT 2
66259: ARRAY
66260: PPUSH
66261: CALL_OW 351
66265: PUSH
66266: LD_VAR 0 14
66270: PUSH
66271: LD_VAR 0 9
66275: ARRAY
66276: PUSH
66277: LD_INT 1
66279: ARRAY
66280: PPUSH
66281: LD_VAR 0 14
66285: PUSH
66286: LD_VAR 0 9
66290: ARRAY
66291: PUSH
66292: LD_INT 2
66294: ARRAY
66295: PPUSH
66296: CALL_OW 488
66300: NOT
66301: OR
66302: PUSH
66303: LD_VAR 0 13
66307: PPUSH
66308: CALL_OW 247
66312: PUSH
66313: LD_INT 3
66315: EQUAL
66316: OR
66317: IFFALSE 66323
// exit ;
66319: POP
66320: POP
66321: GO 66867
// if not tmp then
66323: LD_VAR 0 13
66327: NOT
66328: IFFALSE 66332
// continue ;
66330: GO 66188
// result := true ;
66332: LD_ADDR_VAR 0 8
66336: PUSH
66337: LD_INT 1
66339: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
66340: LD_VAR 0 6
66344: PUSH
66345: LD_VAR 0 13
66349: PPUSH
66350: CALL_OW 247
66354: PUSH
66355: LD_INT 2
66357: EQUAL
66358: AND
66359: PUSH
66360: LD_VAR 0 13
66364: PPUSH
66365: CALL_OW 263
66369: PUSH
66370: LD_INT 1
66372: EQUAL
66373: AND
66374: IFFALSE 66538
// begin if IsDrivenBy ( tmp ) then
66376: LD_VAR 0 13
66380: PPUSH
66381: CALL_OW 311
66385: IFFALSE 66389
// continue ;
66387: GO 66188
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
66389: LD_VAR 0 6
66393: PPUSH
66394: LD_INT 3
66396: PUSH
66397: LD_INT 60
66399: PUSH
66400: EMPTY
66401: LIST
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PUSH
66407: LD_INT 3
66409: PUSH
66410: LD_INT 55
66412: PUSH
66413: EMPTY
66414: LIST
66415: PUSH
66416: EMPTY
66417: LIST
66418: LIST
66419: PUSH
66420: EMPTY
66421: LIST
66422: LIST
66423: PPUSH
66424: CALL_OW 72
66428: IFFALSE 66536
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
66430: LD_ADDR_VAR 0 18
66434: PUSH
66435: LD_VAR 0 6
66439: PPUSH
66440: LD_INT 3
66442: PUSH
66443: LD_INT 60
66445: PUSH
66446: EMPTY
66447: LIST
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: PUSH
66453: LD_INT 3
66455: PUSH
66456: LD_INT 55
66458: PUSH
66459: EMPTY
66460: LIST
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: PPUSH
66470: CALL_OW 72
66474: PUSH
66475: LD_INT 1
66477: ARRAY
66478: ST_TO_ADDR
// if IsInUnit ( driver ) then
66479: LD_VAR 0 18
66483: PPUSH
66484: CALL_OW 310
66488: IFFALSE 66499
// ComExit ( driver ) ;
66490: LD_VAR 0 18
66494: PPUSH
66495: CALL 91921 0 1
// AddComEnterUnit ( driver , tmp ) ;
66499: LD_VAR 0 18
66503: PPUSH
66504: LD_VAR 0 13
66508: PPUSH
66509: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
66513: LD_VAR 0 18
66517: PPUSH
66518: LD_VAR 0 7
66522: PPUSH
66523: CALL_OW 173
// AddComExitVehicle ( driver ) ;
66527: LD_VAR 0 18
66531: PPUSH
66532: CALL_OW 181
// end ; continue ;
66536: GO 66188
// end ; if not cleaners or not tmp in cleaners then
66538: LD_VAR 0 6
66542: NOT
66543: PUSH
66544: LD_VAR 0 13
66548: PUSH
66549: LD_VAR 0 6
66553: IN
66554: NOT
66555: OR
66556: IFFALSE 66863
// begin if dep then
66558: LD_VAR 0 17
66562: IFFALSE 66698
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
66564: LD_ADDR_VAR 0 16
66568: PUSH
66569: LD_VAR 0 17
66573: PUSH
66574: LD_INT 1
66576: ARRAY
66577: PPUSH
66578: CALL_OW 250
66582: PPUSH
66583: LD_VAR 0 17
66587: PUSH
66588: LD_INT 1
66590: ARRAY
66591: PPUSH
66592: CALL_OW 254
66596: PPUSH
66597: LD_INT 5
66599: PPUSH
66600: CALL_OW 272
66604: PUSH
66605: LD_VAR 0 17
66609: PUSH
66610: LD_INT 1
66612: ARRAY
66613: PPUSH
66614: CALL_OW 251
66618: PPUSH
66619: LD_VAR 0 17
66623: PUSH
66624: LD_INT 1
66626: ARRAY
66627: PPUSH
66628: CALL_OW 254
66632: PPUSH
66633: LD_INT 5
66635: PPUSH
66636: CALL_OW 273
66640: PUSH
66641: EMPTY
66642: LIST
66643: LIST
66644: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
66645: LD_VAR 0 16
66649: PUSH
66650: LD_INT 1
66652: ARRAY
66653: PPUSH
66654: LD_VAR 0 16
66658: PUSH
66659: LD_INT 2
66661: ARRAY
66662: PPUSH
66663: CALL_OW 488
66667: IFFALSE 66698
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
66669: LD_VAR 0 13
66673: PPUSH
66674: LD_VAR 0 16
66678: PUSH
66679: LD_INT 1
66681: ARRAY
66682: PPUSH
66683: LD_VAR 0 16
66687: PUSH
66688: LD_INT 2
66690: ARRAY
66691: PPUSH
66692: CALL_OW 111
// continue ;
66696: GO 66188
// end ; end ; r := GetDir ( tmp ) ;
66698: LD_ADDR_VAR 0 15
66702: PUSH
66703: LD_VAR 0 13
66707: PPUSH
66708: CALL_OW 254
66712: ST_TO_ADDR
// if r = 5 then
66713: LD_VAR 0 15
66717: PUSH
66718: LD_INT 5
66720: EQUAL
66721: IFFALSE 66731
// r := 0 ;
66723: LD_ADDR_VAR 0 15
66727: PUSH
66728: LD_INT 0
66730: ST_TO_ADDR
// for j = r to 5 do
66731: LD_ADDR_VAR 0 10
66735: PUSH
66736: DOUBLE
66737: LD_VAR 0 15
66741: DEC
66742: ST_TO_ADDR
66743: LD_INT 5
66745: PUSH
66746: FOR_TO
66747: IFFALSE 66861
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
66749: LD_ADDR_VAR 0 11
66753: PUSH
66754: LD_VAR 0 13
66758: PPUSH
66759: CALL_OW 250
66763: PPUSH
66764: LD_VAR 0 10
66768: PPUSH
66769: LD_INT 2
66771: PPUSH
66772: CALL_OW 272
66776: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
66777: LD_ADDR_VAR 0 12
66781: PUSH
66782: LD_VAR 0 13
66786: PPUSH
66787: CALL_OW 251
66791: PPUSH
66792: LD_VAR 0 10
66796: PPUSH
66797: LD_INT 2
66799: PPUSH
66800: CALL_OW 273
66804: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
66805: LD_VAR 0 11
66809: PPUSH
66810: LD_VAR 0 12
66814: PPUSH
66815: CALL_OW 488
66819: PUSH
66820: LD_VAR 0 11
66824: PPUSH
66825: LD_VAR 0 12
66829: PPUSH
66830: CALL_OW 428
66834: NOT
66835: AND
66836: IFFALSE 66859
// begin ComMoveXY ( tmp , _x , _y ) ;
66838: LD_VAR 0 13
66842: PPUSH
66843: LD_VAR 0 11
66847: PPUSH
66848: LD_VAR 0 12
66852: PPUSH
66853: CALL_OW 111
// break ;
66857: GO 66861
// end ; end ;
66859: GO 66746
66861: POP
66862: POP
// end ; end ;
66863: GO 66188
66865: POP
66866: POP
// end ;
66867: LD_VAR 0 8
66871: RET
// export function BuildingTechInvented ( side , btype ) ; begin
66872: LD_INT 0
66874: PPUSH
// result := true ;
66875: LD_ADDR_VAR 0 3
66879: PUSH
66880: LD_INT 1
66882: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
66883: LD_VAR 0 2
66887: PUSH
66888: LD_INT 24
66890: DOUBLE
66891: EQUAL
66892: IFTRUE 66902
66894: LD_INT 33
66896: DOUBLE
66897: EQUAL
66898: IFTRUE 66902
66900: GO 66927
66902: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
66903: LD_ADDR_VAR 0 3
66907: PUSH
66908: LD_INT 32
66910: PPUSH
66911: LD_VAR 0 1
66915: PPUSH
66916: CALL_OW 321
66920: PUSH
66921: LD_INT 2
66923: EQUAL
66924: ST_TO_ADDR
66925: GO 67243
66927: LD_INT 20
66929: DOUBLE
66930: EQUAL
66931: IFTRUE 66935
66933: GO 66960
66935: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
66936: LD_ADDR_VAR 0 3
66940: PUSH
66941: LD_INT 6
66943: PPUSH
66944: LD_VAR 0 1
66948: PPUSH
66949: CALL_OW 321
66953: PUSH
66954: LD_INT 2
66956: EQUAL
66957: ST_TO_ADDR
66958: GO 67243
66960: LD_INT 22
66962: DOUBLE
66963: EQUAL
66964: IFTRUE 66974
66966: LD_INT 36
66968: DOUBLE
66969: EQUAL
66970: IFTRUE 66974
66972: GO 66999
66974: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
66975: LD_ADDR_VAR 0 3
66979: PUSH
66980: LD_INT 15
66982: PPUSH
66983: LD_VAR 0 1
66987: PPUSH
66988: CALL_OW 321
66992: PUSH
66993: LD_INT 2
66995: EQUAL
66996: ST_TO_ADDR
66997: GO 67243
66999: LD_INT 30
67001: DOUBLE
67002: EQUAL
67003: IFTRUE 67007
67005: GO 67032
67007: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
67008: LD_ADDR_VAR 0 3
67012: PUSH
67013: LD_INT 20
67015: PPUSH
67016: LD_VAR 0 1
67020: PPUSH
67021: CALL_OW 321
67025: PUSH
67026: LD_INT 2
67028: EQUAL
67029: ST_TO_ADDR
67030: GO 67243
67032: LD_INT 28
67034: DOUBLE
67035: EQUAL
67036: IFTRUE 67046
67038: LD_INT 21
67040: DOUBLE
67041: EQUAL
67042: IFTRUE 67046
67044: GO 67071
67046: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
67047: LD_ADDR_VAR 0 3
67051: PUSH
67052: LD_INT 21
67054: PPUSH
67055: LD_VAR 0 1
67059: PPUSH
67060: CALL_OW 321
67064: PUSH
67065: LD_INT 2
67067: EQUAL
67068: ST_TO_ADDR
67069: GO 67243
67071: LD_INT 16
67073: DOUBLE
67074: EQUAL
67075: IFTRUE 67079
67077: GO 67104
67079: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
67080: LD_ADDR_VAR 0 3
67084: PUSH
67085: LD_INT 84
67087: PPUSH
67088: LD_VAR 0 1
67092: PPUSH
67093: CALL_OW 321
67097: PUSH
67098: LD_INT 2
67100: EQUAL
67101: ST_TO_ADDR
67102: GO 67243
67104: LD_INT 19
67106: DOUBLE
67107: EQUAL
67108: IFTRUE 67118
67110: LD_INT 23
67112: DOUBLE
67113: EQUAL
67114: IFTRUE 67118
67116: GO 67143
67118: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
67119: LD_ADDR_VAR 0 3
67123: PUSH
67124: LD_INT 83
67126: PPUSH
67127: LD_VAR 0 1
67131: PPUSH
67132: CALL_OW 321
67136: PUSH
67137: LD_INT 2
67139: EQUAL
67140: ST_TO_ADDR
67141: GO 67243
67143: LD_INT 17
67145: DOUBLE
67146: EQUAL
67147: IFTRUE 67151
67149: GO 67176
67151: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
67152: LD_ADDR_VAR 0 3
67156: PUSH
67157: LD_INT 39
67159: PPUSH
67160: LD_VAR 0 1
67164: PPUSH
67165: CALL_OW 321
67169: PUSH
67170: LD_INT 2
67172: EQUAL
67173: ST_TO_ADDR
67174: GO 67243
67176: LD_INT 18
67178: DOUBLE
67179: EQUAL
67180: IFTRUE 67184
67182: GO 67209
67184: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
67185: LD_ADDR_VAR 0 3
67189: PUSH
67190: LD_INT 40
67192: PPUSH
67193: LD_VAR 0 1
67197: PPUSH
67198: CALL_OW 321
67202: PUSH
67203: LD_INT 2
67205: EQUAL
67206: ST_TO_ADDR
67207: GO 67243
67209: LD_INT 27
67211: DOUBLE
67212: EQUAL
67213: IFTRUE 67217
67215: GO 67242
67217: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
67218: LD_ADDR_VAR 0 3
67222: PUSH
67223: LD_INT 35
67225: PPUSH
67226: LD_VAR 0 1
67230: PPUSH
67231: CALL_OW 321
67235: PUSH
67236: LD_INT 2
67238: EQUAL
67239: ST_TO_ADDR
67240: GO 67243
67242: POP
// end ;
67243: LD_VAR 0 3
67247: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
67248: LD_INT 0
67250: PPUSH
67251: PPUSH
67252: PPUSH
67253: PPUSH
67254: PPUSH
67255: PPUSH
67256: PPUSH
67257: PPUSH
67258: PPUSH
67259: PPUSH
67260: PPUSH
// result := false ;
67261: LD_ADDR_VAR 0 6
67265: PUSH
67266: LD_INT 0
67268: ST_TO_ADDR
// if btype = b_depot then
67269: LD_VAR 0 2
67273: PUSH
67274: LD_INT 0
67276: EQUAL
67277: IFFALSE 67289
// begin result := true ;
67279: LD_ADDR_VAR 0 6
67283: PUSH
67284: LD_INT 1
67286: ST_TO_ADDR
// exit ;
67287: GO 68115
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
67289: LD_VAR 0 1
67293: NOT
67294: PUSH
67295: LD_VAR 0 1
67299: PPUSH
67300: CALL_OW 266
67304: PUSH
67305: LD_INT 0
67307: PUSH
67308: LD_INT 1
67310: PUSH
67311: EMPTY
67312: LIST
67313: LIST
67314: IN
67315: NOT
67316: OR
67317: PUSH
67318: LD_VAR 0 2
67322: NOT
67323: OR
67324: PUSH
67325: LD_VAR 0 5
67329: PUSH
67330: LD_INT 0
67332: PUSH
67333: LD_INT 1
67335: PUSH
67336: LD_INT 2
67338: PUSH
67339: LD_INT 3
67341: PUSH
67342: LD_INT 4
67344: PUSH
67345: LD_INT 5
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: LIST
67352: LIST
67353: LIST
67354: LIST
67355: IN
67356: NOT
67357: OR
67358: PUSH
67359: LD_VAR 0 3
67363: PPUSH
67364: LD_VAR 0 4
67368: PPUSH
67369: CALL_OW 488
67373: NOT
67374: OR
67375: IFFALSE 67379
// exit ;
67377: GO 68115
// side := GetSide ( depot ) ;
67379: LD_ADDR_VAR 0 9
67383: PUSH
67384: LD_VAR 0 1
67388: PPUSH
67389: CALL_OW 255
67393: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
67394: LD_VAR 0 9
67398: PPUSH
67399: LD_VAR 0 2
67403: PPUSH
67404: CALL 66872 0 2
67408: NOT
67409: IFFALSE 67413
// exit ;
67411: GO 68115
// pom := GetBase ( depot ) ;
67413: LD_ADDR_VAR 0 10
67417: PUSH
67418: LD_VAR 0 1
67422: PPUSH
67423: CALL_OW 274
67427: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
67428: LD_ADDR_VAR 0 11
67432: PUSH
67433: LD_VAR 0 2
67437: PPUSH
67438: LD_VAR 0 1
67442: PPUSH
67443: CALL_OW 248
67447: PPUSH
67448: CALL_OW 450
67452: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
67453: LD_VAR 0 10
67457: PPUSH
67458: LD_INT 1
67460: PPUSH
67461: CALL_OW 275
67465: PUSH
67466: LD_VAR 0 11
67470: PUSH
67471: LD_INT 1
67473: ARRAY
67474: GREATEREQUAL
67475: PUSH
67476: LD_VAR 0 10
67480: PPUSH
67481: LD_INT 2
67483: PPUSH
67484: CALL_OW 275
67488: PUSH
67489: LD_VAR 0 11
67493: PUSH
67494: LD_INT 2
67496: ARRAY
67497: GREATEREQUAL
67498: AND
67499: PUSH
67500: LD_VAR 0 10
67504: PPUSH
67505: LD_INT 3
67507: PPUSH
67508: CALL_OW 275
67512: PUSH
67513: LD_VAR 0 11
67517: PUSH
67518: LD_INT 3
67520: ARRAY
67521: GREATEREQUAL
67522: AND
67523: NOT
67524: IFFALSE 67528
// exit ;
67526: GO 68115
// if GetBType ( depot ) = b_depot then
67528: LD_VAR 0 1
67532: PPUSH
67533: CALL_OW 266
67537: PUSH
67538: LD_INT 0
67540: EQUAL
67541: IFFALSE 67553
// dist := 28 else
67543: LD_ADDR_VAR 0 14
67547: PUSH
67548: LD_INT 28
67550: ST_TO_ADDR
67551: GO 67561
// dist := 36 ;
67553: LD_ADDR_VAR 0 14
67557: PUSH
67558: LD_INT 36
67560: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
67561: LD_VAR 0 1
67565: PPUSH
67566: LD_VAR 0 3
67570: PPUSH
67571: LD_VAR 0 4
67575: PPUSH
67576: CALL_OW 297
67580: PUSH
67581: LD_VAR 0 14
67585: GREATER
67586: IFFALSE 67590
// exit ;
67588: GO 68115
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
67590: LD_ADDR_VAR 0 12
67594: PUSH
67595: LD_VAR 0 2
67599: PPUSH
67600: LD_VAR 0 3
67604: PPUSH
67605: LD_VAR 0 4
67609: PPUSH
67610: LD_VAR 0 5
67614: PPUSH
67615: LD_VAR 0 1
67619: PPUSH
67620: CALL_OW 248
67624: PPUSH
67625: LD_INT 0
67627: PPUSH
67628: CALL 68120 0 6
67632: ST_TO_ADDR
// if not hexes then
67633: LD_VAR 0 12
67637: NOT
67638: IFFALSE 67642
// exit ;
67640: GO 68115
// hex := GetHexInfo ( x , y ) ;
67642: LD_ADDR_VAR 0 15
67646: PUSH
67647: LD_VAR 0 3
67651: PPUSH
67652: LD_VAR 0 4
67656: PPUSH
67657: CALL_OW 546
67661: ST_TO_ADDR
// if hex [ 1 ] then
67662: LD_VAR 0 15
67666: PUSH
67667: LD_INT 1
67669: ARRAY
67670: IFFALSE 67674
// exit ;
67672: GO 68115
// height := hex [ 2 ] ;
67674: LD_ADDR_VAR 0 13
67678: PUSH
67679: LD_VAR 0 15
67683: PUSH
67684: LD_INT 2
67686: ARRAY
67687: ST_TO_ADDR
// for i = 1 to hexes do
67688: LD_ADDR_VAR 0 7
67692: PUSH
67693: DOUBLE
67694: LD_INT 1
67696: DEC
67697: ST_TO_ADDR
67698: LD_VAR 0 12
67702: PUSH
67703: FOR_TO
67704: IFFALSE 68034
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
67706: LD_VAR 0 12
67710: PUSH
67711: LD_VAR 0 7
67715: ARRAY
67716: PUSH
67717: LD_INT 1
67719: ARRAY
67720: PPUSH
67721: LD_VAR 0 12
67725: PUSH
67726: LD_VAR 0 7
67730: ARRAY
67731: PUSH
67732: LD_INT 2
67734: ARRAY
67735: PPUSH
67736: CALL_OW 488
67740: NOT
67741: PUSH
67742: LD_VAR 0 12
67746: PUSH
67747: LD_VAR 0 7
67751: ARRAY
67752: PUSH
67753: LD_INT 1
67755: ARRAY
67756: PPUSH
67757: LD_VAR 0 12
67761: PUSH
67762: LD_VAR 0 7
67766: ARRAY
67767: PUSH
67768: LD_INT 2
67770: ARRAY
67771: PPUSH
67772: CALL_OW 428
67776: PUSH
67777: LD_INT 0
67779: GREATER
67780: OR
67781: PUSH
67782: LD_VAR 0 12
67786: PUSH
67787: LD_VAR 0 7
67791: ARRAY
67792: PUSH
67793: LD_INT 1
67795: ARRAY
67796: PPUSH
67797: LD_VAR 0 12
67801: PUSH
67802: LD_VAR 0 7
67806: ARRAY
67807: PUSH
67808: LD_INT 2
67810: ARRAY
67811: PPUSH
67812: CALL_OW 351
67816: OR
67817: IFFALSE 67823
// exit ;
67819: POP
67820: POP
67821: GO 68115
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
67823: LD_ADDR_VAR 0 8
67827: PUSH
67828: LD_VAR 0 12
67832: PUSH
67833: LD_VAR 0 7
67837: ARRAY
67838: PUSH
67839: LD_INT 1
67841: ARRAY
67842: PPUSH
67843: LD_VAR 0 12
67847: PUSH
67848: LD_VAR 0 7
67852: ARRAY
67853: PUSH
67854: LD_INT 2
67856: ARRAY
67857: PPUSH
67858: CALL_OW 546
67862: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
67863: LD_VAR 0 8
67867: PUSH
67868: LD_INT 1
67870: ARRAY
67871: PUSH
67872: LD_VAR 0 8
67876: PUSH
67877: LD_INT 2
67879: ARRAY
67880: PUSH
67881: LD_VAR 0 13
67885: PUSH
67886: LD_INT 2
67888: PLUS
67889: GREATER
67890: OR
67891: PUSH
67892: LD_VAR 0 8
67896: PUSH
67897: LD_INT 2
67899: ARRAY
67900: PUSH
67901: LD_VAR 0 13
67905: PUSH
67906: LD_INT 2
67908: MINUS
67909: LESS
67910: OR
67911: PUSH
67912: LD_VAR 0 8
67916: PUSH
67917: LD_INT 3
67919: ARRAY
67920: PUSH
67921: LD_INT 0
67923: PUSH
67924: LD_INT 8
67926: PUSH
67927: LD_INT 9
67929: PUSH
67930: LD_INT 10
67932: PUSH
67933: LD_INT 11
67935: PUSH
67936: LD_INT 12
67938: PUSH
67939: LD_INT 13
67941: PUSH
67942: LD_INT 16
67944: PUSH
67945: LD_INT 17
67947: PUSH
67948: LD_INT 18
67950: PUSH
67951: LD_INT 19
67953: PUSH
67954: LD_INT 20
67956: PUSH
67957: LD_INT 21
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: LIST
67964: LIST
67965: LIST
67966: LIST
67967: LIST
67968: LIST
67969: LIST
67970: LIST
67971: LIST
67972: LIST
67973: LIST
67974: IN
67975: NOT
67976: OR
67977: PUSH
67978: LD_VAR 0 8
67982: PUSH
67983: LD_INT 5
67985: ARRAY
67986: NOT
67987: OR
67988: PUSH
67989: LD_VAR 0 8
67993: PUSH
67994: LD_INT 6
67996: ARRAY
67997: PUSH
67998: LD_INT 1
68000: PUSH
68001: LD_INT 2
68003: PUSH
68004: LD_INT 7
68006: PUSH
68007: LD_INT 9
68009: PUSH
68010: LD_INT 10
68012: PUSH
68013: LD_INT 11
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: LIST
68020: LIST
68021: LIST
68022: LIST
68023: IN
68024: NOT
68025: OR
68026: IFFALSE 68032
// exit ;
68028: POP
68029: POP
68030: GO 68115
// end ;
68032: GO 67703
68034: POP
68035: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
68036: LD_VAR 0 9
68040: PPUSH
68041: LD_VAR 0 3
68045: PPUSH
68046: LD_VAR 0 4
68050: PPUSH
68051: LD_INT 20
68053: PPUSH
68054: CALL 60038 0 4
68058: PUSH
68059: LD_INT 4
68061: ARRAY
68062: IFFALSE 68066
// exit ;
68064: GO 68115
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
68066: LD_VAR 0 2
68070: PUSH
68071: LD_INT 29
68073: PUSH
68074: LD_INT 30
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: IN
68081: PUSH
68082: LD_VAR 0 3
68086: PPUSH
68087: LD_VAR 0 4
68091: PPUSH
68092: LD_VAR 0 9
68096: PPUSH
68097: CALL_OW 440
68101: NOT
68102: AND
68103: IFFALSE 68107
// exit ;
68105: GO 68115
// result := true ;
68107: LD_ADDR_VAR 0 6
68111: PUSH
68112: LD_INT 1
68114: ST_TO_ADDR
// end ;
68115: LD_VAR 0 6
68119: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
68120: LD_INT 0
68122: PPUSH
68123: PPUSH
68124: PPUSH
68125: PPUSH
68126: PPUSH
68127: PPUSH
68128: PPUSH
68129: PPUSH
68130: PPUSH
68131: PPUSH
68132: PPUSH
68133: PPUSH
68134: PPUSH
68135: PPUSH
68136: PPUSH
68137: PPUSH
68138: PPUSH
68139: PPUSH
68140: PPUSH
68141: PPUSH
68142: PPUSH
68143: PPUSH
68144: PPUSH
68145: PPUSH
68146: PPUSH
68147: PPUSH
68148: PPUSH
68149: PPUSH
68150: PPUSH
68151: PPUSH
68152: PPUSH
68153: PPUSH
68154: PPUSH
68155: PPUSH
68156: PPUSH
68157: PPUSH
68158: PPUSH
68159: PPUSH
68160: PPUSH
68161: PPUSH
68162: PPUSH
68163: PPUSH
68164: PPUSH
68165: PPUSH
68166: PPUSH
68167: PPUSH
68168: PPUSH
68169: PPUSH
68170: PPUSH
68171: PPUSH
68172: PPUSH
68173: PPUSH
68174: PPUSH
68175: PPUSH
68176: PPUSH
68177: PPUSH
68178: PPUSH
68179: PPUSH
// result = [ ] ;
68180: LD_ADDR_VAR 0 7
68184: PUSH
68185: EMPTY
68186: ST_TO_ADDR
// temp_list = [ ] ;
68187: LD_ADDR_VAR 0 9
68191: PUSH
68192: EMPTY
68193: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
68194: LD_VAR 0 4
68198: PUSH
68199: LD_INT 0
68201: PUSH
68202: LD_INT 1
68204: PUSH
68205: LD_INT 2
68207: PUSH
68208: LD_INT 3
68210: PUSH
68211: LD_INT 4
68213: PUSH
68214: LD_INT 5
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: LIST
68224: IN
68225: NOT
68226: PUSH
68227: LD_VAR 0 1
68231: PUSH
68232: LD_INT 0
68234: PUSH
68235: LD_INT 1
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: IN
68242: PUSH
68243: LD_VAR 0 5
68247: PUSH
68248: LD_INT 1
68250: PUSH
68251: LD_INT 2
68253: PUSH
68254: LD_INT 3
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: LIST
68261: IN
68262: NOT
68263: AND
68264: OR
68265: IFFALSE 68269
// exit ;
68267: GO 86660
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
68269: LD_VAR 0 1
68273: PUSH
68274: LD_INT 6
68276: PUSH
68277: LD_INT 7
68279: PUSH
68280: LD_INT 8
68282: PUSH
68283: LD_INT 13
68285: PUSH
68286: LD_INT 12
68288: PUSH
68289: LD_INT 15
68291: PUSH
68292: LD_INT 11
68294: PUSH
68295: LD_INT 14
68297: PUSH
68298: LD_INT 10
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: IN
68312: IFFALSE 68322
// btype = b_lab ;
68314: LD_ADDR_VAR 0 1
68318: PUSH
68319: LD_INT 6
68321: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
68322: LD_VAR 0 6
68326: PUSH
68327: LD_INT 0
68329: PUSH
68330: LD_INT 1
68332: PUSH
68333: LD_INT 2
68335: PUSH
68336: EMPTY
68337: LIST
68338: LIST
68339: LIST
68340: IN
68341: NOT
68342: PUSH
68343: LD_VAR 0 1
68347: PUSH
68348: LD_INT 0
68350: PUSH
68351: LD_INT 1
68353: PUSH
68354: LD_INT 2
68356: PUSH
68357: LD_INT 3
68359: PUSH
68360: LD_INT 6
68362: PUSH
68363: LD_INT 36
68365: PUSH
68366: LD_INT 4
68368: PUSH
68369: LD_INT 5
68371: PUSH
68372: LD_INT 31
68374: PUSH
68375: LD_INT 32
68377: PUSH
68378: LD_INT 33
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: IN
68394: NOT
68395: PUSH
68396: LD_VAR 0 6
68400: PUSH
68401: LD_INT 1
68403: EQUAL
68404: AND
68405: OR
68406: PUSH
68407: LD_VAR 0 1
68411: PUSH
68412: LD_INT 2
68414: PUSH
68415: LD_INT 3
68417: PUSH
68418: EMPTY
68419: LIST
68420: LIST
68421: IN
68422: NOT
68423: PUSH
68424: LD_VAR 0 6
68428: PUSH
68429: LD_INT 2
68431: EQUAL
68432: AND
68433: OR
68434: IFFALSE 68444
// mode = 0 ;
68436: LD_ADDR_VAR 0 6
68440: PUSH
68441: LD_INT 0
68443: ST_TO_ADDR
// case mode of 0 :
68444: LD_VAR 0 6
68448: PUSH
68449: LD_INT 0
68451: DOUBLE
68452: EQUAL
68453: IFTRUE 68457
68455: GO 79910
68457: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
68458: LD_ADDR_VAR 0 11
68462: PUSH
68463: LD_INT 0
68465: PUSH
68466: LD_INT 0
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: PUSH
68473: LD_INT 0
68475: PUSH
68476: LD_INT 1
68478: NEG
68479: PUSH
68480: EMPTY
68481: LIST
68482: LIST
68483: PUSH
68484: LD_INT 1
68486: PUSH
68487: LD_INT 0
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 1
68496: PUSH
68497: LD_INT 1
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PUSH
68504: LD_INT 0
68506: PUSH
68507: LD_INT 1
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 1
68516: NEG
68517: PUSH
68518: LD_INT 0
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 1
68527: NEG
68528: PUSH
68529: LD_INT 1
68531: NEG
68532: PUSH
68533: EMPTY
68534: LIST
68535: LIST
68536: PUSH
68537: LD_INT 1
68539: NEG
68540: PUSH
68541: LD_INT 2
68543: NEG
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 0
68551: PUSH
68552: LD_INT 2
68554: NEG
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: PUSH
68560: LD_INT 1
68562: PUSH
68563: LD_INT 1
68565: NEG
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 1
68573: PUSH
68574: LD_INT 2
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 0
68583: PUSH
68584: LD_INT 2
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: LD_INT 1
68593: NEG
68594: PUSH
68595: LD_INT 1
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 1
68604: PUSH
68605: LD_INT 3
68607: PUSH
68608: EMPTY
68609: LIST
68610: LIST
68611: PUSH
68612: LD_INT 0
68614: PUSH
68615: LD_INT 3
68617: PUSH
68618: EMPTY
68619: LIST
68620: LIST
68621: PUSH
68622: LD_INT 1
68624: NEG
68625: PUSH
68626: LD_INT 2
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: LIST
68640: LIST
68641: LIST
68642: LIST
68643: LIST
68644: LIST
68645: LIST
68646: LIST
68647: LIST
68648: LIST
68649: LIST
68650: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68651: LD_ADDR_VAR 0 12
68655: PUSH
68656: LD_INT 0
68658: PUSH
68659: LD_INT 0
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 0
68668: PUSH
68669: LD_INT 1
68671: NEG
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PUSH
68677: LD_INT 1
68679: PUSH
68680: LD_INT 0
68682: PUSH
68683: EMPTY
68684: LIST
68685: LIST
68686: PUSH
68687: LD_INT 1
68689: PUSH
68690: LD_INT 1
68692: PUSH
68693: EMPTY
68694: LIST
68695: LIST
68696: PUSH
68697: LD_INT 0
68699: PUSH
68700: LD_INT 1
68702: PUSH
68703: EMPTY
68704: LIST
68705: LIST
68706: PUSH
68707: LD_INT 1
68709: NEG
68710: PUSH
68711: LD_INT 0
68713: PUSH
68714: EMPTY
68715: LIST
68716: LIST
68717: PUSH
68718: LD_INT 1
68720: NEG
68721: PUSH
68722: LD_INT 1
68724: NEG
68725: PUSH
68726: EMPTY
68727: LIST
68728: LIST
68729: PUSH
68730: LD_INT 1
68732: PUSH
68733: LD_INT 1
68735: NEG
68736: PUSH
68737: EMPTY
68738: LIST
68739: LIST
68740: PUSH
68741: LD_INT 2
68743: PUSH
68744: LD_INT 0
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PUSH
68751: LD_INT 2
68753: PUSH
68754: LD_INT 1
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: PUSH
68761: LD_INT 1
68763: NEG
68764: PUSH
68765: LD_INT 1
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: LD_INT 2
68774: NEG
68775: PUSH
68776: LD_INT 0
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: LD_INT 2
68785: NEG
68786: PUSH
68787: LD_INT 1
68789: NEG
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 2
68797: NEG
68798: PUSH
68799: LD_INT 1
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 3
68808: NEG
68809: PUSH
68810: LD_INT 0
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 3
68819: NEG
68820: PUSH
68821: LD_INT 1
68823: NEG
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: LIST
68833: LIST
68834: LIST
68835: LIST
68836: LIST
68837: LIST
68838: LIST
68839: LIST
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68847: LD_ADDR_VAR 0 13
68851: PUSH
68852: LD_INT 0
68854: PUSH
68855: LD_INT 0
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: LD_INT 0
68864: PUSH
68865: LD_INT 1
68867: NEG
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 1
68875: PUSH
68876: LD_INT 0
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 1
68885: PUSH
68886: LD_INT 1
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: LD_INT 0
68895: PUSH
68896: LD_INT 1
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: LD_INT 1
68905: NEG
68906: PUSH
68907: LD_INT 0
68909: PUSH
68910: EMPTY
68911: LIST
68912: LIST
68913: PUSH
68914: LD_INT 1
68916: NEG
68917: PUSH
68918: LD_INT 1
68920: NEG
68921: PUSH
68922: EMPTY
68923: LIST
68924: LIST
68925: PUSH
68926: LD_INT 1
68928: NEG
68929: PUSH
68930: LD_INT 2
68932: NEG
68933: PUSH
68934: EMPTY
68935: LIST
68936: LIST
68937: PUSH
68938: LD_INT 2
68940: PUSH
68941: LD_INT 1
68943: PUSH
68944: EMPTY
68945: LIST
68946: LIST
68947: PUSH
68948: LD_INT 2
68950: PUSH
68951: LD_INT 2
68953: PUSH
68954: EMPTY
68955: LIST
68956: LIST
68957: PUSH
68958: LD_INT 1
68960: PUSH
68961: LD_INT 2
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 2
68970: NEG
68971: PUSH
68972: LD_INT 1
68974: NEG
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 2
68982: NEG
68983: PUSH
68984: LD_INT 2
68986: NEG
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 2
68994: NEG
68995: PUSH
68996: LD_INT 3
68998: NEG
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 3
69006: NEG
69007: PUSH
69008: LD_INT 2
69010: NEG
69011: PUSH
69012: EMPTY
69013: LIST
69014: LIST
69015: PUSH
69016: LD_INT 3
69018: NEG
69019: PUSH
69020: LD_INT 3
69022: NEG
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PUSH
69028: EMPTY
69029: LIST
69030: LIST
69031: LIST
69032: LIST
69033: LIST
69034: LIST
69035: LIST
69036: LIST
69037: LIST
69038: LIST
69039: LIST
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: LIST
69045: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
69046: LD_ADDR_VAR 0 14
69050: PUSH
69051: LD_INT 0
69053: PUSH
69054: LD_INT 0
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PUSH
69061: LD_INT 0
69063: PUSH
69064: LD_INT 1
69066: NEG
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 1
69074: PUSH
69075: LD_INT 0
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: PUSH
69082: LD_INT 1
69084: PUSH
69085: LD_INT 1
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 0
69094: PUSH
69095: LD_INT 1
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: PUSH
69102: LD_INT 1
69104: NEG
69105: PUSH
69106: LD_INT 0
69108: PUSH
69109: EMPTY
69110: LIST
69111: LIST
69112: PUSH
69113: LD_INT 1
69115: NEG
69116: PUSH
69117: LD_INT 1
69119: NEG
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: PUSH
69125: LD_INT 1
69127: NEG
69128: PUSH
69129: LD_INT 2
69131: NEG
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: LD_INT 0
69139: PUSH
69140: LD_INT 2
69142: NEG
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: LD_INT 1
69150: PUSH
69151: LD_INT 1
69153: NEG
69154: PUSH
69155: EMPTY
69156: LIST
69157: LIST
69158: PUSH
69159: LD_INT 1
69161: PUSH
69162: LD_INT 2
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 0
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: PUSH
69179: LD_INT 1
69181: NEG
69182: PUSH
69183: LD_INT 1
69185: PUSH
69186: EMPTY
69187: LIST
69188: LIST
69189: PUSH
69190: LD_INT 1
69192: NEG
69193: PUSH
69194: LD_INT 3
69196: NEG
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 0
69204: PUSH
69205: LD_INT 3
69207: NEG
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: PUSH
69213: LD_INT 1
69215: PUSH
69216: LD_INT 2
69218: NEG
69219: PUSH
69220: EMPTY
69221: LIST
69222: LIST
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: LIST
69228: LIST
69229: LIST
69230: LIST
69231: LIST
69232: LIST
69233: LIST
69234: LIST
69235: LIST
69236: LIST
69237: LIST
69238: LIST
69239: LIST
69240: LIST
69241: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
69242: LD_ADDR_VAR 0 15
69246: PUSH
69247: LD_INT 0
69249: PUSH
69250: LD_INT 0
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 0
69259: PUSH
69260: LD_INT 1
69262: NEG
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: PUSH
69268: LD_INT 1
69270: PUSH
69271: LD_INT 0
69273: PUSH
69274: EMPTY
69275: LIST
69276: LIST
69277: PUSH
69278: LD_INT 1
69280: PUSH
69281: LD_INT 1
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 0
69290: PUSH
69291: LD_INT 1
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PUSH
69298: LD_INT 1
69300: NEG
69301: PUSH
69302: LD_INT 0
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PUSH
69309: LD_INT 1
69311: NEG
69312: PUSH
69313: LD_INT 1
69315: NEG
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PUSH
69321: LD_INT 1
69323: PUSH
69324: LD_INT 1
69326: NEG
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 2
69334: PUSH
69335: LD_INT 0
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PUSH
69342: LD_INT 2
69344: PUSH
69345: LD_INT 1
69347: PUSH
69348: EMPTY
69349: LIST
69350: LIST
69351: PUSH
69352: LD_INT 1
69354: NEG
69355: PUSH
69356: LD_INT 1
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PUSH
69363: LD_INT 2
69365: NEG
69366: PUSH
69367: LD_INT 0
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: LD_INT 2
69376: NEG
69377: PUSH
69378: LD_INT 1
69380: NEG
69381: PUSH
69382: EMPTY
69383: LIST
69384: LIST
69385: PUSH
69386: LD_INT 2
69388: PUSH
69389: LD_INT 1
69391: NEG
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: PUSH
69397: LD_INT 3
69399: PUSH
69400: LD_INT 0
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 3
69409: PUSH
69410: LD_INT 1
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: PUSH
69417: EMPTY
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: LIST
69434: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
69435: LD_ADDR_VAR 0 16
69439: PUSH
69440: LD_INT 0
69442: PUSH
69443: LD_INT 0
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 0
69452: PUSH
69453: LD_INT 1
69455: NEG
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: PUSH
69461: LD_INT 1
69463: PUSH
69464: LD_INT 0
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PUSH
69471: LD_INT 1
69473: PUSH
69474: LD_INT 1
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: PUSH
69481: LD_INT 0
69483: PUSH
69484: LD_INT 1
69486: PUSH
69487: EMPTY
69488: LIST
69489: LIST
69490: PUSH
69491: LD_INT 1
69493: NEG
69494: PUSH
69495: LD_INT 0
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: PUSH
69502: LD_INT 1
69504: NEG
69505: PUSH
69506: LD_INT 1
69508: NEG
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 1
69516: NEG
69517: PUSH
69518: LD_INT 2
69520: NEG
69521: PUSH
69522: EMPTY
69523: LIST
69524: LIST
69525: PUSH
69526: LD_INT 2
69528: PUSH
69529: LD_INT 1
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: LD_INT 2
69538: PUSH
69539: LD_INT 2
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: PUSH
69546: LD_INT 1
69548: PUSH
69549: LD_INT 2
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PUSH
69556: LD_INT 2
69558: NEG
69559: PUSH
69560: LD_INT 1
69562: NEG
69563: PUSH
69564: EMPTY
69565: LIST
69566: LIST
69567: PUSH
69568: LD_INT 2
69570: NEG
69571: PUSH
69572: LD_INT 2
69574: NEG
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 3
69582: PUSH
69583: LD_INT 2
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: LD_INT 3
69592: PUSH
69593: LD_INT 3
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: PUSH
69600: LD_INT 2
69602: PUSH
69603: LD_INT 3
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: LIST
69614: LIST
69615: LIST
69616: LIST
69617: LIST
69618: LIST
69619: LIST
69620: LIST
69621: LIST
69622: LIST
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69628: LD_ADDR_VAR 0 17
69632: PUSH
69633: LD_INT 0
69635: PUSH
69636: LD_INT 0
69638: PUSH
69639: EMPTY
69640: LIST
69641: LIST
69642: PUSH
69643: LD_INT 0
69645: PUSH
69646: LD_INT 1
69648: NEG
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: LD_INT 1
69656: PUSH
69657: LD_INT 0
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: PUSH
69664: LD_INT 1
69666: PUSH
69667: LD_INT 1
69669: PUSH
69670: EMPTY
69671: LIST
69672: LIST
69673: PUSH
69674: LD_INT 0
69676: PUSH
69677: LD_INT 1
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 1
69686: NEG
69687: PUSH
69688: LD_INT 0
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: PUSH
69695: LD_INT 1
69697: NEG
69698: PUSH
69699: LD_INT 1
69701: NEG
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: PUSH
69707: LD_INT 1
69709: NEG
69710: PUSH
69711: LD_INT 2
69713: NEG
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: PUSH
69719: LD_INT 0
69721: PUSH
69722: LD_INT 2
69724: NEG
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: LD_INT 1
69732: PUSH
69733: LD_INT 1
69735: NEG
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 2
69743: PUSH
69744: LD_INT 0
69746: PUSH
69747: EMPTY
69748: LIST
69749: LIST
69750: PUSH
69751: LD_INT 2
69753: PUSH
69754: LD_INT 1
69756: PUSH
69757: EMPTY
69758: LIST
69759: LIST
69760: PUSH
69761: LD_INT 2
69763: PUSH
69764: LD_INT 2
69766: PUSH
69767: EMPTY
69768: LIST
69769: LIST
69770: PUSH
69771: LD_INT 1
69773: PUSH
69774: LD_INT 2
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 0
69783: PUSH
69784: LD_INT 2
69786: PUSH
69787: EMPTY
69788: LIST
69789: LIST
69790: PUSH
69791: LD_INT 1
69793: NEG
69794: PUSH
69795: LD_INT 1
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 2
69804: NEG
69805: PUSH
69806: LD_INT 0
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: PUSH
69813: LD_INT 2
69815: NEG
69816: PUSH
69817: LD_INT 1
69819: NEG
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PUSH
69825: LD_INT 2
69827: NEG
69828: PUSH
69829: LD_INT 2
69831: NEG
69832: PUSH
69833: EMPTY
69834: LIST
69835: LIST
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: LIST
69841: LIST
69842: LIST
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69858: LD_ADDR_VAR 0 18
69862: PUSH
69863: LD_INT 0
69865: PUSH
69866: LD_INT 0
69868: PUSH
69869: EMPTY
69870: LIST
69871: LIST
69872: PUSH
69873: LD_INT 0
69875: PUSH
69876: LD_INT 1
69878: NEG
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 1
69886: PUSH
69887: LD_INT 0
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: LD_INT 1
69896: PUSH
69897: LD_INT 1
69899: PUSH
69900: EMPTY
69901: LIST
69902: LIST
69903: PUSH
69904: LD_INT 0
69906: PUSH
69907: LD_INT 1
69909: PUSH
69910: EMPTY
69911: LIST
69912: LIST
69913: PUSH
69914: LD_INT 1
69916: NEG
69917: PUSH
69918: LD_INT 0
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: PUSH
69925: LD_INT 1
69927: NEG
69928: PUSH
69929: LD_INT 1
69931: NEG
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: LD_INT 2
69943: NEG
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: PUSH
69949: LD_INT 0
69951: PUSH
69952: LD_INT 2
69954: NEG
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 1
69962: PUSH
69963: LD_INT 1
69965: NEG
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 2
69973: PUSH
69974: LD_INT 0
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 2
69983: PUSH
69984: LD_INT 1
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PUSH
69991: LD_INT 2
69993: PUSH
69994: LD_INT 2
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: PUSH
70001: LD_INT 1
70003: PUSH
70004: LD_INT 2
70006: PUSH
70007: EMPTY
70008: LIST
70009: LIST
70010: PUSH
70011: LD_INT 0
70013: PUSH
70014: LD_INT 2
70016: PUSH
70017: EMPTY
70018: LIST
70019: LIST
70020: PUSH
70021: LD_INT 1
70023: NEG
70024: PUSH
70025: LD_INT 1
70027: PUSH
70028: EMPTY
70029: LIST
70030: LIST
70031: PUSH
70032: LD_INT 2
70034: NEG
70035: PUSH
70036: LD_INT 0
70038: PUSH
70039: EMPTY
70040: LIST
70041: LIST
70042: PUSH
70043: LD_INT 2
70045: NEG
70046: PUSH
70047: LD_INT 1
70049: NEG
70050: PUSH
70051: EMPTY
70052: LIST
70053: LIST
70054: PUSH
70055: LD_INT 2
70057: NEG
70058: PUSH
70059: LD_INT 2
70061: NEG
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: EMPTY
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: LIST
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70088: LD_ADDR_VAR 0 19
70092: PUSH
70093: LD_INT 0
70095: PUSH
70096: LD_INT 0
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: LD_INT 0
70105: PUSH
70106: LD_INT 1
70108: NEG
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 1
70116: PUSH
70117: LD_INT 0
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 1
70126: PUSH
70127: LD_INT 1
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 0
70136: PUSH
70137: LD_INT 1
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: PUSH
70144: LD_INT 1
70146: NEG
70147: PUSH
70148: LD_INT 0
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PUSH
70155: LD_INT 1
70157: NEG
70158: PUSH
70159: LD_INT 1
70161: NEG
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: PUSH
70167: LD_INT 1
70169: NEG
70170: PUSH
70171: LD_INT 2
70173: NEG
70174: PUSH
70175: EMPTY
70176: LIST
70177: LIST
70178: PUSH
70179: LD_INT 0
70181: PUSH
70182: LD_INT 2
70184: NEG
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 1
70192: PUSH
70193: LD_INT 1
70195: NEG
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 2
70203: PUSH
70204: LD_INT 0
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 2
70213: PUSH
70214: LD_INT 1
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 2
70223: PUSH
70224: LD_INT 2
70226: PUSH
70227: EMPTY
70228: LIST
70229: LIST
70230: PUSH
70231: LD_INT 1
70233: PUSH
70234: LD_INT 2
70236: PUSH
70237: EMPTY
70238: LIST
70239: LIST
70240: PUSH
70241: LD_INT 0
70243: PUSH
70244: LD_INT 2
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: PUSH
70251: LD_INT 1
70253: NEG
70254: PUSH
70255: LD_INT 1
70257: PUSH
70258: EMPTY
70259: LIST
70260: LIST
70261: PUSH
70262: LD_INT 2
70264: NEG
70265: PUSH
70266: LD_INT 0
70268: PUSH
70269: EMPTY
70270: LIST
70271: LIST
70272: PUSH
70273: LD_INT 2
70275: NEG
70276: PUSH
70277: LD_INT 1
70279: NEG
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PUSH
70285: LD_INT 2
70287: NEG
70288: PUSH
70289: LD_INT 2
70291: NEG
70292: PUSH
70293: EMPTY
70294: LIST
70295: LIST
70296: PUSH
70297: EMPTY
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70318: LD_ADDR_VAR 0 20
70322: PUSH
70323: LD_INT 0
70325: PUSH
70326: LD_INT 0
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PUSH
70333: LD_INT 0
70335: PUSH
70336: LD_INT 1
70338: NEG
70339: PUSH
70340: EMPTY
70341: LIST
70342: LIST
70343: PUSH
70344: LD_INT 1
70346: PUSH
70347: LD_INT 0
70349: PUSH
70350: EMPTY
70351: LIST
70352: LIST
70353: PUSH
70354: LD_INT 1
70356: PUSH
70357: LD_INT 1
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 0
70366: PUSH
70367: LD_INT 1
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 1
70376: NEG
70377: PUSH
70378: LD_INT 0
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: PUSH
70385: LD_INT 1
70387: NEG
70388: PUSH
70389: LD_INT 1
70391: NEG
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: LD_INT 1
70399: NEG
70400: PUSH
70401: LD_INT 2
70403: NEG
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 0
70411: PUSH
70412: LD_INT 2
70414: NEG
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 1
70422: PUSH
70423: LD_INT 1
70425: NEG
70426: PUSH
70427: EMPTY
70428: LIST
70429: LIST
70430: PUSH
70431: LD_INT 2
70433: PUSH
70434: LD_INT 0
70436: PUSH
70437: EMPTY
70438: LIST
70439: LIST
70440: PUSH
70441: LD_INT 2
70443: PUSH
70444: LD_INT 1
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 2
70453: PUSH
70454: LD_INT 2
70456: PUSH
70457: EMPTY
70458: LIST
70459: LIST
70460: PUSH
70461: LD_INT 1
70463: PUSH
70464: LD_INT 2
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: PUSH
70471: LD_INT 0
70473: PUSH
70474: LD_INT 2
70476: PUSH
70477: EMPTY
70478: LIST
70479: LIST
70480: PUSH
70481: LD_INT 1
70483: NEG
70484: PUSH
70485: LD_INT 1
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: PUSH
70492: LD_INT 2
70494: NEG
70495: PUSH
70496: LD_INT 0
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 2
70505: NEG
70506: PUSH
70507: LD_INT 1
70509: NEG
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: PUSH
70515: LD_INT 2
70517: NEG
70518: PUSH
70519: LD_INT 2
70521: NEG
70522: PUSH
70523: EMPTY
70524: LIST
70525: LIST
70526: PUSH
70527: EMPTY
70528: LIST
70529: LIST
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: LIST
70535: LIST
70536: LIST
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: LIST
70542: LIST
70543: LIST
70544: LIST
70545: LIST
70546: LIST
70547: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70548: LD_ADDR_VAR 0 21
70552: PUSH
70553: LD_INT 0
70555: PUSH
70556: LD_INT 0
70558: PUSH
70559: EMPTY
70560: LIST
70561: LIST
70562: PUSH
70563: LD_INT 0
70565: PUSH
70566: LD_INT 1
70568: NEG
70569: PUSH
70570: EMPTY
70571: LIST
70572: LIST
70573: PUSH
70574: LD_INT 1
70576: PUSH
70577: LD_INT 0
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: PUSH
70584: LD_INT 1
70586: PUSH
70587: LD_INT 1
70589: PUSH
70590: EMPTY
70591: LIST
70592: LIST
70593: PUSH
70594: LD_INT 0
70596: PUSH
70597: LD_INT 1
70599: PUSH
70600: EMPTY
70601: LIST
70602: LIST
70603: PUSH
70604: LD_INT 1
70606: NEG
70607: PUSH
70608: LD_INT 0
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: PUSH
70615: LD_INT 1
70617: NEG
70618: PUSH
70619: LD_INT 1
70621: NEG
70622: PUSH
70623: EMPTY
70624: LIST
70625: LIST
70626: PUSH
70627: LD_INT 1
70629: NEG
70630: PUSH
70631: LD_INT 2
70633: NEG
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 0
70641: PUSH
70642: LD_INT 2
70644: NEG
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: PUSH
70650: LD_INT 1
70652: PUSH
70653: LD_INT 1
70655: NEG
70656: PUSH
70657: EMPTY
70658: LIST
70659: LIST
70660: PUSH
70661: LD_INT 2
70663: PUSH
70664: LD_INT 0
70666: PUSH
70667: EMPTY
70668: LIST
70669: LIST
70670: PUSH
70671: LD_INT 2
70673: PUSH
70674: LD_INT 1
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 2
70683: PUSH
70684: LD_INT 2
70686: PUSH
70687: EMPTY
70688: LIST
70689: LIST
70690: PUSH
70691: LD_INT 1
70693: PUSH
70694: LD_INT 2
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 0
70703: PUSH
70704: LD_INT 2
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PUSH
70711: LD_INT 1
70713: NEG
70714: PUSH
70715: LD_INT 1
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PUSH
70722: LD_INT 2
70724: NEG
70725: PUSH
70726: LD_INT 0
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: LD_INT 2
70735: NEG
70736: PUSH
70737: LD_INT 1
70739: NEG
70740: PUSH
70741: EMPTY
70742: LIST
70743: LIST
70744: PUSH
70745: LD_INT 2
70747: NEG
70748: PUSH
70749: LD_INT 2
70751: NEG
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: LIST
70765: LIST
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70778: LD_ADDR_VAR 0 22
70782: PUSH
70783: LD_INT 0
70785: PUSH
70786: LD_INT 0
70788: PUSH
70789: EMPTY
70790: LIST
70791: LIST
70792: PUSH
70793: LD_INT 0
70795: PUSH
70796: LD_INT 1
70798: NEG
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: PUSH
70804: LD_INT 1
70806: PUSH
70807: LD_INT 0
70809: PUSH
70810: EMPTY
70811: LIST
70812: LIST
70813: PUSH
70814: LD_INT 1
70816: PUSH
70817: LD_INT 1
70819: PUSH
70820: EMPTY
70821: LIST
70822: LIST
70823: PUSH
70824: LD_INT 0
70826: PUSH
70827: LD_INT 1
70829: PUSH
70830: EMPTY
70831: LIST
70832: LIST
70833: PUSH
70834: LD_INT 1
70836: NEG
70837: PUSH
70838: LD_INT 0
70840: PUSH
70841: EMPTY
70842: LIST
70843: LIST
70844: PUSH
70845: LD_INT 1
70847: NEG
70848: PUSH
70849: LD_INT 1
70851: NEG
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: LD_INT 1
70859: NEG
70860: PUSH
70861: LD_INT 2
70863: NEG
70864: PUSH
70865: EMPTY
70866: LIST
70867: LIST
70868: PUSH
70869: LD_INT 0
70871: PUSH
70872: LD_INT 2
70874: NEG
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: PUSH
70880: LD_INT 1
70882: PUSH
70883: LD_INT 1
70885: NEG
70886: PUSH
70887: EMPTY
70888: LIST
70889: LIST
70890: PUSH
70891: LD_INT 2
70893: PUSH
70894: LD_INT 0
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: PUSH
70901: LD_INT 2
70903: PUSH
70904: LD_INT 1
70906: PUSH
70907: EMPTY
70908: LIST
70909: LIST
70910: PUSH
70911: LD_INT 2
70913: PUSH
70914: LD_INT 2
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: PUSH
70921: LD_INT 1
70923: PUSH
70924: LD_INT 2
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: PUSH
70931: LD_INT 0
70933: PUSH
70934: LD_INT 2
70936: PUSH
70937: EMPTY
70938: LIST
70939: LIST
70940: PUSH
70941: LD_INT 1
70943: NEG
70944: PUSH
70945: LD_INT 1
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: PUSH
70952: LD_INT 2
70954: NEG
70955: PUSH
70956: LD_INT 0
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: PUSH
70963: LD_INT 2
70965: NEG
70966: PUSH
70967: LD_INT 1
70969: NEG
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PUSH
70975: LD_INT 2
70977: NEG
70978: PUSH
70979: LD_INT 2
70981: NEG
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: LIST
70994: LIST
70995: LIST
70996: LIST
70997: LIST
70998: LIST
70999: LIST
71000: LIST
71001: LIST
71002: LIST
71003: LIST
71004: LIST
71005: LIST
71006: LIST
71007: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
71008: LD_ADDR_VAR 0 23
71012: PUSH
71013: LD_INT 0
71015: PUSH
71016: LD_INT 0
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 0
71025: PUSH
71026: LD_INT 1
71028: NEG
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PUSH
71034: LD_INT 1
71036: PUSH
71037: LD_INT 0
71039: PUSH
71040: EMPTY
71041: LIST
71042: LIST
71043: PUSH
71044: LD_INT 1
71046: PUSH
71047: LD_INT 1
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: PUSH
71054: LD_INT 0
71056: PUSH
71057: LD_INT 1
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: PUSH
71064: LD_INT 1
71066: NEG
71067: PUSH
71068: LD_INT 0
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: LD_INT 1
71077: NEG
71078: PUSH
71079: LD_INT 1
71081: NEG
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 1
71089: NEG
71090: PUSH
71091: LD_INT 2
71093: NEG
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: PUSH
71099: LD_INT 0
71101: PUSH
71102: LD_INT 2
71104: NEG
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: PUSH
71110: LD_INT 1
71112: PUSH
71113: LD_INT 1
71115: NEG
71116: PUSH
71117: EMPTY
71118: LIST
71119: LIST
71120: PUSH
71121: LD_INT 2
71123: PUSH
71124: LD_INT 0
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: PUSH
71131: LD_INT 2
71133: PUSH
71134: LD_INT 1
71136: PUSH
71137: EMPTY
71138: LIST
71139: LIST
71140: PUSH
71141: LD_INT 2
71143: PUSH
71144: LD_INT 2
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: LD_INT 1
71153: PUSH
71154: LD_INT 2
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PUSH
71161: LD_INT 0
71163: PUSH
71164: LD_INT 2
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 1
71173: NEG
71174: PUSH
71175: LD_INT 1
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 2
71184: NEG
71185: PUSH
71186: LD_INT 0
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 2
71195: NEG
71196: PUSH
71197: LD_INT 1
71199: NEG
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: LD_INT 2
71207: NEG
71208: PUSH
71209: LD_INT 2
71211: NEG
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: PUSH
71217: LD_INT 2
71219: NEG
71220: PUSH
71221: LD_INT 3
71223: NEG
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: PUSH
71229: LD_INT 1
71231: NEG
71232: PUSH
71233: LD_INT 3
71235: NEG
71236: PUSH
71237: EMPTY
71238: LIST
71239: LIST
71240: PUSH
71241: LD_INT 1
71243: PUSH
71244: LD_INT 2
71246: NEG
71247: PUSH
71248: EMPTY
71249: LIST
71250: LIST
71251: PUSH
71252: LD_INT 2
71254: PUSH
71255: LD_INT 1
71257: NEG
71258: PUSH
71259: EMPTY
71260: LIST
71261: LIST
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: LIST
71279: LIST
71280: LIST
71281: LIST
71282: LIST
71283: LIST
71284: LIST
71285: LIST
71286: LIST
71287: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
71288: LD_ADDR_VAR 0 24
71292: PUSH
71293: LD_INT 0
71295: PUSH
71296: LD_INT 0
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 0
71305: PUSH
71306: LD_INT 1
71308: NEG
71309: PUSH
71310: EMPTY
71311: LIST
71312: LIST
71313: PUSH
71314: LD_INT 1
71316: PUSH
71317: LD_INT 0
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: PUSH
71324: LD_INT 1
71326: PUSH
71327: LD_INT 1
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PUSH
71334: LD_INT 0
71336: PUSH
71337: LD_INT 1
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: LD_INT 1
71346: NEG
71347: PUSH
71348: LD_INT 0
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: LD_INT 1
71357: NEG
71358: PUSH
71359: LD_INT 1
71361: NEG
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 1
71369: NEG
71370: PUSH
71371: LD_INT 2
71373: NEG
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PUSH
71379: LD_INT 0
71381: PUSH
71382: LD_INT 2
71384: NEG
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PUSH
71390: LD_INT 1
71392: PUSH
71393: LD_INT 1
71395: NEG
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: PUSH
71401: LD_INT 2
71403: PUSH
71404: LD_INT 0
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: PUSH
71411: LD_INT 2
71413: PUSH
71414: LD_INT 1
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: PUSH
71421: LD_INT 2
71423: PUSH
71424: LD_INT 2
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: LD_INT 1
71433: PUSH
71434: LD_INT 2
71436: PUSH
71437: EMPTY
71438: LIST
71439: LIST
71440: PUSH
71441: LD_INT 0
71443: PUSH
71444: LD_INT 2
71446: PUSH
71447: EMPTY
71448: LIST
71449: LIST
71450: PUSH
71451: LD_INT 1
71453: NEG
71454: PUSH
71455: LD_INT 1
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: LD_INT 2
71464: NEG
71465: PUSH
71466: LD_INT 0
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 2
71475: NEG
71476: PUSH
71477: LD_INT 1
71479: NEG
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: PUSH
71485: LD_INT 2
71487: NEG
71488: PUSH
71489: LD_INT 2
71491: NEG
71492: PUSH
71493: EMPTY
71494: LIST
71495: LIST
71496: PUSH
71497: LD_INT 1
71499: PUSH
71500: LD_INT 2
71502: NEG
71503: PUSH
71504: EMPTY
71505: LIST
71506: LIST
71507: PUSH
71508: LD_INT 2
71510: PUSH
71511: LD_INT 1
71513: NEG
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 3
71521: PUSH
71522: LD_INT 1
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 3
71531: PUSH
71532: LD_INT 2
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: LIST
71543: LIST
71544: LIST
71545: LIST
71546: LIST
71547: LIST
71548: LIST
71549: LIST
71550: LIST
71551: LIST
71552: LIST
71553: LIST
71554: LIST
71555: LIST
71556: LIST
71557: LIST
71558: LIST
71559: LIST
71560: LIST
71561: LIST
71562: LIST
71563: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
71564: LD_ADDR_VAR 0 25
71568: PUSH
71569: LD_INT 0
71571: PUSH
71572: LD_INT 0
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PUSH
71579: LD_INT 0
71581: PUSH
71582: LD_INT 1
71584: NEG
71585: PUSH
71586: EMPTY
71587: LIST
71588: LIST
71589: PUSH
71590: LD_INT 1
71592: PUSH
71593: LD_INT 0
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: PUSH
71600: LD_INT 1
71602: PUSH
71603: LD_INT 1
71605: PUSH
71606: EMPTY
71607: LIST
71608: LIST
71609: PUSH
71610: LD_INT 0
71612: PUSH
71613: LD_INT 1
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: PUSH
71620: LD_INT 1
71622: NEG
71623: PUSH
71624: LD_INT 0
71626: PUSH
71627: EMPTY
71628: LIST
71629: LIST
71630: PUSH
71631: LD_INT 1
71633: NEG
71634: PUSH
71635: LD_INT 1
71637: NEG
71638: PUSH
71639: EMPTY
71640: LIST
71641: LIST
71642: PUSH
71643: LD_INT 1
71645: NEG
71646: PUSH
71647: LD_INT 2
71649: NEG
71650: PUSH
71651: EMPTY
71652: LIST
71653: LIST
71654: PUSH
71655: LD_INT 0
71657: PUSH
71658: LD_INT 2
71660: NEG
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: PUSH
71666: LD_INT 1
71668: PUSH
71669: LD_INT 1
71671: NEG
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: PUSH
71677: LD_INT 2
71679: PUSH
71680: LD_INT 0
71682: PUSH
71683: EMPTY
71684: LIST
71685: LIST
71686: PUSH
71687: LD_INT 2
71689: PUSH
71690: LD_INT 1
71692: PUSH
71693: EMPTY
71694: LIST
71695: LIST
71696: PUSH
71697: LD_INT 2
71699: PUSH
71700: LD_INT 2
71702: PUSH
71703: EMPTY
71704: LIST
71705: LIST
71706: PUSH
71707: LD_INT 1
71709: PUSH
71710: LD_INT 2
71712: PUSH
71713: EMPTY
71714: LIST
71715: LIST
71716: PUSH
71717: LD_INT 0
71719: PUSH
71720: LD_INT 2
71722: PUSH
71723: EMPTY
71724: LIST
71725: LIST
71726: PUSH
71727: LD_INT 1
71729: NEG
71730: PUSH
71731: LD_INT 1
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 2
71740: NEG
71741: PUSH
71742: LD_INT 0
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 2
71751: NEG
71752: PUSH
71753: LD_INT 1
71755: NEG
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 2
71763: NEG
71764: PUSH
71765: LD_INT 2
71767: NEG
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: LD_INT 3
71775: PUSH
71776: LD_INT 1
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: PUSH
71783: LD_INT 3
71785: PUSH
71786: LD_INT 2
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: PUSH
71793: LD_INT 2
71795: PUSH
71796: LD_INT 3
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: PUSH
71803: LD_INT 1
71805: PUSH
71806: LD_INT 3
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: LIST
71817: LIST
71818: LIST
71819: LIST
71820: LIST
71821: LIST
71822: LIST
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: LIST
71828: LIST
71829: LIST
71830: LIST
71831: LIST
71832: LIST
71833: LIST
71834: LIST
71835: LIST
71836: LIST
71837: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
71838: LD_ADDR_VAR 0 26
71842: PUSH
71843: LD_INT 0
71845: PUSH
71846: LD_INT 0
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 0
71855: PUSH
71856: LD_INT 1
71858: NEG
71859: PUSH
71860: EMPTY
71861: LIST
71862: LIST
71863: PUSH
71864: LD_INT 1
71866: PUSH
71867: LD_INT 0
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: PUSH
71874: LD_INT 1
71876: PUSH
71877: LD_INT 1
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 0
71886: PUSH
71887: LD_INT 1
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 1
71896: NEG
71897: PUSH
71898: LD_INT 0
71900: PUSH
71901: EMPTY
71902: LIST
71903: LIST
71904: PUSH
71905: LD_INT 1
71907: NEG
71908: PUSH
71909: LD_INT 1
71911: NEG
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: LD_INT 1
71919: NEG
71920: PUSH
71921: LD_INT 2
71923: NEG
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PUSH
71929: LD_INT 0
71931: PUSH
71932: LD_INT 2
71934: NEG
71935: PUSH
71936: EMPTY
71937: LIST
71938: LIST
71939: PUSH
71940: LD_INT 1
71942: PUSH
71943: LD_INT 1
71945: NEG
71946: PUSH
71947: EMPTY
71948: LIST
71949: LIST
71950: PUSH
71951: LD_INT 2
71953: PUSH
71954: LD_INT 0
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: PUSH
71961: LD_INT 2
71963: PUSH
71964: LD_INT 1
71966: PUSH
71967: EMPTY
71968: LIST
71969: LIST
71970: PUSH
71971: LD_INT 2
71973: PUSH
71974: LD_INT 2
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: PUSH
71981: LD_INT 1
71983: PUSH
71984: LD_INT 2
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: LD_INT 0
71993: PUSH
71994: LD_INT 2
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PUSH
72001: LD_INT 1
72003: NEG
72004: PUSH
72005: LD_INT 1
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: PUSH
72012: LD_INT 2
72014: NEG
72015: PUSH
72016: LD_INT 0
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 2
72025: NEG
72026: PUSH
72027: LD_INT 1
72029: NEG
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 2
72037: NEG
72038: PUSH
72039: LD_INT 2
72041: NEG
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: LD_INT 2
72049: PUSH
72050: LD_INT 3
72052: PUSH
72053: EMPTY
72054: LIST
72055: LIST
72056: PUSH
72057: LD_INT 1
72059: PUSH
72060: LD_INT 3
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: LD_INT 1
72069: NEG
72070: PUSH
72071: LD_INT 2
72073: PUSH
72074: EMPTY
72075: LIST
72076: LIST
72077: PUSH
72078: LD_INT 2
72080: NEG
72081: PUSH
72082: LD_INT 1
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: LIST
72103: LIST
72104: LIST
72105: LIST
72106: LIST
72107: LIST
72108: LIST
72109: LIST
72110: LIST
72111: LIST
72112: LIST
72113: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
72114: LD_ADDR_VAR 0 27
72118: PUSH
72119: LD_INT 0
72121: PUSH
72122: LD_INT 0
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: PUSH
72129: LD_INT 0
72131: PUSH
72132: LD_INT 1
72134: NEG
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: LD_INT 1
72142: PUSH
72143: LD_INT 0
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: PUSH
72150: LD_INT 1
72152: PUSH
72153: LD_INT 1
72155: PUSH
72156: EMPTY
72157: LIST
72158: LIST
72159: PUSH
72160: LD_INT 0
72162: PUSH
72163: LD_INT 1
72165: PUSH
72166: EMPTY
72167: LIST
72168: LIST
72169: PUSH
72170: LD_INT 1
72172: NEG
72173: PUSH
72174: LD_INT 0
72176: PUSH
72177: EMPTY
72178: LIST
72179: LIST
72180: PUSH
72181: LD_INT 1
72183: NEG
72184: PUSH
72185: LD_INT 1
72187: NEG
72188: PUSH
72189: EMPTY
72190: LIST
72191: LIST
72192: PUSH
72193: LD_INT 1
72195: NEG
72196: PUSH
72197: LD_INT 2
72199: NEG
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: PUSH
72205: LD_INT 0
72207: PUSH
72208: LD_INT 2
72210: NEG
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: PUSH
72216: LD_INT 1
72218: PUSH
72219: LD_INT 1
72221: NEG
72222: PUSH
72223: EMPTY
72224: LIST
72225: LIST
72226: PUSH
72227: LD_INT 2
72229: PUSH
72230: LD_INT 0
72232: PUSH
72233: EMPTY
72234: LIST
72235: LIST
72236: PUSH
72237: LD_INT 2
72239: PUSH
72240: LD_INT 1
72242: PUSH
72243: EMPTY
72244: LIST
72245: LIST
72246: PUSH
72247: LD_INT 2
72249: PUSH
72250: LD_INT 2
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PUSH
72257: LD_INT 1
72259: PUSH
72260: LD_INT 2
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 0
72269: PUSH
72270: LD_INT 2
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 1
72279: NEG
72280: PUSH
72281: LD_INT 1
72283: PUSH
72284: EMPTY
72285: LIST
72286: LIST
72287: PUSH
72288: LD_INT 2
72290: NEG
72291: PUSH
72292: LD_INT 0
72294: PUSH
72295: EMPTY
72296: LIST
72297: LIST
72298: PUSH
72299: LD_INT 2
72301: NEG
72302: PUSH
72303: LD_INT 1
72305: NEG
72306: PUSH
72307: EMPTY
72308: LIST
72309: LIST
72310: PUSH
72311: LD_INT 2
72313: NEG
72314: PUSH
72315: LD_INT 2
72317: NEG
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: PUSH
72323: LD_INT 1
72325: NEG
72326: PUSH
72327: LD_INT 2
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: LD_INT 2
72336: NEG
72337: PUSH
72338: LD_INT 1
72340: PUSH
72341: EMPTY
72342: LIST
72343: LIST
72344: PUSH
72345: LD_INT 3
72347: NEG
72348: PUSH
72349: LD_INT 1
72351: NEG
72352: PUSH
72353: EMPTY
72354: LIST
72355: LIST
72356: PUSH
72357: LD_INT 3
72359: NEG
72360: PUSH
72361: LD_INT 2
72363: NEG
72364: PUSH
72365: EMPTY
72366: LIST
72367: LIST
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: LIST
72385: LIST
72386: LIST
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
72394: LD_ADDR_VAR 0 28
72398: PUSH
72399: LD_INT 0
72401: PUSH
72402: LD_INT 0
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 0
72411: PUSH
72412: LD_INT 1
72414: NEG
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PUSH
72420: LD_INT 1
72422: PUSH
72423: LD_INT 0
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 1
72432: PUSH
72433: LD_INT 1
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: PUSH
72440: LD_INT 0
72442: PUSH
72443: LD_INT 1
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: PUSH
72450: LD_INT 1
72452: NEG
72453: PUSH
72454: LD_INT 0
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 1
72463: NEG
72464: PUSH
72465: LD_INT 1
72467: NEG
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: PUSH
72473: LD_INT 1
72475: NEG
72476: PUSH
72477: LD_INT 2
72479: NEG
72480: PUSH
72481: EMPTY
72482: LIST
72483: LIST
72484: PUSH
72485: LD_INT 0
72487: PUSH
72488: LD_INT 2
72490: NEG
72491: PUSH
72492: EMPTY
72493: LIST
72494: LIST
72495: PUSH
72496: LD_INT 1
72498: PUSH
72499: LD_INT 1
72501: NEG
72502: PUSH
72503: EMPTY
72504: LIST
72505: LIST
72506: PUSH
72507: LD_INT 2
72509: PUSH
72510: LD_INT 0
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: LD_INT 2
72519: PUSH
72520: LD_INT 1
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: PUSH
72527: LD_INT 2
72529: PUSH
72530: LD_INT 2
72532: PUSH
72533: EMPTY
72534: LIST
72535: LIST
72536: PUSH
72537: LD_INT 1
72539: PUSH
72540: LD_INT 2
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: PUSH
72547: LD_INT 0
72549: PUSH
72550: LD_INT 2
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 1
72559: NEG
72560: PUSH
72561: LD_INT 1
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 2
72570: NEG
72571: PUSH
72572: LD_INT 0
72574: PUSH
72575: EMPTY
72576: LIST
72577: LIST
72578: PUSH
72579: LD_INT 2
72581: NEG
72582: PUSH
72583: LD_INT 1
72585: NEG
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: PUSH
72591: LD_INT 2
72593: NEG
72594: PUSH
72595: LD_INT 2
72597: NEG
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 2
72605: NEG
72606: PUSH
72607: LD_INT 3
72609: NEG
72610: PUSH
72611: EMPTY
72612: LIST
72613: LIST
72614: PUSH
72615: LD_INT 1
72617: NEG
72618: PUSH
72619: LD_INT 3
72621: NEG
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: PUSH
72627: LD_INT 3
72629: NEG
72630: PUSH
72631: LD_INT 1
72633: NEG
72634: PUSH
72635: EMPTY
72636: LIST
72637: LIST
72638: PUSH
72639: LD_INT 3
72641: NEG
72642: PUSH
72643: LD_INT 2
72645: NEG
72646: PUSH
72647: EMPTY
72648: LIST
72649: LIST
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: LIST
72666: LIST
72667: LIST
72668: LIST
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72676: LD_ADDR_VAR 0 29
72680: PUSH
72681: LD_INT 0
72683: PUSH
72684: LD_INT 0
72686: PUSH
72687: EMPTY
72688: LIST
72689: LIST
72690: PUSH
72691: LD_INT 0
72693: PUSH
72694: LD_INT 1
72696: NEG
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: PUSH
72702: LD_INT 1
72704: PUSH
72705: LD_INT 0
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: PUSH
72712: LD_INT 1
72714: PUSH
72715: LD_INT 1
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: PUSH
72722: LD_INT 0
72724: PUSH
72725: LD_INT 1
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PUSH
72732: LD_INT 1
72734: NEG
72735: PUSH
72736: LD_INT 0
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 1
72745: NEG
72746: PUSH
72747: LD_INT 1
72749: NEG
72750: PUSH
72751: EMPTY
72752: LIST
72753: LIST
72754: PUSH
72755: LD_INT 1
72757: NEG
72758: PUSH
72759: LD_INT 2
72761: NEG
72762: PUSH
72763: EMPTY
72764: LIST
72765: LIST
72766: PUSH
72767: LD_INT 0
72769: PUSH
72770: LD_INT 2
72772: NEG
72773: PUSH
72774: EMPTY
72775: LIST
72776: LIST
72777: PUSH
72778: LD_INT 1
72780: PUSH
72781: LD_INT 1
72783: NEG
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: LD_INT 2
72791: PUSH
72792: LD_INT 0
72794: PUSH
72795: EMPTY
72796: LIST
72797: LIST
72798: PUSH
72799: LD_INT 2
72801: PUSH
72802: LD_INT 1
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: PUSH
72809: LD_INT 1
72811: PUSH
72812: LD_INT 2
72814: PUSH
72815: EMPTY
72816: LIST
72817: LIST
72818: PUSH
72819: LD_INT 0
72821: PUSH
72822: LD_INT 2
72824: PUSH
72825: EMPTY
72826: LIST
72827: LIST
72828: PUSH
72829: LD_INT 1
72831: NEG
72832: PUSH
72833: LD_INT 1
72835: PUSH
72836: EMPTY
72837: LIST
72838: LIST
72839: PUSH
72840: LD_INT 2
72842: NEG
72843: PUSH
72844: LD_INT 1
72846: NEG
72847: PUSH
72848: EMPTY
72849: LIST
72850: LIST
72851: PUSH
72852: LD_INT 2
72854: NEG
72855: PUSH
72856: LD_INT 2
72858: NEG
72859: PUSH
72860: EMPTY
72861: LIST
72862: LIST
72863: PUSH
72864: LD_INT 2
72866: NEG
72867: PUSH
72868: LD_INT 3
72870: NEG
72871: PUSH
72872: EMPTY
72873: LIST
72874: LIST
72875: PUSH
72876: LD_INT 2
72878: PUSH
72879: LD_INT 1
72881: NEG
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 3
72889: PUSH
72890: LD_INT 1
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 1
72899: PUSH
72900: LD_INT 3
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: LD_INT 2
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 3
72920: NEG
72921: PUSH
72922: LD_INT 2
72924: NEG
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: LIST
72939: LIST
72940: LIST
72941: LIST
72942: LIST
72943: LIST
72944: LIST
72945: LIST
72946: LIST
72947: LIST
72948: LIST
72949: LIST
72950: LIST
72951: LIST
72952: LIST
72953: LIST
72954: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72955: LD_ADDR_VAR 0 30
72959: PUSH
72960: LD_INT 0
72962: PUSH
72963: LD_INT 0
72965: PUSH
72966: EMPTY
72967: LIST
72968: LIST
72969: PUSH
72970: LD_INT 0
72972: PUSH
72973: LD_INT 1
72975: NEG
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 1
72983: PUSH
72984: LD_INT 0
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: PUSH
72991: LD_INT 1
72993: PUSH
72994: LD_INT 1
72996: PUSH
72997: EMPTY
72998: LIST
72999: LIST
73000: PUSH
73001: LD_INT 0
73003: PUSH
73004: LD_INT 1
73006: PUSH
73007: EMPTY
73008: LIST
73009: LIST
73010: PUSH
73011: LD_INT 1
73013: NEG
73014: PUSH
73015: LD_INT 0
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PUSH
73022: LD_INT 1
73024: NEG
73025: PUSH
73026: LD_INT 1
73028: NEG
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: LD_INT 1
73036: NEG
73037: PUSH
73038: LD_INT 2
73040: NEG
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PUSH
73046: LD_INT 0
73048: PUSH
73049: LD_INT 2
73051: NEG
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: LD_INT 1
73059: PUSH
73060: LD_INT 1
73062: NEG
73063: PUSH
73064: EMPTY
73065: LIST
73066: LIST
73067: PUSH
73068: LD_INT 2
73070: PUSH
73071: LD_INT 0
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 2
73080: PUSH
73081: LD_INT 1
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 2
73090: PUSH
73091: LD_INT 2
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: LD_INT 1
73100: PUSH
73101: LD_INT 2
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 1
73110: NEG
73111: PUSH
73112: LD_INT 1
73114: PUSH
73115: EMPTY
73116: LIST
73117: LIST
73118: PUSH
73119: LD_INT 2
73121: NEG
73122: PUSH
73123: LD_INT 0
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: PUSH
73130: LD_INT 2
73132: NEG
73133: PUSH
73134: LD_INT 1
73136: NEG
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: LD_INT 1
73144: NEG
73145: PUSH
73146: LD_INT 3
73148: NEG
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: LD_INT 1
73156: PUSH
73157: LD_INT 2
73159: NEG
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 3
73167: PUSH
73168: LD_INT 2
73170: PUSH
73171: EMPTY
73172: LIST
73173: LIST
73174: PUSH
73175: LD_INT 2
73177: PUSH
73178: LD_INT 3
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 2
73187: NEG
73188: PUSH
73189: LD_INT 1
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: LD_INT 3
73198: NEG
73199: PUSH
73200: LD_INT 1
73202: NEG
73203: PUSH
73204: EMPTY
73205: LIST
73206: LIST
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: LIST
73219: LIST
73220: LIST
73221: LIST
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: LIST
73232: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73233: LD_ADDR_VAR 0 31
73237: PUSH
73238: LD_INT 0
73240: PUSH
73241: LD_INT 0
73243: PUSH
73244: EMPTY
73245: LIST
73246: LIST
73247: PUSH
73248: LD_INT 0
73250: PUSH
73251: LD_INT 1
73253: NEG
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: PUSH
73259: LD_INT 1
73261: PUSH
73262: LD_INT 0
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: LD_INT 1
73271: PUSH
73272: LD_INT 1
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: LD_INT 0
73281: PUSH
73282: LD_INT 1
73284: PUSH
73285: EMPTY
73286: LIST
73287: LIST
73288: PUSH
73289: LD_INT 1
73291: NEG
73292: PUSH
73293: LD_INT 0
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: PUSH
73300: LD_INT 1
73302: NEG
73303: PUSH
73304: LD_INT 1
73306: NEG
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 1
73314: NEG
73315: PUSH
73316: LD_INT 2
73318: NEG
73319: PUSH
73320: EMPTY
73321: LIST
73322: LIST
73323: PUSH
73324: LD_INT 1
73326: PUSH
73327: LD_INT 1
73329: NEG
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 2
73337: PUSH
73338: LD_INT 0
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 2
73347: PUSH
73348: LD_INT 1
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: LD_INT 2
73357: PUSH
73358: LD_INT 2
73360: PUSH
73361: EMPTY
73362: LIST
73363: LIST
73364: PUSH
73365: LD_INT 1
73367: PUSH
73368: LD_INT 2
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: PUSH
73375: LD_INT 0
73377: PUSH
73378: LD_INT 2
73380: PUSH
73381: EMPTY
73382: LIST
73383: LIST
73384: PUSH
73385: LD_INT 1
73387: NEG
73388: PUSH
73389: LD_INT 1
73391: PUSH
73392: EMPTY
73393: LIST
73394: LIST
73395: PUSH
73396: LD_INT 2
73398: NEG
73399: PUSH
73400: LD_INT 1
73402: NEG
73403: PUSH
73404: EMPTY
73405: LIST
73406: LIST
73407: PUSH
73408: LD_INT 2
73410: NEG
73411: PUSH
73412: LD_INT 2
73414: NEG
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: PUSH
73420: LD_INT 2
73422: NEG
73423: PUSH
73424: LD_INT 3
73426: NEG
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: PUSH
73432: LD_INT 2
73434: PUSH
73435: LD_INT 1
73437: NEG
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 3
73445: PUSH
73446: LD_INT 1
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 1
73455: PUSH
73456: LD_INT 3
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 1
73465: NEG
73466: PUSH
73467: LD_INT 2
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 3
73476: NEG
73477: PUSH
73478: LD_INT 2
73480: NEG
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: LIST
73490: LIST
73491: LIST
73492: LIST
73493: LIST
73494: LIST
73495: LIST
73496: LIST
73497: LIST
73498: LIST
73499: LIST
73500: LIST
73501: LIST
73502: LIST
73503: LIST
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73511: LD_ADDR_VAR 0 32
73515: PUSH
73516: LD_INT 0
73518: PUSH
73519: LD_INT 0
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PUSH
73526: LD_INT 0
73528: PUSH
73529: LD_INT 1
73531: NEG
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: LD_INT 1
73539: PUSH
73540: LD_INT 0
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: PUSH
73547: LD_INT 1
73549: PUSH
73550: LD_INT 1
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: PUSH
73557: LD_INT 0
73559: PUSH
73560: LD_INT 1
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: PUSH
73567: LD_INT 1
73569: NEG
73570: PUSH
73571: LD_INT 0
73573: PUSH
73574: EMPTY
73575: LIST
73576: LIST
73577: PUSH
73578: LD_INT 1
73580: NEG
73581: PUSH
73582: LD_INT 1
73584: NEG
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 1
73592: NEG
73593: PUSH
73594: LD_INT 2
73596: NEG
73597: PUSH
73598: EMPTY
73599: LIST
73600: LIST
73601: PUSH
73602: LD_INT 0
73604: PUSH
73605: LD_INT 2
73607: NEG
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: PUSH
73613: LD_INT 1
73615: PUSH
73616: LD_INT 1
73618: NEG
73619: PUSH
73620: EMPTY
73621: LIST
73622: LIST
73623: PUSH
73624: LD_INT 2
73626: PUSH
73627: LD_INT 1
73629: PUSH
73630: EMPTY
73631: LIST
73632: LIST
73633: PUSH
73634: LD_INT 2
73636: PUSH
73637: LD_INT 2
73639: PUSH
73640: EMPTY
73641: LIST
73642: LIST
73643: PUSH
73644: LD_INT 1
73646: PUSH
73647: LD_INT 2
73649: PUSH
73650: EMPTY
73651: LIST
73652: LIST
73653: PUSH
73654: LD_INT 0
73656: PUSH
73657: LD_INT 2
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: PUSH
73664: LD_INT 1
73666: NEG
73667: PUSH
73668: LD_INT 1
73670: PUSH
73671: EMPTY
73672: LIST
73673: LIST
73674: PUSH
73675: LD_INT 2
73677: NEG
73678: PUSH
73679: LD_INT 0
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 2
73688: NEG
73689: PUSH
73690: LD_INT 1
73692: NEG
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: PUSH
73698: LD_INT 1
73700: NEG
73701: PUSH
73702: LD_INT 3
73704: NEG
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 1
73712: PUSH
73713: LD_INT 2
73715: NEG
73716: PUSH
73717: EMPTY
73718: LIST
73719: LIST
73720: PUSH
73721: LD_INT 3
73723: PUSH
73724: LD_INT 2
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: PUSH
73731: LD_INT 2
73733: PUSH
73734: LD_INT 3
73736: PUSH
73737: EMPTY
73738: LIST
73739: LIST
73740: PUSH
73741: LD_INT 2
73743: NEG
73744: PUSH
73745: LD_INT 1
73747: PUSH
73748: EMPTY
73749: LIST
73750: LIST
73751: PUSH
73752: LD_INT 3
73754: NEG
73755: PUSH
73756: LD_INT 1
73758: NEG
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: LIST
73768: LIST
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: LIST
73778: LIST
73779: LIST
73780: LIST
73781: LIST
73782: LIST
73783: LIST
73784: LIST
73785: LIST
73786: LIST
73787: LIST
73788: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73789: LD_ADDR_VAR 0 33
73793: PUSH
73794: LD_INT 0
73796: PUSH
73797: LD_INT 0
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 0
73806: PUSH
73807: LD_INT 1
73809: NEG
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 1
73817: PUSH
73818: LD_INT 0
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: PUSH
73825: LD_INT 1
73827: PUSH
73828: LD_INT 1
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 0
73837: PUSH
73838: LD_INT 1
73840: PUSH
73841: EMPTY
73842: LIST
73843: LIST
73844: PUSH
73845: LD_INT 1
73847: NEG
73848: PUSH
73849: LD_INT 0
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 1
73858: NEG
73859: PUSH
73860: LD_INT 1
73862: NEG
73863: PUSH
73864: EMPTY
73865: LIST
73866: LIST
73867: PUSH
73868: LD_INT 1
73870: NEG
73871: PUSH
73872: LD_INT 2
73874: NEG
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: LD_INT 1
73882: PUSH
73883: LD_INT 1
73885: NEG
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 2
73893: PUSH
73894: LD_INT 0
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: LD_INT 2
73903: PUSH
73904: LD_INT 1
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: LD_INT 1
73913: PUSH
73914: LD_INT 2
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 0
73923: PUSH
73924: LD_INT 2
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: LD_INT 1
73933: NEG
73934: PUSH
73935: LD_INT 1
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: LD_INT 2
73944: NEG
73945: PUSH
73946: LD_INT 0
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 2
73955: NEG
73956: PUSH
73957: LD_INT 1
73959: NEG
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 2
73967: NEG
73968: PUSH
73969: LD_INT 2
73971: NEG
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: LD_INT 2
73979: NEG
73980: PUSH
73981: LD_INT 3
73983: NEG
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 2
73991: PUSH
73992: LD_INT 1
73994: NEG
73995: PUSH
73996: EMPTY
73997: LIST
73998: LIST
73999: PUSH
74000: LD_INT 3
74002: PUSH
74003: LD_INT 1
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PUSH
74010: LD_INT 1
74012: PUSH
74013: LD_INT 3
74015: PUSH
74016: EMPTY
74017: LIST
74018: LIST
74019: PUSH
74020: LD_INT 1
74022: NEG
74023: PUSH
74024: LD_INT 2
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 3
74033: NEG
74034: PUSH
74035: LD_INT 2
74037: NEG
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74068: LD_ADDR_VAR 0 34
74072: PUSH
74073: LD_INT 0
74075: PUSH
74076: LD_INT 0
74078: PUSH
74079: EMPTY
74080: LIST
74081: LIST
74082: PUSH
74083: LD_INT 0
74085: PUSH
74086: LD_INT 1
74088: NEG
74089: PUSH
74090: EMPTY
74091: LIST
74092: LIST
74093: PUSH
74094: LD_INT 1
74096: PUSH
74097: LD_INT 0
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: PUSH
74104: LD_INT 1
74106: PUSH
74107: LD_INT 1
74109: PUSH
74110: EMPTY
74111: LIST
74112: LIST
74113: PUSH
74114: LD_INT 0
74116: PUSH
74117: LD_INT 1
74119: PUSH
74120: EMPTY
74121: LIST
74122: LIST
74123: PUSH
74124: LD_INT 1
74126: NEG
74127: PUSH
74128: LD_INT 0
74130: PUSH
74131: EMPTY
74132: LIST
74133: LIST
74134: PUSH
74135: LD_INT 1
74137: NEG
74138: PUSH
74139: LD_INT 1
74141: NEG
74142: PUSH
74143: EMPTY
74144: LIST
74145: LIST
74146: PUSH
74147: LD_INT 1
74149: NEG
74150: PUSH
74151: LD_INT 2
74153: NEG
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PUSH
74159: LD_INT 0
74161: PUSH
74162: LD_INT 2
74164: NEG
74165: PUSH
74166: EMPTY
74167: LIST
74168: LIST
74169: PUSH
74170: LD_INT 1
74172: PUSH
74173: LD_INT 1
74175: NEG
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: PUSH
74181: LD_INT 2
74183: PUSH
74184: LD_INT 1
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: PUSH
74191: LD_INT 2
74193: PUSH
74194: LD_INT 2
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PUSH
74201: LD_INT 1
74203: PUSH
74204: LD_INT 2
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: LD_INT 1
74213: NEG
74214: PUSH
74215: LD_INT 1
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 2
74224: NEG
74225: PUSH
74226: LD_INT 0
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: PUSH
74233: LD_INT 2
74235: NEG
74236: PUSH
74237: LD_INT 1
74239: NEG
74240: PUSH
74241: EMPTY
74242: LIST
74243: LIST
74244: PUSH
74245: LD_INT 2
74247: NEG
74248: PUSH
74249: LD_INT 2
74251: NEG
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: PUSH
74257: LD_INT 1
74259: NEG
74260: PUSH
74261: LD_INT 3
74263: NEG
74264: PUSH
74265: EMPTY
74266: LIST
74267: LIST
74268: PUSH
74269: LD_INT 1
74271: PUSH
74272: LD_INT 2
74274: NEG
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 3
74282: PUSH
74283: LD_INT 2
74285: PUSH
74286: EMPTY
74287: LIST
74288: LIST
74289: PUSH
74290: LD_INT 2
74292: PUSH
74293: LD_INT 3
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: PUSH
74300: LD_INT 2
74302: NEG
74303: PUSH
74304: LD_INT 1
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 3
74313: NEG
74314: PUSH
74315: LD_INT 1
74317: NEG
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: LIST
74327: LIST
74328: LIST
74329: LIST
74330: LIST
74331: LIST
74332: LIST
74333: LIST
74334: LIST
74335: LIST
74336: LIST
74337: LIST
74338: LIST
74339: LIST
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: LIST
74345: LIST
74346: LIST
74347: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
74348: LD_ADDR_VAR 0 35
74352: PUSH
74353: LD_INT 0
74355: PUSH
74356: LD_INT 0
74358: PUSH
74359: EMPTY
74360: LIST
74361: LIST
74362: PUSH
74363: LD_INT 0
74365: PUSH
74366: LD_INT 1
74368: NEG
74369: PUSH
74370: EMPTY
74371: LIST
74372: LIST
74373: PUSH
74374: LD_INT 1
74376: PUSH
74377: LD_INT 0
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 1
74386: PUSH
74387: LD_INT 1
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: LD_INT 0
74396: PUSH
74397: LD_INT 1
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: PUSH
74404: LD_INT 1
74406: NEG
74407: PUSH
74408: LD_INT 0
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: LD_INT 1
74417: NEG
74418: PUSH
74419: LD_INT 1
74421: NEG
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: PUSH
74427: LD_INT 2
74429: PUSH
74430: LD_INT 1
74432: PUSH
74433: EMPTY
74434: LIST
74435: LIST
74436: PUSH
74437: LD_INT 2
74439: NEG
74440: PUSH
74441: LD_INT 1
74443: NEG
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: LIST
74453: LIST
74454: LIST
74455: LIST
74456: LIST
74457: LIST
74458: LIST
74459: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
74460: LD_ADDR_VAR 0 36
74464: PUSH
74465: LD_INT 0
74467: PUSH
74468: LD_INT 0
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: PUSH
74475: LD_INT 0
74477: PUSH
74478: LD_INT 1
74480: NEG
74481: PUSH
74482: EMPTY
74483: LIST
74484: LIST
74485: PUSH
74486: LD_INT 1
74488: PUSH
74489: LD_INT 0
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 1
74498: PUSH
74499: LD_INT 1
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: PUSH
74506: LD_INT 0
74508: PUSH
74509: LD_INT 1
74511: PUSH
74512: EMPTY
74513: LIST
74514: LIST
74515: PUSH
74516: LD_INT 1
74518: NEG
74519: PUSH
74520: LD_INT 0
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: PUSH
74527: LD_INT 1
74529: NEG
74530: PUSH
74531: LD_INT 1
74533: NEG
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: PUSH
74539: LD_INT 1
74541: NEG
74542: PUSH
74543: LD_INT 2
74545: NEG
74546: PUSH
74547: EMPTY
74548: LIST
74549: LIST
74550: PUSH
74551: LD_INT 1
74553: PUSH
74554: LD_INT 2
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: LIST
74569: LIST
74570: LIST
74571: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74572: LD_ADDR_VAR 0 37
74576: PUSH
74577: LD_INT 0
74579: PUSH
74580: LD_INT 0
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: LD_INT 0
74589: PUSH
74590: LD_INT 1
74592: NEG
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 1
74600: PUSH
74601: LD_INT 0
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 1
74610: PUSH
74611: LD_INT 1
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 0
74620: PUSH
74621: LD_INT 1
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: LD_INT 1
74630: NEG
74631: PUSH
74632: LD_INT 0
74634: PUSH
74635: EMPTY
74636: LIST
74637: LIST
74638: PUSH
74639: LD_INT 1
74641: NEG
74642: PUSH
74643: LD_INT 1
74645: NEG
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: PUSH
74651: LD_INT 1
74653: PUSH
74654: LD_INT 1
74656: NEG
74657: PUSH
74658: EMPTY
74659: LIST
74660: LIST
74661: PUSH
74662: LD_INT 1
74664: NEG
74665: PUSH
74666: LD_INT 1
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: LIST
74677: LIST
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: LIST
74683: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
74684: LD_ADDR_VAR 0 38
74688: PUSH
74689: LD_INT 0
74691: PUSH
74692: LD_INT 0
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 0
74701: PUSH
74702: LD_INT 1
74704: NEG
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 1
74712: PUSH
74713: LD_INT 0
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 1
74722: PUSH
74723: LD_INT 1
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 0
74732: PUSH
74733: LD_INT 1
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: LD_INT 1
74742: NEG
74743: PUSH
74744: LD_INT 0
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 1
74753: NEG
74754: PUSH
74755: LD_INT 1
74757: NEG
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: PUSH
74763: LD_INT 2
74765: PUSH
74766: LD_INT 1
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: PUSH
74773: LD_INT 2
74775: NEG
74776: PUSH
74777: LD_INT 1
74779: NEG
74780: PUSH
74781: EMPTY
74782: LIST
74783: LIST
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: LIST
74791: LIST
74792: LIST
74793: LIST
74794: LIST
74795: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
74796: LD_ADDR_VAR 0 39
74800: PUSH
74801: LD_INT 0
74803: PUSH
74804: LD_INT 0
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 0
74813: PUSH
74814: LD_INT 1
74816: NEG
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: PUSH
74822: LD_INT 1
74824: PUSH
74825: LD_INT 0
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 1
74834: PUSH
74835: LD_INT 1
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 0
74844: PUSH
74845: LD_INT 1
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 1
74854: NEG
74855: PUSH
74856: LD_INT 0
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 1
74865: NEG
74866: PUSH
74867: LD_INT 1
74869: NEG
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 1
74877: NEG
74878: PUSH
74879: LD_INT 2
74881: NEG
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 1
74889: PUSH
74890: LD_INT 2
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: LIST
74901: LIST
74902: LIST
74903: LIST
74904: LIST
74905: LIST
74906: LIST
74907: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74908: LD_ADDR_VAR 0 40
74912: PUSH
74913: LD_INT 0
74915: PUSH
74916: LD_INT 0
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 0
74925: PUSH
74926: LD_INT 1
74928: NEG
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 1
74936: PUSH
74937: LD_INT 0
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: LD_INT 1
74946: PUSH
74947: LD_INT 1
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: LD_INT 0
74956: PUSH
74957: LD_INT 1
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PUSH
74964: LD_INT 1
74966: NEG
74967: PUSH
74968: LD_INT 0
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 1
74977: NEG
74978: PUSH
74979: LD_INT 1
74981: NEG
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: PUSH
74987: LD_INT 1
74989: PUSH
74990: LD_INT 1
74992: NEG
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PUSH
74998: LD_INT 1
75000: NEG
75001: PUSH
75002: LD_INT 1
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PUSH
75009: EMPTY
75010: LIST
75011: LIST
75012: LIST
75013: LIST
75014: LIST
75015: LIST
75016: LIST
75017: LIST
75018: LIST
75019: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75020: LD_ADDR_VAR 0 41
75024: PUSH
75025: LD_INT 0
75027: PUSH
75028: LD_INT 0
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: PUSH
75035: LD_INT 0
75037: PUSH
75038: LD_INT 1
75040: NEG
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PUSH
75046: LD_INT 1
75048: PUSH
75049: LD_INT 0
75051: PUSH
75052: EMPTY
75053: LIST
75054: LIST
75055: PUSH
75056: LD_INT 1
75058: PUSH
75059: LD_INT 1
75061: PUSH
75062: EMPTY
75063: LIST
75064: LIST
75065: PUSH
75066: LD_INT 0
75068: PUSH
75069: LD_INT 1
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: LD_INT 1
75078: NEG
75079: PUSH
75080: LD_INT 0
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: PUSH
75087: LD_INT 1
75089: NEG
75090: PUSH
75091: LD_INT 1
75093: NEG
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: PUSH
75099: LD_INT 1
75101: NEG
75102: PUSH
75103: LD_INT 2
75105: NEG
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: PUSH
75111: LD_INT 1
75113: PUSH
75114: LD_INT 1
75116: NEG
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: PUSH
75122: LD_INT 2
75124: PUSH
75125: LD_INT 0
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: PUSH
75132: LD_INT 2
75134: PUSH
75135: LD_INT 1
75137: PUSH
75138: EMPTY
75139: LIST
75140: LIST
75141: PUSH
75142: LD_INT 2
75144: PUSH
75145: LD_INT 2
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: LD_INT 1
75154: PUSH
75155: LD_INT 2
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: PUSH
75162: LD_INT 1
75164: NEG
75165: PUSH
75166: LD_INT 1
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: LD_INT 2
75175: NEG
75176: PUSH
75177: LD_INT 0
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 2
75186: NEG
75187: PUSH
75188: LD_INT 1
75190: NEG
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 2
75198: NEG
75199: PUSH
75200: LD_INT 2
75202: NEG
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PUSH
75208: LD_INT 2
75210: NEG
75211: PUSH
75212: LD_INT 3
75214: NEG
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: LD_INT 2
75222: PUSH
75223: LD_INT 1
75225: NEG
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: LD_INT 3
75233: PUSH
75234: LD_INT 0
75236: PUSH
75237: EMPTY
75238: LIST
75239: LIST
75240: PUSH
75241: LD_INT 3
75243: PUSH
75244: LD_INT 1
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: PUSH
75251: LD_INT 3
75253: PUSH
75254: LD_INT 2
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: LD_INT 3
75263: PUSH
75264: LD_INT 3
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: PUSH
75271: LD_INT 2
75273: PUSH
75274: LD_INT 3
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: LD_INT 2
75283: NEG
75284: PUSH
75285: LD_INT 1
75287: PUSH
75288: EMPTY
75289: LIST
75290: LIST
75291: PUSH
75292: LD_INT 3
75294: NEG
75295: PUSH
75296: LD_INT 0
75298: PUSH
75299: EMPTY
75300: LIST
75301: LIST
75302: PUSH
75303: LD_INT 3
75305: NEG
75306: PUSH
75307: LD_INT 1
75309: NEG
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: LD_INT 3
75317: NEG
75318: PUSH
75319: LD_INT 2
75321: NEG
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: PUSH
75327: LD_INT 3
75329: NEG
75330: PUSH
75331: LD_INT 3
75333: NEG
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: PUSH
75339: EMPTY
75340: LIST
75341: LIST
75342: LIST
75343: LIST
75344: LIST
75345: LIST
75346: LIST
75347: LIST
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: LIST
75359: LIST
75360: LIST
75361: LIST
75362: LIST
75363: LIST
75364: LIST
75365: LIST
75366: LIST
75367: LIST
75368: LIST
75369: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75370: LD_ADDR_VAR 0 42
75374: PUSH
75375: LD_INT 0
75377: PUSH
75378: LD_INT 0
75380: PUSH
75381: EMPTY
75382: LIST
75383: LIST
75384: PUSH
75385: LD_INT 0
75387: PUSH
75388: LD_INT 1
75390: NEG
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: PUSH
75396: LD_INT 1
75398: PUSH
75399: LD_INT 0
75401: PUSH
75402: EMPTY
75403: LIST
75404: LIST
75405: PUSH
75406: LD_INT 1
75408: PUSH
75409: LD_INT 1
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: PUSH
75416: LD_INT 0
75418: PUSH
75419: LD_INT 1
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 1
75428: NEG
75429: PUSH
75430: LD_INT 0
75432: PUSH
75433: EMPTY
75434: LIST
75435: LIST
75436: PUSH
75437: LD_INT 1
75439: NEG
75440: PUSH
75441: LD_INT 1
75443: NEG
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: LD_INT 1
75451: NEG
75452: PUSH
75453: LD_INT 2
75455: NEG
75456: PUSH
75457: EMPTY
75458: LIST
75459: LIST
75460: PUSH
75461: LD_INT 0
75463: PUSH
75464: LD_INT 2
75466: NEG
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: LD_INT 1
75474: PUSH
75475: LD_INT 1
75477: NEG
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 2
75485: PUSH
75486: LD_INT 1
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: PUSH
75493: LD_INT 2
75495: PUSH
75496: LD_INT 2
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: PUSH
75503: LD_INT 1
75505: PUSH
75506: LD_INT 2
75508: PUSH
75509: EMPTY
75510: LIST
75511: LIST
75512: PUSH
75513: LD_INT 0
75515: PUSH
75516: LD_INT 2
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: PUSH
75523: LD_INT 1
75525: NEG
75526: PUSH
75527: LD_INT 1
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PUSH
75534: LD_INT 2
75536: NEG
75537: PUSH
75538: LD_INT 1
75540: NEG
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: PUSH
75546: LD_INT 2
75548: NEG
75549: PUSH
75550: LD_INT 2
75552: NEG
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: LD_INT 2
75560: NEG
75561: PUSH
75562: LD_INT 3
75564: NEG
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 1
75572: NEG
75573: PUSH
75574: LD_INT 3
75576: NEG
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 0
75584: PUSH
75585: LD_INT 3
75587: NEG
75588: PUSH
75589: EMPTY
75590: LIST
75591: LIST
75592: PUSH
75593: LD_INT 1
75595: PUSH
75596: LD_INT 2
75598: NEG
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: PUSH
75604: LD_INT 3
75606: PUSH
75607: LD_INT 2
75609: PUSH
75610: EMPTY
75611: LIST
75612: LIST
75613: PUSH
75614: LD_INT 3
75616: PUSH
75617: LD_INT 3
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: PUSH
75624: LD_INT 2
75626: PUSH
75627: LD_INT 3
75629: PUSH
75630: EMPTY
75631: LIST
75632: LIST
75633: PUSH
75634: LD_INT 1
75636: PUSH
75637: LD_INT 3
75639: PUSH
75640: EMPTY
75641: LIST
75642: LIST
75643: PUSH
75644: LD_INT 0
75646: PUSH
75647: LD_INT 3
75649: PUSH
75650: EMPTY
75651: LIST
75652: LIST
75653: PUSH
75654: LD_INT 1
75656: NEG
75657: PUSH
75658: LD_INT 2
75660: PUSH
75661: EMPTY
75662: LIST
75663: LIST
75664: PUSH
75665: LD_INT 3
75667: NEG
75668: PUSH
75669: LD_INT 2
75671: NEG
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: PUSH
75677: LD_INT 3
75679: NEG
75680: PUSH
75681: LD_INT 3
75683: NEG
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: LIST
75693: LIST
75694: LIST
75695: LIST
75696: LIST
75697: LIST
75698: LIST
75699: LIST
75700: LIST
75701: LIST
75702: LIST
75703: LIST
75704: LIST
75705: LIST
75706: LIST
75707: LIST
75708: LIST
75709: LIST
75710: LIST
75711: LIST
75712: LIST
75713: LIST
75714: LIST
75715: LIST
75716: LIST
75717: LIST
75718: LIST
75719: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75720: LD_ADDR_VAR 0 43
75724: PUSH
75725: LD_INT 0
75727: PUSH
75728: LD_INT 0
75730: PUSH
75731: EMPTY
75732: LIST
75733: LIST
75734: PUSH
75735: LD_INT 0
75737: PUSH
75738: LD_INT 1
75740: NEG
75741: PUSH
75742: EMPTY
75743: LIST
75744: LIST
75745: PUSH
75746: LD_INT 1
75748: PUSH
75749: LD_INT 0
75751: PUSH
75752: EMPTY
75753: LIST
75754: LIST
75755: PUSH
75756: LD_INT 1
75758: PUSH
75759: LD_INT 1
75761: PUSH
75762: EMPTY
75763: LIST
75764: LIST
75765: PUSH
75766: LD_INT 0
75768: PUSH
75769: LD_INT 1
75771: PUSH
75772: EMPTY
75773: LIST
75774: LIST
75775: PUSH
75776: LD_INT 1
75778: NEG
75779: PUSH
75780: LD_INT 0
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PUSH
75787: LD_INT 1
75789: NEG
75790: PUSH
75791: LD_INT 1
75793: NEG
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 1
75801: NEG
75802: PUSH
75803: LD_INT 2
75805: NEG
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: PUSH
75811: LD_INT 0
75813: PUSH
75814: LD_INT 2
75816: NEG
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: PUSH
75822: LD_INT 1
75824: PUSH
75825: LD_INT 1
75827: NEG
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: PUSH
75833: LD_INT 2
75835: PUSH
75836: LD_INT 0
75838: PUSH
75839: EMPTY
75840: LIST
75841: LIST
75842: PUSH
75843: LD_INT 2
75845: PUSH
75846: LD_INT 1
75848: PUSH
75849: EMPTY
75850: LIST
75851: LIST
75852: PUSH
75853: LD_INT 1
75855: PUSH
75856: LD_INT 2
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 0
75865: PUSH
75866: LD_INT 2
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PUSH
75873: LD_INT 1
75875: NEG
75876: PUSH
75877: LD_INT 1
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: LD_INT 2
75886: NEG
75887: PUSH
75888: LD_INT 0
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: PUSH
75895: LD_INT 2
75897: NEG
75898: PUSH
75899: LD_INT 1
75901: NEG
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: LD_INT 1
75909: NEG
75910: PUSH
75911: LD_INT 3
75913: NEG
75914: PUSH
75915: EMPTY
75916: LIST
75917: LIST
75918: PUSH
75919: LD_INT 0
75921: PUSH
75922: LD_INT 3
75924: NEG
75925: PUSH
75926: EMPTY
75927: LIST
75928: LIST
75929: PUSH
75930: LD_INT 1
75932: PUSH
75933: LD_INT 2
75935: NEG
75936: PUSH
75937: EMPTY
75938: LIST
75939: LIST
75940: PUSH
75941: LD_INT 2
75943: PUSH
75944: LD_INT 1
75946: NEG
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 3
75954: PUSH
75955: LD_INT 0
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: PUSH
75962: LD_INT 3
75964: PUSH
75965: LD_INT 1
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: LD_INT 1
75974: PUSH
75975: LD_INT 3
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: PUSH
75982: LD_INT 0
75984: PUSH
75985: LD_INT 3
75987: PUSH
75988: EMPTY
75989: LIST
75990: LIST
75991: PUSH
75992: LD_INT 1
75994: NEG
75995: PUSH
75996: LD_INT 2
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: PUSH
76003: LD_INT 2
76005: NEG
76006: PUSH
76007: LD_INT 1
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: PUSH
76014: LD_INT 3
76016: NEG
76017: PUSH
76018: LD_INT 0
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: LD_INT 3
76027: NEG
76028: PUSH
76029: LD_INT 1
76031: NEG
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: LIST
76041: LIST
76042: LIST
76043: LIST
76044: LIST
76045: LIST
76046: LIST
76047: LIST
76048: LIST
76049: LIST
76050: LIST
76051: LIST
76052: LIST
76053: LIST
76054: LIST
76055: LIST
76056: LIST
76057: LIST
76058: LIST
76059: LIST
76060: LIST
76061: LIST
76062: LIST
76063: LIST
76064: LIST
76065: LIST
76066: LIST
76067: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76068: LD_ADDR_VAR 0 44
76072: PUSH
76073: LD_INT 0
76075: PUSH
76076: LD_INT 0
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PUSH
76083: LD_INT 0
76085: PUSH
76086: LD_INT 1
76088: NEG
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: PUSH
76094: LD_INT 1
76096: PUSH
76097: LD_INT 0
76099: PUSH
76100: EMPTY
76101: LIST
76102: LIST
76103: PUSH
76104: LD_INT 1
76106: PUSH
76107: LD_INT 1
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: PUSH
76114: LD_INT 0
76116: PUSH
76117: LD_INT 1
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: LD_INT 1
76126: NEG
76127: PUSH
76128: LD_INT 0
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: LD_INT 1
76137: NEG
76138: PUSH
76139: LD_INT 1
76141: NEG
76142: PUSH
76143: EMPTY
76144: LIST
76145: LIST
76146: PUSH
76147: LD_INT 1
76149: NEG
76150: PUSH
76151: LD_INT 2
76153: NEG
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: LD_INT 1
76161: PUSH
76162: LD_INT 1
76164: NEG
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: PUSH
76170: LD_INT 2
76172: PUSH
76173: LD_INT 0
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: PUSH
76180: LD_INT 2
76182: PUSH
76183: LD_INT 1
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: PUSH
76190: LD_INT 2
76192: PUSH
76193: LD_INT 2
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: LD_INT 1
76202: PUSH
76203: LD_INT 2
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: PUSH
76210: LD_INT 1
76212: NEG
76213: PUSH
76214: LD_INT 1
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: PUSH
76221: LD_INT 2
76223: NEG
76224: PUSH
76225: LD_INT 0
76227: PUSH
76228: EMPTY
76229: LIST
76230: LIST
76231: PUSH
76232: LD_INT 2
76234: NEG
76235: PUSH
76236: LD_INT 1
76238: NEG
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: LD_INT 2
76246: NEG
76247: PUSH
76248: LD_INT 2
76250: NEG
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PUSH
76256: LD_INT 2
76258: NEG
76259: PUSH
76260: LD_INT 3
76262: NEG
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: PUSH
76268: LD_INT 2
76270: PUSH
76271: LD_INT 1
76273: NEG
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PUSH
76279: LD_INT 3
76281: PUSH
76282: LD_INT 0
76284: PUSH
76285: EMPTY
76286: LIST
76287: LIST
76288: PUSH
76289: LD_INT 3
76291: PUSH
76292: LD_INT 1
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: PUSH
76299: LD_INT 3
76301: PUSH
76302: LD_INT 2
76304: PUSH
76305: EMPTY
76306: LIST
76307: LIST
76308: PUSH
76309: LD_INT 3
76311: PUSH
76312: LD_INT 3
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: LD_INT 2
76321: PUSH
76322: LD_INT 3
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: PUSH
76329: LD_INT 2
76331: NEG
76332: PUSH
76333: LD_INT 1
76335: PUSH
76336: EMPTY
76337: LIST
76338: LIST
76339: PUSH
76340: LD_INT 3
76342: NEG
76343: PUSH
76344: LD_INT 0
76346: PUSH
76347: EMPTY
76348: LIST
76349: LIST
76350: PUSH
76351: LD_INT 3
76353: NEG
76354: PUSH
76355: LD_INT 1
76357: NEG
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PUSH
76363: LD_INT 3
76365: NEG
76366: PUSH
76367: LD_INT 2
76369: NEG
76370: PUSH
76371: EMPTY
76372: LIST
76373: LIST
76374: PUSH
76375: LD_INT 3
76377: NEG
76378: PUSH
76379: LD_INT 3
76381: NEG
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: LIST
76391: LIST
76392: LIST
76393: LIST
76394: LIST
76395: LIST
76396: LIST
76397: LIST
76398: LIST
76399: LIST
76400: LIST
76401: LIST
76402: LIST
76403: LIST
76404: LIST
76405: LIST
76406: LIST
76407: LIST
76408: LIST
76409: LIST
76410: LIST
76411: LIST
76412: LIST
76413: LIST
76414: LIST
76415: LIST
76416: LIST
76417: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76418: LD_ADDR_VAR 0 45
76422: PUSH
76423: LD_INT 0
76425: PUSH
76426: LD_INT 0
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: LD_INT 0
76435: PUSH
76436: LD_INT 1
76438: NEG
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: LD_INT 1
76446: PUSH
76447: LD_INT 0
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: LD_INT 1
76456: PUSH
76457: LD_INT 1
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: PUSH
76464: LD_INT 0
76466: PUSH
76467: LD_INT 1
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: PUSH
76474: LD_INT 1
76476: NEG
76477: PUSH
76478: LD_INT 0
76480: PUSH
76481: EMPTY
76482: LIST
76483: LIST
76484: PUSH
76485: LD_INT 1
76487: NEG
76488: PUSH
76489: LD_INT 1
76491: NEG
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 1
76499: NEG
76500: PUSH
76501: LD_INT 2
76503: NEG
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: LD_INT 0
76511: PUSH
76512: LD_INT 2
76514: NEG
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 1
76522: PUSH
76523: LD_INT 1
76525: NEG
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: PUSH
76531: LD_INT 2
76533: PUSH
76534: LD_INT 1
76536: PUSH
76537: EMPTY
76538: LIST
76539: LIST
76540: PUSH
76541: LD_INT 2
76543: PUSH
76544: LD_INT 2
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: PUSH
76551: LD_INT 1
76553: PUSH
76554: LD_INT 2
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: PUSH
76561: LD_INT 0
76563: PUSH
76564: LD_INT 2
76566: PUSH
76567: EMPTY
76568: LIST
76569: LIST
76570: PUSH
76571: LD_INT 1
76573: NEG
76574: PUSH
76575: LD_INT 1
76577: PUSH
76578: EMPTY
76579: LIST
76580: LIST
76581: PUSH
76582: LD_INT 2
76584: NEG
76585: PUSH
76586: LD_INT 1
76588: NEG
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PUSH
76594: LD_INT 2
76596: NEG
76597: PUSH
76598: LD_INT 2
76600: NEG
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: PUSH
76606: LD_INT 2
76608: NEG
76609: PUSH
76610: LD_INT 3
76612: NEG
76613: PUSH
76614: EMPTY
76615: LIST
76616: LIST
76617: PUSH
76618: LD_INT 1
76620: NEG
76621: PUSH
76622: LD_INT 3
76624: NEG
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: PUSH
76630: LD_INT 0
76632: PUSH
76633: LD_INT 3
76635: NEG
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: LD_INT 1
76643: PUSH
76644: LD_INT 2
76646: NEG
76647: PUSH
76648: EMPTY
76649: LIST
76650: LIST
76651: PUSH
76652: LD_INT 3
76654: PUSH
76655: LD_INT 2
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 3
76664: PUSH
76665: LD_INT 3
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: PUSH
76672: LD_INT 2
76674: PUSH
76675: LD_INT 3
76677: PUSH
76678: EMPTY
76679: LIST
76680: LIST
76681: PUSH
76682: LD_INT 1
76684: PUSH
76685: LD_INT 3
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: PUSH
76692: LD_INT 0
76694: PUSH
76695: LD_INT 3
76697: PUSH
76698: EMPTY
76699: LIST
76700: LIST
76701: PUSH
76702: LD_INT 1
76704: NEG
76705: PUSH
76706: LD_INT 2
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: PUSH
76713: LD_INT 3
76715: NEG
76716: PUSH
76717: LD_INT 2
76719: NEG
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PUSH
76725: LD_INT 3
76727: NEG
76728: PUSH
76729: LD_INT 3
76731: NEG
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: LIST
76741: LIST
76742: LIST
76743: LIST
76744: LIST
76745: LIST
76746: LIST
76747: LIST
76748: LIST
76749: LIST
76750: LIST
76751: LIST
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: LIST
76761: LIST
76762: LIST
76763: LIST
76764: LIST
76765: LIST
76766: LIST
76767: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76768: LD_ADDR_VAR 0 46
76772: PUSH
76773: LD_INT 0
76775: PUSH
76776: LD_INT 0
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: PUSH
76783: LD_INT 0
76785: PUSH
76786: LD_INT 1
76788: NEG
76789: PUSH
76790: EMPTY
76791: LIST
76792: LIST
76793: PUSH
76794: LD_INT 1
76796: PUSH
76797: LD_INT 0
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: PUSH
76804: LD_INT 1
76806: PUSH
76807: LD_INT 1
76809: PUSH
76810: EMPTY
76811: LIST
76812: LIST
76813: PUSH
76814: LD_INT 0
76816: PUSH
76817: LD_INT 1
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PUSH
76824: LD_INT 1
76826: NEG
76827: PUSH
76828: LD_INT 0
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PUSH
76835: LD_INT 1
76837: NEG
76838: PUSH
76839: LD_INT 1
76841: NEG
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: PUSH
76847: LD_INT 1
76849: NEG
76850: PUSH
76851: LD_INT 2
76853: NEG
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 0
76861: PUSH
76862: LD_INT 2
76864: NEG
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 1
76872: PUSH
76873: LD_INT 1
76875: NEG
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 2
76883: PUSH
76884: LD_INT 0
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: LD_INT 2
76893: PUSH
76894: LD_INT 1
76896: PUSH
76897: EMPTY
76898: LIST
76899: LIST
76900: PUSH
76901: LD_INT 1
76903: PUSH
76904: LD_INT 2
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: LD_INT 0
76913: PUSH
76914: LD_INT 2
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: PUSH
76921: LD_INT 1
76923: NEG
76924: PUSH
76925: LD_INT 1
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: LD_INT 2
76934: NEG
76935: PUSH
76936: LD_INT 0
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: PUSH
76943: LD_INT 2
76945: NEG
76946: PUSH
76947: LD_INT 1
76949: NEG
76950: PUSH
76951: EMPTY
76952: LIST
76953: LIST
76954: PUSH
76955: LD_INT 1
76957: NEG
76958: PUSH
76959: LD_INT 3
76961: NEG
76962: PUSH
76963: EMPTY
76964: LIST
76965: LIST
76966: PUSH
76967: LD_INT 0
76969: PUSH
76970: LD_INT 3
76972: NEG
76973: PUSH
76974: EMPTY
76975: LIST
76976: LIST
76977: PUSH
76978: LD_INT 1
76980: PUSH
76981: LD_INT 2
76983: NEG
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: PUSH
76989: LD_INT 2
76991: PUSH
76992: LD_INT 1
76994: NEG
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: PUSH
77000: LD_INT 3
77002: PUSH
77003: LD_INT 0
77005: PUSH
77006: EMPTY
77007: LIST
77008: LIST
77009: PUSH
77010: LD_INT 3
77012: PUSH
77013: LD_INT 1
77015: PUSH
77016: EMPTY
77017: LIST
77018: LIST
77019: PUSH
77020: LD_INT 1
77022: PUSH
77023: LD_INT 3
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 0
77032: PUSH
77033: LD_INT 3
77035: PUSH
77036: EMPTY
77037: LIST
77038: LIST
77039: PUSH
77040: LD_INT 1
77042: NEG
77043: PUSH
77044: LD_INT 2
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PUSH
77051: LD_INT 2
77053: NEG
77054: PUSH
77055: LD_INT 1
77057: PUSH
77058: EMPTY
77059: LIST
77060: LIST
77061: PUSH
77062: LD_INT 3
77064: NEG
77065: PUSH
77066: LD_INT 0
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: PUSH
77073: LD_INT 3
77075: NEG
77076: PUSH
77077: LD_INT 1
77079: NEG
77080: PUSH
77081: EMPTY
77082: LIST
77083: LIST
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: LIST
77089: LIST
77090: LIST
77091: LIST
77092: LIST
77093: LIST
77094: LIST
77095: LIST
77096: LIST
77097: LIST
77098: LIST
77099: LIST
77100: LIST
77101: LIST
77102: LIST
77103: LIST
77104: LIST
77105: LIST
77106: LIST
77107: LIST
77108: LIST
77109: LIST
77110: LIST
77111: LIST
77112: LIST
77113: LIST
77114: LIST
77115: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77116: LD_ADDR_VAR 0 47
77120: PUSH
77121: LD_INT 0
77123: PUSH
77124: LD_INT 0
77126: PUSH
77127: EMPTY
77128: LIST
77129: LIST
77130: PUSH
77131: LD_INT 0
77133: PUSH
77134: LD_INT 1
77136: NEG
77137: PUSH
77138: EMPTY
77139: LIST
77140: LIST
77141: PUSH
77142: LD_INT 1
77144: PUSH
77145: LD_INT 0
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: PUSH
77152: LD_INT 1
77154: PUSH
77155: LD_INT 1
77157: PUSH
77158: EMPTY
77159: LIST
77160: LIST
77161: PUSH
77162: LD_INT 0
77164: PUSH
77165: LD_INT 1
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: PUSH
77172: LD_INT 1
77174: NEG
77175: PUSH
77176: LD_INT 0
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 1
77185: NEG
77186: PUSH
77187: LD_INT 1
77189: NEG
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: PUSH
77195: LD_INT 1
77197: NEG
77198: PUSH
77199: LD_INT 2
77201: NEG
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: LD_INT 0
77209: PUSH
77210: LD_INT 2
77212: NEG
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: PUSH
77218: LD_INT 1
77220: PUSH
77221: LD_INT 1
77223: NEG
77224: PUSH
77225: EMPTY
77226: LIST
77227: LIST
77228: PUSH
77229: LD_INT 2
77231: NEG
77232: PUSH
77233: LD_INT 1
77235: NEG
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 2
77243: NEG
77244: PUSH
77245: LD_INT 2
77247: NEG
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: LIST
77257: LIST
77258: LIST
77259: LIST
77260: LIST
77261: LIST
77262: LIST
77263: LIST
77264: LIST
77265: LIST
77266: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77267: LD_ADDR_VAR 0 48
77271: PUSH
77272: LD_INT 0
77274: PUSH
77275: LD_INT 0
77277: PUSH
77278: EMPTY
77279: LIST
77280: LIST
77281: PUSH
77282: LD_INT 0
77284: PUSH
77285: LD_INT 1
77287: NEG
77288: PUSH
77289: EMPTY
77290: LIST
77291: LIST
77292: PUSH
77293: LD_INT 1
77295: PUSH
77296: LD_INT 0
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 1
77305: PUSH
77306: LD_INT 1
77308: PUSH
77309: EMPTY
77310: LIST
77311: LIST
77312: PUSH
77313: LD_INT 0
77315: PUSH
77316: LD_INT 1
77318: PUSH
77319: EMPTY
77320: LIST
77321: LIST
77322: PUSH
77323: LD_INT 1
77325: NEG
77326: PUSH
77327: LD_INT 0
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 1
77336: NEG
77337: PUSH
77338: LD_INT 1
77340: NEG
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PUSH
77346: LD_INT 1
77348: NEG
77349: PUSH
77350: LD_INT 2
77352: NEG
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: PUSH
77358: LD_INT 0
77360: PUSH
77361: LD_INT 2
77363: NEG
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: LD_INT 1
77371: PUSH
77372: LD_INT 1
77374: NEG
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 2
77382: PUSH
77383: LD_INT 0
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 2
77392: PUSH
77393: LD_INT 1
77395: PUSH
77396: EMPTY
77397: LIST
77398: LIST
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: LIST
77404: LIST
77405: LIST
77406: LIST
77407: LIST
77408: LIST
77409: LIST
77410: LIST
77411: LIST
77412: LIST
77413: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77414: LD_ADDR_VAR 0 49
77418: PUSH
77419: LD_INT 0
77421: PUSH
77422: LD_INT 0
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 0
77431: PUSH
77432: LD_INT 1
77434: NEG
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: PUSH
77440: LD_INT 1
77442: PUSH
77443: LD_INT 0
77445: PUSH
77446: EMPTY
77447: LIST
77448: LIST
77449: PUSH
77450: LD_INT 1
77452: PUSH
77453: LD_INT 1
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: LD_INT 0
77462: PUSH
77463: LD_INT 1
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 1
77472: NEG
77473: PUSH
77474: LD_INT 0
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 1
77483: NEG
77484: PUSH
77485: LD_INT 1
77487: NEG
77488: PUSH
77489: EMPTY
77490: LIST
77491: LIST
77492: PUSH
77493: LD_INT 1
77495: PUSH
77496: LD_INT 1
77498: NEG
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: LD_INT 2
77506: PUSH
77507: LD_INT 0
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 2
77516: PUSH
77517: LD_INT 1
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: LD_INT 2
77526: PUSH
77527: LD_INT 2
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: PUSH
77534: LD_INT 1
77536: PUSH
77537: LD_INT 2
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: LIST
77548: LIST
77549: LIST
77550: LIST
77551: LIST
77552: LIST
77553: LIST
77554: LIST
77555: LIST
77556: LIST
77557: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77558: LD_ADDR_VAR 0 50
77562: PUSH
77563: LD_INT 0
77565: PUSH
77566: LD_INT 0
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: PUSH
77573: LD_INT 0
77575: PUSH
77576: LD_INT 1
77578: NEG
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: LD_INT 1
77586: PUSH
77587: LD_INT 0
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 1
77596: PUSH
77597: LD_INT 1
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 0
77606: PUSH
77607: LD_INT 1
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 1
77616: NEG
77617: PUSH
77618: LD_INT 0
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 1
77627: NEG
77628: PUSH
77629: LD_INT 1
77631: NEG
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 2
77639: PUSH
77640: LD_INT 1
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: LD_INT 2
77649: PUSH
77650: LD_INT 2
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: PUSH
77657: LD_INT 1
77659: PUSH
77660: LD_INT 2
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: PUSH
77667: LD_INT 0
77669: PUSH
77670: LD_INT 2
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: LD_INT 1
77679: NEG
77680: PUSH
77681: LD_INT 1
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: EMPTY
77689: LIST
77690: LIST
77691: LIST
77692: LIST
77693: LIST
77694: LIST
77695: LIST
77696: LIST
77697: LIST
77698: LIST
77699: LIST
77700: LIST
77701: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77702: LD_ADDR_VAR 0 51
77706: PUSH
77707: LD_INT 0
77709: PUSH
77710: LD_INT 0
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 0
77719: PUSH
77720: LD_INT 1
77722: NEG
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: PUSH
77728: LD_INT 1
77730: PUSH
77731: LD_INT 0
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: PUSH
77738: LD_INT 1
77740: PUSH
77741: LD_INT 1
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: PUSH
77748: LD_INT 0
77750: PUSH
77751: LD_INT 1
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: PUSH
77758: LD_INT 1
77760: NEG
77761: PUSH
77762: LD_INT 0
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: LD_INT 1
77771: NEG
77772: PUSH
77773: LD_INT 1
77775: NEG
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: PUSH
77781: LD_INT 1
77783: PUSH
77784: LD_INT 2
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: PUSH
77791: LD_INT 0
77793: PUSH
77794: LD_INT 2
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 1
77803: NEG
77804: PUSH
77805: LD_INT 1
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PUSH
77812: LD_INT 2
77814: NEG
77815: PUSH
77816: LD_INT 0
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 2
77825: NEG
77826: PUSH
77827: LD_INT 1
77829: NEG
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: LIST
77839: LIST
77840: LIST
77841: LIST
77842: LIST
77843: LIST
77844: LIST
77845: LIST
77846: LIST
77847: LIST
77848: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77849: LD_ADDR_VAR 0 52
77853: PUSH
77854: LD_INT 0
77856: PUSH
77857: LD_INT 0
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: PUSH
77864: LD_INT 0
77866: PUSH
77867: LD_INT 1
77869: NEG
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: PUSH
77875: LD_INT 1
77877: PUSH
77878: LD_INT 0
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 1
77887: PUSH
77888: LD_INT 1
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 0
77897: PUSH
77898: LD_INT 1
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 1
77907: NEG
77908: PUSH
77909: LD_INT 0
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 1
77918: NEG
77919: PUSH
77920: LD_INT 1
77922: NEG
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: LD_INT 1
77930: NEG
77931: PUSH
77932: LD_INT 2
77934: NEG
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 1
77942: NEG
77943: PUSH
77944: LD_INT 1
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 2
77953: NEG
77954: PUSH
77955: LD_INT 0
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 2
77964: NEG
77965: PUSH
77966: LD_INT 1
77968: NEG
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 2
77976: NEG
77977: PUSH
77978: LD_INT 2
77980: NEG
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: LIST
77990: LIST
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78000: LD_ADDR_VAR 0 53
78004: PUSH
78005: LD_INT 0
78007: PUSH
78008: LD_INT 0
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: PUSH
78015: LD_INT 0
78017: PUSH
78018: LD_INT 1
78020: NEG
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 1
78028: PUSH
78029: LD_INT 0
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: LD_INT 1
78038: PUSH
78039: LD_INT 1
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: PUSH
78046: LD_INT 0
78048: PUSH
78049: LD_INT 1
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 1
78058: NEG
78059: PUSH
78060: LD_INT 0
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: LD_INT 1
78069: NEG
78070: PUSH
78071: LD_INT 1
78073: NEG
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 1
78081: NEG
78082: PUSH
78083: LD_INT 2
78085: NEG
78086: PUSH
78087: EMPTY
78088: LIST
78089: LIST
78090: PUSH
78091: LD_INT 0
78093: PUSH
78094: LD_INT 2
78096: NEG
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: LD_INT 1
78104: PUSH
78105: LD_INT 1
78107: NEG
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 2
78115: PUSH
78116: LD_INT 0
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 2
78125: PUSH
78126: LD_INT 1
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: PUSH
78133: LD_INT 2
78135: PUSH
78136: LD_INT 2
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: PUSH
78143: LD_INT 1
78145: PUSH
78146: LD_INT 2
78148: PUSH
78149: EMPTY
78150: LIST
78151: LIST
78152: PUSH
78153: LD_INT 0
78155: PUSH
78156: LD_INT 2
78158: PUSH
78159: EMPTY
78160: LIST
78161: LIST
78162: PUSH
78163: LD_INT 1
78165: NEG
78166: PUSH
78167: LD_INT 1
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: LD_INT 2
78176: NEG
78177: PUSH
78178: LD_INT 0
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: PUSH
78185: LD_INT 2
78187: NEG
78188: PUSH
78189: LD_INT 1
78191: NEG
78192: PUSH
78193: EMPTY
78194: LIST
78195: LIST
78196: PUSH
78197: LD_INT 2
78199: NEG
78200: PUSH
78201: LD_INT 2
78203: NEG
78204: PUSH
78205: EMPTY
78206: LIST
78207: LIST
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78230: LD_ADDR_VAR 0 54
78234: PUSH
78235: LD_INT 0
78237: PUSH
78238: LD_INT 0
78240: PUSH
78241: EMPTY
78242: LIST
78243: LIST
78244: PUSH
78245: LD_INT 0
78247: PUSH
78248: LD_INT 1
78250: NEG
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 1
78258: PUSH
78259: LD_INT 0
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 1
78268: PUSH
78269: LD_INT 1
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 0
78278: PUSH
78279: LD_INT 1
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 1
78288: NEG
78289: PUSH
78290: LD_INT 0
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: LD_INT 1
78299: NEG
78300: PUSH
78301: LD_INT 1
78303: NEG
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: PUSH
78309: LD_INT 1
78311: NEG
78312: PUSH
78313: LD_INT 2
78315: NEG
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PUSH
78321: LD_INT 0
78323: PUSH
78324: LD_INT 2
78326: NEG
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 1
78334: PUSH
78335: LD_INT 1
78337: NEG
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: LD_INT 2
78345: PUSH
78346: LD_INT 0
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 2
78355: PUSH
78356: LD_INT 1
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 2
78365: PUSH
78366: LD_INT 2
78368: PUSH
78369: EMPTY
78370: LIST
78371: LIST
78372: PUSH
78373: LD_INT 1
78375: PUSH
78376: LD_INT 2
78378: PUSH
78379: EMPTY
78380: LIST
78381: LIST
78382: PUSH
78383: LD_INT 0
78385: PUSH
78386: LD_INT 2
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PUSH
78393: LD_INT 1
78395: NEG
78396: PUSH
78397: LD_INT 1
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: LD_INT 2
78406: NEG
78407: PUSH
78408: LD_INT 0
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PUSH
78415: LD_INT 2
78417: NEG
78418: PUSH
78419: LD_INT 1
78421: NEG
78422: PUSH
78423: EMPTY
78424: LIST
78425: LIST
78426: PUSH
78427: LD_INT 2
78429: NEG
78430: PUSH
78431: LD_INT 2
78433: NEG
78434: PUSH
78435: EMPTY
78436: LIST
78437: LIST
78438: PUSH
78439: EMPTY
78440: LIST
78441: LIST
78442: LIST
78443: LIST
78444: LIST
78445: LIST
78446: LIST
78447: LIST
78448: LIST
78449: LIST
78450: LIST
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: LIST
78457: LIST
78458: LIST
78459: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78460: LD_ADDR_VAR 0 55
78464: PUSH
78465: LD_INT 0
78467: PUSH
78468: LD_INT 0
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: LD_INT 0
78477: PUSH
78478: LD_INT 1
78480: NEG
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 1
78488: PUSH
78489: LD_INT 0
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 1
78498: PUSH
78499: LD_INT 1
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 0
78508: PUSH
78509: LD_INT 1
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 1
78518: NEG
78519: PUSH
78520: LD_INT 0
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: LD_INT 1
78529: NEG
78530: PUSH
78531: LD_INT 1
78533: NEG
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PUSH
78539: LD_INT 1
78541: NEG
78542: PUSH
78543: LD_INT 2
78545: NEG
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 0
78553: PUSH
78554: LD_INT 2
78556: NEG
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PUSH
78562: LD_INT 1
78564: PUSH
78565: LD_INT 1
78567: NEG
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: PUSH
78573: LD_INT 2
78575: PUSH
78576: LD_INT 0
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 2
78585: PUSH
78586: LD_INT 1
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: LD_INT 2
78595: PUSH
78596: LD_INT 2
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: PUSH
78603: LD_INT 1
78605: PUSH
78606: LD_INT 2
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: PUSH
78613: LD_INT 0
78615: PUSH
78616: LD_INT 2
78618: PUSH
78619: EMPTY
78620: LIST
78621: LIST
78622: PUSH
78623: LD_INT 1
78625: NEG
78626: PUSH
78627: LD_INT 1
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 2
78636: NEG
78637: PUSH
78638: LD_INT 0
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: LD_INT 2
78647: NEG
78648: PUSH
78649: LD_INT 1
78651: NEG
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 2
78659: NEG
78660: PUSH
78661: LD_INT 2
78663: NEG
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: LIST
78673: LIST
78674: LIST
78675: LIST
78676: LIST
78677: LIST
78678: LIST
78679: LIST
78680: LIST
78681: LIST
78682: LIST
78683: LIST
78684: LIST
78685: LIST
78686: LIST
78687: LIST
78688: LIST
78689: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78690: LD_ADDR_VAR 0 56
78694: PUSH
78695: LD_INT 0
78697: PUSH
78698: LD_INT 0
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 0
78707: PUSH
78708: LD_INT 1
78710: NEG
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 1
78718: PUSH
78719: LD_INT 0
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 1
78728: PUSH
78729: LD_INT 1
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: LD_INT 0
78738: PUSH
78739: LD_INT 1
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 1
78748: NEG
78749: PUSH
78750: LD_INT 0
78752: PUSH
78753: EMPTY
78754: LIST
78755: LIST
78756: PUSH
78757: LD_INT 1
78759: NEG
78760: PUSH
78761: LD_INT 1
78763: NEG
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: PUSH
78769: LD_INT 1
78771: NEG
78772: PUSH
78773: LD_INT 2
78775: NEG
78776: PUSH
78777: EMPTY
78778: LIST
78779: LIST
78780: PUSH
78781: LD_INT 0
78783: PUSH
78784: LD_INT 2
78786: NEG
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: LD_INT 1
78794: PUSH
78795: LD_INT 1
78797: NEG
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: PUSH
78803: LD_INT 2
78805: PUSH
78806: LD_INT 0
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PUSH
78813: LD_INT 2
78815: PUSH
78816: LD_INT 1
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PUSH
78823: LD_INT 2
78825: PUSH
78826: LD_INT 2
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: PUSH
78833: LD_INT 1
78835: PUSH
78836: LD_INT 2
78838: PUSH
78839: EMPTY
78840: LIST
78841: LIST
78842: PUSH
78843: LD_INT 0
78845: PUSH
78846: LD_INT 2
78848: PUSH
78849: EMPTY
78850: LIST
78851: LIST
78852: PUSH
78853: LD_INT 1
78855: NEG
78856: PUSH
78857: LD_INT 1
78859: PUSH
78860: EMPTY
78861: LIST
78862: LIST
78863: PUSH
78864: LD_INT 2
78866: NEG
78867: PUSH
78868: LD_INT 0
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 2
78877: NEG
78878: PUSH
78879: LD_INT 1
78881: NEG
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 2
78889: NEG
78890: PUSH
78891: LD_INT 2
78893: NEG
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: LIST
78903: LIST
78904: LIST
78905: LIST
78906: LIST
78907: LIST
78908: LIST
78909: LIST
78910: LIST
78911: LIST
78912: LIST
78913: LIST
78914: LIST
78915: LIST
78916: LIST
78917: LIST
78918: LIST
78919: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78920: LD_ADDR_VAR 0 57
78924: PUSH
78925: LD_INT 0
78927: PUSH
78928: LD_INT 0
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: LD_INT 0
78937: PUSH
78938: LD_INT 1
78940: NEG
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 1
78948: PUSH
78949: LD_INT 0
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: PUSH
78956: LD_INT 1
78958: PUSH
78959: LD_INT 1
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 0
78968: PUSH
78969: LD_INT 1
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PUSH
78976: LD_INT 1
78978: NEG
78979: PUSH
78980: LD_INT 0
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: PUSH
78987: LD_INT 1
78989: NEG
78990: PUSH
78991: LD_INT 1
78993: NEG
78994: PUSH
78995: EMPTY
78996: LIST
78997: LIST
78998: PUSH
78999: LD_INT 1
79001: NEG
79002: PUSH
79003: LD_INT 2
79005: NEG
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: PUSH
79011: LD_INT 0
79013: PUSH
79014: LD_INT 2
79016: NEG
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: LD_INT 1
79024: PUSH
79025: LD_INT 1
79027: NEG
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 2
79035: PUSH
79036: LD_INT 0
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 2
79045: PUSH
79046: LD_INT 1
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 2
79055: PUSH
79056: LD_INT 2
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: LD_INT 1
79065: PUSH
79066: LD_INT 2
79068: PUSH
79069: EMPTY
79070: LIST
79071: LIST
79072: PUSH
79073: LD_INT 0
79075: PUSH
79076: LD_INT 2
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 1
79085: NEG
79086: PUSH
79087: LD_INT 1
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: LD_INT 2
79096: NEG
79097: PUSH
79098: LD_INT 0
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PUSH
79105: LD_INT 2
79107: NEG
79108: PUSH
79109: LD_INT 1
79111: NEG
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 2
79119: NEG
79120: PUSH
79121: LD_INT 2
79123: NEG
79124: PUSH
79125: EMPTY
79126: LIST
79127: LIST
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: LIST
79133: LIST
79134: LIST
79135: LIST
79136: LIST
79137: LIST
79138: LIST
79139: LIST
79140: LIST
79141: LIST
79142: LIST
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79150: LD_ADDR_VAR 0 58
79154: PUSH
79155: LD_INT 0
79157: PUSH
79158: LD_INT 0
79160: PUSH
79161: EMPTY
79162: LIST
79163: LIST
79164: PUSH
79165: LD_INT 0
79167: PUSH
79168: LD_INT 1
79170: NEG
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: PUSH
79176: LD_INT 1
79178: PUSH
79179: LD_INT 0
79181: PUSH
79182: EMPTY
79183: LIST
79184: LIST
79185: PUSH
79186: LD_INT 1
79188: PUSH
79189: LD_INT 1
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: PUSH
79196: LD_INT 0
79198: PUSH
79199: LD_INT 1
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 1
79208: NEG
79209: PUSH
79210: LD_INT 0
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 1
79219: NEG
79220: PUSH
79221: LD_INT 1
79223: NEG
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 1
79231: NEG
79232: PUSH
79233: LD_INT 2
79235: NEG
79236: PUSH
79237: EMPTY
79238: LIST
79239: LIST
79240: PUSH
79241: LD_INT 0
79243: PUSH
79244: LD_INT 2
79246: NEG
79247: PUSH
79248: EMPTY
79249: LIST
79250: LIST
79251: PUSH
79252: LD_INT 1
79254: PUSH
79255: LD_INT 1
79257: NEG
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 2
79265: PUSH
79266: LD_INT 0
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: PUSH
79273: LD_INT 2
79275: PUSH
79276: LD_INT 1
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 2
79285: PUSH
79286: LD_INT 2
79288: PUSH
79289: EMPTY
79290: LIST
79291: LIST
79292: PUSH
79293: LD_INT 1
79295: PUSH
79296: LD_INT 2
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: LD_INT 0
79305: PUSH
79306: LD_INT 2
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 1
79315: NEG
79316: PUSH
79317: LD_INT 1
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: LD_INT 2
79326: NEG
79327: PUSH
79328: LD_INT 0
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: PUSH
79335: LD_INT 2
79337: NEG
79338: PUSH
79339: LD_INT 1
79341: NEG
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 2
79349: NEG
79350: PUSH
79351: LD_INT 2
79353: NEG
79354: PUSH
79355: EMPTY
79356: LIST
79357: LIST
79358: PUSH
79359: EMPTY
79360: LIST
79361: LIST
79362: LIST
79363: LIST
79364: LIST
79365: LIST
79366: LIST
79367: LIST
79368: LIST
79369: LIST
79370: LIST
79371: LIST
79372: LIST
79373: LIST
79374: LIST
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79380: LD_ADDR_VAR 0 59
79384: PUSH
79385: LD_INT 0
79387: PUSH
79388: LD_INT 0
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 0
79397: PUSH
79398: LD_INT 1
79400: NEG
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 1
79408: PUSH
79409: LD_INT 0
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 1
79418: PUSH
79419: LD_INT 1
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 0
79428: PUSH
79429: LD_INT 1
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_INT 1
79438: NEG
79439: PUSH
79440: LD_INT 0
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: PUSH
79447: LD_INT 1
79449: NEG
79450: PUSH
79451: LD_INT 1
79453: NEG
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: LIST
79463: LIST
79464: LIST
79465: LIST
79466: LIST
79467: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79468: LD_ADDR_VAR 0 60
79472: PUSH
79473: LD_INT 0
79475: PUSH
79476: LD_INT 0
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PUSH
79483: LD_INT 0
79485: PUSH
79486: LD_INT 1
79488: NEG
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: LD_INT 1
79496: PUSH
79497: LD_INT 0
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PUSH
79504: LD_INT 1
79506: PUSH
79507: LD_INT 1
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 0
79516: PUSH
79517: LD_INT 1
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: PUSH
79524: LD_INT 1
79526: NEG
79527: PUSH
79528: LD_INT 0
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: LD_INT 1
79537: NEG
79538: PUSH
79539: LD_INT 1
79541: NEG
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PUSH
79547: EMPTY
79548: LIST
79549: LIST
79550: LIST
79551: LIST
79552: LIST
79553: LIST
79554: LIST
79555: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79556: LD_ADDR_VAR 0 61
79560: PUSH
79561: LD_INT 0
79563: PUSH
79564: LD_INT 0
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 0
79573: PUSH
79574: LD_INT 1
79576: NEG
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 1
79584: PUSH
79585: LD_INT 0
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: LD_INT 1
79594: PUSH
79595: LD_INT 1
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: LD_INT 0
79604: PUSH
79605: LD_INT 1
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 1
79614: NEG
79615: PUSH
79616: LD_INT 0
79618: PUSH
79619: EMPTY
79620: LIST
79621: LIST
79622: PUSH
79623: LD_INT 1
79625: NEG
79626: PUSH
79627: LD_INT 1
79629: NEG
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: LIST
79639: LIST
79640: LIST
79641: LIST
79642: LIST
79643: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79644: LD_ADDR_VAR 0 62
79648: PUSH
79649: LD_INT 0
79651: PUSH
79652: LD_INT 0
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 0
79661: PUSH
79662: LD_INT 1
79664: NEG
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 1
79672: PUSH
79673: LD_INT 0
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PUSH
79680: LD_INT 1
79682: PUSH
79683: LD_INT 1
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 0
79692: PUSH
79693: LD_INT 1
79695: PUSH
79696: EMPTY
79697: LIST
79698: LIST
79699: PUSH
79700: LD_INT 1
79702: NEG
79703: PUSH
79704: LD_INT 0
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 1
79713: NEG
79714: PUSH
79715: LD_INT 1
79717: NEG
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: LIST
79727: LIST
79728: LIST
79729: LIST
79730: LIST
79731: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79732: LD_ADDR_VAR 0 63
79736: PUSH
79737: LD_INT 0
79739: PUSH
79740: LD_INT 0
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 0
79749: PUSH
79750: LD_INT 1
79752: NEG
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 1
79760: PUSH
79761: LD_INT 0
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: LD_INT 1
79770: PUSH
79771: LD_INT 1
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 0
79780: PUSH
79781: LD_INT 1
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 1
79790: NEG
79791: PUSH
79792: LD_INT 0
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 1
79801: NEG
79802: PUSH
79803: LD_INT 1
79805: NEG
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: LIST
79815: LIST
79816: LIST
79817: LIST
79818: LIST
79819: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79820: LD_ADDR_VAR 0 64
79824: PUSH
79825: LD_INT 0
79827: PUSH
79828: LD_INT 0
79830: PUSH
79831: EMPTY
79832: LIST
79833: LIST
79834: PUSH
79835: LD_INT 0
79837: PUSH
79838: LD_INT 1
79840: NEG
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: PUSH
79846: LD_INT 1
79848: PUSH
79849: LD_INT 0
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: PUSH
79856: LD_INT 1
79858: PUSH
79859: LD_INT 1
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: PUSH
79866: LD_INT 0
79868: PUSH
79869: LD_INT 1
79871: PUSH
79872: EMPTY
79873: LIST
79874: LIST
79875: PUSH
79876: LD_INT 1
79878: NEG
79879: PUSH
79880: LD_INT 0
79882: PUSH
79883: EMPTY
79884: LIST
79885: LIST
79886: PUSH
79887: LD_INT 1
79889: NEG
79890: PUSH
79891: LD_INT 1
79893: NEG
79894: PUSH
79895: EMPTY
79896: LIST
79897: LIST
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: LIST
79906: LIST
79907: ST_TO_ADDR
// end ; 1 :
79908: GO 85805
79910: LD_INT 1
79912: DOUBLE
79913: EQUAL
79914: IFTRUE 79918
79916: GO 82541
79918: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79919: LD_ADDR_VAR 0 11
79923: PUSH
79924: LD_INT 1
79926: NEG
79927: PUSH
79928: LD_INT 3
79930: NEG
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 0
79938: PUSH
79939: LD_INT 3
79941: NEG
79942: PUSH
79943: EMPTY
79944: LIST
79945: LIST
79946: PUSH
79947: LD_INT 1
79949: PUSH
79950: LD_INT 2
79952: NEG
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: LIST
79962: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79963: LD_ADDR_VAR 0 12
79967: PUSH
79968: LD_INT 2
79970: PUSH
79971: LD_INT 1
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 3
79981: PUSH
79982: LD_INT 0
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 3
79991: PUSH
79992: LD_INT 1
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: LIST
80003: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80004: LD_ADDR_VAR 0 13
80008: PUSH
80009: LD_INT 3
80011: PUSH
80012: LD_INT 2
80014: PUSH
80015: EMPTY
80016: LIST
80017: LIST
80018: PUSH
80019: LD_INT 3
80021: PUSH
80022: LD_INT 3
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 2
80031: PUSH
80032: LD_INT 3
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: EMPTY
80040: LIST
80041: LIST
80042: LIST
80043: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80044: LD_ADDR_VAR 0 14
80048: PUSH
80049: LD_INT 1
80051: PUSH
80052: LD_INT 3
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 0
80061: PUSH
80062: LD_INT 3
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: LD_INT 1
80071: NEG
80072: PUSH
80073: LD_INT 2
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: LIST
80084: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80085: LD_ADDR_VAR 0 15
80089: PUSH
80090: LD_INT 2
80092: NEG
80093: PUSH
80094: LD_INT 1
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 3
80103: NEG
80104: PUSH
80105: LD_INT 0
80107: PUSH
80108: EMPTY
80109: LIST
80110: LIST
80111: PUSH
80112: LD_INT 3
80114: NEG
80115: PUSH
80116: LD_INT 1
80118: NEG
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: LIST
80128: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80129: LD_ADDR_VAR 0 16
80133: PUSH
80134: LD_INT 2
80136: NEG
80137: PUSH
80138: LD_INT 3
80140: NEG
80141: PUSH
80142: EMPTY
80143: LIST
80144: LIST
80145: PUSH
80146: LD_INT 3
80148: NEG
80149: PUSH
80150: LD_INT 2
80152: NEG
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 3
80160: NEG
80161: PUSH
80162: LD_INT 3
80164: NEG
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: LIST
80174: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80175: LD_ADDR_VAR 0 17
80179: PUSH
80180: LD_INT 1
80182: NEG
80183: PUSH
80184: LD_INT 3
80186: NEG
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 0
80194: PUSH
80195: LD_INT 3
80197: NEG
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 1
80205: PUSH
80206: LD_INT 2
80208: NEG
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: LIST
80218: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80219: LD_ADDR_VAR 0 18
80223: PUSH
80224: LD_INT 2
80226: PUSH
80227: LD_INT 1
80229: NEG
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 3
80237: PUSH
80238: LD_INT 0
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: PUSH
80245: LD_INT 3
80247: PUSH
80248: LD_INT 1
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: LIST
80259: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80260: LD_ADDR_VAR 0 19
80264: PUSH
80265: LD_INT 3
80267: PUSH
80268: LD_INT 2
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 3
80277: PUSH
80278: LD_INT 3
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 2
80287: PUSH
80288: LD_INT 3
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: LIST
80299: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80300: LD_ADDR_VAR 0 20
80304: PUSH
80305: LD_INT 1
80307: PUSH
80308: LD_INT 3
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: LD_INT 0
80317: PUSH
80318: LD_INT 3
80320: PUSH
80321: EMPTY
80322: LIST
80323: LIST
80324: PUSH
80325: LD_INT 1
80327: NEG
80328: PUSH
80329: LD_INT 2
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: LIST
80340: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80341: LD_ADDR_VAR 0 21
80345: PUSH
80346: LD_INT 2
80348: NEG
80349: PUSH
80350: LD_INT 1
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 3
80359: NEG
80360: PUSH
80361: LD_INT 0
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: PUSH
80368: LD_INT 3
80370: NEG
80371: PUSH
80372: LD_INT 1
80374: NEG
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: EMPTY
80381: LIST
80382: LIST
80383: LIST
80384: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80385: LD_ADDR_VAR 0 22
80389: PUSH
80390: LD_INT 2
80392: NEG
80393: PUSH
80394: LD_INT 3
80396: NEG
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 3
80404: NEG
80405: PUSH
80406: LD_INT 2
80408: NEG
80409: PUSH
80410: EMPTY
80411: LIST
80412: LIST
80413: PUSH
80414: LD_INT 3
80416: NEG
80417: PUSH
80418: LD_INT 3
80420: NEG
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: LIST
80430: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
80431: LD_ADDR_VAR 0 23
80435: PUSH
80436: LD_INT 0
80438: PUSH
80439: LD_INT 3
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 1
80449: NEG
80450: PUSH
80451: LD_INT 4
80453: NEG
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 1
80461: PUSH
80462: LD_INT 3
80464: NEG
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: LIST
80474: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
80475: LD_ADDR_VAR 0 24
80479: PUSH
80480: LD_INT 3
80482: PUSH
80483: LD_INT 0
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: PUSH
80490: LD_INT 3
80492: PUSH
80493: LD_INT 1
80495: NEG
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 4
80503: PUSH
80504: LD_INT 1
80506: PUSH
80507: EMPTY
80508: LIST
80509: LIST
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: LIST
80515: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
80516: LD_ADDR_VAR 0 25
80520: PUSH
80521: LD_INT 3
80523: PUSH
80524: LD_INT 3
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 4
80533: PUSH
80534: LD_INT 3
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 3
80543: PUSH
80544: LD_INT 4
80546: PUSH
80547: EMPTY
80548: LIST
80549: LIST
80550: PUSH
80551: EMPTY
80552: LIST
80553: LIST
80554: LIST
80555: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
80556: LD_ADDR_VAR 0 26
80560: PUSH
80561: LD_INT 0
80563: PUSH
80564: LD_INT 3
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 1
80573: PUSH
80574: LD_INT 4
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 1
80583: NEG
80584: PUSH
80585: LD_INT 3
80587: PUSH
80588: EMPTY
80589: LIST
80590: LIST
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: LIST
80596: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
80597: LD_ADDR_VAR 0 27
80601: PUSH
80602: LD_INT 3
80604: NEG
80605: PUSH
80606: LD_INT 0
80608: PUSH
80609: EMPTY
80610: LIST
80611: LIST
80612: PUSH
80613: LD_INT 3
80615: NEG
80616: PUSH
80617: LD_INT 1
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 4
80626: NEG
80627: PUSH
80628: LD_INT 1
80630: NEG
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: PUSH
80636: EMPTY
80637: LIST
80638: LIST
80639: LIST
80640: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
80641: LD_ADDR_VAR 0 28
80645: PUSH
80646: LD_INT 3
80648: NEG
80649: PUSH
80650: LD_INT 3
80652: NEG
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 3
80660: NEG
80661: PUSH
80662: LD_INT 4
80664: NEG
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: LD_INT 4
80672: NEG
80673: PUSH
80674: LD_INT 3
80676: NEG
80677: PUSH
80678: EMPTY
80679: LIST
80680: LIST
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: LIST
80686: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
80687: LD_ADDR_VAR 0 29
80691: PUSH
80692: LD_INT 1
80694: NEG
80695: PUSH
80696: LD_INT 3
80698: NEG
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 0
80706: PUSH
80707: LD_INT 3
80709: NEG
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PUSH
80715: LD_INT 1
80717: PUSH
80718: LD_INT 2
80720: NEG
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 1
80728: NEG
80729: PUSH
80730: LD_INT 4
80732: NEG
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: PUSH
80738: LD_INT 0
80740: PUSH
80741: LD_INT 4
80743: NEG
80744: PUSH
80745: EMPTY
80746: LIST
80747: LIST
80748: PUSH
80749: LD_INT 1
80751: PUSH
80752: LD_INT 3
80754: NEG
80755: PUSH
80756: EMPTY
80757: LIST
80758: LIST
80759: PUSH
80760: LD_INT 1
80762: NEG
80763: PUSH
80764: LD_INT 5
80766: NEG
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PUSH
80772: LD_INT 0
80774: PUSH
80775: LD_INT 5
80777: NEG
80778: PUSH
80779: EMPTY
80780: LIST
80781: LIST
80782: PUSH
80783: LD_INT 1
80785: PUSH
80786: LD_INT 4
80788: NEG
80789: PUSH
80790: EMPTY
80791: LIST
80792: LIST
80793: PUSH
80794: LD_INT 1
80796: NEG
80797: PUSH
80798: LD_INT 6
80800: NEG
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: LD_INT 6
80811: NEG
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 1
80819: PUSH
80820: LD_INT 5
80822: NEG
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: LIST
80832: LIST
80833: LIST
80834: LIST
80835: LIST
80836: LIST
80837: LIST
80838: LIST
80839: LIST
80840: LIST
80841: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
80842: LD_ADDR_VAR 0 30
80846: PUSH
80847: LD_INT 2
80849: PUSH
80850: LD_INT 1
80852: NEG
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 3
80860: PUSH
80861: LD_INT 0
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: LD_INT 3
80870: PUSH
80871: LD_INT 1
80873: PUSH
80874: EMPTY
80875: LIST
80876: LIST
80877: PUSH
80878: LD_INT 3
80880: PUSH
80881: LD_INT 1
80883: NEG
80884: PUSH
80885: EMPTY
80886: LIST
80887: LIST
80888: PUSH
80889: LD_INT 4
80891: PUSH
80892: LD_INT 0
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: LD_INT 4
80901: PUSH
80902: LD_INT 1
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: PUSH
80909: LD_INT 4
80911: PUSH
80912: LD_INT 1
80914: NEG
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: LD_INT 5
80922: PUSH
80923: LD_INT 0
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 5
80932: PUSH
80933: LD_INT 1
80935: PUSH
80936: EMPTY
80937: LIST
80938: LIST
80939: PUSH
80940: LD_INT 5
80942: PUSH
80943: LD_INT 1
80945: NEG
80946: PUSH
80947: EMPTY
80948: LIST
80949: LIST
80950: PUSH
80951: LD_INT 6
80953: PUSH
80954: LD_INT 0
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 6
80963: PUSH
80964: LD_INT 1
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: LIST
80977: LIST
80978: LIST
80979: LIST
80980: LIST
80981: LIST
80982: LIST
80983: LIST
80984: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
80985: LD_ADDR_VAR 0 31
80989: PUSH
80990: LD_INT 3
80992: PUSH
80993: LD_INT 2
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: PUSH
81000: LD_INT 3
81002: PUSH
81003: LD_INT 3
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 2
81012: PUSH
81013: LD_INT 3
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: LD_INT 4
81022: PUSH
81023: LD_INT 3
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 4
81032: PUSH
81033: LD_INT 4
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 3
81042: PUSH
81043: LD_INT 4
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 5
81052: PUSH
81053: LD_INT 4
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 5
81062: PUSH
81063: LD_INT 5
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 4
81072: PUSH
81073: LD_INT 5
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 6
81082: PUSH
81083: LD_INT 5
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 6
81092: PUSH
81093: LD_INT 6
81095: PUSH
81096: EMPTY
81097: LIST
81098: LIST
81099: PUSH
81100: LD_INT 5
81102: PUSH
81103: LD_INT 6
81105: PUSH
81106: EMPTY
81107: LIST
81108: LIST
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: LIST
81114: LIST
81115: LIST
81116: LIST
81117: LIST
81118: LIST
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
81124: LD_ADDR_VAR 0 32
81128: PUSH
81129: LD_INT 1
81131: PUSH
81132: LD_INT 3
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_INT 0
81141: PUSH
81142: LD_INT 3
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 1
81151: NEG
81152: PUSH
81153: LD_INT 2
81155: PUSH
81156: EMPTY
81157: LIST
81158: LIST
81159: PUSH
81160: LD_INT 1
81162: PUSH
81163: LD_INT 4
81165: PUSH
81166: EMPTY
81167: LIST
81168: LIST
81169: PUSH
81170: LD_INT 0
81172: PUSH
81173: LD_INT 4
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 1
81182: NEG
81183: PUSH
81184: LD_INT 3
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: PUSH
81191: LD_INT 1
81193: PUSH
81194: LD_INT 5
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: PUSH
81201: LD_INT 0
81203: PUSH
81204: LD_INT 5
81206: PUSH
81207: EMPTY
81208: LIST
81209: LIST
81210: PUSH
81211: LD_INT 1
81213: NEG
81214: PUSH
81215: LD_INT 4
81217: PUSH
81218: EMPTY
81219: LIST
81220: LIST
81221: PUSH
81222: LD_INT 1
81224: PUSH
81225: LD_INT 6
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: PUSH
81232: LD_INT 0
81234: PUSH
81235: LD_INT 6
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 1
81244: NEG
81245: PUSH
81246: LD_INT 5
81248: PUSH
81249: EMPTY
81250: LIST
81251: LIST
81252: PUSH
81253: EMPTY
81254: LIST
81255: LIST
81256: LIST
81257: LIST
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
81267: LD_ADDR_VAR 0 33
81271: PUSH
81272: LD_INT 2
81274: NEG
81275: PUSH
81276: LD_INT 1
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 3
81285: NEG
81286: PUSH
81287: LD_INT 0
81289: PUSH
81290: EMPTY
81291: LIST
81292: LIST
81293: PUSH
81294: LD_INT 3
81296: NEG
81297: PUSH
81298: LD_INT 1
81300: NEG
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 3
81308: NEG
81309: PUSH
81310: LD_INT 1
81312: PUSH
81313: EMPTY
81314: LIST
81315: LIST
81316: PUSH
81317: LD_INT 4
81319: NEG
81320: PUSH
81321: LD_INT 0
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 4
81330: NEG
81331: PUSH
81332: LD_INT 1
81334: NEG
81335: PUSH
81336: EMPTY
81337: LIST
81338: LIST
81339: PUSH
81340: LD_INT 4
81342: NEG
81343: PUSH
81344: LD_INT 1
81346: PUSH
81347: EMPTY
81348: LIST
81349: LIST
81350: PUSH
81351: LD_INT 5
81353: NEG
81354: PUSH
81355: LD_INT 0
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: PUSH
81362: LD_INT 5
81364: NEG
81365: PUSH
81366: LD_INT 1
81368: NEG
81369: PUSH
81370: EMPTY
81371: LIST
81372: LIST
81373: PUSH
81374: LD_INT 5
81376: NEG
81377: PUSH
81378: LD_INT 1
81380: PUSH
81381: EMPTY
81382: LIST
81383: LIST
81384: PUSH
81385: LD_INT 6
81387: NEG
81388: PUSH
81389: LD_INT 0
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 6
81398: NEG
81399: PUSH
81400: LD_INT 1
81402: NEG
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: LIST
81412: LIST
81413: LIST
81414: LIST
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
81422: LD_ADDR_VAR 0 34
81426: PUSH
81427: LD_INT 2
81429: NEG
81430: PUSH
81431: LD_INT 3
81433: NEG
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 3
81441: NEG
81442: PUSH
81443: LD_INT 2
81445: NEG
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 3
81453: NEG
81454: PUSH
81455: LD_INT 3
81457: NEG
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 3
81465: NEG
81466: PUSH
81467: LD_INT 4
81469: NEG
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: PUSH
81475: LD_INT 4
81477: NEG
81478: PUSH
81479: LD_INT 3
81481: NEG
81482: PUSH
81483: EMPTY
81484: LIST
81485: LIST
81486: PUSH
81487: LD_INT 4
81489: NEG
81490: PUSH
81491: LD_INT 4
81493: NEG
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 4
81501: NEG
81502: PUSH
81503: LD_INT 5
81505: NEG
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 5
81513: NEG
81514: PUSH
81515: LD_INT 4
81517: NEG
81518: PUSH
81519: EMPTY
81520: LIST
81521: LIST
81522: PUSH
81523: LD_INT 5
81525: NEG
81526: PUSH
81527: LD_INT 5
81529: NEG
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 5
81537: NEG
81538: PUSH
81539: LD_INT 6
81541: NEG
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 6
81549: NEG
81550: PUSH
81551: LD_INT 5
81553: NEG
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_INT 6
81561: NEG
81562: PUSH
81563: LD_INT 6
81565: NEG
81566: PUSH
81567: EMPTY
81568: LIST
81569: LIST
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: LIST
81575: LIST
81576: LIST
81577: LIST
81578: LIST
81579: LIST
81580: LIST
81581: LIST
81582: LIST
81583: LIST
81584: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
81585: LD_ADDR_VAR 0 41
81589: PUSH
81590: LD_INT 0
81592: PUSH
81593: LD_INT 2
81595: NEG
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 1
81603: NEG
81604: PUSH
81605: LD_INT 3
81607: NEG
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 1
81615: PUSH
81616: LD_INT 2
81618: NEG
81619: PUSH
81620: EMPTY
81621: LIST
81622: LIST
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: LIST
81628: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
81629: LD_ADDR_VAR 0 42
81633: PUSH
81634: LD_INT 2
81636: PUSH
81637: LD_INT 0
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 2
81646: PUSH
81647: LD_INT 1
81649: NEG
81650: PUSH
81651: EMPTY
81652: LIST
81653: LIST
81654: PUSH
81655: LD_INT 3
81657: PUSH
81658: LD_INT 1
81660: PUSH
81661: EMPTY
81662: LIST
81663: LIST
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: LIST
81669: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
81670: LD_ADDR_VAR 0 43
81674: PUSH
81675: LD_INT 2
81677: PUSH
81678: LD_INT 2
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 3
81687: PUSH
81688: LD_INT 2
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: LD_INT 2
81697: PUSH
81698: LD_INT 3
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: LIST
81709: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
81710: LD_ADDR_VAR 0 44
81714: PUSH
81715: LD_INT 0
81717: PUSH
81718: LD_INT 2
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 1
81727: PUSH
81728: LD_INT 3
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 1
81737: NEG
81738: PUSH
81739: LD_INT 2
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: LIST
81750: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81751: LD_ADDR_VAR 0 45
81755: PUSH
81756: LD_INT 2
81758: NEG
81759: PUSH
81760: LD_INT 0
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 2
81769: NEG
81770: PUSH
81771: LD_INT 1
81773: PUSH
81774: EMPTY
81775: LIST
81776: LIST
81777: PUSH
81778: LD_INT 3
81780: NEG
81781: PUSH
81782: LD_INT 1
81784: NEG
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: LIST
81794: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
81795: LD_ADDR_VAR 0 46
81799: PUSH
81800: LD_INT 2
81802: NEG
81803: PUSH
81804: LD_INT 2
81806: NEG
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 2
81814: NEG
81815: PUSH
81816: LD_INT 3
81818: NEG
81819: PUSH
81820: EMPTY
81821: LIST
81822: LIST
81823: PUSH
81824: LD_INT 3
81826: NEG
81827: PUSH
81828: LD_INT 2
81830: NEG
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: LIST
81840: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
81841: LD_ADDR_VAR 0 47
81845: PUSH
81846: LD_INT 2
81848: NEG
81849: PUSH
81850: LD_INT 3
81852: NEG
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: PUSH
81858: LD_INT 1
81860: NEG
81861: PUSH
81862: LD_INT 3
81864: NEG
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81874: LD_ADDR_VAR 0 48
81878: PUSH
81879: LD_INT 1
81881: PUSH
81882: LD_INT 2
81884: NEG
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: LD_INT 2
81892: PUSH
81893: LD_INT 1
81895: NEG
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
81905: LD_ADDR_VAR 0 49
81909: PUSH
81910: LD_INT 3
81912: PUSH
81913: LD_INT 1
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 3
81922: PUSH
81923: LD_INT 2
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
81934: LD_ADDR_VAR 0 50
81938: PUSH
81939: LD_INT 2
81941: PUSH
81942: LD_INT 3
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 1
81951: PUSH
81952: LD_INT 3
81954: PUSH
81955: EMPTY
81956: LIST
81957: LIST
81958: PUSH
81959: EMPTY
81960: LIST
81961: LIST
81962: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81963: LD_ADDR_VAR 0 51
81967: PUSH
81968: LD_INT 1
81970: NEG
81971: PUSH
81972: LD_INT 2
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: LD_INT 2
81981: NEG
81982: PUSH
81983: LD_INT 1
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81994: LD_ADDR_VAR 0 52
81998: PUSH
81999: LD_INT 3
82001: NEG
82002: PUSH
82003: LD_INT 1
82005: NEG
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: LD_INT 3
82013: NEG
82014: PUSH
82015: LD_INT 2
82017: NEG
82018: PUSH
82019: EMPTY
82020: LIST
82021: LIST
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82027: LD_ADDR_VAR 0 53
82031: PUSH
82032: LD_INT 1
82034: NEG
82035: PUSH
82036: LD_INT 3
82038: NEG
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: PUSH
82044: LD_INT 0
82046: PUSH
82047: LD_INT 3
82049: NEG
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 1
82057: PUSH
82058: LD_INT 2
82060: NEG
82061: PUSH
82062: EMPTY
82063: LIST
82064: LIST
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: LIST
82070: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82071: LD_ADDR_VAR 0 54
82075: PUSH
82076: LD_INT 2
82078: PUSH
82079: LD_INT 1
82081: NEG
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 3
82089: PUSH
82090: LD_INT 0
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: LD_INT 3
82099: PUSH
82100: LD_INT 1
82102: PUSH
82103: EMPTY
82104: LIST
82105: LIST
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: LIST
82111: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
82112: LD_ADDR_VAR 0 55
82116: PUSH
82117: LD_INT 3
82119: PUSH
82120: LD_INT 2
82122: PUSH
82123: EMPTY
82124: LIST
82125: LIST
82126: PUSH
82127: LD_INT 3
82129: PUSH
82130: LD_INT 3
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 2
82139: PUSH
82140: LD_INT 3
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: LIST
82151: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
82152: LD_ADDR_VAR 0 56
82156: PUSH
82157: LD_INT 1
82159: PUSH
82160: LD_INT 3
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: PUSH
82167: LD_INT 0
82169: PUSH
82170: LD_INT 3
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 1
82179: NEG
82180: PUSH
82181: LD_INT 2
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: LIST
82192: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82193: LD_ADDR_VAR 0 57
82197: PUSH
82198: LD_INT 2
82200: NEG
82201: PUSH
82202: LD_INT 1
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 3
82211: NEG
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 3
82222: NEG
82223: PUSH
82224: LD_INT 1
82226: NEG
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: LIST
82236: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82237: LD_ADDR_VAR 0 58
82241: PUSH
82242: LD_INT 2
82244: NEG
82245: PUSH
82246: LD_INT 3
82248: NEG
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: LD_INT 3
82256: NEG
82257: PUSH
82258: LD_INT 2
82260: NEG
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 3
82268: NEG
82269: PUSH
82270: LD_INT 3
82272: NEG
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: LIST
82282: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
82283: LD_ADDR_VAR 0 59
82287: PUSH
82288: LD_INT 1
82290: NEG
82291: PUSH
82292: LD_INT 2
82294: NEG
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 0
82302: PUSH
82303: LD_INT 2
82305: NEG
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 1
82313: PUSH
82314: LD_INT 1
82316: NEG
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: LIST
82326: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
82327: LD_ADDR_VAR 0 60
82331: PUSH
82332: LD_INT 1
82334: PUSH
82335: LD_INT 1
82337: NEG
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: LD_INT 2
82345: PUSH
82346: LD_INT 0
82348: PUSH
82349: EMPTY
82350: LIST
82351: LIST
82352: PUSH
82353: LD_INT 2
82355: PUSH
82356: LD_INT 1
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: LIST
82367: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
82368: LD_ADDR_VAR 0 61
82372: PUSH
82373: LD_INT 2
82375: PUSH
82376: LD_INT 1
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 2
82385: PUSH
82386: LD_INT 2
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: LD_INT 1
82395: PUSH
82396: LD_INT 2
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: EMPTY
82404: LIST
82405: LIST
82406: LIST
82407: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
82408: LD_ADDR_VAR 0 62
82412: PUSH
82413: LD_INT 1
82415: PUSH
82416: LD_INT 2
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: LD_INT 0
82425: PUSH
82426: LD_INT 2
82428: PUSH
82429: EMPTY
82430: LIST
82431: LIST
82432: PUSH
82433: LD_INT 1
82435: NEG
82436: PUSH
82437: LD_INT 1
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: LIST
82448: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
82449: LD_ADDR_VAR 0 63
82453: PUSH
82454: LD_INT 1
82456: NEG
82457: PUSH
82458: LD_INT 1
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: PUSH
82465: LD_INT 2
82467: NEG
82468: PUSH
82469: LD_INT 0
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: PUSH
82476: LD_INT 2
82478: NEG
82479: PUSH
82480: LD_INT 1
82482: NEG
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: LIST
82492: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82493: LD_ADDR_VAR 0 64
82497: PUSH
82498: LD_INT 1
82500: NEG
82501: PUSH
82502: LD_INT 2
82504: NEG
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 2
82512: NEG
82513: PUSH
82514: LD_INT 1
82516: NEG
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 2
82524: NEG
82525: PUSH
82526: LD_INT 2
82528: NEG
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: LIST
82538: ST_TO_ADDR
// end ; 2 :
82539: GO 85805
82541: LD_INT 2
82543: DOUBLE
82544: EQUAL
82545: IFTRUE 82549
82547: GO 85804
82549: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
82550: LD_ADDR_VAR 0 29
82554: PUSH
82555: LD_INT 4
82557: PUSH
82558: LD_INT 0
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 4
82567: PUSH
82568: LD_INT 1
82570: NEG
82571: PUSH
82572: EMPTY
82573: LIST
82574: LIST
82575: PUSH
82576: LD_INT 5
82578: PUSH
82579: LD_INT 0
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: LD_INT 5
82588: PUSH
82589: LD_INT 1
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 4
82598: PUSH
82599: LD_INT 1
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 3
82608: PUSH
82609: LD_INT 0
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 3
82618: PUSH
82619: LD_INT 1
82621: NEG
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 3
82629: PUSH
82630: LD_INT 2
82632: NEG
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 5
82640: PUSH
82641: LD_INT 2
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 3
82650: PUSH
82651: LD_INT 3
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 3
82660: PUSH
82661: LD_INT 2
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 4
82670: PUSH
82671: LD_INT 3
82673: PUSH
82674: EMPTY
82675: LIST
82676: LIST
82677: PUSH
82678: LD_INT 4
82680: PUSH
82681: LD_INT 4
82683: PUSH
82684: EMPTY
82685: LIST
82686: LIST
82687: PUSH
82688: LD_INT 3
82690: PUSH
82691: LD_INT 4
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: PUSH
82698: LD_INT 2
82700: PUSH
82701: LD_INT 3
82703: PUSH
82704: EMPTY
82705: LIST
82706: LIST
82707: PUSH
82708: LD_INT 2
82710: PUSH
82711: LD_INT 2
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PUSH
82718: LD_INT 4
82720: PUSH
82721: LD_INT 2
82723: PUSH
82724: EMPTY
82725: LIST
82726: LIST
82727: PUSH
82728: LD_INT 2
82730: PUSH
82731: LD_INT 4
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: LD_INT 0
82740: PUSH
82741: LD_INT 4
82743: PUSH
82744: EMPTY
82745: LIST
82746: LIST
82747: PUSH
82748: LD_INT 0
82750: PUSH
82751: LD_INT 3
82753: PUSH
82754: EMPTY
82755: LIST
82756: LIST
82757: PUSH
82758: LD_INT 1
82760: PUSH
82761: LD_INT 4
82763: PUSH
82764: EMPTY
82765: LIST
82766: LIST
82767: PUSH
82768: LD_INT 1
82770: PUSH
82771: LD_INT 5
82773: PUSH
82774: EMPTY
82775: LIST
82776: LIST
82777: PUSH
82778: LD_INT 0
82780: PUSH
82781: LD_INT 5
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 1
82790: NEG
82791: PUSH
82792: LD_INT 4
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 1
82801: NEG
82802: PUSH
82803: LD_INT 3
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 2
82812: PUSH
82813: LD_INT 5
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: PUSH
82820: LD_INT 2
82822: NEG
82823: PUSH
82824: LD_INT 3
82826: PUSH
82827: EMPTY
82828: LIST
82829: LIST
82830: PUSH
82831: LD_INT 3
82833: NEG
82834: PUSH
82835: LD_INT 0
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 3
82844: NEG
82845: PUSH
82846: LD_INT 1
82848: NEG
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 2
82856: NEG
82857: PUSH
82858: LD_INT 0
82860: PUSH
82861: EMPTY
82862: LIST
82863: LIST
82864: PUSH
82865: LD_INT 2
82867: NEG
82868: PUSH
82869: LD_INT 1
82871: PUSH
82872: EMPTY
82873: LIST
82874: LIST
82875: PUSH
82876: LD_INT 3
82878: NEG
82879: PUSH
82880: LD_INT 1
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 4
82889: NEG
82890: PUSH
82891: LD_INT 0
82893: PUSH
82894: EMPTY
82895: LIST
82896: LIST
82897: PUSH
82898: LD_INT 4
82900: NEG
82901: PUSH
82902: LD_INT 1
82904: NEG
82905: PUSH
82906: EMPTY
82907: LIST
82908: LIST
82909: PUSH
82910: LD_INT 4
82912: NEG
82913: PUSH
82914: LD_INT 2
82916: NEG
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: PUSH
82922: LD_INT 2
82924: NEG
82925: PUSH
82926: LD_INT 2
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 4
82935: NEG
82936: PUSH
82937: LD_INT 4
82939: NEG
82940: PUSH
82941: EMPTY
82942: LIST
82943: LIST
82944: PUSH
82945: LD_INT 4
82947: NEG
82948: PUSH
82949: LD_INT 5
82951: NEG
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 3
82959: NEG
82960: PUSH
82961: LD_INT 4
82963: NEG
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 3
82971: NEG
82972: PUSH
82973: LD_INT 3
82975: NEG
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PUSH
82981: LD_INT 4
82983: NEG
82984: PUSH
82985: LD_INT 3
82987: NEG
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PUSH
82993: LD_INT 5
82995: NEG
82996: PUSH
82997: LD_INT 4
82999: NEG
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: PUSH
83005: LD_INT 5
83007: NEG
83008: PUSH
83009: LD_INT 5
83011: NEG
83012: PUSH
83013: EMPTY
83014: LIST
83015: LIST
83016: PUSH
83017: LD_INT 3
83019: NEG
83020: PUSH
83021: LD_INT 5
83023: NEG
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 5
83031: NEG
83032: PUSH
83033: LD_INT 3
83035: NEG
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: LIST
83060: LIST
83061: LIST
83062: LIST
83063: LIST
83064: LIST
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
83088: LD_ADDR_VAR 0 30
83092: PUSH
83093: LD_INT 4
83095: PUSH
83096: LD_INT 4
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: LD_INT 4
83105: PUSH
83106: LD_INT 3
83108: PUSH
83109: EMPTY
83110: LIST
83111: LIST
83112: PUSH
83113: LD_INT 5
83115: PUSH
83116: LD_INT 4
83118: PUSH
83119: EMPTY
83120: LIST
83121: LIST
83122: PUSH
83123: LD_INT 5
83125: PUSH
83126: LD_INT 5
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: LD_INT 4
83135: PUSH
83136: LD_INT 5
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: PUSH
83143: LD_INT 3
83145: PUSH
83146: LD_INT 4
83148: PUSH
83149: EMPTY
83150: LIST
83151: LIST
83152: PUSH
83153: LD_INT 3
83155: PUSH
83156: LD_INT 3
83158: PUSH
83159: EMPTY
83160: LIST
83161: LIST
83162: PUSH
83163: LD_INT 5
83165: PUSH
83166: LD_INT 3
83168: PUSH
83169: EMPTY
83170: LIST
83171: LIST
83172: PUSH
83173: LD_INT 3
83175: PUSH
83176: LD_INT 5
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 0
83185: PUSH
83186: LD_INT 3
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: PUSH
83193: LD_INT 0
83195: PUSH
83196: LD_INT 2
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 1
83205: PUSH
83206: LD_INT 3
83208: PUSH
83209: EMPTY
83210: LIST
83211: LIST
83212: PUSH
83213: LD_INT 1
83215: PUSH
83216: LD_INT 4
83218: PUSH
83219: EMPTY
83220: LIST
83221: LIST
83222: PUSH
83223: LD_INT 0
83225: PUSH
83226: LD_INT 4
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: PUSH
83233: LD_INT 1
83235: NEG
83236: PUSH
83237: LD_INT 3
83239: PUSH
83240: EMPTY
83241: LIST
83242: LIST
83243: PUSH
83244: LD_INT 1
83246: NEG
83247: PUSH
83248: LD_INT 2
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 2
83257: PUSH
83258: LD_INT 4
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: PUSH
83265: LD_INT 2
83267: NEG
83268: PUSH
83269: LD_INT 2
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: PUSH
83276: LD_INT 4
83278: NEG
83279: PUSH
83280: LD_INT 0
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 4
83289: NEG
83290: PUSH
83291: LD_INT 1
83293: NEG
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PUSH
83299: LD_INT 3
83301: NEG
83302: PUSH
83303: LD_INT 0
83305: PUSH
83306: EMPTY
83307: LIST
83308: LIST
83309: PUSH
83310: LD_INT 3
83312: NEG
83313: PUSH
83314: LD_INT 1
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: PUSH
83321: LD_INT 4
83323: NEG
83324: PUSH
83325: LD_INT 1
83327: PUSH
83328: EMPTY
83329: LIST
83330: LIST
83331: PUSH
83332: LD_INT 5
83334: NEG
83335: PUSH
83336: LD_INT 0
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: PUSH
83343: LD_INT 5
83345: NEG
83346: PUSH
83347: LD_INT 1
83349: NEG
83350: PUSH
83351: EMPTY
83352: LIST
83353: LIST
83354: PUSH
83355: LD_INT 5
83357: NEG
83358: PUSH
83359: LD_INT 2
83361: NEG
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: LD_INT 3
83369: NEG
83370: PUSH
83371: LD_INT 2
83373: PUSH
83374: EMPTY
83375: LIST
83376: LIST
83377: PUSH
83378: LD_INT 3
83380: NEG
83381: PUSH
83382: LD_INT 3
83384: NEG
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 3
83392: NEG
83393: PUSH
83394: LD_INT 4
83396: NEG
83397: PUSH
83398: EMPTY
83399: LIST
83400: LIST
83401: PUSH
83402: LD_INT 2
83404: NEG
83405: PUSH
83406: LD_INT 3
83408: NEG
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: LD_INT 2
83416: NEG
83417: PUSH
83418: LD_INT 2
83420: NEG
83421: PUSH
83422: EMPTY
83423: LIST
83424: LIST
83425: PUSH
83426: LD_INT 3
83428: NEG
83429: PUSH
83430: LD_INT 2
83432: NEG
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: PUSH
83438: LD_INT 4
83440: NEG
83441: PUSH
83442: LD_INT 3
83444: NEG
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 4
83452: NEG
83453: PUSH
83454: LD_INT 4
83456: NEG
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 2
83464: NEG
83465: PUSH
83466: LD_INT 4
83468: NEG
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 4
83476: NEG
83477: PUSH
83478: LD_INT 2
83480: NEG
83481: PUSH
83482: EMPTY
83483: LIST
83484: LIST
83485: PUSH
83486: LD_INT 0
83488: PUSH
83489: LD_INT 4
83491: NEG
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: LD_INT 0
83499: PUSH
83500: LD_INT 5
83502: NEG
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: PUSH
83508: LD_INT 1
83510: PUSH
83511: LD_INT 4
83513: NEG
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: LD_INT 1
83521: PUSH
83522: LD_INT 3
83524: NEG
83525: PUSH
83526: EMPTY
83527: LIST
83528: LIST
83529: PUSH
83530: LD_INT 0
83532: PUSH
83533: LD_INT 3
83535: NEG
83536: PUSH
83537: EMPTY
83538: LIST
83539: LIST
83540: PUSH
83541: LD_INT 1
83543: NEG
83544: PUSH
83545: LD_INT 4
83547: NEG
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: PUSH
83553: LD_INT 1
83555: NEG
83556: PUSH
83557: LD_INT 5
83559: NEG
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: PUSH
83565: LD_INT 2
83567: PUSH
83568: LD_INT 3
83570: NEG
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: PUSH
83576: LD_INT 2
83578: NEG
83579: PUSH
83580: LD_INT 5
83582: NEG
83583: PUSH
83584: EMPTY
83585: LIST
83586: LIST
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: LIST
83592: LIST
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
83635: LD_ADDR_VAR 0 31
83639: PUSH
83640: LD_INT 0
83642: PUSH
83643: LD_INT 4
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: PUSH
83650: LD_INT 0
83652: PUSH
83653: LD_INT 3
83655: PUSH
83656: EMPTY
83657: LIST
83658: LIST
83659: PUSH
83660: LD_INT 1
83662: PUSH
83663: LD_INT 4
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: LD_INT 1
83672: PUSH
83673: LD_INT 5
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 0
83682: PUSH
83683: LD_INT 5
83685: PUSH
83686: EMPTY
83687: LIST
83688: LIST
83689: PUSH
83690: LD_INT 1
83692: NEG
83693: PUSH
83694: LD_INT 4
83696: PUSH
83697: EMPTY
83698: LIST
83699: LIST
83700: PUSH
83701: LD_INT 1
83703: NEG
83704: PUSH
83705: LD_INT 3
83707: PUSH
83708: EMPTY
83709: LIST
83710: LIST
83711: PUSH
83712: LD_INT 2
83714: PUSH
83715: LD_INT 5
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PUSH
83722: LD_INT 2
83724: NEG
83725: PUSH
83726: LD_INT 3
83728: PUSH
83729: EMPTY
83730: LIST
83731: LIST
83732: PUSH
83733: LD_INT 3
83735: NEG
83736: PUSH
83737: LD_INT 0
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: PUSH
83744: LD_INT 3
83746: NEG
83747: PUSH
83748: LD_INT 1
83750: NEG
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 2
83758: NEG
83759: PUSH
83760: LD_INT 0
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: PUSH
83767: LD_INT 2
83769: NEG
83770: PUSH
83771: LD_INT 1
83773: PUSH
83774: EMPTY
83775: LIST
83776: LIST
83777: PUSH
83778: LD_INT 3
83780: NEG
83781: PUSH
83782: LD_INT 1
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: PUSH
83789: LD_INT 4
83791: NEG
83792: PUSH
83793: LD_INT 0
83795: PUSH
83796: EMPTY
83797: LIST
83798: LIST
83799: PUSH
83800: LD_INT 4
83802: NEG
83803: PUSH
83804: LD_INT 1
83806: NEG
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: PUSH
83812: LD_INT 4
83814: NEG
83815: PUSH
83816: LD_INT 2
83818: NEG
83819: PUSH
83820: EMPTY
83821: LIST
83822: LIST
83823: PUSH
83824: LD_INT 2
83826: NEG
83827: PUSH
83828: LD_INT 2
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PUSH
83835: LD_INT 4
83837: NEG
83838: PUSH
83839: LD_INT 4
83841: NEG
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: PUSH
83847: LD_INT 4
83849: NEG
83850: PUSH
83851: LD_INT 5
83853: NEG
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: LD_INT 3
83861: NEG
83862: PUSH
83863: LD_INT 4
83865: NEG
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: PUSH
83871: LD_INT 3
83873: NEG
83874: PUSH
83875: LD_INT 3
83877: NEG
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 4
83885: NEG
83886: PUSH
83887: LD_INT 3
83889: NEG
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 5
83897: NEG
83898: PUSH
83899: LD_INT 4
83901: NEG
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: PUSH
83907: LD_INT 5
83909: NEG
83910: PUSH
83911: LD_INT 5
83913: NEG
83914: PUSH
83915: EMPTY
83916: LIST
83917: LIST
83918: PUSH
83919: LD_INT 3
83921: NEG
83922: PUSH
83923: LD_INT 5
83925: NEG
83926: PUSH
83927: EMPTY
83928: LIST
83929: LIST
83930: PUSH
83931: LD_INT 5
83933: NEG
83934: PUSH
83935: LD_INT 3
83937: NEG
83938: PUSH
83939: EMPTY
83940: LIST
83941: LIST
83942: PUSH
83943: LD_INT 0
83945: PUSH
83946: LD_INT 3
83948: NEG
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: PUSH
83954: LD_INT 0
83956: PUSH
83957: LD_INT 4
83959: NEG
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 1
83967: PUSH
83968: LD_INT 3
83970: NEG
83971: PUSH
83972: EMPTY
83973: LIST
83974: LIST
83975: PUSH
83976: LD_INT 1
83978: PUSH
83979: LD_INT 2
83981: NEG
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: LD_INT 0
83989: PUSH
83990: LD_INT 2
83992: NEG
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: PUSH
83998: LD_INT 1
84000: NEG
84001: PUSH
84002: LD_INT 3
84004: NEG
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 1
84012: NEG
84013: PUSH
84014: LD_INT 4
84016: NEG
84017: PUSH
84018: EMPTY
84019: LIST
84020: LIST
84021: PUSH
84022: LD_INT 2
84024: PUSH
84025: LD_INT 2
84027: NEG
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PUSH
84033: LD_INT 2
84035: NEG
84036: PUSH
84037: LD_INT 4
84039: NEG
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 4
84047: PUSH
84048: LD_INT 0
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: LD_INT 4
84057: PUSH
84058: LD_INT 1
84060: NEG
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: PUSH
84066: LD_INT 5
84068: PUSH
84069: LD_INT 0
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PUSH
84076: LD_INT 5
84078: PUSH
84079: LD_INT 1
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 4
84088: PUSH
84089: LD_INT 1
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 3
84098: PUSH
84099: LD_INT 0
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: LD_INT 3
84108: PUSH
84109: LD_INT 1
84111: NEG
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: PUSH
84117: LD_INT 3
84119: PUSH
84120: LD_INT 2
84122: NEG
84123: PUSH
84124: EMPTY
84125: LIST
84126: LIST
84127: PUSH
84128: LD_INT 5
84130: PUSH
84131: LD_INT 2
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: LIST
84173: LIST
84174: LIST
84175: LIST
84176: LIST
84177: LIST
84178: LIST
84179: LIST
84180: LIST
84181: LIST
84182: LIST
84183: LIST
84184: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
84185: LD_ADDR_VAR 0 32
84189: PUSH
84190: LD_INT 4
84192: NEG
84193: PUSH
84194: LD_INT 0
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: PUSH
84201: LD_INT 4
84203: NEG
84204: PUSH
84205: LD_INT 1
84207: NEG
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 3
84215: NEG
84216: PUSH
84217: LD_INT 0
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 3
84226: NEG
84227: PUSH
84228: LD_INT 1
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: LD_INT 4
84237: NEG
84238: PUSH
84239: LD_INT 1
84241: PUSH
84242: EMPTY
84243: LIST
84244: LIST
84245: PUSH
84246: LD_INT 5
84248: NEG
84249: PUSH
84250: LD_INT 0
84252: PUSH
84253: EMPTY
84254: LIST
84255: LIST
84256: PUSH
84257: LD_INT 5
84259: NEG
84260: PUSH
84261: LD_INT 1
84263: NEG
84264: PUSH
84265: EMPTY
84266: LIST
84267: LIST
84268: PUSH
84269: LD_INT 5
84271: NEG
84272: PUSH
84273: LD_INT 2
84275: NEG
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PUSH
84281: LD_INT 3
84283: NEG
84284: PUSH
84285: LD_INT 2
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: LD_INT 3
84294: NEG
84295: PUSH
84296: LD_INT 3
84298: NEG
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: PUSH
84304: LD_INT 3
84306: NEG
84307: PUSH
84308: LD_INT 4
84310: NEG
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 2
84318: NEG
84319: PUSH
84320: LD_INT 3
84322: NEG
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 2
84330: NEG
84331: PUSH
84332: LD_INT 2
84334: NEG
84335: PUSH
84336: EMPTY
84337: LIST
84338: LIST
84339: PUSH
84340: LD_INT 3
84342: NEG
84343: PUSH
84344: LD_INT 2
84346: NEG
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: PUSH
84352: LD_INT 4
84354: NEG
84355: PUSH
84356: LD_INT 3
84358: NEG
84359: PUSH
84360: EMPTY
84361: LIST
84362: LIST
84363: PUSH
84364: LD_INT 4
84366: NEG
84367: PUSH
84368: LD_INT 4
84370: NEG
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: PUSH
84376: LD_INT 2
84378: NEG
84379: PUSH
84380: LD_INT 4
84382: NEG
84383: PUSH
84384: EMPTY
84385: LIST
84386: LIST
84387: PUSH
84388: LD_INT 4
84390: NEG
84391: PUSH
84392: LD_INT 2
84394: NEG
84395: PUSH
84396: EMPTY
84397: LIST
84398: LIST
84399: PUSH
84400: LD_INT 0
84402: PUSH
84403: LD_INT 4
84405: NEG
84406: PUSH
84407: EMPTY
84408: LIST
84409: LIST
84410: PUSH
84411: LD_INT 0
84413: PUSH
84414: LD_INT 5
84416: NEG
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: PUSH
84422: LD_INT 1
84424: PUSH
84425: LD_INT 4
84427: NEG
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: PUSH
84433: LD_INT 1
84435: PUSH
84436: LD_INT 3
84438: NEG
84439: PUSH
84440: EMPTY
84441: LIST
84442: LIST
84443: PUSH
84444: LD_INT 0
84446: PUSH
84447: LD_INT 3
84449: NEG
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: PUSH
84455: LD_INT 1
84457: NEG
84458: PUSH
84459: LD_INT 4
84461: NEG
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: PUSH
84467: LD_INT 1
84469: NEG
84470: PUSH
84471: LD_INT 5
84473: NEG
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: PUSH
84479: LD_INT 2
84481: PUSH
84482: LD_INT 3
84484: NEG
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 2
84492: NEG
84493: PUSH
84494: LD_INT 5
84496: NEG
84497: PUSH
84498: EMPTY
84499: LIST
84500: LIST
84501: PUSH
84502: LD_INT 3
84504: PUSH
84505: LD_INT 0
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: PUSH
84512: LD_INT 3
84514: PUSH
84515: LD_INT 1
84517: NEG
84518: PUSH
84519: EMPTY
84520: LIST
84521: LIST
84522: PUSH
84523: LD_INT 4
84525: PUSH
84526: LD_INT 0
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: PUSH
84533: LD_INT 4
84535: PUSH
84536: LD_INT 1
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: PUSH
84543: LD_INT 3
84545: PUSH
84546: LD_INT 1
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: PUSH
84553: LD_INT 2
84555: PUSH
84556: LD_INT 0
84558: PUSH
84559: EMPTY
84560: LIST
84561: LIST
84562: PUSH
84563: LD_INT 2
84565: PUSH
84566: LD_INT 1
84568: NEG
84569: PUSH
84570: EMPTY
84571: LIST
84572: LIST
84573: PUSH
84574: LD_INT 2
84576: PUSH
84577: LD_INT 2
84579: NEG
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: PUSH
84585: LD_INT 4
84587: PUSH
84588: LD_INT 2
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 4
84597: PUSH
84598: LD_INT 4
84600: PUSH
84601: EMPTY
84602: LIST
84603: LIST
84604: PUSH
84605: LD_INT 4
84607: PUSH
84608: LD_INT 3
84610: PUSH
84611: EMPTY
84612: LIST
84613: LIST
84614: PUSH
84615: LD_INT 5
84617: PUSH
84618: LD_INT 4
84620: PUSH
84621: EMPTY
84622: LIST
84623: LIST
84624: PUSH
84625: LD_INT 5
84627: PUSH
84628: LD_INT 5
84630: PUSH
84631: EMPTY
84632: LIST
84633: LIST
84634: PUSH
84635: LD_INT 4
84637: PUSH
84638: LD_INT 5
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: LD_INT 3
84647: PUSH
84648: LD_INT 4
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: PUSH
84655: LD_INT 3
84657: PUSH
84658: LD_INT 3
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PUSH
84665: LD_INT 5
84667: PUSH
84668: LD_INT 3
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PUSH
84675: LD_INT 3
84677: PUSH
84678: LD_INT 5
84680: PUSH
84681: EMPTY
84682: LIST
84683: LIST
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: LIST
84691: LIST
84692: LIST
84693: LIST
84694: LIST
84695: LIST
84696: LIST
84697: LIST
84698: LIST
84699: LIST
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: LIST
84705: LIST
84706: LIST
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: LIST
84712: LIST
84713: LIST
84714: LIST
84715: LIST
84716: LIST
84717: LIST
84718: LIST
84719: LIST
84720: LIST
84721: LIST
84722: LIST
84723: LIST
84724: LIST
84725: LIST
84726: LIST
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
84732: LD_ADDR_VAR 0 33
84736: PUSH
84737: LD_INT 4
84739: NEG
84740: PUSH
84741: LD_INT 4
84743: NEG
84744: PUSH
84745: EMPTY
84746: LIST
84747: LIST
84748: PUSH
84749: LD_INT 4
84751: NEG
84752: PUSH
84753: LD_INT 5
84755: NEG
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: LD_INT 3
84763: NEG
84764: PUSH
84765: LD_INT 4
84767: NEG
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: LD_INT 3
84775: NEG
84776: PUSH
84777: LD_INT 3
84779: NEG
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: PUSH
84785: LD_INT 4
84787: NEG
84788: PUSH
84789: LD_INT 3
84791: NEG
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: PUSH
84797: LD_INT 5
84799: NEG
84800: PUSH
84801: LD_INT 4
84803: NEG
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: PUSH
84809: LD_INT 5
84811: NEG
84812: PUSH
84813: LD_INT 5
84815: NEG
84816: PUSH
84817: EMPTY
84818: LIST
84819: LIST
84820: PUSH
84821: LD_INT 3
84823: NEG
84824: PUSH
84825: LD_INT 5
84827: NEG
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: PUSH
84833: LD_INT 5
84835: NEG
84836: PUSH
84837: LD_INT 3
84839: NEG
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: LD_INT 0
84847: PUSH
84848: LD_INT 3
84850: NEG
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: PUSH
84856: LD_INT 0
84858: PUSH
84859: LD_INT 4
84861: NEG
84862: PUSH
84863: EMPTY
84864: LIST
84865: LIST
84866: PUSH
84867: LD_INT 1
84869: PUSH
84870: LD_INT 3
84872: NEG
84873: PUSH
84874: EMPTY
84875: LIST
84876: LIST
84877: PUSH
84878: LD_INT 1
84880: PUSH
84881: LD_INT 2
84883: NEG
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: LD_INT 0
84891: PUSH
84892: LD_INT 2
84894: NEG
84895: PUSH
84896: EMPTY
84897: LIST
84898: LIST
84899: PUSH
84900: LD_INT 1
84902: NEG
84903: PUSH
84904: LD_INT 3
84906: NEG
84907: PUSH
84908: EMPTY
84909: LIST
84910: LIST
84911: PUSH
84912: LD_INT 1
84914: NEG
84915: PUSH
84916: LD_INT 4
84918: NEG
84919: PUSH
84920: EMPTY
84921: LIST
84922: LIST
84923: PUSH
84924: LD_INT 2
84926: PUSH
84927: LD_INT 2
84929: NEG
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: PUSH
84935: LD_INT 2
84937: NEG
84938: PUSH
84939: LD_INT 4
84941: NEG
84942: PUSH
84943: EMPTY
84944: LIST
84945: LIST
84946: PUSH
84947: LD_INT 4
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 4
84959: PUSH
84960: LD_INT 1
84962: NEG
84963: PUSH
84964: EMPTY
84965: LIST
84966: LIST
84967: PUSH
84968: LD_INT 5
84970: PUSH
84971: LD_INT 0
84973: PUSH
84974: EMPTY
84975: LIST
84976: LIST
84977: PUSH
84978: LD_INT 5
84980: PUSH
84981: LD_INT 1
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PUSH
84988: LD_INT 4
84990: PUSH
84991: LD_INT 1
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PUSH
84998: LD_INT 3
85000: PUSH
85001: LD_INT 0
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: PUSH
85008: LD_INT 3
85010: PUSH
85011: LD_INT 1
85013: NEG
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: PUSH
85019: LD_INT 3
85021: PUSH
85022: LD_INT 2
85024: NEG
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_INT 5
85032: PUSH
85033: LD_INT 2
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PUSH
85040: LD_INT 3
85042: PUSH
85043: LD_INT 3
85045: PUSH
85046: EMPTY
85047: LIST
85048: LIST
85049: PUSH
85050: LD_INT 3
85052: PUSH
85053: LD_INT 2
85055: PUSH
85056: EMPTY
85057: LIST
85058: LIST
85059: PUSH
85060: LD_INT 4
85062: PUSH
85063: LD_INT 3
85065: PUSH
85066: EMPTY
85067: LIST
85068: LIST
85069: PUSH
85070: LD_INT 4
85072: PUSH
85073: LD_INT 4
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: PUSH
85080: LD_INT 3
85082: PUSH
85083: LD_INT 4
85085: PUSH
85086: EMPTY
85087: LIST
85088: LIST
85089: PUSH
85090: LD_INT 2
85092: PUSH
85093: LD_INT 3
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: LD_INT 2
85102: PUSH
85103: LD_INT 2
85105: PUSH
85106: EMPTY
85107: LIST
85108: LIST
85109: PUSH
85110: LD_INT 4
85112: PUSH
85113: LD_INT 2
85115: PUSH
85116: EMPTY
85117: LIST
85118: LIST
85119: PUSH
85120: LD_INT 2
85122: PUSH
85123: LD_INT 4
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 0
85132: PUSH
85133: LD_INT 4
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 0
85142: PUSH
85143: LD_INT 3
85145: PUSH
85146: EMPTY
85147: LIST
85148: LIST
85149: PUSH
85150: LD_INT 1
85152: PUSH
85153: LD_INT 4
85155: PUSH
85156: EMPTY
85157: LIST
85158: LIST
85159: PUSH
85160: LD_INT 1
85162: PUSH
85163: LD_INT 5
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: PUSH
85170: LD_INT 0
85172: PUSH
85173: LD_INT 5
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 1
85182: NEG
85183: PUSH
85184: LD_INT 4
85186: PUSH
85187: EMPTY
85188: LIST
85189: LIST
85190: PUSH
85191: LD_INT 1
85193: NEG
85194: PUSH
85195: LD_INT 3
85197: PUSH
85198: EMPTY
85199: LIST
85200: LIST
85201: PUSH
85202: LD_INT 2
85204: PUSH
85205: LD_INT 5
85207: PUSH
85208: EMPTY
85209: LIST
85210: LIST
85211: PUSH
85212: LD_INT 2
85214: NEG
85215: PUSH
85216: LD_INT 3
85218: PUSH
85219: EMPTY
85220: LIST
85221: LIST
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: LIST
85237: LIST
85238: LIST
85239: LIST
85240: LIST
85241: LIST
85242: LIST
85243: LIST
85244: LIST
85245: LIST
85246: LIST
85247: LIST
85248: LIST
85249: LIST
85250: LIST
85251: LIST
85252: LIST
85253: LIST
85254: LIST
85255: LIST
85256: LIST
85257: LIST
85258: LIST
85259: LIST
85260: LIST
85261: LIST
85262: LIST
85263: LIST
85264: LIST
85265: LIST
85266: LIST
85267: LIST
85268: LIST
85269: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
85270: LD_ADDR_VAR 0 34
85274: PUSH
85275: LD_INT 0
85277: PUSH
85278: LD_INT 4
85280: NEG
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: LD_INT 0
85288: PUSH
85289: LD_INT 5
85291: NEG
85292: PUSH
85293: EMPTY
85294: LIST
85295: LIST
85296: PUSH
85297: LD_INT 1
85299: PUSH
85300: LD_INT 4
85302: NEG
85303: PUSH
85304: EMPTY
85305: LIST
85306: LIST
85307: PUSH
85308: LD_INT 1
85310: PUSH
85311: LD_INT 3
85313: NEG
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 0
85321: PUSH
85322: LD_INT 3
85324: NEG
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: PUSH
85330: LD_INT 1
85332: NEG
85333: PUSH
85334: LD_INT 4
85336: NEG
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 1
85344: NEG
85345: PUSH
85346: LD_INT 5
85348: NEG
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PUSH
85354: LD_INT 2
85356: PUSH
85357: LD_INT 3
85359: NEG
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: PUSH
85365: LD_INT 2
85367: NEG
85368: PUSH
85369: LD_INT 5
85371: NEG
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: PUSH
85377: LD_INT 3
85379: PUSH
85380: LD_INT 0
85382: PUSH
85383: EMPTY
85384: LIST
85385: LIST
85386: PUSH
85387: LD_INT 3
85389: PUSH
85390: LD_INT 1
85392: NEG
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 4
85400: PUSH
85401: LD_INT 0
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 4
85410: PUSH
85411: LD_INT 1
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 3
85420: PUSH
85421: LD_INT 1
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 2
85430: PUSH
85431: LD_INT 0
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 2
85440: PUSH
85441: LD_INT 1
85443: NEG
85444: PUSH
85445: EMPTY
85446: LIST
85447: LIST
85448: PUSH
85449: LD_INT 2
85451: PUSH
85452: LD_INT 2
85454: NEG
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 4
85462: PUSH
85463: LD_INT 2
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PUSH
85470: LD_INT 4
85472: PUSH
85473: LD_INT 4
85475: PUSH
85476: EMPTY
85477: LIST
85478: LIST
85479: PUSH
85480: LD_INT 4
85482: PUSH
85483: LD_INT 3
85485: PUSH
85486: EMPTY
85487: LIST
85488: LIST
85489: PUSH
85490: LD_INT 5
85492: PUSH
85493: LD_INT 4
85495: PUSH
85496: EMPTY
85497: LIST
85498: LIST
85499: PUSH
85500: LD_INT 5
85502: PUSH
85503: LD_INT 5
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: PUSH
85510: LD_INT 4
85512: PUSH
85513: LD_INT 5
85515: PUSH
85516: EMPTY
85517: LIST
85518: LIST
85519: PUSH
85520: LD_INT 3
85522: PUSH
85523: LD_INT 4
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: PUSH
85530: LD_INT 3
85532: PUSH
85533: LD_INT 3
85535: PUSH
85536: EMPTY
85537: LIST
85538: LIST
85539: PUSH
85540: LD_INT 5
85542: PUSH
85543: LD_INT 3
85545: PUSH
85546: EMPTY
85547: LIST
85548: LIST
85549: PUSH
85550: LD_INT 3
85552: PUSH
85553: LD_INT 5
85555: PUSH
85556: EMPTY
85557: LIST
85558: LIST
85559: PUSH
85560: LD_INT 0
85562: PUSH
85563: LD_INT 3
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: LD_INT 0
85572: PUSH
85573: LD_INT 2
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: PUSH
85580: LD_INT 1
85582: PUSH
85583: LD_INT 3
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: PUSH
85590: LD_INT 1
85592: PUSH
85593: LD_INT 4
85595: PUSH
85596: EMPTY
85597: LIST
85598: LIST
85599: PUSH
85600: LD_INT 0
85602: PUSH
85603: LD_INT 4
85605: PUSH
85606: EMPTY
85607: LIST
85608: LIST
85609: PUSH
85610: LD_INT 1
85612: NEG
85613: PUSH
85614: LD_INT 3
85616: PUSH
85617: EMPTY
85618: LIST
85619: LIST
85620: PUSH
85621: LD_INT 1
85623: NEG
85624: PUSH
85625: LD_INT 2
85627: PUSH
85628: EMPTY
85629: LIST
85630: LIST
85631: PUSH
85632: LD_INT 2
85634: PUSH
85635: LD_INT 4
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 2
85644: NEG
85645: PUSH
85646: LD_INT 2
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 4
85655: NEG
85656: PUSH
85657: LD_INT 0
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: PUSH
85664: LD_INT 4
85666: NEG
85667: PUSH
85668: LD_INT 1
85670: NEG
85671: PUSH
85672: EMPTY
85673: LIST
85674: LIST
85675: PUSH
85676: LD_INT 3
85678: NEG
85679: PUSH
85680: LD_INT 0
85682: PUSH
85683: EMPTY
85684: LIST
85685: LIST
85686: PUSH
85687: LD_INT 3
85689: NEG
85690: PUSH
85691: LD_INT 1
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: LD_INT 4
85700: NEG
85701: PUSH
85702: LD_INT 1
85704: PUSH
85705: EMPTY
85706: LIST
85707: LIST
85708: PUSH
85709: LD_INT 5
85711: NEG
85712: PUSH
85713: LD_INT 0
85715: PUSH
85716: EMPTY
85717: LIST
85718: LIST
85719: PUSH
85720: LD_INT 5
85722: NEG
85723: PUSH
85724: LD_INT 1
85726: NEG
85727: PUSH
85728: EMPTY
85729: LIST
85730: LIST
85731: PUSH
85732: LD_INT 5
85734: NEG
85735: PUSH
85736: LD_INT 2
85738: NEG
85739: PUSH
85740: EMPTY
85741: LIST
85742: LIST
85743: PUSH
85744: LD_INT 3
85746: NEG
85747: PUSH
85748: LD_INT 2
85750: PUSH
85751: EMPTY
85752: LIST
85753: LIST
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: LIST
85777: LIST
85778: LIST
85779: LIST
85780: LIST
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: LIST
85788: LIST
85789: LIST
85790: LIST
85791: LIST
85792: LIST
85793: LIST
85794: LIST
85795: LIST
85796: LIST
85797: LIST
85798: LIST
85799: LIST
85800: LIST
85801: ST_TO_ADDR
// end ; end ;
85802: GO 85805
85804: POP
// case btype of b_depot , b_warehouse :
85805: LD_VAR 0 1
85809: PUSH
85810: LD_INT 0
85812: DOUBLE
85813: EQUAL
85814: IFTRUE 85824
85816: LD_INT 1
85818: DOUBLE
85819: EQUAL
85820: IFTRUE 85824
85822: GO 86025
85824: POP
// case nation of nation_american :
85825: LD_VAR 0 5
85829: PUSH
85830: LD_INT 1
85832: DOUBLE
85833: EQUAL
85834: IFTRUE 85838
85836: GO 85894
85838: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
85839: LD_ADDR_VAR 0 9
85843: PUSH
85844: LD_VAR 0 11
85848: PUSH
85849: LD_VAR 0 12
85853: PUSH
85854: LD_VAR 0 13
85858: PUSH
85859: LD_VAR 0 14
85863: PUSH
85864: LD_VAR 0 15
85868: PUSH
85869: LD_VAR 0 16
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: PUSH
85882: LD_VAR 0 4
85886: PUSH
85887: LD_INT 1
85889: PLUS
85890: ARRAY
85891: ST_TO_ADDR
85892: GO 86023
85894: LD_INT 2
85896: DOUBLE
85897: EQUAL
85898: IFTRUE 85902
85900: GO 85958
85902: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
85903: LD_ADDR_VAR 0 9
85907: PUSH
85908: LD_VAR 0 17
85912: PUSH
85913: LD_VAR 0 18
85917: PUSH
85918: LD_VAR 0 19
85922: PUSH
85923: LD_VAR 0 20
85927: PUSH
85928: LD_VAR 0 21
85932: PUSH
85933: LD_VAR 0 22
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: PUSH
85946: LD_VAR 0 4
85950: PUSH
85951: LD_INT 1
85953: PLUS
85954: ARRAY
85955: ST_TO_ADDR
85956: GO 86023
85958: LD_INT 3
85960: DOUBLE
85961: EQUAL
85962: IFTRUE 85966
85964: GO 86022
85966: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
85967: LD_ADDR_VAR 0 9
85971: PUSH
85972: LD_VAR 0 23
85976: PUSH
85977: LD_VAR 0 24
85981: PUSH
85982: LD_VAR 0 25
85986: PUSH
85987: LD_VAR 0 26
85991: PUSH
85992: LD_VAR 0 27
85996: PUSH
85997: LD_VAR 0 28
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: PUSH
86010: LD_VAR 0 4
86014: PUSH
86015: LD_INT 1
86017: PLUS
86018: ARRAY
86019: ST_TO_ADDR
86020: GO 86023
86022: POP
86023: GO 86578
86025: LD_INT 2
86027: DOUBLE
86028: EQUAL
86029: IFTRUE 86039
86031: LD_INT 3
86033: DOUBLE
86034: EQUAL
86035: IFTRUE 86039
86037: GO 86095
86039: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
86040: LD_ADDR_VAR 0 9
86044: PUSH
86045: LD_VAR 0 29
86049: PUSH
86050: LD_VAR 0 30
86054: PUSH
86055: LD_VAR 0 31
86059: PUSH
86060: LD_VAR 0 32
86064: PUSH
86065: LD_VAR 0 33
86069: PUSH
86070: LD_VAR 0 34
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: PUSH
86083: LD_VAR 0 4
86087: PUSH
86088: LD_INT 1
86090: PLUS
86091: ARRAY
86092: ST_TO_ADDR
86093: GO 86578
86095: LD_INT 16
86097: DOUBLE
86098: EQUAL
86099: IFTRUE 86157
86101: LD_INT 17
86103: DOUBLE
86104: EQUAL
86105: IFTRUE 86157
86107: LD_INT 18
86109: DOUBLE
86110: EQUAL
86111: IFTRUE 86157
86113: LD_INT 19
86115: DOUBLE
86116: EQUAL
86117: IFTRUE 86157
86119: LD_INT 22
86121: DOUBLE
86122: EQUAL
86123: IFTRUE 86157
86125: LD_INT 20
86127: DOUBLE
86128: EQUAL
86129: IFTRUE 86157
86131: LD_INT 21
86133: DOUBLE
86134: EQUAL
86135: IFTRUE 86157
86137: LD_INT 23
86139: DOUBLE
86140: EQUAL
86141: IFTRUE 86157
86143: LD_INT 24
86145: DOUBLE
86146: EQUAL
86147: IFTRUE 86157
86149: LD_INT 25
86151: DOUBLE
86152: EQUAL
86153: IFTRUE 86157
86155: GO 86213
86157: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
86158: LD_ADDR_VAR 0 9
86162: PUSH
86163: LD_VAR 0 35
86167: PUSH
86168: LD_VAR 0 36
86172: PUSH
86173: LD_VAR 0 37
86177: PUSH
86178: LD_VAR 0 38
86182: PUSH
86183: LD_VAR 0 39
86187: PUSH
86188: LD_VAR 0 40
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: PUSH
86201: LD_VAR 0 4
86205: PUSH
86206: LD_INT 1
86208: PLUS
86209: ARRAY
86210: ST_TO_ADDR
86211: GO 86578
86213: LD_INT 6
86215: DOUBLE
86216: EQUAL
86217: IFTRUE 86269
86219: LD_INT 7
86221: DOUBLE
86222: EQUAL
86223: IFTRUE 86269
86225: LD_INT 8
86227: DOUBLE
86228: EQUAL
86229: IFTRUE 86269
86231: LD_INT 13
86233: DOUBLE
86234: EQUAL
86235: IFTRUE 86269
86237: LD_INT 12
86239: DOUBLE
86240: EQUAL
86241: IFTRUE 86269
86243: LD_INT 15
86245: DOUBLE
86246: EQUAL
86247: IFTRUE 86269
86249: LD_INT 11
86251: DOUBLE
86252: EQUAL
86253: IFTRUE 86269
86255: LD_INT 14
86257: DOUBLE
86258: EQUAL
86259: IFTRUE 86269
86261: LD_INT 10
86263: DOUBLE
86264: EQUAL
86265: IFTRUE 86269
86267: GO 86325
86269: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
86270: LD_ADDR_VAR 0 9
86274: PUSH
86275: LD_VAR 0 41
86279: PUSH
86280: LD_VAR 0 42
86284: PUSH
86285: LD_VAR 0 43
86289: PUSH
86290: LD_VAR 0 44
86294: PUSH
86295: LD_VAR 0 45
86299: PUSH
86300: LD_VAR 0 46
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: PUSH
86313: LD_VAR 0 4
86317: PUSH
86318: LD_INT 1
86320: PLUS
86321: ARRAY
86322: ST_TO_ADDR
86323: GO 86578
86325: LD_INT 36
86327: DOUBLE
86328: EQUAL
86329: IFTRUE 86333
86331: GO 86389
86333: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
86334: LD_ADDR_VAR 0 9
86338: PUSH
86339: LD_VAR 0 47
86343: PUSH
86344: LD_VAR 0 48
86348: PUSH
86349: LD_VAR 0 49
86353: PUSH
86354: LD_VAR 0 50
86358: PUSH
86359: LD_VAR 0 51
86363: PUSH
86364: LD_VAR 0 52
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: LIST
86373: LIST
86374: LIST
86375: LIST
86376: PUSH
86377: LD_VAR 0 4
86381: PUSH
86382: LD_INT 1
86384: PLUS
86385: ARRAY
86386: ST_TO_ADDR
86387: GO 86578
86389: LD_INT 4
86391: DOUBLE
86392: EQUAL
86393: IFTRUE 86415
86395: LD_INT 5
86397: DOUBLE
86398: EQUAL
86399: IFTRUE 86415
86401: LD_INT 34
86403: DOUBLE
86404: EQUAL
86405: IFTRUE 86415
86407: LD_INT 37
86409: DOUBLE
86410: EQUAL
86411: IFTRUE 86415
86413: GO 86471
86415: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
86416: LD_ADDR_VAR 0 9
86420: PUSH
86421: LD_VAR 0 53
86425: PUSH
86426: LD_VAR 0 54
86430: PUSH
86431: LD_VAR 0 55
86435: PUSH
86436: LD_VAR 0 56
86440: PUSH
86441: LD_VAR 0 57
86445: PUSH
86446: LD_VAR 0 58
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: LIST
86455: LIST
86456: LIST
86457: LIST
86458: PUSH
86459: LD_VAR 0 4
86463: PUSH
86464: LD_INT 1
86466: PLUS
86467: ARRAY
86468: ST_TO_ADDR
86469: GO 86578
86471: LD_INT 31
86473: DOUBLE
86474: EQUAL
86475: IFTRUE 86521
86477: LD_INT 32
86479: DOUBLE
86480: EQUAL
86481: IFTRUE 86521
86483: LD_INT 33
86485: DOUBLE
86486: EQUAL
86487: IFTRUE 86521
86489: LD_INT 27
86491: DOUBLE
86492: EQUAL
86493: IFTRUE 86521
86495: LD_INT 26
86497: DOUBLE
86498: EQUAL
86499: IFTRUE 86521
86501: LD_INT 28
86503: DOUBLE
86504: EQUAL
86505: IFTRUE 86521
86507: LD_INT 29
86509: DOUBLE
86510: EQUAL
86511: IFTRUE 86521
86513: LD_INT 30
86515: DOUBLE
86516: EQUAL
86517: IFTRUE 86521
86519: GO 86577
86521: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
86522: LD_ADDR_VAR 0 9
86526: PUSH
86527: LD_VAR 0 59
86531: PUSH
86532: LD_VAR 0 60
86536: PUSH
86537: LD_VAR 0 61
86541: PUSH
86542: LD_VAR 0 62
86546: PUSH
86547: LD_VAR 0 63
86551: PUSH
86552: LD_VAR 0 64
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: PUSH
86565: LD_VAR 0 4
86569: PUSH
86570: LD_INT 1
86572: PLUS
86573: ARRAY
86574: ST_TO_ADDR
86575: GO 86578
86577: POP
// temp_list2 = [ ] ;
86578: LD_ADDR_VAR 0 10
86582: PUSH
86583: EMPTY
86584: ST_TO_ADDR
// for i in temp_list do
86585: LD_ADDR_VAR 0 8
86589: PUSH
86590: LD_VAR 0 9
86594: PUSH
86595: FOR_IN
86596: IFFALSE 86648
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
86598: LD_ADDR_VAR 0 10
86602: PUSH
86603: LD_VAR 0 10
86607: PUSH
86608: LD_VAR 0 8
86612: PUSH
86613: LD_INT 1
86615: ARRAY
86616: PUSH
86617: LD_VAR 0 2
86621: PLUS
86622: PUSH
86623: LD_VAR 0 8
86627: PUSH
86628: LD_INT 2
86630: ARRAY
86631: PUSH
86632: LD_VAR 0 3
86636: PLUS
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: PUSH
86642: EMPTY
86643: LIST
86644: ADD
86645: ST_TO_ADDR
86646: GO 86595
86648: POP
86649: POP
// result = temp_list2 ;
86650: LD_ADDR_VAR 0 7
86654: PUSH
86655: LD_VAR 0 10
86659: ST_TO_ADDR
// end ;
86660: LD_VAR 0 7
86664: RET
// export function EnemyInRange ( unit , dist ) ; begin
86665: LD_INT 0
86667: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
86668: LD_ADDR_VAR 0 3
86672: PUSH
86673: LD_VAR 0 1
86677: PPUSH
86678: CALL_OW 255
86682: PPUSH
86683: LD_VAR 0 1
86687: PPUSH
86688: CALL_OW 250
86692: PPUSH
86693: LD_VAR 0 1
86697: PPUSH
86698: CALL_OW 251
86702: PPUSH
86703: LD_VAR 0 2
86707: PPUSH
86708: CALL 60038 0 4
86712: PUSH
86713: LD_INT 4
86715: ARRAY
86716: ST_TO_ADDR
// end ;
86717: LD_VAR 0 3
86721: RET
// export function PlayerSeeMe ( unit ) ; begin
86722: LD_INT 0
86724: PPUSH
// result := See ( your_side , unit ) ;
86725: LD_ADDR_VAR 0 2
86729: PUSH
86730: LD_OWVAR 2
86734: PPUSH
86735: LD_VAR 0 1
86739: PPUSH
86740: CALL_OW 292
86744: ST_TO_ADDR
// end ;
86745: LD_VAR 0 2
86749: RET
// export function ReverseDir ( unit ) ; begin
86750: LD_INT 0
86752: PPUSH
// if not unit then
86753: LD_VAR 0 1
86757: NOT
86758: IFFALSE 86762
// exit ;
86760: GO 86785
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
86762: LD_ADDR_VAR 0 2
86766: PUSH
86767: LD_VAR 0 1
86771: PPUSH
86772: CALL_OW 254
86776: PUSH
86777: LD_INT 3
86779: PLUS
86780: PUSH
86781: LD_INT 6
86783: MOD
86784: ST_TO_ADDR
// end ;
86785: LD_VAR 0 2
86789: RET
// export function ReverseArray ( array ) ; var i ; begin
86790: LD_INT 0
86792: PPUSH
86793: PPUSH
// if not array then
86794: LD_VAR 0 1
86798: NOT
86799: IFFALSE 86803
// exit ;
86801: GO 86858
// result := [ ] ;
86803: LD_ADDR_VAR 0 2
86807: PUSH
86808: EMPTY
86809: ST_TO_ADDR
// for i := array downto 1 do
86810: LD_ADDR_VAR 0 3
86814: PUSH
86815: DOUBLE
86816: LD_VAR 0 1
86820: INC
86821: ST_TO_ADDR
86822: LD_INT 1
86824: PUSH
86825: FOR_DOWNTO
86826: IFFALSE 86856
// result := Join ( result , array [ i ] ) ;
86828: LD_ADDR_VAR 0 2
86832: PUSH
86833: LD_VAR 0 2
86837: PPUSH
86838: LD_VAR 0 1
86842: PUSH
86843: LD_VAR 0 3
86847: ARRAY
86848: PPUSH
86849: CALL 91523 0 2
86853: ST_TO_ADDR
86854: GO 86825
86856: POP
86857: POP
// end ;
86858: LD_VAR 0 2
86862: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
86863: LD_INT 0
86865: PPUSH
86866: PPUSH
86867: PPUSH
86868: PPUSH
86869: PPUSH
86870: PPUSH
// if not unit or not hexes then
86871: LD_VAR 0 1
86875: NOT
86876: PUSH
86877: LD_VAR 0 2
86881: NOT
86882: OR
86883: IFFALSE 86887
// exit ;
86885: GO 87010
// dist := 9999 ;
86887: LD_ADDR_VAR 0 5
86891: PUSH
86892: LD_INT 9999
86894: ST_TO_ADDR
// for i = 1 to hexes do
86895: LD_ADDR_VAR 0 4
86899: PUSH
86900: DOUBLE
86901: LD_INT 1
86903: DEC
86904: ST_TO_ADDR
86905: LD_VAR 0 2
86909: PUSH
86910: FOR_TO
86911: IFFALSE 86998
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
86913: LD_ADDR_VAR 0 6
86917: PUSH
86918: LD_VAR 0 1
86922: PPUSH
86923: LD_VAR 0 2
86927: PUSH
86928: LD_VAR 0 4
86932: ARRAY
86933: PUSH
86934: LD_INT 1
86936: ARRAY
86937: PPUSH
86938: LD_VAR 0 2
86942: PUSH
86943: LD_VAR 0 4
86947: ARRAY
86948: PUSH
86949: LD_INT 2
86951: ARRAY
86952: PPUSH
86953: CALL_OW 297
86957: ST_TO_ADDR
// if tdist < dist then
86958: LD_VAR 0 6
86962: PUSH
86963: LD_VAR 0 5
86967: LESS
86968: IFFALSE 86996
// begin hex := hexes [ i ] ;
86970: LD_ADDR_VAR 0 8
86974: PUSH
86975: LD_VAR 0 2
86979: PUSH
86980: LD_VAR 0 4
86984: ARRAY
86985: ST_TO_ADDR
// dist := tdist ;
86986: LD_ADDR_VAR 0 5
86990: PUSH
86991: LD_VAR 0 6
86995: ST_TO_ADDR
// end ; end ;
86996: GO 86910
86998: POP
86999: POP
// result := hex ;
87000: LD_ADDR_VAR 0 3
87004: PUSH
87005: LD_VAR 0 8
87009: ST_TO_ADDR
// end ;
87010: LD_VAR 0 3
87014: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
87015: LD_INT 0
87017: PPUSH
87018: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87019: LD_VAR 0 1
87023: NOT
87024: PUSH
87025: LD_VAR 0 1
87029: PUSH
87030: LD_INT 21
87032: PUSH
87033: LD_INT 2
87035: PUSH
87036: EMPTY
87037: LIST
87038: LIST
87039: PUSH
87040: LD_INT 23
87042: PUSH
87043: LD_INT 2
87045: PUSH
87046: EMPTY
87047: LIST
87048: LIST
87049: PUSH
87050: EMPTY
87051: LIST
87052: LIST
87053: PPUSH
87054: CALL_OW 69
87058: IN
87059: NOT
87060: OR
87061: IFFALSE 87065
// exit ;
87063: GO 87112
// for i = 1 to 3 do
87065: LD_ADDR_VAR 0 3
87069: PUSH
87070: DOUBLE
87071: LD_INT 1
87073: DEC
87074: ST_TO_ADDR
87075: LD_INT 3
87077: PUSH
87078: FOR_TO
87079: IFFALSE 87110
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
87081: LD_VAR 0 1
87085: PPUSH
87086: CALL_OW 250
87090: PPUSH
87091: LD_VAR 0 1
87095: PPUSH
87096: CALL_OW 251
87100: PPUSH
87101: LD_INT 1
87103: PPUSH
87104: CALL_OW 453
87108: GO 87078
87110: POP
87111: POP
// end ;
87112: LD_VAR 0 2
87116: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
87117: LD_INT 0
87119: PPUSH
87120: PPUSH
87121: PPUSH
87122: PPUSH
87123: PPUSH
87124: PPUSH
// if not unit or not enemy_unit then
87125: LD_VAR 0 1
87129: NOT
87130: PUSH
87131: LD_VAR 0 2
87135: NOT
87136: OR
87137: IFFALSE 87141
// exit ;
87139: GO 87608
// if GetLives ( i ) < 250 then
87141: LD_VAR 0 4
87145: PPUSH
87146: CALL_OW 256
87150: PUSH
87151: LD_INT 250
87153: LESS
87154: IFFALSE 87167
// begin ComAutodestruct ( i ) ;
87156: LD_VAR 0 4
87160: PPUSH
87161: CALL 87015 0 1
// exit ;
87165: GO 87608
// end ; x := GetX ( enemy_unit ) ;
87167: LD_ADDR_VAR 0 7
87171: PUSH
87172: LD_VAR 0 2
87176: PPUSH
87177: CALL_OW 250
87181: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
87182: LD_ADDR_VAR 0 8
87186: PUSH
87187: LD_VAR 0 2
87191: PPUSH
87192: CALL_OW 251
87196: ST_TO_ADDR
// if not x or not y then
87197: LD_VAR 0 7
87201: NOT
87202: PUSH
87203: LD_VAR 0 8
87207: NOT
87208: OR
87209: IFFALSE 87213
// exit ;
87211: GO 87608
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
87213: LD_ADDR_VAR 0 6
87217: PUSH
87218: LD_VAR 0 7
87222: PPUSH
87223: LD_INT 0
87225: PPUSH
87226: LD_INT 4
87228: PPUSH
87229: CALL_OW 272
87233: PUSH
87234: LD_VAR 0 8
87238: PPUSH
87239: LD_INT 0
87241: PPUSH
87242: LD_INT 4
87244: PPUSH
87245: CALL_OW 273
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: PUSH
87254: LD_VAR 0 7
87258: PPUSH
87259: LD_INT 1
87261: PPUSH
87262: LD_INT 4
87264: PPUSH
87265: CALL_OW 272
87269: PUSH
87270: LD_VAR 0 8
87274: PPUSH
87275: LD_INT 1
87277: PPUSH
87278: LD_INT 4
87280: PPUSH
87281: CALL_OW 273
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PUSH
87290: LD_VAR 0 7
87294: PPUSH
87295: LD_INT 2
87297: PPUSH
87298: LD_INT 4
87300: PPUSH
87301: CALL_OW 272
87305: PUSH
87306: LD_VAR 0 8
87310: PPUSH
87311: LD_INT 2
87313: PPUSH
87314: LD_INT 4
87316: PPUSH
87317: CALL_OW 273
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_VAR 0 7
87330: PPUSH
87331: LD_INT 3
87333: PPUSH
87334: LD_INT 4
87336: PPUSH
87337: CALL_OW 272
87341: PUSH
87342: LD_VAR 0 8
87346: PPUSH
87347: LD_INT 3
87349: PPUSH
87350: LD_INT 4
87352: PPUSH
87353: CALL_OW 273
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: LD_VAR 0 7
87366: PPUSH
87367: LD_INT 4
87369: PPUSH
87370: LD_INT 4
87372: PPUSH
87373: CALL_OW 272
87377: PUSH
87378: LD_VAR 0 8
87382: PPUSH
87383: LD_INT 4
87385: PPUSH
87386: LD_INT 4
87388: PPUSH
87389: CALL_OW 273
87393: PUSH
87394: EMPTY
87395: LIST
87396: LIST
87397: PUSH
87398: LD_VAR 0 7
87402: PPUSH
87403: LD_INT 5
87405: PPUSH
87406: LD_INT 4
87408: PPUSH
87409: CALL_OW 272
87413: PUSH
87414: LD_VAR 0 8
87418: PPUSH
87419: LD_INT 5
87421: PPUSH
87422: LD_INT 4
87424: PPUSH
87425: CALL_OW 273
87429: PUSH
87430: EMPTY
87431: LIST
87432: LIST
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: ST_TO_ADDR
// for i = tmp downto 1 do
87442: LD_ADDR_VAR 0 4
87446: PUSH
87447: DOUBLE
87448: LD_VAR 0 6
87452: INC
87453: ST_TO_ADDR
87454: LD_INT 1
87456: PUSH
87457: FOR_DOWNTO
87458: IFFALSE 87559
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
87460: LD_VAR 0 6
87464: PUSH
87465: LD_VAR 0 4
87469: ARRAY
87470: PUSH
87471: LD_INT 1
87473: ARRAY
87474: PPUSH
87475: LD_VAR 0 6
87479: PUSH
87480: LD_VAR 0 4
87484: ARRAY
87485: PUSH
87486: LD_INT 2
87488: ARRAY
87489: PPUSH
87490: CALL_OW 488
87494: NOT
87495: PUSH
87496: LD_VAR 0 6
87500: PUSH
87501: LD_VAR 0 4
87505: ARRAY
87506: PUSH
87507: LD_INT 1
87509: ARRAY
87510: PPUSH
87511: LD_VAR 0 6
87515: PUSH
87516: LD_VAR 0 4
87520: ARRAY
87521: PUSH
87522: LD_INT 2
87524: ARRAY
87525: PPUSH
87526: CALL_OW 428
87530: PUSH
87531: LD_INT 0
87533: NONEQUAL
87534: OR
87535: IFFALSE 87557
// tmp := Delete ( tmp , i ) ;
87537: LD_ADDR_VAR 0 6
87541: PUSH
87542: LD_VAR 0 6
87546: PPUSH
87547: LD_VAR 0 4
87551: PPUSH
87552: CALL_OW 3
87556: ST_TO_ADDR
87557: GO 87457
87559: POP
87560: POP
// j := GetClosestHex ( unit , tmp ) ;
87561: LD_ADDR_VAR 0 5
87565: PUSH
87566: LD_VAR 0 1
87570: PPUSH
87571: LD_VAR 0 6
87575: PPUSH
87576: CALL 86863 0 2
87580: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
87581: LD_VAR 0 1
87585: PPUSH
87586: LD_VAR 0 5
87590: PUSH
87591: LD_INT 1
87593: ARRAY
87594: PPUSH
87595: LD_VAR 0 5
87599: PUSH
87600: LD_INT 2
87602: ARRAY
87603: PPUSH
87604: CALL_OW 111
// end ;
87608: LD_VAR 0 3
87612: RET
// export function PrepareApemanSoldier ( ) ; begin
87613: LD_INT 0
87615: PPUSH
// uc_nation := 0 ;
87616: LD_ADDR_OWVAR 21
87620: PUSH
87621: LD_INT 0
87623: ST_TO_ADDR
// hc_sex := sex_male ;
87624: LD_ADDR_OWVAR 27
87628: PUSH
87629: LD_INT 1
87631: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
87632: LD_ADDR_OWVAR 28
87636: PUSH
87637: LD_INT 15
87639: ST_TO_ADDR
// hc_gallery :=  ;
87640: LD_ADDR_OWVAR 33
87644: PUSH
87645: LD_STRING 
87647: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87648: LD_ADDR_OWVAR 31
87652: PUSH
87653: LD_INT 0
87655: PPUSH
87656: LD_INT 3
87658: PPUSH
87659: CALL_OW 12
87663: PUSH
87664: LD_INT 0
87666: PPUSH
87667: LD_INT 3
87669: PPUSH
87670: CALL_OW 12
87674: PUSH
87675: LD_INT 0
87677: PUSH
87678: LD_INT 0
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: ST_TO_ADDR
// end ;
87687: LD_VAR 0 1
87691: RET
// export function PrepareApemanEngineer ( ) ; begin
87692: LD_INT 0
87694: PPUSH
// uc_nation := 0 ;
87695: LD_ADDR_OWVAR 21
87699: PUSH
87700: LD_INT 0
87702: ST_TO_ADDR
// hc_sex := sex_male ;
87703: LD_ADDR_OWVAR 27
87707: PUSH
87708: LD_INT 1
87710: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
87711: LD_ADDR_OWVAR 28
87715: PUSH
87716: LD_INT 16
87718: ST_TO_ADDR
// hc_gallery :=  ;
87719: LD_ADDR_OWVAR 33
87723: PUSH
87724: LD_STRING 
87726: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87727: LD_ADDR_OWVAR 31
87731: PUSH
87732: LD_INT 0
87734: PPUSH
87735: LD_INT 3
87737: PPUSH
87738: CALL_OW 12
87742: PUSH
87743: LD_INT 0
87745: PPUSH
87746: LD_INT 3
87748: PPUSH
87749: CALL_OW 12
87753: PUSH
87754: LD_INT 0
87756: PUSH
87757: LD_INT 0
87759: PUSH
87760: EMPTY
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: ST_TO_ADDR
// end ;
87766: LD_VAR 0 1
87770: RET
// export function PrepareApeman ( agressivity ) ; begin
87771: LD_INT 0
87773: PPUSH
// uc_side := 0 ;
87774: LD_ADDR_OWVAR 20
87778: PUSH
87779: LD_INT 0
87781: ST_TO_ADDR
// uc_nation := 0 ;
87782: LD_ADDR_OWVAR 21
87786: PUSH
87787: LD_INT 0
87789: ST_TO_ADDR
// hc_sex := sex_male ;
87790: LD_ADDR_OWVAR 27
87794: PUSH
87795: LD_INT 1
87797: ST_TO_ADDR
// hc_class := class_apeman ;
87798: LD_ADDR_OWVAR 28
87802: PUSH
87803: LD_INT 12
87805: ST_TO_ADDR
// hc_gallery :=  ;
87806: LD_ADDR_OWVAR 33
87810: PUSH
87811: LD_STRING 
87813: ST_TO_ADDR
// if agressivity = 0 then
87814: LD_VAR 0 1
87818: PUSH
87819: LD_INT 0
87821: EQUAL
87822: IFFALSE 87834
// hc_agressivity := 0 else
87824: LD_ADDR_OWVAR 35
87828: PUSH
87829: LD_INT 0
87831: ST_TO_ADDR
87832: GO 87855
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87834: LD_ADDR_OWVAR 35
87838: PUSH
87839: LD_VAR 0 1
87843: NEG
87844: PPUSH
87845: LD_VAR 0 1
87849: PPUSH
87850: CALL_OW 12
87854: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87855: LD_ADDR_OWVAR 31
87859: PUSH
87860: LD_INT 0
87862: PPUSH
87863: LD_INT 3
87865: PPUSH
87866: CALL_OW 12
87870: PUSH
87871: LD_INT 0
87873: PPUSH
87874: LD_INT 3
87876: PPUSH
87877: CALL_OW 12
87881: PUSH
87882: LD_INT 0
87884: PUSH
87885: LD_INT 0
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: ST_TO_ADDR
// end ;
87894: LD_VAR 0 2
87898: RET
// export function PrepareTiger ( agressivity ) ; begin
87899: LD_INT 0
87901: PPUSH
// uc_side := 0 ;
87902: LD_ADDR_OWVAR 20
87906: PUSH
87907: LD_INT 0
87909: ST_TO_ADDR
// uc_nation := 0 ;
87910: LD_ADDR_OWVAR 21
87914: PUSH
87915: LD_INT 0
87917: ST_TO_ADDR
// hc_class := class_tiger ;
87918: LD_ADDR_OWVAR 28
87922: PUSH
87923: LD_INT 14
87925: ST_TO_ADDR
// hc_gallery :=  ;
87926: LD_ADDR_OWVAR 33
87930: PUSH
87931: LD_STRING 
87933: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87934: LD_ADDR_OWVAR 35
87938: PUSH
87939: LD_VAR 0 1
87943: NEG
87944: PPUSH
87945: LD_VAR 0 1
87949: PPUSH
87950: CALL_OW 12
87954: ST_TO_ADDR
// end ;
87955: LD_VAR 0 2
87959: RET
// export function PrepareEnchidna ( ) ; begin
87960: LD_INT 0
87962: PPUSH
// uc_side := 0 ;
87963: LD_ADDR_OWVAR 20
87967: PUSH
87968: LD_INT 0
87970: ST_TO_ADDR
// uc_nation := 0 ;
87971: LD_ADDR_OWVAR 21
87975: PUSH
87976: LD_INT 0
87978: ST_TO_ADDR
// hc_class := class_baggie ;
87979: LD_ADDR_OWVAR 28
87983: PUSH
87984: LD_INT 13
87986: ST_TO_ADDR
// hc_gallery :=  ;
87987: LD_ADDR_OWVAR 33
87991: PUSH
87992: LD_STRING 
87994: ST_TO_ADDR
// end ;
87995: LD_VAR 0 1
87999: RET
// export function PrepareFrog ( ) ; begin
88000: LD_INT 0
88002: PPUSH
// uc_side := 0 ;
88003: LD_ADDR_OWVAR 20
88007: PUSH
88008: LD_INT 0
88010: ST_TO_ADDR
// uc_nation := 0 ;
88011: LD_ADDR_OWVAR 21
88015: PUSH
88016: LD_INT 0
88018: ST_TO_ADDR
// hc_class := class_frog ;
88019: LD_ADDR_OWVAR 28
88023: PUSH
88024: LD_INT 19
88026: ST_TO_ADDR
// hc_gallery :=  ;
88027: LD_ADDR_OWVAR 33
88031: PUSH
88032: LD_STRING 
88034: ST_TO_ADDR
// end ;
88035: LD_VAR 0 1
88039: RET
// export function PrepareFish ( ) ; begin
88040: LD_INT 0
88042: PPUSH
// uc_side := 0 ;
88043: LD_ADDR_OWVAR 20
88047: PUSH
88048: LD_INT 0
88050: ST_TO_ADDR
// uc_nation := 0 ;
88051: LD_ADDR_OWVAR 21
88055: PUSH
88056: LD_INT 0
88058: ST_TO_ADDR
// hc_class := class_fish ;
88059: LD_ADDR_OWVAR 28
88063: PUSH
88064: LD_INT 20
88066: ST_TO_ADDR
// hc_gallery :=  ;
88067: LD_ADDR_OWVAR 33
88071: PUSH
88072: LD_STRING 
88074: ST_TO_ADDR
// end ;
88075: LD_VAR 0 1
88079: RET
// export function PrepareBird ( ) ; begin
88080: LD_INT 0
88082: PPUSH
// uc_side := 0 ;
88083: LD_ADDR_OWVAR 20
88087: PUSH
88088: LD_INT 0
88090: ST_TO_ADDR
// uc_nation := 0 ;
88091: LD_ADDR_OWVAR 21
88095: PUSH
88096: LD_INT 0
88098: ST_TO_ADDR
// hc_class := class_phororhacos ;
88099: LD_ADDR_OWVAR 28
88103: PUSH
88104: LD_INT 18
88106: ST_TO_ADDR
// hc_gallery :=  ;
88107: LD_ADDR_OWVAR 33
88111: PUSH
88112: LD_STRING 
88114: ST_TO_ADDR
// end ;
88115: LD_VAR 0 1
88119: RET
// export function PrepareHorse ( ) ; begin
88120: LD_INT 0
88122: PPUSH
// uc_side := 0 ;
88123: LD_ADDR_OWVAR 20
88127: PUSH
88128: LD_INT 0
88130: ST_TO_ADDR
// uc_nation := 0 ;
88131: LD_ADDR_OWVAR 21
88135: PUSH
88136: LD_INT 0
88138: ST_TO_ADDR
// hc_class := class_horse ;
88139: LD_ADDR_OWVAR 28
88143: PUSH
88144: LD_INT 21
88146: ST_TO_ADDR
// hc_gallery :=  ;
88147: LD_ADDR_OWVAR 33
88151: PUSH
88152: LD_STRING 
88154: ST_TO_ADDR
// end ;
88155: LD_VAR 0 1
88159: RET
// export function PrepareMastodont ( ) ; begin
88160: LD_INT 0
88162: PPUSH
// uc_side := 0 ;
88163: LD_ADDR_OWVAR 20
88167: PUSH
88168: LD_INT 0
88170: ST_TO_ADDR
// uc_nation := 0 ;
88171: LD_ADDR_OWVAR 21
88175: PUSH
88176: LD_INT 0
88178: ST_TO_ADDR
// vc_chassis := class_mastodont ;
88179: LD_ADDR_OWVAR 37
88183: PUSH
88184: LD_INT 31
88186: ST_TO_ADDR
// vc_control := control_rider ;
88187: LD_ADDR_OWVAR 38
88191: PUSH
88192: LD_INT 4
88194: ST_TO_ADDR
// end ;
88195: LD_VAR 0 1
88199: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
88200: LD_INT 0
88202: PPUSH
88203: PPUSH
88204: PPUSH
// uc_side = 0 ;
88205: LD_ADDR_OWVAR 20
88209: PUSH
88210: LD_INT 0
88212: ST_TO_ADDR
// uc_nation = 0 ;
88213: LD_ADDR_OWVAR 21
88217: PUSH
88218: LD_INT 0
88220: ST_TO_ADDR
// InitHc_All ( ) ;
88221: CALL_OW 584
// InitVc ;
88225: CALL_OW 20
// if mastodonts then
88229: LD_VAR 0 6
88233: IFFALSE 88300
// for i = 1 to mastodonts do
88235: LD_ADDR_VAR 0 11
88239: PUSH
88240: DOUBLE
88241: LD_INT 1
88243: DEC
88244: ST_TO_ADDR
88245: LD_VAR 0 6
88249: PUSH
88250: FOR_TO
88251: IFFALSE 88298
// begin vc_chassis := 31 ;
88253: LD_ADDR_OWVAR 37
88257: PUSH
88258: LD_INT 31
88260: ST_TO_ADDR
// vc_control := control_rider ;
88261: LD_ADDR_OWVAR 38
88265: PUSH
88266: LD_INT 4
88268: ST_TO_ADDR
// animal := CreateVehicle ;
88269: LD_ADDR_VAR 0 12
88273: PUSH
88274: CALL_OW 45
88278: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88279: LD_VAR 0 12
88283: PPUSH
88284: LD_VAR 0 8
88288: PPUSH
88289: LD_INT 0
88291: PPUSH
88292: CALL 90428 0 3
// end ;
88296: GO 88250
88298: POP
88299: POP
// if horses then
88300: LD_VAR 0 5
88304: IFFALSE 88371
// for i = 1 to horses do
88306: LD_ADDR_VAR 0 11
88310: PUSH
88311: DOUBLE
88312: LD_INT 1
88314: DEC
88315: ST_TO_ADDR
88316: LD_VAR 0 5
88320: PUSH
88321: FOR_TO
88322: IFFALSE 88369
// begin hc_class := 21 ;
88324: LD_ADDR_OWVAR 28
88328: PUSH
88329: LD_INT 21
88331: ST_TO_ADDR
// hc_gallery :=  ;
88332: LD_ADDR_OWVAR 33
88336: PUSH
88337: LD_STRING 
88339: ST_TO_ADDR
// animal := CreateHuman ;
88340: LD_ADDR_VAR 0 12
88344: PUSH
88345: CALL_OW 44
88349: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88350: LD_VAR 0 12
88354: PPUSH
88355: LD_VAR 0 8
88359: PPUSH
88360: LD_INT 0
88362: PPUSH
88363: CALL 90428 0 3
// end ;
88367: GO 88321
88369: POP
88370: POP
// if birds then
88371: LD_VAR 0 1
88375: IFFALSE 88442
// for i = 1 to birds do
88377: LD_ADDR_VAR 0 11
88381: PUSH
88382: DOUBLE
88383: LD_INT 1
88385: DEC
88386: ST_TO_ADDR
88387: LD_VAR 0 1
88391: PUSH
88392: FOR_TO
88393: IFFALSE 88440
// begin hc_class := 18 ;
88395: LD_ADDR_OWVAR 28
88399: PUSH
88400: LD_INT 18
88402: ST_TO_ADDR
// hc_gallery =  ;
88403: LD_ADDR_OWVAR 33
88407: PUSH
88408: LD_STRING 
88410: ST_TO_ADDR
// animal := CreateHuman ;
88411: LD_ADDR_VAR 0 12
88415: PUSH
88416: CALL_OW 44
88420: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88421: LD_VAR 0 12
88425: PPUSH
88426: LD_VAR 0 8
88430: PPUSH
88431: LD_INT 0
88433: PPUSH
88434: CALL 90428 0 3
// end ;
88438: GO 88392
88440: POP
88441: POP
// if tigers then
88442: LD_VAR 0 2
88446: IFFALSE 88530
// for i = 1 to tigers do
88448: LD_ADDR_VAR 0 11
88452: PUSH
88453: DOUBLE
88454: LD_INT 1
88456: DEC
88457: ST_TO_ADDR
88458: LD_VAR 0 2
88462: PUSH
88463: FOR_TO
88464: IFFALSE 88528
// begin hc_class = class_tiger ;
88466: LD_ADDR_OWVAR 28
88470: PUSH
88471: LD_INT 14
88473: ST_TO_ADDR
// hc_gallery =  ;
88474: LD_ADDR_OWVAR 33
88478: PUSH
88479: LD_STRING 
88481: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
88482: LD_ADDR_OWVAR 35
88486: PUSH
88487: LD_INT 7
88489: NEG
88490: PPUSH
88491: LD_INT 7
88493: PPUSH
88494: CALL_OW 12
88498: ST_TO_ADDR
// animal := CreateHuman ;
88499: LD_ADDR_VAR 0 12
88503: PUSH
88504: CALL_OW 44
88508: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88509: LD_VAR 0 12
88513: PPUSH
88514: LD_VAR 0 8
88518: PPUSH
88519: LD_INT 0
88521: PPUSH
88522: CALL 90428 0 3
// end ;
88526: GO 88463
88528: POP
88529: POP
// if apemans then
88530: LD_VAR 0 3
88534: IFFALSE 88657
// for i = 1 to apemans do
88536: LD_ADDR_VAR 0 11
88540: PUSH
88541: DOUBLE
88542: LD_INT 1
88544: DEC
88545: ST_TO_ADDR
88546: LD_VAR 0 3
88550: PUSH
88551: FOR_TO
88552: IFFALSE 88655
// begin hc_class = class_apeman ;
88554: LD_ADDR_OWVAR 28
88558: PUSH
88559: LD_INT 12
88561: ST_TO_ADDR
// hc_gallery =  ;
88562: LD_ADDR_OWVAR 33
88566: PUSH
88567: LD_STRING 
88569: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
88570: LD_ADDR_OWVAR 35
88574: PUSH
88575: LD_INT 2
88577: NEG
88578: PPUSH
88579: LD_INT 2
88581: PPUSH
88582: CALL_OW 12
88586: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
88587: LD_ADDR_OWVAR 31
88591: PUSH
88592: LD_INT 1
88594: PPUSH
88595: LD_INT 3
88597: PPUSH
88598: CALL_OW 12
88602: PUSH
88603: LD_INT 1
88605: PPUSH
88606: LD_INT 3
88608: PPUSH
88609: CALL_OW 12
88613: PUSH
88614: LD_INT 0
88616: PUSH
88617: LD_INT 0
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: ST_TO_ADDR
// animal := CreateHuman ;
88626: LD_ADDR_VAR 0 12
88630: PUSH
88631: CALL_OW 44
88635: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88636: LD_VAR 0 12
88640: PPUSH
88641: LD_VAR 0 8
88645: PPUSH
88646: LD_INT 0
88648: PPUSH
88649: CALL 90428 0 3
// end ;
88653: GO 88551
88655: POP
88656: POP
// if enchidnas then
88657: LD_VAR 0 4
88661: IFFALSE 88728
// for i = 1 to enchidnas do
88663: LD_ADDR_VAR 0 11
88667: PUSH
88668: DOUBLE
88669: LD_INT 1
88671: DEC
88672: ST_TO_ADDR
88673: LD_VAR 0 4
88677: PUSH
88678: FOR_TO
88679: IFFALSE 88726
// begin hc_class = 13 ;
88681: LD_ADDR_OWVAR 28
88685: PUSH
88686: LD_INT 13
88688: ST_TO_ADDR
// hc_gallery =  ;
88689: LD_ADDR_OWVAR 33
88693: PUSH
88694: LD_STRING 
88696: ST_TO_ADDR
// animal := CreateHuman ;
88697: LD_ADDR_VAR 0 12
88701: PUSH
88702: CALL_OW 44
88706: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88707: LD_VAR 0 12
88711: PPUSH
88712: LD_VAR 0 8
88716: PPUSH
88717: LD_INT 0
88719: PPUSH
88720: CALL 90428 0 3
// end ;
88724: GO 88678
88726: POP
88727: POP
// if fishes then
88728: LD_VAR 0 7
88732: IFFALSE 88799
// for i = 1 to fishes do
88734: LD_ADDR_VAR 0 11
88738: PUSH
88739: DOUBLE
88740: LD_INT 1
88742: DEC
88743: ST_TO_ADDR
88744: LD_VAR 0 7
88748: PUSH
88749: FOR_TO
88750: IFFALSE 88797
// begin hc_class = 20 ;
88752: LD_ADDR_OWVAR 28
88756: PUSH
88757: LD_INT 20
88759: ST_TO_ADDR
// hc_gallery =  ;
88760: LD_ADDR_OWVAR 33
88764: PUSH
88765: LD_STRING 
88767: ST_TO_ADDR
// animal := CreateHuman ;
88768: LD_ADDR_VAR 0 12
88772: PUSH
88773: CALL_OW 44
88777: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
88778: LD_VAR 0 12
88782: PPUSH
88783: LD_VAR 0 9
88787: PPUSH
88788: LD_INT 0
88790: PPUSH
88791: CALL 90428 0 3
// end ;
88795: GO 88749
88797: POP
88798: POP
// end ;
88799: LD_VAR 0 10
88803: RET
// export function WantHeal ( sci , unit ) ; begin
88804: LD_INT 0
88806: PPUSH
// if GetTaskList ( sci ) > 0 then
88807: LD_VAR 0 1
88811: PPUSH
88812: CALL_OW 437
88816: PUSH
88817: LD_INT 0
88819: GREATER
88820: IFFALSE 88890
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
88822: LD_VAR 0 1
88826: PPUSH
88827: CALL_OW 437
88831: PUSH
88832: LD_INT 1
88834: ARRAY
88835: PUSH
88836: LD_INT 1
88838: ARRAY
88839: PUSH
88840: LD_STRING l
88842: EQUAL
88843: PUSH
88844: LD_VAR 0 1
88848: PPUSH
88849: CALL_OW 437
88853: PUSH
88854: LD_INT 1
88856: ARRAY
88857: PUSH
88858: LD_INT 4
88860: ARRAY
88861: PUSH
88862: LD_VAR 0 2
88866: EQUAL
88867: AND
88868: IFFALSE 88880
// result := true else
88870: LD_ADDR_VAR 0 3
88874: PUSH
88875: LD_INT 1
88877: ST_TO_ADDR
88878: GO 88888
// result := false ;
88880: LD_ADDR_VAR 0 3
88884: PUSH
88885: LD_INT 0
88887: ST_TO_ADDR
// end else
88888: GO 88898
// result := false ;
88890: LD_ADDR_VAR 0 3
88894: PUSH
88895: LD_INT 0
88897: ST_TO_ADDR
// end ;
88898: LD_VAR 0 3
88902: RET
// export function HealTarget ( sci ) ; begin
88903: LD_INT 0
88905: PPUSH
// if not sci then
88906: LD_VAR 0 1
88910: NOT
88911: IFFALSE 88915
// exit ;
88913: GO 88980
// result := 0 ;
88915: LD_ADDR_VAR 0 2
88919: PUSH
88920: LD_INT 0
88922: ST_TO_ADDR
// if GetTaskList ( sci ) then
88923: LD_VAR 0 1
88927: PPUSH
88928: CALL_OW 437
88932: IFFALSE 88980
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
88934: LD_VAR 0 1
88938: PPUSH
88939: CALL_OW 437
88943: PUSH
88944: LD_INT 1
88946: ARRAY
88947: PUSH
88948: LD_INT 1
88950: ARRAY
88951: PUSH
88952: LD_STRING l
88954: EQUAL
88955: IFFALSE 88980
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
88957: LD_ADDR_VAR 0 2
88961: PUSH
88962: LD_VAR 0 1
88966: PPUSH
88967: CALL_OW 437
88971: PUSH
88972: LD_INT 1
88974: ARRAY
88975: PUSH
88976: LD_INT 4
88978: ARRAY
88979: ST_TO_ADDR
// end ;
88980: LD_VAR 0 2
88984: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
88985: LD_INT 0
88987: PPUSH
88988: PPUSH
88989: PPUSH
88990: PPUSH
// if not base_units then
88991: LD_VAR 0 1
88995: NOT
88996: IFFALSE 89000
// exit ;
88998: GO 89087
// result := false ;
89000: LD_ADDR_VAR 0 2
89004: PUSH
89005: LD_INT 0
89007: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
89008: LD_ADDR_VAR 0 5
89012: PUSH
89013: LD_VAR 0 1
89017: PPUSH
89018: LD_INT 21
89020: PUSH
89021: LD_INT 3
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: PPUSH
89028: CALL_OW 72
89032: ST_TO_ADDR
// if not tmp then
89033: LD_VAR 0 5
89037: NOT
89038: IFFALSE 89042
// exit ;
89040: GO 89087
// for i in tmp do
89042: LD_ADDR_VAR 0 3
89046: PUSH
89047: LD_VAR 0 5
89051: PUSH
89052: FOR_IN
89053: IFFALSE 89085
// begin result := EnemyInRange ( i , 22 ) ;
89055: LD_ADDR_VAR 0 2
89059: PUSH
89060: LD_VAR 0 3
89064: PPUSH
89065: LD_INT 22
89067: PPUSH
89068: CALL 86665 0 2
89072: ST_TO_ADDR
// if result then
89073: LD_VAR 0 2
89077: IFFALSE 89083
// exit ;
89079: POP
89080: POP
89081: GO 89087
// end ;
89083: GO 89052
89085: POP
89086: POP
// end ;
89087: LD_VAR 0 2
89091: RET
// export function FilterByTag ( units , tag ) ; begin
89092: LD_INT 0
89094: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
89095: LD_ADDR_VAR 0 3
89099: PUSH
89100: LD_VAR 0 1
89104: PPUSH
89105: LD_INT 120
89107: PUSH
89108: LD_VAR 0 2
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PPUSH
89117: CALL_OW 72
89121: ST_TO_ADDR
// end ;
89122: LD_VAR 0 3
89126: RET
// export function IsDriver ( un ) ; begin
89127: LD_INT 0
89129: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
89130: LD_ADDR_VAR 0 2
89134: PUSH
89135: LD_VAR 0 1
89139: PUSH
89140: LD_INT 55
89142: PUSH
89143: EMPTY
89144: LIST
89145: PPUSH
89146: CALL_OW 69
89150: IN
89151: ST_TO_ADDR
// end ;
89152: LD_VAR 0 2
89156: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
89157: LD_INT 0
89159: PPUSH
89160: PPUSH
// list := [ ] ;
89161: LD_ADDR_VAR 0 5
89165: PUSH
89166: EMPTY
89167: ST_TO_ADDR
// case d of 0 :
89168: LD_VAR 0 3
89172: PUSH
89173: LD_INT 0
89175: DOUBLE
89176: EQUAL
89177: IFTRUE 89181
89179: GO 89314
89181: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
89182: LD_ADDR_VAR 0 5
89186: PUSH
89187: LD_VAR 0 1
89191: PUSH
89192: LD_INT 4
89194: MINUS
89195: PUSH
89196: LD_VAR 0 2
89200: PUSH
89201: LD_INT 4
89203: MINUS
89204: PUSH
89205: LD_INT 2
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: LIST
89212: PUSH
89213: LD_VAR 0 1
89217: PUSH
89218: LD_INT 3
89220: MINUS
89221: PUSH
89222: LD_VAR 0 2
89226: PUSH
89227: LD_INT 1
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: LIST
89234: PUSH
89235: LD_VAR 0 1
89239: PUSH
89240: LD_INT 4
89242: PLUS
89243: PUSH
89244: LD_VAR 0 2
89248: PUSH
89249: LD_INT 4
89251: PUSH
89252: EMPTY
89253: LIST
89254: LIST
89255: LIST
89256: PUSH
89257: LD_VAR 0 1
89261: PUSH
89262: LD_INT 3
89264: PLUS
89265: PUSH
89266: LD_VAR 0 2
89270: PUSH
89271: LD_INT 3
89273: PLUS
89274: PUSH
89275: LD_INT 5
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: LIST
89282: PUSH
89283: LD_VAR 0 1
89287: PUSH
89288: LD_VAR 0 2
89292: PUSH
89293: LD_INT 4
89295: PLUS
89296: PUSH
89297: LD_INT 0
89299: PUSH
89300: EMPTY
89301: LIST
89302: LIST
89303: LIST
89304: PUSH
89305: EMPTY
89306: LIST
89307: LIST
89308: LIST
89309: LIST
89310: LIST
89311: ST_TO_ADDR
// end ; 1 :
89312: GO 90012
89314: LD_INT 1
89316: DOUBLE
89317: EQUAL
89318: IFTRUE 89322
89320: GO 89455
89322: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
89323: LD_ADDR_VAR 0 5
89327: PUSH
89328: LD_VAR 0 1
89332: PUSH
89333: LD_VAR 0 2
89337: PUSH
89338: LD_INT 4
89340: MINUS
89341: PUSH
89342: LD_INT 3
89344: PUSH
89345: EMPTY
89346: LIST
89347: LIST
89348: LIST
89349: PUSH
89350: LD_VAR 0 1
89354: PUSH
89355: LD_INT 3
89357: MINUS
89358: PUSH
89359: LD_VAR 0 2
89363: PUSH
89364: LD_INT 3
89366: MINUS
89367: PUSH
89368: LD_INT 2
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: LIST
89375: PUSH
89376: LD_VAR 0 1
89380: PUSH
89381: LD_INT 4
89383: MINUS
89384: PUSH
89385: LD_VAR 0 2
89389: PUSH
89390: LD_INT 1
89392: PUSH
89393: EMPTY
89394: LIST
89395: LIST
89396: LIST
89397: PUSH
89398: LD_VAR 0 1
89402: PUSH
89403: LD_VAR 0 2
89407: PUSH
89408: LD_INT 3
89410: PLUS
89411: PUSH
89412: LD_INT 0
89414: PUSH
89415: EMPTY
89416: LIST
89417: LIST
89418: LIST
89419: PUSH
89420: LD_VAR 0 1
89424: PUSH
89425: LD_INT 4
89427: PLUS
89428: PUSH
89429: LD_VAR 0 2
89433: PUSH
89434: LD_INT 4
89436: PLUS
89437: PUSH
89438: LD_INT 5
89440: PUSH
89441: EMPTY
89442: LIST
89443: LIST
89444: LIST
89445: PUSH
89446: EMPTY
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: ST_TO_ADDR
// end ; 2 :
89453: GO 90012
89455: LD_INT 2
89457: DOUBLE
89458: EQUAL
89459: IFTRUE 89463
89461: GO 89592
89463: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
89464: LD_ADDR_VAR 0 5
89468: PUSH
89469: LD_VAR 0 1
89473: PUSH
89474: LD_VAR 0 2
89478: PUSH
89479: LD_INT 3
89481: MINUS
89482: PUSH
89483: LD_INT 3
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: LIST
89490: PUSH
89491: LD_VAR 0 1
89495: PUSH
89496: LD_INT 4
89498: PLUS
89499: PUSH
89500: LD_VAR 0 2
89504: PUSH
89505: LD_INT 4
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: LIST
89512: PUSH
89513: LD_VAR 0 1
89517: PUSH
89518: LD_VAR 0 2
89522: PUSH
89523: LD_INT 4
89525: PLUS
89526: PUSH
89527: LD_INT 0
89529: PUSH
89530: EMPTY
89531: LIST
89532: LIST
89533: LIST
89534: PUSH
89535: LD_VAR 0 1
89539: PUSH
89540: LD_INT 3
89542: MINUS
89543: PUSH
89544: LD_VAR 0 2
89548: PUSH
89549: LD_INT 1
89551: PUSH
89552: EMPTY
89553: LIST
89554: LIST
89555: LIST
89556: PUSH
89557: LD_VAR 0 1
89561: PUSH
89562: LD_INT 4
89564: MINUS
89565: PUSH
89566: LD_VAR 0 2
89570: PUSH
89571: LD_INT 4
89573: MINUS
89574: PUSH
89575: LD_INT 2
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: LIST
89582: PUSH
89583: EMPTY
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: ST_TO_ADDR
// end ; 3 :
89590: GO 90012
89592: LD_INT 3
89594: DOUBLE
89595: EQUAL
89596: IFTRUE 89600
89598: GO 89733
89600: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
89601: LD_ADDR_VAR 0 5
89605: PUSH
89606: LD_VAR 0 1
89610: PUSH
89611: LD_INT 3
89613: PLUS
89614: PUSH
89615: LD_VAR 0 2
89619: PUSH
89620: LD_INT 4
89622: PUSH
89623: EMPTY
89624: LIST
89625: LIST
89626: LIST
89627: PUSH
89628: LD_VAR 0 1
89632: PUSH
89633: LD_INT 4
89635: PLUS
89636: PUSH
89637: LD_VAR 0 2
89641: PUSH
89642: LD_INT 4
89644: PLUS
89645: PUSH
89646: LD_INT 5
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: LIST
89653: PUSH
89654: LD_VAR 0 1
89658: PUSH
89659: LD_INT 4
89661: MINUS
89662: PUSH
89663: LD_VAR 0 2
89667: PUSH
89668: LD_INT 1
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: LIST
89675: PUSH
89676: LD_VAR 0 1
89680: PUSH
89681: LD_VAR 0 2
89685: PUSH
89686: LD_INT 4
89688: MINUS
89689: PUSH
89690: LD_INT 3
89692: PUSH
89693: EMPTY
89694: LIST
89695: LIST
89696: LIST
89697: PUSH
89698: LD_VAR 0 1
89702: PUSH
89703: LD_INT 3
89705: MINUS
89706: PUSH
89707: LD_VAR 0 2
89711: PUSH
89712: LD_INT 3
89714: MINUS
89715: PUSH
89716: LD_INT 2
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: LIST
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: ST_TO_ADDR
// end ; 4 :
89731: GO 90012
89733: LD_INT 4
89735: DOUBLE
89736: EQUAL
89737: IFTRUE 89741
89739: GO 89874
89741: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
89742: LD_ADDR_VAR 0 5
89746: PUSH
89747: LD_VAR 0 1
89751: PUSH
89752: LD_VAR 0 2
89756: PUSH
89757: LD_INT 4
89759: PLUS
89760: PUSH
89761: LD_INT 0
89763: PUSH
89764: EMPTY
89765: LIST
89766: LIST
89767: LIST
89768: PUSH
89769: LD_VAR 0 1
89773: PUSH
89774: LD_INT 3
89776: PLUS
89777: PUSH
89778: LD_VAR 0 2
89782: PUSH
89783: LD_INT 3
89785: PLUS
89786: PUSH
89787: LD_INT 5
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: LIST
89794: PUSH
89795: LD_VAR 0 1
89799: PUSH
89800: LD_INT 4
89802: PLUS
89803: PUSH
89804: LD_VAR 0 2
89808: PUSH
89809: LD_INT 4
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: LIST
89816: PUSH
89817: LD_VAR 0 1
89821: PUSH
89822: LD_VAR 0 2
89826: PUSH
89827: LD_INT 3
89829: MINUS
89830: PUSH
89831: LD_INT 3
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: LIST
89838: PUSH
89839: LD_VAR 0 1
89843: PUSH
89844: LD_INT 4
89846: MINUS
89847: PUSH
89848: LD_VAR 0 2
89852: PUSH
89853: LD_INT 4
89855: MINUS
89856: PUSH
89857: LD_INT 2
89859: PUSH
89860: EMPTY
89861: LIST
89862: LIST
89863: LIST
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: LIST
89869: LIST
89870: LIST
89871: ST_TO_ADDR
// end ; 5 :
89872: GO 90012
89874: LD_INT 5
89876: DOUBLE
89877: EQUAL
89878: IFTRUE 89882
89880: GO 90011
89882: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
89883: LD_ADDR_VAR 0 5
89887: PUSH
89888: LD_VAR 0 1
89892: PUSH
89893: LD_INT 4
89895: MINUS
89896: PUSH
89897: LD_VAR 0 2
89901: PUSH
89902: LD_INT 1
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: LIST
89909: PUSH
89910: LD_VAR 0 1
89914: PUSH
89915: LD_VAR 0 2
89919: PUSH
89920: LD_INT 4
89922: MINUS
89923: PUSH
89924: LD_INT 3
89926: PUSH
89927: EMPTY
89928: LIST
89929: LIST
89930: LIST
89931: PUSH
89932: LD_VAR 0 1
89936: PUSH
89937: LD_INT 4
89939: PLUS
89940: PUSH
89941: LD_VAR 0 2
89945: PUSH
89946: LD_INT 4
89948: PLUS
89949: PUSH
89950: LD_INT 5
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: LIST
89957: PUSH
89958: LD_VAR 0 1
89962: PUSH
89963: LD_INT 3
89965: PLUS
89966: PUSH
89967: LD_VAR 0 2
89971: PUSH
89972: LD_INT 4
89974: PUSH
89975: EMPTY
89976: LIST
89977: LIST
89978: LIST
89979: PUSH
89980: LD_VAR 0 1
89984: PUSH
89985: LD_VAR 0 2
89989: PUSH
89990: LD_INT 3
89992: PLUS
89993: PUSH
89994: LD_INT 0
89996: PUSH
89997: EMPTY
89998: LIST
89999: LIST
90000: LIST
90001: PUSH
90002: EMPTY
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: ST_TO_ADDR
// end ; end ;
90009: GO 90012
90011: POP
// result := list ;
90012: LD_ADDR_VAR 0 4
90016: PUSH
90017: LD_VAR 0 5
90021: ST_TO_ADDR
// end ;
90022: LD_VAR 0 4
90026: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
90027: LD_INT 0
90029: PPUSH
90030: PPUSH
90031: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
90032: LD_VAR 0 1
90036: NOT
90037: PUSH
90038: LD_VAR 0 2
90042: PUSH
90043: LD_INT 1
90045: PUSH
90046: LD_INT 2
90048: PUSH
90049: LD_INT 3
90051: PUSH
90052: LD_INT 4
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: IN
90061: NOT
90062: OR
90063: IFFALSE 90067
// exit ;
90065: GO 90150
// tmp := [ ] ;
90067: LD_ADDR_VAR 0 5
90071: PUSH
90072: EMPTY
90073: ST_TO_ADDR
// for i in units do
90074: LD_ADDR_VAR 0 4
90078: PUSH
90079: LD_VAR 0 1
90083: PUSH
90084: FOR_IN
90085: IFFALSE 90119
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
90087: LD_ADDR_VAR 0 5
90091: PUSH
90092: LD_VAR 0 5
90096: PPUSH
90097: LD_VAR 0 4
90101: PPUSH
90102: LD_VAR 0 2
90106: PPUSH
90107: CALL_OW 259
90111: PPUSH
90112: CALL 91523 0 2
90116: ST_TO_ADDR
90117: GO 90084
90119: POP
90120: POP
// if not tmp then
90121: LD_VAR 0 5
90125: NOT
90126: IFFALSE 90130
// exit ;
90128: GO 90150
// result := SortListByListDesc ( units , tmp ) ;
90130: LD_ADDR_VAR 0 3
90134: PUSH
90135: LD_VAR 0 1
90139: PPUSH
90140: LD_VAR 0 5
90144: PPUSH
90145: CALL_OW 77
90149: ST_TO_ADDR
// end ;
90150: LD_VAR 0 3
90154: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
90155: LD_INT 0
90157: PPUSH
90158: PPUSH
90159: PPUSH
// result := false ;
90160: LD_ADDR_VAR 0 3
90164: PUSH
90165: LD_INT 0
90167: ST_TO_ADDR
// if not building then
90168: LD_VAR 0 2
90172: NOT
90173: IFFALSE 90177
// exit ;
90175: GO 90315
// x := GetX ( building ) ;
90177: LD_ADDR_VAR 0 4
90181: PUSH
90182: LD_VAR 0 2
90186: PPUSH
90187: CALL_OW 250
90191: ST_TO_ADDR
// y := GetY ( building ) ;
90192: LD_ADDR_VAR 0 5
90196: PUSH
90197: LD_VAR 0 2
90201: PPUSH
90202: CALL_OW 251
90206: ST_TO_ADDR
// if not x or not y then
90207: LD_VAR 0 4
90211: NOT
90212: PUSH
90213: LD_VAR 0 5
90217: NOT
90218: OR
90219: IFFALSE 90223
// exit ;
90221: GO 90315
// if GetTaskList ( unit ) then
90223: LD_VAR 0 1
90227: PPUSH
90228: CALL_OW 437
90232: IFFALSE 90315
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
90234: LD_STRING e
90236: PUSH
90237: LD_VAR 0 1
90241: PPUSH
90242: CALL_OW 437
90246: PUSH
90247: LD_INT 1
90249: ARRAY
90250: PUSH
90251: LD_INT 1
90253: ARRAY
90254: EQUAL
90255: PUSH
90256: LD_VAR 0 4
90260: PUSH
90261: LD_VAR 0 1
90265: PPUSH
90266: CALL_OW 437
90270: PUSH
90271: LD_INT 1
90273: ARRAY
90274: PUSH
90275: LD_INT 2
90277: ARRAY
90278: EQUAL
90279: AND
90280: PUSH
90281: LD_VAR 0 5
90285: PUSH
90286: LD_VAR 0 1
90290: PPUSH
90291: CALL_OW 437
90295: PUSH
90296: LD_INT 1
90298: ARRAY
90299: PUSH
90300: LD_INT 3
90302: ARRAY
90303: EQUAL
90304: AND
90305: IFFALSE 90315
// result := true end ;
90307: LD_ADDR_VAR 0 3
90311: PUSH
90312: LD_INT 1
90314: ST_TO_ADDR
// end ;
90315: LD_VAR 0 3
90319: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
90320: LD_INT 0
90322: PPUSH
// result := false ;
90323: LD_ADDR_VAR 0 4
90327: PUSH
90328: LD_INT 0
90330: ST_TO_ADDR
// if GetTaskList ( unit ) then
90331: LD_VAR 0 1
90335: PPUSH
90336: CALL_OW 437
90340: IFFALSE 90423
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
90342: LD_STRING M
90344: PUSH
90345: LD_VAR 0 1
90349: PPUSH
90350: CALL_OW 437
90354: PUSH
90355: LD_INT 1
90357: ARRAY
90358: PUSH
90359: LD_INT 1
90361: ARRAY
90362: EQUAL
90363: PUSH
90364: LD_VAR 0 2
90368: PUSH
90369: LD_VAR 0 1
90373: PPUSH
90374: CALL_OW 437
90378: PUSH
90379: LD_INT 1
90381: ARRAY
90382: PUSH
90383: LD_INT 2
90385: ARRAY
90386: EQUAL
90387: AND
90388: PUSH
90389: LD_VAR 0 3
90393: PUSH
90394: LD_VAR 0 1
90398: PPUSH
90399: CALL_OW 437
90403: PUSH
90404: LD_INT 1
90406: ARRAY
90407: PUSH
90408: LD_INT 3
90410: ARRAY
90411: EQUAL
90412: AND
90413: IFFALSE 90423
// result := true ;
90415: LD_ADDR_VAR 0 4
90419: PUSH
90420: LD_INT 1
90422: ST_TO_ADDR
// end ; end ;
90423: LD_VAR 0 4
90427: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
90428: LD_INT 0
90430: PPUSH
90431: PPUSH
90432: PPUSH
90433: PPUSH
// if not unit or not area then
90434: LD_VAR 0 1
90438: NOT
90439: PUSH
90440: LD_VAR 0 2
90444: NOT
90445: OR
90446: IFFALSE 90450
// exit ;
90448: GO 90626
// tmp := AreaToList ( area , i ) ;
90450: LD_ADDR_VAR 0 6
90454: PUSH
90455: LD_VAR 0 2
90459: PPUSH
90460: LD_VAR 0 5
90464: PPUSH
90465: CALL_OW 517
90469: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
90470: LD_ADDR_VAR 0 5
90474: PUSH
90475: DOUBLE
90476: LD_INT 1
90478: DEC
90479: ST_TO_ADDR
90480: LD_VAR 0 6
90484: PUSH
90485: LD_INT 1
90487: ARRAY
90488: PUSH
90489: FOR_TO
90490: IFFALSE 90624
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
90492: LD_ADDR_VAR 0 7
90496: PUSH
90497: LD_VAR 0 6
90501: PUSH
90502: LD_INT 1
90504: ARRAY
90505: PUSH
90506: LD_VAR 0 5
90510: ARRAY
90511: PUSH
90512: LD_VAR 0 6
90516: PUSH
90517: LD_INT 2
90519: ARRAY
90520: PUSH
90521: LD_VAR 0 5
90525: ARRAY
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
90531: LD_INT 92
90533: PUSH
90534: LD_VAR 0 7
90538: PUSH
90539: LD_INT 1
90541: ARRAY
90542: PUSH
90543: LD_VAR 0 7
90547: PUSH
90548: LD_INT 2
90550: ARRAY
90551: PUSH
90552: LD_INT 2
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: PPUSH
90561: CALL_OW 69
90565: PUSH
90566: LD_INT 0
90568: EQUAL
90569: IFFALSE 90622
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
90571: LD_VAR 0 1
90575: PPUSH
90576: LD_VAR 0 7
90580: PUSH
90581: LD_INT 1
90583: ARRAY
90584: PPUSH
90585: LD_VAR 0 7
90589: PUSH
90590: LD_INT 2
90592: ARRAY
90593: PPUSH
90594: LD_VAR 0 3
90598: PPUSH
90599: CALL_OW 48
// result := IsPlaced ( unit ) ;
90603: LD_ADDR_VAR 0 4
90607: PUSH
90608: LD_VAR 0 1
90612: PPUSH
90613: CALL_OW 305
90617: ST_TO_ADDR
// exit ;
90618: POP
90619: POP
90620: GO 90626
// end ; end ;
90622: GO 90489
90624: POP
90625: POP
// end ;
90626: LD_VAR 0 4
90630: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
90631: LD_INT 0
90633: PPUSH
90634: PPUSH
90635: PPUSH
// if not side or side > 8 then
90636: LD_VAR 0 1
90640: NOT
90641: PUSH
90642: LD_VAR 0 1
90646: PUSH
90647: LD_INT 8
90649: GREATER
90650: OR
90651: IFFALSE 90655
// exit ;
90653: GO 90842
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
90655: LD_ADDR_VAR 0 4
90659: PUSH
90660: LD_INT 22
90662: PUSH
90663: LD_VAR 0 1
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 21
90674: PUSH
90675: LD_INT 3
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PPUSH
90686: CALL_OW 69
90690: ST_TO_ADDR
// if not tmp then
90691: LD_VAR 0 4
90695: NOT
90696: IFFALSE 90700
// exit ;
90698: GO 90842
// enable_addtolog := true ;
90700: LD_ADDR_OWVAR 81
90704: PUSH
90705: LD_INT 1
90707: ST_TO_ADDR
// AddToLog ( [ ) ;
90708: LD_STRING [
90710: PPUSH
90711: CALL_OW 561
// for i in tmp do
90715: LD_ADDR_VAR 0 3
90719: PUSH
90720: LD_VAR 0 4
90724: PUSH
90725: FOR_IN
90726: IFFALSE 90833
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
90728: LD_STRING [
90730: PUSH
90731: LD_VAR 0 3
90735: PPUSH
90736: CALL_OW 266
90740: STR
90741: PUSH
90742: LD_STRING , 
90744: STR
90745: PUSH
90746: LD_VAR 0 3
90750: PPUSH
90751: CALL_OW 250
90755: STR
90756: PUSH
90757: LD_STRING , 
90759: STR
90760: PUSH
90761: LD_VAR 0 3
90765: PPUSH
90766: CALL_OW 251
90770: STR
90771: PUSH
90772: LD_STRING , 
90774: STR
90775: PUSH
90776: LD_VAR 0 3
90780: PPUSH
90781: CALL_OW 254
90785: STR
90786: PUSH
90787: LD_STRING , 
90789: STR
90790: PUSH
90791: LD_VAR 0 3
90795: PPUSH
90796: LD_INT 1
90798: PPUSH
90799: CALL_OW 268
90803: STR
90804: PUSH
90805: LD_STRING , 
90807: STR
90808: PUSH
90809: LD_VAR 0 3
90813: PPUSH
90814: LD_INT 2
90816: PPUSH
90817: CALL_OW 268
90821: STR
90822: PUSH
90823: LD_STRING ],
90825: STR
90826: PPUSH
90827: CALL_OW 561
// end ;
90831: GO 90725
90833: POP
90834: POP
// AddToLog ( ]; ) ;
90835: LD_STRING ];
90837: PPUSH
90838: CALL_OW 561
// end ;
90842: LD_VAR 0 2
90846: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
90847: LD_INT 0
90849: PPUSH
90850: PPUSH
90851: PPUSH
90852: PPUSH
90853: PPUSH
// if not area or not rate or not max then
90854: LD_VAR 0 1
90858: NOT
90859: PUSH
90860: LD_VAR 0 2
90864: NOT
90865: OR
90866: PUSH
90867: LD_VAR 0 4
90871: NOT
90872: OR
90873: IFFALSE 90877
// exit ;
90875: GO 91066
// while 1 do
90877: LD_INT 1
90879: IFFALSE 91066
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
90881: LD_ADDR_VAR 0 9
90885: PUSH
90886: LD_VAR 0 1
90890: PPUSH
90891: LD_INT 1
90893: PPUSH
90894: CALL_OW 287
90898: PUSH
90899: LD_INT 10
90901: MUL
90902: ST_TO_ADDR
// r := rate / 10 ;
90903: LD_ADDR_VAR 0 7
90907: PUSH
90908: LD_VAR 0 2
90912: PUSH
90913: LD_INT 10
90915: DIVREAL
90916: ST_TO_ADDR
// time := 1 1$00 ;
90917: LD_ADDR_VAR 0 8
90921: PUSH
90922: LD_INT 2100
90924: ST_TO_ADDR
// if amount < min then
90925: LD_VAR 0 9
90929: PUSH
90930: LD_VAR 0 3
90934: LESS
90935: IFFALSE 90953
// r := r * 2 else
90937: LD_ADDR_VAR 0 7
90941: PUSH
90942: LD_VAR 0 7
90946: PUSH
90947: LD_INT 2
90949: MUL
90950: ST_TO_ADDR
90951: GO 90979
// if amount > max then
90953: LD_VAR 0 9
90957: PUSH
90958: LD_VAR 0 4
90962: GREATER
90963: IFFALSE 90979
// r := r / 2 ;
90965: LD_ADDR_VAR 0 7
90969: PUSH
90970: LD_VAR 0 7
90974: PUSH
90975: LD_INT 2
90977: DIVREAL
90978: ST_TO_ADDR
// time := time / r ;
90979: LD_ADDR_VAR 0 8
90983: PUSH
90984: LD_VAR 0 8
90988: PUSH
90989: LD_VAR 0 7
90993: DIVREAL
90994: ST_TO_ADDR
// if time < 0 then
90995: LD_VAR 0 8
90999: PUSH
91000: LD_INT 0
91002: LESS
91003: IFFALSE 91020
// time := time * - 1 ;
91005: LD_ADDR_VAR 0 8
91009: PUSH
91010: LD_VAR 0 8
91014: PUSH
91015: LD_INT 1
91017: NEG
91018: MUL
91019: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
91020: LD_VAR 0 8
91024: PUSH
91025: LD_INT 35
91027: PPUSH
91028: LD_INT 875
91030: PPUSH
91031: CALL_OW 12
91035: PLUS
91036: PPUSH
91037: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
91041: LD_INT 1
91043: PPUSH
91044: LD_INT 5
91046: PPUSH
91047: CALL_OW 12
91051: PPUSH
91052: LD_VAR 0 1
91056: PPUSH
91057: LD_INT 1
91059: PPUSH
91060: CALL_OW 55
// end ;
91064: GO 90877
// end ;
91066: LD_VAR 0 5
91070: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
91071: LD_INT 0
91073: PPUSH
91074: PPUSH
91075: PPUSH
91076: PPUSH
91077: PPUSH
91078: PPUSH
91079: PPUSH
91080: PPUSH
// if not turrets or not factories then
91081: LD_VAR 0 1
91085: NOT
91086: PUSH
91087: LD_VAR 0 2
91091: NOT
91092: OR
91093: IFFALSE 91097
// exit ;
91095: GO 91404
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
91097: LD_ADDR_VAR 0 10
91101: PUSH
91102: LD_INT 5
91104: PUSH
91105: LD_INT 6
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: PUSH
91112: LD_INT 2
91114: PUSH
91115: LD_INT 4
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 3
91124: PUSH
91125: LD_INT 5
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: PUSH
91132: EMPTY
91133: LIST
91134: LIST
91135: LIST
91136: PUSH
91137: LD_INT 24
91139: PUSH
91140: LD_INT 25
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: PUSH
91147: LD_INT 23
91149: PUSH
91150: LD_INT 27
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: PUSH
91161: LD_INT 42
91163: PUSH
91164: LD_INT 43
91166: PUSH
91167: EMPTY
91168: LIST
91169: LIST
91170: PUSH
91171: LD_INT 44
91173: PUSH
91174: LD_INT 46
91176: PUSH
91177: EMPTY
91178: LIST
91179: LIST
91180: PUSH
91181: LD_INT 45
91183: PUSH
91184: LD_INT 47
91186: PUSH
91187: EMPTY
91188: LIST
91189: LIST
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: LIST
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: LIST
91200: ST_TO_ADDR
// result := [ ] ;
91201: LD_ADDR_VAR 0 3
91205: PUSH
91206: EMPTY
91207: ST_TO_ADDR
// for i in turrets do
91208: LD_ADDR_VAR 0 4
91212: PUSH
91213: LD_VAR 0 1
91217: PUSH
91218: FOR_IN
91219: IFFALSE 91402
// begin nat := GetNation ( i ) ;
91221: LD_ADDR_VAR 0 7
91225: PUSH
91226: LD_VAR 0 4
91230: PPUSH
91231: CALL_OW 248
91235: ST_TO_ADDR
// weapon := 0 ;
91236: LD_ADDR_VAR 0 8
91240: PUSH
91241: LD_INT 0
91243: ST_TO_ADDR
// if not nat then
91244: LD_VAR 0 7
91248: NOT
91249: IFFALSE 91253
// continue ;
91251: GO 91218
// for j in list [ nat ] do
91253: LD_ADDR_VAR 0 5
91257: PUSH
91258: LD_VAR 0 10
91262: PUSH
91263: LD_VAR 0 7
91267: ARRAY
91268: PUSH
91269: FOR_IN
91270: IFFALSE 91311
// if GetBWeapon ( i ) = j [ 1 ] then
91272: LD_VAR 0 4
91276: PPUSH
91277: CALL_OW 269
91281: PUSH
91282: LD_VAR 0 5
91286: PUSH
91287: LD_INT 1
91289: ARRAY
91290: EQUAL
91291: IFFALSE 91309
// begin weapon := j [ 2 ] ;
91293: LD_ADDR_VAR 0 8
91297: PUSH
91298: LD_VAR 0 5
91302: PUSH
91303: LD_INT 2
91305: ARRAY
91306: ST_TO_ADDR
// break ;
91307: GO 91311
// end ;
91309: GO 91269
91311: POP
91312: POP
// if not weapon then
91313: LD_VAR 0 8
91317: NOT
91318: IFFALSE 91322
// continue ;
91320: GO 91218
// for k in factories do
91322: LD_ADDR_VAR 0 6
91326: PUSH
91327: LD_VAR 0 2
91331: PUSH
91332: FOR_IN
91333: IFFALSE 91398
// begin weapons := AvailableWeaponList ( k ) ;
91335: LD_ADDR_VAR 0 9
91339: PUSH
91340: LD_VAR 0 6
91344: PPUSH
91345: CALL_OW 478
91349: ST_TO_ADDR
// if not weapons then
91350: LD_VAR 0 9
91354: NOT
91355: IFFALSE 91359
// continue ;
91357: GO 91332
// if weapon in weapons then
91359: LD_VAR 0 8
91363: PUSH
91364: LD_VAR 0 9
91368: IN
91369: IFFALSE 91396
// begin result := [ i , weapon ] ;
91371: LD_ADDR_VAR 0 3
91375: PUSH
91376: LD_VAR 0 4
91380: PUSH
91381: LD_VAR 0 8
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: ST_TO_ADDR
// exit ;
91390: POP
91391: POP
91392: POP
91393: POP
91394: GO 91404
// end ; end ;
91396: GO 91332
91398: POP
91399: POP
// end ;
91400: GO 91218
91402: POP
91403: POP
// end ;
91404: LD_VAR 0 3
91408: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
91409: LD_INT 0
91411: PPUSH
// if not side or side > 8 then
91412: LD_VAR 0 3
91416: NOT
91417: PUSH
91418: LD_VAR 0 3
91422: PUSH
91423: LD_INT 8
91425: GREATER
91426: OR
91427: IFFALSE 91431
// exit ;
91429: GO 91490
// if not range then
91431: LD_VAR 0 4
91435: NOT
91436: IFFALSE 91447
// range := - 12 ;
91438: LD_ADDR_VAR 0 4
91442: PUSH
91443: LD_INT 12
91445: NEG
91446: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
91447: LD_VAR 0 1
91451: PPUSH
91452: LD_VAR 0 2
91456: PPUSH
91457: LD_VAR 0 3
91461: PPUSH
91462: LD_VAR 0 4
91466: PPUSH
91467: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
91471: LD_VAR 0 1
91475: PPUSH
91476: LD_VAR 0 2
91480: PPUSH
91481: LD_VAR 0 3
91485: PPUSH
91486: CALL_OW 331
// end ;
91490: LD_VAR 0 5
91494: RET
// export function Video ( mode ) ; begin
91495: LD_INT 0
91497: PPUSH
// ingame_video = mode ;
91498: LD_ADDR_OWVAR 52
91502: PUSH
91503: LD_VAR 0 1
91507: ST_TO_ADDR
// interface_hidden = mode ;
91508: LD_ADDR_OWVAR 54
91512: PUSH
91513: LD_VAR 0 1
91517: ST_TO_ADDR
// end ;
91518: LD_VAR 0 2
91522: RET
// export function Join ( array , element ) ; begin
91523: LD_INT 0
91525: PPUSH
// result := Replace ( array , array + 1 , element ) ;
91526: LD_ADDR_VAR 0 3
91530: PUSH
91531: LD_VAR 0 1
91535: PPUSH
91536: LD_VAR 0 1
91540: PUSH
91541: LD_INT 1
91543: PLUS
91544: PPUSH
91545: LD_VAR 0 2
91549: PPUSH
91550: CALL_OW 1
91554: ST_TO_ADDR
// end ;
91555: LD_VAR 0 3
91559: RET
// export function JoinUnion ( array , element ) ; begin
91560: LD_INT 0
91562: PPUSH
// result := array union element ;
91563: LD_ADDR_VAR 0 3
91567: PUSH
91568: LD_VAR 0 1
91572: PUSH
91573: LD_VAR 0 2
91577: UNION
91578: ST_TO_ADDR
// end ;
91579: LD_VAR 0 3
91583: RET
// export function GetBehemoths ( side ) ; begin
91584: LD_INT 0
91586: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
91587: LD_ADDR_VAR 0 2
91591: PUSH
91592: LD_INT 22
91594: PUSH
91595: LD_VAR 0 1
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 31
91606: PUSH
91607: LD_INT 25
91609: PUSH
91610: EMPTY
91611: LIST
91612: LIST
91613: PUSH
91614: EMPTY
91615: LIST
91616: LIST
91617: PPUSH
91618: CALL_OW 69
91622: ST_TO_ADDR
// end ;
91623: LD_VAR 0 2
91627: RET
// export function Shuffle ( array ) ; var i , index ; begin
91628: LD_INT 0
91630: PPUSH
91631: PPUSH
91632: PPUSH
// result := [ ] ;
91633: LD_ADDR_VAR 0 2
91637: PUSH
91638: EMPTY
91639: ST_TO_ADDR
// if not array then
91640: LD_VAR 0 1
91644: NOT
91645: IFFALSE 91649
// exit ;
91647: GO 91748
// Randomize ;
91649: CALL_OW 10
// for i = array downto 1 do
91653: LD_ADDR_VAR 0 3
91657: PUSH
91658: DOUBLE
91659: LD_VAR 0 1
91663: INC
91664: ST_TO_ADDR
91665: LD_INT 1
91667: PUSH
91668: FOR_DOWNTO
91669: IFFALSE 91746
// begin index := rand ( 1 , array ) ;
91671: LD_ADDR_VAR 0 4
91675: PUSH
91676: LD_INT 1
91678: PPUSH
91679: LD_VAR 0 1
91683: PPUSH
91684: CALL_OW 12
91688: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
91689: LD_ADDR_VAR 0 2
91693: PUSH
91694: LD_VAR 0 2
91698: PPUSH
91699: LD_VAR 0 2
91703: PUSH
91704: LD_INT 1
91706: PLUS
91707: PPUSH
91708: LD_VAR 0 1
91712: PUSH
91713: LD_VAR 0 4
91717: ARRAY
91718: PPUSH
91719: CALL_OW 2
91723: ST_TO_ADDR
// array := Delete ( array , index ) ;
91724: LD_ADDR_VAR 0 1
91728: PUSH
91729: LD_VAR 0 1
91733: PPUSH
91734: LD_VAR 0 4
91738: PPUSH
91739: CALL_OW 3
91743: ST_TO_ADDR
// end ;
91744: GO 91668
91746: POP
91747: POP
// end ;
91748: LD_VAR 0 2
91752: RET
// export function GetBaseMaterials ( base ) ; begin
91753: LD_INT 0
91755: PPUSH
// result := [ 0 , 0 , 0 ] ;
91756: LD_ADDR_VAR 0 2
91760: PUSH
91761: LD_INT 0
91763: PUSH
91764: LD_INT 0
91766: PUSH
91767: LD_INT 0
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: LIST
91774: ST_TO_ADDR
// if not base then
91775: LD_VAR 0 1
91779: NOT
91780: IFFALSE 91784
// exit ;
91782: GO 91833
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
91784: LD_ADDR_VAR 0 2
91788: PUSH
91789: LD_VAR 0 1
91793: PPUSH
91794: LD_INT 1
91796: PPUSH
91797: CALL_OW 275
91801: PUSH
91802: LD_VAR 0 1
91806: PPUSH
91807: LD_INT 2
91809: PPUSH
91810: CALL_OW 275
91814: PUSH
91815: LD_VAR 0 1
91819: PPUSH
91820: LD_INT 3
91822: PPUSH
91823: CALL_OW 275
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: LIST
91832: ST_TO_ADDR
// end ;
91833: LD_VAR 0 2
91837: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
91838: LD_INT 0
91840: PPUSH
91841: PPUSH
// result := array ;
91842: LD_ADDR_VAR 0 3
91846: PUSH
91847: LD_VAR 0 1
91851: ST_TO_ADDR
// if size >= result then
91852: LD_VAR 0 2
91856: PUSH
91857: LD_VAR 0 3
91861: GREATEREQUAL
91862: IFFALSE 91866
// exit ;
91864: GO 91916
// if size then
91866: LD_VAR 0 2
91870: IFFALSE 91916
// for i := array downto size do
91872: LD_ADDR_VAR 0 4
91876: PUSH
91877: DOUBLE
91878: LD_VAR 0 1
91882: INC
91883: ST_TO_ADDR
91884: LD_VAR 0 2
91888: PUSH
91889: FOR_DOWNTO
91890: IFFALSE 91914
// result := Delete ( result , result ) ;
91892: LD_ADDR_VAR 0 3
91896: PUSH
91897: LD_VAR 0 3
91901: PPUSH
91902: LD_VAR 0 3
91906: PPUSH
91907: CALL_OW 3
91911: ST_TO_ADDR
91912: GO 91889
91914: POP
91915: POP
// end ;
91916: LD_VAR 0 3
91920: RET
// export function ComExit ( unit ) ; var tmp ; begin
91921: LD_INT 0
91923: PPUSH
91924: PPUSH
// if not IsInUnit ( unit ) then
91925: LD_VAR 0 1
91929: PPUSH
91930: CALL_OW 310
91934: NOT
91935: IFFALSE 91939
// exit ;
91937: GO 91999
// tmp := IsInUnit ( unit ) ;
91939: LD_ADDR_VAR 0 3
91943: PUSH
91944: LD_VAR 0 1
91948: PPUSH
91949: CALL_OW 310
91953: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
91954: LD_VAR 0 3
91958: PPUSH
91959: CALL_OW 247
91963: PUSH
91964: LD_INT 2
91966: EQUAL
91967: IFFALSE 91980
// ComExitVehicle ( unit ) else
91969: LD_VAR 0 1
91973: PPUSH
91974: CALL_OW 121
91978: GO 91989
// ComExitBuilding ( unit ) ;
91980: LD_VAR 0 1
91984: PPUSH
91985: CALL_OW 122
// result := tmp ;
91989: LD_ADDR_VAR 0 2
91993: PUSH
91994: LD_VAR 0 3
91998: ST_TO_ADDR
// end ;
91999: LD_VAR 0 2
92003: RET
// export function ComExitAll ( units ) ; var i ; begin
92004: LD_INT 0
92006: PPUSH
92007: PPUSH
// if not units then
92008: LD_VAR 0 1
92012: NOT
92013: IFFALSE 92017
// exit ;
92015: GO 92043
// for i in units do
92017: LD_ADDR_VAR 0 3
92021: PUSH
92022: LD_VAR 0 1
92026: PUSH
92027: FOR_IN
92028: IFFALSE 92041
// ComExit ( i ) ;
92030: LD_VAR 0 3
92034: PPUSH
92035: CALL 91921 0 1
92039: GO 92027
92041: POP
92042: POP
// end ;
92043: LD_VAR 0 2
92047: RET
// export function ResetHc ; begin
92048: LD_INT 0
92050: PPUSH
// InitHc ;
92051: CALL_OW 19
// hc_importance := 0 ;
92055: LD_ADDR_OWVAR 32
92059: PUSH
92060: LD_INT 0
92062: ST_TO_ADDR
// end ;
92063: LD_VAR 0 1
92067: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
92068: LD_INT 0
92070: PPUSH
92071: PPUSH
92072: PPUSH
// _x := ( x1 + x2 ) div 2 ;
92073: LD_ADDR_VAR 0 6
92077: PUSH
92078: LD_VAR 0 1
92082: PUSH
92083: LD_VAR 0 3
92087: PLUS
92088: PUSH
92089: LD_INT 2
92091: DIV
92092: ST_TO_ADDR
// if _x < 0 then
92093: LD_VAR 0 6
92097: PUSH
92098: LD_INT 0
92100: LESS
92101: IFFALSE 92118
// _x := _x * - 1 ;
92103: LD_ADDR_VAR 0 6
92107: PUSH
92108: LD_VAR 0 6
92112: PUSH
92113: LD_INT 1
92115: NEG
92116: MUL
92117: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
92118: LD_ADDR_VAR 0 7
92122: PUSH
92123: LD_VAR 0 2
92127: PUSH
92128: LD_VAR 0 4
92132: PLUS
92133: PUSH
92134: LD_INT 2
92136: DIV
92137: ST_TO_ADDR
// if _y < 0 then
92138: LD_VAR 0 7
92142: PUSH
92143: LD_INT 0
92145: LESS
92146: IFFALSE 92163
// _y := _y * - 1 ;
92148: LD_ADDR_VAR 0 7
92152: PUSH
92153: LD_VAR 0 7
92157: PUSH
92158: LD_INT 1
92160: NEG
92161: MUL
92162: ST_TO_ADDR
// result := [ _x , _y ] ;
92163: LD_ADDR_VAR 0 5
92167: PUSH
92168: LD_VAR 0 6
92172: PUSH
92173: LD_VAR 0 7
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: ST_TO_ADDR
// end ;
92182: LD_VAR 0 5
92186: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
92187: LD_INT 0
92189: PPUSH
92190: PPUSH
92191: PPUSH
92192: PPUSH
// task := GetTaskList ( unit ) ;
92193: LD_ADDR_VAR 0 7
92197: PUSH
92198: LD_VAR 0 1
92202: PPUSH
92203: CALL_OW 437
92207: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
92208: LD_VAR 0 7
92212: NOT
92213: PUSH
92214: LD_VAR 0 1
92218: PPUSH
92219: LD_VAR 0 2
92223: PPUSH
92224: CALL_OW 308
92228: NOT
92229: AND
92230: IFFALSE 92234
// exit ;
92232: GO 92352
// if IsInArea ( unit , area ) then
92234: LD_VAR 0 1
92238: PPUSH
92239: LD_VAR 0 2
92243: PPUSH
92244: CALL_OW 308
92248: IFFALSE 92266
// begin ComMoveToArea ( unit , goAway ) ;
92250: LD_VAR 0 1
92254: PPUSH
92255: LD_VAR 0 3
92259: PPUSH
92260: CALL_OW 113
// exit ;
92264: GO 92352
// end ; if task [ 1 ] [ 1 ] <> M then
92266: LD_VAR 0 7
92270: PUSH
92271: LD_INT 1
92273: ARRAY
92274: PUSH
92275: LD_INT 1
92277: ARRAY
92278: PUSH
92279: LD_STRING M
92281: NONEQUAL
92282: IFFALSE 92286
// exit ;
92284: GO 92352
// x := task [ 1 ] [ 2 ] ;
92286: LD_ADDR_VAR 0 5
92290: PUSH
92291: LD_VAR 0 7
92295: PUSH
92296: LD_INT 1
92298: ARRAY
92299: PUSH
92300: LD_INT 2
92302: ARRAY
92303: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
92304: LD_ADDR_VAR 0 6
92308: PUSH
92309: LD_VAR 0 7
92313: PUSH
92314: LD_INT 1
92316: ARRAY
92317: PUSH
92318: LD_INT 3
92320: ARRAY
92321: ST_TO_ADDR
// if InArea ( x , y , area ) then
92322: LD_VAR 0 5
92326: PPUSH
92327: LD_VAR 0 6
92331: PPUSH
92332: LD_VAR 0 2
92336: PPUSH
92337: CALL_OW 309
92341: IFFALSE 92352
// ComStop ( unit ) ;
92343: LD_VAR 0 1
92347: PPUSH
92348: CALL_OW 141
// end ;
92352: LD_VAR 0 4
92356: RET
// export function Abs ( value ) ; begin
92357: LD_INT 0
92359: PPUSH
// result := value ;
92360: LD_ADDR_VAR 0 2
92364: PUSH
92365: LD_VAR 0 1
92369: ST_TO_ADDR
// if value < 0 then
92370: LD_VAR 0 1
92374: PUSH
92375: LD_INT 0
92377: LESS
92378: IFFALSE 92395
// result := value * - 1 ;
92380: LD_ADDR_VAR 0 2
92384: PUSH
92385: LD_VAR 0 1
92389: PUSH
92390: LD_INT 1
92392: NEG
92393: MUL
92394: ST_TO_ADDR
// end ;
92395: LD_VAR 0 2
92399: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
92400: LD_INT 0
92402: PPUSH
92403: PPUSH
92404: PPUSH
92405: PPUSH
92406: PPUSH
92407: PPUSH
92408: PPUSH
92409: PPUSH
// if not unit or not building then
92410: LD_VAR 0 1
92414: NOT
92415: PUSH
92416: LD_VAR 0 2
92420: NOT
92421: OR
92422: IFFALSE 92426
// exit ;
92424: GO 92652
// x := GetX ( building ) ;
92426: LD_ADDR_VAR 0 4
92430: PUSH
92431: LD_VAR 0 2
92435: PPUSH
92436: CALL_OW 250
92440: ST_TO_ADDR
// y := GetY ( building ) ;
92441: LD_ADDR_VAR 0 6
92445: PUSH
92446: LD_VAR 0 2
92450: PPUSH
92451: CALL_OW 251
92455: ST_TO_ADDR
// d := GetDir ( building ) ;
92456: LD_ADDR_VAR 0 8
92460: PUSH
92461: LD_VAR 0 2
92465: PPUSH
92466: CALL_OW 254
92470: ST_TO_ADDR
// r := 4 ;
92471: LD_ADDR_VAR 0 9
92475: PUSH
92476: LD_INT 4
92478: ST_TO_ADDR
// for i := 1 to 5 do
92479: LD_ADDR_VAR 0 10
92483: PUSH
92484: DOUBLE
92485: LD_INT 1
92487: DEC
92488: ST_TO_ADDR
92489: LD_INT 5
92491: PUSH
92492: FOR_TO
92493: IFFALSE 92650
// begin _x := ShiftX ( x , d , r + i ) ;
92495: LD_ADDR_VAR 0 5
92499: PUSH
92500: LD_VAR 0 4
92504: PPUSH
92505: LD_VAR 0 8
92509: PPUSH
92510: LD_VAR 0 9
92514: PUSH
92515: LD_VAR 0 10
92519: PLUS
92520: PPUSH
92521: CALL_OW 272
92525: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
92526: LD_ADDR_VAR 0 7
92530: PUSH
92531: LD_VAR 0 6
92535: PPUSH
92536: LD_VAR 0 8
92540: PPUSH
92541: LD_VAR 0 9
92545: PUSH
92546: LD_VAR 0 10
92550: PLUS
92551: PPUSH
92552: CALL_OW 273
92556: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
92557: LD_VAR 0 5
92561: PPUSH
92562: LD_VAR 0 7
92566: PPUSH
92567: CALL_OW 488
92571: PUSH
92572: LD_VAR 0 5
92576: PPUSH
92577: LD_VAR 0 7
92581: PPUSH
92582: CALL_OW 428
92586: PPUSH
92587: CALL_OW 247
92591: PUSH
92592: LD_INT 3
92594: PUSH
92595: LD_INT 2
92597: PUSH
92598: EMPTY
92599: LIST
92600: LIST
92601: IN
92602: NOT
92603: AND
92604: IFFALSE 92648
// begin ComMoveXY ( unit , _x , _y ) ;
92606: LD_VAR 0 1
92610: PPUSH
92611: LD_VAR 0 5
92615: PPUSH
92616: LD_VAR 0 7
92620: PPUSH
92621: CALL_OW 111
// result := [ _x , _y ] ;
92625: LD_ADDR_VAR 0 3
92629: PUSH
92630: LD_VAR 0 5
92634: PUSH
92635: LD_VAR 0 7
92639: PUSH
92640: EMPTY
92641: LIST
92642: LIST
92643: ST_TO_ADDR
// exit ;
92644: POP
92645: POP
92646: GO 92652
// end ; end ;
92648: GO 92492
92650: POP
92651: POP
// end ;
92652: LD_VAR 0 3
92656: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
92657: LD_INT 0
92659: PPUSH
92660: PPUSH
92661: PPUSH
// result := 0 ;
92662: LD_ADDR_VAR 0 3
92666: PUSH
92667: LD_INT 0
92669: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
92670: LD_VAR 0 1
92674: PUSH
92675: LD_INT 0
92677: LESS
92678: PUSH
92679: LD_VAR 0 1
92683: PUSH
92684: LD_INT 8
92686: GREATER
92687: OR
92688: PUSH
92689: LD_VAR 0 2
92693: PUSH
92694: LD_INT 0
92696: LESS
92697: OR
92698: PUSH
92699: LD_VAR 0 2
92703: PUSH
92704: LD_INT 8
92706: GREATER
92707: OR
92708: IFFALSE 92712
// exit ;
92710: GO 92787
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
92712: LD_ADDR_VAR 0 4
92716: PUSH
92717: LD_INT 22
92719: PUSH
92720: LD_VAR 0 2
92724: PUSH
92725: EMPTY
92726: LIST
92727: LIST
92728: PPUSH
92729: CALL_OW 69
92733: PUSH
92734: FOR_IN
92735: IFFALSE 92785
// begin un := UnitShoot ( i ) ;
92737: LD_ADDR_VAR 0 5
92741: PUSH
92742: LD_VAR 0 4
92746: PPUSH
92747: CALL_OW 504
92751: ST_TO_ADDR
// if GetSide ( un ) = side1 then
92752: LD_VAR 0 5
92756: PPUSH
92757: CALL_OW 255
92761: PUSH
92762: LD_VAR 0 1
92766: EQUAL
92767: IFFALSE 92783
// begin result := un ;
92769: LD_ADDR_VAR 0 3
92773: PUSH
92774: LD_VAR 0 5
92778: ST_TO_ADDR
// exit ;
92779: POP
92780: POP
92781: GO 92787
// end ; end ;
92783: GO 92734
92785: POP
92786: POP
// end ;
92787: LD_VAR 0 3
92791: RET
// export function GetCargoBay ( units ) ; begin
92792: LD_INT 0
92794: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
92795: LD_ADDR_VAR 0 2
92799: PUSH
92800: LD_VAR 0 1
92804: PPUSH
92805: LD_INT 2
92807: PUSH
92808: LD_INT 34
92810: PUSH
92811: LD_INT 12
92813: PUSH
92814: EMPTY
92815: LIST
92816: LIST
92817: PUSH
92818: LD_INT 34
92820: PUSH
92821: LD_INT 51
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: PUSH
92828: LD_INT 34
92830: PUSH
92831: LD_INT 32
92833: PUSH
92834: EMPTY
92835: LIST
92836: LIST
92837: PUSH
92838: LD_INT 34
92840: PUSH
92841: LD_INT 89
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: PPUSH
92855: CALL_OW 72
92859: ST_TO_ADDR
// end ;
92860: LD_VAR 0 2
92864: RET
// export function Negate ( value ) ; begin
92865: LD_INT 0
92867: PPUSH
// result := not value ;
92868: LD_ADDR_VAR 0 2
92872: PUSH
92873: LD_VAR 0 1
92877: NOT
92878: ST_TO_ADDR
// end ;
92879: LD_VAR 0 2
92883: RET
// export function Inc ( value ) ; begin
92884: LD_INT 0
92886: PPUSH
// result := value + 1 ;
92887: LD_ADDR_VAR 0 2
92891: PUSH
92892: LD_VAR 0 1
92896: PUSH
92897: LD_INT 1
92899: PLUS
92900: ST_TO_ADDR
// end ;
92901: LD_VAR 0 2
92905: RET
// export function Dec ( value ) ; begin
92906: LD_INT 0
92908: PPUSH
// result := value - 1 ;
92909: LD_ADDR_VAR 0 2
92913: PUSH
92914: LD_VAR 0 1
92918: PUSH
92919: LD_INT 1
92921: MINUS
92922: ST_TO_ADDR
// end ;
92923: LD_VAR 0 2
92927: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
92928: LD_INT 0
92930: PPUSH
92931: PPUSH
92932: PPUSH
92933: PPUSH
92934: PPUSH
92935: PPUSH
92936: PPUSH
92937: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
92938: LD_VAR 0 1
92942: PPUSH
92943: LD_VAR 0 2
92947: PPUSH
92948: CALL_OW 488
92952: NOT
92953: PUSH
92954: LD_VAR 0 3
92958: PPUSH
92959: LD_VAR 0 4
92963: PPUSH
92964: CALL_OW 488
92968: NOT
92969: OR
92970: IFFALSE 92983
// begin result := - 1 ;
92972: LD_ADDR_VAR 0 5
92976: PUSH
92977: LD_INT 1
92979: NEG
92980: ST_TO_ADDR
// exit ;
92981: GO 93218
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
92983: LD_ADDR_VAR 0 12
92987: PUSH
92988: LD_VAR 0 1
92992: PPUSH
92993: LD_VAR 0 2
92997: PPUSH
92998: LD_VAR 0 3
93002: PPUSH
93003: LD_VAR 0 4
93007: PPUSH
93008: CALL 92068 0 4
93012: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
93013: LD_ADDR_VAR 0 11
93017: PUSH
93018: LD_VAR 0 1
93022: PPUSH
93023: LD_VAR 0 2
93027: PPUSH
93028: LD_VAR 0 12
93032: PUSH
93033: LD_INT 1
93035: ARRAY
93036: PPUSH
93037: LD_VAR 0 12
93041: PUSH
93042: LD_INT 2
93044: ARRAY
93045: PPUSH
93046: CALL_OW 298
93050: ST_TO_ADDR
// distance := 9999 ;
93051: LD_ADDR_VAR 0 10
93055: PUSH
93056: LD_INT 9999
93058: ST_TO_ADDR
// for i := 0 to 5 do
93059: LD_ADDR_VAR 0 6
93063: PUSH
93064: DOUBLE
93065: LD_INT 0
93067: DEC
93068: ST_TO_ADDR
93069: LD_INT 5
93071: PUSH
93072: FOR_TO
93073: IFFALSE 93216
// begin _x := ShiftX ( x1 , i , centerDist ) ;
93075: LD_ADDR_VAR 0 7
93079: PUSH
93080: LD_VAR 0 1
93084: PPUSH
93085: LD_VAR 0 6
93089: PPUSH
93090: LD_VAR 0 11
93094: PPUSH
93095: CALL_OW 272
93099: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
93100: LD_ADDR_VAR 0 8
93104: PUSH
93105: LD_VAR 0 2
93109: PPUSH
93110: LD_VAR 0 6
93114: PPUSH
93115: LD_VAR 0 11
93119: PPUSH
93120: CALL_OW 273
93124: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
93125: LD_VAR 0 7
93129: PPUSH
93130: LD_VAR 0 8
93134: PPUSH
93135: CALL_OW 488
93139: NOT
93140: IFFALSE 93144
// continue ;
93142: GO 93072
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
93144: LD_ADDR_VAR 0 9
93148: PUSH
93149: LD_VAR 0 12
93153: PUSH
93154: LD_INT 1
93156: ARRAY
93157: PPUSH
93158: LD_VAR 0 12
93162: PUSH
93163: LD_INT 2
93165: ARRAY
93166: PPUSH
93167: LD_VAR 0 7
93171: PPUSH
93172: LD_VAR 0 8
93176: PPUSH
93177: CALL_OW 298
93181: ST_TO_ADDR
// if tmp < distance then
93182: LD_VAR 0 9
93186: PUSH
93187: LD_VAR 0 10
93191: LESS
93192: IFFALSE 93214
// begin result := i ;
93194: LD_ADDR_VAR 0 5
93198: PUSH
93199: LD_VAR 0 6
93203: ST_TO_ADDR
// distance := tmp ;
93204: LD_ADDR_VAR 0 10
93208: PUSH
93209: LD_VAR 0 9
93213: ST_TO_ADDR
// end ; end ;
93214: GO 93072
93216: POP
93217: POP
// end ;
93218: LD_VAR 0 5
93222: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
93223: LD_INT 0
93225: PPUSH
93226: PPUSH
// if not driver or not IsInUnit ( driver ) then
93227: LD_VAR 0 1
93231: NOT
93232: PUSH
93233: LD_VAR 0 1
93237: PPUSH
93238: CALL_OW 310
93242: NOT
93243: OR
93244: IFFALSE 93248
// exit ;
93246: GO 93338
// vehicle := IsInUnit ( driver ) ;
93248: LD_ADDR_VAR 0 3
93252: PUSH
93253: LD_VAR 0 1
93257: PPUSH
93258: CALL_OW 310
93262: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
93263: LD_VAR 0 1
93267: PPUSH
93268: LD_STRING \
93270: PUSH
93271: LD_INT 0
93273: PUSH
93274: LD_INT 0
93276: PUSH
93277: LD_INT 0
93279: PUSH
93280: LD_INT 0
93282: PUSH
93283: LD_INT 0
93285: PUSH
93286: LD_INT 0
93288: PUSH
93289: EMPTY
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: PUSH
93298: LD_STRING E
93300: PUSH
93301: LD_INT 0
93303: PUSH
93304: LD_INT 0
93306: PUSH
93307: LD_VAR 0 3
93311: PUSH
93312: LD_INT 0
93314: PUSH
93315: LD_INT 0
93317: PUSH
93318: LD_INT 0
93320: PUSH
93321: EMPTY
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: PUSH
93330: EMPTY
93331: LIST
93332: LIST
93333: PPUSH
93334: CALL_OW 446
// end ;
93338: LD_VAR 0 2
93342: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
93343: LD_INT 0
93345: PPUSH
93346: PPUSH
// if not driver or not IsInUnit ( driver ) then
93347: LD_VAR 0 1
93351: NOT
93352: PUSH
93353: LD_VAR 0 1
93357: PPUSH
93358: CALL_OW 310
93362: NOT
93363: OR
93364: IFFALSE 93368
// exit ;
93366: GO 93458
// vehicle := IsInUnit ( driver ) ;
93368: LD_ADDR_VAR 0 3
93372: PUSH
93373: LD_VAR 0 1
93377: PPUSH
93378: CALL_OW 310
93382: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
93383: LD_VAR 0 1
93387: PPUSH
93388: LD_STRING \
93390: PUSH
93391: LD_INT 0
93393: PUSH
93394: LD_INT 0
93396: PUSH
93397: LD_INT 0
93399: PUSH
93400: LD_INT 0
93402: PUSH
93403: LD_INT 0
93405: PUSH
93406: LD_INT 0
93408: PUSH
93409: EMPTY
93410: LIST
93411: LIST
93412: LIST
93413: LIST
93414: LIST
93415: LIST
93416: LIST
93417: PUSH
93418: LD_STRING E
93420: PUSH
93421: LD_INT 0
93423: PUSH
93424: LD_INT 0
93426: PUSH
93427: LD_VAR 0 3
93431: PUSH
93432: LD_INT 0
93434: PUSH
93435: LD_INT 0
93437: PUSH
93438: LD_INT 0
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: LIST
93448: LIST
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PPUSH
93454: CALL_OW 447
// end ;
93458: LD_VAR 0 2
93462: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
93463: LD_INT 0
93465: PPUSH
93466: PPUSH
93467: PPUSH
// tmp := [ ] ;
93468: LD_ADDR_VAR 0 5
93472: PUSH
93473: EMPTY
93474: ST_TO_ADDR
// for i in units do
93475: LD_ADDR_VAR 0 4
93479: PUSH
93480: LD_VAR 0 1
93484: PUSH
93485: FOR_IN
93486: IFFALSE 93524
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
93488: LD_ADDR_VAR 0 5
93492: PUSH
93493: LD_VAR 0 5
93497: PPUSH
93498: LD_VAR 0 5
93502: PUSH
93503: LD_INT 1
93505: PLUS
93506: PPUSH
93507: LD_VAR 0 4
93511: PPUSH
93512: CALL_OW 256
93516: PPUSH
93517: CALL_OW 2
93521: ST_TO_ADDR
93522: GO 93485
93524: POP
93525: POP
// if not tmp then
93526: LD_VAR 0 5
93530: NOT
93531: IFFALSE 93535
// exit ;
93533: GO 93583
// if asc then
93535: LD_VAR 0 2
93539: IFFALSE 93563
// result := SortListByListAsc ( units , tmp ) else
93541: LD_ADDR_VAR 0 3
93545: PUSH
93546: LD_VAR 0 1
93550: PPUSH
93551: LD_VAR 0 5
93555: PPUSH
93556: CALL_OW 76
93560: ST_TO_ADDR
93561: GO 93583
// result := SortListByListDesc ( units , tmp ) ;
93563: LD_ADDR_VAR 0 3
93567: PUSH
93568: LD_VAR 0 1
93572: PPUSH
93573: LD_VAR 0 5
93577: PPUSH
93578: CALL_OW 77
93582: ST_TO_ADDR
// end ;
93583: LD_VAR 0 3
93587: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
93588: LD_INT 0
93590: PPUSH
93591: PPUSH
// task := GetTaskList ( mech ) ;
93592: LD_ADDR_VAR 0 4
93596: PUSH
93597: LD_VAR 0 1
93601: PPUSH
93602: CALL_OW 437
93606: ST_TO_ADDR
// if not task then
93607: LD_VAR 0 4
93611: NOT
93612: IFFALSE 93616
// exit ;
93614: GO 93658
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
93616: LD_ADDR_VAR 0 3
93620: PUSH
93621: LD_VAR 0 4
93625: PUSH
93626: LD_INT 1
93628: ARRAY
93629: PUSH
93630: LD_INT 1
93632: ARRAY
93633: PUSH
93634: LD_STRING r
93636: EQUAL
93637: PUSH
93638: LD_VAR 0 4
93642: PUSH
93643: LD_INT 1
93645: ARRAY
93646: PUSH
93647: LD_INT 4
93649: ARRAY
93650: PUSH
93651: LD_VAR 0 2
93655: EQUAL
93656: AND
93657: ST_TO_ADDR
// end ;
93658: LD_VAR 0 3
93662: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
93663: LD_INT 0
93665: PPUSH
// SetDir ( unit , d ) ;
93666: LD_VAR 0 1
93670: PPUSH
93671: LD_VAR 0 4
93675: PPUSH
93676: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
93680: LD_ADDR_VAR 0 6
93684: PUSH
93685: LD_VAR 0 1
93689: PPUSH
93690: LD_VAR 0 2
93694: PPUSH
93695: LD_VAR 0 3
93699: PPUSH
93700: LD_VAR 0 5
93704: PPUSH
93705: CALL_OW 48
93709: ST_TO_ADDR
// end ;
93710: LD_VAR 0 6
93714: RET
// export function ToNaturalNumber ( number ) ; begin
93715: LD_INT 0
93717: PPUSH
// result := number div 1 ;
93718: LD_ADDR_VAR 0 2
93722: PUSH
93723: LD_VAR 0 1
93727: PUSH
93728: LD_INT 1
93730: DIV
93731: ST_TO_ADDR
// if number < 0 then
93732: LD_VAR 0 1
93736: PUSH
93737: LD_INT 0
93739: LESS
93740: IFFALSE 93750
// result := 0 ;
93742: LD_ADDR_VAR 0 2
93746: PUSH
93747: LD_INT 0
93749: ST_TO_ADDR
// end ;
93750: LD_VAR 0 2
93754: RET
// export function SortByClass ( units , class ) ; var un ; begin
93755: LD_INT 0
93757: PPUSH
93758: PPUSH
// if not units or not class then
93759: LD_VAR 0 1
93763: NOT
93764: PUSH
93765: LD_VAR 0 2
93769: NOT
93770: OR
93771: IFFALSE 93775
// exit ;
93773: GO 93870
// result := [ ] ;
93775: LD_ADDR_VAR 0 3
93779: PUSH
93780: EMPTY
93781: ST_TO_ADDR
// for un in units do
93782: LD_ADDR_VAR 0 4
93786: PUSH
93787: LD_VAR 0 1
93791: PUSH
93792: FOR_IN
93793: IFFALSE 93868
// if GetClass ( un ) = class then
93795: LD_VAR 0 4
93799: PPUSH
93800: CALL_OW 257
93804: PUSH
93805: LD_VAR 0 2
93809: EQUAL
93810: IFFALSE 93837
// result := Insert ( result , 1 , un ) else
93812: LD_ADDR_VAR 0 3
93816: PUSH
93817: LD_VAR 0 3
93821: PPUSH
93822: LD_INT 1
93824: PPUSH
93825: LD_VAR 0 4
93829: PPUSH
93830: CALL_OW 2
93834: ST_TO_ADDR
93835: GO 93866
// result := Replace ( result , result + 1 , un ) ;
93837: LD_ADDR_VAR 0 3
93841: PUSH
93842: LD_VAR 0 3
93846: PPUSH
93847: LD_VAR 0 3
93851: PUSH
93852: LD_INT 1
93854: PLUS
93855: PPUSH
93856: LD_VAR 0 4
93860: PPUSH
93861: CALL_OW 1
93865: ST_TO_ADDR
93866: GO 93792
93868: POP
93869: POP
// end ;
93870: LD_VAR 0 3
93874: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
93875: LD_INT 0
93877: PPUSH
93878: PPUSH
93879: PPUSH
93880: PPUSH
93881: PPUSH
93882: PPUSH
93883: PPUSH
// result := [ ] ;
93884: LD_ADDR_VAR 0 4
93888: PUSH
93889: EMPTY
93890: ST_TO_ADDR
// if x - r < 0 then
93891: LD_VAR 0 1
93895: PUSH
93896: LD_VAR 0 3
93900: MINUS
93901: PUSH
93902: LD_INT 0
93904: LESS
93905: IFFALSE 93917
// min_x := 0 else
93907: LD_ADDR_VAR 0 8
93911: PUSH
93912: LD_INT 0
93914: ST_TO_ADDR
93915: GO 93933
// min_x := x - r ;
93917: LD_ADDR_VAR 0 8
93921: PUSH
93922: LD_VAR 0 1
93926: PUSH
93927: LD_VAR 0 3
93931: MINUS
93932: ST_TO_ADDR
// if y - r < 0 then
93933: LD_VAR 0 2
93937: PUSH
93938: LD_VAR 0 3
93942: MINUS
93943: PUSH
93944: LD_INT 0
93946: LESS
93947: IFFALSE 93959
// min_y := 0 else
93949: LD_ADDR_VAR 0 7
93953: PUSH
93954: LD_INT 0
93956: ST_TO_ADDR
93957: GO 93975
// min_y := y - r ;
93959: LD_ADDR_VAR 0 7
93963: PUSH
93964: LD_VAR 0 2
93968: PUSH
93969: LD_VAR 0 3
93973: MINUS
93974: ST_TO_ADDR
// max_x := x + r ;
93975: LD_ADDR_VAR 0 9
93979: PUSH
93980: LD_VAR 0 1
93984: PUSH
93985: LD_VAR 0 3
93989: PLUS
93990: ST_TO_ADDR
// max_y := y + r ;
93991: LD_ADDR_VAR 0 10
93995: PUSH
93996: LD_VAR 0 2
94000: PUSH
94001: LD_VAR 0 3
94005: PLUS
94006: ST_TO_ADDR
// for _x = min_x to max_x do
94007: LD_ADDR_VAR 0 5
94011: PUSH
94012: DOUBLE
94013: LD_VAR 0 8
94017: DEC
94018: ST_TO_ADDR
94019: LD_VAR 0 9
94023: PUSH
94024: FOR_TO
94025: IFFALSE 94126
// for _y = min_y to max_y do
94027: LD_ADDR_VAR 0 6
94031: PUSH
94032: DOUBLE
94033: LD_VAR 0 7
94037: DEC
94038: ST_TO_ADDR
94039: LD_VAR 0 10
94043: PUSH
94044: FOR_TO
94045: IFFALSE 94122
// begin if not ValidHex ( _x , _y ) then
94047: LD_VAR 0 5
94051: PPUSH
94052: LD_VAR 0 6
94056: PPUSH
94057: CALL_OW 488
94061: NOT
94062: IFFALSE 94066
// continue ;
94064: GO 94044
// if GetResourceTypeXY ( _x , _y ) then
94066: LD_VAR 0 5
94070: PPUSH
94071: LD_VAR 0 6
94075: PPUSH
94076: CALL_OW 283
94080: IFFALSE 94120
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
94082: LD_ADDR_VAR 0 4
94086: PUSH
94087: LD_VAR 0 4
94091: PPUSH
94092: LD_VAR 0 4
94096: PUSH
94097: LD_INT 1
94099: PLUS
94100: PPUSH
94101: LD_VAR 0 5
94105: PUSH
94106: LD_VAR 0 6
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PPUSH
94115: CALL_OW 1
94119: ST_TO_ADDR
// end ;
94120: GO 94044
94122: POP
94123: POP
94124: GO 94024
94126: POP
94127: POP
// end ;
94128: LD_VAR 0 4
94132: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
94133: LD_INT 0
94135: PPUSH
94136: PPUSH
94137: PPUSH
94138: PPUSH
94139: PPUSH
94140: PPUSH
94141: PPUSH
94142: PPUSH
// if not units then
94143: LD_VAR 0 1
94147: NOT
94148: IFFALSE 94152
// exit ;
94150: GO 94680
// result := UnitFilter ( units , [ f_ok ] ) ;
94152: LD_ADDR_VAR 0 3
94156: PUSH
94157: LD_VAR 0 1
94161: PPUSH
94162: LD_INT 50
94164: PUSH
94165: EMPTY
94166: LIST
94167: PPUSH
94168: CALL_OW 72
94172: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
94173: LD_ADDR_VAR 0 8
94177: PUSH
94178: LD_VAR 0 1
94182: PUSH
94183: LD_INT 1
94185: ARRAY
94186: PPUSH
94187: CALL_OW 255
94191: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
94192: LD_ADDR_VAR 0 10
94196: PUSH
94197: LD_INT 29
94199: PUSH
94200: LD_INT 91
94202: PUSH
94203: LD_INT 49
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: LIST
94210: ST_TO_ADDR
// if not result then
94211: LD_VAR 0 3
94215: NOT
94216: IFFALSE 94220
// exit ;
94218: GO 94680
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
94220: LD_ADDR_VAR 0 5
94224: PUSH
94225: LD_INT 81
94227: PUSH
94228: LD_VAR 0 8
94232: PUSH
94233: EMPTY
94234: LIST
94235: LIST
94236: PPUSH
94237: CALL_OW 69
94241: ST_TO_ADDR
// for i in result do
94242: LD_ADDR_VAR 0 4
94246: PUSH
94247: LD_VAR 0 3
94251: PUSH
94252: FOR_IN
94253: IFFALSE 94678
// begin tag := GetTag ( i ) + 1 ;
94255: LD_ADDR_VAR 0 9
94259: PUSH
94260: LD_VAR 0 4
94264: PPUSH
94265: CALL_OW 110
94269: PUSH
94270: LD_INT 1
94272: PLUS
94273: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
94274: LD_ADDR_VAR 0 7
94278: PUSH
94279: LD_VAR 0 4
94283: PPUSH
94284: CALL_OW 250
94288: PPUSH
94289: LD_VAR 0 4
94293: PPUSH
94294: CALL_OW 251
94298: PPUSH
94299: LD_INT 4
94301: PPUSH
94302: CALL 93875 0 3
94306: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
94307: LD_VAR 0 4
94311: PPUSH
94312: CALL_OW 247
94316: PUSH
94317: LD_INT 2
94319: EQUAL
94320: PUSH
94321: LD_VAR 0 7
94325: PUSH
94326: LD_INT 2
94328: GREATER
94329: AND
94330: PUSH
94331: LD_VAR 0 4
94335: PPUSH
94336: CALL_OW 264
94340: PUSH
94341: LD_VAR 0 10
94345: IN
94346: NOT
94347: AND
94348: IFFALSE 94387
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
94350: LD_VAR 0 4
94354: PPUSH
94355: LD_VAR 0 7
94359: PUSH
94360: LD_INT 1
94362: ARRAY
94363: PUSH
94364: LD_INT 1
94366: ARRAY
94367: PPUSH
94368: LD_VAR 0 7
94372: PUSH
94373: LD_INT 1
94375: ARRAY
94376: PUSH
94377: LD_INT 2
94379: ARRAY
94380: PPUSH
94381: CALL_OW 116
94385: GO 94676
// if path > tag then
94387: LD_VAR 0 2
94391: PUSH
94392: LD_VAR 0 9
94396: GREATER
94397: IFFALSE 94605
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
94399: LD_ADDR_VAR 0 6
94403: PUSH
94404: LD_VAR 0 5
94408: PPUSH
94409: LD_INT 91
94411: PUSH
94412: LD_VAR 0 4
94416: PUSH
94417: LD_INT 8
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: LIST
94424: PPUSH
94425: CALL_OW 72
94429: ST_TO_ADDR
// if nearEnemy then
94430: LD_VAR 0 6
94434: IFFALSE 94503
// begin if GetWeapon ( i ) = ru_time_lapser then
94436: LD_VAR 0 4
94440: PPUSH
94441: CALL_OW 264
94445: PUSH
94446: LD_INT 49
94448: EQUAL
94449: IFFALSE 94477
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
94451: LD_VAR 0 4
94455: PPUSH
94456: LD_VAR 0 6
94460: PPUSH
94461: LD_VAR 0 4
94465: PPUSH
94466: CALL_OW 74
94470: PPUSH
94471: CALL_OW 112
94475: GO 94501
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
94477: LD_VAR 0 4
94481: PPUSH
94482: LD_VAR 0 6
94486: PPUSH
94487: LD_VAR 0 4
94491: PPUSH
94492: CALL_OW 74
94496: PPUSH
94497: CALL 95751 0 2
// end else
94501: GO 94603
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
94503: LD_VAR 0 4
94507: PPUSH
94508: LD_VAR 0 2
94512: PUSH
94513: LD_VAR 0 9
94517: ARRAY
94518: PUSH
94519: LD_INT 1
94521: ARRAY
94522: PPUSH
94523: LD_VAR 0 2
94527: PUSH
94528: LD_VAR 0 9
94532: ARRAY
94533: PUSH
94534: LD_INT 2
94536: ARRAY
94537: PPUSH
94538: CALL_OW 297
94542: PUSH
94543: LD_INT 6
94545: GREATER
94546: IFFALSE 94589
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
94548: LD_VAR 0 4
94552: PPUSH
94553: LD_VAR 0 2
94557: PUSH
94558: LD_VAR 0 9
94562: ARRAY
94563: PUSH
94564: LD_INT 1
94566: ARRAY
94567: PPUSH
94568: LD_VAR 0 2
94572: PUSH
94573: LD_VAR 0 9
94577: ARRAY
94578: PUSH
94579: LD_INT 2
94581: ARRAY
94582: PPUSH
94583: CALL_OW 114
94587: GO 94603
// SetTag ( i , tag ) ;
94589: LD_VAR 0 4
94593: PPUSH
94594: LD_VAR 0 9
94598: PPUSH
94599: CALL_OW 109
// end else
94603: GO 94676
// if enemy then
94605: LD_VAR 0 5
94609: IFFALSE 94676
// begin if GetWeapon ( i ) = ru_time_lapser then
94611: LD_VAR 0 4
94615: PPUSH
94616: CALL_OW 264
94620: PUSH
94621: LD_INT 49
94623: EQUAL
94624: IFFALSE 94652
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
94626: LD_VAR 0 4
94630: PPUSH
94631: LD_VAR 0 5
94635: PPUSH
94636: LD_VAR 0 4
94640: PPUSH
94641: CALL_OW 74
94645: PPUSH
94646: CALL_OW 112
94650: GO 94676
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
94652: LD_VAR 0 4
94656: PPUSH
94657: LD_VAR 0 5
94661: PPUSH
94662: LD_VAR 0 4
94666: PPUSH
94667: CALL_OW 74
94671: PPUSH
94672: CALL 95751 0 2
// end ; end ;
94676: GO 94252
94678: POP
94679: POP
// end ;
94680: LD_VAR 0 3
94684: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
94685: LD_INT 0
94687: PPUSH
94688: PPUSH
94689: PPUSH
// if not unit or IsInUnit ( unit ) then
94690: LD_VAR 0 1
94694: NOT
94695: PUSH
94696: LD_VAR 0 1
94700: PPUSH
94701: CALL_OW 310
94705: OR
94706: IFFALSE 94710
// exit ;
94708: GO 94801
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
94710: LD_ADDR_VAR 0 4
94714: PUSH
94715: LD_VAR 0 1
94719: PPUSH
94720: CALL_OW 250
94724: PPUSH
94725: LD_VAR 0 2
94729: PPUSH
94730: LD_INT 1
94732: PPUSH
94733: CALL_OW 272
94737: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
94738: LD_ADDR_VAR 0 5
94742: PUSH
94743: LD_VAR 0 1
94747: PPUSH
94748: CALL_OW 251
94752: PPUSH
94753: LD_VAR 0 2
94757: PPUSH
94758: LD_INT 1
94760: PPUSH
94761: CALL_OW 273
94765: ST_TO_ADDR
// if ValidHex ( x , y ) then
94766: LD_VAR 0 4
94770: PPUSH
94771: LD_VAR 0 5
94775: PPUSH
94776: CALL_OW 488
94780: IFFALSE 94801
// ComTurnXY ( unit , x , y ) ;
94782: LD_VAR 0 1
94786: PPUSH
94787: LD_VAR 0 4
94791: PPUSH
94792: LD_VAR 0 5
94796: PPUSH
94797: CALL_OW 118
// end ;
94801: LD_VAR 0 3
94805: RET
// export function SeeUnits ( side , units ) ; var i ; begin
94806: LD_INT 0
94808: PPUSH
94809: PPUSH
// result := false ;
94810: LD_ADDR_VAR 0 3
94814: PUSH
94815: LD_INT 0
94817: ST_TO_ADDR
// if not units then
94818: LD_VAR 0 2
94822: NOT
94823: IFFALSE 94827
// exit ;
94825: GO 94872
// for i in units do
94827: LD_ADDR_VAR 0 4
94831: PUSH
94832: LD_VAR 0 2
94836: PUSH
94837: FOR_IN
94838: IFFALSE 94870
// if See ( side , i ) then
94840: LD_VAR 0 1
94844: PPUSH
94845: LD_VAR 0 4
94849: PPUSH
94850: CALL_OW 292
94854: IFFALSE 94868
// begin result := true ;
94856: LD_ADDR_VAR 0 3
94860: PUSH
94861: LD_INT 1
94863: ST_TO_ADDR
// exit ;
94864: POP
94865: POP
94866: GO 94872
// end ;
94868: GO 94837
94870: POP
94871: POP
// end ;
94872: LD_VAR 0 3
94876: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
94877: LD_INT 0
94879: PPUSH
94880: PPUSH
94881: PPUSH
94882: PPUSH
// if not unit or not points then
94883: LD_VAR 0 1
94887: NOT
94888: PUSH
94889: LD_VAR 0 2
94893: NOT
94894: OR
94895: IFFALSE 94899
// exit ;
94897: GO 94989
// dist := 99999 ;
94899: LD_ADDR_VAR 0 5
94903: PUSH
94904: LD_INT 99999
94906: ST_TO_ADDR
// for i in points do
94907: LD_ADDR_VAR 0 4
94911: PUSH
94912: LD_VAR 0 2
94916: PUSH
94917: FOR_IN
94918: IFFALSE 94987
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
94920: LD_ADDR_VAR 0 6
94924: PUSH
94925: LD_VAR 0 1
94929: PPUSH
94930: LD_VAR 0 4
94934: PUSH
94935: LD_INT 1
94937: ARRAY
94938: PPUSH
94939: LD_VAR 0 4
94943: PUSH
94944: LD_INT 2
94946: ARRAY
94947: PPUSH
94948: CALL_OW 297
94952: ST_TO_ADDR
// if tmpDist < dist then
94953: LD_VAR 0 6
94957: PUSH
94958: LD_VAR 0 5
94962: LESS
94963: IFFALSE 94985
// begin result := i ;
94965: LD_ADDR_VAR 0 3
94969: PUSH
94970: LD_VAR 0 4
94974: ST_TO_ADDR
// dist := tmpDist ;
94975: LD_ADDR_VAR 0 5
94979: PUSH
94980: LD_VAR 0 6
94984: ST_TO_ADDR
// end ; end ;
94985: GO 94917
94987: POP
94988: POP
// end ;
94989: LD_VAR 0 3
94993: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
94994: LD_INT 0
94996: PPUSH
// uc_side := side ;
94997: LD_ADDR_OWVAR 20
95001: PUSH
95002: LD_VAR 0 1
95006: ST_TO_ADDR
// uc_nation := 3 ;
95007: LD_ADDR_OWVAR 21
95011: PUSH
95012: LD_INT 3
95014: ST_TO_ADDR
// vc_chassis := 25 ;
95015: LD_ADDR_OWVAR 37
95019: PUSH
95020: LD_INT 25
95022: ST_TO_ADDR
// vc_engine := engine_siberite ;
95023: LD_ADDR_OWVAR 39
95027: PUSH
95028: LD_INT 3
95030: ST_TO_ADDR
// vc_control := control_computer ;
95031: LD_ADDR_OWVAR 38
95035: PUSH
95036: LD_INT 3
95038: ST_TO_ADDR
// vc_weapon := 59 ;
95039: LD_ADDR_OWVAR 40
95043: PUSH
95044: LD_INT 59
95046: ST_TO_ADDR
// result := CreateVehicle ;
95047: LD_ADDR_VAR 0 5
95051: PUSH
95052: CALL_OW 45
95056: ST_TO_ADDR
// SetDir ( result , d ) ;
95057: LD_VAR 0 5
95061: PPUSH
95062: LD_VAR 0 4
95066: PPUSH
95067: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
95071: LD_VAR 0 5
95075: PPUSH
95076: LD_VAR 0 2
95080: PPUSH
95081: LD_VAR 0 3
95085: PPUSH
95086: LD_INT 0
95088: PPUSH
95089: CALL_OW 48
// end ;
95093: LD_VAR 0 5
95097: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
95098: LD_INT 0
95100: PPUSH
95101: PPUSH
95102: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
95103: LD_ADDR_VAR 0 2
95107: PUSH
95108: LD_INT 0
95110: PUSH
95111: LD_INT 0
95113: PUSH
95114: LD_INT 0
95116: PUSH
95117: LD_INT 0
95119: PUSH
95120: EMPTY
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
95126: LD_VAR 0 1
95130: NOT
95131: PUSH
95132: LD_VAR 0 1
95136: PPUSH
95137: CALL_OW 264
95141: PUSH
95142: LD_INT 12
95144: PUSH
95145: LD_INT 51
95147: PUSH
95148: LD_INT 32
95150: PUSH
95151: LD_INT 89
95153: PUSH
95154: EMPTY
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: IN
95160: NOT
95161: OR
95162: IFFALSE 95166
// exit ;
95164: GO 95264
// for i := 1 to 3 do
95166: LD_ADDR_VAR 0 3
95170: PUSH
95171: DOUBLE
95172: LD_INT 1
95174: DEC
95175: ST_TO_ADDR
95176: LD_INT 3
95178: PUSH
95179: FOR_TO
95180: IFFALSE 95262
// begin tmp := GetCargo ( cargo , i ) ;
95182: LD_ADDR_VAR 0 4
95186: PUSH
95187: LD_VAR 0 1
95191: PPUSH
95192: LD_VAR 0 3
95196: PPUSH
95197: CALL_OW 289
95201: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
95202: LD_ADDR_VAR 0 2
95206: PUSH
95207: LD_VAR 0 2
95211: PPUSH
95212: LD_VAR 0 3
95216: PPUSH
95217: LD_VAR 0 4
95221: PPUSH
95222: CALL_OW 1
95226: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
95227: LD_ADDR_VAR 0 2
95231: PUSH
95232: LD_VAR 0 2
95236: PPUSH
95237: LD_INT 4
95239: PPUSH
95240: LD_VAR 0 2
95244: PUSH
95245: LD_INT 4
95247: ARRAY
95248: PUSH
95249: LD_VAR 0 4
95253: PLUS
95254: PPUSH
95255: CALL_OW 1
95259: ST_TO_ADDR
// end ;
95260: GO 95179
95262: POP
95263: POP
// end ;
95264: LD_VAR 0 2
95268: RET
// export function Length ( array ) ; begin
95269: LD_INT 0
95271: PPUSH
// result := array + 0 ;
95272: LD_ADDR_VAR 0 2
95276: PUSH
95277: LD_VAR 0 1
95281: PUSH
95282: LD_INT 0
95284: PLUS
95285: ST_TO_ADDR
// end ;
95286: LD_VAR 0 2
95290: RET
// export function PrepareArray ( array ) ; begin
95291: LD_INT 0
95293: PPUSH
// result := array diff 0 ;
95294: LD_ADDR_VAR 0 2
95298: PUSH
95299: LD_VAR 0 1
95303: PUSH
95304: LD_INT 0
95306: DIFF
95307: ST_TO_ADDR
// if not result [ 1 ] then
95308: LD_VAR 0 2
95312: PUSH
95313: LD_INT 1
95315: ARRAY
95316: NOT
95317: IFFALSE 95337
// result := Delete ( result , 1 ) ;
95319: LD_ADDR_VAR 0 2
95323: PUSH
95324: LD_VAR 0 2
95328: PPUSH
95329: LD_INT 1
95331: PPUSH
95332: CALL_OW 3
95336: ST_TO_ADDR
// end ;
95337: LD_VAR 0 2
95341: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
95342: LD_INT 0
95344: PPUSH
95345: PPUSH
95346: PPUSH
95347: PPUSH
// sibRocketRange := 25 ;
95348: LD_ADDR_VAR 0 6
95352: PUSH
95353: LD_INT 25
95355: ST_TO_ADDR
// result := false ;
95356: LD_ADDR_VAR 0 4
95360: PUSH
95361: LD_INT 0
95363: ST_TO_ADDR
// for i := 0 to 5 do
95364: LD_ADDR_VAR 0 5
95368: PUSH
95369: DOUBLE
95370: LD_INT 0
95372: DEC
95373: ST_TO_ADDR
95374: LD_INT 5
95376: PUSH
95377: FOR_TO
95378: IFFALSE 95445
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
95380: LD_VAR 0 1
95384: PPUSH
95385: LD_VAR 0 5
95389: PPUSH
95390: LD_VAR 0 6
95394: PPUSH
95395: CALL_OW 272
95399: PPUSH
95400: LD_VAR 0 2
95404: PPUSH
95405: LD_VAR 0 5
95409: PPUSH
95410: LD_VAR 0 6
95414: PPUSH
95415: CALL_OW 273
95419: PPUSH
95420: LD_VAR 0 3
95424: PPUSH
95425: CALL_OW 309
95429: IFFALSE 95443
// begin result := true ;
95431: LD_ADDR_VAR 0 4
95435: PUSH
95436: LD_INT 1
95438: ST_TO_ADDR
// exit ;
95439: POP
95440: POP
95441: GO 95447
// end ;
95443: GO 95377
95445: POP
95446: POP
// end ;
95447: LD_VAR 0 4
95451: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
95452: LD_INT 0
95454: PPUSH
95455: PPUSH
95456: PPUSH
// if btype = b_depot then
95457: LD_VAR 0 2
95461: PUSH
95462: LD_INT 0
95464: EQUAL
95465: IFFALSE 95477
// begin result := true ;
95467: LD_ADDR_VAR 0 3
95471: PUSH
95472: LD_INT 1
95474: ST_TO_ADDR
// exit ;
95475: GO 95593
// end ; pom := GetBase ( depot ) ;
95477: LD_ADDR_VAR 0 4
95481: PUSH
95482: LD_VAR 0 1
95486: PPUSH
95487: CALL_OW 274
95491: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
95492: LD_ADDR_VAR 0 5
95496: PUSH
95497: LD_VAR 0 2
95501: PPUSH
95502: LD_VAR 0 1
95506: PPUSH
95507: CALL_OW 248
95511: PPUSH
95512: CALL_OW 450
95516: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
95517: LD_ADDR_VAR 0 3
95521: PUSH
95522: LD_VAR 0 4
95526: PPUSH
95527: LD_INT 1
95529: PPUSH
95530: CALL_OW 275
95534: PUSH
95535: LD_VAR 0 5
95539: PUSH
95540: LD_INT 1
95542: ARRAY
95543: GREATEREQUAL
95544: PUSH
95545: LD_VAR 0 4
95549: PPUSH
95550: LD_INT 2
95552: PPUSH
95553: CALL_OW 275
95557: PUSH
95558: LD_VAR 0 5
95562: PUSH
95563: LD_INT 2
95565: ARRAY
95566: GREATEREQUAL
95567: AND
95568: PUSH
95569: LD_VAR 0 4
95573: PPUSH
95574: LD_INT 3
95576: PPUSH
95577: CALL_OW 275
95581: PUSH
95582: LD_VAR 0 5
95586: PUSH
95587: LD_INT 3
95589: ARRAY
95590: GREATEREQUAL
95591: AND
95592: ST_TO_ADDR
// end ;
95593: LD_VAR 0 3
95597: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
95598: LD_INT 0
95600: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
95601: LD_VAR 0 1
95605: PPUSH
95606: LD_VAR 0 2
95610: PPUSH
95611: LD_INT 0
95613: PPUSH
95614: LD_INT 0
95616: PPUSH
95617: LD_INT 1
95619: PPUSH
95620: LD_INT 0
95622: PPUSH
95623: CALL_OW 587
// end ;
95627: LD_VAR 0 3
95631: RET
// export function CenterOnNow ( unit ) ; begin
95632: LD_INT 0
95634: PPUSH
// result := IsInUnit ( unit ) ;
95635: LD_ADDR_VAR 0 2
95639: PUSH
95640: LD_VAR 0 1
95644: PPUSH
95645: CALL_OW 310
95649: ST_TO_ADDR
// if not result then
95650: LD_VAR 0 2
95654: NOT
95655: IFFALSE 95667
// result := unit ;
95657: LD_ADDR_VAR 0 2
95661: PUSH
95662: LD_VAR 0 1
95666: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
95667: LD_VAR 0 1
95671: PPUSH
95672: CALL_OW 87
// end ;
95676: LD_VAR 0 2
95680: RET
// export function ComMoveHex ( unit , hex ) ; begin
95681: LD_INT 0
95683: PPUSH
// if not hex then
95684: LD_VAR 0 2
95688: NOT
95689: IFFALSE 95693
// exit ;
95691: GO 95746
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
95693: LD_VAR 0 2
95697: PUSH
95698: LD_INT 1
95700: ARRAY
95701: PPUSH
95702: LD_VAR 0 2
95706: PUSH
95707: LD_INT 2
95709: ARRAY
95710: PPUSH
95711: CALL_OW 428
95715: IFFALSE 95719
// exit ;
95717: GO 95746
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
95719: LD_VAR 0 1
95723: PPUSH
95724: LD_VAR 0 2
95728: PUSH
95729: LD_INT 1
95731: ARRAY
95732: PPUSH
95733: LD_VAR 0 2
95737: PUSH
95738: LD_INT 2
95740: ARRAY
95741: PPUSH
95742: CALL_OW 111
// end ;
95746: LD_VAR 0 3
95750: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
95751: LD_INT 0
95753: PPUSH
95754: PPUSH
95755: PPUSH
// if not unit or not enemy then
95756: LD_VAR 0 1
95760: NOT
95761: PUSH
95762: LD_VAR 0 2
95766: NOT
95767: OR
95768: IFFALSE 95772
// exit ;
95770: GO 95896
// x := GetX ( enemy ) ;
95772: LD_ADDR_VAR 0 4
95776: PUSH
95777: LD_VAR 0 2
95781: PPUSH
95782: CALL_OW 250
95786: ST_TO_ADDR
// y := GetY ( enemy ) ;
95787: LD_ADDR_VAR 0 5
95791: PUSH
95792: LD_VAR 0 2
95796: PPUSH
95797: CALL_OW 251
95801: ST_TO_ADDR
// if ValidHex ( x , y ) then
95802: LD_VAR 0 4
95806: PPUSH
95807: LD_VAR 0 5
95811: PPUSH
95812: CALL_OW 488
95816: IFFALSE 95896
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
95818: LD_VAR 0 2
95822: PPUSH
95823: CALL_OW 247
95827: PUSH
95828: LD_INT 3
95830: PUSH
95831: LD_INT 2
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: IN
95838: PUSH
95839: LD_VAR 0 1
95843: PPUSH
95844: CALL_OW 255
95848: PPUSH
95849: LD_VAR 0 2
95853: PPUSH
95854: CALL_OW 292
95858: OR
95859: IFFALSE 95877
// ComAttackUnit ( unit , enemy ) else
95861: LD_VAR 0 1
95865: PPUSH
95866: LD_VAR 0 2
95870: PPUSH
95871: CALL_OW 115
95875: GO 95896
// ComAgressiveMove ( unit , x , y ) ;
95877: LD_VAR 0 1
95881: PPUSH
95882: LD_VAR 0 4
95886: PPUSH
95887: LD_VAR 0 5
95891: PPUSH
95892: CALL_OW 114
// end ;
95896: LD_VAR 0 3
95900: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
95901: LD_INT 0
95903: PPUSH
95904: PPUSH
95905: PPUSH
// list := AreaToList ( area , 0 ) ;
95906: LD_ADDR_VAR 0 5
95910: PUSH
95911: LD_VAR 0 1
95915: PPUSH
95916: LD_INT 0
95918: PPUSH
95919: CALL_OW 517
95923: ST_TO_ADDR
// if not list then
95924: LD_VAR 0 5
95928: NOT
95929: IFFALSE 95933
// exit ;
95931: GO 96063
// if all then
95933: LD_VAR 0 2
95937: IFFALSE 96025
// begin for i := 1 to list [ 1 ] do
95939: LD_ADDR_VAR 0 4
95943: PUSH
95944: DOUBLE
95945: LD_INT 1
95947: DEC
95948: ST_TO_ADDR
95949: LD_VAR 0 5
95953: PUSH
95954: LD_INT 1
95956: ARRAY
95957: PUSH
95958: FOR_TO
95959: IFFALSE 96021
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
95961: LD_ADDR_VAR 0 3
95965: PUSH
95966: LD_VAR 0 3
95970: PPUSH
95971: LD_VAR 0 3
95975: PUSH
95976: LD_INT 1
95978: PLUS
95979: PPUSH
95980: LD_VAR 0 5
95984: PUSH
95985: LD_INT 1
95987: ARRAY
95988: PUSH
95989: LD_VAR 0 4
95993: ARRAY
95994: PUSH
95995: LD_VAR 0 5
95999: PUSH
96000: LD_INT 2
96002: ARRAY
96003: PUSH
96004: LD_VAR 0 4
96008: ARRAY
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: PPUSH
96014: CALL_OW 1
96018: ST_TO_ADDR
96019: GO 95958
96021: POP
96022: POP
// exit ;
96023: GO 96063
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
96025: LD_ADDR_VAR 0 3
96029: PUSH
96030: LD_VAR 0 5
96034: PUSH
96035: LD_INT 1
96037: ARRAY
96038: PUSH
96039: LD_INT 1
96041: ARRAY
96042: PUSH
96043: LD_VAR 0 5
96047: PUSH
96048: LD_INT 2
96050: ARRAY
96051: PUSH
96052: LD_INT 1
96054: ARRAY
96055: PUSH
96056: EMPTY
96057: LIST
96058: LIST
96059: PUSH
96060: EMPTY
96061: LIST
96062: ST_TO_ADDR
// end ;
96063: LD_VAR 0 3
96067: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
96068: LD_INT 0
96070: PPUSH
96071: PPUSH
// list := AreaToList ( area , 0 ) ;
96072: LD_ADDR_VAR 0 4
96076: PUSH
96077: LD_VAR 0 1
96081: PPUSH
96082: LD_INT 0
96084: PPUSH
96085: CALL_OW 517
96089: ST_TO_ADDR
// if not list then
96090: LD_VAR 0 4
96094: NOT
96095: IFFALSE 96099
// exit ;
96097: GO 96140
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
96099: LD_ADDR_VAR 0 3
96103: PUSH
96104: LD_VAR 0 4
96108: PUSH
96109: LD_INT 1
96111: ARRAY
96112: PUSH
96113: LD_INT 1
96115: ARRAY
96116: PUSH
96117: LD_VAR 0 4
96121: PUSH
96122: LD_INT 2
96124: ARRAY
96125: PUSH
96126: LD_INT 1
96128: ARRAY
96129: PUSH
96130: LD_VAR 0 2
96134: PUSH
96135: EMPTY
96136: LIST
96137: LIST
96138: LIST
96139: ST_TO_ADDR
// end ;
96140: LD_VAR 0 3
96144: RET
// export function First ( array ) ; begin
96145: LD_INT 0
96147: PPUSH
// if not array then
96148: LD_VAR 0 1
96152: NOT
96153: IFFALSE 96157
// exit ;
96155: GO 96171
// result := array [ 1 ] ;
96157: LD_ADDR_VAR 0 2
96161: PUSH
96162: LD_VAR 0 1
96166: PUSH
96167: LD_INT 1
96169: ARRAY
96170: ST_TO_ADDR
// end ;
96171: LD_VAR 0 2
96175: RET
// export function Last ( array ) ; begin
96176: LD_INT 0
96178: PPUSH
// if not array then
96179: LD_VAR 0 1
96183: NOT
96184: IFFALSE 96188
// exit ;
96186: GO 96204
// result := array [ array ] ;
96188: LD_ADDR_VAR 0 2
96192: PUSH
96193: LD_VAR 0 1
96197: PUSH
96198: LD_VAR 0 1
96202: ARRAY
96203: ST_TO_ADDR
// end ;
96204: LD_VAR 0 2
96208: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
96209: LD_INT 0
96211: PPUSH
96212: PPUSH
// result := [ ] ;
96213: LD_ADDR_VAR 0 5
96217: PUSH
96218: EMPTY
96219: ST_TO_ADDR
// if not array then
96220: LD_VAR 0 1
96224: NOT
96225: IFFALSE 96229
// exit ;
96227: GO 96341
// for i := 1 to array do
96229: LD_ADDR_VAR 0 6
96233: PUSH
96234: DOUBLE
96235: LD_INT 1
96237: DEC
96238: ST_TO_ADDR
96239: LD_VAR 0 1
96243: PUSH
96244: FOR_TO
96245: IFFALSE 96339
// if array [ i ] [ index ] = value then
96247: LD_VAR 0 1
96251: PUSH
96252: LD_VAR 0 6
96256: ARRAY
96257: PUSH
96258: LD_VAR 0 2
96262: ARRAY
96263: PUSH
96264: LD_VAR 0 3
96268: EQUAL
96269: IFFALSE 96337
// begin if indexColumn then
96271: LD_VAR 0 4
96275: IFFALSE 96311
// result := Join ( result , array [ i ] [ indexColumn ] ) else
96277: LD_ADDR_VAR 0 5
96281: PUSH
96282: LD_VAR 0 5
96286: PPUSH
96287: LD_VAR 0 1
96291: PUSH
96292: LD_VAR 0 6
96296: ARRAY
96297: PUSH
96298: LD_VAR 0 4
96302: ARRAY
96303: PPUSH
96304: CALL 91523 0 2
96308: ST_TO_ADDR
96309: GO 96337
// result := Join ( result , array [ i ] ) ;
96311: LD_ADDR_VAR 0 5
96315: PUSH
96316: LD_VAR 0 5
96320: PPUSH
96321: LD_VAR 0 1
96325: PUSH
96326: LD_VAR 0 6
96330: ARRAY
96331: PPUSH
96332: CALL 91523 0 2
96336: ST_TO_ADDR
// end ;
96337: GO 96244
96339: POP
96340: POP
// end ;
96341: LD_VAR 0 5
96345: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
96346: LD_INT 0
96348: PPUSH
// if not vehicles or not parkingPoint then
96349: LD_VAR 0 1
96353: NOT
96354: PUSH
96355: LD_VAR 0 2
96359: NOT
96360: OR
96361: IFFALSE 96365
// exit ;
96363: GO 96463
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
96365: LD_ADDR_VAR 0 1
96369: PUSH
96370: LD_VAR 0 1
96374: PPUSH
96375: LD_INT 50
96377: PUSH
96378: EMPTY
96379: LIST
96380: PUSH
96381: LD_INT 3
96383: PUSH
96384: LD_INT 92
96386: PUSH
96387: LD_VAR 0 2
96391: PUSH
96392: LD_INT 1
96394: ARRAY
96395: PUSH
96396: LD_VAR 0 2
96400: PUSH
96401: LD_INT 2
96403: ARRAY
96404: PUSH
96405: LD_INT 8
96407: PUSH
96408: EMPTY
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: PUSH
96418: EMPTY
96419: LIST
96420: LIST
96421: PPUSH
96422: CALL_OW 72
96426: ST_TO_ADDR
// if not vehicles then
96427: LD_VAR 0 1
96431: NOT
96432: IFFALSE 96436
// exit ;
96434: GO 96463
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
96436: LD_VAR 0 1
96440: PPUSH
96441: LD_VAR 0 2
96445: PUSH
96446: LD_INT 1
96448: ARRAY
96449: PPUSH
96450: LD_VAR 0 2
96454: PUSH
96455: LD_INT 2
96457: ARRAY
96458: PPUSH
96459: CALL_OW 111
// end ;
96463: LD_VAR 0 3
96467: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
96468: LD_INT 0
96470: PPUSH
96471: PPUSH
96472: PPUSH
// if not side or not area then
96473: LD_VAR 0 1
96477: NOT
96478: PUSH
96479: LD_VAR 0 2
96483: NOT
96484: OR
96485: IFFALSE 96489
// exit ;
96487: GO 96608
// tmp := AreaToList ( area , 0 ) ;
96489: LD_ADDR_VAR 0 5
96493: PUSH
96494: LD_VAR 0 2
96498: PPUSH
96499: LD_INT 0
96501: PPUSH
96502: CALL_OW 517
96506: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
96507: LD_ADDR_VAR 0 4
96511: PUSH
96512: DOUBLE
96513: LD_INT 1
96515: DEC
96516: ST_TO_ADDR
96517: LD_VAR 0 5
96521: PUSH
96522: LD_INT 1
96524: ARRAY
96525: PUSH
96526: FOR_TO
96527: IFFALSE 96606
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
96529: LD_VAR 0 5
96533: PUSH
96534: LD_INT 1
96536: ARRAY
96537: PUSH
96538: LD_VAR 0 4
96542: ARRAY
96543: PPUSH
96544: LD_VAR 0 5
96548: PUSH
96549: LD_INT 2
96551: ARRAY
96552: PUSH
96553: LD_VAR 0 4
96557: ARRAY
96558: PPUSH
96559: CALL_OW 351
96563: IFFALSE 96604
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
96565: LD_VAR 0 5
96569: PUSH
96570: LD_INT 1
96572: ARRAY
96573: PUSH
96574: LD_VAR 0 4
96578: ARRAY
96579: PPUSH
96580: LD_VAR 0 5
96584: PUSH
96585: LD_INT 2
96587: ARRAY
96588: PUSH
96589: LD_VAR 0 4
96593: ARRAY
96594: PPUSH
96595: LD_VAR 0 1
96599: PPUSH
96600: CALL_OW 244
// end ;
96604: GO 96526
96606: POP
96607: POP
// end ; end_of_file end_of_file
96608: LD_VAR 0 3
96612: RET
// export globalGameSaveCounter ; every 0 0$1 do
96613: GO 96615
96615: DISABLE
// begin enable ;
96616: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
96617: LD_STRING updateTimer(
96619: PUSH
96620: LD_OWVAR 1
96624: STR
96625: PUSH
96626: LD_STRING );
96628: STR
96629: PPUSH
96630: CALL_OW 559
// end ;
96634: END
// every 0 0$1 do
96635: GO 96637
96637: DISABLE
// begin globalGameSaveCounter := 0 ;
96638: LD_ADDR_EXP 125
96642: PUSH
96643: LD_INT 0
96645: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
96646: LD_STRING setGameSaveCounter(0)
96648: PPUSH
96649: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
96653: LD_STRING initStreamRollete();
96655: PPUSH
96656: CALL_OW 559
// InitStreamMode ;
96660: CALL 98003 0 0
// DefineStreamItems ( false ) ;
96664: LD_INT 0
96666: PPUSH
96667: CALL 98467 0 1
// end ;
96671: END
// export function SOS_MapStart ( ) ; begin
96672: LD_INT 0
96674: PPUSH
// if streamModeActive then
96675: LD_EXP 126
96679: IFFALSE 96688
// DefineStreamItems ( true ) ;
96681: LD_INT 1
96683: PPUSH
96684: CALL 98467 0 1
// UpdateLuaVariables ( ) ;
96688: CALL 96705 0 0
// UpdateFactoryWaypoints ( ) ;
96692: CALL 111469 0 0
// UpdateWarehouseGatheringPoints ( ) ;
96696: CALL 111721 0 0
// end ;
96700: LD_VAR 0 1
96704: RET
// function UpdateLuaVariables ( ) ; begin
96705: LD_INT 0
96707: PPUSH
// if globalGameSaveCounter then
96708: LD_EXP 125
96712: IFFALSE 96746
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
96714: LD_ADDR_EXP 125
96718: PUSH
96719: LD_EXP 125
96723: PPUSH
96724: CALL 92884 0 1
96728: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96729: LD_STRING setGameSaveCounter(
96731: PUSH
96732: LD_EXP 125
96736: STR
96737: PUSH
96738: LD_STRING )
96740: STR
96741: PPUSH
96742: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
96746: LD_STRING setGameDifficulty(
96748: PUSH
96749: LD_OWVAR 67
96753: STR
96754: PUSH
96755: LD_STRING )
96757: STR
96758: PPUSH
96759: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
96763: LD_STRING displayDifficulty(
96765: PUSH
96766: LD_OWVAR 67
96770: STR
96771: PUSH
96772: LD_STRING )
96774: STR
96775: PPUSH
96776: CALL_OW 559
// end ;
96780: LD_VAR 0 1
96784: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96785: LD_INT 0
96787: PPUSH
// if p2 = stream_mode then
96788: LD_VAR 0 2
96792: PUSH
96793: LD_INT 100
96795: EQUAL
96796: IFFALSE 97799
// begin if not StreamModeActive then
96798: LD_EXP 126
96802: NOT
96803: IFFALSE 96813
// StreamModeActive := true ;
96805: LD_ADDR_EXP 126
96809: PUSH
96810: LD_INT 1
96812: ST_TO_ADDR
// if p3 = 0 then
96813: LD_VAR 0 3
96817: PUSH
96818: LD_INT 0
96820: EQUAL
96821: IFFALSE 96827
// InitStreamMode ;
96823: CALL 98003 0 0
// if p3 = 1 then
96827: LD_VAR 0 3
96831: PUSH
96832: LD_INT 1
96834: EQUAL
96835: IFFALSE 96845
// sRocket := true ;
96837: LD_ADDR_EXP 131
96841: PUSH
96842: LD_INT 1
96844: ST_TO_ADDR
// if p3 = 2 then
96845: LD_VAR 0 3
96849: PUSH
96850: LD_INT 2
96852: EQUAL
96853: IFFALSE 96863
// sSpeed := true ;
96855: LD_ADDR_EXP 130
96859: PUSH
96860: LD_INT 1
96862: ST_TO_ADDR
// if p3 = 3 then
96863: LD_VAR 0 3
96867: PUSH
96868: LD_INT 3
96870: EQUAL
96871: IFFALSE 96881
// sEngine := true ;
96873: LD_ADDR_EXP 132
96877: PUSH
96878: LD_INT 1
96880: ST_TO_ADDR
// if p3 = 4 then
96881: LD_VAR 0 3
96885: PUSH
96886: LD_INT 4
96888: EQUAL
96889: IFFALSE 96899
// sSpec := true ;
96891: LD_ADDR_EXP 129
96895: PUSH
96896: LD_INT 1
96898: ST_TO_ADDR
// if p3 = 5 then
96899: LD_VAR 0 3
96903: PUSH
96904: LD_INT 5
96906: EQUAL
96907: IFFALSE 96917
// sLevel := true ;
96909: LD_ADDR_EXP 133
96913: PUSH
96914: LD_INT 1
96916: ST_TO_ADDR
// if p3 = 6 then
96917: LD_VAR 0 3
96921: PUSH
96922: LD_INT 6
96924: EQUAL
96925: IFFALSE 96935
// sArmoury := true ;
96927: LD_ADDR_EXP 134
96931: PUSH
96932: LD_INT 1
96934: ST_TO_ADDR
// if p3 = 7 then
96935: LD_VAR 0 3
96939: PUSH
96940: LD_INT 7
96942: EQUAL
96943: IFFALSE 96953
// sRadar := true ;
96945: LD_ADDR_EXP 135
96949: PUSH
96950: LD_INT 1
96952: ST_TO_ADDR
// if p3 = 8 then
96953: LD_VAR 0 3
96957: PUSH
96958: LD_INT 8
96960: EQUAL
96961: IFFALSE 96971
// sBunker := true ;
96963: LD_ADDR_EXP 136
96967: PUSH
96968: LD_INT 1
96970: ST_TO_ADDR
// if p3 = 9 then
96971: LD_VAR 0 3
96975: PUSH
96976: LD_INT 9
96978: EQUAL
96979: IFFALSE 96989
// sHack := true ;
96981: LD_ADDR_EXP 137
96985: PUSH
96986: LD_INT 1
96988: ST_TO_ADDR
// if p3 = 10 then
96989: LD_VAR 0 3
96993: PUSH
96994: LD_INT 10
96996: EQUAL
96997: IFFALSE 97007
// sFire := true ;
96999: LD_ADDR_EXP 138
97003: PUSH
97004: LD_INT 1
97006: ST_TO_ADDR
// if p3 = 11 then
97007: LD_VAR 0 3
97011: PUSH
97012: LD_INT 11
97014: EQUAL
97015: IFFALSE 97025
// sRefresh := true ;
97017: LD_ADDR_EXP 139
97021: PUSH
97022: LD_INT 1
97024: ST_TO_ADDR
// if p3 = 12 then
97025: LD_VAR 0 3
97029: PUSH
97030: LD_INT 12
97032: EQUAL
97033: IFFALSE 97043
// sExp := true ;
97035: LD_ADDR_EXP 140
97039: PUSH
97040: LD_INT 1
97042: ST_TO_ADDR
// if p3 = 13 then
97043: LD_VAR 0 3
97047: PUSH
97048: LD_INT 13
97050: EQUAL
97051: IFFALSE 97061
// sDepot := true ;
97053: LD_ADDR_EXP 141
97057: PUSH
97058: LD_INT 1
97060: ST_TO_ADDR
// if p3 = 14 then
97061: LD_VAR 0 3
97065: PUSH
97066: LD_INT 14
97068: EQUAL
97069: IFFALSE 97079
// sFlag := true ;
97071: LD_ADDR_EXP 142
97075: PUSH
97076: LD_INT 1
97078: ST_TO_ADDR
// if p3 = 15 then
97079: LD_VAR 0 3
97083: PUSH
97084: LD_INT 15
97086: EQUAL
97087: IFFALSE 97097
// sKamikadze := true ;
97089: LD_ADDR_EXP 150
97093: PUSH
97094: LD_INT 1
97096: ST_TO_ADDR
// if p3 = 16 then
97097: LD_VAR 0 3
97101: PUSH
97102: LD_INT 16
97104: EQUAL
97105: IFFALSE 97115
// sTroll := true ;
97107: LD_ADDR_EXP 151
97111: PUSH
97112: LD_INT 1
97114: ST_TO_ADDR
// if p3 = 17 then
97115: LD_VAR 0 3
97119: PUSH
97120: LD_INT 17
97122: EQUAL
97123: IFFALSE 97133
// sSlow := true ;
97125: LD_ADDR_EXP 152
97129: PUSH
97130: LD_INT 1
97132: ST_TO_ADDR
// if p3 = 18 then
97133: LD_VAR 0 3
97137: PUSH
97138: LD_INT 18
97140: EQUAL
97141: IFFALSE 97151
// sLack := true ;
97143: LD_ADDR_EXP 153
97147: PUSH
97148: LD_INT 1
97150: ST_TO_ADDR
// if p3 = 19 then
97151: LD_VAR 0 3
97155: PUSH
97156: LD_INT 19
97158: EQUAL
97159: IFFALSE 97169
// sTank := true ;
97161: LD_ADDR_EXP 155
97165: PUSH
97166: LD_INT 1
97168: ST_TO_ADDR
// if p3 = 20 then
97169: LD_VAR 0 3
97173: PUSH
97174: LD_INT 20
97176: EQUAL
97177: IFFALSE 97187
// sRemote := true ;
97179: LD_ADDR_EXP 156
97183: PUSH
97184: LD_INT 1
97186: ST_TO_ADDR
// if p3 = 21 then
97187: LD_VAR 0 3
97191: PUSH
97192: LD_INT 21
97194: EQUAL
97195: IFFALSE 97205
// sPowell := true ;
97197: LD_ADDR_EXP 157
97201: PUSH
97202: LD_INT 1
97204: ST_TO_ADDR
// if p3 = 22 then
97205: LD_VAR 0 3
97209: PUSH
97210: LD_INT 22
97212: EQUAL
97213: IFFALSE 97223
// sTeleport := true ;
97215: LD_ADDR_EXP 160
97219: PUSH
97220: LD_INT 1
97222: ST_TO_ADDR
// if p3 = 23 then
97223: LD_VAR 0 3
97227: PUSH
97228: LD_INT 23
97230: EQUAL
97231: IFFALSE 97241
// sOilTower := true ;
97233: LD_ADDR_EXP 162
97237: PUSH
97238: LD_INT 1
97240: ST_TO_ADDR
// if p3 = 24 then
97241: LD_VAR 0 3
97245: PUSH
97246: LD_INT 24
97248: EQUAL
97249: IFFALSE 97259
// sShovel := true ;
97251: LD_ADDR_EXP 163
97255: PUSH
97256: LD_INT 1
97258: ST_TO_ADDR
// if p3 = 25 then
97259: LD_VAR 0 3
97263: PUSH
97264: LD_INT 25
97266: EQUAL
97267: IFFALSE 97277
// sSheik := true ;
97269: LD_ADDR_EXP 164
97273: PUSH
97274: LD_INT 1
97276: ST_TO_ADDR
// if p3 = 26 then
97277: LD_VAR 0 3
97281: PUSH
97282: LD_INT 26
97284: EQUAL
97285: IFFALSE 97295
// sEarthquake := true ;
97287: LD_ADDR_EXP 166
97291: PUSH
97292: LD_INT 1
97294: ST_TO_ADDR
// if p3 = 27 then
97295: LD_VAR 0 3
97299: PUSH
97300: LD_INT 27
97302: EQUAL
97303: IFFALSE 97313
// sAI := true ;
97305: LD_ADDR_EXP 167
97309: PUSH
97310: LD_INT 1
97312: ST_TO_ADDR
// if p3 = 28 then
97313: LD_VAR 0 3
97317: PUSH
97318: LD_INT 28
97320: EQUAL
97321: IFFALSE 97331
// sCargo := true ;
97323: LD_ADDR_EXP 170
97327: PUSH
97328: LD_INT 1
97330: ST_TO_ADDR
// if p3 = 29 then
97331: LD_VAR 0 3
97335: PUSH
97336: LD_INT 29
97338: EQUAL
97339: IFFALSE 97349
// sDLaser := true ;
97341: LD_ADDR_EXP 171
97345: PUSH
97346: LD_INT 1
97348: ST_TO_ADDR
// if p3 = 30 then
97349: LD_VAR 0 3
97353: PUSH
97354: LD_INT 30
97356: EQUAL
97357: IFFALSE 97367
// sExchange := true ;
97359: LD_ADDR_EXP 172
97363: PUSH
97364: LD_INT 1
97366: ST_TO_ADDR
// if p3 = 31 then
97367: LD_VAR 0 3
97371: PUSH
97372: LD_INT 31
97374: EQUAL
97375: IFFALSE 97385
// sFac := true ;
97377: LD_ADDR_EXP 173
97381: PUSH
97382: LD_INT 1
97384: ST_TO_ADDR
// if p3 = 32 then
97385: LD_VAR 0 3
97389: PUSH
97390: LD_INT 32
97392: EQUAL
97393: IFFALSE 97403
// sPower := true ;
97395: LD_ADDR_EXP 174
97399: PUSH
97400: LD_INT 1
97402: ST_TO_ADDR
// if p3 = 33 then
97403: LD_VAR 0 3
97407: PUSH
97408: LD_INT 33
97410: EQUAL
97411: IFFALSE 97421
// sRandom := true ;
97413: LD_ADDR_EXP 175
97417: PUSH
97418: LD_INT 1
97420: ST_TO_ADDR
// if p3 = 34 then
97421: LD_VAR 0 3
97425: PUSH
97426: LD_INT 34
97428: EQUAL
97429: IFFALSE 97439
// sShield := true ;
97431: LD_ADDR_EXP 176
97435: PUSH
97436: LD_INT 1
97438: ST_TO_ADDR
// if p3 = 35 then
97439: LD_VAR 0 3
97443: PUSH
97444: LD_INT 35
97446: EQUAL
97447: IFFALSE 97457
// sTime := true ;
97449: LD_ADDR_EXP 177
97453: PUSH
97454: LD_INT 1
97456: ST_TO_ADDR
// if p3 = 36 then
97457: LD_VAR 0 3
97461: PUSH
97462: LD_INT 36
97464: EQUAL
97465: IFFALSE 97475
// sTools := true ;
97467: LD_ADDR_EXP 178
97471: PUSH
97472: LD_INT 1
97474: ST_TO_ADDR
// if p3 = 101 then
97475: LD_VAR 0 3
97479: PUSH
97480: LD_INT 101
97482: EQUAL
97483: IFFALSE 97493
// sSold := true ;
97485: LD_ADDR_EXP 143
97489: PUSH
97490: LD_INT 1
97492: ST_TO_ADDR
// if p3 = 102 then
97493: LD_VAR 0 3
97497: PUSH
97498: LD_INT 102
97500: EQUAL
97501: IFFALSE 97511
// sDiff := true ;
97503: LD_ADDR_EXP 144
97507: PUSH
97508: LD_INT 1
97510: ST_TO_ADDR
// if p3 = 103 then
97511: LD_VAR 0 3
97515: PUSH
97516: LD_INT 103
97518: EQUAL
97519: IFFALSE 97529
// sFog := true ;
97521: LD_ADDR_EXP 147
97525: PUSH
97526: LD_INT 1
97528: ST_TO_ADDR
// if p3 = 104 then
97529: LD_VAR 0 3
97533: PUSH
97534: LD_INT 104
97536: EQUAL
97537: IFFALSE 97547
// sReset := true ;
97539: LD_ADDR_EXP 148
97543: PUSH
97544: LD_INT 1
97546: ST_TO_ADDR
// if p3 = 105 then
97547: LD_VAR 0 3
97551: PUSH
97552: LD_INT 105
97554: EQUAL
97555: IFFALSE 97565
// sSun := true ;
97557: LD_ADDR_EXP 149
97561: PUSH
97562: LD_INT 1
97564: ST_TO_ADDR
// if p3 = 106 then
97565: LD_VAR 0 3
97569: PUSH
97570: LD_INT 106
97572: EQUAL
97573: IFFALSE 97583
// sTiger := true ;
97575: LD_ADDR_EXP 145
97579: PUSH
97580: LD_INT 1
97582: ST_TO_ADDR
// if p3 = 107 then
97583: LD_VAR 0 3
97587: PUSH
97588: LD_INT 107
97590: EQUAL
97591: IFFALSE 97601
// sBomb := true ;
97593: LD_ADDR_EXP 146
97597: PUSH
97598: LD_INT 1
97600: ST_TO_ADDR
// if p3 = 108 then
97601: LD_VAR 0 3
97605: PUSH
97606: LD_INT 108
97608: EQUAL
97609: IFFALSE 97619
// sWound := true ;
97611: LD_ADDR_EXP 154
97615: PUSH
97616: LD_INT 1
97618: ST_TO_ADDR
// if p3 = 109 then
97619: LD_VAR 0 3
97623: PUSH
97624: LD_INT 109
97626: EQUAL
97627: IFFALSE 97637
// sBetray := true ;
97629: LD_ADDR_EXP 158
97633: PUSH
97634: LD_INT 1
97636: ST_TO_ADDR
// if p3 = 110 then
97637: LD_VAR 0 3
97641: PUSH
97642: LD_INT 110
97644: EQUAL
97645: IFFALSE 97655
// sContamin := true ;
97647: LD_ADDR_EXP 159
97651: PUSH
97652: LD_INT 1
97654: ST_TO_ADDR
// if p3 = 111 then
97655: LD_VAR 0 3
97659: PUSH
97660: LD_INT 111
97662: EQUAL
97663: IFFALSE 97673
// sOil := true ;
97665: LD_ADDR_EXP 161
97669: PUSH
97670: LD_INT 1
97672: ST_TO_ADDR
// if p3 = 112 then
97673: LD_VAR 0 3
97677: PUSH
97678: LD_INT 112
97680: EQUAL
97681: IFFALSE 97691
// sStu := true ;
97683: LD_ADDR_EXP 165
97687: PUSH
97688: LD_INT 1
97690: ST_TO_ADDR
// if p3 = 113 then
97691: LD_VAR 0 3
97695: PUSH
97696: LD_INT 113
97698: EQUAL
97699: IFFALSE 97709
// sBazooka := true ;
97701: LD_ADDR_EXP 168
97705: PUSH
97706: LD_INT 1
97708: ST_TO_ADDR
// if p3 = 114 then
97709: LD_VAR 0 3
97713: PUSH
97714: LD_INT 114
97716: EQUAL
97717: IFFALSE 97727
// sMortar := true ;
97719: LD_ADDR_EXP 169
97723: PUSH
97724: LD_INT 1
97726: ST_TO_ADDR
// if p3 = 115 then
97727: LD_VAR 0 3
97731: PUSH
97732: LD_INT 115
97734: EQUAL
97735: IFFALSE 97745
// sRanger := true ;
97737: LD_ADDR_EXP 179
97741: PUSH
97742: LD_INT 1
97744: ST_TO_ADDR
// if p3 = 116 then
97745: LD_VAR 0 3
97749: PUSH
97750: LD_INT 116
97752: EQUAL
97753: IFFALSE 97763
// sComputer := true ;
97755: LD_ADDR_EXP 180
97759: PUSH
97760: LD_INT 1
97762: ST_TO_ADDR
// if p3 = 117 then
97763: LD_VAR 0 3
97767: PUSH
97768: LD_INT 117
97770: EQUAL
97771: IFFALSE 97781
// s30 := true ;
97773: LD_ADDR_EXP 181
97777: PUSH
97778: LD_INT 1
97780: ST_TO_ADDR
// if p3 = 118 then
97781: LD_VAR 0 3
97785: PUSH
97786: LD_INT 118
97788: EQUAL
97789: IFFALSE 97799
// s60 := true ;
97791: LD_ADDR_EXP 182
97795: PUSH
97796: LD_INT 1
97798: ST_TO_ADDR
// end ; if p2 = hack_mode then
97799: LD_VAR 0 2
97803: PUSH
97804: LD_INT 101
97806: EQUAL
97807: IFFALSE 97935
// begin case p3 of 1 :
97809: LD_VAR 0 3
97813: PUSH
97814: LD_INT 1
97816: DOUBLE
97817: EQUAL
97818: IFTRUE 97822
97820: GO 97829
97822: POP
// hHackUnlimitedResources ; 2 :
97823: CALL 110082 0 0
97827: GO 97935
97829: LD_INT 2
97831: DOUBLE
97832: EQUAL
97833: IFTRUE 97837
97835: GO 97844
97837: POP
// hHackSetLevel10 ; 3 :
97838: CALL 110215 0 0
97842: GO 97935
97844: LD_INT 3
97846: DOUBLE
97847: EQUAL
97848: IFTRUE 97852
97850: GO 97859
97852: POP
// hHackSetLevel10YourUnits ; 4 :
97853: CALL 110300 0 0
97857: GO 97935
97859: LD_INT 4
97861: DOUBLE
97862: EQUAL
97863: IFTRUE 97867
97865: GO 97874
97867: POP
// hHackInvincible ; 5 :
97868: CALL 110748 0 0
97872: GO 97935
97874: LD_INT 5
97876: DOUBLE
97877: EQUAL
97878: IFTRUE 97882
97880: GO 97889
97882: POP
// hHackInvisible ; 6 :
97883: CALL 110859 0 0
97887: GO 97935
97889: LD_INT 6
97891: DOUBLE
97892: EQUAL
97893: IFTRUE 97897
97895: GO 97904
97897: POP
// hHackChangeYourSide ; 7 :
97898: CALL 110916 0 0
97902: GO 97935
97904: LD_INT 7
97906: DOUBLE
97907: EQUAL
97908: IFTRUE 97912
97910: GO 97919
97912: POP
// hHackChangeUnitSide ; 8 :
97913: CALL 110958 0 0
97917: GO 97935
97919: LD_INT 8
97921: DOUBLE
97922: EQUAL
97923: IFTRUE 97927
97925: GO 97934
97927: POP
// hHackFog ; end ;
97928: CALL 111059 0 0
97932: GO 97935
97934: POP
// end ; if p2 = game_save_mode then
97935: LD_VAR 0 2
97939: PUSH
97940: LD_INT 102
97942: EQUAL
97943: IFFALSE 97998
// begin if p3 = 1 then
97945: LD_VAR 0 3
97949: PUSH
97950: LD_INT 1
97952: EQUAL
97953: IFFALSE 97965
// globalGameSaveCounter := p4 ;
97955: LD_ADDR_EXP 125
97959: PUSH
97960: LD_VAR 0 4
97964: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
97965: LD_VAR 0 3
97969: PUSH
97970: LD_INT 2
97972: EQUAL
97973: PUSH
97974: LD_EXP 125
97978: AND
97979: IFFALSE 97998
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
97981: LD_STRING setGameSaveCounter(
97983: PUSH
97984: LD_EXP 125
97988: STR
97989: PUSH
97990: LD_STRING )
97992: STR
97993: PPUSH
97994: CALL_OW 559
// end ; end ;
97998: LD_VAR 0 7
98002: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
98003: LD_INT 0
98005: PPUSH
// streamModeActive := false ;
98006: LD_ADDR_EXP 126
98010: PUSH
98011: LD_INT 0
98013: ST_TO_ADDR
// normalCounter := 36 ;
98014: LD_ADDR_EXP 127
98018: PUSH
98019: LD_INT 36
98021: ST_TO_ADDR
// hardcoreCounter := 18 ;
98022: LD_ADDR_EXP 128
98026: PUSH
98027: LD_INT 18
98029: ST_TO_ADDR
// sRocket := false ;
98030: LD_ADDR_EXP 131
98034: PUSH
98035: LD_INT 0
98037: ST_TO_ADDR
// sSpeed := false ;
98038: LD_ADDR_EXP 130
98042: PUSH
98043: LD_INT 0
98045: ST_TO_ADDR
// sEngine := false ;
98046: LD_ADDR_EXP 132
98050: PUSH
98051: LD_INT 0
98053: ST_TO_ADDR
// sSpec := false ;
98054: LD_ADDR_EXP 129
98058: PUSH
98059: LD_INT 0
98061: ST_TO_ADDR
// sLevel := false ;
98062: LD_ADDR_EXP 133
98066: PUSH
98067: LD_INT 0
98069: ST_TO_ADDR
// sArmoury := false ;
98070: LD_ADDR_EXP 134
98074: PUSH
98075: LD_INT 0
98077: ST_TO_ADDR
// sRadar := false ;
98078: LD_ADDR_EXP 135
98082: PUSH
98083: LD_INT 0
98085: ST_TO_ADDR
// sBunker := false ;
98086: LD_ADDR_EXP 136
98090: PUSH
98091: LD_INT 0
98093: ST_TO_ADDR
// sHack := false ;
98094: LD_ADDR_EXP 137
98098: PUSH
98099: LD_INT 0
98101: ST_TO_ADDR
// sFire := false ;
98102: LD_ADDR_EXP 138
98106: PUSH
98107: LD_INT 0
98109: ST_TO_ADDR
// sRefresh := false ;
98110: LD_ADDR_EXP 139
98114: PUSH
98115: LD_INT 0
98117: ST_TO_ADDR
// sExp := false ;
98118: LD_ADDR_EXP 140
98122: PUSH
98123: LD_INT 0
98125: ST_TO_ADDR
// sDepot := false ;
98126: LD_ADDR_EXP 141
98130: PUSH
98131: LD_INT 0
98133: ST_TO_ADDR
// sFlag := false ;
98134: LD_ADDR_EXP 142
98138: PUSH
98139: LD_INT 0
98141: ST_TO_ADDR
// sKamikadze := false ;
98142: LD_ADDR_EXP 150
98146: PUSH
98147: LD_INT 0
98149: ST_TO_ADDR
// sTroll := false ;
98150: LD_ADDR_EXP 151
98154: PUSH
98155: LD_INT 0
98157: ST_TO_ADDR
// sSlow := false ;
98158: LD_ADDR_EXP 152
98162: PUSH
98163: LD_INT 0
98165: ST_TO_ADDR
// sLack := false ;
98166: LD_ADDR_EXP 153
98170: PUSH
98171: LD_INT 0
98173: ST_TO_ADDR
// sTank := false ;
98174: LD_ADDR_EXP 155
98178: PUSH
98179: LD_INT 0
98181: ST_TO_ADDR
// sRemote := false ;
98182: LD_ADDR_EXP 156
98186: PUSH
98187: LD_INT 0
98189: ST_TO_ADDR
// sPowell := false ;
98190: LD_ADDR_EXP 157
98194: PUSH
98195: LD_INT 0
98197: ST_TO_ADDR
// sTeleport := false ;
98198: LD_ADDR_EXP 160
98202: PUSH
98203: LD_INT 0
98205: ST_TO_ADDR
// sOilTower := false ;
98206: LD_ADDR_EXP 162
98210: PUSH
98211: LD_INT 0
98213: ST_TO_ADDR
// sShovel := false ;
98214: LD_ADDR_EXP 163
98218: PUSH
98219: LD_INT 0
98221: ST_TO_ADDR
// sSheik := false ;
98222: LD_ADDR_EXP 164
98226: PUSH
98227: LD_INT 0
98229: ST_TO_ADDR
// sEarthquake := false ;
98230: LD_ADDR_EXP 166
98234: PUSH
98235: LD_INT 0
98237: ST_TO_ADDR
// sAI := false ;
98238: LD_ADDR_EXP 167
98242: PUSH
98243: LD_INT 0
98245: ST_TO_ADDR
// sCargo := false ;
98246: LD_ADDR_EXP 170
98250: PUSH
98251: LD_INT 0
98253: ST_TO_ADDR
// sDLaser := false ;
98254: LD_ADDR_EXP 171
98258: PUSH
98259: LD_INT 0
98261: ST_TO_ADDR
// sExchange := false ;
98262: LD_ADDR_EXP 172
98266: PUSH
98267: LD_INT 0
98269: ST_TO_ADDR
// sFac := false ;
98270: LD_ADDR_EXP 173
98274: PUSH
98275: LD_INT 0
98277: ST_TO_ADDR
// sPower := false ;
98278: LD_ADDR_EXP 174
98282: PUSH
98283: LD_INT 0
98285: ST_TO_ADDR
// sRandom := false ;
98286: LD_ADDR_EXP 175
98290: PUSH
98291: LD_INT 0
98293: ST_TO_ADDR
// sShield := false ;
98294: LD_ADDR_EXP 176
98298: PUSH
98299: LD_INT 0
98301: ST_TO_ADDR
// sTime := false ;
98302: LD_ADDR_EXP 177
98306: PUSH
98307: LD_INT 0
98309: ST_TO_ADDR
// sTools := false ;
98310: LD_ADDR_EXP 178
98314: PUSH
98315: LD_INT 0
98317: ST_TO_ADDR
// sSold := false ;
98318: LD_ADDR_EXP 143
98322: PUSH
98323: LD_INT 0
98325: ST_TO_ADDR
// sDiff := false ;
98326: LD_ADDR_EXP 144
98330: PUSH
98331: LD_INT 0
98333: ST_TO_ADDR
// sFog := false ;
98334: LD_ADDR_EXP 147
98338: PUSH
98339: LD_INT 0
98341: ST_TO_ADDR
// sReset := false ;
98342: LD_ADDR_EXP 148
98346: PUSH
98347: LD_INT 0
98349: ST_TO_ADDR
// sSun := false ;
98350: LD_ADDR_EXP 149
98354: PUSH
98355: LD_INT 0
98357: ST_TO_ADDR
// sTiger := false ;
98358: LD_ADDR_EXP 145
98362: PUSH
98363: LD_INT 0
98365: ST_TO_ADDR
// sBomb := false ;
98366: LD_ADDR_EXP 146
98370: PUSH
98371: LD_INT 0
98373: ST_TO_ADDR
// sWound := false ;
98374: LD_ADDR_EXP 154
98378: PUSH
98379: LD_INT 0
98381: ST_TO_ADDR
// sBetray := false ;
98382: LD_ADDR_EXP 158
98386: PUSH
98387: LD_INT 0
98389: ST_TO_ADDR
// sContamin := false ;
98390: LD_ADDR_EXP 159
98394: PUSH
98395: LD_INT 0
98397: ST_TO_ADDR
// sOil := false ;
98398: LD_ADDR_EXP 161
98402: PUSH
98403: LD_INT 0
98405: ST_TO_ADDR
// sStu := false ;
98406: LD_ADDR_EXP 165
98410: PUSH
98411: LD_INT 0
98413: ST_TO_ADDR
// sBazooka := false ;
98414: LD_ADDR_EXP 168
98418: PUSH
98419: LD_INT 0
98421: ST_TO_ADDR
// sMortar := false ;
98422: LD_ADDR_EXP 169
98426: PUSH
98427: LD_INT 0
98429: ST_TO_ADDR
// sRanger := false ;
98430: LD_ADDR_EXP 179
98434: PUSH
98435: LD_INT 0
98437: ST_TO_ADDR
// sComputer := false ;
98438: LD_ADDR_EXP 180
98442: PUSH
98443: LD_INT 0
98445: ST_TO_ADDR
// s30 := false ;
98446: LD_ADDR_EXP 181
98450: PUSH
98451: LD_INT 0
98453: ST_TO_ADDR
// s60 := false ;
98454: LD_ADDR_EXP 182
98458: PUSH
98459: LD_INT 0
98461: ST_TO_ADDR
// end ;
98462: LD_VAR 0 1
98466: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
98467: LD_INT 0
98469: PPUSH
98470: PPUSH
98471: PPUSH
98472: PPUSH
98473: PPUSH
98474: PPUSH
98475: PPUSH
// result := [ ] ;
98476: LD_ADDR_VAR 0 2
98480: PUSH
98481: EMPTY
98482: ST_TO_ADDR
// if campaign_id = 1 then
98483: LD_OWVAR 69
98487: PUSH
98488: LD_INT 1
98490: EQUAL
98491: IFFALSE 101657
// begin case mission_number of 1 :
98493: LD_OWVAR 70
98497: PUSH
98498: LD_INT 1
98500: DOUBLE
98501: EQUAL
98502: IFTRUE 98506
98504: GO 98582
98506: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
98507: LD_ADDR_VAR 0 2
98511: PUSH
98512: LD_INT 2
98514: PUSH
98515: LD_INT 4
98517: PUSH
98518: LD_INT 11
98520: PUSH
98521: LD_INT 12
98523: PUSH
98524: LD_INT 15
98526: PUSH
98527: LD_INT 16
98529: PUSH
98530: LD_INT 22
98532: PUSH
98533: LD_INT 23
98535: PUSH
98536: LD_INT 26
98538: PUSH
98539: EMPTY
98540: LIST
98541: LIST
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: PUSH
98550: LD_INT 101
98552: PUSH
98553: LD_INT 102
98555: PUSH
98556: LD_INT 106
98558: PUSH
98559: LD_INT 116
98561: PUSH
98562: LD_INT 117
98564: PUSH
98565: LD_INT 118
98567: PUSH
98568: EMPTY
98569: LIST
98570: LIST
98571: LIST
98572: LIST
98573: LIST
98574: LIST
98575: PUSH
98576: EMPTY
98577: LIST
98578: LIST
98579: ST_TO_ADDR
98580: GO 101655
98582: LD_INT 2
98584: DOUBLE
98585: EQUAL
98586: IFTRUE 98590
98588: GO 98674
98590: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
98591: LD_ADDR_VAR 0 2
98595: PUSH
98596: LD_INT 2
98598: PUSH
98599: LD_INT 4
98601: PUSH
98602: LD_INT 11
98604: PUSH
98605: LD_INT 12
98607: PUSH
98608: LD_INT 15
98610: PUSH
98611: LD_INT 16
98613: PUSH
98614: LD_INT 22
98616: PUSH
98617: LD_INT 23
98619: PUSH
98620: LD_INT 26
98622: PUSH
98623: EMPTY
98624: LIST
98625: LIST
98626: LIST
98627: LIST
98628: LIST
98629: LIST
98630: LIST
98631: LIST
98632: LIST
98633: PUSH
98634: LD_INT 101
98636: PUSH
98637: LD_INT 102
98639: PUSH
98640: LD_INT 105
98642: PUSH
98643: LD_INT 106
98645: PUSH
98646: LD_INT 108
98648: PUSH
98649: LD_INT 116
98651: PUSH
98652: LD_INT 117
98654: PUSH
98655: LD_INT 118
98657: PUSH
98658: EMPTY
98659: LIST
98660: LIST
98661: LIST
98662: LIST
98663: LIST
98664: LIST
98665: LIST
98666: LIST
98667: PUSH
98668: EMPTY
98669: LIST
98670: LIST
98671: ST_TO_ADDR
98672: GO 101655
98674: LD_INT 3
98676: DOUBLE
98677: EQUAL
98678: IFTRUE 98682
98680: GO 98770
98682: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
98683: LD_ADDR_VAR 0 2
98687: PUSH
98688: LD_INT 2
98690: PUSH
98691: LD_INT 4
98693: PUSH
98694: LD_INT 5
98696: PUSH
98697: LD_INT 11
98699: PUSH
98700: LD_INT 12
98702: PUSH
98703: LD_INT 15
98705: PUSH
98706: LD_INT 16
98708: PUSH
98709: LD_INT 22
98711: PUSH
98712: LD_INT 26
98714: PUSH
98715: LD_INT 36
98717: PUSH
98718: EMPTY
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: PUSH
98730: LD_INT 101
98732: PUSH
98733: LD_INT 102
98735: PUSH
98736: LD_INT 105
98738: PUSH
98739: LD_INT 106
98741: PUSH
98742: LD_INT 108
98744: PUSH
98745: LD_INT 116
98747: PUSH
98748: LD_INT 117
98750: PUSH
98751: LD_INT 118
98753: PUSH
98754: EMPTY
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: LIST
98762: LIST
98763: PUSH
98764: EMPTY
98765: LIST
98766: LIST
98767: ST_TO_ADDR
98768: GO 101655
98770: LD_INT 4
98772: DOUBLE
98773: EQUAL
98774: IFTRUE 98778
98776: GO 98874
98778: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
98779: LD_ADDR_VAR 0 2
98783: PUSH
98784: LD_INT 2
98786: PUSH
98787: LD_INT 4
98789: PUSH
98790: LD_INT 5
98792: PUSH
98793: LD_INT 8
98795: PUSH
98796: LD_INT 11
98798: PUSH
98799: LD_INT 12
98801: PUSH
98802: LD_INT 15
98804: PUSH
98805: LD_INT 16
98807: PUSH
98808: LD_INT 22
98810: PUSH
98811: LD_INT 23
98813: PUSH
98814: LD_INT 26
98816: PUSH
98817: LD_INT 36
98819: PUSH
98820: EMPTY
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: LIST
98828: LIST
98829: LIST
98830: LIST
98831: LIST
98832: LIST
98833: PUSH
98834: LD_INT 101
98836: PUSH
98837: LD_INT 102
98839: PUSH
98840: LD_INT 105
98842: PUSH
98843: LD_INT 106
98845: PUSH
98846: LD_INT 108
98848: PUSH
98849: LD_INT 116
98851: PUSH
98852: LD_INT 117
98854: PUSH
98855: LD_INT 118
98857: PUSH
98858: EMPTY
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: LIST
98864: LIST
98865: LIST
98866: LIST
98867: PUSH
98868: EMPTY
98869: LIST
98870: LIST
98871: ST_TO_ADDR
98872: GO 101655
98874: LD_INT 5
98876: DOUBLE
98877: EQUAL
98878: IFTRUE 98882
98880: GO 98994
98882: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
98883: LD_ADDR_VAR 0 2
98887: PUSH
98888: LD_INT 2
98890: PUSH
98891: LD_INT 4
98893: PUSH
98894: LD_INT 5
98896: PUSH
98897: LD_INT 6
98899: PUSH
98900: LD_INT 8
98902: PUSH
98903: LD_INT 11
98905: PUSH
98906: LD_INT 12
98908: PUSH
98909: LD_INT 15
98911: PUSH
98912: LD_INT 16
98914: PUSH
98915: LD_INT 22
98917: PUSH
98918: LD_INT 23
98920: PUSH
98921: LD_INT 25
98923: PUSH
98924: LD_INT 26
98926: PUSH
98927: LD_INT 36
98929: PUSH
98930: EMPTY
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: PUSH
98946: LD_INT 101
98948: PUSH
98949: LD_INT 102
98951: PUSH
98952: LD_INT 105
98954: PUSH
98955: LD_INT 106
98957: PUSH
98958: LD_INT 108
98960: PUSH
98961: LD_INT 109
98963: PUSH
98964: LD_INT 112
98966: PUSH
98967: LD_INT 116
98969: PUSH
98970: LD_INT 117
98972: PUSH
98973: LD_INT 118
98975: PUSH
98976: EMPTY
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: PUSH
98988: EMPTY
98989: LIST
98990: LIST
98991: ST_TO_ADDR
98992: GO 101655
98994: LD_INT 6
98996: DOUBLE
98997: EQUAL
98998: IFTRUE 99002
99000: GO 99134
99002: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
99003: LD_ADDR_VAR 0 2
99007: PUSH
99008: LD_INT 2
99010: PUSH
99011: LD_INT 4
99013: PUSH
99014: LD_INT 5
99016: PUSH
99017: LD_INT 6
99019: PUSH
99020: LD_INT 8
99022: PUSH
99023: LD_INT 11
99025: PUSH
99026: LD_INT 12
99028: PUSH
99029: LD_INT 15
99031: PUSH
99032: LD_INT 16
99034: PUSH
99035: LD_INT 20
99037: PUSH
99038: LD_INT 21
99040: PUSH
99041: LD_INT 22
99043: PUSH
99044: LD_INT 23
99046: PUSH
99047: LD_INT 25
99049: PUSH
99050: LD_INT 26
99052: PUSH
99053: LD_INT 30
99055: PUSH
99056: LD_INT 31
99058: PUSH
99059: LD_INT 32
99061: PUSH
99062: LD_INT 36
99064: PUSH
99065: EMPTY
99066: LIST
99067: LIST
99068: LIST
99069: LIST
99070: LIST
99071: LIST
99072: LIST
99073: LIST
99074: LIST
99075: LIST
99076: LIST
99077: LIST
99078: LIST
99079: LIST
99080: LIST
99081: LIST
99082: LIST
99083: LIST
99084: LIST
99085: PUSH
99086: LD_INT 101
99088: PUSH
99089: LD_INT 102
99091: PUSH
99092: LD_INT 105
99094: PUSH
99095: LD_INT 106
99097: PUSH
99098: LD_INT 108
99100: PUSH
99101: LD_INT 109
99103: PUSH
99104: LD_INT 112
99106: PUSH
99107: LD_INT 116
99109: PUSH
99110: LD_INT 117
99112: PUSH
99113: LD_INT 118
99115: PUSH
99116: EMPTY
99117: LIST
99118: LIST
99119: LIST
99120: LIST
99121: LIST
99122: LIST
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: PUSH
99128: EMPTY
99129: LIST
99130: LIST
99131: ST_TO_ADDR
99132: GO 101655
99134: LD_INT 7
99136: DOUBLE
99137: EQUAL
99138: IFTRUE 99142
99140: GO 99254
99142: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
99143: LD_ADDR_VAR 0 2
99147: PUSH
99148: LD_INT 2
99150: PUSH
99151: LD_INT 4
99153: PUSH
99154: LD_INT 5
99156: PUSH
99157: LD_INT 7
99159: PUSH
99160: LD_INT 11
99162: PUSH
99163: LD_INT 12
99165: PUSH
99166: LD_INT 15
99168: PUSH
99169: LD_INT 16
99171: PUSH
99172: LD_INT 20
99174: PUSH
99175: LD_INT 21
99177: PUSH
99178: LD_INT 22
99180: PUSH
99181: LD_INT 23
99183: PUSH
99184: LD_INT 25
99186: PUSH
99187: LD_INT 26
99189: PUSH
99190: EMPTY
99191: LIST
99192: LIST
99193: LIST
99194: LIST
99195: LIST
99196: LIST
99197: LIST
99198: LIST
99199: LIST
99200: LIST
99201: LIST
99202: LIST
99203: LIST
99204: LIST
99205: PUSH
99206: LD_INT 101
99208: PUSH
99209: LD_INT 102
99211: PUSH
99212: LD_INT 103
99214: PUSH
99215: LD_INT 105
99217: PUSH
99218: LD_INT 106
99220: PUSH
99221: LD_INT 108
99223: PUSH
99224: LD_INT 112
99226: PUSH
99227: LD_INT 116
99229: PUSH
99230: LD_INT 117
99232: PUSH
99233: LD_INT 118
99235: PUSH
99236: EMPTY
99237: LIST
99238: LIST
99239: LIST
99240: LIST
99241: LIST
99242: LIST
99243: LIST
99244: LIST
99245: LIST
99246: LIST
99247: PUSH
99248: EMPTY
99249: LIST
99250: LIST
99251: ST_TO_ADDR
99252: GO 101655
99254: LD_INT 8
99256: DOUBLE
99257: EQUAL
99258: IFTRUE 99262
99260: GO 99402
99262: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
99263: LD_ADDR_VAR 0 2
99267: PUSH
99268: LD_INT 2
99270: PUSH
99271: LD_INT 4
99273: PUSH
99274: LD_INT 5
99276: PUSH
99277: LD_INT 6
99279: PUSH
99280: LD_INT 7
99282: PUSH
99283: LD_INT 8
99285: PUSH
99286: LD_INT 11
99288: PUSH
99289: LD_INT 12
99291: PUSH
99292: LD_INT 15
99294: PUSH
99295: LD_INT 16
99297: PUSH
99298: LD_INT 20
99300: PUSH
99301: LD_INT 21
99303: PUSH
99304: LD_INT 22
99306: PUSH
99307: LD_INT 23
99309: PUSH
99310: LD_INT 25
99312: PUSH
99313: LD_INT 26
99315: PUSH
99316: LD_INT 30
99318: PUSH
99319: LD_INT 31
99321: PUSH
99322: LD_INT 32
99324: PUSH
99325: LD_INT 36
99327: PUSH
99328: EMPTY
99329: LIST
99330: LIST
99331: LIST
99332: LIST
99333: LIST
99334: LIST
99335: LIST
99336: LIST
99337: LIST
99338: LIST
99339: LIST
99340: LIST
99341: LIST
99342: LIST
99343: LIST
99344: LIST
99345: LIST
99346: LIST
99347: LIST
99348: LIST
99349: PUSH
99350: LD_INT 101
99352: PUSH
99353: LD_INT 102
99355: PUSH
99356: LD_INT 103
99358: PUSH
99359: LD_INT 105
99361: PUSH
99362: LD_INT 106
99364: PUSH
99365: LD_INT 108
99367: PUSH
99368: LD_INT 109
99370: PUSH
99371: LD_INT 112
99373: PUSH
99374: LD_INT 116
99376: PUSH
99377: LD_INT 117
99379: PUSH
99380: LD_INT 118
99382: PUSH
99383: EMPTY
99384: LIST
99385: LIST
99386: LIST
99387: LIST
99388: LIST
99389: LIST
99390: LIST
99391: LIST
99392: LIST
99393: LIST
99394: LIST
99395: PUSH
99396: EMPTY
99397: LIST
99398: LIST
99399: ST_TO_ADDR
99400: GO 101655
99402: LD_INT 9
99404: DOUBLE
99405: EQUAL
99406: IFTRUE 99410
99408: GO 99558
99410: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
99411: LD_ADDR_VAR 0 2
99415: PUSH
99416: LD_INT 2
99418: PUSH
99419: LD_INT 4
99421: PUSH
99422: LD_INT 5
99424: PUSH
99425: LD_INT 6
99427: PUSH
99428: LD_INT 7
99430: PUSH
99431: LD_INT 8
99433: PUSH
99434: LD_INT 11
99436: PUSH
99437: LD_INT 12
99439: PUSH
99440: LD_INT 15
99442: PUSH
99443: LD_INT 16
99445: PUSH
99446: LD_INT 20
99448: PUSH
99449: LD_INT 21
99451: PUSH
99452: LD_INT 22
99454: PUSH
99455: LD_INT 23
99457: PUSH
99458: LD_INT 25
99460: PUSH
99461: LD_INT 26
99463: PUSH
99464: LD_INT 28
99466: PUSH
99467: LD_INT 30
99469: PUSH
99470: LD_INT 31
99472: PUSH
99473: LD_INT 32
99475: PUSH
99476: LD_INT 36
99478: PUSH
99479: EMPTY
99480: LIST
99481: LIST
99482: LIST
99483: LIST
99484: LIST
99485: LIST
99486: LIST
99487: LIST
99488: LIST
99489: LIST
99490: LIST
99491: LIST
99492: LIST
99493: LIST
99494: LIST
99495: LIST
99496: LIST
99497: LIST
99498: LIST
99499: LIST
99500: LIST
99501: PUSH
99502: LD_INT 101
99504: PUSH
99505: LD_INT 102
99507: PUSH
99508: LD_INT 103
99510: PUSH
99511: LD_INT 105
99513: PUSH
99514: LD_INT 106
99516: PUSH
99517: LD_INT 108
99519: PUSH
99520: LD_INT 109
99522: PUSH
99523: LD_INT 112
99525: PUSH
99526: LD_INT 114
99528: PUSH
99529: LD_INT 116
99531: PUSH
99532: LD_INT 117
99534: PUSH
99535: LD_INT 118
99537: PUSH
99538: EMPTY
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: LIST
99544: LIST
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: PUSH
99552: EMPTY
99553: LIST
99554: LIST
99555: ST_TO_ADDR
99556: GO 101655
99558: LD_INT 10
99560: DOUBLE
99561: EQUAL
99562: IFTRUE 99566
99564: GO 99762
99566: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
99567: LD_ADDR_VAR 0 2
99571: PUSH
99572: LD_INT 2
99574: PUSH
99575: LD_INT 4
99577: PUSH
99578: LD_INT 5
99580: PUSH
99581: LD_INT 6
99583: PUSH
99584: LD_INT 7
99586: PUSH
99587: LD_INT 8
99589: PUSH
99590: LD_INT 9
99592: PUSH
99593: LD_INT 10
99595: PUSH
99596: LD_INT 11
99598: PUSH
99599: LD_INT 12
99601: PUSH
99602: LD_INT 13
99604: PUSH
99605: LD_INT 14
99607: PUSH
99608: LD_INT 15
99610: PUSH
99611: LD_INT 16
99613: PUSH
99614: LD_INT 17
99616: PUSH
99617: LD_INT 18
99619: PUSH
99620: LD_INT 19
99622: PUSH
99623: LD_INT 20
99625: PUSH
99626: LD_INT 21
99628: PUSH
99629: LD_INT 22
99631: PUSH
99632: LD_INT 23
99634: PUSH
99635: LD_INT 24
99637: PUSH
99638: LD_INT 25
99640: PUSH
99641: LD_INT 26
99643: PUSH
99644: LD_INT 28
99646: PUSH
99647: LD_INT 30
99649: PUSH
99650: LD_INT 31
99652: PUSH
99653: LD_INT 32
99655: PUSH
99656: LD_INT 36
99658: PUSH
99659: EMPTY
99660: LIST
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: LIST
99666: LIST
99667: LIST
99668: LIST
99669: LIST
99670: LIST
99671: LIST
99672: LIST
99673: LIST
99674: LIST
99675: LIST
99676: LIST
99677: LIST
99678: LIST
99679: LIST
99680: LIST
99681: LIST
99682: LIST
99683: LIST
99684: LIST
99685: LIST
99686: LIST
99687: LIST
99688: LIST
99689: PUSH
99690: LD_INT 101
99692: PUSH
99693: LD_INT 102
99695: PUSH
99696: LD_INT 103
99698: PUSH
99699: LD_INT 104
99701: PUSH
99702: LD_INT 105
99704: PUSH
99705: LD_INT 106
99707: PUSH
99708: LD_INT 107
99710: PUSH
99711: LD_INT 108
99713: PUSH
99714: LD_INT 109
99716: PUSH
99717: LD_INT 110
99719: PUSH
99720: LD_INT 111
99722: PUSH
99723: LD_INT 112
99725: PUSH
99726: LD_INT 114
99728: PUSH
99729: LD_INT 116
99731: PUSH
99732: LD_INT 117
99734: PUSH
99735: LD_INT 118
99737: PUSH
99738: EMPTY
99739: LIST
99740: LIST
99741: LIST
99742: LIST
99743: LIST
99744: LIST
99745: LIST
99746: LIST
99747: LIST
99748: LIST
99749: LIST
99750: LIST
99751: LIST
99752: LIST
99753: LIST
99754: LIST
99755: PUSH
99756: EMPTY
99757: LIST
99758: LIST
99759: ST_TO_ADDR
99760: GO 101655
99762: LD_INT 11
99764: DOUBLE
99765: EQUAL
99766: IFTRUE 99770
99768: GO 99974
99770: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
99771: LD_ADDR_VAR 0 2
99775: PUSH
99776: LD_INT 2
99778: PUSH
99779: LD_INT 3
99781: PUSH
99782: LD_INT 4
99784: PUSH
99785: LD_INT 5
99787: PUSH
99788: LD_INT 6
99790: PUSH
99791: LD_INT 7
99793: PUSH
99794: LD_INT 8
99796: PUSH
99797: LD_INT 9
99799: PUSH
99800: LD_INT 10
99802: PUSH
99803: LD_INT 11
99805: PUSH
99806: LD_INT 12
99808: PUSH
99809: LD_INT 13
99811: PUSH
99812: LD_INT 14
99814: PUSH
99815: LD_INT 15
99817: PUSH
99818: LD_INT 16
99820: PUSH
99821: LD_INT 17
99823: PUSH
99824: LD_INT 18
99826: PUSH
99827: LD_INT 19
99829: PUSH
99830: LD_INT 20
99832: PUSH
99833: LD_INT 21
99835: PUSH
99836: LD_INT 22
99838: PUSH
99839: LD_INT 23
99841: PUSH
99842: LD_INT 24
99844: PUSH
99845: LD_INT 25
99847: PUSH
99848: LD_INT 26
99850: PUSH
99851: LD_INT 28
99853: PUSH
99854: LD_INT 30
99856: PUSH
99857: LD_INT 31
99859: PUSH
99860: LD_INT 32
99862: PUSH
99863: LD_INT 34
99865: PUSH
99866: LD_INT 36
99868: PUSH
99869: EMPTY
99870: LIST
99871: LIST
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: LIST
99879: LIST
99880: LIST
99881: LIST
99882: LIST
99883: LIST
99884: LIST
99885: LIST
99886: LIST
99887: LIST
99888: LIST
99889: LIST
99890: LIST
99891: LIST
99892: LIST
99893: LIST
99894: LIST
99895: LIST
99896: LIST
99897: LIST
99898: LIST
99899: LIST
99900: LIST
99901: PUSH
99902: LD_INT 101
99904: PUSH
99905: LD_INT 102
99907: PUSH
99908: LD_INT 103
99910: PUSH
99911: LD_INT 104
99913: PUSH
99914: LD_INT 105
99916: PUSH
99917: LD_INT 106
99919: PUSH
99920: LD_INT 107
99922: PUSH
99923: LD_INT 108
99925: PUSH
99926: LD_INT 109
99928: PUSH
99929: LD_INT 110
99931: PUSH
99932: LD_INT 111
99934: PUSH
99935: LD_INT 112
99937: PUSH
99938: LD_INT 114
99940: PUSH
99941: LD_INT 116
99943: PUSH
99944: LD_INT 117
99946: PUSH
99947: LD_INT 118
99949: PUSH
99950: EMPTY
99951: LIST
99952: LIST
99953: LIST
99954: LIST
99955: LIST
99956: LIST
99957: LIST
99958: LIST
99959: LIST
99960: LIST
99961: LIST
99962: LIST
99963: LIST
99964: LIST
99965: LIST
99966: LIST
99967: PUSH
99968: EMPTY
99969: LIST
99970: LIST
99971: ST_TO_ADDR
99972: GO 101655
99974: LD_INT 12
99976: DOUBLE
99977: EQUAL
99978: IFTRUE 99982
99980: GO 100202
99982: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
99983: LD_ADDR_VAR 0 2
99987: PUSH
99988: LD_INT 1
99990: PUSH
99991: LD_INT 2
99993: PUSH
99994: LD_INT 3
99996: PUSH
99997: LD_INT 4
99999: PUSH
100000: LD_INT 5
100002: PUSH
100003: LD_INT 6
100005: PUSH
100006: LD_INT 7
100008: PUSH
100009: LD_INT 8
100011: PUSH
100012: LD_INT 9
100014: PUSH
100015: LD_INT 10
100017: PUSH
100018: LD_INT 11
100020: PUSH
100021: LD_INT 12
100023: PUSH
100024: LD_INT 13
100026: PUSH
100027: LD_INT 14
100029: PUSH
100030: LD_INT 15
100032: PUSH
100033: LD_INT 16
100035: PUSH
100036: LD_INT 17
100038: PUSH
100039: LD_INT 18
100041: PUSH
100042: LD_INT 19
100044: PUSH
100045: LD_INT 20
100047: PUSH
100048: LD_INT 21
100050: PUSH
100051: LD_INT 22
100053: PUSH
100054: LD_INT 23
100056: PUSH
100057: LD_INT 24
100059: PUSH
100060: LD_INT 25
100062: PUSH
100063: LD_INT 26
100065: PUSH
100066: LD_INT 27
100068: PUSH
100069: LD_INT 28
100071: PUSH
100072: LD_INT 30
100074: PUSH
100075: LD_INT 31
100077: PUSH
100078: LD_INT 32
100080: PUSH
100081: LD_INT 33
100083: PUSH
100084: LD_INT 34
100086: PUSH
100087: LD_INT 36
100089: PUSH
100090: EMPTY
100091: LIST
100092: LIST
100093: LIST
100094: LIST
100095: LIST
100096: LIST
100097: LIST
100098: LIST
100099: LIST
100100: LIST
100101: LIST
100102: LIST
100103: LIST
100104: LIST
100105: LIST
100106: LIST
100107: LIST
100108: LIST
100109: LIST
100110: LIST
100111: LIST
100112: LIST
100113: LIST
100114: LIST
100115: LIST
100116: LIST
100117: LIST
100118: LIST
100119: LIST
100120: LIST
100121: LIST
100122: LIST
100123: LIST
100124: LIST
100125: PUSH
100126: LD_INT 101
100128: PUSH
100129: LD_INT 102
100131: PUSH
100132: LD_INT 103
100134: PUSH
100135: LD_INT 104
100137: PUSH
100138: LD_INT 105
100140: PUSH
100141: LD_INT 106
100143: PUSH
100144: LD_INT 107
100146: PUSH
100147: LD_INT 108
100149: PUSH
100150: LD_INT 109
100152: PUSH
100153: LD_INT 110
100155: PUSH
100156: LD_INT 111
100158: PUSH
100159: LD_INT 112
100161: PUSH
100162: LD_INT 113
100164: PUSH
100165: LD_INT 114
100167: PUSH
100168: LD_INT 116
100170: PUSH
100171: LD_INT 117
100173: PUSH
100174: LD_INT 118
100176: PUSH
100177: EMPTY
100178: LIST
100179: LIST
100180: LIST
100181: LIST
100182: LIST
100183: LIST
100184: LIST
100185: LIST
100186: LIST
100187: LIST
100188: LIST
100189: LIST
100190: LIST
100191: LIST
100192: LIST
100193: LIST
100194: LIST
100195: PUSH
100196: EMPTY
100197: LIST
100198: LIST
100199: ST_TO_ADDR
100200: GO 101655
100202: LD_INT 13
100204: DOUBLE
100205: EQUAL
100206: IFTRUE 100210
100208: GO 100418
100210: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
100211: LD_ADDR_VAR 0 2
100215: PUSH
100216: LD_INT 1
100218: PUSH
100219: LD_INT 2
100221: PUSH
100222: LD_INT 3
100224: PUSH
100225: LD_INT 4
100227: PUSH
100228: LD_INT 5
100230: PUSH
100231: LD_INT 8
100233: PUSH
100234: LD_INT 9
100236: PUSH
100237: LD_INT 10
100239: PUSH
100240: LD_INT 11
100242: PUSH
100243: LD_INT 12
100245: PUSH
100246: LD_INT 14
100248: PUSH
100249: LD_INT 15
100251: PUSH
100252: LD_INT 16
100254: PUSH
100255: LD_INT 17
100257: PUSH
100258: LD_INT 18
100260: PUSH
100261: LD_INT 19
100263: PUSH
100264: LD_INT 20
100266: PUSH
100267: LD_INT 21
100269: PUSH
100270: LD_INT 22
100272: PUSH
100273: LD_INT 23
100275: PUSH
100276: LD_INT 24
100278: PUSH
100279: LD_INT 25
100281: PUSH
100282: LD_INT 26
100284: PUSH
100285: LD_INT 27
100287: PUSH
100288: LD_INT 28
100290: PUSH
100291: LD_INT 30
100293: PUSH
100294: LD_INT 31
100296: PUSH
100297: LD_INT 32
100299: PUSH
100300: LD_INT 33
100302: PUSH
100303: LD_INT 34
100305: PUSH
100306: LD_INT 36
100308: PUSH
100309: EMPTY
100310: LIST
100311: LIST
100312: LIST
100313: LIST
100314: LIST
100315: LIST
100316: LIST
100317: LIST
100318: LIST
100319: LIST
100320: LIST
100321: LIST
100322: LIST
100323: LIST
100324: LIST
100325: LIST
100326: LIST
100327: LIST
100328: LIST
100329: LIST
100330: LIST
100331: LIST
100332: LIST
100333: LIST
100334: LIST
100335: LIST
100336: LIST
100337: LIST
100338: LIST
100339: LIST
100340: LIST
100341: PUSH
100342: LD_INT 101
100344: PUSH
100345: LD_INT 102
100347: PUSH
100348: LD_INT 103
100350: PUSH
100351: LD_INT 104
100353: PUSH
100354: LD_INT 105
100356: PUSH
100357: LD_INT 106
100359: PUSH
100360: LD_INT 107
100362: PUSH
100363: LD_INT 108
100365: PUSH
100366: LD_INT 109
100368: PUSH
100369: LD_INT 110
100371: PUSH
100372: LD_INT 111
100374: PUSH
100375: LD_INT 112
100377: PUSH
100378: LD_INT 113
100380: PUSH
100381: LD_INT 114
100383: PUSH
100384: LD_INT 116
100386: PUSH
100387: LD_INT 117
100389: PUSH
100390: LD_INT 118
100392: PUSH
100393: EMPTY
100394: LIST
100395: LIST
100396: LIST
100397: LIST
100398: LIST
100399: LIST
100400: LIST
100401: LIST
100402: LIST
100403: LIST
100404: LIST
100405: LIST
100406: LIST
100407: LIST
100408: LIST
100409: LIST
100410: LIST
100411: PUSH
100412: EMPTY
100413: LIST
100414: LIST
100415: ST_TO_ADDR
100416: GO 101655
100418: LD_INT 14
100420: DOUBLE
100421: EQUAL
100422: IFTRUE 100426
100424: GO 100650
100426: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
100427: LD_ADDR_VAR 0 2
100431: PUSH
100432: LD_INT 1
100434: PUSH
100435: LD_INT 2
100437: PUSH
100438: LD_INT 3
100440: PUSH
100441: LD_INT 4
100443: PUSH
100444: LD_INT 5
100446: PUSH
100447: LD_INT 6
100449: PUSH
100450: LD_INT 7
100452: PUSH
100453: LD_INT 8
100455: PUSH
100456: LD_INT 9
100458: PUSH
100459: LD_INT 10
100461: PUSH
100462: LD_INT 11
100464: PUSH
100465: LD_INT 12
100467: PUSH
100468: LD_INT 13
100470: PUSH
100471: LD_INT 14
100473: PUSH
100474: LD_INT 15
100476: PUSH
100477: LD_INT 16
100479: PUSH
100480: LD_INT 17
100482: PUSH
100483: LD_INT 18
100485: PUSH
100486: LD_INT 19
100488: PUSH
100489: LD_INT 20
100491: PUSH
100492: LD_INT 21
100494: PUSH
100495: LD_INT 22
100497: PUSH
100498: LD_INT 23
100500: PUSH
100501: LD_INT 24
100503: PUSH
100504: LD_INT 25
100506: PUSH
100507: LD_INT 26
100509: PUSH
100510: LD_INT 27
100512: PUSH
100513: LD_INT 28
100515: PUSH
100516: LD_INT 29
100518: PUSH
100519: LD_INT 30
100521: PUSH
100522: LD_INT 31
100524: PUSH
100525: LD_INT 32
100527: PUSH
100528: LD_INT 33
100530: PUSH
100531: LD_INT 34
100533: PUSH
100534: LD_INT 36
100536: PUSH
100537: EMPTY
100538: LIST
100539: LIST
100540: LIST
100541: LIST
100542: LIST
100543: LIST
100544: LIST
100545: LIST
100546: LIST
100547: LIST
100548: LIST
100549: LIST
100550: LIST
100551: LIST
100552: LIST
100553: LIST
100554: LIST
100555: LIST
100556: LIST
100557: LIST
100558: LIST
100559: LIST
100560: LIST
100561: LIST
100562: LIST
100563: LIST
100564: LIST
100565: LIST
100566: LIST
100567: LIST
100568: LIST
100569: LIST
100570: LIST
100571: LIST
100572: LIST
100573: PUSH
100574: LD_INT 101
100576: PUSH
100577: LD_INT 102
100579: PUSH
100580: LD_INT 103
100582: PUSH
100583: LD_INT 104
100585: PUSH
100586: LD_INT 105
100588: PUSH
100589: LD_INT 106
100591: PUSH
100592: LD_INT 107
100594: PUSH
100595: LD_INT 108
100597: PUSH
100598: LD_INT 109
100600: PUSH
100601: LD_INT 110
100603: PUSH
100604: LD_INT 111
100606: PUSH
100607: LD_INT 112
100609: PUSH
100610: LD_INT 113
100612: PUSH
100613: LD_INT 114
100615: PUSH
100616: LD_INT 116
100618: PUSH
100619: LD_INT 117
100621: PUSH
100622: LD_INT 118
100624: PUSH
100625: EMPTY
100626: LIST
100627: LIST
100628: LIST
100629: LIST
100630: LIST
100631: LIST
100632: LIST
100633: LIST
100634: LIST
100635: LIST
100636: LIST
100637: LIST
100638: LIST
100639: LIST
100640: LIST
100641: LIST
100642: LIST
100643: PUSH
100644: EMPTY
100645: LIST
100646: LIST
100647: ST_TO_ADDR
100648: GO 101655
100650: LD_INT 15
100652: DOUBLE
100653: EQUAL
100654: IFTRUE 100658
100656: GO 100882
100658: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
100659: LD_ADDR_VAR 0 2
100663: PUSH
100664: LD_INT 1
100666: PUSH
100667: LD_INT 2
100669: PUSH
100670: LD_INT 3
100672: PUSH
100673: LD_INT 4
100675: PUSH
100676: LD_INT 5
100678: PUSH
100679: LD_INT 6
100681: PUSH
100682: LD_INT 7
100684: PUSH
100685: LD_INT 8
100687: PUSH
100688: LD_INT 9
100690: PUSH
100691: LD_INT 10
100693: PUSH
100694: LD_INT 11
100696: PUSH
100697: LD_INT 12
100699: PUSH
100700: LD_INT 13
100702: PUSH
100703: LD_INT 14
100705: PUSH
100706: LD_INT 15
100708: PUSH
100709: LD_INT 16
100711: PUSH
100712: LD_INT 17
100714: PUSH
100715: LD_INT 18
100717: PUSH
100718: LD_INT 19
100720: PUSH
100721: LD_INT 20
100723: PUSH
100724: LD_INT 21
100726: PUSH
100727: LD_INT 22
100729: PUSH
100730: LD_INT 23
100732: PUSH
100733: LD_INT 24
100735: PUSH
100736: LD_INT 25
100738: PUSH
100739: LD_INT 26
100741: PUSH
100742: LD_INT 27
100744: PUSH
100745: LD_INT 28
100747: PUSH
100748: LD_INT 29
100750: PUSH
100751: LD_INT 30
100753: PUSH
100754: LD_INT 31
100756: PUSH
100757: LD_INT 32
100759: PUSH
100760: LD_INT 33
100762: PUSH
100763: LD_INT 34
100765: PUSH
100766: LD_INT 36
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: LIST
100773: LIST
100774: LIST
100775: LIST
100776: LIST
100777: LIST
100778: LIST
100779: LIST
100780: LIST
100781: LIST
100782: LIST
100783: LIST
100784: LIST
100785: LIST
100786: LIST
100787: LIST
100788: LIST
100789: LIST
100790: LIST
100791: LIST
100792: LIST
100793: LIST
100794: LIST
100795: LIST
100796: LIST
100797: LIST
100798: LIST
100799: LIST
100800: LIST
100801: LIST
100802: LIST
100803: LIST
100804: LIST
100805: PUSH
100806: LD_INT 101
100808: PUSH
100809: LD_INT 102
100811: PUSH
100812: LD_INT 103
100814: PUSH
100815: LD_INT 104
100817: PUSH
100818: LD_INT 105
100820: PUSH
100821: LD_INT 106
100823: PUSH
100824: LD_INT 107
100826: PUSH
100827: LD_INT 108
100829: PUSH
100830: LD_INT 109
100832: PUSH
100833: LD_INT 110
100835: PUSH
100836: LD_INT 111
100838: PUSH
100839: LD_INT 112
100841: PUSH
100842: LD_INT 113
100844: PUSH
100845: LD_INT 114
100847: PUSH
100848: LD_INT 116
100850: PUSH
100851: LD_INT 117
100853: PUSH
100854: LD_INT 118
100856: PUSH
100857: EMPTY
100858: LIST
100859: LIST
100860: LIST
100861: LIST
100862: LIST
100863: LIST
100864: LIST
100865: LIST
100866: LIST
100867: LIST
100868: LIST
100869: LIST
100870: LIST
100871: LIST
100872: LIST
100873: LIST
100874: LIST
100875: PUSH
100876: EMPTY
100877: LIST
100878: LIST
100879: ST_TO_ADDR
100880: GO 101655
100882: LD_INT 16
100884: DOUBLE
100885: EQUAL
100886: IFTRUE 100890
100888: GO 101026
100890: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
100891: LD_ADDR_VAR 0 2
100895: PUSH
100896: LD_INT 2
100898: PUSH
100899: LD_INT 4
100901: PUSH
100902: LD_INT 5
100904: PUSH
100905: LD_INT 7
100907: PUSH
100908: LD_INT 11
100910: PUSH
100911: LD_INT 12
100913: PUSH
100914: LD_INT 15
100916: PUSH
100917: LD_INT 16
100919: PUSH
100920: LD_INT 20
100922: PUSH
100923: LD_INT 21
100925: PUSH
100926: LD_INT 22
100928: PUSH
100929: LD_INT 23
100931: PUSH
100932: LD_INT 25
100934: PUSH
100935: LD_INT 26
100937: PUSH
100938: LD_INT 30
100940: PUSH
100941: LD_INT 31
100943: PUSH
100944: LD_INT 32
100946: PUSH
100947: LD_INT 33
100949: PUSH
100950: LD_INT 34
100952: PUSH
100953: EMPTY
100954: LIST
100955: LIST
100956: LIST
100957: LIST
100958: LIST
100959: LIST
100960: LIST
100961: LIST
100962: LIST
100963: LIST
100964: LIST
100965: LIST
100966: LIST
100967: LIST
100968: LIST
100969: LIST
100970: LIST
100971: LIST
100972: LIST
100973: PUSH
100974: LD_INT 101
100976: PUSH
100977: LD_INT 102
100979: PUSH
100980: LD_INT 103
100982: PUSH
100983: LD_INT 106
100985: PUSH
100986: LD_INT 108
100988: PUSH
100989: LD_INT 112
100991: PUSH
100992: LD_INT 113
100994: PUSH
100995: LD_INT 114
100997: PUSH
100998: LD_INT 116
101000: PUSH
101001: LD_INT 117
101003: PUSH
101004: LD_INT 118
101006: PUSH
101007: EMPTY
101008: LIST
101009: LIST
101010: LIST
101011: LIST
101012: LIST
101013: LIST
101014: LIST
101015: LIST
101016: LIST
101017: LIST
101018: LIST
101019: PUSH
101020: EMPTY
101021: LIST
101022: LIST
101023: ST_TO_ADDR
101024: GO 101655
101026: LD_INT 17
101028: DOUBLE
101029: EQUAL
101030: IFTRUE 101034
101032: GO 101258
101034: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
101035: LD_ADDR_VAR 0 2
101039: PUSH
101040: LD_INT 1
101042: PUSH
101043: LD_INT 2
101045: PUSH
101046: LD_INT 3
101048: PUSH
101049: LD_INT 4
101051: PUSH
101052: LD_INT 5
101054: PUSH
101055: LD_INT 6
101057: PUSH
101058: LD_INT 7
101060: PUSH
101061: LD_INT 8
101063: PUSH
101064: LD_INT 9
101066: PUSH
101067: LD_INT 10
101069: PUSH
101070: LD_INT 11
101072: PUSH
101073: LD_INT 12
101075: PUSH
101076: LD_INT 13
101078: PUSH
101079: LD_INT 14
101081: PUSH
101082: LD_INT 15
101084: PUSH
101085: LD_INT 16
101087: PUSH
101088: LD_INT 17
101090: PUSH
101091: LD_INT 18
101093: PUSH
101094: LD_INT 19
101096: PUSH
101097: LD_INT 20
101099: PUSH
101100: LD_INT 21
101102: PUSH
101103: LD_INT 22
101105: PUSH
101106: LD_INT 23
101108: PUSH
101109: LD_INT 24
101111: PUSH
101112: LD_INT 25
101114: PUSH
101115: LD_INT 26
101117: PUSH
101118: LD_INT 27
101120: PUSH
101121: LD_INT 28
101123: PUSH
101124: LD_INT 29
101126: PUSH
101127: LD_INT 30
101129: PUSH
101130: LD_INT 31
101132: PUSH
101133: LD_INT 32
101135: PUSH
101136: LD_INT 33
101138: PUSH
101139: LD_INT 34
101141: PUSH
101142: LD_INT 36
101144: PUSH
101145: EMPTY
101146: LIST
101147: LIST
101148: LIST
101149: LIST
101150: LIST
101151: LIST
101152: LIST
101153: LIST
101154: LIST
101155: LIST
101156: LIST
101157: LIST
101158: LIST
101159: LIST
101160: LIST
101161: LIST
101162: LIST
101163: LIST
101164: LIST
101165: LIST
101166: LIST
101167: LIST
101168: LIST
101169: LIST
101170: LIST
101171: LIST
101172: LIST
101173: LIST
101174: LIST
101175: LIST
101176: LIST
101177: LIST
101178: LIST
101179: LIST
101180: LIST
101181: PUSH
101182: LD_INT 101
101184: PUSH
101185: LD_INT 102
101187: PUSH
101188: LD_INT 103
101190: PUSH
101191: LD_INT 104
101193: PUSH
101194: LD_INT 105
101196: PUSH
101197: LD_INT 106
101199: PUSH
101200: LD_INT 107
101202: PUSH
101203: LD_INT 108
101205: PUSH
101206: LD_INT 109
101208: PUSH
101209: LD_INT 110
101211: PUSH
101212: LD_INT 111
101214: PUSH
101215: LD_INT 112
101217: PUSH
101218: LD_INT 113
101220: PUSH
101221: LD_INT 114
101223: PUSH
101224: LD_INT 116
101226: PUSH
101227: LD_INT 117
101229: PUSH
101230: LD_INT 118
101232: PUSH
101233: EMPTY
101234: LIST
101235: LIST
101236: LIST
101237: LIST
101238: LIST
101239: LIST
101240: LIST
101241: LIST
101242: LIST
101243: LIST
101244: LIST
101245: LIST
101246: LIST
101247: LIST
101248: LIST
101249: LIST
101250: LIST
101251: PUSH
101252: EMPTY
101253: LIST
101254: LIST
101255: ST_TO_ADDR
101256: GO 101655
101258: LD_INT 18
101260: DOUBLE
101261: EQUAL
101262: IFTRUE 101266
101264: GO 101414
101266: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
101267: LD_ADDR_VAR 0 2
101271: PUSH
101272: LD_INT 2
101274: PUSH
101275: LD_INT 4
101277: PUSH
101278: LD_INT 5
101280: PUSH
101281: LD_INT 7
101283: PUSH
101284: LD_INT 11
101286: PUSH
101287: LD_INT 12
101289: PUSH
101290: LD_INT 15
101292: PUSH
101293: LD_INT 16
101295: PUSH
101296: LD_INT 20
101298: PUSH
101299: LD_INT 21
101301: PUSH
101302: LD_INT 22
101304: PUSH
101305: LD_INT 23
101307: PUSH
101308: LD_INT 25
101310: PUSH
101311: LD_INT 26
101313: PUSH
101314: LD_INT 30
101316: PUSH
101317: LD_INT 31
101319: PUSH
101320: LD_INT 32
101322: PUSH
101323: LD_INT 33
101325: PUSH
101326: LD_INT 34
101328: PUSH
101329: LD_INT 35
101331: PUSH
101332: LD_INT 36
101334: PUSH
101335: EMPTY
101336: LIST
101337: LIST
101338: LIST
101339: LIST
101340: LIST
101341: LIST
101342: LIST
101343: LIST
101344: LIST
101345: LIST
101346: LIST
101347: LIST
101348: LIST
101349: LIST
101350: LIST
101351: LIST
101352: LIST
101353: LIST
101354: LIST
101355: LIST
101356: LIST
101357: PUSH
101358: LD_INT 101
101360: PUSH
101361: LD_INT 102
101363: PUSH
101364: LD_INT 103
101366: PUSH
101367: LD_INT 106
101369: PUSH
101370: LD_INT 108
101372: PUSH
101373: LD_INT 112
101375: PUSH
101376: LD_INT 113
101378: PUSH
101379: LD_INT 114
101381: PUSH
101382: LD_INT 115
101384: PUSH
101385: LD_INT 116
101387: PUSH
101388: LD_INT 117
101390: PUSH
101391: LD_INT 118
101393: PUSH
101394: EMPTY
101395: LIST
101396: LIST
101397: LIST
101398: LIST
101399: LIST
101400: LIST
101401: LIST
101402: LIST
101403: LIST
101404: LIST
101405: LIST
101406: LIST
101407: PUSH
101408: EMPTY
101409: LIST
101410: LIST
101411: ST_TO_ADDR
101412: GO 101655
101414: LD_INT 19
101416: DOUBLE
101417: EQUAL
101418: IFTRUE 101422
101420: GO 101654
101422: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
101423: LD_ADDR_VAR 0 2
101427: PUSH
101428: LD_INT 1
101430: PUSH
101431: LD_INT 2
101433: PUSH
101434: LD_INT 3
101436: PUSH
101437: LD_INT 4
101439: PUSH
101440: LD_INT 5
101442: PUSH
101443: LD_INT 6
101445: PUSH
101446: LD_INT 7
101448: PUSH
101449: LD_INT 8
101451: PUSH
101452: LD_INT 9
101454: PUSH
101455: LD_INT 10
101457: PUSH
101458: LD_INT 11
101460: PUSH
101461: LD_INT 12
101463: PUSH
101464: LD_INT 13
101466: PUSH
101467: LD_INT 14
101469: PUSH
101470: LD_INT 15
101472: PUSH
101473: LD_INT 16
101475: PUSH
101476: LD_INT 17
101478: PUSH
101479: LD_INT 18
101481: PUSH
101482: LD_INT 19
101484: PUSH
101485: LD_INT 20
101487: PUSH
101488: LD_INT 21
101490: PUSH
101491: LD_INT 22
101493: PUSH
101494: LD_INT 23
101496: PUSH
101497: LD_INT 24
101499: PUSH
101500: LD_INT 25
101502: PUSH
101503: LD_INT 26
101505: PUSH
101506: LD_INT 27
101508: PUSH
101509: LD_INT 28
101511: PUSH
101512: LD_INT 29
101514: PUSH
101515: LD_INT 30
101517: PUSH
101518: LD_INT 31
101520: PUSH
101521: LD_INT 32
101523: PUSH
101524: LD_INT 33
101526: PUSH
101527: LD_INT 34
101529: PUSH
101530: LD_INT 35
101532: PUSH
101533: LD_INT 36
101535: PUSH
101536: EMPTY
101537: LIST
101538: LIST
101539: LIST
101540: LIST
101541: LIST
101542: LIST
101543: LIST
101544: LIST
101545: LIST
101546: LIST
101547: LIST
101548: LIST
101549: LIST
101550: LIST
101551: LIST
101552: LIST
101553: LIST
101554: LIST
101555: LIST
101556: LIST
101557: LIST
101558: LIST
101559: LIST
101560: LIST
101561: LIST
101562: LIST
101563: LIST
101564: LIST
101565: LIST
101566: LIST
101567: LIST
101568: LIST
101569: LIST
101570: LIST
101571: LIST
101572: LIST
101573: PUSH
101574: LD_INT 101
101576: PUSH
101577: LD_INT 102
101579: PUSH
101580: LD_INT 103
101582: PUSH
101583: LD_INT 104
101585: PUSH
101586: LD_INT 105
101588: PUSH
101589: LD_INT 106
101591: PUSH
101592: LD_INT 107
101594: PUSH
101595: LD_INT 108
101597: PUSH
101598: LD_INT 109
101600: PUSH
101601: LD_INT 110
101603: PUSH
101604: LD_INT 111
101606: PUSH
101607: LD_INT 112
101609: PUSH
101610: LD_INT 113
101612: PUSH
101613: LD_INT 114
101615: PUSH
101616: LD_INT 115
101618: PUSH
101619: LD_INT 116
101621: PUSH
101622: LD_INT 117
101624: PUSH
101625: LD_INT 118
101627: PUSH
101628: EMPTY
101629: LIST
101630: LIST
101631: LIST
101632: LIST
101633: LIST
101634: LIST
101635: LIST
101636: LIST
101637: LIST
101638: LIST
101639: LIST
101640: LIST
101641: LIST
101642: LIST
101643: LIST
101644: LIST
101645: LIST
101646: LIST
101647: PUSH
101648: EMPTY
101649: LIST
101650: LIST
101651: ST_TO_ADDR
101652: GO 101655
101654: POP
// end else
101655: GO 101886
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
101657: LD_ADDR_VAR 0 2
101661: PUSH
101662: LD_INT 1
101664: PUSH
101665: LD_INT 2
101667: PUSH
101668: LD_INT 3
101670: PUSH
101671: LD_INT 4
101673: PUSH
101674: LD_INT 5
101676: PUSH
101677: LD_INT 6
101679: PUSH
101680: LD_INT 7
101682: PUSH
101683: LD_INT 8
101685: PUSH
101686: LD_INT 9
101688: PUSH
101689: LD_INT 10
101691: PUSH
101692: LD_INT 11
101694: PUSH
101695: LD_INT 12
101697: PUSH
101698: LD_INT 13
101700: PUSH
101701: LD_INT 14
101703: PUSH
101704: LD_INT 15
101706: PUSH
101707: LD_INT 16
101709: PUSH
101710: LD_INT 17
101712: PUSH
101713: LD_INT 18
101715: PUSH
101716: LD_INT 19
101718: PUSH
101719: LD_INT 20
101721: PUSH
101722: LD_INT 21
101724: PUSH
101725: LD_INT 22
101727: PUSH
101728: LD_INT 23
101730: PUSH
101731: LD_INT 24
101733: PUSH
101734: LD_INT 25
101736: PUSH
101737: LD_INT 26
101739: PUSH
101740: LD_INT 27
101742: PUSH
101743: LD_INT 28
101745: PUSH
101746: LD_INT 29
101748: PUSH
101749: LD_INT 30
101751: PUSH
101752: LD_INT 31
101754: PUSH
101755: LD_INT 32
101757: PUSH
101758: LD_INT 33
101760: PUSH
101761: LD_INT 34
101763: PUSH
101764: LD_INT 35
101766: PUSH
101767: LD_INT 36
101769: PUSH
101770: EMPTY
101771: LIST
101772: LIST
101773: LIST
101774: LIST
101775: LIST
101776: LIST
101777: LIST
101778: LIST
101779: LIST
101780: LIST
101781: LIST
101782: LIST
101783: LIST
101784: LIST
101785: LIST
101786: LIST
101787: LIST
101788: LIST
101789: LIST
101790: LIST
101791: LIST
101792: LIST
101793: LIST
101794: LIST
101795: LIST
101796: LIST
101797: LIST
101798: LIST
101799: LIST
101800: LIST
101801: LIST
101802: LIST
101803: LIST
101804: LIST
101805: LIST
101806: LIST
101807: PUSH
101808: LD_INT 101
101810: PUSH
101811: LD_INT 102
101813: PUSH
101814: LD_INT 103
101816: PUSH
101817: LD_INT 104
101819: PUSH
101820: LD_INT 105
101822: PUSH
101823: LD_INT 106
101825: PUSH
101826: LD_INT 107
101828: PUSH
101829: LD_INT 108
101831: PUSH
101832: LD_INT 109
101834: PUSH
101835: LD_INT 110
101837: PUSH
101838: LD_INT 111
101840: PUSH
101841: LD_INT 112
101843: PUSH
101844: LD_INT 113
101846: PUSH
101847: LD_INT 114
101849: PUSH
101850: LD_INT 115
101852: PUSH
101853: LD_INT 116
101855: PUSH
101856: LD_INT 117
101858: PUSH
101859: LD_INT 118
101861: PUSH
101862: EMPTY
101863: LIST
101864: LIST
101865: LIST
101866: LIST
101867: LIST
101868: LIST
101869: LIST
101870: LIST
101871: LIST
101872: LIST
101873: LIST
101874: LIST
101875: LIST
101876: LIST
101877: LIST
101878: LIST
101879: LIST
101880: LIST
101881: PUSH
101882: EMPTY
101883: LIST
101884: LIST
101885: ST_TO_ADDR
// if result then
101886: LD_VAR 0 2
101890: IFFALSE 102676
// begin normal :=  ;
101892: LD_ADDR_VAR 0 5
101896: PUSH
101897: LD_STRING 
101899: ST_TO_ADDR
// hardcore :=  ;
101900: LD_ADDR_VAR 0 6
101904: PUSH
101905: LD_STRING 
101907: ST_TO_ADDR
// active :=  ;
101908: LD_ADDR_VAR 0 7
101912: PUSH
101913: LD_STRING 
101915: ST_TO_ADDR
// for i = 1 to normalCounter do
101916: LD_ADDR_VAR 0 8
101920: PUSH
101921: DOUBLE
101922: LD_INT 1
101924: DEC
101925: ST_TO_ADDR
101926: LD_EXP 127
101930: PUSH
101931: FOR_TO
101932: IFFALSE 102033
// begin tmp := 0 ;
101934: LD_ADDR_VAR 0 3
101938: PUSH
101939: LD_STRING 0
101941: ST_TO_ADDR
// if result [ 1 ] then
101942: LD_VAR 0 2
101946: PUSH
101947: LD_INT 1
101949: ARRAY
101950: IFFALSE 102015
// if result [ 1 ] [ 1 ] = i then
101952: LD_VAR 0 2
101956: PUSH
101957: LD_INT 1
101959: ARRAY
101960: PUSH
101961: LD_INT 1
101963: ARRAY
101964: PUSH
101965: LD_VAR 0 8
101969: EQUAL
101970: IFFALSE 102015
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
101972: LD_ADDR_VAR 0 2
101976: PUSH
101977: LD_VAR 0 2
101981: PPUSH
101982: LD_INT 1
101984: PPUSH
101985: LD_VAR 0 2
101989: PUSH
101990: LD_INT 1
101992: ARRAY
101993: PPUSH
101994: LD_INT 1
101996: PPUSH
101997: CALL_OW 3
102001: PPUSH
102002: CALL_OW 1
102006: ST_TO_ADDR
// tmp := 1 ;
102007: LD_ADDR_VAR 0 3
102011: PUSH
102012: LD_STRING 1
102014: ST_TO_ADDR
// end ; normal := normal & tmp ;
102015: LD_ADDR_VAR 0 5
102019: PUSH
102020: LD_VAR 0 5
102024: PUSH
102025: LD_VAR 0 3
102029: STR
102030: ST_TO_ADDR
// end ;
102031: GO 101931
102033: POP
102034: POP
// for i = 1 to hardcoreCounter do
102035: LD_ADDR_VAR 0 8
102039: PUSH
102040: DOUBLE
102041: LD_INT 1
102043: DEC
102044: ST_TO_ADDR
102045: LD_EXP 128
102049: PUSH
102050: FOR_TO
102051: IFFALSE 102156
// begin tmp := 0 ;
102053: LD_ADDR_VAR 0 3
102057: PUSH
102058: LD_STRING 0
102060: ST_TO_ADDR
// if result [ 2 ] then
102061: LD_VAR 0 2
102065: PUSH
102066: LD_INT 2
102068: ARRAY
102069: IFFALSE 102138
// if result [ 2 ] [ 1 ] = 100 + i then
102071: LD_VAR 0 2
102075: PUSH
102076: LD_INT 2
102078: ARRAY
102079: PUSH
102080: LD_INT 1
102082: ARRAY
102083: PUSH
102084: LD_INT 100
102086: PUSH
102087: LD_VAR 0 8
102091: PLUS
102092: EQUAL
102093: IFFALSE 102138
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
102095: LD_ADDR_VAR 0 2
102099: PUSH
102100: LD_VAR 0 2
102104: PPUSH
102105: LD_INT 2
102107: PPUSH
102108: LD_VAR 0 2
102112: PUSH
102113: LD_INT 2
102115: ARRAY
102116: PPUSH
102117: LD_INT 1
102119: PPUSH
102120: CALL_OW 3
102124: PPUSH
102125: CALL_OW 1
102129: ST_TO_ADDR
// tmp := 1 ;
102130: LD_ADDR_VAR 0 3
102134: PUSH
102135: LD_STRING 1
102137: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
102138: LD_ADDR_VAR 0 6
102142: PUSH
102143: LD_VAR 0 6
102147: PUSH
102148: LD_VAR 0 3
102152: STR
102153: ST_TO_ADDR
// end ;
102154: GO 102050
102156: POP
102157: POP
// if isGameLoad then
102158: LD_VAR 0 1
102162: IFFALSE 102637
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
102164: LD_ADDR_VAR 0 4
102168: PUSH
102169: LD_EXP 131
102173: PUSH
102174: LD_EXP 130
102178: PUSH
102179: LD_EXP 132
102183: PUSH
102184: LD_EXP 129
102188: PUSH
102189: LD_EXP 133
102193: PUSH
102194: LD_EXP 134
102198: PUSH
102199: LD_EXP 135
102203: PUSH
102204: LD_EXP 136
102208: PUSH
102209: LD_EXP 137
102213: PUSH
102214: LD_EXP 138
102218: PUSH
102219: LD_EXP 139
102223: PUSH
102224: LD_EXP 140
102228: PUSH
102229: LD_EXP 141
102233: PUSH
102234: LD_EXP 142
102238: PUSH
102239: LD_EXP 150
102243: PUSH
102244: LD_EXP 151
102248: PUSH
102249: LD_EXP 152
102253: PUSH
102254: LD_EXP 153
102258: PUSH
102259: LD_EXP 155
102263: PUSH
102264: LD_EXP 156
102268: PUSH
102269: LD_EXP 157
102273: PUSH
102274: LD_EXP 160
102278: PUSH
102279: LD_EXP 162
102283: PUSH
102284: LD_EXP 163
102288: PUSH
102289: LD_EXP 164
102293: PUSH
102294: LD_EXP 166
102298: PUSH
102299: LD_EXP 167
102303: PUSH
102304: LD_EXP 170
102308: PUSH
102309: LD_EXP 171
102313: PUSH
102314: LD_EXP 172
102318: PUSH
102319: LD_EXP 173
102323: PUSH
102324: LD_EXP 174
102328: PUSH
102329: LD_EXP 175
102333: PUSH
102334: LD_EXP 176
102338: PUSH
102339: LD_EXP 177
102343: PUSH
102344: LD_EXP 178
102348: PUSH
102349: LD_EXP 143
102353: PUSH
102354: LD_EXP 144
102358: PUSH
102359: LD_EXP 147
102363: PUSH
102364: LD_EXP 148
102368: PUSH
102369: LD_EXP 149
102373: PUSH
102374: LD_EXP 145
102378: PUSH
102379: LD_EXP 146
102383: PUSH
102384: LD_EXP 154
102388: PUSH
102389: LD_EXP 158
102393: PUSH
102394: LD_EXP 159
102398: PUSH
102399: LD_EXP 161
102403: PUSH
102404: LD_EXP 165
102408: PUSH
102409: LD_EXP 168
102413: PUSH
102414: LD_EXP 169
102418: PUSH
102419: LD_EXP 179
102423: PUSH
102424: LD_EXP 180
102428: PUSH
102429: LD_EXP 181
102433: PUSH
102434: LD_EXP 182
102438: PUSH
102439: EMPTY
102440: LIST
102441: LIST
102442: LIST
102443: LIST
102444: LIST
102445: LIST
102446: LIST
102447: LIST
102448: LIST
102449: LIST
102450: LIST
102451: LIST
102452: LIST
102453: LIST
102454: LIST
102455: LIST
102456: LIST
102457: LIST
102458: LIST
102459: LIST
102460: LIST
102461: LIST
102462: LIST
102463: LIST
102464: LIST
102465: LIST
102466: LIST
102467: LIST
102468: LIST
102469: LIST
102470: LIST
102471: LIST
102472: LIST
102473: LIST
102474: LIST
102475: LIST
102476: LIST
102477: LIST
102478: LIST
102479: LIST
102480: LIST
102481: LIST
102482: LIST
102483: LIST
102484: LIST
102485: LIST
102486: LIST
102487: LIST
102488: LIST
102489: LIST
102490: LIST
102491: LIST
102492: LIST
102493: LIST
102494: ST_TO_ADDR
// tmp :=  ;
102495: LD_ADDR_VAR 0 3
102499: PUSH
102500: LD_STRING 
102502: ST_TO_ADDR
// for i = 1 to normalCounter do
102503: LD_ADDR_VAR 0 8
102507: PUSH
102508: DOUBLE
102509: LD_INT 1
102511: DEC
102512: ST_TO_ADDR
102513: LD_EXP 127
102517: PUSH
102518: FOR_TO
102519: IFFALSE 102555
// begin if flags [ i ] then
102521: LD_VAR 0 4
102525: PUSH
102526: LD_VAR 0 8
102530: ARRAY
102531: IFFALSE 102553
// tmp := tmp & i & ; ;
102533: LD_ADDR_VAR 0 3
102537: PUSH
102538: LD_VAR 0 3
102542: PUSH
102543: LD_VAR 0 8
102547: STR
102548: PUSH
102549: LD_STRING ;
102551: STR
102552: ST_TO_ADDR
// end ;
102553: GO 102518
102555: POP
102556: POP
// for i = 1 to hardcoreCounter do
102557: LD_ADDR_VAR 0 8
102561: PUSH
102562: DOUBLE
102563: LD_INT 1
102565: DEC
102566: ST_TO_ADDR
102567: LD_EXP 128
102571: PUSH
102572: FOR_TO
102573: IFFALSE 102619
// begin if flags [ normalCounter + i ] then
102575: LD_VAR 0 4
102579: PUSH
102580: LD_EXP 127
102584: PUSH
102585: LD_VAR 0 8
102589: PLUS
102590: ARRAY
102591: IFFALSE 102617
// tmp := tmp & ( 100 + i ) & ; ;
102593: LD_ADDR_VAR 0 3
102597: PUSH
102598: LD_VAR 0 3
102602: PUSH
102603: LD_INT 100
102605: PUSH
102606: LD_VAR 0 8
102610: PLUS
102611: STR
102612: PUSH
102613: LD_STRING ;
102615: STR
102616: ST_TO_ADDR
// end ;
102617: GO 102572
102619: POP
102620: POP
// if tmp then
102621: LD_VAR 0 3
102625: IFFALSE 102637
// active := tmp ;
102627: LD_ADDR_VAR 0 7
102631: PUSH
102632: LD_VAR 0 3
102636: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
102637: LD_STRING getStreamItemsFromMission("
102639: PUSH
102640: LD_VAR 0 5
102644: STR
102645: PUSH
102646: LD_STRING ","
102648: STR
102649: PUSH
102650: LD_VAR 0 6
102654: STR
102655: PUSH
102656: LD_STRING ","
102658: STR
102659: PUSH
102660: LD_VAR 0 7
102664: STR
102665: PUSH
102666: LD_STRING ")
102668: STR
102669: PPUSH
102670: CALL_OW 559
// end else
102674: GO 102683
// ToLua ( getStreamItemsFromMission("","","") ) ;
102676: LD_STRING getStreamItemsFromMission("","","")
102678: PPUSH
102679: CALL_OW 559
// end ;
102683: LD_VAR 0 2
102687: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
102688: LD_EXP 126
102692: PUSH
102693: LD_EXP 131
102697: AND
102698: IFFALSE 102822
102700: GO 102702
102702: DISABLE
102703: LD_INT 0
102705: PPUSH
102706: PPUSH
// begin enable ;
102707: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
102708: LD_ADDR_VAR 0 2
102712: PUSH
102713: LD_INT 22
102715: PUSH
102716: LD_OWVAR 2
102720: PUSH
102721: EMPTY
102722: LIST
102723: LIST
102724: PUSH
102725: LD_INT 2
102727: PUSH
102728: LD_INT 34
102730: PUSH
102731: LD_INT 7
102733: PUSH
102734: EMPTY
102735: LIST
102736: LIST
102737: PUSH
102738: LD_INT 34
102740: PUSH
102741: LD_INT 45
102743: PUSH
102744: EMPTY
102745: LIST
102746: LIST
102747: PUSH
102748: LD_INT 34
102750: PUSH
102751: LD_INT 28
102753: PUSH
102754: EMPTY
102755: LIST
102756: LIST
102757: PUSH
102758: LD_INT 34
102760: PUSH
102761: LD_INT 47
102763: PUSH
102764: EMPTY
102765: LIST
102766: LIST
102767: PUSH
102768: EMPTY
102769: LIST
102770: LIST
102771: LIST
102772: LIST
102773: LIST
102774: PUSH
102775: EMPTY
102776: LIST
102777: LIST
102778: PPUSH
102779: CALL_OW 69
102783: ST_TO_ADDR
// if not tmp then
102784: LD_VAR 0 2
102788: NOT
102789: IFFALSE 102793
// exit ;
102791: GO 102822
// for i in tmp do
102793: LD_ADDR_VAR 0 1
102797: PUSH
102798: LD_VAR 0 2
102802: PUSH
102803: FOR_IN
102804: IFFALSE 102820
// begin SetLives ( i , 0 ) ;
102806: LD_VAR 0 1
102810: PPUSH
102811: LD_INT 0
102813: PPUSH
102814: CALL_OW 234
// end ;
102818: GO 102803
102820: POP
102821: POP
// end ;
102822: PPOPN 2
102824: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
102825: LD_EXP 126
102829: PUSH
102830: LD_EXP 132
102834: AND
102835: IFFALSE 102919
102837: GO 102839
102839: DISABLE
102840: LD_INT 0
102842: PPUSH
102843: PPUSH
// begin enable ;
102844: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
102845: LD_ADDR_VAR 0 2
102849: PUSH
102850: LD_INT 22
102852: PUSH
102853: LD_OWVAR 2
102857: PUSH
102858: EMPTY
102859: LIST
102860: LIST
102861: PUSH
102862: LD_INT 32
102864: PUSH
102865: LD_INT 3
102867: PUSH
102868: EMPTY
102869: LIST
102870: LIST
102871: PUSH
102872: EMPTY
102873: LIST
102874: LIST
102875: PPUSH
102876: CALL_OW 69
102880: ST_TO_ADDR
// if not tmp then
102881: LD_VAR 0 2
102885: NOT
102886: IFFALSE 102890
// exit ;
102888: GO 102919
// for i in tmp do
102890: LD_ADDR_VAR 0 1
102894: PUSH
102895: LD_VAR 0 2
102899: PUSH
102900: FOR_IN
102901: IFFALSE 102917
// begin SetLives ( i , 0 ) ;
102903: LD_VAR 0 1
102907: PPUSH
102908: LD_INT 0
102910: PPUSH
102911: CALL_OW 234
// end ;
102915: GO 102900
102917: POP
102918: POP
// end ;
102919: PPOPN 2
102921: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
102922: LD_EXP 126
102926: PUSH
102927: LD_EXP 129
102931: AND
102932: IFFALSE 103025
102934: GO 102936
102936: DISABLE
102937: LD_INT 0
102939: PPUSH
// begin enable ;
102940: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
102941: LD_ADDR_VAR 0 1
102945: PUSH
102946: LD_INT 22
102948: PUSH
102949: LD_OWVAR 2
102953: PUSH
102954: EMPTY
102955: LIST
102956: LIST
102957: PUSH
102958: LD_INT 2
102960: PUSH
102961: LD_INT 25
102963: PUSH
102964: LD_INT 5
102966: PUSH
102967: EMPTY
102968: LIST
102969: LIST
102970: PUSH
102971: LD_INT 25
102973: PUSH
102974: LD_INT 9
102976: PUSH
102977: EMPTY
102978: LIST
102979: LIST
102980: PUSH
102981: LD_INT 25
102983: PUSH
102984: LD_INT 8
102986: PUSH
102987: EMPTY
102988: LIST
102989: LIST
102990: PUSH
102991: EMPTY
102992: LIST
102993: LIST
102994: LIST
102995: LIST
102996: PUSH
102997: EMPTY
102998: LIST
102999: LIST
103000: PPUSH
103001: CALL_OW 69
103005: PUSH
103006: FOR_IN
103007: IFFALSE 103023
// begin SetClass ( i , 1 ) ;
103009: LD_VAR 0 1
103013: PPUSH
103014: LD_INT 1
103016: PPUSH
103017: CALL_OW 336
// end ;
103021: GO 103006
103023: POP
103024: POP
// end ;
103025: PPOPN 1
103027: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
103028: LD_EXP 126
103032: PUSH
103033: LD_EXP 130
103037: AND
103038: PUSH
103039: LD_OWVAR 65
103043: PUSH
103044: LD_INT 7
103046: LESS
103047: AND
103048: IFFALSE 103062
103050: GO 103052
103052: DISABLE
// begin enable ;
103053: ENABLE
// game_speed := 7 ;
103054: LD_ADDR_OWVAR 65
103058: PUSH
103059: LD_INT 7
103061: ST_TO_ADDR
// end ;
103062: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
103063: LD_EXP 126
103067: PUSH
103068: LD_EXP 133
103072: AND
103073: IFFALSE 103275
103075: GO 103077
103077: DISABLE
103078: LD_INT 0
103080: PPUSH
103081: PPUSH
103082: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103083: LD_ADDR_VAR 0 3
103087: PUSH
103088: LD_INT 81
103090: PUSH
103091: LD_OWVAR 2
103095: PUSH
103096: EMPTY
103097: LIST
103098: LIST
103099: PUSH
103100: LD_INT 21
103102: PUSH
103103: LD_INT 1
103105: PUSH
103106: EMPTY
103107: LIST
103108: LIST
103109: PUSH
103110: EMPTY
103111: LIST
103112: LIST
103113: PPUSH
103114: CALL_OW 69
103118: ST_TO_ADDR
// if not tmp then
103119: LD_VAR 0 3
103123: NOT
103124: IFFALSE 103128
// exit ;
103126: GO 103275
// if tmp > 5 then
103128: LD_VAR 0 3
103132: PUSH
103133: LD_INT 5
103135: GREATER
103136: IFFALSE 103148
// k := 5 else
103138: LD_ADDR_VAR 0 2
103142: PUSH
103143: LD_INT 5
103145: ST_TO_ADDR
103146: GO 103158
// k := tmp ;
103148: LD_ADDR_VAR 0 2
103152: PUSH
103153: LD_VAR 0 3
103157: ST_TO_ADDR
// for i := 1 to k do
103158: LD_ADDR_VAR 0 1
103162: PUSH
103163: DOUBLE
103164: LD_INT 1
103166: DEC
103167: ST_TO_ADDR
103168: LD_VAR 0 2
103172: PUSH
103173: FOR_TO
103174: IFFALSE 103273
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
103176: LD_VAR 0 3
103180: PUSH
103181: LD_VAR 0 1
103185: ARRAY
103186: PPUSH
103187: LD_VAR 0 1
103191: PUSH
103192: LD_INT 4
103194: MOD
103195: PUSH
103196: LD_INT 1
103198: PLUS
103199: PPUSH
103200: CALL_OW 259
103204: PUSH
103205: LD_INT 10
103207: LESS
103208: IFFALSE 103271
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
103210: LD_VAR 0 3
103214: PUSH
103215: LD_VAR 0 1
103219: ARRAY
103220: PPUSH
103221: LD_VAR 0 1
103225: PUSH
103226: LD_INT 4
103228: MOD
103229: PUSH
103230: LD_INT 1
103232: PLUS
103233: PPUSH
103234: LD_VAR 0 3
103238: PUSH
103239: LD_VAR 0 1
103243: ARRAY
103244: PPUSH
103245: LD_VAR 0 1
103249: PUSH
103250: LD_INT 4
103252: MOD
103253: PUSH
103254: LD_INT 1
103256: PLUS
103257: PPUSH
103258: CALL_OW 259
103262: PUSH
103263: LD_INT 1
103265: PLUS
103266: PPUSH
103267: CALL_OW 237
103271: GO 103173
103273: POP
103274: POP
// end ;
103275: PPOPN 3
103277: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
103278: LD_EXP 126
103282: PUSH
103283: LD_EXP 134
103287: AND
103288: IFFALSE 103308
103290: GO 103292
103292: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
103293: LD_INT 4
103295: PPUSH
103296: LD_OWVAR 2
103300: PPUSH
103301: LD_INT 0
103303: PPUSH
103304: CALL_OW 324
103308: END
// every 0 0$1 trigger StreamModeActive and sShovel do
103309: LD_EXP 126
103313: PUSH
103314: LD_EXP 163
103318: AND
103319: IFFALSE 103339
103321: GO 103323
103323: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
103324: LD_INT 19
103326: PPUSH
103327: LD_OWVAR 2
103331: PPUSH
103332: LD_INT 0
103334: PPUSH
103335: CALL_OW 324
103339: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
103340: LD_EXP 126
103344: PUSH
103345: LD_EXP 135
103349: AND
103350: IFFALSE 103452
103352: GO 103354
103354: DISABLE
103355: LD_INT 0
103357: PPUSH
103358: PPUSH
// begin enable ;
103359: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
103360: LD_ADDR_VAR 0 2
103364: PUSH
103365: LD_INT 22
103367: PUSH
103368: LD_OWVAR 2
103372: PUSH
103373: EMPTY
103374: LIST
103375: LIST
103376: PUSH
103377: LD_INT 2
103379: PUSH
103380: LD_INT 34
103382: PUSH
103383: LD_INT 11
103385: PUSH
103386: EMPTY
103387: LIST
103388: LIST
103389: PUSH
103390: LD_INT 34
103392: PUSH
103393: LD_INT 30
103395: PUSH
103396: EMPTY
103397: LIST
103398: LIST
103399: PUSH
103400: EMPTY
103401: LIST
103402: LIST
103403: LIST
103404: PUSH
103405: EMPTY
103406: LIST
103407: LIST
103408: PPUSH
103409: CALL_OW 69
103413: ST_TO_ADDR
// if not tmp then
103414: LD_VAR 0 2
103418: NOT
103419: IFFALSE 103423
// exit ;
103421: GO 103452
// for i in tmp do
103423: LD_ADDR_VAR 0 1
103427: PUSH
103428: LD_VAR 0 2
103432: PUSH
103433: FOR_IN
103434: IFFALSE 103450
// begin SetLives ( i , 0 ) ;
103436: LD_VAR 0 1
103440: PPUSH
103441: LD_INT 0
103443: PPUSH
103444: CALL_OW 234
// end ;
103448: GO 103433
103450: POP
103451: POP
// end ;
103452: PPOPN 2
103454: END
// every 0 0$1 trigger StreamModeActive and sBunker do
103455: LD_EXP 126
103459: PUSH
103460: LD_EXP 136
103464: AND
103465: IFFALSE 103485
103467: GO 103469
103469: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
103470: LD_INT 32
103472: PPUSH
103473: LD_OWVAR 2
103477: PPUSH
103478: LD_INT 0
103480: PPUSH
103481: CALL_OW 324
103485: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
103486: LD_EXP 126
103490: PUSH
103491: LD_EXP 137
103495: AND
103496: IFFALSE 103677
103498: GO 103500
103500: DISABLE
103501: LD_INT 0
103503: PPUSH
103504: PPUSH
103505: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
103506: LD_ADDR_VAR 0 2
103510: PUSH
103511: LD_INT 22
103513: PUSH
103514: LD_OWVAR 2
103518: PUSH
103519: EMPTY
103520: LIST
103521: LIST
103522: PUSH
103523: LD_INT 33
103525: PUSH
103526: LD_INT 3
103528: PUSH
103529: EMPTY
103530: LIST
103531: LIST
103532: PUSH
103533: EMPTY
103534: LIST
103535: LIST
103536: PPUSH
103537: CALL_OW 69
103541: ST_TO_ADDR
// if not tmp then
103542: LD_VAR 0 2
103546: NOT
103547: IFFALSE 103551
// exit ;
103549: GO 103677
// side := 0 ;
103551: LD_ADDR_VAR 0 3
103555: PUSH
103556: LD_INT 0
103558: ST_TO_ADDR
// for i := 1 to 8 do
103559: LD_ADDR_VAR 0 1
103563: PUSH
103564: DOUBLE
103565: LD_INT 1
103567: DEC
103568: ST_TO_ADDR
103569: LD_INT 8
103571: PUSH
103572: FOR_TO
103573: IFFALSE 103621
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
103575: LD_OWVAR 2
103579: PUSH
103580: LD_VAR 0 1
103584: NONEQUAL
103585: PUSH
103586: LD_OWVAR 2
103590: PPUSH
103591: LD_VAR 0 1
103595: PPUSH
103596: CALL_OW 81
103600: PUSH
103601: LD_INT 2
103603: EQUAL
103604: AND
103605: IFFALSE 103619
// begin side := i ;
103607: LD_ADDR_VAR 0 3
103611: PUSH
103612: LD_VAR 0 1
103616: ST_TO_ADDR
// break ;
103617: GO 103621
// end ;
103619: GO 103572
103621: POP
103622: POP
// if not side then
103623: LD_VAR 0 3
103627: NOT
103628: IFFALSE 103632
// exit ;
103630: GO 103677
// for i := 1 to tmp do
103632: LD_ADDR_VAR 0 1
103636: PUSH
103637: DOUBLE
103638: LD_INT 1
103640: DEC
103641: ST_TO_ADDR
103642: LD_VAR 0 2
103646: PUSH
103647: FOR_TO
103648: IFFALSE 103675
// if Prob ( 60 ) then
103650: LD_INT 60
103652: PPUSH
103653: CALL_OW 13
103657: IFFALSE 103673
// SetSide ( i , side ) ;
103659: LD_VAR 0 1
103663: PPUSH
103664: LD_VAR 0 3
103668: PPUSH
103669: CALL_OW 235
103673: GO 103647
103675: POP
103676: POP
// end ;
103677: PPOPN 3
103679: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
103680: LD_EXP 126
103684: PUSH
103685: LD_EXP 139
103689: AND
103690: IFFALSE 103809
103692: GO 103694
103694: DISABLE
103695: LD_INT 0
103697: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
103698: LD_ADDR_VAR 0 1
103702: PUSH
103703: LD_INT 22
103705: PUSH
103706: LD_OWVAR 2
103710: PUSH
103711: EMPTY
103712: LIST
103713: LIST
103714: PUSH
103715: LD_INT 21
103717: PUSH
103718: LD_INT 1
103720: PUSH
103721: EMPTY
103722: LIST
103723: LIST
103724: PUSH
103725: LD_INT 3
103727: PUSH
103728: LD_INT 23
103730: PUSH
103731: LD_INT 0
103733: PUSH
103734: EMPTY
103735: LIST
103736: LIST
103737: PUSH
103738: EMPTY
103739: LIST
103740: LIST
103741: PUSH
103742: EMPTY
103743: LIST
103744: LIST
103745: LIST
103746: PPUSH
103747: CALL_OW 69
103751: PUSH
103752: FOR_IN
103753: IFFALSE 103807
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
103755: LD_VAR 0 1
103759: PPUSH
103760: CALL_OW 257
103764: PUSH
103765: LD_INT 1
103767: PUSH
103768: LD_INT 2
103770: PUSH
103771: LD_INT 3
103773: PUSH
103774: LD_INT 4
103776: PUSH
103777: EMPTY
103778: LIST
103779: LIST
103780: LIST
103781: LIST
103782: IN
103783: IFFALSE 103805
// SetClass ( un , rand ( 1 , 4 ) ) ;
103785: LD_VAR 0 1
103789: PPUSH
103790: LD_INT 1
103792: PPUSH
103793: LD_INT 4
103795: PPUSH
103796: CALL_OW 12
103800: PPUSH
103801: CALL_OW 336
103805: GO 103752
103807: POP
103808: POP
// end ;
103809: PPOPN 1
103811: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
103812: LD_EXP 126
103816: PUSH
103817: LD_EXP 138
103821: AND
103822: IFFALSE 103901
103824: GO 103826
103826: DISABLE
103827: LD_INT 0
103829: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
103830: LD_ADDR_VAR 0 1
103834: PUSH
103835: LD_INT 22
103837: PUSH
103838: LD_OWVAR 2
103842: PUSH
103843: EMPTY
103844: LIST
103845: LIST
103846: PUSH
103847: LD_INT 21
103849: PUSH
103850: LD_INT 3
103852: PUSH
103853: EMPTY
103854: LIST
103855: LIST
103856: PUSH
103857: EMPTY
103858: LIST
103859: LIST
103860: PPUSH
103861: CALL_OW 69
103865: ST_TO_ADDR
// if not tmp then
103866: LD_VAR 0 1
103870: NOT
103871: IFFALSE 103875
// exit ;
103873: GO 103901
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
103875: LD_VAR 0 1
103879: PUSH
103880: LD_INT 1
103882: PPUSH
103883: LD_VAR 0 1
103887: PPUSH
103888: CALL_OW 12
103892: ARRAY
103893: PPUSH
103894: LD_INT 100
103896: PPUSH
103897: CALL_OW 234
// end ;
103901: PPOPN 1
103903: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
103904: LD_EXP 126
103908: PUSH
103909: LD_EXP 140
103913: AND
103914: IFFALSE 104012
103916: GO 103918
103918: DISABLE
103919: LD_INT 0
103921: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103922: LD_ADDR_VAR 0 1
103926: PUSH
103927: LD_INT 22
103929: PUSH
103930: LD_OWVAR 2
103934: PUSH
103935: EMPTY
103936: LIST
103937: LIST
103938: PUSH
103939: LD_INT 21
103941: PUSH
103942: LD_INT 1
103944: PUSH
103945: EMPTY
103946: LIST
103947: LIST
103948: PUSH
103949: EMPTY
103950: LIST
103951: LIST
103952: PPUSH
103953: CALL_OW 69
103957: ST_TO_ADDR
// if not tmp then
103958: LD_VAR 0 1
103962: NOT
103963: IFFALSE 103967
// exit ;
103965: GO 104012
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
103967: LD_VAR 0 1
103971: PUSH
103972: LD_INT 1
103974: PPUSH
103975: LD_VAR 0 1
103979: PPUSH
103980: CALL_OW 12
103984: ARRAY
103985: PPUSH
103986: LD_INT 1
103988: PPUSH
103989: LD_INT 4
103991: PPUSH
103992: CALL_OW 12
103996: PPUSH
103997: LD_INT 3000
103999: PPUSH
104000: LD_INT 9000
104002: PPUSH
104003: CALL_OW 12
104007: PPUSH
104008: CALL_OW 492
// end ;
104012: PPOPN 1
104014: END
// every 0 0$1 trigger StreamModeActive and sDepot do
104015: LD_EXP 126
104019: PUSH
104020: LD_EXP 141
104024: AND
104025: IFFALSE 104045
104027: GO 104029
104029: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
104030: LD_INT 1
104032: PPUSH
104033: LD_OWVAR 2
104037: PPUSH
104038: LD_INT 0
104040: PPUSH
104041: CALL_OW 324
104045: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
104046: LD_EXP 126
104050: PUSH
104051: LD_EXP 142
104055: AND
104056: IFFALSE 104139
104058: GO 104060
104060: DISABLE
104061: LD_INT 0
104063: PPUSH
104064: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
104065: LD_ADDR_VAR 0 2
104069: PUSH
104070: LD_INT 22
104072: PUSH
104073: LD_OWVAR 2
104077: PUSH
104078: EMPTY
104079: LIST
104080: LIST
104081: PUSH
104082: LD_INT 21
104084: PUSH
104085: LD_INT 3
104087: PUSH
104088: EMPTY
104089: LIST
104090: LIST
104091: PUSH
104092: EMPTY
104093: LIST
104094: LIST
104095: PPUSH
104096: CALL_OW 69
104100: ST_TO_ADDR
// if not tmp then
104101: LD_VAR 0 2
104105: NOT
104106: IFFALSE 104110
// exit ;
104108: GO 104139
// for i in tmp do
104110: LD_ADDR_VAR 0 1
104114: PUSH
104115: LD_VAR 0 2
104119: PUSH
104120: FOR_IN
104121: IFFALSE 104137
// SetBLevel ( i , 10 ) ;
104123: LD_VAR 0 1
104127: PPUSH
104128: LD_INT 10
104130: PPUSH
104131: CALL_OW 241
104135: GO 104120
104137: POP
104138: POP
// end ;
104139: PPOPN 2
104141: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
104142: LD_EXP 126
104146: PUSH
104147: LD_EXP 143
104151: AND
104152: IFFALSE 104263
104154: GO 104156
104156: DISABLE
104157: LD_INT 0
104159: PPUSH
104160: PPUSH
104161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104162: LD_ADDR_VAR 0 3
104166: PUSH
104167: LD_INT 22
104169: PUSH
104170: LD_OWVAR 2
104174: PUSH
104175: EMPTY
104176: LIST
104177: LIST
104178: PUSH
104179: LD_INT 25
104181: PUSH
104182: LD_INT 1
104184: PUSH
104185: EMPTY
104186: LIST
104187: LIST
104188: PUSH
104189: EMPTY
104190: LIST
104191: LIST
104192: PPUSH
104193: CALL_OW 69
104197: ST_TO_ADDR
// if not tmp then
104198: LD_VAR 0 3
104202: NOT
104203: IFFALSE 104207
// exit ;
104205: GO 104263
// un := tmp [ rand ( 1 , tmp ) ] ;
104207: LD_ADDR_VAR 0 2
104211: PUSH
104212: LD_VAR 0 3
104216: PUSH
104217: LD_INT 1
104219: PPUSH
104220: LD_VAR 0 3
104224: PPUSH
104225: CALL_OW 12
104229: ARRAY
104230: ST_TO_ADDR
// if Crawls ( un ) then
104231: LD_VAR 0 2
104235: PPUSH
104236: CALL_OW 318
104240: IFFALSE 104251
// ComWalk ( un ) ;
104242: LD_VAR 0 2
104246: PPUSH
104247: CALL_OW 138
// SetClass ( un , class_sniper ) ;
104251: LD_VAR 0 2
104255: PPUSH
104256: LD_INT 5
104258: PPUSH
104259: CALL_OW 336
// end ;
104263: PPOPN 3
104265: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
104266: LD_EXP 126
104270: PUSH
104271: LD_EXP 144
104275: AND
104276: PUSH
104277: LD_OWVAR 67
104281: PUSH
104282: LD_INT 4
104284: LESS
104285: AND
104286: IFFALSE 104305
104288: GO 104290
104290: DISABLE
// begin Difficulty := Difficulty + 1 ;
104291: LD_ADDR_OWVAR 67
104295: PUSH
104296: LD_OWVAR 67
104300: PUSH
104301: LD_INT 1
104303: PLUS
104304: ST_TO_ADDR
// end ;
104305: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
104306: LD_EXP 126
104310: PUSH
104311: LD_EXP 145
104315: AND
104316: IFFALSE 104419
104318: GO 104320
104320: DISABLE
104321: LD_INT 0
104323: PPUSH
// begin for i := 1 to 5 do
104324: LD_ADDR_VAR 0 1
104328: PUSH
104329: DOUBLE
104330: LD_INT 1
104332: DEC
104333: ST_TO_ADDR
104334: LD_INT 5
104336: PUSH
104337: FOR_TO
104338: IFFALSE 104417
// begin uc_nation := nation_nature ;
104340: LD_ADDR_OWVAR 21
104344: PUSH
104345: LD_INT 0
104347: ST_TO_ADDR
// uc_side := 0 ;
104348: LD_ADDR_OWVAR 20
104352: PUSH
104353: LD_INT 0
104355: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
104356: LD_ADDR_OWVAR 29
104360: PUSH
104361: LD_INT 12
104363: PUSH
104364: LD_INT 12
104366: PUSH
104367: EMPTY
104368: LIST
104369: LIST
104370: ST_TO_ADDR
// hc_agressivity := 20 ;
104371: LD_ADDR_OWVAR 35
104375: PUSH
104376: LD_INT 20
104378: ST_TO_ADDR
// hc_class := class_tiger ;
104379: LD_ADDR_OWVAR 28
104383: PUSH
104384: LD_INT 14
104386: ST_TO_ADDR
// hc_gallery :=  ;
104387: LD_ADDR_OWVAR 33
104391: PUSH
104392: LD_STRING 
104394: ST_TO_ADDR
// hc_name :=  ;
104395: LD_ADDR_OWVAR 26
104399: PUSH
104400: LD_STRING 
104402: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
104403: CALL_OW 44
104407: PPUSH
104408: LD_INT 0
104410: PPUSH
104411: CALL_OW 51
// end ;
104415: GO 104337
104417: POP
104418: POP
// end ;
104419: PPOPN 1
104421: END
// every 0 0$1 trigger StreamModeActive and sBomb do
104422: LD_EXP 126
104426: PUSH
104427: LD_EXP 146
104431: AND
104432: IFFALSE 104441
104434: GO 104436
104436: DISABLE
// StreamSibBomb ;
104437: CALL 104442 0 0
104441: END
// export function StreamSibBomb ; var i , x , y ; begin
104442: LD_INT 0
104444: PPUSH
104445: PPUSH
104446: PPUSH
104447: PPUSH
// result := false ;
104448: LD_ADDR_VAR 0 1
104452: PUSH
104453: LD_INT 0
104455: ST_TO_ADDR
// for i := 1 to 16 do
104456: LD_ADDR_VAR 0 2
104460: PUSH
104461: DOUBLE
104462: LD_INT 1
104464: DEC
104465: ST_TO_ADDR
104466: LD_INT 16
104468: PUSH
104469: FOR_TO
104470: IFFALSE 104669
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
104472: LD_ADDR_VAR 0 3
104476: PUSH
104477: LD_INT 10
104479: PUSH
104480: LD_INT 20
104482: PUSH
104483: LD_INT 30
104485: PUSH
104486: LD_INT 40
104488: PUSH
104489: LD_INT 50
104491: PUSH
104492: LD_INT 60
104494: PUSH
104495: LD_INT 70
104497: PUSH
104498: LD_INT 80
104500: PUSH
104501: LD_INT 90
104503: PUSH
104504: LD_INT 100
104506: PUSH
104507: LD_INT 110
104509: PUSH
104510: LD_INT 120
104512: PUSH
104513: LD_INT 130
104515: PUSH
104516: LD_INT 140
104518: PUSH
104519: LD_INT 150
104521: PUSH
104522: EMPTY
104523: LIST
104524: LIST
104525: LIST
104526: LIST
104527: LIST
104528: LIST
104529: LIST
104530: LIST
104531: LIST
104532: LIST
104533: LIST
104534: LIST
104535: LIST
104536: LIST
104537: LIST
104538: PUSH
104539: LD_INT 1
104541: PPUSH
104542: LD_INT 15
104544: PPUSH
104545: CALL_OW 12
104549: ARRAY
104550: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
104551: LD_ADDR_VAR 0 4
104555: PUSH
104556: LD_INT 10
104558: PUSH
104559: LD_INT 20
104561: PUSH
104562: LD_INT 30
104564: PUSH
104565: LD_INT 40
104567: PUSH
104568: LD_INT 50
104570: PUSH
104571: LD_INT 60
104573: PUSH
104574: LD_INT 70
104576: PUSH
104577: LD_INT 80
104579: PUSH
104580: LD_INT 90
104582: PUSH
104583: LD_INT 100
104585: PUSH
104586: LD_INT 110
104588: PUSH
104589: LD_INT 120
104591: PUSH
104592: LD_INT 130
104594: PUSH
104595: LD_INT 140
104597: PUSH
104598: LD_INT 150
104600: PUSH
104601: EMPTY
104602: LIST
104603: LIST
104604: LIST
104605: LIST
104606: LIST
104607: LIST
104608: LIST
104609: LIST
104610: LIST
104611: LIST
104612: LIST
104613: LIST
104614: LIST
104615: LIST
104616: LIST
104617: PUSH
104618: LD_INT 1
104620: PPUSH
104621: LD_INT 15
104623: PPUSH
104624: CALL_OW 12
104628: ARRAY
104629: ST_TO_ADDR
// if ValidHex ( x , y ) then
104630: LD_VAR 0 3
104634: PPUSH
104635: LD_VAR 0 4
104639: PPUSH
104640: CALL_OW 488
104644: IFFALSE 104667
// begin result := [ x , y ] ;
104646: LD_ADDR_VAR 0 1
104650: PUSH
104651: LD_VAR 0 3
104655: PUSH
104656: LD_VAR 0 4
104660: PUSH
104661: EMPTY
104662: LIST
104663: LIST
104664: ST_TO_ADDR
// break ;
104665: GO 104669
// end ; end ;
104667: GO 104469
104669: POP
104670: POP
// if result then
104671: LD_VAR 0 1
104675: IFFALSE 104735
// begin ToLua ( playSibBomb() ) ;
104677: LD_STRING playSibBomb()
104679: PPUSH
104680: CALL_OW 559
// wait ( 0 0$14 ) ;
104684: LD_INT 490
104686: PPUSH
104687: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
104691: LD_VAR 0 1
104695: PUSH
104696: LD_INT 1
104698: ARRAY
104699: PPUSH
104700: LD_VAR 0 1
104704: PUSH
104705: LD_INT 2
104707: ARRAY
104708: PPUSH
104709: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
104713: LD_VAR 0 1
104717: PUSH
104718: LD_INT 1
104720: ARRAY
104721: PPUSH
104722: LD_VAR 0 1
104726: PUSH
104727: LD_INT 2
104729: ARRAY
104730: PPUSH
104731: CALL_OW 429
// end ; end ;
104735: LD_VAR 0 1
104739: RET
// every 0 0$1 trigger StreamModeActive and sReset do
104740: LD_EXP 126
104744: PUSH
104745: LD_EXP 148
104749: AND
104750: IFFALSE 104762
104752: GO 104754
104754: DISABLE
// YouLost (  ) ;
104755: LD_STRING 
104757: PPUSH
104758: CALL_OW 104
104762: END
// every 0 0$1 trigger StreamModeActive and sFog do
104763: LD_EXP 126
104767: PUSH
104768: LD_EXP 147
104772: AND
104773: IFFALSE 104787
104775: GO 104777
104777: DISABLE
// FogOff ( your_side ) ;
104778: LD_OWVAR 2
104782: PPUSH
104783: CALL_OW 344
104787: END
// every 0 0$1 trigger StreamModeActive and sSun do
104788: LD_EXP 126
104792: PUSH
104793: LD_EXP 149
104797: AND
104798: IFFALSE 104826
104800: GO 104802
104802: DISABLE
// begin solar_recharge_percent := 0 ;
104803: LD_ADDR_OWVAR 79
104807: PUSH
104808: LD_INT 0
104810: ST_TO_ADDR
// wait ( 5 5$00 ) ;
104811: LD_INT 10500
104813: PPUSH
104814: CALL_OW 67
// solar_recharge_percent := 100 ;
104818: LD_ADDR_OWVAR 79
104822: PUSH
104823: LD_INT 100
104825: ST_TO_ADDR
// end ;
104826: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
104827: LD_EXP 126
104831: PUSH
104832: LD_EXP 150
104836: AND
104837: IFFALSE 105076
104839: GO 104841
104841: DISABLE
104842: LD_INT 0
104844: PPUSH
104845: PPUSH
104846: PPUSH
// begin tmp := [ ] ;
104847: LD_ADDR_VAR 0 3
104851: PUSH
104852: EMPTY
104853: ST_TO_ADDR
// for i := 1 to 6 do
104854: LD_ADDR_VAR 0 1
104858: PUSH
104859: DOUBLE
104860: LD_INT 1
104862: DEC
104863: ST_TO_ADDR
104864: LD_INT 6
104866: PUSH
104867: FOR_TO
104868: IFFALSE 104973
// begin uc_nation := nation_nature ;
104870: LD_ADDR_OWVAR 21
104874: PUSH
104875: LD_INT 0
104877: ST_TO_ADDR
// uc_side := 0 ;
104878: LD_ADDR_OWVAR 20
104882: PUSH
104883: LD_INT 0
104885: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
104886: LD_ADDR_OWVAR 29
104890: PUSH
104891: LD_INT 12
104893: PUSH
104894: LD_INT 12
104896: PUSH
104897: EMPTY
104898: LIST
104899: LIST
104900: ST_TO_ADDR
// hc_agressivity := 20 ;
104901: LD_ADDR_OWVAR 35
104905: PUSH
104906: LD_INT 20
104908: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
104909: LD_ADDR_OWVAR 28
104913: PUSH
104914: LD_INT 17
104916: ST_TO_ADDR
// hc_gallery :=  ;
104917: LD_ADDR_OWVAR 33
104921: PUSH
104922: LD_STRING 
104924: ST_TO_ADDR
// hc_name :=  ;
104925: LD_ADDR_OWVAR 26
104929: PUSH
104930: LD_STRING 
104932: ST_TO_ADDR
// un := CreateHuman ;
104933: LD_ADDR_VAR 0 2
104937: PUSH
104938: CALL_OW 44
104942: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
104943: LD_VAR 0 2
104947: PPUSH
104948: LD_INT 1
104950: PPUSH
104951: CALL_OW 51
// tmp := tmp ^ un ;
104955: LD_ADDR_VAR 0 3
104959: PUSH
104960: LD_VAR 0 3
104964: PUSH
104965: LD_VAR 0 2
104969: ADD
104970: ST_TO_ADDR
// end ;
104971: GO 104867
104973: POP
104974: POP
// repeat wait ( 0 0$1 ) ;
104975: LD_INT 35
104977: PPUSH
104978: CALL_OW 67
// for un in tmp do
104982: LD_ADDR_VAR 0 2
104986: PUSH
104987: LD_VAR 0 3
104991: PUSH
104992: FOR_IN
104993: IFFALSE 105067
// begin if IsDead ( un ) then
104995: LD_VAR 0 2
104999: PPUSH
105000: CALL_OW 301
105004: IFFALSE 105024
// begin tmp := tmp diff un ;
105006: LD_ADDR_VAR 0 3
105010: PUSH
105011: LD_VAR 0 3
105015: PUSH
105016: LD_VAR 0 2
105020: DIFF
105021: ST_TO_ADDR
// continue ;
105022: GO 104992
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
105024: LD_VAR 0 2
105028: PPUSH
105029: LD_INT 3
105031: PUSH
105032: LD_INT 22
105034: PUSH
105035: LD_INT 0
105037: PUSH
105038: EMPTY
105039: LIST
105040: LIST
105041: PUSH
105042: EMPTY
105043: LIST
105044: LIST
105045: PPUSH
105046: CALL_OW 69
105050: PPUSH
105051: LD_VAR 0 2
105055: PPUSH
105056: CALL_OW 74
105060: PPUSH
105061: CALL_OW 115
// end ;
105065: GO 104992
105067: POP
105068: POP
// until not tmp ;
105069: LD_VAR 0 3
105073: NOT
105074: IFFALSE 104975
// end ;
105076: PPOPN 3
105078: END
// every 0 0$1 trigger StreamModeActive and sTroll do
105079: LD_EXP 126
105083: PUSH
105084: LD_EXP 151
105088: AND
105089: IFFALSE 105143
105091: GO 105093
105093: DISABLE
// begin ToLua ( displayTroll(); ) ;
105094: LD_STRING displayTroll();
105096: PPUSH
105097: CALL_OW 559
// wait ( 3 3$00 ) ;
105101: LD_INT 6300
105103: PPUSH
105104: CALL_OW 67
// ToLua ( hideTroll(); ) ;
105108: LD_STRING hideTroll();
105110: PPUSH
105111: CALL_OW 559
// wait ( 1 1$00 ) ;
105115: LD_INT 2100
105117: PPUSH
105118: CALL_OW 67
// ToLua ( displayTroll(); ) ;
105122: LD_STRING displayTroll();
105124: PPUSH
105125: CALL_OW 559
// wait ( 1 1$00 ) ;
105129: LD_INT 2100
105131: PPUSH
105132: CALL_OW 67
// ToLua ( hideTroll(); ) ;
105136: LD_STRING hideTroll();
105138: PPUSH
105139: CALL_OW 559
// end ;
105143: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
105144: LD_EXP 126
105148: PUSH
105149: LD_EXP 152
105153: AND
105154: IFFALSE 105217
105156: GO 105158
105158: DISABLE
105159: LD_INT 0
105161: PPUSH
// begin p := 0 ;
105162: LD_ADDR_VAR 0 1
105166: PUSH
105167: LD_INT 0
105169: ST_TO_ADDR
// repeat game_speed := 1 ;
105170: LD_ADDR_OWVAR 65
105174: PUSH
105175: LD_INT 1
105177: ST_TO_ADDR
// wait ( 0 0$1 ) ;
105178: LD_INT 35
105180: PPUSH
105181: CALL_OW 67
// p := p + 1 ;
105185: LD_ADDR_VAR 0 1
105189: PUSH
105190: LD_VAR 0 1
105194: PUSH
105195: LD_INT 1
105197: PLUS
105198: ST_TO_ADDR
// until p >= 60 ;
105199: LD_VAR 0 1
105203: PUSH
105204: LD_INT 60
105206: GREATEREQUAL
105207: IFFALSE 105170
// game_speed := 4 ;
105209: LD_ADDR_OWVAR 65
105213: PUSH
105214: LD_INT 4
105216: ST_TO_ADDR
// end ;
105217: PPOPN 1
105219: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
105220: LD_EXP 126
105224: PUSH
105225: LD_EXP 153
105229: AND
105230: IFFALSE 105376
105232: GO 105234
105234: DISABLE
105235: LD_INT 0
105237: PPUSH
105238: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105239: LD_ADDR_VAR 0 1
105243: PUSH
105244: LD_INT 22
105246: PUSH
105247: LD_OWVAR 2
105251: PUSH
105252: EMPTY
105253: LIST
105254: LIST
105255: PUSH
105256: LD_INT 2
105258: PUSH
105259: LD_INT 30
105261: PUSH
105262: LD_INT 0
105264: PUSH
105265: EMPTY
105266: LIST
105267: LIST
105268: PUSH
105269: LD_INT 30
105271: PUSH
105272: LD_INT 1
105274: PUSH
105275: EMPTY
105276: LIST
105277: LIST
105278: PUSH
105279: EMPTY
105280: LIST
105281: LIST
105282: LIST
105283: PUSH
105284: EMPTY
105285: LIST
105286: LIST
105287: PPUSH
105288: CALL_OW 69
105292: ST_TO_ADDR
// if not depot then
105293: LD_VAR 0 1
105297: NOT
105298: IFFALSE 105302
// exit ;
105300: GO 105376
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
105302: LD_ADDR_VAR 0 2
105306: PUSH
105307: LD_VAR 0 1
105311: PUSH
105312: LD_INT 1
105314: PPUSH
105315: LD_VAR 0 1
105319: PPUSH
105320: CALL_OW 12
105324: ARRAY
105325: PPUSH
105326: CALL_OW 274
105330: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
105331: LD_VAR 0 2
105335: PPUSH
105336: LD_INT 1
105338: PPUSH
105339: LD_INT 0
105341: PPUSH
105342: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
105346: LD_VAR 0 2
105350: PPUSH
105351: LD_INT 2
105353: PPUSH
105354: LD_INT 0
105356: PPUSH
105357: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
105361: LD_VAR 0 2
105365: PPUSH
105366: LD_INT 3
105368: PPUSH
105369: LD_INT 0
105371: PPUSH
105372: CALL_OW 277
// end ;
105376: PPOPN 2
105378: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
105379: LD_EXP 126
105383: PUSH
105384: LD_EXP 154
105388: AND
105389: IFFALSE 105486
105391: GO 105393
105393: DISABLE
105394: LD_INT 0
105396: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105397: LD_ADDR_VAR 0 1
105401: PUSH
105402: LD_INT 22
105404: PUSH
105405: LD_OWVAR 2
105409: PUSH
105410: EMPTY
105411: LIST
105412: LIST
105413: PUSH
105414: LD_INT 21
105416: PUSH
105417: LD_INT 1
105419: PUSH
105420: EMPTY
105421: LIST
105422: LIST
105423: PUSH
105424: LD_INT 3
105426: PUSH
105427: LD_INT 23
105429: PUSH
105430: LD_INT 0
105432: PUSH
105433: EMPTY
105434: LIST
105435: LIST
105436: PUSH
105437: EMPTY
105438: LIST
105439: LIST
105440: PUSH
105441: EMPTY
105442: LIST
105443: LIST
105444: LIST
105445: PPUSH
105446: CALL_OW 69
105450: ST_TO_ADDR
// if not tmp then
105451: LD_VAR 0 1
105455: NOT
105456: IFFALSE 105460
// exit ;
105458: GO 105486
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
105460: LD_VAR 0 1
105464: PUSH
105465: LD_INT 1
105467: PPUSH
105468: LD_VAR 0 1
105472: PPUSH
105473: CALL_OW 12
105477: ARRAY
105478: PPUSH
105479: LD_INT 200
105481: PPUSH
105482: CALL_OW 234
// end ;
105486: PPOPN 1
105488: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
105489: LD_EXP 126
105493: PUSH
105494: LD_EXP 155
105498: AND
105499: IFFALSE 105578
105501: GO 105503
105503: DISABLE
105504: LD_INT 0
105506: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
105507: LD_ADDR_VAR 0 1
105511: PUSH
105512: LD_INT 22
105514: PUSH
105515: LD_OWVAR 2
105519: PUSH
105520: EMPTY
105521: LIST
105522: LIST
105523: PUSH
105524: LD_INT 21
105526: PUSH
105527: LD_INT 2
105529: PUSH
105530: EMPTY
105531: LIST
105532: LIST
105533: PUSH
105534: EMPTY
105535: LIST
105536: LIST
105537: PPUSH
105538: CALL_OW 69
105542: ST_TO_ADDR
// if not tmp then
105543: LD_VAR 0 1
105547: NOT
105548: IFFALSE 105552
// exit ;
105550: GO 105578
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
105552: LD_VAR 0 1
105556: PUSH
105557: LD_INT 1
105559: PPUSH
105560: LD_VAR 0 1
105564: PPUSH
105565: CALL_OW 12
105569: ARRAY
105570: PPUSH
105571: LD_INT 60
105573: PPUSH
105574: CALL_OW 234
// end ;
105578: PPOPN 1
105580: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
105581: LD_EXP 126
105585: PUSH
105586: LD_EXP 156
105590: AND
105591: IFFALSE 105690
105593: GO 105595
105595: DISABLE
105596: LD_INT 0
105598: PPUSH
105599: PPUSH
// begin enable ;
105600: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
105601: LD_ADDR_VAR 0 1
105605: PUSH
105606: LD_INT 22
105608: PUSH
105609: LD_OWVAR 2
105613: PUSH
105614: EMPTY
105615: LIST
105616: LIST
105617: PUSH
105618: LD_INT 61
105620: PUSH
105621: EMPTY
105622: LIST
105623: PUSH
105624: LD_INT 33
105626: PUSH
105627: LD_INT 2
105629: PUSH
105630: EMPTY
105631: LIST
105632: LIST
105633: PUSH
105634: EMPTY
105635: LIST
105636: LIST
105637: LIST
105638: PPUSH
105639: CALL_OW 69
105643: ST_TO_ADDR
// if not tmp then
105644: LD_VAR 0 1
105648: NOT
105649: IFFALSE 105653
// exit ;
105651: GO 105690
// for i in tmp do
105653: LD_ADDR_VAR 0 2
105657: PUSH
105658: LD_VAR 0 1
105662: PUSH
105663: FOR_IN
105664: IFFALSE 105688
// if IsControledBy ( i ) then
105666: LD_VAR 0 2
105670: PPUSH
105671: CALL_OW 312
105675: IFFALSE 105686
// ComUnlink ( i ) ;
105677: LD_VAR 0 2
105681: PPUSH
105682: CALL_OW 136
105686: GO 105663
105688: POP
105689: POP
// end ;
105690: PPOPN 2
105692: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
105693: LD_EXP 126
105697: PUSH
105698: LD_EXP 157
105702: AND
105703: IFFALSE 105843
105705: GO 105707
105707: DISABLE
105708: LD_INT 0
105710: PPUSH
105711: PPUSH
// begin ToLua ( displayPowell(); ) ;
105712: LD_STRING displayPowell();
105714: PPUSH
105715: CALL_OW 559
// uc_side := 0 ;
105719: LD_ADDR_OWVAR 20
105723: PUSH
105724: LD_INT 0
105726: ST_TO_ADDR
// uc_nation := 2 ;
105727: LD_ADDR_OWVAR 21
105731: PUSH
105732: LD_INT 2
105734: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
105735: LD_ADDR_OWVAR 37
105739: PUSH
105740: LD_INT 14
105742: ST_TO_ADDR
// vc_engine := engine_siberite ;
105743: LD_ADDR_OWVAR 39
105747: PUSH
105748: LD_INT 3
105750: ST_TO_ADDR
// vc_control := control_apeman ;
105751: LD_ADDR_OWVAR 38
105755: PUSH
105756: LD_INT 5
105758: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
105759: LD_ADDR_OWVAR 40
105763: PUSH
105764: LD_INT 29
105766: ST_TO_ADDR
// un := CreateVehicle ;
105767: LD_ADDR_VAR 0 2
105771: PUSH
105772: CALL_OW 45
105776: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105777: LD_VAR 0 2
105781: PPUSH
105782: LD_INT 1
105784: PPUSH
105785: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
105789: LD_INT 35
105791: PPUSH
105792: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
105796: LD_VAR 0 2
105800: PPUSH
105801: LD_INT 22
105803: PUSH
105804: LD_OWVAR 2
105808: PUSH
105809: EMPTY
105810: LIST
105811: LIST
105812: PPUSH
105813: CALL_OW 69
105817: PPUSH
105818: LD_VAR 0 2
105822: PPUSH
105823: CALL_OW 74
105827: PPUSH
105828: CALL_OW 115
// until IsDead ( un ) ;
105832: LD_VAR 0 2
105836: PPUSH
105837: CALL_OW 301
105841: IFFALSE 105789
// end ;
105843: PPOPN 2
105845: END
// every 0 0$1 trigger StreamModeActive and sStu do
105846: LD_EXP 126
105850: PUSH
105851: LD_EXP 165
105855: AND
105856: IFFALSE 105872
105858: GO 105860
105860: DISABLE
// begin ToLua ( displayStucuk(); ) ;
105861: LD_STRING displayStucuk();
105863: PPUSH
105864: CALL_OW 559
// ResetFog ;
105868: CALL_OW 335
// end ;
105872: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
105873: LD_EXP 126
105877: PUSH
105878: LD_EXP 158
105882: AND
105883: IFFALSE 106024
105885: GO 105887
105887: DISABLE
105888: LD_INT 0
105890: PPUSH
105891: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105892: LD_ADDR_VAR 0 2
105896: PUSH
105897: LD_INT 22
105899: PUSH
105900: LD_OWVAR 2
105904: PUSH
105905: EMPTY
105906: LIST
105907: LIST
105908: PUSH
105909: LD_INT 21
105911: PUSH
105912: LD_INT 1
105914: PUSH
105915: EMPTY
105916: LIST
105917: LIST
105918: PUSH
105919: EMPTY
105920: LIST
105921: LIST
105922: PPUSH
105923: CALL_OW 69
105927: ST_TO_ADDR
// if not tmp then
105928: LD_VAR 0 2
105932: NOT
105933: IFFALSE 105937
// exit ;
105935: GO 106024
// un := tmp [ rand ( 1 , tmp ) ] ;
105937: LD_ADDR_VAR 0 1
105941: PUSH
105942: LD_VAR 0 2
105946: PUSH
105947: LD_INT 1
105949: PPUSH
105950: LD_VAR 0 2
105954: PPUSH
105955: CALL_OW 12
105959: ARRAY
105960: ST_TO_ADDR
// SetSide ( un , 0 ) ;
105961: LD_VAR 0 1
105965: PPUSH
105966: LD_INT 0
105968: PPUSH
105969: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
105973: LD_VAR 0 1
105977: PPUSH
105978: LD_OWVAR 3
105982: PUSH
105983: LD_VAR 0 1
105987: DIFF
105988: PPUSH
105989: LD_VAR 0 1
105993: PPUSH
105994: CALL_OW 74
105998: PPUSH
105999: CALL_OW 115
// wait ( 0 0$20 ) ;
106003: LD_INT 700
106005: PPUSH
106006: CALL_OW 67
// SetSide ( un , your_side ) ;
106010: LD_VAR 0 1
106014: PPUSH
106015: LD_OWVAR 2
106019: PPUSH
106020: CALL_OW 235
// end ;
106024: PPOPN 2
106026: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
106027: LD_EXP 126
106031: PUSH
106032: LD_EXP 159
106036: AND
106037: IFFALSE 106143
106039: GO 106041
106041: DISABLE
106042: LD_INT 0
106044: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106045: LD_ADDR_VAR 0 1
106049: PUSH
106050: LD_INT 22
106052: PUSH
106053: LD_OWVAR 2
106057: PUSH
106058: EMPTY
106059: LIST
106060: LIST
106061: PUSH
106062: LD_INT 2
106064: PUSH
106065: LD_INT 30
106067: PUSH
106068: LD_INT 0
106070: PUSH
106071: EMPTY
106072: LIST
106073: LIST
106074: PUSH
106075: LD_INT 30
106077: PUSH
106078: LD_INT 1
106080: PUSH
106081: EMPTY
106082: LIST
106083: LIST
106084: PUSH
106085: EMPTY
106086: LIST
106087: LIST
106088: LIST
106089: PUSH
106090: EMPTY
106091: LIST
106092: LIST
106093: PPUSH
106094: CALL_OW 69
106098: ST_TO_ADDR
// if not depot then
106099: LD_VAR 0 1
106103: NOT
106104: IFFALSE 106108
// exit ;
106106: GO 106143
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
106108: LD_VAR 0 1
106112: PUSH
106113: LD_INT 1
106115: ARRAY
106116: PPUSH
106117: CALL_OW 250
106121: PPUSH
106122: LD_VAR 0 1
106126: PUSH
106127: LD_INT 1
106129: ARRAY
106130: PPUSH
106131: CALL_OW 251
106135: PPUSH
106136: LD_INT 70
106138: PPUSH
106139: CALL_OW 495
// end ;
106143: PPOPN 1
106145: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
106146: LD_EXP 126
106150: PUSH
106151: LD_EXP 160
106155: AND
106156: IFFALSE 106367
106158: GO 106160
106160: DISABLE
106161: LD_INT 0
106163: PPUSH
106164: PPUSH
106165: PPUSH
106166: PPUSH
106167: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
106168: LD_ADDR_VAR 0 5
106172: PUSH
106173: LD_INT 22
106175: PUSH
106176: LD_OWVAR 2
106180: PUSH
106181: EMPTY
106182: LIST
106183: LIST
106184: PUSH
106185: LD_INT 21
106187: PUSH
106188: LD_INT 1
106190: PUSH
106191: EMPTY
106192: LIST
106193: LIST
106194: PUSH
106195: EMPTY
106196: LIST
106197: LIST
106198: PPUSH
106199: CALL_OW 69
106203: ST_TO_ADDR
// if not tmp then
106204: LD_VAR 0 5
106208: NOT
106209: IFFALSE 106213
// exit ;
106211: GO 106367
// for i in tmp do
106213: LD_ADDR_VAR 0 1
106217: PUSH
106218: LD_VAR 0 5
106222: PUSH
106223: FOR_IN
106224: IFFALSE 106365
// begin d := rand ( 0 , 5 ) ;
106226: LD_ADDR_VAR 0 4
106230: PUSH
106231: LD_INT 0
106233: PPUSH
106234: LD_INT 5
106236: PPUSH
106237: CALL_OW 12
106241: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
106242: LD_ADDR_VAR 0 2
106246: PUSH
106247: LD_VAR 0 1
106251: PPUSH
106252: CALL_OW 250
106256: PPUSH
106257: LD_VAR 0 4
106261: PPUSH
106262: LD_INT 3
106264: PPUSH
106265: LD_INT 12
106267: PPUSH
106268: CALL_OW 12
106272: PPUSH
106273: CALL_OW 272
106277: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
106278: LD_ADDR_VAR 0 3
106282: PUSH
106283: LD_VAR 0 1
106287: PPUSH
106288: CALL_OW 251
106292: PPUSH
106293: LD_VAR 0 4
106297: PPUSH
106298: LD_INT 3
106300: PPUSH
106301: LD_INT 12
106303: PPUSH
106304: CALL_OW 12
106308: PPUSH
106309: CALL_OW 273
106313: ST_TO_ADDR
// if ValidHex ( x , y ) then
106314: LD_VAR 0 2
106318: PPUSH
106319: LD_VAR 0 3
106323: PPUSH
106324: CALL_OW 488
106328: IFFALSE 106363
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
106330: LD_VAR 0 1
106334: PPUSH
106335: LD_VAR 0 2
106339: PPUSH
106340: LD_VAR 0 3
106344: PPUSH
106345: LD_INT 3
106347: PPUSH
106348: LD_INT 6
106350: PPUSH
106351: CALL_OW 12
106355: PPUSH
106356: LD_INT 1
106358: PPUSH
106359: CALL_OW 483
// end ;
106363: GO 106223
106365: POP
106366: POP
// end ;
106367: PPOPN 5
106369: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
106370: LD_EXP 126
106374: PUSH
106375: LD_EXP 161
106379: AND
106380: IFFALSE 106474
106382: GO 106384
106384: DISABLE
106385: LD_INT 0
106387: PPUSH
106388: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
106389: LD_ADDR_VAR 0 2
106393: PUSH
106394: LD_INT 22
106396: PUSH
106397: LD_OWVAR 2
106401: PUSH
106402: EMPTY
106403: LIST
106404: LIST
106405: PUSH
106406: LD_INT 32
106408: PUSH
106409: LD_INT 1
106411: PUSH
106412: EMPTY
106413: LIST
106414: LIST
106415: PUSH
106416: LD_INT 21
106418: PUSH
106419: LD_INT 2
106421: PUSH
106422: EMPTY
106423: LIST
106424: LIST
106425: PUSH
106426: EMPTY
106427: LIST
106428: LIST
106429: LIST
106430: PPUSH
106431: CALL_OW 69
106435: ST_TO_ADDR
// if not tmp then
106436: LD_VAR 0 2
106440: NOT
106441: IFFALSE 106445
// exit ;
106443: GO 106474
// for i in tmp do
106445: LD_ADDR_VAR 0 1
106449: PUSH
106450: LD_VAR 0 2
106454: PUSH
106455: FOR_IN
106456: IFFALSE 106472
// SetFuel ( i , 0 ) ;
106458: LD_VAR 0 1
106462: PPUSH
106463: LD_INT 0
106465: PPUSH
106466: CALL_OW 240
106470: GO 106455
106472: POP
106473: POP
// end ;
106474: PPOPN 2
106476: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
106477: LD_EXP 126
106481: PUSH
106482: LD_EXP 162
106486: AND
106487: IFFALSE 106553
106489: GO 106491
106491: DISABLE
106492: LD_INT 0
106494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106495: LD_ADDR_VAR 0 1
106499: PUSH
106500: LD_INT 22
106502: PUSH
106503: LD_OWVAR 2
106507: PUSH
106508: EMPTY
106509: LIST
106510: LIST
106511: PUSH
106512: LD_INT 30
106514: PUSH
106515: LD_INT 29
106517: PUSH
106518: EMPTY
106519: LIST
106520: LIST
106521: PUSH
106522: EMPTY
106523: LIST
106524: LIST
106525: PPUSH
106526: CALL_OW 69
106530: ST_TO_ADDR
// if not tmp then
106531: LD_VAR 0 1
106535: NOT
106536: IFFALSE 106540
// exit ;
106538: GO 106553
// DestroyUnit ( tmp [ 1 ] ) ;
106540: LD_VAR 0 1
106544: PUSH
106545: LD_INT 1
106547: ARRAY
106548: PPUSH
106549: CALL_OW 65
// end ;
106553: PPOPN 1
106555: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
106556: LD_EXP 126
106560: PUSH
106561: LD_EXP 164
106565: AND
106566: IFFALSE 106695
106568: GO 106570
106570: DISABLE
106571: LD_INT 0
106573: PPUSH
// begin uc_side := 0 ;
106574: LD_ADDR_OWVAR 20
106578: PUSH
106579: LD_INT 0
106581: ST_TO_ADDR
// uc_nation := nation_arabian ;
106582: LD_ADDR_OWVAR 21
106586: PUSH
106587: LD_INT 2
106589: ST_TO_ADDR
// hc_gallery :=  ;
106590: LD_ADDR_OWVAR 33
106594: PUSH
106595: LD_STRING 
106597: ST_TO_ADDR
// hc_name :=  ;
106598: LD_ADDR_OWVAR 26
106602: PUSH
106603: LD_STRING 
106605: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
106606: LD_INT 1
106608: PPUSH
106609: LD_INT 11
106611: PPUSH
106612: LD_INT 10
106614: PPUSH
106615: CALL_OW 380
// un := CreateHuman ;
106619: LD_ADDR_VAR 0 1
106623: PUSH
106624: CALL_OW 44
106628: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106629: LD_VAR 0 1
106633: PPUSH
106634: LD_INT 1
106636: PPUSH
106637: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
106641: LD_INT 35
106643: PPUSH
106644: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
106648: LD_VAR 0 1
106652: PPUSH
106653: LD_INT 22
106655: PUSH
106656: LD_OWVAR 2
106660: PUSH
106661: EMPTY
106662: LIST
106663: LIST
106664: PPUSH
106665: CALL_OW 69
106669: PPUSH
106670: LD_VAR 0 1
106674: PPUSH
106675: CALL_OW 74
106679: PPUSH
106680: CALL_OW 115
// until IsDead ( un ) ;
106684: LD_VAR 0 1
106688: PPUSH
106689: CALL_OW 301
106693: IFFALSE 106641
// end ;
106695: PPOPN 1
106697: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
106698: LD_EXP 126
106702: PUSH
106703: LD_EXP 166
106707: AND
106708: IFFALSE 106720
106710: GO 106712
106712: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
106713: LD_STRING earthquake(getX(game), 0, 32)
106715: PPUSH
106716: CALL_OW 559
106720: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
106721: LD_EXP 126
106725: PUSH
106726: LD_EXP 167
106730: AND
106731: IFFALSE 106822
106733: GO 106735
106735: DISABLE
106736: LD_INT 0
106738: PPUSH
// begin enable ;
106739: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
106740: LD_ADDR_VAR 0 1
106744: PUSH
106745: LD_INT 22
106747: PUSH
106748: LD_OWVAR 2
106752: PUSH
106753: EMPTY
106754: LIST
106755: LIST
106756: PUSH
106757: LD_INT 21
106759: PUSH
106760: LD_INT 2
106762: PUSH
106763: EMPTY
106764: LIST
106765: LIST
106766: PUSH
106767: LD_INT 33
106769: PUSH
106770: LD_INT 3
106772: PUSH
106773: EMPTY
106774: LIST
106775: LIST
106776: PUSH
106777: EMPTY
106778: LIST
106779: LIST
106780: LIST
106781: PPUSH
106782: CALL_OW 69
106786: ST_TO_ADDR
// if not tmp then
106787: LD_VAR 0 1
106791: NOT
106792: IFFALSE 106796
// exit ;
106794: GO 106822
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
106796: LD_VAR 0 1
106800: PUSH
106801: LD_INT 1
106803: PPUSH
106804: LD_VAR 0 1
106808: PPUSH
106809: CALL_OW 12
106813: ARRAY
106814: PPUSH
106815: LD_INT 1
106817: PPUSH
106818: CALL_OW 234
// end ;
106822: PPOPN 1
106824: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
106825: LD_EXP 126
106829: PUSH
106830: LD_EXP 168
106834: AND
106835: IFFALSE 106976
106837: GO 106839
106839: DISABLE
106840: LD_INT 0
106842: PPUSH
106843: PPUSH
106844: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106845: LD_ADDR_VAR 0 3
106849: PUSH
106850: LD_INT 22
106852: PUSH
106853: LD_OWVAR 2
106857: PUSH
106858: EMPTY
106859: LIST
106860: LIST
106861: PUSH
106862: LD_INT 25
106864: PUSH
106865: LD_INT 1
106867: PUSH
106868: EMPTY
106869: LIST
106870: LIST
106871: PUSH
106872: EMPTY
106873: LIST
106874: LIST
106875: PPUSH
106876: CALL_OW 69
106880: ST_TO_ADDR
// if not tmp then
106881: LD_VAR 0 3
106885: NOT
106886: IFFALSE 106890
// exit ;
106888: GO 106976
// un := tmp [ rand ( 1 , tmp ) ] ;
106890: LD_ADDR_VAR 0 2
106894: PUSH
106895: LD_VAR 0 3
106899: PUSH
106900: LD_INT 1
106902: PPUSH
106903: LD_VAR 0 3
106907: PPUSH
106908: CALL_OW 12
106912: ARRAY
106913: ST_TO_ADDR
// if Crawls ( un ) then
106914: LD_VAR 0 2
106918: PPUSH
106919: CALL_OW 318
106923: IFFALSE 106934
// ComWalk ( un ) ;
106925: LD_VAR 0 2
106929: PPUSH
106930: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
106934: LD_VAR 0 2
106938: PPUSH
106939: LD_INT 9
106941: PPUSH
106942: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
106946: LD_INT 28
106948: PPUSH
106949: LD_OWVAR 2
106953: PPUSH
106954: LD_INT 2
106956: PPUSH
106957: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
106961: LD_INT 29
106963: PPUSH
106964: LD_OWVAR 2
106968: PPUSH
106969: LD_INT 2
106971: PPUSH
106972: CALL_OW 322
// end ;
106976: PPOPN 3
106978: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
106979: LD_EXP 126
106983: PUSH
106984: LD_EXP 169
106988: AND
106989: IFFALSE 107100
106991: GO 106993
106993: DISABLE
106994: LD_INT 0
106996: PPUSH
106997: PPUSH
106998: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106999: LD_ADDR_VAR 0 3
107003: PUSH
107004: LD_INT 22
107006: PUSH
107007: LD_OWVAR 2
107011: PUSH
107012: EMPTY
107013: LIST
107014: LIST
107015: PUSH
107016: LD_INT 25
107018: PUSH
107019: LD_INT 1
107021: PUSH
107022: EMPTY
107023: LIST
107024: LIST
107025: PUSH
107026: EMPTY
107027: LIST
107028: LIST
107029: PPUSH
107030: CALL_OW 69
107034: ST_TO_ADDR
// if not tmp then
107035: LD_VAR 0 3
107039: NOT
107040: IFFALSE 107044
// exit ;
107042: GO 107100
// un := tmp [ rand ( 1 , tmp ) ] ;
107044: LD_ADDR_VAR 0 2
107048: PUSH
107049: LD_VAR 0 3
107053: PUSH
107054: LD_INT 1
107056: PPUSH
107057: LD_VAR 0 3
107061: PPUSH
107062: CALL_OW 12
107066: ARRAY
107067: ST_TO_ADDR
// if Crawls ( un ) then
107068: LD_VAR 0 2
107072: PPUSH
107073: CALL_OW 318
107077: IFFALSE 107088
// ComWalk ( un ) ;
107079: LD_VAR 0 2
107083: PPUSH
107084: CALL_OW 138
// SetClass ( un , class_mortar ) ;
107088: LD_VAR 0 2
107092: PPUSH
107093: LD_INT 8
107095: PPUSH
107096: CALL_OW 336
// end ;
107100: PPOPN 3
107102: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
107103: LD_EXP 126
107107: PUSH
107108: LD_EXP 170
107112: AND
107113: IFFALSE 107257
107115: GO 107117
107117: DISABLE
107118: LD_INT 0
107120: PPUSH
107121: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
107122: LD_ADDR_VAR 0 2
107126: PUSH
107127: LD_INT 22
107129: PUSH
107130: LD_OWVAR 2
107134: PUSH
107135: EMPTY
107136: LIST
107137: LIST
107138: PUSH
107139: LD_INT 21
107141: PUSH
107142: LD_INT 2
107144: PUSH
107145: EMPTY
107146: LIST
107147: LIST
107148: PUSH
107149: LD_INT 2
107151: PUSH
107152: LD_INT 34
107154: PUSH
107155: LD_INT 12
107157: PUSH
107158: EMPTY
107159: LIST
107160: LIST
107161: PUSH
107162: LD_INT 34
107164: PUSH
107165: LD_INT 51
107167: PUSH
107168: EMPTY
107169: LIST
107170: LIST
107171: PUSH
107172: LD_INT 34
107174: PUSH
107175: LD_INT 32
107177: PUSH
107178: EMPTY
107179: LIST
107180: LIST
107181: PUSH
107182: EMPTY
107183: LIST
107184: LIST
107185: LIST
107186: LIST
107187: PUSH
107188: EMPTY
107189: LIST
107190: LIST
107191: LIST
107192: PPUSH
107193: CALL_OW 69
107197: ST_TO_ADDR
// if not tmp then
107198: LD_VAR 0 2
107202: NOT
107203: IFFALSE 107207
// exit ;
107205: GO 107257
// for i in tmp do
107207: LD_ADDR_VAR 0 1
107211: PUSH
107212: LD_VAR 0 2
107216: PUSH
107217: FOR_IN
107218: IFFALSE 107255
// if GetCargo ( i , mat_artifact ) = 0 then
107220: LD_VAR 0 1
107224: PPUSH
107225: LD_INT 4
107227: PPUSH
107228: CALL_OW 289
107232: PUSH
107233: LD_INT 0
107235: EQUAL
107236: IFFALSE 107253
// SetCargo ( i , mat_siberit , 100 ) ;
107238: LD_VAR 0 1
107242: PPUSH
107243: LD_INT 3
107245: PPUSH
107246: LD_INT 100
107248: PPUSH
107249: CALL_OW 290
107253: GO 107217
107255: POP
107256: POP
// end ;
107257: PPOPN 2
107259: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
107260: LD_EXP 126
107264: PUSH
107265: LD_EXP 171
107269: AND
107270: IFFALSE 107453
107272: GO 107274
107274: DISABLE
107275: LD_INT 0
107277: PPUSH
107278: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107279: LD_ADDR_VAR 0 2
107283: PUSH
107284: LD_INT 22
107286: PUSH
107287: LD_OWVAR 2
107291: PUSH
107292: EMPTY
107293: LIST
107294: LIST
107295: PPUSH
107296: CALL_OW 69
107300: ST_TO_ADDR
// if not tmp then
107301: LD_VAR 0 2
107305: NOT
107306: IFFALSE 107310
// exit ;
107308: GO 107453
// for i := 1 to 2 do
107310: LD_ADDR_VAR 0 1
107314: PUSH
107315: DOUBLE
107316: LD_INT 1
107318: DEC
107319: ST_TO_ADDR
107320: LD_INT 2
107322: PUSH
107323: FOR_TO
107324: IFFALSE 107451
// begin uc_side := your_side ;
107326: LD_ADDR_OWVAR 20
107330: PUSH
107331: LD_OWVAR 2
107335: ST_TO_ADDR
// uc_nation := nation_american ;
107336: LD_ADDR_OWVAR 21
107340: PUSH
107341: LD_INT 1
107343: ST_TO_ADDR
// vc_chassis := us_morphling ;
107344: LD_ADDR_OWVAR 37
107348: PUSH
107349: LD_INT 5
107351: ST_TO_ADDR
// vc_engine := engine_siberite ;
107352: LD_ADDR_OWVAR 39
107356: PUSH
107357: LD_INT 3
107359: ST_TO_ADDR
// vc_control := control_computer ;
107360: LD_ADDR_OWVAR 38
107364: PUSH
107365: LD_INT 3
107367: ST_TO_ADDR
// vc_weapon := us_double_laser ;
107368: LD_ADDR_OWVAR 40
107372: PUSH
107373: LD_INT 10
107375: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
107376: LD_VAR 0 2
107380: PUSH
107381: LD_INT 1
107383: ARRAY
107384: PPUSH
107385: CALL_OW 310
107389: NOT
107390: IFFALSE 107437
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
107392: CALL_OW 45
107396: PPUSH
107397: LD_VAR 0 2
107401: PUSH
107402: LD_INT 1
107404: ARRAY
107405: PPUSH
107406: CALL_OW 250
107410: PPUSH
107411: LD_VAR 0 2
107415: PUSH
107416: LD_INT 1
107418: ARRAY
107419: PPUSH
107420: CALL_OW 251
107424: PPUSH
107425: LD_INT 12
107427: PPUSH
107428: LD_INT 1
107430: PPUSH
107431: CALL_OW 50
107435: GO 107449
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
107437: CALL_OW 45
107441: PPUSH
107442: LD_INT 1
107444: PPUSH
107445: CALL_OW 51
// end ;
107449: GO 107323
107451: POP
107452: POP
// end ;
107453: PPOPN 2
107455: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
107456: LD_EXP 126
107460: PUSH
107461: LD_EXP 172
107465: AND
107466: IFFALSE 107688
107468: GO 107470
107470: DISABLE
107471: LD_INT 0
107473: PPUSH
107474: PPUSH
107475: PPUSH
107476: PPUSH
107477: PPUSH
107478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
107479: LD_ADDR_VAR 0 6
107483: PUSH
107484: LD_INT 22
107486: PUSH
107487: LD_OWVAR 2
107491: PUSH
107492: EMPTY
107493: LIST
107494: LIST
107495: PUSH
107496: LD_INT 21
107498: PUSH
107499: LD_INT 1
107501: PUSH
107502: EMPTY
107503: LIST
107504: LIST
107505: PUSH
107506: LD_INT 3
107508: PUSH
107509: LD_INT 23
107511: PUSH
107512: LD_INT 0
107514: PUSH
107515: EMPTY
107516: LIST
107517: LIST
107518: PUSH
107519: EMPTY
107520: LIST
107521: LIST
107522: PUSH
107523: EMPTY
107524: LIST
107525: LIST
107526: LIST
107527: PPUSH
107528: CALL_OW 69
107532: ST_TO_ADDR
// if not tmp then
107533: LD_VAR 0 6
107537: NOT
107538: IFFALSE 107542
// exit ;
107540: GO 107688
// s1 := rand ( 1 , 4 ) ;
107542: LD_ADDR_VAR 0 2
107546: PUSH
107547: LD_INT 1
107549: PPUSH
107550: LD_INT 4
107552: PPUSH
107553: CALL_OW 12
107557: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
107558: LD_ADDR_VAR 0 4
107562: PUSH
107563: LD_VAR 0 6
107567: PUSH
107568: LD_INT 1
107570: ARRAY
107571: PPUSH
107572: LD_VAR 0 2
107576: PPUSH
107577: CALL_OW 259
107581: ST_TO_ADDR
// if s1 = 1 then
107582: LD_VAR 0 2
107586: PUSH
107587: LD_INT 1
107589: EQUAL
107590: IFFALSE 107610
// s2 := rand ( 2 , 4 ) else
107592: LD_ADDR_VAR 0 3
107596: PUSH
107597: LD_INT 2
107599: PPUSH
107600: LD_INT 4
107602: PPUSH
107603: CALL_OW 12
107607: ST_TO_ADDR
107608: GO 107618
// s2 := 1 ;
107610: LD_ADDR_VAR 0 3
107614: PUSH
107615: LD_INT 1
107617: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
107618: LD_ADDR_VAR 0 5
107622: PUSH
107623: LD_VAR 0 6
107627: PUSH
107628: LD_INT 1
107630: ARRAY
107631: PPUSH
107632: LD_VAR 0 3
107636: PPUSH
107637: CALL_OW 259
107641: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
107642: LD_VAR 0 6
107646: PUSH
107647: LD_INT 1
107649: ARRAY
107650: PPUSH
107651: LD_VAR 0 2
107655: PPUSH
107656: LD_VAR 0 5
107660: PPUSH
107661: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
107665: LD_VAR 0 6
107669: PUSH
107670: LD_INT 1
107672: ARRAY
107673: PPUSH
107674: LD_VAR 0 3
107678: PPUSH
107679: LD_VAR 0 4
107683: PPUSH
107684: CALL_OW 237
// end ;
107688: PPOPN 6
107690: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
107691: LD_EXP 126
107695: PUSH
107696: LD_EXP 173
107700: AND
107701: IFFALSE 107780
107703: GO 107705
107705: DISABLE
107706: LD_INT 0
107708: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
107709: LD_ADDR_VAR 0 1
107713: PUSH
107714: LD_INT 22
107716: PUSH
107717: LD_OWVAR 2
107721: PUSH
107722: EMPTY
107723: LIST
107724: LIST
107725: PUSH
107726: LD_INT 30
107728: PUSH
107729: LD_INT 3
107731: PUSH
107732: EMPTY
107733: LIST
107734: LIST
107735: PUSH
107736: EMPTY
107737: LIST
107738: LIST
107739: PPUSH
107740: CALL_OW 69
107744: ST_TO_ADDR
// if not tmp then
107745: LD_VAR 0 1
107749: NOT
107750: IFFALSE 107754
// exit ;
107752: GO 107780
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
107754: LD_VAR 0 1
107758: PUSH
107759: LD_INT 1
107761: PPUSH
107762: LD_VAR 0 1
107766: PPUSH
107767: CALL_OW 12
107771: ARRAY
107772: PPUSH
107773: LD_INT 1
107775: PPUSH
107776: CALL_OW 234
// end ;
107780: PPOPN 1
107782: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
107783: LD_EXP 126
107787: PUSH
107788: LD_EXP 174
107792: AND
107793: IFFALSE 107905
107795: GO 107797
107797: DISABLE
107798: LD_INT 0
107800: PPUSH
107801: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
107802: LD_ADDR_VAR 0 2
107806: PUSH
107807: LD_INT 22
107809: PUSH
107810: LD_OWVAR 2
107814: PUSH
107815: EMPTY
107816: LIST
107817: LIST
107818: PUSH
107819: LD_INT 2
107821: PUSH
107822: LD_INT 30
107824: PUSH
107825: LD_INT 27
107827: PUSH
107828: EMPTY
107829: LIST
107830: LIST
107831: PUSH
107832: LD_INT 30
107834: PUSH
107835: LD_INT 26
107837: PUSH
107838: EMPTY
107839: LIST
107840: LIST
107841: PUSH
107842: LD_INT 30
107844: PUSH
107845: LD_INT 28
107847: PUSH
107848: EMPTY
107849: LIST
107850: LIST
107851: PUSH
107852: EMPTY
107853: LIST
107854: LIST
107855: LIST
107856: LIST
107857: PUSH
107858: EMPTY
107859: LIST
107860: LIST
107861: PPUSH
107862: CALL_OW 69
107866: ST_TO_ADDR
// if not tmp then
107867: LD_VAR 0 2
107871: NOT
107872: IFFALSE 107876
// exit ;
107874: GO 107905
// for i in tmp do
107876: LD_ADDR_VAR 0 1
107880: PUSH
107881: LD_VAR 0 2
107885: PUSH
107886: FOR_IN
107887: IFFALSE 107903
// SetLives ( i , 1 ) ;
107889: LD_VAR 0 1
107893: PPUSH
107894: LD_INT 1
107896: PPUSH
107897: CALL_OW 234
107901: GO 107886
107903: POP
107904: POP
// end ;
107905: PPOPN 2
107907: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
107908: LD_EXP 126
107912: PUSH
107913: LD_EXP 175
107917: AND
107918: IFFALSE 108205
107920: GO 107922
107922: DISABLE
107923: LD_INT 0
107925: PPUSH
107926: PPUSH
107927: PPUSH
// begin i := rand ( 1 , 7 ) ;
107928: LD_ADDR_VAR 0 1
107932: PUSH
107933: LD_INT 1
107935: PPUSH
107936: LD_INT 7
107938: PPUSH
107939: CALL_OW 12
107943: ST_TO_ADDR
// case i of 1 :
107944: LD_VAR 0 1
107948: PUSH
107949: LD_INT 1
107951: DOUBLE
107952: EQUAL
107953: IFTRUE 107957
107955: GO 107967
107957: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
107958: LD_STRING earthquake(getX(game), 0, 32)
107960: PPUSH
107961: CALL_OW 559
107965: GO 108205
107967: LD_INT 2
107969: DOUBLE
107970: EQUAL
107971: IFTRUE 107975
107973: GO 107989
107975: POP
// begin ToLua ( displayStucuk(); ) ;
107976: LD_STRING displayStucuk();
107978: PPUSH
107979: CALL_OW 559
// ResetFog ;
107983: CALL_OW 335
// end ; 3 :
107987: GO 108205
107989: LD_INT 3
107991: DOUBLE
107992: EQUAL
107993: IFTRUE 107997
107995: GO 108101
107997: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107998: LD_ADDR_VAR 0 2
108002: PUSH
108003: LD_INT 22
108005: PUSH
108006: LD_OWVAR 2
108010: PUSH
108011: EMPTY
108012: LIST
108013: LIST
108014: PUSH
108015: LD_INT 25
108017: PUSH
108018: LD_INT 1
108020: PUSH
108021: EMPTY
108022: LIST
108023: LIST
108024: PUSH
108025: EMPTY
108026: LIST
108027: LIST
108028: PPUSH
108029: CALL_OW 69
108033: ST_TO_ADDR
// if not tmp then
108034: LD_VAR 0 2
108038: NOT
108039: IFFALSE 108043
// exit ;
108041: GO 108205
// un := tmp [ rand ( 1 , tmp ) ] ;
108043: LD_ADDR_VAR 0 3
108047: PUSH
108048: LD_VAR 0 2
108052: PUSH
108053: LD_INT 1
108055: PPUSH
108056: LD_VAR 0 2
108060: PPUSH
108061: CALL_OW 12
108065: ARRAY
108066: ST_TO_ADDR
// if Crawls ( un ) then
108067: LD_VAR 0 3
108071: PPUSH
108072: CALL_OW 318
108076: IFFALSE 108087
// ComWalk ( un ) ;
108078: LD_VAR 0 3
108082: PPUSH
108083: CALL_OW 138
// SetClass ( un , class_mortar ) ;
108087: LD_VAR 0 3
108091: PPUSH
108092: LD_INT 8
108094: PPUSH
108095: CALL_OW 336
// end ; 4 :
108099: GO 108205
108101: LD_INT 4
108103: DOUBLE
108104: EQUAL
108105: IFTRUE 108109
108107: GO 108183
108109: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
108110: LD_ADDR_VAR 0 2
108114: PUSH
108115: LD_INT 22
108117: PUSH
108118: LD_OWVAR 2
108122: PUSH
108123: EMPTY
108124: LIST
108125: LIST
108126: PUSH
108127: LD_INT 30
108129: PUSH
108130: LD_INT 29
108132: PUSH
108133: EMPTY
108134: LIST
108135: LIST
108136: PUSH
108137: EMPTY
108138: LIST
108139: LIST
108140: PPUSH
108141: CALL_OW 69
108145: ST_TO_ADDR
// if not tmp then
108146: LD_VAR 0 2
108150: NOT
108151: IFFALSE 108155
// exit ;
108153: GO 108205
// CenterNowOnUnits ( tmp [ 1 ] ) ;
108155: LD_VAR 0 2
108159: PUSH
108160: LD_INT 1
108162: ARRAY
108163: PPUSH
108164: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
108168: LD_VAR 0 2
108172: PUSH
108173: LD_INT 1
108175: ARRAY
108176: PPUSH
108177: CALL_OW 65
// end ; 5 .. 7 :
108181: GO 108205
108183: LD_INT 5
108185: DOUBLE
108186: GREATEREQUAL
108187: IFFALSE 108195
108189: LD_INT 7
108191: DOUBLE
108192: LESSEQUAL
108193: IFTRUE 108197
108195: GO 108204
108197: POP
// StreamSibBomb ; end ;
108198: CALL 104442 0 0
108202: GO 108205
108204: POP
// end ;
108205: PPOPN 3
108207: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
108208: LD_EXP 126
108212: PUSH
108213: LD_EXP 176
108217: AND
108218: IFFALSE 108374
108220: GO 108222
108222: DISABLE
108223: LD_INT 0
108225: PPUSH
108226: PPUSH
108227: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
108228: LD_ADDR_VAR 0 2
108232: PUSH
108233: LD_INT 81
108235: PUSH
108236: LD_OWVAR 2
108240: PUSH
108241: EMPTY
108242: LIST
108243: LIST
108244: PUSH
108245: LD_INT 2
108247: PUSH
108248: LD_INT 21
108250: PUSH
108251: LD_INT 1
108253: PUSH
108254: EMPTY
108255: LIST
108256: LIST
108257: PUSH
108258: LD_INT 21
108260: PUSH
108261: LD_INT 2
108263: PUSH
108264: EMPTY
108265: LIST
108266: LIST
108267: PUSH
108268: EMPTY
108269: LIST
108270: LIST
108271: LIST
108272: PUSH
108273: EMPTY
108274: LIST
108275: LIST
108276: PPUSH
108277: CALL_OW 69
108281: ST_TO_ADDR
// if not tmp then
108282: LD_VAR 0 2
108286: NOT
108287: IFFALSE 108291
// exit ;
108289: GO 108374
// p := 0 ;
108291: LD_ADDR_VAR 0 3
108295: PUSH
108296: LD_INT 0
108298: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108299: LD_INT 35
108301: PPUSH
108302: CALL_OW 67
// p := p + 1 ;
108306: LD_ADDR_VAR 0 3
108310: PUSH
108311: LD_VAR 0 3
108315: PUSH
108316: LD_INT 1
108318: PLUS
108319: ST_TO_ADDR
// for i in tmp do
108320: LD_ADDR_VAR 0 1
108324: PUSH
108325: LD_VAR 0 2
108329: PUSH
108330: FOR_IN
108331: IFFALSE 108362
// if GetLives ( i ) < 1000 then
108333: LD_VAR 0 1
108337: PPUSH
108338: CALL_OW 256
108342: PUSH
108343: LD_INT 1000
108345: LESS
108346: IFFALSE 108360
// SetLives ( i , 1000 ) ;
108348: LD_VAR 0 1
108352: PPUSH
108353: LD_INT 1000
108355: PPUSH
108356: CALL_OW 234
108360: GO 108330
108362: POP
108363: POP
// until p > 20 ;
108364: LD_VAR 0 3
108368: PUSH
108369: LD_INT 20
108371: GREATER
108372: IFFALSE 108299
// end ;
108374: PPOPN 3
108376: END
// every 0 0$1 trigger StreamModeActive and sTime do
108377: LD_EXP 126
108381: PUSH
108382: LD_EXP 177
108386: AND
108387: IFFALSE 108422
108389: GO 108391
108391: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
108392: LD_INT 28
108394: PPUSH
108395: LD_OWVAR 2
108399: PPUSH
108400: LD_INT 2
108402: PPUSH
108403: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
108407: LD_INT 30
108409: PPUSH
108410: LD_OWVAR 2
108414: PPUSH
108415: LD_INT 2
108417: PPUSH
108418: CALL_OW 322
// end ;
108422: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
108423: LD_EXP 126
108427: PUSH
108428: LD_EXP 178
108432: AND
108433: IFFALSE 108554
108435: GO 108437
108437: DISABLE
108438: LD_INT 0
108440: PPUSH
108441: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
108442: LD_ADDR_VAR 0 2
108446: PUSH
108447: LD_INT 22
108449: PUSH
108450: LD_OWVAR 2
108454: PUSH
108455: EMPTY
108456: LIST
108457: LIST
108458: PUSH
108459: LD_INT 21
108461: PUSH
108462: LD_INT 1
108464: PUSH
108465: EMPTY
108466: LIST
108467: LIST
108468: PUSH
108469: LD_INT 3
108471: PUSH
108472: LD_INT 23
108474: PUSH
108475: LD_INT 0
108477: PUSH
108478: EMPTY
108479: LIST
108480: LIST
108481: PUSH
108482: EMPTY
108483: LIST
108484: LIST
108485: PUSH
108486: EMPTY
108487: LIST
108488: LIST
108489: LIST
108490: PPUSH
108491: CALL_OW 69
108495: ST_TO_ADDR
// if not tmp then
108496: LD_VAR 0 2
108500: NOT
108501: IFFALSE 108505
// exit ;
108503: GO 108554
// for i in tmp do
108505: LD_ADDR_VAR 0 1
108509: PUSH
108510: LD_VAR 0 2
108514: PUSH
108515: FOR_IN
108516: IFFALSE 108552
// begin if Crawls ( i ) then
108518: LD_VAR 0 1
108522: PPUSH
108523: CALL_OW 318
108527: IFFALSE 108538
// ComWalk ( i ) ;
108529: LD_VAR 0 1
108533: PPUSH
108534: CALL_OW 138
// SetClass ( i , 2 ) ;
108538: LD_VAR 0 1
108542: PPUSH
108543: LD_INT 2
108545: PPUSH
108546: CALL_OW 336
// end ;
108550: GO 108515
108552: POP
108553: POP
// end ;
108554: PPOPN 2
108556: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
108557: LD_EXP 126
108561: PUSH
108562: LD_EXP 179
108566: AND
108567: IFFALSE 108855
108569: GO 108571
108571: DISABLE
108572: LD_INT 0
108574: PPUSH
108575: PPUSH
108576: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
108577: LD_OWVAR 2
108581: PPUSH
108582: LD_INT 9
108584: PPUSH
108585: LD_INT 1
108587: PPUSH
108588: LD_INT 1
108590: PPUSH
108591: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
108595: LD_INT 9
108597: PPUSH
108598: LD_OWVAR 2
108602: PPUSH
108603: CALL_OW 343
// uc_side := 9 ;
108607: LD_ADDR_OWVAR 20
108611: PUSH
108612: LD_INT 9
108614: ST_TO_ADDR
// uc_nation := 2 ;
108615: LD_ADDR_OWVAR 21
108619: PUSH
108620: LD_INT 2
108622: ST_TO_ADDR
// hc_name := Dark Warrior ;
108623: LD_ADDR_OWVAR 26
108627: PUSH
108628: LD_STRING Dark Warrior
108630: ST_TO_ADDR
// hc_gallery :=  ;
108631: LD_ADDR_OWVAR 33
108635: PUSH
108636: LD_STRING 
108638: ST_TO_ADDR
// hc_noskilllimit := true ;
108639: LD_ADDR_OWVAR 76
108643: PUSH
108644: LD_INT 1
108646: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
108647: LD_ADDR_OWVAR 31
108651: PUSH
108652: LD_INT 30
108654: PUSH
108655: LD_INT 30
108657: PUSH
108658: LD_INT 30
108660: PUSH
108661: LD_INT 30
108663: PUSH
108664: EMPTY
108665: LIST
108666: LIST
108667: LIST
108668: LIST
108669: ST_TO_ADDR
// un := CreateHuman ;
108670: LD_ADDR_VAR 0 3
108674: PUSH
108675: CALL_OW 44
108679: ST_TO_ADDR
// hc_noskilllimit := false ;
108680: LD_ADDR_OWVAR 76
108684: PUSH
108685: LD_INT 0
108687: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
108688: LD_VAR 0 3
108692: PPUSH
108693: LD_INT 1
108695: PPUSH
108696: CALL_OW 51
// ToLua ( playRanger() ) ;
108700: LD_STRING playRanger()
108702: PPUSH
108703: CALL_OW 559
// p := 0 ;
108707: LD_ADDR_VAR 0 2
108711: PUSH
108712: LD_INT 0
108714: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108715: LD_INT 35
108717: PPUSH
108718: CALL_OW 67
// p := p + 1 ;
108722: LD_ADDR_VAR 0 2
108726: PUSH
108727: LD_VAR 0 2
108731: PUSH
108732: LD_INT 1
108734: PLUS
108735: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
108736: LD_VAR 0 3
108740: PPUSH
108741: CALL_OW 256
108745: PUSH
108746: LD_INT 1000
108748: LESS
108749: IFFALSE 108763
// SetLives ( un , 1000 ) ;
108751: LD_VAR 0 3
108755: PPUSH
108756: LD_INT 1000
108758: PPUSH
108759: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
108763: LD_VAR 0 3
108767: PPUSH
108768: LD_INT 81
108770: PUSH
108771: LD_OWVAR 2
108775: PUSH
108776: EMPTY
108777: LIST
108778: LIST
108779: PUSH
108780: LD_INT 91
108782: PUSH
108783: LD_VAR 0 3
108787: PUSH
108788: LD_INT 30
108790: PUSH
108791: EMPTY
108792: LIST
108793: LIST
108794: LIST
108795: PUSH
108796: EMPTY
108797: LIST
108798: LIST
108799: PPUSH
108800: CALL_OW 69
108804: PPUSH
108805: LD_VAR 0 3
108809: PPUSH
108810: CALL_OW 74
108814: PPUSH
108815: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
108819: LD_VAR 0 2
108823: PUSH
108824: LD_INT 80
108826: GREATER
108827: PUSH
108828: LD_VAR 0 3
108832: PPUSH
108833: CALL_OW 301
108837: OR
108838: IFFALSE 108715
// if un then
108840: LD_VAR 0 3
108844: IFFALSE 108855
// RemoveUnit ( un ) ;
108846: LD_VAR 0 3
108850: PPUSH
108851: CALL_OW 64
// end ;
108855: PPOPN 3
108857: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
108858: LD_EXP 180
108862: IFFALSE 108978
108864: GO 108866
108866: DISABLE
108867: LD_INT 0
108869: PPUSH
108870: PPUSH
108871: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
108872: LD_ADDR_VAR 0 2
108876: PUSH
108877: LD_INT 81
108879: PUSH
108880: LD_OWVAR 2
108884: PUSH
108885: EMPTY
108886: LIST
108887: LIST
108888: PUSH
108889: LD_INT 21
108891: PUSH
108892: LD_INT 1
108894: PUSH
108895: EMPTY
108896: LIST
108897: LIST
108898: PUSH
108899: EMPTY
108900: LIST
108901: LIST
108902: PPUSH
108903: CALL_OW 69
108907: ST_TO_ADDR
// ToLua ( playComputer() ) ;
108908: LD_STRING playComputer()
108910: PPUSH
108911: CALL_OW 559
// if not tmp then
108915: LD_VAR 0 2
108919: NOT
108920: IFFALSE 108924
// exit ;
108922: GO 108978
// for i in tmp do
108924: LD_ADDR_VAR 0 1
108928: PUSH
108929: LD_VAR 0 2
108933: PUSH
108934: FOR_IN
108935: IFFALSE 108976
// for j := 1 to 4 do
108937: LD_ADDR_VAR 0 3
108941: PUSH
108942: DOUBLE
108943: LD_INT 1
108945: DEC
108946: ST_TO_ADDR
108947: LD_INT 4
108949: PUSH
108950: FOR_TO
108951: IFFALSE 108972
// SetSkill ( i , j , 10 ) ;
108953: LD_VAR 0 1
108957: PPUSH
108958: LD_VAR 0 3
108962: PPUSH
108963: LD_INT 10
108965: PPUSH
108966: CALL_OW 237
108970: GO 108950
108972: POP
108973: POP
108974: GO 108934
108976: POP
108977: POP
// end ;
108978: PPOPN 3
108980: END
// every 0 0$1 trigger s30 do var i , tmp ;
108981: LD_EXP 181
108985: IFFALSE 109054
108987: GO 108989
108989: DISABLE
108990: LD_INT 0
108992: PPUSH
108993: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108994: LD_ADDR_VAR 0 2
108998: PUSH
108999: LD_INT 22
109001: PUSH
109002: LD_OWVAR 2
109006: PUSH
109007: EMPTY
109008: LIST
109009: LIST
109010: PPUSH
109011: CALL_OW 69
109015: ST_TO_ADDR
// if not tmp then
109016: LD_VAR 0 2
109020: NOT
109021: IFFALSE 109025
// exit ;
109023: GO 109054
// for i in tmp do
109025: LD_ADDR_VAR 0 1
109029: PUSH
109030: LD_VAR 0 2
109034: PUSH
109035: FOR_IN
109036: IFFALSE 109052
// SetLives ( i , 300 ) ;
109038: LD_VAR 0 1
109042: PPUSH
109043: LD_INT 300
109045: PPUSH
109046: CALL_OW 234
109050: GO 109035
109052: POP
109053: POP
// end ;
109054: PPOPN 2
109056: END
// every 0 0$1 trigger s60 do var i , tmp ;
109057: LD_EXP 182
109061: IFFALSE 109130
109063: GO 109065
109065: DISABLE
109066: LD_INT 0
109068: PPUSH
109069: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
109070: LD_ADDR_VAR 0 2
109074: PUSH
109075: LD_INT 22
109077: PUSH
109078: LD_OWVAR 2
109082: PUSH
109083: EMPTY
109084: LIST
109085: LIST
109086: PPUSH
109087: CALL_OW 69
109091: ST_TO_ADDR
// if not tmp then
109092: LD_VAR 0 2
109096: NOT
109097: IFFALSE 109101
// exit ;
109099: GO 109130
// for i in tmp do
109101: LD_ADDR_VAR 0 1
109105: PUSH
109106: LD_VAR 0 2
109110: PUSH
109111: FOR_IN
109112: IFFALSE 109128
// SetLives ( i , 600 ) ;
109114: LD_VAR 0 1
109118: PPUSH
109119: LD_INT 600
109121: PPUSH
109122: CALL_OW 234
109126: GO 109111
109128: POP
109129: POP
// end ;
109130: PPOPN 2
109132: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
109133: LD_INT 0
109135: PPUSH
// case cmd of 301 :
109136: LD_VAR 0 1
109140: PUSH
109141: LD_INT 301
109143: DOUBLE
109144: EQUAL
109145: IFTRUE 109149
109147: GO 109181
109149: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
109150: LD_VAR 0 6
109154: PPUSH
109155: LD_VAR 0 7
109159: PPUSH
109160: LD_VAR 0 8
109164: PPUSH
109165: LD_VAR 0 4
109169: PPUSH
109170: LD_VAR 0 5
109174: PPUSH
109175: CALL 110390 0 5
109179: GO 109302
109181: LD_INT 302
109183: DOUBLE
109184: EQUAL
109185: IFTRUE 109189
109187: GO 109226
109189: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
109190: LD_VAR 0 6
109194: PPUSH
109195: LD_VAR 0 7
109199: PPUSH
109200: LD_VAR 0 8
109204: PPUSH
109205: LD_VAR 0 9
109209: PPUSH
109210: LD_VAR 0 4
109214: PPUSH
109215: LD_VAR 0 5
109219: PPUSH
109220: CALL 110481 0 6
109224: GO 109302
109226: LD_INT 303
109228: DOUBLE
109229: EQUAL
109230: IFTRUE 109234
109232: GO 109271
109234: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
109235: LD_VAR 0 6
109239: PPUSH
109240: LD_VAR 0 7
109244: PPUSH
109245: LD_VAR 0 8
109249: PPUSH
109250: LD_VAR 0 9
109254: PPUSH
109255: LD_VAR 0 4
109259: PPUSH
109260: LD_VAR 0 5
109264: PPUSH
109265: CALL 109307 0 6
109269: GO 109302
109271: LD_INT 304
109273: DOUBLE
109274: EQUAL
109275: IFTRUE 109279
109277: GO 109301
109279: POP
// hHackTeleport ( unit , x , y ) ; end ;
109280: LD_VAR 0 2
109284: PPUSH
109285: LD_VAR 0 4
109289: PPUSH
109290: LD_VAR 0 5
109294: PPUSH
109295: CALL 111074 0 3
109299: GO 109302
109301: POP
// end ;
109302: LD_VAR 0 12
109306: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
109307: LD_INT 0
109309: PPUSH
109310: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
109311: LD_VAR 0 1
109315: PUSH
109316: LD_INT 1
109318: LESS
109319: PUSH
109320: LD_VAR 0 1
109324: PUSH
109325: LD_INT 3
109327: GREATER
109328: OR
109329: PUSH
109330: LD_VAR 0 5
109334: PPUSH
109335: LD_VAR 0 6
109339: PPUSH
109340: CALL_OW 428
109344: OR
109345: IFFALSE 109349
// exit ;
109347: GO 110077
// uc_side := your_side ;
109349: LD_ADDR_OWVAR 20
109353: PUSH
109354: LD_OWVAR 2
109358: ST_TO_ADDR
// uc_nation := nation ;
109359: LD_ADDR_OWVAR 21
109363: PUSH
109364: LD_VAR 0 1
109368: ST_TO_ADDR
// bc_level = 1 ;
109369: LD_ADDR_OWVAR 43
109373: PUSH
109374: LD_INT 1
109376: ST_TO_ADDR
// case btype of 1 :
109377: LD_VAR 0 2
109381: PUSH
109382: LD_INT 1
109384: DOUBLE
109385: EQUAL
109386: IFTRUE 109390
109388: GO 109401
109390: POP
// bc_type := b_depot ; 2 :
109391: LD_ADDR_OWVAR 42
109395: PUSH
109396: LD_INT 0
109398: ST_TO_ADDR
109399: GO 110021
109401: LD_INT 2
109403: DOUBLE
109404: EQUAL
109405: IFTRUE 109409
109407: GO 109420
109409: POP
// bc_type := b_warehouse ; 3 :
109410: LD_ADDR_OWVAR 42
109414: PUSH
109415: LD_INT 1
109417: ST_TO_ADDR
109418: GO 110021
109420: LD_INT 3
109422: DOUBLE
109423: EQUAL
109424: IFTRUE 109428
109426: GO 109439
109428: POP
// bc_type := b_lab ; 4 .. 9 :
109429: LD_ADDR_OWVAR 42
109433: PUSH
109434: LD_INT 6
109436: ST_TO_ADDR
109437: GO 110021
109439: LD_INT 4
109441: DOUBLE
109442: GREATEREQUAL
109443: IFFALSE 109451
109445: LD_INT 9
109447: DOUBLE
109448: LESSEQUAL
109449: IFTRUE 109453
109451: GO 109513
109453: POP
// begin bc_type := b_lab_half ;
109454: LD_ADDR_OWVAR 42
109458: PUSH
109459: LD_INT 7
109461: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
109462: LD_ADDR_OWVAR 44
109466: PUSH
109467: LD_INT 10
109469: PUSH
109470: LD_INT 11
109472: PUSH
109473: LD_INT 12
109475: PUSH
109476: LD_INT 15
109478: PUSH
109479: LD_INT 14
109481: PUSH
109482: LD_INT 13
109484: PUSH
109485: EMPTY
109486: LIST
109487: LIST
109488: LIST
109489: LIST
109490: LIST
109491: LIST
109492: PUSH
109493: LD_VAR 0 2
109497: PUSH
109498: LD_INT 3
109500: MINUS
109501: ARRAY
109502: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
109503: LD_ADDR_OWVAR 45
109507: PUSH
109508: LD_INT 9
109510: ST_TO_ADDR
// end ; 10 .. 13 :
109511: GO 110021
109513: LD_INT 10
109515: DOUBLE
109516: GREATEREQUAL
109517: IFFALSE 109525
109519: LD_INT 13
109521: DOUBLE
109522: LESSEQUAL
109523: IFTRUE 109527
109525: GO 109604
109527: POP
// begin bc_type := b_lab_full ;
109528: LD_ADDR_OWVAR 42
109532: PUSH
109533: LD_INT 8
109535: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
109536: LD_ADDR_OWVAR 44
109540: PUSH
109541: LD_INT 10
109543: PUSH
109544: LD_INT 12
109546: PUSH
109547: LD_INT 14
109549: PUSH
109550: LD_INT 13
109552: PUSH
109553: EMPTY
109554: LIST
109555: LIST
109556: LIST
109557: LIST
109558: PUSH
109559: LD_VAR 0 2
109563: PUSH
109564: LD_INT 9
109566: MINUS
109567: ARRAY
109568: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
109569: LD_ADDR_OWVAR 45
109573: PUSH
109574: LD_INT 11
109576: PUSH
109577: LD_INT 15
109579: PUSH
109580: LD_INT 12
109582: PUSH
109583: LD_INT 15
109585: PUSH
109586: EMPTY
109587: LIST
109588: LIST
109589: LIST
109590: LIST
109591: PUSH
109592: LD_VAR 0 2
109596: PUSH
109597: LD_INT 9
109599: MINUS
109600: ARRAY
109601: ST_TO_ADDR
// end ; 14 :
109602: GO 110021
109604: LD_INT 14
109606: DOUBLE
109607: EQUAL
109608: IFTRUE 109612
109610: GO 109623
109612: POP
// bc_type := b_workshop ; 15 :
109613: LD_ADDR_OWVAR 42
109617: PUSH
109618: LD_INT 2
109620: ST_TO_ADDR
109621: GO 110021
109623: LD_INT 15
109625: DOUBLE
109626: EQUAL
109627: IFTRUE 109631
109629: GO 109642
109631: POP
// bc_type := b_factory ; 16 :
109632: LD_ADDR_OWVAR 42
109636: PUSH
109637: LD_INT 3
109639: ST_TO_ADDR
109640: GO 110021
109642: LD_INT 16
109644: DOUBLE
109645: EQUAL
109646: IFTRUE 109650
109648: GO 109661
109650: POP
// bc_type := b_ext_gun ; 17 :
109651: LD_ADDR_OWVAR 42
109655: PUSH
109656: LD_INT 17
109658: ST_TO_ADDR
109659: GO 110021
109661: LD_INT 17
109663: DOUBLE
109664: EQUAL
109665: IFTRUE 109669
109667: GO 109697
109669: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
109670: LD_ADDR_OWVAR 42
109674: PUSH
109675: LD_INT 19
109677: PUSH
109678: LD_INT 23
109680: PUSH
109681: LD_INT 19
109683: PUSH
109684: EMPTY
109685: LIST
109686: LIST
109687: LIST
109688: PUSH
109689: LD_VAR 0 1
109693: ARRAY
109694: ST_TO_ADDR
109695: GO 110021
109697: LD_INT 18
109699: DOUBLE
109700: EQUAL
109701: IFTRUE 109705
109703: GO 109716
109705: POP
// bc_type := b_ext_radar ; 19 :
109706: LD_ADDR_OWVAR 42
109710: PUSH
109711: LD_INT 20
109713: ST_TO_ADDR
109714: GO 110021
109716: LD_INT 19
109718: DOUBLE
109719: EQUAL
109720: IFTRUE 109724
109722: GO 109735
109724: POP
// bc_type := b_ext_radio ; 20 :
109725: LD_ADDR_OWVAR 42
109729: PUSH
109730: LD_INT 22
109732: ST_TO_ADDR
109733: GO 110021
109735: LD_INT 20
109737: DOUBLE
109738: EQUAL
109739: IFTRUE 109743
109741: GO 109754
109743: POP
// bc_type := b_ext_siberium ; 21 :
109744: LD_ADDR_OWVAR 42
109748: PUSH
109749: LD_INT 21
109751: ST_TO_ADDR
109752: GO 110021
109754: LD_INT 21
109756: DOUBLE
109757: EQUAL
109758: IFTRUE 109762
109760: GO 109773
109762: POP
// bc_type := b_ext_computer ; 22 :
109763: LD_ADDR_OWVAR 42
109767: PUSH
109768: LD_INT 24
109770: ST_TO_ADDR
109771: GO 110021
109773: LD_INT 22
109775: DOUBLE
109776: EQUAL
109777: IFTRUE 109781
109779: GO 109792
109781: POP
// bc_type := b_ext_track ; 23 :
109782: LD_ADDR_OWVAR 42
109786: PUSH
109787: LD_INT 16
109789: ST_TO_ADDR
109790: GO 110021
109792: LD_INT 23
109794: DOUBLE
109795: EQUAL
109796: IFTRUE 109800
109798: GO 109811
109800: POP
// bc_type := b_ext_laser ; 24 :
109801: LD_ADDR_OWVAR 42
109805: PUSH
109806: LD_INT 25
109808: ST_TO_ADDR
109809: GO 110021
109811: LD_INT 24
109813: DOUBLE
109814: EQUAL
109815: IFTRUE 109819
109817: GO 109830
109819: POP
// bc_type := b_control_tower ; 25 :
109820: LD_ADDR_OWVAR 42
109824: PUSH
109825: LD_INT 36
109827: ST_TO_ADDR
109828: GO 110021
109830: LD_INT 25
109832: DOUBLE
109833: EQUAL
109834: IFTRUE 109838
109836: GO 109849
109838: POP
// bc_type := b_breastwork ; 26 :
109839: LD_ADDR_OWVAR 42
109843: PUSH
109844: LD_INT 31
109846: ST_TO_ADDR
109847: GO 110021
109849: LD_INT 26
109851: DOUBLE
109852: EQUAL
109853: IFTRUE 109857
109855: GO 109868
109857: POP
// bc_type := b_bunker ; 27 :
109858: LD_ADDR_OWVAR 42
109862: PUSH
109863: LD_INT 32
109865: ST_TO_ADDR
109866: GO 110021
109868: LD_INT 27
109870: DOUBLE
109871: EQUAL
109872: IFTRUE 109876
109874: GO 109887
109876: POP
// bc_type := b_turret ; 28 :
109877: LD_ADDR_OWVAR 42
109881: PUSH
109882: LD_INT 33
109884: ST_TO_ADDR
109885: GO 110021
109887: LD_INT 28
109889: DOUBLE
109890: EQUAL
109891: IFTRUE 109895
109893: GO 109906
109895: POP
// bc_type := b_armoury ; 29 :
109896: LD_ADDR_OWVAR 42
109900: PUSH
109901: LD_INT 4
109903: ST_TO_ADDR
109904: GO 110021
109906: LD_INT 29
109908: DOUBLE
109909: EQUAL
109910: IFTRUE 109914
109912: GO 109925
109914: POP
// bc_type := b_barracks ; 30 :
109915: LD_ADDR_OWVAR 42
109919: PUSH
109920: LD_INT 5
109922: ST_TO_ADDR
109923: GO 110021
109925: LD_INT 30
109927: DOUBLE
109928: EQUAL
109929: IFTRUE 109933
109931: GO 109944
109933: POP
// bc_type := b_solar_power ; 31 :
109934: LD_ADDR_OWVAR 42
109938: PUSH
109939: LD_INT 27
109941: ST_TO_ADDR
109942: GO 110021
109944: LD_INT 31
109946: DOUBLE
109947: EQUAL
109948: IFTRUE 109952
109950: GO 109963
109952: POP
// bc_type := b_oil_power ; 32 :
109953: LD_ADDR_OWVAR 42
109957: PUSH
109958: LD_INT 26
109960: ST_TO_ADDR
109961: GO 110021
109963: LD_INT 32
109965: DOUBLE
109966: EQUAL
109967: IFTRUE 109971
109969: GO 109982
109971: POP
// bc_type := b_siberite_power ; 33 :
109972: LD_ADDR_OWVAR 42
109976: PUSH
109977: LD_INT 28
109979: ST_TO_ADDR
109980: GO 110021
109982: LD_INT 33
109984: DOUBLE
109985: EQUAL
109986: IFTRUE 109990
109988: GO 110001
109990: POP
// bc_type := b_oil_mine ; 34 :
109991: LD_ADDR_OWVAR 42
109995: PUSH
109996: LD_INT 29
109998: ST_TO_ADDR
109999: GO 110021
110001: LD_INT 34
110003: DOUBLE
110004: EQUAL
110005: IFTRUE 110009
110007: GO 110020
110009: POP
// bc_type := b_siberite_mine ; end ;
110010: LD_ADDR_OWVAR 42
110014: PUSH
110015: LD_INT 30
110017: ST_TO_ADDR
110018: GO 110021
110020: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
110021: LD_ADDR_VAR 0 8
110025: PUSH
110026: LD_VAR 0 5
110030: PPUSH
110031: LD_VAR 0 6
110035: PPUSH
110036: LD_VAR 0 3
110040: PPUSH
110041: CALL_OW 47
110045: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
110046: LD_OWVAR 42
110050: PUSH
110051: LD_INT 32
110053: PUSH
110054: LD_INT 33
110056: PUSH
110057: EMPTY
110058: LIST
110059: LIST
110060: IN
110061: IFFALSE 110077
// PlaceWeaponTurret ( b , weapon ) ;
110063: LD_VAR 0 8
110067: PPUSH
110068: LD_VAR 0 4
110072: PPUSH
110073: CALL_OW 431
// end ;
110077: LD_VAR 0 7
110081: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
110082: LD_INT 0
110084: PPUSH
110085: PPUSH
110086: PPUSH
110087: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
110088: LD_ADDR_VAR 0 4
110092: PUSH
110093: LD_INT 22
110095: PUSH
110096: LD_OWVAR 2
110100: PUSH
110101: EMPTY
110102: LIST
110103: LIST
110104: PUSH
110105: LD_INT 2
110107: PUSH
110108: LD_INT 30
110110: PUSH
110111: LD_INT 0
110113: PUSH
110114: EMPTY
110115: LIST
110116: LIST
110117: PUSH
110118: LD_INT 30
110120: PUSH
110121: LD_INT 1
110123: PUSH
110124: EMPTY
110125: LIST
110126: LIST
110127: PUSH
110128: EMPTY
110129: LIST
110130: LIST
110131: LIST
110132: PUSH
110133: EMPTY
110134: LIST
110135: LIST
110136: PPUSH
110137: CALL_OW 69
110141: ST_TO_ADDR
// if not tmp then
110142: LD_VAR 0 4
110146: NOT
110147: IFFALSE 110151
// exit ;
110149: GO 110210
// for i in tmp do
110151: LD_ADDR_VAR 0 2
110155: PUSH
110156: LD_VAR 0 4
110160: PUSH
110161: FOR_IN
110162: IFFALSE 110208
// for j = 1 to 3 do
110164: LD_ADDR_VAR 0 3
110168: PUSH
110169: DOUBLE
110170: LD_INT 1
110172: DEC
110173: ST_TO_ADDR
110174: LD_INT 3
110176: PUSH
110177: FOR_TO
110178: IFFALSE 110204
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
110180: LD_VAR 0 2
110184: PPUSH
110185: CALL_OW 274
110189: PPUSH
110190: LD_VAR 0 3
110194: PPUSH
110195: LD_INT 99999
110197: PPUSH
110198: CALL_OW 277
110202: GO 110177
110204: POP
110205: POP
110206: GO 110161
110208: POP
110209: POP
// end ;
110210: LD_VAR 0 1
110214: RET
// export function hHackSetLevel10 ; var i , j ; begin
110215: LD_INT 0
110217: PPUSH
110218: PPUSH
110219: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
110220: LD_ADDR_VAR 0 2
110224: PUSH
110225: LD_INT 21
110227: PUSH
110228: LD_INT 1
110230: PUSH
110231: EMPTY
110232: LIST
110233: LIST
110234: PPUSH
110235: CALL_OW 69
110239: PUSH
110240: FOR_IN
110241: IFFALSE 110293
// if IsSelected ( i ) then
110243: LD_VAR 0 2
110247: PPUSH
110248: CALL_OW 306
110252: IFFALSE 110291
// begin for j := 1 to 4 do
110254: LD_ADDR_VAR 0 3
110258: PUSH
110259: DOUBLE
110260: LD_INT 1
110262: DEC
110263: ST_TO_ADDR
110264: LD_INT 4
110266: PUSH
110267: FOR_TO
110268: IFFALSE 110289
// SetSkill ( i , j , 10 ) ;
110270: LD_VAR 0 2
110274: PPUSH
110275: LD_VAR 0 3
110279: PPUSH
110280: LD_INT 10
110282: PPUSH
110283: CALL_OW 237
110287: GO 110267
110289: POP
110290: POP
// end ;
110291: GO 110240
110293: POP
110294: POP
// end ;
110295: LD_VAR 0 1
110299: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
110300: LD_INT 0
110302: PPUSH
110303: PPUSH
110304: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
110305: LD_ADDR_VAR 0 2
110309: PUSH
110310: LD_INT 22
110312: PUSH
110313: LD_OWVAR 2
110317: PUSH
110318: EMPTY
110319: LIST
110320: LIST
110321: PUSH
110322: LD_INT 21
110324: PUSH
110325: LD_INT 1
110327: PUSH
110328: EMPTY
110329: LIST
110330: LIST
110331: PUSH
110332: EMPTY
110333: LIST
110334: LIST
110335: PPUSH
110336: CALL_OW 69
110340: PUSH
110341: FOR_IN
110342: IFFALSE 110383
// begin for j := 1 to 4 do
110344: LD_ADDR_VAR 0 3
110348: PUSH
110349: DOUBLE
110350: LD_INT 1
110352: DEC
110353: ST_TO_ADDR
110354: LD_INT 4
110356: PUSH
110357: FOR_TO
110358: IFFALSE 110379
// SetSkill ( i , j , 10 ) ;
110360: LD_VAR 0 2
110364: PPUSH
110365: LD_VAR 0 3
110369: PPUSH
110370: LD_INT 10
110372: PPUSH
110373: CALL_OW 237
110377: GO 110357
110379: POP
110380: POP
// end ;
110381: GO 110341
110383: POP
110384: POP
// end ;
110385: LD_VAR 0 1
110389: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
110390: LD_INT 0
110392: PPUSH
// uc_side := your_side ;
110393: LD_ADDR_OWVAR 20
110397: PUSH
110398: LD_OWVAR 2
110402: ST_TO_ADDR
// uc_nation := nation ;
110403: LD_ADDR_OWVAR 21
110407: PUSH
110408: LD_VAR 0 1
110412: ST_TO_ADDR
// InitHc ;
110413: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
110417: LD_INT 0
110419: PPUSH
110420: LD_VAR 0 2
110424: PPUSH
110425: LD_VAR 0 3
110429: PPUSH
110430: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
110434: LD_VAR 0 4
110438: PPUSH
110439: LD_VAR 0 5
110443: PPUSH
110444: CALL_OW 428
110448: PUSH
110449: LD_INT 0
110451: EQUAL
110452: IFFALSE 110476
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
110454: CALL_OW 44
110458: PPUSH
110459: LD_VAR 0 4
110463: PPUSH
110464: LD_VAR 0 5
110468: PPUSH
110469: LD_INT 1
110471: PPUSH
110472: CALL_OW 48
// end ;
110476: LD_VAR 0 6
110480: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
110481: LD_INT 0
110483: PPUSH
110484: PPUSH
// uc_side := your_side ;
110485: LD_ADDR_OWVAR 20
110489: PUSH
110490: LD_OWVAR 2
110494: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
110495: LD_VAR 0 1
110499: PUSH
110500: LD_INT 1
110502: PUSH
110503: LD_INT 2
110505: PUSH
110506: LD_INT 3
110508: PUSH
110509: LD_INT 4
110511: PUSH
110512: LD_INT 5
110514: PUSH
110515: EMPTY
110516: LIST
110517: LIST
110518: LIST
110519: LIST
110520: LIST
110521: IN
110522: IFFALSE 110534
// uc_nation := nation_american else
110524: LD_ADDR_OWVAR 21
110528: PUSH
110529: LD_INT 1
110531: ST_TO_ADDR
110532: GO 110577
// if chassis in [ 11 , 12 , 13 , 14 ] then
110534: LD_VAR 0 1
110538: PUSH
110539: LD_INT 11
110541: PUSH
110542: LD_INT 12
110544: PUSH
110545: LD_INT 13
110547: PUSH
110548: LD_INT 14
110550: PUSH
110551: EMPTY
110552: LIST
110553: LIST
110554: LIST
110555: LIST
110556: IN
110557: IFFALSE 110569
// uc_nation := nation_arabian else
110559: LD_ADDR_OWVAR 21
110563: PUSH
110564: LD_INT 2
110566: ST_TO_ADDR
110567: GO 110577
// uc_nation := nation_russian ;
110569: LD_ADDR_OWVAR 21
110573: PUSH
110574: LD_INT 3
110576: ST_TO_ADDR
// vc_chassis := chassis ;
110577: LD_ADDR_OWVAR 37
110581: PUSH
110582: LD_VAR 0 1
110586: ST_TO_ADDR
// vc_engine := engine ;
110587: LD_ADDR_OWVAR 39
110591: PUSH
110592: LD_VAR 0 2
110596: ST_TO_ADDR
// vc_control := control ;
110597: LD_ADDR_OWVAR 38
110601: PUSH
110602: LD_VAR 0 3
110606: ST_TO_ADDR
// vc_weapon := weapon ;
110607: LD_ADDR_OWVAR 40
110611: PUSH
110612: LD_VAR 0 4
110616: ST_TO_ADDR
// un := CreateVehicle ;
110617: LD_ADDR_VAR 0 8
110621: PUSH
110622: CALL_OW 45
110626: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
110627: LD_VAR 0 8
110631: PPUSH
110632: LD_INT 0
110634: PPUSH
110635: LD_INT 5
110637: PPUSH
110638: CALL_OW 12
110642: PPUSH
110643: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
110647: LD_VAR 0 8
110651: PPUSH
110652: LD_VAR 0 5
110656: PPUSH
110657: LD_VAR 0 6
110661: PPUSH
110662: LD_INT 1
110664: PPUSH
110665: CALL_OW 48
// end ;
110669: LD_VAR 0 7
110673: RET
// export hInvincible ; every 1 do
110674: GO 110676
110676: DISABLE
// hInvincible := [ ] ;
110677: LD_ADDR_EXP 183
110681: PUSH
110682: EMPTY
110683: ST_TO_ADDR
110684: END
// every 10 do var i ;
110685: GO 110687
110687: DISABLE
110688: LD_INT 0
110690: PPUSH
// begin enable ;
110691: ENABLE
// if not hInvincible then
110692: LD_EXP 183
110696: NOT
110697: IFFALSE 110701
// exit ;
110699: GO 110745
// for i in hInvincible do
110701: LD_ADDR_VAR 0 1
110705: PUSH
110706: LD_EXP 183
110710: PUSH
110711: FOR_IN
110712: IFFALSE 110743
// if GetLives ( i ) < 1000 then
110714: LD_VAR 0 1
110718: PPUSH
110719: CALL_OW 256
110723: PUSH
110724: LD_INT 1000
110726: LESS
110727: IFFALSE 110741
// SetLives ( i , 1000 ) ;
110729: LD_VAR 0 1
110733: PPUSH
110734: LD_INT 1000
110736: PPUSH
110737: CALL_OW 234
110741: GO 110711
110743: POP
110744: POP
// end ;
110745: PPOPN 1
110747: END
// export function hHackInvincible ; var i ; begin
110748: LD_INT 0
110750: PPUSH
110751: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
110752: LD_ADDR_VAR 0 2
110756: PUSH
110757: LD_INT 2
110759: PUSH
110760: LD_INT 21
110762: PUSH
110763: LD_INT 1
110765: PUSH
110766: EMPTY
110767: LIST
110768: LIST
110769: PUSH
110770: LD_INT 21
110772: PUSH
110773: LD_INT 2
110775: PUSH
110776: EMPTY
110777: LIST
110778: LIST
110779: PUSH
110780: EMPTY
110781: LIST
110782: LIST
110783: LIST
110784: PPUSH
110785: CALL_OW 69
110789: PUSH
110790: FOR_IN
110791: IFFALSE 110852
// if IsSelected ( i ) then
110793: LD_VAR 0 2
110797: PPUSH
110798: CALL_OW 306
110802: IFFALSE 110850
// begin if i in hInvincible then
110804: LD_VAR 0 2
110808: PUSH
110809: LD_EXP 183
110813: IN
110814: IFFALSE 110834
// hInvincible := hInvincible diff i else
110816: LD_ADDR_EXP 183
110820: PUSH
110821: LD_EXP 183
110825: PUSH
110826: LD_VAR 0 2
110830: DIFF
110831: ST_TO_ADDR
110832: GO 110850
// hInvincible := hInvincible union i ;
110834: LD_ADDR_EXP 183
110838: PUSH
110839: LD_EXP 183
110843: PUSH
110844: LD_VAR 0 2
110848: UNION
110849: ST_TO_ADDR
// end ;
110850: GO 110790
110852: POP
110853: POP
// end ;
110854: LD_VAR 0 1
110858: RET
// export function hHackInvisible ; var i , j ; begin
110859: LD_INT 0
110861: PPUSH
110862: PPUSH
110863: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
110864: LD_ADDR_VAR 0 2
110868: PUSH
110869: LD_INT 21
110871: PUSH
110872: LD_INT 1
110874: PUSH
110875: EMPTY
110876: LIST
110877: LIST
110878: PPUSH
110879: CALL_OW 69
110883: PUSH
110884: FOR_IN
110885: IFFALSE 110909
// if IsSelected ( i ) then
110887: LD_VAR 0 2
110891: PPUSH
110892: CALL_OW 306
110896: IFFALSE 110907
// ComForceInvisible ( i ) ;
110898: LD_VAR 0 2
110902: PPUSH
110903: CALL_OW 496
110907: GO 110884
110909: POP
110910: POP
// end ;
110911: LD_VAR 0 1
110915: RET
// export function hHackChangeYourSide ; begin
110916: LD_INT 0
110918: PPUSH
// if your_side = 8 then
110919: LD_OWVAR 2
110923: PUSH
110924: LD_INT 8
110926: EQUAL
110927: IFFALSE 110939
// your_side := 0 else
110929: LD_ADDR_OWVAR 2
110933: PUSH
110934: LD_INT 0
110936: ST_TO_ADDR
110937: GO 110953
// your_side := your_side + 1 ;
110939: LD_ADDR_OWVAR 2
110943: PUSH
110944: LD_OWVAR 2
110948: PUSH
110949: LD_INT 1
110951: PLUS
110952: ST_TO_ADDR
// end ;
110953: LD_VAR 0 1
110957: RET
// export function hHackChangeUnitSide ; var i , j ; begin
110958: LD_INT 0
110960: PPUSH
110961: PPUSH
110962: PPUSH
// for i in all_units do
110963: LD_ADDR_VAR 0 2
110967: PUSH
110968: LD_OWVAR 3
110972: PUSH
110973: FOR_IN
110974: IFFALSE 111052
// if IsSelected ( i ) then
110976: LD_VAR 0 2
110980: PPUSH
110981: CALL_OW 306
110985: IFFALSE 111050
// begin j := GetSide ( i ) ;
110987: LD_ADDR_VAR 0 3
110991: PUSH
110992: LD_VAR 0 2
110996: PPUSH
110997: CALL_OW 255
111001: ST_TO_ADDR
// if j = 8 then
111002: LD_VAR 0 3
111006: PUSH
111007: LD_INT 8
111009: EQUAL
111010: IFFALSE 111022
// j := 0 else
111012: LD_ADDR_VAR 0 3
111016: PUSH
111017: LD_INT 0
111019: ST_TO_ADDR
111020: GO 111036
// j := j + 1 ;
111022: LD_ADDR_VAR 0 3
111026: PUSH
111027: LD_VAR 0 3
111031: PUSH
111032: LD_INT 1
111034: PLUS
111035: ST_TO_ADDR
// SetSide ( i , j ) ;
111036: LD_VAR 0 2
111040: PPUSH
111041: LD_VAR 0 3
111045: PPUSH
111046: CALL_OW 235
// end ;
111050: GO 110973
111052: POP
111053: POP
// end ;
111054: LD_VAR 0 1
111058: RET
// export function hHackFog ; begin
111059: LD_INT 0
111061: PPUSH
// FogOff ( true ) ;
111062: LD_INT 1
111064: PPUSH
111065: CALL_OW 344
// end ;
111069: LD_VAR 0 1
111073: RET
// export function hHackTeleport ( unit , x , y ) ; begin
111074: LD_INT 0
111076: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
111077: LD_VAR 0 1
111081: PPUSH
111082: LD_VAR 0 2
111086: PPUSH
111087: LD_VAR 0 3
111091: PPUSH
111092: LD_INT 1
111094: PPUSH
111095: LD_INT 1
111097: PPUSH
111098: CALL_OW 483
// CenterOnXY ( x , y ) ;
111102: LD_VAR 0 2
111106: PPUSH
111107: LD_VAR 0 3
111111: PPUSH
111112: CALL_OW 84
// end ;
111116: LD_VAR 0 4
111120: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
111121: LD_INT 0
111123: PPUSH
111124: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
111125: LD_VAR 0 1
111129: NOT
111130: PUSH
111131: LD_VAR 0 2
111135: PPUSH
111136: LD_VAR 0 3
111140: PPUSH
111141: CALL_OW 488
111145: NOT
111146: OR
111147: PUSH
111148: LD_VAR 0 1
111152: PPUSH
111153: CALL_OW 266
111157: PUSH
111158: LD_INT 3
111160: NONEQUAL
111161: PUSH
111162: LD_VAR 0 1
111166: PPUSH
111167: CALL_OW 247
111171: PUSH
111172: LD_INT 1
111174: EQUAL
111175: NOT
111176: AND
111177: OR
111178: IFFALSE 111182
// exit ;
111180: GO 111464
// if GetType ( factory ) = unit_human then
111182: LD_VAR 0 1
111186: PPUSH
111187: CALL_OW 247
111191: PUSH
111192: LD_INT 1
111194: EQUAL
111195: IFFALSE 111212
// factory := IsInUnit ( factory ) ;
111197: LD_ADDR_VAR 0 1
111201: PUSH
111202: LD_VAR 0 1
111206: PPUSH
111207: CALL_OW 310
111211: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
111212: LD_VAR 0 1
111216: PPUSH
111217: CALL_OW 266
111221: PUSH
111222: LD_INT 3
111224: NONEQUAL
111225: IFFALSE 111229
// exit ;
111227: GO 111464
// for i := 1 to Count ( factoryWaypoints ) do
111229: LD_ADDR_VAR 0 5
111233: PUSH
111234: DOUBLE
111235: LD_INT 1
111237: DEC
111238: ST_TO_ADDR
111239: LD_EXP 184
111243: PPUSH
111244: CALL 55914 0 1
111248: PUSH
111249: FOR_TO
111250: IFFALSE 111412
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
111252: LD_VAR 0 2
111256: PPUSH
111257: LD_VAR 0 3
111261: PPUSH
111262: CALL_OW 428
111266: PUSH
111267: LD_EXP 184
111271: PUSH
111272: LD_VAR 0 5
111276: ARRAY
111277: PUSH
111278: LD_INT 2
111280: ARRAY
111281: EQUAL
111282: IFFALSE 111314
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
111284: LD_ADDR_EXP 184
111288: PUSH
111289: LD_EXP 184
111293: PPUSH
111294: LD_VAR 0 5
111298: PPUSH
111299: CALL_OW 3
111303: ST_TO_ADDR
// UpdateFactoryWaypoints ;
111304: CALL 111469 0 0
// exit ;
111308: POP
111309: POP
111310: GO 111464
// end else
111312: GO 111410
// if factory = factoryWaypoints [ i ] [ 2 ] then
111314: LD_VAR 0 1
111318: PUSH
111319: LD_EXP 184
111323: PUSH
111324: LD_VAR 0 5
111328: ARRAY
111329: PUSH
111330: LD_INT 2
111332: ARRAY
111333: EQUAL
111334: IFFALSE 111410
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
111336: LD_ADDR_EXP 184
111340: PUSH
111341: LD_EXP 184
111345: PPUSH
111346: LD_VAR 0 5
111350: PPUSH
111351: CALL_OW 3
111355: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
111356: LD_ADDR_EXP 184
111360: PUSH
111361: LD_EXP 184
111365: PPUSH
111366: LD_VAR 0 1
111370: PPUSH
111371: CALL_OW 255
111375: PUSH
111376: LD_VAR 0 1
111380: PUSH
111381: LD_VAR 0 2
111385: PUSH
111386: LD_VAR 0 3
111390: PUSH
111391: EMPTY
111392: LIST
111393: LIST
111394: LIST
111395: LIST
111396: PPUSH
111397: CALL 91523 0 2
111401: ST_TO_ADDR
// UpdateFactoryWaypoints ;
111402: CALL 111469 0 0
// exit ;
111406: POP
111407: POP
111408: GO 111464
// end ; end ;
111410: GO 111249
111412: POP
111413: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
111414: LD_ADDR_EXP 184
111418: PUSH
111419: LD_EXP 184
111423: PPUSH
111424: LD_VAR 0 1
111428: PPUSH
111429: CALL_OW 255
111433: PUSH
111434: LD_VAR 0 1
111438: PUSH
111439: LD_VAR 0 2
111443: PUSH
111444: LD_VAR 0 3
111448: PUSH
111449: EMPTY
111450: LIST
111451: LIST
111452: LIST
111453: LIST
111454: PPUSH
111455: CALL 91523 0 2
111459: ST_TO_ADDR
// UpdateFactoryWaypoints ;
111460: CALL 111469 0 0
// end ;
111464: LD_VAR 0 4
111468: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
111469: LD_INT 0
111471: PPUSH
111472: PPUSH
111473: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
111474: LD_STRING resetFactoryWaypoint();
111476: PPUSH
111477: CALL_OW 559
// if factoryWaypoints then
111481: LD_EXP 184
111485: IFFALSE 111606
// begin list := factoryWaypoints ;
111487: LD_ADDR_VAR 0 3
111491: PUSH
111492: LD_EXP 184
111496: ST_TO_ADDR
// for i := 1 to list do
111497: LD_ADDR_VAR 0 2
111501: PUSH
111502: DOUBLE
111503: LD_INT 1
111505: DEC
111506: ST_TO_ADDR
111507: LD_VAR 0 3
111511: PUSH
111512: FOR_TO
111513: IFFALSE 111604
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
111515: LD_STRING setFactoryWaypointXY(
111517: PUSH
111518: LD_VAR 0 3
111522: PUSH
111523: LD_VAR 0 2
111527: ARRAY
111528: PUSH
111529: LD_INT 1
111531: ARRAY
111532: STR
111533: PUSH
111534: LD_STRING ,
111536: STR
111537: PUSH
111538: LD_VAR 0 3
111542: PUSH
111543: LD_VAR 0 2
111547: ARRAY
111548: PUSH
111549: LD_INT 2
111551: ARRAY
111552: STR
111553: PUSH
111554: LD_STRING ,
111556: STR
111557: PUSH
111558: LD_VAR 0 3
111562: PUSH
111563: LD_VAR 0 2
111567: ARRAY
111568: PUSH
111569: LD_INT 3
111571: ARRAY
111572: STR
111573: PUSH
111574: LD_STRING ,
111576: STR
111577: PUSH
111578: LD_VAR 0 3
111582: PUSH
111583: LD_VAR 0 2
111587: ARRAY
111588: PUSH
111589: LD_INT 4
111591: ARRAY
111592: STR
111593: PUSH
111594: LD_STRING )
111596: STR
111597: PPUSH
111598: CALL_OW 559
111602: GO 111512
111604: POP
111605: POP
// end ; end ;
111606: LD_VAR 0 1
111610: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
111611: LD_INT 0
111613: PPUSH
// if HexInfo ( x , y ) = warehouse then
111614: LD_VAR 0 2
111618: PPUSH
111619: LD_VAR 0 3
111623: PPUSH
111624: CALL_OW 428
111628: PUSH
111629: LD_VAR 0 1
111633: EQUAL
111634: IFFALSE 111661
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
111636: LD_ADDR_EXP 186
111640: PUSH
111641: LD_EXP 186
111645: PPUSH
111646: LD_VAR 0 1
111650: PPUSH
111651: LD_INT 0
111653: PPUSH
111654: CALL_OW 1
111658: ST_TO_ADDR
111659: GO 111712
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
111661: LD_ADDR_EXP 186
111665: PUSH
111666: LD_EXP 186
111670: PPUSH
111671: LD_VAR 0 1
111675: PPUSH
111676: LD_VAR 0 1
111680: PPUSH
111681: CALL_OW 255
111685: PUSH
111686: LD_VAR 0 1
111690: PUSH
111691: LD_VAR 0 2
111695: PUSH
111696: LD_VAR 0 3
111700: PUSH
111701: EMPTY
111702: LIST
111703: LIST
111704: LIST
111705: LIST
111706: PPUSH
111707: CALL_OW 1
111711: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
111712: CALL 111721 0 0
// end ;
111716: LD_VAR 0 4
111720: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
111721: LD_INT 0
111723: PPUSH
111724: PPUSH
111725: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
111726: LD_STRING resetWarehouseGatheringPoints();
111728: PPUSH
111729: CALL_OW 559
// if warehouseGatheringPoints then
111733: LD_EXP 186
111737: IFFALSE 111863
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
111739: LD_ADDR_VAR 0 3
111743: PUSH
111744: LD_EXP 186
111748: PPUSH
111749: CALL 95291 0 1
111753: ST_TO_ADDR
// for i := 1 to list do
111754: LD_ADDR_VAR 0 2
111758: PUSH
111759: DOUBLE
111760: LD_INT 1
111762: DEC
111763: ST_TO_ADDR
111764: LD_VAR 0 3
111768: PUSH
111769: FOR_TO
111770: IFFALSE 111861
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
111772: LD_STRING setWarehouseGatheringPointXY(
111774: PUSH
111775: LD_VAR 0 3
111779: PUSH
111780: LD_VAR 0 2
111784: ARRAY
111785: PUSH
111786: LD_INT 1
111788: ARRAY
111789: STR
111790: PUSH
111791: LD_STRING ,
111793: STR
111794: PUSH
111795: LD_VAR 0 3
111799: PUSH
111800: LD_VAR 0 2
111804: ARRAY
111805: PUSH
111806: LD_INT 2
111808: ARRAY
111809: STR
111810: PUSH
111811: LD_STRING ,
111813: STR
111814: PUSH
111815: LD_VAR 0 3
111819: PUSH
111820: LD_VAR 0 2
111824: ARRAY
111825: PUSH
111826: LD_INT 3
111828: ARRAY
111829: STR
111830: PUSH
111831: LD_STRING ,
111833: STR
111834: PUSH
111835: LD_VAR 0 3
111839: PUSH
111840: LD_VAR 0 2
111844: ARRAY
111845: PUSH
111846: LD_INT 4
111848: ARRAY
111849: STR
111850: PUSH
111851: LD_STRING )
111853: STR
111854: PPUSH
111855: CALL_OW 559
111859: GO 111769
111861: POP
111862: POP
// end ; end ;
111863: LD_VAR 0 1
111867: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
111868: LD_EXP 186
111872: IFFALSE 112557
111874: GO 111876
111876: DISABLE
111877: LD_INT 0
111879: PPUSH
111880: PPUSH
111881: PPUSH
111882: PPUSH
111883: PPUSH
111884: PPUSH
111885: PPUSH
111886: PPUSH
111887: PPUSH
// begin enable ;
111888: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
111889: LD_ADDR_VAR 0 3
111893: PUSH
111894: LD_EXP 186
111898: PPUSH
111899: CALL 95291 0 1
111903: ST_TO_ADDR
// if not list then
111904: LD_VAR 0 3
111908: NOT
111909: IFFALSE 111913
// exit ;
111911: GO 112557
// for i := 1 to list do
111913: LD_ADDR_VAR 0 1
111917: PUSH
111918: DOUBLE
111919: LD_INT 1
111921: DEC
111922: ST_TO_ADDR
111923: LD_VAR 0 3
111927: PUSH
111928: FOR_TO
111929: IFFALSE 112555
// begin depot := list [ i ] [ 2 ] ;
111931: LD_ADDR_VAR 0 8
111935: PUSH
111936: LD_VAR 0 3
111940: PUSH
111941: LD_VAR 0 1
111945: ARRAY
111946: PUSH
111947: LD_INT 2
111949: ARRAY
111950: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
111951: LD_ADDR_VAR 0 5
111955: PUSH
111956: LD_VAR 0 3
111960: PUSH
111961: LD_VAR 0 1
111965: ARRAY
111966: PUSH
111967: LD_INT 1
111969: ARRAY
111970: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
111971: LD_VAR 0 8
111975: PPUSH
111976: CALL_OW 301
111980: PUSH
111981: LD_VAR 0 5
111985: PUSH
111986: LD_VAR 0 8
111990: PPUSH
111991: CALL_OW 255
111995: NONEQUAL
111996: OR
111997: IFFALSE 112026
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
111999: LD_ADDR_EXP 186
112003: PUSH
112004: LD_EXP 186
112008: PPUSH
112009: LD_VAR 0 8
112013: PPUSH
112014: LD_INT 0
112016: PPUSH
112017: CALL_OW 1
112021: ST_TO_ADDR
// exit ;
112022: POP
112023: POP
112024: GO 112557
// end ; x := list [ i ] [ 3 ] ;
112026: LD_ADDR_VAR 0 6
112030: PUSH
112031: LD_VAR 0 3
112035: PUSH
112036: LD_VAR 0 1
112040: ARRAY
112041: PUSH
112042: LD_INT 3
112044: ARRAY
112045: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
112046: LD_ADDR_VAR 0 7
112050: PUSH
112051: LD_VAR 0 3
112055: PUSH
112056: LD_VAR 0 1
112060: ARRAY
112061: PUSH
112062: LD_INT 4
112064: ARRAY
112065: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
112066: LD_ADDR_VAR 0 9
112070: PUSH
112071: LD_VAR 0 6
112075: PPUSH
112076: LD_VAR 0 7
112080: PPUSH
112081: LD_INT 16
112083: PPUSH
112084: CALL 93875 0 3
112088: ST_TO_ADDR
// if not cratesNearbyPoint then
112089: LD_VAR 0 9
112093: NOT
112094: IFFALSE 112100
// exit ;
112096: POP
112097: POP
112098: GO 112557
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
112100: LD_ADDR_VAR 0 4
112104: PUSH
112105: LD_INT 22
112107: PUSH
112108: LD_VAR 0 5
112112: PUSH
112113: EMPTY
112114: LIST
112115: LIST
112116: PUSH
112117: LD_INT 3
112119: PUSH
112120: LD_INT 60
112122: PUSH
112123: EMPTY
112124: LIST
112125: PUSH
112126: EMPTY
112127: LIST
112128: LIST
112129: PUSH
112130: LD_INT 91
112132: PUSH
112133: LD_VAR 0 8
112137: PUSH
112138: LD_INT 6
112140: PUSH
112141: EMPTY
112142: LIST
112143: LIST
112144: LIST
112145: PUSH
112146: LD_INT 2
112148: PUSH
112149: LD_INT 25
112151: PUSH
112152: LD_INT 2
112154: PUSH
112155: EMPTY
112156: LIST
112157: LIST
112158: PUSH
112159: LD_INT 25
112161: PUSH
112162: LD_INT 16
112164: PUSH
112165: EMPTY
112166: LIST
112167: LIST
112168: PUSH
112169: EMPTY
112170: LIST
112171: LIST
112172: LIST
112173: PUSH
112174: EMPTY
112175: LIST
112176: LIST
112177: LIST
112178: LIST
112179: PPUSH
112180: CALL_OW 69
112184: PUSH
112185: LD_VAR 0 8
112189: PPUSH
112190: CALL_OW 313
112194: PPUSH
112195: LD_INT 3
112197: PUSH
112198: LD_INT 60
112200: PUSH
112201: EMPTY
112202: LIST
112203: PUSH
112204: EMPTY
112205: LIST
112206: LIST
112207: PUSH
112208: LD_INT 2
112210: PUSH
112211: LD_INT 25
112213: PUSH
112214: LD_INT 2
112216: PUSH
112217: EMPTY
112218: LIST
112219: LIST
112220: PUSH
112221: LD_INT 25
112223: PUSH
112224: LD_INT 16
112226: PUSH
112227: EMPTY
112228: LIST
112229: LIST
112230: PUSH
112231: EMPTY
112232: LIST
112233: LIST
112234: LIST
112235: PUSH
112236: EMPTY
112237: LIST
112238: LIST
112239: PPUSH
112240: CALL_OW 72
112244: UNION
112245: ST_TO_ADDR
// if tmp then
112246: LD_VAR 0 4
112250: IFFALSE 112330
// begin tmp := ShrinkArray ( tmp , 3 ) ;
112252: LD_ADDR_VAR 0 4
112256: PUSH
112257: LD_VAR 0 4
112261: PPUSH
112262: LD_INT 3
112264: PPUSH
112265: CALL 91838 0 2
112269: ST_TO_ADDR
// for j in tmp do
112270: LD_ADDR_VAR 0 2
112274: PUSH
112275: LD_VAR 0 4
112279: PUSH
112280: FOR_IN
112281: IFFALSE 112324
// begin if IsInUnit ( j ) then
112283: LD_VAR 0 2
112287: PPUSH
112288: CALL_OW 310
112292: IFFALSE 112303
// ComExit ( j ) ;
112294: LD_VAR 0 2
112298: PPUSH
112299: CALL 91921 0 1
// AddComCollect ( j , x , y ) ;
112303: LD_VAR 0 2
112307: PPUSH
112308: LD_VAR 0 6
112312: PPUSH
112313: LD_VAR 0 7
112317: PPUSH
112318: CALL_OW 177
// end ;
112322: GO 112280
112324: POP
112325: POP
// exit ;
112326: POP
112327: POP
112328: GO 112557
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
112330: LD_ADDR_VAR 0 4
112334: PUSH
112335: LD_INT 22
112337: PUSH
112338: LD_VAR 0 5
112342: PUSH
112343: EMPTY
112344: LIST
112345: LIST
112346: PUSH
112347: LD_INT 91
112349: PUSH
112350: LD_VAR 0 8
112354: PUSH
112355: LD_INT 8
112357: PUSH
112358: EMPTY
112359: LIST
112360: LIST
112361: LIST
112362: PUSH
112363: LD_INT 2
112365: PUSH
112366: LD_INT 34
112368: PUSH
112369: LD_INT 12
112371: PUSH
112372: EMPTY
112373: LIST
112374: LIST
112375: PUSH
112376: LD_INT 34
112378: PUSH
112379: LD_INT 51
112381: PUSH
112382: EMPTY
112383: LIST
112384: LIST
112385: PUSH
112386: LD_INT 34
112388: PUSH
112389: LD_INT 32
112391: PUSH
112392: EMPTY
112393: LIST
112394: LIST
112395: PUSH
112396: LD_INT 34
112398: PUSH
112399: LD_INT 89
112401: PUSH
112402: EMPTY
112403: LIST
112404: LIST
112405: PUSH
112406: EMPTY
112407: LIST
112408: LIST
112409: LIST
112410: LIST
112411: LIST
112412: PUSH
112413: EMPTY
112414: LIST
112415: LIST
112416: LIST
112417: PPUSH
112418: CALL_OW 69
112422: ST_TO_ADDR
// if tmp then
112423: LD_VAR 0 4
112427: IFFALSE 112553
// begin for j in tmp do
112429: LD_ADDR_VAR 0 2
112433: PUSH
112434: LD_VAR 0 4
112438: PUSH
112439: FOR_IN
112440: IFFALSE 112551
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
112442: LD_VAR 0 2
112446: PPUSH
112447: CALL_OW 262
112451: PUSH
112452: LD_INT 3
112454: EQUAL
112455: PUSH
112456: LD_VAR 0 2
112460: PPUSH
112461: CALL_OW 261
112465: PUSH
112466: LD_INT 20
112468: GREATER
112469: OR
112470: PUSH
112471: LD_VAR 0 2
112475: PPUSH
112476: CALL_OW 314
112480: NOT
112481: AND
112482: PUSH
112483: LD_VAR 0 2
112487: PPUSH
112488: CALL_OW 263
112492: PUSH
112493: LD_INT 1
112495: NONEQUAL
112496: PUSH
112497: LD_VAR 0 2
112501: PPUSH
112502: CALL_OW 311
112506: OR
112507: AND
112508: IFFALSE 112549
// begin ComCollect ( j , x , y ) ;
112510: LD_VAR 0 2
112514: PPUSH
112515: LD_VAR 0 6
112519: PPUSH
112520: LD_VAR 0 7
112524: PPUSH
112525: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
112529: LD_VAR 0 2
112533: PPUSH
112534: LD_VAR 0 8
112538: PPUSH
112539: CALL_OW 172
// exit ;
112543: POP
112544: POP
112545: POP
112546: POP
112547: GO 112557
// end ;
112549: GO 112439
112551: POP
112552: POP
// end ; end ;
112553: GO 111928
112555: POP
112556: POP
// end ; end_of_file
112557: PPOPN 9
112559: END
// export function SOS_UnitDestroyed ( un ) ; begin
112560: LD_INT 0
112562: PPUSH
// ComRadiation ( un ) ;
112563: LD_VAR 0 1
112567: PPUSH
112568: CALL 113629 0 1
// end ;
112572: LD_VAR 0 2
112576: RET
// export function SOS_UnitKamikazed ( un ) ; begin
112577: LD_INT 0
112579: PPUSH
// ComRadiation ( un ) ;
112580: LD_VAR 0 1
112584: PPUSH
112585: CALL 113629 0 1
// end ;
112589: LD_VAR 0 2
112593: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
112594: LD_INT 0
112596: PPUSH
// end ;
112597: LD_VAR 0 4
112601: RET
// export function SOS_Command ( cmd ) ; begin
112602: LD_INT 0
112604: PPUSH
// end ;
112605: LD_VAR 0 2
112609: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
112610: LD_INT 0
112612: PPUSH
// end ;
112613: LD_VAR 0 6
112617: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex ; begin
112618: LD_INT 0
112620: PPUSH
112621: PPUSH
112622: PPUSH
112623: PPUSH
// if not vehicle or not factory then
112624: LD_VAR 0 1
112628: NOT
112629: PUSH
112630: LD_VAR 0 2
112634: NOT
112635: OR
112636: IFFALSE 112640
// exit ;
112638: GO 113220
// if not factoryWaypoints then
112640: LD_EXP 184
112644: NOT
112645: IFFALSE 112649
// exit ;
112647: GO 113220
// for i := 1 to Count ( factoryWaypoints ) do
112649: LD_ADDR_VAR 0 4
112653: PUSH
112654: DOUBLE
112655: LD_INT 1
112657: DEC
112658: ST_TO_ADDR
112659: LD_EXP 184
112663: PPUSH
112664: CALL 55914 0 1
112668: PUSH
112669: FOR_TO
112670: IFFALSE 113218
// if factoryWaypoints [ i ] [ 2 ] = factory then
112672: LD_EXP 184
112676: PUSH
112677: LD_VAR 0 4
112681: ARRAY
112682: PUSH
112683: LD_INT 2
112685: ARRAY
112686: PUSH
112687: LD_VAR 0 2
112691: EQUAL
112692: IFFALSE 113216
// begin if GetControl ( vehicle ) = control_manual then
112694: LD_VAR 0 1
112698: PPUSH
112699: CALL_OW 263
112703: PUSH
112704: LD_INT 1
112706: EQUAL
112707: IFFALSE 113069
// begin driver := IsDrivenBy ( vehicle ) ;
112709: LD_ADDR_VAR 0 5
112713: PUSH
112714: LD_VAR 0 1
112718: PPUSH
112719: CALL_OW 311
112723: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
112724: LD_VAR 0 5
112728: PUSH
112729: LD_EXP 185
112733: IN
112734: PUSH
112735: LD_VAR 0 1
112739: PUSH
112740: LD_EXP 185
112744: IN
112745: OR
112746: IFFALSE 112752
// exit ;
112748: POP
112749: POP
112750: GO 113220
// if not HasTask ( driver ) then
112752: LD_VAR 0 5
112756: PPUSH
112757: CALL_OW 314
112761: NOT
112762: IFFALSE 113067
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
112764: LD_ADDR_EXP 185
112768: PUSH
112769: LD_EXP 185
112773: PPUSH
112774: LD_VAR 0 5
112778: PPUSH
112779: CALL 91523 0 2
112783: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
112784: LD_ADDR_EXP 185
112788: PUSH
112789: LD_EXP 185
112793: PPUSH
112794: LD_VAR 0 1
112798: PPUSH
112799: CALL 91523 0 2
112803: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
112804: LD_ADDR_VAR 0 6
112808: PUSH
112809: LD_EXP 184
112813: PUSH
112814: LD_VAR 0 4
112818: ARRAY
112819: PUSH
112820: LD_INT 3
112822: ARRAY
112823: PPUSH
112824: LD_EXP 184
112828: PUSH
112829: LD_VAR 0 4
112833: ARRAY
112834: PUSH
112835: LD_INT 4
112837: ARRAY
112838: PPUSH
112839: CALL_OW 428
112843: ST_TO_ADDR
// if hex then
112844: LD_VAR 0 6
112848: IFFALSE 112866
// ComMoveUnit ( driver , hex ) else
112850: LD_VAR 0 5
112854: PPUSH
112855: LD_VAR 0 6
112859: PPUSH
112860: CALL_OW 112
112864: GO 112950
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
112866: LD_VAR 0 1
112870: PPUSH
112871: LD_EXP 184
112875: PUSH
112876: LD_VAR 0 4
112880: ARRAY
112881: PUSH
112882: LD_INT 3
112884: ARRAY
112885: PPUSH
112886: LD_EXP 184
112890: PUSH
112891: LD_VAR 0 4
112895: ARRAY
112896: PUSH
112897: LD_INT 4
112899: ARRAY
112900: PPUSH
112901: CALL_OW 297
112905: PUSH
112906: LD_INT 0
112908: GREATER
112909: IFFALSE 112950
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
112911: LD_VAR 0 5
112915: PPUSH
112916: LD_EXP 184
112920: PUSH
112921: LD_VAR 0 4
112925: ARRAY
112926: PUSH
112927: LD_INT 3
112929: ARRAY
112930: PPUSH
112931: LD_EXP 184
112935: PUSH
112936: LD_VAR 0 4
112940: ARRAY
112941: PUSH
112942: LD_INT 4
112944: ARRAY
112945: PPUSH
112946: CALL_OW 111
// AddComExitVehicle ( driver ) ;
112950: LD_VAR 0 5
112954: PPUSH
112955: CALL_OW 181
// if Multiplayer then
112959: LD_OWVAR 4
112963: IFFALSE 113012
// begin repeat wait ( 10 ) ;
112965: LD_INT 10
112967: PPUSH
112968: CALL_OW 67
// until not IsInUnit ( driver ) ;
112972: LD_VAR 0 5
112976: PPUSH
112977: CALL_OW 310
112981: NOT
112982: IFFALSE 112965
// if not HasTask ( driver ) then
112984: LD_VAR 0 5
112988: PPUSH
112989: CALL_OW 314
112993: NOT
112994: IFFALSE 113010
// ComEnterUnit ( driver , factory ) ;
112996: LD_VAR 0 5
113000: PPUSH
113001: LD_VAR 0 2
113005: PPUSH
113006: CALL_OW 120
// end else
113010: GO 113026
// AddComEnterUnit ( driver , factory ) ;
113012: LD_VAR 0 5
113016: PPUSH
113017: LD_VAR 0 2
113021: PPUSH
113022: CALL_OW 180
// wait ( 0 0$1 ) ;
113026: LD_INT 35
113028: PPUSH
113029: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
113033: LD_ADDR_EXP 185
113037: PUSH
113038: LD_EXP 185
113042: PUSH
113043: LD_VAR 0 5
113047: DIFF
113048: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
113049: LD_ADDR_EXP 185
113053: PUSH
113054: LD_EXP 185
113058: PUSH
113059: LD_VAR 0 1
113063: DIFF
113064: ST_TO_ADDR
// break ;
113065: GO 113218
// end ; end else
113067: GO 113216
// if GetControl ( vehicle ) = control_remote then
113069: LD_VAR 0 1
113073: PPUSH
113074: CALL_OW 263
113078: PUSH
113079: LD_INT 2
113081: EQUAL
113082: IFFALSE 113168
// begin wait ( 0 0$2 ) ;
113084: LD_INT 70
113086: PPUSH
113087: CALL_OW 67
// repeat wait ( 10 ) ;
113091: LD_INT 10
113093: PPUSH
113094: CALL_OW 67
// Connect ( vehicle ) ;
113098: LD_VAR 0 1
113102: PPUSH
113103: CALL 62120 0 1
// until IsControledBy ( vehicle ) ;
113107: LD_VAR 0 1
113111: PPUSH
113112: CALL_OW 312
113116: IFFALSE 113091
// wait ( 10 ) ;
113118: LD_INT 10
113120: PPUSH
113121: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
113125: LD_VAR 0 1
113129: PPUSH
113130: LD_EXP 184
113134: PUSH
113135: LD_VAR 0 4
113139: ARRAY
113140: PUSH
113141: LD_INT 3
113143: ARRAY
113144: PPUSH
113145: LD_EXP 184
113149: PUSH
113150: LD_VAR 0 4
113154: ARRAY
113155: PUSH
113156: LD_INT 4
113158: ARRAY
113159: PPUSH
113160: CALL_OW 111
// break ;
113164: GO 113218
// end else
113166: GO 113216
// begin wait ( 0 0$3 ) ;
113168: LD_INT 105
113170: PPUSH
113171: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
113175: LD_VAR 0 1
113179: PPUSH
113180: LD_EXP 184
113184: PUSH
113185: LD_VAR 0 4
113189: ARRAY
113190: PUSH
113191: LD_INT 3
113193: ARRAY
113194: PPUSH
113195: LD_EXP 184
113199: PUSH
113200: LD_VAR 0 4
113204: ARRAY
113205: PUSH
113206: LD_INT 4
113208: ARRAY
113209: PPUSH
113210: CALL_OW 111
// break ;
113214: GO 113218
// end ; end ;
113216: GO 112669
113218: POP
113219: POP
// end ;
113220: LD_VAR 0 3
113224: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
113225: LD_INT 0
113227: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
113228: LD_VAR 0 1
113232: PUSH
113233: LD_INT 250
113235: EQUAL
113236: PUSH
113237: LD_VAR 0 2
113241: PPUSH
113242: CALL_OW 264
113246: PUSH
113247: LD_INT 81
113249: EQUAL
113250: AND
113251: IFFALSE 113272
// MinerPlaceMine ( unit , x , y ) ;
113253: LD_VAR 0 2
113257: PPUSH
113258: LD_VAR 0 4
113262: PPUSH
113263: LD_VAR 0 5
113267: PPUSH
113268: CALL 116364 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
113272: LD_VAR 0 1
113276: PUSH
113277: LD_INT 251
113279: EQUAL
113280: PUSH
113281: LD_VAR 0 2
113285: PPUSH
113286: CALL_OW 264
113290: PUSH
113291: LD_INT 81
113293: EQUAL
113294: AND
113295: IFFALSE 113316
// MinerDetonateMine ( unit , x , y ) ;
113297: LD_VAR 0 2
113301: PPUSH
113302: LD_VAR 0 4
113306: PPUSH
113307: LD_VAR 0 5
113311: PPUSH
113312: CALL 116639 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
113316: LD_VAR 0 1
113320: PUSH
113321: LD_INT 252
113323: EQUAL
113324: PUSH
113325: LD_VAR 0 2
113329: PPUSH
113330: CALL_OW 264
113334: PUSH
113335: LD_INT 81
113337: EQUAL
113338: AND
113339: IFFALSE 113360
// MinerCreateMinefield ( unit , x , y ) ;
113341: LD_VAR 0 2
113345: PPUSH
113346: LD_VAR 0 4
113350: PPUSH
113351: LD_VAR 0 5
113355: PPUSH
113356: CALL 117056 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
113360: LD_VAR 0 1
113364: PUSH
113365: LD_INT 253
113367: EQUAL
113368: PUSH
113369: LD_VAR 0 2
113373: PPUSH
113374: CALL_OW 257
113378: PUSH
113379: LD_INT 5
113381: EQUAL
113382: AND
113383: IFFALSE 113404
// ComBinocular ( unit , x , y ) ;
113385: LD_VAR 0 2
113389: PPUSH
113390: LD_VAR 0 4
113394: PPUSH
113395: LD_VAR 0 5
113399: PPUSH
113400: CALL 117425 0 3
// if selectedUnit then
113404: LD_VAR 0 3
113408: IFFALSE 113464
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
113410: LD_VAR 0 1
113414: PUSH
113415: LD_INT 254
113417: EQUAL
113418: PUSH
113419: LD_VAR 0 2
113423: PPUSH
113424: CALL_OW 264
113428: PUSH
113429: LD_INT 99
113431: EQUAL
113432: AND
113433: PUSH
113434: LD_VAR 0 3
113438: PPUSH
113439: CALL_OW 263
113443: PUSH
113444: LD_INT 3
113446: EQUAL
113447: AND
113448: IFFALSE 113464
// HackDestroyVehicle ( unit , selectedUnit ) ;
113450: LD_VAR 0 2
113454: PPUSH
113455: LD_VAR 0 3
113459: PPUSH
113460: CALL 115728 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
113464: LD_VAR 0 1
113468: PUSH
113469: LD_INT 255
113471: EQUAL
113472: PUSH
113473: LD_VAR 0 2
113477: PPUSH
113478: CALL_OW 264
113482: PUSH
113483: LD_INT 14
113485: PUSH
113486: LD_INT 53
113488: PUSH
113489: EMPTY
113490: LIST
113491: LIST
113492: IN
113493: AND
113494: PUSH
113495: LD_VAR 0 4
113499: PPUSH
113500: LD_VAR 0 5
113504: PPUSH
113505: CALL_OW 488
113509: AND
113510: IFFALSE 113534
// CutTreeXYR ( unit , x , y , 12 ) ;
113512: LD_VAR 0 2
113516: PPUSH
113517: LD_VAR 0 4
113521: PPUSH
113522: LD_VAR 0 5
113526: PPUSH
113527: LD_INT 12
113529: PPUSH
113530: CALL 113725 0 4
// if cmd = 256 then
113534: LD_VAR 0 1
113538: PUSH
113539: LD_INT 256
113541: EQUAL
113542: IFFALSE 113563
// SetFactoryWaypoint ( unit , x , y ) ;
113544: LD_VAR 0 2
113548: PPUSH
113549: LD_VAR 0 4
113553: PPUSH
113554: LD_VAR 0 5
113558: PPUSH
113559: CALL 111121 0 3
// if cmd = 257 then
113563: LD_VAR 0 1
113567: PUSH
113568: LD_INT 257
113570: EQUAL
113571: IFFALSE 113592
// SetWarehouseGatheringPoint ( unit , x , y ) ;
113573: LD_VAR 0 2
113577: PPUSH
113578: LD_VAR 0 4
113582: PPUSH
113583: LD_VAR 0 5
113587: PPUSH
113588: CALL 111611 0 3
// if cmd = 258 then
113592: LD_VAR 0 1
113596: PUSH
113597: LD_INT 258
113599: EQUAL
113600: IFFALSE 113624
// BurnTreeXYR ( unit , x , y , 8 ) ;
113602: LD_VAR 0 2
113606: PPUSH
113607: LD_VAR 0 4
113611: PPUSH
113612: LD_VAR 0 5
113616: PPUSH
113617: LD_INT 8
113619: PPUSH
113620: CALL 114119 0 4
// end ;
113624: LD_VAR 0 6
113628: RET
// export function ComRadiation ( un ) ; var eff ; begin
113629: LD_INT 0
113631: PPUSH
113632: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
113633: LD_VAR 0 1
113637: PPUSH
113638: CALL_OW 264
113642: PUSH
113643: LD_INT 91
113645: NONEQUAL
113646: IFFALSE 113650
// exit ;
113648: GO 113720
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
113650: LD_INT 68
113652: PPUSH
113653: LD_VAR 0 1
113657: PPUSH
113658: CALL_OW 255
113662: PPUSH
113663: CALL_OW 321
113667: PUSH
113668: LD_INT 2
113670: EQUAL
113671: IFFALSE 113683
// eff := 50 else
113673: LD_ADDR_VAR 0 3
113677: PUSH
113678: LD_INT 50
113680: ST_TO_ADDR
113681: GO 113691
// eff := 25 ;
113683: LD_ADDR_VAR 0 3
113687: PUSH
113688: LD_INT 25
113690: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
113691: LD_VAR 0 1
113695: PPUSH
113696: CALL_OW 250
113700: PPUSH
113701: LD_VAR 0 1
113705: PPUSH
113706: CALL_OW 251
113710: PPUSH
113711: LD_VAR 0 3
113715: PPUSH
113716: CALL_OW 495
// end ;
113720: LD_VAR 0 2
113724: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
113725: LD_INT 0
113727: PPUSH
113728: PPUSH
113729: PPUSH
113730: PPUSH
113731: PPUSH
113732: PPUSH
113733: PPUSH
113734: PPUSH
113735: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
113736: LD_VAR 0 1
113740: PPUSH
113741: CALL_OW 302
113745: NOT
113746: PUSH
113747: LD_VAR 0 2
113751: PPUSH
113752: LD_VAR 0 3
113756: PPUSH
113757: CALL_OW 488
113761: NOT
113762: OR
113763: PUSH
113764: LD_VAR 0 4
113768: NOT
113769: OR
113770: IFFALSE 113774
// exit ;
113772: GO 114114
// list := [ ] ;
113774: LD_ADDR_VAR 0 13
113778: PUSH
113779: EMPTY
113780: ST_TO_ADDR
// if x - r < 0 then
113781: LD_VAR 0 2
113785: PUSH
113786: LD_VAR 0 4
113790: MINUS
113791: PUSH
113792: LD_INT 0
113794: LESS
113795: IFFALSE 113807
// min_x := 0 else
113797: LD_ADDR_VAR 0 7
113801: PUSH
113802: LD_INT 0
113804: ST_TO_ADDR
113805: GO 113823
// min_x := x - r ;
113807: LD_ADDR_VAR 0 7
113811: PUSH
113812: LD_VAR 0 2
113816: PUSH
113817: LD_VAR 0 4
113821: MINUS
113822: ST_TO_ADDR
// if y - r < 0 then
113823: LD_VAR 0 3
113827: PUSH
113828: LD_VAR 0 4
113832: MINUS
113833: PUSH
113834: LD_INT 0
113836: LESS
113837: IFFALSE 113849
// min_y := 0 else
113839: LD_ADDR_VAR 0 8
113843: PUSH
113844: LD_INT 0
113846: ST_TO_ADDR
113847: GO 113865
// min_y := y - r ;
113849: LD_ADDR_VAR 0 8
113853: PUSH
113854: LD_VAR 0 3
113858: PUSH
113859: LD_VAR 0 4
113863: MINUS
113864: ST_TO_ADDR
// max_x := x + r ;
113865: LD_ADDR_VAR 0 9
113869: PUSH
113870: LD_VAR 0 2
113874: PUSH
113875: LD_VAR 0 4
113879: PLUS
113880: ST_TO_ADDR
// max_y := y + r ;
113881: LD_ADDR_VAR 0 10
113885: PUSH
113886: LD_VAR 0 3
113890: PUSH
113891: LD_VAR 0 4
113895: PLUS
113896: ST_TO_ADDR
// for _x = min_x to max_x do
113897: LD_ADDR_VAR 0 11
113901: PUSH
113902: DOUBLE
113903: LD_VAR 0 7
113907: DEC
113908: ST_TO_ADDR
113909: LD_VAR 0 9
113913: PUSH
113914: FOR_TO
113915: IFFALSE 114032
// for _y = min_y to max_y do
113917: LD_ADDR_VAR 0 12
113921: PUSH
113922: DOUBLE
113923: LD_VAR 0 8
113927: DEC
113928: ST_TO_ADDR
113929: LD_VAR 0 10
113933: PUSH
113934: FOR_TO
113935: IFFALSE 114028
// begin if not ValidHex ( _x , _y ) then
113937: LD_VAR 0 11
113941: PPUSH
113942: LD_VAR 0 12
113946: PPUSH
113947: CALL_OW 488
113951: NOT
113952: IFFALSE 113956
// continue ;
113954: GO 113934
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
113956: LD_VAR 0 11
113960: PPUSH
113961: LD_VAR 0 12
113965: PPUSH
113966: CALL_OW 351
113970: PUSH
113971: LD_VAR 0 11
113975: PPUSH
113976: LD_VAR 0 12
113980: PPUSH
113981: CALL_OW 554
113985: AND
113986: IFFALSE 114026
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
113988: LD_ADDR_VAR 0 13
113992: PUSH
113993: LD_VAR 0 13
113997: PPUSH
113998: LD_VAR 0 13
114002: PUSH
114003: LD_INT 1
114005: PLUS
114006: PPUSH
114007: LD_VAR 0 11
114011: PUSH
114012: LD_VAR 0 12
114016: PUSH
114017: EMPTY
114018: LIST
114019: LIST
114020: PPUSH
114021: CALL_OW 2
114025: ST_TO_ADDR
// end ;
114026: GO 113934
114028: POP
114029: POP
114030: GO 113914
114032: POP
114033: POP
// if not list then
114034: LD_VAR 0 13
114038: NOT
114039: IFFALSE 114043
// exit ;
114041: GO 114114
// for i in list do
114043: LD_ADDR_VAR 0 6
114047: PUSH
114048: LD_VAR 0 13
114052: PUSH
114053: FOR_IN
114054: IFFALSE 114112
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
114056: LD_VAR 0 1
114060: PPUSH
114061: LD_STRING M
114063: PUSH
114064: LD_VAR 0 6
114068: PUSH
114069: LD_INT 1
114071: ARRAY
114072: PUSH
114073: LD_VAR 0 6
114077: PUSH
114078: LD_INT 2
114080: ARRAY
114081: PUSH
114082: LD_INT 0
114084: PUSH
114085: LD_INT 0
114087: PUSH
114088: LD_INT 0
114090: PUSH
114091: LD_INT 0
114093: PUSH
114094: EMPTY
114095: LIST
114096: LIST
114097: LIST
114098: LIST
114099: LIST
114100: LIST
114101: LIST
114102: PUSH
114103: EMPTY
114104: LIST
114105: PPUSH
114106: CALL_OW 447
114110: GO 114053
114112: POP
114113: POP
// end ;
114114: LD_VAR 0 5
114118: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
114119: LD_INT 0
114121: PPUSH
114122: PPUSH
114123: PPUSH
114124: PPUSH
114125: PPUSH
114126: PPUSH
114127: PPUSH
114128: PPUSH
114129: PPUSH
114130: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
114131: LD_VAR 0 1
114135: PPUSH
114136: CALL_OW 302
114140: NOT
114141: PUSH
114142: LD_VAR 0 2
114146: PPUSH
114147: LD_VAR 0 3
114151: PPUSH
114152: CALL_OW 488
114156: NOT
114157: OR
114158: PUSH
114159: LD_VAR 0 4
114163: NOT
114164: OR
114165: IFFALSE 114169
// exit ;
114167: GO 114682
// list := [ ] ;
114169: LD_ADDR_VAR 0 13
114173: PUSH
114174: EMPTY
114175: ST_TO_ADDR
// if x - r < 0 then
114176: LD_VAR 0 2
114180: PUSH
114181: LD_VAR 0 4
114185: MINUS
114186: PUSH
114187: LD_INT 0
114189: LESS
114190: IFFALSE 114202
// min_x := 0 else
114192: LD_ADDR_VAR 0 7
114196: PUSH
114197: LD_INT 0
114199: ST_TO_ADDR
114200: GO 114218
// min_x := x - r ;
114202: LD_ADDR_VAR 0 7
114206: PUSH
114207: LD_VAR 0 2
114211: PUSH
114212: LD_VAR 0 4
114216: MINUS
114217: ST_TO_ADDR
// if y - r < 0 then
114218: LD_VAR 0 3
114222: PUSH
114223: LD_VAR 0 4
114227: MINUS
114228: PUSH
114229: LD_INT 0
114231: LESS
114232: IFFALSE 114244
// min_y := 0 else
114234: LD_ADDR_VAR 0 8
114238: PUSH
114239: LD_INT 0
114241: ST_TO_ADDR
114242: GO 114260
// min_y := y - r ;
114244: LD_ADDR_VAR 0 8
114248: PUSH
114249: LD_VAR 0 3
114253: PUSH
114254: LD_VAR 0 4
114258: MINUS
114259: ST_TO_ADDR
// max_x := x + r ;
114260: LD_ADDR_VAR 0 9
114264: PUSH
114265: LD_VAR 0 2
114269: PUSH
114270: LD_VAR 0 4
114274: PLUS
114275: ST_TO_ADDR
// max_y := y + r ;
114276: LD_ADDR_VAR 0 10
114280: PUSH
114281: LD_VAR 0 3
114285: PUSH
114286: LD_VAR 0 4
114290: PLUS
114291: ST_TO_ADDR
// for _x = min_x to max_x do
114292: LD_ADDR_VAR 0 11
114296: PUSH
114297: DOUBLE
114298: LD_VAR 0 7
114302: DEC
114303: ST_TO_ADDR
114304: LD_VAR 0 9
114308: PUSH
114309: FOR_TO
114310: IFFALSE 114427
// for _y = min_y to max_y do
114312: LD_ADDR_VAR 0 12
114316: PUSH
114317: DOUBLE
114318: LD_VAR 0 8
114322: DEC
114323: ST_TO_ADDR
114324: LD_VAR 0 10
114328: PUSH
114329: FOR_TO
114330: IFFALSE 114423
// begin if not ValidHex ( _x , _y ) then
114332: LD_VAR 0 11
114336: PPUSH
114337: LD_VAR 0 12
114341: PPUSH
114342: CALL_OW 488
114346: NOT
114347: IFFALSE 114351
// continue ;
114349: GO 114329
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
114351: LD_VAR 0 11
114355: PPUSH
114356: LD_VAR 0 12
114360: PPUSH
114361: CALL_OW 351
114365: PUSH
114366: LD_VAR 0 11
114370: PPUSH
114371: LD_VAR 0 12
114375: PPUSH
114376: CALL_OW 554
114380: AND
114381: IFFALSE 114421
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
114383: LD_ADDR_VAR 0 13
114387: PUSH
114388: LD_VAR 0 13
114392: PPUSH
114393: LD_VAR 0 13
114397: PUSH
114398: LD_INT 1
114400: PLUS
114401: PPUSH
114402: LD_VAR 0 11
114406: PUSH
114407: LD_VAR 0 12
114411: PUSH
114412: EMPTY
114413: LIST
114414: LIST
114415: PPUSH
114416: CALL_OW 2
114420: ST_TO_ADDR
// end ;
114421: GO 114329
114423: POP
114424: POP
114425: GO 114309
114427: POP
114428: POP
// if not list then
114429: LD_VAR 0 13
114433: NOT
114434: IFFALSE 114438
// exit ;
114436: GO 114682
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
114438: LD_ADDR_VAR 0 13
114442: PUSH
114443: LD_VAR 0 1
114447: PPUSH
114448: LD_VAR 0 13
114452: PPUSH
114453: LD_INT 1
114455: PPUSH
114456: LD_INT 1
114458: PPUSH
114459: CALL 59262 0 4
114463: ST_TO_ADDR
// ComStop ( flame ) ;
114464: LD_VAR 0 1
114468: PPUSH
114469: CALL_OW 141
// for i in list do
114473: LD_ADDR_VAR 0 6
114477: PUSH
114478: LD_VAR 0 13
114482: PUSH
114483: FOR_IN
114484: IFFALSE 114515
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
114486: LD_VAR 0 1
114490: PPUSH
114491: LD_VAR 0 6
114495: PUSH
114496: LD_INT 1
114498: ARRAY
114499: PPUSH
114500: LD_VAR 0 6
114504: PUSH
114505: LD_INT 2
114507: ARRAY
114508: PPUSH
114509: CALL_OW 176
114513: GO 114483
114515: POP
114516: POP
// repeat wait ( 0 0$1 ) ;
114517: LD_INT 35
114519: PPUSH
114520: CALL_OW 67
// task := GetTaskList ( flame ) ;
114524: LD_ADDR_VAR 0 14
114528: PUSH
114529: LD_VAR 0 1
114533: PPUSH
114534: CALL_OW 437
114538: ST_TO_ADDR
// if not task then
114539: LD_VAR 0 14
114543: NOT
114544: IFFALSE 114548
// exit ;
114546: GO 114682
// if task [ 1 ] [ 1 ] <> | then
114548: LD_VAR 0 14
114552: PUSH
114553: LD_INT 1
114555: ARRAY
114556: PUSH
114557: LD_INT 1
114559: ARRAY
114560: PUSH
114561: LD_STRING |
114563: NONEQUAL
114564: IFFALSE 114568
// exit ;
114566: GO 114682
// _x := task [ 1 ] [ 2 ] ;
114568: LD_ADDR_VAR 0 11
114572: PUSH
114573: LD_VAR 0 14
114577: PUSH
114578: LD_INT 1
114580: ARRAY
114581: PUSH
114582: LD_INT 2
114584: ARRAY
114585: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
114586: LD_ADDR_VAR 0 12
114590: PUSH
114591: LD_VAR 0 14
114595: PUSH
114596: LD_INT 1
114598: ARRAY
114599: PUSH
114600: LD_INT 3
114602: ARRAY
114603: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
114604: LD_VAR 0 11
114608: PPUSH
114609: LD_VAR 0 12
114613: PPUSH
114614: CALL_OW 351
114618: NOT
114619: PUSH
114620: LD_VAR 0 11
114624: PPUSH
114625: LD_VAR 0 12
114629: PPUSH
114630: CALL_OW 554
114634: NOT
114635: OR
114636: IFFALSE 114670
// begin task := Delete ( task , 1 ) ;
114638: LD_ADDR_VAR 0 14
114642: PUSH
114643: LD_VAR 0 14
114647: PPUSH
114648: LD_INT 1
114650: PPUSH
114651: CALL_OW 3
114655: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
114656: LD_VAR 0 1
114660: PPUSH
114661: LD_VAR 0 14
114665: PPUSH
114666: CALL_OW 446
// end ; until not HasTask ( flame ) ;
114670: LD_VAR 0 1
114674: PPUSH
114675: CALL_OW 314
114679: NOT
114680: IFFALSE 114517
// end ;
114682: LD_VAR 0 5
114686: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
114687: LD_EXP 188
114691: NOT
114692: IFFALSE 114742
114694: GO 114696
114696: DISABLE
// begin initHack := true ;
114697: LD_ADDR_EXP 188
114701: PUSH
114702: LD_INT 1
114704: ST_TO_ADDR
// hackTanks := [ ] ;
114705: LD_ADDR_EXP 189
114709: PUSH
114710: EMPTY
114711: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
114712: LD_ADDR_EXP 190
114716: PUSH
114717: EMPTY
114718: ST_TO_ADDR
// hackLimit := 3 ;
114719: LD_ADDR_EXP 191
114723: PUSH
114724: LD_INT 3
114726: ST_TO_ADDR
// hackDist := 12 ;
114727: LD_ADDR_EXP 192
114731: PUSH
114732: LD_INT 12
114734: ST_TO_ADDR
// hackCounter := [ ] ;
114735: LD_ADDR_EXP 193
114739: PUSH
114740: EMPTY
114741: ST_TO_ADDR
// end ;
114742: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
114743: LD_EXP 188
114747: PUSH
114748: LD_INT 34
114750: PUSH
114751: LD_INT 99
114753: PUSH
114754: EMPTY
114755: LIST
114756: LIST
114757: PPUSH
114758: CALL_OW 69
114762: AND
114763: IFFALSE 115016
114765: GO 114767
114767: DISABLE
114768: LD_INT 0
114770: PPUSH
114771: PPUSH
// begin enable ;
114772: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
114773: LD_ADDR_VAR 0 1
114777: PUSH
114778: LD_INT 34
114780: PUSH
114781: LD_INT 99
114783: PUSH
114784: EMPTY
114785: LIST
114786: LIST
114787: PPUSH
114788: CALL_OW 69
114792: PUSH
114793: FOR_IN
114794: IFFALSE 115014
// begin if not i in hackTanks then
114796: LD_VAR 0 1
114800: PUSH
114801: LD_EXP 189
114805: IN
114806: NOT
114807: IFFALSE 114890
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
114809: LD_ADDR_EXP 189
114813: PUSH
114814: LD_EXP 189
114818: PPUSH
114819: LD_EXP 189
114823: PUSH
114824: LD_INT 1
114826: PLUS
114827: PPUSH
114828: LD_VAR 0 1
114832: PPUSH
114833: CALL_OW 1
114837: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
114838: LD_ADDR_EXP 190
114842: PUSH
114843: LD_EXP 190
114847: PPUSH
114848: LD_EXP 190
114852: PUSH
114853: LD_INT 1
114855: PLUS
114856: PPUSH
114857: EMPTY
114858: PPUSH
114859: CALL_OW 1
114863: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
114864: LD_ADDR_EXP 193
114868: PUSH
114869: LD_EXP 193
114873: PPUSH
114874: LD_EXP 193
114878: PUSH
114879: LD_INT 1
114881: PLUS
114882: PPUSH
114883: EMPTY
114884: PPUSH
114885: CALL_OW 1
114889: ST_TO_ADDR
// end ; if not IsOk ( i ) then
114890: LD_VAR 0 1
114894: PPUSH
114895: CALL_OW 302
114899: NOT
114900: IFFALSE 114913
// begin HackUnlinkAll ( i ) ;
114902: LD_VAR 0 1
114906: PPUSH
114907: CALL 115019 0 1
// continue ;
114911: GO 114793
// end ; HackCheckCapturedStatus ( i ) ;
114913: LD_VAR 0 1
114917: PPUSH
114918: CALL 115462 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
114922: LD_ADDR_VAR 0 2
114926: PUSH
114927: LD_INT 81
114929: PUSH
114930: LD_VAR 0 1
114934: PPUSH
114935: CALL_OW 255
114939: PUSH
114940: EMPTY
114941: LIST
114942: LIST
114943: PUSH
114944: LD_INT 33
114946: PUSH
114947: LD_INT 3
114949: PUSH
114950: EMPTY
114951: LIST
114952: LIST
114953: PUSH
114954: LD_INT 91
114956: PUSH
114957: LD_VAR 0 1
114961: PUSH
114962: LD_EXP 192
114966: PUSH
114967: EMPTY
114968: LIST
114969: LIST
114970: LIST
114971: PUSH
114972: LD_INT 50
114974: PUSH
114975: EMPTY
114976: LIST
114977: PUSH
114978: EMPTY
114979: LIST
114980: LIST
114981: LIST
114982: LIST
114983: PPUSH
114984: CALL_OW 69
114988: ST_TO_ADDR
// if not tmp then
114989: LD_VAR 0 2
114993: NOT
114994: IFFALSE 114998
// continue ;
114996: GO 114793
// HackLink ( i , tmp ) ;
114998: LD_VAR 0 1
115002: PPUSH
115003: LD_VAR 0 2
115007: PPUSH
115008: CALL 115155 0 2
// end ;
115012: GO 114793
115014: POP
115015: POP
// end ;
115016: PPOPN 2
115018: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
115019: LD_INT 0
115021: PPUSH
115022: PPUSH
115023: PPUSH
// if not hack in hackTanks then
115024: LD_VAR 0 1
115028: PUSH
115029: LD_EXP 189
115033: IN
115034: NOT
115035: IFFALSE 115039
// exit ;
115037: GO 115150
// index := GetElementIndex ( hackTanks , hack ) ;
115039: LD_ADDR_VAR 0 4
115043: PUSH
115044: LD_EXP 189
115048: PPUSH
115049: LD_VAR 0 1
115053: PPUSH
115054: CALL 58559 0 2
115058: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
115059: LD_EXP 190
115063: PUSH
115064: LD_VAR 0 4
115068: ARRAY
115069: IFFALSE 115150
// begin for i in hackTanksCaptured [ index ] do
115071: LD_ADDR_VAR 0 3
115075: PUSH
115076: LD_EXP 190
115080: PUSH
115081: LD_VAR 0 4
115085: ARRAY
115086: PUSH
115087: FOR_IN
115088: IFFALSE 115114
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
115090: LD_VAR 0 3
115094: PUSH
115095: LD_INT 1
115097: ARRAY
115098: PPUSH
115099: LD_VAR 0 3
115103: PUSH
115104: LD_INT 2
115106: ARRAY
115107: PPUSH
115108: CALL_OW 235
115112: GO 115087
115114: POP
115115: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
115116: LD_ADDR_EXP 190
115120: PUSH
115121: LD_EXP 190
115125: PPUSH
115126: LD_VAR 0 4
115130: PPUSH
115131: EMPTY
115132: PPUSH
115133: CALL_OW 1
115137: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
115138: LD_VAR 0 1
115142: PPUSH
115143: LD_INT 0
115145: PPUSH
115146: CALL_OW 505
// end ; end ;
115150: LD_VAR 0 2
115154: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
115155: LD_INT 0
115157: PPUSH
115158: PPUSH
115159: PPUSH
// if not hack in hackTanks or not vehicles then
115160: LD_VAR 0 1
115164: PUSH
115165: LD_EXP 189
115169: IN
115170: NOT
115171: PUSH
115172: LD_VAR 0 2
115176: NOT
115177: OR
115178: IFFALSE 115182
// exit ;
115180: GO 115457
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
115182: LD_ADDR_VAR 0 2
115186: PUSH
115187: LD_VAR 0 1
115191: PPUSH
115192: LD_VAR 0 2
115196: PPUSH
115197: LD_INT 1
115199: PPUSH
115200: LD_INT 1
115202: PPUSH
115203: CALL 59209 0 4
115207: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
115208: LD_ADDR_VAR 0 5
115212: PUSH
115213: LD_EXP 189
115217: PPUSH
115218: LD_VAR 0 1
115222: PPUSH
115223: CALL 58559 0 2
115227: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
115228: LD_EXP 190
115232: PUSH
115233: LD_VAR 0 5
115237: ARRAY
115238: PUSH
115239: LD_EXP 191
115243: LESS
115244: IFFALSE 115433
// begin for i := 1 to vehicles do
115246: LD_ADDR_VAR 0 4
115250: PUSH
115251: DOUBLE
115252: LD_INT 1
115254: DEC
115255: ST_TO_ADDR
115256: LD_VAR 0 2
115260: PUSH
115261: FOR_TO
115262: IFFALSE 115431
// begin if hackTanksCaptured [ index ] = hackLimit then
115264: LD_EXP 190
115268: PUSH
115269: LD_VAR 0 5
115273: ARRAY
115274: PUSH
115275: LD_EXP 191
115279: EQUAL
115280: IFFALSE 115284
// break ;
115282: GO 115431
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
115284: LD_ADDR_EXP 193
115288: PUSH
115289: LD_EXP 193
115293: PPUSH
115294: LD_VAR 0 5
115298: PPUSH
115299: LD_EXP 193
115303: PUSH
115304: LD_VAR 0 5
115308: ARRAY
115309: PUSH
115310: LD_INT 1
115312: PLUS
115313: PPUSH
115314: CALL_OW 1
115318: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
115319: LD_ADDR_EXP 190
115323: PUSH
115324: LD_EXP 190
115328: PPUSH
115329: LD_VAR 0 5
115333: PUSH
115334: LD_EXP 190
115338: PUSH
115339: LD_VAR 0 5
115343: ARRAY
115344: PUSH
115345: LD_INT 1
115347: PLUS
115348: PUSH
115349: EMPTY
115350: LIST
115351: LIST
115352: PPUSH
115353: LD_VAR 0 2
115357: PUSH
115358: LD_VAR 0 4
115362: ARRAY
115363: PUSH
115364: LD_VAR 0 2
115368: PUSH
115369: LD_VAR 0 4
115373: ARRAY
115374: PPUSH
115375: CALL_OW 255
115379: PUSH
115380: EMPTY
115381: LIST
115382: LIST
115383: PPUSH
115384: CALL 58774 0 3
115388: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
115389: LD_VAR 0 2
115393: PUSH
115394: LD_VAR 0 4
115398: ARRAY
115399: PPUSH
115400: LD_VAR 0 1
115404: PPUSH
115405: CALL_OW 255
115409: PPUSH
115410: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
115414: LD_VAR 0 2
115418: PUSH
115419: LD_VAR 0 4
115423: ARRAY
115424: PPUSH
115425: CALL_OW 141
// end ;
115429: GO 115261
115431: POP
115432: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
115433: LD_VAR 0 1
115437: PPUSH
115438: LD_EXP 190
115442: PUSH
115443: LD_VAR 0 5
115447: ARRAY
115448: PUSH
115449: LD_INT 0
115451: PLUS
115452: PPUSH
115453: CALL_OW 505
// end ;
115457: LD_VAR 0 3
115461: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
115462: LD_INT 0
115464: PPUSH
115465: PPUSH
115466: PPUSH
115467: PPUSH
// if not hack in hackTanks then
115468: LD_VAR 0 1
115472: PUSH
115473: LD_EXP 189
115477: IN
115478: NOT
115479: IFFALSE 115483
// exit ;
115481: GO 115723
// index := GetElementIndex ( hackTanks , hack ) ;
115483: LD_ADDR_VAR 0 4
115487: PUSH
115488: LD_EXP 189
115492: PPUSH
115493: LD_VAR 0 1
115497: PPUSH
115498: CALL 58559 0 2
115502: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
115503: LD_ADDR_VAR 0 3
115507: PUSH
115508: DOUBLE
115509: LD_EXP 190
115513: PUSH
115514: LD_VAR 0 4
115518: ARRAY
115519: INC
115520: ST_TO_ADDR
115521: LD_INT 1
115523: PUSH
115524: FOR_DOWNTO
115525: IFFALSE 115697
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
115527: LD_ADDR_VAR 0 5
115531: PUSH
115532: LD_EXP 190
115536: PUSH
115537: LD_VAR 0 4
115541: ARRAY
115542: PUSH
115543: LD_VAR 0 3
115547: ARRAY
115548: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
115549: LD_VAR 0 5
115553: PUSH
115554: LD_INT 1
115556: ARRAY
115557: PPUSH
115558: CALL_OW 302
115562: NOT
115563: PUSH
115564: LD_VAR 0 5
115568: PUSH
115569: LD_INT 1
115571: ARRAY
115572: PPUSH
115573: CALL_OW 255
115577: PUSH
115578: LD_VAR 0 1
115582: PPUSH
115583: CALL_OW 255
115587: NONEQUAL
115588: OR
115589: IFFALSE 115695
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
115591: LD_VAR 0 5
115595: PUSH
115596: LD_INT 1
115598: ARRAY
115599: PPUSH
115600: CALL_OW 305
115604: PUSH
115605: LD_VAR 0 5
115609: PUSH
115610: LD_INT 1
115612: ARRAY
115613: PPUSH
115614: CALL_OW 255
115618: PUSH
115619: LD_VAR 0 1
115623: PPUSH
115624: CALL_OW 255
115628: EQUAL
115629: AND
115630: IFFALSE 115654
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
115632: LD_VAR 0 5
115636: PUSH
115637: LD_INT 1
115639: ARRAY
115640: PPUSH
115641: LD_VAR 0 5
115645: PUSH
115646: LD_INT 2
115648: ARRAY
115649: PPUSH
115650: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
115654: LD_ADDR_EXP 190
115658: PUSH
115659: LD_EXP 190
115663: PPUSH
115664: LD_VAR 0 4
115668: PPUSH
115669: LD_EXP 190
115673: PUSH
115674: LD_VAR 0 4
115678: ARRAY
115679: PPUSH
115680: LD_VAR 0 3
115684: PPUSH
115685: CALL_OW 3
115689: PPUSH
115690: CALL_OW 1
115694: ST_TO_ADDR
// end ; end ;
115695: GO 115524
115697: POP
115698: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
115699: LD_VAR 0 1
115703: PPUSH
115704: LD_EXP 190
115708: PUSH
115709: LD_VAR 0 4
115713: ARRAY
115714: PUSH
115715: LD_INT 0
115717: PLUS
115718: PPUSH
115719: CALL_OW 505
// end ;
115723: LD_VAR 0 2
115727: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
115728: LD_INT 0
115730: PPUSH
115731: PPUSH
115732: PPUSH
115733: PPUSH
// if not hack in hackTanks then
115734: LD_VAR 0 1
115738: PUSH
115739: LD_EXP 189
115743: IN
115744: NOT
115745: IFFALSE 115749
// exit ;
115747: GO 115834
// index := GetElementIndex ( hackTanks , hack ) ;
115749: LD_ADDR_VAR 0 5
115753: PUSH
115754: LD_EXP 189
115758: PPUSH
115759: LD_VAR 0 1
115763: PPUSH
115764: CALL 58559 0 2
115768: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
115769: LD_ADDR_VAR 0 4
115773: PUSH
115774: DOUBLE
115775: LD_INT 1
115777: DEC
115778: ST_TO_ADDR
115779: LD_EXP 190
115783: PUSH
115784: LD_VAR 0 5
115788: ARRAY
115789: PUSH
115790: FOR_TO
115791: IFFALSE 115832
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
115793: LD_EXP 190
115797: PUSH
115798: LD_VAR 0 5
115802: ARRAY
115803: PUSH
115804: LD_VAR 0 4
115808: ARRAY
115809: PUSH
115810: LD_INT 1
115812: ARRAY
115813: PUSH
115814: LD_VAR 0 2
115818: EQUAL
115819: IFFALSE 115830
// KillUnit ( vehicle ) ;
115821: LD_VAR 0 2
115825: PPUSH
115826: CALL_OW 66
115830: GO 115790
115832: POP
115833: POP
// end ;
115834: LD_VAR 0 3
115838: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
115839: LD_EXP 194
115843: NOT
115844: IFFALSE 115879
115846: GO 115848
115848: DISABLE
// begin initMiner := true ;
115849: LD_ADDR_EXP 194
115853: PUSH
115854: LD_INT 1
115856: ST_TO_ADDR
// minersList := [ ] ;
115857: LD_ADDR_EXP 195
115861: PUSH
115862: EMPTY
115863: ST_TO_ADDR
// minerMinesList := [ ] ;
115864: LD_ADDR_EXP 196
115868: PUSH
115869: EMPTY
115870: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
115871: LD_ADDR_EXP 197
115875: PUSH
115876: LD_INT 5
115878: ST_TO_ADDR
// end ;
115879: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
115880: LD_EXP 194
115884: PUSH
115885: LD_INT 34
115887: PUSH
115888: LD_INT 81
115890: PUSH
115891: EMPTY
115892: LIST
115893: LIST
115894: PPUSH
115895: CALL_OW 69
115899: AND
115900: IFFALSE 116361
115902: GO 115904
115904: DISABLE
115905: LD_INT 0
115907: PPUSH
115908: PPUSH
115909: PPUSH
115910: PPUSH
// begin enable ;
115911: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
115912: LD_ADDR_VAR 0 1
115916: PUSH
115917: LD_INT 34
115919: PUSH
115920: LD_INT 81
115922: PUSH
115923: EMPTY
115924: LIST
115925: LIST
115926: PPUSH
115927: CALL_OW 69
115931: PUSH
115932: FOR_IN
115933: IFFALSE 116005
// begin if not i in minersList then
115935: LD_VAR 0 1
115939: PUSH
115940: LD_EXP 195
115944: IN
115945: NOT
115946: IFFALSE 116003
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
115948: LD_ADDR_EXP 195
115952: PUSH
115953: LD_EXP 195
115957: PPUSH
115958: LD_EXP 195
115962: PUSH
115963: LD_INT 1
115965: PLUS
115966: PPUSH
115967: LD_VAR 0 1
115971: PPUSH
115972: CALL_OW 1
115976: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
115977: LD_ADDR_EXP 196
115981: PUSH
115982: LD_EXP 196
115986: PPUSH
115987: LD_EXP 196
115991: PUSH
115992: LD_INT 1
115994: PLUS
115995: PPUSH
115996: EMPTY
115997: PPUSH
115998: CALL_OW 1
116002: ST_TO_ADDR
// end end ;
116003: GO 115932
116005: POP
116006: POP
// for i := minerMinesList downto 1 do
116007: LD_ADDR_VAR 0 1
116011: PUSH
116012: DOUBLE
116013: LD_EXP 196
116017: INC
116018: ST_TO_ADDR
116019: LD_INT 1
116021: PUSH
116022: FOR_DOWNTO
116023: IFFALSE 116359
// begin if IsLive ( minersList [ i ] ) then
116025: LD_EXP 195
116029: PUSH
116030: LD_VAR 0 1
116034: ARRAY
116035: PPUSH
116036: CALL_OW 300
116040: IFFALSE 116068
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
116042: LD_EXP 195
116046: PUSH
116047: LD_VAR 0 1
116051: ARRAY
116052: PPUSH
116053: LD_EXP 196
116057: PUSH
116058: LD_VAR 0 1
116062: ARRAY
116063: PPUSH
116064: CALL_OW 505
// if not minerMinesList [ i ] then
116068: LD_EXP 196
116072: PUSH
116073: LD_VAR 0 1
116077: ARRAY
116078: NOT
116079: IFFALSE 116083
// continue ;
116081: GO 116022
// for j := minerMinesList [ i ] downto 1 do
116083: LD_ADDR_VAR 0 2
116087: PUSH
116088: DOUBLE
116089: LD_EXP 196
116093: PUSH
116094: LD_VAR 0 1
116098: ARRAY
116099: INC
116100: ST_TO_ADDR
116101: LD_INT 1
116103: PUSH
116104: FOR_DOWNTO
116105: IFFALSE 116355
// begin side := GetSide ( minersList [ i ] ) ;
116107: LD_ADDR_VAR 0 3
116111: PUSH
116112: LD_EXP 195
116116: PUSH
116117: LD_VAR 0 1
116121: ARRAY
116122: PPUSH
116123: CALL_OW 255
116127: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
116128: LD_ADDR_VAR 0 4
116132: PUSH
116133: LD_EXP 196
116137: PUSH
116138: LD_VAR 0 1
116142: ARRAY
116143: PUSH
116144: LD_VAR 0 2
116148: ARRAY
116149: PUSH
116150: LD_INT 1
116152: ARRAY
116153: PPUSH
116154: LD_EXP 196
116158: PUSH
116159: LD_VAR 0 1
116163: ARRAY
116164: PUSH
116165: LD_VAR 0 2
116169: ARRAY
116170: PUSH
116171: LD_INT 2
116173: ARRAY
116174: PPUSH
116175: CALL_OW 428
116179: ST_TO_ADDR
// if not tmp then
116180: LD_VAR 0 4
116184: NOT
116185: IFFALSE 116189
// continue ;
116187: GO 116104
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
116189: LD_VAR 0 4
116193: PUSH
116194: LD_INT 81
116196: PUSH
116197: LD_VAR 0 3
116201: PUSH
116202: EMPTY
116203: LIST
116204: LIST
116205: PPUSH
116206: CALL_OW 69
116210: IN
116211: PUSH
116212: LD_EXP 196
116216: PUSH
116217: LD_VAR 0 1
116221: ARRAY
116222: PUSH
116223: LD_VAR 0 2
116227: ARRAY
116228: PUSH
116229: LD_INT 1
116231: ARRAY
116232: PPUSH
116233: LD_EXP 196
116237: PUSH
116238: LD_VAR 0 1
116242: ARRAY
116243: PUSH
116244: LD_VAR 0 2
116248: ARRAY
116249: PUSH
116250: LD_INT 2
116252: ARRAY
116253: PPUSH
116254: CALL_OW 458
116258: AND
116259: IFFALSE 116353
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
116261: LD_EXP 196
116265: PUSH
116266: LD_VAR 0 1
116270: ARRAY
116271: PUSH
116272: LD_VAR 0 2
116276: ARRAY
116277: PUSH
116278: LD_INT 1
116280: ARRAY
116281: PPUSH
116282: LD_EXP 196
116286: PUSH
116287: LD_VAR 0 1
116291: ARRAY
116292: PUSH
116293: LD_VAR 0 2
116297: ARRAY
116298: PUSH
116299: LD_INT 2
116301: ARRAY
116302: PPUSH
116303: LD_VAR 0 3
116307: PPUSH
116308: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
116312: LD_ADDR_EXP 196
116316: PUSH
116317: LD_EXP 196
116321: PPUSH
116322: LD_VAR 0 1
116326: PPUSH
116327: LD_EXP 196
116331: PUSH
116332: LD_VAR 0 1
116336: ARRAY
116337: PPUSH
116338: LD_VAR 0 2
116342: PPUSH
116343: CALL_OW 3
116347: PPUSH
116348: CALL_OW 1
116352: ST_TO_ADDR
// end ; end ;
116353: GO 116104
116355: POP
116356: POP
// end ;
116357: GO 116022
116359: POP
116360: POP
// end ;
116361: PPOPN 4
116363: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
116364: LD_INT 0
116366: PPUSH
116367: PPUSH
// result := false ;
116368: LD_ADDR_VAR 0 4
116372: PUSH
116373: LD_INT 0
116375: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
116376: LD_VAR 0 1
116380: PPUSH
116381: CALL_OW 264
116385: PUSH
116386: LD_INT 81
116388: EQUAL
116389: NOT
116390: IFFALSE 116394
// exit ;
116392: GO 116634
// index := GetElementIndex ( minersList , unit ) ;
116394: LD_ADDR_VAR 0 5
116398: PUSH
116399: LD_EXP 195
116403: PPUSH
116404: LD_VAR 0 1
116408: PPUSH
116409: CALL 58559 0 2
116413: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
116414: LD_EXP 196
116418: PUSH
116419: LD_VAR 0 5
116423: ARRAY
116424: PUSH
116425: LD_EXP 197
116429: GREATEREQUAL
116430: IFFALSE 116434
// exit ;
116432: GO 116634
// ComMoveXY ( unit , x , y ) ;
116434: LD_VAR 0 1
116438: PPUSH
116439: LD_VAR 0 2
116443: PPUSH
116444: LD_VAR 0 3
116448: PPUSH
116449: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
116453: LD_INT 35
116455: PPUSH
116456: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
116460: LD_VAR 0 1
116464: PPUSH
116465: LD_VAR 0 2
116469: PPUSH
116470: LD_VAR 0 3
116474: PPUSH
116475: CALL 90320 0 3
116479: NOT
116480: PUSH
116481: LD_VAR 0 1
116485: PPUSH
116486: CALL_OW 314
116490: AND
116491: IFFALSE 116495
// exit ;
116493: GO 116634
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
116495: LD_VAR 0 2
116499: PPUSH
116500: LD_VAR 0 3
116504: PPUSH
116505: CALL_OW 428
116509: PUSH
116510: LD_VAR 0 1
116514: EQUAL
116515: PUSH
116516: LD_VAR 0 1
116520: PPUSH
116521: CALL_OW 314
116525: NOT
116526: AND
116527: IFFALSE 116453
// PlaySoundXY ( x , y , PlantMine ) ;
116529: LD_VAR 0 2
116533: PPUSH
116534: LD_VAR 0 3
116538: PPUSH
116539: LD_STRING PlantMine
116541: PPUSH
116542: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
116546: LD_VAR 0 2
116550: PPUSH
116551: LD_VAR 0 3
116555: PPUSH
116556: LD_VAR 0 1
116560: PPUSH
116561: CALL_OW 255
116565: PPUSH
116566: LD_INT 0
116568: PPUSH
116569: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
116573: LD_ADDR_EXP 196
116577: PUSH
116578: LD_EXP 196
116582: PPUSH
116583: LD_VAR 0 5
116587: PUSH
116588: LD_EXP 196
116592: PUSH
116593: LD_VAR 0 5
116597: ARRAY
116598: PUSH
116599: LD_INT 1
116601: PLUS
116602: PUSH
116603: EMPTY
116604: LIST
116605: LIST
116606: PPUSH
116607: LD_VAR 0 2
116611: PUSH
116612: LD_VAR 0 3
116616: PUSH
116617: EMPTY
116618: LIST
116619: LIST
116620: PPUSH
116621: CALL 58774 0 3
116625: ST_TO_ADDR
// result := true ;
116626: LD_ADDR_VAR 0 4
116630: PUSH
116631: LD_INT 1
116633: ST_TO_ADDR
// end ;
116634: LD_VAR 0 4
116638: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
116639: LD_INT 0
116641: PPUSH
116642: PPUSH
116643: PPUSH
// if not unit in minersList then
116644: LD_VAR 0 1
116648: PUSH
116649: LD_EXP 195
116653: IN
116654: NOT
116655: IFFALSE 116659
// exit ;
116657: GO 117051
// index := GetElementIndex ( minersList , unit ) ;
116659: LD_ADDR_VAR 0 6
116663: PUSH
116664: LD_EXP 195
116668: PPUSH
116669: LD_VAR 0 1
116673: PPUSH
116674: CALL 58559 0 2
116678: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
116679: LD_ADDR_VAR 0 5
116683: PUSH
116684: DOUBLE
116685: LD_EXP 196
116689: PUSH
116690: LD_VAR 0 6
116694: ARRAY
116695: INC
116696: ST_TO_ADDR
116697: LD_INT 1
116699: PUSH
116700: FOR_DOWNTO
116701: IFFALSE 116862
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
116703: LD_EXP 196
116707: PUSH
116708: LD_VAR 0 6
116712: ARRAY
116713: PUSH
116714: LD_VAR 0 5
116718: ARRAY
116719: PUSH
116720: LD_INT 1
116722: ARRAY
116723: PUSH
116724: LD_VAR 0 2
116728: EQUAL
116729: PUSH
116730: LD_EXP 196
116734: PUSH
116735: LD_VAR 0 6
116739: ARRAY
116740: PUSH
116741: LD_VAR 0 5
116745: ARRAY
116746: PUSH
116747: LD_INT 2
116749: ARRAY
116750: PUSH
116751: LD_VAR 0 3
116755: EQUAL
116756: AND
116757: IFFALSE 116860
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
116759: LD_EXP 196
116763: PUSH
116764: LD_VAR 0 6
116768: ARRAY
116769: PUSH
116770: LD_VAR 0 5
116774: ARRAY
116775: PUSH
116776: LD_INT 1
116778: ARRAY
116779: PPUSH
116780: LD_EXP 196
116784: PUSH
116785: LD_VAR 0 6
116789: ARRAY
116790: PUSH
116791: LD_VAR 0 5
116795: ARRAY
116796: PUSH
116797: LD_INT 2
116799: ARRAY
116800: PPUSH
116801: LD_VAR 0 1
116805: PPUSH
116806: CALL_OW 255
116810: PPUSH
116811: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
116815: LD_ADDR_EXP 196
116819: PUSH
116820: LD_EXP 196
116824: PPUSH
116825: LD_VAR 0 6
116829: PPUSH
116830: LD_EXP 196
116834: PUSH
116835: LD_VAR 0 6
116839: ARRAY
116840: PPUSH
116841: LD_VAR 0 5
116845: PPUSH
116846: CALL_OW 3
116850: PPUSH
116851: CALL_OW 1
116855: ST_TO_ADDR
// exit ;
116856: POP
116857: POP
116858: GO 117051
// end ; end ;
116860: GO 116700
116862: POP
116863: POP
// for i := minerMinesList [ index ] downto 1 do
116864: LD_ADDR_VAR 0 5
116868: PUSH
116869: DOUBLE
116870: LD_EXP 196
116874: PUSH
116875: LD_VAR 0 6
116879: ARRAY
116880: INC
116881: ST_TO_ADDR
116882: LD_INT 1
116884: PUSH
116885: FOR_DOWNTO
116886: IFFALSE 117049
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
116888: LD_EXP 196
116892: PUSH
116893: LD_VAR 0 6
116897: ARRAY
116898: PUSH
116899: LD_VAR 0 5
116903: ARRAY
116904: PUSH
116905: LD_INT 1
116907: ARRAY
116908: PPUSH
116909: LD_EXP 196
116913: PUSH
116914: LD_VAR 0 6
116918: ARRAY
116919: PUSH
116920: LD_VAR 0 5
116924: ARRAY
116925: PUSH
116926: LD_INT 2
116928: ARRAY
116929: PPUSH
116930: LD_VAR 0 2
116934: PPUSH
116935: LD_VAR 0 3
116939: PPUSH
116940: CALL_OW 298
116944: PUSH
116945: LD_INT 6
116947: LESS
116948: IFFALSE 117047
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
116950: LD_EXP 196
116954: PUSH
116955: LD_VAR 0 6
116959: ARRAY
116960: PUSH
116961: LD_VAR 0 5
116965: ARRAY
116966: PUSH
116967: LD_INT 1
116969: ARRAY
116970: PPUSH
116971: LD_EXP 196
116975: PUSH
116976: LD_VAR 0 6
116980: ARRAY
116981: PUSH
116982: LD_VAR 0 5
116986: ARRAY
116987: PUSH
116988: LD_INT 2
116990: ARRAY
116991: PPUSH
116992: LD_VAR 0 1
116996: PPUSH
116997: CALL_OW 255
117001: PPUSH
117002: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
117006: LD_ADDR_EXP 196
117010: PUSH
117011: LD_EXP 196
117015: PPUSH
117016: LD_VAR 0 6
117020: PPUSH
117021: LD_EXP 196
117025: PUSH
117026: LD_VAR 0 6
117030: ARRAY
117031: PPUSH
117032: LD_VAR 0 5
117036: PPUSH
117037: CALL_OW 3
117041: PPUSH
117042: CALL_OW 1
117046: ST_TO_ADDR
// end ; end ;
117047: GO 116885
117049: POP
117050: POP
// end ;
117051: LD_VAR 0 4
117055: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
117056: LD_INT 0
117058: PPUSH
117059: PPUSH
117060: PPUSH
117061: PPUSH
117062: PPUSH
117063: PPUSH
117064: PPUSH
117065: PPUSH
117066: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
117067: LD_VAR 0 1
117071: PPUSH
117072: CALL_OW 264
117076: PUSH
117077: LD_INT 81
117079: EQUAL
117080: NOT
117081: PUSH
117082: LD_VAR 0 1
117086: PUSH
117087: LD_EXP 195
117091: IN
117092: NOT
117093: OR
117094: IFFALSE 117098
// exit ;
117096: GO 117420
// index := GetElementIndex ( minersList , unit ) ;
117098: LD_ADDR_VAR 0 6
117102: PUSH
117103: LD_EXP 195
117107: PPUSH
117108: LD_VAR 0 1
117112: PPUSH
117113: CALL 58559 0 2
117117: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
117118: LD_ADDR_VAR 0 8
117122: PUSH
117123: LD_EXP 197
117127: PUSH
117128: LD_EXP 196
117132: PUSH
117133: LD_VAR 0 6
117137: ARRAY
117138: MINUS
117139: ST_TO_ADDR
// if not minesFreeAmount then
117140: LD_VAR 0 8
117144: NOT
117145: IFFALSE 117149
// exit ;
117147: GO 117420
// tmp := [ ] ;
117149: LD_ADDR_VAR 0 7
117153: PUSH
117154: EMPTY
117155: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
117156: LD_ADDR_VAR 0 5
117160: PUSH
117161: DOUBLE
117162: LD_INT 1
117164: DEC
117165: ST_TO_ADDR
117166: LD_VAR 0 8
117170: PUSH
117171: FOR_TO
117172: IFFALSE 117367
// begin _d := rand ( 0 , 5 ) ;
117174: LD_ADDR_VAR 0 11
117178: PUSH
117179: LD_INT 0
117181: PPUSH
117182: LD_INT 5
117184: PPUSH
117185: CALL_OW 12
117189: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
117190: LD_ADDR_VAR 0 12
117194: PUSH
117195: LD_INT 2
117197: PPUSH
117198: LD_INT 6
117200: PPUSH
117201: CALL_OW 12
117205: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
117206: LD_ADDR_VAR 0 9
117210: PUSH
117211: LD_VAR 0 2
117215: PPUSH
117216: LD_VAR 0 11
117220: PPUSH
117221: LD_VAR 0 12
117225: PPUSH
117226: CALL_OW 272
117230: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
117231: LD_ADDR_VAR 0 10
117235: PUSH
117236: LD_VAR 0 3
117240: PPUSH
117241: LD_VAR 0 11
117245: PPUSH
117246: LD_VAR 0 12
117250: PPUSH
117251: CALL_OW 273
117255: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
117256: LD_VAR 0 9
117260: PPUSH
117261: LD_VAR 0 10
117265: PPUSH
117266: CALL_OW 488
117270: PUSH
117271: LD_VAR 0 9
117275: PUSH
117276: LD_VAR 0 10
117280: PUSH
117281: EMPTY
117282: LIST
117283: LIST
117284: PUSH
117285: LD_VAR 0 7
117289: IN
117290: NOT
117291: AND
117292: PUSH
117293: LD_VAR 0 9
117297: PPUSH
117298: LD_VAR 0 10
117302: PPUSH
117303: CALL_OW 458
117307: NOT
117308: AND
117309: IFFALSE 117351
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
117311: LD_ADDR_VAR 0 7
117315: PUSH
117316: LD_VAR 0 7
117320: PPUSH
117321: LD_VAR 0 7
117325: PUSH
117326: LD_INT 1
117328: PLUS
117329: PPUSH
117330: LD_VAR 0 9
117334: PUSH
117335: LD_VAR 0 10
117339: PUSH
117340: EMPTY
117341: LIST
117342: LIST
117343: PPUSH
117344: CALL_OW 1
117348: ST_TO_ADDR
117349: GO 117365
// i := i - 1 ;
117351: LD_ADDR_VAR 0 5
117355: PUSH
117356: LD_VAR 0 5
117360: PUSH
117361: LD_INT 1
117363: MINUS
117364: ST_TO_ADDR
// end ;
117365: GO 117171
117367: POP
117368: POP
// for i in tmp do
117369: LD_ADDR_VAR 0 5
117373: PUSH
117374: LD_VAR 0 7
117378: PUSH
117379: FOR_IN
117380: IFFALSE 117418
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
117382: LD_VAR 0 1
117386: PPUSH
117387: LD_VAR 0 5
117391: PUSH
117392: LD_INT 1
117394: ARRAY
117395: PPUSH
117396: LD_VAR 0 5
117400: PUSH
117401: LD_INT 2
117403: ARRAY
117404: PPUSH
117405: CALL 116364 0 3
117409: NOT
117410: IFFALSE 117416
// exit ;
117412: POP
117413: POP
117414: GO 117420
117416: GO 117379
117418: POP
117419: POP
// end ;
117420: LD_VAR 0 4
117424: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
117425: LD_INT 0
117427: PPUSH
117428: PPUSH
117429: PPUSH
117430: PPUSH
117431: PPUSH
117432: PPUSH
117433: PPUSH
117434: PPUSH
117435: PPUSH
// if GetClass ( unit ) <> class_sniper then
117436: LD_VAR 0 1
117440: PPUSH
117441: CALL_OW 257
117445: PUSH
117446: LD_INT 5
117448: NONEQUAL
117449: IFFALSE 117453
// exit ;
117451: GO 117919
// dist := 8 ;
117453: LD_ADDR_VAR 0 5
117457: PUSH
117458: LD_INT 8
117460: ST_TO_ADDR
// viewRange := 12 ;
117461: LD_ADDR_VAR 0 8
117465: PUSH
117466: LD_INT 12
117468: ST_TO_ADDR
// side := GetSide ( unit ) ;
117469: LD_ADDR_VAR 0 6
117473: PUSH
117474: LD_VAR 0 1
117478: PPUSH
117479: CALL_OW 255
117483: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
117484: LD_INT 61
117486: PPUSH
117487: LD_VAR 0 6
117491: PPUSH
117492: CALL_OW 321
117496: PUSH
117497: LD_INT 2
117499: EQUAL
117500: IFFALSE 117510
// viewRange := 16 ;
117502: LD_ADDR_VAR 0 8
117506: PUSH
117507: LD_INT 16
117509: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
117510: LD_VAR 0 1
117514: PPUSH
117515: LD_VAR 0 2
117519: PPUSH
117520: LD_VAR 0 3
117524: PPUSH
117525: CALL_OW 297
117529: PUSH
117530: LD_VAR 0 5
117534: GREATER
117535: IFFALSE 117614
// begin ComMoveXY ( unit , x , y ) ;
117537: LD_VAR 0 1
117541: PPUSH
117542: LD_VAR 0 2
117546: PPUSH
117547: LD_VAR 0 3
117551: PPUSH
117552: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
117556: LD_INT 35
117558: PPUSH
117559: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
117563: LD_VAR 0 1
117567: PPUSH
117568: LD_VAR 0 2
117572: PPUSH
117573: LD_VAR 0 3
117577: PPUSH
117578: CALL 90320 0 3
117582: NOT
117583: IFFALSE 117587
// exit ;
117585: GO 117919
// until GetDistUnitXY ( unit , x , y ) < dist ;
117587: LD_VAR 0 1
117591: PPUSH
117592: LD_VAR 0 2
117596: PPUSH
117597: LD_VAR 0 3
117601: PPUSH
117602: CALL_OW 297
117606: PUSH
117607: LD_VAR 0 5
117611: LESS
117612: IFFALSE 117556
// end ; ComTurnXY ( unit , x , y ) ;
117614: LD_VAR 0 1
117618: PPUSH
117619: LD_VAR 0 2
117623: PPUSH
117624: LD_VAR 0 3
117628: PPUSH
117629: CALL_OW 118
// repeat if Multiplayer then
117633: LD_OWVAR 4
117637: IFFALSE 117648
// wait ( 35 ) else
117639: LD_INT 35
117641: PPUSH
117642: CALL_OW 67
117646: GO 117655
// wait ( 5 ) ;
117648: LD_INT 5
117650: PPUSH
117651: CALL_OW 67
// _d := GetDir ( unit ) ;
117655: LD_ADDR_VAR 0 11
117659: PUSH
117660: LD_VAR 0 1
117664: PPUSH
117665: CALL_OW 254
117669: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
117670: LD_ADDR_VAR 0 7
117674: PUSH
117675: LD_VAR 0 1
117679: PPUSH
117680: CALL_OW 250
117684: PPUSH
117685: LD_VAR 0 1
117689: PPUSH
117690: CALL_OW 251
117694: PPUSH
117695: LD_VAR 0 2
117699: PPUSH
117700: LD_VAR 0 3
117704: PPUSH
117705: CALL 92928 0 4
117709: ST_TO_ADDR
// until dir = _d ;
117710: LD_VAR 0 7
117714: PUSH
117715: LD_VAR 0 11
117719: EQUAL
117720: IFFALSE 117633
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
117722: LD_ADDR_VAR 0 9
117726: PUSH
117727: LD_VAR 0 1
117731: PPUSH
117732: CALL_OW 250
117736: PPUSH
117737: LD_VAR 0 7
117741: PPUSH
117742: LD_VAR 0 5
117746: PPUSH
117747: CALL_OW 272
117751: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
117752: LD_ADDR_VAR 0 10
117756: PUSH
117757: LD_VAR 0 1
117761: PPUSH
117762: CALL_OW 251
117766: PPUSH
117767: LD_VAR 0 7
117771: PPUSH
117772: LD_VAR 0 5
117776: PPUSH
117777: CALL_OW 273
117781: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
117782: LD_VAR 0 9
117786: PPUSH
117787: LD_VAR 0 10
117791: PPUSH
117792: CALL_OW 488
117796: NOT
117797: IFFALSE 117801
// exit ;
117799: GO 117919
// ComAnimCustom ( unit , 1 ) ;
117801: LD_VAR 0 1
117805: PPUSH
117806: LD_INT 1
117808: PPUSH
117809: CALL_OW 592
// p := 0 ;
117813: LD_ADDR_VAR 0 12
117817: PUSH
117818: LD_INT 0
117820: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
117821: LD_VAR 0 9
117825: PPUSH
117826: LD_VAR 0 10
117830: PPUSH
117831: LD_VAR 0 6
117835: PPUSH
117836: LD_VAR 0 8
117840: PPUSH
117841: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
117845: LD_INT 35
117847: PPUSH
117848: CALL_OW 67
// p := Inc ( p ) ;
117852: LD_ADDR_VAR 0 12
117856: PUSH
117857: LD_VAR 0 12
117861: PPUSH
117862: CALL 92884 0 1
117866: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
117867: LD_VAR 0 12
117871: PUSH
117872: LD_INT 3
117874: EQUAL
117875: PUSH
117876: LD_VAR 0 1
117880: PPUSH
117881: CALL_OW 302
117885: NOT
117886: OR
117887: PUSH
117888: LD_VAR 0 1
117892: PPUSH
117893: CALL_OW 301
117897: OR
117898: IFFALSE 117845
// RemoveSeeing ( _x , _y , side ) ;
117900: LD_VAR 0 9
117904: PPUSH
117905: LD_VAR 0 10
117909: PPUSH
117910: LD_VAR 0 6
117914: PPUSH
117915: CALL_OW 331
// end ; end_of_file
117919: LD_VAR 0 4
117923: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
117924: LD_INT 0
117926: PPUSH
117927: PPUSH
117928: PPUSH
117929: PPUSH
117930: PPUSH
117931: PPUSH
117932: PPUSH
117933: PPUSH
117934: PPUSH
117935: PPUSH
117936: PPUSH
117937: PPUSH
117938: PPUSH
117939: PPUSH
117940: PPUSH
117941: PPUSH
117942: PPUSH
117943: PPUSH
117944: PPUSH
117945: PPUSH
117946: PPUSH
117947: PPUSH
117948: PPUSH
117949: PPUSH
117950: PPUSH
117951: PPUSH
117952: PPUSH
117953: PPUSH
117954: PPUSH
117955: PPUSH
117956: PPUSH
117957: PPUSH
117958: PPUSH
117959: PPUSH
// if not list then
117960: LD_VAR 0 1
117964: NOT
117965: IFFALSE 117969
// exit ;
117967: GO 122628
// base := list [ 1 ] ;
117969: LD_ADDR_VAR 0 3
117973: PUSH
117974: LD_VAR 0 1
117978: PUSH
117979: LD_INT 1
117981: ARRAY
117982: ST_TO_ADDR
// group := list [ 2 ] ;
117983: LD_ADDR_VAR 0 4
117987: PUSH
117988: LD_VAR 0 1
117992: PUSH
117993: LD_INT 2
117995: ARRAY
117996: ST_TO_ADDR
// path := list [ 3 ] ;
117997: LD_ADDR_VAR 0 5
118001: PUSH
118002: LD_VAR 0 1
118006: PUSH
118007: LD_INT 3
118009: ARRAY
118010: ST_TO_ADDR
// flags := list [ 4 ] ;
118011: LD_ADDR_VAR 0 6
118015: PUSH
118016: LD_VAR 0 1
118020: PUSH
118021: LD_INT 4
118023: ARRAY
118024: ST_TO_ADDR
// mined := [ ] ;
118025: LD_ADDR_VAR 0 27
118029: PUSH
118030: EMPTY
118031: ST_TO_ADDR
// bombed := [ ] ;
118032: LD_ADDR_VAR 0 28
118036: PUSH
118037: EMPTY
118038: ST_TO_ADDR
// healers := [ ] ;
118039: LD_ADDR_VAR 0 31
118043: PUSH
118044: EMPTY
118045: ST_TO_ADDR
// to_heal := [ ] ;
118046: LD_ADDR_VAR 0 30
118050: PUSH
118051: EMPTY
118052: ST_TO_ADDR
// repairs := [ ] ;
118053: LD_ADDR_VAR 0 33
118057: PUSH
118058: EMPTY
118059: ST_TO_ADDR
// to_repair := [ ] ;
118060: LD_ADDR_VAR 0 32
118064: PUSH
118065: EMPTY
118066: ST_TO_ADDR
// if not group or not path then
118067: LD_VAR 0 4
118071: NOT
118072: PUSH
118073: LD_VAR 0 5
118077: NOT
118078: OR
118079: IFFALSE 118083
// exit ;
118081: GO 122628
// side := GetSide ( group [ 1 ] ) ;
118083: LD_ADDR_VAR 0 35
118087: PUSH
118088: LD_VAR 0 4
118092: PUSH
118093: LD_INT 1
118095: ARRAY
118096: PPUSH
118097: CALL_OW 255
118101: ST_TO_ADDR
// if flags then
118102: LD_VAR 0 6
118106: IFFALSE 118250
// begin f_ignore_area := flags [ 1 ] ;
118108: LD_ADDR_VAR 0 17
118112: PUSH
118113: LD_VAR 0 6
118117: PUSH
118118: LD_INT 1
118120: ARRAY
118121: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
118122: LD_ADDR_VAR 0 18
118126: PUSH
118127: LD_VAR 0 6
118131: PUSH
118132: LD_INT 2
118134: ARRAY
118135: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
118136: LD_ADDR_VAR 0 19
118140: PUSH
118141: LD_VAR 0 6
118145: PUSH
118146: LD_INT 3
118148: ARRAY
118149: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
118150: LD_ADDR_VAR 0 20
118154: PUSH
118155: LD_VAR 0 6
118159: PUSH
118160: LD_INT 4
118162: ARRAY
118163: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
118164: LD_ADDR_VAR 0 21
118168: PUSH
118169: LD_VAR 0 6
118173: PUSH
118174: LD_INT 5
118176: ARRAY
118177: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
118178: LD_ADDR_VAR 0 22
118182: PUSH
118183: LD_VAR 0 6
118187: PUSH
118188: LD_INT 6
118190: ARRAY
118191: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
118192: LD_ADDR_VAR 0 23
118196: PUSH
118197: LD_VAR 0 6
118201: PUSH
118202: LD_INT 7
118204: ARRAY
118205: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
118206: LD_ADDR_VAR 0 24
118210: PUSH
118211: LD_VAR 0 6
118215: PUSH
118216: LD_INT 8
118218: ARRAY
118219: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
118220: LD_ADDR_VAR 0 25
118224: PUSH
118225: LD_VAR 0 6
118229: PUSH
118230: LD_INT 9
118232: ARRAY
118233: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
118234: LD_ADDR_VAR 0 26
118238: PUSH
118239: LD_VAR 0 6
118243: PUSH
118244: LD_INT 10
118246: ARRAY
118247: ST_TO_ADDR
// end else
118248: GO 118330
// begin f_ignore_area := false ;
118250: LD_ADDR_VAR 0 17
118254: PUSH
118255: LD_INT 0
118257: ST_TO_ADDR
// f_capture := false ;
118258: LD_ADDR_VAR 0 18
118262: PUSH
118263: LD_INT 0
118265: ST_TO_ADDR
// f_ignore_civ := false ;
118266: LD_ADDR_VAR 0 19
118270: PUSH
118271: LD_INT 0
118273: ST_TO_ADDR
// f_murder := false ;
118274: LD_ADDR_VAR 0 20
118278: PUSH
118279: LD_INT 0
118281: ST_TO_ADDR
// f_mines := false ;
118282: LD_ADDR_VAR 0 21
118286: PUSH
118287: LD_INT 0
118289: ST_TO_ADDR
// f_repair := false ;
118290: LD_ADDR_VAR 0 22
118294: PUSH
118295: LD_INT 0
118297: ST_TO_ADDR
// f_heal := false ;
118298: LD_ADDR_VAR 0 23
118302: PUSH
118303: LD_INT 0
118305: ST_TO_ADDR
// f_spacetime := false ;
118306: LD_ADDR_VAR 0 24
118310: PUSH
118311: LD_INT 0
118313: ST_TO_ADDR
// f_attack_depot := false ;
118314: LD_ADDR_VAR 0 25
118318: PUSH
118319: LD_INT 0
118321: ST_TO_ADDR
// f_crawl := false ;
118322: LD_ADDR_VAR 0 26
118326: PUSH
118327: LD_INT 0
118329: ST_TO_ADDR
// end ; if f_heal then
118330: LD_VAR 0 23
118334: IFFALSE 118361
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
118336: LD_ADDR_VAR 0 31
118340: PUSH
118341: LD_VAR 0 4
118345: PPUSH
118346: LD_INT 25
118348: PUSH
118349: LD_INT 4
118351: PUSH
118352: EMPTY
118353: LIST
118354: LIST
118355: PPUSH
118356: CALL_OW 72
118360: ST_TO_ADDR
// if f_repair then
118361: LD_VAR 0 22
118365: IFFALSE 118392
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
118367: LD_ADDR_VAR 0 33
118371: PUSH
118372: LD_VAR 0 4
118376: PPUSH
118377: LD_INT 25
118379: PUSH
118380: LD_INT 3
118382: PUSH
118383: EMPTY
118384: LIST
118385: LIST
118386: PPUSH
118387: CALL_OW 72
118391: ST_TO_ADDR
// units_path := [ ] ;
118392: LD_ADDR_VAR 0 16
118396: PUSH
118397: EMPTY
118398: ST_TO_ADDR
// for i = 1 to group do
118399: LD_ADDR_VAR 0 7
118403: PUSH
118404: DOUBLE
118405: LD_INT 1
118407: DEC
118408: ST_TO_ADDR
118409: LD_VAR 0 4
118413: PUSH
118414: FOR_TO
118415: IFFALSE 118444
// units_path := Replace ( units_path , i , path ) ;
118417: LD_ADDR_VAR 0 16
118421: PUSH
118422: LD_VAR 0 16
118426: PPUSH
118427: LD_VAR 0 7
118431: PPUSH
118432: LD_VAR 0 5
118436: PPUSH
118437: CALL_OW 1
118441: ST_TO_ADDR
118442: GO 118414
118444: POP
118445: POP
// repeat for i = group downto 1 do
118446: LD_ADDR_VAR 0 7
118450: PUSH
118451: DOUBLE
118452: LD_VAR 0 4
118456: INC
118457: ST_TO_ADDR
118458: LD_INT 1
118460: PUSH
118461: FOR_DOWNTO
118462: IFFALSE 122584
// begin wait ( 5 ) ;
118464: LD_INT 5
118466: PPUSH
118467: CALL_OW 67
// tmp := [ ] ;
118471: LD_ADDR_VAR 0 14
118475: PUSH
118476: EMPTY
118477: ST_TO_ADDR
// attacking := false ;
118478: LD_ADDR_VAR 0 29
118482: PUSH
118483: LD_INT 0
118485: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
118486: LD_VAR 0 4
118490: PUSH
118491: LD_VAR 0 7
118495: ARRAY
118496: PPUSH
118497: CALL_OW 301
118501: PUSH
118502: LD_VAR 0 4
118506: PUSH
118507: LD_VAR 0 7
118511: ARRAY
118512: NOT
118513: OR
118514: IFFALSE 118623
// begin if GetType ( group [ i ] ) = unit_human then
118516: LD_VAR 0 4
118520: PUSH
118521: LD_VAR 0 7
118525: ARRAY
118526: PPUSH
118527: CALL_OW 247
118531: PUSH
118532: LD_INT 1
118534: EQUAL
118535: IFFALSE 118581
// begin to_heal := to_heal diff group [ i ] ;
118537: LD_ADDR_VAR 0 30
118541: PUSH
118542: LD_VAR 0 30
118546: PUSH
118547: LD_VAR 0 4
118551: PUSH
118552: LD_VAR 0 7
118556: ARRAY
118557: DIFF
118558: ST_TO_ADDR
// healers := healers diff group [ i ] ;
118559: LD_ADDR_VAR 0 31
118563: PUSH
118564: LD_VAR 0 31
118568: PUSH
118569: LD_VAR 0 4
118573: PUSH
118574: LD_VAR 0 7
118578: ARRAY
118579: DIFF
118580: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
118581: LD_ADDR_VAR 0 4
118585: PUSH
118586: LD_VAR 0 4
118590: PPUSH
118591: LD_VAR 0 7
118595: PPUSH
118596: CALL_OW 3
118600: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
118601: LD_ADDR_VAR 0 16
118605: PUSH
118606: LD_VAR 0 16
118610: PPUSH
118611: LD_VAR 0 7
118615: PPUSH
118616: CALL_OW 3
118620: ST_TO_ADDR
// continue ;
118621: GO 118461
// end ; if f_repair then
118623: LD_VAR 0 22
118627: IFFALSE 119116
// begin if GetType ( group [ i ] ) = unit_vehicle then
118629: LD_VAR 0 4
118633: PUSH
118634: LD_VAR 0 7
118638: ARRAY
118639: PPUSH
118640: CALL_OW 247
118644: PUSH
118645: LD_INT 2
118647: EQUAL
118648: IFFALSE 118838
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
118650: LD_VAR 0 4
118654: PUSH
118655: LD_VAR 0 7
118659: ARRAY
118660: PPUSH
118661: CALL_OW 256
118665: PUSH
118666: LD_INT 700
118668: LESS
118669: PUSH
118670: LD_VAR 0 4
118674: PUSH
118675: LD_VAR 0 7
118679: ARRAY
118680: PUSH
118681: LD_VAR 0 32
118685: IN
118686: NOT
118687: AND
118688: IFFALSE 118712
// to_repair := to_repair union group [ i ] ;
118690: LD_ADDR_VAR 0 32
118694: PUSH
118695: LD_VAR 0 32
118699: PUSH
118700: LD_VAR 0 4
118704: PUSH
118705: LD_VAR 0 7
118709: ARRAY
118710: UNION
118711: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
118712: LD_VAR 0 4
118716: PUSH
118717: LD_VAR 0 7
118721: ARRAY
118722: PPUSH
118723: CALL_OW 256
118727: PUSH
118728: LD_INT 1000
118730: EQUAL
118731: PUSH
118732: LD_VAR 0 4
118736: PUSH
118737: LD_VAR 0 7
118741: ARRAY
118742: PUSH
118743: LD_VAR 0 32
118747: IN
118748: AND
118749: IFFALSE 118773
// to_repair := to_repair diff group [ i ] ;
118751: LD_ADDR_VAR 0 32
118755: PUSH
118756: LD_VAR 0 32
118760: PUSH
118761: LD_VAR 0 4
118765: PUSH
118766: LD_VAR 0 7
118770: ARRAY
118771: DIFF
118772: ST_TO_ADDR
// if group [ i ] in to_repair then
118773: LD_VAR 0 4
118777: PUSH
118778: LD_VAR 0 7
118782: ARRAY
118783: PUSH
118784: LD_VAR 0 32
118788: IN
118789: IFFALSE 118836
// begin if not IsInArea ( group [ i ] , f_repair ) then
118791: LD_VAR 0 4
118795: PUSH
118796: LD_VAR 0 7
118800: ARRAY
118801: PPUSH
118802: LD_VAR 0 22
118806: PPUSH
118807: CALL_OW 308
118811: NOT
118812: IFFALSE 118834
// ComMoveToArea ( group [ i ] , f_repair ) ;
118814: LD_VAR 0 4
118818: PUSH
118819: LD_VAR 0 7
118823: ARRAY
118824: PPUSH
118825: LD_VAR 0 22
118829: PPUSH
118830: CALL_OW 113
// continue ;
118834: GO 118461
// end ; end else
118836: GO 119116
// if group [ i ] in repairs then
118838: LD_VAR 0 4
118842: PUSH
118843: LD_VAR 0 7
118847: ARRAY
118848: PUSH
118849: LD_VAR 0 33
118853: IN
118854: IFFALSE 119116
// begin if IsInUnit ( group [ i ] ) then
118856: LD_VAR 0 4
118860: PUSH
118861: LD_VAR 0 7
118865: ARRAY
118866: PPUSH
118867: CALL_OW 310
118871: IFFALSE 118939
// begin z := IsInUnit ( group [ i ] ) ;
118873: LD_ADDR_VAR 0 13
118877: PUSH
118878: LD_VAR 0 4
118882: PUSH
118883: LD_VAR 0 7
118887: ARRAY
118888: PPUSH
118889: CALL_OW 310
118893: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
118894: LD_VAR 0 13
118898: PUSH
118899: LD_VAR 0 32
118903: IN
118904: PUSH
118905: LD_VAR 0 13
118909: PPUSH
118910: LD_VAR 0 22
118914: PPUSH
118915: CALL_OW 308
118919: AND
118920: IFFALSE 118937
// ComExitVehicle ( group [ i ] ) ;
118922: LD_VAR 0 4
118926: PUSH
118927: LD_VAR 0 7
118931: ARRAY
118932: PPUSH
118933: CALL_OW 121
// end else
118937: GO 119116
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
118939: LD_ADDR_VAR 0 13
118943: PUSH
118944: LD_VAR 0 4
118948: PPUSH
118949: LD_INT 95
118951: PUSH
118952: LD_VAR 0 22
118956: PUSH
118957: EMPTY
118958: LIST
118959: LIST
118960: PUSH
118961: LD_INT 58
118963: PUSH
118964: EMPTY
118965: LIST
118966: PUSH
118967: EMPTY
118968: LIST
118969: LIST
118970: PPUSH
118971: CALL_OW 72
118975: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
118976: LD_VAR 0 4
118980: PUSH
118981: LD_VAR 0 7
118985: ARRAY
118986: PPUSH
118987: CALL_OW 314
118991: NOT
118992: IFFALSE 119114
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
118994: LD_ADDR_VAR 0 10
118998: PUSH
118999: LD_VAR 0 13
119003: PPUSH
119004: LD_VAR 0 4
119008: PUSH
119009: LD_VAR 0 7
119013: ARRAY
119014: PPUSH
119015: CALL_OW 74
119019: ST_TO_ADDR
// if not x then
119020: LD_VAR 0 10
119024: NOT
119025: IFFALSE 119029
// continue ;
119027: GO 118461
// if GetLives ( x ) < 1000 then
119029: LD_VAR 0 10
119033: PPUSH
119034: CALL_OW 256
119038: PUSH
119039: LD_INT 1000
119041: LESS
119042: IFFALSE 119066
// ComRepairVehicle ( group [ i ] , x ) else
119044: LD_VAR 0 4
119048: PUSH
119049: LD_VAR 0 7
119053: ARRAY
119054: PPUSH
119055: LD_VAR 0 10
119059: PPUSH
119060: CALL_OW 129
119064: GO 119114
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
119066: LD_VAR 0 23
119070: PUSH
119071: LD_VAR 0 4
119075: PUSH
119076: LD_VAR 0 7
119080: ARRAY
119081: PPUSH
119082: CALL_OW 256
119086: PUSH
119087: LD_INT 1000
119089: LESS
119090: AND
119091: NOT
119092: IFFALSE 119114
// ComEnterUnit ( group [ i ] , x ) ;
119094: LD_VAR 0 4
119098: PUSH
119099: LD_VAR 0 7
119103: ARRAY
119104: PPUSH
119105: LD_VAR 0 10
119109: PPUSH
119110: CALL_OW 120
// end ; continue ;
119114: GO 118461
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
119116: LD_VAR 0 23
119120: PUSH
119121: LD_VAR 0 4
119125: PUSH
119126: LD_VAR 0 7
119130: ARRAY
119131: PPUSH
119132: CALL_OW 247
119136: PUSH
119137: LD_INT 1
119139: EQUAL
119140: AND
119141: IFFALSE 119619
// begin if group [ i ] in healers then
119143: LD_VAR 0 4
119147: PUSH
119148: LD_VAR 0 7
119152: ARRAY
119153: PUSH
119154: LD_VAR 0 31
119158: IN
119159: IFFALSE 119432
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
119161: LD_VAR 0 4
119165: PUSH
119166: LD_VAR 0 7
119170: ARRAY
119171: PPUSH
119172: LD_VAR 0 23
119176: PPUSH
119177: CALL_OW 308
119181: NOT
119182: PUSH
119183: LD_VAR 0 4
119187: PUSH
119188: LD_VAR 0 7
119192: ARRAY
119193: PPUSH
119194: CALL_OW 314
119198: NOT
119199: AND
119200: IFFALSE 119224
// ComMoveToArea ( group [ i ] , f_heal ) else
119202: LD_VAR 0 4
119206: PUSH
119207: LD_VAR 0 7
119211: ARRAY
119212: PPUSH
119213: LD_VAR 0 23
119217: PPUSH
119218: CALL_OW 113
119222: GO 119430
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
119224: LD_VAR 0 4
119228: PUSH
119229: LD_VAR 0 7
119233: ARRAY
119234: PPUSH
119235: CALL 88903 0 1
119239: PPUSH
119240: CALL_OW 256
119244: PUSH
119245: LD_INT 1000
119247: EQUAL
119248: IFFALSE 119267
// ComStop ( group [ i ] ) else
119250: LD_VAR 0 4
119254: PUSH
119255: LD_VAR 0 7
119259: ARRAY
119260: PPUSH
119261: CALL_OW 141
119265: GO 119430
// if not HasTask ( group [ i ] ) and to_heal then
119267: LD_VAR 0 4
119271: PUSH
119272: LD_VAR 0 7
119276: ARRAY
119277: PPUSH
119278: CALL_OW 314
119282: NOT
119283: PUSH
119284: LD_VAR 0 30
119288: AND
119289: IFFALSE 119430
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
119291: LD_ADDR_VAR 0 13
119295: PUSH
119296: LD_VAR 0 30
119300: PPUSH
119301: LD_INT 3
119303: PUSH
119304: LD_INT 54
119306: PUSH
119307: EMPTY
119308: LIST
119309: PUSH
119310: EMPTY
119311: LIST
119312: LIST
119313: PPUSH
119314: CALL_OW 72
119318: PPUSH
119319: LD_VAR 0 4
119323: PUSH
119324: LD_VAR 0 7
119328: ARRAY
119329: PPUSH
119330: CALL_OW 74
119334: ST_TO_ADDR
// if z then
119335: LD_VAR 0 13
119339: IFFALSE 119430
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
119341: LD_INT 91
119343: PUSH
119344: LD_VAR 0 13
119348: PUSH
119349: LD_INT 10
119351: PUSH
119352: EMPTY
119353: LIST
119354: LIST
119355: LIST
119356: PUSH
119357: LD_INT 81
119359: PUSH
119360: LD_VAR 0 13
119364: PPUSH
119365: CALL_OW 255
119369: PUSH
119370: EMPTY
119371: LIST
119372: LIST
119373: PUSH
119374: EMPTY
119375: LIST
119376: LIST
119377: PPUSH
119378: CALL_OW 69
119382: PUSH
119383: LD_INT 0
119385: EQUAL
119386: IFFALSE 119410
// ComHeal ( group [ i ] , z ) else
119388: LD_VAR 0 4
119392: PUSH
119393: LD_VAR 0 7
119397: ARRAY
119398: PPUSH
119399: LD_VAR 0 13
119403: PPUSH
119404: CALL_OW 128
119408: GO 119430
// ComMoveToArea ( group [ i ] , f_heal ) ;
119410: LD_VAR 0 4
119414: PUSH
119415: LD_VAR 0 7
119419: ARRAY
119420: PPUSH
119421: LD_VAR 0 23
119425: PPUSH
119426: CALL_OW 113
// end ; continue ;
119430: GO 118461
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
119432: LD_VAR 0 4
119436: PUSH
119437: LD_VAR 0 7
119441: ARRAY
119442: PPUSH
119443: CALL_OW 256
119447: PUSH
119448: LD_INT 700
119450: LESS
119451: PUSH
119452: LD_VAR 0 4
119456: PUSH
119457: LD_VAR 0 7
119461: ARRAY
119462: PUSH
119463: LD_VAR 0 30
119467: IN
119468: NOT
119469: AND
119470: IFFALSE 119494
// to_heal := to_heal union group [ i ] ;
119472: LD_ADDR_VAR 0 30
119476: PUSH
119477: LD_VAR 0 30
119481: PUSH
119482: LD_VAR 0 4
119486: PUSH
119487: LD_VAR 0 7
119491: ARRAY
119492: UNION
119493: ST_TO_ADDR
// if group [ i ] in to_heal then
119494: LD_VAR 0 4
119498: PUSH
119499: LD_VAR 0 7
119503: ARRAY
119504: PUSH
119505: LD_VAR 0 30
119509: IN
119510: IFFALSE 119619
// begin if GetLives ( group [ i ] ) = 1000 then
119512: LD_VAR 0 4
119516: PUSH
119517: LD_VAR 0 7
119521: ARRAY
119522: PPUSH
119523: CALL_OW 256
119527: PUSH
119528: LD_INT 1000
119530: EQUAL
119531: IFFALSE 119557
// to_heal := to_heal diff group [ i ] else
119533: LD_ADDR_VAR 0 30
119537: PUSH
119538: LD_VAR 0 30
119542: PUSH
119543: LD_VAR 0 4
119547: PUSH
119548: LD_VAR 0 7
119552: ARRAY
119553: DIFF
119554: ST_TO_ADDR
119555: GO 119619
// begin if not IsInArea ( group [ i ] , to_heal ) then
119557: LD_VAR 0 4
119561: PUSH
119562: LD_VAR 0 7
119566: ARRAY
119567: PPUSH
119568: LD_VAR 0 30
119572: PPUSH
119573: CALL_OW 308
119577: NOT
119578: IFFALSE 119602
// ComMoveToArea ( group [ i ] , f_heal ) else
119580: LD_VAR 0 4
119584: PUSH
119585: LD_VAR 0 7
119589: ARRAY
119590: PPUSH
119591: LD_VAR 0 23
119595: PPUSH
119596: CALL_OW 113
119600: GO 119617
// ComHold ( group [ i ] ) ;
119602: LD_VAR 0 4
119606: PUSH
119607: LD_VAR 0 7
119611: ARRAY
119612: PPUSH
119613: CALL_OW 140
// continue ;
119617: GO 118461
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
119619: LD_VAR 0 4
119623: PUSH
119624: LD_VAR 0 7
119628: ARRAY
119629: PPUSH
119630: LD_INT 10
119632: PPUSH
119633: CALL 86665 0 2
119637: NOT
119638: PUSH
119639: LD_VAR 0 16
119643: PUSH
119644: LD_VAR 0 7
119648: ARRAY
119649: PUSH
119650: EMPTY
119651: EQUAL
119652: NOT
119653: AND
119654: IFFALSE 119920
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
119656: LD_VAR 0 4
119660: PUSH
119661: LD_VAR 0 7
119665: ARRAY
119666: PPUSH
119667: CALL_OW 262
119671: PUSH
119672: LD_INT 1
119674: PUSH
119675: LD_INT 2
119677: PUSH
119678: EMPTY
119679: LIST
119680: LIST
119681: IN
119682: IFFALSE 119723
// if GetFuel ( group [ i ] ) < 10 then
119684: LD_VAR 0 4
119688: PUSH
119689: LD_VAR 0 7
119693: ARRAY
119694: PPUSH
119695: CALL_OW 261
119699: PUSH
119700: LD_INT 10
119702: LESS
119703: IFFALSE 119723
// SetFuel ( group [ i ] , 12 ) ;
119705: LD_VAR 0 4
119709: PUSH
119710: LD_VAR 0 7
119714: ARRAY
119715: PPUSH
119716: LD_INT 12
119718: PPUSH
119719: CALL_OW 240
// if units_path [ i ] then
119723: LD_VAR 0 16
119727: PUSH
119728: LD_VAR 0 7
119732: ARRAY
119733: IFFALSE 119918
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
119735: LD_VAR 0 4
119739: PUSH
119740: LD_VAR 0 7
119744: ARRAY
119745: PPUSH
119746: LD_VAR 0 16
119750: PUSH
119751: LD_VAR 0 7
119755: ARRAY
119756: PUSH
119757: LD_INT 1
119759: ARRAY
119760: PUSH
119761: LD_INT 1
119763: ARRAY
119764: PPUSH
119765: LD_VAR 0 16
119769: PUSH
119770: LD_VAR 0 7
119774: ARRAY
119775: PUSH
119776: LD_INT 1
119778: ARRAY
119779: PUSH
119780: LD_INT 2
119782: ARRAY
119783: PPUSH
119784: CALL_OW 297
119788: PUSH
119789: LD_INT 6
119791: GREATER
119792: IFFALSE 119867
// begin if not HasTask ( group [ i ] ) then
119794: LD_VAR 0 4
119798: PUSH
119799: LD_VAR 0 7
119803: ARRAY
119804: PPUSH
119805: CALL_OW 314
119809: NOT
119810: IFFALSE 119865
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
119812: LD_VAR 0 4
119816: PUSH
119817: LD_VAR 0 7
119821: ARRAY
119822: PPUSH
119823: LD_VAR 0 16
119827: PUSH
119828: LD_VAR 0 7
119832: ARRAY
119833: PUSH
119834: LD_INT 1
119836: ARRAY
119837: PUSH
119838: LD_INT 1
119840: ARRAY
119841: PPUSH
119842: LD_VAR 0 16
119846: PUSH
119847: LD_VAR 0 7
119851: ARRAY
119852: PUSH
119853: LD_INT 1
119855: ARRAY
119856: PUSH
119857: LD_INT 2
119859: ARRAY
119860: PPUSH
119861: CALL_OW 114
// end else
119865: GO 119918
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
119867: LD_ADDR_VAR 0 15
119871: PUSH
119872: LD_VAR 0 16
119876: PUSH
119877: LD_VAR 0 7
119881: ARRAY
119882: PPUSH
119883: LD_INT 1
119885: PPUSH
119886: CALL_OW 3
119890: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
119891: LD_ADDR_VAR 0 16
119895: PUSH
119896: LD_VAR 0 16
119900: PPUSH
119901: LD_VAR 0 7
119905: PPUSH
119906: LD_VAR 0 15
119910: PPUSH
119911: CALL_OW 1
119915: ST_TO_ADDR
// continue ;
119916: GO 118461
// end ; end ; end else
119918: GO 122582
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
119920: LD_ADDR_VAR 0 14
119924: PUSH
119925: LD_INT 81
119927: PUSH
119928: LD_VAR 0 4
119932: PUSH
119933: LD_VAR 0 7
119937: ARRAY
119938: PPUSH
119939: CALL_OW 255
119943: PUSH
119944: EMPTY
119945: LIST
119946: LIST
119947: PPUSH
119948: CALL_OW 69
119952: ST_TO_ADDR
// if not tmp then
119953: LD_VAR 0 14
119957: NOT
119958: IFFALSE 119962
// continue ;
119960: GO 118461
// if f_ignore_area then
119962: LD_VAR 0 17
119966: IFFALSE 120054
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
119968: LD_ADDR_VAR 0 15
119972: PUSH
119973: LD_VAR 0 14
119977: PPUSH
119978: LD_INT 3
119980: PUSH
119981: LD_INT 92
119983: PUSH
119984: LD_VAR 0 17
119988: PUSH
119989: LD_INT 1
119991: ARRAY
119992: PUSH
119993: LD_VAR 0 17
119997: PUSH
119998: LD_INT 2
120000: ARRAY
120001: PUSH
120002: LD_VAR 0 17
120006: PUSH
120007: LD_INT 3
120009: ARRAY
120010: PUSH
120011: EMPTY
120012: LIST
120013: LIST
120014: LIST
120015: LIST
120016: PUSH
120017: EMPTY
120018: LIST
120019: LIST
120020: PPUSH
120021: CALL_OW 72
120025: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
120026: LD_VAR 0 14
120030: PUSH
120031: LD_VAR 0 15
120035: DIFF
120036: IFFALSE 120054
// tmp := tmp diff tmp2 ;
120038: LD_ADDR_VAR 0 14
120042: PUSH
120043: LD_VAR 0 14
120047: PUSH
120048: LD_VAR 0 15
120052: DIFF
120053: ST_TO_ADDR
// end ; if not f_murder then
120054: LD_VAR 0 20
120058: NOT
120059: IFFALSE 120117
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
120061: LD_ADDR_VAR 0 15
120065: PUSH
120066: LD_VAR 0 14
120070: PPUSH
120071: LD_INT 3
120073: PUSH
120074: LD_INT 50
120076: PUSH
120077: EMPTY
120078: LIST
120079: PUSH
120080: EMPTY
120081: LIST
120082: LIST
120083: PPUSH
120084: CALL_OW 72
120088: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
120089: LD_VAR 0 14
120093: PUSH
120094: LD_VAR 0 15
120098: DIFF
120099: IFFALSE 120117
// tmp := tmp diff tmp2 ;
120101: LD_ADDR_VAR 0 14
120105: PUSH
120106: LD_VAR 0 14
120110: PUSH
120111: LD_VAR 0 15
120115: DIFF
120116: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
120117: LD_ADDR_VAR 0 14
120121: PUSH
120122: LD_VAR 0 4
120126: PUSH
120127: LD_VAR 0 7
120131: ARRAY
120132: PPUSH
120133: LD_VAR 0 14
120137: PPUSH
120138: LD_INT 1
120140: PPUSH
120141: LD_INT 1
120143: PPUSH
120144: CALL 59209 0 4
120148: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
120149: LD_VAR 0 4
120153: PUSH
120154: LD_VAR 0 7
120158: ARRAY
120159: PPUSH
120160: CALL_OW 257
120164: PUSH
120165: LD_INT 1
120167: EQUAL
120168: IFFALSE 120616
// begin if WantPlant ( group [ i ] ) then
120170: LD_VAR 0 4
120174: PUSH
120175: LD_VAR 0 7
120179: ARRAY
120180: PPUSH
120181: CALL 58710 0 1
120185: IFFALSE 120189
// continue ;
120187: GO 118461
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
120189: LD_VAR 0 18
120193: PUSH
120194: LD_VAR 0 4
120198: PUSH
120199: LD_VAR 0 7
120203: ARRAY
120204: PPUSH
120205: CALL_OW 310
120209: NOT
120210: AND
120211: PUSH
120212: LD_VAR 0 14
120216: PUSH
120217: LD_INT 1
120219: ARRAY
120220: PUSH
120221: LD_VAR 0 14
120225: PPUSH
120226: LD_INT 21
120228: PUSH
120229: LD_INT 2
120231: PUSH
120232: EMPTY
120233: LIST
120234: LIST
120235: PUSH
120236: LD_INT 58
120238: PUSH
120239: EMPTY
120240: LIST
120241: PUSH
120242: EMPTY
120243: LIST
120244: LIST
120245: PPUSH
120246: CALL_OW 72
120250: IN
120251: AND
120252: IFFALSE 120288
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
120254: LD_VAR 0 4
120258: PUSH
120259: LD_VAR 0 7
120263: ARRAY
120264: PPUSH
120265: LD_VAR 0 14
120269: PUSH
120270: LD_INT 1
120272: ARRAY
120273: PPUSH
120274: CALL_OW 120
// attacking := true ;
120278: LD_ADDR_VAR 0 29
120282: PUSH
120283: LD_INT 1
120285: ST_TO_ADDR
// continue ;
120286: GO 118461
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
120288: LD_VAR 0 26
120292: PUSH
120293: LD_VAR 0 4
120297: PUSH
120298: LD_VAR 0 7
120302: ARRAY
120303: PPUSH
120304: CALL_OW 257
120308: PUSH
120309: LD_INT 1
120311: EQUAL
120312: AND
120313: PUSH
120314: LD_VAR 0 4
120318: PUSH
120319: LD_VAR 0 7
120323: ARRAY
120324: PPUSH
120325: CALL_OW 256
120329: PUSH
120330: LD_INT 800
120332: LESS
120333: AND
120334: PUSH
120335: LD_VAR 0 4
120339: PUSH
120340: LD_VAR 0 7
120344: ARRAY
120345: PPUSH
120346: CALL_OW 318
120350: NOT
120351: AND
120352: IFFALSE 120369
// ComCrawl ( group [ i ] ) ;
120354: LD_VAR 0 4
120358: PUSH
120359: LD_VAR 0 7
120363: ARRAY
120364: PPUSH
120365: CALL_OW 137
// if f_mines then
120369: LD_VAR 0 21
120373: IFFALSE 120616
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
120375: LD_VAR 0 14
120379: PUSH
120380: LD_INT 1
120382: ARRAY
120383: PPUSH
120384: CALL_OW 247
120388: PUSH
120389: LD_INT 3
120391: EQUAL
120392: PUSH
120393: LD_VAR 0 14
120397: PUSH
120398: LD_INT 1
120400: ARRAY
120401: PUSH
120402: LD_VAR 0 27
120406: IN
120407: NOT
120408: AND
120409: IFFALSE 120616
// begin x := GetX ( tmp [ 1 ] ) ;
120411: LD_ADDR_VAR 0 10
120415: PUSH
120416: LD_VAR 0 14
120420: PUSH
120421: LD_INT 1
120423: ARRAY
120424: PPUSH
120425: CALL_OW 250
120429: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
120430: LD_ADDR_VAR 0 11
120434: PUSH
120435: LD_VAR 0 14
120439: PUSH
120440: LD_INT 1
120442: ARRAY
120443: PPUSH
120444: CALL_OW 251
120448: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
120449: LD_ADDR_VAR 0 12
120453: PUSH
120454: LD_VAR 0 4
120458: PUSH
120459: LD_VAR 0 7
120463: ARRAY
120464: PPUSH
120465: CALL 86750 0 1
120469: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
120470: LD_VAR 0 4
120474: PUSH
120475: LD_VAR 0 7
120479: ARRAY
120480: PPUSH
120481: LD_VAR 0 10
120485: PPUSH
120486: LD_VAR 0 11
120490: PPUSH
120491: LD_VAR 0 14
120495: PUSH
120496: LD_INT 1
120498: ARRAY
120499: PPUSH
120500: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
120504: LD_VAR 0 4
120508: PUSH
120509: LD_VAR 0 7
120513: ARRAY
120514: PPUSH
120515: LD_VAR 0 10
120519: PPUSH
120520: LD_VAR 0 12
120524: PPUSH
120525: LD_INT 7
120527: PPUSH
120528: CALL_OW 272
120532: PPUSH
120533: LD_VAR 0 11
120537: PPUSH
120538: LD_VAR 0 12
120542: PPUSH
120543: LD_INT 7
120545: PPUSH
120546: CALL_OW 273
120550: PPUSH
120551: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
120555: LD_VAR 0 4
120559: PUSH
120560: LD_VAR 0 7
120564: ARRAY
120565: PPUSH
120566: LD_INT 71
120568: PPUSH
120569: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
120573: LD_ADDR_VAR 0 27
120577: PUSH
120578: LD_VAR 0 27
120582: PPUSH
120583: LD_VAR 0 27
120587: PUSH
120588: LD_INT 1
120590: PLUS
120591: PPUSH
120592: LD_VAR 0 14
120596: PUSH
120597: LD_INT 1
120599: ARRAY
120600: PPUSH
120601: CALL_OW 1
120605: ST_TO_ADDR
// attacking := true ;
120606: LD_ADDR_VAR 0 29
120610: PUSH
120611: LD_INT 1
120613: ST_TO_ADDR
// continue ;
120614: GO 118461
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
120616: LD_VAR 0 4
120620: PUSH
120621: LD_VAR 0 7
120625: ARRAY
120626: PPUSH
120627: CALL_OW 257
120631: PUSH
120632: LD_INT 17
120634: EQUAL
120635: PUSH
120636: LD_VAR 0 4
120640: PUSH
120641: LD_VAR 0 7
120645: ARRAY
120646: PPUSH
120647: CALL_OW 110
120651: PUSH
120652: LD_INT 71
120654: EQUAL
120655: NOT
120656: AND
120657: IFFALSE 120803
// begin attacking := false ;
120659: LD_ADDR_VAR 0 29
120663: PUSH
120664: LD_INT 0
120666: ST_TO_ADDR
// k := 5 ;
120667: LD_ADDR_VAR 0 9
120671: PUSH
120672: LD_INT 5
120674: ST_TO_ADDR
// if tmp < k then
120675: LD_VAR 0 14
120679: PUSH
120680: LD_VAR 0 9
120684: LESS
120685: IFFALSE 120697
// k := tmp ;
120687: LD_ADDR_VAR 0 9
120691: PUSH
120692: LD_VAR 0 14
120696: ST_TO_ADDR
// for j = 1 to k do
120697: LD_ADDR_VAR 0 8
120701: PUSH
120702: DOUBLE
120703: LD_INT 1
120705: DEC
120706: ST_TO_ADDR
120707: LD_VAR 0 9
120711: PUSH
120712: FOR_TO
120713: IFFALSE 120801
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
120715: LD_VAR 0 14
120719: PUSH
120720: LD_VAR 0 8
120724: ARRAY
120725: PUSH
120726: LD_VAR 0 14
120730: PPUSH
120731: LD_INT 58
120733: PUSH
120734: EMPTY
120735: LIST
120736: PPUSH
120737: CALL_OW 72
120741: IN
120742: NOT
120743: IFFALSE 120799
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
120745: LD_VAR 0 4
120749: PUSH
120750: LD_VAR 0 7
120754: ARRAY
120755: PPUSH
120756: LD_VAR 0 14
120760: PUSH
120761: LD_VAR 0 8
120765: ARRAY
120766: PPUSH
120767: CALL_OW 115
// attacking := true ;
120771: LD_ADDR_VAR 0 29
120775: PUSH
120776: LD_INT 1
120778: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
120779: LD_VAR 0 4
120783: PUSH
120784: LD_VAR 0 7
120788: ARRAY
120789: PPUSH
120790: LD_INT 71
120792: PPUSH
120793: CALL_OW 109
// continue ;
120797: GO 120712
// end ; end ;
120799: GO 120712
120801: POP
120802: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
120803: LD_VAR 0 4
120807: PUSH
120808: LD_VAR 0 7
120812: ARRAY
120813: PPUSH
120814: CALL_OW 257
120818: PUSH
120819: LD_INT 8
120821: EQUAL
120822: PUSH
120823: LD_VAR 0 4
120827: PUSH
120828: LD_VAR 0 7
120832: ARRAY
120833: PPUSH
120834: CALL_OW 264
120838: PUSH
120839: LD_INT 28
120841: PUSH
120842: LD_INT 45
120844: PUSH
120845: LD_INT 7
120847: PUSH
120848: LD_INT 47
120850: PUSH
120851: EMPTY
120852: LIST
120853: LIST
120854: LIST
120855: LIST
120856: IN
120857: OR
120858: IFFALSE 121114
// begin attacking := false ;
120860: LD_ADDR_VAR 0 29
120864: PUSH
120865: LD_INT 0
120867: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
120868: LD_VAR 0 14
120872: PUSH
120873: LD_INT 1
120875: ARRAY
120876: PPUSH
120877: CALL_OW 266
120881: PUSH
120882: LD_INT 32
120884: PUSH
120885: LD_INT 31
120887: PUSH
120888: LD_INT 33
120890: PUSH
120891: LD_INT 4
120893: PUSH
120894: LD_INT 5
120896: PUSH
120897: EMPTY
120898: LIST
120899: LIST
120900: LIST
120901: LIST
120902: LIST
120903: IN
120904: IFFALSE 121090
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
120906: LD_ADDR_VAR 0 9
120910: PUSH
120911: LD_VAR 0 14
120915: PUSH
120916: LD_INT 1
120918: ARRAY
120919: PPUSH
120920: CALL_OW 266
120924: PPUSH
120925: LD_VAR 0 14
120929: PUSH
120930: LD_INT 1
120932: ARRAY
120933: PPUSH
120934: CALL_OW 250
120938: PPUSH
120939: LD_VAR 0 14
120943: PUSH
120944: LD_INT 1
120946: ARRAY
120947: PPUSH
120948: CALL_OW 251
120952: PPUSH
120953: LD_VAR 0 14
120957: PUSH
120958: LD_INT 1
120960: ARRAY
120961: PPUSH
120962: CALL_OW 254
120966: PPUSH
120967: LD_VAR 0 14
120971: PUSH
120972: LD_INT 1
120974: ARRAY
120975: PPUSH
120976: CALL_OW 248
120980: PPUSH
120981: LD_INT 0
120983: PPUSH
120984: CALL 68120 0 6
120988: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
120989: LD_ADDR_VAR 0 8
120993: PUSH
120994: LD_VAR 0 4
120998: PUSH
120999: LD_VAR 0 7
121003: ARRAY
121004: PPUSH
121005: LD_VAR 0 9
121009: PPUSH
121010: CALL 86863 0 2
121014: ST_TO_ADDR
// if j then
121015: LD_VAR 0 8
121019: IFFALSE 121088
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
121021: LD_VAR 0 8
121025: PUSH
121026: LD_INT 1
121028: ARRAY
121029: PPUSH
121030: LD_VAR 0 8
121034: PUSH
121035: LD_INT 2
121037: ARRAY
121038: PPUSH
121039: CALL_OW 488
121043: IFFALSE 121088
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
121045: LD_VAR 0 4
121049: PUSH
121050: LD_VAR 0 7
121054: ARRAY
121055: PPUSH
121056: LD_VAR 0 8
121060: PUSH
121061: LD_INT 1
121063: ARRAY
121064: PPUSH
121065: LD_VAR 0 8
121069: PUSH
121070: LD_INT 2
121072: ARRAY
121073: PPUSH
121074: CALL_OW 116
// attacking := true ;
121078: LD_ADDR_VAR 0 29
121082: PUSH
121083: LD_INT 1
121085: ST_TO_ADDR
// continue ;
121086: GO 118461
// end ; end else
121088: GO 121114
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121090: LD_VAR 0 4
121094: PUSH
121095: LD_VAR 0 7
121099: ARRAY
121100: PPUSH
121101: LD_VAR 0 14
121105: PUSH
121106: LD_INT 1
121108: ARRAY
121109: PPUSH
121110: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
121114: LD_VAR 0 4
121118: PUSH
121119: LD_VAR 0 7
121123: ARRAY
121124: PPUSH
121125: CALL_OW 265
121129: PUSH
121130: LD_INT 11
121132: EQUAL
121133: IFFALSE 121411
// begin k := 10 ;
121135: LD_ADDR_VAR 0 9
121139: PUSH
121140: LD_INT 10
121142: ST_TO_ADDR
// x := 0 ;
121143: LD_ADDR_VAR 0 10
121147: PUSH
121148: LD_INT 0
121150: ST_TO_ADDR
// if tmp < k then
121151: LD_VAR 0 14
121155: PUSH
121156: LD_VAR 0 9
121160: LESS
121161: IFFALSE 121173
// k := tmp ;
121163: LD_ADDR_VAR 0 9
121167: PUSH
121168: LD_VAR 0 14
121172: ST_TO_ADDR
// for j = k downto 1 do
121173: LD_ADDR_VAR 0 8
121177: PUSH
121178: DOUBLE
121179: LD_VAR 0 9
121183: INC
121184: ST_TO_ADDR
121185: LD_INT 1
121187: PUSH
121188: FOR_DOWNTO
121189: IFFALSE 121264
// begin if GetType ( tmp [ j ] ) = unit_human then
121191: LD_VAR 0 14
121195: PUSH
121196: LD_VAR 0 8
121200: ARRAY
121201: PPUSH
121202: CALL_OW 247
121206: PUSH
121207: LD_INT 1
121209: EQUAL
121210: IFFALSE 121262
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
121212: LD_VAR 0 4
121216: PUSH
121217: LD_VAR 0 7
121221: ARRAY
121222: PPUSH
121223: LD_VAR 0 14
121227: PUSH
121228: LD_VAR 0 8
121232: ARRAY
121233: PPUSH
121234: CALL 87117 0 2
// x := tmp [ j ] ;
121238: LD_ADDR_VAR 0 10
121242: PUSH
121243: LD_VAR 0 14
121247: PUSH
121248: LD_VAR 0 8
121252: ARRAY
121253: ST_TO_ADDR
// attacking := true ;
121254: LD_ADDR_VAR 0 29
121258: PUSH
121259: LD_INT 1
121261: ST_TO_ADDR
// end ; end ;
121262: GO 121188
121264: POP
121265: POP
// if not x then
121266: LD_VAR 0 10
121270: NOT
121271: IFFALSE 121411
// begin attacking := true ;
121273: LD_ADDR_VAR 0 29
121277: PUSH
121278: LD_INT 1
121280: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
121281: LD_VAR 0 4
121285: PUSH
121286: LD_VAR 0 7
121290: ARRAY
121291: PPUSH
121292: CALL_OW 250
121296: PPUSH
121297: LD_VAR 0 4
121301: PUSH
121302: LD_VAR 0 7
121306: ARRAY
121307: PPUSH
121308: CALL_OW 251
121312: PPUSH
121313: CALL_OW 546
121317: PUSH
121318: LD_INT 2
121320: ARRAY
121321: PUSH
121322: LD_VAR 0 14
121326: PUSH
121327: LD_INT 1
121329: ARRAY
121330: PPUSH
121331: CALL_OW 250
121335: PPUSH
121336: LD_VAR 0 14
121340: PUSH
121341: LD_INT 1
121343: ARRAY
121344: PPUSH
121345: CALL_OW 251
121349: PPUSH
121350: CALL_OW 546
121354: PUSH
121355: LD_INT 2
121357: ARRAY
121358: EQUAL
121359: IFFALSE 121387
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
121361: LD_VAR 0 4
121365: PUSH
121366: LD_VAR 0 7
121370: ARRAY
121371: PPUSH
121372: LD_VAR 0 14
121376: PUSH
121377: LD_INT 1
121379: ARRAY
121380: PPUSH
121381: CALL 87117 0 2
121385: GO 121411
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121387: LD_VAR 0 4
121391: PUSH
121392: LD_VAR 0 7
121396: ARRAY
121397: PPUSH
121398: LD_VAR 0 14
121402: PUSH
121403: LD_INT 1
121405: ARRAY
121406: PPUSH
121407: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
121411: LD_VAR 0 4
121415: PUSH
121416: LD_VAR 0 7
121420: ARRAY
121421: PPUSH
121422: CALL_OW 264
121426: PUSH
121427: LD_INT 29
121429: EQUAL
121430: IFFALSE 121796
// begin if WantsToAttack ( group [ i ] ) in bombed then
121432: LD_VAR 0 4
121436: PUSH
121437: LD_VAR 0 7
121441: ARRAY
121442: PPUSH
121443: CALL_OW 319
121447: PUSH
121448: LD_VAR 0 28
121452: IN
121453: IFFALSE 121457
// continue ;
121455: GO 118461
// k := 8 ;
121457: LD_ADDR_VAR 0 9
121461: PUSH
121462: LD_INT 8
121464: ST_TO_ADDR
// x := 0 ;
121465: LD_ADDR_VAR 0 10
121469: PUSH
121470: LD_INT 0
121472: ST_TO_ADDR
// if tmp < k then
121473: LD_VAR 0 14
121477: PUSH
121478: LD_VAR 0 9
121482: LESS
121483: IFFALSE 121495
// k := tmp ;
121485: LD_ADDR_VAR 0 9
121489: PUSH
121490: LD_VAR 0 14
121494: ST_TO_ADDR
// for j = 1 to k do
121495: LD_ADDR_VAR 0 8
121499: PUSH
121500: DOUBLE
121501: LD_INT 1
121503: DEC
121504: ST_TO_ADDR
121505: LD_VAR 0 9
121509: PUSH
121510: FOR_TO
121511: IFFALSE 121643
// begin if GetType ( tmp [ j ] ) = unit_building then
121513: LD_VAR 0 14
121517: PUSH
121518: LD_VAR 0 8
121522: ARRAY
121523: PPUSH
121524: CALL_OW 247
121528: PUSH
121529: LD_INT 3
121531: EQUAL
121532: IFFALSE 121641
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
121534: LD_VAR 0 14
121538: PUSH
121539: LD_VAR 0 8
121543: ARRAY
121544: PUSH
121545: LD_VAR 0 28
121549: IN
121550: NOT
121551: PUSH
121552: LD_VAR 0 14
121556: PUSH
121557: LD_VAR 0 8
121561: ARRAY
121562: PPUSH
121563: CALL_OW 313
121567: AND
121568: IFFALSE 121641
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
121570: LD_VAR 0 4
121574: PUSH
121575: LD_VAR 0 7
121579: ARRAY
121580: PPUSH
121581: LD_VAR 0 14
121585: PUSH
121586: LD_VAR 0 8
121590: ARRAY
121591: PPUSH
121592: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
121596: LD_ADDR_VAR 0 28
121600: PUSH
121601: LD_VAR 0 28
121605: PPUSH
121606: LD_VAR 0 28
121610: PUSH
121611: LD_INT 1
121613: PLUS
121614: PPUSH
121615: LD_VAR 0 14
121619: PUSH
121620: LD_VAR 0 8
121624: ARRAY
121625: PPUSH
121626: CALL_OW 1
121630: ST_TO_ADDR
// attacking := true ;
121631: LD_ADDR_VAR 0 29
121635: PUSH
121636: LD_INT 1
121638: ST_TO_ADDR
// break ;
121639: GO 121643
// end ; end ;
121641: GO 121510
121643: POP
121644: POP
// if not attacking and f_attack_depot then
121645: LD_VAR 0 29
121649: NOT
121650: PUSH
121651: LD_VAR 0 25
121655: AND
121656: IFFALSE 121751
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
121658: LD_ADDR_VAR 0 13
121662: PUSH
121663: LD_VAR 0 14
121667: PPUSH
121668: LD_INT 2
121670: PUSH
121671: LD_INT 30
121673: PUSH
121674: LD_INT 0
121676: PUSH
121677: EMPTY
121678: LIST
121679: LIST
121680: PUSH
121681: LD_INT 30
121683: PUSH
121684: LD_INT 1
121686: PUSH
121687: EMPTY
121688: LIST
121689: LIST
121690: PUSH
121691: EMPTY
121692: LIST
121693: LIST
121694: LIST
121695: PPUSH
121696: CALL_OW 72
121700: ST_TO_ADDR
// if z then
121701: LD_VAR 0 13
121705: IFFALSE 121751
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
121707: LD_VAR 0 4
121711: PUSH
121712: LD_VAR 0 7
121716: ARRAY
121717: PPUSH
121718: LD_VAR 0 13
121722: PPUSH
121723: LD_VAR 0 4
121727: PUSH
121728: LD_VAR 0 7
121732: ARRAY
121733: PPUSH
121734: CALL_OW 74
121738: PPUSH
121739: CALL_OW 115
// attacking := true ;
121743: LD_ADDR_VAR 0 29
121747: PUSH
121748: LD_INT 1
121750: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
121751: LD_VAR 0 4
121755: PUSH
121756: LD_VAR 0 7
121760: ARRAY
121761: PPUSH
121762: CALL_OW 256
121766: PUSH
121767: LD_INT 500
121769: LESS
121770: IFFALSE 121796
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121772: LD_VAR 0 4
121776: PUSH
121777: LD_VAR 0 7
121781: ARRAY
121782: PPUSH
121783: LD_VAR 0 14
121787: PUSH
121788: LD_INT 1
121790: ARRAY
121791: PPUSH
121792: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
121796: LD_VAR 0 4
121800: PUSH
121801: LD_VAR 0 7
121805: ARRAY
121806: PPUSH
121807: CALL_OW 264
121811: PUSH
121812: LD_INT 49
121814: EQUAL
121815: IFFALSE 121936
// begin if not HasTask ( group [ i ] ) then
121817: LD_VAR 0 4
121821: PUSH
121822: LD_VAR 0 7
121826: ARRAY
121827: PPUSH
121828: CALL_OW 314
121832: NOT
121833: IFFALSE 121936
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
121835: LD_ADDR_VAR 0 9
121839: PUSH
121840: LD_INT 81
121842: PUSH
121843: LD_VAR 0 4
121847: PUSH
121848: LD_VAR 0 7
121852: ARRAY
121853: PPUSH
121854: CALL_OW 255
121858: PUSH
121859: EMPTY
121860: LIST
121861: LIST
121862: PPUSH
121863: CALL_OW 69
121867: PPUSH
121868: LD_VAR 0 4
121872: PUSH
121873: LD_VAR 0 7
121877: ARRAY
121878: PPUSH
121879: CALL_OW 74
121883: ST_TO_ADDR
// if k then
121884: LD_VAR 0 9
121888: IFFALSE 121936
// if GetDistUnits ( group [ i ] , k ) > 10 then
121890: LD_VAR 0 4
121894: PUSH
121895: LD_VAR 0 7
121899: ARRAY
121900: PPUSH
121901: LD_VAR 0 9
121905: PPUSH
121906: CALL_OW 296
121910: PUSH
121911: LD_INT 10
121913: GREATER
121914: IFFALSE 121936
// ComMoveUnit ( group [ i ] , k ) ;
121916: LD_VAR 0 4
121920: PUSH
121921: LD_VAR 0 7
121925: ARRAY
121926: PPUSH
121927: LD_VAR 0 9
121931: PPUSH
121932: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
121936: LD_VAR 0 4
121940: PUSH
121941: LD_VAR 0 7
121945: ARRAY
121946: PPUSH
121947: CALL_OW 256
121951: PUSH
121952: LD_INT 250
121954: LESS
121955: PUSH
121956: LD_VAR 0 4
121960: PUSH
121961: LD_VAR 0 7
121965: ARRAY
121966: PUSH
121967: LD_INT 21
121969: PUSH
121970: LD_INT 2
121972: PUSH
121973: EMPTY
121974: LIST
121975: LIST
121976: PUSH
121977: LD_INT 23
121979: PUSH
121980: LD_INT 2
121982: PUSH
121983: EMPTY
121984: LIST
121985: LIST
121986: PUSH
121987: EMPTY
121988: LIST
121989: LIST
121990: PPUSH
121991: CALL_OW 69
121995: IN
121996: AND
121997: IFFALSE 122122
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
121999: LD_ADDR_VAR 0 9
122003: PUSH
122004: LD_OWVAR 3
122008: PUSH
122009: LD_VAR 0 4
122013: PUSH
122014: LD_VAR 0 7
122018: ARRAY
122019: DIFF
122020: PPUSH
122021: LD_VAR 0 4
122025: PUSH
122026: LD_VAR 0 7
122030: ARRAY
122031: PPUSH
122032: CALL_OW 74
122036: ST_TO_ADDR
// if not k then
122037: LD_VAR 0 9
122041: NOT
122042: IFFALSE 122046
// continue ;
122044: GO 118461
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
122046: LD_VAR 0 9
122050: PUSH
122051: LD_INT 81
122053: PUSH
122054: LD_VAR 0 4
122058: PUSH
122059: LD_VAR 0 7
122063: ARRAY
122064: PPUSH
122065: CALL_OW 255
122069: PUSH
122070: EMPTY
122071: LIST
122072: LIST
122073: PPUSH
122074: CALL_OW 69
122078: IN
122079: PUSH
122080: LD_VAR 0 9
122084: PPUSH
122085: LD_VAR 0 4
122089: PUSH
122090: LD_VAR 0 7
122094: ARRAY
122095: PPUSH
122096: CALL_OW 296
122100: PUSH
122101: LD_INT 5
122103: LESS
122104: AND
122105: IFFALSE 122122
// ComAutodestruct ( group [ i ] ) ;
122107: LD_VAR 0 4
122111: PUSH
122112: LD_VAR 0 7
122116: ARRAY
122117: PPUSH
122118: CALL 87015 0 1
// end ; if f_attack_depot then
122122: LD_VAR 0 25
122126: IFFALSE 122238
// begin k := 6 ;
122128: LD_ADDR_VAR 0 9
122132: PUSH
122133: LD_INT 6
122135: ST_TO_ADDR
// if tmp < k then
122136: LD_VAR 0 14
122140: PUSH
122141: LD_VAR 0 9
122145: LESS
122146: IFFALSE 122158
// k := tmp ;
122148: LD_ADDR_VAR 0 9
122152: PUSH
122153: LD_VAR 0 14
122157: ST_TO_ADDR
// for j = 1 to k do
122158: LD_ADDR_VAR 0 8
122162: PUSH
122163: DOUBLE
122164: LD_INT 1
122166: DEC
122167: ST_TO_ADDR
122168: LD_VAR 0 9
122172: PUSH
122173: FOR_TO
122174: IFFALSE 122236
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
122176: LD_VAR 0 8
122180: PPUSH
122181: CALL_OW 266
122185: PUSH
122186: LD_INT 0
122188: PUSH
122189: LD_INT 1
122191: PUSH
122192: EMPTY
122193: LIST
122194: LIST
122195: IN
122196: IFFALSE 122234
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
122198: LD_VAR 0 4
122202: PUSH
122203: LD_VAR 0 7
122207: ARRAY
122208: PPUSH
122209: LD_VAR 0 14
122213: PUSH
122214: LD_VAR 0 8
122218: ARRAY
122219: PPUSH
122220: CALL_OW 115
// attacking := true ;
122224: LD_ADDR_VAR 0 29
122228: PUSH
122229: LD_INT 1
122231: ST_TO_ADDR
// break ;
122232: GO 122236
// end ;
122234: GO 122173
122236: POP
122237: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
122238: LD_VAR 0 4
122242: PUSH
122243: LD_VAR 0 7
122247: ARRAY
122248: PPUSH
122249: CALL_OW 302
122253: PUSH
122254: LD_VAR 0 29
122258: NOT
122259: AND
122260: IFFALSE 122582
// begin if GetTag ( group [ i ] ) = 71 then
122262: LD_VAR 0 4
122266: PUSH
122267: LD_VAR 0 7
122271: ARRAY
122272: PPUSH
122273: CALL_OW 110
122277: PUSH
122278: LD_INT 71
122280: EQUAL
122281: IFFALSE 122322
// begin if HasTask ( group [ i ] ) then
122283: LD_VAR 0 4
122287: PUSH
122288: LD_VAR 0 7
122292: ARRAY
122293: PPUSH
122294: CALL_OW 314
122298: IFFALSE 122304
// continue else
122300: GO 118461
122302: GO 122322
// SetTag ( group [ i ] , 0 ) ;
122304: LD_VAR 0 4
122308: PUSH
122309: LD_VAR 0 7
122313: ARRAY
122314: PPUSH
122315: LD_INT 0
122317: PPUSH
122318: CALL_OW 109
// end ; k := 8 ;
122322: LD_ADDR_VAR 0 9
122326: PUSH
122327: LD_INT 8
122329: ST_TO_ADDR
// x := 0 ;
122330: LD_ADDR_VAR 0 10
122334: PUSH
122335: LD_INT 0
122337: ST_TO_ADDR
// if tmp < k then
122338: LD_VAR 0 14
122342: PUSH
122343: LD_VAR 0 9
122347: LESS
122348: IFFALSE 122360
// k := tmp ;
122350: LD_ADDR_VAR 0 9
122354: PUSH
122355: LD_VAR 0 14
122359: ST_TO_ADDR
// for j = 1 to k do
122360: LD_ADDR_VAR 0 8
122364: PUSH
122365: DOUBLE
122366: LD_INT 1
122368: DEC
122369: ST_TO_ADDR
122370: LD_VAR 0 9
122374: PUSH
122375: FOR_TO
122376: IFFALSE 122474
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
122378: LD_VAR 0 14
122382: PUSH
122383: LD_VAR 0 8
122387: ARRAY
122388: PPUSH
122389: CALL_OW 247
122393: PUSH
122394: LD_INT 1
122396: EQUAL
122397: PUSH
122398: LD_VAR 0 14
122402: PUSH
122403: LD_VAR 0 8
122407: ARRAY
122408: PPUSH
122409: CALL_OW 256
122413: PUSH
122414: LD_INT 250
122416: LESS
122417: PUSH
122418: LD_VAR 0 20
122422: AND
122423: PUSH
122424: LD_VAR 0 20
122428: NOT
122429: PUSH
122430: LD_VAR 0 14
122434: PUSH
122435: LD_VAR 0 8
122439: ARRAY
122440: PPUSH
122441: CALL_OW 256
122445: PUSH
122446: LD_INT 250
122448: GREATEREQUAL
122449: AND
122450: OR
122451: AND
122452: IFFALSE 122472
// begin x := tmp [ j ] ;
122454: LD_ADDR_VAR 0 10
122458: PUSH
122459: LD_VAR 0 14
122463: PUSH
122464: LD_VAR 0 8
122468: ARRAY
122469: ST_TO_ADDR
// break ;
122470: GO 122474
// end ;
122472: GO 122375
122474: POP
122475: POP
// if x then
122476: LD_VAR 0 10
122480: IFFALSE 122504
// ComAttackUnit ( group [ i ] , x ) else
122482: LD_VAR 0 4
122486: PUSH
122487: LD_VAR 0 7
122491: ARRAY
122492: PPUSH
122493: LD_VAR 0 10
122497: PPUSH
122498: CALL_OW 115
122502: GO 122528
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122504: LD_VAR 0 4
122508: PUSH
122509: LD_VAR 0 7
122513: ARRAY
122514: PPUSH
122515: LD_VAR 0 14
122519: PUSH
122520: LD_INT 1
122522: ARRAY
122523: PPUSH
122524: CALL_OW 115
// if not HasTask ( group [ i ] ) then
122528: LD_VAR 0 4
122532: PUSH
122533: LD_VAR 0 7
122537: ARRAY
122538: PPUSH
122539: CALL_OW 314
122543: NOT
122544: IFFALSE 122582
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
122546: LD_VAR 0 4
122550: PUSH
122551: LD_VAR 0 7
122555: ARRAY
122556: PPUSH
122557: LD_VAR 0 14
122561: PPUSH
122562: LD_VAR 0 4
122566: PUSH
122567: LD_VAR 0 7
122571: ARRAY
122572: PPUSH
122573: CALL_OW 74
122577: PPUSH
122578: CALL_OW 115
// end ; end ; end ;
122582: GO 118461
122584: POP
122585: POP
// wait ( 0 0$2 ) ;
122586: LD_INT 70
122588: PPUSH
122589: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
122593: LD_VAR 0 4
122597: NOT
122598: PUSH
122599: LD_VAR 0 4
122603: PUSH
122604: EMPTY
122605: EQUAL
122606: OR
122607: PUSH
122608: LD_INT 81
122610: PUSH
122611: LD_VAR 0 35
122615: PUSH
122616: EMPTY
122617: LIST
122618: LIST
122619: PPUSH
122620: CALL_OW 69
122624: NOT
122625: OR
122626: IFFALSE 118446
// end ;
122628: LD_VAR 0 2
122632: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
122633: LD_INT 0
122635: PPUSH
122636: PPUSH
122637: PPUSH
122638: PPUSH
122639: PPUSH
122640: PPUSH
// if not base or not mc_bases [ base ] or not solds then
122641: LD_VAR 0 1
122645: NOT
122646: PUSH
122647: LD_EXP 80
122651: PUSH
122652: LD_VAR 0 1
122656: ARRAY
122657: NOT
122658: OR
122659: PUSH
122660: LD_VAR 0 2
122664: NOT
122665: OR
122666: IFFALSE 122670
// exit ;
122668: GO 123224
// side := mc_sides [ base ] ;
122670: LD_ADDR_VAR 0 6
122674: PUSH
122675: LD_EXP 106
122679: PUSH
122680: LD_VAR 0 1
122684: ARRAY
122685: ST_TO_ADDR
// if not side then
122686: LD_VAR 0 6
122690: NOT
122691: IFFALSE 122695
// exit ;
122693: GO 123224
// for i in solds do
122695: LD_ADDR_VAR 0 7
122699: PUSH
122700: LD_VAR 0 2
122704: PUSH
122705: FOR_IN
122706: IFFALSE 122767
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
122708: LD_VAR 0 7
122712: PPUSH
122713: CALL_OW 310
122717: PPUSH
122718: CALL_OW 266
122722: PUSH
122723: LD_INT 32
122725: PUSH
122726: LD_INT 31
122728: PUSH
122729: EMPTY
122730: LIST
122731: LIST
122732: IN
122733: IFFALSE 122753
// solds := solds diff i else
122735: LD_ADDR_VAR 0 2
122739: PUSH
122740: LD_VAR 0 2
122744: PUSH
122745: LD_VAR 0 7
122749: DIFF
122750: ST_TO_ADDR
122751: GO 122765
// SetTag ( i , 18 ) ;
122753: LD_VAR 0 7
122757: PPUSH
122758: LD_INT 18
122760: PPUSH
122761: CALL_OW 109
122765: GO 122705
122767: POP
122768: POP
// if not solds then
122769: LD_VAR 0 2
122773: NOT
122774: IFFALSE 122778
// exit ;
122776: GO 123224
// repeat wait ( 0 0$2 ) ;
122778: LD_INT 70
122780: PPUSH
122781: CALL_OW 67
// enemy := mc_scan [ base ] ;
122785: LD_ADDR_VAR 0 4
122789: PUSH
122790: LD_EXP 103
122794: PUSH
122795: LD_VAR 0 1
122799: ARRAY
122800: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122801: LD_EXP 80
122805: PUSH
122806: LD_VAR 0 1
122810: ARRAY
122811: NOT
122812: PUSH
122813: LD_EXP 80
122817: PUSH
122818: LD_VAR 0 1
122822: ARRAY
122823: PUSH
122824: EMPTY
122825: EQUAL
122826: OR
122827: IFFALSE 122864
// begin for i in solds do
122829: LD_ADDR_VAR 0 7
122833: PUSH
122834: LD_VAR 0 2
122838: PUSH
122839: FOR_IN
122840: IFFALSE 122853
// ComStop ( i ) ;
122842: LD_VAR 0 7
122846: PPUSH
122847: CALL_OW 141
122851: GO 122839
122853: POP
122854: POP
// solds := [ ] ;
122855: LD_ADDR_VAR 0 2
122859: PUSH
122860: EMPTY
122861: ST_TO_ADDR
// exit ;
122862: GO 123224
// end ; for i in solds do
122864: LD_ADDR_VAR 0 7
122868: PUSH
122869: LD_VAR 0 2
122873: PUSH
122874: FOR_IN
122875: IFFALSE 123196
// begin if IsInUnit ( i ) then
122877: LD_VAR 0 7
122881: PPUSH
122882: CALL_OW 310
122886: IFFALSE 122897
// ComExitBuilding ( i ) ;
122888: LD_VAR 0 7
122892: PPUSH
122893: CALL_OW 122
// if GetLives ( i ) > 500 then
122897: LD_VAR 0 7
122901: PPUSH
122902: CALL_OW 256
122906: PUSH
122907: LD_INT 500
122909: GREATER
122910: IFFALSE 122963
// begin e := NearestUnitToUnit ( enemy , i ) ;
122912: LD_ADDR_VAR 0 5
122916: PUSH
122917: LD_VAR 0 4
122921: PPUSH
122922: LD_VAR 0 7
122926: PPUSH
122927: CALL_OW 74
122931: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
122932: LD_VAR 0 7
122936: PPUSH
122937: LD_VAR 0 5
122941: PPUSH
122942: CALL_OW 250
122946: PPUSH
122947: LD_VAR 0 5
122951: PPUSH
122952: CALL_OW 251
122956: PPUSH
122957: CALL_OW 114
// end else
122961: GO 123194
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
122963: LD_VAR 0 7
122967: PPUSH
122968: LD_EXP 80
122972: PUSH
122973: LD_VAR 0 1
122977: ARRAY
122978: PPUSH
122979: LD_INT 2
122981: PUSH
122982: LD_INT 30
122984: PUSH
122985: LD_INT 0
122987: PUSH
122988: EMPTY
122989: LIST
122990: LIST
122991: PUSH
122992: LD_INT 30
122994: PUSH
122995: LD_INT 1
122997: PUSH
122998: EMPTY
122999: LIST
123000: LIST
123001: PUSH
123002: LD_INT 30
123004: PUSH
123005: LD_INT 6
123007: PUSH
123008: EMPTY
123009: LIST
123010: LIST
123011: PUSH
123012: EMPTY
123013: LIST
123014: LIST
123015: LIST
123016: LIST
123017: PPUSH
123018: CALL_OW 72
123022: PPUSH
123023: LD_VAR 0 7
123027: PPUSH
123028: CALL_OW 74
123032: PPUSH
123033: CALL_OW 296
123037: PUSH
123038: LD_INT 10
123040: GREATER
123041: IFFALSE 123194
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
123043: LD_ADDR_VAR 0 8
123047: PUSH
123048: LD_EXP 80
123052: PUSH
123053: LD_VAR 0 1
123057: ARRAY
123058: PPUSH
123059: LD_INT 2
123061: PUSH
123062: LD_INT 30
123064: PUSH
123065: LD_INT 0
123067: PUSH
123068: EMPTY
123069: LIST
123070: LIST
123071: PUSH
123072: LD_INT 30
123074: PUSH
123075: LD_INT 1
123077: PUSH
123078: EMPTY
123079: LIST
123080: LIST
123081: PUSH
123082: LD_INT 30
123084: PUSH
123085: LD_INT 6
123087: PUSH
123088: EMPTY
123089: LIST
123090: LIST
123091: PUSH
123092: EMPTY
123093: LIST
123094: LIST
123095: LIST
123096: LIST
123097: PPUSH
123098: CALL_OW 72
123102: PPUSH
123103: LD_VAR 0 7
123107: PPUSH
123108: CALL_OW 74
123112: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
123113: LD_VAR 0 7
123117: PPUSH
123118: LD_VAR 0 8
123122: PPUSH
123123: CALL_OW 250
123127: PPUSH
123128: LD_INT 3
123130: PPUSH
123131: LD_INT 5
123133: PPUSH
123134: CALL_OW 272
123138: PPUSH
123139: LD_VAR 0 8
123143: PPUSH
123144: CALL_OW 251
123148: PPUSH
123149: LD_INT 3
123151: PPUSH
123152: LD_INT 5
123154: PPUSH
123155: CALL_OW 273
123159: PPUSH
123160: CALL_OW 111
// SetTag ( i , 0 ) ;
123164: LD_VAR 0 7
123168: PPUSH
123169: LD_INT 0
123171: PPUSH
123172: CALL_OW 109
// solds := solds diff i ;
123176: LD_ADDR_VAR 0 2
123180: PUSH
123181: LD_VAR 0 2
123185: PUSH
123186: LD_VAR 0 7
123190: DIFF
123191: ST_TO_ADDR
// continue ;
123192: GO 122874
// end ; end ;
123194: GO 122874
123196: POP
123197: POP
// until not solds or not enemy ;
123198: LD_VAR 0 2
123202: NOT
123203: PUSH
123204: LD_VAR 0 4
123208: NOT
123209: OR
123210: IFFALSE 122778
// MC_Reset ( base , 18 ) ;
123212: LD_VAR 0 1
123216: PPUSH
123217: LD_INT 18
123219: PPUSH
123220: CALL 27189 0 2
// end ;
123224: LD_VAR 0 3
123228: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
123229: LD_INT 0
123231: PPUSH
123232: PPUSH
123233: PPUSH
123234: PPUSH
123235: PPUSH
123236: PPUSH
123237: PPUSH
123238: PPUSH
123239: PPUSH
123240: PPUSH
123241: PPUSH
123242: PPUSH
123243: PPUSH
123244: PPUSH
123245: PPUSH
123246: PPUSH
123247: PPUSH
123248: PPUSH
123249: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
123250: LD_ADDR_VAR 0 12
123254: PUSH
123255: LD_EXP 80
123259: PUSH
123260: LD_VAR 0 1
123264: ARRAY
123265: PPUSH
123266: LD_INT 25
123268: PUSH
123269: LD_INT 3
123271: PUSH
123272: EMPTY
123273: LIST
123274: LIST
123275: PPUSH
123276: CALL_OW 72
123280: ST_TO_ADDR
// if mc_remote_driver [ base ] then
123281: LD_EXP 120
123285: PUSH
123286: LD_VAR 0 1
123290: ARRAY
123291: IFFALSE 123315
// mechs := mechs diff mc_remote_driver [ base ] ;
123293: LD_ADDR_VAR 0 12
123297: PUSH
123298: LD_VAR 0 12
123302: PUSH
123303: LD_EXP 120
123307: PUSH
123308: LD_VAR 0 1
123312: ARRAY
123313: DIFF
123314: ST_TO_ADDR
// for i in mechs do
123315: LD_ADDR_VAR 0 4
123319: PUSH
123320: LD_VAR 0 12
123324: PUSH
123325: FOR_IN
123326: IFFALSE 123361
// if GetTag ( i ) > 0 then
123328: LD_VAR 0 4
123332: PPUSH
123333: CALL_OW 110
123337: PUSH
123338: LD_INT 0
123340: GREATER
123341: IFFALSE 123359
// mechs := mechs diff i ;
123343: LD_ADDR_VAR 0 12
123347: PUSH
123348: LD_VAR 0 12
123352: PUSH
123353: LD_VAR 0 4
123357: DIFF
123358: ST_TO_ADDR
123359: GO 123325
123361: POP
123362: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
123363: LD_ADDR_VAR 0 8
123367: PUSH
123368: LD_EXP 80
123372: PUSH
123373: LD_VAR 0 1
123377: ARRAY
123378: PPUSH
123379: LD_INT 2
123381: PUSH
123382: LD_INT 25
123384: PUSH
123385: LD_INT 1
123387: PUSH
123388: EMPTY
123389: LIST
123390: LIST
123391: PUSH
123392: LD_INT 25
123394: PUSH
123395: LD_INT 5
123397: PUSH
123398: EMPTY
123399: LIST
123400: LIST
123401: PUSH
123402: LD_INT 25
123404: PUSH
123405: LD_INT 8
123407: PUSH
123408: EMPTY
123409: LIST
123410: LIST
123411: PUSH
123412: LD_INT 25
123414: PUSH
123415: LD_INT 9
123417: PUSH
123418: EMPTY
123419: LIST
123420: LIST
123421: PUSH
123422: EMPTY
123423: LIST
123424: LIST
123425: LIST
123426: LIST
123427: LIST
123428: PPUSH
123429: CALL_OW 72
123433: ST_TO_ADDR
// if not defenders and not solds then
123434: LD_VAR 0 2
123438: NOT
123439: PUSH
123440: LD_VAR 0 8
123444: NOT
123445: AND
123446: IFFALSE 123450
// exit ;
123448: GO 125220
// depot_under_attack := false ;
123450: LD_ADDR_VAR 0 16
123454: PUSH
123455: LD_INT 0
123457: ST_TO_ADDR
// sold_defenders := [ ] ;
123458: LD_ADDR_VAR 0 17
123462: PUSH
123463: EMPTY
123464: ST_TO_ADDR
// if mechs then
123465: LD_VAR 0 12
123469: IFFALSE 123622
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
123471: LD_ADDR_VAR 0 4
123475: PUSH
123476: LD_VAR 0 2
123480: PPUSH
123481: LD_INT 21
123483: PUSH
123484: LD_INT 2
123486: PUSH
123487: EMPTY
123488: LIST
123489: LIST
123490: PPUSH
123491: CALL_OW 72
123495: PUSH
123496: FOR_IN
123497: IFFALSE 123620
// begin if GetTag ( i ) <> 20 then
123499: LD_VAR 0 4
123503: PPUSH
123504: CALL_OW 110
123508: PUSH
123509: LD_INT 20
123511: NONEQUAL
123512: IFFALSE 123526
// SetTag ( i , 20 ) ;
123514: LD_VAR 0 4
123518: PPUSH
123519: LD_INT 20
123521: PPUSH
123522: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
123526: LD_VAR 0 4
123530: PPUSH
123531: CALL_OW 263
123535: PUSH
123536: LD_INT 1
123538: EQUAL
123539: PUSH
123540: LD_VAR 0 4
123544: PPUSH
123545: CALL_OW 311
123549: NOT
123550: AND
123551: IFFALSE 123618
// begin un := mechs [ 1 ] ;
123553: LD_ADDR_VAR 0 10
123557: PUSH
123558: LD_VAR 0 12
123562: PUSH
123563: LD_INT 1
123565: ARRAY
123566: ST_TO_ADDR
// ComExit ( un ) ;
123567: LD_VAR 0 10
123571: PPUSH
123572: CALL 91921 0 1
// AddComEnterUnit ( un , i ) ;
123576: LD_VAR 0 10
123580: PPUSH
123581: LD_VAR 0 4
123585: PPUSH
123586: CALL_OW 180
// SetTag ( un , 19 ) ;
123590: LD_VAR 0 10
123594: PPUSH
123595: LD_INT 19
123597: PPUSH
123598: CALL_OW 109
// mechs := mechs diff un ;
123602: LD_ADDR_VAR 0 12
123606: PUSH
123607: LD_VAR 0 12
123611: PUSH
123612: LD_VAR 0 10
123616: DIFF
123617: ST_TO_ADDR
// end ; end ;
123618: GO 123496
123620: POP
123621: POP
// if solds then
123622: LD_VAR 0 8
123626: IFFALSE 123685
// for i in solds do
123628: LD_ADDR_VAR 0 4
123632: PUSH
123633: LD_VAR 0 8
123637: PUSH
123638: FOR_IN
123639: IFFALSE 123683
// if not GetTag ( i ) then
123641: LD_VAR 0 4
123645: PPUSH
123646: CALL_OW 110
123650: NOT
123651: IFFALSE 123681
// begin defenders := defenders union i ;
123653: LD_ADDR_VAR 0 2
123657: PUSH
123658: LD_VAR 0 2
123662: PUSH
123663: LD_VAR 0 4
123667: UNION
123668: ST_TO_ADDR
// SetTag ( i , 18 ) ;
123669: LD_VAR 0 4
123673: PPUSH
123674: LD_INT 18
123676: PPUSH
123677: CALL_OW 109
// end ;
123681: GO 123638
123683: POP
123684: POP
// repeat wait ( 0 0$2 ) ;
123685: LD_INT 70
123687: PPUSH
123688: CALL_OW 67
// enemy := mc_scan [ base ] ;
123692: LD_ADDR_VAR 0 21
123696: PUSH
123697: LD_EXP 103
123701: PUSH
123702: LD_VAR 0 1
123706: ARRAY
123707: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
123708: LD_EXP 80
123712: PUSH
123713: LD_VAR 0 1
123717: ARRAY
123718: NOT
123719: PUSH
123720: LD_EXP 80
123724: PUSH
123725: LD_VAR 0 1
123729: ARRAY
123730: PUSH
123731: EMPTY
123732: EQUAL
123733: OR
123734: IFFALSE 123771
// begin for i in defenders do
123736: LD_ADDR_VAR 0 4
123740: PUSH
123741: LD_VAR 0 2
123745: PUSH
123746: FOR_IN
123747: IFFALSE 123760
// ComStop ( i ) ;
123749: LD_VAR 0 4
123753: PPUSH
123754: CALL_OW 141
123758: GO 123746
123760: POP
123761: POP
// defenders := [ ] ;
123762: LD_ADDR_VAR 0 2
123766: PUSH
123767: EMPTY
123768: ST_TO_ADDR
// exit ;
123769: GO 125220
// end ; for i in defenders do
123771: LD_ADDR_VAR 0 4
123775: PUSH
123776: LD_VAR 0 2
123780: PUSH
123781: FOR_IN
123782: IFFALSE 124680
// begin e := NearestUnitToUnit ( enemy , i ) ;
123784: LD_ADDR_VAR 0 13
123788: PUSH
123789: LD_VAR 0 21
123793: PPUSH
123794: LD_VAR 0 4
123798: PPUSH
123799: CALL_OW 74
123803: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
123804: LD_ADDR_VAR 0 7
123808: PUSH
123809: LD_EXP 80
123813: PUSH
123814: LD_VAR 0 1
123818: ARRAY
123819: PPUSH
123820: LD_INT 2
123822: PUSH
123823: LD_INT 30
123825: PUSH
123826: LD_INT 0
123828: PUSH
123829: EMPTY
123830: LIST
123831: LIST
123832: PUSH
123833: LD_INT 30
123835: PUSH
123836: LD_INT 1
123838: PUSH
123839: EMPTY
123840: LIST
123841: LIST
123842: PUSH
123843: EMPTY
123844: LIST
123845: LIST
123846: LIST
123847: PPUSH
123848: CALL_OW 72
123852: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
123853: LD_ADDR_VAR 0 16
123857: PUSH
123858: LD_VAR 0 7
123862: NOT
123863: PUSH
123864: LD_VAR 0 7
123868: PPUSH
123869: LD_INT 3
123871: PUSH
123872: LD_INT 24
123874: PUSH
123875: LD_INT 600
123877: PUSH
123878: EMPTY
123879: LIST
123880: LIST
123881: PUSH
123882: EMPTY
123883: LIST
123884: LIST
123885: PPUSH
123886: CALL_OW 72
123890: OR
123891: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
123892: LD_VAR 0 4
123896: PPUSH
123897: CALL_OW 247
123901: PUSH
123902: LD_INT 2
123904: DOUBLE
123905: EQUAL
123906: IFTRUE 123910
123908: GO 124306
123910: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
123911: LD_VAR 0 4
123915: PPUSH
123916: CALL_OW 256
123920: PUSH
123921: LD_INT 1000
123923: EQUAL
123924: PUSH
123925: LD_VAR 0 4
123929: PPUSH
123930: LD_VAR 0 13
123934: PPUSH
123935: CALL_OW 296
123939: PUSH
123940: LD_INT 40
123942: LESS
123943: PUSH
123944: LD_VAR 0 13
123948: PPUSH
123949: LD_EXP 105
123953: PUSH
123954: LD_VAR 0 1
123958: ARRAY
123959: PPUSH
123960: CALL_OW 308
123964: OR
123965: AND
123966: IFFALSE 124088
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
123968: LD_VAR 0 4
123972: PPUSH
123973: CALL_OW 262
123977: PUSH
123978: LD_INT 1
123980: EQUAL
123981: PUSH
123982: LD_VAR 0 4
123986: PPUSH
123987: CALL_OW 261
123991: PUSH
123992: LD_INT 30
123994: LESS
123995: AND
123996: PUSH
123997: LD_VAR 0 7
124001: AND
124002: IFFALSE 124072
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
124004: LD_VAR 0 4
124008: PPUSH
124009: LD_VAR 0 7
124013: PPUSH
124014: LD_VAR 0 4
124018: PPUSH
124019: CALL_OW 74
124023: PPUSH
124024: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
124028: LD_VAR 0 4
124032: PPUSH
124033: LD_VAR 0 7
124037: PPUSH
124038: LD_VAR 0 4
124042: PPUSH
124043: CALL_OW 74
124047: PPUSH
124048: CALL_OW 296
124052: PUSH
124053: LD_INT 6
124055: LESS
124056: IFFALSE 124070
// SetFuel ( i , 100 ) ;
124058: LD_VAR 0 4
124062: PPUSH
124063: LD_INT 100
124065: PPUSH
124066: CALL_OW 240
// end else
124070: GO 124086
// ComAttackUnit ( i , e ) ;
124072: LD_VAR 0 4
124076: PPUSH
124077: LD_VAR 0 13
124081: PPUSH
124082: CALL_OW 115
// end else
124086: GO 124189
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
124088: LD_VAR 0 13
124092: PPUSH
124093: LD_EXP 105
124097: PUSH
124098: LD_VAR 0 1
124102: ARRAY
124103: PPUSH
124104: CALL_OW 308
124108: NOT
124109: PUSH
124110: LD_VAR 0 4
124114: PPUSH
124115: LD_VAR 0 13
124119: PPUSH
124120: CALL_OW 296
124124: PUSH
124125: LD_INT 40
124127: GREATEREQUAL
124128: AND
124129: PUSH
124130: LD_VAR 0 4
124134: PPUSH
124135: CALL_OW 256
124139: PUSH
124140: LD_INT 650
124142: LESSEQUAL
124143: OR
124144: PUSH
124145: LD_VAR 0 4
124149: PPUSH
124150: LD_EXP 104
124154: PUSH
124155: LD_VAR 0 1
124159: ARRAY
124160: PPUSH
124161: CALL_OW 308
124165: NOT
124166: AND
124167: IFFALSE 124189
// ComMoveToArea ( i , mc_parking [ base ] ) ;
124169: LD_VAR 0 4
124173: PPUSH
124174: LD_EXP 104
124178: PUSH
124179: LD_VAR 0 1
124183: ARRAY
124184: PPUSH
124185: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
124189: LD_VAR 0 4
124193: PPUSH
124194: CALL_OW 256
124198: PUSH
124199: LD_INT 1000
124201: LESS
124202: PUSH
124203: LD_VAR 0 4
124207: PPUSH
124208: CALL_OW 263
124212: PUSH
124213: LD_INT 1
124215: EQUAL
124216: AND
124217: PUSH
124218: LD_VAR 0 4
124222: PPUSH
124223: CALL_OW 311
124227: AND
124228: PUSH
124229: LD_VAR 0 4
124233: PPUSH
124234: LD_EXP 104
124238: PUSH
124239: LD_VAR 0 1
124243: ARRAY
124244: PPUSH
124245: CALL_OW 308
124249: AND
124250: IFFALSE 124304
// begin mech := IsDrivenBy ( i ) ;
124252: LD_ADDR_VAR 0 9
124256: PUSH
124257: LD_VAR 0 4
124261: PPUSH
124262: CALL_OW 311
124266: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
124267: LD_VAR 0 9
124271: PPUSH
124272: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
124276: LD_VAR 0 9
124280: PPUSH
124281: LD_VAR 0 4
124285: PPUSH
124286: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
124290: LD_VAR 0 9
124294: PPUSH
124295: LD_VAR 0 4
124299: PPUSH
124300: CALL_OW 180
// end ; end ; unit_human :
124304: GO 124651
124306: LD_INT 1
124308: DOUBLE
124309: EQUAL
124310: IFTRUE 124314
124312: GO 124650
124314: POP
// begin b := IsInUnit ( i ) ;
124315: LD_ADDR_VAR 0 18
124319: PUSH
124320: LD_VAR 0 4
124324: PPUSH
124325: CALL_OW 310
124329: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
124330: LD_ADDR_VAR 0 19
124334: PUSH
124335: LD_VAR 0 18
124339: NOT
124340: PUSH
124341: LD_VAR 0 18
124345: PPUSH
124346: CALL_OW 266
124350: PUSH
124351: LD_INT 32
124353: PUSH
124354: LD_INT 31
124356: PUSH
124357: EMPTY
124358: LIST
124359: LIST
124360: IN
124361: OR
124362: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
124363: LD_VAR 0 18
124367: PPUSH
124368: CALL_OW 266
124372: PUSH
124373: LD_INT 5
124375: EQUAL
124376: PUSH
124377: LD_VAR 0 4
124381: PPUSH
124382: CALL_OW 257
124386: PUSH
124387: LD_INT 1
124389: PUSH
124390: LD_INT 2
124392: PUSH
124393: LD_INT 3
124395: PUSH
124396: LD_INT 4
124398: PUSH
124399: EMPTY
124400: LIST
124401: LIST
124402: LIST
124403: LIST
124404: IN
124405: AND
124406: IFFALSE 124443
// begin class := AllowSpecClass ( i ) ;
124408: LD_ADDR_VAR 0 20
124412: PUSH
124413: LD_VAR 0 4
124417: PPUSH
124418: CALL 55598 0 1
124422: ST_TO_ADDR
// if class then
124423: LD_VAR 0 20
124427: IFFALSE 124443
// ComChangeProfession ( i , class ) ;
124429: LD_VAR 0 4
124433: PPUSH
124434: LD_VAR 0 20
124438: PPUSH
124439: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
124443: LD_VAR 0 16
124447: PUSH
124448: LD_VAR 0 2
124452: PPUSH
124453: LD_INT 21
124455: PUSH
124456: LD_INT 2
124458: PUSH
124459: EMPTY
124460: LIST
124461: LIST
124462: PPUSH
124463: CALL_OW 72
124467: PUSH
124468: LD_INT 1
124470: LESSEQUAL
124471: OR
124472: PUSH
124473: LD_VAR 0 19
124477: AND
124478: PUSH
124479: LD_VAR 0 4
124483: PUSH
124484: LD_VAR 0 17
124488: IN
124489: NOT
124490: AND
124491: IFFALSE 124584
// begin if b then
124493: LD_VAR 0 18
124497: IFFALSE 124546
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
124499: LD_VAR 0 18
124503: PPUSH
124504: LD_VAR 0 21
124508: PPUSH
124509: LD_VAR 0 18
124513: PPUSH
124514: CALL_OW 74
124518: PPUSH
124519: CALL_OW 296
124523: PUSH
124524: LD_INT 10
124526: LESS
124527: PUSH
124528: LD_VAR 0 18
124532: PPUSH
124533: CALL_OW 461
124537: PUSH
124538: LD_INT 7
124540: NONEQUAL
124541: AND
124542: IFFALSE 124546
// continue ;
124544: GO 123781
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
124546: LD_ADDR_VAR 0 17
124550: PUSH
124551: LD_VAR 0 17
124555: PPUSH
124556: LD_VAR 0 17
124560: PUSH
124561: LD_INT 1
124563: PLUS
124564: PPUSH
124565: LD_VAR 0 4
124569: PPUSH
124570: CALL_OW 1
124574: ST_TO_ADDR
// ComExitBuilding ( i ) ;
124575: LD_VAR 0 4
124579: PPUSH
124580: CALL_OW 122
// end ; if sold_defenders then
124584: LD_VAR 0 17
124588: IFFALSE 124648
// if i in sold_defenders then
124590: LD_VAR 0 4
124594: PUSH
124595: LD_VAR 0 17
124599: IN
124600: IFFALSE 124648
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
124602: LD_VAR 0 4
124606: PPUSH
124607: CALL_OW 314
124611: NOT
124612: PUSH
124613: LD_VAR 0 4
124617: PPUSH
124618: LD_VAR 0 13
124622: PPUSH
124623: CALL_OW 296
124627: PUSH
124628: LD_INT 30
124630: LESS
124631: AND
124632: IFFALSE 124648
// ComAttackUnit ( i , e ) ;
124634: LD_VAR 0 4
124638: PPUSH
124639: LD_VAR 0 13
124643: PPUSH
124644: CALL_OW 115
// end ; end ; end ;
124648: GO 124651
124650: POP
// if IsDead ( i ) then
124651: LD_VAR 0 4
124655: PPUSH
124656: CALL_OW 301
124660: IFFALSE 124678
// defenders := defenders diff i ;
124662: LD_ADDR_VAR 0 2
124666: PUSH
124667: LD_VAR 0 2
124671: PUSH
124672: LD_VAR 0 4
124676: DIFF
124677: ST_TO_ADDR
// end ;
124678: GO 123781
124680: POP
124681: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
124682: LD_VAR 0 21
124686: NOT
124687: PUSH
124688: LD_VAR 0 2
124692: NOT
124693: OR
124694: PUSH
124695: LD_EXP 80
124699: PUSH
124700: LD_VAR 0 1
124704: ARRAY
124705: NOT
124706: OR
124707: IFFALSE 123685
// MC_Reset ( base , 18 ) ;
124709: LD_VAR 0 1
124713: PPUSH
124714: LD_INT 18
124716: PPUSH
124717: CALL 27189 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
124721: LD_ADDR_VAR 0 2
124725: PUSH
124726: LD_VAR 0 2
124730: PUSH
124731: LD_VAR 0 2
124735: PPUSH
124736: LD_INT 2
124738: PUSH
124739: LD_INT 25
124741: PUSH
124742: LD_INT 1
124744: PUSH
124745: EMPTY
124746: LIST
124747: LIST
124748: PUSH
124749: LD_INT 25
124751: PUSH
124752: LD_INT 5
124754: PUSH
124755: EMPTY
124756: LIST
124757: LIST
124758: PUSH
124759: LD_INT 25
124761: PUSH
124762: LD_INT 8
124764: PUSH
124765: EMPTY
124766: LIST
124767: LIST
124768: PUSH
124769: LD_INT 25
124771: PUSH
124772: LD_INT 9
124774: PUSH
124775: EMPTY
124776: LIST
124777: LIST
124778: PUSH
124779: EMPTY
124780: LIST
124781: LIST
124782: LIST
124783: LIST
124784: LIST
124785: PPUSH
124786: CALL_OW 72
124790: DIFF
124791: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
124792: LD_VAR 0 21
124796: NOT
124797: PUSH
124798: LD_VAR 0 2
124802: PPUSH
124803: LD_INT 21
124805: PUSH
124806: LD_INT 2
124808: PUSH
124809: EMPTY
124810: LIST
124811: LIST
124812: PPUSH
124813: CALL_OW 72
124817: AND
124818: IFFALSE 125156
// begin tmp := FilterByTag ( defenders , 19 ) ;
124820: LD_ADDR_VAR 0 11
124824: PUSH
124825: LD_VAR 0 2
124829: PPUSH
124830: LD_INT 19
124832: PPUSH
124833: CALL 89092 0 2
124837: ST_TO_ADDR
// if tmp then
124838: LD_VAR 0 11
124842: IFFALSE 124912
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
124844: LD_ADDR_VAR 0 11
124848: PUSH
124849: LD_VAR 0 11
124853: PPUSH
124854: LD_INT 25
124856: PUSH
124857: LD_INT 3
124859: PUSH
124860: EMPTY
124861: LIST
124862: LIST
124863: PPUSH
124864: CALL_OW 72
124868: ST_TO_ADDR
// if tmp then
124869: LD_VAR 0 11
124873: IFFALSE 124912
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
124875: LD_ADDR_EXP 92
124879: PUSH
124880: LD_EXP 92
124884: PPUSH
124885: LD_VAR 0 1
124889: PPUSH
124890: LD_EXP 92
124894: PUSH
124895: LD_VAR 0 1
124899: ARRAY
124900: PUSH
124901: LD_VAR 0 11
124905: UNION
124906: PPUSH
124907: CALL_OW 1
124911: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
124912: LD_VAR 0 1
124916: PPUSH
124917: LD_INT 19
124919: PPUSH
124920: CALL 27189 0 2
// repeat wait ( 0 0$1 ) ;
124924: LD_INT 35
124926: PPUSH
124927: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
124931: LD_EXP 80
124935: PUSH
124936: LD_VAR 0 1
124940: ARRAY
124941: NOT
124942: PUSH
124943: LD_EXP 80
124947: PUSH
124948: LD_VAR 0 1
124952: ARRAY
124953: PUSH
124954: EMPTY
124955: EQUAL
124956: OR
124957: IFFALSE 124994
// begin for i in defenders do
124959: LD_ADDR_VAR 0 4
124963: PUSH
124964: LD_VAR 0 2
124968: PUSH
124969: FOR_IN
124970: IFFALSE 124983
// ComStop ( i ) ;
124972: LD_VAR 0 4
124976: PPUSH
124977: CALL_OW 141
124981: GO 124969
124983: POP
124984: POP
// defenders := [ ] ;
124985: LD_ADDR_VAR 0 2
124989: PUSH
124990: EMPTY
124991: ST_TO_ADDR
// exit ;
124992: GO 125220
// end ; for i in defenders do
124994: LD_ADDR_VAR 0 4
124998: PUSH
124999: LD_VAR 0 2
125003: PUSH
125004: FOR_IN
125005: IFFALSE 125094
// begin if not IsInArea ( i , mc_parking [ base ] ) then
125007: LD_VAR 0 4
125011: PPUSH
125012: LD_EXP 104
125016: PUSH
125017: LD_VAR 0 1
125021: ARRAY
125022: PPUSH
125023: CALL_OW 308
125027: NOT
125028: IFFALSE 125052
// ComMoveToArea ( i , mc_parking [ base ] ) else
125030: LD_VAR 0 4
125034: PPUSH
125035: LD_EXP 104
125039: PUSH
125040: LD_VAR 0 1
125044: ARRAY
125045: PPUSH
125046: CALL_OW 113
125050: GO 125092
// if GetControl ( i ) = control_manual then
125052: LD_VAR 0 4
125056: PPUSH
125057: CALL_OW 263
125061: PUSH
125062: LD_INT 1
125064: EQUAL
125065: IFFALSE 125092
// if IsDrivenBy ( i ) then
125067: LD_VAR 0 4
125071: PPUSH
125072: CALL_OW 311
125076: IFFALSE 125092
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
125078: LD_VAR 0 4
125082: PPUSH
125083: CALL_OW 311
125087: PPUSH
125088: CALL_OW 121
// end ;
125092: GO 125004
125094: POP
125095: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
125096: LD_VAR 0 2
125100: PPUSH
125101: LD_INT 95
125103: PUSH
125104: LD_EXP 104
125108: PUSH
125109: LD_VAR 0 1
125113: ARRAY
125114: PUSH
125115: EMPTY
125116: LIST
125117: LIST
125118: PPUSH
125119: CALL_OW 72
125123: PUSH
125124: LD_VAR 0 2
125128: EQUAL
125129: PUSH
125130: LD_EXP 103
125134: PUSH
125135: LD_VAR 0 1
125139: ARRAY
125140: OR
125141: PUSH
125142: LD_EXP 80
125146: PUSH
125147: LD_VAR 0 1
125151: ARRAY
125152: NOT
125153: OR
125154: IFFALSE 124924
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
125156: LD_ADDR_EXP 102
125160: PUSH
125161: LD_EXP 102
125165: PPUSH
125166: LD_VAR 0 1
125170: PPUSH
125171: LD_VAR 0 2
125175: PPUSH
125176: LD_INT 21
125178: PUSH
125179: LD_INT 2
125181: PUSH
125182: EMPTY
125183: LIST
125184: LIST
125185: PPUSH
125186: CALL_OW 72
125190: PPUSH
125191: CALL_OW 1
125195: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
125196: LD_VAR 0 1
125200: PPUSH
125201: LD_INT 19
125203: PPUSH
125204: CALL 27189 0 2
// MC_Reset ( base , 20 ) ;
125208: LD_VAR 0 1
125212: PPUSH
125213: LD_INT 20
125215: PPUSH
125216: CALL 27189 0 2
// end ; end_of_file
125220: LD_VAR 0 3
125224: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
125225: LD_VAR 0 1
125229: PUSH
125230: LD_INT 200
125232: DOUBLE
125233: GREATEREQUAL
125234: IFFALSE 125242
125236: LD_INT 299
125238: DOUBLE
125239: LESSEQUAL
125240: IFTRUE 125244
125242: GO 125276
125244: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
125245: LD_VAR 0 1
125249: PPUSH
125250: LD_VAR 0 2
125254: PPUSH
125255: LD_VAR 0 3
125259: PPUSH
125260: LD_VAR 0 4
125264: PPUSH
125265: LD_VAR 0 5
125269: PPUSH
125270: CALL 113225 0 5
125274: GO 125353
125276: LD_INT 300
125278: DOUBLE
125279: GREATEREQUAL
125280: IFFALSE 125288
125282: LD_INT 399
125284: DOUBLE
125285: LESSEQUAL
125286: IFTRUE 125290
125288: GO 125352
125290: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
125291: LD_VAR 0 1
125295: PPUSH
125296: LD_VAR 0 2
125300: PPUSH
125301: LD_VAR 0 3
125305: PPUSH
125306: LD_VAR 0 4
125310: PPUSH
125311: LD_VAR 0 5
125315: PPUSH
125316: LD_VAR 0 6
125320: PPUSH
125321: LD_VAR 0 7
125325: PPUSH
125326: LD_VAR 0 8
125330: PPUSH
125331: LD_VAR 0 9
125335: PPUSH
125336: LD_VAR 0 10
125340: PPUSH
125341: LD_VAR 0 11
125345: PPUSH
125346: CALL 109133 0 11
125350: GO 125353
125352: POP
// end ;
125353: PPOPN 11
125355: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
125356: LD_VAR 0 1
125360: PPUSH
125361: LD_VAR 0 2
125365: PPUSH
125366: LD_VAR 0 3
125370: PPUSH
125371: LD_VAR 0 4
125375: PPUSH
125376: LD_VAR 0 5
125380: PPUSH
125381: CALL 112610 0 5
// end ; end_of_file
125385: PPOPN 5
125387: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
125388: LD_VAR 0 1
125392: PPUSH
125393: LD_VAR 0 2
125397: PPUSH
125398: LD_VAR 0 3
125402: PPUSH
125403: LD_VAR 0 4
125407: PPUSH
125408: LD_VAR 0 5
125412: PPUSH
125413: LD_VAR 0 6
125417: PPUSH
125418: CALL 96785 0 6
// end ;
125422: PPOPN 6
125424: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
125425: LD_INT 0
125427: PPUSH
// begin if not units then
125428: LD_VAR 0 1
125432: NOT
125433: IFFALSE 125437
// exit ;
125435: GO 125437
// end ;
125437: PPOPN 7
125439: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
125440: CALL 96672 0 0
// end ;
125444: PPOPN 1
125446: END
