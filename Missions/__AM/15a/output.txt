// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 20634 0 0
// InitMacro ;
  19: CALL 20802 0 0
// InitNature ;
  23: CALL 17304 0 0
// InitArtifact ;
  27: CALL 17917 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 4625 0 0
// PrepareAlliance ;
  48: CALL 1421 0 0
// PrepareArabian ;
  52: CALL 6393 0 0
// PrepareRussian ;
  56: CALL 8378 0 0
// PrepareLegion ;
  60: CALL 6821 0 0
// Action ;
  64: CALL 10931 0 0
// MC_Start ( ) ;
  68: CALL 22967 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ;
 212: LD_VAR 0 1
 216: RET
// export function CustomInitMacro ( ) ; begin
 217: LD_INT 0
 219: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 220: LD_ADDR_EXP 117
 224: PUSH
 225: LD_INT 26
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 4
 233: PUSH
 234: LD_INT 8
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: LIST
 242: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 243: LD_ADDR_EXP 118
 247: PUSH
 248: LD_INT 27
 250: PUSH
 251: LD_INT 2
 253: PUSH
 254: LD_INT 3
 256: PUSH
 257: LD_INT 7
 259: PUSH
 260: EMPTY
 261: LIST
 262: LIST
 263: LIST
 264: LIST
 265: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_INT 6
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: LD_INT 9
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: LIST
 282: PUSH
 283: LD_OWVAR 67
 287: ARRAY
 288: PPUSH
 289: LD_INT 28
 291: PPUSH
 292: CALL 44355 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 10
 301: PUSH
 302: LD_INT 11
 304: PUSH
 305: LD_INT 13
 307: PUSH
 308: LD_INT 15
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: LIST
 316: PPUSH
 317: CALL 45415 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 29
 326: PUSH
 327: EMPTY
 328: LIST
 329: PPUSH
 330: CALL 45508 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 334: LD_ADDR_EXP 122
 338: PUSH
 339: LD_EXP 122
 343: PPUSH
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 22
 349: PUSH
 350: LD_INT 2
 352: PUSH
 353: EMPTY
 354: LIST
 355: LIST
 356: PUSH
 357: LD_INT 25
 359: PUSH
 360: LD_INT 15
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL_OW 69
 375: PPUSH
 376: CALL_OW 1
 380: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 13
 386: PUSH
 387: LD_INT 2
 389: PUSH
 390: LD_INT 1
 392: PUSH
 393: LD_INT 31
 395: PUSH
 396: EMPTY
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: PUSH
 402: LD_INT 13
 404: PUSH
 405: LD_INT 2
 407: PUSH
 408: LD_INT 1
 410: PUSH
 411: LD_INT 31
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: LIST
 419: PUSH
 420: LD_INT 13
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 1
 428: PUSH
 429: LD_INT 28
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_INT 13
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 1
 446: PUSH
 447: LD_INT 28
 449: PUSH
 450: EMPTY
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_INT 13
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 28
 467: PUSH
 468: EMPTY
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: PUSH
 474: LD_INT 13
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 28
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_INT 13
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 2
 500: PUSH
 501: LD_EXP 78
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PPUSH
 521: CALL 44673 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 525: LD_INT 1
 527: PPUSH
 528: LD_INT 4
 530: PPUSH
 531: CALL 44858 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 10
 540: PUSH
 541: LD_INT 11
 543: PUSH
 544: LD_INT 12
 546: PUSH
 547: LD_INT 14
 549: PUSH
 550: EMPTY
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 45415 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 14
 565: PUSH
 566: EMPTY
 567: LIST
 568: PPUSH
 569: CALL 45508 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 21
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 51
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 22
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 3
 602: PUSH
 603: LD_INT 52
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 22
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 3
 620: PUSH
 621: LD_INT 52
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: LD_INT 24
 632: PUSH
 633: LD_INT 3
 635: PUSH
 636: LD_INT 3
 638: PUSH
 639: LD_INT 47
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: LIST
 646: LIST
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: LD_INT 3
 653: PUSH
 654: LD_INT 3
 656: PUSH
 657: LD_INT 47
 659: PUSH
 660: EMPTY
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: PUSH
 666: LD_INT 24
 668: PUSH
 669: LD_INT 3
 671: PUSH
 672: LD_INT 3
 674: PUSH
 675: LD_INT 47
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: LD_INT 3
 689: PUSH
 690: LD_INT 3
 692: PUSH
 693: LD_INT 47
 695: PUSH
 696: EMPTY
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_INT 24
 704: PUSH
 705: LD_INT 3
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 47
 713: PUSH
 714: EMPTY
 715: LIST
 716: LIST
 717: LIST
 718: LIST
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PPUSH
 730: CALL 44673 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 734: LD_INT 2
 736: PPUSH
 737: LD_INT 5
 739: PPUSH
 740: CALL 44858 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 744: LD_INT 2
 746: PPUSH
 747: LD_INT 0
 749: PPUSH
 750: CALL 45288 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 754: LD_INT 3
 756: PPUSH
 757: LD_INT 10
 759: PUSH
 760: LD_INT 12
 762: PUSH
 763: LD_INT 15
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_OWVAR 67
 775: ARRAY
 776: PPUSH
 777: LD_INT 24
 779: PPUSH
 780: CALL 44355 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 10
 789: PUSH
 790: LD_INT 11
 792: PUSH
 793: LD_INT 13
 795: PUSH
 796: LD_INT 15
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL 45415 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 809: LD_INT 3
 811: PPUSH
 812: LD_INT 13
 814: PUSH
 815: EMPTY
 816: LIST
 817: PPUSH
 818: CALL 45508 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 822: LD_ADDR_EXP 122
 826: PUSH
 827: LD_EXP 122
 831: PPUSH
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 22
 837: PUSH
 838: LD_INT 8
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 25
 847: PUSH
 848: LD_INT 15
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL_OW 69
 863: PPUSH
 864: CALL_OW 1
 868: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 869: LD_INT 3
 871: PPUSH
 872: LD_INT 13
 874: PUSH
 875: LD_INT 2
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 31
 883: PUSH
 884: EMPTY
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 13
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 1
 898: PUSH
 899: LD_INT 31
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_INT 13
 910: PUSH
 911: LD_INT 3
 913: PUSH
 914: LD_INT 2
 916: PUSH
 917: LD_INT 32
 919: PUSH
 920: EMPTY
 921: LIST
 922: LIST
 923: LIST
 924: LIST
 925: PUSH
 926: LD_INT 14
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 1
 934: PUSH
 935: LD_INT 28
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_INT 14
 946: PUSH
 947: LD_INT 1
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 28
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: LIST
 960: LIST
 961: PUSH
 962: LD_INT 14
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 28
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: PUSH
 980: LD_INT 14
 982: PUSH
 983: LD_INT 1
 985: PUSH
 986: LD_INT 1
 988: PUSH
 989: LD_INT 28
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: PUSH
 998: LD_INT 14
1000: PUSH
1001: LD_INT 1
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_EXP 78
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL 44673 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1032: LD_INT 3
1034: PPUSH
1035: LD_INT 4
1037: PPUSH
1038: CALL 44858 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1042: LD_INT 4
1044: PPUSH
1045: LD_INT 10
1047: PUSH
1048: LD_INT 12
1050: PUSH
1051: LD_INT 11
1053: PUSH
1054: LD_INT 15
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PPUSH
1063: CALL 45415 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1067: LD_INT 4
1069: PPUSH
1070: LD_INT 33
1072: PUSH
1073: EMPTY
1074: LIST
1075: PPUSH
1076: CALL 45508 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1080: LD_INT 4
1082: PPUSH
1083: LD_INT 5
1085: PUSH
1086: LD_INT 6
1088: PUSH
1089: LD_INT 7
1091: PUSH
1092: LD_INT 9
1094: PUSH
1095: LD_INT 10
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: PPUSH
1105: CALL 45826 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1109: LD_INT 4
1111: PPUSH
1112: LD_INT 54
1114: PPUSH
1115: LD_INT 85
1117: PPUSH
1118: LD_INT 2
1120: PPUSH
1121: LD_INT 25
1123: PUSH
1124: LD_INT 16
1126: PUSH
1127: LD_INT 17
1129: PUSH
1130: LD_INT 18
1132: PUSH
1133: LD_INT 22
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: PPUSH
1143: CALL 45620 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1147: LD_INT 4
1149: PPUSH
1150: LD_INT 5
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: LD_INT 1
1158: PUSH
1159: LD_INT 7
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 5
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 1
1176: PUSH
1177: LD_INT 6
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 5
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 7
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 5
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 6
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 5
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 3
1230: PUSH
1231: LD_INT 12
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 3
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: LD_INT 3
1248: PUSH
1249: LD_INT 13
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 44673 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 4
1275: PPUSH
1276: CALL 44858 0 2
// MC_SetTame ( 4 , powellApe ) ;
1280: LD_INT 4
1282: PPUSH
1283: LD_INT 11
1285: PPUSH
1286: CALL 45239 0 2
// end ;
1290: LD_VAR 0 1
1294: RET
// every 0 0$1 trigger debug do var i ;
1295: LD_EXP 1
1299: IFFALSE 1397
1301: GO 1303
1303: DISABLE
1304: LD_INT 0
1306: PPUSH
// begin enable ;
1307: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1308: LD_ADDR_VAR 0 1
1312: PUSH
1313: LD_INT 22
1315: PUSH
1316: LD_INT 7
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 2
1325: PUSH
1326: LD_INT 21
1328: PUSH
1329: LD_INT 1
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: PUSH
1336: LD_INT 21
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 3
1353: PUSH
1354: LD_INT 24
1356: PUSH
1357: LD_INT 1000
1359: PUSH
1360: EMPTY
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: PUSH
1378: FOR_IN
1379: IFFALSE 1395
// SetLives ( i , 1000 ) ;
1381: LD_VAR 0 1
1385: PPUSH
1386: LD_INT 1000
1388: PPUSH
1389: CALL_OW 234
1393: GO 1378
1395: POP
1396: POP
// end ;
1397: PPOPN 1
1399: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1400: LD_EXP 16
1404: PUSH
1405: LD_INT 5
1407: GREATEREQUAL
1408: IFFALSE 1420
1410: GO 1412
1412: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1413: LD_STRING ACH_ARTIFACT
1415: PPUSH
1416: CALL_OW 543
1420: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1421: LD_INT 0
1423: PPUSH
1424: PPUSH
1425: PPUSH
1426: PPUSH
1427: PPUSH
// uc_side := 7 ;
1428: LD_ADDR_OWVAR 20
1432: PUSH
1433: LD_INT 7
1435: ST_TO_ADDR
// tmp := [ ] ;
1436: LD_ADDR_VAR 0 5
1440: PUSH
1441: EMPTY
1442: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1443: LD_ADDR_EXP 17
1447: PUSH
1448: LD_STRING JMM
1450: PPUSH
1451: LD_EXP 1
1455: NOT
1456: PPUSH
1457: LD_STRING 14a_
1459: PPUSH
1460: CALL 51118 0 3
1464: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1465: LD_ADDR_EXP 49
1469: PUSH
1470: LD_STRING Burlak
1472: PPUSH
1473: LD_EXP 1
1477: NOT
1478: PPUSH
1479: LD_STRING 14a_
1481: PPUSH
1482: CALL 51118 0 3
1486: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1487: LD_ADDR_EXP 32
1491: PUSH
1492: LD_STRING Joan
1494: PPUSH
1495: LD_EXP 1
1499: NOT
1500: PPUSH
1501: LD_STRING 13a_
1503: PPUSH
1504: CALL 51118 0 3
1508: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1509: LD_ADDR_EXP 18
1513: PUSH
1514: LD_STRING Roth
1516: PPUSH
1517: LD_EXP 1
1521: NOT
1522: PPUSH
1523: LD_STRING 13a_
1525: PPUSH
1526: CALL 51118 0 3
1530: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1531: LD_ADDR_EXP 35
1535: PUSH
1536: LD_STRING Gossudarov
1538: PPUSH
1539: LD_EXP 1
1543: NOT
1544: PPUSH
1545: LD_STRING 13a_
1547: PPUSH
1548: CALL 51118 0 3
1552: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1553: LD_ADDR_EXP 23
1557: PUSH
1558: LD_STRING Denis
1560: PPUSH
1561: LD_EXP 1
1565: NOT
1566: PPUSH
1567: LD_STRING 13a_
1569: PPUSH
1570: CALL 51118 0 3
1574: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1575: LD_ADDR_EXP 33
1579: PUSH
1580: LD_STRING DeltaDoctor
1582: PPUSH
1583: LD_EXP 1
1587: NOT
1588: PPUSH
1589: LD_STRING 13a_
1591: PPUSH
1592: CALL 51118 0 3
1596: ST_TO_ADDR
// if DeltaDoctor then
1597: LD_EXP 33
1601: IFFALSE 1619
// tmp := tmp ^ DeltaDoctor ;
1603: LD_ADDR_VAR 0 5
1607: PUSH
1608: LD_VAR 0 5
1612: PUSH
1613: LD_EXP 33
1617: ADD
1618: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1619: LD_ADDR_EXP 31
1623: PUSH
1624: LD_STRING Simms
1626: PPUSH
1627: LD_EXP 1
1631: NOT
1632: PPUSH
1633: LD_STRING 13a_
1635: PPUSH
1636: CALL 51118 0 3
1640: ST_TO_ADDR
// if Simms then
1641: LD_EXP 31
1645: IFFALSE 1663
// tmp := tmp ^ Simms ;
1647: LD_ADDR_VAR 0 5
1651: PUSH
1652: LD_VAR 0 5
1656: PUSH
1657: LD_EXP 31
1661: ADD
1662: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1663: LD_ADDR_EXP 29
1667: PUSH
1668: LD_STRING Frank
1670: PPUSH
1671: LD_EXP 1
1675: NOT
1676: PPUSH
1677: LD_STRING 13a_
1679: PPUSH
1680: CALL 51118 0 3
1684: ST_TO_ADDR
// if Frank then
1685: LD_EXP 29
1689: IFFALSE 1707
// tmp := tmp ^ Frank ;
1691: LD_ADDR_VAR 0 5
1695: PUSH
1696: LD_VAR 0 5
1700: PUSH
1701: LD_EXP 29
1705: ADD
1706: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1707: LD_ADDR_EXP 36
1711: PUSH
1712: LD_STRING Kirilenkova
1714: PPUSH
1715: LD_EXP 1
1719: NOT
1720: PPUSH
1721: LD_STRING 13a_
1723: PPUSH
1724: CALL 51118 0 3
1728: ST_TO_ADDR
// if Kirilenkova then
1729: LD_EXP 36
1733: IFFALSE 1751
// tmp := tmp ^ Kirilenkova ;
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 5
1744: PUSH
1745: LD_EXP 36
1749: ADD
1750: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1751: LD_ADDR_EXP 37
1755: PUSH
1756: LD_STRING Titov
1758: PPUSH
1759: LD_EXP 1
1763: NOT
1764: PPUSH
1765: LD_STRING 13a_
1767: PPUSH
1768: CALL 51118 0 3
1772: ST_TO_ADDR
// if Titov then
1773: LD_EXP 37
1777: IFFALSE 1795
// tmp := tmp ^ Titov ;
1779: LD_ADDR_VAR 0 5
1783: PUSH
1784: LD_VAR 0 5
1788: PUSH
1789: LD_EXP 37
1793: ADD
1794: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1795: LD_ADDR_EXP 38
1799: PUSH
1800: LD_STRING Fadeev
1802: PPUSH
1803: LD_EXP 1
1807: NOT
1808: PPUSH
1809: LD_STRING 13a_
1811: PPUSH
1812: CALL 51118 0 3
1816: ST_TO_ADDR
// if Fadeev then
1817: LD_EXP 38
1821: IFFALSE 1839
// tmp := tmp ^ Fadeev ;
1823: LD_ADDR_VAR 0 5
1827: PUSH
1828: LD_VAR 0 5
1832: PUSH
1833: LD_EXP 38
1837: ADD
1838: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1839: LD_ADDR_EXP 39
1843: PUSH
1844: LD_STRING Dolgov
1846: PPUSH
1847: LD_EXP 1
1851: NOT
1852: PPUSH
1853: LD_STRING 13a_
1855: PPUSH
1856: CALL 51118 0 3
1860: ST_TO_ADDR
// if Dolgov then
1861: LD_EXP 39
1865: IFFALSE 1883
// tmp := tmp ^ Dolgov ;
1867: LD_ADDR_VAR 0 5
1871: PUSH
1872: LD_VAR 0 5
1876: PUSH
1877: LD_EXP 39
1881: ADD
1882: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1883: LD_ADDR_EXP 40
1887: PUSH
1888: LD_STRING Petrosyan
1890: PPUSH
1891: LD_EXP 1
1895: NOT
1896: PPUSH
1897: LD_STRING 13a_
1899: PPUSH
1900: CALL 51118 0 3
1904: ST_TO_ADDR
// if Petrosyan then
1905: LD_EXP 40
1909: IFFALSE 1927
// tmp := tmp ^ Petrosyan ;
1911: LD_ADDR_VAR 0 5
1915: PUSH
1916: LD_VAR 0 5
1920: PUSH
1921: LD_EXP 40
1925: ADD
1926: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1927: LD_ADDR_EXP 41
1931: PUSH
1932: LD_STRING Scholtze
1934: PPUSH
1935: LD_EXP 1
1939: NOT
1940: PPUSH
1941: LD_STRING 13a_
1943: PPUSH
1944: CALL 51118 0 3
1948: ST_TO_ADDR
// if Scholtze then
1949: LD_EXP 41
1953: IFFALSE 1971
// tmp := tmp ^ Scholtze ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_VAR 0 5
1964: PUSH
1965: LD_EXP 41
1969: ADD
1970: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1971: LD_ADDR_EXP 42
1975: PUSH
1976: LD_STRING Oblukov
1978: PPUSH
1979: LD_EXP 1
1983: NOT
1984: PPUSH
1985: LD_STRING 13a_
1987: PPUSH
1988: CALL 51118 0 3
1992: ST_TO_ADDR
// if Oblukov then
1993: LD_EXP 42
1997: IFFALSE 2015
// tmp := tmp ^ Oblukov ;
1999: LD_ADDR_VAR 0 5
2003: PUSH
2004: LD_VAR 0 5
2008: PUSH
2009: LD_EXP 42
2013: ADD
2014: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2015: LD_ADDR_EXP 43
2019: PUSH
2020: LD_STRING Kapitsova
2022: PPUSH
2023: LD_EXP 1
2027: NOT
2028: PPUSH
2029: LD_STRING 13a_
2031: PPUSH
2032: CALL 51118 0 3
2036: ST_TO_ADDR
// if Kapitsova then
2037: LD_EXP 43
2041: IFFALSE 2059
// tmp := tmp ^ Kapitsova ;
2043: LD_ADDR_VAR 0 5
2047: PUSH
2048: LD_VAR 0 5
2052: PUSH
2053: LD_EXP 43
2057: ADD
2058: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2059: LD_ADDR_EXP 44
2063: PUSH
2064: LD_STRING Lipshchin
2066: PPUSH
2067: LD_EXP 1
2071: NOT
2072: PPUSH
2073: LD_STRING 13a_
2075: PPUSH
2076: CALL 51118 0 3
2080: ST_TO_ADDR
// if Lipshchin then
2081: LD_EXP 44
2085: IFFALSE 2103
// tmp := tmp ^ Lipshchin ;
2087: LD_ADDR_VAR 0 5
2091: PUSH
2092: LD_VAR 0 5
2096: PUSH
2097: LD_EXP 44
2101: ADD
2102: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2103: LD_ADDR_EXP 45
2107: PUSH
2108: LD_STRING Petrovova
2110: PPUSH
2111: LD_EXP 1
2115: NOT
2116: PPUSH
2117: LD_STRING 13a_
2119: PPUSH
2120: CALL 51118 0 3
2124: ST_TO_ADDR
// if Petrovova then
2125: LD_EXP 45
2129: IFFALSE 2147
// tmp := tmp ^ Petrovova ;
2131: LD_ADDR_VAR 0 5
2135: PUSH
2136: LD_VAR 0 5
2140: PUSH
2141: LD_EXP 45
2145: ADD
2146: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2147: LD_ADDR_EXP 46
2151: PUSH
2152: LD_STRING Kovalyuk
2154: PPUSH
2155: LD_EXP 1
2159: NOT
2160: PPUSH
2161: LD_STRING 13a_
2163: PPUSH
2164: CALL 51118 0 3
2168: ST_TO_ADDR
// if Kovalyuk then
2169: LD_EXP 46
2173: IFFALSE 2191
// tmp := tmp ^ Kovalyuk ;
2175: LD_ADDR_VAR 0 5
2179: PUSH
2180: LD_VAR 0 5
2184: PUSH
2185: LD_EXP 46
2189: ADD
2190: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2191: LD_ADDR_EXP 47
2195: PUSH
2196: LD_STRING Kuzmov
2198: PPUSH
2199: LD_EXP 1
2203: NOT
2204: PPUSH
2205: LD_STRING 13a_
2207: PPUSH
2208: CALL 51118 0 3
2212: ST_TO_ADDR
// if Kuzmov then
2213: LD_EXP 47
2217: IFFALSE 2235
// tmp := tmp ^ Kuzmov ;
2219: LD_ADDR_VAR 0 5
2223: PUSH
2224: LD_VAR 0 5
2228: PUSH
2229: LD_EXP 47
2233: ADD
2234: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: LD_STRING Karamazov
2242: PPUSH
2243: LD_EXP 1
2247: NOT
2248: PPUSH
2249: LD_STRING 13a_
2251: PPUSH
2252: CALL 51118 0 3
2256: ST_TO_ADDR
// if Karamazov then
2257: LD_EXP 48
2261: IFFALSE 2279
// tmp := tmp ^ Karamazov ;
2263: LD_ADDR_VAR 0 5
2267: PUSH
2268: LD_VAR 0 5
2272: PUSH
2273: LD_EXP 48
2277: ADD
2278: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2279: LD_ADDR_EXP 50
2283: PUSH
2284: LD_STRING Belkov
2286: PPUSH
2287: LD_EXP 1
2291: NOT
2292: PPUSH
2293: LD_STRING 13a_
2295: PPUSH
2296: CALL 51118 0 3
2300: ST_TO_ADDR
// if Belkov then
2301: LD_EXP 50
2305: IFFALSE 2323
// tmp := tmp ^ Belkov ;
2307: LD_ADDR_VAR 0 5
2311: PUSH
2312: LD_VAR 0 5
2316: PUSH
2317: LD_EXP 50
2321: ADD
2322: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2323: LD_ADDR_EXP 51
2327: PUSH
2328: LD_STRING Gnyevko
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_STRING 13a_
2339: PPUSH
2340: CALL 51118 0 3
2344: ST_TO_ADDR
// if Gnyevko then
2345: LD_EXP 51
2349: IFFALSE 2367
// tmp := tmp ^ Gnyevko ;
2351: LD_ADDR_VAR 0 5
2355: PUSH
2356: LD_VAR 0 5
2360: PUSH
2361: LD_EXP 51
2365: ADD
2366: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2367: LD_ADDR_EXP 34
2371: PUSH
2372: LD_STRING Coonie
2374: PPUSH
2375: CALL_OW 25
2379: ST_TO_ADDR
// if not Lisa then
2380: LD_EXP 19
2384: NOT
2385: IFFALSE 2431
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2387: LD_ADDR_EXP 19
2391: PUSH
2392: LD_STRING Lisa
2394: PPUSH
2395: LD_EXP 1
2399: NOT
2400: PPUSH
2401: LD_STRING 13a_
2403: PPUSH
2404: CALL 51118 0 3
2408: ST_TO_ADDR
// if Lisa then
2409: LD_EXP 19
2413: IFFALSE 2431
// tmp := tmp ^ Lisa ;
2415: LD_ADDR_VAR 0 5
2419: PUSH
2420: LD_VAR 0 5
2424: PUSH
2425: LD_EXP 19
2429: ADD
2430: ST_TO_ADDR
// end ; if not Donaldson then
2431: LD_EXP 20
2435: NOT
2436: IFFALSE 2482
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2438: LD_ADDR_EXP 20
2442: PUSH
2443: LD_STRING Donaldson
2445: PPUSH
2446: LD_EXP 1
2450: NOT
2451: PPUSH
2452: LD_STRING 13a_
2454: PPUSH
2455: CALL 51118 0 3
2459: ST_TO_ADDR
// if Donaldson then
2460: LD_EXP 20
2464: IFFALSE 2482
// tmp := tmp ^ Donaldson ;
2466: LD_ADDR_VAR 0 5
2470: PUSH
2471: LD_VAR 0 5
2475: PUSH
2476: LD_EXP 20
2480: ADD
2481: ST_TO_ADDR
// end ; if not Bobby then
2482: LD_EXP 21
2486: NOT
2487: IFFALSE 2533
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2489: LD_ADDR_EXP 21
2493: PUSH
2494: LD_STRING Bobby
2496: PPUSH
2497: LD_EXP 1
2501: NOT
2502: PPUSH
2503: LD_STRING 13a_
2505: PPUSH
2506: CALL 51118 0 3
2510: ST_TO_ADDR
// if Bobby then
2511: LD_EXP 21
2515: IFFALSE 2533
// tmp := tmp ^ Bobby ;
2517: LD_ADDR_VAR 0 5
2521: PUSH
2522: LD_VAR 0 5
2526: PUSH
2527: LD_EXP 21
2531: ADD
2532: ST_TO_ADDR
// end ; if not Cyrus then
2533: LD_EXP 22
2537: NOT
2538: IFFALSE 2584
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2540: LD_ADDR_EXP 22
2544: PUSH
2545: LD_STRING Cyrus
2547: PPUSH
2548: LD_EXP 1
2552: NOT
2553: PPUSH
2554: LD_STRING 13a_
2556: PPUSH
2557: CALL 51118 0 3
2561: ST_TO_ADDR
// if Cyrus then
2562: LD_EXP 22
2566: IFFALSE 2584
// tmp := tmp ^ Cyrus ;
2568: LD_ADDR_VAR 0 5
2572: PUSH
2573: LD_VAR 0 5
2577: PUSH
2578: LD_EXP 22
2582: ADD
2583: ST_TO_ADDR
// end ; if not Brown then
2584: LD_EXP 24
2588: NOT
2589: IFFALSE 2635
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2591: LD_ADDR_EXP 24
2595: PUSH
2596: LD_STRING Brown
2598: PPUSH
2599: LD_EXP 1
2603: NOT
2604: PPUSH
2605: LD_STRING 13a_
2607: PPUSH
2608: CALL 51118 0 3
2612: ST_TO_ADDR
// if Brown then
2613: LD_EXP 24
2617: IFFALSE 2635
// tmp := tmp ^ Brown ;
2619: LD_ADDR_VAR 0 5
2623: PUSH
2624: LD_VAR 0 5
2628: PUSH
2629: LD_EXP 24
2633: ADD
2634: ST_TO_ADDR
// end ; if not Gladstone then
2635: LD_EXP 25
2639: NOT
2640: IFFALSE 2686
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2642: LD_ADDR_EXP 25
2646: PUSH
2647: LD_STRING Gladstone
2649: PPUSH
2650: LD_EXP 1
2654: NOT
2655: PPUSH
2656: LD_STRING 13a_
2658: PPUSH
2659: CALL 51118 0 3
2663: ST_TO_ADDR
// if Gladstone then
2664: LD_EXP 25
2668: IFFALSE 2686
// tmp := tmp ^ Gladstone ;
2670: LD_ADDR_VAR 0 5
2674: PUSH
2675: LD_VAR 0 5
2679: PUSH
2680: LD_EXP 25
2684: ADD
2685: ST_TO_ADDR
// end ; if not Cornel then
2686: LD_EXP 27
2690: NOT
2691: IFFALSE 2737
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2693: LD_ADDR_EXP 27
2697: PUSH
2698: LD_STRING Cornel
2700: PPUSH
2701: LD_EXP 1
2705: NOT
2706: PPUSH
2707: LD_STRING 13a_
2709: PPUSH
2710: CALL 51118 0 3
2714: ST_TO_ADDR
// if Cornel then
2715: LD_EXP 27
2719: IFFALSE 2737
// tmp := tmp ^ Cornel ;
2721: LD_ADDR_VAR 0 5
2725: PUSH
2726: LD_VAR 0 5
2730: PUSH
2731: LD_EXP 27
2735: ADD
2736: ST_TO_ADDR
// end ; if not Houten then
2737: LD_EXP 26
2741: NOT
2742: IFFALSE 2788
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2744: LD_ADDR_EXP 26
2748: PUSH
2749: LD_STRING Houten
2751: PPUSH
2752: LD_EXP 1
2756: NOT
2757: PPUSH
2758: LD_STRING 13a_
2760: PPUSH
2761: CALL 51118 0 3
2765: ST_TO_ADDR
// if Houten then
2766: LD_EXP 26
2770: IFFALSE 2788
// tmp := tmp ^ Houten ;
2772: LD_ADDR_VAR 0 5
2776: PUSH
2777: LD_VAR 0 5
2781: PUSH
2782: LD_EXP 26
2786: ADD
2787: ST_TO_ADDR
// end ; if not Gary then
2788: LD_EXP 28
2792: NOT
2793: IFFALSE 2839
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2795: LD_ADDR_EXP 28
2799: PUSH
2800: LD_STRING Gary
2802: PPUSH
2803: LD_EXP 1
2807: NOT
2808: PPUSH
2809: LD_STRING 13a_
2811: PPUSH
2812: CALL 51118 0 3
2816: ST_TO_ADDR
// if Gary then
2817: LD_EXP 28
2821: IFFALSE 2839
// tmp := tmp ^ Gary ;
2823: LD_ADDR_VAR 0 5
2827: PUSH
2828: LD_VAR 0 5
2832: PUSH
2833: LD_EXP 28
2837: ADD
2838: ST_TO_ADDR
// end ; if not Kikuchi then
2839: LD_EXP 30
2843: NOT
2844: IFFALSE 2890
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2846: LD_ADDR_EXP 30
2850: PUSH
2851: LD_STRING Kikuchi
2853: PPUSH
2854: LD_EXP 1
2858: NOT
2859: PPUSH
2860: LD_STRING 13a_
2862: PPUSH
2863: CALL 51118 0 3
2867: ST_TO_ADDR
// if Kikuchi then
2868: LD_EXP 30
2872: IFFALSE 2890
// tmp := tmp ^ Kikuchi ;
2874: LD_ADDR_VAR 0 5
2878: PUSH
2879: LD_VAR 0 5
2883: PUSH
2884: LD_EXP 30
2888: ADD
2889: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2890: LD_ADDR_VAR 0 5
2894: PUSH
2895: LD_VAR 0 5
2899: PUSH
2900: LD_STRING 13a_others
2902: PPUSH
2903: CALL_OW 31
2907: UNION
2908: ST_TO_ADDR
// tmp := tmp diff 0 ;
2909: LD_ADDR_VAR 0 5
2913: PUSH
2914: LD_VAR 0 5
2918: PUSH
2919: LD_INT 0
2921: DIFF
2922: ST_TO_ADDR
// if tmp < 15 then
2923: LD_VAR 0 5
2927: PUSH
2928: LD_INT 15
2930: LESS
2931: IFFALSE 3019
// for i = 15 downto tmp do
2933: LD_ADDR_VAR 0 2
2937: PUSH
2938: DOUBLE
2939: LD_INT 15
2941: INC
2942: ST_TO_ADDR
2943: LD_VAR 0 5
2947: PUSH
2948: FOR_DOWNTO
2949: IFFALSE 3017
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2951: LD_ADDR_OWVAR 21
2955: PUSH
2956: LD_INT 1
2958: PUSH
2959: LD_INT 3
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: PUSH
2966: LD_INT 1
2968: PPUSH
2969: LD_INT 2
2971: PPUSH
2972: CALL_OW 12
2976: ARRAY
2977: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2978: LD_INT 0
2980: PPUSH
2981: LD_INT 1
2983: PPUSH
2984: LD_INT 4
2986: PPUSH
2987: CALL_OW 12
2991: PPUSH
2992: LD_INT 8
2994: PPUSH
2995: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2999: LD_ADDR_VAR 0 5
3003: PUSH
3004: LD_VAR 0 5
3008: PUSH
3009: CALL_OW 44
3013: ADD
3014: ST_TO_ADDR
// end ;
3015: GO 2948
3017: POP
3018: POP
// if not debug then
3019: LD_EXP 1
3023: NOT
3024: IFFALSE 3196
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3026: LD_ADDR_VAR 0 4
3030: PUSH
3031: LD_STRING 
3033: PPUSH
3034: LD_INT 15
3036: PUSH
3037: LD_INT 14
3039: PUSH
3040: LD_INT 13
3042: PUSH
3043: EMPTY
3044: LIST
3045: LIST
3046: LIST
3047: PUSH
3048: LD_OWVAR 67
3052: ARRAY
3053: PPUSH
3054: LD_INT 15
3056: PUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 13
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: PUSH
3068: LD_OWVAR 67
3072: ARRAY
3073: PPUSH
3074: LD_INT -5
3076: PUSH
3077: LD_EXP 17
3081: PUSH
3082: LD_EXP 49
3086: PUSH
3087: LD_EXP 18
3091: PUSH
3092: LD_EXP 32
3096: PUSH
3097: LD_EXP 23
3101: PUSH
3102: LD_EXP 35
3106: PUSH
3107: LD_INT -2
3109: PUSH
3110: LD_INT -3
3112: PUSH
3113: LD_INT -5
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: LIST
3126: LIST
3127: PUSH
3128: LD_VAR 0 5
3132: ADD
3133: PPUSH
3134: LD_INT 1
3136: PUSH
3137: LD_INT 4
3139: PUSH
3140: LD_INT 2
3142: PUSH
3143: LD_INT 1
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 3
3152: PUSH
3153: LD_INT 5
3155: PUSH
3156: LD_INT 0
3158: PUSH
3159: LD_INT 3
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: LIST
3166: PUSH
3167: LD_INT 9
3169: PUSH
3170: LD_INT 0
3172: PUSH
3173: LD_INT 3
3175: PUSH
3176: EMPTY
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: LIST
3185: LIST
3186: LIST
3187: LIST
3188: PPUSH
3189: CALL_OW 42
3193: ST_TO_ADDR
3194: GO 3275
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3196: LD_ADDR_VAR 0 4
3200: PUSH
3201: LD_EXP 37
3205: PUSH
3206: LD_EXP 38
3210: PUSH
3211: LD_EXP 39
3215: PUSH
3216: LD_EXP 40
3220: PUSH
3221: LD_EXP 41
3225: PUSH
3226: LD_EXP 42
3230: PUSH
3231: LD_EXP 43
3235: PUSH
3236: LD_EXP 44
3240: PUSH
3241: LD_EXP 45
3245: PUSH
3246: LD_EXP 46
3250: PUSH
3251: LD_EXP 47
3255: PUSH
3256: LD_EXP 48
3260: PUSH
3261: EMPTY
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: ST_TO_ADDR
// uc_nation := 1 ;
3275: LD_ADDR_OWVAR 21
3279: PUSH
3280: LD_INT 1
3282: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3283: LD_INT 5
3285: PPUSH
3286: LD_INT 3
3288: PPUSH
3289: LD_INT 1
3291: PPUSH
3292: LD_INT 6
3294: PPUSH
3295: LD_INT 100
3297: PPUSH
3298: CALL 55982 0 5
// veh := CreateVehicle ;
3302: LD_ADDR_VAR 0 3
3306: PUSH
3307: CALL_OW 45
3311: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3312: LD_VAR 0 3
3316: PPUSH
3317: LD_INT 7
3319: NEG
3320: PPUSH
3321: CALL_OW 242
// SetDir ( veh , 3 ) ;
3325: LD_VAR 0 3
3329: PPUSH
3330: LD_INT 3
3332: PPUSH
3333: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3337: LD_VAR 0 3
3341: PPUSH
3342: LD_INT 31
3344: PPUSH
3345: LD_INT 0
3347: PPUSH
3348: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3352: LD_EXP 17
3356: PPUSH
3357: LD_VAR 0 3
3361: PPUSH
3362: CALL_OW 52
// if Joan then
3366: LD_EXP 32
3370: IFFALSE 3442
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3372: LD_INT 3
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 1
3380: PPUSH
3381: LD_INT 11
3383: PPUSH
3384: LD_INT 100
3386: PPUSH
3387: CALL 55982 0 5
// veh := CreateVehicle ;
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: CALL_OW 45
3400: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3401: LD_VAR 0 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3413: LD_VAR 0 3
3417: PPUSH
3418: LD_INT 30
3420: PPUSH
3421: LD_INT 0
3423: PPUSH
3424: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3428: LD_EXP 32
3432: PPUSH
3433: LD_VAR 0 3
3437: PPUSH
3438: CALL_OW 52
// end ; if Roth then
3442: LD_EXP 18
3446: IFFALSE 3518
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3448: LD_INT 3
3450: PPUSH
3451: LD_INT 3
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 11
3459: PPUSH
3460: LD_INT 100
3462: PPUSH
3463: CALL 55982 0 5
// veh := CreateVehicle ;
3467: LD_ADDR_VAR 0 3
3471: PUSH
3472: CALL_OW 45
3476: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3477: LD_VAR 0 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3489: LD_VAR 0 3
3493: PPUSH
3494: LD_INT 30
3496: PPUSH
3497: LD_INT 0
3499: PPUSH
3500: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3504: LD_EXP 18
3508: PPUSH
3509: LD_VAR 0 3
3513: PPUSH
3514: CALL_OW 52
// end ; if Denis then
3518: LD_EXP 23
3522: IFFALSE 3594
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3524: LD_INT 5
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_INT 1
3532: PPUSH
3533: LD_INT 9
3535: PPUSH
3536: LD_INT 100
3538: PPUSH
3539: CALL 55982 0 5
// veh := CreateVehicle ;
3543: LD_ADDR_VAR 0 3
3547: PUSH
3548: CALL_OW 45
3552: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3553: LD_VAR 0 3
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3565: LD_VAR 0 3
3569: PPUSH
3570: LD_INT 30
3572: PPUSH
3573: LD_INT 0
3575: PPUSH
3576: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3580: LD_EXP 23
3584: PPUSH
3585: LD_VAR 0 3
3589: PPUSH
3590: CALL_OW 52
// end ; uc_nation := 3 ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3602: LD_INT 22
3604: PPUSH
3605: LD_INT 3
3607: PPUSH
3608: LD_INT 1
3610: PPUSH
3611: LD_INT 45
3613: PPUSH
3614: LD_INT 100
3616: PPUSH
3617: CALL 55982 0 5
// veh := CreateVehicle ;
3621: LD_ADDR_VAR 0 3
3625: PUSH
3626: CALL_OW 45
3630: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3631: LD_VAR 0 3
3635: PPUSH
3636: LD_INT 7
3638: NEG
3639: PPUSH
3640: CALL_OW 242
// SetDir ( veh , 3 ) ;
3644: LD_VAR 0 3
3648: PPUSH
3649: LD_INT 3
3651: PPUSH
3652: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3656: LD_VAR 0 3
3660: PPUSH
3661: LD_INT 31
3663: PPUSH
3664: LD_INT 0
3666: PPUSH
3667: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3671: LD_EXP 49
3675: PPUSH
3676: LD_VAR 0 3
3680: PPUSH
3681: CALL_OW 52
// if Gossudarov then
3685: LD_EXP 35
3689: IFFALSE 3776
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3691: LD_INT 22
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 1
3699: PPUSH
3700: LD_INT 51
3702: PPUSH
3703: LD_INT 100
3705: PPUSH
3706: CALL 55982 0 5
// veh := CreateVehicle ;
3710: LD_ADDR_VAR 0 3
3714: PUSH
3715: CALL_OW 45
3719: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3720: LD_VAR 0 3
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3732: LD_VAR 0 3
3736: PPUSH
3737: LD_INT 30
3739: PPUSH
3740: LD_INT 0
3742: PPUSH
3743: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3747: LD_EXP 35
3751: PPUSH
3752: LD_VAR 0 3
3756: PPUSH
3757: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3761: LD_VAR 0 3
3765: PPUSH
3766: LD_INT 1
3768: PPUSH
3769: LD_INT 100
3771: PPUSH
3772: CALL_OW 290
// end ; for i in selected do
3776: LD_ADDR_VAR 0 2
3780: PUSH
3781: LD_VAR 0 4
3785: PUSH
3786: FOR_IN
3787: IFFALSE 4345
// begin uc_nation := GetNation ( i ) ;
3789: LD_ADDR_OWVAR 21
3793: PUSH
3794: LD_VAR 0 2
3798: PPUSH
3799: CALL_OW 248
3803: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3804: LD_VAR 0 2
3808: PUSH
3809: LD_EXP 19
3813: PUSH
3814: LD_EXP 20
3818: PUSH
3819: LD_EXP 22
3823: PUSH
3824: LD_EXP 21
3828: PUSH
3829: EMPTY
3830: LIST
3831: LIST
3832: LIST
3833: LIST
3834: IN
3835: IFFALSE 3858
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3837: LD_INT 5
3839: PPUSH
3840: LD_INT 3
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: LD_INT 6
3848: PPUSH
3849: LD_INT 100
3851: PPUSH
3852: CALL 55982 0 5
3856: GO 4292
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3858: LD_VAR 0 2
3862: PUSH
3863: LD_EXP 42
3867: PUSH
3868: LD_EXP 47
3872: PUSH
3873: LD_EXP 45
3877: PUSH
3878: LD_EXP 37
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: LIST
3887: LIST
3888: IN
3889: IFFALSE 3920
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3891: LD_INT 24
3893: PPUSH
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 1
3899: PPUSH
3900: LD_INT 46
3902: PPUSH
3903: LD_INT 65
3905: PPUSH
3906: LD_INT 75
3908: PPUSH
3909: CALL_OW 12
3913: PPUSH
3914: CALL 55982 0 5
3918: GO 4292
// if i = Karamazov then
3920: LD_VAR 0 2
3924: PUSH
3925: LD_EXP 48
3929: EQUAL
3930: IFFALSE 3953
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3932: LD_INT 22
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: LD_INT 52
3943: PPUSH
3944: LD_INT 100
3946: PPUSH
3947: CALL 55982 0 5
3951: GO 4292
// if i = Brown then
3953: LD_VAR 0 2
3957: PUSH
3958: LD_EXP 24
3962: EQUAL
3963: IFFALSE 3986
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3965: LD_INT 3
3967: PPUSH
3968: LD_INT 3
3970: PPUSH
3971: LD_INT 1
3973: PPUSH
3974: LD_INT 13
3976: PPUSH
3977: LD_INT 100
3979: PPUSH
3980: CALL 55982 0 5
3984: GO 4292
// if uc_nation = nation_american then
3986: LD_OWVAR 21
3990: PUSH
3991: LD_INT 1
3993: EQUAL
3994: IFFALSE 4145
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3996: LD_INT 3
3998: PUSH
3999: LD_INT 5
4001: PUSH
4002: LD_INT 5
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_OWVAR 21
4014: PUSH
4015: LD_INT 3
4017: MOD
4018: PUSH
4019: LD_INT 1
4021: PLUS
4022: ARRAY
4023: PPUSH
4024: LD_INT 1
4026: PUSH
4027: LD_INT 3
4029: PUSH
4030: LD_INT 1
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: LIST
4037: PUSH
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 3
4045: MOD
4046: PUSH
4047: LD_INT 1
4049: PLUS
4050: ARRAY
4051: PPUSH
4052: LD_INT 1
4054: PPUSH
4055: LD_INT 11
4057: PUSH
4058: LD_INT 4
4060: PUSH
4061: LD_INT 5
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: LIST
4068: PUSH
4069: LD_INT 6
4071: PUSH
4072: LD_INT 7
4074: PUSH
4075: LD_INT 9
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: LIST
4082: PUSH
4083: LD_INT 6
4085: PUSH
4086: LD_INT 9
4088: PUSH
4089: LD_INT 12
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: LIST
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: LIST
4101: PUSH
4102: LD_OWVAR 21
4106: PUSH
4107: LD_INT 3
4109: MOD
4110: PUSH
4111: LD_INT 1
4113: PLUS
4114: ARRAY
4115: PUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_INT 3
4121: PPUSH
4122: CALL_OW 12
4126: ARRAY
4127: PPUSH
4128: LD_INT 65
4130: PPUSH
4131: LD_INT 75
4133: PPUSH
4134: CALL_OW 12
4138: PPUSH
4139: CALL 55982 0 5
// end else
4143: GO 4292
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4145: LD_INT 22
4147: PUSH
4148: LD_INT 23
4150: PUSH
4151: LD_INT 23
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: LD_OWVAR 21
4163: PUSH
4164: LD_INT 3
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: ARRAY
4172: PPUSH
4173: LD_INT 1
4175: PUSH
4176: LD_INT 3
4178: PUSH
4179: LD_INT 1
4181: PUSH
4182: EMPTY
4183: LIST
4184: LIST
4185: LIST
4186: PUSH
4187: LD_OWVAR 21
4191: PUSH
4192: LD_INT 3
4194: MOD
4195: PUSH
4196: LD_INT 1
4198: PLUS
4199: ARRAY
4200: PPUSH
4201: LD_INT 1
4203: PPUSH
4204: LD_INT 45
4206: PUSH
4207: LD_INT 43
4209: PUSH
4210: LD_INT 44
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: LIST
4217: PUSH
4218: LD_INT 46
4220: PUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 44
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 46
4234: PUSH
4235: LD_INT 43
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: LIST
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: PUSH
4251: LD_OWVAR 21
4255: PUSH
4256: LD_INT 3
4258: MOD
4259: PUSH
4260: LD_INT 1
4262: PLUS
4263: ARRAY
4264: PUSH
4265: LD_INT 1
4267: PPUSH
4268: LD_INT 3
4270: PPUSH
4271: CALL_OW 12
4275: ARRAY
4276: PPUSH
4277: LD_INT 65
4279: PPUSH
4280: LD_INT 75
4282: PPUSH
4283: CALL_OW 12
4287: PPUSH
4288: CALL 55982 0 5
// end ; veh := CreateVehicle ;
4292: LD_ADDR_VAR 0 3
4296: PUSH
4297: CALL_OW 45
4301: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4302: LD_VAR 0 3
4306: PPUSH
4307: LD_INT 3
4309: PPUSH
4310: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4314: LD_VAR 0 3
4318: PPUSH
4319: LD_INT 30
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4329: LD_VAR 0 2
4333: PPUSH
4334: LD_VAR 0 3
4338: PPUSH
4339: CALL_OW 52
// end ;
4343: GO 3786
4345: POP
4346: POP
// if artifactArCaptured then
4347: LD_EXP 9
4351: IFFALSE 4437
// begin uc_nation := nation_american ;
4353: LD_ADDR_OWVAR 21
4357: PUSH
4358: LD_INT 1
4360: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4361: LD_INT 3
4363: PPUSH
4364: LD_INT 3
4366: PPUSH
4367: LD_INT 3
4369: PPUSH
4370: LD_INT 12
4372: PPUSH
4373: LD_INT 100
4375: PPUSH
4376: CALL 55982 0 5
// veh := CreateVehicle ;
4380: LD_ADDR_VAR 0 3
4384: PUSH
4385: CALL_OW 45
4389: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4390: LD_VAR 0 3
4394: PPUSH
4395: LD_INT 3
4397: PPUSH
4398: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4402: LD_VAR 0 3
4406: PPUSH
4407: LD_INT 198
4409: PPUSH
4410: LD_INT 22
4412: PPUSH
4413: LD_INT 0
4415: PPUSH
4416: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4420: LD_VAR 0 3
4424: PPUSH
4425: LD_INT 4
4427: PPUSH
4428: LD_INT 50
4430: PPUSH
4431: CALL_OW 290
// end else
4435: GO 4456
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4437: LD_INT 4
4439: PPUSH
4440: LD_INT 5
4442: PPUSH
4443: LD_INT 267
4445: PPUSH
4446: LD_INT 226
4448: PPUSH
4449: LD_INT 0
4451: PPUSH
4452: CALL_OW 58
// end ; uc_nation := nation_american ;
4456: LD_ADDR_OWVAR 21
4460: PUSH
4461: LD_INT 1
4463: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4464: LD_INT 3
4466: PPUSH
4467: LD_INT 3
4469: PPUSH
4470: LD_INT 3
4472: PPUSH
4473: LD_INT 12
4475: PPUSH
4476: LD_INT 100
4478: PPUSH
4479: CALL 55982 0 5
// veh := CreateVehicle ;
4483: LD_ADDR_VAR 0 3
4487: PUSH
4488: CALL_OW 45
4492: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4493: LD_VAR 0 3
4497: PPUSH
4498: LD_INT 3
4500: PPUSH
4501: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4505: LD_VAR 0 3
4509: PPUSH
4510: LD_INT 218
4512: PPUSH
4513: LD_INT 23
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4523: LD_VAR 0 3
4527: PPUSH
4528: LD_INT 4
4530: PPUSH
4531: LD_INT 30
4533: PPUSH
4534: CALL_OW 290
// uc_nation := nation_russian ;
4538: LD_ADDR_OWVAR 21
4542: PUSH
4543: LD_INT 3
4545: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4546: LD_INT 22
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 3
4554: PPUSH
4555: LD_INT 51
4557: PPUSH
4558: LD_INT 100
4560: PPUSH
4561: CALL 55982 0 5
// veh := CreateVehicle ;
4565: LD_ADDR_VAR 0 3
4569: PUSH
4570: CALL_OW 45
4574: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 3
4582: PPUSH
4583: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4587: LD_VAR 0 3
4591: PPUSH
4592: LD_INT 214
4594: PPUSH
4595: LD_INT 20
4597: PPUSH
4598: LD_INT 0
4600: PPUSH
4601: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4605: LD_VAR 0 3
4609: PPUSH
4610: LD_INT 4
4612: PPUSH
4613: LD_INT 40
4615: PPUSH
4616: CALL_OW 290
// end ; end_of_file
4620: LD_VAR 0 1
4624: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4625: LD_INT 0
4627: PPUSH
4628: PPUSH
4629: PPUSH
4630: PPUSH
4631: PPUSH
4632: PPUSH
4633: PPUSH
4634: PPUSH
4635: PPUSH
4636: PPUSH
// InitHc ;
4637: CALL_OW 19
// uc_side := 1 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 1
4648: ST_TO_ADDR
// uc_nation := 1 ;
4649: LD_ADDR_OWVAR 21
4653: PUSH
4654: LD_INT 1
4656: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: LD_INT 22
4664: PUSH
4665: LD_INT 1
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 21
4674: PUSH
4675: LD_INT 3
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PPUSH
4686: CALL_OW 69
4690: PUSH
4691: FOR_IN
4692: IFFALSE 4708
// SetBLevel ( i , 10 ) ;
4694: LD_VAR 0 2
4698: PPUSH
4699: LD_INT 10
4701: PPUSH
4702: CALL_OW 241
4706: GO 4691
4708: POP
4709: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4710: LD_INT 387
4712: PPUSH
4713: CALL_OW 274
4717: PPUSH
4718: LD_INT 1
4720: PPUSH
4721: LD_INT 7500
4723: PPUSH
4724: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4728: LD_INT 387
4730: PPUSH
4731: CALL_OW 274
4735: PPUSH
4736: LD_INT 2
4738: PPUSH
4739: LD_INT 4000
4741: PPUSH
4742: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4746: LD_INT 387
4748: PPUSH
4749: CALL_OW 274
4753: PPUSH
4754: LD_INT 3
4756: PPUSH
4757: LD_INT 50
4759: PPUSH
4760: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4764: LD_INT 476
4766: PPUSH
4767: CALL_OW 274
4771: PPUSH
4772: LD_INT 1
4774: PPUSH
4775: LD_INT 5500
4777: PPUSH
4778: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4782: LD_INT 476
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 2
4792: PPUSH
4793: LD_INT 4000
4795: PPUSH
4796: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4800: LD_INT 476
4802: PPUSH
4803: CALL_OW 274
4807: PPUSH
4808: LD_INT 3
4810: PPUSH
4811: LD_INT 10
4813: PPUSH
4814: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4818: LD_ADDR_EXP 52
4822: PUSH
4823: LD_STRING Powell
4825: PPUSH
4826: CALL_OW 25
4830: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4831: LD_EXP 52
4835: PPUSH
4836: LD_INT 387
4838: PPUSH
4839: CALL_OW 52
// tmp := [ ] ;
4843: LD_ADDR_VAR 0 6
4847: PUSH
4848: EMPTY
4849: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4850: LD_ADDR_EXP 19
4854: PUSH
4855: LD_STRING Lisa
4857: PPUSH
4858: LD_EXP 1
4862: NOT
4863: PPUSH
4864: LD_STRING 12p_
4866: PPUSH
4867: CALL 51118 0 3
4871: ST_TO_ADDR
// if Lisa then
4872: LD_EXP 19
4876: IFFALSE 4894
// tmp := tmp ^ Lisa ;
4878: LD_ADDR_VAR 0 6
4882: PUSH
4883: LD_VAR 0 6
4887: PUSH
4888: LD_EXP 19
4892: ADD
4893: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4894: LD_ADDR_EXP 20
4898: PUSH
4899: LD_STRING Donaldson
4901: PPUSH
4902: LD_EXP 1
4906: NOT
4907: PPUSH
4908: LD_STRING 12p_
4910: PPUSH
4911: CALL 51118 0 3
4915: ST_TO_ADDR
// if Donaldson then
4916: LD_EXP 20
4920: IFFALSE 4938
// tmp := tmp ^ Donaldson ;
4922: LD_ADDR_VAR 0 6
4926: PUSH
4927: LD_VAR 0 6
4931: PUSH
4932: LD_EXP 20
4936: ADD
4937: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4938: LD_ADDR_EXP 21
4942: PUSH
4943: LD_STRING Bobby
4945: PPUSH
4946: LD_EXP 1
4950: NOT
4951: PPUSH
4952: LD_STRING 12p_
4954: PPUSH
4955: CALL 51118 0 3
4959: ST_TO_ADDR
// if Bobby then
4960: LD_EXP 21
4964: IFFALSE 4982
// tmp := tmp ^ Bobby ;
4966: LD_ADDR_VAR 0 6
4970: PUSH
4971: LD_VAR 0 6
4975: PUSH
4976: LD_EXP 21
4980: ADD
4981: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4982: LD_ADDR_EXP 22
4986: PUSH
4987: LD_STRING Cyrus
4989: PPUSH
4990: LD_EXP 1
4994: NOT
4995: PPUSH
4996: LD_STRING 12p_
4998: PPUSH
4999: CALL 51118 0 3
5003: ST_TO_ADDR
// if Cyrus then
5004: LD_EXP 22
5008: IFFALSE 5026
// tmp := tmp ^ Cyrus ;
5010: LD_ADDR_VAR 0 6
5014: PUSH
5015: LD_VAR 0 6
5019: PUSH
5020: LD_EXP 22
5024: ADD
5025: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5026: LD_ADDR_EXP 24
5030: PUSH
5031: LD_STRING Brown
5033: PPUSH
5034: LD_EXP 1
5038: NOT
5039: PPUSH
5040: LD_STRING 12p_
5042: PPUSH
5043: CALL 51118 0 3
5047: ST_TO_ADDR
// if Brown then
5048: LD_EXP 24
5052: IFFALSE 5070
// tmp := tmp ^ Brown ;
5054: LD_ADDR_VAR 0 6
5058: PUSH
5059: LD_VAR 0 6
5063: PUSH
5064: LD_EXP 24
5068: ADD
5069: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5070: LD_ADDR_EXP 25
5074: PUSH
5075: LD_STRING Gladstone
5077: PPUSH
5078: LD_EXP 1
5082: NOT
5083: PPUSH
5084: LD_STRING 12p_
5086: PPUSH
5087: CALL 51118 0 3
5091: ST_TO_ADDR
// if Gladstone then
5092: LD_EXP 25
5096: IFFALSE 5114
// tmp := tmp ^ Gladstone ;
5098: LD_ADDR_VAR 0 6
5102: PUSH
5103: LD_VAR 0 6
5107: PUSH
5108: LD_EXP 25
5112: ADD
5113: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5114: LD_ADDR_EXP 26
5118: PUSH
5119: LD_STRING Houten
5121: PPUSH
5122: LD_EXP 1
5126: NOT
5127: PPUSH
5128: LD_STRING 12p_
5130: PPUSH
5131: CALL 51118 0 3
5135: ST_TO_ADDR
// if Houten then
5136: LD_EXP 26
5140: IFFALSE 5158
// tmp := tmp ^ Houten ;
5142: LD_ADDR_VAR 0 6
5146: PUSH
5147: LD_VAR 0 6
5151: PUSH
5152: LD_EXP 26
5156: ADD
5157: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5158: LD_ADDR_EXP 27
5162: PUSH
5163: LD_STRING Cornel
5165: PPUSH
5166: LD_EXP 1
5170: NOT
5171: PPUSH
5172: LD_STRING 12p_
5174: PPUSH
5175: CALL 51118 0 3
5179: ST_TO_ADDR
// if Cornel then
5180: LD_EXP 27
5184: IFFALSE 5202
// tmp := tmp ^ Cornel ;
5186: LD_ADDR_VAR 0 6
5190: PUSH
5191: LD_VAR 0 6
5195: PUSH
5196: LD_EXP 27
5200: ADD
5201: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5202: LD_ADDR_EXP 28
5206: PUSH
5207: LD_STRING Gary
5209: PPUSH
5210: LD_EXP 1
5214: NOT
5215: PPUSH
5216: LD_STRING 12p_
5218: PPUSH
5219: CALL 51118 0 3
5223: ST_TO_ADDR
// if Gary then
5224: LD_EXP 28
5228: IFFALSE 5246
// tmp := tmp ^ Gary ;
5230: LD_ADDR_VAR 0 6
5234: PUSH
5235: LD_VAR 0 6
5239: PUSH
5240: LD_EXP 28
5244: ADD
5245: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5246: LD_ADDR_EXP 30
5250: PUSH
5251: LD_STRING Kikuchi
5253: PPUSH
5254: LD_EXP 1
5258: NOT
5259: PPUSH
5260: LD_STRING 12p_
5262: PPUSH
5263: CALL 51118 0 3
5267: ST_TO_ADDR
// if Kikuchi then
5268: LD_EXP 30
5272: IFFALSE 5290
// tmp := tmp ^ Kikuchi ;
5274: LD_ADDR_VAR 0 6
5278: PUSH
5279: LD_VAR 0 6
5283: PUSH
5284: LD_EXP 30
5288: ADD
5289: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5290: LD_ADDR_VAR 0 6
5294: PUSH
5295: LD_VAR 0 6
5299: PUSH
5300: LD_STRING 12p_others
5302: PPUSH
5303: CALL_OW 31
5307: UNION
5308: ST_TO_ADDR
// if tmp < 36 then
5309: LD_VAR 0 6
5313: PUSH
5314: LD_INT 36
5316: LESS
5317: IFFALSE 5384
// for i = 1 to 36 - tmp do
5319: LD_ADDR_VAR 0 2
5323: PUSH
5324: DOUBLE
5325: LD_INT 1
5327: DEC
5328: ST_TO_ADDR
5329: LD_INT 36
5331: PUSH
5332: LD_VAR 0 6
5336: MINUS
5337: PUSH
5338: FOR_TO
5339: IFFALSE 5382
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5341: LD_INT 1
5343: PPUSH
5344: LD_VAR 0 2
5348: PUSH
5349: LD_INT 4
5351: MOD
5352: PUSH
5353: LD_INT 1
5355: PLUS
5356: PPUSH
5357: LD_INT 10
5359: PPUSH
5360: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: CALL_OW 44
5378: ADD
5379: ST_TO_ADDR
// end ;
5380: GO 5338
5382: POP
5383: POP
// for i in tmp do
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_VAR 0 6
5393: PUSH
5394: FOR_IN
5395: IFFALSE 5420
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5397: LD_VAR 0 2
5401: PPUSH
5402: LD_INT 62
5404: PPUSH
5405: LD_INT 93
5407: PPUSH
5408: LD_INT 9
5410: PPUSH
5411: LD_INT 0
5413: PPUSH
5414: CALL_OW 50
5418: GO 5394
5420: POP
5421: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5422: LD_ADDR_EXP 93
5426: PUSH
5427: LD_EXP 93
5431: PPUSH
5432: LD_INT 4
5434: PPUSH
5435: LD_INT 22
5437: PUSH
5438: LD_INT 1
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL_OW 69
5449: PUSH
5450: LD_EXP 52
5454: DIFF
5455: PPUSH
5456: CALL_OW 1
5460: ST_TO_ADDR
// uc_side := 0 ;
5461: LD_ADDR_OWVAR 20
5465: PUSH
5466: LD_INT 0
5468: ST_TO_ADDR
// uc_nation := 0 ;
5469: LD_ADDR_OWVAR 21
5473: PUSH
5474: LD_INT 0
5476: ST_TO_ADDR
// for i = 1 to 4 do
5477: LD_ADDR_VAR 0 2
5481: PUSH
5482: DOUBLE
5483: LD_INT 1
5485: DEC
5486: ST_TO_ADDR
5487: LD_INT 4
5489: PUSH
5490: FOR_TO
5491: IFFALSE 5522
// begin InitHc ;
5493: CALL_OW 19
// hc_class := class_apeman ;
5497: LD_ADDR_OWVAR 28
5501: PUSH
5502: LD_INT 12
5504: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5505: CALL_OW 44
5509: PPUSH
5510: LD_INT 11
5512: PPUSH
5513: LD_INT 0
5515: PPUSH
5516: CALL_OW 49
// end ;
5520: GO 5490
5522: POP
5523: POP
// end ;
5524: LD_VAR 0 1
5528: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5529: LD_EXP 4
5533: NOT
5534: PUSH
5535: LD_INT 4
5537: PPUSH
5538: LD_INT 1
5540: PPUSH
5541: CALL 46139 0 2
5545: NOT
5546: AND
5547: IFFALSE 6319
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
// begin enable ;
5557: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5558: LD_INT 22
5560: PUSH
5561: LD_INT 1
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: PUSH
5568: LD_INT 23
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: PUSH
5578: LD_INT 30
5580: PUSH
5581: LD_INT 3
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: LIST
5592: PPUSH
5593: CALL_OW 69
5597: NOT
5598: IFFALSE 5602
// exit ;
5600: GO 6319
// if Prob ( 40 ) then
5602: LD_INT 40
5604: PPUSH
5605: CALL_OW 13
5609: IFFALSE 5736
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5611: LD_INT 4
5613: PPUSH
5614: LD_INT 5
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: LD_INT 2
5622: PUSH
5623: LD_INT 7
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: LD_INT 2
5640: PUSH
5641: LD_INT 7
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: LD_INT 5
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 7
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 5
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 6
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 5
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 6
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: LD_INT 5
5706: PUSH
5707: LD_INT 1
5709: PUSH
5710: LD_INT 2
5712: PUSH
5713: LD_INT 6
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: LIST
5729: PPUSH
5730: CALL 44721 0 2
// end else
5734: GO 5859
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5736: LD_INT 4
5738: PPUSH
5739: LD_INT 5
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: LD_INT 2
5747: PUSH
5748: LD_INT 7
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: LIST
5755: LIST
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 1
5762: PUSH
5763: LD_INT 2
5765: PUSH
5766: LD_INT 9
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: PUSH
5775: LD_INT 5
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 2
5783: PUSH
5784: LD_INT 9
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 5
5795: PUSH
5796: LD_INT 1
5798: PUSH
5799: LD_INT 2
5801: PUSH
5802: LD_INT 6
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: PUSH
5811: LD_INT 5
5813: PUSH
5814: LD_INT 1
5816: PUSH
5817: LD_INT 2
5819: PUSH
5820: LD_INT 6
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 5
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 2
5837: PUSH
5838: LD_INT 6
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PPUSH
5855: CALL 44721 0 2
// end ; repeat wait ( 0 0$1 ) ;
5859: LD_INT 35
5861: PPUSH
5862: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5866: LD_INT 4
5868: PPUSH
5869: LD_INT 1
5871: PPUSH
5872: CALL 46139 0 2
5876: PUSH
5877: LD_INT 6
5879: GREATEREQUAL
5880: IFFALSE 5859
// wait ( 0 0$30 ) ;
5882: LD_INT 1050
5884: PPUSH
5885: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5889: LD_ADDR_VAR 0 2
5893: PUSH
5894: LD_INT 4
5896: PPUSH
5897: LD_INT 1
5899: PPUSH
5900: CALL 46139 0 2
5904: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5905: LD_ADDR_EXP 112
5909: PUSH
5910: LD_EXP 112
5914: PPUSH
5915: LD_INT 4
5917: PPUSH
5918: LD_EXP 112
5922: PUSH
5923: LD_INT 4
5925: ARRAY
5926: PUSH
5927: LD_VAR 0 2
5931: DIFF
5932: PPUSH
5933: CALL_OW 1
5937: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 0
5945: PPUSH
5946: LD_INT 2
5948: PPUSH
5949: CALL_OW 12
5953: ST_TO_ADDR
// if target then
5954: LD_VAR 0 3
5958: IFFALSE 6086
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5960: LD_ADDR_VAR 0 2
5964: PUSH
5965: LD_VAR 0 2
5969: PPUSH
5970: LD_INT 24
5972: PUSH
5973: LD_INT 250
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 72
5984: ST_TO_ADDR
// for i in tmp do
5985: LD_ADDR_VAR 0 1
5989: PUSH
5990: LD_VAR 0 2
5994: PUSH
5995: FOR_IN
5996: IFFALSE 6036
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5998: LD_VAR 0 1
6002: PPUSH
6003: LD_INT 114
6005: PPUSH
6006: LD_INT 108
6008: PPUSH
6009: CALL_OW 297
6013: PUSH
6014: LD_INT 9
6016: GREATER
6017: IFFALSE 6034
// ComMoveXY ( i , 114 , 108 ) ;
6019: LD_VAR 0 1
6023: PPUSH
6024: LD_INT 114
6026: PPUSH
6027: LD_INT 108
6029: PPUSH
6030: CALL_OW 111
6034: GO 5995
6036: POP
6037: POP
// wait ( 0 0$1 ) ;
6038: LD_INT 35
6040: PPUSH
6041: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 92
6052: PUSH
6053: LD_INT 114
6055: PUSH
6056: LD_INT 108
6058: PUSH
6059: LD_INT 9
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL_OW 72
6072: PUSH
6073: LD_VAR 0 2
6077: PUSH
6078: LD_INT 1
6080: MINUS
6081: GREATEREQUAL
6082: IFFALSE 5960
// end else
6084: GO 6210
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6086: LD_ADDR_VAR 0 2
6090: PUSH
6091: LD_VAR 0 2
6095: PPUSH
6096: LD_INT 24
6098: PUSH
6099: LD_INT 250
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PPUSH
6106: CALL_OW 72
6110: ST_TO_ADDR
// for i in tmp do
6111: LD_ADDR_VAR 0 1
6115: PUSH
6116: LD_VAR 0 2
6120: PUSH
6121: FOR_IN
6122: IFFALSE 6162
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6124: LD_VAR 0 1
6128: PPUSH
6129: LD_INT 129
6131: PPUSH
6132: LD_INT 139
6134: PPUSH
6135: CALL_OW 297
6139: PUSH
6140: LD_INT 9
6142: GREATER
6143: IFFALSE 6160
// ComMoveXY ( i , 129 , 139 ) ;
6145: LD_VAR 0 1
6149: PPUSH
6150: LD_INT 129
6152: PPUSH
6153: LD_INT 139
6155: PPUSH
6156: CALL_OW 111
6160: GO 6121
6162: POP
6163: POP
// wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6171: LD_VAR 0 2
6175: PPUSH
6176: LD_INT 92
6178: PUSH
6179: LD_INT 129
6181: PUSH
6182: LD_INT 139
6184: PUSH
6185: LD_INT 9
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 72
6198: PUSH
6199: LD_VAR 0 2
6203: PUSH
6204: LD_INT 1
6206: MINUS
6207: GREATEREQUAL
6208: IFFALSE 6086
// end ; repeat wait ( 0 0$1 ) ;
6210: LD_INT 35
6212: PPUSH
6213: CALL_OW 67
// for i in tmp do
6217: LD_ADDR_VAR 0 1
6221: PUSH
6222: LD_VAR 0 2
6226: PUSH
6227: FOR_IN
6228: IFFALSE 6310
// begin if GetLives ( i ) > 251 then
6230: LD_VAR 0 1
6234: PPUSH
6235: CALL_OW 256
6239: PUSH
6240: LD_INT 251
6242: GREATER
6243: IFFALSE 6281
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6245: LD_VAR 0 1
6249: PPUSH
6250: LD_INT 81
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: PPUSH
6260: CALL_OW 69
6264: PPUSH
6265: LD_VAR 0 1
6269: PPUSH
6270: CALL_OW 74
6274: PPUSH
6275: CALL_OW 115
6279: GO 6308
// if IsDead ( i ) then
6281: LD_VAR 0 1
6285: PPUSH
6286: CALL_OW 301
6290: IFFALSE 6308
// tmp := tmp diff i ;
6292: LD_ADDR_VAR 0 2
6296: PUSH
6297: LD_VAR 0 2
6301: PUSH
6302: LD_VAR 0 1
6306: DIFF
6307: ST_TO_ADDR
// end ;
6308: GO 6227
6310: POP
6311: POP
// until not tmp ;
6312: LD_VAR 0 2
6316: NOT
6317: IFFALSE 6210
// end ;
6319: PPOPN 3
6321: END
// every 30 30$00 trigger not americanDestroyed do
6322: LD_EXP 4
6326: NOT
6327: IFFALSE 6392
6329: GO 6331
6331: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6332: LD_INT 63000
6334: PUSH
6335: LD_INT 42000
6337: PUSH
6338: LD_INT 21000
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: LIST
6345: PUSH
6346: LD_OWVAR 67
6350: ARRAY
6351: PPUSH
6352: CALL_OW 67
// if americanDestroyed then
6356: LD_EXP 4
6360: IFFALSE 6364
// exit ;
6362: GO 6392
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6364: LD_INT 4
6366: PPUSH
6367: LD_INT 5
6369: PUSH
6370: LD_INT 3
6372: PUSH
6373: LD_INT 1
6375: PUSH
6376: LD_INT 8
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: EMPTY
6386: LIST
6387: PPUSH
6388: CALL 44721 0 2
// end ; end_of_file
6392: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6393: LD_INT 0
6395: PPUSH
6396: PPUSH
6397: PPUSH
6398: PPUSH
6399: PPUSH
// side := 2 ;
6400: LD_ADDR_VAR 0 5
6404: PUSH
6405: LD_INT 2
6407: ST_TO_ADDR
// InitHc ;
6408: CALL_OW 19
// uc_side := side ;
6412: LD_ADDR_OWVAR 20
6416: PUSH
6417: LD_VAR 0 5
6421: ST_TO_ADDR
// uc_nation := 2 ;
6422: LD_ADDR_OWVAR 21
6426: PUSH
6427: LD_INT 2
6429: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6430: LD_ADDR_VAR 0 2
6434: PUSH
6435: LD_INT 22
6437: PUSH
6438: LD_INT 2
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: LD_INT 21
6447: PUSH
6448: LD_INT 3
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PPUSH
6459: CALL_OW 69
6463: PUSH
6464: FOR_IN
6465: IFFALSE 6481
// SetBLevel ( i , 10 ) ;
6467: LD_VAR 0 2
6471: PPUSH
6472: LD_INT 10
6474: PPUSH
6475: CALL_OW 241
6479: GO 6464
6481: POP
6482: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6483: LD_ADDR_VAR 0 4
6487: PUSH
6488: LD_INT 22
6490: PUSH
6491: LD_VAR 0 5
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 30
6502: PUSH
6503: LD_INT 32
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 58
6512: PUSH
6513: EMPTY
6514: LIST
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: PPUSH
6521: CALL_OW 69
6525: ST_TO_ADDR
// for i = 1 to 10 do
6526: LD_ADDR_VAR 0 2
6530: PUSH
6531: DOUBLE
6532: LD_INT 1
6534: DEC
6535: ST_TO_ADDR
6536: LD_INT 10
6538: PUSH
6539: FOR_TO
6540: IFFALSE 6612
// begin uc_nation := nation_nature ;
6542: LD_ADDR_OWVAR 21
6546: PUSH
6547: LD_INT 0
6549: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6550: LD_ADDR_OWVAR 28
6554: PUSH
6555: LD_INT 15
6557: ST_TO_ADDR
// hc_gallery :=  ;
6558: LD_ADDR_OWVAR 33
6562: PUSH
6563: LD_STRING 
6565: ST_TO_ADDR
// hc_name :=  ;
6566: LD_ADDR_OWVAR 26
6570: PUSH
6571: LD_STRING 
6573: ST_TO_ADDR
// un := CreateHuman ;
6574: LD_ADDR_VAR 0 3
6578: PUSH
6579: CALL_OW 44
6583: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6584: LD_VAR 0 3
6588: PPUSH
6589: LD_VAR 0 4
6593: PUSH
6594: LD_VAR 0 4
6598: PUSH
6599: LD_VAR 0 2
6603: MINUS
6604: ARRAY
6605: PPUSH
6606: CALL_OW 52
// end ;
6610: GO 6539
6612: POP
6613: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6614: LD_INT 503
6616: PPUSH
6617: LD_INT 27
6619: PPUSH
6620: LD_STRING 
6622: PPUSH
6623: LD_INT 8
6625: PUSH
6626: LD_INT 9
6628: PUSH
6629: LD_INT 10
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: LIST
6636: PUSH
6637: LD_OWVAR 67
6641: ARRAY
6642: PPUSH
6643: LD_INT 3000
6645: PUSH
6646: LD_INT 500
6648: PUSH
6649: LD_INT 150
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: LIST
6656: PPUSH
6657: LD_INT 16
6659: PUSH
6660: LD_INT 6
6662: PUSH
6663: LD_INT 6
6665: PUSH
6666: LD_INT 6
6668: PUSH
6669: EMPTY
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: PPUSH
6675: CALL 59429 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6679: LD_ADDR_EXP 93
6683: PUSH
6684: LD_EXP 93
6688: PPUSH
6689: LD_INT 1
6691: PPUSH
6692: LD_INT 22
6694: PUSH
6695: LD_VAR 0 5
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PUSH
6704: LD_INT 23
6706: PUSH
6707: LD_INT 2
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PUSH
6714: LD_INT 3
6716: PUSH
6717: LD_INT 21
6719: PUSH
6720: LD_INT 2
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: PPUSH
6736: CALL_OW 69
6740: PPUSH
6741: CALL_OW 1
6745: ST_TO_ADDR
// end ;
6746: LD_VAR 0 1
6750: RET
// export Omar ; export function PrepareOmarAli ; begin
6751: LD_INT 0
6753: PPUSH
// uc_side := 5 ;
6754: LD_ADDR_OWVAR 20
6758: PUSH
6759: LD_INT 5
6761: ST_TO_ADDR
// uc_nation := 2 ;
6762: LD_ADDR_OWVAR 21
6766: PUSH
6767: LD_INT 2
6769: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6770: LD_ADDR_EXP 53
6774: PUSH
6775: LD_STRING Omar
6777: PPUSH
6778: CALL_OW 25
6782: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6783: LD_EXP 53
6787: PPUSH
6788: LD_INT 330
6790: PPUSH
6791: LD_INT 244
6793: PPUSH
6794: LD_INT 0
6796: PPUSH
6797: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6801: LD_EXP 53
6805: PPUSH
6806: LD_INT 252
6808: PPUSH
6809: LD_INT 220
6811: PPUSH
6812: CALL_OW 111
// end ; end_of_file
6816: LD_VAR 0 1
6820: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6821: LD_INT 0
6823: PPUSH
6824: PPUSH
6825: PPUSH
6826: PPUSH
6827: PPUSH
// side := 8 ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_INT 8
6835: ST_TO_ADDR
// InitHc ;
6836: CALL_OW 19
// uc_side := side ;
6840: LD_ADDR_OWVAR 20
6844: PUSH
6845: LD_VAR 0 3
6849: ST_TO_ADDR
// uc_nation := 2 ;
6850: LD_ADDR_OWVAR 21
6854: PUSH
6855: LD_INT 2
6857: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6858: LD_ADDR_VAR 0 2
6862: PUSH
6863: LD_INT 22
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: LD_INT 21
6877: PUSH
6878: LD_INT 3
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PPUSH
6889: CALL_OW 69
6893: PUSH
6894: FOR_IN
6895: IFFALSE 6911
// SetBLevel ( i , 10 ) ;
6897: LD_VAR 0 2
6901: PPUSH
6902: LD_INT 10
6904: PPUSH
6905: CALL_OW 241
6909: GO 6894
6911: POP
6912: POP
// Schulz := NewCharacter ( Schulz ) ;
6913: LD_ADDR_EXP 54
6917: PUSH
6918: LD_STRING Schulz
6920: PPUSH
6921: CALL_OW 25
6925: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6926: LD_ADDR_EXP 55
6930: PUSH
6931: LD_STRING Kozlov
6933: PPUSH
6934: LD_INT 0
6936: PPUSH
6937: LD_STRING 
6939: PPUSH
6940: CALL 51118 0 3
6944: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6945: LD_EXP 55
6949: PPUSH
6950: LD_INT 22
6952: PUSH
6953: LD_INT 8
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PUSH
6960: LD_INT 23
6962: PUSH
6963: LD_INT 3
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PUSH
6970: LD_INT 30
6972: PUSH
6973: LD_INT 8
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: PUSH
6990: LD_INT 1
6992: ARRAY
6993: PPUSH
6994: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6998: LD_EXP 55
7002: PPUSH
7003: LD_INT 3
7005: PPUSH
7006: LD_INT 10
7008: PPUSH
7009: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7013: LD_ADDR_VAR 0 5
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_VAR 0 3
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PUSH
7030: LD_INT 30
7032: PUSH
7033: LD_INT 32
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 58
7042: PUSH
7043: EMPTY
7044: LIST
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: PPUSH
7051: CALL_OW 69
7055: ST_TO_ADDR
// for i = 1 to 10 do
7056: LD_ADDR_VAR 0 2
7060: PUSH
7061: DOUBLE
7062: LD_INT 1
7064: DEC
7065: ST_TO_ADDR
7066: LD_INT 10
7068: PUSH
7069: FOR_TO
7070: IFFALSE 7142
// begin uc_nation := nation_nature ;
7072: LD_ADDR_OWVAR 21
7076: PUSH
7077: LD_INT 0
7079: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7080: LD_ADDR_OWVAR 28
7084: PUSH
7085: LD_INT 15
7087: ST_TO_ADDR
// hc_gallery :=  ;
7088: LD_ADDR_OWVAR 33
7092: PUSH
7093: LD_STRING 
7095: ST_TO_ADDR
// hc_name :=  ;
7096: LD_ADDR_OWVAR 26
7100: PUSH
7101: LD_STRING 
7103: ST_TO_ADDR
// un := CreateHuman ;
7104: LD_ADDR_VAR 0 4
7108: PUSH
7109: CALL_OW 44
7113: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7114: LD_VAR 0 4
7118: PPUSH
7119: LD_VAR 0 5
7123: PUSH
7124: LD_VAR 0 5
7128: PUSH
7129: LD_VAR 0 2
7133: MINUS
7134: ARRAY
7135: PPUSH
7136: CALL_OW 52
// end ;
7140: GO 7069
7142: POP
7143: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7144: LD_INT 324
7146: PPUSH
7147: LD_INT 3
7149: PPUSH
7150: LD_STRING 
7152: PPUSH
7153: LD_INT 8
7155: PUSH
7156: LD_INT 9
7158: PUSH
7159: LD_INT 10
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: LIST
7166: PUSH
7167: LD_OWVAR 67
7171: ARRAY
7172: PPUSH
7173: LD_INT 3000
7175: PUSH
7176: LD_INT 500
7178: PUSH
7179: LD_INT 150
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: LIST
7186: PPUSH
7187: LD_INT 16
7189: PUSH
7190: LD_INT 6
7192: PUSH
7193: LD_INT 6
7195: PUSH
7196: LD_INT 8
7198: PUSH
7199: EMPTY
7200: LIST
7201: LIST
7202: LIST
7203: LIST
7204: PPUSH
7205: CALL 59429 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7209: LD_ADDR_EXP 93
7213: PUSH
7214: LD_EXP 93
7218: PPUSH
7219: LD_INT 3
7221: PPUSH
7222: LD_INT 22
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 23
7236: PUSH
7237: LD_INT 2
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 21
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: EMPTY
7262: LIST
7263: LIST
7264: LIST
7265: PPUSH
7266: CALL_OW 69
7270: PUSH
7271: LD_EXP 54
7275: DIFF
7276: PPUSH
7277: CALL_OW 1
7281: ST_TO_ADDR
// end ;
7282: LD_VAR 0 1
7286: RET
// export function BuildKozlovBomb ; begin
7287: LD_INT 0
7289: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7290: LD_INT 332
7292: PPUSH
7293: CALL_OW 302
7297: NOT
7298: PUSH
7299: LD_INT 336
7301: PPUSH
7302: CALL_OW 302
7306: NOT
7307: OR
7308: IFFALSE 7312
// exit ;
7310: GO 7409
// ComChangeProfession ( Kozlov , 4 ) ;
7312: LD_EXP 55
7316: PPUSH
7317: LD_INT 4
7319: PPUSH
7320: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7324: LD_INT 336
7326: PPUSH
7327: LD_INT 25
7329: PPUSH
7330: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7334: LD_INT 35
7336: PPUSH
7337: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7341: LD_INT 25
7343: PPUSH
7344: LD_INT 8
7346: PPUSH
7347: CALL_OW 321
7351: PUSH
7352: LD_INT 2
7354: EQUAL
7355: IFFALSE 7334
// ComExitBuilding ( Kozlov ) ;
7357: LD_EXP 55
7361: PPUSH
7362: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7366: LD_EXP 55
7370: PPUSH
7371: LD_INT 332
7373: PPUSH
7374: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7378: LD_EXP 55
7382: PPUSH
7383: LD_INT 3
7385: PPUSH
7386: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7390: LD_INT 332
7392: PPUSH
7393: LD_INT 23
7395: PPUSH
7396: LD_INT 3
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 48
7404: PPUSH
7405: CALL_OW 125
// end ;
7409: LD_VAR 0 1
7413: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7414: LD_EXP 3
7418: NOT
7419: PUSH
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 1
7425: PPUSH
7426: CALL 46139 0 2
7430: NOT
7431: AND
7432: IFFALSE 8272
7434: GO 7436
7436: DISABLE
7437: LD_INT 0
7439: PPUSH
7440: PPUSH
7441: PPUSH
// begin enable ;
7442: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7443: LD_INT 22
7445: PUSH
7446: LD_INT 8
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: LD_INT 23
7455: PUSH
7456: LD_INT 2
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 30
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: NOT
7483: IFFALSE 7487
// exit ;
7485: GO 8272
// if Prob ( 40 ) then
7487: LD_INT 40
7489: PPUSH
7490: CALL_OW 13
7494: IFFALSE 7621
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7496: LD_INT 3
7498: PPUSH
7499: LD_INT 14
7501: PUSH
7502: LD_INT 1
7504: PUSH
7505: LD_INT 2
7507: PUSH
7508: LD_INT 28
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 14
7519: PUSH
7520: LD_INT 1
7522: PUSH
7523: LD_INT 2
7525: PUSH
7526: LD_INT 28
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: LIST
7533: LIST
7534: PUSH
7535: LD_INT 14
7537: PUSH
7538: LD_INT 1
7540: PUSH
7541: LD_INT 2
7543: PUSH
7544: LD_INT 28
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: PUSH
7553: LD_INT 14
7555: PUSH
7556: LD_INT 1
7558: PUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 28
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 14
7573: PUSH
7574: LD_INT 1
7576: PUSH
7577: LD_INT 2
7579: PUSH
7580: LD_INT 28
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: LIST
7587: LIST
7588: PUSH
7589: LD_INT 14
7591: PUSH
7592: LD_INT 1
7594: PUSH
7595: LD_INT 2
7597: PUSH
7598: LD_INT 26
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: LIST
7613: LIST
7614: PPUSH
7615: CALL 44721 0 2
// end else
7619: GO 7812
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 14
7626: PUSH
7627: LD_INT 1
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: LD_INT 27
7635: PUSH
7636: LD_INT 26
7638: PUSH
7639: LD_INT 26
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: PUSH
7647: LD_OWVAR 67
7651: ARRAY
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PUSH
7659: LD_INT 14
7661: PUSH
7662: LD_INT 1
7664: PUSH
7665: LD_INT 2
7667: PUSH
7668: LD_INT 27
7670: PUSH
7671: LD_INT 26
7673: PUSH
7674: LD_INT 26
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: PUSH
7682: LD_OWVAR 67
7686: ARRAY
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: PUSH
7694: LD_INT 14
7696: PUSH
7697: LD_INT 1
7699: PUSH
7700: LD_INT 2
7702: PUSH
7703: LD_INT 26
7705: PUSH
7706: LD_INT 26
7708: PUSH
7709: LD_INT 29
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: PUSH
7717: LD_OWVAR 67
7721: ARRAY
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: PUSH
7729: LD_INT 13
7731: PUSH
7732: LD_INT 1
7734: PUSH
7735: LD_INT 2
7737: PUSH
7738: LD_INT 26
7740: PUSH
7741: LD_INT 29
7743: PUSH
7744: LD_INT 29
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: LIST
7751: PUSH
7752: LD_OWVAR 67
7756: ARRAY
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 13
7766: PUSH
7767: LD_INT 1
7769: PUSH
7770: LD_INT 2
7772: PUSH
7773: LD_INT 29
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: LIST
7780: LIST
7781: PUSH
7782: LD_INT 14
7784: PUSH
7785: LD_INT 1
7787: PUSH
7788: LD_INT 2
7790: PUSH
7791: LD_INT 26
7793: PUSH
7794: EMPTY
7795: LIST
7796: LIST
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PPUSH
7808: CALL 44721 0 2
// end ; repeat wait ( 0 0$1 ) ;
7812: LD_INT 35
7814: PPUSH
7815: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7819: LD_INT 3
7821: PPUSH
7822: LD_INT 1
7824: PPUSH
7825: CALL 46139 0 2
7829: PUSH
7830: LD_INT 6
7832: GREATEREQUAL
7833: IFFALSE 7812
// wait ( 0 0$30 ) ;
7835: LD_INT 1050
7837: PPUSH
7838: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7842: LD_ADDR_VAR 0 2
7846: PUSH
7847: LD_INT 3
7849: PPUSH
7850: LD_INT 1
7852: PPUSH
7853: CALL 46139 0 2
7857: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7858: LD_ADDR_EXP 112
7862: PUSH
7863: LD_EXP 112
7867: PPUSH
7868: LD_INT 3
7870: PPUSH
7871: LD_EXP 112
7875: PUSH
7876: LD_INT 3
7878: ARRAY
7879: PUSH
7880: LD_VAR 0 2
7884: DIFF
7885: PPUSH
7886: CALL_OW 1
7890: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7891: LD_ADDR_VAR 0 3
7895: PUSH
7896: LD_INT 0
7898: PPUSH
7899: LD_INT 2
7901: PPUSH
7902: CALL_OW 12
7906: ST_TO_ADDR
// if target then
7907: LD_VAR 0 3
7911: IFFALSE 8039
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7913: LD_ADDR_VAR 0 2
7917: PUSH
7918: LD_VAR 0 2
7922: PPUSH
7923: LD_INT 24
7925: PUSH
7926: LD_INT 250
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PPUSH
7933: CALL_OW 72
7937: ST_TO_ADDR
// for i in tmp do
7938: LD_ADDR_VAR 0 1
7942: PUSH
7943: LD_VAR 0 2
7947: PUSH
7948: FOR_IN
7949: IFFALSE 7989
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7951: LD_VAR 0 1
7955: PPUSH
7956: LD_INT 89
7958: PPUSH
7959: LD_INT 71
7961: PPUSH
7962: CALL_OW 297
7966: PUSH
7967: LD_INT 9
7969: GREATER
7970: IFFALSE 7987
// ComMoveXY ( i , 89 , 71 ) ;
7972: LD_VAR 0 1
7976: PPUSH
7977: LD_INT 89
7979: PPUSH
7980: LD_INT 71
7982: PPUSH
7983: CALL_OW 111
7987: GO 7948
7989: POP
7990: POP
// wait ( 0 0$1 ) ;
7991: LD_INT 35
7993: PPUSH
7994: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 92
8005: PUSH
8006: LD_INT 89
8008: PUSH
8009: LD_INT 71
8011: PUSH
8012: LD_INT 9
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 72
8025: PUSH
8026: LD_VAR 0 2
8030: PUSH
8031: LD_INT 1
8033: MINUS
8034: GREATEREQUAL
8035: IFFALSE 7913
// end else
8037: GO 8163
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8039: LD_ADDR_VAR 0 2
8043: PUSH
8044: LD_VAR 0 2
8048: PPUSH
8049: LD_INT 24
8051: PUSH
8052: LD_INT 250
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: PPUSH
8059: CALL_OW 72
8063: ST_TO_ADDR
// for i in tmp do
8064: LD_ADDR_VAR 0 1
8068: PUSH
8069: LD_VAR 0 2
8073: PUSH
8074: FOR_IN
8075: IFFALSE 8115
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8077: LD_VAR 0 1
8081: PPUSH
8082: LD_INT 147
8084: PPUSH
8085: LD_INT 4
8087: PPUSH
8088: CALL_OW 297
8092: PUSH
8093: LD_INT 9
8095: GREATER
8096: IFFALSE 8113
// ComMoveXY ( i , 147 , 4 ) ;
8098: LD_VAR 0 1
8102: PPUSH
8103: LD_INT 147
8105: PPUSH
8106: LD_INT 4
8108: PPUSH
8109: CALL_OW 111
8113: GO 8074
8115: POP
8116: POP
// wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8124: LD_VAR 0 2
8128: PPUSH
8129: LD_INT 92
8131: PUSH
8132: LD_INT 147
8134: PUSH
8135: LD_INT 4
8137: PUSH
8138: LD_INT 9
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: LIST
8145: LIST
8146: PPUSH
8147: CALL_OW 72
8151: PUSH
8152: LD_VAR 0 2
8156: PUSH
8157: LD_INT 1
8159: MINUS
8160: GREATEREQUAL
8161: IFFALSE 8039
// end ; repeat wait ( 0 0$1 ) ;
8163: LD_INT 35
8165: PPUSH
8166: CALL_OW 67
// for i in tmp do
8170: LD_ADDR_VAR 0 1
8174: PUSH
8175: LD_VAR 0 2
8179: PUSH
8180: FOR_IN
8181: IFFALSE 8263
// begin if GetLives ( i ) > 251 then
8183: LD_VAR 0 1
8187: PPUSH
8188: CALL_OW 256
8192: PUSH
8193: LD_INT 251
8195: GREATER
8196: IFFALSE 8234
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8198: LD_VAR 0 1
8202: PPUSH
8203: LD_INT 81
8205: PUSH
8206: LD_INT 8
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL_OW 69
8217: PPUSH
8218: LD_VAR 0 1
8222: PPUSH
8223: CALL_OW 74
8227: PPUSH
8228: CALL_OW 115
8232: GO 8261
// if IsDead ( i ) then
8234: LD_VAR 0 1
8238: PPUSH
8239: CALL_OW 301
8243: IFFALSE 8261
// tmp := tmp diff i ;
8245: LD_ADDR_VAR 0 2
8249: PUSH
8250: LD_VAR 0 2
8254: PUSH
8255: LD_VAR 0 1
8259: DIFF
8260: ST_TO_ADDR
// end ;
8261: GO 8180
8263: POP
8264: POP
// until not tmp ;
8265: LD_VAR 0 2
8269: NOT
8270: IFFALSE 8163
// end ;
8272: PPOPN 3
8274: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8275: LD_EXP 55
8279: PPUSH
8280: CALL_OW 302
8284: PUSH
8285: LD_EXP 3
8289: NOT
8290: AND
8291: IFFALSE 8300
8293: GO 8295
8295: DISABLE
// BuildKozlovBomb ;
8296: CALL 7287 0 0
8300: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8301: LD_INT 22
8303: PUSH
8304: LD_INT 8
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: PUSH
8311: LD_INT 34
8313: PUSH
8314: LD_INT 48
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: PPUSH
8325: CALL_OW 69
8329: IFFALSE 8377
8331: GO 8333
8333: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8334: LD_INT 22
8336: PUSH
8337: LD_INT 8
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: PUSH
8344: LD_INT 34
8346: PUSH
8347: LD_INT 48
8349: PUSH
8350: EMPTY
8351: LIST
8352: LIST
8353: PUSH
8354: EMPTY
8355: LIST
8356: LIST
8357: PPUSH
8358: CALL_OW 69
8362: PUSH
8363: LD_INT 1
8365: ARRAY
8366: PPUSH
8367: LD_INT 173
8369: PPUSH
8370: LD_INT 96
8372: PPUSH
8373: CALL_OW 116
// end ; end_of_file
8377: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8378: LD_INT 0
8380: PPUSH
8381: PPUSH
8382: PPUSH
8383: PPUSH
8384: PPUSH
8385: PPUSH
8386: PPUSH
8387: PPUSH
8388: PPUSH
// side := 3 ;
8389: LD_ADDR_VAR 0 6
8393: PUSH
8394: LD_INT 3
8396: ST_TO_ADDR
// InitHc ;
8397: CALL_OW 19
// uc_side := side ;
8401: LD_ADDR_OWVAR 20
8405: PUSH
8406: LD_VAR 0 6
8410: ST_TO_ADDR
// uc_nation := 3 ;
8411: LD_ADDR_OWVAR 21
8415: PUSH
8416: LD_INT 3
8418: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8419: LD_ADDR_VAR 0 2
8423: PUSH
8424: LD_INT 22
8426: PUSH
8427: LD_VAR 0 6
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PUSH
8436: LD_INT 21
8438: PUSH
8439: LD_INT 3
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: PPUSH
8450: CALL_OW 69
8454: PUSH
8455: FOR_IN
8456: IFFALSE 8472
// SetBLevel ( i , 10 ) ;
8458: LD_VAR 0 2
8462: PPUSH
8463: LD_INT 10
8465: PPUSH
8466: CALL_OW 241
8470: GO 8455
8472: POP
8473: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8474: LD_ADDR_VAR 0 9
8478: PUSH
8479: LD_INT 22
8481: PUSH
8482: LD_VAR 0 6
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PUSH
8491: LD_INT 30
8493: PUSH
8494: LD_INT 34
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PPUSH
8505: CALL_OW 69
8509: ST_TO_ADDR
// if teleport then
8510: LD_VAR 0 9
8514: IFFALSE 8535
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8516: LD_VAR 0 9
8520: PUSH
8521: LD_INT 1
8523: ARRAY
8524: PPUSH
8525: LD_INT 123
8527: PPUSH
8528: LD_INT 122
8530: PPUSH
8531: CALL_OW 243
// hc_importance := 0 ;
8535: LD_ADDR_OWVAR 32
8539: PUSH
8540: LD_INT 0
8542: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8543: LD_ADDR_EXP 56
8547: PUSH
8548: LD_STRING Platonov
8550: PPUSH
8551: CALL_OW 25
8555: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8556: LD_ADDR_EXP 57
8560: PUSH
8561: LD_STRING Yakotich
8563: PPUSH
8564: CALL_OW 25
8568: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8569: LD_ADDR_EXP 58
8573: PUSH
8574: LD_STRING Gleb
8576: PPUSH
8577: CALL_OW 25
8581: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8582: LD_STRING 03_Cornel
8584: PPUSH
8585: CALL_OW 28
8589: IFFALSE 8637
// begin Bierezov := NewCharacter ( Mikhail ) ;
8591: LD_ADDR_EXP 59
8595: PUSH
8596: LD_STRING Mikhail
8598: PPUSH
8599: CALL_OW 25
8603: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8604: LD_EXP 59
8608: PPUSH
8609: LD_INT 197
8611: PPUSH
8612: LD_INT 111
8614: PPUSH
8615: LD_INT 9
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8625: LD_EXP 59
8629: PPUSH
8630: LD_INT 3
8632: PPUSH
8633: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8637: LD_EXP 56
8641: PPUSH
8642: LD_INT 126
8644: PPUSH
8645: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8649: LD_EXP 57
8653: PPUSH
8654: LD_INT 197
8656: PPUSH
8657: LD_INT 111
8659: PPUSH
8660: LD_INT 9
8662: PPUSH
8663: LD_INT 0
8665: PPUSH
8666: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8670: LD_EXP 58
8674: PPUSH
8675: LD_INT 197
8677: PPUSH
8678: LD_INT 111
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: LD_INT 0
8686: PPUSH
8687: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8691: LD_ADDR_VAR 0 5
8695: PUSH
8696: LD_INT 126
8698: PPUSH
8699: LD_INT 2
8701: PPUSH
8702: LD_STRING zhukov
8704: PPUSH
8705: LD_INT 9
8707: PUSH
8708: LD_INT 10
8710: PUSH
8711: LD_INT 10
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: LIST
8718: PUSH
8719: LD_OWVAR 67
8723: ARRAY
8724: PPUSH
8725: LD_INT 9000
8727: PUSH
8728: LD_INT 1000
8730: PUSH
8731: LD_INT 300
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: PPUSH
8739: LD_INT 21
8741: PUSH
8742: LD_INT 8
8744: PUSH
8745: LD_INT 13
8747: PUSH
8748: LD_INT 8
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: LIST
8756: PPUSH
8757: CALL 59429 0 6
8761: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_INT 267
8769: PPUSH
8770: CALL_OW 274
8774: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8775: LD_VAR 0 4
8779: PPUSH
8780: LD_INT 1
8782: PPUSH
8783: LD_INT 5000
8785: PPUSH
8786: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8790: LD_VAR 0 4
8794: PPUSH
8795: LD_INT 2
8797: PPUSH
8798: LD_INT 200
8800: PPUSH
8801: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8805: LD_VAR 0 4
8809: PPUSH
8810: LD_INT 3
8812: PPUSH
8813: LD_INT 200
8815: PPUSH
8816: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8820: LD_ADDR_EXP 93
8824: PUSH
8825: LD_EXP 93
8829: PPUSH
8830: LD_INT 2
8832: PPUSH
8833: LD_VAR 0 5
8837: PUSH
8838: LD_INT 22
8840: PUSH
8841: LD_VAR 0 6
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: LD_INT 21
8855: PUSH
8856: LD_INT 2
8858: PUSH
8859: EMPTY
8860: LIST
8861: LIST
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PPUSH
8871: CALL_OW 69
8875: UNION
8876: PUSH
8877: LD_EXP 56
8881: DIFF
8882: PPUSH
8883: CALL_OW 1
8887: ST_TO_ADDR
// behemoths := [ ] ;
8888: LD_ADDR_EXP 60
8892: PUSH
8893: EMPTY
8894: ST_TO_ADDR
// behemothBuilders := [ ] ;
8895: LD_ADDR_EXP 61
8899: PUSH
8900: EMPTY
8901: ST_TO_ADDR
// j := 3 ;
8902: LD_ADDR_VAR 0 3
8906: PUSH
8907: LD_INT 3
8909: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_INT 22
8917: PUSH
8918: LD_INT 3
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 25
8927: PUSH
8928: LD_INT 3
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: PPUSH
8939: CALL_OW 69
8943: PUSH
8944: FOR_IN
8945: IFFALSE 8995
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8947: LD_ADDR_EXP 61
8951: PUSH
8952: LD_EXP 61
8956: PPUSH
8957: LD_VAR 0 2
8961: PPUSH
8962: CALL 87856 0 2
8966: ST_TO_ADDR
// j := j - 1 ;
8967: LD_ADDR_VAR 0 3
8971: PUSH
8972: LD_VAR 0 3
8976: PUSH
8977: LD_INT 1
8979: MINUS
8980: ST_TO_ADDR
// if j = 0 then
8981: LD_VAR 0 3
8985: PUSH
8986: LD_INT 0
8988: EQUAL
8989: IFFALSE 8993
// break ;
8991: GO 8995
// end ;
8993: GO 8944
8995: POP
8996: POP
// end ;
8997: LD_VAR 0 1
9001: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9002: LD_INT 0
9004: PPUSH
9005: PPUSH
9006: PPUSH
9007: PPUSH
9008: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9009: LD_ADDR_VAR 0 4
9013: PUSH
9014: LD_INT 209
9016: PUSH
9017: LD_INT 149
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 219
9026: PUSH
9027: LD_INT 154
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: PUSH
9034: LD_INT 223
9036: PUSH
9037: LD_INT 149
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: PUSH
9044: LD_INT 232
9046: PUSH
9047: LD_INT 155
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: LIST
9058: LIST
9059: ST_TO_ADDR
// if not behemothBuilders then
9060: LD_EXP 61
9064: NOT
9065: IFFALSE 9069
// exit ;
9067: GO 9173
// j := 1 ;
9069: LD_ADDR_VAR 0 3
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// for i in behemothBuilders do
9077: LD_ADDR_VAR 0 2
9081: PUSH
9082: LD_EXP 61
9086: PUSH
9087: FOR_IN
9088: IFFALSE 9171
// begin if IsInUnit ( i ) then
9090: LD_VAR 0 2
9094: PPUSH
9095: CALL_OW 310
9099: IFFALSE 9110
// ComExitBuilding ( i ) ;
9101: LD_VAR 0 2
9105: PPUSH
9106: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9110: LD_VAR 0 2
9114: PPUSH
9115: LD_INT 37
9117: PPUSH
9118: LD_VAR 0 4
9122: PUSH
9123: LD_VAR 0 3
9127: ARRAY
9128: PUSH
9129: LD_INT 1
9131: ARRAY
9132: PPUSH
9133: LD_VAR 0 4
9137: PUSH
9138: LD_VAR 0 3
9142: ARRAY
9143: PUSH
9144: LD_INT 2
9146: ARRAY
9147: PPUSH
9148: LD_INT 0
9150: PPUSH
9151: CALL_OW 230
// j := j + 1 ;
9155: LD_ADDR_VAR 0 3
9159: PUSH
9160: LD_VAR 0 3
9164: PUSH
9165: LD_INT 1
9167: PLUS
9168: ST_TO_ADDR
// end ;
9169: GO 9087
9171: POP
9172: POP
// end ;
9173: LD_VAR 0 1
9177: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9178: LD_INT 3
9180: PPUSH
9181: CALL 87917 0 1
9185: PUSH
9186: LD_INT 22
9188: PUSH
9189: LD_INT 3
9191: PUSH
9192: EMPTY
9193: LIST
9194: LIST
9195: PUSH
9196: LD_INT 30
9198: PUSH
9199: LD_INT 37
9201: PUSH
9202: EMPTY
9203: LIST
9204: LIST
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: PPUSH
9210: CALL_OW 69
9214: NOT
9215: AND
9216: IFFALSE 9402
9218: GO 9220
9220: DISABLE
9221: LD_INT 0
9223: PPUSH
9224: PPUSH
// begin enable ;
9225: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9226: LD_ADDR_VAR 0 2
9230: PUSH
9231: LD_INT 3
9233: PPUSH
9234: CALL 87917 0 1
9238: ST_TO_ADDR
// for i in tmp do
9239: LD_ADDR_VAR 0 1
9243: PUSH
9244: LD_VAR 0 2
9248: PUSH
9249: FOR_IN
9250: IFFALSE 9400
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9252: LD_VAR 0 1
9256: PPUSH
9257: LD_INT 7
9259: PPUSH
9260: CALL_OW 308
9264: PUSH
9265: LD_VAR 0 1
9269: PPUSH
9270: CALL_OW 110
9274: PUSH
9275: LD_INT 2
9277: EQUAL
9278: NOT
9279: AND
9280: IFFALSE 9294
// SetTag ( i , 2 ) ;
9282: LD_VAR 0 1
9286: PPUSH
9287: LD_INT 2
9289: PPUSH
9290: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9294: LD_INT 81
9296: PUSH
9297: LD_INT 3
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: LD_INT 91
9306: PUSH
9307: LD_VAR 0 1
9311: PUSH
9312: LD_INT 12
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: LIST
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PPUSH
9324: CALL_OW 69
9328: NOT
9329: PUSH
9330: LD_VAR 0 1
9334: PPUSH
9335: CALL_OW 110
9339: PUSH
9340: LD_INT 2
9342: EQUAL
9343: NOT
9344: AND
9345: IFFALSE 9364
// ComAgressiveMove ( i , 64 , 93 ) else
9347: LD_VAR 0 1
9351: PPUSH
9352: LD_INT 64
9354: PPUSH
9355: LD_INT 93
9357: PPUSH
9358: CALL_OW 114
9362: GO 9398
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9364: LD_VAR 0 1
9368: PPUSH
9369: LD_INT 81
9371: PUSH
9372: LD_INT 3
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PPUSH
9379: CALL_OW 69
9383: PPUSH
9384: LD_VAR 0 1
9388: PPUSH
9389: CALL_OW 74
9393: PPUSH
9394: CALL_OW 115
// end ;
9398: GO 9249
9400: POP
9401: POP
// end ;
9402: PPOPN 2
9404: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9405: LD_EXP 2
9409: NOT
9410: PUSH
9411: LD_INT 2
9413: PPUSH
9414: LD_INT 1
9416: PPUSH
9417: CALL 46139 0 2
9421: NOT
9422: AND
9423: IFFALSE 10343
9425: GO 9427
9427: DISABLE
9428: LD_INT 0
9430: PPUSH
9431: PPUSH
9432: PPUSH
9433: PPUSH
// begin enable ;
9434: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9435: LD_INT 22
9437: PUSH
9438: LD_INT 3
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: LD_INT 30
9447: PUSH
9448: LD_INT 3
9450: PUSH
9451: EMPTY
9452: LIST
9453: LIST
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: PPUSH
9459: CALL_OW 69
9463: NOT
9464: IFFALSE 9468
// exit ;
9466: GO 10343
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9468: LD_ADDR_VAR 0 4
9472: PUSH
9473: LD_INT 22
9475: PUSH
9476: LD_INT 3
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 30
9485: PUSH
9486: LD_INT 34
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: PPUSH
9497: CALL_OW 69
9501: ST_TO_ADDR
// if Prob ( 40 ) then
9502: LD_INT 40
9504: PPUSH
9505: CALL_OW 13
9509: IFFALSE 9636
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9511: LD_INT 2
9513: PPUSH
9514: LD_INT 22
9516: PUSH
9517: LD_INT 3
9519: PUSH
9520: LD_INT 3
9522: PUSH
9523: LD_INT 49
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: PUSH
9532: LD_INT 22
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: LD_INT 3
9540: PUSH
9541: LD_INT 49
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_INT 22
9552: PUSH
9553: LD_INT 3
9555: PUSH
9556: LD_INT 3
9558: PUSH
9559: LD_INT 49
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: PUSH
9568: LD_INT 24
9570: PUSH
9571: LD_INT 3
9573: PUSH
9574: LD_INT 3
9576: PUSH
9577: LD_INT 46
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: PUSH
9586: LD_INT 24
9588: PUSH
9589: LD_INT 3
9591: PUSH
9592: LD_INT 3
9594: PUSH
9595: LD_INT 46
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 24
9606: PUSH
9607: LD_INT 3
9609: PUSH
9610: LD_INT 3
9612: PUSH
9613: LD_INT 46
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: PPUSH
9630: CALL 44721 0 2
// end else
9634: GO 9759
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9636: LD_INT 2
9638: PPUSH
9639: LD_INT 24
9641: PUSH
9642: LD_INT 3
9644: PUSH
9645: LD_INT 3
9647: PUSH
9648: LD_INT 47
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: PUSH
9657: LD_INT 24
9659: PUSH
9660: LD_INT 3
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: LD_INT 47
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: PUSH
9675: LD_INT 24
9677: PUSH
9678: LD_INT 3
9680: PUSH
9681: LD_INT 3
9683: PUSH
9684: LD_INT 47
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: PUSH
9693: LD_INT 24
9695: PUSH
9696: LD_INT 3
9698: PUSH
9699: LD_INT 3
9701: PUSH
9702: LD_INT 46
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: PUSH
9711: LD_INT 24
9713: PUSH
9714: LD_INT 3
9716: PUSH
9717: LD_INT 3
9719: PUSH
9720: LD_INT 46
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: LIST
9728: PUSH
9729: LD_INT 24
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 3
9737: PUSH
9738: LD_INT 46
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: LIST
9745: LIST
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: PPUSH
9755: CALL 44721 0 2
// end ; if Difficulty > 1 then
9759: LD_OWVAR 67
9763: PUSH
9764: LD_INT 1
9766: GREATER
9767: IFFALSE 9797
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9769: LD_INT 2
9771: PPUSH
9772: LD_INT 24
9774: PUSH
9775: LD_INT 3
9777: PUSH
9778: LD_INT 3
9780: PUSH
9781: LD_INT 47
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: EMPTY
9791: LIST
9792: PPUSH
9793: CALL 44721 0 2
// repeat wait ( 0 0$1 ) ;
9797: LD_INT 35
9799: PPUSH
9800: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9804: LD_INT 2
9806: PPUSH
9807: LD_INT 1
9809: PPUSH
9810: CALL 46139 0 2
9814: PUSH
9815: LD_INT 6
9817: PUSH
9818: LD_INT 7
9820: PUSH
9821: LD_INT 7
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: LD_OWVAR 67
9833: ARRAY
9834: GREATEREQUAL
9835: IFFALSE 9797
// wait ( 0 0$30 ) ;
9837: LD_INT 1050
9839: PPUSH
9840: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9844: LD_ADDR_VAR 0 2
9848: PUSH
9849: LD_INT 2
9851: PPUSH
9852: LD_INT 1
9854: PPUSH
9855: CALL 46139 0 2
9859: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9860: LD_ADDR_EXP 112
9864: PUSH
9865: LD_EXP 112
9869: PPUSH
9870: LD_INT 2
9872: PPUSH
9873: LD_EXP 112
9877: PUSH
9878: LD_INT 2
9880: ARRAY
9881: PUSH
9882: LD_VAR 0 2
9886: DIFF
9887: PPUSH
9888: CALL_OW 1
9892: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9893: LD_ADDR_VAR 0 3
9897: PUSH
9898: LD_INT 0
9900: PPUSH
9901: LD_INT 1
9903: PPUSH
9904: CALL_OW 12
9908: ST_TO_ADDR
// if target then
9909: LD_VAR 0 3
9913: IFFALSE 10041
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9915: LD_ADDR_VAR 0 2
9919: PUSH
9920: LD_VAR 0 2
9924: PPUSH
9925: LD_INT 24
9927: PUSH
9928: LD_INT 250
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: PPUSH
9935: CALL_OW 72
9939: ST_TO_ADDR
// for i in tmp do
9940: LD_ADDR_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: FOR_IN
9951: IFFALSE 9991
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9953: LD_VAR 0 1
9957: PPUSH
9958: LD_INT 139
9960: PPUSH
9961: LD_INT 89
9963: PPUSH
9964: CALL_OW 297
9968: PUSH
9969: LD_INT 9
9971: GREATER
9972: IFFALSE 9989
// ComMoveXY ( i , 139 , 89 ) ;
9974: LD_VAR 0 1
9978: PPUSH
9979: LD_INT 139
9981: PPUSH
9982: LD_INT 89
9984: PPUSH
9985: CALL_OW 111
9989: GO 9950
9991: POP
9992: POP
// wait ( 0 0$1 ) ;
9993: LD_INT 35
9995: PPUSH
9996: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10000: LD_VAR 0 2
10004: PPUSH
10005: LD_INT 92
10007: PUSH
10008: LD_INT 139
10010: PUSH
10011: LD_INT 89
10013: PUSH
10014: LD_INT 9
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: LIST
10021: LIST
10022: PPUSH
10023: CALL_OW 72
10027: PUSH
10028: LD_VAR 0 2
10032: PUSH
10033: LD_INT 1
10035: MINUS
10036: GREATEREQUAL
10037: IFFALSE 9915
// end else
10039: GO 10183
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10041: LD_VAR 0 2
10045: PPUSH
10046: LD_VAR 0 4
10050: PUSH
10051: LD_INT 1
10053: ARRAY
10054: PPUSH
10055: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10059: LD_ADDR_VAR 0 2
10063: PUSH
10064: LD_VAR 0 2
10068: PPUSH
10069: LD_INT 24
10071: PUSH
10072: LD_INT 250
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: PPUSH
10079: CALL_OW 72
10083: ST_TO_ADDR
// for i in tmp do
10084: LD_ADDR_VAR 0 1
10088: PUSH
10089: LD_VAR 0 2
10093: PUSH
10094: FOR_IN
10095: IFFALSE 10135
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10097: LD_VAR 0 1
10101: PPUSH
10102: LD_INT 124
10104: PPUSH
10105: LD_INT 139
10107: PPUSH
10108: CALL_OW 297
10112: PUSH
10113: LD_INT 9
10115: GREATER
10116: IFFALSE 10133
// ComMoveXY ( i , 124 , 139 ) ;
10118: LD_VAR 0 1
10122: PPUSH
10123: LD_INT 124
10125: PPUSH
10126: LD_INT 139
10128: PPUSH
10129: CALL_OW 111
10133: GO 10094
10135: POP
10136: POP
// wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10144: LD_VAR 0 2
10148: PPUSH
10149: LD_INT 92
10151: PUSH
10152: LD_INT 124
10154: PUSH
10155: LD_INT 139
10157: PUSH
10158: LD_INT 9
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: PPUSH
10167: CALL_OW 72
10171: PUSH
10172: LD_VAR 0 2
10176: PUSH
10177: LD_INT 1
10179: MINUS
10180: GREATEREQUAL
10181: IFFALSE 10059
// end ; repeat wait ( 0 0$1 ) ;
10183: LD_INT 35
10185: PPUSH
10186: CALL_OW 67
// for i in tmp do
10190: LD_ADDR_VAR 0 1
10194: PUSH
10195: LD_VAR 0 2
10199: PUSH
10200: FOR_IN
10201: IFFALSE 10334
// begin if GetLives ( i ) > 251 then
10203: LD_VAR 0 1
10207: PPUSH
10208: CALL_OW 256
10212: PUSH
10213: LD_INT 251
10215: GREATER
10216: IFFALSE 10305
// begin if GetWeapon ( i ) = ru_time_lapser then
10218: LD_VAR 0 1
10222: PPUSH
10223: CALL_OW 264
10227: PUSH
10228: LD_INT 49
10230: EQUAL
10231: IFFALSE 10269
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10233: LD_VAR 0 1
10237: PPUSH
10238: LD_INT 81
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PPUSH
10253: LD_VAR 0 1
10257: PPUSH
10258: CALL_OW 74
10262: PPUSH
10263: CALL_OW 112
10267: GO 10303
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10269: LD_VAR 0 1
10273: PPUSH
10274: LD_INT 81
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: PPUSH
10284: CALL_OW 69
10288: PPUSH
10289: LD_VAR 0 1
10293: PPUSH
10294: CALL_OW 74
10298: PPUSH
10299: CALL_OW 115
// end else
10303: GO 10332
// if IsDead ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 301
10314: IFFALSE 10332
// tmp := tmp diff i ;
10316: LD_ADDR_VAR 0 2
10320: PUSH
10321: LD_VAR 0 2
10325: PUSH
10326: LD_VAR 0 1
10330: DIFF
10331: ST_TO_ADDR
// end ;
10332: GO 10200
10334: POP
10335: POP
// until not tmp ;
10336: LD_VAR 0 2
10340: NOT
10341: IFFALSE 10183
// end ;
10343: PPOPN 4
10345: END
// every 30 30$00 trigger not russianDestroyed do
10346: LD_EXP 2
10350: NOT
10351: IFFALSE 10416
10353: GO 10355
10355: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10356: LD_INT 105000
10358: PUSH
10359: LD_INT 84000
10361: PUSH
10362: LD_INT 63000
10364: PUSH
10365: EMPTY
10366: LIST
10367: LIST
10368: LIST
10369: PUSH
10370: LD_OWVAR 67
10374: ARRAY
10375: PPUSH
10376: CALL_OW 67
// if russianDestroyed then
10380: LD_EXP 2
10384: IFFALSE 10388
// exit ;
10386: GO 10416
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10388: LD_INT 2
10390: PPUSH
10391: LD_INT 23
10393: PUSH
10394: LD_INT 3
10396: PUSH
10397: LD_INT 1
10399: PUSH
10400: LD_INT 48
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: PUSH
10409: EMPTY
10410: LIST
10411: PPUSH
10412: CALL 44721 0 2
// end ; end_of_file
10416: END
// export function CustomEvent ( event ) ; begin
10417: LD_INT 0
10419: PPUSH
// end ;
10420: LD_VAR 0 2
10424: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10425: LD_VAR 0 2
10429: PPUSH
10430: LD_VAR 0 3
10434: PPUSH
10435: LD_INT 15
10437: PPUSH
10438: CALL_OW 309
10442: IFFALSE 10451
// YouLost ( MothContaminate ) ;
10444: LD_STRING MothContaminate
10446: PPUSH
10447: CALL_OW 104
// end ;
10451: PPOPN 3
10453: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10454: LD_VAR 0 2
10458: PPUSH
10459: LD_VAR 0 3
10463: PPUSH
10464: LD_INT 15
10466: PPUSH
10467: CALL_OW 309
10471: IFFALSE 10487
// begin wait ( 0 0$6 ) ;
10473: LD_INT 210
10475: PPUSH
10476: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10480: LD_STRING MothContaminateBomb
10482: PPUSH
10483: CALL_OW 104
// end ; end ;
10487: PPOPN 3
10489: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10490: LD_VAR 0 1
10494: PUSH
10495: LD_EXP 17
10499: EQUAL
10500: IFFALSE 10511
// begin YouLost ( JMM ) ;
10502: LD_STRING JMM
10504: PPUSH
10505: CALL_OW 104
// exit ;
10509: GO 10610
// end ; if un = Powell then
10511: LD_VAR 0 1
10515: PUSH
10516: LD_EXP 52
10520: EQUAL
10521: IFFALSE 10531
// americanDestroyed := true ;
10523: LD_ADDR_EXP 4
10527: PUSH
10528: LD_INT 1
10530: ST_TO_ADDR
// if un = Platonov then
10531: LD_VAR 0 1
10535: PUSH
10536: LD_EXP 56
10540: EQUAL
10541: IFFALSE 10551
// russianDestroyed := true ;
10543: LD_ADDR_EXP 2
10547: PUSH
10548: LD_INT 1
10550: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10551: LD_VAR 0 1
10555: PUSH
10556: LD_INT 22
10558: PUSH
10559: LD_INT 7
10561: PUSH
10562: EMPTY
10563: LIST
10564: LIST
10565: PUSH
10566: LD_INT 21
10568: PUSH
10569: LD_INT 2
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: PUSH
10576: EMPTY
10577: LIST
10578: LIST
10579: PPUSH
10580: CALL_OW 69
10584: IN
10585: IFFALSE 10601
// vehicleLostCounter := vehicleLostCounter + 1 ;
10587: LD_ADDR_EXP 15
10591: PUSH
10592: LD_EXP 15
10596: PUSH
10597: LD_INT 1
10599: PLUS
10600: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10601: LD_VAR 0 1
10605: PPUSH
10606: CALL 48132 0 1
// end ;
10610: PPOPN 1
10612: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_VAR 0 2
10622: PPUSH
10623: CALL 50466 0 2
// end ;
10627: PPOPN 2
10629: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10630: LD_VAR 0 1
10634: PPUSH
10635: CALL 49534 0 1
// end ;
10639: PPOPN 1
10641: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10642: LD_VAR 0 1
10646: PUSH
10647: LD_INT 22
10649: PUSH
10650: LD_INT 8
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: PUSH
10657: LD_INT 30
10659: PUSH
10660: LD_INT 2
10662: PUSH
10663: EMPTY
10664: LIST
10665: LIST
10666: PUSH
10667: LD_INT 23
10669: PUSH
10670: LD_INT 3
10672: PUSH
10673: EMPTY
10674: LIST
10675: LIST
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: LIST
10681: PPUSH
10682: CALL_OW 69
10686: IN
10687: IFFALSE 10714
// begin ComUpgrade ( building ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10698: LD_EXP 55
10702: PPUSH
10703: LD_VAR 0 1
10707: PPUSH
10708: CALL 58967 0 2
// exit ;
10712: GO 10723
// end ; MCE_BuildingComplete ( building ) ;
10714: LD_VAR 0 1
10718: PPUSH
10719: CALL 49775 0 1
// end ;
10723: PPOPN 1
10725: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10726: LD_VAR 0 1
10730: PPUSH
10731: LD_VAR 0 2
10735: PPUSH
10736: CALL 47828 0 2
// end ;
10740: PPOPN 2
10742: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10743: LD_VAR 0 1
10747: PPUSH
10748: LD_VAR 0 2
10752: PPUSH
10753: LD_VAR 0 3
10757: PPUSH
10758: LD_VAR 0 4
10762: PPUSH
10763: LD_VAR 0 5
10767: PPUSH
10768: CALL 47448 0 5
// end ;
10772: PPOPN 5
10774: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10775: LD_VAR 0 1
10779: PPUSH
10780: LD_VAR 0 2
10784: PPUSH
10785: CALL 47038 0 2
// end ;
10789: PPOPN 2
10791: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10792: LD_VAR 0 1
10796: PPUSH
10797: LD_VAR 0 2
10801: PPUSH
10802: LD_VAR 0 3
10806: PPUSH
10807: LD_VAR 0 4
10811: PPUSH
10812: CALL 46876 0 4
// end ;
10816: PPOPN 4
10818: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10819: LD_VAR 0 1
10823: PPUSH
10824: LD_VAR 0 2
10828: PPUSH
10829: LD_VAR 0 3
10833: PPUSH
10834: CALL 46651 0 3
// end ;
10838: PPOPN 3
10840: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10841: LD_VAR 0 1
10845: PPUSH
10846: LD_VAR 0 2
10850: PPUSH
10851: CALL 46536 0 2
// end ;
10855: PPOPN 2
10857: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10858: LD_VAR 0 1
10862: PPUSH
10863: LD_VAR 0 2
10867: PPUSH
10868: CALL 50761 0 2
// end ;
10872: PPOPN 2
10874: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10875: LD_VAR 0 1
10879: PPUSH
10880: LD_VAR 0 2
10884: PPUSH
10885: LD_VAR 0 3
10889: PPUSH
10890: LD_VAR 0 4
10894: PPUSH
10895: CALL 50977 0 4
// end ;
10899: PPOPN 4
10901: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10902: LD_VAR 0 1
10906: PPUSH
10907: LD_VAR 0 2
10911: PPUSH
10912: CALL 46345 0 2
// end ;
10916: PPOPN 2
10918: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10919: LD_VAR 0 1
10923: PPUSH
10924: CALL 102870 0 1
// end ; end_of_file
10928: PPOPN 1
10930: END
// export function Action ; begin
10931: LD_INT 0
10933: PPUSH
// InGameOn ;
10934: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10938: LD_INT 206
10940: PPUSH
10941: LD_INT 11
10943: PPUSH
10944: CALL_OW 86
// wait ( 0 0$1 ) ;
10948: LD_INT 35
10950: PPUSH
10951: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10955: LD_EXP 17
10959: PPUSH
10960: LD_STRING DStart-JMM-JMM-1
10962: PPUSH
10963: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10967: LD_EXP 49
10971: PPUSH
10972: LD_STRING DStart-JMM-Bur-1
10974: PPUSH
10975: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10979: LD_EXP 17
10983: PPUSH
10984: LD_STRING DStart-JMM-JMM-2
10986: PPUSH
10987: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10991: LD_EXP 49
10995: PPUSH
10996: LD_STRING DStart-JMM-Bur-2
10998: PPUSH
10999: CALL_OW 88
// InGameOff ;
11003: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11007: LD_STRING MStart
11009: PPUSH
11010: CALL_OW 337
// SaveForQuickRestart ;
11014: CALL_OW 22
// end ;
11018: LD_VAR 0 1
11022: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11023: LD_INT 7
11025: PPUSH
11026: LD_INT 255
11028: PPUSH
11029: LD_INT 219
11031: PPUSH
11032: CALL_OW 293
11036: IFFALSE 11645
11038: GO 11040
11040: DISABLE
11041: LD_INT 0
11043: PPUSH
// begin wait ( 0 0$3 ) ;
11044: LD_INT 105
11046: PPUSH
11047: CALL_OW 67
// alienSpotted := true ;
11051: LD_ADDR_EXP 10
11055: PUSH
11056: LD_INT 1
11058: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11059: LD_ADDR_VAR 0 1
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 7
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: LD_INT 23
11076: PUSH
11077: LD_INT 3
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PUSH
11084: LD_INT 21
11086: PUSH
11087: LD_INT 1
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: LD_INT 26
11096: PUSH
11097: LD_INT 1
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: PPUSH
11110: CALL_OW 69
11114: PUSH
11115: LD_EXP 49
11119: PUSH
11120: LD_EXP 37
11124: PUSH
11125: LD_EXP 39
11129: PUSH
11130: LD_EXP 40
11134: PUSH
11135: LD_EXP 47
11139: PUSH
11140: LD_EXP 46
11144: PUSH
11145: LD_EXP 41
11149: PUSH
11150: EMPTY
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: DIFF
11159: ST_TO_ADDR
// DialogueOn ;
11160: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11164: LD_INT 255
11166: PPUSH
11167: LD_INT 219
11169: PPUSH
11170: LD_INT 7
11172: PPUSH
11173: LD_INT 20
11175: NEG
11176: PPUSH
11177: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11181: LD_INT 255
11183: PPUSH
11184: LD_INT 219
11186: PPUSH
11187: CALL_OW 86
// if speaker then
11191: LD_VAR 0 1
11195: IFFALSE 11213
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11197: LD_VAR 0 1
11201: PUSH
11202: LD_INT 1
11204: ARRAY
11205: PPUSH
11206: LD_STRING DAlienBase-RSol1-1
11208: PPUSH
11209: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11213: LD_EXP 17
11217: PPUSH
11218: LD_STRING DAlienBase-JMM-1
11220: PPUSH
11221: CALL_OW 88
// if IsOk ( Burlak ) then
11225: LD_EXP 49
11229: PPUSH
11230: CALL_OW 302
11234: IFFALSE 11255
// begin dwait ( 0 0$1 ) ;
11236: LD_INT 35
11238: PPUSH
11239: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11243: LD_EXP 49
11247: PPUSH
11248: LD_STRING DAlienBase-Bur-1
11250: PPUSH
11251: CALL_OW 88
// end ; if IsOk ( Roth ) then
11255: LD_EXP 18
11259: PPUSH
11260: CALL_OW 302
11264: IFFALSE 11278
// Say ( Roth , DAlienBase-Roth-1 ) ;
11266: LD_EXP 18
11270: PPUSH
11271: LD_STRING DAlienBase-Roth-1
11273: PPUSH
11274: CALL_OW 88
// if IsOk ( Gossudarov ) then
11278: LD_EXP 35
11282: PPUSH
11283: CALL_OW 302
11287: IFFALSE 11303
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11289: LD_EXP 35
11293: PPUSH
11294: LD_STRING DAlienBase-Gos-1
11296: PPUSH
11297: CALL_OW 88
11301: GO 11420
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11303: LD_ADDR_VAR 0 1
11307: PUSH
11308: LD_INT 22
11310: PUSH
11311: LD_INT 7
11313: PUSH
11314: EMPTY
11315: LIST
11316: LIST
11317: PUSH
11318: LD_INT 25
11320: PUSH
11321: LD_INT 4
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: PUSH
11328: LD_INT 21
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 26
11340: PUSH
11341: LD_INT 1
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: EMPTY
11349: LIST
11350: LIST
11351: LIST
11352: LIST
11353: PPUSH
11354: CALL_OW 69
11358: PUSH
11359: LD_EXP 18
11363: PUSH
11364: LD_EXP 17
11368: PUSH
11369: LD_EXP 49
11373: PUSH
11374: LD_EXP 37
11378: PUSH
11379: LD_EXP 47
11383: PUSH
11384: LD_EXP 46
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: DIFF
11397: ST_TO_ADDR
// if speaker then
11398: LD_VAR 0 1
11402: IFFALSE 11420
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11404: LD_VAR 0 1
11408: PUSH
11409: LD_INT 1
11411: ARRAY
11412: PPUSH
11413: LD_STRING DAlienBase-Sci1-1
11415: PPUSH
11416: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11420: LD_INT 255
11422: PPUSH
11423: LD_INT 219
11425: PPUSH
11426: LD_INT 7
11428: PPUSH
11429: CALL_OW 331
// DialogueOff ;
11433: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11437: LD_INT 35
11439: PPUSH
11440: CALL_OW 67
// until IsSelected ( alien ) ;
11444: LD_INT 1
11446: PPUSH
11447: CALL_OW 306
11451: IFFALSE 11437
// if not artifactIResearched or not artifactIIResearched then
11453: LD_EXP 12
11457: NOT
11458: PUSH
11459: LD_EXP 13
11463: NOT
11464: OR
11465: IFFALSE 11645
// begin if IsOk ( Roth ) then
11467: LD_EXP 18
11471: PPUSH
11472: CALL_OW 302
11476: IFFALSE 11492
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11478: LD_EXP 18
11482: PPUSH
11483: LD_STRING DAlieBaseNotReady-Roth-1
11485: PPUSH
11486: CALL_OW 88
11490: GO 11645
// if IsOk ( Gossudarov ) then
11492: LD_EXP 35
11496: PPUSH
11497: CALL_OW 302
11501: IFFALSE 11517
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11503: LD_EXP 35
11507: PPUSH
11508: LD_STRING DAlieBaseNotReady-Gos-1
11510: PPUSH
11511: CALL_OW 88
11515: GO 11645
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11517: LD_ADDR_VAR 0 1
11521: PUSH
11522: LD_INT 22
11524: PUSH
11525: LD_INT 7
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: PUSH
11532: LD_INT 23
11534: PUSH
11535: LD_INT 3
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 4
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 21
11554: PUSH
11555: LD_INT 1
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 26
11564: PUSH
11565: LD_INT 1
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: PPUSH
11579: CALL_OW 69
11583: PUSH
11584: LD_EXP 18
11588: PUSH
11589: LD_EXP 17
11593: PUSH
11594: LD_EXP 49
11598: PUSH
11599: LD_EXP 37
11603: PUSH
11604: LD_EXP 47
11608: PUSH
11609: LD_EXP 46
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: DIFF
11622: ST_TO_ADDR
// if speaker then
11623: LD_VAR 0 1
11627: IFFALSE 11645
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11629: LD_VAR 0 1
11633: PUSH
11634: LD_INT 1
11636: ARRAY
11637: PPUSH
11638: LD_STRING DAlieBaseNotReady-RSci1-1
11640: PPUSH
11641: CALL_OW 88
// end ; end ; end ;
11645: PPOPN 1
11647: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11648: LD_INT 24
11650: PPUSH
11651: LD_INT 7
11653: PPUSH
11654: CALL_OW 321
11658: PUSH
11659: LD_INT 2
11661: EQUAL
11662: IFFALSE 12353
11664: GO 11666
11666: DISABLE
11667: LD_INT 0
11669: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11670: LD_ADDR_VAR 0 1
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_INT 7
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PUSH
11685: LD_INT 23
11687: PUSH
11688: LD_INT 3
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PUSH
11695: LD_INT 25
11697: PUSH
11698: LD_INT 4
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: PUSH
11705: LD_INT 21
11707: PUSH
11708: LD_INT 1
11710: PUSH
11711: EMPTY
11712: LIST
11713: LIST
11714: PUSH
11715: LD_INT 26
11717: PUSH
11718: LD_INT 1
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: PPUSH
11732: CALL_OW 69
11736: PUSH
11737: LD_EXP 18
11741: PUSH
11742: LD_EXP 17
11746: PUSH
11747: LD_EXP 49
11751: PUSH
11752: LD_EXP 37
11756: PUSH
11757: LD_EXP 47
11761: PUSH
11762: LD_EXP 46
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: DIFF
11775: ST_TO_ADDR
// if not speaker then
11776: LD_VAR 0 1
11780: NOT
11781: IFFALSE 11785
// exit ;
11783: GO 12353
// DialogueOn ;
11785: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11789: LD_VAR 0 1
11793: PUSH
11794: LD_INT 1
11796: ARRAY
11797: PPUSH
11798: LD_STRING DArtefTechnology-RSci1-1
11800: PPUSH
11801: CALL_OW 88
// if IsOk ( Burlak ) then
11805: LD_EXP 49
11809: PPUSH
11810: CALL_OW 302
11814: IFFALSE 11828
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11816: LD_EXP 49
11820: PPUSH
11821: LD_STRING DArtefTechnology-Bur-1
11823: PPUSH
11824: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11828: LD_VAR 0 1
11832: PUSH
11833: LD_INT 1
11835: ARRAY
11836: PPUSH
11837: LD_STRING DArtefTechnology-RSci1-2
11839: PPUSH
11840: CALL_OW 88
// if Denis then
11844: LD_EXP 23
11848: IFFALSE 11865
// speaker := [ Denis ] else
11850: LD_ADDR_VAR 0 1
11854: PUSH
11855: LD_EXP 23
11859: PUSH
11860: EMPTY
11861: LIST
11862: ST_TO_ADDR
11863: GO 11971
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11865: LD_ADDR_VAR 0 1
11869: PUSH
11870: LD_INT 22
11872: PUSH
11873: LD_INT 7
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PUSH
11880: LD_INT 23
11882: PUSH
11883: LD_INT 1
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: PUSH
11890: LD_INT 25
11892: PUSH
11893: LD_INT 4
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: PUSH
11900: LD_INT 21
11902: PUSH
11903: LD_INT 1
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 26
11912: PUSH
11913: LD_INT 1
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: LIST
11924: LIST
11925: LIST
11926: PPUSH
11927: CALL_OW 69
11931: PUSH
11932: LD_EXP 18
11936: PUSH
11937: LD_EXP 17
11941: PUSH
11942: LD_EXP 49
11946: PUSH
11947: LD_EXP 37
11951: PUSH
11952: LD_EXP 47
11956: PUSH
11957: LD_EXP 46
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: DIFF
11970: ST_TO_ADDR
// if speaker then
11971: LD_VAR 0 1
11975: IFFALSE 11993
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11977: LD_VAR 0 1
11981: PUSH
11982: LD_INT 1
11984: ARRAY
11985: PPUSH
11986: LD_STRING DArtefTechnology-Sci1-2
11988: PPUSH
11989: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11993: LD_ADDR_VAR 0 1
11997: PUSH
11998: LD_INT 22
12000: PUSH
12001: LD_INT 7
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: PUSH
12008: LD_INT 23
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: EMPTY
12015: LIST
12016: LIST
12017: PUSH
12018: LD_INT 25
12020: PUSH
12021: LD_INT 4
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 21
12030: PUSH
12031: LD_INT 1
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 26
12040: PUSH
12041: LD_INT 1
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: LIST
12054: PPUSH
12055: CALL_OW 69
12059: PUSH
12060: LD_EXP 18
12064: PUSH
12065: LD_EXP 17
12069: PUSH
12070: LD_EXP 49
12074: PUSH
12075: LD_EXP 37
12079: PUSH
12080: LD_EXP 47
12084: PUSH
12085: LD_EXP 46
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: DIFF
12098: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12099: LD_VAR 0 1
12103: PUSH
12104: LD_EXP 9
12108: PUSH
12109: LD_EXP 5
12113: OR
12114: AND
12115: IFFALSE 12349
// begin if arabianDestroyed and IsOk ( Burlak ) then
12117: LD_EXP 5
12121: PUSH
12122: LD_EXP 49
12126: PPUSH
12127: CALL_OW 302
12131: AND
12132: IFFALSE 12148
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12134: LD_EXP 49
12138: PPUSH
12139: LD_STRING DArtefTechnology-Bur-2
12141: PPUSH
12142: CALL_OW 88
12146: GO 12160
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12148: LD_EXP 17
12152: PPUSH
12153: LD_STRING DArtefTechnology-JMM-2
12155: PPUSH
12156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12160: LD_VAR 0 1
12164: PUSH
12165: LD_INT 1
12167: ARRAY
12168: PPUSH
12169: LD_STRING DArtefTechnology-RSci1-3
12171: PPUSH
12172: CALL_OW 88
// if Denis then
12176: LD_EXP 23
12180: IFFALSE 12197
// speaker := [ Denis ] else
12182: LD_ADDR_VAR 0 1
12186: PUSH
12187: LD_EXP 23
12191: PUSH
12192: EMPTY
12193: LIST
12194: ST_TO_ADDR
12195: GO 12303
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12197: LD_ADDR_VAR 0 1
12201: PUSH
12202: LD_INT 22
12204: PUSH
12205: LD_INT 7
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: PUSH
12212: LD_INT 23
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: LD_INT 25
12224: PUSH
12225: LD_INT 4
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 21
12234: PUSH
12235: LD_INT 1
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 26
12244: PUSH
12245: LD_INT 1
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: PPUSH
12259: CALL_OW 69
12263: PUSH
12264: LD_EXP 18
12268: PUSH
12269: LD_EXP 17
12273: PUSH
12274: LD_EXP 49
12278: PUSH
12279: LD_EXP 37
12283: PUSH
12284: LD_EXP 47
12288: PUSH
12289: LD_EXP 46
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: DIFF
12302: ST_TO_ADDR
// if speaker then
12303: LD_VAR 0 1
12307: IFFALSE 12349
// if alienSpotted then
12309: LD_EXP 10
12313: IFFALSE 12333
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12315: LD_VAR 0 1
12319: PUSH
12320: LD_INT 1
12322: ARRAY
12323: PPUSH
12324: LD_STRING DArtefTechnology-Sci1-3
12326: PPUSH
12327: CALL_OW 88
12331: GO 12349
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12333: LD_VAR 0 1
12337: PUSH
12338: LD_INT 1
12340: ARRAY
12341: PPUSH
12342: LD_STRING DArtefTechnology-Sci1-3a
12344: PPUSH
12345: CALL_OW 88
// end ; DialogueOff ;
12349: CALL_OW 7
// end ;
12353: PPOPN 1
12355: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12356: LD_EXP 12
12360: IFFALSE 12555
12362: GO 12364
12364: DISABLE
12365: LD_INT 0
12367: PPUSH
// begin if Denis then
12368: LD_EXP 23
12372: IFFALSE 12389
// speaker := [ Denis ] else
12374: LD_ADDR_VAR 0 1
12378: PUSH
12379: LD_EXP 23
12383: PUSH
12384: EMPTY
12385: LIST
12386: ST_TO_ADDR
12387: GO 12495
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12389: LD_ADDR_VAR 0 1
12393: PUSH
12394: LD_INT 22
12396: PUSH
12397: LD_INT 7
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: PUSH
12404: LD_INT 23
12406: PUSH
12407: LD_INT 1
12409: PUSH
12410: EMPTY
12411: LIST
12412: LIST
12413: PUSH
12414: LD_INT 25
12416: PUSH
12417: LD_INT 4
12419: PUSH
12420: EMPTY
12421: LIST
12422: LIST
12423: PUSH
12424: LD_INT 21
12426: PUSH
12427: LD_INT 1
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: PUSH
12434: LD_INT 26
12436: PUSH
12437: LD_INT 1
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: PPUSH
12451: CALL_OW 69
12455: PUSH
12456: LD_EXP 18
12460: PUSH
12461: LD_EXP 17
12465: PUSH
12466: LD_EXP 49
12470: PUSH
12471: LD_EXP 37
12475: PUSH
12476: LD_EXP 47
12480: PUSH
12481: LD_EXP 46
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: DIFF
12494: ST_TO_ADDR
// if not speaker then
12495: LD_VAR 0 1
12499: NOT
12500: IFFALSE 12504
// exit ;
12502: GO 12555
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12504: LD_VAR 0 1
12508: PUSH
12509: LD_INT 1
12511: ARRAY
12512: PPUSH
12513: LD_STRING DArtefTechnologyAm-Sci1-1
12515: PPUSH
12516: CALL_OW 88
// if IsOk ( Burlak ) then
12520: LD_EXP 49
12524: PPUSH
12525: CALL_OW 302
12529: IFFALSE 12543
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12531: LD_EXP 49
12535: PPUSH
12536: LD_STRING DArtefTechnologyAm-Bur-1
12538: PPUSH
12539: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12543: LD_EXP 17
12547: PPUSH
12548: LD_STRING DArtefTechnologyAm-JMM-1
12550: PPUSH
12551: CALL_OW 88
// end ;
12555: PPOPN 1
12557: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12558: LD_EXP 13
12562: IFFALSE 12752
12564: GO 12566
12566: DISABLE
12567: LD_INT 0
12569: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12570: LD_ADDR_VAR 0 1
12574: PUSH
12575: LD_INT 22
12577: PUSH
12578: LD_INT 7
12580: PUSH
12581: EMPTY
12582: LIST
12583: LIST
12584: PUSH
12585: LD_INT 23
12587: PUSH
12588: LD_INT 3
12590: PUSH
12591: EMPTY
12592: LIST
12593: LIST
12594: PUSH
12595: LD_INT 25
12597: PUSH
12598: LD_INT 4
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: PUSH
12605: LD_INT 21
12607: PUSH
12608: LD_INT 1
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 26
12617: PUSH
12618: LD_INT 1
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: PPUSH
12632: CALL_OW 69
12636: PUSH
12637: LD_EXP 18
12641: PUSH
12642: LD_EXP 17
12646: PUSH
12647: LD_EXP 49
12651: PUSH
12652: LD_EXP 37
12656: PUSH
12657: LD_EXP 47
12661: PUSH
12662: LD_EXP 46
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: DIFF
12675: ST_TO_ADDR
// if not speaker then
12676: LD_VAR 0 1
12680: NOT
12681: IFFALSE 12685
// exit ;
12683: GO 12752
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12685: LD_VAR 0 1
12689: PUSH
12690: LD_INT 1
12692: ARRAY
12693: PPUSH
12694: LD_STRING DArtefTechnologyRu-RSci1-1
12696: PPUSH
12697: CALL_OW 88
// if IsOk ( Burlak ) then
12701: LD_EXP 49
12705: PPUSH
12706: CALL_OW 302
12710: IFFALSE 12724
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12712: LD_EXP 49
12716: PPUSH
12717: LD_STRING DArtefTechnologyRu-Bur-1
12719: PPUSH
12720: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12724: LD_VAR 0 1
12728: PUSH
12729: LD_INT 1
12731: ARRAY
12732: PPUSH
12733: LD_STRING DArtefTechnologyRu-RSci1-2
12735: PPUSH
12736: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12740: LD_EXP 17
12744: PPUSH
12745: LD_STRING DArtefTechnologyRu-JMM-1
12747: PPUSH
12748: CALL_OW 88
// end ;
12752: PPOPN 1
12754: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12755: LD_INT 24
12757: PPUSH
12758: LD_INT 7
12760: PPUSH
12761: CALL_OW 321
12765: PUSH
12766: LD_INT 2
12768: EQUAL
12769: PUSH
12770: LD_INT 1
12772: PPUSH
12773: CALL_OW 255
12777: PUSH
12778: LD_INT 7
12780: EQUAL
12781: AND
12782: IFFALSE 12942
12784: GO 12786
12786: DISABLE
12787: LD_INT 0
12789: PPUSH
// begin if Denis then
12790: LD_EXP 23
12794: IFFALSE 12811
// speaker := [ Denis ] else
12796: LD_ADDR_VAR 0 1
12800: PUSH
12801: LD_EXP 23
12805: PUSH
12806: EMPTY
12807: LIST
12808: ST_TO_ADDR
12809: GO 12917
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12811: LD_ADDR_VAR 0 1
12815: PUSH
12816: LD_INT 22
12818: PUSH
12819: LD_INT 7
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: LD_INT 23
12828: PUSH
12829: LD_INT 1
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 25
12838: PUSH
12839: LD_INT 4
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 21
12848: PUSH
12849: LD_INT 1
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: LD_INT 26
12858: PUSH
12859: LD_INT 1
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: PPUSH
12873: CALL_OW 69
12877: PUSH
12878: LD_EXP 18
12882: PUSH
12883: LD_EXP 17
12887: PUSH
12888: LD_EXP 49
12892: PUSH
12893: LD_EXP 37
12897: PUSH
12898: LD_EXP 47
12902: PUSH
12903: LD_EXP 46
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: DIFF
12916: ST_TO_ADDR
// if not speaker then
12917: LD_VAR 0 1
12921: NOT
12922: IFFALSE 12926
// exit ;
12924: GO 12942
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12926: LD_VAR 0 1
12930: PUSH
12931: LD_INT 1
12933: ARRAY
12934: PPUSH
12935: LD_STRING DArtefTechnologyArStart-Sci1-1
12937: PPUSH
12938: CALL_OW 88
// end ;
12942: PPOPN 1
12944: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12945: LD_EXP 14
12949: IFFALSE 13230
12951: GO 12953
12953: DISABLE
12954: LD_INT 0
12956: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12957: LD_ADDR_VAR 0 1
12961: PUSH
12962: LD_INT 22
12964: PUSH
12965: LD_INT 7
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 23
12974: PUSH
12975: LD_INT 3
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 25
12984: PUSH
12985: LD_INT 4
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 21
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 26
13004: PUSH
13005: LD_INT 1
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: PPUSH
13019: CALL_OW 69
13023: PUSH
13024: LD_EXP 18
13028: PUSH
13029: LD_EXP 17
13033: PUSH
13034: LD_EXP 49
13038: PUSH
13039: LD_EXP 37
13043: PUSH
13044: LD_EXP 47
13048: PUSH
13049: LD_EXP 46
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: DIFF
13062: ST_TO_ADDR
// if not speaker then
13063: LD_VAR 0 1
13067: NOT
13068: IFFALSE 13072
// exit ;
13070: GO 13230
// DialogueOn ;
13072: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13076: LD_VAR 0 1
13080: PUSH
13081: LD_INT 1
13083: ARRAY
13084: PPUSH
13085: LD_STRING DArtefTechnologyAr-RSci1-1
13087: PPUSH
13088: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13092: LD_EXP 17
13096: PPUSH
13097: LD_STRING DArtefTechnologyAr-JMM-1
13099: PPUSH
13100: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13104: LD_VAR 0 1
13108: PUSH
13109: LD_INT 1
13111: ARRAY
13112: PPUSH
13113: LD_STRING DArtefTechnologyAr-RSci1-2
13115: PPUSH
13116: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13120: LD_EXP 17
13124: PPUSH
13125: LD_STRING DArtefTechnologyAr-JMM-2
13127: PPUSH
13128: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13132: LD_VAR 0 1
13136: PUSH
13137: LD_INT 1
13139: ARRAY
13140: PPUSH
13141: LD_STRING DArtefTechnologyAr-RSci1-3
13143: PPUSH
13144: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13148: LD_EXP 17
13152: PPUSH
13153: LD_STRING DArtefTechnologyAr-JMM-3
13155: PPUSH
13156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13160: LD_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: ARRAY
13168: PPUSH
13169: LD_STRING DArtefTechnologyAr-RSci1-4
13171: PPUSH
13172: CALL_OW 88
// if IsOk ( Burlak ) then
13176: LD_EXP 49
13180: PPUSH
13181: CALL_OW 302
13185: IFFALSE 13199
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13187: LD_EXP 49
13191: PPUSH
13192: LD_STRING DArtefTechnologyAr-Bur-4
13194: PPUSH
13195: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13199: LD_EXP 17
13203: PPUSH
13204: LD_STRING DArtefTechnologyAr-JMM-4
13206: PPUSH
13207: CALL_OW 88
// DialogueOff ;
13211: CALL_OW 7
// wait ( 0 0$45 ) ;
13215: LD_INT 1575
13217: PPUSH
13218: CALL_OW 67
// spawnOmar := true ;
13222: LD_ADDR_EXP 11
13226: PUSH
13227: LD_INT 1
13229: ST_TO_ADDR
// end ;
13230: PPOPN 1
13232: END
// every 0 0$1 trigger spawnOmar do
13233: LD_EXP 11
13237: IFFALSE 13617
13239: GO 13241
13241: DISABLE
// begin PrepareOmarAli ;
13242: CALL 6751 0 0
// if not HasTask ( Omar ) then
13246: LD_EXP 53
13250: PPUSH
13251: CALL_OW 314
13255: NOT
13256: IFFALSE 13273
// ComMoveXY ( Omar , 252 , 220 ) ;
13258: LD_EXP 53
13262: PPUSH
13263: LD_INT 252
13265: PPUSH
13266: LD_INT 220
13268: PPUSH
13269: CALL_OW 111
// if not Omar then
13273: LD_EXP 53
13277: NOT
13278: IFFALSE 13282
// exit ;
13280: GO 13617
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13289: LD_EXP 53
13293: PPUSH
13294: CALL_OW 314
13298: NOT
13299: PUSH
13300: LD_EXP 53
13304: PPUSH
13305: LD_INT 252
13307: PPUSH
13308: LD_INT 220
13310: PPUSH
13311: CALL_OW 297
13315: PUSH
13316: LD_INT 6
13318: GREATER
13319: AND
13320: IFFALSE 13337
// ComMoveXY ( Omar , 252 , 220 ) ;
13322: LD_EXP 53
13326: PPUSH
13327: LD_INT 252
13329: PPUSH
13330: LD_INT 220
13332: PPUSH
13333: CALL_OW 111
// until See ( 7 , Omar ) ;
13337: LD_INT 7
13339: PPUSH
13340: LD_EXP 53
13344: PPUSH
13345: CALL_OW 292
13349: IFFALSE 13282
// CenterNowOnUnits ( Omar ) ;
13351: LD_EXP 53
13355: PPUSH
13356: CALL_OW 87
// DialogueOn ;
13360: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13364: LD_EXP 53
13368: PPUSH
13369: LD_STRING DOmar-Omar-1
13371: PPUSH
13372: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13376: LD_EXP 17
13380: PPUSH
13381: LD_STRING DOmar-JMM-1
13383: PPUSH
13384: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13388: LD_EXP 53
13392: PPUSH
13393: LD_STRING DOmar-Omar-2
13395: PPUSH
13396: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13400: LD_EXP 17
13404: PPUSH
13405: LD_STRING DOmar-JMM-2
13407: PPUSH
13408: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13412: LD_EXP 53
13416: PPUSH
13417: LD_STRING DOmar-Omar-3
13419: PPUSH
13420: CALL_OW 88
// if IsOk ( Burlak ) then
13424: LD_EXP 49
13428: PPUSH
13429: CALL_OW 302
13433: IFFALSE 13449
// Say ( Burlak , DOmar-Bur-3 ) else
13435: LD_EXP 49
13439: PPUSH
13440: LD_STRING DOmar-Bur-3
13442: PPUSH
13443: CALL_OW 88
13447: GO 13461
// Say ( JMM , DOmar-JMM-3 ) ;
13449: LD_EXP 17
13453: PPUSH
13454: LD_STRING DOmar-JMM-3
13456: PPUSH
13457: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13461: LD_EXP 53
13465: PPUSH
13466: LD_STRING DOmar-Omar-4
13468: PPUSH
13469: CALL_OW 88
// case Query ( QAccept ) of 1 :
13473: LD_STRING QAccept
13475: PPUSH
13476: CALL_OW 97
13480: PUSH
13481: LD_INT 1
13483: DOUBLE
13484: EQUAL
13485: IFTRUE 13489
13487: GO 13525
13489: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13490: LD_EXP 17
13494: PPUSH
13495: LD_STRING DQrAccept#1-JMM-1
13497: PPUSH
13498: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13502: LD_EXP 53
13506: PPUSH
13507: LD_INT 7
13509: PPUSH
13510: CALL_OW 235
// ComStop ( Omar ) ;
13514: LD_EXP 53
13518: PPUSH
13519: CALL_OW 141
// end ; 2 :
13523: GO 13574
13525: LD_INT 2
13527: DOUBLE
13528: EQUAL
13529: IFTRUE 13533
13531: GO 13573
13533: POP
// begin if IsOk ( Burlak ) then
13534: LD_EXP 49
13538: PPUSH
13539: CALL_OW 302
13543: IFFALSE 13559
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13545: LD_EXP 49
13549: PPUSH
13550: LD_STRING DQrAccept#2-Bur-1
13552: PPUSH
13553: CALL_OW 88
13557: GO 13571
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13559: LD_EXP 17
13563: PPUSH
13564: LD_STRING DQrAccept#2-JMM-1
13566: PPUSH
13567: CALL_OW 88
// end ; end ;
13571: GO 13574
13573: POP
// DialogueOff ;
13574: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13578: LD_EXP 53
13582: PPUSH
13583: CALL_OW 255
13587: PUSH
13588: LD_INT 7
13590: EQUAL
13591: IFFALSE 13602
// begin SetAchievement ( ACH_OMAR ) ;
13593: LD_STRING ACH_OMAR
13595: PPUSH
13596: CALL_OW 543
// exit ;
13600: GO 13617
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13602: LD_EXP 53
13606: PPUSH
13607: LD_INT 202
13609: PPUSH
13610: LD_INT 115
13612: PPUSH
13613: CALL_OW 111
// end ;
13617: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13618: LD_EXP 53
13622: PPUSH
13623: LD_INT 200
13625: PPUSH
13626: LD_INT 98
13628: PPUSH
13629: CALL_OW 297
13633: PUSH
13634: LD_INT 40
13636: LESS
13637: PUSH
13638: LD_EXP 2
13642: AND
13643: IFFALSE 13861
13645: GO 13647
13647: DISABLE
// begin SetSide ( Omar , 5 ) ;
13648: LD_EXP 53
13652: PPUSH
13653: LD_INT 5
13655: PPUSH
13656: CALL_OW 235
// if IsInUnit ( Omar ) then
13660: LD_EXP 53
13664: PPUSH
13665: CALL_OW 310
13669: IFFALSE 13680
// ComExitVehicle ( Omar ) ;
13671: LD_EXP 53
13675: PPUSH
13676: CALL_OW 121
// if IsInUnit ( Omar ) then
13680: LD_EXP 53
13684: PPUSH
13685: CALL_OW 310
13689: IFFALSE 13700
// ComExitBuilding ( Omar ) ;
13691: LD_EXP 53
13695: PPUSH
13696: CALL_OW 122
// wait ( 0 0$1 ) ;
13700: LD_INT 35
13702: PPUSH
13703: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13707: LD_EXP 53
13711: PPUSH
13712: LD_INT 203
13714: PPUSH
13715: LD_INT 120
13717: PPUSH
13718: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13722: LD_INT 35
13724: PPUSH
13725: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13729: LD_EXP 53
13733: PPUSH
13734: CALL_OW 306
13738: PUSH
13739: LD_EXP 53
13743: PPUSH
13744: LD_INT 203
13746: PPUSH
13747: LD_INT 120
13749: PPUSH
13750: CALL_OW 297
13754: PUSH
13755: LD_INT 6
13757: LESS
13758: OR
13759: IFFALSE 13722
// CenterNowOnUnits ( Omar ) ;
13761: LD_EXP 53
13765: PPUSH
13766: CALL_OW 87
// DialogueOn ;
13770: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13774: LD_EXP 17
13778: PPUSH
13779: LD_STRING DOmarContam-JMM-1
13781: PPUSH
13782: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13786: LD_EXP 53
13790: PPUSH
13791: LD_STRING DOmarContam-Omar-1
13793: PPUSH
13794: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13798: LD_EXP 17
13802: PPUSH
13803: LD_STRING DOmarContam-JMM-2
13805: PPUSH
13806: CALL_OW 88
// DialogueOff ;
13810: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13814: LD_INT 5
13816: PPUSH
13817: LD_INT 7
13819: PPUSH
13820: LD_INT 2
13822: PPUSH
13823: LD_INT 1
13825: PPUSH
13826: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13830: LD_INT 105
13832: PPUSH
13833: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13837: LD_EXP 53
13841: PPUSH
13842: LD_INT 203
13844: PPUSH
13845: LD_INT 120
13847: PPUSH
13848: CALL_OW 307
13852: IFFALSE 13830
// YouLost ( MothContaminate ) ;
13854: LD_STRING MothContaminate
13856: PPUSH
13857: CALL_OW 104
// end ;
13861: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13862: LD_EXP 4
13866: NOT
13867: PUSH
13868: LD_INT 22
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: LD_INT 34
13880: PUSH
13881: LD_INT 8
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PPUSH
13892: CALL_OW 69
13896: AND
13897: IFFALSE 14016
13899: GO 13901
13901: DISABLE
// begin wait ( 0 0$5 ) ;
13902: LD_INT 175
13904: PPUSH
13905: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13909: LD_EXP 52
13913: PPUSH
13914: CALL_OW 302
13918: NOT
13919: PUSH
13920: LD_INT 22
13922: PUSH
13923: LD_INT 1
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: PUSH
13930: LD_INT 34
13932: PUSH
13933: LD_INT 8
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PPUSH
13944: CALL_OW 69
13948: NOT
13949: OR
13950: IFFALSE 13954
// exit ;
13952: GO 14016
// DialogueOn ;
13954: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13958: LD_EXP 52
13962: PPUSH
13963: LD_STRING DWinAmericans-Pow-1
13965: PPUSH
13966: CALL_OW 94
// if IsOk ( Burlak ) then
13970: LD_EXP 49
13974: PPUSH
13975: CALL_OW 302
13979: IFFALSE 13993
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13981: LD_EXP 49
13985: PPUSH
13986: LD_STRING DWinAmericans-Bur-1
13988: PPUSH
13989: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13993: LD_EXP 17
13997: PPUSH
13998: LD_STRING DWinAmericans-JMM-1
14000: PPUSH
14001: CALL_OW 88
// DialogueOff ;
14005: CALL_OW 7
// YouLost ( AmBomb ) ;
14009: LD_STRING AmBomb
14011: PPUSH
14012: CALL_OW 104
// end ;
14016: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14017: LD_EXP 2
14021: NOT
14022: PUSH
14023: LD_INT 22
14025: PUSH
14026: LD_INT 3
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: PUSH
14033: LD_INT 34
14035: PUSH
14036: LD_INT 48
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PPUSH
14047: CALL_OW 69
14051: AND
14052: IFFALSE 14171
14054: GO 14056
14056: DISABLE
// begin wait ( 0 0$5 ) ;
14057: LD_INT 175
14059: PPUSH
14060: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14064: LD_EXP 56
14068: PPUSH
14069: CALL_OW 302
14073: NOT
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 48
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PPUSH
14099: CALL_OW 69
14103: NOT
14104: OR
14105: IFFALSE 14109
// exit ;
14107: GO 14171
// DialogueOn ;
14109: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14113: LD_EXP 56
14117: PPUSH
14118: LD_STRING DWinRussians-Pla-1
14120: PPUSH
14121: CALL_OW 94
// if IsOk ( Burlak ) then
14125: LD_EXP 49
14129: PPUSH
14130: CALL_OW 302
14134: IFFALSE 14148
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14136: LD_EXP 49
14140: PPUSH
14141: LD_STRING DWinRussians-Bur-1
14143: PPUSH
14144: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14148: LD_EXP 17
14152: PPUSH
14153: LD_STRING DWinRussians-JMM-1
14155: PPUSH
14156: CALL_OW 88
// DialogueOff ;
14160: CALL_OW 7
// YouLost ( RuBomb ) ;
14164: LD_STRING RuBomb
14166: PPUSH
14167: CALL_OW 104
// end ;
14171: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14172: LD_INT 7
14174: PPUSH
14175: LD_INT 22
14177: PUSH
14178: LD_INT 7
14180: PUSH
14181: EMPTY
14182: LIST
14183: LIST
14184: PPUSH
14185: CALL_OW 70
14189: PUSH
14190: LD_EXP 4
14194: NOT
14195: AND
14196: IFFALSE 14225
14198: GO 14200
14200: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14201: LD_EXP 52
14205: PPUSH
14206: LD_STRING DSurrenderAmericans-Pow-1
14208: PPUSH
14209: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14213: LD_EXP 17
14217: PPUSH
14218: LD_STRING DSurrenderAmericans-JMM-1
14220: PPUSH
14221: CALL_OW 88
// end ;
14225: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14226: LD_INT 2
14228: PPUSH
14229: LD_INT 22
14231: PUSH
14232: LD_INT 7
14234: PUSH
14235: EMPTY
14236: LIST
14237: LIST
14238: PPUSH
14239: CALL_OW 70
14243: PUSH
14244: LD_EXP 2
14248: NOT
14249: AND
14250: PUSH
14251: LD_EXP 49
14255: AND
14256: IFFALSE 14285
14258: GO 14260
14260: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14261: LD_EXP 56
14265: PPUSH
14266: LD_STRING DSurrenderRussians-Pla-1
14268: PPUSH
14269: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14273: LD_EXP 49
14277: PPUSH
14278: LD_STRING DSurrenderRussians-Bur-1
14280: PPUSH
14281: CALL_OW 88
// end ;
14285: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14286: LD_EXP 4
14290: IFFALSE 14673
14292: GO 14294
14294: DISABLE
14295: LD_INT 0
14297: PPUSH
14298: PPUSH
14299: PPUSH
// begin MC_Kill ( 4 ) ;
14300: LD_INT 4
14302: PPUSH
14303: CALL 21044 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14307: LD_INT 1
14309: PPUSH
14310: LD_INT 7
14312: PPUSH
14313: LD_INT 1
14315: PPUSH
14316: LD_INT 1
14318: PPUSH
14319: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14323: LD_ADDR_VAR 0 3
14327: PUSH
14328: LD_INT 22
14330: PUSH
14331: LD_INT 1
14333: PUSH
14334: EMPTY
14335: LIST
14336: LIST
14337: PUSH
14338: LD_INT 26
14340: PUSH
14341: LD_INT 1
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: LD_INT 23
14350: PUSH
14351: LD_INT 1
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: PPUSH
14363: CALL_OW 69
14367: PUSH
14368: LD_EXP 52
14372: PUSH
14373: LD_EXP 25
14377: PUSH
14378: LD_EXP 22
14382: PUSH
14383: LD_EXP 21
14387: PUSH
14388: LD_EXP 28
14392: PUSH
14393: LD_EXP 26
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: DIFF
14406: ST_TO_ADDR
// if speaker then
14407: LD_VAR 0 3
14411: IFFALSE 14437
// begin DialogueOn ;
14413: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14417: LD_VAR 0 3
14421: PUSH
14422: LD_INT 1
14424: ARRAY
14425: PPUSH
14426: LD_STRING DSurrenderAmericans-Sol1-1a
14428: PPUSH
14429: CALL_OW 94
// DialogueOff ;
14433: CALL_OW 7
// end ; americanCapitulated := true ;
14437: LD_ADDR_EXP 6
14441: PUSH
14442: LD_INT 1
14444: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 1
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 21
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: PUSH
14479: LD_INT 22
14481: PUSH
14482: LD_INT 1
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 21
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: EMPTY
14503: LIST
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: ADD
14515: ST_TO_ADDR
// if tmp then
14516: LD_VAR 0 2
14520: IFFALSE 14673
// repeat wait ( 0 0$1 ) ;
14522: LD_INT 35
14524: PPUSH
14525: CALL_OW 67
// for i in tmp do
14529: LD_ADDR_VAR 0 1
14533: PUSH
14534: LD_VAR 0 2
14538: PUSH
14539: FOR_IN
14540: IFFALSE 14622
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14542: LD_VAR 0 1
14546: PPUSH
14547: CALL_OW 310
14551: PUSH
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 310
14561: PPUSH
14562: CALL_OW 247
14566: PUSH
14567: LD_INT 3
14569: EQUAL
14570: AND
14571: IFFALSE 14582
// ComExitBuilding ( i ) ;
14573: LD_VAR 0 1
14577: PPUSH
14578: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_INT 122
14589: PPUSH
14590: LD_INT 242
14592: PPUSH
14593: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_INT 35
14604: PPUSH
14605: CALL_OW 308
14609: IFFALSE 14620
// RemoveUnit ( i ) ;
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 64
// end ;
14620: GO 14539
14622: POP
14623: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 33
14649: PUSH
14650: LD_INT 1
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: NOT
14671: IFFALSE 14522
// end ;
14673: PPOPN 3
14675: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14676: LD_EXP 2
14680: IFFALSE 15081
14682: GO 14684
14684: DISABLE
14685: LD_INT 0
14687: PPUSH
14688: PPUSH
14689: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14690: LD_INT 35
14692: PPUSH
14693: CALL_OW 67
// until IsDead ( Yakotich ) ;
14697: LD_EXP 57
14701: PPUSH
14702: CALL_OW 301
14706: IFFALSE 14690
// MC_Kill ( 2 ) ;
14708: LD_INT 2
14710: PPUSH
14711: CALL 21044 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14715: LD_INT 3
14717: PPUSH
14718: LD_INT 7
14720: PPUSH
14721: LD_INT 1
14723: PPUSH
14724: LD_INT 1
14726: PPUSH
14727: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14731: LD_ADDR_VAR 0 3
14735: PUSH
14736: LD_INT 22
14738: PUSH
14739: LD_INT 3
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 26
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: LD_INT 23
14758: PUSH
14759: LD_INT 3
14761: PUSH
14762: EMPTY
14763: LIST
14764: LIST
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 69
14775: PUSH
14776: LD_EXP 56
14780: PUSH
14781: LD_EXP 57
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: DIFF
14790: ST_TO_ADDR
// if speaker then
14791: LD_VAR 0 3
14795: IFFALSE 14845
// begin DialogueOn ;
14797: CALL_OW 6
// if Burlak then
14801: LD_EXP 49
14805: IFFALSE 14825
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14807: LD_VAR 0 3
14811: PUSH
14812: LD_INT 1
14814: ARRAY
14815: PPUSH
14816: LD_STRING DSurrenderRussians-RSol1-1
14818: PPUSH
14819: CALL_OW 94
14823: GO 14841
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 1
14832: ARRAY
14833: PPUSH
14834: LD_STRING DSurrenderRussians-RSol1-1a
14836: PPUSH
14837: CALL_OW 94
// DialogueOff ;
14841: CALL_OW 7
// end ; russianCapitulated := true ;
14845: LD_ADDR_EXP 7
14849: PUSH
14850: LD_INT 1
14852: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14853: LD_ADDR_VAR 0 2
14857: PUSH
14858: LD_INT 22
14860: PUSH
14861: LD_INT 3
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: LD_INT 21
14870: PUSH
14871: LD_INT 1
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: PPUSH
14882: CALL_OW 69
14886: PUSH
14887: LD_INT 22
14889: PUSH
14890: LD_INT 3
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: PUSH
14897: LD_INT 21
14899: PUSH
14900: LD_INT 2
14902: PUSH
14903: EMPTY
14904: LIST
14905: LIST
14906: PUSH
14907: LD_INT 1
14909: PUSH
14910: EMPTY
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: LIST
14917: PPUSH
14918: CALL_OW 69
14922: ADD
14923: ST_TO_ADDR
// if tmp then
14924: LD_VAR 0 2
14928: IFFALSE 15081
// repeat wait ( 0 0$1 ) ;
14930: LD_INT 35
14932: PPUSH
14933: CALL_OW 67
// for i in tmp do
14937: LD_ADDR_VAR 0 1
14941: PUSH
14942: LD_VAR 0 2
14946: PUSH
14947: FOR_IN
14948: IFFALSE 15030
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14950: LD_VAR 0 1
14954: PPUSH
14955: CALL_OW 310
14959: PUSH
14960: LD_VAR 0 1
14964: PPUSH
14965: CALL_OW 310
14969: PPUSH
14970: CALL_OW 247
14974: PUSH
14975: LD_INT 3
14977: EQUAL
14978: AND
14979: IFFALSE 14990
// ComExitBuilding ( i ) ;
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14990: LD_VAR 0 1
14994: PPUSH
14995: LD_INT 154
14997: PPUSH
14998: LD_INT 1
15000: PPUSH
15001: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_INT 36
15012: PPUSH
15013: CALL_OW 308
15017: IFFALSE 15028
// RemoveUnit ( i ) ;
15019: LD_VAR 0 1
15023: PPUSH
15024: CALL_OW 64
// end ;
15028: GO 14947
15030: POP
15031: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15032: LD_INT 22
15034: PUSH
15035: LD_INT 3
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: LD_INT 21
15047: PUSH
15048: LD_INT 1
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: PUSH
15055: LD_INT 33
15057: PUSH
15058: LD_INT 1
15060: PUSH
15061: EMPTY
15062: LIST
15063: LIST
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PPUSH
15074: CALL_OW 69
15078: NOT
15079: IFFALSE 14930
// end ;
15081: PPOPN 3
15083: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15084: LD_INT 22
15086: PUSH
15087: LD_INT 8
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: PUSH
15094: LD_INT 21
15096: PUSH
15097: LD_INT 1
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: PUSH
15104: LD_INT 23
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: LIST
15118: PPUSH
15119: CALL_OW 69
15123: PUSH
15124: LD_INT 18
15126: LESS
15127: PUSH
15128: LD_EXP 55
15132: PPUSH
15133: CALL_OW 301
15137: OR
15138: PUSH
15139: LD_INT 324
15141: PPUSH
15142: CALL_OW 255
15146: PUSH
15147: LD_INT 7
15149: EQUAL
15150: OR
15151: IFFALSE 15164
15153: GO 15155
15155: DISABLE
// legionDestroyed := true ;
15156: LD_ADDR_EXP 3
15160: PUSH
15161: LD_INT 1
15163: ST_TO_ADDR
15164: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15165: LD_INT 22
15167: PUSH
15168: LD_INT 2
15170: PUSH
15171: EMPTY
15172: LIST
15173: LIST
15174: PUSH
15175: LD_INT 21
15177: PUSH
15178: LD_INT 1
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PUSH
15185: LD_INT 23
15187: PUSH
15188: LD_INT 2
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PUSH
15195: EMPTY
15196: LIST
15197: LIST
15198: LIST
15199: PPUSH
15200: CALL_OW 69
15204: PUSH
15205: LD_INT 9
15207: LESS
15208: IFFALSE 15221
15210: GO 15212
15212: DISABLE
// arabianDestroyed := true ;
15213: LD_ADDR_EXP 5
15217: PUSH
15218: LD_INT 1
15220: ST_TO_ADDR
15221: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15222: LD_EXP 5
15226: IFFALSE 15470
15228: GO 15230
15230: DISABLE
15231: LD_INT 0
15233: PPUSH
15234: PPUSH
// begin MC_Kill ( 1 ) ;
15235: LD_INT 1
15237: PPUSH
15238: CALL 21044 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15242: LD_ADDR_VAR 0 2
15246: PUSH
15247: LD_INT 22
15249: PUSH
15250: LD_INT 2
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: PUSH
15257: LD_INT 21
15259: PUSH
15260: LD_INT 1
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 69
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 8
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 21
15288: PUSH
15289: LD_INT 2
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 1
15298: PUSH
15299: EMPTY
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: LIST
15306: PPUSH
15307: CALL_OW 69
15311: ADD
15312: ST_TO_ADDR
// if tmp then
15313: LD_VAR 0 2
15317: IFFALSE 15470
// repeat wait ( 0 0$1 ) ;
15319: LD_INT 35
15321: PPUSH
15322: CALL_OW 67
// for i in tmp do
15326: LD_ADDR_VAR 0 1
15330: PUSH
15331: LD_VAR 0 2
15335: PUSH
15336: FOR_IN
15337: IFFALSE 15419
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15339: LD_VAR 0 1
15343: PPUSH
15344: CALL_OW 310
15348: PUSH
15349: LD_VAR 0 1
15353: PPUSH
15354: CALL_OW 310
15358: PPUSH
15359: CALL_OW 247
15363: PUSH
15364: LD_INT 3
15366: EQUAL
15367: AND
15368: IFFALSE 15379
// ComExitBuilding ( i ) ;
15370: LD_VAR 0 1
15374: PPUSH
15375: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15379: LD_VAR 0 1
15383: PPUSH
15384: LD_INT 254
15386: PPUSH
15387: LD_INT 268
15389: PPUSH
15390: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15394: LD_VAR 0 1
15398: PPUSH
15399: LD_INT 34
15401: PPUSH
15402: CALL_OW 308
15406: IFFALSE 15417
// RemoveUnit ( i ) ;
15408: LD_VAR 0 1
15412: PPUSH
15413: CALL_OW 64
// end ;
15417: GO 15336
15419: POP
15420: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15421: LD_INT 22
15423: PUSH
15424: LD_INT 2
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PUSH
15431: LD_INT 2
15433: PUSH
15434: LD_INT 21
15436: PUSH
15437: LD_INT 1
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: LD_INT 33
15446: PUSH
15447: LD_INT 1
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PUSH
15454: EMPTY
15455: LIST
15456: LIST
15457: LIST
15458: PUSH
15459: EMPTY
15460: LIST
15461: LIST
15462: PPUSH
15463: CALL_OW 69
15467: NOT
15468: IFFALSE 15319
// end ;
15470: PPOPN 2
15472: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15473: LD_EXP 3
15477: IFFALSE 15829
15479: GO 15481
15481: DISABLE
15482: LD_INT 0
15484: PPUSH
15485: PPUSH
// begin MC_Kill ( 3 ) ;
15486: LD_INT 3
15488: PPUSH
15489: CALL 21044 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15493: LD_INT 8
15495: PPUSH
15496: LD_INT 7
15498: PPUSH
15499: LD_INT 1
15501: PPUSH
15502: LD_INT 1
15504: PPUSH
15505: CALL_OW 80
// DialogueOn ;
15509: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15513: LD_EXP 54
15517: PPUSH
15518: LD_STRING D15-Szulc-1
15520: PPUSH
15521: CALL_OW 94
// DialogueOff ;
15525: CALL_OW 7
// legionCapitulated := true ;
15529: LD_ADDR_EXP 8
15533: PUSH
15534: LD_INT 1
15536: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15537: LD_ADDR_VAR 0 1
15541: PUSH
15542: LD_INT 22
15544: PUSH
15545: LD_INT 8
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: PUSH
15552: LD_INT 21
15554: PUSH
15555: LD_INT 3
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 23
15564: PUSH
15565: LD_INT 3
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: LIST
15576: PPUSH
15577: CALL_OW 69
15581: PUSH
15582: FOR_IN
15583: IFFALSE 15599
// SetLives ( i , 3 ) ;
15585: LD_VAR 0 1
15589: PPUSH
15590: LD_INT 3
15592: PPUSH
15593: CALL_OW 234
15597: GO 15582
15599: POP
15600: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15601: LD_ADDR_VAR 0 2
15605: PUSH
15606: LD_INT 22
15608: PUSH
15609: LD_INT 8
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: PUSH
15616: LD_INT 21
15618: PUSH
15619: LD_INT 1
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: PPUSH
15630: CALL_OW 69
15634: PUSH
15635: LD_INT 22
15637: PUSH
15638: LD_INT 8
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: LD_INT 21
15647: PUSH
15648: LD_INT 2
15650: PUSH
15651: EMPTY
15652: LIST
15653: LIST
15654: PUSH
15655: LD_INT 1
15657: PUSH
15658: EMPTY
15659: LIST
15660: PUSH
15661: EMPTY
15662: LIST
15663: LIST
15664: LIST
15665: PPUSH
15666: CALL_OW 69
15670: ADD
15671: ST_TO_ADDR
// if tmp then
15672: LD_VAR 0 2
15676: IFFALSE 15829
// repeat wait ( 0 0$1 ) ;
15678: LD_INT 35
15680: PPUSH
15681: CALL_OW 67
// for i in tmp do
15685: LD_ADDR_VAR 0 1
15689: PUSH
15690: LD_VAR 0 2
15694: PUSH
15695: FOR_IN
15696: IFFALSE 15778
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15698: LD_VAR 0 1
15702: PPUSH
15703: CALL_OW 310
15707: PUSH
15708: LD_VAR 0 1
15712: PPUSH
15713: CALL_OW 310
15717: PPUSH
15718: CALL_OW 247
15722: PUSH
15723: LD_INT 3
15725: EQUAL
15726: AND
15727: IFFALSE 15738
// ComExitBuilding ( i ) ;
15729: LD_VAR 0 1
15733: PPUSH
15734: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15738: LD_VAR 0 1
15742: PPUSH
15743: LD_INT 10
15745: PPUSH
15746: LD_INT 1
15748: PPUSH
15749: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15753: LD_VAR 0 1
15757: PPUSH
15758: LD_INT 32
15760: PPUSH
15761: CALL_OW 308
15765: IFFALSE 15776
// RemoveUnit ( i ) ;
15767: LD_VAR 0 1
15771: PPUSH
15772: CALL_OW 64
// end ;
15776: GO 15695
15778: POP
15779: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15780: LD_INT 22
15782: PUSH
15783: LD_INT 8
15785: PUSH
15786: EMPTY
15787: LIST
15788: LIST
15789: PUSH
15790: LD_INT 2
15792: PUSH
15793: LD_INT 21
15795: PUSH
15796: LD_INT 1
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PUSH
15803: LD_INT 33
15805: PUSH
15806: LD_INT 1
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: LIST
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PPUSH
15822: CALL_OW 69
15826: NOT
15827: IFFALSE 15678
// end ;
15829: PPOPN 2
15831: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15832: LD_EXP 4
15836: PUSH
15837: LD_EXP 2
15841: AND
15842: PUSH
15843: LD_EXP 3
15847: AND
15848: PUSH
15849: LD_EXP 5
15853: AND
15854: PUSH
15855: LD_EXP 6
15859: AND
15860: PUSH
15861: LD_EXP 7
15865: AND
15866: PUSH
15867: LD_EXP 8
15871: AND
15872: PUSH
15873: LD_EXP 53
15877: PPUSH
15878: CALL_OW 255
15882: PUSH
15883: LD_INT 5
15885: NONEQUAL
15886: PUSH
15887: LD_EXP 53
15891: PPUSH
15892: CALL_OW 301
15896: OR
15897: PUSH
15898: LD_EXP 53
15902: PPUSH
15903: CALL_OW 305
15907: NOT
15908: OR
15909: AND
15910: IFFALSE 17301
15912: GO 15914
15914: DISABLE
15915: LD_INT 0
15917: PPUSH
15918: PPUSH
// begin wait ( 0 0$5 ) ;
15919: LD_INT 175
15921: PPUSH
15922: CALL_OW 67
// music_class := 5 ;
15926: LD_ADDR_OWVAR 72
15930: PUSH
15931: LD_INT 5
15933: ST_TO_ADDR
// music_nat := 5 ;
15934: LD_ADDR_OWVAR 71
15938: PUSH
15939: LD_INT 5
15941: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15942: LD_EXP 15
15946: PUSH
15947: LD_INT 3
15949: LESS
15950: IFFALSE 15959
// SetAchievement ( ACH_ECONOMY ) ;
15952: LD_STRING ACH_ECONOMY
15954: PPUSH
15955: CALL_OW 543
// if tick < 60 60$00 then
15959: LD_OWVAR 1
15963: PUSH
15964: LD_INT 126000
15966: LESS
15967: IFFALSE 15983
// begin wait ( 3 ) ;
15969: LD_INT 3
15971: PPUSH
15972: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15976: LD_STRING ACH_ASPEED_19
15978: PPUSH
15979: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15983: LD_EXP 17
15987: PPUSH
15988: CALL_OW 87
// InGameOn ;
15992: CALL_OW 8
// DialogueOn ;
15996: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16000: LD_EXP 17
16004: PPUSH
16005: LD_STRING DEnd-JMM-JMM-1
16007: PPUSH
16008: CALL_OW 88
// if Joan then
16012: LD_EXP 32
16016: IFFALSE 16032
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16018: LD_EXP 32
16022: PPUSH
16023: LD_STRING DEnd-JMM-Joan-1
16025: PPUSH
16026: CALL_OW 88
16030: GO 16076
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16032: LD_EXP 19
16036: PUSH
16037: LD_EXP 19
16041: PPUSH
16042: CALL_OW 255
16046: PUSH
16047: LD_INT 7
16049: EQUAL
16050: AND
16051: PUSH
16052: LD_EXP 19
16056: PPUSH
16057: CALL_OW 305
16061: AND
16062: IFFALSE 16076
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16064: LD_EXP 19
16068: PPUSH
16069: LD_STRING DEnd-JMM-Lisa-1
16071: PPUSH
16072: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16076: LD_EXP 29
16080: PUSH
16081: LD_EXP 29
16085: PPUSH
16086: CALL_OW 305
16090: AND
16091: IFFALSE 16105
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16093: LD_EXP 29
16097: PPUSH
16098: LD_STRING DEnd-JMM-Frank-1
16100: PPUSH
16101: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16105: LD_EXP 22
16109: PUSH
16110: LD_EXP 22
16114: PPUSH
16115: CALL_OW 255
16119: PUSH
16120: LD_INT 7
16122: EQUAL
16123: AND
16124: PUSH
16125: LD_EXP 22
16129: PPUSH
16130: CALL_OW 305
16134: AND
16135: IFFALSE 16149
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16137: LD_EXP 22
16141: PPUSH
16142: LD_STRING DEnd-JMM-Cyrus-1
16144: PPUSH
16145: CALL_OW 88
// if Burlak then
16149: LD_EXP 49
16153: IFFALSE 16167
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16155: LD_EXP 49
16159: PPUSH
16160: LD_STRING DEnd-JMM-Bur-1
16162: PPUSH
16163: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16167: LD_EXP 32
16171: PUSH
16172: LD_EXP 19
16176: AND
16177: PUSH
16178: LD_EXP 19
16182: PPUSH
16183: CALL_OW 255
16187: PUSH
16188: LD_INT 7
16190: EQUAL
16191: AND
16192: PUSH
16193: LD_EXP 19
16197: PPUSH
16198: CALL_OW 305
16202: AND
16203: IFFALSE 16217
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16205: LD_EXP 19
16209: PPUSH
16210: LD_STRING DEnd-Burlak-Lisa-1
16212: PPUSH
16213: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16217: LD_EXP 50
16221: PUSH
16222: LD_EXP 50
16226: PPUSH
16227: CALL_OW 305
16231: AND
16232: IFFALSE 16246
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16234: LD_EXP 50
16238: PPUSH
16239: LD_STRING DEnd-JMM-Bel-1
16241: PPUSH
16242: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16246: LD_EXP 51
16250: PUSH
16251: LD_EXP 51
16255: PPUSH
16256: CALL_OW 305
16260: AND
16261: IFFALSE 16275
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16263: LD_EXP 51
16267: PPUSH
16268: LD_STRING DEnd-JMM-Gny-1
16270: PPUSH
16271: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16275: LD_EXP 27
16279: PUSH
16280: LD_EXP 27
16284: PPUSH
16285: CALL_OW 255
16289: PUSH
16290: LD_INT 7
16292: EQUAL
16293: AND
16294: PUSH
16295: LD_EXP 27
16299: PPUSH
16300: CALL_OW 305
16304: AND
16305: IFFALSE 16319
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16307: LD_EXP 27
16311: PPUSH
16312: LD_STRING DEnd-JMM-Corn-1
16314: PPUSH
16315: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16319: LD_EXP 20
16323: PUSH
16324: LD_EXP 20
16328: PPUSH
16329: CALL_OW 255
16333: PUSH
16334: LD_INT 7
16336: EQUAL
16337: AND
16338: PUSH
16339: LD_EXP 20
16343: PPUSH
16344: CALL_OW 305
16348: AND
16349: IFFALSE 16363
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16351: LD_EXP 20
16355: PPUSH
16356: LD_STRING DEnd-JMM-Don-1
16358: PPUSH
16359: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16363: LD_EXP 21
16367: PUSH
16368: LD_EXP 21
16372: PPUSH
16373: CALL_OW 255
16377: PUSH
16378: LD_INT 7
16380: EQUAL
16381: AND
16382: PUSH
16383: LD_EXP 21
16387: PPUSH
16388: CALL_OW 305
16392: AND
16393: IFFALSE 16407
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16395: LD_EXP 21
16399: PPUSH
16400: LD_STRING DEnd-JMM-Bobby-1
16402: PPUSH
16403: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16407: LD_EXP 23
16411: PUSH
16412: LD_EXP 23
16416: PPUSH
16417: CALL_OW 255
16421: PUSH
16422: LD_INT 7
16424: EQUAL
16425: AND
16426: PUSH
16427: LD_EXP 23
16431: PPUSH
16432: CALL_OW 305
16436: AND
16437: IFFALSE 16451
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16439: LD_EXP 23
16443: PPUSH
16444: LD_STRING DEnd-JMM-Den-1
16446: PPUSH
16447: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16451: LD_EXP 25
16455: PUSH
16456: LD_EXP 25
16460: PPUSH
16461: CALL_OW 255
16465: PUSH
16466: LD_INT 7
16468: EQUAL
16469: AND
16470: PUSH
16471: LD_EXP 25
16475: PPUSH
16476: CALL_OW 305
16480: AND
16481: IFFALSE 16495
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16483: LD_EXP 25
16487: PPUSH
16488: LD_STRING DEnd-JMM-Glad-1
16490: PPUSH
16491: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16495: LD_EXP 30
16499: PUSH
16500: LD_EXP 30
16504: PPUSH
16505: CALL_OW 255
16509: PUSH
16510: LD_INT 7
16512: EQUAL
16513: AND
16514: PUSH
16515: LD_EXP 30
16519: PPUSH
16520: CALL_OW 305
16524: AND
16525: IFFALSE 16539
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16527: LD_EXP 30
16531: PPUSH
16532: LD_STRING DEnd-JMM-Yam-1
16534: PPUSH
16535: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16539: LD_EXP 24
16543: PUSH
16544: LD_EXP 24
16548: PPUSH
16549: CALL_OW 255
16553: PUSH
16554: LD_INT 7
16556: EQUAL
16557: AND
16558: PUSH
16559: LD_EXP 24
16563: PPUSH
16564: CALL_OW 305
16568: AND
16569: IFFALSE 16583
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16571: LD_EXP 24
16575: PPUSH
16576: LD_STRING DEnd-JMM-Brown-1
16578: PPUSH
16579: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16583: LD_EXP 34
16587: PUSH
16588: LD_EXP 34
16592: PPUSH
16593: CALL_OW 255
16597: PUSH
16598: LD_INT 7
16600: EQUAL
16601: AND
16602: PUSH
16603: LD_EXP 34
16607: PPUSH
16608: CALL_OW 305
16612: AND
16613: IFFALSE 16627
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16615: LD_EXP 34
16619: PPUSH
16620: LD_STRING DEnd-JMM-Con-1
16622: PPUSH
16623: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16627: LD_EXP 28
16631: PUSH
16632: LD_EXP 28
16636: PPUSH
16637: CALL_OW 255
16641: PUSH
16642: LD_INT 7
16644: EQUAL
16645: AND
16646: PUSH
16647: LD_EXP 28
16651: PPUSH
16652: CALL_OW 305
16656: AND
16657: IFFALSE 16671
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16659: LD_EXP 28
16663: PPUSH
16664: LD_STRING DEnd-JMM-Gary-1
16666: PPUSH
16667: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16671: LD_EXP 31
16675: PUSH
16676: LD_EXP 18
16680: AND
16681: PUSH
16682: LD_EXP 31
16686: PPUSH
16687: CALL_OW 305
16691: AND
16692: IFFALSE 16706
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16694: LD_EXP 31
16698: PPUSH
16699: LD_STRING DEnd-JMM-Sim-1
16701: PPUSH
16702: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16706: LD_EXP 26
16710: PUSH
16711: LD_EXP 26
16715: PPUSH
16716: CALL_OW 255
16720: PUSH
16721: LD_INT 7
16723: EQUAL
16724: AND
16725: PUSH
16726: LD_EXP 26
16730: PPUSH
16731: CALL_OW 305
16735: AND
16736: IFFALSE 16750
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16738: LD_EXP 26
16742: PPUSH
16743: LD_STRING DEnd-JMM-VanH-1
16745: PPUSH
16746: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16750: LD_EXP 39
16754: PUSH
16755: LD_EXP 39
16759: PPUSH
16760: CALL_OW 305
16764: AND
16765: IFFALSE 16779
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16767: LD_EXP 39
16771: PPUSH
16772: LD_STRING DEnd-JMM-Dol-1
16774: PPUSH
16775: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16779: LD_EXP 43
16783: PUSH
16784: LD_EXP 43
16788: PPUSH
16789: CALL_OW 305
16793: AND
16794: IFFALSE 16808
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16796: LD_EXP 43
16800: PPUSH
16801: LD_STRING DEnd-JMM-Kap-1
16803: PPUSH
16804: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16808: LD_EXP 46
16812: PUSH
16813: LD_EXP 46
16817: PPUSH
16818: CALL_OW 305
16822: AND
16823: IFFALSE 16837
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16825: LD_EXP 46
16829: PPUSH
16830: LD_STRING DEnd-JMM-Kov-1
16832: PPUSH
16833: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16837: LD_EXP 41
16841: PUSH
16842: LD_EXP 41
16846: PPUSH
16847: CALL_OW 305
16851: AND
16852: IFFALSE 16866
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16854: LD_EXP 41
16858: PPUSH
16859: LD_STRING DEnd-JMM-Sch-1
16861: PPUSH
16862: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16866: LD_EXP 37
16870: PUSH
16871: LD_EXP 37
16875: PPUSH
16876: CALL_OW 305
16880: AND
16881: IFFALSE 16895
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16883: LD_EXP 37
16887: PPUSH
16888: LD_STRING DEnd-JMM-Tit-1
16890: PPUSH
16891: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16895: LD_EXP 42
16899: PUSH
16900: LD_EXP 42
16904: PPUSH
16905: CALL_OW 305
16909: AND
16910: IFFALSE 16924
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16912: LD_EXP 42
16916: PPUSH
16917: LD_STRING DEnd-JMM-Obl-1
16919: PPUSH
16920: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16924: LD_EXP 44
16928: PUSH
16929: LD_EXP 44
16933: PPUSH
16934: CALL_OW 305
16938: AND
16939: IFFALSE 16953
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16941: LD_EXP 44
16945: PPUSH
16946: LD_STRING DEnd-JMM-Lip-1
16948: PPUSH
16949: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16953: LD_EXP 38
16957: PUSH
16958: LD_EXP 38
16962: PPUSH
16963: CALL_OW 305
16967: AND
16968: PUSH
16969: LD_EXP 49
16973: AND
16974: IFFALSE 16988
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16976: LD_EXP 38
16980: PPUSH
16981: LD_STRING DEnd-Burlak-Fad-1
16983: PPUSH
16984: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16988: LD_EXP 45
16992: PUSH
16993: LD_EXP 45
16997: PPUSH
16998: CALL_OW 305
17002: AND
17003: IFFALSE 17017
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17005: LD_EXP 45
17009: PPUSH
17010: LD_STRING DEnd-Burlak-Ptr-1
17012: PPUSH
17013: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17017: LD_EXP 47
17021: PUSH
17022: LD_EXP 47
17026: PPUSH
17027: CALL_OW 305
17031: AND
17032: IFFALSE 17046
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17034: LD_EXP 47
17038: PPUSH
17039: LD_STRING DEnd-Burlak-Kuz-1
17041: PPUSH
17042: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17046: LD_EXP 36
17050: PUSH
17051: LD_EXP 36
17055: PPUSH
17056: CALL_OW 305
17060: AND
17061: PUSH
17062: LD_EXP 49
17066: AND
17067: IFFALSE 17081
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17069: LD_EXP 36
17073: PPUSH
17074: LD_STRING DEnd-Burlak-Kir-1
17076: PPUSH
17077: CALL_OW 88
// if Burlak then
17081: LD_EXP 49
17085: IFFALSE 17099
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17087: LD_EXP 17
17091: PPUSH
17092: LD_STRING DEnd-Burlak-JMM-1
17094: PPUSH
17095: CALL_OW 88
// dwait ( 0 0$2 ) ;
17099: LD_INT 70
17101: PPUSH
17102: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17106: LD_EXP 54
17110: PPUSH
17111: LD_STRING DEnd-Szulc
17113: PPUSH
17114: CALL_OW 94
// dwait ( 0 0$1 ) ;
17118: LD_INT 35
17120: PPUSH
17121: CALL_OW 68
// if IsLive ( Burlak ) then
17125: LD_EXP 49
17129: PPUSH
17130: CALL_OW 300
17134: IFFALSE 17146
// med1 := 1 else
17136: LD_ADDR_VAR 0 1
17140: PUSH
17141: LD_INT 1
17143: ST_TO_ADDR
17144: GO 17155
// med1 := - 1 ;
17146: LD_ADDR_VAR 0 1
17150: PUSH
17151: LD_INT 1
17153: NEG
17154: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17155: LD_EXP 12
17159: PUSH
17160: LD_EXP 13
17164: AND
17165: PUSH
17166: LD_EXP 14
17170: AND
17171: IFFALSE 17183
// med2 := 1 else
17173: LD_ADDR_VAR 0 2
17177: PUSH
17178: LD_INT 1
17180: ST_TO_ADDR
17181: GO 17192
// med2 := - 1 ;
17183: LD_ADDR_VAR 0 2
17187: PUSH
17188: LD_INT 1
17190: NEG
17191: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17192: LD_STRING Hero
17194: PPUSH
17195: LD_INT 1
17197: PPUSH
17198: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17202: LD_STRING Artefact
17204: PPUSH
17205: LD_VAR 0 2
17209: PPUSH
17210: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17214: LD_STRING ReconcileBurlak
17216: PPUSH
17217: LD_VAR 0 1
17221: PPUSH
17222: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17226: LD_OWVAR 67
17230: PUSH
17231: LD_INT 3
17233: EQUAL
17234: PUSH
17235: LD_VAR 0 1
17239: PUSH
17240: LD_INT 1
17242: EQUAL
17243: AND
17244: PUSH
17245: LD_VAR 0 2
17249: PUSH
17250: LD_INT 1
17252: EQUAL
17253: AND
17254: IFFALSE 17266
// SetAchievementEX ( ACH_AMER , 19 ) ;
17256: LD_STRING ACH_AMER
17258: PPUSH
17259: LD_INT 19
17261: PPUSH
17262: CALL_OW 564
// GiveMedals ( MAIN ) ;
17266: LD_STRING MAIN
17268: PPUSH
17269: CALL_OW 102
// InGameOff ;
17273: CALL_OW 9
// DialogueOff ;
17277: CALL_OW 7
// music_nat := 1 ;
17281: LD_ADDR_OWVAR 71
17285: PUSH
17286: LD_INT 1
17288: ST_TO_ADDR
// music_class := 4 ;
17289: LD_ADDR_OWVAR 72
17293: PUSH
17294: LD_INT 4
17296: ST_TO_ADDR
// YouWin ;
17297: CALL_OW 103
// end ; end_of_file
17301: PPOPN 2
17303: END
// export function InitNature ; begin
17304: LD_INT 0
17306: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17307: LD_INT 3
17309: PPUSH
17310: LD_INT 3
17312: PPUSH
17313: LD_INT 2
17315: PPUSH
17316: LD_INT 1
17318: PPUSH
17319: LD_INT 1
17321: PPUSH
17322: LD_INT 0
17324: PPUSH
17325: LD_INT 0
17327: PPUSH
17328: LD_INT 17
17330: PPUSH
17331: LD_INT 0
17333: PPUSH
17334: CALL 84482 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17338: LD_INT 2
17340: PPUSH
17341: LD_INT 1
17343: PPUSH
17344: LD_INT 1
17346: PPUSH
17347: LD_INT 1
17349: PPUSH
17350: LD_INT 1
17352: PPUSH
17353: LD_INT 0
17355: PPUSH
17356: LD_INT 0
17358: PPUSH
17359: LD_INT 18
17361: PPUSH
17362: LD_INT 0
17364: PPUSH
17365: CALL 84482 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17369: LD_INT 4
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: LD_INT 2
17377: PPUSH
17378: LD_INT 4
17380: PPUSH
17381: LD_INT 2
17383: PPUSH
17384: LD_INT 1
17386: PPUSH
17387: LD_INT 0
17389: PPUSH
17390: LD_INT 19
17392: PPUSH
17393: LD_INT 0
17395: PPUSH
17396: CALL 84482 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17400: LD_INT 0
17402: PPUSH
17403: LD_INT 0
17405: PPUSH
17406: LD_INT 0
17408: PPUSH
17409: LD_INT 0
17411: PPUSH
17412: LD_INT 0
17414: PPUSH
17415: LD_INT 0
17417: PPUSH
17418: LD_INT 9
17420: PPUSH
17421: LD_INT 0
17423: PPUSH
17424: LD_INT 20
17426: PPUSH
17427: CALL 84482 0 9
// end ; end_of_file
17431: LD_VAR 0 1
17435: RET
// every 0 0$30 do var time ;
17436: GO 17438
17438: DISABLE
17439: LD_INT 0
17441: PPUSH
// begin time := 0 0$50 ;
17442: LD_ADDR_VAR 0 1
17446: PUSH
17447: LD_INT 1750
17449: ST_TO_ADDR
// repeat wait ( time ) ;
17450: LD_VAR 0 1
17454: PPUSH
17455: CALL_OW 67
// if Prob ( 50 ) then
17459: LD_INT 50
17461: PPUSH
17462: CALL_OW 13
17466: IFFALSE 17495
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17468: LD_INT 1
17470: PPUSH
17471: LD_INT 5
17473: PPUSH
17474: CALL_OW 12
17478: PPUSH
17479: LD_INT 106
17481: PPUSH
17482: LD_INT 89
17484: PPUSH
17485: LD_INT 45
17487: PPUSH
17488: LD_INT 1
17490: PPUSH
17491: CALL_OW 56
// time := time + 0 0$3 ;
17495: LD_ADDR_VAR 0 1
17499: PUSH
17500: LD_VAR 0 1
17504: PUSH
17505: LD_INT 105
17507: PLUS
17508: ST_TO_ADDR
// if Prob ( 30 ) then
17509: LD_INT 30
17511: PPUSH
17512: CALL_OW 13
17516: IFFALSE 17562
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17518: LD_INT 525
17520: PPUSH
17521: LD_INT 735
17523: PPUSH
17524: CALL_OW 12
17528: PPUSH
17529: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17533: LD_INT 1
17535: PPUSH
17536: LD_INT 5
17538: PPUSH
17539: CALL_OW 12
17543: PPUSH
17544: LD_INT 21
17546: PPUSH
17547: LD_INT 26
17549: PPUSH
17550: LD_INT 12
17552: PPUSH
17553: LD_INT 1
17555: PPUSH
17556: CALL_OW 56
// end else
17560: GO 17598
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17562: LD_INT 700
17564: PPUSH
17565: LD_INT 1225
17567: PPUSH
17568: CALL_OW 12
17572: PPUSH
17573: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17577: LD_INT 1
17579: PPUSH
17580: LD_INT 5
17582: PPUSH
17583: CALL_OW 12
17587: PPUSH
17588: LD_INT 14
17590: PPUSH
17591: LD_INT 1
17593: PPUSH
17594: CALL_OW 55
// end ; if Prob ( 50 ) then
17598: LD_INT 50
17600: PPUSH
17601: CALL_OW 13
17605: IFFALSE 17651
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17607: LD_INT 700
17609: PPUSH
17610: LD_INT 1050
17612: PPUSH
17613: CALL_OW 12
17617: PPUSH
17618: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17622: LD_INT 1
17624: PPUSH
17625: LD_INT 5
17627: PPUSH
17628: CALL_OW 12
17632: PPUSH
17633: LD_INT 181
17635: PPUSH
17636: LD_INT 218
17638: PPUSH
17639: LD_INT 16
17641: PPUSH
17642: LD_INT 1
17644: PPUSH
17645: CALL_OW 56
// end else
17649: GO 17723
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17651: LD_INT 350
17653: PPUSH
17654: LD_INT 525
17656: PPUSH
17657: CALL_OW 12
17661: PPUSH
17662: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17666: LD_INT 1
17668: PPUSH
17669: LD_INT 5
17671: PPUSH
17672: CALL_OW 12
17676: PPUSH
17677: LD_INT 13
17679: PPUSH
17680: LD_INT 1
17682: PPUSH
17683: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17687: LD_INT 350
17689: PPUSH
17690: LD_INT 700
17692: PPUSH
17693: CALL_OW 12
17697: PPUSH
17698: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17702: LD_INT 1
17704: PPUSH
17705: LD_INT 5
17707: PPUSH
17708: CALL_OW 12
17712: PPUSH
17713: LD_INT 33
17715: PPUSH
17716: LD_INT 1
17718: PPUSH
17719: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17723: LD_INT 65
17725: PUSH
17726: LD_INT 62
17728: PUSH
17729: LD_INT 55
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: PUSH
17737: LD_OWVAR 67
17741: ARRAY
17742: PPUSH
17743: CALL_OW 13
17747: IFFALSE 17793
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17749: LD_INT 525
17751: PPUSH
17752: LD_INT 875
17754: PPUSH
17755: CALL_OW 12
17759: PPUSH
17760: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17764: LD_INT 1
17766: PPUSH
17767: LD_INT 5
17769: PPUSH
17770: CALL_OW 12
17774: PPUSH
17775: LD_INT 294
17777: PPUSH
17778: LD_INT 211
17780: PPUSH
17781: LD_INT 30
17783: PPUSH
17784: LD_INT 1
17786: PPUSH
17787: CALL_OW 56
// end else
17791: GO 17835
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17793: LD_INT 420
17795: PPUSH
17796: LD_INT 770
17798: PPUSH
17799: CALL_OW 12
17803: PPUSH
17804: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17808: LD_INT 1
17810: PPUSH
17811: LD_INT 5
17813: PPUSH
17814: CALL_OW 12
17818: PPUSH
17819: LD_INT 294
17821: PPUSH
17822: LD_INT 211
17824: PPUSH
17825: LD_INT 30
17827: PPUSH
17828: LD_INT 1
17830: PPUSH
17831: CALL_OW 56
// end ; if time > 2 2$20 then
17835: LD_VAR 0 1
17839: PUSH
17840: LD_INT 4900
17842: GREATER
17843: IFFALSE 17853
// time := 0 0$50 ;
17845: LD_ADDR_VAR 0 1
17849: PUSH
17850: LD_INT 1750
17852: ST_TO_ADDR
// until false ;
17853: LD_INT 0
17855: IFFALSE 17450
// end ;
17857: PPOPN 1
17859: END
// every 0 0$45 trigger tick < 10 10$00 do
17860: LD_OWVAR 1
17864: PUSH
17865: LD_INT 21000
17867: LESS
17868: IFFALSE 17916
17870: GO 17872
17872: DISABLE
// begin enable ;
17873: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17874: LD_INT 350
17876: PPUSH
17877: LD_INT 700
17879: PPUSH
17880: CALL_OW 12
17884: PPUSH
17885: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17889: LD_INT 3
17891: PPUSH
17892: LD_INT 5
17894: PPUSH
17895: CALL_OW 12
17899: PPUSH
17900: LD_INT 181
17902: PPUSH
17903: LD_INT 13
17905: PPUSH
17906: LD_INT 20
17908: PPUSH
17909: LD_INT 1
17911: PPUSH
17912: CALL_OW 56
// end ; end_of_file
17916: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17917: LD_INT 0
17919: PPUSH
// SetArtifactRes ( 7 , true ) ;
17920: LD_INT 7
17922: PPUSH
17923: LD_INT 1
17925: PPUSH
17926: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17930: LD_ADDR_EXP 62
17934: PUSH
17935: EMPTY
17936: PUSH
17937: EMPTY
17938: PUSH
17939: EMPTY
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17946: LD_ADDR_EXP 63
17950: PUSH
17951: LD_INT 1050
17953: PUSH
17954: LD_OWVAR 67
17958: MUL
17959: PUSH
17960: LD_INT 2800
17962: PUSH
17963: LD_OWVAR 67
17967: MUL
17968: PUSH
17969: LD_INT 1
17971: NEG
17972: PUSH
17973: EMPTY
17974: LIST
17975: LIST
17976: LIST
17977: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17978: LD_ADDR_EXP 64
17982: PUSH
17983: LD_INT 10
17985: PUSH
17986: LD_INT 35
17988: PUSH
17989: LD_INT 100
17991: PUSH
17992: EMPTY
17993: LIST
17994: LIST
17995: LIST
17996: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17997: LD_ADDR_EXP 65
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: LD_INT 0
18007: PUSH
18008: LD_INT 0
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: LIST
18015: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18016: LD_ADDR_EXP 67
18020: PUSH
18021: LD_INT 300
18023: PUSH
18024: LD_INT 500
18026: PUSH
18027: LD_INT 800
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: LIST
18034: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18035: LD_ADDR_EXP 68
18039: PUSH
18040: LD_INT 0
18042: PUSH
18043: LD_INT 0
18045: PUSH
18046: LD_INT 0
18048: PUSH
18049: EMPTY
18050: LIST
18051: LIST
18052: LIST
18053: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18054: LD_ADDR_EXP 69
18058: PUSH
18059: LD_INT 0
18061: PUSH
18062: LD_INT 0
18064: PUSH
18065: LD_INT 0
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: LIST
18072: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18073: LD_ADDR_EXP 66
18077: PUSH
18078: LD_INT 0
18080: PUSH
18081: LD_INT 0
18083: PUSH
18084: LD_INT 0
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18092: LD_ADDR_EXP 70
18096: PUSH
18097: LD_INT 4
18099: PUSH
18100: LD_INT 3
18102: PUSH
18103: LD_INT 1
18105: PUSH
18106: EMPTY
18107: LIST
18108: LIST
18109: LIST
18110: PUSH
18111: LD_INT 5
18113: PUSH
18114: LD_INT 4
18116: PUSH
18117: LD_INT 2
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: PUSH
18125: LD_INT 6
18127: PUSH
18128: LD_INT 3
18130: PUSH
18131: LD_INT 3
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: LIST
18143: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18144: LD_ADDR_EXP 71
18148: PUSH
18149: LD_INT 0
18151: PUSH
18152: LD_INT 0
18154: PUSH
18155: LD_INT 0
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 1
18167: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18168: LD_INT 24
18170: PPUSH
18171: LD_INT 7
18173: PPUSH
18174: CALL_OW 321
18178: PUSH
18179: LD_INT 2
18181: EQUAL
18182: IFFALSE 19108
18184: GO 18186
18186: DISABLE
18187: LD_INT 0
18189: PPUSH
18190: PPUSH
18191: PPUSH
18192: PPUSH
18193: PPUSH
// begin enable ;
18194: ENABLE
// for i = 1 to 3 do
18195: LD_ADDR_VAR 0 1
18199: PUSH
18200: DOUBLE
18201: LD_INT 1
18203: DEC
18204: ST_TO_ADDR
18205: LD_INT 3
18207: PUSH
18208: FOR_TO
18209: IFFALSE 19106
// begin pos := FindArtifact ( i + 2 ) ;
18211: LD_ADDR_VAR 0 2
18215: PUSH
18216: LD_VAR 0 1
18220: PUSH
18221: LD_INT 2
18223: PLUS
18224: PPUSH
18225: CALL_OW 469
18229: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18230: LD_ADDR_EXP 62
18234: PUSH
18235: LD_EXP 62
18239: PPUSH
18240: LD_VAR 0 1
18244: PPUSH
18245: LD_VAR 0 2
18249: PPUSH
18250: CALL_OW 1
18254: ST_TO_ADDR
// if pos then
18255: LD_VAR 0 2
18259: IFFALSE 18967
// begin case i of 1 :
18261: LD_VAR 0 1
18265: PUSH
18266: LD_INT 1
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18351
18274: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18275: LD_ADDR_VAR 0 4
18279: PUSH
18280: LD_INT 22
18282: PUSH
18283: LD_INT 7
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: PUSH
18290: LD_INT 23
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: LD_INT 2
18302: PUSH
18303: LD_INT 30
18305: PUSH
18306: LD_INT 8
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 30
18315: PUSH
18316: LD_INT 7
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 30
18325: PUSH
18326: LD_INT 11
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: LIST
18337: LIST
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: LIST
18343: PPUSH
18344: CALL_OW 69
18348: ST_TO_ADDR
18349: GO 18459
18351: LD_INT 2
18353: DOUBLE
18354: EQUAL
18355: IFTRUE 18359
18357: GO 18436
18359: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18360: LD_ADDR_VAR 0 4
18364: PUSH
18365: LD_INT 22
18367: PUSH
18368: LD_INT 7
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: PUSH
18375: LD_INT 23
18377: PUSH
18378: LD_INT 3
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: PUSH
18385: LD_INT 2
18387: PUSH
18388: LD_INT 30
18390: PUSH
18391: LD_INT 8
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: PUSH
18398: LD_INT 30
18400: PUSH
18401: LD_INT 7
18403: PUSH
18404: EMPTY
18405: LIST
18406: LIST
18407: PUSH
18408: LD_INT 30
18410: PUSH
18411: LD_INT 11
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: PUSH
18424: EMPTY
18425: LIST
18426: LIST
18427: LIST
18428: PPUSH
18429: CALL_OW 69
18433: ST_TO_ADDR
18434: GO 18459
18436: LD_INT 3
18438: DOUBLE
18439: EQUAL
18440: IFTRUE 18444
18442: GO 18458
18444: POP
// labs := [ alien ] ; end ;
18445: LD_ADDR_VAR 0 4
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: ST_TO_ADDR
18456: GO 18459
18458: POP
// if not labs then
18459: LD_VAR 0 4
18463: NOT
18464: IFFALSE 18468
// continue ;
18466: GO 18208
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18468: LD_ADDR_VAR 0 5
18472: PUSH
18473: LD_VAR 0 4
18477: PPUSH
18478: LD_EXP 62
18482: PUSH
18483: LD_VAR 0 1
18487: ARRAY
18488: PUSH
18489: LD_INT 1
18491: ARRAY
18492: PPUSH
18493: LD_EXP 62
18497: PUSH
18498: LD_VAR 0 1
18502: ARRAY
18503: PUSH
18504: LD_INT 2
18506: ARRAY
18507: PPUSH
18508: CALL_OW 73
18512: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18513: LD_VAR 0 5
18517: NOT
18518: PUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_EXP 69
18528: PUSH
18529: LD_VAR 0 1
18533: ARRAY
18534: NONEQUAL
18535: OR
18536: IFFALSE 18641
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18538: LD_INT 7
18540: PPUSH
18541: LD_EXP 70
18545: PUSH
18546: LD_VAR 0 1
18550: ARRAY
18551: PUSH
18552: LD_INT 3
18554: ARRAY
18555: PPUSH
18556: LD_INT 0
18558: PPUSH
18559: LD_EXP 69
18563: PUSH
18564: LD_VAR 0 1
18568: ARRAY
18569: PPUSH
18570: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18574: LD_INT 7
18576: PPUSH
18577: LD_EXP 70
18581: PUSH
18582: LD_VAR 0 1
18586: ARRAY
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: PPUSH
18592: LD_INT 0
18594: PPUSH
18595: LD_EXP 69
18599: PUSH
18600: LD_VAR 0 1
18604: ARRAY
18605: PPUSH
18606: CALL_OW 468
// if nearestLab then
18610: LD_VAR 0 5
18614: IFFALSE 18641
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18616: LD_ADDR_EXP 69
18620: PUSH
18621: LD_EXP 69
18625: PPUSH
18626: LD_VAR 0 1
18630: PPUSH
18631: LD_VAR 0 5
18635: PPUSH
18636: CALL_OW 1
18640: ST_TO_ADDR
// end ; if not nearestLab then
18641: LD_VAR 0 5
18645: NOT
18646: IFFALSE 18650
// continue ;
18648: GO 18208
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18650: LD_VAR 0 5
18654: PPUSH
18655: LD_EXP 62
18659: PUSH
18660: LD_VAR 0 1
18664: ARRAY
18665: PUSH
18666: LD_INT 1
18668: ARRAY
18669: PPUSH
18670: LD_EXP 62
18674: PUSH
18675: LD_VAR 0 1
18679: ARRAY
18680: PUSH
18681: LD_INT 2
18683: ARRAY
18684: PPUSH
18685: CALL_OW 297
18689: PUSH
18690: LD_INT 8
18692: LESS
18693: IFFALSE 18890
// begin if not artifactsResearched [ i ] then
18695: LD_EXP 65
18699: PUSH
18700: LD_VAR 0 1
18704: ARRAY
18705: NOT
18706: IFFALSE 18787
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18708: LD_VAR 0 5
18712: PPUSH
18713: CALL_OW 461
18717: PUSH
18718: LD_INT 2
18720: EQUAL
18721: IFFALSE 18755
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18723: LD_INT 7
18725: PPUSH
18726: LD_EXP 70
18730: PUSH
18731: LD_VAR 0 1
18735: ARRAY
18736: PUSH
18737: LD_INT 3
18739: ARRAY
18740: PPUSH
18741: LD_INT 2
18743: PPUSH
18744: LD_VAR 0 5
18748: PPUSH
18749: CALL_OW 468
18753: GO 18785
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18755: LD_INT 7
18757: PPUSH
18758: LD_EXP 70
18762: PUSH
18763: LD_VAR 0 1
18767: ARRAY
18768: PUSH
18769: LD_INT 3
18771: ARRAY
18772: PPUSH
18773: LD_INT 1
18775: PPUSH
18776: LD_VAR 0 5
18780: PPUSH
18781: CALL_OW 468
// end else
18785: GO 18888
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18787: LD_VAR 0 5
18791: PPUSH
18792: CALL_OW 461
18796: PUSH
18797: LD_INT 2
18799: EQUAL
18800: PUSH
18801: LD_EXP 71
18805: PUSH
18806: LD_VAR 0 1
18810: ARRAY
18811: AND
18812: IFFALSE 18858
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18814: LD_INT 7
18816: PPUSH
18817: LD_EXP 70
18821: PUSH
18822: LD_VAR 0 1
18826: ARRAY
18827: PUSH
18828: LD_INT 1
18830: ARRAY
18831: PPUSH
18832: LD_EXP 70
18836: PUSH
18837: LD_VAR 0 1
18841: ARRAY
18842: PUSH
18843: LD_INT 2
18845: ARRAY
18846: PPUSH
18847: LD_VAR 0 5
18851: PPUSH
18852: CALL_OW 468
18856: GO 18888
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18858: LD_INT 7
18860: PPUSH
18861: LD_EXP 70
18865: PUSH
18866: LD_VAR 0 1
18870: ARRAY
18871: PUSH
18872: LD_INT 1
18874: ARRAY
18875: PPUSH
18876: LD_INT 1
18878: PPUSH
18879: LD_VAR 0 5
18883: PPUSH
18884: CALL_OW 468
// end else
18888: GO 18965
// begin if not artifactsResearched [ i ] then
18890: LD_EXP 65
18894: PUSH
18895: LD_VAR 0 1
18899: ARRAY
18900: NOT
18901: IFFALSE 18935
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18903: LD_INT 7
18905: PPUSH
18906: LD_EXP 70
18910: PUSH
18911: LD_VAR 0 1
18915: ARRAY
18916: PUSH
18917: LD_INT 3
18919: ARRAY
18920: PPUSH
18921: LD_INT 0
18923: PPUSH
18924: LD_VAR 0 5
18928: PPUSH
18929: CALL_OW 468
18933: GO 18965
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18935: LD_INT 7
18937: PPUSH
18938: LD_EXP 70
18942: PUSH
18943: LD_VAR 0 1
18947: ARRAY
18948: PUSH
18949: LD_INT 1
18951: ARRAY
18952: PPUSH
18953: LD_INT 0
18955: PPUSH
18956: LD_VAR 0 5
18960: PPUSH
18961: CALL_OW 468
// end ; end else
18965: GO 19104
// begin if not artifactsLabs [ i ] then
18967: LD_EXP 69
18971: PUSH
18972: LD_VAR 0 1
18976: ARRAY
18977: NOT
18978: IFFALSE 18982
// continue ;
18980: GO 18208
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18982: LD_INT 7
18984: PPUSH
18985: LD_EXP 70
18989: PUSH
18990: LD_VAR 0 1
18994: ARRAY
18995: PUSH
18996: LD_INT 3
18998: ARRAY
18999: PPUSH
19000: LD_INT 0
19002: PPUSH
19003: LD_EXP 69
19007: PUSH
19008: LD_VAR 0 1
19012: ARRAY
19013: PPUSH
19014: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19018: LD_INT 7
19020: PPUSH
19021: LD_EXP 70
19025: PUSH
19026: LD_VAR 0 1
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: ARRAY
19035: PPUSH
19036: LD_INT 0
19038: PPUSH
19039: LD_EXP 69
19043: PUSH
19044: LD_VAR 0 1
19048: ARRAY
19049: PPUSH
19050: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19054: LD_EXP 66
19058: PUSH
19059: LD_VAR 0 1
19063: ARRAY
19064: IFFALSE 19104
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19066: LD_ADDR_EXP 66
19070: PUSH
19071: LD_EXP 66
19075: PPUSH
19076: LD_VAR 0 1
19080: PPUSH
19081: LD_INT 0
19083: PPUSH
19084: CALL_OW 1
19088: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19089: LD_EXP 69
19093: PUSH
19094: LD_VAR 0 1
19098: ARRAY
19099: PPUSH
19100: CALL_OW 127
// end ; end ; end ;
19104: GO 18208
19106: POP
19107: POP
// end ;
19108: PPOPN 5
19110: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19111: LD_INT 0
19113: PPUSH
19114: PPUSH
19115: PPUSH
19116: PPUSH
19117: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19118: LD_VAR 0 2
19122: PUSH
19123: LD_EXP 70
19127: PUSH
19128: LD_INT 1
19130: ARRAY
19131: PUSH
19132: LD_INT 3
19134: ARRAY
19135: EQUAL
19136: IFFALSE 19259
// begin lab := artifactsLabs [ 1 ] ;
19138: LD_ADDR_VAR 0 6
19142: PUSH
19143: LD_EXP 69
19147: PUSH
19148: LD_INT 1
19150: ARRAY
19151: ST_TO_ADDR
// if not lab then
19152: LD_VAR 0 6
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19161: LD_VAR 0 6
19165: PPUSH
19166: LD_EXP 67
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: PPUSH
19175: LD_INT 1
19177: PPUSH
19178: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19182: LD_EXP 68
19186: PUSH
19187: LD_INT 1
19189: ARRAY
19190: IFFALSE 19210
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19192: LD_VAR 0 6
19196: PPUSH
19197: LD_EXP 68
19201: PUSH
19202: LD_INT 1
19204: ARRAY
19205: PPUSH
19206: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19210: LD_ADDR_EXP 66
19214: PUSH
19215: LD_EXP 66
19219: PPUSH
19220: LD_INT 1
19222: PPUSH
19223: LD_INT 1
19225: PPUSH
19226: CALL_OW 1
19230: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19231: LD_INT 7
19233: PPUSH
19234: LD_EXP 70
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: PUSH
19243: LD_INT 3
19245: ARRAY
19246: PPUSH
19247: LD_INT 0
19249: PPUSH
19250: LD_VAR 0 6
19254: PPUSH
19255: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19259: LD_VAR 0 2
19263: PUSH
19264: LD_EXP 70
19268: PUSH
19269: LD_INT 2
19271: ARRAY
19272: PUSH
19273: LD_INT 3
19275: ARRAY
19276: EQUAL
19277: IFFALSE 19400
// begin lab := artifactsLabs [ 2 ] ;
19279: LD_ADDR_VAR 0 6
19283: PUSH
19284: LD_EXP 69
19288: PUSH
19289: LD_INT 2
19291: ARRAY
19292: ST_TO_ADDR
// if not lab then
19293: LD_VAR 0 6
19297: NOT
19298: IFFALSE 19302
// exit ;
19300: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19302: LD_VAR 0 6
19306: PPUSH
19307: LD_EXP 67
19311: PUSH
19312: LD_INT 2
19314: ARRAY
19315: PPUSH
19316: LD_INT 1
19318: PPUSH
19319: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19323: LD_EXP 68
19327: PUSH
19328: LD_INT 2
19330: ARRAY
19331: IFFALSE 19351
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19333: LD_VAR 0 6
19337: PPUSH
19338: LD_EXP 68
19342: PUSH
19343: LD_INT 2
19345: ARRAY
19346: PPUSH
19347: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19351: LD_ADDR_EXP 66
19355: PUSH
19356: LD_EXP 66
19360: PPUSH
19361: LD_INT 2
19363: PPUSH
19364: LD_INT 1
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19372: LD_INT 7
19374: PPUSH
19375: LD_EXP 70
19379: PUSH
19380: LD_INT 2
19382: ARRAY
19383: PUSH
19384: LD_INT 3
19386: ARRAY
19387: PPUSH
19388: LD_INT 0
19390: PPUSH
19391: LD_VAR 0 6
19395: PPUSH
19396: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19400: LD_VAR 0 2
19404: PUSH
19405: LD_EXP 70
19409: PUSH
19410: LD_INT 3
19412: ARRAY
19413: PUSH
19414: LD_INT 3
19416: ARRAY
19417: EQUAL
19418: IFFALSE 19541
// begin lab := artifactsLabs [ 3 ] ;
19420: LD_ADDR_VAR 0 6
19424: PUSH
19425: LD_EXP 69
19429: PUSH
19430: LD_INT 3
19432: ARRAY
19433: ST_TO_ADDR
// if not lab then
19434: LD_VAR 0 6
19438: NOT
19439: IFFALSE 19443
// exit ;
19441: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19443: LD_VAR 0 6
19447: PPUSH
19448: LD_EXP 67
19452: PUSH
19453: LD_INT 3
19455: ARRAY
19456: PPUSH
19457: LD_INT 1
19459: PPUSH
19460: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19464: LD_EXP 68
19468: PUSH
19469: LD_INT 3
19471: ARRAY
19472: IFFALSE 19492
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19474: LD_VAR 0 6
19478: PPUSH
19479: LD_EXP 68
19483: PUSH
19484: LD_INT 3
19486: ARRAY
19487: PPUSH
19488: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19492: LD_ADDR_EXP 66
19496: PUSH
19497: LD_EXP 66
19501: PPUSH
19502: LD_INT 3
19504: PPUSH
19505: LD_INT 1
19507: PPUSH
19508: CALL_OW 1
19512: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19513: LD_INT 7
19515: PPUSH
19516: LD_EXP 70
19520: PUSH
19521: LD_INT 3
19523: ARRAY
19524: PUSH
19525: LD_INT 3
19527: ARRAY
19528: PPUSH
19529: LD_INT 0
19531: PPUSH
19532: LD_VAR 0 6
19536: PPUSH
19537: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19541: LD_VAR 0 2
19545: PUSH
19546: LD_EXP 70
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PUSH
19555: LD_INT 1
19557: ARRAY
19558: EQUAL
19559: IFFALSE 19717
// begin lab := artifactsLabs [ 1 ] ;
19561: LD_ADDR_VAR 0 6
19565: PUSH
19566: LD_EXP 69
19570: PUSH
19571: LD_INT 1
19573: ARRAY
19574: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19575: LD_VAR 0 6
19579: PPUSH
19580: CALL_OW 274
19584: PPUSH
19585: CALL 88086 0 1
19589: PUSH
19590: LD_INT 3
19592: ARRAY
19593: PUSH
19594: LD_EXP 64
19598: PUSH
19599: LD_INT 1
19601: ARRAY
19602: LESS
19603: IFFALSE 19617
// begin HintSpec ( ArtifactCost , 2 ) ;
19605: LD_STRING ArtifactCost
19607: PPUSH
19608: LD_INT 2
19610: PPUSH
19611: CALL_OW 338
// exit ;
19615: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19617: LD_ADDR_EXP 71
19621: PUSH
19622: LD_EXP 71
19626: PPUSH
19627: LD_INT 1
19629: PPUSH
19630: LD_INT 0
19632: PPUSH
19633: CALL_OW 1
19637: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19638: LD_VAR 0 3
19642: PPUSH
19643: LD_VAR 0 4
19647: PPUSH
19648: LD_INT 7
19650: PPUSH
19651: LD_INT 12
19653: NEG
19654: PPUSH
19655: CALL_OW 330
// wait ( 0 0$30 ) ;
19659: LD_INT 1050
19661: PPUSH
19662: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19666: LD_VAR 0 3
19670: PPUSH
19671: LD_VAR 0 4
19675: PPUSH
19676: LD_INT 7
19678: PPUSH
19679: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19683: LD_EXP 63
19687: PUSH
19688: LD_INT 1
19690: ARRAY
19691: PPUSH
19692: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19696: LD_ADDR_EXP 71
19700: PUSH
19701: LD_EXP 71
19705: PPUSH
19706: LD_INT 1
19708: PPUSH
19709: LD_INT 1
19711: PPUSH
19712: CALL_OW 1
19716: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19717: LD_VAR 0 2
19721: PUSH
19722: LD_EXP 70
19726: PUSH
19727: LD_INT 2
19729: ARRAY
19730: PUSH
19731: LD_INT 1
19733: ARRAY
19734: EQUAL
19735: IFFALSE 19972
// begin lab := artifactsLabs [ 2 ] ;
19737: LD_ADDR_VAR 0 6
19741: PUSH
19742: LD_EXP 69
19746: PUSH
19747: LD_INT 2
19749: ARRAY
19750: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19751: LD_VAR 0 3
19755: PUSH
19756: LD_INT 81
19758: PUSH
19759: LD_INT 7
19761: PUSH
19762: EMPTY
19763: LIST
19764: LIST
19765: PUSH
19766: LD_INT 2
19768: PUSH
19769: LD_INT 32
19771: PUSH
19772: LD_INT 3
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 30
19781: PUSH
19782: LD_INT 28
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 30
19791: PUSH
19792: LD_INT 30
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: PUSH
19799: LD_INT 35
19801: PUSH
19802: LD_INT 49
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: PUSH
19809: LD_INT 34
19811: PUSH
19812: LD_INT 49
19814: PUSH
19815: EMPTY
19816: LIST
19817: LIST
19818: PUSH
19819: LD_INT 30
19821: PUSH
19822: LD_INT 21
19824: PUSH
19825: EMPTY
19826: LIST
19827: LIST
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: LIST
19833: LIST
19834: LIST
19835: LIST
19836: LIST
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PPUSH
19842: CALL_OW 69
19846: IN
19847: NOT
19848: IFFALSE 19852
// exit ;
19850: GO 20239
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19852: LD_VAR 0 6
19856: PPUSH
19857: CALL_OW 274
19861: PPUSH
19862: CALL 88086 0 1
19866: PUSH
19867: LD_INT 3
19869: ARRAY
19870: PUSH
19871: LD_EXP 64
19875: PUSH
19876: LD_INT 2
19878: ARRAY
19879: LESS
19880: IFFALSE 19894
// begin HintSpec ( ArtifactCost , 2 ) ;
19882: LD_STRING ArtifactCost
19884: PPUSH
19885: LD_INT 2
19887: PPUSH
19888: CALL_OW 338
// exit ;
19892: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19894: LD_ADDR_EXP 71
19898: PUSH
19899: LD_EXP 71
19903: PPUSH
19904: LD_INT 2
19906: PPUSH
19907: LD_INT 0
19909: PPUSH
19910: CALL_OW 1
19914: ST_TO_ADDR
// KillUnit ( x ) ;
19915: LD_VAR 0 3
19919: PPUSH
19920: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19924: LD_ADDR_EXP 16
19928: PUSH
19929: LD_EXP 16
19933: PUSH
19934: LD_INT 1
19936: PLUS
19937: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19938: LD_EXP 63
19942: PUSH
19943: LD_INT 2
19945: ARRAY
19946: PPUSH
19947: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19951: LD_ADDR_EXP 71
19955: PUSH
19956: LD_EXP 71
19960: PPUSH
19961: LD_INT 2
19963: PPUSH
19964: LD_INT 1
19966: PPUSH
19967: CALL_OW 1
19971: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19972: LD_VAR 0 2
19976: PUSH
19977: LD_EXP 70
19981: PUSH
19982: LD_INT 3
19984: ARRAY
19985: PUSH
19986: LD_INT 1
19988: ARRAY
19989: EQUAL
19990: IFFALSE 20239
// begin lab := artifactsLabs [ 3 ] ;
19992: LD_ADDR_VAR 0 6
19996: PUSH
19997: LD_EXP 69
20001: PUSH
20002: LD_INT 3
20004: ARRAY
20005: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20006: LD_VAR 0 6
20010: PPUSH
20011: CALL_OW 274
20015: PPUSH
20016: CALL 88086 0 1
20020: PUSH
20021: LD_INT 3
20023: ARRAY
20024: PUSH
20025: LD_EXP 64
20029: PUSH
20030: LD_INT 3
20032: ARRAY
20033: LESS
20034: IFFALSE 20048
// begin HintSpec ( ArtifactCost , 2 ) ;
20036: LD_STRING ArtifactCost
20038: PPUSH
20039: LD_INT 2
20041: PPUSH
20042: CALL_OW 338
// exit ;
20046: GO 20239
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20048: LD_INT 37
20050: PPUSH
20051: LD_INT 1
20053: PPUSH
20054: CALL_OW 424
// time := 0 0$30 ;
20058: LD_ADDR_VAR 0 7
20062: PUSH
20063: LD_INT 1050
20065: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20066: LD_ADDR_EXP 71
20070: PUSH
20071: LD_EXP 71
20075: PPUSH
20076: LD_INT 3
20078: PPUSH
20079: LD_INT 0
20081: PPUSH
20082: CALL_OW 1
20086: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20087: LD_ADDR_OWVAR 47
20091: PUSH
20092: LD_STRING #Am15a-1
20094: PUSH
20095: LD_VAR 0 7
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20104: LD_INT 35
20106: PPUSH
20107: CALL_OW 67
// time := time - 0 0$1 ;
20111: LD_ADDR_VAR 0 7
20115: PUSH
20116: LD_VAR 0 7
20120: PUSH
20121: LD_INT 35
20123: MINUS
20124: ST_TO_ADDR
// until time = 0 0$00 ;
20125: LD_VAR 0 7
20129: PUSH
20130: LD_INT 0
20132: EQUAL
20133: IFFALSE 20087
// display_strings :=  ;
20135: LD_ADDR_OWVAR 47
20139: PUSH
20140: LD_STRING 
20142: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20143: LD_INT 37
20145: PPUSH
20146: LD_INT 0
20148: PPUSH
20149: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20153: LD_ADDR_VAR 0 8
20157: PUSH
20158: LD_INT 37
20160: PPUSH
20161: LD_INT 3
20163: PUSH
20164: LD_INT 21
20166: PUSH
20167: LD_INT 3
20169: PUSH
20170: EMPTY
20171: LIST
20172: LIST
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: PPUSH
20178: CALL_OW 70
20182: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20183: LD_VAR 0 3
20187: PPUSH
20188: LD_VAR 0 4
20192: PPUSH
20193: CALL_OW 84
// for un in list do
20197: LD_ADDR_VAR 0 9
20201: PUSH
20202: LD_VAR 0 8
20206: PUSH
20207: FOR_IN
20208: IFFALSE 20237
// TeleportUnit ( un , x , y , 12 , true ) ;
20210: LD_VAR 0 9
20214: PPUSH
20215: LD_VAR 0 3
20219: PPUSH
20220: LD_VAR 0 4
20224: PPUSH
20225: LD_INT 12
20227: PPUSH
20228: LD_INT 1
20230: PPUSH
20231: CALL_OW 483
20235: GO 20207
20237: POP
20238: POP
// end ; end ;
20239: PPOPN 9
20241: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20242: LD_INT 0
20244: PPUSH
20245: PPUSH
// begin labNum := 0 ;
20246: LD_ADDR_VAR 0 4
20250: PUSH
20251: LD_INT 0
20253: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20254: LD_ADDR_VAR 0 3
20258: PUSH
20259: DOUBLE
20260: LD_INT 1
20262: DEC
20263: ST_TO_ADDR
20264: LD_EXP 69
20268: PUSH
20269: FOR_TO
20270: IFFALSE 20304
// if artifactsLabs [ i ] = lab then
20272: LD_EXP 69
20276: PUSH
20277: LD_VAR 0 3
20281: ARRAY
20282: PUSH
20283: LD_VAR 0 1
20287: EQUAL
20288: IFFALSE 20302
// begin labNum := i ;
20290: LD_ADDR_VAR 0 4
20294: PUSH
20295: LD_VAR 0 3
20299: ST_TO_ADDR
// break ;
20300: GO 20304
// end ;
20302: GO 20269
20304: POP
20305: POP
// if not labNum then
20306: LD_VAR 0 4
20310: NOT
20311: IFFALSE 20315
// exit ;
20313: GO 20393
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20315: LD_INT 7
20317: PPUSH
20318: LD_EXP 70
20322: PUSH
20323: LD_VAR 0 4
20327: ARRAY
20328: PUSH
20329: LD_INT 3
20331: ARRAY
20332: PPUSH
20333: LD_INT 2
20335: PPUSH
20336: LD_VAR 0 1
20340: PPUSH
20341: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20345: LD_ADDR_EXP 68
20349: PUSH
20350: LD_EXP 68
20354: PPUSH
20355: LD_VAR 0 4
20359: PPUSH
20360: LD_VAR 0 2
20364: PPUSH
20365: CALL_OW 1
20369: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20370: LD_ADDR_EXP 66
20374: PUSH
20375: LD_EXP 66
20379: PPUSH
20380: LD_VAR 0 4
20384: PPUSH
20385: LD_INT 0
20387: PPUSH
20388: CALL_OW 1
20392: ST_TO_ADDR
// end ;
20393: PPOPN 4
20395: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20396: LD_INT 0
20398: PPUSH
20399: PPUSH
// begin labNum := 0 ;
20400: LD_ADDR_VAR 0 3
20404: PUSH
20405: LD_INT 0
20407: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20408: LD_ADDR_VAR 0 2
20412: PUSH
20413: DOUBLE
20414: LD_INT 1
20416: DEC
20417: ST_TO_ADDR
20418: LD_EXP 69
20422: PUSH
20423: FOR_TO
20424: IFFALSE 20458
// if artifactsLabs [ i ] = lab then
20426: LD_EXP 69
20430: PUSH
20431: LD_VAR 0 2
20435: ARRAY
20436: PUSH
20437: LD_VAR 0 1
20441: EQUAL
20442: IFFALSE 20456
// begin labNum := i ;
20444: LD_ADDR_VAR 0 3
20448: PUSH
20449: LD_VAR 0 2
20453: ST_TO_ADDR
// break ;
20454: GO 20458
// end ;
20456: GO 20423
20458: POP
20459: POP
// if not labNum then
20460: LD_VAR 0 3
20464: NOT
20465: IFFALSE 20469
// exit ;
20467: GO 20631
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20469: LD_INT 7
20471: PPUSH
20472: LD_EXP 70
20476: PUSH
20477: LD_VAR 0 3
20481: ARRAY
20482: PUSH
20483: LD_INT 3
20485: ARRAY
20486: PPUSH
20487: LD_INT 0
20489: PPUSH
20490: LD_VAR 0 1
20494: PPUSH
20495: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20499: LD_ADDR_EXP 65
20503: PUSH
20504: LD_EXP 65
20508: PPUSH
20509: LD_VAR 0 3
20513: PPUSH
20514: LD_INT 1
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20522: LD_ADDR_EXP 71
20526: PUSH
20527: LD_EXP 71
20531: PPUSH
20532: LD_VAR 0 3
20536: PPUSH
20537: LD_INT 1
20539: PPUSH
20540: CALL_OW 1
20544: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20545: LD_ADDR_EXP 66
20549: PUSH
20550: LD_EXP 66
20554: PPUSH
20555: LD_VAR 0 3
20559: PPUSH
20560: LD_INT 0
20562: PPUSH
20563: CALL_OW 1
20567: ST_TO_ADDR
// case labNum of 1 :
20568: LD_VAR 0 3
20572: PUSH
20573: LD_INT 1
20575: DOUBLE
20576: EQUAL
20577: IFTRUE 20581
20579: GO 20592
20581: POP
// artifactIResearched := true ; 2 :
20582: LD_ADDR_EXP 12
20586: PUSH
20587: LD_INT 1
20589: ST_TO_ADDR
20590: GO 20631
20592: LD_INT 2
20594: DOUBLE
20595: EQUAL
20596: IFTRUE 20600
20598: GO 20611
20600: POP
// artifactIIResearched := true ; 3 :
20601: LD_ADDR_EXP 13
20605: PUSH
20606: LD_INT 1
20608: ST_TO_ADDR
20609: GO 20631
20611: LD_INT 3
20613: DOUBLE
20614: EQUAL
20615: IFTRUE 20619
20617: GO 20630
20619: POP
// artifactIIIResearched := true ; end ;
20620: LD_ADDR_EXP 14
20624: PUSH
20625: LD_INT 1
20627: ST_TO_ADDR
20628: GO 20631
20630: POP
// end ; end_of_file
20631: PPOPN 3
20633: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
20634: LD_INT 0
20636: PPUSH
// ar_miner := 81 ;
20637: LD_ADDR_EXP 79
20641: PUSH
20642: LD_INT 81
20644: ST_TO_ADDR
// ar_crane := 88 ;
20645: LD_ADDR_EXP 78
20649: PUSH
20650: LD_INT 88
20652: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20653: LD_ADDR_EXP 73
20657: PUSH
20658: LD_INT 89
20660: ST_TO_ADDR
// us_hack := 99 ;
20661: LD_ADDR_EXP 74
20665: PUSH
20666: LD_INT 99
20668: ST_TO_ADDR
// us_artillery := 97 ;
20669: LD_ADDR_EXP 75
20673: PUSH
20674: LD_INT 97
20676: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20677: LD_ADDR_EXP 76
20681: PUSH
20682: LD_INT 91
20684: ST_TO_ADDR
// ar_mortar := 92 ;
20685: LD_ADDR_EXP 77
20689: PUSH
20690: LD_INT 92
20692: ST_TO_ADDR
// ru_radar := 98 ;
20693: LD_ADDR_EXP 72
20697: PUSH
20698: LD_INT 98
20700: ST_TO_ADDR
// tech_Artillery := 80 ;
20701: LD_ADDR_EXP 80
20705: PUSH
20706: LD_INT 80
20708: ST_TO_ADDR
// tech_RadMat := 81 ;
20709: LD_ADDR_EXP 81
20713: PUSH
20714: LD_INT 81
20716: ST_TO_ADDR
// tech_BasicTools := 82 ;
20717: LD_ADDR_EXP 82
20721: PUSH
20722: LD_INT 82
20724: ST_TO_ADDR
// tech_Cargo := 83 ;
20725: LD_ADDR_EXP 83
20729: PUSH
20730: LD_INT 83
20732: ST_TO_ADDR
// tech_Track := 84 ;
20733: LD_ADDR_EXP 84
20737: PUSH
20738: LD_INT 84
20740: ST_TO_ADDR
// tech_Crane := 85 ;
20741: LD_ADDR_EXP 85
20745: PUSH
20746: LD_INT 85
20748: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20749: LD_ADDR_EXP 86
20753: PUSH
20754: LD_INT 86
20756: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20757: LD_ADDR_EXP 87
20761: PUSH
20762: LD_INT 87
20764: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
20765: LD_ADDR_EXP 88
20769: PUSH
20770: LD_INT 88
20772: ST_TO_ADDR
// class_mastodont := 31 ;
20773: LD_ADDR_EXP 89
20777: PUSH
20778: LD_INT 31
20780: ST_TO_ADDR
// class_horse := 21 ;
20781: LD_ADDR_EXP 90
20785: PUSH
20786: LD_INT 21
20788: ST_TO_ADDR
// end ;
20789: LD_VAR 0 1
20793: RET
// every 1 do
20794: GO 20796
20796: DISABLE
// InitGlobalVariables ; end_of_file
20797: CALL 20634 0 0
20801: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
20802: LD_INT 0
20804: PPUSH
20805: PPUSH
// skirmish := false ;
20806: LD_ADDR_EXP 91
20810: PUSH
20811: LD_INT 0
20813: ST_TO_ADDR
// debug_mc := false ;
20814: LD_ADDR_EXP 92
20818: PUSH
20819: LD_INT 0
20821: ST_TO_ADDR
// mc_bases := [ ] ;
20822: LD_ADDR_EXP 93
20826: PUSH
20827: EMPTY
20828: ST_TO_ADDR
// mc_sides := [ ] ;
20829: LD_ADDR_EXP 119
20833: PUSH
20834: EMPTY
20835: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20836: LD_ADDR_EXP 94
20840: PUSH
20841: EMPTY
20842: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20843: LD_ADDR_EXP 95
20847: PUSH
20848: EMPTY
20849: ST_TO_ADDR
// mc_need_heal := [ ] ;
20850: LD_ADDR_EXP 96
20854: PUSH
20855: EMPTY
20856: ST_TO_ADDR
// mc_healers := [ ] ;
20857: LD_ADDR_EXP 97
20861: PUSH
20862: EMPTY
20863: ST_TO_ADDR
// mc_build_list := [ ] ;
20864: LD_ADDR_EXP 98
20868: PUSH
20869: EMPTY
20870: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20871: LD_ADDR_EXP 125
20875: PUSH
20876: EMPTY
20877: ST_TO_ADDR
// mc_builders := [ ] ;
20878: LD_ADDR_EXP 99
20882: PUSH
20883: EMPTY
20884: ST_TO_ADDR
// mc_construct_list := [ ] ;
20885: LD_ADDR_EXP 100
20889: PUSH
20890: EMPTY
20891: ST_TO_ADDR
// mc_turret_list := [ ] ;
20892: LD_ADDR_EXP 101
20896: PUSH
20897: EMPTY
20898: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20899: LD_ADDR_EXP 102
20903: PUSH
20904: EMPTY
20905: ST_TO_ADDR
// mc_miners := [ ] ;
20906: LD_ADDR_EXP 107
20910: PUSH
20911: EMPTY
20912: ST_TO_ADDR
// mc_mines := [ ] ;
20913: LD_ADDR_EXP 106
20917: PUSH
20918: EMPTY
20919: ST_TO_ADDR
// mc_minefields := [ ] ;
20920: LD_ADDR_EXP 108
20924: PUSH
20925: EMPTY
20926: ST_TO_ADDR
// mc_crates := [ ] ;
20927: LD_ADDR_EXP 109
20931: PUSH
20932: EMPTY
20933: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20934: LD_ADDR_EXP 110
20938: PUSH
20939: EMPTY
20940: ST_TO_ADDR
// mc_crates_area := [ ] ;
20941: LD_ADDR_EXP 111
20945: PUSH
20946: EMPTY
20947: ST_TO_ADDR
// mc_vehicles := [ ] ;
20948: LD_ADDR_EXP 112
20952: PUSH
20953: EMPTY
20954: ST_TO_ADDR
// mc_attack := [ ] ;
20955: LD_ADDR_EXP 113
20959: PUSH
20960: EMPTY
20961: ST_TO_ADDR
// mc_produce := [ ] ;
20962: LD_ADDR_EXP 114
20966: PUSH
20967: EMPTY
20968: ST_TO_ADDR
// mc_defender := [ ] ;
20969: LD_ADDR_EXP 115
20973: PUSH
20974: EMPTY
20975: ST_TO_ADDR
// mc_parking := [ ] ;
20976: LD_ADDR_EXP 117
20980: PUSH
20981: EMPTY
20982: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20983: LD_ADDR_EXP 103
20987: PUSH
20988: EMPTY
20989: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20990: LD_ADDR_EXP 105
20994: PUSH
20995: EMPTY
20996: ST_TO_ADDR
// mc_scan := [ ] ;
20997: LD_ADDR_EXP 116
21001: PUSH
21002: EMPTY
21003: ST_TO_ADDR
// mc_scan_area := [ ] ;
21004: LD_ADDR_EXP 118
21008: PUSH
21009: EMPTY
21010: ST_TO_ADDR
// mc_tech := [ ] ;
21011: LD_ADDR_EXP 120
21015: PUSH
21016: EMPTY
21017: ST_TO_ADDR
// mc_class := [ ] ;
21018: LD_ADDR_EXP 134
21022: PUSH
21023: EMPTY
21024: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21025: LD_ADDR_EXP 135
21029: PUSH
21030: EMPTY
21031: ST_TO_ADDR
// mc_is_defending := [ ] ;
21032: LD_ADDR_EXP 136
21036: PUSH
21037: EMPTY
21038: ST_TO_ADDR
// end ;
21039: LD_VAR 0 1
21043: RET
// export function MC_Kill ( base ) ; begin
21044: LD_INT 0
21046: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21047: LD_ADDR_EXP 93
21051: PUSH
21052: LD_EXP 93
21056: PPUSH
21057: LD_VAR 0 1
21061: PPUSH
21062: EMPTY
21063: PPUSH
21064: CALL_OW 1
21068: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21069: LD_ADDR_EXP 94
21073: PUSH
21074: LD_EXP 94
21078: PPUSH
21079: LD_VAR 0 1
21083: PPUSH
21084: EMPTY
21085: PPUSH
21086: CALL_OW 1
21090: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21091: LD_ADDR_EXP 95
21095: PUSH
21096: LD_EXP 95
21100: PPUSH
21101: LD_VAR 0 1
21105: PPUSH
21106: EMPTY
21107: PPUSH
21108: CALL_OW 1
21112: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21113: LD_ADDR_EXP 96
21117: PUSH
21118: LD_EXP 96
21122: PPUSH
21123: LD_VAR 0 1
21127: PPUSH
21128: EMPTY
21129: PPUSH
21130: CALL_OW 1
21134: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21135: LD_ADDR_EXP 97
21139: PUSH
21140: LD_EXP 97
21144: PPUSH
21145: LD_VAR 0 1
21149: PPUSH
21150: EMPTY
21151: PPUSH
21152: CALL_OW 1
21156: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21157: LD_ADDR_EXP 98
21161: PUSH
21162: LD_EXP 98
21166: PPUSH
21167: LD_VAR 0 1
21171: PPUSH
21172: EMPTY
21173: PPUSH
21174: CALL_OW 1
21178: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21179: LD_ADDR_EXP 99
21183: PUSH
21184: LD_EXP 99
21188: PPUSH
21189: LD_VAR 0 1
21193: PPUSH
21194: EMPTY
21195: PPUSH
21196: CALL_OW 1
21200: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21201: LD_ADDR_EXP 100
21205: PUSH
21206: LD_EXP 100
21210: PPUSH
21211: LD_VAR 0 1
21215: PPUSH
21216: EMPTY
21217: PPUSH
21218: CALL_OW 1
21222: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21223: LD_ADDR_EXP 101
21227: PUSH
21228: LD_EXP 101
21232: PPUSH
21233: LD_VAR 0 1
21237: PPUSH
21238: EMPTY
21239: PPUSH
21240: CALL_OW 1
21244: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21245: LD_ADDR_EXP 102
21249: PUSH
21250: LD_EXP 102
21254: PPUSH
21255: LD_VAR 0 1
21259: PPUSH
21260: EMPTY
21261: PPUSH
21262: CALL_OW 1
21266: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21267: LD_ADDR_EXP 103
21271: PUSH
21272: LD_EXP 103
21276: PPUSH
21277: LD_VAR 0 1
21281: PPUSH
21282: EMPTY
21283: PPUSH
21284: CALL_OW 1
21288: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21289: LD_ADDR_EXP 104
21293: PUSH
21294: LD_EXP 104
21298: PPUSH
21299: LD_VAR 0 1
21303: PPUSH
21304: LD_INT 0
21306: PPUSH
21307: CALL_OW 1
21311: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21312: LD_ADDR_EXP 105
21316: PUSH
21317: LD_EXP 105
21321: PPUSH
21322: LD_VAR 0 1
21326: PPUSH
21327: EMPTY
21328: PPUSH
21329: CALL_OW 1
21333: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21334: LD_ADDR_EXP 106
21338: PUSH
21339: LD_EXP 106
21343: PPUSH
21344: LD_VAR 0 1
21348: PPUSH
21349: EMPTY
21350: PPUSH
21351: CALL_OW 1
21355: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21356: LD_ADDR_EXP 107
21360: PUSH
21361: LD_EXP 107
21365: PPUSH
21366: LD_VAR 0 1
21370: PPUSH
21371: EMPTY
21372: PPUSH
21373: CALL_OW 1
21377: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21378: LD_ADDR_EXP 108
21382: PUSH
21383: LD_EXP 108
21387: PPUSH
21388: LD_VAR 0 1
21392: PPUSH
21393: EMPTY
21394: PPUSH
21395: CALL_OW 1
21399: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21400: LD_ADDR_EXP 109
21404: PUSH
21405: LD_EXP 109
21409: PPUSH
21410: LD_VAR 0 1
21414: PPUSH
21415: EMPTY
21416: PPUSH
21417: CALL_OW 1
21421: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21422: LD_ADDR_EXP 110
21426: PUSH
21427: LD_EXP 110
21431: PPUSH
21432: LD_VAR 0 1
21436: PPUSH
21437: EMPTY
21438: PPUSH
21439: CALL_OW 1
21443: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21444: LD_ADDR_EXP 111
21448: PUSH
21449: LD_EXP 111
21453: PPUSH
21454: LD_VAR 0 1
21458: PPUSH
21459: EMPTY
21460: PPUSH
21461: CALL_OW 1
21465: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21466: LD_ADDR_EXP 112
21470: PUSH
21471: LD_EXP 112
21475: PPUSH
21476: LD_VAR 0 1
21480: PPUSH
21481: EMPTY
21482: PPUSH
21483: CALL_OW 1
21487: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21488: LD_ADDR_EXP 113
21492: PUSH
21493: LD_EXP 113
21497: PPUSH
21498: LD_VAR 0 1
21502: PPUSH
21503: EMPTY
21504: PPUSH
21505: CALL_OW 1
21509: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21510: LD_ADDR_EXP 114
21514: PUSH
21515: LD_EXP 114
21519: PPUSH
21520: LD_VAR 0 1
21524: PPUSH
21525: EMPTY
21526: PPUSH
21527: CALL_OW 1
21531: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21532: LD_ADDR_EXP 115
21536: PUSH
21537: LD_EXP 115
21541: PPUSH
21542: LD_VAR 0 1
21546: PPUSH
21547: EMPTY
21548: PPUSH
21549: CALL_OW 1
21553: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21554: LD_ADDR_EXP 116
21558: PUSH
21559: LD_EXP 116
21563: PPUSH
21564: LD_VAR 0 1
21568: PPUSH
21569: EMPTY
21570: PPUSH
21571: CALL_OW 1
21575: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21576: LD_ADDR_EXP 117
21580: PUSH
21581: LD_EXP 117
21585: PPUSH
21586: LD_VAR 0 1
21590: PPUSH
21591: EMPTY
21592: PPUSH
21593: CALL_OW 1
21597: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21598: LD_ADDR_EXP 118
21602: PUSH
21603: LD_EXP 118
21607: PPUSH
21608: LD_VAR 0 1
21612: PPUSH
21613: EMPTY
21614: PPUSH
21615: CALL_OW 1
21619: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21620: LD_ADDR_EXP 120
21624: PUSH
21625: LD_EXP 120
21629: PPUSH
21630: LD_VAR 0 1
21634: PPUSH
21635: EMPTY
21636: PPUSH
21637: CALL_OW 1
21641: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21642: LD_ADDR_EXP 122
21646: PUSH
21647: LD_EXP 122
21651: PPUSH
21652: LD_VAR 0 1
21656: PPUSH
21657: EMPTY
21658: PPUSH
21659: CALL_OW 1
21663: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21664: LD_ADDR_EXP 123
21668: PUSH
21669: LD_EXP 123
21673: PPUSH
21674: LD_VAR 0 1
21678: PPUSH
21679: EMPTY
21680: PPUSH
21681: CALL_OW 1
21685: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21686: LD_ADDR_EXP 124
21690: PUSH
21691: LD_EXP 124
21695: PPUSH
21696: LD_VAR 0 1
21700: PPUSH
21701: EMPTY
21702: PPUSH
21703: CALL_OW 1
21707: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21708: LD_ADDR_EXP 125
21712: PUSH
21713: LD_EXP 125
21717: PPUSH
21718: LD_VAR 0 1
21722: PPUSH
21723: EMPTY
21724: PPUSH
21725: CALL_OW 1
21729: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21730: LD_ADDR_EXP 126
21734: PUSH
21735: LD_EXP 126
21739: PPUSH
21740: LD_VAR 0 1
21744: PPUSH
21745: EMPTY
21746: PPUSH
21747: CALL_OW 1
21751: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21752: LD_ADDR_EXP 127
21756: PUSH
21757: LD_EXP 127
21761: PPUSH
21762: LD_VAR 0 1
21766: PPUSH
21767: EMPTY
21768: PPUSH
21769: CALL_OW 1
21773: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21774: LD_ADDR_EXP 128
21778: PUSH
21779: LD_EXP 128
21783: PPUSH
21784: LD_VAR 0 1
21788: PPUSH
21789: EMPTY
21790: PPUSH
21791: CALL_OW 1
21795: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21796: LD_ADDR_EXP 129
21800: PUSH
21801: LD_EXP 129
21805: PPUSH
21806: LD_VAR 0 1
21810: PPUSH
21811: EMPTY
21812: PPUSH
21813: CALL_OW 1
21817: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21818: LD_ADDR_EXP 130
21822: PUSH
21823: LD_EXP 130
21827: PPUSH
21828: LD_VAR 0 1
21832: PPUSH
21833: EMPTY
21834: PPUSH
21835: CALL_OW 1
21839: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21840: LD_ADDR_EXP 131
21844: PUSH
21845: LD_EXP 131
21849: PPUSH
21850: LD_VAR 0 1
21854: PPUSH
21855: EMPTY
21856: PPUSH
21857: CALL_OW 1
21861: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21862: LD_ADDR_EXP 132
21866: PUSH
21867: LD_EXP 132
21871: PPUSH
21872: LD_VAR 0 1
21876: PPUSH
21877: EMPTY
21878: PPUSH
21879: CALL_OW 1
21883: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21884: LD_ADDR_EXP 133
21888: PUSH
21889: LD_EXP 133
21893: PPUSH
21894: LD_VAR 0 1
21898: PPUSH
21899: EMPTY
21900: PPUSH
21901: CALL_OW 1
21905: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21906: LD_ADDR_EXP 134
21910: PUSH
21911: LD_EXP 134
21915: PPUSH
21916: LD_VAR 0 1
21920: PPUSH
21921: EMPTY
21922: PPUSH
21923: CALL_OW 1
21927: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21928: LD_ADDR_EXP 135
21932: PUSH
21933: LD_EXP 135
21937: PPUSH
21938: LD_VAR 0 1
21942: PPUSH
21943: LD_INT 0
21945: PPUSH
21946: CALL_OW 1
21950: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
21951: LD_ADDR_EXP 136
21955: PUSH
21956: LD_EXP 136
21960: PPUSH
21961: LD_VAR 0 1
21965: PPUSH
21966: LD_INT 0
21968: PPUSH
21969: CALL_OW 1
21973: ST_TO_ADDR
// end ;
21974: LD_VAR 0 2
21978: RET
// export function MC_Add ( side , units ) ; var base ; begin
21979: LD_INT 0
21981: PPUSH
21982: PPUSH
// base := mc_bases + 1 ;
21983: LD_ADDR_VAR 0 4
21987: PUSH
21988: LD_EXP 93
21992: PUSH
21993: LD_INT 1
21995: PLUS
21996: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21997: LD_ADDR_EXP 119
22001: PUSH
22002: LD_EXP 119
22006: PPUSH
22007: LD_VAR 0 4
22011: PPUSH
22012: LD_VAR 0 1
22016: PPUSH
22017: CALL_OW 1
22021: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22022: LD_ADDR_EXP 93
22026: PUSH
22027: LD_EXP 93
22031: PPUSH
22032: LD_VAR 0 4
22036: PPUSH
22037: LD_VAR 0 2
22041: PPUSH
22042: CALL_OW 1
22046: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22047: LD_ADDR_EXP 94
22051: PUSH
22052: LD_EXP 94
22056: PPUSH
22057: LD_VAR 0 4
22061: PPUSH
22062: EMPTY
22063: PPUSH
22064: CALL_OW 1
22068: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22069: LD_ADDR_EXP 95
22073: PUSH
22074: LD_EXP 95
22078: PPUSH
22079: LD_VAR 0 4
22083: PPUSH
22084: EMPTY
22085: PPUSH
22086: CALL_OW 1
22090: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22091: LD_ADDR_EXP 96
22095: PUSH
22096: LD_EXP 96
22100: PPUSH
22101: LD_VAR 0 4
22105: PPUSH
22106: EMPTY
22107: PPUSH
22108: CALL_OW 1
22112: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22113: LD_ADDR_EXP 97
22117: PUSH
22118: LD_EXP 97
22122: PPUSH
22123: LD_VAR 0 4
22127: PPUSH
22128: EMPTY
22129: PPUSH
22130: CALL_OW 1
22134: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22135: LD_ADDR_EXP 98
22139: PUSH
22140: LD_EXP 98
22144: PPUSH
22145: LD_VAR 0 4
22149: PPUSH
22150: EMPTY
22151: PPUSH
22152: CALL_OW 1
22156: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22157: LD_ADDR_EXP 99
22161: PUSH
22162: LD_EXP 99
22166: PPUSH
22167: LD_VAR 0 4
22171: PPUSH
22172: EMPTY
22173: PPUSH
22174: CALL_OW 1
22178: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22179: LD_ADDR_EXP 100
22183: PUSH
22184: LD_EXP 100
22188: PPUSH
22189: LD_VAR 0 4
22193: PPUSH
22194: EMPTY
22195: PPUSH
22196: CALL_OW 1
22200: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22201: LD_ADDR_EXP 101
22205: PUSH
22206: LD_EXP 101
22210: PPUSH
22211: LD_VAR 0 4
22215: PPUSH
22216: EMPTY
22217: PPUSH
22218: CALL_OW 1
22222: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22223: LD_ADDR_EXP 102
22227: PUSH
22228: LD_EXP 102
22232: PPUSH
22233: LD_VAR 0 4
22237: PPUSH
22238: EMPTY
22239: PPUSH
22240: CALL_OW 1
22244: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22245: LD_ADDR_EXP 103
22249: PUSH
22250: LD_EXP 103
22254: PPUSH
22255: LD_VAR 0 4
22259: PPUSH
22260: EMPTY
22261: PPUSH
22262: CALL_OW 1
22266: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22267: LD_ADDR_EXP 104
22271: PUSH
22272: LD_EXP 104
22276: PPUSH
22277: LD_VAR 0 4
22281: PPUSH
22282: LD_INT 0
22284: PPUSH
22285: CALL_OW 1
22289: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22290: LD_ADDR_EXP 105
22294: PUSH
22295: LD_EXP 105
22299: PPUSH
22300: LD_VAR 0 4
22304: PPUSH
22305: EMPTY
22306: PPUSH
22307: CALL_OW 1
22311: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22312: LD_ADDR_EXP 106
22316: PUSH
22317: LD_EXP 106
22321: PPUSH
22322: LD_VAR 0 4
22326: PPUSH
22327: EMPTY
22328: PPUSH
22329: CALL_OW 1
22333: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22334: LD_ADDR_EXP 107
22338: PUSH
22339: LD_EXP 107
22343: PPUSH
22344: LD_VAR 0 4
22348: PPUSH
22349: EMPTY
22350: PPUSH
22351: CALL_OW 1
22355: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22356: LD_ADDR_EXP 108
22360: PUSH
22361: LD_EXP 108
22365: PPUSH
22366: LD_VAR 0 4
22370: PPUSH
22371: EMPTY
22372: PPUSH
22373: CALL_OW 1
22377: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22378: LD_ADDR_EXP 109
22382: PUSH
22383: LD_EXP 109
22387: PPUSH
22388: LD_VAR 0 4
22392: PPUSH
22393: EMPTY
22394: PPUSH
22395: CALL_OW 1
22399: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22400: LD_ADDR_EXP 110
22404: PUSH
22405: LD_EXP 110
22409: PPUSH
22410: LD_VAR 0 4
22414: PPUSH
22415: EMPTY
22416: PPUSH
22417: CALL_OW 1
22421: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22422: LD_ADDR_EXP 111
22426: PUSH
22427: LD_EXP 111
22431: PPUSH
22432: LD_VAR 0 4
22436: PPUSH
22437: EMPTY
22438: PPUSH
22439: CALL_OW 1
22443: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22444: LD_ADDR_EXP 112
22448: PUSH
22449: LD_EXP 112
22453: PPUSH
22454: LD_VAR 0 4
22458: PPUSH
22459: EMPTY
22460: PPUSH
22461: CALL_OW 1
22465: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22466: LD_ADDR_EXP 113
22470: PUSH
22471: LD_EXP 113
22475: PPUSH
22476: LD_VAR 0 4
22480: PPUSH
22481: EMPTY
22482: PPUSH
22483: CALL_OW 1
22487: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22488: LD_ADDR_EXP 114
22492: PUSH
22493: LD_EXP 114
22497: PPUSH
22498: LD_VAR 0 4
22502: PPUSH
22503: EMPTY
22504: PPUSH
22505: CALL_OW 1
22509: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22510: LD_ADDR_EXP 115
22514: PUSH
22515: LD_EXP 115
22519: PPUSH
22520: LD_VAR 0 4
22524: PPUSH
22525: EMPTY
22526: PPUSH
22527: CALL_OW 1
22531: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22532: LD_ADDR_EXP 116
22536: PUSH
22537: LD_EXP 116
22541: PPUSH
22542: LD_VAR 0 4
22546: PPUSH
22547: EMPTY
22548: PPUSH
22549: CALL_OW 1
22553: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22554: LD_ADDR_EXP 117
22558: PUSH
22559: LD_EXP 117
22563: PPUSH
22564: LD_VAR 0 4
22568: PPUSH
22569: EMPTY
22570: PPUSH
22571: CALL_OW 1
22575: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22576: LD_ADDR_EXP 118
22580: PUSH
22581: LD_EXP 118
22585: PPUSH
22586: LD_VAR 0 4
22590: PPUSH
22591: EMPTY
22592: PPUSH
22593: CALL_OW 1
22597: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22598: LD_ADDR_EXP 120
22602: PUSH
22603: LD_EXP 120
22607: PPUSH
22608: LD_VAR 0 4
22612: PPUSH
22613: EMPTY
22614: PPUSH
22615: CALL_OW 1
22619: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22620: LD_ADDR_EXP 122
22624: PUSH
22625: LD_EXP 122
22629: PPUSH
22630: LD_VAR 0 4
22634: PPUSH
22635: EMPTY
22636: PPUSH
22637: CALL_OW 1
22641: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22642: LD_ADDR_EXP 123
22646: PUSH
22647: LD_EXP 123
22651: PPUSH
22652: LD_VAR 0 4
22656: PPUSH
22657: EMPTY
22658: PPUSH
22659: CALL_OW 1
22663: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22664: LD_ADDR_EXP 124
22668: PUSH
22669: LD_EXP 124
22673: PPUSH
22674: LD_VAR 0 4
22678: PPUSH
22679: EMPTY
22680: PPUSH
22681: CALL_OW 1
22685: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22686: LD_ADDR_EXP 125
22690: PUSH
22691: LD_EXP 125
22695: PPUSH
22696: LD_VAR 0 4
22700: PPUSH
22701: EMPTY
22702: PPUSH
22703: CALL_OW 1
22707: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22708: LD_ADDR_EXP 126
22712: PUSH
22713: LD_EXP 126
22717: PPUSH
22718: LD_VAR 0 4
22722: PPUSH
22723: EMPTY
22724: PPUSH
22725: CALL_OW 1
22729: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22730: LD_ADDR_EXP 127
22734: PUSH
22735: LD_EXP 127
22739: PPUSH
22740: LD_VAR 0 4
22744: PPUSH
22745: EMPTY
22746: PPUSH
22747: CALL_OW 1
22751: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22752: LD_ADDR_EXP 128
22756: PUSH
22757: LD_EXP 128
22761: PPUSH
22762: LD_VAR 0 4
22766: PPUSH
22767: EMPTY
22768: PPUSH
22769: CALL_OW 1
22773: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22774: LD_ADDR_EXP 129
22778: PUSH
22779: LD_EXP 129
22783: PPUSH
22784: LD_VAR 0 4
22788: PPUSH
22789: EMPTY
22790: PPUSH
22791: CALL_OW 1
22795: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22796: LD_ADDR_EXP 130
22800: PUSH
22801: LD_EXP 130
22805: PPUSH
22806: LD_VAR 0 4
22810: PPUSH
22811: EMPTY
22812: PPUSH
22813: CALL_OW 1
22817: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22818: LD_ADDR_EXP 131
22822: PUSH
22823: LD_EXP 131
22827: PPUSH
22828: LD_VAR 0 4
22832: PPUSH
22833: EMPTY
22834: PPUSH
22835: CALL_OW 1
22839: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22840: LD_ADDR_EXP 132
22844: PUSH
22845: LD_EXP 132
22849: PPUSH
22850: LD_VAR 0 4
22854: PPUSH
22855: EMPTY
22856: PPUSH
22857: CALL_OW 1
22861: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22862: LD_ADDR_EXP 133
22866: PUSH
22867: LD_EXP 133
22871: PPUSH
22872: LD_VAR 0 4
22876: PPUSH
22877: EMPTY
22878: PPUSH
22879: CALL_OW 1
22883: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22884: LD_ADDR_EXP 134
22888: PUSH
22889: LD_EXP 134
22893: PPUSH
22894: LD_VAR 0 4
22898: PPUSH
22899: EMPTY
22900: PPUSH
22901: CALL_OW 1
22905: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22906: LD_ADDR_EXP 135
22910: PUSH
22911: LD_EXP 135
22915: PPUSH
22916: LD_VAR 0 4
22920: PPUSH
22921: LD_INT 0
22923: PPUSH
22924: CALL_OW 1
22928: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22929: LD_ADDR_EXP 136
22933: PUSH
22934: LD_EXP 136
22938: PPUSH
22939: LD_VAR 0 4
22943: PPUSH
22944: LD_INT 0
22946: PPUSH
22947: CALL_OW 1
22951: ST_TO_ADDR
// result := base ;
22952: LD_ADDR_VAR 0 3
22956: PUSH
22957: LD_VAR 0 4
22961: ST_TO_ADDR
// end ;
22962: LD_VAR 0 3
22966: RET
// export function MC_Start ( ) ; var i ; begin
22967: LD_INT 0
22969: PPUSH
22970: PPUSH
// for i = 1 to mc_bases do
22971: LD_ADDR_VAR 0 2
22975: PUSH
22976: DOUBLE
22977: LD_INT 1
22979: DEC
22980: ST_TO_ADDR
22981: LD_EXP 93
22985: PUSH
22986: FOR_TO
22987: IFFALSE 24087
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22989: LD_ADDR_EXP 93
22993: PUSH
22994: LD_EXP 93
22998: PPUSH
22999: LD_VAR 0 2
23003: PPUSH
23004: LD_EXP 93
23008: PUSH
23009: LD_VAR 0 2
23013: ARRAY
23014: PUSH
23015: LD_INT 0
23017: DIFF
23018: PPUSH
23019: CALL_OW 1
23023: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23024: LD_ADDR_EXP 94
23028: PUSH
23029: LD_EXP 94
23033: PPUSH
23034: LD_VAR 0 2
23038: PPUSH
23039: EMPTY
23040: PPUSH
23041: CALL_OW 1
23045: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23046: LD_ADDR_EXP 95
23050: PUSH
23051: LD_EXP 95
23055: PPUSH
23056: LD_VAR 0 2
23060: PPUSH
23061: EMPTY
23062: PPUSH
23063: CALL_OW 1
23067: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23068: LD_ADDR_EXP 96
23072: PUSH
23073: LD_EXP 96
23077: PPUSH
23078: LD_VAR 0 2
23082: PPUSH
23083: EMPTY
23084: PPUSH
23085: CALL_OW 1
23089: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23090: LD_ADDR_EXP 97
23094: PUSH
23095: LD_EXP 97
23099: PPUSH
23100: LD_VAR 0 2
23104: PPUSH
23105: EMPTY
23106: PUSH
23107: EMPTY
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: PPUSH
23113: CALL_OW 1
23117: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23118: LD_ADDR_EXP 98
23122: PUSH
23123: LD_EXP 98
23127: PPUSH
23128: LD_VAR 0 2
23132: PPUSH
23133: EMPTY
23134: PPUSH
23135: CALL_OW 1
23139: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23140: LD_ADDR_EXP 125
23144: PUSH
23145: LD_EXP 125
23149: PPUSH
23150: LD_VAR 0 2
23154: PPUSH
23155: EMPTY
23156: PPUSH
23157: CALL_OW 1
23161: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23162: LD_ADDR_EXP 99
23166: PUSH
23167: LD_EXP 99
23171: PPUSH
23172: LD_VAR 0 2
23176: PPUSH
23177: EMPTY
23178: PPUSH
23179: CALL_OW 1
23183: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23184: LD_ADDR_EXP 100
23188: PUSH
23189: LD_EXP 100
23193: PPUSH
23194: LD_VAR 0 2
23198: PPUSH
23199: EMPTY
23200: PPUSH
23201: CALL_OW 1
23205: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23206: LD_ADDR_EXP 101
23210: PUSH
23211: LD_EXP 101
23215: PPUSH
23216: LD_VAR 0 2
23220: PPUSH
23221: LD_EXP 93
23225: PUSH
23226: LD_VAR 0 2
23230: ARRAY
23231: PPUSH
23232: LD_INT 2
23234: PUSH
23235: LD_INT 30
23237: PUSH
23238: LD_INT 32
23240: PUSH
23241: EMPTY
23242: LIST
23243: LIST
23244: PUSH
23245: LD_INT 30
23247: PUSH
23248: LD_INT 33
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: PUSH
23255: EMPTY
23256: LIST
23257: LIST
23258: LIST
23259: PPUSH
23260: CALL_OW 72
23264: PPUSH
23265: CALL_OW 1
23269: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23270: LD_ADDR_EXP 102
23274: PUSH
23275: LD_EXP 102
23279: PPUSH
23280: LD_VAR 0 2
23284: PPUSH
23285: LD_EXP 93
23289: PUSH
23290: LD_VAR 0 2
23294: ARRAY
23295: PPUSH
23296: LD_INT 2
23298: PUSH
23299: LD_INT 30
23301: PUSH
23302: LD_INT 32
23304: PUSH
23305: EMPTY
23306: LIST
23307: LIST
23308: PUSH
23309: LD_INT 30
23311: PUSH
23312: LD_INT 31
23314: PUSH
23315: EMPTY
23316: LIST
23317: LIST
23318: PUSH
23319: EMPTY
23320: LIST
23321: LIST
23322: LIST
23323: PUSH
23324: LD_INT 58
23326: PUSH
23327: EMPTY
23328: LIST
23329: PUSH
23330: EMPTY
23331: LIST
23332: LIST
23333: PPUSH
23334: CALL_OW 72
23338: PPUSH
23339: CALL_OW 1
23343: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23344: LD_ADDR_EXP 103
23348: PUSH
23349: LD_EXP 103
23353: PPUSH
23354: LD_VAR 0 2
23358: PPUSH
23359: EMPTY
23360: PPUSH
23361: CALL_OW 1
23365: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23366: LD_ADDR_EXP 107
23370: PUSH
23371: LD_EXP 107
23375: PPUSH
23376: LD_VAR 0 2
23380: PPUSH
23381: EMPTY
23382: PPUSH
23383: CALL_OW 1
23387: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23388: LD_ADDR_EXP 106
23392: PUSH
23393: LD_EXP 106
23397: PPUSH
23398: LD_VAR 0 2
23402: PPUSH
23403: EMPTY
23404: PPUSH
23405: CALL_OW 1
23409: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23410: LD_ADDR_EXP 108
23414: PUSH
23415: LD_EXP 108
23419: PPUSH
23420: LD_VAR 0 2
23424: PPUSH
23425: EMPTY
23426: PPUSH
23427: CALL_OW 1
23431: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23432: LD_ADDR_EXP 109
23436: PUSH
23437: LD_EXP 109
23441: PPUSH
23442: LD_VAR 0 2
23446: PPUSH
23447: EMPTY
23448: PPUSH
23449: CALL_OW 1
23453: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23454: LD_ADDR_EXP 110
23458: PUSH
23459: LD_EXP 110
23463: PPUSH
23464: LD_VAR 0 2
23468: PPUSH
23469: EMPTY
23470: PPUSH
23471: CALL_OW 1
23475: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23476: LD_ADDR_EXP 111
23480: PUSH
23481: LD_EXP 111
23485: PPUSH
23486: LD_VAR 0 2
23490: PPUSH
23491: EMPTY
23492: PPUSH
23493: CALL_OW 1
23497: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23498: LD_ADDR_EXP 112
23502: PUSH
23503: LD_EXP 112
23507: PPUSH
23508: LD_VAR 0 2
23512: PPUSH
23513: EMPTY
23514: PPUSH
23515: CALL_OW 1
23519: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23520: LD_ADDR_EXP 113
23524: PUSH
23525: LD_EXP 113
23529: PPUSH
23530: LD_VAR 0 2
23534: PPUSH
23535: EMPTY
23536: PPUSH
23537: CALL_OW 1
23541: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23542: LD_ADDR_EXP 114
23546: PUSH
23547: LD_EXP 114
23551: PPUSH
23552: LD_VAR 0 2
23556: PPUSH
23557: EMPTY
23558: PPUSH
23559: CALL_OW 1
23563: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23564: LD_ADDR_EXP 115
23568: PUSH
23569: LD_EXP 115
23573: PPUSH
23574: LD_VAR 0 2
23578: PPUSH
23579: EMPTY
23580: PPUSH
23581: CALL_OW 1
23585: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23586: LD_ADDR_EXP 104
23590: PUSH
23591: LD_EXP 104
23595: PPUSH
23596: LD_VAR 0 2
23600: PPUSH
23601: LD_INT 0
23603: PPUSH
23604: CALL_OW 1
23608: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23609: LD_ADDR_EXP 117
23613: PUSH
23614: LD_EXP 117
23618: PPUSH
23619: LD_VAR 0 2
23623: PPUSH
23624: LD_INT 0
23626: PPUSH
23627: CALL_OW 1
23631: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23632: LD_ADDR_EXP 105
23636: PUSH
23637: LD_EXP 105
23641: PPUSH
23642: LD_VAR 0 2
23646: PPUSH
23647: EMPTY
23648: PPUSH
23649: CALL_OW 1
23653: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23654: LD_ADDR_EXP 116
23658: PUSH
23659: LD_EXP 116
23663: PPUSH
23664: LD_VAR 0 2
23668: PPUSH
23669: LD_INT 0
23671: PPUSH
23672: CALL_OW 1
23676: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23677: LD_ADDR_EXP 118
23681: PUSH
23682: LD_EXP 118
23686: PPUSH
23687: LD_VAR 0 2
23691: PPUSH
23692: EMPTY
23693: PPUSH
23694: CALL_OW 1
23698: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23699: LD_ADDR_EXP 121
23703: PUSH
23704: LD_EXP 121
23708: PPUSH
23709: LD_VAR 0 2
23713: PPUSH
23714: LD_INT 0
23716: PPUSH
23717: CALL_OW 1
23721: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23722: LD_ADDR_EXP 122
23726: PUSH
23727: LD_EXP 122
23731: PPUSH
23732: LD_VAR 0 2
23736: PPUSH
23737: EMPTY
23738: PPUSH
23739: CALL_OW 1
23743: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23744: LD_ADDR_EXP 123
23748: PUSH
23749: LD_EXP 123
23753: PPUSH
23754: LD_VAR 0 2
23758: PPUSH
23759: EMPTY
23760: PPUSH
23761: CALL_OW 1
23765: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23766: LD_ADDR_EXP 124
23770: PUSH
23771: LD_EXP 124
23775: PPUSH
23776: LD_VAR 0 2
23780: PPUSH
23781: EMPTY
23782: PPUSH
23783: CALL_OW 1
23787: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23788: LD_ADDR_EXP 126
23792: PUSH
23793: LD_EXP 126
23797: PPUSH
23798: LD_VAR 0 2
23802: PPUSH
23803: LD_EXP 93
23807: PUSH
23808: LD_VAR 0 2
23812: ARRAY
23813: PPUSH
23814: LD_INT 2
23816: PUSH
23817: LD_INT 30
23819: PUSH
23820: LD_INT 6
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: PUSH
23827: LD_INT 30
23829: PUSH
23830: LD_INT 7
23832: PUSH
23833: EMPTY
23834: LIST
23835: LIST
23836: PUSH
23837: LD_INT 30
23839: PUSH
23840: LD_INT 8
23842: PUSH
23843: EMPTY
23844: LIST
23845: LIST
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 72
23857: PPUSH
23858: CALL_OW 1
23862: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23863: LD_ADDR_EXP 127
23867: PUSH
23868: LD_EXP 127
23872: PPUSH
23873: LD_VAR 0 2
23877: PPUSH
23878: EMPTY
23879: PPUSH
23880: CALL_OW 1
23884: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23885: LD_ADDR_EXP 128
23889: PUSH
23890: LD_EXP 128
23894: PPUSH
23895: LD_VAR 0 2
23899: PPUSH
23900: EMPTY
23901: PPUSH
23902: CALL_OW 1
23906: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23907: LD_ADDR_EXP 129
23911: PUSH
23912: LD_EXP 129
23916: PPUSH
23917: LD_VAR 0 2
23921: PPUSH
23922: EMPTY
23923: PPUSH
23924: CALL_OW 1
23928: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23929: LD_ADDR_EXP 130
23933: PUSH
23934: LD_EXP 130
23938: PPUSH
23939: LD_VAR 0 2
23943: PPUSH
23944: EMPTY
23945: PPUSH
23946: CALL_OW 1
23950: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23951: LD_ADDR_EXP 131
23955: PUSH
23956: LD_EXP 131
23960: PPUSH
23961: LD_VAR 0 2
23965: PPUSH
23966: EMPTY
23967: PPUSH
23968: CALL_OW 1
23972: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23973: LD_ADDR_EXP 132
23977: PUSH
23978: LD_EXP 132
23982: PPUSH
23983: LD_VAR 0 2
23987: PPUSH
23988: EMPTY
23989: PPUSH
23990: CALL_OW 1
23994: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23995: LD_ADDR_EXP 133
23999: PUSH
24000: LD_EXP 133
24004: PPUSH
24005: LD_VAR 0 2
24009: PPUSH
24010: EMPTY
24011: PPUSH
24012: CALL_OW 1
24016: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24017: LD_ADDR_EXP 134
24021: PUSH
24022: LD_EXP 134
24026: PPUSH
24027: LD_VAR 0 2
24031: PPUSH
24032: EMPTY
24033: PPUSH
24034: CALL_OW 1
24038: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24039: LD_ADDR_EXP 135
24043: PUSH
24044: LD_EXP 135
24048: PPUSH
24049: LD_VAR 0 2
24053: PPUSH
24054: LD_INT 0
24056: PPUSH
24057: CALL_OW 1
24061: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24062: LD_ADDR_EXP 136
24066: PUSH
24067: LD_EXP 136
24071: PPUSH
24072: LD_VAR 0 2
24076: PPUSH
24077: LD_INT 0
24079: PPUSH
24080: CALL_OW 1
24084: ST_TO_ADDR
// end ;
24085: GO 22986
24087: POP
24088: POP
// MC_InitSides ( ) ;
24089: CALL 24375 0 0
// MC_InitResearch ( ) ;
24093: CALL 24114 0 0
// CustomInitMacro ( ) ;
24097: CALL 217 0 0
// skirmish := true ;
24101: LD_ADDR_EXP 91
24105: PUSH
24106: LD_INT 1
24108: ST_TO_ADDR
// end ;
24109: LD_VAR 0 1
24113: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24114: LD_INT 0
24116: PPUSH
24117: PPUSH
24118: PPUSH
24119: PPUSH
24120: PPUSH
24121: PPUSH
// if not mc_bases then
24122: LD_EXP 93
24126: NOT
24127: IFFALSE 24131
// exit ;
24129: GO 24370
// for i = 1 to 8 do
24131: LD_ADDR_VAR 0 2
24135: PUSH
24136: DOUBLE
24137: LD_INT 1
24139: DEC
24140: ST_TO_ADDR
24141: LD_INT 8
24143: PUSH
24144: FOR_TO
24145: IFFALSE 24171
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24147: LD_ADDR_EXP 120
24151: PUSH
24152: LD_EXP 120
24156: PPUSH
24157: LD_VAR 0 2
24161: PPUSH
24162: EMPTY
24163: PPUSH
24164: CALL_OW 1
24168: ST_TO_ADDR
24169: GO 24144
24171: POP
24172: POP
// tmp := [ ] ;
24173: LD_ADDR_VAR 0 5
24177: PUSH
24178: EMPTY
24179: ST_TO_ADDR
// for i = 1 to mc_sides do
24180: LD_ADDR_VAR 0 2
24184: PUSH
24185: DOUBLE
24186: LD_INT 1
24188: DEC
24189: ST_TO_ADDR
24190: LD_EXP 119
24194: PUSH
24195: FOR_TO
24196: IFFALSE 24254
// if not mc_sides [ i ] in tmp then
24198: LD_EXP 119
24202: PUSH
24203: LD_VAR 0 2
24207: ARRAY
24208: PUSH
24209: LD_VAR 0 5
24213: IN
24214: NOT
24215: IFFALSE 24252
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24217: LD_ADDR_VAR 0 5
24221: PUSH
24222: LD_VAR 0 5
24226: PPUSH
24227: LD_VAR 0 5
24231: PUSH
24232: LD_INT 1
24234: PLUS
24235: PPUSH
24236: LD_EXP 119
24240: PUSH
24241: LD_VAR 0 2
24245: ARRAY
24246: PPUSH
24247: CALL_OW 2
24251: ST_TO_ADDR
24252: GO 24195
24254: POP
24255: POP
// if not tmp then
24256: LD_VAR 0 5
24260: NOT
24261: IFFALSE 24265
// exit ;
24263: GO 24370
// for j in tmp do
24265: LD_ADDR_VAR 0 3
24269: PUSH
24270: LD_VAR 0 5
24274: PUSH
24275: FOR_IN
24276: IFFALSE 24368
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24278: LD_ADDR_VAR 0 6
24282: PUSH
24283: LD_INT 22
24285: PUSH
24286: LD_VAR 0 3
24290: PUSH
24291: EMPTY
24292: LIST
24293: LIST
24294: PPUSH
24295: CALL_OW 69
24299: ST_TO_ADDR
// if not un then
24300: LD_VAR 0 6
24304: NOT
24305: IFFALSE 24309
// continue ;
24307: GO 24275
// nation := GetNation ( un [ 1 ] ) ;
24309: LD_ADDR_VAR 0 4
24313: PUSH
24314: LD_VAR 0 6
24318: PUSH
24319: LD_INT 1
24321: ARRAY
24322: PPUSH
24323: CALL_OW 248
24327: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24328: LD_ADDR_EXP 120
24332: PUSH
24333: LD_EXP 120
24337: PPUSH
24338: LD_VAR 0 3
24342: PPUSH
24343: LD_VAR 0 3
24347: PPUSH
24348: LD_VAR 0 4
24352: PPUSH
24353: LD_INT 1
24355: PPUSH
24356: CALL 51181 0 3
24360: PPUSH
24361: CALL_OW 1
24365: ST_TO_ADDR
// end ;
24366: GO 24275
24368: POP
24369: POP
// end ;
24370: LD_VAR 0 1
24374: RET
// export function MC_InitSides ( ) ; var i ; begin
24375: LD_INT 0
24377: PPUSH
24378: PPUSH
// if not mc_bases then
24379: LD_EXP 93
24383: NOT
24384: IFFALSE 24388
// exit ;
24386: GO 24462
// for i = 1 to mc_bases do
24388: LD_ADDR_VAR 0 2
24392: PUSH
24393: DOUBLE
24394: LD_INT 1
24396: DEC
24397: ST_TO_ADDR
24398: LD_EXP 93
24402: PUSH
24403: FOR_TO
24404: IFFALSE 24460
// if mc_bases [ i ] then
24406: LD_EXP 93
24410: PUSH
24411: LD_VAR 0 2
24415: ARRAY
24416: IFFALSE 24458
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24418: LD_ADDR_EXP 119
24422: PUSH
24423: LD_EXP 119
24427: PPUSH
24428: LD_VAR 0 2
24432: PPUSH
24433: LD_EXP 93
24437: PUSH
24438: LD_VAR 0 2
24442: ARRAY
24443: PUSH
24444: LD_INT 1
24446: ARRAY
24447: PPUSH
24448: CALL_OW 255
24452: PPUSH
24453: CALL_OW 1
24457: ST_TO_ADDR
24458: GO 24403
24460: POP
24461: POP
// end ;
24462: LD_VAR 0 1
24466: RET
// every 0 0$03 trigger skirmish do
24467: LD_EXP 91
24471: IFFALSE 24625
24473: GO 24475
24475: DISABLE
// begin enable ;
24476: ENABLE
// MC_CheckBuildings ( ) ;
24477: CALL 29123 0 0
// MC_CheckPeopleLife ( ) ;
24481: CALL 29248 0 0
// RaiseSailEvent ( 100 ) ;
24485: LD_INT 100
24487: PPUSH
24488: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24492: LD_INT 103
24494: PPUSH
24495: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24499: LD_INT 104
24501: PPUSH
24502: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24506: LD_INT 105
24508: PPUSH
24509: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24513: LD_INT 106
24515: PPUSH
24516: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24520: LD_INT 107
24522: PPUSH
24523: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24527: LD_INT 108
24529: PPUSH
24530: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24534: LD_INT 109
24536: PPUSH
24537: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24541: LD_INT 110
24543: PPUSH
24544: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24548: LD_INT 111
24550: PPUSH
24551: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24555: LD_INT 112
24557: PPUSH
24558: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24562: LD_INT 113
24564: PPUSH
24565: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24569: LD_INT 120
24571: PPUSH
24572: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24576: LD_INT 121
24578: PPUSH
24579: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24583: LD_INT 122
24585: PPUSH
24586: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24590: LD_INT 123
24592: PPUSH
24593: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24597: LD_INT 124
24599: PPUSH
24600: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24604: LD_INT 125
24606: PPUSH
24607: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24611: LD_INT 126
24613: PPUSH
24614: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24618: LD_INT 200
24620: PPUSH
24621: CALL_OW 427
// end ;
24625: END
// on SailEvent ( event ) do begin if event < 100 then
24626: LD_VAR 0 1
24630: PUSH
24631: LD_INT 100
24633: LESS
24634: IFFALSE 24645
// CustomEvent ( event ) ;
24636: LD_VAR 0 1
24640: PPUSH
24641: CALL 10417 0 1
// if event = 100 then
24645: LD_VAR 0 1
24649: PUSH
24650: LD_INT 100
24652: EQUAL
24653: IFFALSE 24659
// MC_ClassManager ( ) ;
24655: CALL 25051 0 0
// if event = 101 then
24659: LD_VAR 0 1
24663: PUSH
24664: LD_INT 101
24666: EQUAL
24667: IFFALSE 24673
// MC_RepairBuildings ( ) ;
24669: CALL 29833 0 0
// if event = 102 then
24673: LD_VAR 0 1
24677: PUSH
24678: LD_INT 102
24680: EQUAL
24681: IFFALSE 24687
// MC_Heal ( ) ;
24683: CALL 30718 0 0
// if event = 103 then
24687: LD_VAR 0 1
24691: PUSH
24692: LD_INT 103
24694: EQUAL
24695: IFFALSE 24701
// MC_Build ( ) ;
24697: CALL 31140 0 0
// if event = 104 then
24701: LD_VAR 0 1
24705: PUSH
24706: LD_INT 104
24708: EQUAL
24709: IFFALSE 24715
// MC_TurretWeapon ( ) ;
24711: CALL 32781 0 0
// if event = 105 then
24715: LD_VAR 0 1
24719: PUSH
24720: LD_INT 105
24722: EQUAL
24723: IFFALSE 24729
// MC_BuildUpgrade ( ) ;
24725: CALL 32332 0 0
// if event = 106 then
24729: LD_VAR 0 1
24733: PUSH
24734: LD_INT 106
24736: EQUAL
24737: IFFALSE 24743
// MC_PlantMines ( ) ;
24739: CALL 33211 0 0
// if event = 107 then
24743: LD_VAR 0 1
24747: PUSH
24748: LD_INT 107
24750: EQUAL
24751: IFFALSE 24757
// MC_CollectCrates ( ) ;
24753: CALL 34002 0 0
// if event = 108 then
24757: LD_VAR 0 1
24761: PUSH
24762: LD_INT 108
24764: EQUAL
24765: IFFALSE 24771
// MC_LinkRemoteControl ( ) ;
24767: CALL 35778 0 0
// if event = 109 then
24771: LD_VAR 0 1
24775: PUSH
24776: LD_INT 109
24778: EQUAL
24779: IFFALSE 24785
// MC_ProduceVehicle ( ) ;
24781: CALL 35959 0 0
// if event = 110 then
24785: LD_VAR 0 1
24789: PUSH
24790: LD_INT 110
24792: EQUAL
24793: IFFALSE 24799
// MC_SendAttack ( ) ;
24795: CALL 36425 0 0
// if event = 111 then
24799: LD_VAR 0 1
24803: PUSH
24804: LD_INT 111
24806: EQUAL
24807: IFFALSE 24813
// MC_Defend ( ) ;
24809: CALL 36533 0 0
// if event = 112 then
24813: LD_VAR 0 1
24817: PUSH
24818: LD_INT 112
24820: EQUAL
24821: IFFALSE 24827
// MC_Research ( ) ;
24823: CALL 37255 0 0
// if event = 113 then
24827: LD_VAR 0 1
24831: PUSH
24832: LD_INT 113
24834: EQUAL
24835: IFFALSE 24841
// MC_MinesTrigger ( ) ;
24837: CALL 38369 0 0
// if event = 120 then
24841: LD_VAR 0 1
24845: PUSH
24846: LD_INT 120
24848: EQUAL
24849: IFFALSE 24855
// MC_RepairVehicle ( ) ;
24851: CALL 38468 0 0
// if event = 121 then
24855: LD_VAR 0 1
24859: PUSH
24860: LD_INT 121
24862: EQUAL
24863: IFFALSE 24869
// MC_TameApe ( ) ;
24865: CALL 39198 0 0
// if event = 122 then
24869: LD_VAR 0 1
24873: PUSH
24874: LD_INT 122
24876: EQUAL
24877: IFFALSE 24883
// MC_ChangeApeClass ( ) ;
24879: CALL 40027 0 0
// if event = 123 then
24883: LD_VAR 0 1
24887: PUSH
24888: LD_INT 123
24890: EQUAL
24891: IFFALSE 24897
// MC_Bazooka ( ) ;
24893: CALL 40677 0 0
// if event = 124 then
24897: LD_VAR 0 1
24901: PUSH
24902: LD_INT 124
24904: EQUAL
24905: IFFALSE 24911
// MC_TeleportExit ( ) ;
24907: CALL 40875 0 0
// if event = 125 then
24911: LD_VAR 0 1
24915: PUSH
24916: LD_INT 125
24918: EQUAL
24919: IFFALSE 24925
// MC_Deposits ( ) ;
24921: CALL 41522 0 0
// if event = 126 then
24925: LD_VAR 0 1
24929: PUSH
24930: LD_INT 126
24932: EQUAL
24933: IFFALSE 24939
// MC_RemoteDriver ( ) ;
24935: CALL 42147 0 0
// if event = 200 then
24939: LD_VAR 0 1
24943: PUSH
24944: LD_INT 200
24946: EQUAL
24947: IFFALSE 24953
// MC_Idle ( ) ;
24949: CALL 44096 0 0
// end ;
24953: PPOPN 1
24955: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24956: LD_INT 0
24958: PPUSH
24959: PPUSH
// if not mc_bases [ base ] or not tag then
24960: LD_EXP 93
24964: PUSH
24965: LD_VAR 0 1
24969: ARRAY
24970: NOT
24971: PUSH
24972: LD_VAR 0 2
24976: NOT
24977: OR
24978: IFFALSE 24982
// exit ;
24980: GO 25046
// for i in mc_bases [ base ] union mc_ape [ base ] do
24982: LD_ADDR_VAR 0 4
24986: PUSH
24987: LD_EXP 93
24991: PUSH
24992: LD_VAR 0 1
24996: ARRAY
24997: PUSH
24998: LD_EXP 122
25002: PUSH
25003: LD_VAR 0 1
25007: ARRAY
25008: UNION
25009: PUSH
25010: FOR_IN
25011: IFFALSE 25044
// if GetTag ( i ) = tag then
25013: LD_VAR 0 4
25017: PPUSH
25018: CALL_OW 110
25022: PUSH
25023: LD_VAR 0 2
25027: EQUAL
25028: IFFALSE 25042
// SetTag ( i , 0 ) ;
25030: LD_VAR 0 4
25034: PPUSH
25035: LD_INT 0
25037: PPUSH
25038: CALL_OW 109
25042: GO 25010
25044: POP
25045: POP
// end ;
25046: LD_VAR 0 3
25050: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25051: LD_INT 0
25053: PPUSH
25054: PPUSH
25055: PPUSH
25056: PPUSH
25057: PPUSH
25058: PPUSH
25059: PPUSH
25060: PPUSH
// if not mc_bases then
25061: LD_EXP 93
25065: NOT
25066: IFFALSE 25070
// exit ;
25068: GO 25528
// for i = 1 to mc_bases do
25070: LD_ADDR_VAR 0 2
25074: PUSH
25075: DOUBLE
25076: LD_INT 1
25078: DEC
25079: ST_TO_ADDR
25080: LD_EXP 93
25084: PUSH
25085: FOR_TO
25086: IFFALSE 25526
// begin tmp := MC_ClassCheckReq ( i ) ;
25088: LD_ADDR_VAR 0 4
25092: PUSH
25093: LD_VAR 0 2
25097: PPUSH
25098: CALL 25533 0 1
25102: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25103: LD_ADDR_EXP 134
25107: PUSH
25108: LD_EXP 134
25112: PPUSH
25113: LD_VAR 0 2
25117: PPUSH
25118: LD_VAR 0 4
25122: PPUSH
25123: CALL_OW 1
25127: ST_TO_ADDR
// if not tmp then
25128: LD_VAR 0 4
25132: NOT
25133: IFFALSE 25137
// continue ;
25135: GO 25085
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25137: LD_ADDR_VAR 0 6
25141: PUSH
25142: LD_EXP 93
25146: PUSH
25147: LD_VAR 0 2
25151: ARRAY
25152: PPUSH
25153: LD_INT 2
25155: PUSH
25156: LD_INT 30
25158: PUSH
25159: LD_INT 4
25161: PUSH
25162: EMPTY
25163: LIST
25164: LIST
25165: PUSH
25166: LD_INT 30
25168: PUSH
25169: LD_INT 5
25171: PUSH
25172: EMPTY
25173: LIST
25174: LIST
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: LIST
25180: PPUSH
25181: CALL_OW 72
25185: PUSH
25186: LD_EXP 93
25190: PUSH
25191: LD_VAR 0 2
25195: ARRAY
25196: PPUSH
25197: LD_INT 2
25199: PUSH
25200: LD_INT 30
25202: PUSH
25203: LD_INT 0
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: PUSH
25210: LD_INT 30
25212: PUSH
25213: LD_INT 1
25215: PUSH
25216: EMPTY
25217: LIST
25218: LIST
25219: PUSH
25220: EMPTY
25221: LIST
25222: LIST
25223: LIST
25224: PPUSH
25225: CALL_OW 72
25229: PUSH
25230: LD_EXP 93
25234: PUSH
25235: LD_VAR 0 2
25239: ARRAY
25240: PPUSH
25241: LD_INT 30
25243: PUSH
25244: LD_INT 3
25246: PUSH
25247: EMPTY
25248: LIST
25249: LIST
25250: PPUSH
25251: CALL_OW 72
25255: PUSH
25256: LD_EXP 93
25260: PUSH
25261: LD_VAR 0 2
25265: ARRAY
25266: PPUSH
25267: LD_INT 2
25269: PUSH
25270: LD_INT 30
25272: PUSH
25273: LD_INT 6
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: LD_INT 30
25282: PUSH
25283: LD_INT 7
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: LD_INT 30
25292: PUSH
25293: LD_INT 8
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: EMPTY
25301: LIST
25302: LIST
25303: LIST
25304: LIST
25305: PPUSH
25306: CALL_OW 72
25310: PUSH
25311: EMPTY
25312: LIST
25313: LIST
25314: LIST
25315: LIST
25316: ST_TO_ADDR
// for j = 1 to 4 do
25317: LD_ADDR_VAR 0 3
25321: PUSH
25322: DOUBLE
25323: LD_INT 1
25325: DEC
25326: ST_TO_ADDR
25327: LD_INT 4
25329: PUSH
25330: FOR_TO
25331: IFFALSE 25522
// begin if not tmp [ j ] then
25333: LD_VAR 0 4
25337: PUSH
25338: LD_VAR 0 3
25342: ARRAY
25343: NOT
25344: IFFALSE 25348
// continue ;
25346: GO 25330
// for p in tmp [ j ] do
25348: LD_ADDR_VAR 0 5
25352: PUSH
25353: LD_VAR 0 4
25357: PUSH
25358: LD_VAR 0 3
25362: ARRAY
25363: PUSH
25364: FOR_IN
25365: IFFALSE 25518
// begin if not b [ j ] then
25367: LD_VAR 0 6
25371: PUSH
25372: LD_VAR 0 3
25376: ARRAY
25377: NOT
25378: IFFALSE 25382
// break ;
25380: GO 25518
// e := 0 ;
25382: LD_ADDR_VAR 0 7
25386: PUSH
25387: LD_INT 0
25389: ST_TO_ADDR
// for k in b [ j ] do
25390: LD_ADDR_VAR 0 8
25394: PUSH
25395: LD_VAR 0 6
25399: PUSH
25400: LD_VAR 0 3
25404: ARRAY
25405: PUSH
25406: FOR_IN
25407: IFFALSE 25434
// if IsNotFull ( k ) then
25409: LD_VAR 0 8
25413: PPUSH
25414: CALL 53334 0 1
25418: IFFALSE 25432
// begin e := k ;
25420: LD_ADDR_VAR 0 7
25424: PUSH
25425: LD_VAR 0 8
25429: ST_TO_ADDR
// break ;
25430: GO 25434
// end ;
25432: GO 25406
25434: POP
25435: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25436: LD_VAR 0 7
25440: PUSH
25441: LD_VAR 0 5
25445: PPUSH
25446: LD_VAR 0 7
25450: PPUSH
25451: CALL 86499 0 2
25455: NOT
25456: AND
25457: IFFALSE 25516
// begin if IsInUnit ( p ) then
25459: LD_VAR 0 5
25463: PPUSH
25464: CALL_OW 310
25468: IFFALSE 25479
// ComExitBuilding ( p ) ;
25470: LD_VAR 0 5
25474: PPUSH
25475: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25479: LD_VAR 0 5
25483: PPUSH
25484: LD_VAR 0 7
25488: PPUSH
25489: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25493: LD_VAR 0 5
25497: PPUSH
25498: LD_VAR 0 3
25502: PPUSH
25503: CALL_OW 183
// AddComExitBuilding ( p ) ;
25507: LD_VAR 0 5
25511: PPUSH
25512: CALL_OW 182
// end ; end ;
25516: GO 25364
25518: POP
25519: POP
// end ;
25520: GO 25330
25522: POP
25523: POP
// end ;
25524: GO 25085
25526: POP
25527: POP
// end ;
25528: LD_VAR 0 1
25532: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25533: LD_INT 0
25535: PPUSH
25536: PPUSH
25537: PPUSH
25538: PPUSH
25539: PPUSH
25540: PPUSH
25541: PPUSH
25542: PPUSH
25543: PPUSH
25544: PPUSH
25545: PPUSH
25546: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25547: LD_VAR 0 1
25551: NOT
25552: PUSH
25553: LD_EXP 93
25557: PUSH
25558: LD_VAR 0 1
25562: ARRAY
25563: NOT
25564: OR
25565: PUSH
25566: LD_EXP 93
25570: PUSH
25571: LD_VAR 0 1
25575: ARRAY
25576: PPUSH
25577: LD_INT 2
25579: PUSH
25580: LD_INT 30
25582: PUSH
25583: LD_INT 0
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: LD_INT 30
25592: PUSH
25593: LD_INT 1
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: PUSH
25600: EMPTY
25601: LIST
25602: LIST
25603: LIST
25604: PPUSH
25605: CALL_OW 72
25609: NOT
25610: OR
25611: IFFALSE 25615
// exit ;
25613: GO 29118
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25615: LD_ADDR_VAR 0 4
25619: PUSH
25620: LD_EXP 93
25624: PUSH
25625: LD_VAR 0 1
25629: ARRAY
25630: PPUSH
25631: LD_INT 2
25633: PUSH
25634: LD_INT 25
25636: PUSH
25637: LD_INT 1
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: PUSH
25644: LD_INT 25
25646: PUSH
25647: LD_INT 2
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: LD_INT 25
25656: PUSH
25657: LD_INT 3
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: LD_INT 25
25666: PUSH
25667: LD_INT 4
25669: PUSH
25670: EMPTY
25671: LIST
25672: LIST
25673: PUSH
25674: LD_INT 25
25676: PUSH
25677: LD_INT 5
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: PUSH
25684: LD_INT 25
25686: PUSH
25687: LD_INT 8
25689: PUSH
25690: EMPTY
25691: LIST
25692: LIST
25693: PUSH
25694: LD_INT 25
25696: PUSH
25697: LD_INT 9
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: LIST
25708: LIST
25709: LIST
25710: LIST
25711: LIST
25712: LIST
25713: PPUSH
25714: CALL_OW 72
25718: ST_TO_ADDR
// if not tmp then
25719: LD_VAR 0 4
25723: NOT
25724: IFFALSE 25728
// exit ;
25726: GO 29118
// for i in tmp do
25728: LD_ADDR_VAR 0 3
25732: PUSH
25733: LD_VAR 0 4
25737: PUSH
25738: FOR_IN
25739: IFFALSE 25770
// if GetTag ( i ) then
25741: LD_VAR 0 3
25745: PPUSH
25746: CALL_OW 110
25750: IFFALSE 25768
// tmp := tmp diff i ;
25752: LD_ADDR_VAR 0 4
25756: PUSH
25757: LD_VAR 0 4
25761: PUSH
25762: LD_VAR 0 3
25766: DIFF
25767: ST_TO_ADDR
25768: GO 25738
25770: POP
25771: POP
// if not tmp then
25772: LD_VAR 0 4
25776: NOT
25777: IFFALSE 25781
// exit ;
25779: GO 29118
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25781: LD_ADDR_VAR 0 5
25785: PUSH
25786: LD_EXP 93
25790: PUSH
25791: LD_VAR 0 1
25795: ARRAY
25796: PPUSH
25797: LD_INT 2
25799: PUSH
25800: LD_INT 25
25802: PUSH
25803: LD_INT 1
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: LD_INT 25
25812: PUSH
25813: LD_INT 5
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 25
25822: PUSH
25823: LD_INT 8
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: LD_INT 25
25832: PUSH
25833: LD_INT 9
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: EMPTY
25841: LIST
25842: LIST
25843: LIST
25844: LIST
25845: LIST
25846: PPUSH
25847: CALL_OW 72
25851: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25852: LD_ADDR_VAR 0 6
25856: PUSH
25857: LD_EXP 93
25861: PUSH
25862: LD_VAR 0 1
25866: ARRAY
25867: PPUSH
25868: LD_INT 25
25870: PUSH
25871: LD_INT 2
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: PPUSH
25878: CALL_OW 72
25882: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25883: LD_ADDR_VAR 0 7
25887: PUSH
25888: LD_EXP 93
25892: PUSH
25893: LD_VAR 0 1
25897: ARRAY
25898: PPUSH
25899: LD_INT 25
25901: PUSH
25902: LD_INT 3
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: PPUSH
25909: CALL_OW 72
25913: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25914: LD_ADDR_VAR 0 8
25918: PUSH
25919: LD_EXP 93
25923: PUSH
25924: LD_VAR 0 1
25928: ARRAY
25929: PPUSH
25930: LD_INT 25
25932: PUSH
25933: LD_INT 4
25935: PUSH
25936: EMPTY
25937: LIST
25938: LIST
25939: PUSH
25940: LD_INT 24
25942: PUSH
25943: LD_INT 251
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: PPUSH
25954: CALL_OW 72
25958: ST_TO_ADDR
// if mc_scan [ base ] then
25959: LD_EXP 116
25963: PUSH
25964: LD_VAR 0 1
25968: ARRAY
25969: IFFALSE 26430
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25971: LD_ADDR_EXP 135
25975: PUSH
25976: LD_EXP 135
25980: PPUSH
25981: LD_VAR 0 1
25985: PPUSH
25986: LD_INT 4
25988: PPUSH
25989: CALL_OW 1
25993: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25994: LD_ADDR_VAR 0 12
25998: PUSH
25999: LD_EXP 93
26003: PUSH
26004: LD_VAR 0 1
26008: ARRAY
26009: PPUSH
26010: LD_INT 2
26012: PUSH
26013: LD_INT 30
26015: PUSH
26016: LD_INT 4
26018: PUSH
26019: EMPTY
26020: LIST
26021: LIST
26022: PUSH
26023: LD_INT 30
26025: PUSH
26026: LD_INT 5
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: PUSH
26033: EMPTY
26034: LIST
26035: LIST
26036: LIST
26037: PPUSH
26038: CALL_OW 72
26042: ST_TO_ADDR
// if not b then
26043: LD_VAR 0 12
26047: NOT
26048: IFFALSE 26052
// exit ;
26050: GO 29118
// p := [ ] ;
26052: LD_ADDR_VAR 0 11
26056: PUSH
26057: EMPTY
26058: ST_TO_ADDR
// if sci >= 2 then
26059: LD_VAR 0 8
26063: PUSH
26064: LD_INT 2
26066: GREATEREQUAL
26067: IFFALSE 26098
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26069: LD_ADDR_VAR 0 8
26073: PUSH
26074: LD_VAR 0 8
26078: PUSH
26079: LD_INT 1
26081: ARRAY
26082: PUSH
26083: LD_VAR 0 8
26087: PUSH
26088: LD_INT 2
26090: ARRAY
26091: PUSH
26092: EMPTY
26093: LIST
26094: LIST
26095: ST_TO_ADDR
26096: GO 26159
// if sci = 1 then
26098: LD_VAR 0 8
26102: PUSH
26103: LD_INT 1
26105: EQUAL
26106: IFFALSE 26127
// sci := [ sci [ 1 ] ] else
26108: LD_ADDR_VAR 0 8
26112: PUSH
26113: LD_VAR 0 8
26117: PUSH
26118: LD_INT 1
26120: ARRAY
26121: PUSH
26122: EMPTY
26123: LIST
26124: ST_TO_ADDR
26125: GO 26159
// if sci = 0 then
26127: LD_VAR 0 8
26131: PUSH
26132: LD_INT 0
26134: EQUAL
26135: IFFALSE 26159
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26137: LD_ADDR_VAR 0 11
26141: PUSH
26142: LD_VAR 0 4
26146: PPUSH
26147: LD_INT 4
26149: PPUSH
26150: CALL 86362 0 2
26154: PUSH
26155: LD_INT 1
26157: ARRAY
26158: ST_TO_ADDR
// if eng > 4 then
26159: LD_VAR 0 6
26163: PUSH
26164: LD_INT 4
26166: GREATER
26167: IFFALSE 26213
// for i = eng downto 4 do
26169: LD_ADDR_VAR 0 3
26173: PUSH
26174: DOUBLE
26175: LD_VAR 0 6
26179: INC
26180: ST_TO_ADDR
26181: LD_INT 4
26183: PUSH
26184: FOR_DOWNTO
26185: IFFALSE 26211
// eng := eng diff eng [ i ] ;
26187: LD_ADDR_VAR 0 6
26191: PUSH
26192: LD_VAR 0 6
26196: PUSH
26197: LD_VAR 0 6
26201: PUSH
26202: LD_VAR 0 3
26206: ARRAY
26207: DIFF
26208: ST_TO_ADDR
26209: GO 26184
26211: POP
26212: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26213: LD_ADDR_VAR 0 4
26217: PUSH
26218: LD_VAR 0 4
26222: PUSH
26223: LD_VAR 0 5
26227: PUSH
26228: LD_VAR 0 6
26232: UNION
26233: PUSH
26234: LD_VAR 0 7
26238: UNION
26239: PUSH
26240: LD_VAR 0 8
26244: UNION
26245: DIFF
26246: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26247: LD_ADDR_VAR 0 13
26251: PUSH
26252: LD_EXP 93
26256: PUSH
26257: LD_VAR 0 1
26261: ARRAY
26262: PPUSH
26263: LD_INT 2
26265: PUSH
26266: LD_INT 30
26268: PUSH
26269: LD_INT 32
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 30
26278: PUSH
26279: LD_INT 31
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: LIST
26290: PPUSH
26291: CALL_OW 72
26295: PUSH
26296: LD_EXP 93
26300: PUSH
26301: LD_VAR 0 1
26305: ARRAY
26306: PPUSH
26307: LD_INT 2
26309: PUSH
26310: LD_INT 30
26312: PUSH
26313: LD_INT 4
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: LD_INT 30
26322: PUSH
26323: LD_INT 5
26325: PUSH
26326: EMPTY
26327: LIST
26328: LIST
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: LIST
26334: PPUSH
26335: CALL_OW 72
26339: PUSH
26340: LD_INT 6
26342: MUL
26343: PLUS
26344: ST_TO_ADDR
// if bcount < tmp then
26345: LD_VAR 0 13
26349: PUSH
26350: LD_VAR 0 4
26354: LESS
26355: IFFALSE 26401
// for i = tmp downto bcount do
26357: LD_ADDR_VAR 0 3
26361: PUSH
26362: DOUBLE
26363: LD_VAR 0 4
26367: INC
26368: ST_TO_ADDR
26369: LD_VAR 0 13
26373: PUSH
26374: FOR_DOWNTO
26375: IFFALSE 26399
// tmp := Delete ( tmp , tmp ) ;
26377: LD_ADDR_VAR 0 4
26381: PUSH
26382: LD_VAR 0 4
26386: PPUSH
26387: LD_VAR 0 4
26391: PPUSH
26392: CALL_OW 3
26396: ST_TO_ADDR
26397: GO 26374
26399: POP
26400: POP
// result := [ tmp , 0 , 0 , p ] ;
26401: LD_ADDR_VAR 0 2
26405: PUSH
26406: LD_VAR 0 4
26410: PUSH
26411: LD_INT 0
26413: PUSH
26414: LD_INT 0
26416: PUSH
26417: LD_VAR 0 11
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: LIST
26426: LIST
26427: ST_TO_ADDR
// exit ;
26428: GO 29118
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26430: LD_EXP 93
26434: PUSH
26435: LD_VAR 0 1
26439: ARRAY
26440: PPUSH
26441: LD_INT 2
26443: PUSH
26444: LD_INT 30
26446: PUSH
26447: LD_INT 6
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: PUSH
26454: LD_INT 30
26456: PUSH
26457: LD_INT 7
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: LD_INT 30
26466: PUSH
26467: LD_INT 8
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: LIST
26478: LIST
26479: PPUSH
26480: CALL_OW 72
26484: NOT
26485: PUSH
26486: LD_EXP 93
26490: PUSH
26491: LD_VAR 0 1
26495: ARRAY
26496: PPUSH
26497: LD_INT 30
26499: PUSH
26500: LD_INT 3
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PPUSH
26507: CALL_OW 72
26511: NOT
26512: AND
26513: IFFALSE 26585
// begin if eng = tmp then
26515: LD_VAR 0 6
26519: PUSH
26520: LD_VAR 0 4
26524: EQUAL
26525: IFFALSE 26529
// exit ;
26527: GO 29118
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26529: LD_ADDR_EXP 135
26533: PUSH
26534: LD_EXP 135
26538: PPUSH
26539: LD_VAR 0 1
26543: PPUSH
26544: LD_INT 1
26546: PPUSH
26547: CALL_OW 1
26551: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26552: LD_ADDR_VAR 0 2
26556: PUSH
26557: LD_INT 0
26559: PUSH
26560: LD_VAR 0 4
26564: PUSH
26565: LD_VAR 0 6
26569: DIFF
26570: PUSH
26571: LD_INT 0
26573: PUSH
26574: LD_INT 0
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: LIST
26581: LIST
26582: ST_TO_ADDR
// exit ;
26583: GO 29118
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26585: LD_EXP 120
26589: PUSH
26590: LD_EXP 119
26594: PUSH
26595: LD_VAR 0 1
26599: ARRAY
26600: ARRAY
26601: PUSH
26602: LD_EXP 93
26606: PUSH
26607: LD_VAR 0 1
26611: ARRAY
26612: PPUSH
26613: LD_INT 2
26615: PUSH
26616: LD_INT 30
26618: PUSH
26619: LD_INT 6
26621: PUSH
26622: EMPTY
26623: LIST
26624: LIST
26625: PUSH
26626: LD_INT 30
26628: PUSH
26629: LD_INT 7
26631: PUSH
26632: EMPTY
26633: LIST
26634: LIST
26635: PUSH
26636: LD_INT 30
26638: PUSH
26639: LD_INT 8
26641: PUSH
26642: EMPTY
26643: LIST
26644: LIST
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: PPUSH
26652: CALL_OW 72
26656: AND
26657: PUSH
26658: LD_EXP 93
26662: PUSH
26663: LD_VAR 0 1
26667: ARRAY
26668: PPUSH
26669: LD_INT 30
26671: PUSH
26672: LD_INT 3
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: PPUSH
26679: CALL_OW 72
26683: NOT
26684: AND
26685: IFFALSE 26899
// begin if sci >= 6 then
26687: LD_VAR 0 8
26691: PUSH
26692: LD_INT 6
26694: GREATEREQUAL
26695: IFFALSE 26699
// exit ;
26697: GO 29118
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26699: LD_ADDR_EXP 135
26703: PUSH
26704: LD_EXP 135
26708: PPUSH
26709: LD_VAR 0 1
26713: PPUSH
26714: LD_INT 2
26716: PPUSH
26717: CALL_OW 1
26721: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26722: LD_ADDR_VAR 0 9
26726: PUSH
26727: LD_VAR 0 4
26731: PUSH
26732: LD_VAR 0 8
26736: DIFF
26737: PPUSH
26738: LD_INT 4
26740: PPUSH
26741: CALL 86362 0 2
26745: ST_TO_ADDR
// p := [ ] ;
26746: LD_ADDR_VAR 0 11
26750: PUSH
26751: EMPTY
26752: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26753: LD_VAR 0 8
26757: PUSH
26758: LD_INT 6
26760: LESS
26761: PUSH
26762: LD_VAR 0 9
26766: PUSH
26767: LD_INT 6
26769: GREATER
26770: AND
26771: IFFALSE 26852
// begin for i = 1 to 6 - sci do
26773: LD_ADDR_VAR 0 3
26777: PUSH
26778: DOUBLE
26779: LD_INT 1
26781: DEC
26782: ST_TO_ADDR
26783: LD_INT 6
26785: PUSH
26786: LD_VAR 0 8
26790: MINUS
26791: PUSH
26792: FOR_TO
26793: IFFALSE 26848
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26795: LD_ADDR_VAR 0 11
26799: PUSH
26800: LD_VAR 0 11
26804: PPUSH
26805: LD_VAR 0 11
26809: PUSH
26810: LD_INT 1
26812: PLUS
26813: PPUSH
26814: LD_VAR 0 9
26818: PUSH
26819: LD_INT 1
26821: ARRAY
26822: PPUSH
26823: CALL_OW 2
26827: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26828: LD_ADDR_VAR 0 9
26832: PUSH
26833: LD_VAR 0 9
26837: PPUSH
26838: LD_INT 1
26840: PPUSH
26841: CALL_OW 3
26845: ST_TO_ADDR
// end ;
26846: GO 26792
26848: POP
26849: POP
// end else
26850: GO 26872
// if sort then
26852: LD_VAR 0 9
26856: IFFALSE 26872
// p := sort [ 1 ] ;
26858: LD_ADDR_VAR 0 11
26862: PUSH
26863: LD_VAR 0 9
26867: PUSH
26868: LD_INT 1
26870: ARRAY
26871: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26872: LD_ADDR_VAR 0 2
26876: PUSH
26877: LD_INT 0
26879: PUSH
26880: LD_INT 0
26882: PUSH
26883: LD_INT 0
26885: PUSH
26886: LD_VAR 0 11
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: LIST
26895: LIST
26896: ST_TO_ADDR
// exit ;
26897: GO 29118
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26899: LD_EXP 120
26903: PUSH
26904: LD_EXP 119
26908: PUSH
26909: LD_VAR 0 1
26913: ARRAY
26914: ARRAY
26915: PUSH
26916: LD_EXP 93
26920: PUSH
26921: LD_VAR 0 1
26925: ARRAY
26926: PPUSH
26927: LD_INT 2
26929: PUSH
26930: LD_INT 30
26932: PUSH
26933: LD_INT 6
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: PUSH
26940: LD_INT 30
26942: PUSH
26943: LD_INT 7
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 30
26952: PUSH
26953: LD_INT 8
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: LIST
26964: LIST
26965: PPUSH
26966: CALL_OW 72
26970: AND
26971: PUSH
26972: LD_EXP 93
26976: PUSH
26977: LD_VAR 0 1
26981: ARRAY
26982: PPUSH
26983: LD_INT 30
26985: PUSH
26986: LD_INT 3
26988: PUSH
26989: EMPTY
26990: LIST
26991: LIST
26992: PPUSH
26993: CALL_OW 72
26997: AND
26998: IFFALSE 27732
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27000: LD_ADDR_EXP 135
27004: PUSH
27005: LD_EXP 135
27009: PPUSH
27010: LD_VAR 0 1
27014: PPUSH
27015: LD_INT 3
27017: PPUSH
27018: CALL_OW 1
27022: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27023: LD_ADDR_VAR 0 2
27027: PUSH
27028: LD_INT 0
27030: PUSH
27031: LD_INT 0
27033: PUSH
27034: LD_INT 0
27036: PUSH
27037: LD_INT 0
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: LIST
27044: LIST
27045: ST_TO_ADDR
// if not eng then
27046: LD_VAR 0 6
27050: NOT
27051: IFFALSE 27114
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27053: LD_ADDR_VAR 0 11
27057: PUSH
27058: LD_VAR 0 4
27062: PPUSH
27063: LD_INT 2
27065: PPUSH
27066: CALL 86362 0 2
27070: PUSH
27071: LD_INT 1
27073: ARRAY
27074: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27075: LD_ADDR_VAR 0 2
27079: PUSH
27080: LD_VAR 0 2
27084: PPUSH
27085: LD_INT 2
27087: PPUSH
27088: LD_VAR 0 11
27092: PPUSH
27093: CALL_OW 1
27097: ST_TO_ADDR
// tmp := tmp diff p ;
27098: LD_ADDR_VAR 0 4
27102: PUSH
27103: LD_VAR 0 4
27107: PUSH
27108: LD_VAR 0 11
27112: DIFF
27113: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27114: LD_VAR 0 4
27118: PUSH
27119: LD_VAR 0 8
27123: PUSH
27124: LD_INT 6
27126: LESS
27127: AND
27128: IFFALSE 27316
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27130: LD_ADDR_VAR 0 9
27134: PUSH
27135: LD_VAR 0 4
27139: PUSH
27140: LD_VAR 0 8
27144: PUSH
27145: LD_VAR 0 7
27149: UNION
27150: DIFF
27151: PPUSH
27152: LD_INT 4
27154: PPUSH
27155: CALL 86362 0 2
27159: ST_TO_ADDR
// p := [ ] ;
27160: LD_ADDR_VAR 0 11
27164: PUSH
27165: EMPTY
27166: ST_TO_ADDR
// if sort then
27167: LD_VAR 0 9
27171: IFFALSE 27287
// for i = 1 to 6 - sci do
27173: LD_ADDR_VAR 0 3
27177: PUSH
27178: DOUBLE
27179: LD_INT 1
27181: DEC
27182: ST_TO_ADDR
27183: LD_INT 6
27185: PUSH
27186: LD_VAR 0 8
27190: MINUS
27191: PUSH
27192: FOR_TO
27193: IFFALSE 27285
// begin if i = sort then
27195: LD_VAR 0 3
27199: PUSH
27200: LD_VAR 0 9
27204: EQUAL
27205: IFFALSE 27209
// break ;
27207: GO 27285
// if GetClass ( i ) = 4 then
27209: LD_VAR 0 3
27213: PPUSH
27214: CALL_OW 257
27218: PUSH
27219: LD_INT 4
27221: EQUAL
27222: IFFALSE 27226
// continue ;
27224: GO 27192
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27226: LD_ADDR_VAR 0 11
27230: PUSH
27231: LD_VAR 0 11
27235: PPUSH
27236: LD_VAR 0 11
27240: PUSH
27241: LD_INT 1
27243: PLUS
27244: PPUSH
27245: LD_VAR 0 9
27249: PUSH
27250: LD_VAR 0 3
27254: ARRAY
27255: PPUSH
27256: CALL_OW 2
27260: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27261: LD_ADDR_VAR 0 4
27265: PUSH
27266: LD_VAR 0 4
27270: PUSH
27271: LD_VAR 0 9
27275: PUSH
27276: LD_VAR 0 3
27280: ARRAY
27281: DIFF
27282: ST_TO_ADDR
// end ;
27283: GO 27192
27285: POP
27286: POP
// if p then
27287: LD_VAR 0 11
27291: IFFALSE 27316
// result := Replace ( result , 4 , p ) ;
27293: LD_ADDR_VAR 0 2
27297: PUSH
27298: LD_VAR 0 2
27302: PPUSH
27303: LD_INT 4
27305: PPUSH
27306: LD_VAR 0 11
27310: PPUSH
27311: CALL_OW 1
27315: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27316: LD_VAR 0 4
27320: PUSH
27321: LD_VAR 0 7
27325: PUSH
27326: LD_INT 6
27328: LESS
27329: AND
27330: IFFALSE 27518
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27332: LD_ADDR_VAR 0 9
27336: PUSH
27337: LD_VAR 0 4
27341: PUSH
27342: LD_VAR 0 8
27346: PUSH
27347: LD_VAR 0 7
27351: UNION
27352: DIFF
27353: PPUSH
27354: LD_INT 3
27356: PPUSH
27357: CALL 86362 0 2
27361: ST_TO_ADDR
// p := [ ] ;
27362: LD_ADDR_VAR 0 11
27366: PUSH
27367: EMPTY
27368: ST_TO_ADDR
// if sort then
27369: LD_VAR 0 9
27373: IFFALSE 27489
// for i = 1 to 6 - mech do
27375: LD_ADDR_VAR 0 3
27379: PUSH
27380: DOUBLE
27381: LD_INT 1
27383: DEC
27384: ST_TO_ADDR
27385: LD_INT 6
27387: PUSH
27388: LD_VAR 0 7
27392: MINUS
27393: PUSH
27394: FOR_TO
27395: IFFALSE 27487
// begin if i = sort then
27397: LD_VAR 0 3
27401: PUSH
27402: LD_VAR 0 9
27406: EQUAL
27407: IFFALSE 27411
// break ;
27409: GO 27487
// if GetClass ( i ) = 3 then
27411: LD_VAR 0 3
27415: PPUSH
27416: CALL_OW 257
27420: PUSH
27421: LD_INT 3
27423: EQUAL
27424: IFFALSE 27428
// continue ;
27426: GO 27394
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27428: LD_ADDR_VAR 0 11
27432: PUSH
27433: LD_VAR 0 11
27437: PPUSH
27438: LD_VAR 0 11
27442: PUSH
27443: LD_INT 1
27445: PLUS
27446: PPUSH
27447: LD_VAR 0 9
27451: PUSH
27452: LD_VAR 0 3
27456: ARRAY
27457: PPUSH
27458: CALL_OW 2
27462: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27463: LD_ADDR_VAR 0 4
27467: PUSH
27468: LD_VAR 0 4
27472: PUSH
27473: LD_VAR 0 9
27477: PUSH
27478: LD_VAR 0 3
27482: ARRAY
27483: DIFF
27484: ST_TO_ADDR
// end ;
27485: GO 27394
27487: POP
27488: POP
// if p then
27489: LD_VAR 0 11
27493: IFFALSE 27518
// result := Replace ( result , 3 , p ) ;
27495: LD_ADDR_VAR 0 2
27499: PUSH
27500: LD_VAR 0 2
27504: PPUSH
27505: LD_INT 3
27507: PPUSH
27508: LD_VAR 0 11
27512: PPUSH
27513: CALL_OW 1
27517: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27518: LD_VAR 0 4
27522: PUSH
27523: LD_INT 6
27525: GREATER
27526: PUSH
27527: LD_VAR 0 6
27531: PUSH
27532: LD_INT 6
27534: LESS
27535: AND
27536: IFFALSE 27730
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27538: LD_ADDR_VAR 0 9
27542: PUSH
27543: LD_VAR 0 4
27547: PUSH
27548: LD_VAR 0 8
27552: PUSH
27553: LD_VAR 0 7
27557: UNION
27558: PUSH
27559: LD_VAR 0 6
27563: UNION
27564: DIFF
27565: PPUSH
27566: LD_INT 2
27568: PPUSH
27569: CALL 86362 0 2
27573: ST_TO_ADDR
// p := [ ] ;
27574: LD_ADDR_VAR 0 11
27578: PUSH
27579: EMPTY
27580: ST_TO_ADDR
// if sort then
27581: LD_VAR 0 9
27585: IFFALSE 27701
// for i = 1 to 6 - eng do
27587: LD_ADDR_VAR 0 3
27591: PUSH
27592: DOUBLE
27593: LD_INT 1
27595: DEC
27596: ST_TO_ADDR
27597: LD_INT 6
27599: PUSH
27600: LD_VAR 0 6
27604: MINUS
27605: PUSH
27606: FOR_TO
27607: IFFALSE 27699
// begin if i = sort then
27609: LD_VAR 0 3
27613: PUSH
27614: LD_VAR 0 9
27618: EQUAL
27619: IFFALSE 27623
// break ;
27621: GO 27699
// if GetClass ( i ) = 2 then
27623: LD_VAR 0 3
27627: PPUSH
27628: CALL_OW 257
27632: PUSH
27633: LD_INT 2
27635: EQUAL
27636: IFFALSE 27640
// continue ;
27638: GO 27606
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27640: LD_ADDR_VAR 0 11
27644: PUSH
27645: LD_VAR 0 11
27649: PPUSH
27650: LD_VAR 0 11
27654: PUSH
27655: LD_INT 1
27657: PLUS
27658: PPUSH
27659: LD_VAR 0 9
27663: PUSH
27664: LD_VAR 0 3
27668: ARRAY
27669: PPUSH
27670: CALL_OW 2
27674: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27675: LD_ADDR_VAR 0 4
27679: PUSH
27680: LD_VAR 0 4
27684: PUSH
27685: LD_VAR 0 9
27689: PUSH
27690: LD_VAR 0 3
27694: ARRAY
27695: DIFF
27696: ST_TO_ADDR
// end ;
27697: GO 27606
27699: POP
27700: POP
// if p then
27701: LD_VAR 0 11
27705: IFFALSE 27730
// result := Replace ( result , 2 , p ) ;
27707: LD_ADDR_VAR 0 2
27711: PUSH
27712: LD_VAR 0 2
27716: PPUSH
27717: LD_INT 2
27719: PPUSH
27720: LD_VAR 0 11
27724: PPUSH
27725: CALL_OW 1
27729: ST_TO_ADDR
// end ; exit ;
27730: GO 29118
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27732: LD_EXP 120
27736: PUSH
27737: LD_EXP 119
27741: PUSH
27742: LD_VAR 0 1
27746: ARRAY
27747: ARRAY
27748: NOT
27749: PUSH
27750: LD_EXP 93
27754: PUSH
27755: LD_VAR 0 1
27759: ARRAY
27760: PPUSH
27761: LD_INT 30
27763: PUSH
27764: LD_INT 3
27766: PUSH
27767: EMPTY
27768: LIST
27769: LIST
27770: PPUSH
27771: CALL_OW 72
27775: AND
27776: PUSH
27777: LD_EXP 98
27781: PUSH
27782: LD_VAR 0 1
27786: ARRAY
27787: AND
27788: IFFALSE 28396
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27790: LD_ADDR_EXP 135
27794: PUSH
27795: LD_EXP 135
27799: PPUSH
27800: LD_VAR 0 1
27804: PPUSH
27805: LD_INT 5
27807: PPUSH
27808: CALL_OW 1
27812: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27813: LD_ADDR_VAR 0 2
27817: PUSH
27818: LD_INT 0
27820: PUSH
27821: LD_INT 0
27823: PUSH
27824: LD_INT 0
27826: PUSH
27827: LD_INT 0
27829: PUSH
27830: EMPTY
27831: LIST
27832: LIST
27833: LIST
27834: LIST
27835: ST_TO_ADDR
// if sci > 1 then
27836: LD_VAR 0 8
27840: PUSH
27841: LD_INT 1
27843: GREATER
27844: IFFALSE 27872
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27846: LD_ADDR_VAR 0 4
27850: PUSH
27851: LD_VAR 0 4
27855: PUSH
27856: LD_VAR 0 8
27860: PUSH
27861: LD_VAR 0 8
27865: PUSH
27866: LD_INT 1
27868: ARRAY
27869: DIFF
27870: DIFF
27871: ST_TO_ADDR
// if tmp and not sci then
27872: LD_VAR 0 4
27876: PUSH
27877: LD_VAR 0 8
27881: NOT
27882: AND
27883: IFFALSE 27952
// begin sort := SortBySkill ( tmp , 4 ) ;
27885: LD_ADDR_VAR 0 9
27889: PUSH
27890: LD_VAR 0 4
27894: PPUSH
27895: LD_INT 4
27897: PPUSH
27898: CALL 86362 0 2
27902: ST_TO_ADDR
// if sort then
27903: LD_VAR 0 9
27907: IFFALSE 27923
// p := sort [ 1 ] ;
27909: LD_ADDR_VAR 0 11
27913: PUSH
27914: LD_VAR 0 9
27918: PUSH
27919: LD_INT 1
27921: ARRAY
27922: ST_TO_ADDR
// if p then
27923: LD_VAR 0 11
27927: IFFALSE 27952
// result := Replace ( result , 4 , p ) ;
27929: LD_ADDR_VAR 0 2
27933: PUSH
27934: LD_VAR 0 2
27938: PPUSH
27939: LD_INT 4
27941: PPUSH
27942: LD_VAR 0 11
27946: PPUSH
27947: CALL_OW 1
27951: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27952: LD_ADDR_VAR 0 4
27956: PUSH
27957: LD_VAR 0 4
27961: PUSH
27962: LD_VAR 0 7
27966: DIFF
27967: ST_TO_ADDR
// if tmp and mech < 6 then
27968: LD_VAR 0 4
27972: PUSH
27973: LD_VAR 0 7
27977: PUSH
27978: LD_INT 6
27980: LESS
27981: AND
27982: IFFALSE 28170
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27984: LD_ADDR_VAR 0 9
27988: PUSH
27989: LD_VAR 0 4
27993: PUSH
27994: LD_VAR 0 8
27998: PUSH
27999: LD_VAR 0 7
28003: UNION
28004: DIFF
28005: PPUSH
28006: LD_INT 3
28008: PPUSH
28009: CALL 86362 0 2
28013: ST_TO_ADDR
// p := [ ] ;
28014: LD_ADDR_VAR 0 11
28018: PUSH
28019: EMPTY
28020: ST_TO_ADDR
// if sort then
28021: LD_VAR 0 9
28025: IFFALSE 28141
// for i = 1 to 6 - mech do
28027: LD_ADDR_VAR 0 3
28031: PUSH
28032: DOUBLE
28033: LD_INT 1
28035: DEC
28036: ST_TO_ADDR
28037: LD_INT 6
28039: PUSH
28040: LD_VAR 0 7
28044: MINUS
28045: PUSH
28046: FOR_TO
28047: IFFALSE 28139
// begin if i = sort then
28049: LD_VAR 0 3
28053: PUSH
28054: LD_VAR 0 9
28058: EQUAL
28059: IFFALSE 28063
// break ;
28061: GO 28139
// if GetClass ( i ) = 3 then
28063: LD_VAR 0 3
28067: PPUSH
28068: CALL_OW 257
28072: PUSH
28073: LD_INT 3
28075: EQUAL
28076: IFFALSE 28080
// continue ;
28078: GO 28046
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28080: LD_ADDR_VAR 0 11
28084: PUSH
28085: LD_VAR 0 11
28089: PPUSH
28090: LD_VAR 0 11
28094: PUSH
28095: LD_INT 1
28097: PLUS
28098: PPUSH
28099: LD_VAR 0 9
28103: PUSH
28104: LD_VAR 0 3
28108: ARRAY
28109: PPUSH
28110: CALL_OW 2
28114: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28115: LD_ADDR_VAR 0 4
28119: PUSH
28120: LD_VAR 0 4
28124: PUSH
28125: LD_VAR 0 9
28129: PUSH
28130: LD_VAR 0 3
28134: ARRAY
28135: DIFF
28136: ST_TO_ADDR
// end ;
28137: GO 28046
28139: POP
28140: POP
// if p then
28141: LD_VAR 0 11
28145: IFFALSE 28170
// result := Replace ( result , 3 , p ) ;
28147: LD_ADDR_VAR 0 2
28151: PUSH
28152: LD_VAR 0 2
28156: PPUSH
28157: LD_INT 3
28159: PPUSH
28160: LD_VAR 0 11
28164: PPUSH
28165: CALL_OW 1
28169: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28170: LD_ADDR_VAR 0 4
28174: PUSH
28175: LD_VAR 0 4
28179: PUSH
28180: LD_VAR 0 6
28184: DIFF
28185: ST_TO_ADDR
// if tmp and eng < 6 then
28186: LD_VAR 0 4
28190: PUSH
28191: LD_VAR 0 6
28195: PUSH
28196: LD_INT 6
28198: LESS
28199: AND
28200: IFFALSE 28394
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28202: LD_ADDR_VAR 0 9
28206: PUSH
28207: LD_VAR 0 4
28211: PUSH
28212: LD_VAR 0 8
28216: PUSH
28217: LD_VAR 0 7
28221: UNION
28222: PUSH
28223: LD_VAR 0 6
28227: UNION
28228: DIFF
28229: PPUSH
28230: LD_INT 2
28232: PPUSH
28233: CALL 86362 0 2
28237: ST_TO_ADDR
// p := [ ] ;
28238: LD_ADDR_VAR 0 11
28242: PUSH
28243: EMPTY
28244: ST_TO_ADDR
// if sort then
28245: LD_VAR 0 9
28249: IFFALSE 28365
// for i = 1 to 6 - eng do
28251: LD_ADDR_VAR 0 3
28255: PUSH
28256: DOUBLE
28257: LD_INT 1
28259: DEC
28260: ST_TO_ADDR
28261: LD_INT 6
28263: PUSH
28264: LD_VAR 0 6
28268: MINUS
28269: PUSH
28270: FOR_TO
28271: IFFALSE 28363
// begin if i = sort then
28273: LD_VAR 0 3
28277: PUSH
28278: LD_VAR 0 9
28282: EQUAL
28283: IFFALSE 28287
// break ;
28285: GO 28363
// if GetClass ( i ) = 2 then
28287: LD_VAR 0 3
28291: PPUSH
28292: CALL_OW 257
28296: PUSH
28297: LD_INT 2
28299: EQUAL
28300: IFFALSE 28304
// continue ;
28302: GO 28270
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28304: LD_ADDR_VAR 0 11
28308: PUSH
28309: LD_VAR 0 11
28313: PPUSH
28314: LD_VAR 0 11
28318: PUSH
28319: LD_INT 1
28321: PLUS
28322: PPUSH
28323: LD_VAR 0 9
28327: PUSH
28328: LD_VAR 0 3
28332: ARRAY
28333: PPUSH
28334: CALL_OW 2
28338: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28339: LD_ADDR_VAR 0 4
28343: PUSH
28344: LD_VAR 0 4
28348: PUSH
28349: LD_VAR 0 9
28353: PUSH
28354: LD_VAR 0 3
28358: ARRAY
28359: DIFF
28360: ST_TO_ADDR
// end ;
28361: GO 28270
28363: POP
28364: POP
// if p then
28365: LD_VAR 0 11
28369: IFFALSE 28394
// result := Replace ( result , 2 , p ) ;
28371: LD_ADDR_VAR 0 2
28375: PUSH
28376: LD_VAR 0 2
28380: PPUSH
28381: LD_INT 2
28383: PPUSH
28384: LD_VAR 0 11
28388: PPUSH
28389: CALL_OW 1
28393: ST_TO_ADDR
// end ; exit ;
28394: GO 29118
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28396: LD_EXP 120
28400: PUSH
28401: LD_EXP 119
28405: PUSH
28406: LD_VAR 0 1
28410: ARRAY
28411: ARRAY
28412: NOT
28413: PUSH
28414: LD_EXP 93
28418: PUSH
28419: LD_VAR 0 1
28423: ARRAY
28424: PPUSH
28425: LD_INT 30
28427: PUSH
28428: LD_INT 3
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PPUSH
28435: CALL_OW 72
28439: AND
28440: PUSH
28441: LD_EXP 98
28445: PUSH
28446: LD_VAR 0 1
28450: ARRAY
28451: NOT
28452: AND
28453: IFFALSE 29118
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28455: LD_ADDR_EXP 135
28459: PUSH
28460: LD_EXP 135
28464: PPUSH
28465: LD_VAR 0 1
28469: PPUSH
28470: LD_INT 6
28472: PPUSH
28473: CALL_OW 1
28477: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28478: LD_ADDR_VAR 0 2
28482: PUSH
28483: LD_INT 0
28485: PUSH
28486: LD_INT 0
28488: PUSH
28489: LD_INT 0
28491: PUSH
28492: LD_INT 0
28494: PUSH
28495: EMPTY
28496: LIST
28497: LIST
28498: LIST
28499: LIST
28500: ST_TO_ADDR
// if sci >= 1 then
28501: LD_VAR 0 8
28505: PUSH
28506: LD_INT 1
28508: GREATEREQUAL
28509: IFFALSE 28531
// tmp := tmp diff sci [ 1 ] ;
28511: LD_ADDR_VAR 0 4
28515: PUSH
28516: LD_VAR 0 4
28520: PUSH
28521: LD_VAR 0 8
28525: PUSH
28526: LD_INT 1
28528: ARRAY
28529: DIFF
28530: ST_TO_ADDR
// if tmp and not sci then
28531: LD_VAR 0 4
28535: PUSH
28536: LD_VAR 0 8
28540: NOT
28541: AND
28542: IFFALSE 28611
// begin sort := SortBySkill ( tmp , 4 ) ;
28544: LD_ADDR_VAR 0 9
28548: PUSH
28549: LD_VAR 0 4
28553: PPUSH
28554: LD_INT 4
28556: PPUSH
28557: CALL 86362 0 2
28561: ST_TO_ADDR
// if sort then
28562: LD_VAR 0 9
28566: IFFALSE 28582
// p := sort [ 1 ] ;
28568: LD_ADDR_VAR 0 11
28572: PUSH
28573: LD_VAR 0 9
28577: PUSH
28578: LD_INT 1
28580: ARRAY
28581: ST_TO_ADDR
// if p then
28582: LD_VAR 0 11
28586: IFFALSE 28611
// result := Replace ( result , 4 , p ) ;
28588: LD_ADDR_VAR 0 2
28592: PUSH
28593: LD_VAR 0 2
28597: PPUSH
28598: LD_INT 4
28600: PPUSH
28601: LD_VAR 0 11
28605: PPUSH
28606: CALL_OW 1
28610: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28611: LD_ADDR_VAR 0 4
28615: PUSH
28616: LD_VAR 0 4
28620: PUSH
28621: LD_VAR 0 7
28625: DIFF
28626: ST_TO_ADDR
// if tmp and mech < 6 then
28627: LD_VAR 0 4
28631: PUSH
28632: LD_VAR 0 7
28636: PUSH
28637: LD_INT 6
28639: LESS
28640: AND
28641: IFFALSE 28823
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28643: LD_ADDR_VAR 0 9
28647: PUSH
28648: LD_VAR 0 4
28652: PUSH
28653: LD_VAR 0 7
28657: DIFF
28658: PPUSH
28659: LD_INT 3
28661: PPUSH
28662: CALL 86362 0 2
28666: ST_TO_ADDR
// p := [ ] ;
28667: LD_ADDR_VAR 0 11
28671: PUSH
28672: EMPTY
28673: ST_TO_ADDR
// if sort then
28674: LD_VAR 0 9
28678: IFFALSE 28794
// for i = 1 to 6 - mech do
28680: LD_ADDR_VAR 0 3
28684: PUSH
28685: DOUBLE
28686: LD_INT 1
28688: DEC
28689: ST_TO_ADDR
28690: LD_INT 6
28692: PUSH
28693: LD_VAR 0 7
28697: MINUS
28698: PUSH
28699: FOR_TO
28700: IFFALSE 28792
// begin if i = sort then
28702: LD_VAR 0 3
28706: PUSH
28707: LD_VAR 0 9
28711: EQUAL
28712: IFFALSE 28716
// break ;
28714: GO 28792
// if GetClass ( i ) = 3 then
28716: LD_VAR 0 3
28720: PPUSH
28721: CALL_OW 257
28725: PUSH
28726: LD_INT 3
28728: EQUAL
28729: IFFALSE 28733
// continue ;
28731: GO 28699
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28733: LD_ADDR_VAR 0 11
28737: PUSH
28738: LD_VAR 0 11
28742: PPUSH
28743: LD_VAR 0 11
28747: PUSH
28748: LD_INT 1
28750: PLUS
28751: PPUSH
28752: LD_VAR 0 9
28756: PUSH
28757: LD_VAR 0 3
28761: ARRAY
28762: PPUSH
28763: CALL_OW 2
28767: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28768: LD_ADDR_VAR 0 4
28772: PUSH
28773: LD_VAR 0 4
28777: PUSH
28778: LD_VAR 0 9
28782: PUSH
28783: LD_VAR 0 3
28787: ARRAY
28788: DIFF
28789: ST_TO_ADDR
// end ;
28790: GO 28699
28792: POP
28793: POP
// if p then
28794: LD_VAR 0 11
28798: IFFALSE 28823
// result := Replace ( result , 3 , p ) ;
28800: LD_ADDR_VAR 0 2
28804: PUSH
28805: LD_VAR 0 2
28809: PPUSH
28810: LD_INT 3
28812: PPUSH
28813: LD_VAR 0 11
28817: PPUSH
28818: CALL_OW 1
28822: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28823: LD_ADDR_VAR 0 4
28827: PUSH
28828: LD_VAR 0 4
28832: PUSH
28833: LD_VAR 0 6
28837: DIFF
28838: ST_TO_ADDR
// if tmp and eng < 4 then
28839: LD_VAR 0 4
28843: PUSH
28844: LD_VAR 0 6
28848: PUSH
28849: LD_INT 4
28851: LESS
28852: AND
28853: IFFALSE 29043
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28855: LD_ADDR_VAR 0 9
28859: PUSH
28860: LD_VAR 0 4
28864: PUSH
28865: LD_VAR 0 7
28869: PUSH
28870: LD_VAR 0 6
28874: UNION
28875: DIFF
28876: PPUSH
28877: LD_INT 2
28879: PPUSH
28880: CALL 86362 0 2
28884: ST_TO_ADDR
// p := [ ] ;
28885: LD_ADDR_VAR 0 11
28889: PUSH
28890: EMPTY
28891: ST_TO_ADDR
// if sort then
28892: LD_VAR 0 9
28896: IFFALSE 29012
// for i = 1 to 4 - eng do
28898: LD_ADDR_VAR 0 3
28902: PUSH
28903: DOUBLE
28904: LD_INT 1
28906: DEC
28907: ST_TO_ADDR
28908: LD_INT 4
28910: PUSH
28911: LD_VAR 0 6
28915: MINUS
28916: PUSH
28917: FOR_TO
28918: IFFALSE 29010
// begin if i = sort then
28920: LD_VAR 0 3
28924: PUSH
28925: LD_VAR 0 9
28929: EQUAL
28930: IFFALSE 28934
// break ;
28932: GO 29010
// if GetClass ( i ) = 2 then
28934: LD_VAR 0 3
28938: PPUSH
28939: CALL_OW 257
28943: PUSH
28944: LD_INT 2
28946: EQUAL
28947: IFFALSE 28951
// continue ;
28949: GO 28917
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28951: LD_ADDR_VAR 0 11
28955: PUSH
28956: LD_VAR 0 11
28960: PPUSH
28961: LD_VAR 0 11
28965: PUSH
28966: LD_INT 1
28968: PLUS
28969: PPUSH
28970: LD_VAR 0 9
28974: PUSH
28975: LD_VAR 0 3
28979: ARRAY
28980: PPUSH
28981: CALL_OW 2
28985: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28986: LD_ADDR_VAR 0 4
28990: PUSH
28991: LD_VAR 0 4
28995: PUSH
28996: LD_VAR 0 9
29000: PUSH
29001: LD_VAR 0 3
29005: ARRAY
29006: DIFF
29007: ST_TO_ADDR
// end ;
29008: GO 28917
29010: POP
29011: POP
// if p then
29012: LD_VAR 0 11
29016: IFFALSE 29041
// result := Replace ( result , 2 , p ) ;
29018: LD_ADDR_VAR 0 2
29022: PUSH
29023: LD_VAR 0 2
29027: PPUSH
29028: LD_INT 2
29030: PPUSH
29031: LD_VAR 0 11
29035: PPUSH
29036: CALL_OW 1
29040: ST_TO_ADDR
// end else
29041: GO 29087
// for i = eng downto 5 do
29043: LD_ADDR_VAR 0 3
29047: PUSH
29048: DOUBLE
29049: LD_VAR 0 6
29053: INC
29054: ST_TO_ADDR
29055: LD_INT 5
29057: PUSH
29058: FOR_DOWNTO
29059: IFFALSE 29085
// tmp := tmp union eng [ i ] ;
29061: LD_ADDR_VAR 0 4
29065: PUSH
29066: LD_VAR 0 4
29070: PUSH
29071: LD_VAR 0 6
29075: PUSH
29076: LD_VAR 0 3
29080: ARRAY
29081: UNION
29082: ST_TO_ADDR
29083: GO 29058
29085: POP
29086: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29087: LD_ADDR_VAR 0 2
29091: PUSH
29092: LD_VAR 0 2
29096: PPUSH
29097: LD_INT 1
29099: PPUSH
29100: LD_VAR 0 4
29104: PUSH
29105: LD_VAR 0 5
29109: DIFF
29110: PPUSH
29111: CALL_OW 1
29115: ST_TO_ADDR
// exit ;
29116: GO 29118
// end ; end ;
29118: LD_VAR 0 2
29122: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29123: LD_INT 0
29125: PPUSH
29126: PPUSH
29127: PPUSH
// if not mc_bases then
29128: LD_EXP 93
29132: NOT
29133: IFFALSE 29137
// exit ;
29135: GO 29243
// for i = 1 to mc_bases do
29137: LD_ADDR_VAR 0 2
29141: PUSH
29142: DOUBLE
29143: LD_INT 1
29145: DEC
29146: ST_TO_ADDR
29147: LD_EXP 93
29151: PUSH
29152: FOR_TO
29153: IFFALSE 29234
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29155: LD_ADDR_VAR 0 3
29159: PUSH
29160: LD_EXP 93
29164: PUSH
29165: LD_VAR 0 2
29169: ARRAY
29170: PPUSH
29171: LD_INT 21
29173: PUSH
29174: LD_INT 3
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: LD_INT 3
29183: PUSH
29184: LD_INT 24
29186: PUSH
29187: LD_INT 1000
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PPUSH
29202: CALL_OW 72
29206: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29207: LD_ADDR_EXP 94
29211: PUSH
29212: LD_EXP 94
29216: PPUSH
29217: LD_VAR 0 2
29221: PPUSH
29222: LD_VAR 0 3
29226: PPUSH
29227: CALL_OW 1
29231: ST_TO_ADDR
// end ;
29232: GO 29152
29234: POP
29235: POP
// RaiseSailEvent ( 101 ) ;
29236: LD_INT 101
29238: PPUSH
29239: CALL_OW 427
// end ;
29243: LD_VAR 0 1
29247: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29248: LD_INT 0
29250: PPUSH
29251: PPUSH
29252: PPUSH
29253: PPUSH
29254: PPUSH
29255: PPUSH
29256: PPUSH
// if not mc_bases then
29257: LD_EXP 93
29261: NOT
29262: IFFALSE 29266
// exit ;
29264: GO 29828
// for i = 1 to mc_bases do
29266: LD_ADDR_VAR 0 2
29270: PUSH
29271: DOUBLE
29272: LD_INT 1
29274: DEC
29275: ST_TO_ADDR
29276: LD_EXP 93
29280: PUSH
29281: FOR_TO
29282: IFFALSE 29819
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29284: LD_ADDR_VAR 0 5
29288: PUSH
29289: LD_EXP 93
29293: PUSH
29294: LD_VAR 0 2
29298: ARRAY
29299: PUSH
29300: LD_EXP 122
29304: PUSH
29305: LD_VAR 0 2
29309: ARRAY
29310: UNION
29311: PPUSH
29312: LD_INT 21
29314: PUSH
29315: LD_INT 1
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 1
29324: PUSH
29325: LD_INT 3
29327: PUSH
29328: LD_INT 54
29330: PUSH
29331: EMPTY
29332: LIST
29333: PUSH
29334: EMPTY
29335: LIST
29336: LIST
29337: PUSH
29338: LD_INT 3
29340: PUSH
29341: LD_INT 24
29343: PUSH
29344: LD_INT 1000
29346: PUSH
29347: EMPTY
29348: LIST
29349: LIST
29350: PUSH
29351: EMPTY
29352: LIST
29353: LIST
29354: PUSH
29355: EMPTY
29356: LIST
29357: LIST
29358: LIST
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PPUSH
29364: CALL_OW 72
29368: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29369: LD_ADDR_VAR 0 6
29373: PUSH
29374: LD_EXP 93
29378: PUSH
29379: LD_VAR 0 2
29383: ARRAY
29384: PPUSH
29385: LD_INT 21
29387: PUSH
29388: LD_INT 1
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: LD_INT 1
29397: PUSH
29398: LD_INT 3
29400: PUSH
29401: LD_INT 54
29403: PUSH
29404: EMPTY
29405: LIST
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: PUSH
29411: LD_INT 3
29413: PUSH
29414: LD_INT 24
29416: PUSH
29417: LD_INT 250
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: LIST
29432: PUSH
29433: EMPTY
29434: LIST
29435: LIST
29436: PPUSH
29437: CALL_OW 72
29441: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29442: LD_ADDR_VAR 0 7
29446: PUSH
29447: LD_VAR 0 5
29451: PUSH
29452: LD_VAR 0 6
29456: DIFF
29457: ST_TO_ADDR
// if not need_heal_1 then
29458: LD_VAR 0 6
29462: NOT
29463: IFFALSE 29496
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29465: LD_ADDR_EXP 96
29469: PUSH
29470: LD_EXP 96
29474: PPUSH
29475: LD_VAR 0 2
29479: PUSH
29480: LD_INT 1
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PPUSH
29487: EMPTY
29488: PPUSH
29489: CALL 56104 0 3
29493: ST_TO_ADDR
29494: GO 29566
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29496: LD_ADDR_EXP 96
29500: PUSH
29501: LD_EXP 96
29505: PPUSH
29506: LD_VAR 0 2
29510: PUSH
29511: LD_INT 1
29513: PUSH
29514: EMPTY
29515: LIST
29516: LIST
29517: PPUSH
29518: LD_EXP 96
29522: PUSH
29523: LD_VAR 0 2
29527: ARRAY
29528: PUSH
29529: LD_INT 1
29531: ARRAY
29532: PPUSH
29533: LD_INT 3
29535: PUSH
29536: LD_INT 24
29538: PUSH
29539: LD_INT 1000
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PPUSH
29550: CALL_OW 72
29554: PUSH
29555: LD_VAR 0 6
29559: UNION
29560: PPUSH
29561: CALL 56104 0 3
29565: ST_TO_ADDR
// if not need_heal_2 then
29566: LD_VAR 0 7
29570: NOT
29571: IFFALSE 29604
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29573: LD_ADDR_EXP 96
29577: PUSH
29578: LD_EXP 96
29582: PPUSH
29583: LD_VAR 0 2
29587: PUSH
29588: LD_INT 2
29590: PUSH
29591: EMPTY
29592: LIST
29593: LIST
29594: PPUSH
29595: EMPTY
29596: PPUSH
29597: CALL 56104 0 3
29601: ST_TO_ADDR
29602: GO 29636
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29604: LD_ADDR_EXP 96
29608: PUSH
29609: LD_EXP 96
29613: PPUSH
29614: LD_VAR 0 2
29618: PUSH
29619: LD_INT 2
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PPUSH
29626: LD_VAR 0 7
29630: PPUSH
29631: CALL 56104 0 3
29635: ST_TO_ADDR
// if need_heal_2 then
29636: LD_VAR 0 7
29640: IFFALSE 29801
// for j in need_heal_2 do
29642: LD_ADDR_VAR 0 3
29646: PUSH
29647: LD_VAR 0 7
29651: PUSH
29652: FOR_IN
29653: IFFALSE 29799
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29655: LD_ADDR_VAR 0 5
29659: PUSH
29660: LD_EXP 93
29664: PUSH
29665: LD_VAR 0 2
29669: ARRAY
29670: PPUSH
29671: LD_INT 2
29673: PUSH
29674: LD_INT 30
29676: PUSH
29677: LD_INT 6
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 30
29686: PUSH
29687: LD_INT 7
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 30
29696: PUSH
29697: LD_INT 8
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: PUSH
29704: LD_INT 30
29706: PUSH
29707: LD_INT 0
29709: PUSH
29710: EMPTY
29711: LIST
29712: LIST
29713: PUSH
29714: LD_INT 30
29716: PUSH
29717: LD_INT 1
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: PPUSH
29732: CALL_OW 72
29736: ST_TO_ADDR
// if tmp then
29737: LD_VAR 0 5
29741: IFFALSE 29797
// begin k := NearestUnitToUnit ( tmp , j ) ;
29743: LD_ADDR_VAR 0 4
29747: PUSH
29748: LD_VAR 0 5
29752: PPUSH
29753: LD_VAR 0 3
29757: PPUSH
29758: CALL_OW 74
29762: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29763: LD_VAR 0 3
29767: PPUSH
29768: LD_VAR 0 4
29772: PPUSH
29773: CALL_OW 296
29777: PUSH
29778: LD_INT 5
29780: GREATER
29781: IFFALSE 29797
// ComMoveToNearbyEntrance ( j , k ) ;
29783: LD_VAR 0 3
29787: PPUSH
29788: LD_VAR 0 4
29792: PPUSH
29793: CALL 88723 0 2
// end ; end ;
29797: GO 29652
29799: POP
29800: POP
// if not need_heal_1 and not need_heal_2 then
29801: LD_VAR 0 6
29805: NOT
29806: PUSH
29807: LD_VAR 0 7
29811: NOT
29812: AND
29813: IFFALSE 29817
// continue ;
29815: GO 29281
// end ;
29817: GO 29281
29819: POP
29820: POP
// RaiseSailEvent ( 102 ) ;
29821: LD_INT 102
29823: PPUSH
29824: CALL_OW 427
// end ;
29828: LD_VAR 0 1
29832: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29833: LD_INT 0
29835: PPUSH
29836: PPUSH
29837: PPUSH
29838: PPUSH
29839: PPUSH
29840: PPUSH
29841: PPUSH
29842: PPUSH
// if not mc_bases then
29843: LD_EXP 93
29847: NOT
29848: IFFALSE 29852
// exit ;
29850: GO 30713
// for i = 1 to mc_bases do
29852: LD_ADDR_VAR 0 2
29856: PUSH
29857: DOUBLE
29858: LD_INT 1
29860: DEC
29861: ST_TO_ADDR
29862: LD_EXP 93
29866: PUSH
29867: FOR_TO
29868: IFFALSE 30711
// begin if not mc_building_need_repair [ i ] then
29870: LD_EXP 94
29874: PUSH
29875: LD_VAR 0 2
29879: ARRAY
29880: NOT
29881: IFFALSE 30068
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
29883: LD_ADDR_VAR 0 6
29887: PUSH
29888: LD_EXP 112
29892: PUSH
29893: LD_VAR 0 2
29897: ARRAY
29898: PPUSH
29899: LD_INT 3
29901: PUSH
29902: LD_INT 24
29904: PUSH
29905: LD_INT 1000
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 2
29918: PUSH
29919: LD_INT 34
29921: PUSH
29922: LD_INT 13
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 34
29931: PUSH
29932: LD_INT 52
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 34
29941: PUSH
29942: LD_EXP 78
29946: PUSH
29947: EMPTY
29948: LIST
29949: LIST
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: PPUSH
29961: CALL_OW 72
29965: ST_TO_ADDR
// if cranes then
29966: LD_VAR 0 6
29970: IFFALSE 30032
// for j in cranes do
29972: LD_ADDR_VAR 0 3
29976: PUSH
29977: LD_VAR 0 6
29981: PUSH
29982: FOR_IN
29983: IFFALSE 30030
// if not IsInArea ( j , mc_parking [ i ] ) then
29985: LD_VAR 0 3
29989: PPUSH
29990: LD_EXP 117
29994: PUSH
29995: LD_VAR 0 2
29999: ARRAY
30000: PPUSH
30001: CALL_OW 308
30005: NOT
30006: IFFALSE 30028
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30008: LD_VAR 0 3
30012: PPUSH
30013: LD_EXP 117
30017: PUSH
30018: LD_VAR 0 2
30022: ARRAY
30023: PPUSH
30024: CALL_OW 113
30028: GO 29982
30030: POP
30031: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30032: LD_ADDR_EXP 95
30036: PUSH
30037: LD_EXP 95
30041: PPUSH
30042: LD_VAR 0 2
30046: PPUSH
30047: EMPTY
30048: PPUSH
30049: CALL_OW 1
30053: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30054: LD_VAR 0 2
30058: PPUSH
30059: LD_INT 101
30061: PPUSH
30062: CALL 24956 0 2
// continue ;
30066: GO 29867
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30068: LD_ADDR_EXP 99
30072: PUSH
30073: LD_EXP 99
30077: PPUSH
30078: LD_VAR 0 2
30082: PPUSH
30083: EMPTY
30084: PPUSH
30085: CALL_OW 1
30089: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30090: LD_VAR 0 2
30094: PPUSH
30095: LD_INT 103
30097: PPUSH
30098: CALL 24956 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30102: LD_ADDR_VAR 0 5
30106: PUSH
30107: LD_EXP 93
30111: PUSH
30112: LD_VAR 0 2
30116: ARRAY
30117: PUSH
30118: LD_EXP 122
30122: PUSH
30123: LD_VAR 0 2
30127: ARRAY
30128: UNION
30129: PPUSH
30130: LD_INT 2
30132: PUSH
30133: LD_INT 25
30135: PUSH
30136: LD_INT 2
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PUSH
30143: LD_INT 25
30145: PUSH
30146: LD_INT 16
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: LIST
30157: PUSH
30158: EMPTY
30159: LIST
30160: PPUSH
30161: CALL_OW 72
30165: PUSH
30166: LD_EXP 96
30170: PUSH
30171: LD_VAR 0 2
30175: ARRAY
30176: PUSH
30177: LD_INT 1
30179: ARRAY
30180: PUSH
30181: LD_EXP 96
30185: PUSH
30186: LD_VAR 0 2
30190: ARRAY
30191: PUSH
30192: LD_INT 2
30194: ARRAY
30195: UNION
30196: DIFF
30197: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30198: LD_ADDR_VAR 0 6
30202: PUSH
30203: LD_EXP 112
30207: PUSH
30208: LD_VAR 0 2
30212: ARRAY
30213: PPUSH
30214: LD_INT 2
30216: PUSH
30217: LD_INT 34
30219: PUSH
30220: LD_INT 13
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 34
30229: PUSH
30230: LD_INT 52
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 34
30239: PUSH
30240: LD_EXP 78
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: EMPTY
30250: LIST
30251: LIST
30252: LIST
30253: LIST
30254: PPUSH
30255: CALL_OW 72
30259: ST_TO_ADDR
// if cranes then
30260: LD_VAR 0 6
30264: IFFALSE 30400
// begin for j in cranes do
30266: LD_ADDR_VAR 0 3
30270: PUSH
30271: LD_VAR 0 6
30275: PUSH
30276: FOR_IN
30277: IFFALSE 30398
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30279: LD_VAR 0 3
30283: PPUSH
30284: CALL_OW 256
30288: PUSH
30289: LD_INT 1000
30291: EQUAL
30292: PUSH
30293: LD_VAR 0 3
30297: PPUSH
30298: CALL_OW 314
30302: NOT
30303: AND
30304: IFFALSE 30338
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30306: LD_VAR 0 3
30310: PPUSH
30311: LD_EXP 94
30315: PUSH
30316: LD_VAR 0 2
30320: ARRAY
30321: PPUSH
30322: LD_VAR 0 3
30326: PPUSH
30327: CALL_OW 74
30331: PPUSH
30332: CALL_OW 130
30336: GO 30396
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30338: LD_VAR 0 3
30342: PPUSH
30343: CALL_OW 256
30347: PUSH
30348: LD_INT 500
30350: LESS
30351: PUSH
30352: LD_VAR 0 3
30356: PPUSH
30357: LD_EXP 117
30361: PUSH
30362: LD_VAR 0 2
30366: ARRAY
30367: PPUSH
30368: CALL_OW 308
30372: NOT
30373: AND
30374: IFFALSE 30396
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30376: LD_VAR 0 3
30380: PPUSH
30381: LD_EXP 117
30385: PUSH
30386: LD_VAR 0 2
30390: ARRAY
30391: PPUSH
30392: CALL_OW 113
// end ;
30396: GO 30276
30398: POP
30399: POP
// end ; if tmp > 3 then
30400: LD_VAR 0 5
30404: PUSH
30405: LD_INT 3
30407: GREATER
30408: IFFALSE 30428
// tmp := ShrinkArray ( tmp , 4 ) ;
30410: LD_ADDR_VAR 0 5
30414: PUSH
30415: LD_VAR 0 5
30419: PPUSH
30420: LD_INT 4
30422: PPUSH
30423: CALL 88171 0 2
30427: ST_TO_ADDR
// if not tmp then
30428: LD_VAR 0 5
30432: NOT
30433: IFFALSE 30437
// continue ;
30435: GO 29867
// for j in tmp do
30437: LD_ADDR_VAR 0 3
30441: PUSH
30442: LD_VAR 0 5
30446: PUSH
30447: FOR_IN
30448: IFFALSE 30707
// begin if IsInUnit ( j ) then
30450: LD_VAR 0 3
30454: PPUSH
30455: CALL_OW 310
30459: IFFALSE 30470
// ComExitBuilding ( j ) ;
30461: LD_VAR 0 3
30465: PPUSH
30466: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30470: LD_VAR 0 3
30474: PUSH
30475: LD_EXP 95
30479: PUSH
30480: LD_VAR 0 2
30484: ARRAY
30485: IN
30486: NOT
30487: IFFALSE 30545
// begin SetTag ( j , 101 ) ;
30489: LD_VAR 0 3
30493: PPUSH
30494: LD_INT 101
30496: PPUSH
30497: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30501: LD_ADDR_EXP 95
30505: PUSH
30506: LD_EXP 95
30510: PPUSH
30511: LD_VAR 0 2
30515: PUSH
30516: LD_EXP 95
30520: PUSH
30521: LD_VAR 0 2
30525: ARRAY
30526: PUSH
30527: LD_INT 1
30529: PLUS
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PPUSH
30535: LD_VAR 0 3
30539: PPUSH
30540: CALL 56104 0 3
30544: ST_TO_ADDR
// end ; wait ( 1 ) ;
30545: LD_INT 1
30547: PPUSH
30548: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30552: LD_ADDR_VAR 0 7
30556: PUSH
30557: LD_EXP 94
30561: PUSH
30562: LD_VAR 0 2
30566: ARRAY
30567: ST_TO_ADDR
// if mc_scan [ i ] then
30568: LD_EXP 116
30572: PUSH
30573: LD_VAR 0 2
30577: ARRAY
30578: IFFALSE 30640
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30580: LD_ADDR_VAR 0 7
30584: PUSH
30585: LD_EXP 94
30589: PUSH
30590: LD_VAR 0 2
30594: ARRAY
30595: PPUSH
30596: LD_INT 3
30598: PUSH
30599: LD_INT 30
30601: PUSH
30602: LD_INT 32
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: PUSH
30609: LD_INT 30
30611: PUSH
30612: LD_INT 33
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 30
30621: PUSH
30622: LD_INT 31
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: PPUSH
30635: CALL_OW 72
30639: ST_TO_ADDR
// if not to_repair_tmp then
30640: LD_VAR 0 7
30644: NOT
30645: IFFALSE 30649
// continue ;
30647: GO 30447
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30649: LD_ADDR_VAR 0 8
30653: PUSH
30654: LD_VAR 0 7
30658: PPUSH
30659: LD_VAR 0 3
30663: PPUSH
30664: CALL_OW 74
30668: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30669: LD_VAR 0 8
30673: PPUSH
30674: LD_INT 16
30676: PPUSH
30677: CALL 58703 0 2
30681: PUSH
30682: LD_INT 4
30684: ARRAY
30685: PUSH
30686: LD_INT 10
30688: LESS
30689: IFFALSE 30705
// ComRepairBuilding ( j , to_repair ) ;
30691: LD_VAR 0 3
30695: PPUSH
30696: LD_VAR 0 8
30700: PPUSH
30701: CALL_OW 130
// end ;
30705: GO 30447
30707: POP
30708: POP
// end ;
30709: GO 29867
30711: POP
30712: POP
// end ;
30713: LD_VAR 0 1
30717: RET
// export function MC_Heal ; var i , j , tmp ; begin
30718: LD_INT 0
30720: PPUSH
30721: PPUSH
30722: PPUSH
30723: PPUSH
// if not mc_bases then
30724: LD_EXP 93
30728: NOT
30729: IFFALSE 30733
// exit ;
30731: GO 31135
// for i = 1 to mc_bases do
30733: LD_ADDR_VAR 0 2
30737: PUSH
30738: DOUBLE
30739: LD_INT 1
30741: DEC
30742: ST_TO_ADDR
30743: LD_EXP 93
30747: PUSH
30748: FOR_TO
30749: IFFALSE 31133
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30751: LD_EXP 96
30755: PUSH
30756: LD_VAR 0 2
30760: ARRAY
30761: PUSH
30762: LD_INT 1
30764: ARRAY
30765: NOT
30766: PUSH
30767: LD_EXP 96
30771: PUSH
30772: LD_VAR 0 2
30776: ARRAY
30777: PUSH
30778: LD_INT 2
30780: ARRAY
30781: NOT
30782: AND
30783: IFFALSE 30821
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30785: LD_ADDR_EXP 97
30789: PUSH
30790: LD_EXP 97
30794: PPUSH
30795: LD_VAR 0 2
30799: PPUSH
30800: EMPTY
30801: PPUSH
30802: CALL_OW 1
30806: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30807: LD_VAR 0 2
30811: PPUSH
30812: LD_INT 102
30814: PPUSH
30815: CALL 24956 0 2
// continue ;
30819: GO 30748
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30821: LD_ADDR_VAR 0 4
30825: PUSH
30826: LD_EXP 93
30830: PUSH
30831: LD_VAR 0 2
30835: ARRAY
30836: PPUSH
30837: LD_INT 25
30839: PUSH
30840: LD_INT 4
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PPUSH
30847: CALL_OW 72
30851: ST_TO_ADDR
// if not tmp then
30852: LD_VAR 0 4
30856: NOT
30857: IFFALSE 30861
// continue ;
30859: GO 30748
// if mc_taming [ i ] then
30861: LD_EXP 124
30865: PUSH
30866: LD_VAR 0 2
30870: ARRAY
30871: IFFALSE 30895
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30873: LD_ADDR_EXP 124
30877: PUSH
30878: LD_EXP 124
30882: PPUSH
30883: LD_VAR 0 2
30887: PPUSH
30888: EMPTY
30889: PPUSH
30890: CALL_OW 1
30894: ST_TO_ADDR
// for j in tmp do
30895: LD_ADDR_VAR 0 3
30899: PUSH
30900: LD_VAR 0 4
30904: PUSH
30905: FOR_IN
30906: IFFALSE 31129
// begin if IsInUnit ( j ) then
30908: LD_VAR 0 3
30912: PPUSH
30913: CALL_OW 310
30917: IFFALSE 30928
// ComExitBuilding ( j ) ;
30919: LD_VAR 0 3
30923: PPUSH
30924: CALL_OW 122
// if not j in mc_healers [ i ] then
30928: LD_VAR 0 3
30932: PUSH
30933: LD_EXP 97
30937: PUSH
30938: LD_VAR 0 2
30942: ARRAY
30943: IN
30944: NOT
30945: IFFALSE 30991
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30947: LD_ADDR_EXP 97
30951: PUSH
30952: LD_EXP 97
30956: PPUSH
30957: LD_VAR 0 2
30961: PUSH
30962: LD_EXP 97
30966: PUSH
30967: LD_VAR 0 2
30971: ARRAY
30972: PUSH
30973: LD_INT 1
30975: PLUS
30976: PUSH
30977: EMPTY
30978: LIST
30979: LIST
30980: PPUSH
30981: LD_VAR 0 3
30985: PPUSH
30986: CALL 56104 0 3
30990: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30991: LD_VAR 0 3
30995: PPUSH
30996: CALL_OW 110
31000: PUSH
31001: LD_INT 102
31003: NONEQUAL
31004: IFFALSE 31018
// SetTag ( j , 102 ) ;
31006: LD_VAR 0 3
31010: PPUSH
31011: LD_INT 102
31013: PPUSH
31014: CALL_OW 109
// Wait ( 3 ) ;
31018: LD_INT 3
31020: PPUSH
31021: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31025: LD_EXP 96
31029: PUSH
31030: LD_VAR 0 2
31034: ARRAY
31035: PUSH
31036: LD_INT 1
31038: ARRAY
31039: IFFALSE 31071
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31041: LD_VAR 0 3
31045: PPUSH
31046: LD_EXP 96
31050: PUSH
31051: LD_VAR 0 2
31055: ARRAY
31056: PUSH
31057: LD_INT 1
31059: ARRAY
31060: PUSH
31061: LD_INT 1
31063: ARRAY
31064: PPUSH
31065: CALL_OW 128
31069: GO 31127
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31071: LD_VAR 0 3
31075: PPUSH
31076: CALL_OW 314
31080: NOT
31081: PUSH
31082: LD_EXP 96
31086: PUSH
31087: LD_VAR 0 2
31091: ARRAY
31092: PUSH
31093: LD_INT 2
31095: ARRAY
31096: AND
31097: IFFALSE 31127
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31099: LD_VAR 0 3
31103: PPUSH
31104: LD_EXP 96
31108: PUSH
31109: LD_VAR 0 2
31113: ARRAY
31114: PUSH
31115: LD_INT 2
31117: ARRAY
31118: PUSH
31119: LD_INT 1
31121: ARRAY
31122: PPUSH
31123: CALL_OW 128
// end ;
31127: GO 30905
31129: POP
31130: POP
// end ;
31131: GO 30748
31133: POP
31134: POP
// end ;
31135: LD_VAR 0 1
31139: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31140: LD_INT 0
31142: PPUSH
31143: PPUSH
31144: PPUSH
31145: PPUSH
31146: PPUSH
// if not mc_bases then
31147: LD_EXP 93
31151: NOT
31152: IFFALSE 31156
// exit ;
31154: GO 32327
// for i = 1 to mc_bases do
31156: LD_ADDR_VAR 0 2
31160: PUSH
31161: DOUBLE
31162: LD_INT 1
31164: DEC
31165: ST_TO_ADDR
31166: LD_EXP 93
31170: PUSH
31171: FOR_TO
31172: IFFALSE 32325
// begin if mc_scan [ i ] then
31174: LD_EXP 116
31178: PUSH
31179: LD_VAR 0 2
31183: ARRAY
31184: IFFALSE 31188
// continue ;
31186: GO 31171
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31188: LD_EXP 98
31192: PUSH
31193: LD_VAR 0 2
31197: ARRAY
31198: NOT
31199: PUSH
31200: LD_EXP 100
31204: PUSH
31205: LD_VAR 0 2
31209: ARRAY
31210: NOT
31211: AND
31212: PUSH
31213: LD_EXP 99
31217: PUSH
31218: LD_VAR 0 2
31222: ARRAY
31223: AND
31224: IFFALSE 31262
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31226: LD_ADDR_EXP 99
31230: PUSH
31231: LD_EXP 99
31235: PPUSH
31236: LD_VAR 0 2
31240: PPUSH
31241: EMPTY
31242: PPUSH
31243: CALL_OW 1
31247: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31248: LD_VAR 0 2
31252: PPUSH
31253: LD_INT 103
31255: PPUSH
31256: CALL 24956 0 2
// continue ;
31260: GO 31171
// end ; if mc_construct_list [ i ] then
31262: LD_EXP 100
31266: PUSH
31267: LD_VAR 0 2
31271: ARRAY
31272: IFFALSE 31492
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31274: LD_ADDR_VAR 0 4
31278: PUSH
31279: LD_EXP 93
31283: PUSH
31284: LD_VAR 0 2
31288: ARRAY
31289: PPUSH
31290: LD_INT 25
31292: PUSH
31293: LD_INT 2
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PPUSH
31300: CALL_OW 72
31304: PUSH
31305: LD_EXP 95
31309: PUSH
31310: LD_VAR 0 2
31314: ARRAY
31315: DIFF
31316: ST_TO_ADDR
// if not tmp then
31317: LD_VAR 0 4
31321: NOT
31322: IFFALSE 31326
// continue ;
31324: GO 31171
// for j in tmp do
31326: LD_ADDR_VAR 0 3
31330: PUSH
31331: LD_VAR 0 4
31335: PUSH
31336: FOR_IN
31337: IFFALSE 31488
// begin if not mc_builders [ i ] then
31339: LD_EXP 99
31343: PUSH
31344: LD_VAR 0 2
31348: ARRAY
31349: NOT
31350: IFFALSE 31408
// begin SetTag ( j , 103 ) ;
31352: LD_VAR 0 3
31356: PPUSH
31357: LD_INT 103
31359: PPUSH
31360: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31364: LD_ADDR_EXP 99
31368: PUSH
31369: LD_EXP 99
31373: PPUSH
31374: LD_VAR 0 2
31378: PUSH
31379: LD_EXP 99
31383: PUSH
31384: LD_VAR 0 2
31388: ARRAY
31389: PUSH
31390: LD_INT 1
31392: PLUS
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PPUSH
31398: LD_VAR 0 3
31402: PPUSH
31403: CALL 56104 0 3
31407: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31408: LD_VAR 0 3
31412: PPUSH
31413: CALL_OW 310
31417: IFFALSE 31428
// ComExitBuilding ( j ) ;
31419: LD_VAR 0 3
31423: PPUSH
31424: CALL_OW 122
// wait ( 3 ) ;
31428: LD_INT 3
31430: PPUSH
31431: CALL_OW 67
// if not mc_construct_list [ i ] then
31435: LD_EXP 100
31439: PUSH
31440: LD_VAR 0 2
31444: ARRAY
31445: NOT
31446: IFFALSE 31450
// break ;
31448: GO 31488
// if not HasTask ( j ) then
31450: LD_VAR 0 3
31454: PPUSH
31455: CALL_OW 314
31459: NOT
31460: IFFALSE 31486
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31462: LD_VAR 0 3
31466: PPUSH
31467: LD_EXP 100
31471: PUSH
31472: LD_VAR 0 2
31476: ARRAY
31477: PUSH
31478: LD_INT 1
31480: ARRAY
31481: PPUSH
31482: CALL 58967 0 2
// end ;
31486: GO 31336
31488: POP
31489: POP
// end else
31490: GO 32323
// if mc_build_list [ i ] then
31492: LD_EXP 98
31496: PUSH
31497: LD_VAR 0 2
31501: ARRAY
31502: IFFALSE 32323
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31504: LD_ADDR_VAR 0 5
31508: PUSH
31509: LD_EXP 93
31513: PUSH
31514: LD_VAR 0 2
31518: ARRAY
31519: PPUSH
31520: LD_INT 2
31522: PUSH
31523: LD_INT 30
31525: PUSH
31526: LD_INT 0
31528: PUSH
31529: EMPTY
31530: LIST
31531: LIST
31532: PUSH
31533: LD_INT 30
31535: PUSH
31536: LD_INT 1
31538: PUSH
31539: EMPTY
31540: LIST
31541: LIST
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: LIST
31547: PPUSH
31548: CALL_OW 72
31552: ST_TO_ADDR
// if depot then
31553: LD_VAR 0 5
31557: IFFALSE 31575
// depot := depot [ 1 ] else
31559: LD_ADDR_VAR 0 5
31563: PUSH
31564: LD_VAR 0 5
31568: PUSH
31569: LD_INT 1
31571: ARRAY
31572: ST_TO_ADDR
31573: GO 31583
// depot := 0 ;
31575: LD_ADDR_VAR 0 5
31579: PUSH
31580: LD_INT 0
31582: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31583: LD_EXP 98
31587: PUSH
31588: LD_VAR 0 2
31592: ARRAY
31593: PUSH
31594: LD_INT 1
31596: ARRAY
31597: PUSH
31598: LD_INT 1
31600: ARRAY
31601: PPUSH
31602: CALL 58791 0 1
31606: PUSH
31607: LD_EXP 93
31611: PUSH
31612: LD_VAR 0 2
31616: ARRAY
31617: PPUSH
31618: LD_INT 2
31620: PUSH
31621: LD_INT 30
31623: PUSH
31624: LD_INT 2
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 30
31633: PUSH
31634: LD_INT 3
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PUSH
31641: EMPTY
31642: LIST
31643: LIST
31644: LIST
31645: PPUSH
31646: CALL_OW 72
31650: NOT
31651: AND
31652: IFFALSE 31757
// begin for j = 1 to mc_build_list [ i ] do
31654: LD_ADDR_VAR 0 3
31658: PUSH
31659: DOUBLE
31660: LD_INT 1
31662: DEC
31663: ST_TO_ADDR
31664: LD_EXP 98
31668: PUSH
31669: LD_VAR 0 2
31673: ARRAY
31674: PUSH
31675: FOR_TO
31676: IFFALSE 31755
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31678: LD_EXP 98
31682: PUSH
31683: LD_VAR 0 2
31687: ARRAY
31688: PUSH
31689: LD_VAR 0 3
31693: ARRAY
31694: PUSH
31695: LD_INT 1
31697: ARRAY
31698: PUSH
31699: LD_INT 2
31701: EQUAL
31702: IFFALSE 31753
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31704: LD_ADDR_EXP 98
31708: PUSH
31709: LD_EXP 98
31713: PPUSH
31714: LD_VAR 0 2
31718: PPUSH
31719: LD_EXP 98
31723: PUSH
31724: LD_VAR 0 2
31728: ARRAY
31729: PPUSH
31730: LD_VAR 0 3
31734: PPUSH
31735: LD_INT 1
31737: PPUSH
31738: LD_INT 0
31740: PPUSH
31741: CALL 55522 0 4
31745: PPUSH
31746: CALL_OW 1
31750: ST_TO_ADDR
// break ;
31751: GO 31755
// end ;
31753: GO 31675
31755: POP
31756: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31757: LD_EXP 98
31761: PUSH
31762: LD_VAR 0 2
31766: ARRAY
31767: PUSH
31768: LD_INT 1
31770: ARRAY
31771: PUSH
31772: LD_INT 1
31774: ARRAY
31775: PUSH
31776: LD_INT 0
31778: EQUAL
31779: PUSH
31780: LD_VAR 0 5
31784: PUSH
31785: LD_VAR 0 5
31789: PPUSH
31790: LD_EXP 98
31794: PUSH
31795: LD_VAR 0 2
31799: ARRAY
31800: PUSH
31801: LD_INT 1
31803: ARRAY
31804: PUSH
31805: LD_INT 1
31807: ARRAY
31808: PPUSH
31809: LD_EXP 98
31813: PUSH
31814: LD_VAR 0 2
31818: ARRAY
31819: PUSH
31820: LD_INT 1
31822: ARRAY
31823: PUSH
31824: LD_INT 2
31826: ARRAY
31827: PPUSH
31828: LD_EXP 98
31832: PUSH
31833: LD_VAR 0 2
31837: ARRAY
31838: PUSH
31839: LD_INT 1
31841: ARRAY
31842: PUSH
31843: LD_INT 3
31845: ARRAY
31846: PPUSH
31847: LD_EXP 98
31851: PUSH
31852: LD_VAR 0 2
31856: ARRAY
31857: PUSH
31858: LD_INT 1
31860: ARRAY
31861: PUSH
31862: LD_INT 4
31864: ARRAY
31865: PPUSH
31866: CALL 64208 0 5
31870: AND
31871: OR
31872: IFFALSE 32153
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31874: LD_ADDR_VAR 0 4
31878: PUSH
31879: LD_EXP 93
31883: PUSH
31884: LD_VAR 0 2
31888: ARRAY
31889: PPUSH
31890: LD_INT 25
31892: PUSH
31893: LD_INT 2
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PPUSH
31900: CALL_OW 72
31904: PUSH
31905: LD_EXP 95
31909: PUSH
31910: LD_VAR 0 2
31914: ARRAY
31915: DIFF
31916: ST_TO_ADDR
// if not tmp then
31917: LD_VAR 0 4
31921: NOT
31922: IFFALSE 31926
// continue ;
31924: GO 31171
// for j in tmp do
31926: LD_ADDR_VAR 0 3
31930: PUSH
31931: LD_VAR 0 4
31935: PUSH
31936: FOR_IN
31937: IFFALSE 32149
// begin if not mc_builders [ i ] then
31939: LD_EXP 99
31943: PUSH
31944: LD_VAR 0 2
31948: ARRAY
31949: NOT
31950: IFFALSE 32008
// begin SetTag ( j , 103 ) ;
31952: LD_VAR 0 3
31956: PPUSH
31957: LD_INT 103
31959: PPUSH
31960: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31964: LD_ADDR_EXP 99
31968: PUSH
31969: LD_EXP 99
31973: PPUSH
31974: LD_VAR 0 2
31978: PUSH
31979: LD_EXP 99
31983: PUSH
31984: LD_VAR 0 2
31988: ARRAY
31989: PUSH
31990: LD_INT 1
31992: PLUS
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PPUSH
31998: LD_VAR 0 3
32002: PPUSH
32003: CALL 56104 0 3
32007: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32008: LD_VAR 0 3
32012: PPUSH
32013: CALL_OW 310
32017: IFFALSE 32028
// ComExitBuilding ( j ) ;
32019: LD_VAR 0 3
32023: PPUSH
32024: CALL_OW 122
// wait ( 3 ) ;
32028: LD_INT 3
32030: PPUSH
32031: CALL_OW 67
// if not mc_build_list [ i ] then
32035: LD_EXP 98
32039: PUSH
32040: LD_VAR 0 2
32044: ARRAY
32045: NOT
32046: IFFALSE 32050
// break ;
32048: GO 32149
// if not HasTask ( j ) then
32050: LD_VAR 0 3
32054: PPUSH
32055: CALL_OW 314
32059: NOT
32060: IFFALSE 32147
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32062: LD_VAR 0 3
32066: PPUSH
32067: LD_EXP 98
32071: PUSH
32072: LD_VAR 0 2
32076: ARRAY
32077: PUSH
32078: LD_INT 1
32080: ARRAY
32081: PUSH
32082: LD_INT 1
32084: ARRAY
32085: PPUSH
32086: LD_EXP 98
32090: PUSH
32091: LD_VAR 0 2
32095: ARRAY
32096: PUSH
32097: LD_INT 1
32099: ARRAY
32100: PUSH
32101: LD_INT 2
32103: ARRAY
32104: PPUSH
32105: LD_EXP 98
32109: PUSH
32110: LD_VAR 0 2
32114: ARRAY
32115: PUSH
32116: LD_INT 1
32118: ARRAY
32119: PUSH
32120: LD_INT 3
32122: ARRAY
32123: PPUSH
32124: LD_EXP 98
32128: PUSH
32129: LD_VAR 0 2
32133: ARRAY
32134: PUSH
32135: LD_INT 1
32137: ARRAY
32138: PUSH
32139: LD_INT 4
32141: ARRAY
32142: PPUSH
32143: CALL_OW 145
// end ;
32147: GO 31936
32149: POP
32150: POP
// end else
32151: GO 32323
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32153: LD_EXP 93
32157: PUSH
32158: LD_VAR 0 2
32162: ARRAY
32163: PPUSH
32164: LD_EXP 98
32168: PUSH
32169: LD_VAR 0 2
32173: ARRAY
32174: PUSH
32175: LD_INT 1
32177: ARRAY
32178: PUSH
32179: LD_INT 1
32181: ARRAY
32182: PPUSH
32183: LD_EXP 98
32187: PUSH
32188: LD_VAR 0 2
32192: ARRAY
32193: PUSH
32194: LD_INT 1
32196: ARRAY
32197: PUSH
32198: LD_INT 2
32200: ARRAY
32201: PPUSH
32202: LD_EXP 98
32206: PUSH
32207: LD_VAR 0 2
32211: ARRAY
32212: PUSH
32213: LD_INT 1
32215: ARRAY
32216: PUSH
32217: LD_INT 3
32219: ARRAY
32220: PPUSH
32221: LD_EXP 98
32225: PUSH
32226: LD_VAR 0 2
32230: ARRAY
32231: PUSH
32232: LD_INT 1
32234: ARRAY
32235: PUSH
32236: LD_INT 4
32238: ARRAY
32239: PPUSH
32240: LD_EXP 93
32244: PUSH
32245: LD_VAR 0 2
32249: ARRAY
32250: PPUSH
32251: LD_INT 21
32253: PUSH
32254: LD_INT 3
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: PPUSH
32261: CALL_OW 72
32265: PPUSH
32266: EMPTY
32267: PPUSH
32268: CALL 62958 0 7
32272: NOT
32273: IFFALSE 32323
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32275: LD_ADDR_EXP 98
32279: PUSH
32280: LD_EXP 98
32284: PPUSH
32285: LD_VAR 0 2
32289: PPUSH
32290: LD_EXP 98
32294: PUSH
32295: LD_VAR 0 2
32299: ARRAY
32300: PPUSH
32301: LD_INT 1
32303: PPUSH
32304: LD_INT 1
32306: NEG
32307: PPUSH
32308: LD_INT 0
32310: PPUSH
32311: CALL 55522 0 4
32315: PPUSH
32316: CALL_OW 1
32320: ST_TO_ADDR
// continue ;
32321: GO 31171
// end ; end ; end ;
32323: GO 31171
32325: POP
32326: POP
// end ;
32327: LD_VAR 0 1
32331: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32332: LD_INT 0
32334: PPUSH
32335: PPUSH
32336: PPUSH
32337: PPUSH
32338: PPUSH
32339: PPUSH
// if not mc_bases then
32340: LD_EXP 93
32344: NOT
32345: IFFALSE 32349
// exit ;
32347: GO 32776
// for i = 1 to mc_bases do
32349: LD_ADDR_VAR 0 2
32353: PUSH
32354: DOUBLE
32355: LD_INT 1
32357: DEC
32358: ST_TO_ADDR
32359: LD_EXP 93
32363: PUSH
32364: FOR_TO
32365: IFFALSE 32774
// begin tmp := mc_build_upgrade [ i ] ;
32367: LD_ADDR_VAR 0 4
32371: PUSH
32372: LD_EXP 125
32376: PUSH
32377: LD_VAR 0 2
32381: ARRAY
32382: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32383: LD_ADDR_VAR 0 6
32387: PUSH
32388: LD_EXP 126
32392: PUSH
32393: LD_VAR 0 2
32397: ARRAY
32398: PPUSH
32399: LD_INT 2
32401: PUSH
32402: LD_INT 30
32404: PUSH
32405: LD_INT 6
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: LD_INT 30
32414: PUSH
32415: LD_INT 7
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: LIST
32426: PPUSH
32427: CALL_OW 72
32431: ST_TO_ADDR
// if not tmp and not lab then
32432: LD_VAR 0 4
32436: NOT
32437: PUSH
32438: LD_VAR 0 6
32442: NOT
32443: AND
32444: IFFALSE 32448
// continue ;
32446: GO 32364
// if tmp then
32448: LD_VAR 0 4
32452: IFFALSE 32572
// for j in tmp do
32454: LD_ADDR_VAR 0 3
32458: PUSH
32459: LD_VAR 0 4
32463: PUSH
32464: FOR_IN
32465: IFFALSE 32570
// begin if UpgradeCost ( j ) then
32467: LD_VAR 0 3
32471: PPUSH
32472: CALL 62618 0 1
32476: IFFALSE 32568
// begin ComUpgrade ( j ) ;
32478: LD_VAR 0 3
32482: PPUSH
32483: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32487: LD_ADDR_EXP 125
32491: PUSH
32492: LD_EXP 125
32496: PPUSH
32497: LD_VAR 0 2
32501: PPUSH
32502: LD_EXP 125
32506: PUSH
32507: LD_VAR 0 2
32511: ARRAY
32512: PUSH
32513: LD_VAR 0 3
32517: DIFF
32518: PPUSH
32519: CALL_OW 1
32523: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32524: LD_ADDR_EXP 100
32528: PUSH
32529: LD_EXP 100
32533: PPUSH
32534: LD_VAR 0 2
32538: PUSH
32539: LD_EXP 100
32543: PUSH
32544: LD_VAR 0 2
32548: ARRAY
32549: PUSH
32550: LD_INT 1
32552: PLUS
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: PPUSH
32558: LD_VAR 0 3
32562: PPUSH
32563: CALL 56104 0 3
32567: ST_TO_ADDR
// end ; end ;
32568: GO 32464
32570: POP
32571: POP
// if not lab or not mc_lab_upgrade [ i ] then
32572: LD_VAR 0 6
32576: NOT
32577: PUSH
32578: LD_EXP 127
32582: PUSH
32583: LD_VAR 0 2
32587: ARRAY
32588: NOT
32589: OR
32590: IFFALSE 32594
// continue ;
32592: GO 32364
// for j in lab do
32594: LD_ADDR_VAR 0 3
32598: PUSH
32599: LD_VAR 0 6
32603: PUSH
32604: FOR_IN
32605: IFFALSE 32770
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32607: LD_VAR 0 3
32611: PPUSH
32612: CALL_OW 266
32616: PUSH
32617: LD_INT 6
32619: PUSH
32620: LD_INT 7
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: IN
32627: PUSH
32628: LD_VAR 0 3
32632: PPUSH
32633: CALL_OW 461
32637: PUSH
32638: LD_INT 1
32640: NONEQUAL
32641: AND
32642: IFFALSE 32768
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32644: LD_VAR 0 3
32648: PPUSH
32649: LD_EXP 127
32653: PUSH
32654: LD_VAR 0 2
32658: ARRAY
32659: PUSH
32660: LD_INT 1
32662: ARRAY
32663: PPUSH
32664: CALL 62823 0 2
32668: IFFALSE 32768
// begin ComCancel ( j ) ;
32670: LD_VAR 0 3
32674: PPUSH
32675: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32679: LD_VAR 0 3
32683: PPUSH
32684: LD_EXP 127
32688: PUSH
32689: LD_VAR 0 2
32693: ARRAY
32694: PUSH
32695: LD_INT 1
32697: ARRAY
32698: PPUSH
32699: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32703: LD_VAR 0 3
32707: PUSH
32708: LD_EXP 100
32712: PUSH
32713: LD_VAR 0 2
32717: ARRAY
32718: IN
32719: NOT
32720: IFFALSE 32766
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32722: LD_ADDR_EXP 100
32726: PUSH
32727: LD_EXP 100
32731: PPUSH
32732: LD_VAR 0 2
32736: PUSH
32737: LD_EXP 100
32741: PUSH
32742: LD_VAR 0 2
32746: ARRAY
32747: PUSH
32748: LD_INT 1
32750: PLUS
32751: PUSH
32752: EMPTY
32753: LIST
32754: LIST
32755: PPUSH
32756: LD_VAR 0 3
32760: PPUSH
32761: CALL 56104 0 3
32765: ST_TO_ADDR
// break ;
32766: GO 32770
// end ; end ; end ;
32768: GO 32604
32770: POP
32771: POP
// end ;
32772: GO 32364
32774: POP
32775: POP
// end ;
32776: LD_VAR 0 1
32780: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32781: LD_INT 0
32783: PPUSH
32784: PPUSH
32785: PPUSH
32786: PPUSH
32787: PPUSH
32788: PPUSH
32789: PPUSH
32790: PPUSH
32791: PPUSH
// if not mc_bases then
32792: LD_EXP 93
32796: NOT
32797: IFFALSE 32801
// exit ;
32799: GO 33206
// for i = 1 to mc_bases do
32801: LD_ADDR_VAR 0 2
32805: PUSH
32806: DOUBLE
32807: LD_INT 1
32809: DEC
32810: ST_TO_ADDR
32811: LD_EXP 93
32815: PUSH
32816: FOR_TO
32817: IFFALSE 33204
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32819: LD_EXP 101
32823: PUSH
32824: LD_VAR 0 2
32828: ARRAY
32829: NOT
32830: PUSH
32831: LD_EXP 93
32835: PUSH
32836: LD_VAR 0 2
32840: ARRAY
32841: PPUSH
32842: LD_INT 30
32844: PUSH
32845: LD_INT 3
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PPUSH
32852: CALL_OW 72
32856: NOT
32857: OR
32858: IFFALSE 32862
// continue ;
32860: GO 32816
// busy := false ;
32862: LD_ADDR_VAR 0 8
32866: PUSH
32867: LD_INT 0
32869: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32870: LD_ADDR_VAR 0 4
32874: PUSH
32875: LD_EXP 93
32879: PUSH
32880: LD_VAR 0 2
32884: ARRAY
32885: PPUSH
32886: LD_INT 30
32888: PUSH
32889: LD_INT 3
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PPUSH
32896: CALL_OW 72
32900: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32901: LD_ADDR_VAR 0 6
32905: PUSH
32906: LD_EXP 101
32910: PUSH
32911: LD_VAR 0 2
32915: ARRAY
32916: PPUSH
32917: LD_INT 2
32919: PUSH
32920: LD_INT 30
32922: PUSH
32923: LD_INT 32
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 30
32932: PUSH
32933: LD_INT 33
32935: PUSH
32936: EMPTY
32937: LIST
32938: LIST
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: LIST
32944: PPUSH
32945: CALL_OW 72
32949: ST_TO_ADDR
// if not t then
32950: LD_VAR 0 6
32954: NOT
32955: IFFALSE 32959
// continue ;
32957: GO 32816
// for j in tmp do
32959: LD_ADDR_VAR 0 3
32963: PUSH
32964: LD_VAR 0 4
32968: PUSH
32969: FOR_IN
32970: IFFALSE 33000
// if not BuildingStatus ( j ) = bs_idle then
32972: LD_VAR 0 3
32976: PPUSH
32977: CALL_OW 461
32981: PUSH
32982: LD_INT 2
32984: EQUAL
32985: NOT
32986: IFFALSE 32998
// begin busy := true ;
32988: LD_ADDR_VAR 0 8
32992: PUSH
32993: LD_INT 1
32995: ST_TO_ADDR
// break ;
32996: GO 33000
// end ;
32998: GO 32969
33000: POP
33001: POP
// if busy then
33002: LD_VAR 0 8
33006: IFFALSE 33010
// continue ;
33008: GO 32816
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33010: LD_ADDR_VAR 0 7
33014: PUSH
33015: LD_VAR 0 6
33019: PPUSH
33020: LD_INT 35
33022: PUSH
33023: LD_INT 0
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PPUSH
33030: CALL_OW 72
33034: ST_TO_ADDR
// if tw then
33035: LD_VAR 0 7
33039: IFFALSE 33116
// begin tw := tw [ 1 ] ;
33041: LD_ADDR_VAR 0 7
33045: PUSH
33046: LD_VAR 0 7
33050: PUSH
33051: LD_INT 1
33053: ARRAY
33054: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33055: LD_ADDR_VAR 0 9
33059: PUSH
33060: LD_VAR 0 7
33064: PPUSH
33065: LD_EXP 118
33069: PUSH
33070: LD_VAR 0 2
33074: ARRAY
33075: PPUSH
33076: CALL 61115 0 2
33080: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33081: LD_EXP 132
33085: PUSH
33086: LD_VAR 0 2
33090: ARRAY
33091: IFFALSE 33114
// if not weapon in mc_allowed_tower_weapons [ i ] then
33093: LD_VAR 0 9
33097: PUSH
33098: LD_EXP 132
33102: PUSH
33103: LD_VAR 0 2
33107: ARRAY
33108: IN
33109: NOT
33110: IFFALSE 33114
// continue ;
33112: GO 32816
// end else
33114: GO 33179
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33116: LD_ADDR_VAR 0 5
33120: PUSH
33121: LD_EXP 101
33125: PUSH
33126: LD_VAR 0 2
33130: ARRAY
33131: PPUSH
33132: LD_VAR 0 4
33136: PPUSH
33137: CALL 87404 0 2
33141: ST_TO_ADDR
// if not tmp2 then
33142: LD_VAR 0 5
33146: NOT
33147: IFFALSE 33151
// continue ;
33149: GO 32816
// tw := tmp2 [ 1 ] ;
33151: LD_ADDR_VAR 0 7
33155: PUSH
33156: LD_VAR 0 5
33160: PUSH
33161: LD_INT 1
33163: ARRAY
33164: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33165: LD_ADDR_VAR 0 9
33169: PUSH
33170: LD_VAR 0 5
33174: PUSH
33175: LD_INT 2
33177: ARRAY
33178: ST_TO_ADDR
// end ; if not weapon then
33179: LD_VAR 0 9
33183: NOT
33184: IFFALSE 33188
// continue ;
33186: GO 32816
// ComPlaceWeapon ( tw , weapon ) ;
33188: LD_VAR 0 7
33192: PPUSH
33193: LD_VAR 0 9
33197: PPUSH
33198: CALL_OW 148
// end ;
33202: GO 32816
33204: POP
33205: POP
// end ;
33206: LD_VAR 0 1
33210: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33211: LD_INT 0
33213: PPUSH
33214: PPUSH
33215: PPUSH
33216: PPUSH
33217: PPUSH
33218: PPUSH
33219: PPUSH
// if not mc_bases then
33220: LD_EXP 93
33224: NOT
33225: IFFALSE 33229
// exit ;
33227: GO 33997
// for i = 1 to mc_bases do
33229: LD_ADDR_VAR 0 2
33233: PUSH
33234: DOUBLE
33235: LD_INT 1
33237: DEC
33238: ST_TO_ADDR
33239: LD_EXP 93
33243: PUSH
33244: FOR_TO
33245: IFFALSE 33995
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33247: LD_EXP 106
33251: PUSH
33252: LD_VAR 0 2
33256: ARRAY
33257: NOT
33258: PUSH
33259: LD_EXP 106
33263: PUSH
33264: LD_VAR 0 2
33268: ARRAY
33269: PUSH
33270: LD_EXP 107
33274: PUSH
33275: LD_VAR 0 2
33279: ARRAY
33280: EQUAL
33281: OR
33282: PUSH
33283: LD_EXP 116
33287: PUSH
33288: LD_VAR 0 2
33292: ARRAY
33293: OR
33294: IFFALSE 33298
// continue ;
33296: GO 33244
// if mc_miners [ i ] then
33298: LD_EXP 107
33302: PUSH
33303: LD_VAR 0 2
33307: ARRAY
33308: IFFALSE 33682
// begin for j = mc_miners [ i ] downto 1 do
33310: LD_ADDR_VAR 0 3
33314: PUSH
33315: DOUBLE
33316: LD_EXP 107
33320: PUSH
33321: LD_VAR 0 2
33325: ARRAY
33326: INC
33327: ST_TO_ADDR
33328: LD_INT 1
33330: PUSH
33331: FOR_DOWNTO
33332: IFFALSE 33680
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33334: LD_EXP 107
33338: PUSH
33339: LD_VAR 0 2
33343: ARRAY
33344: PUSH
33345: LD_VAR 0 3
33349: ARRAY
33350: PPUSH
33351: CALL_OW 301
33355: PUSH
33356: LD_EXP 107
33360: PUSH
33361: LD_VAR 0 2
33365: ARRAY
33366: PUSH
33367: LD_VAR 0 3
33371: ARRAY
33372: PPUSH
33373: CALL_OW 257
33377: PUSH
33378: LD_INT 1
33380: NONEQUAL
33381: OR
33382: IFFALSE 33445
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33384: LD_ADDR_VAR 0 5
33388: PUSH
33389: LD_EXP 107
33393: PUSH
33394: LD_VAR 0 2
33398: ARRAY
33399: PUSH
33400: LD_EXP 107
33404: PUSH
33405: LD_VAR 0 2
33409: ARRAY
33410: PUSH
33411: LD_VAR 0 3
33415: ARRAY
33416: DIFF
33417: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33418: LD_ADDR_EXP 107
33422: PUSH
33423: LD_EXP 107
33427: PPUSH
33428: LD_VAR 0 2
33432: PPUSH
33433: LD_VAR 0 5
33437: PPUSH
33438: CALL_OW 1
33442: ST_TO_ADDR
// continue ;
33443: GO 33331
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33445: LD_EXP 107
33449: PUSH
33450: LD_VAR 0 2
33454: ARRAY
33455: PUSH
33456: LD_VAR 0 3
33460: ARRAY
33461: PPUSH
33462: CALL_OW 257
33466: PUSH
33467: LD_INT 1
33469: EQUAL
33470: PUSH
33471: LD_EXP 107
33475: PUSH
33476: LD_VAR 0 2
33480: ARRAY
33481: PUSH
33482: LD_VAR 0 3
33486: ARRAY
33487: PPUSH
33488: CALL_OW 459
33492: NOT
33493: AND
33494: PUSH
33495: LD_EXP 107
33499: PUSH
33500: LD_VAR 0 2
33504: ARRAY
33505: PUSH
33506: LD_VAR 0 3
33510: ARRAY
33511: PPUSH
33512: CALL_OW 314
33516: NOT
33517: AND
33518: IFFALSE 33678
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33520: LD_EXP 107
33524: PUSH
33525: LD_VAR 0 2
33529: ARRAY
33530: PUSH
33531: LD_VAR 0 3
33535: ARRAY
33536: PPUSH
33537: CALL_OW 310
33541: IFFALSE 33564
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33543: LD_EXP 107
33547: PUSH
33548: LD_VAR 0 2
33552: ARRAY
33553: PUSH
33554: LD_VAR 0 3
33558: ARRAY
33559: PPUSH
33560: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33564: LD_EXP 107
33568: PUSH
33569: LD_VAR 0 2
33573: ARRAY
33574: PUSH
33575: LD_VAR 0 3
33579: ARRAY
33580: PPUSH
33581: CALL_OW 314
33585: NOT
33586: IFFALSE 33678
// begin r := rand ( 1 , mc_mines [ i ] ) ;
33588: LD_ADDR_VAR 0 7
33592: PUSH
33593: LD_INT 1
33595: PPUSH
33596: LD_EXP 106
33600: PUSH
33601: LD_VAR 0 2
33605: ARRAY
33606: PPUSH
33607: CALL_OW 12
33611: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
33612: LD_EXP 107
33616: PUSH
33617: LD_VAR 0 2
33621: ARRAY
33622: PUSH
33623: LD_VAR 0 3
33627: ARRAY
33628: PPUSH
33629: LD_EXP 106
33633: PUSH
33634: LD_VAR 0 2
33638: ARRAY
33639: PUSH
33640: LD_VAR 0 7
33644: ARRAY
33645: PUSH
33646: LD_INT 1
33648: ARRAY
33649: PPUSH
33650: LD_EXP 106
33654: PUSH
33655: LD_VAR 0 2
33659: ARRAY
33660: PUSH
33661: LD_VAR 0 7
33665: ARRAY
33666: PUSH
33667: LD_INT 2
33669: ARRAY
33670: PPUSH
33671: LD_INT 0
33673: PPUSH
33674: CALL_OW 193
// end ; end ; end ;
33678: GO 33331
33680: POP
33681: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33682: LD_ADDR_VAR 0 5
33686: PUSH
33687: LD_EXP 93
33691: PUSH
33692: LD_VAR 0 2
33696: ARRAY
33697: PPUSH
33698: LD_INT 2
33700: PUSH
33701: LD_INT 30
33703: PUSH
33704: LD_INT 4
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 30
33713: PUSH
33714: LD_INT 5
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: PUSH
33721: LD_INT 30
33723: PUSH
33724: LD_INT 32
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: PPUSH
33737: CALL_OW 72
33741: ST_TO_ADDR
// if not tmp then
33742: LD_VAR 0 5
33746: NOT
33747: IFFALSE 33751
// continue ;
33749: GO 33244
// list := [ ] ;
33751: LD_ADDR_VAR 0 6
33755: PUSH
33756: EMPTY
33757: ST_TO_ADDR
// for j in tmp do
33758: LD_ADDR_VAR 0 3
33762: PUSH
33763: LD_VAR 0 5
33767: PUSH
33768: FOR_IN
33769: IFFALSE 33838
// begin for k in UnitsInside ( j ) do
33771: LD_ADDR_VAR 0 4
33775: PUSH
33776: LD_VAR 0 3
33780: PPUSH
33781: CALL_OW 313
33785: PUSH
33786: FOR_IN
33787: IFFALSE 33834
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33789: LD_VAR 0 4
33793: PPUSH
33794: CALL_OW 257
33798: PUSH
33799: LD_INT 1
33801: EQUAL
33802: PUSH
33803: LD_VAR 0 4
33807: PPUSH
33808: CALL_OW 459
33812: NOT
33813: AND
33814: IFFALSE 33832
// list := list ^ k ;
33816: LD_ADDR_VAR 0 6
33820: PUSH
33821: LD_VAR 0 6
33825: PUSH
33826: LD_VAR 0 4
33830: ADD
33831: ST_TO_ADDR
33832: GO 33786
33834: POP
33835: POP
// end ;
33836: GO 33768
33838: POP
33839: POP
// list := list diff mc_miners [ i ] ;
33840: LD_ADDR_VAR 0 6
33844: PUSH
33845: LD_VAR 0 6
33849: PUSH
33850: LD_EXP 107
33854: PUSH
33855: LD_VAR 0 2
33859: ARRAY
33860: DIFF
33861: ST_TO_ADDR
// if not list then
33862: LD_VAR 0 6
33866: NOT
33867: IFFALSE 33871
// continue ;
33869: GO 33244
// k := mc_mines [ i ] - mc_miners [ i ] ;
33871: LD_ADDR_VAR 0 4
33875: PUSH
33876: LD_EXP 106
33880: PUSH
33881: LD_VAR 0 2
33885: ARRAY
33886: PUSH
33887: LD_EXP 107
33891: PUSH
33892: LD_VAR 0 2
33896: ARRAY
33897: MINUS
33898: ST_TO_ADDR
// if k > list then
33899: LD_VAR 0 4
33903: PUSH
33904: LD_VAR 0 6
33908: GREATER
33909: IFFALSE 33921
// k := list ;
33911: LD_ADDR_VAR 0 4
33915: PUSH
33916: LD_VAR 0 6
33920: ST_TO_ADDR
// for j = 1 to k do
33921: LD_ADDR_VAR 0 3
33925: PUSH
33926: DOUBLE
33927: LD_INT 1
33929: DEC
33930: ST_TO_ADDR
33931: LD_VAR 0 4
33935: PUSH
33936: FOR_TO
33937: IFFALSE 33991
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33939: LD_ADDR_EXP 107
33943: PUSH
33944: LD_EXP 107
33948: PPUSH
33949: LD_VAR 0 2
33953: PUSH
33954: LD_EXP 107
33958: PUSH
33959: LD_VAR 0 2
33963: ARRAY
33964: PUSH
33965: LD_INT 1
33967: PLUS
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PPUSH
33973: LD_VAR 0 6
33977: PUSH
33978: LD_VAR 0 3
33982: ARRAY
33983: PPUSH
33984: CALL 56104 0 3
33988: ST_TO_ADDR
33989: GO 33936
33991: POP
33992: POP
// end ;
33993: GO 33244
33995: POP
33996: POP
// end ;
33997: LD_VAR 0 1
34001: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
34002: LD_INT 0
34004: PPUSH
34005: PPUSH
34006: PPUSH
34007: PPUSH
34008: PPUSH
34009: PPUSH
34010: PPUSH
34011: PPUSH
34012: PPUSH
34013: PPUSH
// if not mc_bases then
34014: LD_EXP 93
34018: NOT
34019: IFFALSE 34023
// exit ;
34021: GO 35773
// for i = 1 to mc_bases do
34023: LD_ADDR_VAR 0 2
34027: PUSH
34028: DOUBLE
34029: LD_INT 1
34031: DEC
34032: ST_TO_ADDR
34033: LD_EXP 93
34037: PUSH
34038: FOR_TO
34039: IFFALSE 35771
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34041: LD_EXP 93
34045: PUSH
34046: LD_VAR 0 2
34050: ARRAY
34051: NOT
34052: PUSH
34053: LD_EXP 100
34057: PUSH
34058: LD_VAR 0 2
34062: ARRAY
34063: OR
34064: IFFALSE 34068
// continue ;
34066: GO 34038
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34068: LD_EXP 109
34072: PUSH
34073: LD_VAR 0 2
34077: ARRAY
34078: NOT
34079: PUSH
34080: LD_EXP 110
34084: PUSH
34085: LD_VAR 0 2
34089: ARRAY
34090: AND
34091: IFFALSE 34129
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34093: LD_ADDR_EXP 110
34097: PUSH
34098: LD_EXP 110
34102: PPUSH
34103: LD_VAR 0 2
34107: PPUSH
34108: EMPTY
34109: PPUSH
34110: CALL_OW 1
34114: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34115: LD_VAR 0 2
34119: PPUSH
34120: LD_INT 107
34122: PPUSH
34123: CALL 24956 0 2
// continue ;
34127: GO 34038
// end ; target := [ ] ;
34129: LD_ADDR_VAR 0 6
34133: PUSH
34134: EMPTY
34135: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34136: LD_ADDR_VAR 0 3
34140: PUSH
34141: DOUBLE
34142: LD_EXP 109
34146: PUSH
34147: LD_VAR 0 2
34151: ARRAY
34152: INC
34153: ST_TO_ADDR
34154: LD_INT 1
34156: PUSH
34157: FOR_DOWNTO
34158: IFFALSE 34418
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34160: LD_EXP 109
34164: PUSH
34165: LD_VAR 0 2
34169: ARRAY
34170: PUSH
34171: LD_VAR 0 3
34175: ARRAY
34176: PUSH
34177: LD_INT 2
34179: ARRAY
34180: PPUSH
34181: LD_EXP 109
34185: PUSH
34186: LD_VAR 0 2
34190: ARRAY
34191: PUSH
34192: LD_VAR 0 3
34196: ARRAY
34197: PUSH
34198: LD_INT 3
34200: ARRAY
34201: PPUSH
34202: CALL_OW 488
34206: PUSH
34207: LD_EXP 109
34211: PUSH
34212: LD_VAR 0 2
34216: ARRAY
34217: PUSH
34218: LD_VAR 0 3
34222: ARRAY
34223: PUSH
34224: LD_INT 2
34226: ARRAY
34227: PPUSH
34228: LD_EXP 109
34232: PUSH
34233: LD_VAR 0 2
34237: ARRAY
34238: PUSH
34239: LD_VAR 0 3
34243: ARRAY
34244: PUSH
34245: LD_INT 3
34247: ARRAY
34248: PPUSH
34249: CALL_OW 284
34253: PUSH
34254: LD_INT 0
34256: EQUAL
34257: AND
34258: IFFALSE 34313
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34260: LD_ADDR_VAR 0 5
34264: PUSH
34265: LD_EXP 109
34269: PUSH
34270: LD_VAR 0 2
34274: ARRAY
34275: PPUSH
34276: LD_VAR 0 3
34280: PPUSH
34281: CALL_OW 3
34285: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34286: LD_ADDR_EXP 109
34290: PUSH
34291: LD_EXP 109
34295: PPUSH
34296: LD_VAR 0 2
34300: PPUSH
34301: LD_VAR 0 5
34305: PPUSH
34306: CALL_OW 1
34310: ST_TO_ADDR
// continue ;
34311: GO 34157
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34313: LD_EXP 93
34317: PUSH
34318: LD_VAR 0 2
34322: ARRAY
34323: PUSH
34324: LD_INT 1
34326: ARRAY
34327: PPUSH
34328: CALL_OW 255
34332: PPUSH
34333: LD_EXP 109
34337: PUSH
34338: LD_VAR 0 2
34342: ARRAY
34343: PUSH
34344: LD_VAR 0 3
34348: ARRAY
34349: PUSH
34350: LD_INT 2
34352: ARRAY
34353: PPUSH
34354: LD_EXP 109
34358: PUSH
34359: LD_VAR 0 2
34363: ARRAY
34364: PUSH
34365: LD_VAR 0 3
34369: ARRAY
34370: PUSH
34371: LD_INT 3
34373: ARRAY
34374: PPUSH
34375: LD_INT 30
34377: PPUSH
34378: CALL 57000 0 4
34382: PUSH
34383: LD_INT 4
34385: ARRAY
34386: PUSH
34387: LD_INT 0
34389: EQUAL
34390: IFFALSE 34416
// begin target := mc_crates [ i ] [ j ] ;
34392: LD_ADDR_VAR 0 6
34396: PUSH
34397: LD_EXP 109
34401: PUSH
34402: LD_VAR 0 2
34406: ARRAY
34407: PUSH
34408: LD_VAR 0 3
34412: ARRAY
34413: ST_TO_ADDR
// break ;
34414: GO 34418
// end ; end ;
34416: GO 34157
34418: POP
34419: POP
// if not target then
34420: LD_VAR 0 6
34424: NOT
34425: IFFALSE 34429
// continue ;
34427: GO 34038
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34429: LD_ADDR_VAR 0 7
34433: PUSH
34434: LD_EXP 112
34438: PUSH
34439: LD_VAR 0 2
34443: ARRAY
34444: PPUSH
34445: LD_INT 2
34447: PUSH
34448: LD_INT 3
34450: PUSH
34451: LD_INT 58
34453: PUSH
34454: EMPTY
34455: LIST
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 61
34463: PUSH
34464: EMPTY
34465: LIST
34466: PUSH
34467: LD_INT 33
34469: PUSH
34470: LD_INT 5
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 33
34479: PUSH
34480: LD_INT 3
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: EMPTY
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 2
34496: PUSH
34497: LD_INT 34
34499: PUSH
34500: LD_INT 32
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 34
34509: PUSH
34510: LD_INT 51
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 34
34519: PUSH
34520: LD_INT 12
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: LIST
34531: LIST
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PPUSH
34537: CALL_OW 72
34541: ST_TO_ADDR
// if not cargo then
34542: LD_VAR 0 7
34546: NOT
34547: IFFALSE 35190
// begin if mc_crates_collector [ i ] < 5 then
34549: LD_EXP 110
34553: PUSH
34554: LD_VAR 0 2
34558: ARRAY
34559: PUSH
34560: LD_INT 5
34562: LESS
34563: IFFALSE 34929
// begin if mc_ape [ i ] then
34565: LD_EXP 122
34569: PUSH
34570: LD_VAR 0 2
34574: ARRAY
34575: IFFALSE 34622
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34577: LD_ADDR_VAR 0 5
34581: PUSH
34582: LD_EXP 122
34586: PUSH
34587: LD_VAR 0 2
34591: ARRAY
34592: PPUSH
34593: LD_INT 25
34595: PUSH
34596: LD_INT 16
34598: PUSH
34599: EMPTY
34600: LIST
34601: LIST
34602: PUSH
34603: LD_INT 24
34605: PUSH
34606: LD_INT 750
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: EMPTY
34614: LIST
34615: LIST
34616: PPUSH
34617: CALL_OW 72
34621: ST_TO_ADDR
// if not tmp then
34622: LD_VAR 0 5
34626: NOT
34627: IFFALSE 34674
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34629: LD_ADDR_VAR 0 5
34633: PUSH
34634: LD_EXP 93
34638: PUSH
34639: LD_VAR 0 2
34643: ARRAY
34644: PPUSH
34645: LD_INT 25
34647: PUSH
34648: LD_INT 2
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 24
34657: PUSH
34658: LD_INT 750
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PPUSH
34669: CALL_OW 72
34673: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34674: LD_EXP 122
34678: PUSH
34679: LD_VAR 0 2
34683: ARRAY
34684: PUSH
34685: LD_EXP 93
34689: PUSH
34690: LD_VAR 0 2
34694: ARRAY
34695: PPUSH
34696: LD_INT 25
34698: PUSH
34699: LD_INT 2
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: PUSH
34706: LD_INT 24
34708: PUSH
34709: LD_INT 750
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PPUSH
34720: CALL_OW 72
34724: AND
34725: PUSH
34726: LD_VAR 0 5
34730: PUSH
34731: LD_INT 5
34733: LESS
34734: AND
34735: IFFALSE 34817
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34737: LD_ADDR_VAR 0 3
34741: PUSH
34742: LD_EXP 93
34746: PUSH
34747: LD_VAR 0 2
34751: ARRAY
34752: PPUSH
34753: LD_INT 25
34755: PUSH
34756: LD_INT 2
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 24
34765: PUSH
34766: LD_INT 750
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PPUSH
34777: CALL_OW 72
34781: PUSH
34782: FOR_IN
34783: IFFALSE 34815
// begin tmp := tmp union j ;
34785: LD_ADDR_VAR 0 5
34789: PUSH
34790: LD_VAR 0 5
34794: PUSH
34795: LD_VAR 0 3
34799: UNION
34800: ST_TO_ADDR
// if tmp >= 5 then
34801: LD_VAR 0 5
34805: PUSH
34806: LD_INT 5
34808: GREATEREQUAL
34809: IFFALSE 34813
// break ;
34811: GO 34815
// end ;
34813: GO 34782
34815: POP
34816: POP
// end ; if not tmp then
34817: LD_VAR 0 5
34821: NOT
34822: IFFALSE 34826
// continue ;
34824: GO 34038
// for j in tmp do
34826: LD_ADDR_VAR 0 3
34830: PUSH
34831: LD_VAR 0 5
34835: PUSH
34836: FOR_IN
34837: IFFALSE 34927
// if not GetTag ( j ) then
34839: LD_VAR 0 3
34843: PPUSH
34844: CALL_OW 110
34848: NOT
34849: IFFALSE 34925
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34851: LD_ADDR_EXP 110
34855: PUSH
34856: LD_EXP 110
34860: PPUSH
34861: LD_VAR 0 2
34865: PUSH
34866: LD_EXP 110
34870: PUSH
34871: LD_VAR 0 2
34875: ARRAY
34876: PUSH
34877: LD_INT 1
34879: PLUS
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PPUSH
34885: LD_VAR 0 3
34889: PPUSH
34890: CALL 56104 0 3
34894: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34895: LD_VAR 0 3
34899: PPUSH
34900: LD_INT 107
34902: PPUSH
34903: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34907: LD_EXP 110
34911: PUSH
34912: LD_VAR 0 2
34916: ARRAY
34917: PUSH
34918: LD_INT 5
34920: GREATEREQUAL
34921: IFFALSE 34925
// break ;
34923: GO 34927
// end ;
34925: GO 34836
34927: POP
34928: POP
// end ; if mc_crates_collector [ i ] and target then
34929: LD_EXP 110
34933: PUSH
34934: LD_VAR 0 2
34938: ARRAY
34939: PUSH
34940: LD_VAR 0 6
34944: AND
34945: IFFALSE 35188
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34947: LD_EXP 110
34951: PUSH
34952: LD_VAR 0 2
34956: ARRAY
34957: PUSH
34958: LD_VAR 0 6
34962: PUSH
34963: LD_INT 1
34965: ARRAY
34966: LESS
34967: IFFALSE 34987
// tmp := mc_crates_collector [ i ] else
34969: LD_ADDR_VAR 0 5
34973: PUSH
34974: LD_EXP 110
34978: PUSH
34979: LD_VAR 0 2
34983: ARRAY
34984: ST_TO_ADDR
34985: GO 35001
// tmp := target [ 1 ] ;
34987: LD_ADDR_VAR 0 5
34991: PUSH
34992: LD_VAR 0 6
34996: PUSH
34997: LD_INT 1
34999: ARRAY
35000: ST_TO_ADDR
// k := 0 ;
35001: LD_ADDR_VAR 0 4
35005: PUSH
35006: LD_INT 0
35008: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35009: LD_ADDR_VAR 0 3
35013: PUSH
35014: LD_EXP 110
35018: PUSH
35019: LD_VAR 0 2
35023: ARRAY
35024: PUSH
35025: FOR_IN
35026: IFFALSE 35186
// begin k := k + 1 ;
35028: LD_ADDR_VAR 0 4
35032: PUSH
35033: LD_VAR 0 4
35037: PUSH
35038: LD_INT 1
35040: PLUS
35041: ST_TO_ADDR
// if k > tmp then
35042: LD_VAR 0 4
35046: PUSH
35047: LD_VAR 0 5
35051: GREATER
35052: IFFALSE 35056
// break ;
35054: GO 35186
// if not GetClass ( j ) in [ 2 , 16 ] then
35056: LD_VAR 0 3
35060: PPUSH
35061: CALL_OW 257
35065: PUSH
35066: LD_INT 2
35068: PUSH
35069: LD_INT 16
35071: PUSH
35072: EMPTY
35073: LIST
35074: LIST
35075: IN
35076: NOT
35077: IFFALSE 35130
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35079: LD_ADDR_EXP 110
35083: PUSH
35084: LD_EXP 110
35088: PPUSH
35089: LD_VAR 0 2
35093: PPUSH
35094: LD_EXP 110
35098: PUSH
35099: LD_VAR 0 2
35103: ARRAY
35104: PUSH
35105: LD_VAR 0 3
35109: DIFF
35110: PPUSH
35111: CALL_OW 1
35115: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35116: LD_VAR 0 3
35120: PPUSH
35121: LD_INT 0
35123: PPUSH
35124: CALL_OW 109
// continue ;
35128: GO 35025
// end ; if IsInUnit ( j ) then
35130: LD_VAR 0 3
35134: PPUSH
35135: CALL_OW 310
35139: IFFALSE 35150
// ComExitBuilding ( j ) ;
35141: LD_VAR 0 3
35145: PPUSH
35146: CALL_OW 122
// wait ( 3 ) ;
35150: LD_INT 3
35152: PPUSH
35153: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35157: LD_VAR 0 3
35161: PPUSH
35162: LD_VAR 0 6
35166: PUSH
35167: LD_INT 2
35169: ARRAY
35170: PPUSH
35171: LD_VAR 0 6
35175: PUSH
35176: LD_INT 3
35178: ARRAY
35179: PPUSH
35180: CALL_OW 117
// end ;
35184: GO 35025
35186: POP
35187: POP
// end ; end else
35188: GO 35769
// begin for j in cargo do
35190: LD_ADDR_VAR 0 3
35194: PUSH
35195: LD_VAR 0 7
35199: PUSH
35200: FOR_IN
35201: IFFALSE 35767
// begin if GetTag ( j ) <> 0 then
35203: LD_VAR 0 3
35207: PPUSH
35208: CALL_OW 110
35212: PUSH
35213: LD_INT 0
35215: NONEQUAL
35216: IFFALSE 35220
// continue ;
35218: GO 35200
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35220: LD_VAR 0 3
35224: PPUSH
35225: CALL_OW 256
35229: PUSH
35230: LD_INT 1000
35232: LESS
35233: PUSH
35234: LD_VAR 0 3
35238: PPUSH
35239: LD_EXP 117
35243: PUSH
35244: LD_VAR 0 2
35248: ARRAY
35249: PPUSH
35250: CALL_OW 308
35254: NOT
35255: AND
35256: IFFALSE 35278
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35258: LD_VAR 0 3
35262: PPUSH
35263: LD_EXP 117
35267: PUSH
35268: LD_VAR 0 2
35272: ARRAY
35273: PPUSH
35274: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35278: LD_VAR 0 3
35282: PPUSH
35283: CALL_OW 256
35287: PUSH
35288: LD_INT 1000
35290: LESS
35291: PUSH
35292: LD_VAR 0 3
35296: PPUSH
35297: LD_EXP 117
35301: PUSH
35302: LD_VAR 0 2
35306: ARRAY
35307: PPUSH
35308: CALL_OW 308
35312: AND
35313: IFFALSE 35317
// continue ;
35315: GO 35200
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35317: LD_VAR 0 3
35321: PPUSH
35322: CALL_OW 262
35326: PUSH
35327: LD_INT 2
35329: EQUAL
35330: PUSH
35331: LD_VAR 0 3
35335: PPUSH
35336: CALL_OW 261
35340: PUSH
35341: LD_INT 15
35343: LESS
35344: AND
35345: IFFALSE 35349
// continue ;
35347: GO 35200
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35349: LD_VAR 0 3
35353: PPUSH
35354: CALL_OW 262
35358: PUSH
35359: LD_INT 1
35361: EQUAL
35362: PUSH
35363: LD_VAR 0 3
35367: PPUSH
35368: CALL_OW 261
35372: PUSH
35373: LD_INT 10
35375: LESS
35376: AND
35377: IFFALSE 35706
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35379: LD_ADDR_VAR 0 8
35383: PUSH
35384: LD_EXP 93
35388: PUSH
35389: LD_VAR 0 2
35393: ARRAY
35394: PPUSH
35395: LD_INT 2
35397: PUSH
35398: LD_INT 30
35400: PUSH
35401: LD_INT 0
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 30
35410: PUSH
35411: LD_INT 1
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: EMPTY
35419: LIST
35420: LIST
35421: LIST
35422: PPUSH
35423: CALL_OW 72
35427: ST_TO_ADDR
// if not depot then
35428: LD_VAR 0 8
35432: NOT
35433: IFFALSE 35437
// continue ;
35435: GO 35200
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35437: LD_VAR 0 3
35441: PPUSH
35442: LD_VAR 0 8
35446: PPUSH
35447: LD_VAR 0 3
35451: PPUSH
35452: CALL_OW 74
35456: PPUSH
35457: CALL_OW 296
35461: PUSH
35462: LD_INT 6
35464: LESS
35465: IFFALSE 35481
// SetFuel ( j , 100 ) else
35467: LD_VAR 0 3
35471: PPUSH
35472: LD_INT 100
35474: PPUSH
35475: CALL_OW 240
35479: GO 35706
// if GetFuel ( j ) = 0 then
35481: LD_VAR 0 3
35485: PPUSH
35486: CALL_OW 261
35490: PUSH
35491: LD_INT 0
35493: EQUAL
35494: IFFALSE 35706
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35496: LD_ADDR_EXP 112
35500: PUSH
35501: LD_EXP 112
35505: PPUSH
35506: LD_VAR 0 2
35510: PPUSH
35511: LD_EXP 112
35515: PUSH
35516: LD_VAR 0 2
35520: ARRAY
35521: PUSH
35522: LD_VAR 0 3
35526: DIFF
35527: PPUSH
35528: CALL_OW 1
35532: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35533: LD_VAR 0 3
35537: PPUSH
35538: CALL_OW 263
35542: PUSH
35543: LD_INT 1
35545: EQUAL
35546: IFFALSE 35562
// ComExitVehicle ( IsInUnit ( j ) ) ;
35548: LD_VAR 0 3
35552: PPUSH
35553: CALL_OW 310
35557: PPUSH
35558: CALL_OW 121
// if GetControl ( j ) = control_remote then
35562: LD_VAR 0 3
35566: PPUSH
35567: CALL_OW 263
35571: PUSH
35572: LD_INT 2
35574: EQUAL
35575: IFFALSE 35586
// ComUnlink ( j ) ;
35577: LD_VAR 0 3
35581: PPUSH
35582: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35586: LD_ADDR_VAR 0 9
35590: PUSH
35591: LD_VAR 0 2
35595: PPUSH
35596: LD_INT 3
35598: PPUSH
35599: CALL 45176 0 2
35603: ST_TO_ADDR
// if fac then
35604: LD_VAR 0 9
35608: IFFALSE 35704
// begin for k in fac do
35610: LD_ADDR_VAR 0 4
35614: PUSH
35615: LD_VAR 0 9
35619: PUSH
35620: FOR_IN
35621: IFFALSE 35702
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35623: LD_ADDR_VAR 0 10
35627: PUSH
35628: LD_VAR 0 9
35632: PPUSH
35633: LD_VAR 0 3
35637: PPUSH
35638: CALL_OW 265
35642: PPUSH
35643: LD_VAR 0 3
35647: PPUSH
35648: CALL_OW 262
35652: PPUSH
35653: LD_VAR 0 3
35657: PPUSH
35658: CALL_OW 263
35662: PPUSH
35663: LD_VAR 0 3
35667: PPUSH
35668: CALL_OW 264
35672: PPUSH
35673: CALL 53600 0 5
35677: ST_TO_ADDR
// if components then
35678: LD_VAR 0 10
35682: IFFALSE 35700
// begin MC_InsertProduceList ( i , components ) ;
35684: LD_VAR 0 2
35688: PPUSH
35689: LD_VAR 0 10
35693: PPUSH
35694: CALL 44721 0 2
// break ;
35698: GO 35702
// end ; end ;
35700: GO 35620
35702: POP
35703: POP
// end ; continue ;
35704: GO 35200
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35706: LD_VAR 0 3
35710: PPUSH
35711: LD_INT 1
35713: PPUSH
35714: CALL_OW 289
35718: PUSH
35719: LD_INT 100
35721: LESS
35722: PUSH
35723: LD_VAR 0 3
35727: PPUSH
35728: CALL_OW 314
35732: NOT
35733: AND
35734: IFFALSE 35763
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35736: LD_VAR 0 3
35740: PPUSH
35741: LD_VAR 0 6
35745: PUSH
35746: LD_INT 2
35748: ARRAY
35749: PPUSH
35750: LD_VAR 0 6
35754: PUSH
35755: LD_INT 3
35757: ARRAY
35758: PPUSH
35759: CALL_OW 117
// break ;
35763: GO 35767
// end ;
35765: GO 35200
35767: POP
35768: POP
// end ; end ;
35769: GO 34038
35771: POP
35772: POP
// end ;
35773: LD_VAR 0 1
35777: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35778: LD_INT 0
35780: PPUSH
35781: PPUSH
35782: PPUSH
35783: PPUSH
// if not mc_bases then
35784: LD_EXP 93
35788: NOT
35789: IFFALSE 35793
// exit ;
35791: GO 35954
// for i = 1 to mc_bases do
35793: LD_ADDR_VAR 0 2
35797: PUSH
35798: DOUBLE
35799: LD_INT 1
35801: DEC
35802: ST_TO_ADDR
35803: LD_EXP 93
35807: PUSH
35808: FOR_TO
35809: IFFALSE 35952
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35811: LD_ADDR_VAR 0 4
35815: PUSH
35816: LD_EXP 112
35820: PUSH
35821: LD_VAR 0 2
35825: ARRAY
35826: PUSH
35827: LD_EXP 115
35831: PUSH
35832: LD_VAR 0 2
35836: ARRAY
35837: UNION
35838: PPUSH
35839: LD_INT 33
35841: PUSH
35842: LD_INT 2
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PPUSH
35849: CALL_OW 72
35853: ST_TO_ADDR
// if tmp then
35854: LD_VAR 0 4
35858: IFFALSE 35950
// for j in tmp do
35860: LD_ADDR_VAR 0 3
35864: PUSH
35865: LD_VAR 0 4
35869: PUSH
35870: FOR_IN
35871: IFFALSE 35948
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35873: LD_VAR 0 3
35877: PPUSH
35878: CALL_OW 312
35882: NOT
35883: PUSH
35884: LD_VAR 0 3
35888: PPUSH
35889: CALL_OW 256
35893: PUSH
35894: LD_INT 250
35896: GREATEREQUAL
35897: AND
35898: IFFALSE 35911
// Connect ( j ) else
35900: LD_VAR 0 3
35904: PPUSH
35905: CALL 59075 0 1
35909: GO 35946
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35911: LD_VAR 0 3
35915: PPUSH
35916: CALL_OW 256
35920: PUSH
35921: LD_INT 250
35923: LESS
35924: PUSH
35925: LD_VAR 0 3
35929: PPUSH
35930: CALL_OW 312
35934: AND
35935: IFFALSE 35946
// ComUnlink ( j ) ;
35937: LD_VAR 0 3
35941: PPUSH
35942: CALL_OW 136
35946: GO 35870
35948: POP
35949: POP
// end ;
35950: GO 35808
35952: POP
35953: POP
// end ;
35954: LD_VAR 0 1
35958: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35959: LD_INT 0
35961: PPUSH
35962: PPUSH
35963: PPUSH
35964: PPUSH
35965: PPUSH
// if not mc_bases then
35966: LD_EXP 93
35970: NOT
35971: IFFALSE 35975
// exit ;
35973: GO 36420
// for i = 1 to mc_bases do
35975: LD_ADDR_VAR 0 2
35979: PUSH
35980: DOUBLE
35981: LD_INT 1
35983: DEC
35984: ST_TO_ADDR
35985: LD_EXP 93
35989: PUSH
35990: FOR_TO
35991: IFFALSE 36418
// begin if not mc_produce [ i ] then
35993: LD_EXP 114
35997: PUSH
35998: LD_VAR 0 2
36002: ARRAY
36003: NOT
36004: IFFALSE 36008
// continue ;
36006: GO 35990
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36008: LD_ADDR_VAR 0 5
36012: PUSH
36013: LD_EXP 93
36017: PUSH
36018: LD_VAR 0 2
36022: ARRAY
36023: PPUSH
36024: LD_INT 30
36026: PUSH
36027: LD_INT 3
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PPUSH
36034: CALL_OW 72
36038: ST_TO_ADDR
// if not fac then
36039: LD_VAR 0 5
36043: NOT
36044: IFFALSE 36048
// continue ;
36046: GO 35990
// for j in fac do
36048: LD_ADDR_VAR 0 3
36052: PUSH
36053: LD_VAR 0 5
36057: PUSH
36058: FOR_IN
36059: IFFALSE 36414
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36061: LD_VAR 0 3
36065: PPUSH
36066: CALL_OW 461
36070: PUSH
36071: LD_INT 2
36073: NONEQUAL
36074: PUSH
36075: LD_VAR 0 3
36079: PPUSH
36080: LD_INT 15
36082: PPUSH
36083: CALL 58703 0 2
36087: PUSH
36088: LD_INT 4
36090: ARRAY
36091: OR
36092: IFFALSE 36096
// continue ;
36094: GO 36058
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36096: LD_VAR 0 3
36100: PPUSH
36101: LD_EXP 114
36105: PUSH
36106: LD_VAR 0 2
36110: ARRAY
36111: PUSH
36112: LD_INT 1
36114: ARRAY
36115: PUSH
36116: LD_INT 1
36118: ARRAY
36119: PPUSH
36120: LD_EXP 114
36124: PUSH
36125: LD_VAR 0 2
36129: ARRAY
36130: PUSH
36131: LD_INT 1
36133: ARRAY
36134: PUSH
36135: LD_INT 2
36137: ARRAY
36138: PPUSH
36139: LD_EXP 114
36143: PUSH
36144: LD_VAR 0 2
36148: ARRAY
36149: PUSH
36150: LD_INT 1
36152: ARRAY
36153: PUSH
36154: LD_INT 3
36156: ARRAY
36157: PPUSH
36158: LD_EXP 114
36162: PUSH
36163: LD_VAR 0 2
36167: ARRAY
36168: PUSH
36169: LD_INT 1
36171: ARRAY
36172: PUSH
36173: LD_INT 4
36175: ARRAY
36176: PPUSH
36177: CALL_OW 448
36181: PUSH
36182: LD_VAR 0 3
36186: PPUSH
36187: LD_EXP 114
36191: PUSH
36192: LD_VAR 0 2
36196: ARRAY
36197: PUSH
36198: LD_INT 1
36200: ARRAY
36201: PUSH
36202: LD_INT 1
36204: ARRAY
36205: PUSH
36206: LD_EXP 114
36210: PUSH
36211: LD_VAR 0 2
36215: ARRAY
36216: PUSH
36217: LD_INT 1
36219: ARRAY
36220: PUSH
36221: LD_INT 2
36223: ARRAY
36224: PUSH
36225: LD_EXP 114
36229: PUSH
36230: LD_VAR 0 2
36234: ARRAY
36235: PUSH
36236: LD_INT 1
36238: ARRAY
36239: PUSH
36240: LD_INT 3
36242: ARRAY
36243: PUSH
36244: LD_EXP 114
36248: PUSH
36249: LD_VAR 0 2
36253: ARRAY
36254: PUSH
36255: LD_INT 1
36257: ARRAY
36258: PUSH
36259: LD_INT 4
36261: ARRAY
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: PPUSH
36269: CALL 62471 0 2
36273: AND
36274: IFFALSE 36412
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36276: LD_VAR 0 3
36280: PPUSH
36281: LD_EXP 114
36285: PUSH
36286: LD_VAR 0 2
36290: ARRAY
36291: PUSH
36292: LD_INT 1
36294: ARRAY
36295: PUSH
36296: LD_INT 1
36298: ARRAY
36299: PPUSH
36300: LD_EXP 114
36304: PUSH
36305: LD_VAR 0 2
36309: ARRAY
36310: PUSH
36311: LD_INT 1
36313: ARRAY
36314: PUSH
36315: LD_INT 2
36317: ARRAY
36318: PPUSH
36319: LD_EXP 114
36323: PUSH
36324: LD_VAR 0 2
36328: ARRAY
36329: PUSH
36330: LD_INT 1
36332: ARRAY
36333: PUSH
36334: LD_INT 3
36336: ARRAY
36337: PPUSH
36338: LD_EXP 114
36342: PUSH
36343: LD_VAR 0 2
36347: ARRAY
36348: PUSH
36349: LD_INT 1
36351: ARRAY
36352: PUSH
36353: LD_INT 4
36355: ARRAY
36356: PPUSH
36357: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36361: LD_ADDR_VAR 0 4
36365: PUSH
36366: LD_EXP 114
36370: PUSH
36371: LD_VAR 0 2
36375: ARRAY
36376: PPUSH
36377: LD_INT 1
36379: PPUSH
36380: CALL_OW 3
36384: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36385: LD_ADDR_EXP 114
36389: PUSH
36390: LD_EXP 114
36394: PPUSH
36395: LD_VAR 0 2
36399: PPUSH
36400: LD_VAR 0 4
36404: PPUSH
36405: CALL_OW 1
36409: ST_TO_ADDR
// break ;
36410: GO 36414
// end ; end ;
36412: GO 36058
36414: POP
36415: POP
// end ;
36416: GO 35990
36418: POP
36419: POP
// end ;
36420: LD_VAR 0 1
36424: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36425: LD_INT 0
36427: PPUSH
36428: PPUSH
36429: PPUSH
// if not mc_bases then
36430: LD_EXP 93
36434: NOT
36435: IFFALSE 36439
// exit ;
36437: GO 36528
// for i = 1 to mc_bases do
36439: LD_ADDR_VAR 0 2
36443: PUSH
36444: DOUBLE
36445: LD_INT 1
36447: DEC
36448: ST_TO_ADDR
36449: LD_EXP 93
36453: PUSH
36454: FOR_TO
36455: IFFALSE 36526
// begin if mc_attack [ i ] then
36457: LD_EXP 113
36461: PUSH
36462: LD_VAR 0 2
36466: ARRAY
36467: IFFALSE 36524
// begin tmp := mc_attack [ i ] [ 1 ] ;
36469: LD_ADDR_VAR 0 3
36473: PUSH
36474: LD_EXP 113
36478: PUSH
36479: LD_VAR 0 2
36483: ARRAY
36484: PUSH
36485: LD_INT 1
36487: ARRAY
36488: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36489: LD_ADDR_EXP 113
36493: PUSH
36494: LD_EXP 113
36498: PPUSH
36499: LD_VAR 0 2
36503: PPUSH
36504: EMPTY
36505: PPUSH
36506: CALL_OW 1
36510: ST_TO_ADDR
// Attack ( tmp ) ;
36511: LD_VAR 0 3
36515: PPUSH
36516: CALL 106779 0 1
// exit ;
36520: POP
36521: POP
36522: GO 36528
// end ; end ;
36524: GO 36454
36526: POP
36527: POP
// end ;
36528: LD_VAR 0 1
36532: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36533: LD_INT 0
36535: PPUSH
36536: PPUSH
36537: PPUSH
36538: PPUSH
36539: PPUSH
36540: PPUSH
36541: PPUSH
// if not mc_bases then
36542: LD_EXP 93
36546: NOT
36547: IFFALSE 36551
// exit ;
36549: GO 37250
// for i = 1 to mc_bases do
36551: LD_ADDR_VAR 0 2
36555: PUSH
36556: DOUBLE
36557: LD_INT 1
36559: DEC
36560: ST_TO_ADDR
36561: LD_EXP 93
36565: PUSH
36566: FOR_TO
36567: IFFALSE 37248
// begin if not mc_bases [ i ] then
36569: LD_EXP 93
36573: PUSH
36574: LD_VAR 0 2
36578: ARRAY
36579: NOT
36580: IFFALSE 36584
// continue ;
36582: GO 36566
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36584: LD_ADDR_VAR 0 7
36588: PUSH
36589: LD_EXP 93
36593: PUSH
36594: LD_VAR 0 2
36598: ARRAY
36599: PUSH
36600: LD_INT 1
36602: ARRAY
36603: PPUSH
36604: CALL 52904 0 1
36608: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36609: LD_ADDR_EXP 116
36613: PUSH
36614: LD_EXP 116
36618: PPUSH
36619: LD_VAR 0 2
36623: PPUSH
36624: LD_EXP 93
36628: PUSH
36629: LD_VAR 0 2
36633: ARRAY
36634: PUSH
36635: LD_INT 1
36637: ARRAY
36638: PPUSH
36639: CALL_OW 255
36643: PPUSH
36644: LD_EXP 118
36648: PUSH
36649: LD_VAR 0 2
36653: ARRAY
36654: PPUSH
36655: CALL 52869 0 2
36659: PPUSH
36660: CALL_OW 1
36664: ST_TO_ADDR
// if not mc_scan [ i ] then
36665: LD_EXP 116
36669: PUSH
36670: LD_VAR 0 2
36674: ARRAY
36675: NOT
36676: IFFALSE 36854
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36678: LD_ADDR_VAR 0 4
36682: PUSH
36683: LD_EXP 93
36687: PUSH
36688: LD_VAR 0 2
36692: ARRAY
36693: PPUSH
36694: LD_INT 2
36696: PUSH
36697: LD_INT 25
36699: PUSH
36700: LD_INT 5
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 25
36709: PUSH
36710: LD_INT 8
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 25
36719: PUSH
36720: LD_INT 9
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: LIST
36731: LIST
36732: PPUSH
36733: CALL_OW 72
36737: ST_TO_ADDR
// if not tmp then
36738: LD_VAR 0 4
36742: NOT
36743: IFFALSE 36747
// continue ;
36745: GO 36566
// for j in tmp do
36747: LD_ADDR_VAR 0 3
36751: PUSH
36752: LD_VAR 0 4
36756: PUSH
36757: FOR_IN
36758: IFFALSE 36829
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36760: LD_VAR 0 3
36764: PPUSH
36765: CALL_OW 310
36769: PPUSH
36770: CALL_OW 266
36774: PUSH
36775: LD_INT 5
36777: EQUAL
36778: PUSH
36779: LD_VAR 0 3
36783: PPUSH
36784: CALL_OW 257
36788: PUSH
36789: LD_INT 1
36791: EQUAL
36792: AND
36793: PUSH
36794: LD_VAR 0 3
36798: PPUSH
36799: CALL_OW 459
36803: NOT
36804: AND
36805: PUSH
36806: LD_VAR 0 7
36810: AND
36811: IFFALSE 36827
// ComChangeProfession ( j , class ) ;
36813: LD_VAR 0 3
36817: PPUSH
36818: LD_VAR 0 7
36822: PPUSH
36823: CALL_OW 123
36827: GO 36757
36829: POP
36830: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
36831: LD_ADDR_EXP 136
36835: PUSH
36836: LD_EXP 136
36840: PPUSH
36841: LD_VAR 0 2
36845: PPUSH
36846: LD_INT 0
36848: PPUSH
36849: CALL_OW 1
36853: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36854: LD_EXP 116
36858: PUSH
36859: LD_VAR 0 2
36863: ARRAY
36864: PUSH
36865: LD_EXP 136
36869: PUSH
36870: LD_VAR 0 2
36874: ARRAY
36875: NOT
36876: AND
36877: PUSH
36878: LD_EXP 115
36882: PUSH
36883: LD_VAR 0 2
36887: ARRAY
36888: NOT
36889: AND
36890: PUSH
36891: LD_EXP 93
36895: PUSH
36896: LD_VAR 0 2
36900: ARRAY
36901: PPUSH
36902: LD_INT 30
36904: PUSH
36905: LD_INT 32
36907: PUSH
36908: EMPTY
36909: LIST
36910: LIST
36911: PPUSH
36912: CALL_OW 72
36916: NOT
36917: AND
36918: PUSH
36919: LD_EXP 93
36923: PUSH
36924: LD_VAR 0 2
36928: ARRAY
36929: PPUSH
36930: LD_INT 2
36932: PUSH
36933: LD_INT 30
36935: PUSH
36936: LD_INT 4
36938: PUSH
36939: EMPTY
36940: LIST
36941: LIST
36942: PUSH
36943: LD_INT 30
36945: PUSH
36946: LD_INT 5
36948: PUSH
36949: EMPTY
36950: LIST
36951: LIST
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: LIST
36957: PPUSH
36958: CALL_OW 72
36962: NOT
36963: AND
36964: IFFALSE 37119
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36966: LD_ADDR_VAR 0 4
36970: PUSH
36971: LD_EXP 93
36975: PUSH
36976: LD_VAR 0 2
36980: ARRAY
36981: PPUSH
36982: LD_INT 2
36984: PUSH
36985: LD_INT 25
36987: PUSH
36988: LD_INT 1
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: LD_INT 25
36997: PUSH
36998: LD_INT 5
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 25
37007: PUSH
37008: LD_INT 8
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: LD_INT 25
37017: PUSH
37018: LD_INT 9
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: EMPTY
37026: LIST
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: PPUSH
37032: CALL_OW 72
37036: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37037: LD_ADDR_VAR 0 4
37041: PUSH
37042: LD_VAR 0 4
37046: PUSH
37047: LD_VAR 0 4
37051: PPUSH
37052: LD_INT 18
37054: PPUSH
37055: CALL 85374 0 2
37059: DIFF
37060: ST_TO_ADDR
// if tmp then
37061: LD_VAR 0 4
37065: IFFALSE 37119
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37067: LD_ADDR_EXP 136
37071: PUSH
37072: LD_EXP 136
37076: PPUSH
37077: LD_VAR 0 2
37081: PPUSH
37082: LD_INT 1
37084: PPUSH
37085: CALL_OW 1
37089: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
37090: LD_VAR 0 2
37094: PPUSH
37095: LD_VAR 0 4
37099: PPUSH
37100: LD_EXP 118
37104: PUSH
37105: LD_VAR 0 2
37109: ARRAY
37110: PPUSH
37111: CALL 111488 0 3
// exit ;
37115: POP
37116: POP
37117: GO 37250
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
37119: LD_EXP 116
37123: PUSH
37124: LD_VAR 0 2
37128: ARRAY
37129: PUSH
37130: LD_EXP 136
37134: PUSH
37135: LD_VAR 0 2
37139: ARRAY
37140: NOT
37141: AND
37142: PUSH
37143: LD_EXP 115
37147: PUSH
37148: LD_VAR 0 2
37152: ARRAY
37153: AND
37154: IFFALSE 37246
// begin tmp := mc_defender [ i ] ;
37156: LD_ADDR_VAR 0 4
37160: PUSH
37161: LD_EXP 115
37165: PUSH
37166: LD_VAR 0 2
37170: ARRAY
37171: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37172: LD_ADDR_EXP 115
37176: PUSH
37177: LD_EXP 115
37181: PPUSH
37182: LD_VAR 0 2
37186: PPUSH
37187: EMPTY
37188: PPUSH
37189: CALL_OW 1
37193: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37194: LD_ADDR_EXP 136
37198: PUSH
37199: LD_EXP 136
37203: PPUSH
37204: LD_VAR 0 2
37208: PPUSH
37209: LD_INT 1
37211: PPUSH
37212: CALL_OW 1
37216: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
37217: LD_VAR 0 2
37221: PPUSH
37222: LD_VAR 0 4
37226: PPUSH
37227: LD_EXP 116
37231: PUSH
37232: LD_VAR 0 2
37236: ARRAY
37237: PPUSH
37238: CALL 112049 0 3
// exit ;
37242: POP
37243: POP
37244: GO 37250
// end ; end ;
37246: GO 36566
37248: POP
37249: POP
// end ;
37250: LD_VAR 0 1
37254: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
37255: LD_INT 0
37257: PPUSH
37258: PPUSH
37259: PPUSH
37260: PPUSH
37261: PPUSH
37262: PPUSH
37263: PPUSH
37264: PPUSH
37265: PPUSH
37266: PPUSH
37267: PPUSH
// if not mc_bases then
37268: LD_EXP 93
37272: NOT
37273: IFFALSE 37277
// exit ;
37275: GO 38364
// for i = 1 to mc_bases do
37277: LD_ADDR_VAR 0 2
37281: PUSH
37282: DOUBLE
37283: LD_INT 1
37285: DEC
37286: ST_TO_ADDR
37287: LD_EXP 93
37291: PUSH
37292: FOR_TO
37293: IFFALSE 38362
// begin tmp := mc_lab [ i ] ;
37295: LD_ADDR_VAR 0 6
37299: PUSH
37300: LD_EXP 126
37304: PUSH
37305: LD_VAR 0 2
37309: ARRAY
37310: ST_TO_ADDR
// if not tmp then
37311: LD_VAR 0 6
37315: NOT
37316: IFFALSE 37320
// continue ;
37318: GO 37292
// idle_lab := 0 ;
37320: LD_ADDR_VAR 0 11
37324: PUSH
37325: LD_INT 0
37327: ST_TO_ADDR
// for j in tmp do
37328: LD_ADDR_VAR 0 3
37332: PUSH
37333: LD_VAR 0 6
37337: PUSH
37338: FOR_IN
37339: IFFALSE 38358
// begin researching := false ;
37341: LD_ADDR_VAR 0 10
37345: PUSH
37346: LD_INT 0
37348: ST_TO_ADDR
// side := GetSide ( j ) ;
37349: LD_ADDR_VAR 0 4
37353: PUSH
37354: LD_VAR 0 3
37358: PPUSH
37359: CALL_OW 255
37363: ST_TO_ADDR
// if not mc_tech [ side ] then
37364: LD_EXP 120
37368: PUSH
37369: LD_VAR 0 4
37373: ARRAY
37374: NOT
37375: IFFALSE 37379
// continue ;
37377: GO 37338
// if BuildingStatus ( j ) = bs_idle then
37379: LD_VAR 0 3
37383: PPUSH
37384: CALL_OW 461
37388: PUSH
37389: LD_INT 2
37391: EQUAL
37392: IFFALSE 37580
// begin if idle_lab and UnitsInside ( j ) < 6 then
37394: LD_VAR 0 11
37398: PUSH
37399: LD_VAR 0 3
37403: PPUSH
37404: CALL_OW 313
37408: PUSH
37409: LD_INT 6
37411: LESS
37412: AND
37413: IFFALSE 37484
// begin tmp2 := UnitsInside ( idle_lab ) ;
37415: LD_ADDR_VAR 0 9
37419: PUSH
37420: LD_VAR 0 11
37424: PPUSH
37425: CALL_OW 313
37429: ST_TO_ADDR
// if tmp2 then
37430: LD_VAR 0 9
37434: IFFALSE 37476
// for x in tmp2 do
37436: LD_ADDR_VAR 0 7
37440: PUSH
37441: LD_VAR 0 9
37445: PUSH
37446: FOR_IN
37447: IFFALSE 37474
// begin ComExitBuilding ( x ) ;
37449: LD_VAR 0 7
37453: PPUSH
37454: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37458: LD_VAR 0 7
37462: PPUSH
37463: LD_VAR 0 3
37467: PPUSH
37468: CALL_OW 180
// end ;
37472: GO 37446
37474: POP
37475: POP
// idle_lab := 0 ;
37476: LD_ADDR_VAR 0 11
37480: PUSH
37481: LD_INT 0
37483: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37484: LD_ADDR_VAR 0 5
37488: PUSH
37489: LD_EXP 120
37493: PUSH
37494: LD_VAR 0 4
37498: ARRAY
37499: PUSH
37500: FOR_IN
37501: IFFALSE 37561
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37503: LD_VAR 0 3
37507: PPUSH
37508: LD_VAR 0 5
37512: PPUSH
37513: CALL_OW 430
37517: PUSH
37518: LD_VAR 0 4
37522: PPUSH
37523: LD_VAR 0 5
37527: PPUSH
37528: CALL 51974 0 2
37532: AND
37533: IFFALSE 37559
// begin researching := true ;
37535: LD_ADDR_VAR 0 10
37539: PUSH
37540: LD_INT 1
37542: ST_TO_ADDR
// ComResearch ( j , t ) ;
37543: LD_VAR 0 3
37547: PPUSH
37548: LD_VAR 0 5
37552: PPUSH
37553: CALL_OW 124
// break ;
37557: GO 37561
// end ;
37559: GO 37500
37561: POP
37562: POP
// if not researching then
37563: LD_VAR 0 10
37567: NOT
37568: IFFALSE 37580
// idle_lab := j ;
37570: LD_ADDR_VAR 0 11
37574: PUSH
37575: LD_VAR 0 3
37579: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37580: LD_VAR 0 3
37584: PPUSH
37585: CALL_OW 461
37589: PUSH
37590: LD_INT 10
37592: EQUAL
37593: IFFALSE 38181
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37595: LD_EXP 122
37599: PUSH
37600: LD_VAR 0 2
37604: ARRAY
37605: NOT
37606: PUSH
37607: LD_EXP 123
37611: PUSH
37612: LD_VAR 0 2
37616: ARRAY
37617: NOT
37618: AND
37619: PUSH
37620: LD_EXP 120
37624: PUSH
37625: LD_VAR 0 4
37629: ARRAY
37630: PUSH
37631: LD_INT 1
37633: GREATER
37634: AND
37635: IFFALSE 37766
// begin ComCancel ( j ) ;
37637: LD_VAR 0 3
37641: PPUSH
37642: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37646: LD_ADDR_EXP 120
37650: PUSH
37651: LD_EXP 120
37655: PPUSH
37656: LD_VAR 0 4
37660: PPUSH
37661: LD_EXP 120
37665: PUSH
37666: LD_VAR 0 4
37670: ARRAY
37671: PPUSH
37672: LD_EXP 120
37676: PUSH
37677: LD_VAR 0 4
37681: ARRAY
37682: PUSH
37683: LD_INT 1
37685: MINUS
37686: PPUSH
37687: LD_EXP 120
37691: PUSH
37692: LD_VAR 0 4
37696: ARRAY
37697: PPUSH
37698: LD_INT 0
37700: PPUSH
37701: CALL 55522 0 4
37705: PPUSH
37706: CALL_OW 1
37710: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37711: LD_ADDR_EXP 120
37715: PUSH
37716: LD_EXP 120
37720: PPUSH
37721: LD_VAR 0 4
37725: PPUSH
37726: LD_EXP 120
37730: PUSH
37731: LD_VAR 0 4
37735: ARRAY
37736: PPUSH
37737: LD_EXP 120
37741: PUSH
37742: LD_VAR 0 4
37746: ARRAY
37747: PPUSH
37748: LD_INT 1
37750: PPUSH
37751: LD_INT 0
37753: PPUSH
37754: CALL 55522 0 4
37758: PPUSH
37759: CALL_OW 1
37763: ST_TO_ADDR
// continue ;
37764: GO 37338
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37766: LD_EXP 122
37770: PUSH
37771: LD_VAR 0 2
37775: ARRAY
37776: PUSH
37777: LD_EXP 123
37781: PUSH
37782: LD_VAR 0 2
37786: ARRAY
37787: NOT
37788: AND
37789: IFFALSE 37916
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37791: LD_ADDR_EXP 123
37795: PUSH
37796: LD_EXP 123
37800: PPUSH
37801: LD_VAR 0 2
37805: PUSH
37806: LD_EXP 123
37810: PUSH
37811: LD_VAR 0 2
37815: ARRAY
37816: PUSH
37817: LD_INT 1
37819: PLUS
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PPUSH
37825: LD_EXP 122
37829: PUSH
37830: LD_VAR 0 2
37834: ARRAY
37835: PUSH
37836: LD_INT 1
37838: ARRAY
37839: PPUSH
37840: CALL 56104 0 3
37844: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37845: LD_EXP 122
37849: PUSH
37850: LD_VAR 0 2
37854: ARRAY
37855: PUSH
37856: LD_INT 1
37858: ARRAY
37859: PPUSH
37860: LD_INT 112
37862: PPUSH
37863: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37867: LD_ADDR_VAR 0 9
37871: PUSH
37872: LD_EXP 122
37876: PUSH
37877: LD_VAR 0 2
37881: ARRAY
37882: PPUSH
37883: LD_INT 1
37885: PPUSH
37886: CALL_OW 3
37890: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37891: LD_ADDR_EXP 122
37895: PUSH
37896: LD_EXP 122
37900: PPUSH
37901: LD_VAR 0 2
37905: PPUSH
37906: LD_VAR 0 9
37910: PPUSH
37911: CALL_OW 1
37915: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37916: LD_EXP 122
37920: PUSH
37921: LD_VAR 0 2
37925: ARRAY
37926: PUSH
37927: LD_EXP 123
37931: PUSH
37932: LD_VAR 0 2
37936: ARRAY
37937: AND
37938: PUSH
37939: LD_EXP 123
37943: PUSH
37944: LD_VAR 0 2
37948: ARRAY
37949: PUSH
37950: LD_INT 1
37952: ARRAY
37953: PPUSH
37954: CALL_OW 310
37958: NOT
37959: AND
37960: PUSH
37961: LD_VAR 0 3
37965: PPUSH
37966: CALL_OW 313
37970: PUSH
37971: LD_INT 6
37973: EQUAL
37974: AND
37975: IFFALSE 38031
// begin tmp2 := UnitsInside ( j ) ;
37977: LD_ADDR_VAR 0 9
37981: PUSH
37982: LD_VAR 0 3
37986: PPUSH
37987: CALL_OW 313
37991: ST_TO_ADDR
// if tmp2 = 6 then
37992: LD_VAR 0 9
37996: PUSH
37997: LD_INT 6
37999: EQUAL
38000: IFFALSE 38031
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38002: LD_VAR 0 9
38006: PUSH
38007: LD_INT 1
38009: ARRAY
38010: PPUSH
38011: LD_INT 112
38013: PPUSH
38014: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38018: LD_VAR 0 9
38022: PUSH
38023: LD_INT 1
38025: ARRAY
38026: PPUSH
38027: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38031: LD_EXP 123
38035: PUSH
38036: LD_VAR 0 2
38040: ARRAY
38041: PUSH
38042: LD_EXP 123
38046: PUSH
38047: LD_VAR 0 2
38051: ARRAY
38052: PUSH
38053: LD_INT 1
38055: ARRAY
38056: PPUSH
38057: CALL_OW 314
38061: NOT
38062: AND
38063: PUSH
38064: LD_EXP 123
38068: PUSH
38069: LD_VAR 0 2
38073: ARRAY
38074: PUSH
38075: LD_INT 1
38077: ARRAY
38078: PPUSH
38079: CALL_OW 310
38083: NOT
38084: AND
38085: IFFALSE 38111
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38087: LD_EXP 123
38091: PUSH
38092: LD_VAR 0 2
38096: ARRAY
38097: PUSH
38098: LD_INT 1
38100: ARRAY
38101: PPUSH
38102: LD_VAR 0 3
38106: PPUSH
38107: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38111: LD_EXP 123
38115: PUSH
38116: LD_VAR 0 2
38120: ARRAY
38121: PUSH
38122: LD_INT 1
38124: ARRAY
38125: PPUSH
38126: CALL_OW 310
38130: PUSH
38131: LD_EXP 123
38135: PUSH
38136: LD_VAR 0 2
38140: ARRAY
38141: PUSH
38142: LD_INT 1
38144: ARRAY
38145: PPUSH
38146: CALL_OW 310
38150: PPUSH
38151: CALL_OW 461
38155: PUSH
38156: LD_INT 3
38158: NONEQUAL
38159: AND
38160: IFFALSE 38181
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
38162: LD_EXP 123
38166: PUSH
38167: LD_VAR 0 2
38171: ARRAY
38172: PUSH
38173: LD_INT 1
38175: ARRAY
38176: PPUSH
38177: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
38181: LD_VAR 0 3
38185: PPUSH
38186: CALL_OW 461
38190: PUSH
38191: LD_INT 6
38193: EQUAL
38194: PUSH
38195: LD_VAR 0 6
38199: PUSH
38200: LD_INT 1
38202: GREATER
38203: AND
38204: IFFALSE 38356
// begin sci := [ ] ;
38206: LD_ADDR_VAR 0 8
38210: PUSH
38211: EMPTY
38212: ST_TO_ADDR
// for x in ( tmp diff j ) do
38213: LD_ADDR_VAR 0 7
38217: PUSH
38218: LD_VAR 0 6
38222: PUSH
38223: LD_VAR 0 3
38227: DIFF
38228: PUSH
38229: FOR_IN
38230: IFFALSE 38282
// begin if sci = 6 then
38232: LD_VAR 0 8
38236: PUSH
38237: LD_INT 6
38239: EQUAL
38240: IFFALSE 38244
// break ;
38242: GO 38282
// if BuildingStatus ( x ) = bs_idle then
38244: LD_VAR 0 7
38248: PPUSH
38249: CALL_OW 461
38253: PUSH
38254: LD_INT 2
38256: EQUAL
38257: IFFALSE 38280
// sci := sci ^ UnitsInside ( x ) ;
38259: LD_ADDR_VAR 0 8
38263: PUSH
38264: LD_VAR 0 8
38268: PUSH
38269: LD_VAR 0 7
38273: PPUSH
38274: CALL_OW 313
38278: ADD
38279: ST_TO_ADDR
// end ;
38280: GO 38229
38282: POP
38283: POP
// if not sci then
38284: LD_VAR 0 8
38288: NOT
38289: IFFALSE 38293
// continue ;
38291: GO 37338
// for x in sci do
38293: LD_ADDR_VAR 0 7
38297: PUSH
38298: LD_VAR 0 8
38302: PUSH
38303: FOR_IN
38304: IFFALSE 38354
// if IsInUnit ( x ) and not HasTask ( x ) then
38306: LD_VAR 0 7
38310: PPUSH
38311: CALL_OW 310
38315: PUSH
38316: LD_VAR 0 7
38320: PPUSH
38321: CALL_OW 314
38325: NOT
38326: AND
38327: IFFALSE 38352
// begin ComExitBuilding ( x ) ;
38329: LD_VAR 0 7
38333: PPUSH
38334: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38338: LD_VAR 0 7
38342: PPUSH
38343: LD_VAR 0 3
38347: PPUSH
38348: CALL_OW 180
// end ;
38352: GO 38303
38354: POP
38355: POP
// end ; end ;
38356: GO 37338
38358: POP
38359: POP
// end ;
38360: GO 37292
38362: POP
38363: POP
// end ;
38364: LD_VAR 0 1
38368: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38369: LD_INT 0
38371: PPUSH
38372: PPUSH
// if not mc_bases then
38373: LD_EXP 93
38377: NOT
38378: IFFALSE 38382
// exit ;
38380: GO 38463
// for i = 1 to mc_bases do
38382: LD_ADDR_VAR 0 2
38386: PUSH
38387: DOUBLE
38388: LD_INT 1
38390: DEC
38391: ST_TO_ADDR
38392: LD_EXP 93
38396: PUSH
38397: FOR_TO
38398: IFFALSE 38461
// if mc_mines [ i ] and mc_miners [ i ] then
38400: LD_EXP 106
38404: PUSH
38405: LD_VAR 0 2
38409: ARRAY
38410: PUSH
38411: LD_EXP 107
38415: PUSH
38416: LD_VAR 0 2
38420: ARRAY
38421: AND
38422: IFFALSE 38459
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38424: LD_EXP 107
38428: PUSH
38429: LD_VAR 0 2
38433: ARRAY
38434: PUSH
38435: LD_INT 1
38437: ARRAY
38438: PPUSH
38439: CALL_OW 255
38443: PPUSH
38444: LD_EXP 106
38448: PUSH
38449: LD_VAR 0 2
38453: ARRAY
38454: PPUSH
38455: CALL 53057 0 2
38459: GO 38397
38461: POP
38462: POP
// end ;
38463: LD_VAR 0 1
38467: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38468: LD_INT 0
38470: PPUSH
38471: PPUSH
38472: PPUSH
38473: PPUSH
38474: PPUSH
38475: PPUSH
38476: PPUSH
38477: PPUSH
// if not mc_bases or not mc_parking then
38478: LD_EXP 93
38482: NOT
38483: PUSH
38484: LD_EXP 117
38488: NOT
38489: OR
38490: IFFALSE 38494
// exit ;
38492: GO 39193
// for i = 1 to mc_bases do
38494: LD_ADDR_VAR 0 2
38498: PUSH
38499: DOUBLE
38500: LD_INT 1
38502: DEC
38503: ST_TO_ADDR
38504: LD_EXP 93
38508: PUSH
38509: FOR_TO
38510: IFFALSE 39191
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38512: LD_EXP 93
38516: PUSH
38517: LD_VAR 0 2
38521: ARRAY
38522: NOT
38523: PUSH
38524: LD_EXP 117
38528: PUSH
38529: LD_VAR 0 2
38533: ARRAY
38534: NOT
38535: OR
38536: IFFALSE 38540
// continue ;
38538: GO 38509
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38540: LD_ADDR_VAR 0 5
38544: PUSH
38545: LD_EXP 93
38549: PUSH
38550: LD_VAR 0 2
38554: ARRAY
38555: PUSH
38556: LD_INT 1
38558: ARRAY
38559: PPUSH
38560: CALL_OW 255
38564: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38565: LD_ADDR_VAR 0 6
38569: PUSH
38570: LD_EXP 93
38574: PUSH
38575: LD_VAR 0 2
38579: ARRAY
38580: PPUSH
38581: LD_INT 30
38583: PUSH
38584: LD_INT 3
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: PPUSH
38591: CALL_OW 72
38595: ST_TO_ADDR
// if not fac then
38596: LD_VAR 0 6
38600: NOT
38601: IFFALSE 38652
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38603: LD_ADDR_VAR 0 6
38607: PUSH
38608: LD_EXP 93
38612: PUSH
38613: LD_VAR 0 2
38617: ARRAY
38618: PPUSH
38619: LD_INT 2
38621: PUSH
38622: LD_INT 30
38624: PUSH
38625: LD_INT 0
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 30
38634: PUSH
38635: LD_INT 1
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: LIST
38646: PPUSH
38647: CALL_OW 72
38651: ST_TO_ADDR
// if not fac then
38652: LD_VAR 0 6
38656: NOT
38657: IFFALSE 38661
// continue ;
38659: GO 38509
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38661: LD_ADDR_VAR 0 7
38665: PUSH
38666: LD_EXP 117
38670: PUSH
38671: LD_VAR 0 2
38675: ARRAY
38676: PPUSH
38677: LD_INT 22
38679: PUSH
38680: LD_VAR 0 5
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 21
38691: PUSH
38692: LD_INT 2
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 3
38701: PUSH
38702: LD_INT 24
38704: PUSH
38705: LD_INT 1000
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: LIST
38720: PPUSH
38721: CALL_OW 70
38725: ST_TO_ADDR
// for j in fac do
38726: LD_ADDR_VAR 0 3
38730: PUSH
38731: LD_VAR 0 6
38735: PUSH
38736: FOR_IN
38737: IFFALSE 38818
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38739: LD_ADDR_VAR 0 7
38743: PUSH
38744: LD_VAR 0 7
38748: PUSH
38749: LD_INT 22
38751: PUSH
38752: LD_VAR 0 5
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PUSH
38761: LD_INT 91
38763: PUSH
38764: LD_VAR 0 3
38768: PUSH
38769: LD_INT 15
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: LIST
38776: PUSH
38777: LD_INT 21
38779: PUSH
38780: LD_INT 2
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: PUSH
38787: LD_INT 3
38789: PUSH
38790: LD_INT 24
38792: PUSH
38793: LD_INT 1000
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: LIST
38808: LIST
38809: PPUSH
38810: CALL_OW 69
38814: UNION
38815: ST_TO_ADDR
38816: GO 38736
38818: POP
38819: POP
// if not vehs then
38820: LD_VAR 0 7
38824: NOT
38825: IFFALSE 38851
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38827: LD_ADDR_EXP 105
38831: PUSH
38832: LD_EXP 105
38836: PPUSH
38837: LD_VAR 0 2
38841: PPUSH
38842: EMPTY
38843: PPUSH
38844: CALL_OW 1
38848: ST_TO_ADDR
// continue ;
38849: GO 38509
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38851: LD_ADDR_VAR 0 8
38855: PUSH
38856: LD_EXP 93
38860: PUSH
38861: LD_VAR 0 2
38865: ARRAY
38866: PPUSH
38867: LD_INT 30
38869: PUSH
38870: LD_INT 3
38872: PUSH
38873: EMPTY
38874: LIST
38875: LIST
38876: PPUSH
38877: CALL_OW 72
38881: ST_TO_ADDR
// if tmp then
38882: LD_VAR 0 8
38886: IFFALSE 38989
// begin for j in tmp do
38888: LD_ADDR_VAR 0 3
38892: PUSH
38893: LD_VAR 0 8
38897: PUSH
38898: FOR_IN
38899: IFFALSE 38987
// for k in UnitsInside ( j ) do
38901: LD_ADDR_VAR 0 4
38905: PUSH
38906: LD_VAR 0 3
38910: PPUSH
38911: CALL_OW 313
38915: PUSH
38916: FOR_IN
38917: IFFALSE 38983
// if k then
38919: LD_VAR 0 4
38923: IFFALSE 38981
// if not k in mc_repair_vehicle [ i ] then
38925: LD_VAR 0 4
38929: PUSH
38930: LD_EXP 105
38934: PUSH
38935: LD_VAR 0 2
38939: ARRAY
38940: IN
38941: NOT
38942: IFFALSE 38981
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38944: LD_ADDR_EXP 105
38948: PUSH
38949: LD_EXP 105
38953: PPUSH
38954: LD_VAR 0 2
38958: PPUSH
38959: LD_EXP 105
38963: PUSH
38964: LD_VAR 0 2
38968: ARRAY
38969: PUSH
38970: LD_VAR 0 4
38974: UNION
38975: PPUSH
38976: CALL_OW 1
38980: ST_TO_ADDR
38981: GO 38916
38983: POP
38984: POP
38985: GO 38898
38987: POP
38988: POP
// end ; if not mc_repair_vehicle [ i ] then
38989: LD_EXP 105
38993: PUSH
38994: LD_VAR 0 2
38998: ARRAY
38999: NOT
39000: IFFALSE 39004
// continue ;
39002: GO 38509
// for j in mc_repair_vehicle [ i ] do
39004: LD_ADDR_VAR 0 3
39008: PUSH
39009: LD_EXP 105
39013: PUSH
39014: LD_VAR 0 2
39018: ARRAY
39019: PUSH
39020: FOR_IN
39021: IFFALSE 39187
// begin if GetClass ( j ) <> 3 then
39023: LD_VAR 0 3
39027: PPUSH
39028: CALL_OW 257
39032: PUSH
39033: LD_INT 3
39035: NONEQUAL
39036: IFFALSE 39077
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39038: LD_ADDR_EXP 105
39042: PUSH
39043: LD_EXP 105
39047: PPUSH
39048: LD_VAR 0 2
39052: PPUSH
39053: LD_EXP 105
39057: PUSH
39058: LD_VAR 0 2
39062: ARRAY
39063: PUSH
39064: LD_VAR 0 3
39068: DIFF
39069: PPUSH
39070: CALL_OW 1
39074: ST_TO_ADDR
// continue ;
39075: GO 39020
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39077: LD_VAR 0 3
39081: PPUSH
39082: CALL_OW 311
39086: NOT
39087: PUSH
39088: LD_VAR 0 3
39092: PUSH
39093: LD_EXP 96
39097: PUSH
39098: LD_VAR 0 2
39102: ARRAY
39103: PUSH
39104: LD_INT 1
39106: ARRAY
39107: IN
39108: NOT
39109: AND
39110: PUSH
39111: LD_VAR 0 3
39115: PUSH
39116: LD_EXP 96
39120: PUSH
39121: LD_VAR 0 2
39125: ARRAY
39126: PUSH
39127: LD_INT 2
39129: ARRAY
39130: IN
39131: NOT
39132: AND
39133: IFFALSE 39185
// begin if IsInUnit ( j ) then
39135: LD_VAR 0 3
39139: PPUSH
39140: CALL_OW 310
39144: IFFALSE 39155
// ComExitBuilding ( j ) ;
39146: LD_VAR 0 3
39150: PPUSH
39151: CALL_OW 122
// if not HasTask ( j ) then
39155: LD_VAR 0 3
39159: PPUSH
39160: CALL_OW 314
39164: NOT
39165: IFFALSE 39185
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
39167: LD_VAR 0 3
39171: PPUSH
39172: LD_VAR 0 7
39176: PUSH
39177: LD_INT 1
39179: ARRAY
39180: PPUSH
39181: CALL_OW 189
// end ; end ;
39185: GO 39020
39187: POP
39188: POP
// end ;
39189: GO 38509
39191: POP
39192: POP
// end ;
39193: LD_VAR 0 1
39197: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
39198: LD_INT 0
39200: PPUSH
39201: PPUSH
39202: PPUSH
39203: PPUSH
39204: PPUSH
39205: PPUSH
39206: PPUSH
39207: PPUSH
39208: PPUSH
39209: PPUSH
39210: PPUSH
// if not mc_bases then
39211: LD_EXP 93
39215: NOT
39216: IFFALSE 39220
// exit ;
39218: GO 40022
// for i = 1 to mc_bases do
39220: LD_ADDR_VAR 0 2
39224: PUSH
39225: DOUBLE
39226: LD_INT 1
39228: DEC
39229: ST_TO_ADDR
39230: LD_EXP 93
39234: PUSH
39235: FOR_TO
39236: IFFALSE 40020
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
39238: LD_EXP 121
39242: PUSH
39243: LD_VAR 0 2
39247: ARRAY
39248: NOT
39249: PUSH
39250: LD_EXP 96
39254: PUSH
39255: LD_VAR 0 2
39259: ARRAY
39260: PUSH
39261: LD_INT 1
39263: ARRAY
39264: OR
39265: PUSH
39266: LD_EXP 96
39270: PUSH
39271: LD_VAR 0 2
39275: ARRAY
39276: PUSH
39277: LD_INT 2
39279: ARRAY
39280: OR
39281: PUSH
39282: LD_EXP 119
39286: PUSH
39287: LD_VAR 0 2
39291: ARRAY
39292: PPUSH
39293: LD_INT 1
39295: PPUSH
39296: CALL_OW 325
39300: NOT
39301: OR
39302: PUSH
39303: LD_EXP 116
39307: PUSH
39308: LD_VAR 0 2
39312: ARRAY
39313: OR
39314: IFFALSE 39318
// continue ;
39316: GO 39235
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39318: LD_ADDR_VAR 0 8
39322: PUSH
39323: LD_EXP 93
39327: PUSH
39328: LD_VAR 0 2
39332: ARRAY
39333: PPUSH
39334: LD_INT 25
39336: PUSH
39337: LD_INT 4
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 50
39346: PUSH
39347: EMPTY
39348: LIST
39349: PUSH
39350: LD_INT 3
39352: PUSH
39353: LD_INT 60
39355: PUSH
39356: EMPTY
39357: LIST
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: LIST
39367: PPUSH
39368: CALL_OW 72
39372: PUSH
39373: LD_EXP 97
39377: PUSH
39378: LD_VAR 0 2
39382: ARRAY
39383: DIFF
39384: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39385: LD_ADDR_VAR 0 9
39389: PUSH
39390: LD_EXP 93
39394: PUSH
39395: LD_VAR 0 2
39399: ARRAY
39400: PPUSH
39401: LD_INT 2
39403: PUSH
39404: LD_INT 30
39406: PUSH
39407: LD_INT 0
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 30
39416: PUSH
39417: LD_INT 1
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: LIST
39428: PPUSH
39429: CALL_OW 72
39433: ST_TO_ADDR
// if not tmp or not dep then
39434: LD_VAR 0 8
39438: NOT
39439: PUSH
39440: LD_VAR 0 9
39444: NOT
39445: OR
39446: IFFALSE 39450
// continue ;
39448: GO 39235
// side := GetSide ( tmp [ 1 ] ) ;
39450: LD_ADDR_VAR 0 11
39454: PUSH
39455: LD_VAR 0 8
39459: PUSH
39460: LD_INT 1
39462: ARRAY
39463: PPUSH
39464: CALL_OW 255
39468: ST_TO_ADDR
// dep := dep [ 1 ] ;
39469: LD_ADDR_VAR 0 9
39473: PUSH
39474: LD_VAR 0 9
39478: PUSH
39479: LD_INT 1
39481: ARRAY
39482: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39483: LD_ADDR_VAR 0 7
39487: PUSH
39488: LD_EXP 121
39492: PUSH
39493: LD_VAR 0 2
39497: ARRAY
39498: PPUSH
39499: LD_INT 22
39501: PUSH
39502: LD_INT 0
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 25
39511: PUSH
39512: LD_INT 12
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PPUSH
39523: CALL_OW 70
39527: PUSH
39528: LD_INT 22
39530: PUSH
39531: LD_INT 0
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: PUSH
39538: LD_INT 25
39540: PUSH
39541: LD_INT 12
39543: PUSH
39544: EMPTY
39545: LIST
39546: LIST
39547: PUSH
39548: LD_INT 91
39550: PUSH
39551: LD_VAR 0 9
39555: PUSH
39556: LD_INT 20
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: LIST
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: LIST
39568: PPUSH
39569: CALL_OW 69
39573: UNION
39574: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39575: LD_ADDR_VAR 0 10
39579: PUSH
39580: LD_EXP 121
39584: PUSH
39585: LD_VAR 0 2
39589: ARRAY
39590: PPUSH
39591: LD_INT 81
39593: PUSH
39594: LD_VAR 0 11
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PPUSH
39603: CALL_OW 70
39607: ST_TO_ADDR
// if not apes or danger_at_area then
39608: LD_VAR 0 7
39612: NOT
39613: PUSH
39614: LD_VAR 0 10
39618: OR
39619: IFFALSE 39669
// begin if mc_taming [ i ] then
39621: LD_EXP 124
39625: PUSH
39626: LD_VAR 0 2
39630: ARRAY
39631: IFFALSE 39667
// begin MC_Reset ( i , 121 ) ;
39633: LD_VAR 0 2
39637: PPUSH
39638: LD_INT 121
39640: PPUSH
39641: CALL 24956 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39645: LD_ADDR_EXP 124
39649: PUSH
39650: LD_EXP 124
39654: PPUSH
39655: LD_VAR 0 2
39659: PPUSH
39660: EMPTY
39661: PPUSH
39662: CALL_OW 1
39666: ST_TO_ADDR
// end ; continue ;
39667: GO 39235
// end ; for j in tmp do
39669: LD_ADDR_VAR 0 3
39673: PUSH
39674: LD_VAR 0 8
39678: PUSH
39679: FOR_IN
39680: IFFALSE 40016
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39682: LD_VAR 0 3
39686: PUSH
39687: LD_EXP 124
39691: PUSH
39692: LD_VAR 0 2
39696: ARRAY
39697: IN
39698: NOT
39699: PUSH
39700: LD_EXP 124
39704: PUSH
39705: LD_VAR 0 2
39709: ARRAY
39710: PUSH
39711: LD_INT 3
39713: LESS
39714: AND
39715: IFFALSE 39773
// begin SetTag ( j , 121 ) ;
39717: LD_VAR 0 3
39721: PPUSH
39722: LD_INT 121
39724: PPUSH
39725: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39729: LD_ADDR_EXP 124
39733: PUSH
39734: LD_EXP 124
39738: PPUSH
39739: LD_VAR 0 2
39743: PUSH
39744: LD_EXP 124
39748: PUSH
39749: LD_VAR 0 2
39753: ARRAY
39754: PUSH
39755: LD_INT 1
39757: PLUS
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: PPUSH
39763: LD_VAR 0 3
39767: PPUSH
39768: CALL 56104 0 3
39772: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39773: LD_VAR 0 3
39777: PUSH
39778: LD_EXP 124
39782: PUSH
39783: LD_VAR 0 2
39787: ARRAY
39788: IN
39789: IFFALSE 40014
// begin if GetClass ( j ) <> 4 then
39791: LD_VAR 0 3
39795: PPUSH
39796: CALL_OW 257
39800: PUSH
39801: LD_INT 4
39803: NONEQUAL
39804: IFFALSE 39857
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39806: LD_ADDR_EXP 124
39810: PUSH
39811: LD_EXP 124
39815: PPUSH
39816: LD_VAR 0 2
39820: PPUSH
39821: LD_EXP 124
39825: PUSH
39826: LD_VAR 0 2
39830: ARRAY
39831: PUSH
39832: LD_VAR 0 3
39836: DIFF
39837: PPUSH
39838: CALL_OW 1
39842: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39843: LD_VAR 0 3
39847: PPUSH
39848: LD_INT 0
39850: PPUSH
39851: CALL_OW 109
// continue ;
39855: GO 39679
// end ; if IsInUnit ( j ) then
39857: LD_VAR 0 3
39861: PPUSH
39862: CALL_OW 310
39866: IFFALSE 39877
// ComExitBuilding ( j ) ;
39868: LD_VAR 0 3
39872: PPUSH
39873: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39877: LD_ADDR_VAR 0 6
39881: PUSH
39882: LD_VAR 0 7
39886: PPUSH
39887: LD_VAR 0 3
39891: PPUSH
39892: CALL_OW 74
39896: ST_TO_ADDR
// if not ape then
39897: LD_VAR 0 6
39901: NOT
39902: IFFALSE 39906
// break ;
39904: GO 40016
// x := GetX ( ape ) ;
39906: LD_ADDR_VAR 0 4
39910: PUSH
39911: LD_VAR 0 6
39915: PPUSH
39916: CALL_OW 250
39920: ST_TO_ADDR
// y := GetY ( ape ) ;
39921: LD_ADDR_VAR 0 5
39925: PUSH
39926: LD_VAR 0 6
39930: PPUSH
39931: CALL_OW 251
39935: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39936: LD_VAR 0 4
39940: PPUSH
39941: LD_VAR 0 5
39945: PPUSH
39946: CALL_OW 488
39950: NOT
39951: PUSH
39952: LD_VAR 0 11
39956: PPUSH
39957: LD_VAR 0 4
39961: PPUSH
39962: LD_VAR 0 5
39966: PPUSH
39967: LD_INT 20
39969: PPUSH
39970: CALL 57000 0 4
39974: PUSH
39975: LD_INT 4
39977: ARRAY
39978: OR
39979: IFFALSE 39983
// break ;
39981: GO 40016
// if not HasTask ( j ) then
39983: LD_VAR 0 3
39987: PPUSH
39988: CALL_OW 314
39992: NOT
39993: IFFALSE 40014
// ComTameXY ( j , x , y ) ;
39995: LD_VAR 0 3
39999: PPUSH
40000: LD_VAR 0 4
40004: PPUSH
40005: LD_VAR 0 5
40009: PPUSH
40010: CALL_OW 131
// end ; end ;
40014: GO 39679
40016: POP
40017: POP
// end ;
40018: GO 39235
40020: POP
40021: POP
// end ;
40022: LD_VAR 0 1
40026: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40027: LD_INT 0
40029: PPUSH
40030: PPUSH
40031: PPUSH
40032: PPUSH
40033: PPUSH
40034: PPUSH
40035: PPUSH
40036: PPUSH
// if not mc_bases then
40037: LD_EXP 93
40041: NOT
40042: IFFALSE 40046
// exit ;
40044: GO 40672
// for i = 1 to mc_bases do
40046: LD_ADDR_VAR 0 2
40050: PUSH
40051: DOUBLE
40052: LD_INT 1
40054: DEC
40055: ST_TO_ADDR
40056: LD_EXP 93
40060: PUSH
40061: FOR_TO
40062: IFFALSE 40670
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40064: LD_EXP 122
40068: PUSH
40069: LD_VAR 0 2
40073: ARRAY
40074: NOT
40075: PUSH
40076: LD_EXP 122
40080: PUSH
40081: LD_VAR 0 2
40085: ARRAY
40086: PPUSH
40087: LD_INT 25
40089: PUSH
40090: LD_INT 12
40092: PUSH
40093: EMPTY
40094: LIST
40095: LIST
40096: PPUSH
40097: CALL_OW 72
40101: NOT
40102: OR
40103: IFFALSE 40107
// continue ;
40105: GO 40061
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
40107: LD_ADDR_VAR 0 5
40111: PUSH
40112: LD_EXP 122
40116: PUSH
40117: LD_VAR 0 2
40121: ARRAY
40122: PUSH
40123: LD_INT 1
40125: ARRAY
40126: PPUSH
40127: CALL_OW 255
40131: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
40132: LD_VAR 0 5
40136: PPUSH
40137: LD_INT 2
40139: PPUSH
40140: CALL_OW 325
40144: IFFALSE 40397
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40146: LD_ADDR_VAR 0 4
40150: PUSH
40151: LD_EXP 122
40155: PUSH
40156: LD_VAR 0 2
40160: ARRAY
40161: PPUSH
40162: LD_INT 25
40164: PUSH
40165: LD_INT 16
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PPUSH
40172: CALL_OW 72
40176: ST_TO_ADDR
// if tmp < 6 then
40177: LD_VAR 0 4
40181: PUSH
40182: LD_INT 6
40184: LESS
40185: IFFALSE 40397
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40187: LD_ADDR_VAR 0 6
40191: PUSH
40192: LD_EXP 93
40196: PUSH
40197: LD_VAR 0 2
40201: ARRAY
40202: PPUSH
40203: LD_INT 2
40205: PUSH
40206: LD_INT 30
40208: PUSH
40209: LD_INT 0
40211: PUSH
40212: EMPTY
40213: LIST
40214: LIST
40215: PUSH
40216: LD_INT 30
40218: PUSH
40219: LD_INT 1
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: EMPTY
40227: LIST
40228: LIST
40229: LIST
40230: PPUSH
40231: CALL_OW 72
40235: ST_TO_ADDR
// if depot then
40236: LD_VAR 0 6
40240: IFFALSE 40397
// begin selected := 0 ;
40242: LD_ADDR_VAR 0 7
40246: PUSH
40247: LD_INT 0
40249: ST_TO_ADDR
// for j in depot do
40250: LD_ADDR_VAR 0 3
40254: PUSH
40255: LD_VAR 0 6
40259: PUSH
40260: FOR_IN
40261: IFFALSE 40292
// begin if UnitsInside ( j ) < 6 then
40263: LD_VAR 0 3
40267: PPUSH
40268: CALL_OW 313
40272: PUSH
40273: LD_INT 6
40275: LESS
40276: IFFALSE 40290
// begin selected := j ;
40278: LD_ADDR_VAR 0 7
40282: PUSH
40283: LD_VAR 0 3
40287: ST_TO_ADDR
// break ;
40288: GO 40292
// end ; end ;
40290: GO 40260
40292: POP
40293: POP
// if selected then
40294: LD_VAR 0 7
40298: IFFALSE 40397
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40300: LD_ADDR_VAR 0 3
40304: PUSH
40305: LD_EXP 122
40309: PUSH
40310: LD_VAR 0 2
40314: ARRAY
40315: PPUSH
40316: LD_INT 25
40318: PUSH
40319: LD_INT 12
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PPUSH
40326: CALL_OW 72
40330: PUSH
40331: FOR_IN
40332: IFFALSE 40395
// if not HasTask ( j ) then
40334: LD_VAR 0 3
40338: PPUSH
40339: CALL_OW 314
40343: NOT
40344: IFFALSE 40393
// begin if not IsInUnit ( j ) then
40346: LD_VAR 0 3
40350: PPUSH
40351: CALL_OW 310
40355: NOT
40356: IFFALSE 40372
// ComEnterUnit ( j , selected ) ;
40358: LD_VAR 0 3
40362: PPUSH
40363: LD_VAR 0 7
40367: PPUSH
40368: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40372: LD_VAR 0 3
40376: PPUSH
40377: LD_INT 16
40379: PPUSH
40380: CALL_OW 183
// AddComExitBuilding ( j ) ;
40384: LD_VAR 0 3
40388: PPUSH
40389: CALL_OW 182
// end ;
40393: GO 40331
40395: POP
40396: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40397: LD_VAR 0 5
40401: PPUSH
40402: LD_INT 11
40404: PPUSH
40405: CALL_OW 325
40409: IFFALSE 40668
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40411: LD_ADDR_VAR 0 4
40415: PUSH
40416: LD_EXP 122
40420: PUSH
40421: LD_VAR 0 2
40425: ARRAY
40426: PPUSH
40427: LD_INT 25
40429: PUSH
40430: LD_INT 16
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PPUSH
40437: CALL_OW 72
40441: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40442: LD_VAR 0 4
40446: PUSH
40447: LD_INT 6
40449: GREATEREQUAL
40450: PUSH
40451: LD_VAR 0 5
40455: PPUSH
40456: LD_INT 2
40458: PPUSH
40459: CALL_OW 325
40463: NOT
40464: OR
40465: IFFALSE 40668
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40467: LD_ADDR_VAR 0 8
40471: PUSH
40472: LD_EXP 93
40476: PUSH
40477: LD_VAR 0 2
40481: ARRAY
40482: PPUSH
40483: LD_INT 2
40485: PUSH
40486: LD_INT 30
40488: PUSH
40489: LD_INT 4
40491: PUSH
40492: EMPTY
40493: LIST
40494: LIST
40495: PUSH
40496: LD_INT 30
40498: PUSH
40499: LD_INT 5
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PUSH
40506: EMPTY
40507: LIST
40508: LIST
40509: LIST
40510: PPUSH
40511: CALL_OW 72
40515: ST_TO_ADDR
// if barracks then
40516: LD_VAR 0 8
40520: IFFALSE 40668
// begin selected := 0 ;
40522: LD_ADDR_VAR 0 7
40526: PUSH
40527: LD_INT 0
40529: ST_TO_ADDR
// for j in barracks do
40530: LD_ADDR_VAR 0 3
40534: PUSH
40535: LD_VAR 0 8
40539: PUSH
40540: FOR_IN
40541: IFFALSE 40572
// begin if UnitsInside ( j ) < 6 then
40543: LD_VAR 0 3
40547: PPUSH
40548: CALL_OW 313
40552: PUSH
40553: LD_INT 6
40555: LESS
40556: IFFALSE 40570
// begin selected := j ;
40558: LD_ADDR_VAR 0 7
40562: PUSH
40563: LD_VAR 0 3
40567: ST_TO_ADDR
// break ;
40568: GO 40572
// end ; end ;
40570: GO 40540
40572: POP
40573: POP
// if selected then
40574: LD_VAR 0 7
40578: IFFALSE 40668
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40580: LD_ADDR_VAR 0 3
40584: PUSH
40585: LD_EXP 122
40589: PUSH
40590: LD_VAR 0 2
40594: ARRAY
40595: PPUSH
40596: LD_INT 25
40598: PUSH
40599: LD_INT 12
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: PPUSH
40606: CALL_OW 72
40610: PUSH
40611: FOR_IN
40612: IFFALSE 40666
// if not IsInUnit ( j ) and not HasTask ( j ) then
40614: LD_VAR 0 3
40618: PPUSH
40619: CALL_OW 310
40623: NOT
40624: PUSH
40625: LD_VAR 0 3
40629: PPUSH
40630: CALL_OW 314
40634: NOT
40635: AND
40636: IFFALSE 40664
// begin ComEnterUnit ( j , selected ) ;
40638: LD_VAR 0 3
40642: PPUSH
40643: LD_VAR 0 7
40647: PPUSH
40648: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40652: LD_VAR 0 3
40656: PPUSH
40657: LD_INT 15
40659: PPUSH
40660: CALL_OW 183
// end ;
40664: GO 40611
40666: POP
40667: POP
// end ; end ; end ; end ; end ;
40668: GO 40061
40670: POP
40671: POP
// end ;
40672: LD_VAR 0 1
40676: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40677: LD_INT 0
40679: PPUSH
40680: PPUSH
40681: PPUSH
40682: PPUSH
// if not mc_bases then
40683: LD_EXP 93
40687: NOT
40688: IFFALSE 40692
// exit ;
40690: GO 40870
// for i = 1 to mc_bases do
40692: LD_ADDR_VAR 0 2
40696: PUSH
40697: DOUBLE
40698: LD_INT 1
40700: DEC
40701: ST_TO_ADDR
40702: LD_EXP 93
40706: PUSH
40707: FOR_TO
40708: IFFALSE 40868
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40710: LD_ADDR_VAR 0 4
40714: PUSH
40715: LD_EXP 93
40719: PUSH
40720: LD_VAR 0 2
40724: ARRAY
40725: PPUSH
40726: LD_INT 25
40728: PUSH
40729: LD_INT 9
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PPUSH
40736: CALL_OW 72
40740: ST_TO_ADDR
// if not tmp then
40741: LD_VAR 0 4
40745: NOT
40746: IFFALSE 40750
// continue ;
40748: GO 40707
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40750: LD_EXP 119
40754: PUSH
40755: LD_VAR 0 2
40759: ARRAY
40760: PPUSH
40761: LD_INT 29
40763: PPUSH
40764: CALL_OW 325
40768: NOT
40769: PUSH
40770: LD_EXP 119
40774: PUSH
40775: LD_VAR 0 2
40779: ARRAY
40780: PPUSH
40781: LD_INT 28
40783: PPUSH
40784: CALL_OW 325
40788: NOT
40789: AND
40790: IFFALSE 40794
// continue ;
40792: GO 40707
// for j in tmp do
40794: LD_ADDR_VAR 0 3
40798: PUSH
40799: LD_VAR 0 4
40803: PUSH
40804: FOR_IN
40805: IFFALSE 40864
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40807: LD_VAR 0 3
40811: PUSH
40812: LD_EXP 96
40816: PUSH
40817: LD_VAR 0 2
40821: ARRAY
40822: PUSH
40823: LD_INT 1
40825: ARRAY
40826: IN
40827: NOT
40828: PUSH
40829: LD_VAR 0 3
40833: PUSH
40834: LD_EXP 96
40838: PUSH
40839: LD_VAR 0 2
40843: ARRAY
40844: PUSH
40845: LD_INT 2
40847: ARRAY
40848: IN
40849: NOT
40850: AND
40851: IFFALSE 40862
// ComSpaceTimeShoot ( j ) ;
40853: LD_VAR 0 3
40857: PPUSH
40858: CALL 52065 0 1
40862: GO 40804
40864: POP
40865: POP
// end ;
40866: GO 40707
40868: POP
40869: POP
// end ;
40870: LD_VAR 0 1
40874: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40875: LD_INT 0
40877: PPUSH
40878: PPUSH
40879: PPUSH
40880: PPUSH
40881: PPUSH
40882: PPUSH
40883: PPUSH
40884: PPUSH
40885: PPUSH
// if not mc_bases then
40886: LD_EXP 93
40890: NOT
40891: IFFALSE 40895
// exit ;
40893: GO 41517
// for i = 1 to mc_bases do
40895: LD_ADDR_VAR 0 2
40899: PUSH
40900: DOUBLE
40901: LD_INT 1
40903: DEC
40904: ST_TO_ADDR
40905: LD_EXP 93
40909: PUSH
40910: FOR_TO
40911: IFFALSE 41515
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40913: LD_EXP 128
40917: PUSH
40918: LD_VAR 0 2
40922: ARRAY
40923: NOT
40924: PUSH
40925: LD_INT 38
40927: PPUSH
40928: LD_EXP 119
40932: PUSH
40933: LD_VAR 0 2
40937: ARRAY
40938: PPUSH
40939: CALL_OW 321
40943: PUSH
40944: LD_INT 2
40946: NONEQUAL
40947: OR
40948: IFFALSE 40952
// continue ;
40950: GO 40910
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40952: LD_ADDR_VAR 0 8
40956: PUSH
40957: LD_EXP 93
40961: PUSH
40962: LD_VAR 0 2
40966: ARRAY
40967: PPUSH
40968: LD_INT 30
40970: PUSH
40971: LD_INT 34
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PPUSH
40978: CALL_OW 72
40982: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40983: LD_ADDR_VAR 0 9
40987: PUSH
40988: LD_EXP 93
40992: PUSH
40993: LD_VAR 0 2
40997: ARRAY
40998: PPUSH
40999: LD_INT 25
41001: PUSH
41002: LD_INT 4
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PPUSH
41009: CALL_OW 72
41013: PPUSH
41014: LD_INT 0
41016: PPUSH
41017: CALL 85374 0 2
41021: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41022: LD_VAR 0 9
41026: NOT
41027: PUSH
41028: LD_VAR 0 8
41032: NOT
41033: OR
41034: PUSH
41035: LD_EXP 93
41039: PUSH
41040: LD_VAR 0 2
41044: ARRAY
41045: PPUSH
41046: LD_INT 124
41048: PPUSH
41049: CALL 85374 0 2
41053: OR
41054: IFFALSE 41058
// continue ;
41056: GO 40910
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41058: LD_EXP 129
41062: PUSH
41063: LD_VAR 0 2
41067: ARRAY
41068: PUSH
41069: LD_EXP 128
41073: PUSH
41074: LD_VAR 0 2
41078: ARRAY
41079: LESS
41080: PUSH
41081: LD_EXP 129
41085: PUSH
41086: LD_VAR 0 2
41090: ARRAY
41091: PUSH
41092: LD_VAR 0 8
41096: LESS
41097: AND
41098: IFFALSE 41513
// begin tmp := sci [ 1 ] ;
41100: LD_ADDR_VAR 0 7
41104: PUSH
41105: LD_VAR 0 9
41109: PUSH
41110: LD_INT 1
41112: ARRAY
41113: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
41114: LD_VAR 0 7
41118: PPUSH
41119: LD_INT 124
41121: PPUSH
41122: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
41126: LD_ADDR_VAR 0 3
41130: PUSH
41131: DOUBLE
41132: LD_EXP 128
41136: PUSH
41137: LD_VAR 0 2
41141: ARRAY
41142: INC
41143: ST_TO_ADDR
41144: LD_EXP 128
41148: PUSH
41149: LD_VAR 0 2
41153: ARRAY
41154: PUSH
41155: FOR_DOWNTO
41156: IFFALSE 41499
// begin if IsInUnit ( tmp ) then
41158: LD_VAR 0 7
41162: PPUSH
41163: CALL_OW 310
41167: IFFALSE 41178
// ComExitBuilding ( tmp ) ;
41169: LD_VAR 0 7
41173: PPUSH
41174: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
41178: LD_INT 35
41180: PPUSH
41181: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
41185: LD_VAR 0 7
41189: PPUSH
41190: CALL_OW 310
41194: NOT
41195: PUSH
41196: LD_VAR 0 7
41200: PPUSH
41201: CALL_OW 314
41205: NOT
41206: AND
41207: IFFALSE 41178
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
41209: LD_ADDR_VAR 0 6
41213: PUSH
41214: LD_VAR 0 7
41218: PPUSH
41219: CALL_OW 250
41223: PUSH
41224: LD_VAR 0 7
41228: PPUSH
41229: CALL_OW 251
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41238: LD_INT 35
41240: PPUSH
41241: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
41245: LD_ADDR_VAR 0 4
41249: PUSH
41250: LD_EXP 128
41254: PUSH
41255: LD_VAR 0 2
41259: ARRAY
41260: PUSH
41261: LD_VAR 0 3
41265: ARRAY
41266: PUSH
41267: LD_INT 1
41269: ARRAY
41270: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
41271: LD_ADDR_VAR 0 5
41275: PUSH
41276: LD_EXP 128
41280: PUSH
41281: LD_VAR 0 2
41285: ARRAY
41286: PUSH
41287: LD_VAR 0 3
41291: ARRAY
41292: PUSH
41293: LD_INT 2
41295: ARRAY
41296: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
41297: LD_VAR 0 7
41301: PPUSH
41302: LD_INT 10
41304: PPUSH
41305: CALL 58703 0 2
41309: PUSH
41310: LD_INT 4
41312: ARRAY
41313: IFFALSE 41351
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
41315: LD_VAR 0 7
41319: PPUSH
41320: LD_VAR 0 6
41324: PUSH
41325: LD_INT 1
41327: ARRAY
41328: PPUSH
41329: LD_VAR 0 6
41333: PUSH
41334: LD_INT 2
41336: ARRAY
41337: PPUSH
41338: CALL_OW 111
// wait ( 0 0$10 ) ;
41342: LD_INT 350
41344: PPUSH
41345: CALL_OW 67
// end else
41349: GO 41377
// begin ComMoveXY ( tmp , x , y ) ;
41351: LD_VAR 0 7
41355: PPUSH
41356: LD_VAR 0 4
41360: PPUSH
41361: LD_VAR 0 5
41365: PPUSH
41366: CALL_OW 111
// wait ( 0 0$3 ) ;
41370: LD_INT 105
41372: PPUSH
41373: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41377: LD_VAR 0 7
41381: PPUSH
41382: LD_VAR 0 4
41386: PPUSH
41387: LD_VAR 0 5
41391: PPUSH
41392: CALL_OW 307
41396: IFFALSE 41238
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41398: LD_VAR 0 7
41402: PPUSH
41403: LD_VAR 0 4
41407: PPUSH
41408: LD_VAR 0 5
41412: PPUSH
41413: LD_VAR 0 8
41417: PUSH
41418: LD_VAR 0 3
41422: ARRAY
41423: PPUSH
41424: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41428: LD_INT 35
41430: PPUSH
41431: CALL_OW 67
// until not HasTask ( tmp ) ;
41435: LD_VAR 0 7
41439: PPUSH
41440: CALL_OW 314
41444: NOT
41445: IFFALSE 41428
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41447: LD_ADDR_EXP 129
41451: PUSH
41452: LD_EXP 129
41456: PPUSH
41457: LD_VAR 0 2
41461: PUSH
41462: LD_EXP 129
41466: PUSH
41467: LD_VAR 0 2
41471: ARRAY
41472: PUSH
41473: LD_INT 1
41475: PLUS
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PPUSH
41481: LD_VAR 0 8
41485: PUSH
41486: LD_VAR 0 3
41490: ARRAY
41491: PPUSH
41492: CALL 56104 0 3
41496: ST_TO_ADDR
// end ;
41497: GO 41155
41499: POP
41500: POP
// MC_Reset ( i , 124 ) ;
41501: LD_VAR 0 2
41505: PPUSH
41506: LD_INT 124
41508: PPUSH
41509: CALL 24956 0 2
// end ; end ;
41513: GO 40910
41515: POP
41516: POP
// end ;
41517: LD_VAR 0 1
41521: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41522: LD_INT 0
41524: PPUSH
41525: PPUSH
41526: PPUSH
// if not mc_bases then
41527: LD_EXP 93
41531: NOT
41532: IFFALSE 41536
// exit ;
41534: GO 42142
// for i = 1 to mc_bases do
41536: LD_ADDR_VAR 0 2
41540: PUSH
41541: DOUBLE
41542: LD_INT 1
41544: DEC
41545: ST_TO_ADDR
41546: LD_EXP 93
41550: PUSH
41551: FOR_TO
41552: IFFALSE 42140
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41554: LD_ADDR_VAR 0 3
41558: PUSH
41559: LD_EXP 93
41563: PUSH
41564: LD_VAR 0 2
41568: ARRAY
41569: PPUSH
41570: LD_INT 25
41572: PUSH
41573: LD_INT 4
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PPUSH
41580: CALL_OW 72
41584: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41585: LD_VAR 0 3
41589: NOT
41590: PUSH
41591: LD_EXP 130
41595: PUSH
41596: LD_VAR 0 2
41600: ARRAY
41601: NOT
41602: OR
41603: PUSH
41604: LD_EXP 93
41608: PUSH
41609: LD_VAR 0 2
41613: ARRAY
41614: PPUSH
41615: LD_INT 2
41617: PUSH
41618: LD_INT 30
41620: PUSH
41621: LD_INT 0
41623: PUSH
41624: EMPTY
41625: LIST
41626: LIST
41627: PUSH
41628: LD_INT 30
41630: PUSH
41631: LD_INT 1
41633: PUSH
41634: EMPTY
41635: LIST
41636: LIST
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: LIST
41642: PPUSH
41643: CALL_OW 72
41647: NOT
41648: OR
41649: IFFALSE 41699
// begin if mc_deposits_finder [ i ] then
41651: LD_EXP 131
41655: PUSH
41656: LD_VAR 0 2
41660: ARRAY
41661: IFFALSE 41697
// begin MC_Reset ( i , 125 ) ;
41663: LD_VAR 0 2
41667: PPUSH
41668: LD_INT 125
41670: PPUSH
41671: CALL 24956 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41675: LD_ADDR_EXP 131
41679: PUSH
41680: LD_EXP 131
41684: PPUSH
41685: LD_VAR 0 2
41689: PPUSH
41690: EMPTY
41691: PPUSH
41692: CALL_OW 1
41696: ST_TO_ADDR
// end ; continue ;
41697: GO 41551
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41699: LD_EXP 130
41703: PUSH
41704: LD_VAR 0 2
41708: ARRAY
41709: PUSH
41710: LD_INT 1
41712: ARRAY
41713: PUSH
41714: LD_INT 3
41716: ARRAY
41717: PUSH
41718: LD_INT 1
41720: EQUAL
41721: PUSH
41722: LD_INT 20
41724: PPUSH
41725: LD_EXP 119
41729: PUSH
41730: LD_VAR 0 2
41734: ARRAY
41735: PPUSH
41736: CALL_OW 321
41740: PUSH
41741: LD_INT 2
41743: NONEQUAL
41744: AND
41745: IFFALSE 41795
// begin if mc_deposits_finder [ i ] then
41747: LD_EXP 131
41751: PUSH
41752: LD_VAR 0 2
41756: ARRAY
41757: IFFALSE 41793
// begin MC_Reset ( i , 125 ) ;
41759: LD_VAR 0 2
41763: PPUSH
41764: LD_INT 125
41766: PPUSH
41767: CALL 24956 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41771: LD_ADDR_EXP 131
41775: PUSH
41776: LD_EXP 131
41780: PPUSH
41781: LD_VAR 0 2
41785: PPUSH
41786: EMPTY
41787: PPUSH
41788: CALL_OW 1
41792: ST_TO_ADDR
// end ; continue ;
41793: GO 41551
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41795: LD_EXP 130
41799: PUSH
41800: LD_VAR 0 2
41804: ARRAY
41805: PUSH
41806: LD_INT 1
41808: ARRAY
41809: PUSH
41810: LD_INT 1
41812: ARRAY
41813: PPUSH
41814: LD_EXP 130
41818: PUSH
41819: LD_VAR 0 2
41823: ARRAY
41824: PUSH
41825: LD_INT 1
41827: ARRAY
41828: PUSH
41829: LD_INT 2
41831: ARRAY
41832: PPUSH
41833: LD_EXP 119
41837: PUSH
41838: LD_VAR 0 2
41842: ARRAY
41843: PPUSH
41844: CALL_OW 440
41848: IFFALSE 41891
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41850: LD_ADDR_EXP 130
41854: PUSH
41855: LD_EXP 130
41859: PPUSH
41860: LD_VAR 0 2
41864: PPUSH
41865: LD_EXP 130
41869: PUSH
41870: LD_VAR 0 2
41874: ARRAY
41875: PPUSH
41876: LD_INT 1
41878: PPUSH
41879: CALL_OW 3
41883: PPUSH
41884: CALL_OW 1
41888: ST_TO_ADDR
41889: GO 42138
// begin if not mc_deposits_finder [ i ] then
41891: LD_EXP 131
41895: PUSH
41896: LD_VAR 0 2
41900: ARRAY
41901: NOT
41902: IFFALSE 41954
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41904: LD_ADDR_EXP 131
41908: PUSH
41909: LD_EXP 131
41913: PPUSH
41914: LD_VAR 0 2
41918: PPUSH
41919: LD_VAR 0 3
41923: PUSH
41924: LD_INT 1
41926: ARRAY
41927: PUSH
41928: EMPTY
41929: LIST
41930: PPUSH
41931: CALL_OW 1
41935: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41936: LD_VAR 0 3
41940: PUSH
41941: LD_INT 1
41943: ARRAY
41944: PPUSH
41945: LD_INT 125
41947: PPUSH
41948: CALL_OW 109
// end else
41952: GO 42138
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41954: LD_EXP 131
41958: PUSH
41959: LD_VAR 0 2
41963: ARRAY
41964: PUSH
41965: LD_INT 1
41967: ARRAY
41968: PPUSH
41969: CALL_OW 310
41973: IFFALSE 41996
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41975: LD_EXP 131
41979: PUSH
41980: LD_VAR 0 2
41984: ARRAY
41985: PUSH
41986: LD_INT 1
41988: ARRAY
41989: PPUSH
41990: CALL_OW 122
41994: GO 42138
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41996: LD_EXP 131
42000: PUSH
42001: LD_VAR 0 2
42005: ARRAY
42006: PUSH
42007: LD_INT 1
42009: ARRAY
42010: PPUSH
42011: CALL_OW 314
42015: NOT
42016: PUSH
42017: LD_EXP 131
42021: PUSH
42022: LD_VAR 0 2
42026: ARRAY
42027: PUSH
42028: LD_INT 1
42030: ARRAY
42031: PPUSH
42032: LD_EXP 130
42036: PUSH
42037: LD_VAR 0 2
42041: ARRAY
42042: PUSH
42043: LD_INT 1
42045: ARRAY
42046: PUSH
42047: LD_INT 1
42049: ARRAY
42050: PPUSH
42051: LD_EXP 130
42055: PUSH
42056: LD_VAR 0 2
42060: ARRAY
42061: PUSH
42062: LD_INT 1
42064: ARRAY
42065: PUSH
42066: LD_INT 2
42068: ARRAY
42069: PPUSH
42070: CALL_OW 297
42074: PUSH
42075: LD_INT 6
42077: GREATER
42078: AND
42079: IFFALSE 42138
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42081: LD_EXP 131
42085: PUSH
42086: LD_VAR 0 2
42090: ARRAY
42091: PUSH
42092: LD_INT 1
42094: ARRAY
42095: PPUSH
42096: LD_EXP 130
42100: PUSH
42101: LD_VAR 0 2
42105: ARRAY
42106: PUSH
42107: LD_INT 1
42109: ARRAY
42110: PUSH
42111: LD_INT 1
42113: ARRAY
42114: PPUSH
42115: LD_EXP 130
42119: PUSH
42120: LD_VAR 0 2
42124: ARRAY
42125: PUSH
42126: LD_INT 1
42128: ARRAY
42129: PUSH
42130: LD_INT 2
42132: ARRAY
42133: PPUSH
42134: CALL_OW 111
// end ; end ; end ;
42138: GO 41551
42140: POP
42141: POP
// end ;
42142: LD_VAR 0 1
42146: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
42147: LD_INT 0
42149: PPUSH
42150: PPUSH
42151: PPUSH
42152: PPUSH
42153: PPUSH
42154: PPUSH
42155: PPUSH
42156: PPUSH
42157: PPUSH
42158: PPUSH
42159: PPUSH
// if not mc_bases then
42160: LD_EXP 93
42164: NOT
42165: IFFALSE 42169
// exit ;
42167: GO 43109
// for i = 1 to mc_bases do
42169: LD_ADDR_VAR 0 2
42173: PUSH
42174: DOUBLE
42175: LD_INT 1
42177: DEC
42178: ST_TO_ADDR
42179: LD_EXP 93
42183: PUSH
42184: FOR_TO
42185: IFFALSE 43107
// begin if not mc_bases [ i ] or mc_scan [ i ] then
42187: LD_EXP 93
42191: PUSH
42192: LD_VAR 0 2
42196: ARRAY
42197: NOT
42198: PUSH
42199: LD_EXP 116
42203: PUSH
42204: LD_VAR 0 2
42208: ARRAY
42209: OR
42210: IFFALSE 42214
// continue ;
42212: GO 42184
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
42214: LD_ADDR_VAR 0 7
42218: PUSH
42219: LD_EXP 93
42223: PUSH
42224: LD_VAR 0 2
42228: ARRAY
42229: PUSH
42230: LD_INT 1
42232: ARRAY
42233: PPUSH
42234: CALL_OW 248
42238: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
42239: LD_VAR 0 7
42243: PUSH
42244: LD_INT 3
42246: EQUAL
42247: PUSH
42248: LD_EXP 112
42252: PUSH
42253: LD_VAR 0 2
42257: ARRAY
42258: PUSH
42259: LD_EXP 115
42263: PUSH
42264: LD_VAR 0 2
42268: ARRAY
42269: UNION
42270: PPUSH
42271: LD_INT 33
42273: PUSH
42274: LD_INT 2
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: PPUSH
42281: CALL_OW 72
42285: NOT
42286: OR
42287: IFFALSE 42291
// continue ;
42289: GO 42184
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
42291: LD_ADDR_VAR 0 9
42295: PUSH
42296: LD_EXP 93
42300: PUSH
42301: LD_VAR 0 2
42305: ARRAY
42306: PPUSH
42307: LD_INT 30
42309: PUSH
42310: LD_INT 36
42312: PUSH
42313: EMPTY
42314: LIST
42315: LIST
42316: PPUSH
42317: CALL_OW 72
42321: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42322: LD_ADDR_VAR 0 10
42326: PUSH
42327: LD_EXP 112
42331: PUSH
42332: LD_VAR 0 2
42336: ARRAY
42337: PPUSH
42338: LD_INT 34
42340: PUSH
42341: LD_INT 31
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PPUSH
42348: CALL_OW 72
42352: ST_TO_ADDR
// if not cts and not mcts then
42353: LD_VAR 0 9
42357: NOT
42358: PUSH
42359: LD_VAR 0 10
42363: NOT
42364: AND
42365: IFFALSE 42369
// continue ;
42367: GO 42184
// x := cts ;
42369: LD_ADDR_VAR 0 11
42373: PUSH
42374: LD_VAR 0 9
42378: ST_TO_ADDR
// if not x then
42379: LD_VAR 0 11
42383: NOT
42384: IFFALSE 42396
// x := mcts ;
42386: LD_ADDR_VAR 0 11
42390: PUSH
42391: LD_VAR 0 10
42395: ST_TO_ADDR
// if not x then
42396: LD_VAR 0 11
42400: NOT
42401: IFFALSE 42405
// continue ;
42403: GO 42184
// if mc_remote_driver [ i ] then
42405: LD_EXP 133
42409: PUSH
42410: LD_VAR 0 2
42414: ARRAY
42415: IFFALSE 42802
// for j in mc_remote_driver [ i ] do
42417: LD_ADDR_VAR 0 3
42421: PUSH
42422: LD_EXP 133
42426: PUSH
42427: LD_VAR 0 2
42431: ARRAY
42432: PUSH
42433: FOR_IN
42434: IFFALSE 42800
// begin if GetClass ( j ) <> 3 then
42436: LD_VAR 0 3
42440: PPUSH
42441: CALL_OW 257
42445: PUSH
42446: LD_INT 3
42448: NONEQUAL
42449: IFFALSE 42502
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42451: LD_ADDR_EXP 133
42455: PUSH
42456: LD_EXP 133
42460: PPUSH
42461: LD_VAR 0 2
42465: PPUSH
42466: LD_EXP 133
42470: PUSH
42471: LD_VAR 0 2
42475: ARRAY
42476: PUSH
42477: LD_VAR 0 3
42481: DIFF
42482: PPUSH
42483: CALL_OW 1
42487: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42488: LD_VAR 0 3
42492: PPUSH
42493: LD_INT 0
42495: PPUSH
42496: CALL_OW 109
// continue ;
42500: GO 42433
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42502: LD_EXP 112
42506: PUSH
42507: LD_VAR 0 2
42511: ARRAY
42512: PPUSH
42513: LD_INT 34
42515: PUSH
42516: LD_INT 31
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 58
42525: PUSH
42526: EMPTY
42527: LIST
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: PPUSH
42533: CALL_OW 72
42537: PUSH
42538: LD_VAR 0 3
42542: PPUSH
42543: CALL 85462 0 1
42547: NOT
42548: AND
42549: IFFALSE 42620
// begin if IsInUnit ( j ) then
42551: LD_VAR 0 3
42555: PPUSH
42556: CALL_OW 310
42560: IFFALSE 42571
// ComExitBuilding ( j ) ;
42562: LD_VAR 0 3
42566: PPUSH
42567: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42571: LD_VAR 0 3
42575: PPUSH
42576: LD_EXP 112
42580: PUSH
42581: LD_VAR 0 2
42585: ARRAY
42586: PPUSH
42587: LD_INT 34
42589: PUSH
42590: LD_INT 31
42592: PUSH
42593: EMPTY
42594: LIST
42595: LIST
42596: PUSH
42597: LD_INT 58
42599: PUSH
42600: EMPTY
42601: LIST
42602: PUSH
42603: EMPTY
42604: LIST
42605: LIST
42606: PPUSH
42607: CALL_OW 72
42611: PUSH
42612: LD_INT 1
42614: ARRAY
42615: PPUSH
42616: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42620: LD_VAR 0 3
42624: PPUSH
42625: CALL_OW 310
42629: NOT
42630: PUSH
42631: LD_VAR 0 3
42635: PPUSH
42636: CALL_OW 310
42640: PPUSH
42641: CALL_OW 266
42645: PUSH
42646: LD_INT 36
42648: NONEQUAL
42649: PUSH
42650: LD_VAR 0 3
42654: PPUSH
42655: CALL 85462 0 1
42659: NOT
42660: AND
42661: OR
42662: IFFALSE 42798
// begin if IsInUnit ( j ) then
42664: LD_VAR 0 3
42668: PPUSH
42669: CALL_OW 310
42673: IFFALSE 42684
// ComExitBuilding ( j ) ;
42675: LD_VAR 0 3
42679: PPUSH
42680: CALL_OW 122
// ct := 0 ;
42684: LD_ADDR_VAR 0 8
42688: PUSH
42689: LD_INT 0
42691: ST_TO_ADDR
// for k in x do
42692: LD_ADDR_VAR 0 4
42696: PUSH
42697: LD_VAR 0 11
42701: PUSH
42702: FOR_IN
42703: IFFALSE 42776
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42705: LD_VAR 0 4
42709: PPUSH
42710: CALL_OW 264
42714: PUSH
42715: LD_INT 31
42717: EQUAL
42718: PUSH
42719: LD_VAR 0 4
42723: PPUSH
42724: CALL_OW 311
42728: NOT
42729: AND
42730: PUSH
42731: LD_VAR 0 4
42735: PPUSH
42736: CALL_OW 266
42740: PUSH
42741: LD_INT 36
42743: EQUAL
42744: PUSH
42745: LD_VAR 0 4
42749: PPUSH
42750: CALL_OW 313
42754: PUSH
42755: LD_INT 3
42757: LESS
42758: AND
42759: OR
42760: IFFALSE 42774
// begin ct := k ;
42762: LD_ADDR_VAR 0 8
42766: PUSH
42767: LD_VAR 0 4
42771: ST_TO_ADDR
// break ;
42772: GO 42776
// end ;
42774: GO 42702
42776: POP
42777: POP
// if ct then
42778: LD_VAR 0 8
42782: IFFALSE 42798
// ComEnterUnit ( j , ct ) ;
42784: LD_VAR 0 3
42788: PPUSH
42789: LD_VAR 0 8
42793: PPUSH
42794: CALL_OW 120
// end ; end ;
42798: GO 42433
42800: POP
42801: POP
// places := 0 ;
42802: LD_ADDR_VAR 0 5
42806: PUSH
42807: LD_INT 0
42809: ST_TO_ADDR
// for j = 1 to x do
42810: LD_ADDR_VAR 0 3
42814: PUSH
42815: DOUBLE
42816: LD_INT 1
42818: DEC
42819: ST_TO_ADDR
42820: LD_VAR 0 11
42824: PUSH
42825: FOR_TO
42826: IFFALSE 42902
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42828: LD_VAR 0 11
42832: PUSH
42833: LD_VAR 0 3
42837: ARRAY
42838: PPUSH
42839: CALL_OW 264
42843: PUSH
42844: LD_INT 31
42846: EQUAL
42847: IFFALSE 42865
// places := places + 1 else
42849: LD_ADDR_VAR 0 5
42853: PUSH
42854: LD_VAR 0 5
42858: PUSH
42859: LD_INT 1
42861: PLUS
42862: ST_TO_ADDR
42863: GO 42900
// if GetBType ( x [ j ] ) = b_control_tower then
42865: LD_VAR 0 11
42869: PUSH
42870: LD_VAR 0 3
42874: ARRAY
42875: PPUSH
42876: CALL_OW 266
42880: PUSH
42881: LD_INT 36
42883: EQUAL
42884: IFFALSE 42900
// places := places + 3 ;
42886: LD_ADDR_VAR 0 5
42890: PUSH
42891: LD_VAR 0 5
42895: PUSH
42896: LD_INT 3
42898: PLUS
42899: ST_TO_ADDR
42900: GO 42825
42902: POP
42903: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42904: LD_VAR 0 5
42908: PUSH
42909: LD_INT 0
42911: EQUAL
42912: PUSH
42913: LD_VAR 0 5
42917: PUSH
42918: LD_EXP 133
42922: PUSH
42923: LD_VAR 0 2
42927: ARRAY
42928: LESSEQUAL
42929: OR
42930: IFFALSE 42934
// continue ;
42932: GO 42184
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42934: LD_ADDR_VAR 0 6
42938: PUSH
42939: LD_EXP 93
42943: PUSH
42944: LD_VAR 0 2
42948: ARRAY
42949: PPUSH
42950: LD_INT 25
42952: PUSH
42953: LD_INT 3
42955: PUSH
42956: EMPTY
42957: LIST
42958: LIST
42959: PPUSH
42960: CALL_OW 72
42964: PUSH
42965: LD_EXP 133
42969: PUSH
42970: LD_VAR 0 2
42974: ARRAY
42975: DIFF
42976: PPUSH
42977: LD_INT 3
42979: PPUSH
42980: CALL 86362 0 2
42984: ST_TO_ADDR
// for j in tmp do
42985: LD_ADDR_VAR 0 3
42989: PUSH
42990: LD_VAR 0 6
42994: PUSH
42995: FOR_IN
42996: IFFALSE 43031
// if GetTag ( j ) > 0 then
42998: LD_VAR 0 3
43002: PPUSH
43003: CALL_OW 110
43007: PUSH
43008: LD_INT 0
43010: GREATER
43011: IFFALSE 43029
// tmp := tmp diff j ;
43013: LD_ADDR_VAR 0 6
43017: PUSH
43018: LD_VAR 0 6
43022: PUSH
43023: LD_VAR 0 3
43027: DIFF
43028: ST_TO_ADDR
43029: GO 42995
43031: POP
43032: POP
// if not tmp then
43033: LD_VAR 0 6
43037: NOT
43038: IFFALSE 43042
// continue ;
43040: GO 42184
// if places then
43042: LD_VAR 0 5
43046: IFFALSE 43105
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43048: LD_ADDR_EXP 133
43052: PUSH
43053: LD_EXP 133
43057: PPUSH
43058: LD_VAR 0 2
43062: PPUSH
43063: LD_EXP 133
43067: PUSH
43068: LD_VAR 0 2
43072: ARRAY
43073: PUSH
43074: LD_VAR 0 6
43078: PUSH
43079: LD_INT 1
43081: ARRAY
43082: UNION
43083: PPUSH
43084: CALL_OW 1
43088: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43089: LD_VAR 0 6
43093: PUSH
43094: LD_INT 1
43096: ARRAY
43097: PPUSH
43098: LD_INT 126
43100: PPUSH
43101: CALL_OW 109
// end ; end ;
43105: GO 42184
43107: POP
43108: POP
// end ;
43109: LD_VAR 0 1
43113: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
43114: LD_INT 0
43116: PPUSH
43117: PPUSH
43118: PPUSH
43119: PPUSH
43120: PPUSH
43121: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
43122: LD_VAR 0 1
43126: NOT
43127: PUSH
43128: LD_VAR 0 2
43132: NOT
43133: OR
43134: PUSH
43135: LD_VAR 0 3
43139: NOT
43140: OR
43141: PUSH
43142: LD_VAR 0 4
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: LD_INT 2
43152: PUSH
43153: LD_INT 3
43155: PUSH
43156: LD_INT 4
43158: PUSH
43159: LD_INT 5
43161: PUSH
43162: LD_INT 8
43164: PUSH
43165: LD_INT 9
43167: PUSH
43168: LD_INT 15
43170: PUSH
43171: LD_INT 16
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: IN
43185: NOT
43186: OR
43187: IFFALSE 43191
// exit ;
43189: GO 44091
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
43191: LD_ADDR_VAR 0 2
43195: PUSH
43196: LD_VAR 0 2
43200: PPUSH
43201: LD_INT 21
43203: PUSH
43204: LD_INT 3
43206: PUSH
43207: EMPTY
43208: LIST
43209: LIST
43210: PUSH
43211: LD_INT 24
43213: PUSH
43214: LD_INT 250
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: PPUSH
43225: CALL_OW 72
43229: ST_TO_ADDR
// case class of 1 , 15 :
43230: LD_VAR 0 4
43234: PUSH
43235: LD_INT 1
43237: DOUBLE
43238: EQUAL
43239: IFTRUE 43249
43241: LD_INT 15
43243: DOUBLE
43244: EQUAL
43245: IFTRUE 43249
43247: GO 43334
43249: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
43250: LD_ADDR_VAR 0 8
43254: PUSH
43255: LD_VAR 0 2
43259: PPUSH
43260: LD_INT 2
43262: PUSH
43263: LD_INT 30
43265: PUSH
43266: LD_INT 32
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: PUSH
43273: LD_INT 30
43275: PUSH
43276: LD_INT 31
43278: PUSH
43279: EMPTY
43280: LIST
43281: LIST
43282: PUSH
43283: EMPTY
43284: LIST
43285: LIST
43286: LIST
43287: PPUSH
43288: CALL_OW 72
43292: PUSH
43293: LD_VAR 0 2
43297: PPUSH
43298: LD_INT 2
43300: PUSH
43301: LD_INT 30
43303: PUSH
43304: LD_INT 4
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 30
43313: PUSH
43314: LD_INT 5
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: EMPTY
43322: LIST
43323: LIST
43324: LIST
43325: PPUSH
43326: CALL_OW 72
43330: ADD
43331: ST_TO_ADDR
43332: GO 43580
43334: LD_INT 2
43336: DOUBLE
43337: EQUAL
43338: IFTRUE 43348
43340: LD_INT 16
43342: DOUBLE
43343: EQUAL
43344: IFTRUE 43348
43346: GO 43394
43348: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43349: LD_ADDR_VAR 0 8
43353: PUSH
43354: LD_VAR 0 2
43358: PPUSH
43359: LD_INT 2
43361: PUSH
43362: LD_INT 30
43364: PUSH
43365: LD_INT 0
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 30
43374: PUSH
43375: LD_INT 1
43377: PUSH
43378: EMPTY
43379: LIST
43380: LIST
43381: PUSH
43382: EMPTY
43383: LIST
43384: LIST
43385: LIST
43386: PPUSH
43387: CALL_OW 72
43391: ST_TO_ADDR
43392: GO 43580
43394: LD_INT 3
43396: DOUBLE
43397: EQUAL
43398: IFTRUE 43402
43400: GO 43448
43402: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43403: LD_ADDR_VAR 0 8
43407: PUSH
43408: LD_VAR 0 2
43412: PPUSH
43413: LD_INT 2
43415: PUSH
43416: LD_INT 30
43418: PUSH
43419: LD_INT 2
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: PUSH
43426: LD_INT 30
43428: PUSH
43429: LD_INT 3
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: PUSH
43436: EMPTY
43437: LIST
43438: LIST
43439: LIST
43440: PPUSH
43441: CALL_OW 72
43445: ST_TO_ADDR
43446: GO 43580
43448: LD_INT 4
43450: DOUBLE
43451: EQUAL
43452: IFTRUE 43456
43454: GO 43513
43456: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43457: LD_ADDR_VAR 0 8
43461: PUSH
43462: LD_VAR 0 2
43466: PPUSH
43467: LD_INT 2
43469: PUSH
43470: LD_INT 30
43472: PUSH
43473: LD_INT 6
43475: PUSH
43476: EMPTY
43477: LIST
43478: LIST
43479: PUSH
43480: LD_INT 30
43482: PUSH
43483: LD_INT 7
43485: PUSH
43486: EMPTY
43487: LIST
43488: LIST
43489: PUSH
43490: LD_INT 30
43492: PUSH
43493: LD_INT 8
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: LIST
43504: LIST
43505: PPUSH
43506: CALL_OW 72
43510: ST_TO_ADDR
43511: GO 43580
43513: LD_INT 5
43515: DOUBLE
43516: EQUAL
43517: IFTRUE 43533
43519: LD_INT 8
43521: DOUBLE
43522: EQUAL
43523: IFTRUE 43533
43525: LD_INT 9
43527: DOUBLE
43528: EQUAL
43529: IFTRUE 43533
43531: GO 43579
43533: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43534: LD_ADDR_VAR 0 8
43538: PUSH
43539: LD_VAR 0 2
43543: PPUSH
43544: LD_INT 2
43546: PUSH
43547: LD_INT 30
43549: PUSH
43550: LD_INT 4
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: LD_INT 30
43559: PUSH
43560: LD_INT 5
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: EMPTY
43568: LIST
43569: LIST
43570: LIST
43571: PPUSH
43572: CALL_OW 72
43576: ST_TO_ADDR
43577: GO 43580
43579: POP
// if not tmp then
43580: LD_VAR 0 8
43584: NOT
43585: IFFALSE 43589
// exit ;
43587: GO 44091
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43589: LD_VAR 0 4
43593: PUSH
43594: LD_INT 1
43596: PUSH
43597: LD_INT 15
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: IN
43604: PUSH
43605: LD_EXP 102
43609: PUSH
43610: LD_VAR 0 1
43614: ARRAY
43615: AND
43616: IFFALSE 43772
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43618: LD_ADDR_VAR 0 9
43622: PUSH
43623: LD_EXP 102
43627: PUSH
43628: LD_VAR 0 1
43632: ARRAY
43633: PUSH
43634: LD_INT 1
43636: ARRAY
43637: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43638: LD_VAR 0 9
43642: PUSH
43643: LD_EXP 103
43647: PUSH
43648: LD_VAR 0 1
43652: ARRAY
43653: IN
43654: NOT
43655: IFFALSE 43770
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43657: LD_ADDR_EXP 103
43661: PUSH
43662: LD_EXP 103
43666: PPUSH
43667: LD_VAR 0 1
43671: PUSH
43672: LD_EXP 103
43676: PUSH
43677: LD_VAR 0 1
43681: ARRAY
43682: PUSH
43683: LD_INT 1
43685: PLUS
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PPUSH
43691: LD_VAR 0 9
43695: PPUSH
43696: CALL 56104 0 3
43700: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43701: LD_ADDR_EXP 102
43705: PUSH
43706: LD_EXP 102
43710: PPUSH
43711: LD_VAR 0 1
43715: PPUSH
43716: LD_EXP 102
43720: PUSH
43721: LD_VAR 0 1
43725: ARRAY
43726: PUSH
43727: LD_VAR 0 9
43731: DIFF
43732: PPUSH
43733: CALL_OW 1
43737: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43738: LD_VAR 0 3
43742: PPUSH
43743: LD_EXP 103
43747: PUSH
43748: LD_VAR 0 1
43752: ARRAY
43753: PUSH
43754: LD_EXP 103
43758: PUSH
43759: LD_VAR 0 1
43763: ARRAY
43764: ARRAY
43765: PPUSH
43766: CALL_OW 120
// end ; exit ;
43770: GO 44091
// end ; if tmp > 1 then
43772: LD_VAR 0 8
43776: PUSH
43777: LD_INT 1
43779: GREATER
43780: IFFALSE 43884
// for i = 2 to tmp do
43782: LD_ADDR_VAR 0 6
43786: PUSH
43787: DOUBLE
43788: LD_INT 2
43790: DEC
43791: ST_TO_ADDR
43792: LD_VAR 0 8
43796: PUSH
43797: FOR_TO
43798: IFFALSE 43882
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43800: LD_VAR 0 8
43804: PUSH
43805: LD_VAR 0 6
43809: ARRAY
43810: PPUSH
43811: CALL_OW 461
43815: PUSH
43816: LD_INT 6
43818: EQUAL
43819: IFFALSE 43880
// begin x := tmp [ i ] ;
43821: LD_ADDR_VAR 0 9
43825: PUSH
43826: LD_VAR 0 8
43830: PUSH
43831: LD_VAR 0 6
43835: ARRAY
43836: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43837: LD_ADDR_VAR 0 8
43841: PUSH
43842: LD_VAR 0 8
43846: PPUSH
43847: LD_VAR 0 6
43851: PPUSH
43852: CALL_OW 3
43856: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43857: LD_ADDR_VAR 0 8
43861: PUSH
43862: LD_VAR 0 8
43866: PPUSH
43867: LD_INT 1
43869: PPUSH
43870: LD_VAR 0 9
43874: PPUSH
43875: CALL_OW 2
43879: ST_TO_ADDR
// end ;
43880: GO 43797
43882: POP
43883: POP
// for i in tmp do
43884: LD_ADDR_VAR 0 6
43888: PUSH
43889: LD_VAR 0 8
43893: PUSH
43894: FOR_IN
43895: IFFALSE 43964
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43897: LD_VAR 0 6
43901: PPUSH
43902: CALL_OW 313
43906: PUSH
43907: LD_INT 6
43909: LESS
43910: PUSH
43911: LD_VAR 0 6
43915: PPUSH
43916: CALL_OW 266
43920: PUSH
43921: LD_INT 31
43923: PUSH
43924: LD_INT 32
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: IN
43931: NOT
43932: AND
43933: PUSH
43934: LD_VAR 0 6
43938: PPUSH
43939: CALL_OW 313
43943: PUSH
43944: LD_INT 0
43946: EQUAL
43947: OR
43948: IFFALSE 43962
// begin j := i ;
43950: LD_ADDR_VAR 0 7
43954: PUSH
43955: LD_VAR 0 6
43959: ST_TO_ADDR
// break ;
43960: GO 43964
// end ; end ;
43962: GO 43894
43964: POP
43965: POP
// if j then
43966: LD_VAR 0 7
43970: IFFALSE 43988
// ComEnterUnit ( unit , j ) else
43972: LD_VAR 0 3
43976: PPUSH
43977: LD_VAR 0 7
43981: PPUSH
43982: CALL_OW 120
43986: GO 44091
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43988: LD_ADDR_VAR 0 10
43992: PUSH
43993: LD_VAR 0 2
43997: PPUSH
43998: LD_INT 2
44000: PUSH
44001: LD_INT 30
44003: PUSH
44004: LD_INT 0
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 30
44013: PUSH
44014: LD_INT 1
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: LIST
44025: PPUSH
44026: CALL_OW 72
44030: ST_TO_ADDR
// if depot then
44031: LD_VAR 0 10
44035: IFFALSE 44091
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44037: LD_ADDR_VAR 0 10
44041: PUSH
44042: LD_VAR 0 10
44046: PPUSH
44047: LD_VAR 0 3
44051: PPUSH
44052: CALL_OW 74
44056: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44057: LD_VAR 0 3
44061: PPUSH
44062: LD_VAR 0 10
44066: PPUSH
44067: CALL_OW 296
44071: PUSH
44072: LD_INT 10
44074: GREATER
44075: IFFALSE 44091
// ComStandNearbyBuilding ( unit , depot ) ;
44077: LD_VAR 0 3
44081: PPUSH
44082: LD_VAR 0 10
44086: PPUSH
44087: CALL 52682 0 2
// end ; end ; end ;
44091: LD_VAR 0 5
44095: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44096: LD_INT 0
44098: PPUSH
44099: PPUSH
44100: PPUSH
44101: PPUSH
// if not mc_bases then
44102: LD_EXP 93
44106: NOT
44107: IFFALSE 44111
// exit ;
44109: GO 44350
// for i = 1 to mc_bases do
44111: LD_ADDR_VAR 0 2
44115: PUSH
44116: DOUBLE
44117: LD_INT 1
44119: DEC
44120: ST_TO_ADDR
44121: LD_EXP 93
44125: PUSH
44126: FOR_TO
44127: IFFALSE 44348
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
44129: LD_ADDR_VAR 0 4
44133: PUSH
44134: LD_EXP 93
44138: PUSH
44139: LD_VAR 0 2
44143: ARRAY
44144: PPUSH
44145: LD_INT 21
44147: PUSH
44148: LD_INT 1
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PPUSH
44155: CALL_OW 72
44159: PUSH
44160: LD_EXP 122
44164: PUSH
44165: LD_VAR 0 2
44169: ARRAY
44170: UNION
44171: ST_TO_ADDR
// if not tmp then
44172: LD_VAR 0 4
44176: NOT
44177: IFFALSE 44181
// continue ;
44179: GO 44126
// for j in tmp do
44181: LD_ADDR_VAR 0 3
44185: PUSH
44186: LD_VAR 0 4
44190: PUSH
44191: FOR_IN
44192: IFFALSE 44344
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
44194: LD_VAR 0 3
44198: PPUSH
44199: CALL_OW 110
44203: NOT
44204: PUSH
44205: LD_VAR 0 3
44209: PPUSH
44210: CALL_OW 314
44214: NOT
44215: AND
44216: PUSH
44217: LD_VAR 0 3
44221: PPUSH
44222: CALL_OW 311
44226: NOT
44227: AND
44228: PUSH
44229: LD_VAR 0 3
44233: PPUSH
44234: CALL_OW 310
44238: NOT
44239: AND
44240: PUSH
44241: LD_VAR 0 3
44245: PUSH
44246: LD_EXP 96
44250: PUSH
44251: LD_VAR 0 2
44255: ARRAY
44256: PUSH
44257: LD_INT 1
44259: ARRAY
44260: IN
44261: NOT
44262: AND
44263: PUSH
44264: LD_VAR 0 3
44268: PUSH
44269: LD_EXP 96
44273: PUSH
44274: LD_VAR 0 2
44278: ARRAY
44279: PUSH
44280: LD_INT 2
44282: ARRAY
44283: IN
44284: NOT
44285: AND
44286: PUSH
44287: LD_VAR 0 3
44291: PUSH
44292: LD_EXP 105
44296: PUSH
44297: LD_VAR 0 2
44301: ARRAY
44302: IN
44303: NOT
44304: AND
44305: IFFALSE 44342
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
44307: LD_VAR 0 2
44311: PPUSH
44312: LD_EXP 93
44316: PUSH
44317: LD_VAR 0 2
44321: ARRAY
44322: PPUSH
44323: LD_VAR 0 3
44327: PPUSH
44328: LD_VAR 0 3
44332: PPUSH
44333: CALL_OW 257
44337: PPUSH
44338: CALL 43114 0 4
// end ;
44342: GO 44191
44344: POP
44345: POP
// end ;
44346: GO 44126
44348: POP
44349: POP
// end ;
44350: LD_VAR 0 1
44354: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44355: LD_INT 0
44357: PPUSH
44358: PPUSH
44359: PPUSH
44360: PPUSH
44361: PPUSH
44362: PPUSH
// if not mc_bases [ base ] then
44363: LD_EXP 93
44367: PUSH
44368: LD_VAR 0 1
44372: ARRAY
44373: NOT
44374: IFFALSE 44378
// exit ;
44376: GO 44560
// tmp := [ ] ;
44378: LD_ADDR_VAR 0 6
44382: PUSH
44383: EMPTY
44384: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44385: LD_ADDR_VAR 0 7
44389: PUSH
44390: LD_VAR 0 3
44394: PPUSH
44395: LD_INT 0
44397: PPUSH
44398: CALL_OW 517
44402: ST_TO_ADDR
// if not list then
44403: LD_VAR 0 7
44407: NOT
44408: IFFALSE 44412
// exit ;
44410: GO 44560
// for i = 1 to amount do
44412: LD_ADDR_VAR 0 5
44416: PUSH
44417: DOUBLE
44418: LD_INT 1
44420: DEC
44421: ST_TO_ADDR
44422: LD_VAR 0 2
44426: PUSH
44427: FOR_TO
44428: IFFALSE 44508
// begin x := rand ( 1 , list [ 1 ] ) ;
44430: LD_ADDR_VAR 0 8
44434: PUSH
44435: LD_INT 1
44437: PPUSH
44438: LD_VAR 0 7
44442: PUSH
44443: LD_INT 1
44445: ARRAY
44446: PPUSH
44447: CALL_OW 12
44451: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44452: LD_ADDR_VAR 0 6
44456: PUSH
44457: LD_VAR 0 6
44461: PPUSH
44462: LD_VAR 0 5
44466: PPUSH
44467: LD_VAR 0 7
44471: PUSH
44472: LD_INT 1
44474: ARRAY
44475: PUSH
44476: LD_VAR 0 8
44480: ARRAY
44481: PUSH
44482: LD_VAR 0 7
44486: PUSH
44487: LD_INT 2
44489: ARRAY
44490: PUSH
44491: LD_VAR 0 8
44495: ARRAY
44496: PUSH
44497: EMPTY
44498: LIST
44499: LIST
44500: PPUSH
44501: CALL_OW 1
44505: ST_TO_ADDR
// end ;
44506: GO 44427
44508: POP
44509: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44510: LD_ADDR_EXP 106
44514: PUSH
44515: LD_EXP 106
44519: PPUSH
44520: LD_VAR 0 1
44524: PPUSH
44525: LD_VAR 0 6
44529: PPUSH
44530: CALL_OW 1
44534: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44535: LD_ADDR_EXP 108
44539: PUSH
44540: LD_EXP 108
44544: PPUSH
44545: LD_VAR 0 1
44549: PPUSH
44550: LD_VAR 0 3
44554: PPUSH
44555: CALL_OW 1
44559: ST_TO_ADDR
// end ;
44560: LD_VAR 0 4
44564: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44565: LD_INT 0
44567: PPUSH
// if not mc_bases [ base ] then
44568: LD_EXP 93
44572: PUSH
44573: LD_VAR 0 1
44577: ARRAY
44578: NOT
44579: IFFALSE 44583
// exit ;
44581: GO 44608
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44583: LD_ADDR_EXP 98
44587: PUSH
44588: LD_EXP 98
44592: PPUSH
44593: LD_VAR 0 1
44597: PPUSH
44598: LD_VAR 0 2
44602: PPUSH
44603: CALL_OW 1
44607: ST_TO_ADDR
// end ;
44608: LD_VAR 0 3
44612: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44613: LD_INT 0
44615: PPUSH
// if not mc_bases [ base ] then
44616: LD_EXP 93
44620: PUSH
44621: LD_VAR 0 1
44625: ARRAY
44626: NOT
44627: IFFALSE 44631
// exit ;
44629: GO 44668
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44631: LD_ADDR_EXP 98
44635: PUSH
44636: LD_EXP 98
44640: PPUSH
44641: LD_VAR 0 1
44645: PPUSH
44646: LD_EXP 98
44650: PUSH
44651: LD_VAR 0 1
44655: ARRAY
44656: PUSH
44657: LD_VAR 0 2
44661: UNION
44662: PPUSH
44663: CALL_OW 1
44667: ST_TO_ADDR
// end ;
44668: LD_VAR 0 3
44672: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44673: LD_INT 0
44675: PPUSH
// if not mc_bases [ base ] then
44676: LD_EXP 93
44680: PUSH
44681: LD_VAR 0 1
44685: ARRAY
44686: NOT
44687: IFFALSE 44691
// exit ;
44689: GO 44716
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44691: LD_ADDR_EXP 114
44695: PUSH
44696: LD_EXP 114
44700: PPUSH
44701: LD_VAR 0 1
44705: PPUSH
44706: LD_VAR 0 2
44710: PPUSH
44711: CALL_OW 1
44715: ST_TO_ADDR
// end ;
44716: LD_VAR 0 3
44720: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44721: LD_INT 0
44723: PPUSH
// if not mc_bases [ base ] then
44724: LD_EXP 93
44728: PUSH
44729: LD_VAR 0 1
44733: ARRAY
44734: NOT
44735: IFFALSE 44739
// exit ;
44737: GO 44776
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44739: LD_ADDR_EXP 114
44743: PUSH
44744: LD_EXP 114
44748: PPUSH
44749: LD_VAR 0 1
44753: PPUSH
44754: LD_EXP 114
44758: PUSH
44759: LD_VAR 0 1
44763: ARRAY
44764: PUSH
44765: LD_VAR 0 2
44769: ADD
44770: PPUSH
44771: CALL_OW 1
44775: ST_TO_ADDR
// end ;
44776: LD_VAR 0 3
44780: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44781: LD_INT 0
44783: PPUSH
// if not mc_bases [ base ] then
44784: LD_EXP 93
44788: PUSH
44789: LD_VAR 0 1
44793: ARRAY
44794: NOT
44795: IFFALSE 44799
// exit ;
44797: GO 44853
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44799: LD_ADDR_EXP 115
44803: PUSH
44804: LD_EXP 115
44808: PPUSH
44809: LD_VAR 0 1
44813: PPUSH
44814: LD_VAR 0 2
44818: PPUSH
44819: CALL_OW 1
44823: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44824: LD_ADDR_EXP 104
44828: PUSH
44829: LD_EXP 104
44833: PPUSH
44834: LD_VAR 0 1
44838: PPUSH
44839: LD_VAR 0 2
44843: PUSH
44844: LD_INT 0
44846: PLUS
44847: PPUSH
44848: CALL_OW 1
44852: ST_TO_ADDR
// end ;
44853: LD_VAR 0 3
44857: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44858: LD_INT 0
44860: PPUSH
// if not mc_bases [ base ] then
44861: LD_EXP 93
44865: PUSH
44866: LD_VAR 0 1
44870: ARRAY
44871: NOT
44872: IFFALSE 44876
// exit ;
44874: GO 44901
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44876: LD_ADDR_EXP 104
44880: PUSH
44881: LD_EXP 104
44885: PPUSH
44886: LD_VAR 0 1
44890: PPUSH
44891: LD_VAR 0 2
44895: PPUSH
44896: CALL_OW 1
44900: ST_TO_ADDR
// end ;
44901: LD_VAR 0 3
44905: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44906: LD_INT 0
44908: PPUSH
44909: PPUSH
44910: PPUSH
44911: PPUSH
// if not mc_bases [ base ] then
44912: LD_EXP 93
44916: PUSH
44917: LD_VAR 0 1
44921: ARRAY
44922: NOT
44923: IFFALSE 44927
// exit ;
44925: GO 44992
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44927: LD_ADDR_EXP 113
44931: PUSH
44932: LD_EXP 113
44936: PPUSH
44937: LD_VAR 0 1
44941: PUSH
44942: LD_EXP 113
44946: PUSH
44947: LD_VAR 0 1
44951: ARRAY
44952: PUSH
44953: LD_INT 1
44955: PLUS
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: PPUSH
44961: LD_VAR 0 1
44965: PUSH
44966: LD_VAR 0 2
44970: PUSH
44971: LD_VAR 0 3
44975: PUSH
44976: LD_VAR 0 4
44980: PUSH
44981: EMPTY
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: PPUSH
44987: CALL 56104 0 3
44991: ST_TO_ADDR
// end ;
44992: LD_VAR 0 5
44996: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44997: LD_INT 0
44999: PPUSH
// if not mc_bases [ base ] then
45000: LD_EXP 93
45004: PUSH
45005: LD_VAR 0 1
45009: ARRAY
45010: NOT
45011: IFFALSE 45015
// exit ;
45013: GO 45040
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45015: LD_ADDR_EXP 130
45019: PUSH
45020: LD_EXP 130
45024: PPUSH
45025: LD_VAR 0 1
45029: PPUSH
45030: LD_VAR 0 2
45034: PPUSH
45035: CALL_OW 1
45039: ST_TO_ADDR
// end ;
45040: LD_VAR 0 3
45044: RET
// export function MC_GetMinesField ( base ) ; begin
45045: LD_INT 0
45047: PPUSH
// result := mc_mines [ base ] ;
45048: LD_ADDR_VAR 0 2
45052: PUSH
45053: LD_EXP 106
45057: PUSH
45058: LD_VAR 0 1
45062: ARRAY
45063: ST_TO_ADDR
// end ;
45064: LD_VAR 0 2
45068: RET
// export function MC_GetProduceList ( base ) ; begin
45069: LD_INT 0
45071: PPUSH
// result := mc_produce [ base ] ;
45072: LD_ADDR_VAR 0 2
45076: PUSH
45077: LD_EXP 114
45081: PUSH
45082: LD_VAR 0 1
45086: ARRAY
45087: ST_TO_ADDR
// end ;
45088: LD_VAR 0 2
45092: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45093: LD_INT 0
45095: PPUSH
45096: PPUSH
// if not mc_bases then
45097: LD_EXP 93
45101: NOT
45102: IFFALSE 45106
// exit ;
45104: GO 45171
// if mc_bases [ base ] then
45106: LD_EXP 93
45110: PUSH
45111: LD_VAR 0 1
45115: ARRAY
45116: IFFALSE 45171
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45118: LD_ADDR_VAR 0 3
45122: PUSH
45123: LD_EXP 93
45127: PUSH
45128: LD_VAR 0 1
45132: ARRAY
45133: PPUSH
45134: LD_INT 30
45136: PUSH
45137: LD_VAR 0 2
45141: PUSH
45142: EMPTY
45143: LIST
45144: LIST
45145: PPUSH
45146: CALL_OW 72
45150: ST_TO_ADDR
// if result then
45151: LD_VAR 0 3
45155: IFFALSE 45171
// result := result [ 1 ] ;
45157: LD_ADDR_VAR 0 3
45161: PUSH
45162: LD_VAR 0 3
45166: PUSH
45167: LD_INT 1
45169: ARRAY
45170: ST_TO_ADDR
// end ; end ;
45171: LD_VAR 0 3
45175: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
45176: LD_INT 0
45178: PPUSH
45179: PPUSH
// if not mc_bases then
45180: LD_EXP 93
45184: NOT
45185: IFFALSE 45189
// exit ;
45187: GO 45234
// if mc_bases [ base ] then
45189: LD_EXP 93
45193: PUSH
45194: LD_VAR 0 1
45198: ARRAY
45199: IFFALSE 45234
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45201: LD_ADDR_VAR 0 3
45205: PUSH
45206: LD_EXP 93
45210: PUSH
45211: LD_VAR 0 1
45215: ARRAY
45216: PPUSH
45217: LD_INT 30
45219: PUSH
45220: LD_VAR 0 2
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PPUSH
45229: CALL_OW 72
45233: ST_TO_ADDR
// end ;
45234: LD_VAR 0 3
45238: RET
// export function MC_SetTame ( base , area ) ; begin
45239: LD_INT 0
45241: PPUSH
// if not mc_bases or not base then
45242: LD_EXP 93
45246: NOT
45247: PUSH
45248: LD_VAR 0 1
45252: NOT
45253: OR
45254: IFFALSE 45258
// exit ;
45256: GO 45283
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
45258: LD_ADDR_EXP 121
45262: PUSH
45263: LD_EXP 121
45267: PPUSH
45268: LD_VAR 0 1
45272: PPUSH
45273: LD_VAR 0 2
45277: PPUSH
45278: CALL_OW 1
45282: ST_TO_ADDR
// end ;
45283: LD_VAR 0 3
45287: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
45288: LD_INT 0
45290: PPUSH
45291: PPUSH
// if not mc_bases or not base then
45292: LD_EXP 93
45296: NOT
45297: PUSH
45298: LD_VAR 0 1
45302: NOT
45303: OR
45304: IFFALSE 45308
// exit ;
45306: GO 45410
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45308: LD_ADDR_VAR 0 4
45312: PUSH
45313: LD_EXP 93
45317: PUSH
45318: LD_VAR 0 1
45322: ARRAY
45323: PPUSH
45324: LD_INT 30
45326: PUSH
45327: LD_VAR 0 2
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PPUSH
45336: CALL_OW 72
45340: ST_TO_ADDR
// if not tmp then
45341: LD_VAR 0 4
45345: NOT
45346: IFFALSE 45350
// exit ;
45348: GO 45410
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45350: LD_ADDR_EXP 125
45354: PUSH
45355: LD_EXP 125
45359: PPUSH
45360: LD_VAR 0 1
45364: PPUSH
45365: LD_EXP 125
45369: PUSH
45370: LD_VAR 0 1
45374: ARRAY
45375: PPUSH
45376: LD_EXP 125
45380: PUSH
45381: LD_VAR 0 1
45385: ARRAY
45386: PUSH
45387: LD_INT 1
45389: PLUS
45390: PPUSH
45391: LD_VAR 0 4
45395: PUSH
45396: LD_INT 1
45398: ARRAY
45399: PPUSH
45400: CALL_OW 2
45404: PPUSH
45405: CALL_OW 1
45409: ST_TO_ADDR
// end ;
45410: LD_VAR 0 3
45414: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45415: LD_INT 0
45417: PPUSH
45418: PPUSH
// if not mc_bases or not base or not kinds then
45419: LD_EXP 93
45423: NOT
45424: PUSH
45425: LD_VAR 0 1
45429: NOT
45430: OR
45431: PUSH
45432: LD_VAR 0 2
45436: NOT
45437: OR
45438: IFFALSE 45442
// exit ;
45440: GO 45503
// for i in kinds do
45442: LD_ADDR_VAR 0 4
45446: PUSH
45447: LD_VAR 0 2
45451: PUSH
45452: FOR_IN
45453: IFFALSE 45501
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45455: LD_ADDR_EXP 127
45459: PUSH
45460: LD_EXP 127
45464: PPUSH
45465: LD_VAR 0 1
45469: PUSH
45470: LD_EXP 127
45474: PUSH
45475: LD_VAR 0 1
45479: ARRAY
45480: PUSH
45481: LD_INT 1
45483: PLUS
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: PPUSH
45489: LD_VAR 0 4
45493: PPUSH
45494: CALL 56104 0 3
45498: ST_TO_ADDR
45499: GO 45452
45501: POP
45502: POP
// end ;
45503: LD_VAR 0 3
45507: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45508: LD_INT 0
45510: PPUSH
// if not mc_bases or not base or not areas then
45511: LD_EXP 93
45515: NOT
45516: PUSH
45517: LD_VAR 0 1
45521: NOT
45522: OR
45523: PUSH
45524: LD_VAR 0 2
45528: NOT
45529: OR
45530: IFFALSE 45534
// exit ;
45532: GO 45559
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45534: LD_ADDR_EXP 111
45538: PUSH
45539: LD_EXP 111
45543: PPUSH
45544: LD_VAR 0 1
45548: PPUSH
45549: LD_VAR 0 2
45553: PPUSH
45554: CALL_OW 1
45558: ST_TO_ADDR
// end ;
45559: LD_VAR 0 3
45563: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45564: LD_INT 0
45566: PPUSH
// if not mc_bases or not base or not teleports_exit then
45567: LD_EXP 93
45571: NOT
45572: PUSH
45573: LD_VAR 0 1
45577: NOT
45578: OR
45579: PUSH
45580: LD_VAR 0 2
45584: NOT
45585: OR
45586: IFFALSE 45590
// exit ;
45588: GO 45615
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45590: LD_ADDR_EXP 128
45594: PUSH
45595: LD_EXP 128
45599: PPUSH
45600: LD_VAR 0 1
45604: PPUSH
45605: LD_VAR 0 2
45609: PPUSH
45610: CALL_OW 1
45614: ST_TO_ADDR
// end ;
45615: LD_VAR 0 3
45619: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45620: LD_INT 0
45622: PPUSH
45623: PPUSH
45624: PPUSH
// if not mc_bases or not base or not ext_list then
45625: LD_EXP 93
45629: NOT
45630: PUSH
45631: LD_VAR 0 1
45635: NOT
45636: OR
45637: PUSH
45638: LD_VAR 0 5
45642: NOT
45643: OR
45644: IFFALSE 45648
// exit ;
45646: GO 45821
// tmp := GetFacExtXYD ( x , y , d ) ;
45648: LD_ADDR_VAR 0 8
45652: PUSH
45653: LD_VAR 0 2
45657: PPUSH
45658: LD_VAR 0 3
45662: PPUSH
45663: LD_VAR 0 4
45667: PPUSH
45668: CALL 85492 0 3
45672: ST_TO_ADDR
// if not tmp then
45673: LD_VAR 0 8
45677: NOT
45678: IFFALSE 45682
// exit ;
45680: GO 45821
// for i in tmp do
45682: LD_ADDR_VAR 0 7
45686: PUSH
45687: LD_VAR 0 8
45691: PUSH
45692: FOR_IN
45693: IFFALSE 45819
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45695: LD_ADDR_EXP 98
45699: PUSH
45700: LD_EXP 98
45704: PPUSH
45705: LD_VAR 0 1
45709: PPUSH
45710: LD_EXP 98
45714: PUSH
45715: LD_VAR 0 1
45719: ARRAY
45720: PPUSH
45721: LD_EXP 98
45725: PUSH
45726: LD_VAR 0 1
45730: ARRAY
45731: PUSH
45732: LD_INT 1
45734: PLUS
45735: PPUSH
45736: LD_VAR 0 5
45740: PUSH
45741: LD_INT 1
45743: ARRAY
45744: PUSH
45745: LD_VAR 0 7
45749: PUSH
45750: LD_INT 1
45752: ARRAY
45753: PUSH
45754: LD_VAR 0 7
45758: PUSH
45759: LD_INT 2
45761: ARRAY
45762: PUSH
45763: LD_VAR 0 7
45767: PUSH
45768: LD_INT 3
45770: ARRAY
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: LIST
45776: LIST
45777: PPUSH
45778: CALL_OW 2
45782: PPUSH
45783: CALL_OW 1
45787: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45788: LD_ADDR_VAR 0 5
45792: PUSH
45793: LD_VAR 0 5
45797: PPUSH
45798: LD_INT 1
45800: PPUSH
45801: CALL_OW 3
45805: ST_TO_ADDR
// if not ext_list then
45806: LD_VAR 0 5
45810: NOT
45811: IFFALSE 45817
// exit ;
45813: POP
45814: POP
45815: GO 45821
// end ;
45817: GO 45692
45819: POP
45820: POP
// end ;
45821: LD_VAR 0 6
45825: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45826: LD_INT 0
45828: PPUSH
// if not mc_bases or not base or not weapon_list then
45829: LD_EXP 93
45833: NOT
45834: PUSH
45835: LD_VAR 0 1
45839: NOT
45840: OR
45841: PUSH
45842: LD_VAR 0 2
45846: NOT
45847: OR
45848: IFFALSE 45852
// exit ;
45850: GO 45877
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45852: LD_ADDR_EXP 132
45856: PUSH
45857: LD_EXP 132
45861: PPUSH
45862: LD_VAR 0 1
45866: PPUSH
45867: LD_VAR 0 2
45871: PPUSH
45872: CALL_OW 1
45876: ST_TO_ADDR
// end ;
45877: LD_VAR 0 3
45881: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45882: LD_INT 0
45884: PPUSH
// if not mc_bases or not base or not tech_list then
45885: LD_EXP 93
45889: NOT
45890: PUSH
45891: LD_VAR 0 1
45895: NOT
45896: OR
45897: PUSH
45898: LD_VAR 0 2
45902: NOT
45903: OR
45904: IFFALSE 45908
// exit ;
45906: GO 45933
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45908: LD_ADDR_EXP 120
45912: PUSH
45913: LD_EXP 120
45917: PPUSH
45918: LD_VAR 0 1
45922: PPUSH
45923: LD_VAR 0 2
45927: PPUSH
45928: CALL_OW 1
45932: ST_TO_ADDR
// end ;
45933: LD_VAR 0 3
45937: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45938: LD_INT 0
45940: PPUSH
// if not mc_bases or not parking_area or not base then
45941: LD_EXP 93
45945: NOT
45946: PUSH
45947: LD_VAR 0 2
45951: NOT
45952: OR
45953: PUSH
45954: LD_VAR 0 1
45958: NOT
45959: OR
45960: IFFALSE 45964
// exit ;
45962: GO 45989
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45964: LD_ADDR_EXP 117
45968: PUSH
45969: LD_EXP 117
45973: PPUSH
45974: LD_VAR 0 1
45978: PPUSH
45979: LD_VAR 0 2
45983: PPUSH
45984: CALL_OW 1
45988: ST_TO_ADDR
// end ;
45989: LD_VAR 0 3
45993: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45994: LD_INT 0
45996: PPUSH
// if not mc_bases or not base or not scan_area then
45997: LD_EXP 93
46001: NOT
46002: PUSH
46003: LD_VAR 0 1
46007: NOT
46008: OR
46009: PUSH
46010: LD_VAR 0 2
46014: NOT
46015: OR
46016: IFFALSE 46020
// exit ;
46018: GO 46045
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46020: LD_ADDR_EXP 118
46024: PUSH
46025: LD_EXP 118
46029: PPUSH
46030: LD_VAR 0 1
46034: PPUSH
46035: LD_VAR 0 2
46039: PPUSH
46040: CALL_OW 1
46044: ST_TO_ADDR
// end ;
46045: LD_VAR 0 3
46049: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46050: LD_INT 0
46052: PPUSH
46053: PPUSH
// if not mc_bases or not base then
46054: LD_EXP 93
46058: NOT
46059: PUSH
46060: LD_VAR 0 1
46064: NOT
46065: OR
46066: IFFALSE 46070
// exit ;
46068: GO 46134
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46070: LD_ADDR_VAR 0 3
46074: PUSH
46075: LD_INT 1
46077: PUSH
46078: LD_INT 2
46080: PUSH
46081: LD_INT 3
46083: PUSH
46084: LD_INT 4
46086: PUSH
46087: LD_INT 11
46089: PUSH
46090: EMPTY
46091: LIST
46092: LIST
46093: LIST
46094: LIST
46095: LIST
46096: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46097: LD_ADDR_EXP 120
46101: PUSH
46102: LD_EXP 120
46106: PPUSH
46107: LD_VAR 0 1
46111: PPUSH
46112: LD_EXP 120
46116: PUSH
46117: LD_VAR 0 1
46121: ARRAY
46122: PUSH
46123: LD_VAR 0 3
46127: DIFF
46128: PPUSH
46129: CALL_OW 1
46133: ST_TO_ADDR
// end ;
46134: LD_VAR 0 2
46138: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
46139: LD_INT 0
46141: PPUSH
// result := mc_vehicles [ base ] ;
46142: LD_ADDR_VAR 0 3
46146: PUSH
46147: LD_EXP 112
46151: PUSH
46152: LD_VAR 0 1
46156: ARRAY
46157: ST_TO_ADDR
// if onlyCombat then
46158: LD_VAR 0 2
46162: IFFALSE 46340
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
46164: LD_ADDR_VAR 0 3
46168: PUSH
46169: LD_VAR 0 3
46173: PUSH
46174: LD_VAR 0 3
46178: PPUSH
46179: LD_INT 2
46181: PUSH
46182: LD_INT 34
46184: PUSH
46185: LD_INT 12
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: PUSH
46192: LD_INT 34
46194: PUSH
46195: LD_INT 51
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 34
46204: PUSH
46205: LD_EXP 73
46209: PUSH
46210: EMPTY
46211: LIST
46212: LIST
46213: PUSH
46214: LD_INT 34
46216: PUSH
46217: LD_INT 32
46219: PUSH
46220: EMPTY
46221: LIST
46222: LIST
46223: PUSH
46224: LD_INT 34
46226: PUSH
46227: LD_INT 13
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: PUSH
46234: LD_INT 34
46236: PUSH
46237: LD_INT 52
46239: PUSH
46240: EMPTY
46241: LIST
46242: LIST
46243: PUSH
46244: LD_INT 34
46246: PUSH
46247: LD_EXP 78
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 34
46258: PUSH
46259: LD_INT 14
46261: PUSH
46262: EMPTY
46263: LIST
46264: LIST
46265: PUSH
46266: LD_INT 34
46268: PUSH
46269: LD_INT 53
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: LD_INT 34
46278: PUSH
46279: LD_EXP 72
46283: PUSH
46284: EMPTY
46285: LIST
46286: LIST
46287: PUSH
46288: LD_INT 34
46290: PUSH
46291: LD_INT 31
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: PUSH
46298: LD_INT 34
46300: PUSH
46301: LD_INT 48
46303: PUSH
46304: EMPTY
46305: LIST
46306: LIST
46307: PUSH
46308: LD_INT 34
46310: PUSH
46311: LD_INT 8
46313: PUSH
46314: EMPTY
46315: LIST
46316: LIST
46317: PUSH
46318: EMPTY
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: LIST
46324: LIST
46325: LIST
46326: LIST
46327: LIST
46328: LIST
46329: LIST
46330: LIST
46331: LIST
46332: LIST
46333: PPUSH
46334: CALL_OW 72
46338: DIFF
46339: ST_TO_ADDR
// end ; end_of_file
46340: LD_VAR 0 3
46344: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46345: LD_INT 0
46347: PPUSH
46348: PPUSH
46349: PPUSH
// if not mc_bases or not skirmish then
46350: LD_EXP 93
46354: NOT
46355: PUSH
46356: LD_EXP 91
46360: NOT
46361: OR
46362: IFFALSE 46366
// exit ;
46364: GO 46531
// for i = 1 to mc_bases do
46366: LD_ADDR_VAR 0 4
46370: PUSH
46371: DOUBLE
46372: LD_INT 1
46374: DEC
46375: ST_TO_ADDR
46376: LD_EXP 93
46380: PUSH
46381: FOR_TO
46382: IFFALSE 46529
// begin if sci in mc_bases [ i ] then
46384: LD_VAR 0 2
46388: PUSH
46389: LD_EXP 93
46393: PUSH
46394: LD_VAR 0 4
46398: ARRAY
46399: IN
46400: IFFALSE 46527
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46402: LD_ADDR_EXP 122
46406: PUSH
46407: LD_EXP 122
46411: PPUSH
46412: LD_VAR 0 4
46416: PUSH
46417: LD_EXP 122
46421: PUSH
46422: LD_VAR 0 4
46426: ARRAY
46427: PUSH
46428: LD_INT 1
46430: PLUS
46431: PUSH
46432: EMPTY
46433: LIST
46434: LIST
46435: PPUSH
46436: LD_VAR 0 1
46440: PPUSH
46441: CALL 56104 0 3
46445: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46446: LD_ADDR_VAR 0 5
46450: PUSH
46451: LD_EXP 93
46455: PUSH
46456: LD_VAR 0 4
46460: ARRAY
46461: PPUSH
46462: LD_INT 2
46464: PUSH
46465: LD_INT 30
46467: PUSH
46468: LD_INT 0
46470: PUSH
46471: EMPTY
46472: LIST
46473: LIST
46474: PUSH
46475: LD_INT 30
46477: PUSH
46478: LD_INT 1
46480: PUSH
46481: EMPTY
46482: LIST
46483: LIST
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: LIST
46489: PPUSH
46490: CALL_OW 72
46494: PPUSH
46495: LD_VAR 0 1
46499: PPUSH
46500: CALL_OW 74
46504: ST_TO_ADDR
// if tmp then
46505: LD_VAR 0 5
46509: IFFALSE 46525
// ComStandNearbyBuilding ( ape , tmp ) ;
46511: LD_VAR 0 1
46515: PPUSH
46516: LD_VAR 0 5
46520: PPUSH
46521: CALL 52682 0 2
// break ;
46525: GO 46529
// end ; end ;
46527: GO 46381
46529: POP
46530: POP
// end ;
46531: LD_VAR 0 3
46535: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46536: LD_INT 0
46538: PPUSH
46539: PPUSH
46540: PPUSH
// if not mc_bases or not skirmish then
46541: LD_EXP 93
46545: NOT
46546: PUSH
46547: LD_EXP 91
46551: NOT
46552: OR
46553: IFFALSE 46557
// exit ;
46555: GO 46646
// for i = 1 to mc_bases do
46557: LD_ADDR_VAR 0 4
46561: PUSH
46562: DOUBLE
46563: LD_INT 1
46565: DEC
46566: ST_TO_ADDR
46567: LD_EXP 93
46571: PUSH
46572: FOR_TO
46573: IFFALSE 46644
// begin if building in mc_busy_turret_list [ i ] then
46575: LD_VAR 0 1
46579: PUSH
46580: LD_EXP 103
46584: PUSH
46585: LD_VAR 0 4
46589: ARRAY
46590: IN
46591: IFFALSE 46642
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46593: LD_ADDR_VAR 0 5
46597: PUSH
46598: LD_EXP 103
46602: PUSH
46603: LD_VAR 0 4
46607: ARRAY
46608: PUSH
46609: LD_VAR 0 1
46613: DIFF
46614: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46615: LD_ADDR_EXP 103
46619: PUSH
46620: LD_EXP 103
46624: PPUSH
46625: LD_VAR 0 4
46629: PPUSH
46630: LD_VAR 0 5
46634: PPUSH
46635: CALL_OW 1
46639: ST_TO_ADDR
// break ;
46640: GO 46644
// end ; end ;
46642: GO 46572
46644: POP
46645: POP
// end ;
46646: LD_VAR 0 3
46650: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46651: LD_INT 0
46653: PPUSH
46654: PPUSH
46655: PPUSH
// if not mc_bases or not skirmish then
46656: LD_EXP 93
46660: NOT
46661: PUSH
46662: LD_EXP 91
46666: NOT
46667: OR
46668: IFFALSE 46672
// exit ;
46670: GO 46871
// for i = 1 to mc_bases do
46672: LD_ADDR_VAR 0 5
46676: PUSH
46677: DOUBLE
46678: LD_INT 1
46680: DEC
46681: ST_TO_ADDR
46682: LD_EXP 93
46686: PUSH
46687: FOR_TO
46688: IFFALSE 46869
// if building in mc_bases [ i ] then
46690: LD_VAR 0 1
46694: PUSH
46695: LD_EXP 93
46699: PUSH
46700: LD_VAR 0 5
46704: ARRAY
46705: IN
46706: IFFALSE 46867
// begin tmp := mc_bases [ i ] diff building ;
46708: LD_ADDR_VAR 0 6
46712: PUSH
46713: LD_EXP 93
46717: PUSH
46718: LD_VAR 0 5
46722: ARRAY
46723: PUSH
46724: LD_VAR 0 1
46728: DIFF
46729: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46730: LD_ADDR_EXP 93
46734: PUSH
46735: LD_EXP 93
46739: PPUSH
46740: LD_VAR 0 5
46744: PPUSH
46745: LD_VAR 0 6
46749: PPUSH
46750: CALL_OW 1
46754: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46755: LD_VAR 0 1
46759: PUSH
46760: LD_EXP 101
46764: PUSH
46765: LD_VAR 0 5
46769: ARRAY
46770: IN
46771: IFFALSE 46810
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46773: LD_ADDR_EXP 101
46777: PUSH
46778: LD_EXP 101
46782: PPUSH
46783: LD_VAR 0 5
46787: PPUSH
46788: LD_EXP 101
46792: PUSH
46793: LD_VAR 0 5
46797: ARRAY
46798: PUSH
46799: LD_VAR 0 1
46803: DIFF
46804: PPUSH
46805: CALL_OW 1
46809: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46810: LD_VAR 0 1
46814: PUSH
46815: LD_EXP 102
46819: PUSH
46820: LD_VAR 0 5
46824: ARRAY
46825: IN
46826: IFFALSE 46865
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46828: LD_ADDR_EXP 102
46832: PUSH
46833: LD_EXP 102
46837: PPUSH
46838: LD_VAR 0 5
46842: PPUSH
46843: LD_EXP 102
46847: PUSH
46848: LD_VAR 0 5
46852: ARRAY
46853: PUSH
46854: LD_VAR 0 1
46858: DIFF
46859: PPUSH
46860: CALL_OW 1
46864: ST_TO_ADDR
// break ;
46865: GO 46869
// end ;
46867: GO 46687
46869: POP
46870: POP
// end ;
46871: LD_VAR 0 4
46875: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46876: LD_INT 0
46878: PPUSH
46879: PPUSH
46880: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46881: LD_EXP 93
46885: NOT
46886: PUSH
46887: LD_EXP 91
46891: NOT
46892: OR
46893: PUSH
46894: LD_VAR 0 3
46898: PUSH
46899: LD_EXP 119
46903: IN
46904: NOT
46905: OR
46906: IFFALSE 46910
// exit ;
46908: GO 47033
// for i = 1 to mc_vehicles do
46910: LD_ADDR_VAR 0 6
46914: PUSH
46915: DOUBLE
46916: LD_INT 1
46918: DEC
46919: ST_TO_ADDR
46920: LD_EXP 112
46924: PUSH
46925: FOR_TO
46926: IFFALSE 47031
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46928: LD_VAR 0 2
46932: PUSH
46933: LD_EXP 112
46937: PUSH
46938: LD_VAR 0 6
46942: ARRAY
46943: IN
46944: PUSH
46945: LD_VAR 0 1
46949: PUSH
46950: LD_EXP 112
46954: PUSH
46955: LD_VAR 0 6
46959: ARRAY
46960: IN
46961: OR
46962: IFFALSE 47029
// begin tmp := mc_vehicles [ i ] diff old ;
46964: LD_ADDR_VAR 0 7
46968: PUSH
46969: LD_EXP 112
46973: PUSH
46974: LD_VAR 0 6
46978: ARRAY
46979: PUSH
46980: LD_VAR 0 2
46984: DIFF
46985: ST_TO_ADDR
// tmp := tmp diff new ;
46986: LD_ADDR_VAR 0 7
46990: PUSH
46991: LD_VAR 0 7
46995: PUSH
46996: LD_VAR 0 1
47000: DIFF
47001: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47002: LD_ADDR_EXP 112
47006: PUSH
47007: LD_EXP 112
47011: PPUSH
47012: LD_VAR 0 6
47016: PPUSH
47017: LD_VAR 0 7
47021: PPUSH
47022: CALL_OW 1
47026: ST_TO_ADDR
// break ;
47027: GO 47031
// end ;
47029: GO 46925
47031: POP
47032: POP
// end ;
47033: LD_VAR 0 5
47037: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47038: LD_INT 0
47040: PPUSH
47041: PPUSH
47042: PPUSH
47043: PPUSH
// if not mc_bases or not skirmish then
47044: LD_EXP 93
47048: NOT
47049: PUSH
47050: LD_EXP 91
47054: NOT
47055: OR
47056: IFFALSE 47060
// exit ;
47058: GO 47443
// side := GetSide ( vehicle ) ;
47060: LD_ADDR_VAR 0 5
47064: PUSH
47065: LD_VAR 0 1
47069: PPUSH
47070: CALL_OW 255
47074: ST_TO_ADDR
// for i = 1 to mc_bases do
47075: LD_ADDR_VAR 0 4
47079: PUSH
47080: DOUBLE
47081: LD_INT 1
47083: DEC
47084: ST_TO_ADDR
47085: LD_EXP 93
47089: PUSH
47090: FOR_TO
47091: IFFALSE 47441
// begin if factory in mc_bases [ i ] then
47093: LD_VAR 0 2
47097: PUSH
47098: LD_EXP 93
47102: PUSH
47103: LD_VAR 0 4
47107: ARRAY
47108: IN
47109: IFFALSE 47439
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
47111: LD_EXP 115
47115: PUSH
47116: LD_VAR 0 4
47120: ARRAY
47121: PUSH
47122: LD_EXP 104
47126: PUSH
47127: LD_VAR 0 4
47131: ARRAY
47132: LESS
47133: PUSH
47134: LD_VAR 0 1
47138: PPUSH
47139: CALL_OW 264
47143: PUSH
47144: LD_INT 31
47146: PUSH
47147: LD_INT 32
47149: PUSH
47150: LD_INT 51
47152: PUSH
47153: LD_EXP 73
47157: PUSH
47158: LD_INT 12
47160: PUSH
47161: LD_INT 30
47163: PUSH
47164: LD_EXP 72
47168: PUSH
47169: LD_INT 11
47171: PUSH
47172: LD_INT 53
47174: PUSH
47175: LD_INT 14
47177: PUSH
47178: LD_EXP 76
47182: PUSH
47183: LD_INT 29
47185: PUSH
47186: LD_EXP 74
47190: PUSH
47191: LD_INT 13
47193: PUSH
47194: LD_INT 52
47196: PUSH
47197: LD_EXP 78
47201: PUSH
47202: LD_INT 48
47204: PUSH
47205: LD_INT 8
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: LIST
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: IN
47228: NOT
47229: AND
47230: IFFALSE 47278
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
47232: LD_ADDR_EXP 115
47236: PUSH
47237: LD_EXP 115
47241: PPUSH
47242: LD_VAR 0 4
47246: PUSH
47247: LD_EXP 115
47251: PUSH
47252: LD_VAR 0 4
47256: ARRAY
47257: PUSH
47258: LD_INT 1
47260: PLUS
47261: PUSH
47262: EMPTY
47263: LIST
47264: LIST
47265: PPUSH
47266: LD_VAR 0 1
47270: PPUSH
47271: CALL 56104 0 3
47275: ST_TO_ADDR
47276: GO 47322
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
47278: LD_ADDR_EXP 112
47282: PUSH
47283: LD_EXP 112
47287: PPUSH
47288: LD_VAR 0 4
47292: PUSH
47293: LD_EXP 112
47297: PUSH
47298: LD_VAR 0 4
47302: ARRAY
47303: PUSH
47304: LD_INT 1
47306: PLUS
47307: PUSH
47308: EMPTY
47309: LIST
47310: LIST
47311: PPUSH
47312: LD_VAR 0 1
47316: PPUSH
47317: CALL 56104 0 3
47321: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
47322: LD_VAR 0 1
47326: PPUSH
47327: CALL_OW 263
47331: PUSH
47332: LD_INT 2
47334: EQUAL
47335: IFFALSE 47355
// begin repeat wait ( 0 0$1 ) ;
47337: LD_INT 35
47339: PPUSH
47340: CALL_OW 67
// until IsControledBy ( vehicle ) ;
47344: LD_VAR 0 1
47348: PPUSH
47349: CALL_OW 312
47353: IFFALSE 47337
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47355: LD_VAR 0 1
47359: PPUSH
47360: LD_EXP 117
47364: PUSH
47365: LD_VAR 0 4
47369: ARRAY
47370: PPUSH
47371: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47375: LD_VAR 0 1
47379: PPUSH
47380: CALL_OW 263
47384: PUSH
47385: LD_INT 1
47387: NONEQUAL
47388: IFFALSE 47392
// break ;
47390: GO 47441
// repeat wait ( 0 0$1 ) ;
47392: LD_INT 35
47394: PPUSH
47395: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47399: LD_VAR 0 1
47403: PPUSH
47404: LD_EXP 117
47408: PUSH
47409: LD_VAR 0 4
47413: ARRAY
47414: PPUSH
47415: CALL_OW 308
47419: IFFALSE 47392
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47421: LD_VAR 0 1
47425: PPUSH
47426: CALL_OW 311
47430: PPUSH
47431: CALL_OW 121
// exit ;
47435: POP
47436: POP
47437: GO 47443
// end ; end ;
47439: GO 47090
47441: POP
47442: POP
// end ;
47443: LD_VAR 0 3
47447: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47448: LD_INT 0
47450: PPUSH
47451: PPUSH
47452: PPUSH
47453: PPUSH
// if not mc_bases or not skirmish then
47454: LD_EXP 93
47458: NOT
47459: PUSH
47460: LD_EXP 91
47464: NOT
47465: OR
47466: IFFALSE 47470
// exit ;
47468: GO 47823
// repeat wait ( 0 0$1 ) ;
47470: LD_INT 35
47472: PPUSH
47473: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47477: LD_VAR 0 2
47481: PPUSH
47482: LD_VAR 0 3
47486: PPUSH
47487: CALL_OW 284
47491: IFFALSE 47470
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47493: LD_VAR 0 2
47497: PPUSH
47498: LD_VAR 0 3
47502: PPUSH
47503: CALL_OW 283
47507: PUSH
47508: LD_INT 4
47510: EQUAL
47511: IFFALSE 47515
// exit ;
47513: GO 47823
// for i = 1 to mc_bases do
47515: LD_ADDR_VAR 0 7
47519: PUSH
47520: DOUBLE
47521: LD_INT 1
47523: DEC
47524: ST_TO_ADDR
47525: LD_EXP 93
47529: PUSH
47530: FOR_TO
47531: IFFALSE 47821
// begin if mc_crates_area [ i ] then
47533: LD_EXP 111
47537: PUSH
47538: LD_VAR 0 7
47542: ARRAY
47543: IFFALSE 47654
// for j in mc_crates_area [ i ] do
47545: LD_ADDR_VAR 0 8
47549: PUSH
47550: LD_EXP 111
47554: PUSH
47555: LD_VAR 0 7
47559: ARRAY
47560: PUSH
47561: FOR_IN
47562: IFFALSE 47652
// if InArea ( x , y , j ) then
47564: LD_VAR 0 2
47568: PPUSH
47569: LD_VAR 0 3
47573: PPUSH
47574: LD_VAR 0 8
47578: PPUSH
47579: CALL_OW 309
47583: IFFALSE 47650
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47585: LD_ADDR_EXP 109
47589: PUSH
47590: LD_EXP 109
47594: PPUSH
47595: LD_VAR 0 7
47599: PUSH
47600: LD_EXP 109
47604: PUSH
47605: LD_VAR 0 7
47609: ARRAY
47610: PUSH
47611: LD_INT 1
47613: PLUS
47614: PUSH
47615: EMPTY
47616: LIST
47617: LIST
47618: PPUSH
47619: LD_VAR 0 4
47623: PUSH
47624: LD_VAR 0 2
47628: PUSH
47629: LD_VAR 0 3
47633: PUSH
47634: EMPTY
47635: LIST
47636: LIST
47637: LIST
47638: PPUSH
47639: CALL 56104 0 3
47643: ST_TO_ADDR
// exit ;
47644: POP
47645: POP
47646: POP
47647: POP
47648: GO 47823
// end ;
47650: GO 47561
47652: POP
47653: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47654: LD_ADDR_VAR 0 9
47658: PUSH
47659: LD_EXP 93
47663: PUSH
47664: LD_VAR 0 7
47668: ARRAY
47669: PPUSH
47670: LD_INT 2
47672: PUSH
47673: LD_INT 30
47675: PUSH
47676: LD_INT 0
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: PUSH
47683: LD_INT 30
47685: PUSH
47686: LD_INT 1
47688: PUSH
47689: EMPTY
47690: LIST
47691: LIST
47692: PUSH
47693: EMPTY
47694: LIST
47695: LIST
47696: LIST
47697: PPUSH
47698: CALL_OW 72
47702: ST_TO_ADDR
// if not depot then
47703: LD_VAR 0 9
47707: NOT
47708: IFFALSE 47712
// continue ;
47710: GO 47530
// for j in depot do
47712: LD_ADDR_VAR 0 8
47716: PUSH
47717: LD_VAR 0 9
47721: PUSH
47722: FOR_IN
47723: IFFALSE 47817
// if GetDistUnitXY ( j , x , y ) < 30 then
47725: LD_VAR 0 8
47729: PPUSH
47730: LD_VAR 0 2
47734: PPUSH
47735: LD_VAR 0 3
47739: PPUSH
47740: CALL_OW 297
47744: PUSH
47745: LD_INT 30
47747: LESS
47748: IFFALSE 47815
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47750: LD_ADDR_EXP 109
47754: PUSH
47755: LD_EXP 109
47759: PPUSH
47760: LD_VAR 0 7
47764: PUSH
47765: LD_EXP 109
47769: PUSH
47770: LD_VAR 0 7
47774: ARRAY
47775: PUSH
47776: LD_INT 1
47778: PLUS
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: PPUSH
47784: LD_VAR 0 4
47788: PUSH
47789: LD_VAR 0 2
47793: PUSH
47794: LD_VAR 0 3
47798: PUSH
47799: EMPTY
47800: LIST
47801: LIST
47802: LIST
47803: PPUSH
47804: CALL 56104 0 3
47808: ST_TO_ADDR
// exit ;
47809: POP
47810: POP
47811: POP
47812: POP
47813: GO 47823
// end ;
47815: GO 47722
47817: POP
47818: POP
// end ;
47819: GO 47530
47821: POP
47822: POP
// end ;
47823: LD_VAR 0 6
47827: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47828: LD_INT 0
47830: PPUSH
47831: PPUSH
47832: PPUSH
47833: PPUSH
// if not mc_bases or not skirmish then
47834: LD_EXP 93
47838: NOT
47839: PUSH
47840: LD_EXP 91
47844: NOT
47845: OR
47846: IFFALSE 47850
// exit ;
47848: GO 48127
// side := GetSide ( lab ) ;
47850: LD_ADDR_VAR 0 4
47854: PUSH
47855: LD_VAR 0 2
47859: PPUSH
47860: CALL_OW 255
47864: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47865: LD_VAR 0 4
47869: PUSH
47870: LD_EXP 119
47874: IN
47875: NOT
47876: PUSH
47877: LD_EXP 120
47881: NOT
47882: OR
47883: PUSH
47884: LD_EXP 93
47888: NOT
47889: OR
47890: IFFALSE 47894
// exit ;
47892: GO 48127
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47894: LD_ADDR_EXP 120
47898: PUSH
47899: LD_EXP 120
47903: PPUSH
47904: LD_VAR 0 4
47908: PPUSH
47909: LD_EXP 120
47913: PUSH
47914: LD_VAR 0 4
47918: ARRAY
47919: PUSH
47920: LD_VAR 0 1
47924: DIFF
47925: PPUSH
47926: CALL_OW 1
47930: ST_TO_ADDR
// for i = 1 to mc_bases do
47931: LD_ADDR_VAR 0 5
47935: PUSH
47936: DOUBLE
47937: LD_INT 1
47939: DEC
47940: ST_TO_ADDR
47941: LD_EXP 93
47945: PUSH
47946: FOR_TO
47947: IFFALSE 48125
// begin if lab in mc_bases [ i ] then
47949: LD_VAR 0 2
47953: PUSH
47954: LD_EXP 93
47958: PUSH
47959: LD_VAR 0 5
47963: ARRAY
47964: IN
47965: IFFALSE 48123
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47967: LD_VAR 0 1
47971: PUSH
47972: LD_INT 11
47974: PUSH
47975: LD_INT 4
47977: PUSH
47978: LD_INT 3
47980: PUSH
47981: LD_INT 2
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: IN
47990: PUSH
47991: LD_EXP 123
47995: PUSH
47996: LD_VAR 0 5
48000: ARRAY
48001: AND
48002: IFFALSE 48123
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48004: LD_ADDR_VAR 0 6
48008: PUSH
48009: LD_EXP 123
48013: PUSH
48014: LD_VAR 0 5
48018: ARRAY
48019: PUSH
48020: LD_INT 1
48022: ARRAY
48023: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48024: LD_ADDR_EXP 123
48028: PUSH
48029: LD_EXP 123
48033: PPUSH
48034: LD_VAR 0 5
48038: PPUSH
48039: EMPTY
48040: PPUSH
48041: CALL_OW 1
48045: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48046: LD_VAR 0 6
48050: PPUSH
48051: LD_INT 0
48053: PPUSH
48054: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48058: LD_VAR 0 6
48062: PPUSH
48063: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48067: LD_ADDR_EXP 122
48071: PUSH
48072: LD_EXP 122
48076: PPUSH
48077: LD_VAR 0 5
48081: PPUSH
48082: LD_EXP 122
48086: PUSH
48087: LD_VAR 0 5
48091: ARRAY
48092: PPUSH
48093: LD_INT 1
48095: PPUSH
48096: LD_VAR 0 6
48100: PPUSH
48101: CALL_OW 2
48105: PPUSH
48106: CALL_OW 1
48110: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
48111: LD_VAR 0 5
48115: PPUSH
48116: LD_INT 112
48118: PPUSH
48119: CALL 24956 0 2
// end ; end ; end ;
48123: GO 47946
48125: POP
48126: POP
// end ;
48127: LD_VAR 0 3
48131: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
48132: LD_INT 0
48134: PPUSH
48135: PPUSH
48136: PPUSH
48137: PPUSH
48138: PPUSH
48139: PPUSH
48140: PPUSH
48141: PPUSH
// if not mc_bases or not skirmish then
48142: LD_EXP 93
48146: NOT
48147: PUSH
48148: LD_EXP 91
48152: NOT
48153: OR
48154: IFFALSE 48158
// exit ;
48156: GO 49529
// for i = 1 to mc_bases do
48158: LD_ADDR_VAR 0 3
48162: PUSH
48163: DOUBLE
48164: LD_INT 1
48166: DEC
48167: ST_TO_ADDR
48168: LD_EXP 93
48172: PUSH
48173: FOR_TO
48174: IFFALSE 49527
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
48176: LD_VAR 0 1
48180: PUSH
48181: LD_EXP 93
48185: PUSH
48186: LD_VAR 0 3
48190: ARRAY
48191: IN
48192: PUSH
48193: LD_VAR 0 1
48197: PUSH
48198: LD_EXP 100
48202: PUSH
48203: LD_VAR 0 3
48207: ARRAY
48208: IN
48209: OR
48210: PUSH
48211: LD_VAR 0 1
48215: PUSH
48216: LD_EXP 115
48220: PUSH
48221: LD_VAR 0 3
48225: ARRAY
48226: IN
48227: OR
48228: PUSH
48229: LD_VAR 0 1
48233: PUSH
48234: LD_EXP 112
48238: PUSH
48239: LD_VAR 0 3
48243: ARRAY
48244: IN
48245: OR
48246: PUSH
48247: LD_VAR 0 1
48251: PUSH
48252: LD_EXP 122
48256: PUSH
48257: LD_VAR 0 3
48261: ARRAY
48262: IN
48263: OR
48264: PUSH
48265: LD_VAR 0 1
48269: PUSH
48270: LD_EXP 123
48274: PUSH
48275: LD_VAR 0 3
48279: ARRAY
48280: IN
48281: OR
48282: IFFALSE 49525
// begin if un in mc_ape [ i ] then
48284: LD_VAR 0 1
48288: PUSH
48289: LD_EXP 122
48293: PUSH
48294: LD_VAR 0 3
48298: ARRAY
48299: IN
48300: IFFALSE 48339
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
48302: LD_ADDR_EXP 122
48306: PUSH
48307: LD_EXP 122
48311: PPUSH
48312: LD_VAR 0 3
48316: PPUSH
48317: LD_EXP 122
48321: PUSH
48322: LD_VAR 0 3
48326: ARRAY
48327: PUSH
48328: LD_VAR 0 1
48332: DIFF
48333: PPUSH
48334: CALL_OW 1
48338: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48339: LD_VAR 0 1
48343: PUSH
48344: LD_EXP 123
48348: PUSH
48349: LD_VAR 0 3
48353: ARRAY
48354: IN
48355: IFFALSE 48379
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48357: LD_ADDR_EXP 123
48361: PUSH
48362: LD_EXP 123
48366: PPUSH
48367: LD_VAR 0 3
48371: PPUSH
48372: EMPTY
48373: PPUSH
48374: CALL_OW 1
48378: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48379: LD_VAR 0 1
48383: PPUSH
48384: CALL_OW 247
48388: PUSH
48389: LD_INT 2
48391: EQUAL
48392: PUSH
48393: LD_VAR 0 1
48397: PPUSH
48398: CALL_OW 110
48402: PUSH
48403: LD_INT 20
48405: EQUAL
48406: PUSH
48407: LD_VAR 0 1
48411: PUSH
48412: LD_EXP 115
48416: PUSH
48417: LD_VAR 0 3
48421: ARRAY
48422: IN
48423: OR
48424: PUSH
48425: LD_VAR 0 1
48429: PPUSH
48430: CALL_OW 264
48434: PUSH
48435: LD_INT 12
48437: PUSH
48438: LD_INT 51
48440: PUSH
48441: LD_EXP 73
48445: PUSH
48446: LD_INT 32
48448: PUSH
48449: LD_INT 13
48451: PUSH
48452: LD_INT 52
48454: PUSH
48455: LD_INT 31
48457: PUSH
48458: EMPTY
48459: LIST
48460: LIST
48461: LIST
48462: LIST
48463: LIST
48464: LIST
48465: LIST
48466: IN
48467: OR
48468: AND
48469: IFFALSE 48777
// begin if un in mc_defender [ i ] then
48471: LD_VAR 0 1
48475: PUSH
48476: LD_EXP 115
48480: PUSH
48481: LD_VAR 0 3
48485: ARRAY
48486: IN
48487: IFFALSE 48526
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48489: LD_ADDR_EXP 115
48493: PUSH
48494: LD_EXP 115
48498: PPUSH
48499: LD_VAR 0 3
48503: PPUSH
48504: LD_EXP 115
48508: PUSH
48509: LD_VAR 0 3
48513: ARRAY
48514: PUSH
48515: LD_VAR 0 1
48519: DIFF
48520: PPUSH
48521: CALL_OW 1
48525: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48526: LD_ADDR_VAR 0 8
48530: PUSH
48531: LD_VAR 0 3
48535: PPUSH
48536: LD_INT 3
48538: PPUSH
48539: CALL 45176 0 2
48543: ST_TO_ADDR
// if fac then
48544: LD_VAR 0 8
48548: IFFALSE 48777
// begin for j in fac do
48550: LD_ADDR_VAR 0 4
48554: PUSH
48555: LD_VAR 0 8
48559: PUSH
48560: FOR_IN
48561: IFFALSE 48775
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48563: LD_ADDR_VAR 0 9
48567: PUSH
48568: LD_VAR 0 8
48572: PPUSH
48573: LD_VAR 0 1
48577: PPUSH
48578: CALL_OW 265
48582: PPUSH
48583: LD_VAR 0 1
48587: PPUSH
48588: CALL_OW 262
48592: PPUSH
48593: LD_VAR 0 1
48597: PPUSH
48598: CALL_OW 263
48602: PPUSH
48603: LD_VAR 0 1
48607: PPUSH
48608: CALL_OW 264
48612: PPUSH
48613: CALL 53600 0 5
48617: ST_TO_ADDR
// if components then
48618: LD_VAR 0 9
48622: IFFALSE 48773
// begin if GetWeapon ( un ) = ar_control_tower then
48624: LD_VAR 0 1
48628: PPUSH
48629: CALL_OW 264
48633: PUSH
48634: LD_INT 31
48636: EQUAL
48637: IFFALSE 48754
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48639: LD_VAR 0 1
48643: PPUSH
48644: CALL_OW 311
48648: PPUSH
48649: LD_INT 0
48651: PPUSH
48652: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48656: LD_ADDR_EXP 133
48660: PUSH
48661: LD_EXP 133
48665: PPUSH
48666: LD_VAR 0 3
48670: PPUSH
48671: LD_EXP 133
48675: PUSH
48676: LD_VAR 0 3
48680: ARRAY
48681: PUSH
48682: LD_VAR 0 1
48686: PPUSH
48687: CALL_OW 311
48691: DIFF
48692: PPUSH
48693: CALL_OW 1
48697: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48698: LD_ADDR_VAR 0 7
48702: PUSH
48703: LD_EXP 114
48707: PUSH
48708: LD_VAR 0 3
48712: ARRAY
48713: PPUSH
48714: LD_INT 1
48716: PPUSH
48717: LD_VAR 0 9
48721: PPUSH
48722: CALL_OW 2
48726: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48727: LD_ADDR_EXP 114
48731: PUSH
48732: LD_EXP 114
48736: PPUSH
48737: LD_VAR 0 3
48741: PPUSH
48742: LD_VAR 0 7
48746: PPUSH
48747: CALL_OW 1
48751: ST_TO_ADDR
// end else
48752: GO 48771
// MC_InsertProduceList ( i , [ components ] ) ;
48754: LD_VAR 0 3
48758: PPUSH
48759: LD_VAR 0 9
48763: PUSH
48764: EMPTY
48765: LIST
48766: PPUSH
48767: CALL 44721 0 2
// break ;
48771: GO 48775
// end ; end ;
48773: GO 48560
48775: POP
48776: POP
// end ; end ; if GetType ( un ) = unit_building then
48777: LD_VAR 0 1
48781: PPUSH
48782: CALL_OW 247
48786: PUSH
48787: LD_INT 3
48789: EQUAL
48790: IFFALSE 49193
// begin btype := GetBType ( un ) ;
48792: LD_ADDR_VAR 0 5
48796: PUSH
48797: LD_VAR 0 1
48801: PPUSH
48802: CALL_OW 266
48806: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48807: LD_VAR 0 5
48811: PUSH
48812: LD_INT 29
48814: PUSH
48815: LD_INT 30
48817: PUSH
48818: EMPTY
48819: LIST
48820: LIST
48821: IN
48822: IFFALSE 48895
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48824: LD_VAR 0 1
48828: PPUSH
48829: CALL_OW 250
48833: PPUSH
48834: LD_VAR 0 1
48838: PPUSH
48839: CALL_OW 251
48843: PPUSH
48844: LD_VAR 0 1
48848: PPUSH
48849: CALL_OW 255
48853: PPUSH
48854: CALL_OW 440
48858: NOT
48859: IFFALSE 48895
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48861: LD_VAR 0 1
48865: PPUSH
48866: CALL_OW 250
48870: PPUSH
48871: LD_VAR 0 1
48875: PPUSH
48876: CALL_OW 251
48880: PPUSH
48881: LD_VAR 0 1
48885: PPUSH
48886: CALL_OW 255
48890: PPUSH
48891: CALL_OW 441
// end ; if btype = b_warehouse then
48895: LD_VAR 0 5
48899: PUSH
48900: LD_INT 1
48902: EQUAL
48903: IFFALSE 48921
// begin btype := b_depot ;
48905: LD_ADDR_VAR 0 5
48909: PUSH
48910: LD_INT 0
48912: ST_TO_ADDR
// pos := 1 ;
48913: LD_ADDR_VAR 0 6
48917: PUSH
48918: LD_INT 1
48920: ST_TO_ADDR
// end ; if btype = b_factory then
48921: LD_VAR 0 5
48925: PUSH
48926: LD_INT 3
48928: EQUAL
48929: IFFALSE 48947
// begin btype := b_workshop ;
48931: LD_ADDR_VAR 0 5
48935: PUSH
48936: LD_INT 2
48938: ST_TO_ADDR
// pos := 1 ;
48939: LD_ADDR_VAR 0 6
48943: PUSH
48944: LD_INT 1
48946: ST_TO_ADDR
// end ; if btype = b_barracks then
48947: LD_VAR 0 5
48951: PUSH
48952: LD_INT 5
48954: EQUAL
48955: IFFALSE 48965
// btype := b_armoury ;
48957: LD_ADDR_VAR 0 5
48961: PUSH
48962: LD_INT 4
48964: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48965: LD_VAR 0 5
48969: PUSH
48970: LD_INT 7
48972: PUSH
48973: LD_INT 8
48975: PUSH
48976: EMPTY
48977: LIST
48978: LIST
48979: IN
48980: IFFALSE 48990
// btype := b_lab ;
48982: LD_ADDR_VAR 0 5
48986: PUSH
48987: LD_INT 6
48989: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48990: LD_ADDR_EXP 98
48994: PUSH
48995: LD_EXP 98
48999: PPUSH
49000: LD_VAR 0 3
49004: PUSH
49005: LD_EXP 98
49009: PUSH
49010: LD_VAR 0 3
49014: ARRAY
49015: PUSH
49016: LD_INT 1
49018: PLUS
49019: PUSH
49020: EMPTY
49021: LIST
49022: LIST
49023: PPUSH
49024: LD_VAR 0 5
49028: PUSH
49029: LD_VAR 0 1
49033: PPUSH
49034: CALL_OW 250
49038: PUSH
49039: LD_VAR 0 1
49043: PPUSH
49044: CALL_OW 251
49048: PUSH
49049: LD_VAR 0 1
49053: PPUSH
49054: CALL_OW 254
49058: PUSH
49059: EMPTY
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: PPUSH
49065: CALL 56104 0 3
49069: ST_TO_ADDR
// if pos = 1 then
49070: LD_VAR 0 6
49074: PUSH
49075: LD_INT 1
49077: EQUAL
49078: IFFALSE 49193
// begin tmp := mc_build_list [ i ] ;
49080: LD_ADDR_VAR 0 7
49084: PUSH
49085: LD_EXP 98
49089: PUSH
49090: LD_VAR 0 3
49094: ARRAY
49095: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
49096: LD_VAR 0 7
49100: PPUSH
49101: LD_INT 2
49103: PUSH
49104: LD_INT 30
49106: PUSH
49107: LD_INT 0
49109: PUSH
49110: EMPTY
49111: LIST
49112: LIST
49113: PUSH
49114: LD_INT 30
49116: PUSH
49117: LD_INT 1
49119: PUSH
49120: EMPTY
49121: LIST
49122: LIST
49123: PUSH
49124: EMPTY
49125: LIST
49126: LIST
49127: LIST
49128: PPUSH
49129: CALL_OW 72
49133: IFFALSE 49143
// pos := 2 ;
49135: LD_ADDR_VAR 0 6
49139: PUSH
49140: LD_INT 2
49142: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
49143: LD_ADDR_VAR 0 7
49147: PUSH
49148: LD_VAR 0 7
49152: PPUSH
49153: LD_VAR 0 6
49157: PPUSH
49158: LD_VAR 0 7
49162: PPUSH
49163: CALL 56430 0 3
49167: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
49168: LD_ADDR_EXP 98
49172: PUSH
49173: LD_EXP 98
49177: PPUSH
49178: LD_VAR 0 3
49182: PPUSH
49183: LD_VAR 0 7
49187: PPUSH
49188: CALL_OW 1
49192: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
49193: LD_VAR 0 1
49197: PUSH
49198: LD_EXP 93
49202: PUSH
49203: LD_VAR 0 3
49207: ARRAY
49208: IN
49209: IFFALSE 49248
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
49211: LD_ADDR_EXP 93
49215: PUSH
49216: LD_EXP 93
49220: PPUSH
49221: LD_VAR 0 3
49225: PPUSH
49226: LD_EXP 93
49230: PUSH
49231: LD_VAR 0 3
49235: ARRAY
49236: PUSH
49237: LD_VAR 0 1
49241: DIFF
49242: PPUSH
49243: CALL_OW 1
49247: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
49248: LD_VAR 0 1
49252: PUSH
49253: LD_EXP 100
49257: PUSH
49258: LD_VAR 0 3
49262: ARRAY
49263: IN
49264: IFFALSE 49303
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
49266: LD_ADDR_EXP 100
49270: PUSH
49271: LD_EXP 100
49275: PPUSH
49276: LD_VAR 0 3
49280: PPUSH
49281: LD_EXP 100
49285: PUSH
49286: LD_VAR 0 3
49290: ARRAY
49291: PUSH
49292: LD_VAR 0 1
49296: DIFF
49297: PPUSH
49298: CALL_OW 1
49302: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
49303: LD_VAR 0 1
49307: PUSH
49308: LD_EXP 112
49312: PUSH
49313: LD_VAR 0 3
49317: ARRAY
49318: IN
49319: IFFALSE 49358
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
49321: LD_ADDR_EXP 112
49325: PUSH
49326: LD_EXP 112
49330: PPUSH
49331: LD_VAR 0 3
49335: PPUSH
49336: LD_EXP 112
49340: PUSH
49341: LD_VAR 0 3
49345: ARRAY
49346: PUSH
49347: LD_VAR 0 1
49351: DIFF
49352: PPUSH
49353: CALL_OW 1
49357: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49358: LD_VAR 0 1
49362: PUSH
49363: LD_EXP 115
49367: PUSH
49368: LD_VAR 0 3
49372: ARRAY
49373: IN
49374: IFFALSE 49413
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49376: LD_ADDR_EXP 115
49380: PUSH
49381: LD_EXP 115
49385: PPUSH
49386: LD_VAR 0 3
49390: PPUSH
49391: LD_EXP 115
49395: PUSH
49396: LD_VAR 0 3
49400: ARRAY
49401: PUSH
49402: LD_VAR 0 1
49406: DIFF
49407: PPUSH
49408: CALL_OW 1
49412: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49413: LD_VAR 0 1
49417: PUSH
49418: LD_EXP 102
49422: PUSH
49423: LD_VAR 0 3
49427: ARRAY
49428: IN
49429: IFFALSE 49468
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49431: LD_ADDR_EXP 102
49435: PUSH
49436: LD_EXP 102
49440: PPUSH
49441: LD_VAR 0 3
49445: PPUSH
49446: LD_EXP 102
49450: PUSH
49451: LD_VAR 0 3
49455: ARRAY
49456: PUSH
49457: LD_VAR 0 1
49461: DIFF
49462: PPUSH
49463: CALL_OW 1
49467: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49468: LD_VAR 0 1
49472: PUSH
49473: LD_EXP 101
49477: PUSH
49478: LD_VAR 0 3
49482: ARRAY
49483: IN
49484: IFFALSE 49523
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49486: LD_ADDR_EXP 101
49490: PUSH
49491: LD_EXP 101
49495: PPUSH
49496: LD_VAR 0 3
49500: PPUSH
49501: LD_EXP 101
49505: PUSH
49506: LD_VAR 0 3
49510: ARRAY
49511: PUSH
49512: LD_VAR 0 1
49516: DIFF
49517: PPUSH
49518: CALL_OW 1
49522: ST_TO_ADDR
// end ; break ;
49523: GO 49527
// end ;
49525: GO 48173
49527: POP
49528: POP
// end ;
49529: LD_VAR 0 2
49533: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49534: LD_INT 0
49536: PPUSH
49537: PPUSH
49538: PPUSH
// if not mc_bases or not skirmish then
49539: LD_EXP 93
49543: NOT
49544: PUSH
49545: LD_EXP 91
49549: NOT
49550: OR
49551: IFFALSE 49555
// exit ;
49553: GO 49770
// for i = 1 to mc_bases do
49555: LD_ADDR_VAR 0 3
49559: PUSH
49560: DOUBLE
49561: LD_INT 1
49563: DEC
49564: ST_TO_ADDR
49565: LD_EXP 93
49569: PUSH
49570: FOR_TO
49571: IFFALSE 49768
// begin if building in mc_construct_list [ i ] then
49573: LD_VAR 0 1
49577: PUSH
49578: LD_EXP 100
49582: PUSH
49583: LD_VAR 0 3
49587: ARRAY
49588: IN
49589: IFFALSE 49766
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49591: LD_ADDR_EXP 100
49595: PUSH
49596: LD_EXP 100
49600: PPUSH
49601: LD_VAR 0 3
49605: PPUSH
49606: LD_EXP 100
49610: PUSH
49611: LD_VAR 0 3
49615: ARRAY
49616: PUSH
49617: LD_VAR 0 1
49621: DIFF
49622: PPUSH
49623: CALL_OW 1
49627: ST_TO_ADDR
// if building in mc_lab [ i ] then
49628: LD_VAR 0 1
49632: PUSH
49633: LD_EXP 126
49637: PUSH
49638: LD_VAR 0 3
49642: ARRAY
49643: IN
49644: IFFALSE 49699
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49646: LD_ADDR_EXP 127
49650: PUSH
49651: LD_EXP 127
49655: PPUSH
49656: LD_VAR 0 3
49660: PPUSH
49661: LD_EXP 127
49665: PUSH
49666: LD_VAR 0 3
49670: ARRAY
49671: PPUSH
49672: LD_INT 1
49674: PPUSH
49675: LD_EXP 127
49679: PUSH
49680: LD_VAR 0 3
49684: ARRAY
49685: PPUSH
49686: LD_INT 0
49688: PPUSH
49689: CALL 55522 0 4
49693: PPUSH
49694: CALL_OW 1
49698: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49699: LD_VAR 0 1
49703: PUSH
49704: LD_EXP 93
49708: PUSH
49709: LD_VAR 0 3
49713: ARRAY
49714: IN
49715: NOT
49716: IFFALSE 49762
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49718: LD_ADDR_EXP 93
49722: PUSH
49723: LD_EXP 93
49727: PPUSH
49728: LD_VAR 0 3
49732: PUSH
49733: LD_EXP 93
49737: PUSH
49738: LD_VAR 0 3
49742: ARRAY
49743: PUSH
49744: LD_INT 1
49746: PLUS
49747: PUSH
49748: EMPTY
49749: LIST
49750: LIST
49751: PPUSH
49752: LD_VAR 0 1
49756: PPUSH
49757: CALL 56104 0 3
49761: ST_TO_ADDR
// exit ;
49762: POP
49763: POP
49764: GO 49770
// end ; end ;
49766: GO 49570
49768: POP
49769: POP
// end ;
49770: LD_VAR 0 2
49774: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49775: LD_INT 0
49777: PPUSH
49778: PPUSH
49779: PPUSH
49780: PPUSH
49781: PPUSH
49782: PPUSH
49783: PPUSH
// if not mc_bases or not skirmish then
49784: LD_EXP 93
49788: NOT
49789: PUSH
49790: LD_EXP 91
49794: NOT
49795: OR
49796: IFFALSE 49800
// exit ;
49798: GO 50461
// for i = 1 to mc_bases do
49800: LD_ADDR_VAR 0 3
49804: PUSH
49805: DOUBLE
49806: LD_INT 1
49808: DEC
49809: ST_TO_ADDR
49810: LD_EXP 93
49814: PUSH
49815: FOR_TO
49816: IFFALSE 50459
// begin if building in mc_construct_list [ i ] then
49818: LD_VAR 0 1
49822: PUSH
49823: LD_EXP 100
49827: PUSH
49828: LD_VAR 0 3
49832: ARRAY
49833: IN
49834: IFFALSE 50457
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49836: LD_ADDR_EXP 100
49840: PUSH
49841: LD_EXP 100
49845: PPUSH
49846: LD_VAR 0 3
49850: PPUSH
49851: LD_EXP 100
49855: PUSH
49856: LD_VAR 0 3
49860: ARRAY
49861: PUSH
49862: LD_VAR 0 1
49866: DIFF
49867: PPUSH
49868: CALL_OW 1
49872: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49873: LD_ADDR_EXP 93
49877: PUSH
49878: LD_EXP 93
49882: PPUSH
49883: LD_VAR 0 3
49887: PUSH
49888: LD_EXP 93
49892: PUSH
49893: LD_VAR 0 3
49897: ARRAY
49898: PUSH
49899: LD_INT 1
49901: PLUS
49902: PUSH
49903: EMPTY
49904: LIST
49905: LIST
49906: PPUSH
49907: LD_VAR 0 1
49911: PPUSH
49912: CALL 56104 0 3
49916: ST_TO_ADDR
// btype := GetBType ( building ) ;
49917: LD_ADDR_VAR 0 5
49921: PUSH
49922: LD_VAR 0 1
49926: PPUSH
49927: CALL_OW 266
49931: ST_TO_ADDR
// side := GetSide ( building ) ;
49932: LD_ADDR_VAR 0 8
49936: PUSH
49937: LD_VAR 0 1
49941: PPUSH
49942: CALL_OW 255
49946: ST_TO_ADDR
// if btype = b_lab then
49947: LD_VAR 0 5
49951: PUSH
49952: LD_INT 6
49954: EQUAL
49955: IFFALSE 50005
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49957: LD_ADDR_EXP 126
49961: PUSH
49962: LD_EXP 126
49966: PPUSH
49967: LD_VAR 0 3
49971: PUSH
49972: LD_EXP 126
49976: PUSH
49977: LD_VAR 0 3
49981: ARRAY
49982: PUSH
49983: LD_INT 1
49985: PLUS
49986: PUSH
49987: EMPTY
49988: LIST
49989: LIST
49990: PPUSH
49991: LD_VAR 0 1
49995: PPUSH
49996: CALL 56104 0 3
50000: ST_TO_ADDR
// exit ;
50001: POP
50002: POP
50003: GO 50461
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50005: LD_VAR 0 5
50009: PUSH
50010: LD_INT 0
50012: PUSH
50013: LD_INT 2
50015: PUSH
50016: LD_INT 4
50018: PUSH
50019: EMPTY
50020: LIST
50021: LIST
50022: LIST
50023: IN
50024: IFFALSE 50148
// begin if btype = b_armoury then
50026: LD_VAR 0 5
50030: PUSH
50031: LD_INT 4
50033: EQUAL
50034: IFFALSE 50044
// btype := b_barracks ;
50036: LD_ADDR_VAR 0 5
50040: PUSH
50041: LD_INT 5
50043: ST_TO_ADDR
// if btype = b_depot then
50044: LD_VAR 0 5
50048: PUSH
50049: LD_INT 0
50051: EQUAL
50052: IFFALSE 50062
// btype := b_warehouse ;
50054: LD_ADDR_VAR 0 5
50058: PUSH
50059: LD_INT 1
50061: ST_TO_ADDR
// if btype = b_workshop then
50062: LD_VAR 0 5
50066: PUSH
50067: LD_INT 2
50069: EQUAL
50070: IFFALSE 50080
// btype := b_factory ;
50072: LD_ADDR_VAR 0 5
50076: PUSH
50077: LD_INT 3
50079: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50080: LD_VAR 0 5
50084: PPUSH
50085: LD_VAR 0 8
50089: PPUSH
50090: CALL_OW 323
50094: PUSH
50095: LD_INT 1
50097: EQUAL
50098: IFFALSE 50144
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
50100: LD_ADDR_EXP 125
50104: PUSH
50105: LD_EXP 125
50109: PPUSH
50110: LD_VAR 0 3
50114: PUSH
50115: LD_EXP 125
50119: PUSH
50120: LD_VAR 0 3
50124: ARRAY
50125: PUSH
50126: LD_INT 1
50128: PLUS
50129: PUSH
50130: EMPTY
50131: LIST
50132: LIST
50133: PPUSH
50134: LD_VAR 0 1
50138: PPUSH
50139: CALL 56104 0 3
50143: ST_TO_ADDR
// exit ;
50144: POP
50145: POP
50146: GO 50461
// end ; if btype in [ b_bunker , b_turret ] then
50148: LD_VAR 0 5
50152: PUSH
50153: LD_INT 32
50155: PUSH
50156: LD_INT 33
50158: PUSH
50159: EMPTY
50160: LIST
50161: LIST
50162: IN
50163: IFFALSE 50453
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
50165: LD_ADDR_EXP 101
50169: PUSH
50170: LD_EXP 101
50174: PPUSH
50175: LD_VAR 0 3
50179: PUSH
50180: LD_EXP 101
50184: PUSH
50185: LD_VAR 0 3
50189: ARRAY
50190: PUSH
50191: LD_INT 1
50193: PLUS
50194: PUSH
50195: EMPTY
50196: LIST
50197: LIST
50198: PPUSH
50199: LD_VAR 0 1
50203: PPUSH
50204: CALL 56104 0 3
50208: ST_TO_ADDR
// if btype = b_bunker then
50209: LD_VAR 0 5
50213: PUSH
50214: LD_INT 32
50216: EQUAL
50217: IFFALSE 50453
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50219: LD_ADDR_EXP 102
50223: PUSH
50224: LD_EXP 102
50228: PPUSH
50229: LD_VAR 0 3
50233: PUSH
50234: LD_EXP 102
50238: PUSH
50239: LD_VAR 0 3
50243: ARRAY
50244: PUSH
50245: LD_INT 1
50247: PLUS
50248: PUSH
50249: EMPTY
50250: LIST
50251: LIST
50252: PPUSH
50253: LD_VAR 0 1
50257: PPUSH
50258: CALL 56104 0 3
50262: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
50263: LD_ADDR_VAR 0 6
50267: PUSH
50268: LD_EXP 93
50272: PUSH
50273: LD_VAR 0 3
50277: ARRAY
50278: PPUSH
50279: LD_INT 25
50281: PUSH
50282: LD_INT 1
50284: PUSH
50285: EMPTY
50286: LIST
50287: LIST
50288: PUSH
50289: LD_INT 3
50291: PUSH
50292: LD_INT 54
50294: PUSH
50295: EMPTY
50296: LIST
50297: PUSH
50298: EMPTY
50299: LIST
50300: LIST
50301: PUSH
50302: EMPTY
50303: LIST
50304: LIST
50305: PPUSH
50306: CALL_OW 72
50310: ST_TO_ADDR
// if tmp then
50311: LD_VAR 0 6
50315: IFFALSE 50321
// exit ;
50317: POP
50318: POP
50319: GO 50461
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
50321: LD_ADDR_VAR 0 6
50325: PUSH
50326: LD_EXP 93
50330: PUSH
50331: LD_VAR 0 3
50335: ARRAY
50336: PPUSH
50337: LD_INT 2
50339: PUSH
50340: LD_INT 30
50342: PUSH
50343: LD_INT 4
50345: PUSH
50346: EMPTY
50347: LIST
50348: LIST
50349: PUSH
50350: LD_INT 30
50352: PUSH
50353: LD_INT 5
50355: PUSH
50356: EMPTY
50357: LIST
50358: LIST
50359: PUSH
50360: EMPTY
50361: LIST
50362: LIST
50363: LIST
50364: PPUSH
50365: CALL_OW 72
50369: ST_TO_ADDR
// if not tmp then
50370: LD_VAR 0 6
50374: NOT
50375: IFFALSE 50381
// exit ;
50377: POP
50378: POP
50379: GO 50461
// for j in tmp do
50381: LD_ADDR_VAR 0 4
50385: PUSH
50386: LD_VAR 0 6
50390: PUSH
50391: FOR_IN
50392: IFFALSE 50451
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50394: LD_ADDR_VAR 0 7
50398: PUSH
50399: LD_VAR 0 4
50403: PPUSH
50404: CALL_OW 313
50408: PPUSH
50409: LD_INT 25
50411: PUSH
50412: LD_INT 1
50414: PUSH
50415: EMPTY
50416: LIST
50417: LIST
50418: PPUSH
50419: CALL_OW 72
50423: ST_TO_ADDR
// if units then
50424: LD_VAR 0 7
50428: IFFALSE 50449
// begin ComExitBuilding ( units [ 1 ] ) ;
50430: LD_VAR 0 7
50434: PUSH
50435: LD_INT 1
50437: ARRAY
50438: PPUSH
50439: CALL_OW 122
// exit ;
50443: POP
50444: POP
50445: POP
50446: POP
50447: GO 50461
// end ; end ;
50449: GO 50391
50451: POP
50452: POP
// end ; end ; exit ;
50453: POP
50454: POP
50455: GO 50461
// end ; end ;
50457: GO 49815
50459: POP
50460: POP
// end ;
50461: LD_VAR 0 2
50465: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50466: LD_INT 0
50468: PPUSH
50469: PPUSH
50470: PPUSH
50471: PPUSH
50472: PPUSH
50473: PPUSH
50474: PPUSH
// if not mc_bases or not skirmish then
50475: LD_EXP 93
50479: NOT
50480: PUSH
50481: LD_EXP 91
50485: NOT
50486: OR
50487: IFFALSE 50491
// exit ;
50489: GO 50756
// btype := GetBType ( building ) ;
50491: LD_ADDR_VAR 0 6
50495: PUSH
50496: LD_VAR 0 1
50500: PPUSH
50501: CALL_OW 266
50505: ST_TO_ADDR
// x := GetX ( building ) ;
50506: LD_ADDR_VAR 0 7
50510: PUSH
50511: LD_VAR 0 1
50515: PPUSH
50516: CALL_OW 250
50520: ST_TO_ADDR
// y := GetY ( building ) ;
50521: LD_ADDR_VAR 0 8
50525: PUSH
50526: LD_VAR 0 1
50530: PPUSH
50531: CALL_OW 251
50535: ST_TO_ADDR
// d := GetDir ( building ) ;
50536: LD_ADDR_VAR 0 9
50540: PUSH
50541: LD_VAR 0 1
50545: PPUSH
50546: CALL_OW 254
50550: ST_TO_ADDR
// for i = 1 to mc_bases do
50551: LD_ADDR_VAR 0 4
50555: PUSH
50556: DOUBLE
50557: LD_INT 1
50559: DEC
50560: ST_TO_ADDR
50561: LD_EXP 93
50565: PUSH
50566: FOR_TO
50567: IFFALSE 50754
// begin if not mc_build_list [ i ] then
50569: LD_EXP 98
50573: PUSH
50574: LD_VAR 0 4
50578: ARRAY
50579: NOT
50580: IFFALSE 50584
// continue ;
50582: GO 50566
// for j := 1 to mc_build_list [ i ] do
50584: LD_ADDR_VAR 0 5
50588: PUSH
50589: DOUBLE
50590: LD_INT 1
50592: DEC
50593: ST_TO_ADDR
50594: LD_EXP 98
50598: PUSH
50599: LD_VAR 0 4
50603: ARRAY
50604: PUSH
50605: FOR_TO
50606: IFFALSE 50750
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
50608: LD_VAR 0 6
50612: PUSH
50613: LD_VAR 0 7
50617: PUSH
50618: LD_VAR 0 8
50622: PUSH
50623: LD_VAR 0 9
50627: PUSH
50628: EMPTY
50629: LIST
50630: LIST
50631: LIST
50632: LIST
50633: PPUSH
50634: LD_EXP 98
50638: PUSH
50639: LD_VAR 0 4
50643: ARRAY
50644: PUSH
50645: LD_VAR 0 5
50649: ARRAY
50650: PPUSH
50651: CALL 62287 0 2
50655: IFFALSE 50748
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
50657: LD_ADDR_EXP 98
50661: PUSH
50662: LD_EXP 98
50666: PPUSH
50667: LD_VAR 0 4
50671: PPUSH
50672: LD_EXP 98
50676: PUSH
50677: LD_VAR 0 4
50681: ARRAY
50682: PPUSH
50683: LD_VAR 0 5
50687: PPUSH
50688: CALL_OW 3
50692: PPUSH
50693: CALL_OW 1
50697: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50698: LD_ADDR_EXP 100
50702: PUSH
50703: LD_EXP 100
50707: PPUSH
50708: LD_VAR 0 4
50712: PUSH
50713: LD_EXP 100
50717: PUSH
50718: LD_VAR 0 4
50722: ARRAY
50723: PUSH
50724: LD_INT 1
50726: PLUS
50727: PUSH
50728: EMPTY
50729: LIST
50730: LIST
50731: PPUSH
50732: LD_VAR 0 1
50736: PPUSH
50737: CALL 56104 0 3
50741: ST_TO_ADDR
// exit ;
50742: POP
50743: POP
50744: POP
50745: POP
50746: GO 50756
// end ;
50748: GO 50605
50750: POP
50751: POP
// end ;
50752: GO 50566
50754: POP
50755: POP
// end ;
50756: LD_VAR 0 3
50760: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50761: LD_INT 0
50763: PPUSH
50764: PPUSH
50765: PPUSH
// if not mc_bases or not skirmish then
50766: LD_EXP 93
50770: NOT
50771: PUSH
50772: LD_EXP 91
50776: NOT
50777: OR
50778: IFFALSE 50782
// exit ;
50780: GO 50972
// for i = 1 to mc_bases do
50782: LD_ADDR_VAR 0 4
50786: PUSH
50787: DOUBLE
50788: LD_INT 1
50790: DEC
50791: ST_TO_ADDR
50792: LD_EXP 93
50796: PUSH
50797: FOR_TO
50798: IFFALSE 50885
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50800: LD_VAR 0 1
50804: PUSH
50805: LD_EXP 101
50809: PUSH
50810: LD_VAR 0 4
50814: ARRAY
50815: IN
50816: PUSH
50817: LD_VAR 0 1
50821: PUSH
50822: LD_EXP 102
50826: PUSH
50827: LD_VAR 0 4
50831: ARRAY
50832: IN
50833: NOT
50834: AND
50835: IFFALSE 50883
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50837: LD_ADDR_EXP 102
50841: PUSH
50842: LD_EXP 102
50846: PPUSH
50847: LD_VAR 0 4
50851: PUSH
50852: LD_EXP 102
50856: PUSH
50857: LD_VAR 0 4
50861: ARRAY
50862: PUSH
50863: LD_INT 1
50865: PLUS
50866: PUSH
50867: EMPTY
50868: LIST
50869: LIST
50870: PPUSH
50871: LD_VAR 0 1
50875: PPUSH
50876: CALL 56104 0 3
50880: ST_TO_ADDR
// break ;
50881: GO 50885
// end ; end ;
50883: GO 50797
50885: POP
50886: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50887: LD_VAR 0 1
50891: PPUSH
50892: CALL_OW 257
50896: PUSH
50897: LD_EXP 119
50901: IN
50902: PUSH
50903: LD_VAR 0 1
50907: PPUSH
50908: CALL_OW 266
50912: PUSH
50913: LD_INT 5
50915: EQUAL
50916: AND
50917: PUSH
50918: LD_VAR 0 2
50922: PPUSH
50923: CALL_OW 110
50927: PUSH
50928: LD_INT 18
50930: NONEQUAL
50931: AND
50932: IFFALSE 50972
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50934: LD_VAR 0 2
50938: PPUSH
50939: CALL_OW 257
50943: PUSH
50944: LD_INT 5
50946: PUSH
50947: LD_INT 8
50949: PUSH
50950: LD_INT 9
50952: PUSH
50953: EMPTY
50954: LIST
50955: LIST
50956: LIST
50957: IN
50958: IFFALSE 50972
// SetClass ( unit , 1 ) ;
50960: LD_VAR 0 2
50964: PPUSH
50965: LD_INT 1
50967: PPUSH
50968: CALL_OW 336
// end ;
50972: LD_VAR 0 3
50976: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50977: LD_INT 0
50979: PPUSH
50980: PPUSH
// if not mc_bases or not skirmish then
50981: LD_EXP 93
50985: NOT
50986: PUSH
50987: LD_EXP 91
50991: NOT
50992: OR
50993: IFFALSE 50997
// exit ;
50995: GO 51113
// if GetLives ( abandoned_vehicle ) > 250 then
50997: LD_VAR 0 2
51001: PPUSH
51002: CALL_OW 256
51006: PUSH
51007: LD_INT 250
51009: GREATER
51010: IFFALSE 51014
// exit ;
51012: GO 51113
// for i = 1 to mc_bases do
51014: LD_ADDR_VAR 0 6
51018: PUSH
51019: DOUBLE
51020: LD_INT 1
51022: DEC
51023: ST_TO_ADDR
51024: LD_EXP 93
51028: PUSH
51029: FOR_TO
51030: IFFALSE 51111
// begin if driver in mc_bases [ i ] then
51032: LD_VAR 0 1
51036: PUSH
51037: LD_EXP 93
51041: PUSH
51042: LD_VAR 0 6
51046: ARRAY
51047: IN
51048: IFFALSE 51109
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51050: LD_VAR 0 1
51054: PPUSH
51055: LD_EXP 93
51059: PUSH
51060: LD_VAR 0 6
51064: ARRAY
51065: PPUSH
51066: LD_INT 2
51068: PUSH
51069: LD_INT 30
51071: PUSH
51072: LD_INT 0
51074: PUSH
51075: EMPTY
51076: LIST
51077: LIST
51078: PUSH
51079: LD_INT 30
51081: PUSH
51082: LD_INT 1
51084: PUSH
51085: EMPTY
51086: LIST
51087: LIST
51088: PUSH
51089: EMPTY
51090: LIST
51091: LIST
51092: LIST
51093: PPUSH
51094: CALL_OW 72
51098: PUSH
51099: LD_INT 1
51101: ARRAY
51102: PPUSH
51103: CALL 88723 0 2
// break ;
51107: GO 51111
// end ; end ;
51109: GO 51029
51111: POP
51112: POP
// end ; end_of_file
51113: LD_VAR 0 5
51117: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
51118: LD_INT 0
51120: PPUSH
51121: PPUSH
// if exist_mode then
51122: LD_VAR 0 2
51126: IFFALSE 51151
// unit := CreateCharacter ( prefix & ident ) else
51128: LD_ADDR_VAR 0 5
51132: PUSH
51133: LD_VAR 0 3
51137: PUSH
51138: LD_VAR 0 1
51142: STR
51143: PPUSH
51144: CALL_OW 34
51148: ST_TO_ADDR
51149: GO 51166
// unit := NewCharacter ( ident ) ;
51151: LD_ADDR_VAR 0 5
51155: PUSH
51156: LD_VAR 0 1
51160: PPUSH
51161: CALL_OW 25
51165: ST_TO_ADDR
// result := unit ;
51166: LD_ADDR_VAR 0 4
51170: PUSH
51171: LD_VAR 0 5
51175: ST_TO_ADDR
// end ;
51176: LD_VAR 0 4
51180: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
51181: LD_INT 0
51183: PPUSH
51184: PPUSH
// if not side or not nation then
51185: LD_VAR 0 1
51189: NOT
51190: PUSH
51191: LD_VAR 0 2
51195: NOT
51196: OR
51197: IFFALSE 51201
// exit ;
51199: GO 51969
// case nation of nation_american :
51201: LD_VAR 0 2
51205: PUSH
51206: LD_INT 1
51208: DOUBLE
51209: EQUAL
51210: IFTRUE 51214
51212: GO 51428
51214: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
51215: LD_ADDR_VAR 0 4
51219: PUSH
51220: LD_INT 35
51222: PUSH
51223: LD_INT 45
51225: PUSH
51226: LD_INT 46
51228: PUSH
51229: LD_INT 47
51231: PUSH
51232: LD_INT 82
51234: PUSH
51235: LD_INT 83
51237: PUSH
51238: LD_INT 84
51240: PUSH
51241: LD_INT 85
51243: PUSH
51244: LD_INT 86
51246: PUSH
51247: LD_INT 1
51249: PUSH
51250: LD_INT 2
51252: PUSH
51253: LD_INT 6
51255: PUSH
51256: LD_INT 15
51258: PUSH
51259: LD_INT 16
51261: PUSH
51262: LD_INT 7
51264: PUSH
51265: LD_INT 12
51267: PUSH
51268: LD_INT 13
51270: PUSH
51271: LD_INT 10
51273: PUSH
51274: LD_INT 14
51276: PUSH
51277: LD_INT 20
51279: PUSH
51280: LD_INT 21
51282: PUSH
51283: LD_INT 22
51285: PUSH
51286: LD_INT 25
51288: PUSH
51289: LD_INT 32
51291: PUSH
51292: LD_INT 27
51294: PUSH
51295: LD_INT 36
51297: PUSH
51298: LD_INT 69
51300: PUSH
51301: LD_INT 39
51303: PUSH
51304: LD_INT 34
51306: PUSH
51307: LD_INT 40
51309: PUSH
51310: LD_INT 48
51312: PUSH
51313: LD_INT 49
51315: PUSH
51316: LD_INT 50
51318: PUSH
51319: LD_INT 51
51321: PUSH
51322: LD_INT 52
51324: PUSH
51325: LD_INT 53
51327: PUSH
51328: LD_INT 54
51330: PUSH
51331: LD_INT 55
51333: PUSH
51334: LD_INT 56
51336: PUSH
51337: LD_INT 57
51339: PUSH
51340: LD_INT 58
51342: PUSH
51343: LD_INT 59
51345: PUSH
51346: LD_INT 60
51348: PUSH
51349: LD_INT 61
51351: PUSH
51352: LD_INT 62
51354: PUSH
51355: LD_INT 80
51357: PUSH
51358: LD_INT 82
51360: PUSH
51361: LD_INT 83
51363: PUSH
51364: LD_INT 84
51366: PUSH
51367: LD_INT 85
51369: PUSH
51370: LD_INT 86
51372: PUSH
51373: EMPTY
51374: LIST
51375: LIST
51376: LIST
51377: LIST
51378: LIST
51379: LIST
51380: LIST
51381: LIST
51382: LIST
51383: LIST
51384: LIST
51385: LIST
51386: LIST
51387: LIST
51388: LIST
51389: LIST
51390: LIST
51391: LIST
51392: LIST
51393: LIST
51394: LIST
51395: LIST
51396: LIST
51397: LIST
51398: LIST
51399: LIST
51400: LIST
51401: LIST
51402: LIST
51403: LIST
51404: LIST
51405: LIST
51406: LIST
51407: LIST
51408: LIST
51409: LIST
51410: LIST
51411: LIST
51412: LIST
51413: LIST
51414: LIST
51415: LIST
51416: LIST
51417: LIST
51418: LIST
51419: LIST
51420: LIST
51421: LIST
51422: LIST
51423: LIST
51424: LIST
51425: ST_TO_ADDR
51426: GO 51893
51428: LD_INT 2
51430: DOUBLE
51431: EQUAL
51432: IFTRUE 51436
51434: GO 51662
51436: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
51437: LD_ADDR_VAR 0 4
51441: PUSH
51442: LD_INT 35
51444: PUSH
51445: LD_INT 45
51447: PUSH
51448: LD_INT 46
51450: PUSH
51451: LD_INT 47
51453: PUSH
51454: LD_INT 82
51456: PUSH
51457: LD_INT 83
51459: PUSH
51460: LD_INT 84
51462: PUSH
51463: LD_INT 85
51465: PUSH
51466: LD_INT 87
51468: PUSH
51469: LD_INT 70
51471: PUSH
51472: LD_INT 1
51474: PUSH
51475: LD_INT 11
51477: PUSH
51478: LD_INT 3
51480: PUSH
51481: LD_INT 4
51483: PUSH
51484: LD_INT 5
51486: PUSH
51487: LD_INT 6
51489: PUSH
51490: LD_INT 15
51492: PUSH
51493: LD_INT 18
51495: PUSH
51496: LD_INT 7
51498: PUSH
51499: LD_INT 17
51501: PUSH
51502: LD_INT 8
51504: PUSH
51505: LD_INT 20
51507: PUSH
51508: LD_INT 21
51510: PUSH
51511: LD_INT 22
51513: PUSH
51514: LD_INT 72
51516: PUSH
51517: LD_INT 26
51519: PUSH
51520: LD_INT 69
51522: PUSH
51523: LD_INT 39
51525: PUSH
51526: LD_INT 40
51528: PUSH
51529: LD_INT 41
51531: PUSH
51532: LD_INT 42
51534: PUSH
51535: LD_INT 43
51537: PUSH
51538: LD_INT 48
51540: PUSH
51541: LD_INT 49
51543: PUSH
51544: LD_INT 50
51546: PUSH
51547: LD_INT 51
51549: PUSH
51550: LD_INT 52
51552: PUSH
51553: LD_INT 53
51555: PUSH
51556: LD_INT 54
51558: PUSH
51559: LD_INT 55
51561: PUSH
51562: LD_INT 56
51564: PUSH
51565: LD_INT 60
51567: PUSH
51568: LD_INT 61
51570: PUSH
51571: LD_INT 62
51573: PUSH
51574: LD_INT 66
51576: PUSH
51577: LD_INT 67
51579: PUSH
51580: LD_INT 68
51582: PUSH
51583: LD_INT 81
51585: PUSH
51586: LD_INT 82
51588: PUSH
51589: LD_INT 83
51591: PUSH
51592: LD_INT 84
51594: PUSH
51595: LD_INT 85
51597: PUSH
51598: LD_INT 87
51600: PUSH
51601: LD_INT 88
51603: PUSH
51604: EMPTY
51605: LIST
51606: LIST
51607: LIST
51608: LIST
51609: LIST
51610: LIST
51611: LIST
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: LIST
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: LIST
51622: LIST
51623: LIST
51624: LIST
51625: LIST
51626: LIST
51627: LIST
51628: LIST
51629: LIST
51630: LIST
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: LIST
51637: LIST
51638: LIST
51639: LIST
51640: LIST
51641: LIST
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: LIST
51649: LIST
51650: LIST
51651: LIST
51652: LIST
51653: LIST
51654: LIST
51655: LIST
51656: LIST
51657: LIST
51658: LIST
51659: ST_TO_ADDR
51660: GO 51893
51662: LD_INT 3
51664: DOUBLE
51665: EQUAL
51666: IFTRUE 51670
51668: GO 51892
51670: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51671: LD_ADDR_VAR 0 4
51675: PUSH
51676: LD_INT 46
51678: PUSH
51679: LD_INT 47
51681: PUSH
51682: LD_INT 1
51684: PUSH
51685: LD_INT 2
51687: PUSH
51688: LD_INT 82
51690: PUSH
51691: LD_INT 83
51693: PUSH
51694: LD_INT 84
51696: PUSH
51697: LD_INT 85
51699: PUSH
51700: LD_INT 86
51702: PUSH
51703: LD_INT 11
51705: PUSH
51706: LD_INT 9
51708: PUSH
51709: LD_INT 20
51711: PUSH
51712: LD_INT 19
51714: PUSH
51715: LD_INT 21
51717: PUSH
51718: LD_INT 24
51720: PUSH
51721: LD_INT 22
51723: PUSH
51724: LD_INT 25
51726: PUSH
51727: LD_INT 28
51729: PUSH
51730: LD_INT 29
51732: PUSH
51733: LD_INT 30
51735: PUSH
51736: LD_INT 31
51738: PUSH
51739: LD_INT 37
51741: PUSH
51742: LD_INT 38
51744: PUSH
51745: LD_INT 32
51747: PUSH
51748: LD_INT 27
51750: PUSH
51751: LD_INT 33
51753: PUSH
51754: LD_INT 69
51756: PUSH
51757: LD_INT 39
51759: PUSH
51760: LD_INT 34
51762: PUSH
51763: LD_INT 40
51765: PUSH
51766: LD_INT 71
51768: PUSH
51769: LD_INT 23
51771: PUSH
51772: LD_INT 44
51774: PUSH
51775: LD_INT 48
51777: PUSH
51778: LD_INT 49
51780: PUSH
51781: LD_INT 50
51783: PUSH
51784: LD_INT 51
51786: PUSH
51787: LD_INT 52
51789: PUSH
51790: LD_INT 53
51792: PUSH
51793: LD_INT 54
51795: PUSH
51796: LD_INT 55
51798: PUSH
51799: LD_INT 56
51801: PUSH
51802: LD_INT 57
51804: PUSH
51805: LD_INT 58
51807: PUSH
51808: LD_INT 59
51810: PUSH
51811: LD_INT 63
51813: PUSH
51814: LD_INT 64
51816: PUSH
51817: LD_INT 65
51819: PUSH
51820: LD_INT 82
51822: PUSH
51823: LD_INT 83
51825: PUSH
51826: LD_INT 84
51828: PUSH
51829: LD_INT 85
51831: PUSH
51832: LD_INT 86
51834: PUSH
51835: EMPTY
51836: LIST
51837: LIST
51838: LIST
51839: LIST
51840: LIST
51841: LIST
51842: LIST
51843: LIST
51844: LIST
51845: LIST
51846: LIST
51847: LIST
51848: LIST
51849: LIST
51850: LIST
51851: LIST
51852: LIST
51853: LIST
51854: LIST
51855: LIST
51856: LIST
51857: LIST
51858: LIST
51859: LIST
51860: LIST
51861: LIST
51862: LIST
51863: LIST
51864: LIST
51865: LIST
51866: LIST
51867: LIST
51868: LIST
51869: LIST
51870: LIST
51871: LIST
51872: LIST
51873: LIST
51874: LIST
51875: LIST
51876: LIST
51877: LIST
51878: LIST
51879: LIST
51880: LIST
51881: LIST
51882: LIST
51883: LIST
51884: LIST
51885: LIST
51886: LIST
51887: LIST
51888: LIST
51889: ST_TO_ADDR
51890: GO 51893
51892: POP
// if state > - 1 and state < 3 then
51893: LD_VAR 0 3
51897: PUSH
51898: LD_INT 1
51900: NEG
51901: GREATER
51902: PUSH
51903: LD_VAR 0 3
51907: PUSH
51908: LD_INT 3
51910: LESS
51911: AND
51912: IFFALSE 51969
// for i in result do
51914: LD_ADDR_VAR 0 5
51918: PUSH
51919: LD_VAR 0 4
51923: PUSH
51924: FOR_IN
51925: IFFALSE 51967
// if GetTech ( i , side ) <> state then
51927: LD_VAR 0 5
51931: PPUSH
51932: LD_VAR 0 1
51936: PPUSH
51937: CALL_OW 321
51941: PUSH
51942: LD_VAR 0 3
51946: NONEQUAL
51947: IFFALSE 51965
// result := result diff i ;
51949: LD_ADDR_VAR 0 4
51953: PUSH
51954: LD_VAR 0 4
51958: PUSH
51959: LD_VAR 0 5
51963: DIFF
51964: ST_TO_ADDR
51965: GO 51924
51967: POP
51968: POP
// end ;
51969: LD_VAR 0 4
51973: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51974: LD_INT 0
51976: PPUSH
51977: PPUSH
51978: PPUSH
// result := true ;
51979: LD_ADDR_VAR 0 3
51983: PUSH
51984: LD_INT 1
51986: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51987: LD_ADDR_VAR 0 5
51991: PUSH
51992: LD_VAR 0 2
51996: PPUSH
51997: CALL_OW 480
52001: ST_TO_ADDR
// if not tmp then
52002: LD_VAR 0 5
52006: NOT
52007: IFFALSE 52011
// exit ;
52009: GO 52060
// for i in tmp do
52011: LD_ADDR_VAR 0 4
52015: PUSH
52016: LD_VAR 0 5
52020: PUSH
52021: FOR_IN
52022: IFFALSE 52058
// if GetTech ( i , side ) <> state_researched then
52024: LD_VAR 0 4
52028: PPUSH
52029: LD_VAR 0 1
52033: PPUSH
52034: CALL_OW 321
52038: PUSH
52039: LD_INT 2
52041: NONEQUAL
52042: IFFALSE 52056
// begin result := false ;
52044: LD_ADDR_VAR 0 3
52048: PUSH
52049: LD_INT 0
52051: ST_TO_ADDR
// exit ;
52052: POP
52053: POP
52054: GO 52060
// end ;
52056: GO 52021
52058: POP
52059: POP
// end ;
52060: LD_VAR 0 3
52064: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52065: LD_INT 0
52067: PPUSH
52068: PPUSH
52069: PPUSH
52070: PPUSH
52071: PPUSH
52072: PPUSH
52073: PPUSH
52074: PPUSH
52075: PPUSH
52076: PPUSH
52077: PPUSH
52078: PPUSH
52079: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52080: LD_VAR 0 1
52084: NOT
52085: PUSH
52086: LD_VAR 0 1
52090: PPUSH
52091: CALL_OW 257
52095: PUSH
52096: LD_INT 9
52098: NONEQUAL
52099: OR
52100: IFFALSE 52104
// exit ;
52102: GO 52677
// side := GetSide ( unit ) ;
52104: LD_ADDR_VAR 0 9
52108: PUSH
52109: LD_VAR 0 1
52113: PPUSH
52114: CALL_OW 255
52118: ST_TO_ADDR
// tech_space := tech_spacanom ;
52119: LD_ADDR_VAR 0 12
52123: PUSH
52124: LD_INT 29
52126: ST_TO_ADDR
// tech_time := tech_taurad ;
52127: LD_ADDR_VAR 0 13
52131: PUSH
52132: LD_INT 28
52134: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
52135: LD_ADDR_VAR 0 11
52139: PUSH
52140: LD_VAR 0 1
52144: PPUSH
52145: CALL_OW 310
52149: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
52150: LD_VAR 0 11
52154: PPUSH
52155: CALL_OW 247
52159: PUSH
52160: LD_INT 2
52162: EQUAL
52163: IFFALSE 52167
// exit ;
52165: GO 52677
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52167: LD_ADDR_VAR 0 8
52171: PUSH
52172: LD_INT 81
52174: PUSH
52175: LD_VAR 0 9
52179: PUSH
52180: EMPTY
52181: LIST
52182: LIST
52183: PUSH
52184: LD_INT 3
52186: PUSH
52187: LD_INT 21
52189: PUSH
52190: LD_INT 3
52192: PUSH
52193: EMPTY
52194: LIST
52195: LIST
52196: PUSH
52197: EMPTY
52198: LIST
52199: LIST
52200: PUSH
52201: EMPTY
52202: LIST
52203: LIST
52204: PPUSH
52205: CALL_OW 69
52209: ST_TO_ADDR
// if not tmp then
52210: LD_VAR 0 8
52214: NOT
52215: IFFALSE 52219
// exit ;
52217: GO 52677
// if in_unit then
52219: LD_VAR 0 11
52223: IFFALSE 52247
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
52225: LD_ADDR_VAR 0 10
52229: PUSH
52230: LD_VAR 0 8
52234: PPUSH
52235: LD_VAR 0 11
52239: PPUSH
52240: CALL_OW 74
52244: ST_TO_ADDR
52245: GO 52267
// enemy := NearestUnitToUnit ( tmp , unit ) ;
52247: LD_ADDR_VAR 0 10
52251: PUSH
52252: LD_VAR 0 8
52256: PPUSH
52257: LD_VAR 0 1
52261: PPUSH
52262: CALL_OW 74
52266: ST_TO_ADDR
// if not enemy then
52267: LD_VAR 0 10
52271: NOT
52272: IFFALSE 52276
// exit ;
52274: GO 52677
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
52276: LD_VAR 0 11
52280: PUSH
52281: LD_VAR 0 11
52285: PPUSH
52286: LD_VAR 0 10
52290: PPUSH
52291: CALL_OW 296
52295: PUSH
52296: LD_INT 13
52298: GREATER
52299: AND
52300: PUSH
52301: LD_VAR 0 1
52305: PPUSH
52306: LD_VAR 0 10
52310: PPUSH
52311: CALL_OW 296
52315: PUSH
52316: LD_INT 12
52318: GREATER
52319: OR
52320: IFFALSE 52324
// exit ;
52322: GO 52677
// missile := [ 1 ] ;
52324: LD_ADDR_VAR 0 14
52328: PUSH
52329: LD_INT 1
52331: PUSH
52332: EMPTY
52333: LIST
52334: ST_TO_ADDR
// if Researched ( side , tech_space ) then
52335: LD_VAR 0 9
52339: PPUSH
52340: LD_VAR 0 12
52344: PPUSH
52345: CALL_OW 325
52349: IFFALSE 52378
// missile := Insert ( missile , missile + 1 , 2 ) ;
52351: LD_ADDR_VAR 0 14
52355: PUSH
52356: LD_VAR 0 14
52360: PPUSH
52361: LD_VAR 0 14
52365: PUSH
52366: LD_INT 1
52368: PLUS
52369: PPUSH
52370: LD_INT 2
52372: PPUSH
52373: CALL_OW 2
52377: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52378: LD_VAR 0 9
52382: PPUSH
52383: LD_VAR 0 13
52387: PPUSH
52388: CALL_OW 325
52392: PUSH
52393: LD_VAR 0 10
52397: PPUSH
52398: CALL_OW 255
52402: PPUSH
52403: LD_VAR 0 13
52407: PPUSH
52408: CALL_OW 325
52412: NOT
52413: AND
52414: IFFALSE 52443
// missile := Insert ( missile , missile + 1 , 3 ) ;
52416: LD_ADDR_VAR 0 14
52420: PUSH
52421: LD_VAR 0 14
52425: PPUSH
52426: LD_VAR 0 14
52430: PUSH
52431: LD_INT 1
52433: PLUS
52434: PPUSH
52435: LD_INT 3
52437: PPUSH
52438: CALL_OW 2
52442: ST_TO_ADDR
// if missile < 2 then
52443: LD_VAR 0 14
52447: PUSH
52448: LD_INT 2
52450: LESS
52451: IFFALSE 52455
// exit ;
52453: GO 52677
// x := GetX ( enemy ) ;
52455: LD_ADDR_VAR 0 4
52459: PUSH
52460: LD_VAR 0 10
52464: PPUSH
52465: CALL_OW 250
52469: ST_TO_ADDR
// y := GetY ( enemy ) ;
52470: LD_ADDR_VAR 0 5
52474: PUSH
52475: LD_VAR 0 10
52479: PPUSH
52480: CALL_OW 251
52484: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52485: LD_ADDR_VAR 0 6
52489: PUSH
52490: LD_VAR 0 4
52494: PUSH
52495: LD_INT 1
52497: NEG
52498: PPUSH
52499: LD_INT 1
52501: PPUSH
52502: CALL_OW 12
52506: PLUS
52507: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52508: LD_ADDR_VAR 0 7
52512: PUSH
52513: LD_VAR 0 5
52517: PUSH
52518: LD_INT 1
52520: NEG
52521: PPUSH
52522: LD_INT 1
52524: PPUSH
52525: CALL_OW 12
52529: PLUS
52530: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52531: LD_VAR 0 6
52535: PPUSH
52536: LD_VAR 0 7
52540: PPUSH
52541: CALL_OW 488
52545: NOT
52546: IFFALSE 52568
// begin _x := x ;
52548: LD_ADDR_VAR 0 6
52552: PUSH
52553: LD_VAR 0 4
52557: ST_TO_ADDR
// _y := y ;
52558: LD_ADDR_VAR 0 7
52562: PUSH
52563: LD_VAR 0 5
52567: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52568: LD_ADDR_VAR 0 3
52572: PUSH
52573: LD_INT 1
52575: PPUSH
52576: LD_VAR 0 14
52580: PPUSH
52581: CALL_OW 12
52585: ST_TO_ADDR
// case i of 1 :
52586: LD_VAR 0 3
52590: PUSH
52591: LD_INT 1
52593: DOUBLE
52594: EQUAL
52595: IFTRUE 52599
52597: GO 52616
52599: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52600: LD_VAR 0 1
52604: PPUSH
52605: LD_VAR 0 10
52609: PPUSH
52610: CALL_OW 115
52614: GO 52677
52616: LD_INT 2
52618: DOUBLE
52619: EQUAL
52620: IFTRUE 52624
52622: GO 52646
52624: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52625: LD_VAR 0 1
52629: PPUSH
52630: LD_VAR 0 6
52634: PPUSH
52635: LD_VAR 0 7
52639: PPUSH
52640: CALL_OW 153
52644: GO 52677
52646: LD_INT 3
52648: DOUBLE
52649: EQUAL
52650: IFTRUE 52654
52652: GO 52676
52654: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52655: LD_VAR 0 1
52659: PPUSH
52660: LD_VAR 0 6
52664: PPUSH
52665: LD_VAR 0 7
52669: PPUSH
52670: CALL_OW 154
52674: GO 52677
52676: POP
// end ;
52677: LD_VAR 0 2
52681: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52682: LD_INT 0
52684: PPUSH
52685: PPUSH
52686: PPUSH
52687: PPUSH
52688: PPUSH
52689: PPUSH
// if not unit or not building then
52690: LD_VAR 0 1
52694: NOT
52695: PUSH
52696: LD_VAR 0 2
52700: NOT
52701: OR
52702: IFFALSE 52706
// exit ;
52704: GO 52864
// x := GetX ( building ) ;
52706: LD_ADDR_VAR 0 5
52710: PUSH
52711: LD_VAR 0 2
52715: PPUSH
52716: CALL_OW 250
52720: ST_TO_ADDR
// y := GetY ( building ) ;
52721: LD_ADDR_VAR 0 6
52725: PUSH
52726: LD_VAR 0 2
52730: PPUSH
52731: CALL_OW 251
52735: ST_TO_ADDR
// for i = 0 to 5 do
52736: LD_ADDR_VAR 0 4
52740: PUSH
52741: DOUBLE
52742: LD_INT 0
52744: DEC
52745: ST_TO_ADDR
52746: LD_INT 5
52748: PUSH
52749: FOR_TO
52750: IFFALSE 52862
// begin _x := ShiftX ( x , i , 3 ) ;
52752: LD_ADDR_VAR 0 7
52756: PUSH
52757: LD_VAR 0 5
52761: PPUSH
52762: LD_VAR 0 4
52766: PPUSH
52767: LD_INT 3
52769: PPUSH
52770: CALL_OW 272
52774: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52775: LD_ADDR_VAR 0 8
52779: PUSH
52780: LD_VAR 0 6
52784: PPUSH
52785: LD_VAR 0 4
52789: PPUSH
52790: LD_INT 3
52792: PPUSH
52793: CALL_OW 273
52797: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52798: LD_VAR 0 7
52802: PPUSH
52803: LD_VAR 0 8
52807: PPUSH
52808: CALL_OW 488
52812: NOT
52813: IFFALSE 52817
// continue ;
52815: GO 52749
// if HexInfo ( _x , _y ) = 0 then
52817: LD_VAR 0 7
52821: PPUSH
52822: LD_VAR 0 8
52826: PPUSH
52827: CALL_OW 428
52831: PUSH
52832: LD_INT 0
52834: EQUAL
52835: IFFALSE 52860
// begin ComMoveXY ( unit , _x , _y ) ;
52837: LD_VAR 0 1
52841: PPUSH
52842: LD_VAR 0 7
52846: PPUSH
52847: LD_VAR 0 8
52851: PPUSH
52852: CALL_OW 111
// exit ;
52856: POP
52857: POP
52858: GO 52864
// end ; end ;
52860: GO 52749
52862: POP
52863: POP
// end ;
52864: LD_VAR 0 3
52868: RET
// export function ScanBase ( side , base_area ) ; begin
52869: LD_INT 0
52871: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52872: LD_ADDR_VAR 0 3
52876: PUSH
52877: LD_VAR 0 2
52881: PPUSH
52882: LD_INT 81
52884: PUSH
52885: LD_VAR 0 1
52889: PUSH
52890: EMPTY
52891: LIST
52892: LIST
52893: PPUSH
52894: CALL_OW 70
52898: ST_TO_ADDR
// end ;
52899: LD_VAR 0 3
52903: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
52904: LD_INT 0
52906: PPUSH
52907: PPUSH
52908: PPUSH
52909: PPUSH
// result := false ;
52910: LD_ADDR_VAR 0 2
52914: PUSH
52915: LD_INT 0
52917: ST_TO_ADDR
// side := GetSide ( unit ) ;
52918: LD_ADDR_VAR 0 3
52922: PUSH
52923: LD_VAR 0 1
52927: PPUSH
52928: CALL_OW 255
52932: ST_TO_ADDR
// nat := GetNation ( unit ) ;
52933: LD_ADDR_VAR 0 4
52937: PUSH
52938: LD_VAR 0 1
52942: PPUSH
52943: CALL_OW 248
52947: ST_TO_ADDR
// case nat of 1 :
52948: LD_VAR 0 4
52952: PUSH
52953: LD_INT 1
52955: DOUBLE
52956: EQUAL
52957: IFTRUE 52961
52959: GO 52972
52961: POP
// tech := tech_lassight ; 2 :
52962: LD_ADDR_VAR 0 5
52966: PUSH
52967: LD_INT 12
52969: ST_TO_ADDR
52970: GO 53011
52972: LD_INT 2
52974: DOUBLE
52975: EQUAL
52976: IFTRUE 52980
52978: GO 52991
52980: POP
// tech := tech_mortar ; 3 :
52981: LD_ADDR_VAR 0 5
52985: PUSH
52986: LD_INT 41
52988: ST_TO_ADDR
52989: GO 53011
52991: LD_INT 3
52993: DOUBLE
52994: EQUAL
52995: IFTRUE 52999
52997: GO 53010
52999: POP
// tech := tech_bazooka ; end ;
53000: LD_ADDR_VAR 0 5
53004: PUSH
53005: LD_INT 44
53007: ST_TO_ADDR
53008: GO 53011
53010: POP
// if Researched ( side , tech ) then
53011: LD_VAR 0 3
53015: PPUSH
53016: LD_VAR 0 5
53020: PPUSH
53021: CALL_OW 325
53025: IFFALSE 53052
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53027: LD_ADDR_VAR 0 2
53031: PUSH
53032: LD_INT 5
53034: PUSH
53035: LD_INT 8
53037: PUSH
53038: LD_INT 9
53040: PUSH
53041: EMPTY
53042: LIST
53043: LIST
53044: LIST
53045: PUSH
53046: LD_VAR 0 4
53050: ARRAY
53051: ST_TO_ADDR
// end ;
53052: LD_VAR 0 2
53056: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53057: LD_INT 0
53059: PPUSH
53060: PPUSH
53061: PPUSH
// if not mines then
53062: LD_VAR 0 2
53066: NOT
53067: IFFALSE 53071
// exit ;
53069: GO 53215
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53071: LD_ADDR_VAR 0 5
53075: PUSH
53076: LD_INT 81
53078: PUSH
53079: LD_VAR 0 1
53083: PUSH
53084: EMPTY
53085: LIST
53086: LIST
53087: PUSH
53088: LD_INT 3
53090: PUSH
53091: LD_INT 21
53093: PUSH
53094: LD_INT 3
53096: PUSH
53097: EMPTY
53098: LIST
53099: LIST
53100: PUSH
53101: EMPTY
53102: LIST
53103: LIST
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: PPUSH
53109: CALL_OW 69
53113: ST_TO_ADDR
// for i in mines do
53114: LD_ADDR_VAR 0 4
53118: PUSH
53119: LD_VAR 0 2
53123: PUSH
53124: FOR_IN
53125: IFFALSE 53213
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53127: LD_VAR 0 4
53131: PUSH
53132: LD_INT 1
53134: ARRAY
53135: PPUSH
53136: LD_VAR 0 4
53140: PUSH
53141: LD_INT 2
53143: ARRAY
53144: PPUSH
53145: CALL_OW 458
53149: NOT
53150: IFFALSE 53154
// continue ;
53152: GO 53124
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53154: LD_VAR 0 4
53158: PUSH
53159: LD_INT 1
53161: ARRAY
53162: PPUSH
53163: LD_VAR 0 4
53167: PUSH
53168: LD_INT 2
53170: ARRAY
53171: PPUSH
53172: CALL_OW 428
53176: PUSH
53177: LD_VAR 0 5
53181: IN
53182: IFFALSE 53211
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53184: LD_VAR 0 4
53188: PUSH
53189: LD_INT 1
53191: ARRAY
53192: PPUSH
53193: LD_VAR 0 4
53197: PUSH
53198: LD_INT 2
53200: ARRAY
53201: PPUSH
53202: LD_VAR 0 1
53206: PPUSH
53207: CALL_OW 456
// end ;
53211: GO 53124
53213: POP
53214: POP
// end ;
53215: LD_VAR 0 3
53219: RET
// export function Count ( array ) ; var i ; begin
53220: LD_INT 0
53222: PPUSH
53223: PPUSH
// result := 0 ;
53224: LD_ADDR_VAR 0 2
53228: PUSH
53229: LD_INT 0
53231: ST_TO_ADDR
// for i in array do
53232: LD_ADDR_VAR 0 3
53236: PUSH
53237: LD_VAR 0 1
53241: PUSH
53242: FOR_IN
53243: IFFALSE 53267
// if i then
53245: LD_VAR 0 3
53249: IFFALSE 53265
// result := result + 1 ;
53251: LD_ADDR_VAR 0 2
53255: PUSH
53256: LD_VAR 0 2
53260: PUSH
53261: LD_INT 1
53263: PLUS
53264: ST_TO_ADDR
53265: GO 53242
53267: POP
53268: POP
// end ;
53269: LD_VAR 0 2
53273: RET
// export function IsEmpty ( building ) ; begin
53274: LD_INT 0
53276: PPUSH
// if not building then
53277: LD_VAR 0 1
53281: NOT
53282: IFFALSE 53286
// exit ;
53284: GO 53329
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53286: LD_ADDR_VAR 0 2
53290: PUSH
53291: LD_VAR 0 1
53295: PUSH
53296: LD_INT 22
53298: PUSH
53299: LD_VAR 0 1
53303: PPUSH
53304: CALL_OW 255
53308: PUSH
53309: EMPTY
53310: LIST
53311: LIST
53312: PUSH
53313: LD_INT 58
53315: PUSH
53316: EMPTY
53317: LIST
53318: PUSH
53319: EMPTY
53320: LIST
53321: LIST
53322: PPUSH
53323: CALL_OW 69
53327: IN
53328: ST_TO_ADDR
// end ;
53329: LD_VAR 0 2
53333: RET
// export function IsNotFull ( building ) ; begin
53334: LD_INT 0
53336: PPUSH
// if not building then
53337: LD_VAR 0 1
53341: NOT
53342: IFFALSE 53346
// exit ;
53344: GO 53365
// result := UnitsInside ( building ) < 6 ;
53346: LD_ADDR_VAR 0 2
53350: PUSH
53351: LD_VAR 0 1
53355: PPUSH
53356: CALL_OW 313
53360: PUSH
53361: LD_INT 6
53363: LESS
53364: ST_TO_ADDR
// end ;
53365: LD_VAR 0 2
53369: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53370: LD_INT 0
53372: PPUSH
53373: PPUSH
53374: PPUSH
53375: PPUSH
// tmp := [ ] ;
53376: LD_ADDR_VAR 0 3
53380: PUSH
53381: EMPTY
53382: ST_TO_ADDR
// list := [ ] ;
53383: LD_ADDR_VAR 0 5
53387: PUSH
53388: EMPTY
53389: ST_TO_ADDR
// for i = 16 to 25 do
53390: LD_ADDR_VAR 0 4
53394: PUSH
53395: DOUBLE
53396: LD_INT 16
53398: DEC
53399: ST_TO_ADDR
53400: LD_INT 25
53402: PUSH
53403: FOR_TO
53404: IFFALSE 53477
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53406: LD_ADDR_VAR 0 3
53410: PUSH
53411: LD_VAR 0 3
53415: PUSH
53416: LD_INT 22
53418: PUSH
53419: LD_VAR 0 1
53423: PPUSH
53424: CALL_OW 255
53428: PUSH
53429: EMPTY
53430: LIST
53431: LIST
53432: PUSH
53433: LD_INT 91
53435: PUSH
53436: LD_VAR 0 1
53440: PUSH
53441: LD_INT 6
53443: PUSH
53444: EMPTY
53445: LIST
53446: LIST
53447: LIST
53448: PUSH
53449: LD_INT 30
53451: PUSH
53452: LD_VAR 0 4
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: PUSH
53461: EMPTY
53462: LIST
53463: LIST
53464: LIST
53465: PUSH
53466: EMPTY
53467: LIST
53468: PPUSH
53469: CALL_OW 69
53473: ADD
53474: ST_TO_ADDR
53475: GO 53403
53477: POP
53478: POP
// for i = 1 to tmp do
53479: LD_ADDR_VAR 0 4
53483: PUSH
53484: DOUBLE
53485: LD_INT 1
53487: DEC
53488: ST_TO_ADDR
53489: LD_VAR 0 3
53493: PUSH
53494: FOR_TO
53495: IFFALSE 53583
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53497: LD_ADDR_VAR 0 5
53501: PUSH
53502: LD_VAR 0 5
53506: PUSH
53507: LD_VAR 0 3
53511: PUSH
53512: LD_VAR 0 4
53516: ARRAY
53517: PPUSH
53518: CALL_OW 266
53522: PUSH
53523: LD_VAR 0 3
53527: PUSH
53528: LD_VAR 0 4
53532: ARRAY
53533: PPUSH
53534: CALL_OW 250
53538: PUSH
53539: LD_VAR 0 3
53543: PUSH
53544: LD_VAR 0 4
53548: ARRAY
53549: PPUSH
53550: CALL_OW 251
53554: PUSH
53555: LD_VAR 0 3
53559: PUSH
53560: LD_VAR 0 4
53564: ARRAY
53565: PPUSH
53566: CALL_OW 254
53570: PUSH
53571: EMPTY
53572: LIST
53573: LIST
53574: LIST
53575: LIST
53576: PUSH
53577: EMPTY
53578: LIST
53579: ADD
53580: ST_TO_ADDR
53581: GO 53494
53583: POP
53584: POP
// result := list ;
53585: LD_ADDR_VAR 0 2
53589: PUSH
53590: LD_VAR 0 5
53594: ST_TO_ADDR
// end ;
53595: LD_VAR 0 2
53599: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53600: LD_INT 0
53602: PPUSH
53603: PPUSH
53604: PPUSH
53605: PPUSH
53606: PPUSH
53607: PPUSH
53608: PPUSH
// if not factory then
53609: LD_VAR 0 1
53613: NOT
53614: IFFALSE 53618
// exit ;
53616: GO 54211
// if control = control_apeman then
53618: LD_VAR 0 4
53622: PUSH
53623: LD_INT 5
53625: EQUAL
53626: IFFALSE 53735
// begin tmp := UnitsInside ( factory ) ;
53628: LD_ADDR_VAR 0 8
53632: PUSH
53633: LD_VAR 0 1
53637: PPUSH
53638: CALL_OW 313
53642: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53643: LD_VAR 0 8
53647: PPUSH
53648: LD_INT 25
53650: PUSH
53651: LD_INT 12
53653: PUSH
53654: EMPTY
53655: LIST
53656: LIST
53657: PPUSH
53658: CALL_OW 72
53662: NOT
53663: IFFALSE 53673
// control := control_manual ;
53665: LD_ADDR_VAR 0 4
53669: PUSH
53670: LD_INT 1
53672: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53673: LD_ADDR_VAR 0 8
53677: PUSH
53678: LD_VAR 0 1
53682: PPUSH
53683: CALL 53370 0 1
53687: ST_TO_ADDR
// if tmp then
53688: LD_VAR 0 8
53692: IFFALSE 53735
// begin for i in tmp do
53694: LD_ADDR_VAR 0 7
53698: PUSH
53699: LD_VAR 0 8
53703: PUSH
53704: FOR_IN
53705: IFFALSE 53733
// if i [ 1 ] = b_ext_radio then
53707: LD_VAR 0 7
53711: PUSH
53712: LD_INT 1
53714: ARRAY
53715: PUSH
53716: LD_INT 22
53718: EQUAL
53719: IFFALSE 53731
// begin control := control_remote ;
53721: LD_ADDR_VAR 0 4
53725: PUSH
53726: LD_INT 2
53728: ST_TO_ADDR
// break ;
53729: GO 53733
// end ;
53731: GO 53704
53733: POP
53734: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53735: LD_VAR 0 1
53739: PPUSH
53740: LD_VAR 0 2
53744: PPUSH
53745: LD_VAR 0 3
53749: PPUSH
53750: LD_VAR 0 4
53754: PPUSH
53755: LD_VAR 0 5
53759: PPUSH
53760: CALL_OW 448
53764: IFFALSE 53799
// begin result := [ chassis , engine , control , weapon ] ;
53766: LD_ADDR_VAR 0 6
53770: PUSH
53771: LD_VAR 0 2
53775: PUSH
53776: LD_VAR 0 3
53780: PUSH
53781: LD_VAR 0 4
53785: PUSH
53786: LD_VAR 0 5
53790: PUSH
53791: EMPTY
53792: LIST
53793: LIST
53794: LIST
53795: LIST
53796: ST_TO_ADDR
// exit ;
53797: GO 54211
// end ; _chassis := AvailableChassisList ( factory ) ;
53799: LD_ADDR_VAR 0 9
53803: PUSH
53804: LD_VAR 0 1
53808: PPUSH
53809: CALL_OW 475
53813: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53814: LD_ADDR_VAR 0 11
53818: PUSH
53819: LD_VAR 0 1
53823: PPUSH
53824: CALL_OW 476
53828: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53829: LD_ADDR_VAR 0 12
53833: PUSH
53834: LD_VAR 0 1
53838: PPUSH
53839: CALL_OW 477
53843: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
53844: LD_ADDR_VAR 0 10
53848: PUSH
53849: LD_VAR 0 1
53853: PPUSH
53854: CALL_OW 478
53858: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
53859: LD_VAR 0 9
53863: NOT
53864: PUSH
53865: LD_VAR 0 11
53869: NOT
53870: OR
53871: PUSH
53872: LD_VAR 0 12
53876: NOT
53877: OR
53878: PUSH
53879: LD_VAR 0 10
53883: NOT
53884: OR
53885: IFFALSE 53920
// begin result := [ chassis , engine , control , weapon ] ;
53887: LD_ADDR_VAR 0 6
53891: PUSH
53892: LD_VAR 0 2
53896: PUSH
53897: LD_VAR 0 3
53901: PUSH
53902: LD_VAR 0 4
53906: PUSH
53907: LD_VAR 0 5
53911: PUSH
53912: EMPTY
53913: LIST
53914: LIST
53915: LIST
53916: LIST
53917: ST_TO_ADDR
// exit ;
53918: GO 54211
// end ; if not chassis in _chassis then
53920: LD_VAR 0 2
53924: PUSH
53925: LD_VAR 0 9
53929: IN
53930: NOT
53931: IFFALSE 53957
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
53933: LD_ADDR_VAR 0 2
53937: PUSH
53938: LD_VAR 0 9
53942: PUSH
53943: LD_INT 1
53945: PPUSH
53946: LD_VAR 0 9
53950: PPUSH
53951: CALL_OW 12
53955: ARRAY
53956: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
53957: LD_VAR 0 2
53961: PPUSH
53962: LD_VAR 0 3
53966: PPUSH
53967: CALL 54216 0 2
53971: NOT
53972: IFFALSE 54031
// repeat engine := _engine [ 1 ] ;
53974: LD_ADDR_VAR 0 3
53978: PUSH
53979: LD_VAR 0 11
53983: PUSH
53984: LD_INT 1
53986: ARRAY
53987: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
53988: LD_ADDR_VAR 0 11
53992: PUSH
53993: LD_VAR 0 11
53997: PPUSH
53998: LD_INT 1
54000: PPUSH
54001: CALL_OW 3
54005: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54006: LD_VAR 0 2
54010: PPUSH
54011: LD_VAR 0 3
54015: PPUSH
54016: CALL 54216 0 2
54020: PUSH
54021: LD_VAR 0 11
54025: PUSH
54026: EMPTY
54027: EQUAL
54028: OR
54029: IFFALSE 53974
// if not control in _control then
54031: LD_VAR 0 4
54035: PUSH
54036: LD_VAR 0 12
54040: IN
54041: NOT
54042: IFFALSE 54068
// control := _control [ rand ( 1 , _control ) ] ;
54044: LD_ADDR_VAR 0 4
54048: PUSH
54049: LD_VAR 0 12
54053: PUSH
54054: LD_INT 1
54056: PPUSH
54057: LD_VAR 0 12
54061: PPUSH
54062: CALL_OW 12
54066: ARRAY
54067: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54068: LD_VAR 0 2
54072: PPUSH
54073: LD_VAR 0 5
54077: PPUSH
54078: CALL 54436 0 2
54082: NOT
54083: IFFALSE 54142
// repeat weapon := _weapon [ 1 ] ;
54085: LD_ADDR_VAR 0 5
54089: PUSH
54090: LD_VAR 0 10
54094: PUSH
54095: LD_INT 1
54097: ARRAY
54098: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54099: LD_ADDR_VAR 0 10
54103: PUSH
54104: LD_VAR 0 10
54108: PPUSH
54109: LD_INT 1
54111: PPUSH
54112: CALL_OW 3
54116: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
54117: LD_VAR 0 2
54121: PPUSH
54122: LD_VAR 0 5
54126: PPUSH
54127: CALL 54436 0 2
54131: PUSH
54132: LD_VAR 0 10
54136: PUSH
54137: EMPTY
54138: EQUAL
54139: OR
54140: IFFALSE 54085
// result := [ ] ;
54142: LD_ADDR_VAR 0 6
54146: PUSH
54147: EMPTY
54148: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54149: LD_VAR 0 1
54153: PPUSH
54154: LD_VAR 0 2
54158: PPUSH
54159: LD_VAR 0 3
54163: PPUSH
54164: LD_VAR 0 4
54168: PPUSH
54169: LD_VAR 0 5
54173: PPUSH
54174: CALL_OW 448
54178: IFFALSE 54211
// result := [ chassis , engine , control , weapon ] ;
54180: LD_ADDR_VAR 0 6
54184: PUSH
54185: LD_VAR 0 2
54189: PUSH
54190: LD_VAR 0 3
54194: PUSH
54195: LD_VAR 0 4
54199: PUSH
54200: LD_VAR 0 5
54204: PUSH
54205: EMPTY
54206: LIST
54207: LIST
54208: LIST
54209: LIST
54210: ST_TO_ADDR
// end ;
54211: LD_VAR 0 6
54215: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
54216: LD_INT 0
54218: PPUSH
// if not chassis or not engine then
54219: LD_VAR 0 1
54223: NOT
54224: PUSH
54225: LD_VAR 0 2
54229: NOT
54230: OR
54231: IFFALSE 54235
// exit ;
54233: GO 54431
// case engine of engine_solar :
54235: LD_VAR 0 2
54239: PUSH
54240: LD_INT 2
54242: DOUBLE
54243: EQUAL
54244: IFTRUE 54248
54246: GO 54286
54248: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
54249: LD_ADDR_VAR 0 3
54253: PUSH
54254: LD_INT 11
54256: PUSH
54257: LD_INT 12
54259: PUSH
54260: LD_INT 13
54262: PUSH
54263: LD_INT 14
54265: PUSH
54266: LD_INT 1
54268: PUSH
54269: LD_INT 2
54271: PUSH
54272: LD_INT 3
54274: PUSH
54275: EMPTY
54276: LIST
54277: LIST
54278: LIST
54279: LIST
54280: LIST
54281: LIST
54282: LIST
54283: ST_TO_ADDR
54284: GO 54415
54286: LD_INT 1
54288: DOUBLE
54289: EQUAL
54290: IFTRUE 54294
54292: GO 54356
54294: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54295: LD_ADDR_VAR 0 3
54299: PUSH
54300: LD_INT 11
54302: PUSH
54303: LD_INT 12
54305: PUSH
54306: LD_INT 13
54308: PUSH
54309: LD_INT 14
54311: PUSH
54312: LD_INT 1
54314: PUSH
54315: LD_INT 2
54317: PUSH
54318: LD_INT 3
54320: PUSH
54321: LD_INT 4
54323: PUSH
54324: LD_INT 5
54326: PUSH
54327: LD_INT 21
54329: PUSH
54330: LD_INT 23
54332: PUSH
54333: LD_INT 22
54335: PUSH
54336: LD_INT 24
54338: PUSH
54339: EMPTY
54340: LIST
54341: LIST
54342: LIST
54343: LIST
54344: LIST
54345: LIST
54346: LIST
54347: LIST
54348: LIST
54349: LIST
54350: LIST
54351: LIST
54352: LIST
54353: ST_TO_ADDR
54354: GO 54415
54356: LD_INT 3
54358: DOUBLE
54359: EQUAL
54360: IFTRUE 54364
54362: GO 54414
54364: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54365: LD_ADDR_VAR 0 3
54369: PUSH
54370: LD_INT 13
54372: PUSH
54373: LD_INT 14
54375: PUSH
54376: LD_INT 2
54378: PUSH
54379: LD_INT 3
54381: PUSH
54382: LD_INT 4
54384: PUSH
54385: LD_INT 5
54387: PUSH
54388: LD_INT 21
54390: PUSH
54391: LD_INT 22
54393: PUSH
54394: LD_INT 23
54396: PUSH
54397: LD_INT 24
54399: PUSH
54400: EMPTY
54401: LIST
54402: LIST
54403: LIST
54404: LIST
54405: LIST
54406: LIST
54407: LIST
54408: LIST
54409: LIST
54410: LIST
54411: ST_TO_ADDR
54412: GO 54415
54414: POP
// result := ( chassis in result ) ;
54415: LD_ADDR_VAR 0 3
54419: PUSH
54420: LD_VAR 0 1
54424: PUSH
54425: LD_VAR 0 3
54429: IN
54430: ST_TO_ADDR
// end ;
54431: LD_VAR 0 3
54435: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54436: LD_INT 0
54438: PPUSH
// if not chassis or not weapon then
54439: LD_VAR 0 1
54443: NOT
54444: PUSH
54445: LD_VAR 0 2
54449: NOT
54450: OR
54451: IFFALSE 54455
// exit ;
54453: GO 55517
// case weapon of us_machine_gun :
54455: LD_VAR 0 2
54459: PUSH
54460: LD_INT 2
54462: DOUBLE
54463: EQUAL
54464: IFTRUE 54468
54466: GO 54498
54468: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54469: LD_ADDR_VAR 0 3
54473: PUSH
54474: LD_INT 1
54476: PUSH
54477: LD_INT 2
54479: PUSH
54480: LD_INT 3
54482: PUSH
54483: LD_INT 4
54485: PUSH
54486: LD_INT 5
54488: PUSH
54489: EMPTY
54490: LIST
54491: LIST
54492: LIST
54493: LIST
54494: LIST
54495: ST_TO_ADDR
54496: GO 55501
54498: LD_INT 3
54500: DOUBLE
54501: EQUAL
54502: IFTRUE 54506
54504: GO 54536
54506: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54507: LD_ADDR_VAR 0 3
54511: PUSH
54512: LD_INT 1
54514: PUSH
54515: LD_INT 2
54517: PUSH
54518: LD_INT 3
54520: PUSH
54521: LD_INT 4
54523: PUSH
54524: LD_INT 5
54526: PUSH
54527: EMPTY
54528: LIST
54529: LIST
54530: LIST
54531: LIST
54532: LIST
54533: ST_TO_ADDR
54534: GO 55501
54536: LD_INT 11
54538: DOUBLE
54539: EQUAL
54540: IFTRUE 54544
54542: GO 54574
54544: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54545: LD_ADDR_VAR 0 3
54549: PUSH
54550: LD_INT 1
54552: PUSH
54553: LD_INT 2
54555: PUSH
54556: LD_INT 3
54558: PUSH
54559: LD_INT 4
54561: PUSH
54562: LD_INT 5
54564: PUSH
54565: EMPTY
54566: LIST
54567: LIST
54568: LIST
54569: LIST
54570: LIST
54571: ST_TO_ADDR
54572: GO 55501
54574: LD_INT 4
54576: DOUBLE
54577: EQUAL
54578: IFTRUE 54582
54580: GO 54608
54582: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54583: LD_ADDR_VAR 0 3
54587: PUSH
54588: LD_INT 2
54590: PUSH
54591: LD_INT 3
54593: PUSH
54594: LD_INT 4
54596: PUSH
54597: LD_INT 5
54599: PUSH
54600: EMPTY
54601: LIST
54602: LIST
54603: LIST
54604: LIST
54605: ST_TO_ADDR
54606: GO 55501
54608: LD_INT 5
54610: DOUBLE
54611: EQUAL
54612: IFTRUE 54616
54614: GO 54642
54616: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54617: LD_ADDR_VAR 0 3
54621: PUSH
54622: LD_INT 2
54624: PUSH
54625: LD_INT 3
54627: PUSH
54628: LD_INT 4
54630: PUSH
54631: LD_INT 5
54633: PUSH
54634: EMPTY
54635: LIST
54636: LIST
54637: LIST
54638: LIST
54639: ST_TO_ADDR
54640: GO 55501
54642: LD_INT 9
54644: DOUBLE
54645: EQUAL
54646: IFTRUE 54650
54648: GO 54676
54650: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54651: LD_ADDR_VAR 0 3
54655: PUSH
54656: LD_INT 2
54658: PUSH
54659: LD_INT 3
54661: PUSH
54662: LD_INT 4
54664: PUSH
54665: LD_INT 5
54667: PUSH
54668: EMPTY
54669: LIST
54670: LIST
54671: LIST
54672: LIST
54673: ST_TO_ADDR
54674: GO 55501
54676: LD_INT 7
54678: DOUBLE
54679: EQUAL
54680: IFTRUE 54684
54682: GO 54710
54684: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54685: LD_ADDR_VAR 0 3
54689: PUSH
54690: LD_INT 2
54692: PUSH
54693: LD_INT 3
54695: PUSH
54696: LD_INT 4
54698: PUSH
54699: LD_INT 5
54701: PUSH
54702: EMPTY
54703: LIST
54704: LIST
54705: LIST
54706: LIST
54707: ST_TO_ADDR
54708: GO 55501
54710: LD_INT 12
54712: DOUBLE
54713: EQUAL
54714: IFTRUE 54718
54716: GO 54744
54718: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54719: LD_ADDR_VAR 0 3
54723: PUSH
54724: LD_INT 2
54726: PUSH
54727: LD_INT 3
54729: PUSH
54730: LD_INT 4
54732: PUSH
54733: LD_INT 5
54735: PUSH
54736: EMPTY
54737: LIST
54738: LIST
54739: LIST
54740: LIST
54741: ST_TO_ADDR
54742: GO 55501
54744: LD_INT 13
54746: DOUBLE
54747: EQUAL
54748: IFTRUE 54752
54750: GO 54778
54752: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54753: LD_ADDR_VAR 0 3
54757: PUSH
54758: LD_INT 2
54760: PUSH
54761: LD_INT 3
54763: PUSH
54764: LD_INT 4
54766: PUSH
54767: LD_INT 5
54769: PUSH
54770: EMPTY
54771: LIST
54772: LIST
54773: LIST
54774: LIST
54775: ST_TO_ADDR
54776: GO 55501
54778: LD_INT 14
54780: DOUBLE
54781: EQUAL
54782: IFTRUE 54786
54784: GO 54804
54786: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54787: LD_ADDR_VAR 0 3
54791: PUSH
54792: LD_INT 4
54794: PUSH
54795: LD_INT 5
54797: PUSH
54798: EMPTY
54799: LIST
54800: LIST
54801: ST_TO_ADDR
54802: GO 55501
54804: LD_INT 6
54806: DOUBLE
54807: EQUAL
54808: IFTRUE 54812
54810: GO 54830
54812: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54813: LD_ADDR_VAR 0 3
54817: PUSH
54818: LD_INT 4
54820: PUSH
54821: LD_INT 5
54823: PUSH
54824: EMPTY
54825: LIST
54826: LIST
54827: ST_TO_ADDR
54828: GO 55501
54830: LD_INT 10
54832: DOUBLE
54833: EQUAL
54834: IFTRUE 54838
54836: GO 54856
54838: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
54839: LD_ADDR_VAR 0 3
54843: PUSH
54844: LD_INT 4
54846: PUSH
54847: LD_INT 5
54849: PUSH
54850: EMPTY
54851: LIST
54852: LIST
54853: ST_TO_ADDR
54854: GO 55501
54856: LD_INT 22
54858: DOUBLE
54859: EQUAL
54860: IFTRUE 54864
54862: GO 54890
54864: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
54865: LD_ADDR_VAR 0 3
54869: PUSH
54870: LD_INT 11
54872: PUSH
54873: LD_INT 12
54875: PUSH
54876: LD_INT 13
54878: PUSH
54879: LD_INT 14
54881: PUSH
54882: EMPTY
54883: LIST
54884: LIST
54885: LIST
54886: LIST
54887: ST_TO_ADDR
54888: GO 55501
54890: LD_INT 23
54892: DOUBLE
54893: EQUAL
54894: IFTRUE 54898
54896: GO 54924
54898: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
54899: LD_ADDR_VAR 0 3
54903: PUSH
54904: LD_INT 11
54906: PUSH
54907: LD_INT 12
54909: PUSH
54910: LD_INT 13
54912: PUSH
54913: LD_INT 14
54915: PUSH
54916: EMPTY
54917: LIST
54918: LIST
54919: LIST
54920: LIST
54921: ST_TO_ADDR
54922: GO 55501
54924: LD_INT 24
54926: DOUBLE
54927: EQUAL
54928: IFTRUE 54932
54930: GO 54958
54932: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
54933: LD_ADDR_VAR 0 3
54937: PUSH
54938: LD_INT 11
54940: PUSH
54941: LD_INT 12
54943: PUSH
54944: LD_INT 13
54946: PUSH
54947: LD_INT 14
54949: PUSH
54950: EMPTY
54951: LIST
54952: LIST
54953: LIST
54954: LIST
54955: ST_TO_ADDR
54956: GO 55501
54958: LD_INT 30
54960: DOUBLE
54961: EQUAL
54962: IFTRUE 54966
54964: GO 54992
54966: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
54967: LD_ADDR_VAR 0 3
54971: PUSH
54972: LD_INT 11
54974: PUSH
54975: LD_INT 12
54977: PUSH
54978: LD_INT 13
54980: PUSH
54981: LD_INT 14
54983: PUSH
54984: EMPTY
54985: LIST
54986: LIST
54987: LIST
54988: LIST
54989: ST_TO_ADDR
54990: GO 55501
54992: LD_INT 25
54994: DOUBLE
54995: EQUAL
54996: IFTRUE 55000
54998: GO 55018
55000: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55001: LD_ADDR_VAR 0 3
55005: PUSH
55006: LD_INT 13
55008: PUSH
55009: LD_INT 14
55011: PUSH
55012: EMPTY
55013: LIST
55014: LIST
55015: ST_TO_ADDR
55016: GO 55501
55018: LD_INT 27
55020: DOUBLE
55021: EQUAL
55022: IFTRUE 55026
55024: GO 55044
55026: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55027: LD_ADDR_VAR 0 3
55031: PUSH
55032: LD_INT 13
55034: PUSH
55035: LD_INT 14
55037: PUSH
55038: EMPTY
55039: LIST
55040: LIST
55041: ST_TO_ADDR
55042: GO 55501
55044: LD_EXP 77
55048: DOUBLE
55049: EQUAL
55050: IFTRUE 55054
55052: GO 55080
55054: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55055: LD_ADDR_VAR 0 3
55059: PUSH
55060: LD_INT 11
55062: PUSH
55063: LD_INT 12
55065: PUSH
55066: LD_INT 13
55068: PUSH
55069: LD_INT 14
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: LIST
55076: LIST
55077: ST_TO_ADDR
55078: GO 55501
55080: LD_INT 28
55082: DOUBLE
55083: EQUAL
55084: IFTRUE 55088
55086: GO 55106
55088: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55089: LD_ADDR_VAR 0 3
55093: PUSH
55094: LD_INT 13
55096: PUSH
55097: LD_INT 14
55099: PUSH
55100: EMPTY
55101: LIST
55102: LIST
55103: ST_TO_ADDR
55104: GO 55501
55106: LD_INT 29
55108: DOUBLE
55109: EQUAL
55110: IFTRUE 55114
55112: GO 55132
55114: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55115: LD_ADDR_VAR 0 3
55119: PUSH
55120: LD_INT 13
55122: PUSH
55123: LD_INT 14
55125: PUSH
55126: EMPTY
55127: LIST
55128: LIST
55129: ST_TO_ADDR
55130: GO 55501
55132: LD_INT 31
55134: DOUBLE
55135: EQUAL
55136: IFTRUE 55140
55138: GO 55158
55140: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
55141: LD_ADDR_VAR 0 3
55145: PUSH
55146: LD_INT 13
55148: PUSH
55149: LD_INT 14
55151: PUSH
55152: EMPTY
55153: LIST
55154: LIST
55155: ST_TO_ADDR
55156: GO 55501
55158: LD_INT 26
55160: DOUBLE
55161: EQUAL
55162: IFTRUE 55166
55164: GO 55184
55166: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
55167: LD_ADDR_VAR 0 3
55171: PUSH
55172: LD_INT 13
55174: PUSH
55175: LD_INT 14
55177: PUSH
55178: EMPTY
55179: LIST
55180: LIST
55181: ST_TO_ADDR
55182: GO 55501
55184: LD_INT 42
55186: DOUBLE
55187: EQUAL
55188: IFTRUE 55192
55190: GO 55218
55192: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
55193: LD_ADDR_VAR 0 3
55197: PUSH
55198: LD_INT 21
55200: PUSH
55201: LD_INT 22
55203: PUSH
55204: LD_INT 23
55206: PUSH
55207: LD_INT 24
55209: PUSH
55210: EMPTY
55211: LIST
55212: LIST
55213: LIST
55214: LIST
55215: ST_TO_ADDR
55216: GO 55501
55218: LD_INT 43
55220: DOUBLE
55221: EQUAL
55222: IFTRUE 55226
55224: GO 55252
55226: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
55227: LD_ADDR_VAR 0 3
55231: PUSH
55232: LD_INT 21
55234: PUSH
55235: LD_INT 22
55237: PUSH
55238: LD_INT 23
55240: PUSH
55241: LD_INT 24
55243: PUSH
55244: EMPTY
55245: LIST
55246: LIST
55247: LIST
55248: LIST
55249: ST_TO_ADDR
55250: GO 55501
55252: LD_INT 44
55254: DOUBLE
55255: EQUAL
55256: IFTRUE 55260
55258: GO 55286
55260: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
55261: LD_ADDR_VAR 0 3
55265: PUSH
55266: LD_INT 21
55268: PUSH
55269: LD_INT 22
55271: PUSH
55272: LD_INT 23
55274: PUSH
55275: LD_INT 24
55277: PUSH
55278: EMPTY
55279: LIST
55280: LIST
55281: LIST
55282: LIST
55283: ST_TO_ADDR
55284: GO 55501
55286: LD_INT 45
55288: DOUBLE
55289: EQUAL
55290: IFTRUE 55294
55292: GO 55320
55294: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55295: LD_ADDR_VAR 0 3
55299: PUSH
55300: LD_INT 21
55302: PUSH
55303: LD_INT 22
55305: PUSH
55306: LD_INT 23
55308: PUSH
55309: LD_INT 24
55311: PUSH
55312: EMPTY
55313: LIST
55314: LIST
55315: LIST
55316: LIST
55317: ST_TO_ADDR
55318: GO 55501
55320: LD_INT 49
55322: DOUBLE
55323: EQUAL
55324: IFTRUE 55328
55326: GO 55354
55328: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55329: LD_ADDR_VAR 0 3
55333: PUSH
55334: LD_INT 21
55336: PUSH
55337: LD_INT 22
55339: PUSH
55340: LD_INT 23
55342: PUSH
55343: LD_INT 24
55345: PUSH
55346: EMPTY
55347: LIST
55348: LIST
55349: LIST
55350: LIST
55351: ST_TO_ADDR
55352: GO 55501
55354: LD_INT 51
55356: DOUBLE
55357: EQUAL
55358: IFTRUE 55362
55360: GO 55388
55362: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55363: LD_ADDR_VAR 0 3
55367: PUSH
55368: LD_INT 21
55370: PUSH
55371: LD_INT 22
55373: PUSH
55374: LD_INT 23
55376: PUSH
55377: LD_INT 24
55379: PUSH
55380: EMPTY
55381: LIST
55382: LIST
55383: LIST
55384: LIST
55385: ST_TO_ADDR
55386: GO 55501
55388: LD_INT 52
55390: DOUBLE
55391: EQUAL
55392: IFTRUE 55396
55394: GO 55422
55396: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55397: LD_ADDR_VAR 0 3
55401: PUSH
55402: LD_INT 21
55404: PUSH
55405: LD_INT 22
55407: PUSH
55408: LD_INT 23
55410: PUSH
55411: LD_INT 24
55413: PUSH
55414: EMPTY
55415: LIST
55416: LIST
55417: LIST
55418: LIST
55419: ST_TO_ADDR
55420: GO 55501
55422: LD_INT 53
55424: DOUBLE
55425: EQUAL
55426: IFTRUE 55430
55428: GO 55448
55430: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55431: LD_ADDR_VAR 0 3
55435: PUSH
55436: LD_INT 23
55438: PUSH
55439: LD_INT 24
55441: PUSH
55442: EMPTY
55443: LIST
55444: LIST
55445: ST_TO_ADDR
55446: GO 55501
55448: LD_INT 46
55450: DOUBLE
55451: EQUAL
55452: IFTRUE 55456
55454: GO 55474
55456: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55457: LD_ADDR_VAR 0 3
55461: PUSH
55462: LD_INT 23
55464: PUSH
55465: LD_INT 24
55467: PUSH
55468: EMPTY
55469: LIST
55470: LIST
55471: ST_TO_ADDR
55472: GO 55501
55474: LD_INT 47
55476: DOUBLE
55477: EQUAL
55478: IFTRUE 55482
55480: GO 55500
55482: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55483: LD_ADDR_VAR 0 3
55487: PUSH
55488: LD_INT 23
55490: PUSH
55491: LD_INT 24
55493: PUSH
55494: EMPTY
55495: LIST
55496: LIST
55497: ST_TO_ADDR
55498: GO 55501
55500: POP
// result := ( chassis in result ) ;
55501: LD_ADDR_VAR 0 3
55505: PUSH
55506: LD_VAR 0 1
55510: PUSH
55511: LD_VAR 0 3
55515: IN
55516: ST_TO_ADDR
// end ;
55517: LD_VAR 0 3
55521: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55522: LD_INT 0
55524: PPUSH
55525: PPUSH
55526: PPUSH
55527: PPUSH
55528: PPUSH
55529: PPUSH
55530: PPUSH
// result := array ;
55531: LD_ADDR_VAR 0 5
55535: PUSH
55536: LD_VAR 0 1
55540: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55541: LD_VAR 0 1
55545: NOT
55546: PUSH
55547: LD_VAR 0 2
55551: NOT
55552: OR
55553: PUSH
55554: LD_VAR 0 3
55558: NOT
55559: OR
55560: PUSH
55561: LD_VAR 0 2
55565: PUSH
55566: LD_VAR 0 1
55570: GREATER
55571: OR
55572: PUSH
55573: LD_VAR 0 3
55577: PUSH
55578: LD_VAR 0 1
55582: GREATER
55583: OR
55584: IFFALSE 55588
// exit ;
55586: GO 55884
// if direction then
55588: LD_VAR 0 4
55592: IFFALSE 55656
// begin d := 1 ;
55594: LD_ADDR_VAR 0 9
55598: PUSH
55599: LD_INT 1
55601: ST_TO_ADDR
// if i_from > i_to then
55602: LD_VAR 0 2
55606: PUSH
55607: LD_VAR 0 3
55611: GREATER
55612: IFFALSE 55638
// length := ( array - i_from ) + i_to else
55614: LD_ADDR_VAR 0 11
55618: PUSH
55619: LD_VAR 0 1
55623: PUSH
55624: LD_VAR 0 2
55628: MINUS
55629: PUSH
55630: LD_VAR 0 3
55634: PLUS
55635: ST_TO_ADDR
55636: GO 55654
// length := i_to - i_from ;
55638: LD_ADDR_VAR 0 11
55642: PUSH
55643: LD_VAR 0 3
55647: PUSH
55648: LD_VAR 0 2
55652: MINUS
55653: ST_TO_ADDR
// end else
55654: GO 55717
// begin d := - 1 ;
55656: LD_ADDR_VAR 0 9
55660: PUSH
55661: LD_INT 1
55663: NEG
55664: ST_TO_ADDR
// if i_from > i_to then
55665: LD_VAR 0 2
55669: PUSH
55670: LD_VAR 0 3
55674: GREATER
55675: IFFALSE 55695
// length := i_from - i_to else
55677: LD_ADDR_VAR 0 11
55681: PUSH
55682: LD_VAR 0 2
55686: PUSH
55687: LD_VAR 0 3
55691: MINUS
55692: ST_TO_ADDR
55693: GO 55717
// length := ( array - i_to ) + i_from ;
55695: LD_ADDR_VAR 0 11
55699: PUSH
55700: LD_VAR 0 1
55704: PUSH
55705: LD_VAR 0 3
55709: MINUS
55710: PUSH
55711: LD_VAR 0 2
55715: PLUS
55716: ST_TO_ADDR
// end ; if not length then
55717: LD_VAR 0 11
55721: NOT
55722: IFFALSE 55726
// exit ;
55724: GO 55884
// tmp := array ;
55726: LD_ADDR_VAR 0 10
55730: PUSH
55731: LD_VAR 0 1
55735: ST_TO_ADDR
// for i = 1 to length do
55736: LD_ADDR_VAR 0 6
55740: PUSH
55741: DOUBLE
55742: LD_INT 1
55744: DEC
55745: ST_TO_ADDR
55746: LD_VAR 0 11
55750: PUSH
55751: FOR_TO
55752: IFFALSE 55872
// begin for j = 1 to array do
55754: LD_ADDR_VAR 0 7
55758: PUSH
55759: DOUBLE
55760: LD_INT 1
55762: DEC
55763: ST_TO_ADDR
55764: LD_VAR 0 1
55768: PUSH
55769: FOR_TO
55770: IFFALSE 55858
// begin k := j + d ;
55772: LD_ADDR_VAR 0 8
55776: PUSH
55777: LD_VAR 0 7
55781: PUSH
55782: LD_VAR 0 9
55786: PLUS
55787: ST_TO_ADDR
// if k > array then
55788: LD_VAR 0 8
55792: PUSH
55793: LD_VAR 0 1
55797: GREATER
55798: IFFALSE 55808
// k := 1 ;
55800: LD_ADDR_VAR 0 8
55804: PUSH
55805: LD_INT 1
55807: ST_TO_ADDR
// if not k then
55808: LD_VAR 0 8
55812: NOT
55813: IFFALSE 55825
// k := array ;
55815: LD_ADDR_VAR 0 8
55819: PUSH
55820: LD_VAR 0 1
55824: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55825: LD_ADDR_VAR 0 10
55829: PUSH
55830: LD_VAR 0 10
55834: PPUSH
55835: LD_VAR 0 8
55839: PPUSH
55840: LD_VAR 0 1
55844: PUSH
55845: LD_VAR 0 7
55849: ARRAY
55850: PPUSH
55851: CALL_OW 1
55855: ST_TO_ADDR
// end ;
55856: GO 55769
55858: POP
55859: POP
// array := tmp ;
55860: LD_ADDR_VAR 0 1
55864: PUSH
55865: LD_VAR 0 10
55869: ST_TO_ADDR
// end ;
55870: GO 55751
55872: POP
55873: POP
// result := array ;
55874: LD_ADDR_VAR 0 5
55878: PUSH
55879: LD_VAR 0 1
55883: ST_TO_ADDR
// end ;
55884: LD_VAR 0 5
55888: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
55889: LD_INT 0
55891: PPUSH
55892: PPUSH
// result := 0 ;
55893: LD_ADDR_VAR 0 3
55897: PUSH
55898: LD_INT 0
55900: ST_TO_ADDR
// if not array or not value in array then
55901: LD_VAR 0 1
55905: NOT
55906: PUSH
55907: LD_VAR 0 2
55911: PUSH
55912: LD_VAR 0 1
55916: IN
55917: NOT
55918: OR
55919: IFFALSE 55923
// exit ;
55921: GO 55977
// for i = 1 to array do
55923: LD_ADDR_VAR 0 4
55927: PUSH
55928: DOUBLE
55929: LD_INT 1
55931: DEC
55932: ST_TO_ADDR
55933: LD_VAR 0 1
55937: PUSH
55938: FOR_TO
55939: IFFALSE 55975
// if value = array [ i ] then
55941: LD_VAR 0 2
55945: PUSH
55946: LD_VAR 0 1
55950: PUSH
55951: LD_VAR 0 4
55955: ARRAY
55956: EQUAL
55957: IFFALSE 55973
// begin result := i ;
55959: LD_ADDR_VAR 0 3
55963: PUSH
55964: LD_VAR 0 4
55968: ST_TO_ADDR
// exit ;
55969: POP
55970: POP
55971: GO 55977
// end ;
55973: GO 55938
55975: POP
55976: POP
// end ;
55977: LD_VAR 0 3
55981: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
55982: LD_INT 0
55984: PPUSH
// vc_chassis := chassis ;
55985: LD_ADDR_OWVAR 37
55989: PUSH
55990: LD_VAR 0 1
55994: ST_TO_ADDR
// vc_engine := engine ;
55995: LD_ADDR_OWVAR 39
55999: PUSH
56000: LD_VAR 0 2
56004: ST_TO_ADDR
// vc_control := control ;
56005: LD_ADDR_OWVAR 38
56009: PUSH
56010: LD_VAR 0 3
56014: ST_TO_ADDR
// vc_weapon := weapon ;
56015: LD_ADDR_OWVAR 40
56019: PUSH
56020: LD_VAR 0 4
56024: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56025: LD_ADDR_OWVAR 41
56029: PUSH
56030: LD_VAR 0 5
56034: ST_TO_ADDR
// end ;
56035: LD_VAR 0 6
56039: RET
// export function WantPlant ( unit ) ; var task ; begin
56040: LD_INT 0
56042: PPUSH
56043: PPUSH
// result := false ;
56044: LD_ADDR_VAR 0 2
56048: PUSH
56049: LD_INT 0
56051: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56052: LD_ADDR_VAR 0 3
56056: PUSH
56057: LD_VAR 0 1
56061: PPUSH
56062: CALL_OW 437
56066: ST_TO_ADDR
// if task then
56067: LD_VAR 0 3
56071: IFFALSE 56099
// if task [ 1 ] [ 1 ] = p then
56073: LD_VAR 0 3
56077: PUSH
56078: LD_INT 1
56080: ARRAY
56081: PUSH
56082: LD_INT 1
56084: ARRAY
56085: PUSH
56086: LD_STRING p
56088: EQUAL
56089: IFFALSE 56099
// result := true ;
56091: LD_ADDR_VAR 0 2
56095: PUSH
56096: LD_INT 1
56098: ST_TO_ADDR
// end ;
56099: LD_VAR 0 2
56103: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56104: LD_INT 0
56106: PPUSH
56107: PPUSH
56108: PPUSH
56109: PPUSH
// if pos < 1 then
56110: LD_VAR 0 2
56114: PUSH
56115: LD_INT 1
56117: LESS
56118: IFFALSE 56122
// exit ;
56120: GO 56425
// if pos = 1 then
56122: LD_VAR 0 2
56126: PUSH
56127: LD_INT 1
56129: EQUAL
56130: IFFALSE 56163
// result := Replace ( arr , pos [ 1 ] , value ) else
56132: LD_ADDR_VAR 0 4
56136: PUSH
56137: LD_VAR 0 1
56141: PPUSH
56142: LD_VAR 0 2
56146: PUSH
56147: LD_INT 1
56149: ARRAY
56150: PPUSH
56151: LD_VAR 0 3
56155: PPUSH
56156: CALL_OW 1
56160: ST_TO_ADDR
56161: GO 56425
// begin tmp := arr ;
56163: LD_ADDR_VAR 0 6
56167: PUSH
56168: LD_VAR 0 1
56172: ST_TO_ADDR
// s_arr := [ tmp ] ;
56173: LD_ADDR_VAR 0 7
56177: PUSH
56178: LD_VAR 0 6
56182: PUSH
56183: EMPTY
56184: LIST
56185: ST_TO_ADDR
// for i = 1 to pos - 1 do
56186: LD_ADDR_VAR 0 5
56190: PUSH
56191: DOUBLE
56192: LD_INT 1
56194: DEC
56195: ST_TO_ADDR
56196: LD_VAR 0 2
56200: PUSH
56201: LD_INT 1
56203: MINUS
56204: PUSH
56205: FOR_TO
56206: IFFALSE 56251
// begin tmp := tmp [ pos [ i ] ] ;
56208: LD_ADDR_VAR 0 6
56212: PUSH
56213: LD_VAR 0 6
56217: PUSH
56218: LD_VAR 0 2
56222: PUSH
56223: LD_VAR 0 5
56227: ARRAY
56228: ARRAY
56229: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
56230: LD_ADDR_VAR 0 7
56234: PUSH
56235: LD_VAR 0 7
56239: PUSH
56240: LD_VAR 0 6
56244: PUSH
56245: EMPTY
56246: LIST
56247: ADD
56248: ST_TO_ADDR
// end ;
56249: GO 56205
56251: POP
56252: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
56253: LD_ADDR_VAR 0 6
56257: PUSH
56258: LD_VAR 0 6
56262: PPUSH
56263: LD_VAR 0 2
56267: PUSH
56268: LD_VAR 0 2
56272: ARRAY
56273: PPUSH
56274: LD_VAR 0 3
56278: PPUSH
56279: CALL_OW 1
56283: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
56284: LD_ADDR_VAR 0 7
56288: PUSH
56289: LD_VAR 0 7
56293: PPUSH
56294: LD_VAR 0 7
56298: PPUSH
56299: LD_VAR 0 6
56303: PPUSH
56304: CALL_OW 1
56308: ST_TO_ADDR
// for i = s_arr downto 2 do
56309: LD_ADDR_VAR 0 5
56313: PUSH
56314: DOUBLE
56315: LD_VAR 0 7
56319: INC
56320: ST_TO_ADDR
56321: LD_INT 2
56323: PUSH
56324: FOR_DOWNTO
56325: IFFALSE 56409
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56327: LD_ADDR_VAR 0 6
56331: PUSH
56332: LD_VAR 0 7
56336: PUSH
56337: LD_VAR 0 5
56341: PUSH
56342: LD_INT 1
56344: MINUS
56345: ARRAY
56346: PPUSH
56347: LD_VAR 0 2
56351: PUSH
56352: LD_VAR 0 5
56356: PUSH
56357: LD_INT 1
56359: MINUS
56360: ARRAY
56361: PPUSH
56362: LD_VAR 0 7
56366: PUSH
56367: LD_VAR 0 5
56371: ARRAY
56372: PPUSH
56373: CALL_OW 1
56377: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56378: LD_ADDR_VAR 0 7
56382: PUSH
56383: LD_VAR 0 7
56387: PPUSH
56388: LD_VAR 0 5
56392: PUSH
56393: LD_INT 1
56395: MINUS
56396: PPUSH
56397: LD_VAR 0 6
56401: PPUSH
56402: CALL_OW 1
56406: ST_TO_ADDR
// end ;
56407: GO 56324
56409: POP
56410: POP
// result := s_arr [ 1 ] ;
56411: LD_ADDR_VAR 0 4
56415: PUSH
56416: LD_VAR 0 7
56420: PUSH
56421: LD_INT 1
56423: ARRAY
56424: ST_TO_ADDR
// end ; end ;
56425: LD_VAR 0 4
56429: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56430: LD_INT 0
56432: PPUSH
56433: PPUSH
// if not list then
56434: LD_VAR 0 1
56438: NOT
56439: IFFALSE 56443
// exit ;
56441: GO 56534
// i := list [ pos1 ] ;
56443: LD_ADDR_VAR 0 5
56447: PUSH
56448: LD_VAR 0 1
56452: PUSH
56453: LD_VAR 0 2
56457: ARRAY
56458: ST_TO_ADDR
// if not i then
56459: LD_VAR 0 5
56463: NOT
56464: IFFALSE 56468
// exit ;
56466: GO 56534
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56468: LD_ADDR_VAR 0 1
56472: PUSH
56473: LD_VAR 0 1
56477: PPUSH
56478: LD_VAR 0 2
56482: PPUSH
56483: LD_VAR 0 1
56487: PUSH
56488: LD_VAR 0 3
56492: ARRAY
56493: PPUSH
56494: CALL_OW 1
56498: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56499: LD_ADDR_VAR 0 1
56503: PUSH
56504: LD_VAR 0 1
56508: PPUSH
56509: LD_VAR 0 3
56513: PPUSH
56514: LD_VAR 0 5
56518: PPUSH
56519: CALL_OW 1
56523: ST_TO_ADDR
// result := list ;
56524: LD_ADDR_VAR 0 4
56528: PUSH
56529: LD_VAR 0 1
56533: ST_TO_ADDR
// end ;
56534: LD_VAR 0 4
56538: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56539: LD_INT 0
56541: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56542: LD_ADDR_VAR 0 5
56546: PUSH
56547: LD_VAR 0 1
56551: PPUSH
56552: CALL_OW 250
56556: PPUSH
56557: LD_VAR 0 1
56561: PPUSH
56562: CALL_OW 251
56566: PPUSH
56567: LD_VAR 0 2
56571: PPUSH
56572: LD_VAR 0 3
56576: PPUSH
56577: LD_VAR 0 4
56581: PPUSH
56582: CALL 56592 0 5
56586: ST_TO_ADDR
// end ;
56587: LD_VAR 0 5
56591: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56592: LD_INT 0
56594: PPUSH
56595: PPUSH
56596: PPUSH
56597: PPUSH
// if not list then
56598: LD_VAR 0 3
56602: NOT
56603: IFFALSE 56607
// exit ;
56605: GO 56995
// result := [ ] ;
56607: LD_ADDR_VAR 0 6
56611: PUSH
56612: EMPTY
56613: ST_TO_ADDR
// for i in list do
56614: LD_ADDR_VAR 0 7
56618: PUSH
56619: LD_VAR 0 3
56623: PUSH
56624: FOR_IN
56625: IFFALSE 56827
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56627: LD_ADDR_VAR 0 9
56631: PUSH
56632: LD_VAR 0 7
56636: PPUSH
56637: LD_VAR 0 1
56641: PPUSH
56642: LD_VAR 0 2
56646: PPUSH
56647: CALL_OW 297
56651: ST_TO_ADDR
// if not result then
56652: LD_VAR 0 6
56656: NOT
56657: IFFALSE 56683
// result := [ [ i , tmp ] ] else
56659: LD_ADDR_VAR 0 6
56663: PUSH
56664: LD_VAR 0 7
56668: PUSH
56669: LD_VAR 0 9
56673: PUSH
56674: EMPTY
56675: LIST
56676: LIST
56677: PUSH
56678: EMPTY
56679: LIST
56680: ST_TO_ADDR
56681: GO 56825
// begin if result [ result ] [ 2 ] < tmp then
56683: LD_VAR 0 6
56687: PUSH
56688: LD_VAR 0 6
56692: ARRAY
56693: PUSH
56694: LD_INT 2
56696: ARRAY
56697: PUSH
56698: LD_VAR 0 9
56702: LESS
56703: IFFALSE 56745
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56705: LD_ADDR_VAR 0 6
56709: PUSH
56710: LD_VAR 0 6
56714: PPUSH
56715: LD_VAR 0 6
56719: PUSH
56720: LD_INT 1
56722: PLUS
56723: PPUSH
56724: LD_VAR 0 7
56728: PUSH
56729: LD_VAR 0 9
56733: PUSH
56734: EMPTY
56735: LIST
56736: LIST
56737: PPUSH
56738: CALL_OW 2
56742: ST_TO_ADDR
56743: GO 56825
// for j = 1 to result do
56745: LD_ADDR_VAR 0 8
56749: PUSH
56750: DOUBLE
56751: LD_INT 1
56753: DEC
56754: ST_TO_ADDR
56755: LD_VAR 0 6
56759: PUSH
56760: FOR_TO
56761: IFFALSE 56823
// begin if tmp < result [ j ] [ 2 ] then
56763: LD_VAR 0 9
56767: PUSH
56768: LD_VAR 0 6
56772: PUSH
56773: LD_VAR 0 8
56777: ARRAY
56778: PUSH
56779: LD_INT 2
56781: ARRAY
56782: LESS
56783: IFFALSE 56821
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56785: LD_ADDR_VAR 0 6
56789: PUSH
56790: LD_VAR 0 6
56794: PPUSH
56795: LD_VAR 0 8
56799: PPUSH
56800: LD_VAR 0 7
56804: PUSH
56805: LD_VAR 0 9
56809: PUSH
56810: EMPTY
56811: LIST
56812: LIST
56813: PPUSH
56814: CALL_OW 2
56818: ST_TO_ADDR
// break ;
56819: GO 56823
// end ; end ;
56821: GO 56760
56823: POP
56824: POP
// end ; end ;
56825: GO 56624
56827: POP
56828: POP
// if result and not asc then
56829: LD_VAR 0 6
56833: PUSH
56834: LD_VAR 0 4
56838: NOT
56839: AND
56840: IFFALSE 56915
// begin tmp := result ;
56842: LD_ADDR_VAR 0 9
56846: PUSH
56847: LD_VAR 0 6
56851: ST_TO_ADDR
// for i = tmp downto 1 do
56852: LD_ADDR_VAR 0 7
56856: PUSH
56857: DOUBLE
56858: LD_VAR 0 9
56862: INC
56863: ST_TO_ADDR
56864: LD_INT 1
56866: PUSH
56867: FOR_DOWNTO
56868: IFFALSE 56913
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56870: LD_ADDR_VAR 0 6
56874: PUSH
56875: LD_VAR 0 6
56879: PPUSH
56880: LD_VAR 0 9
56884: PUSH
56885: LD_VAR 0 7
56889: MINUS
56890: PUSH
56891: LD_INT 1
56893: PLUS
56894: PPUSH
56895: LD_VAR 0 9
56899: PUSH
56900: LD_VAR 0 7
56904: ARRAY
56905: PPUSH
56906: CALL_OW 1
56910: ST_TO_ADDR
56911: GO 56867
56913: POP
56914: POP
// end ; tmp := [ ] ;
56915: LD_ADDR_VAR 0 9
56919: PUSH
56920: EMPTY
56921: ST_TO_ADDR
// if mode then
56922: LD_VAR 0 5
56926: IFFALSE 56995
// begin for i = 1 to result do
56928: LD_ADDR_VAR 0 7
56932: PUSH
56933: DOUBLE
56934: LD_INT 1
56936: DEC
56937: ST_TO_ADDR
56938: LD_VAR 0 6
56942: PUSH
56943: FOR_TO
56944: IFFALSE 56983
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
56946: LD_ADDR_VAR 0 9
56950: PUSH
56951: LD_VAR 0 9
56955: PPUSH
56956: LD_VAR 0 7
56960: PPUSH
56961: LD_VAR 0 6
56965: PUSH
56966: LD_VAR 0 7
56970: ARRAY
56971: PUSH
56972: LD_INT 1
56974: ARRAY
56975: PPUSH
56976: CALL_OW 1
56980: ST_TO_ADDR
56981: GO 56943
56983: POP
56984: POP
// result := tmp ;
56985: LD_ADDR_VAR 0 6
56989: PUSH
56990: LD_VAR 0 9
56994: ST_TO_ADDR
// end ; end ;
56995: LD_VAR 0 6
56999: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57000: LD_INT 0
57002: PPUSH
57003: PPUSH
57004: PPUSH
57005: PPUSH
57006: PPUSH
57007: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57008: LD_ADDR_VAR 0 5
57012: PUSH
57013: LD_INT 0
57015: PUSH
57016: LD_INT 0
57018: PUSH
57019: LD_INT 0
57021: PUSH
57022: EMPTY
57023: PUSH
57024: EMPTY
57025: LIST
57026: LIST
57027: LIST
57028: LIST
57029: ST_TO_ADDR
// if not x or not y then
57030: LD_VAR 0 2
57034: NOT
57035: PUSH
57036: LD_VAR 0 3
57040: NOT
57041: OR
57042: IFFALSE 57046
// exit ;
57044: GO 58698
// if not range then
57046: LD_VAR 0 4
57050: NOT
57051: IFFALSE 57061
// range := 10 ;
57053: LD_ADDR_VAR 0 4
57057: PUSH
57058: LD_INT 10
57060: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57061: LD_ADDR_VAR 0 8
57065: PUSH
57066: LD_INT 81
57068: PUSH
57069: LD_VAR 0 1
57073: PUSH
57074: EMPTY
57075: LIST
57076: LIST
57077: PUSH
57078: LD_INT 92
57080: PUSH
57081: LD_VAR 0 2
57085: PUSH
57086: LD_VAR 0 3
57090: PUSH
57091: LD_VAR 0 4
57095: PUSH
57096: EMPTY
57097: LIST
57098: LIST
57099: LIST
57100: LIST
57101: PUSH
57102: LD_INT 3
57104: PUSH
57105: LD_INT 21
57107: PUSH
57108: LD_INT 3
57110: PUSH
57111: EMPTY
57112: LIST
57113: LIST
57114: PUSH
57115: EMPTY
57116: LIST
57117: LIST
57118: PUSH
57119: EMPTY
57120: LIST
57121: LIST
57122: LIST
57123: PPUSH
57124: CALL_OW 69
57128: ST_TO_ADDR
// if not tmp then
57129: LD_VAR 0 8
57133: NOT
57134: IFFALSE 57138
// exit ;
57136: GO 58698
// for i in tmp do
57138: LD_ADDR_VAR 0 6
57142: PUSH
57143: LD_VAR 0 8
57147: PUSH
57148: FOR_IN
57149: IFFALSE 58673
// begin points := [ 0 , 0 , 0 ] ;
57151: LD_ADDR_VAR 0 9
57155: PUSH
57156: LD_INT 0
57158: PUSH
57159: LD_INT 0
57161: PUSH
57162: LD_INT 0
57164: PUSH
57165: EMPTY
57166: LIST
57167: LIST
57168: LIST
57169: ST_TO_ADDR
// bpoints := 1 ;
57170: LD_ADDR_VAR 0 10
57174: PUSH
57175: LD_INT 1
57177: ST_TO_ADDR
// case GetType ( i ) of unit_human :
57178: LD_VAR 0 6
57182: PPUSH
57183: CALL_OW 247
57187: PUSH
57188: LD_INT 1
57190: DOUBLE
57191: EQUAL
57192: IFTRUE 57196
57194: GO 57774
57196: POP
// begin if GetClass ( i ) = 1 then
57197: LD_VAR 0 6
57201: PPUSH
57202: CALL_OW 257
57206: PUSH
57207: LD_INT 1
57209: EQUAL
57210: IFFALSE 57231
// points := [ 10 , 5 , 3 ] ;
57212: LD_ADDR_VAR 0 9
57216: PUSH
57217: LD_INT 10
57219: PUSH
57220: LD_INT 5
57222: PUSH
57223: LD_INT 3
57225: PUSH
57226: EMPTY
57227: LIST
57228: LIST
57229: LIST
57230: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
57231: LD_VAR 0 6
57235: PPUSH
57236: CALL_OW 257
57240: PUSH
57241: LD_INT 2
57243: PUSH
57244: LD_INT 3
57246: PUSH
57247: LD_INT 4
57249: PUSH
57250: EMPTY
57251: LIST
57252: LIST
57253: LIST
57254: IN
57255: IFFALSE 57276
// points := [ 3 , 2 , 1 ] ;
57257: LD_ADDR_VAR 0 9
57261: PUSH
57262: LD_INT 3
57264: PUSH
57265: LD_INT 2
57267: PUSH
57268: LD_INT 1
57270: PUSH
57271: EMPTY
57272: LIST
57273: LIST
57274: LIST
57275: ST_TO_ADDR
// if GetClass ( i ) = 5 then
57276: LD_VAR 0 6
57280: PPUSH
57281: CALL_OW 257
57285: PUSH
57286: LD_INT 5
57288: EQUAL
57289: IFFALSE 57310
// points := [ 130 , 5 , 2 ] ;
57291: LD_ADDR_VAR 0 9
57295: PUSH
57296: LD_INT 130
57298: PUSH
57299: LD_INT 5
57301: PUSH
57302: LD_INT 2
57304: PUSH
57305: EMPTY
57306: LIST
57307: LIST
57308: LIST
57309: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57310: LD_VAR 0 6
57314: PPUSH
57315: CALL_OW 257
57319: PUSH
57320: LD_INT 8
57322: EQUAL
57323: IFFALSE 57344
// points := [ 35 , 35 , 30 ] ;
57325: LD_ADDR_VAR 0 9
57329: PUSH
57330: LD_INT 35
57332: PUSH
57333: LD_INT 35
57335: PUSH
57336: LD_INT 30
57338: PUSH
57339: EMPTY
57340: LIST
57341: LIST
57342: LIST
57343: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57344: LD_VAR 0 6
57348: PPUSH
57349: CALL_OW 257
57353: PUSH
57354: LD_INT 9
57356: EQUAL
57357: IFFALSE 57378
// points := [ 20 , 55 , 40 ] ;
57359: LD_ADDR_VAR 0 9
57363: PUSH
57364: LD_INT 20
57366: PUSH
57367: LD_INT 55
57369: PUSH
57370: LD_INT 40
57372: PUSH
57373: EMPTY
57374: LIST
57375: LIST
57376: LIST
57377: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57378: LD_VAR 0 6
57382: PPUSH
57383: CALL_OW 257
57387: PUSH
57388: LD_INT 12
57390: PUSH
57391: LD_INT 16
57393: PUSH
57394: EMPTY
57395: LIST
57396: LIST
57397: IN
57398: IFFALSE 57419
// points := [ 5 , 3 , 2 ] ;
57400: LD_ADDR_VAR 0 9
57404: PUSH
57405: LD_INT 5
57407: PUSH
57408: LD_INT 3
57410: PUSH
57411: LD_INT 2
57413: PUSH
57414: EMPTY
57415: LIST
57416: LIST
57417: LIST
57418: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57419: LD_VAR 0 6
57423: PPUSH
57424: CALL_OW 257
57428: PUSH
57429: LD_INT 17
57431: EQUAL
57432: IFFALSE 57453
// points := [ 100 , 50 , 75 ] ;
57434: LD_ADDR_VAR 0 9
57438: PUSH
57439: LD_INT 100
57441: PUSH
57442: LD_INT 50
57444: PUSH
57445: LD_INT 75
57447: PUSH
57448: EMPTY
57449: LIST
57450: LIST
57451: LIST
57452: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57453: LD_VAR 0 6
57457: PPUSH
57458: CALL_OW 257
57462: PUSH
57463: LD_INT 15
57465: EQUAL
57466: IFFALSE 57487
// points := [ 10 , 5 , 3 ] ;
57468: LD_ADDR_VAR 0 9
57472: PUSH
57473: LD_INT 10
57475: PUSH
57476: LD_INT 5
57478: PUSH
57479: LD_INT 3
57481: PUSH
57482: EMPTY
57483: LIST
57484: LIST
57485: LIST
57486: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57487: LD_VAR 0 6
57491: PPUSH
57492: CALL_OW 257
57496: PUSH
57497: LD_INT 14
57499: EQUAL
57500: IFFALSE 57521
// points := [ 10 , 0 , 0 ] ;
57502: LD_ADDR_VAR 0 9
57506: PUSH
57507: LD_INT 10
57509: PUSH
57510: LD_INT 0
57512: PUSH
57513: LD_INT 0
57515: PUSH
57516: EMPTY
57517: LIST
57518: LIST
57519: LIST
57520: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57521: LD_VAR 0 6
57525: PPUSH
57526: CALL_OW 257
57530: PUSH
57531: LD_INT 11
57533: EQUAL
57534: IFFALSE 57555
// points := [ 30 , 10 , 5 ] ;
57536: LD_ADDR_VAR 0 9
57540: PUSH
57541: LD_INT 30
57543: PUSH
57544: LD_INT 10
57546: PUSH
57547: LD_INT 5
57549: PUSH
57550: EMPTY
57551: LIST
57552: LIST
57553: LIST
57554: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57555: LD_VAR 0 1
57559: PPUSH
57560: LD_INT 5
57562: PPUSH
57563: CALL_OW 321
57567: PUSH
57568: LD_INT 2
57570: EQUAL
57571: IFFALSE 57588
// bpoints := bpoints * 1.8 ;
57573: LD_ADDR_VAR 0 10
57577: PUSH
57578: LD_VAR 0 10
57582: PUSH
57583: LD_REAL  1.80000000000000E+0000
57586: MUL
57587: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57588: LD_VAR 0 6
57592: PPUSH
57593: CALL_OW 257
57597: PUSH
57598: LD_INT 1
57600: PUSH
57601: LD_INT 2
57603: PUSH
57604: LD_INT 3
57606: PUSH
57607: LD_INT 4
57609: PUSH
57610: EMPTY
57611: LIST
57612: LIST
57613: LIST
57614: LIST
57615: IN
57616: PUSH
57617: LD_VAR 0 1
57621: PPUSH
57622: LD_INT 51
57624: PPUSH
57625: CALL_OW 321
57629: PUSH
57630: LD_INT 2
57632: EQUAL
57633: AND
57634: IFFALSE 57651
// bpoints := bpoints * 1.2 ;
57636: LD_ADDR_VAR 0 10
57640: PUSH
57641: LD_VAR 0 10
57645: PUSH
57646: LD_REAL  1.20000000000000E+0000
57649: MUL
57650: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57651: LD_VAR 0 6
57655: PPUSH
57656: CALL_OW 257
57660: PUSH
57661: LD_INT 5
57663: PUSH
57664: LD_INT 7
57666: PUSH
57667: LD_INT 9
57669: PUSH
57670: EMPTY
57671: LIST
57672: LIST
57673: LIST
57674: IN
57675: PUSH
57676: LD_VAR 0 1
57680: PPUSH
57681: LD_INT 52
57683: PPUSH
57684: CALL_OW 321
57688: PUSH
57689: LD_INT 2
57691: EQUAL
57692: AND
57693: IFFALSE 57710
// bpoints := bpoints * 1.5 ;
57695: LD_ADDR_VAR 0 10
57699: PUSH
57700: LD_VAR 0 10
57704: PUSH
57705: LD_REAL  1.50000000000000E+0000
57708: MUL
57709: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57710: LD_VAR 0 1
57714: PPUSH
57715: LD_INT 66
57717: PPUSH
57718: CALL_OW 321
57722: PUSH
57723: LD_INT 2
57725: EQUAL
57726: IFFALSE 57743
// bpoints := bpoints * 1.1 ;
57728: LD_ADDR_VAR 0 10
57732: PUSH
57733: LD_VAR 0 10
57737: PUSH
57738: LD_REAL  1.10000000000000E+0000
57741: MUL
57742: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57743: LD_ADDR_VAR 0 10
57747: PUSH
57748: LD_VAR 0 10
57752: PUSH
57753: LD_VAR 0 6
57757: PPUSH
57758: LD_INT 1
57760: PPUSH
57761: CALL_OW 259
57765: PUSH
57766: LD_REAL  1.15000000000000E+0000
57769: MUL
57770: MUL
57771: ST_TO_ADDR
// end ; unit_vehicle :
57772: GO 58602
57774: LD_INT 2
57776: DOUBLE
57777: EQUAL
57778: IFTRUE 57782
57780: GO 58590
57782: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57783: LD_VAR 0 6
57787: PPUSH
57788: CALL_OW 264
57792: PUSH
57793: LD_INT 2
57795: PUSH
57796: LD_INT 42
57798: PUSH
57799: LD_INT 24
57801: PUSH
57802: EMPTY
57803: LIST
57804: LIST
57805: LIST
57806: IN
57807: IFFALSE 57828
// points := [ 25 , 5 , 3 ] ;
57809: LD_ADDR_VAR 0 9
57813: PUSH
57814: LD_INT 25
57816: PUSH
57817: LD_INT 5
57819: PUSH
57820: LD_INT 3
57822: PUSH
57823: EMPTY
57824: LIST
57825: LIST
57826: LIST
57827: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57828: LD_VAR 0 6
57832: PPUSH
57833: CALL_OW 264
57837: PUSH
57838: LD_INT 4
57840: PUSH
57841: LD_INT 43
57843: PUSH
57844: LD_INT 25
57846: PUSH
57847: EMPTY
57848: LIST
57849: LIST
57850: LIST
57851: IN
57852: IFFALSE 57873
// points := [ 40 , 15 , 5 ] ;
57854: LD_ADDR_VAR 0 9
57858: PUSH
57859: LD_INT 40
57861: PUSH
57862: LD_INT 15
57864: PUSH
57865: LD_INT 5
57867: PUSH
57868: EMPTY
57869: LIST
57870: LIST
57871: LIST
57872: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57873: LD_VAR 0 6
57877: PPUSH
57878: CALL_OW 264
57882: PUSH
57883: LD_INT 3
57885: PUSH
57886: LD_INT 23
57888: PUSH
57889: EMPTY
57890: LIST
57891: LIST
57892: IN
57893: IFFALSE 57914
// points := [ 7 , 25 , 8 ] ;
57895: LD_ADDR_VAR 0 9
57899: PUSH
57900: LD_INT 7
57902: PUSH
57903: LD_INT 25
57905: PUSH
57906: LD_INT 8
57908: PUSH
57909: EMPTY
57910: LIST
57911: LIST
57912: LIST
57913: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
57914: LD_VAR 0 6
57918: PPUSH
57919: CALL_OW 264
57923: PUSH
57924: LD_INT 5
57926: PUSH
57927: LD_INT 27
57929: PUSH
57930: LD_INT 44
57932: PUSH
57933: EMPTY
57934: LIST
57935: LIST
57936: LIST
57937: IN
57938: IFFALSE 57959
// points := [ 14 , 50 , 16 ] ;
57940: LD_ADDR_VAR 0 9
57944: PUSH
57945: LD_INT 14
57947: PUSH
57948: LD_INT 50
57950: PUSH
57951: LD_INT 16
57953: PUSH
57954: EMPTY
57955: LIST
57956: LIST
57957: LIST
57958: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
57959: LD_VAR 0 6
57963: PPUSH
57964: CALL_OW 264
57968: PUSH
57969: LD_INT 6
57971: PUSH
57972: LD_INT 46
57974: PUSH
57975: EMPTY
57976: LIST
57977: LIST
57978: IN
57979: IFFALSE 58000
// points := [ 32 , 120 , 70 ] ;
57981: LD_ADDR_VAR 0 9
57985: PUSH
57986: LD_INT 32
57988: PUSH
57989: LD_INT 120
57991: PUSH
57992: LD_INT 70
57994: PUSH
57995: EMPTY
57996: LIST
57997: LIST
57998: LIST
57999: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58000: LD_VAR 0 6
58004: PPUSH
58005: CALL_OW 264
58009: PUSH
58010: LD_INT 7
58012: PUSH
58013: LD_INT 28
58015: PUSH
58016: LD_INT 45
58018: PUSH
58019: LD_EXP 77
58023: PUSH
58024: EMPTY
58025: LIST
58026: LIST
58027: LIST
58028: LIST
58029: IN
58030: IFFALSE 58051
// points := [ 35 , 20 , 45 ] ;
58032: LD_ADDR_VAR 0 9
58036: PUSH
58037: LD_INT 35
58039: PUSH
58040: LD_INT 20
58042: PUSH
58043: LD_INT 45
58045: PUSH
58046: EMPTY
58047: LIST
58048: LIST
58049: LIST
58050: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58051: LD_VAR 0 6
58055: PPUSH
58056: CALL_OW 264
58060: PUSH
58061: LD_INT 47
58063: PUSH
58064: EMPTY
58065: LIST
58066: IN
58067: IFFALSE 58088
// points := [ 67 , 45 , 75 ] ;
58069: LD_ADDR_VAR 0 9
58073: PUSH
58074: LD_INT 67
58076: PUSH
58077: LD_INT 45
58079: PUSH
58080: LD_INT 75
58082: PUSH
58083: EMPTY
58084: LIST
58085: LIST
58086: LIST
58087: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58088: LD_VAR 0 6
58092: PPUSH
58093: CALL_OW 264
58097: PUSH
58098: LD_INT 26
58100: PUSH
58101: EMPTY
58102: LIST
58103: IN
58104: IFFALSE 58125
// points := [ 120 , 30 , 80 ] ;
58106: LD_ADDR_VAR 0 9
58110: PUSH
58111: LD_INT 120
58113: PUSH
58114: LD_INT 30
58116: PUSH
58117: LD_INT 80
58119: PUSH
58120: EMPTY
58121: LIST
58122: LIST
58123: LIST
58124: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58125: LD_VAR 0 6
58129: PPUSH
58130: CALL_OW 264
58134: PUSH
58135: LD_INT 22
58137: PUSH
58138: EMPTY
58139: LIST
58140: IN
58141: IFFALSE 58162
// points := [ 40 , 1 , 1 ] ;
58143: LD_ADDR_VAR 0 9
58147: PUSH
58148: LD_INT 40
58150: PUSH
58151: LD_INT 1
58153: PUSH
58154: LD_INT 1
58156: PUSH
58157: EMPTY
58158: LIST
58159: LIST
58160: LIST
58161: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
58162: LD_VAR 0 6
58166: PPUSH
58167: CALL_OW 264
58171: PUSH
58172: LD_INT 29
58174: PUSH
58175: EMPTY
58176: LIST
58177: IN
58178: IFFALSE 58199
// points := [ 70 , 200 , 400 ] ;
58180: LD_ADDR_VAR 0 9
58184: PUSH
58185: LD_INT 70
58187: PUSH
58188: LD_INT 200
58190: PUSH
58191: LD_INT 400
58193: PUSH
58194: EMPTY
58195: LIST
58196: LIST
58197: LIST
58198: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
58199: LD_VAR 0 6
58203: PPUSH
58204: CALL_OW 264
58208: PUSH
58209: LD_INT 14
58211: PUSH
58212: LD_INT 53
58214: PUSH
58215: EMPTY
58216: LIST
58217: LIST
58218: IN
58219: IFFALSE 58240
// points := [ 40 , 10 , 20 ] ;
58221: LD_ADDR_VAR 0 9
58225: PUSH
58226: LD_INT 40
58228: PUSH
58229: LD_INT 10
58231: PUSH
58232: LD_INT 20
58234: PUSH
58235: EMPTY
58236: LIST
58237: LIST
58238: LIST
58239: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
58240: LD_VAR 0 6
58244: PPUSH
58245: CALL_OW 264
58249: PUSH
58250: LD_INT 9
58252: PUSH
58253: EMPTY
58254: LIST
58255: IN
58256: IFFALSE 58277
// points := [ 5 , 70 , 20 ] ;
58258: LD_ADDR_VAR 0 9
58262: PUSH
58263: LD_INT 5
58265: PUSH
58266: LD_INT 70
58268: PUSH
58269: LD_INT 20
58271: PUSH
58272: EMPTY
58273: LIST
58274: LIST
58275: LIST
58276: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
58277: LD_VAR 0 6
58281: PPUSH
58282: CALL_OW 264
58286: PUSH
58287: LD_INT 10
58289: PUSH
58290: EMPTY
58291: LIST
58292: IN
58293: IFFALSE 58314
// points := [ 35 , 110 , 70 ] ;
58295: LD_ADDR_VAR 0 9
58299: PUSH
58300: LD_INT 35
58302: PUSH
58303: LD_INT 110
58305: PUSH
58306: LD_INT 70
58308: PUSH
58309: EMPTY
58310: LIST
58311: LIST
58312: LIST
58313: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58314: LD_VAR 0 6
58318: PPUSH
58319: CALL_OW 265
58323: PUSH
58324: LD_INT 25
58326: EQUAL
58327: IFFALSE 58348
// points := [ 80 , 65 , 100 ] ;
58329: LD_ADDR_VAR 0 9
58333: PUSH
58334: LD_INT 80
58336: PUSH
58337: LD_INT 65
58339: PUSH
58340: LD_INT 100
58342: PUSH
58343: EMPTY
58344: LIST
58345: LIST
58346: LIST
58347: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58348: LD_VAR 0 6
58352: PPUSH
58353: CALL_OW 263
58357: PUSH
58358: LD_INT 1
58360: EQUAL
58361: IFFALSE 58396
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58363: LD_ADDR_VAR 0 10
58367: PUSH
58368: LD_VAR 0 10
58372: PUSH
58373: LD_VAR 0 6
58377: PPUSH
58378: CALL_OW 311
58382: PPUSH
58383: LD_INT 3
58385: PPUSH
58386: CALL_OW 259
58390: PUSH
58391: LD_INT 4
58393: MUL
58394: MUL
58395: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58396: LD_VAR 0 6
58400: PPUSH
58401: CALL_OW 263
58405: PUSH
58406: LD_INT 2
58408: EQUAL
58409: IFFALSE 58460
// begin j := IsControledBy ( i ) ;
58411: LD_ADDR_VAR 0 7
58415: PUSH
58416: LD_VAR 0 6
58420: PPUSH
58421: CALL_OW 312
58425: ST_TO_ADDR
// if j then
58426: LD_VAR 0 7
58430: IFFALSE 58460
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58432: LD_ADDR_VAR 0 10
58436: PUSH
58437: LD_VAR 0 10
58441: PUSH
58442: LD_VAR 0 7
58446: PPUSH
58447: LD_INT 3
58449: PPUSH
58450: CALL_OW 259
58454: PUSH
58455: LD_INT 3
58457: MUL
58458: MUL
58459: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58460: LD_VAR 0 6
58464: PPUSH
58465: CALL_OW 264
58469: PUSH
58470: LD_INT 5
58472: PUSH
58473: LD_INT 6
58475: PUSH
58476: LD_INT 46
58478: PUSH
58479: LD_INT 44
58481: PUSH
58482: LD_INT 47
58484: PUSH
58485: LD_INT 45
58487: PUSH
58488: LD_INT 28
58490: PUSH
58491: LD_INT 7
58493: PUSH
58494: LD_INT 27
58496: PUSH
58497: LD_INT 29
58499: PUSH
58500: EMPTY
58501: LIST
58502: LIST
58503: LIST
58504: LIST
58505: LIST
58506: LIST
58507: LIST
58508: LIST
58509: LIST
58510: LIST
58511: IN
58512: PUSH
58513: LD_VAR 0 1
58517: PPUSH
58518: LD_INT 52
58520: PPUSH
58521: CALL_OW 321
58525: PUSH
58526: LD_INT 2
58528: EQUAL
58529: AND
58530: IFFALSE 58547
// bpoints := bpoints * 1.2 ;
58532: LD_ADDR_VAR 0 10
58536: PUSH
58537: LD_VAR 0 10
58541: PUSH
58542: LD_REAL  1.20000000000000E+0000
58545: MUL
58546: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58547: LD_VAR 0 6
58551: PPUSH
58552: CALL_OW 264
58556: PUSH
58557: LD_INT 6
58559: PUSH
58560: LD_INT 46
58562: PUSH
58563: LD_INT 47
58565: PUSH
58566: EMPTY
58567: LIST
58568: LIST
58569: LIST
58570: IN
58571: IFFALSE 58588
// bpoints := bpoints * 1.2 ;
58573: LD_ADDR_VAR 0 10
58577: PUSH
58578: LD_VAR 0 10
58582: PUSH
58583: LD_REAL  1.20000000000000E+0000
58586: MUL
58587: ST_TO_ADDR
// end ; unit_building :
58588: GO 58602
58590: LD_INT 3
58592: DOUBLE
58593: EQUAL
58594: IFTRUE 58598
58596: GO 58601
58598: POP
// ; end ;
58599: GO 58602
58601: POP
// for j = 1 to 3 do
58602: LD_ADDR_VAR 0 7
58606: PUSH
58607: DOUBLE
58608: LD_INT 1
58610: DEC
58611: ST_TO_ADDR
58612: LD_INT 3
58614: PUSH
58615: FOR_TO
58616: IFFALSE 58669
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58618: LD_ADDR_VAR 0 5
58622: PUSH
58623: LD_VAR 0 5
58627: PPUSH
58628: LD_VAR 0 7
58632: PPUSH
58633: LD_VAR 0 5
58637: PUSH
58638: LD_VAR 0 7
58642: ARRAY
58643: PUSH
58644: LD_VAR 0 9
58648: PUSH
58649: LD_VAR 0 7
58653: ARRAY
58654: PUSH
58655: LD_VAR 0 10
58659: MUL
58660: PLUS
58661: PPUSH
58662: CALL_OW 1
58666: ST_TO_ADDR
58667: GO 58615
58669: POP
58670: POP
// end ;
58671: GO 57148
58673: POP
58674: POP
// result := Replace ( result , 4 , tmp ) ;
58675: LD_ADDR_VAR 0 5
58679: PUSH
58680: LD_VAR 0 5
58684: PPUSH
58685: LD_INT 4
58687: PPUSH
58688: LD_VAR 0 8
58692: PPUSH
58693: CALL_OW 1
58697: ST_TO_ADDR
// end ;
58698: LD_VAR 0 5
58702: RET
// export function DangerAtRange ( unit , range ) ; begin
58703: LD_INT 0
58705: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58706: LD_ADDR_VAR 0 3
58710: PUSH
58711: LD_VAR 0 1
58715: PPUSH
58716: CALL_OW 255
58720: PPUSH
58721: LD_VAR 0 1
58725: PPUSH
58726: CALL_OW 250
58730: PPUSH
58731: LD_VAR 0 1
58735: PPUSH
58736: CALL_OW 251
58740: PPUSH
58741: LD_VAR 0 2
58745: PPUSH
58746: CALL 57000 0 4
58750: ST_TO_ADDR
// end ;
58751: LD_VAR 0 3
58755: RET
// export function DangerInArea ( side , area ) ; begin
58756: LD_INT 0
58758: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58759: LD_ADDR_VAR 0 3
58763: PUSH
58764: LD_VAR 0 2
58768: PPUSH
58769: LD_INT 81
58771: PUSH
58772: LD_VAR 0 1
58776: PUSH
58777: EMPTY
58778: LIST
58779: LIST
58780: PPUSH
58781: CALL_OW 70
58785: ST_TO_ADDR
// end ;
58786: LD_VAR 0 3
58790: RET
// export function IsExtension ( b ) ; begin
58791: LD_INT 0
58793: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58794: LD_ADDR_VAR 0 2
58798: PUSH
58799: LD_VAR 0 1
58803: PUSH
58804: LD_INT 23
58806: PUSH
58807: LD_INT 20
58809: PUSH
58810: LD_INT 22
58812: PUSH
58813: LD_INT 17
58815: PUSH
58816: LD_INT 24
58818: PUSH
58819: LD_INT 21
58821: PUSH
58822: LD_INT 19
58824: PUSH
58825: LD_INT 16
58827: PUSH
58828: LD_INT 25
58830: PUSH
58831: LD_INT 18
58833: PUSH
58834: EMPTY
58835: LIST
58836: LIST
58837: LIST
58838: LIST
58839: LIST
58840: LIST
58841: LIST
58842: LIST
58843: LIST
58844: LIST
58845: IN
58846: ST_TO_ADDR
// end ;
58847: LD_VAR 0 2
58851: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
58852: LD_INT 0
58854: PPUSH
58855: PPUSH
58856: PPUSH
// result := [ ] ;
58857: LD_ADDR_VAR 0 4
58861: PUSH
58862: EMPTY
58863: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58864: LD_ADDR_VAR 0 5
58868: PUSH
58869: LD_VAR 0 2
58873: PPUSH
58874: LD_INT 21
58876: PUSH
58877: LD_INT 3
58879: PUSH
58880: EMPTY
58881: LIST
58882: LIST
58883: PPUSH
58884: CALL_OW 70
58888: ST_TO_ADDR
// if not tmp then
58889: LD_VAR 0 5
58893: NOT
58894: IFFALSE 58898
// exit ;
58896: GO 58962
// if checkLink then
58898: LD_VAR 0 3
58902: IFFALSE 58952
// begin for i in tmp do
58904: LD_ADDR_VAR 0 6
58908: PUSH
58909: LD_VAR 0 5
58913: PUSH
58914: FOR_IN
58915: IFFALSE 58950
// if GetBase ( i ) <> base then
58917: LD_VAR 0 6
58921: PPUSH
58922: CALL_OW 274
58926: PUSH
58927: LD_VAR 0 1
58931: NONEQUAL
58932: IFFALSE 58948
// ComLinkToBase ( base , i ) ;
58934: LD_VAR 0 1
58938: PPUSH
58939: LD_VAR 0 6
58943: PPUSH
58944: CALL_OW 169
58948: GO 58914
58950: POP
58951: POP
// end ; result := tmp ;
58952: LD_ADDR_VAR 0 4
58956: PUSH
58957: LD_VAR 0 5
58961: ST_TO_ADDR
// end ;
58962: LD_VAR 0 4
58966: RET
// export function ComComplete ( units , b ) ; var i ; begin
58967: LD_INT 0
58969: PPUSH
58970: PPUSH
// if not units then
58971: LD_VAR 0 1
58975: NOT
58976: IFFALSE 58980
// exit ;
58978: GO 59070
// for i in units do
58980: LD_ADDR_VAR 0 4
58984: PUSH
58985: LD_VAR 0 1
58989: PUSH
58990: FOR_IN
58991: IFFALSE 59068
// if BuildingStatus ( b ) = bs_build then
58993: LD_VAR 0 2
58997: PPUSH
58998: CALL_OW 461
59002: PUSH
59003: LD_INT 1
59005: EQUAL
59006: IFFALSE 59066
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59008: LD_VAR 0 4
59012: PPUSH
59013: LD_STRING h
59015: PUSH
59016: LD_VAR 0 2
59020: PPUSH
59021: CALL_OW 250
59025: PUSH
59026: LD_VAR 0 2
59030: PPUSH
59031: CALL_OW 251
59035: PUSH
59036: LD_VAR 0 2
59040: PUSH
59041: LD_INT 0
59043: PUSH
59044: LD_INT 0
59046: PUSH
59047: LD_INT 0
59049: PUSH
59050: EMPTY
59051: LIST
59052: LIST
59053: LIST
59054: LIST
59055: LIST
59056: LIST
59057: LIST
59058: PUSH
59059: EMPTY
59060: LIST
59061: PPUSH
59062: CALL_OW 446
59066: GO 58990
59068: POP
59069: POP
// end ;
59070: LD_VAR 0 3
59074: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59075: LD_INT 0
59077: PPUSH
59078: PPUSH
59079: PPUSH
59080: PPUSH
59081: PPUSH
59082: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
59083: LD_VAR 0 1
59087: NOT
59088: PUSH
59089: LD_VAR 0 1
59093: PPUSH
59094: CALL_OW 263
59098: PUSH
59099: LD_INT 2
59101: EQUAL
59102: NOT
59103: OR
59104: IFFALSE 59108
// exit ;
59106: GO 59424
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59108: LD_ADDR_VAR 0 6
59112: PUSH
59113: LD_INT 22
59115: PUSH
59116: LD_VAR 0 1
59120: PPUSH
59121: CALL_OW 255
59125: PUSH
59126: EMPTY
59127: LIST
59128: LIST
59129: PUSH
59130: LD_INT 2
59132: PUSH
59133: LD_INT 30
59135: PUSH
59136: LD_INT 36
59138: PUSH
59139: EMPTY
59140: LIST
59141: LIST
59142: PUSH
59143: LD_INT 34
59145: PUSH
59146: LD_INT 31
59148: PUSH
59149: EMPTY
59150: LIST
59151: LIST
59152: PUSH
59153: EMPTY
59154: LIST
59155: LIST
59156: LIST
59157: PUSH
59158: EMPTY
59159: LIST
59160: LIST
59161: PPUSH
59162: CALL_OW 69
59166: ST_TO_ADDR
// if not tmp then
59167: LD_VAR 0 6
59171: NOT
59172: IFFALSE 59176
// exit ;
59174: GO 59424
// result := [ ] ;
59176: LD_ADDR_VAR 0 2
59180: PUSH
59181: EMPTY
59182: ST_TO_ADDR
// for i in tmp do
59183: LD_ADDR_VAR 0 3
59187: PUSH
59188: LD_VAR 0 6
59192: PUSH
59193: FOR_IN
59194: IFFALSE 59265
// begin t := UnitsInside ( i ) ;
59196: LD_ADDR_VAR 0 4
59200: PUSH
59201: LD_VAR 0 3
59205: PPUSH
59206: CALL_OW 313
59210: ST_TO_ADDR
// if t then
59211: LD_VAR 0 4
59215: IFFALSE 59263
// for j in t do
59217: LD_ADDR_VAR 0 7
59221: PUSH
59222: LD_VAR 0 4
59226: PUSH
59227: FOR_IN
59228: IFFALSE 59261
// result := Insert ( result , result + 1 , j ) ;
59230: LD_ADDR_VAR 0 2
59234: PUSH
59235: LD_VAR 0 2
59239: PPUSH
59240: LD_VAR 0 2
59244: PUSH
59245: LD_INT 1
59247: PLUS
59248: PPUSH
59249: LD_VAR 0 7
59253: PPUSH
59254: CALL_OW 2
59258: ST_TO_ADDR
59259: GO 59227
59261: POP
59262: POP
// end ;
59263: GO 59193
59265: POP
59266: POP
// if not result then
59267: LD_VAR 0 2
59271: NOT
59272: IFFALSE 59276
// exit ;
59274: GO 59424
// mech := result [ 1 ] ;
59276: LD_ADDR_VAR 0 5
59280: PUSH
59281: LD_VAR 0 2
59285: PUSH
59286: LD_INT 1
59288: ARRAY
59289: ST_TO_ADDR
// if result > 1 then
59290: LD_VAR 0 2
59294: PUSH
59295: LD_INT 1
59297: GREATER
59298: IFFALSE 59410
// for i = 2 to result do
59300: LD_ADDR_VAR 0 3
59304: PUSH
59305: DOUBLE
59306: LD_INT 2
59308: DEC
59309: ST_TO_ADDR
59310: LD_VAR 0 2
59314: PUSH
59315: FOR_TO
59316: IFFALSE 59408
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
59318: LD_ADDR_VAR 0 4
59322: PUSH
59323: LD_VAR 0 2
59327: PUSH
59328: LD_VAR 0 3
59332: ARRAY
59333: PPUSH
59334: LD_INT 3
59336: PPUSH
59337: CALL_OW 259
59341: PUSH
59342: LD_VAR 0 2
59346: PUSH
59347: LD_VAR 0 3
59351: ARRAY
59352: PPUSH
59353: CALL_OW 432
59357: MINUS
59358: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59359: LD_VAR 0 4
59363: PUSH
59364: LD_VAR 0 5
59368: PPUSH
59369: LD_INT 3
59371: PPUSH
59372: CALL_OW 259
59376: PUSH
59377: LD_VAR 0 5
59381: PPUSH
59382: CALL_OW 432
59386: MINUS
59387: GREATEREQUAL
59388: IFFALSE 59406
// mech := result [ i ] ;
59390: LD_ADDR_VAR 0 5
59394: PUSH
59395: LD_VAR 0 2
59399: PUSH
59400: LD_VAR 0 3
59404: ARRAY
59405: ST_TO_ADDR
// end ;
59406: GO 59315
59408: POP
59409: POP
// ComLinkTo ( vehicle , mech ) ;
59410: LD_VAR 0 1
59414: PPUSH
59415: LD_VAR 0 5
59419: PPUSH
59420: CALL_OW 135
// end ;
59424: LD_VAR 0 2
59428: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59429: LD_INT 0
59431: PPUSH
59432: PPUSH
59433: PPUSH
59434: PPUSH
59435: PPUSH
59436: PPUSH
59437: PPUSH
59438: PPUSH
59439: PPUSH
59440: PPUSH
59441: PPUSH
59442: PPUSH
59443: PPUSH
// result := [ ] ;
59444: LD_ADDR_VAR 0 7
59448: PUSH
59449: EMPTY
59450: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59451: LD_VAR 0 1
59455: PPUSH
59456: CALL_OW 266
59460: PUSH
59461: LD_INT 0
59463: PUSH
59464: LD_INT 1
59466: PUSH
59467: EMPTY
59468: LIST
59469: LIST
59470: IN
59471: NOT
59472: IFFALSE 59476
// exit ;
59474: GO 61110
// if name then
59476: LD_VAR 0 3
59480: IFFALSE 59496
// SetBName ( base_dep , name ) ;
59482: LD_VAR 0 1
59486: PPUSH
59487: LD_VAR 0 3
59491: PPUSH
59492: CALL_OW 500
// base := GetBase ( base_dep ) ;
59496: LD_ADDR_VAR 0 15
59500: PUSH
59501: LD_VAR 0 1
59505: PPUSH
59506: CALL_OW 274
59510: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59511: LD_ADDR_VAR 0 16
59515: PUSH
59516: LD_VAR 0 1
59520: PPUSH
59521: CALL_OW 255
59525: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59526: LD_ADDR_VAR 0 17
59530: PUSH
59531: LD_VAR 0 1
59535: PPUSH
59536: CALL_OW 248
59540: ST_TO_ADDR
// if sources then
59541: LD_VAR 0 5
59545: IFFALSE 59592
// for i = 1 to 3 do
59547: LD_ADDR_VAR 0 8
59551: PUSH
59552: DOUBLE
59553: LD_INT 1
59555: DEC
59556: ST_TO_ADDR
59557: LD_INT 3
59559: PUSH
59560: FOR_TO
59561: IFFALSE 59590
// AddResourceType ( base , i , sources [ i ] ) ;
59563: LD_VAR 0 15
59567: PPUSH
59568: LD_VAR 0 8
59572: PPUSH
59573: LD_VAR 0 5
59577: PUSH
59578: LD_VAR 0 8
59582: ARRAY
59583: PPUSH
59584: CALL_OW 276
59588: GO 59560
59590: POP
59591: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
59592: LD_ADDR_VAR 0 18
59596: PUSH
59597: LD_VAR 0 15
59601: PPUSH
59602: LD_VAR 0 2
59606: PPUSH
59607: LD_INT 1
59609: PPUSH
59610: CALL 58852 0 3
59614: ST_TO_ADDR
// InitHc ;
59615: CALL_OW 19
// InitUc ;
59619: CALL_OW 18
// uc_side := side ;
59623: LD_ADDR_OWVAR 20
59627: PUSH
59628: LD_VAR 0 16
59632: ST_TO_ADDR
// uc_nation := nation ;
59633: LD_ADDR_OWVAR 21
59637: PUSH
59638: LD_VAR 0 17
59642: ST_TO_ADDR
// if buildings then
59643: LD_VAR 0 18
59647: IFFALSE 60969
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59649: LD_ADDR_VAR 0 19
59653: PUSH
59654: LD_VAR 0 18
59658: PPUSH
59659: LD_INT 2
59661: PUSH
59662: LD_INT 30
59664: PUSH
59665: LD_INT 29
59667: PUSH
59668: EMPTY
59669: LIST
59670: LIST
59671: PUSH
59672: LD_INT 30
59674: PUSH
59675: LD_INT 30
59677: PUSH
59678: EMPTY
59679: LIST
59680: LIST
59681: PUSH
59682: EMPTY
59683: LIST
59684: LIST
59685: LIST
59686: PPUSH
59687: CALL_OW 72
59691: ST_TO_ADDR
// if tmp then
59692: LD_VAR 0 19
59696: IFFALSE 59744
// for i in tmp do
59698: LD_ADDR_VAR 0 8
59702: PUSH
59703: LD_VAR 0 19
59707: PUSH
59708: FOR_IN
59709: IFFALSE 59742
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59711: LD_VAR 0 8
59715: PPUSH
59716: CALL_OW 250
59720: PPUSH
59721: LD_VAR 0 8
59725: PPUSH
59726: CALL_OW 251
59730: PPUSH
59731: LD_VAR 0 16
59735: PPUSH
59736: CALL_OW 441
59740: GO 59708
59742: POP
59743: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59744: LD_VAR 0 18
59748: PPUSH
59749: LD_INT 2
59751: PUSH
59752: LD_INT 30
59754: PUSH
59755: LD_INT 32
59757: PUSH
59758: EMPTY
59759: LIST
59760: LIST
59761: PUSH
59762: LD_INT 30
59764: PUSH
59765: LD_INT 33
59767: PUSH
59768: EMPTY
59769: LIST
59770: LIST
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: LIST
59776: PPUSH
59777: CALL_OW 72
59781: IFFALSE 59869
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59783: LD_ADDR_VAR 0 8
59787: PUSH
59788: LD_VAR 0 18
59792: PPUSH
59793: LD_INT 2
59795: PUSH
59796: LD_INT 30
59798: PUSH
59799: LD_INT 32
59801: PUSH
59802: EMPTY
59803: LIST
59804: LIST
59805: PUSH
59806: LD_INT 30
59808: PUSH
59809: LD_INT 33
59811: PUSH
59812: EMPTY
59813: LIST
59814: LIST
59815: PUSH
59816: EMPTY
59817: LIST
59818: LIST
59819: LIST
59820: PPUSH
59821: CALL_OW 72
59825: PUSH
59826: FOR_IN
59827: IFFALSE 59867
// begin if not GetBWeapon ( i ) then
59829: LD_VAR 0 8
59833: PPUSH
59834: CALL_OW 269
59838: NOT
59839: IFFALSE 59865
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59841: LD_VAR 0 8
59845: PPUSH
59846: LD_VAR 0 8
59850: PPUSH
59851: LD_VAR 0 2
59855: PPUSH
59856: CALL 61115 0 2
59860: PPUSH
59861: CALL_OW 431
// end ;
59865: GO 59826
59867: POP
59868: POP
// end ; for i = 1 to personel do
59869: LD_ADDR_VAR 0 8
59873: PUSH
59874: DOUBLE
59875: LD_INT 1
59877: DEC
59878: ST_TO_ADDR
59879: LD_VAR 0 6
59883: PUSH
59884: FOR_TO
59885: IFFALSE 60949
// begin if i > 4 then
59887: LD_VAR 0 8
59891: PUSH
59892: LD_INT 4
59894: GREATER
59895: IFFALSE 59899
// break ;
59897: GO 60949
// case i of 1 :
59899: LD_VAR 0 8
59903: PUSH
59904: LD_INT 1
59906: DOUBLE
59907: EQUAL
59908: IFTRUE 59912
59910: GO 59992
59912: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59913: LD_ADDR_VAR 0 12
59917: PUSH
59918: LD_VAR 0 18
59922: PPUSH
59923: LD_INT 22
59925: PUSH
59926: LD_VAR 0 16
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: PUSH
59935: LD_INT 58
59937: PUSH
59938: EMPTY
59939: LIST
59940: PUSH
59941: LD_INT 2
59943: PUSH
59944: LD_INT 30
59946: PUSH
59947: LD_INT 32
59949: PUSH
59950: EMPTY
59951: LIST
59952: LIST
59953: PUSH
59954: LD_INT 30
59956: PUSH
59957: LD_INT 4
59959: PUSH
59960: EMPTY
59961: LIST
59962: LIST
59963: PUSH
59964: LD_INT 30
59966: PUSH
59967: LD_INT 5
59969: PUSH
59970: EMPTY
59971: LIST
59972: LIST
59973: PUSH
59974: EMPTY
59975: LIST
59976: LIST
59977: LIST
59978: LIST
59979: PUSH
59980: EMPTY
59981: LIST
59982: LIST
59983: LIST
59984: PPUSH
59985: CALL_OW 72
59989: ST_TO_ADDR
59990: GO 60214
59992: LD_INT 2
59994: DOUBLE
59995: EQUAL
59996: IFTRUE 60000
59998: GO 60062
60000: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60001: LD_ADDR_VAR 0 12
60005: PUSH
60006: LD_VAR 0 18
60010: PPUSH
60011: LD_INT 22
60013: PUSH
60014: LD_VAR 0 16
60018: PUSH
60019: EMPTY
60020: LIST
60021: LIST
60022: PUSH
60023: LD_INT 2
60025: PUSH
60026: LD_INT 30
60028: PUSH
60029: LD_INT 0
60031: PUSH
60032: EMPTY
60033: LIST
60034: LIST
60035: PUSH
60036: LD_INT 30
60038: PUSH
60039: LD_INT 1
60041: PUSH
60042: EMPTY
60043: LIST
60044: LIST
60045: PUSH
60046: EMPTY
60047: LIST
60048: LIST
60049: LIST
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: PPUSH
60055: CALL_OW 72
60059: ST_TO_ADDR
60060: GO 60214
60062: LD_INT 3
60064: DOUBLE
60065: EQUAL
60066: IFTRUE 60070
60068: GO 60132
60070: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60071: LD_ADDR_VAR 0 12
60075: PUSH
60076: LD_VAR 0 18
60080: PPUSH
60081: LD_INT 22
60083: PUSH
60084: LD_VAR 0 16
60088: PUSH
60089: EMPTY
60090: LIST
60091: LIST
60092: PUSH
60093: LD_INT 2
60095: PUSH
60096: LD_INT 30
60098: PUSH
60099: LD_INT 2
60101: PUSH
60102: EMPTY
60103: LIST
60104: LIST
60105: PUSH
60106: LD_INT 30
60108: PUSH
60109: LD_INT 3
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: PUSH
60116: EMPTY
60117: LIST
60118: LIST
60119: LIST
60120: PUSH
60121: EMPTY
60122: LIST
60123: LIST
60124: PPUSH
60125: CALL_OW 72
60129: ST_TO_ADDR
60130: GO 60214
60132: LD_INT 4
60134: DOUBLE
60135: EQUAL
60136: IFTRUE 60140
60138: GO 60213
60140: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60141: LD_ADDR_VAR 0 12
60145: PUSH
60146: LD_VAR 0 18
60150: PPUSH
60151: LD_INT 22
60153: PUSH
60154: LD_VAR 0 16
60158: PUSH
60159: EMPTY
60160: LIST
60161: LIST
60162: PUSH
60163: LD_INT 2
60165: PUSH
60166: LD_INT 30
60168: PUSH
60169: LD_INT 6
60171: PUSH
60172: EMPTY
60173: LIST
60174: LIST
60175: PUSH
60176: LD_INT 30
60178: PUSH
60179: LD_INT 7
60181: PUSH
60182: EMPTY
60183: LIST
60184: LIST
60185: PUSH
60186: LD_INT 30
60188: PUSH
60189: LD_INT 8
60191: PUSH
60192: EMPTY
60193: LIST
60194: LIST
60195: PUSH
60196: EMPTY
60197: LIST
60198: LIST
60199: LIST
60200: LIST
60201: PUSH
60202: EMPTY
60203: LIST
60204: LIST
60205: PPUSH
60206: CALL_OW 72
60210: ST_TO_ADDR
60211: GO 60214
60213: POP
// if i = 1 then
60214: LD_VAR 0 8
60218: PUSH
60219: LD_INT 1
60221: EQUAL
60222: IFFALSE 60333
// begin tmp := [ ] ;
60224: LD_ADDR_VAR 0 19
60228: PUSH
60229: EMPTY
60230: ST_TO_ADDR
// for j in f do
60231: LD_ADDR_VAR 0 9
60235: PUSH
60236: LD_VAR 0 12
60240: PUSH
60241: FOR_IN
60242: IFFALSE 60315
// if GetBType ( j ) = b_bunker then
60244: LD_VAR 0 9
60248: PPUSH
60249: CALL_OW 266
60253: PUSH
60254: LD_INT 32
60256: EQUAL
60257: IFFALSE 60284
// tmp := Insert ( tmp , 1 , j ) else
60259: LD_ADDR_VAR 0 19
60263: PUSH
60264: LD_VAR 0 19
60268: PPUSH
60269: LD_INT 1
60271: PPUSH
60272: LD_VAR 0 9
60276: PPUSH
60277: CALL_OW 2
60281: ST_TO_ADDR
60282: GO 60313
// tmp := Insert ( tmp , tmp + 1 , j ) ;
60284: LD_ADDR_VAR 0 19
60288: PUSH
60289: LD_VAR 0 19
60293: PPUSH
60294: LD_VAR 0 19
60298: PUSH
60299: LD_INT 1
60301: PLUS
60302: PPUSH
60303: LD_VAR 0 9
60307: PPUSH
60308: CALL_OW 2
60312: ST_TO_ADDR
60313: GO 60241
60315: POP
60316: POP
// if tmp then
60317: LD_VAR 0 19
60321: IFFALSE 60333
// f := tmp ;
60323: LD_ADDR_VAR 0 12
60327: PUSH
60328: LD_VAR 0 19
60332: ST_TO_ADDR
// end ; x := personel [ i ] ;
60333: LD_ADDR_VAR 0 13
60337: PUSH
60338: LD_VAR 0 6
60342: PUSH
60343: LD_VAR 0 8
60347: ARRAY
60348: ST_TO_ADDR
// if x = - 1 then
60349: LD_VAR 0 13
60353: PUSH
60354: LD_INT 1
60356: NEG
60357: EQUAL
60358: IFFALSE 60567
// begin for j in f do
60360: LD_ADDR_VAR 0 9
60364: PUSH
60365: LD_VAR 0 12
60369: PUSH
60370: FOR_IN
60371: IFFALSE 60563
// repeat InitHc ;
60373: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60377: LD_VAR 0 9
60381: PPUSH
60382: CALL_OW 266
60386: PUSH
60387: LD_INT 5
60389: EQUAL
60390: IFFALSE 60460
// begin if UnitsInside ( j ) < 3 then
60392: LD_VAR 0 9
60396: PPUSH
60397: CALL_OW 313
60401: PUSH
60402: LD_INT 3
60404: LESS
60405: IFFALSE 60441
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60407: LD_INT 0
60409: PPUSH
60410: LD_INT 5
60412: PUSH
60413: LD_INT 8
60415: PUSH
60416: LD_INT 9
60418: PUSH
60419: EMPTY
60420: LIST
60421: LIST
60422: LIST
60423: PUSH
60424: LD_VAR 0 17
60428: ARRAY
60429: PPUSH
60430: LD_VAR 0 4
60434: PPUSH
60435: CALL_OW 380
60439: GO 60458
// PrepareHuman ( false , i , skill ) ;
60441: LD_INT 0
60443: PPUSH
60444: LD_VAR 0 8
60448: PPUSH
60449: LD_VAR 0 4
60453: PPUSH
60454: CALL_OW 380
// end else
60458: GO 60477
// PrepareHuman ( false , i , skill ) ;
60460: LD_INT 0
60462: PPUSH
60463: LD_VAR 0 8
60467: PPUSH
60468: LD_VAR 0 4
60472: PPUSH
60473: CALL_OW 380
// un := CreateHuman ;
60477: LD_ADDR_VAR 0 14
60481: PUSH
60482: CALL_OW 44
60486: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60487: LD_ADDR_VAR 0 7
60491: PUSH
60492: LD_VAR 0 7
60496: PPUSH
60497: LD_INT 1
60499: PPUSH
60500: LD_VAR 0 14
60504: PPUSH
60505: CALL_OW 2
60509: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60510: LD_VAR 0 14
60514: PPUSH
60515: LD_VAR 0 9
60519: PPUSH
60520: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60524: LD_VAR 0 9
60528: PPUSH
60529: CALL_OW 313
60533: PUSH
60534: LD_INT 6
60536: EQUAL
60537: PUSH
60538: LD_VAR 0 9
60542: PPUSH
60543: CALL_OW 266
60547: PUSH
60548: LD_INT 32
60550: PUSH
60551: LD_INT 31
60553: PUSH
60554: EMPTY
60555: LIST
60556: LIST
60557: IN
60558: OR
60559: IFFALSE 60373
60561: GO 60370
60563: POP
60564: POP
// end else
60565: GO 60947
// for j = 1 to x do
60567: LD_ADDR_VAR 0 9
60571: PUSH
60572: DOUBLE
60573: LD_INT 1
60575: DEC
60576: ST_TO_ADDR
60577: LD_VAR 0 13
60581: PUSH
60582: FOR_TO
60583: IFFALSE 60945
// begin InitHc ;
60585: CALL_OW 19
// if not f then
60589: LD_VAR 0 12
60593: NOT
60594: IFFALSE 60683
// begin PrepareHuman ( false , i , skill ) ;
60596: LD_INT 0
60598: PPUSH
60599: LD_VAR 0 8
60603: PPUSH
60604: LD_VAR 0 4
60608: PPUSH
60609: CALL_OW 380
// un := CreateHuman ;
60613: LD_ADDR_VAR 0 14
60617: PUSH
60618: CALL_OW 44
60622: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60623: LD_ADDR_VAR 0 7
60627: PUSH
60628: LD_VAR 0 7
60632: PPUSH
60633: LD_INT 1
60635: PPUSH
60636: LD_VAR 0 14
60640: PPUSH
60641: CALL_OW 2
60645: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60646: LD_VAR 0 14
60650: PPUSH
60651: LD_VAR 0 1
60655: PPUSH
60656: CALL_OW 250
60660: PPUSH
60661: LD_VAR 0 1
60665: PPUSH
60666: CALL_OW 251
60670: PPUSH
60671: LD_INT 10
60673: PPUSH
60674: LD_INT 0
60676: PPUSH
60677: CALL_OW 50
// continue ;
60681: GO 60582
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60683: LD_VAR 0 12
60687: PUSH
60688: LD_INT 1
60690: ARRAY
60691: PPUSH
60692: CALL_OW 313
60696: PUSH
60697: LD_VAR 0 12
60701: PUSH
60702: LD_INT 1
60704: ARRAY
60705: PPUSH
60706: CALL_OW 266
60710: PUSH
60711: LD_INT 32
60713: PUSH
60714: LD_INT 31
60716: PUSH
60717: EMPTY
60718: LIST
60719: LIST
60720: IN
60721: AND
60722: PUSH
60723: LD_VAR 0 12
60727: PUSH
60728: LD_INT 1
60730: ARRAY
60731: PPUSH
60732: CALL_OW 313
60736: PUSH
60737: LD_INT 6
60739: EQUAL
60740: OR
60741: IFFALSE 60761
// f := Delete ( f , 1 ) ;
60743: LD_ADDR_VAR 0 12
60747: PUSH
60748: LD_VAR 0 12
60752: PPUSH
60753: LD_INT 1
60755: PPUSH
60756: CALL_OW 3
60760: ST_TO_ADDR
// if not f then
60761: LD_VAR 0 12
60765: NOT
60766: IFFALSE 60784
// begin x := x + 2 ;
60768: LD_ADDR_VAR 0 13
60772: PUSH
60773: LD_VAR 0 13
60777: PUSH
60778: LD_INT 2
60780: PLUS
60781: ST_TO_ADDR
// continue ;
60782: GO 60582
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60784: LD_VAR 0 12
60788: PUSH
60789: LD_INT 1
60791: ARRAY
60792: PPUSH
60793: CALL_OW 266
60797: PUSH
60798: LD_INT 5
60800: EQUAL
60801: IFFALSE 60875
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60803: LD_VAR 0 12
60807: PUSH
60808: LD_INT 1
60810: ARRAY
60811: PPUSH
60812: CALL_OW 313
60816: PUSH
60817: LD_INT 3
60819: LESS
60820: IFFALSE 60856
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60822: LD_INT 0
60824: PPUSH
60825: LD_INT 5
60827: PUSH
60828: LD_INT 8
60830: PUSH
60831: LD_INT 9
60833: PUSH
60834: EMPTY
60835: LIST
60836: LIST
60837: LIST
60838: PUSH
60839: LD_VAR 0 17
60843: ARRAY
60844: PPUSH
60845: LD_VAR 0 4
60849: PPUSH
60850: CALL_OW 380
60854: GO 60873
// PrepareHuman ( false , i , skill ) ;
60856: LD_INT 0
60858: PPUSH
60859: LD_VAR 0 8
60863: PPUSH
60864: LD_VAR 0 4
60868: PPUSH
60869: CALL_OW 380
// end else
60873: GO 60892
// PrepareHuman ( false , i , skill ) ;
60875: LD_INT 0
60877: PPUSH
60878: LD_VAR 0 8
60882: PPUSH
60883: LD_VAR 0 4
60887: PPUSH
60888: CALL_OW 380
// un := CreateHuman ;
60892: LD_ADDR_VAR 0 14
60896: PUSH
60897: CALL_OW 44
60901: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60902: LD_ADDR_VAR 0 7
60906: PUSH
60907: LD_VAR 0 7
60911: PPUSH
60912: LD_INT 1
60914: PPUSH
60915: LD_VAR 0 14
60919: PPUSH
60920: CALL_OW 2
60924: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
60925: LD_VAR 0 14
60929: PPUSH
60930: LD_VAR 0 12
60934: PUSH
60935: LD_INT 1
60937: ARRAY
60938: PPUSH
60939: CALL_OW 52
// end ;
60943: GO 60582
60945: POP
60946: POP
// end ;
60947: GO 59884
60949: POP
60950: POP
// result := result ^ buildings ;
60951: LD_ADDR_VAR 0 7
60955: PUSH
60956: LD_VAR 0 7
60960: PUSH
60961: LD_VAR 0 18
60965: ADD
60966: ST_TO_ADDR
// end else
60967: GO 61110
// begin for i = 1 to personel do
60969: LD_ADDR_VAR 0 8
60973: PUSH
60974: DOUBLE
60975: LD_INT 1
60977: DEC
60978: ST_TO_ADDR
60979: LD_VAR 0 6
60983: PUSH
60984: FOR_TO
60985: IFFALSE 61108
// begin if i > 4 then
60987: LD_VAR 0 8
60991: PUSH
60992: LD_INT 4
60994: GREATER
60995: IFFALSE 60999
// break ;
60997: GO 61108
// x := personel [ i ] ;
60999: LD_ADDR_VAR 0 13
61003: PUSH
61004: LD_VAR 0 6
61008: PUSH
61009: LD_VAR 0 8
61013: ARRAY
61014: ST_TO_ADDR
// if x = - 1 then
61015: LD_VAR 0 13
61019: PUSH
61020: LD_INT 1
61022: NEG
61023: EQUAL
61024: IFFALSE 61028
// continue ;
61026: GO 60984
// PrepareHuman ( false , i , skill ) ;
61028: LD_INT 0
61030: PPUSH
61031: LD_VAR 0 8
61035: PPUSH
61036: LD_VAR 0 4
61040: PPUSH
61041: CALL_OW 380
// un := CreateHuman ;
61045: LD_ADDR_VAR 0 14
61049: PUSH
61050: CALL_OW 44
61054: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61055: LD_VAR 0 14
61059: PPUSH
61060: LD_VAR 0 1
61064: PPUSH
61065: CALL_OW 250
61069: PPUSH
61070: LD_VAR 0 1
61074: PPUSH
61075: CALL_OW 251
61079: PPUSH
61080: LD_INT 10
61082: PPUSH
61083: LD_INT 0
61085: PPUSH
61086: CALL_OW 50
// result := result ^ un ;
61090: LD_ADDR_VAR 0 7
61094: PUSH
61095: LD_VAR 0 7
61099: PUSH
61100: LD_VAR 0 14
61104: ADD
61105: ST_TO_ADDR
// end ;
61106: GO 60984
61108: POP
61109: POP
// end ; end ;
61110: LD_VAR 0 7
61114: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61115: LD_INT 0
61117: PPUSH
61118: PPUSH
61119: PPUSH
61120: PPUSH
61121: PPUSH
61122: PPUSH
61123: PPUSH
61124: PPUSH
61125: PPUSH
61126: PPUSH
61127: PPUSH
61128: PPUSH
61129: PPUSH
61130: PPUSH
61131: PPUSH
61132: PPUSH
// result := false ;
61133: LD_ADDR_VAR 0 3
61137: PUSH
61138: LD_INT 0
61140: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61141: LD_VAR 0 1
61145: NOT
61146: PUSH
61147: LD_VAR 0 1
61151: PPUSH
61152: CALL_OW 266
61156: PUSH
61157: LD_INT 32
61159: PUSH
61160: LD_INT 33
61162: PUSH
61163: EMPTY
61164: LIST
61165: LIST
61166: IN
61167: NOT
61168: OR
61169: IFFALSE 61173
// exit ;
61171: GO 62282
// nat := GetNation ( tower ) ;
61173: LD_ADDR_VAR 0 12
61177: PUSH
61178: LD_VAR 0 1
61182: PPUSH
61183: CALL_OW 248
61187: ST_TO_ADDR
// side := GetSide ( tower ) ;
61188: LD_ADDR_VAR 0 16
61192: PUSH
61193: LD_VAR 0 1
61197: PPUSH
61198: CALL_OW 255
61202: ST_TO_ADDR
// x := GetX ( tower ) ;
61203: LD_ADDR_VAR 0 10
61207: PUSH
61208: LD_VAR 0 1
61212: PPUSH
61213: CALL_OW 250
61217: ST_TO_ADDR
// y := GetY ( tower ) ;
61218: LD_ADDR_VAR 0 11
61222: PUSH
61223: LD_VAR 0 1
61227: PPUSH
61228: CALL_OW 251
61232: ST_TO_ADDR
// if not x or not y then
61233: LD_VAR 0 10
61237: NOT
61238: PUSH
61239: LD_VAR 0 11
61243: NOT
61244: OR
61245: IFFALSE 61249
// exit ;
61247: GO 62282
// weapon := 0 ;
61249: LD_ADDR_VAR 0 18
61253: PUSH
61254: LD_INT 0
61256: ST_TO_ADDR
// fac_list := [ ] ;
61257: LD_ADDR_VAR 0 17
61261: PUSH
61262: EMPTY
61263: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
61264: LD_ADDR_VAR 0 6
61268: PUSH
61269: LD_VAR 0 1
61273: PPUSH
61274: CALL_OW 274
61278: PPUSH
61279: LD_VAR 0 2
61283: PPUSH
61284: LD_INT 0
61286: PPUSH
61287: CALL 58852 0 3
61291: PPUSH
61292: LD_INT 30
61294: PUSH
61295: LD_INT 3
61297: PUSH
61298: EMPTY
61299: LIST
61300: LIST
61301: PPUSH
61302: CALL_OW 72
61306: ST_TO_ADDR
// if not factories then
61307: LD_VAR 0 6
61311: NOT
61312: IFFALSE 61316
// exit ;
61314: GO 62282
// for i in factories do
61316: LD_ADDR_VAR 0 8
61320: PUSH
61321: LD_VAR 0 6
61325: PUSH
61326: FOR_IN
61327: IFFALSE 61352
// fac_list := fac_list union AvailableWeaponList ( i ) ;
61329: LD_ADDR_VAR 0 17
61333: PUSH
61334: LD_VAR 0 17
61338: PUSH
61339: LD_VAR 0 8
61343: PPUSH
61344: CALL_OW 478
61348: UNION
61349: ST_TO_ADDR
61350: GO 61326
61352: POP
61353: POP
// if not fac_list then
61354: LD_VAR 0 17
61358: NOT
61359: IFFALSE 61363
// exit ;
61361: GO 62282
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61363: LD_ADDR_VAR 0 5
61367: PUSH
61368: LD_INT 4
61370: PUSH
61371: LD_INT 5
61373: PUSH
61374: LD_INT 9
61376: PUSH
61377: LD_INT 10
61379: PUSH
61380: LD_INT 6
61382: PUSH
61383: LD_INT 7
61385: PUSH
61386: LD_INT 11
61388: PUSH
61389: EMPTY
61390: LIST
61391: LIST
61392: LIST
61393: LIST
61394: LIST
61395: LIST
61396: LIST
61397: PUSH
61398: LD_INT 27
61400: PUSH
61401: LD_INT 28
61403: PUSH
61404: LD_INT 26
61406: PUSH
61407: LD_INT 30
61409: PUSH
61410: EMPTY
61411: LIST
61412: LIST
61413: LIST
61414: LIST
61415: PUSH
61416: LD_INT 43
61418: PUSH
61419: LD_INT 44
61421: PUSH
61422: LD_INT 46
61424: PUSH
61425: LD_INT 45
61427: PUSH
61428: LD_INT 47
61430: PUSH
61431: LD_INT 49
61433: PUSH
61434: EMPTY
61435: LIST
61436: LIST
61437: LIST
61438: LIST
61439: LIST
61440: LIST
61441: PUSH
61442: EMPTY
61443: LIST
61444: LIST
61445: LIST
61446: PUSH
61447: LD_VAR 0 12
61451: ARRAY
61452: ST_TO_ADDR
// list := list isect fac_list ;
61453: LD_ADDR_VAR 0 5
61457: PUSH
61458: LD_VAR 0 5
61462: PUSH
61463: LD_VAR 0 17
61467: ISECT
61468: ST_TO_ADDR
// if not list then
61469: LD_VAR 0 5
61473: NOT
61474: IFFALSE 61478
// exit ;
61476: GO 62282
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61478: LD_VAR 0 12
61482: PUSH
61483: LD_INT 3
61485: EQUAL
61486: PUSH
61487: LD_INT 49
61489: PUSH
61490: LD_VAR 0 5
61494: IN
61495: AND
61496: PUSH
61497: LD_INT 31
61499: PPUSH
61500: LD_VAR 0 16
61504: PPUSH
61505: CALL_OW 321
61509: PUSH
61510: LD_INT 2
61512: EQUAL
61513: AND
61514: IFFALSE 61574
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61516: LD_INT 22
61518: PUSH
61519: LD_VAR 0 16
61523: PUSH
61524: EMPTY
61525: LIST
61526: LIST
61527: PUSH
61528: LD_INT 35
61530: PUSH
61531: LD_INT 49
61533: PUSH
61534: EMPTY
61535: LIST
61536: LIST
61537: PUSH
61538: LD_INT 91
61540: PUSH
61541: LD_VAR 0 1
61545: PUSH
61546: LD_INT 10
61548: PUSH
61549: EMPTY
61550: LIST
61551: LIST
61552: LIST
61553: PUSH
61554: EMPTY
61555: LIST
61556: LIST
61557: LIST
61558: PPUSH
61559: CALL_OW 69
61563: NOT
61564: IFFALSE 61574
// weapon := ru_time_lapser ;
61566: LD_ADDR_VAR 0 18
61570: PUSH
61571: LD_INT 49
61573: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61574: LD_VAR 0 12
61578: PUSH
61579: LD_INT 1
61581: PUSH
61582: LD_INT 2
61584: PUSH
61585: EMPTY
61586: LIST
61587: LIST
61588: IN
61589: PUSH
61590: LD_INT 11
61592: PUSH
61593: LD_VAR 0 5
61597: IN
61598: PUSH
61599: LD_INT 30
61601: PUSH
61602: LD_VAR 0 5
61606: IN
61607: OR
61608: AND
61609: PUSH
61610: LD_INT 6
61612: PPUSH
61613: LD_VAR 0 16
61617: PPUSH
61618: CALL_OW 321
61622: PUSH
61623: LD_INT 2
61625: EQUAL
61626: AND
61627: IFFALSE 61792
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61629: LD_INT 22
61631: PUSH
61632: LD_VAR 0 16
61636: PUSH
61637: EMPTY
61638: LIST
61639: LIST
61640: PUSH
61641: LD_INT 2
61643: PUSH
61644: LD_INT 35
61646: PUSH
61647: LD_INT 11
61649: PUSH
61650: EMPTY
61651: LIST
61652: LIST
61653: PUSH
61654: LD_INT 35
61656: PUSH
61657: LD_INT 30
61659: PUSH
61660: EMPTY
61661: LIST
61662: LIST
61663: PUSH
61664: EMPTY
61665: LIST
61666: LIST
61667: LIST
61668: PUSH
61669: LD_INT 91
61671: PUSH
61672: LD_VAR 0 1
61676: PUSH
61677: LD_INT 18
61679: PUSH
61680: EMPTY
61681: LIST
61682: LIST
61683: LIST
61684: PUSH
61685: EMPTY
61686: LIST
61687: LIST
61688: LIST
61689: PPUSH
61690: CALL_OW 69
61694: NOT
61695: PUSH
61696: LD_INT 22
61698: PUSH
61699: LD_VAR 0 16
61703: PUSH
61704: EMPTY
61705: LIST
61706: LIST
61707: PUSH
61708: LD_INT 2
61710: PUSH
61711: LD_INT 30
61713: PUSH
61714: LD_INT 32
61716: PUSH
61717: EMPTY
61718: LIST
61719: LIST
61720: PUSH
61721: LD_INT 30
61723: PUSH
61724: LD_INT 33
61726: PUSH
61727: EMPTY
61728: LIST
61729: LIST
61730: PUSH
61731: EMPTY
61732: LIST
61733: LIST
61734: LIST
61735: PUSH
61736: LD_INT 91
61738: PUSH
61739: LD_VAR 0 1
61743: PUSH
61744: LD_INT 12
61746: PUSH
61747: EMPTY
61748: LIST
61749: LIST
61750: LIST
61751: PUSH
61752: EMPTY
61753: LIST
61754: LIST
61755: LIST
61756: PUSH
61757: EMPTY
61758: LIST
61759: PPUSH
61760: CALL_OW 69
61764: PUSH
61765: LD_INT 2
61767: GREATER
61768: AND
61769: IFFALSE 61792
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61771: LD_ADDR_VAR 0 18
61775: PUSH
61776: LD_INT 11
61778: PUSH
61779: LD_INT 30
61781: PUSH
61782: EMPTY
61783: LIST
61784: LIST
61785: PUSH
61786: LD_VAR 0 12
61790: ARRAY
61791: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61792: LD_VAR 0 18
61796: NOT
61797: PUSH
61798: LD_INT 40
61800: PPUSH
61801: LD_VAR 0 16
61805: PPUSH
61806: CALL_OW 321
61810: PUSH
61811: LD_INT 2
61813: EQUAL
61814: AND
61815: PUSH
61816: LD_INT 7
61818: PUSH
61819: LD_VAR 0 5
61823: IN
61824: PUSH
61825: LD_INT 28
61827: PUSH
61828: LD_VAR 0 5
61832: IN
61833: OR
61834: PUSH
61835: LD_INT 45
61837: PUSH
61838: LD_VAR 0 5
61842: IN
61843: OR
61844: AND
61845: IFFALSE 62099
// begin hex := GetHexInfo ( x , y ) ;
61847: LD_ADDR_VAR 0 4
61851: PUSH
61852: LD_VAR 0 10
61856: PPUSH
61857: LD_VAR 0 11
61861: PPUSH
61862: CALL_OW 546
61866: ST_TO_ADDR
// if hex [ 1 ] then
61867: LD_VAR 0 4
61871: PUSH
61872: LD_INT 1
61874: ARRAY
61875: IFFALSE 61879
// exit ;
61877: GO 62282
// height := hex [ 2 ] ;
61879: LD_ADDR_VAR 0 15
61883: PUSH
61884: LD_VAR 0 4
61888: PUSH
61889: LD_INT 2
61891: ARRAY
61892: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61893: LD_ADDR_VAR 0 14
61897: PUSH
61898: LD_INT 0
61900: PUSH
61901: LD_INT 2
61903: PUSH
61904: LD_INT 3
61906: PUSH
61907: LD_INT 5
61909: PUSH
61910: EMPTY
61911: LIST
61912: LIST
61913: LIST
61914: LIST
61915: ST_TO_ADDR
// for i in tmp do
61916: LD_ADDR_VAR 0 8
61920: PUSH
61921: LD_VAR 0 14
61925: PUSH
61926: FOR_IN
61927: IFFALSE 62097
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
61929: LD_ADDR_VAR 0 9
61933: PUSH
61934: LD_VAR 0 10
61938: PPUSH
61939: LD_VAR 0 8
61943: PPUSH
61944: LD_INT 5
61946: PPUSH
61947: CALL_OW 272
61951: PUSH
61952: LD_VAR 0 11
61956: PPUSH
61957: LD_VAR 0 8
61961: PPUSH
61962: LD_INT 5
61964: PPUSH
61965: CALL_OW 273
61969: PUSH
61970: EMPTY
61971: LIST
61972: LIST
61973: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
61974: LD_VAR 0 9
61978: PUSH
61979: LD_INT 1
61981: ARRAY
61982: PPUSH
61983: LD_VAR 0 9
61987: PUSH
61988: LD_INT 2
61990: ARRAY
61991: PPUSH
61992: CALL_OW 488
61996: IFFALSE 62095
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
61998: LD_ADDR_VAR 0 4
62002: PUSH
62003: LD_VAR 0 9
62007: PUSH
62008: LD_INT 1
62010: ARRAY
62011: PPUSH
62012: LD_VAR 0 9
62016: PUSH
62017: LD_INT 2
62019: ARRAY
62020: PPUSH
62021: CALL_OW 546
62025: ST_TO_ADDR
// if hex [ 1 ] then
62026: LD_VAR 0 4
62030: PUSH
62031: LD_INT 1
62033: ARRAY
62034: IFFALSE 62038
// continue ;
62036: GO 61926
// h := hex [ 2 ] ;
62038: LD_ADDR_VAR 0 13
62042: PUSH
62043: LD_VAR 0 4
62047: PUSH
62048: LD_INT 2
62050: ARRAY
62051: ST_TO_ADDR
// if h + 7 < height then
62052: LD_VAR 0 13
62056: PUSH
62057: LD_INT 7
62059: PLUS
62060: PUSH
62061: LD_VAR 0 15
62065: LESS
62066: IFFALSE 62095
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62068: LD_ADDR_VAR 0 18
62072: PUSH
62073: LD_INT 7
62075: PUSH
62076: LD_INT 28
62078: PUSH
62079: LD_INT 45
62081: PUSH
62082: EMPTY
62083: LIST
62084: LIST
62085: LIST
62086: PUSH
62087: LD_VAR 0 12
62091: ARRAY
62092: ST_TO_ADDR
// break ;
62093: GO 62097
// end ; end ; end ;
62095: GO 61926
62097: POP
62098: POP
// end ; if not weapon then
62099: LD_VAR 0 18
62103: NOT
62104: IFFALSE 62164
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62106: LD_ADDR_VAR 0 5
62110: PUSH
62111: LD_VAR 0 5
62115: PUSH
62116: LD_INT 11
62118: PUSH
62119: LD_INT 30
62121: PUSH
62122: LD_INT 49
62124: PUSH
62125: EMPTY
62126: LIST
62127: LIST
62128: LIST
62129: DIFF
62130: ST_TO_ADDR
// if not list then
62131: LD_VAR 0 5
62135: NOT
62136: IFFALSE 62140
// exit ;
62138: GO 62282
// weapon := list [ rand ( 1 , list ) ] ;
62140: LD_ADDR_VAR 0 18
62144: PUSH
62145: LD_VAR 0 5
62149: PUSH
62150: LD_INT 1
62152: PPUSH
62153: LD_VAR 0 5
62157: PPUSH
62158: CALL_OW 12
62162: ARRAY
62163: ST_TO_ADDR
// end ; if weapon then
62164: LD_VAR 0 18
62168: IFFALSE 62282
// begin tmp := CostOfWeapon ( weapon ) ;
62170: LD_ADDR_VAR 0 14
62174: PUSH
62175: LD_VAR 0 18
62179: PPUSH
62180: CALL_OW 451
62184: ST_TO_ADDR
// j := GetBase ( tower ) ;
62185: LD_ADDR_VAR 0 9
62189: PUSH
62190: LD_VAR 0 1
62194: PPUSH
62195: CALL_OW 274
62199: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
62200: LD_VAR 0 9
62204: PPUSH
62205: LD_INT 1
62207: PPUSH
62208: CALL_OW 275
62212: PUSH
62213: LD_VAR 0 14
62217: PUSH
62218: LD_INT 1
62220: ARRAY
62221: GREATEREQUAL
62222: PUSH
62223: LD_VAR 0 9
62227: PPUSH
62228: LD_INT 2
62230: PPUSH
62231: CALL_OW 275
62235: PUSH
62236: LD_VAR 0 14
62240: PUSH
62241: LD_INT 2
62243: ARRAY
62244: GREATEREQUAL
62245: AND
62246: PUSH
62247: LD_VAR 0 9
62251: PPUSH
62252: LD_INT 3
62254: PPUSH
62255: CALL_OW 275
62259: PUSH
62260: LD_VAR 0 14
62264: PUSH
62265: LD_INT 3
62267: ARRAY
62268: GREATEREQUAL
62269: AND
62270: IFFALSE 62282
// result := weapon ;
62272: LD_ADDR_VAR 0 3
62276: PUSH
62277: LD_VAR 0 18
62281: ST_TO_ADDR
// end ; end ;
62282: LD_VAR 0 3
62286: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
62287: LD_INT 0
62289: PPUSH
62290: PPUSH
// result := true ;
62291: LD_ADDR_VAR 0 3
62295: PUSH
62296: LD_INT 1
62298: ST_TO_ADDR
// if array1 = array2 then
62299: LD_VAR 0 1
62303: PUSH
62304: LD_VAR 0 2
62308: EQUAL
62309: IFFALSE 62369
// begin for i = 1 to array1 do
62311: LD_ADDR_VAR 0 4
62315: PUSH
62316: DOUBLE
62317: LD_INT 1
62319: DEC
62320: ST_TO_ADDR
62321: LD_VAR 0 1
62325: PUSH
62326: FOR_TO
62327: IFFALSE 62365
// if array1 [ i ] <> array2 [ i ] then
62329: LD_VAR 0 1
62333: PUSH
62334: LD_VAR 0 4
62338: ARRAY
62339: PUSH
62340: LD_VAR 0 2
62344: PUSH
62345: LD_VAR 0 4
62349: ARRAY
62350: NONEQUAL
62351: IFFALSE 62363
// begin result := false ;
62353: LD_ADDR_VAR 0 3
62357: PUSH
62358: LD_INT 0
62360: ST_TO_ADDR
// break ;
62361: GO 62365
// end ;
62363: GO 62326
62365: POP
62366: POP
// end else
62367: GO 62377
// result := false ;
62369: LD_ADDR_VAR 0 3
62373: PUSH
62374: LD_INT 0
62376: ST_TO_ADDR
// end ;
62377: LD_VAR 0 3
62381: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
62382: LD_INT 0
62384: PPUSH
62385: PPUSH
// if not array1 or not array2 then
62386: LD_VAR 0 1
62390: NOT
62391: PUSH
62392: LD_VAR 0 2
62396: NOT
62397: OR
62398: IFFALSE 62402
// exit ;
62400: GO 62466
// result := true ;
62402: LD_ADDR_VAR 0 3
62406: PUSH
62407: LD_INT 1
62409: ST_TO_ADDR
// for i = 1 to array1 do
62410: LD_ADDR_VAR 0 4
62414: PUSH
62415: DOUBLE
62416: LD_INT 1
62418: DEC
62419: ST_TO_ADDR
62420: LD_VAR 0 1
62424: PUSH
62425: FOR_TO
62426: IFFALSE 62464
// if array1 [ i ] <> array2 [ i ] then
62428: LD_VAR 0 1
62432: PUSH
62433: LD_VAR 0 4
62437: ARRAY
62438: PUSH
62439: LD_VAR 0 2
62443: PUSH
62444: LD_VAR 0 4
62448: ARRAY
62449: NONEQUAL
62450: IFFALSE 62462
// begin result := false ;
62452: LD_ADDR_VAR 0 3
62456: PUSH
62457: LD_INT 0
62459: ST_TO_ADDR
// break ;
62460: GO 62464
// end ;
62462: GO 62425
62464: POP
62465: POP
// end ;
62466: LD_VAR 0 3
62470: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62471: LD_INT 0
62473: PPUSH
62474: PPUSH
62475: PPUSH
// pom := GetBase ( fac ) ;
62476: LD_ADDR_VAR 0 5
62480: PUSH
62481: LD_VAR 0 1
62485: PPUSH
62486: CALL_OW 274
62490: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62491: LD_ADDR_VAR 0 4
62495: PUSH
62496: LD_VAR 0 2
62500: PUSH
62501: LD_INT 1
62503: ARRAY
62504: PPUSH
62505: LD_VAR 0 2
62509: PUSH
62510: LD_INT 2
62512: ARRAY
62513: PPUSH
62514: LD_VAR 0 2
62518: PUSH
62519: LD_INT 3
62521: ARRAY
62522: PPUSH
62523: LD_VAR 0 2
62527: PUSH
62528: LD_INT 4
62530: ARRAY
62531: PPUSH
62532: CALL_OW 449
62536: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62537: LD_ADDR_VAR 0 3
62541: PUSH
62542: LD_VAR 0 5
62546: PPUSH
62547: LD_INT 1
62549: PPUSH
62550: CALL_OW 275
62554: PUSH
62555: LD_VAR 0 4
62559: PUSH
62560: LD_INT 1
62562: ARRAY
62563: GREATEREQUAL
62564: PUSH
62565: LD_VAR 0 5
62569: PPUSH
62570: LD_INT 2
62572: PPUSH
62573: CALL_OW 275
62577: PUSH
62578: LD_VAR 0 4
62582: PUSH
62583: LD_INT 2
62585: ARRAY
62586: GREATEREQUAL
62587: AND
62588: PUSH
62589: LD_VAR 0 5
62593: PPUSH
62594: LD_INT 3
62596: PPUSH
62597: CALL_OW 275
62601: PUSH
62602: LD_VAR 0 4
62606: PUSH
62607: LD_INT 3
62609: ARRAY
62610: GREATEREQUAL
62611: AND
62612: ST_TO_ADDR
// end ;
62613: LD_VAR 0 3
62617: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62618: LD_INT 0
62620: PPUSH
62621: PPUSH
62622: PPUSH
62623: PPUSH
// pom := GetBase ( building ) ;
62624: LD_ADDR_VAR 0 3
62628: PUSH
62629: LD_VAR 0 1
62633: PPUSH
62634: CALL_OW 274
62638: ST_TO_ADDR
// if not pom then
62639: LD_VAR 0 3
62643: NOT
62644: IFFALSE 62648
// exit ;
62646: GO 62818
// btype := GetBType ( building ) ;
62648: LD_ADDR_VAR 0 5
62652: PUSH
62653: LD_VAR 0 1
62657: PPUSH
62658: CALL_OW 266
62662: ST_TO_ADDR
// if btype = b_armoury then
62663: LD_VAR 0 5
62667: PUSH
62668: LD_INT 4
62670: EQUAL
62671: IFFALSE 62681
// btype := b_barracks ;
62673: LD_ADDR_VAR 0 5
62677: PUSH
62678: LD_INT 5
62680: ST_TO_ADDR
// if btype = b_depot then
62681: LD_VAR 0 5
62685: PUSH
62686: LD_INT 0
62688: EQUAL
62689: IFFALSE 62699
// btype := b_warehouse ;
62691: LD_ADDR_VAR 0 5
62695: PUSH
62696: LD_INT 1
62698: ST_TO_ADDR
// if btype = b_workshop then
62699: LD_VAR 0 5
62703: PUSH
62704: LD_INT 2
62706: EQUAL
62707: IFFALSE 62717
// btype := b_factory ;
62709: LD_ADDR_VAR 0 5
62713: PUSH
62714: LD_INT 3
62716: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62717: LD_ADDR_VAR 0 4
62721: PUSH
62722: LD_VAR 0 5
62726: PPUSH
62727: LD_VAR 0 1
62731: PPUSH
62732: CALL_OW 248
62736: PPUSH
62737: CALL_OW 450
62741: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62742: LD_ADDR_VAR 0 2
62746: PUSH
62747: LD_VAR 0 3
62751: PPUSH
62752: LD_INT 1
62754: PPUSH
62755: CALL_OW 275
62759: PUSH
62760: LD_VAR 0 4
62764: PUSH
62765: LD_INT 1
62767: ARRAY
62768: GREATEREQUAL
62769: PUSH
62770: LD_VAR 0 3
62774: PPUSH
62775: LD_INT 2
62777: PPUSH
62778: CALL_OW 275
62782: PUSH
62783: LD_VAR 0 4
62787: PUSH
62788: LD_INT 2
62790: ARRAY
62791: GREATEREQUAL
62792: AND
62793: PUSH
62794: LD_VAR 0 3
62798: PPUSH
62799: LD_INT 3
62801: PPUSH
62802: CALL_OW 275
62806: PUSH
62807: LD_VAR 0 4
62811: PUSH
62812: LD_INT 3
62814: ARRAY
62815: GREATEREQUAL
62816: AND
62817: ST_TO_ADDR
// end ;
62818: LD_VAR 0 2
62822: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62823: LD_INT 0
62825: PPUSH
62826: PPUSH
62827: PPUSH
// pom := GetBase ( building ) ;
62828: LD_ADDR_VAR 0 4
62832: PUSH
62833: LD_VAR 0 1
62837: PPUSH
62838: CALL_OW 274
62842: ST_TO_ADDR
// if not pom then
62843: LD_VAR 0 4
62847: NOT
62848: IFFALSE 62852
// exit ;
62850: GO 62953
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62852: LD_ADDR_VAR 0 5
62856: PUSH
62857: LD_VAR 0 2
62861: PPUSH
62862: LD_VAR 0 1
62866: PPUSH
62867: CALL_OW 248
62871: PPUSH
62872: CALL_OW 450
62876: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62877: LD_ADDR_VAR 0 3
62881: PUSH
62882: LD_VAR 0 4
62886: PPUSH
62887: LD_INT 1
62889: PPUSH
62890: CALL_OW 275
62894: PUSH
62895: LD_VAR 0 5
62899: PUSH
62900: LD_INT 1
62902: ARRAY
62903: GREATEREQUAL
62904: PUSH
62905: LD_VAR 0 4
62909: PPUSH
62910: LD_INT 2
62912: PPUSH
62913: CALL_OW 275
62917: PUSH
62918: LD_VAR 0 5
62922: PUSH
62923: LD_INT 2
62925: ARRAY
62926: GREATEREQUAL
62927: AND
62928: PUSH
62929: LD_VAR 0 4
62933: PPUSH
62934: LD_INT 3
62936: PPUSH
62937: CALL_OW 275
62941: PUSH
62942: LD_VAR 0 5
62946: PUSH
62947: LD_INT 3
62949: ARRAY
62950: GREATEREQUAL
62951: AND
62952: ST_TO_ADDR
// end ;
62953: LD_VAR 0 3
62957: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
62958: LD_INT 0
62960: PPUSH
62961: PPUSH
62962: PPUSH
62963: PPUSH
62964: PPUSH
62965: PPUSH
62966: PPUSH
62967: PPUSH
62968: PPUSH
62969: PPUSH
62970: PPUSH
// result := false ;
62971: LD_ADDR_VAR 0 8
62975: PUSH
62976: LD_INT 0
62978: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
62979: LD_VAR 0 5
62983: NOT
62984: PUSH
62985: LD_VAR 0 1
62989: NOT
62990: OR
62991: PUSH
62992: LD_VAR 0 2
62996: NOT
62997: OR
62998: PUSH
62999: LD_VAR 0 3
63003: NOT
63004: OR
63005: IFFALSE 63009
// exit ;
63007: GO 63823
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63009: LD_ADDR_VAR 0 14
63013: PUSH
63014: LD_VAR 0 1
63018: PPUSH
63019: LD_VAR 0 2
63023: PPUSH
63024: LD_VAR 0 3
63028: PPUSH
63029: LD_VAR 0 4
63033: PPUSH
63034: LD_VAR 0 5
63038: PUSH
63039: LD_INT 1
63041: ARRAY
63042: PPUSH
63043: CALL_OW 248
63047: PPUSH
63048: LD_INT 0
63050: PPUSH
63051: CALL 65060 0 6
63055: ST_TO_ADDR
// if not hexes then
63056: LD_VAR 0 14
63060: NOT
63061: IFFALSE 63065
// exit ;
63063: GO 63823
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63065: LD_ADDR_VAR 0 17
63069: PUSH
63070: LD_VAR 0 5
63074: PPUSH
63075: LD_INT 22
63077: PUSH
63078: LD_VAR 0 13
63082: PPUSH
63083: CALL_OW 255
63087: PUSH
63088: EMPTY
63089: LIST
63090: LIST
63091: PUSH
63092: LD_INT 2
63094: PUSH
63095: LD_INT 30
63097: PUSH
63098: LD_INT 0
63100: PUSH
63101: EMPTY
63102: LIST
63103: LIST
63104: PUSH
63105: LD_INT 30
63107: PUSH
63108: LD_INT 1
63110: PUSH
63111: EMPTY
63112: LIST
63113: LIST
63114: PUSH
63115: EMPTY
63116: LIST
63117: LIST
63118: LIST
63119: PUSH
63120: EMPTY
63121: LIST
63122: LIST
63123: PPUSH
63124: CALL_OW 72
63128: ST_TO_ADDR
// for i = 1 to hexes do
63129: LD_ADDR_VAR 0 9
63133: PUSH
63134: DOUBLE
63135: LD_INT 1
63137: DEC
63138: ST_TO_ADDR
63139: LD_VAR 0 14
63143: PUSH
63144: FOR_TO
63145: IFFALSE 63821
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63147: LD_ADDR_VAR 0 13
63151: PUSH
63152: LD_VAR 0 14
63156: PUSH
63157: LD_VAR 0 9
63161: ARRAY
63162: PUSH
63163: LD_INT 1
63165: ARRAY
63166: PPUSH
63167: LD_VAR 0 14
63171: PUSH
63172: LD_VAR 0 9
63176: ARRAY
63177: PUSH
63178: LD_INT 2
63180: ARRAY
63181: PPUSH
63182: CALL_OW 428
63186: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63187: LD_VAR 0 14
63191: PUSH
63192: LD_VAR 0 9
63196: ARRAY
63197: PUSH
63198: LD_INT 1
63200: ARRAY
63201: PPUSH
63202: LD_VAR 0 14
63206: PUSH
63207: LD_VAR 0 9
63211: ARRAY
63212: PUSH
63213: LD_INT 2
63215: ARRAY
63216: PPUSH
63217: CALL_OW 351
63221: PUSH
63222: LD_VAR 0 14
63226: PUSH
63227: LD_VAR 0 9
63231: ARRAY
63232: PUSH
63233: LD_INT 1
63235: ARRAY
63236: PPUSH
63237: LD_VAR 0 14
63241: PUSH
63242: LD_VAR 0 9
63246: ARRAY
63247: PUSH
63248: LD_INT 2
63250: ARRAY
63251: PPUSH
63252: CALL_OW 488
63256: NOT
63257: OR
63258: PUSH
63259: LD_VAR 0 13
63263: PPUSH
63264: CALL_OW 247
63268: PUSH
63269: LD_INT 3
63271: EQUAL
63272: OR
63273: IFFALSE 63279
// exit ;
63275: POP
63276: POP
63277: GO 63823
// if not tmp then
63279: LD_VAR 0 13
63283: NOT
63284: IFFALSE 63288
// continue ;
63286: GO 63144
// result := true ;
63288: LD_ADDR_VAR 0 8
63292: PUSH
63293: LD_INT 1
63295: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
63296: LD_VAR 0 6
63300: PUSH
63301: LD_VAR 0 13
63305: PPUSH
63306: CALL_OW 247
63310: PUSH
63311: LD_INT 2
63313: EQUAL
63314: AND
63315: PUSH
63316: LD_VAR 0 13
63320: PPUSH
63321: CALL_OW 263
63325: PUSH
63326: LD_INT 1
63328: EQUAL
63329: AND
63330: IFFALSE 63494
// begin if IsDrivenBy ( tmp ) then
63332: LD_VAR 0 13
63336: PPUSH
63337: CALL_OW 311
63341: IFFALSE 63345
// continue ;
63343: GO 63144
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
63345: LD_VAR 0 6
63349: PPUSH
63350: LD_INT 3
63352: PUSH
63353: LD_INT 60
63355: PUSH
63356: EMPTY
63357: LIST
63358: PUSH
63359: EMPTY
63360: LIST
63361: LIST
63362: PUSH
63363: LD_INT 3
63365: PUSH
63366: LD_INT 55
63368: PUSH
63369: EMPTY
63370: LIST
63371: PUSH
63372: EMPTY
63373: LIST
63374: LIST
63375: PUSH
63376: EMPTY
63377: LIST
63378: LIST
63379: PPUSH
63380: CALL_OW 72
63384: IFFALSE 63492
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
63386: LD_ADDR_VAR 0 18
63390: PUSH
63391: LD_VAR 0 6
63395: PPUSH
63396: LD_INT 3
63398: PUSH
63399: LD_INT 60
63401: PUSH
63402: EMPTY
63403: LIST
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: PUSH
63409: LD_INT 3
63411: PUSH
63412: LD_INT 55
63414: PUSH
63415: EMPTY
63416: LIST
63417: PUSH
63418: EMPTY
63419: LIST
63420: LIST
63421: PUSH
63422: EMPTY
63423: LIST
63424: LIST
63425: PPUSH
63426: CALL_OW 72
63430: PUSH
63431: LD_INT 1
63433: ARRAY
63434: ST_TO_ADDR
// if IsInUnit ( driver ) then
63435: LD_VAR 0 18
63439: PPUSH
63440: CALL_OW 310
63444: IFFALSE 63455
// ComExit ( driver ) ;
63446: LD_VAR 0 18
63450: PPUSH
63451: CALL 88244 0 1
// AddComEnterUnit ( driver , tmp ) ;
63455: LD_VAR 0 18
63459: PPUSH
63460: LD_VAR 0 13
63464: PPUSH
63465: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
63469: LD_VAR 0 18
63473: PPUSH
63474: LD_VAR 0 7
63478: PPUSH
63479: CALL_OW 173
// AddComExitVehicle ( driver ) ;
63483: LD_VAR 0 18
63487: PPUSH
63488: CALL_OW 181
// end ; continue ;
63492: GO 63144
// end ; if not cleaners or not tmp in cleaners then
63494: LD_VAR 0 6
63498: NOT
63499: PUSH
63500: LD_VAR 0 13
63504: PUSH
63505: LD_VAR 0 6
63509: IN
63510: NOT
63511: OR
63512: IFFALSE 63819
// begin if dep then
63514: LD_VAR 0 17
63518: IFFALSE 63654
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
63520: LD_ADDR_VAR 0 16
63524: PUSH
63525: LD_VAR 0 17
63529: PUSH
63530: LD_INT 1
63532: ARRAY
63533: PPUSH
63534: CALL_OW 250
63538: PPUSH
63539: LD_VAR 0 17
63543: PUSH
63544: LD_INT 1
63546: ARRAY
63547: PPUSH
63548: CALL_OW 254
63552: PPUSH
63553: LD_INT 5
63555: PPUSH
63556: CALL_OW 272
63560: PUSH
63561: LD_VAR 0 17
63565: PUSH
63566: LD_INT 1
63568: ARRAY
63569: PPUSH
63570: CALL_OW 251
63574: PPUSH
63575: LD_VAR 0 17
63579: PUSH
63580: LD_INT 1
63582: ARRAY
63583: PPUSH
63584: CALL_OW 254
63588: PPUSH
63589: LD_INT 5
63591: PPUSH
63592: CALL_OW 273
63596: PUSH
63597: EMPTY
63598: LIST
63599: LIST
63600: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63601: LD_VAR 0 16
63605: PUSH
63606: LD_INT 1
63608: ARRAY
63609: PPUSH
63610: LD_VAR 0 16
63614: PUSH
63615: LD_INT 2
63617: ARRAY
63618: PPUSH
63619: CALL_OW 488
63623: IFFALSE 63654
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63625: LD_VAR 0 13
63629: PPUSH
63630: LD_VAR 0 16
63634: PUSH
63635: LD_INT 1
63637: ARRAY
63638: PPUSH
63639: LD_VAR 0 16
63643: PUSH
63644: LD_INT 2
63646: ARRAY
63647: PPUSH
63648: CALL_OW 111
// continue ;
63652: GO 63144
// end ; end ; r := GetDir ( tmp ) ;
63654: LD_ADDR_VAR 0 15
63658: PUSH
63659: LD_VAR 0 13
63663: PPUSH
63664: CALL_OW 254
63668: ST_TO_ADDR
// if r = 5 then
63669: LD_VAR 0 15
63673: PUSH
63674: LD_INT 5
63676: EQUAL
63677: IFFALSE 63687
// r := 0 ;
63679: LD_ADDR_VAR 0 15
63683: PUSH
63684: LD_INT 0
63686: ST_TO_ADDR
// for j = r to 5 do
63687: LD_ADDR_VAR 0 10
63691: PUSH
63692: DOUBLE
63693: LD_VAR 0 15
63697: DEC
63698: ST_TO_ADDR
63699: LD_INT 5
63701: PUSH
63702: FOR_TO
63703: IFFALSE 63817
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
63705: LD_ADDR_VAR 0 11
63709: PUSH
63710: LD_VAR 0 13
63714: PPUSH
63715: CALL_OW 250
63719: PPUSH
63720: LD_VAR 0 10
63724: PPUSH
63725: LD_INT 2
63727: PPUSH
63728: CALL_OW 272
63732: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63733: LD_ADDR_VAR 0 12
63737: PUSH
63738: LD_VAR 0 13
63742: PPUSH
63743: CALL_OW 251
63747: PPUSH
63748: LD_VAR 0 10
63752: PPUSH
63753: LD_INT 2
63755: PPUSH
63756: CALL_OW 273
63760: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63761: LD_VAR 0 11
63765: PPUSH
63766: LD_VAR 0 12
63770: PPUSH
63771: CALL_OW 488
63775: PUSH
63776: LD_VAR 0 11
63780: PPUSH
63781: LD_VAR 0 12
63785: PPUSH
63786: CALL_OW 428
63790: NOT
63791: AND
63792: IFFALSE 63815
// begin ComMoveXY ( tmp , _x , _y ) ;
63794: LD_VAR 0 13
63798: PPUSH
63799: LD_VAR 0 11
63803: PPUSH
63804: LD_VAR 0 12
63808: PPUSH
63809: CALL_OW 111
// break ;
63813: GO 63817
// end ; end ;
63815: GO 63702
63817: POP
63818: POP
// end ; end ;
63819: GO 63144
63821: POP
63822: POP
// end ;
63823: LD_VAR 0 8
63827: RET
// export function BuildingTechInvented ( side , btype ) ; begin
63828: LD_INT 0
63830: PPUSH
// result := true ;
63831: LD_ADDR_VAR 0 3
63835: PUSH
63836: LD_INT 1
63838: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
63839: LD_VAR 0 2
63843: PUSH
63844: LD_INT 24
63846: DOUBLE
63847: EQUAL
63848: IFTRUE 63858
63850: LD_INT 33
63852: DOUBLE
63853: EQUAL
63854: IFTRUE 63858
63856: GO 63883
63858: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
63859: LD_ADDR_VAR 0 3
63863: PUSH
63864: LD_INT 32
63866: PPUSH
63867: LD_VAR 0 1
63871: PPUSH
63872: CALL_OW 321
63876: PUSH
63877: LD_INT 2
63879: EQUAL
63880: ST_TO_ADDR
63881: GO 64203
63883: LD_INT 20
63885: DOUBLE
63886: EQUAL
63887: IFTRUE 63891
63889: GO 63916
63891: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
63892: LD_ADDR_VAR 0 3
63896: PUSH
63897: LD_INT 6
63899: PPUSH
63900: LD_VAR 0 1
63904: PPUSH
63905: CALL_OW 321
63909: PUSH
63910: LD_INT 2
63912: EQUAL
63913: ST_TO_ADDR
63914: GO 64203
63916: LD_INT 22
63918: DOUBLE
63919: EQUAL
63920: IFTRUE 63930
63922: LD_INT 36
63924: DOUBLE
63925: EQUAL
63926: IFTRUE 63930
63928: GO 63955
63930: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
63931: LD_ADDR_VAR 0 3
63935: PUSH
63936: LD_INT 15
63938: PPUSH
63939: LD_VAR 0 1
63943: PPUSH
63944: CALL_OW 321
63948: PUSH
63949: LD_INT 2
63951: EQUAL
63952: ST_TO_ADDR
63953: GO 64203
63955: LD_INT 30
63957: DOUBLE
63958: EQUAL
63959: IFTRUE 63963
63961: GO 63988
63963: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
63964: LD_ADDR_VAR 0 3
63968: PUSH
63969: LD_INT 20
63971: PPUSH
63972: LD_VAR 0 1
63976: PPUSH
63977: CALL_OW 321
63981: PUSH
63982: LD_INT 2
63984: EQUAL
63985: ST_TO_ADDR
63986: GO 64203
63988: LD_INT 28
63990: DOUBLE
63991: EQUAL
63992: IFTRUE 64002
63994: LD_INT 21
63996: DOUBLE
63997: EQUAL
63998: IFTRUE 64002
64000: GO 64027
64002: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64003: LD_ADDR_VAR 0 3
64007: PUSH
64008: LD_INT 21
64010: PPUSH
64011: LD_VAR 0 1
64015: PPUSH
64016: CALL_OW 321
64020: PUSH
64021: LD_INT 2
64023: EQUAL
64024: ST_TO_ADDR
64025: GO 64203
64027: LD_INT 16
64029: DOUBLE
64030: EQUAL
64031: IFTRUE 64035
64033: GO 64062
64035: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64036: LD_ADDR_VAR 0 3
64040: PUSH
64041: LD_EXP 84
64045: PPUSH
64046: LD_VAR 0 1
64050: PPUSH
64051: CALL_OW 321
64055: PUSH
64056: LD_INT 2
64058: EQUAL
64059: ST_TO_ADDR
64060: GO 64203
64062: LD_INT 19
64064: DOUBLE
64065: EQUAL
64066: IFTRUE 64076
64068: LD_INT 23
64070: DOUBLE
64071: EQUAL
64072: IFTRUE 64076
64074: GO 64103
64076: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
64077: LD_ADDR_VAR 0 3
64081: PUSH
64082: LD_EXP 83
64086: PPUSH
64087: LD_VAR 0 1
64091: PPUSH
64092: CALL_OW 321
64096: PUSH
64097: LD_INT 2
64099: EQUAL
64100: ST_TO_ADDR
64101: GO 64203
64103: LD_INT 17
64105: DOUBLE
64106: EQUAL
64107: IFTRUE 64111
64109: GO 64136
64111: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
64112: LD_ADDR_VAR 0 3
64116: PUSH
64117: LD_INT 39
64119: PPUSH
64120: LD_VAR 0 1
64124: PPUSH
64125: CALL_OW 321
64129: PUSH
64130: LD_INT 2
64132: EQUAL
64133: ST_TO_ADDR
64134: GO 64203
64136: LD_INT 18
64138: DOUBLE
64139: EQUAL
64140: IFTRUE 64144
64142: GO 64169
64144: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
64145: LD_ADDR_VAR 0 3
64149: PUSH
64150: LD_INT 40
64152: PPUSH
64153: LD_VAR 0 1
64157: PPUSH
64158: CALL_OW 321
64162: PUSH
64163: LD_INT 2
64165: EQUAL
64166: ST_TO_ADDR
64167: GO 64203
64169: LD_INT 27
64171: DOUBLE
64172: EQUAL
64173: IFTRUE 64177
64175: GO 64202
64177: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
64178: LD_ADDR_VAR 0 3
64182: PUSH
64183: LD_INT 35
64185: PPUSH
64186: LD_VAR 0 1
64190: PPUSH
64191: CALL_OW 321
64195: PUSH
64196: LD_INT 2
64198: EQUAL
64199: ST_TO_ADDR
64200: GO 64203
64202: POP
// end ;
64203: LD_VAR 0 3
64207: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
64208: LD_INT 0
64210: PPUSH
64211: PPUSH
64212: PPUSH
64213: PPUSH
64214: PPUSH
64215: PPUSH
64216: PPUSH
64217: PPUSH
64218: PPUSH
64219: PPUSH
64220: PPUSH
// result := false ;
64221: LD_ADDR_VAR 0 6
64225: PUSH
64226: LD_INT 0
64228: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64229: LD_VAR 0 1
64233: NOT
64234: PUSH
64235: LD_VAR 0 1
64239: PPUSH
64240: CALL_OW 266
64244: PUSH
64245: LD_INT 0
64247: PUSH
64248: LD_INT 1
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: IN
64255: NOT
64256: OR
64257: PUSH
64258: LD_VAR 0 2
64262: NOT
64263: OR
64264: PUSH
64265: LD_VAR 0 5
64269: PUSH
64270: LD_INT 0
64272: PUSH
64273: LD_INT 1
64275: PUSH
64276: LD_INT 2
64278: PUSH
64279: LD_INT 3
64281: PUSH
64282: LD_INT 4
64284: PUSH
64285: LD_INT 5
64287: PUSH
64288: EMPTY
64289: LIST
64290: LIST
64291: LIST
64292: LIST
64293: LIST
64294: LIST
64295: IN
64296: NOT
64297: OR
64298: PUSH
64299: LD_VAR 0 3
64303: PPUSH
64304: LD_VAR 0 4
64308: PPUSH
64309: CALL_OW 488
64313: NOT
64314: OR
64315: IFFALSE 64319
// exit ;
64317: GO 65055
// side := GetSide ( depot ) ;
64319: LD_ADDR_VAR 0 9
64323: PUSH
64324: LD_VAR 0 1
64328: PPUSH
64329: CALL_OW 255
64333: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
64334: LD_VAR 0 9
64338: PPUSH
64339: LD_VAR 0 2
64343: PPUSH
64344: CALL 63828 0 2
64348: NOT
64349: IFFALSE 64353
// exit ;
64351: GO 65055
// pom := GetBase ( depot ) ;
64353: LD_ADDR_VAR 0 10
64357: PUSH
64358: LD_VAR 0 1
64362: PPUSH
64363: CALL_OW 274
64367: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
64368: LD_ADDR_VAR 0 11
64372: PUSH
64373: LD_VAR 0 2
64377: PPUSH
64378: LD_VAR 0 1
64382: PPUSH
64383: CALL_OW 248
64387: PPUSH
64388: CALL_OW 450
64392: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
64393: LD_VAR 0 10
64397: PPUSH
64398: LD_INT 1
64400: PPUSH
64401: CALL_OW 275
64405: PUSH
64406: LD_VAR 0 11
64410: PUSH
64411: LD_INT 1
64413: ARRAY
64414: GREATEREQUAL
64415: PUSH
64416: LD_VAR 0 10
64420: PPUSH
64421: LD_INT 2
64423: PPUSH
64424: CALL_OW 275
64428: PUSH
64429: LD_VAR 0 11
64433: PUSH
64434: LD_INT 2
64436: ARRAY
64437: GREATEREQUAL
64438: AND
64439: PUSH
64440: LD_VAR 0 10
64444: PPUSH
64445: LD_INT 3
64447: PPUSH
64448: CALL_OW 275
64452: PUSH
64453: LD_VAR 0 11
64457: PUSH
64458: LD_INT 3
64460: ARRAY
64461: GREATEREQUAL
64462: AND
64463: NOT
64464: IFFALSE 64468
// exit ;
64466: GO 65055
// if GetBType ( depot ) = b_depot then
64468: LD_VAR 0 1
64472: PPUSH
64473: CALL_OW 266
64477: PUSH
64478: LD_INT 0
64480: EQUAL
64481: IFFALSE 64493
// dist := 28 else
64483: LD_ADDR_VAR 0 14
64487: PUSH
64488: LD_INT 28
64490: ST_TO_ADDR
64491: GO 64501
// dist := 36 ;
64493: LD_ADDR_VAR 0 14
64497: PUSH
64498: LD_INT 36
64500: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
64501: LD_VAR 0 1
64505: PPUSH
64506: LD_VAR 0 3
64510: PPUSH
64511: LD_VAR 0 4
64515: PPUSH
64516: CALL_OW 297
64520: PUSH
64521: LD_VAR 0 14
64525: GREATER
64526: IFFALSE 64530
// exit ;
64528: GO 65055
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
64530: LD_ADDR_VAR 0 12
64534: PUSH
64535: LD_VAR 0 2
64539: PPUSH
64540: LD_VAR 0 3
64544: PPUSH
64545: LD_VAR 0 4
64549: PPUSH
64550: LD_VAR 0 5
64554: PPUSH
64555: LD_VAR 0 1
64559: PPUSH
64560: CALL_OW 248
64564: PPUSH
64565: LD_INT 0
64567: PPUSH
64568: CALL 65060 0 6
64572: ST_TO_ADDR
// if not hexes then
64573: LD_VAR 0 12
64577: NOT
64578: IFFALSE 64582
// exit ;
64580: GO 65055
// hex := GetHexInfo ( x , y ) ;
64582: LD_ADDR_VAR 0 15
64586: PUSH
64587: LD_VAR 0 3
64591: PPUSH
64592: LD_VAR 0 4
64596: PPUSH
64597: CALL_OW 546
64601: ST_TO_ADDR
// if hex [ 1 ] then
64602: LD_VAR 0 15
64606: PUSH
64607: LD_INT 1
64609: ARRAY
64610: IFFALSE 64614
// exit ;
64612: GO 65055
// height := hex [ 2 ] ;
64614: LD_ADDR_VAR 0 13
64618: PUSH
64619: LD_VAR 0 15
64623: PUSH
64624: LD_INT 2
64626: ARRAY
64627: ST_TO_ADDR
// for i = 1 to hexes do
64628: LD_ADDR_VAR 0 7
64632: PUSH
64633: DOUBLE
64634: LD_INT 1
64636: DEC
64637: ST_TO_ADDR
64638: LD_VAR 0 12
64642: PUSH
64643: FOR_TO
64644: IFFALSE 64974
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
64646: LD_VAR 0 12
64650: PUSH
64651: LD_VAR 0 7
64655: ARRAY
64656: PUSH
64657: LD_INT 1
64659: ARRAY
64660: PPUSH
64661: LD_VAR 0 12
64665: PUSH
64666: LD_VAR 0 7
64670: ARRAY
64671: PUSH
64672: LD_INT 2
64674: ARRAY
64675: PPUSH
64676: CALL_OW 488
64680: NOT
64681: PUSH
64682: LD_VAR 0 12
64686: PUSH
64687: LD_VAR 0 7
64691: ARRAY
64692: PUSH
64693: LD_INT 1
64695: ARRAY
64696: PPUSH
64697: LD_VAR 0 12
64701: PUSH
64702: LD_VAR 0 7
64706: ARRAY
64707: PUSH
64708: LD_INT 2
64710: ARRAY
64711: PPUSH
64712: CALL_OW 428
64716: PUSH
64717: LD_INT 0
64719: GREATER
64720: OR
64721: PUSH
64722: LD_VAR 0 12
64726: PUSH
64727: LD_VAR 0 7
64731: ARRAY
64732: PUSH
64733: LD_INT 1
64735: ARRAY
64736: PPUSH
64737: LD_VAR 0 12
64741: PUSH
64742: LD_VAR 0 7
64746: ARRAY
64747: PUSH
64748: LD_INT 2
64750: ARRAY
64751: PPUSH
64752: CALL_OW 351
64756: OR
64757: IFFALSE 64763
// exit ;
64759: POP
64760: POP
64761: GO 65055
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64763: LD_ADDR_VAR 0 8
64767: PUSH
64768: LD_VAR 0 12
64772: PUSH
64773: LD_VAR 0 7
64777: ARRAY
64778: PUSH
64779: LD_INT 1
64781: ARRAY
64782: PPUSH
64783: LD_VAR 0 12
64787: PUSH
64788: LD_VAR 0 7
64792: ARRAY
64793: PUSH
64794: LD_INT 2
64796: ARRAY
64797: PPUSH
64798: CALL_OW 546
64802: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
64803: LD_VAR 0 8
64807: PUSH
64808: LD_INT 1
64810: ARRAY
64811: PUSH
64812: LD_VAR 0 8
64816: PUSH
64817: LD_INT 2
64819: ARRAY
64820: PUSH
64821: LD_VAR 0 13
64825: PUSH
64826: LD_INT 2
64828: PLUS
64829: GREATER
64830: OR
64831: PUSH
64832: LD_VAR 0 8
64836: PUSH
64837: LD_INT 2
64839: ARRAY
64840: PUSH
64841: LD_VAR 0 13
64845: PUSH
64846: LD_INT 2
64848: MINUS
64849: LESS
64850: OR
64851: PUSH
64852: LD_VAR 0 8
64856: PUSH
64857: LD_INT 3
64859: ARRAY
64860: PUSH
64861: LD_INT 0
64863: PUSH
64864: LD_INT 8
64866: PUSH
64867: LD_INT 9
64869: PUSH
64870: LD_INT 10
64872: PUSH
64873: LD_INT 11
64875: PUSH
64876: LD_INT 12
64878: PUSH
64879: LD_INT 13
64881: PUSH
64882: LD_INT 16
64884: PUSH
64885: LD_INT 17
64887: PUSH
64888: LD_INT 18
64890: PUSH
64891: LD_INT 19
64893: PUSH
64894: LD_INT 20
64896: PUSH
64897: LD_INT 21
64899: PUSH
64900: EMPTY
64901: LIST
64902: LIST
64903: LIST
64904: LIST
64905: LIST
64906: LIST
64907: LIST
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: LIST
64913: LIST
64914: IN
64915: NOT
64916: OR
64917: PUSH
64918: LD_VAR 0 8
64922: PUSH
64923: LD_INT 5
64925: ARRAY
64926: NOT
64927: OR
64928: PUSH
64929: LD_VAR 0 8
64933: PUSH
64934: LD_INT 6
64936: ARRAY
64937: PUSH
64938: LD_INT 1
64940: PUSH
64941: LD_INT 2
64943: PUSH
64944: LD_INT 7
64946: PUSH
64947: LD_INT 9
64949: PUSH
64950: LD_INT 10
64952: PUSH
64953: LD_INT 11
64955: PUSH
64956: EMPTY
64957: LIST
64958: LIST
64959: LIST
64960: LIST
64961: LIST
64962: LIST
64963: IN
64964: NOT
64965: OR
64966: IFFALSE 64972
// exit ;
64968: POP
64969: POP
64970: GO 65055
// end ;
64972: GO 64643
64974: POP
64975: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
64976: LD_VAR 0 9
64980: PPUSH
64981: LD_VAR 0 3
64985: PPUSH
64986: LD_VAR 0 4
64990: PPUSH
64991: LD_INT 20
64993: PPUSH
64994: CALL 57000 0 4
64998: PUSH
64999: LD_INT 4
65001: ARRAY
65002: IFFALSE 65006
// exit ;
65004: GO 65055
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65006: LD_VAR 0 2
65010: PUSH
65011: LD_INT 29
65013: PUSH
65014: LD_INT 30
65016: PUSH
65017: EMPTY
65018: LIST
65019: LIST
65020: IN
65021: PUSH
65022: LD_VAR 0 3
65026: PPUSH
65027: LD_VAR 0 4
65031: PPUSH
65032: LD_VAR 0 9
65036: PPUSH
65037: CALL_OW 440
65041: NOT
65042: AND
65043: IFFALSE 65047
// exit ;
65045: GO 65055
// result := true ;
65047: LD_ADDR_VAR 0 6
65051: PUSH
65052: LD_INT 1
65054: ST_TO_ADDR
// end ;
65055: LD_VAR 0 6
65059: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65060: LD_INT 0
65062: PPUSH
65063: PPUSH
65064: PPUSH
65065: PPUSH
65066: PPUSH
65067: PPUSH
65068: PPUSH
65069: PPUSH
65070: PPUSH
65071: PPUSH
65072: PPUSH
65073: PPUSH
65074: PPUSH
65075: PPUSH
65076: PPUSH
65077: PPUSH
65078: PPUSH
65079: PPUSH
65080: PPUSH
65081: PPUSH
65082: PPUSH
65083: PPUSH
65084: PPUSH
65085: PPUSH
65086: PPUSH
65087: PPUSH
65088: PPUSH
65089: PPUSH
65090: PPUSH
65091: PPUSH
65092: PPUSH
65093: PPUSH
65094: PPUSH
65095: PPUSH
65096: PPUSH
65097: PPUSH
65098: PPUSH
65099: PPUSH
65100: PPUSH
65101: PPUSH
65102: PPUSH
65103: PPUSH
65104: PPUSH
65105: PPUSH
65106: PPUSH
65107: PPUSH
65108: PPUSH
65109: PPUSH
65110: PPUSH
65111: PPUSH
65112: PPUSH
65113: PPUSH
65114: PPUSH
65115: PPUSH
65116: PPUSH
65117: PPUSH
65118: PPUSH
65119: PPUSH
// result = [ ] ;
65120: LD_ADDR_VAR 0 7
65124: PUSH
65125: EMPTY
65126: ST_TO_ADDR
// temp_list = [ ] ;
65127: LD_ADDR_VAR 0 9
65131: PUSH
65132: EMPTY
65133: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65134: LD_VAR 0 4
65138: PUSH
65139: LD_INT 0
65141: PUSH
65142: LD_INT 1
65144: PUSH
65145: LD_INT 2
65147: PUSH
65148: LD_INT 3
65150: PUSH
65151: LD_INT 4
65153: PUSH
65154: LD_INT 5
65156: PUSH
65157: EMPTY
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: IN
65165: NOT
65166: PUSH
65167: LD_VAR 0 1
65171: PUSH
65172: LD_INT 0
65174: PUSH
65175: LD_INT 1
65177: PUSH
65178: EMPTY
65179: LIST
65180: LIST
65181: IN
65182: PUSH
65183: LD_VAR 0 5
65187: PUSH
65188: LD_INT 1
65190: PUSH
65191: LD_INT 2
65193: PUSH
65194: LD_INT 3
65196: PUSH
65197: EMPTY
65198: LIST
65199: LIST
65200: LIST
65201: IN
65202: NOT
65203: AND
65204: OR
65205: IFFALSE 65209
// exit ;
65207: GO 83600
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65209: LD_VAR 0 1
65213: PUSH
65214: LD_INT 6
65216: PUSH
65217: LD_INT 7
65219: PUSH
65220: LD_INT 8
65222: PUSH
65223: LD_INT 13
65225: PUSH
65226: LD_INT 12
65228: PUSH
65229: LD_INT 15
65231: PUSH
65232: LD_INT 11
65234: PUSH
65235: LD_INT 14
65237: PUSH
65238: LD_INT 10
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: LIST
65245: LIST
65246: LIST
65247: LIST
65248: LIST
65249: LIST
65250: LIST
65251: IN
65252: IFFALSE 65262
// btype = b_lab ;
65254: LD_ADDR_VAR 0 1
65258: PUSH
65259: LD_INT 6
65261: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65262: LD_VAR 0 6
65266: PUSH
65267: LD_INT 0
65269: PUSH
65270: LD_INT 1
65272: PUSH
65273: LD_INT 2
65275: PUSH
65276: EMPTY
65277: LIST
65278: LIST
65279: LIST
65280: IN
65281: NOT
65282: PUSH
65283: LD_VAR 0 1
65287: PUSH
65288: LD_INT 0
65290: PUSH
65291: LD_INT 1
65293: PUSH
65294: LD_INT 2
65296: PUSH
65297: LD_INT 3
65299: PUSH
65300: LD_INT 6
65302: PUSH
65303: LD_INT 36
65305: PUSH
65306: LD_INT 4
65308: PUSH
65309: LD_INT 5
65311: PUSH
65312: LD_INT 31
65314: PUSH
65315: LD_INT 32
65317: PUSH
65318: LD_INT 33
65320: PUSH
65321: EMPTY
65322: LIST
65323: LIST
65324: LIST
65325: LIST
65326: LIST
65327: LIST
65328: LIST
65329: LIST
65330: LIST
65331: LIST
65332: LIST
65333: IN
65334: NOT
65335: PUSH
65336: LD_VAR 0 6
65340: PUSH
65341: LD_INT 1
65343: EQUAL
65344: AND
65345: OR
65346: PUSH
65347: LD_VAR 0 1
65351: PUSH
65352: LD_INT 2
65354: PUSH
65355: LD_INT 3
65357: PUSH
65358: EMPTY
65359: LIST
65360: LIST
65361: IN
65362: NOT
65363: PUSH
65364: LD_VAR 0 6
65368: PUSH
65369: LD_INT 2
65371: EQUAL
65372: AND
65373: OR
65374: IFFALSE 65384
// mode = 0 ;
65376: LD_ADDR_VAR 0 6
65380: PUSH
65381: LD_INT 0
65383: ST_TO_ADDR
// case mode of 0 :
65384: LD_VAR 0 6
65388: PUSH
65389: LD_INT 0
65391: DOUBLE
65392: EQUAL
65393: IFTRUE 65397
65395: GO 76850
65397: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
65398: LD_ADDR_VAR 0 11
65402: PUSH
65403: LD_INT 0
65405: PUSH
65406: LD_INT 0
65408: PUSH
65409: EMPTY
65410: LIST
65411: LIST
65412: PUSH
65413: LD_INT 0
65415: PUSH
65416: LD_INT 1
65418: NEG
65419: PUSH
65420: EMPTY
65421: LIST
65422: LIST
65423: PUSH
65424: LD_INT 1
65426: PUSH
65427: LD_INT 0
65429: PUSH
65430: EMPTY
65431: LIST
65432: LIST
65433: PUSH
65434: LD_INT 1
65436: PUSH
65437: LD_INT 1
65439: PUSH
65440: EMPTY
65441: LIST
65442: LIST
65443: PUSH
65444: LD_INT 0
65446: PUSH
65447: LD_INT 1
65449: PUSH
65450: EMPTY
65451: LIST
65452: LIST
65453: PUSH
65454: LD_INT 1
65456: NEG
65457: PUSH
65458: LD_INT 0
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: PUSH
65465: LD_INT 1
65467: NEG
65468: PUSH
65469: LD_INT 1
65471: NEG
65472: PUSH
65473: EMPTY
65474: LIST
65475: LIST
65476: PUSH
65477: LD_INT 1
65479: NEG
65480: PUSH
65481: LD_INT 2
65483: NEG
65484: PUSH
65485: EMPTY
65486: LIST
65487: LIST
65488: PUSH
65489: LD_INT 0
65491: PUSH
65492: LD_INT 2
65494: NEG
65495: PUSH
65496: EMPTY
65497: LIST
65498: LIST
65499: PUSH
65500: LD_INT 1
65502: PUSH
65503: LD_INT 1
65505: NEG
65506: PUSH
65507: EMPTY
65508: LIST
65509: LIST
65510: PUSH
65511: LD_INT 1
65513: PUSH
65514: LD_INT 2
65516: PUSH
65517: EMPTY
65518: LIST
65519: LIST
65520: PUSH
65521: LD_INT 0
65523: PUSH
65524: LD_INT 2
65526: PUSH
65527: EMPTY
65528: LIST
65529: LIST
65530: PUSH
65531: LD_INT 1
65533: NEG
65534: PUSH
65535: LD_INT 1
65537: PUSH
65538: EMPTY
65539: LIST
65540: LIST
65541: PUSH
65542: LD_INT 1
65544: PUSH
65545: LD_INT 3
65547: PUSH
65548: EMPTY
65549: LIST
65550: LIST
65551: PUSH
65552: LD_INT 0
65554: PUSH
65555: LD_INT 3
65557: PUSH
65558: EMPTY
65559: LIST
65560: LIST
65561: PUSH
65562: LD_INT 1
65564: NEG
65565: PUSH
65566: LD_INT 2
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: EMPTY
65574: LIST
65575: LIST
65576: LIST
65577: LIST
65578: LIST
65579: LIST
65580: LIST
65581: LIST
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65591: LD_ADDR_VAR 0 12
65595: PUSH
65596: LD_INT 0
65598: PUSH
65599: LD_INT 0
65601: PUSH
65602: EMPTY
65603: LIST
65604: LIST
65605: PUSH
65606: LD_INT 0
65608: PUSH
65609: LD_INT 1
65611: NEG
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: PUSH
65617: LD_INT 1
65619: PUSH
65620: LD_INT 0
65622: PUSH
65623: EMPTY
65624: LIST
65625: LIST
65626: PUSH
65627: LD_INT 1
65629: PUSH
65630: LD_INT 1
65632: PUSH
65633: EMPTY
65634: LIST
65635: LIST
65636: PUSH
65637: LD_INT 0
65639: PUSH
65640: LD_INT 1
65642: PUSH
65643: EMPTY
65644: LIST
65645: LIST
65646: PUSH
65647: LD_INT 1
65649: NEG
65650: PUSH
65651: LD_INT 0
65653: PUSH
65654: EMPTY
65655: LIST
65656: LIST
65657: PUSH
65658: LD_INT 1
65660: NEG
65661: PUSH
65662: LD_INT 1
65664: NEG
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: LD_INT 1
65672: PUSH
65673: LD_INT 1
65675: NEG
65676: PUSH
65677: EMPTY
65678: LIST
65679: LIST
65680: PUSH
65681: LD_INT 2
65683: PUSH
65684: LD_INT 0
65686: PUSH
65687: EMPTY
65688: LIST
65689: LIST
65690: PUSH
65691: LD_INT 2
65693: PUSH
65694: LD_INT 1
65696: PUSH
65697: EMPTY
65698: LIST
65699: LIST
65700: PUSH
65701: LD_INT 1
65703: NEG
65704: PUSH
65705: LD_INT 1
65707: PUSH
65708: EMPTY
65709: LIST
65710: LIST
65711: PUSH
65712: LD_INT 2
65714: NEG
65715: PUSH
65716: LD_INT 0
65718: PUSH
65719: EMPTY
65720: LIST
65721: LIST
65722: PUSH
65723: LD_INT 2
65725: NEG
65726: PUSH
65727: LD_INT 1
65729: NEG
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: LD_INT 2
65737: NEG
65738: PUSH
65739: LD_INT 1
65741: PUSH
65742: EMPTY
65743: LIST
65744: LIST
65745: PUSH
65746: LD_INT 3
65748: NEG
65749: PUSH
65750: LD_INT 0
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: LD_INT 3
65759: NEG
65760: PUSH
65761: LD_INT 1
65763: NEG
65764: PUSH
65765: EMPTY
65766: LIST
65767: LIST
65768: PUSH
65769: EMPTY
65770: LIST
65771: LIST
65772: LIST
65773: LIST
65774: LIST
65775: LIST
65776: LIST
65777: LIST
65778: LIST
65779: LIST
65780: LIST
65781: LIST
65782: LIST
65783: LIST
65784: LIST
65785: LIST
65786: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65787: LD_ADDR_VAR 0 13
65791: PUSH
65792: LD_INT 0
65794: PUSH
65795: LD_INT 0
65797: PUSH
65798: EMPTY
65799: LIST
65800: LIST
65801: PUSH
65802: LD_INT 0
65804: PUSH
65805: LD_INT 1
65807: NEG
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 1
65815: PUSH
65816: LD_INT 0
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 1
65825: PUSH
65826: LD_INT 1
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: LD_INT 0
65835: PUSH
65836: LD_INT 1
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: LD_INT 1
65845: NEG
65846: PUSH
65847: LD_INT 0
65849: PUSH
65850: EMPTY
65851: LIST
65852: LIST
65853: PUSH
65854: LD_INT 1
65856: NEG
65857: PUSH
65858: LD_INT 1
65860: NEG
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 1
65868: NEG
65869: PUSH
65870: LD_INT 2
65872: NEG
65873: PUSH
65874: EMPTY
65875: LIST
65876: LIST
65877: PUSH
65878: LD_INT 2
65880: PUSH
65881: LD_INT 1
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: PUSH
65888: LD_INT 2
65890: PUSH
65891: LD_INT 2
65893: PUSH
65894: EMPTY
65895: LIST
65896: LIST
65897: PUSH
65898: LD_INT 1
65900: PUSH
65901: LD_INT 2
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 2
65910: NEG
65911: PUSH
65912: LD_INT 1
65914: NEG
65915: PUSH
65916: EMPTY
65917: LIST
65918: LIST
65919: PUSH
65920: LD_INT 2
65922: NEG
65923: PUSH
65924: LD_INT 2
65926: NEG
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 2
65934: NEG
65935: PUSH
65936: LD_INT 3
65938: NEG
65939: PUSH
65940: EMPTY
65941: LIST
65942: LIST
65943: PUSH
65944: LD_INT 3
65946: NEG
65947: PUSH
65948: LD_INT 2
65950: NEG
65951: PUSH
65952: EMPTY
65953: LIST
65954: LIST
65955: PUSH
65956: LD_INT 3
65958: NEG
65959: PUSH
65960: LD_INT 3
65962: NEG
65963: PUSH
65964: EMPTY
65965: LIST
65966: LIST
65967: PUSH
65968: EMPTY
65969: LIST
65970: LIST
65971: LIST
65972: LIST
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: LIST
65978: LIST
65979: LIST
65980: LIST
65981: LIST
65982: LIST
65983: LIST
65984: LIST
65985: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
65986: LD_ADDR_VAR 0 14
65990: PUSH
65991: LD_INT 0
65993: PUSH
65994: LD_INT 0
65996: PUSH
65997: EMPTY
65998: LIST
65999: LIST
66000: PUSH
66001: LD_INT 0
66003: PUSH
66004: LD_INT 1
66006: NEG
66007: PUSH
66008: EMPTY
66009: LIST
66010: LIST
66011: PUSH
66012: LD_INT 1
66014: PUSH
66015: LD_INT 0
66017: PUSH
66018: EMPTY
66019: LIST
66020: LIST
66021: PUSH
66022: LD_INT 1
66024: PUSH
66025: LD_INT 1
66027: PUSH
66028: EMPTY
66029: LIST
66030: LIST
66031: PUSH
66032: LD_INT 0
66034: PUSH
66035: LD_INT 1
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: PUSH
66042: LD_INT 1
66044: NEG
66045: PUSH
66046: LD_INT 0
66048: PUSH
66049: EMPTY
66050: LIST
66051: LIST
66052: PUSH
66053: LD_INT 1
66055: NEG
66056: PUSH
66057: LD_INT 1
66059: NEG
66060: PUSH
66061: EMPTY
66062: LIST
66063: LIST
66064: PUSH
66065: LD_INT 1
66067: NEG
66068: PUSH
66069: LD_INT 2
66071: NEG
66072: PUSH
66073: EMPTY
66074: LIST
66075: LIST
66076: PUSH
66077: LD_INT 0
66079: PUSH
66080: LD_INT 2
66082: NEG
66083: PUSH
66084: EMPTY
66085: LIST
66086: LIST
66087: PUSH
66088: LD_INT 1
66090: PUSH
66091: LD_INT 1
66093: NEG
66094: PUSH
66095: EMPTY
66096: LIST
66097: LIST
66098: PUSH
66099: LD_INT 1
66101: PUSH
66102: LD_INT 2
66104: PUSH
66105: EMPTY
66106: LIST
66107: LIST
66108: PUSH
66109: LD_INT 0
66111: PUSH
66112: LD_INT 2
66114: PUSH
66115: EMPTY
66116: LIST
66117: LIST
66118: PUSH
66119: LD_INT 1
66121: NEG
66122: PUSH
66123: LD_INT 1
66125: PUSH
66126: EMPTY
66127: LIST
66128: LIST
66129: PUSH
66130: LD_INT 1
66132: NEG
66133: PUSH
66134: LD_INT 3
66136: NEG
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: PUSH
66142: LD_INT 0
66144: PUSH
66145: LD_INT 3
66147: NEG
66148: PUSH
66149: EMPTY
66150: LIST
66151: LIST
66152: PUSH
66153: LD_INT 1
66155: PUSH
66156: LD_INT 2
66158: NEG
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66182: LD_ADDR_VAR 0 15
66186: PUSH
66187: LD_INT 0
66189: PUSH
66190: LD_INT 0
66192: PUSH
66193: EMPTY
66194: LIST
66195: LIST
66196: PUSH
66197: LD_INT 0
66199: PUSH
66200: LD_INT 1
66202: NEG
66203: PUSH
66204: EMPTY
66205: LIST
66206: LIST
66207: PUSH
66208: LD_INT 1
66210: PUSH
66211: LD_INT 0
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: PUSH
66218: LD_INT 1
66220: PUSH
66221: LD_INT 1
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: LD_INT 0
66230: PUSH
66231: LD_INT 1
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PUSH
66238: LD_INT 1
66240: NEG
66241: PUSH
66242: LD_INT 0
66244: PUSH
66245: EMPTY
66246: LIST
66247: LIST
66248: PUSH
66249: LD_INT 1
66251: NEG
66252: PUSH
66253: LD_INT 1
66255: NEG
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 1
66263: PUSH
66264: LD_INT 1
66266: NEG
66267: PUSH
66268: EMPTY
66269: LIST
66270: LIST
66271: PUSH
66272: LD_INT 2
66274: PUSH
66275: LD_INT 0
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PUSH
66282: LD_INT 2
66284: PUSH
66285: LD_INT 1
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 1
66294: NEG
66295: PUSH
66296: LD_INT 1
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: PUSH
66303: LD_INT 2
66305: NEG
66306: PUSH
66307: LD_INT 0
66309: PUSH
66310: EMPTY
66311: LIST
66312: LIST
66313: PUSH
66314: LD_INT 2
66316: NEG
66317: PUSH
66318: LD_INT 1
66320: NEG
66321: PUSH
66322: EMPTY
66323: LIST
66324: LIST
66325: PUSH
66326: LD_INT 2
66328: PUSH
66329: LD_INT 1
66331: NEG
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 3
66339: PUSH
66340: LD_INT 0
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 3
66349: PUSH
66350: LD_INT 1
66352: PUSH
66353: EMPTY
66354: LIST
66355: LIST
66356: PUSH
66357: EMPTY
66358: LIST
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
66375: LD_ADDR_VAR 0 16
66379: PUSH
66380: LD_INT 0
66382: PUSH
66383: LD_INT 0
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: PUSH
66390: LD_INT 0
66392: PUSH
66393: LD_INT 1
66395: NEG
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 1
66403: PUSH
66404: LD_INT 0
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 1
66413: PUSH
66414: LD_INT 1
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PUSH
66421: LD_INT 0
66423: PUSH
66424: LD_INT 1
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: LD_INT 1
66433: NEG
66434: PUSH
66435: LD_INT 0
66437: PUSH
66438: EMPTY
66439: LIST
66440: LIST
66441: PUSH
66442: LD_INT 1
66444: NEG
66445: PUSH
66446: LD_INT 1
66448: NEG
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 1
66456: NEG
66457: PUSH
66458: LD_INT 2
66460: NEG
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: LD_INT 2
66468: PUSH
66469: LD_INT 1
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 2
66478: PUSH
66479: LD_INT 2
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: PUSH
66486: LD_INT 1
66488: PUSH
66489: LD_INT 2
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PUSH
66496: LD_INT 2
66498: NEG
66499: PUSH
66500: LD_INT 1
66502: NEG
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: LD_INT 2
66510: NEG
66511: PUSH
66512: LD_INT 2
66514: NEG
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: PUSH
66520: LD_INT 3
66522: PUSH
66523: LD_INT 2
66525: PUSH
66526: EMPTY
66527: LIST
66528: LIST
66529: PUSH
66530: LD_INT 3
66532: PUSH
66533: LD_INT 3
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 2
66542: PUSH
66543: LD_INT 3
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: LIST
66554: LIST
66555: LIST
66556: LIST
66557: LIST
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: LIST
66564: LIST
66565: LIST
66566: LIST
66567: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66568: LD_ADDR_VAR 0 17
66572: PUSH
66573: LD_INT 0
66575: PUSH
66576: LD_INT 0
66578: PUSH
66579: EMPTY
66580: LIST
66581: LIST
66582: PUSH
66583: LD_INT 0
66585: PUSH
66586: LD_INT 1
66588: NEG
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: PUSH
66594: LD_INT 1
66596: PUSH
66597: LD_INT 0
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: LD_INT 1
66606: PUSH
66607: LD_INT 1
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: PUSH
66614: LD_INT 0
66616: PUSH
66617: LD_INT 1
66619: PUSH
66620: EMPTY
66621: LIST
66622: LIST
66623: PUSH
66624: LD_INT 1
66626: NEG
66627: PUSH
66628: LD_INT 0
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: PUSH
66635: LD_INT 1
66637: NEG
66638: PUSH
66639: LD_INT 1
66641: NEG
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: PUSH
66647: LD_INT 1
66649: NEG
66650: PUSH
66651: LD_INT 2
66653: NEG
66654: PUSH
66655: EMPTY
66656: LIST
66657: LIST
66658: PUSH
66659: LD_INT 0
66661: PUSH
66662: LD_INT 2
66664: NEG
66665: PUSH
66666: EMPTY
66667: LIST
66668: LIST
66669: PUSH
66670: LD_INT 1
66672: PUSH
66673: LD_INT 1
66675: NEG
66676: PUSH
66677: EMPTY
66678: LIST
66679: LIST
66680: PUSH
66681: LD_INT 2
66683: PUSH
66684: LD_INT 0
66686: PUSH
66687: EMPTY
66688: LIST
66689: LIST
66690: PUSH
66691: LD_INT 2
66693: PUSH
66694: LD_INT 1
66696: PUSH
66697: EMPTY
66698: LIST
66699: LIST
66700: PUSH
66701: LD_INT 2
66703: PUSH
66704: LD_INT 2
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: PUSH
66711: LD_INT 1
66713: PUSH
66714: LD_INT 2
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: PUSH
66721: LD_INT 0
66723: PUSH
66724: LD_INT 2
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: PUSH
66731: LD_INT 1
66733: NEG
66734: PUSH
66735: LD_INT 1
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: PUSH
66742: LD_INT 2
66744: NEG
66745: PUSH
66746: LD_INT 0
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: PUSH
66753: LD_INT 2
66755: NEG
66756: PUSH
66757: LD_INT 1
66759: NEG
66760: PUSH
66761: EMPTY
66762: LIST
66763: LIST
66764: PUSH
66765: LD_INT 2
66767: NEG
66768: PUSH
66769: LD_INT 2
66771: NEG
66772: PUSH
66773: EMPTY
66774: LIST
66775: LIST
66776: PUSH
66777: EMPTY
66778: LIST
66779: LIST
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: LIST
66793: LIST
66794: LIST
66795: LIST
66796: LIST
66797: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66798: LD_ADDR_VAR 0 18
66802: PUSH
66803: LD_INT 0
66805: PUSH
66806: LD_INT 0
66808: PUSH
66809: EMPTY
66810: LIST
66811: LIST
66812: PUSH
66813: LD_INT 0
66815: PUSH
66816: LD_INT 1
66818: NEG
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: PUSH
66824: LD_INT 1
66826: PUSH
66827: LD_INT 0
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: PUSH
66834: LD_INT 1
66836: PUSH
66837: LD_INT 1
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: PUSH
66844: LD_INT 0
66846: PUSH
66847: LD_INT 1
66849: PUSH
66850: EMPTY
66851: LIST
66852: LIST
66853: PUSH
66854: LD_INT 1
66856: NEG
66857: PUSH
66858: LD_INT 0
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 1
66867: NEG
66868: PUSH
66869: LD_INT 1
66871: NEG
66872: PUSH
66873: EMPTY
66874: LIST
66875: LIST
66876: PUSH
66877: LD_INT 1
66879: NEG
66880: PUSH
66881: LD_INT 2
66883: NEG
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: PUSH
66889: LD_INT 0
66891: PUSH
66892: LD_INT 2
66894: NEG
66895: PUSH
66896: EMPTY
66897: LIST
66898: LIST
66899: PUSH
66900: LD_INT 1
66902: PUSH
66903: LD_INT 1
66905: NEG
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PUSH
66911: LD_INT 2
66913: PUSH
66914: LD_INT 0
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: PUSH
66921: LD_INT 2
66923: PUSH
66924: LD_INT 1
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: PUSH
66931: LD_INT 2
66933: PUSH
66934: LD_INT 2
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PUSH
66941: LD_INT 1
66943: PUSH
66944: LD_INT 2
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: PUSH
66951: LD_INT 0
66953: PUSH
66954: LD_INT 2
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: PUSH
66961: LD_INT 1
66963: NEG
66964: PUSH
66965: LD_INT 1
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PUSH
66972: LD_INT 2
66974: NEG
66975: PUSH
66976: LD_INT 0
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 2
66985: NEG
66986: PUSH
66987: LD_INT 1
66989: NEG
66990: PUSH
66991: EMPTY
66992: LIST
66993: LIST
66994: PUSH
66995: LD_INT 2
66997: NEG
66998: PUSH
66999: LD_INT 2
67001: NEG
67002: PUSH
67003: EMPTY
67004: LIST
67005: LIST
67006: PUSH
67007: EMPTY
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: LIST
67022: LIST
67023: LIST
67024: LIST
67025: LIST
67026: LIST
67027: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67028: LD_ADDR_VAR 0 19
67032: PUSH
67033: LD_INT 0
67035: PUSH
67036: LD_INT 0
67038: PUSH
67039: EMPTY
67040: LIST
67041: LIST
67042: PUSH
67043: LD_INT 0
67045: PUSH
67046: LD_INT 1
67048: NEG
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 1
67056: PUSH
67057: LD_INT 0
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: PUSH
67064: LD_INT 1
67066: PUSH
67067: LD_INT 1
67069: PUSH
67070: EMPTY
67071: LIST
67072: LIST
67073: PUSH
67074: LD_INT 0
67076: PUSH
67077: LD_INT 1
67079: PUSH
67080: EMPTY
67081: LIST
67082: LIST
67083: PUSH
67084: LD_INT 1
67086: NEG
67087: PUSH
67088: LD_INT 0
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: PUSH
67095: LD_INT 1
67097: NEG
67098: PUSH
67099: LD_INT 1
67101: NEG
67102: PUSH
67103: EMPTY
67104: LIST
67105: LIST
67106: PUSH
67107: LD_INT 1
67109: NEG
67110: PUSH
67111: LD_INT 2
67113: NEG
67114: PUSH
67115: EMPTY
67116: LIST
67117: LIST
67118: PUSH
67119: LD_INT 0
67121: PUSH
67122: LD_INT 2
67124: NEG
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 1
67132: PUSH
67133: LD_INT 1
67135: NEG
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 2
67143: PUSH
67144: LD_INT 0
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: PUSH
67151: LD_INT 2
67153: PUSH
67154: LD_INT 1
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: PUSH
67161: LD_INT 2
67163: PUSH
67164: LD_INT 2
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: PUSH
67171: LD_INT 1
67173: PUSH
67174: LD_INT 2
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: PUSH
67181: LD_INT 0
67183: PUSH
67184: LD_INT 2
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: PUSH
67191: LD_INT 1
67193: NEG
67194: PUSH
67195: LD_INT 1
67197: PUSH
67198: EMPTY
67199: LIST
67200: LIST
67201: PUSH
67202: LD_INT 2
67204: NEG
67205: PUSH
67206: LD_INT 0
67208: PUSH
67209: EMPTY
67210: LIST
67211: LIST
67212: PUSH
67213: LD_INT 2
67215: NEG
67216: PUSH
67217: LD_INT 1
67219: NEG
67220: PUSH
67221: EMPTY
67222: LIST
67223: LIST
67224: PUSH
67225: LD_INT 2
67227: NEG
67228: PUSH
67229: LD_INT 2
67231: NEG
67232: PUSH
67233: EMPTY
67234: LIST
67235: LIST
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: LIST
67249: LIST
67250: LIST
67251: LIST
67252: LIST
67253: LIST
67254: LIST
67255: LIST
67256: LIST
67257: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67258: LD_ADDR_VAR 0 20
67262: PUSH
67263: LD_INT 0
67265: PUSH
67266: LD_INT 0
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 0
67275: PUSH
67276: LD_INT 1
67278: NEG
67279: PUSH
67280: EMPTY
67281: LIST
67282: LIST
67283: PUSH
67284: LD_INT 1
67286: PUSH
67287: LD_INT 0
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: LD_INT 1
67296: PUSH
67297: LD_INT 1
67299: PUSH
67300: EMPTY
67301: LIST
67302: LIST
67303: PUSH
67304: LD_INT 0
67306: PUSH
67307: LD_INT 1
67309: PUSH
67310: EMPTY
67311: LIST
67312: LIST
67313: PUSH
67314: LD_INT 1
67316: NEG
67317: PUSH
67318: LD_INT 0
67320: PUSH
67321: EMPTY
67322: LIST
67323: LIST
67324: PUSH
67325: LD_INT 1
67327: NEG
67328: PUSH
67329: LD_INT 1
67331: NEG
67332: PUSH
67333: EMPTY
67334: LIST
67335: LIST
67336: PUSH
67337: LD_INT 1
67339: NEG
67340: PUSH
67341: LD_INT 2
67343: NEG
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 0
67351: PUSH
67352: LD_INT 2
67354: NEG
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 1
67362: PUSH
67363: LD_INT 1
67365: NEG
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: PUSH
67371: LD_INT 2
67373: PUSH
67374: LD_INT 0
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 2
67383: PUSH
67384: LD_INT 1
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: LD_INT 2
67393: PUSH
67394: LD_INT 2
67396: PUSH
67397: EMPTY
67398: LIST
67399: LIST
67400: PUSH
67401: LD_INT 1
67403: PUSH
67404: LD_INT 2
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PUSH
67411: LD_INT 0
67413: PUSH
67414: LD_INT 2
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: PUSH
67421: LD_INT 1
67423: NEG
67424: PUSH
67425: LD_INT 1
67427: PUSH
67428: EMPTY
67429: LIST
67430: LIST
67431: PUSH
67432: LD_INT 2
67434: NEG
67435: PUSH
67436: LD_INT 0
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: LD_INT 2
67445: NEG
67446: PUSH
67447: LD_INT 1
67449: NEG
67450: PUSH
67451: EMPTY
67452: LIST
67453: LIST
67454: PUSH
67455: LD_INT 2
67457: NEG
67458: PUSH
67459: LD_INT 2
67461: NEG
67462: PUSH
67463: EMPTY
67464: LIST
67465: LIST
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: LIST
67483: LIST
67484: LIST
67485: LIST
67486: LIST
67487: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67488: LD_ADDR_VAR 0 21
67492: PUSH
67493: LD_INT 0
67495: PUSH
67496: LD_INT 0
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: PUSH
67503: LD_INT 0
67505: PUSH
67506: LD_INT 1
67508: NEG
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: LD_INT 1
67516: PUSH
67517: LD_INT 0
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PUSH
67524: LD_INT 1
67526: PUSH
67527: LD_INT 1
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 0
67536: PUSH
67537: LD_INT 1
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 1
67546: NEG
67547: PUSH
67548: LD_INT 0
67550: PUSH
67551: EMPTY
67552: LIST
67553: LIST
67554: PUSH
67555: LD_INT 1
67557: NEG
67558: PUSH
67559: LD_INT 1
67561: NEG
67562: PUSH
67563: EMPTY
67564: LIST
67565: LIST
67566: PUSH
67567: LD_INT 1
67569: NEG
67570: PUSH
67571: LD_INT 2
67573: NEG
67574: PUSH
67575: EMPTY
67576: LIST
67577: LIST
67578: PUSH
67579: LD_INT 0
67581: PUSH
67582: LD_INT 2
67584: NEG
67585: PUSH
67586: EMPTY
67587: LIST
67588: LIST
67589: PUSH
67590: LD_INT 1
67592: PUSH
67593: LD_INT 1
67595: NEG
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: PUSH
67601: LD_INT 2
67603: PUSH
67604: LD_INT 0
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: PUSH
67611: LD_INT 2
67613: PUSH
67614: LD_INT 1
67616: PUSH
67617: EMPTY
67618: LIST
67619: LIST
67620: PUSH
67621: LD_INT 2
67623: PUSH
67624: LD_INT 2
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 1
67633: PUSH
67634: LD_INT 2
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 0
67643: PUSH
67644: LD_INT 2
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: LD_INT 1
67653: NEG
67654: PUSH
67655: LD_INT 1
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 2
67664: NEG
67665: PUSH
67666: LD_INT 0
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 2
67675: NEG
67676: PUSH
67677: LD_INT 1
67679: NEG
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: PUSH
67685: LD_INT 2
67687: NEG
67688: PUSH
67689: LD_INT 2
67691: NEG
67692: PUSH
67693: EMPTY
67694: LIST
67695: LIST
67696: PUSH
67697: EMPTY
67698: LIST
67699: LIST
67700: LIST
67701: LIST
67702: LIST
67703: LIST
67704: LIST
67705: LIST
67706: LIST
67707: LIST
67708: LIST
67709: LIST
67710: LIST
67711: LIST
67712: LIST
67713: LIST
67714: LIST
67715: LIST
67716: LIST
67717: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67718: LD_ADDR_VAR 0 22
67722: PUSH
67723: LD_INT 0
67725: PUSH
67726: LD_INT 0
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: PUSH
67733: LD_INT 0
67735: PUSH
67736: LD_INT 1
67738: NEG
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: PUSH
67744: LD_INT 1
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 1
67756: PUSH
67757: LD_INT 1
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PUSH
67764: LD_INT 0
67766: PUSH
67767: LD_INT 1
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: PUSH
67774: LD_INT 1
67776: NEG
67777: PUSH
67778: LD_INT 0
67780: PUSH
67781: EMPTY
67782: LIST
67783: LIST
67784: PUSH
67785: LD_INT 1
67787: NEG
67788: PUSH
67789: LD_INT 1
67791: NEG
67792: PUSH
67793: EMPTY
67794: LIST
67795: LIST
67796: PUSH
67797: LD_INT 1
67799: NEG
67800: PUSH
67801: LD_INT 2
67803: NEG
67804: PUSH
67805: EMPTY
67806: LIST
67807: LIST
67808: PUSH
67809: LD_INT 0
67811: PUSH
67812: LD_INT 2
67814: NEG
67815: PUSH
67816: EMPTY
67817: LIST
67818: LIST
67819: PUSH
67820: LD_INT 1
67822: PUSH
67823: LD_INT 1
67825: NEG
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: PUSH
67831: LD_INT 2
67833: PUSH
67834: LD_INT 0
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: PUSH
67841: LD_INT 2
67843: PUSH
67844: LD_INT 1
67846: PUSH
67847: EMPTY
67848: LIST
67849: LIST
67850: PUSH
67851: LD_INT 2
67853: PUSH
67854: LD_INT 2
67856: PUSH
67857: EMPTY
67858: LIST
67859: LIST
67860: PUSH
67861: LD_INT 1
67863: PUSH
67864: LD_INT 2
67866: PUSH
67867: EMPTY
67868: LIST
67869: LIST
67870: PUSH
67871: LD_INT 0
67873: PUSH
67874: LD_INT 2
67876: PUSH
67877: EMPTY
67878: LIST
67879: LIST
67880: PUSH
67881: LD_INT 1
67883: NEG
67884: PUSH
67885: LD_INT 1
67887: PUSH
67888: EMPTY
67889: LIST
67890: LIST
67891: PUSH
67892: LD_INT 2
67894: NEG
67895: PUSH
67896: LD_INT 0
67898: PUSH
67899: EMPTY
67900: LIST
67901: LIST
67902: PUSH
67903: LD_INT 2
67905: NEG
67906: PUSH
67907: LD_INT 1
67909: NEG
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: PUSH
67915: LD_INT 2
67917: NEG
67918: PUSH
67919: LD_INT 2
67921: NEG
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: LIST
67940: LIST
67941: LIST
67942: LIST
67943: LIST
67944: LIST
67945: LIST
67946: LIST
67947: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
67948: LD_ADDR_VAR 0 23
67952: PUSH
67953: LD_INT 0
67955: PUSH
67956: LD_INT 0
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PUSH
67963: LD_INT 0
67965: PUSH
67966: LD_INT 1
67968: NEG
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: LD_INT 1
67976: PUSH
67977: LD_INT 0
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 1
67986: PUSH
67987: LD_INT 1
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 0
67996: PUSH
67997: LD_INT 1
67999: PUSH
68000: EMPTY
68001: LIST
68002: LIST
68003: PUSH
68004: LD_INT 1
68006: NEG
68007: PUSH
68008: LD_INT 0
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: LD_INT 1
68017: NEG
68018: PUSH
68019: LD_INT 1
68021: NEG
68022: PUSH
68023: EMPTY
68024: LIST
68025: LIST
68026: PUSH
68027: LD_INT 1
68029: NEG
68030: PUSH
68031: LD_INT 2
68033: NEG
68034: PUSH
68035: EMPTY
68036: LIST
68037: LIST
68038: PUSH
68039: LD_INT 0
68041: PUSH
68042: LD_INT 2
68044: NEG
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: PUSH
68050: LD_INT 1
68052: PUSH
68053: LD_INT 1
68055: NEG
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: PUSH
68061: LD_INT 2
68063: PUSH
68064: LD_INT 0
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 2
68073: PUSH
68074: LD_INT 1
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: LD_INT 2
68083: PUSH
68084: LD_INT 2
68086: PUSH
68087: EMPTY
68088: LIST
68089: LIST
68090: PUSH
68091: LD_INT 1
68093: PUSH
68094: LD_INT 2
68096: PUSH
68097: EMPTY
68098: LIST
68099: LIST
68100: PUSH
68101: LD_INT 0
68103: PUSH
68104: LD_INT 2
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: PUSH
68111: LD_INT 1
68113: NEG
68114: PUSH
68115: LD_INT 1
68117: PUSH
68118: EMPTY
68119: LIST
68120: LIST
68121: PUSH
68122: LD_INT 2
68124: NEG
68125: PUSH
68126: LD_INT 0
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PUSH
68133: LD_INT 2
68135: NEG
68136: PUSH
68137: LD_INT 1
68139: NEG
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 2
68147: NEG
68148: PUSH
68149: LD_INT 2
68151: NEG
68152: PUSH
68153: EMPTY
68154: LIST
68155: LIST
68156: PUSH
68157: LD_INT 2
68159: NEG
68160: PUSH
68161: LD_INT 3
68163: NEG
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: PUSH
68169: LD_INT 1
68171: NEG
68172: PUSH
68173: LD_INT 3
68175: NEG
68176: PUSH
68177: EMPTY
68178: LIST
68179: LIST
68180: PUSH
68181: LD_INT 1
68183: PUSH
68184: LD_INT 2
68186: NEG
68187: PUSH
68188: EMPTY
68189: LIST
68190: LIST
68191: PUSH
68192: LD_INT 2
68194: PUSH
68195: LD_INT 1
68197: NEG
68198: PUSH
68199: EMPTY
68200: LIST
68201: LIST
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: LIST
68211: LIST
68212: LIST
68213: LIST
68214: LIST
68215: LIST
68216: LIST
68217: LIST
68218: LIST
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: LIST
68224: LIST
68225: LIST
68226: LIST
68227: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68228: LD_ADDR_VAR 0 24
68232: PUSH
68233: LD_INT 0
68235: PUSH
68236: LD_INT 0
68238: PUSH
68239: EMPTY
68240: LIST
68241: LIST
68242: PUSH
68243: LD_INT 0
68245: PUSH
68246: LD_INT 1
68248: NEG
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PUSH
68254: LD_INT 1
68256: PUSH
68257: LD_INT 0
68259: PUSH
68260: EMPTY
68261: LIST
68262: LIST
68263: PUSH
68264: LD_INT 1
68266: PUSH
68267: LD_INT 1
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: LD_INT 0
68276: PUSH
68277: LD_INT 1
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 1
68286: NEG
68287: PUSH
68288: LD_INT 0
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: LD_INT 1
68297: NEG
68298: PUSH
68299: LD_INT 1
68301: NEG
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: LD_INT 1
68309: NEG
68310: PUSH
68311: LD_INT 2
68313: NEG
68314: PUSH
68315: EMPTY
68316: LIST
68317: LIST
68318: PUSH
68319: LD_INT 0
68321: PUSH
68322: LD_INT 2
68324: NEG
68325: PUSH
68326: EMPTY
68327: LIST
68328: LIST
68329: PUSH
68330: LD_INT 1
68332: PUSH
68333: LD_INT 1
68335: NEG
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 2
68343: PUSH
68344: LD_INT 0
68346: PUSH
68347: EMPTY
68348: LIST
68349: LIST
68350: PUSH
68351: LD_INT 2
68353: PUSH
68354: LD_INT 1
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 2
68363: PUSH
68364: LD_INT 2
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: LD_INT 2
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 0
68383: PUSH
68384: LD_INT 2
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 1
68393: NEG
68394: PUSH
68395: LD_INT 1
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PUSH
68402: LD_INT 2
68404: NEG
68405: PUSH
68406: LD_INT 0
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 2
68415: NEG
68416: PUSH
68417: LD_INT 1
68419: NEG
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PUSH
68425: LD_INT 2
68427: NEG
68428: PUSH
68429: LD_INT 2
68431: NEG
68432: PUSH
68433: EMPTY
68434: LIST
68435: LIST
68436: PUSH
68437: LD_INT 1
68439: PUSH
68440: LD_INT 2
68442: NEG
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 2
68450: PUSH
68451: LD_INT 1
68453: NEG
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 3
68461: PUSH
68462: LD_INT 1
68464: PUSH
68465: EMPTY
68466: LIST
68467: LIST
68468: PUSH
68469: LD_INT 3
68471: PUSH
68472: LD_INT 2
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: LIST
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: LIST
68496: LIST
68497: LIST
68498: LIST
68499: LIST
68500: LIST
68501: LIST
68502: LIST
68503: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
68504: LD_ADDR_VAR 0 25
68508: PUSH
68509: LD_INT 0
68511: PUSH
68512: LD_INT 0
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: LD_INT 0
68521: PUSH
68522: LD_INT 1
68524: NEG
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: PUSH
68530: LD_INT 1
68532: PUSH
68533: LD_INT 0
68535: PUSH
68536: EMPTY
68537: LIST
68538: LIST
68539: PUSH
68540: LD_INT 1
68542: PUSH
68543: LD_INT 1
68545: PUSH
68546: EMPTY
68547: LIST
68548: LIST
68549: PUSH
68550: LD_INT 0
68552: PUSH
68553: LD_INT 1
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: PUSH
68560: LD_INT 1
68562: NEG
68563: PUSH
68564: LD_INT 0
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 1
68573: NEG
68574: PUSH
68575: LD_INT 1
68577: NEG
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: PUSH
68583: LD_INT 1
68585: NEG
68586: PUSH
68587: LD_INT 2
68589: NEG
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: PUSH
68595: LD_INT 0
68597: PUSH
68598: LD_INT 2
68600: NEG
68601: PUSH
68602: EMPTY
68603: LIST
68604: LIST
68605: PUSH
68606: LD_INT 1
68608: PUSH
68609: LD_INT 1
68611: NEG
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: PUSH
68617: LD_INT 2
68619: PUSH
68620: LD_INT 0
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PUSH
68627: LD_INT 2
68629: PUSH
68630: LD_INT 1
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PUSH
68637: LD_INT 2
68639: PUSH
68640: LD_INT 2
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: PUSH
68647: LD_INT 1
68649: PUSH
68650: LD_INT 2
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PUSH
68657: LD_INT 0
68659: PUSH
68660: LD_INT 2
68662: PUSH
68663: EMPTY
68664: LIST
68665: LIST
68666: PUSH
68667: LD_INT 1
68669: NEG
68670: PUSH
68671: LD_INT 1
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 2
68680: NEG
68681: PUSH
68682: LD_INT 0
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: LD_INT 2
68691: NEG
68692: PUSH
68693: LD_INT 1
68695: NEG
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: LD_INT 2
68703: NEG
68704: PUSH
68705: LD_INT 2
68707: NEG
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 3
68715: PUSH
68716: LD_INT 1
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 3
68725: PUSH
68726: LD_INT 2
68728: PUSH
68729: EMPTY
68730: LIST
68731: LIST
68732: PUSH
68733: LD_INT 2
68735: PUSH
68736: LD_INT 3
68738: PUSH
68739: EMPTY
68740: LIST
68741: LIST
68742: PUSH
68743: LD_INT 1
68745: PUSH
68746: LD_INT 3
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: LIST
68757: LIST
68758: LIST
68759: LIST
68760: LIST
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: LIST
68768: LIST
68769: LIST
68770: LIST
68771: LIST
68772: LIST
68773: LIST
68774: LIST
68775: LIST
68776: LIST
68777: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
68778: LD_ADDR_VAR 0 26
68782: PUSH
68783: LD_INT 0
68785: PUSH
68786: LD_INT 0
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 0
68795: PUSH
68796: LD_INT 1
68798: NEG
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: LD_INT 1
68806: PUSH
68807: LD_INT 0
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 1
68816: PUSH
68817: LD_INT 1
68819: PUSH
68820: EMPTY
68821: LIST
68822: LIST
68823: PUSH
68824: LD_INT 0
68826: PUSH
68827: LD_INT 1
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: PUSH
68834: LD_INT 1
68836: NEG
68837: PUSH
68838: LD_INT 0
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: PUSH
68845: LD_INT 1
68847: NEG
68848: PUSH
68849: LD_INT 1
68851: NEG
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: PUSH
68857: LD_INT 1
68859: NEG
68860: PUSH
68861: LD_INT 2
68863: NEG
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: PUSH
68869: LD_INT 0
68871: PUSH
68872: LD_INT 2
68874: NEG
68875: PUSH
68876: EMPTY
68877: LIST
68878: LIST
68879: PUSH
68880: LD_INT 1
68882: PUSH
68883: LD_INT 1
68885: NEG
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: LD_INT 2
68893: PUSH
68894: LD_INT 0
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 2
68903: PUSH
68904: LD_INT 1
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 2
68913: PUSH
68914: LD_INT 2
68916: PUSH
68917: EMPTY
68918: LIST
68919: LIST
68920: PUSH
68921: LD_INT 1
68923: PUSH
68924: LD_INT 2
68926: PUSH
68927: EMPTY
68928: LIST
68929: LIST
68930: PUSH
68931: LD_INT 0
68933: PUSH
68934: LD_INT 2
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: LD_INT 1
68943: NEG
68944: PUSH
68945: LD_INT 1
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: PUSH
68952: LD_INT 2
68954: NEG
68955: PUSH
68956: LD_INT 0
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: LD_INT 2
68965: NEG
68966: PUSH
68967: LD_INT 1
68969: NEG
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 2
68977: NEG
68978: PUSH
68979: LD_INT 2
68981: NEG
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PUSH
68987: LD_INT 2
68989: PUSH
68990: LD_INT 3
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: PUSH
68997: LD_INT 1
68999: PUSH
69000: LD_INT 3
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: LD_INT 1
69009: NEG
69010: PUSH
69011: LD_INT 2
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PUSH
69018: LD_INT 2
69020: NEG
69021: PUSH
69022: LD_INT 1
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: LIST
69033: LIST
69034: LIST
69035: LIST
69036: LIST
69037: LIST
69038: LIST
69039: LIST
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: LIST
69051: LIST
69052: LIST
69053: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69054: LD_ADDR_VAR 0 27
69058: PUSH
69059: LD_INT 0
69061: PUSH
69062: LD_INT 0
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 0
69071: PUSH
69072: LD_INT 1
69074: NEG
69075: PUSH
69076: EMPTY
69077: LIST
69078: LIST
69079: PUSH
69080: LD_INT 1
69082: PUSH
69083: LD_INT 0
69085: PUSH
69086: EMPTY
69087: LIST
69088: LIST
69089: PUSH
69090: LD_INT 1
69092: PUSH
69093: LD_INT 1
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: PUSH
69100: LD_INT 0
69102: PUSH
69103: LD_INT 1
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 1
69112: NEG
69113: PUSH
69114: LD_INT 0
69116: PUSH
69117: EMPTY
69118: LIST
69119: LIST
69120: PUSH
69121: LD_INT 1
69123: NEG
69124: PUSH
69125: LD_INT 1
69127: NEG
69128: PUSH
69129: EMPTY
69130: LIST
69131: LIST
69132: PUSH
69133: LD_INT 1
69135: NEG
69136: PUSH
69137: LD_INT 2
69139: NEG
69140: PUSH
69141: EMPTY
69142: LIST
69143: LIST
69144: PUSH
69145: LD_INT 0
69147: PUSH
69148: LD_INT 2
69150: NEG
69151: PUSH
69152: EMPTY
69153: LIST
69154: LIST
69155: PUSH
69156: LD_INT 1
69158: PUSH
69159: LD_INT 1
69161: NEG
69162: PUSH
69163: EMPTY
69164: LIST
69165: LIST
69166: PUSH
69167: LD_INT 2
69169: PUSH
69170: LD_INT 0
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: PUSH
69177: LD_INT 2
69179: PUSH
69180: LD_INT 1
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PUSH
69187: LD_INT 2
69189: PUSH
69190: LD_INT 2
69192: PUSH
69193: EMPTY
69194: LIST
69195: LIST
69196: PUSH
69197: LD_INT 1
69199: PUSH
69200: LD_INT 2
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: PUSH
69207: LD_INT 0
69209: PUSH
69210: LD_INT 2
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: PUSH
69217: LD_INT 1
69219: NEG
69220: PUSH
69221: LD_INT 1
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: PUSH
69228: LD_INT 2
69230: NEG
69231: PUSH
69232: LD_INT 0
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: LD_INT 2
69241: NEG
69242: PUSH
69243: LD_INT 1
69245: NEG
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PUSH
69251: LD_INT 2
69253: NEG
69254: PUSH
69255: LD_INT 2
69257: NEG
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: LD_INT 1
69265: NEG
69266: PUSH
69267: LD_INT 2
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: PUSH
69274: LD_INT 2
69276: NEG
69277: PUSH
69278: LD_INT 1
69280: PUSH
69281: EMPTY
69282: LIST
69283: LIST
69284: PUSH
69285: LD_INT 3
69287: NEG
69288: PUSH
69289: LD_INT 1
69291: NEG
69292: PUSH
69293: EMPTY
69294: LIST
69295: LIST
69296: PUSH
69297: LD_INT 3
69299: NEG
69300: PUSH
69301: LD_INT 2
69303: NEG
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: LIST
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: LIST
69332: LIST
69333: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69334: LD_ADDR_VAR 0 28
69338: PUSH
69339: LD_INT 0
69341: PUSH
69342: LD_INT 0
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PUSH
69349: LD_INT 0
69351: PUSH
69352: LD_INT 1
69354: NEG
69355: PUSH
69356: EMPTY
69357: LIST
69358: LIST
69359: PUSH
69360: LD_INT 1
69362: PUSH
69363: LD_INT 0
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: PUSH
69370: LD_INT 1
69372: PUSH
69373: LD_INT 1
69375: PUSH
69376: EMPTY
69377: LIST
69378: LIST
69379: PUSH
69380: LD_INT 0
69382: PUSH
69383: LD_INT 1
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 1
69392: NEG
69393: PUSH
69394: LD_INT 0
69396: PUSH
69397: EMPTY
69398: LIST
69399: LIST
69400: PUSH
69401: LD_INT 1
69403: NEG
69404: PUSH
69405: LD_INT 1
69407: NEG
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: PUSH
69413: LD_INT 1
69415: NEG
69416: PUSH
69417: LD_INT 2
69419: NEG
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 0
69427: PUSH
69428: LD_INT 2
69430: NEG
69431: PUSH
69432: EMPTY
69433: LIST
69434: LIST
69435: PUSH
69436: LD_INT 1
69438: PUSH
69439: LD_INT 1
69441: NEG
69442: PUSH
69443: EMPTY
69444: LIST
69445: LIST
69446: PUSH
69447: LD_INT 2
69449: PUSH
69450: LD_INT 0
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PUSH
69457: LD_INT 2
69459: PUSH
69460: LD_INT 1
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 2
69469: PUSH
69470: LD_INT 2
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: PUSH
69477: LD_INT 1
69479: PUSH
69480: LD_INT 2
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: PUSH
69487: LD_INT 0
69489: PUSH
69490: LD_INT 2
69492: PUSH
69493: EMPTY
69494: LIST
69495: LIST
69496: PUSH
69497: LD_INT 1
69499: NEG
69500: PUSH
69501: LD_INT 1
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 2
69510: NEG
69511: PUSH
69512: LD_INT 0
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: LD_INT 2
69521: NEG
69522: PUSH
69523: LD_INT 1
69525: NEG
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 2
69533: NEG
69534: PUSH
69535: LD_INT 2
69537: NEG
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: PUSH
69543: LD_INT 2
69545: NEG
69546: PUSH
69547: LD_INT 3
69549: NEG
69550: PUSH
69551: EMPTY
69552: LIST
69553: LIST
69554: PUSH
69555: LD_INT 1
69557: NEG
69558: PUSH
69559: LD_INT 3
69561: NEG
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 3
69569: NEG
69570: PUSH
69571: LD_INT 1
69573: NEG
69574: PUSH
69575: EMPTY
69576: LIST
69577: LIST
69578: PUSH
69579: LD_INT 3
69581: NEG
69582: PUSH
69583: LD_INT 2
69585: NEG
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: LIST
69609: LIST
69610: LIST
69611: LIST
69612: LIST
69613: LIST
69614: LIST
69615: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69616: LD_ADDR_VAR 0 29
69620: PUSH
69621: LD_INT 0
69623: PUSH
69624: LD_INT 0
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: PUSH
69631: LD_INT 0
69633: PUSH
69634: LD_INT 1
69636: NEG
69637: PUSH
69638: EMPTY
69639: LIST
69640: LIST
69641: PUSH
69642: LD_INT 1
69644: PUSH
69645: LD_INT 0
69647: PUSH
69648: EMPTY
69649: LIST
69650: LIST
69651: PUSH
69652: LD_INT 1
69654: PUSH
69655: LD_INT 1
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: PUSH
69662: LD_INT 0
69664: PUSH
69665: LD_INT 1
69667: PUSH
69668: EMPTY
69669: LIST
69670: LIST
69671: PUSH
69672: LD_INT 1
69674: NEG
69675: PUSH
69676: LD_INT 0
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: PUSH
69683: LD_INT 1
69685: NEG
69686: PUSH
69687: LD_INT 1
69689: NEG
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: PUSH
69695: LD_INT 1
69697: NEG
69698: PUSH
69699: LD_INT 2
69701: NEG
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: PUSH
69707: LD_INT 0
69709: PUSH
69710: LD_INT 2
69712: NEG
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 1
69720: PUSH
69721: LD_INT 1
69723: NEG
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 2
69731: PUSH
69732: LD_INT 0
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: PUSH
69739: LD_INT 2
69741: PUSH
69742: LD_INT 1
69744: PUSH
69745: EMPTY
69746: LIST
69747: LIST
69748: PUSH
69749: LD_INT 1
69751: PUSH
69752: LD_INT 2
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: PUSH
69759: LD_INT 0
69761: PUSH
69762: LD_INT 2
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: PUSH
69769: LD_INT 1
69771: NEG
69772: PUSH
69773: LD_INT 1
69775: PUSH
69776: EMPTY
69777: LIST
69778: LIST
69779: PUSH
69780: LD_INT 2
69782: NEG
69783: PUSH
69784: LD_INT 1
69786: NEG
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 2
69794: NEG
69795: PUSH
69796: LD_INT 2
69798: NEG
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 2
69806: NEG
69807: PUSH
69808: LD_INT 3
69810: NEG
69811: PUSH
69812: EMPTY
69813: LIST
69814: LIST
69815: PUSH
69816: LD_INT 2
69818: PUSH
69819: LD_INT 1
69821: NEG
69822: PUSH
69823: EMPTY
69824: LIST
69825: LIST
69826: PUSH
69827: LD_INT 3
69829: PUSH
69830: LD_INT 1
69832: PUSH
69833: EMPTY
69834: LIST
69835: LIST
69836: PUSH
69837: LD_INT 1
69839: PUSH
69840: LD_INT 3
69842: PUSH
69843: EMPTY
69844: LIST
69845: LIST
69846: PUSH
69847: LD_INT 1
69849: NEG
69850: PUSH
69851: LD_INT 2
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: PUSH
69858: LD_INT 3
69860: NEG
69861: PUSH
69862: LD_INT 2
69864: NEG
69865: PUSH
69866: EMPTY
69867: LIST
69868: LIST
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: LIST
69883: LIST
69884: LIST
69885: LIST
69886: LIST
69887: LIST
69888: LIST
69889: LIST
69890: LIST
69891: LIST
69892: LIST
69893: LIST
69894: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69895: LD_ADDR_VAR 0 30
69899: PUSH
69900: LD_INT 0
69902: PUSH
69903: LD_INT 0
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 0
69912: PUSH
69913: LD_INT 1
69915: NEG
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 1
69923: PUSH
69924: LD_INT 0
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 1
69933: PUSH
69934: LD_INT 1
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 0
69943: PUSH
69944: LD_INT 1
69946: PUSH
69947: EMPTY
69948: LIST
69949: LIST
69950: PUSH
69951: LD_INT 1
69953: NEG
69954: PUSH
69955: LD_INT 0
69957: PUSH
69958: EMPTY
69959: LIST
69960: LIST
69961: PUSH
69962: LD_INT 1
69964: NEG
69965: PUSH
69966: LD_INT 1
69968: NEG
69969: PUSH
69970: EMPTY
69971: LIST
69972: LIST
69973: PUSH
69974: LD_INT 1
69976: NEG
69977: PUSH
69978: LD_INT 2
69980: NEG
69981: PUSH
69982: EMPTY
69983: LIST
69984: LIST
69985: PUSH
69986: LD_INT 0
69988: PUSH
69989: LD_INT 2
69991: NEG
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: LD_INT 1
69999: PUSH
70000: LD_INT 1
70002: NEG
70003: PUSH
70004: EMPTY
70005: LIST
70006: LIST
70007: PUSH
70008: LD_INT 2
70010: PUSH
70011: LD_INT 0
70013: PUSH
70014: EMPTY
70015: LIST
70016: LIST
70017: PUSH
70018: LD_INT 2
70020: PUSH
70021: LD_INT 1
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PUSH
70028: LD_INT 2
70030: PUSH
70031: LD_INT 2
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: PUSH
70038: LD_INT 1
70040: PUSH
70041: LD_INT 2
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: PUSH
70048: LD_INT 1
70050: NEG
70051: PUSH
70052: LD_INT 1
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: PUSH
70059: LD_INT 2
70061: NEG
70062: PUSH
70063: LD_INT 0
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 2
70072: NEG
70073: PUSH
70074: LD_INT 1
70076: NEG
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: PUSH
70082: LD_INT 1
70084: NEG
70085: PUSH
70086: LD_INT 3
70088: NEG
70089: PUSH
70090: EMPTY
70091: LIST
70092: LIST
70093: PUSH
70094: LD_INT 1
70096: PUSH
70097: LD_INT 2
70099: NEG
70100: PUSH
70101: EMPTY
70102: LIST
70103: LIST
70104: PUSH
70105: LD_INT 3
70107: PUSH
70108: LD_INT 2
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PUSH
70115: LD_INT 2
70117: PUSH
70118: LD_INT 3
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: LD_INT 2
70127: NEG
70128: PUSH
70129: LD_INT 1
70131: PUSH
70132: EMPTY
70133: LIST
70134: LIST
70135: PUSH
70136: LD_INT 3
70138: NEG
70139: PUSH
70140: LD_INT 1
70142: NEG
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: LIST
70152: LIST
70153: LIST
70154: LIST
70155: LIST
70156: LIST
70157: LIST
70158: LIST
70159: LIST
70160: LIST
70161: LIST
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: LIST
70167: LIST
70168: LIST
70169: LIST
70170: LIST
70171: LIST
70172: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70173: LD_ADDR_VAR 0 31
70177: PUSH
70178: LD_INT 0
70180: PUSH
70181: LD_INT 0
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 0
70190: PUSH
70191: LD_INT 1
70193: NEG
70194: PUSH
70195: EMPTY
70196: LIST
70197: LIST
70198: PUSH
70199: LD_INT 1
70201: PUSH
70202: LD_INT 0
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PUSH
70209: LD_INT 1
70211: PUSH
70212: LD_INT 1
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 0
70221: PUSH
70222: LD_INT 1
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: PUSH
70229: LD_INT 1
70231: NEG
70232: PUSH
70233: LD_INT 0
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 1
70242: NEG
70243: PUSH
70244: LD_INT 1
70246: NEG
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 1
70254: NEG
70255: PUSH
70256: LD_INT 2
70258: NEG
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 1
70266: PUSH
70267: LD_INT 1
70269: NEG
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 2
70277: PUSH
70278: LD_INT 0
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PUSH
70285: LD_INT 2
70287: PUSH
70288: LD_INT 1
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 2
70297: PUSH
70298: LD_INT 2
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 1
70307: PUSH
70308: LD_INT 2
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PUSH
70315: LD_INT 0
70317: PUSH
70318: LD_INT 2
70320: PUSH
70321: EMPTY
70322: LIST
70323: LIST
70324: PUSH
70325: LD_INT 1
70327: NEG
70328: PUSH
70329: LD_INT 1
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 2
70338: NEG
70339: PUSH
70340: LD_INT 1
70342: NEG
70343: PUSH
70344: EMPTY
70345: LIST
70346: LIST
70347: PUSH
70348: LD_INT 2
70350: NEG
70351: PUSH
70352: LD_INT 2
70354: NEG
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 2
70362: NEG
70363: PUSH
70364: LD_INT 3
70366: NEG
70367: PUSH
70368: EMPTY
70369: LIST
70370: LIST
70371: PUSH
70372: LD_INT 2
70374: PUSH
70375: LD_INT 1
70377: NEG
70378: PUSH
70379: EMPTY
70380: LIST
70381: LIST
70382: PUSH
70383: LD_INT 3
70385: PUSH
70386: LD_INT 1
70388: PUSH
70389: EMPTY
70390: LIST
70391: LIST
70392: PUSH
70393: LD_INT 1
70395: PUSH
70396: LD_INT 3
70398: PUSH
70399: EMPTY
70400: LIST
70401: LIST
70402: PUSH
70403: LD_INT 1
70405: NEG
70406: PUSH
70407: LD_INT 2
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PUSH
70414: LD_INT 3
70416: NEG
70417: PUSH
70418: LD_INT 2
70420: NEG
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: LIST
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: LIST
70445: LIST
70446: LIST
70447: LIST
70448: LIST
70449: LIST
70450: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70451: LD_ADDR_VAR 0 32
70455: PUSH
70456: LD_INT 0
70458: PUSH
70459: LD_INT 0
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 0
70468: PUSH
70469: LD_INT 1
70471: NEG
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 1
70479: PUSH
70480: LD_INT 0
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 1
70489: PUSH
70490: LD_INT 1
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: PUSH
70497: LD_INT 0
70499: PUSH
70500: LD_INT 1
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: PUSH
70507: LD_INT 1
70509: NEG
70510: PUSH
70511: LD_INT 0
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: PUSH
70518: LD_INT 1
70520: NEG
70521: PUSH
70522: LD_INT 1
70524: NEG
70525: PUSH
70526: EMPTY
70527: LIST
70528: LIST
70529: PUSH
70530: LD_INT 1
70532: NEG
70533: PUSH
70534: LD_INT 2
70536: NEG
70537: PUSH
70538: EMPTY
70539: LIST
70540: LIST
70541: PUSH
70542: LD_INT 0
70544: PUSH
70545: LD_INT 2
70547: NEG
70548: PUSH
70549: EMPTY
70550: LIST
70551: LIST
70552: PUSH
70553: LD_INT 1
70555: PUSH
70556: LD_INT 1
70558: NEG
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 2
70566: PUSH
70567: LD_INT 1
70569: PUSH
70570: EMPTY
70571: LIST
70572: LIST
70573: PUSH
70574: LD_INT 2
70576: PUSH
70577: LD_INT 2
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: PUSH
70584: LD_INT 1
70586: PUSH
70587: LD_INT 2
70589: PUSH
70590: EMPTY
70591: LIST
70592: LIST
70593: PUSH
70594: LD_INT 0
70596: PUSH
70597: LD_INT 2
70599: PUSH
70600: EMPTY
70601: LIST
70602: LIST
70603: PUSH
70604: LD_INT 1
70606: NEG
70607: PUSH
70608: LD_INT 1
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: PUSH
70615: LD_INT 2
70617: NEG
70618: PUSH
70619: LD_INT 0
70621: PUSH
70622: EMPTY
70623: LIST
70624: LIST
70625: PUSH
70626: LD_INT 2
70628: NEG
70629: PUSH
70630: LD_INT 1
70632: NEG
70633: PUSH
70634: EMPTY
70635: LIST
70636: LIST
70637: PUSH
70638: LD_INT 1
70640: NEG
70641: PUSH
70642: LD_INT 3
70644: NEG
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: PUSH
70650: LD_INT 1
70652: PUSH
70653: LD_INT 2
70655: NEG
70656: PUSH
70657: EMPTY
70658: LIST
70659: LIST
70660: PUSH
70661: LD_INT 3
70663: PUSH
70664: LD_INT 2
70666: PUSH
70667: EMPTY
70668: LIST
70669: LIST
70670: PUSH
70671: LD_INT 2
70673: PUSH
70674: LD_INT 3
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 2
70683: NEG
70684: PUSH
70685: LD_INT 1
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: LD_INT 3
70694: NEG
70695: PUSH
70696: LD_INT 1
70698: NEG
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: EMPTY
70705: LIST
70706: LIST
70707: LIST
70708: LIST
70709: LIST
70710: LIST
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: LIST
70718: LIST
70719: LIST
70720: LIST
70721: LIST
70722: LIST
70723: LIST
70724: LIST
70725: LIST
70726: LIST
70727: LIST
70728: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70729: LD_ADDR_VAR 0 33
70733: PUSH
70734: LD_INT 0
70736: PUSH
70737: LD_INT 0
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 0
70746: PUSH
70747: LD_INT 1
70749: NEG
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PUSH
70755: LD_INT 1
70757: PUSH
70758: LD_INT 0
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 1
70767: PUSH
70768: LD_INT 1
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: LD_INT 0
70777: PUSH
70778: LD_INT 1
70780: PUSH
70781: EMPTY
70782: LIST
70783: LIST
70784: PUSH
70785: LD_INT 1
70787: NEG
70788: PUSH
70789: LD_INT 0
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 1
70798: NEG
70799: PUSH
70800: LD_INT 1
70802: NEG
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: PUSH
70808: LD_INT 1
70810: NEG
70811: PUSH
70812: LD_INT 2
70814: NEG
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 1
70822: PUSH
70823: LD_INT 1
70825: NEG
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 2
70833: PUSH
70834: LD_INT 0
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 2
70843: PUSH
70844: LD_INT 1
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 1
70853: PUSH
70854: LD_INT 2
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 0
70863: PUSH
70864: LD_INT 2
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: PUSH
70871: LD_INT 1
70873: NEG
70874: PUSH
70875: LD_INT 1
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 2
70884: NEG
70885: PUSH
70886: LD_INT 0
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: LD_INT 2
70895: NEG
70896: PUSH
70897: LD_INT 1
70899: NEG
70900: PUSH
70901: EMPTY
70902: LIST
70903: LIST
70904: PUSH
70905: LD_INT 2
70907: NEG
70908: PUSH
70909: LD_INT 2
70911: NEG
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 2
70919: NEG
70920: PUSH
70921: LD_INT 3
70923: NEG
70924: PUSH
70925: EMPTY
70926: LIST
70927: LIST
70928: PUSH
70929: LD_INT 2
70931: PUSH
70932: LD_INT 1
70934: NEG
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 3
70942: PUSH
70943: LD_INT 1
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 1
70952: PUSH
70953: LD_INT 3
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PUSH
70960: LD_INT 1
70962: NEG
70963: PUSH
70964: LD_INT 2
70966: PUSH
70967: EMPTY
70968: LIST
70969: LIST
70970: PUSH
70971: LD_INT 3
70973: NEG
70974: PUSH
70975: LD_INT 2
70977: NEG
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: LIST
70994: LIST
70995: LIST
70996: LIST
70997: LIST
70998: LIST
70999: LIST
71000: LIST
71001: LIST
71002: LIST
71003: LIST
71004: LIST
71005: LIST
71006: LIST
71007: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71008: LD_ADDR_VAR 0 34
71012: PUSH
71013: LD_INT 0
71015: PUSH
71016: LD_INT 0
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 0
71025: PUSH
71026: LD_INT 1
71028: NEG
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PUSH
71034: LD_INT 1
71036: PUSH
71037: LD_INT 0
71039: PUSH
71040: EMPTY
71041: LIST
71042: LIST
71043: PUSH
71044: LD_INT 1
71046: PUSH
71047: LD_INT 1
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: PUSH
71054: LD_INT 0
71056: PUSH
71057: LD_INT 1
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: PUSH
71064: LD_INT 1
71066: NEG
71067: PUSH
71068: LD_INT 0
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: LD_INT 1
71077: NEG
71078: PUSH
71079: LD_INT 1
71081: NEG
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 1
71089: NEG
71090: PUSH
71091: LD_INT 2
71093: NEG
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: PUSH
71099: LD_INT 0
71101: PUSH
71102: LD_INT 2
71104: NEG
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: PUSH
71110: LD_INT 1
71112: PUSH
71113: LD_INT 1
71115: NEG
71116: PUSH
71117: EMPTY
71118: LIST
71119: LIST
71120: PUSH
71121: LD_INT 2
71123: PUSH
71124: LD_INT 1
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: PUSH
71131: LD_INT 2
71133: PUSH
71134: LD_INT 2
71136: PUSH
71137: EMPTY
71138: LIST
71139: LIST
71140: PUSH
71141: LD_INT 1
71143: PUSH
71144: LD_INT 2
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: LD_INT 1
71153: NEG
71154: PUSH
71155: LD_INT 1
71157: PUSH
71158: EMPTY
71159: LIST
71160: LIST
71161: PUSH
71162: LD_INT 2
71164: NEG
71165: PUSH
71166: LD_INT 0
71168: PUSH
71169: EMPTY
71170: LIST
71171: LIST
71172: PUSH
71173: LD_INT 2
71175: NEG
71176: PUSH
71177: LD_INT 1
71179: NEG
71180: PUSH
71181: EMPTY
71182: LIST
71183: LIST
71184: PUSH
71185: LD_INT 2
71187: NEG
71188: PUSH
71189: LD_INT 2
71191: NEG
71192: PUSH
71193: EMPTY
71194: LIST
71195: LIST
71196: PUSH
71197: LD_INT 1
71199: NEG
71200: PUSH
71201: LD_INT 3
71203: NEG
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: PUSH
71209: LD_INT 1
71211: PUSH
71212: LD_INT 2
71214: NEG
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 3
71222: PUSH
71223: LD_INT 2
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: PUSH
71230: LD_INT 2
71232: PUSH
71233: LD_INT 3
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: PUSH
71240: LD_INT 2
71242: NEG
71243: PUSH
71244: LD_INT 1
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 3
71253: NEG
71254: PUSH
71255: LD_INT 1
71257: NEG
71258: PUSH
71259: EMPTY
71260: LIST
71261: LIST
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: LIST
71279: LIST
71280: LIST
71281: LIST
71282: LIST
71283: LIST
71284: LIST
71285: LIST
71286: LIST
71287: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71288: LD_ADDR_VAR 0 35
71292: PUSH
71293: LD_INT 0
71295: PUSH
71296: LD_INT 0
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 0
71305: PUSH
71306: LD_INT 1
71308: NEG
71309: PUSH
71310: EMPTY
71311: LIST
71312: LIST
71313: PUSH
71314: LD_INT 1
71316: PUSH
71317: LD_INT 0
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: PUSH
71324: LD_INT 1
71326: PUSH
71327: LD_INT 1
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PUSH
71334: LD_INT 0
71336: PUSH
71337: LD_INT 1
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: LD_INT 1
71346: NEG
71347: PUSH
71348: LD_INT 0
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: LD_INT 1
71357: NEG
71358: PUSH
71359: LD_INT 1
71361: NEG
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 2
71369: PUSH
71370: LD_INT 1
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 2
71379: NEG
71380: PUSH
71381: LD_INT 1
71383: NEG
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: PUSH
71389: EMPTY
71390: LIST
71391: LIST
71392: LIST
71393: LIST
71394: LIST
71395: LIST
71396: LIST
71397: LIST
71398: LIST
71399: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71400: LD_ADDR_VAR 0 36
71404: PUSH
71405: LD_INT 0
71407: PUSH
71408: LD_INT 0
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: PUSH
71415: LD_INT 0
71417: PUSH
71418: LD_INT 1
71420: NEG
71421: PUSH
71422: EMPTY
71423: LIST
71424: LIST
71425: PUSH
71426: LD_INT 1
71428: PUSH
71429: LD_INT 0
71431: PUSH
71432: EMPTY
71433: LIST
71434: LIST
71435: PUSH
71436: LD_INT 1
71438: PUSH
71439: LD_INT 1
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: PUSH
71446: LD_INT 0
71448: PUSH
71449: LD_INT 1
71451: PUSH
71452: EMPTY
71453: LIST
71454: LIST
71455: PUSH
71456: LD_INT 1
71458: NEG
71459: PUSH
71460: LD_INT 0
71462: PUSH
71463: EMPTY
71464: LIST
71465: LIST
71466: PUSH
71467: LD_INT 1
71469: NEG
71470: PUSH
71471: LD_INT 1
71473: NEG
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: LD_INT 1
71481: NEG
71482: PUSH
71483: LD_INT 2
71485: NEG
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 1
71493: PUSH
71494: LD_INT 2
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: LIST
71505: LIST
71506: LIST
71507: LIST
71508: LIST
71509: LIST
71510: LIST
71511: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71512: LD_ADDR_VAR 0 37
71516: PUSH
71517: LD_INT 0
71519: PUSH
71520: LD_INT 0
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: PUSH
71527: LD_INT 0
71529: PUSH
71530: LD_INT 1
71532: NEG
71533: PUSH
71534: EMPTY
71535: LIST
71536: LIST
71537: PUSH
71538: LD_INT 1
71540: PUSH
71541: LD_INT 0
71543: PUSH
71544: EMPTY
71545: LIST
71546: LIST
71547: PUSH
71548: LD_INT 1
71550: PUSH
71551: LD_INT 1
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: PUSH
71558: LD_INT 0
71560: PUSH
71561: LD_INT 1
71563: PUSH
71564: EMPTY
71565: LIST
71566: LIST
71567: PUSH
71568: LD_INT 1
71570: NEG
71571: PUSH
71572: LD_INT 0
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PUSH
71579: LD_INT 1
71581: NEG
71582: PUSH
71583: LD_INT 1
71585: NEG
71586: PUSH
71587: EMPTY
71588: LIST
71589: LIST
71590: PUSH
71591: LD_INT 1
71593: PUSH
71594: LD_INT 1
71596: NEG
71597: PUSH
71598: EMPTY
71599: LIST
71600: LIST
71601: PUSH
71602: LD_INT 1
71604: NEG
71605: PUSH
71606: LD_INT 1
71608: PUSH
71609: EMPTY
71610: LIST
71611: LIST
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: LIST
71623: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71624: LD_ADDR_VAR 0 38
71628: PUSH
71629: LD_INT 0
71631: PUSH
71632: LD_INT 0
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: LD_INT 0
71641: PUSH
71642: LD_INT 1
71644: NEG
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: PUSH
71650: LD_INT 1
71652: PUSH
71653: LD_INT 0
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 1
71662: PUSH
71663: LD_INT 1
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 0
71672: PUSH
71673: LD_INT 1
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: LD_INT 1
71682: NEG
71683: PUSH
71684: LD_INT 0
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: PUSH
71691: LD_INT 1
71693: NEG
71694: PUSH
71695: LD_INT 1
71697: NEG
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 2
71705: PUSH
71706: LD_INT 1
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 2
71715: NEG
71716: PUSH
71717: LD_INT 1
71719: NEG
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: PUSH
71725: EMPTY
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: LIST
71734: LIST
71735: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71736: LD_ADDR_VAR 0 39
71740: PUSH
71741: LD_INT 0
71743: PUSH
71744: LD_INT 0
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: PUSH
71751: LD_INT 0
71753: PUSH
71754: LD_INT 1
71756: NEG
71757: PUSH
71758: EMPTY
71759: LIST
71760: LIST
71761: PUSH
71762: LD_INT 1
71764: PUSH
71765: LD_INT 0
71767: PUSH
71768: EMPTY
71769: LIST
71770: LIST
71771: PUSH
71772: LD_INT 1
71774: PUSH
71775: LD_INT 1
71777: PUSH
71778: EMPTY
71779: LIST
71780: LIST
71781: PUSH
71782: LD_INT 0
71784: PUSH
71785: LD_INT 1
71787: PUSH
71788: EMPTY
71789: LIST
71790: LIST
71791: PUSH
71792: LD_INT 1
71794: NEG
71795: PUSH
71796: LD_INT 0
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: PUSH
71803: LD_INT 1
71805: NEG
71806: PUSH
71807: LD_INT 1
71809: NEG
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: PUSH
71815: LD_INT 1
71817: NEG
71818: PUSH
71819: LD_INT 2
71821: NEG
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 1
71829: PUSH
71830: LD_INT 2
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: LIST
71841: LIST
71842: LIST
71843: LIST
71844: LIST
71845: LIST
71846: LIST
71847: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71848: LD_ADDR_VAR 0 40
71852: PUSH
71853: LD_INT 0
71855: PUSH
71856: LD_INT 0
71858: PUSH
71859: EMPTY
71860: LIST
71861: LIST
71862: PUSH
71863: LD_INT 0
71865: PUSH
71866: LD_INT 1
71868: NEG
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: PUSH
71874: LD_INT 1
71876: PUSH
71877: LD_INT 0
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 1
71886: PUSH
71887: LD_INT 1
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 0
71896: PUSH
71897: LD_INT 1
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 1
71906: NEG
71907: PUSH
71908: LD_INT 0
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: PUSH
71915: LD_INT 1
71917: NEG
71918: PUSH
71919: LD_INT 1
71921: NEG
71922: PUSH
71923: EMPTY
71924: LIST
71925: LIST
71926: PUSH
71927: LD_INT 1
71929: PUSH
71930: LD_INT 1
71932: NEG
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: PUSH
71938: LD_INT 1
71940: NEG
71941: PUSH
71942: LD_INT 1
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: LIST
71953: LIST
71954: LIST
71955: LIST
71956: LIST
71957: LIST
71958: LIST
71959: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71960: LD_ADDR_VAR 0 41
71964: PUSH
71965: LD_INT 0
71967: PUSH
71968: LD_INT 0
71970: PUSH
71971: EMPTY
71972: LIST
71973: LIST
71974: PUSH
71975: LD_INT 0
71977: PUSH
71978: LD_INT 1
71980: NEG
71981: PUSH
71982: EMPTY
71983: LIST
71984: LIST
71985: PUSH
71986: LD_INT 1
71988: PUSH
71989: LD_INT 0
71991: PUSH
71992: EMPTY
71993: LIST
71994: LIST
71995: PUSH
71996: LD_INT 1
71998: PUSH
71999: LD_INT 1
72001: PUSH
72002: EMPTY
72003: LIST
72004: LIST
72005: PUSH
72006: LD_INT 0
72008: PUSH
72009: LD_INT 1
72011: PUSH
72012: EMPTY
72013: LIST
72014: LIST
72015: PUSH
72016: LD_INT 1
72018: NEG
72019: PUSH
72020: LD_INT 0
72022: PUSH
72023: EMPTY
72024: LIST
72025: LIST
72026: PUSH
72027: LD_INT 1
72029: NEG
72030: PUSH
72031: LD_INT 1
72033: NEG
72034: PUSH
72035: EMPTY
72036: LIST
72037: LIST
72038: PUSH
72039: LD_INT 1
72041: NEG
72042: PUSH
72043: LD_INT 2
72045: NEG
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 1
72053: PUSH
72054: LD_INT 1
72056: NEG
72057: PUSH
72058: EMPTY
72059: LIST
72060: LIST
72061: PUSH
72062: LD_INT 2
72064: PUSH
72065: LD_INT 0
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PUSH
72072: LD_INT 2
72074: PUSH
72075: LD_INT 1
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: PUSH
72082: LD_INT 2
72084: PUSH
72085: LD_INT 2
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: PUSH
72092: LD_INT 1
72094: PUSH
72095: LD_INT 2
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: PUSH
72102: LD_INT 1
72104: NEG
72105: PUSH
72106: LD_INT 1
72108: PUSH
72109: EMPTY
72110: LIST
72111: LIST
72112: PUSH
72113: LD_INT 2
72115: NEG
72116: PUSH
72117: LD_INT 0
72119: PUSH
72120: EMPTY
72121: LIST
72122: LIST
72123: PUSH
72124: LD_INT 2
72126: NEG
72127: PUSH
72128: LD_INT 1
72130: NEG
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PUSH
72136: LD_INT 2
72138: NEG
72139: PUSH
72140: LD_INT 2
72142: NEG
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 2
72150: NEG
72151: PUSH
72152: LD_INT 3
72154: NEG
72155: PUSH
72156: EMPTY
72157: LIST
72158: LIST
72159: PUSH
72160: LD_INT 2
72162: PUSH
72163: LD_INT 1
72165: NEG
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: LD_INT 3
72173: PUSH
72174: LD_INT 0
72176: PUSH
72177: EMPTY
72178: LIST
72179: LIST
72180: PUSH
72181: LD_INT 3
72183: PUSH
72184: LD_INT 1
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: PUSH
72191: LD_INT 3
72193: PUSH
72194: LD_INT 2
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: PUSH
72201: LD_INT 3
72203: PUSH
72204: LD_INT 3
72206: PUSH
72207: EMPTY
72208: LIST
72209: LIST
72210: PUSH
72211: LD_INT 2
72213: PUSH
72214: LD_INT 3
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: PUSH
72221: LD_INT 2
72223: NEG
72224: PUSH
72225: LD_INT 1
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 3
72234: NEG
72235: PUSH
72236: LD_INT 0
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PUSH
72243: LD_INT 3
72245: NEG
72246: PUSH
72247: LD_INT 1
72249: NEG
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 3
72257: NEG
72258: PUSH
72259: LD_INT 2
72261: NEG
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 3
72269: NEG
72270: PUSH
72271: LD_INT 3
72273: NEG
72274: PUSH
72275: EMPTY
72276: LIST
72277: LIST
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: LIST
72283: LIST
72284: LIST
72285: LIST
72286: LIST
72287: LIST
72288: LIST
72289: LIST
72290: LIST
72291: LIST
72292: LIST
72293: LIST
72294: LIST
72295: LIST
72296: LIST
72297: LIST
72298: LIST
72299: LIST
72300: LIST
72301: LIST
72302: LIST
72303: LIST
72304: LIST
72305: LIST
72306: LIST
72307: LIST
72308: LIST
72309: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72310: LD_ADDR_VAR 0 42
72314: PUSH
72315: LD_INT 0
72317: PUSH
72318: LD_INT 0
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: LD_INT 0
72327: PUSH
72328: LD_INT 1
72330: NEG
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: PUSH
72336: LD_INT 1
72338: PUSH
72339: LD_INT 0
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: PUSH
72346: LD_INT 1
72348: PUSH
72349: LD_INT 1
72351: PUSH
72352: EMPTY
72353: LIST
72354: LIST
72355: PUSH
72356: LD_INT 0
72358: PUSH
72359: LD_INT 1
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 1
72368: NEG
72369: PUSH
72370: LD_INT 0
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 1
72379: NEG
72380: PUSH
72381: LD_INT 1
72383: NEG
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: LD_INT 1
72391: NEG
72392: PUSH
72393: LD_INT 2
72395: NEG
72396: PUSH
72397: EMPTY
72398: LIST
72399: LIST
72400: PUSH
72401: LD_INT 0
72403: PUSH
72404: LD_INT 2
72406: NEG
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PUSH
72412: LD_INT 1
72414: PUSH
72415: LD_INT 1
72417: NEG
72418: PUSH
72419: EMPTY
72420: LIST
72421: LIST
72422: PUSH
72423: LD_INT 2
72425: PUSH
72426: LD_INT 1
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: PUSH
72433: LD_INT 2
72435: PUSH
72436: LD_INT 2
72438: PUSH
72439: EMPTY
72440: LIST
72441: LIST
72442: PUSH
72443: LD_INT 1
72445: PUSH
72446: LD_INT 2
72448: PUSH
72449: EMPTY
72450: LIST
72451: LIST
72452: PUSH
72453: LD_INT 0
72455: PUSH
72456: LD_INT 2
72458: PUSH
72459: EMPTY
72460: LIST
72461: LIST
72462: PUSH
72463: LD_INT 1
72465: NEG
72466: PUSH
72467: LD_INT 1
72469: PUSH
72470: EMPTY
72471: LIST
72472: LIST
72473: PUSH
72474: LD_INT 2
72476: NEG
72477: PUSH
72478: LD_INT 1
72480: NEG
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: PUSH
72486: LD_INT 2
72488: NEG
72489: PUSH
72490: LD_INT 2
72492: NEG
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 2
72500: NEG
72501: PUSH
72502: LD_INT 3
72504: NEG
72505: PUSH
72506: EMPTY
72507: LIST
72508: LIST
72509: PUSH
72510: LD_INT 1
72512: NEG
72513: PUSH
72514: LD_INT 3
72516: NEG
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 0
72524: PUSH
72525: LD_INT 3
72527: NEG
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PUSH
72533: LD_INT 1
72535: PUSH
72536: LD_INT 2
72538: NEG
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 3
72546: PUSH
72547: LD_INT 2
72549: PUSH
72550: EMPTY
72551: LIST
72552: LIST
72553: PUSH
72554: LD_INT 3
72556: PUSH
72557: LD_INT 3
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: PUSH
72564: LD_INT 2
72566: PUSH
72567: LD_INT 3
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: LD_INT 1
72576: PUSH
72577: LD_INT 3
72579: PUSH
72580: EMPTY
72581: LIST
72582: LIST
72583: PUSH
72584: LD_INT 0
72586: PUSH
72587: LD_INT 3
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: PUSH
72594: LD_INT 1
72596: NEG
72597: PUSH
72598: LD_INT 2
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: PUSH
72605: LD_INT 3
72607: NEG
72608: PUSH
72609: LD_INT 2
72611: NEG
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: PUSH
72617: LD_INT 3
72619: NEG
72620: PUSH
72621: LD_INT 3
72623: NEG
72624: PUSH
72625: EMPTY
72626: LIST
72627: LIST
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: LIST
72633: LIST
72634: LIST
72635: LIST
72636: LIST
72637: LIST
72638: LIST
72639: LIST
72640: LIST
72641: LIST
72642: LIST
72643: LIST
72644: LIST
72645: LIST
72646: LIST
72647: LIST
72648: LIST
72649: LIST
72650: LIST
72651: LIST
72652: LIST
72653: LIST
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72660: LD_ADDR_VAR 0 43
72664: PUSH
72665: LD_INT 0
72667: PUSH
72668: LD_INT 0
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: PUSH
72675: LD_INT 0
72677: PUSH
72678: LD_INT 1
72680: NEG
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 1
72688: PUSH
72689: LD_INT 0
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 1
72698: PUSH
72699: LD_INT 1
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: PUSH
72706: LD_INT 0
72708: PUSH
72709: LD_INT 1
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: LD_INT 1
72718: NEG
72719: PUSH
72720: LD_INT 0
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 1
72729: NEG
72730: PUSH
72731: LD_INT 1
72733: NEG
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 1
72741: NEG
72742: PUSH
72743: LD_INT 2
72745: NEG
72746: PUSH
72747: EMPTY
72748: LIST
72749: LIST
72750: PUSH
72751: LD_INT 0
72753: PUSH
72754: LD_INT 2
72756: NEG
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: LD_INT 1
72764: PUSH
72765: LD_INT 1
72767: NEG
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: LD_INT 2
72775: PUSH
72776: LD_INT 0
72778: PUSH
72779: EMPTY
72780: LIST
72781: LIST
72782: PUSH
72783: LD_INT 2
72785: PUSH
72786: LD_INT 1
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: PUSH
72793: LD_INT 1
72795: PUSH
72796: LD_INT 2
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 0
72805: PUSH
72806: LD_INT 2
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: PUSH
72813: LD_INT 1
72815: NEG
72816: PUSH
72817: LD_INT 1
72819: PUSH
72820: EMPTY
72821: LIST
72822: LIST
72823: PUSH
72824: LD_INT 2
72826: NEG
72827: PUSH
72828: LD_INT 0
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PUSH
72835: LD_INT 2
72837: NEG
72838: PUSH
72839: LD_INT 1
72841: NEG
72842: PUSH
72843: EMPTY
72844: LIST
72845: LIST
72846: PUSH
72847: LD_INT 1
72849: NEG
72850: PUSH
72851: LD_INT 3
72853: NEG
72854: PUSH
72855: EMPTY
72856: LIST
72857: LIST
72858: PUSH
72859: LD_INT 0
72861: PUSH
72862: LD_INT 3
72864: NEG
72865: PUSH
72866: EMPTY
72867: LIST
72868: LIST
72869: PUSH
72870: LD_INT 1
72872: PUSH
72873: LD_INT 2
72875: NEG
72876: PUSH
72877: EMPTY
72878: LIST
72879: LIST
72880: PUSH
72881: LD_INT 2
72883: PUSH
72884: LD_INT 1
72886: NEG
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: LD_INT 3
72894: PUSH
72895: LD_INT 0
72897: PUSH
72898: EMPTY
72899: LIST
72900: LIST
72901: PUSH
72902: LD_INT 3
72904: PUSH
72905: LD_INT 1
72907: PUSH
72908: EMPTY
72909: LIST
72910: LIST
72911: PUSH
72912: LD_INT 1
72914: PUSH
72915: LD_INT 3
72917: PUSH
72918: EMPTY
72919: LIST
72920: LIST
72921: PUSH
72922: LD_INT 0
72924: PUSH
72925: LD_INT 3
72927: PUSH
72928: EMPTY
72929: LIST
72930: LIST
72931: PUSH
72932: LD_INT 1
72934: NEG
72935: PUSH
72936: LD_INT 2
72938: PUSH
72939: EMPTY
72940: LIST
72941: LIST
72942: PUSH
72943: LD_INT 2
72945: NEG
72946: PUSH
72947: LD_INT 1
72949: PUSH
72950: EMPTY
72951: LIST
72952: LIST
72953: PUSH
72954: LD_INT 3
72956: NEG
72957: PUSH
72958: LD_INT 0
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 3
72967: NEG
72968: PUSH
72969: LD_INT 1
72971: NEG
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: LIST
72981: LIST
72982: LIST
72983: LIST
72984: LIST
72985: LIST
72986: LIST
72987: LIST
72988: LIST
72989: LIST
72990: LIST
72991: LIST
72992: LIST
72993: LIST
72994: LIST
72995: LIST
72996: LIST
72997: LIST
72998: LIST
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73008: LD_ADDR_VAR 0 44
73012: PUSH
73013: LD_INT 0
73015: PUSH
73016: LD_INT 0
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: PUSH
73023: LD_INT 0
73025: PUSH
73026: LD_INT 1
73028: NEG
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: LD_INT 1
73036: PUSH
73037: LD_INT 0
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PUSH
73044: LD_INT 1
73046: PUSH
73047: LD_INT 1
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: PUSH
73054: LD_INT 0
73056: PUSH
73057: LD_INT 1
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: PUSH
73064: LD_INT 1
73066: NEG
73067: PUSH
73068: LD_INT 0
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 1
73077: NEG
73078: PUSH
73079: LD_INT 1
73081: NEG
73082: PUSH
73083: EMPTY
73084: LIST
73085: LIST
73086: PUSH
73087: LD_INT 1
73089: NEG
73090: PUSH
73091: LD_INT 2
73093: NEG
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PUSH
73099: LD_INT 1
73101: PUSH
73102: LD_INT 1
73104: NEG
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: LD_INT 2
73112: PUSH
73113: LD_INT 0
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: PUSH
73120: LD_INT 2
73122: PUSH
73123: LD_INT 1
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: PUSH
73130: LD_INT 2
73132: PUSH
73133: LD_INT 2
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: PUSH
73140: LD_INT 1
73142: PUSH
73143: LD_INT 2
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PUSH
73150: LD_INT 1
73152: NEG
73153: PUSH
73154: LD_INT 1
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: PUSH
73161: LD_INT 2
73163: NEG
73164: PUSH
73165: LD_INT 0
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 2
73174: NEG
73175: PUSH
73176: LD_INT 1
73178: NEG
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: LD_INT 2
73186: NEG
73187: PUSH
73188: LD_INT 2
73190: NEG
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: LD_INT 2
73198: NEG
73199: PUSH
73200: LD_INT 3
73202: NEG
73203: PUSH
73204: EMPTY
73205: LIST
73206: LIST
73207: PUSH
73208: LD_INT 2
73210: PUSH
73211: LD_INT 1
73213: NEG
73214: PUSH
73215: EMPTY
73216: LIST
73217: LIST
73218: PUSH
73219: LD_INT 3
73221: PUSH
73222: LD_INT 0
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: PUSH
73229: LD_INT 3
73231: PUSH
73232: LD_INT 1
73234: PUSH
73235: EMPTY
73236: LIST
73237: LIST
73238: PUSH
73239: LD_INT 3
73241: PUSH
73242: LD_INT 2
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: PUSH
73249: LD_INT 3
73251: PUSH
73252: LD_INT 3
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: PUSH
73259: LD_INT 2
73261: PUSH
73262: LD_INT 3
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: LD_INT 2
73271: NEG
73272: PUSH
73273: LD_INT 1
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: PUSH
73280: LD_INT 3
73282: NEG
73283: PUSH
73284: LD_INT 0
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: PUSH
73291: LD_INT 3
73293: NEG
73294: PUSH
73295: LD_INT 1
73297: NEG
73298: PUSH
73299: EMPTY
73300: LIST
73301: LIST
73302: PUSH
73303: LD_INT 3
73305: NEG
73306: PUSH
73307: LD_INT 2
73309: NEG
73310: PUSH
73311: EMPTY
73312: LIST
73313: LIST
73314: PUSH
73315: LD_INT 3
73317: NEG
73318: PUSH
73319: LD_INT 3
73321: NEG
73322: PUSH
73323: EMPTY
73324: LIST
73325: LIST
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: LIST
73331: LIST
73332: LIST
73333: LIST
73334: LIST
73335: LIST
73336: LIST
73337: LIST
73338: LIST
73339: LIST
73340: LIST
73341: LIST
73342: LIST
73343: LIST
73344: LIST
73345: LIST
73346: LIST
73347: LIST
73348: LIST
73349: LIST
73350: LIST
73351: LIST
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: LIST
73357: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73358: LD_ADDR_VAR 0 45
73362: PUSH
73363: LD_INT 0
73365: PUSH
73366: LD_INT 0
73368: PUSH
73369: EMPTY
73370: LIST
73371: LIST
73372: PUSH
73373: LD_INT 0
73375: PUSH
73376: LD_INT 1
73378: NEG
73379: PUSH
73380: EMPTY
73381: LIST
73382: LIST
73383: PUSH
73384: LD_INT 1
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: EMPTY
73391: LIST
73392: LIST
73393: PUSH
73394: LD_INT 1
73396: PUSH
73397: LD_INT 1
73399: PUSH
73400: EMPTY
73401: LIST
73402: LIST
73403: PUSH
73404: LD_INT 0
73406: PUSH
73407: LD_INT 1
73409: PUSH
73410: EMPTY
73411: LIST
73412: LIST
73413: PUSH
73414: LD_INT 1
73416: NEG
73417: PUSH
73418: LD_INT 0
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: PUSH
73425: LD_INT 1
73427: NEG
73428: PUSH
73429: LD_INT 1
73431: NEG
73432: PUSH
73433: EMPTY
73434: LIST
73435: LIST
73436: PUSH
73437: LD_INT 1
73439: NEG
73440: PUSH
73441: LD_INT 2
73443: NEG
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: LD_INT 0
73451: PUSH
73452: LD_INT 2
73454: NEG
73455: PUSH
73456: EMPTY
73457: LIST
73458: LIST
73459: PUSH
73460: LD_INT 1
73462: PUSH
73463: LD_INT 1
73465: NEG
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: PUSH
73471: LD_INT 2
73473: PUSH
73474: LD_INT 1
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 2
73483: PUSH
73484: LD_INT 2
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: PUSH
73491: LD_INT 1
73493: PUSH
73494: LD_INT 2
73496: PUSH
73497: EMPTY
73498: LIST
73499: LIST
73500: PUSH
73501: LD_INT 0
73503: PUSH
73504: LD_INT 2
73506: PUSH
73507: EMPTY
73508: LIST
73509: LIST
73510: PUSH
73511: LD_INT 1
73513: NEG
73514: PUSH
73515: LD_INT 1
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 2
73524: NEG
73525: PUSH
73526: LD_INT 1
73528: NEG
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 2
73536: NEG
73537: PUSH
73538: LD_INT 2
73540: NEG
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: PUSH
73546: LD_INT 2
73548: NEG
73549: PUSH
73550: LD_INT 3
73552: NEG
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: LD_INT 1
73560: NEG
73561: PUSH
73562: LD_INT 3
73564: NEG
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 0
73572: PUSH
73573: LD_INT 3
73575: NEG
73576: PUSH
73577: EMPTY
73578: LIST
73579: LIST
73580: PUSH
73581: LD_INT 1
73583: PUSH
73584: LD_INT 2
73586: NEG
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: PUSH
73592: LD_INT 3
73594: PUSH
73595: LD_INT 2
73597: PUSH
73598: EMPTY
73599: LIST
73600: LIST
73601: PUSH
73602: LD_INT 3
73604: PUSH
73605: LD_INT 3
73607: PUSH
73608: EMPTY
73609: LIST
73610: LIST
73611: PUSH
73612: LD_INT 2
73614: PUSH
73615: LD_INT 3
73617: PUSH
73618: EMPTY
73619: LIST
73620: LIST
73621: PUSH
73622: LD_INT 1
73624: PUSH
73625: LD_INT 3
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: PUSH
73632: LD_INT 0
73634: PUSH
73635: LD_INT 3
73637: PUSH
73638: EMPTY
73639: LIST
73640: LIST
73641: PUSH
73642: LD_INT 1
73644: NEG
73645: PUSH
73646: LD_INT 2
73648: PUSH
73649: EMPTY
73650: LIST
73651: LIST
73652: PUSH
73653: LD_INT 3
73655: NEG
73656: PUSH
73657: LD_INT 2
73659: NEG
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: PUSH
73665: LD_INT 3
73667: NEG
73668: PUSH
73669: LD_INT 3
73671: NEG
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: LIST
73681: LIST
73682: LIST
73683: LIST
73684: LIST
73685: LIST
73686: LIST
73687: LIST
73688: LIST
73689: LIST
73690: LIST
73691: LIST
73692: LIST
73693: LIST
73694: LIST
73695: LIST
73696: LIST
73697: LIST
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: LIST
73703: LIST
73704: LIST
73705: LIST
73706: LIST
73707: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73708: LD_ADDR_VAR 0 46
73712: PUSH
73713: LD_INT 0
73715: PUSH
73716: LD_INT 0
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 0
73725: PUSH
73726: LD_INT 1
73728: NEG
73729: PUSH
73730: EMPTY
73731: LIST
73732: LIST
73733: PUSH
73734: LD_INT 1
73736: PUSH
73737: LD_INT 0
73739: PUSH
73740: EMPTY
73741: LIST
73742: LIST
73743: PUSH
73744: LD_INT 1
73746: PUSH
73747: LD_INT 1
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: PUSH
73754: LD_INT 0
73756: PUSH
73757: LD_INT 1
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: LD_INT 1
73766: NEG
73767: PUSH
73768: LD_INT 0
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: PUSH
73775: LD_INT 1
73777: NEG
73778: PUSH
73779: LD_INT 1
73781: NEG
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: PUSH
73787: LD_INT 1
73789: NEG
73790: PUSH
73791: LD_INT 2
73793: NEG
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 0
73801: PUSH
73802: LD_INT 2
73804: NEG
73805: PUSH
73806: EMPTY
73807: LIST
73808: LIST
73809: PUSH
73810: LD_INT 1
73812: PUSH
73813: LD_INT 1
73815: NEG
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: PUSH
73821: LD_INT 2
73823: PUSH
73824: LD_INT 0
73826: PUSH
73827: EMPTY
73828: LIST
73829: LIST
73830: PUSH
73831: LD_INT 2
73833: PUSH
73834: LD_INT 1
73836: PUSH
73837: EMPTY
73838: LIST
73839: LIST
73840: PUSH
73841: LD_INT 1
73843: PUSH
73844: LD_INT 2
73846: PUSH
73847: EMPTY
73848: LIST
73849: LIST
73850: PUSH
73851: LD_INT 0
73853: PUSH
73854: LD_INT 2
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: PUSH
73861: LD_INT 1
73863: NEG
73864: PUSH
73865: LD_INT 1
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: LD_INT 2
73874: NEG
73875: PUSH
73876: LD_INT 0
73878: PUSH
73879: EMPTY
73880: LIST
73881: LIST
73882: PUSH
73883: LD_INT 2
73885: NEG
73886: PUSH
73887: LD_INT 1
73889: NEG
73890: PUSH
73891: EMPTY
73892: LIST
73893: LIST
73894: PUSH
73895: LD_INT 1
73897: NEG
73898: PUSH
73899: LD_INT 3
73901: NEG
73902: PUSH
73903: EMPTY
73904: LIST
73905: LIST
73906: PUSH
73907: LD_INT 0
73909: PUSH
73910: LD_INT 3
73912: NEG
73913: PUSH
73914: EMPTY
73915: LIST
73916: LIST
73917: PUSH
73918: LD_INT 1
73920: PUSH
73921: LD_INT 2
73923: NEG
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: PUSH
73929: LD_INT 2
73931: PUSH
73932: LD_INT 1
73934: NEG
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 3
73942: PUSH
73943: LD_INT 0
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 3
73952: PUSH
73953: LD_INT 1
73955: PUSH
73956: EMPTY
73957: LIST
73958: LIST
73959: PUSH
73960: LD_INT 1
73962: PUSH
73963: LD_INT 3
73965: PUSH
73966: EMPTY
73967: LIST
73968: LIST
73969: PUSH
73970: LD_INT 0
73972: PUSH
73973: LD_INT 3
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: PUSH
73980: LD_INT 1
73982: NEG
73983: PUSH
73984: LD_INT 2
73986: PUSH
73987: EMPTY
73988: LIST
73989: LIST
73990: PUSH
73991: LD_INT 2
73993: NEG
73994: PUSH
73995: LD_INT 1
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PUSH
74002: LD_INT 3
74004: NEG
74005: PUSH
74006: LD_INT 0
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: PUSH
74013: LD_INT 3
74015: NEG
74016: PUSH
74017: LD_INT 1
74019: NEG
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: LIST
74029: LIST
74030: LIST
74031: LIST
74032: LIST
74033: LIST
74034: LIST
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: LIST
74040: LIST
74041: LIST
74042: LIST
74043: LIST
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74056: LD_ADDR_VAR 0 47
74060: PUSH
74061: LD_INT 0
74063: PUSH
74064: LD_INT 0
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: PUSH
74071: LD_INT 0
74073: PUSH
74074: LD_INT 1
74076: NEG
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PUSH
74082: LD_INT 1
74084: PUSH
74085: LD_INT 0
74087: PUSH
74088: EMPTY
74089: LIST
74090: LIST
74091: PUSH
74092: LD_INT 1
74094: PUSH
74095: LD_INT 1
74097: PUSH
74098: EMPTY
74099: LIST
74100: LIST
74101: PUSH
74102: LD_INT 0
74104: PUSH
74105: LD_INT 1
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: PUSH
74112: LD_INT 1
74114: NEG
74115: PUSH
74116: LD_INT 0
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: LD_INT 1
74125: NEG
74126: PUSH
74127: LD_INT 1
74129: NEG
74130: PUSH
74131: EMPTY
74132: LIST
74133: LIST
74134: PUSH
74135: LD_INT 1
74137: NEG
74138: PUSH
74139: LD_INT 2
74141: NEG
74142: PUSH
74143: EMPTY
74144: LIST
74145: LIST
74146: PUSH
74147: LD_INT 0
74149: PUSH
74150: LD_INT 2
74152: NEG
74153: PUSH
74154: EMPTY
74155: LIST
74156: LIST
74157: PUSH
74158: LD_INT 1
74160: PUSH
74161: LD_INT 1
74163: NEG
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: PUSH
74169: LD_INT 2
74171: NEG
74172: PUSH
74173: LD_INT 1
74175: NEG
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: PUSH
74181: LD_INT 2
74183: NEG
74184: PUSH
74185: LD_INT 2
74187: NEG
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: LIST
74197: LIST
74198: LIST
74199: LIST
74200: LIST
74201: LIST
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74207: LD_ADDR_VAR 0 48
74211: PUSH
74212: LD_INT 0
74214: PUSH
74215: LD_INT 0
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 0
74224: PUSH
74225: LD_INT 1
74227: NEG
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: PUSH
74233: LD_INT 1
74235: PUSH
74236: LD_INT 0
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: PUSH
74243: LD_INT 1
74245: PUSH
74246: LD_INT 1
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 0
74255: PUSH
74256: LD_INT 1
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 1
74265: NEG
74266: PUSH
74267: LD_INT 0
74269: PUSH
74270: EMPTY
74271: LIST
74272: LIST
74273: PUSH
74274: LD_INT 1
74276: NEG
74277: PUSH
74278: LD_INT 1
74280: NEG
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 1
74288: NEG
74289: PUSH
74290: LD_INT 2
74292: NEG
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PUSH
74298: LD_INT 0
74300: PUSH
74301: LD_INT 2
74303: NEG
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: LD_INT 1
74311: PUSH
74312: LD_INT 1
74314: NEG
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: PUSH
74320: LD_INT 2
74322: PUSH
74323: LD_INT 0
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: PUSH
74330: LD_INT 2
74332: PUSH
74333: LD_INT 1
74335: PUSH
74336: EMPTY
74337: LIST
74338: LIST
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: LIST
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: LIST
74350: LIST
74351: LIST
74352: LIST
74353: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74354: LD_ADDR_VAR 0 49
74358: PUSH
74359: LD_INT 0
74361: PUSH
74362: LD_INT 0
74364: PUSH
74365: EMPTY
74366: LIST
74367: LIST
74368: PUSH
74369: LD_INT 0
74371: PUSH
74372: LD_INT 1
74374: NEG
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: PUSH
74380: LD_INT 1
74382: PUSH
74383: LD_INT 0
74385: PUSH
74386: EMPTY
74387: LIST
74388: LIST
74389: PUSH
74390: LD_INT 1
74392: PUSH
74393: LD_INT 1
74395: PUSH
74396: EMPTY
74397: LIST
74398: LIST
74399: PUSH
74400: LD_INT 0
74402: PUSH
74403: LD_INT 1
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: PUSH
74410: LD_INT 1
74412: NEG
74413: PUSH
74414: LD_INT 0
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: PUSH
74421: LD_INT 1
74423: NEG
74424: PUSH
74425: LD_INT 1
74427: NEG
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: PUSH
74433: LD_INT 1
74435: PUSH
74436: LD_INT 1
74438: NEG
74439: PUSH
74440: EMPTY
74441: LIST
74442: LIST
74443: PUSH
74444: LD_INT 2
74446: PUSH
74447: LD_INT 0
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: PUSH
74454: LD_INT 2
74456: PUSH
74457: LD_INT 1
74459: PUSH
74460: EMPTY
74461: LIST
74462: LIST
74463: PUSH
74464: LD_INT 2
74466: PUSH
74467: LD_INT 2
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: PUSH
74474: LD_INT 1
74476: PUSH
74477: LD_INT 2
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: LIST
74488: LIST
74489: LIST
74490: LIST
74491: LIST
74492: LIST
74493: LIST
74494: LIST
74495: LIST
74496: LIST
74497: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74498: LD_ADDR_VAR 0 50
74502: PUSH
74503: LD_INT 0
74505: PUSH
74506: LD_INT 0
74508: PUSH
74509: EMPTY
74510: LIST
74511: LIST
74512: PUSH
74513: LD_INT 0
74515: PUSH
74516: LD_INT 1
74518: NEG
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: PUSH
74524: LD_INT 1
74526: PUSH
74527: LD_INT 0
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 1
74536: PUSH
74537: LD_INT 1
74539: PUSH
74540: EMPTY
74541: LIST
74542: LIST
74543: PUSH
74544: LD_INT 0
74546: PUSH
74547: LD_INT 1
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 1
74556: NEG
74557: PUSH
74558: LD_INT 0
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: LD_INT 1
74567: NEG
74568: PUSH
74569: LD_INT 1
74571: NEG
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 2
74579: PUSH
74580: LD_INT 1
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: LD_INT 2
74589: PUSH
74590: LD_INT 2
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 1
74599: PUSH
74600: LD_INT 2
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: PUSH
74607: LD_INT 0
74609: PUSH
74610: LD_INT 2
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: PUSH
74617: LD_INT 1
74619: NEG
74620: PUSH
74621: LD_INT 1
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: EMPTY
74629: LIST
74630: LIST
74631: LIST
74632: LIST
74633: LIST
74634: LIST
74635: LIST
74636: LIST
74637: LIST
74638: LIST
74639: LIST
74640: LIST
74641: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74642: LD_ADDR_VAR 0 51
74646: PUSH
74647: LD_INT 0
74649: PUSH
74650: LD_INT 0
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: PUSH
74657: LD_INT 0
74659: PUSH
74660: LD_INT 1
74662: NEG
74663: PUSH
74664: EMPTY
74665: LIST
74666: LIST
74667: PUSH
74668: LD_INT 1
74670: PUSH
74671: LD_INT 0
74673: PUSH
74674: EMPTY
74675: LIST
74676: LIST
74677: PUSH
74678: LD_INT 1
74680: PUSH
74681: LD_INT 1
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PUSH
74688: LD_INT 0
74690: PUSH
74691: LD_INT 1
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: PUSH
74698: LD_INT 1
74700: NEG
74701: PUSH
74702: LD_INT 0
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: LD_INT 1
74711: NEG
74712: PUSH
74713: LD_INT 1
74715: NEG
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PUSH
74721: LD_INT 1
74723: PUSH
74724: LD_INT 2
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: PUSH
74731: LD_INT 0
74733: PUSH
74734: LD_INT 2
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 1
74743: NEG
74744: PUSH
74745: LD_INT 1
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PUSH
74752: LD_INT 2
74754: NEG
74755: PUSH
74756: LD_INT 0
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: PUSH
74763: LD_INT 2
74765: NEG
74766: PUSH
74767: LD_INT 1
74769: NEG
74770: PUSH
74771: EMPTY
74772: LIST
74773: LIST
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: LIST
74779: LIST
74780: LIST
74781: LIST
74782: LIST
74783: LIST
74784: LIST
74785: LIST
74786: LIST
74787: LIST
74788: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74789: LD_ADDR_VAR 0 52
74793: PUSH
74794: LD_INT 0
74796: PUSH
74797: LD_INT 0
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: PUSH
74804: LD_INT 0
74806: PUSH
74807: LD_INT 1
74809: NEG
74810: PUSH
74811: EMPTY
74812: LIST
74813: LIST
74814: PUSH
74815: LD_INT 1
74817: PUSH
74818: LD_INT 0
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: PUSH
74825: LD_INT 1
74827: PUSH
74828: LD_INT 1
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PUSH
74835: LD_INT 0
74837: PUSH
74838: LD_INT 1
74840: PUSH
74841: EMPTY
74842: LIST
74843: LIST
74844: PUSH
74845: LD_INT 1
74847: NEG
74848: PUSH
74849: LD_INT 0
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: PUSH
74856: LD_INT 1
74858: NEG
74859: PUSH
74860: LD_INT 1
74862: NEG
74863: PUSH
74864: EMPTY
74865: LIST
74866: LIST
74867: PUSH
74868: LD_INT 1
74870: NEG
74871: PUSH
74872: LD_INT 2
74874: NEG
74875: PUSH
74876: EMPTY
74877: LIST
74878: LIST
74879: PUSH
74880: LD_INT 1
74882: NEG
74883: PUSH
74884: LD_INT 1
74886: PUSH
74887: EMPTY
74888: LIST
74889: LIST
74890: PUSH
74891: LD_INT 2
74893: NEG
74894: PUSH
74895: LD_INT 0
74897: PUSH
74898: EMPTY
74899: LIST
74900: LIST
74901: PUSH
74902: LD_INT 2
74904: NEG
74905: PUSH
74906: LD_INT 1
74908: NEG
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: LD_INT 2
74916: NEG
74917: PUSH
74918: LD_INT 2
74920: NEG
74921: PUSH
74922: EMPTY
74923: LIST
74924: LIST
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: LIST
74930: LIST
74931: LIST
74932: LIST
74933: LIST
74934: LIST
74935: LIST
74936: LIST
74937: LIST
74938: LIST
74939: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74940: LD_ADDR_VAR 0 53
74944: PUSH
74945: LD_INT 0
74947: PUSH
74948: LD_INT 0
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 0
74957: PUSH
74958: LD_INT 1
74960: NEG
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 1
74968: PUSH
74969: LD_INT 0
74971: PUSH
74972: EMPTY
74973: LIST
74974: LIST
74975: PUSH
74976: LD_INT 1
74978: PUSH
74979: LD_INT 1
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: PUSH
74986: LD_INT 0
74988: PUSH
74989: LD_INT 1
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: LD_INT 1
74998: NEG
74999: PUSH
75000: LD_INT 0
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 1
75009: NEG
75010: PUSH
75011: LD_INT 1
75013: NEG
75014: PUSH
75015: EMPTY
75016: LIST
75017: LIST
75018: PUSH
75019: LD_INT 1
75021: NEG
75022: PUSH
75023: LD_INT 2
75025: NEG
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: PUSH
75031: LD_INT 0
75033: PUSH
75034: LD_INT 2
75036: NEG
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: PUSH
75042: LD_INT 1
75044: PUSH
75045: LD_INT 1
75047: NEG
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: LD_INT 2
75055: PUSH
75056: LD_INT 0
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: LD_INT 2
75065: PUSH
75066: LD_INT 1
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PUSH
75073: LD_INT 2
75075: PUSH
75076: LD_INT 2
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 1
75085: PUSH
75086: LD_INT 2
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 0
75095: PUSH
75096: LD_INT 2
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 1
75105: NEG
75106: PUSH
75107: LD_INT 1
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: PUSH
75114: LD_INT 2
75116: NEG
75117: PUSH
75118: LD_INT 0
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: LD_INT 2
75127: NEG
75128: PUSH
75129: LD_INT 1
75131: NEG
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PUSH
75137: LD_INT 2
75139: NEG
75140: PUSH
75141: LD_INT 2
75143: NEG
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: EMPTY
75150: LIST
75151: LIST
75152: LIST
75153: LIST
75154: LIST
75155: LIST
75156: LIST
75157: LIST
75158: LIST
75159: LIST
75160: LIST
75161: LIST
75162: LIST
75163: LIST
75164: LIST
75165: LIST
75166: LIST
75167: LIST
75168: LIST
75169: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75170: LD_ADDR_VAR 0 54
75174: PUSH
75175: LD_INT 0
75177: PUSH
75178: LD_INT 0
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: PUSH
75185: LD_INT 0
75187: PUSH
75188: LD_INT 1
75190: NEG
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 1
75198: PUSH
75199: LD_INT 0
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: PUSH
75206: LD_INT 1
75208: PUSH
75209: LD_INT 1
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 0
75218: PUSH
75219: LD_INT 1
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: PUSH
75226: LD_INT 1
75228: NEG
75229: PUSH
75230: LD_INT 0
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: PUSH
75237: LD_INT 1
75239: NEG
75240: PUSH
75241: LD_INT 1
75243: NEG
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 1
75251: NEG
75252: PUSH
75253: LD_INT 2
75255: NEG
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: LD_INT 0
75263: PUSH
75264: LD_INT 2
75266: NEG
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: LD_INT 1
75274: PUSH
75275: LD_INT 1
75277: NEG
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: PUSH
75283: LD_INT 2
75285: PUSH
75286: LD_INT 0
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: PUSH
75293: LD_INT 2
75295: PUSH
75296: LD_INT 1
75298: PUSH
75299: EMPTY
75300: LIST
75301: LIST
75302: PUSH
75303: LD_INT 2
75305: PUSH
75306: LD_INT 2
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: PUSH
75313: LD_INT 1
75315: PUSH
75316: LD_INT 2
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 0
75325: PUSH
75326: LD_INT 2
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: LD_INT 1
75335: NEG
75336: PUSH
75337: LD_INT 1
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: PUSH
75344: LD_INT 2
75346: NEG
75347: PUSH
75348: LD_INT 0
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 2
75357: NEG
75358: PUSH
75359: LD_INT 1
75361: NEG
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: LD_INT 2
75369: NEG
75370: PUSH
75371: LD_INT 2
75373: NEG
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: PUSH
75379: EMPTY
75380: LIST
75381: LIST
75382: LIST
75383: LIST
75384: LIST
75385: LIST
75386: LIST
75387: LIST
75388: LIST
75389: LIST
75390: LIST
75391: LIST
75392: LIST
75393: LIST
75394: LIST
75395: LIST
75396: LIST
75397: LIST
75398: LIST
75399: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75400: LD_ADDR_VAR 0 55
75404: PUSH
75405: LD_INT 0
75407: PUSH
75408: LD_INT 0
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: PUSH
75415: LD_INT 0
75417: PUSH
75418: LD_INT 1
75420: NEG
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 1
75428: PUSH
75429: LD_INT 0
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: PUSH
75436: LD_INT 1
75438: PUSH
75439: LD_INT 1
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: PUSH
75446: LD_INT 0
75448: PUSH
75449: LD_INT 1
75451: PUSH
75452: EMPTY
75453: LIST
75454: LIST
75455: PUSH
75456: LD_INT 1
75458: NEG
75459: PUSH
75460: LD_INT 0
75462: PUSH
75463: EMPTY
75464: LIST
75465: LIST
75466: PUSH
75467: LD_INT 1
75469: NEG
75470: PUSH
75471: LD_INT 1
75473: NEG
75474: PUSH
75475: EMPTY
75476: LIST
75477: LIST
75478: PUSH
75479: LD_INT 1
75481: NEG
75482: PUSH
75483: LD_INT 2
75485: NEG
75486: PUSH
75487: EMPTY
75488: LIST
75489: LIST
75490: PUSH
75491: LD_INT 0
75493: PUSH
75494: LD_INT 2
75496: NEG
75497: PUSH
75498: EMPTY
75499: LIST
75500: LIST
75501: PUSH
75502: LD_INT 1
75504: PUSH
75505: LD_INT 1
75507: NEG
75508: PUSH
75509: EMPTY
75510: LIST
75511: LIST
75512: PUSH
75513: LD_INT 2
75515: PUSH
75516: LD_INT 0
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: PUSH
75523: LD_INT 2
75525: PUSH
75526: LD_INT 1
75528: PUSH
75529: EMPTY
75530: LIST
75531: LIST
75532: PUSH
75533: LD_INT 2
75535: PUSH
75536: LD_INT 2
75538: PUSH
75539: EMPTY
75540: LIST
75541: LIST
75542: PUSH
75543: LD_INT 1
75545: PUSH
75546: LD_INT 2
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: PUSH
75553: LD_INT 0
75555: PUSH
75556: LD_INT 2
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: PUSH
75563: LD_INT 1
75565: NEG
75566: PUSH
75567: LD_INT 1
75569: PUSH
75570: EMPTY
75571: LIST
75572: LIST
75573: PUSH
75574: LD_INT 2
75576: NEG
75577: PUSH
75578: LD_INT 0
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: LD_INT 2
75587: NEG
75588: PUSH
75589: LD_INT 1
75591: NEG
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PUSH
75597: LD_INT 2
75599: NEG
75600: PUSH
75601: LD_INT 2
75603: NEG
75604: PUSH
75605: EMPTY
75606: LIST
75607: LIST
75608: PUSH
75609: EMPTY
75610: LIST
75611: LIST
75612: LIST
75613: LIST
75614: LIST
75615: LIST
75616: LIST
75617: LIST
75618: LIST
75619: LIST
75620: LIST
75621: LIST
75622: LIST
75623: LIST
75624: LIST
75625: LIST
75626: LIST
75627: LIST
75628: LIST
75629: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75630: LD_ADDR_VAR 0 56
75634: PUSH
75635: LD_INT 0
75637: PUSH
75638: LD_INT 0
75640: PUSH
75641: EMPTY
75642: LIST
75643: LIST
75644: PUSH
75645: LD_INT 0
75647: PUSH
75648: LD_INT 1
75650: NEG
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: PUSH
75656: LD_INT 1
75658: PUSH
75659: LD_INT 0
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: PUSH
75666: LD_INT 1
75668: PUSH
75669: LD_INT 1
75671: PUSH
75672: EMPTY
75673: LIST
75674: LIST
75675: PUSH
75676: LD_INT 0
75678: PUSH
75679: LD_INT 1
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: LD_INT 1
75688: NEG
75689: PUSH
75690: LD_INT 0
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PUSH
75697: LD_INT 1
75699: NEG
75700: PUSH
75701: LD_INT 1
75703: NEG
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: LD_INT 1
75711: NEG
75712: PUSH
75713: LD_INT 2
75715: NEG
75716: PUSH
75717: EMPTY
75718: LIST
75719: LIST
75720: PUSH
75721: LD_INT 0
75723: PUSH
75724: LD_INT 2
75726: NEG
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: LD_INT 1
75734: PUSH
75735: LD_INT 1
75737: NEG
75738: PUSH
75739: EMPTY
75740: LIST
75741: LIST
75742: PUSH
75743: LD_INT 2
75745: PUSH
75746: LD_INT 0
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: LD_INT 2
75755: PUSH
75756: LD_INT 1
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 2
75765: PUSH
75766: LD_INT 2
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PUSH
75773: LD_INT 1
75775: PUSH
75776: LD_INT 2
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 0
75785: PUSH
75786: LD_INT 2
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: PUSH
75793: LD_INT 1
75795: NEG
75796: PUSH
75797: LD_INT 1
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PUSH
75804: LD_INT 2
75806: NEG
75807: PUSH
75808: LD_INT 0
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 2
75817: NEG
75818: PUSH
75819: LD_INT 1
75821: NEG
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: LD_INT 2
75829: NEG
75830: PUSH
75831: LD_INT 2
75833: NEG
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: EMPTY
75840: LIST
75841: LIST
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: LIST
75847: LIST
75848: LIST
75849: LIST
75850: LIST
75851: LIST
75852: LIST
75853: LIST
75854: LIST
75855: LIST
75856: LIST
75857: LIST
75858: LIST
75859: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75860: LD_ADDR_VAR 0 57
75864: PUSH
75865: LD_INT 0
75867: PUSH
75868: LD_INT 0
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: PUSH
75875: LD_INT 0
75877: PUSH
75878: LD_INT 1
75880: NEG
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PUSH
75886: LD_INT 1
75888: PUSH
75889: LD_INT 0
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: LD_INT 1
75898: PUSH
75899: LD_INT 1
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: LD_INT 0
75908: PUSH
75909: LD_INT 1
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: PUSH
75916: LD_INT 1
75918: NEG
75919: PUSH
75920: LD_INT 0
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: PUSH
75927: LD_INT 1
75929: NEG
75930: PUSH
75931: LD_INT 1
75933: NEG
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: PUSH
75939: LD_INT 1
75941: NEG
75942: PUSH
75943: LD_INT 2
75945: NEG
75946: PUSH
75947: EMPTY
75948: LIST
75949: LIST
75950: PUSH
75951: LD_INT 0
75953: PUSH
75954: LD_INT 2
75956: NEG
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: PUSH
75962: LD_INT 1
75964: PUSH
75965: LD_INT 1
75967: NEG
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: PUSH
75973: LD_INT 2
75975: PUSH
75976: LD_INT 0
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: PUSH
75983: LD_INT 2
75985: PUSH
75986: LD_INT 1
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: PUSH
75993: LD_INT 2
75995: PUSH
75996: LD_INT 2
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: PUSH
76003: LD_INT 1
76005: PUSH
76006: LD_INT 2
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 0
76015: PUSH
76016: LD_INT 2
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 1
76025: NEG
76026: PUSH
76027: LD_INT 1
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PUSH
76034: LD_INT 2
76036: NEG
76037: PUSH
76038: LD_INT 0
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: LD_INT 2
76047: NEG
76048: PUSH
76049: LD_INT 1
76051: NEG
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: PUSH
76057: LD_INT 2
76059: NEG
76060: PUSH
76061: LD_INT 2
76063: NEG
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: LIST
76077: LIST
76078: LIST
76079: LIST
76080: LIST
76081: LIST
76082: LIST
76083: LIST
76084: LIST
76085: LIST
76086: LIST
76087: LIST
76088: LIST
76089: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76090: LD_ADDR_VAR 0 58
76094: PUSH
76095: LD_INT 0
76097: PUSH
76098: LD_INT 0
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 0
76107: PUSH
76108: LD_INT 1
76110: NEG
76111: PUSH
76112: EMPTY
76113: LIST
76114: LIST
76115: PUSH
76116: LD_INT 1
76118: PUSH
76119: LD_INT 0
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: PUSH
76126: LD_INT 1
76128: PUSH
76129: LD_INT 1
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: LD_INT 0
76138: PUSH
76139: LD_INT 1
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: LD_INT 1
76148: NEG
76149: PUSH
76150: LD_INT 0
76152: PUSH
76153: EMPTY
76154: LIST
76155: LIST
76156: PUSH
76157: LD_INT 1
76159: NEG
76160: PUSH
76161: LD_INT 1
76163: NEG
76164: PUSH
76165: EMPTY
76166: LIST
76167: LIST
76168: PUSH
76169: LD_INT 1
76171: NEG
76172: PUSH
76173: LD_INT 2
76175: NEG
76176: PUSH
76177: EMPTY
76178: LIST
76179: LIST
76180: PUSH
76181: LD_INT 0
76183: PUSH
76184: LD_INT 2
76186: NEG
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PUSH
76192: LD_INT 1
76194: PUSH
76195: LD_INT 1
76197: NEG
76198: PUSH
76199: EMPTY
76200: LIST
76201: LIST
76202: PUSH
76203: LD_INT 2
76205: PUSH
76206: LD_INT 0
76208: PUSH
76209: EMPTY
76210: LIST
76211: LIST
76212: PUSH
76213: LD_INT 2
76215: PUSH
76216: LD_INT 1
76218: PUSH
76219: EMPTY
76220: LIST
76221: LIST
76222: PUSH
76223: LD_INT 2
76225: PUSH
76226: LD_INT 2
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: PUSH
76233: LD_INT 1
76235: PUSH
76236: LD_INT 2
76238: PUSH
76239: EMPTY
76240: LIST
76241: LIST
76242: PUSH
76243: LD_INT 0
76245: PUSH
76246: LD_INT 2
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: LD_INT 1
76255: NEG
76256: PUSH
76257: LD_INT 1
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: PUSH
76264: LD_INT 2
76266: NEG
76267: PUSH
76268: LD_INT 0
76270: PUSH
76271: EMPTY
76272: LIST
76273: LIST
76274: PUSH
76275: LD_INT 2
76277: NEG
76278: PUSH
76279: LD_INT 1
76281: NEG
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 2
76289: NEG
76290: PUSH
76291: LD_INT 2
76293: NEG
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: LIST
76303: LIST
76304: LIST
76305: LIST
76306: LIST
76307: LIST
76308: LIST
76309: LIST
76310: LIST
76311: LIST
76312: LIST
76313: LIST
76314: LIST
76315: LIST
76316: LIST
76317: LIST
76318: LIST
76319: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76320: LD_ADDR_VAR 0 59
76324: PUSH
76325: LD_INT 0
76327: PUSH
76328: LD_INT 0
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: LD_INT 0
76337: PUSH
76338: LD_INT 1
76340: NEG
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PUSH
76346: LD_INT 1
76348: PUSH
76349: LD_INT 0
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: LD_INT 1
76358: PUSH
76359: LD_INT 1
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: LD_INT 0
76368: PUSH
76369: LD_INT 1
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 1
76378: NEG
76379: PUSH
76380: LD_INT 0
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: LD_INT 1
76389: NEG
76390: PUSH
76391: LD_INT 1
76393: NEG
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: LIST
76403: LIST
76404: LIST
76405: LIST
76406: LIST
76407: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76408: LD_ADDR_VAR 0 60
76412: PUSH
76413: LD_INT 0
76415: PUSH
76416: LD_INT 0
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: LD_INT 0
76425: PUSH
76426: LD_INT 1
76428: NEG
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: PUSH
76434: LD_INT 1
76436: PUSH
76437: LD_INT 0
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: LD_INT 1
76446: PUSH
76447: LD_INT 1
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: LD_INT 0
76456: PUSH
76457: LD_INT 1
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: PUSH
76464: LD_INT 1
76466: NEG
76467: PUSH
76468: LD_INT 0
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: PUSH
76475: LD_INT 1
76477: NEG
76478: PUSH
76479: LD_INT 1
76481: NEG
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: LIST
76493: LIST
76494: LIST
76495: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76496: LD_ADDR_VAR 0 61
76500: PUSH
76501: LD_INT 0
76503: PUSH
76504: LD_INT 0
76506: PUSH
76507: EMPTY
76508: LIST
76509: LIST
76510: PUSH
76511: LD_INT 0
76513: PUSH
76514: LD_INT 1
76516: NEG
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: PUSH
76522: LD_INT 1
76524: PUSH
76525: LD_INT 0
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: PUSH
76532: LD_INT 1
76534: PUSH
76535: LD_INT 1
76537: PUSH
76538: EMPTY
76539: LIST
76540: LIST
76541: PUSH
76542: LD_INT 0
76544: PUSH
76545: LD_INT 1
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_INT 1
76554: NEG
76555: PUSH
76556: LD_INT 0
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 1
76565: NEG
76566: PUSH
76567: LD_INT 1
76569: NEG
76570: PUSH
76571: EMPTY
76572: LIST
76573: LIST
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: LIST
76579: LIST
76580: LIST
76581: LIST
76582: LIST
76583: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76584: LD_ADDR_VAR 0 62
76588: PUSH
76589: LD_INT 0
76591: PUSH
76592: LD_INT 0
76594: PUSH
76595: EMPTY
76596: LIST
76597: LIST
76598: PUSH
76599: LD_INT 0
76601: PUSH
76602: LD_INT 1
76604: NEG
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 1
76612: PUSH
76613: LD_INT 0
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PUSH
76620: LD_INT 1
76622: PUSH
76623: LD_INT 1
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: PUSH
76630: LD_INT 0
76632: PUSH
76633: LD_INT 1
76635: PUSH
76636: EMPTY
76637: LIST
76638: LIST
76639: PUSH
76640: LD_INT 1
76642: NEG
76643: PUSH
76644: LD_INT 0
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: PUSH
76651: LD_INT 1
76653: NEG
76654: PUSH
76655: LD_INT 1
76657: NEG
76658: PUSH
76659: EMPTY
76660: LIST
76661: LIST
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: LIST
76667: LIST
76668: LIST
76669: LIST
76670: LIST
76671: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76672: LD_ADDR_VAR 0 63
76676: PUSH
76677: LD_INT 0
76679: PUSH
76680: LD_INT 0
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 0
76689: PUSH
76690: LD_INT 1
76692: NEG
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PUSH
76698: LD_INT 1
76700: PUSH
76701: LD_INT 0
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 1
76710: PUSH
76711: LD_INT 1
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PUSH
76718: LD_INT 0
76720: PUSH
76721: LD_INT 1
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: LD_INT 1
76730: NEG
76731: PUSH
76732: LD_INT 0
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 1
76741: NEG
76742: PUSH
76743: LD_INT 1
76745: NEG
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76760: LD_ADDR_VAR 0 64
76764: PUSH
76765: LD_INT 0
76767: PUSH
76768: LD_INT 0
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 0
76777: PUSH
76778: LD_INT 1
76780: NEG
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 1
76788: PUSH
76789: LD_INT 0
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 1
76798: PUSH
76799: LD_INT 1
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: LD_INT 0
76808: PUSH
76809: LD_INT 1
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 1
76818: NEG
76819: PUSH
76820: LD_INT 0
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 1
76829: NEG
76830: PUSH
76831: LD_INT 1
76833: NEG
76834: PUSH
76835: EMPTY
76836: LIST
76837: LIST
76838: PUSH
76839: EMPTY
76840: LIST
76841: LIST
76842: LIST
76843: LIST
76844: LIST
76845: LIST
76846: LIST
76847: ST_TO_ADDR
// end ; 1 :
76848: GO 82745
76850: LD_INT 1
76852: DOUBLE
76853: EQUAL
76854: IFTRUE 76858
76856: GO 79481
76858: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76859: LD_ADDR_VAR 0 11
76863: PUSH
76864: LD_INT 1
76866: NEG
76867: PUSH
76868: LD_INT 3
76870: NEG
76871: PUSH
76872: EMPTY
76873: LIST
76874: LIST
76875: PUSH
76876: LD_INT 0
76878: PUSH
76879: LD_INT 3
76881: NEG
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PUSH
76887: LD_INT 1
76889: PUSH
76890: LD_INT 2
76892: NEG
76893: PUSH
76894: EMPTY
76895: LIST
76896: LIST
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: LIST
76902: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76903: LD_ADDR_VAR 0 12
76907: PUSH
76908: LD_INT 2
76910: PUSH
76911: LD_INT 1
76913: NEG
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: LD_INT 3
76921: PUSH
76922: LD_INT 0
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: LD_INT 3
76931: PUSH
76932: LD_INT 1
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: LIST
76943: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76944: LD_ADDR_VAR 0 13
76948: PUSH
76949: LD_INT 3
76951: PUSH
76952: LD_INT 2
76954: PUSH
76955: EMPTY
76956: LIST
76957: LIST
76958: PUSH
76959: LD_INT 3
76961: PUSH
76962: LD_INT 3
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 2
76971: PUSH
76972: LD_INT 3
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: LIST
76983: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76984: LD_ADDR_VAR 0 14
76988: PUSH
76989: LD_INT 1
76991: PUSH
76992: LD_INT 3
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: PUSH
76999: LD_INT 0
77001: PUSH
77002: LD_INT 3
77004: PUSH
77005: EMPTY
77006: LIST
77007: LIST
77008: PUSH
77009: LD_INT 1
77011: NEG
77012: PUSH
77013: LD_INT 2
77015: PUSH
77016: EMPTY
77017: LIST
77018: LIST
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: LIST
77024: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77025: LD_ADDR_VAR 0 15
77029: PUSH
77030: LD_INT 2
77032: NEG
77033: PUSH
77034: LD_INT 1
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: LD_INT 3
77043: NEG
77044: PUSH
77045: LD_INT 0
77047: PUSH
77048: EMPTY
77049: LIST
77050: LIST
77051: PUSH
77052: LD_INT 3
77054: NEG
77055: PUSH
77056: LD_INT 1
77058: NEG
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: LIST
77068: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77069: LD_ADDR_VAR 0 16
77073: PUSH
77074: LD_INT 2
77076: NEG
77077: PUSH
77078: LD_INT 3
77080: NEG
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: PUSH
77086: LD_INT 3
77088: NEG
77089: PUSH
77090: LD_INT 2
77092: NEG
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: PUSH
77098: LD_INT 3
77100: NEG
77101: PUSH
77102: LD_INT 3
77104: NEG
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: LIST
77114: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77115: LD_ADDR_VAR 0 17
77119: PUSH
77120: LD_INT 1
77122: NEG
77123: PUSH
77124: LD_INT 3
77126: NEG
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: PUSH
77132: LD_INT 0
77134: PUSH
77135: LD_INT 3
77137: NEG
77138: PUSH
77139: EMPTY
77140: LIST
77141: LIST
77142: PUSH
77143: LD_INT 1
77145: PUSH
77146: LD_INT 2
77148: NEG
77149: PUSH
77150: EMPTY
77151: LIST
77152: LIST
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: LIST
77158: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77159: LD_ADDR_VAR 0 18
77163: PUSH
77164: LD_INT 2
77166: PUSH
77167: LD_INT 1
77169: NEG
77170: PUSH
77171: EMPTY
77172: LIST
77173: LIST
77174: PUSH
77175: LD_INT 3
77177: PUSH
77178: LD_INT 0
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: PUSH
77185: LD_INT 3
77187: PUSH
77188: LD_INT 1
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: LIST
77199: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77200: LD_ADDR_VAR 0 19
77204: PUSH
77205: LD_INT 3
77207: PUSH
77208: LD_INT 2
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 3
77217: PUSH
77218: LD_INT 3
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 2
77227: PUSH
77228: LD_INT 3
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: EMPTY
77236: LIST
77237: LIST
77238: LIST
77239: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77240: LD_ADDR_VAR 0 20
77244: PUSH
77245: LD_INT 1
77247: PUSH
77248: LD_INT 3
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: PUSH
77255: LD_INT 0
77257: PUSH
77258: LD_INT 3
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 1
77267: NEG
77268: PUSH
77269: LD_INT 2
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: EMPTY
77277: LIST
77278: LIST
77279: LIST
77280: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77281: LD_ADDR_VAR 0 21
77285: PUSH
77286: LD_INT 2
77288: NEG
77289: PUSH
77290: LD_INT 1
77292: PUSH
77293: EMPTY
77294: LIST
77295: LIST
77296: PUSH
77297: LD_INT 3
77299: NEG
77300: PUSH
77301: LD_INT 0
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 3
77310: NEG
77311: PUSH
77312: LD_INT 1
77314: NEG
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: PUSH
77320: EMPTY
77321: LIST
77322: LIST
77323: LIST
77324: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77325: LD_ADDR_VAR 0 22
77329: PUSH
77330: LD_INT 2
77332: NEG
77333: PUSH
77334: LD_INT 3
77336: NEG
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: LD_INT 3
77344: NEG
77345: PUSH
77346: LD_INT 2
77348: NEG
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: PUSH
77354: LD_INT 3
77356: NEG
77357: PUSH
77358: LD_INT 3
77360: NEG
77361: PUSH
77362: EMPTY
77363: LIST
77364: LIST
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: LIST
77370: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
77371: LD_ADDR_VAR 0 23
77375: PUSH
77376: LD_INT 0
77378: PUSH
77379: LD_INT 3
77381: NEG
77382: PUSH
77383: EMPTY
77384: LIST
77385: LIST
77386: PUSH
77387: LD_INT 1
77389: NEG
77390: PUSH
77391: LD_INT 4
77393: NEG
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: PUSH
77399: LD_INT 1
77401: PUSH
77402: LD_INT 3
77404: NEG
77405: PUSH
77406: EMPTY
77407: LIST
77408: LIST
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: LIST
77414: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
77415: LD_ADDR_VAR 0 24
77419: PUSH
77420: LD_INT 3
77422: PUSH
77423: LD_INT 0
77425: PUSH
77426: EMPTY
77427: LIST
77428: LIST
77429: PUSH
77430: LD_INT 3
77432: PUSH
77433: LD_INT 1
77435: NEG
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: LD_INT 4
77443: PUSH
77444: LD_INT 1
77446: PUSH
77447: EMPTY
77448: LIST
77449: LIST
77450: PUSH
77451: EMPTY
77452: LIST
77453: LIST
77454: LIST
77455: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
77456: LD_ADDR_VAR 0 25
77460: PUSH
77461: LD_INT 3
77463: PUSH
77464: LD_INT 3
77466: PUSH
77467: EMPTY
77468: LIST
77469: LIST
77470: PUSH
77471: LD_INT 4
77473: PUSH
77474: LD_INT 3
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 3
77483: PUSH
77484: LD_INT 4
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: LIST
77495: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
77496: LD_ADDR_VAR 0 26
77500: PUSH
77501: LD_INT 0
77503: PUSH
77504: LD_INT 3
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 1
77513: PUSH
77514: LD_INT 4
77516: PUSH
77517: EMPTY
77518: LIST
77519: LIST
77520: PUSH
77521: LD_INT 1
77523: NEG
77524: PUSH
77525: LD_INT 3
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: LIST
77536: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
77537: LD_ADDR_VAR 0 27
77541: PUSH
77542: LD_INT 3
77544: NEG
77545: PUSH
77546: LD_INT 0
77548: PUSH
77549: EMPTY
77550: LIST
77551: LIST
77552: PUSH
77553: LD_INT 3
77555: NEG
77556: PUSH
77557: LD_INT 1
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: LD_INT 4
77566: NEG
77567: PUSH
77568: LD_INT 1
77570: NEG
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: PUSH
77576: EMPTY
77577: LIST
77578: LIST
77579: LIST
77580: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
77581: LD_ADDR_VAR 0 28
77585: PUSH
77586: LD_INT 3
77588: NEG
77589: PUSH
77590: LD_INT 3
77592: NEG
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 3
77600: NEG
77601: PUSH
77602: LD_INT 4
77604: NEG
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: LD_INT 4
77612: NEG
77613: PUSH
77614: LD_INT 3
77616: NEG
77617: PUSH
77618: EMPTY
77619: LIST
77620: LIST
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: LIST
77626: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77627: LD_ADDR_VAR 0 29
77631: PUSH
77632: LD_INT 1
77634: NEG
77635: PUSH
77636: LD_INT 3
77638: NEG
77639: PUSH
77640: EMPTY
77641: LIST
77642: LIST
77643: PUSH
77644: LD_INT 0
77646: PUSH
77647: LD_INT 3
77649: NEG
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: PUSH
77655: LD_INT 1
77657: PUSH
77658: LD_INT 2
77660: NEG
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: LD_INT 1
77668: NEG
77669: PUSH
77670: LD_INT 4
77672: NEG
77673: PUSH
77674: EMPTY
77675: LIST
77676: LIST
77677: PUSH
77678: LD_INT 0
77680: PUSH
77681: LD_INT 4
77683: NEG
77684: PUSH
77685: EMPTY
77686: LIST
77687: LIST
77688: PUSH
77689: LD_INT 1
77691: PUSH
77692: LD_INT 3
77694: NEG
77695: PUSH
77696: EMPTY
77697: LIST
77698: LIST
77699: PUSH
77700: LD_INT 1
77702: NEG
77703: PUSH
77704: LD_INT 5
77706: NEG
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: LD_INT 0
77714: PUSH
77715: LD_INT 5
77717: NEG
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: PUSH
77723: LD_INT 1
77725: PUSH
77726: LD_INT 4
77728: NEG
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PUSH
77734: LD_INT 1
77736: NEG
77737: PUSH
77738: LD_INT 6
77740: NEG
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: PUSH
77746: LD_INT 0
77748: PUSH
77749: LD_INT 6
77751: NEG
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PUSH
77757: LD_INT 1
77759: PUSH
77760: LD_INT 5
77762: NEG
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: LIST
77772: LIST
77773: LIST
77774: LIST
77775: LIST
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: LIST
77781: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
77782: LD_ADDR_VAR 0 30
77786: PUSH
77787: LD_INT 2
77789: PUSH
77790: LD_INT 1
77792: NEG
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: PUSH
77798: LD_INT 3
77800: PUSH
77801: LD_INT 0
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: LD_INT 3
77810: PUSH
77811: LD_INT 1
77813: PUSH
77814: EMPTY
77815: LIST
77816: LIST
77817: PUSH
77818: LD_INT 3
77820: PUSH
77821: LD_INT 1
77823: NEG
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: LD_INT 4
77831: PUSH
77832: LD_INT 0
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: PUSH
77839: LD_INT 4
77841: PUSH
77842: LD_INT 1
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 4
77851: PUSH
77852: LD_INT 1
77854: NEG
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PUSH
77860: LD_INT 5
77862: PUSH
77863: LD_INT 0
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: PUSH
77870: LD_INT 5
77872: PUSH
77873: LD_INT 1
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: PUSH
77880: LD_INT 5
77882: PUSH
77883: LD_INT 1
77885: NEG
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: PUSH
77891: LD_INT 6
77893: PUSH
77894: LD_INT 0
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PUSH
77901: LD_INT 6
77903: PUSH
77904: LD_INT 1
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: LIST
77915: LIST
77916: LIST
77917: LIST
77918: LIST
77919: LIST
77920: LIST
77921: LIST
77922: LIST
77923: LIST
77924: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
77925: LD_ADDR_VAR 0 31
77929: PUSH
77930: LD_INT 3
77932: PUSH
77933: LD_INT 2
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 3
77942: PUSH
77943: LD_INT 3
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: LD_INT 2
77952: PUSH
77953: LD_INT 3
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: PUSH
77960: LD_INT 4
77962: PUSH
77963: LD_INT 3
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: PUSH
77970: LD_INT 4
77972: PUSH
77973: LD_INT 4
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: PUSH
77980: LD_INT 3
77982: PUSH
77983: LD_INT 4
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: LD_INT 5
77992: PUSH
77993: LD_INT 4
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 5
78002: PUSH
78003: LD_INT 5
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: PUSH
78010: LD_INT 4
78012: PUSH
78013: LD_INT 5
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 6
78022: PUSH
78023: LD_INT 5
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: LD_INT 6
78032: PUSH
78033: LD_INT 6
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: LD_INT 5
78042: PUSH
78043: LD_INT 6
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: LIST
78054: LIST
78055: LIST
78056: LIST
78057: LIST
78058: LIST
78059: LIST
78060: LIST
78061: LIST
78062: LIST
78063: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78064: LD_ADDR_VAR 0 32
78068: PUSH
78069: LD_INT 1
78071: PUSH
78072: LD_INT 3
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 0
78081: PUSH
78082: LD_INT 3
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: PUSH
78089: LD_INT 1
78091: NEG
78092: PUSH
78093: LD_INT 2
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_INT 1
78102: PUSH
78103: LD_INT 4
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: PUSH
78110: LD_INT 0
78112: PUSH
78113: LD_INT 4
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 1
78122: NEG
78123: PUSH
78124: LD_INT 3
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: PUSH
78131: LD_INT 1
78133: PUSH
78134: LD_INT 5
78136: PUSH
78137: EMPTY
78138: LIST
78139: LIST
78140: PUSH
78141: LD_INT 0
78143: PUSH
78144: LD_INT 5
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: PUSH
78151: LD_INT 1
78153: NEG
78154: PUSH
78155: LD_INT 4
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 1
78164: PUSH
78165: LD_INT 6
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 0
78174: PUSH
78175: LD_INT 6
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: LD_INT 1
78184: NEG
78185: PUSH
78186: LD_INT 5
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: PUSH
78193: EMPTY
78194: LIST
78195: LIST
78196: LIST
78197: LIST
78198: LIST
78199: LIST
78200: LIST
78201: LIST
78202: LIST
78203: LIST
78204: LIST
78205: LIST
78206: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78207: LD_ADDR_VAR 0 33
78211: PUSH
78212: LD_INT 2
78214: NEG
78215: PUSH
78216: LD_INT 1
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PUSH
78223: LD_INT 3
78225: NEG
78226: PUSH
78227: LD_INT 0
78229: PUSH
78230: EMPTY
78231: LIST
78232: LIST
78233: PUSH
78234: LD_INT 3
78236: NEG
78237: PUSH
78238: LD_INT 1
78240: NEG
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: PUSH
78246: LD_INT 3
78248: NEG
78249: PUSH
78250: LD_INT 1
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: PUSH
78257: LD_INT 4
78259: NEG
78260: PUSH
78261: LD_INT 0
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: LD_INT 4
78270: NEG
78271: PUSH
78272: LD_INT 1
78274: NEG
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: LD_INT 4
78282: NEG
78283: PUSH
78284: LD_INT 1
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: PUSH
78291: LD_INT 5
78293: NEG
78294: PUSH
78295: LD_INT 0
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: PUSH
78302: LD_INT 5
78304: NEG
78305: PUSH
78306: LD_INT 1
78308: NEG
78309: PUSH
78310: EMPTY
78311: LIST
78312: LIST
78313: PUSH
78314: LD_INT 5
78316: NEG
78317: PUSH
78318: LD_INT 1
78320: PUSH
78321: EMPTY
78322: LIST
78323: LIST
78324: PUSH
78325: LD_INT 6
78327: NEG
78328: PUSH
78329: LD_INT 0
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: PUSH
78336: LD_INT 6
78338: NEG
78339: PUSH
78340: LD_INT 1
78342: NEG
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: LIST
78352: LIST
78353: LIST
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: LIST
78361: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
78362: LD_ADDR_VAR 0 34
78366: PUSH
78367: LD_INT 2
78369: NEG
78370: PUSH
78371: LD_INT 3
78373: NEG
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 3
78381: NEG
78382: PUSH
78383: LD_INT 2
78385: NEG
78386: PUSH
78387: EMPTY
78388: LIST
78389: LIST
78390: PUSH
78391: LD_INT 3
78393: NEG
78394: PUSH
78395: LD_INT 3
78397: NEG
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: PUSH
78403: LD_INT 3
78405: NEG
78406: PUSH
78407: LD_INT 4
78409: NEG
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PUSH
78415: LD_INT 4
78417: NEG
78418: PUSH
78419: LD_INT 3
78421: NEG
78422: PUSH
78423: EMPTY
78424: LIST
78425: LIST
78426: PUSH
78427: LD_INT 4
78429: NEG
78430: PUSH
78431: LD_INT 4
78433: NEG
78434: PUSH
78435: EMPTY
78436: LIST
78437: LIST
78438: PUSH
78439: LD_INT 4
78441: NEG
78442: PUSH
78443: LD_INT 5
78445: NEG
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: LD_INT 5
78453: NEG
78454: PUSH
78455: LD_INT 4
78457: NEG
78458: PUSH
78459: EMPTY
78460: LIST
78461: LIST
78462: PUSH
78463: LD_INT 5
78465: NEG
78466: PUSH
78467: LD_INT 5
78469: NEG
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: LD_INT 5
78477: NEG
78478: PUSH
78479: LD_INT 6
78481: NEG
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: PUSH
78487: LD_INT 6
78489: NEG
78490: PUSH
78491: LD_INT 5
78493: NEG
78494: PUSH
78495: EMPTY
78496: LIST
78497: LIST
78498: PUSH
78499: LD_INT 6
78501: NEG
78502: PUSH
78503: LD_INT 6
78505: NEG
78506: PUSH
78507: EMPTY
78508: LIST
78509: LIST
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: LIST
78515: LIST
78516: LIST
78517: LIST
78518: LIST
78519: LIST
78520: LIST
78521: LIST
78522: LIST
78523: LIST
78524: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
78525: LD_ADDR_VAR 0 41
78529: PUSH
78530: LD_INT 0
78532: PUSH
78533: LD_INT 2
78535: NEG
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: PUSH
78541: LD_INT 1
78543: NEG
78544: PUSH
78545: LD_INT 3
78547: NEG
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 1
78555: PUSH
78556: LD_INT 2
78558: NEG
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: LIST
78568: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
78569: LD_ADDR_VAR 0 42
78573: PUSH
78574: LD_INT 2
78576: PUSH
78577: LD_INT 0
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: LD_INT 2
78586: PUSH
78587: LD_INT 1
78589: NEG
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 3
78597: PUSH
78598: LD_INT 1
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: LIST
78609: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78610: LD_ADDR_VAR 0 43
78614: PUSH
78615: LD_INT 2
78617: PUSH
78618: LD_INT 2
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 3
78627: PUSH
78628: LD_INT 2
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: PUSH
78635: LD_INT 2
78637: PUSH
78638: LD_INT 3
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: LIST
78649: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
78650: LD_ADDR_VAR 0 44
78654: PUSH
78655: LD_INT 0
78657: PUSH
78658: LD_INT 2
78660: PUSH
78661: EMPTY
78662: LIST
78663: LIST
78664: PUSH
78665: LD_INT 1
78667: PUSH
78668: LD_INT 3
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: LD_INT 1
78677: NEG
78678: PUSH
78679: LD_INT 2
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: LIST
78690: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78691: LD_ADDR_VAR 0 45
78695: PUSH
78696: LD_INT 2
78698: NEG
78699: PUSH
78700: LD_INT 0
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: PUSH
78707: LD_INT 2
78709: NEG
78710: PUSH
78711: LD_INT 1
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: LD_INT 3
78720: NEG
78721: PUSH
78722: LD_INT 1
78724: NEG
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: LIST
78734: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78735: LD_ADDR_VAR 0 46
78739: PUSH
78740: LD_INT 2
78742: NEG
78743: PUSH
78744: LD_INT 2
78746: NEG
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 2
78754: NEG
78755: PUSH
78756: LD_INT 3
78758: NEG
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 3
78766: NEG
78767: PUSH
78768: LD_INT 2
78770: NEG
78771: PUSH
78772: EMPTY
78773: LIST
78774: LIST
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: LIST
78780: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
78781: LD_ADDR_VAR 0 47
78785: PUSH
78786: LD_INT 2
78788: NEG
78789: PUSH
78790: LD_INT 3
78792: NEG
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 1
78800: NEG
78801: PUSH
78802: LD_INT 3
78804: NEG
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78814: LD_ADDR_VAR 0 48
78818: PUSH
78819: LD_INT 1
78821: PUSH
78822: LD_INT 2
78824: NEG
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: PUSH
78830: LD_INT 2
78832: PUSH
78833: LD_INT 1
78835: NEG
78836: PUSH
78837: EMPTY
78838: LIST
78839: LIST
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
78845: LD_ADDR_VAR 0 49
78849: PUSH
78850: LD_INT 3
78852: PUSH
78853: LD_INT 1
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: PUSH
78860: LD_INT 3
78862: PUSH
78863: LD_INT 2
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
78874: LD_ADDR_VAR 0 50
78878: PUSH
78879: LD_INT 2
78881: PUSH
78882: LD_INT 3
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 1
78891: PUSH
78892: LD_INT 3
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78903: LD_ADDR_VAR 0 51
78907: PUSH
78908: LD_INT 1
78910: NEG
78911: PUSH
78912: LD_INT 2
78914: PUSH
78915: EMPTY
78916: LIST
78917: LIST
78918: PUSH
78919: LD_INT 2
78921: NEG
78922: PUSH
78923: LD_INT 1
78925: PUSH
78926: EMPTY
78927: LIST
78928: LIST
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78934: LD_ADDR_VAR 0 52
78938: PUSH
78939: LD_INT 3
78941: NEG
78942: PUSH
78943: LD_INT 1
78945: NEG
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: PUSH
78951: LD_INT 3
78953: NEG
78954: PUSH
78955: LD_INT 2
78957: NEG
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: EMPTY
78964: LIST
78965: LIST
78966: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78967: LD_ADDR_VAR 0 53
78971: PUSH
78972: LD_INT 1
78974: NEG
78975: PUSH
78976: LD_INT 3
78978: NEG
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: PUSH
78984: LD_INT 0
78986: PUSH
78987: LD_INT 3
78989: NEG
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: PUSH
78995: LD_INT 1
78997: PUSH
78998: LD_INT 2
79000: NEG
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: LIST
79010: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79011: LD_ADDR_VAR 0 54
79015: PUSH
79016: LD_INT 2
79018: PUSH
79019: LD_INT 1
79021: NEG
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 3
79029: PUSH
79030: LD_INT 0
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 3
79039: PUSH
79040: LD_INT 1
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: LIST
79051: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79052: LD_ADDR_VAR 0 55
79056: PUSH
79057: LD_INT 3
79059: PUSH
79060: LD_INT 2
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: PUSH
79067: LD_INT 3
79069: PUSH
79070: LD_INT 3
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: PUSH
79077: LD_INT 2
79079: PUSH
79080: LD_INT 3
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: EMPTY
79088: LIST
79089: LIST
79090: LIST
79091: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79092: LD_ADDR_VAR 0 56
79096: PUSH
79097: LD_INT 1
79099: PUSH
79100: LD_INT 3
79102: PUSH
79103: EMPTY
79104: LIST
79105: LIST
79106: PUSH
79107: LD_INT 0
79109: PUSH
79110: LD_INT 3
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 1
79119: NEG
79120: PUSH
79121: LD_INT 2
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: EMPTY
79129: LIST
79130: LIST
79131: LIST
79132: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79133: LD_ADDR_VAR 0 57
79137: PUSH
79138: LD_INT 2
79140: NEG
79141: PUSH
79142: LD_INT 1
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 3
79151: NEG
79152: PUSH
79153: LD_INT 0
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 3
79162: NEG
79163: PUSH
79164: LD_INT 1
79166: NEG
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: LIST
79176: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79177: LD_ADDR_VAR 0 58
79181: PUSH
79182: LD_INT 2
79184: NEG
79185: PUSH
79186: LD_INT 3
79188: NEG
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 3
79196: NEG
79197: PUSH
79198: LD_INT 2
79200: NEG
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 3
79208: NEG
79209: PUSH
79210: LD_INT 3
79212: NEG
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: LIST
79222: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79223: LD_ADDR_VAR 0 59
79227: PUSH
79228: LD_INT 1
79230: NEG
79231: PUSH
79232: LD_INT 2
79234: NEG
79235: PUSH
79236: EMPTY
79237: LIST
79238: LIST
79239: PUSH
79240: LD_INT 0
79242: PUSH
79243: LD_INT 2
79245: NEG
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: PUSH
79251: LD_INT 1
79253: PUSH
79254: LD_INT 1
79256: NEG
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: LIST
79266: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79267: LD_ADDR_VAR 0 60
79271: PUSH
79272: LD_INT 1
79274: PUSH
79275: LD_INT 1
79277: NEG
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 2
79285: PUSH
79286: LD_INT 0
79288: PUSH
79289: EMPTY
79290: LIST
79291: LIST
79292: PUSH
79293: LD_INT 2
79295: PUSH
79296: LD_INT 1
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: LIST
79307: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79308: LD_ADDR_VAR 0 61
79312: PUSH
79313: LD_INT 2
79315: PUSH
79316: LD_INT 1
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: LD_INT 2
79325: PUSH
79326: LD_INT 2
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 1
79335: PUSH
79336: LD_INT 2
79338: PUSH
79339: EMPTY
79340: LIST
79341: LIST
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: LIST
79347: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
79348: LD_ADDR_VAR 0 62
79352: PUSH
79353: LD_INT 1
79355: PUSH
79356: LD_INT 2
79358: PUSH
79359: EMPTY
79360: LIST
79361: LIST
79362: PUSH
79363: LD_INT 0
79365: PUSH
79366: LD_INT 2
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PUSH
79373: LD_INT 1
79375: NEG
79376: PUSH
79377: LD_INT 1
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: LIST
79388: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
79389: LD_ADDR_VAR 0 63
79393: PUSH
79394: LD_INT 1
79396: NEG
79397: PUSH
79398: LD_INT 1
79400: PUSH
79401: EMPTY
79402: LIST
79403: LIST
79404: PUSH
79405: LD_INT 2
79407: NEG
79408: PUSH
79409: LD_INT 0
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 2
79418: NEG
79419: PUSH
79420: LD_INT 1
79422: NEG
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: EMPTY
79429: LIST
79430: LIST
79431: LIST
79432: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79433: LD_ADDR_VAR 0 64
79437: PUSH
79438: LD_INT 1
79440: NEG
79441: PUSH
79442: LD_INT 2
79444: NEG
79445: PUSH
79446: EMPTY
79447: LIST
79448: LIST
79449: PUSH
79450: LD_INT 2
79452: NEG
79453: PUSH
79454: LD_INT 1
79456: NEG
79457: PUSH
79458: EMPTY
79459: LIST
79460: LIST
79461: PUSH
79462: LD_INT 2
79464: NEG
79465: PUSH
79466: LD_INT 2
79468: NEG
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: LIST
79478: ST_TO_ADDR
// end ; 2 :
79479: GO 82745
79481: LD_INT 2
79483: DOUBLE
79484: EQUAL
79485: IFTRUE 79489
79487: GO 82744
79489: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
79490: LD_ADDR_VAR 0 29
79494: PUSH
79495: LD_INT 4
79497: PUSH
79498: LD_INT 0
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PUSH
79505: LD_INT 4
79507: PUSH
79508: LD_INT 1
79510: NEG
79511: PUSH
79512: EMPTY
79513: LIST
79514: LIST
79515: PUSH
79516: LD_INT 5
79518: PUSH
79519: LD_INT 0
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PUSH
79526: LD_INT 5
79528: PUSH
79529: LD_INT 1
79531: PUSH
79532: EMPTY
79533: LIST
79534: LIST
79535: PUSH
79536: LD_INT 4
79538: PUSH
79539: LD_INT 1
79541: PUSH
79542: EMPTY
79543: LIST
79544: LIST
79545: PUSH
79546: LD_INT 3
79548: PUSH
79549: LD_INT 0
79551: PUSH
79552: EMPTY
79553: LIST
79554: LIST
79555: PUSH
79556: LD_INT 3
79558: PUSH
79559: LD_INT 1
79561: NEG
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 3
79569: PUSH
79570: LD_INT 2
79572: NEG
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: PUSH
79578: LD_INT 5
79580: PUSH
79581: LD_INT 2
79583: PUSH
79584: EMPTY
79585: LIST
79586: LIST
79587: PUSH
79588: LD_INT 3
79590: PUSH
79591: LD_INT 3
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: PUSH
79598: LD_INT 3
79600: PUSH
79601: LD_INT 2
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: LD_INT 4
79610: PUSH
79611: LD_INT 3
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PUSH
79618: LD_INT 4
79620: PUSH
79621: LD_INT 4
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 3
79630: PUSH
79631: LD_INT 4
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 2
79640: PUSH
79641: LD_INT 3
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 2
79650: PUSH
79651: LD_INT 2
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 4
79660: PUSH
79661: LD_INT 2
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: LD_INT 2
79670: PUSH
79671: LD_INT 4
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: LD_INT 0
79680: PUSH
79681: LD_INT 4
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 0
79690: PUSH
79691: LD_INT 3
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 1
79700: PUSH
79701: LD_INT 4
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 1
79710: PUSH
79711: LD_INT 5
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 0
79720: PUSH
79721: LD_INT 5
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PUSH
79728: LD_INT 1
79730: NEG
79731: PUSH
79732: LD_INT 4
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 1
79741: NEG
79742: PUSH
79743: LD_INT 3
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PUSH
79750: LD_INT 2
79752: PUSH
79753: LD_INT 5
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 2
79762: NEG
79763: PUSH
79764: LD_INT 3
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: PUSH
79771: LD_INT 3
79773: NEG
79774: PUSH
79775: LD_INT 0
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: LD_INT 3
79784: NEG
79785: PUSH
79786: LD_INT 1
79788: NEG
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: LD_INT 2
79796: NEG
79797: PUSH
79798: LD_INT 0
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: LD_INT 2
79807: NEG
79808: PUSH
79809: LD_INT 1
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: PUSH
79816: LD_INT 3
79818: NEG
79819: PUSH
79820: LD_INT 1
79822: PUSH
79823: EMPTY
79824: LIST
79825: LIST
79826: PUSH
79827: LD_INT 4
79829: NEG
79830: PUSH
79831: LD_INT 0
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PUSH
79838: LD_INT 4
79840: NEG
79841: PUSH
79842: LD_INT 1
79844: NEG
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 4
79852: NEG
79853: PUSH
79854: LD_INT 2
79856: NEG
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: LD_INT 2
79864: NEG
79865: PUSH
79866: LD_INT 2
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 4
79875: NEG
79876: PUSH
79877: LD_INT 4
79879: NEG
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 4
79887: NEG
79888: PUSH
79889: LD_INT 5
79891: NEG
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: PUSH
79897: LD_INT 3
79899: NEG
79900: PUSH
79901: LD_INT 4
79903: NEG
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 3
79911: NEG
79912: PUSH
79913: LD_INT 3
79915: NEG
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: LD_INT 4
79923: NEG
79924: PUSH
79925: LD_INT 3
79927: NEG
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 5
79935: NEG
79936: PUSH
79937: LD_INT 4
79939: NEG
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 5
79947: NEG
79948: PUSH
79949: LD_INT 5
79951: NEG
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 3
79959: NEG
79960: PUSH
79961: LD_INT 5
79963: NEG
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: PUSH
79969: LD_INT 5
79971: NEG
79972: PUSH
79973: LD_INT 3
79975: NEG
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: LIST
80020: LIST
80021: LIST
80022: LIST
80023: LIST
80024: LIST
80025: LIST
80026: LIST
80027: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80028: LD_ADDR_VAR 0 30
80032: PUSH
80033: LD_INT 4
80035: PUSH
80036: LD_INT 4
80038: PUSH
80039: EMPTY
80040: LIST
80041: LIST
80042: PUSH
80043: LD_INT 4
80045: PUSH
80046: LD_INT 3
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 5
80055: PUSH
80056: LD_INT 4
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 5
80065: PUSH
80066: LD_INT 5
80068: PUSH
80069: EMPTY
80070: LIST
80071: LIST
80072: PUSH
80073: LD_INT 4
80075: PUSH
80076: LD_INT 5
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: PUSH
80083: LD_INT 3
80085: PUSH
80086: LD_INT 4
80088: PUSH
80089: EMPTY
80090: LIST
80091: LIST
80092: PUSH
80093: LD_INT 3
80095: PUSH
80096: LD_INT 3
80098: PUSH
80099: EMPTY
80100: LIST
80101: LIST
80102: PUSH
80103: LD_INT 5
80105: PUSH
80106: LD_INT 3
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_INT 3
80115: PUSH
80116: LD_INT 5
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PUSH
80123: LD_INT 0
80125: PUSH
80126: LD_INT 3
80128: PUSH
80129: EMPTY
80130: LIST
80131: LIST
80132: PUSH
80133: LD_INT 0
80135: PUSH
80136: LD_INT 2
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 1
80145: PUSH
80146: LD_INT 3
80148: PUSH
80149: EMPTY
80150: LIST
80151: LIST
80152: PUSH
80153: LD_INT 1
80155: PUSH
80156: LD_INT 4
80158: PUSH
80159: EMPTY
80160: LIST
80161: LIST
80162: PUSH
80163: LD_INT 0
80165: PUSH
80166: LD_INT 4
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: PUSH
80173: LD_INT 1
80175: NEG
80176: PUSH
80177: LD_INT 3
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 1
80186: NEG
80187: PUSH
80188: LD_INT 2
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 2
80197: PUSH
80198: LD_INT 4
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 2
80207: NEG
80208: PUSH
80209: LD_INT 2
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: LD_INT 4
80218: NEG
80219: PUSH
80220: LD_INT 0
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 4
80229: NEG
80230: PUSH
80231: LD_INT 1
80233: NEG
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 3
80241: NEG
80242: PUSH
80243: LD_INT 0
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 3
80252: NEG
80253: PUSH
80254: LD_INT 1
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 4
80263: NEG
80264: PUSH
80265: LD_INT 1
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 5
80274: NEG
80275: PUSH
80276: LD_INT 0
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 5
80285: NEG
80286: PUSH
80287: LD_INT 1
80289: NEG
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PUSH
80295: LD_INT 5
80297: NEG
80298: PUSH
80299: LD_INT 2
80301: NEG
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 3
80309: NEG
80310: PUSH
80311: LD_INT 2
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 3
80320: NEG
80321: PUSH
80322: LD_INT 3
80324: NEG
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: LD_INT 3
80332: NEG
80333: PUSH
80334: LD_INT 4
80336: NEG
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: PUSH
80342: LD_INT 2
80344: NEG
80345: PUSH
80346: LD_INT 3
80348: NEG
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: PUSH
80354: LD_INT 2
80356: NEG
80357: PUSH
80358: LD_INT 2
80360: NEG
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 3
80368: NEG
80369: PUSH
80370: LD_INT 2
80372: NEG
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 4
80380: NEG
80381: PUSH
80382: LD_INT 3
80384: NEG
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 4
80392: NEG
80393: PUSH
80394: LD_INT 4
80396: NEG
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 2
80404: NEG
80405: PUSH
80406: LD_INT 4
80408: NEG
80409: PUSH
80410: EMPTY
80411: LIST
80412: LIST
80413: PUSH
80414: LD_INT 4
80416: NEG
80417: PUSH
80418: LD_INT 2
80420: NEG
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: LD_INT 0
80428: PUSH
80429: LD_INT 4
80431: NEG
80432: PUSH
80433: EMPTY
80434: LIST
80435: LIST
80436: PUSH
80437: LD_INT 0
80439: PUSH
80440: LD_INT 5
80442: NEG
80443: PUSH
80444: EMPTY
80445: LIST
80446: LIST
80447: PUSH
80448: LD_INT 1
80450: PUSH
80451: LD_INT 4
80453: NEG
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 1
80461: PUSH
80462: LD_INT 3
80464: NEG
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: PUSH
80470: LD_INT 0
80472: PUSH
80473: LD_INT 3
80475: NEG
80476: PUSH
80477: EMPTY
80478: LIST
80479: LIST
80480: PUSH
80481: LD_INT 1
80483: NEG
80484: PUSH
80485: LD_INT 4
80487: NEG
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 1
80495: NEG
80496: PUSH
80497: LD_INT 5
80499: NEG
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 2
80507: PUSH
80508: LD_INT 3
80510: NEG
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 2
80518: NEG
80519: PUSH
80520: LD_INT 5
80522: NEG
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: PUSH
80528: EMPTY
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: LIST
80552: LIST
80553: LIST
80554: LIST
80555: LIST
80556: LIST
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
80575: LD_ADDR_VAR 0 31
80579: PUSH
80580: LD_INT 0
80582: PUSH
80583: LD_INT 4
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 0
80592: PUSH
80593: LD_INT 3
80595: PUSH
80596: EMPTY
80597: LIST
80598: LIST
80599: PUSH
80600: LD_INT 1
80602: PUSH
80603: LD_INT 4
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 1
80612: PUSH
80613: LD_INT 5
80615: PUSH
80616: EMPTY
80617: LIST
80618: LIST
80619: PUSH
80620: LD_INT 0
80622: PUSH
80623: LD_INT 5
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 1
80632: NEG
80633: PUSH
80634: LD_INT 4
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 1
80643: NEG
80644: PUSH
80645: LD_INT 3
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: PUSH
80652: LD_INT 2
80654: PUSH
80655: LD_INT 5
80657: PUSH
80658: EMPTY
80659: LIST
80660: LIST
80661: PUSH
80662: LD_INT 2
80664: NEG
80665: PUSH
80666: LD_INT 3
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: LD_INT 3
80675: NEG
80676: PUSH
80677: LD_INT 0
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: PUSH
80684: LD_INT 3
80686: NEG
80687: PUSH
80688: LD_INT 1
80690: NEG
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 2
80698: NEG
80699: PUSH
80700: LD_INT 0
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: PUSH
80707: LD_INT 2
80709: NEG
80710: PUSH
80711: LD_INT 1
80713: PUSH
80714: EMPTY
80715: LIST
80716: LIST
80717: PUSH
80718: LD_INT 3
80720: NEG
80721: PUSH
80722: LD_INT 1
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: LD_INT 4
80731: NEG
80732: PUSH
80733: LD_INT 0
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 4
80742: NEG
80743: PUSH
80744: LD_INT 1
80746: NEG
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 4
80754: NEG
80755: PUSH
80756: LD_INT 2
80758: NEG
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: LD_INT 2
80766: NEG
80767: PUSH
80768: LD_INT 2
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 4
80777: NEG
80778: PUSH
80779: LD_INT 4
80781: NEG
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 4
80789: NEG
80790: PUSH
80791: LD_INT 5
80793: NEG
80794: PUSH
80795: EMPTY
80796: LIST
80797: LIST
80798: PUSH
80799: LD_INT 3
80801: NEG
80802: PUSH
80803: LD_INT 4
80805: NEG
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PUSH
80811: LD_INT 3
80813: NEG
80814: PUSH
80815: LD_INT 3
80817: NEG
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 4
80825: NEG
80826: PUSH
80827: LD_INT 3
80829: NEG
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 5
80837: NEG
80838: PUSH
80839: LD_INT 4
80841: NEG
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 5
80849: NEG
80850: PUSH
80851: LD_INT 5
80853: NEG
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: LD_INT 3
80861: NEG
80862: PUSH
80863: LD_INT 5
80865: NEG
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PUSH
80871: LD_INT 5
80873: NEG
80874: PUSH
80875: LD_INT 3
80877: NEG
80878: PUSH
80879: EMPTY
80880: LIST
80881: LIST
80882: PUSH
80883: LD_INT 0
80885: PUSH
80886: LD_INT 3
80888: NEG
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: LD_INT 0
80896: PUSH
80897: LD_INT 4
80899: NEG
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: LD_INT 1
80907: PUSH
80908: LD_INT 3
80910: NEG
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 1
80918: PUSH
80919: LD_INT 2
80921: NEG
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 0
80929: PUSH
80930: LD_INT 2
80932: NEG
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 1
80940: NEG
80941: PUSH
80942: LD_INT 3
80944: NEG
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 1
80952: NEG
80953: PUSH
80954: LD_INT 4
80956: NEG
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PUSH
80962: LD_INT 2
80964: PUSH
80965: LD_INT 2
80967: NEG
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: PUSH
80973: LD_INT 2
80975: NEG
80976: PUSH
80977: LD_INT 4
80979: NEG
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 4
80987: PUSH
80988: LD_INT 0
80990: PUSH
80991: EMPTY
80992: LIST
80993: LIST
80994: PUSH
80995: LD_INT 4
80997: PUSH
80998: LD_INT 1
81000: NEG
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: PUSH
81006: LD_INT 5
81008: PUSH
81009: LD_INT 0
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 5
81018: PUSH
81019: LD_INT 1
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 4
81028: PUSH
81029: LD_INT 1
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: LD_INT 3
81038: PUSH
81039: LD_INT 0
81041: PUSH
81042: EMPTY
81043: LIST
81044: LIST
81045: PUSH
81046: LD_INT 3
81048: PUSH
81049: LD_INT 1
81051: NEG
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: PUSH
81057: LD_INT 3
81059: PUSH
81060: LD_INT 2
81062: NEG
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: PUSH
81068: LD_INT 5
81070: PUSH
81071: LD_INT 2
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: EMPTY
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: LIST
81097: LIST
81098: LIST
81099: LIST
81100: LIST
81101: LIST
81102: LIST
81103: LIST
81104: LIST
81105: LIST
81106: LIST
81107: LIST
81108: LIST
81109: LIST
81110: LIST
81111: LIST
81112: LIST
81113: LIST
81114: LIST
81115: LIST
81116: LIST
81117: LIST
81118: LIST
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: LIST
81124: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81125: LD_ADDR_VAR 0 32
81129: PUSH
81130: LD_INT 4
81132: NEG
81133: PUSH
81134: LD_INT 0
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 4
81143: NEG
81144: PUSH
81145: LD_INT 1
81147: NEG
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 3
81155: NEG
81156: PUSH
81157: LD_INT 0
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: PUSH
81164: LD_INT 3
81166: NEG
81167: PUSH
81168: LD_INT 1
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 4
81177: NEG
81178: PUSH
81179: LD_INT 1
81181: PUSH
81182: EMPTY
81183: LIST
81184: LIST
81185: PUSH
81186: LD_INT 5
81188: NEG
81189: PUSH
81190: LD_INT 0
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 5
81199: NEG
81200: PUSH
81201: LD_INT 1
81203: NEG
81204: PUSH
81205: EMPTY
81206: LIST
81207: LIST
81208: PUSH
81209: LD_INT 5
81211: NEG
81212: PUSH
81213: LD_INT 2
81215: NEG
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 3
81223: NEG
81224: PUSH
81225: LD_INT 2
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: PUSH
81232: LD_INT 3
81234: NEG
81235: PUSH
81236: LD_INT 3
81238: NEG
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 3
81246: NEG
81247: PUSH
81248: LD_INT 4
81250: NEG
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 2
81258: NEG
81259: PUSH
81260: LD_INT 3
81262: NEG
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 2
81270: NEG
81271: PUSH
81272: LD_INT 2
81274: NEG
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: PUSH
81280: LD_INT 3
81282: NEG
81283: PUSH
81284: LD_INT 2
81286: NEG
81287: PUSH
81288: EMPTY
81289: LIST
81290: LIST
81291: PUSH
81292: LD_INT 4
81294: NEG
81295: PUSH
81296: LD_INT 3
81298: NEG
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 4
81306: NEG
81307: PUSH
81308: LD_INT 4
81310: NEG
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 2
81318: NEG
81319: PUSH
81320: LD_INT 4
81322: NEG
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 4
81330: NEG
81331: PUSH
81332: LD_INT 2
81334: NEG
81335: PUSH
81336: EMPTY
81337: LIST
81338: LIST
81339: PUSH
81340: LD_INT 0
81342: PUSH
81343: LD_INT 4
81345: NEG
81346: PUSH
81347: EMPTY
81348: LIST
81349: LIST
81350: PUSH
81351: LD_INT 0
81353: PUSH
81354: LD_INT 5
81356: NEG
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: PUSH
81362: LD_INT 1
81364: PUSH
81365: LD_INT 4
81367: NEG
81368: PUSH
81369: EMPTY
81370: LIST
81371: LIST
81372: PUSH
81373: LD_INT 1
81375: PUSH
81376: LD_INT 3
81378: NEG
81379: PUSH
81380: EMPTY
81381: LIST
81382: LIST
81383: PUSH
81384: LD_INT 0
81386: PUSH
81387: LD_INT 3
81389: NEG
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 1
81397: NEG
81398: PUSH
81399: LD_INT 4
81401: NEG
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 1
81409: NEG
81410: PUSH
81411: LD_INT 5
81413: NEG
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 2
81421: PUSH
81422: LD_INT 3
81424: NEG
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 2
81432: NEG
81433: PUSH
81434: LD_INT 5
81436: NEG
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 3
81444: PUSH
81445: LD_INT 0
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: LD_INT 3
81454: PUSH
81455: LD_INT 1
81457: NEG
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 4
81465: PUSH
81466: LD_INT 0
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 4
81475: PUSH
81476: LD_INT 1
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: PUSH
81483: LD_INT 3
81485: PUSH
81486: LD_INT 1
81488: PUSH
81489: EMPTY
81490: LIST
81491: LIST
81492: PUSH
81493: LD_INT 2
81495: PUSH
81496: LD_INT 0
81498: PUSH
81499: EMPTY
81500: LIST
81501: LIST
81502: PUSH
81503: LD_INT 2
81505: PUSH
81506: LD_INT 1
81508: NEG
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: PUSH
81514: LD_INT 2
81516: PUSH
81517: LD_INT 2
81519: NEG
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 4
81527: PUSH
81528: LD_INT 2
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 4
81537: PUSH
81538: LD_INT 4
81540: PUSH
81541: EMPTY
81542: LIST
81543: LIST
81544: PUSH
81545: LD_INT 4
81547: PUSH
81548: LD_INT 3
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: LD_INT 5
81557: PUSH
81558: LD_INT 4
81560: PUSH
81561: EMPTY
81562: LIST
81563: LIST
81564: PUSH
81565: LD_INT 5
81567: PUSH
81568: LD_INT 5
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 4
81577: PUSH
81578: LD_INT 5
81580: PUSH
81581: EMPTY
81582: LIST
81583: LIST
81584: PUSH
81585: LD_INT 3
81587: PUSH
81588: LD_INT 4
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: PUSH
81595: LD_INT 3
81597: PUSH
81598: LD_INT 3
81600: PUSH
81601: EMPTY
81602: LIST
81603: LIST
81604: PUSH
81605: LD_INT 5
81607: PUSH
81608: LD_INT 3
81610: PUSH
81611: EMPTY
81612: LIST
81613: LIST
81614: PUSH
81615: LD_INT 3
81617: PUSH
81618: LD_INT 5
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: LIST
81629: LIST
81630: LIST
81631: LIST
81632: LIST
81633: LIST
81634: LIST
81635: LIST
81636: LIST
81637: LIST
81638: LIST
81639: LIST
81640: LIST
81641: LIST
81642: LIST
81643: LIST
81644: LIST
81645: LIST
81646: LIST
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: LIST
81655: LIST
81656: LIST
81657: LIST
81658: LIST
81659: LIST
81660: LIST
81661: LIST
81662: LIST
81663: LIST
81664: LIST
81665: LIST
81666: LIST
81667: LIST
81668: LIST
81669: LIST
81670: LIST
81671: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
81672: LD_ADDR_VAR 0 33
81676: PUSH
81677: LD_INT 4
81679: NEG
81680: PUSH
81681: LD_INT 4
81683: NEG
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: LD_INT 4
81691: NEG
81692: PUSH
81693: LD_INT 5
81695: NEG
81696: PUSH
81697: EMPTY
81698: LIST
81699: LIST
81700: PUSH
81701: LD_INT 3
81703: NEG
81704: PUSH
81705: LD_INT 4
81707: NEG
81708: PUSH
81709: EMPTY
81710: LIST
81711: LIST
81712: PUSH
81713: LD_INT 3
81715: NEG
81716: PUSH
81717: LD_INT 3
81719: NEG
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 4
81727: NEG
81728: PUSH
81729: LD_INT 3
81731: NEG
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: PUSH
81737: LD_INT 5
81739: NEG
81740: PUSH
81741: LD_INT 4
81743: NEG
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 5
81751: NEG
81752: PUSH
81753: LD_INT 5
81755: NEG
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 3
81763: NEG
81764: PUSH
81765: LD_INT 5
81767: NEG
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: LD_INT 5
81775: NEG
81776: PUSH
81777: LD_INT 3
81779: NEG
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 0
81787: PUSH
81788: LD_INT 3
81790: NEG
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 0
81798: PUSH
81799: LD_INT 4
81801: NEG
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 1
81809: PUSH
81810: LD_INT 3
81812: NEG
81813: PUSH
81814: EMPTY
81815: LIST
81816: LIST
81817: PUSH
81818: LD_INT 1
81820: PUSH
81821: LD_INT 2
81823: NEG
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 0
81831: PUSH
81832: LD_INT 2
81834: NEG
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 1
81842: NEG
81843: PUSH
81844: LD_INT 3
81846: NEG
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 1
81854: NEG
81855: PUSH
81856: LD_INT 4
81858: NEG
81859: PUSH
81860: EMPTY
81861: LIST
81862: LIST
81863: PUSH
81864: LD_INT 2
81866: PUSH
81867: LD_INT 2
81869: NEG
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 2
81877: NEG
81878: PUSH
81879: LD_INT 4
81881: NEG
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 4
81889: PUSH
81890: LD_INT 0
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 4
81899: PUSH
81900: LD_INT 1
81902: NEG
81903: PUSH
81904: EMPTY
81905: LIST
81906: LIST
81907: PUSH
81908: LD_INT 5
81910: PUSH
81911: LD_INT 0
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 5
81920: PUSH
81921: LD_INT 1
81923: PUSH
81924: EMPTY
81925: LIST
81926: LIST
81927: PUSH
81928: LD_INT 4
81930: PUSH
81931: LD_INT 1
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PUSH
81938: LD_INT 3
81940: PUSH
81941: LD_INT 0
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: PUSH
81948: LD_INT 3
81950: PUSH
81951: LD_INT 1
81953: NEG
81954: PUSH
81955: EMPTY
81956: LIST
81957: LIST
81958: PUSH
81959: LD_INT 3
81961: PUSH
81962: LD_INT 2
81964: NEG
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 5
81972: PUSH
81973: LD_INT 2
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 3
81982: PUSH
81983: LD_INT 3
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: LD_INT 3
81992: PUSH
81993: LD_INT 2
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: PUSH
82000: LD_INT 4
82002: PUSH
82003: LD_INT 3
82005: PUSH
82006: EMPTY
82007: LIST
82008: LIST
82009: PUSH
82010: LD_INT 4
82012: PUSH
82013: LD_INT 4
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: PUSH
82020: LD_INT 3
82022: PUSH
82023: LD_INT 4
82025: PUSH
82026: EMPTY
82027: LIST
82028: LIST
82029: PUSH
82030: LD_INT 2
82032: PUSH
82033: LD_INT 3
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: LD_INT 2
82042: PUSH
82043: LD_INT 2
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: LD_INT 4
82052: PUSH
82053: LD_INT 2
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 2
82062: PUSH
82063: LD_INT 4
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 0
82072: PUSH
82073: LD_INT 4
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 0
82082: PUSH
82083: LD_INT 3
82085: PUSH
82086: EMPTY
82087: LIST
82088: LIST
82089: PUSH
82090: LD_INT 1
82092: PUSH
82093: LD_INT 4
82095: PUSH
82096: EMPTY
82097: LIST
82098: LIST
82099: PUSH
82100: LD_INT 1
82102: PUSH
82103: LD_INT 5
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: PUSH
82110: LD_INT 0
82112: PUSH
82113: LD_INT 5
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 1
82122: NEG
82123: PUSH
82124: LD_INT 4
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 1
82133: NEG
82134: PUSH
82135: LD_INT 3
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 2
82144: PUSH
82145: LD_INT 5
82147: PUSH
82148: EMPTY
82149: LIST
82150: LIST
82151: PUSH
82152: LD_INT 2
82154: NEG
82155: PUSH
82156: LD_INT 3
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: LIST
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: LIST
82203: LIST
82204: LIST
82205: LIST
82206: LIST
82207: LIST
82208: LIST
82209: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82210: LD_ADDR_VAR 0 34
82214: PUSH
82215: LD_INT 0
82217: PUSH
82218: LD_INT 4
82220: NEG
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_INT 0
82228: PUSH
82229: LD_INT 5
82231: NEG
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 1
82239: PUSH
82240: LD_INT 4
82242: NEG
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: PUSH
82248: LD_INT 1
82250: PUSH
82251: LD_INT 3
82253: NEG
82254: PUSH
82255: EMPTY
82256: LIST
82257: LIST
82258: PUSH
82259: LD_INT 0
82261: PUSH
82262: LD_INT 3
82264: NEG
82265: PUSH
82266: EMPTY
82267: LIST
82268: LIST
82269: PUSH
82270: LD_INT 1
82272: NEG
82273: PUSH
82274: LD_INT 4
82276: NEG
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: PUSH
82282: LD_INT 1
82284: NEG
82285: PUSH
82286: LD_INT 5
82288: NEG
82289: PUSH
82290: EMPTY
82291: LIST
82292: LIST
82293: PUSH
82294: LD_INT 2
82296: PUSH
82297: LD_INT 3
82299: NEG
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: PUSH
82305: LD_INT 2
82307: NEG
82308: PUSH
82309: LD_INT 5
82311: NEG
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: PUSH
82317: LD_INT 3
82319: PUSH
82320: LD_INT 0
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: PUSH
82327: LD_INT 3
82329: PUSH
82330: LD_INT 1
82332: NEG
82333: PUSH
82334: EMPTY
82335: LIST
82336: LIST
82337: PUSH
82338: LD_INT 4
82340: PUSH
82341: LD_INT 0
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 4
82350: PUSH
82351: LD_INT 1
82353: PUSH
82354: EMPTY
82355: LIST
82356: LIST
82357: PUSH
82358: LD_INT 3
82360: PUSH
82361: LD_INT 1
82363: PUSH
82364: EMPTY
82365: LIST
82366: LIST
82367: PUSH
82368: LD_INT 2
82370: PUSH
82371: LD_INT 0
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: PUSH
82378: LD_INT 2
82380: PUSH
82381: LD_INT 1
82383: NEG
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: PUSH
82389: LD_INT 2
82391: PUSH
82392: LD_INT 2
82394: NEG
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: LD_INT 4
82402: PUSH
82403: LD_INT 2
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 4
82412: PUSH
82413: LD_INT 4
82415: PUSH
82416: EMPTY
82417: LIST
82418: LIST
82419: PUSH
82420: LD_INT 4
82422: PUSH
82423: LD_INT 3
82425: PUSH
82426: EMPTY
82427: LIST
82428: LIST
82429: PUSH
82430: LD_INT 5
82432: PUSH
82433: LD_INT 4
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PUSH
82440: LD_INT 5
82442: PUSH
82443: LD_INT 5
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 4
82452: PUSH
82453: LD_INT 5
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 3
82462: PUSH
82463: LD_INT 4
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 3
82472: PUSH
82473: LD_INT 3
82475: PUSH
82476: EMPTY
82477: LIST
82478: LIST
82479: PUSH
82480: LD_INT 5
82482: PUSH
82483: LD_INT 3
82485: PUSH
82486: EMPTY
82487: LIST
82488: LIST
82489: PUSH
82490: LD_INT 3
82492: PUSH
82493: LD_INT 5
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 0
82502: PUSH
82503: LD_INT 3
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 0
82512: PUSH
82513: LD_INT 2
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 1
82522: PUSH
82523: LD_INT 3
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 1
82532: PUSH
82533: LD_INT 4
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 0
82542: PUSH
82543: LD_INT 4
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: PUSH
82550: LD_INT 1
82552: NEG
82553: PUSH
82554: LD_INT 3
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 1
82563: NEG
82564: PUSH
82565: LD_INT 2
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: PUSH
82572: LD_INT 2
82574: PUSH
82575: LD_INT 4
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 2
82584: NEG
82585: PUSH
82586: LD_INT 2
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: PUSH
82593: LD_INT 4
82595: NEG
82596: PUSH
82597: LD_INT 0
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 4
82606: NEG
82607: PUSH
82608: LD_INT 1
82610: NEG
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 3
82618: NEG
82619: PUSH
82620: LD_INT 0
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 3
82629: NEG
82630: PUSH
82631: LD_INT 1
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 4
82640: NEG
82641: PUSH
82642: LD_INT 1
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: LD_INT 5
82651: NEG
82652: PUSH
82653: LD_INT 0
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 5
82662: NEG
82663: PUSH
82664: LD_INT 1
82666: NEG
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 5
82674: NEG
82675: PUSH
82676: LD_INT 2
82678: NEG
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 3
82686: NEG
82687: PUSH
82688: LD_INT 2
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: ST_TO_ADDR
// end ; end ;
82742: GO 82745
82744: POP
// case btype of b_depot , b_warehouse :
82745: LD_VAR 0 1
82749: PUSH
82750: LD_INT 0
82752: DOUBLE
82753: EQUAL
82754: IFTRUE 82764
82756: LD_INT 1
82758: DOUBLE
82759: EQUAL
82760: IFTRUE 82764
82762: GO 82965
82764: POP
// case nation of nation_american :
82765: LD_VAR 0 5
82769: PUSH
82770: LD_INT 1
82772: DOUBLE
82773: EQUAL
82774: IFTRUE 82778
82776: GO 82834
82778: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
82779: LD_ADDR_VAR 0 9
82783: PUSH
82784: LD_VAR 0 11
82788: PUSH
82789: LD_VAR 0 12
82793: PUSH
82794: LD_VAR 0 13
82798: PUSH
82799: LD_VAR 0 14
82803: PUSH
82804: LD_VAR 0 15
82808: PUSH
82809: LD_VAR 0 16
82813: PUSH
82814: EMPTY
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: PUSH
82822: LD_VAR 0 4
82826: PUSH
82827: LD_INT 1
82829: PLUS
82830: ARRAY
82831: ST_TO_ADDR
82832: GO 82963
82834: LD_INT 2
82836: DOUBLE
82837: EQUAL
82838: IFTRUE 82842
82840: GO 82898
82842: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
82843: LD_ADDR_VAR 0 9
82847: PUSH
82848: LD_VAR 0 17
82852: PUSH
82853: LD_VAR 0 18
82857: PUSH
82858: LD_VAR 0 19
82862: PUSH
82863: LD_VAR 0 20
82867: PUSH
82868: LD_VAR 0 21
82872: PUSH
82873: LD_VAR 0 22
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: LIST
82882: LIST
82883: LIST
82884: LIST
82885: PUSH
82886: LD_VAR 0 4
82890: PUSH
82891: LD_INT 1
82893: PLUS
82894: ARRAY
82895: ST_TO_ADDR
82896: GO 82963
82898: LD_INT 3
82900: DOUBLE
82901: EQUAL
82902: IFTRUE 82906
82904: GO 82962
82906: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
82907: LD_ADDR_VAR 0 9
82911: PUSH
82912: LD_VAR 0 23
82916: PUSH
82917: LD_VAR 0 24
82921: PUSH
82922: LD_VAR 0 25
82926: PUSH
82927: LD_VAR 0 26
82931: PUSH
82932: LD_VAR 0 27
82936: PUSH
82937: LD_VAR 0 28
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: LIST
82946: LIST
82947: LIST
82948: LIST
82949: PUSH
82950: LD_VAR 0 4
82954: PUSH
82955: LD_INT 1
82957: PLUS
82958: ARRAY
82959: ST_TO_ADDR
82960: GO 82963
82962: POP
82963: GO 83518
82965: LD_INT 2
82967: DOUBLE
82968: EQUAL
82969: IFTRUE 82979
82971: LD_INT 3
82973: DOUBLE
82974: EQUAL
82975: IFTRUE 82979
82977: GO 83035
82979: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
82980: LD_ADDR_VAR 0 9
82984: PUSH
82985: LD_VAR 0 29
82989: PUSH
82990: LD_VAR 0 30
82994: PUSH
82995: LD_VAR 0 31
82999: PUSH
83000: LD_VAR 0 32
83004: PUSH
83005: LD_VAR 0 33
83009: PUSH
83010: LD_VAR 0 34
83014: PUSH
83015: EMPTY
83016: LIST
83017: LIST
83018: LIST
83019: LIST
83020: LIST
83021: LIST
83022: PUSH
83023: LD_VAR 0 4
83027: PUSH
83028: LD_INT 1
83030: PLUS
83031: ARRAY
83032: ST_TO_ADDR
83033: GO 83518
83035: LD_INT 16
83037: DOUBLE
83038: EQUAL
83039: IFTRUE 83097
83041: LD_INT 17
83043: DOUBLE
83044: EQUAL
83045: IFTRUE 83097
83047: LD_INT 18
83049: DOUBLE
83050: EQUAL
83051: IFTRUE 83097
83053: LD_INT 19
83055: DOUBLE
83056: EQUAL
83057: IFTRUE 83097
83059: LD_INT 22
83061: DOUBLE
83062: EQUAL
83063: IFTRUE 83097
83065: LD_INT 20
83067: DOUBLE
83068: EQUAL
83069: IFTRUE 83097
83071: LD_INT 21
83073: DOUBLE
83074: EQUAL
83075: IFTRUE 83097
83077: LD_INT 23
83079: DOUBLE
83080: EQUAL
83081: IFTRUE 83097
83083: LD_INT 24
83085: DOUBLE
83086: EQUAL
83087: IFTRUE 83097
83089: LD_INT 25
83091: DOUBLE
83092: EQUAL
83093: IFTRUE 83097
83095: GO 83153
83097: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83098: LD_ADDR_VAR 0 9
83102: PUSH
83103: LD_VAR 0 35
83107: PUSH
83108: LD_VAR 0 36
83112: PUSH
83113: LD_VAR 0 37
83117: PUSH
83118: LD_VAR 0 38
83122: PUSH
83123: LD_VAR 0 39
83127: PUSH
83128: LD_VAR 0 40
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: LIST
83140: PUSH
83141: LD_VAR 0 4
83145: PUSH
83146: LD_INT 1
83148: PLUS
83149: ARRAY
83150: ST_TO_ADDR
83151: GO 83518
83153: LD_INT 6
83155: DOUBLE
83156: EQUAL
83157: IFTRUE 83209
83159: LD_INT 7
83161: DOUBLE
83162: EQUAL
83163: IFTRUE 83209
83165: LD_INT 8
83167: DOUBLE
83168: EQUAL
83169: IFTRUE 83209
83171: LD_INT 13
83173: DOUBLE
83174: EQUAL
83175: IFTRUE 83209
83177: LD_INT 12
83179: DOUBLE
83180: EQUAL
83181: IFTRUE 83209
83183: LD_INT 15
83185: DOUBLE
83186: EQUAL
83187: IFTRUE 83209
83189: LD_INT 11
83191: DOUBLE
83192: EQUAL
83193: IFTRUE 83209
83195: LD_INT 14
83197: DOUBLE
83198: EQUAL
83199: IFTRUE 83209
83201: LD_INT 10
83203: DOUBLE
83204: EQUAL
83205: IFTRUE 83209
83207: GO 83265
83209: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
83210: LD_ADDR_VAR 0 9
83214: PUSH
83215: LD_VAR 0 41
83219: PUSH
83220: LD_VAR 0 42
83224: PUSH
83225: LD_VAR 0 43
83229: PUSH
83230: LD_VAR 0 44
83234: PUSH
83235: LD_VAR 0 45
83239: PUSH
83240: LD_VAR 0 46
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: PUSH
83253: LD_VAR 0 4
83257: PUSH
83258: LD_INT 1
83260: PLUS
83261: ARRAY
83262: ST_TO_ADDR
83263: GO 83518
83265: LD_INT 36
83267: DOUBLE
83268: EQUAL
83269: IFTRUE 83273
83271: GO 83329
83273: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83274: LD_ADDR_VAR 0 9
83278: PUSH
83279: LD_VAR 0 47
83283: PUSH
83284: LD_VAR 0 48
83288: PUSH
83289: LD_VAR 0 49
83293: PUSH
83294: LD_VAR 0 50
83298: PUSH
83299: LD_VAR 0 51
83303: PUSH
83304: LD_VAR 0 52
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: LIST
83313: LIST
83314: LIST
83315: LIST
83316: PUSH
83317: LD_VAR 0 4
83321: PUSH
83322: LD_INT 1
83324: PLUS
83325: ARRAY
83326: ST_TO_ADDR
83327: GO 83518
83329: LD_INT 4
83331: DOUBLE
83332: EQUAL
83333: IFTRUE 83355
83335: LD_INT 5
83337: DOUBLE
83338: EQUAL
83339: IFTRUE 83355
83341: LD_INT 34
83343: DOUBLE
83344: EQUAL
83345: IFTRUE 83355
83347: LD_INT 37
83349: DOUBLE
83350: EQUAL
83351: IFTRUE 83355
83353: GO 83411
83355: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
83356: LD_ADDR_VAR 0 9
83360: PUSH
83361: LD_VAR 0 53
83365: PUSH
83366: LD_VAR 0 54
83370: PUSH
83371: LD_VAR 0 55
83375: PUSH
83376: LD_VAR 0 56
83380: PUSH
83381: LD_VAR 0 57
83385: PUSH
83386: LD_VAR 0 58
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: LIST
83398: PUSH
83399: LD_VAR 0 4
83403: PUSH
83404: LD_INT 1
83406: PLUS
83407: ARRAY
83408: ST_TO_ADDR
83409: GO 83518
83411: LD_INT 31
83413: DOUBLE
83414: EQUAL
83415: IFTRUE 83461
83417: LD_INT 32
83419: DOUBLE
83420: EQUAL
83421: IFTRUE 83461
83423: LD_INT 33
83425: DOUBLE
83426: EQUAL
83427: IFTRUE 83461
83429: LD_INT 27
83431: DOUBLE
83432: EQUAL
83433: IFTRUE 83461
83435: LD_INT 26
83437: DOUBLE
83438: EQUAL
83439: IFTRUE 83461
83441: LD_INT 28
83443: DOUBLE
83444: EQUAL
83445: IFTRUE 83461
83447: LD_INT 29
83449: DOUBLE
83450: EQUAL
83451: IFTRUE 83461
83453: LD_INT 30
83455: DOUBLE
83456: EQUAL
83457: IFTRUE 83461
83459: GO 83517
83461: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
83462: LD_ADDR_VAR 0 9
83466: PUSH
83467: LD_VAR 0 59
83471: PUSH
83472: LD_VAR 0 60
83476: PUSH
83477: LD_VAR 0 61
83481: PUSH
83482: LD_VAR 0 62
83486: PUSH
83487: LD_VAR 0 63
83491: PUSH
83492: LD_VAR 0 64
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: LIST
83501: LIST
83502: LIST
83503: LIST
83504: PUSH
83505: LD_VAR 0 4
83509: PUSH
83510: LD_INT 1
83512: PLUS
83513: ARRAY
83514: ST_TO_ADDR
83515: GO 83518
83517: POP
// temp_list2 = [ ] ;
83518: LD_ADDR_VAR 0 10
83522: PUSH
83523: EMPTY
83524: ST_TO_ADDR
// for i in temp_list do
83525: LD_ADDR_VAR 0 8
83529: PUSH
83530: LD_VAR 0 9
83534: PUSH
83535: FOR_IN
83536: IFFALSE 83588
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
83538: LD_ADDR_VAR 0 10
83542: PUSH
83543: LD_VAR 0 10
83547: PUSH
83548: LD_VAR 0 8
83552: PUSH
83553: LD_INT 1
83555: ARRAY
83556: PUSH
83557: LD_VAR 0 2
83561: PLUS
83562: PUSH
83563: LD_VAR 0 8
83567: PUSH
83568: LD_INT 2
83570: ARRAY
83571: PUSH
83572: LD_VAR 0 3
83576: PLUS
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: EMPTY
83583: LIST
83584: ADD
83585: ST_TO_ADDR
83586: GO 83535
83588: POP
83589: POP
// result = temp_list2 ;
83590: LD_ADDR_VAR 0 7
83594: PUSH
83595: LD_VAR 0 10
83599: ST_TO_ADDR
// end ;
83600: LD_VAR 0 7
83604: RET
// export function EnemyInRange ( unit , dist ) ; begin
83605: LD_INT 0
83607: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83608: LD_ADDR_VAR 0 3
83612: PUSH
83613: LD_VAR 0 1
83617: PPUSH
83618: CALL_OW 255
83622: PPUSH
83623: LD_VAR 0 1
83627: PPUSH
83628: CALL_OW 250
83632: PPUSH
83633: LD_VAR 0 1
83637: PPUSH
83638: CALL_OW 251
83642: PPUSH
83643: LD_VAR 0 2
83647: PPUSH
83648: CALL 57000 0 4
83652: PUSH
83653: LD_INT 4
83655: ARRAY
83656: ST_TO_ADDR
// end ;
83657: LD_VAR 0 3
83661: RET
// export function PlayerSeeMe ( unit ) ; begin
83662: LD_INT 0
83664: PPUSH
// result := See ( your_side , unit ) ;
83665: LD_ADDR_VAR 0 2
83669: PUSH
83670: LD_OWVAR 2
83674: PPUSH
83675: LD_VAR 0 1
83679: PPUSH
83680: CALL_OW 292
83684: ST_TO_ADDR
// end ;
83685: LD_VAR 0 2
83689: RET
// export function ReverseDir ( unit ) ; begin
83690: LD_INT 0
83692: PPUSH
// if not unit then
83693: LD_VAR 0 1
83697: NOT
83698: IFFALSE 83702
// exit ;
83700: GO 83725
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
83702: LD_ADDR_VAR 0 2
83706: PUSH
83707: LD_VAR 0 1
83711: PPUSH
83712: CALL_OW 254
83716: PUSH
83717: LD_INT 3
83719: PLUS
83720: PUSH
83721: LD_INT 6
83723: MOD
83724: ST_TO_ADDR
// end ;
83725: LD_VAR 0 2
83729: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
83730: LD_INT 0
83732: PPUSH
83733: PPUSH
83734: PPUSH
83735: PPUSH
83736: PPUSH
// if not hexes then
83737: LD_VAR 0 2
83741: NOT
83742: IFFALSE 83746
// exit ;
83744: GO 83894
// dist := 9999 ;
83746: LD_ADDR_VAR 0 5
83750: PUSH
83751: LD_INT 9999
83753: ST_TO_ADDR
// for i = 1 to hexes do
83754: LD_ADDR_VAR 0 4
83758: PUSH
83759: DOUBLE
83760: LD_INT 1
83762: DEC
83763: ST_TO_ADDR
83764: LD_VAR 0 2
83768: PUSH
83769: FOR_TO
83770: IFFALSE 83882
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
83772: LD_VAR 0 1
83776: PPUSH
83777: LD_VAR 0 2
83781: PUSH
83782: LD_VAR 0 4
83786: ARRAY
83787: PUSH
83788: LD_INT 1
83790: ARRAY
83791: PPUSH
83792: LD_VAR 0 2
83796: PUSH
83797: LD_VAR 0 4
83801: ARRAY
83802: PUSH
83803: LD_INT 2
83805: ARRAY
83806: PPUSH
83807: CALL_OW 297
83811: PUSH
83812: LD_VAR 0 5
83816: LESS
83817: IFFALSE 83880
// begin hex := hexes [ i ] ;
83819: LD_ADDR_VAR 0 7
83823: PUSH
83824: LD_VAR 0 2
83828: PUSH
83829: LD_VAR 0 4
83833: ARRAY
83834: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83835: LD_ADDR_VAR 0 5
83839: PUSH
83840: LD_VAR 0 1
83844: PPUSH
83845: LD_VAR 0 2
83849: PUSH
83850: LD_VAR 0 4
83854: ARRAY
83855: PUSH
83856: LD_INT 1
83858: ARRAY
83859: PPUSH
83860: LD_VAR 0 2
83864: PUSH
83865: LD_VAR 0 4
83869: ARRAY
83870: PUSH
83871: LD_INT 2
83873: ARRAY
83874: PPUSH
83875: CALL_OW 297
83879: ST_TO_ADDR
// end ; end ;
83880: GO 83769
83882: POP
83883: POP
// result := hex ;
83884: LD_ADDR_VAR 0 3
83888: PUSH
83889: LD_VAR 0 7
83893: ST_TO_ADDR
// end ;
83894: LD_VAR 0 3
83898: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
83899: LD_INT 0
83901: PPUSH
83902: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83903: LD_VAR 0 1
83907: NOT
83908: PUSH
83909: LD_VAR 0 1
83913: PUSH
83914: LD_INT 21
83916: PUSH
83917: LD_INT 2
83919: PUSH
83920: EMPTY
83921: LIST
83922: LIST
83923: PUSH
83924: LD_INT 23
83926: PUSH
83927: LD_INT 2
83929: PUSH
83930: EMPTY
83931: LIST
83932: LIST
83933: PUSH
83934: EMPTY
83935: LIST
83936: LIST
83937: PPUSH
83938: CALL_OW 69
83942: IN
83943: NOT
83944: OR
83945: IFFALSE 83949
// exit ;
83947: GO 83996
// for i = 1 to 3 do
83949: LD_ADDR_VAR 0 3
83953: PUSH
83954: DOUBLE
83955: LD_INT 1
83957: DEC
83958: ST_TO_ADDR
83959: LD_INT 3
83961: PUSH
83962: FOR_TO
83963: IFFALSE 83994
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
83965: LD_VAR 0 1
83969: PPUSH
83970: CALL_OW 250
83974: PPUSH
83975: LD_VAR 0 1
83979: PPUSH
83980: CALL_OW 251
83984: PPUSH
83985: LD_INT 1
83987: PPUSH
83988: CALL_OW 453
83992: GO 83962
83994: POP
83995: POP
// end ;
83996: LD_VAR 0 2
84000: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84001: LD_INT 0
84003: PPUSH
84004: PPUSH
84005: PPUSH
84006: PPUSH
84007: PPUSH
84008: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84009: LD_VAR 0 1
84013: NOT
84014: PUSH
84015: LD_VAR 0 2
84019: NOT
84020: OR
84021: PUSH
84022: LD_VAR 0 1
84026: PPUSH
84027: CALL_OW 314
84031: OR
84032: IFFALSE 84036
// exit ;
84034: GO 84477
// x := GetX ( enemy_unit ) ;
84036: LD_ADDR_VAR 0 7
84040: PUSH
84041: LD_VAR 0 2
84045: PPUSH
84046: CALL_OW 250
84050: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84051: LD_ADDR_VAR 0 8
84055: PUSH
84056: LD_VAR 0 2
84060: PPUSH
84061: CALL_OW 251
84065: ST_TO_ADDR
// if not x or not y then
84066: LD_VAR 0 7
84070: NOT
84071: PUSH
84072: LD_VAR 0 8
84076: NOT
84077: OR
84078: IFFALSE 84082
// exit ;
84080: GO 84477
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84082: LD_ADDR_VAR 0 6
84086: PUSH
84087: LD_VAR 0 7
84091: PPUSH
84092: LD_INT 0
84094: PPUSH
84095: LD_INT 4
84097: PPUSH
84098: CALL_OW 272
84102: PUSH
84103: LD_VAR 0 8
84107: PPUSH
84108: LD_INT 0
84110: PPUSH
84111: LD_INT 4
84113: PPUSH
84114: CALL_OW 273
84118: PUSH
84119: EMPTY
84120: LIST
84121: LIST
84122: PUSH
84123: LD_VAR 0 7
84127: PPUSH
84128: LD_INT 1
84130: PPUSH
84131: LD_INT 4
84133: PPUSH
84134: CALL_OW 272
84138: PUSH
84139: LD_VAR 0 8
84143: PPUSH
84144: LD_INT 1
84146: PPUSH
84147: LD_INT 4
84149: PPUSH
84150: CALL_OW 273
84154: PUSH
84155: EMPTY
84156: LIST
84157: LIST
84158: PUSH
84159: LD_VAR 0 7
84163: PPUSH
84164: LD_INT 2
84166: PPUSH
84167: LD_INT 4
84169: PPUSH
84170: CALL_OW 272
84174: PUSH
84175: LD_VAR 0 8
84179: PPUSH
84180: LD_INT 2
84182: PPUSH
84183: LD_INT 4
84185: PPUSH
84186: CALL_OW 273
84190: PUSH
84191: EMPTY
84192: LIST
84193: LIST
84194: PUSH
84195: LD_VAR 0 7
84199: PPUSH
84200: LD_INT 3
84202: PPUSH
84203: LD_INT 4
84205: PPUSH
84206: CALL_OW 272
84210: PUSH
84211: LD_VAR 0 8
84215: PPUSH
84216: LD_INT 3
84218: PPUSH
84219: LD_INT 4
84221: PPUSH
84222: CALL_OW 273
84226: PUSH
84227: EMPTY
84228: LIST
84229: LIST
84230: PUSH
84231: LD_VAR 0 7
84235: PPUSH
84236: LD_INT 4
84238: PPUSH
84239: LD_INT 4
84241: PPUSH
84242: CALL_OW 272
84246: PUSH
84247: LD_VAR 0 8
84251: PPUSH
84252: LD_INT 4
84254: PPUSH
84255: LD_INT 4
84257: PPUSH
84258: CALL_OW 273
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: PUSH
84267: LD_VAR 0 7
84271: PPUSH
84272: LD_INT 5
84274: PPUSH
84275: LD_INT 4
84277: PPUSH
84278: CALL_OW 272
84282: PUSH
84283: LD_VAR 0 8
84287: PPUSH
84288: LD_INT 5
84290: PPUSH
84291: LD_INT 4
84293: PPUSH
84294: CALL_OW 273
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: ST_TO_ADDR
// for i = tmp downto 1 do
84311: LD_ADDR_VAR 0 4
84315: PUSH
84316: DOUBLE
84317: LD_VAR 0 6
84321: INC
84322: ST_TO_ADDR
84323: LD_INT 1
84325: PUSH
84326: FOR_DOWNTO
84327: IFFALSE 84428
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
84329: LD_VAR 0 6
84333: PUSH
84334: LD_VAR 0 4
84338: ARRAY
84339: PUSH
84340: LD_INT 1
84342: ARRAY
84343: PPUSH
84344: LD_VAR 0 6
84348: PUSH
84349: LD_VAR 0 4
84353: ARRAY
84354: PUSH
84355: LD_INT 2
84357: ARRAY
84358: PPUSH
84359: CALL_OW 488
84363: NOT
84364: PUSH
84365: LD_VAR 0 6
84369: PUSH
84370: LD_VAR 0 4
84374: ARRAY
84375: PUSH
84376: LD_INT 1
84378: ARRAY
84379: PPUSH
84380: LD_VAR 0 6
84384: PUSH
84385: LD_VAR 0 4
84389: ARRAY
84390: PUSH
84391: LD_INT 2
84393: ARRAY
84394: PPUSH
84395: CALL_OW 428
84399: PUSH
84400: LD_INT 0
84402: NONEQUAL
84403: OR
84404: IFFALSE 84426
// tmp := Delete ( tmp , i ) ;
84406: LD_ADDR_VAR 0 6
84410: PUSH
84411: LD_VAR 0 6
84415: PPUSH
84416: LD_VAR 0 4
84420: PPUSH
84421: CALL_OW 3
84425: ST_TO_ADDR
84426: GO 84326
84428: POP
84429: POP
// j := GetClosestHex ( unit , tmp ) ;
84430: LD_ADDR_VAR 0 5
84434: PUSH
84435: LD_VAR 0 1
84439: PPUSH
84440: LD_VAR 0 6
84444: PPUSH
84445: CALL 83730 0 2
84449: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
84450: LD_VAR 0 1
84454: PPUSH
84455: LD_VAR 0 5
84459: PUSH
84460: LD_INT 1
84462: ARRAY
84463: PPUSH
84464: LD_VAR 0 5
84468: PUSH
84469: LD_INT 2
84471: ARRAY
84472: PPUSH
84473: CALL_OW 111
// end ;
84477: LD_VAR 0 3
84481: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
84482: LD_INT 0
84484: PPUSH
84485: PPUSH
84486: PPUSH
// uc_side = 0 ;
84487: LD_ADDR_OWVAR 20
84491: PUSH
84492: LD_INT 0
84494: ST_TO_ADDR
// uc_nation = 0 ;
84495: LD_ADDR_OWVAR 21
84499: PUSH
84500: LD_INT 0
84502: ST_TO_ADDR
// InitHc_All ( ) ;
84503: CALL_OW 584
// InitVc ;
84507: CALL_OW 20
// if mastodonts then
84511: LD_VAR 0 6
84515: IFFALSE 84582
// for i = 1 to mastodonts do
84517: LD_ADDR_VAR 0 11
84521: PUSH
84522: DOUBLE
84523: LD_INT 1
84525: DEC
84526: ST_TO_ADDR
84527: LD_VAR 0 6
84531: PUSH
84532: FOR_TO
84533: IFFALSE 84580
// begin vc_chassis := 31 ;
84535: LD_ADDR_OWVAR 37
84539: PUSH
84540: LD_INT 31
84542: ST_TO_ADDR
// vc_control := control_rider ;
84543: LD_ADDR_OWVAR 38
84547: PUSH
84548: LD_INT 4
84550: ST_TO_ADDR
// animal := CreateVehicle ;
84551: LD_ADDR_VAR 0 12
84555: PUSH
84556: CALL_OW 45
84560: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84561: LD_VAR 0 12
84565: PPUSH
84566: LD_VAR 0 8
84570: PPUSH
84571: LD_INT 0
84573: PPUSH
84574: CALL 86770 0 3
// end ;
84578: GO 84532
84580: POP
84581: POP
// if horses then
84582: LD_VAR 0 5
84586: IFFALSE 84653
// for i = 1 to horses do
84588: LD_ADDR_VAR 0 11
84592: PUSH
84593: DOUBLE
84594: LD_INT 1
84596: DEC
84597: ST_TO_ADDR
84598: LD_VAR 0 5
84602: PUSH
84603: FOR_TO
84604: IFFALSE 84651
// begin hc_class := 21 ;
84606: LD_ADDR_OWVAR 28
84610: PUSH
84611: LD_INT 21
84613: ST_TO_ADDR
// hc_gallery :=  ;
84614: LD_ADDR_OWVAR 33
84618: PUSH
84619: LD_STRING 
84621: ST_TO_ADDR
// animal := CreateHuman ;
84622: LD_ADDR_VAR 0 12
84626: PUSH
84627: CALL_OW 44
84631: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84632: LD_VAR 0 12
84636: PPUSH
84637: LD_VAR 0 8
84641: PPUSH
84642: LD_INT 0
84644: PPUSH
84645: CALL 86770 0 3
// end ;
84649: GO 84603
84651: POP
84652: POP
// if birds then
84653: LD_VAR 0 1
84657: IFFALSE 84724
// for i = 1 to birds do
84659: LD_ADDR_VAR 0 11
84663: PUSH
84664: DOUBLE
84665: LD_INT 1
84667: DEC
84668: ST_TO_ADDR
84669: LD_VAR 0 1
84673: PUSH
84674: FOR_TO
84675: IFFALSE 84722
// begin hc_class = 18 ;
84677: LD_ADDR_OWVAR 28
84681: PUSH
84682: LD_INT 18
84684: ST_TO_ADDR
// hc_gallery =  ;
84685: LD_ADDR_OWVAR 33
84689: PUSH
84690: LD_STRING 
84692: ST_TO_ADDR
// animal := CreateHuman ;
84693: LD_ADDR_VAR 0 12
84697: PUSH
84698: CALL_OW 44
84702: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84703: LD_VAR 0 12
84707: PPUSH
84708: LD_VAR 0 8
84712: PPUSH
84713: LD_INT 0
84715: PPUSH
84716: CALL 86770 0 3
// end ;
84720: GO 84674
84722: POP
84723: POP
// if tigers then
84724: LD_VAR 0 2
84728: IFFALSE 84812
// for i = 1 to tigers do
84730: LD_ADDR_VAR 0 11
84734: PUSH
84735: DOUBLE
84736: LD_INT 1
84738: DEC
84739: ST_TO_ADDR
84740: LD_VAR 0 2
84744: PUSH
84745: FOR_TO
84746: IFFALSE 84810
// begin hc_class = class_tiger ;
84748: LD_ADDR_OWVAR 28
84752: PUSH
84753: LD_INT 14
84755: ST_TO_ADDR
// hc_gallery =  ;
84756: LD_ADDR_OWVAR 33
84760: PUSH
84761: LD_STRING 
84763: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84764: LD_ADDR_OWVAR 35
84768: PUSH
84769: LD_INT 7
84771: NEG
84772: PPUSH
84773: LD_INT 7
84775: PPUSH
84776: CALL_OW 12
84780: ST_TO_ADDR
// animal := CreateHuman ;
84781: LD_ADDR_VAR 0 12
84785: PUSH
84786: CALL_OW 44
84790: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84791: LD_VAR 0 12
84795: PPUSH
84796: LD_VAR 0 8
84800: PPUSH
84801: LD_INT 0
84803: PPUSH
84804: CALL 86770 0 3
// end ;
84808: GO 84745
84810: POP
84811: POP
// if apemans then
84812: LD_VAR 0 3
84816: IFFALSE 84939
// for i = 1 to apemans do
84818: LD_ADDR_VAR 0 11
84822: PUSH
84823: DOUBLE
84824: LD_INT 1
84826: DEC
84827: ST_TO_ADDR
84828: LD_VAR 0 3
84832: PUSH
84833: FOR_TO
84834: IFFALSE 84937
// begin hc_class = class_apeman ;
84836: LD_ADDR_OWVAR 28
84840: PUSH
84841: LD_INT 12
84843: ST_TO_ADDR
// hc_gallery =  ;
84844: LD_ADDR_OWVAR 33
84848: PUSH
84849: LD_STRING 
84851: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
84852: LD_ADDR_OWVAR 35
84856: PUSH
84857: LD_INT 5
84859: NEG
84860: PPUSH
84861: LD_INT 5
84863: PPUSH
84864: CALL_OW 12
84868: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
84869: LD_ADDR_OWVAR 31
84873: PUSH
84874: LD_INT 1
84876: PPUSH
84877: LD_INT 3
84879: PPUSH
84880: CALL_OW 12
84884: PUSH
84885: LD_INT 1
84887: PPUSH
84888: LD_INT 3
84890: PPUSH
84891: CALL_OW 12
84895: PUSH
84896: LD_INT 0
84898: PUSH
84899: LD_INT 0
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: LIST
84906: LIST
84907: ST_TO_ADDR
// animal := CreateHuman ;
84908: LD_ADDR_VAR 0 12
84912: PUSH
84913: CALL_OW 44
84917: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84918: LD_VAR 0 12
84922: PPUSH
84923: LD_VAR 0 8
84927: PPUSH
84928: LD_INT 0
84930: PPUSH
84931: CALL 86770 0 3
// end ;
84935: GO 84833
84937: POP
84938: POP
// if enchidnas then
84939: LD_VAR 0 4
84943: IFFALSE 85010
// for i = 1 to enchidnas do
84945: LD_ADDR_VAR 0 11
84949: PUSH
84950: DOUBLE
84951: LD_INT 1
84953: DEC
84954: ST_TO_ADDR
84955: LD_VAR 0 4
84959: PUSH
84960: FOR_TO
84961: IFFALSE 85008
// begin hc_class = 13 ;
84963: LD_ADDR_OWVAR 28
84967: PUSH
84968: LD_INT 13
84970: ST_TO_ADDR
// hc_gallery =  ;
84971: LD_ADDR_OWVAR 33
84975: PUSH
84976: LD_STRING 
84978: ST_TO_ADDR
// animal := CreateHuman ;
84979: LD_ADDR_VAR 0 12
84983: PUSH
84984: CALL_OW 44
84988: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84989: LD_VAR 0 12
84993: PPUSH
84994: LD_VAR 0 8
84998: PPUSH
84999: LD_INT 0
85001: PPUSH
85002: CALL 86770 0 3
// end ;
85006: GO 84960
85008: POP
85009: POP
// if fishes then
85010: LD_VAR 0 7
85014: IFFALSE 85081
// for i = 1 to fishes do
85016: LD_ADDR_VAR 0 11
85020: PUSH
85021: DOUBLE
85022: LD_INT 1
85024: DEC
85025: ST_TO_ADDR
85026: LD_VAR 0 7
85030: PUSH
85031: FOR_TO
85032: IFFALSE 85079
// begin hc_class = 20 ;
85034: LD_ADDR_OWVAR 28
85038: PUSH
85039: LD_INT 20
85041: ST_TO_ADDR
// hc_gallery =  ;
85042: LD_ADDR_OWVAR 33
85046: PUSH
85047: LD_STRING 
85049: ST_TO_ADDR
// animal := CreateHuman ;
85050: LD_ADDR_VAR 0 12
85054: PUSH
85055: CALL_OW 44
85059: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85060: LD_VAR 0 12
85064: PPUSH
85065: LD_VAR 0 9
85069: PPUSH
85070: LD_INT 0
85072: PPUSH
85073: CALL 86770 0 3
// end ;
85077: GO 85031
85079: POP
85080: POP
// end ;
85081: LD_VAR 0 10
85085: RET
// export function WantHeal ( sci , unit ) ; begin
85086: LD_INT 0
85088: PPUSH
// if GetTaskList ( sci ) > 0 then
85089: LD_VAR 0 1
85093: PPUSH
85094: CALL_OW 437
85098: PUSH
85099: LD_INT 0
85101: GREATER
85102: IFFALSE 85172
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85104: LD_VAR 0 1
85108: PPUSH
85109: CALL_OW 437
85113: PUSH
85114: LD_INT 1
85116: ARRAY
85117: PUSH
85118: LD_INT 1
85120: ARRAY
85121: PUSH
85122: LD_STRING l
85124: EQUAL
85125: PUSH
85126: LD_VAR 0 1
85130: PPUSH
85131: CALL_OW 437
85135: PUSH
85136: LD_INT 1
85138: ARRAY
85139: PUSH
85140: LD_INT 4
85142: ARRAY
85143: PUSH
85144: LD_VAR 0 2
85148: EQUAL
85149: AND
85150: IFFALSE 85162
// result := true else
85152: LD_ADDR_VAR 0 3
85156: PUSH
85157: LD_INT 1
85159: ST_TO_ADDR
85160: GO 85170
// result := false ;
85162: LD_ADDR_VAR 0 3
85166: PUSH
85167: LD_INT 0
85169: ST_TO_ADDR
// end else
85170: GO 85180
// result := false ;
85172: LD_ADDR_VAR 0 3
85176: PUSH
85177: LD_INT 0
85179: ST_TO_ADDR
// end ;
85180: LD_VAR 0 3
85184: RET
// export function HealTarget ( sci ) ; begin
85185: LD_INT 0
85187: PPUSH
// if not sci then
85188: LD_VAR 0 1
85192: NOT
85193: IFFALSE 85197
// exit ;
85195: GO 85262
// result := 0 ;
85197: LD_ADDR_VAR 0 2
85201: PUSH
85202: LD_INT 0
85204: ST_TO_ADDR
// if GetTaskList ( sci ) then
85205: LD_VAR 0 1
85209: PPUSH
85210: CALL_OW 437
85214: IFFALSE 85262
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85216: LD_VAR 0 1
85220: PPUSH
85221: CALL_OW 437
85225: PUSH
85226: LD_INT 1
85228: ARRAY
85229: PUSH
85230: LD_INT 1
85232: ARRAY
85233: PUSH
85234: LD_STRING l
85236: EQUAL
85237: IFFALSE 85262
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85239: LD_ADDR_VAR 0 2
85243: PUSH
85244: LD_VAR 0 1
85248: PPUSH
85249: CALL_OW 437
85253: PUSH
85254: LD_INT 1
85256: ARRAY
85257: PUSH
85258: LD_INT 4
85260: ARRAY
85261: ST_TO_ADDR
// end ;
85262: LD_VAR 0 2
85266: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
85267: LD_INT 0
85269: PPUSH
85270: PPUSH
85271: PPUSH
85272: PPUSH
// if not base_units then
85273: LD_VAR 0 1
85277: NOT
85278: IFFALSE 85282
// exit ;
85280: GO 85369
// result := false ;
85282: LD_ADDR_VAR 0 2
85286: PUSH
85287: LD_INT 0
85289: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
85290: LD_ADDR_VAR 0 5
85294: PUSH
85295: LD_VAR 0 1
85299: PPUSH
85300: LD_INT 21
85302: PUSH
85303: LD_INT 3
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PPUSH
85310: CALL_OW 72
85314: ST_TO_ADDR
// if not tmp then
85315: LD_VAR 0 5
85319: NOT
85320: IFFALSE 85324
// exit ;
85322: GO 85369
// for i in tmp do
85324: LD_ADDR_VAR 0 3
85328: PUSH
85329: LD_VAR 0 5
85333: PUSH
85334: FOR_IN
85335: IFFALSE 85367
// begin result := EnemyInRange ( i , 22 ) ;
85337: LD_ADDR_VAR 0 2
85341: PUSH
85342: LD_VAR 0 3
85346: PPUSH
85347: LD_INT 22
85349: PPUSH
85350: CALL 83605 0 2
85354: ST_TO_ADDR
// if result then
85355: LD_VAR 0 2
85359: IFFALSE 85365
// exit ;
85361: POP
85362: POP
85363: GO 85369
// end ;
85365: GO 85334
85367: POP
85368: POP
// end ;
85369: LD_VAR 0 2
85373: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
85374: LD_INT 0
85376: PPUSH
85377: PPUSH
// if not units then
85378: LD_VAR 0 1
85382: NOT
85383: IFFALSE 85387
// exit ;
85385: GO 85457
// result := [ ] ;
85387: LD_ADDR_VAR 0 3
85391: PUSH
85392: EMPTY
85393: ST_TO_ADDR
// for i in units do
85394: LD_ADDR_VAR 0 4
85398: PUSH
85399: LD_VAR 0 1
85403: PUSH
85404: FOR_IN
85405: IFFALSE 85455
// if GetTag ( i ) = tag then
85407: LD_VAR 0 4
85411: PPUSH
85412: CALL_OW 110
85416: PUSH
85417: LD_VAR 0 2
85421: EQUAL
85422: IFFALSE 85453
// result := Insert ( result , result + 1 , i ) ;
85424: LD_ADDR_VAR 0 3
85428: PUSH
85429: LD_VAR 0 3
85433: PPUSH
85434: LD_VAR 0 3
85438: PUSH
85439: LD_INT 1
85441: PLUS
85442: PPUSH
85443: LD_VAR 0 4
85447: PPUSH
85448: CALL_OW 2
85452: ST_TO_ADDR
85453: GO 85404
85455: POP
85456: POP
// end ;
85457: LD_VAR 0 3
85461: RET
// export function IsDriver ( un ) ; begin
85462: LD_INT 0
85464: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
85465: LD_ADDR_VAR 0 2
85469: PUSH
85470: LD_VAR 0 1
85474: PUSH
85475: LD_INT 55
85477: PUSH
85478: EMPTY
85479: LIST
85480: PPUSH
85481: CALL_OW 69
85485: IN
85486: ST_TO_ADDR
// end ;
85487: LD_VAR 0 2
85491: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
85492: LD_INT 0
85494: PPUSH
85495: PPUSH
// list := [ ] ;
85496: LD_ADDR_VAR 0 5
85500: PUSH
85501: EMPTY
85502: ST_TO_ADDR
// case d of 0 :
85503: LD_VAR 0 3
85507: PUSH
85508: LD_INT 0
85510: DOUBLE
85511: EQUAL
85512: IFTRUE 85516
85514: GO 85649
85516: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
85517: LD_ADDR_VAR 0 5
85521: PUSH
85522: LD_VAR 0 1
85526: PUSH
85527: LD_INT 4
85529: MINUS
85530: PUSH
85531: LD_VAR 0 2
85535: PUSH
85536: LD_INT 4
85538: MINUS
85539: PUSH
85540: LD_INT 2
85542: PUSH
85543: EMPTY
85544: LIST
85545: LIST
85546: LIST
85547: PUSH
85548: LD_VAR 0 1
85552: PUSH
85553: LD_INT 3
85555: MINUS
85556: PUSH
85557: LD_VAR 0 2
85561: PUSH
85562: LD_INT 1
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: LIST
85569: PUSH
85570: LD_VAR 0 1
85574: PUSH
85575: LD_INT 4
85577: PLUS
85578: PUSH
85579: LD_VAR 0 2
85583: PUSH
85584: LD_INT 4
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: LIST
85591: PUSH
85592: LD_VAR 0 1
85596: PUSH
85597: LD_INT 3
85599: PLUS
85600: PUSH
85601: LD_VAR 0 2
85605: PUSH
85606: LD_INT 3
85608: PLUS
85609: PUSH
85610: LD_INT 5
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: LIST
85617: PUSH
85618: LD_VAR 0 1
85622: PUSH
85623: LD_VAR 0 2
85627: PUSH
85628: LD_INT 4
85630: PLUS
85631: PUSH
85632: LD_INT 0
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: LIST
85639: PUSH
85640: EMPTY
85641: LIST
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: ST_TO_ADDR
// end ; 1 :
85647: GO 86347
85649: LD_INT 1
85651: DOUBLE
85652: EQUAL
85653: IFTRUE 85657
85655: GO 85790
85657: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
85658: LD_ADDR_VAR 0 5
85662: PUSH
85663: LD_VAR 0 1
85667: PUSH
85668: LD_VAR 0 2
85672: PUSH
85673: LD_INT 4
85675: MINUS
85676: PUSH
85677: LD_INT 3
85679: PUSH
85680: EMPTY
85681: LIST
85682: LIST
85683: LIST
85684: PUSH
85685: LD_VAR 0 1
85689: PUSH
85690: LD_INT 3
85692: MINUS
85693: PUSH
85694: LD_VAR 0 2
85698: PUSH
85699: LD_INT 3
85701: MINUS
85702: PUSH
85703: LD_INT 2
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: LIST
85710: PUSH
85711: LD_VAR 0 1
85715: PUSH
85716: LD_INT 4
85718: MINUS
85719: PUSH
85720: LD_VAR 0 2
85724: PUSH
85725: LD_INT 1
85727: PUSH
85728: EMPTY
85729: LIST
85730: LIST
85731: LIST
85732: PUSH
85733: LD_VAR 0 1
85737: PUSH
85738: LD_VAR 0 2
85742: PUSH
85743: LD_INT 3
85745: PLUS
85746: PUSH
85747: LD_INT 0
85749: PUSH
85750: EMPTY
85751: LIST
85752: LIST
85753: LIST
85754: PUSH
85755: LD_VAR 0 1
85759: PUSH
85760: LD_INT 4
85762: PLUS
85763: PUSH
85764: LD_VAR 0 2
85768: PUSH
85769: LD_INT 4
85771: PLUS
85772: PUSH
85773: LD_INT 5
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: LIST
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: ST_TO_ADDR
// end ; 2 :
85788: GO 86347
85790: LD_INT 2
85792: DOUBLE
85793: EQUAL
85794: IFTRUE 85798
85796: GO 85927
85798: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
85799: LD_ADDR_VAR 0 5
85803: PUSH
85804: LD_VAR 0 1
85808: PUSH
85809: LD_VAR 0 2
85813: PUSH
85814: LD_INT 3
85816: MINUS
85817: PUSH
85818: LD_INT 3
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: LIST
85825: PUSH
85826: LD_VAR 0 1
85830: PUSH
85831: LD_INT 4
85833: PLUS
85834: PUSH
85835: LD_VAR 0 2
85839: PUSH
85840: LD_INT 4
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: LIST
85847: PUSH
85848: LD_VAR 0 1
85852: PUSH
85853: LD_VAR 0 2
85857: PUSH
85858: LD_INT 4
85860: PLUS
85861: PUSH
85862: LD_INT 0
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: LIST
85869: PUSH
85870: LD_VAR 0 1
85874: PUSH
85875: LD_INT 3
85877: MINUS
85878: PUSH
85879: LD_VAR 0 2
85883: PUSH
85884: LD_INT 1
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: LIST
85891: PUSH
85892: LD_VAR 0 1
85896: PUSH
85897: LD_INT 4
85899: MINUS
85900: PUSH
85901: LD_VAR 0 2
85905: PUSH
85906: LD_INT 4
85908: MINUS
85909: PUSH
85910: LD_INT 2
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: LIST
85917: PUSH
85918: EMPTY
85919: LIST
85920: LIST
85921: LIST
85922: LIST
85923: LIST
85924: ST_TO_ADDR
// end ; 3 :
85925: GO 86347
85927: LD_INT 3
85929: DOUBLE
85930: EQUAL
85931: IFTRUE 85935
85933: GO 86068
85935: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
85936: LD_ADDR_VAR 0 5
85940: PUSH
85941: LD_VAR 0 1
85945: PUSH
85946: LD_INT 3
85948: PLUS
85949: PUSH
85950: LD_VAR 0 2
85954: PUSH
85955: LD_INT 4
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: LIST
85962: PUSH
85963: LD_VAR 0 1
85967: PUSH
85968: LD_INT 4
85970: PLUS
85971: PUSH
85972: LD_VAR 0 2
85976: PUSH
85977: LD_INT 4
85979: PLUS
85980: PUSH
85981: LD_INT 5
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: LIST
85988: PUSH
85989: LD_VAR 0 1
85993: PUSH
85994: LD_INT 4
85996: MINUS
85997: PUSH
85998: LD_VAR 0 2
86002: PUSH
86003: LD_INT 1
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: LIST
86010: PUSH
86011: LD_VAR 0 1
86015: PUSH
86016: LD_VAR 0 2
86020: PUSH
86021: LD_INT 4
86023: MINUS
86024: PUSH
86025: LD_INT 3
86027: PUSH
86028: EMPTY
86029: LIST
86030: LIST
86031: LIST
86032: PUSH
86033: LD_VAR 0 1
86037: PUSH
86038: LD_INT 3
86040: MINUS
86041: PUSH
86042: LD_VAR 0 2
86046: PUSH
86047: LD_INT 3
86049: MINUS
86050: PUSH
86051: LD_INT 2
86053: PUSH
86054: EMPTY
86055: LIST
86056: LIST
86057: LIST
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: LIST
86063: LIST
86064: LIST
86065: ST_TO_ADDR
// end ; 4 :
86066: GO 86347
86068: LD_INT 4
86070: DOUBLE
86071: EQUAL
86072: IFTRUE 86076
86074: GO 86209
86076: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
86077: LD_ADDR_VAR 0 5
86081: PUSH
86082: LD_VAR 0 1
86086: PUSH
86087: LD_VAR 0 2
86091: PUSH
86092: LD_INT 4
86094: PLUS
86095: PUSH
86096: LD_INT 0
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: LIST
86103: PUSH
86104: LD_VAR 0 1
86108: PUSH
86109: LD_INT 3
86111: PLUS
86112: PUSH
86113: LD_VAR 0 2
86117: PUSH
86118: LD_INT 3
86120: PLUS
86121: PUSH
86122: LD_INT 5
86124: PUSH
86125: EMPTY
86126: LIST
86127: LIST
86128: LIST
86129: PUSH
86130: LD_VAR 0 1
86134: PUSH
86135: LD_INT 4
86137: PLUS
86138: PUSH
86139: LD_VAR 0 2
86143: PUSH
86144: LD_INT 4
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: LIST
86151: PUSH
86152: LD_VAR 0 1
86156: PUSH
86157: LD_VAR 0 2
86161: PUSH
86162: LD_INT 3
86164: MINUS
86165: PUSH
86166: LD_INT 3
86168: PUSH
86169: EMPTY
86170: LIST
86171: LIST
86172: LIST
86173: PUSH
86174: LD_VAR 0 1
86178: PUSH
86179: LD_INT 4
86181: MINUS
86182: PUSH
86183: LD_VAR 0 2
86187: PUSH
86188: LD_INT 4
86190: MINUS
86191: PUSH
86192: LD_INT 2
86194: PUSH
86195: EMPTY
86196: LIST
86197: LIST
86198: LIST
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: ST_TO_ADDR
// end ; 5 :
86207: GO 86347
86209: LD_INT 5
86211: DOUBLE
86212: EQUAL
86213: IFTRUE 86217
86215: GO 86346
86217: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
86218: LD_ADDR_VAR 0 5
86222: PUSH
86223: LD_VAR 0 1
86227: PUSH
86228: LD_INT 4
86230: MINUS
86231: PUSH
86232: LD_VAR 0 2
86236: PUSH
86237: LD_INT 1
86239: PUSH
86240: EMPTY
86241: LIST
86242: LIST
86243: LIST
86244: PUSH
86245: LD_VAR 0 1
86249: PUSH
86250: LD_VAR 0 2
86254: PUSH
86255: LD_INT 4
86257: MINUS
86258: PUSH
86259: LD_INT 3
86261: PUSH
86262: EMPTY
86263: LIST
86264: LIST
86265: LIST
86266: PUSH
86267: LD_VAR 0 1
86271: PUSH
86272: LD_INT 4
86274: PLUS
86275: PUSH
86276: LD_VAR 0 2
86280: PUSH
86281: LD_INT 4
86283: PLUS
86284: PUSH
86285: LD_INT 5
86287: PUSH
86288: EMPTY
86289: LIST
86290: LIST
86291: LIST
86292: PUSH
86293: LD_VAR 0 1
86297: PUSH
86298: LD_INT 3
86300: PLUS
86301: PUSH
86302: LD_VAR 0 2
86306: PUSH
86307: LD_INT 4
86309: PUSH
86310: EMPTY
86311: LIST
86312: LIST
86313: LIST
86314: PUSH
86315: LD_VAR 0 1
86319: PUSH
86320: LD_VAR 0 2
86324: PUSH
86325: LD_INT 3
86327: PLUS
86328: PUSH
86329: LD_INT 0
86331: PUSH
86332: EMPTY
86333: LIST
86334: LIST
86335: LIST
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: LIST
86341: LIST
86342: LIST
86343: ST_TO_ADDR
// end ; end ;
86344: GO 86347
86346: POP
// result := list ;
86347: LD_ADDR_VAR 0 4
86351: PUSH
86352: LD_VAR 0 5
86356: ST_TO_ADDR
// end ;
86357: LD_VAR 0 4
86361: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
86362: LD_INT 0
86364: PPUSH
86365: PPUSH
86366: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
86367: LD_VAR 0 1
86371: NOT
86372: PUSH
86373: LD_VAR 0 2
86377: PUSH
86378: LD_INT 1
86380: PUSH
86381: LD_INT 2
86383: PUSH
86384: LD_INT 3
86386: PUSH
86387: LD_INT 4
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: LIST
86394: LIST
86395: IN
86396: NOT
86397: OR
86398: IFFALSE 86402
// exit ;
86400: GO 86494
// tmp := [ ] ;
86402: LD_ADDR_VAR 0 5
86406: PUSH
86407: EMPTY
86408: ST_TO_ADDR
// for i in units do
86409: LD_ADDR_VAR 0 4
86413: PUSH
86414: LD_VAR 0 1
86418: PUSH
86419: FOR_IN
86420: IFFALSE 86463
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
86422: LD_ADDR_VAR 0 5
86426: PUSH
86427: LD_VAR 0 5
86431: PPUSH
86432: LD_VAR 0 5
86436: PUSH
86437: LD_INT 1
86439: PLUS
86440: PPUSH
86441: LD_VAR 0 4
86445: PPUSH
86446: LD_VAR 0 2
86450: PPUSH
86451: CALL_OW 259
86455: PPUSH
86456: CALL_OW 2
86460: ST_TO_ADDR
86461: GO 86419
86463: POP
86464: POP
// if not tmp then
86465: LD_VAR 0 5
86469: NOT
86470: IFFALSE 86474
// exit ;
86472: GO 86494
// result := SortListByListDesc ( units , tmp ) ;
86474: LD_ADDR_VAR 0 3
86478: PUSH
86479: LD_VAR 0 1
86483: PPUSH
86484: LD_VAR 0 5
86488: PPUSH
86489: CALL_OW 77
86493: ST_TO_ADDR
// end ;
86494: LD_VAR 0 3
86498: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
86499: LD_INT 0
86501: PPUSH
86502: PPUSH
86503: PPUSH
// result := false ;
86504: LD_ADDR_VAR 0 3
86508: PUSH
86509: LD_INT 0
86511: ST_TO_ADDR
// x := GetX ( building ) ;
86512: LD_ADDR_VAR 0 4
86516: PUSH
86517: LD_VAR 0 2
86521: PPUSH
86522: CALL_OW 250
86526: ST_TO_ADDR
// y := GetY ( building ) ;
86527: LD_ADDR_VAR 0 5
86531: PUSH
86532: LD_VAR 0 2
86536: PPUSH
86537: CALL_OW 251
86541: ST_TO_ADDR
// if not building or not x or not y then
86542: LD_VAR 0 2
86546: NOT
86547: PUSH
86548: LD_VAR 0 4
86552: NOT
86553: OR
86554: PUSH
86555: LD_VAR 0 5
86559: NOT
86560: OR
86561: IFFALSE 86565
// exit ;
86563: GO 86657
// if GetTaskList ( unit ) then
86565: LD_VAR 0 1
86569: PPUSH
86570: CALL_OW 437
86574: IFFALSE 86657
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86576: LD_STRING e
86578: PUSH
86579: LD_VAR 0 1
86583: PPUSH
86584: CALL_OW 437
86588: PUSH
86589: LD_INT 1
86591: ARRAY
86592: PUSH
86593: LD_INT 1
86595: ARRAY
86596: EQUAL
86597: PUSH
86598: LD_VAR 0 4
86602: PUSH
86603: LD_VAR 0 1
86607: PPUSH
86608: CALL_OW 437
86612: PUSH
86613: LD_INT 1
86615: ARRAY
86616: PUSH
86617: LD_INT 2
86619: ARRAY
86620: EQUAL
86621: AND
86622: PUSH
86623: LD_VAR 0 5
86627: PUSH
86628: LD_VAR 0 1
86632: PPUSH
86633: CALL_OW 437
86637: PUSH
86638: LD_INT 1
86640: ARRAY
86641: PUSH
86642: LD_INT 3
86644: ARRAY
86645: EQUAL
86646: AND
86647: IFFALSE 86657
// result := true end ;
86649: LD_ADDR_VAR 0 3
86653: PUSH
86654: LD_INT 1
86656: ST_TO_ADDR
// end ;
86657: LD_VAR 0 3
86661: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
86662: LD_INT 0
86664: PPUSH
// result := false ;
86665: LD_ADDR_VAR 0 4
86669: PUSH
86670: LD_INT 0
86672: ST_TO_ADDR
// if GetTaskList ( unit ) then
86673: LD_VAR 0 1
86677: PPUSH
86678: CALL_OW 437
86682: IFFALSE 86765
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86684: LD_STRING M
86686: PUSH
86687: LD_VAR 0 1
86691: PPUSH
86692: CALL_OW 437
86696: PUSH
86697: LD_INT 1
86699: ARRAY
86700: PUSH
86701: LD_INT 1
86703: ARRAY
86704: EQUAL
86705: PUSH
86706: LD_VAR 0 2
86710: PUSH
86711: LD_VAR 0 1
86715: PPUSH
86716: CALL_OW 437
86720: PUSH
86721: LD_INT 1
86723: ARRAY
86724: PUSH
86725: LD_INT 2
86727: ARRAY
86728: EQUAL
86729: AND
86730: PUSH
86731: LD_VAR 0 3
86735: PUSH
86736: LD_VAR 0 1
86740: PPUSH
86741: CALL_OW 437
86745: PUSH
86746: LD_INT 1
86748: ARRAY
86749: PUSH
86750: LD_INT 3
86752: ARRAY
86753: EQUAL
86754: AND
86755: IFFALSE 86765
// result := true ;
86757: LD_ADDR_VAR 0 4
86761: PUSH
86762: LD_INT 1
86764: ST_TO_ADDR
// end ; end ;
86765: LD_VAR 0 4
86769: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
86770: LD_INT 0
86772: PPUSH
86773: PPUSH
86774: PPUSH
86775: PPUSH
// if not unit or not area then
86776: LD_VAR 0 1
86780: NOT
86781: PUSH
86782: LD_VAR 0 2
86786: NOT
86787: OR
86788: IFFALSE 86792
// exit ;
86790: GO 86956
// tmp := AreaToList ( area , i ) ;
86792: LD_ADDR_VAR 0 6
86796: PUSH
86797: LD_VAR 0 2
86801: PPUSH
86802: LD_VAR 0 5
86806: PPUSH
86807: CALL_OW 517
86811: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
86812: LD_ADDR_VAR 0 5
86816: PUSH
86817: DOUBLE
86818: LD_INT 1
86820: DEC
86821: ST_TO_ADDR
86822: LD_VAR 0 6
86826: PUSH
86827: LD_INT 1
86829: ARRAY
86830: PUSH
86831: FOR_TO
86832: IFFALSE 86954
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
86834: LD_ADDR_VAR 0 7
86838: PUSH
86839: LD_VAR 0 6
86843: PUSH
86844: LD_INT 1
86846: ARRAY
86847: PUSH
86848: LD_VAR 0 5
86852: ARRAY
86853: PUSH
86854: LD_VAR 0 6
86858: PUSH
86859: LD_INT 2
86861: ARRAY
86862: PUSH
86863: LD_VAR 0 5
86867: ARRAY
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
86873: LD_VAR 0 7
86877: PUSH
86878: LD_INT 1
86880: ARRAY
86881: PPUSH
86882: LD_VAR 0 7
86886: PUSH
86887: LD_INT 2
86889: ARRAY
86890: PPUSH
86891: CALL_OW 428
86895: PUSH
86896: LD_INT 0
86898: EQUAL
86899: IFFALSE 86952
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
86901: LD_VAR 0 1
86905: PPUSH
86906: LD_VAR 0 7
86910: PUSH
86911: LD_INT 1
86913: ARRAY
86914: PPUSH
86915: LD_VAR 0 7
86919: PUSH
86920: LD_INT 2
86922: ARRAY
86923: PPUSH
86924: LD_VAR 0 3
86928: PPUSH
86929: CALL_OW 48
// result := IsPlaced ( unit ) ;
86933: LD_ADDR_VAR 0 4
86937: PUSH
86938: LD_VAR 0 1
86942: PPUSH
86943: CALL_OW 305
86947: ST_TO_ADDR
// exit ;
86948: POP
86949: POP
86950: GO 86956
// end ; end ;
86952: GO 86831
86954: POP
86955: POP
// end ;
86956: LD_VAR 0 4
86960: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
86961: LD_INT 0
86963: PPUSH
86964: PPUSH
86965: PPUSH
// if not side or side > 8 then
86966: LD_VAR 0 1
86970: NOT
86971: PUSH
86972: LD_VAR 0 1
86976: PUSH
86977: LD_INT 8
86979: GREATER
86980: OR
86981: IFFALSE 86985
// exit ;
86983: GO 87172
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
86985: LD_ADDR_VAR 0 4
86989: PUSH
86990: LD_INT 22
86992: PUSH
86993: LD_VAR 0 1
86997: PUSH
86998: EMPTY
86999: LIST
87000: LIST
87001: PUSH
87002: LD_INT 21
87004: PUSH
87005: LD_INT 3
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: PUSH
87012: EMPTY
87013: LIST
87014: LIST
87015: PPUSH
87016: CALL_OW 69
87020: ST_TO_ADDR
// if not tmp then
87021: LD_VAR 0 4
87025: NOT
87026: IFFALSE 87030
// exit ;
87028: GO 87172
// enable_addtolog := true ;
87030: LD_ADDR_OWVAR 81
87034: PUSH
87035: LD_INT 1
87037: ST_TO_ADDR
// AddToLog ( [ ) ;
87038: LD_STRING [
87040: PPUSH
87041: CALL_OW 561
// for i in tmp do
87045: LD_ADDR_VAR 0 3
87049: PUSH
87050: LD_VAR 0 4
87054: PUSH
87055: FOR_IN
87056: IFFALSE 87163
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
87058: LD_STRING [
87060: PUSH
87061: LD_VAR 0 3
87065: PPUSH
87066: CALL_OW 266
87070: STR
87071: PUSH
87072: LD_STRING , 
87074: STR
87075: PUSH
87076: LD_VAR 0 3
87080: PPUSH
87081: CALL_OW 250
87085: STR
87086: PUSH
87087: LD_STRING , 
87089: STR
87090: PUSH
87091: LD_VAR 0 3
87095: PPUSH
87096: CALL_OW 251
87100: STR
87101: PUSH
87102: LD_STRING , 
87104: STR
87105: PUSH
87106: LD_VAR 0 3
87110: PPUSH
87111: CALL_OW 254
87115: STR
87116: PUSH
87117: LD_STRING , 
87119: STR
87120: PUSH
87121: LD_VAR 0 3
87125: PPUSH
87126: LD_INT 1
87128: PPUSH
87129: CALL_OW 268
87133: STR
87134: PUSH
87135: LD_STRING , 
87137: STR
87138: PUSH
87139: LD_VAR 0 3
87143: PPUSH
87144: LD_INT 2
87146: PPUSH
87147: CALL_OW 268
87151: STR
87152: PUSH
87153: LD_STRING ],
87155: STR
87156: PPUSH
87157: CALL_OW 561
// end ;
87161: GO 87055
87163: POP
87164: POP
// AddToLog ( ]; ) ;
87165: LD_STRING ];
87167: PPUSH
87168: CALL_OW 561
// end ;
87172: LD_VAR 0 2
87176: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
87177: LD_INT 0
87179: PPUSH
87180: PPUSH
87181: PPUSH
87182: PPUSH
87183: PPUSH
// if not area or not rate or not max then
87184: LD_VAR 0 1
87188: NOT
87189: PUSH
87190: LD_VAR 0 2
87194: NOT
87195: OR
87196: PUSH
87197: LD_VAR 0 4
87201: NOT
87202: OR
87203: IFFALSE 87207
// exit ;
87205: GO 87399
// while 1 do
87207: LD_INT 1
87209: IFFALSE 87399
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
87211: LD_ADDR_VAR 0 9
87215: PUSH
87216: LD_VAR 0 1
87220: PPUSH
87221: LD_INT 1
87223: PPUSH
87224: CALL_OW 287
87228: PUSH
87229: LD_INT 10
87231: MUL
87232: ST_TO_ADDR
// r := rate / 10 ;
87233: LD_ADDR_VAR 0 7
87237: PUSH
87238: LD_VAR 0 2
87242: PUSH
87243: LD_INT 10
87245: DIVREAL
87246: ST_TO_ADDR
// time := 1 1$00 ;
87247: LD_ADDR_VAR 0 8
87251: PUSH
87252: LD_INT 2100
87254: ST_TO_ADDR
// if amount < min then
87255: LD_VAR 0 9
87259: PUSH
87260: LD_VAR 0 3
87264: LESS
87265: IFFALSE 87283
// r := r * 2 else
87267: LD_ADDR_VAR 0 7
87271: PUSH
87272: LD_VAR 0 7
87276: PUSH
87277: LD_INT 2
87279: MUL
87280: ST_TO_ADDR
87281: GO 87309
// if amount > max then
87283: LD_VAR 0 9
87287: PUSH
87288: LD_VAR 0 4
87292: GREATER
87293: IFFALSE 87309
// r := r / 2 ;
87295: LD_ADDR_VAR 0 7
87299: PUSH
87300: LD_VAR 0 7
87304: PUSH
87305: LD_INT 2
87307: DIVREAL
87308: ST_TO_ADDR
// time := time / r ;
87309: LD_ADDR_VAR 0 8
87313: PUSH
87314: LD_VAR 0 8
87318: PUSH
87319: LD_VAR 0 7
87323: DIVREAL
87324: ST_TO_ADDR
// if time < 0 then
87325: LD_VAR 0 8
87329: PUSH
87330: LD_INT 0
87332: LESS
87333: IFFALSE 87350
// time := time * - 1 ;
87335: LD_ADDR_VAR 0 8
87339: PUSH
87340: LD_VAR 0 8
87344: PUSH
87345: LD_INT 1
87347: NEG
87348: MUL
87349: ST_TO_ADDR
// wait ( time ) ;
87350: LD_VAR 0 8
87354: PPUSH
87355: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
87359: LD_INT 35
87361: PPUSH
87362: LD_INT 875
87364: PPUSH
87365: CALL_OW 12
87369: PPUSH
87370: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
87374: LD_INT 1
87376: PPUSH
87377: LD_INT 5
87379: PPUSH
87380: CALL_OW 12
87384: PPUSH
87385: LD_VAR 0 1
87389: PPUSH
87390: LD_INT 1
87392: PPUSH
87393: CALL_OW 55
// end ;
87397: GO 87207
// end ;
87399: LD_VAR 0 5
87403: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
87404: LD_INT 0
87406: PPUSH
87407: PPUSH
87408: PPUSH
87409: PPUSH
87410: PPUSH
87411: PPUSH
87412: PPUSH
87413: PPUSH
// if not turrets or not factories then
87414: LD_VAR 0 1
87418: NOT
87419: PUSH
87420: LD_VAR 0 2
87424: NOT
87425: OR
87426: IFFALSE 87430
// exit ;
87428: GO 87737
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
87430: LD_ADDR_VAR 0 10
87434: PUSH
87435: LD_INT 5
87437: PUSH
87438: LD_INT 6
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: PUSH
87445: LD_INT 2
87447: PUSH
87448: LD_INT 4
87450: PUSH
87451: EMPTY
87452: LIST
87453: LIST
87454: PUSH
87455: LD_INT 3
87457: PUSH
87458: LD_INT 5
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: LIST
87469: PUSH
87470: LD_INT 24
87472: PUSH
87473: LD_INT 25
87475: PUSH
87476: EMPTY
87477: LIST
87478: LIST
87479: PUSH
87480: LD_INT 23
87482: PUSH
87483: LD_INT 27
87485: PUSH
87486: EMPTY
87487: LIST
87488: LIST
87489: PUSH
87490: EMPTY
87491: LIST
87492: LIST
87493: PUSH
87494: LD_INT 42
87496: PUSH
87497: LD_INT 43
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PUSH
87504: LD_INT 44
87506: PUSH
87507: LD_INT 46
87509: PUSH
87510: EMPTY
87511: LIST
87512: LIST
87513: PUSH
87514: LD_INT 45
87516: PUSH
87517: LD_INT 47
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: LIST
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: LIST
87533: ST_TO_ADDR
// result := [ ] ;
87534: LD_ADDR_VAR 0 3
87538: PUSH
87539: EMPTY
87540: ST_TO_ADDR
// for i in turrets do
87541: LD_ADDR_VAR 0 4
87545: PUSH
87546: LD_VAR 0 1
87550: PUSH
87551: FOR_IN
87552: IFFALSE 87735
// begin nat := GetNation ( i ) ;
87554: LD_ADDR_VAR 0 7
87558: PUSH
87559: LD_VAR 0 4
87563: PPUSH
87564: CALL_OW 248
87568: ST_TO_ADDR
// weapon := 0 ;
87569: LD_ADDR_VAR 0 8
87573: PUSH
87574: LD_INT 0
87576: ST_TO_ADDR
// if not nat then
87577: LD_VAR 0 7
87581: NOT
87582: IFFALSE 87586
// continue ;
87584: GO 87551
// for j in list [ nat ] do
87586: LD_ADDR_VAR 0 5
87590: PUSH
87591: LD_VAR 0 10
87595: PUSH
87596: LD_VAR 0 7
87600: ARRAY
87601: PUSH
87602: FOR_IN
87603: IFFALSE 87644
// if GetBWeapon ( i ) = j [ 1 ] then
87605: LD_VAR 0 4
87609: PPUSH
87610: CALL_OW 269
87614: PUSH
87615: LD_VAR 0 5
87619: PUSH
87620: LD_INT 1
87622: ARRAY
87623: EQUAL
87624: IFFALSE 87642
// begin weapon := j [ 2 ] ;
87626: LD_ADDR_VAR 0 8
87630: PUSH
87631: LD_VAR 0 5
87635: PUSH
87636: LD_INT 2
87638: ARRAY
87639: ST_TO_ADDR
// break ;
87640: GO 87644
// end ;
87642: GO 87602
87644: POP
87645: POP
// if not weapon then
87646: LD_VAR 0 8
87650: NOT
87651: IFFALSE 87655
// continue ;
87653: GO 87551
// for k in factories do
87655: LD_ADDR_VAR 0 6
87659: PUSH
87660: LD_VAR 0 2
87664: PUSH
87665: FOR_IN
87666: IFFALSE 87731
// begin weapons := AvailableWeaponList ( k ) ;
87668: LD_ADDR_VAR 0 9
87672: PUSH
87673: LD_VAR 0 6
87677: PPUSH
87678: CALL_OW 478
87682: ST_TO_ADDR
// if not weapons then
87683: LD_VAR 0 9
87687: NOT
87688: IFFALSE 87692
// continue ;
87690: GO 87665
// if weapon in weapons then
87692: LD_VAR 0 8
87696: PUSH
87697: LD_VAR 0 9
87701: IN
87702: IFFALSE 87729
// begin result := [ i , weapon ] ;
87704: LD_ADDR_VAR 0 3
87708: PUSH
87709: LD_VAR 0 4
87713: PUSH
87714: LD_VAR 0 8
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: ST_TO_ADDR
// exit ;
87723: POP
87724: POP
87725: POP
87726: POP
87727: GO 87737
// end ; end ;
87729: GO 87665
87731: POP
87732: POP
// end ;
87733: GO 87551
87735: POP
87736: POP
// end ;
87737: LD_VAR 0 3
87741: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
87742: LD_INT 0
87744: PPUSH
// if not side or side > 8 then
87745: LD_VAR 0 3
87749: NOT
87750: PUSH
87751: LD_VAR 0 3
87755: PUSH
87756: LD_INT 8
87758: GREATER
87759: OR
87760: IFFALSE 87764
// exit ;
87762: GO 87823
// if not range then
87764: LD_VAR 0 4
87768: NOT
87769: IFFALSE 87780
// range := - 12 ;
87771: LD_ADDR_VAR 0 4
87775: PUSH
87776: LD_INT 12
87778: NEG
87779: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
87780: LD_VAR 0 1
87784: PPUSH
87785: LD_VAR 0 2
87789: PPUSH
87790: LD_VAR 0 3
87794: PPUSH
87795: LD_VAR 0 4
87799: PPUSH
87800: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
87804: LD_VAR 0 1
87808: PPUSH
87809: LD_VAR 0 2
87813: PPUSH
87814: LD_VAR 0 3
87818: PPUSH
87819: CALL_OW 331
// end ;
87823: LD_VAR 0 5
87827: RET
// export function Video ( mode ) ; begin
87828: LD_INT 0
87830: PPUSH
// ingame_video = mode ;
87831: LD_ADDR_OWVAR 52
87835: PUSH
87836: LD_VAR 0 1
87840: ST_TO_ADDR
// interface_hidden = mode ;
87841: LD_ADDR_OWVAR 54
87845: PUSH
87846: LD_VAR 0 1
87850: ST_TO_ADDR
// end ;
87851: LD_VAR 0 2
87855: RET
// export function Join ( array , element ) ; begin
87856: LD_INT 0
87858: PPUSH
// result := Replace ( array , array + 1 , element ) ;
87859: LD_ADDR_VAR 0 3
87863: PUSH
87864: LD_VAR 0 1
87868: PPUSH
87869: LD_VAR 0 1
87873: PUSH
87874: LD_INT 1
87876: PLUS
87877: PPUSH
87878: LD_VAR 0 2
87882: PPUSH
87883: CALL_OW 1
87887: ST_TO_ADDR
// end ;
87888: LD_VAR 0 3
87892: RET
// export function JoinUnion ( array , element ) ; begin
87893: LD_INT 0
87895: PPUSH
// result := array union element ;
87896: LD_ADDR_VAR 0 3
87900: PUSH
87901: LD_VAR 0 1
87905: PUSH
87906: LD_VAR 0 2
87910: UNION
87911: ST_TO_ADDR
// end ;
87912: LD_VAR 0 3
87916: RET
// export function GetBehemoths ( side ) ; begin
87917: LD_INT 0
87919: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
87920: LD_ADDR_VAR 0 2
87924: PUSH
87925: LD_INT 22
87927: PUSH
87928: LD_VAR 0 1
87932: PUSH
87933: EMPTY
87934: LIST
87935: LIST
87936: PUSH
87937: LD_INT 31
87939: PUSH
87940: LD_INT 25
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PPUSH
87951: CALL_OW 69
87955: ST_TO_ADDR
// end ;
87956: LD_VAR 0 2
87960: RET
// export function Shuffle ( array ) ; var i , index ; begin
87961: LD_INT 0
87963: PPUSH
87964: PPUSH
87965: PPUSH
// result := [ ] ;
87966: LD_ADDR_VAR 0 2
87970: PUSH
87971: EMPTY
87972: ST_TO_ADDR
// if not array then
87973: LD_VAR 0 1
87977: NOT
87978: IFFALSE 87982
// exit ;
87980: GO 88081
// Randomize ;
87982: CALL_OW 10
// for i = array downto 1 do
87986: LD_ADDR_VAR 0 3
87990: PUSH
87991: DOUBLE
87992: LD_VAR 0 1
87996: INC
87997: ST_TO_ADDR
87998: LD_INT 1
88000: PUSH
88001: FOR_DOWNTO
88002: IFFALSE 88079
// begin index := rand ( 1 , array ) ;
88004: LD_ADDR_VAR 0 4
88008: PUSH
88009: LD_INT 1
88011: PPUSH
88012: LD_VAR 0 1
88016: PPUSH
88017: CALL_OW 12
88021: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
88022: LD_ADDR_VAR 0 2
88026: PUSH
88027: LD_VAR 0 2
88031: PPUSH
88032: LD_VAR 0 2
88036: PUSH
88037: LD_INT 1
88039: PLUS
88040: PPUSH
88041: LD_VAR 0 1
88045: PUSH
88046: LD_VAR 0 4
88050: ARRAY
88051: PPUSH
88052: CALL_OW 2
88056: ST_TO_ADDR
// array := Delete ( array , index ) ;
88057: LD_ADDR_VAR 0 1
88061: PUSH
88062: LD_VAR 0 1
88066: PPUSH
88067: LD_VAR 0 4
88071: PPUSH
88072: CALL_OW 3
88076: ST_TO_ADDR
// end ;
88077: GO 88001
88079: POP
88080: POP
// end ;
88081: LD_VAR 0 2
88085: RET
// export function GetBaseMaterials ( base ) ; begin
88086: LD_INT 0
88088: PPUSH
// result := [ 0 , 0 , 0 ] ;
88089: LD_ADDR_VAR 0 2
88093: PUSH
88094: LD_INT 0
88096: PUSH
88097: LD_INT 0
88099: PUSH
88100: LD_INT 0
88102: PUSH
88103: EMPTY
88104: LIST
88105: LIST
88106: LIST
88107: ST_TO_ADDR
// if not base then
88108: LD_VAR 0 1
88112: NOT
88113: IFFALSE 88117
// exit ;
88115: GO 88166
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
88117: LD_ADDR_VAR 0 2
88121: PUSH
88122: LD_VAR 0 1
88126: PPUSH
88127: LD_INT 1
88129: PPUSH
88130: CALL_OW 275
88134: PUSH
88135: LD_VAR 0 1
88139: PPUSH
88140: LD_INT 2
88142: PPUSH
88143: CALL_OW 275
88147: PUSH
88148: LD_VAR 0 1
88152: PPUSH
88153: LD_INT 3
88155: PPUSH
88156: CALL_OW 275
88160: PUSH
88161: EMPTY
88162: LIST
88163: LIST
88164: LIST
88165: ST_TO_ADDR
// end ;
88166: LD_VAR 0 2
88170: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
88171: LD_INT 0
88173: PPUSH
88174: PPUSH
// result := array ;
88175: LD_ADDR_VAR 0 3
88179: PUSH
88180: LD_VAR 0 1
88184: ST_TO_ADDR
// if size > 0 then
88185: LD_VAR 0 2
88189: PUSH
88190: LD_INT 0
88192: GREATER
88193: IFFALSE 88239
// for i := array downto size do
88195: LD_ADDR_VAR 0 4
88199: PUSH
88200: DOUBLE
88201: LD_VAR 0 1
88205: INC
88206: ST_TO_ADDR
88207: LD_VAR 0 2
88211: PUSH
88212: FOR_DOWNTO
88213: IFFALSE 88237
// result := Delete ( result , result ) ;
88215: LD_ADDR_VAR 0 3
88219: PUSH
88220: LD_VAR 0 3
88224: PPUSH
88225: LD_VAR 0 3
88229: PPUSH
88230: CALL_OW 3
88234: ST_TO_ADDR
88235: GO 88212
88237: POP
88238: POP
// end ;
88239: LD_VAR 0 3
88243: RET
// export function ComExit ( unit ) ; var tmp ; begin
88244: LD_INT 0
88246: PPUSH
88247: PPUSH
// if not IsInUnit ( unit ) then
88248: LD_VAR 0 1
88252: PPUSH
88253: CALL_OW 310
88257: NOT
88258: IFFALSE 88262
// exit ;
88260: GO 88322
// tmp := IsInUnit ( unit ) ;
88262: LD_ADDR_VAR 0 3
88266: PUSH
88267: LD_VAR 0 1
88271: PPUSH
88272: CALL_OW 310
88276: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
88277: LD_VAR 0 3
88281: PPUSH
88282: CALL_OW 247
88286: PUSH
88287: LD_INT 2
88289: EQUAL
88290: IFFALSE 88303
// ComExitVehicle ( unit ) else
88292: LD_VAR 0 1
88296: PPUSH
88297: CALL_OW 121
88301: GO 88312
// ComExitBuilding ( unit ) ;
88303: LD_VAR 0 1
88307: PPUSH
88308: CALL_OW 122
// result := tmp ;
88312: LD_ADDR_VAR 0 2
88316: PUSH
88317: LD_VAR 0 3
88321: ST_TO_ADDR
// end ;
88322: LD_VAR 0 2
88326: RET
// export function ComExitAll ( units ) ; var i ; begin
88327: LD_INT 0
88329: PPUSH
88330: PPUSH
// if not units then
88331: LD_VAR 0 1
88335: NOT
88336: IFFALSE 88340
// exit ;
88338: GO 88366
// for i in units do
88340: LD_ADDR_VAR 0 3
88344: PUSH
88345: LD_VAR 0 1
88349: PUSH
88350: FOR_IN
88351: IFFALSE 88364
// ComExit ( i ) ;
88353: LD_VAR 0 3
88357: PPUSH
88358: CALL 88244 0 1
88362: GO 88350
88364: POP
88365: POP
// end ;
88366: LD_VAR 0 2
88370: RET
// export function ResetHc ; begin
88371: LD_INT 0
88373: PPUSH
// InitHc ;
88374: CALL_OW 19
// hc_importance := 0 ;
88378: LD_ADDR_OWVAR 32
88382: PUSH
88383: LD_INT 0
88385: ST_TO_ADDR
// end ;
88386: LD_VAR 0 1
88390: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
88391: LD_INT 0
88393: PPUSH
88394: PPUSH
88395: PPUSH
// _x := ( x1 + x2 ) div 2 ;
88396: LD_ADDR_VAR 0 6
88400: PUSH
88401: LD_VAR 0 1
88405: PUSH
88406: LD_VAR 0 3
88410: PLUS
88411: PUSH
88412: LD_INT 2
88414: DIV
88415: ST_TO_ADDR
// if _x < 0 then
88416: LD_VAR 0 6
88420: PUSH
88421: LD_INT 0
88423: LESS
88424: IFFALSE 88441
// _x := _x * - 1 ;
88426: LD_ADDR_VAR 0 6
88430: PUSH
88431: LD_VAR 0 6
88435: PUSH
88436: LD_INT 1
88438: NEG
88439: MUL
88440: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
88441: LD_ADDR_VAR 0 7
88445: PUSH
88446: LD_VAR 0 2
88450: PUSH
88451: LD_VAR 0 4
88455: PLUS
88456: PUSH
88457: LD_INT 2
88459: DIV
88460: ST_TO_ADDR
// if _y < 0 then
88461: LD_VAR 0 7
88465: PUSH
88466: LD_INT 0
88468: LESS
88469: IFFALSE 88486
// _y := _y * - 1 ;
88471: LD_ADDR_VAR 0 7
88475: PUSH
88476: LD_VAR 0 7
88480: PUSH
88481: LD_INT 1
88483: NEG
88484: MUL
88485: ST_TO_ADDR
// result := [ _x , _y ] ;
88486: LD_ADDR_VAR 0 5
88490: PUSH
88491: LD_VAR 0 6
88495: PUSH
88496: LD_VAR 0 7
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: ST_TO_ADDR
// end ;
88505: LD_VAR 0 5
88509: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
88510: LD_INT 0
88512: PPUSH
88513: PPUSH
88514: PPUSH
88515: PPUSH
// task := GetTaskList ( unit ) ;
88516: LD_ADDR_VAR 0 7
88520: PUSH
88521: LD_VAR 0 1
88525: PPUSH
88526: CALL_OW 437
88530: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
88531: LD_VAR 0 7
88535: NOT
88536: PUSH
88537: LD_VAR 0 1
88541: PPUSH
88542: LD_VAR 0 2
88546: PPUSH
88547: CALL_OW 308
88551: NOT
88552: AND
88553: IFFALSE 88557
// exit ;
88555: GO 88675
// if IsInArea ( unit , area ) then
88557: LD_VAR 0 1
88561: PPUSH
88562: LD_VAR 0 2
88566: PPUSH
88567: CALL_OW 308
88571: IFFALSE 88589
// begin ComMoveToArea ( unit , goAway ) ;
88573: LD_VAR 0 1
88577: PPUSH
88578: LD_VAR 0 3
88582: PPUSH
88583: CALL_OW 113
// exit ;
88587: GO 88675
// end ; if task [ 1 ] [ 1 ] <> M then
88589: LD_VAR 0 7
88593: PUSH
88594: LD_INT 1
88596: ARRAY
88597: PUSH
88598: LD_INT 1
88600: ARRAY
88601: PUSH
88602: LD_STRING M
88604: NONEQUAL
88605: IFFALSE 88609
// exit ;
88607: GO 88675
// x := task [ 1 ] [ 2 ] ;
88609: LD_ADDR_VAR 0 5
88613: PUSH
88614: LD_VAR 0 7
88618: PUSH
88619: LD_INT 1
88621: ARRAY
88622: PUSH
88623: LD_INT 2
88625: ARRAY
88626: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
88627: LD_ADDR_VAR 0 6
88631: PUSH
88632: LD_VAR 0 7
88636: PUSH
88637: LD_INT 1
88639: ARRAY
88640: PUSH
88641: LD_INT 3
88643: ARRAY
88644: ST_TO_ADDR
// if InArea ( x , y , area ) then
88645: LD_VAR 0 5
88649: PPUSH
88650: LD_VAR 0 6
88654: PPUSH
88655: LD_VAR 0 2
88659: PPUSH
88660: CALL_OW 309
88664: IFFALSE 88675
// ComStop ( unit ) ;
88666: LD_VAR 0 1
88670: PPUSH
88671: CALL_OW 141
// end ;
88675: LD_VAR 0 4
88679: RET
// export function Abs ( value ) ; begin
88680: LD_INT 0
88682: PPUSH
// result := value ;
88683: LD_ADDR_VAR 0 2
88687: PUSH
88688: LD_VAR 0 1
88692: ST_TO_ADDR
// if value < 0 then
88693: LD_VAR 0 1
88697: PUSH
88698: LD_INT 0
88700: LESS
88701: IFFALSE 88718
// result := value * - 1 ;
88703: LD_ADDR_VAR 0 2
88707: PUSH
88708: LD_VAR 0 1
88712: PUSH
88713: LD_INT 1
88715: NEG
88716: MUL
88717: ST_TO_ADDR
// end ;
88718: LD_VAR 0 2
88722: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
88723: LD_INT 0
88725: PPUSH
88726: PPUSH
88727: PPUSH
88728: PPUSH
88729: PPUSH
88730: PPUSH
88731: PPUSH
88732: PPUSH
// if not unit or not building then
88733: LD_VAR 0 1
88737: NOT
88738: PUSH
88739: LD_VAR 0 2
88743: NOT
88744: OR
88745: IFFALSE 88749
// exit ;
88747: GO 88975
// x := GetX ( building ) ;
88749: LD_ADDR_VAR 0 4
88753: PUSH
88754: LD_VAR 0 2
88758: PPUSH
88759: CALL_OW 250
88763: ST_TO_ADDR
// y := GetY ( building ) ;
88764: LD_ADDR_VAR 0 6
88768: PUSH
88769: LD_VAR 0 2
88773: PPUSH
88774: CALL_OW 251
88778: ST_TO_ADDR
// d := GetDir ( building ) ;
88779: LD_ADDR_VAR 0 8
88783: PUSH
88784: LD_VAR 0 2
88788: PPUSH
88789: CALL_OW 254
88793: ST_TO_ADDR
// r := 4 ;
88794: LD_ADDR_VAR 0 9
88798: PUSH
88799: LD_INT 4
88801: ST_TO_ADDR
// for i := 1 to 5 do
88802: LD_ADDR_VAR 0 10
88806: PUSH
88807: DOUBLE
88808: LD_INT 1
88810: DEC
88811: ST_TO_ADDR
88812: LD_INT 5
88814: PUSH
88815: FOR_TO
88816: IFFALSE 88973
// begin _x := ShiftX ( x , d , r + i ) ;
88818: LD_ADDR_VAR 0 5
88822: PUSH
88823: LD_VAR 0 4
88827: PPUSH
88828: LD_VAR 0 8
88832: PPUSH
88833: LD_VAR 0 9
88837: PUSH
88838: LD_VAR 0 10
88842: PLUS
88843: PPUSH
88844: CALL_OW 272
88848: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
88849: LD_ADDR_VAR 0 7
88853: PUSH
88854: LD_VAR 0 6
88858: PPUSH
88859: LD_VAR 0 8
88863: PPUSH
88864: LD_VAR 0 9
88868: PUSH
88869: LD_VAR 0 10
88873: PLUS
88874: PPUSH
88875: CALL_OW 273
88879: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
88880: LD_VAR 0 5
88884: PPUSH
88885: LD_VAR 0 7
88889: PPUSH
88890: CALL_OW 488
88894: PUSH
88895: LD_VAR 0 5
88899: PPUSH
88900: LD_VAR 0 7
88904: PPUSH
88905: CALL_OW 428
88909: PPUSH
88910: CALL_OW 247
88914: PUSH
88915: LD_INT 3
88917: PUSH
88918: LD_INT 2
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: IN
88925: NOT
88926: AND
88927: IFFALSE 88971
// begin ComMoveXY ( unit , _x , _y ) ;
88929: LD_VAR 0 1
88933: PPUSH
88934: LD_VAR 0 5
88938: PPUSH
88939: LD_VAR 0 7
88943: PPUSH
88944: CALL_OW 111
// result := [ _x , _y ] ;
88948: LD_ADDR_VAR 0 3
88952: PUSH
88953: LD_VAR 0 5
88957: PUSH
88958: LD_VAR 0 7
88962: PUSH
88963: EMPTY
88964: LIST
88965: LIST
88966: ST_TO_ADDR
// exit ;
88967: POP
88968: POP
88969: GO 88975
// end ; end ;
88971: GO 88815
88973: POP
88974: POP
// end ;
88975: LD_VAR 0 3
88979: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
88980: LD_INT 0
88982: PPUSH
88983: PPUSH
88984: PPUSH
// result := 0 ;
88985: LD_ADDR_VAR 0 3
88989: PUSH
88990: LD_INT 0
88992: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
88993: LD_VAR 0 1
88997: PUSH
88998: LD_INT 0
89000: LESS
89001: PUSH
89002: LD_VAR 0 1
89006: PUSH
89007: LD_INT 8
89009: GREATER
89010: OR
89011: PUSH
89012: LD_VAR 0 2
89016: PUSH
89017: LD_INT 0
89019: LESS
89020: OR
89021: PUSH
89022: LD_VAR 0 2
89026: PUSH
89027: LD_INT 8
89029: GREATER
89030: OR
89031: IFFALSE 89035
// exit ;
89033: GO 89110
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
89035: LD_ADDR_VAR 0 4
89039: PUSH
89040: LD_INT 22
89042: PUSH
89043: LD_VAR 0 2
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PPUSH
89052: CALL_OW 69
89056: PUSH
89057: FOR_IN
89058: IFFALSE 89108
// begin un := UnitShoot ( i ) ;
89060: LD_ADDR_VAR 0 5
89064: PUSH
89065: LD_VAR 0 4
89069: PPUSH
89070: CALL_OW 504
89074: ST_TO_ADDR
// if GetSide ( un ) = side1 then
89075: LD_VAR 0 5
89079: PPUSH
89080: CALL_OW 255
89084: PUSH
89085: LD_VAR 0 1
89089: EQUAL
89090: IFFALSE 89106
// begin result := un ;
89092: LD_ADDR_VAR 0 3
89096: PUSH
89097: LD_VAR 0 5
89101: ST_TO_ADDR
// exit ;
89102: POP
89103: POP
89104: GO 89110
// end ; end ;
89106: GO 89057
89108: POP
89109: POP
// end ;
89110: LD_VAR 0 3
89114: RET
// export function GetCargoBay ( units ) ; begin
89115: LD_INT 0
89117: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
89118: LD_ADDR_VAR 0 2
89122: PUSH
89123: LD_VAR 0 1
89127: PPUSH
89128: LD_INT 2
89130: PUSH
89131: LD_INT 34
89133: PUSH
89134: LD_INT 12
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 34
89143: PUSH
89144: LD_INT 51
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: PUSH
89151: LD_INT 34
89153: PUSH
89154: LD_INT 32
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 34
89163: PUSH
89164: LD_EXP 73
89168: PUSH
89169: EMPTY
89170: LIST
89171: LIST
89172: PUSH
89173: EMPTY
89174: LIST
89175: LIST
89176: LIST
89177: LIST
89178: LIST
89179: PPUSH
89180: CALL_OW 72
89184: ST_TO_ADDR
// end ;
89185: LD_VAR 0 2
89189: RET
// export function Negate ( value ) ; begin
89190: LD_INT 0
89192: PPUSH
// result := not value ;
89193: LD_ADDR_VAR 0 2
89197: PUSH
89198: LD_VAR 0 1
89202: NOT
89203: ST_TO_ADDR
// end ;
89204: LD_VAR 0 2
89208: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
89209: LD_INT 0
89211: PPUSH
// if x1 = x2 then
89212: LD_VAR 0 1
89216: PUSH
89217: LD_VAR 0 3
89221: EQUAL
89222: IFFALSE 89256
// begin if y1 > y2 then
89224: LD_VAR 0 2
89228: PUSH
89229: LD_VAR 0 4
89233: GREATER
89234: IFFALSE 89246
// result := 0 else
89236: LD_ADDR_VAR 0 5
89240: PUSH
89241: LD_INT 0
89243: ST_TO_ADDR
89244: GO 89254
// result := 3 ;
89246: LD_ADDR_VAR 0 5
89250: PUSH
89251: LD_INT 3
89253: ST_TO_ADDR
// exit ;
89254: GO 89342
// end ; if y1 = y2 then
89256: LD_VAR 0 2
89260: PUSH
89261: LD_VAR 0 4
89265: EQUAL
89266: IFFALSE 89300
// begin if x1 > x2 then
89268: LD_VAR 0 1
89272: PUSH
89273: LD_VAR 0 3
89277: GREATER
89278: IFFALSE 89290
// result := 1 else
89280: LD_ADDR_VAR 0 5
89284: PUSH
89285: LD_INT 1
89287: ST_TO_ADDR
89288: GO 89298
// result := 4 ;
89290: LD_ADDR_VAR 0 5
89294: PUSH
89295: LD_INT 4
89297: ST_TO_ADDR
// exit ;
89298: GO 89342
// end ; if x1 > x2 and y1 > y2 then
89300: LD_VAR 0 1
89304: PUSH
89305: LD_VAR 0 3
89309: GREATER
89310: PUSH
89311: LD_VAR 0 2
89315: PUSH
89316: LD_VAR 0 4
89320: GREATER
89321: AND
89322: IFFALSE 89334
// result := 2 else
89324: LD_ADDR_VAR 0 5
89328: PUSH
89329: LD_INT 2
89331: ST_TO_ADDR
89332: GO 89342
// result := 5 ;
89334: LD_ADDR_VAR 0 5
89338: PUSH
89339: LD_INT 5
89341: ST_TO_ADDR
// end ;
89342: LD_VAR 0 5
89346: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89347: LD_INT 0
89349: PPUSH
89350: PPUSH
// if not driver or not IsInUnit ( driver ) then
89351: LD_VAR 0 1
89355: NOT
89356: PUSH
89357: LD_VAR 0 1
89361: PPUSH
89362: CALL_OW 310
89366: NOT
89367: OR
89368: IFFALSE 89372
// exit ;
89370: GO 89462
// vehicle := IsInUnit ( driver ) ;
89372: LD_ADDR_VAR 0 3
89376: PUSH
89377: LD_VAR 0 1
89381: PPUSH
89382: CALL_OW 310
89386: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89387: LD_VAR 0 1
89391: PPUSH
89392: LD_STRING \
89394: PUSH
89395: LD_INT 0
89397: PUSH
89398: LD_INT 0
89400: PUSH
89401: LD_INT 0
89403: PUSH
89404: LD_INT 0
89406: PUSH
89407: LD_INT 0
89409: PUSH
89410: LD_INT 0
89412: PUSH
89413: EMPTY
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: PUSH
89422: LD_STRING E
89424: PUSH
89425: LD_INT 0
89427: PUSH
89428: LD_INT 0
89430: PUSH
89431: LD_VAR 0 3
89435: PUSH
89436: LD_INT 0
89438: PUSH
89439: LD_INT 0
89441: PUSH
89442: LD_INT 0
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: PPUSH
89458: CALL_OW 446
// end ;
89462: LD_VAR 0 2
89466: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
89467: LD_INT 0
89469: PPUSH
89470: PPUSH
89471: PPUSH
// tmp := [ ] ;
89472: LD_ADDR_VAR 0 5
89476: PUSH
89477: EMPTY
89478: ST_TO_ADDR
// for i in units do
89479: LD_ADDR_VAR 0 4
89483: PUSH
89484: LD_VAR 0 1
89488: PUSH
89489: FOR_IN
89490: IFFALSE 89528
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
89492: LD_ADDR_VAR 0 5
89496: PUSH
89497: LD_VAR 0 5
89501: PPUSH
89502: LD_VAR 0 5
89506: PUSH
89507: LD_INT 1
89509: PLUS
89510: PPUSH
89511: LD_VAR 0 4
89515: PPUSH
89516: CALL_OW 256
89520: PPUSH
89521: CALL_OW 2
89525: ST_TO_ADDR
89526: GO 89489
89528: POP
89529: POP
// if not tmp then
89530: LD_VAR 0 5
89534: NOT
89535: IFFALSE 89539
// exit ;
89537: GO 89587
// if asc then
89539: LD_VAR 0 2
89543: IFFALSE 89567
// result := SortListByListAsc ( units , tmp ) else
89545: LD_ADDR_VAR 0 3
89549: PUSH
89550: LD_VAR 0 1
89554: PPUSH
89555: LD_VAR 0 5
89559: PPUSH
89560: CALL_OW 76
89564: ST_TO_ADDR
89565: GO 89587
// result := SortListByListDesc ( units , tmp ) ;
89567: LD_ADDR_VAR 0 3
89571: PUSH
89572: LD_VAR 0 1
89576: PPUSH
89577: LD_VAR 0 5
89581: PPUSH
89582: CALL_OW 77
89586: ST_TO_ADDR
// end ; end_of_file end_of_file
89587: LD_VAR 0 3
89591: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
89592: LD_INT 0
89594: PPUSH
// if p2 = 100 then
89595: LD_VAR 0 2
89599: PUSH
89600: LD_INT 100
89602: EQUAL
89603: IFFALSE 90552
// begin if not StreamModeActive then
89605: LD_EXP 137
89609: NOT
89610: IFFALSE 89620
// StreamModeActive := true ;
89612: LD_ADDR_EXP 137
89616: PUSH
89617: LD_INT 1
89619: ST_TO_ADDR
// if p3 = 0 then
89620: LD_VAR 0 3
89624: PUSH
89625: LD_INT 0
89627: EQUAL
89628: IFFALSE 89634
// InitStreamMode ;
89630: CALL 90712 0 0
// if p3 = 1 then
89634: LD_VAR 0 3
89638: PUSH
89639: LD_INT 1
89641: EQUAL
89642: IFFALSE 89652
// sRocket := true ;
89644: LD_ADDR_EXP 142
89648: PUSH
89649: LD_INT 1
89651: ST_TO_ADDR
// if p3 = 2 then
89652: LD_VAR 0 3
89656: PUSH
89657: LD_INT 2
89659: EQUAL
89660: IFFALSE 89670
// sSpeed := true ;
89662: LD_ADDR_EXP 141
89666: PUSH
89667: LD_INT 1
89669: ST_TO_ADDR
// if p3 = 3 then
89670: LD_VAR 0 3
89674: PUSH
89675: LD_INT 3
89677: EQUAL
89678: IFFALSE 89688
// sEngine := true ;
89680: LD_ADDR_EXP 143
89684: PUSH
89685: LD_INT 1
89687: ST_TO_ADDR
// if p3 = 4 then
89688: LD_VAR 0 3
89692: PUSH
89693: LD_INT 4
89695: EQUAL
89696: IFFALSE 89706
// sSpec := true ;
89698: LD_ADDR_EXP 140
89702: PUSH
89703: LD_INT 1
89705: ST_TO_ADDR
// if p3 = 5 then
89706: LD_VAR 0 3
89710: PUSH
89711: LD_INT 5
89713: EQUAL
89714: IFFALSE 89724
// sLevel := true ;
89716: LD_ADDR_EXP 144
89720: PUSH
89721: LD_INT 1
89723: ST_TO_ADDR
// if p3 = 6 then
89724: LD_VAR 0 3
89728: PUSH
89729: LD_INT 6
89731: EQUAL
89732: IFFALSE 89742
// sArmoury := true ;
89734: LD_ADDR_EXP 145
89738: PUSH
89739: LD_INT 1
89741: ST_TO_ADDR
// if p3 = 7 then
89742: LD_VAR 0 3
89746: PUSH
89747: LD_INT 7
89749: EQUAL
89750: IFFALSE 89760
// sRadar := true ;
89752: LD_ADDR_EXP 146
89756: PUSH
89757: LD_INT 1
89759: ST_TO_ADDR
// if p3 = 8 then
89760: LD_VAR 0 3
89764: PUSH
89765: LD_INT 8
89767: EQUAL
89768: IFFALSE 89778
// sBunker := true ;
89770: LD_ADDR_EXP 147
89774: PUSH
89775: LD_INT 1
89777: ST_TO_ADDR
// if p3 = 9 then
89778: LD_VAR 0 3
89782: PUSH
89783: LD_INT 9
89785: EQUAL
89786: IFFALSE 89796
// sHack := true ;
89788: LD_ADDR_EXP 148
89792: PUSH
89793: LD_INT 1
89795: ST_TO_ADDR
// if p3 = 10 then
89796: LD_VAR 0 3
89800: PUSH
89801: LD_INT 10
89803: EQUAL
89804: IFFALSE 89814
// sFire := true ;
89806: LD_ADDR_EXP 149
89810: PUSH
89811: LD_INT 1
89813: ST_TO_ADDR
// if p3 = 11 then
89814: LD_VAR 0 3
89818: PUSH
89819: LD_INT 11
89821: EQUAL
89822: IFFALSE 89832
// sRefresh := true ;
89824: LD_ADDR_EXP 150
89828: PUSH
89829: LD_INT 1
89831: ST_TO_ADDR
// if p3 = 12 then
89832: LD_VAR 0 3
89836: PUSH
89837: LD_INT 12
89839: EQUAL
89840: IFFALSE 89850
// sExp := true ;
89842: LD_ADDR_EXP 151
89846: PUSH
89847: LD_INT 1
89849: ST_TO_ADDR
// if p3 = 13 then
89850: LD_VAR 0 3
89854: PUSH
89855: LD_INT 13
89857: EQUAL
89858: IFFALSE 89868
// sDepot := true ;
89860: LD_ADDR_EXP 152
89864: PUSH
89865: LD_INT 1
89867: ST_TO_ADDR
// if p3 = 14 then
89868: LD_VAR 0 3
89872: PUSH
89873: LD_INT 14
89875: EQUAL
89876: IFFALSE 89886
// sFlag := true ;
89878: LD_ADDR_EXP 153
89882: PUSH
89883: LD_INT 1
89885: ST_TO_ADDR
// if p3 = 15 then
89886: LD_VAR 0 3
89890: PUSH
89891: LD_INT 15
89893: EQUAL
89894: IFFALSE 89904
// sKamikadze := true ;
89896: LD_ADDR_EXP 161
89900: PUSH
89901: LD_INT 1
89903: ST_TO_ADDR
// if p3 = 16 then
89904: LD_VAR 0 3
89908: PUSH
89909: LD_INT 16
89911: EQUAL
89912: IFFALSE 89922
// sTroll := true ;
89914: LD_ADDR_EXP 162
89918: PUSH
89919: LD_INT 1
89921: ST_TO_ADDR
// if p3 = 17 then
89922: LD_VAR 0 3
89926: PUSH
89927: LD_INT 17
89929: EQUAL
89930: IFFALSE 89940
// sSlow := true ;
89932: LD_ADDR_EXP 163
89936: PUSH
89937: LD_INT 1
89939: ST_TO_ADDR
// if p3 = 18 then
89940: LD_VAR 0 3
89944: PUSH
89945: LD_INT 18
89947: EQUAL
89948: IFFALSE 89958
// sLack := true ;
89950: LD_ADDR_EXP 164
89954: PUSH
89955: LD_INT 1
89957: ST_TO_ADDR
// if p3 = 19 then
89958: LD_VAR 0 3
89962: PUSH
89963: LD_INT 19
89965: EQUAL
89966: IFFALSE 89976
// sTank := true ;
89968: LD_ADDR_EXP 166
89972: PUSH
89973: LD_INT 1
89975: ST_TO_ADDR
// if p3 = 20 then
89976: LD_VAR 0 3
89980: PUSH
89981: LD_INT 20
89983: EQUAL
89984: IFFALSE 89994
// sRemote := true ;
89986: LD_ADDR_EXP 167
89990: PUSH
89991: LD_INT 1
89993: ST_TO_ADDR
// if p3 = 21 then
89994: LD_VAR 0 3
89998: PUSH
89999: LD_INT 21
90001: EQUAL
90002: IFFALSE 90012
// sPowell := true ;
90004: LD_ADDR_EXP 168
90008: PUSH
90009: LD_INT 1
90011: ST_TO_ADDR
// if p3 = 22 then
90012: LD_VAR 0 3
90016: PUSH
90017: LD_INT 22
90019: EQUAL
90020: IFFALSE 90030
// sTeleport := true ;
90022: LD_ADDR_EXP 171
90026: PUSH
90027: LD_INT 1
90029: ST_TO_ADDR
// if p3 = 23 then
90030: LD_VAR 0 3
90034: PUSH
90035: LD_INT 23
90037: EQUAL
90038: IFFALSE 90048
// sOilTower := true ;
90040: LD_ADDR_EXP 173
90044: PUSH
90045: LD_INT 1
90047: ST_TO_ADDR
// if p3 = 24 then
90048: LD_VAR 0 3
90052: PUSH
90053: LD_INT 24
90055: EQUAL
90056: IFFALSE 90066
// sShovel := true ;
90058: LD_ADDR_EXP 174
90062: PUSH
90063: LD_INT 1
90065: ST_TO_ADDR
// if p3 = 25 then
90066: LD_VAR 0 3
90070: PUSH
90071: LD_INT 25
90073: EQUAL
90074: IFFALSE 90084
// sSheik := true ;
90076: LD_ADDR_EXP 175
90080: PUSH
90081: LD_INT 1
90083: ST_TO_ADDR
// if p3 = 26 then
90084: LD_VAR 0 3
90088: PUSH
90089: LD_INT 26
90091: EQUAL
90092: IFFALSE 90102
// sEarthquake := true ;
90094: LD_ADDR_EXP 177
90098: PUSH
90099: LD_INT 1
90101: ST_TO_ADDR
// if p3 = 27 then
90102: LD_VAR 0 3
90106: PUSH
90107: LD_INT 27
90109: EQUAL
90110: IFFALSE 90120
// sAI := true ;
90112: LD_ADDR_EXP 178
90116: PUSH
90117: LD_INT 1
90119: ST_TO_ADDR
// if p3 = 28 then
90120: LD_VAR 0 3
90124: PUSH
90125: LD_INT 28
90127: EQUAL
90128: IFFALSE 90138
// sCargo := true ;
90130: LD_ADDR_EXP 181
90134: PUSH
90135: LD_INT 1
90137: ST_TO_ADDR
// if p3 = 29 then
90138: LD_VAR 0 3
90142: PUSH
90143: LD_INT 29
90145: EQUAL
90146: IFFALSE 90156
// sDLaser := true ;
90148: LD_ADDR_EXP 182
90152: PUSH
90153: LD_INT 1
90155: ST_TO_ADDR
// if p3 = 30 then
90156: LD_VAR 0 3
90160: PUSH
90161: LD_INT 30
90163: EQUAL
90164: IFFALSE 90174
// sExchange := true ;
90166: LD_ADDR_EXP 183
90170: PUSH
90171: LD_INT 1
90173: ST_TO_ADDR
// if p3 = 31 then
90174: LD_VAR 0 3
90178: PUSH
90179: LD_INT 31
90181: EQUAL
90182: IFFALSE 90192
// sFac := true ;
90184: LD_ADDR_EXP 184
90188: PUSH
90189: LD_INT 1
90191: ST_TO_ADDR
// if p3 = 32 then
90192: LD_VAR 0 3
90196: PUSH
90197: LD_INT 32
90199: EQUAL
90200: IFFALSE 90210
// sPower := true ;
90202: LD_ADDR_EXP 185
90206: PUSH
90207: LD_INT 1
90209: ST_TO_ADDR
// if p3 = 33 then
90210: LD_VAR 0 3
90214: PUSH
90215: LD_INT 33
90217: EQUAL
90218: IFFALSE 90228
// sRandom := true ;
90220: LD_ADDR_EXP 186
90224: PUSH
90225: LD_INT 1
90227: ST_TO_ADDR
// if p3 = 34 then
90228: LD_VAR 0 3
90232: PUSH
90233: LD_INT 34
90235: EQUAL
90236: IFFALSE 90246
// sShield := true ;
90238: LD_ADDR_EXP 187
90242: PUSH
90243: LD_INT 1
90245: ST_TO_ADDR
// if p3 = 35 then
90246: LD_VAR 0 3
90250: PUSH
90251: LD_INT 35
90253: EQUAL
90254: IFFALSE 90264
// sTime := true ;
90256: LD_ADDR_EXP 188
90260: PUSH
90261: LD_INT 1
90263: ST_TO_ADDR
// if p3 = 36 then
90264: LD_VAR 0 3
90268: PUSH
90269: LD_INT 36
90271: EQUAL
90272: IFFALSE 90282
// sTools := true ;
90274: LD_ADDR_EXP 189
90278: PUSH
90279: LD_INT 1
90281: ST_TO_ADDR
// if p3 = 101 then
90282: LD_VAR 0 3
90286: PUSH
90287: LD_INT 101
90289: EQUAL
90290: IFFALSE 90300
// sSold := true ;
90292: LD_ADDR_EXP 154
90296: PUSH
90297: LD_INT 1
90299: ST_TO_ADDR
// if p3 = 102 then
90300: LD_VAR 0 3
90304: PUSH
90305: LD_INT 102
90307: EQUAL
90308: IFFALSE 90318
// sDiff := true ;
90310: LD_ADDR_EXP 155
90314: PUSH
90315: LD_INT 1
90317: ST_TO_ADDR
// if p3 = 103 then
90318: LD_VAR 0 3
90322: PUSH
90323: LD_INT 103
90325: EQUAL
90326: IFFALSE 90336
// sFog := true ;
90328: LD_ADDR_EXP 158
90332: PUSH
90333: LD_INT 1
90335: ST_TO_ADDR
// if p3 = 104 then
90336: LD_VAR 0 3
90340: PUSH
90341: LD_INT 104
90343: EQUAL
90344: IFFALSE 90354
// sReset := true ;
90346: LD_ADDR_EXP 159
90350: PUSH
90351: LD_INT 1
90353: ST_TO_ADDR
// if p3 = 105 then
90354: LD_VAR 0 3
90358: PUSH
90359: LD_INT 105
90361: EQUAL
90362: IFFALSE 90372
// sSun := true ;
90364: LD_ADDR_EXP 160
90368: PUSH
90369: LD_INT 1
90371: ST_TO_ADDR
// if p3 = 106 then
90372: LD_VAR 0 3
90376: PUSH
90377: LD_INT 106
90379: EQUAL
90380: IFFALSE 90390
// sTiger := true ;
90382: LD_ADDR_EXP 156
90386: PUSH
90387: LD_INT 1
90389: ST_TO_ADDR
// if p3 = 107 then
90390: LD_VAR 0 3
90394: PUSH
90395: LD_INT 107
90397: EQUAL
90398: IFFALSE 90408
// sBomb := true ;
90400: LD_ADDR_EXP 157
90404: PUSH
90405: LD_INT 1
90407: ST_TO_ADDR
// if p3 = 108 then
90408: LD_VAR 0 3
90412: PUSH
90413: LD_INT 108
90415: EQUAL
90416: IFFALSE 90426
// sWound := true ;
90418: LD_ADDR_EXP 165
90422: PUSH
90423: LD_INT 1
90425: ST_TO_ADDR
// if p3 = 109 then
90426: LD_VAR 0 3
90430: PUSH
90431: LD_INT 109
90433: EQUAL
90434: IFFALSE 90444
// sBetray := true ;
90436: LD_ADDR_EXP 169
90440: PUSH
90441: LD_INT 1
90443: ST_TO_ADDR
// if p3 = 110 then
90444: LD_VAR 0 3
90448: PUSH
90449: LD_INT 110
90451: EQUAL
90452: IFFALSE 90462
// sContamin := true ;
90454: LD_ADDR_EXP 170
90458: PUSH
90459: LD_INT 1
90461: ST_TO_ADDR
// if p3 = 111 then
90462: LD_VAR 0 3
90466: PUSH
90467: LD_INT 111
90469: EQUAL
90470: IFFALSE 90480
// sOil := true ;
90472: LD_ADDR_EXP 172
90476: PUSH
90477: LD_INT 1
90479: ST_TO_ADDR
// if p3 = 112 then
90480: LD_VAR 0 3
90484: PUSH
90485: LD_INT 112
90487: EQUAL
90488: IFFALSE 90498
// sStu := true ;
90490: LD_ADDR_EXP 176
90494: PUSH
90495: LD_INT 1
90497: ST_TO_ADDR
// if p3 = 113 then
90498: LD_VAR 0 3
90502: PUSH
90503: LD_INT 113
90505: EQUAL
90506: IFFALSE 90516
// sBazooka := true ;
90508: LD_ADDR_EXP 179
90512: PUSH
90513: LD_INT 1
90515: ST_TO_ADDR
// if p3 = 114 then
90516: LD_VAR 0 3
90520: PUSH
90521: LD_INT 114
90523: EQUAL
90524: IFFALSE 90534
// sMortar := true ;
90526: LD_ADDR_EXP 180
90530: PUSH
90531: LD_INT 1
90533: ST_TO_ADDR
// if p3 = 115 then
90534: LD_VAR 0 3
90538: PUSH
90539: LD_INT 115
90541: EQUAL
90542: IFFALSE 90552
// sRanger := true ;
90544: LD_ADDR_EXP 190
90548: PUSH
90549: LD_INT 1
90551: ST_TO_ADDR
// end ; if p2 = 101 then
90552: LD_VAR 0 2
90556: PUSH
90557: LD_INT 101
90559: EQUAL
90560: IFFALSE 90688
// begin case p3 of 1 :
90562: LD_VAR 0 3
90566: PUSH
90567: LD_INT 1
90569: DOUBLE
90570: EQUAL
90571: IFTRUE 90575
90573: GO 90582
90575: POP
// hHackUnlimitedResources ; 2 :
90576: CALL 101725 0 0
90580: GO 90688
90582: LD_INT 2
90584: DOUBLE
90585: EQUAL
90586: IFTRUE 90590
90588: GO 90597
90590: POP
// hHackSetLevel10 ; 3 :
90591: CALL 101858 0 0
90595: GO 90688
90597: LD_INT 3
90599: DOUBLE
90600: EQUAL
90601: IFTRUE 90605
90603: GO 90612
90605: POP
// hHackSetLevel10YourUnits ; 4 :
90606: CALL 101943 0 0
90610: GO 90688
90612: LD_INT 4
90614: DOUBLE
90615: EQUAL
90616: IFTRUE 90620
90618: GO 90627
90620: POP
// hHackInvincible ; 5 :
90621: CALL 102391 0 0
90625: GO 90688
90627: LD_INT 5
90629: DOUBLE
90630: EQUAL
90631: IFTRUE 90635
90633: GO 90642
90635: POP
// hHackInvisible ; 6 :
90636: CALL 102502 0 0
90640: GO 90688
90642: LD_INT 6
90644: DOUBLE
90645: EQUAL
90646: IFTRUE 90650
90648: GO 90657
90650: POP
// hHackChangeYourSide ; 7 :
90651: CALL 102559 0 0
90655: GO 90688
90657: LD_INT 7
90659: DOUBLE
90660: EQUAL
90661: IFTRUE 90665
90663: GO 90672
90665: POP
// hHackChangeUnitSide ; 8 :
90666: CALL 102601 0 0
90670: GO 90688
90672: LD_INT 8
90674: DOUBLE
90675: EQUAL
90676: IFTRUE 90680
90678: GO 90687
90680: POP
// hHackFog ; end ;
90681: CALL 102702 0 0
90685: GO 90688
90687: POP
// end ; end ;
90688: LD_VAR 0 7
90692: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
90693: GO 90695
90695: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
90696: LD_STRING initStreamRollete();
90698: PPUSH
90699: CALL_OW 559
// InitStreamMode ;
90703: CALL 90712 0 0
// DefineStreamItems ( ) ;
90707: CALL 91152 0 0
// end ;
90711: END
// function InitStreamMode ; begin
90712: LD_INT 0
90714: PPUSH
// streamModeActive := false ;
90715: LD_ADDR_EXP 137
90719: PUSH
90720: LD_INT 0
90722: ST_TO_ADDR
// normalCounter := 36 ;
90723: LD_ADDR_EXP 138
90727: PUSH
90728: LD_INT 36
90730: ST_TO_ADDR
// hardcoreCounter := 16 ;
90731: LD_ADDR_EXP 139
90735: PUSH
90736: LD_INT 16
90738: ST_TO_ADDR
// sRocket := false ;
90739: LD_ADDR_EXP 142
90743: PUSH
90744: LD_INT 0
90746: ST_TO_ADDR
// sSpeed := false ;
90747: LD_ADDR_EXP 141
90751: PUSH
90752: LD_INT 0
90754: ST_TO_ADDR
// sEngine := false ;
90755: LD_ADDR_EXP 143
90759: PUSH
90760: LD_INT 0
90762: ST_TO_ADDR
// sSpec := false ;
90763: LD_ADDR_EXP 140
90767: PUSH
90768: LD_INT 0
90770: ST_TO_ADDR
// sLevel := false ;
90771: LD_ADDR_EXP 144
90775: PUSH
90776: LD_INT 0
90778: ST_TO_ADDR
// sArmoury := false ;
90779: LD_ADDR_EXP 145
90783: PUSH
90784: LD_INT 0
90786: ST_TO_ADDR
// sRadar := false ;
90787: LD_ADDR_EXP 146
90791: PUSH
90792: LD_INT 0
90794: ST_TO_ADDR
// sBunker := false ;
90795: LD_ADDR_EXP 147
90799: PUSH
90800: LD_INT 0
90802: ST_TO_ADDR
// sHack := false ;
90803: LD_ADDR_EXP 148
90807: PUSH
90808: LD_INT 0
90810: ST_TO_ADDR
// sFire := false ;
90811: LD_ADDR_EXP 149
90815: PUSH
90816: LD_INT 0
90818: ST_TO_ADDR
// sRefresh := false ;
90819: LD_ADDR_EXP 150
90823: PUSH
90824: LD_INT 0
90826: ST_TO_ADDR
// sExp := false ;
90827: LD_ADDR_EXP 151
90831: PUSH
90832: LD_INT 0
90834: ST_TO_ADDR
// sDepot := false ;
90835: LD_ADDR_EXP 152
90839: PUSH
90840: LD_INT 0
90842: ST_TO_ADDR
// sFlag := false ;
90843: LD_ADDR_EXP 153
90847: PUSH
90848: LD_INT 0
90850: ST_TO_ADDR
// sKamikadze := false ;
90851: LD_ADDR_EXP 161
90855: PUSH
90856: LD_INT 0
90858: ST_TO_ADDR
// sTroll := false ;
90859: LD_ADDR_EXP 162
90863: PUSH
90864: LD_INT 0
90866: ST_TO_ADDR
// sSlow := false ;
90867: LD_ADDR_EXP 163
90871: PUSH
90872: LD_INT 0
90874: ST_TO_ADDR
// sLack := false ;
90875: LD_ADDR_EXP 164
90879: PUSH
90880: LD_INT 0
90882: ST_TO_ADDR
// sTank := false ;
90883: LD_ADDR_EXP 166
90887: PUSH
90888: LD_INT 0
90890: ST_TO_ADDR
// sRemote := false ;
90891: LD_ADDR_EXP 167
90895: PUSH
90896: LD_INT 0
90898: ST_TO_ADDR
// sPowell := false ;
90899: LD_ADDR_EXP 168
90903: PUSH
90904: LD_INT 0
90906: ST_TO_ADDR
// sTeleport := false ;
90907: LD_ADDR_EXP 171
90911: PUSH
90912: LD_INT 0
90914: ST_TO_ADDR
// sOilTower := false ;
90915: LD_ADDR_EXP 173
90919: PUSH
90920: LD_INT 0
90922: ST_TO_ADDR
// sShovel := false ;
90923: LD_ADDR_EXP 174
90927: PUSH
90928: LD_INT 0
90930: ST_TO_ADDR
// sSheik := false ;
90931: LD_ADDR_EXP 175
90935: PUSH
90936: LD_INT 0
90938: ST_TO_ADDR
// sEarthquake := false ;
90939: LD_ADDR_EXP 177
90943: PUSH
90944: LD_INT 0
90946: ST_TO_ADDR
// sAI := false ;
90947: LD_ADDR_EXP 178
90951: PUSH
90952: LD_INT 0
90954: ST_TO_ADDR
// sCargo := false ;
90955: LD_ADDR_EXP 181
90959: PUSH
90960: LD_INT 0
90962: ST_TO_ADDR
// sDLaser := false ;
90963: LD_ADDR_EXP 182
90967: PUSH
90968: LD_INT 0
90970: ST_TO_ADDR
// sExchange := false ;
90971: LD_ADDR_EXP 183
90975: PUSH
90976: LD_INT 0
90978: ST_TO_ADDR
// sFac := false ;
90979: LD_ADDR_EXP 184
90983: PUSH
90984: LD_INT 0
90986: ST_TO_ADDR
// sPower := false ;
90987: LD_ADDR_EXP 185
90991: PUSH
90992: LD_INT 0
90994: ST_TO_ADDR
// sRandom := false ;
90995: LD_ADDR_EXP 186
90999: PUSH
91000: LD_INT 0
91002: ST_TO_ADDR
// sShield := false ;
91003: LD_ADDR_EXP 187
91007: PUSH
91008: LD_INT 0
91010: ST_TO_ADDR
// sTime := false ;
91011: LD_ADDR_EXP 188
91015: PUSH
91016: LD_INT 0
91018: ST_TO_ADDR
// sTools := false ;
91019: LD_ADDR_EXP 189
91023: PUSH
91024: LD_INT 0
91026: ST_TO_ADDR
// sSold := false ;
91027: LD_ADDR_EXP 154
91031: PUSH
91032: LD_INT 0
91034: ST_TO_ADDR
// sDiff := false ;
91035: LD_ADDR_EXP 155
91039: PUSH
91040: LD_INT 0
91042: ST_TO_ADDR
// sFog := false ;
91043: LD_ADDR_EXP 158
91047: PUSH
91048: LD_INT 0
91050: ST_TO_ADDR
// sReset := false ;
91051: LD_ADDR_EXP 159
91055: PUSH
91056: LD_INT 0
91058: ST_TO_ADDR
// sSun := false ;
91059: LD_ADDR_EXP 160
91063: PUSH
91064: LD_INT 0
91066: ST_TO_ADDR
// sTiger := false ;
91067: LD_ADDR_EXP 156
91071: PUSH
91072: LD_INT 0
91074: ST_TO_ADDR
// sBomb := false ;
91075: LD_ADDR_EXP 157
91079: PUSH
91080: LD_INT 0
91082: ST_TO_ADDR
// sWound := false ;
91083: LD_ADDR_EXP 165
91087: PUSH
91088: LD_INT 0
91090: ST_TO_ADDR
// sBetray := false ;
91091: LD_ADDR_EXP 169
91095: PUSH
91096: LD_INT 0
91098: ST_TO_ADDR
// sContamin := false ;
91099: LD_ADDR_EXP 170
91103: PUSH
91104: LD_INT 0
91106: ST_TO_ADDR
// sOil := false ;
91107: LD_ADDR_EXP 172
91111: PUSH
91112: LD_INT 0
91114: ST_TO_ADDR
// sStu := false ;
91115: LD_ADDR_EXP 176
91119: PUSH
91120: LD_INT 0
91122: ST_TO_ADDR
// sBazooka := false ;
91123: LD_ADDR_EXP 179
91127: PUSH
91128: LD_INT 0
91130: ST_TO_ADDR
// sMortar := false ;
91131: LD_ADDR_EXP 180
91135: PUSH
91136: LD_INT 0
91138: ST_TO_ADDR
// sRanger := false ;
91139: LD_ADDR_EXP 190
91143: PUSH
91144: LD_INT 0
91146: ST_TO_ADDR
// end ;
91147: LD_VAR 0 1
91151: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
91152: LD_INT 0
91154: PPUSH
91155: PPUSH
91156: PPUSH
91157: PPUSH
91158: PPUSH
// result := [ ] ;
91159: LD_ADDR_VAR 0 1
91163: PUSH
91164: EMPTY
91165: ST_TO_ADDR
// if campaign_id = 1 then
91166: LD_OWVAR 69
91170: PUSH
91171: LD_INT 1
91173: EQUAL
91174: IFFALSE 94112
// begin case mission_number of 1 :
91176: LD_OWVAR 70
91180: PUSH
91181: LD_INT 1
91183: DOUBLE
91184: EQUAL
91185: IFTRUE 91189
91187: GO 91253
91189: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
91190: LD_ADDR_VAR 0 1
91194: PUSH
91195: LD_INT 2
91197: PUSH
91198: LD_INT 4
91200: PUSH
91201: LD_INT 11
91203: PUSH
91204: LD_INT 12
91206: PUSH
91207: LD_INT 15
91209: PUSH
91210: LD_INT 16
91212: PUSH
91213: LD_INT 22
91215: PUSH
91216: LD_INT 23
91218: PUSH
91219: LD_INT 26
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 101
91235: PUSH
91236: LD_INT 102
91238: PUSH
91239: LD_INT 106
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: LIST
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: ST_TO_ADDR
91251: GO 94110
91253: LD_INT 2
91255: DOUBLE
91256: EQUAL
91257: IFTRUE 91261
91259: GO 91333
91261: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
91262: LD_ADDR_VAR 0 1
91266: PUSH
91267: LD_INT 2
91269: PUSH
91270: LD_INT 4
91272: PUSH
91273: LD_INT 11
91275: PUSH
91276: LD_INT 12
91278: PUSH
91279: LD_INT 15
91281: PUSH
91282: LD_INT 16
91284: PUSH
91285: LD_INT 22
91287: PUSH
91288: LD_INT 23
91290: PUSH
91291: LD_INT 26
91293: PUSH
91294: EMPTY
91295: LIST
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: PUSH
91305: LD_INT 101
91307: PUSH
91308: LD_INT 102
91310: PUSH
91311: LD_INT 105
91313: PUSH
91314: LD_INT 106
91316: PUSH
91317: LD_INT 108
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: LIST
91324: LIST
91325: LIST
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: ST_TO_ADDR
91331: GO 94110
91333: LD_INT 3
91335: DOUBLE
91336: EQUAL
91337: IFTRUE 91341
91339: GO 91417
91341: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
91342: LD_ADDR_VAR 0 1
91346: PUSH
91347: LD_INT 2
91349: PUSH
91350: LD_INT 4
91352: PUSH
91353: LD_INT 5
91355: PUSH
91356: LD_INT 11
91358: PUSH
91359: LD_INT 12
91361: PUSH
91362: LD_INT 15
91364: PUSH
91365: LD_INT 16
91367: PUSH
91368: LD_INT 22
91370: PUSH
91371: LD_INT 26
91373: PUSH
91374: LD_INT 36
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: LIST
91381: LIST
91382: LIST
91383: LIST
91384: LIST
91385: LIST
91386: LIST
91387: LIST
91388: PUSH
91389: LD_INT 101
91391: PUSH
91392: LD_INT 102
91394: PUSH
91395: LD_INT 105
91397: PUSH
91398: LD_INT 106
91400: PUSH
91401: LD_INT 108
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: PUSH
91411: EMPTY
91412: LIST
91413: LIST
91414: ST_TO_ADDR
91415: GO 94110
91417: LD_INT 4
91419: DOUBLE
91420: EQUAL
91421: IFTRUE 91425
91423: GO 91509
91425: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
91426: LD_ADDR_VAR 0 1
91430: PUSH
91431: LD_INT 2
91433: PUSH
91434: LD_INT 4
91436: PUSH
91437: LD_INT 5
91439: PUSH
91440: LD_INT 8
91442: PUSH
91443: LD_INT 11
91445: PUSH
91446: LD_INT 12
91448: PUSH
91449: LD_INT 15
91451: PUSH
91452: LD_INT 16
91454: PUSH
91455: LD_INT 22
91457: PUSH
91458: LD_INT 23
91460: PUSH
91461: LD_INT 26
91463: PUSH
91464: LD_INT 36
91466: PUSH
91467: EMPTY
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: LIST
91478: LIST
91479: LIST
91480: PUSH
91481: LD_INT 101
91483: PUSH
91484: LD_INT 102
91486: PUSH
91487: LD_INT 105
91489: PUSH
91490: LD_INT 106
91492: PUSH
91493: LD_INT 108
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: LIST
91500: LIST
91501: LIST
91502: PUSH
91503: EMPTY
91504: LIST
91505: LIST
91506: ST_TO_ADDR
91507: GO 94110
91509: LD_INT 5
91511: DOUBLE
91512: EQUAL
91513: IFTRUE 91517
91515: GO 91617
91517: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
91518: LD_ADDR_VAR 0 1
91522: PUSH
91523: LD_INT 2
91525: PUSH
91526: LD_INT 4
91528: PUSH
91529: LD_INT 5
91531: PUSH
91532: LD_INT 6
91534: PUSH
91535: LD_INT 8
91537: PUSH
91538: LD_INT 11
91540: PUSH
91541: LD_INT 12
91543: PUSH
91544: LD_INT 15
91546: PUSH
91547: LD_INT 16
91549: PUSH
91550: LD_INT 22
91552: PUSH
91553: LD_INT 23
91555: PUSH
91556: LD_INT 25
91558: PUSH
91559: LD_INT 26
91561: PUSH
91562: LD_INT 36
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: LIST
91573: LIST
91574: LIST
91575: LIST
91576: LIST
91577: LIST
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 101
91583: PUSH
91584: LD_INT 102
91586: PUSH
91587: LD_INT 105
91589: PUSH
91590: LD_INT 106
91592: PUSH
91593: LD_INT 108
91595: PUSH
91596: LD_INT 109
91598: PUSH
91599: LD_INT 112
91601: PUSH
91602: EMPTY
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: PUSH
91611: EMPTY
91612: LIST
91613: LIST
91614: ST_TO_ADDR
91615: GO 94110
91617: LD_INT 6
91619: DOUBLE
91620: EQUAL
91621: IFTRUE 91625
91623: GO 91745
91625: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
91626: LD_ADDR_VAR 0 1
91630: PUSH
91631: LD_INT 2
91633: PUSH
91634: LD_INT 4
91636: PUSH
91637: LD_INT 5
91639: PUSH
91640: LD_INT 6
91642: PUSH
91643: LD_INT 8
91645: PUSH
91646: LD_INT 11
91648: PUSH
91649: LD_INT 12
91651: PUSH
91652: LD_INT 15
91654: PUSH
91655: LD_INT 16
91657: PUSH
91658: LD_INT 20
91660: PUSH
91661: LD_INT 21
91663: PUSH
91664: LD_INT 22
91666: PUSH
91667: LD_INT 23
91669: PUSH
91670: LD_INT 25
91672: PUSH
91673: LD_INT 26
91675: PUSH
91676: LD_INT 30
91678: PUSH
91679: LD_INT 31
91681: PUSH
91682: LD_INT 32
91684: PUSH
91685: LD_INT 36
91687: PUSH
91688: EMPTY
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: PUSH
91709: LD_INT 101
91711: PUSH
91712: LD_INT 102
91714: PUSH
91715: LD_INT 105
91717: PUSH
91718: LD_INT 106
91720: PUSH
91721: LD_INT 108
91723: PUSH
91724: LD_INT 109
91726: PUSH
91727: LD_INT 112
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: LIST
91734: LIST
91735: LIST
91736: LIST
91737: LIST
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: ST_TO_ADDR
91743: GO 94110
91745: LD_INT 7
91747: DOUBLE
91748: EQUAL
91749: IFTRUE 91753
91751: GO 91853
91753: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
91754: LD_ADDR_VAR 0 1
91758: PUSH
91759: LD_INT 2
91761: PUSH
91762: LD_INT 4
91764: PUSH
91765: LD_INT 5
91767: PUSH
91768: LD_INT 7
91770: PUSH
91771: LD_INT 11
91773: PUSH
91774: LD_INT 12
91776: PUSH
91777: LD_INT 15
91779: PUSH
91780: LD_INT 16
91782: PUSH
91783: LD_INT 20
91785: PUSH
91786: LD_INT 21
91788: PUSH
91789: LD_INT 22
91791: PUSH
91792: LD_INT 23
91794: PUSH
91795: LD_INT 25
91797: PUSH
91798: LD_INT 26
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: LIST
91807: LIST
91808: LIST
91809: LIST
91810: LIST
91811: LIST
91812: LIST
91813: LIST
91814: LIST
91815: LIST
91816: PUSH
91817: LD_INT 101
91819: PUSH
91820: LD_INT 102
91822: PUSH
91823: LD_INT 103
91825: PUSH
91826: LD_INT 105
91828: PUSH
91829: LD_INT 106
91831: PUSH
91832: LD_INT 108
91834: PUSH
91835: LD_INT 112
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: ST_TO_ADDR
91851: GO 94110
91853: LD_INT 8
91855: DOUBLE
91856: EQUAL
91857: IFTRUE 91861
91859: GO 91989
91861: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
91862: LD_ADDR_VAR 0 1
91866: PUSH
91867: LD_INT 2
91869: PUSH
91870: LD_INT 4
91872: PUSH
91873: LD_INT 5
91875: PUSH
91876: LD_INT 6
91878: PUSH
91879: LD_INT 7
91881: PUSH
91882: LD_INT 8
91884: PUSH
91885: LD_INT 11
91887: PUSH
91888: LD_INT 12
91890: PUSH
91891: LD_INT 15
91893: PUSH
91894: LD_INT 16
91896: PUSH
91897: LD_INT 20
91899: PUSH
91900: LD_INT 21
91902: PUSH
91903: LD_INT 22
91905: PUSH
91906: LD_INT 23
91908: PUSH
91909: LD_INT 25
91911: PUSH
91912: LD_INT 26
91914: PUSH
91915: LD_INT 30
91917: PUSH
91918: LD_INT 31
91920: PUSH
91921: LD_INT 32
91923: PUSH
91924: LD_INT 36
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: LIST
91937: LIST
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: PUSH
91949: LD_INT 101
91951: PUSH
91952: LD_INT 102
91954: PUSH
91955: LD_INT 103
91957: PUSH
91958: LD_INT 105
91960: PUSH
91961: LD_INT 106
91963: PUSH
91964: LD_INT 108
91966: PUSH
91967: LD_INT 109
91969: PUSH
91970: LD_INT 112
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: LIST
91977: LIST
91978: LIST
91979: LIST
91980: LIST
91981: LIST
91982: PUSH
91983: EMPTY
91984: LIST
91985: LIST
91986: ST_TO_ADDR
91987: GO 94110
91989: LD_INT 9
91991: DOUBLE
91992: EQUAL
91993: IFTRUE 91997
91995: GO 92133
91997: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
91998: LD_ADDR_VAR 0 1
92002: PUSH
92003: LD_INT 2
92005: PUSH
92006: LD_INT 4
92008: PUSH
92009: LD_INT 5
92011: PUSH
92012: LD_INT 6
92014: PUSH
92015: LD_INT 7
92017: PUSH
92018: LD_INT 8
92020: PUSH
92021: LD_INT 11
92023: PUSH
92024: LD_INT 12
92026: PUSH
92027: LD_INT 15
92029: PUSH
92030: LD_INT 16
92032: PUSH
92033: LD_INT 20
92035: PUSH
92036: LD_INT 21
92038: PUSH
92039: LD_INT 22
92041: PUSH
92042: LD_INT 23
92044: PUSH
92045: LD_INT 25
92047: PUSH
92048: LD_INT 26
92050: PUSH
92051: LD_INT 28
92053: PUSH
92054: LD_INT 30
92056: PUSH
92057: LD_INT 31
92059: PUSH
92060: LD_INT 32
92062: PUSH
92063: LD_INT 36
92065: PUSH
92066: EMPTY
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: LIST
92080: LIST
92081: LIST
92082: LIST
92083: LIST
92084: LIST
92085: LIST
92086: LIST
92087: LIST
92088: PUSH
92089: LD_INT 101
92091: PUSH
92092: LD_INT 102
92094: PUSH
92095: LD_INT 103
92097: PUSH
92098: LD_INT 105
92100: PUSH
92101: LD_INT 106
92103: PUSH
92104: LD_INT 108
92106: PUSH
92107: LD_INT 109
92109: PUSH
92110: LD_INT 112
92112: PUSH
92113: LD_INT 114
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: LIST
92120: LIST
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: PUSH
92127: EMPTY
92128: LIST
92129: LIST
92130: ST_TO_ADDR
92131: GO 94110
92133: LD_INT 10
92135: DOUBLE
92136: EQUAL
92137: IFTRUE 92141
92139: GO 92325
92141: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
92142: LD_ADDR_VAR 0 1
92146: PUSH
92147: LD_INT 2
92149: PUSH
92150: LD_INT 4
92152: PUSH
92153: LD_INT 5
92155: PUSH
92156: LD_INT 6
92158: PUSH
92159: LD_INT 7
92161: PUSH
92162: LD_INT 8
92164: PUSH
92165: LD_INT 9
92167: PUSH
92168: LD_INT 10
92170: PUSH
92171: LD_INT 11
92173: PUSH
92174: LD_INT 12
92176: PUSH
92177: LD_INT 13
92179: PUSH
92180: LD_INT 14
92182: PUSH
92183: LD_INT 15
92185: PUSH
92186: LD_INT 16
92188: PUSH
92189: LD_INT 17
92191: PUSH
92192: LD_INT 18
92194: PUSH
92195: LD_INT 19
92197: PUSH
92198: LD_INT 20
92200: PUSH
92201: LD_INT 21
92203: PUSH
92204: LD_INT 22
92206: PUSH
92207: LD_INT 23
92209: PUSH
92210: LD_INT 24
92212: PUSH
92213: LD_INT 25
92215: PUSH
92216: LD_INT 26
92218: PUSH
92219: LD_INT 28
92221: PUSH
92222: LD_INT 30
92224: PUSH
92225: LD_INT 31
92227: PUSH
92228: LD_INT 32
92230: PUSH
92231: LD_INT 36
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: PUSH
92265: LD_INT 101
92267: PUSH
92268: LD_INT 102
92270: PUSH
92271: LD_INT 103
92273: PUSH
92274: LD_INT 104
92276: PUSH
92277: LD_INT 105
92279: PUSH
92280: LD_INT 106
92282: PUSH
92283: LD_INT 107
92285: PUSH
92286: LD_INT 108
92288: PUSH
92289: LD_INT 109
92291: PUSH
92292: LD_INT 110
92294: PUSH
92295: LD_INT 111
92297: PUSH
92298: LD_INT 112
92300: PUSH
92301: LD_INT 114
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: PUSH
92319: EMPTY
92320: LIST
92321: LIST
92322: ST_TO_ADDR
92323: GO 94110
92325: LD_INT 11
92327: DOUBLE
92328: EQUAL
92329: IFTRUE 92333
92331: GO 92525
92333: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
92334: LD_ADDR_VAR 0 1
92338: PUSH
92339: LD_INT 2
92341: PUSH
92342: LD_INT 3
92344: PUSH
92345: LD_INT 4
92347: PUSH
92348: LD_INT 5
92350: PUSH
92351: LD_INT 6
92353: PUSH
92354: LD_INT 7
92356: PUSH
92357: LD_INT 8
92359: PUSH
92360: LD_INT 9
92362: PUSH
92363: LD_INT 10
92365: PUSH
92366: LD_INT 11
92368: PUSH
92369: LD_INT 12
92371: PUSH
92372: LD_INT 13
92374: PUSH
92375: LD_INT 14
92377: PUSH
92378: LD_INT 15
92380: PUSH
92381: LD_INT 16
92383: PUSH
92384: LD_INT 17
92386: PUSH
92387: LD_INT 18
92389: PUSH
92390: LD_INT 19
92392: PUSH
92393: LD_INT 20
92395: PUSH
92396: LD_INT 21
92398: PUSH
92399: LD_INT 22
92401: PUSH
92402: LD_INT 23
92404: PUSH
92405: LD_INT 24
92407: PUSH
92408: LD_INT 25
92410: PUSH
92411: LD_INT 26
92413: PUSH
92414: LD_INT 28
92416: PUSH
92417: LD_INT 30
92419: PUSH
92420: LD_INT 31
92422: PUSH
92423: LD_INT 32
92425: PUSH
92426: LD_INT 34
92428: PUSH
92429: LD_INT 36
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: LIST
92458: LIST
92459: LIST
92460: LIST
92461: LIST
92462: LIST
92463: LIST
92464: PUSH
92465: LD_INT 101
92467: PUSH
92468: LD_INT 102
92470: PUSH
92471: LD_INT 103
92473: PUSH
92474: LD_INT 104
92476: PUSH
92477: LD_INT 105
92479: PUSH
92480: LD_INT 106
92482: PUSH
92483: LD_INT 107
92485: PUSH
92486: LD_INT 108
92488: PUSH
92489: LD_INT 109
92491: PUSH
92492: LD_INT 110
92494: PUSH
92495: LD_INT 111
92497: PUSH
92498: LD_INT 112
92500: PUSH
92501: LD_INT 114
92503: PUSH
92504: EMPTY
92505: LIST
92506: LIST
92507: LIST
92508: LIST
92509: LIST
92510: LIST
92511: LIST
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: LIST
92517: LIST
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: ST_TO_ADDR
92523: GO 94110
92525: LD_INT 12
92527: DOUBLE
92528: EQUAL
92529: IFTRUE 92533
92531: GO 92741
92533: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
92534: LD_ADDR_VAR 0 1
92538: PUSH
92539: LD_INT 1
92541: PUSH
92542: LD_INT 2
92544: PUSH
92545: LD_INT 3
92547: PUSH
92548: LD_INT 4
92550: PUSH
92551: LD_INT 5
92553: PUSH
92554: LD_INT 6
92556: PUSH
92557: LD_INT 7
92559: PUSH
92560: LD_INT 8
92562: PUSH
92563: LD_INT 9
92565: PUSH
92566: LD_INT 10
92568: PUSH
92569: LD_INT 11
92571: PUSH
92572: LD_INT 12
92574: PUSH
92575: LD_INT 13
92577: PUSH
92578: LD_INT 14
92580: PUSH
92581: LD_INT 15
92583: PUSH
92584: LD_INT 16
92586: PUSH
92587: LD_INT 17
92589: PUSH
92590: LD_INT 18
92592: PUSH
92593: LD_INT 19
92595: PUSH
92596: LD_INT 20
92598: PUSH
92599: LD_INT 21
92601: PUSH
92602: LD_INT 22
92604: PUSH
92605: LD_INT 23
92607: PUSH
92608: LD_INT 24
92610: PUSH
92611: LD_INT 25
92613: PUSH
92614: LD_INT 26
92616: PUSH
92617: LD_INT 27
92619: PUSH
92620: LD_INT 28
92622: PUSH
92623: LD_INT 30
92625: PUSH
92626: LD_INT 31
92628: PUSH
92629: LD_INT 32
92631: PUSH
92632: LD_INT 33
92634: PUSH
92635: LD_INT 34
92637: PUSH
92638: LD_INT 36
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 101
92679: PUSH
92680: LD_INT 102
92682: PUSH
92683: LD_INT 103
92685: PUSH
92686: LD_INT 104
92688: PUSH
92689: LD_INT 105
92691: PUSH
92692: LD_INT 106
92694: PUSH
92695: LD_INT 107
92697: PUSH
92698: LD_INT 108
92700: PUSH
92701: LD_INT 109
92703: PUSH
92704: LD_INT 110
92706: PUSH
92707: LD_INT 111
92709: PUSH
92710: LD_INT 112
92712: PUSH
92713: LD_INT 113
92715: PUSH
92716: LD_INT 114
92718: PUSH
92719: EMPTY
92720: LIST
92721: LIST
92722: LIST
92723: LIST
92724: LIST
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: PUSH
92735: EMPTY
92736: LIST
92737: LIST
92738: ST_TO_ADDR
92739: GO 94110
92741: LD_INT 13
92743: DOUBLE
92744: EQUAL
92745: IFTRUE 92749
92747: GO 92945
92749: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
92750: LD_ADDR_VAR 0 1
92754: PUSH
92755: LD_INT 1
92757: PUSH
92758: LD_INT 2
92760: PUSH
92761: LD_INT 3
92763: PUSH
92764: LD_INT 4
92766: PUSH
92767: LD_INT 5
92769: PUSH
92770: LD_INT 8
92772: PUSH
92773: LD_INT 9
92775: PUSH
92776: LD_INT 10
92778: PUSH
92779: LD_INT 11
92781: PUSH
92782: LD_INT 12
92784: PUSH
92785: LD_INT 14
92787: PUSH
92788: LD_INT 15
92790: PUSH
92791: LD_INT 16
92793: PUSH
92794: LD_INT 17
92796: PUSH
92797: LD_INT 18
92799: PUSH
92800: LD_INT 19
92802: PUSH
92803: LD_INT 20
92805: PUSH
92806: LD_INT 21
92808: PUSH
92809: LD_INT 22
92811: PUSH
92812: LD_INT 23
92814: PUSH
92815: LD_INT 24
92817: PUSH
92818: LD_INT 25
92820: PUSH
92821: LD_INT 26
92823: PUSH
92824: LD_INT 27
92826: PUSH
92827: LD_INT 28
92829: PUSH
92830: LD_INT 30
92832: PUSH
92833: LD_INT 31
92835: PUSH
92836: LD_INT 32
92838: PUSH
92839: LD_INT 33
92841: PUSH
92842: LD_INT 34
92844: PUSH
92845: LD_INT 36
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: PUSH
92881: LD_INT 101
92883: PUSH
92884: LD_INT 102
92886: PUSH
92887: LD_INT 103
92889: PUSH
92890: LD_INT 104
92892: PUSH
92893: LD_INT 105
92895: PUSH
92896: LD_INT 106
92898: PUSH
92899: LD_INT 107
92901: PUSH
92902: LD_INT 108
92904: PUSH
92905: LD_INT 109
92907: PUSH
92908: LD_INT 110
92910: PUSH
92911: LD_INT 111
92913: PUSH
92914: LD_INT 112
92916: PUSH
92917: LD_INT 113
92919: PUSH
92920: LD_INT 114
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: ST_TO_ADDR
92943: GO 94110
92945: LD_INT 14
92947: DOUBLE
92948: EQUAL
92949: IFTRUE 92953
92951: GO 93165
92953: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
92954: LD_ADDR_VAR 0 1
92958: PUSH
92959: LD_INT 1
92961: PUSH
92962: LD_INT 2
92964: PUSH
92965: LD_INT 3
92967: PUSH
92968: LD_INT 4
92970: PUSH
92971: LD_INT 5
92973: PUSH
92974: LD_INT 6
92976: PUSH
92977: LD_INT 7
92979: PUSH
92980: LD_INT 8
92982: PUSH
92983: LD_INT 9
92985: PUSH
92986: LD_INT 10
92988: PUSH
92989: LD_INT 11
92991: PUSH
92992: LD_INT 12
92994: PUSH
92995: LD_INT 13
92997: PUSH
92998: LD_INT 14
93000: PUSH
93001: LD_INT 15
93003: PUSH
93004: LD_INT 16
93006: PUSH
93007: LD_INT 17
93009: PUSH
93010: LD_INT 18
93012: PUSH
93013: LD_INT 19
93015: PUSH
93016: LD_INT 20
93018: PUSH
93019: LD_INT 21
93021: PUSH
93022: LD_INT 22
93024: PUSH
93025: LD_INT 23
93027: PUSH
93028: LD_INT 24
93030: PUSH
93031: LD_INT 25
93033: PUSH
93034: LD_INT 26
93036: PUSH
93037: LD_INT 27
93039: PUSH
93040: LD_INT 28
93042: PUSH
93043: LD_INT 29
93045: PUSH
93046: LD_INT 30
93048: PUSH
93049: LD_INT 31
93051: PUSH
93052: LD_INT 32
93054: PUSH
93055: LD_INT 33
93057: PUSH
93058: LD_INT 34
93060: PUSH
93061: LD_INT 36
93063: PUSH
93064: EMPTY
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: LIST
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: LIST
93096: LIST
93097: LIST
93098: LIST
93099: LIST
93100: PUSH
93101: LD_INT 101
93103: PUSH
93104: LD_INT 102
93106: PUSH
93107: LD_INT 103
93109: PUSH
93110: LD_INT 104
93112: PUSH
93113: LD_INT 105
93115: PUSH
93116: LD_INT 106
93118: PUSH
93119: LD_INT 107
93121: PUSH
93122: LD_INT 108
93124: PUSH
93125: LD_INT 109
93127: PUSH
93128: LD_INT 110
93130: PUSH
93131: LD_INT 111
93133: PUSH
93134: LD_INT 112
93136: PUSH
93137: LD_INT 113
93139: PUSH
93140: LD_INT 114
93142: PUSH
93143: EMPTY
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: PUSH
93159: EMPTY
93160: LIST
93161: LIST
93162: ST_TO_ADDR
93163: GO 94110
93165: LD_INT 15
93167: DOUBLE
93168: EQUAL
93169: IFTRUE 93173
93171: GO 93385
93173: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
93174: LD_ADDR_VAR 0 1
93178: PUSH
93179: LD_INT 1
93181: PUSH
93182: LD_INT 2
93184: PUSH
93185: LD_INT 3
93187: PUSH
93188: LD_INT 4
93190: PUSH
93191: LD_INT 5
93193: PUSH
93194: LD_INT 6
93196: PUSH
93197: LD_INT 7
93199: PUSH
93200: LD_INT 8
93202: PUSH
93203: LD_INT 9
93205: PUSH
93206: LD_INT 10
93208: PUSH
93209: LD_INT 11
93211: PUSH
93212: LD_INT 12
93214: PUSH
93215: LD_INT 13
93217: PUSH
93218: LD_INT 14
93220: PUSH
93221: LD_INT 15
93223: PUSH
93224: LD_INT 16
93226: PUSH
93227: LD_INT 17
93229: PUSH
93230: LD_INT 18
93232: PUSH
93233: LD_INT 19
93235: PUSH
93236: LD_INT 20
93238: PUSH
93239: LD_INT 21
93241: PUSH
93242: LD_INT 22
93244: PUSH
93245: LD_INT 23
93247: PUSH
93248: LD_INT 24
93250: PUSH
93251: LD_INT 25
93253: PUSH
93254: LD_INT 26
93256: PUSH
93257: LD_INT 27
93259: PUSH
93260: LD_INT 28
93262: PUSH
93263: LD_INT 29
93265: PUSH
93266: LD_INT 30
93268: PUSH
93269: LD_INT 31
93271: PUSH
93272: LD_INT 32
93274: PUSH
93275: LD_INT 33
93277: PUSH
93278: LD_INT 34
93280: PUSH
93281: LD_INT 36
93283: PUSH
93284: EMPTY
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: LIST
93298: LIST
93299: LIST
93300: LIST
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: PUSH
93321: LD_INT 101
93323: PUSH
93324: LD_INT 102
93326: PUSH
93327: LD_INT 103
93329: PUSH
93330: LD_INT 104
93332: PUSH
93333: LD_INT 105
93335: PUSH
93336: LD_INT 106
93338: PUSH
93339: LD_INT 107
93341: PUSH
93342: LD_INT 108
93344: PUSH
93345: LD_INT 109
93347: PUSH
93348: LD_INT 110
93350: PUSH
93351: LD_INT 111
93353: PUSH
93354: LD_INT 112
93356: PUSH
93357: LD_INT 113
93359: PUSH
93360: LD_INT 114
93362: PUSH
93363: EMPTY
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: PUSH
93379: EMPTY
93380: LIST
93381: LIST
93382: ST_TO_ADDR
93383: GO 94110
93385: LD_INT 16
93387: DOUBLE
93388: EQUAL
93389: IFTRUE 93393
93391: GO 93517
93393: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
93394: LD_ADDR_VAR 0 1
93398: PUSH
93399: LD_INT 2
93401: PUSH
93402: LD_INT 4
93404: PUSH
93405: LD_INT 5
93407: PUSH
93408: LD_INT 7
93410: PUSH
93411: LD_INT 11
93413: PUSH
93414: LD_INT 12
93416: PUSH
93417: LD_INT 15
93419: PUSH
93420: LD_INT 16
93422: PUSH
93423: LD_INT 20
93425: PUSH
93426: LD_INT 21
93428: PUSH
93429: LD_INT 22
93431: PUSH
93432: LD_INT 23
93434: PUSH
93435: LD_INT 25
93437: PUSH
93438: LD_INT 26
93440: PUSH
93441: LD_INT 30
93443: PUSH
93444: LD_INT 31
93446: PUSH
93447: LD_INT 32
93449: PUSH
93450: LD_INT 33
93452: PUSH
93453: LD_INT 34
93455: PUSH
93456: EMPTY
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: PUSH
93477: LD_INT 101
93479: PUSH
93480: LD_INT 102
93482: PUSH
93483: LD_INT 103
93485: PUSH
93486: LD_INT 106
93488: PUSH
93489: LD_INT 108
93491: PUSH
93492: LD_INT 112
93494: PUSH
93495: LD_INT 113
93497: PUSH
93498: LD_INT 114
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: LIST
93508: LIST
93509: LIST
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: ST_TO_ADDR
93515: GO 94110
93517: LD_INT 17
93519: DOUBLE
93520: EQUAL
93521: IFTRUE 93525
93523: GO 93737
93525: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
93526: LD_ADDR_VAR 0 1
93530: PUSH
93531: LD_INT 1
93533: PUSH
93534: LD_INT 2
93536: PUSH
93537: LD_INT 3
93539: PUSH
93540: LD_INT 4
93542: PUSH
93543: LD_INT 5
93545: PUSH
93546: LD_INT 6
93548: PUSH
93549: LD_INT 7
93551: PUSH
93552: LD_INT 8
93554: PUSH
93555: LD_INT 9
93557: PUSH
93558: LD_INT 10
93560: PUSH
93561: LD_INT 11
93563: PUSH
93564: LD_INT 12
93566: PUSH
93567: LD_INT 13
93569: PUSH
93570: LD_INT 14
93572: PUSH
93573: LD_INT 15
93575: PUSH
93576: LD_INT 16
93578: PUSH
93579: LD_INT 17
93581: PUSH
93582: LD_INT 18
93584: PUSH
93585: LD_INT 19
93587: PUSH
93588: LD_INT 20
93590: PUSH
93591: LD_INT 21
93593: PUSH
93594: LD_INT 22
93596: PUSH
93597: LD_INT 23
93599: PUSH
93600: LD_INT 24
93602: PUSH
93603: LD_INT 25
93605: PUSH
93606: LD_INT 26
93608: PUSH
93609: LD_INT 27
93611: PUSH
93612: LD_INT 28
93614: PUSH
93615: LD_INT 29
93617: PUSH
93618: LD_INT 30
93620: PUSH
93621: LD_INT 31
93623: PUSH
93624: LD_INT 32
93626: PUSH
93627: LD_INT 33
93629: PUSH
93630: LD_INT 34
93632: PUSH
93633: LD_INT 36
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: LIST
93640: LIST
93641: LIST
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: LIST
93648: LIST
93649: LIST
93650: LIST
93651: LIST
93652: LIST
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: LIST
93662: LIST
93663: LIST
93664: LIST
93665: LIST
93666: LIST
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: PUSH
93673: LD_INT 101
93675: PUSH
93676: LD_INT 102
93678: PUSH
93679: LD_INT 103
93681: PUSH
93682: LD_INT 104
93684: PUSH
93685: LD_INT 105
93687: PUSH
93688: LD_INT 106
93690: PUSH
93691: LD_INT 107
93693: PUSH
93694: LD_INT 108
93696: PUSH
93697: LD_INT 109
93699: PUSH
93700: LD_INT 110
93702: PUSH
93703: LD_INT 111
93705: PUSH
93706: LD_INT 112
93708: PUSH
93709: LD_INT 113
93711: PUSH
93712: LD_INT 114
93714: PUSH
93715: EMPTY
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: PUSH
93731: EMPTY
93732: LIST
93733: LIST
93734: ST_TO_ADDR
93735: GO 94110
93737: LD_INT 18
93739: DOUBLE
93740: EQUAL
93741: IFTRUE 93745
93743: GO 93881
93745: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
93746: LD_ADDR_VAR 0 1
93750: PUSH
93751: LD_INT 2
93753: PUSH
93754: LD_INT 4
93756: PUSH
93757: LD_INT 5
93759: PUSH
93760: LD_INT 7
93762: PUSH
93763: LD_INT 11
93765: PUSH
93766: LD_INT 12
93768: PUSH
93769: LD_INT 15
93771: PUSH
93772: LD_INT 16
93774: PUSH
93775: LD_INT 20
93777: PUSH
93778: LD_INT 21
93780: PUSH
93781: LD_INT 22
93783: PUSH
93784: LD_INT 23
93786: PUSH
93787: LD_INT 25
93789: PUSH
93790: LD_INT 26
93792: PUSH
93793: LD_INT 30
93795: PUSH
93796: LD_INT 31
93798: PUSH
93799: LD_INT 32
93801: PUSH
93802: LD_INT 33
93804: PUSH
93805: LD_INT 34
93807: PUSH
93808: LD_INT 35
93810: PUSH
93811: LD_INT 36
93813: PUSH
93814: EMPTY
93815: LIST
93816: LIST
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: LIST
93822: LIST
93823: LIST
93824: LIST
93825: LIST
93826: LIST
93827: LIST
93828: LIST
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: PUSH
93837: LD_INT 101
93839: PUSH
93840: LD_INT 102
93842: PUSH
93843: LD_INT 103
93845: PUSH
93846: LD_INT 106
93848: PUSH
93849: LD_INT 108
93851: PUSH
93852: LD_INT 112
93854: PUSH
93855: LD_INT 113
93857: PUSH
93858: LD_INT 114
93860: PUSH
93861: LD_INT 115
93863: PUSH
93864: EMPTY
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: PUSH
93875: EMPTY
93876: LIST
93877: LIST
93878: ST_TO_ADDR
93879: GO 94110
93881: LD_INT 19
93883: DOUBLE
93884: EQUAL
93885: IFTRUE 93889
93887: GO 94109
93889: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
93890: LD_ADDR_VAR 0 1
93894: PUSH
93895: LD_INT 1
93897: PUSH
93898: LD_INT 2
93900: PUSH
93901: LD_INT 3
93903: PUSH
93904: LD_INT 4
93906: PUSH
93907: LD_INT 5
93909: PUSH
93910: LD_INT 6
93912: PUSH
93913: LD_INT 7
93915: PUSH
93916: LD_INT 8
93918: PUSH
93919: LD_INT 9
93921: PUSH
93922: LD_INT 10
93924: PUSH
93925: LD_INT 11
93927: PUSH
93928: LD_INT 12
93930: PUSH
93931: LD_INT 13
93933: PUSH
93934: LD_INT 14
93936: PUSH
93937: LD_INT 15
93939: PUSH
93940: LD_INT 16
93942: PUSH
93943: LD_INT 17
93945: PUSH
93946: LD_INT 18
93948: PUSH
93949: LD_INT 19
93951: PUSH
93952: LD_INT 20
93954: PUSH
93955: LD_INT 21
93957: PUSH
93958: LD_INT 22
93960: PUSH
93961: LD_INT 23
93963: PUSH
93964: LD_INT 24
93966: PUSH
93967: LD_INT 25
93969: PUSH
93970: LD_INT 26
93972: PUSH
93973: LD_INT 27
93975: PUSH
93976: LD_INT 28
93978: PUSH
93979: LD_INT 29
93981: PUSH
93982: LD_INT 30
93984: PUSH
93985: LD_INT 31
93987: PUSH
93988: LD_INT 32
93990: PUSH
93991: LD_INT 33
93993: PUSH
93994: LD_INT 34
93996: PUSH
93997: LD_INT 35
93999: PUSH
94000: LD_INT 36
94002: PUSH
94003: EMPTY
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: PUSH
94041: LD_INT 101
94043: PUSH
94044: LD_INT 102
94046: PUSH
94047: LD_INT 103
94049: PUSH
94050: LD_INT 104
94052: PUSH
94053: LD_INT 105
94055: PUSH
94056: LD_INT 106
94058: PUSH
94059: LD_INT 107
94061: PUSH
94062: LD_INT 108
94064: PUSH
94065: LD_INT 109
94067: PUSH
94068: LD_INT 110
94070: PUSH
94071: LD_INT 111
94073: PUSH
94074: LD_INT 112
94076: PUSH
94077: LD_INT 113
94079: PUSH
94080: LD_INT 114
94082: PUSH
94083: LD_INT 115
94085: PUSH
94086: EMPTY
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: PUSH
94103: EMPTY
94104: LIST
94105: LIST
94106: ST_TO_ADDR
94107: GO 94110
94109: POP
// end else
94110: GO 94329
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
94112: LD_ADDR_VAR 0 1
94116: PUSH
94117: LD_INT 1
94119: PUSH
94120: LD_INT 2
94122: PUSH
94123: LD_INT 3
94125: PUSH
94126: LD_INT 4
94128: PUSH
94129: LD_INT 5
94131: PUSH
94132: LD_INT 6
94134: PUSH
94135: LD_INT 7
94137: PUSH
94138: LD_INT 8
94140: PUSH
94141: LD_INT 9
94143: PUSH
94144: LD_INT 10
94146: PUSH
94147: LD_INT 11
94149: PUSH
94150: LD_INT 12
94152: PUSH
94153: LD_INT 13
94155: PUSH
94156: LD_INT 14
94158: PUSH
94159: LD_INT 15
94161: PUSH
94162: LD_INT 16
94164: PUSH
94165: LD_INT 17
94167: PUSH
94168: LD_INT 18
94170: PUSH
94171: LD_INT 19
94173: PUSH
94174: LD_INT 20
94176: PUSH
94177: LD_INT 21
94179: PUSH
94180: LD_INT 22
94182: PUSH
94183: LD_INT 23
94185: PUSH
94186: LD_INT 24
94188: PUSH
94189: LD_INT 25
94191: PUSH
94192: LD_INT 26
94194: PUSH
94195: LD_INT 27
94197: PUSH
94198: LD_INT 28
94200: PUSH
94201: LD_INT 29
94203: PUSH
94204: LD_INT 30
94206: PUSH
94207: LD_INT 31
94209: PUSH
94210: LD_INT 32
94212: PUSH
94213: LD_INT 33
94215: PUSH
94216: LD_INT 34
94218: PUSH
94219: LD_INT 35
94221: PUSH
94222: LD_INT 36
94224: PUSH
94225: EMPTY
94226: LIST
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: LIST
94235: LIST
94236: LIST
94237: LIST
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: LIST
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: LIST
94256: LIST
94257: LIST
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 101
94265: PUSH
94266: LD_INT 102
94268: PUSH
94269: LD_INT 103
94271: PUSH
94272: LD_INT 104
94274: PUSH
94275: LD_INT 105
94277: PUSH
94278: LD_INT 106
94280: PUSH
94281: LD_INT 107
94283: PUSH
94284: LD_INT 108
94286: PUSH
94287: LD_INT 109
94289: PUSH
94290: LD_INT 110
94292: PUSH
94293: LD_INT 111
94295: PUSH
94296: LD_INT 112
94298: PUSH
94299: LD_INT 113
94301: PUSH
94302: LD_INT 114
94304: PUSH
94305: LD_INT 115
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: ST_TO_ADDR
// if result then
94329: LD_VAR 0 1
94333: IFFALSE 94622
// begin normal :=  ;
94335: LD_ADDR_VAR 0 3
94339: PUSH
94340: LD_STRING 
94342: ST_TO_ADDR
// hardcore :=  ;
94343: LD_ADDR_VAR 0 4
94347: PUSH
94348: LD_STRING 
94350: ST_TO_ADDR
// for i = 1 to normalCounter do
94351: LD_ADDR_VAR 0 5
94355: PUSH
94356: DOUBLE
94357: LD_INT 1
94359: DEC
94360: ST_TO_ADDR
94361: LD_EXP 138
94365: PUSH
94366: FOR_TO
94367: IFFALSE 94468
// begin tmp := 0 ;
94369: LD_ADDR_VAR 0 2
94373: PUSH
94374: LD_STRING 0
94376: ST_TO_ADDR
// if result [ 1 ] then
94377: LD_VAR 0 1
94381: PUSH
94382: LD_INT 1
94384: ARRAY
94385: IFFALSE 94450
// if result [ 1 ] [ 1 ] = i then
94387: LD_VAR 0 1
94391: PUSH
94392: LD_INT 1
94394: ARRAY
94395: PUSH
94396: LD_INT 1
94398: ARRAY
94399: PUSH
94400: LD_VAR 0 5
94404: EQUAL
94405: IFFALSE 94450
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
94407: LD_ADDR_VAR 0 1
94411: PUSH
94412: LD_VAR 0 1
94416: PPUSH
94417: LD_INT 1
94419: PPUSH
94420: LD_VAR 0 1
94424: PUSH
94425: LD_INT 1
94427: ARRAY
94428: PPUSH
94429: LD_INT 1
94431: PPUSH
94432: CALL_OW 3
94436: PPUSH
94437: CALL_OW 1
94441: ST_TO_ADDR
// tmp := 1 ;
94442: LD_ADDR_VAR 0 2
94446: PUSH
94447: LD_STRING 1
94449: ST_TO_ADDR
// end ; normal := normal & tmp ;
94450: LD_ADDR_VAR 0 3
94454: PUSH
94455: LD_VAR 0 3
94459: PUSH
94460: LD_VAR 0 2
94464: STR
94465: ST_TO_ADDR
// end ;
94466: GO 94366
94468: POP
94469: POP
// for i = 1 to hardcoreCounter do
94470: LD_ADDR_VAR 0 5
94474: PUSH
94475: DOUBLE
94476: LD_INT 1
94478: DEC
94479: ST_TO_ADDR
94480: LD_EXP 139
94484: PUSH
94485: FOR_TO
94486: IFFALSE 94591
// begin tmp := 0 ;
94488: LD_ADDR_VAR 0 2
94492: PUSH
94493: LD_STRING 0
94495: ST_TO_ADDR
// if result [ 2 ] then
94496: LD_VAR 0 1
94500: PUSH
94501: LD_INT 2
94503: ARRAY
94504: IFFALSE 94573
// if result [ 2 ] [ 1 ] = 100 + i then
94506: LD_VAR 0 1
94510: PUSH
94511: LD_INT 2
94513: ARRAY
94514: PUSH
94515: LD_INT 1
94517: ARRAY
94518: PUSH
94519: LD_INT 100
94521: PUSH
94522: LD_VAR 0 5
94526: PLUS
94527: EQUAL
94528: IFFALSE 94573
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
94530: LD_ADDR_VAR 0 1
94534: PUSH
94535: LD_VAR 0 1
94539: PPUSH
94540: LD_INT 2
94542: PPUSH
94543: LD_VAR 0 1
94547: PUSH
94548: LD_INT 2
94550: ARRAY
94551: PPUSH
94552: LD_INT 1
94554: PPUSH
94555: CALL_OW 3
94559: PPUSH
94560: CALL_OW 1
94564: ST_TO_ADDR
// tmp := 1 ;
94565: LD_ADDR_VAR 0 2
94569: PUSH
94570: LD_STRING 1
94572: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
94573: LD_ADDR_VAR 0 4
94577: PUSH
94578: LD_VAR 0 4
94582: PUSH
94583: LD_VAR 0 2
94587: STR
94588: ST_TO_ADDR
// end ;
94589: GO 94485
94591: POP
94592: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
94593: LD_STRING getStreamItemsFromMission("
94595: PUSH
94596: LD_VAR 0 3
94600: STR
94601: PUSH
94602: LD_STRING ","
94604: STR
94605: PUSH
94606: LD_VAR 0 4
94610: STR
94611: PUSH
94612: LD_STRING ")
94614: STR
94615: PPUSH
94616: CALL_OW 559
// end else
94620: GO 94629
// ToLua ( getStreamItemsFromMission("","") ) ;
94622: LD_STRING getStreamItemsFromMission("","")
94624: PPUSH
94625: CALL_OW 559
// end ;
94629: LD_VAR 0 1
94633: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
94634: LD_EXP 137
94638: PUSH
94639: LD_EXP 142
94643: AND
94644: IFFALSE 94768
94646: GO 94648
94648: DISABLE
94649: LD_INT 0
94651: PPUSH
94652: PPUSH
// begin enable ;
94653: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
94654: LD_ADDR_VAR 0 2
94658: PUSH
94659: LD_INT 22
94661: PUSH
94662: LD_OWVAR 2
94666: PUSH
94667: EMPTY
94668: LIST
94669: LIST
94670: PUSH
94671: LD_INT 2
94673: PUSH
94674: LD_INT 34
94676: PUSH
94677: LD_INT 7
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 34
94686: PUSH
94687: LD_INT 45
94689: PUSH
94690: EMPTY
94691: LIST
94692: LIST
94693: PUSH
94694: LD_INT 34
94696: PUSH
94697: LD_INT 28
94699: PUSH
94700: EMPTY
94701: LIST
94702: LIST
94703: PUSH
94704: LD_INT 34
94706: PUSH
94707: LD_INT 47
94709: PUSH
94710: EMPTY
94711: LIST
94712: LIST
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: LIST
94720: PUSH
94721: EMPTY
94722: LIST
94723: LIST
94724: PPUSH
94725: CALL_OW 69
94729: ST_TO_ADDR
// if not tmp then
94730: LD_VAR 0 2
94734: NOT
94735: IFFALSE 94739
// exit ;
94737: GO 94768
// for i in tmp do
94739: LD_ADDR_VAR 0 1
94743: PUSH
94744: LD_VAR 0 2
94748: PUSH
94749: FOR_IN
94750: IFFALSE 94766
// begin SetLives ( i , 0 ) ;
94752: LD_VAR 0 1
94756: PPUSH
94757: LD_INT 0
94759: PPUSH
94760: CALL_OW 234
// end ;
94764: GO 94749
94766: POP
94767: POP
// end ;
94768: PPOPN 2
94770: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
94771: LD_EXP 137
94775: PUSH
94776: LD_EXP 143
94780: AND
94781: IFFALSE 94865
94783: GO 94785
94785: DISABLE
94786: LD_INT 0
94788: PPUSH
94789: PPUSH
// begin enable ;
94790: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
94791: LD_ADDR_VAR 0 2
94795: PUSH
94796: LD_INT 22
94798: PUSH
94799: LD_OWVAR 2
94803: PUSH
94804: EMPTY
94805: LIST
94806: LIST
94807: PUSH
94808: LD_INT 32
94810: PUSH
94811: LD_INT 3
94813: PUSH
94814: EMPTY
94815: LIST
94816: LIST
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: PPUSH
94822: CALL_OW 69
94826: ST_TO_ADDR
// if not tmp then
94827: LD_VAR 0 2
94831: NOT
94832: IFFALSE 94836
// exit ;
94834: GO 94865
// for i in tmp do
94836: LD_ADDR_VAR 0 1
94840: PUSH
94841: LD_VAR 0 2
94845: PUSH
94846: FOR_IN
94847: IFFALSE 94863
// begin SetLives ( i , 0 ) ;
94849: LD_VAR 0 1
94853: PPUSH
94854: LD_INT 0
94856: PPUSH
94857: CALL_OW 234
// end ;
94861: GO 94846
94863: POP
94864: POP
// end ;
94865: PPOPN 2
94867: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
94868: LD_EXP 137
94872: PUSH
94873: LD_EXP 140
94877: AND
94878: IFFALSE 94971
94880: GO 94882
94882: DISABLE
94883: LD_INT 0
94885: PPUSH
// begin enable ;
94886: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
94887: LD_ADDR_VAR 0 1
94891: PUSH
94892: LD_INT 22
94894: PUSH
94895: LD_OWVAR 2
94899: PUSH
94900: EMPTY
94901: LIST
94902: LIST
94903: PUSH
94904: LD_INT 2
94906: PUSH
94907: LD_INT 25
94909: PUSH
94910: LD_INT 5
94912: PUSH
94913: EMPTY
94914: LIST
94915: LIST
94916: PUSH
94917: LD_INT 25
94919: PUSH
94920: LD_INT 9
94922: PUSH
94923: EMPTY
94924: LIST
94925: LIST
94926: PUSH
94927: LD_INT 25
94929: PUSH
94930: LD_INT 8
94932: PUSH
94933: EMPTY
94934: LIST
94935: LIST
94936: PUSH
94937: EMPTY
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: PUSH
94943: EMPTY
94944: LIST
94945: LIST
94946: PPUSH
94947: CALL_OW 69
94951: PUSH
94952: FOR_IN
94953: IFFALSE 94969
// begin SetClass ( i , 1 ) ;
94955: LD_VAR 0 1
94959: PPUSH
94960: LD_INT 1
94962: PPUSH
94963: CALL_OW 336
// end ;
94967: GO 94952
94969: POP
94970: POP
// end ;
94971: PPOPN 1
94973: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
94974: LD_EXP 137
94978: PUSH
94979: LD_EXP 141
94983: AND
94984: PUSH
94985: LD_OWVAR 65
94989: PUSH
94990: LD_INT 7
94992: LESS
94993: AND
94994: IFFALSE 95008
94996: GO 94998
94998: DISABLE
// begin enable ;
94999: ENABLE
// game_speed := 7 ;
95000: LD_ADDR_OWVAR 65
95004: PUSH
95005: LD_INT 7
95007: ST_TO_ADDR
// end ;
95008: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
95009: LD_EXP 137
95013: PUSH
95014: LD_EXP 144
95018: AND
95019: IFFALSE 95221
95021: GO 95023
95023: DISABLE
95024: LD_INT 0
95026: PPUSH
95027: PPUSH
95028: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
95029: LD_ADDR_VAR 0 3
95033: PUSH
95034: LD_INT 81
95036: PUSH
95037: LD_OWVAR 2
95041: PUSH
95042: EMPTY
95043: LIST
95044: LIST
95045: PUSH
95046: LD_INT 21
95048: PUSH
95049: LD_INT 1
95051: PUSH
95052: EMPTY
95053: LIST
95054: LIST
95055: PUSH
95056: EMPTY
95057: LIST
95058: LIST
95059: PPUSH
95060: CALL_OW 69
95064: ST_TO_ADDR
// if not tmp then
95065: LD_VAR 0 3
95069: NOT
95070: IFFALSE 95074
// exit ;
95072: GO 95221
// if tmp > 5 then
95074: LD_VAR 0 3
95078: PUSH
95079: LD_INT 5
95081: GREATER
95082: IFFALSE 95094
// k := 5 else
95084: LD_ADDR_VAR 0 2
95088: PUSH
95089: LD_INT 5
95091: ST_TO_ADDR
95092: GO 95104
// k := tmp ;
95094: LD_ADDR_VAR 0 2
95098: PUSH
95099: LD_VAR 0 3
95103: ST_TO_ADDR
// for i := 1 to k do
95104: LD_ADDR_VAR 0 1
95108: PUSH
95109: DOUBLE
95110: LD_INT 1
95112: DEC
95113: ST_TO_ADDR
95114: LD_VAR 0 2
95118: PUSH
95119: FOR_TO
95120: IFFALSE 95219
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
95122: LD_VAR 0 3
95126: PUSH
95127: LD_VAR 0 1
95131: ARRAY
95132: PPUSH
95133: LD_VAR 0 1
95137: PUSH
95138: LD_INT 4
95140: MOD
95141: PUSH
95142: LD_INT 1
95144: PLUS
95145: PPUSH
95146: CALL_OW 259
95150: PUSH
95151: LD_INT 10
95153: LESS
95154: IFFALSE 95217
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
95156: LD_VAR 0 3
95160: PUSH
95161: LD_VAR 0 1
95165: ARRAY
95166: PPUSH
95167: LD_VAR 0 1
95171: PUSH
95172: LD_INT 4
95174: MOD
95175: PUSH
95176: LD_INT 1
95178: PLUS
95179: PPUSH
95180: LD_VAR 0 3
95184: PUSH
95185: LD_VAR 0 1
95189: ARRAY
95190: PPUSH
95191: LD_VAR 0 1
95195: PUSH
95196: LD_INT 4
95198: MOD
95199: PUSH
95200: LD_INT 1
95202: PLUS
95203: PPUSH
95204: CALL_OW 259
95208: PUSH
95209: LD_INT 1
95211: PLUS
95212: PPUSH
95213: CALL_OW 237
95217: GO 95119
95219: POP
95220: POP
// end ;
95221: PPOPN 3
95223: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
95224: LD_EXP 137
95228: PUSH
95229: LD_EXP 145
95233: AND
95234: IFFALSE 95254
95236: GO 95238
95238: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
95239: LD_INT 4
95241: PPUSH
95242: LD_OWVAR 2
95246: PPUSH
95247: LD_INT 0
95249: PPUSH
95250: CALL_OW 324
95254: END
// every 0 0$1 trigger StreamModeActive and sShovel do
95255: LD_EXP 137
95259: PUSH
95260: LD_EXP 174
95264: AND
95265: IFFALSE 95285
95267: GO 95269
95269: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
95270: LD_INT 19
95272: PPUSH
95273: LD_OWVAR 2
95277: PPUSH
95278: LD_INT 0
95280: PPUSH
95281: CALL_OW 324
95285: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
95286: LD_EXP 137
95290: PUSH
95291: LD_EXP 146
95295: AND
95296: IFFALSE 95398
95298: GO 95300
95300: DISABLE
95301: LD_INT 0
95303: PPUSH
95304: PPUSH
// begin enable ;
95305: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
95306: LD_ADDR_VAR 0 2
95310: PUSH
95311: LD_INT 22
95313: PUSH
95314: LD_OWVAR 2
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: PUSH
95323: LD_INT 2
95325: PUSH
95326: LD_INT 34
95328: PUSH
95329: LD_INT 11
95331: PUSH
95332: EMPTY
95333: LIST
95334: LIST
95335: PUSH
95336: LD_INT 34
95338: PUSH
95339: LD_INT 30
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: LIST
95350: PUSH
95351: EMPTY
95352: LIST
95353: LIST
95354: PPUSH
95355: CALL_OW 69
95359: ST_TO_ADDR
// if not tmp then
95360: LD_VAR 0 2
95364: NOT
95365: IFFALSE 95369
// exit ;
95367: GO 95398
// for i in tmp do
95369: LD_ADDR_VAR 0 1
95373: PUSH
95374: LD_VAR 0 2
95378: PUSH
95379: FOR_IN
95380: IFFALSE 95396
// begin SetLives ( i , 0 ) ;
95382: LD_VAR 0 1
95386: PPUSH
95387: LD_INT 0
95389: PPUSH
95390: CALL_OW 234
// end ;
95394: GO 95379
95396: POP
95397: POP
// end ;
95398: PPOPN 2
95400: END
// every 0 0$1 trigger StreamModeActive and sBunker do
95401: LD_EXP 137
95405: PUSH
95406: LD_EXP 147
95410: AND
95411: IFFALSE 95431
95413: GO 95415
95415: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
95416: LD_INT 32
95418: PPUSH
95419: LD_OWVAR 2
95423: PPUSH
95424: LD_INT 0
95426: PPUSH
95427: CALL_OW 324
95431: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
95432: LD_EXP 137
95436: PUSH
95437: LD_EXP 148
95441: AND
95442: IFFALSE 95623
95444: GO 95446
95446: DISABLE
95447: LD_INT 0
95449: PPUSH
95450: PPUSH
95451: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
95452: LD_ADDR_VAR 0 2
95456: PUSH
95457: LD_INT 22
95459: PUSH
95460: LD_OWVAR 2
95464: PUSH
95465: EMPTY
95466: LIST
95467: LIST
95468: PUSH
95469: LD_INT 33
95471: PUSH
95472: LD_INT 3
95474: PUSH
95475: EMPTY
95476: LIST
95477: LIST
95478: PUSH
95479: EMPTY
95480: LIST
95481: LIST
95482: PPUSH
95483: CALL_OW 69
95487: ST_TO_ADDR
// if not tmp then
95488: LD_VAR 0 2
95492: NOT
95493: IFFALSE 95497
// exit ;
95495: GO 95623
// side := 0 ;
95497: LD_ADDR_VAR 0 3
95501: PUSH
95502: LD_INT 0
95504: ST_TO_ADDR
// for i := 1 to 8 do
95505: LD_ADDR_VAR 0 1
95509: PUSH
95510: DOUBLE
95511: LD_INT 1
95513: DEC
95514: ST_TO_ADDR
95515: LD_INT 8
95517: PUSH
95518: FOR_TO
95519: IFFALSE 95567
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
95521: LD_OWVAR 2
95525: PUSH
95526: LD_VAR 0 1
95530: NONEQUAL
95531: PUSH
95532: LD_OWVAR 2
95536: PPUSH
95537: LD_VAR 0 1
95541: PPUSH
95542: CALL_OW 81
95546: PUSH
95547: LD_INT 2
95549: EQUAL
95550: AND
95551: IFFALSE 95565
// begin side := i ;
95553: LD_ADDR_VAR 0 3
95557: PUSH
95558: LD_VAR 0 1
95562: ST_TO_ADDR
// break ;
95563: GO 95567
// end ;
95565: GO 95518
95567: POP
95568: POP
// if not side then
95569: LD_VAR 0 3
95573: NOT
95574: IFFALSE 95578
// exit ;
95576: GO 95623
// for i := 1 to tmp do
95578: LD_ADDR_VAR 0 1
95582: PUSH
95583: DOUBLE
95584: LD_INT 1
95586: DEC
95587: ST_TO_ADDR
95588: LD_VAR 0 2
95592: PUSH
95593: FOR_TO
95594: IFFALSE 95621
// if Prob ( 60 ) then
95596: LD_INT 60
95598: PPUSH
95599: CALL_OW 13
95603: IFFALSE 95619
// SetSide ( i , side ) ;
95605: LD_VAR 0 1
95609: PPUSH
95610: LD_VAR 0 3
95614: PPUSH
95615: CALL_OW 235
95619: GO 95593
95621: POP
95622: POP
// end ;
95623: PPOPN 3
95625: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
95626: LD_EXP 137
95630: PUSH
95631: LD_EXP 150
95635: AND
95636: IFFALSE 95755
95638: GO 95640
95640: DISABLE
95641: LD_INT 0
95643: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
95644: LD_ADDR_VAR 0 1
95648: PUSH
95649: LD_INT 22
95651: PUSH
95652: LD_OWVAR 2
95656: PUSH
95657: EMPTY
95658: LIST
95659: LIST
95660: PUSH
95661: LD_INT 21
95663: PUSH
95664: LD_INT 1
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: PUSH
95671: LD_INT 3
95673: PUSH
95674: LD_INT 23
95676: PUSH
95677: LD_INT 0
95679: PUSH
95680: EMPTY
95681: LIST
95682: LIST
95683: PUSH
95684: EMPTY
95685: LIST
95686: LIST
95687: PUSH
95688: EMPTY
95689: LIST
95690: LIST
95691: LIST
95692: PPUSH
95693: CALL_OW 69
95697: PUSH
95698: FOR_IN
95699: IFFALSE 95753
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
95701: LD_VAR 0 1
95705: PPUSH
95706: CALL_OW 257
95710: PUSH
95711: LD_INT 1
95713: PUSH
95714: LD_INT 2
95716: PUSH
95717: LD_INT 3
95719: PUSH
95720: LD_INT 4
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: IN
95729: IFFALSE 95751
// SetClass ( un , rand ( 1 , 4 ) ) ;
95731: LD_VAR 0 1
95735: PPUSH
95736: LD_INT 1
95738: PPUSH
95739: LD_INT 4
95741: PPUSH
95742: CALL_OW 12
95746: PPUSH
95747: CALL_OW 336
95751: GO 95698
95753: POP
95754: POP
// end ;
95755: PPOPN 1
95757: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
95758: LD_EXP 137
95762: PUSH
95763: LD_EXP 149
95767: AND
95768: IFFALSE 95847
95770: GO 95772
95772: DISABLE
95773: LD_INT 0
95775: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95776: LD_ADDR_VAR 0 1
95780: PUSH
95781: LD_INT 22
95783: PUSH
95784: LD_OWVAR 2
95788: PUSH
95789: EMPTY
95790: LIST
95791: LIST
95792: PUSH
95793: LD_INT 21
95795: PUSH
95796: LD_INT 3
95798: PUSH
95799: EMPTY
95800: LIST
95801: LIST
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PPUSH
95807: CALL_OW 69
95811: ST_TO_ADDR
// if not tmp then
95812: LD_VAR 0 1
95816: NOT
95817: IFFALSE 95821
// exit ;
95819: GO 95847
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
95821: LD_VAR 0 1
95825: PUSH
95826: LD_INT 1
95828: PPUSH
95829: LD_VAR 0 1
95833: PPUSH
95834: CALL_OW 12
95838: ARRAY
95839: PPUSH
95840: LD_INT 100
95842: PPUSH
95843: CALL_OW 234
// end ;
95847: PPOPN 1
95849: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
95850: LD_EXP 137
95854: PUSH
95855: LD_EXP 151
95859: AND
95860: IFFALSE 95958
95862: GO 95864
95864: DISABLE
95865: LD_INT 0
95867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95868: LD_ADDR_VAR 0 1
95872: PUSH
95873: LD_INT 22
95875: PUSH
95876: LD_OWVAR 2
95880: PUSH
95881: EMPTY
95882: LIST
95883: LIST
95884: PUSH
95885: LD_INT 21
95887: PUSH
95888: LD_INT 1
95890: PUSH
95891: EMPTY
95892: LIST
95893: LIST
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PPUSH
95899: CALL_OW 69
95903: ST_TO_ADDR
// if not tmp then
95904: LD_VAR 0 1
95908: NOT
95909: IFFALSE 95913
// exit ;
95911: GO 95958
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
95913: LD_VAR 0 1
95917: PUSH
95918: LD_INT 1
95920: PPUSH
95921: LD_VAR 0 1
95925: PPUSH
95926: CALL_OW 12
95930: ARRAY
95931: PPUSH
95932: LD_INT 1
95934: PPUSH
95935: LD_INT 4
95937: PPUSH
95938: CALL_OW 12
95942: PPUSH
95943: LD_INT 3000
95945: PPUSH
95946: LD_INT 9000
95948: PPUSH
95949: CALL_OW 12
95953: PPUSH
95954: CALL_OW 492
// end ;
95958: PPOPN 1
95960: END
// every 0 0$1 trigger StreamModeActive and sDepot do
95961: LD_EXP 137
95965: PUSH
95966: LD_EXP 152
95970: AND
95971: IFFALSE 95991
95973: GO 95975
95975: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
95976: LD_INT 1
95978: PPUSH
95979: LD_OWVAR 2
95983: PPUSH
95984: LD_INT 0
95986: PPUSH
95987: CALL_OW 324
95991: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
95992: LD_EXP 137
95996: PUSH
95997: LD_EXP 153
96001: AND
96002: IFFALSE 96085
96004: GO 96006
96006: DISABLE
96007: LD_INT 0
96009: PPUSH
96010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96011: LD_ADDR_VAR 0 2
96015: PUSH
96016: LD_INT 22
96018: PUSH
96019: LD_OWVAR 2
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PUSH
96028: LD_INT 21
96030: PUSH
96031: LD_INT 3
96033: PUSH
96034: EMPTY
96035: LIST
96036: LIST
96037: PUSH
96038: EMPTY
96039: LIST
96040: LIST
96041: PPUSH
96042: CALL_OW 69
96046: ST_TO_ADDR
// if not tmp then
96047: LD_VAR 0 2
96051: NOT
96052: IFFALSE 96056
// exit ;
96054: GO 96085
// for i in tmp do
96056: LD_ADDR_VAR 0 1
96060: PUSH
96061: LD_VAR 0 2
96065: PUSH
96066: FOR_IN
96067: IFFALSE 96083
// SetBLevel ( i , 10 ) ;
96069: LD_VAR 0 1
96073: PPUSH
96074: LD_INT 10
96076: PPUSH
96077: CALL_OW 241
96081: GO 96066
96083: POP
96084: POP
// end ;
96085: PPOPN 2
96087: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
96088: LD_EXP 137
96092: PUSH
96093: LD_EXP 154
96097: AND
96098: IFFALSE 96209
96100: GO 96102
96102: DISABLE
96103: LD_INT 0
96105: PPUSH
96106: PPUSH
96107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96108: LD_ADDR_VAR 0 3
96112: PUSH
96113: LD_INT 22
96115: PUSH
96116: LD_OWVAR 2
96120: PUSH
96121: EMPTY
96122: LIST
96123: LIST
96124: PUSH
96125: LD_INT 25
96127: PUSH
96128: LD_INT 1
96130: PUSH
96131: EMPTY
96132: LIST
96133: LIST
96134: PUSH
96135: EMPTY
96136: LIST
96137: LIST
96138: PPUSH
96139: CALL_OW 69
96143: ST_TO_ADDR
// if not tmp then
96144: LD_VAR 0 3
96148: NOT
96149: IFFALSE 96153
// exit ;
96151: GO 96209
// un := tmp [ rand ( 1 , tmp ) ] ;
96153: LD_ADDR_VAR 0 2
96157: PUSH
96158: LD_VAR 0 3
96162: PUSH
96163: LD_INT 1
96165: PPUSH
96166: LD_VAR 0 3
96170: PPUSH
96171: CALL_OW 12
96175: ARRAY
96176: ST_TO_ADDR
// if Crawls ( un ) then
96177: LD_VAR 0 2
96181: PPUSH
96182: CALL_OW 318
96186: IFFALSE 96197
// ComWalk ( un ) ;
96188: LD_VAR 0 2
96192: PPUSH
96193: CALL_OW 138
// SetClass ( un , class_sniper ) ;
96197: LD_VAR 0 2
96201: PPUSH
96202: LD_INT 5
96204: PPUSH
96205: CALL_OW 336
// end ;
96209: PPOPN 3
96211: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
96212: LD_EXP 137
96216: PUSH
96217: LD_EXP 155
96221: AND
96222: PUSH
96223: LD_OWVAR 67
96227: PUSH
96228: LD_INT 3
96230: LESS
96231: AND
96232: IFFALSE 96251
96234: GO 96236
96236: DISABLE
// Difficulty := Difficulty + 1 ;
96237: LD_ADDR_OWVAR 67
96241: PUSH
96242: LD_OWVAR 67
96246: PUSH
96247: LD_INT 1
96249: PLUS
96250: ST_TO_ADDR
96251: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
96252: LD_EXP 137
96256: PUSH
96257: LD_EXP 156
96261: AND
96262: IFFALSE 96365
96264: GO 96266
96266: DISABLE
96267: LD_INT 0
96269: PPUSH
// begin for i := 1 to 5 do
96270: LD_ADDR_VAR 0 1
96274: PUSH
96275: DOUBLE
96276: LD_INT 1
96278: DEC
96279: ST_TO_ADDR
96280: LD_INT 5
96282: PUSH
96283: FOR_TO
96284: IFFALSE 96363
// begin uc_nation := nation_nature ;
96286: LD_ADDR_OWVAR 21
96290: PUSH
96291: LD_INT 0
96293: ST_TO_ADDR
// uc_side := 0 ;
96294: LD_ADDR_OWVAR 20
96298: PUSH
96299: LD_INT 0
96301: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96302: LD_ADDR_OWVAR 29
96306: PUSH
96307: LD_INT 12
96309: PUSH
96310: LD_INT 12
96312: PUSH
96313: EMPTY
96314: LIST
96315: LIST
96316: ST_TO_ADDR
// hc_agressivity := 20 ;
96317: LD_ADDR_OWVAR 35
96321: PUSH
96322: LD_INT 20
96324: ST_TO_ADDR
// hc_class := class_tiger ;
96325: LD_ADDR_OWVAR 28
96329: PUSH
96330: LD_INT 14
96332: ST_TO_ADDR
// hc_gallery :=  ;
96333: LD_ADDR_OWVAR 33
96337: PUSH
96338: LD_STRING 
96340: ST_TO_ADDR
// hc_name :=  ;
96341: LD_ADDR_OWVAR 26
96345: PUSH
96346: LD_STRING 
96348: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
96349: CALL_OW 44
96353: PPUSH
96354: LD_INT 0
96356: PPUSH
96357: CALL_OW 51
// end ;
96361: GO 96283
96363: POP
96364: POP
// end ;
96365: PPOPN 1
96367: END
// every 0 0$1 trigger StreamModeActive and sBomb do
96368: LD_EXP 137
96372: PUSH
96373: LD_EXP 157
96377: AND
96378: IFFALSE 96387
96380: GO 96382
96382: DISABLE
// StreamSibBomb ;
96383: CALL 96388 0 0
96387: END
// export function StreamSibBomb ; var i , x , y ; begin
96388: LD_INT 0
96390: PPUSH
96391: PPUSH
96392: PPUSH
96393: PPUSH
// result := false ;
96394: LD_ADDR_VAR 0 1
96398: PUSH
96399: LD_INT 0
96401: ST_TO_ADDR
// for i := 1 to 16 do
96402: LD_ADDR_VAR 0 2
96406: PUSH
96407: DOUBLE
96408: LD_INT 1
96410: DEC
96411: ST_TO_ADDR
96412: LD_INT 16
96414: PUSH
96415: FOR_TO
96416: IFFALSE 96615
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96418: LD_ADDR_VAR 0 3
96422: PUSH
96423: LD_INT 10
96425: PUSH
96426: LD_INT 20
96428: PUSH
96429: LD_INT 30
96431: PUSH
96432: LD_INT 40
96434: PUSH
96435: LD_INT 50
96437: PUSH
96438: LD_INT 60
96440: PUSH
96441: LD_INT 70
96443: PUSH
96444: LD_INT 80
96446: PUSH
96447: LD_INT 90
96449: PUSH
96450: LD_INT 100
96452: PUSH
96453: LD_INT 110
96455: PUSH
96456: LD_INT 120
96458: PUSH
96459: LD_INT 130
96461: PUSH
96462: LD_INT 140
96464: PUSH
96465: LD_INT 150
96467: PUSH
96468: EMPTY
96469: LIST
96470: LIST
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: PUSH
96485: LD_INT 1
96487: PPUSH
96488: LD_INT 15
96490: PPUSH
96491: CALL_OW 12
96495: ARRAY
96496: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96497: LD_ADDR_VAR 0 4
96501: PUSH
96502: LD_INT 10
96504: PUSH
96505: LD_INT 20
96507: PUSH
96508: LD_INT 30
96510: PUSH
96511: LD_INT 40
96513: PUSH
96514: LD_INT 50
96516: PUSH
96517: LD_INT 60
96519: PUSH
96520: LD_INT 70
96522: PUSH
96523: LD_INT 80
96525: PUSH
96526: LD_INT 90
96528: PUSH
96529: LD_INT 100
96531: PUSH
96532: LD_INT 110
96534: PUSH
96535: LD_INT 120
96537: PUSH
96538: LD_INT 130
96540: PUSH
96541: LD_INT 140
96543: PUSH
96544: LD_INT 150
96546: PUSH
96547: EMPTY
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: PUSH
96564: LD_INT 1
96566: PPUSH
96567: LD_INT 15
96569: PPUSH
96570: CALL_OW 12
96574: ARRAY
96575: ST_TO_ADDR
// if ValidHex ( x , y ) then
96576: LD_VAR 0 3
96580: PPUSH
96581: LD_VAR 0 4
96585: PPUSH
96586: CALL_OW 488
96590: IFFALSE 96613
// begin result := [ x , y ] ;
96592: LD_ADDR_VAR 0 1
96596: PUSH
96597: LD_VAR 0 3
96601: PUSH
96602: LD_VAR 0 4
96606: PUSH
96607: EMPTY
96608: LIST
96609: LIST
96610: ST_TO_ADDR
// break ;
96611: GO 96615
// end ; end ;
96613: GO 96415
96615: POP
96616: POP
// if result then
96617: LD_VAR 0 1
96621: IFFALSE 96681
// begin ToLua ( playSibBomb() ) ;
96623: LD_STRING playSibBomb()
96625: PPUSH
96626: CALL_OW 559
// wait ( 0 0$14 ) ;
96630: LD_INT 490
96632: PPUSH
96633: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
96637: LD_VAR 0 1
96641: PUSH
96642: LD_INT 1
96644: ARRAY
96645: PPUSH
96646: LD_VAR 0 1
96650: PUSH
96651: LD_INT 2
96653: ARRAY
96654: PPUSH
96655: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
96659: LD_VAR 0 1
96663: PUSH
96664: LD_INT 1
96666: ARRAY
96667: PPUSH
96668: LD_VAR 0 1
96672: PUSH
96673: LD_INT 2
96675: ARRAY
96676: PPUSH
96677: CALL_OW 429
// end ; end ;
96681: LD_VAR 0 1
96685: RET
// every 0 0$1 trigger StreamModeActive and sReset do
96686: LD_EXP 137
96690: PUSH
96691: LD_EXP 159
96695: AND
96696: IFFALSE 96708
96698: GO 96700
96700: DISABLE
// YouLost (  ) ;
96701: LD_STRING 
96703: PPUSH
96704: CALL_OW 104
96708: END
// every 0 0$1 trigger StreamModeActive and sFog do
96709: LD_EXP 137
96713: PUSH
96714: LD_EXP 158
96718: AND
96719: IFFALSE 96733
96721: GO 96723
96723: DISABLE
// FogOff ( your_side ) ;
96724: LD_OWVAR 2
96728: PPUSH
96729: CALL_OW 344
96733: END
// every 0 0$1 trigger StreamModeActive and sSun do
96734: LD_EXP 137
96738: PUSH
96739: LD_EXP 160
96743: AND
96744: IFFALSE 96772
96746: GO 96748
96748: DISABLE
// begin solar_recharge_percent := 0 ;
96749: LD_ADDR_OWVAR 79
96753: PUSH
96754: LD_INT 0
96756: ST_TO_ADDR
// wait ( 5 5$00 ) ;
96757: LD_INT 10500
96759: PPUSH
96760: CALL_OW 67
// solar_recharge_percent := 100 ;
96764: LD_ADDR_OWVAR 79
96768: PUSH
96769: LD_INT 100
96771: ST_TO_ADDR
// end ;
96772: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
96773: LD_EXP 137
96777: PUSH
96778: LD_EXP 161
96782: AND
96783: IFFALSE 97022
96785: GO 96787
96787: DISABLE
96788: LD_INT 0
96790: PPUSH
96791: PPUSH
96792: PPUSH
// begin tmp := [ ] ;
96793: LD_ADDR_VAR 0 3
96797: PUSH
96798: EMPTY
96799: ST_TO_ADDR
// for i := 1 to 6 do
96800: LD_ADDR_VAR 0 1
96804: PUSH
96805: DOUBLE
96806: LD_INT 1
96808: DEC
96809: ST_TO_ADDR
96810: LD_INT 6
96812: PUSH
96813: FOR_TO
96814: IFFALSE 96919
// begin uc_nation := nation_nature ;
96816: LD_ADDR_OWVAR 21
96820: PUSH
96821: LD_INT 0
96823: ST_TO_ADDR
// uc_side := 0 ;
96824: LD_ADDR_OWVAR 20
96828: PUSH
96829: LD_INT 0
96831: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96832: LD_ADDR_OWVAR 29
96836: PUSH
96837: LD_INT 12
96839: PUSH
96840: LD_INT 12
96842: PUSH
96843: EMPTY
96844: LIST
96845: LIST
96846: ST_TO_ADDR
// hc_agressivity := 20 ;
96847: LD_ADDR_OWVAR 35
96851: PUSH
96852: LD_INT 20
96854: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
96855: LD_ADDR_OWVAR 28
96859: PUSH
96860: LD_INT 17
96862: ST_TO_ADDR
// hc_gallery :=  ;
96863: LD_ADDR_OWVAR 33
96867: PUSH
96868: LD_STRING 
96870: ST_TO_ADDR
// hc_name :=  ;
96871: LD_ADDR_OWVAR 26
96875: PUSH
96876: LD_STRING 
96878: ST_TO_ADDR
// un := CreateHuman ;
96879: LD_ADDR_VAR 0 2
96883: PUSH
96884: CALL_OW 44
96888: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
96889: LD_VAR 0 2
96893: PPUSH
96894: LD_INT 1
96896: PPUSH
96897: CALL_OW 51
// tmp := tmp ^ un ;
96901: LD_ADDR_VAR 0 3
96905: PUSH
96906: LD_VAR 0 3
96910: PUSH
96911: LD_VAR 0 2
96915: ADD
96916: ST_TO_ADDR
// end ;
96917: GO 96813
96919: POP
96920: POP
// repeat wait ( 0 0$1 ) ;
96921: LD_INT 35
96923: PPUSH
96924: CALL_OW 67
// for un in tmp do
96928: LD_ADDR_VAR 0 2
96932: PUSH
96933: LD_VAR 0 3
96937: PUSH
96938: FOR_IN
96939: IFFALSE 97013
// begin if IsDead ( un ) then
96941: LD_VAR 0 2
96945: PPUSH
96946: CALL_OW 301
96950: IFFALSE 96970
// begin tmp := tmp diff un ;
96952: LD_ADDR_VAR 0 3
96956: PUSH
96957: LD_VAR 0 3
96961: PUSH
96962: LD_VAR 0 2
96966: DIFF
96967: ST_TO_ADDR
// continue ;
96968: GO 96938
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
96970: LD_VAR 0 2
96974: PPUSH
96975: LD_INT 3
96977: PUSH
96978: LD_INT 22
96980: PUSH
96981: LD_INT 0
96983: PUSH
96984: EMPTY
96985: LIST
96986: LIST
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PPUSH
96992: CALL_OW 69
96996: PPUSH
96997: LD_VAR 0 2
97001: PPUSH
97002: CALL_OW 74
97006: PPUSH
97007: CALL_OW 115
// end ;
97011: GO 96938
97013: POP
97014: POP
// until not tmp ;
97015: LD_VAR 0 3
97019: NOT
97020: IFFALSE 96921
// end ;
97022: PPOPN 3
97024: END
// every 0 0$1 trigger StreamModeActive and sTroll do
97025: LD_EXP 137
97029: PUSH
97030: LD_EXP 162
97034: AND
97035: IFFALSE 97089
97037: GO 97039
97039: DISABLE
// begin ToLua ( displayTroll(); ) ;
97040: LD_STRING displayTroll();
97042: PPUSH
97043: CALL_OW 559
// wait ( 3 3$00 ) ;
97047: LD_INT 6300
97049: PPUSH
97050: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97054: LD_STRING hideTroll();
97056: PPUSH
97057: CALL_OW 559
// wait ( 1 1$00 ) ;
97061: LD_INT 2100
97063: PPUSH
97064: CALL_OW 67
// ToLua ( displayTroll(); ) ;
97068: LD_STRING displayTroll();
97070: PPUSH
97071: CALL_OW 559
// wait ( 1 1$00 ) ;
97075: LD_INT 2100
97077: PPUSH
97078: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97082: LD_STRING hideTroll();
97084: PPUSH
97085: CALL_OW 559
// end ;
97089: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
97090: LD_EXP 137
97094: PUSH
97095: LD_EXP 163
97099: AND
97100: IFFALSE 97163
97102: GO 97104
97104: DISABLE
97105: LD_INT 0
97107: PPUSH
// begin p := 0 ;
97108: LD_ADDR_VAR 0 1
97112: PUSH
97113: LD_INT 0
97115: ST_TO_ADDR
// repeat game_speed := 1 ;
97116: LD_ADDR_OWVAR 65
97120: PUSH
97121: LD_INT 1
97123: ST_TO_ADDR
// wait ( 0 0$1 ) ;
97124: LD_INT 35
97126: PPUSH
97127: CALL_OW 67
// p := p + 1 ;
97131: LD_ADDR_VAR 0 1
97135: PUSH
97136: LD_VAR 0 1
97140: PUSH
97141: LD_INT 1
97143: PLUS
97144: ST_TO_ADDR
// until p >= 60 ;
97145: LD_VAR 0 1
97149: PUSH
97150: LD_INT 60
97152: GREATEREQUAL
97153: IFFALSE 97116
// game_speed := 4 ;
97155: LD_ADDR_OWVAR 65
97159: PUSH
97160: LD_INT 4
97162: ST_TO_ADDR
// end ;
97163: PPOPN 1
97165: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
97166: LD_EXP 137
97170: PUSH
97171: LD_EXP 164
97175: AND
97176: IFFALSE 97322
97178: GO 97180
97180: DISABLE
97181: LD_INT 0
97183: PPUSH
97184: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97185: LD_ADDR_VAR 0 1
97189: PUSH
97190: LD_INT 22
97192: PUSH
97193: LD_OWVAR 2
97197: PUSH
97198: EMPTY
97199: LIST
97200: LIST
97201: PUSH
97202: LD_INT 2
97204: PUSH
97205: LD_INT 30
97207: PUSH
97208: LD_INT 0
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: PUSH
97215: LD_INT 30
97217: PUSH
97218: LD_INT 1
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: PUSH
97225: EMPTY
97226: LIST
97227: LIST
97228: LIST
97229: PUSH
97230: EMPTY
97231: LIST
97232: LIST
97233: PPUSH
97234: CALL_OW 69
97238: ST_TO_ADDR
// if not depot then
97239: LD_VAR 0 1
97243: NOT
97244: IFFALSE 97248
// exit ;
97246: GO 97322
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
97248: LD_ADDR_VAR 0 2
97252: PUSH
97253: LD_VAR 0 1
97257: PUSH
97258: LD_INT 1
97260: PPUSH
97261: LD_VAR 0 1
97265: PPUSH
97266: CALL_OW 12
97270: ARRAY
97271: PPUSH
97272: CALL_OW 274
97276: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
97277: LD_VAR 0 2
97281: PPUSH
97282: LD_INT 1
97284: PPUSH
97285: LD_INT 0
97287: PPUSH
97288: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
97292: LD_VAR 0 2
97296: PPUSH
97297: LD_INT 2
97299: PPUSH
97300: LD_INT 0
97302: PPUSH
97303: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
97307: LD_VAR 0 2
97311: PPUSH
97312: LD_INT 3
97314: PPUSH
97315: LD_INT 0
97317: PPUSH
97318: CALL_OW 277
// end ;
97322: PPOPN 2
97324: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
97325: LD_EXP 137
97329: PUSH
97330: LD_EXP 165
97334: AND
97335: IFFALSE 97432
97337: GO 97339
97339: DISABLE
97340: LD_INT 0
97342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97343: LD_ADDR_VAR 0 1
97347: PUSH
97348: LD_INT 22
97350: PUSH
97351: LD_OWVAR 2
97355: PUSH
97356: EMPTY
97357: LIST
97358: LIST
97359: PUSH
97360: LD_INT 21
97362: PUSH
97363: LD_INT 1
97365: PUSH
97366: EMPTY
97367: LIST
97368: LIST
97369: PUSH
97370: LD_INT 3
97372: PUSH
97373: LD_INT 23
97375: PUSH
97376: LD_INT 0
97378: PUSH
97379: EMPTY
97380: LIST
97381: LIST
97382: PUSH
97383: EMPTY
97384: LIST
97385: LIST
97386: PUSH
97387: EMPTY
97388: LIST
97389: LIST
97390: LIST
97391: PPUSH
97392: CALL_OW 69
97396: ST_TO_ADDR
// if not tmp then
97397: LD_VAR 0 1
97401: NOT
97402: IFFALSE 97406
// exit ;
97404: GO 97432
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
97406: LD_VAR 0 1
97410: PUSH
97411: LD_INT 1
97413: PPUSH
97414: LD_VAR 0 1
97418: PPUSH
97419: CALL_OW 12
97423: ARRAY
97424: PPUSH
97425: LD_INT 200
97427: PPUSH
97428: CALL_OW 234
// end ;
97432: PPOPN 1
97434: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
97435: LD_EXP 137
97439: PUSH
97440: LD_EXP 166
97444: AND
97445: IFFALSE 97524
97447: GO 97449
97449: DISABLE
97450: LD_INT 0
97452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
97453: LD_ADDR_VAR 0 1
97457: PUSH
97458: LD_INT 22
97460: PUSH
97461: LD_OWVAR 2
97465: PUSH
97466: EMPTY
97467: LIST
97468: LIST
97469: PUSH
97470: LD_INT 21
97472: PUSH
97473: LD_INT 2
97475: PUSH
97476: EMPTY
97477: LIST
97478: LIST
97479: PUSH
97480: EMPTY
97481: LIST
97482: LIST
97483: PPUSH
97484: CALL_OW 69
97488: ST_TO_ADDR
// if not tmp then
97489: LD_VAR 0 1
97493: NOT
97494: IFFALSE 97498
// exit ;
97496: GO 97524
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
97498: LD_VAR 0 1
97502: PUSH
97503: LD_INT 1
97505: PPUSH
97506: LD_VAR 0 1
97510: PPUSH
97511: CALL_OW 12
97515: ARRAY
97516: PPUSH
97517: LD_INT 60
97519: PPUSH
97520: CALL_OW 234
// end ;
97524: PPOPN 1
97526: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
97527: LD_EXP 137
97531: PUSH
97532: LD_EXP 167
97536: AND
97537: IFFALSE 97636
97539: GO 97541
97541: DISABLE
97542: LD_INT 0
97544: PPUSH
97545: PPUSH
// begin enable ;
97546: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
97547: LD_ADDR_VAR 0 1
97551: PUSH
97552: LD_INT 22
97554: PUSH
97555: LD_OWVAR 2
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: PUSH
97564: LD_INT 61
97566: PUSH
97567: EMPTY
97568: LIST
97569: PUSH
97570: LD_INT 33
97572: PUSH
97573: LD_INT 2
97575: PUSH
97576: EMPTY
97577: LIST
97578: LIST
97579: PUSH
97580: EMPTY
97581: LIST
97582: LIST
97583: LIST
97584: PPUSH
97585: CALL_OW 69
97589: ST_TO_ADDR
// if not tmp then
97590: LD_VAR 0 1
97594: NOT
97595: IFFALSE 97599
// exit ;
97597: GO 97636
// for i in tmp do
97599: LD_ADDR_VAR 0 2
97603: PUSH
97604: LD_VAR 0 1
97608: PUSH
97609: FOR_IN
97610: IFFALSE 97634
// if IsControledBy ( i ) then
97612: LD_VAR 0 2
97616: PPUSH
97617: CALL_OW 312
97621: IFFALSE 97632
// ComUnlink ( i ) ;
97623: LD_VAR 0 2
97627: PPUSH
97628: CALL_OW 136
97632: GO 97609
97634: POP
97635: POP
// end ;
97636: PPOPN 2
97638: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
97639: LD_EXP 137
97643: PUSH
97644: LD_EXP 168
97648: AND
97649: IFFALSE 97789
97651: GO 97653
97653: DISABLE
97654: LD_INT 0
97656: PPUSH
97657: PPUSH
// begin ToLua ( displayPowell(); ) ;
97658: LD_STRING displayPowell();
97660: PPUSH
97661: CALL_OW 559
// uc_side := 0 ;
97665: LD_ADDR_OWVAR 20
97669: PUSH
97670: LD_INT 0
97672: ST_TO_ADDR
// uc_nation := 2 ;
97673: LD_ADDR_OWVAR 21
97677: PUSH
97678: LD_INT 2
97680: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
97681: LD_ADDR_OWVAR 37
97685: PUSH
97686: LD_INT 14
97688: ST_TO_ADDR
// vc_engine := engine_siberite ;
97689: LD_ADDR_OWVAR 39
97693: PUSH
97694: LD_INT 3
97696: ST_TO_ADDR
// vc_control := control_apeman ;
97697: LD_ADDR_OWVAR 38
97701: PUSH
97702: LD_INT 5
97704: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
97705: LD_ADDR_OWVAR 40
97709: PUSH
97710: LD_INT 29
97712: ST_TO_ADDR
// un := CreateVehicle ;
97713: LD_ADDR_VAR 0 2
97717: PUSH
97718: CALL_OW 45
97722: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97723: LD_VAR 0 2
97727: PPUSH
97728: LD_INT 1
97730: PPUSH
97731: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97735: LD_INT 35
97737: PPUSH
97738: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97742: LD_VAR 0 2
97746: PPUSH
97747: LD_INT 22
97749: PUSH
97750: LD_OWVAR 2
97754: PUSH
97755: EMPTY
97756: LIST
97757: LIST
97758: PPUSH
97759: CALL_OW 69
97763: PPUSH
97764: LD_VAR 0 2
97768: PPUSH
97769: CALL_OW 74
97773: PPUSH
97774: CALL_OW 115
// until IsDead ( un ) ;
97778: LD_VAR 0 2
97782: PPUSH
97783: CALL_OW 301
97787: IFFALSE 97735
// end ;
97789: PPOPN 2
97791: END
// every 0 0$1 trigger StreamModeActive and sStu do
97792: LD_EXP 137
97796: PUSH
97797: LD_EXP 176
97801: AND
97802: IFFALSE 97818
97804: GO 97806
97806: DISABLE
// begin ToLua ( displayStucuk(); ) ;
97807: LD_STRING displayStucuk();
97809: PPUSH
97810: CALL_OW 559
// ResetFog ;
97814: CALL_OW 335
// end ;
97818: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
97819: LD_EXP 137
97823: PUSH
97824: LD_EXP 169
97828: AND
97829: IFFALSE 97970
97831: GO 97833
97833: DISABLE
97834: LD_INT 0
97836: PPUSH
97837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97838: LD_ADDR_VAR 0 2
97842: PUSH
97843: LD_INT 22
97845: PUSH
97846: LD_OWVAR 2
97850: PUSH
97851: EMPTY
97852: LIST
97853: LIST
97854: PUSH
97855: LD_INT 21
97857: PUSH
97858: LD_INT 1
97860: PUSH
97861: EMPTY
97862: LIST
97863: LIST
97864: PUSH
97865: EMPTY
97866: LIST
97867: LIST
97868: PPUSH
97869: CALL_OW 69
97873: ST_TO_ADDR
// if not tmp then
97874: LD_VAR 0 2
97878: NOT
97879: IFFALSE 97883
// exit ;
97881: GO 97970
// un := tmp [ rand ( 1 , tmp ) ] ;
97883: LD_ADDR_VAR 0 1
97887: PUSH
97888: LD_VAR 0 2
97892: PUSH
97893: LD_INT 1
97895: PPUSH
97896: LD_VAR 0 2
97900: PPUSH
97901: CALL_OW 12
97905: ARRAY
97906: ST_TO_ADDR
// SetSide ( un , 0 ) ;
97907: LD_VAR 0 1
97911: PPUSH
97912: LD_INT 0
97914: PPUSH
97915: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
97919: LD_VAR 0 1
97923: PPUSH
97924: LD_OWVAR 3
97928: PUSH
97929: LD_VAR 0 1
97933: DIFF
97934: PPUSH
97935: LD_VAR 0 1
97939: PPUSH
97940: CALL_OW 74
97944: PPUSH
97945: CALL_OW 115
// wait ( 0 0$20 ) ;
97949: LD_INT 700
97951: PPUSH
97952: CALL_OW 67
// SetSide ( un , your_side ) ;
97956: LD_VAR 0 1
97960: PPUSH
97961: LD_OWVAR 2
97965: PPUSH
97966: CALL_OW 235
// end ;
97970: PPOPN 2
97972: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
97973: LD_EXP 137
97977: PUSH
97978: LD_EXP 170
97982: AND
97983: IFFALSE 98089
97985: GO 97987
97987: DISABLE
97988: LD_INT 0
97990: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97991: LD_ADDR_VAR 0 1
97995: PUSH
97996: LD_INT 22
97998: PUSH
97999: LD_OWVAR 2
98003: PUSH
98004: EMPTY
98005: LIST
98006: LIST
98007: PUSH
98008: LD_INT 2
98010: PUSH
98011: LD_INT 30
98013: PUSH
98014: LD_INT 0
98016: PUSH
98017: EMPTY
98018: LIST
98019: LIST
98020: PUSH
98021: LD_INT 30
98023: PUSH
98024: LD_INT 1
98026: PUSH
98027: EMPTY
98028: LIST
98029: LIST
98030: PUSH
98031: EMPTY
98032: LIST
98033: LIST
98034: LIST
98035: PUSH
98036: EMPTY
98037: LIST
98038: LIST
98039: PPUSH
98040: CALL_OW 69
98044: ST_TO_ADDR
// if not depot then
98045: LD_VAR 0 1
98049: NOT
98050: IFFALSE 98054
// exit ;
98052: GO 98089
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
98054: LD_VAR 0 1
98058: PUSH
98059: LD_INT 1
98061: ARRAY
98062: PPUSH
98063: CALL_OW 250
98067: PPUSH
98068: LD_VAR 0 1
98072: PUSH
98073: LD_INT 1
98075: ARRAY
98076: PPUSH
98077: CALL_OW 251
98081: PPUSH
98082: LD_INT 70
98084: PPUSH
98085: CALL_OW 495
// end ;
98089: PPOPN 1
98091: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
98092: LD_EXP 137
98096: PUSH
98097: LD_EXP 171
98101: AND
98102: IFFALSE 98313
98104: GO 98106
98106: DISABLE
98107: LD_INT 0
98109: PPUSH
98110: PPUSH
98111: PPUSH
98112: PPUSH
98113: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98114: LD_ADDR_VAR 0 5
98118: PUSH
98119: LD_INT 22
98121: PUSH
98122: LD_OWVAR 2
98126: PUSH
98127: EMPTY
98128: LIST
98129: LIST
98130: PUSH
98131: LD_INT 21
98133: PUSH
98134: LD_INT 1
98136: PUSH
98137: EMPTY
98138: LIST
98139: LIST
98140: PUSH
98141: EMPTY
98142: LIST
98143: LIST
98144: PPUSH
98145: CALL_OW 69
98149: ST_TO_ADDR
// if not tmp then
98150: LD_VAR 0 5
98154: NOT
98155: IFFALSE 98159
// exit ;
98157: GO 98313
// for i in tmp do
98159: LD_ADDR_VAR 0 1
98163: PUSH
98164: LD_VAR 0 5
98168: PUSH
98169: FOR_IN
98170: IFFALSE 98311
// begin d := rand ( 0 , 5 ) ;
98172: LD_ADDR_VAR 0 4
98176: PUSH
98177: LD_INT 0
98179: PPUSH
98180: LD_INT 5
98182: PPUSH
98183: CALL_OW 12
98187: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
98188: LD_ADDR_VAR 0 2
98192: PUSH
98193: LD_VAR 0 1
98197: PPUSH
98198: CALL_OW 250
98202: PPUSH
98203: LD_VAR 0 4
98207: PPUSH
98208: LD_INT 3
98210: PPUSH
98211: LD_INT 12
98213: PPUSH
98214: CALL_OW 12
98218: PPUSH
98219: CALL_OW 272
98223: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
98224: LD_ADDR_VAR 0 3
98228: PUSH
98229: LD_VAR 0 1
98233: PPUSH
98234: CALL_OW 251
98238: PPUSH
98239: LD_VAR 0 4
98243: PPUSH
98244: LD_INT 3
98246: PPUSH
98247: LD_INT 12
98249: PPUSH
98250: CALL_OW 12
98254: PPUSH
98255: CALL_OW 273
98259: ST_TO_ADDR
// if ValidHex ( x , y ) then
98260: LD_VAR 0 2
98264: PPUSH
98265: LD_VAR 0 3
98269: PPUSH
98270: CALL_OW 488
98274: IFFALSE 98309
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
98276: LD_VAR 0 1
98280: PPUSH
98281: LD_VAR 0 2
98285: PPUSH
98286: LD_VAR 0 3
98290: PPUSH
98291: LD_INT 3
98293: PPUSH
98294: LD_INT 6
98296: PPUSH
98297: CALL_OW 12
98301: PPUSH
98302: LD_INT 1
98304: PPUSH
98305: CALL_OW 483
// end ;
98309: GO 98169
98311: POP
98312: POP
// end ;
98313: PPOPN 5
98315: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
98316: LD_EXP 137
98320: PUSH
98321: LD_EXP 172
98325: AND
98326: IFFALSE 98420
98328: GO 98330
98330: DISABLE
98331: LD_INT 0
98333: PPUSH
98334: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
98335: LD_ADDR_VAR 0 2
98339: PUSH
98340: LD_INT 22
98342: PUSH
98343: LD_OWVAR 2
98347: PUSH
98348: EMPTY
98349: LIST
98350: LIST
98351: PUSH
98352: LD_INT 32
98354: PUSH
98355: LD_INT 1
98357: PUSH
98358: EMPTY
98359: LIST
98360: LIST
98361: PUSH
98362: LD_INT 21
98364: PUSH
98365: LD_INT 2
98367: PUSH
98368: EMPTY
98369: LIST
98370: LIST
98371: PUSH
98372: EMPTY
98373: LIST
98374: LIST
98375: LIST
98376: PPUSH
98377: CALL_OW 69
98381: ST_TO_ADDR
// if not tmp then
98382: LD_VAR 0 2
98386: NOT
98387: IFFALSE 98391
// exit ;
98389: GO 98420
// for i in tmp do
98391: LD_ADDR_VAR 0 1
98395: PUSH
98396: LD_VAR 0 2
98400: PUSH
98401: FOR_IN
98402: IFFALSE 98418
// SetFuel ( i , 0 ) ;
98404: LD_VAR 0 1
98408: PPUSH
98409: LD_INT 0
98411: PPUSH
98412: CALL_OW 240
98416: GO 98401
98418: POP
98419: POP
// end ;
98420: PPOPN 2
98422: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
98423: LD_EXP 137
98427: PUSH
98428: LD_EXP 173
98432: AND
98433: IFFALSE 98499
98435: GO 98437
98437: DISABLE
98438: LD_INT 0
98440: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98441: LD_ADDR_VAR 0 1
98445: PUSH
98446: LD_INT 22
98448: PUSH
98449: LD_OWVAR 2
98453: PUSH
98454: EMPTY
98455: LIST
98456: LIST
98457: PUSH
98458: LD_INT 30
98460: PUSH
98461: LD_INT 29
98463: PUSH
98464: EMPTY
98465: LIST
98466: LIST
98467: PUSH
98468: EMPTY
98469: LIST
98470: LIST
98471: PPUSH
98472: CALL_OW 69
98476: ST_TO_ADDR
// if not tmp then
98477: LD_VAR 0 1
98481: NOT
98482: IFFALSE 98486
// exit ;
98484: GO 98499
// DestroyUnit ( tmp [ 1 ] ) ;
98486: LD_VAR 0 1
98490: PUSH
98491: LD_INT 1
98493: ARRAY
98494: PPUSH
98495: CALL_OW 65
// end ;
98499: PPOPN 1
98501: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
98502: LD_EXP 137
98506: PUSH
98507: LD_EXP 175
98511: AND
98512: IFFALSE 98641
98514: GO 98516
98516: DISABLE
98517: LD_INT 0
98519: PPUSH
// begin uc_side := 0 ;
98520: LD_ADDR_OWVAR 20
98524: PUSH
98525: LD_INT 0
98527: ST_TO_ADDR
// uc_nation := nation_arabian ;
98528: LD_ADDR_OWVAR 21
98532: PUSH
98533: LD_INT 2
98535: ST_TO_ADDR
// hc_gallery :=  ;
98536: LD_ADDR_OWVAR 33
98540: PUSH
98541: LD_STRING 
98543: ST_TO_ADDR
// hc_name :=  ;
98544: LD_ADDR_OWVAR 26
98548: PUSH
98549: LD_STRING 
98551: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
98552: LD_INT 1
98554: PPUSH
98555: LD_INT 11
98557: PPUSH
98558: LD_INT 10
98560: PPUSH
98561: CALL_OW 380
// un := CreateHuman ;
98565: LD_ADDR_VAR 0 1
98569: PUSH
98570: CALL_OW 44
98574: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98575: LD_VAR 0 1
98579: PPUSH
98580: LD_INT 1
98582: PPUSH
98583: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98587: LD_INT 35
98589: PPUSH
98590: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98594: LD_VAR 0 1
98598: PPUSH
98599: LD_INT 22
98601: PUSH
98602: LD_OWVAR 2
98606: PUSH
98607: EMPTY
98608: LIST
98609: LIST
98610: PPUSH
98611: CALL_OW 69
98615: PPUSH
98616: LD_VAR 0 1
98620: PPUSH
98621: CALL_OW 74
98625: PPUSH
98626: CALL_OW 115
// until IsDead ( un ) ;
98630: LD_VAR 0 1
98634: PPUSH
98635: CALL_OW 301
98639: IFFALSE 98587
// end ;
98641: PPOPN 1
98643: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
98644: LD_EXP 137
98648: PUSH
98649: LD_EXP 177
98653: AND
98654: IFFALSE 98666
98656: GO 98658
98658: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
98659: LD_STRING earthquake(getX(game), 0, 32)
98661: PPUSH
98662: CALL_OW 559
98666: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
98667: LD_EXP 137
98671: PUSH
98672: LD_EXP 178
98676: AND
98677: IFFALSE 98768
98679: GO 98681
98681: DISABLE
98682: LD_INT 0
98684: PPUSH
// begin enable ;
98685: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
98686: LD_ADDR_VAR 0 1
98690: PUSH
98691: LD_INT 22
98693: PUSH
98694: LD_OWVAR 2
98698: PUSH
98699: EMPTY
98700: LIST
98701: LIST
98702: PUSH
98703: LD_INT 21
98705: PUSH
98706: LD_INT 2
98708: PUSH
98709: EMPTY
98710: LIST
98711: LIST
98712: PUSH
98713: LD_INT 33
98715: PUSH
98716: LD_INT 3
98718: PUSH
98719: EMPTY
98720: LIST
98721: LIST
98722: PUSH
98723: EMPTY
98724: LIST
98725: LIST
98726: LIST
98727: PPUSH
98728: CALL_OW 69
98732: ST_TO_ADDR
// if not tmp then
98733: LD_VAR 0 1
98737: NOT
98738: IFFALSE 98742
// exit ;
98740: GO 98768
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98742: LD_VAR 0 1
98746: PUSH
98747: LD_INT 1
98749: PPUSH
98750: LD_VAR 0 1
98754: PPUSH
98755: CALL_OW 12
98759: ARRAY
98760: PPUSH
98761: LD_INT 1
98763: PPUSH
98764: CALL_OW 234
// end ;
98768: PPOPN 1
98770: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
98771: LD_EXP 137
98775: PUSH
98776: LD_EXP 179
98780: AND
98781: IFFALSE 98922
98783: GO 98785
98785: DISABLE
98786: LD_INT 0
98788: PPUSH
98789: PPUSH
98790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98791: LD_ADDR_VAR 0 3
98795: PUSH
98796: LD_INT 22
98798: PUSH
98799: LD_OWVAR 2
98803: PUSH
98804: EMPTY
98805: LIST
98806: LIST
98807: PUSH
98808: LD_INT 25
98810: PUSH
98811: LD_INT 1
98813: PUSH
98814: EMPTY
98815: LIST
98816: LIST
98817: PUSH
98818: EMPTY
98819: LIST
98820: LIST
98821: PPUSH
98822: CALL_OW 69
98826: ST_TO_ADDR
// if not tmp then
98827: LD_VAR 0 3
98831: NOT
98832: IFFALSE 98836
// exit ;
98834: GO 98922
// un := tmp [ rand ( 1 , tmp ) ] ;
98836: LD_ADDR_VAR 0 2
98840: PUSH
98841: LD_VAR 0 3
98845: PUSH
98846: LD_INT 1
98848: PPUSH
98849: LD_VAR 0 3
98853: PPUSH
98854: CALL_OW 12
98858: ARRAY
98859: ST_TO_ADDR
// if Crawls ( un ) then
98860: LD_VAR 0 2
98864: PPUSH
98865: CALL_OW 318
98869: IFFALSE 98880
// ComWalk ( un ) ;
98871: LD_VAR 0 2
98875: PPUSH
98876: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
98880: LD_VAR 0 2
98884: PPUSH
98885: LD_INT 9
98887: PPUSH
98888: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
98892: LD_INT 28
98894: PPUSH
98895: LD_OWVAR 2
98899: PPUSH
98900: LD_INT 2
98902: PPUSH
98903: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
98907: LD_INT 29
98909: PPUSH
98910: LD_OWVAR 2
98914: PPUSH
98915: LD_INT 2
98917: PPUSH
98918: CALL_OW 322
// end ;
98922: PPOPN 3
98924: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
98925: LD_EXP 137
98929: PUSH
98930: LD_EXP 180
98934: AND
98935: IFFALSE 99046
98937: GO 98939
98939: DISABLE
98940: LD_INT 0
98942: PPUSH
98943: PPUSH
98944: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98945: LD_ADDR_VAR 0 3
98949: PUSH
98950: LD_INT 22
98952: PUSH
98953: LD_OWVAR 2
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: PUSH
98962: LD_INT 25
98964: PUSH
98965: LD_INT 1
98967: PUSH
98968: EMPTY
98969: LIST
98970: LIST
98971: PUSH
98972: EMPTY
98973: LIST
98974: LIST
98975: PPUSH
98976: CALL_OW 69
98980: ST_TO_ADDR
// if not tmp then
98981: LD_VAR 0 3
98985: NOT
98986: IFFALSE 98990
// exit ;
98988: GO 99046
// un := tmp [ rand ( 1 , tmp ) ] ;
98990: LD_ADDR_VAR 0 2
98994: PUSH
98995: LD_VAR 0 3
98999: PUSH
99000: LD_INT 1
99002: PPUSH
99003: LD_VAR 0 3
99007: PPUSH
99008: CALL_OW 12
99012: ARRAY
99013: ST_TO_ADDR
// if Crawls ( un ) then
99014: LD_VAR 0 2
99018: PPUSH
99019: CALL_OW 318
99023: IFFALSE 99034
// ComWalk ( un ) ;
99025: LD_VAR 0 2
99029: PPUSH
99030: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99034: LD_VAR 0 2
99038: PPUSH
99039: LD_INT 8
99041: PPUSH
99042: CALL_OW 336
// end ;
99046: PPOPN 3
99048: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
99049: LD_EXP 137
99053: PUSH
99054: LD_EXP 181
99058: AND
99059: IFFALSE 99203
99061: GO 99063
99063: DISABLE
99064: LD_INT 0
99066: PPUSH
99067: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
99068: LD_ADDR_VAR 0 2
99072: PUSH
99073: LD_INT 22
99075: PUSH
99076: LD_OWVAR 2
99080: PUSH
99081: EMPTY
99082: LIST
99083: LIST
99084: PUSH
99085: LD_INT 21
99087: PUSH
99088: LD_INT 2
99090: PUSH
99091: EMPTY
99092: LIST
99093: LIST
99094: PUSH
99095: LD_INT 2
99097: PUSH
99098: LD_INT 34
99100: PUSH
99101: LD_INT 12
99103: PUSH
99104: EMPTY
99105: LIST
99106: LIST
99107: PUSH
99108: LD_INT 34
99110: PUSH
99111: LD_INT 51
99113: PUSH
99114: EMPTY
99115: LIST
99116: LIST
99117: PUSH
99118: LD_INT 34
99120: PUSH
99121: LD_INT 32
99123: PUSH
99124: EMPTY
99125: LIST
99126: LIST
99127: PUSH
99128: EMPTY
99129: LIST
99130: LIST
99131: LIST
99132: LIST
99133: PUSH
99134: EMPTY
99135: LIST
99136: LIST
99137: LIST
99138: PPUSH
99139: CALL_OW 69
99143: ST_TO_ADDR
// if not tmp then
99144: LD_VAR 0 2
99148: NOT
99149: IFFALSE 99153
// exit ;
99151: GO 99203
// for i in tmp do
99153: LD_ADDR_VAR 0 1
99157: PUSH
99158: LD_VAR 0 2
99162: PUSH
99163: FOR_IN
99164: IFFALSE 99201
// if GetCargo ( i , mat_artifact ) = 0 then
99166: LD_VAR 0 1
99170: PPUSH
99171: LD_INT 4
99173: PPUSH
99174: CALL_OW 289
99178: PUSH
99179: LD_INT 0
99181: EQUAL
99182: IFFALSE 99199
// SetCargo ( i , mat_siberit , 100 ) ;
99184: LD_VAR 0 1
99188: PPUSH
99189: LD_INT 3
99191: PPUSH
99192: LD_INT 100
99194: PPUSH
99195: CALL_OW 290
99199: GO 99163
99201: POP
99202: POP
// end ;
99203: PPOPN 2
99205: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
99206: LD_EXP 137
99210: PUSH
99211: LD_EXP 182
99215: AND
99216: IFFALSE 99399
99218: GO 99220
99220: DISABLE
99221: LD_INT 0
99223: PPUSH
99224: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99225: LD_ADDR_VAR 0 2
99229: PUSH
99230: LD_INT 22
99232: PUSH
99233: LD_OWVAR 2
99237: PUSH
99238: EMPTY
99239: LIST
99240: LIST
99241: PPUSH
99242: CALL_OW 69
99246: ST_TO_ADDR
// if not tmp then
99247: LD_VAR 0 2
99251: NOT
99252: IFFALSE 99256
// exit ;
99254: GO 99399
// for i := 1 to 2 do
99256: LD_ADDR_VAR 0 1
99260: PUSH
99261: DOUBLE
99262: LD_INT 1
99264: DEC
99265: ST_TO_ADDR
99266: LD_INT 2
99268: PUSH
99269: FOR_TO
99270: IFFALSE 99397
// begin uc_side := your_side ;
99272: LD_ADDR_OWVAR 20
99276: PUSH
99277: LD_OWVAR 2
99281: ST_TO_ADDR
// uc_nation := nation_american ;
99282: LD_ADDR_OWVAR 21
99286: PUSH
99287: LD_INT 1
99289: ST_TO_ADDR
// vc_chassis := us_morphling ;
99290: LD_ADDR_OWVAR 37
99294: PUSH
99295: LD_INT 5
99297: ST_TO_ADDR
// vc_engine := engine_siberite ;
99298: LD_ADDR_OWVAR 39
99302: PUSH
99303: LD_INT 3
99305: ST_TO_ADDR
// vc_control := control_computer ;
99306: LD_ADDR_OWVAR 38
99310: PUSH
99311: LD_INT 3
99313: ST_TO_ADDR
// vc_weapon := us_double_laser ;
99314: LD_ADDR_OWVAR 40
99318: PUSH
99319: LD_INT 10
99321: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
99322: LD_VAR 0 2
99326: PUSH
99327: LD_INT 1
99329: ARRAY
99330: PPUSH
99331: CALL_OW 310
99335: NOT
99336: IFFALSE 99383
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
99338: CALL_OW 45
99342: PPUSH
99343: LD_VAR 0 2
99347: PUSH
99348: LD_INT 1
99350: ARRAY
99351: PPUSH
99352: CALL_OW 250
99356: PPUSH
99357: LD_VAR 0 2
99361: PUSH
99362: LD_INT 1
99364: ARRAY
99365: PPUSH
99366: CALL_OW 251
99370: PPUSH
99371: LD_INT 12
99373: PPUSH
99374: LD_INT 1
99376: PPUSH
99377: CALL_OW 50
99381: GO 99395
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99383: CALL_OW 45
99387: PPUSH
99388: LD_INT 1
99390: PPUSH
99391: CALL_OW 51
// end ;
99395: GO 99269
99397: POP
99398: POP
// end ;
99399: PPOPN 2
99401: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
99402: LD_EXP 137
99406: PUSH
99407: LD_EXP 183
99411: AND
99412: IFFALSE 99634
99414: GO 99416
99416: DISABLE
99417: LD_INT 0
99419: PPUSH
99420: PPUSH
99421: PPUSH
99422: PPUSH
99423: PPUSH
99424: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99425: LD_ADDR_VAR 0 6
99429: PUSH
99430: LD_INT 22
99432: PUSH
99433: LD_OWVAR 2
99437: PUSH
99438: EMPTY
99439: LIST
99440: LIST
99441: PUSH
99442: LD_INT 21
99444: PUSH
99445: LD_INT 1
99447: PUSH
99448: EMPTY
99449: LIST
99450: LIST
99451: PUSH
99452: LD_INT 3
99454: PUSH
99455: LD_INT 23
99457: PUSH
99458: LD_INT 0
99460: PUSH
99461: EMPTY
99462: LIST
99463: LIST
99464: PUSH
99465: EMPTY
99466: LIST
99467: LIST
99468: PUSH
99469: EMPTY
99470: LIST
99471: LIST
99472: LIST
99473: PPUSH
99474: CALL_OW 69
99478: ST_TO_ADDR
// if not tmp then
99479: LD_VAR 0 6
99483: NOT
99484: IFFALSE 99488
// exit ;
99486: GO 99634
// s1 := rand ( 1 , 4 ) ;
99488: LD_ADDR_VAR 0 2
99492: PUSH
99493: LD_INT 1
99495: PPUSH
99496: LD_INT 4
99498: PPUSH
99499: CALL_OW 12
99503: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
99504: LD_ADDR_VAR 0 4
99508: PUSH
99509: LD_VAR 0 6
99513: PUSH
99514: LD_INT 1
99516: ARRAY
99517: PPUSH
99518: LD_VAR 0 2
99522: PPUSH
99523: CALL_OW 259
99527: ST_TO_ADDR
// if s1 = 1 then
99528: LD_VAR 0 2
99532: PUSH
99533: LD_INT 1
99535: EQUAL
99536: IFFALSE 99556
// s2 := rand ( 2 , 4 ) else
99538: LD_ADDR_VAR 0 3
99542: PUSH
99543: LD_INT 2
99545: PPUSH
99546: LD_INT 4
99548: PPUSH
99549: CALL_OW 12
99553: ST_TO_ADDR
99554: GO 99564
// s2 := 1 ;
99556: LD_ADDR_VAR 0 3
99560: PUSH
99561: LD_INT 1
99563: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
99564: LD_ADDR_VAR 0 5
99568: PUSH
99569: LD_VAR 0 6
99573: PUSH
99574: LD_INT 1
99576: ARRAY
99577: PPUSH
99578: LD_VAR 0 3
99582: PPUSH
99583: CALL_OW 259
99587: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
99588: LD_VAR 0 6
99592: PUSH
99593: LD_INT 1
99595: ARRAY
99596: PPUSH
99597: LD_VAR 0 2
99601: PPUSH
99602: LD_VAR 0 5
99606: PPUSH
99607: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
99611: LD_VAR 0 6
99615: PUSH
99616: LD_INT 1
99618: ARRAY
99619: PPUSH
99620: LD_VAR 0 3
99624: PPUSH
99625: LD_VAR 0 4
99629: PPUSH
99630: CALL_OW 237
// end ;
99634: PPOPN 6
99636: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
99637: LD_EXP 137
99641: PUSH
99642: LD_EXP 184
99646: AND
99647: IFFALSE 99726
99649: GO 99651
99651: DISABLE
99652: LD_INT 0
99654: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
99655: LD_ADDR_VAR 0 1
99659: PUSH
99660: LD_INT 22
99662: PUSH
99663: LD_OWVAR 2
99667: PUSH
99668: EMPTY
99669: LIST
99670: LIST
99671: PUSH
99672: LD_INT 30
99674: PUSH
99675: LD_INT 3
99677: PUSH
99678: EMPTY
99679: LIST
99680: LIST
99681: PUSH
99682: EMPTY
99683: LIST
99684: LIST
99685: PPUSH
99686: CALL_OW 69
99690: ST_TO_ADDR
// if not tmp then
99691: LD_VAR 0 1
99695: NOT
99696: IFFALSE 99700
// exit ;
99698: GO 99726
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99700: LD_VAR 0 1
99704: PUSH
99705: LD_INT 1
99707: PPUSH
99708: LD_VAR 0 1
99712: PPUSH
99713: CALL_OW 12
99717: ARRAY
99718: PPUSH
99719: LD_INT 1
99721: PPUSH
99722: CALL_OW 234
// end ;
99726: PPOPN 1
99728: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
99729: LD_EXP 137
99733: PUSH
99734: LD_EXP 185
99738: AND
99739: IFFALSE 99851
99741: GO 99743
99743: DISABLE
99744: LD_INT 0
99746: PPUSH
99747: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
99748: LD_ADDR_VAR 0 2
99752: PUSH
99753: LD_INT 22
99755: PUSH
99756: LD_OWVAR 2
99760: PUSH
99761: EMPTY
99762: LIST
99763: LIST
99764: PUSH
99765: LD_INT 2
99767: PUSH
99768: LD_INT 30
99770: PUSH
99771: LD_INT 27
99773: PUSH
99774: EMPTY
99775: LIST
99776: LIST
99777: PUSH
99778: LD_INT 30
99780: PUSH
99781: LD_INT 26
99783: PUSH
99784: EMPTY
99785: LIST
99786: LIST
99787: PUSH
99788: LD_INT 30
99790: PUSH
99791: LD_INT 28
99793: PUSH
99794: EMPTY
99795: LIST
99796: LIST
99797: PUSH
99798: EMPTY
99799: LIST
99800: LIST
99801: LIST
99802: LIST
99803: PUSH
99804: EMPTY
99805: LIST
99806: LIST
99807: PPUSH
99808: CALL_OW 69
99812: ST_TO_ADDR
// if not tmp then
99813: LD_VAR 0 2
99817: NOT
99818: IFFALSE 99822
// exit ;
99820: GO 99851
// for i in tmp do
99822: LD_ADDR_VAR 0 1
99826: PUSH
99827: LD_VAR 0 2
99831: PUSH
99832: FOR_IN
99833: IFFALSE 99849
// SetLives ( i , 1 ) ;
99835: LD_VAR 0 1
99839: PPUSH
99840: LD_INT 1
99842: PPUSH
99843: CALL_OW 234
99847: GO 99832
99849: POP
99850: POP
// end ;
99851: PPOPN 2
99853: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
99854: LD_EXP 137
99858: PUSH
99859: LD_EXP 186
99863: AND
99864: IFFALSE 100138
99866: GO 99868
99868: DISABLE
99869: LD_INT 0
99871: PPUSH
99872: PPUSH
99873: PPUSH
// begin i := rand ( 1 , 7 ) ;
99874: LD_ADDR_VAR 0 1
99878: PUSH
99879: LD_INT 1
99881: PPUSH
99882: LD_INT 7
99884: PPUSH
99885: CALL_OW 12
99889: ST_TO_ADDR
// case i of 1 :
99890: LD_VAR 0 1
99894: PUSH
99895: LD_INT 1
99897: DOUBLE
99898: EQUAL
99899: IFTRUE 99903
99901: GO 99913
99903: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
99904: LD_STRING earthquake(getX(game), 0, 32)
99906: PPUSH
99907: CALL_OW 559
99911: GO 100138
99913: LD_INT 2
99915: DOUBLE
99916: EQUAL
99917: IFTRUE 99921
99919: GO 99935
99921: POP
// begin ToLua ( displayStucuk(); ) ;
99922: LD_STRING displayStucuk();
99924: PPUSH
99925: CALL_OW 559
// ResetFog ;
99929: CALL_OW 335
// end ; 3 :
99933: GO 100138
99935: LD_INT 3
99937: DOUBLE
99938: EQUAL
99939: IFTRUE 99943
99941: GO 100047
99943: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99944: LD_ADDR_VAR 0 2
99948: PUSH
99949: LD_INT 22
99951: PUSH
99952: LD_OWVAR 2
99956: PUSH
99957: EMPTY
99958: LIST
99959: LIST
99960: PUSH
99961: LD_INT 25
99963: PUSH
99964: LD_INT 1
99966: PUSH
99967: EMPTY
99968: LIST
99969: LIST
99970: PUSH
99971: EMPTY
99972: LIST
99973: LIST
99974: PPUSH
99975: CALL_OW 69
99979: ST_TO_ADDR
// if not tmp then
99980: LD_VAR 0 2
99984: NOT
99985: IFFALSE 99989
// exit ;
99987: GO 100138
// un := tmp [ rand ( 1 , tmp ) ] ;
99989: LD_ADDR_VAR 0 3
99993: PUSH
99994: LD_VAR 0 2
99998: PUSH
99999: LD_INT 1
100001: PPUSH
100002: LD_VAR 0 2
100006: PPUSH
100007: CALL_OW 12
100011: ARRAY
100012: ST_TO_ADDR
// if Crawls ( un ) then
100013: LD_VAR 0 3
100017: PPUSH
100018: CALL_OW 318
100022: IFFALSE 100033
// ComWalk ( un ) ;
100024: LD_VAR 0 3
100028: PPUSH
100029: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100033: LD_VAR 0 3
100037: PPUSH
100038: LD_INT 8
100040: PPUSH
100041: CALL_OW 336
// end ; 4 :
100045: GO 100138
100047: LD_INT 4
100049: DOUBLE
100050: EQUAL
100051: IFTRUE 100055
100053: GO 100116
100055: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100056: LD_ADDR_VAR 0 2
100060: PUSH
100061: LD_INT 22
100063: PUSH
100064: LD_OWVAR 2
100068: PUSH
100069: EMPTY
100070: LIST
100071: LIST
100072: PUSH
100073: LD_INT 30
100075: PUSH
100076: LD_INT 29
100078: PUSH
100079: EMPTY
100080: LIST
100081: LIST
100082: PUSH
100083: EMPTY
100084: LIST
100085: LIST
100086: PPUSH
100087: CALL_OW 69
100091: ST_TO_ADDR
// if not tmp then
100092: LD_VAR 0 2
100096: NOT
100097: IFFALSE 100101
// exit ;
100099: GO 100138
// DestroyUnit ( tmp [ 1 ] ) ;
100101: LD_VAR 0 2
100105: PUSH
100106: LD_INT 1
100108: ARRAY
100109: PPUSH
100110: CALL_OW 65
// end ; 5 .. 7 :
100114: GO 100138
100116: LD_INT 5
100118: DOUBLE
100119: GREATEREQUAL
100120: IFFALSE 100128
100122: LD_INT 7
100124: DOUBLE
100125: LESSEQUAL
100126: IFTRUE 100130
100128: GO 100137
100130: POP
// StreamSibBomb ; end ;
100131: CALL 96388 0 0
100135: GO 100138
100137: POP
// end ;
100138: PPOPN 3
100140: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
100141: LD_EXP 137
100145: PUSH
100146: LD_EXP 187
100150: AND
100151: IFFALSE 100307
100153: GO 100155
100155: DISABLE
100156: LD_INT 0
100158: PPUSH
100159: PPUSH
100160: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
100161: LD_ADDR_VAR 0 2
100165: PUSH
100166: LD_INT 81
100168: PUSH
100169: LD_OWVAR 2
100173: PUSH
100174: EMPTY
100175: LIST
100176: LIST
100177: PUSH
100178: LD_INT 2
100180: PUSH
100181: LD_INT 21
100183: PUSH
100184: LD_INT 1
100186: PUSH
100187: EMPTY
100188: LIST
100189: LIST
100190: PUSH
100191: LD_INT 21
100193: PUSH
100194: LD_INT 2
100196: PUSH
100197: EMPTY
100198: LIST
100199: LIST
100200: PUSH
100201: EMPTY
100202: LIST
100203: LIST
100204: LIST
100205: PUSH
100206: EMPTY
100207: LIST
100208: LIST
100209: PPUSH
100210: CALL_OW 69
100214: ST_TO_ADDR
// if not tmp then
100215: LD_VAR 0 2
100219: NOT
100220: IFFALSE 100224
// exit ;
100222: GO 100307
// p := 0 ;
100224: LD_ADDR_VAR 0 3
100228: PUSH
100229: LD_INT 0
100231: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100232: LD_INT 35
100234: PPUSH
100235: CALL_OW 67
// p := p + 1 ;
100239: LD_ADDR_VAR 0 3
100243: PUSH
100244: LD_VAR 0 3
100248: PUSH
100249: LD_INT 1
100251: PLUS
100252: ST_TO_ADDR
// for i in tmp do
100253: LD_ADDR_VAR 0 1
100257: PUSH
100258: LD_VAR 0 2
100262: PUSH
100263: FOR_IN
100264: IFFALSE 100295
// if GetLives ( i ) < 1000 then
100266: LD_VAR 0 1
100270: PPUSH
100271: CALL_OW 256
100275: PUSH
100276: LD_INT 1000
100278: LESS
100279: IFFALSE 100293
// SetLives ( i , 1000 ) ;
100281: LD_VAR 0 1
100285: PPUSH
100286: LD_INT 1000
100288: PPUSH
100289: CALL_OW 234
100293: GO 100263
100295: POP
100296: POP
// until p > 20 ;
100297: LD_VAR 0 3
100301: PUSH
100302: LD_INT 20
100304: GREATER
100305: IFFALSE 100232
// end ;
100307: PPOPN 3
100309: END
// every 0 0$1 trigger StreamModeActive and sTime do
100310: LD_EXP 137
100314: PUSH
100315: LD_EXP 188
100319: AND
100320: IFFALSE 100355
100322: GO 100324
100324: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
100325: LD_INT 28
100327: PPUSH
100328: LD_OWVAR 2
100332: PPUSH
100333: LD_INT 2
100335: PPUSH
100336: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
100340: LD_INT 30
100342: PPUSH
100343: LD_OWVAR 2
100347: PPUSH
100348: LD_INT 2
100350: PPUSH
100351: CALL_OW 322
// end ;
100355: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
100356: LD_EXP 137
100360: PUSH
100361: LD_EXP 189
100365: AND
100366: IFFALSE 100487
100368: GO 100370
100370: DISABLE
100371: LD_INT 0
100373: PPUSH
100374: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100375: LD_ADDR_VAR 0 2
100379: PUSH
100380: LD_INT 22
100382: PUSH
100383: LD_OWVAR 2
100387: PUSH
100388: EMPTY
100389: LIST
100390: LIST
100391: PUSH
100392: LD_INT 21
100394: PUSH
100395: LD_INT 1
100397: PUSH
100398: EMPTY
100399: LIST
100400: LIST
100401: PUSH
100402: LD_INT 3
100404: PUSH
100405: LD_INT 23
100407: PUSH
100408: LD_INT 0
100410: PUSH
100411: EMPTY
100412: LIST
100413: LIST
100414: PUSH
100415: EMPTY
100416: LIST
100417: LIST
100418: PUSH
100419: EMPTY
100420: LIST
100421: LIST
100422: LIST
100423: PPUSH
100424: CALL_OW 69
100428: ST_TO_ADDR
// if not tmp then
100429: LD_VAR 0 2
100433: NOT
100434: IFFALSE 100438
// exit ;
100436: GO 100487
// for i in tmp do
100438: LD_ADDR_VAR 0 1
100442: PUSH
100443: LD_VAR 0 2
100447: PUSH
100448: FOR_IN
100449: IFFALSE 100485
// begin if Crawls ( i ) then
100451: LD_VAR 0 1
100455: PPUSH
100456: CALL_OW 318
100460: IFFALSE 100471
// ComWalk ( i ) ;
100462: LD_VAR 0 1
100466: PPUSH
100467: CALL_OW 138
// SetClass ( i , 2 ) ;
100471: LD_VAR 0 1
100475: PPUSH
100476: LD_INT 2
100478: PPUSH
100479: CALL_OW 336
// end ;
100483: GO 100448
100485: POP
100486: POP
// end ;
100487: PPOPN 2
100489: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
100490: LD_EXP 137
100494: PUSH
100495: LD_EXP 190
100499: AND
100500: IFFALSE 100781
100502: GO 100504
100504: DISABLE
100505: LD_INT 0
100507: PPUSH
100508: PPUSH
100509: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
100510: LD_OWVAR 2
100514: PPUSH
100515: LD_INT 9
100517: PPUSH
100518: LD_INT 1
100520: PPUSH
100521: LD_INT 1
100523: PPUSH
100524: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
100528: LD_INT 9
100530: PPUSH
100531: LD_OWVAR 2
100535: PPUSH
100536: CALL_OW 343
// uc_side := 9 ;
100540: LD_ADDR_OWVAR 20
100544: PUSH
100545: LD_INT 9
100547: ST_TO_ADDR
// uc_nation := 2 ;
100548: LD_ADDR_OWVAR 21
100552: PUSH
100553: LD_INT 2
100555: ST_TO_ADDR
// hc_name := Dark Warrior ;
100556: LD_ADDR_OWVAR 26
100560: PUSH
100561: LD_STRING Dark Warrior
100563: ST_TO_ADDR
// hc_gallery :=  ;
100564: LD_ADDR_OWVAR 33
100568: PUSH
100569: LD_STRING 
100571: ST_TO_ADDR
// hc_noskilllimit := true ;
100572: LD_ADDR_OWVAR 76
100576: PUSH
100577: LD_INT 1
100579: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
100580: LD_ADDR_OWVAR 31
100584: PUSH
100585: LD_INT 30
100587: PUSH
100588: LD_INT 30
100590: PUSH
100591: LD_INT 30
100593: PUSH
100594: LD_INT 30
100596: PUSH
100597: EMPTY
100598: LIST
100599: LIST
100600: LIST
100601: LIST
100602: ST_TO_ADDR
// un := CreateHuman ;
100603: LD_ADDR_VAR 0 3
100607: PUSH
100608: CALL_OW 44
100612: ST_TO_ADDR
// hc_noskilllimit := false ;
100613: LD_ADDR_OWVAR 76
100617: PUSH
100618: LD_INT 0
100620: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100621: LD_VAR 0 3
100625: PPUSH
100626: LD_INT 1
100628: PPUSH
100629: CALL_OW 51
// p := 0 ;
100633: LD_ADDR_VAR 0 2
100637: PUSH
100638: LD_INT 0
100640: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100641: LD_INT 35
100643: PPUSH
100644: CALL_OW 67
// p := p + 1 ;
100648: LD_ADDR_VAR 0 2
100652: PUSH
100653: LD_VAR 0 2
100657: PUSH
100658: LD_INT 1
100660: PLUS
100661: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
100662: LD_VAR 0 3
100666: PPUSH
100667: CALL_OW 256
100671: PUSH
100672: LD_INT 1000
100674: LESS
100675: IFFALSE 100689
// SetLives ( un , 1000 ) ;
100677: LD_VAR 0 3
100681: PPUSH
100682: LD_INT 1000
100684: PPUSH
100685: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
100689: LD_VAR 0 3
100693: PPUSH
100694: LD_INT 81
100696: PUSH
100697: LD_OWVAR 2
100701: PUSH
100702: EMPTY
100703: LIST
100704: LIST
100705: PUSH
100706: LD_INT 91
100708: PUSH
100709: LD_VAR 0 3
100713: PUSH
100714: LD_INT 30
100716: PUSH
100717: EMPTY
100718: LIST
100719: LIST
100720: LIST
100721: PUSH
100722: EMPTY
100723: LIST
100724: LIST
100725: PPUSH
100726: CALL_OW 69
100730: PPUSH
100731: LD_VAR 0 3
100735: PPUSH
100736: CALL_OW 74
100740: PPUSH
100741: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
100745: LD_VAR 0 2
100749: PUSH
100750: LD_INT 60
100752: GREATER
100753: PUSH
100754: LD_VAR 0 3
100758: PPUSH
100759: CALL_OW 301
100763: OR
100764: IFFALSE 100641
// if un then
100766: LD_VAR 0 3
100770: IFFALSE 100781
// RemoveUnit ( un ) ;
100772: LD_VAR 0 3
100776: PPUSH
100777: CALL_OW 64
// end ;
100781: PPOPN 3
100783: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
100784: LD_INT 0
100786: PPUSH
// case cmd of 301 :
100787: LD_VAR 0 1
100791: PUSH
100792: LD_INT 301
100794: DOUBLE
100795: EQUAL
100796: IFTRUE 100800
100798: GO 100832
100800: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
100801: LD_VAR 0 6
100805: PPUSH
100806: LD_VAR 0 7
100810: PPUSH
100811: LD_VAR 0 8
100815: PPUSH
100816: LD_VAR 0 4
100820: PPUSH
100821: LD_VAR 0 5
100825: PPUSH
100826: CALL 102033 0 5
100830: GO 100953
100832: LD_INT 302
100834: DOUBLE
100835: EQUAL
100836: IFTRUE 100840
100838: GO 100877
100840: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
100841: LD_VAR 0 6
100845: PPUSH
100846: LD_VAR 0 7
100850: PPUSH
100851: LD_VAR 0 8
100855: PPUSH
100856: LD_VAR 0 9
100860: PPUSH
100861: LD_VAR 0 4
100865: PPUSH
100866: LD_VAR 0 5
100870: PPUSH
100871: CALL 102124 0 6
100875: GO 100953
100877: LD_INT 303
100879: DOUBLE
100880: EQUAL
100881: IFTRUE 100885
100883: GO 100922
100885: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
100886: LD_VAR 0 6
100890: PPUSH
100891: LD_VAR 0 7
100895: PPUSH
100896: LD_VAR 0 8
100900: PPUSH
100901: LD_VAR 0 9
100905: PPUSH
100906: LD_VAR 0 4
100910: PPUSH
100911: LD_VAR 0 5
100915: PPUSH
100916: CALL 100958 0 6
100920: GO 100953
100922: LD_INT 304
100924: DOUBLE
100925: EQUAL
100926: IFTRUE 100930
100928: GO 100952
100930: POP
// hHackTeleport ( unit , x , y ) ; end ;
100931: LD_VAR 0 2
100935: PPUSH
100936: LD_VAR 0 4
100940: PPUSH
100941: LD_VAR 0 5
100945: PPUSH
100946: CALL 102717 0 3
100950: GO 100953
100952: POP
// end ;
100953: LD_VAR 0 12
100957: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
100958: LD_INT 0
100960: PPUSH
100961: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
100962: LD_VAR 0 1
100966: PUSH
100967: LD_INT 1
100969: LESS
100970: PUSH
100971: LD_VAR 0 1
100975: PUSH
100976: LD_INT 3
100978: GREATER
100979: OR
100980: PUSH
100981: LD_VAR 0 5
100985: PPUSH
100986: LD_VAR 0 6
100990: PPUSH
100991: CALL_OW 428
100995: OR
100996: IFFALSE 101000
// exit ;
100998: GO 101720
// uc_side := your_side ;
101000: LD_ADDR_OWVAR 20
101004: PUSH
101005: LD_OWVAR 2
101009: ST_TO_ADDR
// uc_nation := nation ;
101010: LD_ADDR_OWVAR 21
101014: PUSH
101015: LD_VAR 0 1
101019: ST_TO_ADDR
// bc_level = 1 ;
101020: LD_ADDR_OWVAR 43
101024: PUSH
101025: LD_INT 1
101027: ST_TO_ADDR
// case btype of 1 :
101028: LD_VAR 0 2
101032: PUSH
101033: LD_INT 1
101035: DOUBLE
101036: EQUAL
101037: IFTRUE 101041
101039: GO 101052
101041: POP
// bc_type := b_depot ; 2 :
101042: LD_ADDR_OWVAR 42
101046: PUSH
101047: LD_INT 0
101049: ST_TO_ADDR
101050: GO 101664
101052: LD_INT 2
101054: DOUBLE
101055: EQUAL
101056: IFTRUE 101060
101058: GO 101071
101060: POP
// bc_type := b_warehouse ; 3 :
101061: LD_ADDR_OWVAR 42
101065: PUSH
101066: LD_INT 1
101068: ST_TO_ADDR
101069: GO 101664
101071: LD_INT 3
101073: DOUBLE
101074: EQUAL
101075: IFTRUE 101079
101077: GO 101090
101079: POP
// bc_type := b_lab ; 4 .. 9 :
101080: LD_ADDR_OWVAR 42
101084: PUSH
101085: LD_INT 6
101087: ST_TO_ADDR
101088: GO 101664
101090: LD_INT 4
101092: DOUBLE
101093: GREATEREQUAL
101094: IFFALSE 101102
101096: LD_INT 9
101098: DOUBLE
101099: LESSEQUAL
101100: IFTRUE 101104
101102: GO 101156
101104: POP
// begin bc_type := b_lab_half ;
101105: LD_ADDR_OWVAR 42
101109: PUSH
101110: LD_INT 7
101112: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
101113: LD_ADDR_OWVAR 44
101117: PUSH
101118: LD_INT 10
101120: PUSH
101121: LD_INT 11
101123: PUSH
101124: LD_INT 12
101126: PUSH
101127: LD_INT 15
101129: PUSH
101130: LD_INT 14
101132: PUSH
101133: LD_INT 13
101135: PUSH
101136: EMPTY
101137: LIST
101138: LIST
101139: LIST
101140: LIST
101141: LIST
101142: LIST
101143: PUSH
101144: LD_VAR 0 2
101148: PUSH
101149: LD_INT 3
101151: MINUS
101152: ARRAY
101153: ST_TO_ADDR
// end ; 10 .. 13 :
101154: GO 101664
101156: LD_INT 10
101158: DOUBLE
101159: GREATEREQUAL
101160: IFFALSE 101168
101162: LD_INT 13
101164: DOUBLE
101165: LESSEQUAL
101166: IFTRUE 101170
101168: GO 101247
101170: POP
// begin bc_type := b_lab_full ;
101171: LD_ADDR_OWVAR 42
101175: PUSH
101176: LD_INT 8
101178: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
101179: LD_ADDR_OWVAR 44
101183: PUSH
101184: LD_INT 10
101186: PUSH
101187: LD_INT 12
101189: PUSH
101190: LD_INT 14
101192: PUSH
101193: LD_INT 13
101195: PUSH
101196: EMPTY
101197: LIST
101198: LIST
101199: LIST
101200: LIST
101201: PUSH
101202: LD_VAR 0 2
101206: PUSH
101207: LD_INT 9
101209: MINUS
101210: ARRAY
101211: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
101212: LD_ADDR_OWVAR 45
101216: PUSH
101217: LD_INT 11
101219: PUSH
101220: LD_INT 15
101222: PUSH
101223: LD_INT 12
101225: PUSH
101226: LD_INT 15
101228: PUSH
101229: EMPTY
101230: LIST
101231: LIST
101232: LIST
101233: LIST
101234: PUSH
101235: LD_VAR 0 2
101239: PUSH
101240: LD_INT 9
101242: MINUS
101243: ARRAY
101244: ST_TO_ADDR
// end ; 14 :
101245: GO 101664
101247: LD_INT 14
101249: DOUBLE
101250: EQUAL
101251: IFTRUE 101255
101253: GO 101266
101255: POP
// bc_type := b_workshop ; 15 :
101256: LD_ADDR_OWVAR 42
101260: PUSH
101261: LD_INT 2
101263: ST_TO_ADDR
101264: GO 101664
101266: LD_INT 15
101268: DOUBLE
101269: EQUAL
101270: IFTRUE 101274
101272: GO 101285
101274: POP
// bc_type := b_factory ; 16 :
101275: LD_ADDR_OWVAR 42
101279: PUSH
101280: LD_INT 3
101282: ST_TO_ADDR
101283: GO 101664
101285: LD_INT 16
101287: DOUBLE
101288: EQUAL
101289: IFTRUE 101293
101291: GO 101304
101293: POP
// bc_type := b_ext_gun ; 17 :
101294: LD_ADDR_OWVAR 42
101298: PUSH
101299: LD_INT 17
101301: ST_TO_ADDR
101302: GO 101664
101304: LD_INT 17
101306: DOUBLE
101307: EQUAL
101308: IFTRUE 101312
101310: GO 101340
101312: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
101313: LD_ADDR_OWVAR 42
101317: PUSH
101318: LD_INT 19
101320: PUSH
101321: LD_INT 23
101323: PUSH
101324: LD_INT 19
101326: PUSH
101327: EMPTY
101328: LIST
101329: LIST
101330: LIST
101331: PUSH
101332: LD_VAR 0 1
101336: ARRAY
101337: ST_TO_ADDR
101338: GO 101664
101340: LD_INT 18
101342: DOUBLE
101343: EQUAL
101344: IFTRUE 101348
101346: GO 101359
101348: POP
// bc_type := b_ext_radar ; 19 :
101349: LD_ADDR_OWVAR 42
101353: PUSH
101354: LD_INT 20
101356: ST_TO_ADDR
101357: GO 101664
101359: LD_INT 19
101361: DOUBLE
101362: EQUAL
101363: IFTRUE 101367
101365: GO 101378
101367: POP
// bc_type := b_ext_radio ; 20 :
101368: LD_ADDR_OWVAR 42
101372: PUSH
101373: LD_INT 22
101375: ST_TO_ADDR
101376: GO 101664
101378: LD_INT 20
101380: DOUBLE
101381: EQUAL
101382: IFTRUE 101386
101384: GO 101397
101386: POP
// bc_type := b_ext_siberium ; 21 :
101387: LD_ADDR_OWVAR 42
101391: PUSH
101392: LD_INT 21
101394: ST_TO_ADDR
101395: GO 101664
101397: LD_INT 21
101399: DOUBLE
101400: EQUAL
101401: IFTRUE 101405
101403: GO 101416
101405: POP
// bc_type := b_ext_computer ; 22 :
101406: LD_ADDR_OWVAR 42
101410: PUSH
101411: LD_INT 24
101413: ST_TO_ADDR
101414: GO 101664
101416: LD_INT 22
101418: DOUBLE
101419: EQUAL
101420: IFTRUE 101424
101422: GO 101435
101424: POP
// bc_type := b_ext_track ; 23 :
101425: LD_ADDR_OWVAR 42
101429: PUSH
101430: LD_INT 16
101432: ST_TO_ADDR
101433: GO 101664
101435: LD_INT 23
101437: DOUBLE
101438: EQUAL
101439: IFTRUE 101443
101441: GO 101454
101443: POP
// bc_type := b_ext_laser ; 24 :
101444: LD_ADDR_OWVAR 42
101448: PUSH
101449: LD_INT 25
101451: ST_TO_ADDR
101452: GO 101664
101454: LD_INT 24
101456: DOUBLE
101457: EQUAL
101458: IFTRUE 101462
101460: GO 101473
101462: POP
// bc_type := b_control_tower ; 25 :
101463: LD_ADDR_OWVAR 42
101467: PUSH
101468: LD_INT 36
101470: ST_TO_ADDR
101471: GO 101664
101473: LD_INT 25
101475: DOUBLE
101476: EQUAL
101477: IFTRUE 101481
101479: GO 101492
101481: POP
// bc_type := b_breastwork ; 26 :
101482: LD_ADDR_OWVAR 42
101486: PUSH
101487: LD_INT 31
101489: ST_TO_ADDR
101490: GO 101664
101492: LD_INT 26
101494: DOUBLE
101495: EQUAL
101496: IFTRUE 101500
101498: GO 101511
101500: POP
// bc_type := b_bunker ; 27 :
101501: LD_ADDR_OWVAR 42
101505: PUSH
101506: LD_INT 32
101508: ST_TO_ADDR
101509: GO 101664
101511: LD_INT 27
101513: DOUBLE
101514: EQUAL
101515: IFTRUE 101519
101517: GO 101530
101519: POP
// bc_type := b_turret ; 28 :
101520: LD_ADDR_OWVAR 42
101524: PUSH
101525: LD_INT 33
101527: ST_TO_ADDR
101528: GO 101664
101530: LD_INT 28
101532: DOUBLE
101533: EQUAL
101534: IFTRUE 101538
101536: GO 101549
101538: POP
// bc_type := b_armoury ; 29 :
101539: LD_ADDR_OWVAR 42
101543: PUSH
101544: LD_INT 4
101546: ST_TO_ADDR
101547: GO 101664
101549: LD_INT 29
101551: DOUBLE
101552: EQUAL
101553: IFTRUE 101557
101555: GO 101568
101557: POP
// bc_type := b_barracks ; 30 :
101558: LD_ADDR_OWVAR 42
101562: PUSH
101563: LD_INT 5
101565: ST_TO_ADDR
101566: GO 101664
101568: LD_INT 30
101570: DOUBLE
101571: EQUAL
101572: IFTRUE 101576
101574: GO 101587
101576: POP
// bc_type := b_solar_power ; 31 :
101577: LD_ADDR_OWVAR 42
101581: PUSH
101582: LD_INT 27
101584: ST_TO_ADDR
101585: GO 101664
101587: LD_INT 31
101589: DOUBLE
101590: EQUAL
101591: IFTRUE 101595
101593: GO 101606
101595: POP
// bc_type := b_oil_power ; 32 :
101596: LD_ADDR_OWVAR 42
101600: PUSH
101601: LD_INT 26
101603: ST_TO_ADDR
101604: GO 101664
101606: LD_INT 32
101608: DOUBLE
101609: EQUAL
101610: IFTRUE 101614
101612: GO 101625
101614: POP
// bc_type := b_siberite_power ; 33 :
101615: LD_ADDR_OWVAR 42
101619: PUSH
101620: LD_INT 28
101622: ST_TO_ADDR
101623: GO 101664
101625: LD_INT 33
101627: DOUBLE
101628: EQUAL
101629: IFTRUE 101633
101631: GO 101644
101633: POP
// bc_type := b_oil_mine ; 34 :
101634: LD_ADDR_OWVAR 42
101638: PUSH
101639: LD_INT 29
101641: ST_TO_ADDR
101642: GO 101664
101644: LD_INT 34
101646: DOUBLE
101647: EQUAL
101648: IFTRUE 101652
101650: GO 101663
101652: POP
// bc_type := b_siberite_mine ; end ;
101653: LD_ADDR_OWVAR 42
101657: PUSH
101658: LD_INT 30
101660: ST_TO_ADDR
101661: GO 101664
101663: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
101664: LD_ADDR_VAR 0 8
101668: PUSH
101669: LD_VAR 0 5
101673: PPUSH
101674: LD_VAR 0 6
101678: PPUSH
101679: LD_VAR 0 3
101683: PPUSH
101684: CALL_OW 47
101688: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
101689: LD_OWVAR 42
101693: PUSH
101694: LD_INT 32
101696: PUSH
101697: LD_INT 33
101699: PUSH
101700: EMPTY
101701: LIST
101702: LIST
101703: IN
101704: IFFALSE 101720
// PlaceWeaponTurret ( b , weapon ) ;
101706: LD_VAR 0 8
101710: PPUSH
101711: LD_VAR 0 4
101715: PPUSH
101716: CALL_OW 431
// end ;
101720: LD_VAR 0 7
101724: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
101725: LD_INT 0
101727: PPUSH
101728: PPUSH
101729: PPUSH
101730: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101731: LD_ADDR_VAR 0 4
101735: PUSH
101736: LD_INT 22
101738: PUSH
101739: LD_OWVAR 2
101743: PUSH
101744: EMPTY
101745: LIST
101746: LIST
101747: PUSH
101748: LD_INT 2
101750: PUSH
101751: LD_INT 30
101753: PUSH
101754: LD_INT 0
101756: PUSH
101757: EMPTY
101758: LIST
101759: LIST
101760: PUSH
101761: LD_INT 30
101763: PUSH
101764: LD_INT 1
101766: PUSH
101767: EMPTY
101768: LIST
101769: LIST
101770: PUSH
101771: EMPTY
101772: LIST
101773: LIST
101774: LIST
101775: PUSH
101776: EMPTY
101777: LIST
101778: LIST
101779: PPUSH
101780: CALL_OW 69
101784: ST_TO_ADDR
// if not tmp then
101785: LD_VAR 0 4
101789: NOT
101790: IFFALSE 101794
// exit ;
101792: GO 101853
// for i in tmp do
101794: LD_ADDR_VAR 0 2
101798: PUSH
101799: LD_VAR 0 4
101803: PUSH
101804: FOR_IN
101805: IFFALSE 101851
// for j = 1 to 3 do
101807: LD_ADDR_VAR 0 3
101811: PUSH
101812: DOUBLE
101813: LD_INT 1
101815: DEC
101816: ST_TO_ADDR
101817: LD_INT 3
101819: PUSH
101820: FOR_TO
101821: IFFALSE 101847
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
101823: LD_VAR 0 2
101827: PPUSH
101828: CALL_OW 274
101832: PPUSH
101833: LD_VAR 0 3
101837: PPUSH
101838: LD_INT 99999
101840: PPUSH
101841: CALL_OW 277
101845: GO 101820
101847: POP
101848: POP
101849: GO 101804
101851: POP
101852: POP
// end ;
101853: LD_VAR 0 1
101857: RET
// export function hHackSetLevel10 ; var i , j ; begin
101858: LD_INT 0
101860: PPUSH
101861: PPUSH
101862: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101863: LD_ADDR_VAR 0 2
101867: PUSH
101868: LD_INT 21
101870: PUSH
101871: LD_INT 1
101873: PUSH
101874: EMPTY
101875: LIST
101876: LIST
101877: PPUSH
101878: CALL_OW 69
101882: PUSH
101883: FOR_IN
101884: IFFALSE 101936
// if IsSelected ( i ) then
101886: LD_VAR 0 2
101890: PPUSH
101891: CALL_OW 306
101895: IFFALSE 101934
// begin for j := 1 to 4 do
101897: LD_ADDR_VAR 0 3
101901: PUSH
101902: DOUBLE
101903: LD_INT 1
101905: DEC
101906: ST_TO_ADDR
101907: LD_INT 4
101909: PUSH
101910: FOR_TO
101911: IFFALSE 101932
// SetSkill ( i , j , 10 ) ;
101913: LD_VAR 0 2
101917: PPUSH
101918: LD_VAR 0 3
101922: PPUSH
101923: LD_INT 10
101925: PPUSH
101926: CALL_OW 237
101930: GO 101910
101932: POP
101933: POP
// end ;
101934: GO 101883
101936: POP
101937: POP
// end ;
101938: LD_VAR 0 1
101942: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
101943: LD_INT 0
101945: PPUSH
101946: PPUSH
101947: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
101948: LD_ADDR_VAR 0 2
101952: PUSH
101953: LD_INT 22
101955: PUSH
101956: LD_OWVAR 2
101960: PUSH
101961: EMPTY
101962: LIST
101963: LIST
101964: PUSH
101965: LD_INT 21
101967: PUSH
101968: LD_INT 1
101970: PUSH
101971: EMPTY
101972: LIST
101973: LIST
101974: PUSH
101975: EMPTY
101976: LIST
101977: LIST
101978: PPUSH
101979: CALL_OW 69
101983: PUSH
101984: FOR_IN
101985: IFFALSE 102026
// begin for j := 1 to 4 do
101987: LD_ADDR_VAR 0 3
101991: PUSH
101992: DOUBLE
101993: LD_INT 1
101995: DEC
101996: ST_TO_ADDR
101997: LD_INT 4
101999: PUSH
102000: FOR_TO
102001: IFFALSE 102022
// SetSkill ( i , j , 10 ) ;
102003: LD_VAR 0 2
102007: PPUSH
102008: LD_VAR 0 3
102012: PPUSH
102013: LD_INT 10
102015: PPUSH
102016: CALL_OW 237
102020: GO 102000
102022: POP
102023: POP
// end ;
102024: GO 101984
102026: POP
102027: POP
// end ;
102028: LD_VAR 0 1
102032: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
102033: LD_INT 0
102035: PPUSH
// uc_side := your_side ;
102036: LD_ADDR_OWVAR 20
102040: PUSH
102041: LD_OWVAR 2
102045: ST_TO_ADDR
// uc_nation := nation ;
102046: LD_ADDR_OWVAR 21
102050: PUSH
102051: LD_VAR 0 1
102055: ST_TO_ADDR
// InitHc ;
102056: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
102060: LD_INT 0
102062: PPUSH
102063: LD_VAR 0 2
102067: PPUSH
102068: LD_VAR 0 3
102072: PPUSH
102073: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
102077: LD_VAR 0 4
102081: PPUSH
102082: LD_VAR 0 5
102086: PPUSH
102087: CALL_OW 428
102091: PUSH
102092: LD_INT 0
102094: EQUAL
102095: IFFALSE 102119
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
102097: CALL_OW 44
102101: PPUSH
102102: LD_VAR 0 4
102106: PPUSH
102107: LD_VAR 0 5
102111: PPUSH
102112: LD_INT 1
102114: PPUSH
102115: CALL_OW 48
// end ;
102119: LD_VAR 0 6
102123: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
102124: LD_INT 0
102126: PPUSH
102127: PPUSH
// uc_side := your_side ;
102128: LD_ADDR_OWVAR 20
102132: PUSH
102133: LD_OWVAR 2
102137: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
102138: LD_VAR 0 1
102142: PUSH
102143: LD_INT 1
102145: PUSH
102146: LD_INT 2
102148: PUSH
102149: LD_INT 3
102151: PUSH
102152: LD_INT 4
102154: PUSH
102155: LD_INT 5
102157: PUSH
102158: EMPTY
102159: LIST
102160: LIST
102161: LIST
102162: LIST
102163: LIST
102164: IN
102165: IFFALSE 102177
// uc_nation := nation_american else
102167: LD_ADDR_OWVAR 21
102171: PUSH
102172: LD_INT 1
102174: ST_TO_ADDR
102175: GO 102220
// if chassis in [ 11 , 12 , 13 , 14 ] then
102177: LD_VAR 0 1
102181: PUSH
102182: LD_INT 11
102184: PUSH
102185: LD_INT 12
102187: PUSH
102188: LD_INT 13
102190: PUSH
102191: LD_INT 14
102193: PUSH
102194: EMPTY
102195: LIST
102196: LIST
102197: LIST
102198: LIST
102199: IN
102200: IFFALSE 102212
// uc_nation := nation_arabian else
102202: LD_ADDR_OWVAR 21
102206: PUSH
102207: LD_INT 2
102209: ST_TO_ADDR
102210: GO 102220
// uc_nation := nation_russian ;
102212: LD_ADDR_OWVAR 21
102216: PUSH
102217: LD_INT 3
102219: ST_TO_ADDR
// vc_chassis := chassis ;
102220: LD_ADDR_OWVAR 37
102224: PUSH
102225: LD_VAR 0 1
102229: ST_TO_ADDR
// vc_engine := engine ;
102230: LD_ADDR_OWVAR 39
102234: PUSH
102235: LD_VAR 0 2
102239: ST_TO_ADDR
// vc_control := control ;
102240: LD_ADDR_OWVAR 38
102244: PUSH
102245: LD_VAR 0 3
102249: ST_TO_ADDR
// vc_weapon := weapon ;
102250: LD_ADDR_OWVAR 40
102254: PUSH
102255: LD_VAR 0 4
102259: ST_TO_ADDR
// un := CreateVehicle ;
102260: LD_ADDR_VAR 0 8
102264: PUSH
102265: CALL_OW 45
102269: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
102270: LD_VAR 0 8
102274: PPUSH
102275: LD_INT 0
102277: PPUSH
102278: LD_INT 5
102280: PPUSH
102281: CALL_OW 12
102285: PPUSH
102286: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
102290: LD_VAR 0 8
102294: PPUSH
102295: LD_VAR 0 5
102299: PPUSH
102300: LD_VAR 0 6
102304: PPUSH
102305: LD_INT 1
102307: PPUSH
102308: CALL_OW 48
// end ;
102312: LD_VAR 0 7
102316: RET
// export hInvincible ; every 1 do
102317: GO 102319
102319: DISABLE
// hInvincible := [ ] ;
102320: LD_ADDR_EXP 191
102324: PUSH
102325: EMPTY
102326: ST_TO_ADDR
102327: END
// every 10 do var i ;
102328: GO 102330
102330: DISABLE
102331: LD_INT 0
102333: PPUSH
// begin enable ;
102334: ENABLE
// if not hInvincible then
102335: LD_EXP 191
102339: NOT
102340: IFFALSE 102344
// exit ;
102342: GO 102388
// for i in hInvincible do
102344: LD_ADDR_VAR 0 1
102348: PUSH
102349: LD_EXP 191
102353: PUSH
102354: FOR_IN
102355: IFFALSE 102386
// if GetLives ( i ) < 1000 then
102357: LD_VAR 0 1
102361: PPUSH
102362: CALL_OW 256
102366: PUSH
102367: LD_INT 1000
102369: LESS
102370: IFFALSE 102384
// SetLives ( i , 1000 ) ;
102372: LD_VAR 0 1
102376: PPUSH
102377: LD_INT 1000
102379: PPUSH
102380: CALL_OW 234
102384: GO 102354
102386: POP
102387: POP
// end ;
102388: PPOPN 1
102390: END
// export function hHackInvincible ; var i ; begin
102391: LD_INT 0
102393: PPUSH
102394: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
102395: LD_ADDR_VAR 0 2
102399: PUSH
102400: LD_INT 2
102402: PUSH
102403: LD_INT 21
102405: PUSH
102406: LD_INT 1
102408: PUSH
102409: EMPTY
102410: LIST
102411: LIST
102412: PUSH
102413: LD_INT 21
102415: PUSH
102416: LD_INT 2
102418: PUSH
102419: EMPTY
102420: LIST
102421: LIST
102422: PUSH
102423: EMPTY
102424: LIST
102425: LIST
102426: LIST
102427: PPUSH
102428: CALL_OW 69
102432: PUSH
102433: FOR_IN
102434: IFFALSE 102495
// if IsSelected ( i ) then
102436: LD_VAR 0 2
102440: PPUSH
102441: CALL_OW 306
102445: IFFALSE 102493
// begin if i in hInvincible then
102447: LD_VAR 0 2
102451: PUSH
102452: LD_EXP 191
102456: IN
102457: IFFALSE 102477
// hInvincible := hInvincible diff i else
102459: LD_ADDR_EXP 191
102463: PUSH
102464: LD_EXP 191
102468: PUSH
102469: LD_VAR 0 2
102473: DIFF
102474: ST_TO_ADDR
102475: GO 102493
// hInvincible := hInvincible union i ;
102477: LD_ADDR_EXP 191
102481: PUSH
102482: LD_EXP 191
102486: PUSH
102487: LD_VAR 0 2
102491: UNION
102492: ST_TO_ADDR
// end ;
102493: GO 102433
102495: POP
102496: POP
// end ;
102497: LD_VAR 0 1
102501: RET
// export function hHackInvisible ; var i , j ; begin
102502: LD_INT 0
102504: PPUSH
102505: PPUSH
102506: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102507: LD_ADDR_VAR 0 2
102511: PUSH
102512: LD_INT 21
102514: PUSH
102515: LD_INT 1
102517: PUSH
102518: EMPTY
102519: LIST
102520: LIST
102521: PPUSH
102522: CALL_OW 69
102526: PUSH
102527: FOR_IN
102528: IFFALSE 102552
// if IsSelected ( i ) then
102530: LD_VAR 0 2
102534: PPUSH
102535: CALL_OW 306
102539: IFFALSE 102550
// ComForceInvisible ( i ) ;
102541: LD_VAR 0 2
102545: PPUSH
102546: CALL_OW 496
102550: GO 102527
102552: POP
102553: POP
// end ;
102554: LD_VAR 0 1
102558: RET
// export function hHackChangeYourSide ; begin
102559: LD_INT 0
102561: PPUSH
// if your_side = 8 then
102562: LD_OWVAR 2
102566: PUSH
102567: LD_INT 8
102569: EQUAL
102570: IFFALSE 102582
// your_side := 0 else
102572: LD_ADDR_OWVAR 2
102576: PUSH
102577: LD_INT 0
102579: ST_TO_ADDR
102580: GO 102596
// your_side := your_side + 1 ;
102582: LD_ADDR_OWVAR 2
102586: PUSH
102587: LD_OWVAR 2
102591: PUSH
102592: LD_INT 1
102594: PLUS
102595: ST_TO_ADDR
// end ;
102596: LD_VAR 0 1
102600: RET
// export function hHackChangeUnitSide ; var i , j ; begin
102601: LD_INT 0
102603: PPUSH
102604: PPUSH
102605: PPUSH
// for i in all_units do
102606: LD_ADDR_VAR 0 2
102610: PUSH
102611: LD_OWVAR 3
102615: PUSH
102616: FOR_IN
102617: IFFALSE 102695
// if IsSelected ( i ) then
102619: LD_VAR 0 2
102623: PPUSH
102624: CALL_OW 306
102628: IFFALSE 102693
// begin j := GetSide ( i ) ;
102630: LD_ADDR_VAR 0 3
102634: PUSH
102635: LD_VAR 0 2
102639: PPUSH
102640: CALL_OW 255
102644: ST_TO_ADDR
// if j = 8 then
102645: LD_VAR 0 3
102649: PUSH
102650: LD_INT 8
102652: EQUAL
102653: IFFALSE 102665
// j := 0 else
102655: LD_ADDR_VAR 0 3
102659: PUSH
102660: LD_INT 0
102662: ST_TO_ADDR
102663: GO 102679
// j := j + 1 ;
102665: LD_ADDR_VAR 0 3
102669: PUSH
102670: LD_VAR 0 3
102674: PUSH
102675: LD_INT 1
102677: PLUS
102678: ST_TO_ADDR
// SetSide ( i , j ) ;
102679: LD_VAR 0 2
102683: PPUSH
102684: LD_VAR 0 3
102688: PPUSH
102689: CALL_OW 235
// end ;
102693: GO 102616
102695: POP
102696: POP
// end ;
102697: LD_VAR 0 1
102701: RET
// export function hHackFog ; begin
102702: LD_INT 0
102704: PPUSH
// FogOff ( true ) ;
102705: LD_INT 1
102707: PPUSH
102708: CALL_OW 344
// end ;
102712: LD_VAR 0 1
102716: RET
// export function hHackTeleport ( unit , x , y ) ; begin
102717: LD_INT 0
102719: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
102720: LD_VAR 0 1
102724: PPUSH
102725: LD_VAR 0 2
102729: PPUSH
102730: LD_VAR 0 3
102734: PPUSH
102735: LD_INT 1
102737: PPUSH
102738: LD_INT 1
102740: PPUSH
102741: CALL_OW 483
// CenterOnXY ( x , y ) ;
102745: LD_VAR 0 2
102749: PPUSH
102750: LD_VAR 0 3
102754: PPUSH
102755: CALL_OW 84
// end ; end_of_file
102759: LD_VAR 0 4
102763: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
102764: LD_INT 0
102766: PPUSH
102767: PPUSH
102768: PPUSH
102769: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
102770: LD_VAR 0 1
102774: PPUSH
102775: CALL_OW 264
102779: PUSH
102780: LD_EXP 76
102784: EQUAL
102785: IFFALSE 102857
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
102787: LD_INT 68
102789: PPUSH
102790: LD_VAR 0 1
102794: PPUSH
102795: CALL_OW 255
102799: PPUSH
102800: CALL_OW 321
102804: PUSH
102805: LD_INT 2
102807: EQUAL
102808: IFFALSE 102820
// eff := 70 else
102810: LD_ADDR_VAR 0 4
102814: PUSH
102815: LD_INT 70
102817: ST_TO_ADDR
102818: GO 102828
// eff := 30 ;
102820: LD_ADDR_VAR 0 4
102824: PUSH
102825: LD_INT 30
102827: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
102828: LD_VAR 0 1
102832: PPUSH
102833: CALL_OW 250
102837: PPUSH
102838: LD_VAR 0 1
102842: PPUSH
102843: CALL_OW 251
102847: PPUSH
102848: LD_VAR 0 4
102852: PPUSH
102853: CALL_OW 495
// end ; end ;
102857: LD_VAR 0 2
102861: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
102862: LD_INT 0
102864: PPUSH
// end ;
102865: LD_VAR 0 4
102869: RET
// export function SOS_Command ( cmd ) ; begin
102870: LD_INT 0
102872: PPUSH
// end ;
102873: LD_VAR 0 2
102877: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
102878: LD_INT 0
102880: PPUSH
// if cmd = 121 then
102881: LD_VAR 0 1
102885: PUSH
102886: LD_INT 121
102888: EQUAL
102889: IFFALSE 102891
// end ;
102891: LD_VAR 0 6
102895: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
102896: LD_INT 0
102898: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
102899: LD_VAR 0 1
102903: PUSH
102904: LD_INT 250
102906: EQUAL
102907: PUSH
102908: LD_VAR 0 2
102912: PPUSH
102913: CALL_OW 264
102917: PUSH
102918: LD_EXP 79
102922: EQUAL
102923: AND
102924: IFFALSE 102945
// MinerPlaceMine ( unit , x , y ) ;
102926: LD_VAR 0 2
102930: PPUSH
102931: LD_VAR 0 4
102935: PPUSH
102936: LD_VAR 0 5
102940: PPUSH
102941: CALL 105294 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
102945: LD_VAR 0 1
102949: PUSH
102950: LD_INT 251
102952: EQUAL
102953: PUSH
102954: LD_VAR 0 2
102958: PPUSH
102959: CALL_OW 264
102963: PUSH
102964: LD_EXP 79
102968: EQUAL
102969: AND
102970: IFFALSE 102991
// MinerDetonateMine ( unit , x , y ) ;
102972: LD_VAR 0 2
102976: PPUSH
102977: LD_VAR 0 4
102981: PPUSH
102982: LD_VAR 0 5
102986: PPUSH
102987: CALL 105571 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
102991: LD_VAR 0 1
102995: PUSH
102996: LD_INT 252
102998: EQUAL
102999: PUSH
103000: LD_VAR 0 2
103004: PPUSH
103005: CALL_OW 264
103009: PUSH
103010: LD_EXP 79
103014: EQUAL
103015: AND
103016: IFFALSE 103037
// MinerCreateMinefield ( unit , x , y ) ;
103018: LD_VAR 0 2
103022: PPUSH
103023: LD_VAR 0 4
103027: PPUSH
103028: LD_VAR 0 5
103032: PPUSH
103033: CALL 105988 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
103037: LD_VAR 0 1
103041: PUSH
103042: LD_INT 253
103044: EQUAL
103045: PUSH
103046: LD_VAR 0 2
103050: PPUSH
103051: CALL_OW 257
103055: PUSH
103056: LD_INT 5
103058: EQUAL
103059: AND
103060: IFFALSE 103081
// ComBinocular ( unit , x , y ) ;
103062: LD_VAR 0 2
103066: PPUSH
103067: LD_VAR 0 4
103071: PPUSH
103072: LD_VAR 0 5
103076: PPUSH
103077: CALL 106359 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
103081: LD_VAR 0 1
103085: PUSH
103086: LD_INT 254
103088: EQUAL
103089: PUSH
103090: LD_VAR 0 2
103094: PPUSH
103095: CALL_OW 264
103099: PUSH
103100: LD_EXP 74
103104: EQUAL
103105: AND
103106: PUSH
103107: LD_VAR 0 3
103111: PPUSH
103112: CALL_OW 263
103116: PUSH
103117: LD_INT 3
103119: EQUAL
103120: AND
103121: IFFALSE 103137
// HackDestroyVehicle ( unit , selectedUnit ) ;
103123: LD_VAR 0 2
103127: PPUSH
103128: LD_VAR 0 3
103132: PPUSH
103133: CALL 104654 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
103137: LD_VAR 0 1
103141: PUSH
103142: LD_INT 255
103144: EQUAL
103145: PUSH
103146: LD_VAR 0 2
103150: PPUSH
103151: CALL_OW 264
103155: PUSH
103156: LD_INT 14
103158: PUSH
103159: LD_INT 53
103161: PUSH
103162: EMPTY
103163: LIST
103164: LIST
103165: IN
103166: AND
103167: PUSH
103168: LD_VAR 0 4
103172: PPUSH
103173: LD_VAR 0 5
103177: PPUSH
103178: CALL_OW 488
103182: AND
103183: IFFALSE 103207
// CutTreeXYR ( unit , x , y , 12 ) ;
103185: LD_VAR 0 2
103189: PPUSH
103190: LD_VAR 0 4
103194: PPUSH
103195: LD_VAR 0 5
103199: PPUSH
103200: LD_INT 12
103202: PPUSH
103203: CALL 103220 0 4
// end ;
103207: LD_VAR 0 6
103211: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
103212: LD_INT 0
103214: PPUSH
// end ;
103215: LD_VAR 0 4
103219: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
103220: LD_INT 0
103222: PPUSH
103223: PPUSH
103224: PPUSH
103225: PPUSH
103226: PPUSH
103227: PPUSH
103228: PPUSH
103229: PPUSH
103230: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
103231: LD_VAR 0 1
103235: NOT
103236: PUSH
103237: LD_VAR 0 2
103241: PPUSH
103242: LD_VAR 0 3
103246: PPUSH
103247: CALL_OW 488
103251: NOT
103252: OR
103253: PUSH
103254: LD_VAR 0 4
103258: NOT
103259: OR
103260: IFFALSE 103264
// exit ;
103262: GO 103604
// list := [ ] ;
103264: LD_ADDR_VAR 0 13
103268: PUSH
103269: EMPTY
103270: ST_TO_ADDR
// if x - r < 0 then
103271: LD_VAR 0 2
103275: PUSH
103276: LD_VAR 0 4
103280: MINUS
103281: PUSH
103282: LD_INT 0
103284: LESS
103285: IFFALSE 103297
// min_x := 0 else
103287: LD_ADDR_VAR 0 7
103291: PUSH
103292: LD_INT 0
103294: ST_TO_ADDR
103295: GO 103313
// min_x := x - r ;
103297: LD_ADDR_VAR 0 7
103301: PUSH
103302: LD_VAR 0 2
103306: PUSH
103307: LD_VAR 0 4
103311: MINUS
103312: ST_TO_ADDR
// if y - r < 0 then
103313: LD_VAR 0 3
103317: PUSH
103318: LD_VAR 0 4
103322: MINUS
103323: PUSH
103324: LD_INT 0
103326: LESS
103327: IFFALSE 103339
// min_y := 0 else
103329: LD_ADDR_VAR 0 8
103333: PUSH
103334: LD_INT 0
103336: ST_TO_ADDR
103337: GO 103355
// min_y := y - r ;
103339: LD_ADDR_VAR 0 8
103343: PUSH
103344: LD_VAR 0 3
103348: PUSH
103349: LD_VAR 0 4
103353: MINUS
103354: ST_TO_ADDR
// max_x := x + r ;
103355: LD_ADDR_VAR 0 9
103359: PUSH
103360: LD_VAR 0 2
103364: PUSH
103365: LD_VAR 0 4
103369: PLUS
103370: ST_TO_ADDR
// max_y := y + r ;
103371: LD_ADDR_VAR 0 10
103375: PUSH
103376: LD_VAR 0 3
103380: PUSH
103381: LD_VAR 0 4
103385: PLUS
103386: ST_TO_ADDR
// for _x = min_x to max_x do
103387: LD_ADDR_VAR 0 11
103391: PUSH
103392: DOUBLE
103393: LD_VAR 0 7
103397: DEC
103398: ST_TO_ADDR
103399: LD_VAR 0 9
103403: PUSH
103404: FOR_TO
103405: IFFALSE 103522
// for _y = min_y to max_y do
103407: LD_ADDR_VAR 0 12
103411: PUSH
103412: DOUBLE
103413: LD_VAR 0 8
103417: DEC
103418: ST_TO_ADDR
103419: LD_VAR 0 10
103423: PUSH
103424: FOR_TO
103425: IFFALSE 103518
// begin if not ValidHex ( _x , _y ) then
103427: LD_VAR 0 11
103431: PPUSH
103432: LD_VAR 0 12
103436: PPUSH
103437: CALL_OW 488
103441: NOT
103442: IFFALSE 103446
// continue ;
103444: GO 103424
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
103446: LD_VAR 0 11
103450: PPUSH
103451: LD_VAR 0 12
103455: PPUSH
103456: CALL_OW 351
103460: PUSH
103461: LD_VAR 0 11
103465: PPUSH
103466: LD_VAR 0 12
103470: PPUSH
103471: CALL_OW 554
103475: AND
103476: IFFALSE 103516
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
103478: LD_ADDR_VAR 0 13
103482: PUSH
103483: LD_VAR 0 13
103487: PPUSH
103488: LD_VAR 0 13
103492: PUSH
103493: LD_INT 1
103495: PLUS
103496: PPUSH
103497: LD_VAR 0 11
103501: PUSH
103502: LD_VAR 0 12
103506: PUSH
103507: EMPTY
103508: LIST
103509: LIST
103510: PPUSH
103511: CALL_OW 2
103515: ST_TO_ADDR
// end ;
103516: GO 103424
103518: POP
103519: POP
103520: GO 103404
103522: POP
103523: POP
// if not list then
103524: LD_VAR 0 13
103528: NOT
103529: IFFALSE 103533
// exit ;
103531: GO 103604
// for i in list do
103533: LD_ADDR_VAR 0 6
103537: PUSH
103538: LD_VAR 0 13
103542: PUSH
103543: FOR_IN
103544: IFFALSE 103602
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
103546: LD_VAR 0 1
103550: PPUSH
103551: LD_STRING M
103553: PUSH
103554: LD_VAR 0 6
103558: PUSH
103559: LD_INT 1
103561: ARRAY
103562: PUSH
103563: LD_VAR 0 6
103567: PUSH
103568: LD_INT 2
103570: ARRAY
103571: PUSH
103572: LD_INT 0
103574: PUSH
103575: LD_INT 0
103577: PUSH
103578: LD_INT 0
103580: PUSH
103581: LD_INT 0
103583: PUSH
103584: EMPTY
103585: LIST
103586: LIST
103587: LIST
103588: LIST
103589: LIST
103590: LIST
103591: LIST
103592: PUSH
103593: EMPTY
103594: LIST
103595: PPUSH
103596: CALL_OW 447
103600: GO 103543
103602: POP
103603: POP
// end ;
103604: LD_VAR 0 5
103608: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
103609: LD_EXP 194
103613: NOT
103614: IFFALSE 103664
103616: GO 103618
103618: DISABLE
// begin initHack := true ;
103619: LD_ADDR_EXP 194
103623: PUSH
103624: LD_INT 1
103626: ST_TO_ADDR
// hackTanks := [ ] ;
103627: LD_ADDR_EXP 195
103631: PUSH
103632: EMPTY
103633: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
103634: LD_ADDR_EXP 196
103638: PUSH
103639: EMPTY
103640: ST_TO_ADDR
// hackLimit := 3 ;
103641: LD_ADDR_EXP 197
103645: PUSH
103646: LD_INT 3
103648: ST_TO_ADDR
// hackDist := 12 ;
103649: LD_ADDR_EXP 198
103653: PUSH
103654: LD_INT 12
103656: ST_TO_ADDR
// hackCounter := [ ] ;
103657: LD_ADDR_EXP 199
103661: PUSH
103662: EMPTY
103663: ST_TO_ADDR
// end ;
103664: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
103665: LD_EXP 194
103669: PUSH
103670: LD_INT 34
103672: PUSH
103673: LD_EXP 74
103677: PUSH
103678: EMPTY
103679: LIST
103680: LIST
103681: PPUSH
103682: CALL_OW 69
103686: AND
103687: IFFALSE 103942
103689: GO 103691
103691: DISABLE
103692: LD_INT 0
103694: PPUSH
103695: PPUSH
// begin enable ;
103696: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
103697: LD_ADDR_VAR 0 1
103701: PUSH
103702: LD_INT 34
103704: PUSH
103705: LD_EXP 74
103709: PUSH
103710: EMPTY
103711: LIST
103712: LIST
103713: PPUSH
103714: CALL_OW 69
103718: PUSH
103719: FOR_IN
103720: IFFALSE 103940
// begin if not i in hackTanks then
103722: LD_VAR 0 1
103726: PUSH
103727: LD_EXP 195
103731: IN
103732: NOT
103733: IFFALSE 103816
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
103735: LD_ADDR_EXP 195
103739: PUSH
103740: LD_EXP 195
103744: PPUSH
103745: LD_EXP 195
103749: PUSH
103750: LD_INT 1
103752: PLUS
103753: PPUSH
103754: LD_VAR 0 1
103758: PPUSH
103759: CALL_OW 1
103763: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
103764: LD_ADDR_EXP 196
103768: PUSH
103769: LD_EXP 196
103773: PPUSH
103774: LD_EXP 196
103778: PUSH
103779: LD_INT 1
103781: PLUS
103782: PPUSH
103783: EMPTY
103784: PPUSH
103785: CALL_OW 1
103789: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
103790: LD_ADDR_EXP 199
103794: PUSH
103795: LD_EXP 199
103799: PPUSH
103800: LD_EXP 199
103804: PUSH
103805: LD_INT 1
103807: PLUS
103808: PPUSH
103809: EMPTY
103810: PPUSH
103811: CALL_OW 1
103815: ST_TO_ADDR
// end ; if not IsOk ( i ) then
103816: LD_VAR 0 1
103820: PPUSH
103821: CALL_OW 302
103825: NOT
103826: IFFALSE 103839
// begin HackUnlinkAll ( i ) ;
103828: LD_VAR 0 1
103832: PPUSH
103833: CALL 103945 0 1
// continue ;
103837: GO 103719
// end ; HackCheckCapturedStatus ( i ) ;
103839: LD_VAR 0 1
103843: PPUSH
103844: CALL 104388 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
103848: LD_ADDR_VAR 0 2
103852: PUSH
103853: LD_INT 81
103855: PUSH
103856: LD_VAR 0 1
103860: PPUSH
103861: CALL_OW 255
103865: PUSH
103866: EMPTY
103867: LIST
103868: LIST
103869: PUSH
103870: LD_INT 33
103872: PUSH
103873: LD_INT 3
103875: PUSH
103876: EMPTY
103877: LIST
103878: LIST
103879: PUSH
103880: LD_INT 91
103882: PUSH
103883: LD_VAR 0 1
103887: PUSH
103888: LD_EXP 198
103892: PUSH
103893: EMPTY
103894: LIST
103895: LIST
103896: LIST
103897: PUSH
103898: LD_INT 50
103900: PUSH
103901: EMPTY
103902: LIST
103903: PUSH
103904: EMPTY
103905: LIST
103906: LIST
103907: LIST
103908: LIST
103909: PPUSH
103910: CALL_OW 69
103914: ST_TO_ADDR
// if not tmp then
103915: LD_VAR 0 2
103919: NOT
103920: IFFALSE 103924
// continue ;
103922: GO 103719
// HackLink ( i , tmp ) ;
103924: LD_VAR 0 1
103928: PPUSH
103929: LD_VAR 0 2
103933: PPUSH
103934: CALL 104081 0 2
// end ;
103938: GO 103719
103940: POP
103941: POP
// end ;
103942: PPOPN 2
103944: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
103945: LD_INT 0
103947: PPUSH
103948: PPUSH
103949: PPUSH
// if not hack in hackTanks then
103950: LD_VAR 0 1
103954: PUSH
103955: LD_EXP 195
103959: IN
103960: NOT
103961: IFFALSE 103965
// exit ;
103963: GO 104076
// index := GetElementIndex ( hackTanks , hack ) ;
103965: LD_ADDR_VAR 0 4
103969: PUSH
103970: LD_EXP 195
103974: PPUSH
103975: LD_VAR 0 1
103979: PPUSH
103980: CALL 55889 0 2
103984: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
103985: LD_EXP 196
103989: PUSH
103990: LD_VAR 0 4
103994: ARRAY
103995: IFFALSE 104076
// begin for i in hackTanksCaptured [ index ] do
103997: LD_ADDR_VAR 0 3
104001: PUSH
104002: LD_EXP 196
104006: PUSH
104007: LD_VAR 0 4
104011: ARRAY
104012: PUSH
104013: FOR_IN
104014: IFFALSE 104040
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
104016: LD_VAR 0 3
104020: PUSH
104021: LD_INT 1
104023: ARRAY
104024: PPUSH
104025: LD_VAR 0 3
104029: PUSH
104030: LD_INT 2
104032: ARRAY
104033: PPUSH
104034: CALL_OW 235
104038: GO 104013
104040: POP
104041: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
104042: LD_ADDR_EXP 196
104046: PUSH
104047: LD_EXP 196
104051: PPUSH
104052: LD_VAR 0 4
104056: PPUSH
104057: EMPTY
104058: PPUSH
104059: CALL_OW 1
104063: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
104064: LD_VAR 0 1
104068: PPUSH
104069: LD_INT 0
104071: PPUSH
104072: CALL_OW 505
// end ; end ;
104076: LD_VAR 0 2
104080: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
104081: LD_INT 0
104083: PPUSH
104084: PPUSH
104085: PPUSH
// if not hack in hackTanks or not vehicles then
104086: LD_VAR 0 1
104090: PUSH
104091: LD_EXP 195
104095: IN
104096: NOT
104097: PUSH
104098: LD_VAR 0 2
104102: NOT
104103: OR
104104: IFFALSE 104108
// exit ;
104106: GO 104383
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
104108: LD_ADDR_VAR 0 2
104112: PUSH
104113: LD_VAR 0 1
104117: PPUSH
104118: LD_VAR 0 2
104122: PPUSH
104123: LD_INT 1
104125: PPUSH
104126: LD_INT 1
104128: PPUSH
104129: CALL 56539 0 4
104133: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
104134: LD_ADDR_VAR 0 5
104138: PUSH
104139: LD_EXP 195
104143: PPUSH
104144: LD_VAR 0 1
104148: PPUSH
104149: CALL 55889 0 2
104153: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
104154: LD_EXP 196
104158: PUSH
104159: LD_VAR 0 5
104163: ARRAY
104164: PUSH
104165: LD_EXP 197
104169: LESS
104170: IFFALSE 104359
// begin for i := 1 to vehicles do
104172: LD_ADDR_VAR 0 4
104176: PUSH
104177: DOUBLE
104178: LD_INT 1
104180: DEC
104181: ST_TO_ADDR
104182: LD_VAR 0 2
104186: PUSH
104187: FOR_TO
104188: IFFALSE 104357
// begin if hackTanksCaptured [ index ] = hackLimit then
104190: LD_EXP 196
104194: PUSH
104195: LD_VAR 0 5
104199: ARRAY
104200: PUSH
104201: LD_EXP 197
104205: EQUAL
104206: IFFALSE 104210
// break ;
104208: GO 104357
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
104210: LD_ADDR_EXP 199
104214: PUSH
104215: LD_EXP 199
104219: PPUSH
104220: LD_VAR 0 5
104224: PPUSH
104225: LD_EXP 199
104229: PUSH
104230: LD_VAR 0 5
104234: ARRAY
104235: PUSH
104236: LD_INT 1
104238: PLUS
104239: PPUSH
104240: CALL_OW 1
104244: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
104245: LD_ADDR_EXP 196
104249: PUSH
104250: LD_EXP 196
104254: PPUSH
104255: LD_VAR 0 5
104259: PUSH
104260: LD_EXP 196
104264: PUSH
104265: LD_VAR 0 5
104269: ARRAY
104270: PUSH
104271: LD_INT 1
104273: PLUS
104274: PUSH
104275: EMPTY
104276: LIST
104277: LIST
104278: PPUSH
104279: LD_VAR 0 2
104283: PUSH
104284: LD_VAR 0 4
104288: ARRAY
104289: PUSH
104290: LD_VAR 0 2
104294: PUSH
104295: LD_VAR 0 4
104299: ARRAY
104300: PPUSH
104301: CALL_OW 255
104305: PUSH
104306: EMPTY
104307: LIST
104308: LIST
104309: PPUSH
104310: CALL 56104 0 3
104314: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
104315: LD_VAR 0 2
104319: PUSH
104320: LD_VAR 0 4
104324: ARRAY
104325: PPUSH
104326: LD_VAR 0 1
104330: PPUSH
104331: CALL_OW 255
104335: PPUSH
104336: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
104340: LD_VAR 0 2
104344: PUSH
104345: LD_VAR 0 4
104349: ARRAY
104350: PPUSH
104351: CALL_OW 141
// end ;
104355: GO 104187
104357: POP
104358: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104359: LD_VAR 0 1
104363: PPUSH
104364: LD_EXP 196
104368: PUSH
104369: LD_VAR 0 5
104373: ARRAY
104374: PUSH
104375: LD_INT 0
104377: PLUS
104378: PPUSH
104379: CALL_OW 505
// end ;
104383: LD_VAR 0 3
104387: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
104388: LD_INT 0
104390: PPUSH
104391: PPUSH
104392: PPUSH
104393: PPUSH
// if not hack in hackTanks then
104394: LD_VAR 0 1
104398: PUSH
104399: LD_EXP 195
104403: IN
104404: NOT
104405: IFFALSE 104409
// exit ;
104407: GO 104649
// index := GetElementIndex ( hackTanks , hack ) ;
104409: LD_ADDR_VAR 0 4
104413: PUSH
104414: LD_EXP 195
104418: PPUSH
104419: LD_VAR 0 1
104423: PPUSH
104424: CALL 55889 0 2
104428: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
104429: LD_ADDR_VAR 0 3
104433: PUSH
104434: DOUBLE
104435: LD_EXP 196
104439: PUSH
104440: LD_VAR 0 4
104444: ARRAY
104445: INC
104446: ST_TO_ADDR
104447: LD_INT 1
104449: PUSH
104450: FOR_DOWNTO
104451: IFFALSE 104623
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
104453: LD_ADDR_VAR 0 5
104457: PUSH
104458: LD_EXP 196
104462: PUSH
104463: LD_VAR 0 4
104467: ARRAY
104468: PUSH
104469: LD_VAR 0 3
104473: ARRAY
104474: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
104475: LD_VAR 0 5
104479: PUSH
104480: LD_INT 1
104482: ARRAY
104483: PPUSH
104484: CALL_OW 302
104488: NOT
104489: PUSH
104490: LD_VAR 0 5
104494: PUSH
104495: LD_INT 1
104497: ARRAY
104498: PPUSH
104499: CALL_OW 255
104503: PUSH
104504: LD_VAR 0 1
104508: PPUSH
104509: CALL_OW 255
104513: NONEQUAL
104514: OR
104515: IFFALSE 104621
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
104517: LD_VAR 0 5
104521: PUSH
104522: LD_INT 1
104524: ARRAY
104525: PPUSH
104526: CALL_OW 305
104530: PUSH
104531: LD_VAR 0 5
104535: PUSH
104536: LD_INT 1
104538: ARRAY
104539: PPUSH
104540: CALL_OW 255
104544: PUSH
104545: LD_VAR 0 1
104549: PPUSH
104550: CALL_OW 255
104554: EQUAL
104555: AND
104556: IFFALSE 104580
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
104558: LD_VAR 0 5
104562: PUSH
104563: LD_INT 1
104565: ARRAY
104566: PPUSH
104567: LD_VAR 0 5
104571: PUSH
104572: LD_INT 2
104574: ARRAY
104575: PPUSH
104576: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
104580: LD_ADDR_EXP 196
104584: PUSH
104585: LD_EXP 196
104589: PPUSH
104590: LD_VAR 0 4
104594: PPUSH
104595: LD_EXP 196
104599: PUSH
104600: LD_VAR 0 4
104604: ARRAY
104605: PPUSH
104606: LD_VAR 0 3
104610: PPUSH
104611: CALL_OW 3
104615: PPUSH
104616: CALL_OW 1
104620: ST_TO_ADDR
// end ; end ;
104621: GO 104450
104623: POP
104624: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104625: LD_VAR 0 1
104629: PPUSH
104630: LD_EXP 196
104634: PUSH
104635: LD_VAR 0 4
104639: ARRAY
104640: PUSH
104641: LD_INT 0
104643: PLUS
104644: PPUSH
104645: CALL_OW 505
// end ;
104649: LD_VAR 0 2
104653: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
104654: LD_INT 0
104656: PPUSH
104657: PPUSH
104658: PPUSH
104659: PPUSH
// if not hack in hackTanks then
104660: LD_VAR 0 1
104664: PUSH
104665: LD_EXP 195
104669: IN
104670: NOT
104671: IFFALSE 104675
// exit ;
104673: GO 104760
// index := GetElementIndex ( hackTanks , hack ) ;
104675: LD_ADDR_VAR 0 5
104679: PUSH
104680: LD_EXP 195
104684: PPUSH
104685: LD_VAR 0 1
104689: PPUSH
104690: CALL 55889 0 2
104694: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
104695: LD_ADDR_VAR 0 4
104699: PUSH
104700: DOUBLE
104701: LD_INT 1
104703: DEC
104704: ST_TO_ADDR
104705: LD_EXP 196
104709: PUSH
104710: LD_VAR 0 5
104714: ARRAY
104715: PUSH
104716: FOR_TO
104717: IFFALSE 104758
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
104719: LD_EXP 196
104723: PUSH
104724: LD_VAR 0 5
104728: ARRAY
104729: PUSH
104730: LD_VAR 0 4
104734: ARRAY
104735: PUSH
104736: LD_INT 1
104738: ARRAY
104739: PUSH
104740: LD_VAR 0 2
104744: EQUAL
104745: IFFALSE 104756
// KillUnit ( vehicle ) ;
104747: LD_VAR 0 2
104751: PPUSH
104752: CALL_OW 66
104756: GO 104716
104758: POP
104759: POP
// end ;
104760: LD_VAR 0 3
104764: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
104765: LD_EXP 200
104769: NOT
104770: IFFALSE 104805
104772: GO 104774
104774: DISABLE
// begin initMiner := true ;
104775: LD_ADDR_EXP 200
104779: PUSH
104780: LD_INT 1
104782: ST_TO_ADDR
// minersList := [ ] ;
104783: LD_ADDR_EXP 201
104787: PUSH
104788: EMPTY
104789: ST_TO_ADDR
// minerMinesList := [ ] ;
104790: LD_ADDR_EXP 202
104794: PUSH
104795: EMPTY
104796: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
104797: LD_ADDR_EXP 203
104801: PUSH
104802: LD_INT 5
104804: ST_TO_ADDR
// end ;
104805: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
104806: LD_EXP 200
104810: PUSH
104811: LD_INT 34
104813: PUSH
104814: LD_EXP 79
104818: PUSH
104819: EMPTY
104820: LIST
104821: LIST
104822: PPUSH
104823: CALL_OW 69
104827: AND
104828: IFFALSE 105291
104830: GO 104832
104832: DISABLE
104833: LD_INT 0
104835: PPUSH
104836: PPUSH
104837: PPUSH
104838: PPUSH
// begin enable ;
104839: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
104840: LD_ADDR_VAR 0 1
104844: PUSH
104845: LD_INT 34
104847: PUSH
104848: LD_EXP 79
104852: PUSH
104853: EMPTY
104854: LIST
104855: LIST
104856: PPUSH
104857: CALL_OW 69
104861: PUSH
104862: FOR_IN
104863: IFFALSE 104935
// begin if not i in minersList then
104865: LD_VAR 0 1
104869: PUSH
104870: LD_EXP 201
104874: IN
104875: NOT
104876: IFFALSE 104933
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
104878: LD_ADDR_EXP 201
104882: PUSH
104883: LD_EXP 201
104887: PPUSH
104888: LD_EXP 201
104892: PUSH
104893: LD_INT 1
104895: PLUS
104896: PPUSH
104897: LD_VAR 0 1
104901: PPUSH
104902: CALL_OW 1
104906: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
104907: LD_ADDR_EXP 202
104911: PUSH
104912: LD_EXP 202
104916: PPUSH
104917: LD_EXP 202
104921: PUSH
104922: LD_INT 1
104924: PLUS
104925: PPUSH
104926: EMPTY
104927: PPUSH
104928: CALL_OW 1
104932: ST_TO_ADDR
// end end ;
104933: GO 104862
104935: POP
104936: POP
// for i := minerMinesList downto 1 do
104937: LD_ADDR_VAR 0 1
104941: PUSH
104942: DOUBLE
104943: LD_EXP 202
104947: INC
104948: ST_TO_ADDR
104949: LD_INT 1
104951: PUSH
104952: FOR_DOWNTO
104953: IFFALSE 105289
// begin if IsLive ( minersList [ i ] ) then
104955: LD_EXP 201
104959: PUSH
104960: LD_VAR 0 1
104964: ARRAY
104965: PPUSH
104966: CALL_OW 300
104970: IFFALSE 104998
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
104972: LD_EXP 201
104976: PUSH
104977: LD_VAR 0 1
104981: ARRAY
104982: PPUSH
104983: LD_EXP 202
104987: PUSH
104988: LD_VAR 0 1
104992: ARRAY
104993: PPUSH
104994: CALL_OW 505
// if not minerMinesList [ i ] then
104998: LD_EXP 202
105002: PUSH
105003: LD_VAR 0 1
105007: ARRAY
105008: NOT
105009: IFFALSE 105013
// continue ;
105011: GO 104952
// for j := minerMinesList [ i ] downto 1 do
105013: LD_ADDR_VAR 0 2
105017: PUSH
105018: DOUBLE
105019: LD_EXP 202
105023: PUSH
105024: LD_VAR 0 1
105028: ARRAY
105029: INC
105030: ST_TO_ADDR
105031: LD_INT 1
105033: PUSH
105034: FOR_DOWNTO
105035: IFFALSE 105285
// begin side := GetSide ( minersList [ i ] ) ;
105037: LD_ADDR_VAR 0 3
105041: PUSH
105042: LD_EXP 201
105046: PUSH
105047: LD_VAR 0 1
105051: ARRAY
105052: PPUSH
105053: CALL_OW 255
105057: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
105058: LD_ADDR_VAR 0 4
105062: PUSH
105063: LD_EXP 202
105067: PUSH
105068: LD_VAR 0 1
105072: ARRAY
105073: PUSH
105074: LD_VAR 0 2
105078: ARRAY
105079: PUSH
105080: LD_INT 1
105082: ARRAY
105083: PPUSH
105084: LD_EXP 202
105088: PUSH
105089: LD_VAR 0 1
105093: ARRAY
105094: PUSH
105095: LD_VAR 0 2
105099: ARRAY
105100: PUSH
105101: LD_INT 2
105103: ARRAY
105104: PPUSH
105105: CALL_OW 428
105109: ST_TO_ADDR
// if not tmp then
105110: LD_VAR 0 4
105114: NOT
105115: IFFALSE 105119
// continue ;
105117: GO 105034
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
105119: LD_VAR 0 4
105123: PUSH
105124: LD_INT 81
105126: PUSH
105127: LD_VAR 0 3
105131: PUSH
105132: EMPTY
105133: LIST
105134: LIST
105135: PPUSH
105136: CALL_OW 69
105140: IN
105141: PUSH
105142: LD_EXP 202
105146: PUSH
105147: LD_VAR 0 1
105151: ARRAY
105152: PUSH
105153: LD_VAR 0 2
105157: ARRAY
105158: PUSH
105159: LD_INT 1
105161: ARRAY
105162: PPUSH
105163: LD_EXP 202
105167: PUSH
105168: LD_VAR 0 1
105172: ARRAY
105173: PUSH
105174: LD_VAR 0 2
105178: ARRAY
105179: PUSH
105180: LD_INT 2
105182: ARRAY
105183: PPUSH
105184: CALL_OW 458
105188: AND
105189: IFFALSE 105283
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
105191: LD_EXP 202
105195: PUSH
105196: LD_VAR 0 1
105200: ARRAY
105201: PUSH
105202: LD_VAR 0 2
105206: ARRAY
105207: PUSH
105208: LD_INT 1
105210: ARRAY
105211: PPUSH
105212: LD_EXP 202
105216: PUSH
105217: LD_VAR 0 1
105221: ARRAY
105222: PUSH
105223: LD_VAR 0 2
105227: ARRAY
105228: PUSH
105229: LD_INT 2
105231: ARRAY
105232: PPUSH
105233: LD_VAR 0 3
105237: PPUSH
105238: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
105242: LD_ADDR_EXP 202
105246: PUSH
105247: LD_EXP 202
105251: PPUSH
105252: LD_VAR 0 1
105256: PPUSH
105257: LD_EXP 202
105261: PUSH
105262: LD_VAR 0 1
105266: ARRAY
105267: PPUSH
105268: LD_VAR 0 2
105272: PPUSH
105273: CALL_OW 3
105277: PPUSH
105278: CALL_OW 1
105282: ST_TO_ADDR
// end ; end ;
105283: GO 105034
105285: POP
105286: POP
// end ;
105287: GO 104952
105289: POP
105290: POP
// end ;
105291: PPOPN 4
105293: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
105294: LD_INT 0
105296: PPUSH
105297: PPUSH
// result := false ;
105298: LD_ADDR_VAR 0 4
105302: PUSH
105303: LD_INT 0
105305: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
105306: LD_VAR 0 1
105310: PPUSH
105311: CALL_OW 264
105315: PUSH
105316: LD_EXP 79
105320: EQUAL
105321: NOT
105322: IFFALSE 105326
// exit ;
105324: GO 105566
// index := GetElementIndex ( minersList , unit ) ;
105326: LD_ADDR_VAR 0 5
105330: PUSH
105331: LD_EXP 201
105335: PPUSH
105336: LD_VAR 0 1
105340: PPUSH
105341: CALL 55889 0 2
105345: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
105346: LD_EXP 202
105350: PUSH
105351: LD_VAR 0 5
105355: ARRAY
105356: PUSH
105357: LD_EXP 203
105361: GREATEREQUAL
105362: IFFALSE 105366
// exit ;
105364: GO 105566
// ComMoveXY ( unit , x , y ) ;
105366: LD_VAR 0 1
105370: PPUSH
105371: LD_VAR 0 2
105375: PPUSH
105376: LD_VAR 0 3
105380: PPUSH
105381: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105385: LD_INT 35
105387: PPUSH
105388: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
105392: LD_VAR 0 1
105396: PPUSH
105397: LD_VAR 0 2
105401: PPUSH
105402: LD_VAR 0 3
105406: PPUSH
105407: CALL 86662 0 3
105411: NOT
105412: PUSH
105413: LD_VAR 0 1
105417: PPUSH
105418: CALL_OW 314
105422: AND
105423: IFFALSE 105427
// exit ;
105425: GO 105566
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
105427: LD_VAR 0 2
105431: PPUSH
105432: LD_VAR 0 3
105436: PPUSH
105437: CALL_OW 428
105441: PUSH
105442: LD_VAR 0 1
105446: EQUAL
105447: PUSH
105448: LD_VAR 0 1
105452: PPUSH
105453: CALL_OW 314
105457: NOT
105458: AND
105459: IFFALSE 105385
// PlaySoundXY ( x , y , PlantMine ) ;
105461: LD_VAR 0 2
105465: PPUSH
105466: LD_VAR 0 3
105470: PPUSH
105471: LD_STRING PlantMine
105473: PPUSH
105474: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
105478: LD_VAR 0 2
105482: PPUSH
105483: LD_VAR 0 3
105487: PPUSH
105488: LD_VAR 0 1
105492: PPUSH
105493: CALL_OW 255
105497: PPUSH
105498: LD_INT 0
105500: PPUSH
105501: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
105505: LD_ADDR_EXP 202
105509: PUSH
105510: LD_EXP 202
105514: PPUSH
105515: LD_VAR 0 5
105519: PUSH
105520: LD_EXP 202
105524: PUSH
105525: LD_VAR 0 5
105529: ARRAY
105530: PUSH
105531: LD_INT 1
105533: PLUS
105534: PUSH
105535: EMPTY
105536: LIST
105537: LIST
105538: PPUSH
105539: LD_VAR 0 2
105543: PUSH
105544: LD_VAR 0 3
105548: PUSH
105549: EMPTY
105550: LIST
105551: LIST
105552: PPUSH
105553: CALL 56104 0 3
105557: ST_TO_ADDR
// result := true ;
105558: LD_ADDR_VAR 0 4
105562: PUSH
105563: LD_INT 1
105565: ST_TO_ADDR
// end ;
105566: LD_VAR 0 4
105570: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
105571: LD_INT 0
105573: PPUSH
105574: PPUSH
105575: PPUSH
// if not unit in minersList then
105576: LD_VAR 0 1
105580: PUSH
105581: LD_EXP 201
105585: IN
105586: NOT
105587: IFFALSE 105591
// exit ;
105589: GO 105983
// index := GetElementIndex ( minersList , unit ) ;
105591: LD_ADDR_VAR 0 6
105595: PUSH
105596: LD_EXP 201
105600: PPUSH
105601: LD_VAR 0 1
105605: PPUSH
105606: CALL 55889 0 2
105610: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
105611: LD_ADDR_VAR 0 5
105615: PUSH
105616: DOUBLE
105617: LD_EXP 202
105621: PUSH
105622: LD_VAR 0 6
105626: ARRAY
105627: INC
105628: ST_TO_ADDR
105629: LD_INT 1
105631: PUSH
105632: FOR_DOWNTO
105633: IFFALSE 105794
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
105635: LD_EXP 202
105639: PUSH
105640: LD_VAR 0 6
105644: ARRAY
105645: PUSH
105646: LD_VAR 0 5
105650: ARRAY
105651: PUSH
105652: LD_INT 1
105654: ARRAY
105655: PUSH
105656: LD_VAR 0 2
105660: EQUAL
105661: PUSH
105662: LD_EXP 202
105666: PUSH
105667: LD_VAR 0 6
105671: ARRAY
105672: PUSH
105673: LD_VAR 0 5
105677: ARRAY
105678: PUSH
105679: LD_INT 2
105681: ARRAY
105682: PUSH
105683: LD_VAR 0 3
105687: EQUAL
105688: AND
105689: IFFALSE 105792
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
105691: LD_EXP 202
105695: PUSH
105696: LD_VAR 0 6
105700: ARRAY
105701: PUSH
105702: LD_VAR 0 5
105706: ARRAY
105707: PUSH
105708: LD_INT 1
105710: ARRAY
105711: PPUSH
105712: LD_EXP 202
105716: PUSH
105717: LD_VAR 0 6
105721: ARRAY
105722: PUSH
105723: LD_VAR 0 5
105727: ARRAY
105728: PUSH
105729: LD_INT 2
105731: ARRAY
105732: PPUSH
105733: LD_VAR 0 1
105737: PPUSH
105738: CALL_OW 255
105742: PPUSH
105743: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105747: LD_ADDR_EXP 202
105751: PUSH
105752: LD_EXP 202
105756: PPUSH
105757: LD_VAR 0 6
105761: PPUSH
105762: LD_EXP 202
105766: PUSH
105767: LD_VAR 0 6
105771: ARRAY
105772: PPUSH
105773: LD_VAR 0 5
105777: PPUSH
105778: CALL_OW 3
105782: PPUSH
105783: CALL_OW 1
105787: ST_TO_ADDR
// exit ;
105788: POP
105789: POP
105790: GO 105983
// end ; end ;
105792: GO 105632
105794: POP
105795: POP
// for i := minerMinesList [ index ] downto 1 do
105796: LD_ADDR_VAR 0 5
105800: PUSH
105801: DOUBLE
105802: LD_EXP 202
105806: PUSH
105807: LD_VAR 0 6
105811: ARRAY
105812: INC
105813: ST_TO_ADDR
105814: LD_INT 1
105816: PUSH
105817: FOR_DOWNTO
105818: IFFALSE 105981
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
105820: LD_EXP 202
105824: PUSH
105825: LD_VAR 0 6
105829: ARRAY
105830: PUSH
105831: LD_VAR 0 5
105835: ARRAY
105836: PUSH
105837: LD_INT 1
105839: ARRAY
105840: PPUSH
105841: LD_EXP 202
105845: PUSH
105846: LD_VAR 0 6
105850: ARRAY
105851: PUSH
105852: LD_VAR 0 5
105856: ARRAY
105857: PUSH
105858: LD_INT 2
105860: ARRAY
105861: PPUSH
105862: LD_VAR 0 2
105866: PPUSH
105867: LD_VAR 0 3
105871: PPUSH
105872: CALL_OW 298
105876: PUSH
105877: LD_INT 6
105879: LESS
105880: IFFALSE 105979
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
105882: LD_EXP 202
105886: PUSH
105887: LD_VAR 0 6
105891: ARRAY
105892: PUSH
105893: LD_VAR 0 5
105897: ARRAY
105898: PUSH
105899: LD_INT 1
105901: ARRAY
105902: PPUSH
105903: LD_EXP 202
105907: PUSH
105908: LD_VAR 0 6
105912: ARRAY
105913: PUSH
105914: LD_VAR 0 5
105918: ARRAY
105919: PUSH
105920: LD_INT 2
105922: ARRAY
105923: PPUSH
105924: LD_VAR 0 1
105928: PPUSH
105929: CALL_OW 255
105933: PPUSH
105934: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105938: LD_ADDR_EXP 202
105942: PUSH
105943: LD_EXP 202
105947: PPUSH
105948: LD_VAR 0 6
105952: PPUSH
105953: LD_EXP 202
105957: PUSH
105958: LD_VAR 0 6
105962: ARRAY
105963: PPUSH
105964: LD_VAR 0 5
105968: PPUSH
105969: CALL_OW 3
105973: PPUSH
105974: CALL_OW 1
105978: ST_TO_ADDR
// end ; end ;
105979: GO 105817
105981: POP
105982: POP
// end ;
105983: LD_VAR 0 4
105987: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
105988: LD_INT 0
105990: PPUSH
105991: PPUSH
105992: PPUSH
105993: PPUSH
105994: PPUSH
105995: PPUSH
105996: PPUSH
105997: PPUSH
105998: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
105999: LD_VAR 0 1
106003: PPUSH
106004: CALL_OW 264
106008: PUSH
106009: LD_EXP 79
106013: EQUAL
106014: NOT
106015: PUSH
106016: LD_VAR 0 1
106020: PUSH
106021: LD_EXP 201
106025: IN
106026: NOT
106027: OR
106028: IFFALSE 106032
// exit ;
106030: GO 106354
// index := GetElementIndex ( minersList , unit ) ;
106032: LD_ADDR_VAR 0 6
106036: PUSH
106037: LD_EXP 201
106041: PPUSH
106042: LD_VAR 0 1
106046: PPUSH
106047: CALL 55889 0 2
106051: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
106052: LD_ADDR_VAR 0 8
106056: PUSH
106057: LD_EXP 203
106061: PUSH
106062: LD_EXP 202
106066: PUSH
106067: LD_VAR 0 6
106071: ARRAY
106072: MINUS
106073: ST_TO_ADDR
// if not minesFreeAmount then
106074: LD_VAR 0 8
106078: NOT
106079: IFFALSE 106083
// exit ;
106081: GO 106354
// tmp := [ ] ;
106083: LD_ADDR_VAR 0 7
106087: PUSH
106088: EMPTY
106089: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
106090: LD_ADDR_VAR 0 5
106094: PUSH
106095: DOUBLE
106096: LD_INT 1
106098: DEC
106099: ST_TO_ADDR
106100: LD_VAR 0 8
106104: PUSH
106105: FOR_TO
106106: IFFALSE 106301
// begin _d := rand ( 0 , 5 ) ;
106108: LD_ADDR_VAR 0 11
106112: PUSH
106113: LD_INT 0
106115: PPUSH
106116: LD_INT 5
106118: PPUSH
106119: CALL_OW 12
106123: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
106124: LD_ADDR_VAR 0 12
106128: PUSH
106129: LD_INT 2
106131: PPUSH
106132: LD_INT 6
106134: PPUSH
106135: CALL_OW 12
106139: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
106140: LD_ADDR_VAR 0 9
106144: PUSH
106145: LD_VAR 0 2
106149: PPUSH
106150: LD_VAR 0 11
106154: PPUSH
106155: LD_VAR 0 12
106159: PPUSH
106160: CALL_OW 272
106164: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
106165: LD_ADDR_VAR 0 10
106169: PUSH
106170: LD_VAR 0 3
106174: PPUSH
106175: LD_VAR 0 11
106179: PPUSH
106180: LD_VAR 0 12
106184: PPUSH
106185: CALL_OW 273
106189: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
106190: LD_VAR 0 9
106194: PPUSH
106195: LD_VAR 0 10
106199: PPUSH
106200: CALL_OW 488
106204: PUSH
106205: LD_VAR 0 9
106209: PUSH
106210: LD_VAR 0 10
106214: PUSH
106215: EMPTY
106216: LIST
106217: LIST
106218: PUSH
106219: LD_VAR 0 7
106223: IN
106224: NOT
106225: AND
106226: PUSH
106227: LD_VAR 0 9
106231: PPUSH
106232: LD_VAR 0 10
106236: PPUSH
106237: CALL_OW 458
106241: NOT
106242: AND
106243: IFFALSE 106285
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
106245: LD_ADDR_VAR 0 7
106249: PUSH
106250: LD_VAR 0 7
106254: PPUSH
106255: LD_VAR 0 7
106259: PUSH
106260: LD_INT 1
106262: PLUS
106263: PPUSH
106264: LD_VAR 0 9
106268: PUSH
106269: LD_VAR 0 10
106273: PUSH
106274: EMPTY
106275: LIST
106276: LIST
106277: PPUSH
106278: CALL_OW 1
106282: ST_TO_ADDR
106283: GO 106299
// i := i - 1 ;
106285: LD_ADDR_VAR 0 5
106289: PUSH
106290: LD_VAR 0 5
106294: PUSH
106295: LD_INT 1
106297: MINUS
106298: ST_TO_ADDR
// end ;
106299: GO 106105
106301: POP
106302: POP
// for i in tmp do
106303: LD_ADDR_VAR 0 5
106307: PUSH
106308: LD_VAR 0 7
106312: PUSH
106313: FOR_IN
106314: IFFALSE 106352
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
106316: LD_VAR 0 1
106320: PPUSH
106321: LD_VAR 0 5
106325: PUSH
106326: LD_INT 1
106328: ARRAY
106329: PPUSH
106330: LD_VAR 0 5
106334: PUSH
106335: LD_INT 2
106337: ARRAY
106338: PPUSH
106339: CALL 105294 0 3
106343: NOT
106344: IFFALSE 106350
// exit ;
106346: POP
106347: POP
106348: GO 106354
106350: GO 106313
106352: POP
106353: POP
// end ;
106354: LD_VAR 0 4
106358: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
106359: LD_INT 0
106361: PPUSH
106362: PPUSH
106363: PPUSH
106364: PPUSH
106365: PPUSH
106366: PPUSH
106367: PPUSH
// if not GetClass ( unit ) = class_sniper then
106368: LD_VAR 0 1
106372: PPUSH
106373: CALL_OW 257
106377: PUSH
106378: LD_INT 5
106380: EQUAL
106381: NOT
106382: IFFALSE 106386
// exit ;
106384: GO 106774
// dist := 8 ;
106386: LD_ADDR_VAR 0 5
106390: PUSH
106391: LD_INT 8
106393: ST_TO_ADDR
// viewRange := 12 ;
106394: LD_ADDR_VAR 0 7
106398: PUSH
106399: LD_INT 12
106401: ST_TO_ADDR
// side := GetSide ( unit ) ;
106402: LD_ADDR_VAR 0 6
106406: PUSH
106407: LD_VAR 0 1
106411: PPUSH
106412: CALL_OW 255
106416: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
106417: LD_INT 61
106419: PPUSH
106420: LD_VAR 0 6
106424: PPUSH
106425: CALL_OW 321
106429: PUSH
106430: LD_INT 2
106432: EQUAL
106433: IFFALSE 106443
// viewRange := 16 ;
106435: LD_ADDR_VAR 0 7
106439: PUSH
106440: LD_INT 16
106442: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
106443: LD_VAR 0 1
106447: PPUSH
106448: LD_VAR 0 2
106452: PPUSH
106453: LD_VAR 0 3
106457: PPUSH
106458: CALL_OW 297
106462: PUSH
106463: LD_VAR 0 5
106467: GREATER
106468: IFFALSE 106547
// begin ComMoveXY ( unit , x , y ) ;
106470: LD_VAR 0 1
106474: PPUSH
106475: LD_VAR 0 2
106479: PPUSH
106480: LD_VAR 0 3
106484: PPUSH
106485: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106489: LD_INT 35
106491: PPUSH
106492: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
106496: LD_VAR 0 1
106500: PPUSH
106501: LD_VAR 0 2
106505: PPUSH
106506: LD_VAR 0 3
106510: PPUSH
106511: CALL 86662 0 3
106515: NOT
106516: IFFALSE 106520
// exit ;
106518: GO 106774
// until GetDistUnitXY ( unit , x , y ) < dist ;
106520: LD_VAR 0 1
106524: PPUSH
106525: LD_VAR 0 2
106529: PPUSH
106530: LD_VAR 0 3
106534: PPUSH
106535: CALL_OW 297
106539: PUSH
106540: LD_VAR 0 5
106544: LESS
106545: IFFALSE 106489
// end ; ComTurnXY ( unit , x , y ) ;
106547: LD_VAR 0 1
106551: PPUSH
106552: LD_VAR 0 2
106556: PPUSH
106557: LD_VAR 0 3
106561: PPUSH
106562: CALL_OW 118
// wait ( 5 ) ;
106566: LD_INT 5
106568: PPUSH
106569: CALL_OW 67
// _d := GetDir ( unit ) ;
106573: LD_ADDR_VAR 0 10
106577: PUSH
106578: LD_VAR 0 1
106582: PPUSH
106583: CALL_OW 254
106587: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
106588: LD_ADDR_VAR 0 8
106592: PUSH
106593: LD_VAR 0 1
106597: PPUSH
106598: CALL_OW 250
106602: PPUSH
106603: LD_VAR 0 10
106607: PPUSH
106608: LD_VAR 0 5
106612: PPUSH
106613: CALL_OW 272
106617: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
106618: LD_ADDR_VAR 0 9
106622: PUSH
106623: LD_VAR 0 1
106627: PPUSH
106628: CALL_OW 251
106632: PPUSH
106633: LD_VAR 0 10
106637: PPUSH
106638: LD_VAR 0 5
106642: PPUSH
106643: CALL_OW 273
106647: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106648: LD_VAR 0 8
106652: PPUSH
106653: LD_VAR 0 9
106657: PPUSH
106658: CALL_OW 488
106662: NOT
106663: IFFALSE 106667
// exit ;
106665: GO 106774
// ComAnimCustom ( unit , 1 ) ;
106667: LD_VAR 0 1
106671: PPUSH
106672: LD_INT 1
106674: PPUSH
106675: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
106679: LD_VAR 0 8
106683: PPUSH
106684: LD_VAR 0 9
106688: PPUSH
106689: LD_VAR 0 6
106693: PPUSH
106694: LD_VAR 0 7
106698: PPUSH
106699: CALL_OW 330
// repeat wait ( 1 ) ;
106703: LD_INT 1
106705: PPUSH
106706: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
106710: LD_VAR 0 1
106714: PPUSH
106715: CALL_OW 316
106719: PUSH
106720: LD_VAR 0 1
106724: PPUSH
106725: CALL_OW 314
106729: OR
106730: PUSH
106731: LD_VAR 0 1
106735: PPUSH
106736: CALL_OW 302
106740: NOT
106741: OR
106742: PUSH
106743: LD_VAR 0 1
106747: PPUSH
106748: CALL_OW 301
106752: OR
106753: IFFALSE 106703
// RemoveSeeing ( _x , _y , side ) ;
106755: LD_VAR 0 8
106759: PPUSH
106760: LD_VAR 0 9
106764: PPUSH
106765: LD_VAR 0 6
106769: PPUSH
106770: CALL_OW 331
// end ; end_of_file
106774: LD_VAR 0 4
106778: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
106779: LD_INT 0
106781: PPUSH
106782: PPUSH
106783: PPUSH
106784: PPUSH
106785: PPUSH
106786: PPUSH
106787: PPUSH
106788: PPUSH
106789: PPUSH
106790: PPUSH
106791: PPUSH
106792: PPUSH
106793: PPUSH
106794: PPUSH
106795: PPUSH
106796: PPUSH
106797: PPUSH
106798: PPUSH
106799: PPUSH
106800: PPUSH
106801: PPUSH
106802: PPUSH
106803: PPUSH
106804: PPUSH
106805: PPUSH
106806: PPUSH
106807: PPUSH
106808: PPUSH
106809: PPUSH
106810: PPUSH
106811: PPUSH
106812: PPUSH
106813: PPUSH
106814: PPUSH
// if not list then
106815: LD_VAR 0 1
106819: NOT
106820: IFFALSE 106824
// exit ;
106822: GO 111483
// base := list [ 1 ] ;
106824: LD_ADDR_VAR 0 3
106828: PUSH
106829: LD_VAR 0 1
106833: PUSH
106834: LD_INT 1
106836: ARRAY
106837: ST_TO_ADDR
// group := list [ 2 ] ;
106838: LD_ADDR_VAR 0 4
106842: PUSH
106843: LD_VAR 0 1
106847: PUSH
106848: LD_INT 2
106850: ARRAY
106851: ST_TO_ADDR
// path := list [ 3 ] ;
106852: LD_ADDR_VAR 0 5
106856: PUSH
106857: LD_VAR 0 1
106861: PUSH
106862: LD_INT 3
106864: ARRAY
106865: ST_TO_ADDR
// flags := list [ 4 ] ;
106866: LD_ADDR_VAR 0 6
106870: PUSH
106871: LD_VAR 0 1
106875: PUSH
106876: LD_INT 4
106878: ARRAY
106879: ST_TO_ADDR
// mined := [ ] ;
106880: LD_ADDR_VAR 0 27
106884: PUSH
106885: EMPTY
106886: ST_TO_ADDR
// bombed := [ ] ;
106887: LD_ADDR_VAR 0 28
106891: PUSH
106892: EMPTY
106893: ST_TO_ADDR
// healers := [ ] ;
106894: LD_ADDR_VAR 0 31
106898: PUSH
106899: EMPTY
106900: ST_TO_ADDR
// to_heal := [ ] ;
106901: LD_ADDR_VAR 0 30
106905: PUSH
106906: EMPTY
106907: ST_TO_ADDR
// repairs := [ ] ;
106908: LD_ADDR_VAR 0 33
106912: PUSH
106913: EMPTY
106914: ST_TO_ADDR
// to_repair := [ ] ;
106915: LD_ADDR_VAR 0 32
106919: PUSH
106920: EMPTY
106921: ST_TO_ADDR
// if not group or not path then
106922: LD_VAR 0 4
106926: NOT
106927: PUSH
106928: LD_VAR 0 5
106932: NOT
106933: OR
106934: IFFALSE 106938
// exit ;
106936: GO 111483
// side := GetSide ( group [ 1 ] ) ;
106938: LD_ADDR_VAR 0 35
106942: PUSH
106943: LD_VAR 0 4
106947: PUSH
106948: LD_INT 1
106950: ARRAY
106951: PPUSH
106952: CALL_OW 255
106956: ST_TO_ADDR
// if flags then
106957: LD_VAR 0 6
106961: IFFALSE 107105
// begin f_ignore_area := flags [ 1 ] ;
106963: LD_ADDR_VAR 0 17
106967: PUSH
106968: LD_VAR 0 6
106972: PUSH
106973: LD_INT 1
106975: ARRAY
106976: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
106977: LD_ADDR_VAR 0 18
106981: PUSH
106982: LD_VAR 0 6
106986: PUSH
106987: LD_INT 2
106989: ARRAY
106990: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
106991: LD_ADDR_VAR 0 19
106995: PUSH
106996: LD_VAR 0 6
107000: PUSH
107001: LD_INT 3
107003: ARRAY
107004: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
107005: LD_ADDR_VAR 0 20
107009: PUSH
107010: LD_VAR 0 6
107014: PUSH
107015: LD_INT 4
107017: ARRAY
107018: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
107019: LD_ADDR_VAR 0 21
107023: PUSH
107024: LD_VAR 0 6
107028: PUSH
107029: LD_INT 5
107031: ARRAY
107032: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
107033: LD_ADDR_VAR 0 22
107037: PUSH
107038: LD_VAR 0 6
107042: PUSH
107043: LD_INT 6
107045: ARRAY
107046: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
107047: LD_ADDR_VAR 0 23
107051: PUSH
107052: LD_VAR 0 6
107056: PUSH
107057: LD_INT 7
107059: ARRAY
107060: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
107061: LD_ADDR_VAR 0 24
107065: PUSH
107066: LD_VAR 0 6
107070: PUSH
107071: LD_INT 8
107073: ARRAY
107074: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
107075: LD_ADDR_VAR 0 25
107079: PUSH
107080: LD_VAR 0 6
107084: PUSH
107085: LD_INT 9
107087: ARRAY
107088: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
107089: LD_ADDR_VAR 0 26
107093: PUSH
107094: LD_VAR 0 6
107098: PUSH
107099: LD_INT 10
107101: ARRAY
107102: ST_TO_ADDR
// end else
107103: GO 107185
// begin f_ignore_area := false ;
107105: LD_ADDR_VAR 0 17
107109: PUSH
107110: LD_INT 0
107112: ST_TO_ADDR
// f_capture := false ;
107113: LD_ADDR_VAR 0 18
107117: PUSH
107118: LD_INT 0
107120: ST_TO_ADDR
// f_ignore_civ := false ;
107121: LD_ADDR_VAR 0 19
107125: PUSH
107126: LD_INT 0
107128: ST_TO_ADDR
// f_murder := false ;
107129: LD_ADDR_VAR 0 20
107133: PUSH
107134: LD_INT 0
107136: ST_TO_ADDR
// f_mines := false ;
107137: LD_ADDR_VAR 0 21
107141: PUSH
107142: LD_INT 0
107144: ST_TO_ADDR
// f_repair := false ;
107145: LD_ADDR_VAR 0 22
107149: PUSH
107150: LD_INT 0
107152: ST_TO_ADDR
// f_heal := false ;
107153: LD_ADDR_VAR 0 23
107157: PUSH
107158: LD_INT 0
107160: ST_TO_ADDR
// f_spacetime := false ;
107161: LD_ADDR_VAR 0 24
107165: PUSH
107166: LD_INT 0
107168: ST_TO_ADDR
// f_attack_depot := false ;
107169: LD_ADDR_VAR 0 25
107173: PUSH
107174: LD_INT 0
107176: ST_TO_ADDR
// f_crawl := false ;
107177: LD_ADDR_VAR 0 26
107181: PUSH
107182: LD_INT 0
107184: ST_TO_ADDR
// end ; if f_heal then
107185: LD_VAR 0 23
107189: IFFALSE 107216
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
107191: LD_ADDR_VAR 0 31
107195: PUSH
107196: LD_VAR 0 4
107200: PPUSH
107201: LD_INT 25
107203: PUSH
107204: LD_INT 4
107206: PUSH
107207: EMPTY
107208: LIST
107209: LIST
107210: PPUSH
107211: CALL_OW 72
107215: ST_TO_ADDR
// if f_repair then
107216: LD_VAR 0 22
107220: IFFALSE 107247
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
107222: LD_ADDR_VAR 0 33
107226: PUSH
107227: LD_VAR 0 4
107231: PPUSH
107232: LD_INT 25
107234: PUSH
107235: LD_INT 3
107237: PUSH
107238: EMPTY
107239: LIST
107240: LIST
107241: PPUSH
107242: CALL_OW 72
107246: ST_TO_ADDR
// units_path := [ ] ;
107247: LD_ADDR_VAR 0 16
107251: PUSH
107252: EMPTY
107253: ST_TO_ADDR
// for i = 1 to group do
107254: LD_ADDR_VAR 0 7
107258: PUSH
107259: DOUBLE
107260: LD_INT 1
107262: DEC
107263: ST_TO_ADDR
107264: LD_VAR 0 4
107268: PUSH
107269: FOR_TO
107270: IFFALSE 107299
// units_path := Replace ( units_path , i , path ) ;
107272: LD_ADDR_VAR 0 16
107276: PUSH
107277: LD_VAR 0 16
107281: PPUSH
107282: LD_VAR 0 7
107286: PPUSH
107287: LD_VAR 0 5
107291: PPUSH
107292: CALL_OW 1
107296: ST_TO_ADDR
107297: GO 107269
107299: POP
107300: POP
// repeat for i = group downto 1 do
107301: LD_ADDR_VAR 0 7
107305: PUSH
107306: DOUBLE
107307: LD_VAR 0 4
107311: INC
107312: ST_TO_ADDR
107313: LD_INT 1
107315: PUSH
107316: FOR_DOWNTO
107317: IFFALSE 111439
// begin wait ( 5 ) ;
107319: LD_INT 5
107321: PPUSH
107322: CALL_OW 67
// tmp := [ ] ;
107326: LD_ADDR_VAR 0 14
107330: PUSH
107331: EMPTY
107332: ST_TO_ADDR
// attacking := false ;
107333: LD_ADDR_VAR 0 29
107337: PUSH
107338: LD_INT 0
107340: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
107341: LD_VAR 0 4
107345: PUSH
107346: LD_VAR 0 7
107350: ARRAY
107351: PPUSH
107352: CALL_OW 301
107356: PUSH
107357: LD_VAR 0 4
107361: PUSH
107362: LD_VAR 0 7
107366: ARRAY
107367: NOT
107368: OR
107369: IFFALSE 107478
// begin if GetType ( group [ i ] ) = unit_human then
107371: LD_VAR 0 4
107375: PUSH
107376: LD_VAR 0 7
107380: ARRAY
107381: PPUSH
107382: CALL_OW 247
107386: PUSH
107387: LD_INT 1
107389: EQUAL
107390: IFFALSE 107436
// begin to_heal := to_heal diff group [ i ] ;
107392: LD_ADDR_VAR 0 30
107396: PUSH
107397: LD_VAR 0 30
107401: PUSH
107402: LD_VAR 0 4
107406: PUSH
107407: LD_VAR 0 7
107411: ARRAY
107412: DIFF
107413: ST_TO_ADDR
// healers := healers diff group [ i ] ;
107414: LD_ADDR_VAR 0 31
107418: PUSH
107419: LD_VAR 0 31
107423: PUSH
107424: LD_VAR 0 4
107428: PUSH
107429: LD_VAR 0 7
107433: ARRAY
107434: DIFF
107435: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
107436: LD_ADDR_VAR 0 4
107440: PUSH
107441: LD_VAR 0 4
107445: PPUSH
107446: LD_VAR 0 7
107450: PPUSH
107451: CALL_OW 3
107455: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
107456: LD_ADDR_VAR 0 16
107460: PUSH
107461: LD_VAR 0 16
107465: PPUSH
107466: LD_VAR 0 7
107470: PPUSH
107471: CALL_OW 3
107475: ST_TO_ADDR
// continue ;
107476: GO 107316
// end ; if f_repair then
107478: LD_VAR 0 22
107482: IFFALSE 107971
// begin if GetType ( group [ i ] ) = unit_vehicle then
107484: LD_VAR 0 4
107488: PUSH
107489: LD_VAR 0 7
107493: ARRAY
107494: PPUSH
107495: CALL_OW 247
107499: PUSH
107500: LD_INT 2
107502: EQUAL
107503: IFFALSE 107693
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
107505: LD_VAR 0 4
107509: PUSH
107510: LD_VAR 0 7
107514: ARRAY
107515: PPUSH
107516: CALL_OW 256
107520: PUSH
107521: LD_INT 700
107523: LESS
107524: PUSH
107525: LD_VAR 0 4
107529: PUSH
107530: LD_VAR 0 7
107534: ARRAY
107535: PUSH
107536: LD_VAR 0 32
107540: IN
107541: NOT
107542: AND
107543: IFFALSE 107567
// to_repair := to_repair union group [ i ] ;
107545: LD_ADDR_VAR 0 32
107549: PUSH
107550: LD_VAR 0 32
107554: PUSH
107555: LD_VAR 0 4
107559: PUSH
107560: LD_VAR 0 7
107564: ARRAY
107565: UNION
107566: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
107567: LD_VAR 0 4
107571: PUSH
107572: LD_VAR 0 7
107576: ARRAY
107577: PPUSH
107578: CALL_OW 256
107582: PUSH
107583: LD_INT 1000
107585: EQUAL
107586: PUSH
107587: LD_VAR 0 4
107591: PUSH
107592: LD_VAR 0 7
107596: ARRAY
107597: PUSH
107598: LD_VAR 0 32
107602: IN
107603: AND
107604: IFFALSE 107628
// to_repair := to_repair diff group [ i ] ;
107606: LD_ADDR_VAR 0 32
107610: PUSH
107611: LD_VAR 0 32
107615: PUSH
107616: LD_VAR 0 4
107620: PUSH
107621: LD_VAR 0 7
107625: ARRAY
107626: DIFF
107627: ST_TO_ADDR
// if group [ i ] in to_repair then
107628: LD_VAR 0 4
107632: PUSH
107633: LD_VAR 0 7
107637: ARRAY
107638: PUSH
107639: LD_VAR 0 32
107643: IN
107644: IFFALSE 107691
// begin if not IsInArea ( group [ i ] , f_repair ) then
107646: LD_VAR 0 4
107650: PUSH
107651: LD_VAR 0 7
107655: ARRAY
107656: PPUSH
107657: LD_VAR 0 22
107661: PPUSH
107662: CALL_OW 308
107666: NOT
107667: IFFALSE 107689
// ComMoveToArea ( group [ i ] , f_repair ) ;
107669: LD_VAR 0 4
107673: PUSH
107674: LD_VAR 0 7
107678: ARRAY
107679: PPUSH
107680: LD_VAR 0 22
107684: PPUSH
107685: CALL_OW 113
// continue ;
107689: GO 107316
// end ; end else
107691: GO 107971
// if group [ i ] in repairs then
107693: LD_VAR 0 4
107697: PUSH
107698: LD_VAR 0 7
107702: ARRAY
107703: PUSH
107704: LD_VAR 0 33
107708: IN
107709: IFFALSE 107971
// begin if IsInUnit ( group [ i ] ) then
107711: LD_VAR 0 4
107715: PUSH
107716: LD_VAR 0 7
107720: ARRAY
107721: PPUSH
107722: CALL_OW 310
107726: IFFALSE 107794
// begin z := IsInUnit ( group [ i ] ) ;
107728: LD_ADDR_VAR 0 13
107732: PUSH
107733: LD_VAR 0 4
107737: PUSH
107738: LD_VAR 0 7
107742: ARRAY
107743: PPUSH
107744: CALL_OW 310
107748: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
107749: LD_VAR 0 13
107753: PUSH
107754: LD_VAR 0 32
107758: IN
107759: PUSH
107760: LD_VAR 0 13
107764: PPUSH
107765: LD_VAR 0 22
107769: PPUSH
107770: CALL_OW 308
107774: AND
107775: IFFALSE 107792
// ComExitVehicle ( group [ i ] ) ;
107777: LD_VAR 0 4
107781: PUSH
107782: LD_VAR 0 7
107786: ARRAY
107787: PPUSH
107788: CALL_OW 121
// end else
107792: GO 107971
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
107794: LD_ADDR_VAR 0 13
107798: PUSH
107799: LD_VAR 0 4
107803: PPUSH
107804: LD_INT 95
107806: PUSH
107807: LD_VAR 0 22
107811: PUSH
107812: EMPTY
107813: LIST
107814: LIST
107815: PUSH
107816: LD_INT 58
107818: PUSH
107819: EMPTY
107820: LIST
107821: PUSH
107822: EMPTY
107823: LIST
107824: LIST
107825: PPUSH
107826: CALL_OW 72
107830: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
107831: LD_VAR 0 4
107835: PUSH
107836: LD_VAR 0 7
107840: ARRAY
107841: PPUSH
107842: CALL_OW 314
107846: NOT
107847: IFFALSE 107969
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
107849: LD_ADDR_VAR 0 10
107853: PUSH
107854: LD_VAR 0 13
107858: PPUSH
107859: LD_VAR 0 4
107863: PUSH
107864: LD_VAR 0 7
107868: ARRAY
107869: PPUSH
107870: CALL_OW 74
107874: ST_TO_ADDR
// if not x then
107875: LD_VAR 0 10
107879: NOT
107880: IFFALSE 107884
// continue ;
107882: GO 107316
// if GetLives ( x ) < 1000 then
107884: LD_VAR 0 10
107888: PPUSH
107889: CALL_OW 256
107893: PUSH
107894: LD_INT 1000
107896: LESS
107897: IFFALSE 107921
// ComRepairVehicle ( group [ i ] , x ) else
107899: LD_VAR 0 4
107903: PUSH
107904: LD_VAR 0 7
107908: ARRAY
107909: PPUSH
107910: LD_VAR 0 10
107914: PPUSH
107915: CALL_OW 129
107919: GO 107969
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
107921: LD_VAR 0 23
107925: PUSH
107926: LD_VAR 0 4
107930: PUSH
107931: LD_VAR 0 7
107935: ARRAY
107936: PPUSH
107937: CALL_OW 256
107941: PUSH
107942: LD_INT 1000
107944: LESS
107945: AND
107946: NOT
107947: IFFALSE 107969
// ComEnterUnit ( group [ i ] , x ) ;
107949: LD_VAR 0 4
107953: PUSH
107954: LD_VAR 0 7
107958: ARRAY
107959: PPUSH
107960: LD_VAR 0 10
107964: PPUSH
107965: CALL_OW 120
// end ; continue ;
107969: GO 107316
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
107971: LD_VAR 0 23
107975: PUSH
107976: LD_VAR 0 4
107980: PUSH
107981: LD_VAR 0 7
107985: ARRAY
107986: PPUSH
107987: CALL_OW 247
107991: PUSH
107992: LD_INT 1
107994: EQUAL
107995: AND
107996: IFFALSE 108474
// begin if group [ i ] in healers then
107998: LD_VAR 0 4
108002: PUSH
108003: LD_VAR 0 7
108007: ARRAY
108008: PUSH
108009: LD_VAR 0 31
108013: IN
108014: IFFALSE 108287
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
108016: LD_VAR 0 4
108020: PUSH
108021: LD_VAR 0 7
108025: ARRAY
108026: PPUSH
108027: LD_VAR 0 23
108031: PPUSH
108032: CALL_OW 308
108036: NOT
108037: PUSH
108038: LD_VAR 0 4
108042: PUSH
108043: LD_VAR 0 7
108047: ARRAY
108048: PPUSH
108049: CALL_OW 314
108053: NOT
108054: AND
108055: IFFALSE 108079
// ComMoveToArea ( group [ i ] , f_heal ) else
108057: LD_VAR 0 4
108061: PUSH
108062: LD_VAR 0 7
108066: ARRAY
108067: PPUSH
108068: LD_VAR 0 23
108072: PPUSH
108073: CALL_OW 113
108077: GO 108285
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
108079: LD_VAR 0 4
108083: PUSH
108084: LD_VAR 0 7
108088: ARRAY
108089: PPUSH
108090: CALL 85185 0 1
108094: PPUSH
108095: CALL_OW 256
108099: PUSH
108100: LD_INT 1000
108102: EQUAL
108103: IFFALSE 108122
// ComStop ( group [ i ] ) else
108105: LD_VAR 0 4
108109: PUSH
108110: LD_VAR 0 7
108114: ARRAY
108115: PPUSH
108116: CALL_OW 141
108120: GO 108285
// if not HasTask ( group [ i ] ) and to_heal then
108122: LD_VAR 0 4
108126: PUSH
108127: LD_VAR 0 7
108131: ARRAY
108132: PPUSH
108133: CALL_OW 314
108137: NOT
108138: PUSH
108139: LD_VAR 0 30
108143: AND
108144: IFFALSE 108285
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
108146: LD_ADDR_VAR 0 13
108150: PUSH
108151: LD_VAR 0 30
108155: PPUSH
108156: LD_INT 3
108158: PUSH
108159: LD_INT 54
108161: PUSH
108162: EMPTY
108163: LIST
108164: PUSH
108165: EMPTY
108166: LIST
108167: LIST
108168: PPUSH
108169: CALL_OW 72
108173: PPUSH
108174: LD_VAR 0 4
108178: PUSH
108179: LD_VAR 0 7
108183: ARRAY
108184: PPUSH
108185: CALL_OW 74
108189: ST_TO_ADDR
// if z then
108190: LD_VAR 0 13
108194: IFFALSE 108285
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
108196: LD_INT 91
108198: PUSH
108199: LD_VAR 0 13
108203: PUSH
108204: LD_INT 10
108206: PUSH
108207: EMPTY
108208: LIST
108209: LIST
108210: LIST
108211: PUSH
108212: LD_INT 81
108214: PUSH
108215: LD_VAR 0 13
108219: PPUSH
108220: CALL_OW 255
108224: PUSH
108225: EMPTY
108226: LIST
108227: LIST
108228: PUSH
108229: EMPTY
108230: LIST
108231: LIST
108232: PPUSH
108233: CALL_OW 69
108237: PUSH
108238: LD_INT 0
108240: EQUAL
108241: IFFALSE 108265
// ComHeal ( group [ i ] , z ) else
108243: LD_VAR 0 4
108247: PUSH
108248: LD_VAR 0 7
108252: ARRAY
108253: PPUSH
108254: LD_VAR 0 13
108258: PPUSH
108259: CALL_OW 128
108263: GO 108285
// ComMoveToArea ( group [ i ] , f_heal ) ;
108265: LD_VAR 0 4
108269: PUSH
108270: LD_VAR 0 7
108274: ARRAY
108275: PPUSH
108276: LD_VAR 0 23
108280: PPUSH
108281: CALL_OW 113
// end ; continue ;
108285: GO 107316
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
108287: LD_VAR 0 4
108291: PUSH
108292: LD_VAR 0 7
108296: ARRAY
108297: PPUSH
108298: CALL_OW 256
108302: PUSH
108303: LD_INT 700
108305: LESS
108306: PUSH
108307: LD_VAR 0 4
108311: PUSH
108312: LD_VAR 0 7
108316: ARRAY
108317: PUSH
108318: LD_VAR 0 30
108322: IN
108323: NOT
108324: AND
108325: IFFALSE 108349
// to_heal := to_heal union group [ i ] ;
108327: LD_ADDR_VAR 0 30
108331: PUSH
108332: LD_VAR 0 30
108336: PUSH
108337: LD_VAR 0 4
108341: PUSH
108342: LD_VAR 0 7
108346: ARRAY
108347: UNION
108348: ST_TO_ADDR
// if group [ i ] in to_heal then
108349: LD_VAR 0 4
108353: PUSH
108354: LD_VAR 0 7
108358: ARRAY
108359: PUSH
108360: LD_VAR 0 30
108364: IN
108365: IFFALSE 108474
// begin if GetLives ( group [ i ] ) = 1000 then
108367: LD_VAR 0 4
108371: PUSH
108372: LD_VAR 0 7
108376: ARRAY
108377: PPUSH
108378: CALL_OW 256
108382: PUSH
108383: LD_INT 1000
108385: EQUAL
108386: IFFALSE 108412
// to_heal := to_heal diff group [ i ] else
108388: LD_ADDR_VAR 0 30
108392: PUSH
108393: LD_VAR 0 30
108397: PUSH
108398: LD_VAR 0 4
108402: PUSH
108403: LD_VAR 0 7
108407: ARRAY
108408: DIFF
108409: ST_TO_ADDR
108410: GO 108474
// begin if not IsInArea ( group [ i ] , to_heal ) then
108412: LD_VAR 0 4
108416: PUSH
108417: LD_VAR 0 7
108421: ARRAY
108422: PPUSH
108423: LD_VAR 0 30
108427: PPUSH
108428: CALL_OW 308
108432: NOT
108433: IFFALSE 108457
// ComMoveToArea ( group [ i ] , f_heal ) else
108435: LD_VAR 0 4
108439: PUSH
108440: LD_VAR 0 7
108444: ARRAY
108445: PPUSH
108446: LD_VAR 0 23
108450: PPUSH
108451: CALL_OW 113
108455: GO 108472
// ComHold ( group [ i ] ) ;
108457: LD_VAR 0 4
108461: PUSH
108462: LD_VAR 0 7
108466: ARRAY
108467: PPUSH
108468: CALL_OW 140
// continue ;
108472: GO 107316
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
108474: LD_VAR 0 4
108478: PUSH
108479: LD_VAR 0 7
108483: ARRAY
108484: PPUSH
108485: LD_INT 10
108487: PPUSH
108488: CALL 83605 0 2
108492: NOT
108493: PUSH
108494: LD_VAR 0 16
108498: PUSH
108499: LD_VAR 0 7
108503: ARRAY
108504: PUSH
108505: EMPTY
108506: EQUAL
108507: NOT
108508: AND
108509: IFFALSE 108775
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
108511: LD_VAR 0 4
108515: PUSH
108516: LD_VAR 0 7
108520: ARRAY
108521: PPUSH
108522: CALL_OW 262
108526: PUSH
108527: LD_INT 1
108529: PUSH
108530: LD_INT 2
108532: PUSH
108533: EMPTY
108534: LIST
108535: LIST
108536: IN
108537: IFFALSE 108578
// if GetFuel ( group [ i ] ) < 10 then
108539: LD_VAR 0 4
108543: PUSH
108544: LD_VAR 0 7
108548: ARRAY
108549: PPUSH
108550: CALL_OW 261
108554: PUSH
108555: LD_INT 10
108557: LESS
108558: IFFALSE 108578
// SetFuel ( group [ i ] , 12 ) ;
108560: LD_VAR 0 4
108564: PUSH
108565: LD_VAR 0 7
108569: ARRAY
108570: PPUSH
108571: LD_INT 12
108573: PPUSH
108574: CALL_OW 240
// if units_path [ i ] then
108578: LD_VAR 0 16
108582: PUSH
108583: LD_VAR 0 7
108587: ARRAY
108588: IFFALSE 108773
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
108590: LD_VAR 0 4
108594: PUSH
108595: LD_VAR 0 7
108599: ARRAY
108600: PPUSH
108601: LD_VAR 0 16
108605: PUSH
108606: LD_VAR 0 7
108610: ARRAY
108611: PUSH
108612: LD_INT 1
108614: ARRAY
108615: PUSH
108616: LD_INT 1
108618: ARRAY
108619: PPUSH
108620: LD_VAR 0 16
108624: PUSH
108625: LD_VAR 0 7
108629: ARRAY
108630: PUSH
108631: LD_INT 1
108633: ARRAY
108634: PUSH
108635: LD_INT 2
108637: ARRAY
108638: PPUSH
108639: CALL_OW 297
108643: PUSH
108644: LD_INT 6
108646: GREATER
108647: IFFALSE 108722
// begin if not HasTask ( group [ i ] ) then
108649: LD_VAR 0 4
108653: PUSH
108654: LD_VAR 0 7
108658: ARRAY
108659: PPUSH
108660: CALL_OW 314
108664: NOT
108665: IFFALSE 108720
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
108667: LD_VAR 0 4
108671: PUSH
108672: LD_VAR 0 7
108676: ARRAY
108677: PPUSH
108678: LD_VAR 0 16
108682: PUSH
108683: LD_VAR 0 7
108687: ARRAY
108688: PUSH
108689: LD_INT 1
108691: ARRAY
108692: PUSH
108693: LD_INT 1
108695: ARRAY
108696: PPUSH
108697: LD_VAR 0 16
108701: PUSH
108702: LD_VAR 0 7
108706: ARRAY
108707: PUSH
108708: LD_INT 1
108710: ARRAY
108711: PUSH
108712: LD_INT 2
108714: ARRAY
108715: PPUSH
108716: CALL_OW 114
// end else
108720: GO 108773
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
108722: LD_ADDR_VAR 0 15
108726: PUSH
108727: LD_VAR 0 16
108731: PUSH
108732: LD_VAR 0 7
108736: ARRAY
108737: PPUSH
108738: LD_INT 1
108740: PPUSH
108741: CALL_OW 3
108745: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
108746: LD_ADDR_VAR 0 16
108750: PUSH
108751: LD_VAR 0 16
108755: PPUSH
108756: LD_VAR 0 7
108760: PPUSH
108761: LD_VAR 0 15
108765: PPUSH
108766: CALL_OW 1
108770: ST_TO_ADDR
// continue ;
108771: GO 107316
// end ; end ; end else
108773: GO 111437
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
108775: LD_ADDR_VAR 0 14
108779: PUSH
108780: LD_INT 81
108782: PUSH
108783: LD_VAR 0 4
108787: PUSH
108788: LD_VAR 0 7
108792: ARRAY
108793: PPUSH
108794: CALL_OW 255
108798: PUSH
108799: EMPTY
108800: LIST
108801: LIST
108802: PPUSH
108803: CALL_OW 69
108807: ST_TO_ADDR
// if not tmp then
108808: LD_VAR 0 14
108812: NOT
108813: IFFALSE 108817
// continue ;
108815: GO 107316
// if f_ignore_area then
108817: LD_VAR 0 17
108821: IFFALSE 108909
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
108823: LD_ADDR_VAR 0 15
108827: PUSH
108828: LD_VAR 0 14
108832: PPUSH
108833: LD_INT 3
108835: PUSH
108836: LD_INT 92
108838: PUSH
108839: LD_VAR 0 17
108843: PUSH
108844: LD_INT 1
108846: ARRAY
108847: PUSH
108848: LD_VAR 0 17
108852: PUSH
108853: LD_INT 2
108855: ARRAY
108856: PUSH
108857: LD_VAR 0 17
108861: PUSH
108862: LD_INT 3
108864: ARRAY
108865: PUSH
108866: EMPTY
108867: LIST
108868: LIST
108869: LIST
108870: LIST
108871: PUSH
108872: EMPTY
108873: LIST
108874: LIST
108875: PPUSH
108876: CALL_OW 72
108880: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
108881: LD_VAR 0 14
108885: PUSH
108886: LD_VAR 0 15
108890: DIFF
108891: IFFALSE 108909
// tmp := tmp diff tmp2 ;
108893: LD_ADDR_VAR 0 14
108897: PUSH
108898: LD_VAR 0 14
108902: PUSH
108903: LD_VAR 0 15
108907: DIFF
108908: ST_TO_ADDR
// end ; if not f_murder then
108909: LD_VAR 0 20
108913: NOT
108914: IFFALSE 108972
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
108916: LD_ADDR_VAR 0 15
108920: PUSH
108921: LD_VAR 0 14
108925: PPUSH
108926: LD_INT 3
108928: PUSH
108929: LD_INT 50
108931: PUSH
108932: EMPTY
108933: LIST
108934: PUSH
108935: EMPTY
108936: LIST
108937: LIST
108938: PPUSH
108939: CALL_OW 72
108943: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
108944: LD_VAR 0 14
108948: PUSH
108949: LD_VAR 0 15
108953: DIFF
108954: IFFALSE 108972
// tmp := tmp diff tmp2 ;
108956: LD_ADDR_VAR 0 14
108960: PUSH
108961: LD_VAR 0 14
108965: PUSH
108966: LD_VAR 0 15
108970: DIFF
108971: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
108972: LD_ADDR_VAR 0 14
108976: PUSH
108977: LD_VAR 0 4
108981: PUSH
108982: LD_VAR 0 7
108986: ARRAY
108987: PPUSH
108988: LD_VAR 0 14
108992: PPUSH
108993: LD_INT 1
108995: PPUSH
108996: LD_INT 1
108998: PPUSH
108999: CALL 56539 0 4
109003: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
109004: LD_VAR 0 4
109008: PUSH
109009: LD_VAR 0 7
109013: ARRAY
109014: PPUSH
109015: CALL_OW 257
109019: PUSH
109020: LD_INT 1
109022: EQUAL
109023: IFFALSE 109471
// begin if WantPlant ( group [ i ] ) then
109025: LD_VAR 0 4
109029: PUSH
109030: LD_VAR 0 7
109034: ARRAY
109035: PPUSH
109036: CALL 56040 0 1
109040: IFFALSE 109044
// continue ;
109042: GO 107316
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
109044: LD_VAR 0 18
109048: PUSH
109049: LD_VAR 0 4
109053: PUSH
109054: LD_VAR 0 7
109058: ARRAY
109059: PPUSH
109060: CALL_OW 310
109064: NOT
109065: AND
109066: PUSH
109067: LD_VAR 0 14
109071: PUSH
109072: LD_INT 1
109074: ARRAY
109075: PUSH
109076: LD_VAR 0 14
109080: PPUSH
109081: LD_INT 21
109083: PUSH
109084: LD_INT 2
109086: PUSH
109087: EMPTY
109088: LIST
109089: LIST
109090: PUSH
109091: LD_INT 58
109093: PUSH
109094: EMPTY
109095: LIST
109096: PUSH
109097: EMPTY
109098: LIST
109099: LIST
109100: PPUSH
109101: CALL_OW 72
109105: IN
109106: AND
109107: IFFALSE 109143
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
109109: LD_VAR 0 4
109113: PUSH
109114: LD_VAR 0 7
109118: ARRAY
109119: PPUSH
109120: LD_VAR 0 14
109124: PUSH
109125: LD_INT 1
109127: ARRAY
109128: PPUSH
109129: CALL_OW 120
// attacking := true ;
109133: LD_ADDR_VAR 0 29
109137: PUSH
109138: LD_INT 1
109140: ST_TO_ADDR
// continue ;
109141: GO 107316
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
109143: LD_VAR 0 26
109147: PUSH
109148: LD_VAR 0 4
109152: PUSH
109153: LD_VAR 0 7
109157: ARRAY
109158: PPUSH
109159: CALL_OW 257
109163: PUSH
109164: LD_INT 1
109166: EQUAL
109167: AND
109168: PUSH
109169: LD_VAR 0 4
109173: PUSH
109174: LD_VAR 0 7
109178: ARRAY
109179: PPUSH
109180: CALL_OW 256
109184: PUSH
109185: LD_INT 800
109187: LESS
109188: AND
109189: PUSH
109190: LD_VAR 0 4
109194: PUSH
109195: LD_VAR 0 7
109199: ARRAY
109200: PPUSH
109201: CALL_OW 318
109205: NOT
109206: AND
109207: IFFALSE 109224
// ComCrawl ( group [ i ] ) ;
109209: LD_VAR 0 4
109213: PUSH
109214: LD_VAR 0 7
109218: ARRAY
109219: PPUSH
109220: CALL_OW 137
// if f_mines then
109224: LD_VAR 0 21
109228: IFFALSE 109471
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
109230: LD_VAR 0 14
109234: PUSH
109235: LD_INT 1
109237: ARRAY
109238: PPUSH
109239: CALL_OW 247
109243: PUSH
109244: LD_INT 3
109246: EQUAL
109247: PUSH
109248: LD_VAR 0 14
109252: PUSH
109253: LD_INT 1
109255: ARRAY
109256: PUSH
109257: LD_VAR 0 27
109261: IN
109262: NOT
109263: AND
109264: IFFALSE 109471
// begin x := GetX ( tmp [ 1 ] ) ;
109266: LD_ADDR_VAR 0 10
109270: PUSH
109271: LD_VAR 0 14
109275: PUSH
109276: LD_INT 1
109278: ARRAY
109279: PPUSH
109280: CALL_OW 250
109284: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
109285: LD_ADDR_VAR 0 11
109289: PUSH
109290: LD_VAR 0 14
109294: PUSH
109295: LD_INT 1
109297: ARRAY
109298: PPUSH
109299: CALL_OW 251
109303: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
109304: LD_ADDR_VAR 0 12
109308: PUSH
109309: LD_VAR 0 4
109313: PUSH
109314: LD_VAR 0 7
109318: ARRAY
109319: PPUSH
109320: CALL 83690 0 1
109324: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
109325: LD_VAR 0 4
109329: PUSH
109330: LD_VAR 0 7
109334: ARRAY
109335: PPUSH
109336: LD_VAR 0 10
109340: PPUSH
109341: LD_VAR 0 11
109345: PPUSH
109346: LD_VAR 0 14
109350: PUSH
109351: LD_INT 1
109353: ARRAY
109354: PPUSH
109355: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
109359: LD_VAR 0 4
109363: PUSH
109364: LD_VAR 0 7
109368: ARRAY
109369: PPUSH
109370: LD_VAR 0 10
109374: PPUSH
109375: LD_VAR 0 12
109379: PPUSH
109380: LD_INT 7
109382: PPUSH
109383: CALL_OW 272
109387: PPUSH
109388: LD_VAR 0 11
109392: PPUSH
109393: LD_VAR 0 12
109397: PPUSH
109398: LD_INT 7
109400: PPUSH
109401: CALL_OW 273
109405: PPUSH
109406: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
109410: LD_VAR 0 4
109414: PUSH
109415: LD_VAR 0 7
109419: ARRAY
109420: PPUSH
109421: LD_INT 71
109423: PPUSH
109424: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
109428: LD_ADDR_VAR 0 27
109432: PUSH
109433: LD_VAR 0 27
109437: PPUSH
109438: LD_VAR 0 27
109442: PUSH
109443: LD_INT 1
109445: PLUS
109446: PPUSH
109447: LD_VAR 0 14
109451: PUSH
109452: LD_INT 1
109454: ARRAY
109455: PPUSH
109456: CALL_OW 1
109460: ST_TO_ADDR
// attacking := true ;
109461: LD_ADDR_VAR 0 29
109465: PUSH
109466: LD_INT 1
109468: ST_TO_ADDR
// continue ;
109469: GO 107316
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
109471: LD_VAR 0 4
109475: PUSH
109476: LD_VAR 0 7
109480: ARRAY
109481: PPUSH
109482: CALL_OW 257
109486: PUSH
109487: LD_INT 17
109489: EQUAL
109490: PUSH
109491: LD_VAR 0 4
109495: PUSH
109496: LD_VAR 0 7
109500: ARRAY
109501: PPUSH
109502: CALL_OW 110
109506: PUSH
109507: LD_INT 71
109509: EQUAL
109510: NOT
109511: AND
109512: IFFALSE 109658
// begin attacking := false ;
109514: LD_ADDR_VAR 0 29
109518: PUSH
109519: LD_INT 0
109521: ST_TO_ADDR
// k := 5 ;
109522: LD_ADDR_VAR 0 9
109526: PUSH
109527: LD_INT 5
109529: ST_TO_ADDR
// if tmp < k then
109530: LD_VAR 0 14
109534: PUSH
109535: LD_VAR 0 9
109539: LESS
109540: IFFALSE 109552
// k := tmp ;
109542: LD_ADDR_VAR 0 9
109546: PUSH
109547: LD_VAR 0 14
109551: ST_TO_ADDR
// for j = 1 to k do
109552: LD_ADDR_VAR 0 8
109556: PUSH
109557: DOUBLE
109558: LD_INT 1
109560: DEC
109561: ST_TO_ADDR
109562: LD_VAR 0 9
109566: PUSH
109567: FOR_TO
109568: IFFALSE 109656
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
109570: LD_VAR 0 14
109574: PUSH
109575: LD_VAR 0 8
109579: ARRAY
109580: PUSH
109581: LD_VAR 0 14
109585: PPUSH
109586: LD_INT 58
109588: PUSH
109589: EMPTY
109590: LIST
109591: PPUSH
109592: CALL_OW 72
109596: IN
109597: NOT
109598: IFFALSE 109654
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109600: LD_VAR 0 4
109604: PUSH
109605: LD_VAR 0 7
109609: ARRAY
109610: PPUSH
109611: LD_VAR 0 14
109615: PUSH
109616: LD_VAR 0 8
109620: ARRAY
109621: PPUSH
109622: CALL_OW 115
// attacking := true ;
109626: LD_ADDR_VAR 0 29
109630: PUSH
109631: LD_INT 1
109633: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
109634: LD_VAR 0 4
109638: PUSH
109639: LD_VAR 0 7
109643: ARRAY
109644: PPUSH
109645: LD_INT 71
109647: PPUSH
109648: CALL_OW 109
// continue ;
109652: GO 109567
// end ; end ;
109654: GO 109567
109656: POP
109657: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
109658: LD_VAR 0 4
109662: PUSH
109663: LD_VAR 0 7
109667: ARRAY
109668: PPUSH
109669: CALL_OW 257
109673: PUSH
109674: LD_INT 8
109676: EQUAL
109677: PUSH
109678: LD_VAR 0 4
109682: PUSH
109683: LD_VAR 0 7
109687: ARRAY
109688: PPUSH
109689: CALL_OW 264
109693: PUSH
109694: LD_INT 28
109696: PUSH
109697: LD_INT 45
109699: PUSH
109700: LD_INT 7
109702: PUSH
109703: LD_INT 47
109705: PUSH
109706: EMPTY
109707: LIST
109708: LIST
109709: LIST
109710: LIST
109711: IN
109712: OR
109713: IFFALSE 109969
// begin attacking := false ;
109715: LD_ADDR_VAR 0 29
109719: PUSH
109720: LD_INT 0
109722: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
109723: LD_VAR 0 14
109727: PUSH
109728: LD_INT 1
109730: ARRAY
109731: PPUSH
109732: CALL_OW 266
109736: PUSH
109737: LD_INT 32
109739: PUSH
109740: LD_INT 31
109742: PUSH
109743: LD_INT 33
109745: PUSH
109746: LD_INT 4
109748: PUSH
109749: LD_INT 5
109751: PUSH
109752: EMPTY
109753: LIST
109754: LIST
109755: LIST
109756: LIST
109757: LIST
109758: IN
109759: IFFALSE 109945
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
109761: LD_ADDR_VAR 0 9
109765: PUSH
109766: LD_VAR 0 14
109770: PUSH
109771: LD_INT 1
109773: ARRAY
109774: PPUSH
109775: CALL_OW 266
109779: PPUSH
109780: LD_VAR 0 14
109784: PUSH
109785: LD_INT 1
109787: ARRAY
109788: PPUSH
109789: CALL_OW 250
109793: PPUSH
109794: LD_VAR 0 14
109798: PUSH
109799: LD_INT 1
109801: ARRAY
109802: PPUSH
109803: CALL_OW 251
109807: PPUSH
109808: LD_VAR 0 14
109812: PUSH
109813: LD_INT 1
109815: ARRAY
109816: PPUSH
109817: CALL_OW 254
109821: PPUSH
109822: LD_VAR 0 14
109826: PUSH
109827: LD_INT 1
109829: ARRAY
109830: PPUSH
109831: CALL_OW 248
109835: PPUSH
109836: LD_INT 0
109838: PPUSH
109839: CALL 65060 0 6
109843: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
109844: LD_ADDR_VAR 0 8
109848: PUSH
109849: LD_VAR 0 4
109853: PUSH
109854: LD_VAR 0 7
109858: ARRAY
109859: PPUSH
109860: LD_VAR 0 9
109864: PPUSH
109865: CALL 83730 0 2
109869: ST_TO_ADDR
// if j then
109870: LD_VAR 0 8
109874: IFFALSE 109943
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
109876: LD_VAR 0 8
109880: PUSH
109881: LD_INT 1
109883: ARRAY
109884: PPUSH
109885: LD_VAR 0 8
109889: PUSH
109890: LD_INT 2
109892: ARRAY
109893: PPUSH
109894: CALL_OW 488
109898: IFFALSE 109943
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
109900: LD_VAR 0 4
109904: PUSH
109905: LD_VAR 0 7
109909: ARRAY
109910: PPUSH
109911: LD_VAR 0 8
109915: PUSH
109916: LD_INT 1
109918: ARRAY
109919: PPUSH
109920: LD_VAR 0 8
109924: PUSH
109925: LD_INT 2
109927: ARRAY
109928: PPUSH
109929: CALL_OW 116
// attacking := true ;
109933: LD_ADDR_VAR 0 29
109937: PUSH
109938: LD_INT 1
109940: ST_TO_ADDR
// continue ;
109941: GO 107316
// end ; end else
109943: GO 109969
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109945: LD_VAR 0 4
109949: PUSH
109950: LD_VAR 0 7
109954: ARRAY
109955: PPUSH
109956: LD_VAR 0 14
109960: PUSH
109961: LD_INT 1
109963: ARRAY
109964: PPUSH
109965: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
109969: LD_VAR 0 4
109973: PUSH
109974: LD_VAR 0 7
109978: ARRAY
109979: PPUSH
109980: CALL_OW 265
109984: PUSH
109985: LD_INT 11
109987: EQUAL
109988: IFFALSE 110266
// begin k := 10 ;
109990: LD_ADDR_VAR 0 9
109994: PUSH
109995: LD_INT 10
109997: ST_TO_ADDR
// x := 0 ;
109998: LD_ADDR_VAR 0 10
110002: PUSH
110003: LD_INT 0
110005: ST_TO_ADDR
// if tmp < k then
110006: LD_VAR 0 14
110010: PUSH
110011: LD_VAR 0 9
110015: LESS
110016: IFFALSE 110028
// k := tmp ;
110018: LD_ADDR_VAR 0 9
110022: PUSH
110023: LD_VAR 0 14
110027: ST_TO_ADDR
// for j = k downto 1 do
110028: LD_ADDR_VAR 0 8
110032: PUSH
110033: DOUBLE
110034: LD_VAR 0 9
110038: INC
110039: ST_TO_ADDR
110040: LD_INT 1
110042: PUSH
110043: FOR_DOWNTO
110044: IFFALSE 110119
// begin if GetType ( tmp [ j ] ) = unit_human then
110046: LD_VAR 0 14
110050: PUSH
110051: LD_VAR 0 8
110055: ARRAY
110056: PPUSH
110057: CALL_OW 247
110061: PUSH
110062: LD_INT 1
110064: EQUAL
110065: IFFALSE 110117
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
110067: LD_VAR 0 4
110071: PUSH
110072: LD_VAR 0 7
110076: ARRAY
110077: PPUSH
110078: LD_VAR 0 14
110082: PUSH
110083: LD_VAR 0 8
110087: ARRAY
110088: PPUSH
110089: CALL 84001 0 2
// x := tmp [ j ] ;
110093: LD_ADDR_VAR 0 10
110097: PUSH
110098: LD_VAR 0 14
110102: PUSH
110103: LD_VAR 0 8
110107: ARRAY
110108: ST_TO_ADDR
// attacking := true ;
110109: LD_ADDR_VAR 0 29
110113: PUSH
110114: LD_INT 1
110116: ST_TO_ADDR
// end ; end ;
110117: GO 110043
110119: POP
110120: POP
// if not x then
110121: LD_VAR 0 10
110125: NOT
110126: IFFALSE 110266
// begin attacking := true ;
110128: LD_ADDR_VAR 0 29
110132: PUSH
110133: LD_INT 1
110135: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
110136: LD_VAR 0 4
110140: PUSH
110141: LD_VAR 0 7
110145: ARRAY
110146: PPUSH
110147: CALL_OW 250
110151: PPUSH
110152: LD_VAR 0 4
110156: PUSH
110157: LD_VAR 0 7
110161: ARRAY
110162: PPUSH
110163: CALL_OW 251
110167: PPUSH
110168: CALL_OW 546
110172: PUSH
110173: LD_INT 2
110175: ARRAY
110176: PUSH
110177: LD_VAR 0 14
110181: PUSH
110182: LD_INT 1
110184: ARRAY
110185: PPUSH
110186: CALL_OW 250
110190: PPUSH
110191: LD_VAR 0 14
110195: PUSH
110196: LD_INT 1
110198: ARRAY
110199: PPUSH
110200: CALL_OW 251
110204: PPUSH
110205: CALL_OW 546
110209: PUSH
110210: LD_INT 2
110212: ARRAY
110213: EQUAL
110214: IFFALSE 110242
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
110216: LD_VAR 0 4
110220: PUSH
110221: LD_VAR 0 7
110225: ARRAY
110226: PPUSH
110227: LD_VAR 0 14
110231: PUSH
110232: LD_INT 1
110234: ARRAY
110235: PPUSH
110236: CALL 84001 0 2
110240: GO 110266
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110242: LD_VAR 0 4
110246: PUSH
110247: LD_VAR 0 7
110251: ARRAY
110252: PPUSH
110253: LD_VAR 0 14
110257: PUSH
110258: LD_INT 1
110260: ARRAY
110261: PPUSH
110262: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
110266: LD_VAR 0 4
110270: PUSH
110271: LD_VAR 0 7
110275: ARRAY
110276: PPUSH
110277: CALL_OW 264
110281: PUSH
110282: LD_INT 29
110284: EQUAL
110285: IFFALSE 110651
// begin if WantsToAttack ( group [ i ] ) in bombed then
110287: LD_VAR 0 4
110291: PUSH
110292: LD_VAR 0 7
110296: ARRAY
110297: PPUSH
110298: CALL_OW 319
110302: PUSH
110303: LD_VAR 0 28
110307: IN
110308: IFFALSE 110312
// continue ;
110310: GO 107316
// k := 8 ;
110312: LD_ADDR_VAR 0 9
110316: PUSH
110317: LD_INT 8
110319: ST_TO_ADDR
// x := 0 ;
110320: LD_ADDR_VAR 0 10
110324: PUSH
110325: LD_INT 0
110327: ST_TO_ADDR
// if tmp < k then
110328: LD_VAR 0 14
110332: PUSH
110333: LD_VAR 0 9
110337: LESS
110338: IFFALSE 110350
// k := tmp ;
110340: LD_ADDR_VAR 0 9
110344: PUSH
110345: LD_VAR 0 14
110349: ST_TO_ADDR
// for j = 1 to k do
110350: LD_ADDR_VAR 0 8
110354: PUSH
110355: DOUBLE
110356: LD_INT 1
110358: DEC
110359: ST_TO_ADDR
110360: LD_VAR 0 9
110364: PUSH
110365: FOR_TO
110366: IFFALSE 110498
// begin if GetType ( tmp [ j ] ) = unit_building then
110368: LD_VAR 0 14
110372: PUSH
110373: LD_VAR 0 8
110377: ARRAY
110378: PPUSH
110379: CALL_OW 247
110383: PUSH
110384: LD_INT 3
110386: EQUAL
110387: IFFALSE 110496
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
110389: LD_VAR 0 14
110393: PUSH
110394: LD_VAR 0 8
110398: ARRAY
110399: PUSH
110400: LD_VAR 0 28
110404: IN
110405: NOT
110406: PUSH
110407: LD_VAR 0 14
110411: PUSH
110412: LD_VAR 0 8
110416: ARRAY
110417: PPUSH
110418: CALL_OW 313
110422: AND
110423: IFFALSE 110496
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110425: LD_VAR 0 4
110429: PUSH
110430: LD_VAR 0 7
110434: ARRAY
110435: PPUSH
110436: LD_VAR 0 14
110440: PUSH
110441: LD_VAR 0 8
110445: ARRAY
110446: PPUSH
110447: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
110451: LD_ADDR_VAR 0 28
110455: PUSH
110456: LD_VAR 0 28
110460: PPUSH
110461: LD_VAR 0 28
110465: PUSH
110466: LD_INT 1
110468: PLUS
110469: PPUSH
110470: LD_VAR 0 14
110474: PUSH
110475: LD_VAR 0 8
110479: ARRAY
110480: PPUSH
110481: CALL_OW 1
110485: ST_TO_ADDR
// attacking := true ;
110486: LD_ADDR_VAR 0 29
110490: PUSH
110491: LD_INT 1
110493: ST_TO_ADDR
// break ;
110494: GO 110498
// end ; end ;
110496: GO 110365
110498: POP
110499: POP
// if not attacking and f_attack_depot then
110500: LD_VAR 0 29
110504: NOT
110505: PUSH
110506: LD_VAR 0 25
110510: AND
110511: IFFALSE 110606
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110513: LD_ADDR_VAR 0 13
110517: PUSH
110518: LD_VAR 0 14
110522: PPUSH
110523: LD_INT 2
110525: PUSH
110526: LD_INT 30
110528: PUSH
110529: LD_INT 0
110531: PUSH
110532: EMPTY
110533: LIST
110534: LIST
110535: PUSH
110536: LD_INT 30
110538: PUSH
110539: LD_INT 1
110541: PUSH
110542: EMPTY
110543: LIST
110544: LIST
110545: PUSH
110546: EMPTY
110547: LIST
110548: LIST
110549: LIST
110550: PPUSH
110551: CALL_OW 72
110555: ST_TO_ADDR
// if z then
110556: LD_VAR 0 13
110560: IFFALSE 110606
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
110562: LD_VAR 0 4
110566: PUSH
110567: LD_VAR 0 7
110571: ARRAY
110572: PPUSH
110573: LD_VAR 0 13
110577: PPUSH
110578: LD_VAR 0 4
110582: PUSH
110583: LD_VAR 0 7
110587: ARRAY
110588: PPUSH
110589: CALL_OW 74
110593: PPUSH
110594: CALL_OW 115
// attacking := true ;
110598: LD_ADDR_VAR 0 29
110602: PUSH
110603: LD_INT 1
110605: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
110606: LD_VAR 0 4
110610: PUSH
110611: LD_VAR 0 7
110615: ARRAY
110616: PPUSH
110617: CALL_OW 256
110621: PUSH
110622: LD_INT 500
110624: LESS
110625: IFFALSE 110651
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110627: LD_VAR 0 4
110631: PUSH
110632: LD_VAR 0 7
110636: ARRAY
110637: PPUSH
110638: LD_VAR 0 14
110642: PUSH
110643: LD_INT 1
110645: ARRAY
110646: PPUSH
110647: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
110651: LD_VAR 0 4
110655: PUSH
110656: LD_VAR 0 7
110660: ARRAY
110661: PPUSH
110662: CALL_OW 264
110666: PUSH
110667: LD_INT 49
110669: EQUAL
110670: IFFALSE 110791
// begin if not HasTask ( group [ i ] ) then
110672: LD_VAR 0 4
110676: PUSH
110677: LD_VAR 0 7
110681: ARRAY
110682: PPUSH
110683: CALL_OW 314
110687: NOT
110688: IFFALSE 110791
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
110690: LD_ADDR_VAR 0 9
110694: PUSH
110695: LD_INT 81
110697: PUSH
110698: LD_VAR 0 4
110702: PUSH
110703: LD_VAR 0 7
110707: ARRAY
110708: PPUSH
110709: CALL_OW 255
110713: PUSH
110714: EMPTY
110715: LIST
110716: LIST
110717: PPUSH
110718: CALL_OW 69
110722: PPUSH
110723: LD_VAR 0 4
110727: PUSH
110728: LD_VAR 0 7
110732: ARRAY
110733: PPUSH
110734: CALL_OW 74
110738: ST_TO_ADDR
// if k then
110739: LD_VAR 0 9
110743: IFFALSE 110791
// if GetDistUnits ( group [ i ] , k ) > 10 then
110745: LD_VAR 0 4
110749: PUSH
110750: LD_VAR 0 7
110754: ARRAY
110755: PPUSH
110756: LD_VAR 0 9
110760: PPUSH
110761: CALL_OW 296
110765: PUSH
110766: LD_INT 10
110768: GREATER
110769: IFFALSE 110791
// ComMoveUnit ( group [ i ] , k ) ;
110771: LD_VAR 0 4
110775: PUSH
110776: LD_VAR 0 7
110780: ARRAY
110781: PPUSH
110782: LD_VAR 0 9
110786: PPUSH
110787: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
110791: LD_VAR 0 4
110795: PUSH
110796: LD_VAR 0 7
110800: ARRAY
110801: PPUSH
110802: CALL_OW 256
110806: PUSH
110807: LD_INT 250
110809: LESS
110810: PUSH
110811: LD_VAR 0 4
110815: PUSH
110816: LD_VAR 0 7
110820: ARRAY
110821: PUSH
110822: LD_INT 21
110824: PUSH
110825: LD_INT 2
110827: PUSH
110828: EMPTY
110829: LIST
110830: LIST
110831: PUSH
110832: LD_INT 23
110834: PUSH
110835: LD_INT 2
110837: PUSH
110838: EMPTY
110839: LIST
110840: LIST
110841: PUSH
110842: EMPTY
110843: LIST
110844: LIST
110845: PPUSH
110846: CALL_OW 69
110850: IN
110851: AND
110852: IFFALSE 110977
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
110854: LD_ADDR_VAR 0 9
110858: PUSH
110859: LD_OWVAR 3
110863: PUSH
110864: LD_VAR 0 4
110868: PUSH
110869: LD_VAR 0 7
110873: ARRAY
110874: DIFF
110875: PPUSH
110876: LD_VAR 0 4
110880: PUSH
110881: LD_VAR 0 7
110885: ARRAY
110886: PPUSH
110887: CALL_OW 74
110891: ST_TO_ADDR
// if not k then
110892: LD_VAR 0 9
110896: NOT
110897: IFFALSE 110901
// continue ;
110899: GO 107316
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
110901: LD_VAR 0 9
110905: PUSH
110906: LD_INT 81
110908: PUSH
110909: LD_VAR 0 4
110913: PUSH
110914: LD_VAR 0 7
110918: ARRAY
110919: PPUSH
110920: CALL_OW 255
110924: PUSH
110925: EMPTY
110926: LIST
110927: LIST
110928: PPUSH
110929: CALL_OW 69
110933: IN
110934: PUSH
110935: LD_VAR 0 9
110939: PPUSH
110940: LD_VAR 0 4
110944: PUSH
110945: LD_VAR 0 7
110949: ARRAY
110950: PPUSH
110951: CALL_OW 296
110955: PUSH
110956: LD_INT 5
110958: LESS
110959: AND
110960: IFFALSE 110977
// ComAutodestruct ( group [ i ] ) ;
110962: LD_VAR 0 4
110966: PUSH
110967: LD_VAR 0 7
110971: ARRAY
110972: PPUSH
110973: CALL 83899 0 1
// end ; if f_attack_depot then
110977: LD_VAR 0 25
110981: IFFALSE 111093
// begin k := 6 ;
110983: LD_ADDR_VAR 0 9
110987: PUSH
110988: LD_INT 6
110990: ST_TO_ADDR
// if tmp < k then
110991: LD_VAR 0 14
110995: PUSH
110996: LD_VAR 0 9
111000: LESS
111001: IFFALSE 111013
// k := tmp ;
111003: LD_ADDR_VAR 0 9
111007: PUSH
111008: LD_VAR 0 14
111012: ST_TO_ADDR
// for j = 1 to k do
111013: LD_ADDR_VAR 0 8
111017: PUSH
111018: DOUBLE
111019: LD_INT 1
111021: DEC
111022: ST_TO_ADDR
111023: LD_VAR 0 9
111027: PUSH
111028: FOR_TO
111029: IFFALSE 111091
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
111031: LD_VAR 0 8
111035: PPUSH
111036: CALL_OW 266
111040: PUSH
111041: LD_INT 0
111043: PUSH
111044: LD_INT 1
111046: PUSH
111047: EMPTY
111048: LIST
111049: LIST
111050: IN
111051: IFFALSE 111089
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111053: LD_VAR 0 4
111057: PUSH
111058: LD_VAR 0 7
111062: ARRAY
111063: PPUSH
111064: LD_VAR 0 14
111068: PUSH
111069: LD_VAR 0 8
111073: ARRAY
111074: PPUSH
111075: CALL_OW 115
// attacking := true ;
111079: LD_ADDR_VAR 0 29
111083: PUSH
111084: LD_INT 1
111086: ST_TO_ADDR
// break ;
111087: GO 111091
// end ;
111089: GO 111028
111091: POP
111092: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
111093: LD_VAR 0 4
111097: PUSH
111098: LD_VAR 0 7
111102: ARRAY
111103: PPUSH
111104: CALL_OW 302
111108: PUSH
111109: LD_VAR 0 29
111113: NOT
111114: AND
111115: IFFALSE 111437
// begin if GetTag ( group [ i ] ) = 71 then
111117: LD_VAR 0 4
111121: PUSH
111122: LD_VAR 0 7
111126: ARRAY
111127: PPUSH
111128: CALL_OW 110
111132: PUSH
111133: LD_INT 71
111135: EQUAL
111136: IFFALSE 111177
// begin if HasTask ( group [ i ] ) then
111138: LD_VAR 0 4
111142: PUSH
111143: LD_VAR 0 7
111147: ARRAY
111148: PPUSH
111149: CALL_OW 314
111153: IFFALSE 111159
// continue else
111155: GO 107316
111157: GO 111177
// SetTag ( group [ i ] , 0 ) ;
111159: LD_VAR 0 4
111163: PUSH
111164: LD_VAR 0 7
111168: ARRAY
111169: PPUSH
111170: LD_INT 0
111172: PPUSH
111173: CALL_OW 109
// end ; k := 8 ;
111177: LD_ADDR_VAR 0 9
111181: PUSH
111182: LD_INT 8
111184: ST_TO_ADDR
// x := 0 ;
111185: LD_ADDR_VAR 0 10
111189: PUSH
111190: LD_INT 0
111192: ST_TO_ADDR
// if tmp < k then
111193: LD_VAR 0 14
111197: PUSH
111198: LD_VAR 0 9
111202: LESS
111203: IFFALSE 111215
// k := tmp ;
111205: LD_ADDR_VAR 0 9
111209: PUSH
111210: LD_VAR 0 14
111214: ST_TO_ADDR
// for j = 1 to k do
111215: LD_ADDR_VAR 0 8
111219: PUSH
111220: DOUBLE
111221: LD_INT 1
111223: DEC
111224: ST_TO_ADDR
111225: LD_VAR 0 9
111229: PUSH
111230: FOR_TO
111231: IFFALSE 111329
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
111233: LD_VAR 0 14
111237: PUSH
111238: LD_VAR 0 8
111242: ARRAY
111243: PPUSH
111244: CALL_OW 247
111248: PUSH
111249: LD_INT 1
111251: EQUAL
111252: PUSH
111253: LD_VAR 0 14
111257: PUSH
111258: LD_VAR 0 8
111262: ARRAY
111263: PPUSH
111264: CALL_OW 256
111268: PUSH
111269: LD_INT 250
111271: LESS
111272: PUSH
111273: LD_VAR 0 20
111277: AND
111278: PUSH
111279: LD_VAR 0 20
111283: NOT
111284: PUSH
111285: LD_VAR 0 14
111289: PUSH
111290: LD_VAR 0 8
111294: ARRAY
111295: PPUSH
111296: CALL_OW 256
111300: PUSH
111301: LD_INT 250
111303: GREATEREQUAL
111304: AND
111305: OR
111306: AND
111307: IFFALSE 111327
// begin x := tmp [ j ] ;
111309: LD_ADDR_VAR 0 10
111313: PUSH
111314: LD_VAR 0 14
111318: PUSH
111319: LD_VAR 0 8
111323: ARRAY
111324: ST_TO_ADDR
// break ;
111325: GO 111329
// end ;
111327: GO 111230
111329: POP
111330: POP
// if x then
111331: LD_VAR 0 10
111335: IFFALSE 111359
// ComAttackUnit ( group [ i ] , x ) else
111337: LD_VAR 0 4
111341: PUSH
111342: LD_VAR 0 7
111346: ARRAY
111347: PPUSH
111348: LD_VAR 0 10
111352: PPUSH
111353: CALL_OW 115
111357: GO 111383
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111359: LD_VAR 0 4
111363: PUSH
111364: LD_VAR 0 7
111368: ARRAY
111369: PPUSH
111370: LD_VAR 0 14
111374: PUSH
111375: LD_INT 1
111377: ARRAY
111378: PPUSH
111379: CALL_OW 115
// if not HasTask ( group [ i ] ) then
111383: LD_VAR 0 4
111387: PUSH
111388: LD_VAR 0 7
111392: ARRAY
111393: PPUSH
111394: CALL_OW 314
111398: NOT
111399: IFFALSE 111437
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
111401: LD_VAR 0 4
111405: PUSH
111406: LD_VAR 0 7
111410: ARRAY
111411: PPUSH
111412: LD_VAR 0 14
111416: PPUSH
111417: LD_VAR 0 4
111421: PUSH
111422: LD_VAR 0 7
111426: ARRAY
111427: PPUSH
111428: CALL_OW 74
111432: PPUSH
111433: CALL_OW 115
// end ; end ; end ;
111437: GO 107316
111439: POP
111440: POP
// wait ( 0 0$2 ) ;
111441: LD_INT 70
111443: PPUSH
111444: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
111448: LD_VAR 0 4
111452: NOT
111453: PUSH
111454: LD_VAR 0 4
111458: PUSH
111459: EMPTY
111460: EQUAL
111461: OR
111462: PUSH
111463: LD_INT 81
111465: PUSH
111466: LD_VAR 0 35
111470: PUSH
111471: EMPTY
111472: LIST
111473: LIST
111474: PPUSH
111475: CALL_OW 69
111479: NOT
111480: OR
111481: IFFALSE 107301
// end ;
111483: LD_VAR 0 2
111487: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
111488: LD_INT 0
111490: PPUSH
111491: PPUSH
111492: PPUSH
111493: PPUSH
111494: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
111495: LD_VAR 0 1
111499: NOT
111500: PUSH
111501: LD_EXP 93
111505: PUSH
111506: LD_VAR 0 1
111510: ARRAY
111511: NOT
111512: OR
111513: PUSH
111514: LD_VAR 0 2
111518: NOT
111519: OR
111520: PUSH
111521: LD_VAR 0 3
111525: NOT
111526: OR
111527: IFFALSE 111531
// exit ;
111529: GO 112044
// side := mc_sides [ base ] ;
111531: LD_ADDR_VAR 0 6
111535: PUSH
111536: LD_EXP 119
111540: PUSH
111541: LD_VAR 0 1
111545: ARRAY
111546: ST_TO_ADDR
// if not side then
111547: LD_VAR 0 6
111551: NOT
111552: IFFALSE 111556
// exit ;
111554: GO 112044
// for i in solds do
111556: LD_ADDR_VAR 0 7
111560: PUSH
111561: LD_VAR 0 2
111565: PUSH
111566: FOR_IN
111567: IFFALSE 111628
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
111569: LD_VAR 0 7
111573: PPUSH
111574: CALL_OW 310
111578: PPUSH
111579: CALL_OW 266
111583: PUSH
111584: LD_INT 32
111586: PUSH
111587: LD_INT 31
111589: PUSH
111590: EMPTY
111591: LIST
111592: LIST
111593: IN
111594: IFFALSE 111614
// solds := solds diff i else
111596: LD_ADDR_VAR 0 2
111600: PUSH
111601: LD_VAR 0 2
111605: PUSH
111606: LD_VAR 0 7
111610: DIFF
111611: ST_TO_ADDR
111612: GO 111626
// SetTag ( i , 18 ) ;
111614: LD_VAR 0 7
111618: PPUSH
111619: LD_INT 18
111621: PPUSH
111622: CALL_OW 109
111626: GO 111566
111628: POP
111629: POP
// if not solds then
111630: LD_VAR 0 2
111634: NOT
111635: IFFALSE 111639
// exit ;
111637: GO 112044
// repeat wait ( 0 0$2 ) ;
111639: LD_INT 70
111641: PPUSH
111642: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
111646: LD_ADDR_VAR 0 5
111650: PUSH
111651: LD_VAR 0 6
111655: PPUSH
111656: LD_VAR 0 3
111660: PPUSH
111661: CALL 52869 0 2
111665: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111666: LD_EXP 93
111670: PUSH
111671: LD_VAR 0 1
111675: ARRAY
111676: NOT
111677: PUSH
111678: LD_EXP 93
111682: PUSH
111683: LD_VAR 0 1
111687: ARRAY
111688: PUSH
111689: EMPTY
111690: EQUAL
111691: OR
111692: IFFALSE 111729
// begin for i in solds do
111694: LD_ADDR_VAR 0 7
111698: PUSH
111699: LD_VAR 0 2
111703: PUSH
111704: FOR_IN
111705: IFFALSE 111718
// ComStop ( i ) ;
111707: LD_VAR 0 7
111711: PPUSH
111712: CALL_OW 141
111716: GO 111704
111718: POP
111719: POP
// solds := [ ] ;
111720: LD_ADDR_VAR 0 2
111724: PUSH
111725: EMPTY
111726: ST_TO_ADDR
// exit ;
111727: GO 112044
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
111729: LD_VAR 0 5
111733: NOT
111734: PUSH
111735: LD_VAR 0 5
111739: PUSH
111740: LD_INT 3
111742: GREATER
111743: OR
111744: PUSH
111745: LD_EXP 115
111749: PUSH
111750: LD_VAR 0 1
111754: ARRAY
111755: OR
111756: IFFALSE 111797
// begin for i in solds do
111758: LD_ADDR_VAR 0 7
111762: PUSH
111763: LD_VAR 0 2
111767: PUSH
111768: FOR_IN
111769: IFFALSE 111793
// if HasTask ( i ) then
111771: LD_VAR 0 7
111775: PPUSH
111776: CALL_OW 314
111780: IFFALSE 111791
// ComStop ( i ) ;
111782: LD_VAR 0 7
111786: PPUSH
111787: CALL_OW 141
111791: GO 111768
111793: POP
111794: POP
// break ;
111795: GO 112032
// end ; for i in solds do
111797: LD_ADDR_VAR 0 7
111801: PUSH
111802: LD_VAR 0 2
111806: PUSH
111807: FOR_IN
111808: IFFALSE 112024
// begin if IsInUnit ( i ) then
111810: LD_VAR 0 7
111814: PPUSH
111815: CALL_OW 310
111819: IFFALSE 111830
// ComExitBuilding ( i ) ;
111821: LD_VAR 0 7
111825: PPUSH
111826: CALL_OW 122
// if GetLives ( i ) > 333 then
111830: LD_VAR 0 7
111834: PPUSH
111835: CALL_OW 256
111839: PUSH
111840: LD_INT 333
111842: GREATER
111843: IFFALSE 111871
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
111845: LD_VAR 0 7
111849: PPUSH
111850: LD_VAR 0 5
111854: PPUSH
111855: LD_VAR 0 7
111859: PPUSH
111860: CALL_OW 74
111864: PPUSH
111865: CALL_OW 115
111869: GO 112022
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
111871: LD_ADDR_VAR 0 8
111875: PUSH
111876: LD_EXP 93
111880: PUSH
111881: LD_VAR 0 1
111885: ARRAY
111886: PPUSH
111887: LD_INT 2
111889: PUSH
111890: LD_INT 30
111892: PUSH
111893: LD_INT 0
111895: PUSH
111896: EMPTY
111897: LIST
111898: LIST
111899: PUSH
111900: LD_INT 30
111902: PUSH
111903: LD_INT 1
111905: PUSH
111906: EMPTY
111907: LIST
111908: LIST
111909: PUSH
111910: LD_INT 30
111912: PUSH
111913: LD_INT 6
111915: PUSH
111916: EMPTY
111917: LIST
111918: LIST
111919: PUSH
111920: EMPTY
111921: LIST
111922: LIST
111923: LIST
111924: LIST
111925: PPUSH
111926: CALL_OW 72
111930: PPUSH
111931: LD_VAR 0 7
111935: PPUSH
111936: CALL_OW 74
111940: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
111941: LD_VAR 0 7
111945: PPUSH
111946: LD_VAR 0 8
111950: PPUSH
111951: CALL_OW 250
111955: PPUSH
111956: LD_INT 3
111958: PPUSH
111959: LD_INT 5
111961: PPUSH
111962: CALL_OW 272
111966: PPUSH
111967: LD_VAR 0 8
111971: PPUSH
111972: CALL_OW 251
111976: PPUSH
111977: LD_INT 3
111979: PPUSH
111980: LD_INT 5
111982: PPUSH
111983: CALL_OW 273
111987: PPUSH
111988: CALL_OW 111
// SetTag ( i , 0 ) ;
111992: LD_VAR 0 7
111996: PPUSH
111997: LD_INT 0
111999: PPUSH
112000: CALL_OW 109
// solds := solds diff i ;
112004: LD_ADDR_VAR 0 2
112008: PUSH
112009: LD_VAR 0 2
112013: PUSH
112014: LD_VAR 0 7
112018: DIFF
112019: ST_TO_ADDR
// continue ;
112020: GO 111807
// end ; end ;
112022: GO 111807
112024: POP
112025: POP
// until solds ;
112026: LD_VAR 0 2
112030: IFFALSE 111639
// MC_Reset ( base , 18 ) ;
112032: LD_VAR 0 1
112036: PPUSH
112037: LD_INT 18
112039: PPUSH
112040: CALL 24956 0 2
// end ;
112044: LD_VAR 0 4
112048: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
112049: LD_INT 0
112051: PPUSH
112052: PPUSH
112053: PPUSH
112054: PPUSH
112055: PPUSH
112056: PPUSH
112057: PPUSH
112058: PPUSH
112059: PPUSH
112060: PPUSH
112061: PPUSH
112062: PPUSH
112063: PPUSH
112064: PPUSH
112065: PPUSH
112066: PPUSH
112067: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
112068: LD_ADDR_VAR 0 13
112072: PUSH
112073: LD_EXP 93
112077: PUSH
112078: LD_VAR 0 1
112082: ARRAY
112083: PPUSH
112084: LD_INT 25
112086: PUSH
112087: LD_INT 3
112089: PUSH
112090: EMPTY
112091: LIST
112092: LIST
112093: PPUSH
112094: CALL_OW 72
112098: ST_TO_ADDR
// if mc_remote_driver [ base ] then
112099: LD_EXP 133
112103: PUSH
112104: LD_VAR 0 1
112108: ARRAY
112109: IFFALSE 112133
// mechs := mechs diff mc_remote_driver [ base ] ;
112111: LD_ADDR_VAR 0 13
112115: PUSH
112116: LD_VAR 0 13
112120: PUSH
112121: LD_EXP 133
112125: PUSH
112126: LD_VAR 0 1
112130: ARRAY
112131: DIFF
112132: ST_TO_ADDR
// for i in mechs do
112133: LD_ADDR_VAR 0 5
112137: PUSH
112138: LD_VAR 0 13
112142: PUSH
112143: FOR_IN
112144: IFFALSE 112179
// if GetTag ( i ) > 0 then
112146: LD_VAR 0 5
112150: PPUSH
112151: CALL_OW 110
112155: PUSH
112156: LD_INT 0
112158: GREATER
112159: IFFALSE 112177
// mechs := mechs diff i ;
112161: LD_ADDR_VAR 0 13
112165: PUSH
112166: LD_VAR 0 13
112170: PUSH
112171: LD_VAR 0 5
112175: DIFF
112176: ST_TO_ADDR
112177: GO 112143
112179: POP
112180: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112181: LD_ADDR_VAR 0 9
112185: PUSH
112186: LD_EXP 93
112190: PUSH
112191: LD_VAR 0 1
112195: ARRAY
112196: PPUSH
112197: LD_INT 2
112199: PUSH
112200: LD_INT 25
112202: PUSH
112203: LD_INT 1
112205: PUSH
112206: EMPTY
112207: LIST
112208: LIST
112209: PUSH
112210: LD_INT 25
112212: PUSH
112213: LD_INT 5
112215: PUSH
112216: EMPTY
112217: LIST
112218: LIST
112219: PUSH
112220: LD_INT 25
112222: PUSH
112223: LD_INT 8
112225: PUSH
112226: EMPTY
112227: LIST
112228: LIST
112229: PUSH
112230: LD_INT 25
112232: PUSH
112233: LD_INT 9
112235: PUSH
112236: EMPTY
112237: LIST
112238: LIST
112239: PUSH
112240: EMPTY
112241: LIST
112242: LIST
112243: LIST
112244: LIST
112245: LIST
112246: PPUSH
112247: CALL_OW 72
112251: ST_TO_ADDR
// if not defenders and not solds then
112252: LD_VAR 0 2
112256: NOT
112257: PUSH
112258: LD_VAR 0 9
112262: NOT
112263: AND
112264: IFFALSE 112268
// exit ;
112266: GO 113958
// depot_under_attack := false ;
112268: LD_ADDR_VAR 0 17
112272: PUSH
112273: LD_INT 0
112275: ST_TO_ADDR
// sold_defenders := [ ] ;
112276: LD_ADDR_VAR 0 18
112280: PUSH
112281: EMPTY
112282: ST_TO_ADDR
// if mechs then
112283: LD_VAR 0 13
112287: IFFALSE 112440
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
112289: LD_ADDR_VAR 0 5
112293: PUSH
112294: LD_VAR 0 2
112298: PPUSH
112299: LD_INT 21
112301: PUSH
112302: LD_INT 2
112304: PUSH
112305: EMPTY
112306: LIST
112307: LIST
112308: PPUSH
112309: CALL_OW 72
112313: PUSH
112314: FOR_IN
112315: IFFALSE 112438
// begin if GetTag ( i ) <> 20 then
112317: LD_VAR 0 5
112321: PPUSH
112322: CALL_OW 110
112326: PUSH
112327: LD_INT 20
112329: NONEQUAL
112330: IFFALSE 112344
// SetTag ( i , 20 ) ;
112332: LD_VAR 0 5
112336: PPUSH
112337: LD_INT 20
112339: PPUSH
112340: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
112344: LD_VAR 0 5
112348: PPUSH
112349: CALL_OW 263
112353: PUSH
112354: LD_INT 1
112356: EQUAL
112357: PUSH
112358: LD_VAR 0 5
112362: PPUSH
112363: CALL_OW 311
112367: NOT
112368: AND
112369: IFFALSE 112436
// begin un := mechs [ 1 ] ;
112371: LD_ADDR_VAR 0 11
112375: PUSH
112376: LD_VAR 0 13
112380: PUSH
112381: LD_INT 1
112383: ARRAY
112384: ST_TO_ADDR
// ComExit ( un ) ;
112385: LD_VAR 0 11
112389: PPUSH
112390: CALL 88244 0 1
// AddComEnterUnit ( un , i ) ;
112394: LD_VAR 0 11
112398: PPUSH
112399: LD_VAR 0 5
112403: PPUSH
112404: CALL_OW 180
// SetTag ( un , 19 ) ;
112408: LD_VAR 0 11
112412: PPUSH
112413: LD_INT 19
112415: PPUSH
112416: CALL_OW 109
// mechs := mechs diff un ;
112420: LD_ADDR_VAR 0 13
112424: PUSH
112425: LD_VAR 0 13
112429: PUSH
112430: LD_VAR 0 11
112434: DIFF
112435: ST_TO_ADDR
// end ; end ;
112436: GO 112314
112438: POP
112439: POP
// if solds then
112440: LD_VAR 0 9
112444: IFFALSE 112503
// for i in solds do
112446: LD_ADDR_VAR 0 5
112450: PUSH
112451: LD_VAR 0 9
112455: PUSH
112456: FOR_IN
112457: IFFALSE 112501
// if not GetTag ( i ) then
112459: LD_VAR 0 5
112463: PPUSH
112464: CALL_OW 110
112468: NOT
112469: IFFALSE 112499
// begin defenders := defenders union i ;
112471: LD_ADDR_VAR 0 2
112475: PUSH
112476: LD_VAR 0 2
112480: PUSH
112481: LD_VAR 0 5
112485: UNION
112486: ST_TO_ADDR
// SetTag ( i , 18 ) ;
112487: LD_VAR 0 5
112491: PPUSH
112492: LD_INT 18
112494: PPUSH
112495: CALL_OW 109
// end ;
112499: GO 112456
112501: POP
112502: POP
// repeat wait ( 0 0$2 ) ;
112503: LD_INT 70
112505: PPUSH
112506: CALL_OW 67
// enemy := mc_scan [ base ] ;
112510: LD_ADDR_VAR 0 3
112514: PUSH
112515: LD_EXP 116
112519: PUSH
112520: LD_VAR 0 1
112524: ARRAY
112525: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112526: LD_EXP 93
112530: PUSH
112531: LD_VAR 0 1
112535: ARRAY
112536: NOT
112537: PUSH
112538: LD_EXP 93
112542: PUSH
112543: LD_VAR 0 1
112547: ARRAY
112548: PUSH
112549: EMPTY
112550: EQUAL
112551: OR
112552: IFFALSE 112589
// begin for i in defenders do
112554: LD_ADDR_VAR 0 5
112558: PUSH
112559: LD_VAR 0 2
112563: PUSH
112564: FOR_IN
112565: IFFALSE 112578
// ComStop ( i ) ;
112567: LD_VAR 0 5
112571: PPUSH
112572: CALL_OW 141
112576: GO 112564
112578: POP
112579: POP
// defenders := [ ] ;
112580: LD_ADDR_VAR 0 2
112584: PUSH
112585: EMPTY
112586: ST_TO_ADDR
// exit ;
112587: GO 113958
// end ; for i in defenders do
112589: LD_ADDR_VAR 0 5
112593: PUSH
112594: LD_VAR 0 2
112598: PUSH
112599: FOR_IN
112600: IFFALSE 113418
// begin e := NearestUnitToUnit ( enemy , i ) ;
112602: LD_ADDR_VAR 0 14
112606: PUSH
112607: LD_VAR 0 3
112611: PPUSH
112612: LD_VAR 0 5
112616: PPUSH
112617: CALL_OW 74
112621: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
112622: LD_ADDR_VAR 0 8
112626: PUSH
112627: LD_EXP 93
112631: PUSH
112632: LD_VAR 0 1
112636: ARRAY
112637: PPUSH
112638: LD_INT 2
112640: PUSH
112641: LD_INT 30
112643: PUSH
112644: LD_INT 0
112646: PUSH
112647: EMPTY
112648: LIST
112649: LIST
112650: PUSH
112651: LD_INT 30
112653: PUSH
112654: LD_INT 1
112656: PUSH
112657: EMPTY
112658: LIST
112659: LIST
112660: PUSH
112661: EMPTY
112662: LIST
112663: LIST
112664: LIST
112665: PPUSH
112666: CALL_OW 72
112670: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
112671: LD_ADDR_VAR 0 17
112675: PUSH
112676: LD_VAR 0 8
112680: NOT
112681: PUSH
112682: LD_VAR 0 8
112686: PPUSH
112687: LD_INT 3
112689: PUSH
112690: LD_INT 24
112692: PUSH
112693: LD_INT 600
112695: PUSH
112696: EMPTY
112697: LIST
112698: LIST
112699: PUSH
112700: EMPTY
112701: LIST
112702: LIST
112703: PPUSH
112704: CALL_OW 72
112708: OR
112709: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
112710: LD_VAR 0 5
112714: PPUSH
112715: CALL_OW 247
112719: PUSH
112720: LD_INT 2
112722: DOUBLE
112723: EQUAL
112724: IFTRUE 112728
112726: GO 113124
112728: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
112729: LD_VAR 0 5
112733: PPUSH
112734: CALL_OW 256
112738: PUSH
112739: LD_INT 1000
112741: EQUAL
112742: PUSH
112743: LD_VAR 0 5
112747: PPUSH
112748: LD_VAR 0 14
112752: PPUSH
112753: CALL_OW 296
112757: PUSH
112758: LD_INT 40
112760: LESS
112761: PUSH
112762: LD_VAR 0 14
112766: PPUSH
112767: LD_EXP 118
112771: PUSH
112772: LD_VAR 0 1
112776: ARRAY
112777: PPUSH
112778: CALL_OW 308
112782: OR
112783: AND
112784: IFFALSE 112906
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
112786: LD_VAR 0 5
112790: PPUSH
112791: CALL_OW 262
112795: PUSH
112796: LD_INT 1
112798: EQUAL
112799: PUSH
112800: LD_VAR 0 5
112804: PPUSH
112805: CALL_OW 261
112809: PUSH
112810: LD_INT 30
112812: LESS
112813: AND
112814: PUSH
112815: LD_VAR 0 8
112819: AND
112820: IFFALSE 112890
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
112822: LD_VAR 0 5
112826: PPUSH
112827: LD_VAR 0 8
112831: PPUSH
112832: LD_VAR 0 5
112836: PPUSH
112837: CALL_OW 74
112841: PPUSH
112842: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
112846: LD_VAR 0 5
112850: PPUSH
112851: LD_VAR 0 8
112855: PPUSH
112856: LD_VAR 0 5
112860: PPUSH
112861: CALL_OW 74
112865: PPUSH
112866: CALL_OW 296
112870: PUSH
112871: LD_INT 6
112873: LESS
112874: IFFALSE 112888
// SetFuel ( i , 100 ) ;
112876: LD_VAR 0 5
112880: PPUSH
112881: LD_INT 100
112883: PPUSH
112884: CALL_OW 240
// end else
112888: GO 112904
// ComAttackUnit ( i , e ) ;
112890: LD_VAR 0 5
112894: PPUSH
112895: LD_VAR 0 14
112899: PPUSH
112900: CALL_OW 115
// end else
112904: GO 113007
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
112906: LD_VAR 0 14
112910: PPUSH
112911: LD_EXP 118
112915: PUSH
112916: LD_VAR 0 1
112920: ARRAY
112921: PPUSH
112922: CALL_OW 308
112926: NOT
112927: PUSH
112928: LD_VAR 0 5
112932: PPUSH
112933: LD_VAR 0 14
112937: PPUSH
112938: CALL_OW 296
112942: PUSH
112943: LD_INT 40
112945: GREATEREQUAL
112946: AND
112947: PUSH
112948: LD_VAR 0 5
112952: PPUSH
112953: CALL_OW 256
112957: PUSH
112958: LD_INT 650
112960: LESSEQUAL
112961: OR
112962: PUSH
112963: LD_VAR 0 5
112967: PPUSH
112968: LD_EXP 117
112972: PUSH
112973: LD_VAR 0 1
112977: ARRAY
112978: PPUSH
112979: CALL_OW 308
112983: NOT
112984: AND
112985: IFFALSE 113007
// ComMoveToArea ( i , mc_parking [ base ] ) ;
112987: LD_VAR 0 5
112991: PPUSH
112992: LD_EXP 117
112996: PUSH
112997: LD_VAR 0 1
113001: ARRAY
113002: PPUSH
113003: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
113007: LD_VAR 0 5
113011: PPUSH
113012: CALL_OW 256
113016: PUSH
113017: LD_INT 1000
113019: LESS
113020: PUSH
113021: LD_VAR 0 5
113025: PPUSH
113026: CALL_OW 263
113030: PUSH
113031: LD_INT 1
113033: EQUAL
113034: AND
113035: PUSH
113036: LD_VAR 0 5
113040: PPUSH
113041: CALL_OW 311
113045: AND
113046: PUSH
113047: LD_VAR 0 5
113051: PPUSH
113052: LD_EXP 117
113056: PUSH
113057: LD_VAR 0 1
113061: ARRAY
113062: PPUSH
113063: CALL_OW 308
113067: AND
113068: IFFALSE 113122
// begin mech := IsDrivenBy ( i ) ;
113070: LD_ADDR_VAR 0 10
113074: PUSH
113075: LD_VAR 0 5
113079: PPUSH
113080: CALL_OW 311
113084: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
113085: LD_VAR 0 10
113089: PPUSH
113090: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
113094: LD_VAR 0 10
113098: PPUSH
113099: LD_VAR 0 5
113103: PPUSH
113104: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
113108: LD_VAR 0 10
113112: PPUSH
113113: LD_VAR 0 5
113117: PPUSH
113118: CALL_OW 180
// end ; end ; unit_human :
113122: GO 113389
113124: LD_INT 1
113126: DOUBLE
113127: EQUAL
113128: IFTRUE 113132
113130: GO 113388
113132: POP
// begin b := IsInUnit ( i ) ;
113133: LD_ADDR_VAR 0 19
113137: PUSH
113138: LD_VAR 0 5
113142: PPUSH
113143: CALL_OW 310
113147: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
113148: LD_ADDR_VAR 0 20
113152: PUSH
113153: LD_VAR 0 19
113157: NOT
113158: PUSH
113159: LD_VAR 0 19
113163: PPUSH
113164: CALL_OW 266
113168: PUSH
113169: LD_INT 32
113171: PUSH
113172: LD_INT 31
113174: PUSH
113175: EMPTY
113176: LIST
113177: LIST
113178: IN
113179: OR
113180: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
113181: LD_VAR 0 17
113185: PUSH
113186: LD_VAR 0 2
113190: PPUSH
113191: LD_INT 21
113193: PUSH
113194: LD_INT 2
113196: PUSH
113197: EMPTY
113198: LIST
113199: LIST
113200: PPUSH
113201: CALL_OW 72
113205: PUSH
113206: LD_INT 1
113208: LESSEQUAL
113209: OR
113210: PUSH
113211: LD_VAR 0 20
113215: AND
113216: PUSH
113217: LD_VAR 0 5
113221: PUSH
113222: LD_VAR 0 18
113226: IN
113227: NOT
113228: AND
113229: IFFALSE 113322
// begin if b then
113231: LD_VAR 0 19
113235: IFFALSE 113284
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
113237: LD_VAR 0 19
113241: PPUSH
113242: LD_VAR 0 3
113246: PPUSH
113247: LD_VAR 0 19
113251: PPUSH
113252: CALL_OW 74
113256: PPUSH
113257: CALL_OW 296
113261: PUSH
113262: LD_INT 10
113264: LESS
113265: PUSH
113266: LD_VAR 0 19
113270: PPUSH
113271: CALL_OW 461
113275: PUSH
113276: LD_INT 7
113278: NONEQUAL
113279: AND
113280: IFFALSE 113284
// continue ;
113282: GO 112599
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
113284: LD_ADDR_VAR 0 18
113288: PUSH
113289: LD_VAR 0 18
113293: PPUSH
113294: LD_VAR 0 18
113298: PUSH
113299: LD_INT 1
113301: PLUS
113302: PPUSH
113303: LD_VAR 0 5
113307: PPUSH
113308: CALL_OW 1
113312: ST_TO_ADDR
// ComExitBuilding ( i ) ;
113313: LD_VAR 0 5
113317: PPUSH
113318: CALL_OW 122
// end ; if sold_defenders then
113322: LD_VAR 0 18
113326: IFFALSE 113386
// if i in sold_defenders then
113328: LD_VAR 0 5
113332: PUSH
113333: LD_VAR 0 18
113337: IN
113338: IFFALSE 113386
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
113340: LD_VAR 0 5
113344: PPUSH
113345: CALL_OW 314
113349: NOT
113350: PUSH
113351: LD_VAR 0 5
113355: PPUSH
113356: LD_VAR 0 14
113360: PPUSH
113361: CALL_OW 296
113365: PUSH
113366: LD_INT 30
113368: LESS
113369: AND
113370: IFFALSE 113386
// ComAttackUnit ( i , e ) ;
113372: LD_VAR 0 5
113376: PPUSH
113377: LD_VAR 0 14
113381: PPUSH
113382: CALL_OW 115
// end ; end ; end ;
113386: GO 113389
113388: POP
// if IsDead ( i ) then
113389: LD_VAR 0 5
113393: PPUSH
113394: CALL_OW 301
113398: IFFALSE 113416
// defenders := defenders diff i ;
113400: LD_ADDR_VAR 0 2
113404: PUSH
113405: LD_VAR 0 2
113409: PUSH
113410: LD_VAR 0 5
113414: DIFF
113415: ST_TO_ADDR
// end ;
113416: GO 112599
113418: POP
113419: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
113420: LD_VAR 0 3
113424: NOT
113425: PUSH
113426: LD_VAR 0 2
113430: NOT
113431: OR
113432: PUSH
113433: LD_EXP 93
113437: PUSH
113438: LD_VAR 0 1
113442: ARRAY
113443: NOT
113444: OR
113445: IFFALSE 112503
// MC_Reset ( base , 18 ) ;
113447: LD_VAR 0 1
113451: PPUSH
113452: LD_INT 18
113454: PPUSH
113455: CALL 24956 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113459: LD_ADDR_VAR 0 2
113463: PUSH
113464: LD_VAR 0 2
113468: PUSH
113469: LD_VAR 0 2
113473: PPUSH
113474: LD_INT 2
113476: PUSH
113477: LD_INT 25
113479: PUSH
113480: LD_INT 1
113482: PUSH
113483: EMPTY
113484: LIST
113485: LIST
113486: PUSH
113487: LD_INT 25
113489: PUSH
113490: LD_INT 5
113492: PUSH
113493: EMPTY
113494: LIST
113495: LIST
113496: PUSH
113497: LD_INT 25
113499: PUSH
113500: LD_INT 8
113502: PUSH
113503: EMPTY
113504: LIST
113505: LIST
113506: PUSH
113507: LD_INT 25
113509: PUSH
113510: LD_INT 9
113512: PUSH
113513: EMPTY
113514: LIST
113515: LIST
113516: PUSH
113517: EMPTY
113518: LIST
113519: LIST
113520: LIST
113521: LIST
113522: LIST
113523: PPUSH
113524: CALL_OW 72
113528: DIFF
113529: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
113530: LD_VAR 0 3
113534: NOT
113535: PUSH
113536: LD_VAR 0 2
113540: PPUSH
113541: LD_INT 21
113543: PUSH
113544: LD_INT 2
113546: PUSH
113547: EMPTY
113548: LIST
113549: LIST
113550: PPUSH
113551: CALL_OW 72
113555: AND
113556: IFFALSE 113894
// begin tmp := FilterByTag ( defenders , 19 ) ;
113558: LD_ADDR_VAR 0 12
113562: PUSH
113563: LD_VAR 0 2
113567: PPUSH
113568: LD_INT 19
113570: PPUSH
113571: CALL 85374 0 2
113575: ST_TO_ADDR
// if tmp then
113576: LD_VAR 0 12
113580: IFFALSE 113650
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
113582: LD_ADDR_VAR 0 12
113586: PUSH
113587: LD_VAR 0 12
113591: PPUSH
113592: LD_INT 25
113594: PUSH
113595: LD_INT 3
113597: PUSH
113598: EMPTY
113599: LIST
113600: LIST
113601: PPUSH
113602: CALL_OW 72
113606: ST_TO_ADDR
// if tmp then
113607: LD_VAR 0 12
113611: IFFALSE 113650
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
113613: LD_ADDR_EXP 105
113617: PUSH
113618: LD_EXP 105
113622: PPUSH
113623: LD_VAR 0 1
113627: PPUSH
113628: LD_EXP 105
113632: PUSH
113633: LD_VAR 0 1
113637: ARRAY
113638: PUSH
113639: LD_VAR 0 12
113643: UNION
113644: PPUSH
113645: CALL_OW 1
113649: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
113650: LD_VAR 0 1
113654: PPUSH
113655: LD_INT 19
113657: PPUSH
113658: CALL 24956 0 2
// repeat wait ( 0 0$1 ) ;
113662: LD_INT 35
113664: PPUSH
113665: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113669: LD_EXP 93
113673: PUSH
113674: LD_VAR 0 1
113678: ARRAY
113679: NOT
113680: PUSH
113681: LD_EXP 93
113685: PUSH
113686: LD_VAR 0 1
113690: ARRAY
113691: PUSH
113692: EMPTY
113693: EQUAL
113694: OR
113695: IFFALSE 113732
// begin for i in defenders do
113697: LD_ADDR_VAR 0 5
113701: PUSH
113702: LD_VAR 0 2
113706: PUSH
113707: FOR_IN
113708: IFFALSE 113721
// ComStop ( i ) ;
113710: LD_VAR 0 5
113714: PPUSH
113715: CALL_OW 141
113719: GO 113707
113721: POP
113722: POP
// defenders := [ ] ;
113723: LD_ADDR_VAR 0 2
113727: PUSH
113728: EMPTY
113729: ST_TO_ADDR
// exit ;
113730: GO 113958
// end ; for i in defenders do
113732: LD_ADDR_VAR 0 5
113736: PUSH
113737: LD_VAR 0 2
113741: PUSH
113742: FOR_IN
113743: IFFALSE 113832
// begin if not IsInArea ( i , mc_parking [ base ] ) then
113745: LD_VAR 0 5
113749: PPUSH
113750: LD_EXP 117
113754: PUSH
113755: LD_VAR 0 1
113759: ARRAY
113760: PPUSH
113761: CALL_OW 308
113765: NOT
113766: IFFALSE 113790
// ComMoveToArea ( i , mc_parking [ base ] ) else
113768: LD_VAR 0 5
113772: PPUSH
113773: LD_EXP 117
113777: PUSH
113778: LD_VAR 0 1
113782: ARRAY
113783: PPUSH
113784: CALL_OW 113
113788: GO 113830
// if GetControl ( i ) = control_manual then
113790: LD_VAR 0 5
113794: PPUSH
113795: CALL_OW 263
113799: PUSH
113800: LD_INT 1
113802: EQUAL
113803: IFFALSE 113830
// if IsDrivenBy ( i ) then
113805: LD_VAR 0 5
113809: PPUSH
113810: CALL_OW 311
113814: IFFALSE 113830
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
113816: LD_VAR 0 5
113820: PPUSH
113821: CALL_OW 311
113825: PPUSH
113826: CALL_OW 121
// end ;
113830: GO 113742
113832: POP
113833: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
113834: LD_VAR 0 2
113838: PPUSH
113839: LD_INT 95
113841: PUSH
113842: LD_EXP 117
113846: PUSH
113847: LD_VAR 0 1
113851: ARRAY
113852: PUSH
113853: EMPTY
113854: LIST
113855: LIST
113856: PPUSH
113857: CALL_OW 72
113861: PUSH
113862: LD_VAR 0 2
113866: EQUAL
113867: PUSH
113868: LD_EXP 116
113872: PUSH
113873: LD_VAR 0 1
113877: ARRAY
113878: OR
113879: PUSH
113880: LD_EXP 93
113884: PUSH
113885: LD_VAR 0 1
113889: ARRAY
113890: NOT
113891: OR
113892: IFFALSE 113662
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
113894: LD_ADDR_EXP 115
113898: PUSH
113899: LD_EXP 115
113903: PPUSH
113904: LD_VAR 0 1
113908: PPUSH
113909: LD_VAR 0 2
113913: PPUSH
113914: LD_INT 21
113916: PUSH
113917: LD_INT 2
113919: PUSH
113920: EMPTY
113921: LIST
113922: LIST
113923: PPUSH
113924: CALL_OW 72
113928: PPUSH
113929: CALL_OW 1
113933: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
113934: LD_VAR 0 1
113938: PPUSH
113939: LD_INT 19
113941: PPUSH
113942: CALL 24956 0 2
// MC_Reset ( base , 20 ) ;
113946: LD_VAR 0 1
113950: PPUSH
113951: LD_INT 20
113953: PPUSH
113954: CALL 24956 0 2
// end ; end_of_file
113958: LD_VAR 0 4
113962: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
113963: LD_VAR 0 1
113967: PUSH
113968: LD_INT 200
113970: DOUBLE
113971: GREATEREQUAL
113972: IFFALSE 113980
113974: LD_INT 299
113976: DOUBLE
113977: LESSEQUAL
113978: IFTRUE 113982
113980: GO 114014
113982: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
113983: LD_VAR 0 1
113987: PPUSH
113988: LD_VAR 0 2
113992: PPUSH
113993: LD_VAR 0 3
113997: PPUSH
113998: LD_VAR 0 4
114002: PPUSH
114003: LD_VAR 0 5
114007: PPUSH
114008: CALL 102896 0 5
114012: GO 114091
114014: LD_INT 300
114016: DOUBLE
114017: GREATEREQUAL
114018: IFFALSE 114026
114020: LD_INT 399
114022: DOUBLE
114023: LESSEQUAL
114024: IFTRUE 114028
114026: GO 114090
114028: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
114029: LD_VAR 0 1
114033: PPUSH
114034: LD_VAR 0 2
114038: PPUSH
114039: LD_VAR 0 3
114043: PPUSH
114044: LD_VAR 0 4
114048: PPUSH
114049: LD_VAR 0 5
114053: PPUSH
114054: LD_VAR 0 6
114058: PPUSH
114059: LD_VAR 0 7
114063: PPUSH
114064: LD_VAR 0 8
114068: PPUSH
114069: LD_VAR 0 9
114073: PPUSH
114074: LD_VAR 0 10
114078: PPUSH
114079: LD_VAR 0 11
114083: PPUSH
114084: CALL 100784 0 11
114088: GO 114091
114090: POP
// end ;
114091: PPOPN 11
114093: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
114094: LD_VAR 0 1
114098: PPUSH
114099: LD_VAR 0 2
114103: PPUSH
114104: LD_VAR 0 3
114108: PPUSH
114109: LD_VAR 0 4
114113: PPUSH
114114: LD_VAR 0 5
114118: PPUSH
114119: CALL 102878 0 5
// end ; end_of_file
114123: PPOPN 5
114125: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
114126: LD_VAR 0 1
114130: PPUSH
114131: LD_VAR 0 2
114135: PPUSH
114136: LD_VAR 0 3
114140: PPUSH
114141: LD_VAR 0 4
114145: PPUSH
114146: LD_VAR 0 5
114150: PPUSH
114151: LD_VAR 0 6
114155: PPUSH
114156: CALL 89592 0 6
// end ;
114160: PPOPN 6
114162: END
