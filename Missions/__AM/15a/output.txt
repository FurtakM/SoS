// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 20634 0 0
// InitMacro ;
  19: CALL 20778 0 0
// InitNature ;
  23: CALL 17304 0 0
// InitArtifact ;
  27: CALL 17917 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 4625 0 0
// PrepareAlliance ;
  48: CALL 1421 0 0
// PrepareArabian ;
  52: CALL 6393 0 0
// PrepareRussian ;
  56: CALL 8378 0 0
// PrepareLegion ;
  60: CALL 6821 0 0
// Action ;
  64: CALL 10931 0 0
// MC_Start ( ) ;
  68: CALL 22890 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ;
 212: LD_VAR 0 1
 216: RET
// export function CustomInitMacro ( ) ; begin
 217: LD_INT 0
 219: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 220: LD_ADDR_EXP 114
 224: PUSH
 225: LD_INT 26
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 4
 233: PUSH
 234: LD_INT 8
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: LIST
 242: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 243: LD_ADDR_EXP 115
 247: PUSH
 248: LD_INT 27
 250: PUSH
 251: LD_INT 2
 253: PUSH
 254: LD_INT 3
 256: PUSH
 257: LD_INT 7
 259: PUSH
 260: EMPTY
 261: LIST
 262: LIST
 263: LIST
 264: LIST
 265: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_INT 6
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: LD_INT 9
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: LIST
 282: PUSH
 283: LD_OWVAR 67
 287: ARRAY
 288: PPUSH
 289: LD_INT 28
 291: PPUSH
 292: CALL 44160 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 10
 301: PUSH
 302: LD_INT 11
 304: PUSH
 305: LD_INT 13
 307: PUSH
 308: LD_INT 15
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: LIST
 316: PPUSH
 317: CALL 45220 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 29
 326: PUSH
 327: EMPTY
 328: LIST
 329: PPUSH
 330: CALL 45313 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 334: LD_ADDR_EXP 119
 338: PUSH
 339: LD_EXP 119
 343: PPUSH
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 22
 349: PUSH
 350: LD_INT 2
 352: PUSH
 353: EMPTY
 354: LIST
 355: LIST
 356: PUSH
 357: LD_INT 25
 359: PUSH
 360: LD_INT 15
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL_OW 69
 375: PPUSH
 376: CALL_OW 1
 380: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 13
 386: PUSH
 387: LD_INT 2
 389: PUSH
 390: LD_INT 1
 392: PUSH
 393: LD_INT 31
 395: PUSH
 396: EMPTY
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: PUSH
 402: LD_INT 13
 404: PUSH
 405: LD_INT 2
 407: PUSH
 408: LD_INT 1
 410: PUSH
 411: LD_INT 31
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: LIST
 419: PUSH
 420: LD_INT 13
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 1
 428: PUSH
 429: LD_INT 28
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_INT 13
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 1
 446: PUSH
 447: LD_INT 28
 449: PUSH
 450: EMPTY
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_INT 13
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 28
 467: PUSH
 468: EMPTY
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: PUSH
 474: LD_INT 13
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 28
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_INT 13
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 2
 500: PUSH
 501: LD_EXP 78
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PPUSH
 521: CALL 44478 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 525: LD_INT 1
 527: PPUSH
 528: LD_INT 4
 530: PPUSH
 531: CALL 44663 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 10
 540: PUSH
 541: LD_INT 11
 543: PUSH
 544: LD_INT 12
 546: PUSH
 547: LD_INT 14
 549: PUSH
 550: EMPTY
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 45220 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 14
 565: PUSH
 566: EMPTY
 567: LIST
 568: PPUSH
 569: CALL 45313 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 21
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 51
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 22
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 3
 602: PUSH
 603: LD_INT 52
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 22
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 3
 620: PUSH
 621: LD_INT 52
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: LD_INT 24
 632: PUSH
 633: LD_INT 3
 635: PUSH
 636: LD_INT 3
 638: PUSH
 639: LD_INT 47
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: LIST
 646: LIST
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: LD_INT 3
 653: PUSH
 654: LD_INT 3
 656: PUSH
 657: LD_INT 47
 659: PUSH
 660: EMPTY
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: PUSH
 666: LD_INT 24
 668: PUSH
 669: LD_INT 3
 671: PUSH
 672: LD_INT 3
 674: PUSH
 675: LD_INT 47
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: LD_INT 3
 689: PUSH
 690: LD_INT 3
 692: PUSH
 693: LD_INT 47
 695: PUSH
 696: EMPTY
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_INT 24
 704: PUSH
 705: LD_INT 3
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 47
 713: PUSH
 714: EMPTY
 715: LIST
 716: LIST
 717: LIST
 718: LIST
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PPUSH
 730: CALL 44478 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 734: LD_INT 2
 736: PPUSH
 737: LD_INT 5
 739: PPUSH
 740: CALL 44663 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 744: LD_INT 2
 746: PPUSH
 747: LD_INT 0
 749: PPUSH
 750: CALL 45093 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 754: LD_INT 3
 756: PPUSH
 757: LD_INT 10
 759: PUSH
 760: LD_INT 12
 762: PUSH
 763: LD_INT 15
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_OWVAR 67
 775: ARRAY
 776: PPUSH
 777: LD_INT 24
 779: PPUSH
 780: CALL 44160 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 10
 789: PUSH
 790: LD_INT 11
 792: PUSH
 793: LD_INT 13
 795: PUSH
 796: LD_INT 15
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL 45220 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 809: LD_INT 3
 811: PPUSH
 812: LD_INT 13
 814: PUSH
 815: EMPTY
 816: LIST
 817: PPUSH
 818: CALL 45313 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 822: LD_ADDR_EXP 119
 826: PUSH
 827: LD_EXP 119
 831: PPUSH
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 22
 837: PUSH
 838: LD_INT 8
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 25
 847: PUSH
 848: LD_INT 15
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL_OW 69
 863: PPUSH
 864: CALL_OW 1
 868: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 869: LD_INT 3
 871: PPUSH
 872: LD_INT 13
 874: PUSH
 875: LD_INT 2
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 31
 883: PUSH
 884: EMPTY
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 13
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 1
 898: PUSH
 899: LD_INT 31
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_INT 13
 910: PUSH
 911: LD_INT 3
 913: PUSH
 914: LD_INT 2
 916: PUSH
 917: LD_INT 32
 919: PUSH
 920: EMPTY
 921: LIST
 922: LIST
 923: LIST
 924: LIST
 925: PUSH
 926: LD_INT 14
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 1
 934: PUSH
 935: LD_INT 28
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_INT 14
 946: PUSH
 947: LD_INT 1
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 28
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: LIST
 960: LIST
 961: PUSH
 962: LD_INT 14
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 28
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: PUSH
 980: LD_INT 14
 982: PUSH
 983: LD_INT 1
 985: PUSH
 986: LD_INT 1
 988: PUSH
 989: LD_INT 28
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: PUSH
 998: LD_INT 14
1000: PUSH
1001: LD_INT 1
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_EXP 78
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL 44478 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1032: LD_INT 3
1034: PPUSH
1035: LD_INT 4
1037: PPUSH
1038: CALL 44663 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1042: LD_INT 4
1044: PPUSH
1045: LD_INT 10
1047: PUSH
1048: LD_INT 12
1050: PUSH
1051: LD_INT 11
1053: PUSH
1054: LD_INT 15
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PPUSH
1063: CALL 45220 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1067: LD_INT 4
1069: PPUSH
1070: LD_INT 33
1072: PUSH
1073: EMPTY
1074: LIST
1075: PPUSH
1076: CALL 45313 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1080: LD_INT 4
1082: PPUSH
1083: LD_INT 5
1085: PUSH
1086: LD_INT 6
1088: PUSH
1089: LD_INT 7
1091: PUSH
1092: LD_INT 9
1094: PUSH
1095: LD_INT 10
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: PPUSH
1105: CALL 45631 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1109: LD_INT 4
1111: PPUSH
1112: LD_INT 54
1114: PPUSH
1115: LD_INT 85
1117: PPUSH
1118: LD_INT 2
1120: PPUSH
1121: LD_INT 25
1123: PUSH
1124: LD_INT 16
1126: PUSH
1127: LD_INT 17
1129: PUSH
1130: LD_INT 18
1132: PUSH
1133: LD_INT 22
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: PPUSH
1143: CALL 45425 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1147: LD_INT 4
1149: PPUSH
1150: LD_INT 5
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: LD_INT 1
1158: PUSH
1159: LD_INT 7
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 5
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 1
1176: PUSH
1177: LD_INT 6
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 5
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 7
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 5
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 6
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 5
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 3
1230: PUSH
1231: LD_INT 12
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 3
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: LD_INT 3
1248: PUSH
1249: LD_INT 13
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 44478 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 4
1275: PPUSH
1276: CALL 44663 0 2
// MC_SetTame ( 4 , powellApe ) ;
1280: LD_INT 4
1282: PPUSH
1283: LD_INT 11
1285: PPUSH
1286: CALL 45044 0 2
// end ;
1290: LD_VAR 0 1
1294: RET
// every 0 0$1 trigger debug do var i ;
1295: LD_EXP 1
1299: IFFALSE 1397
1301: GO 1303
1303: DISABLE
1304: LD_INT 0
1306: PPUSH
// begin enable ;
1307: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1308: LD_ADDR_VAR 0 1
1312: PUSH
1313: LD_INT 22
1315: PUSH
1316: LD_INT 7
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 2
1325: PUSH
1326: LD_INT 21
1328: PUSH
1329: LD_INT 1
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: PUSH
1336: LD_INT 21
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 3
1353: PUSH
1354: LD_INT 24
1356: PUSH
1357: LD_INT 1000
1359: PUSH
1360: EMPTY
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: PUSH
1378: FOR_IN
1379: IFFALSE 1395
// SetLives ( i , 1000 ) ;
1381: LD_VAR 0 1
1385: PPUSH
1386: LD_INT 1000
1388: PPUSH
1389: CALL_OW 234
1393: GO 1378
1395: POP
1396: POP
// end ;
1397: PPOPN 1
1399: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1400: LD_EXP 16
1404: PUSH
1405: LD_INT 5
1407: GREATEREQUAL
1408: IFFALSE 1420
1410: GO 1412
1412: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1413: LD_STRING ACH_ARTIFACT
1415: PPUSH
1416: CALL_OW 543
1420: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1421: LD_INT 0
1423: PPUSH
1424: PPUSH
1425: PPUSH
1426: PPUSH
1427: PPUSH
// uc_side := 7 ;
1428: LD_ADDR_OWVAR 20
1432: PUSH
1433: LD_INT 7
1435: ST_TO_ADDR
// tmp := [ ] ;
1436: LD_ADDR_VAR 0 5
1440: PUSH
1441: EMPTY
1442: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1443: LD_ADDR_EXP 17
1447: PUSH
1448: LD_STRING JMM
1450: PPUSH
1451: LD_EXP 1
1455: NOT
1456: PPUSH
1457: LD_STRING 14a_
1459: PPUSH
1460: CALL 50889 0 3
1464: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1465: LD_ADDR_EXP 49
1469: PUSH
1470: LD_STRING Burlak
1472: PPUSH
1473: LD_EXP 1
1477: NOT
1478: PPUSH
1479: LD_STRING 14a_
1481: PPUSH
1482: CALL 50889 0 3
1486: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1487: LD_ADDR_EXP 32
1491: PUSH
1492: LD_STRING Joan
1494: PPUSH
1495: LD_EXP 1
1499: NOT
1500: PPUSH
1501: LD_STRING 13a_
1503: PPUSH
1504: CALL 50889 0 3
1508: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1509: LD_ADDR_EXP 18
1513: PUSH
1514: LD_STRING Roth
1516: PPUSH
1517: LD_EXP 1
1521: NOT
1522: PPUSH
1523: LD_STRING 13a_
1525: PPUSH
1526: CALL 50889 0 3
1530: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1531: LD_ADDR_EXP 35
1535: PUSH
1536: LD_STRING Gossudarov
1538: PPUSH
1539: LD_EXP 1
1543: NOT
1544: PPUSH
1545: LD_STRING 13a_
1547: PPUSH
1548: CALL 50889 0 3
1552: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1553: LD_ADDR_EXP 23
1557: PUSH
1558: LD_STRING Denis
1560: PPUSH
1561: LD_EXP 1
1565: NOT
1566: PPUSH
1567: LD_STRING 13a_
1569: PPUSH
1570: CALL 50889 0 3
1574: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1575: LD_ADDR_EXP 33
1579: PUSH
1580: LD_STRING DeltaDoctor
1582: PPUSH
1583: LD_EXP 1
1587: NOT
1588: PPUSH
1589: LD_STRING 13a_
1591: PPUSH
1592: CALL 50889 0 3
1596: ST_TO_ADDR
// if DeltaDoctor then
1597: LD_EXP 33
1601: IFFALSE 1619
// tmp := tmp ^ DeltaDoctor ;
1603: LD_ADDR_VAR 0 5
1607: PUSH
1608: LD_VAR 0 5
1612: PUSH
1613: LD_EXP 33
1617: ADD
1618: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1619: LD_ADDR_EXP 31
1623: PUSH
1624: LD_STRING Simms
1626: PPUSH
1627: LD_EXP 1
1631: NOT
1632: PPUSH
1633: LD_STRING 13a_
1635: PPUSH
1636: CALL 50889 0 3
1640: ST_TO_ADDR
// if Simms then
1641: LD_EXP 31
1645: IFFALSE 1663
// tmp := tmp ^ Simms ;
1647: LD_ADDR_VAR 0 5
1651: PUSH
1652: LD_VAR 0 5
1656: PUSH
1657: LD_EXP 31
1661: ADD
1662: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1663: LD_ADDR_EXP 29
1667: PUSH
1668: LD_STRING Frank
1670: PPUSH
1671: LD_EXP 1
1675: NOT
1676: PPUSH
1677: LD_STRING 13a_
1679: PPUSH
1680: CALL 50889 0 3
1684: ST_TO_ADDR
// if Frank then
1685: LD_EXP 29
1689: IFFALSE 1707
// tmp := tmp ^ Frank ;
1691: LD_ADDR_VAR 0 5
1695: PUSH
1696: LD_VAR 0 5
1700: PUSH
1701: LD_EXP 29
1705: ADD
1706: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1707: LD_ADDR_EXP 36
1711: PUSH
1712: LD_STRING Kirilenkova
1714: PPUSH
1715: LD_EXP 1
1719: NOT
1720: PPUSH
1721: LD_STRING 13a_
1723: PPUSH
1724: CALL 50889 0 3
1728: ST_TO_ADDR
// if Kirilenkova then
1729: LD_EXP 36
1733: IFFALSE 1751
// tmp := tmp ^ Kirilenkova ;
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 5
1744: PUSH
1745: LD_EXP 36
1749: ADD
1750: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1751: LD_ADDR_EXP 37
1755: PUSH
1756: LD_STRING Titov
1758: PPUSH
1759: LD_EXP 1
1763: NOT
1764: PPUSH
1765: LD_STRING 13a_
1767: PPUSH
1768: CALL 50889 0 3
1772: ST_TO_ADDR
// if Titov then
1773: LD_EXP 37
1777: IFFALSE 1795
// tmp := tmp ^ Titov ;
1779: LD_ADDR_VAR 0 5
1783: PUSH
1784: LD_VAR 0 5
1788: PUSH
1789: LD_EXP 37
1793: ADD
1794: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1795: LD_ADDR_EXP 38
1799: PUSH
1800: LD_STRING Fadeev
1802: PPUSH
1803: LD_EXP 1
1807: NOT
1808: PPUSH
1809: LD_STRING 13a_
1811: PPUSH
1812: CALL 50889 0 3
1816: ST_TO_ADDR
// if Fadeev then
1817: LD_EXP 38
1821: IFFALSE 1839
// tmp := tmp ^ Fadeev ;
1823: LD_ADDR_VAR 0 5
1827: PUSH
1828: LD_VAR 0 5
1832: PUSH
1833: LD_EXP 38
1837: ADD
1838: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1839: LD_ADDR_EXP 39
1843: PUSH
1844: LD_STRING Dolgov
1846: PPUSH
1847: LD_EXP 1
1851: NOT
1852: PPUSH
1853: LD_STRING 13a_
1855: PPUSH
1856: CALL 50889 0 3
1860: ST_TO_ADDR
// if Dolgov then
1861: LD_EXP 39
1865: IFFALSE 1883
// tmp := tmp ^ Dolgov ;
1867: LD_ADDR_VAR 0 5
1871: PUSH
1872: LD_VAR 0 5
1876: PUSH
1877: LD_EXP 39
1881: ADD
1882: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1883: LD_ADDR_EXP 40
1887: PUSH
1888: LD_STRING Petrosyan
1890: PPUSH
1891: LD_EXP 1
1895: NOT
1896: PPUSH
1897: LD_STRING 13a_
1899: PPUSH
1900: CALL 50889 0 3
1904: ST_TO_ADDR
// if Petrosyan then
1905: LD_EXP 40
1909: IFFALSE 1927
// tmp := tmp ^ Petrosyan ;
1911: LD_ADDR_VAR 0 5
1915: PUSH
1916: LD_VAR 0 5
1920: PUSH
1921: LD_EXP 40
1925: ADD
1926: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1927: LD_ADDR_EXP 41
1931: PUSH
1932: LD_STRING Scholtze
1934: PPUSH
1935: LD_EXP 1
1939: NOT
1940: PPUSH
1941: LD_STRING 13a_
1943: PPUSH
1944: CALL 50889 0 3
1948: ST_TO_ADDR
// if Scholtze then
1949: LD_EXP 41
1953: IFFALSE 1971
// tmp := tmp ^ Scholtze ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_VAR 0 5
1964: PUSH
1965: LD_EXP 41
1969: ADD
1970: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1971: LD_ADDR_EXP 42
1975: PUSH
1976: LD_STRING Oblukov
1978: PPUSH
1979: LD_EXP 1
1983: NOT
1984: PPUSH
1985: LD_STRING 13a_
1987: PPUSH
1988: CALL 50889 0 3
1992: ST_TO_ADDR
// if Oblukov then
1993: LD_EXP 42
1997: IFFALSE 2015
// tmp := tmp ^ Oblukov ;
1999: LD_ADDR_VAR 0 5
2003: PUSH
2004: LD_VAR 0 5
2008: PUSH
2009: LD_EXP 42
2013: ADD
2014: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2015: LD_ADDR_EXP 43
2019: PUSH
2020: LD_STRING Kapitsova
2022: PPUSH
2023: LD_EXP 1
2027: NOT
2028: PPUSH
2029: LD_STRING 13a_
2031: PPUSH
2032: CALL 50889 0 3
2036: ST_TO_ADDR
// if Kapitsova then
2037: LD_EXP 43
2041: IFFALSE 2059
// tmp := tmp ^ Kapitsova ;
2043: LD_ADDR_VAR 0 5
2047: PUSH
2048: LD_VAR 0 5
2052: PUSH
2053: LD_EXP 43
2057: ADD
2058: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2059: LD_ADDR_EXP 44
2063: PUSH
2064: LD_STRING Lipshchin
2066: PPUSH
2067: LD_EXP 1
2071: NOT
2072: PPUSH
2073: LD_STRING 13a_
2075: PPUSH
2076: CALL 50889 0 3
2080: ST_TO_ADDR
// if Lipshchin then
2081: LD_EXP 44
2085: IFFALSE 2103
// tmp := tmp ^ Lipshchin ;
2087: LD_ADDR_VAR 0 5
2091: PUSH
2092: LD_VAR 0 5
2096: PUSH
2097: LD_EXP 44
2101: ADD
2102: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2103: LD_ADDR_EXP 45
2107: PUSH
2108: LD_STRING Petrovova
2110: PPUSH
2111: LD_EXP 1
2115: NOT
2116: PPUSH
2117: LD_STRING 13a_
2119: PPUSH
2120: CALL 50889 0 3
2124: ST_TO_ADDR
// if Petrovova then
2125: LD_EXP 45
2129: IFFALSE 2147
// tmp := tmp ^ Petrovova ;
2131: LD_ADDR_VAR 0 5
2135: PUSH
2136: LD_VAR 0 5
2140: PUSH
2141: LD_EXP 45
2145: ADD
2146: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2147: LD_ADDR_EXP 46
2151: PUSH
2152: LD_STRING Kovalyuk
2154: PPUSH
2155: LD_EXP 1
2159: NOT
2160: PPUSH
2161: LD_STRING 13a_
2163: PPUSH
2164: CALL 50889 0 3
2168: ST_TO_ADDR
// if Kovalyuk then
2169: LD_EXP 46
2173: IFFALSE 2191
// tmp := tmp ^ Kovalyuk ;
2175: LD_ADDR_VAR 0 5
2179: PUSH
2180: LD_VAR 0 5
2184: PUSH
2185: LD_EXP 46
2189: ADD
2190: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2191: LD_ADDR_EXP 47
2195: PUSH
2196: LD_STRING Kuzmov
2198: PPUSH
2199: LD_EXP 1
2203: NOT
2204: PPUSH
2205: LD_STRING 13a_
2207: PPUSH
2208: CALL 50889 0 3
2212: ST_TO_ADDR
// if Kuzmov then
2213: LD_EXP 47
2217: IFFALSE 2235
// tmp := tmp ^ Kuzmov ;
2219: LD_ADDR_VAR 0 5
2223: PUSH
2224: LD_VAR 0 5
2228: PUSH
2229: LD_EXP 47
2233: ADD
2234: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: LD_STRING Karamazov
2242: PPUSH
2243: LD_EXP 1
2247: NOT
2248: PPUSH
2249: LD_STRING 13a_
2251: PPUSH
2252: CALL 50889 0 3
2256: ST_TO_ADDR
// if Karamazov then
2257: LD_EXP 48
2261: IFFALSE 2279
// tmp := tmp ^ Karamazov ;
2263: LD_ADDR_VAR 0 5
2267: PUSH
2268: LD_VAR 0 5
2272: PUSH
2273: LD_EXP 48
2277: ADD
2278: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2279: LD_ADDR_EXP 50
2283: PUSH
2284: LD_STRING Belkov
2286: PPUSH
2287: LD_EXP 1
2291: NOT
2292: PPUSH
2293: LD_STRING 13a_
2295: PPUSH
2296: CALL 50889 0 3
2300: ST_TO_ADDR
// if Belkov then
2301: LD_EXP 50
2305: IFFALSE 2323
// tmp := tmp ^ Belkov ;
2307: LD_ADDR_VAR 0 5
2311: PUSH
2312: LD_VAR 0 5
2316: PUSH
2317: LD_EXP 50
2321: ADD
2322: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2323: LD_ADDR_EXP 51
2327: PUSH
2328: LD_STRING Gnyevko
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_STRING 13a_
2339: PPUSH
2340: CALL 50889 0 3
2344: ST_TO_ADDR
// if Gnyevko then
2345: LD_EXP 51
2349: IFFALSE 2367
// tmp := tmp ^ Gnyevko ;
2351: LD_ADDR_VAR 0 5
2355: PUSH
2356: LD_VAR 0 5
2360: PUSH
2361: LD_EXP 51
2365: ADD
2366: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2367: LD_ADDR_EXP 34
2371: PUSH
2372: LD_STRING Coonie
2374: PPUSH
2375: CALL_OW 25
2379: ST_TO_ADDR
// if not Lisa then
2380: LD_EXP 19
2384: NOT
2385: IFFALSE 2431
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2387: LD_ADDR_EXP 19
2391: PUSH
2392: LD_STRING Lisa
2394: PPUSH
2395: LD_EXP 1
2399: NOT
2400: PPUSH
2401: LD_STRING 13a_
2403: PPUSH
2404: CALL 50889 0 3
2408: ST_TO_ADDR
// if Lisa then
2409: LD_EXP 19
2413: IFFALSE 2431
// tmp := tmp ^ Lisa ;
2415: LD_ADDR_VAR 0 5
2419: PUSH
2420: LD_VAR 0 5
2424: PUSH
2425: LD_EXP 19
2429: ADD
2430: ST_TO_ADDR
// end ; if not Donaldson then
2431: LD_EXP 20
2435: NOT
2436: IFFALSE 2482
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2438: LD_ADDR_EXP 20
2442: PUSH
2443: LD_STRING Donaldson
2445: PPUSH
2446: LD_EXP 1
2450: NOT
2451: PPUSH
2452: LD_STRING 13a_
2454: PPUSH
2455: CALL 50889 0 3
2459: ST_TO_ADDR
// if Donaldson then
2460: LD_EXP 20
2464: IFFALSE 2482
// tmp := tmp ^ Donaldson ;
2466: LD_ADDR_VAR 0 5
2470: PUSH
2471: LD_VAR 0 5
2475: PUSH
2476: LD_EXP 20
2480: ADD
2481: ST_TO_ADDR
// end ; if not Bobby then
2482: LD_EXP 21
2486: NOT
2487: IFFALSE 2533
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2489: LD_ADDR_EXP 21
2493: PUSH
2494: LD_STRING Bobby
2496: PPUSH
2497: LD_EXP 1
2501: NOT
2502: PPUSH
2503: LD_STRING 13a_
2505: PPUSH
2506: CALL 50889 0 3
2510: ST_TO_ADDR
// if Bobby then
2511: LD_EXP 21
2515: IFFALSE 2533
// tmp := tmp ^ Bobby ;
2517: LD_ADDR_VAR 0 5
2521: PUSH
2522: LD_VAR 0 5
2526: PUSH
2527: LD_EXP 21
2531: ADD
2532: ST_TO_ADDR
// end ; if not Cyrus then
2533: LD_EXP 22
2537: NOT
2538: IFFALSE 2584
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2540: LD_ADDR_EXP 22
2544: PUSH
2545: LD_STRING Cyrus
2547: PPUSH
2548: LD_EXP 1
2552: NOT
2553: PPUSH
2554: LD_STRING 13a_
2556: PPUSH
2557: CALL 50889 0 3
2561: ST_TO_ADDR
// if Cyrus then
2562: LD_EXP 22
2566: IFFALSE 2584
// tmp := tmp ^ Cyrus ;
2568: LD_ADDR_VAR 0 5
2572: PUSH
2573: LD_VAR 0 5
2577: PUSH
2578: LD_EXP 22
2582: ADD
2583: ST_TO_ADDR
// end ; if not Brown then
2584: LD_EXP 24
2588: NOT
2589: IFFALSE 2635
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2591: LD_ADDR_EXP 24
2595: PUSH
2596: LD_STRING Brown
2598: PPUSH
2599: LD_EXP 1
2603: NOT
2604: PPUSH
2605: LD_STRING 13a_
2607: PPUSH
2608: CALL 50889 0 3
2612: ST_TO_ADDR
// if Brown then
2613: LD_EXP 24
2617: IFFALSE 2635
// tmp := tmp ^ Brown ;
2619: LD_ADDR_VAR 0 5
2623: PUSH
2624: LD_VAR 0 5
2628: PUSH
2629: LD_EXP 24
2633: ADD
2634: ST_TO_ADDR
// end ; if not Gladstone then
2635: LD_EXP 25
2639: NOT
2640: IFFALSE 2686
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2642: LD_ADDR_EXP 25
2646: PUSH
2647: LD_STRING Gladstone
2649: PPUSH
2650: LD_EXP 1
2654: NOT
2655: PPUSH
2656: LD_STRING 13a_
2658: PPUSH
2659: CALL 50889 0 3
2663: ST_TO_ADDR
// if Gladstone then
2664: LD_EXP 25
2668: IFFALSE 2686
// tmp := tmp ^ Gladstone ;
2670: LD_ADDR_VAR 0 5
2674: PUSH
2675: LD_VAR 0 5
2679: PUSH
2680: LD_EXP 25
2684: ADD
2685: ST_TO_ADDR
// end ; if not Cornel then
2686: LD_EXP 27
2690: NOT
2691: IFFALSE 2737
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2693: LD_ADDR_EXP 27
2697: PUSH
2698: LD_STRING Cornel
2700: PPUSH
2701: LD_EXP 1
2705: NOT
2706: PPUSH
2707: LD_STRING 13a_
2709: PPUSH
2710: CALL 50889 0 3
2714: ST_TO_ADDR
// if Cornel then
2715: LD_EXP 27
2719: IFFALSE 2737
// tmp := tmp ^ Cornel ;
2721: LD_ADDR_VAR 0 5
2725: PUSH
2726: LD_VAR 0 5
2730: PUSH
2731: LD_EXP 27
2735: ADD
2736: ST_TO_ADDR
// end ; if not Houten then
2737: LD_EXP 26
2741: NOT
2742: IFFALSE 2788
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2744: LD_ADDR_EXP 26
2748: PUSH
2749: LD_STRING Houten
2751: PPUSH
2752: LD_EXP 1
2756: NOT
2757: PPUSH
2758: LD_STRING 13a_
2760: PPUSH
2761: CALL 50889 0 3
2765: ST_TO_ADDR
// if Houten then
2766: LD_EXP 26
2770: IFFALSE 2788
// tmp := tmp ^ Houten ;
2772: LD_ADDR_VAR 0 5
2776: PUSH
2777: LD_VAR 0 5
2781: PUSH
2782: LD_EXP 26
2786: ADD
2787: ST_TO_ADDR
// end ; if not Gary then
2788: LD_EXP 28
2792: NOT
2793: IFFALSE 2839
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2795: LD_ADDR_EXP 28
2799: PUSH
2800: LD_STRING Gary
2802: PPUSH
2803: LD_EXP 1
2807: NOT
2808: PPUSH
2809: LD_STRING 13a_
2811: PPUSH
2812: CALL 50889 0 3
2816: ST_TO_ADDR
// if Gary then
2817: LD_EXP 28
2821: IFFALSE 2839
// tmp := tmp ^ Gary ;
2823: LD_ADDR_VAR 0 5
2827: PUSH
2828: LD_VAR 0 5
2832: PUSH
2833: LD_EXP 28
2837: ADD
2838: ST_TO_ADDR
// end ; if not Kikuchi then
2839: LD_EXP 30
2843: NOT
2844: IFFALSE 2890
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2846: LD_ADDR_EXP 30
2850: PUSH
2851: LD_STRING Kikuchi
2853: PPUSH
2854: LD_EXP 1
2858: NOT
2859: PPUSH
2860: LD_STRING 13a_
2862: PPUSH
2863: CALL 50889 0 3
2867: ST_TO_ADDR
// if Kikuchi then
2868: LD_EXP 30
2872: IFFALSE 2890
// tmp := tmp ^ Kikuchi ;
2874: LD_ADDR_VAR 0 5
2878: PUSH
2879: LD_VAR 0 5
2883: PUSH
2884: LD_EXP 30
2888: ADD
2889: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2890: LD_ADDR_VAR 0 5
2894: PUSH
2895: LD_VAR 0 5
2899: PUSH
2900: LD_STRING 13a_others
2902: PPUSH
2903: CALL_OW 31
2907: UNION
2908: ST_TO_ADDR
// tmp := tmp diff 0 ;
2909: LD_ADDR_VAR 0 5
2913: PUSH
2914: LD_VAR 0 5
2918: PUSH
2919: LD_INT 0
2921: DIFF
2922: ST_TO_ADDR
// if tmp < 15 then
2923: LD_VAR 0 5
2927: PUSH
2928: LD_INT 15
2930: LESS
2931: IFFALSE 3019
// for i = 15 downto tmp do
2933: LD_ADDR_VAR 0 2
2937: PUSH
2938: DOUBLE
2939: LD_INT 15
2941: INC
2942: ST_TO_ADDR
2943: LD_VAR 0 5
2947: PUSH
2948: FOR_DOWNTO
2949: IFFALSE 3017
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2951: LD_ADDR_OWVAR 21
2955: PUSH
2956: LD_INT 1
2958: PUSH
2959: LD_INT 3
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: PUSH
2966: LD_INT 1
2968: PPUSH
2969: LD_INT 2
2971: PPUSH
2972: CALL_OW 12
2976: ARRAY
2977: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2978: LD_INT 0
2980: PPUSH
2981: LD_INT 1
2983: PPUSH
2984: LD_INT 4
2986: PPUSH
2987: CALL_OW 12
2991: PPUSH
2992: LD_INT 8
2994: PPUSH
2995: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2999: LD_ADDR_VAR 0 5
3003: PUSH
3004: LD_VAR 0 5
3008: PUSH
3009: CALL_OW 44
3013: ADD
3014: ST_TO_ADDR
// end ;
3015: GO 2948
3017: POP
3018: POP
// if not debug then
3019: LD_EXP 1
3023: NOT
3024: IFFALSE 3196
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3026: LD_ADDR_VAR 0 4
3030: PUSH
3031: LD_STRING 
3033: PPUSH
3034: LD_INT 15
3036: PUSH
3037: LD_INT 14
3039: PUSH
3040: LD_INT 13
3042: PUSH
3043: EMPTY
3044: LIST
3045: LIST
3046: LIST
3047: PUSH
3048: LD_OWVAR 67
3052: ARRAY
3053: PPUSH
3054: LD_INT 15
3056: PUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 13
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: PUSH
3068: LD_OWVAR 67
3072: ARRAY
3073: PPUSH
3074: LD_INT -5
3076: PUSH
3077: LD_EXP 17
3081: PUSH
3082: LD_EXP 49
3086: PUSH
3087: LD_EXP 18
3091: PUSH
3092: LD_EXP 32
3096: PUSH
3097: LD_EXP 23
3101: PUSH
3102: LD_EXP 35
3106: PUSH
3107: LD_INT -2
3109: PUSH
3110: LD_INT -3
3112: PUSH
3113: LD_INT -5
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: LIST
3126: LIST
3127: PUSH
3128: LD_VAR 0 5
3132: ADD
3133: PPUSH
3134: LD_INT 1
3136: PUSH
3137: LD_INT 4
3139: PUSH
3140: LD_INT 2
3142: PUSH
3143: LD_INT 1
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 3
3152: PUSH
3153: LD_INT 5
3155: PUSH
3156: LD_INT 0
3158: PUSH
3159: LD_INT 3
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: LIST
3166: PUSH
3167: LD_INT 9
3169: PUSH
3170: LD_INT 0
3172: PUSH
3173: LD_INT 3
3175: PUSH
3176: EMPTY
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: LIST
3185: LIST
3186: LIST
3187: LIST
3188: PPUSH
3189: CALL_OW 42
3193: ST_TO_ADDR
3194: GO 3275
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3196: LD_ADDR_VAR 0 4
3200: PUSH
3201: LD_EXP 37
3205: PUSH
3206: LD_EXP 38
3210: PUSH
3211: LD_EXP 39
3215: PUSH
3216: LD_EXP 40
3220: PUSH
3221: LD_EXP 41
3225: PUSH
3226: LD_EXP 42
3230: PUSH
3231: LD_EXP 43
3235: PUSH
3236: LD_EXP 44
3240: PUSH
3241: LD_EXP 45
3245: PUSH
3246: LD_EXP 46
3250: PUSH
3251: LD_EXP 47
3255: PUSH
3256: LD_EXP 48
3260: PUSH
3261: EMPTY
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: ST_TO_ADDR
// uc_nation := 1 ;
3275: LD_ADDR_OWVAR 21
3279: PUSH
3280: LD_INT 1
3282: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3283: LD_INT 5
3285: PPUSH
3286: LD_INT 3
3288: PPUSH
3289: LD_INT 1
3291: PPUSH
3292: LD_INT 6
3294: PPUSH
3295: LD_INT 100
3297: PPUSH
3298: CALL 55713 0 5
// veh := CreateVehicle ;
3302: LD_ADDR_VAR 0 3
3306: PUSH
3307: CALL_OW 45
3311: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3312: LD_VAR 0 3
3316: PPUSH
3317: LD_INT 7
3319: NEG
3320: PPUSH
3321: CALL_OW 242
// SetDir ( veh , 3 ) ;
3325: LD_VAR 0 3
3329: PPUSH
3330: LD_INT 3
3332: PPUSH
3333: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3337: LD_VAR 0 3
3341: PPUSH
3342: LD_INT 31
3344: PPUSH
3345: LD_INT 0
3347: PPUSH
3348: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3352: LD_EXP 17
3356: PPUSH
3357: LD_VAR 0 3
3361: PPUSH
3362: CALL_OW 52
// if Joan then
3366: LD_EXP 32
3370: IFFALSE 3442
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3372: LD_INT 3
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 1
3380: PPUSH
3381: LD_INT 11
3383: PPUSH
3384: LD_INT 100
3386: PPUSH
3387: CALL 55713 0 5
// veh := CreateVehicle ;
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: CALL_OW 45
3400: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3401: LD_VAR 0 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3413: LD_VAR 0 3
3417: PPUSH
3418: LD_INT 30
3420: PPUSH
3421: LD_INT 0
3423: PPUSH
3424: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3428: LD_EXP 32
3432: PPUSH
3433: LD_VAR 0 3
3437: PPUSH
3438: CALL_OW 52
// end ; if Roth then
3442: LD_EXP 18
3446: IFFALSE 3518
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3448: LD_INT 3
3450: PPUSH
3451: LD_INT 3
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 11
3459: PPUSH
3460: LD_INT 100
3462: PPUSH
3463: CALL 55713 0 5
// veh := CreateVehicle ;
3467: LD_ADDR_VAR 0 3
3471: PUSH
3472: CALL_OW 45
3476: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3477: LD_VAR 0 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3489: LD_VAR 0 3
3493: PPUSH
3494: LD_INT 30
3496: PPUSH
3497: LD_INT 0
3499: PPUSH
3500: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3504: LD_EXP 18
3508: PPUSH
3509: LD_VAR 0 3
3513: PPUSH
3514: CALL_OW 52
// end ; if Denis then
3518: LD_EXP 23
3522: IFFALSE 3594
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3524: LD_INT 5
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_INT 1
3532: PPUSH
3533: LD_INT 9
3535: PPUSH
3536: LD_INT 100
3538: PPUSH
3539: CALL 55713 0 5
// veh := CreateVehicle ;
3543: LD_ADDR_VAR 0 3
3547: PUSH
3548: CALL_OW 45
3552: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3553: LD_VAR 0 3
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3565: LD_VAR 0 3
3569: PPUSH
3570: LD_INT 30
3572: PPUSH
3573: LD_INT 0
3575: PPUSH
3576: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3580: LD_EXP 23
3584: PPUSH
3585: LD_VAR 0 3
3589: PPUSH
3590: CALL_OW 52
// end ; uc_nation := 3 ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3602: LD_INT 22
3604: PPUSH
3605: LD_INT 3
3607: PPUSH
3608: LD_INT 1
3610: PPUSH
3611: LD_INT 45
3613: PPUSH
3614: LD_INT 100
3616: PPUSH
3617: CALL 55713 0 5
// veh := CreateVehicle ;
3621: LD_ADDR_VAR 0 3
3625: PUSH
3626: CALL_OW 45
3630: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3631: LD_VAR 0 3
3635: PPUSH
3636: LD_INT 7
3638: NEG
3639: PPUSH
3640: CALL_OW 242
// SetDir ( veh , 3 ) ;
3644: LD_VAR 0 3
3648: PPUSH
3649: LD_INT 3
3651: PPUSH
3652: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3656: LD_VAR 0 3
3660: PPUSH
3661: LD_INT 31
3663: PPUSH
3664: LD_INT 0
3666: PPUSH
3667: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3671: LD_EXP 49
3675: PPUSH
3676: LD_VAR 0 3
3680: PPUSH
3681: CALL_OW 52
// if Gossudarov then
3685: LD_EXP 35
3689: IFFALSE 3776
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3691: LD_INT 22
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 1
3699: PPUSH
3700: LD_INT 51
3702: PPUSH
3703: LD_INT 100
3705: PPUSH
3706: CALL 55713 0 5
// veh := CreateVehicle ;
3710: LD_ADDR_VAR 0 3
3714: PUSH
3715: CALL_OW 45
3719: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3720: LD_VAR 0 3
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3732: LD_VAR 0 3
3736: PPUSH
3737: LD_INT 30
3739: PPUSH
3740: LD_INT 0
3742: PPUSH
3743: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3747: LD_EXP 35
3751: PPUSH
3752: LD_VAR 0 3
3756: PPUSH
3757: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3761: LD_VAR 0 3
3765: PPUSH
3766: LD_INT 1
3768: PPUSH
3769: LD_INT 100
3771: PPUSH
3772: CALL_OW 290
// end ; for i in selected do
3776: LD_ADDR_VAR 0 2
3780: PUSH
3781: LD_VAR 0 4
3785: PUSH
3786: FOR_IN
3787: IFFALSE 4345
// begin uc_nation := GetNation ( i ) ;
3789: LD_ADDR_OWVAR 21
3793: PUSH
3794: LD_VAR 0 2
3798: PPUSH
3799: CALL_OW 248
3803: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3804: LD_VAR 0 2
3808: PUSH
3809: LD_EXP 19
3813: PUSH
3814: LD_EXP 20
3818: PUSH
3819: LD_EXP 22
3823: PUSH
3824: LD_EXP 21
3828: PUSH
3829: EMPTY
3830: LIST
3831: LIST
3832: LIST
3833: LIST
3834: IN
3835: IFFALSE 3858
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3837: LD_INT 5
3839: PPUSH
3840: LD_INT 3
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: LD_INT 6
3848: PPUSH
3849: LD_INT 100
3851: PPUSH
3852: CALL 55713 0 5
3856: GO 4292
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3858: LD_VAR 0 2
3862: PUSH
3863: LD_EXP 42
3867: PUSH
3868: LD_EXP 47
3872: PUSH
3873: LD_EXP 45
3877: PUSH
3878: LD_EXP 37
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: LIST
3887: LIST
3888: IN
3889: IFFALSE 3920
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3891: LD_INT 24
3893: PPUSH
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 1
3899: PPUSH
3900: LD_INT 46
3902: PPUSH
3903: LD_INT 65
3905: PPUSH
3906: LD_INT 75
3908: PPUSH
3909: CALL_OW 12
3913: PPUSH
3914: CALL 55713 0 5
3918: GO 4292
// if i = Karamazov then
3920: LD_VAR 0 2
3924: PUSH
3925: LD_EXP 48
3929: EQUAL
3930: IFFALSE 3953
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3932: LD_INT 22
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: LD_INT 52
3943: PPUSH
3944: LD_INT 100
3946: PPUSH
3947: CALL 55713 0 5
3951: GO 4292
// if i = Brown then
3953: LD_VAR 0 2
3957: PUSH
3958: LD_EXP 24
3962: EQUAL
3963: IFFALSE 3986
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3965: LD_INT 3
3967: PPUSH
3968: LD_INT 3
3970: PPUSH
3971: LD_INT 1
3973: PPUSH
3974: LD_INT 13
3976: PPUSH
3977: LD_INT 100
3979: PPUSH
3980: CALL 55713 0 5
3984: GO 4292
// if uc_nation = nation_american then
3986: LD_OWVAR 21
3990: PUSH
3991: LD_INT 1
3993: EQUAL
3994: IFFALSE 4145
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3996: LD_INT 3
3998: PUSH
3999: LD_INT 5
4001: PUSH
4002: LD_INT 5
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_OWVAR 21
4014: PUSH
4015: LD_INT 3
4017: MOD
4018: PUSH
4019: LD_INT 1
4021: PLUS
4022: ARRAY
4023: PPUSH
4024: LD_INT 1
4026: PUSH
4027: LD_INT 3
4029: PUSH
4030: LD_INT 1
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: LIST
4037: PUSH
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 3
4045: MOD
4046: PUSH
4047: LD_INT 1
4049: PLUS
4050: ARRAY
4051: PPUSH
4052: LD_INT 1
4054: PPUSH
4055: LD_INT 11
4057: PUSH
4058: LD_INT 4
4060: PUSH
4061: LD_INT 5
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: LIST
4068: PUSH
4069: LD_INT 6
4071: PUSH
4072: LD_INT 7
4074: PUSH
4075: LD_INT 9
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: LIST
4082: PUSH
4083: LD_INT 6
4085: PUSH
4086: LD_INT 9
4088: PUSH
4089: LD_INT 12
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: LIST
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: LIST
4101: PUSH
4102: LD_OWVAR 21
4106: PUSH
4107: LD_INT 3
4109: MOD
4110: PUSH
4111: LD_INT 1
4113: PLUS
4114: ARRAY
4115: PUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_INT 3
4121: PPUSH
4122: CALL_OW 12
4126: ARRAY
4127: PPUSH
4128: LD_INT 65
4130: PPUSH
4131: LD_INT 75
4133: PPUSH
4134: CALL_OW 12
4138: PPUSH
4139: CALL 55713 0 5
// end else
4143: GO 4292
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4145: LD_INT 22
4147: PUSH
4148: LD_INT 23
4150: PUSH
4151: LD_INT 23
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: LD_OWVAR 21
4163: PUSH
4164: LD_INT 3
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: ARRAY
4172: PPUSH
4173: LD_INT 1
4175: PUSH
4176: LD_INT 3
4178: PUSH
4179: LD_INT 1
4181: PUSH
4182: EMPTY
4183: LIST
4184: LIST
4185: LIST
4186: PUSH
4187: LD_OWVAR 21
4191: PUSH
4192: LD_INT 3
4194: MOD
4195: PUSH
4196: LD_INT 1
4198: PLUS
4199: ARRAY
4200: PPUSH
4201: LD_INT 1
4203: PPUSH
4204: LD_INT 45
4206: PUSH
4207: LD_INT 43
4209: PUSH
4210: LD_INT 44
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: LIST
4217: PUSH
4218: LD_INT 46
4220: PUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 44
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 46
4234: PUSH
4235: LD_INT 43
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: LIST
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: PUSH
4251: LD_OWVAR 21
4255: PUSH
4256: LD_INT 3
4258: MOD
4259: PUSH
4260: LD_INT 1
4262: PLUS
4263: ARRAY
4264: PUSH
4265: LD_INT 1
4267: PPUSH
4268: LD_INT 3
4270: PPUSH
4271: CALL_OW 12
4275: ARRAY
4276: PPUSH
4277: LD_INT 65
4279: PPUSH
4280: LD_INT 75
4282: PPUSH
4283: CALL_OW 12
4287: PPUSH
4288: CALL 55713 0 5
// end ; veh := CreateVehicle ;
4292: LD_ADDR_VAR 0 3
4296: PUSH
4297: CALL_OW 45
4301: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4302: LD_VAR 0 3
4306: PPUSH
4307: LD_INT 3
4309: PPUSH
4310: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4314: LD_VAR 0 3
4318: PPUSH
4319: LD_INT 30
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4329: LD_VAR 0 2
4333: PPUSH
4334: LD_VAR 0 3
4338: PPUSH
4339: CALL_OW 52
// end ;
4343: GO 3786
4345: POP
4346: POP
// if artifactArCaptured then
4347: LD_EXP 9
4351: IFFALSE 4437
// begin uc_nation := nation_american ;
4353: LD_ADDR_OWVAR 21
4357: PUSH
4358: LD_INT 1
4360: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4361: LD_INT 3
4363: PPUSH
4364: LD_INT 3
4366: PPUSH
4367: LD_INT 3
4369: PPUSH
4370: LD_INT 12
4372: PPUSH
4373: LD_INT 100
4375: PPUSH
4376: CALL 55713 0 5
// veh := CreateVehicle ;
4380: LD_ADDR_VAR 0 3
4384: PUSH
4385: CALL_OW 45
4389: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4390: LD_VAR 0 3
4394: PPUSH
4395: LD_INT 3
4397: PPUSH
4398: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4402: LD_VAR 0 3
4406: PPUSH
4407: LD_INT 198
4409: PPUSH
4410: LD_INT 22
4412: PPUSH
4413: LD_INT 0
4415: PPUSH
4416: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4420: LD_VAR 0 3
4424: PPUSH
4425: LD_INT 4
4427: PPUSH
4428: LD_INT 50
4430: PPUSH
4431: CALL_OW 290
// end else
4435: GO 4456
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4437: LD_INT 4
4439: PPUSH
4440: LD_INT 5
4442: PPUSH
4443: LD_INT 267
4445: PPUSH
4446: LD_INT 226
4448: PPUSH
4449: LD_INT 0
4451: PPUSH
4452: CALL_OW 58
// end ; uc_nation := nation_american ;
4456: LD_ADDR_OWVAR 21
4460: PUSH
4461: LD_INT 1
4463: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4464: LD_INT 3
4466: PPUSH
4467: LD_INT 3
4469: PPUSH
4470: LD_INT 3
4472: PPUSH
4473: LD_INT 12
4475: PPUSH
4476: LD_INT 100
4478: PPUSH
4479: CALL 55713 0 5
// veh := CreateVehicle ;
4483: LD_ADDR_VAR 0 3
4487: PUSH
4488: CALL_OW 45
4492: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4493: LD_VAR 0 3
4497: PPUSH
4498: LD_INT 3
4500: PPUSH
4501: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4505: LD_VAR 0 3
4509: PPUSH
4510: LD_INT 218
4512: PPUSH
4513: LD_INT 23
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4523: LD_VAR 0 3
4527: PPUSH
4528: LD_INT 4
4530: PPUSH
4531: LD_INT 30
4533: PPUSH
4534: CALL_OW 290
// uc_nation := nation_russian ;
4538: LD_ADDR_OWVAR 21
4542: PUSH
4543: LD_INT 3
4545: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4546: LD_INT 22
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 3
4554: PPUSH
4555: LD_INT 51
4557: PPUSH
4558: LD_INT 100
4560: PPUSH
4561: CALL 55713 0 5
// veh := CreateVehicle ;
4565: LD_ADDR_VAR 0 3
4569: PUSH
4570: CALL_OW 45
4574: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 3
4582: PPUSH
4583: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4587: LD_VAR 0 3
4591: PPUSH
4592: LD_INT 214
4594: PPUSH
4595: LD_INT 20
4597: PPUSH
4598: LD_INT 0
4600: PPUSH
4601: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4605: LD_VAR 0 3
4609: PPUSH
4610: LD_INT 4
4612: PPUSH
4613: LD_INT 40
4615: PPUSH
4616: CALL_OW 290
// end ; end_of_file
4620: LD_VAR 0 1
4624: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4625: LD_INT 0
4627: PPUSH
4628: PPUSH
4629: PPUSH
4630: PPUSH
4631: PPUSH
4632: PPUSH
4633: PPUSH
4634: PPUSH
4635: PPUSH
4636: PPUSH
// InitHc ;
4637: CALL_OW 19
// uc_side := 1 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 1
4648: ST_TO_ADDR
// uc_nation := 1 ;
4649: LD_ADDR_OWVAR 21
4653: PUSH
4654: LD_INT 1
4656: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: LD_INT 22
4664: PUSH
4665: LD_INT 1
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 21
4674: PUSH
4675: LD_INT 3
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PPUSH
4686: CALL_OW 69
4690: PUSH
4691: FOR_IN
4692: IFFALSE 4708
// SetBLevel ( i , 10 ) ;
4694: LD_VAR 0 2
4698: PPUSH
4699: LD_INT 10
4701: PPUSH
4702: CALL_OW 241
4706: GO 4691
4708: POP
4709: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4710: LD_INT 387
4712: PPUSH
4713: CALL_OW 274
4717: PPUSH
4718: LD_INT 1
4720: PPUSH
4721: LD_INT 7500
4723: PPUSH
4724: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4728: LD_INT 387
4730: PPUSH
4731: CALL_OW 274
4735: PPUSH
4736: LD_INT 2
4738: PPUSH
4739: LD_INT 4000
4741: PPUSH
4742: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4746: LD_INT 387
4748: PPUSH
4749: CALL_OW 274
4753: PPUSH
4754: LD_INT 3
4756: PPUSH
4757: LD_INT 50
4759: PPUSH
4760: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4764: LD_INT 476
4766: PPUSH
4767: CALL_OW 274
4771: PPUSH
4772: LD_INT 1
4774: PPUSH
4775: LD_INT 5500
4777: PPUSH
4778: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4782: LD_INT 476
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 2
4792: PPUSH
4793: LD_INT 4000
4795: PPUSH
4796: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4800: LD_INT 476
4802: PPUSH
4803: CALL_OW 274
4807: PPUSH
4808: LD_INT 3
4810: PPUSH
4811: LD_INT 10
4813: PPUSH
4814: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4818: LD_ADDR_EXP 52
4822: PUSH
4823: LD_STRING Powell
4825: PPUSH
4826: CALL_OW 25
4830: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4831: LD_EXP 52
4835: PPUSH
4836: LD_INT 387
4838: PPUSH
4839: CALL_OW 52
// tmp := [ ] ;
4843: LD_ADDR_VAR 0 6
4847: PUSH
4848: EMPTY
4849: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4850: LD_ADDR_EXP 19
4854: PUSH
4855: LD_STRING Lisa
4857: PPUSH
4858: LD_EXP 1
4862: NOT
4863: PPUSH
4864: LD_STRING 12p_
4866: PPUSH
4867: CALL 50889 0 3
4871: ST_TO_ADDR
// if Lisa then
4872: LD_EXP 19
4876: IFFALSE 4894
// tmp := tmp ^ Lisa ;
4878: LD_ADDR_VAR 0 6
4882: PUSH
4883: LD_VAR 0 6
4887: PUSH
4888: LD_EXP 19
4892: ADD
4893: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4894: LD_ADDR_EXP 20
4898: PUSH
4899: LD_STRING Donaldson
4901: PPUSH
4902: LD_EXP 1
4906: NOT
4907: PPUSH
4908: LD_STRING 12p_
4910: PPUSH
4911: CALL 50889 0 3
4915: ST_TO_ADDR
// if Donaldson then
4916: LD_EXP 20
4920: IFFALSE 4938
// tmp := tmp ^ Donaldson ;
4922: LD_ADDR_VAR 0 6
4926: PUSH
4927: LD_VAR 0 6
4931: PUSH
4932: LD_EXP 20
4936: ADD
4937: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4938: LD_ADDR_EXP 21
4942: PUSH
4943: LD_STRING Bobby
4945: PPUSH
4946: LD_EXP 1
4950: NOT
4951: PPUSH
4952: LD_STRING 12p_
4954: PPUSH
4955: CALL 50889 0 3
4959: ST_TO_ADDR
// if Bobby then
4960: LD_EXP 21
4964: IFFALSE 4982
// tmp := tmp ^ Bobby ;
4966: LD_ADDR_VAR 0 6
4970: PUSH
4971: LD_VAR 0 6
4975: PUSH
4976: LD_EXP 21
4980: ADD
4981: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4982: LD_ADDR_EXP 22
4986: PUSH
4987: LD_STRING Cyrus
4989: PPUSH
4990: LD_EXP 1
4994: NOT
4995: PPUSH
4996: LD_STRING 12p_
4998: PPUSH
4999: CALL 50889 0 3
5003: ST_TO_ADDR
// if Cyrus then
5004: LD_EXP 22
5008: IFFALSE 5026
// tmp := tmp ^ Cyrus ;
5010: LD_ADDR_VAR 0 6
5014: PUSH
5015: LD_VAR 0 6
5019: PUSH
5020: LD_EXP 22
5024: ADD
5025: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5026: LD_ADDR_EXP 24
5030: PUSH
5031: LD_STRING Brown
5033: PPUSH
5034: LD_EXP 1
5038: NOT
5039: PPUSH
5040: LD_STRING 12p_
5042: PPUSH
5043: CALL 50889 0 3
5047: ST_TO_ADDR
// if Brown then
5048: LD_EXP 24
5052: IFFALSE 5070
// tmp := tmp ^ Brown ;
5054: LD_ADDR_VAR 0 6
5058: PUSH
5059: LD_VAR 0 6
5063: PUSH
5064: LD_EXP 24
5068: ADD
5069: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5070: LD_ADDR_EXP 25
5074: PUSH
5075: LD_STRING Gladstone
5077: PPUSH
5078: LD_EXP 1
5082: NOT
5083: PPUSH
5084: LD_STRING 12p_
5086: PPUSH
5087: CALL 50889 0 3
5091: ST_TO_ADDR
// if Gladstone then
5092: LD_EXP 25
5096: IFFALSE 5114
// tmp := tmp ^ Gladstone ;
5098: LD_ADDR_VAR 0 6
5102: PUSH
5103: LD_VAR 0 6
5107: PUSH
5108: LD_EXP 25
5112: ADD
5113: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5114: LD_ADDR_EXP 26
5118: PUSH
5119: LD_STRING Houten
5121: PPUSH
5122: LD_EXP 1
5126: NOT
5127: PPUSH
5128: LD_STRING 12p_
5130: PPUSH
5131: CALL 50889 0 3
5135: ST_TO_ADDR
// if Houten then
5136: LD_EXP 26
5140: IFFALSE 5158
// tmp := tmp ^ Houten ;
5142: LD_ADDR_VAR 0 6
5146: PUSH
5147: LD_VAR 0 6
5151: PUSH
5152: LD_EXP 26
5156: ADD
5157: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5158: LD_ADDR_EXP 27
5162: PUSH
5163: LD_STRING Cornel
5165: PPUSH
5166: LD_EXP 1
5170: NOT
5171: PPUSH
5172: LD_STRING 12p_
5174: PPUSH
5175: CALL 50889 0 3
5179: ST_TO_ADDR
// if Cornel then
5180: LD_EXP 27
5184: IFFALSE 5202
// tmp := tmp ^ Cornel ;
5186: LD_ADDR_VAR 0 6
5190: PUSH
5191: LD_VAR 0 6
5195: PUSH
5196: LD_EXP 27
5200: ADD
5201: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5202: LD_ADDR_EXP 28
5206: PUSH
5207: LD_STRING Gary
5209: PPUSH
5210: LD_EXP 1
5214: NOT
5215: PPUSH
5216: LD_STRING 12p_
5218: PPUSH
5219: CALL 50889 0 3
5223: ST_TO_ADDR
// if Gary then
5224: LD_EXP 28
5228: IFFALSE 5246
// tmp := tmp ^ Gary ;
5230: LD_ADDR_VAR 0 6
5234: PUSH
5235: LD_VAR 0 6
5239: PUSH
5240: LD_EXP 28
5244: ADD
5245: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5246: LD_ADDR_EXP 30
5250: PUSH
5251: LD_STRING Kikuchi
5253: PPUSH
5254: LD_EXP 1
5258: NOT
5259: PPUSH
5260: LD_STRING 12p_
5262: PPUSH
5263: CALL 50889 0 3
5267: ST_TO_ADDR
// if Kikuchi then
5268: LD_EXP 30
5272: IFFALSE 5290
// tmp := tmp ^ Kikuchi ;
5274: LD_ADDR_VAR 0 6
5278: PUSH
5279: LD_VAR 0 6
5283: PUSH
5284: LD_EXP 30
5288: ADD
5289: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5290: LD_ADDR_VAR 0 6
5294: PUSH
5295: LD_VAR 0 6
5299: PUSH
5300: LD_STRING 12p_others
5302: PPUSH
5303: CALL_OW 31
5307: UNION
5308: ST_TO_ADDR
// if tmp < 36 then
5309: LD_VAR 0 6
5313: PUSH
5314: LD_INT 36
5316: LESS
5317: IFFALSE 5384
// for i = 1 to 36 - tmp do
5319: LD_ADDR_VAR 0 2
5323: PUSH
5324: DOUBLE
5325: LD_INT 1
5327: DEC
5328: ST_TO_ADDR
5329: LD_INT 36
5331: PUSH
5332: LD_VAR 0 6
5336: MINUS
5337: PUSH
5338: FOR_TO
5339: IFFALSE 5382
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5341: LD_INT 1
5343: PPUSH
5344: LD_VAR 0 2
5348: PUSH
5349: LD_INT 4
5351: MOD
5352: PUSH
5353: LD_INT 1
5355: PLUS
5356: PPUSH
5357: LD_INT 10
5359: PPUSH
5360: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: CALL_OW 44
5378: ADD
5379: ST_TO_ADDR
// end ;
5380: GO 5338
5382: POP
5383: POP
// for i in tmp do
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_VAR 0 6
5393: PUSH
5394: FOR_IN
5395: IFFALSE 5420
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5397: LD_VAR 0 2
5401: PPUSH
5402: LD_INT 62
5404: PPUSH
5405: LD_INT 93
5407: PPUSH
5408: LD_INT 9
5410: PPUSH
5411: LD_INT 0
5413: PPUSH
5414: CALL_OW 50
5418: GO 5394
5420: POP
5421: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5422: LD_ADDR_EXP 90
5426: PUSH
5427: LD_EXP 90
5431: PPUSH
5432: LD_INT 4
5434: PPUSH
5435: LD_INT 22
5437: PUSH
5438: LD_INT 1
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL_OW 69
5449: PUSH
5450: LD_EXP 52
5454: DIFF
5455: PPUSH
5456: CALL_OW 1
5460: ST_TO_ADDR
// uc_side := 0 ;
5461: LD_ADDR_OWVAR 20
5465: PUSH
5466: LD_INT 0
5468: ST_TO_ADDR
// uc_nation := 0 ;
5469: LD_ADDR_OWVAR 21
5473: PUSH
5474: LD_INT 0
5476: ST_TO_ADDR
// for i = 1 to 4 do
5477: LD_ADDR_VAR 0 2
5481: PUSH
5482: DOUBLE
5483: LD_INT 1
5485: DEC
5486: ST_TO_ADDR
5487: LD_INT 4
5489: PUSH
5490: FOR_TO
5491: IFFALSE 5522
// begin InitHc ;
5493: CALL_OW 19
// hc_class := class_apeman ;
5497: LD_ADDR_OWVAR 28
5501: PUSH
5502: LD_INT 12
5504: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5505: CALL_OW 44
5509: PPUSH
5510: LD_INT 11
5512: PPUSH
5513: LD_INT 0
5515: PPUSH
5516: CALL_OW 49
// end ;
5520: GO 5490
5522: POP
5523: POP
// end ;
5524: LD_VAR 0 1
5528: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5529: LD_EXP 4
5533: NOT
5534: PUSH
5535: LD_INT 4
5537: PPUSH
5538: LD_INT 1
5540: PPUSH
5541: CALL 45944 0 2
5545: NOT
5546: AND
5547: IFFALSE 6319
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
// begin enable ;
5557: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5558: LD_INT 22
5560: PUSH
5561: LD_INT 1
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: PUSH
5568: LD_INT 23
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: PUSH
5578: LD_INT 30
5580: PUSH
5581: LD_INT 3
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: LIST
5592: PPUSH
5593: CALL_OW 69
5597: NOT
5598: IFFALSE 5602
// exit ;
5600: GO 6319
// if Prob ( 40 ) then
5602: LD_INT 40
5604: PPUSH
5605: CALL_OW 13
5609: IFFALSE 5736
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5611: LD_INT 4
5613: PPUSH
5614: LD_INT 5
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: LD_INT 2
5622: PUSH
5623: LD_INT 7
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: LD_INT 2
5640: PUSH
5641: LD_INT 7
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: LD_INT 5
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 7
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 5
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 6
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 5
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 6
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: LD_INT 5
5706: PUSH
5707: LD_INT 1
5709: PUSH
5710: LD_INT 2
5712: PUSH
5713: LD_INT 6
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: LIST
5729: PPUSH
5730: CALL 44526 0 2
// end else
5734: GO 5859
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5736: LD_INT 4
5738: PPUSH
5739: LD_INT 5
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: LD_INT 2
5747: PUSH
5748: LD_INT 7
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: LIST
5755: LIST
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 1
5762: PUSH
5763: LD_INT 2
5765: PUSH
5766: LD_INT 9
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: PUSH
5775: LD_INT 5
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 2
5783: PUSH
5784: LD_INT 9
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 5
5795: PUSH
5796: LD_INT 1
5798: PUSH
5799: LD_INT 2
5801: PUSH
5802: LD_INT 6
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: PUSH
5811: LD_INT 5
5813: PUSH
5814: LD_INT 1
5816: PUSH
5817: LD_INT 2
5819: PUSH
5820: LD_INT 6
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 5
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 2
5837: PUSH
5838: LD_INT 6
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PPUSH
5855: CALL 44526 0 2
// end ; repeat wait ( 0 0$1 ) ;
5859: LD_INT 35
5861: PPUSH
5862: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5866: LD_INT 4
5868: PPUSH
5869: LD_INT 1
5871: PPUSH
5872: CALL 45944 0 2
5876: PUSH
5877: LD_INT 6
5879: GREATEREQUAL
5880: IFFALSE 5859
// wait ( 0 0$30 ) ;
5882: LD_INT 1050
5884: PPUSH
5885: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5889: LD_ADDR_VAR 0 2
5893: PUSH
5894: LD_INT 4
5896: PPUSH
5897: LD_INT 1
5899: PPUSH
5900: CALL 45944 0 2
5904: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5905: LD_ADDR_EXP 109
5909: PUSH
5910: LD_EXP 109
5914: PPUSH
5915: LD_INT 4
5917: PPUSH
5918: LD_EXP 109
5922: PUSH
5923: LD_INT 4
5925: ARRAY
5926: PUSH
5927: LD_VAR 0 2
5931: DIFF
5932: PPUSH
5933: CALL_OW 1
5937: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 0
5945: PPUSH
5946: LD_INT 2
5948: PPUSH
5949: CALL_OW 12
5953: ST_TO_ADDR
// if target then
5954: LD_VAR 0 3
5958: IFFALSE 6086
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5960: LD_ADDR_VAR 0 2
5964: PUSH
5965: LD_VAR 0 2
5969: PPUSH
5970: LD_INT 24
5972: PUSH
5973: LD_INT 250
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 72
5984: ST_TO_ADDR
// for i in tmp do
5985: LD_ADDR_VAR 0 1
5989: PUSH
5990: LD_VAR 0 2
5994: PUSH
5995: FOR_IN
5996: IFFALSE 6036
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5998: LD_VAR 0 1
6002: PPUSH
6003: LD_INT 114
6005: PPUSH
6006: LD_INT 108
6008: PPUSH
6009: CALL_OW 297
6013: PUSH
6014: LD_INT 9
6016: GREATER
6017: IFFALSE 6034
// ComMoveXY ( i , 114 , 108 ) ;
6019: LD_VAR 0 1
6023: PPUSH
6024: LD_INT 114
6026: PPUSH
6027: LD_INT 108
6029: PPUSH
6030: CALL_OW 111
6034: GO 5995
6036: POP
6037: POP
// wait ( 0 0$1 ) ;
6038: LD_INT 35
6040: PPUSH
6041: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 92
6052: PUSH
6053: LD_INT 114
6055: PUSH
6056: LD_INT 108
6058: PUSH
6059: LD_INT 9
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL_OW 72
6072: PUSH
6073: LD_VAR 0 2
6077: PUSH
6078: LD_INT 1
6080: MINUS
6081: GREATEREQUAL
6082: IFFALSE 5960
// end else
6084: GO 6210
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6086: LD_ADDR_VAR 0 2
6090: PUSH
6091: LD_VAR 0 2
6095: PPUSH
6096: LD_INT 24
6098: PUSH
6099: LD_INT 250
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PPUSH
6106: CALL_OW 72
6110: ST_TO_ADDR
// for i in tmp do
6111: LD_ADDR_VAR 0 1
6115: PUSH
6116: LD_VAR 0 2
6120: PUSH
6121: FOR_IN
6122: IFFALSE 6162
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6124: LD_VAR 0 1
6128: PPUSH
6129: LD_INT 129
6131: PPUSH
6132: LD_INT 139
6134: PPUSH
6135: CALL_OW 297
6139: PUSH
6140: LD_INT 9
6142: GREATER
6143: IFFALSE 6160
// ComMoveXY ( i , 129 , 139 ) ;
6145: LD_VAR 0 1
6149: PPUSH
6150: LD_INT 129
6152: PPUSH
6153: LD_INT 139
6155: PPUSH
6156: CALL_OW 111
6160: GO 6121
6162: POP
6163: POP
// wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6171: LD_VAR 0 2
6175: PPUSH
6176: LD_INT 92
6178: PUSH
6179: LD_INT 129
6181: PUSH
6182: LD_INT 139
6184: PUSH
6185: LD_INT 9
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 72
6198: PUSH
6199: LD_VAR 0 2
6203: PUSH
6204: LD_INT 1
6206: MINUS
6207: GREATEREQUAL
6208: IFFALSE 6086
// end ; repeat wait ( 0 0$1 ) ;
6210: LD_INT 35
6212: PPUSH
6213: CALL_OW 67
// for i in tmp do
6217: LD_ADDR_VAR 0 1
6221: PUSH
6222: LD_VAR 0 2
6226: PUSH
6227: FOR_IN
6228: IFFALSE 6310
// begin if GetLives ( i ) > 251 then
6230: LD_VAR 0 1
6234: PPUSH
6235: CALL_OW 256
6239: PUSH
6240: LD_INT 251
6242: GREATER
6243: IFFALSE 6281
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6245: LD_VAR 0 1
6249: PPUSH
6250: LD_INT 81
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: PPUSH
6260: CALL_OW 69
6264: PPUSH
6265: LD_VAR 0 1
6269: PPUSH
6270: CALL_OW 74
6274: PPUSH
6275: CALL_OW 115
6279: GO 6308
// if IsDead ( i ) then
6281: LD_VAR 0 1
6285: PPUSH
6286: CALL_OW 301
6290: IFFALSE 6308
// tmp := tmp diff i ;
6292: LD_ADDR_VAR 0 2
6296: PUSH
6297: LD_VAR 0 2
6301: PUSH
6302: LD_VAR 0 1
6306: DIFF
6307: ST_TO_ADDR
// end ;
6308: GO 6227
6310: POP
6311: POP
// until not tmp ;
6312: LD_VAR 0 2
6316: NOT
6317: IFFALSE 6210
// end ;
6319: PPOPN 3
6321: END
// every 30 30$00 trigger not americanDestroyed do
6322: LD_EXP 4
6326: NOT
6327: IFFALSE 6392
6329: GO 6331
6331: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6332: LD_INT 63000
6334: PUSH
6335: LD_INT 42000
6337: PUSH
6338: LD_INT 21000
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: LIST
6345: PUSH
6346: LD_OWVAR 67
6350: ARRAY
6351: PPUSH
6352: CALL_OW 67
// if americanDestroyed then
6356: LD_EXP 4
6360: IFFALSE 6364
// exit ;
6362: GO 6392
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6364: LD_INT 4
6366: PPUSH
6367: LD_INT 5
6369: PUSH
6370: LD_INT 3
6372: PUSH
6373: LD_INT 1
6375: PUSH
6376: LD_INT 8
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: EMPTY
6386: LIST
6387: PPUSH
6388: CALL 44526 0 2
// end ; end_of_file
6392: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6393: LD_INT 0
6395: PPUSH
6396: PPUSH
6397: PPUSH
6398: PPUSH
6399: PPUSH
// side := 2 ;
6400: LD_ADDR_VAR 0 5
6404: PUSH
6405: LD_INT 2
6407: ST_TO_ADDR
// InitHc ;
6408: CALL_OW 19
// uc_side := side ;
6412: LD_ADDR_OWVAR 20
6416: PUSH
6417: LD_VAR 0 5
6421: ST_TO_ADDR
// uc_nation := 2 ;
6422: LD_ADDR_OWVAR 21
6426: PUSH
6427: LD_INT 2
6429: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6430: LD_ADDR_VAR 0 2
6434: PUSH
6435: LD_INT 22
6437: PUSH
6438: LD_INT 2
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: LD_INT 21
6447: PUSH
6448: LD_INT 3
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PPUSH
6459: CALL_OW 69
6463: PUSH
6464: FOR_IN
6465: IFFALSE 6481
// SetBLevel ( i , 10 ) ;
6467: LD_VAR 0 2
6471: PPUSH
6472: LD_INT 10
6474: PPUSH
6475: CALL_OW 241
6479: GO 6464
6481: POP
6482: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6483: LD_ADDR_VAR 0 4
6487: PUSH
6488: LD_INT 22
6490: PUSH
6491: LD_VAR 0 5
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 30
6502: PUSH
6503: LD_INT 32
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 58
6512: PUSH
6513: EMPTY
6514: LIST
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: PPUSH
6521: CALL_OW 69
6525: ST_TO_ADDR
// for i = 1 to 10 do
6526: LD_ADDR_VAR 0 2
6530: PUSH
6531: DOUBLE
6532: LD_INT 1
6534: DEC
6535: ST_TO_ADDR
6536: LD_INT 10
6538: PUSH
6539: FOR_TO
6540: IFFALSE 6612
// begin uc_nation := nation_nature ;
6542: LD_ADDR_OWVAR 21
6546: PUSH
6547: LD_INT 0
6549: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6550: LD_ADDR_OWVAR 28
6554: PUSH
6555: LD_INT 15
6557: ST_TO_ADDR
// hc_gallery :=  ;
6558: LD_ADDR_OWVAR 33
6562: PUSH
6563: LD_STRING 
6565: ST_TO_ADDR
// hc_name :=  ;
6566: LD_ADDR_OWVAR 26
6570: PUSH
6571: LD_STRING 
6573: ST_TO_ADDR
// un := CreateHuman ;
6574: LD_ADDR_VAR 0 3
6578: PUSH
6579: CALL_OW 44
6583: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6584: LD_VAR 0 3
6588: PPUSH
6589: LD_VAR 0 4
6593: PUSH
6594: LD_VAR 0 4
6598: PUSH
6599: LD_VAR 0 2
6603: MINUS
6604: ARRAY
6605: PPUSH
6606: CALL_OW 52
// end ;
6610: GO 6539
6612: POP
6613: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6614: LD_INT 503
6616: PPUSH
6617: LD_INT 27
6619: PPUSH
6620: LD_STRING 
6622: PPUSH
6623: LD_INT 8
6625: PUSH
6626: LD_INT 9
6628: PUSH
6629: LD_INT 10
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: LIST
6636: PUSH
6637: LD_OWVAR 67
6641: ARRAY
6642: PPUSH
6643: LD_INT 3000
6645: PUSH
6646: LD_INT 500
6648: PUSH
6649: LD_INT 150
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: LIST
6656: PPUSH
6657: LD_INT 16
6659: PUSH
6660: LD_INT 6
6662: PUSH
6663: LD_INT 6
6665: PUSH
6666: LD_INT 6
6668: PUSH
6669: EMPTY
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: PPUSH
6675: CALL 59154 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6679: LD_ADDR_EXP 90
6683: PUSH
6684: LD_EXP 90
6688: PPUSH
6689: LD_INT 1
6691: PPUSH
6692: LD_INT 22
6694: PUSH
6695: LD_VAR 0 5
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PUSH
6704: LD_INT 23
6706: PUSH
6707: LD_INT 2
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PUSH
6714: LD_INT 3
6716: PUSH
6717: LD_INT 21
6719: PUSH
6720: LD_INT 2
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: PPUSH
6736: CALL_OW 69
6740: PPUSH
6741: CALL_OW 1
6745: ST_TO_ADDR
// end ;
6746: LD_VAR 0 1
6750: RET
// export Omar ; export function PrepareOmarAli ; begin
6751: LD_INT 0
6753: PPUSH
// uc_side := 5 ;
6754: LD_ADDR_OWVAR 20
6758: PUSH
6759: LD_INT 5
6761: ST_TO_ADDR
// uc_nation := 2 ;
6762: LD_ADDR_OWVAR 21
6766: PUSH
6767: LD_INT 2
6769: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6770: LD_ADDR_EXP 53
6774: PUSH
6775: LD_STRING Omar
6777: PPUSH
6778: CALL_OW 25
6782: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6783: LD_EXP 53
6787: PPUSH
6788: LD_INT 330
6790: PPUSH
6791: LD_INT 244
6793: PPUSH
6794: LD_INT 0
6796: PPUSH
6797: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6801: LD_EXP 53
6805: PPUSH
6806: LD_INT 252
6808: PPUSH
6809: LD_INT 220
6811: PPUSH
6812: CALL_OW 111
// end ; end_of_file
6816: LD_VAR 0 1
6820: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6821: LD_INT 0
6823: PPUSH
6824: PPUSH
6825: PPUSH
6826: PPUSH
6827: PPUSH
// side := 8 ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_INT 8
6835: ST_TO_ADDR
// InitHc ;
6836: CALL_OW 19
// uc_side := side ;
6840: LD_ADDR_OWVAR 20
6844: PUSH
6845: LD_VAR 0 3
6849: ST_TO_ADDR
// uc_nation := 2 ;
6850: LD_ADDR_OWVAR 21
6854: PUSH
6855: LD_INT 2
6857: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6858: LD_ADDR_VAR 0 2
6862: PUSH
6863: LD_INT 22
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: LD_INT 21
6877: PUSH
6878: LD_INT 3
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PPUSH
6889: CALL_OW 69
6893: PUSH
6894: FOR_IN
6895: IFFALSE 6911
// SetBLevel ( i , 10 ) ;
6897: LD_VAR 0 2
6901: PPUSH
6902: LD_INT 10
6904: PPUSH
6905: CALL_OW 241
6909: GO 6894
6911: POP
6912: POP
// Schulz := NewCharacter ( Schulz ) ;
6913: LD_ADDR_EXP 54
6917: PUSH
6918: LD_STRING Schulz
6920: PPUSH
6921: CALL_OW 25
6925: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6926: LD_ADDR_EXP 55
6930: PUSH
6931: LD_STRING Kozlov
6933: PPUSH
6934: LD_INT 0
6936: PPUSH
6937: LD_STRING 
6939: PPUSH
6940: CALL 50889 0 3
6944: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6945: LD_EXP 55
6949: PPUSH
6950: LD_INT 22
6952: PUSH
6953: LD_INT 8
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PUSH
6960: LD_INT 23
6962: PUSH
6963: LD_INT 3
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PUSH
6970: LD_INT 30
6972: PUSH
6973: LD_INT 8
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: PUSH
6990: LD_INT 1
6992: ARRAY
6993: PPUSH
6994: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6998: LD_EXP 55
7002: PPUSH
7003: LD_INT 3
7005: PPUSH
7006: LD_INT 10
7008: PPUSH
7009: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7013: LD_ADDR_VAR 0 5
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_VAR 0 3
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PUSH
7030: LD_INT 30
7032: PUSH
7033: LD_INT 32
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 58
7042: PUSH
7043: EMPTY
7044: LIST
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: PPUSH
7051: CALL_OW 69
7055: ST_TO_ADDR
// for i = 1 to 10 do
7056: LD_ADDR_VAR 0 2
7060: PUSH
7061: DOUBLE
7062: LD_INT 1
7064: DEC
7065: ST_TO_ADDR
7066: LD_INT 10
7068: PUSH
7069: FOR_TO
7070: IFFALSE 7142
// begin uc_nation := nation_nature ;
7072: LD_ADDR_OWVAR 21
7076: PUSH
7077: LD_INT 0
7079: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7080: LD_ADDR_OWVAR 28
7084: PUSH
7085: LD_INT 15
7087: ST_TO_ADDR
// hc_gallery :=  ;
7088: LD_ADDR_OWVAR 33
7092: PUSH
7093: LD_STRING 
7095: ST_TO_ADDR
// hc_name :=  ;
7096: LD_ADDR_OWVAR 26
7100: PUSH
7101: LD_STRING 
7103: ST_TO_ADDR
// un := CreateHuman ;
7104: LD_ADDR_VAR 0 4
7108: PUSH
7109: CALL_OW 44
7113: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7114: LD_VAR 0 4
7118: PPUSH
7119: LD_VAR 0 5
7123: PUSH
7124: LD_VAR 0 5
7128: PUSH
7129: LD_VAR 0 2
7133: MINUS
7134: ARRAY
7135: PPUSH
7136: CALL_OW 52
// end ;
7140: GO 7069
7142: POP
7143: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7144: LD_INT 324
7146: PPUSH
7147: LD_INT 3
7149: PPUSH
7150: LD_STRING 
7152: PPUSH
7153: LD_INT 8
7155: PUSH
7156: LD_INT 9
7158: PUSH
7159: LD_INT 10
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: LIST
7166: PUSH
7167: LD_OWVAR 67
7171: ARRAY
7172: PPUSH
7173: LD_INT 3000
7175: PUSH
7176: LD_INT 500
7178: PUSH
7179: LD_INT 150
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: LIST
7186: PPUSH
7187: LD_INT 16
7189: PUSH
7190: LD_INT 6
7192: PUSH
7193: LD_INT 6
7195: PUSH
7196: LD_INT 8
7198: PUSH
7199: EMPTY
7200: LIST
7201: LIST
7202: LIST
7203: LIST
7204: PPUSH
7205: CALL 59154 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7209: LD_ADDR_EXP 90
7213: PUSH
7214: LD_EXP 90
7218: PPUSH
7219: LD_INT 3
7221: PPUSH
7222: LD_INT 22
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 23
7236: PUSH
7237: LD_INT 2
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 21
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: EMPTY
7262: LIST
7263: LIST
7264: LIST
7265: PPUSH
7266: CALL_OW 69
7270: PUSH
7271: LD_EXP 54
7275: DIFF
7276: PPUSH
7277: CALL_OW 1
7281: ST_TO_ADDR
// end ;
7282: LD_VAR 0 1
7286: RET
// export function BuildKozlovBomb ; begin
7287: LD_INT 0
7289: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7290: LD_INT 332
7292: PPUSH
7293: CALL_OW 302
7297: NOT
7298: PUSH
7299: LD_INT 336
7301: PPUSH
7302: CALL_OW 302
7306: NOT
7307: OR
7308: IFFALSE 7312
// exit ;
7310: GO 7409
// ComChangeProfession ( Kozlov , 4 ) ;
7312: LD_EXP 55
7316: PPUSH
7317: LD_INT 4
7319: PPUSH
7320: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7324: LD_INT 336
7326: PPUSH
7327: LD_INT 25
7329: PPUSH
7330: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7334: LD_INT 35
7336: PPUSH
7337: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7341: LD_INT 25
7343: PPUSH
7344: LD_INT 8
7346: PPUSH
7347: CALL_OW 321
7351: PUSH
7352: LD_INT 2
7354: EQUAL
7355: IFFALSE 7334
// ComExitBuilding ( Kozlov ) ;
7357: LD_EXP 55
7361: PPUSH
7362: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7366: LD_EXP 55
7370: PPUSH
7371: LD_INT 332
7373: PPUSH
7374: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7378: LD_EXP 55
7382: PPUSH
7383: LD_INT 3
7385: PPUSH
7386: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7390: LD_INT 332
7392: PPUSH
7393: LD_INT 23
7395: PPUSH
7396: LD_INT 3
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 48
7404: PPUSH
7405: CALL_OW 125
// end ;
7409: LD_VAR 0 1
7413: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7414: LD_EXP 3
7418: NOT
7419: PUSH
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 1
7425: PPUSH
7426: CALL 45944 0 2
7430: NOT
7431: AND
7432: IFFALSE 8272
7434: GO 7436
7436: DISABLE
7437: LD_INT 0
7439: PPUSH
7440: PPUSH
7441: PPUSH
// begin enable ;
7442: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7443: LD_INT 22
7445: PUSH
7446: LD_INT 8
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: LD_INT 23
7455: PUSH
7456: LD_INT 2
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 30
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: NOT
7483: IFFALSE 7487
// exit ;
7485: GO 8272
// if Prob ( 40 ) then
7487: LD_INT 40
7489: PPUSH
7490: CALL_OW 13
7494: IFFALSE 7621
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7496: LD_INT 3
7498: PPUSH
7499: LD_INT 14
7501: PUSH
7502: LD_INT 1
7504: PUSH
7505: LD_INT 2
7507: PUSH
7508: LD_INT 28
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 14
7519: PUSH
7520: LD_INT 1
7522: PUSH
7523: LD_INT 2
7525: PUSH
7526: LD_INT 28
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: LIST
7533: LIST
7534: PUSH
7535: LD_INT 14
7537: PUSH
7538: LD_INT 1
7540: PUSH
7541: LD_INT 2
7543: PUSH
7544: LD_INT 28
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: PUSH
7553: LD_INT 14
7555: PUSH
7556: LD_INT 1
7558: PUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 28
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 14
7573: PUSH
7574: LD_INT 1
7576: PUSH
7577: LD_INT 2
7579: PUSH
7580: LD_INT 28
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: LIST
7587: LIST
7588: PUSH
7589: LD_INT 14
7591: PUSH
7592: LD_INT 1
7594: PUSH
7595: LD_INT 2
7597: PUSH
7598: LD_INT 26
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: LIST
7613: LIST
7614: PPUSH
7615: CALL 44526 0 2
// end else
7619: GO 7812
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 14
7626: PUSH
7627: LD_INT 1
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: LD_INT 27
7635: PUSH
7636: LD_INT 26
7638: PUSH
7639: LD_INT 26
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: PUSH
7647: LD_OWVAR 67
7651: ARRAY
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PUSH
7659: LD_INT 14
7661: PUSH
7662: LD_INT 1
7664: PUSH
7665: LD_INT 2
7667: PUSH
7668: LD_INT 27
7670: PUSH
7671: LD_INT 26
7673: PUSH
7674: LD_INT 26
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: PUSH
7682: LD_OWVAR 67
7686: ARRAY
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: PUSH
7694: LD_INT 14
7696: PUSH
7697: LD_INT 1
7699: PUSH
7700: LD_INT 2
7702: PUSH
7703: LD_INT 26
7705: PUSH
7706: LD_INT 26
7708: PUSH
7709: LD_INT 29
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: PUSH
7717: LD_OWVAR 67
7721: ARRAY
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: PUSH
7729: LD_INT 13
7731: PUSH
7732: LD_INT 1
7734: PUSH
7735: LD_INT 2
7737: PUSH
7738: LD_INT 26
7740: PUSH
7741: LD_INT 29
7743: PUSH
7744: LD_INT 29
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: LIST
7751: PUSH
7752: LD_OWVAR 67
7756: ARRAY
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 13
7766: PUSH
7767: LD_INT 1
7769: PUSH
7770: LD_INT 2
7772: PUSH
7773: LD_INT 29
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: LIST
7780: LIST
7781: PUSH
7782: LD_INT 14
7784: PUSH
7785: LD_INT 1
7787: PUSH
7788: LD_INT 2
7790: PUSH
7791: LD_INT 26
7793: PUSH
7794: EMPTY
7795: LIST
7796: LIST
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PPUSH
7808: CALL 44526 0 2
// end ; repeat wait ( 0 0$1 ) ;
7812: LD_INT 35
7814: PPUSH
7815: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7819: LD_INT 3
7821: PPUSH
7822: LD_INT 1
7824: PPUSH
7825: CALL 45944 0 2
7829: PUSH
7830: LD_INT 6
7832: GREATEREQUAL
7833: IFFALSE 7812
// wait ( 0 0$30 ) ;
7835: LD_INT 1050
7837: PPUSH
7838: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7842: LD_ADDR_VAR 0 2
7846: PUSH
7847: LD_INT 3
7849: PPUSH
7850: LD_INT 1
7852: PPUSH
7853: CALL 45944 0 2
7857: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7858: LD_ADDR_EXP 109
7862: PUSH
7863: LD_EXP 109
7867: PPUSH
7868: LD_INT 3
7870: PPUSH
7871: LD_EXP 109
7875: PUSH
7876: LD_INT 3
7878: ARRAY
7879: PUSH
7880: LD_VAR 0 2
7884: DIFF
7885: PPUSH
7886: CALL_OW 1
7890: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7891: LD_ADDR_VAR 0 3
7895: PUSH
7896: LD_INT 0
7898: PPUSH
7899: LD_INT 2
7901: PPUSH
7902: CALL_OW 12
7906: ST_TO_ADDR
// if target then
7907: LD_VAR 0 3
7911: IFFALSE 8039
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7913: LD_ADDR_VAR 0 2
7917: PUSH
7918: LD_VAR 0 2
7922: PPUSH
7923: LD_INT 24
7925: PUSH
7926: LD_INT 250
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PPUSH
7933: CALL_OW 72
7937: ST_TO_ADDR
// for i in tmp do
7938: LD_ADDR_VAR 0 1
7942: PUSH
7943: LD_VAR 0 2
7947: PUSH
7948: FOR_IN
7949: IFFALSE 7989
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7951: LD_VAR 0 1
7955: PPUSH
7956: LD_INT 89
7958: PPUSH
7959: LD_INT 71
7961: PPUSH
7962: CALL_OW 297
7966: PUSH
7967: LD_INT 9
7969: GREATER
7970: IFFALSE 7987
// ComMoveXY ( i , 89 , 71 ) ;
7972: LD_VAR 0 1
7976: PPUSH
7977: LD_INT 89
7979: PPUSH
7980: LD_INT 71
7982: PPUSH
7983: CALL_OW 111
7987: GO 7948
7989: POP
7990: POP
// wait ( 0 0$1 ) ;
7991: LD_INT 35
7993: PPUSH
7994: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 92
8005: PUSH
8006: LD_INT 89
8008: PUSH
8009: LD_INT 71
8011: PUSH
8012: LD_INT 9
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 72
8025: PUSH
8026: LD_VAR 0 2
8030: PUSH
8031: LD_INT 1
8033: MINUS
8034: GREATEREQUAL
8035: IFFALSE 7913
// end else
8037: GO 8163
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8039: LD_ADDR_VAR 0 2
8043: PUSH
8044: LD_VAR 0 2
8048: PPUSH
8049: LD_INT 24
8051: PUSH
8052: LD_INT 250
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: PPUSH
8059: CALL_OW 72
8063: ST_TO_ADDR
// for i in tmp do
8064: LD_ADDR_VAR 0 1
8068: PUSH
8069: LD_VAR 0 2
8073: PUSH
8074: FOR_IN
8075: IFFALSE 8115
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8077: LD_VAR 0 1
8081: PPUSH
8082: LD_INT 147
8084: PPUSH
8085: LD_INT 4
8087: PPUSH
8088: CALL_OW 297
8092: PUSH
8093: LD_INT 9
8095: GREATER
8096: IFFALSE 8113
// ComMoveXY ( i , 147 , 4 ) ;
8098: LD_VAR 0 1
8102: PPUSH
8103: LD_INT 147
8105: PPUSH
8106: LD_INT 4
8108: PPUSH
8109: CALL_OW 111
8113: GO 8074
8115: POP
8116: POP
// wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8124: LD_VAR 0 2
8128: PPUSH
8129: LD_INT 92
8131: PUSH
8132: LD_INT 147
8134: PUSH
8135: LD_INT 4
8137: PUSH
8138: LD_INT 9
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: LIST
8145: LIST
8146: PPUSH
8147: CALL_OW 72
8151: PUSH
8152: LD_VAR 0 2
8156: PUSH
8157: LD_INT 1
8159: MINUS
8160: GREATEREQUAL
8161: IFFALSE 8039
// end ; repeat wait ( 0 0$1 ) ;
8163: LD_INT 35
8165: PPUSH
8166: CALL_OW 67
// for i in tmp do
8170: LD_ADDR_VAR 0 1
8174: PUSH
8175: LD_VAR 0 2
8179: PUSH
8180: FOR_IN
8181: IFFALSE 8263
// begin if GetLives ( i ) > 251 then
8183: LD_VAR 0 1
8187: PPUSH
8188: CALL_OW 256
8192: PUSH
8193: LD_INT 251
8195: GREATER
8196: IFFALSE 8234
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8198: LD_VAR 0 1
8202: PPUSH
8203: LD_INT 81
8205: PUSH
8206: LD_INT 8
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL_OW 69
8217: PPUSH
8218: LD_VAR 0 1
8222: PPUSH
8223: CALL_OW 74
8227: PPUSH
8228: CALL_OW 115
8232: GO 8261
// if IsDead ( i ) then
8234: LD_VAR 0 1
8238: PPUSH
8239: CALL_OW 301
8243: IFFALSE 8261
// tmp := tmp diff i ;
8245: LD_ADDR_VAR 0 2
8249: PUSH
8250: LD_VAR 0 2
8254: PUSH
8255: LD_VAR 0 1
8259: DIFF
8260: ST_TO_ADDR
// end ;
8261: GO 8180
8263: POP
8264: POP
// until not tmp ;
8265: LD_VAR 0 2
8269: NOT
8270: IFFALSE 8163
// end ;
8272: PPOPN 3
8274: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8275: LD_EXP 55
8279: PPUSH
8280: CALL_OW 302
8284: PUSH
8285: LD_EXP 3
8289: NOT
8290: AND
8291: IFFALSE 8300
8293: GO 8295
8295: DISABLE
// BuildKozlovBomb ;
8296: CALL 7287 0 0
8300: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8301: LD_INT 22
8303: PUSH
8304: LD_INT 8
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: PUSH
8311: LD_INT 34
8313: PUSH
8314: LD_INT 48
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: PPUSH
8325: CALL_OW 69
8329: IFFALSE 8377
8331: GO 8333
8333: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8334: LD_INT 22
8336: PUSH
8337: LD_INT 8
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: PUSH
8344: LD_INT 34
8346: PUSH
8347: LD_INT 48
8349: PUSH
8350: EMPTY
8351: LIST
8352: LIST
8353: PUSH
8354: EMPTY
8355: LIST
8356: LIST
8357: PPUSH
8358: CALL_OW 69
8362: PUSH
8363: LD_INT 1
8365: ARRAY
8366: PPUSH
8367: LD_INT 173
8369: PPUSH
8370: LD_INT 96
8372: PPUSH
8373: CALL_OW 116
// end ; end_of_file
8377: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8378: LD_INT 0
8380: PPUSH
8381: PPUSH
8382: PPUSH
8383: PPUSH
8384: PPUSH
8385: PPUSH
8386: PPUSH
8387: PPUSH
8388: PPUSH
// side := 3 ;
8389: LD_ADDR_VAR 0 6
8393: PUSH
8394: LD_INT 3
8396: ST_TO_ADDR
// InitHc ;
8397: CALL_OW 19
// uc_side := side ;
8401: LD_ADDR_OWVAR 20
8405: PUSH
8406: LD_VAR 0 6
8410: ST_TO_ADDR
// uc_nation := 3 ;
8411: LD_ADDR_OWVAR 21
8415: PUSH
8416: LD_INT 3
8418: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8419: LD_ADDR_VAR 0 2
8423: PUSH
8424: LD_INT 22
8426: PUSH
8427: LD_VAR 0 6
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PUSH
8436: LD_INT 21
8438: PUSH
8439: LD_INT 3
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: PPUSH
8450: CALL_OW 69
8454: PUSH
8455: FOR_IN
8456: IFFALSE 8472
// SetBLevel ( i , 10 ) ;
8458: LD_VAR 0 2
8462: PPUSH
8463: LD_INT 10
8465: PPUSH
8466: CALL_OW 241
8470: GO 8455
8472: POP
8473: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8474: LD_ADDR_VAR 0 9
8478: PUSH
8479: LD_INT 22
8481: PUSH
8482: LD_VAR 0 6
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PUSH
8491: LD_INT 30
8493: PUSH
8494: LD_INT 34
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PPUSH
8505: CALL_OW 69
8509: ST_TO_ADDR
// if teleport then
8510: LD_VAR 0 9
8514: IFFALSE 8535
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8516: LD_VAR 0 9
8520: PUSH
8521: LD_INT 1
8523: ARRAY
8524: PPUSH
8525: LD_INT 123
8527: PPUSH
8528: LD_INT 122
8530: PPUSH
8531: CALL_OW 243
// hc_importance := 0 ;
8535: LD_ADDR_OWVAR 32
8539: PUSH
8540: LD_INT 0
8542: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8543: LD_ADDR_EXP 56
8547: PUSH
8548: LD_STRING Platonov
8550: PPUSH
8551: CALL_OW 25
8555: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8556: LD_ADDR_EXP 57
8560: PUSH
8561: LD_STRING Yakotich
8563: PPUSH
8564: CALL_OW 25
8568: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8569: LD_ADDR_EXP 58
8573: PUSH
8574: LD_STRING Gleb
8576: PPUSH
8577: CALL_OW 25
8581: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8582: LD_STRING 03_Cornel
8584: PPUSH
8585: CALL_OW 28
8589: IFFALSE 8637
// begin Bierezov := NewCharacter ( Mikhail ) ;
8591: LD_ADDR_EXP 59
8595: PUSH
8596: LD_STRING Mikhail
8598: PPUSH
8599: CALL_OW 25
8603: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8604: LD_EXP 59
8608: PPUSH
8609: LD_INT 197
8611: PPUSH
8612: LD_INT 111
8614: PPUSH
8615: LD_INT 9
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8625: LD_EXP 59
8629: PPUSH
8630: LD_INT 3
8632: PPUSH
8633: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8637: LD_EXP 56
8641: PPUSH
8642: LD_INT 126
8644: PPUSH
8645: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8649: LD_EXP 57
8653: PPUSH
8654: LD_INT 197
8656: PPUSH
8657: LD_INT 111
8659: PPUSH
8660: LD_INT 9
8662: PPUSH
8663: LD_INT 0
8665: PPUSH
8666: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8670: LD_EXP 58
8674: PPUSH
8675: LD_INT 197
8677: PPUSH
8678: LD_INT 111
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: LD_INT 0
8686: PPUSH
8687: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8691: LD_ADDR_VAR 0 5
8695: PUSH
8696: LD_INT 126
8698: PPUSH
8699: LD_INT 2
8701: PPUSH
8702: LD_STRING zhukov
8704: PPUSH
8705: LD_INT 9
8707: PUSH
8708: LD_INT 10
8710: PUSH
8711: LD_INT 10
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: LIST
8718: PUSH
8719: LD_OWVAR 67
8723: ARRAY
8724: PPUSH
8725: LD_INT 9000
8727: PUSH
8728: LD_INT 1000
8730: PUSH
8731: LD_INT 300
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: PPUSH
8739: LD_INT 21
8741: PUSH
8742: LD_INT 8
8744: PUSH
8745: LD_INT 13
8747: PUSH
8748: LD_INT 8
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: LIST
8756: PPUSH
8757: CALL 59154 0 6
8761: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_INT 267
8769: PPUSH
8770: CALL_OW 274
8774: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8775: LD_VAR 0 4
8779: PPUSH
8780: LD_INT 1
8782: PPUSH
8783: LD_INT 5000
8785: PPUSH
8786: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8790: LD_VAR 0 4
8794: PPUSH
8795: LD_INT 2
8797: PPUSH
8798: LD_INT 200
8800: PPUSH
8801: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8805: LD_VAR 0 4
8809: PPUSH
8810: LD_INT 3
8812: PPUSH
8813: LD_INT 200
8815: PPUSH
8816: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8820: LD_ADDR_EXP 90
8824: PUSH
8825: LD_EXP 90
8829: PPUSH
8830: LD_INT 2
8832: PPUSH
8833: LD_VAR 0 5
8837: PUSH
8838: LD_INT 22
8840: PUSH
8841: LD_VAR 0 6
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: LD_INT 21
8855: PUSH
8856: LD_INT 2
8858: PUSH
8859: EMPTY
8860: LIST
8861: LIST
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PPUSH
8871: CALL_OW 69
8875: UNION
8876: PUSH
8877: LD_EXP 56
8881: DIFF
8882: PPUSH
8883: CALL_OW 1
8887: ST_TO_ADDR
// behemoths := [ ] ;
8888: LD_ADDR_EXP 60
8892: PUSH
8893: EMPTY
8894: ST_TO_ADDR
// behemothBuilders := [ ] ;
8895: LD_ADDR_EXP 61
8899: PUSH
8900: EMPTY
8901: ST_TO_ADDR
// j := 3 ;
8902: LD_ADDR_VAR 0 3
8906: PUSH
8907: LD_INT 3
8909: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_INT 22
8917: PUSH
8918: LD_INT 3
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 25
8927: PUSH
8928: LD_INT 3
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: PPUSH
8939: CALL_OW 69
8943: PUSH
8944: FOR_IN
8945: IFFALSE 8995
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8947: LD_ADDR_EXP 61
8951: PUSH
8952: LD_EXP 61
8956: PPUSH
8957: LD_VAR 0 2
8961: PPUSH
8962: CALL 87211 0 2
8966: ST_TO_ADDR
// j := j - 1 ;
8967: LD_ADDR_VAR 0 3
8971: PUSH
8972: LD_VAR 0 3
8976: PUSH
8977: LD_INT 1
8979: MINUS
8980: ST_TO_ADDR
// if j = 0 then
8981: LD_VAR 0 3
8985: PUSH
8986: LD_INT 0
8988: EQUAL
8989: IFFALSE 8993
// break ;
8991: GO 8995
// end ;
8993: GO 8944
8995: POP
8996: POP
// end ;
8997: LD_VAR 0 1
9001: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9002: LD_INT 0
9004: PPUSH
9005: PPUSH
9006: PPUSH
9007: PPUSH
9008: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9009: LD_ADDR_VAR 0 4
9013: PUSH
9014: LD_INT 209
9016: PUSH
9017: LD_INT 149
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 219
9026: PUSH
9027: LD_INT 154
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: PUSH
9034: LD_INT 223
9036: PUSH
9037: LD_INT 149
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: PUSH
9044: LD_INT 232
9046: PUSH
9047: LD_INT 155
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: LIST
9058: LIST
9059: ST_TO_ADDR
// if not behemothBuilders then
9060: LD_EXP 61
9064: NOT
9065: IFFALSE 9069
// exit ;
9067: GO 9173
// j := 1 ;
9069: LD_ADDR_VAR 0 3
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// for i in behemothBuilders do
9077: LD_ADDR_VAR 0 2
9081: PUSH
9082: LD_EXP 61
9086: PUSH
9087: FOR_IN
9088: IFFALSE 9171
// begin if IsInUnit ( i ) then
9090: LD_VAR 0 2
9094: PPUSH
9095: CALL_OW 310
9099: IFFALSE 9110
// ComExitBuilding ( i ) ;
9101: LD_VAR 0 2
9105: PPUSH
9106: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9110: LD_VAR 0 2
9114: PPUSH
9115: LD_INT 37
9117: PPUSH
9118: LD_VAR 0 4
9122: PUSH
9123: LD_VAR 0 3
9127: ARRAY
9128: PUSH
9129: LD_INT 1
9131: ARRAY
9132: PPUSH
9133: LD_VAR 0 4
9137: PUSH
9138: LD_VAR 0 3
9142: ARRAY
9143: PUSH
9144: LD_INT 2
9146: ARRAY
9147: PPUSH
9148: LD_INT 0
9150: PPUSH
9151: CALL_OW 230
// j := j + 1 ;
9155: LD_ADDR_VAR 0 3
9159: PUSH
9160: LD_VAR 0 3
9164: PUSH
9165: LD_INT 1
9167: PLUS
9168: ST_TO_ADDR
// end ;
9169: GO 9087
9171: POP
9172: POP
// end ;
9173: LD_VAR 0 1
9177: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9178: LD_INT 3
9180: PPUSH
9181: CALL 87272 0 1
9185: PUSH
9186: LD_INT 22
9188: PUSH
9189: LD_INT 3
9191: PUSH
9192: EMPTY
9193: LIST
9194: LIST
9195: PUSH
9196: LD_INT 30
9198: PUSH
9199: LD_INT 37
9201: PUSH
9202: EMPTY
9203: LIST
9204: LIST
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: PPUSH
9210: CALL_OW 69
9214: NOT
9215: AND
9216: IFFALSE 9402
9218: GO 9220
9220: DISABLE
9221: LD_INT 0
9223: PPUSH
9224: PPUSH
// begin enable ;
9225: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9226: LD_ADDR_VAR 0 2
9230: PUSH
9231: LD_INT 3
9233: PPUSH
9234: CALL 87272 0 1
9238: ST_TO_ADDR
// for i in tmp do
9239: LD_ADDR_VAR 0 1
9243: PUSH
9244: LD_VAR 0 2
9248: PUSH
9249: FOR_IN
9250: IFFALSE 9400
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9252: LD_VAR 0 1
9256: PPUSH
9257: LD_INT 7
9259: PPUSH
9260: CALL_OW 308
9264: PUSH
9265: LD_VAR 0 1
9269: PPUSH
9270: CALL_OW 110
9274: PUSH
9275: LD_INT 2
9277: EQUAL
9278: NOT
9279: AND
9280: IFFALSE 9294
// SetTag ( i , 2 ) ;
9282: LD_VAR 0 1
9286: PPUSH
9287: LD_INT 2
9289: PPUSH
9290: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9294: LD_INT 81
9296: PUSH
9297: LD_INT 3
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: LD_INT 91
9306: PUSH
9307: LD_VAR 0 1
9311: PUSH
9312: LD_INT 12
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: LIST
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PPUSH
9324: CALL_OW 69
9328: NOT
9329: PUSH
9330: LD_VAR 0 1
9334: PPUSH
9335: CALL_OW 110
9339: PUSH
9340: LD_INT 2
9342: EQUAL
9343: NOT
9344: AND
9345: IFFALSE 9364
// ComAgressiveMove ( i , 64 , 93 ) else
9347: LD_VAR 0 1
9351: PPUSH
9352: LD_INT 64
9354: PPUSH
9355: LD_INT 93
9357: PPUSH
9358: CALL_OW 114
9362: GO 9398
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9364: LD_VAR 0 1
9368: PPUSH
9369: LD_INT 81
9371: PUSH
9372: LD_INT 3
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PPUSH
9379: CALL_OW 69
9383: PPUSH
9384: LD_VAR 0 1
9388: PPUSH
9389: CALL_OW 74
9393: PPUSH
9394: CALL_OW 115
// end ;
9398: GO 9249
9400: POP
9401: POP
// end ;
9402: PPOPN 2
9404: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9405: LD_EXP 2
9409: NOT
9410: PUSH
9411: LD_INT 2
9413: PPUSH
9414: LD_INT 1
9416: PPUSH
9417: CALL 45944 0 2
9421: NOT
9422: AND
9423: IFFALSE 10343
9425: GO 9427
9427: DISABLE
9428: LD_INT 0
9430: PPUSH
9431: PPUSH
9432: PPUSH
9433: PPUSH
// begin enable ;
9434: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9435: LD_INT 22
9437: PUSH
9438: LD_INT 3
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: LD_INT 30
9447: PUSH
9448: LD_INT 3
9450: PUSH
9451: EMPTY
9452: LIST
9453: LIST
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: PPUSH
9459: CALL_OW 69
9463: NOT
9464: IFFALSE 9468
// exit ;
9466: GO 10343
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9468: LD_ADDR_VAR 0 4
9472: PUSH
9473: LD_INT 22
9475: PUSH
9476: LD_INT 3
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 30
9485: PUSH
9486: LD_INT 34
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: PPUSH
9497: CALL_OW 69
9501: ST_TO_ADDR
// if Prob ( 40 ) then
9502: LD_INT 40
9504: PPUSH
9505: CALL_OW 13
9509: IFFALSE 9636
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9511: LD_INT 2
9513: PPUSH
9514: LD_INT 22
9516: PUSH
9517: LD_INT 3
9519: PUSH
9520: LD_INT 3
9522: PUSH
9523: LD_INT 49
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: PUSH
9532: LD_INT 22
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: LD_INT 3
9540: PUSH
9541: LD_INT 49
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_INT 22
9552: PUSH
9553: LD_INT 3
9555: PUSH
9556: LD_INT 3
9558: PUSH
9559: LD_INT 49
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: PUSH
9568: LD_INT 24
9570: PUSH
9571: LD_INT 3
9573: PUSH
9574: LD_INT 3
9576: PUSH
9577: LD_INT 46
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: PUSH
9586: LD_INT 24
9588: PUSH
9589: LD_INT 3
9591: PUSH
9592: LD_INT 3
9594: PUSH
9595: LD_INT 46
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 24
9606: PUSH
9607: LD_INT 3
9609: PUSH
9610: LD_INT 3
9612: PUSH
9613: LD_INT 46
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: PPUSH
9630: CALL 44526 0 2
// end else
9634: GO 9759
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9636: LD_INT 2
9638: PPUSH
9639: LD_INT 24
9641: PUSH
9642: LD_INT 3
9644: PUSH
9645: LD_INT 3
9647: PUSH
9648: LD_INT 47
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: PUSH
9657: LD_INT 24
9659: PUSH
9660: LD_INT 3
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: LD_INT 47
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: PUSH
9675: LD_INT 24
9677: PUSH
9678: LD_INT 3
9680: PUSH
9681: LD_INT 3
9683: PUSH
9684: LD_INT 47
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: PUSH
9693: LD_INT 24
9695: PUSH
9696: LD_INT 3
9698: PUSH
9699: LD_INT 3
9701: PUSH
9702: LD_INT 46
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: PUSH
9711: LD_INT 24
9713: PUSH
9714: LD_INT 3
9716: PUSH
9717: LD_INT 3
9719: PUSH
9720: LD_INT 46
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: LIST
9728: PUSH
9729: LD_INT 24
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 3
9737: PUSH
9738: LD_INT 46
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: LIST
9745: LIST
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: PPUSH
9755: CALL 44526 0 2
// end ; if Difficulty > 1 then
9759: LD_OWVAR 67
9763: PUSH
9764: LD_INT 1
9766: GREATER
9767: IFFALSE 9797
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9769: LD_INT 2
9771: PPUSH
9772: LD_INT 24
9774: PUSH
9775: LD_INT 3
9777: PUSH
9778: LD_INT 3
9780: PUSH
9781: LD_INT 47
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: EMPTY
9791: LIST
9792: PPUSH
9793: CALL 44526 0 2
// repeat wait ( 0 0$1 ) ;
9797: LD_INT 35
9799: PPUSH
9800: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9804: LD_INT 2
9806: PPUSH
9807: LD_INT 1
9809: PPUSH
9810: CALL 45944 0 2
9814: PUSH
9815: LD_INT 6
9817: PUSH
9818: LD_INT 7
9820: PUSH
9821: LD_INT 7
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: LD_OWVAR 67
9833: ARRAY
9834: GREATEREQUAL
9835: IFFALSE 9797
// wait ( 0 0$30 ) ;
9837: LD_INT 1050
9839: PPUSH
9840: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9844: LD_ADDR_VAR 0 2
9848: PUSH
9849: LD_INT 2
9851: PPUSH
9852: LD_INT 1
9854: PPUSH
9855: CALL 45944 0 2
9859: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9860: LD_ADDR_EXP 109
9864: PUSH
9865: LD_EXP 109
9869: PPUSH
9870: LD_INT 2
9872: PPUSH
9873: LD_EXP 109
9877: PUSH
9878: LD_INT 2
9880: ARRAY
9881: PUSH
9882: LD_VAR 0 2
9886: DIFF
9887: PPUSH
9888: CALL_OW 1
9892: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9893: LD_ADDR_VAR 0 3
9897: PUSH
9898: LD_INT 0
9900: PPUSH
9901: LD_INT 1
9903: PPUSH
9904: CALL_OW 12
9908: ST_TO_ADDR
// if target then
9909: LD_VAR 0 3
9913: IFFALSE 10041
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9915: LD_ADDR_VAR 0 2
9919: PUSH
9920: LD_VAR 0 2
9924: PPUSH
9925: LD_INT 24
9927: PUSH
9928: LD_INT 250
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: PPUSH
9935: CALL_OW 72
9939: ST_TO_ADDR
// for i in tmp do
9940: LD_ADDR_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: FOR_IN
9951: IFFALSE 9991
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9953: LD_VAR 0 1
9957: PPUSH
9958: LD_INT 139
9960: PPUSH
9961: LD_INT 89
9963: PPUSH
9964: CALL_OW 297
9968: PUSH
9969: LD_INT 9
9971: GREATER
9972: IFFALSE 9989
// ComMoveXY ( i , 139 , 89 ) ;
9974: LD_VAR 0 1
9978: PPUSH
9979: LD_INT 139
9981: PPUSH
9982: LD_INT 89
9984: PPUSH
9985: CALL_OW 111
9989: GO 9950
9991: POP
9992: POP
// wait ( 0 0$1 ) ;
9993: LD_INT 35
9995: PPUSH
9996: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10000: LD_VAR 0 2
10004: PPUSH
10005: LD_INT 92
10007: PUSH
10008: LD_INT 139
10010: PUSH
10011: LD_INT 89
10013: PUSH
10014: LD_INT 9
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: LIST
10021: LIST
10022: PPUSH
10023: CALL_OW 72
10027: PUSH
10028: LD_VAR 0 2
10032: PUSH
10033: LD_INT 1
10035: MINUS
10036: GREATEREQUAL
10037: IFFALSE 9915
// end else
10039: GO 10183
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10041: LD_VAR 0 2
10045: PPUSH
10046: LD_VAR 0 4
10050: PUSH
10051: LD_INT 1
10053: ARRAY
10054: PPUSH
10055: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10059: LD_ADDR_VAR 0 2
10063: PUSH
10064: LD_VAR 0 2
10068: PPUSH
10069: LD_INT 24
10071: PUSH
10072: LD_INT 250
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: PPUSH
10079: CALL_OW 72
10083: ST_TO_ADDR
// for i in tmp do
10084: LD_ADDR_VAR 0 1
10088: PUSH
10089: LD_VAR 0 2
10093: PUSH
10094: FOR_IN
10095: IFFALSE 10135
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10097: LD_VAR 0 1
10101: PPUSH
10102: LD_INT 124
10104: PPUSH
10105: LD_INT 139
10107: PPUSH
10108: CALL_OW 297
10112: PUSH
10113: LD_INT 9
10115: GREATER
10116: IFFALSE 10133
// ComMoveXY ( i , 124 , 139 ) ;
10118: LD_VAR 0 1
10122: PPUSH
10123: LD_INT 124
10125: PPUSH
10126: LD_INT 139
10128: PPUSH
10129: CALL_OW 111
10133: GO 10094
10135: POP
10136: POP
// wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10144: LD_VAR 0 2
10148: PPUSH
10149: LD_INT 92
10151: PUSH
10152: LD_INT 124
10154: PUSH
10155: LD_INT 139
10157: PUSH
10158: LD_INT 9
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: PPUSH
10167: CALL_OW 72
10171: PUSH
10172: LD_VAR 0 2
10176: PUSH
10177: LD_INT 1
10179: MINUS
10180: GREATEREQUAL
10181: IFFALSE 10059
// end ; repeat wait ( 0 0$1 ) ;
10183: LD_INT 35
10185: PPUSH
10186: CALL_OW 67
// for i in tmp do
10190: LD_ADDR_VAR 0 1
10194: PUSH
10195: LD_VAR 0 2
10199: PUSH
10200: FOR_IN
10201: IFFALSE 10334
// begin if GetLives ( i ) > 251 then
10203: LD_VAR 0 1
10207: PPUSH
10208: CALL_OW 256
10212: PUSH
10213: LD_INT 251
10215: GREATER
10216: IFFALSE 10305
// begin if GetWeapon ( i ) = ru_time_lapser then
10218: LD_VAR 0 1
10222: PPUSH
10223: CALL_OW 264
10227: PUSH
10228: LD_INT 49
10230: EQUAL
10231: IFFALSE 10269
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10233: LD_VAR 0 1
10237: PPUSH
10238: LD_INT 81
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PPUSH
10253: LD_VAR 0 1
10257: PPUSH
10258: CALL_OW 74
10262: PPUSH
10263: CALL_OW 112
10267: GO 10303
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10269: LD_VAR 0 1
10273: PPUSH
10274: LD_INT 81
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: PPUSH
10284: CALL_OW 69
10288: PPUSH
10289: LD_VAR 0 1
10293: PPUSH
10294: CALL_OW 74
10298: PPUSH
10299: CALL_OW 115
// end else
10303: GO 10332
// if IsDead ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 301
10314: IFFALSE 10332
// tmp := tmp diff i ;
10316: LD_ADDR_VAR 0 2
10320: PUSH
10321: LD_VAR 0 2
10325: PUSH
10326: LD_VAR 0 1
10330: DIFF
10331: ST_TO_ADDR
// end ;
10332: GO 10200
10334: POP
10335: POP
// until not tmp ;
10336: LD_VAR 0 2
10340: NOT
10341: IFFALSE 10183
// end ;
10343: PPOPN 4
10345: END
// every 30 30$00 trigger not russianDestroyed do
10346: LD_EXP 2
10350: NOT
10351: IFFALSE 10416
10353: GO 10355
10355: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10356: LD_INT 105000
10358: PUSH
10359: LD_INT 84000
10361: PUSH
10362: LD_INT 63000
10364: PUSH
10365: EMPTY
10366: LIST
10367: LIST
10368: LIST
10369: PUSH
10370: LD_OWVAR 67
10374: ARRAY
10375: PPUSH
10376: CALL_OW 67
// if russianDestroyed then
10380: LD_EXP 2
10384: IFFALSE 10388
// exit ;
10386: GO 10416
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10388: LD_INT 2
10390: PPUSH
10391: LD_INT 23
10393: PUSH
10394: LD_INT 3
10396: PUSH
10397: LD_INT 1
10399: PUSH
10400: LD_INT 48
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: PUSH
10409: EMPTY
10410: LIST
10411: PPUSH
10412: CALL 44526 0 2
// end ; end_of_file
10416: END
// export function CustomEvent ( event ) ; begin
10417: LD_INT 0
10419: PPUSH
// end ;
10420: LD_VAR 0 2
10424: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10425: LD_VAR 0 2
10429: PPUSH
10430: LD_VAR 0 3
10434: PPUSH
10435: LD_INT 15
10437: PPUSH
10438: CALL_OW 309
10442: IFFALSE 10451
// YouLost ( MothContaminate ) ;
10444: LD_STRING MothContaminate
10446: PPUSH
10447: CALL_OW 104
// end ;
10451: PPOPN 3
10453: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10454: LD_VAR 0 2
10458: PPUSH
10459: LD_VAR 0 3
10463: PPUSH
10464: LD_INT 15
10466: PPUSH
10467: CALL_OW 309
10471: IFFALSE 10487
// begin wait ( 0 0$6 ) ;
10473: LD_INT 210
10475: PPUSH
10476: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10480: LD_STRING MothContaminateBomb
10482: PPUSH
10483: CALL_OW 104
// end ; end ;
10487: PPOPN 3
10489: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10490: LD_VAR 0 1
10494: PUSH
10495: LD_EXP 17
10499: EQUAL
10500: IFFALSE 10511
// begin YouLost ( JMM ) ;
10502: LD_STRING JMM
10504: PPUSH
10505: CALL_OW 104
// exit ;
10509: GO 10610
// end ; if un = Powell then
10511: LD_VAR 0 1
10515: PUSH
10516: LD_EXP 52
10520: EQUAL
10521: IFFALSE 10531
// americanDestroyed := true ;
10523: LD_ADDR_EXP 4
10527: PUSH
10528: LD_INT 1
10530: ST_TO_ADDR
// if un = Platonov then
10531: LD_VAR 0 1
10535: PUSH
10536: LD_EXP 56
10540: EQUAL
10541: IFFALSE 10551
// russianDestroyed := true ;
10543: LD_ADDR_EXP 2
10547: PUSH
10548: LD_INT 1
10550: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10551: LD_VAR 0 1
10555: PUSH
10556: LD_INT 22
10558: PUSH
10559: LD_INT 7
10561: PUSH
10562: EMPTY
10563: LIST
10564: LIST
10565: PUSH
10566: LD_INT 21
10568: PUSH
10569: LD_INT 2
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: PUSH
10576: EMPTY
10577: LIST
10578: LIST
10579: PPUSH
10580: CALL_OW 69
10584: IN
10585: IFFALSE 10601
// vehicleLostCounter := vehicleLostCounter + 1 ;
10587: LD_ADDR_EXP 15
10591: PUSH
10592: LD_EXP 15
10596: PUSH
10597: LD_INT 1
10599: PLUS
10600: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10601: LD_VAR 0 1
10605: PPUSH
10606: CALL 47937 0 1
// end ;
10610: PPOPN 1
10612: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_VAR 0 2
10622: PPUSH
10623: CALL 50271 0 2
// end ;
10627: PPOPN 2
10629: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10630: LD_VAR 0 1
10634: PPUSH
10635: CALL 49339 0 1
// end ;
10639: PPOPN 1
10641: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10642: LD_VAR 0 1
10646: PUSH
10647: LD_INT 22
10649: PUSH
10650: LD_INT 8
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: PUSH
10657: LD_INT 30
10659: PUSH
10660: LD_INT 2
10662: PUSH
10663: EMPTY
10664: LIST
10665: LIST
10666: PUSH
10667: LD_INT 23
10669: PUSH
10670: LD_INT 3
10672: PUSH
10673: EMPTY
10674: LIST
10675: LIST
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: LIST
10681: PPUSH
10682: CALL_OW 69
10686: IN
10687: IFFALSE 10714
// begin ComUpgrade ( building ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10698: LD_EXP 55
10702: PPUSH
10703: LD_VAR 0 1
10707: PPUSH
10708: CALL 58692 0 2
// exit ;
10712: GO 10723
// end ; MCE_BuildingComplete ( building ) ;
10714: LD_VAR 0 1
10718: PPUSH
10719: CALL 49580 0 1
// end ;
10723: PPOPN 1
10725: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10726: LD_VAR 0 1
10730: PPUSH
10731: LD_VAR 0 2
10735: PPUSH
10736: CALL 47633 0 2
// end ;
10740: PPOPN 2
10742: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10743: LD_VAR 0 1
10747: PPUSH
10748: LD_VAR 0 2
10752: PPUSH
10753: LD_VAR 0 3
10757: PPUSH
10758: LD_VAR 0 4
10762: PPUSH
10763: LD_VAR 0 5
10767: PPUSH
10768: CALL 47253 0 5
// end ;
10772: PPOPN 5
10774: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10775: LD_VAR 0 1
10779: PPUSH
10780: LD_VAR 0 2
10784: PPUSH
10785: CALL 46843 0 2
// end ;
10789: PPOPN 2
10791: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10792: LD_VAR 0 1
10796: PPUSH
10797: LD_VAR 0 2
10801: PPUSH
10802: LD_VAR 0 3
10806: PPUSH
10807: LD_VAR 0 4
10811: PPUSH
10812: CALL 46681 0 4
// end ;
10816: PPOPN 4
10818: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10819: LD_VAR 0 1
10823: PPUSH
10824: LD_VAR 0 2
10828: PPUSH
10829: LD_VAR 0 3
10833: PPUSH
10834: CALL 46456 0 3
// end ;
10838: PPOPN 3
10840: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10841: LD_VAR 0 1
10845: PPUSH
10846: LD_VAR 0 2
10850: PPUSH
10851: CALL 46341 0 2
// end ;
10855: PPOPN 2
10857: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10858: LD_VAR 0 1
10862: PPUSH
10863: LD_VAR 0 2
10867: PPUSH
10868: CALL 50532 0 2
// end ;
10872: PPOPN 2
10874: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10875: LD_VAR 0 1
10879: PPUSH
10880: LD_VAR 0 2
10884: PPUSH
10885: LD_VAR 0 3
10889: PPUSH
10890: LD_VAR 0 4
10894: PPUSH
10895: CALL 50748 0 4
// end ;
10899: PPOPN 4
10901: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10902: LD_VAR 0 1
10906: PPUSH
10907: LD_VAR 0 2
10911: PPUSH
10912: CALL 46150 0 2
// end ;
10916: PPOPN 2
10918: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10919: LD_VAR 0 1
10923: PPUSH
10924: CALL 101818 0 1
// end ; end_of_file
10928: PPOPN 1
10930: END
// export function Action ; begin
10931: LD_INT 0
10933: PPUSH
// InGameOn ;
10934: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10938: LD_INT 206
10940: PPUSH
10941: LD_INT 11
10943: PPUSH
10944: CALL_OW 86
// wait ( 0 0$1 ) ;
10948: LD_INT 35
10950: PPUSH
10951: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10955: LD_EXP 17
10959: PPUSH
10960: LD_STRING DStart-JMM-JMM-1
10962: PPUSH
10963: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10967: LD_EXP 49
10971: PPUSH
10972: LD_STRING DStart-JMM-Bur-1
10974: PPUSH
10975: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10979: LD_EXP 17
10983: PPUSH
10984: LD_STRING DStart-JMM-JMM-2
10986: PPUSH
10987: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10991: LD_EXP 49
10995: PPUSH
10996: LD_STRING DStart-JMM-Bur-2
10998: PPUSH
10999: CALL_OW 88
// InGameOff ;
11003: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11007: LD_STRING MStart
11009: PPUSH
11010: CALL_OW 337
// SaveForQuickRestart ;
11014: CALL_OW 22
// end ;
11018: LD_VAR 0 1
11022: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11023: LD_INT 7
11025: PPUSH
11026: LD_INT 255
11028: PPUSH
11029: LD_INT 219
11031: PPUSH
11032: CALL_OW 293
11036: IFFALSE 11645
11038: GO 11040
11040: DISABLE
11041: LD_INT 0
11043: PPUSH
// begin wait ( 0 0$3 ) ;
11044: LD_INT 105
11046: PPUSH
11047: CALL_OW 67
// alienSpotted := true ;
11051: LD_ADDR_EXP 10
11055: PUSH
11056: LD_INT 1
11058: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11059: LD_ADDR_VAR 0 1
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 7
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: LD_INT 23
11076: PUSH
11077: LD_INT 3
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PUSH
11084: LD_INT 21
11086: PUSH
11087: LD_INT 1
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: LD_INT 26
11096: PUSH
11097: LD_INT 1
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: PPUSH
11110: CALL_OW 69
11114: PUSH
11115: LD_EXP 49
11119: PUSH
11120: LD_EXP 37
11124: PUSH
11125: LD_EXP 39
11129: PUSH
11130: LD_EXP 40
11134: PUSH
11135: LD_EXP 47
11139: PUSH
11140: LD_EXP 46
11144: PUSH
11145: LD_EXP 41
11149: PUSH
11150: EMPTY
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: DIFF
11159: ST_TO_ADDR
// DialogueOn ;
11160: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11164: LD_INT 255
11166: PPUSH
11167: LD_INT 219
11169: PPUSH
11170: LD_INT 7
11172: PPUSH
11173: LD_INT 20
11175: NEG
11176: PPUSH
11177: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11181: LD_INT 255
11183: PPUSH
11184: LD_INT 219
11186: PPUSH
11187: CALL_OW 86
// if speaker then
11191: LD_VAR 0 1
11195: IFFALSE 11213
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11197: LD_VAR 0 1
11201: PUSH
11202: LD_INT 1
11204: ARRAY
11205: PPUSH
11206: LD_STRING DAlienBase-RSol1-1
11208: PPUSH
11209: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11213: LD_EXP 17
11217: PPUSH
11218: LD_STRING DAlienBase-JMM-1
11220: PPUSH
11221: CALL_OW 88
// if IsOk ( Burlak ) then
11225: LD_EXP 49
11229: PPUSH
11230: CALL_OW 302
11234: IFFALSE 11255
// begin dwait ( 0 0$1 ) ;
11236: LD_INT 35
11238: PPUSH
11239: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11243: LD_EXP 49
11247: PPUSH
11248: LD_STRING DAlienBase-Bur-1
11250: PPUSH
11251: CALL_OW 88
// end ; if IsOk ( Roth ) then
11255: LD_EXP 18
11259: PPUSH
11260: CALL_OW 302
11264: IFFALSE 11278
// Say ( Roth , DAlienBase-Roth-1 ) ;
11266: LD_EXP 18
11270: PPUSH
11271: LD_STRING DAlienBase-Roth-1
11273: PPUSH
11274: CALL_OW 88
// if IsOk ( Gossudarov ) then
11278: LD_EXP 35
11282: PPUSH
11283: CALL_OW 302
11287: IFFALSE 11303
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11289: LD_EXP 35
11293: PPUSH
11294: LD_STRING DAlienBase-Gos-1
11296: PPUSH
11297: CALL_OW 88
11301: GO 11420
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11303: LD_ADDR_VAR 0 1
11307: PUSH
11308: LD_INT 22
11310: PUSH
11311: LD_INT 7
11313: PUSH
11314: EMPTY
11315: LIST
11316: LIST
11317: PUSH
11318: LD_INT 25
11320: PUSH
11321: LD_INT 4
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: PUSH
11328: LD_INT 21
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 26
11340: PUSH
11341: LD_INT 1
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: EMPTY
11349: LIST
11350: LIST
11351: LIST
11352: LIST
11353: PPUSH
11354: CALL_OW 69
11358: PUSH
11359: LD_EXP 18
11363: PUSH
11364: LD_EXP 17
11368: PUSH
11369: LD_EXP 49
11373: PUSH
11374: LD_EXP 37
11378: PUSH
11379: LD_EXP 47
11383: PUSH
11384: LD_EXP 46
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: DIFF
11397: ST_TO_ADDR
// if speaker then
11398: LD_VAR 0 1
11402: IFFALSE 11420
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11404: LD_VAR 0 1
11408: PUSH
11409: LD_INT 1
11411: ARRAY
11412: PPUSH
11413: LD_STRING DAlienBase-Sci1-1
11415: PPUSH
11416: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11420: LD_INT 255
11422: PPUSH
11423: LD_INT 219
11425: PPUSH
11426: LD_INT 7
11428: PPUSH
11429: CALL_OW 331
// DialogueOff ;
11433: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11437: LD_INT 35
11439: PPUSH
11440: CALL_OW 67
// until IsSelected ( alien ) ;
11444: LD_INT 1
11446: PPUSH
11447: CALL_OW 306
11451: IFFALSE 11437
// if not artifactIResearched or not artifactIIResearched then
11453: LD_EXP 12
11457: NOT
11458: PUSH
11459: LD_EXP 13
11463: NOT
11464: OR
11465: IFFALSE 11645
// begin if IsOk ( Roth ) then
11467: LD_EXP 18
11471: PPUSH
11472: CALL_OW 302
11476: IFFALSE 11492
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11478: LD_EXP 18
11482: PPUSH
11483: LD_STRING DAlieBaseNotReady-Roth-1
11485: PPUSH
11486: CALL_OW 88
11490: GO 11645
// if IsOk ( Gossudarov ) then
11492: LD_EXP 35
11496: PPUSH
11497: CALL_OW 302
11501: IFFALSE 11517
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11503: LD_EXP 35
11507: PPUSH
11508: LD_STRING DAlieBaseNotReady-Gos-1
11510: PPUSH
11511: CALL_OW 88
11515: GO 11645
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11517: LD_ADDR_VAR 0 1
11521: PUSH
11522: LD_INT 22
11524: PUSH
11525: LD_INT 7
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: PUSH
11532: LD_INT 23
11534: PUSH
11535: LD_INT 3
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 4
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 21
11554: PUSH
11555: LD_INT 1
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 26
11564: PUSH
11565: LD_INT 1
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: PPUSH
11579: CALL_OW 69
11583: PUSH
11584: LD_EXP 18
11588: PUSH
11589: LD_EXP 17
11593: PUSH
11594: LD_EXP 49
11598: PUSH
11599: LD_EXP 37
11603: PUSH
11604: LD_EXP 47
11608: PUSH
11609: LD_EXP 46
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: DIFF
11622: ST_TO_ADDR
// if speaker then
11623: LD_VAR 0 1
11627: IFFALSE 11645
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11629: LD_VAR 0 1
11633: PUSH
11634: LD_INT 1
11636: ARRAY
11637: PPUSH
11638: LD_STRING DAlieBaseNotReady-RSci1-1
11640: PPUSH
11641: CALL_OW 88
// end ; end ; end ;
11645: PPOPN 1
11647: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11648: LD_INT 24
11650: PPUSH
11651: LD_INT 7
11653: PPUSH
11654: CALL_OW 321
11658: PUSH
11659: LD_INT 2
11661: EQUAL
11662: IFFALSE 12353
11664: GO 11666
11666: DISABLE
11667: LD_INT 0
11669: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11670: LD_ADDR_VAR 0 1
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_INT 7
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PUSH
11685: LD_INT 23
11687: PUSH
11688: LD_INT 3
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PUSH
11695: LD_INT 25
11697: PUSH
11698: LD_INT 4
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: PUSH
11705: LD_INT 21
11707: PUSH
11708: LD_INT 1
11710: PUSH
11711: EMPTY
11712: LIST
11713: LIST
11714: PUSH
11715: LD_INT 26
11717: PUSH
11718: LD_INT 1
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: PPUSH
11732: CALL_OW 69
11736: PUSH
11737: LD_EXP 18
11741: PUSH
11742: LD_EXP 17
11746: PUSH
11747: LD_EXP 49
11751: PUSH
11752: LD_EXP 37
11756: PUSH
11757: LD_EXP 47
11761: PUSH
11762: LD_EXP 46
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: DIFF
11775: ST_TO_ADDR
// if not speaker then
11776: LD_VAR 0 1
11780: NOT
11781: IFFALSE 11785
// exit ;
11783: GO 12353
// DialogueOn ;
11785: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11789: LD_VAR 0 1
11793: PUSH
11794: LD_INT 1
11796: ARRAY
11797: PPUSH
11798: LD_STRING DArtefTechnology-RSci1-1
11800: PPUSH
11801: CALL_OW 88
// if IsOk ( Burlak ) then
11805: LD_EXP 49
11809: PPUSH
11810: CALL_OW 302
11814: IFFALSE 11828
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11816: LD_EXP 49
11820: PPUSH
11821: LD_STRING DArtefTechnology-Bur-1
11823: PPUSH
11824: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11828: LD_VAR 0 1
11832: PUSH
11833: LD_INT 1
11835: ARRAY
11836: PPUSH
11837: LD_STRING DArtefTechnology-RSci1-2
11839: PPUSH
11840: CALL_OW 88
// if Denis then
11844: LD_EXP 23
11848: IFFALSE 11865
// speaker := [ Denis ] else
11850: LD_ADDR_VAR 0 1
11854: PUSH
11855: LD_EXP 23
11859: PUSH
11860: EMPTY
11861: LIST
11862: ST_TO_ADDR
11863: GO 11971
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11865: LD_ADDR_VAR 0 1
11869: PUSH
11870: LD_INT 22
11872: PUSH
11873: LD_INT 7
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PUSH
11880: LD_INT 23
11882: PUSH
11883: LD_INT 1
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: PUSH
11890: LD_INT 25
11892: PUSH
11893: LD_INT 4
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: PUSH
11900: LD_INT 21
11902: PUSH
11903: LD_INT 1
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 26
11912: PUSH
11913: LD_INT 1
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: LIST
11924: LIST
11925: LIST
11926: PPUSH
11927: CALL_OW 69
11931: PUSH
11932: LD_EXP 18
11936: PUSH
11937: LD_EXP 17
11941: PUSH
11942: LD_EXP 49
11946: PUSH
11947: LD_EXP 37
11951: PUSH
11952: LD_EXP 47
11956: PUSH
11957: LD_EXP 46
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: DIFF
11970: ST_TO_ADDR
// if speaker then
11971: LD_VAR 0 1
11975: IFFALSE 11993
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11977: LD_VAR 0 1
11981: PUSH
11982: LD_INT 1
11984: ARRAY
11985: PPUSH
11986: LD_STRING DArtefTechnology-Sci1-2
11988: PPUSH
11989: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11993: LD_ADDR_VAR 0 1
11997: PUSH
11998: LD_INT 22
12000: PUSH
12001: LD_INT 7
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: PUSH
12008: LD_INT 23
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: EMPTY
12015: LIST
12016: LIST
12017: PUSH
12018: LD_INT 25
12020: PUSH
12021: LD_INT 4
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 21
12030: PUSH
12031: LD_INT 1
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 26
12040: PUSH
12041: LD_INT 1
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: LIST
12054: PPUSH
12055: CALL_OW 69
12059: PUSH
12060: LD_EXP 18
12064: PUSH
12065: LD_EXP 17
12069: PUSH
12070: LD_EXP 49
12074: PUSH
12075: LD_EXP 37
12079: PUSH
12080: LD_EXP 47
12084: PUSH
12085: LD_EXP 46
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: DIFF
12098: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12099: LD_VAR 0 1
12103: PUSH
12104: LD_EXP 9
12108: PUSH
12109: LD_EXP 5
12113: OR
12114: AND
12115: IFFALSE 12349
// begin if arabianDestroyed and IsOk ( Burlak ) then
12117: LD_EXP 5
12121: PUSH
12122: LD_EXP 49
12126: PPUSH
12127: CALL_OW 302
12131: AND
12132: IFFALSE 12148
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12134: LD_EXP 49
12138: PPUSH
12139: LD_STRING DArtefTechnology-Bur-2
12141: PPUSH
12142: CALL_OW 88
12146: GO 12160
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12148: LD_EXP 17
12152: PPUSH
12153: LD_STRING DArtefTechnology-JMM-2
12155: PPUSH
12156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12160: LD_VAR 0 1
12164: PUSH
12165: LD_INT 1
12167: ARRAY
12168: PPUSH
12169: LD_STRING DArtefTechnology-RSci1-3
12171: PPUSH
12172: CALL_OW 88
// if Denis then
12176: LD_EXP 23
12180: IFFALSE 12197
// speaker := [ Denis ] else
12182: LD_ADDR_VAR 0 1
12186: PUSH
12187: LD_EXP 23
12191: PUSH
12192: EMPTY
12193: LIST
12194: ST_TO_ADDR
12195: GO 12303
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12197: LD_ADDR_VAR 0 1
12201: PUSH
12202: LD_INT 22
12204: PUSH
12205: LD_INT 7
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: PUSH
12212: LD_INT 23
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: LD_INT 25
12224: PUSH
12225: LD_INT 4
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 21
12234: PUSH
12235: LD_INT 1
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 26
12244: PUSH
12245: LD_INT 1
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: PPUSH
12259: CALL_OW 69
12263: PUSH
12264: LD_EXP 18
12268: PUSH
12269: LD_EXP 17
12273: PUSH
12274: LD_EXP 49
12278: PUSH
12279: LD_EXP 37
12283: PUSH
12284: LD_EXP 47
12288: PUSH
12289: LD_EXP 46
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: DIFF
12302: ST_TO_ADDR
// if speaker then
12303: LD_VAR 0 1
12307: IFFALSE 12349
// if alienSpotted then
12309: LD_EXP 10
12313: IFFALSE 12333
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12315: LD_VAR 0 1
12319: PUSH
12320: LD_INT 1
12322: ARRAY
12323: PPUSH
12324: LD_STRING DArtefTechnology-Sci1-3
12326: PPUSH
12327: CALL_OW 88
12331: GO 12349
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12333: LD_VAR 0 1
12337: PUSH
12338: LD_INT 1
12340: ARRAY
12341: PPUSH
12342: LD_STRING DArtefTechnology-Sci1-3a
12344: PPUSH
12345: CALL_OW 88
// end ; DialogueOff ;
12349: CALL_OW 7
// end ;
12353: PPOPN 1
12355: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12356: LD_EXP 12
12360: IFFALSE 12555
12362: GO 12364
12364: DISABLE
12365: LD_INT 0
12367: PPUSH
// begin if Denis then
12368: LD_EXP 23
12372: IFFALSE 12389
// speaker := [ Denis ] else
12374: LD_ADDR_VAR 0 1
12378: PUSH
12379: LD_EXP 23
12383: PUSH
12384: EMPTY
12385: LIST
12386: ST_TO_ADDR
12387: GO 12495
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12389: LD_ADDR_VAR 0 1
12393: PUSH
12394: LD_INT 22
12396: PUSH
12397: LD_INT 7
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: PUSH
12404: LD_INT 23
12406: PUSH
12407: LD_INT 1
12409: PUSH
12410: EMPTY
12411: LIST
12412: LIST
12413: PUSH
12414: LD_INT 25
12416: PUSH
12417: LD_INT 4
12419: PUSH
12420: EMPTY
12421: LIST
12422: LIST
12423: PUSH
12424: LD_INT 21
12426: PUSH
12427: LD_INT 1
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: PUSH
12434: LD_INT 26
12436: PUSH
12437: LD_INT 1
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: PPUSH
12451: CALL_OW 69
12455: PUSH
12456: LD_EXP 18
12460: PUSH
12461: LD_EXP 17
12465: PUSH
12466: LD_EXP 49
12470: PUSH
12471: LD_EXP 37
12475: PUSH
12476: LD_EXP 47
12480: PUSH
12481: LD_EXP 46
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: DIFF
12494: ST_TO_ADDR
// if not speaker then
12495: LD_VAR 0 1
12499: NOT
12500: IFFALSE 12504
// exit ;
12502: GO 12555
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12504: LD_VAR 0 1
12508: PUSH
12509: LD_INT 1
12511: ARRAY
12512: PPUSH
12513: LD_STRING DArtefTechnologyAm-Sci1-1
12515: PPUSH
12516: CALL_OW 88
// if IsOk ( Burlak ) then
12520: LD_EXP 49
12524: PPUSH
12525: CALL_OW 302
12529: IFFALSE 12543
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12531: LD_EXP 49
12535: PPUSH
12536: LD_STRING DArtefTechnologyAm-Bur-1
12538: PPUSH
12539: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12543: LD_EXP 17
12547: PPUSH
12548: LD_STRING DArtefTechnologyAm-JMM-1
12550: PPUSH
12551: CALL_OW 88
// end ;
12555: PPOPN 1
12557: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12558: LD_EXP 13
12562: IFFALSE 12752
12564: GO 12566
12566: DISABLE
12567: LD_INT 0
12569: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12570: LD_ADDR_VAR 0 1
12574: PUSH
12575: LD_INT 22
12577: PUSH
12578: LD_INT 7
12580: PUSH
12581: EMPTY
12582: LIST
12583: LIST
12584: PUSH
12585: LD_INT 23
12587: PUSH
12588: LD_INT 3
12590: PUSH
12591: EMPTY
12592: LIST
12593: LIST
12594: PUSH
12595: LD_INT 25
12597: PUSH
12598: LD_INT 4
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: PUSH
12605: LD_INT 21
12607: PUSH
12608: LD_INT 1
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 26
12617: PUSH
12618: LD_INT 1
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: PPUSH
12632: CALL_OW 69
12636: PUSH
12637: LD_EXP 18
12641: PUSH
12642: LD_EXP 17
12646: PUSH
12647: LD_EXP 49
12651: PUSH
12652: LD_EXP 37
12656: PUSH
12657: LD_EXP 47
12661: PUSH
12662: LD_EXP 46
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: DIFF
12675: ST_TO_ADDR
// if not speaker then
12676: LD_VAR 0 1
12680: NOT
12681: IFFALSE 12685
// exit ;
12683: GO 12752
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12685: LD_VAR 0 1
12689: PUSH
12690: LD_INT 1
12692: ARRAY
12693: PPUSH
12694: LD_STRING DArtefTechnologyRu-RSci1-1
12696: PPUSH
12697: CALL_OW 88
// if IsOk ( Burlak ) then
12701: LD_EXP 49
12705: PPUSH
12706: CALL_OW 302
12710: IFFALSE 12724
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12712: LD_EXP 49
12716: PPUSH
12717: LD_STRING DArtefTechnologyRu-Bur-1
12719: PPUSH
12720: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12724: LD_VAR 0 1
12728: PUSH
12729: LD_INT 1
12731: ARRAY
12732: PPUSH
12733: LD_STRING DArtefTechnologyRu-RSci1-2
12735: PPUSH
12736: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12740: LD_EXP 17
12744: PPUSH
12745: LD_STRING DArtefTechnologyRu-JMM-1
12747: PPUSH
12748: CALL_OW 88
// end ;
12752: PPOPN 1
12754: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12755: LD_INT 24
12757: PPUSH
12758: LD_INT 7
12760: PPUSH
12761: CALL_OW 321
12765: PUSH
12766: LD_INT 2
12768: EQUAL
12769: PUSH
12770: LD_INT 1
12772: PPUSH
12773: CALL_OW 255
12777: PUSH
12778: LD_INT 7
12780: EQUAL
12781: AND
12782: IFFALSE 12942
12784: GO 12786
12786: DISABLE
12787: LD_INT 0
12789: PPUSH
// begin if Denis then
12790: LD_EXP 23
12794: IFFALSE 12811
// speaker := [ Denis ] else
12796: LD_ADDR_VAR 0 1
12800: PUSH
12801: LD_EXP 23
12805: PUSH
12806: EMPTY
12807: LIST
12808: ST_TO_ADDR
12809: GO 12917
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12811: LD_ADDR_VAR 0 1
12815: PUSH
12816: LD_INT 22
12818: PUSH
12819: LD_INT 7
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: LD_INT 23
12828: PUSH
12829: LD_INT 1
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 25
12838: PUSH
12839: LD_INT 4
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 21
12848: PUSH
12849: LD_INT 1
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: LD_INT 26
12858: PUSH
12859: LD_INT 1
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: PPUSH
12873: CALL_OW 69
12877: PUSH
12878: LD_EXP 18
12882: PUSH
12883: LD_EXP 17
12887: PUSH
12888: LD_EXP 49
12892: PUSH
12893: LD_EXP 37
12897: PUSH
12898: LD_EXP 47
12902: PUSH
12903: LD_EXP 46
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: DIFF
12916: ST_TO_ADDR
// if not speaker then
12917: LD_VAR 0 1
12921: NOT
12922: IFFALSE 12926
// exit ;
12924: GO 12942
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12926: LD_VAR 0 1
12930: PUSH
12931: LD_INT 1
12933: ARRAY
12934: PPUSH
12935: LD_STRING DArtefTechnologyArStart-Sci1-1
12937: PPUSH
12938: CALL_OW 88
// end ;
12942: PPOPN 1
12944: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12945: LD_EXP 14
12949: IFFALSE 13230
12951: GO 12953
12953: DISABLE
12954: LD_INT 0
12956: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12957: LD_ADDR_VAR 0 1
12961: PUSH
12962: LD_INT 22
12964: PUSH
12965: LD_INT 7
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 23
12974: PUSH
12975: LD_INT 3
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 25
12984: PUSH
12985: LD_INT 4
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 21
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 26
13004: PUSH
13005: LD_INT 1
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: PPUSH
13019: CALL_OW 69
13023: PUSH
13024: LD_EXP 18
13028: PUSH
13029: LD_EXP 17
13033: PUSH
13034: LD_EXP 49
13038: PUSH
13039: LD_EXP 37
13043: PUSH
13044: LD_EXP 47
13048: PUSH
13049: LD_EXP 46
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: DIFF
13062: ST_TO_ADDR
// if not speaker then
13063: LD_VAR 0 1
13067: NOT
13068: IFFALSE 13072
// exit ;
13070: GO 13230
// DialogueOn ;
13072: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13076: LD_VAR 0 1
13080: PUSH
13081: LD_INT 1
13083: ARRAY
13084: PPUSH
13085: LD_STRING DArtefTechnologyAr-RSci1-1
13087: PPUSH
13088: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13092: LD_EXP 17
13096: PPUSH
13097: LD_STRING DArtefTechnologyAr-JMM-1
13099: PPUSH
13100: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13104: LD_VAR 0 1
13108: PUSH
13109: LD_INT 1
13111: ARRAY
13112: PPUSH
13113: LD_STRING DArtefTechnologyAr-RSci1-2
13115: PPUSH
13116: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13120: LD_EXP 17
13124: PPUSH
13125: LD_STRING DArtefTechnologyAr-JMM-2
13127: PPUSH
13128: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13132: LD_VAR 0 1
13136: PUSH
13137: LD_INT 1
13139: ARRAY
13140: PPUSH
13141: LD_STRING DArtefTechnologyAr-RSci1-3
13143: PPUSH
13144: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13148: LD_EXP 17
13152: PPUSH
13153: LD_STRING DArtefTechnologyAr-JMM-3
13155: PPUSH
13156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13160: LD_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: ARRAY
13168: PPUSH
13169: LD_STRING DArtefTechnologyAr-RSci1-4
13171: PPUSH
13172: CALL_OW 88
// if IsOk ( Burlak ) then
13176: LD_EXP 49
13180: PPUSH
13181: CALL_OW 302
13185: IFFALSE 13199
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13187: LD_EXP 49
13191: PPUSH
13192: LD_STRING DArtefTechnologyAr-Bur-4
13194: PPUSH
13195: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13199: LD_EXP 17
13203: PPUSH
13204: LD_STRING DArtefTechnologyAr-JMM-4
13206: PPUSH
13207: CALL_OW 88
// DialogueOff ;
13211: CALL_OW 7
// wait ( 0 0$45 ) ;
13215: LD_INT 1575
13217: PPUSH
13218: CALL_OW 67
// spawnOmar := true ;
13222: LD_ADDR_EXP 11
13226: PUSH
13227: LD_INT 1
13229: ST_TO_ADDR
// end ;
13230: PPOPN 1
13232: END
// every 0 0$1 trigger spawnOmar do
13233: LD_EXP 11
13237: IFFALSE 13617
13239: GO 13241
13241: DISABLE
// begin PrepareOmarAli ;
13242: CALL 6751 0 0
// if not HasTask ( Omar ) then
13246: LD_EXP 53
13250: PPUSH
13251: CALL_OW 314
13255: NOT
13256: IFFALSE 13273
// ComMoveXY ( Omar , 252 , 220 ) ;
13258: LD_EXP 53
13262: PPUSH
13263: LD_INT 252
13265: PPUSH
13266: LD_INT 220
13268: PPUSH
13269: CALL_OW 111
// if not Omar then
13273: LD_EXP 53
13277: NOT
13278: IFFALSE 13282
// exit ;
13280: GO 13617
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13289: LD_EXP 53
13293: PPUSH
13294: CALL_OW 314
13298: NOT
13299: PUSH
13300: LD_EXP 53
13304: PPUSH
13305: LD_INT 252
13307: PPUSH
13308: LD_INT 220
13310: PPUSH
13311: CALL_OW 297
13315: PUSH
13316: LD_INT 6
13318: GREATER
13319: AND
13320: IFFALSE 13337
// ComMoveXY ( Omar , 252 , 220 ) ;
13322: LD_EXP 53
13326: PPUSH
13327: LD_INT 252
13329: PPUSH
13330: LD_INT 220
13332: PPUSH
13333: CALL_OW 111
// until See ( 7 , Omar ) ;
13337: LD_INT 7
13339: PPUSH
13340: LD_EXP 53
13344: PPUSH
13345: CALL_OW 292
13349: IFFALSE 13282
// CenterNowOnUnits ( Omar ) ;
13351: LD_EXP 53
13355: PPUSH
13356: CALL_OW 87
// DialogueOn ;
13360: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13364: LD_EXP 53
13368: PPUSH
13369: LD_STRING DOmar-Omar-1
13371: PPUSH
13372: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13376: LD_EXP 17
13380: PPUSH
13381: LD_STRING DOmar-JMM-1
13383: PPUSH
13384: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13388: LD_EXP 53
13392: PPUSH
13393: LD_STRING DOmar-Omar-2
13395: PPUSH
13396: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13400: LD_EXP 17
13404: PPUSH
13405: LD_STRING DOmar-JMM-2
13407: PPUSH
13408: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13412: LD_EXP 53
13416: PPUSH
13417: LD_STRING DOmar-Omar-3
13419: PPUSH
13420: CALL_OW 88
// if IsOk ( Burlak ) then
13424: LD_EXP 49
13428: PPUSH
13429: CALL_OW 302
13433: IFFALSE 13449
// Say ( Burlak , DOmar-Bur-3 ) else
13435: LD_EXP 49
13439: PPUSH
13440: LD_STRING DOmar-Bur-3
13442: PPUSH
13443: CALL_OW 88
13447: GO 13461
// Say ( JMM , DOmar-JMM-3 ) ;
13449: LD_EXP 17
13453: PPUSH
13454: LD_STRING DOmar-JMM-3
13456: PPUSH
13457: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13461: LD_EXP 53
13465: PPUSH
13466: LD_STRING DOmar-Omar-4
13468: PPUSH
13469: CALL_OW 88
// case Query ( QAccept ) of 1 :
13473: LD_STRING QAccept
13475: PPUSH
13476: CALL_OW 97
13480: PUSH
13481: LD_INT 1
13483: DOUBLE
13484: EQUAL
13485: IFTRUE 13489
13487: GO 13525
13489: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13490: LD_EXP 17
13494: PPUSH
13495: LD_STRING DQrAccept#1-JMM-1
13497: PPUSH
13498: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13502: LD_EXP 53
13506: PPUSH
13507: LD_INT 7
13509: PPUSH
13510: CALL_OW 235
// ComStop ( Omar ) ;
13514: LD_EXP 53
13518: PPUSH
13519: CALL_OW 141
// end ; 2 :
13523: GO 13574
13525: LD_INT 2
13527: DOUBLE
13528: EQUAL
13529: IFTRUE 13533
13531: GO 13573
13533: POP
// begin if IsOk ( Burlak ) then
13534: LD_EXP 49
13538: PPUSH
13539: CALL_OW 302
13543: IFFALSE 13559
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13545: LD_EXP 49
13549: PPUSH
13550: LD_STRING DQrAccept#2-Bur-1
13552: PPUSH
13553: CALL_OW 88
13557: GO 13571
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13559: LD_EXP 17
13563: PPUSH
13564: LD_STRING DQrAccept#2-JMM-1
13566: PPUSH
13567: CALL_OW 88
// end ; end ;
13571: GO 13574
13573: POP
// DialogueOff ;
13574: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13578: LD_EXP 53
13582: PPUSH
13583: CALL_OW 255
13587: PUSH
13588: LD_INT 7
13590: EQUAL
13591: IFFALSE 13602
// begin SetAchievement ( ACH_OMAR ) ;
13593: LD_STRING ACH_OMAR
13595: PPUSH
13596: CALL_OW 543
// exit ;
13600: GO 13617
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13602: LD_EXP 53
13606: PPUSH
13607: LD_INT 202
13609: PPUSH
13610: LD_INT 115
13612: PPUSH
13613: CALL_OW 111
// end ;
13617: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13618: LD_EXP 53
13622: PPUSH
13623: LD_INT 200
13625: PPUSH
13626: LD_INT 98
13628: PPUSH
13629: CALL_OW 297
13633: PUSH
13634: LD_INT 40
13636: LESS
13637: PUSH
13638: LD_EXP 2
13642: AND
13643: IFFALSE 13861
13645: GO 13647
13647: DISABLE
// begin SetSide ( Omar , 5 ) ;
13648: LD_EXP 53
13652: PPUSH
13653: LD_INT 5
13655: PPUSH
13656: CALL_OW 235
// if IsInUnit ( Omar ) then
13660: LD_EXP 53
13664: PPUSH
13665: CALL_OW 310
13669: IFFALSE 13680
// ComExitVehicle ( Omar ) ;
13671: LD_EXP 53
13675: PPUSH
13676: CALL_OW 121
// if IsInUnit ( Omar ) then
13680: LD_EXP 53
13684: PPUSH
13685: CALL_OW 310
13689: IFFALSE 13700
// ComExitBuilding ( Omar ) ;
13691: LD_EXP 53
13695: PPUSH
13696: CALL_OW 122
// wait ( 0 0$1 ) ;
13700: LD_INT 35
13702: PPUSH
13703: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13707: LD_EXP 53
13711: PPUSH
13712: LD_INT 203
13714: PPUSH
13715: LD_INT 120
13717: PPUSH
13718: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13722: LD_INT 35
13724: PPUSH
13725: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13729: LD_EXP 53
13733: PPUSH
13734: CALL_OW 306
13738: PUSH
13739: LD_EXP 53
13743: PPUSH
13744: LD_INT 203
13746: PPUSH
13747: LD_INT 120
13749: PPUSH
13750: CALL_OW 297
13754: PUSH
13755: LD_INT 6
13757: LESS
13758: OR
13759: IFFALSE 13722
// CenterNowOnUnits ( Omar ) ;
13761: LD_EXP 53
13765: PPUSH
13766: CALL_OW 87
// DialogueOn ;
13770: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13774: LD_EXP 17
13778: PPUSH
13779: LD_STRING DOmarContam-JMM-1
13781: PPUSH
13782: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13786: LD_EXP 53
13790: PPUSH
13791: LD_STRING DOmarContam-Omar-1
13793: PPUSH
13794: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13798: LD_EXP 17
13802: PPUSH
13803: LD_STRING DOmarContam-JMM-2
13805: PPUSH
13806: CALL_OW 88
// DialogueOff ;
13810: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13814: LD_INT 5
13816: PPUSH
13817: LD_INT 7
13819: PPUSH
13820: LD_INT 2
13822: PPUSH
13823: LD_INT 1
13825: PPUSH
13826: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13830: LD_INT 105
13832: PPUSH
13833: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13837: LD_EXP 53
13841: PPUSH
13842: LD_INT 203
13844: PPUSH
13845: LD_INT 120
13847: PPUSH
13848: CALL_OW 307
13852: IFFALSE 13830
// YouLost ( MothContaminate ) ;
13854: LD_STRING MothContaminate
13856: PPUSH
13857: CALL_OW 104
// end ;
13861: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13862: LD_EXP 4
13866: NOT
13867: PUSH
13868: LD_INT 22
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: LD_INT 34
13880: PUSH
13881: LD_INT 8
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PPUSH
13892: CALL_OW 69
13896: AND
13897: IFFALSE 14016
13899: GO 13901
13901: DISABLE
// begin wait ( 0 0$5 ) ;
13902: LD_INT 175
13904: PPUSH
13905: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13909: LD_EXP 52
13913: PPUSH
13914: CALL_OW 302
13918: NOT
13919: PUSH
13920: LD_INT 22
13922: PUSH
13923: LD_INT 1
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: PUSH
13930: LD_INT 34
13932: PUSH
13933: LD_INT 8
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PPUSH
13944: CALL_OW 69
13948: NOT
13949: OR
13950: IFFALSE 13954
// exit ;
13952: GO 14016
// DialogueOn ;
13954: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13958: LD_EXP 52
13962: PPUSH
13963: LD_STRING DWinAmericans-Pow-1
13965: PPUSH
13966: CALL_OW 94
// if IsOk ( Burlak ) then
13970: LD_EXP 49
13974: PPUSH
13975: CALL_OW 302
13979: IFFALSE 13993
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13981: LD_EXP 49
13985: PPUSH
13986: LD_STRING DWinAmericans-Bur-1
13988: PPUSH
13989: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13993: LD_EXP 17
13997: PPUSH
13998: LD_STRING DWinAmericans-JMM-1
14000: PPUSH
14001: CALL_OW 88
// DialogueOff ;
14005: CALL_OW 7
// YouLost ( AmBomb ) ;
14009: LD_STRING AmBomb
14011: PPUSH
14012: CALL_OW 104
// end ;
14016: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14017: LD_EXP 2
14021: NOT
14022: PUSH
14023: LD_INT 22
14025: PUSH
14026: LD_INT 3
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: PUSH
14033: LD_INT 34
14035: PUSH
14036: LD_INT 48
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PPUSH
14047: CALL_OW 69
14051: AND
14052: IFFALSE 14171
14054: GO 14056
14056: DISABLE
// begin wait ( 0 0$5 ) ;
14057: LD_INT 175
14059: PPUSH
14060: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14064: LD_EXP 56
14068: PPUSH
14069: CALL_OW 302
14073: NOT
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 48
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PPUSH
14099: CALL_OW 69
14103: NOT
14104: OR
14105: IFFALSE 14109
// exit ;
14107: GO 14171
// DialogueOn ;
14109: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14113: LD_EXP 56
14117: PPUSH
14118: LD_STRING DWinRussians-Pla-1
14120: PPUSH
14121: CALL_OW 94
// if IsOk ( Burlak ) then
14125: LD_EXP 49
14129: PPUSH
14130: CALL_OW 302
14134: IFFALSE 14148
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14136: LD_EXP 49
14140: PPUSH
14141: LD_STRING DWinRussians-Bur-1
14143: PPUSH
14144: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14148: LD_EXP 17
14152: PPUSH
14153: LD_STRING DWinRussians-JMM-1
14155: PPUSH
14156: CALL_OW 88
// DialogueOff ;
14160: CALL_OW 7
// YouLost ( RuBomb ) ;
14164: LD_STRING RuBomb
14166: PPUSH
14167: CALL_OW 104
// end ;
14171: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14172: LD_INT 7
14174: PPUSH
14175: LD_INT 22
14177: PUSH
14178: LD_INT 7
14180: PUSH
14181: EMPTY
14182: LIST
14183: LIST
14184: PPUSH
14185: CALL_OW 70
14189: PUSH
14190: LD_EXP 4
14194: NOT
14195: AND
14196: IFFALSE 14225
14198: GO 14200
14200: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14201: LD_EXP 52
14205: PPUSH
14206: LD_STRING DSurrenderAmericans-Pow-1
14208: PPUSH
14209: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14213: LD_EXP 17
14217: PPUSH
14218: LD_STRING DSurrenderAmericans-JMM-1
14220: PPUSH
14221: CALL_OW 88
// end ;
14225: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14226: LD_INT 2
14228: PPUSH
14229: LD_INT 22
14231: PUSH
14232: LD_INT 7
14234: PUSH
14235: EMPTY
14236: LIST
14237: LIST
14238: PPUSH
14239: CALL_OW 70
14243: PUSH
14244: LD_EXP 2
14248: NOT
14249: AND
14250: PUSH
14251: LD_EXP 49
14255: AND
14256: IFFALSE 14285
14258: GO 14260
14260: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14261: LD_EXP 56
14265: PPUSH
14266: LD_STRING DSurrenderRussians-Pla-1
14268: PPUSH
14269: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14273: LD_EXP 49
14277: PPUSH
14278: LD_STRING DSurrenderRussians-Bur-1
14280: PPUSH
14281: CALL_OW 88
// end ;
14285: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14286: LD_EXP 4
14290: IFFALSE 14673
14292: GO 14294
14294: DISABLE
14295: LD_INT 0
14297: PPUSH
14298: PPUSH
14299: PPUSH
// begin MC_Kill ( 4 ) ;
14300: LD_INT 4
14302: PPUSH
14303: CALL 21013 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14307: LD_INT 1
14309: PPUSH
14310: LD_INT 7
14312: PPUSH
14313: LD_INT 1
14315: PPUSH
14316: LD_INT 1
14318: PPUSH
14319: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14323: LD_ADDR_VAR 0 3
14327: PUSH
14328: LD_INT 22
14330: PUSH
14331: LD_INT 1
14333: PUSH
14334: EMPTY
14335: LIST
14336: LIST
14337: PUSH
14338: LD_INT 26
14340: PUSH
14341: LD_INT 1
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: LD_INT 23
14350: PUSH
14351: LD_INT 1
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: PPUSH
14363: CALL_OW 69
14367: PUSH
14368: LD_EXP 52
14372: PUSH
14373: LD_EXP 25
14377: PUSH
14378: LD_EXP 22
14382: PUSH
14383: LD_EXP 21
14387: PUSH
14388: LD_EXP 28
14392: PUSH
14393: LD_EXP 26
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: DIFF
14406: ST_TO_ADDR
// if speaker then
14407: LD_VAR 0 3
14411: IFFALSE 14437
// begin DialogueOn ;
14413: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14417: LD_VAR 0 3
14421: PUSH
14422: LD_INT 1
14424: ARRAY
14425: PPUSH
14426: LD_STRING DSurrenderAmericans-Sol1-1a
14428: PPUSH
14429: CALL_OW 94
// DialogueOff ;
14433: CALL_OW 7
// end ; americanCapitulated := true ;
14437: LD_ADDR_EXP 6
14441: PUSH
14442: LD_INT 1
14444: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 1
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 21
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: PUSH
14479: LD_INT 22
14481: PUSH
14482: LD_INT 1
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 21
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: EMPTY
14503: LIST
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: ADD
14515: ST_TO_ADDR
// if tmp then
14516: LD_VAR 0 2
14520: IFFALSE 14673
// repeat wait ( 0 0$1 ) ;
14522: LD_INT 35
14524: PPUSH
14525: CALL_OW 67
// for i in tmp do
14529: LD_ADDR_VAR 0 1
14533: PUSH
14534: LD_VAR 0 2
14538: PUSH
14539: FOR_IN
14540: IFFALSE 14622
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14542: LD_VAR 0 1
14546: PPUSH
14547: CALL_OW 310
14551: PUSH
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 310
14561: PPUSH
14562: CALL_OW 247
14566: PUSH
14567: LD_INT 3
14569: EQUAL
14570: AND
14571: IFFALSE 14582
// ComExitBuilding ( i ) ;
14573: LD_VAR 0 1
14577: PPUSH
14578: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_INT 122
14589: PPUSH
14590: LD_INT 242
14592: PPUSH
14593: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_INT 35
14604: PPUSH
14605: CALL_OW 308
14609: IFFALSE 14620
// RemoveUnit ( i ) ;
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 64
// end ;
14620: GO 14539
14622: POP
14623: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 33
14649: PUSH
14650: LD_INT 1
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: NOT
14671: IFFALSE 14522
// end ;
14673: PPOPN 3
14675: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14676: LD_EXP 2
14680: IFFALSE 15081
14682: GO 14684
14684: DISABLE
14685: LD_INT 0
14687: PPUSH
14688: PPUSH
14689: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14690: LD_INT 35
14692: PPUSH
14693: CALL_OW 67
// until IsDead ( Yakotich ) ;
14697: LD_EXP 57
14701: PPUSH
14702: CALL_OW 301
14706: IFFALSE 14690
// MC_Kill ( 2 ) ;
14708: LD_INT 2
14710: PPUSH
14711: CALL 21013 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14715: LD_INT 3
14717: PPUSH
14718: LD_INT 7
14720: PPUSH
14721: LD_INT 1
14723: PPUSH
14724: LD_INT 1
14726: PPUSH
14727: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14731: LD_ADDR_VAR 0 3
14735: PUSH
14736: LD_INT 22
14738: PUSH
14739: LD_INT 3
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 26
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: LD_INT 23
14758: PUSH
14759: LD_INT 3
14761: PUSH
14762: EMPTY
14763: LIST
14764: LIST
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 69
14775: PUSH
14776: LD_EXP 56
14780: PUSH
14781: LD_EXP 57
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: DIFF
14790: ST_TO_ADDR
// if speaker then
14791: LD_VAR 0 3
14795: IFFALSE 14845
// begin DialogueOn ;
14797: CALL_OW 6
// if Burlak then
14801: LD_EXP 49
14805: IFFALSE 14825
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14807: LD_VAR 0 3
14811: PUSH
14812: LD_INT 1
14814: ARRAY
14815: PPUSH
14816: LD_STRING DSurrenderRussians-RSol1-1
14818: PPUSH
14819: CALL_OW 94
14823: GO 14841
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 1
14832: ARRAY
14833: PPUSH
14834: LD_STRING DSurrenderRussians-RSol1-1a
14836: PPUSH
14837: CALL_OW 94
// DialogueOff ;
14841: CALL_OW 7
// end ; russianCapitulated := true ;
14845: LD_ADDR_EXP 7
14849: PUSH
14850: LD_INT 1
14852: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14853: LD_ADDR_VAR 0 2
14857: PUSH
14858: LD_INT 22
14860: PUSH
14861: LD_INT 3
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: LD_INT 21
14870: PUSH
14871: LD_INT 1
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: PPUSH
14882: CALL_OW 69
14886: PUSH
14887: LD_INT 22
14889: PUSH
14890: LD_INT 3
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: PUSH
14897: LD_INT 21
14899: PUSH
14900: LD_INT 2
14902: PUSH
14903: EMPTY
14904: LIST
14905: LIST
14906: PUSH
14907: LD_INT 1
14909: PUSH
14910: EMPTY
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: LIST
14917: PPUSH
14918: CALL_OW 69
14922: ADD
14923: ST_TO_ADDR
// if tmp then
14924: LD_VAR 0 2
14928: IFFALSE 15081
// repeat wait ( 0 0$1 ) ;
14930: LD_INT 35
14932: PPUSH
14933: CALL_OW 67
// for i in tmp do
14937: LD_ADDR_VAR 0 1
14941: PUSH
14942: LD_VAR 0 2
14946: PUSH
14947: FOR_IN
14948: IFFALSE 15030
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14950: LD_VAR 0 1
14954: PPUSH
14955: CALL_OW 310
14959: PUSH
14960: LD_VAR 0 1
14964: PPUSH
14965: CALL_OW 310
14969: PPUSH
14970: CALL_OW 247
14974: PUSH
14975: LD_INT 3
14977: EQUAL
14978: AND
14979: IFFALSE 14990
// ComExitBuilding ( i ) ;
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14990: LD_VAR 0 1
14994: PPUSH
14995: LD_INT 154
14997: PPUSH
14998: LD_INT 1
15000: PPUSH
15001: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_INT 36
15012: PPUSH
15013: CALL_OW 308
15017: IFFALSE 15028
// RemoveUnit ( i ) ;
15019: LD_VAR 0 1
15023: PPUSH
15024: CALL_OW 64
// end ;
15028: GO 14947
15030: POP
15031: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15032: LD_INT 22
15034: PUSH
15035: LD_INT 3
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: LD_INT 21
15047: PUSH
15048: LD_INT 1
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: PUSH
15055: LD_INT 33
15057: PUSH
15058: LD_INT 1
15060: PUSH
15061: EMPTY
15062: LIST
15063: LIST
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PPUSH
15074: CALL_OW 69
15078: NOT
15079: IFFALSE 14930
// end ;
15081: PPOPN 3
15083: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15084: LD_INT 22
15086: PUSH
15087: LD_INT 8
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: PUSH
15094: LD_INT 21
15096: PUSH
15097: LD_INT 1
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: PUSH
15104: LD_INT 23
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: LIST
15118: PPUSH
15119: CALL_OW 69
15123: PUSH
15124: LD_INT 18
15126: LESS
15127: PUSH
15128: LD_EXP 55
15132: PPUSH
15133: CALL_OW 301
15137: OR
15138: PUSH
15139: LD_INT 324
15141: PPUSH
15142: CALL_OW 255
15146: PUSH
15147: LD_INT 7
15149: EQUAL
15150: OR
15151: IFFALSE 15164
15153: GO 15155
15155: DISABLE
// legionDestroyed := true ;
15156: LD_ADDR_EXP 3
15160: PUSH
15161: LD_INT 1
15163: ST_TO_ADDR
15164: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15165: LD_INT 22
15167: PUSH
15168: LD_INT 2
15170: PUSH
15171: EMPTY
15172: LIST
15173: LIST
15174: PUSH
15175: LD_INT 21
15177: PUSH
15178: LD_INT 1
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PUSH
15185: LD_INT 23
15187: PUSH
15188: LD_INT 2
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PUSH
15195: EMPTY
15196: LIST
15197: LIST
15198: LIST
15199: PPUSH
15200: CALL_OW 69
15204: PUSH
15205: LD_INT 9
15207: LESS
15208: IFFALSE 15221
15210: GO 15212
15212: DISABLE
// arabianDestroyed := true ;
15213: LD_ADDR_EXP 5
15217: PUSH
15218: LD_INT 1
15220: ST_TO_ADDR
15221: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15222: LD_EXP 5
15226: IFFALSE 15470
15228: GO 15230
15230: DISABLE
15231: LD_INT 0
15233: PPUSH
15234: PPUSH
// begin MC_Kill ( 1 ) ;
15235: LD_INT 1
15237: PPUSH
15238: CALL 21013 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15242: LD_ADDR_VAR 0 2
15246: PUSH
15247: LD_INT 22
15249: PUSH
15250: LD_INT 2
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: PUSH
15257: LD_INT 21
15259: PUSH
15260: LD_INT 1
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 69
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 8
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 21
15288: PUSH
15289: LD_INT 2
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 1
15298: PUSH
15299: EMPTY
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: LIST
15306: PPUSH
15307: CALL_OW 69
15311: ADD
15312: ST_TO_ADDR
// if tmp then
15313: LD_VAR 0 2
15317: IFFALSE 15470
// repeat wait ( 0 0$1 ) ;
15319: LD_INT 35
15321: PPUSH
15322: CALL_OW 67
// for i in tmp do
15326: LD_ADDR_VAR 0 1
15330: PUSH
15331: LD_VAR 0 2
15335: PUSH
15336: FOR_IN
15337: IFFALSE 15419
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15339: LD_VAR 0 1
15343: PPUSH
15344: CALL_OW 310
15348: PUSH
15349: LD_VAR 0 1
15353: PPUSH
15354: CALL_OW 310
15358: PPUSH
15359: CALL_OW 247
15363: PUSH
15364: LD_INT 3
15366: EQUAL
15367: AND
15368: IFFALSE 15379
// ComExitBuilding ( i ) ;
15370: LD_VAR 0 1
15374: PPUSH
15375: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15379: LD_VAR 0 1
15383: PPUSH
15384: LD_INT 254
15386: PPUSH
15387: LD_INT 268
15389: PPUSH
15390: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15394: LD_VAR 0 1
15398: PPUSH
15399: LD_INT 34
15401: PPUSH
15402: CALL_OW 308
15406: IFFALSE 15417
// RemoveUnit ( i ) ;
15408: LD_VAR 0 1
15412: PPUSH
15413: CALL_OW 64
// end ;
15417: GO 15336
15419: POP
15420: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15421: LD_INT 22
15423: PUSH
15424: LD_INT 2
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PUSH
15431: LD_INT 2
15433: PUSH
15434: LD_INT 21
15436: PUSH
15437: LD_INT 1
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: LD_INT 33
15446: PUSH
15447: LD_INT 1
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PUSH
15454: EMPTY
15455: LIST
15456: LIST
15457: LIST
15458: PUSH
15459: EMPTY
15460: LIST
15461: LIST
15462: PPUSH
15463: CALL_OW 69
15467: NOT
15468: IFFALSE 15319
// end ;
15470: PPOPN 2
15472: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15473: LD_EXP 3
15477: IFFALSE 15829
15479: GO 15481
15481: DISABLE
15482: LD_INT 0
15484: PPUSH
15485: PPUSH
// begin MC_Kill ( 3 ) ;
15486: LD_INT 3
15488: PPUSH
15489: CALL 21013 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15493: LD_INT 8
15495: PPUSH
15496: LD_INT 7
15498: PPUSH
15499: LD_INT 1
15501: PPUSH
15502: LD_INT 1
15504: PPUSH
15505: CALL_OW 80
// DialogueOn ;
15509: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15513: LD_EXP 54
15517: PPUSH
15518: LD_STRING D15-Szulc-1
15520: PPUSH
15521: CALL_OW 94
// DialogueOff ;
15525: CALL_OW 7
// legionCapitulated := true ;
15529: LD_ADDR_EXP 8
15533: PUSH
15534: LD_INT 1
15536: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15537: LD_ADDR_VAR 0 1
15541: PUSH
15542: LD_INT 22
15544: PUSH
15545: LD_INT 8
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: PUSH
15552: LD_INT 21
15554: PUSH
15555: LD_INT 3
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 23
15564: PUSH
15565: LD_INT 3
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: LIST
15576: PPUSH
15577: CALL_OW 69
15581: PUSH
15582: FOR_IN
15583: IFFALSE 15599
// SetLives ( i , 3 ) ;
15585: LD_VAR 0 1
15589: PPUSH
15590: LD_INT 3
15592: PPUSH
15593: CALL_OW 234
15597: GO 15582
15599: POP
15600: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15601: LD_ADDR_VAR 0 2
15605: PUSH
15606: LD_INT 22
15608: PUSH
15609: LD_INT 8
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: PUSH
15616: LD_INT 21
15618: PUSH
15619: LD_INT 1
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: PPUSH
15630: CALL_OW 69
15634: PUSH
15635: LD_INT 22
15637: PUSH
15638: LD_INT 8
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: LD_INT 21
15647: PUSH
15648: LD_INT 2
15650: PUSH
15651: EMPTY
15652: LIST
15653: LIST
15654: PUSH
15655: LD_INT 1
15657: PUSH
15658: EMPTY
15659: LIST
15660: PUSH
15661: EMPTY
15662: LIST
15663: LIST
15664: LIST
15665: PPUSH
15666: CALL_OW 69
15670: ADD
15671: ST_TO_ADDR
// if tmp then
15672: LD_VAR 0 2
15676: IFFALSE 15829
// repeat wait ( 0 0$1 ) ;
15678: LD_INT 35
15680: PPUSH
15681: CALL_OW 67
// for i in tmp do
15685: LD_ADDR_VAR 0 1
15689: PUSH
15690: LD_VAR 0 2
15694: PUSH
15695: FOR_IN
15696: IFFALSE 15778
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15698: LD_VAR 0 1
15702: PPUSH
15703: CALL_OW 310
15707: PUSH
15708: LD_VAR 0 1
15712: PPUSH
15713: CALL_OW 310
15717: PPUSH
15718: CALL_OW 247
15722: PUSH
15723: LD_INT 3
15725: EQUAL
15726: AND
15727: IFFALSE 15738
// ComExitBuilding ( i ) ;
15729: LD_VAR 0 1
15733: PPUSH
15734: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15738: LD_VAR 0 1
15742: PPUSH
15743: LD_INT 10
15745: PPUSH
15746: LD_INT 1
15748: PPUSH
15749: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15753: LD_VAR 0 1
15757: PPUSH
15758: LD_INT 32
15760: PPUSH
15761: CALL_OW 308
15765: IFFALSE 15776
// RemoveUnit ( i ) ;
15767: LD_VAR 0 1
15771: PPUSH
15772: CALL_OW 64
// end ;
15776: GO 15695
15778: POP
15779: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15780: LD_INT 22
15782: PUSH
15783: LD_INT 8
15785: PUSH
15786: EMPTY
15787: LIST
15788: LIST
15789: PUSH
15790: LD_INT 2
15792: PUSH
15793: LD_INT 21
15795: PUSH
15796: LD_INT 1
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PUSH
15803: LD_INT 33
15805: PUSH
15806: LD_INT 1
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: LIST
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PPUSH
15822: CALL_OW 69
15826: NOT
15827: IFFALSE 15678
// end ;
15829: PPOPN 2
15831: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15832: LD_EXP 4
15836: PUSH
15837: LD_EXP 2
15841: AND
15842: PUSH
15843: LD_EXP 3
15847: AND
15848: PUSH
15849: LD_EXP 5
15853: AND
15854: PUSH
15855: LD_EXP 6
15859: AND
15860: PUSH
15861: LD_EXP 7
15865: AND
15866: PUSH
15867: LD_EXP 8
15871: AND
15872: PUSH
15873: LD_EXP 53
15877: PPUSH
15878: CALL_OW 255
15882: PUSH
15883: LD_INT 5
15885: NONEQUAL
15886: PUSH
15887: LD_EXP 53
15891: PPUSH
15892: CALL_OW 301
15896: OR
15897: PUSH
15898: LD_EXP 53
15902: PPUSH
15903: CALL_OW 305
15907: NOT
15908: OR
15909: AND
15910: IFFALSE 17301
15912: GO 15914
15914: DISABLE
15915: LD_INT 0
15917: PPUSH
15918: PPUSH
// begin wait ( 0 0$5 ) ;
15919: LD_INT 175
15921: PPUSH
15922: CALL_OW 67
// music_class := 5 ;
15926: LD_ADDR_OWVAR 72
15930: PUSH
15931: LD_INT 5
15933: ST_TO_ADDR
// music_nat := 5 ;
15934: LD_ADDR_OWVAR 71
15938: PUSH
15939: LD_INT 5
15941: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15942: LD_EXP 15
15946: PUSH
15947: LD_INT 3
15949: LESS
15950: IFFALSE 15959
// SetAchievement ( ACH_ECONOMY ) ;
15952: LD_STRING ACH_ECONOMY
15954: PPUSH
15955: CALL_OW 543
// if tick < 60 60$00 then
15959: LD_OWVAR 1
15963: PUSH
15964: LD_INT 126000
15966: LESS
15967: IFFALSE 15983
// begin wait ( 3 ) ;
15969: LD_INT 3
15971: PPUSH
15972: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15976: LD_STRING ACH_ASPEED_19
15978: PPUSH
15979: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15983: LD_EXP 17
15987: PPUSH
15988: CALL_OW 87
// InGameOn ;
15992: CALL_OW 8
// DialogueOn ;
15996: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16000: LD_EXP 17
16004: PPUSH
16005: LD_STRING DEnd-JMM-JMM-1
16007: PPUSH
16008: CALL_OW 88
// if Joan then
16012: LD_EXP 32
16016: IFFALSE 16032
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16018: LD_EXP 32
16022: PPUSH
16023: LD_STRING DEnd-JMM-Joan-1
16025: PPUSH
16026: CALL_OW 88
16030: GO 16076
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16032: LD_EXP 19
16036: PUSH
16037: LD_EXP 19
16041: PPUSH
16042: CALL_OW 255
16046: PUSH
16047: LD_INT 7
16049: EQUAL
16050: AND
16051: PUSH
16052: LD_EXP 19
16056: PPUSH
16057: CALL_OW 305
16061: AND
16062: IFFALSE 16076
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16064: LD_EXP 19
16068: PPUSH
16069: LD_STRING DEnd-JMM-Lisa-1
16071: PPUSH
16072: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16076: LD_EXP 29
16080: PUSH
16081: LD_EXP 29
16085: PPUSH
16086: CALL_OW 305
16090: AND
16091: IFFALSE 16105
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16093: LD_EXP 29
16097: PPUSH
16098: LD_STRING DEnd-JMM-Frank-1
16100: PPUSH
16101: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16105: LD_EXP 22
16109: PUSH
16110: LD_EXP 22
16114: PPUSH
16115: CALL_OW 255
16119: PUSH
16120: LD_INT 7
16122: EQUAL
16123: AND
16124: PUSH
16125: LD_EXP 22
16129: PPUSH
16130: CALL_OW 305
16134: AND
16135: IFFALSE 16149
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16137: LD_EXP 22
16141: PPUSH
16142: LD_STRING DEnd-JMM-Cyrus-1
16144: PPUSH
16145: CALL_OW 88
// if Burlak then
16149: LD_EXP 49
16153: IFFALSE 16167
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16155: LD_EXP 49
16159: PPUSH
16160: LD_STRING DEnd-JMM-Bur-1
16162: PPUSH
16163: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16167: LD_EXP 32
16171: PUSH
16172: LD_EXP 19
16176: AND
16177: PUSH
16178: LD_EXP 19
16182: PPUSH
16183: CALL_OW 255
16187: PUSH
16188: LD_INT 7
16190: EQUAL
16191: AND
16192: PUSH
16193: LD_EXP 19
16197: PPUSH
16198: CALL_OW 305
16202: AND
16203: IFFALSE 16217
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16205: LD_EXP 19
16209: PPUSH
16210: LD_STRING DEnd-Burlak-Lisa-1
16212: PPUSH
16213: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16217: LD_EXP 50
16221: PUSH
16222: LD_EXP 50
16226: PPUSH
16227: CALL_OW 305
16231: AND
16232: IFFALSE 16246
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16234: LD_EXP 50
16238: PPUSH
16239: LD_STRING DEnd-JMM-Bel-1
16241: PPUSH
16242: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16246: LD_EXP 51
16250: PUSH
16251: LD_EXP 51
16255: PPUSH
16256: CALL_OW 305
16260: AND
16261: IFFALSE 16275
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16263: LD_EXP 51
16267: PPUSH
16268: LD_STRING DEnd-JMM-Gny-1
16270: PPUSH
16271: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16275: LD_EXP 27
16279: PUSH
16280: LD_EXP 27
16284: PPUSH
16285: CALL_OW 255
16289: PUSH
16290: LD_INT 7
16292: EQUAL
16293: AND
16294: PUSH
16295: LD_EXP 27
16299: PPUSH
16300: CALL_OW 305
16304: AND
16305: IFFALSE 16319
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16307: LD_EXP 27
16311: PPUSH
16312: LD_STRING DEnd-JMM-Corn-1
16314: PPUSH
16315: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16319: LD_EXP 20
16323: PUSH
16324: LD_EXP 20
16328: PPUSH
16329: CALL_OW 255
16333: PUSH
16334: LD_INT 7
16336: EQUAL
16337: AND
16338: PUSH
16339: LD_EXP 20
16343: PPUSH
16344: CALL_OW 305
16348: AND
16349: IFFALSE 16363
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16351: LD_EXP 20
16355: PPUSH
16356: LD_STRING DEnd-JMM-Don-1
16358: PPUSH
16359: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16363: LD_EXP 21
16367: PUSH
16368: LD_EXP 21
16372: PPUSH
16373: CALL_OW 255
16377: PUSH
16378: LD_INT 7
16380: EQUAL
16381: AND
16382: PUSH
16383: LD_EXP 21
16387: PPUSH
16388: CALL_OW 305
16392: AND
16393: IFFALSE 16407
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16395: LD_EXP 21
16399: PPUSH
16400: LD_STRING DEnd-JMM-Bobby-1
16402: PPUSH
16403: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16407: LD_EXP 23
16411: PUSH
16412: LD_EXP 23
16416: PPUSH
16417: CALL_OW 255
16421: PUSH
16422: LD_INT 7
16424: EQUAL
16425: AND
16426: PUSH
16427: LD_EXP 23
16431: PPUSH
16432: CALL_OW 305
16436: AND
16437: IFFALSE 16451
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16439: LD_EXP 23
16443: PPUSH
16444: LD_STRING DEnd-JMM-Den-1
16446: PPUSH
16447: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16451: LD_EXP 25
16455: PUSH
16456: LD_EXP 25
16460: PPUSH
16461: CALL_OW 255
16465: PUSH
16466: LD_INT 7
16468: EQUAL
16469: AND
16470: PUSH
16471: LD_EXP 25
16475: PPUSH
16476: CALL_OW 305
16480: AND
16481: IFFALSE 16495
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16483: LD_EXP 25
16487: PPUSH
16488: LD_STRING DEnd-JMM-Glad-1
16490: PPUSH
16491: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16495: LD_EXP 30
16499: PUSH
16500: LD_EXP 30
16504: PPUSH
16505: CALL_OW 255
16509: PUSH
16510: LD_INT 7
16512: EQUAL
16513: AND
16514: PUSH
16515: LD_EXP 30
16519: PPUSH
16520: CALL_OW 305
16524: AND
16525: IFFALSE 16539
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16527: LD_EXP 30
16531: PPUSH
16532: LD_STRING DEnd-JMM-Yam-1
16534: PPUSH
16535: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16539: LD_EXP 24
16543: PUSH
16544: LD_EXP 24
16548: PPUSH
16549: CALL_OW 255
16553: PUSH
16554: LD_INT 7
16556: EQUAL
16557: AND
16558: PUSH
16559: LD_EXP 24
16563: PPUSH
16564: CALL_OW 305
16568: AND
16569: IFFALSE 16583
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16571: LD_EXP 24
16575: PPUSH
16576: LD_STRING DEnd-JMM-Brown-1
16578: PPUSH
16579: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16583: LD_EXP 34
16587: PUSH
16588: LD_EXP 34
16592: PPUSH
16593: CALL_OW 255
16597: PUSH
16598: LD_INT 7
16600: EQUAL
16601: AND
16602: PUSH
16603: LD_EXP 34
16607: PPUSH
16608: CALL_OW 305
16612: AND
16613: IFFALSE 16627
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16615: LD_EXP 34
16619: PPUSH
16620: LD_STRING DEnd-JMM-Con-1
16622: PPUSH
16623: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16627: LD_EXP 28
16631: PUSH
16632: LD_EXP 28
16636: PPUSH
16637: CALL_OW 255
16641: PUSH
16642: LD_INT 7
16644: EQUAL
16645: AND
16646: PUSH
16647: LD_EXP 28
16651: PPUSH
16652: CALL_OW 305
16656: AND
16657: IFFALSE 16671
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16659: LD_EXP 28
16663: PPUSH
16664: LD_STRING DEnd-JMM-Gary-1
16666: PPUSH
16667: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16671: LD_EXP 31
16675: PUSH
16676: LD_EXP 18
16680: AND
16681: PUSH
16682: LD_EXP 31
16686: PPUSH
16687: CALL_OW 305
16691: AND
16692: IFFALSE 16706
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16694: LD_EXP 31
16698: PPUSH
16699: LD_STRING DEnd-JMM-Sim-1
16701: PPUSH
16702: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16706: LD_EXP 26
16710: PUSH
16711: LD_EXP 26
16715: PPUSH
16716: CALL_OW 255
16720: PUSH
16721: LD_INT 7
16723: EQUAL
16724: AND
16725: PUSH
16726: LD_EXP 26
16730: PPUSH
16731: CALL_OW 305
16735: AND
16736: IFFALSE 16750
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16738: LD_EXP 26
16742: PPUSH
16743: LD_STRING DEnd-JMM-VanH-1
16745: PPUSH
16746: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16750: LD_EXP 39
16754: PUSH
16755: LD_EXP 39
16759: PPUSH
16760: CALL_OW 305
16764: AND
16765: IFFALSE 16779
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16767: LD_EXP 39
16771: PPUSH
16772: LD_STRING DEnd-JMM-Dol-1
16774: PPUSH
16775: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16779: LD_EXP 43
16783: PUSH
16784: LD_EXP 43
16788: PPUSH
16789: CALL_OW 305
16793: AND
16794: IFFALSE 16808
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16796: LD_EXP 43
16800: PPUSH
16801: LD_STRING DEnd-JMM-Kap-1
16803: PPUSH
16804: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16808: LD_EXP 46
16812: PUSH
16813: LD_EXP 46
16817: PPUSH
16818: CALL_OW 305
16822: AND
16823: IFFALSE 16837
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16825: LD_EXP 46
16829: PPUSH
16830: LD_STRING DEnd-JMM-Kov-1
16832: PPUSH
16833: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16837: LD_EXP 41
16841: PUSH
16842: LD_EXP 41
16846: PPUSH
16847: CALL_OW 305
16851: AND
16852: IFFALSE 16866
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16854: LD_EXP 41
16858: PPUSH
16859: LD_STRING DEnd-JMM-Sch-1
16861: PPUSH
16862: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16866: LD_EXP 37
16870: PUSH
16871: LD_EXP 37
16875: PPUSH
16876: CALL_OW 305
16880: AND
16881: IFFALSE 16895
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16883: LD_EXP 37
16887: PPUSH
16888: LD_STRING DEnd-JMM-Tit-1
16890: PPUSH
16891: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16895: LD_EXP 42
16899: PUSH
16900: LD_EXP 42
16904: PPUSH
16905: CALL_OW 305
16909: AND
16910: IFFALSE 16924
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16912: LD_EXP 42
16916: PPUSH
16917: LD_STRING DEnd-JMM-Obl-1
16919: PPUSH
16920: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16924: LD_EXP 44
16928: PUSH
16929: LD_EXP 44
16933: PPUSH
16934: CALL_OW 305
16938: AND
16939: IFFALSE 16953
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16941: LD_EXP 44
16945: PPUSH
16946: LD_STRING DEnd-JMM-Lip-1
16948: PPUSH
16949: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16953: LD_EXP 38
16957: PUSH
16958: LD_EXP 38
16962: PPUSH
16963: CALL_OW 305
16967: AND
16968: PUSH
16969: LD_EXP 49
16973: AND
16974: IFFALSE 16988
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16976: LD_EXP 38
16980: PPUSH
16981: LD_STRING DEnd-Burlak-Fad-1
16983: PPUSH
16984: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16988: LD_EXP 45
16992: PUSH
16993: LD_EXP 45
16997: PPUSH
16998: CALL_OW 305
17002: AND
17003: IFFALSE 17017
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17005: LD_EXP 45
17009: PPUSH
17010: LD_STRING DEnd-Burlak-Ptr-1
17012: PPUSH
17013: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17017: LD_EXP 47
17021: PUSH
17022: LD_EXP 47
17026: PPUSH
17027: CALL_OW 305
17031: AND
17032: IFFALSE 17046
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17034: LD_EXP 47
17038: PPUSH
17039: LD_STRING DEnd-Burlak-Kuz-1
17041: PPUSH
17042: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17046: LD_EXP 36
17050: PUSH
17051: LD_EXP 36
17055: PPUSH
17056: CALL_OW 305
17060: AND
17061: PUSH
17062: LD_EXP 49
17066: AND
17067: IFFALSE 17081
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17069: LD_EXP 36
17073: PPUSH
17074: LD_STRING DEnd-Burlak-Kir-1
17076: PPUSH
17077: CALL_OW 88
// if Burlak then
17081: LD_EXP 49
17085: IFFALSE 17099
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17087: LD_EXP 17
17091: PPUSH
17092: LD_STRING DEnd-Burlak-JMM-1
17094: PPUSH
17095: CALL_OW 88
// dwait ( 0 0$2 ) ;
17099: LD_INT 70
17101: PPUSH
17102: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17106: LD_EXP 54
17110: PPUSH
17111: LD_STRING DEnd-Szulc
17113: PPUSH
17114: CALL_OW 94
// dwait ( 0 0$1 ) ;
17118: LD_INT 35
17120: PPUSH
17121: CALL_OW 68
// if IsLive ( Burlak ) then
17125: LD_EXP 49
17129: PPUSH
17130: CALL_OW 300
17134: IFFALSE 17146
// med1 := 1 else
17136: LD_ADDR_VAR 0 1
17140: PUSH
17141: LD_INT 1
17143: ST_TO_ADDR
17144: GO 17155
// med1 := - 1 ;
17146: LD_ADDR_VAR 0 1
17150: PUSH
17151: LD_INT 1
17153: NEG
17154: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17155: LD_EXP 12
17159: PUSH
17160: LD_EXP 13
17164: AND
17165: PUSH
17166: LD_EXP 14
17170: AND
17171: IFFALSE 17183
// med2 := 1 else
17173: LD_ADDR_VAR 0 2
17177: PUSH
17178: LD_INT 1
17180: ST_TO_ADDR
17181: GO 17192
// med2 := - 1 ;
17183: LD_ADDR_VAR 0 2
17187: PUSH
17188: LD_INT 1
17190: NEG
17191: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17192: LD_STRING Hero
17194: PPUSH
17195: LD_INT 1
17197: PPUSH
17198: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17202: LD_STRING Artefact
17204: PPUSH
17205: LD_VAR 0 2
17209: PPUSH
17210: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17214: LD_STRING ReconcileBurlak
17216: PPUSH
17217: LD_VAR 0 1
17221: PPUSH
17222: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17226: LD_OWVAR 67
17230: PUSH
17231: LD_INT 3
17233: EQUAL
17234: PUSH
17235: LD_VAR 0 1
17239: PUSH
17240: LD_INT 1
17242: EQUAL
17243: AND
17244: PUSH
17245: LD_VAR 0 2
17249: PUSH
17250: LD_INT 1
17252: EQUAL
17253: AND
17254: IFFALSE 17266
// SetAchievementEX ( ACH_AMER , 19 ) ;
17256: LD_STRING ACH_AMER
17258: PPUSH
17259: LD_INT 19
17261: PPUSH
17262: CALL_OW 564
// GiveMedals ( MAIN ) ;
17266: LD_STRING MAIN
17268: PPUSH
17269: CALL_OW 102
// InGameOff ;
17273: CALL_OW 9
// DialogueOff ;
17277: CALL_OW 7
// music_nat := 1 ;
17281: LD_ADDR_OWVAR 71
17285: PUSH
17286: LD_INT 1
17288: ST_TO_ADDR
// music_class := 4 ;
17289: LD_ADDR_OWVAR 72
17293: PUSH
17294: LD_INT 4
17296: ST_TO_ADDR
// YouWin ;
17297: CALL_OW 103
// end ; end_of_file
17301: PPOPN 2
17303: END
// export function InitNature ; begin
17304: LD_INT 0
17306: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17307: LD_INT 3
17309: PPUSH
17310: LD_INT 3
17312: PPUSH
17313: LD_INT 2
17315: PPUSH
17316: LD_INT 1
17318: PPUSH
17319: LD_INT 1
17321: PPUSH
17322: LD_INT 0
17324: PPUSH
17325: LD_INT 0
17327: PPUSH
17328: LD_INT 17
17330: PPUSH
17331: LD_INT 0
17333: PPUSH
17334: CALL 83837 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17338: LD_INT 2
17340: PPUSH
17341: LD_INT 1
17343: PPUSH
17344: LD_INT 1
17346: PPUSH
17347: LD_INT 1
17349: PPUSH
17350: LD_INT 1
17352: PPUSH
17353: LD_INT 0
17355: PPUSH
17356: LD_INT 0
17358: PPUSH
17359: LD_INT 18
17361: PPUSH
17362: LD_INT 0
17364: PPUSH
17365: CALL 83837 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17369: LD_INT 4
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: LD_INT 2
17377: PPUSH
17378: LD_INT 4
17380: PPUSH
17381: LD_INT 2
17383: PPUSH
17384: LD_INT 1
17386: PPUSH
17387: LD_INT 0
17389: PPUSH
17390: LD_INT 19
17392: PPUSH
17393: LD_INT 0
17395: PPUSH
17396: CALL 83837 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17400: LD_INT 0
17402: PPUSH
17403: LD_INT 0
17405: PPUSH
17406: LD_INT 0
17408: PPUSH
17409: LD_INT 0
17411: PPUSH
17412: LD_INT 0
17414: PPUSH
17415: LD_INT 0
17417: PPUSH
17418: LD_INT 9
17420: PPUSH
17421: LD_INT 0
17423: PPUSH
17424: LD_INT 20
17426: PPUSH
17427: CALL 83837 0 9
// end ; end_of_file
17431: LD_VAR 0 1
17435: RET
// every 0 0$30 do var time ;
17436: GO 17438
17438: DISABLE
17439: LD_INT 0
17441: PPUSH
// begin time := 0 0$50 ;
17442: LD_ADDR_VAR 0 1
17446: PUSH
17447: LD_INT 1750
17449: ST_TO_ADDR
// repeat wait ( time ) ;
17450: LD_VAR 0 1
17454: PPUSH
17455: CALL_OW 67
// if Prob ( 50 ) then
17459: LD_INT 50
17461: PPUSH
17462: CALL_OW 13
17466: IFFALSE 17495
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17468: LD_INT 1
17470: PPUSH
17471: LD_INT 5
17473: PPUSH
17474: CALL_OW 12
17478: PPUSH
17479: LD_INT 106
17481: PPUSH
17482: LD_INT 89
17484: PPUSH
17485: LD_INT 45
17487: PPUSH
17488: LD_INT 1
17490: PPUSH
17491: CALL_OW 56
// time := time + 0 0$3 ;
17495: LD_ADDR_VAR 0 1
17499: PUSH
17500: LD_VAR 0 1
17504: PUSH
17505: LD_INT 105
17507: PLUS
17508: ST_TO_ADDR
// if Prob ( 30 ) then
17509: LD_INT 30
17511: PPUSH
17512: CALL_OW 13
17516: IFFALSE 17562
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17518: LD_INT 525
17520: PPUSH
17521: LD_INT 735
17523: PPUSH
17524: CALL_OW 12
17528: PPUSH
17529: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17533: LD_INT 1
17535: PPUSH
17536: LD_INT 5
17538: PPUSH
17539: CALL_OW 12
17543: PPUSH
17544: LD_INT 21
17546: PPUSH
17547: LD_INT 26
17549: PPUSH
17550: LD_INT 12
17552: PPUSH
17553: LD_INT 1
17555: PPUSH
17556: CALL_OW 56
// end else
17560: GO 17598
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17562: LD_INT 700
17564: PPUSH
17565: LD_INT 1225
17567: PPUSH
17568: CALL_OW 12
17572: PPUSH
17573: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17577: LD_INT 1
17579: PPUSH
17580: LD_INT 5
17582: PPUSH
17583: CALL_OW 12
17587: PPUSH
17588: LD_INT 14
17590: PPUSH
17591: LD_INT 1
17593: PPUSH
17594: CALL_OW 55
// end ; if Prob ( 50 ) then
17598: LD_INT 50
17600: PPUSH
17601: CALL_OW 13
17605: IFFALSE 17651
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17607: LD_INT 700
17609: PPUSH
17610: LD_INT 1050
17612: PPUSH
17613: CALL_OW 12
17617: PPUSH
17618: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17622: LD_INT 1
17624: PPUSH
17625: LD_INT 5
17627: PPUSH
17628: CALL_OW 12
17632: PPUSH
17633: LD_INT 181
17635: PPUSH
17636: LD_INT 218
17638: PPUSH
17639: LD_INT 16
17641: PPUSH
17642: LD_INT 1
17644: PPUSH
17645: CALL_OW 56
// end else
17649: GO 17723
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17651: LD_INT 350
17653: PPUSH
17654: LD_INT 525
17656: PPUSH
17657: CALL_OW 12
17661: PPUSH
17662: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17666: LD_INT 1
17668: PPUSH
17669: LD_INT 5
17671: PPUSH
17672: CALL_OW 12
17676: PPUSH
17677: LD_INT 13
17679: PPUSH
17680: LD_INT 1
17682: PPUSH
17683: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17687: LD_INT 350
17689: PPUSH
17690: LD_INT 700
17692: PPUSH
17693: CALL_OW 12
17697: PPUSH
17698: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17702: LD_INT 1
17704: PPUSH
17705: LD_INT 5
17707: PPUSH
17708: CALL_OW 12
17712: PPUSH
17713: LD_INT 33
17715: PPUSH
17716: LD_INT 1
17718: PPUSH
17719: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17723: LD_INT 65
17725: PUSH
17726: LD_INT 62
17728: PUSH
17729: LD_INT 55
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: PUSH
17737: LD_OWVAR 67
17741: ARRAY
17742: PPUSH
17743: CALL_OW 13
17747: IFFALSE 17793
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17749: LD_INT 525
17751: PPUSH
17752: LD_INT 875
17754: PPUSH
17755: CALL_OW 12
17759: PPUSH
17760: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17764: LD_INT 1
17766: PPUSH
17767: LD_INT 5
17769: PPUSH
17770: CALL_OW 12
17774: PPUSH
17775: LD_INT 294
17777: PPUSH
17778: LD_INT 211
17780: PPUSH
17781: LD_INT 30
17783: PPUSH
17784: LD_INT 1
17786: PPUSH
17787: CALL_OW 56
// end else
17791: GO 17835
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17793: LD_INT 420
17795: PPUSH
17796: LD_INT 770
17798: PPUSH
17799: CALL_OW 12
17803: PPUSH
17804: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17808: LD_INT 1
17810: PPUSH
17811: LD_INT 5
17813: PPUSH
17814: CALL_OW 12
17818: PPUSH
17819: LD_INT 294
17821: PPUSH
17822: LD_INT 211
17824: PPUSH
17825: LD_INT 30
17827: PPUSH
17828: LD_INT 1
17830: PPUSH
17831: CALL_OW 56
// end ; if time > 2 2$20 then
17835: LD_VAR 0 1
17839: PUSH
17840: LD_INT 4900
17842: GREATER
17843: IFFALSE 17853
// time := 0 0$50 ;
17845: LD_ADDR_VAR 0 1
17849: PUSH
17850: LD_INT 1750
17852: ST_TO_ADDR
// until false ;
17853: LD_INT 0
17855: IFFALSE 17450
// end ;
17857: PPOPN 1
17859: END
// every 0 0$45 trigger tick < 10 10$00 do
17860: LD_OWVAR 1
17864: PUSH
17865: LD_INT 21000
17867: LESS
17868: IFFALSE 17916
17870: GO 17872
17872: DISABLE
// begin enable ;
17873: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17874: LD_INT 350
17876: PPUSH
17877: LD_INT 700
17879: PPUSH
17880: CALL_OW 12
17884: PPUSH
17885: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17889: LD_INT 3
17891: PPUSH
17892: LD_INT 5
17894: PPUSH
17895: CALL_OW 12
17899: PPUSH
17900: LD_INT 181
17902: PPUSH
17903: LD_INT 13
17905: PPUSH
17906: LD_INT 20
17908: PPUSH
17909: LD_INT 1
17911: PPUSH
17912: CALL_OW 56
// end ; end_of_file
17916: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17917: LD_INT 0
17919: PPUSH
// SetArtifactRes ( 7 , true ) ;
17920: LD_INT 7
17922: PPUSH
17923: LD_INT 1
17925: PPUSH
17926: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17930: LD_ADDR_EXP 62
17934: PUSH
17935: EMPTY
17936: PUSH
17937: EMPTY
17938: PUSH
17939: EMPTY
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17946: LD_ADDR_EXP 63
17950: PUSH
17951: LD_INT 1050
17953: PUSH
17954: LD_OWVAR 67
17958: MUL
17959: PUSH
17960: LD_INT 2800
17962: PUSH
17963: LD_OWVAR 67
17967: MUL
17968: PUSH
17969: LD_INT 1
17971: NEG
17972: PUSH
17973: EMPTY
17974: LIST
17975: LIST
17976: LIST
17977: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17978: LD_ADDR_EXP 64
17982: PUSH
17983: LD_INT 10
17985: PUSH
17986: LD_INT 35
17988: PUSH
17989: LD_INT 100
17991: PUSH
17992: EMPTY
17993: LIST
17994: LIST
17995: LIST
17996: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17997: LD_ADDR_EXP 65
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: LD_INT 0
18007: PUSH
18008: LD_INT 0
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: LIST
18015: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18016: LD_ADDR_EXP 67
18020: PUSH
18021: LD_INT 300
18023: PUSH
18024: LD_INT 500
18026: PUSH
18027: LD_INT 800
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: LIST
18034: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18035: LD_ADDR_EXP 68
18039: PUSH
18040: LD_INT 0
18042: PUSH
18043: LD_INT 0
18045: PUSH
18046: LD_INT 0
18048: PUSH
18049: EMPTY
18050: LIST
18051: LIST
18052: LIST
18053: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18054: LD_ADDR_EXP 69
18058: PUSH
18059: LD_INT 0
18061: PUSH
18062: LD_INT 0
18064: PUSH
18065: LD_INT 0
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: LIST
18072: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18073: LD_ADDR_EXP 66
18077: PUSH
18078: LD_INT 0
18080: PUSH
18081: LD_INT 0
18083: PUSH
18084: LD_INT 0
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18092: LD_ADDR_EXP 70
18096: PUSH
18097: LD_INT 4
18099: PUSH
18100: LD_INT 3
18102: PUSH
18103: LD_INT 1
18105: PUSH
18106: EMPTY
18107: LIST
18108: LIST
18109: LIST
18110: PUSH
18111: LD_INT 5
18113: PUSH
18114: LD_INT 4
18116: PUSH
18117: LD_INT 2
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: PUSH
18125: LD_INT 6
18127: PUSH
18128: LD_INT 3
18130: PUSH
18131: LD_INT 3
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: LIST
18143: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18144: LD_ADDR_EXP 71
18148: PUSH
18149: LD_INT 0
18151: PUSH
18152: LD_INT 0
18154: PUSH
18155: LD_INT 0
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 1
18167: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18168: LD_INT 24
18170: PPUSH
18171: LD_INT 7
18173: PPUSH
18174: CALL_OW 321
18178: PUSH
18179: LD_INT 2
18181: EQUAL
18182: IFFALSE 19108
18184: GO 18186
18186: DISABLE
18187: LD_INT 0
18189: PPUSH
18190: PPUSH
18191: PPUSH
18192: PPUSH
18193: PPUSH
// begin enable ;
18194: ENABLE
// for i = 1 to 3 do
18195: LD_ADDR_VAR 0 1
18199: PUSH
18200: DOUBLE
18201: LD_INT 1
18203: DEC
18204: ST_TO_ADDR
18205: LD_INT 3
18207: PUSH
18208: FOR_TO
18209: IFFALSE 19106
// begin pos := FindArtifact ( i + 2 ) ;
18211: LD_ADDR_VAR 0 2
18215: PUSH
18216: LD_VAR 0 1
18220: PUSH
18221: LD_INT 2
18223: PLUS
18224: PPUSH
18225: CALL_OW 469
18229: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18230: LD_ADDR_EXP 62
18234: PUSH
18235: LD_EXP 62
18239: PPUSH
18240: LD_VAR 0 1
18244: PPUSH
18245: LD_VAR 0 2
18249: PPUSH
18250: CALL_OW 1
18254: ST_TO_ADDR
// if pos then
18255: LD_VAR 0 2
18259: IFFALSE 18967
// begin case i of 1 :
18261: LD_VAR 0 1
18265: PUSH
18266: LD_INT 1
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18351
18274: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18275: LD_ADDR_VAR 0 4
18279: PUSH
18280: LD_INT 22
18282: PUSH
18283: LD_INT 7
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: PUSH
18290: LD_INT 23
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: LD_INT 2
18302: PUSH
18303: LD_INT 30
18305: PUSH
18306: LD_INT 8
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 30
18315: PUSH
18316: LD_INT 7
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 30
18325: PUSH
18326: LD_INT 11
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: LIST
18337: LIST
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: LIST
18343: PPUSH
18344: CALL_OW 69
18348: ST_TO_ADDR
18349: GO 18459
18351: LD_INT 2
18353: DOUBLE
18354: EQUAL
18355: IFTRUE 18359
18357: GO 18436
18359: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18360: LD_ADDR_VAR 0 4
18364: PUSH
18365: LD_INT 22
18367: PUSH
18368: LD_INT 7
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: PUSH
18375: LD_INT 23
18377: PUSH
18378: LD_INT 3
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: PUSH
18385: LD_INT 2
18387: PUSH
18388: LD_INT 30
18390: PUSH
18391: LD_INT 8
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: PUSH
18398: LD_INT 30
18400: PUSH
18401: LD_INT 7
18403: PUSH
18404: EMPTY
18405: LIST
18406: LIST
18407: PUSH
18408: LD_INT 30
18410: PUSH
18411: LD_INT 11
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: PUSH
18424: EMPTY
18425: LIST
18426: LIST
18427: LIST
18428: PPUSH
18429: CALL_OW 69
18433: ST_TO_ADDR
18434: GO 18459
18436: LD_INT 3
18438: DOUBLE
18439: EQUAL
18440: IFTRUE 18444
18442: GO 18458
18444: POP
// labs := [ alien ] ; end ;
18445: LD_ADDR_VAR 0 4
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: ST_TO_ADDR
18456: GO 18459
18458: POP
// if not labs then
18459: LD_VAR 0 4
18463: NOT
18464: IFFALSE 18468
// continue ;
18466: GO 18208
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18468: LD_ADDR_VAR 0 5
18472: PUSH
18473: LD_VAR 0 4
18477: PPUSH
18478: LD_EXP 62
18482: PUSH
18483: LD_VAR 0 1
18487: ARRAY
18488: PUSH
18489: LD_INT 1
18491: ARRAY
18492: PPUSH
18493: LD_EXP 62
18497: PUSH
18498: LD_VAR 0 1
18502: ARRAY
18503: PUSH
18504: LD_INT 2
18506: ARRAY
18507: PPUSH
18508: CALL_OW 73
18512: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18513: LD_VAR 0 5
18517: NOT
18518: PUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_EXP 69
18528: PUSH
18529: LD_VAR 0 1
18533: ARRAY
18534: NONEQUAL
18535: OR
18536: IFFALSE 18641
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18538: LD_INT 7
18540: PPUSH
18541: LD_EXP 70
18545: PUSH
18546: LD_VAR 0 1
18550: ARRAY
18551: PUSH
18552: LD_INT 3
18554: ARRAY
18555: PPUSH
18556: LD_INT 0
18558: PPUSH
18559: LD_EXP 69
18563: PUSH
18564: LD_VAR 0 1
18568: ARRAY
18569: PPUSH
18570: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18574: LD_INT 7
18576: PPUSH
18577: LD_EXP 70
18581: PUSH
18582: LD_VAR 0 1
18586: ARRAY
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: PPUSH
18592: LD_INT 0
18594: PPUSH
18595: LD_EXP 69
18599: PUSH
18600: LD_VAR 0 1
18604: ARRAY
18605: PPUSH
18606: CALL_OW 468
// if nearestLab then
18610: LD_VAR 0 5
18614: IFFALSE 18641
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18616: LD_ADDR_EXP 69
18620: PUSH
18621: LD_EXP 69
18625: PPUSH
18626: LD_VAR 0 1
18630: PPUSH
18631: LD_VAR 0 5
18635: PPUSH
18636: CALL_OW 1
18640: ST_TO_ADDR
// end ; if not nearestLab then
18641: LD_VAR 0 5
18645: NOT
18646: IFFALSE 18650
// continue ;
18648: GO 18208
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18650: LD_VAR 0 5
18654: PPUSH
18655: LD_EXP 62
18659: PUSH
18660: LD_VAR 0 1
18664: ARRAY
18665: PUSH
18666: LD_INT 1
18668: ARRAY
18669: PPUSH
18670: LD_EXP 62
18674: PUSH
18675: LD_VAR 0 1
18679: ARRAY
18680: PUSH
18681: LD_INT 2
18683: ARRAY
18684: PPUSH
18685: CALL_OW 297
18689: PUSH
18690: LD_INT 8
18692: LESS
18693: IFFALSE 18890
// begin if not artifactsResearched [ i ] then
18695: LD_EXP 65
18699: PUSH
18700: LD_VAR 0 1
18704: ARRAY
18705: NOT
18706: IFFALSE 18787
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18708: LD_VAR 0 5
18712: PPUSH
18713: CALL_OW 461
18717: PUSH
18718: LD_INT 2
18720: EQUAL
18721: IFFALSE 18755
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18723: LD_INT 7
18725: PPUSH
18726: LD_EXP 70
18730: PUSH
18731: LD_VAR 0 1
18735: ARRAY
18736: PUSH
18737: LD_INT 3
18739: ARRAY
18740: PPUSH
18741: LD_INT 2
18743: PPUSH
18744: LD_VAR 0 5
18748: PPUSH
18749: CALL_OW 468
18753: GO 18785
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18755: LD_INT 7
18757: PPUSH
18758: LD_EXP 70
18762: PUSH
18763: LD_VAR 0 1
18767: ARRAY
18768: PUSH
18769: LD_INT 3
18771: ARRAY
18772: PPUSH
18773: LD_INT 1
18775: PPUSH
18776: LD_VAR 0 5
18780: PPUSH
18781: CALL_OW 468
// end else
18785: GO 18888
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18787: LD_VAR 0 5
18791: PPUSH
18792: CALL_OW 461
18796: PUSH
18797: LD_INT 2
18799: EQUAL
18800: PUSH
18801: LD_EXP 71
18805: PUSH
18806: LD_VAR 0 1
18810: ARRAY
18811: AND
18812: IFFALSE 18858
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18814: LD_INT 7
18816: PPUSH
18817: LD_EXP 70
18821: PUSH
18822: LD_VAR 0 1
18826: ARRAY
18827: PUSH
18828: LD_INT 1
18830: ARRAY
18831: PPUSH
18832: LD_EXP 70
18836: PUSH
18837: LD_VAR 0 1
18841: ARRAY
18842: PUSH
18843: LD_INT 2
18845: ARRAY
18846: PPUSH
18847: LD_VAR 0 5
18851: PPUSH
18852: CALL_OW 468
18856: GO 18888
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18858: LD_INT 7
18860: PPUSH
18861: LD_EXP 70
18865: PUSH
18866: LD_VAR 0 1
18870: ARRAY
18871: PUSH
18872: LD_INT 1
18874: ARRAY
18875: PPUSH
18876: LD_INT 1
18878: PPUSH
18879: LD_VAR 0 5
18883: PPUSH
18884: CALL_OW 468
// end else
18888: GO 18965
// begin if not artifactsResearched [ i ] then
18890: LD_EXP 65
18894: PUSH
18895: LD_VAR 0 1
18899: ARRAY
18900: NOT
18901: IFFALSE 18935
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18903: LD_INT 7
18905: PPUSH
18906: LD_EXP 70
18910: PUSH
18911: LD_VAR 0 1
18915: ARRAY
18916: PUSH
18917: LD_INT 3
18919: ARRAY
18920: PPUSH
18921: LD_INT 0
18923: PPUSH
18924: LD_VAR 0 5
18928: PPUSH
18929: CALL_OW 468
18933: GO 18965
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18935: LD_INT 7
18937: PPUSH
18938: LD_EXP 70
18942: PUSH
18943: LD_VAR 0 1
18947: ARRAY
18948: PUSH
18949: LD_INT 1
18951: ARRAY
18952: PPUSH
18953: LD_INT 0
18955: PPUSH
18956: LD_VAR 0 5
18960: PPUSH
18961: CALL_OW 468
// end ; end else
18965: GO 19104
// begin if not artifactsLabs [ i ] then
18967: LD_EXP 69
18971: PUSH
18972: LD_VAR 0 1
18976: ARRAY
18977: NOT
18978: IFFALSE 18982
// continue ;
18980: GO 18208
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18982: LD_INT 7
18984: PPUSH
18985: LD_EXP 70
18989: PUSH
18990: LD_VAR 0 1
18994: ARRAY
18995: PUSH
18996: LD_INT 3
18998: ARRAY
18999: PPUSH
19000: LD_INT 0
19002: PPUSH
19003: LD_EXP 69
19007: PUSH
19008: LD_VAR 0 1
19012: ARRAY
19013: PPUSH
19014: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19018: LD_INT 7
19020: PPUSH
19021: LD_EXP 70
19025: PUSH
19026: LD_VAR 0 1
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: ARRAY
19035: PPUSH
19036: LD_INT 0
19038: PPUSH
19039: LD_EXP 69
19043: PUSH
19044: LD_VAR 0 1
19048: ARRAY
19049: PPUSH
19050: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19054: LD_EXP 66
19058: PUSH
19059: LD_VAR 0 1
19063: ARRAY
19064: IFFALSE 19104
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19066: LD_ADDR_EXP 66
19070: PUSH
19071: LD_EXP 66
19075: PPUSH
19076: LD_VAR 0 1
19080: PPUSH
19081: LD_INT 0
19083: PPUSH
19084: CALL_OW 1
19088: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19089: LD_EXP 69
19093: PUSH
19094: LD_VAR 0 1
19098: ARRAY
19099: PPUSH
19100: CALL_OW 127
// end ; end ; end ;
19104: GO 18208
19106: POP
19107: POP
// end ;
19108: PPOPN 5
19110: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19111: LD_INT 0
19113: PPUSH
19114: PPUSH
19115: PPUSH
19116: PPUSH
19117: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19118: LD_VAR 0 2
19122: PUSH
19123: LD_EXP 70
19127: PUSH
19128: LD_INT 1
19130: ARRAY
19131: PUSH
19132: LD_INT 3
19134: ARRAY
19135: EQUAL
19136: IFFALSE 19259
// begin lab := artifactsLabs [ 1 ] ;
19138: LD_ADDR_VAR 0 6
19142: PUSH
19143: LD_EXP 69
19147: PUSH
19148: LD_INT 1
19150: ARRAY
19151: ST_TO_ADDR
// if not lab then
19152: LD_VAR 0 6
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19161: LD_VAR 0 6
19165: PPUSH
19166: LD_EXP 67
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: PPUSH
19175: LD_INT 1
19177: PPUSH
19178: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19182: LD_EXP 68
19186: PUSH
19187: LD_INT 1
19189: ARRAY
19190: IFFALSE 19210
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19192: LD_VAR 0 6
19196: PPUSH
19197: LD_EXP 68
19201: PUSH
19202: LD_INT 1
19204: ARRAY
19205: PPUSH
19206: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19210: LD_ADDR_EXP 66
19214: PUSH
19215: LD_EXP 66
19219: PPUSH
19220: LD_INT 1
19222: PPUSH
19223: LD_INT 1
19225: PPUSH
19226: CALL_OW 1
19230: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19231: LD_INT 7
19233: PPUSH
19234: LD_EXP 70
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: PUSH
19243: LD_INT 3
19245: ARRAY
19246: PPUSH
19247: LD_INT 0
19249: PPUSH
19250: LD_VAR 0 6
19254: PPUSH
19255: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19259: LD_VAR 0 2
19263: PUSH
19264: LD_EXP 70
19268: PUSH
19269: LD_INT 2
19271: ARRAY
19272: PUSH
19273: LD_INT 3
19275: ARRAY
19276: EQUAL
19277: IFFALSE 19400
// begin lab := artifactsLabs [ 2 ] ;
19279: LD_ADDR_VAR 0 6
19283: PUSH
19284: LD_EXP 69
19288: PUSH
19289: LD_INT 2
19291: ARRAY
19292: ST_TO_ADDR
// if not lab then
19293: LD_VAR 0 6
19297: NOT
19298: IFFALSE 19302
// exit ;
19300: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19302: LD_VAR 0 6
19306: PPUSH
19307: LD_EXP 67
19311: PUSH
19312: LD_INT 2
19314: ARRAY
19315: PPUSH
19316: LD_INT 1
19318: PPUSH
19319: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19323: LD_EXP 68
19327: PUSH
19328: LD_INT 2
19330: ARRAY
19331: IFFALSE 19351
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19333: LD_VAR 0 6
19337: PPUSH
19338: LD_EXP 68
19342: PUSH
19343: LD_INT 2
19345: ARRAY
19346: PPUSH
19347: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19351: LD_ADDR_EXP 66
19355: PUSH
19356: LD_EXP 66
19360: PPUSH
19361: LD_INT 2
19363: PPUSH
19364: LD_INT 1
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19372: LD_INT 7
19374: PPUSH
19375: LD_EXP 70
19379: PUSH
19380: LD_INT 2
19382: ARRAY
19383: PUSH
19384: LD_INT 3
19386: ARRAY
19387: PPUSH
19388: LD_INT 0
19390: PPUSH
19391: LD_VAR 0 6
19395: PPUSH
19396: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19400: LD_VAR 0 2
19404: PUSH
19405: LD_EXP 70
19409: PUSH
19410: LD_INT 3
19412: ARRAY
19413: PUSH
19414: LD_INT 3
19416: ARRAY
19417: EQUAL
19418: IFFALSE 19541
// begin lab := artifactsLabs [ 3 ] ;
19420: LD_ADDR_VAR 0 6
19424: PUSH
19425: LD_EXP 69
19429: PUSH
19430: LD_INT 3
19432: ARRAY
19433: ST_TO_ADDR
// if not lab then
19434: LD_VAR 0 6
19438: NOT
19439: IFFALSE 19443
// exit ;
19441: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19443: LD_VAR 0 6
19447: PPUSH
19448: LD_EXP 67
19452: PUSH
19453: LD_INT 3
19455: ARRAY
19456: PPUSH
19457: LD_INT 1
19459: PPUSH
19460: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19464: LD_EXP 68
19468: PUSH
19469: LD_INT 3
19471: ARRAY
19472: IFFALSE 19492
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19474: LD_VAR 0 6
19478: PPUSH
19479: LD_EXP 68
19483: PUSH
19484: LD_INT 3
19486: ARRAY
19487: PPUSH
19488: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19492: LD_ADDR_EXP 66
19496: PUSH
19497: LD_EXP 66
19501: PPUSH
19502: LD_INT 3
19504: PPUSH
19505: LD_INT 1
19507: PPUSH
19508: CALL_OW 1
19512: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19513: LD_INT 7
19515: PPUSH
19516: LD_EXP 70
19520: PUSH
19521: LD_INT 3
19523: ARRAY
19524: PUSH
19525: LD_INT 3
19527: ARRAY
19528: PPUSH
19529: LD_INT 0
19531: PPUSH
19532: LD_VAR 0 6
19536: PPUSH
19537: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19541: LD_VAR 0 2
19545: PUSH
19546: LD_EXP 70
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PUSH
19555: LD_INT 1
19557: ARRAY
19558: EQUAL
19559: IFFALSE 19717
// begin lab := artifactsLabs [ 1 ] ;
19561: LD_ADDR_VAR 0 6
19565: PUSH
19566: LD_EXP 69
19570: PUSH
19571: LD_INT 1
19573: ARRAY
19574: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19575: LD_VAR 0 6
19579: PPUSH
19580: CALL_OW 274
19584: PPUSH
19585: CALL 87441 0 1
19589: PUSH
19590: LD_INT 3
19592: ARRAY
19593: PUSH
19594: LD_EXP 64
19598: PUSH
19599: LD_INT 1
19601: ARRAY
19602: LESS
19603: IFFALSE 19617
// begin HintSpec ( ArtifactCost , 2 ) ;
19605: LD_STRING ArtifactCost
19607: PPUSH
19608: LD_INT 2
19610: PPUSH
19611: CALL_OW 338
// exit ;
19615: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19617: LD_ADDR_EXP 71
19621: PUSH
19622: LD_EXP 71
19626: PPUSH
19627: LD_INT 1
19629: PPUSH
19630: LD_INT 0
19632: PPUSH
19633: CALL_OW 1
19637: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19638: LD_VAR 0 3
19642: PPUSH
19643: LD_VAR 0 4
19647: PPUSH
19648: LD_INT 7
19650: PPUSH
19651: LD_INT 12
19653: NEG
19654: PPUSH
19655: CALL_OW 330
// wait ( 0 0$30 ) ;
19659: LD_INT 1050
19661: PPUSH
19662: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19666: LD_VAR 0 3
19670: PPUSH
19671: LD_VAR 0 4
19675: PPUSH
19676: LD_INT 7
19678: PPUSH
19679: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19683: LD_EXP 63
19687: PUSH
19688: LD_INT 1
19690: ARRAY
19691: PPUSH
19692: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19696: LD_ADDR_EXP 71
19700: PUSH
19701: LD_EXP 71
19705: PPUSH
19706: LD_INT 1
19708: PPUSH
19709: LD_INT 1
19711: PPUSH
19712: CALL_OW 1
19716: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19717: LD_VAR 0 2
19721: PUSH
19722: LD_EXP 70
19726: PUSH
19727: LD_INT 2
19729: ARRAY
19730: PUSH
19731: LD_INT 1
19733: ARRAY
19734: EQUAL
19735: IFFALSE 19972
// begin lab := artifactsLabs [ 2 ] ;
19737: LD_ADDR_VAR 0 6
19741: PUSH
19742: LD_EXP 69
19746: PUSH
19747: LD_INT 2
19749: ARRAY
19750: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19751: LD_VAR 0 3
19755: PUSH
19756: LD_INT 81
19758: PUSH
19759: LD_INT 7
19761: PUSH
19762: EMPTY
19763: LIST
19764: LIST
19765: PUSH
19766: LD_INT 2
19768: PUSH
19769: LD_INT 32
19771: PUSH
19772: LD_INT 3
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 30
19781: PUSH
19782: LD_INT 28
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 30
19791: PUSH
19792: LD_INT 30
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: PUSH
19799: LD_INT 35
19801: PUSH
19802: LD_INT 49
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: PUSH
19809: LD_INT 34
19811: PUSH
19812: LD_INT 49
19814: PUSH
19815: EMPTY
19816: LIST
19817: LIST
19818: PUSH
19819: LD_INT 30
19821: PUSH
19822: LD_INT 21
19824: PUSH
19825: EMPTY
19826: LIST
19827: LIST
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: LIST
19833: LIST
19834: LIST
19835: LIST
19836: LIST
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PPUSH
19842: CALL_OW 69
19846: IN
19847: NOT
19848: IFFALSE 19852
// exit ;
19850: GO 20239
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19852: LD_VAR 0 6
19856: PPUSH
19857: CALL_OW 274
19861: PPUSH
19862: CALL 87441 0 1
19866: PUSH
19867: LD_INT 3
19869: ARRAY
19870: PUSH
19871: LD_EXP 64
19875: PUSH
19876: LD_INT 2
19878: ARRAY
19879: LESS
19880: IFFALSE 19894
// begin HintSpec ( ArtifactCost , 2 ) ;
19882: LD_STRING ArtifactCost
19884: PPUSH
19885: LD_INT 2
19887: PPUSH
19888: CALL_OW 338
// exit ;
19892: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19894: LD_ADDR_EXP 71
19898: PUSH
19899: LD_EXP 71
19903: PPUSH
19904: LD_INT 2
19906: PPUSH
19907: LD_INT 0
19909: PPUSH
19910: CALL_OW 1
19914: ST_TO_ADDR
// KillUnit ( x ) ;
19915: LD_VAR 0 3
19919: PPUSH
19920: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19924: LD_ADDR_EXP 16
19928: PUSH
19929: LD_EXP 16
19933: PUSH
19934: LD_INT 1
19936: PLUS
19937: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19938: LD_EXP 63
19942: PUSH
19943: LD_INT 2
19945: ARRAY
19946: PPUSH
19947: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19951: LD_ADDR_EXP 71
19955: PUSH
19956: LD_EXP 71
19960: PPUSH
19961: LD_INT 2
19963: PPUSH
19964: LD_INT 1
19966: PPUSH
19967: CALL_OW 1
19971: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19972: LD_VAR 0 2
19976: PUSH
19977: LD_EXP 70
19981: PUSH
19982: LD_INT 3
19984: ARRAY
19985: PUSH
19986: LD_INT 1
19988: ARRAY
19989: EQUAL
19990: IFFALSE 20239
// begin lab := artifactsLabs [ 3 ] ;
19992: LD_ADDR_VAR 0 6
19996: PUSH
19997: LD_EXP 69
20001: PUSH
20002: LD_INT 3
20004: ARRAY
20005: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20006: LD_VAR 0 6
20010: PPUSH
20011: CALL_OW 274
20015: PPUSH
20016: CALL 87441 0 1
20020: PUSH
20021: LD_INT 3
20023: ARRAY
20024: PUSH
20025: LD_EXP 64
20029: PUSH
20030: LD_INT 3
20032: ARRAY
20033: LESS
20034: IFFALSE 20048
// begin HintSpec ( ArtifactCost , 2 ) ;
20036: LD_STRING ArtifactCost
20038: PPUSH
20039: LD_INT 2
20041: PPUSH
20042: CALL_OW 338
// exit ;
20046: GO 20239
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20048: LD_INT 37
20050: PPUSH
20051: LD_INT 1
20053: PPUSH
20054: CALL_OW 424
// time := 0 0$30 ;
20058: LD_ADDR_VAR 0 7
20062: PUSH
20063: LD_INT 1050
20065: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20066: LD_ADDR_EXP 71
20070: PUSH
20071: LD_EXP 71
20075: PPUSH
20076: LD_INT 3
20078: PPUSH
20079: LD_INT 0
20081: PPUSH
20082: CALL_OW 1
20086: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20087: LD_ADDR_OWVAR 47
20091: PUSH
20092: LD_STRING #Am15a-1
20094: PUSH
20095: LD_VAR 0 7
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20104: LD_INT 35
20106: PPUSH
20107: CALL_OW 67
// time := time - 0 0$1 ;
20111: LD_ADDR_VAR 0 7
20115: PUSH
20116: LD_VAR 0 7
20120: PUSH
20121: LD_INT 35
20123: MINUS
20124: ST_TO_ADDR
// until time = 0 0$00 ;
20125: LD_VAR 0 7
20129: PUSH
20130: LD_INT 0
20132: EQUAL
20133: IFFALSE 20087
// display_strings :=  ;
20135: LD_ADDR_OWVAR 47
20139: PUSH
20140: LD_STRING 
20142: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20143: LD_INT 37
20145: PPUSH
20146: LD_INT 0
20148: PPUSH
20149: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20153: LD_ADDR_VAR 0 8
20157: PUSH
20158: LD_INT 37
20160: PPUSH
20161: LD_INT 3
20163: PUSH
20164: LD_INT 21
20166: PUSH
20167: LD_INT 3
20169: PUSH
20170: EMPTY
20171: LIST
20172: LIST
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: PPUSH
20178: CALL_OW 70
20182: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20183: LD_VAR 0 3
20187: PPUSH
20188: LD_VAR 0 4
20192: PPUSH
20193: CALL_OW 84
// for un in list do
20197: LD_ADDR_VAR 0 9
20201: PUSH
20202: LD_VAR 0 8
20206: PUSH
20207: FOR_IN
20208: IFFALSE 20237
// TeleportUnit ( un , x , y , 12 , true ) ;
20210: LD_VAR 0 9
20214: PPUSH
20215: LD_VAR 0 3
20219: PPUSH
20220: LD_VAR 0 4
20224: PPUSH
20225: LD_INT 12
20227: PPUSH
20228: LD_INT 1
20230: PPUSH
20231: CALL_OW 483
20235: GO 20207
20237: POP
20238: POP
// end ; end ;
20239: PPOPN 9
20241: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20242: LD_INT 0
20244: PPUSH
20245: PPUSH
// begin labNum := 0 ;
20246: LD_ADDR_VAR 0 4
20250: PUSH
20251: LD_INT 0
20253: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20254: LD_ADDR_VAR 0 3
20258: PUSH
20259: DOUBLE
20260: LD_INT 1
20262: DEC
20263: ST_TO_ADDR
20264: LD_EXP 69
20268: PUSH
20269: FOR_TO
20270: IFFALSE 20304
// if artifactsLabs [ i ] = lab then
20272: LD_EXP 69
20276: PUSH
20277: LD_VAR 0 3
20281: ARRAY
20282: PUSH
20283: LD_VAR 0 1
20287: EQUAL
20288: IFFALSE 20302
// begin labNum := i ;
20290: LD_ADDR_VAR 0 4
20294: PUSH
20295: LD_VAR 0 3
20299: ST_TO_ADDR
// break ;
20300: GO 20304
// end ;
20302: GO 20269
20304: POP
20305: POP
// if not labNum then
20306: LD_VAR 0 4
20310: NOT
20311: IFFALSE 20315
// exit ;
20313: GO 20393
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20315: LD_INT 7
20317: PPUSH
20318: LD_EXP 70
20322: PUSH
20323: LD_VAR 0 4
20327: ARRAY
20328: PUSH
20329: LD_INT 3
20331: ARRAY
20332: PPUSH
20333: LD_INT 2
20335: PPUSH
20336: LD_VAR 0 1
20340: PPUSH
20341: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20345: LD_ADDR_EXP 68
20349: PUSH
20350: LD_EXP 68
20354: PPUSH
20355: LD_VAR 0 4
20359: PPUSH
20360: LD_VAR 0 2
20364: PPUSH
20365: CALL_OW 1
20369: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20370: LD_ADDR_EXP 66
20374: PUSH
20375: LD_EXP 66
20379: PPUSH
20380: LD_VAR 0 4
20384: PPUSH
20385: LD_INT 0
20387: PPUSH
20388: CALL_OW 1
20392: ST_TO_ADDR
// end ;
20393: PPOPN 4
20395: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20396: LD_INT 0
20398: PPUSH
20399: PPUSH
// begin labNum := 0 ;
20400: LD_ADDR_VAR 0 3
20404: PUSH
20405: LD_INT 0
20407: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20408: LD_ADDR_VAR 0 2
20412: PUSH
20413: DOUBLE
20414: LD_INT 1
20416: DEC
20417: ST_TO_ADDR
20418: LD_EXP 69
20422: PUSH
20423: FOR_TO
20424: IFFALSE 20458
// if artifactsLabs [ i ] = lab then
20426: LD_EXP 69
20430: PUSH
20431: LD_VAR 0 2
20435: ARRAY
20436: PUSH
20437: LD_VAR 0 1
20441: EQUAL
20442: IFFALSE 20456
// begin labNum := i ;
20444: LD_ADDR_VAR 0 3
20448: PUSH
20449: LD_VAR 0 2
20453: ST_TO_ADDR
// break ;
20454: GO 20458
// end ;
20456: GO 20423
20458: POP
20459: POP
// if not labNum then
20460: LD_VAR 0 3
20464: NOT
20465: IFFALSE 20469
// exit ;
20467: GO 20631
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20469: LD_INT 7
20471: PPUSH
20472: LD_EXP 70
20476: PUSH
20477: LD_VAR 0 3
20481: ARRAY
20482: PUSH
20483: LD_INT 3
20485: ARRAY
20486: PPUSH
20487: LD_INT 0
20489: PPUSH
20490: LD_VAR 0 1
20494: PPUSH
20495: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20499: LD_ADDR_EXP 65
20503: PUSH
20504: LD_EXP 65
20508: PPUSH
20509: LD_VAR 0 3
20513: PPUSH
20514: LD_INT 1
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20522: LD_ADDR_EXP 71
20526: PUSH
20527: LD_EXP 71
20531: PPUSH
20532: LD_VAR 0 3
20536: PPUSH
20537: LD_INT 1
20539: PPUSH
20540: CALL_OW 1
20544: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20545: LD_ADDR_EXP 66
20549: PUSH
20550: LD_EXP 66
20554: PPUSH
20555: LD_VAR 0 3
20559: PPUSH
20560: LD_INT 0
20562: PPUSH
20563: CALL_OW 1
20567: ST_TO_ADDR
// case labNum of 1 :
20568: LD_VAR 0 3
20572: PUSH
20573: LD_INT 1
20575: DOUBLE
20576: EQUAL
20577: IFTRUE 20581
20579: GO 20592
20581: POP
// artifactIResearched := true ; 2 :
20582: LD_ADDR_EXP 12
20586: PUSH
20587: LD_INT 1
20589: ST_TO_ADDR
20590: GO 20631
20592: LD_INT 2
20594: DOUBLE
20595: EQUAL
20596: IFTRUE 20600
20598: GO 20611
20600: POP
// artifactIIResearched := true ; 3 :
20601: LD_ADDR_EXP 13
20605: PUSH
20606: LD_INT 1
20608: ST_TO_ADDR
20609: GO 20631
20611: LD_INT 3
20613: DOUBLE
20614: EQUAL
20615: IFTRUE 20619
20617: GO 20630
20619: POP
// artifactIIIResearched := true ; end ;
20620: LD_ADDR_EXP 14
20624: PUSH
20625: LD_INT 1
20627: ST_TO_ADDR
20628: GO 20631
20630: POP
// end ; end_of_file
20631: PPOPN 3
20633: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
20634: LD_INT 0
20636: PPUSH
// ar_miner := 81 ;
20637: LD_ADDR_EXP 79
20641: PUSH
20642: LD_INT 81
20644: ST_TO_ADDR
// ar_crane := 88 ;
20645: LD_ADDR_EXP 78
20649: PUSH
20650: LD_INT 88
20652: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20653: LD_ADDR_EXP 73
20657: PUSH
20658: LD_INT 89
20660: ST_TO_ADDR
// us_hack := 99 ;
20661: LD_ADDR_EXP 74
20665: PUSH
20666: LD_INT 99
20668: ST_TO_ADDR
// us_artillery := 97 ;
20669: LD_ADDR_EXP 75
20673: PUSH
20674: LD_INT 97
20676: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20677: LD_ADDR_EXP 76
20681: PUSH
20682: LD_INT 91
20684: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
20685: LD_ADDR_EXP 77
20689: PUSH
20690: LD_INT 92
20692: ST_TO_ADDR
// ru_radar := 98 ;
20693: LD_ADDR_EXP 72
20697: PUSH
20698: LD_INT 98
20700: ST_TO_ADDR
// tech_Artillery := 80 ;
20701: LD_ADDR_EXP 80
20705: PUSH
20706: LD_INT 80
20708: ST_TO_ADDR
// tech_RadMat := 81 ;
20709: LD_ADDR_EXP 81
20713: PUSH
20714: LD_INT 81
20716: ST_TO_ADDR
// tech_BasicTools := 82 ;
20717: LD_ADDR_EXP 82
20721: PUSH
20722: LD_INT 82
20724: ST_TO_ADDR
// tech_Cargo := 83 ;
20725: LD_ADDR_EXP 83
20729: PUSH
20730: LD_INT 83
20732: ST_TO_ADDR
// tech_Track := 84 ;
20733: LD_ADDR_EXP 84
20737: PUSH
20738: LD_INT 84
20740: ST_TO_ADDR
// tech_Crane := 85 ;
20741: LD_ADDR_EXP 85
20745: PUSH
20746: LD_INT 85
20748: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20749: LD_ADDR_EXP 86
20753: PUSH
20754: LD_INT 86
20756: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20757: LD_ADDR_EXP 87
20761: PUSH
20762: LD_INT 87
20764: ST_TO_ADDR
// end ;
20765: LD_VAR 0 1
20769: RET
// every 1 do
20770: GO 20772
20772: DISABLE
// InitGlobalVariables ; end_of_file
20773: CALL 20634 0 0
20777: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20778: LD_INT 0
20780: PPUSH
20781: PPUSH
// skirmish := false ;
20782: LD_ADDR_EXP 88
20786: PUSH
20787: LD_INT 0
20789: ST_TO_ADDR
// debug_mc := false ;
20790: LD_ADDR_EXP 89
20794: PUSH
20795: LD_INT 0
20797: ST_TO_ADDR
// mc_bases := [ ] ;
20798: LD_ADDR_EXP 90
20802: PUSH
20803: EMPTY
20804: ST_TO_ADDR
// mc_sides := [ ] ;
20805: LD_ADDR_EXP 116
20809: PUSH
20810: EMPTY
20811: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20812: LD_ADDR_EXP 91
20816: PUSH
20817: EMPTY
20818: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20819: LD_ADDR_EXP 92
20823: PUSH
20824: EMPTY
20825: ST_TO_ADDR
// mc_need_heal := [ ] ;
20826: LD_ADDR_EXP 93
20830: PUSH
20831: EMPTY
20832: ST_TO_ADDR
// mc_healers := [ ] ;
20833: LD_ADDR_EXP 94
20837: PUSH
20838: EMPTY
20839: ST_TO_ADDR
// mc_build_list := [ ] ;
20840: LD_ADDR_EXP 95
20844: PUSH
20845: EMPTY
20846: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20847: LD_ADDR_EXP 122
20851: PUSH
20852: EMPTY
20853: ST_TO_ADDR
// mc_builders := [ ] ;
20854: LD_ADDR_EXP 96
20858: PUSH
20859: EMPTY
20860: ST_TO_ADDR
// mc_construct_list := [ ] ;
20861: LD_ADDR_EXP 97
20865: PUSH
20866: EMPTY
20867: ST_TO_ADDR
// mc_turret_list := [ ] ;
20868: LD_ADDR_EXP 98
20872: PUSH
20873: EMPTY
20874: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20875: LD_ADDR_EXP 99
20879: PUSH
20880: EMPTY
20881: ST_TO_ADDR
// mc_miners := [ ] ;
20882: LD_ADDR_EXP 104
20886: PUSH
20887: EMPTY
20888: ST_TO_ADDR
// mc_mines := [ ] ;
20889: LD_ADDR_EXP 103
20893: PUSH
20894: EMPTY
20895: ST_TO_ADDR
// mc_minefields := [ ] ;
20896: LD_ADDR_EXP 105
20900: PUSH
20901: EMPTY
20902: ST_TO_ADDR
// mc_crates := [ ] ;
20903: LD_ADDR_EXP 106
20907: PUSH
20908: EMPTY
20909: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20910: LD_ADDR_EXP 107
20914: PUSH
20915: EMPTY
20916: ST_TO_ADDR
// mc_crates_area := [ ] ;
20917: LD_ADDR_EXP 108
20921: PUSH
20922: EMPTY
20923: ST_TO_ADDR
// mc_vehicles := [ ] ;
20924: LD_ADDR_EXP 109
20928: PUSH
20929: EMPTY
20930: ST_TO_ADDR
// mc_attack := [ ] ;
20931: LD_ADDR_EXP 110
20935: PUSH
20936: EMPTY
20937: ST_TO_ADDR
// mc_produce := [ ] ;
20938: LD_ADDR_EXP 111
20942: PUSH
20943: EMPTY
20944: ST_TO_ADDR
// mc_defender := [ ] ;
20945: LD_ADDR_EXP 112
20949: PUSH
20950: EMPTY
20951: ST_TO_ADDR
// mc_parking := [ ] ;
20952: LD_ADDR_EXP 114
20956: PUSH
20957: EMPTY
20958: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20959: LD_ADDR_EXP 100
20963: PUSH
20964: EMPTY
20965: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20966: LD_ADDR_EXP 102
20970: PUSH
20971: EMPTY
20972: ST_TO_ADDR
// mc_scan := [ ] ;
20973: LD_ADDR_EXP 113
20977: PUSH
20978: EMPTY
20979: ST_TO_ADDR
// mc_scan_area := [ ] ;
20980: LD_ADDR_EXP 115
20984: PUSH
20985: EMPTY
20986: ST_TO_ADDR
// mc_tech := [ ] ;
20987: LD_ADDR_EXP 117
20991: PUSH
20992: EMPTY
20993: ST_TO_ADDR
// mc_class := [ ] ;
20994: LD_ADDR_EXP 131
20998: PUSH
20999: EMPTY
21000: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21001: LD_ADDR_EXP 132
21005: PUSH
21006: EMPTY
21007: ST_TO_ADDR
// end ;
21008: LD_VAR 0 1
21012: RET
// export function MC_Kill ( base ) ; begin
21013: LD_INT 0
21015: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21016: LD_ADDR_EXP 90
21020: PUSH
21021: LD_EXP 90
21025: PPUSH
21026: LD_VAR 0 1
21030: PPUSH
21031: EMPTY
21032: PPUSH
21033: CALL_OW 1
21037: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21038: LD_ADDR_EXP 91
21042: PUSH
21043: LD_EXP 91
21047: PPUSH
21048: LD_VAR 0 1
21052: PPUSH
21053: EMPTY
21054: PPUSH
21055: CALL_OW 1
21059: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21060: LD_ADDR_EXP 92
21064: PUSH
21065: LD_EXP 92
21069: PPUSH
21070: LD_VAR 0 1
21074: PPUSH
21075: EMPTY
21076: PPUSH
21077: CALL_OW 1
21081: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21082: LD_ADDR_EXP 93
21086: PUSH
21087: LD_EXP 93
21091: PPUSH
21092: LD_VAR 0 1
21096: PPUSH
21097: EMPTY
21098: PPUSH
21099: CALL_OW 1
21103: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21104: LD_ADDR_EXP 94
21108: PUSH
21109: LD_EXP 94
21113: PPUSH
21114: LD_VAR 0 1
21118: PPUSH
21119: EMPTY
21120: PPUSH
21121: CALL_OW 1
21125: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21126: LD_ADDR_EXP 95
21130: PUSH
21131: LD_EXP 95
21135: PPUSH
21136: LD_VAR 0 1
21140: PPUSH
21141: EMPTY
21142: PPUSH
21143: CALL_OW 1
21147: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21148: LD_ADDR_EXP 96
21152: PUSH
21153: LD_EXP 96
21157: PPUSH
21158: LD_VAR 0 1
21162: PPUSH
21163: EMPTY
21164: PPUSH
21165: CALL_OW 1
21169: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21170: LD_ADDR_EXP 97
21174: PUSH
21175: LD_EXP 97
21179: PPUSH
21180: LD_VAR 0 1
21184: PPUSH
21185: EMPTY
21186: PPUSH
21187: CALL_OW 1
21191: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21192: LD_ADDR_EXP 98
21196: PUSH
21197: LD_EXP 98
21201: PPUSH
21202: LD_VAR 0 1
21206: PPUSH
21207: EMPTY
21208: PPUSH
21209: CALL_OW 1
21213: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21214: LD_ADDR_EXP 99
21218: PUSH
21219: LD_EXP 99
21223: PPUSH
21224: LD_VAR 0 1
21228: PPUSH
21229: EMPTY
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21236: LD_ADDR_EXP 100
21240: PUSH
21241: LD_EXP 100
21245: PPUSH
21246: LD_VAR 0 1
21250: PPUSH
21251: EMPTY
21252: PPUSH
21253: CALL_OW 1
21257: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21258: LD_ADDR_EXP 101
21262: PUSH
21263: LD_EXP 101
21267: PPUSH
21268: LD_VAR 0 1
21272: PPUSH
21273: LD_INT 0
21275: PPUSH
21276: CALL_OW 1
21280: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21281: LD_ADDR_EXP 102
21285: PUSH
21286: LD_EXP 102
21290: PPUSH
21291: LD_VAR 0 1
21295: PPUSH
21296: EMPTY
21297: PPUSH
21298: CALL_OW 1
21302: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21303: LD_ADDR_EXP 103
21307: PUSH
21308: LD_EXP 103
21312: PPUSH
21313: LD_VAR 0 1
21317: PPUSH
21318: EMPTY
21319: PPUSH
21320: CALL_OW 1
21324: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21325: LD_ADDR_EXP 104
21329: PUSH
21330: LD_EXP 104
21334: PPUSH
21335: LD_VAR 0 1
21339: PPUSH
21340: EMPTY
21341: PPUSH
21342: CALL_OW 1
21346: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21347: LD_ADDR_EXP 105
21351: PUSH
21352: LD_EXP 105
21356: PPUSH
21357: LD_VAR 0 1
21361: PPUSH
21362: EMPTY
21363: PPUSH
21364: CALL_OW 1
21368: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21369: LD_ADDR_EXP 106
21373: PUSH
21374: LD_EXP 106
21378: PPUSH
21379: LD_VAR 0 1
21383: PPUSH
21384: EMPTY
21385: PPUSH
21386: CALL_OW 1
21390: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21391: LD_ADDR_EXP 107
21395: PUSH
21396: LD_EXP 107
21400: PPUSH
21401: LD_VAR 0 1
21405: PPUSH
21406: EMPTY
21407: PPUSH
21408: CALL_OW 1
21412: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21413: LD_ADDR_EXP 108
21417: PUSH
21418: LD_EXP 108
21422: PPUSH
21423: LD_VAR 0 1
21427: PPUSH
21428: EMPTY
21429: PPUSH
21430: CALL_OW 1
21434: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21435: LD_ADDR_EXP 109
21439: PUSH
21440: LD_EXP 109
21444: PPUSH
21445: LD_VAR 0 1
21449: PPUSH
21450: EMPTY
21451: PPUSH
21452: CALL_OW 1
21456: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21457: LD_ADDR_EXP 110
21461: PUSH
21462: LD_EXP 110
21466: PPUSH
21467: LD_VAR 0 1
21471: PPUSH
21472: EMPTY
21473: PPUSH
21474: CALL_OW 1
21478: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21479: LD_ADDR_EXP 111
21483: PUSH
21484: LD_EXP 111
21488: PPUSH
21489: LD_VAR 0 1
21493: PPUSH
21494: EMPTY
21495: PPUSH
21496: CALL_OW 1
21500: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21501: LD_ADDR_EXP 112
21505: PUSH
21506: LD_EXP 112
21510: PPUSH
21511: LD_VAR 0 1
21515: PPUSH
21516: EMPTY
21517: PPUSH
21518: CALL_OW 1
21522: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21523: LD_ADDR_EXP 113
21527: PUSH
21528: LD_EXP 113
21532: PPUSH
21533: LD_VAR 0 1
21537: PPUSH
21538: EMPTY
21539: PPUSH
21540: CALL_OW 1
21544: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21545: LD_ADDR_EXP 114
21549: PUSH
21550: LD_EXP 114
21554: PPUSH
21555: LD_VAR 0 1
21559: PPUSH
21560: EMPTY
21561: PPUSH
21562: CALL_OW 1
21566: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21567: LD_ADDR_EXP 115
21571: PUSH
21572: LD_EXP 115
21576: PPUSH
21577: LD_VAR 0 1
21581: PPUSH
21582: EMPTY
21583: PPUSH
21584: CALL_OW 1
21588: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21589: LD_ADDR_EXP 117
21593: PUSH
21594: LD_EXP 117
21598: PPUSH
21599: LD_VAR 0 1
21603: PPUSH
21604: EMPTY
21605: PPUSH
21606: CALL_OW 1
21610: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21611: LD_ADDR_EXP 119
21615: PUSH
21616: LD_EXP 119
21620: PPUSH
21621: LD_VAR 0 1
21625: PPUSH
21626: EMPTY
21627: PPUSH
21628: CALL_OW 1
21632: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21633: LD_ADDR_EXP 120
21637: PUSH
21638: LD_EXP 120
21642: PPUSH
21643: LD_VAR 0 1
21647: PPUSH
21648: EMPTY
21649: PPUSH
21650: CALL_OW 1
21654: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21655: LD_ADDR_EXP 121
21659: PUSH
21660: LD_EXP 121
21664: PPUSH
21665: LD_VAR 0 1
21669: PPUSH
21670: EMPTY
21671: PPUSH
21672: CALL_OW 1
21676: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21677: LD_ADDR_EXP 122
21681: PUSH
21682: LD_EXP 122
21686: PPUSH
21687: LD_VAR 0 1
21691: PPUSH
21692: EMPTY
21693: PPUSH
21694: CALL_OW 1
21698: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21699: LD_ADDR_EXP 123
21703: PUSH
21704: LD_EXP 123
21708: PPUSH
21709: LD_VAR 0 1
21713: PPUSH
21714: EMPTY
21715: PPUSH
21716: CALL_OW 1
21720: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21721: LD_ADDR_EXP 124
21725: PUSH
21726: LD_EXP 124
21730: PPUSH
21731: LD_VAR 0 1
21735: PPUSH
21736: EMPTY
21737: PPUSH
21738: CALL_OW 1
21742: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21743: LD_ADDR_EXP 125
21747: PUSH
21748: LD_EXP 125
21752: PPUSH
21753: LD_VAR 0 1
21757: PPUSH
21758: EMPTY
21759: PPUSH
21760: CALL_OW 1
21764: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21765: LD_ADDR_EXP 126
21769: PUSH
21770: LD_EXP 126
21774: PPUSH
21775: LD_VAR 0 1
21779: PPUSH
21780: EMPTY
21781: PPUSH
21782: CALL_OW 1
21786: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21787: LD_ADDR_EXP 127
21791: PUSH
21792: LD_EXP 127
21796: PPUSH
21797: LD_VAR 0 1
21801: PPUSH
21802: EMPTY
21803: PPUSH
21804: CALL_OW 1
21808: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21809: LD_ADDR_EXP 128
21813: PUSH
21814: LD_EXP 128
21818: PPUSH
21819: LD_VAR 0 1
21823: PPUSH
21824: EMPTY
21825: PPUSH
21826: CALL_OW 1
21830: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21831: LD_ADDR_EXP 129
21835: PUSH
21836: LD_EXP 129
21840: PPUSH
21841: LD_VAR 0 1
21845: PPUSH
21846: EMPTY
21847: PPUSH
21848: CALL_OW 1
21852: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21853: LD_ADDR_EXP 130
21857: PUSH
21858: LD_EXP 130
21862: PPUSH
21863: LD_VAR 0 1
21867: PPUSH
21868: EMPTY
21869: PPUSH
21870: CALL_OW 1
21874: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21875: LD_ADDR_EXP 131
21879: PUSH
21880: LD_EXP 131
21884: PPUSH
21885: LD_VAR 0 1
21889: PPUSH
21890: EMPTY
21891: PPUSH
21892: CALL_OW 1
21896: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21897: LD_ADDR_EXP 132
21901: PUSH
21902: LD_EXP 132
21906: PPUSH
21907: LD_VAR 0 1
21911: PPUSH
21912: LD_INT 0
21914: PPUSH
21915: CALL_OW 1
21919: ST_TO_ADDR
// end ;
21920: LD_VAR 0 2
21924: RET
// export function MC_Add ( side , units ) ; var base ; begin
21925: LD_INT 0
21927: PPUSH
21928: PPUSH
// base := mc_bases + 1 ;
21929: LD_ADDR_VAR 0 4
21933: PUSH
21934: LD_EXP 90
21938: PUSH
21939: LD_INT 1
21941: PLUS
21942: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21943: LD_ADDR_EXP 116
21947: PUSH
21948: LD_EXP 116
21952: PPUSH
21953: LD_VAR 0 4
21957: PPUSH
21958: LD_VAR 0 1
21962: PPUSH
21963: CALL_OW 1
21967: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21968: LD_ADDR_EXP 90
21972: PUSH
21973: LD_EXP 90
21977: PPUSH
21978: LD_VAR 0 4
21982: PPUSH
21983: LD_VAR 0 2
21987: PPUSH
21988: CALL_OW 1
21992: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21993: LD_ADDR_EXP 91
21997: PUSH
21998: LD_EXP 91
22002: PPUSH
22003: LD_VAR 0 4
22007: PPUSH
22008: EMPTY
22009: PPUSH
22010: CALL_OW 1
22014: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22015: LD_ADDR_EXP 92
22019: PUSH
22020: LD_EXP 92
22024: PPUSH
22025: LD_VAR 0 4
22029: PPUSH
22030: EMPTY
22031: PPUSH
22032: CALL_OW 1
22036: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22037: LD_ADDR_EXP 93
22041: PUSH
22042: LD_EXP 93
22046: PPUSH
22047: LD_VAR 0 4
22051: PPUSH
22052: EMPTY
22053: PPUSH
22054: CALL_OW 1
22058: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22059: LD_ADDR_EXP 94
22063: PUSH
22064: LD_EXP 94
22068: PPUSH
22069: LD_VAR 0 4
22073: PPUSH
22074: EMPTY
22075: PPUSH
22076: CALL_OW 1
22080: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22081: LD_ADDR_EXP 95
22085: PUSH
22086: LD_EXP 95
22090: PPUSH
22091: LD_VAR 0 4
22095: PPUSH
22096: EMPTY
22097: PPUSH
22098: CALL_OW 1
22102: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22103: LD_ADDR_EXP 96
22107: PUSH
22108: LD_EXP 96
22112: PPUSH
22113: LD_VAR 0 4
22117: PPUSH
22118: EMPTY
22119: PPUSH
22120: CALL_OW 1
22124: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22125: LD_ADDR_EXP 97
22129: PUSH
22130: LD_EXP 97
22134: PPUSH
22135: LD_VAR 0 4
22139: PPUSH
22140: EMPTY
22141: PPUSH
22142: CALL_OW 1
22146: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22147: LD_ADDR_EXP 98
22151: PUSH
22152: LD_EXP 98
22156: PPUSH
22157: LD_VAR 0 4
22161: PPUSH
22162: EMPTY
22163: PPUSH
22164: CALL_OW 1
22168: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22169: LD_ADDR_EXP 99
22173: PUSH
22174: LD_EXP 99
22178: PPUSH
22179: LD_VAR 0 4
22183: PPUSH
22184: EMPTY
22185: PPUSH
22186: CALL_OW 1
22190: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22191: LD_ADDR_EXP 100
22195: PUSH
22196: LD_EXP 100
22200: PPUSH
22201: LD_VAR 0 4
22205: PPUSH
22206: EMPTY
22207: PPUSH
22208: CALL_OW 1
22212: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22213: LD_ADDR_EXP 101
22217: PUSH
22218: LD_EXP 101
22222: PPUSH
22223: LD_VAR 0 4
22227: PPUSH
22228: LD_INT 0
22230: PPUSH
22231: CALL_OW 1
22235: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22236: LD_ADDR_EXP 102
22240: PUSH
22241: LD_EXP 102
22245: PPUSH
22246: LD_VAR 0 4
22250: PPUSH
22251: EMPTY
22252: PPUSH
22253: CALL_OW 1
22257: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22258: LD_ADDR_EXP 103
22262: PUSH
22263: LD_EXP 103
22267: PPUSH
22268: LD_VAR 0 4
22272: PPUSH
22273: EMPTY
22274: PPUSH
22275: CALL_OW 1
22279: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22280: LD_ADDR_EXP 104
22284: PUSH
22285: LD_EXP 104
22289: PPUSH
22290: LD_VAR 0 4
22294: PPUSH
22295: EMPTY
22296: PPUSH
22297: CALL_OW 1
22301: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22302: LD_ADDR_EXP 105
22306: PUSH
22307: LD_EXP 105
22311: PPUSH
22312: LD_VAR 0 4
22316: PPUSH
22317: EMPTY
22318: PPUSH
22319: CALL_OW 1
22323: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22324: LD_ADDR_EXP 106
22328: PUSH
22329: LD_EXP 106
22333: PPUSH
22334: LD_VAR 0 4
22338: PPUSH
22339: EMPTY
22340: PPUSH
22341: CALL_OW 1
22345: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22346: LD_ADDR_EXP 107
22350: PUSH
22351: LD_EXP 107
22355: PPUSH
22356: LD_VAR 0 4
22360: PPUSH
22361: EMPTY
22362: PPUSH
22363: CALL_OW 1
22367: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22368: LD_ADDR_EXP 108
22372: PUSH
22373: LD_EXP 108
22377: PPUSH
22378: LD_VAR 0 4
22382: PPUSH
22383: EMPTY
22384: PPUSH
22385: CALL_OW 1
22389: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22390: LD_ADDR_EXP 109
22394: PUSH
22395: LD_EXP 109
22399: PPUSH
22400: LD_VAR 0 4
22404: PPUSH
22405: EMPTY
22406: PPUSH
22407: CALL_OW 1
22411: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22412: LD_ADDR_EXP 110
22416: PUSH
22417: LD_EXP 110
22421: PPUSH
22422: LD_VAR 0 4
22426: PPUSH
22427: EMPTY
22428: PPUSH
22429: CALL_OW 1
22433: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22434: LD_ADDR_EXP 111
22438: PUSH
22439: LD_EXP 111
22443: PPUSH
22444: LD_VAR 0 4
22448: PPUSH
22449: EMPTY
22450: PPUSH
22451: CALL_OW 1
22455: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22456: LD_ADDR_EXP 112
22460: PUSH
22461: LD_EXP 112
22465: PPUSH
22466: LD_VAR 0 4
22470: PPUSH
22471: EMPTY
22472: PPUSH
22473: CALL_OW 1
22477: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22478: LD_ADDR_EXP 113
22482: PUSH
22483: LD_EXP 113
22487: PPUSH
22488: LD_VAR 0 4
22492: PPUSH
22493: EMPTY
22494: PPUSH
22495: CALL_OW 1
22499: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22500: LD_ADDR_EXP 114
22504: PUSH
22505: LD_EXP 114
22509: PPUSH
22510: LD_VAR 0 4
22514: PPUSH
22515: EMPTY
22516: PPUSH
22517: CALL_OW 1
22521: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22522: LD_ADDR_EXP 115
22526: PUSH
22527: LD_EXP 115
22531: PPUSH
22532: LD_VAR 0 4
22536: PPUSH
22537: EMPTY
22538: PPUSH
22539: CALL_OW 1
22543: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22544: LD_ADDR_EXP 117
22548: PUSH
22549: LD_EXP 117
22553: PPUSH
22554: LD_VAR 0 4
22558: PPUSH
22559: EMPTY
22560: PPUSH
22561: CALL_OW 1
22565: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22566: LD_ADDR_EXP 119
22570: PUSH
22571: LD_EXP 119
22575: PPUSH
22576: LD_VAR 0 4
22580: PPUSH
22581: EMPTY
22582: PPUSH
22583: CALL_OW 1
22587: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22588: LD_ADDR_EXP 120
22592: PUSH
22593: LD_EXP 120
22597: PPUSH
22598: LD_VAR 0 4
22602: PPUSH
22603: EMPTY
22604: PPUSH
22605: CALL_OW 1
22609: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22610: LD_ADDR_EXP 121
22614: PUSH
22615: LD_EXP 121
22619: PPUSH
22620: LD_VAR 0 4
22624: PPUSH
22625: EMPTY
22626: PPUSH
22627: CALL_OW 1
22631: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22632: LD_ADDR_EXP 122
22636: PUSH
22637: LD_EXP 122
22641: PPUSH
22642: LD_VAR 0 4
22646: PPUSH
22647: EMPTY
22648: PPUSH
22649: CALL_OW 1
22653: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22654: LD_ADDR_EXP 123
22658: PUSH
22659: LD_EXP 123
22663: PPUSH
22664: LD_VAR 0 4
22668: PPUSH
22669: EMPTY
22670: PPUSH
22671: CALL_OW 1
22675: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22676: LD_ADDR_EXP 124
22680: PUSH
22681: LD_EXP 124
22685: PPUSH
22686: LD_VAR 0 4
22690: PPUSH
22691: EMPTY
22692: PPUSH
22693: CALL_OW 1
22697: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22698: LD_ADDR_EXP 125
22702: PUSH
22703: LD_EXP 125
22707: PPUSH
22708: LD_VAR 0 4
22712: PPUSH
22713: EMPTY
22714: PPUSH
22715: CALL_OW 1
22719: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22720: LD_ADDR_EXP 126
22724: PUSH
22725: LD_EXP 126
22729: PPUSH
22730: LD_VAR 0 4
22734: PPUSH
22735: EMPTY
22736: PPUSH
22737: CALL_OW 1
22741: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22742: LD_ADDR_EXP 127
22746: PUSH
22747: LD_EXP 127
22751: PPUSH
22752: LD_VAR 0 4
22756: PPUSH
22757: EMPTY
22758: PPUSH
22759: CALL_OW 1
22763: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22764: LD_ADDR_EXP 128
22768: PUSH
22769: LD_EXP 128
22773: PPUSH
22774: LD_VAR 0 4
22778: PPUSH
22779: EMPTY
22780: PPUSH
22781: CALL_OW 1
22785: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22786: LD_ADDR_EXP 129
22790: PUSH
22791: LD_EXP 129
22795: PPUSH
22796: LD_VAR 0 4
22800: PPUSH
22801: EMPTY
22802: PPUSH
22803: CALL_OW 1
22807: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22808: LD_ADDR_EXP 130
22812: PUSH
22813: LD_EXP 130
22817: PPUSH
22818: LD_VAR 0 4
22822: PPUSH
22823: EMPTY
22824: PPUSH
22825: CALL_OW 1
22829: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22830: LD_ADDR_EXP 131
22834: PUSH
22835: LD_EXP 131
22839: PPUSH
22840: LD_VAR 0 4
22844: PPUSH
22845: EMPTY
22846: PPUSH
22847: CALL_OW 1
22851: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22852: LD_ADDR_EXP 132
22856: PUSH
22857: LD_EXP 132
22861: PPUSH
22862: LD_VAR 0 4
22866: PPUSH
22867: LD_INT 0
22869: PPUSH
22870: CALL_OW 1
22874: ST_TO_ADDR
// result := base ;
22875: LD_ADDR_VAR 0 3
22879: PUSH
22880: LD_VAR 0 4
22884: ST_TO_ADDR
// end ;
22885: LD_VAR 0 3
22889: RET
// export function MC_Start ( ) ; var i ; begin
22890: LD_INT 0
22892: PPUSH
22893: PPUSH
// for i = 1 to mc_bases do
22894: LD_ADDR_VAR 0 2
22898: PUSH
22899: DOUBLE
22900: LD_INT 1
22902: DEC
22903: ST_TO_ADDR
22904: LD_EXP 90
22908: PUSH
22909: FOR_TO
22910: IFFALSE 23987
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22912: LD_ADDR_EXP 90
22916: PUSH
22917: LD_EXP 90
22921: PPUSH
22922: LD_VAR 0 2
22926: PPUSH
22927: LD_EXP 90
22931: PUSH
22932: LD_VAR 0 2
22936: ARRAY
22937: PUSH
22938: LD_INT 0
22940: DIFF
22941: PPUSH
22942: CALL_OW 1
22946: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22947: LD_ADDR_EXP 91
22951: PUSH
22952: LD_EXP 91
22956: PPUSH
22957: LD_VAR 0 2
22961: PPUSH
22962: EMPTY
22963: PPUSH
22964: CALL_OW 1
22968: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22969: LD_ADDR_EXP 92
22973: PUSH
22974: LD_EXP 92
22978: PPUSH
22979: LD_VAR 0 2
22983: PPUSH
22984: EMPTY
22985: PPUSH
22986: CALL_OW 1
22990: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22991: LD_ADDR_EXP 93
22995: PUSH
22996: LD_EXP 93
23000: PPUSH
23001: LD_VAR 0 2
23005: PPUSH
23006: EMPTY
23007: PPUSH
23008: CALL_OW 1
23012: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23013: LD_ADDR_EXP 94
23017: PUSH
23018: LD_EXP 94
23022: PPUSH
23023: LD_VAR 0 2
23027: PPUSH
23028: EMPTY
23029: PUSH
23030: EMPTY
23031: PUSH
23032: EMPTY
23033: LIST
23034: LIST
23035: PPUSH
23036: CALL_OW 1
23040: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23041: LD_ADDR_EXP 95
23045: PUSH
23046: LD_EXP 95
23050: PPUSH
23051: LD_VAR 0 2
23055: PPUSH
23056: EMPTY
23057: PPUSH
23058: CALL_OW 1
23062: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23063: LD_ADDR_EXP 122
23067: PUSH
23068: LD_EXP 122
23072: PPUSH
23073: LD_VAR 0 2
23077: PPUSH
23078: EMPTY
23079: PPUSH
23080: CALL_OW 1
23084: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23085: LD_ADDR_EXP 96
23089: PUSH
23090: LD_EXP 96
23094: PPUSH
23095: LD_VAR 0 2
23099: PPUSH
23100: EMPTY
23101: PPUSH
23102: CALL_OW 1
23106: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23107: LD_ADDR_EXP 97
23111: PUSH
23112: LD_EXP 97
23116: PPUSH
23117: LD_VAR 0 2
23121: PPUSH
23122: EMPTY
23123: PPUSH
23124: CALL_OW 1
23128: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23129: LD_ADDR_EXP 98
23133: PUSH
23134: LD_EXP 98
23138: PPUSH
23139: LD_VAR 0 2
23143: PPUSH
23144: LD_EXP 90
23148: PUSH
23149: LD_VAR 0 2
23153: ARRAY
23154: PPUSH
23155: LD_INT 2
23157: PUSH
23158: LD_INT 30
23160: PUSH
23161: LD_INT 32
23163: PUSH
23164: EMPTY
23165: LIST
23166: LIST
23167: PUSH
23168: LD_INT 30
23170: PUSH
23171: LD_INT 33
23173: PUSH
23174: EMPTY
23175: LIST
23176: LIST
23177: PUSH
23178: EMPTY
23179: LIST
23180: LIST
23181: LIST
23182: PPUSH
23183: CALL_OW 72
23187: PPUSH
23188: CALL_OW 1
23192: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23193: LD_ADDR_EXP 99
23197: PUSH
23198: LD_EXP 99
23202: PPUSH
23203: LD_VAR 0 2
23207: PPUSH
23208: LD_EXP 90
23212: PUSH
23213: LD_VAR 0 2
23217: ARRAY
23218: PPUSH
23219: LD_INT 2
23221: PUSH
23222: LD_INT 30
23224: PUSH
23225: LD_INT 32
23227: PUSH
23228: EMPTY
23229: LIST
23230: LIST
23231: PUSH
23232: LD_INT 30
23234: PUSH
23235: LD_INT 31
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: PUSH
23242: EMPTY
23243: LIST
23244: LIST
23245: LIST
23246: PUSH
23247: LD_INT 58
23249: PUSH
23250: EMPTY
23251: LIST
23252: PUSH
23253: EMPTY
23254: LIST
23255: LIST
23256: PPUSH
23257: CALL_OW 72
23261: PPUSH
23262: CALL_OW 1
23266: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23267: LD_ADDR_EXP 100
23271: PUSH
23272: LD_EXP 100
23276: PPUSH
23277: LD_VAR 0 2
23281: PPUSH
23282: EMPTY
23283: PPUSH
23284: CALL_OW 1
23288: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23289: LD_ADDR_EXP 104
23293: PUSH
23294: LD_EXP 104
23298: PPUSH
23299: LD_VAR 0 2
23303: PPUSH
23304: EMPTY
23305: PPUSH
23306: CALL_OW 1
23310: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23311: LD_ADDR_EXP 103
23315: PUSH
23316: LD_EXP 103
23320: PPUSH
23321: LD_VAR 0 2
23325: PPUSH
23326: EMPTY
23327: PPUSH
23328: CALL_OW 1
23332: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23333: LD_ADDR_EXP 105
23337: PUSH
23338: LD_EXP 105
23342: PPUSH
23343: LD_VAR 0 2
23347: PPUSH
23348: EMPTY
23349: PPUSH
23350: CALL_OW 1
23354: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23355: LD_ADDR_EXP 106
23359: PUSH
23360: LD_EXP 106
23364: PPUSH
23365: LD_VAR 0 2
23369: PPUSH
23370: EMPTY
23371: PPUSH
23372: CALL_OW 1
23376: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23377: LD_ADDR_EXP 107
23381: PUSH
23382: LD_EXP 107
23386: PPUSH
23387: LD_VAR 0 2
23391: PPUSH
23392: EMPTY
23393: PPUSH
23394: CALL_OW 1
23398: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23399: LD_ADDR_EXP 108
23403: PUSH
23404: LD_EXP 108
23408: PPUSH
23409: LD_VAR 0 2
23413: PPUSH
23414: EMPTY
23415: PPUSH
23416: CALL_OW 1
23420: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23421: LD_ADDR_EXP 109
23425: PUSH
23426: LD_EXP 109
23430: PPUSH
23431: LD_VAR 0 2
23435: PPUSH
23436: EMPTY
23437: PPUSH
23438: CALL_OW 1
23442: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23443: LD_ADDR_EXP 110
23447: PUSH
23448: LD_EXP 110
23452: PPUSH
23453: LD_VAR 0 2
23457: PPUSH
23458: EMPTY
23459: PPUSH
23460: CALL_OW 1
23464: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23465: LD_ADDR_EXP 111
23469: PUSH
23470: LD_EXP 111
23474: PPUSH
23475: LD_VAR 0 2
23479: PPUSH
23480: EMPTY
23481: PPUSH
23482: CALL_OW 1
23486: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23487: LD_ADDR_EXP 112
23491: PUSH
23492: LD_EXP 112
23496: PPUSH
23497: LD_VAR 0 2
23501: PPUSH
23502: EMPTY
23503: PPUSH
23504: CALL_OW 1
23508: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23509: LD_ADDR_EXP 101
23513: PUSH
23514: LD_EXP 101
23518: PPUSH
23519: LD_VAR 0 2
23523: PPUSH
23524: LD_INT 0
23526: PPUSH
23527: CALL_OW 1
23531: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23532: LD_ADDR_EXP 114
23536: PUSH
23537: LD_EXP 114
23541: PPUSH
23542: LD_VAR 0 2
23546: PPUSH
23547: LD_INT 0
23549: PPUSH
23550: CALL_OW 1
23554: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23555: LD_ADDR_EXP 102
23559: PUSH
23560: LD_EXP 102
23564: PPUSH
23565: LD_VAR 0 2
23569: PPUSH
23570: EMPTY
23571: PPUSH
23572: CALL_OW 1
23576: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23577: LD_ADDR_EXP 113
23581: PUSH
23582: LD_EXP 113
23586: PPUSH
23587: LD_VAR 0 2
23591: PPUSH
23592: LD_INT 0
23594: PPUSH
23595: CALL_OW 1
23599: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23600: LD_ADDR_EXP 115
23604: PUSH
23605: LD_EXP 115
23609: PPUSH
23610: LD_VAR 0 2
23614: PPUSH
23615: EMPTY
23616: PPUSH
23617: CALL_OW 1
23621: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23622: LD_ADDR_EXP 118
23626: PUSH
23627: LD_EXP 118
23631: PPUSH
23632: LD_VAR 0 2
23636: PPUSH
23637: LD_INT 0
23639: PPUSH
23640: CALL_OW 1
23644: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23645: LD_ADDR_EXP 119
23649: PUSH
23650: LD_EXP 119
23654: PPUSH
23655: LD_VAR 0 2
23659: PPUSH
23660: EMPTY
23661: PPUSH
23662: CALL_OW 1
23666: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23667: LD_ADDR_EXP 120
23671: PUSH
23672: LD_EXP 120
23676: PPUSH
23677: LD_VAR 0 2
23681: PPUSH
23682: EMPTY
23683: PPUSH
23684: CALL_OW 1
23688: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23689: LD_ADDR_EXP 121
23693: PUSH
23694: LD_EXP 121
23698: PPUSH
23699: LD_VAR 0 2
23703: PPUSH
23704: EMPTY
23705: PPUSH
23706: CALL_OW 1
23710: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23711: LD_ADDR_EXP 123
23715: PUSH
23716: LD_EXP 123
23720: PPUSH
23721: LD_VAR 0 2
23725: PPUSH
23726: LD_EXP 90
23730: PUSH
23731: LD_VAR 0 2
23735: ARRAY
23736: PPUSH
23737: LD_INT 2
23739: PUSH
23740: LD_INT 30
23742: PUSH
23743: LD_INT 6
23745: PUSH
23746: EMPTY
23747: LIST
23748: LIST
23749: PUSH
23750: LD_INT 30
23752: PUSH
23753: LD_INT 7
23755: PUSH
23756: EMPTY
23757: LIST
23758: LIST
23759: PUSH
23760: LD_INT 30
23762: PUSH
23763: LD_INT 8
23765: PUSH
23766: EMPTY
23767: LIST
23768: LIST
23769: PUSH
23770: EMPTY
23771: LIST
23772: LIST
23773: LIST
23774: LIST
23775: PPUSH
23776: CALL_OW 72
23780: PPUSH
23781: CALL_OW 1
23785: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23786: LD_ADDR_EXP 124
23790: PUSH
23791: LD_EXP 124
23795: PPUSH
23796: LD_VAR 0 2
23800: PPUSH
23801: EMPTY
23802: PPUSH
23803: CALL_OW 1
23807: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23808: LD_ADDR_EXP 125
23812: PUSH
23813: LD_EXP 125
23817: PPUSH
23818: LD_VAR 0 2
23822: PPUSH
23823: EMPTY
23824: PPUSH
23825: CALL_OW 1
23829: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23830: LD_ADDR_EXP 126
23834: PUSH
23835: LD_EXP 126
23839: PPUSH
23840: LD_VAR 0 2
23844: PPUSH
23845: EMPTY
23846: PPUSH
23847: CALL_OW 1
23851: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23852: LD_ADDR_EXP 127
23856: PUSH
23857: LD_EXP 127
23861: PPUSH
23862: LD_VAR 0 2
23866: PPUSH
23867: EMPTY
23868: PPUSH
23869: CALL_OW 1
23873: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23874: LD_ADDR_EXP 128
23878: PUSH
23879: LD_EXP 128
23883: PPUSH
23884: LD_VAR 0 2
23888: PPUSH
23889: EMPTY
23890: PPUSH
23891: CALL_OW 1
23895: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23896: LD_ADDR_EXP 129
23900: PUSH
23901: LD_EXP 129
23905: PPUSH
23906: LD_VAR 0 2
23910: PPUSH
23911: EMPTY
23912: PPUSH
23913: CALL_OW 1
23917: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23918: LD_ADDR_EXP 130
23922: PUSH
23923: LD_EXP 130
23927: PPUSH
23928: LD_VAR 0 2
23932: PPUSH
23933: EMPTY
23934: PPUSH
23935: CALL_OW 1
23939: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23940: LD_ADDR_EXP 131
23944: PUSH
23945: LD_EXP 131
23949: PPUSH
23950: LD_VAR 0 2
23954: PPUSH
23955: EMPTY
23956: PPUSH
23957: CALL_OW 1
23961: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23962: LD_ADDR_EXP 132
23966: PUSH
23967: LD_EXP 132
23971: PPUSH
23972: LD_VAR 0 2
23976: PPUSH
23977: LD_INT 0
23979: PPUSH
23980: CALL_OW 1
23984: ST_TO_ADDR
// end ;
23985: GO 22909
23987: POP
23988: POP
// MC_InitSides ( ) ;
23989: CALL 24275 0 0
// MC_InitResearch ( ) ;
23993: CALL 24014 0 0
// CustomInitMacro ( ) ;
23997: CALL 217 0 0
// skirmish := true ;
24001: LD_ADDR_EXP 88
24005: PUSH
24006: LD_INT 1
24008: ST_TO_ADDR
// end ;
24009: LD_VAR 0 1
24013: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24014: LD_INT 0
24016: PPUSH
24017: PPUSH
24018: PPUSH
24019: PPUSH
24020: PPUSH
24021: PPUSH
// if not mc_bases then
24022: LD_EXP 90
24026: NOT
24027: IFFALSE 24031
// exit ;
24029: GO 24270
// for i = 1 to 8 do
24031: LD_ADDR_VAR 0 2
24035: PUSH
24036: DOUBLE
24037: LD_INT 1
24039: DEC
24040: ST_TO_ADDR
24041: LD_INT 8
24043: PUSH
24044: FOR_TO
24045: IFFALSE 24071
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24047: LD_ADDR_EXP 117
24051: PUSH
24052: LD_EXP 117
24056: PPUSH
24057: LD_VAR 0 2
24061: PPUSH
24062: EMPTY
24063: PPUSH
24064: CALL_OW 1
24068: ST_TO_ADDR
24069: GO 24044
24071: POP
24072: POP
// tmp := [ ] ;
24073: LD_ADDR_VAR 0 5
24077: PUSH
24078: EMPTY
24079: ST_TO_ADDR
// for i = 1 to mc_sides do
24080: LD_ADDR_VAR 0 2
24084: PUSH
24085: DOUBLE
24086: LD_INT 1
24088: DEC
24089: ST_TO_ADDR
24090: LD_EXP 116
24094: PUSH
24095: FOR_TO
24096: IFFALSE 24154
// if not mc_sides [ i ] in tmp then
24098: LD_EXP 116
24102: PUSH
24103: LD_VAR 0 2
24107: ARRAY
24108: PUSH
24109: LD_VAR 0 5
24113: IN
24114: NOT
24115: IFFALSE 24152
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24117: LD_ADDR_VAR 0 5
24121: PUSH
24122: LD_VAR 0 5
24126: PPUSH
24127: LD_VAR 0 5
24131: PUSH
24132: LD_INT 1
24134: PLUS
24135: PPUSH
24136: LD_EXP 116
24140: PUSH
24141: LD_VAR 0 2
24145: ARRAY
24146: PPUSH
24147: CALL_OW 2
24151: ST_TO_ADDR
24152: GO 24095
24154: POP
24155: POP
// if not tmp then
24156: LD_VAR 0 5
24160: NOT
24161: IFFALSE 24165
// exit ;
24163: GO 24270
// for j in tmp do
24165: LD_ADDR_VAR 0 3
24169: PUSH
24170: LD_VAR 0 5
24174: PUSH
24175: FOR_IN
24176: IFFALSE 24268
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24178: LD_ADDR_VAR 0 6
24182: PUSH
24183: LD_INT 22
24185: PUSH
24186: LD_VAR 0 3
24190: PUSH
24191: EMPTY
24192: LIST
24193: LIST
24194: PPUSH
24195: CALL_OW 69
24199: ST_TO_ADDR
// if not un then
24200: LD_VAR 0 6
24204: NOT
24205: IFFALSE 24209
// continue ;
24207: GO 24175
// nation := GetNation ( un [ 1 ] ) ;
24209: LD_ADDR_VAR 0 4
24213: PUSH
24214: LD_VAR 0 6
24218: PUSH
24219: LD_INT 1
24221: ARRAY
24222: PPUSH
24223: CALL_OW 248
24227: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24228: LD_ADDR_EXP 117
24232: PUSH
24233: LD_EXP 117
24237: PPUSH
24238: LD_VAR 0 3
24242: PPUSH
24243: LD_VAR 0 3
24247: PPUSH
24248: LD_VAR 0 4
24252: PPUSH
24253: LD_INT 1
24255: PPUSH
24256: CALL 50952 0 3
24260: PPUSH
24261: CALL_OW 1
24265: ST_TO_ADDR
// end ;
24266: GO 24175
24268: POP
24269: POP
// end ;
24270: LD_VAR 0 1
24274: RET
// export function MC_InitSides ( ) ; var i ; begin
24275: LD_INT 0
24277: PPUSH
24278: PPUSH
// if not mc_bases then
24279: LD_EXP 90
24283: NOT
24284: IFFALSE 24288
// exit ;
24286: GO 24362
// for i = 1 to mc_bases do
24288: LD_ADDR_VAR 0 2
24292: PUSH
24293: DOUBLE
24294: LD_INT 1
24296: DEC
24297: ST_TO_ADDR
24298: LD_EXP 90
24302: PUSH
24303: FOR_TO
24304: IFFALSE 24360
// if mc_bases [ i ] then
24306: LD_EXP 90
24310: PUSH
24311: LD_VAR 0 2
24315: ARRAY
24316: IFFALSE 24358
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24318: LD_ADDR_EXP 116
24322: PUSH
24323: LD_EXP 116
24327: PPUSH
24328: LD_VAR 0 2
24332: PPUSH
24333: LD_EXP 90
24337: PUSH
24338: LD_VAR 0 2
24342: ARRAY
24343: PUSH
24344: LD_INT 1
24346: ARRAY
24347: PPUSH
24348: CALL_OW 255
24352: PPUSH
24353: CALL_OW 1
24357: ST_TO_ADDR
24358: GO 24303
24360: POP
24361: POP
// end ;
24362: LD_VAR 0 1
24366: RET
// every 0 0$03 trigger skirmish do
24367: LD_EXP 88
24371: IFFALSE 24525
24373: GO 24375
24375: DISABLE
// begin enable ;
24376: ENABLE
// MC_CheckBuildings ( ) ;
24377: CALL 29023 0 0
// MC_CheckPeopleLife ( ) ;
24381: CALL 29148 0 0
// RaiseSailEvent ( 100 ) ;
24385: LD_INT 100
24387: PPUSH
24388: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24392: LD_INT 103
24394: PPUSH
24395: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24399: LD_INT 104
24401: PPUSH
24402: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24406: LD_INT 105
24408: PPUSH
24409: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24413: LD_INT 106
24415: PPUSH
24416: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24420: LD_INT 107
24422: PPUSH
24423: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24427: LD_INT 108
24429: PPUSH
24430: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24434: LD_INT 109
24436: PPUSH
24437: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24441: LD_INT 110
24443: PPUSH
24444: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24448: LD_INT 111
24450: PPUSH
24451: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24455: LD_INT 112
24457: PPUSH
24458: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24462: LD_INT 113
24464: PPUSH
24465: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24469: LD_INT 120
24471: PPUSH
24472: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24476: LD_INT 121
24478: PPUSH
24479: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24483: LD_INT 122
24485: PPUSH
24486: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24490: LD_INT 123
24492: PPUSH
24493: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24497: LD_INT 124
24499: PPUSH
24500: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24504: LD_INT 125
24506: PPUSH
24507: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24511: LD_INT 126
24513: PPUSH
24514: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24518: LD_INT 200
24520: PPUSH
24521: CALL_OW 427
// end ;
24525: END
// on SailEvent ( event ) do begin if event < 100 then
24526: LD_VAR 0 1
24530: PUSH
24531: LD_INT 100
24533: LESS
24534: IFFALSE 24545
// CustomEvent ( event ) ;
24536: LD_VAR 0 1
24540: PPUSH
24541: CALL 10417 0 1
// if event = 100 then
24545: LD_VAR 0 1
24549: PUSH
24550: LD_INT 100
24552: EQUAL
24553: IFFALSE 24559
// MC_ClassManager ( ) ;
24555: CALL 24951 0 0
// if event = 101 then
24559: LD_VAR 0 1
24563: PUSH
24564: LD_INT 101
24566: EQUAL
24567: IFFALSE 24573
// MC_RepairBuildings ( ) ;
24569: CALL 29733 0 0
// if event = 102 then
24573: LD_VAR 0 1
24577: PUSH
24578: LD_INT 102
24580: EQUAL
24581: IFFALSE 24587
// MC_Heal ( ) ;
24583: CALL 30618 0 0
// if event = 103 then
24587: LD_VAR 0 1
24591: PUSH
24592: LD_INT 103
24594: EQUAL
24595: IFFALSE 24601
// MC_Build ( ) ;
24597: CALL 31040 0 0
// if event = 104 then
24601: LD_VAR 0 1
24605: PUSH
24606: LD_INT 104
24608: EQUAL
24609: IFFALSE 24615
// MC_TurretWeapon ( ) ;
24611: CALL 32681 0 0
// if event = 105 then
24615: LD_VAR 0 1
24619: PUSH
24620: LD_INT 105
24622: EQUAL
24623: IFFALSE 24629
// MC_BuildUpgrade ( ) ;
24625: CALL 32232 0 0
// if event = 106 then
24629: LD_VAR 0 1
24633: PUSH
24634: LD_INT 106
24636: EQUAL
24637: IFFALSE 24643
// MC_PlantMines ( ) ;
24639: CALL 33111 0 0
// if event = 107 then
24643: LD_VAR 0 1
24647: PUSH
24648: LD_INT 107
24650: EQUAL
24651: IFFALSE 24657
// MC_CollectCrates ( ) ;
24653: CALL 33902 0 0
// if event = 108 then
24657: LD_VAR 0 1
24661: PUSH
24662: LD_INT 108
24664: EQUAL
24665: IFFALSE 24671
// MC_LinkRemoteControl ( ) ;
24667: CALL 35678 0 0
// if event = 109 then
24671: LD_VAR 0 1
24675: PUSH
24676: LD_INT 109
24678: EQUAL
24679: IFFALSE 24685
// MC_ProduceVehicle ( ) ;
24681: CALL 35859 0 0
// if event = 110 then
24685: LD_VAR 0 1
24689: PUSH
24690: LD_INT 110
24692: EQUAL
24693: IFFALSE 24699
// MC_SendAttack ( ) ;
24695: CALL 36325 0 0
// if event = 111 then
24699: LD_VAR 0 1
24703: PUSH
24704: LD_INT 111
24706: EQUAL
24707: IFFALSE 24713
// MC_Defend ( ) ;
24709: CALL 36433 0 0
// if event = 112 then
24713: LD_VAR 0 1
24717: PUSH
24718: LD_INT 112
24720: EQUAL
24721: IFFALSE 24727
// MC_Research ( ) ;
24723: CALL 37060 0 0
// if event = 113 then
24727: LD_VAR 0 1
24731: PUSH
24732: LD_INT 113
24734: EQUAL
24735: IFFALSE 24741
// MC_MinesTrigger ( ) ;
24737: CALL 38174 0 0
// if event = 120 then
24741: LD_VAR 0 1
24745: PUSH
24746: LD_INT 120
24748: EQUAL
24749: IFFALSE 24755
// MC_RepairVehicle ( ) ;
24751: CALL 38273 0 0
// if event = 121 then
24755: LD_VAR 0 1
24759: PUSH
24760: LD_INT 121
24762: EQUAL
24763: IFFALSE 24769
// MC_TameApe ( ) ;
24765: CALL 39003 0 0
// if event = 122 then
24769: LD_VAR 0 1
24773: PUSH
24774: LD_INT 122
24776: EQUAL
24777: IFFALSE 24783
// MC_ChangeApeClass ( ) ;
24779: CALL 39832 0 0
// if event = 123 then
24783: LD_VAR 0 1
24787: PUSH
24788: LD_INT 123
24790: EQUAL
24791: IFFALSE 24797
// MC_Bazooka ( ) ;
24793: CALL 40482 0 0
// if event = 124 then
24797: LD_VAR 0 1
24801: PUSH
24802: LD_INT 124
24804: EQUAL
24805: IFFALSE 24811
// MC_TeleportExit ( ) ;
24807: CALL 40680 0 0
// if event = 125 then
24811: LD_VAR 0 1
24815: PUSH
24816: LD_INT 125
24818: EQUAL
24819: IFFALSE 24825
// MC_Deposits ( ) ;
24821: CALL 41327 0 0
// if event = 126 then
24825: LD_VAR 0 1
24829: PUSH
24830: LD_INT 126
24832: EQUAL
24833: IFFALSE 24839
// MC_RemoteDriver ( ) ;
24835: CALL 41952 0 0
// if event = 200 then
24839: LD_VAR 0 1
24843: PUSH
24844: LD_INT 200
24846: EQUAL
24847: IFFALSE 24853
// MC_Idle ( ) ;
24849: CALL 43901 0 0
// end ;
24853: PPOPN 1
24855: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24856: LD_INT 0
24858: PPUSH
24859: PPUSH
// if not mc_bases [ base ] or not tag then
24860: LD_EXP 90
24864: PUSH
24865: LD_VAR 0 1
24869: ARRAY
24870: NOT
24871: PUSH
24872: LD_VAR 0 2
24876: NOT
24877: OR
24878: IFFALSE 24882
// exit ;
24880: GO 24946
// for i in mc_bases [ base ] union mc_ape [ base ] do
24882: LD_ADDR_VAR 0 4
24886: PUSH
24887: LD_EXP 90
24891: PUSH
24892: LD_VAR 0 1
24896: ARRAY
24897: PUSH
24898: LD_EXP 119
24902: PUSH
24903: LD_VAR 0 1
24907: ARRAY
24908: UNION
24909: PUSH
24910: FOR_IN
24911: IFFALSE 24944
// if GetTag ( i ) = tag then
24913: LD_VAR 0 4
24917: PPUSH
24918: CALL_OW 110
24922: PUSH
24923: LD_VAR 0 2
24927: EQUAL
24928: IFFALSE 24942
// SetTag ( i , 0 ) ;
24930: LD_VAR 0 4
24934: PPUSH
24935: LD_INT 0
24937: PPUSH
24938: CALL_OW 109
24942: GO 24910
24944: POP
24945: POP
// end ;
24946: LD_VAR 0 3
24950: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24951: LD_INT 0
24953: PPUSH
24954: PPUSH
24955: PPUSH
24956: PPUSH
24957: PPUSH
24958: PPUSH
24959: PPUSH
24960: PPUSH
// if not mc_bases then
24961: LD_EXP 90
24965: NOT
24966: IFFALSE 24970
// exit ;
24968: GO 25428
// for i = 1 to mc_bases do
24970: LD_ADDR_VAR 0 2
24974: PUSH
24975: DOUBLE
24976: LD_INT 1
24978: DEC
24979: ST_TO_ADDR
24980: LD_EXP 90
24984: PUSH
24985: FOR_TO
24986: IFFALSE 25426
// begin tmp := MC_ClassCheckReq ( i ) ;
24988: LD_ADDR_VAR 0 4
24992: PUSH
24993: LD_VAR 0 2
24997: PPUSH
24998: CALL 25433 0 1
25002: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25003: LD_ADDR_EXP 131
25007: PUSH
25008: LD_EXP 131
25012: PPUSH
25013: LD_VAR 0 2
25017: PPUSH
25018: LD_VAR 0 4
25022: PPUSH
25023: CALL_OW 1
25027: ST_TO_ADDR
// if not tmp then
25028: LD_VAR 0 4
25032: NOT
25033: IFFALSE 25037
// continue ;
25035: GO 24985
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25037: LD_ADDR_VAR 0 6
25041: PUSH
25042: LD_EXP 90
25046: PUSH
25047: LD_VAR 0 2
25051: ARRAY
25052: PPUSH
25053: LD_INT 2
25055: PUSH
25056: LD_INT 30
25058: PUSH
25059: LD_INT 4
25061: PUSH
25062: EMPTY
25063: LIST
25064: LIST
25065: PUSH
25066: LD_INT 30
25068: PUSH
25069: LD_INT 5
25071: PUSH
25072: EMPTY
25073: LIST
25074: LIST
25075: PUSH
25076: EMPTY
25077: LIST
25078: LIST
25079: LIST
25080: PPUSH
25081: CALL_OW 72
25085: PUSH
25086: LD_EXP 90
25090: PUSH
25091: LD_VAR 0 2
25095: ARRAY
25096: PPUSH
25097: LD_INT 2
25099: PUSH
25100: LD_INT 30
25102: PUSH
25103: LD_INT 0
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: PUSH
25110: LD_INT 30
25112: PUSH
25113: LD_INT 1
25115: PUSH
25116: EMPTY
25117: LIST
25118: LIST
25119: PUSH
25120: EMPTY
25121: LIST
25122: LIST
25123: LIST
25124: PPUSH
25125: CALL_OW 72
25129: PUSH
25130: LD_EXP 90
25134: PUSH
25135: LD_VAR 0 2
25139: ARRAY
25140: PPUSH
25141: LD_INT 30
25143: PUSH
25144: LD_INT 3
25146: PUSH
25147: EMPTY
25148: LIST
25149: LIST
25150: PPUSH
25151: CALL_OW 72
25155: PUSH
25156: LD_EXP 90
25160: PUSH
25161: LD_VAR 0 2
25165: ARRAY
25166: PPUSH
25167: LD_INT 2
25169: PUSH
25170: LD_INT 30
25172: PUSH
25173: LD_INT 6
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: PUSH
25180: LD_INT 30
25182: PUSH
25183: LD_INT 7
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: PUSH
25190: LD_INT 30
25192: PUSH
25193: LD_INT 8
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: LIST
25204: LIST
25205: PPUSH
25206: CALL_OW 72
25210: PUSH
25211: EMPTY
25212: LIST
25213: LIST
25214: LIST
25215: LIST
25216: ST_TO_ADDR
// for j = 1 to 4 do
25217: LD_ADDR_VAR 0 3
25221: PUSH
25222: DOUBLE
25223: LD_INT 1
25225: DEC
25226: ST_TO_ADDR
25227: LD_INT 4
25229: PUSH
25230: FOR_TO
25231: IFFALSE 25422
// begin if not tmp [ j ] then
25233: LD_VAR 0 4
25237: PUSH
25238: LD_VAR 0 3
25242: ARRAY
25243: NOT
25244: IFFALSE 25248
// continue ;
25246: GO 25230
// for p in tmp [ j ] do
25248: LD_ADDR_VAR 0 5
25252: PUSH
25253: LD_VAR 0 4
25257: PUSH
25258: LD_VAR 0 3
25262: ARRAY
25263: PUSH
25264: FOR_IN
25265: IFFALSE 25418
// begin if not b [ j ] then
25267: LD_VAR 0 6
25271: PUSH
25272: LD_VAR 0 3
25276: ARRAY
25277: NOT
25278: IFFALSE 25282
// break ;
25280: GO 25418
// e := 0 ;
25282: LD_ADDR_VAR 0 7
25286: PUSH
25287: LD_INT 0
25289: ST_TO_ADDR
// for k in b [ j ] do
25290: LD_ADDR_VAR 0 8
25294: PUSH
25295: LD_VAR 0 6
25299: PUSH
25300: LD_VAR 0 3
25304: ARRAY
25305: PUSH
25306: FOR_IN
25307: IFFALSE 25334
// if IsNotFull ( k ) then
25309: LD_VAR 0 8
25313: PPUSH
25314: CALL 53101 0 1
25318: IFFALSE 25332
// begin e := k ;
25320: LD_ADDR_VAR 0 7
25324: PUSH
25325: LD_VAR 0 8
25329: ST_TO_ADDR
// break ;
25330: GO 25334
// end ;
25332: GO 25306
25334: POP
25335: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25336: LD_VAR 0 7
25340: PUSH
25341: LD_VAR 0 5
25345: PPUSH
25346: LD_VAR 0 7
25350: PPUSH
25351: CALL 85854 0 2
25355: NOT
25356: AND
25357: IFFALSE 25416
// begin if IsInUnit ( p ) then
25359: LD_VAR 0 5
25363: PPUSH
25364: CALL_OW 310
25368: IFFALSE 25379
// ComExitBuilding ( p ) ;
25370: LD_VAR 0 5
25374: PPUSH
25375: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25379: LD_VAR 0 5
25383: PPUSH
25384: LD_VAR 0 7
25388: PPUSH
25389: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25393: LD_VAR 0 5
25397: PPUSH
25398: LD_VAR 0 3
25402: PPUSH
25403: CALL_OW 183
// AddComExitBuilding ( p ) ;
25407: LD_VAR 0 5
25411: PPUSH
25412: CALL_OW 182
// end ; end ;
25416: GO 25264
25418: POP
25419: POP
// end ;
25420: GO 25230
25422: POP
25423: POP
// end ;
25424: GO 24985
25426: POP
25427: POP
// end ;
25428: LD_VAR 0 1
25432: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25433: LD_INT 0
25435: PPUSH
25436: PPUSH
25437: PPUSH
25438: PPUSH
25439: PPUSH
25440: PPUSH
25441: PPUSH
25442: PPUSH
25443: PPUSH
25444: PPUSH
25445: PPUSH
25446: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25447: LD_VAR 0 1
25451: NOT
25452: PUSH
25453: LD_EXP 90
25457: PUSH
25458: LD_VAR 0 1
25462: ARRAY
25463: NOT
25464: OR
25465: PUSH
25466: LD_EXP 90
25470: PUSH
25471: LD_VAR 0 1
25475: ARRAY
25476: PPUSH
25477: LD_INT 2
25479: PUSH
25480: LD_INT 30
25482: PUSH
25483: LD_INT 0
25485: PUSH
25486: EMPTY
25487: LIST
25488: LIST
25489: PUSH
25490: LD_INT 30
25492: PUSH
25493: LD_INT 1
25495: PUSH
25496: EMPTY
25497: LIST
25498: LIST
25499: PUSH
25500: EMPTY
25501: LIST
25502: LIST
25503: LIST
25504: PPUSH
25505: CALL_OW 72
25509: NOT
25510: OR
25511: IFFALSE 25515
// exit ;
25513: GO 29018
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25515: LD_ADDR_VAR 0 4
25519: PUSH
25520: LD_EXP 90
25524: PUSH
25525: LD_VAR 0 1
25529: ARRAY
25530: PPUSH
25531: LD_INT 2
25533: PUSH
25534: LD_INT 25
25536: PUSH
25537: LD_INT 1
25539: PUSH
25540: EMPTY
25541: LIST
25542: LIST
25543: PUSH
25544: LD_INT 25
25546: PUSH
25547: LD_INT 2
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: PUSH
25554: LD_INT 25
25556: PUSH
25557: LD_INT 3
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: PUSH
25564: LD_INT 25
25566: PUSH
25567: LD_INT 4
25569: PUSH
25570: EMPTY
25571: LIST
25572: LIST
25573: PUSH
25574: LD_INT 25
25576: PUSH
25577: LD_INT 5
25579: PUSH
25580: EMPTY
25581: LIST
25582: LIST
25583: PUSH
25584: LD_INT 25
25586: PUSH
25587: LD_INT 8
25589: PUSH
25590: EMPTY
25591: LIST
25592: LIST
25593: PUSH
25594: LD_INT 25
25596: PUSH
25597: LD_INT 9
25599: PUSH
25600: EMPTY
25601: LIST
25602: LIST
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: LIST
25608: LIST
25609: LIST
25610: LIST
25611: LIST
25612: LIST
25613: PPUSH
25614: CALL_OW 72
25618: ST_TO_ADDR
// if not tmp then
25619: LD_VAR 0 4
25623: NOT
25624: IFFALSE 25628
// exit ;
25626: GO 29018
// for i in tmp do
25628: LD_ADDR_VAR 0 3
25632: PUSH
25633: LD_VAR 0 4
25637: PUSH
25638: FOR_IN
25639: IFFALSE 25670
// if GetTag ( i ) then
25641: LD_VAR 0 3
25645: PPUSH
25646: CALL_OW 110
25650: IFFALSE 25668
// tmp := tmp diff i ;
25652: LD_ADDR_VAR 0 4
25656: PUSH
25657: LD_VAR 0 4
25661: PUSH
25662: LD_VAR 0 3
25666: DIFF
25667: ST_TO_ADDR
25668: GO 25638
25670: POP
25671: POP
// if not tmp then
25672: LD_VAR 0 4
25676: NOT
25677: IFFALSE 25681
// exit ;
25679: GO 29018
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25681: LD_ADDR_VAR 0 5
25685: PUSH
25686: LD_EXP 90
25690: PUSH
25691: LD_VAR 0 1
25695: ARRAY
25696: PPUSH
25697: LD_INT 2
25699: PUSH
25700: LD_INT 25
25702: PUSH
25703: LD_INT 1
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: PUSH
25710: LD_INT 25
25712: PUSH
25713: LD_INT 5
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: PUSH
25720: LD_INT 25
25722: PUSH
25723: LD_INT 8
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: PUSH
25730: LD_INT 25
25732: PUSH
25733: LD_INT 9
25735: PUSH
25736: EMPTY
25737: LIST
25738: LIST
25739: PUSH
25740: EMPTY
25741: LIST
25742: LIST
25743: LIST
25744: LIST
25745: LIST
25746: PPUSH
25747: CALL_OW 72
25751: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25752: LD_ADDR_VAR 0 6
25756: PUSH
25757: LD_EXP 90
25761: PUSH
25762: LD_VAR 0 1
25766: ARRAY
25767: PPUSH
25768: LD_INT 25
25770: PUSH
25771: LD_INT 2
25773: PUSH
25774: EMPTY
25775: LIST
25776: LIST
25777: PPUSH
25778: CALL_OW 72
25782: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25783: LD_ADDR_VAR 0 7
25787: PUSH
25788: LD_EXP 90
25792: PUSH
25793: LD_VAR 0 1
25797: ARRAY
25798: PPUSH
25799: LD_INT 25
25801: PUSH
25802: LD_INT 3
25804: PUSH
25805: EMPTY
25806: LIST
25807: LIST
25808: PPUSH
25809: CALL_OW 72
25813: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25814: LD_ADDR_VAR 0 8
25818: PUSH
25819: LD_EXP 90
25823: PUSH
25824: LD_VAR 0 1
25828: ARRAY
25829: PPUSH
25830: LD_INT 25
25832: PUSH
25833: LD_INT 4
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 24
25842: PUSH
25843: LD_INT 251
25845: PUSH
25846: EMPTY
25847: LIST
25848: LIST
25849: PUSH
25850: EMPTY
25851: LIST
25852: LIST
25853: PPUSH
25854: CALL_OW 72
25858: ST_TO_ADDR
// if mc_scan [ base ] then
25859: LD_EXP 113
25863: PUSH
25864: LD_VAR 0 1
25868: ARRAY
25869: IFFALSE 26330
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25871: LD_ADDR_EXP 132
25875: PUSH
25876: LD_EXP 132
25880: PPUSH
25881: LD_VAR 0 1
25885: PPUSH
25886: LD_INT 4
25888: PPUSH
25889: CALL_OW 1
25893: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25894: LD_ADDR_VAR 0 12
25898: PUSH
25899: LD_EXP 90
25903: PUSH
25904: LD_VAR 0 1
25908: ARRAY
25909: PPUSH
25910: LD_INT 2
25912: PUSH
25913: LD_INT 30
25915: PUSH
25916: LD_INT 4
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PUSH
25923: LD_INT 30
25925: PUSH
25926: LD_INT 5
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: PUSH
25933: EMPTY
25934: LIST
25935: LIST
25936: LIST
25937: PPUSH
25938: CALL_OW 72
25942: ST_TO_ADDR
// if not b then
25943: LD_VAR 0 12
25947: NOT
25948: IFFALSE 25952
// exit ;
25950: GO 29018
// p := [ ] ;
25952: LD_ADDR_VAR 0 11
25956: PUSH
25957: EMPTY
25958: ST_TO_ADDR
// if sci >= 2 then
25959: LD_VAR 0 8
25963: PUSH
25964: LD_INT 2
25966: GREATEREQUAL
25967: IFFALSE 25998
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25969: LD_ADDR_VAR 0 8
25973: PUSH
25974: LD_VAR 0 8
25978: PUSH
25979: LD_INT 1
25981: ARRAY
25982: PUSH
25983: LD_VAR 0 8
25987: PUSH
25988: LD_INT 2
25990: ARRAY
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: ST_TO_ADDR
25996: GO 26059
// if sci = 1 then
25998: LD_VAR 0 8
26002: PUSH
26003: LD_INT 1
26005: EQUAL
26006: IFFALSE 26027
// sci := [ sci [ 1 ] ] else
26008: LD_ADDR_VAR 0 8
26012: PUSH
26013: LD_VAR 0 8
26017: PUSH
26018: LD_INT 1
26020: ARRAY
26021: PUSH
26022: EMPTY
26023: LIST
26024: ST_TO_ADDR
26025: GO 26059
// if sci = 0 then
26027: LD_VAR 0 8
26031: PUSH
26032: LD_INT 0
26034: EQUAL
26035: IFFALSE 26059
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26037: LD_ADDR_VAR 0 11
26041: PUSH
26042: LD_VAR 0 4
26046: PPUSH
26047: LD_INT 4
26049: PPUSH
26050: CALL 85717 0 2
26054: PUSH
26055: LD_INT 1
26057: ARRAY
26058: ST_TO_ADDR
// if eng > 4 then
26059: LD_VAR 0 6
26063: PUSH
26064: LD_INT 4
26066: GREATER
26067: IFFALSE 26113
// for i = eng downto 4 do
26069: LD_ADDR_VAR 0 3
26073: PUSH
26074: DOUBLE
26075: LD_VAR 0 6
26079: INC
26080: ST_TO_ADDR
26081: LD_INT 4
26083: PUSH
26084: FOR_DOWNTO
26085: IFFALSE 26111
// eng := eng diff eng [ i ] ;
26087: LD_ADDR_VAR 0 6
26091: PUSH
26092: LD_VAR 0 6
26096: PUSH
26097: LD_VAR 0 6
26101: PUSH
26102: LD_VAR 0 3
26106: ARRAY
26107: DIFF
26108: ST_TO_ADDR
26109: GO 26084
26111: POP
26112: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26113: LD_ADDR_VAR 0 4
26117: PUSH
26118: LD_VAR 0 4
26122: PUSH
26123: LD_VAR 0 5
26127: PUSH
26128: LD_VAR 0 6
26132: UNION
26133: PUSH
26134: LD_VAR 0 7
26138: UNION
26139: PUSH
26140: LD_VAR 0 8
26144: UNION
26145: DIFF
26146: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26147: LD_ADDR_VAR 0 13
26151: PUSH
26152: LD_EXP 90
26156: PUSH
26157: LD_VAR 0 1
26161: ARRAY
26162: PPUSH
26163: LD_INT 2
26165: PUSH
26166: LD_INT 30
26168: PUSH
26169: LD_INT 32
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 30
26178: PUSH
26179: LD_INT 31
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: PUSH
26186: EMPTY
26187: LIST
26188: LIST
26189: LIST
26190: PPUSH
26191: CALL_OW 72
26195: PUSH
26196: LD_EXP 90
26200: PUSH
26201: LD_VAR 0 1
26205: ARRAY
26206: PPUSH
26207: LD_INT 2
26209: PUSH
26210: LD_INT 30
26212: PUSH
26213: LD_INT 4
26215: PUSH
26216: EMPTY
26217: LIST
26218: LIST
26219: PUSH
26220: LD_INT 30
26222: PUSH
26223: LD_INT 5
26225: PUSH
26226: EMPTY
26227: LIST
26228: LIST
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: LIST
26234: PPUSH
26235: CALL_OW 72
26239: PUSH
26240: LD_INT 6
26242: MUL
26243: PLUS
26244: ST_TO_ADDR
// if bcount < tmp then
26245: LD_VAR 0 13
26249: PUSH
26250: LD_VAR 0 4
26254: LESS
26255: IFFALSE 26301
// for i = tmp downto bcount do
26257: LD_ADDR_VAR 0 3
26261: PUSH
26262: DOUBLE
26263: LD_VAR 0 4
26267: INC
26268: ST_TO_ADDR
26269: LD_VAR 0 13
26273: PUSH
26274: FOR_DOWNTO
26275: IFFALSE 26299
// tmp := Delete ( tmp , tmp ) ;
26277: LD_ADDR_VAR 0 4
26281: PUSH
26282: LD_VAR 0 4
26286: PPUSH
26287: LD_VAR 0 4
26291: PPUSH
26292: CALL_OW 3
26296: ST_TO_ADDR
26297: GO 26274
26299: POP
26300: POP
// result := [ tmp , 0 , 0 , p ] ;
26301: LD_ADDR_VAR 0 2
26305: PUSH
26306: LD_VAR 0 4
26310: PUSH
26311: LD_INT 0
26313: PUSH
26314: LD_INT 0
26316: PUSH
26317: LD_VAR 0 11
26321: PUSH
26322: EMPTY
26323: LIST
26324: LIST
26325: LIST
26326: LIST
26327: ST_TO_ADDR
// exit ;
26328: GO 29018
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26330: LD_EXP 90
26334: PUSH
26335: LD_VAR 0 1
26339: ARRAY
26340: PPUSH
26341: LD_INT 2
26343: PUSH
26344: LD_INT 30
26346: PUSH
26347: LD_INT 6
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 30
26356: PUSH
26357: LD_INT 7
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 30
26366: PUSH
26367: LD_INT 8
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: LIST
26378: LIST
26379: PPUSH
26380: CALL_OW 72
26384: NOT
26385: PUSH
26386: LD_EXP 90
26390: PUSH
26391: LD_VAR 0 1
26395: ARRAY
26396: PPUSH
26397: LD_INT 30
26399: PUSH
26400: LD_INT 3
26402: PUSH
26403: EMPTY
26404: LIST
26405: LIST
26406: PPUSH
26407: CALL_OW 72
26411: NOT
26412: AND
26413: IFFALSE 26485
// begin if eng = tmp then
26415: LD_VAR 0 6
26419: PUSH
26420: LD_VAR 0 4
26424: EQUAL
26425: IFFALSE 26429
// exit ;
26427: GO 29018
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26429: LD_ADDR_EXP 132
26433: PUSH
26434: LD_EXP 132
26438: PPUSH
26439: LD_VAR 0 1
26443: PPUSH
26444: LD_INT 1
26446: PPUSH
26447: CALL_OW 1
26451: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26452: LD_ADDR_VAR 0 2
26456: PUSH
26457: LD_INT 0
26459: PUSH
26460: LD_VAR 0 4
26464: PUSH
26465: LD_VAR 0 6
26469: DIFF
26470: PUSH
26471: LD_INT 0
26473: PUSH
26474: LD_INT 0
26476: PUSH
26477: EMPTY
26478: LIST
26479: LIST
26480: LIST
26481: LIST
26482: ST_TO_ADDR
// exit ;
26483: GO 29018
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26485: LD_EXP 117
26489: PUSH
26490: LD_EXP 116
26494: PUSH
26495: LD_VAR 0 1
26499: ARRAY
26500: ARRAY
26501: PUSH
26502: LD_EXP 90
26506: PUSH
26507: LD_VAR 0 1
26511: ARRAY
26512: PPUSH
26513: LD_INT 2
26515: PUSH
26516: LD_INT 30
26518: PUSH
26519: LD_INT 6
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: PUSH
26526: LD_INT 30
26528: PUSH
26529: LD_INT 7
26531: PUSH
26532: EMPTY
26533: LIST
26534: LIST
26535: PUSH
26536: LD_INT 30
26538: PUSH
26539: LD_INT 8
26541: PUSH
26542: EMPTY
26543: LIST
26544: LIST
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: LIST
26550: LIST
26551: PPUSH
26552: CALL_OW 72
26556: AND
26557: PUSH
26558: LD_EXP 90
26562: PUSH
26563: LD_VAR 0 1
26567: ARRAY
26568: PPUSH
26569: LD_INT 30
26571: PUSH
26572: LD_INT 3
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PPUSH
26579: CALL_OW 72
26583: NOT
26584: AND
26585: IFFALSE 26799
// begin if sci >= 6 then
26587: LD_VAR 0 8
26591: PUSH
26592: LD_INT 6
26594: GREATEREQUAL
26595: IFFALSE 26599
// exit ;
26597: GO 29018
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26599: LD_ADDR_EXP 132
26603: PUSH
26604: LD_EXP 132
26608: PPUSH
26609: LD_VAR 0 1
26613: PPUSH
26614: LD_INT 2
26616: PPUSH
26617: CALL_OW 1
26621: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26622: LD_ADDR_VAR 0 9
26626: PUSH
26627: LD_VAR 0 4
26631: PUSH
26632: LD_VAR 0 8
26636: DIFF
26637: PPUSH
26638: LD_INT 4
26640: PPUSH
26641: CALL 85717 0 2
26645: ST_TO_ADDR
// p := [ ] ;
26646: LD_ADDR_VAR 0 11
26650: PUSH
26651: EMPTY
26652: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26653: LD_VAR 0 8
26657: PUSH
26658: LD_INT 6
26660: LESS
26661: PUSH
26662: LD_VAR 0 9
26666: PUSH
26667: LD_INT 6
26669: GREATER
26670: AND
26671: IFFALSE 26752
// begin for i = 1 to 6 - sci do
26673: LD_ADDR_VAR 0 3
26677: PUSH
26678: DOUBLE
26679: LD_INT 1
26681: DEC
26682: ST_TO_ADDR
26683: LD_INT 6
26685: PUSH
26686: LD_VAR 0 8
26690: MINUS
26691: PUSH
26692: FOR_TO
26693: IFFALSE 26748
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26695: LD_ADDR_VAR 0 11
26699: PUSH
26700: LD_VAR 0 11
26704: PPUSH
26705: LD_VAR 0 11
26709: PUSH
26710: LD_INT 1
26712: PLUS
26713: PPUSH
26714: LD_VAR 0 9
26718: PUSH
26719: LD_INT 1
26721: ARRAY
26722: PPUSH
26723: CALL_OW 2
26727: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26728: LD_ADDR_VAR 0 9
26732: PUSH
26733: LD_VAR 0 9
26737: PPUSH
26738: LD_INT 1
26740: PPUSH
26741: CALL_OW 3
26745: ST_TO_ADDR
// end ;
26746: GO 26692
26748: POP
26749: POP
// end else
26750: GO 26772
// if sort then
26752: LD_VAR 0 9
26756: IFFALSE 26772
// p := sort [ 1 ] ;
26758: LD_ADDR_VAR 0 11
26762: PUSH
26763: LD_VAR 0 9
26767: PUSH
26768: LD_INT 1
26770: ARRAY
26771: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26772: LD_ADDR_VAR 0 2
26776: PUSH
26777: LD_INT 0
26779: PUSH
26780: LD_INT 0
26782: PUSH
26783: LD_INT 0
26785: PUSH
26786: LD_VAR 0 11
26790: PUSH
26791: EMPTY
26792: LIST
26793: LIST
26794: LIST
26795: LIST
26796: ST_TO_ADDR
// exit ;
26797: GO 29018
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26799: LD_EXP 117
26803: PUSH
26804: LD_EXP 116
26808: PUSH
26809: LD_VAR 0 1
26813: ARRAY
26814: ARRAY
26815: PUSH
26816: LD_EXP 90
26820: PUSH
26821: LD_VAR 0 1
26825: ARRAY
26826: PPUSH
26827: LD_INT 2
26829: PUSH
26830: LD_INT 30
26832: PUSH
26833: LD_INT 6
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 30
26842: PUSH
26843: LD_INT 7
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PUSH
26850: LD_INT 30
26852: PUSH
26853: LD_INT 8
26855: PUSH
26856: EMPTY
26857: LIST
26858: LIST
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: LIST
26864: LIST
26865: PPUSH
26866: CALL_OW 72
26870: AND
26871: PUSH
26872: LD_EXP 90
26876: PUSH
26877: LD_VAR 0 1
26881: ARRAY
26882: PPUSH
26883: LD_INT 30
26885: PUSH
26886: LD_INT 3
26888: PUSH
26889: EMPTY
26890: LIST
26891: LIST
26892: PPUSH
26893: CALL_OW 72
26897: AND
26898: IFFALSE 27632
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26900: LD_ADDR_EXP 132
26904: PUSH
26905: LD_EXP 132
26909: PPUSH
26910: LD_VAR 0 1
26914: PPUSH
26915: LD_INT 3
26917: PPUSH
26918: CALL_OW 1
26922: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26923: LD_ADDR_VAR 0 2
26927: PUSH
26928: LD_INT 0
26930: PUSH
26931: LD_INT 0
26933: PUSH
26934: LD_INT 0
26936: PUSH
26937: LD_INT 0
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: ST_TO_ADDR
// if not eng then
26946: LD_VAR 0 6
26950: NOT
26951: IFFALSE 27014
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26953: LD_ADDR_VAR 0 11
26957: PUSH
26958: LD_VAR 0 4
26962: PPUSH
26963: LD_INT 2
26965: PPUSH
26966: CALL 85717 0 2
26970: PUSH
26971: LD_INT 1
26973: ARRAY
26974: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26975: LD_ADDR_VAR 0 2
26979: PUSH
26980: LD_VAR 0 2
26984: PPUSH
26985: LD_INT 2
26987: PPUSH
26988: LD_VAR 0 11
26992: PPUSH
26993: CALL_OW 1
26997: ST_TO_ADDR
// tmp := tmp diff p ;
26998: LD_ADDR_VAR 0 4
27002: PUSH
27003: LD_VAR 0 4
27007: PUSH
27008: LD_VAR 0 11
27012: DIFF
27013: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27014: LD_VAR 0 4
27018: PUSH
27019: LD_VAR 0 8
27023: PUSH
27024: LD_INT 6
27026: LESS
27027: AND
27028: IFFALSE 27216
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27030: LD_ADDR_VAR 0 9
27034: PUSH
27035: LD_VAR 0 4
27039: PUSH
27040: LD_VAR 0 8
27044: PUSH
27045: LD_VAR 0 7
27049: UNION
27050: DIFF
27051: PPUSH
27052: LD_INT 4
27054: PPUSH
27055: CALL 85717 0 2
27059: ST_TO_ADDR
// p := [ ] ;
27060: LD_ADDR_VAR 0 11
27064: PUSH
27065: EMPTY
27066: ST_TO_ADDR
// if sort then
27067: LD_VAR 0 9
27071: IFFALSE 27187
// for i = 1 to 6 - sci do
27073: LD_ADDR_VAR 0 3
27077: PUSH
27078: DOUBLE
27079: LD_INT 1
27081: DEC
27082: ST_TO_ADDR
27083: LD_INT 6
27085: PUSH
27086: LD_VAR 0 8
27090: MINUS
27091: PUSH
27092: FOR_TO
27093: IFFALSE 27185
// begin if i = sort then
27095: LD_VAR 0 3
27099: PUSH
27100: LD_VAR 0 9
27104: EQUAL
27105: IFFALSE 27109
// break ;
27107: GO 27185
// if GetClass ( i ) = 4 then
27109: LD_VAR 0 3
27113: PPUSH
27114: CALL_OW 257
27118: PUSH
27119: LD_INT 4
27121: EQUAL
27122: IFFALSE 27126
// continue ;
27124: GO 27092
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27126: LD_ADDR_VAR 0 11
27130: PUSH
27131: LD_VAR 0 11
27135: PPUSH
27136: LD_VAR 0 11
27140: PUSH
27141: LD_INT 1
27143: PLUS
27144: PPUSH
27145: LD_VAR 0 9
27149: PUSH
27150: LD_VAR 0 3
27154: ARRAY
27155: PPUSH
27156: CALL_OW 2
27160: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27161: LD_ADDR_VAR 0 4
27165: PUSH
27166: LD_VAR 0 4
27170: PUSH
27171: LD_VAR 0 9
27175: PUSH
27176: LD_VAR 0 3
27180: ARRAY
27181: DIFF
27182: ST_TO_ADDR
// end ;
27183: GO 27092
27185: POP
27186: POP
// if p then
27187: LD_VAR 0 11
27191: IFFALSE 27216
// result := Replace ( result , 4 , p ) ;
27193: LD_ADDR_VAR 0 2
27197: PUSH
27198: LD_VAR 0 2
27202: PPUSH
27203: LD_INT 4
27205: PPUSH
27206: LD_VAR 0 11
27210: PPUSH
27211: CALL_OW 1
27215: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27216: LD_VAR 0 4
27220: PUSH
27221: LD_VAR 0 7
27225: PUSH
27226: LD_INT 6
27228: LESS
27229: AND
27230: IFFALSE 27418
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27232: LD_ADDR_VAR 0 9
27236: PUSH
27237: LD_VAR 0 4
27241: PUSH
27242: LD_VAR 0 8
27246: PUSH
27247: LD_VAR 0 7
27251: UNION
27252: DIFF
27253: PPUSH
27254: LD_INT 3
27256: PPUSH
27257: CALL 85717 0 2
27261: ST_TO_ADDR
// p := [ ] ;
27262: LD_ADDR_VAR 0 11
27266: PUSH
27267: EMPTY
27268: ST_TO_ADDR
// if sort then
27269: LD_VAR 0 9
27273: IFFALSE 27389
// for i = 1 to 6 - mech do
27275: LD_ADDR_VAR 0 3
27279: PUSH
27280: DOUBLE
27281: LD_INT 1
27283: DEC
27284: ST_TO_ADDR
27285: LD_INT 6
27287: PUSH
27288: LD_VAR 0 7
27292: MINUS
27293: PUSH
27294: FOR_TO
27295: IFFALSE 27387
// begin if i = sort then
27297: LD_VAR 0 3
27301: PUSH
27302: LD_VAR 0 9
27306: EQUAL
27307: IFFALSE 27311
// break ;
27309: GO 27387
// if GetClass ( i ) = 3 then
27311: LD_VAR 0 3
27315: PPUSH
27316: CALL_OW 257
27320: PUSH
27321: LD_INT 3
27323: EQUAL
27324: IFFALSE 27328
// continue ;
27326: GO 27294
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27328: LD_ADDR_VAR 0 11
27332: PUSH
27333: LD_VAR 0 11
27337: PPUSH
27338: LD_VAR 0 11
27342: PUSH
27343: LD_INT 1
27345: PLUS
27346: PPUSH
27347: LD_VAR 0 9
27351: PUSH
27352: LD_VAR 0 3
27356: ARRAY
27357: PPUSH
27358: CALL_OW 2
27362: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27363: LD_ADDR_VAR 0 4
27367: PUSH
27368: LD_VAR 0 4
27372: PUSH
27373: LD_VAR 0 9
27377: PUSH
27378: LD_VAR 0 3
27382: ARRAY
27383: DIFF
27384: ST_TO_ADDR
// end ;
27385: GO 27294
27387: POP
27388: POP
// if p then
27389: LD_VAR 0 11
27393: IFFALSE 27418
// result := Replace ( result , 3 , p ) ;
27395: LD_ADDR_VAR 0 2
27399: PUSH
27400: LD_VAR 0 2
27404: PPUSH
27405: LD_INT 3
27407: PPUSH
27408: LD_VAR 0 11
27412: PPUSH
27413: CALL_OW 1
27417: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27418: LD_VAR 0 4
27422: PUSH
27423: LD_INT 6
27425: GREATER
27426: PUSH
27427: LD_VAR 0 6
27431: PUSH
27432: LD_INT 6
27434: LESS
27435: AND
27436: IFFALSE 27630
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27438: LD_ADDR_VAR 0 9
27442: PUSH
27443: LD_VAR 0 4
27447: PUSH
27448: LD_VAR 0 8
27452: PUSH
27453: LD_VAR 0 7
27457: UNION
27458: PUSH
27459: LD_VAR 0 6
27463: UNION
27464: DIFF
27465: PPUSH
27466: LD_INT 2
27468: PPUSH
27469: CALL 85717 0 2
27473: ST_TO_ADDR
// p := [ ] ;
27474: LD_ADDR_VAR 0 11
27478: PUSH
27479: EMPTY
27480: ST_TO_ADDR
// if sort then
27481: LD_VAR 0 9
27485: IFFALSE 27601
// for i = 1 to 6 - eng do
27487: LD_ADDR_VAR 0 3
27491: PUSH
27492: DOUBLE
27493: LD_INT 1
27495: DEC
27496: ST_TO_ADDR
27497: LD_INT 6
27499: PUSH
27500: LD_VAR 0 6
27504: MINUS
27505: PUSH
27506: FOR_TO
27507: IFFALSE 27599
// begin if i = sort then
27509: LD_VAR 0 3
27513: PUSH
27514: LD_VAR 0 9
27518: EQUAL
27519: IFFALSE 27523
// break ;
27521: GO 27599
// if GetClass ( i ) = 2 then
27523: LD_VAR 0 3
27527: PPUSH
27528: CALL_OW 257
27532: PUSH
27533: LD_INT 2
27535: EQUAL
27536: IFFALSE 27540
// continue ;
27538: GO 27506
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27540: LD_ADDR_VAR 0 11
27544: PUSH
27545: LD_VAR 0 11
27549: PPUSH
27550: LD_VAR 0 11
27554: PUSH
27555: LD_INT 1
27557: PLUS
27558: PPUSH
27559: LD_VAR 0 9
27563: PUSH
27564: LD_VAR 0 3
27568: ARRAY
27569: PPUSH
27570: CALL_OW 2
27574: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27575: LD_ADDR_VAR 0 4
27579: PUSH
27580: LD_VAR 0 4
27584: PUSH
27585: LD_VAR 0 9
27589: PUSH
27590: LD_VAR 0 3
27594: ARRAY
27595: DIFF
27596: ST_TO_ADDR
// end ;
27597: GO 27506
27599: POP
27600: POP
// if p then
27601: LD_VAR 0 11
27605: IFFALSE 27630
// result := Replace ( result , 2 , p ) ;
27607: LD_ADDR_VAR 0 2
27611: PUSH
27612: LD_VAR 0 2
27616: PPUSH
27617: LD_INT 2
27619: PPUSH
27620: LD_VAR 0 11
27624: PPUSH
27625: CALL_OW 1
27629: ST_TO_ADDR
// end ; exit ;
27630: GO 29018
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27632: LD_EXP 117
27636: PUSH
27637: LD_EXP 116
27641: PUSH
27642: LD_VAR 0 1
27646: ARRAY
27647: ARRAY
27648: NOT
27649: PUSH
27650: LD_EXP 90
27654: PUSH
27655: LD_VAR 0 1
27659: ARRAY
27660: PPUSH
27661: LD_INT 30
27663: PUSH
27664: LD_INT 3
27666: PUSH
27667: EMPTY
27668: LIST
27669: LIST
27670: PPUSH
27671: CALL_OW 72
27675: AND
27676: PUSH
27677: LD_EXP 95
27681: PUSH
27682: LD_VAR 0 1
27686: ARRAY
27687: AND
27688: IFFALSE 28296
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27690: LD_ADDR_EXP 132
27694: PUSH
27695: LD_EXP 132
27699: PPUSH
27700: LD_VAR 0 1
27704: PPUSH
27705: LD_INT 5
27707: PPUSH
27708: CALL_OW 1
27712: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27713: LD_ADDR_VAR 0 2
27717: PUSH
27718: LD_INT 0
27720: PUSH
27721: LD_INT 0
27723: PUSH
27724: LD_INT 0
27726: PUSH
27727: LD_INT 0
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: LIST
27734: LIST
27735: ST_TO_ADDR
// if sci > 1 then
27736: LD_VAR 0 8
27740: PUSH
27741: LD_INT 1
27743: GREATER
27744: IFFALSE 27772
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27746: LD_ADDR_VAR 0 4
27750: PUSH
27751: LD_VAR 0 4
27755: PUSH
27756: LD_VAR 0 8
27760: PUSH
27761: LD_VAR 0 8
27765: PUSH
27766: LD_INT 1
27768: ARRAY
27769: DIFF
27770: DIFF
27771: ST_TO_ADDR
// if tmp and not sci then
27772: LD_VAR 0 4
27776: PUSH
27777: LD_VAR 0 8
27781: NOT
27782: AND
27783: IFFALSE 27852
// begin sort := SortBySkill ( tmp , 4 ) ;
27785: LD_ADDR_VAR 0 9
27789: PUSH
27790: LD_VAR 0 4
27794: PPUSH
27795: LD_INT 4
27797: PPUSH
27798: CALL 85717 0 2
27802: ST_TO_ADDR
// if sort then
27803: LD_VAR 0 9
27807: IFFALSE 27823
// p := sort [ 1 ] ;
27809: LD_ADDR_VAR 0 11
27813: PUSH
27814: LD_VAR 0 9
27818: PUSH
27819: LD_INT 1
27821: ARRAY
27822: ST_TO_ADDR
// if p then
27823: LD_VAR 0 11
27827: IFFALSE 27852
// result := Replace ( result , 4 , p ) ;
27829: LD_ADDR_VAR 0 2
27833: PUSH
27834: LD_VAR 0 2
27838: PPUSH
27839: LD_INT 4
27841: PPUSH
27842: LD_VAR 0 11
27846: PPUSH
27847: CALL_OW 1
27851: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27852: LD_ADDR_VAR 0 4
27856: PUSH
27857: LD_VAR 0 4
27861: PUSH
27862: LD_VAR 0 7
27866: DIFF
27867: ST_TO_ADDR
// if tmp and mech < 6 then
27868: LD_VAR 0 4
27872: PUSH
27873: LD_VAR 0 7
27877: PUSH
27878: LD_INT 6
27880: LESS
27881: AND
27882: IFFALSE 28070
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27884: LD_ADDR_VAR 0 9
27888: PUSH
27889: LD_VAR 0 4
27893: PUSH
27894: LD_VAR 0 8
27898: PUSH
27899: LD_VAR 0 7
27903: UNION
27904: DIFF
27905: PPUSH
27906: LD_INT 3
27908: PPUSH
27909: CALL 85717 0 2
27913: ST_TO_ADDR
// p := [ ] ;
27914: LD_ADDR_VAR 0 11
27918: PUSH
27919: EMPTY
27920: ST_TO_ADDR
// if sort then
27921: LD_VAR 0 9
27925: IFFALSE 28041
// for i = 1 to 6 - mech do
27927: LD_ADDR_VAR 0 3
27931: PUSH
27932: DOUBLE
27933: LD_INT 1
27935: DEC
27936: ST_TO_ADDR
27937: LD_INT 6
27939: PUSH
27940: LD_VAR 0 7
27944: MINUS
27945: PUSH
27946: FOR_TO
27947: IFFALSE 28039
// begin if i = sort then
27949: LD_VAR 0 3
27953: PUSH
27954: LD_VAR 0 9
27958: EQUAL
27959: IFFALSE 27963
// break ;
27961: GO 28039
// if GetClass ( i ) = 3 then
27963: LD_VAR 0 3
27967: PPUSH
27968: CALL_OW 257
27972: PUSH
27973: LD_INT 3
27975: EQUAL
27976: IFFALSE 27980
// continue ;
27978: GO 27946
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27980: LD_ADDR_VAR 0 11
27984: PUSH
27985: LD_VAR 0 11
27989: PPUSH
27990: LD_VAR 0 11
27994: PUSH
27995: LD_INT 1
27997: PLUS
27998: PPUSH
27999: LD_VAR 0 9
28003: PUSH
28004: LD_VAR 0 3
28008: ARRAY
28009: PPUSH
28010: CALL_OW 2
28014: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28015: LD_ADDR_VAR 0 4
28019: PUSH
28020: LD_VAR 0 4
28024: PUSH
28025: LD_VAR 0 9
28029: PUSH
28030: LD_VAR 0 3
28034: ARRAY
28035: DIFF
28036: ST_TO_ADDR
// end ;
28037: GO 27946
28039: POP
28040: POP
// if p then
28041: LD_VAR 0 11
28045: IFFALSE 28070
// result := Replace ( result , 3 , p ) ;
28047: LD_ADDR_VAR 0 2
28051: PUSH
28052: LD_VAR 0 2
28056: PPUSH
28057: LD_INT 3
28059: PPUSH
28060: LD_VAR 0 11
28064: PPUSH
28065: CALL_OW 1
28069: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28070: LD_ADDR_VAR 0 4
28074: PUSH
28075: LD_VAR 0 4
28079: PUSH
28080: LD_VAR 0 6
28084: DIFF
28085: ST_TO_ADDR
// if tmp and eng < 6 then
28086: LD_VAR 0 4
28090: PUSH
28091: LD_VAR 0 6
28095: PUSH
28096: LD_INT 6
28098: LESS
28099: AND
28100: IFFALSE 28294
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28102: LD_ADDR_VAR 0 9
28106: PUSH
28107: LD_VAR 0 4
28111: PUSH
28112: LD_VAR 0 8
28116: PUSH
28117: LD_VAR 0 7
28121: UNION
28122: PUSH
28123: LD_VAR 0 6
28127: UNION
28128: DIFF
28129: PPUSH
28130: LD_INT 2
28132: PPUSH
28133: CALL 85717 0 2
28137: ST_TO_ADDR
// p := [ ] ;
28138: LD_ADDR_VAR 0 11
28142: PUSH
28143: EMPTY
28144: ST_TO_ADDR
// if sort then
28145: LD_VAR 0 9
28149: IFFALSE 28265
// for i = 1 to 6 - eng do
28151: LD_ADDR_VAR 0 3
28155: PUSH
28156: DOUBLE
28157: LD_INT 1
28159: DEC
28160: ST_TO_ADDR
28161: LD_INT 6
28163: PUSH
28164: LD_VAR 0 6
28168: MINUS
28169: PUSH
28170: FOR_TO
28171: IFFALSE 28263
// begin if i = sort then
28173: LD_VAR 0 3
28177: PUSH
28178: LD_VAR 0 9
28182: EQUAL
28183: IFFALSE 28187
// break ;
28185: GO 28263
// if GetClass ( i ) = 2 then
28187: LD_VAR 0 3
28191: PPUSH
28192: CALL_OW 257
28196: PUSH
28197: LD_INT 2
28199: EQUAL
28200: IFFALSE 28204
// continue ;
28202: GO 28170
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28204: LD_ADDR_VAR 0 11
28208: PUSH
28209: LD_VAR 0 11
28213: PPUSH
28214: LD_VAR 0 11
28218: PUSH
28219: LD_INT 1
28221: PLUS
28222: PPUSH
28223: LD_VAR 0 9
28227: PUSH
28228: LD_VAR 0 3
28232: ARRAY
28233: PPUSH
28234: CALL_OW 2
28238: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28239: LD_ADDR_VAR 0 4
28243: PUSH
28244: LD_VAR 0 4
28248: PUSH
28249: LD_VAR 0 9
28253: PUSH
28254: LD_VAR 0 3
28258: ARRAY
28259: DIFF
28260: ST_TO_ADDR
// end ;
28261: GO 28170
28263: POP
28264: POP
// if p then
28265: LD_VAR 0 11
28269: IFFALSE 28294
// result := Replace ( result , 2 , p ) ;
28271: LD_ADDR_VAR 0 2
28275: PUSH
28276: LD_VAR 0 2
28280: PPUSH
28281: LD_INT 2
28283: PPUSH
28284: LD_VAR 0 11
28288: PPUSH
28289: CALL_OW 1
28293: ST_TO_ADDR
// end ; exit ;
28294: GO 29018
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28296: LD_EXP 117
28300: PUSH
28301: LD_EXP 116
28305: PUSH
28306: LD_VAR 0 1
28310: ARRAY
28311: ARRAY
28312: NOT
28313: PUSH
28314: LD_EXP 90
28318: PUSH
28319: LD_VAR 0 1
28323: ARRAY
28324: PPUSH
28325: LD_INT 30
28327: PUSH
28328: LD_INT 3
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PPUSH
28335: CALL_OW 72
28339: AND
28340: PUSH
28341: LD_EXP 95
28345: PUSH
28346: LD_VAR 0 1
28350: ARRAY
28351: NOT
28352: AND
28353: IFFALSE 29018
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28355: LD_ADDR_EXP 132
28359: PUSH
28360: LD_EXP 132
28364: PPUSH
28365: LD_VAR 0 1
28369: PPUSH
28370: LD_INT 6
28372: PPUSH
28373: CALL_OW 1
28377: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28378: LD_ADDR_VAR 0 2
28382: PUSH
28383: LD_INT 0
28385: PUSH
28386: LD_INT 0
28388: PUSH
28389: LD_INT 0
28391: PUSH
28392: LD_INT 0
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: ST_TO_ADDR
// if sci >= 1 then
28401: LD_VAR 0 8
28405: PUSH
28406: LD_INT 1
28408: GREATEREQUAL
28409: IFFALSE 28431
// tmp := tmp diff sci [ 1 ] ;
28411: LD_ADDR_VAR 0 4
28415: PUSH
28416: LD_VAR 0 4
28420: PUSH
28421: LD_VAR 0 8
28425: PUSH
28426: LD_INT 1
28428: ARRAY
28429: DIFF
28430: ST_TO_ADDR
// if tmp and not sci then
28431: LD_VAR 0 4
28435: PUSH
28436: LD_VAR 0 8
28440: NOT
28441: AND
28442: IFFALSE 28511
// begin sort := SortBySkill ( tmp , 4 ) ;
28444: LD_ADDR_VAR 0 9
28448: PUSH
28449: LD_VAR 0 4
28453: PPUSH
28454: LD_INT 4
28456: PPUSH
28457: CALL 85717 0 2
28461: ST_TO_ADDR
// if sort then
28462: LD_VAR 0 9
28466: IFFALSE 28482
// p := sort [ 1 ] ;
28468: LD_ADDR_VAR 0 11
28472: PUSH
28473: LD_VAR 0 9
28477: PUSH
28478: LD_INT 1
28480: ARRAY
28481: ST_TO_ADDR
// if p then
28482: LD_VAR 0 11
28486: IFFALSE 28511
// result := Replace ( result , 4 , p ) ;
28488: LD_ADDR_VAR 0 2
28492: PUSH
28493: LD_VAR 0 2
28497: PPUSH
28498: LD_INT 4
28500: PPUSH
28501: LD_VAR 0 11
28505: PPUSH
28506: CALL_OW 1
28510: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28511: LD_ADDR_VAR 0 4
28515: PUSH
28516: LD_VAR 0 4
28520: PUSH
28521: LD_VAR 0 7
28525: DIFF
28526: ST_TO_ADDR
// if tmp and mech < 6 then
28527: LD_VAR 0 4
28531: PUSH
28532: LD_VAR 0 7
28536: PUSH
28537: LD_INT 6
28539: LESS
28540: AND
28541: IFFALSE 28723
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28543: LD_ADDR_VAR 0 9
28547: PUSH
28548: LD_VAR 0 4
28552: PUSH
28553: LD_VAR 0 7
28557: DIFF
28558: PPUSH
28559: LD_INT 3
28561: PPUSH
28562: CALL 85717 0 2
28566: ST_TO_ADDR
// p := [ ] ;
28567: LD_ADDR_VAR 0 11
28571: PUSH
28572: EMPTY
28573: ST_TO_ADDR
// if sort then
28574: LD_VAR 0 9
28578: IFFALSE 28694
// for i = 1 to 6 - mech do
28580: LD_ADDR_VAR 0 3
28584: PUSH
28585: DOUBLE
28586: LD_INT 1
28588: DEC
28589: ST_TO_ADDR
28590: LD_INT 6
28592: PUSH
28593: LD_VAR 0 7
28597: MINUS
28598: PUSH
28599: FOR_TO
28600: IFFALSE 28692
// begin if i = sort then
28602: LD_VAR 0 3
28606: PUSH
28607: LD_VAR 0 9
28611: EQUAL
28612: IFFALSE 28616
// break ;
28614: GO 28692
// if GetClass ( i ) = 3 then
28616: LD_VAR 0 3
28620: PPUSH
28621: CALL_OW 257
28625: PUSH
28626: LD_INT 3
28628: EQUAL
28629: IFFALSE 28633
// continue ;
28631: GO 28599
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28633: LD_ADDR_VAR 0 11
28637: PUSH
28638: LD_VAR 0 11
28642: PPUSH
28643: LD_VAR 0 11
28647: PUSH
28648: LD_INT 1
28650: PLUS
28651: PPUSH
28652: LD_VAR 0 9
28656: PUSH
28657: LD_VAR 0 3
28661: ARRAY
28662: PPUSH
28663: CALL_OW 2
28667: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28668: LD_ADDR_VAR 0 4
28672: PUSH
28673: LD_VAR 0 4
28677: PUSH
28678: LD_VAR 0 9
28682: PUSH
28683: LD_VAR 0 3
28687: ARRAY
28688: DIFF
28689: ST_TO_ADDR
// end ;
28690: GO 28599
28692: POP
28693: POP
// if p then
28694: LD_VAR 0 11
28698: IFFALSE 28723
// result := Replace ( result , 3 , p ) ;
28700: LD_ADDR_VAR 0 2
28704: PUSH
28705: LD_VAR 0 2
28709: PPUSH
28710: LD_INT 3
28712: PPUSH
28713: LD_VAR 0 11
28717: PPUSH
28718: CALL_OW 1
28722: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28723: LD_ADDR_VAR 0 4
28727: PUSH
28728: LD_VAR 0 4
28732: PUSH
28733: LD_VAR 0 6
28737: DIFF
28738: ST_TO_ADDR
// if tmp and eng < 4 then
28739: LD_VAR 0 4
28743: PUSH
28744: LD_VAR 0 6
28748: PUSH
28749: LD_INT 4
28751: LESS
28752: AND
28753: IFFALSE 28943
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28755: LD_ADDR_VAR 0 9
28759: PUSH
28760: LD_VAR 0 4
28764: PUSH
28765: LD_VAR 0 7
28769: PUSH
28770: LD_VAR 0 6
28774: UNION
28775: DIFF
28776: PPUSH
28777: LD_INT 2
28779: PPUSH
28780: CALL 85717 0 2
28784: ST_TO_ADDR
// p := [ ] ;
28785: LD_ADDR_VAR 0 11
28789: PUSH
28790: EMPTY
28791: ST_TO_ADDR
// if sort then
28792: LD_VAR 0 9
28796: IFFALSE 28912
// for i = 1 to 4 - eng do
28798: LD_ADDR_VAR 0 3
28802: PUSH
28803: DOUBLE
28804: LD_INT 1
28806: DEC
28807: ST_TO_ADDR
28808: LD_INT 4
28810: PUSH
28811: LD_VAR 0 6
28815: MINUS
28816: PUSH
28817: FOR_TO
28818: IFFALSE 28910
// begin if i = sort then
28820: LD_VAR 0 3
28824: PUSH
28825: LD_VAR 0 9
28829: EQUAL
28830: IFFALSE 28834
// break ;
28832: GO 28910
// if GetClass ( i ) = 2 then
28834: LD_VAR 0 3
28838: PPUSH
28839: CALL_OW 257
28843: PUSH
28844: LD_INT 2
28846: EQUAL
28847: IFFALSE 28851
// continue ;
28849: GO 28817
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28851: LD_ADDR_VAR 0 11
28855: PUSH
28856: LD_VAR 0 11
28860: PPUSH
28861: LD_VAR 0 11
28865: PUSH
28866: LD_INT 1
28868: PLUS
28869: PPUSH
28870: LD_VAR 0 9
28874: PUSH
28875: LD_VAR 0 3
28879: ARRAY
28880: PPUSH
28881: CALL_OW 2
28885: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28886: LD_ADDR_VAR 0 4
28890: PUSH
28891: LD_VAR 0 4
28895: PUSH
28896: LD_VAR 0 9
28900: PUSH
28901: LD_VAR 0 3
28905: ARRAY
28906: DIFF
28907: ST_TO_ADDR
// end ;
28908: GO 28817
28910: POP
28911: POP
// if p then
28912: LD_VAR 0 11
28916: IFFALSE 28941
// result := Replace ( result , 2 , p ) ;
28918: LD_ADDR_VAR 0 2
28922: PUSH
28923: LD_VAR 0 2
28927: PPUSH
28928: LD_INT 2
28930: PPUSH
28931: LD_VAR 0 11
28935: PPUSH
28936: CALL_OW 1
28940: ST_TO_ADDR
// end else
28941: GO 28987
// for i = eng downto 5 do
28943: LD_ADDR_VAR 0 3
28947: PUSH
28948: DOUBLE
28949: LD_VAR 0 6
28953: INC
28954: ST_TO_ADDR
28955: LD_INT 5
28957: PUSH
28958: FOR_DOWNTO
28959: IFFALSE 28985
// tmp := tmp union eng [ i ] ;
28961: LD_ADDR_VAR 0 4
28965: PUSH
28966: LD_VAR 0 4
28970: PUSH
28971: LD_VAR 0 6
28975: PUSH
28976: LD_VAR 0 3
28980: ARRAY
28981: UNION
28982: ST_TO_ADDR
28983: GO 28958
28985: POP
28986: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28987: LD_ADDR_VAR 0 2
28991: PUSH
28992: LD_VAR 0 2
28996: PPUSH
28997: LD_INT 1
28999: PPUSH
29000: LD_VAR 0 4
29004: PUSH
29005: LD_VAR 0 5
29009: DIFF
29010: PPUSH
29011: CALL_OW 1
29015: ST_TO_ADDR
// exit ;
29016: GO 29018
// end ; end ;
29018: LD_VAR 0 2
29022: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29023: LD_INT 0
29025: PPUSH
29026: PPUSH
29027: PPUSH
// if not mc_bases then
29028: LD_EXP 90
29032: NOT
29033: IFFALSE 29037
// exit ;
29035: GO 29143
// for i = 1 to mc_bases do
29037: LD_ADDR_VAR 0 2
29041: PUSH
29042: DOUBLE
29043: LD_INT 1
29045: DEC
29046: ST_TO_ADDR
29047: LD_EXP 90
29051: PUSH
29052: FOR_TO
29053: IFFALSE 29134
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29055: LD_ADDR_VAR 0 3
29059: PUSH
29060: LD_EXP 90
29064: PUSH
29065: LD_VAR 0 2
29069: ARRAY
29070: PPUSH
29071: LD_INT 21
29073: PUSH
29074: LD_INT 3
29076: PUSH
29077: EMPTY
29078: LIST
29079: LIST
29080: PUSH
29081: LD_INT 3
29083: PUSH
29084: LD_INT 24
29086: PUSH
29087: LD_INT 1000
29089: PUSH
29090: EMPTY
29091: LIST
29092: LIST
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PPUSH
29102: CALL_OW 72
29106: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29107: LD_ADDR_EXP 91
29111: PUSH
29112: LD_EXP 91
29116: PPUSH
29117: LD_VAR 0 2
29121: PPUSH
29122: LD_VAR 0 3
29126: PPUSH
29127: CALL_OW 1
29131: ST_TO_ADDR
// end ;
29132: GO 29052
29134: POP
29135: POP
// RaiseSailEvent ( 101 ) ;
29136: LD_INT 101
29138: PPUSH
29139: CALL_OW 427
// end ;
29143: LD_VAR 0 1
29147: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29148: LD_INT 0
29150: PPUSH
29151: PPUSH
29152: PPUSH
29153: PPUSH
29154: PPUSH
29155: PPUSH
29156: PPUSH
// if not mc_bases then
29157: LD_EXP 90
29161: NOT
29162: IFFALSE 29166
// exit ;
29164: GO 29728
// for i = 1 to mc_bases do
29166: LD_ADDR_VAR 0 2
29170: PUSH
29171: DOUBLE
29172: LD_INT 1
29174: DEC
29175: ST_TO_ADDR
29176: LD_EXP 90
29180: PUSH
29181: FOR_TO
29182: IFFALSE 29719
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29184: LD_ADDR_VAR 0 5
29188: PUSH
29189: LD_EXP 90
29193: PUSH
29194: LD_VAR 0 2
29198: ARRAY
29199: PUSH
29200: LD_EXP 119
29204: PUSH
29205: LD_VAR 0 2
29209: ARRAY
29210: UNION
29211: PPUSH
29212: LD_INT 21
29214: PUSH
29215: LD_INT 1
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 1
29224: PUSH
29225: LD_INT 3
29227: PUSH
29228: LD_INT 54
29230: PUSH
29231: EMPTY
29232: LIST
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 3
29240: PUSH
29241: LD_INT 24
29243: PUSH
29244: LD_INT 1000
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: LIST
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: PPUSH
29264: CALL_OW 72
29268: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29269: LD_ADDR_VAR 0 6
29273: PUSH
29274: LD_EXP 90
29278: PUSH
29279: LD_VAR 0 2
29283: ARRAY
29284: PPUSH
29285: LD_INT 21
29287: PUSH
29288: LD_INT 1
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PUSH
29295: LD_INT 1
29297: PUSH
29298: LD_INT 3
29300: PUSH
29301: LD_INT 54
29303: PUSH
29304: EMPTY
29305: LIST
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: LD_INT 3
29313: PUSH
29314: LD_INT 24
29316: PUSH
29317: LD_INT 250
29319: PUSH
29320: EMPTY
29321: LIST
29322: LIST
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: LIST
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PPUSH
29337: CALL_OW 72
29341: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29342: LD_ADDR_VAR 0 7
29346: PUSH
29347: LD_VAR 0 5
29351: PUSH
29352: LD_VAR 0 6
29356: DIFF
29357: ST_TO_ADDR
// if not need_heal_1 then
29358: LD_VAR 0 6
29362: NOT
29363: IFFALSE 29396
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29365: LD_ADDR_EXP 93
29369: PUSH
29370: LD_EXP 93
29374: PPUSH
29375: LD_VAR 0 2
29379: PUSH
29380: LD_INT 1
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PPUSH
29387: EMPTY
29388: PPUSH
29389: CALL 55835 0 3
29393: ST_TO_ADDR
29394: GO 29466
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29396: LD_ADDR_EXP 93
29400: PUSH
29401: LD_EXP 93
29405: PPUSH
29406: LD_VAR 0 2
29410: PUSH
29411: LD_INT 1
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PPUSH
29418: LD_EXP 93
29422: PUSH
29423: LD_VAR 0 2
29427: ARRAY
29428: PUSH
29429: LD_INT 1
29431: ARRAY
29432: PPUSH
29433: LD_INT 3
29435: PUSH
29436: LD_INT 24
29438: PUSH
29439: LD_INT 1000
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PPUSH
29450: CALL_OW 72
29454: PUSH
29455: LD_VAR 0 6
29459: UNION
29460: PPUSH
29461: CALL 55835 0 3
29465: ST_TO_ADDR
// if not need_heal_2 then
29466: LD_VAR 0 7
29470: NOT
29471: IFFALSE 29504
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29473: LD_ADDR_EXP 93
29477: PUSH
29478: LD_EXP 93
29482: PPUSH
29483: LD_VAR 0 2
29487: PUSH
29488: LD_INT 2
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: PPUSH
29495: EMPTY
29496: PPUSH
29497: CALL 55835 0 3
29501: ST_TO_ADDR
29502: GO 29536
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29504: LD_ADDR_EXP 93
29508: PUSH
29509: LD_EXP 93
29513: PPUSH
29514: LD_VAR 0 2
29518: PUSH
29519: LD_INT 2
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PPUSH
29526: LD_VAR 0 7
29530: PPUSH
29531: CALL 55835 0 3
29535: ST_TO_ADDR
// if need_heal_2 then
29536: LD_VAR 0 7
29540: IFFALSE 29701
// for j in need_heal_2 do
29542: LD_ADDR_VAR 0 3
29546: PUSH
29547: LD_VAR 0 7
29551: PUSH
29552: FOR_IN
29553: IFFALSE 29699
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29555: LD_ADDR_VAR 0 5
29559: PUSH
29560: LD_EXP 90
29564: PUSH
29565: LD_VAR 0 2
29569: ARRAY
29570: PPUSH
29571: LD_INT 2
29573: PUSH
29574: LD_INT 30
29576: PUSH
29577: LD_INT 6
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: PUSH
29584: LD_INT 30
29586: PUSH
29587: LD_INT 7
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PUSH
29594: LD_INT 30
29596: PUSH
29597: LD_INT 8
29599: PUSH
29600: EMPTY
29601: LIST
29602: LIST
29603: PUSH
29604: LD_INT 30
29606: PUSH
29607: LD_INT 0
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 30
29616: PUSH
29617: LD_INT 1
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: LIST
29628: LIST
29629: LIST
29630: LIST
29631: PPUSH
29632: CALL_OW 72
29636: ST_TO_ADDR
// if tmp then
29637: LD_VAR 0 5
29641: IFFALSE 29697
// begin k := NearestUnitToUnit ( tmp , j ) ;
29643: LD_ADDR_VAR 0 4
29647: PUSH
29648: LD_VAR 0 5
29652: PPUSH
29653: LD_VAR 0 3
29657: PPUSH
29658: CALL_OW 74
29662: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29663: LD_VAR 0 3
29667: PPUSH
29668: LD_VAR 0 4
29672: PPUSH
29673: CALL_OW 296
29677: PUSH
29678: LD_INT 5
29680: GREATER
29681: IFFALSE 29697
// ComMoveToNearbyEntrance ( j , k ) ;
29683: LD_VAR 0 3
29687: PPUSH
29688: LD_VAR 0 4
29692: PPUSH
29693: CALL 88078 0 2
// end ; end ;
29697: GO 29552
29699: POP
29700: POP
// if not need_heal_1 and not need_heal_2 then
29701: LD_VAR 0 6
29705: NOT
29706: PUSH
29707: LD_VAR 0 7
29711: NOT
29712: AND
29713: IFFALSE 29717
// continue ;
29715: GO 29181
// end ;
29717: GO 29181
29719: POP
29720: POP
// RaiseSailEvent ( 102 ) ;
29721: LD_INT 102
29723: PPUSH
29724: CALL_OW 427
// end ;
29728: LD_VAR 0 1
29732: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29733: LD_INT 0
29735: PPUSH
29736: PPUSH
29737: PPUSH
29738: PPUSH
29739: PPUSH
29740: PPUSH
29741: PPUSH
29742: PPUSH
// if not mc_bases then
29743: LD_EXP 90
29747: NOT
29748: IFFALSE 29752
// exit ;
29750: GO 30613
// for i = 1 to mc_bases do
29752: LD_ADDR_VAR 0 2
29756: PUSH
29757: DOUBLE
29758: LD_INT 1
29760: DEC
29761: ST_TO_ADDR
29762: LD_EXP 90
29766: PUSH
29767: FOR_TO
29768: IFFALSE 30611
// begin if not mc_building_need_repair [ i ] then
29770: LD_EXP 91
29774: PUSH
29775: LD_VAR 0 2
29779: ARRAY
29780: NOT
29781: IFFALSE 29968
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
29783: LD_ADDR_VAR 0 6
29787: PUSH
29788: LD_EXP 109
29792: PUSH
29793: LD_VAR 0 2
29797: ARRAY
29798: PPUSH
29799: LD_INT 3
29801: PUSH
29802: LD_INT 24
29804: PUSH
29805: LD_INT 1000
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 2
29818: PUSH
29819: LD_INT 34
29821: PUSH
29822: LD_INT 13
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 34
29831: PUSH
29832: LD_INT 52
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 34
29841: PUSH
29842: LD_EXP 78
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: EMPTY
29852: LIST
29853: LIST
29854: LIST
29855: LIST
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PPUSH
29861: CALL_OW 72
29865: ST_TO_ADDR
// if cranes then
29866: LD_VAR 0 6
29870: IFFALSE 29932
// for j in cranes do
29872: LD_ADDR_VAR 0 3
29876: PUSH
29877: LD_VAR 0 6
29881: PUSH
29882: FOR_IN
29883: IFFALSE 29930
// if not IsInArea ( j , mc_parking [ i ] ) then
29885: LD_VAR 0 3
29889: PPUSH
29890: LD_EXP 114
29894: PUSH
29895: LD_VAR 0 2
29899: ARRAY
29900: PPUSH
29901: CALL_OW 308
29905: NOT
29906: IFFALSE 29928
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29908: LD_VAR 0 3
29912: PPUSH
29913: LD_EXP 114
29917: PUSH
29918: LD_VAR 0 2
29922: ARRAY
29923: PPUSH
29924: CALL_OW 113
29928: GO 29882
29930: POP
29931: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29932: LD_ADDR_EXP 92
29936: PUSH
29937: LD_EXP 92
29941: PPUSH
29942: LD_VAR 0 2
29946: PPUSH
29947: EMPTY
29948: PPUSH
29949: CALL_OW 1
29953: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29954: LD_VAR 0 2
29958: PPUSH
29959: LD_INT 101
29961: PPUSH
29962: CALL 24856 0 2
// continue ;
29966: GO 29767
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29968: LD_ADDR_EXP 96
29972: PUSH
29973: LD_EXP 96
29977: PPUSH
29978: LD_VAR 0 2
29982: PPUSH
29983: EMPTY
29984: PPUSH
29985: CALL_OW 1
29989: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29990: LD_VAR 0 2
29994: PPUSH
29995: LD_INT 103
29997: PPUSH
29998: CALL 24856 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30002: LD_ADDR_VAR 0 5
30006: PUSH
30007: LD_EXP 90
30011: PUSH
30012: LD_VAR 0 2
30016: ARRAY
30017: PUSH
30018: LD_EXP 119
30022: PUSH
30023: LD_VAR 0 2
30027: ARRAY
30028: UNION
30029: PPUSH
30030: LD_INT 2
30032: PUSH
30033: LD_INT 25
30035: PUSH
30036: LD_INT 2
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 25
30045: PUSH
30046: LD_INT 16
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: LIST
30057: PUSH
30058: EMPTY
30059: LIST
30060: PPUSH
30061: CALL_OW 72
30065: PUSH
30066: LD_EXP 93
30070: PUSH
30071: LD_VAR 0 2
30075: ARRAY
30076: PUSH
30077: LD_INT 1
30079: ARRAY
30080: PUSH
30081: LD_EXP 93
30085: PUSH
30086: LD_VAR 0 2
30090: ARRAY
30091: PUSH
30092: LD_INT 2
30094: ARRAY
30095: UNION
30096: DIFF
30097: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30098: LD_ADDR_VAR 0 6
30102: PUSH
30103: LD_EXP 109
30107: PUSH
30108: LD_VAR 0 2
30112: ARRAY
30113: PPUSH
30114: LD_INT 2
30116: PUSH
30117: LD_INT 34
30119: PUSH
30120: LD_INT 13
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 34
30129: PUSH
30130: LD_INT 52
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 34
30139: PUSH
30140: LD_EXP 78
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: PPUSH
30155: CALL_OW 72
30159: ST_TO_ADDR
// if cranes then
30160: LD_VAR 0 6
30164: IFFALSE 30300
// begin for j in cranes do
30166: LD_ADDR_VAR 0 3
30170: PUSH
30171: LD_VAR 0 6
30175: PUSH
30176: FOR_IN
30177: IFFALSE 30298
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30179: LD_VAR 0 3
30183: PPUSH
30184: CALL_OW 256
30188: PUSH
30189: LD_INT 1000
30191: EQUAL
30192: PUSH
30193: LD_VAR 0 3
30197: PPUSH
30198: CALL_OW 314
30202: NOT
30203: AND
30204: IFFALSE 30238
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30206: LD_VAR 0 3
30210: PPUSH
30211: LD_EXP 91
30215: PUSH
30216: LD_VAR 0 2
30220: ARRAY
30221: PPUSH
30222: LD_VAR 0 3
30226: PPUSH
30227: CALL_OW 74
30231: PPUSH
30232: CALL_OW 130
30236: GO 30296
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30238: LD_VAR 0 3
30242: PPUSH
30243: CALL_OW 256
30247: PUSH
30248: LD_INT 500
30250: LESS
30251: PUSH
30252: LD_VAR 0 3
30256: PPUSH
30257: LD_EXP 114
30261: PUSH
30262: LD_VAR 0 2
30266: ARRAY
30267: PPUSH
30268: CALL_OW 308
30272: NOT
30273: AND
30274: IFFALSE 30296
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30276: LD_VAR 0 3
30280: PPUSH
30281: LD_EXP 114
30285: PUSH
30286: LD_VAR 0 2
30290: ARRAY
30291: PPUSH
30292: CALL_OW 113
// end ;
30296: GO 30176
30298: POP
30299: POP
// end ; if tmp > 3 then
30300: LD_VAR 0 5
30304: PUSH
30305: LD_INT 3
30307: GREATER
30308: IFFALSE 30328
// tmp := ShrinkArray ( tmp , 4 ) ;
30310: LD_ADDR_VAR 0 5
30314: PUSH
30315: LD_VAR 0 5
30319: PPUSH
30320: LD_INT 4
30322: PPUSH
30323: CALL 87526 0 2
30327: ST_TO_ADDR
// if not tmp then
30328: LD_VAR 0 5
30332: NOT
30333: IFFALSE 30337
// continue ;
30335: GO 29767
// for j in tmp do
30337: LD_ADDR_VAR 0 3
30341: PUSH
30342: LD_VAR 0 5
30346: PUSH
30347: FOR_IN
30348: IFFALSE 30607
// begin if IsInUnit ( j ) then
30350: LD_VAR 0 3
30354: PPUSH
30355: CALL_OW 310
30359: IFFALSE 30370
// ComExitBuilding ( j ) ;
30361: LD_VAR 0 3
30365: PPUSH
30366: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30370: LD_VAR 0 3
30374: PUSH
30375: LD_EXP 92
30379: PUSH
30380: LD_VAR 0 2
30384: ARRAY
30385: IN
30386: NOT
30387: IFFALSE 30445
// begin SetTag ( j , 101 ) ;
30389: LD_VAR 0 3
30393: PPUSH
30394: LD_INT 101
30396: PPUSH
30397: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30401: LD_ADDR_EXP 92
30405: PUSH
30406: LD_EXP 92
30410: PPUSH
30411: LD_VAR 0 2
30415: PUSH
30416: LD_EXP 92
30420: PUSH
30421: LD_VAR 0 2
30425: ARRAY
30426: PUSH
30427: LD_INT 1
30429: PLUS
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PPUSH
30435: LD_VAR 0 3
30439: PPUSH
30440: CALL 55835 0 3
30444: ST_TO_ADDR
// end ; wait ( 1 ) ;
30445: LD_INT 1
30447: PPUSH
30448: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30452: LD_ADDR_VAR 0 7
30456: PUSH
30457: LD_EXP 91
30461: PUSH
30462: LD_VAR 0 2
30466: ARRAY
30467: ST_TO_ADDR
// if mc_scan [ i ] then
30468: LD_EXP 113
30472: PUSH
30473: LD_VAR 0 2
30477: ARRAY
30478: IFFALSE 30540
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30480: LD_ADDR_VAR 0 7
30484: PUSH
30485: LD_EXP 91
30489: PUSH
30490: LD_VAR 0 2
30494: ARRAY
30495: PPUSH
30496: LD_INT 3
30498: PUSH
30499: LD_INT 30
30501: PUSH
30502: LD_INT 32
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: PUSH
30509: LD_INT 30
30511: PUSH
30512: LD_INT 33
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: LD_INT 30
30521: PUSH
30522: LD_INT 31
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: PPUSH
30535: CALL_OW 72
30539: ST_TO_ADDR
// if not to_repair_tmp then
30540: LD_VAR 0 7
30544: NOT
30545: IFFALSE 30549
// continue ;
30547: GO 30347
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30549: LD_ADDR_VAR 0 8
30553: PUSH
30554: LD_VAR 0 7
30558: PPUSH
30559: LD_VAR 0 3
30563: PPUSH
30564: CALL_OW 74
30568: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30569: LD_VAR 0 8
30573: PPUSH
30574: LD_INT 16
30576: PPUSH
30577: CALL 58428 0 2
30581: PUSH
30582: LD_INT 4
30584: ARRAY
30585: PUSH
30586: LD_INT 10
30588: LESS
30589: IFFALSE 30605
// ComRepairBuilding ( j , to_repair ) ;
30591: LD_VAR 0 3
30595: PPUSH
30596: LD_VAR 0 8
30600: PPUSH
30601: CALL_OW 130
// end ;
30605: GO 30347
30607: POP
30608: POP
// end ;
30609: GO 29767
30611: POP
30612: POP
// end ;
30613: LD_VAR 0 1
30617: RET
// export function MC_Heal ; var i , j , tmp ; begin
30618: LD_INT 0
30620: PPUSH
30621: PPUSH
30622: PPUSH
30623: PPUSH
// if not mc_bases then
30624: LD_EXP 90
30628: NOT
30629: IFFALSE 30633
// exit ;
30631: GO 31035
// for i = 1 to mc_bases do
30633: LD_ADDR_VAR 0 2
30637: PUSH
30638: DOUBLE
30639: LD_INT 1
30641: DEC
30642: ST_TO_ADDR
30643: LD_EXP 90
30647: PUSH
30648: FOR_TO
30649: IFFALSE 31033
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30651: LD_EXP 93
30655: PUSH
30656: LD_VAR 0 2
30660: ARRAY
30661: PUSH
30662: LD_INT 1
30664: ARRAY
30665: NOT
30666: PUSH
30667: LD_EXP 93
30671: PUSH
30672: LD_VAR 0 2
30676: ARRAY
30677: PUSH
30678: LD_INT 2
30680: ARRAY
30681: NOT
30682: AND
30683: IFFALSE 30721
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30685: LD_ADDR_EXP 94
30689: PUSH
30690: LD_EXP 94
30694: PPUSH
30695: LD_VAR 0 2
30699: PPUSH
30700: EMPTY
30701: PPUSH
30702: CALL_OW 1
30706: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30707: LD_VAR 0 2
30711: PPUSH
30712: LD_INT 102
30714: PPUSH
30715: CALL 24856 0 2
// continue ;
30719: GO 30648
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30721: LD_ADDR_VAR 0 4
30725: PUSH
30726: LD_EXP 90
30730: PUSH
30731: LD_VAR 0 2
30735: ARRAY
30736: PPUSH
30737: LD_INT 25
30739: PUSH
30740: LD_INT 4
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PPUSH
30747: CALL_OW 72
30751: ST_TO_ADDR
// if not tmp then
30752: LD_VAR 0 4
30756: NOT
30757: IFFALSE 30761
// continue ;
30759: GO 30648
// if mc_taming [ i ] then
30761: LD_EXP 121
30765: PUSH
30766: LD_VAR 0 2
30770: ARRAY
30771: IFFALSE 30795
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30773: LD_ADDR_EXP 121
30777: PUSH
30778: LD_EXP 121
30782: PPUSH
30783: LD_VAR 0 2
30787: PPUSH
30788: EMPTY
30789: PPUSH
30790: CALL_OW 1
30794: ST_TO_ADDR
// for j in tmp do
30795: LD_ADDR_VAR 0 3
30799: PUSH
30800: LD_VAR 0 4
30804: PUSH
30805: FOR_IN
30806: IFFALSE 31029
// begin if IsInUnit ( j ) then
30808: LD_VAR 0 3
30812: PPUSH
30813: CALL_OW 310
30817: IFFALSE 30828
// ComExitBuilding ( j ) ;
30819: LD_VAR 0 3
30823: PPUSH
30824: CALL_OW 122
// if not j in mc_healers [ i ] then
30828: LD_VAR 0 3
30832: PUSH
30833: LD_EXP 94
30837: PUSH
30838: LD_VAR 0 2
30842: ARRAY
30843: IN
30844: NOT
30845: IFFALSE 30891
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30847: LD_ADDR_EXP 94
30851: PUSH
30852: LD_EXP 94
30856: PPUSH
30857: LD_VAR 0 2
30861: PUSH
30862: LD_EXP 94
30866: PUSH
30867: LD_VAR 0 2
30871: ARRAY
30872: PUSH
30873: LD_INT 1
30875: PLUS
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PPUSH
30881: LD_VAR 0 3
30885: PPUSH
30886: CALL 55835 0 3
30890: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30891: LD_VAR 0 3
30895: PPUSH
30896: CALL_OW 110
30900: PUSH
30901: LD_INT 102
30903: NONEQUAL
30904: IFFALSE 30918
// SetTag ( j , 102 ) ;
30906: LD_VAR 0 3
30910: PPUSH
30911: LD_INT 102
30913: PPUSH
30914: CALL_OW 109
// Wait ( 3 ) ;
30918: LD_INT 3
30920: PPUSH
30921: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30925: LD_EXP 93
30929: PUSH
30930: LD_VAR 0 2
30934: ARRAY
30935: PUSH
30936: LD_INT 1
30938: ARRAY
30939: IFFALSE 30971
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30941: LD_VAR 0 3
30945: PPUSH
30946: LD_EXP 93
30950: PUSH
30951: LD_VAR 0 2
30955: ARRAY
30956: PUSH
30957: LD_INT 1
30959: ARRAY
30960: PUSH
30961: LD_INT 1
30963: ARRAY
30964: PPUSH
30965: CALL_OW 128
30969: GO 31027
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30971: LD_VAR 0 3
30975: PPUSH
30976: CALL_OW 314
30980: NOT
30981: PUSH
30982: LD_EXP 93
30986: PUSH
30987: LD_VAR 0 2
30991: ARRAY
30992: PUSH
30993: LD_INT 2
30995: ARRAY
30996: AND
30997: IFFALSE 31027
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30999: LD_VAR 0 3
31003: PPUSH
31004: LD_EXP 93
31008: PUSH
31009: LD_VAR 0 2
31013: ARRAY
31014: PUSH
31015: LD_INT 2
31017: ARRAY
31018: PUSH
31019: LD_INT 1
31021: ARRAY
31022: PPUSH
31023: CALL_OW 128
// end ;
31027: GO 30805
31029: POP
31030: POP
// end ;
31031: GO 30648
31033: POP
31034: POP
// end ;
31035: LD_VAR 0 1
31039: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31040: LD_INT 0
31042: PPUSH
31043: PPUSH
31044: PPUSH
31045: PPUSH
31046: PPUSH
// if not mc_bases then
31047: LD_EXP 90
31051: NOT
31052: IFFALSE 31056
// exit ;
31054: GO 32227
// for i = 1 to mc_bases do
31056: LD_ADDR_VAR 0 2
31060: PUSH
31061: DOUBLE
31062: LD_INT 1
31064: DEC
31065: ST_TO_ADDR
31066: LD_EXP 90
31070: PUSH
31071: FOR_TO
31072: IFFALSE 32225
// begin if mc_scan [ i ] then
31074: LD_EXP 113
31078: PUSH
31079: LD_VAR 0 2
31083: ARRAY
31084: IFFALSE 31088
// continue ;
31086: GO 31071
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31088: LD_EXP 95
31092: PUSH
31093: LD_VAR 0 2
31097: ARRAY
31098: NOT
31099: PUSH
31100: LD_EXP 97
31104: PUSH
31105: LD_VAR 0 2
31109: ARRAY
31110: NOT
31111: AND
31112: PUSH
31113: LD_EXP 96
31117: PUSH
31118: LD_VAR 0 2
31122: ARRAY
31123: AND
31124: IFFALSE 31162
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31126: LD_ADDR_EXP 96
31130: PUSH
31131: LD_EXP 96
31135: PPUSH
31136: LD_VAR 0 2
31140: PPUSH
31141: EMPTY
31142: PPUSH
31143: CALL_OW 1
31147: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31148: LD_VAR 0 2
31152: PPUSH
31153: LD_INT 103
31155: PPUSH
31156: CALL 24856 0 2
// continue ;
31160: GO 31071
// end ; if mc_construct_list [ i ] then
31162: LD_EXP 97
31166: PUSH
31167: LD_VAR 0 2
31171: ARRAY
31172: IFFALSE 31392
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31174: LD_ADDR_VAR 0 4
31178: PUSH
31179: LD_EXP 90
31183: PUSH
31184: LD_VAR 0 2
31188: ARRAY
31189: PPUSH
31190: LD_INT 25
31192: PUSH
31193: LD_INT 2
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: PPUSH
31200: CALL_OW 72
31204: PUSH
31205: LD_EXP 92
31209: PUSH
31210: LD_VAR 0 2
31214: ARRAY
31215: DIFF
31216: ST_TO_ADDR
// if not tmp then
31217: LD_VAR 0 4
31221: NOT
31222: IFFALSE 31226
// continue ;
31224: GO 31071
// for j in tmp do
31226: LD_ADDR_VAR 0 3
31230: PUSH
31231: LD_VAR 0 4
31235: PUSH
31236: FOR_IN
31237: IFFALSE 31388
// begin if not mc_builders [ i ] then
31239: LD_EXP 96
31243: PUSH
31244: LD_VAR 0 2
31248: ARRAY
31249: NOT
31250: IFFALSE 31308
// begin SetTag ( j , 103 ) ;
31252: LD_VAR 0 3
31256: PPUSH
31257: LD_INT 103
31259: PPUSH
31260: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31264: LD_ADDR_EXP 96
31268: PUSH
31269: LD_EXP 96
31273: PPUSH
31274: LD_VAR 0 2
31278: PUSH
31279: LD_EXP 96
31283: PUSH
31284: LD_VAR 0 2
31288: ARRAY
31289: PUSH
31290: LD_INT 1
31292: PLUS
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: PPUSH
31298: LD_VAR 0 3
31302: PPUSH
31303: CALL 55835 0 3
31307: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31308: LD_VAR 0 3
31312: PPUSH
31313: CALL_OW 310
31317: IFFALSE 31328
// ComExitBuilding ( j ) ;
31319: LD_VAR 0 3
31323: PPUSH
31324: CALL_OW 122
// wait ( 3 ) ;
31328: LD_INT 3
31330: PPUSH
31331: CALL_OW 67
// if not mc_construct_list [ i ] then
31335: LD_EXP 97
31339: PUSH
31340: LD_VAR 0 2
31344: ARRAY
31345: NOT
31346: IFFALSE 31350
// break ;
31348: GO 31388
// if not HasTask ( j ) then
31350: LD_VAR 0 3
31354: PPUSH
31355: CALL_OW 314
31359: NOT
31360: IFFALSE 31386
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31362: LD_VAR 0 3
31366: PPUSH
31367: LD_EXP 97
31371: PUSH
31372: LD_VAR 0 2
31376: ARRAY
31377: PUSH
31378: LD_INT 1
31380: ARRAY
31381: PPUSH
31382: CALL 58692 0 2
// end ;
31386: GO 31236
31388: POP
31389: POP
// end else
31390: GO 32223
// if mc_build_list [ i ] then
31392: LD_EXP 95
31396: PUSH
31397: LD_VAR 0 2
31401: ARRAY
31402: IFFALSE 32223
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31404: LD_ADDR_VAR 0 5
31408: PUSH
31409: LD_EXP 90
31413: PUSH
31414: LD_VAR 0 2
31418: ARRAY
31419: PPUSH
31420: LD_INT 2
31422: PUSH
31423: LD_INT 30
31425: PUSH
31426: LD_INT 0
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 30
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: LIST
31447: PPUSH
31448: CALL_OW 72
31452: ST_TO_ADDR
// if depot then
31453: LD_VAR 0 5
31457: IFFALSE 31475
// depot := depot [ 1 ] else
31459: LD_ADDR_VAR 0 5
31463: PUSH
31464: LD_VAR 0 5
31468: PUSH
31469: LD_INT 1
31471: ARRAY
31472: ST_TO_ADDR
31473: GO 31483
// depot := 0 ;
31475: LD_ADDR_VAR 0 5
31479: PUSH
31480: LD_INT 0
31482: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31483: LD_EXP 95
31487: PUSH
31488: LD_VAR 0 2
31492: ARRAY
31493: PUSH
31494: LD_INT 1
31496: ARRAY
31497: PUSH
31498: LD_INT 1
31500: ARRAY
31501: PPUSH
31502: CALL 58516 0 1
31506: PUSH
31507: LD_EXP 90
31511: PUSH
31512: LD_VAR 0 2
31516: ARRAY
31517: PPUSH
31518: LD_INT 2
31520: PUSH
31521: LD_INT 30
31523: PUSH
31524: LD_INT 2
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: LD_INT 30
31533: PUSH
31534: LD_INT 3
31536: PUSH
31537: EMPTY
31538: LIST
31539: LIST
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: LIST
31545: PPUSH
31546: CALL_OW 72
31550: NOT
31551: AND
31552: IFFALSE 31657
// begin for j = 1 to mc_build_list [ i ] do
31554: LD_ADDR_VAR 0 3
31558: PUSH
31559: DOUBLE
31560: LD_INT 1
31562: DEC
31563: ST_TO_ADDR
31564: LD_EXP 95
31568: PUSH
31569: LD_VAR 0 2
31573: ARRAY
31574: PUSH
31575: FOR_TO
31576: IFFALSE 31655
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31578: LD_EXP 95
31582: PUSH
31583: LD_VAR 0 2
31587: ARRAY
31588: PUSH
31589: LD_VAR 0 3
31593: ARRAY
31594: PUSH
31595: LD_INT 1
31597: ARRAY
31598: PUSH
31599: LD_INT 2
31601: EQUAL
31602: IFFALSE 31653
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31604: LD_ADDR_EXP 95
31608: PUSH
31609: LD_EXP 95
31613: PPUSH
31614: LD_VAR 0 2
31618: PPUSH
31619: LD_EXP 95
31623: PUSH
31624: LD_VAR 0 2
31628: ARRAY
31629: PPUSH
31630: LD_VAR 0 3
31634: PPUSH
31635: LD_INT 1
31637: PPUSH
31638: LD_INT 0
31640: PPUSH
31641: CALL 55253 0 4
31645: PPUSH
31646: CALL_OW 1
31650: ST_TO_ADDR
// break ;
31651: GO 31655
// end ;
31653: GO 31575
31655: POP
31656: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31657: LD_EXP 95
31661: PUSH
31662: LD_VAR 0 2
31666: ARRAY
31667: PUSH
31668: LD_INT 1
31670: ARRAY
31671: PUSH
31672: LD_INT 1
31674: ARRAY
31675: PUSH
31676: LD_INT 0
31678: EQUAL
31679: PUSH
31680: LD_VAR 0 5
31684: PUSH
31685: LD_VAR 0 5
31689: PPUSH
31690: LD_EXP 95
31694: PUSH
31695: LD_VAR 0 2
31699: ARRAY
31700: PUSH
31701: LD_INT 1
31703: ARRAY
31704: PUSH
31705: LD_INT 1
31707: ARRAY
31708: PPUSH
31709: LD_EXP 95
31713: PUSH
31714: LD_VAR 0 2
31718: ARRAY
31719: PUSH
31720: LD_INT 1
31722: ARRAY
31723: PUSH
31724: LD_INT 2
31726: ARRAY
31727: PPUSH
31728: LD_EXP 95
31732: PUSH
31733: LD_VAR 0 2
31737: ARRAY
31738: PUSH
31739: LD_INT 1
31741: ARRAY
31742: PUSH
31743: LD_INT 3
31745: ARRAY
31746: PPUSH
31747: LD_EXP 95
31751: PUSH
31752: LD_VAR 0 2
31756: ARRAY
31757: PUSH
31758: LD_INT 1
31760: ARRAY
31761: PUSH
31762: LD_INT 4
31764: ARRAY
31765: PPUSH
31766: CALL 63583 0 5
31770: AND
31771: OR
31772: IFFALSE 32053
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31774: LD_ADDR_VAR 0 4
31778: PUSH
31779: LD_EXP 90
31783: PUSH
31784: LD_VAR 0 2
31788: ARRAY
31789: PPUSH
31790: LD_INT 25
31792: PUSH
31793: LD_INT 2
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PPUSH
31800: CALL_OW 72
31804: PUSH
31805: LD_EXP 92
31809: PUSH
31810: LD_VAR 0 2
31814: ARRAY
31815: DIFF
31816: ST_TO_ADDR
// if not tmp then
31817: LD_VAR 0 4
31821: NOT
31822: IFFALSE 31826
// continue ;
31824: GO 31071
// for j in tmp do
31826: LD_ADDR_VAR 0 3
31830: PUSH
31831: LD_VAR 0 4
31835: PUSH
31836: FOR_IN
31837: IFFALSE 32049
// begin if not mc_builders [ i ] then
31839: LD_EXP 96
31843: PUSH
31844: LD_VAR 0 2
31848: ARRAY
31849: NOT
31850: IFFALSE 31908
// begin SetTag ( j , 103 ) ;
31852: LD_VAR 0 3
31856: PPUSH
31857: LD_INT 103
31859: PPUSH
31860: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31864: LD_ADDR_EXP 96
31868: PUSH
31869: LD_EXP 96
31873: PPUSH
31874: LD_VAR 0 2
31878: PUSH
31879: LD_EXP 96
31883: PUSH
31884: LD_VAR 0 2
31888: ARRAY
31889: PUSH
31890: LD_INT 1
31892: PLUS
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PPUSH
31898: LD_VAR 0 3
31902: PPUSH
31903: CALL 55835 0 3
31907: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31908: LD_VAR 0 3
31912: PPUSH
31913: CALL_OW 310
31917: IFFALSE 31928
// ComExitBuilding ( j ) ;
31919: LD_VAR 0 3
31923: PPUSH
31924: CALL_OW 122
// wait ( 3 ) ;
31928: LD_INT 3
31930: PPUSH
31931: CALL_OW 67
// if not mc_build_list [ i ] then
31935: LD_EXP 95
31939: PUSH
31940: LD_VAR 0 2
31944: ARRAY
31945: NOT
31946: IFFALSE 31950
// break ;
31948: GO 32049
// if not HasTask ( j ) then
31950: LD_VAR 0 3
31954: PPUSH
31955: CALL_OW 314
31959: NOT
31960: IFFALSE 32047
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31962: LD_VAR 0 3
31966: PPUSH
31967: LD_EXP 95
31971: PUSH
31972: LD_VAR 0 2
31976: ARRAY
31977: PUSH
31978: LD_INT 1
31980: ARRAY
31981: PUSH
31982: LD_INT 1
31984: ARRAY
31985: PPUSH
31986: LD_EXP 95
31990: PUSH
31991: LD_VAR 0 2
31995: ARRAY
31996: PUSH
31997: LD_INT 1
31999: ARRAY
32000: PUSH
32001: LD_INT 2
32003: ARRAY
32004: PPUSH
32005: LD_EXP 95
32009: PUSH
32010: LD_VAR 0 2
32014: ARRAY
32015: PUSH
32016: LD_INT 1
32018: ARRAY
32019: PUSH
32020: LD_INT 3
32022: ARRAY
32023: PPUSH
32024: LD_EXP 95
32028: PUSH
32029: LD_VAR 0 2
32033: ARRAY
32034: PUSH
32035: LD_INT 1
32037: ARRAY
32038: PUSH
32039: LD_INT 4
32041: ARRAY
32042: PPUSH
32043: CALL_OW 145
// end ;
32047: GO 31836
32049: POP
32050: POP
// end else
32051: GO 32223
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32053: LD_EXP 90
32057: PUSH
32058: LD_VAR 0 2
32062: ARRAY
32063: PPUSH
32064: LD_EXP 95
32068: PUSH
32069: LD_VAR 0 2
32073: ARRAY
32074: PUSH
32075: LD_INT 1
32077: ARRAY
32078: PUSH
32079: LD_INT 1
32081: ARRAY
32082: PPUSH
32083: LD_EXP 95
32087: PUSH
32088: LD_VAR 0 2
32092: ARRAY
32093: PUSH
32094: LD_INT 1
32096: ARRAY
32097: PUSH
32098: LD_INT 2
32100: ARRAY
32101: PPUSH
32102: LD_EXP 95
32106: PUSH
32107: LD_VAR 0 2
32111: ARRAY
32112: PUSH
32113: LD_INT 1
32115: ARRAY
32116: PUSH
32117: LD_INT 3
32119: ARRAY
32120: PPUSH
32121: LD_EXP 95
32125: PUSH
32126: LD_VAR 0 2
32130: ARRAY
32131: PUSH
32132: LD_INT 1
32134: ARRAY
32135: PUSH
32136: LD_INT 4
32138: ARRAY
32139: PPUSH
32140: LD_EXP 90
32144: PUSH
32145: LD_VAR 0 2
32149: ARRAY
32150: PPUSH
32151: LD_INT 21
32153: PUSH
32154: LD_INT 3
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: PPUSH
32161: CALL_OW 72
32165: PPUSH
32166: EMPTY
32167: PPUSH
32168: CALL 62713 0 7
32172: NOT
32173: IFFALSE 32223
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32175: LD_ADDR_EXP 95
32179: PUSH
32180: LD_EXP 95
32184: PPUSH
32185: LD_VAR 0 2
32189: PPUSH
32190: LD_EXP 95
32194: PUSH
32195: LD_VAR 0 2
32199: ARRAY
32200: PPUSH
32201: LD_INT 1
32203: PPUSH
32204: LD_INT 1
32206: NEG
32207: PPUSH
32208: LD_INT 0
32210: PPUSH
32211: CALL 55253 0 4
32215: PPUSH
32216: CALL_OW 1
32220: ST_TO_ADDR
// continue ;
32221: GO 31071
// end ; end ; end ;
32223: GO 31071
32225: POP
32226: POP
// end ;
32227: LD_VAR 0 1
32231: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32232: LD_INT 0
32234: PPUSH
32235: PPUSH
32236: PPUSH
32237: PPUSH
32238: PPUSH
32239: PPUSH
// if not mc_bases then
32240: LD_EXP 90
32244: NOT
32245: IFFALSE 32249
// exit ;
32247: GO 32676
// for i = 1 to mc_bases do
32249: LD_ADDR_VAR 0 2
32253: PUSH
32254: DOUBLE
32255: LD_INT 1
32257: DEC
32258: ST_TO_ADDR
32259: LD_EXP 90
32263: PUSH
32264: FOR_TO
32265: IFFALSE 32674
// begin tmp := mc_build_upgrade [ i ] ;
32267: LD_ADDR_VAR 0 4
32271: PUSH
32272: LD_EXP 122
32276: PUSH
32277: LD_VAR 0 2
32281: ARRAY
32282: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32283: LD_ADDR_VAR 0 6
32287: PUSH
32288: LD_EXP 123
32292: PUSH
32293: LD_VAR 0 2
32297: ARRAY
32298: PPUSH
32299: LD_INT 2
32301: PUSH
32302: LD_INT 30
32304: PUSH
32305: LD_INT 6
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: LD_INT 30
32314: PUSH
32315: LD_INT 7
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: EMPTY
32323: LIST
32324: LIST
32325: LIST
32326: PPUSH
32327: CALL_OW 72
32331: ST_TO_ADDR
// if not tmp and not lab then
32332: LD_VAR 0 4
32336: NOT
32337: PUSH
32338: LD_VAR 0 6
32342: NOT
32343: AND
32344: IFFALSE 32348
// continue ;
32346: GO 32264
// if tmp then
32348: LD_VAR 0 4
32352: IFFALSE 32472
// for j in tmp do
32354: LD_ADDR_VAR 0 3
32358: PUSH
32359: LD_VAR 0 4
32363: PUSH
32364: FOR_IN
32365: IFFALSE 32470
// begin if UpgradeCost ( j ) then
32367: LD_VAR 0 3
32371: PPUSH
32372: CALL 62373 0 1
32376: IFFALSE 32468
// begin ComUpgrade ( j ) ;
32378: LD_VAR 0 3
32382: PPUSH
32383: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32387: LD_ADDR_EXP 122
32391: PUSH
32392: LD_EXP 122
32396: PPUSH
32397: LD_VAR 0 2
32401: PPUSH
32402: LD_EXP 122
32406: PUSH
32407: LD_VAR 0 2
32411: ARRAY
32412: PUSH
32413: LD_VAR 0 3
32417: DIFF
32418: PPUSH
32419: CALL_OW 1
32423: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32424: LD_ADDR_EXP 97
32428: PUSH
32429: LD_EXP 97
32433: PPUSH
32434: LD_VAR 0 2
32438: PUSH
32439: LD_EXP 97
32443: PUSH
32444: LD_VAR 0 2
32448: ARRAY
32449: PUSH
32450: LD_INT 1
32452: PLUS
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PPUSH
32458: LD_VAR 0 3
32462: PPUSH
32463: CALL 55835 0 3
32467: ST_TO_ADDR
// end ; end ;
32468: GO 32364
32470: POP
32471: POP
// if not lab or not mc_lab_upgrade [ i ] then
32472: LD_VAR 0 6
32476: NOT
32477: PUSH
32478: LD_EXP 124
32482: PUSH
32483: LD_VAR 0 2
32487: ARRAY
32488: NOT
32489: OR
32490: IFFALSE 32494
// continue ;
32492: GO 32264
// for j in lab do
32494: LD_ADDR_VAR 0 3
32498: PUSH
32499: LD_VAR 0 6
32503: PUSH
32504: FOR_IN
32505: IFFALSE 32670
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32507: LD_VAR 0 3
32511: PPUSH
32512: CALL_OW 266
32516: PUSH
32517: LD_INT 6
32519: PUSH
32520: LD_INT 7
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: IN
32527: PUSH
32528: LD_VAR 0 3
32532: PPUSH
32533: CALL_OW 461
32537: PUSH
32538: LD_INT 1
32540: NONEQUAL
32541: AND
32542: IFFALSE 32668
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32544: LD_VAR 0 3
32548: PPUSH
32549: LD_EXP 124
32553: PUSH
32554: LD_VAR 0 2
32558: ARRAY
32559: PUSH
32560: LD_INT 1
32562: ARRAY
32563: PPUSH
32564: CALL 62578 0 2
32568: IFFALSE 32668
// begin ComCancel ( j ) ;
32570: LD_VAR 0 3
32574: PPUSH
32575: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32579: LD_VAR 0 3
32583: PPUSH
32584: LD_EXP 124
32588: PUSH
32589: LD_VAR 0 2
32593: ARRAY
32594: PUSH
32595: LD_INT 1
32597: ARRAY
32598: PPUSH
32599: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32603: LD_VAR 0 3
32607: PUSH
32608: LD_EXP 97
32612: PUSH
32613: LD_VAR 0 2
32617: ARRAY
32618: IN
32619: NOT
32620: IFFALSE 32666
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32622: LD_ADDR_EXP 97
32626: PUSH
32627: LD_EXP 97
32631: PPUSH
32632: LD_VAR 0 2
32636: PUSH
32637: LD_EXP 97
32641: PUSH
32642: LD_VAR 0 2
32646: ARRAY
32647: PUSH
32648: LD_INT 1
32650: PLUS
32651: PUSH
32652: EMPTY
32653: LIST
32654: LIST
32655: PPUSH
32656: LD_VAR 0 3
32660: PPUSH
32661: CALL 55835 0 3
32665: ST_TO_ADDR
// break ;
32666: GO 32670
// end ; end ; end ;
32668: GO 32504
32670: POP
32671: POP
// end ;
32672: GO 32264
32674: POP
32675: POP
// end ;
32676: LD_VAR 0 1
32680: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32681: LD_INT 0
32683: PPUSH
32684: PPUSH
32685: PPUSH
32686: PPUSH
32687: PPUSH
32688: PPUSH
32689: PPUSH
32690: PPUSH
32691: PPUSH
// if not mc_bases then
32692: LD_EXP 90
32696: NOT
32697: IFFALSE 32701
// exit ;
32699: GO 33106
// for i = 1 to mc_bases do
32701: LD_ADDR_VAR 0 2
32705: PUSH
32706: DOUBLE
32707: LD_INT 1
32709: DEC
32710: ST_TO_ADDR
32711: LD_EXP 90
32715: PUSH
32716: FOR_TO
32717: IFFALSE 33104
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32719: LD_EXP 98
32723: PUSH
32724: LD_VAR 0 2
32728: ARRAY
32729: NOT
32730: PUSH
32731: LD_EXP 90
32735: PUSH
32736: LD_VAR 0 2
32740: ARRAY
32741: PPUSH
32742: LD_INT 30
32744: PUSH
32745: LD_INT 3
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PPUSH
32752: CALL_OW 72
32756: NOT
32757: OR
32758: IFFALSE 32762
// continue ;
32760: GO 32716
// busy := false ;
32762: LD_ADDR_VAR 0 8
32766: PUSH
32767: LD_INT 0
32769: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32770: LD_ADDR_VAR 0 4
32774: PUSH
32775: LD_EXP 90
32779: PUSH
32780: LD_VAR 0 2
32784: ARRAY
32785: PPUSH
32786: LD_INT 30
32788: PUSH
32789: LD_INT 3
32791: PUSH
32792: EMPTY
32793: LIST
32794: LIST
32795: PPUSH
32796: CALL_OW 72
32800: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32801: LD_ADDR_VAR 0 6
32805: PUSH
32806: LD_EXP 98
32810: PUSH
32811: LD_VAR 0 2
32815: ARRAY
32816: PPUSH
32817: LD_INT 2
32819: PUSH
32820: LD_INT 30
32822: PUSH
32823: LD_INT 32
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 30
32832: PUSH
32833: LD_INT 33
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: LIST
32844: PPUSH
32845: CALL_OW 72
32849: ST_TO_ADDR
// if not t then
32850: LD_VAR 0 6
32854: NOT
32855: IFFALSE 32859
// continue ;
32857: GO 32716
// for j in tmp do
32859: LD_ADDR_VAR 0 3
32863: PUSH
32864: LD_VAR 0 4
32868: PUSH
32869: FOR_IN
32870: IFFALSE 32900
// if not BuildingStatus ( j ) = bs_idle then
32872: LD_VAR 0 3
32876: PPUSH
32877: CALL_OW 461
32881: PUSH
32882: LD_INT 2
32884: EQUAL
32885: NOT
32886: IFFALSE 32898
// begin busy := true ;
32888: LD_ADDR_VAR 0 8
32892: PUSH
32893: LD_INT 1
32895: ST_TO_ADDR
// break ;
32896: GO 32900
// end ;
32898: GO 32869
32900: POP
32901: POP
// if busy then
32902: LD_VAR 0 8
32906: IFFALSE 32910
// continue ;
32908: GO 32716
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32910: LD_ADDR_VAR 0 7
32914: PUSH
32915: LD_VAR 0 6
32919: PPUSH
32920: LD_INT 35
32922: PUSH
32923: LD_INT 0
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PPUSH
32930: CALL_OW 72
32934: ST_TO_ADDR
// if tw then
32935: LD_VAR 0 7
32939: IFFALSE 33016
// begin tw := tw [ 1 ] ;
32941: LD_ADDR_VAR 0 7
32945: PUSH
32946: LD_VAR 0 7
32950: PUSH
32951: LD_INT 1
32953: ARRAY
32954: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32955: LD_ADDR_VAR 0 9
32959: PUSH
32960: LD_VAR 0 7
32964: PPUSH
32965: LD_EXP 115
32969: PUSH
32970: LD_VAR 0 2
32974: ARRAY
32975: PPUSH
32976: CALL 60840 0 2
32980: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32981: LD_EXP 129
32985: PUSH
32986: LD_VAR 0 2
32990: ARRAY
32991: IFFALSE 33014
// if not weapon in mc_allowed_tower_weapons [ i ] then
32993: LD_VAR 0 9
32997: PUSH
32998: LD_EXP 129
33002: PUSH
33003: LD_VAR 0 2
33007: ARRAY
33008: IN
33009: NOT
33010: IFFALSE 33014
// continue ;
33012: GO 32716
// end else
33014: GO 33079
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33016: LD_ADDR_VAR 0 5
33020: PUSH
33021: LD_EXP 98
33025: PUSH
33026: LD_VAR 0 2
33030: ARRAY
33031: PPUSH
33032: LD_VAR 0 4
33036: PPUSH
33037: CALL 86759 0 2
33041: ST_TO_ADDR
// if not tmp2 then
33042: LD_VAR 0 5
33046: NOT
33047: IFFALSE 33051
// continue ;
33049: GO 32716
// tw := tmp2 [ 1 ] ;
33051: LD_ADDR_VAR 0 7
33055: PUSH
33056: LD_VAR 0 5
33060: PUSH
33061: LD_INT 1
33063: ARRAY
33064: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33065: LD_ADDR_VAR 0 9
33069: PUSH
33070: LD_VAR 0 5
33074: PUSH
33075: LD_INT 2
33077: ARRAY
33078: ST_TO_ADDR
// end ; if not weapon then
33079: LD_VAR 0 9
33083: NOT
33084: IFFALSE 33088
// continue ;
33086: GO 32716
// ComPlaceWeapon ( tw , weapon ) ;
33088: LD_VAR 0 7
33092: PPUSH
33093: LD_VAR 0 9
33097: PPUSH
33098: CALL_OW 148
// end ;
33102: GO 32716
33104: POP
33105: POP
// end ;
33106: LD_VAR 0 1
33110: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33111: LD_INT 0
33113: PPUSH
33114: PPUSH
33115: PPUSH
33116: PPUSH
33117: PPUSH
33118: PPUSH
33119: PPUSH
// if not mc_bases then
33120: LD_EXP 90
33124: NOT
33125: IFFALSE 33129
// exit ;
33127: GO 33897
// for i = 1 to mc_bases do
33129: LD_ADDR_VAR 0 2
33133: PUSH
33134: DOUBLE
33135: LD_INT 1
33137: DEC
33138: ST_TO_ADDR
33139: LD_EXP 90
33143: PUSH
33144: FOR_TO
33145: IFFALSE 33895
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33147: LD_EXP 103
33151: PUSH
33152: LD_VAR 0 2
33156: ARRAY
33157: NOT
33158: PUSH
33159: LD_EXP 103
33163: PUSH
33164: LD_VAR 0 2
33168: ARRAY
33169: PUSH
33170: LD_EXP 104
33174: PUSH
33175: LD_VAR 0 2
33179: ARRAY
33180: EQUAL
33181: OR
33182: PUSH
33183: LD_EXP 113
33187: PUSH
33188: LD_VAR 0 2
33192: ARRAY
33193: OR
33194: IFFALSE 33198
// continue ;
33196: GO 33144
// if mc_miners [ i ] then
33198: LD_EXP 104
33202: PUSH
33203: LD_VAR 0 2
33207: ARRAY
33208: IFFALSE 33582
// begin for j = mc_miners [ i ] downto 1 do
33210: LD_ADDR_VAR 0 3
33214: PUSH
33215: DOUBLE
33216: LD_EXP 104
33220: PUSH
33221: LD_VAR 0 2
33225: ARRAY
33226: INC
33227: ST_TO_ADDR
33228: LD_INT 1
33230: PUSH
33231: FOR_DOWNTO
33232: IFFALSE 33580
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33234: LD_EXP 104
33238: PUSH
33239: LD_VAR 0 2
33243: ARRAY
33244: PUSH
33245: LD_VAR 0 3
33249: ARRAY
33250: PPUSH
33251: CALL_OW 301
33255: PUSH
33256: LD_EXP 104
33260: PUSH
33261: LD_VAR 0 2
33265: ARRAY
33266: PUSH
33267: LD_VAR 0 3
33271: ARRAY
33272: PPUSH
33273: CALL_OW 257
33277: PUSH
33278: LD_INT 1
33280: NONEQUAL
33281: OR
33282: IFFALSE 33345
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33284: LD_ADDR_VAR 0 5
33288: PUSH
33289: LD_EXP 104
33293: PUSH
33294: LD_VAR 0 2
33298: ARRAY
33299: PUSH
33300: LD_EXP 104
33304: PUSH
33305: LD_VAR 0 2
33309: ARRAY
33310: PUSH
33311: LD_VAR 0 3
33315: ARRAY
33316: DIFF
33317: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33318: LD_ADDR_EXP 104
33322: PUSH
33323: LD_EXP 104
33327: PPUSH
33328: LD_VAR 0 2
33332: PPUSH
33333: LD_VAR 0 5
33337: PPUSH
33338: CALL_OW 1
33342: ST_TO_ADDR
// continue ;
33343: GO 33231
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33345: LD_EXP 104
33349: PUSH
33350: LD_VAR 0 2
33354: ARRAY
33355: PUSH
33356: LD_VAR 0 3
33360: ARRAY
33361: PPUSH
33362: CALL_OW 257
33366: PUSH
33367: LD_INT 1
33369: EQUAL
33370: PUSH
33371: LD_EXP 104
33375: PUSH
33376: LD_VAR 0 2
33380: ARRAY
33381: PUSH
33382: LD_VAR 0 3
33386: ARRAY
33387: PPUSH
33388: CALL_OW 459
33392: NOT
33393: AND
33394: PUSH
33395: LD_EXP 104
33399: PUSH
33400: LD_VAR 0 2
33404: ARRAY
33405: PUSH
33406: LD_VAR 0 3
33410: ARRAY
33411: PPUSH
33412: CALL_OW 314
33416: NOT
33417: AND
33418: IFFALSE 33578
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33420: LD_EXP 104
33424: PUSH
33425: LD_VAR 0 2
33429: ARRAY
33430: PUSH
33431: LD_VAR 0 3
33435: ARRAY
33436: PPUSH
33437: CALL_OW 310
33441: IFFALSE 33464
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33443: LD_EXP 104
33447: PUSH
33448: LD_VAR 0 2
33452: ARRAY
33453: PUSH
33454: LD_VAR 0 3
33458: ARRAY
33459: PPUSH
33460: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33464: LD_EXP 104
33468: PUSH
33469: LD_VAR 0 2
33473: ARRAY
33474: PUSH
33475: LD_VAR 0 3
33479: ARRAY
33480: PPUSH
33481: CALL_OW 314
33485: NOT
33486: IFFALSE 33578
// begin r := rand ( 1 , mc_mines [ i ] ) ;
33488: LD_ADDR_VAR 0 7
33492: PUSH
33493: LD_INT 1
33495: PPUSH
33496: LD_EXP 103
33500: PUSH
33501: LD_VAR 0 2
33505: ARRAY
33506: PPUSH
33507: CALL_OW 12
33511: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
33512: LD_EXP 104
33516: PUSH
33517: LD_VAR 0 2
33521: ARRAY
33522: PUSH
33523: LD_VAR 0 3
33527: ARRAY
33528: PPUSH
33529: LD_EXP 103
33533: PUSH
33534: LD_VAR 0 2
33538: ARRAY
33539: PUSH
33540: LD_VAR 0 7
33544: ARRAY
33545: PUSH
33546: LD_INT 1
33548: ARRAY
33549: PPUSH
33550: LD_EXP 103
33554: PUSH
33555: LD_VAR 0 2
33559: ARRAY
33560: PUSH
33561: LD_VAR 0 7
33565: ARRAY
33566: PUSH
33567: LD_INT 2
33569: ARRAY
33570: PPUSH
33571: LD_INT 0
33573: PPUSH
33574: CALL_OW 193
// end ; end ; end ;
33578: GO 33231
33580: POP
33581: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33582: LD_ADDR_VAR 0 5
33586: PUSH
33587: LD_EXP 90
33591: PUSH
33592: LD_VAR 0 2
33596: ARRAY
33597: PPUSH
33598: LD_INT 2
33600: PUSH
33601: LD_INT 30
33603: PUSH
33604: LD_INT 4
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: LD_INT 30
33613: PUSH
33614: LD_INT 5
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 30
33623: PUSH
33624: LD_INT 32
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: LIST
33635: LIST
33636: PPUSH
33637: CALL_OW 72
33641: ST_TO_ADDR
// if not tmp then
33642: LD_VAR 0 5
33646: NOT
33647: IFFALSE 33651
// continue ;
33649: GO 33144
// list := [ ] ;
33651: LD_ADDR_VAR 0 6
33655: PUSH
33656: EMPTY
33657: ST_TO_ADDR
// for j in tmp do
33658: LD_ADDR_VAR 0 3
33662: PUSH
33663: LD_VAR 0 5
33667: PUSH
33668: FOR_IN
33669: IFFALSE 33738
// begin for k in UnitsInside ( j ) do
33671: LD_ADDR_VAR 0 4
33675: PUSH
33676: LD_VAR 0 3
33680: PPUSH
33681: CALL_OW 313
33685: PUSH
33686: FOR_IN
33687: IFFALSE 33734
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33689: LD_VAR 0 4
33693: PPUSH
33694: CALL_OW 257
33698: PUSH
33699: LD_INT 1
33701: EQUAL
33702: PUSH
33703: LD_VAR 0 4
33707: PPUSH
33708: CALL_OW 459
33712: NOT
33713: AND
33714: IFFALSE 33732
// list := list ^ k ;
33716: LD_ADDR_VAR 0 6
33720: PUSH
33721: LD_VAR 0 6
33725: PUSH
33726: LD_VAR 0 4
33730: ADD
33731: ST_TO_ADDR
33732: GO 33686
33734: POP
33735: POP
// end ;
33736: GO 33668
33738: POP
33739: POP
// list := list diff mc_miners [ i ] ;
33740: LD_ADDR_VAR 0 6
33744: PUSH
33745: LD_VAR 0 6
33749: PUSH
33750: LD_EXP 104
33754: PUSH
33755: LD_VAR 0 2
33759: ARRAY
33760: DIFF
33761: ST_TO_ADDR
// if not list then
33762: LD_VAR 0 6
33766: NOT
33767: IFFALSE 33771
// continue ;
33769: GO 33144
// k := mc_mines [ i ] - mc_miners [ i ] ;
33771: LD_ADDR_VAR 0 4
33775: PUSH
33776: LD_EXP 103
33780: PUSH
33781: LD_VAR 0 2
33785: ARRAY
33786: PUSH
33787: LD_EXP 104
33791: PUSH
33792: LD_VAR 0 2
33796: ARRAY
33797: MINUS
33798: ST_TO_ADDR
// if k > list then
33799: LD_VAR 0 4
33803: PUSH
33804: LD_VAR 0 6
33808: GREATER
33809: IFFALSE 33821
// k := list ;
33811: LD_ADDR_VAR 0 4
33815: PUSH
33816: LD_VAR 0 6
33820: ST_TO_ADDR
// for j = 1 to k do
33821: LD_ADDR_VAR 0 3
33825: PUSH
33826: DOUBLE
33827: LD_INT 1
33829: DEC
33830: ST_TO_ADDR
33831: LD_VAR 0 4
33835: PUSH
33836: FOR_TO
33837: IFFALSE 33891
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33839: LD_ADDR_EXP 104
33843: PUSH
33844: LD_EXP 104
33848: PPUSH
33849: LD_VAR 0 2
33853: PUSH
33854: LD_EXP 104
33858: PUSH
33859: LD_VAR 0 2
33863: ARRAY
33864: PUSH
33865: LD_INT 1
33867: PLUS
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PPUSH
33873: LD_VAR 0 6
33877: PUSH
33878: LD_VAR 0 3
33882: ARRAY
33883: PPUSH
33884: CALL 55835 0 3
33888: ST_TO_ADDR
33889: GO 33836
33891: POP
33892: POP
// end ;
33893: GO 33144
33895: POP
33896: POP
// end ;
33897: LD_VAR 0 1
33901: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33902: LD_INT 0
33904: PPUSH
33905: PPUSH
33906: PPUSH
33907: PPUSH
33908: PPUSH
33909: PPUSH
33910: PPUSH
33911: PPUSH
33912: PPUSH
33913: PPUSH
// if not mc_bases then
33914: LD_EXP 90
33918: NOT
33919: IFFALSE 33923
// exit ;
33921: GO 35673
// for i = 1 to mc_bases do
33923: LD_ADDR_VAR 0 2
33927: PUSH
33928: DOUBLE
33929: LD_INT 1
33931: DEC
33932: ST_TO_ADDR
33933: LD_EXP 90
33937: PUSH
33938: FOR_TO
33939: IFFALSE 35671
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33941: LD_EXP 90
33945: PUSH
33946: LD_VAR 0 2
33950: ARRAY
33951: NOT
33952: PUSH
33953: LD_EXP 97
33957: PUSH
33958: LD_VAR 0 2
33962: ARRAY
33963: OR
33964: IFFALSE 33968
// continue ;
33966: GO 33938
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33968: LD_EXP 106
33972: PUSH
33973: LD_VAR 0 2
33977: ARRAY
33978: NOT
33979: PUSH
33980: LD_EXP 107
33984: PUSH
33985: LD_VAR 0 2
33989: ARRAY
33990: AND
33991: IFFALSE 34029
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33993: LD_ADDR_EXP 107
33997: PUSH
33998: LD_EXP 107
34002: PPUSH
34003: LD_VAR 0 2
34007: PPUSH
34008: EMPTY
34009: PPUSH
34010: CALL_OW 1
34014: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34015: LD_VAR 0 2
34019: PPUSH
34020: LD_INT 107
34022: PPUSH
34023: CALL 24856 0 2
// continue ;
34027: GO 33938
// end ; target := [ ] ;
34029: LD_ADDR_VAR 0 6
34033: PUSH
34034: EMPTY
34035: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34036: LD_ADDR_VAR 0 3
34040: PUSH
34041: DOUBLE
34042: LD_EXP 106
34046: PUSH
34047: LD_VAR 0 2
34051: ARRAY
34052: INC
34053: ST_TO_ADDR
34054: LD_INT 1
34056: PUSH
34057: FOR_DOWNTO
34058: IFFALSE 34318
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34060: LD_EXP 106
34064: PUSH
34065: LD_VAR 0 2
34069: ARRAY
34070: PUSH
34071: LD_VAR 0 3
34075: ARRAY
34076: PUSH
34077: LD_INT 2
34079: ARRAY
34080: PPUSH
34081: LD_EXP 106
34085: PUSH
34086: LD_VAR 0 2
34090: ARRAY
34091: PUSH
34092: LD_VAR 0 3
34096: ARRAY
34097: PUSH
34098: LD_INT 3
34100: ARRAY
34101: PPUSH
34102: CALL_OW 488
34106: PUSH
34107: LD_EXP 106
34111: PUSH
34112: LD_VAR 0 2
34116: ARRAY
34117: PUSH
34118: LD_VAR 0 3
34122: ARRAY
34123: PUSH
34124: LD_INT 2
34126: ARRAY
34127: PPUSH
34128: LD_EXP 106
34132: PUSH
34133: LD_VAR 0 2
34137: ARRAY
34138: PUSH
34139: LD_VAR 0 3
34143: ARRAY
34144: PUSH
34145: LD_INT 3
34147: ARRAY
34148: PPUSH
34149: CALL_OW 284
34153: PUSH
34154: LD_INT 0
34156: EQUAL
34157: AND
34158: IFFALSE 34213
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34160: LD_ADDR_VAR 0 5
34164: PUSH
34165: LD_EXP 106
34169: PUSH
34170: LD_VAR 0 2
34174: ARRAY
34175: PPUSH
34176: LD_VAR 0 3
34180: PPUSH
34181: CALL_OW 3
34185: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34186: LD_ADDR_EXP 106
34190: PUSH
34191: LD_EXP 106
34195: PPUSH
34196: LD_VAR 0 2
34200: PPUSH
34201: LD_VAR 0 5
34205: PPUSH
34206: CALL_OW 1
34210: ST_TO_ADDR
// continue ;
34211: GO 34057
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34213: LD_EXP 90
34217: PUSH
34218: LD_VAR 0 2
34222: ARRAY
34223: PUSH
34224: LD_INT 1
34226: ARRAY
34227: PPUSH
34228: CALL_OW 255
34232: PPUSH
34233: LD_EXP 106
34237: PUSH
34238: LD_VAR 0 2
34242: ARRAY
34243: PUSH
34244: LD_VAR 0 3
34248: ARRAY
34249: PUSH
34250: LD_INT 2
34252: ARRAY
34253: PPUSH
34254: LD_EXP 106
34258: PUSH
34259: LD_VAR 0 2
34263: ARRAY
34264: PUSH
34265: LD_VAR 0 3
34269: ARRAY
34270: PUSH
34271: LD_INT 3
34273: ARRAY
34274: PPUSH
34275: LD_INT 30
34277: PPUSH
34278: CALL 56731 0 4
34282: PUSH
34283: LD_INT 4
34285: ARRAY
34286: PUSH
34287: LD_INT 0
34289: EQUAL
34290: IFFALSE 34316
// begin target := mc_crates [ i ] [ j ] ;
34292: LD_ADDR_VAR 0 6
34296: PUSH
34297: LD_EXP 106
34301: PUSH
34302: LD_VAR 0 2
34306: ARRAY
34307: PUSH
34308: LD_VAR 0 3
34312: ARRAY
34313: ST_TO_ADDR
// break ;
34314: GO 34318
// end ; end ;
34316: GO 34057
34318: POP
34319: POP
// if not target then
34320: LD_VAR 0 6
34324: NOT
34325: IFFALSE 34329
// continue ;
34327: GO 33938
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34329: LD_ADDR_VAR 0 7
34333: PUSH
34334: LD_EXP 109
34338: PUSH
34339: LD_VAR 0 2
34343: ARRAY
34344: PPUSH
34345: LD_INT 2
34347: PUSH
34348: LD_INT 3
34350: PUSH
34351: LD_INT 58
34353: PUSH
34354: EMPTY
34355: LIST
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 61
34363: PUSH
34364: EMPTY
34365: LIST
34366: PUSH
34367: LD_INT 33
34369: PUSH
34370: LD_INT 5
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 33
34379: PUSH
34380: LD_INT 3
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: PUSH
34394: LD_INT 2
34396: PUSH
34397: LD_INT 34
34399: PUSH
34400: LD_INT 32
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 34
34409: PUSH
34410: LD_INT 51
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: LD_INT 34
34419: PUSH
34420: LD_INT 12
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PPUSH
34437: CALL_OW 72
34441: ST_TO_ADDR
// if not cargo then
34442: LD_VAR 0 7
34446: NOT
34447: IFFALSE 35090
// begin if mc_crates_collector [ i ] < 5 then
34449: LD_EXP 107
34453: PUSH
34454: LD_VAR 0 2
34458: ARRAY
34459: PUSH
34460: LD_INT 5
34462: LESS
34463: IFFALSE 34829
// begin if mc_ape [ i ] then
34465: LD_EXP 119
34469: PUSH
34470: LD_VAR 0 2
34474: ARRAY
34475: IFFALSE 34522
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34477: LD_ADDR_VAR 0 5
34481: PUSH
34482: LD_EXP 119
34486: PUSH
34487: LD_VAR 0 2
34491: ARRAY
34492: PPUSH
34493: LD_INT 25
34495: PUSH
34496: LD_INT 16
34498: PUSH
34499: EMPTY
34500: LIST
34501: LIST
34502: PUSH
34503: LD_INT 24
34505: PUSH
34506: LD_INT 750
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PPUSH
34517: CALL_OW 72
34521: ST_TO_ADDR
// if not tmp then
34522: LD_VAR 0 5
34526: NOT
34527: IFFALSE 34574
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34529: LD_ADDR_VAR 0 5
34533: PUSH
34534: LD_EXP 90
34538: PUSH
34539: LD_VAR 0 2
34543: ARRAY
34544: PPUSH
34545: LD_INT 25
34547: PUSH
34548: LD_INT 2
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 24
34557: PUSH
34558: LD_INT 750
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: PPUSH
34569: CALL_OW 72
34573: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34574: LD_EXP 119
34578: PUSH
34579: LD_VAR 0 2
34583: ARRAY
34584: PUSH
34585: LD_EXP 90
34589: PUSH
34590: LD_VAR 0 2
34594: ARRAY
34595: PPUSH
34596: LD_INT 25
34598: PUSH
34599: LD_INT 2
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 24
34608: PUSH
34609: LD_INT 750
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: PPUSH
34620: CALL_OW 72
34624: AND
34625: PUSH
34626: LD_VAR 0 5
34630: PUSH
34631: LD_INT 5
34633: LESS
34634: AND
34635: IFFALSE 34717
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34637: LD_ADDR_VAR 0 3
34641: PUSH
34642: LD_EXP 90
34646: PUSH
34647: LD_VAR 0 2
34651: ARRAY
34652: PPUSH
34653: LD_INT 25
34655: PUSH
34656: LD_INT 2
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 24
34665: PUSH
34666: LD_INT 750
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: PPUSH
34677: CALL_OW 72
34681: PUSH
34682: FOR_IN
34683: IFFALSE 34715
// begin tmp := tmp union j ;
34685: LD_ADDR_VAR 0 5
34689: PUSH
34690: LD_VAR 0 5
34694: PUSH
34695: LD_VAR 0 3
34699: UNION
34700: ST_TO_ADDR
// if tmp >= 5 then
34701: LD_VAR 0 5
34705: PUSH
34706: LD_INT 5
34708: GREATEREQUAL
34709: IFFALSE 34713
// break ;
34711: GO 34715
// end ;
34713: GO 34682
34715: POP
34716: POP
// end ; if not tmp then
34717: LD_VAR 0 5
34721: NOT
34722: IFFALSE 34726
// continue ;
34724: GO 33938
// for j in tmp do
34726: LD_ADDR_VAR 0 3
34730: PUSH
34731: LD_VAR 0 5
34735: PUSH
34736: FOR_IN
34737: IFFALSE 34827
// if not GetTag ( j ) then
34739: LD_VAR 0 3
34743: PPUSH
34744: CALL_OW 110
34748: NOT
34749: IFFALSE 34825
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34751: LD_ADDR_EXP 107
34755: PUSH
34756: LD_EXP 107
34760: PPUSH
34761: LD_VAR 0 2
34765: PUSH
34766: LD_EXP 107
34770: PUSH
34771: LD_VAR 0 2
34775: ARRAY
34776: PUSH
34777: LD_INT 1
34779: PLUS
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PPUSH
34785: LD_VAR 0 3
34789: PPUSH
34790: CALL 55835 0 3
34794: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34795: LD_VAR 0 3
34799: PPUSH
34800: LD_INT 107
34802: PPUSH
34803: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34807: LD_EXP 107
34811: PUSH
34812: LD_VAR 0 2
34816: ARRAY
34817: PUSH
34818: LD_INT 5
34820: GREATEREQUAL
34821: IFFALSE 34825
// break ;
34823: GO 34827
// end ;
34825: GO 34736
34827: POP
34828: POP
// end ; if mc_crates_collector [ i ] and target then
34829: LD_EXP 107
34833: PUSH
34834: LD_VAR 0 2
34838: ARRAY
34839: PUSH
34840: LD_VAR 0 6
34844: AND
34845: IFFALSE 35088
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34847: LD_EXP 107
34851: PUSH
34852: LD_VAR 0 2
34856: ARRAY
34857: PUSH
34858: LD_VAR 0 6
34862: PUSH
34863: LD_INT 1
34865: ARRAY
34866: LESS
34867: IFFALSE 34887
// tmp := mc_crates_collector [ i ] else
34869: LD_ADDR_VAR 0 5
34873: PUSH
34874: LD_EXP 107
34878: PUSH
34879: LD_VAR 0 2
34883: ARRAY
34884: ST_TO_ADDR
34885: GO 34901
// tmp := target [ 1 ] ;
34887: LD_ADDR_VAR 0 5
34891: PUSH
34892: LD_VAR 0 6
34896: PUSH
34897: LD_INT 1
34899: ARRAY
34900: ST_TO_ADDR
// k := 0 ;
34901: LD_ADDR_VAR 0 4
34905: PUSH
34906: LD_INT 0
34908: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34909: LD_ADDR_VAR 0 3
34913: PUSH
34914: LD_EXP 107
34918: PUSH
34919: LD_VAR 0 2
34923: ARRAY
34924: PUSH
34925: FOR_IN
34926: IFFALSE 35086
// begin k := k + 1 ;
34928: LD_ADDR_VAR 0 4
34932: PUSH
34933: LD_VAR 0 4
34937: PUSH
34938: LD_INT 1
34940: PLUS
34941: ST_TO_ADDR
// if k > tmp then
34942: LD_VAR 0 4
34946: PUSH
34947: LD_VAR 0 5
34951: GREATER
34952: IFFALSE 34956
// break ;
34954: GO 35086
// if not GetClass ( j ) in [ 2 , 16 ] then
34956: LD_VAR 0 3
34960: PPUSH
34961: CALL_OW 257
34965: PUSH
34966: LD_INT 2
34968: PUSH
34969: LD_INT 16
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: IN
34976: NOT
34977: IFFALSE 35030
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34979: LD_ADDR_EXP 107
34983: PUSH
34984: LD_EXP 107
34988: PPUSH
34989: LD_VAR 0 2
34993: PPUSH
34994: LD_EXP 107
34998: PUSH
34999: LD_VAR 0 2
35003: ARRAY
35004: PUSH
35005: LD_VAR 0 3
35009: DIFF
35010: PPUSH
35011: CALL_OW 1
35015: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35016: LD_VAR 0 3
35020: PPUSH
35021: LD_INT 0
35023: PPUSH
35024: CALL_OW 109
// continue ;
35028: GO 34925
// end ; if IsInUnit ( j ) then
35030: LD_VAR 0 3
35034: PPUSH
35035: CALL_OW 310
35039: IFFALSE 35050
// ComExitBuilding ( j ) ;
35041: LD_VAR 0 3
35045: PPUSH
35046: CALL_OW 122
// wait ( 3 ) ;
35050: LD_INT 3
35052: PPUSH
35053: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35057: LD_VAR 0 3
35061: PPUSH
35062: LD_VAR 0 6
35066: PUSH
35067: LD_INT 2
35069: ARRAY
35070: PPUSH
35071: LD_VAR 0 6
35075: PUSH
35076: LD_INT 3
35078: ARRAY
35079: PPUSH
35080: CALL_OW 117
// end ;
35084: GO 34925
35086: POP
35087: POP
// end ; end else
35088: GO 35669
// begin for j in cargo do
35090: LD_ADDR_VAR 0 3
35094: PUSH
35095: LD_VAR 0 7
35099: PUSH
35100: FOR_IN
35101: IFFALSE 35667
// begin if GetTag ( j ) <> 0 then
35103: LD_VAR 0 3
35107: PPUSH
35108: CALL_OW 110
35112: PUSH
35113: LD_INT 0
35115: NONEQUAL
35116: IFFALSE 35120
// continue ;
35118: GO 35100
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35120: LD_VAR 0 3
35124: PPUSH
35125: CALL_OW 256
35129: PUSH
35130: LD_INT 1000
35132: LESS
35133: PUSH
35134: LD_VAR 0 3
35138: PPUSH
35139: LD_EXP 114
35143: PUSH
35144: LD_VAR 0 2
35148: ARRAY
35149: PPUSH
35150: CALL_OW 308
35154: NOT
35155: AND
35156: IFFALSE 35178
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35158: LD_VAR 0 3
35162: PPUSH
35163: LD_EXP 114
35167: PUSH
35168: LD_VAR 0 2
35172: ARRAY
35173: PPUSH
35174: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35178: LD_VAR 0 3
35182: PPUSH
35183: CALL_OW 256
35187: PUSH
35188: LD_INT 1000
35190: LESS
35191: PUSH
35192: LD_VAR 0 3
35196: PPUSH
35197: LD_EXP 114
35201: PUSH
35202: LD_VAR 0 2
35206: ARRAY
35207: PPUSH
35208: CALL_OW 308
35212: AND
35213: IFFALSE 35217
// continue ;
35215: GO 35100
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35217: LD_VAR 0 3
35221: PPUSH
35222: CALL_OW 262
35226: PUSH
35227: LD_INT 2
35229: EQUAL
35230: PUSH
35231: LD_VAR 0 3
35235: PPUSH
35236: CALL_OW 261
35240: PUSH
35241: LD_INT 15
35243: LESS
35244: AND
35245: IFFALSE 35249
// continue ;
35247: GO 35100
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35249: LD_VAR 0 3
35253: PPUSH
35254: CALL_OW 262
35258: PUSH
35259: LD_INT 1
35261: EQUAL
35262: PUSH
35263: LD_VAR 0 3
35267: PPUSH
35268: CALL_OW 261
35272: PUSH
35273: LD_INT 10
35275: LESS
35276: AND
35277: IFFALSE 35606
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35279: LD_ADDR_VAR 0 8
35283: PUSH
35284: LD_EXP 90
35288: PUSH
35289: LD_VAR 0 2
35293: ARRAY
35294: PPUSH
35295: LD_INT 2
35297: PUSH
35298: LD_INT 30
35300: PUSH
35301: LD_INT 0
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PUSH
35308: LD_INT 30
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: LIST
35322: PPUSH
35323: CALL_OW 72
35327: ST_TO_ADDR
// if not depot then
35328: LD_VAR 0 8
35332: NOT
35333: IFFALSE 35337
// continue ;
35335: GO 35100
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35337: LD_VAR 0 3
35341: PPUSH
35342: LD_VAR 0 8
35346: PPUSH
35347: LD_VAR 0 3
35351: PPUSH
35352: CALL_OW 74
35356: PPUSH
35357: CALL_OW 296
35361: PUSH
35362: LD_INT 6
35364: LESS
35365: IFFALSE 35381
// SetFuel ( j , 100 ) else
35367: LD_VAR 0 3
35371: PPUSH
35372: LD_INT 100
35374: PPUSH
35375: CALL_OW 240
35379: GO 35606
// if GetFuel ( j ) = 0 then
35381: LD_VAR 0 3
35385: PPUSH
35386: CALL_OW 261
35390: PUSH
35391: LD_INT 0
35393: EQUAL
35394: IFFALSE 35606
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35396: LD_ADDR_EXP 109
35400: PUSH
35401: LD_EXP 109
35405: PPUSH
35406: LD_VAR 0 2
35410: PPUSH
35411: LD_EXP 109
35415: PUSH
35416: LD_VAR 0 2
35420: ARRAY
35421: PUSH
35422: LD_VAR 0 3
35426: DIFF
35427: PPUSH
35428: CALL_OW 1
35432: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35433: LD_VAR 0 3
35437: PPUSH
35438: CALL_OW 263
35442: PUSH
35443: LD_INT 1
35445: EQUAL
35446: IFFALSE 35462
// ComExitVehicle ( IsInUnit ( j ) ) ;
35448: LD_VAR 0 3
35452: PPUSH
35453: CALL_OW 310
35457: PPUSH
35458: CALL_OW 121
// if GetControl ( j ) = control_remote then
35462: LD_VAR 0 3
35466: PPUSH
35467: CALL_OW 263
35471: PUSH
35472: LD_INT 2
35474: EQUAL
35475: IFFALSE 35486
// ComUnlink ( j ) ;
35477: LD_VAR 0 3
35481: PPUSH
35482: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35486: LD_ADDR_VAR 0 9
35490: PUSH
35491: LD_VAR 0 2
35495: PPUSH
35496: LD_INT 3
35498: PPUSH
35499: CALL 44981 0 2
35503: ST_TO_ADDR
// if fac then
35504: LD_VAR 0 9
35508: IFFALSE 35604
// begin for k in fac do
35510: LD_ADDR_VAR 0 4
35514: PUSH
35515: LD_VAR 0 9
35519: PUSH
35520: FOR_IN
35521: IFFALSE 35602
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35523: LD_ADDR_VAR 0 10
35527: PUSH
35528: LD_VAR 0 9
35532: PPUSH
35533: LD_VAR 0 3
35537: PPUSH
35538: CALL_OW 265
35542: PPUSH
35543: LD_VAR 0 3
35547: PPUSH
35548: CALL_OW 262
35552: PPUSH
35553: LD_VAR 0 3
35557: PPUSH
35558: CALL_OW 263
35562: PPUSH
35563: LD_VAR 0 3
35567: PPUSH
35568: CALL_OW 264
35572: PPUSH
35573: CALL 53367 0 5
35577: ST_TO_ADDR
// if components then
35578: LD_VAR 0 10
35582: IFFALSE 35600
// begin MC_InsertProduceList ( i , components ) ;
35584: LD_VAR 0 2
35588: PPUSH
35589: LD_VAR 0 10
35593: PPUSH
35594: CALL 44526 0 2
// break ;
35598: GO 35602
// end ; end ;
35600: GO 35520
35602: POP
35603: POP
// end ; continue ;
35604: GO 35100
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35606: LD_VAR 0 3
35610: PPUSH
35611: LD_INT 1
35613: PPUSH
35614: CALL_OW 289
35618: PUSH
35619: LD_INT 100
35621: LESS
35622: PUSH
35623: LD_VAR 0 3
35627: PPUSH
35628: CALL_OW 314
35632: NOT
35633: AND
35634: IFFALSE 35663
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35636: LD_VAR 0 3
35640: PPUSH
35641: LD_VAR 0 6
35645: PUSH
35646: LD_INT 2
35648: ARRAY
35649: PPUSH
35650: LD_VAR 0 6
35654: PUSH
35655: LD_INT 3
35657: ARRAY
35658: PPUSH
35659: CALL_OW 117
// break ;
35663: GO 35667
// end ;
35665: GO 35100
35667: POP
35668: POP
// end ; end ;
35669: GO 33938
35671: POP
35672: POP
// end ;
35673: LD_VAR 0 1
35677: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35678: LD_INT 0
35680: PPUSH
35681: PPUSH
35682: PPUSH
35683: PPUSH
// if not mc_bases then
35684: LD_EXP 90
35688: NOT
35689: IFFALSE 35693
// exit ;
35691: GO 35854
// for i = 1 to mc_bases do
35693: LD_ADDR_VAR 0 2
35697: PUSH
35698: DOUBLE
35699: LD_INT 1
35701: DEC
35702: ST_TO_ADDR
35703: LD_EXP 90
35707: PUSH
35708: FOR_TO
35709: IFFALSE 35852
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35711: LD_ADDR_VAR 0 4
35715: PUSH
35716: LD_EXP 109
35720: PUSH
35721: LD_VAR 0 2
35725: ARRAY
35726: PUSH
35727: LD_EXP 112
35731: PUSH
35732: LD_VAR 0 2
35736: ARRAY
35737: UNION
35738: PPUSH
35739: LD_INT 33
35741: PUSH
35742: LD_INT 2
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: PPUSH
35749: CALL_OW 72
35753: ST_TO_ADDR
// if tmp then
35754: LD_VAR 0 4
35758: IFFALSE 35850
// for j in tmp do
35760: LD_ADDR_VAR 0 3
35764: PUSH
35765: LD_VAR 0 4
35769: PUSH
35770: FOR_IN
35771: IFFALSE 35848
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35773: LD_VAR 0 3
35777: PPUSH
35778: CALL_OW 312
35782: NOT
35783: PUSH
35784: LD_VAR 0 3
35788: PPUSH
35789: CALL_OW 256
35793: PUSH
35794: LD_INT 250
35796: GREATEREQUAL
35797: AND
35798: IFFALSE 35811
// Connect ( j ) else
35800: LD_VAR 0 3
35804: PPUSH
35805: CALL 58800 0 1
35809: GO 35846
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35811: LD_VAR 0 3
35815: PPUSH
35816: CALL_OW 256
35820: PUSH
35821: LD_INT 250
35823: LESS
35824: PUSH
35825: LD_VAR 0 3
35829: PPUSH
35830: CALL_OW 312
35834: AND
35835: IFFALSE 35846
// ComUnlink ( j ) ;
35837: LD_VAR 0 3
35841: PPUSH
35842: CALL_OW 136
35846: GO 35770
35848: POP
35849: POP
// end ;
35850: GO 35708
35852: POP
35853: POP
// end ;
35854: LD_VAR 0 1
35858: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35859: LD_INT 0
35861: PPUSH
35862: PPUSH
35863: PPUSH
35864: PPUSH
35865: PPUSH
// if not mc_bases then
35866: LD_EXP 90
35870: NOT
35871: IFFALSE 35875
// exit ;
35873: GO 36320
// for i = 1 to mc_bases do
35875: LD_ADDR_VAR 0 2
35879: PUSH
35880: DOUBLE
35881: LD_INT 1
35883: DEC
35884: ST_TO_ADDR
35885: LD_EXP 90
35889: PUSH
35890: FOR_TO
35891: IFFALSE 36318
// begin if not mc_produce [ i ] then
35893: LD_EXP 111
35897: PUSH
35898: LD_VAR 0 2
35902: ARRAY
35903: NOT
35904: IFFALSE 35908
// continue ;
35906: GO 35890
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35908: LD_ADDR_VAR 0 5
35912: PUSH
35913: LD_EXP 90
35917: PUSH
35918: LD_VAR 0 2
35922: ARRAY
35923: PPUSH
35924: LD_INT 30
35926: PUSH
35927: LD_INT 3
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PPUSH
35934: CALL_OW 72
35938: ST_TO_ADDR
// if not fac then
35939: LD_VAR 0 5
35943: NOT
35944: IFFALSE 35948
// continue ;
35946: GO 35890
// for j in fac do
35948: LD_ADDR_VAR 0 3
35952: PUSH
35953: LD_VAR 0 5
35957: PUSH
35958: FOR_IN
35959: IFFALSE 36314
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35961: LD_VAR 0 3
35965: PPUSH
35966: CALL_OW 461
35970: PUSH
35971: LD_INT 2
35973: NONEQUAL
35974: PUSH
35975: LD_VAR 0 3
35979: PPUSH
35980: LD_INT 15
35982: PPUSH
35983: CALL 58428 0 2
35987: PUSH
35988: LD_INT 4
35990: ARRAY
35991: OR
35992: IFFALSE 35996
// continue ;
35994: GO 35958
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35996: LD_VAR 0 3
36000: PPUSH
36001: LD_EXP 111
36005: PUSH
36006: LD_VAR 0 2
36010: ARRAY
36011: PUSH
36012: LD_INT 1
36014: ARRAY
36015: PUSH
36016: LD_INT 1
36018: ARRAY
36019: PPUSH
36020: LD_EXP 111
36024: PUSH
36025: LD_VAR 0 2
36029: ARRAY
36030: PUSH
36031: LD_INT 1
36033: ARRAY
36034: PUSH
36035: LD_INT 2
36037: ARRAY
36038: PPUSH
36039: LD_EXP 111
36043: PUSH
36044: LD_VAR 0 2
36048: ARRAY
36049: PUSH
36050: LD_INT 1
36052: ARRAY
36053: PUSH
36054: LD_INT 3
36056: ARRAY
36057: PPUSH
36058: LD_EXP 111
36062: PUSH
36063: LD_VAR 0 2
36067: ARRAY
36068: PUSH
36069: LD_INT 1
36071: ARRAY
36072: PUSH
36073: LD_INT 4
36075: ARRAY
36076: PPUSH
36077: CALL_OW 448
36081: PUSH
36082: LD_VAR 0 3
36086: PPUSH
36087: LD_EXP 111
36091: PUSH
36092: LD_VAR 0 2
36096: ARRAY
36097: PUSH
36098: LD_INT 1
36100: ARRAY
36101: PUSH
36102: LD_INT 1
36104: ARRAY
36105: PUSH
36106: LD_EXP 111
36110: PUSH
36111: LD_VAR 0 2
36115: ARRAY
36116: PUSH
36117: LD_INT 1
36119: ARRAY
36120: PUSH
36121: LD_INT 2
36123: ARRAY
36124: PUSH
36125: LD_EXP 111
36129: PUSH
36130: LD_VAR 0 2
36134: ARRAY
36135: PUSH
36136: LD_INT 1
36138: ARRAY
36139: PUSH
36140: LD_INT 3
36142: ARRAY
36143: PUSH
36144: LD_EXP 111
36148: PUSH
36149: LD_VAR 0 2
36153: ARRAY
36154: PUSH
36155: LD_INT 1
36157: ARRAY
36158: PUSH
36159: LD_INT 4
36161: ARRAY
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: LIST
36167: LIST
36168: PPUSH
36169: CALL 62226 0 2
36173: AND
36174: IFFALSE 36312
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36176: LD_VAR 0 3
36180: PPUSH
36181: LD_EXP 111
36185: PUSH
36186: LD_VAR 0 2
36190: ARRAY
36191: PUSH
36192: LD_INT 1
36194: ARRAY
36195: PUSH
36196: LD_INT 1
36198: ARRAY
36199: PPUSH
36200: LD_EXP 111
36204: PUSH
36205: LD_VAR 0 2
36209: ARRAY
36210: PUSH
36211: LD_INT 1
36213: ARRAY
36214: PUSH
36215: LD_INT 2
36217: ARRAY
36218: PPUSH
36219: LD_EXP 111
36223: PUSH
36224: LD_VAR 0 2
36228: ARRAY
36229: PUSH
36230: LD_INT 1
36232: ARRAY
36233: PUSH
36234: LD_INT 3
36236: ARRAY
36237: PPUSH
36238: LD_EXP 111
36242: PUSH
36243: LD_VAR 0 2
36247: ARRAY
36248: PUSH
36249: LD_INT 1
36251: ARRAY
36252: PUSH
36253: LD_INT 4
36255: ARRAY
36256: PPUSH
36257: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36261: LD_ADDR_VAR 0 4
36265: PUSH
36266: LD_EXP 111
36270: PUSH
36271: LD_VAR 0 2
36275: ARRAY
36276: PPUSH
36277: LD_INT 1
36279: PPUSH
36280: CALL_OW 3
36284: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36285: LD_ADDR_EXP 111
36289: PUSH
36290: LD_EXP 111
36294: PPUSH
36295: LD_VAR 0 2
36299: PPUSH
36300: LD_VAR 0 4
36304: PPUSH
36305: CALL_OW 1
36309: ST_TO_ADDR
// break ;
36310: GO 36314
// end ; end ;
36312: GO 35958
36314: POP
36315: POP
// end ;
36316: GO 35890
36318: POP
36319: POP
// end ;
36320: LD_VAR 0 1
36324: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36325: LD_INT 0
36327: PPUSH
36328: PPUSH
36329: PPUSH
// if not mc_bases then
36330: LD_EXP 90
36334: NOT
36335: IFFALSE 36339
// exit ;
36337: GO 36428
// for i = 1 to mc_bases do
36339: LD_ADDR_VAR 0 2
36343: PUSH
36344: DOUBLE
36345: LD_INT 1
36347: DEC
36348: ST_TO_ADDR
36349: LD_EXP 90
36353: PUSH
36354: FOR_TO
36355: IFFALSE 36426
// begin if mc_attack [ i ] then
36357: LD_EXP 110
36361: PUSH
36362: LD_VAR 0 2
36366: ARRAY
36367: IFFALSE 36424
// begin tmp := mc_attack [ i ] [ 1 ] ;
36369: LD_ADDR_VAR 0 3
36373: PUSH
36374: LD_EXP 110
36378: PUSH
36379: LD_VAR 0 2
36383: ARRAY
36384: PUSH
36385: LD_INT 1
36387: ARRAY
36388: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36389: LD_ADDR_EXP 110
36393: PUSH
36394: LD_EXP 110
36398: PPUSH
36399: LD_VAR 0 2
36403: PPUSH
36404: EMPTY
36405: PPUSH
36406: CALL_OW 1
36410: ST_TO_ADDR
// Attack ( tmp ) ;
36411: LD_VAR 0 3
36415: PPUSH
36416: CALL 105727 0 1
// exit ;
36420: POP
36421: POP
36422: GO 36428
// end ; end ;
36424: GO 36354
36426: POP
36427: POP
// end ;
36428: LD_VAR 0 1
36432: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36433: LD_INT 0
36435: PPUSH
36436: PPUSH
36437: PPUSH
36438: PPUSH
36439: PPUSH
36440: PPUSH
36441: PPUSH
// if not mc_bases then
36442: LD_EXP 90
36446: NOT
36447: IFFALSE 36451
// exit ;
36449: GO 37055
// for i = 1 to mc_bases do
36451: LD_ADDR_VAR 0 2
36455: PUSH
36456: DOUBLE
36457: LD_INT 1
36459: DEC
36460: ST_TO_ADDR
36461: LD_EXP 90
36465: PUSH
36466: FOR_TO
36467: IFFALSE 37053
// begin if not mc_bases [ i ] then
36469: LD_EXP 90
36473: PUSH
36474: LD_VAR 0 2
36478: ARRAY
36479: NOT
36480: IFFALSE 36484
// continue ;
36482: GO 36466
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36484: LD_ADDR_VAR 0 7
36488: PUSH
36489: LD_EXP 90
36493: PUSH
36494: LD_VAR 0 2
36498: ARRAY
36499: PUSH
36500: LD_INT 1
36502: ARRAY
36503: PPUSH
36504: CALL 52671 0 1
36508: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36509: LD_ADDR_EXP 113
36513: PUSH
36514: LD_EXP 113
36518: PPUSH
36519: LD_VAR 0 2
36523: PPUSH
36524: LD_EXP 90
36528: PUSH
36529: LD_VAR 0 2
36533: ARRAY
36534: PUSH
36535: LD_INT 1
36537: ARRAY
36538: PPUSH
36539: CALL_OW 255
36543: PPUSH
36544: LD_EXP 115
36548: PUSH
36549: LD_VAR 0 2
36553: ARRAY
36554: PPUSH
36555: CALL 52636 0 2
36559: PPUSH
36560: CALL_OW 1
36564: ST_TO_ADDR
// if not mc_scan [ i ] then
36565: LD_EXP 113
36569: PUSH
36570: LD_VAR 0 2
36574: ARRAY
36575: NOT
36576: IFFALSE 36731
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36578: LD_ADDR_VAR 0 4
36582: PUSH
36583: LD_EXP 90
36587: PUSH
36588: LD_VAR 0 2
36592: ARRAY
36593: PPUSH
36594: LD_INT 2
36596: PUSH
36597: LD_INT 25
36599: PUSH
36600: LD_INT 5
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: LD_INT 25
36609: PUSH
36610: LD_INT 8
36612: PUSH
36613: EMPTY
36614: LIST
36615: LIST
36616: PUSH
36617: LD_INT 25
36619: PUSH
36620: LD_INT 9
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: LIST
36631: LIST
36632: PPUSH
36633: CALL_OW 72
36637: ST_TO_ADDR
// if not tmp then
36638: LD_VAR 0 4
36642: NOT
36643: IFFALSE 36647
// continue ;
36645: GO 36466
// for j in tmp do
36647: LD_ADDR_VAR 0 3
36651: PUSH
36652: LD_VAR 0 4
36656: PUSH
36657: FOR_IN
36658: IFFALSE 36729
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36660: LD_VAR 0 3
36664: PPUSH
36665: CALL_OW 310
36669: PPUSH
36670: CALL_OW 266
36674: PUSH
36675: LD_INT 5
36677: EQUAL
36678: PUSH
36679: LD_VAR 0 3
36683: PPUSH
36684: CALL_OW 257
36688: PUSH
36689: LD_INT 1
36691: EQUAL
36692: AND
36693: PUSH
36694: LD_VAR 0 3
36698: PPUSH
36699: CALL_OW 459
36703: NOT
36704: AND
36705: PUSH
36706: LD_VAR 0 7
36710: AND
36711: IFFALSE 36727
// ComChangeProfession ( j , class ) ;
36713: LD_VAR 0 3
36717: PPUSH
36718: LD_VAR 0 7
36722: PPUSH
36723: CALL_OW 123
36727: GO 36657
36729: POP
36730: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36731: LD_EXP 113
36735: PUSH
36736: LD_VAR 0 2
36740: ARRAY
36741: PUSH
36742: LD_EXP 112
36746: PUSH
36747: LD_VAR 0 2
36751: ARRAY
36752: NOT
36753: AND
36754: PUSH
36755: LD_EXP 90
36759: PUSH
36760: LD_VAR 0 2
36764: ARRAY
36765: PPUSH
36766: LD_INT 30
36768: PUSH
36769: LD_INT 32
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PPUSH
36776: CALL_OW 72
36780: NOT
36781: AND
36782: PUSH
36783: LD_EXP 90
36787: PUSH
36788: LD_VAR 0 2
36792: ARRAY
36793: PPUSH
36794: LD_INT 2
36796: PUSH
36797: LD_INT 30
36799: PUSH
36800: LD_INT 4
36802: PUSH
36803: EMPTY
36804: LIST
36805: LIST
36806: PUSH
36807: LD_INT 30
36809: PUSH
36810: LD_INT 5
36812: PUSH
36813: EMPTY
36814: LIST
36815: LIST
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: LIST
36821: PPUSH
36822: CALL_OW 72
36826: NOT
36827: AND
36828: IFFALSE 36960
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36830: LD_ADDR_VAR 0 4
36834: PUSH
36835: LD_EXP 90
36839: PUSH
36840: LD_VAR 0 2
36844: ARRAY
36845: PPUSH
36846: LD_INT 2
36848: PUSH
36849: LD_INT 25
36851: PUSH
36852: LD_INT 1
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PUSH
36859: LD_INT 25
36861: PUSH
36862: LD_INT 5
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 25
36871: PUSH
36872: LD_INT 8
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 25
36881: PUSH
36882: LD_INT 9
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: LIST
36893: LIST
36894: LIST
36895: PPUSH
36896: CALL_OW 72
36900: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36901: LD_ADDR_VAR 0 4
36905: PUSH
36906: LD_VAR 0 4
36910: PUSH
36911: LD_VAR 0 4
36915: PPUSH
36916: LD_INT 18
36918: PPUSH
36919: CALL 84729 0 2
36923: DIFF
36924: ST_TO_ADDR
// if tmp then
36925: LD_VAR 0 4
36929: IFFALSE 36960
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36931: LD_VAR 0 2
36935: PPUSH
36936: LD_VAR 0 4
36940: PPUSH
36941: LD_EXP 115
36945: PUSH
36946: LD_VAR 0 2
36950: ARRAY
36951: PPUSH
36952: CALL 110436 0 3
// exit ;
36956: POP
36957: POP
36958: GO 37055
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36960: LD_EXP 113
36964: PUSH
36965: LD_VAR 0 2
36969: ARRAY
36970: PUSH
36971: LD_EXP 112
36975: PUSH
36976: LD_VAR 0 2
36980: ARRAY
36981: AND
36982: IFFALSE 37051
// begin tmp := mc_defender [ i ] ;
36984: LD_ADDR_VAR 0 4
36988: PUSH
36989: LD_EXP 112
36993: PUSH
36994: LD_VAR 0 2
36998: ARRAY
36999: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37000: LD_ADDR_EXP 112
37004: PUSH
37005: LD_EXP 112
37009: PPUSH
37010: LD_VAR 0 2
37014: PPUSH
37015: EMPTY
37016: PPUSH
37017: CALL_OW 1
37021: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
37022: LD_VAR 0 2
37026: PPUSH
37027: LD_VAR 0 4
37031: PPUSH
37032: LD_EXP 113
37036: PUSH
37037: LD_VAR 0 2
37041: ARRAY
37042: PPUSH
37043: CALL 110997 0 3
// exit ;
37047: POP
37048: POP
37049: GO 37055
// end ; end ;
37051: GO 36466
37053: POP
37054: POP
// end ;
37055: LD_VAR 0 1
37059: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
37060: LD_INT 0
37062: PPUSH
37063: PPUSH
37064: PPUSH
37065: PPUSH
37066: PPUSH
37067: PPUSH
37068: PPUSH
37069: PPUSH
37070: PPUSH
37071: PPUSH
37072: PPUSH
// if not mc_bases then
37073: LD_EXP 90
37077: NOT
37078: IFFALSE 37082
// exit ;
37080: GO 38169
// for i = 1 to mc_bases do
37082: LD_ADDR_VAR 0 2
37086: PUSH
37087: DOUBLE
37088: LD_INT 1
37090: DEC
37091: ST_TO_ADDR
37092: LD_EXP 90
37096: PUSH
37097: FOR_TO
37098: IFFALSE 38167
// begin tmp := mc_lab [ i ] ;
37100: LD_ADDR_VAR 0 6
37104: PUSH
37105: LD_EXP 123
37109: PUSH
37110: LD_VAR 0 2
37114: ARRAY
37115: ST_TO_ADDR
// if not tmp then
37116: LD_VAR 0 6
37120: NOT
37121: IFFALSE 37125
// continue ;
37123: GO 37097
// idle_lab := 0 ;
37125: LD_ADDR_VAR 0 11
37129: PUSH
37130: LD_INT 0
37132: ST_TO_ADDR
// for j in tmp do
37133: LD_ADDR_VAR 0 3
37137: PUSH
37138: LD_VAR 0 6
37142: PUSH
37143: FOR_IN
37144: IFFALSE 38163
// begin researching := false ;
37146: LD_ADDR_VAR 0 10
37150: PUSH
37151: LD_INT 0
37153: ST_TO_ADDR
// side := GetSide ( j ) ;
37154: LD_ADDR_VAR 0 4
37158: PUSH
37159: LD_VAR 0 3
37163: PPUSH
37164: CALL_OW 255
37168: ST_TO_ADDR
// if not mc_tech [ side ] then
37169: LD_EXP 117
37173: PUSH
37174: LD_VAR 0 4
37178: ARRAY
37179: NOT
37180: IFFALSE 37184
// continue ;
37182: GO 37143
// if BuildingStatus ( j ) = bs_idle then
37184: LD_VAR 0 3
37188: PPUSH
37189: CALL_OW 461
37193: PUSH
37194: LD_INT 2
37196: EQUAL
37197: IFFALSE 37385
// begin if idle_lab and UnitsInside ( j ) < 6 then
37199: LD_VAR 0 11
37203: PUSH
37204: LD_VAR 0 3
37208: PPUSH
37209: CALL_OW 313
37213: PUSH
37214: LD_INT 6
37216: LESS
37217: AND
37218: IFFALSE 37289
// begin tmp2 := UnitsInside ( idle_lab ) ;
37220: LD_ADDR_VAR 0 9
37224: PUSH
37225: LD_VAR 0 11
37229: PPUSH
37230: CALL_OW 313
37234: ST_TO_ADDR
// if tmp2 then
37235: LD_VAR 0 9
37239: IFFALSE 37281
// for x in tmp2 do
37241: LD_ADDR_VAR 0 7
37245: PUSH
37246: LD_VAR 0 9
37250: PUSH
37251: FOR_IN
37252: IFFALSE 37279
// begin ComExitBuilding ( x ) ;
37254: LD_VAR 0 7
37258: PPUSH
37259: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37263: LD_VAR 0 7
37267: PPUSH
37268: LD_VAR 0 3
37272: PPUSH
37273: CALL_OW 180
// end ;
37277: GO 37251
37279: POP
37280: POP
// idle_lab := 0 ;
37281: LD_ADDR_VAR 0 11
37285: PUSH
37286: LD_INT 0
37288: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37289: LD_ADDR_VAR 0 5
37293: PUSH
37294: LD_EXP 117
37298: PUSH
37299: LD_VAR 0 4
37303: ARRAY
37304: PUSH
37305: FOR_IN
37306: IFFALSE 37366
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37308: LD_VAR 0 3
37312: PPUSH
37313: LD_VAR 0 5
37317: PPUSH
37318: CALL_OW 430
37322: PUSH
37323: LD_VAR 0 4
37327: PPUSH
37328: LD_VAR 0 5
37332: PPUSH
37333: CALL 51741 0 2
37337: AND
37338: IFFALSE 37364
// begin researching := true ;
37340: LD_ADDR_VAR 0 10
37344: PUSH
37345: LD_INT 1
37347: ST_TO_ADDR
// ComResearch ( j , t ) ;
37348: LD_VAR 0 3
37352: PPUSH
37353: LD_VAR 0 5
37357: PPUSH
37358: CALL_OW 124
// break ;
37362: GO 37366
// end ;
37364: GO 37305
37366: POP
37367: POP
// if not researching then
37368: LD_VAR 0 10
37372: NOT
37373: IFFALSE 37385
// idle_lab := j ;
37375: LD_ADDR_VAR 0 11
37379: PUSH
37380: LD_VAR 0 3
37384: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37385: LD_VAR 0 3
37389: PPUSH
37390: CALL_OW 461
37394: PUSH
37395: LD_INT 10
37397: EQUAL
37398: IFFALSE 37986
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37400: LD_EXP 119
37404: PUSH
37405: LD_VAR 0 2
37409: ARRAY
37410: NOT
37411: PUSH
37412: LD_EXP 120
37416: PUSH
37417: LD_VAR 0 2
37421: ARRAY
37422: NOT
37423: AND
37424: PUSH
37425: LD_EXP 117
37429: PUSH
37430: LD_VAR 0 4
37434: ARRAY
37435: PUSH
37436: LD_INT 1
37438: GREATER
37439: AND
37440: IFFALSE 37571
// begin ComCancel ( j ) ;
37442: LD_VAR 0 3
37446: PPUSH
37447: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37451: LD_ADDR_EXP 117
37455: PUSH
37456: LD_EXP 117
37460: PPUSH
37461: LD_VAR 0 4
37465: PPUSH
37466: LD_EXP 117
37470: PUSH
37471: LD_VAR 0 4
37475: ARRAY
37476: PPUSH
37477: LD_EXP 117
37481: PUSH
37482: LD_VAR 0 4
37486: ARRAY
37487: PUSH
37488: LD_INT 1
37490: MINUS
37491: PPUSH
37492: LD_EXP 117
37496: PUSH
37497: LD_VAR 0 4
37501: ARRAY
37502: PPUSH
37503: LD_INT 0
37505: PPUSH
37506: CALL 55253 0 4
37510: PPUSH
37511: CALL_OW 1
37515: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37516: LD_ADDR_EXP 117
37520: PUSH
37521: LD_EXP 117
37525: PPUSH
37526: LD_VAR 0 4
37530: PPUSH
37531: LD_EXP 117
37535: PUSH
37536: LD_VAR 0 4
37540: ARRAY
37541: PPUSH
37542: LD_EXP 117
37546: PUSH
37547: LD_VAR 0 4
37551: ARRAY
37552: PPUSH
37553: LD_INT 1
37555: PPUSH
37556: LD_INT 0
37558: PPUSH
37559: CALL 55253 0 4
37563: PPUSH
37564: CALL_OW 1
37568: ST_TO_ADDR
// continue ;
37569: GO 37143
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37571: LD_EXP 119
37575: PUSH
37576: LD_VAR 0 2
37580: ARRAY
37581: PUSH
37582: LD_EXP 120
37586: PUSH
37587: LD_VAR 0 2
37591: ARRAY
37592: NOT
37593: AND
37594: IFFALSE 37721
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37596: LD_ADDR_EXP 120
37600: PUSH
37601: LD_EXP 120
37605: PPUSH
37606: LD_VAR 0 2
37610: PUSH
37611: LD_EXP 120
37615: PUSH
37616: LD_VAR 0 2
37620: ARRAY
37621: PUSH
37622: LD_INT 1
37624: PLUS
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PPUSH
37630: LD_EXP 119
37634: PUSH
37635: LD_VAR 0 2
37639: ARRAY
37640: PUSH
37641: LD_INT 1
37643: ARRAY
37644: PPUSH
37645: CALL 55835 0 3
37649: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37650: LD_EXP 119
37654: PUSH
37655: LD_VAR 0 2
37659: ARRAY
37660: PUSH
37661: LD_INT 1
37663: ARRAY
37664: PPUSH
37665: LD_INT 112
37667: PPUSH
37668: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37672: LD_ADDR_VAR 0 9
37676: PUSH
37677: LD_EXP 119
37681: PUSH
37682: LD_VAR 0 2
37686: ARRAY
37687: PPUSH
37688: LD_INT 1
37690: PPUSH
37691: CALL_OW 3
37695: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37696: LD_ADDR_EXP 119
37700: PUSH
37701: LD_EXP 119
37705: PPUSH
37706: LD_VAR 0 2
37710: PPUSH
37711: LD_VAR 0 9
37715: PPUSH
37716: CALL_OW 1
37720: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37721: LD_EXP 119
37725: PUSH
37726: LD_VAR 0 2
37730: ARRAY
37731: PUSH
37732: LD_EXP 120
37736: PUSH
37737: LD_VAR 0 2
37741: ARRAY
37742: AND
37743: PUSH
37744: LD_EXP 120
37748: PUSH
37749: LD_VAR 0 2
37753: ARRAY
37754: PUSH
37755: LD_INT 1
37757: ARRAY
37758: PPUSH
37759: CALL_OW 310
37763: NOT
37764: AND
37765: PUSH
37766: LD_VAR 0 3
37770: PPUSH
37771: CALL_OW 313
37775: PUSH
37776: LD_INT 6
37778: EQUAL
37779: AND
37780: IFFALSE 37836
// begin tmp2 := UnitsInside ( j ) ;
37782: LD_ADDR_VAR 0 9
37786: PUSH
37787: LD_VAR 0 3
37791: PPUSH
37792: CALL_OW 313
37796: ST_TO_ADDR
// if tmp2 = 6 then
37797: LD_VAR 0 9
37801: PUSH
37802: LD_INT 6
37804: EQUAL
37805: IFFALSE 37836
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37807: LD_VAR 0 9
37811: PUSH
37812: LD_INT 1
37814: ARRAY
37815: PPUSH
37816: LD_INT 112
37818: PPUSH
37819: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37823: LD_VAR 0 9
37827: PUSH
37828: LD_INT 1
37830: ARRAY
37831: PPUSH
37832: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37836: LD_EXP 120
37840: PUSH
37841: LD_VAR 0 2
37845: ARRAY
37846: PUSH
37847: LD_EXP 120
37851: PUSH
37852: LD_VAR 0 2
37856: ARRAY
37857: PUSH
37858: LD_INT 1
37860: ARRAY
37861: PPUSH
37862: CALL_OW 314
37866: NOT
37867: AND
37868: PUSH
37869: LD_EXP 120
37873: PUSH
37874: LD_VAR 0 2
37878: ARRAY
37879: PUSH
37880: LD_INT 1
37882: ARRAY
37883: PPUSH
37884: CALL_OW 310
37888: NOT
37889: AND
37890: IFFALSE 37916
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37892: LD_EXP 120
37896: PUSH
37897: LD_VAR 0 2
37901: ARRAY
37902: PUSH
37903: LD_INT 1
37905: ARRAY
37906: PPUSH
37907: LD_VAR 0 3
37911: PPUSH
37912: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37916: LD_EXP 120
37920: PUSH
37921: LD_VAR 0 2
37925: ARRAY
37926: PUSH
37927: LD_INT 1
37929: ARRAY
37930: PPUSH
37931: CALL_OW 310
37935: PUSH
37936: LD_EXP 120
37940: PUSH
37941: LD_VAR 0 2
37945: ARRAY
37946: PUSH
37947: LD_INT 1
37949: ARRAY
37950: PPUSH
37951: CALL_OW 310
37955: PPUSH
37956: CALL_OW 461
37960: PUSH
37961: LD_INT 3
37963: NONEQUAL
37964: AND
37965: IFFALSE 37986
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37967: LD_EXP 120
37971: PUSH
37972: LD_VAR 0 2
37976: ARRAY
37977: PUSH
37978: LD_INT 1
37980: ARRAY
37981: PPUSH
37982: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37986: LD_VAR 0 3
37990: PPUSH
37991: CALL_OW 461
37995: PUSH
37996: LD_INT 6
37998: EQUAL
37999: PUSH
38000: LD_VAR 0 6
38004: PUSH
38005: LD_INT 1
38007: GREATER
38008: AND
38009: IFFALSE 38161
// begin sci := [ ] ;
38011: LD_ADDR_VAR 0 8
38015: PUSH
38016: EMPTY
38017: ST_TO_ADDR
// for x in ( tmp diff j ) do
38018: LD_ADDR_VAR 0 7
38022: PUSH
38023: LD_VAR 0 6
38027: PUSH
38028: LD_VAR 0 3
38032: DIFF
38033: PUSH
38034: FOR_IN
38035: IFFALSE 38087
// begin if sci = 6 then
38037: LD_VAR 0 8
38041: PUSH
38042: LD_INT 6
38044: EQUAL
38045: IFFALSE 38049
// break ;
38047: GO 38087
// if BuildingStatus ( x ) = bs_idle then
38049: LD_VAR 0 7
38053: PPUSH
38054: CALL_OW 461
38058: PUSH
38059: LD_INT 2
38061: EQUAL
38062: IFFALSE 38085
// sci := sci ^ UnitsInside ( x ) ;
38064: LD_ADDR_VAR 0 8
38068: PUSH
38069: LD_VAR 0 8
38073: PUSH
38074: LD_VAR 0 7
38078: PPUSH
38079: CALL_OW 313
38083: ADD
38084: ST_TO_ADDR
// end ;
38085: GO 38034
38087: POP
38088: POP
// if not sci then
38089: LD_VAR 0 8
38093: NOT
38094: IFFALSE 38098
// continue ;
38096: GO 37143
// for x in sci do
38098: LD_ADDR_VAR 0 7
38102: PUSH
38103: LD_VAR 0 8
38107: PUSH
38108: FOR_IN
38109: IFFALSE 38159
// if IsInUnit ( x ) and not HasTask ( x ) then
38111: LD_VAR 0 7
38115: PPUSH
38116: CALL_OW 310
38120: PUSH
38121: LD_VAR 0 7
38125: PPUSH
38126: CALL_OW 314
38130: NOT
38131: AND
38132: IFFALSE 38157
// begin ComExitBuilding ( x ) ;
38134: LD_VAR 0 7
38138: PPUSH
38139: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38143: LD_VAR 0 7
38147: PPUSH
38148: LD_VAR 0 3
38152: PPUSH
38153: CALL_OW 180
// end ;
38157: GO 38108
38159: POP
38160: POP
// end ; end ;
38161: GO 37143
38163: POP
38164: POP
// end ;
38165: GO 37097
38167: POP
38168: POP
// end ;
38169: LD_VAR 0 1
38173: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38174: LD_INT 0
38176: PPUSH
38177: PPUSH
// if not mc_bases then
38178: LD_EXP 90
38182: NOT
38183: IFFALSE 38187
// exit ;
38185: GO 38268
// for i = 1 to mc_bases do
38187: LD_ADDR_VAR 0 2
38191: PUSH
38192: DOUBLE
38193: LD_INT 1
38195: DEC
38196: ST_TO_ADDR
38197: LD_EXP 90
38201: PUSH
38202: FOR_TO
38203: IFFALSE 38266
// if mc_mines [ i ] and mc_miners [ i ] then
38205: LD_EXP 103
38209: PUSH
38210: LD_VAR 0 2
38214: ARRAY
38215: PUSH
38216: LD_EXP 104
38220: PUSH
38221: LD_VAR 0 2
38225: ARRAY
38226: AND
38227: IFFALSE 38264
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38229: LD_EXP 104
38233: PUSH
38234: LD_VAR 0 2
38238: ARRAY
38239: PUSH
38240: LD_INT 1
38242: ARRAY
38243: PPUSH
38244: CALL_OW 255
38248: PPUSH
38249: LD_EXP 103
38253: PUSH
38254: LD_VAR 0 2
38258: ARRAY
38259: PPUSH
38260: CALL 52824 0 2
38264: GO 38202
38266: POP
38267: POP
// end ;
38268: LD_VAR 0 1
38272: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38273: LD_INT 0
38275: PPUSH
38276: PPUSH
38277: PPUSH
38278: PPUSH
38279: PPUSH
38280: PPUSH
38281: PPUSH
38282: PPUSH
// if not mc_bases or not mc_parking then
38283: LD_EXP 90
38287: NOT
38288: PUSH
38289: LD_EXP 114
38293: NOT
38294: OR
38295: IFFALSE 38299
// exit ;
38297: GO 38998
// for i = 1 to mc_bases do
38299: LD_ADDR_VAR 0 2
38303: PUSH
38304: DOUBLE
38305: LD_INT 1
38307: DEC
38308: ST_TO_ADDR
38309: LD_EXP 90
38313: PUSH
38314: FOR_TO
38315: IFFALSE 38996
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38317: LD_EXP 90
38321: PUSH
38322: LD_VAR 0 2
38326: ARRAY
38327: NOT
38328: PUSH
38329: LD_EXP 114
38333: PUSH
38334: LD_VAR 0 2
38338: ARRAY
38339: NOT
38340: OR
38341: IFFALSE 38345
// continue ;
38343: GO 38314
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38345: LD_ADDR_VAR 0 5
38349: PUSH
38350: LD_EXP 90
38354: PUSH
38355: LD_VAR 0 2
38359: ARRAY
38360: PUSH
38361: LD_INT 1
38363: ARRAY
38364: PPUSH
38365: CALL_OW 255
38369: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38370: LD_ADDR_VAR 0 6
38374: PUSH
38375: LD_EXP 90
38379: PUSH
38380: LD_VAR 0 2
38384: ARRAY
38385: PPUSH
38386: LD_INT 30
38388: PUSH
38389: LD_INT 3
38391: PUSH
38392: EMPTY
38393: LIST
38394: LIST
38395: PPUSH
38396: CALL_OW 72
38400: ST_TO_ADDR
// if not fac then
38401: LD_VAR 0 6
38405: NOT
38406: IFFALSE 38457
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38408: LD_ADDR_VAR 0 6
38412: PUSH
38413: LD_EXP 90
38417: PUSH
38418: LD_VAR 0 2
38422: ARRAY
38423: PPUSH
38424: LD_INT 2
38426: PUSH
38427: LD_INT 30
38429: PUSH
38430: LD_INT 0
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: PUSH
38437: LD_INT 30
38439: PUSH
38440: LD_INT 1
38442: PUSH
38443: EMPTY
38444: LIST
38445: LIST
38446: PUSH
38447: EMPTY
38448: LIST
38449: LIST
38450: LIST
38451: PPUSH
38452: CALL_OW 72
38456: ST_TO_ADDR
// if not fac then
38457: LD_VAR 0 6
38461: NOT
38462: IFFALSE 38466
// continue ;
38464: GO 38314
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38466: LD_ADDR_VAR 0 7
38470: PUSH
38471: LD_EXP 114
38475: PUSH
38476: LD_VAR 0 2
38480: ARRAY
38481: PPUSH
38482: LD_INT 22
38484: PUSH
38485: LD_VAR 0 5
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: LD_INT 21
38496: PUSH
38497: LD_INT 2
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 3
38506: PUSH
38507: LD_INT 24
38509: PUSH
38510: LD_INT 1000
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: LIST
38525: PPUSH
38526: CALL_OW 70
38530: ST_TO_ADDR
// for j in fac do
38531: LD_ADDR_VAR 0 3
38535: PUSH
38536: LD_VAR 0 6
38540: PUSH
38541: FOR_IN
38542: IFFALSE 38623
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38544: LD_ADDR_VAR 0 7
38548: PUSH
38549: LD_VAR 0 7
38553: PUSH
38554: LD_INT 22
38556: PUSH
38557: LD_VAR 0 5
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 91
38568: PUSH
38569: LD_VAR 0 3
38573: PUSH
38574: LD_INT 15
38576: PUSH
38577: EMPTY
38578: LIST
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 21
38584: PUSH
38585: LD_INT 2
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 3
38594: PUSH
38595: LD_INT 24
38597: PUSH
38598: LD_INT 1000
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: PPUSH
38615: CALL_OW 69
38619: UNION
38620: ST_TO_ADDR
38621: GO 38541
38623: POP
38624: POP
// if not vehs then
38625: LD_VAR 0 7
38629: NOT
38630: IFFALSE 38656
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38632: LD_ADDR_EXP 102
38636: PUSH
38637: LD_EXP 102
38641: PPUSH
38642: LD_VAR 0 2
38646: PPUSH
38647: EMPTY
38648: PPUSH
38649: CALL_OW 1
38653: ST_TO_ADDR
// continue ;
38654: GO 38314
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38656: LD_ADDR_VAR 0 8
38660: PUSH
38661: LD_EXP 90
38665: PUSH
38666: LD_VAR 0 2
38670: ARRAY
38671: PPUSH
38672: LD_INT 30
38674: PUSH
38675: LD_INT 3
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PPUSH
38682: CALL_OW 72
38686: ST_TO_ADDR
// if tmp then
38687: LD_VAR 0 8
38691: IFFALSE 38794
// begin for j in tmp do
38693: LD_ADDR_VAR 0 3
38697: PUSH
38698: LD_VAR 0 8
38702: PUSH
38703: FOR_IN
38704: IFFALSE 38792
// for k in UnitsInside ( j ) do
38706: LD_ADDR_VAR 0 4
38710: PUSH
38711: LD_VAR 0 3
38715: PPUSH
38716: CALL_OW 313
38720: PUSH
38721: FOR_IN
38722: IFFALSE 38788
// if k then
38724: LD_VAR 0 4
38728: IFFALSE 38786
// if not k in mc_repair_vehicle [ i ] then
38730: LD_VAR 0 4
38734: PUSH
38735: LD_EXP 102
38739: PUSH
38740: LD_VAR 0 2
38744: ARRAY
38745: IN
38746: NOT
38747: IFFALSE 38786
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38749: LD_ADDR_EXP 102
38753: PUSH
38754: LD_EXP 102
38758: PPUSH
38759: LD_VAR 0 2
38763: PPUSH
38764: LD_EXP 102
38768: PUSH
38769: LD_VAR 0 2
38773: ARRAY
38774: PUSH
38775: LD_VAR 0 4
38779: UNION
38780: PPUSH
38781: CALL_OW 1
38785: ST_TO_ADDR
38786: GO 38721
38788: POP
38789: POP
38790: GO 38703
38792: POP
38793: POP
// end ; if not mc_repair_vehicle [ i ] then
38794: LD_EXP 102
38798: PUSH
38799: LD_VAR 0 2
38803: ARRAY
38804: NOT
38805: IFFALSE 38809
// continue ;
38807: GO 38314
// for j in mc_repair_vehicle [ i ] do
38809: LD_ADDR_VAR 0 3
38813: PUSH
38814: LD_EXP 102
38818: PUSH
38819: LD_VAR 0 2
38823: ARRAY
38824: PUSH
38825: FOR_IN
38826: IFFALSE 38992
// begin if GetClass ( j ) <> 3 then
38828: LD_VAR 0 3
38832: PPUSH
38833: CALL_OW 257
38837: PUSH
38838: LD_INT 3
38840: NONEQUAL
38841: IFFALSE 38882
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38843: LD_ADDR_EXP 102
38847: PUSH
38848: LD_EXP 102
38852: PPUSH
38853: LD_VAR 0 2
38857: PPUSH
38858: LD_EXP 102
38862: PUSH
38863: LD_VAR 0 2
38867: ARRAY
38868: PUSH
38869: LD_VAR 0 3
38873: DIFF
38874: PPUSH
38875: CALL_OW 1
38879: ST_TO_ADDR
// continue ;
38880: GO 38825
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38882: LD_VAR 0 3
38886: PPUSH
38887: CALL_OW 311
38891: NOT
38892: PUSH
38893: LD_VAR 0 3
38897: PUSH
38898: LD_EXP 93
38902: PUSH
38903: LD_VAR 0 2
38907: ARRAY
38908: PUSH
38909: LD_INT 1
38911: ARRAY
38912: IN
38913: NOT
38914: AND
38915: PUSH
38916: LD_VAR 0 3
38920: PUSH
38921: LD_EXP 93
38925: PUSH
38926: LD_VAR 0 2
38930: ARRAY
38931: PUSH
38932: LD_INT 2
38934: ARRAY
38935: IN
38936: NOT
38937: AND
38938: IFFALSE 38990
// begin if IsInUnit ( j ) then
38940: LD_VAR 0 3
38944: PPUSH
38945: CALL_OW 310
38949: IFFALSE 38960
// ComExitBuilding ( j ) ;
38951: LD_VAR 0 3
38955: PPUSH
38956: CALL_OW 122
// if not HasTask ( j ) then
38960: LD_VAR 0 3
38964: PPUSH
38965: CALL_OW 314
38969: NOT
38970: IFFALSE 38990
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38972: LD_VAR 0 3
38976: PPUSH
38977: LD_VAR 0 7
38981: PUSH
38982: LD_INT 1
38984: ARRAY
38985: PPUSH
38986: CALL_OW 189
// end ; end ;
38990: GO 38825
38992: POP
38993: POP
// end ;
38994: GO 38314
38996: POP
38997: POP
// end ;
38998: LD_VAR 0 1
39002: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
39003: LD_INT 0
39005: PPUSH
39006: PPUSH
39007: PPUSH
39008: PPUSH
39009: PPUSH
39010: PPUSH
39011: PPUSH
39012: PPUSH
39013: PPUSH
39014: PPUSH
39015: PPUSH
// if not mc_bases then
39016: LD_EXP 90
39020: NOT
39021: IFFALSE 39025
// exit ;
39023: GO 39827
// for i = 1 to mc_bases do
39025: LD_ADDR_VAR 0 2
39029: PUSH
39030: DOUBLE
39031: LD_INT 1
39033: DEC
39034: ST_TO_ADDR
39035: LD_EXP 90
39039: PUSH
39040: FOR_TO
39041: IFFALSE 39825
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
39043: LD_EXP 118
39047: PUSH
39048: LD_VAR 0 2
39052: ARRAY
39053: NOT
39054: PUSH
39055: LD_EXP 93
39059: PUSH
39060: LD_VAR 0 2
39064: ARRAY
39065: PUSH
39066: LD_INT 1
39068: ARRAY
39069: OR
39070: PUSH
39071: LD_EXP 93
39075: PUSH
39076: LD_VAR 0 2
39080: ARRAY
39081: PUSH
39082: LD_INT 2
39084: ARRAY
39085: OR
39086: PUSH
39087: LD_EXP 116
39091: PUSH
39092: LD_VAR 0 2
39096: ARRAY
39097: PPUSH
39098: LD_INT 1
39100: PPUSH
39101: CALL_OW 325
39105: NOT
39106: OR
39107: PUSH
39108: LD_EXP 113
39112: PUSH
39113: LD_VAR 0 2
39117: ARRAY
39118: OR
39119: IFFALSE 39123
// continue ;
39121: GO 39040
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39123: LD_ADDR_VAR 0 8
39127: PUSH
39128: LD_EXP 90
39132: PUSH
39133: LD_VAR 0 2
39137: ARRAY
39138: PPUSH
39139: LD_INT 25
39141: PUSH
39142: LD_INT 4
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 50
39151: PUSH
39152: EMPTY
39153: LIST
39154: PUSH
39155: LD_INT 3
39157: PUSH
39158: LD_INT 60
39160: PUSH
39161: EMPTY
39162: LIST
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: LIST
39172: PPUSH
39173: CALL_OW 72
39177: PUSH
39178: LD_EXP 94
39182: PUSH
39183: LD_VAR 0 2
39187: ARRAY
39188: DIFF
39189: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39190: LD_ADDR_VAR 0 9
39194: PUSH
39195: LD_EXP 90
39199: PUSH
39200: LD_VAR 0 2
39204: ARRAY
39205: PPUSH
39206: LD_INT 2
39208: PUSH
39209: LD_INT 30
39211: PUSH
39212: LD_INT 0
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: PUSH
39219: LD_INT 30
39221: PUSH
39222: LD_INT 1
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: LIST
39233: PPUSH
39234: CALL_OW 72
39238: ST_TO_ADDR
// if not tmp or not dep then
39239: LD_VAR 0 8
39243: NOT
39244: PUSH
39245: LD_VAR 0 9
39249: NOT
39250: OR
39251: IFFALSE 39255
// continue ;
39253: GO 39040
// side := GetSide ( tmp [ 1 ] ) ;
39255: LD_ADDR_VAR 0 11
39259: PUSH
39260: LD_VAR 0 8
39264: PUSH
39265: LD_INT 1
39267: ARRAY
39268: PPUSH
39269: CALL_OW 255
39273: ST_TO_ADDR
// dep := dep [ 1 ] ;
39274: LD_ADDR_VAR 0 9
39278: PUSH
39279: LD_VAR 0 9
39283: PUSH
39284: LD_INT 1
39286: ARRAY
39287: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39288: LD_ADDR_VAR 0 7
39292: PUSH
39293: LD_EXP 118
39297: PUSH
39298: LD_VAR 0 2
39302: ARRAY
39303: PPUSH
39304: LD_INT 22
39306: PUSH
39307: LD_INT 0
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 25
39316: PUSH
39317: LD_INT 12
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PPUSH
39328: CALL_OW 70
39332: PUSH
39333: LD_INT 22
39335: PUSH
39336: LD_INT 0
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 25
39345: PUSH
39346: LD_INT 12
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 91
39355: PUSH
39356: LD_VAR 0 9
39360: PUSH
39361: LD_INT 20
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: LIST
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: LIST
39373: PPUSH
39374: CALL_OW 69
39378: UNION
39379: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39380: LD_ADDR_VAR 0 10
39384: PUSH
39385: LD_EXP 118
39389: PUSH
39390: LD_VAR 0 2
39394: ARRAY
39395: PPUSH
39396: LD_INT 81
39398: PUSH
39399: LD_VAR 0 11
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PPUSH
39408: CALL_OW 70
39412: ST_TO_ADDR
// if not apes or danger_at_area then
39413: LD_VAR 0 7
39417: NOT
39418: PUSH
39419: LD_VAR 0 10
39423: OR
39424: IFFALSE 39474
// begin if mc_taming [ i ] then
39426: LD_EXP 121
39430: PUSH
39431: LD_VAR 0 2
39435: ARRAY
39436: IFFALSE 39472
// begin MC_Reset ( i , 121 ) ;
39438: LD_VAR 0 2
39442: PPUSH
39443: LD_INT 121
39445: PPUSH
39446: CALL 24856 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39450: LD_ADDR_EXP 121
39454: PUSH
39455: LD_EXP 121
39459: PPUSH
39460: LD_VAR 0 2
39464: PPUSH
39465: EMPTY
39466: PPUSH
39467: CALL_OW 1
39471: ST_TO_ADDR
// end ; continue ;
39472: GO 39040
// end ; for j in tmp do
39474: LD_ADDR_VAR 0 3
39478: PUSH
39479: LD_VAR 0 8
39483: PUSH
39484: FOR_IN
39485: IFFALSE 39821
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39487: LD_VAR 0 3
39491: PUSH
39492: LD_EXP 121
39496: PUSH
39497: LD_VAR 0 2
39501: ARRAY
39502: IN
39503: NOT
39504: PUSH
39505: LD_EXP 121
39509: PUSH
39510: LD_VAR 0 2
39514: ARRAY
39515: PUSH
39516: LD_INT 3
39518: LESS
39519: AND
39520: IFFALSE 39578
// begin SetTag ( j , 121 ) ;
39522: LD_VAR 0 3
39526: PPUSH
39527: LD_INT 121
39529: PPUSH
39530: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39534: LD_ADDR_EXP 121
39538: PUSH
39539: LD_EXP 121
39543: PPUSH
39544: LD_VAR 0 2
39548: PUSH
39549: LD_EXP 121
39553: PUSH
39554: LD_VAR 0 2
39558: ARRAY
39559: PUSH
39560: LD_INT 1
39562: PLUS
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PPUSH
39568: LD_VAR 0 3
39572: PPUSH
39573: CALL 55835 0 3
39577: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39578: LD_VAR 0 3
39582: PUSH
39583: LD_EXP 121
39587: PUSH
39588: LD_VAR 0 2
39592: ARRAY
39593: IN
39594: IFFALSE 39819
// begin if GetClass ( j ) <> 4 then
39596: LD_VAR 0 3
39600: PPUSH
39601: CALL_OW 257
39605: PUSH
39606: LD_INT 4
39608: NONEQUAL
39609: IFFALSE 39662
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39611: LD_ADDR_EXP 121
39615: PUSH
39616: LD_EXP 121
39620: PPUSH
39621: LD_VAR 0 2
39625: PPUSH
39626: LD_EXP 121
39630: PUSH
39631: LD_VAR 0 2
39635: ARRAY
39636: PUSH
39637: LD_VAR 0 3
39641: DIFF
39642: PPUSH
39643: CALL_OW 1
39647: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39648: LD_VAR 0 3
39652: PPUSH
39653: LD_INT 0
39655: PPUSH
39656: CALL_OW 109
// continue ;
39660: GO 39484
// end ; if IsInUnit ( j ) then
39662: LD_VAR 0 3
39666: PPUSH
39667: CALL_OW 310
39671: IFFALSE 39682
// ComExitBuilding ( j ) ;
39673: LD_VAR 0 3
39677: PPUSH
39678: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39682: LD_ADDR_VAR 0 6
39686: PUSH
39687: LD_VAR 0 7
39691: PPUSH
39692: LD_VAR 0 3
39696: PPUSH
39697: CALL_OW 74
39701: ST_TO_ADDR
// if not ape then
39702: LD_VAR 0 6
39706: NOT
39707: IFFALSE 39711
// break ;
39709: GO 39821
// x := GetX ( ape ) ;
39711: LD_ADDR_VAR 0 4
39715: PUSH
39716: LD_VAR 0 6
39720: PPUSH
39721: CALL_OW 250
39725: ST_TO_ADDR
// y := GetY ( ape ) ;
39726: LD_ADDR_VAR 0 5
39730: PUSH
39731: LD_VAR 0 6
39735: PPUSH
39736: CALL_OW 251
39740: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39741: LD_VAR 0 4
39745: PPUSH
39746: LD_VAR 0 5
39750: PPUSH
39751: CALL_OW 488
39755: NOT
39756: PUSH
39757: LD_VAR 0 11
39761: PPUSH
39762: LD_VAR 0 4
39766: PPUSH
39767: LD_VAR 0 5
39771: PPUSH
39772: LD_INT 20
39774: PPUSH
39775: CALL 56731 0 4
39779: PUSH
39780: LD_INT 4
39782: ARRAY
39783: OR
39784: IFFALSE 39788
// break ;
39786: GO 39821
// if not HasTask ( j ) then
39788: LD_VAR 0 3
39792: PPUSH
39793: CALL_OW 314
39797: NOT
39798: IFFALSE 39819
// ComTameXY ( j , x , y ) ;
39800: LD_VAR 0 3
39804: PPUSH
39805: LD_VAR 0 4
39809: PPUSH
39810: LD_VAR 0 5
39814: PPUSH
39815: CALL_OW 131
// end ; end ;
39819: GO 39484
39821: POP
39822: POP
// end ;
39823: GO 39040
39825: POP
39826: POP
// end ;
39827: LD_VAR 0 1
39831: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39832: LD_INT 0
39834: PPUSH
39835: PPUSH
39836: PPUSH
39837: PPUSH
39838: PPUSH
39839: PPUSH
39840: PPUSH
39841: PPUSH
// if not mc_bases then
39842: LD_EXP 90
39846: NOT
39847: IFFALSE 39851
// exit ;
39849: GO 40477
// for i = 1 to mc_bases do
39851: LD_ADDR_VAR 0 2
39855: PUSH
39856: DOUBLE
39857: LD_INT 1
39859: DEC
39860: ST_TO_ADDR
39861: LD_EXP 90
39865: PUSH
39866: FOR_TO
39867: IFFALSE 40475
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39869: LD_EXP 119
39873: PUSH
39874: LD_VAR 0 2
39878: ARRAY
39879: NOT
39880: PUSH
39881: LD_EXP 119
39885: PUSH
39886: LD_VAR 0 2
39890: ARRAY
39891: PPUSH
39892: LD_INT 25
39894: PUSH
39895: LD_INT 12
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: PPUSH
39902: CALL_OW 72
39906: NOT
39907: OR
39908: IFFALSE 39912
// continue ;
39910: GO 39866
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39912: LD_ADDR_VAR 0 5
39916: PUSH
39917: LD_EXP 119
39921: PUSH
39922: LD_VAR 0 2
39926: ARRAY
39927: PUSH
39928: LD_INT 1
39930: ARRAY
39931: PPUSH
39932: CALL_OW 255
39936: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39937: LD_VAR 0 5
39941: PPUSH
39942: LD_INT 2
39944: PPUSH
39945: CALL_OW 325
39949: IFFALSE 40202
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39951: LD_ADDR_VAR 0 4
39955: PUSH
39956: LD_EXP 119
39960: PUSH
39961: LD_VAR 0 2
39965: ARRAY
39966: PPUSH
39967: LD_INT 25
39969: PUSH
39970: LD_INT 16
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PPUSH
39977: CALL_OW 72
39981: ST_TO_ADDR
// if tmp < 6 then
39982: LD_VAR 0 4
39986: PUSH
39987: LD_INT 6
39989: LESS
39990: IFFALSE 40202
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39992: LD_ADDR_VAR 0 6
39996: PUSH
39997: LD_EXP 90
40001: PUSH
40002: LD_VAR 0 2
40006: ARRAY
40007: PPUSH
40008: LD_INT 2
40010: PUSH
40011: LD_INT 30
40013: PUSH
40014: LD_INT 0
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 30
40023: PUSH
40024: LD_INT 1
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: LIST
40035: PPUSH
40036: CALL_OW 72
40040: ST_TO_ADDR
// if depot then
40041: LD_VAR 0 6
40045: IFFALSE 40202
// begin selected := 0 ;
40047: LD_ADDR_VAR 0 7
40051: PUSH
40052: LD_INT 0
40054: ST_TO_ADDR
// for j in depot do
40055: LD_ADDR_VAR 0 3
40059: PUSH
40060: LD_VAR 0 6
40064: PUSH
40065: FOR_IN
40066: IFFALSE 40097
// begin if UnitsInside ( j ) < 6 then
40068: LD_VAR 0 3
40072: PPUSH
40073: CALL_OW 313
40077: PUSH
40078: LD_INT 6
40080: LESS
40081: IFFALSE 40095
// begin selected := j ;
40083: LD_ADDR_VAR 0 7
40087: PUSH
40088: LD_VAR 0 3
40092: ST_TO_ADDR
// break ;
40093: GO 40097
// end ; end ;
40095: GO 40065
40097: POP
40098: POP
// if selected then
40099: LD_VAR 0 7
40103: IFFALSE 40202
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40105: LD_ADDR_VAR 0 3
40109: PUSH
40110: LD_EXP 119
40114: PUSH
40115: LD_VAR 0 2
40119: ARRAY
40120: PPUSH
40121: LD_INT 25
40123: PUSH
40124: LD_INT 12
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PPUSH
40131: CALL_OW 72
40135: PUSH
40136: FOR_IN
40137: IFFALSE 40200
// if not HasTask ( j ) then
40139: LD_VAR 0 3
40143: PPUSH
40144: CALL_OW 314
40148: NOT
40149: IFFALSE 40198
// begin if not IsInUnit ( j ) then
40151: LD_VAR 0 3
40155: PPUSH
40156: CALL_OW 310
40160: NOT
40161: IFFALSE 40177
// ComEnterUnit ( j , selected ) ;
40163: LD_VAR 0 3
40167: PPUSH
40168: LD_VAR 0 7
40172: PPUSH
40173: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40177: LD_VAR 0 3
40181: PPUSH
40182: LD_INT 16
40184: PPUSH
40185: CALL_OW 183
// AddComExitBuilding ( j ) ;
40189: LD_VAR 0 3
40193: PPUSH
40194: CALL_OW 182
// end ;
40198: GO 40136
40200: POP
40201: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40202: LD_VAR 0 5
40206: PPUSH
40207: LD_INT 11
40209: PPUSH
40210: CALL_OW 325
40214: IFFALSE 40473
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40216: LD_ADDR_VAR 0 4
40220: PUSH
40221: LD_EXP 119
40225: PUSH
40226: LD_VAR 0 2
40230: ARRAY
40231: PPUSH
40232: LD_INT 25
40234: PUSH
40235: LD_INT 16
40237: PUSH
40238: EMPTY
40239: LIST
40240: LIST
40241: PPUSH
40242: CALL_OW 72
40246: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40247: LD_VAR 0 4
40251: PUSH
40252: LD_INT 6
40254: GREATEREQUAL
40255: PUSH
40256: LD_VAR 0 5
40260: PPUSH
40261: LD_INT 2
40263: PPUSH
40264: CALL_OW 325
40268: NOT
40269: OR
40270: IFFALSE 40473
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40272: LD_ADDR_VAR 0 8
40276: PUSH
40277: LD_EXP 90
40281: PUSH
40282: LD_VAR 0 2
40286: ARRAY
40287: PPUSH
40288: LD_INT 2
40290: PUSH
40291: LD_INT 30
40293: PUSH
40294: LD_INT 4
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 30
40303: PUSH
40304: LD_INT 5
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: LIST
40315: PPUSH
40316: CALL_OW 72
40320: ST_TO_ADDR
// if barracks then
40321: LD_VAR 0 8
40325: IFFALSE 40473
// begin selected := 0 ;
40327: LD_ADDR_VAR 0 7
40331: PUSH
40332: LD_INT 0
40334: ST_TO_ADDR
// for j in barracks do
40335: LD_ADDR_VAR 0 3
40339: PUSH
40340: LD_VAR 0 8
40344: PUSH
40345: FOR_IN
40346: IFFALSE 40377
// begin if UnitsInside ( j ) < 6 then
40348: LD_VAR 0 3
40352: PPUSH
40353: CALL_OW 313
40357: PUSH
40358: LD_INT 6
40360: LESS
40361: IFFALSE 40375
// begin selected := j ;
40363: LD_ADDR_VAR 0 7
40367: PUSH
40368: LD_VAR 0 3
40372: ST_TO_ADDR
// break ;
40373: GO 40377
// end ; end ;
40375: GO 40345
40377: POP
40378: POP
// if selected then
40379: LD_VAR 0 7
40383: IFFALSE 40473
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40385: LD_ADDR_VAR 0 3
40389: PUSH
40390: LD_EXP 119
40394: PUSH
40395: LD_VAR 0 2
40399: ARRAY
40400: PPUSH
40401: LD_INT 25
40403: PUSH
40404: LD_INT 12
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PPUSH
40411: CALL_OW 72
40415: PUSH
40416: FOR_IN
40417: IFFALSE 40471
// if not IsInUnit ( j ) and not HasTask ( j ) then
40419: LD_VAR 0 3
40423: PPUSH
40424: CALL_OW 310
40428: NOT
40429: PUSH
40430: LD_VAR 0 3
40434: PPUSH
40435: CALL_OW 314
40439: NOT
40440: AND
40441: IFFALSE 40469
// begin ComEnterUnit ( j , selected ) ;
40443: LD_VAR 0 3
40447: PPUSH
40448: LD_VAR 0 7
40452: PPUSH
40453: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40457: LD_VAR 0 3
40461: PPUSH
40462: LD_INT 15
40464: PPUSH
40465: CALL_OW 183
// end ;
40469: GO 40416
40471: POP
40472: POP
// end ; end ; end ; end ; end ;
40473: GO 39866
40475: POP
40476: POP
// end ;
40477: LD_VAR 0 1
40481: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40482: LD_INT 0
40484: PPUSH
40485: PPUSH
40486: PPUSH
40487: PPUSH
// if not mc_bases then
40488: LD_EXP 90
40492: NOT
40493: IFFALSE 40497
// exit ;
40495: GO 40675
// for i = 1 to mc_bases do
40497: LD_ADDR_VAR 0 2
40501: PUSH
40502: DOUBLE
40503: LD_INT 1
40505: DEC
40506: ST_TO_ADDR
40507: LD_EXP 90
40511: PUSH
40512: FOR_TO
40513: IFFALSE 40673
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40515: LD_ADDR_VAR 0 4
40519: PUSH
40520: LD_EXP 90
40524: PUSH
40525: LD_VAR 0 2
40529: ARRAY
40530: PPUSH
40531: LD_INT 25
40533: PUSH
40534: LD_INT 9
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: PPUSH
40541: CALL_OW 72
40545: ST_TO_ADDR
// if not tmp then
40546: LD_VAR 0 4
40550: NOT
40551: IFFALSE 40555
// continue ;
40553: GO 40512
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40555: LD_EXP 116
40559: PUSH
40560: LD_VAR 0 2
40564: ARRAY
40565: PPUSH
40566: LD_INT 29
40568: PPUSH
40569: CALL_OW 325
40573: NOT
40574: PUSH
40575: LD_EXP 116
40579: PUSH
40580: LD_VAR 0 2
40584: ARRAY
40585: PPUSH
40586: LD_INT 28
40588: PPUSH
40589: CALL_OW 325
40593: NOT
40594: AND
40595: IFFALSE 40599
// continue ;
40597: GO 40512
// for j in tmp do
40599: LD_ADDR_VAR 0 3
40603: PUSH
40604: LD_VAR 0 4
40608: PUSH
40609: FOR_IN
40610: IFFALSE 40669
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40612: LD_VAR 0 3
40616: PUSH
40617: LD_EXP 93
40621: PUSH
40622: LD_VAR 0 2
40626: ARRAY
40627: PUSH
40628: LD_INT 1
40630: ARRAY
40631: IN
40632: NOT
40633: PUSH
40634: LD_VAR 0 3
40638: PUSH
40639: LD_EXP 93
40643: PUSH
40644: LD_VAR 0 2
40648: ARRAY
40649: PUSH
40650: LD_INT 2
40652: ARRAY
40653: IN
40654: NOT
40655: AND
40656: IFFALSE 40667
// ComSpaceTimeShoot ( j ) ;
40658: LD_VAR 0 3
40662: PPUSH
40663: CALL 51832 0 1
40667: GO 40609
40669: POP
40670: POP
// end ;
40671: GO 40512
40673: POP
40674: POP
// end ;
40675: LD_VAR 0 1
40679: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40680: LD_INT 0
40682: PPUSH
40683: PPUSH
40684: PPUSH
40685: PPUSH
40686: PPUSH
40687: PPUSH
40688: PPUSH
40689: PPUSH
40690: PPUSH
// if not mc_bases then
40691: LD_EXP 90
40695: NOT
40696: IFFALSE 40700
// exit ;
40698: GO 41322
// for i = 1 to mc_bases do
40700: LD_ADDR_VAR 0 2
40704: PUSH
40705: DOUBLE
40706: LD_INT 1
40708: DEC
40709: ST_TO_ADDR
40710: LD_EXP 90
40714: PUSH
40715: FOR_TO
40716: IFFALSE 41320
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40718: LD_EXP 125
40722: PUSH
40723: LD_VAR 0 2
40727: ARRAY
40728: NOT
40729: PUSH
40730: LD_INT 38
40732: PPUSH
40733: LD_EXP 116
40737: PUSH
40738: LD_VAR 0 2
40742: ARRAY
40743: PPUSH
40744: CALL_OW 321
40748: PUSH
40749: LD_INT 2
40751: NONEQUAL
40752: OR
40753: IFFALSE 40757
// continue ;
40755: GO 40715
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40757: LD_ADDR_VAR 0 8
40761: PUSH
40762: LD_EXP 90
40766: PUSH
40767: LD_VAR 0 2
40771: ARRAY
40772: PPUSH
40773: LD_INT 30
40775: PUSH
40776: LD_INT 34
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PPUSH
40783: CALL_OW 72
40787: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40788: LD_ADDR_VAR 0 9
40792: PUSH
40793: LD_EXP 90
40797: PUSH
40798: LD_VAR 0 2
40802: ARRAY
40803: PPUSH
40804: LD_INT 25
40806: PUSH
40807: LD_INT 4
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PPUSH
40814: CALL_OW 72
40818: PPUSH
40819: LD_INT 0
40821: PPUSH
40822: CALL 84729 0 2
40826: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40827: LD_VAR 0 9
40831: NOT
40832: PUSH
40833: LD_VAR 0 8
40837: NOT
40838: OR
40839: PUSH
40840: LD_EXP 90
40844: PUSH
40845: LD_VAR 0 2
40849: ARRAY
40850: PPUSH
40851: LD_INT 124
40853: PPUSH
40854: CALL 84729 0 2
40858: OR
40859: IFFALSE 40863
// continue ;
40861: GO 40715
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40863: LD_EXP 126
40867: PUSH
40868: LD_VAR 0 2
40872: ARRAY
40873: PUSH
40874: LD_EXP 125
40878: PUSH
40879: LD_VAR 0 2
40883: ARRAY
40884: LESS
40885: PUSH
40886: LD_EXP 126
40890: PUSH
40891: LD_VAR 0 2
40895: ARRAY
40896: PUSH
40897: LD_VAR 0 8
40901: LESS
40902: AND
40903: IFFALSE 41318
// begin tmp := sci [ 1 ] ;
40905: LD_ADDR_VAR 0 7
40909: PUSH
40910: LD_VAR 0 9
40914: PUSH
40915: LD_INT 1
40917: ARRAY
40918: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40919: LD_VAR 0 7
40923: PPUSH
40924: LD_INT 124
40926: PPUSH
40927: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40931: LD_ADDR_VAR 0 3
40935: PUSH
40936: DOUBLE
40937: LD_EXP 125
40941: PUSH
40942: LD_VAR 0 2
40946: ARRAY
40947: INC
40948: ST_TO_ADDR
40949: LD_EXP 125
40953: PUSH
40954: LD_VAR 0 2
40958: ARRAY
40959: PUSH
40960: FOR_DOWNTO
40961: IFFALSE 41304
// begin if IsInUnit ( tmp ) then
40963: LD_VAR 0 7
40967: PPUSH
40968: CALL_OW 310
40972: IFFALSE 40983
// ComExitBuilding ( tmp ) ;
40974: LD_VAR 0 7
40978: PPUSH
40979: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40983: LD_INT 35
40985: PPUSH
40986: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40990: LD_VAR 0 7
40994: PPUSH
40995: CALL_OW 310
40999: NOT
41000: PUSH
41001: LD_VAR 0 7
41005: PPUSH
41006: CALL_OW 314
41010: NOT
41011: AND
41012: IFFALSE 40983
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
41014: LD_ADDR_VAR 0 6
41018: PUSH
41019: LD_VAR 0 7
41023: PPUSH
41024: CALL_OW 250
41028: PUSH
41029: LD_VAR 0 7
41033: PPUSH
41034: CALL_OW 251
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41043: LD_INT 35
41045: PPUSH
41046: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
41050: LD_ADDR_VAR 0 4
41054: PUSH
41055: LD_EXP 125
41059: PUSH
41060: LD_VAR 0 2
41064: ARRAY
41065: PUSH
41066: LD_VAR 0 3
41070: ARRAY
41071: PUSH
41072: LD_INT 1
41074: ARRAY
41075: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
41076: LD_ADDR_VAR 0 5
41080: PUSH
41081: LD_EXP 125
41085: PUSH
41086: LD_VAR 0 2
41090: ARRAY
41091: PUSH
41092: LD_VAR 0 3
41096: ARRAY
41097: PUSH
41098: LD_INT 2
41100: ARRAY
41101: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
41102: LD_VAR 0 7
41106: PPUSH
41107: LD_INT 10
41109: PPUSH
41110: CALL 58428 0 2
41114: PUSH
41115: LD_INT 4
41117: ARRAY
41118: IFFALSE 41156
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
41120: LD_VAR 0 7
41124: PPUSH
41125: LD_VAR 0 6
41129: PUSH
41130: LD_INT 1
41132: ARRAY
41133: PPUSH
41134: LD_VAR 0 6
41138: PUSH
41139: LD_INT 2
41141: ARRAY
41142: PPUSH
41143: CALL_OW 111
// wait ( 0 0$10 ) ;
41147: LD_INT 350
41149: PPUSH
41150: CALL_OW 67
// end else
41154: GO 41182
// begin ComMoveXY ( tmp , x , y ) ;
41156: LD_VAR 0 7
41160: PPUSH
41161: LD_VAR 0 4
41165: PPUSH
41166: LD_VAR 0 5
41170: PPUSH
41171: CALL_OW 111
// wait ( 0 0$3 ) ;
41175: LD_INT 105
41177: PPUSH
41178: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41182: LD_VAR 0 7
41186: PPUSH
41187: LD_VAR 0 4
41191: PPUSH
41192: LD_VAR 0 5
41196: PPUSH
41197: CALL_OW 307
41201: IFFALSE 41043
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41203: LD_VAR 0 7
41207: PPUSH
41208: LD_VAR 0 4
41212: PPUSH
41213: LD_VAR 0 5
41217: PPUSH
41218: LD_VAR 0 8
41222: PUSH
41223: LD_VAR 0 3
41227: ARRAY
41228: PPUSH
41229: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41233: LD_INT 35
41235: PPUSH
41236: CALL_OW 67
// until not HasTask ( tmp ) ;
41240: LD_VAR 0 7
41244: PPUSH
41245: CALL_OW 314
41249: NOT
41250: IFFALSE 41233
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41252: LD_ADDR_EXP 126
41256: PUSH
41257: LD_EXP 126
41261: PPUSH
41262: LD_VAR 0 2
41266: PUSH
41267: LD_EXP 126
41271: PUSH
41272: LD_VAR 0 2
41276: ARRAY
41277: PUSH
41278: LD_INT 1
41280: PLUS
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PPUSH
41286: LD_VAR 0 8
41290: PUSH
41291: LD_VAR 0 3
41295: ARRAY
41296: PPUSH
41297: CALL 55835 0 3
41301: ST_TO_ADDR
// end ;
41302: GO 40960
41304: POP
41305: POP
// MC_Reset ( i , 124 ) ;
41306: LD_VAR 0 2
41310: PPUSH
41311: LD_INT 124
41313: PPUSH
41314: CALL 24856 0 2
// end ; end ;
41318: GO 40715
41320: POP
41321: POP
// end ;
41322: LD_VAR 0 1
41326: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41327: LD_INT 0
41329: PPUSH
41330: PPUSH
41331: PPUSH
// if not mc_bases then
41332: LD_EXP 90
41336: NOT
41337: IFFALSE 41341
// exit ;
41339: GO 41947
// for i = 1 to mc_bases do
41341: LD_ADDR_VAR 0 2
41345: PUSH
41346: DOUBLE
41347: LD_INT 1
41349: DEC
41350: ST_TO_ADDR
41351: LD_EXP 90
41355: PUSH
41356: FOR_TO
41357: IFFALSE 41945
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41359: LD_ADDR_VAR 0 3
41363: PUSH
41364: LD_EXP 90
41368: PUSH
41369: LD_VAR 0 2
41373: ARRAY
41374: PPUSH
41375: LD_INT 25
41377: PUSH
41378: LD_INT 4
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PPUSH
41385: CALL_OW 72
41389: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41390: LD_VAR 0 3
41394: NOT
41395: PUSH
41396: LD_EXP 127
41400: PUSH
41401: LD_VAR 0 2
41405: ARRAY
41406: NOT
41407: OR
41408: PUSH
41409: LD_EXP 90
41413: PUSH
41414: LD_VAR 0 2
41418: ARRAY
41419: PPUSH
41420: LD_INT 2
41422: PUSH
41423: LD_INT 30
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 30
41435: PUSH
41436: LD_INT 1
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: LIST
41447: PPUSH
41448: CALL_OW 72
41452: NOT
41453: OR
41454: IFFALSE 41504
// begin if mc_deposits_finder [ i ] then
41456: LD_EXP 128
41460: PUSH
41461: LD_VAR 0 2
41465: ARRAY
41466: IFFALSE 41502
// begin MC_Reset ( i , 125 ) ;
41468: LD_VAR 0 2
41472: PPUSH
41473: LD_INT 125
41475: PPUSH
41476: CALL 24856 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41480: LD_ADDR_EXP 128
41484: PUSH
41485: LD_EXP 128
41489: PPUSH
41490: LD_VAR 0 2
41494: PPUSH
41495: EMPTY
41496: PPUSH
41497: CALL_OW 1
41501: ST_TO_ADDR
// end ; continue ;
41502: GO 41356
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41504: LD_EXP 127
41508: PUSH
41509: LD_VAR 0 2
41513: ARRAY
41514: PUSH
41515: LD_INT 1
41517: ARRAY
41518: PUSH
41519: LD_INT 3
41521: ARRAY
41522: PUSH
41523: LD_INT 1
41525: EQUAL
41526: PUSH
41527: LD_INT 20
41529: PPUSH
41530: LD_EXP 116
41534: PUSH
41535: LD_VAR 0 2
41539: ARRAY
41540: PPUSH
41541: CALL_OW 321
41545: PUSH
41546: LD_INT 2
41548: NONEQUAL
41549: AND
41550: IFFALSE 41600
// begin if mc_deposits_finder [ i ] then
41552: LD_EXP 128
41556: PUSH
41557: LD_VAR 0 2
41561: ARRAY
41562: IFFALSE 41598
// begin MC_Reset ( i , 125 ) ;
41564: LD_VAR 0 2
41568: PPUSH
41569: LD_INT 125
41571: PPUSH
41572: CALL 24856 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41576: LD_ADDR_EXP 128
41580: PUSH
41581: LD_EXP 128
41585: PPUSH
41586: LD_VAR 0 2
41590: PPUSH
41591: EMPTY
41592: PPUSH
41593: CALL_OW 1
41597: ST_TO_ADDR
// end ; continue ;
41598: GO 41356
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41600: LD_EXP 127
41604: PUSH
41605: LD_VAR 0 2
41609: ARRAY
41610: PUSH
41611: LD_INT 1
41613: ARRAY
41614: PUSH
41615: LD_INT 1
41617: ARRAY
41618: PPUSH
41619: LD_EXP 127
41623: PUSH
41624: LD_VAR 0 2
41628: ARRAY
41629: PUSH
41630: LD_INT 1
41632: ARRAY
41633: PUSH
41634: LD_INT 2
41636: ARRAY
41637: PPUSH
41638: LD_EXP 116
41642: PUSH
41643: LD_VAR 0 2
41647: ARRAY
41648: PPUSH
41649: CALL_OW 440
41653: IFFALSE 41696
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41655: LD_ADDR_EXP 127
41659: PUSH
41660: LD_EXP 127
41664: PPUSH
41665: LD_VAR 0 2
41669: PPUSH
41670: LD_EXP 127
41674: PUSH
41675: LD_VAR 0 2
41679: ARRAY
41680: PPUSH
41681: LD_INT 1
41683: PPUSH
41684: CALL_OW 3
41688: PPUSH
41689: CALL_OW 1
41693: ST_TO_ADDR
41694: GO 41943
// begin if not mc_deposits_finder [ i ] then
41696: LD_EXP 128
41700: PUSH
41701: LD_VAR 0 2
41705: ARRAY
41706: NOT
41707: IFFALSE 41759
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41709: LD_ADDR_EXP 128
41713: PUSH
41714: LD_EXP 128
41718: PPUSH
41719: LD_VAR 0 2
41723: PPUSH
41724: LD_VAR 0 3
41728: PUSH
41729: LD_INT 1
41731: ARRAY
41732: PUSH
41733: EMPTY
41734: LIST
41735: PPUSH
41736: CALL_OW 1
41740: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41741: LD_VAR 0 3
41745: PUSH
41746: LD_INT 1
41748: ARRAY
41749: PPUSH
41750: LD_INT 125
41752: PPUSH
41753: CALL_OW 109
// end else
41757: GO 41943
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41759: LD_EXP 128
41763: PUSH
41764: LD_VAR 0 2
41768: ARRAY
41769: PUSH
41770: LD_INT 1
41772: ARRAY
41773: PPUSH
41774: CALL_OW 310
41778: IFFALSE 41801
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41780: LD_EXP 128
41784: PUSH
41785: LD_VAR 0 2
41789: ARRAY
41790: PUSH
41791: LD_INT 1
41793: ARRAY
41794: PPUSH
41795: CALL_OW 122
41799: GO 41943
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41801: LD_EXP 128
41805: PUSH
41806: LD_VAR 0 2
41810: ARRAY
41811: PUSH
41812: LD_INT 1
41814: ARRAY
41815: PPUSH
41816: CALL_OW 314
41820: NOT
41821: PUSH
41822: LD_EXP 128
41826: PUSH
41827: LD_VAR 0 2
41831: ARRAY
41832: PUSH
41833: LD_INT 1
41835: ARRAY
41836: PPUSH
41837: LD_EXP 127
41841: PUSH
41842: LD_VAR 0 2
41846: ARRAY
41847: PUSH
41848: LD_INT 1
41850: ARRAY
41851: PUSH
41852: LD_INT 1
41854: ARRAY
41855: PPUSH
41856: LD_EXP 127
41860: PUSH
41861: LD_VAR 0 2
41865: ARRAY
41866: PUSH
41867: LD_INT 1
41869: ARRAY
41870: PUSH
41871: LD_INT 2
41873: ARRAY
41874: PPUSH
41875: CALL_OW 297
41879: PUSH
41880: LD_INT 6
41882: GREATER
41883: AND
41884: IFFALSE 41943
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41886: LD_EXP 128
41890: PUSH
41891: LD_VAR 0 2
41895: ARRAY
41896: PUSH
41897: LD_INT 1
41899: ARRAY
41900: PPUSH
41901: LD_EXP 127
41905: PUSH
41906: LD_VAR 0 2
41910: ARRAY
41911: PUSH
41912: LD_INT 1
41914: ARRAY
41915: PUSH
41916: LD_INT 1
41918: ARRAY
41919: PPUSH
41920: LD_EXP 127
41924: PUSH
41925: LD_VAR 0 2
41929: ARRAY
41930: PUSH
41931: LD_INT 1
41933: ARRAY
41934: PUSH
41935: LD_INT 2
41937: ARRAY
41938: PPUSH
41939: CALL_OW 111
// end ; end ; end ;
41943: GO 41356
41945: POP
41946: POP
// end ;
41947: LD_VAR 0 1
41951: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41952: LD_INT 0
41954: PPUSH
41955: PPUSH
41956: PPUSH
41957: PPUSH
41958: PPUSH
41959: PPUSH
41960: PPUSH
41961: PPUSH
41962: PPUSH
41963: PPUSH
41964: PPUSH
// if not mc_bases then
41965: LD_EXP 90
41969: NOT
41970: IFFALSE 41974
// exit ;
41972: GO 42914
// for i = 1 to mc_bases do
41974: LD_ADDR_VAR 0 2
41978: PUSH
41979: DOUBLE
41980: LD_INT 1
41982: DEC
41983: ST_TO_ADDR
41984: LD_EXP 90
41988: PUSH
41989: FOR_TO
41990: IFFALSE 42912
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41992: LD_EXP 90
41996: PUSH
41997: LD_VAR 0 2
42001: ARRAY
42002: NOT
42003: PUSH
42004: LD_EXP 113
42008: PUSH
42009: LD_VAR 0 2
42013: ARRAY
42014: OR
42015: IFFALSE 42019
// continue ;
42017: GO 41989
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
42019: LD_ADDR_VAR 0 7
42023: PUSH
42024: LD_EXP 90
42028: PUSH
42029: LD_VAR 0 2
42033: ARRAY
42034: PUSH
42035: LD_INT 1
42037: ARRAY
42038: PPUSH
42039: CALL_OW 248
42043: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
42044: LD_VAR 0 7
42048: PUSH
42049: LD_INT 3
42051: EQUAL
42052: PUSH
42053: LD_EXP 109
42057: PUSH
42058: LD_VAR 0 2
42062: ARRAY
42063: PUSH
42064: LD_EXP 112
42068: PUSH
42069: LD_VAR 0 2
42073: ARRAY
42074: UNION
42075: PPUSH
42076: LD_INT 33
42078: PUSH
42079: LD_INT 2
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: PPUSH
42086: CALL_OW 72
42090: NOT
42091: OR
42092: IFFALSE 42096
// continue ;
42094: GO 41989
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
42096: LD_ADDR_VAR 0 9
42100: PUSH
42101: LD_EXP 90
42105: PUSH
42106: LD_VAR 0 2
42110: ARRAY
42111: PPUSH
42112: LD_INT 30
42114: PUSH
42115: LD_INT 36
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PPUSH
42122: CALL_OW 72
42126: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42127: LD_ADDR_VAR 0 10
42131: PUSH
42132: LD_EXP 109
42136: PUSH
42137: LD_VAR 0 2
42141: ARRAY
42142: PPUSH
42143: LD_INT 34
42145: PUSH
42146: LD_INT 31
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PPUSH
42153: CALL_OW 72
42157: ST_TO_ADDR
// if not cts and not mcts then
42158: LD_VAR 0 9
42162: NOT
42163: PUSH
42164: LD_VAR 0 10
42168: NOT
42169: AND
42170: IFFALSE 42174
// continue ;
42172: GO 41989
// x := cts ;
42174: LD_ADDR_VAR 0 11
42178: PUSH
42179: LD_VAR 0 9
42183: ST_TO_ADDR
// if not x then
42184: LD_VAR 0 11
42188: NOT
42189: IFFALSE 42201
// x := mcts ;
42191: LD_ADDR_VAR 0 11
42195: PUSH
42196: LD_VAR 0 10
42200: ST_TO_ADDR
// if not x then
42201: LD_VAR 0 11
42205: NOT
42206: IFFALSE 42210
// continue ;
42208: GO 41989
// if mc_remote_driver [ i ] then
42210: LD_EXP 130
42214: PUSH
42215: LD_VAR 0 2
42219: ARRAY
42220: IFFALSE 42607
// for j in mc_remote_driver [ i ] do
42222: LD_ADDR_VAR 0 3
42226: PUSH
42227: LD_EXP 130
42231: PUSH
42232: LD_VAR 0 2
42236: ARRAY
42237: PUSH
42238: FOR_IN
42239: IFFALSE 42605
// begin if GetClass ( j ) <> 3 then
42241: LD_VAR 0 3
42245: PPUSH
42246: CALL_OW 257
42250: PUSH
42251: LD_INT 3
42253: NONEQUAL
42254: IFFALSE 42307
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42256: LD_ADDR_EXP 130
42260: PUSH
42261: LD_EXP 130
42265: PPUSH
42266: LD_VAR 0 2
42270: PPUSH
42271: LD_EXP 130
42275: PUSH
42276: LD_VAR 0 2
42280: ARRAY
42281: PUSH
42282: LD_VAR 0 3
42286: DIFF
42287: PPUSH
42288: CALL_OW 1
42292: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42293: LD_VAR 0 3
42297: PPUSH
42298: LD_INT 0
42300: PPUSH
42301: CALL_OW 109
// continue ;
42305: GO 42238
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42307: LD_EXP 109
42311: PUSH
42312: LD_VAR 0 2
42316: ARRAY
42317: PPUSH
42318: LD_INT 34
42320: PUSH
42321: LD_INT 31
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 58
42330: PUSH
42331: EMPTY
42332: LIST
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PPUSH
42338: CALL_OW 72
42342: PUSH
42343: LD_VAR 0 3
42347: PPUSH
42348: CALL 84817 0 1
42352: NOT
42353: AND
42354: IFFALSE 42425
// begin if IsInUnit ( j ) then
42356: LD_VAR 0 3
42360: PPUSH
42361: CALL_OW 310
42365: IFFALSE 42376
// ComExitBuilding ( j ) ;
42367: LD_VAR 0 3
42371: PPUSH
42372: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42376: LD_VAR 0 3
42380: PPUSH
42381: LD_EXP 109
42385: PUSH
42386: LD_VAR 0 2
42390: ARRAY
42391: PPUSH
42392: LD_INT 34
42394: PUSH
42395: LD_INT 31
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: PUSH
42402: LD_INT 58
42404: PUSH
42405: EMPTY
42406: LIST
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: PPUSH
42412: CALL_OW 72
42416: PUSH
42417: LD_INT 1
42419: ARRAY
42420: PPUSH
42421: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42425: LD_VAR 0 3
42429: PPUSH
42430: CALL_OW 310
42434: NOT
42435: PUSH
42436: LD_VAR 0 3
42440: PPUSH
42441: CALL_OW 310
42445: PPUSH
42446: CALL_OW 266
42450: PUSH
42451: LD_INT 36
42453: NONEQUAL
42454: PUSH
42455: LD_VAR 0 3
42459: PPUSH
42460: CALL 84817 0 1
42464: NOT
42465: AND
42466: OR
42467: IFFALSE 42603
// begin if IsInUnit ( j ) then
42469: LD_VAR 0 3
42473: PPUSH
42474: CALL_OW 310
42478: IFFALSE 42489
// ComExitBuilding ( j ) ;
42480: LD_VAR 0 3
42484: PPUSH
42485: CALL_OW 122
// ct := 0 ;
42489: LD_ADDR_VAR 0 8
42493: PUSH
42494: LD_INT 0
42496: ST_TO_ADDR
// for k in x do
42497: LD_ADDR_VAR 0 4
42501: PUSH
42502: LD_VAR 0 11
42506: PUSH
42507: FOR_IN
42508: IFFALSE 42581
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42510: LD_VAR 0 4
42514: PPUSH
42515: CALL_OW 264
42519: PUSH
42520: LD_INT 31
42522: EQUAL
42523: PUSH
42524: LD_VAR 0 4
42528: PPUSH
42529: CALL_OW 311
42533: NOT
42534: AND
42535: PUSH
42536: LD_VAR 0 4
42540: PPUSH
42541: CALL_OW 266
42545: PUSH
42546: LD_INT 36
42548: EQUAL
42549: PUSH
42550: LD_VAR 0 4
42554: PPUSH
42555: CALL_OW 313
42559: PUSH
42560: LD_INT 3
42562: LESS
42563: AND
42564: OR
42565: IFFALSE 42579
// begin ct := k ;
42567: LD_ADDR_VAR 0 8
42571: PUSH
42572: LD_VAR 0 4
42576: ST_TO_ADDR
// break ;
42577: GO 42581
// end ;
42579: GO 42507
42581: POP
42582: POP
// if ct then
42583: LD_VAR 0 8
42587: IFFALSE 42603
// ComEnterUnit ( j , ct ) ;
42589: LD_VAR 0 3
42593: PPUSH
42594: LD_VAR 0 8
42598: PPUSH
42599: CALL_OW 120
// end ; end ;
42603: GO 42238
42605: POP
42606: POP
// places := 0 ;
42607: LD_ADDR_VAR 0 5
42611: PUSH
42612: LD_INT 0
42614: ST_TO_ADDR
// for j = 1 to x do
42615: LD_ADDR_VAR 0 3
42619: PUSH
42620: DOUBLE
42621: LD_INT 1
42623: DEC
42624: ST_TO_ADDR
42625: LD_VAR 0 11
42629: PUSH
42630: FOR_TO
42631: IFFALSE 42707
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42633: LD_VAR 0 11
42637: PUSH
42638: LD_VAR 0 3
42642: ARRAY
42643: PPUSH
42644: CALL_OW 264
42648: PUSH
42649: LD_INT 31
42651: EQUAL
42652: IFFALSE 42670
// places := places + 1 else
42654: LD_ADDR_VAR 0 5
42658: PUSH
42659: LD_VAR 0 5
42663: PUSH
42664: LD_INT 1
42666: PLUS
42667: ST_TO_ADDR
42668: GO 42705
// if GetBType ( x [ j ] ) = b_control_tower then
42670: LD_VAR 0 11
42674: PUSH
42675: LD_VAR 0 3
42679: ARRAY
42680: PPUSH
42681: CALL_OW 266
42685: PUSH
42686: LD_INT 36
42688: EQUAL
42689: IFFALSE 42705
// places := places + 3 ;
42691: LD_ADDR_VAR 0 5
42695: PUSH
42696: LD_VAR 0 5
42700: PUSH
42701: LD_INT 3
42703: PLUS
42704: ST_TO_ADDR
42705: GO 42630
42707: POP
42708: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42709: LD_VAR 0 5
42713: PUSH
42714: LD_INT 0
42716: EQUAL
42717: PUSH
42718: LD_VAR 0 5
42722: PUSH
42723: LD_EXP 130
42727: PUSH
42728: LD_VAR 0 2
42732: ARRAY
42733: LESSEQUAL
42734: OR
42735: IFFALSE 42739
// continue ;
42737: GO 41989
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42739: LD_ADDR_VAR 0 6
42743: PUSH
42744: LD_EXP 90
42748: PUSH
42749: LD_VAR 0 2
42753: ARRAY
42754: PPUSH
42755: LD_INT 25
42757: PUSH
42758: LD_INT 3
42760: PUSH
42761: EMPTY
42762: LIST
42763: LIST
42764: PPUSH
42765: CALL_OW 72
42769: PUSH
42770: LD_EXP 130
42774: PUSH
42775: LD_VAR 0 2
42779: ARRAY
42780: DIFF
42781: PPUSH
42782: LD_INT 3
42784: PPUSH
42785: CALL 85717 0 2
42789: ST_TO_ADDR
// for j in tmp do
42790: LD_ADDR_VAR 0 3
42794: PUSH
42795: LD_VAR 0 6
42799: PUSH
42800: FOR_IN
42801: IFFALSE 42836
// if GetTag ( j ) > 0 then
42803: LD_VAR 0 3
42807: PPUSH
42808: CALL_OW 110
42812: PUSH
42813: LD_INT 0
42815: GREATER
42816: IFFALSE 42834
// tmp := tmp diff j ;
42818: LD_ADDR_VAR 0 6
42822: PUSH
42823: LD_VAR 0 6
42827: PUSH
42828: LD_VAR 0 3
42832: DIFF
42833: ST_TO_ADDR
42834: GO 42800
42836: POP
42837: POP
// if not tmp then
42838: LD_VAR 0 6
42842: NOT
42843: IFFALSE 42847
// continue ;
42845: GO 41989
// if places then
42847: LD_VAR 0 5
42851: IFFALSE 42910
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42853: LD_ADDR_EXP 130
42857: PUSH
42858: LD_EXP 130
42862: PPUSH
42863: LD_VAR 0 2
42867: PPUSH
42868: LD_EXP 130
42872: PUSH
42873: LD_VAR 0 2
42877: ARRAY
42878: PUSH
42879: LD_VAR 0 6
42883: PUSH
42884: LD_INT 1
42886: ARRAY
42887: UNION
42888: PPUSH
42889: CALL_OW 1
42893: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42894: LD_VAR 0 6
42898: PUSH
42899: LD_INT 1
42901: ARRAY
42902: PPUSH
42903: LD_INT 126
42905: PPUSH
42906: CALL_OW 109
// end ; end ;
42910: GO 41989
42912: POP
42913: POP
// end ;
42914: LD_VAR 0 1
42918: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42919: LD_INT 0
42921: PPUSH
42922: PPUSH
42923: PPUSH
42924: PPUSH
42925: PPUSH
42926: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42927: LD_VAR 0 1
42931: NOT
42932: PUSH
42933: LD_VAR 0 2
42937: NOT
42938: OR
42939: PUSH
42940: LD_VAR 0 3
42944: NOT
42945: OR
42946: PUSH
42947: LD_VAR 0 4
42951: PUSH
42952: LD_INT 1
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: LD_INT 3
42960: PUSH
42961: LD_INT 4
42963: PUSH
42964: LD_INT 5
42966: PUSH
42967: LD_INT 8
42969: PUSH
42970: LD_INT 9
42972: PUSH
42973: LD_INT 15
42975: PUSH
42976: LD_INT 16
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: LIST
42983: LIST
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: LIST
42989: IN
42990: NOT
42991: OR
42992: IFFALSE 42996
// exit ;
42994: GO 43896
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42996: LD_ADDR_VAR 0 2
43000: PUSH
43001: LD_VAR 0 2
43005: PPUSH
43006: LD_INT 21
43008: PUSH
43009: LD_INT 3
43011: PUSH
43012: EMPTY
43013: LIST
43014: LIST
43015: PUSH
43016: LD_INT 24
43018: PUSH
43019: LD_INT 250
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: PPUSH
43030: CALL_OW 72
43034: ST_TO_ADDR
// case class of 1 , 15 :
43035: LD_VAR 0 4
43039: PUSH
43040: LD_INT 1
43042: DOUBLE
43043: EQUAL
43044: IFTRUE 43054
43046: LD_INT 15
43048: DOUBLE
43049: EQUAL
43050: IFTRUE 43054
43052: GO 43139
43054: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
43055: LD_ADDR_VAR 0 8
43059: PUSH
43060: LD_VAR 0 2
43064: PPUSH
43065: LD_INT 2
43067: PUSH
43068: LD_INT 30
43070: PUSH
43071: LD_INT 32
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: PUSH
43078: LD_INT 30
43080: PUSH
43081: LD_INT 31
43083: PUSH
43084: EMPTY
43085: LIST
43086: LIST
43087: PUSH
43088: EMPTY
43089: LIST
43090: LIST
43091: LIST
43092: PPUSH
43093: CALL_OW 72
43097: PUSH
43098: LD_VAR 0 2
43102: PPUSH
43103: LD_INT 2
43105: PUSH
43106: LD_INT 30
43108: PUSH
43109: LD_INT 4
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PUSH
43116: LD_INT 30
43118: PUSH
43119: LD_INT 5
43121: PUSH
43122: EMPTY
43123: LIST
43124: LIST
43125: PUSH
43126: EMPTY
43127: LIST
43128: LIST
43129: LIST
43130: PPUSH
43131: CALL_OW 72
43135: ADD
43136: ST_TO_ADDR
43137: GO 43385
43139: LD_INT 2
43141: DOUBLE
43142: EQUAL
43143: IFTRUE 43153
43145: LD_INT 16
43147: DOUBLE
43148: EQUAL
43149: IFTRUE 43153
43151: GO 43199
43153: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43154: LD_ADDR_VAR 0 8
43158: PUSH
43159: LD_VAR 0 2
43163: PPUSH
43164: LD_INT 2
43166: PUSH
43167: LD_INT 30
43169: PUSH
43170: LD_INT 0
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: LD_INT 30
43179: PUSH
43180: LD_INT 1
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: LIST
43191: PPUSH
43192: CALL_OW 72
43196: ST_TO_ADDR
43197: GO 43385
43199: LD_INT 3
43201: DOUBLE
43202: EQUAL
43203: IFTRUE 43207
43205: GO 43253
43207: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43208: LD_ADDR_VAR 0 8
43212: PUSH
43213: LD_VAR 0 2
43217: PPUSH
43218: LD_INT 2
43220: PUSH
43221: LD_INT 30
43223: PUSH
43224: LD_INT 2
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PUSH
43231: LD_INT 30
43233: PUSH
43234: LD_INT 3
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: LIST
43245: PPUSH
43246: CALL_OW 72
43250: ST_TO_ADDR
43251: GO 43385
43253: LD_INT 4
43255: DOUBLE
43256: EQUAL
43257: IFTRUE 43261
43259: GO 43318
43261: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43262: LD_ADDR_VAR 0 8
43266: PUSH
43267: LD_VAR 0 2
43271: PPUSH
43272: LD_INT 2
43274: PUSH
43275: LD_INT 30
43277: PUSH
43278: LD_INT 6
43280: PUSH
43281: EMPTY
43282: LIST
43283: LIST
43284: PUSH
43285: LD_INT 30
43287: PUSH
43288: LD_INT 7
43290: PUSH
43291: EMPTY
43292: LIST
43293: LIST
43294: PUSH
43295: LD_INT 30
43297: PUSH
43298: LD_INT 8
43300: PUSH
43301: EMPTY
43302: LIST
43303: LIST
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: LIST
43309: LIST
43310: PPUSH
43311: CALL_OW 72
43315: ST_TO_ADDR
43316: GO 43385
43318: LD_INT 5
43320: DOUBLE
43321: EQUAL
43322: IFTRUE 43338
43324: LD_INT 8
43326: DOUBLE
43327: EQUAL
43328: IFTRUE 43338
43330: LD_INT 9
43332: DOUBLE
43333: EQUAL
43334: IFTRUE 43338
43336: GO 43384
43338: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43339: LD_ADDR_VAR 0 8
43343: PUSH
43344: LD_VAR 0 2
43348: PPUSH
43349: LD_INT 2
43351: PUSH
43352: LD_INT 30
43354: PUSH
43355: LD_INT 4
43357: PUSH
43358: EMPTY
43359: LIST
43360: LIST
43361: PUSH
43362: LD_INT 30
43364: PUSH
43365: LD_INT 5
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: EMPTY
43373: LIST
43374: LIST
43375: LIST
43376: PPUSH
43377: CALL_OW 72
43381: ST_TO_ADDR
43382: GO 43385
43384: POP
// if not tmp then
43385: LD_VAR 0 8
43389: NOT
43390: IFFALSE 43394
// exit ;
43392: GO 43896
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43394: LD_VAR 0 4
43398: PUSH
43399: LD_INT 1
43401: PUSH
43402: LD_INT 15
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: IN
43409: PUSH
43410: LD_EXP 99
43414: PUSH
43415: LD_VAR 0 1
43419: ARRAY
43420: AND
43421: IFFALSE 43577
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43423: LD_ADDR_VAR 0 9
43427: PUSH
43428: LD_EXP 99
43432: PUSH
43433: LD_VAR 0 1
43437: ARRAY
43438: PUSH
43439: LD_INT 1
43441: ARRAY
43442: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43443: LD_VAR 0 9
43447: PUSH
43448: LD_EXP 100
43452: PUSH
43453: LD_VAR 0 1
43457: ARRAY
43458: IN
43459: NOT
43460: IFFALSE 43575
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43462: LD_ADDR_EXP 100
43466: PUSH
43467: LD_EXP 100
43471: PPUSH
43472: LD_VAR 0 1
43476: PUSH
43477: LD_EXP 100
43481: PUSH
43482: LD_VAR 0 1
43486: ARRAY
43487: PUSH
43488: LD_INT 1
43490: PLUS
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PPUSH
43496: LD_VAR 0 9
43500: PPUSH
43501: CALL 55835 0 3
43505: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43506: LD_ADDR_EXP 99
43510: PUSH
43511: LD_EXP 99
43515: PPUSH
43516: LD_VAR 0 1
43520: PPUSH
43521: LD_EXP 99
43525: PUSH
43526: LD_VAR 0 1
43530: ARRAY
43531: PUSH
43532: LD_VAR 0 9
43536: DIFF
43537: PPUSH
43538: CALL_OW 1
43542: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43543: LD_VAR 0 3
43547: PPUSH
43548: LD_EXP 100
43552: PUSH
43553: LD_VAR 0 1
43557: ARRAY
43558: PUSH
43559: LD_EXP 100
43563: PUSH
43564: LD_VAR 0 1
43568: ARRAY
43569: ARRAY
43570: PPUSH
43571: CALL_OW 120
// end ; exit ;
43575: GO 43896
// end ; if tmp > 1 then
43577: LD_VAR 0 8
43581: PUSH
43582: LD_INT 1
43584: GREATER
43585: IFFALSE 43689
// for i = 2 to tmp do
43587: LD_ADDR_VAR 0 6
43591: PUSH
43592: DOUBLE
43593: LD_INT 2
43595: DEC
43596: ST_TO_ADDR
43597: LD_VAR 0 8
43601: PUSH
43602: FOR_TO
43603: IFFALSE 43687
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43605: LD_VAR 0 8
43609: PUSH
43610: LD_VAR 0 6
43614: ARRAY
43615: PPUSH
43616: CALL_OW 461
43620: PUSH
43621: LD_INT 6
43623: EQUAL
43624: IFFALSE 43685
// begin x := tmp [ i ] ;
43626: LD_ADDR_VAR 0 9
43630: PUSH
43631: LD_VAR 0 8
43635: PUSH
43636: LD_VAR 0 6
43640: ARRAY
43641: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43642: LD_ADDR_VAR 0 8
43646: PUSH
43647: LD_VAR 0 8
43651: PPUSH
43652: LD_VAR 0 6
43656: PPUSH
43657: CALL_OW 3
43661: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43662: LD_ADDR_VAR 0 8
43666: PUSH
43667: LD_VAR 0 8
43671: PPUSH
43672: LD_INT 1
43674: PPUSH
43675: LD_VAR 0 9
43679: PPUSH
43680: CALL_OW 2
43684: ST_TO_ADDR
// end ;
43685: GO 43602
43687: POP
43688: POP
// for i in tmp do
43689: LD_ADDR_VAR 0 6
43693: PUSH
43694: LD_VAR 0 8
43698: PUSH
43699: FOR_IN
43700: IFFALSE 43769
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43702: LD_VAR 0 6
43706: PPUSH
43707: CALL_OW 313
43711: PUSH
43712: LD_INT 6
43714: LESS
43715: PUSH
43716: LD_VAR 0 6
43720: PPUSH
43721: CALL_OW 266
43725: PUSH
43726: LD_INT 31
43728: PUSH
43729: LD_INT 32
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: IN
43736: NOT
43737: AND
43738: PUSH
43739: LD_VAR 0 6
43743: PPUSH
43744: CALL_OW 313
43748: PUSH
43749: LD_INT 0
43751: EQUAL
43752: OR
43753: IFFALSE 43767
// begin j := i ;
43755: LD_ADDR_VAR 0 7
43759: PUSH
43760: LD_VAR 0 6
43764: ST_TO_ADDR
// break ;
43765: GO 43769
// end ; end ;
43767: GO 43699
43769: POP
43770: POP
// if j then
43771: LD_VAR 0 7
43775: IFFALSE 43793
// ComEnterUnit ( unit , j ) else
43777: LD_VAR 0 3
43781: PPUSH
43782: LD_VAR 0 7
43786: PPUSH
43787: CALL_OW 120
43791: GO 43896
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43793: LD_ADDR_VAR 0 10
43797: PUSH
43798: LD_VAR 0 2
43802: PPUSH
43803: LD_INT 2
43805: PUSH
43806: LD_INT 30
43808: PUSH
43809: LD_INT 0
43811: PUSH
43812: EMPTY
43813: LIST
43814: LIST
43815: PUSH
43816: LD_INT 30
43818: PUSH
43819: LD_INT 1
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: EMPTY
43827: LIST
43828: LIST
43829: LIST
43830: PPUSH
43831: CALL_OW 72
43835: ST_TO_ADDR
// if depot then
43836: LD_VAR 0 10
43840: IFFALSE 43896
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43842: LD_ADDR_VAR 0 10
43846: PUSH
43847: LD_VAR 0 10
43851: PPUSH
43852: LD_VAR 0 3
43856: PPUSH
43857: CALL_OW 74
43861: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43862: LD_VAR 0 3
43866: PPUSH
43867: LD_VAR 0 10
43871: PPUSH
43872: CALL_OW 296
43876: PUSH
43877: LD_INT 10
43879: GREATER
43880: IFFALSE 43896
// ComStandNearbyBuilding ( unit , depot ) ;
43882: LD_VAR 0 3
43886: PPUSH
43887: LD_VAR 0 10
43891: PPUSH
43892: CALL 52449 0 2
// end ; end ; end ;
43896: LD_VAR 0 5
43900: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43901: LD_INT 0
43903: PPUSH
43904: PPUSH
43905: PPUSH
43906: PPUSH
// if not mc_bases then
43907: LD_EXP 90
43911: NOT
43912: IFFALSE 43916
// exit ;
43914: GO 44155
// for i = 1 to mc_bases do
43916: LD_ADDR_VAR 0 2
43920: PUSH
43921: DOUBLE
43922: LD_INT 1
43924: DEC
43925: ST_TO_ADDR
43926: LD_EXP 90
43930: PUSH
43931: FOR_TO
43932: IFFALSE 44153
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43934: LD_ADDR_VAR 0 4
43938: PUSH
43939: LD_EXP 90
43943: PUSH
43944: LD_VAR 0 2
43948: ARRAY
43949: PPUSH
43950: LD_INT 21
43952: PUSH
43953: LD_INT 1
43955: PUSH
43956: EMPTY
43957: LIST
43958: LIST
43959: PPUSH
43960: CALL_OW 72
43964: PUSH
43965: LD_EXP 119
43969: PUSH
43970: LD_VAR 0 2
43974: ARRAY
43975: UNION
43976: ST_TO_ADDR
// if not tmp then
43977: LD_VAR 0 4
43981: NOT
43982: IFFALSE 43986
// continue ;
43984: GO 43931
// for j in tmp do
43986: LD_ADDR_VAR 0 3
43990: PUSH
43991: LD_VAR 0 4
43995: PUSH
43996: FOR_IN
43997: IFFALSE 44149
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43999: LD_VAR 0 3
44003: PPUSH
44004: CALL_OW 110
44008: NOT
44009: PUSH
44010: LD_VAR 0 3
44014: PPUSH
44015: CALL_OW 314
44019: NOT
44020: AND
44021: PUSH
44022: LD_VAR 0 3
44026: PPUSH
44027: CALL_OW 311
44031: NOT
44032: AND
44033: PUSH
44034: LD_VAR 0 3
44038: PPUSH
44039: CALL_OW 310
44043: NOT
44044: AND
44045: PUSH
44046: LD_VAR 0 3
44050: PUSH
44051: LD_EXP 93
44055: PUSH
44056: LD_VAR 0 2
44060: ARRAY
44061: PUSH
44062: LD_INT 1
44064: ARRAY
44065: IN
44066: NOT
44067: AND
44068: PUSH
44069: LD_VAR 0 3
44073: PUSH
44074: LD_EXP 93
44078: PUSH
44079: LD_VAR 0 2
44083: ARRAY
44084: PUSH
44085: LD_INT 2
44087: ARRAY
44088: IN
44089: NOT
44090: AND
44091: PUSH
44092: LD_VAR 0 3
44096: PUSH
44097: LD_EXP 102
44101: PUSH
44102: LD_VAR 0 2
44106: ARRAY
44107: IN
44108: NOT
44109: AND
44110: IFFALSE 44147
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
44112: LD_VAR 0 2
44116: PPUSH
44117: LD_EXP 90
44121: PUSH
44122: LD_VAR 0 2
44126: ARRAY
44127: PPUSH
44128: LD_VAR 0 3
44132: PPUSH
44133: LD_VAR 0 3
44137: PPUSH
44138: CALL_OW 257
44142: PPUSH
44143: CALL 42919 0 4
// end ;
44147: GO 43996
44149: POP
44150: POP
// end ;
44151: GO 43931
44153: POP
44154: POP
// end ;
44155: LD_VAR 0 1
44159: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44160: LD_INT 0
44162: PPUSH
44163: PPUSH
44164: PPUSH
44165: PPUSH
44166: PPUSH
44167: PPUSH
// if not mc_bases [ base ] then
44168: LD_EXP 90
44172: PUSH
44173: LD_VAR 0 1
44177: ARRAY
44178: NOT
44179: IFFALSE 44183
// exit ;
44181: GO 44365
// tmp := [ ] ;
44183: LD_ADDR_VAR 0 6
44187: PUSH
44188: EMPTY
44189: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44190: LD_ADDR_VAR 0 7
44194: PUSH
44195: LD_VAR 0 3
44199: PPUSH
44200: LD_INT 0
44202: PPUSH
44203: CALL_OW 517
44207: ST_TO_ADDR
// if not list then
44208: LD_VAR 0 7
44212: NOT
44213: IFFALSE 44217
// exit ;
44215: GO 44365
// for i = 1 to amount do
44217: LD_ADDR_VAR 0 5
44221: PUSH
44222: DOUBLE
44223: LD_INT 1
44225: DEC
44226: ST_TO_ADDR
44227: LD_VAR 0 2
44231: PUSH
44232: FOR_TO
44233: IFFALSE 44313
// begin x := rand ( 1 , list [ 1 ] ) ;
44235: LD_ADDR_VAR 0 8
44239: PUSH
44240: LD_INT 1
44242: PPUSH
44243: LD_VAR 0 7
44247: PUSH
44248: LD_INT 1
44250: ARRAY
44251: PPUSH
44252: CALL_OW 12
44256: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44257: LD_ADDR_VAR 0 6
44261: PUSH
44262: LD_VAR 0 6
44266: PPUSH
44267: LD_VAR 0 5
44271: PPUSH
44272: LD_VAR 0 7
44276: PUSH
44277: LD_INT 1
44279: ARRAY
44280: PUSH
44281: LD_VAR 0 8
44285: ARRAY
44286: PUSH
44287: LD_VAR 0 7
44291: PUSH
44292: LD_INT 2
44294: ARRAY
44295: PUSH
44296: LD_VAR 0 8
44300: ARRAY
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PPUSH
44306: CALL_OW 1
44310: ST_TO_ADDR
// end ;
44311: GO 44232
44313: POP
44314: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44315: LD_ADDR_EXP 103
44319: PUSH
44320: LD_EXP 103
44324: PPUSH
44325: LD_VAR 0 1
44329: PPUSH
44330: LD_VAR 0 6
44334: PPUSH
44335: CALL_OW 1
44339: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44340: LD_ADDR_EXP 105
44344: PUSH
44345: LD_EXP 105
44349: PPUSH
44350: LD_VAR 0 1
44354: PPUSH
44355: LD_VAR 0 3
44359: PPUSH
44360: CALL_OW 1
44364: ST_TO_ADDR
// end ;
44365: LD_VAR 0 4
44369: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44370: LD_INT 0
44372: PPUSH
// if not mc_bases [ base ] then
44373: LD_EXP 90
44377: PUSH
44378: LD_VAR 0 1
44382: ARRAY
44383: NOT
44384: IFFALSE 44388
// exit ;
44386: GO 44413
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44388: LD_ADDR_EXP 95
44392: PUSH
44393: LD_EXP 95
44397: PPUSH
44398: LD_VAR 0 1
44402: PPUSH
44403: LD_VAR 0 2
44407: PPUSH
44408: CALL_OW 1
44412: ST_TO_ADDR
// end ;
44413: LD_VAR 0 3
44417: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44418: LD_INT 0
44420: PPUSH
// if not mc_bases [ base ] then
44421: LD_EXP 90
44425: PUSH
44426: LD_VAR 0 1
44430: ARRAY
44431: NOT
44432: IFFALSE 44436
// exit ;
44434: GO 44473
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44436: LD_ADDR_EXP 95
44440: PUSH
44441: LD_EXP 95
44445: PPUSH
44446: LD_VAR 0 1
44450: PPUSH
44451: LD_EXP 95
44455: PUSH
44456: LD_VAR 0 1
44460: ARRAY
44461: PUSH
44462: LD_VAR 0 2
44466: UNION
44467: PPUSH
44468: CALL_OW 1
44472: ST_TO_ADDR
// end ;
44473: LD_VAR 0 3
44477: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44478: LD_INT 0
44480: PPUSH
// if not mc_bases [ base ] then
44481: LD_EXP 90
44485: PUSH
44486: LD_VAR 0 1
44490: ARRAY
44491: NOT
44492: IFFALSE 44496
// exit ;
44494: GO 44521
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44496: LD_ADDR_EXP 111
44500: PUSH
44501: LD_EXP 111
44505: PPUSH
44506: LD_VAR 0 1
44510: PPUSH
44511: LD_VAR 0 2
44515: PPUSH
44516: CALL_OW 1
44520: ST_TO_ADDR
// end ;
44521: LD_VAR 0 3
44525: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44526: LD_INT 0
44528: PPUSH
// if not mc_bases [ base ] then
44529: LD_EXP 90
44533: PUSH
44534: LD_VAR 0 1
44538: ARRAY
44539: NOT
44540: IFFALSE 44544
// exit ;
44542: GO 44581
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44544: LD_ADDR_EXP 111
44548: PUSH
44549: LD_EXP 111
44553: PPUSH
44554: LD_VAR 0 1
44558: PPUSH
44559: LD_EXP 111
44563: PUSH
44564: LD_VAR 0 1
44568: ARRAY
44569: PUSH
44570: LD_VAR 0 2
44574: ADD
44575: PPUSH
44576: CALL_OW 1
44580: ST_TO_ADDR
// end ;
44581: LD_VAR 0 3
44585: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44586: LD_INT 0
44588: PPUSH
// if not mc_bases [ base ] then
44589: LD_EXP 90
44593: PUSH
44594: LD_VAR 0 1
44598: ARRAY
44599: NOT
44600: IFFALSE 44604
// exit ;
44602: GO 44658
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44604: LD_ADDR_EXP 112
44608: PUSH
44609: LD_EXP 112
44613: PPUSH
44614: LD_VAR 0 1
44618: PPUSH
44619: LD_VAR 0 2
44623: PPUSH
44624: CALL_OW 1
44628: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44629: LD_ADDR_EXP 101
44633: PUSH
44634: LD_EXP 101
44638: PPUSH
44639: LD_VAR 0 1
44643: PPUSH
44644: LD_VAR 0 2
44648: PUSH
44649: LD_INT 0
44651: PLUS
44652: PPUSH
44653: CALL_OW 1
44657: ST_TO_ADDR
// end ;
44658: LD_VAR 0 3
44662: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44663: LD_INT 0
44665: PPUSH
// if not mc_bases [ base ] then
44666: LD_EXP 90
44670: PUSH
44671: LD_VAR 0 1
44675: ARRAY
44676: NOT
44677: IFFALSE 44681
// exit ;
44679: GO 44706
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44681: LD_ADDR_EXP 101
44685: PUSH
44686: LD_EXP 101
44690: PPUSH
44691: LD_VAR 0 1
44695: PPUSH
44696: LD_VAR 0 2
44700: PPUSH
44701: CALL_OW 1
44705: ST_TO_ADDR
// end ;
44706: LD_VAR 0 3
44710: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44711: LD_INT 0
44713: PPUSH
44714: PPUSH
44715: PPUSH
44716: PPUSH
// if not mc_bases [ base ] then
44717: LD_EXP 90
44721: PUSH
44722: LD_VAR 0 1
44726: ARRAY
44727: NOT
44728: IFFALSE 44732
// exit ;
44730: GO 44797
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44732: LD_ADDR_EXP 110
44736: PUSH
44737: LD_EXP 110
44741: PPUSH
44742: LD_VAR 0 1
44746: PUSH
44747: LD_EXP 110
44751: PUSH
44752: LD_VAR 0 1
44756: ARRAY
44757: PUSH
44758: LD_INT 1
44760: PLUS
44761: PUSH
44762: EMPTY
44763: LIST
44764: LIST
44765: PPUSH
44766: LD_VAR 0 1
44770: PUSH
44771: LD_VAR 0 2
44775: PUSH
44776: LD_VAR 0 3
44780: PUSH
44781: LD_VAR 0 4
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: LIST
44790: LIST
44791: PPUSH
44792: CALL 55835 0 3
44796: ST_TO_ADDR
// end ;
44797: LD_VAR 0 5
44801: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44802: LD_INT 0
44804: PPUSH
// if not mc_bases [ base ] then
44805: LD_EXP 90
44809: PUSH
44810: LD_VAR 0 1
44814: ARRAY
44815: NOT
44816: IFFALSE 44820
// exit ;
44818: GO 44845
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44820: LD_ADDR_EXP 127
44824: PUSH
44825: LD_EXP 127
44829: PPUSH
44830: LD_VAR 0 1
44834: PPUSH
44835: LD_VAR 0 2
44839: PPUSH
44840: CALL_OW 1
44844: ST_TO_ADDR
// end ;
44845: LD_VAR 0 3
44849: RET
// export function MC_GetMinesField ( base ) ; begin
44850: LD_INT 0
44852: PPUSH
// result := mc_mines [ base ] ;
44853: LD_ADDR_VAR 0 2
44857: PUSH
44858: LD_EXP 103
44862: PUSH
44863: LD_VAR 0 1
44867: ARRAY
44868: ST_TO_ADDR
// end ;
44869: LD_VAR 0 2
44873: RET
// export function MC_GetProduceList ( base ) ; begin
44874: LD_INT 0
44876: PPUSH
// result := mc_produce [ base ] ;
44877: LD_ADDR_VAR 0 2
44881: PUSH
44882: LD_EXP 111
44886: PUSH
44887: LD_VAR 0 1
44891: ARRAY
44892: ST_TO_ADDR
// end ;
44893: LD_VAR 0 2
44897: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44898: LD_INT 0
44900: PPUSH
44901: PPUSH
// if not mc_bases then
44902: LD_EXP 90
44906: NOT
44907: IFFALSE 44911
// exit ;
44909: GO 44976
// if mc_bases [ base ] then
44911: LD_EXP 90
44915: PUSH
44916: LD_VAR 0 1
44920: ARRAY
44921: IFFALSE 44976
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44923: LD_ADDR_VAR 0 3
44927: PUSH
44928: LD_EXP 90
44932: PUSH
44933: LD_VAR 0 1
44937: ARRAY
44938: PPUSH
44939: LD_INT 30
44941: PUSH
44942: LD_VAR 0 2
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: PPUSH
44951: CALL_OW 72
44955: ST_TO_ADDR
// if result then
44956: LD_VAR 0 3
44960: IFFALSE 44976
// result := result [ 1 ] ;
44962: LD_ADDR_VAR 0 3
44966: PUSH
44967: LD_VAR 0 3
44971: PUSH
44972: LD_INT 1
44974: ARRAY
44975: ST_TO_ADDR
// end ; end ;
44976: LD_VAR 0 3
44980: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44981: LD_INT 0
44983: PPUSH
44984: PPUSH
// if not mc_bases then
44985: LD_EXP 90
44989: NOT
44990: IFFALSE 44994
// exit ;
44992: GO 45039
// if mc_bases [ base ] then
44994: LD_EXP 90
44998: PUSH
44999: LD_VAR 0 1
45003: ARRAY
45004: IFFALSE 45039
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45006: LD_ADDR_VAR 0 3
45010: PUSH
45011: LD_EXP 90
45015: PUSH
45016: LD_VAR 0 1
45020: ARRAY
45021: PPUSH
45022: LD_INT 30
45024: PUSH
45025: LD_VAR 0 2
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PPUSH
45034: CALL_OW 72
45038: ST_TO_ADDR
// end ;
45039: LD_VAR 0 3
45043: RET
// export function MC_SetTame ( base , area ) ; begin
45044: LD_INT 0
45046: PPUSH
// if not mc_bases or not base then
45047: LD_EXP 90
45051: NOT
45052: PUSH
45053: LD_VAR 0 1
45057: NOT
45058: OR
45059: IFFALSE 45063
// exit ;
45061: GO 45088
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
45063: LD_ADDR_EXP 118
45067: PUSH
45068: LD_EXP 118
45072: PPUSH
45073: LD_VAR 0 1
45077: PPUSH
45078: LD_VAR 0 2
45082: PPUSH
45083: CALL_OW 1
45087: ST_TO_ADDR
// end ;
45088: LD_VAR 0 3
45092: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
45093: LD_INT 0
45095: PPUSH
45096: PPUSH
// if not mc_bases or not base then
45097: LD_EXP 90
45101: NOT
45102: PUSH
45103: LD_VAR 0 1
45107: NOT
45108: OR
45109: IFFALSE 45113
// exit ;
45111: GO 45215
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45113: LD_ADDR_VAR 0 4
45117: PUSH
45118: LD_EXP 90
45122: PUSH
45123: LD_VAR 0 1
45127: ARRAY
45128: PPUSH
45129: LD_INT 30
45131: PUSH
45132: LD_VAR 0 2
45136: PUSH
45137: EMPTY
45138: LIST
45139: LIST
45140: PPUSH
45141: CALL_OW 72
45145: ST_TO_ADDR
// if not tmp then
45146: LD_VAR 0 4
45150: NOT
45151: IFFALSE 45155
// exit ;
45153: GO 45215
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45155: LD_ADDR_EXP 122
45159: PUSH
45160: LD_EXP 122
45164: PPUSH
45165: LD_VAR 0 1
45169: PPUSH
45170: LD_EXP 122
45174: PUSH
45175: LD_VAR 0 1
45179: ARRAY
45180: PPUSH
45181: LD_EXP 122
45185: PUSH
45186: LD_VAR 0 1
45190: ARRAY
45191: PUSH
45192: LD_INT 1
45194: PLUS
45195: PPUSH
45196: LD_VAR 0 4
45200: PUSH
45201: LD_INT 1
45203: ARRAY
45204: PPUSH
45205: CALL_OW 2
45209: PPUSH
45210: CALL_OW 1
45214: ST_TO_ADDR
// end ;
45215: LD_VAR 0 3
45219: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45220: LD_INT 0
45222: PPUSH
45223: PPUSH
// if not mc_bases or not base or not kinds then
45224: LD_EXP 90
45228: NOT
45229: PUSH
45230: LD_VAR 0 1
45234: NOT
45235: OR
45236: PUSH
45237: LD_VAR 0 2
45241: NOT
45242: OR
45243: IFFALSE 45247
// exit ;
45245: GO 45308
// for i in kinds do
45247: LD_ADDR_VAR 0 4
45251: PUSH
45252: LD_VAR 0 2
45256: PUSH
45257: FOR_IN
45258: IFFALSE 45306
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45260: LD_ADDR_EXP 124
45264: PUSH
45265: LD_EXP 124
45269: PPUSH
45270: LD_VAR 0 1
45274: PUSH
45275: LD_EXP 124
45279: PUSH
45280: LD_VAR 0 1
45284: ARRAY
45285: PUSH
45286: LD_INT 1
45288: PLUS
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: PPUSH
45294: LD_VAR 0 4
45298: PPUSH
45299: CALL 55835 0 3
45303: ST_TO_ADDR
45304: GO 45257
45306: POP
45307: POP
// end ;
45308: LD_VAR 0 3
45312: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45313: LD_INT 0
45315: PPUSH
// if not mc_bases or not base or not areas then
45316: LD_EXP 90
45320: NOT
45321: PUSH
45322: LD_VAR 0 1
45326: NOT
45327: OR
45328: PUSH
45329: LD_VAR 0 2
45333: NOT
45334: OR
45335: IFFALSE 45339
// exit ;
45337: GO 45364
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45339: LD_ADDR_EXP 108
45343: PUSH
45344: LD_EXP 108
45348: PPUSH
45349: LD_VAR 0 1
45353: PPUSH
45354: LD_VAR 0 2
45358: PPUSH
45359: CALL_OW 1
45363: ST_TO_ADDR
// end ;
45364: LD_VAR 0 3
45368: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45369: LD_INT 0
45371: PPUSH
// if not mc_bases or not base or not teleports_exit then
45372: LD_EXP 90
45376: NOT
45377: PUSH
45378: LD_VAR 0 1
45382: NOT
45383: OR
45384: PUSH
45385: LD_VAR 0 2
45389: NOT
45390: OR
45391: IFFALSE 45395
// exit ;
45393: GO 45420
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45395: LD_ADDR_EXP 125
45399: PUSH
45400: LD_EXP 125
45404: PPUSH
45405: LD_VAR 0 1
45409: PPUSH
45410: LD_VAR 0 2
45414: PPUSH
45415: CALL_OW 1
45419: ST_TO_ADDR
// end ;
45420: LD_VAR 0 3
45424: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45425: LD_INT 0
45427: PPUSH
45428: PPUSH
45429: PPUSH
// if not mc_bases or not base or not ext_list then
45430: LD_EXP 90
45434: NOT
45435: PUSH
45436: LD_VAR 0 1
45440: NOT
45441: OR
45442: PUSH
45443: LD_VAR 0 5
45447: NOT
45448: OR
45449: IFFALSE 45453
// exit ;
45451: GO 45626
// tmp := GetFacExtXYD ( x , y , d ) ;
45453: LD_ADDR_VAR 0 8
45457: PUSH
45458: LD_VAR 0 2
45462: PPUSH
45463: LD_VAR 0 3
45467: PPUSH
45468: LD_VAR 0 4
45472: PPUSH
45473: CALL 84847 0 3
45477: ST_TO_ADDR
// if not tmp then
45478: LD_VAR 0 8
45482: NOT
45483: IFFALSE 45487
// exit ;
45485: GO 45626
// for i in tmp do
45487: LD_ADDR_VAR 0 7
45491: PUSH
45492: LD_VAR 0 8
45496: PUSH
45497: FOR_IN
45498: IFFALSE 45624
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45500: LD_ADDR_EXP 95
45504: PUSH
45505: LD_EXP 95
45509: PPUSH
45510: LD_VAR 0 1
45514: PPUSH
45515: LD_EXP 95
45519: PUSH
45520: LD_VAR 0 1
45524: ARRAY
45525: PPUSH
45526: LD_EXP 95
45530: PUSH
45531: LD_VAR 0 1
45535: ARRAY
45536: PUSH
45537: LD_INT 1
45539: PLUS
45540: PPUSH
45541: LD_VAR 0 5
45545: PUSH
45546: LD_INT 1
45548: ARRAY
45549: PUSH
45550: LD_VAR 0 7
45554: PUSH
45555: LD_INT 1
45557: ARRAY
45558: PUSH
45559: LD_VAR 0 7
45563: PUSH
45564: LD_INT 2
45566: ARRAY
45567: PUSH
45568: LD_VAR 0 7
45572: PUSH
45573: LD_INT 3
45575: ARRAY
45576: PUSH
45577: EMPTY
45578: LIST
45579: LIST
45580: LIST
45581: LIST
45582: PPUSH
45583: CALL_OW 2
45587: PPUSH
45588: CALL_OW 1
45592: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45593: LD_ADDR_VAR 0 5
45597: PUSH
45598: LD_VAR 0 5
45602: PPUSH
45603: LD_INT 1
45605: PPUSH
45606: CALL_OW 3
45610: ST_TO_ADDR
// if not ext_list then
45611: LD_VAR 0 5
45615: NOT
45616: IFFALSE 45622
// exit ;
45618: POP
45619: POP
45620: GO 45626
// end ;
45622: GO 45497
45624: POP
45625: POP
// end ;
45626: LD_VAR 0 6
45630: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45631: LD_INT 0
45633: PPUSH
// if not mc_bases or not base or not weapon_list then
45634: LD_EXP 90
45638: NOT
45639: PUSH
45640: LD_VAR 0 1
45644: NOT
45645: OR
45646: PUSH
45647: LD_VAR 0 2
45651: NOT
45652: OR
45653: IFFALSE 45657
// exit ;
45655: GO 45682
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45657: LD_ADDR_EXP 129
45661: PUSH
45662: LD_EXP 129
45666: PPUSH
45667: LD_VAR 0 1
45671: PPUSH
45672: LD_VAR 0 2
45676: PPUSH
45677: CALL_OW 1
45681: ST_TO_ADDR
// end ;
45682: LD_VAR 0 3
45686: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45687: LD_INT 0
45689: PPUSH
// if not mc_bases or not base or not tech_list then
45690: LD_EXP 90
45694: NOT
45695: PUSH
45696: LD_VAR 0 1
45700: NOT
45701: OR
45702: PUSH
45703: LD_VAR 0 2
45707: NOT
45708: OR
45709: IFFALSE 45713
// exit ;
45711: GO 45738
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45713: LD_ADDR_EXP 117
45717: PUSH
45718: LD_EXP 117
45722: PPUSH
45723: LD_VAR 0 1
45727: PPUSH
45728: LD_VAR 0 2
45732: PPUSH
45733: CALL_OW 1
45737: ST_TO_ADDR
// end ;
45738: LD_VAR 0 3
45742: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45743: LD_INT 0
45745: PPUSH
// if not mc_bases or not parking_area or not base then
45746: LD_EXP 90
45750: NOT
45751: PUSH
45752: LD_VAR 0 2
45756: NOT
45757: OR
45758: PUSH
45759: LD_VAR 0 1
45763: NOT
45764: OR
45765: IFFALSE 45769
// exit ;
45767: GO 45794
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45769: LD_ADDR_EXP 114
45773: PUSH
45774: LD_EXP 114
45778: PPUSH
45779: LD_VAR 0 1
45783: PPUSH
45784: LD_VAR 0 2
45788: PPUSH
45789: CALL_OW 1
45793: ST_TO_ADDR
// end ;
45794: LD_VAR 0 3
45798: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45799: LD_INT 0
45801: PPUSH
// if not mc_bases or not base or not scan_area then
45802: LD_EXP 90
45806: NOT
45807: PUSH
45808: LD_VAR 0 1
45812: NOT
45813: OR
45814: PUSH
45815: LD_VAR 0 2
45819: NOT
45820: OR
45821: IFFALSE 45825
// exit ;
45823: GO 45850
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45825: LD_ADDR_EXP 115
45829: PUSH
45830: LD_EXP 115
45834: PPUSH
45835: LD_VAR 0 1
45839: PPUSH
45840: LD_VAR 0 2
45844: PPUSH
45845: CALL_OW 1
45849: ST_TO_ADDR
// end ;
45850: LD_VAR 0 3
45854: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45855: LD_INT 0
45857: PPUSH
45858: PPUSH
// if not mc_bases or not base then
45859: LD_EXP 90
45863: NOT
45864: PUSH
45865: LD_VAR 0 1
45869: NOT
45870: OR
45871: IFFALSE 45875
// exit ;
45873: GO 45939
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45875: LD_ADDR_VAR 0 3
45879: PUSH
45880: LD_INT 1
45882: PUSH
45883: LD_INT 2
45885: PUSH
45886: LD_INT 3
45888: PUSH
45889: LD_INT 4
45891: PUSH
45892: LD_INT 11
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: LIST
45901: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45902: LD_ADDR_EXP 117
45906: PUSH
45907: LD_EXP 117
45911: PPUSH
45912: LD_VAR 0 1
45916: PPUSH
45917: LD_EXP 117
45921: PUSH
45922: LD_VAR 0 1
45926: ARRAY
45927: PUSH
45928: LD_VAR 0 3
45932: DIFF
45933: PPUSH
45934: CALL_OW 1
45938: ST_TO_ADDR
// end ;
45939: LD_VAR 0 2
45943: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45944: LD_INT 0
45946: PPUSH
// result := mc_vehicles [ base ] ;
45947: LD_ADDR_VAR 0 3
45951: PUSH
45952: LD_EXP 109
45956: PUSH
45957: LD_VAR 0 1
45961: ARRAY
45962: ST_TO_ADDR
// if onlyCombat then
45963: LD_VAR 0 2
45967: IFFALSE 46145
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45969: LD_ADDR_VAR 0 3
45973: PUSH
45974: LD_VAR 0 3
45978: PUSH
45979: LD_VAR 0 3
45983: PPUSH
45984: LD_INT 2
45986: PUSH
45987: LD_INT 34
45989: PUSH
45990: LD_INT 12
45992: PUSH
45993: EMPTY
45994: LIST
45995: LIST
45996: PUSH
45997: LD_INT 34
45999: PUSH
46000: LD_INT 51
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: LD_INT 34
46009: PUSH
46010: LD_EXP 73
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 34
46021: PUSH
46022: LD_INT 32
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 34
46031: PUSH
46032: LD_INT 13
46034: PUSH
46035: EMPTY
46036: LIST
46037: LIST
46038: PUSH
46039: LD_INT 34
46041: PUSH
46042: LD_INT 52
46044: PUSH
46045: EMPTY
46046: LIST
46047: LIST
46048: PUSH
46049: LD_INT 34
46051: PUSH
46052: LD_EXP 78
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PUSH
46061: LD_INT 34
46063: PUSH
46064: LD_INT 14
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: PUSH
46071: LD_INT 34
46073: PUSH
46074: LD_INT 53
46076: PUSH
46077: EMPTY
46078: LIST
46079: LIST
46080: PUSH
46081: LD_INT 34
46083: PUSH
46084: LD_EXP 72
46088: PUSH
46089: EMPTY
46090: LIST
46091: LIST
46092: PUSH
46093: LD_INT 34
46095: PUSH
46096: LD_INT 31
46098: PUSH
46099: EMPTY
46100: LIST
46101: LIST
46102: PUSH
46103: LD_INT 34
46105: PUSH
46106: LD_INT 48
46108: PUSH
46109: EMPTY
46110: LIST
46111: LIST
46112: PUSH
46113: LD_INT 34
46115: PUSH
46116: LD_INT 8
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: EMPTY
46124: LIST
46125: LIST
46126: LIST
46127: LIST
46128: LIST
46129: LIST
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: LIST
46136: LIST
46137: LIST
46138: PPUSH
46139: CALL_OW 72
46143: DIFF
46144: ST_TO_ADDR
// end ; end_of_file
46145: LD_VAR 0 3
46149: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46150: LD_INT 0
46152: PPUSH
46153: PPUSH
46154: PPUSH
// if not mc_bases or not skirmish then
46155: LD_EXP 90
46159: NOT
46160: PUSH
46161: LD_EXP 88
46165: NOT
46166: OR
46167: IFFALSE 46171
// exit ;
46169: GO 46336
// for i = 1 to mc_bases do
46171: LD_ADDR_VAR 0 4
46175: PUSH
46176: DOUBLE
46177: LD_INT 1
46179: DEC
46180: ST_TO_ADDR
46181: LD_EXP 90
46185: PUSH
46186: FOR_TO
46187: IFFALSE 46334
// begin if sci in mc_bases [ i ] then
46189: LD_VAR 0 2
46193: PUSH
46194: LD_EXP 90
46198: PUSH
46199: LD_VAR 0 4
46203: ARRAY
46204: IN
46205: IFFALSE 46332
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46207: LD_ADDR_EXP 119
46211: PUSH
46212: LD_EXP 119
46216: PPUSH
46217: LD_VAR 0 4
46221: PUSH
46222: LD_EXP 119
46226: PUSH
46227: LD_VAR 0 4
46231: ARRAY
46232: PUSH
46233: LD_INT 1
46235: PLUS
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PPUSH
46241: LD_VAR 0 1
46245: PPUSH
46246: CALL 55835 0 3
46250: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46251: LD_ADDR_VAR 0 5
46255: PUSH
46256: LD_EXP 90
46260: PUSH
46261: LD_VAR 0 4
46265: ARRAY
46266: PPUSH
46267: LD_INT 2
46269: PUSH
46270: LD_INT 30
46272: PUSH
46273: LD_INT 0
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: PUSH
46280: LD_INT 30
46282: PUSH
46283: LD_INT 1
46285: PUSH
46286: EMPTY
46287: LIST
46288: LIST
46289: PUSH
46290: EMPTY
46291: LIST
46292: LIST
46293: LIST
46294: PPUSH
46295: CALL_OW 72
46299: PPUSH
46300: LD_VAR 0 1
46304: PPUSH
46305: CALL_OW 74
46309: ST_TO_ADDR
// if tmp then
46310: LD_VAR 0 5
46314: IFFALSE 46330
// ComStandNearbyBuilding ( ape , tmp ) ;
46316: LD_VAR 0 1
46320: PPUSH
46321: LD_VAR 0 5
46325: PPUSH
46326: CALL 52449 0 2
// break ;
46330: GO 46334
// end ; end ;
46332: GO 46186
46334: POP
46335: POP
// end ;
46336: LD_VAR 0 3
46340: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46341: LD_INT 0
46343: PPUSH
46344: PPUSH
46345: PPUSH
// if not mc_bases or not skirmish then
46346: LD_EXP 90
46350: NOT
46351: PUSH
46352: LD_EXP 88
46356: NOT
46357: OR
46358: IFFALSE 46362
// exit ;
46360: GO 46451
// for i = 1 to mc_bases do
46362: LD_ADDR_VAR 0 4
46366: PUSH
46367: DOUBLE
46368: LD_INT 1
46370: DEC
46371: ST_TO_ADDR
46372: LD_EXP 90
46376: PUSH
46377: FOR_TO
46378: IFFALSE 46449
// begin if building in mc_busy_turret_list [ i ] then
46380: LD_VAR 0 1
46384: PUSH
46385: LD_EXP 100
46389: PUSH
46390: LD_VAR 0 4
46394: ARRAY
46395: IN
46396: IFFALSE 46447
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46398: LD_ADDR_VAR 0 5
46402: PUSH
46403: LD_EXP 100
46407: PUSH
46408: LD_VAR 0 4
46412: ARRAY
46413: PUSH
46414: LD_VAR 0 1
46418: DIFF
46419: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46420: LD_ADDR_EXP 100
46424: PUSH
46425: LD_EXP 100
46429: PPUSH
46430: LD_VAR 0 4
46434: PPUSH
46435: LD_VAR 0 5
46439: PPUSH
46440: CALL_OW 1
46444: ST_TO_ADDR
// break ;
46445: GO 46449
// end ; end ;
46447: GO 46377
46449: POP
46450: POP
// end ;
46451: LD_VAR 0 3
46455: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46456: LD_INT 0
46458: PPUSH
46459: PPUSH
46460: PPUSH
// if not mc_bases or not skirmish then
46461: LD_EXP 90
46465: NOT
46466: PUSH
46467: LD_EXP 88
46471: NOT
46472: OR
46473: IFFALSE 46477
// exit ;
46475: GO 46676
// for i = 1 to mc_bases do
46477: LD_ADDR_VAR 0 5
46481: PUSH
46482: DOUBLE
46483: LD_INT 1
46485: DEC
46486: ST_TO_ADDR
46487: LD_EXP 90
46491: PUSH
46492: FOR_TO
46493: IFFALSE 46674
// if building in mc_bases [ i ] then
46495: LD_VAR 0 1
46499: PUSH
46500: LD_EXP 90
46504: PUSH
46505: LD_VAR 0 5
46509: ARRAY
46510: IN
46511: IFFALSE 46672
// begin tmp := mc_bases [ i ] diff building ;
46513: LD_ADDR_VAR 0 6
46517: PUSH
46518: LD_EXP 90
46522: PUSH
46523: LD_VAR 0 5
46527: ARRAY
46528: PUSH
46529: LD_VAR 0 1
46533: DIFF
46534: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46535: LD_ADDR_EXP 90
46539: PUSH
46540: LD_EXP 90
46544: PPUSH
46545: LD_VAR 0 5
46549: PPUSH
46550: LD_VAR 0 6
46554: PPUSH
46555: CALL_OW 1
46559: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46560: LD_VAR 0 1
46564: PUSH
46565: LD_EXP 98
46569: PUSH
46570: LD_VAR 0 5
46574: ARRAY
46575: IN
46576: IFFALSE 46615
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46578: LD_ADDR_EXP 98
46582: PUSH
46583: LD_EXP 98
46587: PPUSH
46588: LD_VAR 0 5
46592: PPUSH
46593: LD_EXP 98
46597: PUSH
46598: LD_VAR 0 5
46602: ARRAY
46603: PUSH
46604: LD_VAR 0 1
46608: DIFF
46609: PPUSH
46610: CALL_OW 1
46614: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46615: LD_VAR 0 1
46619: PUSH
46620: LD_EXP 99
46624: PUSH
46625: LD_VAR 0 5
46629: ARRAY
46630: IN
46631: IFFALSE 46670
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46633: LD_ADDR_EXP 99
46637: PUSH
46638: LD_EXP 99
46642: PPUSH
46643: LD_VAR 0 5
46647: PPUSH
46648: LD_EXP 99
46652: PUSH
46653: LD_VAR 0 5
46657: ARRAY
46658: PUSH
46659: LD_VAR 0 1
46663: DIFF
46664: PPUSH
46665: CALL_OW 1
46669: ST_TO_ADDR
// break ;
46670: GO 46674
// end ;
46672: GO 46492
46674: POP
46675: POP
// end ;
46676: LD_VAR 0 4
46680: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46681: LD_INT 0
46683: PPUSH
46684: PPUSH
46685: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46686: LD_EXP 90
46690: NOT
46691: PUSH
46692: LD_EXP 88
46696: NOT
46697: OR
46698: PUSH
46699: LD_VAR 0 3
46703: PUSH
46704: LD_EXP 116
46708: IN
46709: NOT
46710: OR
46711: IFFALSE 46715
// exit ;
46713: GO 46838
// for i = 1 to mc_vehicles do
46715: LD_ADDR_VAR 0 6
46719: PUSH
46720: DOUBLE
46721: LD_INT 1
46723: DEC
46724: ST_TO_ADDR
46725: LD_EXP 109
46729: PUSH
46730: FOR_TO
46731: IFFALSE 46836
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46733: LD_VAR 0 2
46737: PUSH
46738: LD_EXP 109
46742: PUSH
46743: LD_VAR 0 6
46747: ARRAY
46748: IN
46749: PUSH
46750: LD_VAR 0 1
46754: PUSH
46755: LD_EXP 109
46759: PUSH
46760: LD_VAR 0 6
46764: ARRAY
46765: IN
46766: OR
46767: IFFALSE 46834
// begin tmp := mc_vehicles [ i ] diff old ;
46769: LD_ADDR_VAR 0 7
46773: PUSH
46774: LD_EXP 109
46778: PUSH
46779: LD_VAR 0 6
46783: ARRAY
46784: PUSH
46785: LD_VAR 0 2
46789: DIFF
46790: ST_TO_ADDR
// tmp := tmp diff new ;
46791: LD_ADDR_VAR 0 7
46795: PUSH
46796: LD_VAR 0 7
46800: PUSH
46801: LD_VAR 0 1
46805: DIFF
46806: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46807: LD_ADDR_EXP 109
46811: PUSH
46812: LD_EXP 109
46816: PPUSH
46817: LD_VAR 0 6
46821: PPUSH
46822: LD_VAR 0 7
46826: PPUSH
46827: CALL_OW 1
46831: ST_TO_ADDR
// break ;
46832: GO 46836
// end ;
46834: GO 46730
46836: POP
46837: POP
// end ;
46838: LD_VAR 0 5
46842: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46843: LD_INT 0
46845: PPUSH
46846: PPUSH
46847: PPUSH
46848: PPUSH
// if not mc_bases or not skirmish then
46849: LD_EXP 90
46853: NOT
46854: PUSH
46855: LD_EXP 88
46859: NOT
46860: OR
46861: IFFALSE 46865
// exit ;
46863: GO 47248
// side := GetSide ( vehicle ) ;
46865: LD_ADDR_VAR 0 5
46869: PUSH
46870: LD_VAR 0 1
46874: PPUSH
46875: CALL_OW 255
46879: ST_TO_ADDR
// for i = 1 to mc_bases do
46880: LD_ADDR_VAR 0 4
46884: PUSH
46885: DOUBLE
46886: LD_INT 1
46888: DEC
46889: ST_TO_ADDR
46890: LD_EXP 90
46894: PUSH
46895: FOR_TO
46896: IFFALSE 47246
// begin if factory in mc_bases [ i ] then
46898: LD_VAR 0 2
46902: PUSH
46903: LD_EXP 90
46907: PUSH
46908: LD_VAR 0 4
46912: ARRAY
46913: IN
46914: IFFALSE 47244
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
46916: LD_EXP 112
46920: PUSH
46921: LD_VAR 0 4
46925: ARRAY
46926: PUSH
46927: LD_EXP 101
46931: PUSH
46932: LD_VAR 0 4
46936: ARRAY
46937: LESS
46938: PUSH
46939: LD_VAR 0 1
46943: PPUSH
46944: CALL_OW 264
46948: PUSH
46949: LD_INT 31
46951: PUSH
46952: LD_INT 32
46954: PUSH
46955: LD_INT 51
46957: PUSH
46958: LD_EXP 73
46962: PUSH
46963: LD_INT 12
46965: PUSH
46966: LD_INT 30
46968: PUSH
46969: LD_EXP 72
46973: PUSH
46974: LD_INT 11
46976: PUSH
46977: LD_INT 53
46979: PUSH
46980: LD_INT 14
46982: PUSH
46983: LD_EXP 76
46987: PUSH
46988: LD_INT 29
46990: PUSH
46991: LD_EXP 74
46995: PUSH
46996: LD_INT 13
46998: PUSH
46999: LD_INT 52
47001: PUSH
47002: LD_EXP 78
47006: PUSH
47007: LD_INT 48
47009: PUSH
47010: LD_INT 8
47012: PUSH
47013: EMPTY
47014: LIST
47015: LIST
47016: LIST
47017: LIST
47018: LIST
47019: LIST
47020: LIST
47021: LIST
47022: LIST
47023: LIST
47024: LIST
47025: LIST
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: IN
47033: NOT
47034: AND
47035: IFFALSE 47083
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
47037: LD_ADDR_EXP 112
47041: PUSH
47042: LD_EXP 112
47046: PPUSH
47047: LD_VAR 0 4
47051: PUSH
47052: LD_EXP 112
47056: PUSH
47057: LD_VAR 0 4
47061: ARRAY
47062: PUSH
47063: LD_INT 1
47065: PLUS
47066: PUSH
47067: EMPTY
47068: LIST
47069: LIST
47070: PPUSH
47071: LD_VAR 0 1
47075: PPUSH
47076: CALL 55835 0 3
47080: ST_TO_ADDR
47081: GO 47127
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
47083: LD_ADDR_EXP 109
47087: PUSH
47088: LD_EXP 109
47092: PPUSH
47093: LD_VAR 0 4
47097: PUSH
47098: LD_EXP 109
47102: PUSH
47103: LD_VAR 0 4
47107: ARRAY
47108: PUSH
47109: LD_INT 1
47111: PLUS
47112: PUSH
47113: EMPTY
47114: LIST
47115: LIST
47116: PPUSH
47117: LD_VAR 0 1
47121: PPUSH
47122: CALL 55835 0 3
47126: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
47127: LD_VAR 0 1
47131: PPUSH
47132: CALL_OW 263
47136: PUSH
47137: LD_INT 2
47139: EQUAL
47140: IFFALSE 47160
// begin repeat wait ( 0 0$1 ) ;
47142: LD_INT 35
47144: PPUSH
47145: CALL_OW 67
// until IsControledBy ( vehicle ) ;
47149: LD_VAR 0 1
47153: PPUSH
47154: CALL_OW 312
47158: IFFALSE 47142
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47160: LD_VAR 0 1
47164: PPUSH
47165: LD_EXP 114
47169: PUSH
47170: LD_VAR 0 4
47174: ARRAY
47175: PPUSH
47176: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47180: LD_VAR 0 1
47184: PPUSH
47185: CALL_OW 263
47189: PUSH
47190: LD_INT 1
47192: NONEQUAL
47193: IFFALSE 47197
// break ;
47195: GO 47246
// repeat wait ( 0 0$1 ) ;
47197: LD_INT 35
47199: PPUSH
47200: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47204: LD_VAR 0 1
47208: PPUSH
47209: LD_EXP 114
47213: PUSH
47214: LD_VAR 0 4
47218: ARRAY
47219: PPUSH
47220: CALL_OW 308
47224: IFFALSE 47197
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47226: LD_VAR 0 1
47230: PPUSH
47231: CALL_OW 311
47235: PPUSH
47236: CALL_OW 121
// exit ;
47240: POP
47241: POP
47242: GO 47248
// end ; end ;
47244: GO 46895
47246: POP
47247: POP
// end ;
47248: LD_VAR 0 3
47252: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47253: LD_INT 0
47255: PPUSH
47256: PPUSH
47257: PPUSH
47258: PPUSH
// if not mc_bases or not skirmish then
47259: LD_EXP 90
47263: NOT
47264: PUSH
47265: LD_EXP 88
47269: NOT
47270: OR
47271: IFFALSE 47275
// exit ;
47273: GO 47628
// repeat wait ( 0 0$1 ) ;
47275: LD_INT 35
47277: PPUSH
47278: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47282: LD_VAR 0 2
47286: PPUSH
47287: LD_VAR 0 3
47291: PPUSH
47292: CALL_OW 284
47296: IFFALSE 47275
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47298: LD_VAR 0 2
47302: PPUSH
47303: LD_VAR 0 3
47307: PPUSH
47308: CALL_OW 283
47312: PUSH
47313: LD_INT 4
47315: EQUAL
47316: IFFALSE 47320
// exit ;
47318: GO 47628
// for i = 1 to mc_bases do
47320: LD_ADDR_VAR 0 7
47324: PUSH
47325: DOUBLE
47326: LD_INT 1
47328: DEC
47329: ST_TO_ADDR
47330: LD_EXP 90
47334: PUSH
47335: FOR_TO
47336: IFFALSE 47626
// begin if mc_crates_area [ i ] then
47338: LD_EXP 108
47342: PUSH
47343: LD_VAR 0 7
47347: ARRAY
47348: IFFALSE 47459
// for j in mc_crates_area [ i ] do
47350: LD_ADDR_VAR 0 8
47354: PUSH
47355: LD_EXP 108
47359: PUSH
47360: LD_VAR 0 7
47364: ARRAY
47365: PUSH
47366: FOR_IN
47367: IFFALSE 47457
// if InArea ( x , y , j ) then
47369: LD_VAR 0 2
47373: PPUSH
47374: LD_VAR 0 3
47378: PPUSH
47379: LD_VAR 0 8
47383: PPUSH
47384: CALL_OW 309
47388: IFFALSE 47455
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47390: LD_ADDR_EXP 106
47394: PUSH
47395: LD_EXP 106
47399: PPUSH
47400: LD_VAR 0 7
47404: PUSH
47405: LD_EXP 106
47409: PUSH
47410: LD_VAR 0 7
47414: ARRAY
47415: PUSH
47416: LD_INT 1
47418: PLUS
47419: PUSH
47420: EMPTY
47421: LIST
47422: LIST
47423: PPUSH
47424: LD_VAR 0 4
47428: PUSH
47429: LD_VAR 0 2
47433: PUSH
47434: LD_VAR 0 3
47438: PUSH
47439: EMPTY
47440: LIST
47441: LIST
47442: LIST
47443: PPUSH
47444: CALL 55835 0 3
47448: ST_TO_ADDR
// exit ;
47449: POP
47450: POP
47451: POP
47452: POP
47453: GO 47628
// end ;
47455: GO 47366
47457: POP
47458: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47459: LD_ADDR_VAR 0 9
47463: PUSH
47464: LD_EXP 90
47468: PUSH
47469: LD_VAR 0 7
47473: ARRAY
47474: PPUSH
47475: LD_INT 2
47477: PUSH
47478: LD_INT 30
47480: PUSH
47481: LD_INT 0
47483: PUSH
47484: EMPTY
47485: LIST
47486: LIST
47487: PUSH
47488: LD_INT 30
47490: PUSH
47491: LD_INT 1
47493: PUSH
47494: EMPTY
47495: LIST
47496: LIST
47497: PUSH
47498: EMPTY
47499: LIST
47500: LIST
47501: LIST
47502: PPUSH
47503: CALL_OW 72
47507: ST_TO_ADDR
// if not depot then
47508: LD_VAR 0 9
47512: NOT
47513: IFFALSE 47517
// continue ;
47515: GO 47335
// for j in depot do
47517: LD_ADDR_VAR 0 8
47521: PUSH
47522: LD_VAR 0 9
47526: PUSH
47527: FOR_IN
47528: IFFALSE 47622
// if GetDistUnitXY ( j , x , y ) < 30 then
47530: LD_VAR 0 8
47534: PPUSH
47535: LD_VAR 0 2
47539: PPUSH
47540: LD_VAR 0 3
47544: PPUSH
47545: CALL_OW 297
47549: PUSH
47550: LD_INT 30
47552: LESS
47553: IFFALSE 47620
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47555: LD_ADDR_EXP 106
47559: PUSH
47560: LD_EXP 106
47564: PPUSH
47565: LD_VAR 0 7
47569: PUSH
47570: LD_EXP 106
47574: PUSH
47575: LD_VAR 0 7
47579: ARRAY
47580: PUSH
47581: LD_INT 1
47583: PLUS
47584: PUSH
47585: EMPTY
47586: LIST
47587: LIST
47588: PPUSH
47589: LD_VAR 0 4
47593: PUSH
47594: LD_VAR 0 2
47598: PUSH
47599: LD_VAR 0 3
47603: PUSH
47604: EMPTY
47605: LIST
47606: LIST
47607: LIST
47608: PPUSH
47609: CALL 55835 0 3
47613: ST_TO_ADDR
// exit ;
47614: POP
47615: POP
47616: POP
47617: POP
47618: GO 47628
// end ;
47620: GO 47527
47622: POP
47623: POP
// end ;
47624: GO 47335
47626: POP
47627: POP
// end ;
47628: LD_VAR 0 6
47632: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47633: LD_INT 0
47635: PPUSH
47636: PPUSH
47637: PPUSH
47638: PPUSH
// if not mc_bases or not skirmish then
47639: LD_EXP 90
47643: NOT
47644: PUSH
47645: LD_EXP 88
47649: NOT
47650: OR
47651: IFFALSE 47655
// exit ;
47653: GO 47932
// side := GetSide ( lab ) ;
47655: LD_ADDR_VAR 0 4
47659: PUSH
47660: LD_VAR 0 2
47664: PPUSH
47665: CALL_OW 255
47669: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47670: LD_VAR 0 4
47674: PUSH
47675: LD_EXP 116
47679: IN
47680: NOT
47681: PUSH
47682: LD_EXP 117
47686: NOT
47687: OR
47688: PUSH
47689: LD_EXP 90
47693: NOT
47694: OR
47695: IFFALSE 47699
// exit ;
47697: GO 47932
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47699: LD_ADDR_EXP 117
47703: PUSH
47704: LD_EXP 117
47708: PPUSH
47709: LD_VAR 0 4
47713: PPUSH
47714: LD_EXP 117
47718: PUSH
47719: LD_VAR 0 4
47723: ARRAY
47724: PUSH
47725: LD_VAR 0 1
47729: DIFF
47730: PPUSH
47731: CALL_OW 1
47735: ST_TO_ADDR
// for i = 1 to mc_bases do
47736: LD_ADDR_VAR 0 5
47740: PUSH
47741: DOUBLE
47742: LD_INT 1
47744: DEC
47745: ST_TO_ADDR
47746: LD_EXP 90
47750: PUSH
47751: FOR_TO
47752: IFFALSE 47930
// begin if lab in mc_bases [ i ] then
47754: LD_VAR 0 2
47758: PUSH
47759: LD_EXP 90
47763: PUSH
47764: LD_VAR 0 5
47768: ARRAY
47769: IN
47770: IFFALSE 47928
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47772: LD_VAR 0 1
47776: PUSH
47777: LD_INT 11
47779: PUSH
47780: LD_INT 4
47782: PUSH
47783: LD_INT 3
47785: PUSH
47786: LD_INT 2
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: LIST
47793: LIST
47794: IN
47795: PUSH
47796: LD_EXP 120
47800: PUSH
47801: LD_VAR 0 5
47805: ARRAY
47806: AND
47807: IFFALSE 47928
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47809: LD_ADDR_VAR 0 6
47813: PUSH
47814: LD_EXP 120
47818: PUSH
47819: LD_VAR 0 5
47823: ARRAY
47824: PUSH
47825: LD_INT 1
47827: ARRAY
47828: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47829: LD_ADDR_EXP 120
47833: PUSH
47834: LD_EXP 120
47838: PPUSH
47839: LD_VAR 0 5
47843: PPUSH
47844: EMPTY
47845: PPUSH
47846: CALL_OW 1
47850: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47851: LD_VAR 0 6
47855: PPUSH
47856: LD_INT 0
47858: PPUSH
47859: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47863: LD_VAR 0 6
47867: PPUSH
47868: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47872: LD_ADDR_EXP 119
47876: PUSH
47877: LD_EXP 119
47881: PPUSH
47882: LD_VAR 0 5
47886: PPUSH
47887: LD_EXP 119
47891: PUSH
47892: LD_VAR 0 5
47896: ARRAY
47897: PPUSH
47898: LD_INT 1
47900: PPUSH
47901: LD_VAR 0 6
47905: PPUSH
47906: CALL_OW 2
47910: PPUSH
47911: CALL_OW 1
47915: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47916: LD_VAR 0 5
47920: PPUSH
47921: LD_INT 112
47923: PPUSH
47924: CALL 24856 0 2
// end ; end ; end ;
47928: GO 47751
47930: POP
47931: POP
// end ;
47932: LD_VAR 0 3
47936: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47937: LD_INT 0
47939: PPUSH
47940: PPUSH
47941: PPUSH
47942: PPUSH
47943: PPUSH
47944: PPUSH
47945: PPUSH
47946: PPUSH
// if not mc_bases or not skirmish then
47947: LD_EXP 90
47951: NOT
47952: PUSH
47953: LD_EXP 88
47957: NOT
47958: OR
47959: IFFALSE 47963
// exit ;
47961: GO 49334
// for i = 1 to mc_bases do
47963: LD_ADDR_VAR 0 3
47967: PUSH
47968: DOUBLE
47969: LD_INT 1
47971: DEC
47972: ST_TO_ADDR
47973: LD_EXP 90
47977: PUSH
47978: FOR_TO
47979: IFFALSE 49332
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47981: LD_VAR 0 1
47985: PUSH
47986: LD_EXP 90
47990: PUSH
47991: LD_VAR 0 3
47995: ARRAY
47996: IN
47997: PUSH
47998: LD_VAR 0 1
48002: PUSH
48003: LD_EXP 97
48007: PUSH
48008: LD_VAR 0 3
48012: ARRAY
48013: IN
48014: OR
48015: PUSH
48016: LD_VAR 0 1
48020: PUSH
48021: LD_EXP 112
48025: PUSH
48026: LD_VAR 0 3
48030: ARRAY
48031: IN
48032: OR
48033: PUSH
48034: LD_VAR 0 1
48038: PUSH
48039: LD_EXP 109
48043: PUSH
48044: LD_VAR 0 3
48048: ARRAY
48049: IN
48050: OR
48051: PUSH
48052: LD_VAR 0 1
48056: PUSH
48057: LD_EXP 119
48061: PUSH
48062: LD_VAR 0 3
48066: ARRAY
48067: IN
48068: OR
48069: PUSH
48070: LD_VAR 0 1
48074: PUSH
48075: LD_EXP 120
48079: PUSH
48080: LD_VAR 0 3
48084: ARRAY
48085: IN
48086: OR
48087: IFFALSE 49330
// begin if un in mc_ape [ i ] then
48089: LD_VAR 0 1
48093: PUSH
48094: LD_EXP 119
48098: PUSH
48099: LD_VAR 0 3
48103: ARRAY
48104: IN
48105: IFFALSE 48144
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
48107: LD_ADDR_EXP 119
48111: PUSH
48112: LD_EXP 119
48116: PPUSH
48117: LD_VAR 0 3
48121: PPUSH
48122: LD_EXP 119
48126: PUSH
48127: LD_VAR 0 3
48131: ARRAY
48132: PUSH
48133: LD_VAR 0 1
48137: DIFF
48138: PPUSH
48139: CALL_OW 1
48143: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48144: LD_VAR 0 1
48148: PUSH
48149: LD_EXP 120
48153: PUSH
48154: LD_VAR 0 3
48158: ARRAY
48159: IN
48160: IFFALSE 48184
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48162: LD_ADDR_EXP 120
48166: PUSH
48167: LD_EXP 120
48171: PPUSH
48172: LD_VAR 0 3
48176: PPUSH
48177: EMPTY
48178: PPUSH
48179: CALL_OW 1
48183: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48184: LD_VAR 0 1
48188: PPUSH
48189: CALL_OW 247
48193: PUSH
48194: LD_INT 2
48196: EQUAL
48197: PUSH
48198: LD_VAR 0 1
48202: PPUSH
48203: CALL_OW 110
48207: PUSH
48208: LD_INT 20
48210: EQUAL
48211: PUSH
48212: LD_VAR 0 1
48216: PUSH
48217: LD_EXP 112
48221: PUSH
48222: LD_VAR 0 3
48226: ARRAY
48227: IN
48228: OR
48229: PUSH
48230: LD_VAR 0 1
48234: PPUSH
48235: CALL_OW 264
48239: PUSH
48240: LD_INT 12
48242: PUSH
48243: LD_INT 51
48245: PUSH
48246: LD_EXP 73
48250: PUSH
48251: LD_INT 32
48253: PUSH
48254: LD_INT 13
48256: PUSH
48257: LD_INT 52
48259: PUSH
48260: LD_INT 31
48262: PUSH
48263: EMPTY
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: IN
48272: OR
48273: AND
48274: IFFALSE 48582
// begin if un in mc_defender [ i ] then
48276: LD_VAR 0 1
48280: PUSH
48281: LD_EXP 112
48285: PUSH
48286: LD_VAR 0 3
48290: ARRAY
48291: IN
48292: IFFALSE 48331
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48294: LD_ADDR_EXP 112
48298: PUSH
48299: LD_EXP 112
48303: PPUSH
48304: LD_VAR 0 3
48308: PPUSH
48309: LD_EXP 112
48313: PUSH
48314: LD_VAR 0 3
48318: ARRAY
48319: PUSH
48320: LD_VAR 0 1
48324: DIFF
48325: PPUSH
48326: CALL_OW 1
48330: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48331: LD_ADDR_VAR 0 8
48335: PUSH
48336: LD_VAR 0 3
48340: PPUSH
48341: LD_INT 3
48343: PPUSH
48344: CALL 44981 0 2
48348: ST_TO_ADDR
// if fac then
48349: LD_VAR 0 8
48353: IFFALSE 48582
// begin for j in fac do
48355: LD_ADDR_VAR 0 4
48359: PUSH
48360: LD_VAR 0 8
48364: PUSH
48365: FOR_IN
48366: IFFALSE 48580
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48368: LD_ADDR_VAR 0 9
48372: PUSH
48373: LD_VAR 0 8
48377: PPUSH
48378: LD_VAR 0 1
48382: PPUSH
48383: CALL_OW 265
48387: PPUSH
48388: LD_VAR 0 1
48392: PPUSH
48393: CALL_OW 262
48397: PPUSH
48398: LD_VAR 0 1
48402: PPUSH
48403: CALL_OW 263
48407: PPUSH
48408: LD_VAR 0 1
48412: PPUSH
48413: CALL_OW 264
48417: PPUSH
48418: CALL 53367 0 5
48422: ST_TO_ADDR
// if components then
48423: LD_VAR 0 9
48427: IFFALSE 48578
// begin if GetWeapon ( un ) = ar_control_tower then
48429: LD_VAR 0 1
48433: PPUSH
48434: CALL_OW 264
48438: PUSH
48439: LD_INT 31
48441: EQUAL
48442: IFFALSE 48559
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48444: LD_VAR 0 1
48448: PPUSH
48449: CALL_OW 311
48453: PPUSH
48454: LD_INT 0
48456: PPUSH
48457: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48461: LD_ADDR_EXP 130
48465: PUSH
48466: LD_EXP 130
48470: PPUSH
48471: LD_VAR 0 3
48475: PPUSH
48476: LD_EXP 130
48480: PUSH
48481: LD_VAR 0 3
48485: ARRAY
48486: PUSH
48487: LD_VAR 0 1
48491: PPUSH
48492: CALL_OW 311
48496: DIFF
48497: PPUSH
48498: CALL_OW 1
48502: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48503: LD_ADDR_VAR 0 7
48507: PUSH
48508: LD_EXP 111
48512: PUSH
48513: LD_VAR 0 3
48517: ARRAY
48518: PPUSH
48519: LD_INT 1
48521: PPUSH
48522: LD_VAR 0 9
48526: PPUSH
48527: CALL_OW 2
48531: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48532: LD_ADDR_EXP 111
48536: PUSH
48537: LD_EXP 111
48541: PPUSH
48542: LD_VAR 0 3
48546: PPUSH
48547: LD_VAR 0 7
48551: PPUSH
48552: CALL_OW 1
48556: ST_TO_ADDR
// end else
48557: GO 48576
// MC_InsertProduceList ( i , [ components ] ) ;
48559: LD_VAR 0 3
48563: PPUSH
48564: LD_VAR 0 9
48568: PUSH
48569: EMPTY
48570: LIST
48571: PPUSH
48572: CALL 44526 0 2
// break ;
48576: GO 48580
// end ; end ;
48578: GO 48365
48580: POP
48581: POP
// end ; end ; if GetType ( un ) = unit_building then
48582: LD_VAR 0 1
48586: PPUSH
48587: CALL_OW 247
48591: PUSH
48592: LD_INT 3
48594: EQUAL
48595: IFFALSE 48998
// begin btype := GetBType ( un ) ;
48597: LD_ADDR_VAR 0 5
48601: PUSH
48602: LD_VAR 0 1
48606: PPUSH
48607: CALL_OW 266
48611: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48612: LD_VAR 0 5
48616: PUSH
48617: LD_INT 29
48619: PUSH
48620: LD_INT 30
48622: PUSH
48623: EMPTY
48624: LIST
48625: LIST
48626: IN
48627: IFFALSE 48700
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48629: LD_VAR 0 1
48633: PPUSH
48634: CALL_OW 250
48638: PPUSH
48639: LD_VAR 0 1
48643: PPUSH
48644: CALL_OW 251
48648: PPUSH
48649: LD_VAR 0 1
48653: PPUSH
48654: CALL_OW 255
48658: PPUSH
48659: CALL_OW 440
48663: NOT
48664: IFFALSE 48700
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48666: LD_VAR 0 1
48670: PPUSH
48671: CALL_OW 250
48675: PPUSH
48676: LD_VAR 0 1
48680: PPUSH
48681: CALL_OW 251
48685: PPUSH
48686: LD_VAR 0 1
48690: PPUSH
48691: CALL_OW 255
48695: PPUSH
48696: CALL_OW 441
// end ; if btype = b_warehouse then
48700: LD_VAR 0 5
48704: PUSH
48705: LD_INT 1
48707: EQUAL
48708: IFFALSE 48726
// begin btype := b_depot ;
48710: LD_ADDR_VAR 0 5
48714: PUSH
48715: LD_INT 0
48717: ST_TO_ADDR
// pos := 1 ;
48718: LD_ADDR_VAR 0 6
48722: PUSH
48723: LD_INT 1
48725: ST_TO_ADDR
// end ; if btype = b_factory then
48726: LD_VAR 0 5
48730: PUSH
48731: LD_INT 3
48733: EQUAL
48734: IFFALSE 48752
// begin btype := b_workshop ;
48736: LD_ADDR_VAR 0 5
48740: PUSH
48741: LD_INT 2
48743: ST_TO_ADDR
// pos := 1 ;
48744: LD_ADDR_VAR 0 6
48748: PUSH
48749: LD_INT 1
48751: ST_TO_ADDR
// end ; if btype = b_barracks then
48752: LD_VAR 0 5
48756: PUSH
48757: LD_INT 5
48759: EQUAL
48760: IFFALSE 48770
// btype := b_armoury ;
48762: LD_ADDR_VAR 0 5
48766: PUSH
48767: LD_INT 4
48769: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48770: LD_VAR 0 5
48774: PUSH
48775: LD_INT 7
48777: PUSH
48778: LD_INT 8
48780: PUSH
48781: EMPTY
48782: LIST
48783: LIST
48784: IN
48785: IFFALSE 48795
// btype := b_lab ;
48787: LD_ADDR_VAR 0 5
48791: PUSH
48792: LD_INT 6
48794: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48795: LD_ADDR_EXP 95
48799: PUSH
48800: LD_EXP 95
48804: PPUSH
48805: LD_VAR 0 3
48809: PUSH
48810: LD_EXP 95
48814: PUSH
48815: LD_VAR 0 3
48819: ARRAY
48820: PUSH
48821: LD_INT 1
48823: PLUS
48824: PUSH
48825: EMPTY
48826: LIST
48827: LIST
48828: PPUSH
48829: LD_VAR 0 5
48833: PUSH
48834: LD_VAR 0 1
48838: PPUSH
48839: CALL_OW 250
48843: PUSH
48844: LD_VAR 0 1
48848: PPUSH
48849: CALL_OW 251
48853: PUSH
48854: LD_VAR 0 1
48858: PPUSH
48859: CALL_OW 254
48863: PUSH
48864: EMPTY
48865: LIST
48866: LIST
48867: LIST
48868: LIST
48869: PPUSH
48870: CALL 55835 0 3
48874: ST_TO_ADDR
// if pos = 1 then
48875: LD_VAR 0 6
48879: PUSH
48880: LD_INT 1
48882: EQUAL
48883: IFFALSE 48998
// begin tmp := mc_build_list [ i ] ;
48885: LD_ADDR_VAR 0 7
48889: PUSH
48890: LD_EXP 95
48894: PUSH
48895: LD_VAR 0 3
48899: ARRAY
48900: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48901: LD_VAR 0 7
48905: PPUSH
48906: LD_INT 2
48908: PUSH
48909: LD_INT 30
48911: PUSH
48912: LD_INT 0
48914: PUSH
48915: EMPTY
48916: LIST
48917: LIST
48918: PUSH
48919: LD_INT 30
48921: PUSH
48922: LD_INT 1
48924: PUSH
48925: EMPTY
48926: LIST
48927: LIST
48928: PUSH
48929: EMPTY
48930: LIST
48931: LIST
48932: LIST
48933: PPUSH
48934: CALL_OW 72
48938: IFFALSE 48948
// pos := 2 ;
48940: LD_ADDR_VAR 0 6
48944: PUSH
48945: LD_INT 2
48947: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48948: LD_ADDR_VAR 0 7
48952: PUSH
48953: LD_VAR 0 7
48957: PPUSH
48958: LD_VAR 0 6
48962: PPUSH
48963: LD_VAR 0 7
48967: PPUSH
48968: CALL 56161 0 3
48972: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48973: LD_ADDR_EXP 95
48977: PUSH
48978: LD_EXP 95
48982: PPUSH
48983: LD_VAR 0 3
48987: PPUSH
48988: LD_VAR 0 7
48992: PPUSH
48993: CALL_OW 1
48997: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48998: LD_VAR 0 1
49002: PUSH
49003: LD_EXP 90
49007: PUSH
49008: LD_VAR 0 3
49012: ARRAY
49013: IN
49014: IFFALSE 49053
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
49016: LD_ADDR_EXP 90
49020: PUSH
49021: LD_EXP 90
49025: PPUSH
49026: LD_VAR 0 3
49030: PPUSH
49031: LD_EXP 90
49035: PUSH
49036: LD_VAR 0 3
49040: ARRAY
49041: PUSH
49042: LD_VAR 0 1
49046: DIFF
49047: PPUSH
49048: CALL_OW 1
49052: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
49053: LD_VAR 0 1
49057: PUSH
49058: LD_EXP 97
49062: PUSH
49063: LD_VAR 0 3
49067: ARRAY
49068: IN
49069: IFFALSE 49108
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
49071: LD_ADDR_EXP 97
49075: PUSH
49076: LD_EXP 97
49080: PPUSH
49081: LD_VAR 0 3
49085: PPUSH
49086: LD_EXP 97
49090: PUSH
49091: LD_VAR 0 3
49095: ARRAY
49096: PUSH
49097: LD_VAR 0 1
49101: DIFF
49102: PPUSH
49103: CALL_OW 1
49107: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
49108: LD_VAR 0 1
49112: PUSH
49113: LD_EXP 109
49117: PUSH
49118: LD_VAR 0 3
49122: ARRAY
49123: IN
49124: IFFALSE 49163
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
49126: LD_ADDR_EXP 109
49130: PUSH
49131: LD_EXP 109
49135: PPUSH
49136: LD_VAR 0 3
49140: PPUSH
49141: LD_EXP 109
49145: PUSH
49146: LD_VAR 0 3
49150: ARRAY
49151: PUSH
49152: LD_VAR 0 1
49156: DIFF
49157: PPUSH
49158: CALL_OW 1
49162: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49163: LD_VAR 0 1
49167: PUSH
49168: LD_EXP 112
49172: PUSH
49173: LD_VAR 0 3
49177: ARRAY
49178: IN
49179: IFFALSE 49218
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49181: LD_ADDR_EXP 112
49185: PUSH
49186: LD_EXP 112
49190: PPUSH
49191: LD_VAR 0 3
49195: PPUSH
49196: LD_EXP 112
49200: PUSH
49201: LD_VAR 0 3
49205: ARRAY
49206: PUSH
49207: LD_VAR 0 1
49211: DIFF
49212: PPUSH
49213: CALL_OW 1
49217: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49218: LD_VAR 0 1
49222: PUSH
49223: LD_EXP 99
49227: PUSH
49228: LD_VAR 0 3
49232: ARRAY
49233: IN
49234: IFFALSE 49273
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49236: LD_ADDR_EXP 99
49240: PUSH
49241: LD_EXP 99
49245: PPUSH
49246: LD_VAR 0 3
49250: PPUSH
49251: LD_EXP 99
49255: PUSH
49256: LD_VAR 0 3
49260: ARRAY
49261: PUSH
49262: LD_VAR 0 1
49266: DIFF
49267: PPUSH
49268: CALL_OW 1
49272: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49273: LD_VAR 0 1
49277: PUSH
49278: LD_EXP 98
49282: PUSH
49283: LD_VAR 0 3
49287: ARRAY
49288: IN
49289: IFFALSE 49328
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49291: LD_ADDR_EXP 98
49295: PUSH
49296: LD_EXP 98
49300: PPUSH
49301: LD_VAR 0 3
49305: PPUSH
49306: LD_EXP 98
49310: PUSH
49311: LD_VAR 0 3
49315: ARRAY
49316: PUSH
49317: LD_VAR 0 1
49321: DIFF
49322: PPUSH
49323: CALL_OW 1
49327: ST_TO_ADDR
// end ; break ;
49328: GO 49332
// end ;
49330: GO 47978
49332: POP
49333: POP
// end ;
49334: LD_VAR 0 2
49338: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49339: LD_INT 0
49341: PPUSH
49342: PPUSH
49343: PPUSH
// if not mc_bases or not skirmish then
49344: LD_EXP 90
49348: NOT
49349: PUSH
49350: LD_EXP 88
49354: NOT
49355: OR
49356: IFFALSE 49360
// exit ;
49358: GO 49575
// for i = 1 to mc_bases do
49360: LD_ADDR_VAR 0 3
49364: PUSH
49365: DOUBLE
49366: LD_INT 1
49368: DEC
49369: ST_TO_ADDR
49370: LD_EXP 90
49374: PUSH
49375: FOR_TO
49376: IFFALSE 49573
// begin if building in mc_construct_list [ i ] then
49378: LD_VAR 0 1
49382: PUSH
49383: LD_EXP 97
49387: PUSH
49388: LD_VAR 0 3
49392: ARRAY
49393: IN
49394: IFFALSE 49571
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49396: LD_ADDR_EXP 97
49400: PUSH
49401: LD_EXP 97
49405: PPUSH
49406: LD_VAR 0 3
49410: PPUSH
49411: LD_EXP 97
49415: PUSH
49416: LD_VAR 0 3
49420: ARRAY
49421: PUSH
49422: LD_VAR 0 1
49426: DIFF
49427: PPUSH
49428: CALL_OW 1
49432: ST_TO_ADDR
// if building in mc_lab [ i ] then
49433: LD_VAR 0 1
49437: PUSH
49438: LD_EXP 123
49442: PUSH
49443: LD_VAR 0 3
49447: ARRAY
49448: IN
49449: IFFALSE 49504
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49451: LD_ADDR_EXP 124
49455: PUSH
49456: LD_EXP 124
49460: PPUSH
49461: LD_VAR 0 3
49465: PPUSH
49466: LD_EXP 124
49470: PUSH
49471: LD_VAR 0 3
49475: ARRAY
49476: PPUSH
49477: LD_INT 1
49479: PPUSH
49480: LD_EXP 124
49484: PUSH
49485: LD_VAR 0 3
49489: ARRAY
49490: PPUSH
49491: LD_INT 0
49493: PPUSH
49494: CALL 55253 0 4
49498: PPUSH
49499: CALL_OW 1
49503: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49504: LD_VAR 0 1
49508: PUSH
49509: LD_EXP 90
49513: PUSH
49514: LD_VAR 0 3
49518: ARRAY
49519: IN
49520: NOT
49521: IFFALSE 49567
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49523: LD_ADDR_EXP 90
49527: PUSH
49528: LD_EXP 90
49532: PPUSH
49533: LD_VAR 0 3
49537: PUSH
49538: LD_EXP 90
49542: PUSH
49543: LD_VAR 0 3
49547: ARRAY
49548: PUSH
49549: LD_INT 1
49551: PLUS
49552: PUSH
49553: EMPTY
49554: LIST
49555: LIST
49556: PPUSH
49557: LD_VAR 0 1
49561: PPUSH
49562: CALL 55835 0 3
49566: ST_TO_ADDR
// exit ;
49567: POP
49568: POP
49569: GO 49575
// end ; end ;
49571: GO 49375
49573: POP
49574: POP
// end ;
49575: LD_VAR 0 2
49579: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49580: LD_INT 0
49582: PPUSH
49583: PPUSH
49584: PPUSH
49585: PPUSH
49586: PPUSH
49587: PPUSH
49588: PPUSH
// if not mc_bases or not skirmish then
49589: LD_EXP 90
49593: NOT
49594: PUSH
49595: LD_EXP 88
49599: NOT
49600: OR
49601: IFFALSE 49605
// exit ;
49603: GO 50266
// for i = 1 to mc_bases do
49605: LD_ADDR_VAR 0 3
49609: PUSH
49610: DOUBLE
49611: LD_INT 1
49613: DEC
49614: ST_TO_ADDR
49615: LD_EXP 90
49619: PUSH
49620: FOR_TO
49621: IFFALSE 50264
// begin if building in mc_construct_list [ i ] then
49623: LD_VAR 0 1
49627: PUSH
49628: LD_EXP 97
49632: PUSH
49633: LD_VAR 0 3
49637: ARRAY
49638: IN
49639: IFFALSE 50262
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49641: LD_ADDR_EXP 97
49645: PUSH
49646: LD_EXP 97
49650: PPUSH
49651: LD_VAR 0 3
49655: PPUSH
49656: LD_EXP 97
49660: PUSH
49661: LD_VAR 0 3
49665: ARRAY
49666: PUSH
49667: LD_VAR 0 1
49671: DIFF
49672: PPUSH
49673: CALL_OW 1
49677: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49678: LD_ADDR_EXP 90
49682: PUSH
49683: LD_EXP 90
49687: PPUSH
49688: LD_VAR 0 3
49692: PUSH
49693: LD_EXP 90
49697: PUSH
49698: LD_VAR 0 3
49702: ARRAY
49703: PUSH
49704: LD_INT 1
49706: PLUS
49707: PUSH
49708: EMPTY
49709: LIST
49710: LIST
49711: PPUSH
49712: LD_VAR 0 1
49716: PPUSH
49717: CALL 55835 0 3
49721: ST_TO_ADDR
// btype := GetBType ( building ) ;
49722: LD_ADDR_VAR 0 5
49726: PUSH
49727: LD_VAR 0 1
49731: PPUSH
49732: CALL_OW 266
49736: ST_TO_ADDR
// side := GetSide ( building ) ;
49737: LD_ADDR_VAR 0 8
49741: PUSH
49742: LD_VAR 0 1
49746: PPUSH
49747: CALL_OW 255
49751: ST_TO_ADDR
// if btype = b_lab then
49752: LD_VAR 0 5
49756: PUSH
49757: LD_INT 6
49759: EQUAL
49760: IFFALSE 49810
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49762: LD_ADDR_EXP 123
49766: PUSH
49767: LD_EXP 123
49771: PPUSH
49772: LD_VAR 0 3
49776: PUSH
49777: LD_EXP 123
49781: PUSH
49782: LD_VAR 0 3
49786: ARRAY
49787: PUSH
49788: LD_INT 1
49790: PLUS
49791: PUSH
49792: EMPTY
49793: LIST
49794: LIST
49795: PPUSH
49796: LD_VAR 0 1
49800: PPUSH
49801: CALL 55835 0 3
49805: ST_TO_ADDR
// exit ;
49806: POP
49807: POP
49808: GO 50266
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49810: LD_VAR 0 5
49814: PUSH
49815: LD_INT 0
49817: PUSH
49818: LD_INT 2
49820: PUSH
49821: LD_INT 4
49823: PUSH
49824: EMPTY
49825: LIST
49826: LIST
49827: LIST
49828: IN
49829: IFFALSE 49953
// begin if btype = b_armoury then
49831: LD_VAR 0 5
49835: PUSH
49836: LD_INT 4
49838: EQUAL
49839: IFFALSE 49849
// btype := b_barracks ;
49841: LD_ADDR_VAR 0 5
49845: PUSH
49846: LD_INT 5
49848: ST_TO_ADDR
// if btype = b_depot then
49849: LD_VAR 0 5
49853: PUSH
49854: LD_INT 0
49856: EQUAL
49857: IFFALSE 49867
// btype := b_warehouse ;
49859: LD_ADDR_VAR 0 5
49863: PUSH
49864: LD_INT 1
49866: ST_TO_ADDR
// if btype = b_workshop then
49867: LD_VAR 0 5
49871: PUSH
49872: LD_INT 2
49874: EQUAL
49875: IFFALSE 49885
// btype := b_factory ;
49877: LD_ADDR_VAR 0 5
49881: PUSH
49882: LD_INT 3
49884: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49885: LD_VAR 0 5
49889: PPUSH
49890: LD_VAR 0 8
49894: PPUSH
49895: CALL_OW 323
49899: PUSH
49900: LD_INT 1
49902: EQUAL
49903: IFFALSE 49949
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49905: LD_ADDR_EXP 122
49909: PUSH
49910: LD_EXP 122
49914: PPUSH
49915: LD_VAR 0 3
49919: PUSH
49920: LD_EXP 122
49924: PUSH
49925: LD_VAR 0 3
49929: ARRAY
49930: PUSH
49931: LD_INT 1
49933: PLUS
49934: PUSH
49935: EMPTY
49936: LIST
49937: LIST
49938: PPUSH
49939: LD_VAR 0 1
49943: PPUSH
49944: CALL 55835 0 3
49948: ST_TO_ADDR
// exit ;
49949: POP
49950: POP
49951: GO 50266
// end ; if btype in [ b_bunker , b_turret ] then
49953: LD_VAR 0 5
49957: PUSH
49958: LD_INT 32
49960: PUSH
49961: LD_INT 33
49963: PUSH
49964: EMPTY
49965: LIST
49966: LIST
49967: IN
49968: IFFALSE 50258
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49970: LD_ADDR_EXP 98
49974: PUSH
49975: LD_EXP 98
49979: PPUSH
49980: LD_VAR 0 3
49984: PUSH
49985: LD_EXP 98
49989: PUSH
49990: LD_VAR 0 3
49994: ARRAY
49995: PUSH
49996: LD_INT 1
49998: PLUS
49999: PUSH
50000: EMPTY
50001: LIST
50002: LIST
50003: PPUSH
50004: LD_VAR 0 1
50008: PPUSH
50009: CALL 55835 0 3
50013: ST_TO_ADDR
// if btype = b_bunker then
50014: LD_VAR 0 5
50018: PUSH
50019: LD_INT 32
50021: EQUAL
50022: IFFALSE 50258
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50024: LD_ADDR_EXP 99
50028: PUSH
50029: LD_EXP 99
50033: PPUSH
50034: LD_VAR 0 3
50038: PUSH
50039: LD_EXP 99
50043: PUSH
50044: LD_VAR 0 3
50048: ARRAY
50049: PUSH
50050: LD_INT 1
50052: PLUS
50053: PUSH
50054: EMPTY
50055: LIST
50056: LIST
50057: PPUSH
50058: LD_VAR 0 1
50062: PPUSH
50063: CALL 55835 0 3
50067: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
50068: LD_ADDR_VAR 0 6
50072: PUSH
50073: LD_EXP 90
50077: PUSH
50078: LD_VAR 0 3
50082: ARRAY
50083: PPUSH
50084: LD_INT 25
50086: PUSH
50087: LD_INT 1
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: PUSH
50094: LD_INT 3
50096: PUSH
50097: LD_INT 54
50099: PUSH
50100: EMPTY
50101: LIST
50102: PUSH
50103: EMPTY
50104: LIST
50105: LIST
50106: PUSH
50107: EMPTY
50108: LIST
50109: LIST
50110: PPUSH
50111: CALL_OW 72
50115: ST_TO_ADDR
// if tmp then
50116: LD_VAR 0 6
50120: IFFALSE 50126
// exit ;
50122: POP
50123: POP
50124: GO 50266
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
50126: LD_ADDR_VAR 0 6
50130: PUSH
50131: LD_EXP 90
50135: PUSH
50136: LD_VAR 0 3
50140: ARRAY
50141: PPUSH
50142: LD_INT 2
50144: PUSH
50145: LD_INT 30
50147: PUSH
50148: LD_INT 4
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PUSH
50155: LD_INT 30
50157: PUSH
50158: LD_INT 5
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: PUSH
50165: EMPTY
50166: LIST
50167: LIST
50168: LIST
50169: PPUSH
50170: CALL_OW 72
50174: ST_TO_ADDR
// if not tmp then
50175: LD_VAR 0 6
50179: NOT
50180: IFFALSE 50186
// exit ;
50182: POP
50183: POP
50184: GO 50266
// for j in tmp do
50186: LD_ADDR_VAR 0 4
50190: PUSH
50191: LD_VAR 0 6
50195: PUSH
50196: FOR_IN
50197: IFFALSE 50256
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50199: LD_ADDR_VAR 0 7
50203: PUSH
50204: LD_VAR 0 4
50208: PPUSH
50209: CALL_OW 313
50213: PPUSH
50214: LD_INT 25
50216: PUSH
50217: LD_INT 1
50219: PUSH
50220: EMPTY
50221: LIST
50222: LIST
50223: PPUSH
50224: CALL_OW 72
50228: ST_TO_ADDR
// if units then
50229: LD_VAR 0 7
50233: IFFALSE 50254
// begin ComExitBuilding ( units [ 1 ] ) ;
50235: LD_VAR 0 7
50239: PUSH
50240: LD_INT 1
50242: ARRAY
50243: PPUSH
50244: CALL_OW 122
// exit ;
50248: POP
50249: POP
50250: POP
50251: POP
50252: GO 50266
// end ; end ;
50254: GO 50196
50256: POP
50257: POP
// end ; end ; exit ;
50258: POP
50259: POP
50260: GO 50266
// end ; end ;
50262: GO 49620
50264: POP
50265: POP
// end ;
50266: LD_VAR 0 2
50270: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50271: LD_INT 0
50273: PPUSH
50274: PPUSH
50275: PPUSH
50276: PPUSH
50277: PPUSH
50278: PPUSH
50279: PPUSH
// if not mc_bases or not skirmish then
50280: LD_EXP 90
50284: NOT
50285: PUSH
50286: LD_EXP 88
50290: NOT
50291: OR
50292: IFFALSE 50296
// exit ;
50294: GO 50527
// btype := GetBType ( building ) ;
50296: LD_ADDR_VAR 0 6
50300: PUSH
50301: LD_VAR 0 1
50305: PPUSH
50306: CALL_OW 266
50310: ST_TO_ADDR
// x := GetX ( building ) ;
50311: LD_ADDR_VAR 0 7
50315: PUSH
50316: LD_VAR 0 1
50320: PPUSH
50321: CALL_OW 250
50325: ST_TO_ADDR
// y := GetY ( building ) ;
50326: LD_ADDR_VAR 0 8
50330: PUSH
50331: LD_VAR 0 1
50335: PPUSH
50336: CALL_OW 251
50340: ST_TO_ADDR
// d := GetDir ( building ) ;
50341: LD_ADDR_VAR 0 9
50345: PUSH
50346: LD_VAR 0 1
50350: PPUSH
50351: CALL_OW 254
50355: ST_TO_ADDR
// for i = 1 to mc_bases do
50356: LD_ADDR_VAR 0 4
50360: PUSH
50361: DOUBLE
50362: LD_INT 1
50364: DEC
50365: ST_TO_ADDR
50366: LD_EXP 90
50370: PUSH
50371: FOR_TO
50372: IFFALSE 50525
// begin if not mc_build_list [ i ] then
50374: LD_EXP 95
50378: PUSH
50379: LD_VAR 0 4
50383: ARRAY
50384: NOT
50385: IFFALSE 50389
// continue ;
50387: GO 50371
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50389: LD_VAR 0 6
50393: PUSH
50394: LD_VAR 0 7
50398: PUSH
50399: LD_VAR 0 8
50403: PUSH
50404: LD_VAR 0 9
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: LIST
50413: LIST
50414: PPUSH
50415: LD_EXP 95
50419: PUSH
50420: LD_VAR 0 4
50424: ARRAY
50425: PUSH
50426: LD_INT 1
50428: ARRAY
50429: PPUSH
50430: CALL 62042 0 2
50434: IFFALSE 50523
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50436: LD_ADDR_EXP 95
50440: PUSH
50441: LD_EXP 95
50445: PPUSH
50446: LD_VAR 0 4
50450: PPUSH
50451: LD_EXP 95
50455: PUSH
50456: LD_VAR 0 4
50460: ARRAY
50461: PPUSH
50462: LD_INT 1
50464: PPUSH
50465: CALL_OW 3
50469: PPUSH
50470: CALL_OW 1
50474: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50475: LD_ADDR_EXP 97
50479: PUSH
50480: LD_EXP 97
50484: PPUSH
50485: LD_VAR 0 4
50489: PUSH
50490: LD_EXP 97
50494: PUSH
50495: LD_VAR 0 4
50499: ARRAY
50500: PUSH
50501: LD_INT 1
50503: PLUS
50504: PUSH
50505: EMPTY
50506: LIST
50507: LIST
50508: PPUSH
50509: LD_VAR 0 1
50513: PPUSH
50514: CALL 55835 0 3
50518: ST_TO_ADDR
// exit ;
50519: POP
50520: POP
50521: GO 50527
// end ; end ;
50523: GO 50371
50525: POP
50526: POP
// end ;
50527: LD_VAR 0 3
50531: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50532: LD_INT 0
50534: PPUSH
50535: PPUSH
50536: PPUSH
// if not mc_bases or not skirmish then
50537: LD_EXP 90
50541: NOT
50542: PUSH
50543: LD_EXP 88
50547: NOT
50548: OR
50549: IFFALSE 50553
// exit ;
50551: GO 50743
// for i = 1 to mc_bases do
50553: LD_ADDR_VAR 0 4
50557: PUSH
50558: DOUBLE
50559: LD_INT 1
50561: DEC
50562: ST_TO_ADDR
50563: LD_EXP 90
50567: PUSH
50568: FOR_TO
50569: IFFALSE 50656
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50571: LD_VAR 0 1
50575: PUSH
50576: LD_EXP 98
50580: PUSH
50581: LD_VAR 0 4
50585: ARRAY
50586: IN
50587: PUSH
50588: LD_VAR 0 1
50592: PUSH
50593: LD_EXP 99
50597: PUSH
50598: LD_VAR 0 4
50602: ARRAY
50603: IN
50604: NOT
50605: AND
50606: IFFALSE 50654
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50608: LD_ADDR_EXP 99
50612: PUSH
50613: LD_EXP 99
50617: PPUSH
50618: LD_VAR 0 4
50622: PUSH
50623: LD_EXP 99
50627: PUSH
50628: LD_VAR 0 4
50632: ARRAY
50633: PUSH
50634: LD_INT 1
50636: PLUS
50637: PUSH
50638: EMPTY
50639: LIST
50640: LIST
50641: PPUSH
50642: LD_VAR 0 1
50646: PPUSH
50647: CALL 55835 0 3
50651: ST_TO_ADDR
// break ;
50652: GO 50656
// end ; end ;
50654: GO 50568
50656: POP
50657: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50658: LD_VAR 0 1
50662: PPUSH
50663: CALL_OW 257
50667: PUSH
50668: LD_EXP 116
50672: IN
50673: PUSH
50674: LD_VAR 0 1
50678: PPUSH
50679: CALL_OW 266
50683: PUSH
50684: LD_INT 5
50686: EQUAL
50687: AND
50688: PUSH
50689: LD_VAR 0 2
50693: PPUSH
50694: CALL_OW 110
50698: PUSH
50699: LD_INT 18
50701: NONEQUAL
50702: AND
50703: IFFALSE 50743
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50705: LD_VAR 0 2
50709: PPUSH
50710: CALL_OW 257
50714: PUSH
50715: LD_INT 5
50717: PUSH
50718: LD_INT 8
50720: PUSH
50721: LD_INT 9
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: LIST
50728: IN
50729: IFFALSE 50743
// SetClass ( unit , 1 ) ;
50731: LD_VAR 0 2
50735: PPUSH
50736: LD_INT 1
50738: PPUSH
50739: CALL_OW 336
// end ;
50743: LD_VAR 0 3
50747: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50748: LD_INT 0
50750: PPUSH
50751: PPUSH
// if not mc_bases or not skirmish then
50752: LD_EXP 90
50756: NOT
50757: PUSH
50758: LD_EXP 88
50762: NOT
50763: OR
50764: IFFALSE 50768
// exit ;
50766: GO 50884
// if GetLives ( abandoned_vehicle ) > 250 then
50768: LD_VAR 0 2
50772: PPUSH
50773: CALL_OW 256
50777: PUSH
50778: LD_INT 250
50780: GREATER
50781: IFFALSE 50785
// exit ;
50783: GO 50884
// for i = 1 to mc_bases do
50785: LD_ADDR_VAR 0 6
50789: PUSH
50790: DOUBLE
50791: LD_INT 1
50793: DEC
50794: ST_TO_ADDR
50795: LD_EXP 90
50799: PUSH
50800: FOR_TO
50801: IFFALSE 50882
// begin if driver in mc_bases [ i ] then
50803: LD_VAR 0 1
50807: PUSH
50808: LD_EXP 90
50812: PUSH
50813: LD_VAR 0 6
50817: ARRAY
50818: IN
50819: IFFALSE 50880
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50821: LD_VAR 0 1
50825: PPUSH
50826: LD_EXP 90
50830: PUSH
50831: LD_VAR 0 6
50835: ARRAY
50836: PPUSH
50837: LD_INT 2
50839: PUSH
50840: LD_INT 30
50842: PUSH
50843: LD_INT 0
50845: PUSH
50846: EMPTY
50847: LIST
50848: LIST
50849: PUSH
50850: LD_INT 30
50852: PUSH
50853: LD_INT 1
50855: PUSH
50856: EMPTY
50857: LIST
50858: LIST
50859: PUSH
50860: EMPTY
50861: LIST
50862: LIST
50863: LIST
50864: PPUSH
50865: CALL_OW 72
50869: PUSH
50870: LD_INT 1
50872: ARRAY
50873: PPUSH
50874: CALL 88078 0 2
// break ;
50878: GO 50882
// end ; end ;
50880: GO 50800
50882: POP
50883: POP
// end ; end_of_file
50884: LD_VAR 0 5
50888: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50889: LD_INT 0
50891: PPUSH
50892: PPUSH
// if exist_mode then
50893: LD_VAR 0 2
50897: IFFALSE 50922
// unit := CreateCharacter ( prefix & ident ) else
50899: LD_ADDR_VAR 0 5
50903: PUSH
50904: LD_VAR 0 3
50908: PUSH
50909: LD_VAR 0 1
50913: STR
50914: PPUSH
50915: CALL_OW 34
50919: ST_TO_ADDR
50920: GO 50937
// unit := NewCharacter ( ident ) ;
50922: LD_ADDR_VAR 0 5
50926: PUSH
50927: LD_VAR 0 1
50931: PPUSH
50932: CALL_OW 25
50936: ST_TO_ADDR
// result := unit ;
50937: LD_ADDR_VAR 0 4
50941: PUSH
50942: LD_VAR 0 5
50946: ST_TO_ADDR
// end ;
50947: LD_VAR 0 4
50951: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50952: LD_INT 0
50954: PPUSH
50955: PPUSH
// if not side or not nation then
50956: LD_VAR 0 1
50960: NOT
50961: PUSH
50962: LD_VAR 0 2
50966: NOT
50967: OR
50968: IFFALSE 50972
// exit ;
50970: GO 51736
// case nation of nation_american :
50972: LD_VAR 0 2
50976: PUSH
50977: LD_INT 1
50979: DOUBLE
50980: EQUAL
50981: IFTRUE 50985
50983: GO 51199
50985: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
50986: LD_ADDR_VAR 0 4
50990: PUSH
50991: LD_INT 35
50993: PUSH
50994: LD_INT 45
50996: PUSH
50997: LD_INT 46
50999: PUSH
51000: LD_INT 47
51002: PUSH
51003: LD_INT 82
51005: PUSH
51006: LD_INT 83
51008: PUSH
51009: LD_INT 84
51011: PUSH
51012: LD_INT 85
51014: PUSH
51015: LD_INT 86
51017: PUSH
51018: LD_INT 1
51020: PUSH
51021: LD_INT 2
51023: PUSH
51024: LD_INT 6
51026: PUSH
51027: LD_INT 15
51029: PUSH
51030: LD_INT 16
51032: PUSH
51033: LD_INT 7
51035: PUSH
51036: LD_INT 12
51038: PUSH
51039: LD_INT 13
51041: PUSH
51042: LD_INT 10
51044: PUSH
51045: LD_INT 14
51047: PUSH
51048: LD_INT 20
51050: PUSH
51051: LD_INT 21
51053: PUSH
51054: LD_INT 22
51056: PUSH
51057: LD_INT 25
51059: PUSH
51060: LD_INT 32
51062: PUSH
51063: LD_INT 27
51065: PUSH
51066: LD_INT 36
51068: PUSH
51069: LD_INT 69
51071: PUSH
51072: LD_INT 39
51074: PUSH
51075: LD_INT 34
51077: PUSH
51078: LD_INT 40
51080: PUSH
51081: LD_INT 48
51083: PUSH
51084: LD_INT 49
51086: PUSH
51087: LD_INT 50
51089: PUSH
51090: LD_INT 51
51092: PUSH
51093: LD_INT 52
51095: PUSH
51096: LD_INT 53
51098: PUSH
51099: LD_INT 54
51101: PUSH
51102: LD_INT 55
51104: PUSH
51105: LD_INT 56
51107: PUSH
51108: LD_INT 57
51110: PUSH
51111: LD_INT 58
51113: PUSH
51114: LD_INT 59
51116: PUSH
51117: LD_INT 60
51119: PUSH
51120: LD_INT 61
51122: PUSH
51123: LD_INT 62
51125: PUSH
51126: LD_INT 80
51128: PUSH
51129: LD_INT 82
51131: PUSH
51132: LD_INT 83
51134: PUSH
51135: LD_INT 84
51137: PUSH
51138: LD_INT 85
51140: PUSH
51141: LD_INT 86
51143: PUSH
51144: EMPTY
51145: LIST
51146: LIST
51147: LIST
51148: LIST
51149: LIST
51150: LIST
51151: LIST
51152: LIST
51153: LIST
51154: LIST
51155: LIST
51156: LIST
51157: LIST
51158: LIST
51159: LIST
51160: LIST
51161: LIST
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: LIST
51172: LIST
51173: LIST
51174: LIST
51175: LIST
51176: LIST
51177: LIST
51178: LIST
51179: LIST
51180: LIST
51181: LIST
51182: LIST
51183: LIST
51184: LIST
51185: LIST
51186: LIST
51187: LIST
51188: LIST
51189: LIST
51190: LIST
51191: LIST
51192: LIST
51193: LIST
51194: LIST
51195: LIST
51196: ST_TO_ADDR
51197: GO 51660
51199: LD_INT 2
51201: DOUBLE
51202: EQUAL
51203: IFTRUE 51207
51205: GO 51429
51207: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
51208: LD_ADDR_VAR 0 4
51212: PUSH
51213: LD_INT 35
51215: PUSH
51216: LD_INT 45
51218: PUSH
51219: LD_INT 46
51221: PUSH
51222: LD_INT 47
51224: PUSH
51225: LD_INT 82
51227: PUSH
51228: LD_INT 83
51230: PUSH
51231: LD_INT 84
51233: PUSH
51234: LD_INT 85
51236: PUSH
51237: LD_INT 87
51239: PUSH
51240: LD_INT 70
51242: PUSH
51243: LD_INT 1
51245: PUSH
51246: LD_INT 11
51248: PUSH
51249: LD_INT 3
51251: PUSH
51252: LD_INT 4
51254: PUSH
51255: LD_INT 5
51257: PUSH
51258: LD_INT 6
51260: PUSH
51261: LD_INT 15
51263: PUSH
51264: LD_INT 18
51266: PUSH
51267: LD_INT 7
51269: PUSH
51270: LD_INT 17
51272: PUSH
51273: LD_INT 8
51275: PUSH
51276: LD_INT 20
51278: PUSH
51279: LD_INT 21
51281: PUSH
51282: LD_INT 22
51284: PUSH
51285: LD_INT 72
51287: PUSH
51288: LD_INT 26
51290: PUSH
51291: LD_INT 69
51293: PUSH
51294: LD_INT 39
51296: PUSH
51297: LD_INT 40
51299: PUSH
51300: LD_INT 41
51302: PUSH
51303: LD_INT 42
51305: PUSH
51306: LD_INT 43
51308: PUSH
51309: LD_INT 48
51311: PUSH
51312: LD_INT 49
51314: PUSH
51315: LD_INT 50
51317: PUSH
51318: LD_INT 51
51320: PUSH
51321: LD_INT 52
51323: PUSH
51324: LD_INT 53
51326: PUSH
51327: LD_INT 54
51329: PUSH
51330: LD_INT 55
51332: PUSH
51333: LD_INT 56
51335: PUSH
51336: LD_INT 60
51338: PUSH
51339: LD_INT 61
51341: PUSH
51342: LD_INT 62
51344: PUSH
51345: LD_INT 66
51347: PUSH
51348: LD_INT 67
51350: PUSH
51351: LD_INT 68
51353: PUSH
51354: LD_INT 81
51356: PUSH
51357: LD_INT 82
51359: PUSH
51360: LD_INT 83
51362: PUSH
51363: LD_INT 84
51365: PUSH
51366: LD_INT 85
51368: PUSH
51369: LD_INT 87
51371: PUSH
51372: EMPTY
51373: LIST
51374: LIST
51375: LIST
51376: LIST
51377: LIST
51378: LIST
51379: LIST
51380: LIST
51381: LIST
51382: LIST
51383: LIST
51384: LIST
51385: LIST
51386: LIST
51387: LIST
51388: LIST
51389: LIST
51390: LIST
51391: LIST
51392: LIST
51393: LIST
51394: LIST
51395: LIST
51396: LIST
51397: LIST
51398: LIST
51399: LIST
51400: LIST
51401: LIST
51402: LIST
51403: LIST
51404: LIST
51405: LIST
51406: LIST
51407: LIST
51408: LIST
51409: LIST
51410: LIST
51411: LIST
51412: LIST
51413: LIST
51414: LIST
51415: LIST
51416: LIST
51417: LIST
51418: LIST
51419: LIST
51420: LIST
51421: LIST
51422: LIST
51423: LIST
51424: LIST
51425: LIST
51426: ST_TO_ADDR
51427: GO 51660
51429: LD_INT 3
51431: DOUBLE
51432: EQUAL
51433: IFTRUE 51437
51435: GO 51659
51437: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51438: LD_ADDR_VAR 0 4
51442: PUSH
51443: LD_INT 46
51445: PUSH
51446: LD_INT 47
51448: PUSH
51449: LD_INT 1
51451: PUSH
51452: LD_INT 2
51454: PUSH
51455: LD_INT 82
51457: PUSH
51458: LD_INT 83
51460: PUSH
51461: LD_INT 84
51463: PUSH
51464: LD_INT 85
51466: PUSH
51467: LD_INT 86
51469: PUSH
51470: LD_INT 11
51472: PUSH
51473: LD_INT 9
51475: PUSH
51476: LD_INT 20
51478: PUSH
51479: LD_INT 19
51481: PUSH
51482: LD_INT 21
51484: PUSH
51485: LD_INT 24
51487: PUSH
51488: LD_INT 22
51490: PUSH
51491: LD_INT 25
51493: PUSH
51494: LD_INT 28
51496: PUSH
51497: LD_INT 29
51499: PUSH
51500: LD_INT 30
51502: PUSH
51503: LD_INT 31
51505: PUSH
51506: LD_INT 37
51508: PUSH
51509: LD_INT 38
51511: PUSH
51512: LD_INT 32
51514: PUSH
51515: LD_INT 27
51517: PUSH
51518: LD_INT 33
51520: PUSH
51521: LD_INT 69
51523: PUSH
51524: LD_INT 39
51526: PUSH
51527: LD_INT 34
51529: PUSH
51530: LD_INT 40
51532: PUSH
51533: LD_INT 71
51535: PUSH
51536: LD_INT 23
51538: PUSH
51539: LD_INT 44
51541: PUSH
51542: LD_INT 48
51544: PUSH
51545: LD_INT 49
51547: PUSH
51548: LD_INT 50
51550: PUSH
51551: LD_INT 51
51553: PUSH
51554: LD_INT 52
51556: PUSH
51557: LD_INT 53
51559: PUSH
51560: LD_INT 54
51562: PUSH
51563: LD_INT 55
51565: PUSH
51566: LD_INT 56
51568: PUSH
51569: LD_INT 57
51571: PUSH
51572: LD_INT 58
51574: PUSH
51575: LD_INT 59
51577: PUSH
51578: LD_INT 63
51580: PUSH
51581: LD_INT 64
51583: PUSH
51584: LD_INT 65
51586: PUSH
51587: LD_INT 82
51589: PUSH
51590: LD_INT 83
51592: PUSH
51593: LD_INT 84
51595: PUSH
51596: LD_INT 85
51598: PUSH
51599: LD_INT 86
51601: PUSH
51602: EMPTY
51603: LIST
51604: LIST
51605: LIST
51606: LIST
51607: LIST
51608: LIST
51609: LIST
51610: LIST
51611: LIST
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: LIST
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: LIST
51622: LIST
51623: LIST
51624: LIST
51625: LIST
51626: LIST
51627: LIST
51628: LIST
51629: LIST
51630: LIST
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: LIST
51636: LIST
51637: LIST
51638: LIST
51639: LIST
51640: LIST
51641: LIST
51642: LIST
51643: LIST
51644: LIST
51645: LIST
51646: LIST
51647: LIST
51648: LIST
51649: LIST
51650: LIST
51651: LIST
51652: LIST
51653: LIST
51654: LIST
51655: LIST
51656: ST_TO_ADDR
51657: GO 51660
51659: POP
// if state > - 1 and state < 3 then
51660: LD_VAR 0 3
51664: PUSH
51665: LD_INT 1
51667: NEG
51668: GREATER
51669: PUSH
51670: LD_VAR 0 3
51674: PUSH
51675: LD_INT 3
51677: LESS
51678: AND
51679: IFFALSE 51736
// for i in result do
51681: LD_ADDR_VAR 0 5
51685: PUSH
51686: LD_VAR 0 4
51690: PUSH
51691: FOR_IN
51692: IFFALSE 51734
// if GetTech ( i , side ) <> state then
51694: LD_VAR 0 5
51698: PPUSH
51699: LD_VAR 0 1
51703: PPUSH
51704: CALL_OW 321
51708: PUSH
51709: LD_VAR 0 3
51713: NONEQUAL
51714: IFFALSE 51732
// result := result diff i ;
51716: LD_ADDR_VAR 0 4
51720: PUSH
51721: LD_VAR 0 4
51725: PUSH
51726: LD_VAR 0 5
51730: DIFF
51731: ST_TO_ADDR
51732: GO 51691
51734: POP
51735: POP
// end ;
51736: LD_VAR 0 4
51740: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51741: LD_INT 0
51743: PPUSH
51744: PPUSH
51745: PPUSH
// result := true ;
51746: LD_ADDR_VAR 0 3
51750: PUSH
51751: LD_INT 1
51753: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51754: LD_ADDR_VAR 0 5
51758: PUSH
51759: LD_VAR 0 2
51763: PPUSH
51764: CALL_OW 480
51768: ST_TO_ADDR
// if not tmp then
51769: LD_VAR 0 5
51773: NOT
51774: IFFALSE 51778
// exit ;
51776: GO 51827
// for i in tmp do
51778: LD_ADDR_VAR 0 4
51782: PUSH
51783: LD_VAR 0 5
51787: PUSH
51788: FOR_IN
51789: IFFALSE 51825
// if GetTech ( i , side ) <> state_researched then
51791: LD_VAR 0 4
51795: PPUSH
51796: LD_VAR 0 1
51800: PPUSH
51801: CALL_OW 321
51805: PUSH
51806: LD_INT 2
51808: NONEQUAL
51809: IFFALSE 51823
// begin result := false ;
51811: LD_ADDR_VAR 0 3
51815: PUSH
51816: LD_INT 0
51818: ST_TO_ADDR
// exit ;
51819: POP
51820: POP
51821: GO 51827
// end ;
51823: GO 51788
51825: POP
51826: POP
// end ;
51827: LD_VAR 0 3
51831: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51832: LD_INT 0
51834: PPUSH
51835: PPUSH
51836: PPUSH
51837: PPUSH
51838: PPUSH
51839: PPUSH
51840: PPUSH
51841: PPUSH
51842: PPUSH
51843: PPUSH
51844: PPUSH
51845: PPUSH
51846: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51847: LD_VAR 0 1
51851: NOT
51852: PUSH
51853: LD_VAR 0 1
51857: PPUSH
51858: CALL_OW 257
51862: PUSH
51863: LD_INT 9
51865: NONEQUAL
51866: OR
51867: IFFALSE 51871
// exit ;
51869: GO 52444
// side := GetSide ( unit ) ;
51871: LD_ADDR_VAR 0 9
51875: PUSH
51876: LD_VAR 0 1
51880: PPUSH
51881: CALL_OW 255
51885: ST_TO_ADDR
// tech_space := tech_spacanom ;
51886: LD_ADDR_VAR 0 12
51890: PUSH
51891: LD_INT 29
51893: ST_TO_ADDR
// tech_time := tech_taurad ;
51894: LD_ADDR_VAR 0 13
51898: PUSH
51899: LD_INT 28
51901: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51902: LD_ADDR_VAR 0 11
51906: PUSH
51907: LD_VAR 0 1
51911: PPUSH
51912: CALL_OW 310
51916: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51917: LD_VAR 0 11
51921: PPUSH
51922: CALL_OW 247
51926: PUSH
51927: LD_INT 2
51929: EQUAL
51930: IFFALSE 51934
// exit ;
51932: GO 52444
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51934: LD_ADDR_VAR 0 8
51938: PUSH
51939: LD_INT 81
51941: PUSH
51942: LD_VAR 0 9
51946: PUSH
51947: EMPTY
51948: LIST
51949: LIST
51950: PUSH
51951: LD_INT 3
51953: PUSH
51954: LD_INT 21
51956: PUSH
51957: LD_INT 3
51959: PUSH
51960: EMPTY
51961: LIST
51962: LIST
51963: PUSH
51964: EMPTY
51965: LIST
51966: LIST
51967: PUSH
51968: EMPTY
51969: LIST
51970: LIST
51971: PPUSH
51972: CALL_OW 69
51976: ST_TO_ADDR
// if not tmp then
51977: LD_VAR 0 8
51981: NOT
51982: IFFALSE 51986
// exit ;
51984: GO 52444
// if in_unit then
51986: LD_VAR 0 11
51990: IFFALSE 52014
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51992: LD_ADDR_VAR 0 10
51996: PUSH
51997: LD_VAR 0 8
52001: PPUSH
52002: LD_VAR 0 11
52006: PPUSH
52007: CALL_OW 74
52011: ST_TO_ADDR
52012: GO 52034
// enemy := NearestUnitToUnit ( tmp , unit ) ;
52014: LD_ADDR_VAR 0 10
52018: PUSH
52019: LD_VAR 0 8
52023: PPUSH
52024: LD_VAR 0 1
52028: PPUSH
52029: CALL_OW 74
52033: ST_TO_ADDR
// if not enemy then
52034: LD_VAR 0 10
52038: NOT
52039: IFFALSE 52043
// exit ;
52041: GO 52444
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
52043: LD_VAR 0 11
52047: PUSH
52048: LD_VAR 0 11
52052: PPUSH
52053: LD_VAR 0 10
52057: PPUSH
52058: CALL_OW 296
52062: PUSH
52063: LD_INT 13
52065: GREATER
52066: AND
52067: PUSH
52068: LD_VAR 0 1
52072: PPUSH
52073: LD_VAR 0 10
52077: PPUSH
52078: CALL_OW 296
52082: PUSH
52083: LD_INT 12
52085: GREATER
52086: OR
52087: IFFALSE 52091
// exit ;
52089: GO 52444
// missile := [ 1 ] ;
52091: LD_ADDR_VAR 0 14
52095: PUSH
52096: LD_INT 1
52098: PUSH
52099: EMPTY
52100: LIST
52101: ST_TO_ADDR
// if Researched ( side , tech_space ) then
52102: LD_VAR 0 9
52106: PPUSH
52107: LD_VAR 0 12
52111: PPUSH
52112: CALL_OW 325
52116: IFFALSE 52145
// missile := Insert ( missile , missile + 1 , 2 ) ;
52118: LD_ADDR_VAR 0 14
52122: PUSH
52123: LD_VAR 0 14
52127: PPUSH
52128: LD_VAR 0 14
52132: PUSH
52133: LD_INT 1
52135: PLUS
52136: PPUSH
52137: LD_INT 2
52139: PPUSH
52140: CALL_OW 2
52144: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52145: LD_VAR 0 9
52149: PPUSH
52150: LD_VAR 0 13
52154: PPUSH
52155: CALL_OW 325
52159: PUSH
52160: LD_VAR 0 10
52164: PPUSH
52165: CALL_OW 255
52169: PPUSH
52170: LD_VAR 0 13
52174: PPUSH
52175: CALL_OW 325
52179: NOT
52180: AND
52181: IFFALSE 52210
// missile := Insert ( missile , missile + 1 , 3 ) ;
52183: LD_ADDR_VAR 0 14
52187: PUSH
52188: LD_VAR 0 14
52192: PPUSH
52193: LD_VAR 0 14
52197: PUSH
52198: LD_INT 1
52200: PLUS
52201: PPUSH
52202: LD_INT 3
52204: PPUSH
52205: CALL_OW 2
52209: ST_TO_ADDR
// if missile < 2 then
52210: LD_VAR 0 14
52214: PUSH
52215: LD_INT 2
52217: LESS
52218: IFFALSE 52222
// exit ;
52220: GO 52444
// x := GetX ( enemy ) ;
52222: LD_ADDR_VAR 0 4
52226: PUSH
52227: LD_VAR 0 10
52231: PPUSH
52232: CALL_OW 250
52236: ST_TO_ADDR
// y := GetY ( enemy ) ;
52237: LD_ADDR_VAR 0 5
52241: PUSH
52242: LD_VAR 0 10
52246: PPUSH
52247: CALL_OW 251
52251: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52252: LD_ADDR_VAR 0 6
52256: PUSH
52257: LD_VAR 0 4
52261: PUSH
52262: LD_INT 1
52264: NEG
52265: PPUSH
52266: LD_INT 1
52268: PPUSH
52269: CALL_OW 12
52273: PLUS
52274: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52275: LD_ADDR_VAR 0 7
52279: PUSH
52280: LD_VAR 0 5
52284: PUSH
52285: LD_INT 1
52287: NEG
52288: PPUSH
52289: LD_INT 1
52291: PPUSH
52292: CALL_OW 12
52296: PLUS
52297: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52298: LD_VAR 0 6
52302: PPUSH
52303: LD_VAR 0 7
52307: PPUSH
52308: CALL_OW 488
52312: NOT
52313: IFFALSE 52335
// begin _x := x ;
52315: LD_ADDR_VAR 0 6
52319: PUSH
52320: LD_VAR 0 4
52324: ST_TO_ADDR
// _y := y ;
52325: LD_ADDR_VAR 0 7
52329: PUSH
52330: LD_VAR 0 5
52334: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52335: LD_ADDR_VAR 0 3
52339: PUSH
52340: LD_INT 1
52342: PPUSH
52343: LD_VAR 0 14
52347: PPUSH
52348: CALL_OW 12
52352: ST_TO_ADDR
// case i of 1 :
52353: LD_VAR 0 3
52357: PUSH
52358: LD_INT 1
52360: DOUBLE
52361: EQUAL
52362: IFTRUE 52366
52364: GO 52383
52366: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52367: LD_VAR 0 1
52371: PPUSH
52372: LD_VAR 0 10
52376: PPUSH
52377: CALL_OW 115
52381: GO 52444
52383: LD_INT 2
52385: DOUBLE
52386: EQUAL
52387: IFTRUE 52391
52389: GO 52413
52391: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52392: LD_VAR 0 1
52396: PPUSH
52397: LD_VAR 0 6
52401: PPUSH
52402: LD_VAR 0 7
52406: PPUSH
52407: CALL_OW 153
52411: GO 52444
52413: LD_INT 3
52415: DOUBLE
52416: EQUAL
52417: IFTRUE 52421
52419: GO 52443
52421: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52422: LD_VAR 0 1
52426: PPUSH
52427: LD_VAR 0 6
52431: PPUSH
52432: LD_VAR 0 7
52436: PPUSH
52437: CALL_OW 154
52441: GO 52444
52443: POP
// end ;
52444: LD_VAR 0 2
52448: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52449: LD_INT 0
52451: PPUSH
52452: PPUSH
52453: PPUSH
52454: PPUSH
52455: PPUSH
52456: PPUSH
// if not unit or not building then
52457: LD_VAR 0 1
52461: NOT
52462: PUSH
52463: LD_VAR 0 2
52467: NOT
52468: OR
52469: IFFALSE 52473
// exit ;
52471: GO 52631
// x := GetX ( building ) ;
52473: LD_ADDR_VAR 0 5
52477: PUSH
52478: LD_VAR 0 2
52482: PPUSH
52483: CALL_OW 250
52487: ST_TO_ADDR
// y := GetY ( building ) ;
52488: LD_ADDR_VAR 0 6
52492: PUSH
52493: LD_VAR 0 2
52497: PPUSH
52498: CALL_OW 251
52502: ST_TO_ADDR
// for i = 0 to 5 do
52503: LD_ADDR_VAR 0 4
52507: PUSH
52508: DOUBLE
52509: LD_INT 0
52511: DEC
52512: ST_TO_ADDR
52513: LD_INT 5
52515: PUSH
52516: FOR_TO
52517: IFFALSE 52629
// begin _x := ShiftX ( x , i , 3 ) ;
52519: LD_ADDR_VAR 0 7
52523: PUSH
52524: LD_VAR 0 5
52528: PPUSH
52529: LD_VAR 0 4
52533: PPUSH
52534: LD_INT 3
52536: PPUSH
52537: CALL_OW 272
52541: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52542: LD_ADDR_VAR 0 8
52546: PUSH
52547: LD_VAR 0 6
52551: PPUSH
52552: LD_VAR 0 4
52556: PPUSH
52557: LD_INT 3
52559: PPUSH
52560: CALL_OW 273
52564: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52565: LD_VAR 0 7
52569: PPUSH
52570: LD_VAR 0 8
52574: PPUSH
52575: CALL_OW 488
52579: NOT
52580: IFFALSE 52584
// continue ;
52582: GO 52516
// if HexInfo ( _x , _y ) = 0 then
52584: LD_VAR 0 7
52588: PPUSH
52589: LD_VAR 0 8
52593: PPUSH
52594: CALL_OW 428
52598: PUSH
52599: LD_INT 0
52601: EQUAL
52602: IFFALSE 52627
// begin ComMoveXY ( unit , _x , _y ) ;
52604: LD_VAR 0 1
52608: PPUSH
52609: LD_VAR 0 7
52613: PPUSH
52614: LD_VAR 0 8
52618: PPUSH
52619: CALL_OW 111
// exit ;
52623: POP
52624: POP
52625: GO 52631
// end ; end ;
52627: GO 52516
52629: POP
52630: POP
// end ;
52631: LD_VAR 0 3
52635: RET
// export function ScanBase ( side , base_area ) ; begin
52636: LD_INT 0
52638: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52639: LD_ADDR_VAR 0 3
52643: PUSH
52644: LD_VAR 0 2
52648: PPUSH
52649: LD_INT 81
52651: PUSH
52652: LD_VAR 0 1
52656: PUSH
52657: EMPTY
52658: LIST
52659: LIST
52660: PPUSH
52661: CALL_OW 70
52665: ST_TO_ADDR
// end ;
52666: LD_VAR 0 3
52670: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
52671: LD_INT 0
52673: PPUSH
52674: PPUSH
52675: PPUSH
52676: PPUSH
// result := false ;
52677: LD_ADDR_VAR 0 2
52681: PUSH
52682: LD_INT 0
52684: ST_TO_ADDR
// side := GetSide ( unit ) ;
52685: LD_ADDR_VAR 0 3
52689: PUSH
52690: LD_VAR 0 1
52694: PPUSH
52695: CALL_OW 255
52699: ST_TO_ADDR
// nat := GetNation ( unit ) ;
52700: LD_ADDR_VAR 0 4
52704: PUSH
52705: LD_VAR 0 1
52709: PPUSH
52710: CALL_OW 248
52714: ST_TO_ADDR
// case nat of 1 :
52715: LD_VAR 0 4
52719: PUSH
52720: LD_INT 1
52722: DOUBLE
52723: EQUAL
52724: IFTRUE 52728
52726: GO 52739
52728: POP
// tech := tech_lassight ; 2 :
52729: LD_ADDR_VAR 0 5
52733: PUSH
52734: LD_INT 12
52736: ST_TO_ADDR
52737: GO 52778
52739: LD_INT 2
52741: DOUBLE
52742: EQUAL
52743: IFTRUE 52747
52745: GO 52758
52747: POP
// tech := tech_mortar ; 3 :
52748: LD_ADDR_VAR 0 5
52752: PUSH
52753: LD_INT 41
52755: ST_TO_ADDR
52756: GO 52778
52758: LD_INT 3
52760: DOUBLE
52761: EQUAL
52762: IFTRUE 52766
52764: GO 52777
52766: POP
// tech := tech_bazooka ; end ;
52767: LD_ADDR_VAR 0 5
52771: PUSH
52772: LD_INT 44
52774: ST_TO_ADDR
52775: GO 52778
52777: POP
// if Researched ( side , tech ) then
52778: LD_VAR 0 3
52782: PPUSH
52783: LD_VAR 0 5
52787: PPUSH
52788: CALL_OW 325
52792: IFFALSE 52819
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
52794: LD_ADDR_VAR 0 2
52798: PUSH
52799: LD_INT 5
52801: PUSH
52802: LD_INT 8
52804: PUSH
52805: LD_INT 9
52807: PUSH
52808: EMPTY
52809: LIST
52810: LIST
52811: LIST
52812: PUSH
52813: LD_VAR 0 4
52817: ARRAY
52818: ST_TO_ADDR
// end ;
52819: LD_VAR 0 2
52823: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
52824: LD_INT 0
52826: PPUSH
52827: PPUSH
52828: PPUSH
// if not mines then
52829: LD_VAR 0 2
52833: NOT
52834: IFFALSE 52838
// exit ;
52836: GO 52982
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52838: LD_ADDR_VAR 0 5
52842: PUSH
52843: LD_INT 81
52845: PUSH
52846: LD_VAR 0 1
52850: PUSH
52851: EMPTY
52852: LIST
52853: LIST
52854: PUSH
52855: LD_INT 3
52857: PUSH
52858: LD_INT 21
52860: PUSH
52861: LD_INT 3
52863: PUSH
52864: EMPTY
52865: LIST
52866: LIST
52867: PUSH
52868: EMPTY
52869: LIST
52870: LIST
52871: PUSH
52872: EMPTY
52873: LIST
52874: LIST
52875: PPUSH
52876: CALL_OW 69
52880: ST_TO_ADDR
// for i in mines do
52881: LD_ADDR_VAR 0 4
52885: PUSH
52886: LD_VAR 0 2
52890: PUSH
52891: FOR_IN
52892: IFFALSE 52980
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
52894: LD_VAR 0 4
52898: PUSH
52899: LD_INT 1
52901: ARRAY
52902: PPUSH
52903: LD_VAR 0 4
52907: PUSH
52908: LD_INT 2
52910: ARRAY
52911: PPUSH
52912: CALL_OW 458
52916: NOT
52917: IFFALSE 52921
// continue ;
52919: GO 52891
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
52921: LD_VAR 0 4
52925: PUSH
52926: LD_INT 1
52928: ARRAY
52929: PPUSH
52930: LD_VAR 0 4
52934: PUSH
52935: LD_INT 2
52937: ARRAY
52938: PPUSH
52939: CALL_OW 428
52943: PUSH
52944: LD_VAR 0 5
52948: IN
52949: IFFALSE 52978
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
52951: LD_VAR 0 4
52955: PUSH
52956: LD_INT 1
52958: ARRAY
52959: PPUSH
52960: LD_VAR 0 4
52964: PUSH
52965: LD_INT 2
52967: ARRAY
52968: PPUSH
52969: LD_VAR 0 1
52973: PPUSH
52974: CALL_OW 456
// end ;
52978: GO 52891
52980: POP
52981: POP
// end ;
52982: LD_VAR 0 3
52986: RET
// export function Count ( array ) ; var i ; begin
52987: LD_INT 0
52989: PPUSH
52990: PPUSH
// result := 0 ;
52991: LD_ADDR_VAR 0 2
52995: PUSH
52996: LD_INT 0
52998: ST_TO_ADDR
// for i in array do
52999: LD_ADDR_VAR 0 3
53003: PUSH
53004: LD_VAR 0 1
53008: PUSH
53009: FOR_IN
53010: IFFALSE 53034
// if i then
53012: LD_VAR 0 3
53016: IFFALSE 53032
// result := result + 1 ;
53018: LD_ADDR_VAR 0 2
53022: PUSH
53023: LD_VAR 0 2
53027: PUSH
53028: LD_INT 1
53030: PLUS
53031: ST_TO_ADDR
53032: GO 53009
53034: POP
53035: POP
// end ;
53036: LD_VAR 0 2
53040: RET
// export function IsEmpty ( building ) ; begin
53041: LD_INT 0
53043: PPUSH
// if not building then
53044: LD_VAR 0 1
53048: NOT
53049: IFFALSE 53053
// exit ;
53051: GO 53096
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53053: LD_ADDR_VAR 0 2
53057: PUSH
53058: LD_VAR 0 1
53062: PUSH
53063: LD_INT 22
53065: PUSH
53066: LD_VAR 0 1
53070: PPUSH
53071: CALL_OW 255
53075: PUSH
53076: EMPTY
53077: LIST
53078: LIST
53079: PUSH
53080: LD_INT 58
53082: PUSH
53083: EMPTY
53084: LIST
53085: PUSH
53086: EMPTY
53087: LIST
53088: LIST
53089: PPUSH
53090: CALL_OW 69
53094: IN
53095: ST_TO_ADDR
// end ;
53096: LD_VAR 0 2
53100: RET
// export function IsNotFull ( building ) ; begin
53101: LD_INT 0
53103: PPUSH
// if not building then
53104: LD_VAR 0 1
53108: NOT
53109: IFFALSE 53113
// exit ;
53111: GO 53132
// result := UnitsInside ( building ) < 6 ;
53113: LD_ADDR_VAR 0 2
53117: PUSH
53118: LD_VAR 0 1
53122: PPUSH
53123: CALL_OW 313
53127: PUSH
53128: LD_INT 6
53130: LESS
53131: ST_TO_ADDR
// end ;
53132: LD_VAR 0 2
53136: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53137: LD_INT 0
53139: PPUSH
53140: PPUSH
53141: PPUSH
53142: PPUSH
// tmp := [ ] ;
53143: LD_ADDR_VAR 0 3
53147: PUSH
53148: EMPTY
53149: ST_TO_ADDR
// list := [ ] ;
53150: LD_ADDR_VAR 0 5
53154: PUSH
53155: EMPTY
53156: ST_TO_ADDR
// for i = 16 to 25 do
53157: LD_ADDR_VAR 0 4
53161: PUSH
53162: DOUBLE
53163: LD_INT 16
53165: DEC
53166: ST_TO_ADDR
53167: LD_INT 25
53169: PUSH
53170: FOR_TO
53171: IFFALSE 53244
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53173: LD_ADDR_VAR 0 3
53177: PUSH
53178: LD_VAR 0 3
53182: PUSH
53183: LD_INT 22
53185: PUSH
53186: LD_VAR 0 1
53190: PPUSH
53191: CALL_OW 255
53195: PUSH
53196: EMPTY
53197: LIST
53198: LIST
53199: PUSH
53200: LD_INT 91
53202: PUSH
53203: LD_VAR 0 1
53207: PUSH
53208: LD_INT 6
53210: PUSH
53211: EMPTY
53212: LIST
53213: LIST
53214: LIST
53215: PUSH
53216: LD_INT 30
53218: PUSH
53219: LD_VAR 0 4
53223: PUSH
53224: EMPTY
53225: LIST
53226: LIST
53227: PUSH
53228: EMPTY
53229: LIST
53230: LIST
53231: LIST
53232: PUSH
53233: EMPTY
53234: LIST
53235: PPUSH
53236: CALL_OW 69
53240: ADD
53241: ST_TO_ADDR
53242: GO 53170
53244: POP
53245: POP
// for i = 1 to tmp do
53246: LD_ADDR_VAR 0 4
53250: PUSH
53251: DOUBLE
53252: LD_INT 1
53254: DEC
53255: ST_TO_ADDR
53256: LD_VAR 0 3
53260: PUSH
53261: FOR_TO
53262: IFFALSE 53350
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53264: LD_ADDR_VAR 0 5
53268: PUSH
53269: LD_VAR 0 5
53273: PUSH
53274: LD_VAR 0 3
53278: PUSH
53279: LD_VAR 0 4
53283: ARRAY
53284: PPUSH
53285: CALL_OW 266
53289: PUSH
53290: LD_VAR 0 3
53294: PUSH
53295: LD_VAR 0 4
53299: ARRAY
53300: PPUSH
53301: CALL_OW 250
53305: PUSH
53306: LD_VAR 0 3
53310: PUSH
53311: LD_VAR 0 4
53315: ARRAY
53316: PPUSH
53317: CALL_OW 251
53321: PUSH
53322: LD_VAR 0 3
53326: PUSH
53327: LD_VAR 0 4
53331: ARRAY
53332: PPUSH
53333: CALL_OW 254
53337: PUSH
53338: EMPTY
53339: LIST
53340: LIST
53341: LIST
53342: LIST
53343: PUSH
53344: EMPTY
53345: LIST
53346: ADD
53347: ST_TO_ADDR
53348: GO 53261
53350: POP
53351: POP
// result := list ;
53352: LD_ADDR_VAR 0 2
53356: PUSH
53357: LD_VAR 0 5
53361: ST_TO_ADDR
// end ;
53362: LD_VAR 0 2
53366: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53367: LD_INT 0
53369: PPUSH
53370: PPUSH
53371: PPUSH
53372: PPUSH
53373: PPUSH
53374: PPUSH
53375: PPUSH
// if not factory then
53376: LD_VAR 0 1
53380: NOT
53381: IFFALSE 53385
// exit ;
53383: GO 53978
// if control = control_apeman then
53385: LD_VAR 0 4
53389: PUSH
53390: LD_INT 5
53392: EQUAL
53393: IFFALSE 53502
// begin tmp := UnitsInside ( factory ) ;
53395: LD_ADDR_VAR 0 8
53399: PUSH
53400: LD_VAR 0 1
53404: PPUSH
53405: CALL_OW 313
53409: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53410: LD_VAR 0 8
53414: PPUSH
53415: LD_INT 25
53417: PUSH
53418: LD_INT 12
53420: PUSH
53421: EMPTY
53422: LIST
53423: LIST
53424: PPUSH
53425: CALL_OW 72
53429: NOT
53430: IFFALSE 53440
// control := control_manual ;
53432: LD_ADDR_VAR 0 4
53436: PUSH
53437: LD_INT 1
53439: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53440: LD_ADDR_VAR 0 8
53444: PUSH
53445: LD_VAR 0 1
53449: PPUSH
53450: CALL 53137 0 1
53454: ST_TO_ADDR
// if tmp then
53455: LD_VAR 0 8
53459: IFFALSE 53502
// begin for i in tmp do
53461: LD_ADDR_VAR 0 7
53465: PUSH
53466: LD_VAR 0 8
53470: PUSH
53471: FOR_IN
53472: IFFALSE 53500
// if i [ 1 ] = b_ext_radio then
53474: LD_VAR 0 7
53478: PUSH
53479: LD_INT 1
53481: ARRAY
53482: PUSH
53483: LD_INT 22
53485: EQUAL
53486: IFFALSE 53498
// begin control := control_remote ;
53488: LD_ADDR_VAR 0 4
53492: PUSH
53493: LD_INT 2
53495: ST_TO_ADDR
// break ;
53496: GO 53500
// end ;
53498: GO 53471
53500: POP
53501: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53502: LD_VAR 0 1
53506: PPUSH
53507: LD_VAR 0 2
53511: PPUSH
53512: LD_VAR 0 3
53516: PPUSH
53517: LD_VAR 0 4
53521: PPUSH
53522: LD_VAR 0 5
53526: PPUSH
53527: CALL_OW 448
53531: IFFALSE 53566
// begin result := [ chassis , engine , control , weapon ] ;
53533: LD_ADDR_VAR 0 6
53537: PUSH
53538: LD_VAR 0 2
53542: PUSH
53543: LD_VAR 0 3
53547: PUSH
53548: LD_VAR 0 4
53552: PUSH
53553: LD_VAR 0 5
53557: PUSH
53558: EMPTY
53559: LIST
53560: LIST
53561: LIST
53562: LIST
53563: ST_TO_ADDR
// exit ;
53564: GO 53978
// end ; _chassis := AvailableChassisList ( factory ) ;
53566: LD_ADDR_VAR 0 9
53570: PUSH
53571: LD_VAR 0 1
53575: PPUSH
53576: CALL_OW 475
53580: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53581: LD_ADDR_VAR 0 11
53585: PUSH
53586: LD_VAR 0 1
53590: PPUSH
53591: CALL_OW 476
53595: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53596: LD_ADDR_VAR 0 12
53600: PUSH
53601: LD_VAR 0 1
53605: PPUSH
53606: CALL_OW 477
53610: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
53611: LD_ADDR_VAR 0 10
53615: PUSH
53616: LD_VAR 0 1
53620: PPUSH
53621: CALL_OW 478
53625: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
53626: LD_VAR 0 9
53630: NOT
53631: PUSH
53632: LD_VAR 0 11
53636: NOT
53637: OR
53638: PUSH
53639: LD_VAR 0 12
53643: NOT
53644: OR
53645: PUSH
53646: LD_VAR 0 10
53650: NOT
53651: OR
53652: IFFALSE 53687
// begin result := [ chassis , engine , control , weapon ] ;
53654: LD_ADDR_VAR 0 6
53658: PUSH
53659: LD_VAR 0 2
53663: PUSH
53664: LD_VAR 0 3
53668: PUSH
53669: LD_VAR 0 4
53673: PUSH
53674: LD_VAR 0 5
53678: PUSH
53679: EMPTY
53680: LIST
53681: LIST
53682: LIST
53683: LIST
53684: ST_TO_ADDR
// exit ;
53685: GO 53978
// end ; if not chassis in _chassis then
53687: LD_VAR 0 2
53691: PUSH
53692: LD_VAR 0 9
53696: IN
53697: NOT
53698: IFFALSE 53724
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
53700: LD_ADDR_VAR 0 2
53704: PUSH
53705: LD_VAR 0 9
53709: PUSH
53710: LD_INT 1
53712: PPUSH
53713: LD_VAR 0 9
53717: PPUSH
53718: CALL_OW 12
53722: ARRAY
53723: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
53724: LD_VAR 0 2
53728: PPUSH
53729: LD_VAR 0 3
53733: PPUSH
53734: CALL 53983 0 2
53738: NOT
53739: IFFALSE 53798
// repeat engine := _engine [ 1 ] ;
53741: LD_ADDR_VAR 0 3
53745: PUSH
53746: LD_VAR 0 11
53750: PUSH
53751: LD_INT 1
53753: ARRAY
53754: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
53755: LD_ADDR_VAR 0 11
53759: PUSH
53760: LD_VAR 0 11
53764: PPUSH
53765: LD_INT 1
53767: PPUSH
53768: CALL_OW 3
53772: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
53773: LD_VAR 0 2
53777: PPUSH
53778: LD_VAR 0 3
53782: PPUSH
53783: CALL 53983 0 2
53787: PUSH
53788: LD_VAR 0 11
53792: PUSH
53793: EMPTY
53794: EQUAL
53795: OR
53796: IFFALSE 53741
// if not control in _control then
53798: LD_VAR 0 4
53802: PUSH
53803: LD_VAR 0 12
53807: IN
53808: NOT
53809: IFFALSE 53835
// control := _control [ rand ( 1 , _control ) ] ;
53811: LD_ADDR_VAR 0 4
53815: PUSH
53816: LD_VAR 0 12
53820: PUSH
53821: LD_INT 1
53823: PPUSH
53824: LD_VAR 0 12
53828: PPUSH
53829: CALL_OW 12
53833: ARRAY
53834: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
53835: LD_VAR 0 2
53839: PPUSH
53840: LD_VAR 0 5
53844: PPUSH
53845: CALL 54203 0 2
53849: NOT
53850: IFFALSE 53909
// repeat weapon := _weapon [ 1 ] ;
53852: LD_ADDR_VAR 0 5
53856: PUSH
53857: LD_VAR 0 10
53861: PUSH
53862: LD_INT 1
53864: ARRAY
53865: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
53866: LD_ADDR_VAR 0 10
53870: PUSH
53871: LD_VAR 0 10
53875: PPUSH
53876: LD_INT 1
53878: PPUSH
53879: CALL_OW 3
53883: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
53884: LD_VAR 0 2
53888: PPUSH
53889: LD_VAR 0 5
53893: PPUSH
53894: CALL 54203 0 2
53898: PUSH
53899: LD_VAR 0 10
53903: PUSH
53904: EMPTY
53905: EQUAL
53906: OR
53907: IFFALSE 53852
// result := [ ] ;
53909: LD_ADDR_VAR 0 6
53913: PUSH
53914: EMPTY
53915: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53916: LD_VAR 0 1
53920: PPUSH
53921: LD_VAR 0 2
53925: PPUSH
53926: LD_VAR 0 3
53930: PPUSH
53931: LD_VAR 0 4
53935: PPUSH
53936: LD_VAR 0 5
53940: PPUSH
53941: CALL_OW 448
53945: IFFALSE 53978
// result := [ chassis , engine , control , weapon ] ;
53947: LD_ADDR_VAR 0 6
53951: PUSH
53952: LD_VAR 0 2
53956: PUSH
53957: LD_VAR 0 3
53961: PUSH
53962: LD_VAR 0 4
53966: PUSH
53967: LD_VAR 0 5
53971: PUSH
53972: EMPTY
53973: LIST
53974: LIST
53975: LIST
53976: LIST
53977: ST_TO_ADDR
// end ;
53978: LD_VAR 0 6
53982: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
53983: LD_INT 0
53985: PPUSH
// if not chassis or not engine then
53986: LD_VAR 0 1
53990: NOT
53991: PUSH
53992: LD_VAR 0 2
53996: NOT
53997: OR
53998: IFFALSE 54002
// exit ;
54000: GO 54198
// case engine of engine_solar :
54002: LD_VAR 0 2
54006: PUSH
54007: LD_INT 2
54009: DOUBLE
54010: EQUAL
54011: IFTRUE 54015
54013: GO 54053
54015: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
54016: LD_ADDR_VAR 0 3
54020: PUSH
54021: LD_INT 11
54023: PUSH
54024: LD_INT 12
54026: PUSH
54027: LD_INT 13
54029: PUSH
54030: LD_INT 14
54032: PUSH
54033: LD_INT 1
54035: PUSH
54036: LD_INT 2
54038: PUSH
54039: LD_INT 3
54041: PUSH
54042: EMPTY
54043: LIST
54044: LIST
54045: LIST
54046: LIST
54047: LIST
54048: LIST
54049: LIST
54050: ST_TO_ADDR
54051: GO 54182
54053: LD_INT 1
54055: DOUBLE
54056: EQUAL
54057: IFTRUE 54061
54059: GO 54123
54061: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54062: LD_ADDR_VAR 0 3
54066: PUSH
54067: LD_INT 11
54069: PUSH
54070: LD_INT 12
54072: PUSH
54073: LD_INT 13
54075: PUSH
54076: LD_INT 14
54078: PUSH
54079: LD_INT 1
54081: PUSH
54082: LD_INT 2
54084: PUSH
54085: LD_INT 3
54087: PUSH
54088: LD_INT 4
54090: PUSH
54091: LD_INT 5
54093: PUSH
54094: LD_INT 21
54096: PUSH
54097: LD_INT 23
54099: PUSH
54100: LD_INT 22
54102: PUSH
54103: LD_INT 24
54105: PUSH
54106: EMPTY
54107: LIST
54108: LIST
54109: LIST
54110: LIST
54111: LIST
54112: LIST
54113: LIST
54114: LIST
54115: LIST
54116: LIST
54117: LIST
54118: LIST
54119: LIST
54120: ST_TO_ADDR
54121: GO 54182
54123: LD_INT 3
54125: DOUBLE
54126: EQUAL
54127: IFTRUE 54131
54129: GO 54181
54131: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54132: LD_ADDR_VAR 0 3
54136: PUSH
54137: LD_INT 13
54139: PUSH
54140: LD_INT 14
54142: PUSH
54143: LD_INT 2
54145: PUSH
54146: LD_INT 3
54148: PUSH
54149: LD_INT 4
54151: PUSH
54152: LD_INT 5
54154: PUSH
54155: LD_INT 21
54157: PUSH
54158: LD_INT 22
54160: PUSH
54161: LD_INT 23
54163: PUSH
54164: LD_INT 24
54166: PUSH
54167: EMPTY
54168: LIST
54169: LIST
54170: LIST
54171: LIST
54172: LIST
54173: LIST
54174: LIST
54175: LIST
54176: LIST
54177: LIST
54178: ST_TO_ADDR
54179: GO 54182
54181: POP
// result := ( chassis in result ) ;
54182: LD_ADDR_VAR 0 3
54186: PUSH
54187: LD_VAR 0 1
54191: PUSH
54192: LD_VAR 0 3
54196: IN
54197: ST_TO_ADDR
// end ;
54198: LD_VAR 0 3
54202: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54203: LD_INT 0
54205: PPUSH
// if not chassis or not weapon then
54206: LD_VAR 0 1
54210: NOT
54211: PUSH
54212: LD_VAR 0 2
54216: NOT
54217: OR
54218: IFFALSE 54222
// exit ;
54220: GO 55248
// case weapon of us_machine_gun :
54222: LD_VAR 0 2
54226: PUSH
54227: LD_INT 2
54229: DOUBLE
54230: EQUAL
54231: IFTRUE 54235
54233: GO 54265
54235: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54236: LD_ADDR_VAR 0 3
54240: PUSH
54241: LD_INT 1
54243: PUSH
54244: LD_INT 2
54246: PUSH
54247: LD_INT 3
54249: PUSH
54250: LD_INT 4
54252: PUSH
54253: LD_INT 5
54255: PUSH
54256: EMPTY
54257: LIST
54258: LIST
54259: LIST
54260: LIST
54261: LIST
54262: ST_TO_ADDR
54263: GO 55232
54265: LD_INT 3
54267: DOUBLE
54268: EQUAL
54269: IFTRUE 54273
54271: GO 54303
54273: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54274: LD_ADDR_VAR 0 3
54278: PUSH
54279: LD_INT 1
54281: PUSH
54282: LD_INT 2
54284: PUSH
54285: LD_INT 3
54287: PUSH
54288: LD_INT 4
54290: PUSH
54291: LD_INT 5
54293: PUSH
54294: EMPTY
54295: LIST
54296: LIST
54297: LIST
54298: LIST
54299: LIST
54300: ST_TO_ADDR
54301: GO 55232
54303: LD_INT 11
54305: DOUBLE
54306: EQUAL
54307: IFTRUE 54311
54309: GO 54341
54311: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54312: LD_ADDR_VAR 0 3
54316: PUSH
54317: LD_INT 1
54319: PUSH
54320: LD_INT 2
54322: PUSH
54323: LD_INT 3
54325: PUSH
54326: LD_INT 4
54328: PUSH
54329: LD_INT 5
54331: PUSH
54332: EMPTY
54333: LIST
54334: LIST
54335: LIST
54336: LIST
54337: LIST
54338: ST_TO_ADDR
54339: GO 55232
54341: LD_INT 4
54343: DOUBLE
54344: EQUAL
54345: IFTRUE 54349
54347: GO 54375
54349: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54350: LD_ADDR_VAR 0 3
54354: PUSH
54355: LD_INT 2
54357: PUSH
54358: LD_INT 3
54360: PUSH
54361: LD_INT 4
54363: PUSH
54364: LD_INT 5
54366: PUSH
54367: EMPTY
54368: LIST
54369: LIST
54370: LIST
54371: LIST
54372: ST_TO_ADDR
54373: GO 55232
54375: LD_INT 5
54377: DOUBLE
54378: EQUAL
54379: IFTRUE 54383
54381: GO 54409
54383: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54384: LD_ADDR_VAR 0 3
54388: PUSH
54389: LD_INT 2
54391: PUSH
54392: LD_INT 3
54394: PUSH
54395: LD_INT 4
54397: PUSH
54398: LD_INT 5
54400: PUSH
54401: EMPTY
54402: LIST
54403: LIST
54404: LIST
54405: LIST
54406: ST_TO_ADDR
54407: GO 55232
54409: LD_INT 9
54411: DOUBLE
54412: EQUAL
54413: IFTRUE 54417
54415: GO 54443
54417: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54418: LD_ADDR_VAR 0 3
54422: PUSH
54423: LD_INT 2
54425: PUSH
54426: LD_INT 3
54428: PUSH
54429: LD_INT 4
54431: PUSH
54432: LD_INT 5
54434: PUSH
54435: EMPTY
54436: LIST
54437: LIST
54438: LIST
54439: LIST
54440: ST_TO_ADDR
54441: GO 55232
54443: LD_INT 7
54445: DOUBLE
54446: EQUAL
54447: IFTRUE 54451
54449: GO 54477
54451: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54452: LD_ADDR_VAR 0 3
54456: PUSH
54457: LD_INT 2
54459: PUSH
54460: LD_INT 3
54462: PUSH
54463: LD_INT 4
54465: PUSH
54466: LD_INT 5
54468: PUSH
54469: EMPTY
54470: LIST
54471: LIST
54472: LIST
54473: LIST
54474: ST_TO_ADDR
54475: GO 55232
54477: LD_INT 12
54479: DOUBLE
54480: EQUAL
54481: IFTRUE 54485
54483: GO 54511
54485: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54486: LD_ADDR_VAR 0 3
54490: PUSH
54491: LD_INT 2
54493: PUSH
54494: LD_INT 3
54496: PUSH
54497: LD_INT 4
54499: PUSH
54500: LD_INT 5
54502: PUSH
54503: EMPTY
54504: LIST
54505: LIST
54506: LIST
54507: LIST
54508: ST_TO_ADDR
54509: GO 55232
54511: LD_INT 13
54513: DOUBLE
54514: EQUAL
54515: IFTRUE 54519
54517: GO 54545
54519: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54520: LD_ADDR_VAR 0 3
54524: PUSH
54525: LD_INT 2
54527: PUSH
54528: LD_INT 3
54530: PUSH
54531: LD_INT 4
54533: PUSH
54534: LD_INT 5
54536: PUSH
54537: EMPTY
54538: LIST
54539: LIST
54540: LIST
54541: LIST
54542: ST_TO_ADDR
54543: GO 55232
54545: LD_INT 14
54547: DOUBLE
54548: EQUAL
54549: IFTRUE 54553
54551: GO 54571
54553: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54554: LD_ADDR_VAR 0 3
54558: PUSH
54559: LD_INT 4
54561: PUSH
54562: LD_INT 5
54564: PUSH
54565: EMPTY
54566: LIST
54567: LIST
54568: ST_TO_ADDR
54569: GO 55232
54571: LD_INT 6
54573: DOUBLE
54574: EQUAL
54575: IFTRUE 54579
54577: GO 54597
54579: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54580: LD_ADDR_VAR 0 3
54584: PUSH
54585: LD_INT 4
54587: PUSH
54588: LD_INT 5
54590: PUSH
54591: EMPTY
54592: LIST
54593: LIST
54594: ST_TO_ADDR
54595: GO 55232
54597: LD_INT 10
54599: DOUBLE
54600: EQUAL
54601: IFTRUE 54605
54603: GO 54623
54605: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
54606: LD_ADDR_VAR 0 3
54610: PUSH
54611: LD_INT 4
54613: PUSH
54614: LD_INT 5
54616: PUSH
54617: EMPTY
54618: LIST
54619: LIST
54620: ST_TO_ADDR
54621: GO 55232
54623: LD_INT 22
54625: DOUBLE
54626: EQUAL
54627: IFTRUE 54631
54629: GO 54657
54631: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
54632: LD_ADDR_VAR 0 3
54636: PUSH
54637: LD_INT 11
54639: PUSH
54640: LD_INT 12
54642: PUSH
54643: LD_INT 13
54645: PUSH
54646: LD_INT 14
54648: PUSH
54649: EMPTY
54650: LIST
54651: LIST
54652: LIST
54653: LIST
54654: ST_TO_ADDR
54655: GO 55232
54657: LD_INT 23
54659: DOUBLE
54660: EQUAL
54661: IFTRUE 54665
54663: GO 54691
54665: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
54666: LD_ADDR_VAR 0 3
54670: PUSH
54671: LD_INT 11
54673: PUSH
54674: LD_INT 12
54676: PUSH
54677: LD_INT 13
54679: PUSH
54680: LD_INT 14
54682: PUSH
54683: EMPTY
54684: LIST
54685: LIST
54686: LIST
54687: LIST
54688: ST_TO_ADDR
54689: GO 55232
54691: LD_INT 24
54693: DOUBLE
54694: EQUAL
54695: IFTRUE 54699
54697: GO 54725
54699: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
54700: LD_ADDR_VAR 0 3
54704: PUSH
54705: LD_INT 11
54707: PUSH
54708: LD_INT 12
54710: PUSH
54711: LD_INT 13
54713: PUSH
54714: LD_INT 14
54716: PUSH
54717: EMPTY
54718: LIST
54719: LIST
54720: LIST
54721: LIST
54722: ST_TO_ADDR
54723: GO 55232
54725: LD_INT 30
54727: DOUBLE
54728: EQUAL
54729: IFTRUE 54733
54731: GO 54759
54733: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
54734: LD_ADDR_VAR 0 3
54738: PUSH
54739: LD_INT 11
54741: PUSH
54742: LD_INT 12
54744: PUSH
54745: LD_INT 13
54747: PUSH
54748: LD_INT 14
54750: PUSH
54751: EMPTY
54752: LIST
54753: LIST
54754: LIST
54755: LIST
54756: ST_TO_ADDR
54757: GO 55232
54759: LD_INT 25
54761: DOUBLE
54762: EQUAL
54763: IFTRUE 54767
54765: GO 54785
54767: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
54768: LD_ADDR_VAR 0 3
54772: PUSH
54773: LD_INT 13
54775: PUSH
54776: LD_INT 14
54778: PUSH
54779: EMPTY
54780: LIST
54781: LIST
54782: ST_TO_ADDR
54783: GO 55232
54785: LD_INT 27
54787: DOUBLE
54788: EQUAL
54789: IFTRUE 54793
54791: GO 54811
54793: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
54794: LD_ADDR_VAR 0 3
54798: PUSH
54799: LD_INT 13
54801: PUSH
54802: LD_INT 14
54804: PUSH
54805: EMPTY
54806: LIST
54807: LIST
54808: ST_TO_ADDR
54809: GO 55232
54811: LD_INT 28
54813: DOUBLE
54814: EQUAL
54815: IFTRUE 54819
54817: GO 54837
54819: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
54820: LD_ADDR_VAR 0 3
54824: PUSH
54825: LD_INT 13
54827: PUSH
54828: LD_INT 14
54830: PUSH
54831: EMPTY
54832: LIST
54833: LIST
54834: ST_TO_ADDR
54835: GO 55232
54837: LD_INT 29
54839: DOUBLE
54840: EQUAL
54841: IFTRUE 54845
54843: GO 54863
54845: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
54846: LD_ADDR_VAR 0 3
54850: PUSH
54851: LD_INT 13
54853: PUSH
54854: LD_INT 14
54856: PUSH
54857: EMPTY
54858: LIST
54859: LIST
54860: ST_TO_ADDR
54861: GO 55232
54863: LD_INT 31
54865: DOUBLE
54866: EQUAL
54867: IFTRUE 54871
54869: GO 54889
54871: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
54872: LD_ADDR_VAR 0 3
54876: PUSH
54877: LD_INT 13
54879: PUSH
54880: LD_INT 14
54882: PUSH
54883: EMPTY
54884: LIST
54885: LIST
54886: ST_TO_ADDR
54887: GO 55232
54889: LD_INT 26
54891: DOUBLE
54892: EQUAL
54893: IFTRUE 54897
54895: GO 54915
54897: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
54898: LD_ADDR_VAR 0 3
54902: PUSH
54903: LD_INT 13
54905: PUSH
54906: LD_INT 14
54908: PUSH
54909: EMPTY
54910: LIST
54911: LIST
54912: ST_TO_ADDR
54913: GO 55232
54915: LD_INT 42
54917: DOUBLE
54918: EQUAL
54919: IFTRUE 54923
54921: GO 54949
54923: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
54924: LD_ADDR_VAR 0 3
54928: PUSH
54929: LD_INT 21
54931: PUSH
54932: LD_INT 22
54934: PUSH
54935: LD_INT 23
54937: PUSH
54938: LD_INT 24
54940: PUSH
54941: EMPTY
54942: LIST
54943: LIST
54944: LIST
54945: LIST
54946: ST_TO_ADDR
54947: GO 55232
54949: LD_INT 43
54951: DOUBLE
54952: EQUAL
54953: IFTRUE 54957
54955: GO 54983
54957: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
54958: LD_ADDR_VAR 0 3
54962: PUSH
54963: LD_INT 21
54965: PUSH
54966: LD_INT 22
54968: PUSH
54969: LD_INT 23
54971: PUSH
54972: LD_INT 24
54974: PUSH
54975: EMPTY
54976: LIST
54977: LIST
54978: LIST
54979: LIST
54980: ST_TO_ADDR
54981: GO 55232
54983: LD_INT 44
54985: DOUBLE
54986: EQUAL
54987: IFTRUE 54991
54989: GO 55017
54991: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
54992: LD_ADDR_VAR 0 3
54996: PUSH
54997: LD_INT 21
54999: PUSH
55000: LD_INT 22
55002: PUSH
55003: LD_INT 23
55005: PUSH
55006: LD_INT 24
55008: PUSH
55009: EMPTY
55010: LIST
55011: LIST
55012: LIST
55013: LIST
55014: ST_TO_ADDR
55015: GO 55232
55017: LD_INT 45
55019: DOUBLE
55020: EQUAL
55021: IFTRUE 55025
55023: GO 55051
55025: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55026: LD_ADDR_VAR 0 3
55030: PUSH
55031: LD_INT 21
55033: PUSH
55034: LD_INT 22
55036: PUSH
55037: LD_INT 23
55039: PUSH
55040: LD_INT 24
55042: PUSH
55043: EMPTY
55044: LIST
55045: LIST
55046: LIST
55047: LIST
55048: ST_TO_ADDR
55049: GO 55232
55051: LD_INT 49
55053: DOUBLE
55054: EQUAL
55055: IFTRUE 55059
55057: GO 55085
55059: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55060: LD_ADDR_VAR 0 3
55064: PUSH
55065: LD_INT 21
55067: PUSH
55068: LD_INT 22
55070: PUSH
55071: LD_INT 23
55073: PUSH
55074: LD_INT 24
55076: PUSH
55077: EMPTY
55078: LIST
55079: LIST
55080: LIST
55081: LIST
55082: ST_TO_ADDR
55083: GO 55232
55085: LD_INT 51
55087: DOUBLE
55088: EQUAL
55089: IFTRUE 55093
55091: GO 55119
55093: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55094: LD_ADDR_VAR 0 3
55098: PUSH
55099: LD_INT 21
55101: PUSH
55102: LD_INT 22
55104: PUSH
55105: LD_INT 23
55107: PUSH
55108: LD_INT 24
55110: PUSH
55111: EMPTY
55112: LIST
55113: LIST
55114: LIST
55115: LIST
55116: ST_TO_ADDR
55117: GO 55232
55119: LD_INT 52
55121: DOUBLE
55122: EQUAL
55123: IFTRUE 55127
55125: GO 55153
55127: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55128: LD_ADDR_VAR 0 3
55132: PUSH
55133: LD_INT 21
55135: PUSH
55136: LD_INT 22
55138: PUSH
55139: LD_INT 23
55141: PUSH
55142: LD_INT 24
55144: PUSH
55145: EMPTY
55146: LIST
55147: LIST
55148: LIST
55149: LIST
55150: ST_TO_ADDR
55151: GO 55232
55153: LD_INT 53
55155: DOUBLE
55156: EQUAL
55157: IFTRUE 55161
55159: GO 55179
55161: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55162: LD_ADDR_VAR 0 3
55166: PUSH
55167: LD_INT 23
55169: PUSH
55170: LD_INT 24
55172: PUSH
55173: EMPTY
55174: LIST
55175: LIST
55176: ST_TO_ADDR
55177: GO 55232
55179: LD_INT 46
55181: DOUBLE
55182: EQUAL
55183: IFTRUE 55187
55185: GO 55205
55187: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55188: LD_ADDR_VAR 0 3
55192: PUSH
55193: LD_INT 23
55195: PUSH
55196: LD_INT 24
55198: PUSH
55199: EMPTY
55200: LIST
55201: LIST
55202: ST_TO_ADDR
55203: GO 55232
55205: LD_INT 47
55207: DOUBLE
55208: EQUAL
55209: IFTRUE 55213
55211: GO 55231
55213: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55214: LD_ADDR_VAR 0 3
55218: PUSH
55219: LD_INT 23
55221: PUSH
55222: LD_INT 24
55224: PUSH
55225: EMPTY
55226: LIST
55227: LIST
55228: ST_TO_ADDR
55229: GO 55232
55231: POP
// result := ( chassis in result ) ;
55232: LD_ADDR_VAR 0 3
55236: PUSH
55237: LD_VAR 0 1
55241: PUSH
55242: LD_VAR 0 3
55246: IN
55247: ST_TO_ADDR
// end ;
55248: LD_VAR 0 3
55252: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55253: LD_INT 0
55255: PPUSH
55256: PPUSH
55257: PPUSH
55258: PPUSH
55259: PPUSH
55260: PPUSH
55261: PPUSH
// result := array ;
55262: LD_ADDR_VAR 0 5
55266: PUSH
55267: LD_VAR 0 1
55271: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55272: LD_VAR 0 1
55276: NOT
55277: PUSH
55278: LD_VAR 0 2
55282: NOT
55283: OR
55284: PUSH
55285: LD_VAR 0 3
55289: NOT
55290: OR
55291: PUSH
55292: LD_VAR 0 2
55296: PUSH
55297: LD_VAR 0 1
55301: GREATER
55302: OR
55303: PUSH
55304: LD_VAR 0 3
55308: PUSH
55309: LD_VAR 0 1
55313: GREATER
55314: OR
55315: IFFALSE 55319
// exit ;
55317: GO 55615
// if direction then
55319: LD_VAR 0 4
55323: IFFALSE 55387
// begin d := 1 ;
55325: LD_ADDR_VAR 0 9
55329: PUSH
55330: LD_INT 1
55332: ST_TO_ADDR
// if i_from > i_to then
55333: LD_VAR 0 2
55337: PUSH
55338: LD_VAR 0 3
55342: GREATER
55343: IFFALSE 55369
// length := ( array - i_from ) + i_to else
55345: LD_ADDR_VAR 0 11
55349: PUSH
55350: LD_VAR 0 1
55354: PUSH
55355: LD_VAR 0 2
55359: MINUS
55360: PUSH
55361: LD_VAR 0 3
55365: PLUS
55366: ST_TO_ADDR
55367: GO 55385
// length := i_to - i_from ;
55369: LD_ADDR_VAR 0 11
55373: PUSH
55374: LD_VAR 0 3
55378: PUSH
55379: LD_VAR 0 2
55383: MINUS
55384: ST_TO_ADDR
// end else
55385: GO 55448
// begin d := - 1 ;
55387: LD_ADDR_VAR 0 9
55391: PUSH
55392: LD_INT 1
55394: NEG
55395: ST_TO_ADDR
// if i_from > i_to then
55396: LD_VAR 0 2
55400: PUSH
55401: LD_VAR 0 3
55405: GREATER
55406: IFFALSE 55426
// length := i_from - i_to else
55408: LD_ADDR_VAR 0 11
55412: PUSH
55413: LD_VAR 0 2
55417: PUSH
55418: LD_VAR 0 3
55422: MINUS
55423: ST_TO_ADDR
55424: GO 55448
// length := ( array - i_to ) + i_from ;
55426: LD_ADDR_VAR 0 11
55430: PUSH
55431: LD_VAR 0 1
55435: PUSH
55436: LD_VAR 0 3
55440: MINUS
55441: PUSH
55442: LD_VAR 0 2
55446: PLUS
55447: ST_TO_ADDR
// end ; if not length then
55448: LD_VAR 0 11
55452: NOT
55453: IFFALSE 55457
// exit ;
55455: GO 55615
// tmp := array ;
55457: LD_ADDR_VAR 0 10
55461: PUSH
55462: LD_VAR 0 1
55466: ST_TO_ADDR
// for i = 1 to length do
55467: LD_ADDR_VAR 0 6
55471: PUSH
55472: DOUBLE
55473: LD_INT 1
55475: DEC
55476: ST_TO_ADDR
55477: LD_VAR 0 11
55481: PUSH
55482: FOR_TO
55483: IFFALSE 55603
// begin for j = 1 to array do
55485: LD_ADDR_VAR 0 7
55489: PUSH
55490: DOUBLE
55491: LD_INT 1
55493: DEC
55494: ST_TO_ADDR
55495: LD_VAR 0 1
55499: PUSH
55500: FOR_TO
55501: IFFALSE 55589
// begin k := j + d ;
55503: LD_ADDR_VAR 0 8
55507: PUSH
55508: LD_VAR 0 7
55512: PUSH
55513: LD_VAR 0 9
55517: PLUS
55518: ST_TO_ADDR
// if k > array then
55519: LD_VAR 0 8
55523: PUSH
55524: LD_VAR 0 1
55528: GREATER
55529: IFFALSE 55539
// k := 1 ;
55531: LD_ADDR_VAR 0 8
55535: PUSH
55536: LD_INT 1
55538: ST_TO_ADDR
// if not k then
55539: LD_VAR 0 8
55543: NOT
55544: IFFALSE 55556
// k := array ;
55546: LD_ADDR_VAR 0 8
55550: PUSH
55551: LD_VAR 0 1
55555: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55556: LD_ADDR_VAR 0 10
55560: PUSH
55561: LD_VAR 0 10
55565: PPUSH
55566: LD_VAR 0 8
55570: PPUSH
55571: LD_VAR 0 1
55575: PUSH
55576: LD_VAR 0 7
55580: ARRAY
55581: PPUSH
55582: CALL_OW 1
55586: ST_TO_ADDR
// end ;
55587: GO 55500
55589: POP
55590: POP
// array := tmp ;
55591: LD_ADDR_VAR 0 1
55595: PUSH
55596: LD_VAR 0 10
55600: ST_TO_ADDR
// end ;
55601: GO 55482
55603: POP
55604: POP
// result := array ;
55605: LD_ADDR_VAR 0 5
55609: PUSH
55610: LD_VAR 0 1
55614: ST_TO_ADDR
// end ;
55615: LD_VAR 0 5
55619: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
55620: LD_INT 0
55622: PPUSH
55623: PPUSH
// result := 0 ;
55624: LD_ADDR_VAR 0 3
55628: PUSH
55629: LD_INT 0
55631: ST_TO_ADDR
// if not array or not value in array then
55632: LD_VAR 0 1
55636: NOT
55637: PUSH
55638: LD_VAR 0 2
55642: PUSH
55643: LD_VAR 0 1
55647: IN
55648: NOT
55649: OR
55650: IFFALSE 55654
// exit ;
55652: GO 55708
// for i = 1 to array do
55654: LD_ADDR_VAR 0 4
55658: PUSH
55659: DOUBLE
55660: LD_INT 1
55662: DEC
55663: ST_TO_ADDR
55664: LD_VAR 0 1
55668: PUSH
55669: FOR_TO
55670: IFFALSE 55706
// if value = array [ i ] then
55672: LD_VAR 0 2
55676: PUSH
55677: LD_VAR 0 1
55681: PUSH
55682: LD_VAR 0 4
55686: ARRAY
55687: EQUAL
55688: IFFALSE 55704
// begin result := i ;
55690: LD_ADDR_VAR 0 3
55694: PUSH
55695: LD_VAR 0 4
55699: ST_TO_ADDR
// exit ;
55700: POP
55701: POP
55702: GO 55708
// end ;
55704: GO 55669
55706: POP
55707: POP
// end ;
55708: LD_VAR 0 3
55712: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
55713: LD_INT 0
55715: PPUSH
// vc_chassis := chassis ;
55716: LD_ADDR_OWVAR 37
55720: PUSH
55721: LD_VAR 0 1
55725: ST_TO_ADDR
// vc_engine := engine ;
55726: LD_ADDR_OWVAR 39
55730: PUSH
55731: LD_VAR 0 2
55735: ST_TO_ADDR
// vc_control := control ;
55736: LD_ADDR_OWVAR 38
55740: PUSH
55741: LD_VAR 0 3
55745: ST_TO_ADDR
// vc_weapon := weapon ;
55746: LD_ADDR_OWVAR 40
55750: PUSH
55751: LD_VAR 0 4
55755: ST_TO_ADDR
// vc_fuel_battery := fuel ;
55756: LD_ADDR_OWVAR 41
55760: PUSH
55761: LD_VAR 0 5
55765: ST_TO_ADDR
// end ;
55766: LD_VAR 0 6
55770: RET
// export function WantPlant ( unit ) ; var task ; begin
55771: LD_INT 0
55773: PPUSH
55774: PPUSH
// result := false ;
55775: LD_ADDR_VAR 0 2
55779: PUSH
55780: LD_INT 0
55782: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
55783: LD_ADDR_VAR 0 3
55787: PUSH
55788: LD_VAR 0 1
55792: PPUSH
55793: CALL_OW 437
55797: ST_TO_ADDR
// if task then
55798: LD_VAR 0 3
55802: IFFALSE 55830
// if task [ 1 ] [ 1 ] = p then
55804: LD_VAR 0 3
55808: PUSH
55809: LD_INT 1
55811: ARRAY
55812: PUSH
55813: LD_INT 1
55815: ARRAY
55816: PUSH
55817: LD_STRING p
55819: EQUAL
55820: IFFALSE 55830
// result := true ;
55822: LD_ADDR_VAR 0 2
55826: PUSH
55827: LD_INT 1
55829: ST_TO_ADDR
// end ;
55830: LD_VAR 0 2
55834: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
55835: LD_INT 0
55837: PPUSH
55838: PPUSH
55839: PPUSH
55840: PPUSH
// if pos < 1 then
55841: LD_VAR 0 2
55845: PUSH
55846: LD_INT 1
55848: LESS
55849: IFFALSE 55853
// exit ;
55851: GO 56156
// if pos = 1 then
55853: LD_VAR 0 2
55857: PUSH
55858: LD_INT 1
55860: EQUAL
55861: IFFALSE 55894
// result := Replace ( arr , pos [ 1 ] , value ) else
55863: LD_ADDR_VAR 0 4
55867: PUSH
55868: LD_VAR 0 1
55872: PPUSH
55873: LD_VAR 0 2
55877: PUSH
55878: LD_INT 1
55880: ARRAY
55881: PPUSH
55882: LD_VAR 0 3
55886: PPUSH
55887: CALL_OW 1
55891: ST_TO_ADDR
55892: GO 56156
// begin tmp := arr ;
55894: LD_ADDR_VAR 0 6
55898: PUSH
55899: LD_VAR 0 1
55903: ST_TO_ADDR
// s_arr := [ tmp ] ;
55904: LD_ADDR_VAR 0 7
55908: PUSH
55909: LD_VAR 0 6
55913: PUSH
55914: EMPTY
55915: LIST
55916: ST_TO_ADDR
// for i = 1 to pos - 1 do
55917: LD_ADDR_VAR 0 5
55921: PUSH
55922: DOUBLE
55923: LD_INT 1
55925: DEC
55926: ST_TO_ADDR
55927: LD_VAR 0 2
55931: PUSH
55932: LD_INT 1
55934: MINUS
55935: PUSH
55936: FOR_TO
55937: IFFALSE 55982
// begin tmp := tmp [ pos [ i ] ] ;
55939: LD_ADDR_VAR 0 6
55943: PUSH
55944: LD_VAR 0 6
55948: PUSH
55949: LD_VAR 0 2
55953: PUSH
55954: LD_VAR 0 5
55958: ARRAY
55959: ARRAY
55960: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
55961: LD_ADDR_VAR 0 7
55965: PUSH
55966: LD_VAR 0 7
55970: PUSH
55971: LD_VAR 0 6
55975: PUSH
55976: EMPTY
55977: LIST
55978: ADD
55979: ST_TO_ADDR
// end ;
55980: GO 55936
55982: POP
55983: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
55984: LD_ADDR_VAR 0 6
55988: PUSH
55989: LD_VAR 0 6
55993: PPUSH
55994: LD_VAR 0 2
55998: PUSH
55999: LD_VAR 0 2
56003: ARRAY
56004: PPUSH
56005: LD_VAR 0 3
56009: PPUSH
56010: CALL_OW 1
56014: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
56015: LD_ADDR_VAR 0 7
56019: PUSH
56020: LD_VAR 0 7
56024: PPUSH
56025: LD_VAR 0 7
56029: PPUSH
56030: LD_VAR 0 6
56034: PPUSH
56035: CALL_OW 1
56039: ST_TO_ADDR
// for i = s_arr downto 2 do
56040: LD_ADDR_VAR 0 5
56044: PUSH
56045: DOUBLE
56046: LD_VAR 0 7
56050: INC
56051: ST_TO_ADDR
56052: LD_INT 2
56054: PUSH
56055: FOR_DOWNTO
56056: IFFALSE 56140
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56058: LD_ADDR_VAR 0 6
56062: PUSH
56063: LD_VAR 0 7
56067: PUSH
56068: LD_VAR 0 5
56072: PUSH
56073: LD_INT 1
56075: MINUS
56076: ARRAY
56077: PPUSH
56078: LD_VAR 0 2
56082: PUSH
56083: LD_VAR 0 5
56087: PUSH
56088: LD_INT 1
56090: MINUS
56091: ARRAY
56092: PPUSH
56093: LD_VAR 0 7
56097: PUSH
56098: LD_VAR 0 5
56102: ARRAY
56103: PPUSH
56104: CALL_OW 1
56108: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56109: LD_ADDR_VAR 0 7
56113: PUSH
56114: LD_VAR 0 7
56118: PPUSH
56119: LD_VAR 0 5
56123: PUSH
56124: LD_INT 1
56126: MINUS
56127: PPUSH
56128: LD_VAR 0 6
56132: PPUSH
56133: CALL_OW 1
56137: ST_TO_ADDR
// end ;
56138: GO 56055
56140: POP
56141: POP
// result := s_arr [ 1 ] ;
56142: LD_ADDR_VAR 0 4
56146: PUSH
56147: LD_VAR 0 7
56151: PUSH
56152: LD_INT 1
56154: ARRAY
56155: ST_TO_ADDR
// end ; end ;
56156: LD_VAR 0 4
56160: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56161: LD_INT 0
56163: PPUSH
56164: PPUSH
// if not list then
56165: LD_VAR 0 1
56169: NOT
56170: IFFALSE 56174
// exit ;
56172: GO 56265
// i := list [ pos1 ] ;
56174: LD_ADDR_VAR 0 5
56178: PUSH
56179: LD_VAR 0 1
56183: PUSH
56184: LD_VAR 0 2
56188: ARRAY
56189: ST_TO_ADDR
// if not i then
56190: LD_VAR 0 5
56194: NOT
56195: IFFALSE 56199
// exit ;
56197: GO 56265
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56199: LD_ADDR_VAR 0 1
56203: PUSH
56204: LD_VAR 0 1
56208: PPUSH
56209: LD_VAR 0 2
56213: PPUSH
56214: LD_VAR 0 1
56218: PUSH
56219: LD_VAR 0 3
56223: ARRAY
56224: PPUSH
56225: CALL_OW 1
56229: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56230: LD_ADDR_VAR 0 1
56234: PUSH
56235: LD_VAR 0 1
56239: PPUSH
56240: LD_VAR 0 3
56244: PPUSH
56245: LD_VAR 0 5
56249: PPUSH
56250: CALL_OW 1
56254: ST_TO_ADDR
// result := list ;
56255: LD_ADDR_VAR 0 4
56259: PUSH
56260: LD_VAR 0 1
56264: ST_TO_ADDR
// end ;
56265: LD_VAR 0 4
56269: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56270: LD_INT 0
56272: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56273: LD_ADDR_VAR 0 5
56277: PUSH
56278: LD_VAR 0 1
56282: PPUSH
56283: CALL_OW 250
56287: PPUSH
56288: LD_VAR 0 1
56292: PPUSH
56293: CALL_OW 251
56297: PPUSH
56298: LD_VAR 0 2
56302: PPUSH
56303: LD_VAR 0 3
56307: PPUSH
56308: LD_VAR 0 4
56312: PPUSH
56313: CALL 56323 0 5
56317: ST_TO_ADDR
// end ;
56318: LD_VAR 0 5
56322: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56323: LD_INT 0
56325: PPUSH
56326: PPUSH
56327: PPUSH
56328: PPUSH
// if not list then
56329: LD_VAR 0 3
56333: NOT
56334: IFFALSE 56338
// exit ;
56336: GO 56726
// result := [ ] ;
56338: LD_ADDR_VAR 0 6
56342: PUSH
56343: EMPTY
56344: ST_TO_ADDR
// for i in list do
56345: LD_ADDR_VAR 0 7
56349: PUSH
56350: LD_VAR 0 3
56354: PUSH
56355: FOR_IN
56356: IFFALSE 56558
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56358: LD_ADDR_VAR 0 9
56362: PUSH
56363: LD_VAR 0 7
56367: PPUSH
56368: LD_VAR 0 1
56372: PPUSH
56373: LD_VAR 0 2
56377: PPUSH
56378: CALL_OW 297
56382: ST_TO_ADDR
// if not result then
56383: LD_VAR 0 6
56387: NOT
56388: IFFALSE 56414
// result := [ [ i , tmp ] ] else
56390: LD_ADDR_VAR 0 6
56394: PUSH
56395: LD_VAR 0 7
56399: PUSH
56400: LD_VAR 0 9
56404: PUSH
56405: EMPTY
56406: LIST
56407: LIST
56408: PUSH
56409: EMPTY
56410: LIST
56411: ST_TO_ADDR
56412: GO 56556
// begin if result [ result ] [ 2 ] < tmp then
56414: LD_VAR 0 6
56418: PUSH
56419: LD_VAR 0 6
56423: ARRAY
56424: PUSH
56425: LD_INT 2
56427: ARRAY
56428: PUSH
56429: LD_VAR 0 9
56433: LESS
56434: IFFALSE 56476
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56436: LD_ADDR_VAR 0 6
56440: PUSH
56441: LD_VAR 0 6
56445: PPUSH
56446: LD_VAR 0 6
56450: PUSH
56451: LD_INT 1
56453: PLUS
56454: PPUSH
56455: LD_VAR 0 7
56459: PUSH
56460: LD_VAR 0 9
56464: PUSH
56465: EMPTY
56466: LIST
56467: LIST
56468: PPUSH
56469: CALL_OW 2
56473: ST_TO_ADDR
56474: GO 56556
// for j = 1 to result do
56476: LD_ADDR_VAR 0 8
56480: PUSH
56481: DOUBLE
56482: LD_INT 1
56484: DEC
56485: ST_TO_ADDR
56486: LD_VAR 0 6
56490: PUSH
56491: FOR_TO
56492: IFFALSE 56554
// begin if tmp < result [ j ] [ 2 ] then
56494: LD_VAR 0 9
56498: PUSH
56499: LD_VAR 0 6
56503: PUSH
56504: LD_VAR 0 8
56508: ARRAY
56509: PUSH
56510: LD_INT 2
56512: ARRAY
56513: LESS
56514: IFFALSE 56552
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56516: LD_ADDR_VAR 0 6
56520: PUSH
56521: LD_VAR 0 6
56525: PPUSH
56526: LD_VAR 0 8
56530: PPUSH
56531: LD_VAR 0 7
56535: PUSH
56536: LD_VAR 0 9
56540: PUSH
56541: EMPTY
56542: LIST
56543: LIST
56544: PPUSH
56545: CALL_OW 2
56549: ST_TO_ADDR
// break ;
56550: GO 56554
// end ; end ;
56552: GO 56491
56554: POP
56555: POP
// end ; end ;
56556: GO 56355
56558: POP
56559: POP
// if result and not asc then
56560: LD_VAR 0 6
56564: PUSH
56565: LD_VAR 0 4
56569: NOT
56570: AND
56571: IFFALSE 56646
// begin tmp := result ;
56573: LD_ADDR_VAR 0 9
56577: PUSH
56578: LD_VAR 0 6
56582: ST_TO_ADDR
// for i = tmp downto 1 do
56583: LD_ADDR_VAR 0 7
56587: PUSH
56588: DOUBLE
56589: LD_VAR 0 9
56593: INC
56594: ST_TO_ADDR
56595: LD_INT 1
56597: PUSH
56598: FOR_DOWNTO
56599: IFFALSE 56644
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56601: LD_ADDR_VAR 0 6
56605: PUSH
56606: LD_VAR 0 6
56610: PPUSH
56611: LD_VAR 0 9
56615: PUSH
56616: LD_VAR 0 7
56620: MINUS
56621: PUSH
56622: LD_INT 1
56624: PLUS
56625: PPUSH
56626: LD_VAR 0 9
56630: PUSH
56631: LD_VAR 0 7
56635: ARRAY
56636: PPUSH
56637: CALL_OW 1
56641: ST_TO_ADDR
56642: GO 56598
56644: POP
56645: POP
// end ; tmp := [ ] ;
56646: LD_ADDR_VAR 0 9
56650: PUSH
56651: EMPTY
56652: ST_TO_ADDR
// if mode then
56653: LD_VAR 0 5
56657: IFFALSE 56726
// begin for i = 1 to result do
56659: LD_ADDR_VAR 0 7
56663: PUSH
56664: DOUBLE
56665: LD_INT 1
56667: DEC
56668: ST_TO_ADDR
56669: LD_VAR 0 6
56673: PUSH
56674: FOR_TO
56675: IFFALSE 56714
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
56677: LD_ADDR_VAR 0 9
56681: PUSH
56682: LD_VAR 0 9
56686: PPUSH
56687: LD_VAR 0 7
56691: PPUSH
56692: LD_VAR 0 6
56696: PUSH
56697: LD_VAR 0 7
56701: ARRAY
56702: PUSH
56703: LD_INT 1
56705: ARRAY
56706: PPUSH
56707: CALL_OW 1
56711: ST_TO_ADDR
56712: GO 56674
56714: POP
56715: POP
// result := tmp ;
56716: LD_ADDR_VAR 0 6
56720: PUSH
56721: LD_VAR 0 9
56725: ST_TO_ADDR
// end ; end ;
56726: LD_VAR 0 6
56730: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
56731: LD_INT 0
56733: PPUSH
56734: PPUSH
56735: PPUSH
56736: PPUSH
56737: PPUSH
56738: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
56739: LD_ADDR_VAR 0 5
56743: PUSH
56744: LD_INT 0
56746: PUSH
56747: LD_INT 0
56749: PUSH
56750: LD_INT 0
56752: PUSH
56753: EMPTY
56754: PUSH
56755: EMPTY
56756: LIST
56757: LIST
56758: LIST
56759: LIST
56760: ST_TO_ADDR
// if not x or not y then
56761: LD_VAR 0 2
56765: NOT
56766: PUSH
56767: LD_VAR 0 3
56771: NOT
56772: OR
56773: IFFALSE 56777
// exit ;
56775: GO 58423
// if not range then
56777: LD_VAR 0 4
56781: NOT
56782: IFFALSE 56792
// range := 10 ;
56784: LD_ADDR_VAR 0 4
56788: PUSH
56789: LD_INT 10
56791: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56792: LD_ADDR_VAR 0 8
56796: PUSH
56797: LD_INT 81
56799: PUSH
56800: LD_VAR 0 1
56804: PUSH
56805: EMPTY
56806: LIST
56807: LIST
56808: PUSH
56809: LD_INT 92
56811: PUSH
56812: LD_VAR 0 2
56816: PUSH
56817: LD_VAR 0 3
56821: PUSH
56822: LD_VAR 0 4
56826: PUSH
56827: EMPTY
56828: LIST
56829: LIST
56830: LIST
56831: LIST
56832: PUSH
56833: LD_INT 3
56835: PUSH
56836: LD_INT 21
56838: PUSH
56839: LD_INT 3
56841: PUSH
56842: EMPTY
56843: LIST
56844: LIST
56845: PUSH
56846: EMPTY
56847: LIST
56848: LIST
56849: PUSH
56850: EMPTY
56851: LIST
56852: LIST
56853: LIST
56854: PPUSH
56855: CALL_OW 69
56859: ST_TO_ADDR
// if not tmp then
56860: LD_VAR 0 8
56864: NOT
56865: IFFALSE 56869
// exit ;
56867: GO 58423
// for i in tmp do
56869: LD_ADDR_VAR 0 6
56873: PUSH
56874: LD_VAR 0 8
56878: PUSH
56879: FOR_IN
56880: IFFALSE 58398
// begin points := [ 0 , 0 , 0 ] ;
56882: LD_ADDR_VAR 0 9
56886: PUSH
56887: LD_INT 0
56889: PUSH
56890: LD_INT 0
56892: PUSH
56893: LD_INT 0
56895: PUSH
56896: EMPTY
56897: LIST
56898: LIST
56899: LIST
56900: ST_TO_ADDR
// bpoints := 1 ;
56901: LD_ADDR_VAR 0 10
56905: PUSH
56906: LD_INT 1
56908: ST_TO_ADDR
// case GetType ( i ) of unit_human :
56909: LD_VAR 0 6
56913: PPUSH
56914: CALL_OW 247
56918: PUSH
56919: LD_INT 1
56921: DOUBLE
56922: EQUAL
56923: IFTRUE 56927
56925: GO 57505
56927: POP
// begin if GetClass ( i ) = 1 then
56928: LD_VAR 0 6
56932: PPUSH
56933: CALL_OW 257
56937: PUSH
56938: LD_INT 1
56940: EQUAL
56941: IFFALSE 56962
// points := [ 10 , 5 , 3 ] ;
56943: LD_ADDR_VAR 0 9
56947: PUSH
56948: LD_INT 10
56950: PUSH
56951: LD_INT 5
56953: PUSH
56954: LD_INT 3
56956: PUSH
56957: EMPTY
56958: LIST
56959: LIST
56960: LIST
56961: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
56962: LD_VAR 0 6
56966: PPUSH
56967: CALL_OW 257
56971: PUSH
56972: LD_INT 2
56974: PUSH
56975: LD_INT 3
56977: PUSH
56978: LD_INT 4
56980: PUSH
56981: EMPTY
56982: LIST
56983: LIST
56984: LIST
56985: IN
56986: IFFALSE 57007
// points := [ 3 , 2 , 1 ] ;
56988: LD_ADDR_VAR 0 9
56992: PUSH
56993: LD_INT 3
56995: PUSH
56996: LD_INT 2
56998: PUSH
56999: LD_INT 1
57001: PUSH
57002: EMPTY
57003: LIST
57004: LIST
57005: LIST
57006: ST_TO_ADDR
// if GetClass ( i ) = 5 then
57007: LD_VAR 0 6
57011: PPUSH
57012: CALL_OW 257
57016: PUSH
57017: LD_INT 5
57019: EQUAL
57020: IFFALSE 57041
// points := [ 130 , 5 , 2 ] ;
57022: LD_ADDR_VAR 0 9
57026: PUSH
57027: LD_INT 130
57029: PUSH
57030: LD_INT 5
57032: PUSH
57033: LD_INT 2
57035: PUSH
57036: EMPTY
57037: LIST
57038: LIST
57039: LIST
57040: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57041: LD_VAR 0 6
57045: PPUSH
57046: CALL_OW 257
57050: PUSH
57051: LD_INT 8
57053: EQUAL
57054: IFFALSE 57075
// points := [ 35 , 35 , 30 ] ;
57056: LD_ADDR_VAR 0 9
57060: PUSH
57061: LD_INT 35
57063: PUSH
57064: LD_INT 35
57066: PUSH
57067: LD_INT 30
57069: PUSH
57070: EMPTY
57071: LIST
57072: LIST
57073: LIST
57074: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57075: LD_VAR 0 6
57079: PPUSH
57080: CALL_OW 257
57084: PUSH
57085: LD_INT 9
57087: EQUAL
57088: IFFALSE 57109
// points := [ 20 , 55 , 40 ] ;
57090: LD_ADDR_VAR 0 9
57094: PUSH
57095: LD_INT 20
57097: PUSH
57098: LD_INT 55
57100: PUSH
57101: LD_INT 40
57103: PUSH
57104: EMPTY
57105: LIST
57106: LIST
57107: LIST
57108: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57109: LD_VAR 0 6
57113: PPUSH
57114: CALL_OW 257
57118: PUSH
57119: LD_INT 12
57121: PUSH
57122: LD_INT 16
57124: PUSH
57125: EMPTY
57126: LIST
57127: LIST
57128: IN
57129: IFFALSE 57150
// points := [ 5 , 3 , 2 ] ;
57131: LD_ADDR_VAR 0 9
57135: PUSH
57136: LD_INT 5
57138: PUSH
57139: LD_INT 3
57141: PUSH
57142: LD_INT 2
57144: PUSH
57145: EMPTY
57146: LIST
57147: LIST
57148: LIST
57149: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57150: LD_VAR 0 6
57154: PPUSH
57155: CALL_OW 257
57159: PUSH
57160: LD_INT 17
57162: EQUAL
57163: IFFALSE 57184
// points := [ 100 , 50 , 75 ] ;
57165: LD_ADDR_VAR 0 9
57169: PUSH
57170: LD_INT 100
57172: PUSH
57173: LD_INT 50
57175: PUSH
57176: LD_INT 75
57178: PUSH
57179: EMPTY
57180: LIST
57181: LIST
57182: LIST
57183: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57184: LD_VAR 0 6
57188: PPUSH
57189: CALL_OW 257
57193: PUSH
57194: LD_INT 15
57196: EQUAL
57197: IFFALSE 57218
// points := [ 10 , 5 , 3 ] ;
57199: LD_ADDR_VAR 0 9
57203: PUSH
57204: LD_INT 10
57206: PUSH
57207: LD_INT 5
57209: PUSH
57210: LD_INT 3
57212: PUSH
57213: EMPTY
57214: LIST
57215: LIST
57216: LIST
57217: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57218: LD_VAR 0 6
57222: PPUSH
57223: CALL_OW 257
57227: PUSH
57228: LD_INT 14
57230: EQUAL
57231: IFFALSE 57252
// points := [ 10 , 0 , 0 ] ;
57233: LD_ADDR_VAR 0 9
57237: PUSH
57238: LD_INT 10
57240: PUSH
57241: LD_INT 0
57243: PUSH
57244: LD_INT 0
57246: PUSH
57247: EMPTY
57248: LIST
57249: LIST
57250: LIST
57251: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57252: LD_VAR 0 6
57256: PPUSH
57257: CALL_OW 257
57261: PUSH
57262: LD_INT 11
57264: EQUAL
57265: IFFALSE 57286
// points := [ 30 , 10 , 5 ] ;
57267: LD_ADDR_VAR 0 9
57271: PUSH
57272: LD_INT 30
57274: PUSH
57275: LD_INT 10
57277: PUSH
57278: LD_INT 5
57280: PUSH
57281: EMPTY
57282: LIST
57283: LIST
57284: LIST
57285: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57286: LD_VAR 0 1
57290: PPUSH
57291: LD_INT 5
57293: PPUSH
57294: CALL_OW 321
57298: PUSH
57299: LD_INT 2
57301: EQUAL
57302: IFFALSE 57319
// bpoints := bpoints * 1.8 ;
57304: LD_ADDR_VAR 0 10
57308: PUSH
57309: LD_VAR 0 10
57313: PUSH
57314: LD_REAL  1.80000000000000E+0000
57317: MUL
57318: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57319: LD_VAR 0 6
57323: PPUSH
57324: CALL_OW 257
57328: PUSH
57329: LD_INT 1
57331: PUSH
57332: LD_INT 2
57334: PUSH
57335: LD_INT 3
57337: PUSH
57338: LD_INT 4
57340: PUSH
57341: EMPTY
57342: LIST
57343: LIST
57344: LIST
57345: LIST
57346: IN
57347: PUSH
57348: LD_VAR 0 1
57352: PPUSH
57353: LD_INT 51
57355: PPUSH
57356: CALL_OW 321
57360: PUSH
57361: LD_INT 2
57363: EQUAL
57364: AND
57365: IFFALSE 57382
// bpoints := bpoints * 1.2 ;
57367: LD_ADDR_VAR 0 10
57371: PUSH
57372: LD_VAR 0 10
57376: PUSH
57377: LD_REAL  1.20000000000000E+0000
57380: MUL
57381: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57382: LD_VAR 0 6
57386: PPUSH
57387: CALL_OW 257
57391: PUSH
57392: LD_INT 5
57394: PUSH
57395: LD_INT 7
57397: PUSH
57398: LD_INT 9
57400: PUSH
57401: EMPTY
57402: LIST
57403: LIST
57404: LIST
57405: IN
57406: PUSH
57407: LD_VAR 0 1
57411: PPUSH
57412: LD_INT 52
57414: PPUSH
57415: CALL_OW 321
57419: PUSH
57420: LD_INT 2
57422: EQUAL
57423: AND
57424: IFFALSE 57441
// bpoints := bpoints * 1.5 ;
57426: LD_ADDR_VAR 0 10
57430: PUSH
57431: LD_VAR 0 10
57435: PUSH
57436: LD_REAL  1.50000000000000E+0000
57439: MUL
57440: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57441: LD_VAR 0 1
57445: PPUSH
57446: LD_INT 66
57448: PPUSH
57449: CALL_OW 321
57453: PUSH
57454: LD_INT 2
57456: EQUAL
57457: IFFALSE 57474
// bpoints := bpoints * 1.1 ;
57459: LD_ADDR_VAR 0 10
57463: PUSH
57464: LD_VAR 0 10
57468: PUSH
57469: LD_REAL  1.10000000000000E+0000
57472: MUL
57473: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57474: LD_ADDR_VAR 0 10
57478: PUSH
57479: LD_VAR 0 10
57483: PUSH
57484: LD_VAR 0 6
57488: PPUSH
57489: LD_INT 1
57491: PPUSH
57492: CALL_OW 259
57496: PUSH
57497: LD_REAL  1.15000000000000E+0000
57500: MUL
57501: MUL
57502: ST_TO_ADDR
// end ; unit_vehicle :
57503: GO 58327
57505: LD_INT 2
57507: DOUBLE
57508: EQUAL
57509: IFTRUE 57513
57511: GO 58315
57513: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57514: LD_VAR 0 6
57518: PPUSH
57519: CALL_OW 264
57523: PUSH
57524: LD_INT 2
57526: PUSH
57527: LD_INT 42
57529: PUSH
57530: LD_INT 24
57532: PUSH
57533: EMPTY
57534: LIST
57535: LIST
57536: LIST
57537: IN
57538: IFFALSE 57559
// points := [ 25 , 5 , 3 ] ;
57540: LD_ADDR_VAR 0 9
57544: PUSH
57545: LD_INT 25
57547: PUSH
57548: LD_INT 5
57550: PUSH
57551: LD_INT 3
57553: PUSH
57554: EMPTY
57555: LIST
57556: LIST
57557: LIST
57558: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57559: LD_VAR 0 6
57563: PPUSH
57564: CALL_OW 264
57568: PUSH
57569: LD_INT 4
57571: PUSH
57572: LD_INT 43
57574: PUSH
57575: LD_INT 25
57577: PUSH
57578: EMPTY
57579: LIST
57580: LIST
57581: LIST
57582: IN
57583: IFFALSE 57604
// points := [ 40 , 15 , 5 ] ;
57585: LD_ADDR_VAR 0 9
57589: PUSH
57590: LD_INT 40
57592: PUSH
57593: LD_INT 15
57595: PUSH
57596: LD_INT 5
57598: PUSH
57599: EMPTY
57600: LIST
57601: LIST
57602: LIST
57603: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57604: LD_VAR 0 6
57608: PPUSH
57609: CALL_OW 264
57613: PUSH
57614: LD_INT 3
57616: PUSH
57617: LD_INT 23
57619: PUSH
57620: EMPTY
57621: LIST
57622: LIST
57623: IN
57624: IFFALSE 57645
// points := [ 7 , 25 , 8 ] ;
57626: LD_ADDR_VAR 0 9
57630: PUSH
57631: LD_INT 7
57633: PUSH
57634: LD_INT 25
57636: PUSH
57637: LD_INT 8
57639: PUSH
57640: EMPTY
57641: LIST
57642: LIST
57643: LIST
57644: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
57645: LD_VAR 0 6
57649: PPUSH
57650: CALL_OW 264
57654: PUSH
57655: LD_INT 5
57657: PUSH
57658: LD_INT 27
57660: PUSH
57661: LD_INT 44
57663: PUSH
57664: EMPTY
57665: LIST
57666: LIST
57667: LIST
57668: IN
57669: IFFALSE 57690
// points := [ 14 , 50 , 16 ] ;
57671: LD_ADDR_VAR 0 9
57675: PUSH
57676: LD_INT 14
57678: PUSH
57679: LD_INT 50
57681: PUSH
57682: LD_INT 16
57684: PUSH
57685: EMPTY
57686: LIST
57687: LIST
57688: LIST
57689: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
57690: LD_VAR 0 6
57694: PPUSH
57695: CALL_OW 264
57699: PUSH
57700: LD_INT 6
57702: PUSH
57703: LD_INT 46
57705: PUSH
57706: EMPTY
57707: LIST
57708: LIST
57709: IN
57710: IFFALSE 57731
// points := [ 32 , 120 , 70 ] ;
57712: LD_ADDR_VAR 0 9
57716: PUSH
57717: LD_INT 32
57719: PUSH
57720: LD_INT 120
57722: PUSH
57723: LD_INT 70
57725: PUSH
57726: EMPTY
57727: LIST
57728: LIST
57729: LIST
57730: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
57731: LD_VAR 0 6
57735: PPUSH
57736: CALL_OW 264
57740: PUSH
57741: LD_INT 7
57743: PUSH
57744: LD_INT 28
57746: PUSH
57747: LD_INT 45
57749: PUSH
57750: EMPTY
57751: LIST
57752: LIST
57753: LIST
57754: IN
57755: IFFALSE 57776
// points := [ 35 , 20 , 45 ] ;
57757: LD_ADDR_VAR 0 9
57761: PUSH
57762: LD_INT 35
57764: PUSH
57765: LD_INT 20
57767: PUSH
57768: LD_INT 45
57770: PUSH
57771: EMPTY
57772: LIST
57773: LIST
57774: LIST
57775: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
57776: LD_VAR 0 6
57780: PPUSH
57781: CALL_OW 264
57785: PUSH
57786: LD_INT 47
57788: PUSH
57789: EMPTY
57790: LIST
57791: IN
57792: IFFALSE 57813
// points := [ 67 , 45 , 75 ] ;
57794: LD_ADDR_VAR 0 9
57798: PUSH
57799: LD_INT 67
57801: PUSH
57802: LD_INT 45
57804: PUSH
57805: LD_INT 75
57807: PUSH
57808: EMPTY
57809: LIST
57810: LIST
57811: LIST
57812: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
57813: LD_VAR 0 6
57817: PPUSH
57818: CALL_OW 264
57822: PUSH
57823: LD_INT 26
57825: PUSH
57826: EMPTY
57827: LIST
57828: IN
57829: IFFALSE 57850
// points := [ 120 , 30 , 80 ] ;
57831: LD_ADDR_VAR 0 9
57835: PUSH
57836: LD_INT 120
57838: PUSH
57839: LD_INT 30
57841: PUSH
57842: LD_INT 80
57844: PUSH
57845: EMPTY
57846: LIST
57847: LIST
57848: LIST
57849: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
57850: LD_VAR 0 6
57854: PPUSH
57855: CALL_OW 264
57859: PUSH
57860: LD_INT 22
57862: PUSH
57863: EMPTY
57864: LIST
57865: IN
57866: IFFALSE 57887
// points := [ 40 , 1 , 1 ] ;
57868: LD_ADDR_VAR 0 9
57872: PUSH
57873: LD_INT 40
57875: PUSH
57876: LD_INT 1
57878: PUSH
57879: LD_INT 1
57881: PUSH
57882: EMPTY
57883: LIST
57884: LIST
57885: LIST
57886: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
57887: LD_VAR 0 6
57891: PPUSH
57892: CALL_OW 264
57896: PUSH
57897: LD_INT 29
57899: PUSH
57900: EMPTY
57901: LIST
57902: IN
57903: IFFALSE 57924
// points := [ 70 , 200 , 400 ] ;
57905: LD_ADDR_VAR 0 9
57909: PUSH
57910: LD_INT 70
57912: PUSH
57913: LD_INT 200
57915: PUSH
57916: LD_INT 400
57918: PUSH
57919: EMPTY
57920: LIST
57921: LIST
57922: LIST
57923: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
57924: LD_VAR 0 6
57928: PPUSH
57929: CALL_OW 264
57933: PUSH
57934: LD_INT 14
57936: PUSH
57937: LD_INT 53
57939: PUSH
57940: EMPTY
57941: LIST
57942: LIST
57943: IN
57944: IFFALSE 57965
// points := [ 40 , 10 , 20 ] ;
57946: LD_ADDR_VAR 0 9
57950: PUSH
57951: LD_INT 40
57953: PUSH
57954: LD_INT 10
57956: PUSH
57957: LD_INT 20
57959: PUSH
57960: EMPTY
57961: LIST
57962: LIST
57963: LIST
57964: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
57965: LD_VAR 0 6
57969: PPUSH
57970: CALL_OW 264
57974: PUSH
57975: LD_INT 9
57977: PUSH
57978: EMPTY
57979: LIST
57980: IN
57981: IFFALSE 58002
// points := [ 5 , 70 , 20 ] ;
57983: LD_ADDR_VAR 0 9
57987: PUSH
57988: LD_INT 5
57990: PUSH
57991: LD_INT 70
57993: PUSH
57994: LD_INT 20
57996: PUSH
57997: EMPTY
57998: LIST
57999: LIST
58000: LIST
58001: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
58002: LD_VAR 0 6
58006: PPUSH
58007: CALL_OW 264
58011: PUSH
58012: LD_INT 10
58014: PUSH
58015: EMPTY
58016: LIST
58017: IN
58018: IFFALSE 58039
// points := [ 35 , 110 , 70 ] ;
58020: LD_ADDR_VAR 0 9
58024: PUSH
58025: LD_INT 35
58027: PUSH
58028: LD_INT 110
58030: PUSH
58031: LD_INT 70
58033: PUSH
58034: EMPTY
58035: LIST
58036: LIST
58037: LIST
58038: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58039: LD_VAR 0 6
58043: PPUSH
58044: CALL_OW 265
58048: PUSH
58049: LD_INT 25
58051: EQUAL
58052: IFFALSE 58073
// points := [ 80 , 65 , 100 ] ;
58054: LD_ADDR_VAR 0 9
58058: PUSH
58059: LD_INT 80
58061: PUSH
58062: LD_INT 65
58064: PUSH
58065: LD_INT 100
58067: PUSH
58068: EMPTY
58069: LIST
58070: LIST
58071: LIST
58072: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58073: LD_VAR 0 6
58077: PPUSH
58078: CALL_OW 263
58082: PUSH
58083: LD_INT 1
58085: EQUAL
58086: IFFALSE 58121
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58088: LD_ADDR_VAR 0 10
58092: PUSH
58093: LD_VAR 0 10
58097: PUSH
58098: LD_VAR 0 6
58102: PPUSH
58103: CALL_OW 311
58107: PPUSH
58108: LD_INT 3
58110: PPUSH
58111: CALL_OW 259
58115: PUSH
58116: LD_INT 4
58118: MUL
58119: MUL
58120: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58121: LD_VAR 0 6
58125: PPUSH
58126: CALL_OW 263
58130: PUSH
58131: LD_INT 2
58133: EQUAL
58134: IFFALSE 58185
// begin j := IsControledBy ( i ) ;
58136: LD_ADDR_VAR 0 7
58140: PUSH
58141: LD_VAR 0 6
58145: PPUSH
58146: CALL_OW 312
58150: ST_TO_ADDR
// if j then
58151: LD_VAR 0 7
58155: IFFALSE 58185
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58157: LD_ADDR_VAR 0 10
58161: PUSH
58162: LD_VAR 0 10
58166: PUSH
58167: LD_VAR 0 7
58171: PPUSH
58172: LD_INT 3
58174: PPUSH
58175: CALL_OW 259
58179: PUSH
58180: LD_INT 3
58182: MUL
58183: MUL
58184: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58185: LD_VAR 0 6
58189: PPUSH
58190: CALL_OW 264
58194: PUSH
58195: LD_INT 5
58197: PUSH
58198: LD_INT 6
58200: PUSH
58201: LD_INT 46
58203: PUSH
58204: LD_INT 44
58206: PUSH
58207: LD_INT 47
58209: PUSH
58210: LD_INT 45
58212: PUSH
58213: LD_INT 28
58215: PUSH
58216: LD_INT 7
58218: PUSH
58219: LD_INT 27
58221: PUSH
58222: LD_INT 29
58224: PUSH
58225: EMPTY
58226: LIST
58227: LIST
58228: LIST
58229: LIST
58230: LIST
58231: LIST
58232: LIST
58233: LIST
58234: LIST
58235: LIST
58236: IN
58237: PUSH
58238: LD_VAR 0 1
58242: PPUSH
58243: LD_INT 52
58245: PPUSH
58246: CALL_OW 321
58250: PUSH
58251: LD_INT 2
58253: EQUAL
58254: AND
58255: IFFALSE 58272
// bpoints := bpoints * 1.2 ;
58257: LD_ADDR_VAR 0 10
58261: PUSH
58262: LD_VAR 0 10
58266: PUSH
58267: LD_REAL  1.20000000000000E+0000
58270: MUL
58271: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58272: LD_VAR 0 6
58276: PPUSH
58277: CALL_OW 264
58281: PUSH
58282: LD_INT 6
58284: PUSH
58285: LD_INT 46
58287: PUSH
58288: LD_INT 47
58290: PUSH
58291: EMPTY
58292: LIST
58293: LIST
58294: LIST
58295: IN
58296: IFFALSE 58313
// bpoints := bpoints * 1.2 ;
58298: LD_ADDR_VAR 0 10
58302: PUSH
58303: LD_VAR 0 10
58307: PUSH
58308: LD_REAL  1.20000000000000E+0000
58311: MUL
58312: ST_TO_ADDR
// end ; unit_building :
58313: GO 58327
58315: LD_INT 3
58317: DOUBLE
58318: EQUAL
58319: IFTRUE 58323
58321: GO 58326
58323: POP
// ; end ;
58324: GO 58327
58326: POP
// for j = 1 to 3 do
58327: LD_ADDR_VAR 0 7
58331: PUSH
58332: DOUBLE
58333: LD_INT 1
58335: DEC
58336: ST_TO_ADDR
58337: LD_INT 3
58339: PUSH
58340: FOR_TO
58341: IFFALSE 58394
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58343: LD_ADDR_VAR 0 5
58347: PUSH
58348: LD_VAR 0 5
58352: PPUSH
58353: LD_VAR 0 7
58357: PPUSH
58358: LD_VAR 0 5
58362: PUSH
58363: LD_VAR 0 7
58367: ARRAY
58368: PUSH
58369: LD_VAR 0 9
58373: PUSH
58374: LD_VAR 0 7
58378: ARRAY
58379: PUSH
58380: LD_VAR 0 10
58384: MUL
58385: PLUS
58386: PPUSH
58387: CALL_OW 1
58391: ST_TO_ADDR
58392: GO 58340
58394: POP
58395: POP
// end ;
58396: GO 56879
58398: POP
58399: POP
// result := Replace ( result , 4 , tmp ) ;
58400: LD_ADDR_VAR 0 5
58404: PUSH
58405: LD_VAR 0 5
58409: PPUSH
58410: LD_INT 4
58412: PPUSH
58413: LD_VAR 0 8
58417: PPUSH
58418: CALL_OW 1
58422: ST_TO_ADDR
// end ;
58423: LD_VAR 0 5
58427: RET
// export function DangerAtRange ( unit , range ) ; begin
58428: LD_INT 0
58430: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58431: LD_ADDR_VAR 0 3
58435: PUSH
58436: LD_VAR 0 1
58440: PPUSH
58441: CALL_OW 255
58445: PPUSH
58446: LD_VAR 0 1
58450: PPUSH
58451: CALL_OW 250
58455: PPUSH
58456: LD_VAR 0 1
58460: PPUSH
58461: CALL_OW 251
58465: PPUSH
58466: LD_VAR 0 2
58470: PPUSH
58471: CALL 56731 0 4
58475: ST_TO_ADDR
// end ;
58476: LD_VAR 0 3
58480: RET
// export function DangerInArea ( side , area ) ; begin
58481: LD_INT 0
58483: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58484: LD_ADDR_VAR 0 3
58488: PUSH
58489: LD_VAR 0 2
58493: PPUSH
58494: LD_INT 81
58496: PUSH
58497: LD_VAR 0 1
58501: PUSH
58502: EMPTY
58503: LIST
58504: LIST
58505: PPUSH
58506: CALL_OW 70
58510: ST_TO_ADDR
// end ;
58511: LD_VAR 0 3
58515: RET
// export function IsExtension ( b ) ; begin
58516: LD_INT 0
58518: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58519: LD_ADDR_VAR 0 2
58523: PUSH
58524: LD_VAR 0 1
58528: PUSH
58529: LD_INT 23
58531: PUSH
58532: LD_INT 20
58534: PUSH
58535: LD_INT 22
58537: PUSH
58538: LD_INT 17
58540: PUSH
58541: LD_INT 24
58543: PUSH
58544: LD_INT 21
58546: PUSH
58547: LD_INT 19
58549: PUSH
58550: LD_INT 16
58552: PUSH
58553: LD_INT 25
58555: PUSH
58556: LD_INT 18
58558: PUSH
58559: EMPTY
58560: LIST
58561: LIST
58562: LIST
58563: LIST
58564: LIST
58565: LIST
58566: LIST
58567: LIST
58568: LIST
58569: LIST
58570: IN
58571: ST_TO_ADDR
// end ;
58572: LD_VAR 0 2
58576: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
58577: LD_INT 0
58579: PPUSH
58580: PPUSH
58581: PPUSH
// result := [ ] ;
58582: LD_ADDR_VAR 0 4
58586: PUSH
58587: EMPTY
58588: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58589: LD_ADDR_VAR 0 5
58593: PUSH
58594: LD_VAR 0 2
58598: PPUSH
58599: LD_INT 21
58601: PUSH
58602: LD_INT 3
58604: PUSH
58605: EMPTY
58606: LIST
58607: LIST
58608: PPUSH
58609: CALL_OW 70
58613: ST_TO_ADDR
// if not tmp then
58614: LD_VAR 0 5
58618: NOT
58619: IFFALSE 58623
// exit ;
58621: GO 58687
// if checkLink then
58623: LD_VAR 0 3
58627: IFFALSE 58677
// begin for i in tmp do
58629: LD_ADDR_VAR 0 6
58633: PUSH
58634: LD_VAR 0 5
58638: PUSH
58639: FOR_IN
58640: IFFALSE 58675
// if GetBase ( i ) <> base then
58642: LD_VAR 0 6
58646: PPUSH
58647: CALL_OW 274
58651: PUSH
58652: LD_VAR 0 1
58656: NONEQUAL
58657: IFFALSE 58673
// ComLinkToBase ( base , i ) ;
58659: LD_VAR 0 1
58663: PPUSH
58664: LD_VAR 0 6
58668: PPUSH
58669: CALL_OW 169
58673: GO 58639
58675: POP
58676: POP
// end ; result := tmp ;
58677: LD_ADDR_VAR 0 4
58681: PUSH
58682: LD_VAR 0 5
58686: ST_TO_ADDR
// end ;
58687: LD_VAR 0 4
58691: RET
// export function ComComplete ( units , b ) ; var i ; begin
58692: LD_INT 0
58694: PPUSH
58695: PPUSH
// if not units then
58696: LD_VAR 0 1
58700: NOT
58701: IFFALSE 58705
// exit ;
58703: GO 58795
// for i in units do
58705: LD_ADDR_VAR 0 4
58709: PUSH
58710: LD_VAR 0 1
58714: PUSH
58715: FOR_IN
58716: IFFALSE 58793
// if BuildingStatus ( b ) = bs_build then
58718: LD_VAR 0 2
58722: PPUSH
58723: CALL_OW 461
58727: PUSH
58728: LD_INT 1
58730: EQUAL
58731: IFFALSE 58791
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
58733: LD_VAR 0 4
58737: PPUSH
58738: LD_STRING h
58740: PUSH
58741: LD_VAR 0 2
58745: PPUSH
58746: CALL_OW 250
58750: PUSH
58751: LD_VAR 0 2
58755: PPUSH
58756: CALL_OW 251
58760: PUSH
58761: LD_VAR 0 2
58765: PUSH
58766: LD_INT 0
58768: PUSH
58769: LD_INT 0
58771: PUSH
58772: LD_INT 0
58774: PUSH
58775: EMPTY
58776: LIST
58777: LIST
58778: LIST
58779: LIST
58780: LIST
58781: LIST
58782: LIST
58783: PUSH
58784: EMPTY
58785: LIST
58786: PPUSH
58787: CALL_OW 446
58791: GO 58715
58793: POP
58794: POP
// end ;
58795: LD_VAR 0 3
58799: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
58800: LD_INT 0
58802: PPUSH
58803: PPUSH
58804: PPUSH
58805: PPUSH
58806: PPUSH
58807: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
58808: LD_VAR 0 1
58812: NOT
58813: PUSH
58814: LD_VAR 0 1
58818: PPUSH
58819: CALL_OW 263
58823: PUSH
58824: LD_INT 2
58826: EQUAL
58827: NOT
58828: OR
58829: IFFALSE 58833
// exit ;
58831: GO 59149
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
58833: LD_ADDR_VAR 0 6
58837: PUSH
58838: LD_INT 22
58840: PUSH
58841: LD_VAR 0 1
58845: PPUSH
58846: CALL_OW 255
58850: PUSH
58851: EMPTY
58852: LIST
58853: LIST
58854: PUSH
58855: LD_INT 2
58857: PUSH
58858: LD_INT 30
58860: PUSH
58861: LD_INT 36
58863: PUSH
58864: EMPTY
58865: LIST
58866: LIST
58867: PUSH
58868: LD_INT 34
58870: PUSH
58871: LD_INT 31
58873: PUSH
58874: EMPTY
58875: LIST
58876: LIST
58877: PUSH
58878: EMPTY
58879: LIST
58880: LIST
58881: LIST
58882: PUSH
58883: EMPTY
58884: LIST
58885: LIST
58886: PPUSH
58887: CALL_OW 69
58891: ST_TO_ADDR
// if not tmp then
58892: LD_VAR 0 6
58896: NOT
58897: IFFALSE 58901
// exit ;
58899: GO 59149
// result := [ ] ;
58901: LD_ADDR_VAR 0 2
58905: PUSH
58906: EMPTY
58907: ST_TO_ADDR
// for i in tmp do
58908: LD_ADDR_VAR 0 3
58912: PUSH
58913: LD_VAR 0 6
58917: PUSH
58918: FOR_IN
58919: IFFALSE 58990
// begin t := UnitsInside ( i ) ;
58921: LD_ADDR_VAR 0 4
58925: PUSH
58926: LD_VAR 0 3
58930: PPUSH
58931: CALL_OW 313
58935: ST_TO_ADDR
// if t then
58936: LD_VAR 0 4
58940: IFFALSE 58988
// for j in t do
58942: LD_ADDR_VAR 0 7
58946: PUSH
58947: LD_VAR 0 4
58951: PUSH
58952: FOR_IN
58953: IFFALSE 58986
// result := Insert ( result , result + 1 , j ) ;
58955: LD_ADDR_VAR 0 2
58959: PUSH
58960: LD_VAR 0 2
58964: PPUSH
58965: LD_VAR 0 2
58969: PUSH
58970: LD_INT 1
58972: PLUS
58973: PPUSH
58974: LD_VAR 0 7
58978: PPUSH
58979: CALL_OW 2
58983: ST_TO_ADDR
58984: GO 58952
58986: POP
58987: POP
// end ;
58988: GO 58918
58990: POP
58991: POP
// if not result then
58992: LD_VAR 0 2
58996: NOT
58997: IFFALSE 59001
// exit ;
58999: GO 59149
// mech := result [ 1 ] ;
59001: LD_ADDR_VAR 0 5
59005: PUSH
59006: LD_VAR 0 2
59010: PUSH
59011: LD_INT 1
59013: ARRAY
59014: ST_TO_ADDR
// if result > 1 then
59015: LD_VAR 0 2
59019: PUSH
59020: LD_INT 1
59022: GREATER
59023: IFFALSE 59135
// for i = 2 to result do
59025: LD_ADDR_VAR 0 3
59029: PUSH
59030: DOUBLE
59031: LD_INT 2
59033: DEC
59034: ST_TO_ADDR
59035: LD_VAR 0 2
59039: PUSH
59040: FOR_TO
59041: IFFALSE 59133
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
59043: LD_ADDR_VAR 0 4
59047: PUSH
59048: LD_VAR 0 2
59052: PUSH
59053: LD_VAR 0 3
59057: ARRAY
59058: PPUSH
59059: LD_INT 3
59061: PPUSH
59062: CALL_OW 259
59066: PUSH
59067: LD_VAR 0 2
59071: PUSH
59072: LD_VAR 0 3
59076: ARRAY
59077: PPUSH
59078: CALL_OW 432
59082: MINUS
59083: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59084: LD_VAR 0 4
59088: PUSH
59089: LD_VAR 0 5
59093: PPUSH
59094: LD_INT 3
59096: PPUSH
59097: CALL_OW 259
59101: PUSH
59102: LD_VAR 0 5
59106: PPUSH
59107: CALL_OW 432
59111: MINUS
59112: GREATEREQUAL
59113: IFFALSE 59131
// mech := result [ i ] ;
59115: LD_ADDR_VAR 0 5
59119: PUSH
59120: LD_VAR 0 2
59124: PUSH
59125: LD_VAR 0 3
59129: ARRAY
59130: ST_TO_ADDR
// end ;
59131: GO 59040
59133: POP
59134: POP
// ComLinkTo ( vehicle , mech ) ;
59135: LD_VAR 0 1
59139: PPUSH
59140: LD_VAR 0 5
59144: PPUSH
59145: CALL_OW 135
// end ;
59149: LD_VAR 0 2
59153: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59154: LD_INT 0
59156: PPUSH
59157: PPUSH
59158: PPUSH
59159: PPUSH
59160: PPUSH
59161: PPUSH
59162: PPUSH
59163: PPUSH
59164: PPUSH
59165: PPUSH
59166: PPUSH
59167: PPUSH
59168: PPUSH
// result := [ ] ;
59169: LD_ADDR_VAR 0 7
59173: PUSH
59174: EMPTY
59175: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59176: LD_VAR 0 1
59180: PPUSH
59181: CALL_OW 266
59185: PUSH
59186: LD_INT 0
59188: PUSH
59189: LD_INT 1
59191: PUSH
59192: EMPTY
59193: LIST
59194: LIST
59195: IN
59196: NOT
59197: IFFALSE 59201
// exit ;
59199: GO 60835
// if name then
59201: LD_VAR 0 3
59205: IFFALSE 59221
// SetBName ( base_dep , name ) ;
59207: LD_VAR 0 1
59211: PPUSH
59212: LD_VAR 0 3
59216: PPUSH
59217: CALL_OW 500
// base := GetBase ( base_dep ) ;
59221: LD_ADDR_VAR 0 15
59225: PUSH
59226: LD_VAR 0 1
59230: PPUSH
59231: CALL_OW 274
59235: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59236: LD_ADDR_VAR 0 16
59240: PUSH
59241: LD_VAR 0 1
59245: PPUSH
59246: CALL_OW 255
59250: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59251: LD_ADDR_VAR 0 17
59255: PUSH
59256: LD_VAR 0 1
59260: PPUSH
59261: CALL_OW 248
59265: ST_TO_ADDR
// if sources then
59266: LD_VAR 0 5
59270: IFFALSE 59317
// for i = 1 to 3 do
59272: LD_ADDR_VAR 0 8
59276: PUSH
59277: DOUBLE
59278: LD_INT 1
59280: DEC
59281: ST_TO_ADDR
59282: LD_INT 3
59284: PUSH
59285: FOR_TO
59286: IFFALSE 59315
// AddResourceType ( base , i , sources [ i ] ) ;
59288: LD_VAR 0 15
59292: PPUSH
59293: LD_VAR 0 8
59297: PPUSH
59298: LD_VAR 0 5
59302: PUSH
59303: LD_VAR 0 8
59307: ARRAY
59308: PPUSH
59309: CALL_OW 276
59313: GO 59285
59315: POP
59316: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
59317: LD_ADDR_VAR 0 18
59321: PUSH
59322: LD_VAR 0 15
59326: PPUSH
59327: LD_VAR 0 2
59331: PPUSH
59332: LD_INT 1
59334: PPUSH
59335: CALL 58577 0 3
59339: ST_TO_ADDR
// InitHc ;
59340: CALL_OW 19
// InitUc ;
59344: CALL_OW 18
// uc_side := side ;
59348: LD_ADDR_OWVAR 20
59352: PUSH
59353: LD_VAR 0 16
59357: ST_TO_ADDR
// uc_nation := nation ;
59358: LD_ADDR_OWVAR 21
59362: PUSH
59363: LD_VAR 0 17
59367: ST_TO_ADDR
// if buildings then
59368: LD_VAR 0 18
59372: IFFALSE 60694
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59374: LD_ADDR_VAR 0 19
59378: PUSH
59379: LD_VAR 0 18
59383: PPUSH
59384: LD_INT 2
59386: PUSH
59387: LD_INT 30
59389: PUSH
59390: LD_INT 29
59392: PUSH
59393: EMPTY
59394: LIST
59395: LIST
59396: PUSH
59397: LD_INT 30
59399: PUSH
59400: LD_INT 30
59402: PUSH
59403: EMPTY
59404: LIST
59405: LIST
59406: PUSH
59407: EMPTY
59408: LIST
59409: LIST
59410: LIST
59411: PPUSH
59412: CALL_OW 72
59416: ST_TO_ADDR
// if tmp then
59417: LD_VAR 0 19
59421: IFFALSE 59469
// for i in tmp do
59423: LD_ADDR_VAR 0 8
59427: PUSH
59428: LD_VAR 0 19
59432: PUSH
59433: FOR_IN
59434: IFFALSE 59467
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59436: LD_VAR 0 8
59440: PPUSH
59441: CALL_OW 250
59445: PPUSH
59446: LD_VAR 0 8
59450: PPUSH
59451: CALL_OW 251
59455: PPUSH
59456: LD_VAR 0 16
59460: PPUSH
59461: CALL_OW 441
59465: GO 59433
59467: POP
59468: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59469: LD_VAR 0 18
59473: PPUSH
59474: LD_INT 2
59476: PUSH
59477: LD_INT 30
59479: PUSH
59480: LD_INT 32
59482: PUSH
59483: EMPTY
59484: LIST
59485: LIST
59486: PUSH
59487: LD_INT 30
59489: PUSH
59490: LD_INT 33
59492: PUSH
59493: EMPTY
59494: LIST
59495: LIST
59496: PUSH
59497: EMPTY
59498: LIST
59499: LIST
59500: LIST
59501: PPUSH
59502: CALL_OW 72
59506: IFFALSE 59594
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59508: LD_ADDR_VAR 0 8
59512: PUSH
59513: LD_VAR 0 18
59517: PPUSH
59518: LD_INT 2
59520: PUSH
59521: LD_INT 30
59523: PUSH
59524: LD_INT 32
59526: PUSH
59527: EMPTY
59528: LIST
59529: LIST
59530: PUSH
59531: LD_INT 30
59533: PUSH
59534: LD_INT 33
59536: PUSH
59537: EMPTY
59538: LIST
59539: LIST
59540: PUSH
59541: EMPTY
59542: LIST
59543: LIST
59544: LIST
59545: PPUSH
59546: CALL_OW 72
59550: PUSH
59551: FOR_IN
59552: IFFALSE 59592
// begin if not GetBWeapon ( i ) then
59554: LD_VAR 0 8
59558: PPUSH
59559: CALL_OW 269
59563: NOT
59564: IFFALSE 59590
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59566: LD_VAR 0 8
59570: PPUSH
59571: LD_VAR 0 8
59575: PPUSH
59576: LD_VAR 0 2
59580: PPUSH
59581: CALL 60840 0 2
59585: PPUSH
59586: CALL_OW 431
// end ;
59590: GO 59551
59592: POP
59593: POP
// end ; for i = 1 to personel do
59594: LD_ADDR_VAR 0 8
59598: PUSH
59599: DOUBLE
59600: LD_INT 1
59602: DEC
59603: ST_TO_ADDR
59604: LD_VAR 0 6
59608: PUSH
59609: FOR_TO
59610: IFFALSE 60674
// begin if i > 4 then
59612: LD_VAR 0 8
59616: PUSH
59617: LD_INT 4
59619: GREATER
59620: IFFALSE 59624
// break ;
59622: GO 60674
// case i of 1 :
59624: LD_VAR 0 8
59628: PUSH
59629: LD_INT 1
59631: DOUBLE
59632: EQUAL
59633: IFTRUE 59637
59635: GO 59717
59637: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59638: LD_ADDR_VAR 0 12
59642: PUSH
59643: LD_VAR 0 18
59647: PPUSH
59648: LD_INT 22
59650: PUSH
59651: LD_VAR 0 16
59655: PUSH
59656: EMPTY
59657: LIST
59658: LIST
59659: PUSH
59660: LD_INT 58
59662: PUSH
59663: EMPTY
59664: LIST
59665: PUSH
59666: LD_INT 2
59668: PUSH
59669: LD_INT 30
59671: PUSH
59672: LD_INT 32
59674: PUSH
59675: EMPTY
59676: LIST
59677: LIST
59678: PUSH
59679: LD_INT 30
59681: PUSH
59682: LD_INT 4
59684: PUSH
59685: EMPTY
59686: LIST
59687: LIST
59688: PUSH
59689: LD_INT 30
59691: PUSH
59692: LD_INT 5
59694: PUSH
59695: EMPTY
59696: LIST
59697: LIST
59698: PUSH
59699: EMPTY
59700: LIST
59701: LIST
59702: LIST
59703: LIST
59704: PUSH
59705: EMPTY
59706: LIST
59707: LIST
59708: LIST
59709: PPUSH
59710: CALL_OW 72
59714: ST_TO_ADDR
59715: GO 59939
59717: LD_INT 2
59719: DOUBLE
59720: EQUAL
59721: IFTRUE 59725
59723: GO 59787
59725: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
59726: LD_ADDR_VAR 0 12
59730: PUSH
59731: LD_VAR 0 18
59735: PPUSH
59736: LD_INT 22
59738: PUSH
59739: LD_VAR 0 16
59743: PUSH
59744: EMPTY
59745: LIST
59746: LIST
59747: PUSH
59748: LD_INT 2
59750: PUSH
59751: LD_INT 30
59753: PUSH
59754: LD_INT 0
59756: PUSH
59757: EMPTY
59758: LIST
59759: LIST
59760: PUSH
59761: LD_INT 30
59763: PUSH
59764: LD_INT 1
59766: PUSH
59767: EMPTY
59768: LIST
59769: LIST
59770: PUSH
59771: EMPTY
59772: LIST
59773: LIST
59774: LIST
59775: PUSH
59776: EMPTY
59777: LIST
59778: LIST
59779: PPUSH
59780: CALL_OW 72
59784: ST_TO_ADDR
59785: GO 59939
59787: LD_INT 3
59789: DOUBLE
59790: EQUAL
59791: IFTRUE 59795
59793: GO 59857
59795: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
59796: LD_ADDR_VAR 0 12
59800: PUSH
59801: LD_VAR 0 18
59805: PPUSH
59806: LD_INT 22
59808: PUSH
59809: LD_VAR 0 16
59813: PUSH
59814: EMPTY
59815: LIST
59816: LIST
59817: PUSH
59818: LD_INT 2
59820: PUSH
59821: LD_INT 30
59823: PUSH
59824: LD_INT 2
59826: PUSH
59827: EMPTY
59828: LIST
59829: LIST
59830: PUSH
59831: LD_INT 30
59833: PUSH
59834: LD_INT 3
59836: PUSH
59837: EMPTY
59838: LIST
59839: LIST
59840: PUSH
59841: EMPTY
59842: LIST
59843: LIST
59844: LIST
59845: PUSH
59846: EMPTY
59847: LIST
59848: LIST
59849: PPUSH
59850: CALL_OW 72
59854: ST_TO_ADDR
59855: GO 59939
59857: LD_INT 4
59859: DOUBLE
59860: EQUAL
59861: IFTRUE 59865
59863: GO 59938
59865: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
59866: LD_ADDR_VAR 0 12
59870: PUSH
59871: LD_VAR 0 18
59875: PPUSH
59876: LD_INT 22
59878: PUSH
59879: LD_VAR 0 16
59883: PUSH
59884: EMPTY
59885: LIST
59886: LIST
59887: PUSH
59888: LD_INT 2
59890: PUSH
59891: LD_INT 30
59893: PUSH
59894: LD_INT 6
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: PUSH
59901: LD_INT 30
59903: PUSH
59904: LD_INT 7
59906: PUSH
59907: EMPTY
59908: LIST
59909: LIST
59910: PUSH
59911: LD_INT 30
59913: PUSH
59914: LD_INT 8
59916: PUSH
59917: EMPTY
59918: LIST
59919: LIST
59920: PUSH
59921: EMPTY
59922: LIST
59923: LIST
59924: LIST
59925: LIST
59926: PUSH
59927: EMPTY
59928: LIST
59929: LIST
59930: PPUSH
59931: CALL_OW 72
59935: ST_TO_ADDR
59936: GO 59939
59938: POP
// if i = 1 then
59939: LD_VAR 0 8
59943: PUSH
59944: LD_INT 1
59946: EQUAL
59947: IFFALSE 60058
// begin tmp := [ ] ;
59949: LD_ADDR_VAR 0 19
59953: PUSH
59954: EMPTY
59955: ST_TO_ADDR
// for j in f do
59956: LD_ADDR_VAR 0 9
59960: PUSH
59961: LD_VAR 0 12
59965: PUSH
59966: FOR_IN
59967: IFFALSE 60040
// if GetBType ( j ) = b_bunker then
59969: LD_VAR 0 9
59973: PPUSH
59974: CALL_OW 266
59978: PUSH
59979: LD_INT 32
59981: EQUAL
59982: IFFALSE 60009
// tmp := Insert ( tmp , 1 , j ) else
59984: LD_ADDR_VAR 0 19
59988: PUSH
59989: LD_VAR 0 19
59993: PPUSH
59994: LD_INT 1
59996: PPUSH
59997: LD_VAR 0 9
60001: PPUSH
60002: CALL_OW 2
60006: ST_TO_ADDR
60007: GO 60038
// tmp := Insert ( tmp , tmp + 1 , j ) ;
60009: LD_ADDR_VAR 0 19
60013: PUSH
60014: LD_VAR 0 19
60018: PPUSH
60019: LD_VAR 0 19
60023: PUSH
60024: LD_INT 1
60026: PLUS
60027: PPUSH
60028: LD_VAR 0 9
60032: PPUSH
60033: CALL_OW 2
60037: ST_TO_ADDR
60038: GO 59966
60040: POP
60041: POP
// if tmp then
60042: LD_VAR 0 19
60046: IFFALSE 60058
// f := tmp ;
60048: LD_ADDR_VAR 0 12
60052: PUSH
60053: LD_VAR 0 19
60057: ST_TO_ADDR
// end ; x := personel [ i ] ;
60058: LD_ADDR_VAR 0 13
60062: PUSH
60063: LD_VAR 0 6
60067: PUSH
60068: LD_VAR 0 8
60072: ARRAY
60073: ST_TO_ADDR
// if x = - 1 then
60074: LD_VAR 0 13
60078: PUSH
60079: LD_INT 1
60081: NEG
60082: EQUAL
60083: IFFALSE 60292
// begin for j in f do
60085: LD_ADDR_VAR 0 9
60089: PUSH
60090: LD_VAR 0 12
60094: PUSH
60095: FOR_IN
60096: IFFALSE 60288
// repeat InitHc ;
60098: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60102: LD_VAR 0 9
60106: PPUSH
60107: CALL_OW 266
60111: PUSH
60112: LD_INT 5
60114: EQUAL
60115: IFFALSE 60185
// begin if UnitsInside ( j ) < 3 then
60117: LD_VAR 0 9
60121: PPUSH
60122: CALL_OW 313
60126: PUSH
60127: LD_INT 3
60129: LESS
60130: IFFALSE 60166
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60132: LD_INT 0
60134: PPUSH
60135: LD_INT 5
60137: PUSH
60138: LD_INT 8
60140: PUSH
60141: LD_INT 9
60143: PUSH
60144: EMPTY
60145: LIST
60146: LIST
60147: LIST
60148: PUSH
60149: LD_VAR 0 17
60153: ARRAY
60154: PPUSH
60155: LD_VAR 0 4
60159: PPUSH
60160: CALL_OW 380
60164: GO 60183
// PrepareHuman ( false , i , skill ) ;
60166: LD_INT 0
60168: PPUSH
60169: LD_VAR 0 8
60173: PPUSH
60174: LD_VAR 0 4
60178: PPUSH
60179: CALL_OW 380
// end else
60183: GO 60202
// PrepareHuman ( false , i , skill ) ;
60185: LD_INT 0
60187: PPUSH
60188: LD_VAR 0 8
60192: PPUSH
60193: LD_VAR 0 4
60197: PPUSH
60198: CALL_OW 380
// un := CreateHuman ;
60202: LD_ADDR_VAR 0 14
60206: PUSH
60207: CALL_OW 44
60211: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60212: LD_ADDR_VAR 0 7
60216: PUSH
60217: LD_VAR 0 7
60221: PPUSH
60222: LD_INT 1
60224: PPUSH
60225: LD_VAR 0 14
60229: PPUSH
60230: CALL_OW 2
60234: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60235: LD_VAR 0 14
60239: PPUSH
60240: LD_VAR 0 9
60244: PPUSH
60245: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60249: LD_VAR 0 9
60253: PPUSH
60254: CALL_OW 313
60258: PUSH
60259: LD_INT 6
60261: EQUAL
60262: PUSH
60263: LD_VAR 0 9
60267: PPUSH
60268: CALL_OW 266
60272: PUSH
60273: LD_INT 32
60275: PUSH
60276: LD_INT 31
60278: PUSH
60279: EMPTY
60280: LIST
60281: LIST
60282: IN
60283: OR
60284: IFFALSE 60098
60286: GO 60095
60288: POP
60289: POP
// end else
60290: GO 60672
// for j = 1 to x do
60292: LD_ADDR_VAR 0 9
60296: PUSH
60297: DOUBLE
60298: LD_INT 1
60300: DEC
60301: ST_TO_ADDR
60302: LD_VAR 0 13
60306: PUSH
60307: FOR_TO
60308: IFFALSE 60670
// begin InitHc ;
60310: CALL_OW 19
// if not f then
60314: LD_VAR 0 12
60318: NOT
60319: IFFALSE 60408
// begin PrepareHuman ( false , i , skill ) ;
60321: LD_INT 0
60323: PPUSH
60324: LD_VAR 0 8
60328: PPUSH
60329: LD_VAR 0 4
60333: PPUSH
60334: CALL_OW 380
// un := CreateHuman ;
60338: LD_ADDR_VAR 0 14
60342: PUSH
60343: CALL_OW 44
60347: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60348: LD_ADDR_VAR 0 7
60352: PUSH
60353: LD_VAR 0 7
60357: PPUSH
60358: LD_INT 1
60360: PPUSH
60361: LD_VAR 0 14
60365: PPUSH
60366: CALL_OW 2
60370: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60371: LD_VAR 0 14
60375: PPUSH
60376: LD_VAR 0 1
60380: PPUSH
60381: CALL_OW 250
60385: PPUSH
60386: LD_VAR 0 1
60390: PPUSH
60391: CALL_OW 251
60395: PPUSH
60396: LD_INT 10
60398: PPUSH
60399: LD_INT 0
60401: PPUSH
60402: CALL_OW 50
// continue ;
60406: GO 60307
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60408: LD_VAR 0 12
60412: PUSH
60413: LD_INT 1
60415: ARRAY
60416: PPUSH
60417: CALL_OW 313
60421: PUSH
60422: LD_VAR 0 12
60426: PUSH
60427: LD_INT 1
60429: ARRAY
60430: PPUSH
60431: CALL_OW 266
60435: PUSH
60436: LD_INT 32
60438: PUSH
60439: LD_INT 31
60441: PUSH
60442: EMPTY
60443: LIST
60444: LIST
60445: IN
60446: AND
60447: PUSH
60448: LD_VAR 0 12
60452: PUSH
60453: LD_INT 1
60455: ARRAY
60456: PPUSH
60457: CALL_OW 313
60461: PUSH
60462: LD_INT 6
60464: EQUAL
60465: OR
60466: IFFALSE 60486
// f := Delete ( f , 1 ) ;
60468: LD_ADDR_VAR 0 12
60472: PUSH
60473: LD_VAR 0 12
60477: PPUSH
60478: LD_INT 1
60480: PPUSH
60481: CALL_OW 3
60485: ST_TO_ADDR
// if not f then
60486: LD_VAR 0 12
60490: NOT
60491: IFFALSE 60509
// begin x := x + 2 ;
60493: LD_ADDR_VAR 0 13
60497: PUSH
60498: LD_VAR 0 13
60502: PUSH
60503: LD_INT 2
60505: PLUS
60506: ST_TO_ADDR
// continue ;
60507: GO 60307
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60509: LD_VAR 0 12
60513: PUSH
60514: LD_INT 1
60516: ARRAY
60517: PPUSH
60518: CALL_OW 266
60522: PUSH
60523: LD_INT 5
60525: EQUAL
60526: IFFALSE 60600
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60528: LD_VAR 0 12
60532: PUSH
60533: LD_INT 1
60535: ARRAY
60536: PPUSH
60537: CALL_OW 313
60541: PUSH
60542: LD_INT 3
60544: LESS
60545: IFFALSE 60581
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60547: LD_INT 0
60549: PPUSH
60550: LD_INT 5
60552: PUSH
60553: LD_INT 8
60555: PUSH
60556: LD_INT 9
60558: PUSH
60559: EMPTY
60560: LIST
60561: LIST
60562: LIST
60563: PUSH
60564: LD_VAR 0 17
60568: ARRAY
60569: PPUSH
60570: LD_VAR 0 4
60574: PPUSH
60575: CALL_OW 380
60579: GO 60598
// PrepareHuman ( false , i , skill ) ;
60581: LD_INT 0
60583: PPUSH
60584: LD_VAR 0 8
60588: PPUSH
60589: LD_VAR 0 4
60593: PPUSH
60594: CALL_OW 380
// end else
60598: GO 60617
// PrepareHuman ( false , i , skill ) ;
60600: LD_INT 0
60602: PPUSH
60603: LD_VAR 0 8
60607: PPUSH
60608: LD_VAR 0 4
60612: PPUSH
60613: CALL_OW 380
// un := CreateHuman ;
60617: LD_ADDR_VAR 0 14
60621: PUSH
60622: CALL_OW 44
60626: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60627: LD_ADDR_VAR 0 7
60631: PUSH
60632: LD_VAR 0 7
60636: PPUSH
60637: LD_INT 1
60639: PPUSH
60640: LD_VAR 0 14
60644: PPUSH
60645: CALL_OW 2
60649: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
60650: LD_VAR 0 14
60654: PPUSH
60655: LD_VAR 0 12
60659: PUSH
60660: LD_INT 1
60662: ARRAY
60663: PPUSH
60664: CALL_OW 52
// end ;
60668: GO 60307
60670: POP
60671: POP
// end ;
60672: GO 59609
60674: POP
60675: POP
// result := result ^ buildings ;
60676: LD_ADDR_VAR 0 7
60680: PUSH
60681: LD_VAR 0 7
60685: PUSH
60686: LD_VAR 0 18
60690: ADD
60691: ST_TO_ADDR
// end else
60692: GO 60835
// begin for i = 1 to personel do
60694: LD_ADDR_VAR 0 8
60698: PUSH
60699: DOUBLE
60700: LD_INT 1
60702: DEC
60703: ST_TO_ADDR
60704: LD_VAR 0 6
60708: PUSH
60709: FOR_TO
60710: IFFALSE 60833
// begin if i > 4 then
60712: LD_VAR 0 8
60716: PUSH
60717: LD_INT 4
60719: GREATER
60720: IFFALSE 60724
// break ;
60722: GO 60833
// x := personel [ i ] ;
60724: LD_ADDR_VAR 0 13
60728: PUSH
60729: LD_VAR 0 6
60733: PUSH
60734: LD_VAR 0 8
60738: ARRAY
60739: ST_TO_ADDR
// if x = - 1 then
60740: LD_VAR 0 13
60744: PUSH
60745: LD_INT 1
60747: NEG
60748: EQUAL
60749: IFFALSE 60753
// continue ;
60751: GO 60709
// PrepareHuman ( false , i , skill ) ;
60753: LD_INT 0
60755: PPUSH
60756: LD_VAR 0 8
60760: PPUSH
60761: LD_VAR 0 4
60765: PPUSH
60766: CALL_OW 380
// un := CreateHuman ;
60770: LD_ADDR_VAR 0 14
60774: PUSH
60775: CALL_OW 44
60779: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60780: LD_VAR 0 14
60784: PPUSH
60785: LD_VAR 0 1
60789: PPUSH
60790: CALL_OW 250
60794: PPUSH
60795: LD_VAR 0 1
60799: PPUSH
60800: CALL_OW 251
60804: PPUSH
60805: LD_INT 10
60807: PPUSH
60808: LD_INT 0
60810: PPUSH
60811: CALL_OW 50
// result := result ^ un ;
60815: LD_ADDR_VAR 0 7
60819: PUSH
60820: LD_VAR 0 7
60824: PUSH
60825: LD_VAR 0 14
60829: ADD
60830: ST_TO_ADDR
// end ;
60831: GO 60709
60833: POP
60834: POP
// end ; end ;
60835: LD_VAR 0 7
60839: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
60840: LD_INT 0
60842: PPUSH
60843: PPUSH
60844: PPUSH
60845: PPUSH
60846: PPUSH
60847: PPUSH
60848: PPUSH
60849: PPUSH
60850: PPUSH
60851: PPUSH
60852: PPUSH
60853: PPUSH
60854: PPUSH
60855: PPUSH
60856: PPUSH
60857: PPUSH
// result := false ;
60858: LD_ADDR_VAR 0 3
60862: PUSH
60863: LD_INT 0
60865: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
60866: LD_VAR 0 1
60870: NOT
60871: PUSH
60872: LD_VAR 0 1
60876: PPUSH
60877: CALL_OW 266
60881: PUSH
60882: LD_INT 32
60884: PUSH
60885: LD_INT 33
60887: PUSH
60888: EMPTY
60889: LIST
60890: LIST
60891: IN
60892: NOT
60893: OR
60894: IFFALSE 60898
// exit ;
60896: GO 62037
// nat := GetNation ( tower ) ;
60898: LD_ADDR_VAR 0 12
60902: PUSH
60903: LD_VAR 0 1
60907: PPUSH
60908: CALL_OW 248
60912: ST_TO_ADDR
// side := GetSide ( tower ) ;
60913: LD_ADDR_VAR 0 16
60917: PUSH
60918: LD_VAR 0 1
60922: PPUSH
60923: CALL_OW 255
60927: ST_TO_ADDR
// x := GetX ( tower ) ;
60928: LD_ADDR_VAR 0 10
60932: PUSH
60933: LD_VAR 0 1
60937: PPUSH
60938: CALL_OW 250
60942: ST_TO_ADDR
// y := GetY ( tower ) ;
60943: LD_ADDR_VAR 0 11
60947: PUSH
60948: LD_VAR 0 1
60952: PPUSH
60953: CALL_OW 251
60957: ST_TO_ADDR
// if not x or not y then
60958: LD_VAR 0 10
60962: NOT
60963: PUSH
60964: LD_VAR 0 11
60968: NOT
60969: OR
60970: IFFALSE 60974
// exit ;
60972: GO 62037
// weapon := 0 ;
60974: LD_ADDR_VAR 0 18
60978: PUSH
60979: LD_INT 0
60981: ST_TO_ADDR
// fac_list := [ ] ;
60982: LD_ADDR_VAR 0 17
60986: PUSH
60987: EMPTY
60988: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
60989: LD_ADDR_VAR 0 6
60993: PUSH
60994: LD_VAR 0 1
60998: PPUSH
60999: CALL_OW 274
61003: PPUSH
61004: LD_VAR 0 2
61008: PPUSH
61009: LD_INT 0
61011: PPUSH
61012: CALL 58577 0 3
61016: PPUSH
61017: LD_INT 30
61019: PUSH
61020: LD_INT 3
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: PPUSH
61027: CALL_OW 72
61031: ST_TO_ADDR
// if not factories then
61032: LD_VAR 0 6
61036: NOT
61037: IFFALSE 61041
// exit ;
61039: GO 62037
// for i in factories do
61041: LD_ADDR_VAR 0 8
61045: PUSH
61046: LD_VAR 0 6
61050: PUSH
61051: FOR_IN
61052: IFFALSE 61077
// fac_list := fac_list union AvailableWeaponList ( i ) ;
61054: LD_ADDR_VAR 0 17
61058: PUSH
61059: LD_VAR 0 17
61063: PUSH
61064: LD_VAR 0 8
61068: PPUSH
61069: CALL_OW 478
61073: UNION
61074: ST_TO_ADDR
61075: GO 61051
61077: POP
61078: POP
// if not fac_list then
61079: LD_VAR 0 17
61083: NOT
61084: IFFALSE 61088
// exit ;
61086: GO 62037
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61088: LD_ADDR_VAR 0 5
61092: PUSH
61093: LD_INT 4
61095: PUSH
61096: LD_INT 5
61098: PUSH
61099: LD_INT 9
61101: PUSH
61102: LD_INT 10
61104: PUSH
61105: LD_INT 6
61107: PUSH
61108: LD_INT 7
61110: PUSH
61111: LD_INT 11
61113: PUSH
61114: EMPTY
61115: LIST
61116: LIST
61117: LIST
61118: LIST
61119: LIST
61120: LIST
61121: LIST
61122: PUSH
61123: LD_INT 27
61125: PUSH
61126: LD_INT 28
61128: PUSH
61129: LD_INT 26
61131: PUSH
61132: LD_INT 30
61134: PUSH
61135: EMPTY
61136: LIST
61137: LIST
61138: LIST
61139: LIST
61140: PUSH
61141: LD_INT 43
61143: PUSH
61144: LD_INT 44
61146: PUSH
61147: LD_INT 46
61149: PUSH
61150: LD_INT 45
61152: PUSH
61153: LD_INT 47
61155: PUSH
61156: LD_INT 49
61158: PUSH
61159: EMPTY
61160: LIST
61161: LIST
61162: LIST
61163: LIST
61164: LIST
61165: LIST
61166: PUSH
61167: EMPTY
61168: LIST
61169: LIST
61170: LIST
61171: PUSH
61172: LD_VAR 0 12
61176: ARRAY
61177: ST_TO_ADDR
// for i in list do
61178: LD_ADDR_VAR 0 8
61182: PUSH
61183: LD_VAR 0 5
61187: PUSH
61188: FOR_IN
61189: IFFALSE 61222
// if not i in fac_list then
61191: LD_VAR 0 8
61195: PUSH
61196: LD_VAR 0 17
61200: IN
61201: NOT
61202: IFFALSE 61220
// list := list diff i ;
61204: LD_ADDR_VAR 0 5
61208: PUSH
61209: LD_VAR 0 5
61213: PUSH
61214: LD_VAR 0 8
61218: DIFF
61219: ST_TO_ADDR
61220: GO 61188
61222: POP
61223: POP
// if not list then
61224: LD_VAR 0 5
61228: NOT
61229: IFFALSE 61233
// exit ;
61231: GO 62037
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61233: LD_VAR 0 12
61237: PUSH
61238: LD_INT 3
61240: EQUAL
61241: PUSH
61242: LD_INT 49
61244: PUSH
61245: LD_VAR 0 5
61249: IN
61250: AND
61251: PUSH
61252: LD_INT 31
61254: PPUSH
61255: LD_VAR 0 16
61259: PPUSH
61260: CALL_OW 321
61264: PUSH
61265: LD_INT 2
61267: EQUAL
61268: AND
61269: IFFALSE 61329
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61271: LD_INT 22
61273: PUSH
61274: LD_VAR 0 16
61278: PUSH
61279: EMPTY
61280: LIST
61281: LIST
61282: PUSH
61283: LD_INT 35
61285: PUSH
61286: LD_INT 49
61288: PUSH
61289: EMPTY
61290: LIST
61291: LIST
61292: PUSH
61293: LD_INT 91
61295: PUSH
61296: LD_VAR 0 1
61300: PUSH
61301: LD_INT 10
61303: PUSH
61304: EMPTY
61305: LIST
61306: LIST
61307: LIST
61308: PUSH
61309: EMPTY
61310: LIST
61311: LIST
61312: LIST
61313: PPUSH
61314: CALL_OW 69
61318: NOT
61319: IFFALSE 61329
// weapon := ru_time_lapser ;
61321: LD_ADDR_VAR 0 18
61325: PUSH
61326: LD_INT 49
61328: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61329: LD_VAR 0 12
61333: PUSH
61334: LD_INT 1
61336: PUSH
61337: LD_INT 2
61339: PUSH
61340: EMPTY
61341: LIST
61342: LIST
61343: IN
61344: PUSH
61345: LD_INT 11
61347: PUSH
61348: LD_VAR 0 5
61352: IN
61353: PUSH
61354: LD_INT 30
61356: PUSH
61357: LD_VAR 0 5
61361: IN
61362: OR
61363: AND
61364: PUSH
61365: LD_INT 6
61367: PPUSH
61368: LD_VAR 0 16
61372: PPUSH
61373: CALL_OW 321
61377: PUSH
61378: LD_INT 2
61380: EQUAL
61381: AND
61382: IFFALSE 61547
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61384: LD_INT 22
61386: PUSH
61387: LD_VAR 0 16
61391: PUSH
61392: EMPTY
61393: LIST
61394: LIST
61395: PUSH
61396: LD_INT 2
61398: PUSH
61399: LD_INT 35
61401: PUSH
61402: LD_INT 11
61404: PUSH
61405: EMPTY
61406: LIST
61407: LIST
61408: PUSH
61409: LD_INT 35
61411: PUSH
61412: LD_INT 30
61414: PUSH
61415: EMPTY
61416: LIST
61417: LIST
61418: PUSH
61419: EMPTY
61420: LIST
61421: LIST
61422: LIST
61423: PUSH
61424: LD_INT 91
61426: PUSH
61427: LD_VAR 0 1
61431: PUSH
61432: LD_INT 18
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: LIST
61439: PUSH
61440: EMPTY
61441: LIST
61442: LIST
61443: LIST
61444: PPUSH
61445: CALL_OW 69
61449: NOT
61450: PUSH
61451: LD_INT 22
61453: PUSH
61454: LD_VAR 0 16
61458: PUSH
61459: EMPTY
61460: LIST
61461: LIST
61462: PUSH
61463: LD_INT 2
61465: PUSH
61466: LD_INT 30
61468: PUSH
61469: LD_INT 32
61471: PUSH
61472: EMPTY
61473: LIST
61474: LIST
61475: PUSH
61476: LD_INT 30
61478: PUSH
61479: LD_INT 33
61481: PUSH
61482: EMPTY
61483: LIST
61484: LIST
61485: PUSH
61486: EMPTY
61487: LIST
61488: LIST
61489: LIST
61490: PUSH
61491: LD_INT 91
61493: PUSH
61494: LD_VAR 0 1
61498: PUSH
61499: LD_INT 12
61501: PUSH
61502: EMPTY
61503: LIST
61504: LIST
61505: LIST
61506: PUSH
61507: EMPTY
61508: LIST
61509: LIST
61510: LIST
61511: PUSH
61512: EMPTY
61513: LIST
61514: PPUSH
61515: CALL_OW 69
61519: PUSH
61520: LD_INT 2
61522: GREATER
61523: AND
61524: IFFALSE 61547
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61526: LD_ADDR_VAR 0 18
61530: PUSH
61531: LD_INT 11
61533: PUSH
61534: LD_INT 30
61536: PUSH
61537: EMPTY
61538: LIST
61539: LIST
61540: PUSH
61541: LD_VAR 0 12
61545: ARRAY
61546: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61547: LD_VAR 0 18
61551: NOT
61552: PUSH
61553: LD_INT 40
61555: PPUSH
61556: LD_VAR 0 16
61560: PPUSH
61561: CALL_OW 321
61565: PUSH
61566: LD_INT 2
61568: EQUAL
61569: AND
61570: PUSH
61571: LD_INT 7
61573: PUSH
61574: LD_VAR 0 5
61578: IN
61579: PUSH
61580: LD_INT 28
61582: PUSH
61583: LD_VAR 0 5
61587: IN
61588: OR
61589: PUSH
61590: LD_INT 45
61592: PUSH
61593: LD_VAR 0 5
61597: IN
61598: OR
61599: AND
61600: IFFALSE 61854
// begin hex := GetHexInfo ( x , y ) ;
61602: LD_ADDR_VAR 0 4
61606: PUSH
61607: LD_VAR 0 10
61611: PPUSH
61612: LD_VAR 0 11
61616: PPUSH
61617: CALL_OW 546
61621: ST_TO_ADDR
// if hex [ 1 ] then
61622: LD_VAR 0 4
61626: PUSH
61627: LD_INT 1
61629: ARRAY
61630: IFFALSE 61634
// exit ;
61632: GO 62037
// height := hex [ 2 ] ;
61634: LD_ADDR_VAR 0 15
61638: PUSH
61639: LD_VAR 0 4
61643: PUSH
61644: LD_INT 2
61646: ARRAY
61647: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61648: LD_ADDR_VAR 0 14
61652: PUSH
61653: LD_INT 0
61655: PUSH
61656: LD_INT 2
61658: PUSH
61659: LD_INT 3
61661: PUSH
61662: LD_INT 5
61664: PUSH
61665: EMPTY
61666: LIST
61667: LIST
61668: LIST
61669: LIST
61670: ST_TO_ADDR
// for i in tmp do
61671: LD_ADDR_VAR 0 8
61675: PUSH
61676: LD_VAR 0 14
61680: PUSH
61681: FOR_IN
61682: IFFALSE 61852
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
61684: LD_ADDR_VAR 0 9
61688: PUSH
61689: LD_VAR 0 10
61693: PPUSH
61694: LD_VAR 0 8
61698: PPUSH
61699: LD_INT 5
61701: PPUSH
61702: CALL_OW 272
61706: PUSH
61707: LD_VAR 0 11
61711: PPUSH
61712: LD_VAR 0 8
61716: PPUSH
61717: LD_INT 5
61719: PPUSH
61720: CALL_OW 273
61724: PUSH
61725: EMPTY
61726: LIST
61727: LIST
61728: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
61729: LD_VAR 0 9
61733: PUSH
61734: LD_INT 1
61736: ARRAY
61737: PPUSH
61738: LD_VAR 0 9
61742: PUSH
61743: LD_INT 2
61745: ARRAY
61746: PPUSH
61747: CALL_OW 488
61751: IFFALSE 61850
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
61753: LD_ADDR_VAR 0 4
61757: PUSH
61758: LD_VAR 0 9
61762: PUSH
61763: LD_INT 1
61765: ARRAY
61766: PPUSH
61767: LD_VAR 0 9
61771: PUSH
61772: LD_INT 2
61774: ARRAY
61775: PPUSH
61776: CALL_OW 546
61780: ST_TO_ADDR
// if hex [ 1 ] then
61781: LD_VAR 0 4
61785: PUSH
61786: LD_INT 1
61788: ARRAY
61789: IFFALSE 61793
// continue ;
61791: GO 61681
// h := hex [ 2 ] ;
61793: LD_ADDR_VAR 0 13
61797: PUSH
61798: LD_VAR 0 4
61802: PUSH
61803: LD_INT 2
61805: ARRAY
61806: ST_TO_ADDR
// if h + 7 < height then
61807: LD_VAR 0 13
61811: PUSH
61812: LD_INT 7
61814: PLUS
61815: PUSH
61816: LD_VAR 0 15
61820: LESS
61821: IFFALSE 61850
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
61823: LD_ADDR_VAR 0 18
61827: PUSH
61828: LD_INT 7
61830: PUSH
61831: LD_INT 28
61833: PUSH
61834: LD_INT 45
61836: PUSH
61837: EMPTY
61838: LIST
61839: LIST
61840: LIST
61841: PUSH
61842: LD_VAR 0 12
61846: ARRAY
61847: ST_TO_ADDR
// break ;
61848: GO 61852
// end ; end ; end ;
61850: GO 61681
61852: POP
61853: POP
// end ; if not weapon then
61854: LD_VAR 0 18
61858: NOT
61859: IFFALSE 61919
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
61861: LD_ADDR_VAR 0 5
61865: PUSH
61866: LD_VAR 0 5
61870: PUSH
61871: LD_INT 11
61873: PUSH
61874: LD_INT 30
61876: PUSH
61877: LD_INT 49
61879: PUSH
61880: EMPTY
61881: LIST
61882: LIST
61883: LIST
61884: DIFF
61885: ST_TO_ADDR
// if not list then
61886: LD_VAR 0 5
61890: NOT
61891: IFFALSE 61895
// exit ;
61893: GO 62037
// weapon := list [ rand ( 1 , list ) ] ;
61895: LD_ADDR_VAR 0 18
61899: PUSH
61900: LD_VAR 0 5
61904: PUSH
61905: LD_INT 1
61907: PPUSH
61908: LD_VAR 0 5
61912: PPUSH
61913: CALL_OW 12
61917: ARRAY
61918: ST_TO_ADDR
// end ; if weapon then
61919: LD_VAR 0 18
61923: IFFALSE 62037
// begin tmp := CostOfWeapon ( weapon ) ;
61925: LD_ADDR_VAR 0 14
61929: PUSH
61930: LD_VAR 0 18
61934: PPUSH
61935: CALL_OW 451
61939: ST_TO_ADDR
// j := GetBase ( tower ) ;
61940: LD_ADDR_VAR 0 9
61944: PUSH
61945: LD_VAR 0 1
61949: PPUSH
61950: CALL_OW 274
61954: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
61955: LD_VAR 0 9
61959: PPUSH
61960: LD_INT 1
61962: PPUSH
61963: CALL_OW 275
61967: PUSH
61968: LD_VAR 0 14
61972: PUSH
61973: LD_INT 1
61975: ARRAY
61976: GREATEREQUAL
61977: PUSH
61978: LD_VAR 0 9
61982: PPUSH
61983: LD_INT 2
61985: PPUSH
61986: CALL_OW 275
61990: PUSH
61991: LD_VAR 0 14
61995: PUSH
61996: LD_INT 2
61998: ARRAY
61999: GREATEREQUAL
62000: AND
62001: PUSH
62002: LD_VAR 0 9
62006: PPUSH
62007: LD_INT 3
62009: PPUSH
62010: CALL_OW 275
62014: PUSH
62015: LD_VAR 0 14
62019: PUSH
62020: LD_INT 3
62022: ARRAY
62023: GREATEREQUAL
62024: AND
62025: IFFALSE 62037
// result := weapon ;
62027: LD_ADDR_VAR 0 3
62031: PUSH
62032: LD_VAR 0 18
62036: ST_TO_ADDR
// end ; end ;
62037: LD_VAR 0 3
62041: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
62042: LD_INT 0
62044: PPUSH
62045: PPUSH
// result := true ;
62046: LD_ADDR_VAR 0 3
62050: PUSH
62051: LD_INT 1
62053: ST_TO_ADDR
// if array1 = array2 then
62054: LD_VAR 0 1
62058: PUSH
62059: LD_VAR 0 2
62063: EQUAL
62064: IFFALSE 62124
// begin for i = 1 to array1 do
62066: LD_ADDR_VAR 0 4
62070: PUSH
62071: DOUBLE
62072: LD_INT 1
62074: DEC
62075: ST_TO_ADDR
62076: LD_VAR 0 1
62080: PUSH
62081: FOR_TO
62082: IFFALSE 62120
// if array1 [ i ] <> array2 [ i ] then
62084: LD_VAR 0 1
62088: PUSH
62089: LD_VAR 0 4
62093: ARRAY
62094: PUSH
62095: LD_VAR 0 2
62099: PUSH
62100: LD_VAR 0 4
62104: ARRAY
62105: NONEQUAL
62106: IFFALSE 62118
// begin result := false ;
62108: LD_ADDR_VAR 0 3
62112: PUSH
62113: LD_INT 0
62115: ST_TO_ADDR
// break ;
62116: GO 62120
// end ;
62118: GO 62081
62120: POP
62121: POP
// end else
62122: GO 62132
// result := false ;
62124: LD_ADDR_VAR 0 3
62128: PUSH
62129: LD_INT 0
62131: ST_TO_ADDR
// end ;
62132: LD_VAR 0 3
62136: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
62137: LD_INT 0
62139: PPUSH
62140: PPUSH
// if not array1 or not array2 then
62141: LD_VAR 0 1
62145: NOT
62146: PUSH
62147: LD_VAR 0 2
62151: NOT
62152: OR
62153: IFFALSE 62157
// exit ;
62155: GO 62221
// result := true ;
62157: LD_ADDR_VAR 0 3
62161: PUSH
62162: LD_INT 1
62164: ST_TO_ADDR
// for i = 1 to array1 do
62165: LD_ADDR_VAR 0 4
62169: PUSH
62170: DOUBLE
62171: LD_INT 1
62173: DEC
62174: ST_TO_ADDR
62175: LD_VAR 0 1
62179: PUSH
62180: FOR_TO
62181: IFFALSE 62219
// if array1 [ i ] <> array2 [ i ] then
62183: LD_VAR 0 1
62187: PUSH
62188: LD_VAR 0 4
62192: ARRAY
62193: PUSH
62194: LD_VAR 0 2
62198: PUSH
62199: LD_VAR 0 4
62203: ARRAY
62204: NONEQUAL
62205: IFFALSE 62217
// begin result := false ;
62207: LD_ADDR_VAR 0 3
62211: PUSH
62212: LD_INT 0
62214: ST_TO_ADDR
// break ;
62215: GO 62219
// end ;
62217: GO 62180
62219: POP
62220: POP
// end ;
62221: LD_VAR 0 3
62225: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62226: LD_INT 0
62228: PPUSH
62229: PPUSH
62230: PPUSH
// pom := GetBase ( fac ) ;
62231: LD_ADDR_VAR 0 5
62235: PUSH
62236: LD_VAR 0 1
62240: PPUSH
62241: CALL_OW 274
62245: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62246: LD_ADDR_VAR 0 4
62250: PUSH
62251: LD_VAR 0 2
62255: PUSH
62256: LD_INT 1
62258: ARRAY
62259: PPUSH
62260: LD_VAR 0 2
62264: PUSH
62265: LD_INT 2
62267: ARRAY
62268: PPUSH
62269: LD_VAR 0 2
62273: PUSH
62274: LD_INT 3
62276: ARRAY
62277: PPUSH
62278: LD_VAR 0 2
62282: PUSH
62283: LD_INT 4
62285: ARRAY
62286: PPUSH
62287: CALL_OW 449
62291: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62292: LD_ADDR_VAR 0 3
62296: PUSH
62297: LD_VAR 0 5
62301: PPUSH
62302: LD_INT 1
62304: PPUSH
62305: CALL_OW 275
62309: PUSH
62310: LD_VAR 0 4
62314: PUSH
62315: LD_INT 1
62317: ARRAY
62318: GREATEREQUAL
62319: PUSH
62320: LD_VAR 0 5
62324: PPUSH
62325: LD_INT 2
62327: PPUSH
62328: CALL_OW 275
62332: PUSH
62333: LD_VAR 0 4
62337: PUSH
62338: LD_INT 2
62340: ARRAY
62341: GREATEREQUAL
62342: AND
62343: PUSH
62344: LD_VAR 0 5
62348: PPUSH
62349: LD_INT 3
62351: PPUSH
62352: CALL_OW 275
62356: PUSH
62357: LD_VAR 0 4
62361: PUSH
62362: LD_INT 3
62364: ARRAY
62365: GREATEREQUAL
62366: AND
62367: ST_TO_ADDR
// end ;
62368: LD_VAR 0 3
62372: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62373: LD_INT 0
62375: PPUSH
62376: PPUSH
62377: PPUSH
62378: PPUSH
// pom := GetBase ( building ) ;
62379: LD_ADDR_VAR 0 3
62383: PUSH
62384: LD_VAR 0 1
62388: PPUSH
62389: CALL_OW 274
62393: ST_TO_ADDR
// if not pom then
62394: LD_VAR 0 3
62398: NOT
62399: IFFALSE 62403
// exit ;
62401: GO 62573
// btype := GetBType ( building ) ;
62403: LD_ADDR_VAR 0 5
62407: PUSH
62408: LD_VAR 0 1
62412: PPUSH
62413: CALL_OW 266
62417: ST_TO_ADDR
// if btype = b_armoury then
62418: LD_VAR 0 5
62422: PUSH
62423: LD_INT 4
62425: EQUAL
62426: IFFALSE 62436
// btype := b_barracks ;
62428: LD_ADDR_VAR 0 5
62432: PUSH
62433: LD_INT 5
62435: ST_TO_ADDR
// if btype = b_depot then
62436: LD_VAR 0 5
62440: PUSH
62441: LD_INT 0
62443: EQUAL
62444: IFFALSE 62454
// btype := b_warehouse ;
62446: LD_ADDR_VAR 0 5
62450: PUSH
62451: LD_INT 1
62453: ST_TO_ADDR
// if btype = b_workshop then
62454: LD_VAR 0 5
62458: PUSH
62459: LD_INT 2
62461: EQUAL
62462: IFFALSE 62472
// btype := b_factory ;
62464: LD_ADDR_VAR 0 5
62468: PUSH
62469: LD_INT 3
62471: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62472: LD_ADDR_VAR 0 4
62476: PUSH
62477: LD_VAR 0 5
62481: PPUSH
62482: LD_VAR 0 1
62486: PPUSH
62487: CALL_OW 248
62491: PPUSH
62492: CALL_OW 450
62496: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62497: LD_ADDR_VAR 0 2
62501: PUSH
62502: LD_VAR 0 3
62506: PPUSH
62507: LD_INT 1
62509: PPUSH
62510: CALL_OW 275
62514: PUSH
62515: LD_VAR 0 4
62519: PUSH
62520: LD_INT 1
62522: ARRAY
62523: GREATEREQUAL
62524: PUSH
62525: LD_VAR 0 3
62529: PPUSH
62530: LD_INT 2
62532: PPUSH
62533: CALL_OW 275
62537: PUSH
62538: LD_VAR 0 4
62542: PUSH
62543: LD_INT 2
62545: ARRAY
62546: GREATEREQUAL
62547: AND
62548: PUSH
62549: LD_VAR 0 3
62553: PPUSH
62554: LD_INT 3
62556: PPUSH
62557: CALL_OW 275
62561: PUSH
62562: LD_VAR 0 4
62566: PUSH
62567: LD_INT 3
62569: ARRAY
62570: GREATEREQUAL
62571: AND
62572: ST_TO_ADDR
// end ;
62573: LD_VAR 0 2
62577: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62578: LD_INT 0
62580: PPUSH
62581: PPUSH
62582: PPUSH
// pom := GetBase ( building ) ;
62583: LD_ADDR_VAR 0 4
62587: PUSH
62588: LD_VAR 0 1
62592: PPUSH
62593: CALL_OW 274
62597: ST_TO_ADDR
// if not pom then
62598: LD_VAR 0 4
62602: NOT
62603: IFFALSE 62607
// exit ;
62605: GO 62708
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62607: LD_ADDR_VAR 0 5
62611: PUSH
62612: LD_VAR 0 2
62616: PPUSH
62617: LD_VAR 0 1
62621: PPUSH
62622: CALL_OW 248
62626: PPUSH
62627: CALL_OW 450
62631: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62632: LD_ADDR_VAR 0 3
62636: PUSH
62637: LD_VAR 0 4
62641: PPUSH
62642: LD_INT 1
62644: PPUSH
62645: CALL_OW 275
62649: PUSH
62650: LD_VAR 0 5
62654: PUSH
62655: LD_INT 1
62657: ARRAY
62658: GREATEREQUAL
62659: PUSH
62660: LD_VAR 0 4
62664: PPUSH
62665: LD_INT 2
62667: PPUSH
62668: CALL_OW 275
62672: PUSH
62673: LD_VAR 0 5
62677: PUSH
62678: LD_INT 2
62680: ARRAY
62681: GREATEREQUAL
62682: AND
62683: PUSH
62684: LD_VAR 0 4
62688: PPUSH
62689: LD_INT 3
62691: PPUSH
62692: CALL_OW 275
62696: PUSH
62697: LD_VAR 0 5
62701: PUSH
62702: LD_INT 3
62704: ARRAY
62705: GREATEREQUAL
62706: AND
62707: ST_TO_ADDR
// end ;
62708: LD_VAR 0 3
62712: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
62713: LD_INT 0
62715: PPUSH
62716: PPUSH
62717: PPUSH
62718: PPUSH
62719: PPUSH
62720: PPUSH
62721: PPUSH
62722: PPUSH
62723: PPUSH
62724: PPUSH
62725: PPUSH
// result := false ;
62726: LD_ADDR_VAR 0 8
62730: PUSH
62731: LD_INT 0
62733: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
62734: LD_VAR 0 5
62738: NOT
62739: PUSH
62740: LD_VAR 0 1
62744: NOT
62745: OR
62746: PUSH
62747: LD_VAR 0 2
62751: NOT
62752: OR
62753: PUSH
62754: LD_VAR 0 3
62758: NOT
62759: OR
62760: IFFALSE 62764
// exit ;
62762: GO 63578
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
62764: LD_ADDR_VAR 0 14
62768: PUSH
62769: LD_VAR 0 1
62773: PPUSH
62774: LD_VAR 0 2
62778: PPUSH
62779: LD_VAR 0 3
62783: PPUSH
62784: LD_VAR 0 4
62788: PPUSH
62789: LD_VAR 0 5
62793: PUSH
62794: LD_INT 1
62796: ARRAY
62797: PPUSH
62798: CALL_OW 248
62802: PPUSH
62803: LD_INT 0
62805: PPUSH
62806: CALL 64415 0 6
62810: ST_TO_ADDR
// if not hexes then
62811: LD_VAR 0 14
62815: NOT
62816: IFFALSE 62820
// exit ;
62818: GO 63578
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
62820: LD_ADDR_VAR 0 17
62824: PUSH
62825: LD_VAR 0 5
62829: PPUSH
62830: LD_INT 22
62832: PUSH
62833: LD_VAR 0 13
62837: PPUSH
62838: CALL_OW 255
62842: PUSH
62843: EMPTY
62844: LIST
62845: LIST
62846: PUSH
62847: LD_INT 2
62849: PUSH
62850: LD_INT 30
62852: PUSH
62853: LD_INT 0
62855: PUSH
62856: EMPTY
62857: LIST
62858: LIST
62859: PUSH
62860: LD_INT 30
62862: PUSH
62863: LD_INT 1
62865: PUSH
62866: EMPTY
62867: LIST
62868: LIST
62869: PUSH
62870: EMPTY
62871: LIST
62872: LIST
62873: LIST
62874: PUSH
62875: EMPTY
62876: LIST
62877: LIST
62878: PPUSH
62879: CALL_OW 72
62883: ST_TO_ADDR
// for i = 1 to hexes do
62884: LD_ADDR_VAR 0 9
62888: PUSH
62889: DOUBLE
62890: LD_INT 1
62892: DEC
62893: ST_TO_ADDR
62894: LD_VAR 0 14
62898: PUSH
62899: FOR_TO
62900: IFFALSE 63576
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62902: LD_ADDR_VAR 0 13
62906: PUSH
62907: LD_VAR 0 14
62911: PUSH
62912: LD_VAR 0 9
62916: ARRAY
62917: PUSH
62918: LD_INT 1
62920: ARRAY
62921: PPUSH
62922: LD_VAR 0 14
62926: PUSH
62927: LD_VAR 0 9
62931: ARRAY
62932: PUSH
62933: LD_INT 2
62935: ARRAY
62936: PPUSH
62937: CALL_OW 428
62941: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
62942: LD_VAR 0 14
62946: PUSH
62947: LD_VAR 0 9
62951: ARRAY
62952: PUSH
62953: LD_INT 1
62955: ARRAY
62956: PPUSH
62957: LD_VAR 0 14
62961: PUSH
62962: LD_VAR 0 9
62966: ARRAY
62967: PUSH
62968: LD_INT 2
62970: ARRAY
62971: PPUSH
62972: CALL_OW 351
62976: PUSH
62977: LD_VAR 0 14
62981: PUSH
62982: LD_VAR 0 9
62986: ARRAY
62987: PUSH
62988: LD_INT 1
62990: ARRAY
62991: PPUSH
62992: LD_VAR 0 14
62996: PUSH
62997: LD_VAR 0 9
63001: ARRAY
63002: PUSH
63003: LD_INT 2
63005: ARRAY
63006: PPUSH
63007: CALL_OW 488
63011: NOT
63012: OR
63013: PUSH
63014: LD_VAR 0 13
63018: PPUSH
63019: CALL_OW 247
63023: PUSH
63024: LD_INT 3
63026: EQUAL
63027: OR
63028: IFFALSE 63034
// exit ;
63030: POP
63031: POP
63032: GO 63578
// if not tmp then
63034: LD_VAR 0 13
63038: NOT
63039: IFFALSE 63043
// continue ;
63041: GO 62899
// result := true ;
63043: LD_ADDR_VAR 0 8
63047: PUSH
63048: LD_INT 1
63050: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
63051: LD_VAR 0 6
63055: PUSH
63056: LD_VAR 0 13
63060: PPUSH
63061: CALL_OW 247
63065: PUSH
63066: LD_INT 2
63068: EQUAL
63069: AND
63070: PUSH
63071: LD_VAR 0 13
63075: PPUSH
63076: CALL_OW 263
63080: PUSH
63081: LD_INT 1
63083: EQUAL
63084: AND
63085: IFFALSE 63249
// begin if IsDrivenBy ( tmp ) then
63087: LD_VAR 0 13
63091: PPUSH
63092: CALL_OW 311
63096: IFFALSE 63100
// continue ;
63098: GO 62899
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
63100: LD_VAR 0 6
63104: PPUSH
63105: LD_INT 3
63107: PUSH
63108: LD_INT 60
63110: PUSH
63111: EMPTY
63112: LIST
63113: PUSH
63114: EMPTY
63115: LIST
63116: LIST
63117: PUSH
63118: LD_INT 3
63120: PUSH
63121: LD_INT 55
63123: PUSH
63124: EMPTY
63125: LIST
63126: PUSH
63127: EMPTY
63128: LIST
63129: LIST
63130: PUSH
63131: EMPTY
63132: LIST
63133: LIST
63134: PPUSH
63135: CALL_OW 72
63139: IFFALSE 63247
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
63141: LD_ADDR_VAR 0 18
63145: PUSH
63146: LD_VAR 0 6
63150: PPUSH
63151: LD_INT 3
63153: PUSH
63154: LD_INT 60
63156: PUSH
63157: EMPTY
63158: LIST
63159: PUSH
63160: EMPTY
63161: LIST
63162: LIST
63163: PUSH
63164: LD_INT 3
63166: PUSH
63167: LD_INT 55
63169: PUSH
63170: EMPTY
63171: LIST
63172: PUSH
63173: EMPTY
63174: LIST
63175: LIST
63176: PUSH
63177: EMPTY
63178: LIST
63179: LIST
63180: PPUSH
63181: CALL_OW 72
63185: PUSH
63186: LD_INT 1
63188: ARRAY
63189: ST_TO_ADDR
// if IsInUnit ( driver ) then
63190: LD_VAR 0 18
63194: PPUSH
63195: CALL_OW 310
63199: IFFALSE 63210
// ComExit ( driver ) ;
63201: LD_VAR 0 18
63205: PPUSH
63206: CALL 87599 0 1
// AddComEnterUnit ( driver , tmp ) ;
63210: LD_VAR 0 18
63214: PPUSH
63215: LD_VAR 0 13
63219: PPUSH
63220: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
63224: LD_VAR 0 18
63228: PPUSH
63229: LD_VAR 0 7
63233: PPUSH
63234: CALL_OW 173
// AddComExitVehicle ( driver ) ;
63238: LD_VAR 0 18
63242: PPUSH
63243: CALL_OW 181
// end ; continue ;
63247: GO 62899
// end ; if not cleaners or not tmp in cleaners then
63249: LD_VAR 0 6
63253: NOT
63254: PUSH
63255: LD_VAR 0 13
63259: PUSH
63260: LD_VAR 0 6
63264: IN
63265: NOT
63266: OR
63267: IFFALSE 63574
// begin if dep then
63269: LD_VAR 0 17
63273: IFFALSE 63409
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
63275: LD_ADDR_VAR 0 16
63279: PUSH
63280: LD_VAR 0 17
63284: PUSH
63285: LD_INT 1
63287: ARRAY
63288: PPUSH
63289: CALL_OW 250
63293: PPUSH
63294: LD_VAR 0 17
63298: PUSH
63299: LD_INT 1
63301: ARRAY
63302: PPUSH
63303: CALL_OW 254
63307: PPUSH
63308: LD_INT 5
63310: PPUSH
63311: CALL_OW 272
63315: PUSH
63316: LD_VAR 0 17
63320: PUSH
63321: LD_INT 1
63323: ARRAY
63324: PPUSH
63325: CALL_OW 251
63329: PPUSH
63330: LD_VAR 0 17
63334: PUSH
63335: LD_INT 1
63337: ARRAY
63338: PPUSH
63339: CALL_OW 254
63343: PPUSH
63344: LD_INT 5
63346: PPUSH
63347: CALL_OW 273
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63356: LD_VAR 0 16
63360: PUSH
63361: LD_INT 1
63363: ARRAY
63364: PPUSH
63365: LD_VAR 0 16
63369: PUSH
63370: LD_INT 2
63372: ARRAY
63373: PPUSH
63374: CALL_OW 488
63378: IFFALSE 63409
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63380: LD_VAR 0 13
63384: PPUSH
63385: LD_VAR 0 16
63389: PUSH
63390: LD_INT 1
63392: ARRAY
63393: PPUSH
63394: LD_VAR 0 16
63398: PUSH
63399: LD_INT 2
63401: ARRAY
63402: PPUSH
63403: CALL_OW 111
// continue ;
63407: GO 62899
// end ; end ; r := GetDir ( tmp ) ;
63409: LD_ADDR_VAR 0 15
63413: PUSH
63414: LD_VAR 0 13
63418: PPUSH
63419: CALL_OW 254
63423: ST_TO_ADDR
// if r = 5 then
63424: LD_VAR 0 15
63428: PUSH
63429: LD_INT 5
63431: EQUAL
63432: IFFALSE 63442
// r := 0 ;
63434: LD_ADDR_VAR 0 15
63438: PUSH
63439: LD_INT 0
63441: ST_TO_ADDR
// for j = r to 5 do
63442: LD_ADDR_VAR 0 10
63446: PUSH
63447: DOUBLE
63448: LD_VAR 0 15
63452: DEC
63453: ST_TO_ADDR
63454: LD_INT 5
63456: PUSH
63457: FOR_TO
63458: IFFALSE 63572
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
63460: LD_ADDR_VAR 0 11
63464: PUSH
63465: LD_VAR 0 13
63469: PPUSH
63470: CALL_OW 250
63474: PPUSH
63475: LD_VAR 0 10
63479: PPUSH
63480: LD_INT 2
63482: PPUSH
63483: CALL_OW 272
63487: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63488: LD_ADDR_VAR 0 12
63492: PUSH
63493: LD_VAR 0 13
63497: PPUSH
63498: CALL_OW 251
63502: PPUSH
63503: LD_VAR 0 10
63507: PPUSH
63508: LD_INT 2
63510: PPUSH
63511: CALL_OW 273
63515: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63516: LD_VAR 0 11
63520: PPUSH
63521: LD_VAR 0 12
63525: PPUSH
63526: CALL_OW 488
63530: PUSH
63531: LD_VAR 0 11
63535: PPUSH
63536: LD_VAR 0 12
63540: PPUSH
63541: CALL_OW 428
63545: NOT
63546: AND
63547: IFFALSE 63570
// begin ComMoveXY ( tmp , _x , _y ) ;
63549: LD_VAR 0 13
63553: PPUSH
63554: LD_VAR 0 11
63558: PPUSH
63559: LD_VAR 0 12
63563: PPUSH
63564: CALL_OW 111
// break ;
63568: GO 63572
// end ; end ;
63570: GO 63457
63572: POP
63573: POP
// end ; end ;
63574: GO 62899
63576: POP
63577: POP
// end ;
63578: LD_VAR 0 8
63582: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
63583: LD_INT 0
63585: PPUSH
63586: PPUSH
63587: PPUSH
63588: PPUSH
63589: PPUSH
63590: PPUSH
63591: PPUSH
63592: PPUSH
63593: PPUSH
63594: PPUSH
// result := false ;
63595: LD_ADDR_VAR 0 6
63599: PUSH
63600: LD_INT 0
63602: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
63603: LD_VAR 0 1
63607: NOT
63608: PUSH
63609: LD_VAR 0 1
63613: PPUSH
63614: CALL_OW 266
63618: PUSH
63619: LD_INT 0
63621: PUSH
63622: LD_INT 1
63624: PUSH
63625: EMPTY
63626: LIST
63627: LIST
63628: IN
63629: NOT
63630: OR
63631: PUSH
63632: LD_VAR 0 2
63636: NOT
63637: OR
63638: PUSH
63639: LD_VAR 0 5
63643: PUSH
63644: LD_INT 0
63646: PUSH
63647: LD_INT 1
63649: PUSH
63650: LD_INT 2
63652: PUSH
63653: LD_INT 3
63655: PUSH
63656: LD_INT 4
63658: PUSH
63659: LD_INT 5
63661: PUSH
63662: EMPTY
63663: LIST
63664: LIST
63665: LIST
63666: LIST
63667: LIST
63668: LIST
63669: IN
63670: NOT
63671: OR
63672: PUSH
63673: LD_VAR 0 3
63677: PPUSH
63678: LD_VAR 0 4
63682: PPUSH
63683: CALL_OW 488
63687: NOT
63688: OR
63689: IFFALSE 63693
// exit ;
63691: GO 64410
// pom := GetBase ( depot ) ;
63693: LD_ADDR_VAR 0 10
63697: PUSH
63698: LD_VAR 0 1
63702: PPUSH
63703: CALL_OW 274
63707: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63708: LD_ADDR_VAR 0 11
63712: PUSH
63713: LD_VAR 0 2
63717: PPUSH
63718: LD_VAR 0 1
63722: PPUSH
63723: CALL_OW 248
63727: PPUSH
63728: CALL_OW 450
63732: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63733: LD_VAR 0 10
63737: PPUSH
63738: LD_INT 1
63740: PPUSH
63741: CALL_OW 275
63745: PUSH
63746: LD_VAR 0 11
63750: PUSH
63751: LD_INT 1
63753: ARRAY
63754: GREATEREQUAL
63755: PUSH
63756: LD_VAR 0 10
63760: PPUSH
63761: LD_INT 2
63763: PPUSH
63764: CALL_OW 275
63768: PUSH
63769: LD_VAR 0 11
63773: PUSH
63774: LD_INT 2
63776: ARRAY
63777: GREATEREQUAL
63778: AND
63779: PUSH
63780: LD_VAR 0 10
63784: PPUSH
63785: LD_INT 3
63787: PPUSH
63788: CALL_OW 275
63792: PUSH
63793: LD_VAR 0 11
63797: PUSH
63798: LD_INT 3
63800: ARRAY
63801: GREATEREQUAL
63802: AND
63803: NOT
63804: IFFALSE 63808
// exit ;
63806: GO 64410
// if GetBType ( depot ) = b_depot then
63808: LD_VAR 0 1
63812: PPUSH
63813: CALL_OW 266
63817: PUSH
63818: LD_INT 0
63820: EQUAL
63821: IFFALSE 63833
// dist := 28 else
63823: LD_ADDR_VAR 0 14
63827: PUSH
63828: LD_INT 28
63830: ST_TO_ADDR
63831: GO 63841
// dist := 36 ;
63833: LD_ADDR_VAR 0 14
63837: PUSH
63838: LD_INT 36
63840: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
63841: LD_VAR 0 1
63845: PPUSH
63846: LD_VAR 0 3
63850: PPUSH
63851: LD_VAR 0 4
63855: PPUSH
63856: CALL_OW 297
63860: PUSH
63861: LD_VAR 0 14
63865: GREATER
63866: IFFALSE 63870
// exit ;
63868: GO 64410
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
63870: LD_ADDR_VAR 0 12
63874: PUSH
63875: LD_VAR 0 2
63879: PPUSH
63880: LD_VAR 0 3
63884: PPUSH
63885: LD_VAR 0 4
63889: PPUSH
63890: LD_VAR 0 5
63894: PPUSH
63895: LD_VAR 0 1
63899: PPUSH
63900: CALL_OW 248
63904: PPUSH
63905: LD_INT 0
63907: PPUSH
63908: CALL 64415 0 6
63912: ST_TO_ADDR
// if not hexes then
63913: LD_VAR 0 12
63917: NOT
63918: IFFALSE 63922
// exit ;
63920: GO 64410
// hex := GetHexInfo ( x , y ) ;
63922: LD_ADDR_VAR 0 15
63926: PUSH
63927: LD_VAR 0 3
63931: PPUSH
63932: LD_VAR 0 4
63936: PPUSH
63937: CALL_OW 546
63941: ST_TO_ADDR
// if hex [ 1 ] then
63942: LD_VAR 0 15
63946: PUSH
63947: LD_INT 1
63949: ARRAY
63950: IFFALSE 63954
// exit ;
63952: GO 64410
// height := hex [ 2 ] ;
63954: LD_ADDR_VAR 0 13
63958: PUSH
63959: LD_VAR 0 15
63963: PUSH
63964: LD_INT 2
63966: ARRAY
63967: ST_TO_ADDR
// for i = 1 to hexes do
63968: LD_ADDR_VAR 0 7
63972: PUSH
63973: DOUBLE
63974: LD_INT 1
63976: DEC
63977: ST_TO_ADDR
63978: LD_VAR 0 12
63982: PUSH
63983: FOR_TO
63984: IFFALSE 64314
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63986: LD_VAR 0 12
63990: PUSH
63991: LD_VAR 0 7
63995: ARRAY
63996: PUSH
63997: LD_INT 1
63999: ARRAY
64000: PPUSH
64001: LD_VAR 0 12
64005: PUSH
64006: LD_VAR 0 7
64010: ARRAY
64011: PUSH
64012: LD_INT 2
64014: ARRAY
64015: PPUSH
64016: CALL_OW 488
64020: NOT
64021: PUSH
64022: LD_VAR 0 12
64026: PUSH
64027: LD_VAR 0 7
64031: ARRAY
64032: PUSH
64033: LD_INT 1
64035: ARRAY
64036: PPUSH
64037: LD_VAR 0 12
64041: PUSH
64042: LD_VAR 0 7
64046: ARRAY
64047: PUSH
64048: LD_INT 2
64050: ARRAY
64051: PPUSH
64052: CALL_OW 428
64056: PUSH
64057: LD_INT 0
64059: GREATER
64060: OR
64061: PUSH
64062: LD_VAR 0 12
64066: PUSH
64067: LD_VAR 0 7
64071: ARRAY
64072: PUSH
64073: LD_INT 1
64075: ARRAY
64076: PPUSH
64077: LD_VAR 0 12
64081: PUSH
64082: LD_VAR 0 7
64086: ARRAY
64087: PUSH
64088: LD_INT 2
64090: ARRAY
64091: PPUSH
64092: CALL_OW 351
64096: OR
64097: IFFALSE 64103
// exit ;
64099: POP
64100: POP
64101: GO 64410
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64103: LD_ADDR_VAR 0 8
64107: PUSH
64108: LD_VAR 0 12
64112: PUSH
64113: LD_VAR 0 7
64117: ARRAY
64118: PUSH
64119: LD_INT 1
64121: ARRAY
64122: PPUSH
64123: LD_VAR 0 12
64127: PUSH
64128: LD_VAR 0 7
64132: ARRAY
64133: PUSH
64134: LD_INT 2
64136: ARRAY
64137: PPUSH
64138: CALL_OW 546
64142: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
64143: LD_VAR 0 8
64147: PUSH
64148: LD_INT 1
64150: ARRAY
64151: PUSH
64152: LD_VAR 0 8
64156: PUSH
64157: LD_INT 2
64159: ARRAY
64160: PUSH
64161: LD_VAR 0 13
64165: PUSH
64166: LD_INT 2
64168: PLUS
64169: GREATER
64170: OR
64171: PUSH
64172: LD_VAR 0 8
64176: PUSH
64177: LD_INT 2
64179: ARRAY
64180: PUSH
64181: LD_VAR 0 13
64185: PUSH
64186: LD_INT 2
64188: MINUS
64189: LESS
64190: OR
64191: PUSH
64192: LD_VAR 0 8
64196: PUSH
64197: LD_INT 3
64199: ARRAY
64200: PUSH
64201: LD_INT 0
64203: PUSH
64204: LD_INT 8
64206: PUSH
64207: LD_INT 9
64209: PUSH
64210: LD_INT 10
64212: PUSH
64213: LD_INT 11
64215: PUSH
64216: LD_INT 12
64218: PUSH
64219: LD_INT 13
64221: PUSH
64222: LD_INT 16
64224: PUSH
64225: LD_INT 17
64227: PUSH
64228: LD_INT 18
64230: PUSH
64231: LD_INT 19
64233: PUSH
64234: LD_INT 20
64236: PUSH
64237: LD_INT 21
64239: PUSH
64240: EMPTY
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: LIST
64250: LIST
64251: LIST
64252: LIST
64253: LIST
64254: IN
64255: NOT
64256: OR
64257: PUSH
64258: LD_VAR 0 8
64262: PUSH
64263: LD_INT 5
64265: ARRAY
64266: NOT
64267: OR
64268: PUSH
64269: LD_VAR 0 8
64273: PUSH
64274: LD_INT 6
64276: ARRAY
64277: PUSH
64278: LD_INT 1
64280: PUSH
64281: LD_INT 2
64283: PUSH
64284: LD_INT 7
64286: PUSH
64287: LD_INT 9
64289: PUSH
64290: LD_INT 10
64292: PUSH
64293: LD_INT 11
64295: PUSH
64296: EMPTY
64297: LIST
64298: LIST
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: IN
64304: NOT
64305: OR
64306: IFFALSE 64312
// exit ;
64308: POP
64309: POP
64310: GO 64410
// end ;
64312: GO 63983
64314: POP
64315: POP
// side := GetSide ( depot ) ;
64316: LD_ADDR_VAR 0 9
64320: PUSH
64321: LD_VAR 0 1
64325: PPUSH
64326: CALL_OW 255
64330: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
64331: LD_VAR 0 9
64335: PPUSH
64336: LD_VAR 0 3
64340: PPUSH
64341: LD_VAR 0 4
64345: PPUSH
64346: LD_INT 20
64348: PPUSH
64349: CALL 56731 0 4
64353: PUSH
64354: LD_INT 4
64356: ARRAY
64357: IFFALSE 64361
// exit ;
64359: GO 64410
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
64361: LD_VAR 0 2
64365: PUSH
64366: LD_INT 29
64368: PUSH
64369: LD_INT 30
64371: PUSH
64372: EMPTY
64373: LIST
64374: LIST
64375: IN
64376: PUSH
64377: LD_VAR 0 3
64381: PPUSH
64382: LD_VAR 0 4
64386: PPUSH
64387: LD_VAR 0 9
64391: PPUSH
64392: CALL_OW 440
64396: NOT
64397: AND
64398: IFFALSE 64402
// exit ;
64400: GO 64410
// result := true ;
64402: LD_ADDR_VAR 0 6
64406: PUSH
64407: LD_INT 1
64409: ST_TO_ADDR
// end ;
64410: LD_VAR 0 6
64414: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
64415: LD_INT 0
64417: PPUSH
64418: PPUSH
64419: PPUSH
64420: PPUSH
64421: PPUSH
64422: PPUSH
64423: PPUSH
64424: PPUSH
64425: PPUSH
64426: PPUSH
64427: PPUSH
64428: PPUSH
64429: PPUSH
64430: PPUSH
64431: PPUSH
64432: PPUSH
64433: PPUSH
64434: PPUSH
64435: PPUSH
64436: PPUSH
64437: PPUSH
64438: PPUSH
64439: PPUSH
64440: PPUSH
64441: PPUSH
64442: PPUSH
64443: PPUSH
64444: PPUSH
64445: PPUSH
64446: PPUSH
64447: PPUSH
64448: PPUSH
64449: PPUSH
64450: PPUSH
64451: PPUSH
64452: PPUSH
64453: PPUSH
64454: PPUSH
64455: PPUSH
64456: PPUSH
64457: PPUSH
64458: PPUSH
64459: PPUSH
64460: PPUSH
64461: PPUSH
64462: PPUSH
64463: PPUSH
64464: PPUSH
64465: PPUSH
64466: PPUSH
64467: PPUSH
64468: PPUSH
64469: PPUSH
64470: PPUSH
64471: PPUSH
64472: PPUSH
64473: PPUSH
64474: PPUSH
// result = [ ] ;
64475: LD_ADDR_VAR 0 7
64479: PUSH
64480: EMPTY
64481: ST_TO_ADDR
// temp_list = [ ] ;
64482: LD_ADDR_VAR 0 9
64486: PUSH
64487: EMPTY
64488: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
64489: LD_VAR 0 4
64493: PUSH
64494: LD_INT 0
64496: PUSH
64497: LD_INT 1
64499: PUSH
64500: LD_INT 2
64502: PUSH
64503: LD_INT 3
64505: PUSH
64506: LD_INT 4
64508: PUSH
64509: LD_INT 5
64511: PUSH
64512: EMPTY
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: LIST
64519: IN
64520: NOT
64521: PUSH
64522: LD_VAR 0 1
64526: PUSH
64527: LD_INT 0
64529: PUSH
64530: LD_INT 1
64532: PUSH
64533: EMPTY
64534: LIST
64535: LIST
64536: IN
64537: PUSH
64538: LD_VAR 0 5
64542: PUSH
64543: LD_INT 1
64545: PUSH
64546: LD_INT 2
64548: PUSH
64549: LD_INT 3
64551: PUSH
64552: EMPTY
64553: LIST
64554: LIST
64555: LIST
64556: IN
64557: NOT
64558: AND
64559: OR
64560: IFFALSE 64564
// exit ;
64562: GO 82955
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
64564: LD_VAR 0 1
64568: PUSH
64569: LD_INT 6
64571: PUSH
64572: LD_INT 7
64574: PUSH
64575: LD_INT 8
64577: PUSH
64578: LD_INT 13
64580: PUSH
64581: LD_INT 12
64583: PUSH
64584: LD_INT 15
64586: PUSH
64587: LD_INT 11
64589: PUSH
64590: LD_INT 14
64592: PUSH
64593: LD_INT 10
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: LIST
64602: LIST
64603: LIST
64604: LIST
64605: LIST
64606: IN
64607: IFFALSE 64617
// btype = b_lab ;
64609: LD_ADDR_VAR 0 1
64613: PUSH
64614: LD_INT 6
64616: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
64617: LD_VAR 0 6
64621: PUSH
64622: LD_INT 0
64624: PUSH
64625: LD_INT 1
64627: PUSH
64628: LD_INT 2
64630: PUSH
64631: EMPTY
64632: LIST
64633: LIST
64634: LIST
64635: IN
64636: NOT
64637: PUSH
64638: LD_VAR 0 1
64642: PUSH
64643: LD_INT 0
64645: PUSH
64646: LD_INT 1
64648: PUSH
64649: LD_INT 2
64651: PUSH
64652: LD_INT 3
64654: PUSH
64655: LD_INT 6
64657: PUSH
64658: LD_INT 36
64660: PUSH
64661: LD_INT 4
64663: PUSH
64664: LD_INT 5
64666: PUSH
64667: LD_INT 31
64669: PUSH
64670: LD_INT 32
64672: PUSH
64673: LD_INT 33
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: IN
64689: NOT
64690: PUSH
64691: LD_VAR 0 6
64695: PUSH
64696: LD_INT 1
64698: EQUAL
64699: AND
64700: OR
64701: PUSH
64702: LD_VAR 0 1
64706: PUSH
64707: LD_INT 2
64709: PUSH
64710: LD_INT 3
64712: PUSH
64713: EMPTY
64714: LIST
64715: LIST
64716: IN
64717: NOT
64718: PUSH
64719: LD_VAR 0 6
64723: PUSH
64724: LD_INT 2
64726: EQUAL
64727: AND
64728: OR
64729: IFFALSE 64739
// mode = 0 ;
64731: LD_ADDR_VAR 0 6
64735: PUSH
64736: LD_INT 0
64738: ST_TO_ADDR
// case mode of 0 :
64739: LD_VAR 0 6
64743: PUSH
64744: LD_INT 0
64746: DOUBLE
64747: EQUAL
64748: IFTRUE 64752
64750: GO 76205
64752: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64753: LD_ADDR_VAR 0 11
64757: PUSH
64758: LD_INT 0
64760: PUSH
64761: LD_INT 0
64763: PUSH
64764: EMPTY
64765: LIST
64766: LIST
64767: PUSH
64768: LD_INT 0
64770: PUSH
64771: LD_INT 1
64773: NEG
64774: PUSH
64775: EMPTY
64776: LIST
64777: LIST
64778: PUSH
64779: LD_INT 1
64781: PUSH
64782: LD_INT 0
64784: PUSH
64785: EMPTY
64786: LIST
64787: LIST
64788: PUSH
64789: LD_INT 1
64791: PUSH
64792: LD_INT 1
64794: PUSH
64795: EMPTY
64796: LIST
64797: LIST
64798: PUSH
64799: LD_INT 0
64801: PUSH
64802: LD_INT 1
64804: PUSH
64805: EMPTY
64806: LIST
64807: LIST
64808: PUSH
64809: LD_INT 1
64811: NEG
64812: PUSH
64813: LD_INT 0
64815: PUSH
64816: EMPTY
64817: LIST
64818: LIST
64819: PUSH
64820: LD_INT 1
64822: NEG
64823: PUSH
64824: LD_INT 1
64826: NEG
64827: PUSH
64828: EMPTY
64829: LIST
64830: LIST
64831: PUSH
64832: LD_INT 1
64834: NEG
64835: PUSH
64836: LD_INT 2
64838: NEG
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: LD_INT 0
64846: PUSH
64847: LD_INT 2
64849: NEG
64850: PUSH
64851: EMPTY
64852: LIST
64853: LIST
64854: PUSH
64855: LD_INT 1
64857: PUSH
64858: LD_INT 1
64860: NEG
64861: PUSH
64862: EMPTY
64863: LIST
64864: LIST
64865: PUSH
64866: LD_INT 1
64868: PUSH
64869: LD_INT 2
64871: PUSH
64872: EMPTY
64873: LIST
64874: LIST
64875: PUSH
64876: LD_INT 0
64878: PUSH
64879: LD_INT 2
64881: PUSH
64882: EMPTY
64883: LIST
64884: LIST
64885: PUSH
64886: LD_INT 1
64888: NEG
64889: PUSH
64890: LD_INT 1
64892: PUSH
64893: EMPTY
64894: LIST
64895: LIST
64896: PUSH
64897: LD_INT 1
64899: PUSH
64900: LD_INT 3
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: PUSH
64907: LD_INT 0
64909: PUSH
64910: LD_INT 3
64912: PUSH
64913: EMPTY
64914: LIST
64915: LIST
64916: PUSH
64917: LD_INT 1
64919: NEG
64920: PUSH
64921: LD_INT 2
64923: PUSH
64924: EMPTY
64925: LIST
64926: LIST
64927: PUSH
64928: EMPTY
64929: LIST
64930: LIST
64931: LIST
64932: LIST
64933: LIST
64934: LIST
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: LIST
64940: LIST
64941: LIST
64942: LIST
64943: LIST
64944: LIST
64945: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64946: LD_ADDR_VAR 0 12
64950: PUSH
64951: LD_INT 0
64953: PUSH
64954: LD_INT 0
64956: PUSH
64957: EMPTY
64958: LIST
64959: LIST
64960: PUSH
64961: LD_INT 0
64963: PUSH
64964: LD_INT 1
64966: NEG
64967: PUSH
64968: EMPTY
64969: LIST
64970: LIST
64971: PUSH
64972: LD_INT 1
64974: PUSH
64975: LD_INT 0
64977: PUSH
64978: EMPTY
64979: LIST
64980: LIST
64981: PUSH
64982: LD_INT 1
64984: PUSH
64985: LD_INT 1
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: PUSH
64992: LD_INT 0
64994: PUSH
64995: LD_INT 1
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: PUSH
65002: LD_INT 1
65004: NEG
65005: PUSH
65006: LD_INT 0
65008: PUSH
65009: EMPTY
65010: LIST
65011: LIST
65012: PUSH
65013: LD_INT 1
65015: NEG
65016: PUSH
65017: LD_INT 1
65019: NEG
65020: PUSH
65021: EMPTY
65022: LIST
65023: LIST
65024: PUSH
65025: LD_INT 1
65027: PUSH
65028: LD_INT 1
65030: NEG
65031: PUSH
65032: EMPTY
65033: LIST
65034: LIST
65035: PUSH
65036: LD_INT 2
65038: PUSH
65039: LD_INT 0
65041: PUSH
65042: EMPTY
65043: LIST
65044: LIST
65045: PUSH
65046: LD_INT 2
65048: PUSH
65049: LD_INT 1
65051: PUSH
65052: EMPTY
65053: LIST
65054: LIST
65055: PUSH
65056: LD_INT 1
65058: NEG
65059: PUSH
65060: LD_INT 1
65062: PUSH
65063: EMPTY
65064: LIST
65065: LIST
65066: PUSH
65067: LD_INT 2
65069: NEG
65070: PUSH
65071: LD_INT 0
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: PUSH
65078: LD_INT 2
65080: NEG
65081: PUSH
65082: LD_INT 1
65084: NEG
65085: PUSH
65086: EMPTY
65087: LIST
65088: LIST
65089: PUSH
65090: LD_INT 2
65092: NEG
65093: PUSH
65094: LD_INT 1
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: PUSH
65101: LD_INT 3
65103: NEG
65104: PUSH
65105: LD_INT 0
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: PUSH
65112: LD_INT 3
65114: NEG
65115: PUSH
65116: LD_INT 1
65118: NEG
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: PUSH
65124: EMPTY
65125: LIST
65126: LIST
65127: LIST
65128: LIST
65129: LIST
65130: LIST
65131: LIST
65132: LIST
65133: LIST
65134: LIST
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65142: LD_ADDR_VAR 0 13
65146: PUSH
65147: LD_INT 0
65149: PUSH
65150: LD_INT 0
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: PUSH
65157: LD_INT 0
65159: PUSH
65160: LD_INT 1
65162: NEG
65163: PUSH
65164: EMPTY
65165: LIST
65166: LIST
65167: PUSH
65168: LD_INT 1
65170: PUSH
65171: LD_INT 0
65173: PUSH
65174: EMPTY
65175: LIST
65176: LIST
65177: PUSH
65178: LD_INT 1
65180: PUSH
65181: LD_INT 1
65183: PUSH
65184: EMPTY
65185: LIST
65186: LIST
65187: PUSH
65188: LD_INT 0
65190: PUSH
65191: LD_INT 1
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: PUSH
65198: LD_INT 1
65200: NEG
65201: PUSH
65202: LD_INT 0
65204: PUSH
65205: EMPTY
65206: LIST
65207: LIST
65208: PUSH
65209: LD_INT 1
65211: NEG
65212: PUSH
65213: LD_INT 1
65215: NEG
65216: PUSH
65217: EMPTY
65218: LIST
65219: LIST
65220: PUSH
65221: LD_INT 1
65223: NEG
65224: PUSH
65225: LD_INT 2
65227: NEG
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PUSH
65233: LD_INT 2
65235: PUSH
65236: LD_INT 1
65238: PUSH
65239: EMPTY
65240: LIST
65241: LIST
65242: PUSH
65243: LD_INT 2
65245: PUSH
65246: LD_INT 2
65248: PUSH
65249: EMPTY
65250: LIST
65251: LIST
65252: PUSH
65253: LD_INT 1
65255: PUSH
65256: LD_INT 2
65258: PUSH
65259: EMPTY
65260: LIST
65261: LIST
65262: PUSH
65263: LD_INT 2
65265: NEG
65266: PUSH
65267: LD_INT 1
65269: NEG
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PUSH
65275: LD_INT 2
65277: NEG
65278: PUSH
65279: LD_INT 2
65281: NEG
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 2
65289: NEG
65290: PUSH
65291: LD_INT 3
65293: NEG
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 3
65301: NEG
65302: PUSH
65303: LD_INT 2
65305: NEG
65306: PUSH
65307: EMPTY
65308: LIST
65309: LIST
65310: PUSH
65311: LD_INT 3
65313: NEG
65314: PUSH
65315: LD_INT 3
65317: NEG
65318: PUSH
65319: EMPTY
65320: LIST
65321: LIST
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: LIST
65327: LIST
65328: LIST
65329: LIST
65330: LIST
65331: LIST
65332: LIST
65333: LIST
65334: LIST
65335: LIST
65336: LIST
65337: LIST
65338: LIST
65339: LIST
65340: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
65341: LD_ADDR_VAR 0 14
65345: PUSH
65346: LD_INT 0
65348: PUSH
65349: LD_INT 0
65351: PUSH
65352: EMPTY
65353: LIST
65354: LIST
65355: PUSH
65356: LD_INT 0
65358: PUSH
65359: LD_INT 1
65361: NEG
65362: PUSH
65363: EMPTY
65364: LIST
65365: LIST
65366: PUSH
65367: LD_INT 1
65369: PUSH
65370: LD_INT 0
65372: PUSH
65373: EMPTY
65374: LIST
65375: LIST
65376: PUSH
65377: LD_INT 1
65379: PUSH
65380: LD_INT 1
65382: PUSH
65383: EMPTY
65384: LIST
65385: LIST
65386: PUSH
65387: LD_INT 0
65389: PUSH
65390: LD_INT 1
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: PUSH
65397: LD_INT 1
65399: NEG
65400: PUSH
65401: LD_INT 0
65403: PUSH
65404: EMPTY
65405: LIST
65406: LIST
65407: PUSH
65408: LD_INT 1
65410: NEG
65411: PUSH
65412: LD_INT 1
65414: NEG
65415: PUSH
65416: EMPTY
65417: LIST
65418: LIST
65419: PUSH
65420: LD_INT 1
65422: NEG
65423: PUSH
65424: LD_INT 2
65426: NEG
65427: PUSH
65428: EMPTY
65429: LIST
65430: LIST
65431: PUSH
65432: LD_INT 0
65434: PUSH
65435: LD_INT 2
65437: NEG
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: LD_INT 1
65445: PUSH
65446: LD_INT 1
65448: NEG
65449: PUSH
65450: EMPTY
65451: LIST
65452: LIST
65453: PUSH
65454: LD_INT 1
65456: PUSH
65457: LD_INT 2
65459: PUSH
65460: EMPTY
65461: LIST
65462: LIST
65463: PUSH
65464: LD_INT 0
65466: PUSH
65467: LD_INT 2
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PUSH
65474: LD_INT 1
65476: NEG
65477: PUSH
65478: LD_INT 1
65480: PUSH
65481: EMPTY
65482: LIST
65483: LIST
65484: PUSH
65485: LD_INT 1
65487: NEG
65488: PUSH
65489: LD_INT 3
65491: NEG
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PUSH
65497: LD_INT 0
65499: PUSH
65500: LD_INT 3
65502: NEG
65503: PUSH
65504: EMPTY
65505: LIST
65506: LIST
65507: PUSH
65508: LD_INT 1
65510: PUSH
65511: LD_INT 2
65513: NEG
65514: PUSH
65515: EMPTY
65516: LIST
65517: LIST
65518: PUSH
65519: EMPTY
65520: LIST
65521: LIST
65522: LIST
65523: LIST
65524: LIST
65525: LIST
65526: LIST
65527: LIST
65528: LIST
65529: LIST
65530: LIST
65531: LIST
65532: LIST
65533: LIST
65534: LIST
65535: LIST
65536: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
65537: LD_ADDR_VAR 0 15
65541: PUSH
65542: LD_INT 0
65544: PUSH
65545: LD_INT 0
65547: PUSH
65548: EMPTY
65549: LIST
65550: LIST
65551: PUSH
65552: LD_INT 0
65554: PUSH
65555: LD_INT 1
65557: NEG
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: PUSH
65563: LD_INT 1
65565: PUSH
65566: LD_INT 0
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: LD_INT 1
65575: PUSH
65576: LD_INT 1
65578: PUSH
65579: EMPTY
65580: LIST
65581: LIST
65582: PUSH
65583: LD_INT 0
65585: PUSH
65586: LD_INT 1
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 1
65595: NEG
65596: PUSH
65597: LD_INT 0
65599: PUSH
65600: EMPTY
65601: LIST
65602: LIST
65603: PUSH
65604: LD_INT 1
65606: NEG
65607: PUSH
65608: LD_INT 1
65610: NEG
65611: PUSH
65612: EMPTY
65613: LIST
65614: LIST
65615: PUSH
65616: LD_INT 1
65618: PUSH
65619: LD_INT 1
65621: NEG
65622: PUSH
65623: EMPTY
65624: LIST
65625: LIST
65626: PUSH
65627: LD_INT 2
65629: PUSH
65630: LD_INT 0
65632: PUSH
65633: EMPTY
65634: LIST
65635: LIST
65636: PUSH
65637: LD_INT 2
65639: PUSH
65640: LD_INT 1
65642: PUSH
65643: EMPTY
65644: LIST
65645: LIST
65646: PUSH
65647: LD_INT 1
65649: NEG
65650: PUSH
65651: LD_INT 1
65653: PUSH
65654: EMPTY
65655: LIST
65656: LIST
65657: PUSH
65658: LD_INT 2
65660: NEG
65661: PUSH
65662: LD_INT 0
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: PUSH
65669: LD_INT 2
65671: NEG
65672: PUSH
65673: LD_INT 1
65675: NEG
65676: PUSH
65677: EMPTY
65678: LIST
65679: LIST
65680: PUSH
65681: LD_INT 2
65683: PUSH
65684: LD_INT 1
65686: NEG
65687: PUSH
65688: EMPTY
65689: LIST
65690: LIST
65691: PUSH
65692: LD_INT 3
65694: PUSH
65695: LD_INT 0
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PUSH
65702: LD_INT 3
65704: PUSH
65705: LD_INT 1
65707: PUSH
65708: EMPTY
65709: LIST
65710: LIST
65711: PUSH
65712: EMPTY
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: LIST
65721: LIST
65722: LIST
65723: LIST
65724: LIST
65725: LIST
65726: LIST
65727: LIST
65728: LIST
65729: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65730: LD_ADDR_VAR 0 16
65734: PUSH
65735: LD_INT 0
65737: PUSH
65738: LD_INT 0
65740: PUSH
65741: EMPTY
65742: LIST
65743: LIST
65744: PUSH
65745: LD_INT 0
65747: PUSH
65748: LD_INT 1
65750: NEG
65751: PUSH
65752: EMPTY
65753: LIST
65754: LIST
65755: PUSH
65756: LD_INT 1
65758: PUSH
65759: LD_INT 0
65761: PUSH
65762: EMPTY
65763: LIST
65764: LIST
65765: PUSH
65766: LD_INT 1
65768: PUSH
65769: LD_INT 1
65771: PUSH
65772: EMPTY
65773: LIST
65774: LIST
65775: PUSH
65776: LD_INT 0
65778: PUSH
65779: LD_INT 1
65781: PUSH
65782: EMPTY
65783: LIST
65784: LIST
65785: PUSH
65786: LD_INT 1
65788: NEG
65789: PUSH
65790: LD_INT 0
65792: PUSH
65793: EMPTY
65794: LIST
65795: LIST
65796: PUSH
65797: LD_INT 1
65799: NEG
65800: PUSH
65801: LD_INT 1
65803: NEG
65804: PUSH
65805: EMPTY
65806: LIST
65807: LIST
65808: PUSH
65809: LD_INT 1
65811: NEG
65812: PUSH
65813: LD_INT 2
65815: NEG
65816: PUSH
65817: EMPTY
65818: LIST
65819: LIST
65820: PUSH
65821: LD_INT 2
65823: PUSH
65824: LD_INT 1
65826: PUSH
65827: EMPTY
65828: LIST
65829: LIST
65830: PUSH
65831: LD_INT 2
65833: PUSH
65834: LD_INT 2
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: PUSH
65841: LD_INT 1
65843: PUSH
65844: LD_INT 2
65846: PUSH
65847: EMPTY
65848: LIST
65849: LIST
65850: PUSH
65851: LD_INT 2
65853: NEG
65854: PUSH
65855: LD_INT 1
65857: NEG
65858: PUSH
65859: EMPTY
65860: LIST
65861: LIST
65862: PUSH
65863: LD_INT 2
65865: NEG
65866: PUSH
65867: LD_INT 2
65869: NEG
65870: PUSH
65871: EMPTY
65872: LIST
65873: LIST
65874: PUSH
65875: LD_INT 3
65877: PUSH
65878: LD_INT 2
65880: PUSH
65881: EMPTY
65882: LIST
65883: LIST
65884: PUSH
65885: LD_INT 3
65887: PUSH
65888: LD_INT 3
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 2
65897: PUSH
65898: LD_INT 3
65900: PUSH
65901: EMPTY
65902: LIST
65903: LIST
65904: PUSH
65905: EMPTY
65906: LIST
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65923: LD_ADDR_VAR 0 17
65927: PUSH
65928: LD_INT 0
65930: PUSH
65931: LD_INT 0
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PUSH
65938: LD_INT 0
65940: PUSH
65941: LD_INT 1
65943: NEG
65944: PUSH
65945: EMPTY
65946: LIST
65947: LIST
65948: PUSH
65949: LD_INT 1
65951: PUSH
65952: LD_INT 0
65954: PUSH
65955: EMPTY
65956: LIST
65957: LIST
65958: PUSH
65959: LD_INT 1
65961: PUSH
65962: LD_INT 1
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: PUSH
65969: LD_INT 0
65971: PUSH
65972: LD_INT 1
65974: PUSH
65975: EMPTY
65976: LIST
65977: LIST
65978: PUSH
65979: LD_INT 1
65981: NEG
65982: PUSH
65983: LD_INT 0
65985: PUSH
65986: EMPTY
65987: LIST
65988: LIST
65989: PUSH
65990: LD_INT 1
65992: NEG
65993: PUSH
65994: LD_INT 1
65996: NEG
65997: PUSH
65998: EMPTY
65999: LIST
66000: LIST
66001: PUSH
66002: LD_INT 1
66004: NEG
66005: PUSH
66006: LD_INT 2
66008: NEG
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: LD_INT 0
66016: PUSH
66017: LD_INT 2
66019: NEG
66020: PUSH
66021: EMPTY
66022: LIST
66023: LIST
66024: PUSH
66025: LD_INT 1
66027: PUSH
66028: LD_INT 1
66030: NEG
66031: PUSH
66032: EMPTY
66033: LIST
66034: LIST
66035: PUSH
66036: LD_INT 2
66038: PUSH
66039: LD_INT 0
66041: PUSH
66042: EMPTY
66043: LIST
66044: LIST
66045: PUSH
66046: LD_INT 2
66048: PUSH
66049: LD_INT 1
66051: PUSH
66052: EMPTY
66053: LIST
66054: LIST
66055: PUSH
66056: LD_INT 2
66058: PUSH
66059: LD_INT 2
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: PUSH
66066: LD_INT 1
66068: PUSH
66069: LD_INT 2
66071: PUSH
66072: EMPTY
66073: LIST
66074: LIST
66075: PUSH
66076: LD_INT 0
66078: PUSH
66079: LD_INT 2
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: PUSH
66086: LD_INT 1
66088: NEG
66089: PUSH
66090: LD_INT 1
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: PUSH
66097: LD_INT 2
66099: NEG
66100: PUSH
66101: LD_INT 0
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: PUSH
66108: LD_INT 2
66110: NEG
66111: PUSH
66112: LD_INT 1
66114: NEG
66115: PUSH
66116: EMPTY
66117: LIST
66118: LIST
66119: PUSH
66120: LD_INT 2
66122: NEG
66123: PUSH
66124: LD_INT 2
66126: NEG
66127: PUSH
66128: EMPTY
66129: LIST
66130: LIST
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66153: LD_ADDR_VAR 0 18
66157: PUSH
66158: LD_INT 0
66160: PUSH
66161: LD_INT 0
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PUSH
66168: LD_INT 0
66170: PUSH
66171: LD_INT 1
66173: NEG
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: LD_INT 1
66181: PUSH
66182: LD_INT 0
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: LD_INT 1
66191: PUSH
66192: LD_INT 1
66194: PUSH
66195: EMPTY
66196: LIST
66197: LIST
66198: PUSH
66199: LD_INT 0
66201: PUSH
66202: LD_INT 1
66204: PUSH
66205: EMPTY
66206: LIST
66207: LIST
66208: PUSH
66209: LD_INT 1
66211: NEG
66212: PUSH
66213: LD_INT 0
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: PUSH
66220: LD_INT 1
66222: NEG
66223: PUSH
66224: LD_INT 1
66226: NEG
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: PUSH
66232: LD_INT 1
66234: NEG
66235: PUSH
66236: LD_INT 2
66238: NEG
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: PUSH
66244: LD_INT 0
66246: PUSH
66247: LD_INT 2
66249: NEG
66250: PUSH
66251: EMPTY
66252: LIST
66253: LIST
66254: PUSH
66255: LD_INT 1
66257: PUSH
66258: LD_INT 1
66260: NEG
66261: PUSH
66262: EMPTY
66263: LIST
66264: LIST
66265: PUSH
66266: LD_INT 2
66268: PUSH
66269: LD_INT 0
66271: PUSH
66272: EMPTY
66273: LIST
66274: LIST
66275: PUSH
66276: LD_INT 2
66278: PUSH
66279: LD_INT 1
66281: PUSH
66282: EMPTY
66283: LIST
66284: LIST
66285: PUSH
66286: LD_INT 2
66288: PUSH
66289: LD_INT 2
66291: PUSH
66292: EMPTY
66293: LIST
66294: LIST
66295: PUSH
66296: LD_INT 1
66298: PUSH
66299: LD_INT 2
66301: PUSH
66302: EMPTY
66303: LIST
66304: LIST
66305: PUSH
66306: LD_INT 0
66308: PUSH
66309: LD_INT 2
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: PUSH
66316: LD_INT 1
66318: NEG
66319: PUSH
66320: LD_INT 1
66322: PUSH
66323: EMPTY
66324: LIST
66325: LIST
66326: PUSH
66327: LD_INT 2
66329: NEG
66330: PUSH
66331: LD_INT 0
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PUSH
66338: LD_INT 2
66340: NEG
66341: PUSH
66342: LD_INT 1
66344: NEG
66345: PUSH
66346: EMPTY
66347: LIST
66348: LIST
66349: PUSH
66350: LD_INT 2
66352: NEG
66353: PUSH
66354: LD_INT 2
66356: NEG
66357: PUSH
66358: EMPTY
66359: LIST
66360: LIST
66361: PUSH
66362: EMPTY
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: LIST
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: LIST
66382: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66383: LD_ADDR_VAR 0 19
66387: PUSH
66388: LD_INT 0
66390: PUSH
66391: LD_INT 0
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: LD_INT 0
66400: PUSH
66401: LD_INT 1
66403: NEG
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: PUSH
66409: LD_INT 1
66411: PUSH
66412: LD_INT 0
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: PUSH
66419: LD_INT 1
66421: PUSH
66422: LD_INT 1
66424: PUSH
66425: EMPTY
66426: LIST
66427: LIST
66428: PUSH
66429: LD_INT 0
66431: PUSH
66432: LD_INT 1
66434: PUSH
66435: EMPTY
66436: LIST
66437: LIST
66438: PUSH
66439: LD_INT 1
66441: NEG
66442: PUSH
66443: LD_INT 0
66445: PUSH
66446: EMPTY
66447: LIST
66448: LIST
66449: PUSH
66450: LD_INT 1
66452: NEG
66453: PUSH
66454: LD_INT 1
66456: NEG
66457: PUSH
66458: EMPTY
66459: LIST
66460: LIST
66461: PUSH
66462: LD_INT 1
66464: NEG
66465: PUSH
66466: LD_INT 2
66468: NEG
66469: PUSH
66470: EMPTY
66471: LIST
66472: LIST
66473: PUSH
66474: LD_INT 0
66476: PUSH
66477: LD_INT 2
66479: NEG
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PUSH
66485: LD_INT 1
66487: PUSH
66488: LD_INT 1
66490: NEG
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PUSH
66496: LD_INT 2
66498: PUSH
66499: LD_INT 0
66501: PUSH
66502: EMPTY
66503: LIST
66504: LIST
66505: PUSH
66506: LD_INT 2
66508: PUSH
66509: LD_INT 1
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: PUSH
66516: LD_INT 2
66518: PUSH
66519: LD_INT 2
66521: PUSH
66522: EMPTY
66523: LIST
66524: LIST
66525: PUSH
66526: LD_INT 1
66528: PUSH
66529: LD_INT 2
66531: PUSH
66532: EMPTY
66533: LIST
66534: LIST
66535: PUSH
66536: LD_INT 0
66538: PUSH
66539: LD_INT 2
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: PUSH
66546: LD_INT 1
66548: NEG
66549: PUSH
66550: LD_INT 1
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: PUSH
66557: LD_INT 2
66559: NEG
66560: PUSH
66561: LD_INT 0
66563: PUSH
66564: EMPTY
66565: LIST
66566: LIST
66567: PUSH
66568: LD_INT 2
66570: NEG
66571: PUSH
66572: LD_INT 1
66574: NEG
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 2
66582: NEG
66583: PUSH
66584: LD_INT 2
66586: NEG
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: EMPTY
66593: LIST
66594: LIST
66595: LIST
66596: LIST
66597: LIST
66598: LIST
66599: LIST
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66613: LD_ADDR_VAR 0 20
66617: PUSH
66618: LD_INT 0
66620: PUSH
66621: LD_INT 0
66623: PUSH
66624: EMPTY
66625: LIST
66626: LIST
66627: PUSH
66628: LD_INT 0
66630: PUSH
66631: LD_INT 1
66633: NEG
66634: PUSH
66635: EMPTY
66636: LIST
66637: LIST
66638: PUSH
66639: LD_INT 1
66641: PUSH
66642: LD_INT 0
66644: PUSH
66645: EMPTY
66646: LIST
66647: LIST
66648: PUSH
66649: LD_INT 1
66651: PUSH
66652: LD_INT 1
66654: PUSH
66655: EMPTY
66656: LIST
66657: LIST
66658: PUSH
66659: LD_INT 0
66661: PUSH
66662: LD_INT 1
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: PUSH
66669: LD_INT 1
66671: NEG
66672: PUSH
66673: LD_INT 0
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: PUSH
66680: LD_INT 1
66682: NEG
66683: PUSH
66684: LD_INT 1
66686: NEG
66687: PUSH
66688: EMPTY
66689: LIST
66690: LIST
66691: PUSH
66692: LD_INT 1
66694: NEG
66695: PUSH
66696: LD_INT 2
66698: NEG
66699: PUSH
66700: EMPTY
66701: LIST
66702: LIST
66703: PUSH
66704: LD_INT 0
66706: PUSH
66707: LD_INT 2
66709: NEG
66710: PUSH
66711: EMPTY
66712: LIST
66713: LIST
66714: PUSH
66715: LD_INT 1
66717: PUSH
66718: LD_INT 1
66720: NEG
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: PUSH
66726: LD_INT 2
66728: PUSH
66729: LD_INT 0
66731: PUSH
66732: EMPTY
66733: LIST
66734: LIST
66735: PUSH
66736: LD_INT 2
66738: PUSH
66739: LD_INT 1
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: PUSH
66746: LD_INT 2
66748: PUSH
66749: LD_INT 2
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: PUSH
66756: LD_INT 1
66758: PUSH
66759: LD_INT 2
66761: PUSH
66762: EMPTY
66763: LIST
66764: LIST
66765: PUSH
66766: LD_INT 0
66768: PUSH
66769: LD_INT 2
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: PUSH
66776: LD_INT 1
66778: NEG
66779: PUSH
66780: LD_INT 1
66782: PUSH
66783: EMPTY
66784: LIST
66785: LIST
66786: PUSH
66787: LD_INT 2
66789: NEG
66790: PUSH
66791: LD_INT 0
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: LD_INT 2
66800: NEG
66801: PUSH
66802: LD_INT 1
66804: NEG
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 2
66812: NEG
66813: PUSH
66814: LD_INT 2
66816: NEG
66817: PUSH
66818: EMPTY
66819: LIST
66820: LIST
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: LIST
66826: LIST
66827: LIST
66828: LIST
66829: LIST
66830: LIST
66831: LIST
66832: LIST
66833: LIST
66834: LIST
66835: LIST
66836: LIST
66837: LIST
66838: LIST
66839: LIST
66840: LIST
66841: LIST
66842: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66843: LD_ADDR_VAR 0 21
66847: PUSH
66848: LD_INT 0
66850: PUSH
66851: LD_INT 0
66853: PUSH
66854: EMPTY
66855: LIST
66856: LIST
66857: PUSH
66858: LD_INT 0
66860: PUSH
66861: LD_INT 1
66863: NEG
66864: PUSH
66865: EMPTY
66866: LIST
66867: LIST
66868: PUSH
66869: LD_INT 1
66871: PUSH
66872: LD_INT 0
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: PUSH
66879: LD_INT 1
66881: PUSH
66882: LD_INT 1
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: PUSH
66889: LD_INT 0
66891: PUSH
66892: LD_INT 1
66894: PUSH
66895: EMPTY
66896: LIST
66897: LIST
66898: PUSH
66899: LD_INT 1
66901: NEG
66902: PUSH
66903: LD_INT 0
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: PUSH
66910: LD_INT 1
66912: NEG
66913: PUSH
66914: LD_INT 1
66916: NEG
66917: PUSH
66918: EMPTY
66919: LIST
66920: LIST
66921: PUSH
66922: LD_INT 1
66924: NEG
66925: PUSH
66926: LD_INT 2
66928: NEG
66929: PUSH
66930: EMPTY
66931: LIST
66932: LIST
66933: PUSH
66934: LD_INT 0
66936: PUSH
66937: LD_INT 2
66939: NEG
66940: PUSH
66941: EMPTY
66942: LIST
66943: LIST
66944: PUSH
66945: LD_INT 1
66947: PUSH
66948: LD_INT 1
66950: NEG
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: PUSH
66956: LD_INT 2
66958: PUSH
66959: LD_INT 0
66961: PUSH
66962: EMPTY
66963: LIST
66964: LIST
66965: PUSH
66966: LD_INT 2
66968: PUSH
66969: LD_INT 1
66971: PUSH
66972: EMPTY
66973: LIST
66974: LIST
66975: PUSH
66976: LD_INT 2
66978: PUSH
66979: LD_INT 2
66981: PUSH
66982: EMPTY
66983: LIST
66984: LIST
66985: PUSH
66986: LD_INT 1
66988: PUSH
66989: LD_INT 2
66991: PUSH
66992: EMPTY
66993: LIST
66994: LIST
66995: PUSH
66996: LD_INT 0
66998: PUSH
66999: LD_INT 2
67001: PUSH
67002: EMPTY
67003: LIST
67004: LIST
67005: PUSH
67006: LD_INT 1
67008: NEG
67009: PUSH
67010: LD_INT 1
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: PUSH
67017: LD_INT 2
67019: NEG
67020: PUSH
67021: LD_INT 0
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: PUSH
67028: LD_INT 2
67030: NEG
67031: PUSH
67032: LD_INT 1
67034: NEG
67035: PUSH
67036: EMPTY
67037: LIST
67038: LIST
67039: PUSH
67040: LD_INT 2
67042: NEG
67043: PUSH
67044: LD_INT 2
67046: NEG
67047: PUSH
67048: EMPTY
67049: LIST
67050: LIST
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: LIST
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67073: LD_ADDR_VAR 0 22
67077: PUSH
67078: LD_INT 0
67080: PUSH
67081: LD_INT 0
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: PUSH
67088: LD_INT 0
67090: PUSH
67091: LD_INT 1
67093: NEG
67094: PUSH
67095: EMPTY
67096: LIST
67097: LIST
67098: PUSH
67099: LD_INT 1
67101: PUSH
67102: LD_INT 0
67104: PUSH
67105: EMPTY
67106: LIST
67107: LIST
67108: PUSH
67109: LD_INT 1
67111: PUSH
67112: LD_INT 1
67114: PUSH
67115: EMPTY
67116: LIST
67117: LIST
67118: PUSH
67119: LD_INT 0
67121: PUSH
67122: LD_INT 1
67124: PUSH
67125: EMPTY
67126: LIST
67127: LIST
67128: PUSH
67129: LD_INT 1
67131: NEG
67132: PUSH
67133: LD_INT 0
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 1
67142: NEG
67143: PUSH
67144: LD_INT 1
67146: NEG
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: PUSH
67152: LD_INT 1
67154: NEG
67155: PUSH
67156: LD_INT 2
67158: NEG
67159: PUSH
67160: EMPTY
67161: LIST
67162: LIST
67163: PUSH
67164: LD_INT 0
67166: PUSH
67167: LD_INT 2
67169: NEG
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 1
67177: PUSH
67178: LD_INT 1
67180: NEG
67181: PUSH
67182: EMPTY
67183: LIST
67184: LIST
67185: PUSH
67186: LD_INT 2
67188: PUSH
67189: LD_INT 0
67191: PUSH
67192: EMPTY
67193: LIST
67194: LIST
67195: PUSH
67196: LD_INT 2
67198: PUSH
67199: LD_INT 1
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: PUSH
67206: LD_INT 2
67208: PUSH
67209: LD_INT 2
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: LD_INT 1
67218: PUSH
67219: LD_INT 2
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: LD_INT 0
67228: PUSH
67229: LD_INT 2
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: LD_INT 1
67238: NEG
67239: PUSH
67240: LD_INT 1
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: PUSH
67247: LD_INT 2
67249: NEG
67250: PUSH
67251: LD_INT 0
67253: PUSH
67254: EMPTY
67255: LIST
67256: LIST
67257: PUSH
67258: LD_INT 2
67260: NEG
67261: PUSH
67262: LD_INT 1
67264: NEG
67265: PUSH
67266: EMPTY
67267: LIST
67268: LIST
67269: PUSH
67270: LD_INT 2
67272: NEG
67273: PUSH
67274: LD_INT 2
67276: NEG
67277: PUSH
67278: EMPTY
67279: LIST
67280: LIST
67281: PUSH
67282: EMPTY
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
67303: LD_ADDR_VAR 0 23
67307: PUSH
67308: LD_INT 0
67310: PUSH
67311: LD_INT 0
67313: PUSH
67314: EMPTY
67315: LIST
67316: LIST
67317: PUSH
67318: LD_INT 0
67320: PUSH
67321: LD_INT 1
67323: NEG
67324: PUSH
67325: EMPTY
67326: LIST
67327: LIST
67328: PUSH
67329: LD_INT 1
67331: PUSH
67332: LD_INT 0
67334: PUSH
67335: EMPTY
67336: LIST
67337: LIST
67338: PUSH
67339: LD_INT 1
67341: PUSH
67342: LD_INT 1
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 0
67351: PUSH
67352: LD_INT 1
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: LD_INT 1
67361: NEG
67362: PUSH
67363: LD_INT 0
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 1
67372: NEG
67373: PUSH
67374: LD_INT 1
67376: NEG
67377: PUSH
67378: EMPTY
67379: LIST
67380: LIST
67381: PUSH
67382: LD_INT 1
67384: NEG
67385: PUSH
67386: LD_INT 2
67388: NEG
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: LD_INT 0
67396: PUSH
67397: LD_INT 2
67399: NEG
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: PUSH
67405: LD_INT 1
67407: PUSH
67408: LD_INT 1
67410: NEG
67411: PUSH
67412: EMPTY
67413: LIST
67414: LIST
67415: PUSH
67416: LD_INT 2
67418: PUSH
67419: LD_INT 0
67421: PUSH
67422: EMPTY
67423: LIST
67424: LIST
67425: PUSH
67426: LD_INT 2
67428: PUSH
67429: LD_INT 1
67431: PUSH
67432: EMPTY
67433: LIST
67434: LIST
67435: PUSH
67436: LD_INT 2
67438: PUSH
67439: LD_INT 2
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: LD_INT 1
67448: PUSH
67449: LD_INT 2
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PUSH
67456: LD_INT 0
67458: PUSH
67459: LD_INT 2
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 1
67468: NEG
67469: PUSH
67470: LD_INT 1
67472: PUSH
67473: EMPTY
67474: LIST
67475: LIST
67476: PUSH
67477: LD_INT 2
67479: NEG
67480: PUSH
67481: LD_INT 0
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: PUSH
67488: LD_INT 2
67490: NEG
67491: PUSH
67492: LD_INT 1
67494: NEG
67495: PUSH
67496: EMPTY
67497: LIST
67498: LIST
67499: PUSH
67500: LD_INT 2
67502: NEG
67503: PUSH
67504: LD_INT 2
67506: NEG
67507: PUSH
67508: EMPTY
67509: LIST
67510: LIST
67511: PUSH
67512: LD_INT 2
67514: NEG
67515: PUSH
67516: LD_INT 3
67518: NEG
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PUSH
67524: LD_INT 1
67526: NEG
67527: PUSH
67528: LD_INT 3
67530: NEG
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 1
67538: PUSH
67539: LD_INT 2
67541: NEG
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 2
67549: PUSH
67550: LD_INT 1
67552: NEG
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: EMPTY
67559: LIST
67560: LIST
67561: LIST
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: LIST
67576: LIST
67577: LIST
67578: LIST
67579: LIST
67580: LIST
67581: LIST
67582: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
67583: LD_ADDR_VAR 0 24
67587: PUSH
67588: LD_INT 0
67590: PUSH
67591: LD_INT 0
67593: PUSH
67594: EMPTY
67595: LIST
67596: LIST
67597: PUSH
67598: LD_INT 0
67600: PUSH
67601: LD_INT 1
67603: NEG
67604: PUSH
67605: EMPTY
67606: LIST
67607: LIST
67608: PUSH
67609: LD_INT 1
67611: PUSH
67612: LD_INT 0
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: PUSH
67619: LD_INT 1
67621: PUSH
67622: LD_INT 1
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: PUSH
67629: LD_INT 0
67631: PUSH
67632: LD_INT 1
67634: PUSH
67635: EMPTY
67636: LIST
67637: LIST
67638: PUSH
67639: LD_INT 1
67641: NEG
67642: PUSH
67643: LD_INT 0
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: LD_INT 1
67652: NEG
67653: PUSH
67654: LD_INT 1
67656: NEG
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 1
67664: NEG
67665: PUSH
67666: LD_INT 2
67668: NEG
67669: PUSH
67670: EMPTY
67671: LIST
67672: LIST
67673: PUSH
67674: LD_INT 0
67676: PUSH
67677: LD_INT 2
67679: NEG
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: PUSH
67685: LD_INT 1
67687: PUSH
67688: LD_INT 1
67690: NEG
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PUSH
67696: LD_INT 2
67698: PUSH
67699: LD_INT 0
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: LD_INT 2
67708: PUSH
67709: LD_INT 1
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 2
67718: PUSH
67719: LD_INT 2
67721: PUSH
67722: EMPTY
67723: LIST
67724: LIST
67725: PUSH
67726: LD_INT 1
67728: PUSH
67729: LD_INT 2
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: PUSH
67736: LD_INT 0
67738: PUSH
67739: LD_INT 2
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: LD_INT 1
67748: NEG
67749: PUSH
67750: LD_INT 1
67752: PUSH
67753: EMPTY
67754: LIST
67755: LIST
67756: PUSH
67757: LD_INT 2
67759: NEG
67760: PUSH
67761: LD_INT 0
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 2
67770: NEG
67771: PUSH
67772: LD_INT 1
67774: NEG
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 2
67782: NEG
67783: PUSH
67784: LD_INT 2
67786: NEG
67787: PUSH
67788: EMPTY
67789: LIST
67790: LIST
67791: PUSH
67792: LD_INT 1
67794: PUSH
67795: LD_INT 2
67797: NEG
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 2
67805: PUSH
67806: LD_INT 1
67808: NEG
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 3
67816: PUSH
67817: LD_INT 1
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 3
67826: PUSH
67827: LD_INT 2
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
67859: LD_ADDR_VAR 0 25
67863: PUSH
67864: LD_INT 0
67866: PUSH
67867: LD_INT 0
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: LD_INT 0
67876: PUSH
67877: LD_INT 1
67879: NEG
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: PUSH
67885: LD_INT 1
67887: PUSH
67888: LD_INT 0
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 1
67897: PUSH
67898: LD_INT 1
67900: PUSH
67901: EMPTY
67902: LIST
67903: LIST
67904: PUSH
67905: LD_INT 0
67907: PUSH
67908: LD_INT 1
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: PUSH
67915: LD_INT 1
67917: NEG
67918: PUSH
67919: LD_INT 0
67921: PUSH
67922: EMPTY
67923: LIST
67924: LIST
67925: PUSH
67926: LD_INT 1
67928: NEG
67929: PUSH
67930: LD_INT 1
67932: NEG
67933: PUSH
67934: EMPTY
67935: LIST
67936: LIST
67937: PUSH
67938: LD_INT 1
67940: NEG
67941: PUSH
67942: LD_INT 2
67944: NEG
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 0
67952: PUSH
67953: LD_INT 2
67955: NEG
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 1
67963: PUSH
67964: LD_INT 1
67966: NEG
67967: PUSH
67968: EMPTY
67969: LIST
67970: LIST
67971: PUSH
67972: LD_INT 2
67974: PUSH
67975: LD_INT 0
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: LD_INT 2
67984: PUSH
67985: LD_INT 1
67987: PUSH
67988: EMPTY
67989: LIST
67990: LIST
67991: PUSH
67992: LD_INT 2
67994: PUSH
67995: LD_INT 2
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: PUSH
68002: LD_INT 1
68004: PUSH
68005: LD_INT 2
68007: PUSH
68008: EMPTY
68009: LIST
68010: LIST
68011: PUSH
68012: LD_INT 0
68014: PUSH
68015: LD_INT 2
68017: PUSH
68018: EMPTY
68019: LIST
68020: LIST
68021: PUSH
68022: LD_INT 1
68024: NEG
68025: PUSH
68026: LD_INT 1
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 2
68035: NEG
68036: PUSH
68037: LD_INT 0
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 2
68046: NEG
68047: PUSH
68048: LD_INT 1
68050: NEG
68051: PUSH
68052: EMPTY
68053: LIST
68054: LIST
68055: PUSH
68056: LD_INT 2
68058: NEG
68059: PUSH
68060: LD_INT 2
68062: NEG
68063: PUSH
68064: EMPTY
68065: LIST
68066: LIST
68067: PUSH
68068: LD_INT 3
68070: PUSH
68071: LD_INT 1
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: PUSH
68078: LD_INT 3
68080: PUSH
68081: LD_INT 2
68083: PUSH
68084: EMPTY
68085: LIST
68086: LIST
68087: PUSH
68088: LD_INT 2
68090: PUSH
68091: LD_INT 3
68093: PUSH
68094: EMPTY
68095: LIST
68096: LIST
68097: PUSH
68098: LD_INT 1
68100: PUSH
68101: LD_INT 3
68103: PUSH
68104: EMPTY
68105: LIST
68106: LIST
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: LIST
68129: LIST
68130: LIST
68131: LIST
68132: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
68133: LD_ADDR_VAR 0 26
68137: PUSH
68138: LD_INT 0
68140: PUSH
68141: LD_INT 0
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: PUSH
68148: LD_INT 0
68150: PUSH
68151: LD_INT 1
68153: NEG
68154: PUSH
68155: EMPTY
68156: LIST
68157: LIST
68158: PUSH
68159: LD_INT 1
68161: PUSH
68162: LD_INT 0
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: PUSH
68169: LD_INT 1
68171: PUSH
68172: LD_INT 1
68174: PUSH
68175: EMPTY
68176: LIST
68177: LIST
68178: PUSH
68179: LD_INT 0
68181: PUSH
68182: LD_INT 1
68184: PUSH
68185: EMPTY
68186: LIST
68187: LIST
68188: PUSH
68189: LD_INT 1
68191: NEG
68192: PUSH
68193: LD_INT 0
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 1
68202: NEG
68203: PUSH
68204: LD_INT 1
68206: NEG
68207: PUSH
68208: EMPTY
68209: LIST
68210: LIST
68211: PUSH
68212: LD_INT 1
68214: NEG
68215: PUSH
68216: LD_INT 2
68218: NEG
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 0
68226: PUSH
68227: LD_INT 2
68229: NEG
68230: PUSH
68231: EMPTY
68232: LIST
68233: LIST
68234: PUSH
68235: LD_INT 1
68237: PUSH
68238: LD_INT 1
68240: NEG
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: PUSH
68246: LD_INT 2
68248: PUSH
68249: LD_INT 0
68251: PUSH
68252: EMPTY
68253: LIST
68254: LIST
68255: PUSH
68256: LD_INT 2
68258: PUSH
68259: LD_INT 1
68261: PUSH
68262: EMPTY
68263: LIST
68264: LIST
68265: PUSH
68266: LD_INT 2
68268: PUSH
68269: LD_INT 2
68271: PUSH
68272: EMPTY
68273: LIST
68274: LIST
68275: PUSH
68276: LD_INT 1
68278: PUSH
68279: LD_INT 2
68281: PUSH
68282: EMPTY
68283: LIST
68284: LIST
68285: PUSH
68286: LD_INT 0
68288: PUSH
68289: LD_INT 2
68291: PUSH
68292: EMPTY
68293: LIST
68294: LIST
68295: PUSH
68296: LD_INT 1
68298: NEG
68299: PUSH
68300: LD_INT 1
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: LD_INT 2
68309: NEG
68310: PUSH
68311: LD_INT 0
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 2
68320: NEG
68321: PUSH
68322: LD_INT 1
68324: NEG
68325: PUSH
68326: EMPTY
68327: LIST
68328: LIST
68329: PUSH
68330: LD_INT 2
68332: NEG
68333: PUSH
68334: LD_INT 2
68336: NEG
68337: PUSH
68338: EMPTY
68339: LIST
68340: LIST
68341: PUSH
68342: LD_INT 2
68344: PUSH
68345: LD_INT 3
68347: PUSH
68348: EMPTY
68349: LIST
68350: LIST
68351: PUSH
68352: LD_INT 1
68354: PUSH
68355: LD_INT 3
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: PUSH
68362: LD_INT 1
68364: NEG
68365: PUSH
68366: LD_INT 2
68368: PUSH
68369: EMPTY
68370: LIST
68371: LIST
68372: PUSH
68373: LD_INT 2
68375: NEG
68376: PUSH
68377: LD_INT 1
68379: PUSH
68380: EMPTY
68381: LIST
68382: LIST
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68409: LD_ADDR_VAR 0 27
68413: PUSH
68414: LD_INT 0
68416: PUSH
68417: LD_INT 0
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: LD_INT 0
68426: PUSH
68427: LD_INT 1
68429: NEG
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 1
68437: PUSH
68438: LD_INT 0
68440: PUSH
68441: EMPTY
68442: LIST
68443: LIST
68444: PUSH
68445: LD_INT 1
68447: PUSH
68448: LD_INT 1
68450: PUSH
68451: EMPTY
68452: LIST
68453: LIST
68454: PUSH
68455: LD_INT 0
68457: PUSH
68458: LD_INT 1
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PUSH
68465: LD_INT 1
68467: NEG
68468: PUSH
68469: LD_INT 0
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PUSH
68476: LD_INT 1
68478: NEG
68479: PUSH
68480: LD_INT 1
68482: NEG
68483: PUSH
68484: EMPTY
68485: LIST
68486: LIST
68487: PUSH
68488: LD_INT 1
68490: NEG
68491: PUSH
68492: LD_INT 2
68494: NEG
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: PUSH
68500: LD_INT 0
68502: PUSH
68503: LD_INT 2
68505: NEG
68506: PUSH
68507: EMPTY
68508: LIST
68509: LIST
68510: PUSH
68511: LD_INT 1
68513: PUSH
68514: LD_INT 1
68516: NEG
68517: PUSH
68518: EMPTY
68519: LIST
68520: LIST
68521: PUSH
68522: LD_INT 2
68524: PUSH
68525: LD_INT 0
68527: PUSH
68528: EMPTY
68529: LIST
68530: LIST
68531: PUSH
68532: LD_INT 2
68534: PUSH
68535: LD_INT 1
68537: PUSH
68538: EMPTY
68539: LIST
68540: LIST
68541: PUSH
68542: LD_INT 2
68544: PUSH
68545: LD_INT 2
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 1
68554: PUSH
68555: LD_INT 2
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: PUSH
68562: LD_INT 0
68564: PUSH
68565: LD_INT 2
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: LD_INT 1
68574: NEG
68575: PUSH
68576: LD_INT 1
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: PUSH
68583: LD_INT 2
68585: NEG
68586: PUSH
68587: LD_INT 0
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: PUSH
68594: LD_INT 2
68596: NEG
68597: PUSH
68598: LD_INT 1
68600: NEG
68601: PUSH
68602: EMPTY
68603: LIST
68604: LIST
68605: PUSH
68606: LD_INT 2
68608: NEG
68609: PUSH
68610: LD_INT 2
68612: NEG
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: PUSH
68618: LD_INT 1
68620: NEG
68621: PUSH
68622: LD_INT 2
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: PUSH
68629: LD_INT 2
68631: NEG
68632: PUSH
68633: LD_INT 1
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 3
68642: NEG
68643: PUSH
68644: LD_INT 1
68646: NEG
68647: PUSH
68648: EMPTY
68649: LIST
68650: LIST
68651: PUSH
68652: LD_INT 3
68654: NEG
68655: PUSH
68656: LD_INT 2
68658: NEG
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: LIST
68668: LIST
68669: LIST
68670: LIST
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68689: LD_ADDR_VAR 0 28
68693: PUSH
68694: LD_INT 0
68696: PUSH
68697: LD_INT 0
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: LD_INT 0
68706: PUSH
68707: LD_INT 1
68709: NEG
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 1
68717: PUSH
68718: LD_INT 0
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 1
68727: PUSH
68728: LD_INT 1
68730: PUSH
68731: EMPTY
68732: LIST
68733: LIST
68734: PUSH
68735: LD_INT 0
68737: PUSH
68738: LD_INT 1
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 1
68747: NEG
68748: PUSH
68749: LD_INT 0
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: PUSH
68756: LD_INT 1
68758: NEG
68759: PUSH
68760: LD_INT 1
68762: NEG
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 1
68770: NEG
68771: PUSH
68772: LD_INT 2
68774: NEG
68775: PUSH
68776: EMPTY
68777: LIST
68778: LIST
68779: PUSH
68780: LD_INT 0
68782: PUSH
68783: LD_INT 2
68785: NEG
68786: PUSH
68787: EMPTY
68788: LIST
68789: LIST
68790: PUSH
68791: LD_INT 1
68793: PUSH
68794: LD_INT 1
68796: NEG
68797: PUSH
68798: EMPTY
68799: LIST
68800: LIST
68801: PUSH
68802: LD_INT 2
68804: PUSH
68805: LD_INT 0
68807: PUSH
68808: EMPTY
68809: LIST
68810: LIST
68811: PUSH
68812: LD_INT 2
68814: PUSH
68815: LD_INT 1
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: PUSH
68822: LD_INT 2
68824: PUSH
68825: LD_INT 2
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: PUSH
68832: LD_INT 1
68834: PUSH
68835: LD_INT 2
68837: PUSH
68838: EMPTY
68839: LIST
68840: LIST
68841: PUSH
68842: LD_INT 0
68844: PUSH
68845: LD_INT 2
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: LD_INT 1
68854: NEG
68855: PUSH
68856: LD_INT 1
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: LD_INT 0
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: PUSH
68874: LD_INT 2
68876: NEG
68877: PUSH
68878: LD_INT 1
68880: NEG
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PUSH
68886: LD_INT 2
68888: NEG
68889: PUSH
68890: LD_INT 2
68892: NEG
68893: PUSH
68894: EMPTY
68895: LIST
68896: LIST
68897: PUSH
68898: LD_INT 2
68900: NEG
68901: PUSH
68902: LD_INT 3
68904: NEG
68905: PUSH
68906: EMPTY
68907: LIST
68908: LIST
68909: PUSH
68910: LD_INT 1
68912: NEG
68913: PUSH
68914: LD_INT 3
68916: NEG
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 3
68924: NEG
68925: PUSH
68926: LD_INT 1
68928: NEG
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 3
68936: NEG
68937: PUSH
68938: LD_INT 2
68940: NEG
68941: PUSH
68942: EMPTY
68943: LIST
68944: LIST
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68971: LD_ADDR_VAR 0 29
68975: PUSH
68976: LD_INT 0
68978: PUSH
68979: LD_INT 0
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 0
68988: PUSH
68989: LD_INT 1
68991: NEG
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: PUSH
68997: LD_INT 1
68999: PUSH
69000: LD_INT 0
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: LD_INT 1
69009: PUSH
69010: LD_INT 1
69012: PUSH
69013: EMPTY
69014: LIST
69015: LIST
69016: PUSH
69017: LD_INT 0
69019: PUSH
69020: LD_INT 1
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 1
69029: NEG
69030: PUSH
69031: LD_INT 0
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 1
69040: NEG
69041: PUSH
69042: LD_INT 1
69044: NEG
69045: PUSH
69046: EMPTY
69047: LIST
69048: LIST
69049: PUSH
69050: LD_INT 1
69052: NEG
69053: PUSH
69054: LD_INT 2
69056: NEG
69057: PUSH
69058: EMPTY
69059: LIST
69060: LIST
69061: PUSH
69062: LD_INT 0
69064: PUSH
69065: LD_INT 2
69067: NEG
69068: PUSH
69069: EMPTY
69070: LIST
69071: LIST
69072: PUSH
69073: LD_INT 1
69075: PUSH
69076: LD_INT 1
69078: NEG
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 2
69086: PUSH
69087: LD_INT 0
69089: PUSH
69090: EMPTY
69091: LIST
69092: LIST
69093: PUSH
69094: LD_INT 2
69096: PUSH
69097: LD_INT 1
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: LD_INT 1
69106: PUSH
69107: LD_INT 2
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: PUSH
69114: LD_INT 0
69116: PUSH
69117: LD_INT 2
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: PUSH
69124: LD_INT 1
69126: NEG
69127: PUSH
69128: LD_INT 1
69130: PUSH
69131: EMPTY
69132: LIST
69133: LIST
69134: PUSH
69135: LD_INT 2
69137: NEG
69138: PUSH
69139: LD_INT 1
69141: NEG
69142: PUSH
69143: EMPTY
69144: LIST
69145: LIST
69146: PUSH
69147: LD_INT 2
69149: NEG
69150: PUSH
69151: LD_INT 2
69153: NEG
69154: PUSH
69155: EMPTY
69156: LIST
69157: LIST
69158: PUSH
69159: LD_INT 2
69161: NEG
69162: PUSH
69163: LD_INT 3
69165: NEG
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: PUSH
69171: LD_INT 2
69173: PUSH
69174: LD_INT 1
69176: NEG
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PUSH
69182: LD_INT 3
69184: PUSH
69185: LD_INT 1
69187: PUSH
69188: EMPTY
69189: LIST
69190: LIST
69191: PUSH
69192: LD_INT 1
69194: PUSH
69195: LD_INT 3
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 1
69204: NEG
69205: PUSH
69206: LD_INT 2
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: PUSH
69213: LD_INT 3
69215: NEG
69216: PUSH
69217: LD_INT 2
69219: NEG
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: LIST
69229: LIST
69230: LIST
69231: LIST
69232: LIST
69233: LIST
69234: LIST
69235: LIST
69236: LIST
69237: LIST
69238: LIST
69239: LIST
69240: LIST
69241: LIST
69242: LIST
69243: LIST
69244: LIST
69245: LIST
69246: LIST
69247: LIST
69248: LIST
69249: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69250: LD_ADDR_VAR 0 30
69254: PUSH
69255: LD_INT 0
69257: PUSH
69258: LD_INT 0
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PUSH
69265: LD_INT 0
69267: PUSH
69268: LD_INT 1
69270: NEG
69271: PUSH
69272: EMPTY
69273: LIST
69274: LIST
69275: PUSH
69276: LD_INT 1
69278: PUSH
69279: LD_INT 0
69281: PUSH
69282: EMPTY
69283: LIST
69284: LIST
69285: PUSH
69286: LD_INT 1
69288: PUSH
69289: LD_INT 1
69291: PUSH
69292: EMPTY
69293: LIST
69294: LIST
69295: PUSH
69296: LD_INT 0
69298: PUSH
69299: LD_INT 1
69301: PUSH
69302: EMPTY
69303: LIST
69304: LIST
69305: PUSH
69306: LD_INT 1
69308: NEG
69309: PUSH
69310: LD_INT 0
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 1
69319: NEG
69320: PUSH
69321: LD_INT 1
69323: NEG
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: PUSH
69329: LD_INT 1
69331: NEG
69332: PUSH
69333: LD_INT 2
69335: NEG
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: PUSH
69341: LD_INT 0
69343: PUSH
69344: LD_INT 2
69346: NEG
69347: PUSH
69348: EMPTY
69349: LIST
69350: LIST
69351: PUSH
69352: LD_INT 1
69354: PUSH
69355: LD_INT 1
69357: NEG
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PUSH
69363: LD_INT 2
69365: PUSH
69366: LD_INT 0
69368: PUSH
69369: EMPTY
69370: LIST
69371: LIST
69372: PUSH
69373: LD_INT 2
69375: PUSH
69376: LD_INT 1
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 2
69385: PUSH
69386: LD_INT 2
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: LD_INT 1
69395: PUSH
69396: LD_INT 2
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PUSH
69403: LD_INT 1
69405: NEG
69406: PUSH
69407: LD_INT 1
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 2
69416: NEG
69417: PUSH
69418: LD_INT 0
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 2
69427: NEG
69428: PUSH
69429: LD_INT 1
69431: NEG
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 1
69439: NEG
69440: PUSH
69441: LD_INT 3
69443: NEG
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 1
69451: PUSH
69452: LD_INT 2
69454: NEG
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 3
69462: PUSH
69463: LD_INT 2
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 2
69472: PUSH
69473: LD_INT 3
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: PUSH
69480: LD_INT 2
69482: NEG
69483: PUSH
69484: LD_INT 1
69486: PUSH
69487: EMPTY
69488: LIST
69489: LIST
69490: PUSH
69491: LD_INT 3
69493: NEG
69494: PUSH
69495: LD_INT 1
69497: NEG
69498: PUSH
69499: EMPTY
69500: LIST
69501: LIST
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: LIST
69507: LIST
69508: LIST
69509: LIST
69510: LIST
69511: LIST
69512: LIST
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: LIST
69526: LIST
69527: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69528: LD_ADDR_VAR 0 31
69532: PUSH
69533: LD_INT 0
69535: PUSH
69536: LD_INT 0
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: PUSH
69543: LD_INT 0
69545: PUSH
69546: LD_INT 1
69548: NEG
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: LD_INT 1
69556: PUSH
69557: LD_INT 0
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 1
69566: PUSH
69567: LD_INT 1
69569: PUSH
69570: EMPTY
69571: LIST
69572: LIST
69573: PUSH
69574: LD_INT 0
69576: PUSH
69577: LD_INT 1
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: PUSH
69584: LD_INT 1
69586: NEG
69587: PUSH
69588: LD_INT 0
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: PUSH
69595: LD_INT 1
69597: NEG
69598: PUSH
69599: LD_INT 1
69601: NEG
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 1
69609: NEG
69610: PUSH
69611: LD_INT 2
69613: NEG
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PUSH
69619: LD_INT 1
69621: PUSH
69622: LD_INT 1
69624: NEG
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: LD_INT 2
69632: PUSH
69633: LD_INT 0
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: LD_INT 2
69642: PUSH
69643: LD_INT 1
69645: PUSH
69646: EMPTY
69647: LIST
69648: LIST
69649: PUSH
69650: LD_INT 2
69652: PUSH
69653: LD_INT 2
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: PUSH
69660: LD_INT 1
69662: PUSH
69663: LD_INT 2
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 0
69672: PUSH
69673: LD_INT 2
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 1
69682: NEG
69683: PUSH
69684: LD_INT 1
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: LD_INT 2
69693: NEG
69694: PUSH
69695: LD_INT 1
69697: NEG
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: LD_INT 2
69705: NEG
69706: PUSH
69707: LD_INT 2
69709: NEG
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: LD_INT 2
69717: NEG
69718: PUSH
69719: LD_INT 3
69721: NEG
69722: PUSH
69723: EMPTY
69724: LIST
69725: LIST
69726: PUSH
69727: LD_INT 2
69729: PUSH
69730: LD_INT 1
69732: NEG
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: PUSH
69738: LD_INT 3
69740: PUSH
69741: LD_INT 1
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: PUSH
69748: LD_INT 1
69750: PUSH
69751: LD_INT 3
69753: PUSH
69754: EMPTY
69755: LIST
69756: LIST
69757: PUSH
69758: LD_INT 1
69760: NEG
69761: PUSH
69762: LD_INT 2
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: PUSH
69769: LD_INT 3
69771: NEG
69772: PUSH
69773: LD_INT 2
69775: NEG
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: LIST
69785: LIST
69786: LIST
69787: LIST
69788: LIST
69789: LIST
69790: LIST
69791: LIST
69792: LIST
69793: LIST
69794: LIST
69795: LIST
69796: LIST
69797: LIST
69798: LIST
69799: LIST
69800: LIST
69801: LIST
69802: LIST
69803: LIST
69804: LIST
69805: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69806: LD_ADDR_VAR 0 32
69810: PUSH
69811: LD_INT 0
69813: PUSH
69814: LD_INT 0
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 0
69823: PUSH
69824: LD_INT 1
69826: NEG
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: LD_INT 1
69834: PUSH
69835: LD_INT 0
69837: PUSH
69838: EMPTY
69839: LIST
69840: LIST
69841: PUSH
69842: LD_INT 1
69844: PUSH
69845: LD_INT 1
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: PUSH
69852: LD_INT 0
69854: PUSH
69855: LD_INT 1
69857: PUSH
69858: EMPTY
69859: LIST
69860: LIST
69861: PUSH
69862: LD_INT 1
69864: NEG
69865: PUSH
69866: LD_INT 0
69868: PUSH
69869: EMPTY
69870: LIST
69871: LIST
69872: PUSH
69873: LD_INT 1
69875: NEG
69876: PUSH
69877: LD_INT 1
69879: NEG
69880: PUSH
69881: EMPTY
69882: LIST
69883: LIST
69884: PUSH
69885: LD_INT 1
69887: NEG
69888: PUSH
69889: LD_INT 2
69891: NEG
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 0
69899: PUSH
69900: LD_INT 2
69902: NEG
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: LD_INT 1
69910: PUSH
69911: LD_INT 1
69913: NEG
69914: PUSH
69915: EMPTY
69916: LIST
69917: LIST
69918: PUSH
69919: LD_INT 2
69921: PUSH
69922: LD_INT 1
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: LD_INT 2
69931: PUSH
69932: LD_INT 2
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: PUSH
69939: LD_INT 1
69941: PUSH
69942: LD_INT 2
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: PUSH
69949: LD_INT 0
69951: PUSH
69952: LD_INT 2
69954: PUSH
69955: EMPTY
69956: LIST
69957: LIST
69958: PUSH
69959: LD_INT 1
69961: NEG
69962: PUSH
69963: LD_INT 1
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: PUSH
69970: LD_INT 2
69972: NEG
69973: PUSH
69974: LD_INT 0
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 2
69983: NEG
69984: PUSH
69985: LD_INT 1
69987: NEG
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: LD_INT 1
69995: NEG
69996: PUSH
69997: LD_INT 3
69999: NEG
70000: PUSH
70001: EMPTY
70002: LIST
70003: LIST
70004: PUSH
70005: LD_INT 1
70007: PUSH
70008: LD_INT 2
70010: NEG
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: LD_INT 3
70018: PUSH
70019: LD_INT 2
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: PUSH
70026: LD_INT 2
70028: PUSH
70029: LD_INT 3
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: PUSH
70036: LD_INT 2
70038: NEG
70039: PUSH
70040: LD_INT 1
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 3
70049: NEG
70050: PUSH
70051: LD_INT 1
70053: NEG
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: PUSH
70059: EMPTY
70060: LIST
70061: LIST
70062: LIST
70063: LIST
70064: LIST
70065: LIST
70066: LIST
70067: LIST
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: LIST
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70084: LD_ADDR_VAR 0 33
70088: PUSH
70089: LD_INT 0
70091: PUSH
70092: LD_INT 0
70094: PUSH
70095: EMPTY
70096: LIST
70097: LIST
70098: PUSH
70099: LD_INT 0
70101: PUSH
70102: LD_INT 1
70104: NEG
70105: PUSH
70106: EMPTY
70107: LIST
70108: LIST
70109: PUSH
70110: LD_INT 1
70112: PUSH
70113: LD_INT 0
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: PUSH
70120: LD_INT 1
70122: PUSH
70123: LD_INT 1
70125: PUSH
70126: EMPTY
70127: LIST
70128: LIST
70129: PUSH
70130: LD_INT 0
70132: PUSH
70133: LD_INT 1
70135: PUSH
70136: EMPTY
70137: LIST
70138: LIST
70139: PUSH
70140: LD_INT 1
70142: NEG
70143: PUSH
70144: LD_INT 0
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: LD_INT 1
70153: NEG
70154: PUSH
70155: LD_INT 1
70157: NEG
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 1
70165: NEG
70166: PUSH
70167: LD_INT 2
70169: NEG
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 1
70177: PUSH
70178: LD_INT 1
70180: NEG
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: LD_INT 2
70188: PUSH
70189: LD_INT 0
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 2
70198: PUSH
70199: LD_INT 1
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 1
70208: PUSH
70209: LD_INT 2
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 0
70218: PUSH
70219: LD_INT 2
70221: PUSH
70222: EMPTY
70223: LIST
70224: LIST
70225: PUSH
70226: LD_INT 1
70228: NEG
70229: PUSH
70230: LD_INT 1
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PUSH
70237: LD_INT 2
70239: NEG
70240: PUSH
70241: LD_INT 0
70243: PUSH
70244: EMPTY
70245: LIST
70246: LIST
70247: PUSH
70248: LD_INT 2
70250: NEG
70251: PUSH
70252: LD_INT 1
70254: NEG
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 2
70262: NEG
70263: PUSH
70264: LD_INT 2
70266: NEG
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: LD_INT 2
70274: NEG
70275: PUSH
70276: LD_INT 3
70278: NEG
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: PUSH
70284: LD_INT 2
70286: PUSH
70287: LD_INT 1
70289: NEG
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 3
70297: PUSH
70298: LD_INT 1
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 1
70307: PUSH
70308: LD_INT 3
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PUSH
70315: LD_INT 1
70317: NEG
70318: PUSH
70319: LD_INT 2
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 3
70328: NEG
70329: PUSH
70330: LD_INT 2
70332: NEG
70333: PUSH
70334: EMPTY
70335: LIST
70336: LIST
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: LIST
70342: LIST
70343: LIST
70344: LIST
70345: LIST
70346: LIST
70347: LIST
70348: LIST
70349: LIST
70350: LIST
70351: LIST
70352: LIST
70353: LIST
70354: LIST
70355: LIST
70356: LIST
70357: LIST
70358: LIST
70359: LIST
70360: LIST
70361: LIST
70362: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70363: LD_ADDR_VAR 0 34
70367: PUSH
70368: LD_INT 0
70370: PUSH
70371: LD_INT 0
70373: PUSH
70374: EMPTY
70375: LIST
70376: LIST
70377: PUSH
70378: LD_INT 0
70380: PUSH
70381: LD_INT 1
70383: NEG
70384: PUSH
70385: EMPTY
70386: LIST
70387: LIST
70388: PUSH
70389: LD_INT 1
70391: PUSH
70392: LD_INT 0
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: LD_INT 1
70401: PUSH
70402: LD_INT 1
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 0
70411: PUSH
70412: LD_INT 1
70414: PUSH
70415: EMPTY
70416: LIST
70417: LIST
70418: PUSH
70419: LD_INT 1
70421: NEG
70422: PUSH
70423: LD_INT 0
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: PUSH
70430: LD_INT 1
70432: NEG
70433: PUSH
70434: LD_INT 1
70436: NEG
70437: PUSH
70438: EMPTY
70439: LIST
70440: LIST
70441: PUSH
70442: LD_INT 1
70444: NEG
70445: PUSH
70446: LD_INT 2
70448: NEG
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: PUSH
70454: LD_INT 0
70456: PUSH
70457: LD_INT 2
70459: NEG
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: PUSH
70465: LD_INT 1
70467: PUSH
70468: LD_INT 1
70470: NEG
70471: PUSH
70472: EMPTY
70473: LIST
70474: LIST
70475: PUSH
70476: LD_INT 2
70478: PUSH
70479: LD_INT 1
70481: PUSH
70482: EMPTY
70483: LIST
70484: LIST
70485: PUSH
70486: LD_INT 2
70488: PUSH
70489: LD_INT 2
70491: PUSH
70492: EMPTY
70493: LIST
70494: LIST
70495: PUSH
70496: LD_INT 1
70498: PUSH
70499: LD_INT 2
70501: PUSH
70502: EMPTY
70503: LIST
70504: LIST
70505: PUSH
70506: LD_INT 1
70508: NEG
70509: PUSH
70510: LD_INT 1
70512: PUSH
70513: EMPTY
70514: LIST
70515: LIST
70516: PUSH
70517: LD_INT 2
70519: NEG
70520: PUSH
70521: LD_INT 0
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: PUSH
70528: LD_INT 2
70530: NEG
70531: PUSH
70532: LD_INT 1
70534: NEG
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: PUSH
70540: LD_INT 2
70542: NEG
70543: PUSH
70544: LD_INT 2
70546: NEG
70547: PUSH
70548: EMPTY
70549: LIST
70550: LIST
70551: PUSH
70552: LD_INT 1
70554: NEG
70555: PUSH
70556: LD_INT 3
70558: NEG
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 1
70566: PUSH
70567: LD_INT 2
70569: NEG
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PUSH
70575: LD_INT 3
70577: PUSH
70578: LD_INT 2
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: PUSH
70585: LD_INT 2
70587: PUSH
70588: LD_INT 3
70590: PUSH
70591: EMPTY
70592: LIST
70593: LIST
70594: PUSH
70595: LD_INT 2
70597: NEG
70598: PUSH
70599: LD_INT 1
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: LD_INT 3
70608: NEG
70609: PUSH
70610: LD_INT 1
70612: NEG
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: LIST
70622: LIST
70623: LIST
70624: LIST
70625: LIST
70626: LIST
70627: LIST
70628: LIST
70629: LIST
70630: LIST
70631: LIST
70632: LIST
70633: LIST
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: LIST
70642: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70643: LD_ADDR_VAR 0 35
70647: PUSH
70648: LD_INT 0
70650: PUSH
70651: LD_INT 0
70653: PUSH
70654: EMPTY
70655: LIST
70656: LIST
70657: PUSH
70658: LD_INT 0
70660: PUSH
70661: LD_INT 1
70663: NEG
70664: PUSH
70665: EMPTY
70666: LIST
70667: LIST
70668: PUSH
70669: LD_INT 1
70671: PUSH
70672: LD_INT 0
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: LD_INT 1
70681: PUSH
70682: LD_INT 1
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 0
70691: PUSH
70692: LD_INT 1
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 1
70701: NEG
70702: PUSH
70703: LD_INT 0
70705: PUSH
70706: EMPTY
70707: LIST
70708: LIST
70709: PUSH
70710: LD_INT 1
70712: NEG
70713: PUSH
70714: LD_INT 1
70716: NEG
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PUSH
70722: LD_INT 2
70724: PUSH
70725: LD_INT 1
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: PUSH
70732: LD_INT 2
70734: NEG
70735: PUSH
70736: LD_INT 1
70738: NEG
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: EMPTY
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70755: LD_ADDR_VAR 0 36
70759: PUSH
70760: LD_INT 0
70762: PUSH
70763: LD_INT 0
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: PUSH
70770: LD_INT 0
70772: PUSH
70773: LD_INT 1
70775: NEG
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: PUSH
70781: LD_INT 1
70783: PUSH
70784: LD_INT 0
70786: PUSH
70787: EMPTY
70788: LIST
70789: LIST
70790: PUSH
70791: LD_INT 1
70793: PUSH
70794: LD_INT 1
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: LD_INT 0
70803: PUSH
70804: LD_INT 1
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 1
70813: NEG
70814: PUSH
70815: LD_INT 0
70817: PUSH
70818: EMPTY
70819: LIST
70820: LIST
70821: PUSH
70822: LD_INT 1
70824: NEG
70825: PUSH
70826: LD_INT 1
70828: NEG
70829: PUSH
70830: EMPTY
70831: LIST
70832: LIST
70833: PUSH
70834: LD_INT 1
70836: NEG
70837: PUSH
70838: LD_INT 2
70840: NEG
70841: PUSH
70842: EMPTY
70843: LIST
70844: LIST
70845: PUSH
70846: LD_INT 1
70848: PUSH
70849: LD_INT 2
70851: PUSH
70852: EMPTY
70853: LIST
70854: LIST
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: LIST
70860: LIST
70861: LIST
70862: LIST
70863: LIST
70864: LIST
70865: LIST
70866: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70867: LD_ADDR_VAR 0 37
70871: PUSH
70872: LD_INT 0
70874: PUSH
70875: LD_INT 0
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 0
70884: PUSH
70885: LD_INT 1
70887: NEG
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: LD_INT 1
70895: PUSH
70896: LD_INT 0
70898: PUSH
70899: EMPTY
70900: LIST
70901: LIST
70902: PUSH
70903: LD_INT 1
70905: PUSH
70906: LD_INT 1
70908: PUSH
70909: EMPTY
70910: LIST
70911: LIST
70912: PUSH
70913: LD_INT 0
70915: PUSH
70916: LD_INT 1
70918: PUSH
70919: EMPTY
70920: LIST
70921: LIST
70922: PUSH
70923: LD_INT 1
70925: NEG
70926: PUSH
70927: LD_INT 0
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PUSH
70934: LD_INT 1
70936: NEG
70937: PUSH
70938: LD_INT 1
70940: NEG
70941: PUSH
70942: EMPTY
70943: LIST
70944: LIST
70945: PUSH
70946: LD_INT 1
70948: PUSH
70949: LD_INT 1
70951: NEG
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: PUSH
70957: LD_INT 1
70959: NEG
70960: PUSH
70961: LD_INT 1
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PUSH
70968: EMPTY
70969: LIST
70970: LIST
70971: LIST
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70979: LD_ADDR_VAR 0 38
70983: PUSH
70984: LD_INT 0
70986: PUSH
70987: LD_INT 0
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 0
70996: PUSH
70997: LD_INT 1
70999: NEG
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 1
71007: PUSH
71008: LD_INT 0
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: PUSH
71015: LD_INT 1
71017: PUSH
71018: LD_INT 1
71020: PUSH
71021: EMPTY
71022: LIST
71023: LIST
71024: PUSH
71025: LD_INT 0
71027: PUSH
71028: LD_INT 1
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: PUSH
71035: LD_INT 1
71037: NEG
71038: PUSH
71039: LD_INT 0
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: PUSH
71046: LD_INT 1
71048: NEG
71049: PUSH
71050: LD_INT 1
71052: NEG
71053: PUSH
71054: EMPTY
71055: LIST
71056: LIST
71057: PUSH
71058: LD_INT 2
71060: PUSH
71061: LD_INT 1
71063: PUSH
71064: EMPTY
71065: LIST
71066: LIST
71067: PUSH
71068: LD_INT 2
71070: NEG
71071: PUSH
71072: LD_INT 1
71074: NEG
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: EMPTY
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71091: LD_ADDR_VAR 0 39
71095: PUSH
71096: LD_INT 0
71098: PUSH
71099: LD_INT 0
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 0
71108: PUSH
71109: LD_INT 1
71111: NEG
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: PUSH
71117: LD_INT 1
71119: PUSH
71120: LD_INT 0
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 1
71129: PUSH
71130: LD_INT 1
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: PUSH
71137: LD_INT 0
71139: PUSH
71140: LD_INT 1
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: LD_INT 1
71149: NEG
71150: PUSH
71151: LD_INT 0
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: PUSH
71158: LD_INT 1
71160: NEG
71161: PUSH
71162: LD_INT 1
71164: NEG
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 1
71172: NEG
71173: PUSH
71174: LD_INT 2
71176: NEG
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 1
71184: PUSH
71185: LD_INT 2
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: LIST
71196: LIST
71197: LIST
71198: LIST
71199: LIST
71200: LIST
71201: LIST
71202: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71203: LD_ADDR_VAR 0 40
71207: PUSH
71208: LD_INT 0
71210: PUSH
71211: LD_INT 0
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: PUSH
71218: LD_INT 0
71220: PUSH
71221: LD_INT 1
71223: NEG
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: PUSH
71229: LD_INT 1
71231: PUSH
71232: LD_INT 0
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 1
71241: PUSH
71242: LD_INT 1
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: LD_INT 0
71251: PUSH
71252: LD_INT 1
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 1
71261: NEG
71262: PUSH
71263: LD_INT 0
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 1
71272: NEG
71273: PUSH
71274: LD_INT 1
71276: NEG
71277: PUSH
71278: EMPTY
71279: LIST
71280: LIST
71281: PUSH
71282: LD_INT 1
71284: PUSH
71285: LD_INT 1
71287: NEG
71288: PUSH
71289: EMPTY
71290: LIST
71291: LIST
71292: PUSH
71293: LD_INT 1
71295: NEG
71296: PUSH
71297: LD_INT 1
71299: PUSH
71300: EMPTY
71301: LIST
71302: LIST
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71315: LD_ADDR_VAR 0 41
71319: PUSH
71320: LD_INT 0
71322: PUSH
71323: LD_INT 0
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PUSH
71330: LD_INT 0
71332: PUSH
71333: LD_INT 1
71335: NEG
71336: PUSH
71337: EMPTY
71338: LIST
71339: LIST
71340: PUSH
71341: LD_INT 1
71343: PUSH
71344: LD_INT 0
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: LD_INT 1
71353: PUSH
71354: LD_INT 1
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: PUSH
71361: LD_INT 0
71363: PUSH
71364: LD_INT 1
71366: PUSH
71367: EMPTY
71368: LIST
71369: LIST
71370: PUSH
71371: LD_INT 1
71373: NEG
71374: PUSH
71375: LD_INT 0
71377: PUSH
71378: EMPTY
71379: LIST
71380: LIST
71381: PUSH
71382: LD_INT 1
71384: NEG
71385: PUSH
71386: LD_INT 1
71388: NEG
71389: PUSH
71390: EMPTY
71391: LIST
71392: LIST
71393: PUSH
71394: LD_INT 1
71396: NEG
71397: PUSH
71398: LD_INT 2
71400: NEG
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: PUSH
71406: LD_INT 1
71408: PUSH
71409: LD_INT 1
71411: NEG
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: LD_INT 2
71419: PUSH
71420: LD_INT 0
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 2
71429: PUSH
71430: LD_INT 1
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: PUSH
71437: LD_INT 2
71439: PUSH
71440: LD_INT 2
71442: PUSH
71443: EMPTY
71444: LIST
71445: LIST
71446: PUSH
71447: LD_INT 1
71449: PUSH
71450: LD_INT 2
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: LD_INT 1
71459: NEG
71460: PUSH
71461: LD_INT 1
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PUSH
71468: LD_INT 2
71470: NEG
71471: PUSH
71472: LD_INT 0
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: LD_INT 2
71481: NEG
71482: PUSH
71483: LD_INT 1
71485: NEG
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 2
71493: NEG
71494: PUSH
71495: LD_INT 2
71497: NEG
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 2
71505: NEG
71506: PUSH
71507: LD_INT 3
71509: NEG
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: PUSH
71515: LD_INT 2
71517: PUSH
71518: LD_INT 1
71520: NEG
71521: PUSH
71522: EMPTY
71523: LIST
71524: LIST
71525: PUSH
71526: LD_INT 3
71528: PUSH
71529: LD_INT 0
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PUSH
71536: LD_INT 3
71538: PUSH
71539: LD_INT 1
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: LD_INT 3
71548: PUSH
71549: LD_INT 2
71551: PUSH
71552: EMPTY
71553: LIST
71554: LIST
71555: PUSH
71556: LD_INT 3
71558: PUSH
71559: LD_INT 3
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 2
71568: PUSH
71569: LD_INT 3
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PUSH
71576: LD_INT 2
71578: NEG
71579: PUSH
71580: LD_INT 1
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 3
71589: NEG
71590: PUSH
71591: LD_INT 0
71593: PUSH
71594: EMPTY
71595: LIST
71596: LIST
71597: PUSH
71598: LD_INT 3
71600: NEG
71601: PUSH
71602: LD_INT 1
71604: NEG
71605: PUSH
71606: EMPTY
71607: LIST
71608: LIST
71609: PUSH
71610: LD_INT 3
71612: NEG
71613: PUSH
71614: LD_INT 2
71616: NEG
71617: PUSH
71618: EMPTY
71619: LIST
71620: LIST
71621: PUSH
71622: LD_INT 3
71624: NEG
71625: PUSH
71626: LD_INT 3
71628: NEG
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: LIST
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: LIST
71647: LIST
71648: LIST
71649: LIST
71650: LIST
71651: LIST
71652: LIST
71653: LIST
71654: LIST
71655: LIST
71656: LIST
71657: LIST
71658: LIST
71659: LIST
71660: LIST
71661: LIST
71662: LIST
71663: LIST
71664: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71665: LD_ADDR_VAR 0 42
71669: PUSH
71670: LD_INT 0
71672: PUSH
71673: LD_INT 0
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: LD_INT 0
71682: PUSH
71683: LD_INT 1
71685: NEG
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: PUSH
71691: LD_INT 1
71693: PUSH
71694: LD_INT 0
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: LD_INT 1
71703: PUSH
71704: LD_INT 1
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: LD_INT 0
71713: PUSH
71714: LD_INT 1
71716: PUSH
71717: EMPTY
71718: LIST
71719: LIST
71720: PUSH
71721: LD_INT 1
71723: NEG
71724: PUSH
71725: LD_INT 0
71727: PUSH
71728: EMPTY
71729: LIST
71730: LIST
71731: PUSH
71732: LD_INT 1
71734: NEG
71735: PUSH
71736: LD_INT 1
71738: NEG
71739: PUSH
71740: EMPTY
71741: LIST
71742: LIST
71743: PUSH
71744: LD_INT 1
71746: NEG
71747: PUSH
71748: LD_INT 2
71750: NEG
71751: PUSH
71752: EMPTY
71753: LIST
71754: LIST
71755: PUSH
71756: LD_INT 0
71758: PUSH
71759: LD_INT 2
71761: NEG
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: LD_INT 1
71769: PUSH
71770: LD_INT 1
71772: NEG
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 2
71780: PUSH
71781: LD_INT 1
71783: PUSH
71784: EMPTY
71785: LIST
71786: LIST
71787: PUSH
71788: LD_INT 2
71790: PUSH
71791: LD_INT 2
71793: PUSH
71794: EMPTY
71795: LIST
71796: LIST
71797: PUSH
71798: LD_INT 1
71800: PUSH
71801: LD_INT 2
71803: PUSH
71804: EMPTY
71805: LIST
71806: LIST
71807: PUSH
71808: LD_INT 0
71810: PUSH
71811: LD_INT 2
71813: PUSH
71814: EMPTY
71815: LIST
71816: LIST
71817: PUSH
71818: LD_INT 1
71820: NEG
71821: PUSH
71822: LD_INT 1
71824: PUSH
71825: EMPTY
71826: LIST
71827: LIST
71828: PUSH
71829: LD_INT 2
71831: NEG
71832: PUSH
71833: LD_INT 1
71835: NEG
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: PUSH
71841: LD_INT 2
71843: NEG
71844: PUSH
71845: LD_INT 2
71847: NEG
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 2
71855: NEG
71856: PUSH
71857: LD_INT 3
71859: NEG
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PUSH
71865: LD_INT 1
71867: NEG
71868: PUSH
71869: LD_INT 3
71871: NEG
71872: PUSH
71873: EMPTY
71874: LIST
71875: LIST
71876: PUSH
71877: LD_INT 0
71879: PUSH
71880: LD_INT 3
71882: NEG
71883: PUSH
71884: EMPTY
71885: LIST
71886: LIST
71887: PUSH
71888: LD_INT 1
71890: PUSH
71891: LD_INT 2
71893: NEG
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: PUSH
71899: LD_INT 3
71901: PUSH
71902: LD_INT 2
71904: PUSH
71905: EMPTY
71906: LIST
71907: LIST
71908: PUSH
71909: LD_INT 3
71911: PUSH
71912: LD_INT 3
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PUSH
71919: LD_INT 2
71921: PUSH
71922: LD_INT 3
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PUSH
71929: LD_INT 1
71931: PUSH
71932: LD_INT 3
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: PUSH
71939: LD_INT 0
71941: PUSH
71942: LD_INT 3
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 1
71951: NEG
71952: PUSH
71953: LD_INT 2
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PUSH
71960: LD_INT 3
71962: NEG
71963: PUSH
71964: LD_INT 2
71966: NEG
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PUSH
71972: LD_INT 3
71974: NEG
71975: PUSH
71976: LD_INT 3
71978: NEG
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: LIST
71988: LIST
71989: LIST
71990: LIST
71991: LIST
71992: LIST
71993: LIST
71994: LIST
71995: LIST
71996: LIST
71997: LIST
71998: LIST
71999: LIST
72000: LIST
72001: LIST
72002: LIST
72003: LIST
72004: LIST
72005: LIST
72006: LIST
72007: LIST
72008: LIST
72009: LIST
72010: LIST
72011: LIST
72012: LIST
72013: LIST
72014: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72015: LD_ADDR_VAR 0 43
72019: PUSH
72020: LD_INT 0
72022: PUSH
72023: LD_INT 0
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: PUSH
72030: LD_INT 0
72032: PUSH
72033: LD_INT 1
72035: NEG
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 1
72043: PUSH
72044: LD_INT 0
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 1
72053: PUSH
72054: LD_INT 1
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: LD_INT 0
72063: PUSH
72064: LD_INT 1
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 1
72073: NEG
72074: PUSH
72075: LD_INT 0
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: PUSH
72082: LD_INT 1
72084: NEG
72085: PUSH
72086: LD_INT 1
72088: NEG
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: PUSH
72094: LD_INT 1
72096: NEG
72097: PUSH
72098: LD_INT 2
72100: NEG
72101: PUSH
72102: EMPTY
72103: LIST
72104: LIST
72105: PUSH
72106: LD_INT 0
72108: PUSH
72109: LD_INT 2
72111: NEG
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: PUSH
72117: LD_INT 1
72119: PUSH
72120: LD_INT 1
72122: NEG
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 2
72130: PUSH
72131: LD_INT 0
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 2
72140: PUSH
72141: LD_INT 1
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 1
72150: PUSH
72151: LD_INT 2
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 0
72160: PUSH
72161: LD_INT 2
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: LD_INT 1
72170: NEG
72171: PUSH
72172: LD_INT 1
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: PUSH
72179: LD_INT 2
72181: NEG
72182: PUSH
72183: LD_INT 0
72185: PUSH
72186: EMPTY
72187: LIST
72188: LIST
72189: PUSH
72190: LD_INT 2
72192: NEG
72193: PUSH
72194: LD_INT 1
72196: NEG
72197: PUSH
72198: EMPTY
72199: LIST
72200: LIST
72201: PUSH
72202: LD_INT 1
72204: NEG
72205: PUSH
72206: LD_INT 3
72208: NEG
72209: PUSH
72210: EMPTY
72211: LIST
72212: LIST
72213: PUSH
72214: LD_INT 0
72216: PUSH
72217: LD_INT 3
72219: NEG
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 1
72227: PUSH
72228: LD_INT 2
72230: NEG
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 2
72238: PUSH
72239: LD_INT 1
72241: NEG
72242: PUSH
72243: EMPTY
72244: LIST
72245: LIST
72246: PUSH
72247: LD_INT 3
72249: PUSH
72250: LD_INT 0
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PUSH
72257: LD_INT 3
72259: PUSH
72260: LD_INT 1
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 1
72269: PUSH
72270: LD_INT 3
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: LD_INT 3
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 1
72289: NEG
72290: PUSH
72291: LD_INT 2
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 2
72300: NEG
72301: PUSH
72302: LD_INT 1
72304: PUSH
72305: EMPTY
72306: LIST
72307: LIST
72308: PUSH
72309: LD_INT 3
72311: NEG
72312: PUSH
72313: LD_INT 0
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: PUSH
72320: LD_INT 3
72322: NEG
72323: PUSH
72324: LD_INT 1
72326: NEG
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: LIST
72339: LIST
72340: LIST
72341: LIST
72342: LIST
72343: LIST
72344: LIST
72345: LIST
72346: LIST
72347: LIST
72348: LIST
72349: LIST
72350: LIST
72351: LIST
72352: LIST
72353: LIST
72354: LIST
72355: LIST
72356: LIST
72357: LIST
72358: LIST
72359: LIST
72360: LIST
72361: LIST
72362: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72363: LD_ADDR_VAR 0 44
72367: PUSH
72368: LD_INT 0
72370: PUSH
72371: LD_INT 0
72373: PUSH
72374: EMPTY
72375: LIST
72376: LIST
72377: PUSH
72378: LD_INT 0
72380: PUSH
72381: LD_INT 1
72383: NEG
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: LD_INT 1
72391: PUSH
72392: LD_INT 0
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 1
72401: PUSH
72402: LD_INT 1
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 0
72411: PUSH
72412: LD_INT 1
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: PUSH
72419: LD_INT 1
72421: NEG
72422: PUSH
72423: LD_INT 0
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 1
72432: NEG
72433: PUSH
72434: LD_INT 1
72436: NEG
72437: PUSH
72438: EMPTY
72439: LIST
72440: LIST
72441: PUSH
72442: LD_INT 1
72444: NEG
72445: PUSH
72446: LD_INT 2
72448: NEG
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: PUSH
72454: LD_INT 1
72456: PUSH
72457: LD_INT 1
72459: NEG
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 2
72467: PUSH
72468: LD_INT 0
72470: PUSH
72471: EMPTY
72472: LIST
72473: LIST
72474: PUSH
72475: LD_INT 2
72477: PUSH
72478: LD_INT 1
72480: PUSH
72481: EMPTY
72482: LIST
72483: LIST
72484: PUSH
72485: LD_INT 2
72487: PUSH
72488: LD_INT 2
72490: PUSH
72491: EMPTY
72492: LIST
72493: LIST
72494: PUSH
72495: LD_INT 1
72497: PUSH
72498: LD_INT 2
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 1
72507: NEG
72508: PUSH
72509: LD_INT 1
72511: PUSH
72512: EMPTY
72513: LIST
72514: LIST
72515: PUSH
72516: LD_INT 2
72518: NEG
72519: PUSH
72520: LD_INT 0
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: PUSH
72527: LD_INT 2
72529: NEG
72530: PUSH
72531: LD_INT 1
72533: NEG
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: LD_INT 2
72541: NEG
72542: PUSH
72543: LD_INT 2
72545: NEG
72546: PUSH
72547: EMPTY
72548: LIST
72549: LIST
72550: PUSH
72551: LD_INT 2
72553: NEG
72554: PUSH
72555: LD_INT 3
72557: NEG
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 2
72565: PUSH
72566: LD_INT 1
72568: NEG
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: LD_INT 3
72576: PUSH
72577: LD_INT 0
72579: PUSH
72580: EMPTY
72581: LIST
72582: LIST
72583: PUSH
72584: LD_INT 3
72586: PUSH
72587: LD_INT 1
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: PUSH
72594: LD_INT 3
72596: PUSH
72597: LD_INT 2
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: PUSH
72604: LD_INT 3
72606: PUSH
72607: LD_INT 3
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: PUSH
72614: LD_INT 2
72616: PUSH
72617: LD_INT 3
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 2
72626: NEG
72627: PUSH
72628: LD_INT 1
72630: PUSH
72631: EMPTY
72632: LIST
72633: LIST
72634: PUSH
72635: LD_INT 3
72637: NEG
72638: PUSH
72639: LD_INT 0
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: PUSH
72646: LD_INT 3
72648: NEG
72649: PUSH
72650: LD_INT 1
72652: NEG
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: LD_INT 3
72660: NEG
72661: PUSH
72662: LD_INT 2
72664: NEG
72665: PUSH
72666: EMPTY
72667: LIST
72668: LIST
72669: PUSH
72670: LD_INT 3
72672: NEG
72673: PUSH
72674: LD_INT 3
72676: NEG
72677: PUSH
72678: EMPTY
72679: LIST
72680: LIST
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: LIST
72686: LIST
72687: LIST
72688: LIST
72689: LIST
72690: LIST
72691: LIST
72692: LIST
72693: LIST
72694: LIST
72695: LIST
72696: LIST
72697: LIST
72698: LIST
72699: LIST
72700: LIST
72701: LIST
72702: LIST
72703: LIST
72704: LIST
72705: LIST
72706: LIST
72707: LIST
72708: LIST
72709: LIST
72710: LIST
72711: LIST
72712: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72713: LD_ADDR_VAR 0 45
72717: PUSH
72718: LD_INT 0
72720: PUSH
72721: LD_INT 0
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: PUSH
72728: LD_INT 0
72730: PUSH
72731: LD_INT 1
72733: NEG
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 1
72741: PUSH
72742: LD_INT 0
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 1
72751: PUSH
72752: LD_INT 1
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: LD_INT 0
72761: PUSH
72762: LD_INT 1
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: PUSH
72769: LD_INT 1
72771: NEG
72772: PUSH
72773: LD_INT 0
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: PUSH
72780: LD_INT 1
72782: NEG
72783: PUSH
72784: LD_INT 1
72786: NEG
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: PUSH
72792: LD_INT 1
72794: NEG
72795: PUSH
72796: LD_INT 2
72798: NEG
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: LD_INT 0
72806: PUSH
72807: LD_INT 2
72809: NEG
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 1
72817: PUSH
72818: LD_INT 1
72820: NEG
72821: PUSH
72822: EMPTY
72823: LIST
72824: LIST
72825: PUSH
72826: LD_INT 2
72828: PUSH
72829: LD_INT 1
72831: PUSH
72832: EMPTY
72833: LIST
72834: LIST
72835: PUSH
72836: LD_INT 2
72838: PUSH
72839: LD_INT 2
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: PUSH
72846: LD_INT 1
72848: PUSH
72849: LD_INT 2
72851: PUSH
72852: EMPTY
72853: LIST
72854: LIST
72855: PUSH
72856: LD_INT 0
72858: PUSH
72859: LD_INT 2
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 1
72868: NEG
72869: PUSH
72870: LD_INT 1
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: LD_INT 2
72879: NEG
72880: PUSH
72881: LD_INT 1
72883: NEG
72884: PUSH
72885: EMPTY
72886: LIST
72887: LIST
72888: PUSH
72889: LD_INT 2
72891: NEG
72892: PUSH
72893: LD_INT 2
72895: NEG
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PUSH
72901: LD_INT 2
72903: NEG
72904: PUSH
72905: LD_INT 3
72907: NEG
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: LD_INT 1
72915: NEG
72916: PUSH
72917: LD_INT 3
72919: NEG
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: LD_INT 0
72927: PUSH
72928: LD_INT 3
72930: NEG
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 1
72938: PUSH
72939: LD_INT 2
72941: NEG
72942: PUSH
72943: EMPTY
72944: LIST
72945: LIST
72946: PUSH
72947: LD_INT 3
72949: PUSH
72950: LD_INT 2
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 3
72959: PUSH
72960: LD_INT 3
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 2
72969: PUSH
72970: LD_INT 3
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: PUSH
72977: LD_INT 1
72979: PUSH
72980: LD_INT 3
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: PUSH
72987: LD_INT 0
72989: PUSH
72990: LD_INT 3
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: LD_INT 1
72999: NEG
73000: PUSH
73001: LD_INT 2
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: PUSH
73008: LD_INT 3
73010: NEG
73011: PUSH
73012: LD_INT 2
73014: NEG
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: PUSH
73020: LD_INT 3
73022: NEG
73023: PUSH
73024: LD_INT 3
73026: NEG
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: LIST
73036: LIST
73037: LIST
73038: LIST
73039: LIST
73040: LIST
73041: LIST
73042: LIST
73043: LIST
73044: LIST
73045: LIST
73046: LIST
73047: LIST
73048: LIST
73049: LIST
73050: LIST
73051: LIST
73052: LIST
73053: LIST
73054: LIST
73055: LIST
73056: LIST
73057: LIST
73058: LIST
73059: LIST
73060: LIST
73061: LIST
73062: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73063: LD_ADDR_VAR 0 46
73067: PUSH
73068: LD_INT 0
73070: PUSH
73071: LD_INT 0
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 0
73080: PUSH
73081: LD_INT 1
73083: NEG
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: PUSH
73089: LD_INT 1
73091: PUSH
73092: LD_INT 0
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PUSH
73099: LD_INT 1
73101: PUSH
73102: LD_INT 1
73104: PUSH
73105: EMPTY
73106: LIST
73107: LIST
73108: PUSH
73109: LD_INT 0
73111: PUSH
73112: LD_INT 1
73114: PUSH
73115: EMPTY
73116: LIST
73117: LIST
73118: PUSH
73119: LD_INT 1
73121: NEG
73122: PUSH
73123: LD_INT 0
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: PUSH
73130: LD_INT 1
73132: NEG
73133: PUSH
73134: LD_INT 1
73136: NEG
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: LD_INT 1
73144: NEG
73145: PUSH
73146: LD_INT 2
73148: NEG
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: LD_INT 0
73156: PUSH
73157: LD_INT 2
73159: NEG
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 1
73167: PUSH
73168: LD_INT 1
73170: NEG
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: LD_INT 2
73178: PUSH
73179: LD_INT 0
73181: PUSH
73182: EMPTY
73183: LIST
73184: LIST
73185: PUSH
73186: LD_INT 2
73188: PUSH
73189: LD_INT 1
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: LD_INT 1
73198: PUSH
73199: LD_INT 2
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: PUSH
73206: LD_INT 0
73208: PUSH
73209: LD_INT 2
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: PUSH
73216: LD_INT 1
73218: NEG
73219: PUSH
73220: LD_INT 1
73222: PUSH
73223: EMPTY
73224: LIST
73225: LIST
73226: PUSH
73227: LD_INT 2
73229: NEG
73230: PUSH
73231: LD_INT 0
73233: PUSH
73234: EMPTY
73235: LIST
73236: LIST
73237: PUSH
73238: LD_INT 2
73240: NEG
73241: PUSH
73242: LD_INT 1
73244: NEG
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: PUSH
73250: LD_INT 1
73252: NEG
73253: PUSH
73254: LD_INT 3
73256: NEG
73257: PUSH
73258: EMPTY
73259: LIST
73260: LIST
73261: PUSH
73262: LD_INT 0
73264: PUSH
73265: LD_INT 3
73267: NEG
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: PUSH
73273: LD_INT 1
73275: PUSH
73276: LD_INT 2
73278: NEG
73279: PUSH
73280: EMPTY
73281: LIST
73282: LIST
73283: PUSH
73284: LD_INT 2
73286: PUSH
73287: LD_INT 1
73289: NEG
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: PUSH
73295: LD_INT 3
73297: PUSH
73298: LD_INT 0
73300: PUSH
73301: EMPTY
73302: LIST
73303: LIST
73304: PUSH
73305: LD_INT 3
73307: PUSH
73308: LD_INT 1
73310: PUSH
73311: EMPTY
73312: LIST
73313: LIST
73314: PUSH
73315: LD_INT 1
73317: PUSH
73318: LD_INT 3
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: PUSH
73325: LD_INT 0
73327: PUSH
73328: LD_INT 3
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 1
73337: NEG
73338: PUSH
73339: LD_INT 2
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 2
73348: NEG
73349: PUSH
73350: LD_INT 1
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: PUSH
73357: LD_INT 3
73359: NEG
73360: PUSH
73361: LD_INT 0
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: PUSH
73368: LD_INT 3
73370: NEG
73371: PUSH
73372: LD_INT 1
73374: NEG
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: PUSH
73380: EMPTY
73381: LIST
73382: LIST
73383: LIST
73384: LIST
73385: LIST
73386: LIST
73387: LIST
73388: LIST
73389: LIST
73390: LIST
73391: LIST
73392: LIST
73393: LIST
73394: LIST
73395: LIST
73396: LIST
73397: LIST
73398: LIST
73399: LIST
73400: LIST
73401: LIST
73402: LIST
73403: LIST
73404: LIST
73405: LIST
73406: LIST
73407: LIST
73408: LIST
73409: LIST
73410: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73411: LD_ADDR_VAR 0 47
73415: PUSH
73416: LD_INT 0
73418: PUSH
73419: LD_INT 0
73421: PUSH
73422: EMPTY
73423: LIST
73424: LIST
73425: PUSH
73426: LD_INT 0
73428: PUSH
73429: LD_INT 1
73431: NEG
73432: PUSH
73433: EMPTY
73434: LIST
73435: LIST
73436: PUSH
73437: LD_INT 1
73439: PUSH
73440: LD_INT 0
73442: PUSH
73443: EMPTY
73444: LIST
73445: LIST
73446: PUSH
73447: LD_INT 1
73449: PUSH
73450: LD_INT 1
73452: PUSH
73453: EMPTY
73454: LIST
73455: LIST
73456: PUSH
73457: LD_INT 0
73459: PUSH
73460: LD_INT 1
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: PUSH
73467: LD_INT 1
73469: NEG
73470: PUSH
73471: LD_INT 0
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: LD_INT 1
73480: NEG
73481: PUSH
73482: LD_INT 1
73484: NEG
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: PUSH
73490: LD_INT 1
73492: NEG
73493: PUSH
73494: LD_INT 2
73496: NEG
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PUSH
73502: LD_INT 0
73504: PUSH
73505: LD_INT 2
73507: NEG
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: LD_INT 1
73515: PUSH
73516: LD_INT 1
73518: NEG
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 2
73526: NEG
73527: PUSH
73528: LD_INT 1
73530: NEG
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: LD_INT 2
73538: NEG
73539: PUSH
73540: LD_INT 2
73542: NEG
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: LIST
73552: LIST
73553: LIST
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73562: LD_ADDR_VAR 0 48
73566: PUSH
73567: LD_INT 0
73569: PUSH
73570: LD_INT 0
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 0
73579: PUSH
73580: LD_INT 1
73582: NEG
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: LD_INT 1
73590: PUSH
73591: LD_INT 0
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: PUSH
73598: LD_INT 1
73600: PUSH
73601: LD_INT 1
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 0
73610: PUSH
73611: LD_INT 1
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: LD_INT 1
73620: NEG
73621: PUSH
73622: LD_INT 0
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 1
73631: NEG
73632: PUSH
73633: LD_INT 1
73635: NEG
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 1
73643: NEG
73644: PUSH
73645: LD_INT 2
73647: NEG
73648: PUSH
73649: EMPTY
73650: LIST
73651: LIST
73652: PUSH
73653: LD_INT 0
73655: PUSH
73656: LD_INT 2
73658: NEG
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: PUSH
73664: LD_INT 1
73666: PUSH
73667: LD_INT 1
73669: NEG
73670: PUSH
73671: EMPTY
73672: LIST
73673: LIST
73674: PUSH
73675: LD_INT 2
73677: PUSH
73678: LD_INT 0
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: PUSH
73685: LD_INT 2
73687: PUSH
73688: LD_INT 1
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: EMPTY
73696: LIST
73697: LIST
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: LIST
73703: LIST
73704: LIST
73705: LIST
73706: LIST
73707: LIST
73708: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73709: LD_ADDR_VAR 0 49
73713: PUSH
73714: LD_INT 0
73716: PUSH
73717: LD_INT 0
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: PUSH
73724: LD_INT 0
73726: PUSH
73727: LD_INT 1
73729: NEG
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 1
73737: PUSH
73738: LD_INT 0
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: LD_INT 1
73747: PUSH
73748: LD_INT 1
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: LD_INT 0
73757: PUSH
73758: LD_INT 1
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: LD_INT 1
73767: NEG
73768: PUSH
73769: LD_INT 0
73771: PUSH
73772: EMPTY
73773: LIST
73774: LIST
73775: PUSH
73776: LD_INT 1
73778: NEG
73779: PUSH
73780: LD_INT 1
73782: NEG
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 1
73790: PUSH
73791: LD_INT 1
73793: NEG
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 2
73801: PUSH
73802: LD_INT 0
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 2
73811: PUSH
73812: LD_INT 1
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: PUSH
73819: LD_INT 2
73821: PUSH
73822: LD_INT 2
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 1
73831: PUSH
73832: LD_INT 2
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: LIST
73846: LIST
73847: LIST
73848: LIST
73849: LIST
73850: LIST
73851: LIST
73852: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73853: LD_ADDR_VAR 0 50
73857: PUSH
73858: LD_INT 0
73860: PUSH
73861: LD_INT 0
73863: PUSH
73864: EMPTY
73865: LIST
73866: LIST
73867: PUSH
73868: LD_INT 0
73870: PUSH
73871: LD_INT 1
73873: NEG
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: PUSH
73879: LD_INT 1
73881: PUSH
73882: LD_INT 0
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: LD_INT 1
73891: PUSH
73892: LD_INT 1
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 0
73901: PUSH
73902: LD_INT 1
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: LD_INT 1
73911: NEG
73912: PUSH
73913: LD_INT 0
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: PUSH
73920: LD_INT 1
73922: NEG
73923: PUSH
73924: LD_INT 1
73926: NEG
73927: PUSH
73928: EMPTY
73929: LIST
73930: LIST
73931: PUSH
73932: LD_INT 2
73934: PUSH
73935: LD_INT 1
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: LD_INT 2
73944: PUSH
73945: LD_INT 2
73947: PUSH
73948: EMPTY
73949: LIST
73950: LIST
73951: PUSH
73952: LD_INT 1
73954: PUSH
73955: LD_INT 2
73957: PUSH
73958: EMPTY
73959: LIST
73960: LIST
73961: PUSH
73962: LD_INT 0
73964: PUSH
73965: LD_INT 2
73967: PUSH
73968: EMPTY
73969: LIST
73970: LIST
73971: PUSH
73972: LD_INT 1
73974: NEG
73975: PUSH
73976: LD_INT 1
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: LIST
73987: LIST
73988: LIST
73989: LIST
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: LIST
73996: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73997: LD_ADDR_VAR 0 51
74001: PUSH
74002: LD_INT 0
74004: PUSH
74005: LD_INT 0
74007: PUSH
74008: EMPTY
74009: LIST
74010: LIST
74011: PUSH
74012: LD_INT 0
74014: PUSH
74015: LD_INT 1
74017: NEG
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 1
74025: PUSH
74026: LD_INT 0
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: PUSH
74033: LD_INT 1
74035: PUSH
74036: LD_INT 1
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PUSH
74043: LD_INT 0
74045: PUSH
74046: LD_INT 1
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 1
74055: NEG
74056: PUSH
74057: LD_INT 0
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 1
74066: NEG
74067: PUSH
74068: LD_INT 1
74070: NEG
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 1
74078: PUSH
74079: LD_INT 2
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: PUSH
74086: LD_INT 0
74088: PUSH
74089: LD_INT 2
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 1
74098: NEG
74099: PUSH
74100: LD_INT 1
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 2
74109: NEG
74110: PUSH
74111: LD_INT 0
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: PUSH
74118: LD_INT 2
74120: NEG
74121: PUSH
74122: LD_INT 1
74124: NEG
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: LIST
74134: LIST
74135: LIST
74136: LIST
74137: LIST
74138: LIST
74139: LIST
74140: LIST
74141: LIST
74142: LIST
74143: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74144: LD_ADDR_VAR 0 52
74148: PUSH
74149: LD_INT 0
74151: PUSH
74152: LD_INT 0
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PUSH
74159: LD_INT 0
74161: PUSH
74162: LD_INT 1
74164: NEG
74165: PUSH
74166: EMPTY
74167: LIST
74168: LIST
74169: PUSH
74170: LD_INT 1
74172: PUSH
74173: LD_INT 0
74175: PUSH
74176: EMPTY
74177: LIST
74178: LIST
74179: PUSH
74180: LD_INT 1
74182: PUSH
74183: LD_INT 1
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PUSH
74190: LD_INT 0
74192: PUSH
74193: LD_INT 1
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: PUSH
74200: LD_INT 1
74202: NEG
74203: PUSH
74204: LD_INT 0
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: LD_INT 1
74213: NEG
74214: PUSH
74215: LD_INT 1
74217: NEG
74218: PUSH
74219: EMPTY
74220: LIST
74221: LIST
74222: PUSH
74223: LD_INT 1
74225: NEG
74226: PUSH
74227: LD_INT 2
74229: NEG
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: PUSH
74235: LD_INT 1
74237: NEG
74238: PUSH
74239: LD_INT 1
74241: PUSH
74242: EMPTY
74243: LIST
74244: LIST
74245: PUSH
74246: LD_INT 2
74248: NEG
74249: PUSH
74250: LD_INT 0
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: PUSH
74257: LD_INT 2
74259: NEG
74260: PUSH
74261: LD_INT 1
74263: NEG
74264: PUSH
74265: EMPTY
74266: LIST
74267: LIST
74268: PUSH
74269: LD_INT 2
74271: NEG
74272: PUSH
74273: LD_INT 2
74275: NEG
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: PUSH
74281: EMPTY
74282: LIST
74283: LIST
74284: LIST
74285: LIST
74286: LIST
74287: LIST
74288: LIST
74289: LIST
74290: LIST
74291: LIST
74292: LIST
74293: LIST
74294: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74295: LD_ADDR_VAR 0 53
74299: PUSH
74300: LD_INT 0
74302: PUSH
74303: LD_INT 0
74305: PUSH
74306: EMPTY
74307: LIST
74308: LIST
74309: PUSH
74310: LD_INT 0
74312: PUSH
74313: LD_INT 1
74315: NEG
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 1
74323: PUSH
74324: LD_INT 0
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 1
74333: PUSH
74334: LD_INT 1
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 0
74343: PUSH
74344: LD_INT 1
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: PUSH
74351: LD_INT 1
74353: NEG
74354: PUSH
74355: LD_INT 0
74357: PUSH
74358: EMPTY
74359: LIST
74360: LIST
74361: PUSH
74362: LD_INT 1
74364: NEG
74365: PUSH
74366: LD_INT 1
74368: NEG
74369: PUSH
74370: EMPTY
74371: LIST
74372: LIST
74373: PUSH
74374: LD_INT 1
74376: NEG
74377: PUSH
74378: LD_INT 2
74380: NEG
74381: PUSH
74382: EMPTY
74383: LIST
74384: LIST
74385: PUSH
74386: LD_INT 0
74388: PUSH
74389: LD_INT 2
74391: NEG
74392: PUSH
74393: EMPTY
74394: LIST
74395: LIST
74396: PUSH
74397: LD_INT 1
74399: PUSH
74400: LD_INT 1
74402: NEG
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: LD_INT 2
74410: PUSH
74411: LD_INT 0
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PUSH
74418: LD_INT 2
74420: PUSH
74421: LD_INT 1
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: PUSH
74428: LD_INT 2
74430: PUSH
74431: LD_INT 2
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 1
74440: PUSH
74441: LD_INT 2
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PUSH
74448: LD_INT 0
74450: PUSH
74451: LD_INT 2
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: PUSH
74458: LD_INT 1
74460: NEG
74461: PUSH
74462: LD_INT 1
74464: PUSH
74465: EMPTY
74466: LIST
74467: LIST
74468: PUSH
74469: LD_INT 2
74471: NEG
74472: PUSH
74473: LD_INT 0
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: PUSH
74480: LD_INT 2
74482: NEG
74483: PUSH
74484: LD_INT 1
74486: NEG
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 2
74494: NEG
74495: PUSH
74496: LD_INT 2
74498: NEG
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: PUSH
74504: EMPTY
74505: LIST
74506: LIST
74507: LIST
74508: LIST
74509: LIST
74510: LIST
74511: LIST
74512: LIST
74513: LIST
74514: LIST
74515: LIST
74516: LIST
74517: LIST
74518: LIST
74519: LIST
74520: LIST
74521: LIST
74522: LIST
74523: LIST
74524: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74525: LD_ADDR_VAR 0 54
74529: PUSH
74530: LD_INT 0
74532: PUSH
74533: LD_INT 0
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 0
74542: PUSH
74543: LD_INT 1
74545: NEG
74546: PUSH
74547: EMPTY
74548: LIST
74549: LIST
74550: PUSH
74551: LD_INT 1
74553: PUSH
74554: LD_INT 0
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: LD_INT 1
74563: PUSH
74564: LD_INT 1
74566: PUSH
74567: EMPTY
74568: LIST
74569: LIST
74570: PUSH
74571: LD_INT 0
74573: PUSH
74574: LD_INT 1
74576: PUSH
74577: EMPTY
74578: LIST
74579: LIST
74580: PUSH
74581: LD_INT 1
74583: NEG
74584: PUSH
74585: LD_INT 0
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: PUSH
74592: LD_INT 1
74594: NEG
74595: PUSH
74596: LD_INT 1
74598: NEG
74599: PUSH
74600: EMPTY
74601: LIST
74602: LIST
74603: PUSH
74604: LD_INT 1
74606: NEG
74607: PUSH
74608: LD_INT 2
74610: NEG
74611: PUSH
74612: EMPTY
74613: LIST
74614: LIST
74615: PUSH
74616: LD_INT 0
74618: PUSH
74619: LD_INT 2
74621: NEG
74622: PUSH
74623: EMPTY
74624: LIST
74625: LIST
74626: PUSH
74627: LD_INT 1
74629: PUSH
74630: LD_INT 1
74632: NEG
74633: PUSH
74634: EMPTY
74635: LIST
74636: LIST
74637: PUSH
74638: LD_INT 2
74640: PUSH
74641: LD_INT 0
74643: PUSH
74644: EMPTY
74645: LIST
74646: LIST
74647: PUSH
74648: LD_INT 2
74650: PUSH
74651: LD_INT 1
74653: PUSH
74654: EMPTY
74655: LIST
74656: LIST
74657: PUSH
74658: LD_INT 2
74660: PUSH
74661: LD_INT 2
74663: PUSH
74664: EMPTY
74665: LIST
74666: LIST
74667: PUSH
74668: LD_INT 1
74670: PUSH
74671: LD_INT 2
74673: PUSH
74674: EMPTY
74675: LIST
74676: LIST
74677: PUSH
74678: LD_INT 0
74680: PUSH
74681: LD_INT 2
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PUSH
74688: LD_INT 1
74690: NEG
74691: PUSH
74692: LD_INT 1
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 2
74701: NEG
74702: PUSH
74703: LD_INT 0
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 2
74712: NEG
74713: PUSH
74714: LD_INT 1
74716: NEG
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: LD_INT 2
74724: NEG
74725: PUSH
74726: LD_INT 2
74728: NEG
74729: PUSH
74730: EMPTY
74731: LIST
74732: LIST
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: LIST
74738: LIST
74739: LIST
74740: LIST
74741: LIST
74742: LIST
74743: LIST
74744: LIST
74745: LIST
74746: LIST
74747: LIST
74748: LIST
74749: LIST
74750: LIST
74751: LIST
74752: LIST
74753: LIST
74754: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74755: LD_ADDR_VAR 0 55
74759: PUSH
74760: LD_INT 0
74762: PUSH
74763: LD_INT 0
74765: PUSH
74766: EMPTY
74767: LIST
74768: LIST
74769: PUSH
74770: LD_INT 0
74772: PUSH
74773: LD_INT 1
74775: NEG
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: PUSH
74781: LD_INT 1
74783: PUSH
74784: LD_INT 0
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PUSH
74791: LD_INT 1
74793: PUSH
74794: LD_INT 1
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 0
74803: PUSH
74804: LD_INT 1
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 1
74813: NEG
74814: PUSH
74815: LD_INT 0
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: PUSH
74822: LD_INT 1
74824: NEG
74825: PUSH
74826: LD_INT 1
74828: NEG
74829: PUSH
74830: EMPTY
74831: LIST
74832: LIST
74833: PUSH
74834: LD_INT 1
74836: NEG
74837: PUSH
74838: LD_INT 2
74840: NEG
74841: PUSH
74842: EMPTY
74843: LIST
74844: LIST
74845: PUSH
74846: LD_INT 0
74848: PUSH
74849: LD_INT 2
74851: NEG
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: PUSH
74857: LD_INT 1
74859: PUSH
74860: LD_INT 1
74862: NEG
74863: PUSH
74864: EMPTY
74865: LIST
74866: LIST
74867: PUSH
74868: LD_INT 2
74870: PUSH
74871: LD_INT 0
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PUSH
74878: LD_INT 2
74880: PUSH
74881: LD_INT 1
74883: PUSH
74884: EMPTY
74885: LIST
74886: LIST
74887: PUSH
74888: LD_INT 2
74890: PUSH
74891: LD_INT 2
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: LD_INT 2
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: LD_INT 0
74910: PUSH
74911: LD_INT 2
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 1
74920: NEG
74921: PUSH
74922: LD_INT 1
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 2
74931: NEG
74932: PUSH
74933: LD_INT 0
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: LD_INT 2
74942: NEG
74943: PUSH
74944: LD_INT 1
74946: NEG
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PUSH
74952: LD_INT 2
74954: NEG
74955: PUSH
74956: LD_INT 2
74958: NEG
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: LIST
74968: LIST
74969: LIST
74970: LIST
74971: LIST
74972: LIST
74973: LIST
74974: LIST
74975: LIST
74976: LIST
74977: LIST
74978: LIST
74979: LIST
74980: LIST
74981: LIST
74982: LIST
74983: LIST
74984: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74985: LD_ADDR_VAR 0 56
74989: PUSH
74990: LD_INT 0
74992: PUSH
74993: LD_INT 0
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: LD_INT 0
75002: PUSH
75003: LD_INT 1
75005: NEG
75006: PUSH
75007: EMPTY
75008: LIST
75009: LIST
75010: PUSH
75011: LD_INT 1
75013: PUSH
75014: LD_INT 0
75016: PUSH
75017: EMPTY
75018: LIST
75019: LIST
75020: PUSH
75021: LD_INT 1
75023: PUSH
75024: LD_INT 1
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: PUSH
75031: LD_INT 0
75033: PUSH
75034: LD_INT 1
75036: PUSH
75037: EMPTY
75038: LIST
75039: LIST
75040: PUSH
75041: LD_INT 1
75043: NEG
75044: PUSH
75045: LD_INT 0
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PUSH
75052: LD_INT 1
75054: NEG
75055: PUSH
75056: LD_INT 1
75058: NEG
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PUSH
75064: LD_INT 1
75066: NEG
75067: PUSH
75068: LD_INT 2
75070: NEG
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: LD_INT 0
75078: PUSH
75079: LD_INT 2
75081: NEG
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: PUSH
75087: LD_INT 1
75089: PUSH
75090: LD_INT 1
75092: NEG
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PUSH
75098: LD_INT 2
75100: PUSH
75101: LD_INT 0
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: LD_INT 2
75110: PUSH
75111: LD_INT 1
75113: PUSH
75114: EMPTY
75115: LIST
75116: LIST
75117: PUSH
75118: LD_INT 2
75120: PUSH
75121: LD_INT 2
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 1
75130: PUSH
75131: LD_INT 2
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 0
75140: PUSH
75141: LD_INT 2
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 1
75150: NEG
75151: PUSH
75152: LD_INT 1
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 2
75161: NEG
75162: PUSH
75163: LD_INT 0
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 2
75172: NEG
75173: PUSH
75174: LD_INT 1
75176: NEG
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 2
75184: NEG
75185: PUSH
75186: LD_INT 2
75188: NEG
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: EMPTY
75195: LIST
75196: LIST
75197: LIST
75198: LIST
75199: LIST
75200: LIST
75201: LIST
75202: LIST
75203: LIST
75204: LIST
75205: LIST
75206: LIST
75207: LIST
75208: LIST
75209: LIST
75210: LIST
75211: LIST
75212: LIST
75213: LIST
75214: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75215: LD_ADDR_VAR 0 57
75219: PUSH
75220: LD_INT 0
75222: PUSH
75223: LD_INT 0
75225: PUSH
75226: EMPTY
75227: LIST
75228: LIST
75229: PUSH
75230: LD_INT 0
75232: PUSH
75233: LD_INT 1
75235: NEG
75236: PUSH
75237: EMPTY
75238: LIST
75239: LIST
75240: PUSH
75241: LD_INT 1
75243: PUSH
75244: LD_INT 0
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: PUSH
75251: LD_INT 1
75253: PUSH
75254: LD_INT 1
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: LD_INT 0
75263: PUSH
75264: LD_INT 1
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: PUSH
75271: LD_INT 1
75273: NEG
75274: PUSH
75275: LD_INT 0
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: PUSH
75282: LD_INT 1
75284: NEG
75285: PUSH
75286: LD_INT 1
75288: NEG
75289: PUSH
75290: EMPTY
75291: LIST
75292: LIST
75293: PUSH
75294: LD_INT 1
75296: NEG
75297: PUSH
75298: LD_INT 2
75300: NEG
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 0
75308: PUSH
75309: LD_INT 2
75311: NEG
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: PUSH
75317: LD_INT 1
75319: PUSH
75320: LD_INT 1
75322: NEG
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PUSH
75328: LD_INT 2
75330: PUSH
75331: LD_INT 0
75333: PUSH
75334: EMPTY
75335: LIST
75336: LIST
75337: PUSH
75338: LD_INT 2
75340: PUSH
75341: LD_INT 1
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PUSH
75348: LD_INT 2
75350: PUSH
75351: LD_INT 2
75353: PUSH
75354: EMPTY
75355: LIST
75356: LIST
75357: PUSH
75358: LD_INT 1
75360: PUSH
75361: LD_INT 2
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: PUSH
75368: LD_INT 0
75370: PUSH
75371: LD_INT 2
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 1
75380: NEG
75381: PUSH
75382: LD_INT 1
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: LD_INT 2
75391: NEG
75392: PUSH
75393: LD_INT 0
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 2
75402: NEG
75403: PUSH
75404: LD_INT 1
75406: NEG
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: LD_INT 2
75414: NEG
75415: PUSH
75416: LD_INT 2
75418: NEG
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: LIST
75428: LIST
75429: LIST
75430: LIST
75431: LIST
75432: LIST
75433: LIST
75434: LIST
75435: LIST
75436: LIST
75437: LIST
75438: LIST
75439: LIST
75440: LIST
75441: LIST
75442: LIST
75443: LIST
75444: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75445: LD_ADDR_VAR 0 58
75449: PUSH
75450: LD_INT 0
75452: PUSH
75453: LD_INT 0
75455: PUSH
75456: EMPTY
75457: LIST
75458: LIST
75459: PUSH
75460: LD_INT 0
75462: PUSH
75463: LD_INT 1
75465: NEG
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 1
75473: PUSH
75474: LD_INT 0
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: LD_INT 1
75483: PUSH
75484: LD_INT 1
75486: PUSH
75487: EMPTY
75488: LIST
75489: LIST
75490: PUSH
75491: LD_INT 0
75493: PUSH
75494: LD_INT 1
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: PUSH
75501: LD_INT 1
75503: NEG
75504: PUSH
75505: LD_INT 0
75507: PUSH
75508: EMPTY
75509: LIST
75510: LIST
75511: PUSH
75512: LD_INT 1
75514: NEG
75515: PUSH
75516: LD_INT 1
75518: NEG
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 1
75526: NEG
75527: PUSH
75528: LD_INT 2
75530: NEG
75531: PUSH
75532: EMPTY
75533: LIST
75534: LIST
75535: PUSH
75536: LD_INT 0
75538: PUSH
75539: LD_INT 2
75541: NEG
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: PUSH
75547: LD_INT 1
75549: PUSH
75550: LD_INT 1
75552: NEG
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: LD_INT 2
75560: PUSH
75561: LD_INT 0
75563: PUSH
75564: EMPTY
75565: LIST
75566: LIST
75567: PUSH
75568: LD_INT 2
75570: PUSH
75571: LD_INT 1
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: PUSH
75578: LD_INT 2
75580: PUSH
75581: LD_INT 2
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: LD_INT 1
75590: PUSH
75591: LD_INT 2
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: LD_INT 0
75600: PUSH
75601: LD_INT 2
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 1
75610: NEG
75611: PUSH
75612: LD_INT 1
75614: PUSH
75615: EMPTY
75616: LIST
75617: LIST
75618: PUSH
75619: LD_INT 2
75621: NEG
75622: PUSH
75623: LD_INT 0
75625: PUSH
75626: EMPTY
75627: LIST
75628: LIST
75629: PUSH
75630: LD_INT 2
75632: NEG
75633: PUSH
75634: LD_INT 1
75636: NEG
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: PUSH
75642: LD_INT 2
75644: NEG
75645: PUSH
75646: LD_INT 2
75648: NEG
75649: PUSH
75650: EMPTY
75651: LIST
75652: LIST
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: LIST
75658: LIST
75659: LIST
75660: LIST
75661: LIST
75662: LIST
75663: LIST
75664: LIST
75665: LIST
75666: LIST
75667: LIST
75668: LIST
75669: LIST
75670: LIST
75671: LIST
75672: LIST
75673: LIST
75674: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75675: LD_ADDR_VAR 0 59
75679: PUSH
75680: LD_INT 0
75682: PUSH
75683: LD_INT 0
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: PUSH
75690: LD_INT 0
75692: PUSH
75693: LD_INT 1
75695: NEG
75696: PUSH
75697: EMPTY
75698: LIST
75699: LIST
75700: PUSH
75701: LD_INT 1
75703: PUSH
75704: LD_INT 0
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: PUSH
75711: LD_INT 1
75713: PUSH
75714: LD_INT 1
75716: PUSH
75717: EMPTY
75718: LIST
75719: LIST
75720: PUSH
75721: LD_INT 0
75723: PUSH
75724: LD_INT 1
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: PUSH
75731: LD_INT 1
75733: NEG
75734: PUSH
75735: LD_INT 0
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 1
75744: NEG
75745: PUSH
75746: LD_INT 1
75748: NEG
75749: PUSH
75750: EMPTY
75751: LIST
75752: LIST
75753: PUSH
75754: EMPTY
75755: LIST
75756: LIST
75757: LIST
75758: LIST
75759: LIST
75760: LIST
75761: LIST
75762: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75763: LD_ADDR_VAR 0 60
75767: PUSH
75768: LD_INT 0
75770: PUSH
75771: LD_INT 0
75773: PUSH
75774: EMPTY
75775: LIST
75776: LIST
75777: PUSH
75778: LD_INT 0
75780: PUSH
75781: LD_INT 1
75783: NEG
75784: PUSH
75785: EMPTY
75786: LIST
75787: LIST
75788: PUSH
75789: LD_INT 1
75791: PUSH
75792: LD_INT 0
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 1
75801: PUSH
75802: LD_INT 1
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 0
75811: PUSH
75812: LD_INT 1
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: PUSH
75819: LD_INT 1
75821: NEG
75822: PUSH
75823: LD_INT 0
75825: PUSH
75826: EMPTY
75827: LIST
75828: LIST
75829: PUSH
75830: LD_INT 1
75832: NEG
75833: PUSH
75834: LD_INT 1
75836: NEG
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: EMPTY
75843: LIST
75844: LIST
75845: LIST
75846: LIST
75847: LIST
75848: LIST
75849: LIST
75850: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75851: LD_ADDR_VAR 0 61
75855: PUSH
75856: LD_INT 0
75858: PUSH
75859: LD_INT 0
75861: PUSH
75862: EMPTY
75863: LIST
75864: LIST
75865: PUSH
75866: LD_INT 0
75868: PUSH
75869: LD_INT 1
75871: NEG
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: PUSH
75877: LD_INT 1
75879: PUSH
75880: LD_INT 0
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 1
75889: PUSH
75890: LD_INT 1
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 0
75899: PUSH
75900: LD_INT 1
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: LD_INT 1
75909: NEG
75910: PUSH
75911: LD_INT 0
75913: PUSH
75914: EMPTY
75915: LIST
75916: LIST
75917: PUSH
75918: LD_INT 1
75920: NEG
75921: PUSH
75922: LD_INT 1
75924: NEG
75925: PUSH
75926: EMPTY
75927: LIST
75928: LIST
75929: PUSH
75930: EMPTY
75931: LIST
75932: LIST
75933: LIST
75934: LIST
75935: LIST
75936: LIST
75937: LIST
75938: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75939: LD_ADDR_VAR 0 62
75943: PUSH
75944: LD_INT 0
75946: PUSH
75947: LD_INT 0
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 0
75956: PUSH
75957: LD_INT 1
75959: NEG
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 1
75967: PUSH
75968: LD_INT 0
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: LD_INT 1
75977: PUSH
75978: LD_INT 1
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: PUSH
75985: LD_INT 0
75987: PUSH
75988: LD_INT 1
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 1
75997: NEG
75998: PUSH
75999: LD_INT 0
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: PUSH
76006: LD_INT 1
76008: NEG
76009: PUSH
76010: LD_INT 1
76012: NEG
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: LIST
76022: LIST
76023: LIST
76024: LIST
76025: LIST
76026: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76027: LD_ADDR_VAR 0 63
76031: PUSH
76032: LD_INT 0
76034: PUSH
76035: LD_INT 0
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 0
76044: PUSH
76045: LD_INT 1
76047: NEG
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 1
76055: PUSH
76056: LD_INT 0
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 1
76065: PUSH
76066: LD_INT 1
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 0
76075: PUSH
76076: LD_INT 1
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PUSH
76083: LD_INT 1
76085: NEG
76086: PUSH
76087: LD_INT 0
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: PUSH
76094: LD_INT 1
76096: NEG
76097: PUSH
76098: LD_INT 1
76100: NEG
76101: PUSH
76102: EMPTY
76103: LIST
76104: LIST
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: LIST
76110: LIST
76111: LIST
76112: LIST
76113: LIST
76114: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76115: LD_ADDR_VAR 0 64
76119: PUSH
76120: LD_INT 0
76122: PUSH
76123: LD_INT 0
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: LD_INT 0
76132: PUSH
76133: LD_INT 1
76135: NEG
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: PUSH
76141: LD_INT 1
76143: PUSH
76144: LD_INT 0
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: PUSH
76151: LD_INT 1
76153: PUSH
76154: LD_INT 1
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 0
76163: PUSH
76164: LD_INT 1
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 1
76173: NEG
76174: PUSH
76175: LD_INT 0
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 1
76184: NEG
76185: PUSH
76186: LD_INT 1
76188: NEG
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: PUSH
76194: EMPTY
76195: LIST
76196: LIST
76197: LIST
76198: LIST
76199: LIST
76200: LIST
76201: LIST
76202: ST_TO_ADDR
// end ; 1 :
76203: GO 82100
76205: LD_INT 1
76207: DOUBLE
76208: EQUAL
76209: IFTRUE 76213
76211: GO 78836
76213: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76214: LD_ADDR_VAR 0 11
76218: PUSH
76219: LD_INT 1
76221: NEG
76222: PUSH
76223: LD_INT 3
76225: NEG
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 0
76233: PUSH
76234: LD_INT 3
76236: NEG
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: LD_INT 1
76244: PUSH
76245: LD_INT 2
76247: NEG
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: LIST
76257: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76258: LD_ADDR_VAR 0 12
76262: PUSH
76263: LD_INT 2
76265: PUSH
76266: LD_INT 1
76268: NEG
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PUSH
76274: LD_INT 3
76276: PUSH
76277: LD_INT 0
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: LD_INT 3
76286: PUSH
76287: LD_INT 1
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: LIST
76298: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76299: LD_ADDR_VAR 0 13
76303: PUSH
76304: LD_INT 3
76306: PUSH
76307: LD_INT 2
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 3
76316: PUSH
76317: LD_INT 3
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: LD_INT 2
76326: PUSH
76327: LD_INT 3
76329: PUSH
76330: EMPTY
76331: LIST
76332: LIST
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: LIST
76338: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76339: LD_ADDR_VAR 0 14
76343: PUSH
76344: LD_INT 1
76346: PUSH
76347: LD_INT 3
76349: PUSH
76350: EMPTY
76351: LIST
76352: LIST
76353: PUSH
76354: LD_INT 0
76356: PUSH
76357: LD_INT 3
76359: PUSH
76360: EMPTY
76361: LIST
76362: LIST
76363: PUSH
76364: LD_INT 1
76366: NEG
76367: PUSH
76368: LD_INT 2
76370: PUSH
76371: EMPTY
76372: LIST
76373: LIST
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: LIST
76379: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76380: LD_ADDR_VAR 0 15
76384: PUSH
76385: LD_INT 2
76387: NEG
76388: PUSH
76389: LD_INT 1
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: PUSH
76396: LD_INT 3
76398: NEG
76399: PUSH
76400: LD_INT 0
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: PUSH
76407: LD_INT 3
76409: NEG
76410: PUSH
76411: LD_INT 1
76413: NEG
76414: PUSH
76415: EMPTY
76416: LIST
76417: LIST
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: LIST
76423: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76424: LD_ADDR_VAR 0 16
76428: PUSH
76429: LD_INT 2
76431: NEG
76432: PUSH
76433: LD_INT 3
76435: NEG
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PUSH
76441: LD_INT 3
76443: NEG
76444: PUSH
76445: LD_INT 2
76447: NEG
76448: PUSH
76449: EMPTY
76450: LIST
76451: LIST
76452: PUSH
76453: LD_INT 3
76455: NEG
76456: PUSH
76457: LD_INT 3
76459: NEG
76460: PUSH
76461: EMPTY
76462: LIST
76463: LIST
76464: PUSH
76465: EMPTY
76466: LIST
76467: LIST
76468: LIST
76469: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76470: LD_ADDR_VAR 0 17
76474: PUSH
76475: LD_INT 1
76477: NEG
76478: PUSH
76479: LD_INT 3
76481: NEG
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: LD_INT 0
76489: PUSH
76490: LD_INT 3
76492: NEG
76493: PUSH
76494: EMPTY
76495: LIST
76496: LIST
76497: PUSH
76498: LD_INT 1
76500: PUSH
76501: LD_INT 2
76503: NEG
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: LIST
76513: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76514: LD_ADDR_VAR 0 18
76518: PUSH
76519: LD_INT 2
76521: PUSH
76522: LD_INT 1
76524: NEG
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: LD_INT 3
76532: PUSH
76533: LD_INT 0
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: LD_INT 3
76542: PUSH
76543: LD_INT 1
76545: PUSH
76546: EMPTY
76547: LIST
76548: LIST
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: LIST
76554: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76555: LD_ADDR_VAR 0 19
76559: PUSH
76560: LD_INT 3
76562: PUSH
76563: LD_INT 2
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: PUSH
76570: LD_INT 3
76572: PUSH
76573: LD_INT 3
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 2
76582: PUSH
76583: LD_INT 3
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: LIST
76594: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76595: LD_ADDR_VAR 0 20
76599: PUSH
76600: LD_INT 1
76602: PUSH
76603: LD_INT 3
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 0
76612: PUSH
76613: LD_INT 3
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PUSH
76620: LD_INT 1
76622: NEG
76623: PUSH
76624: LD_INT 2
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: LIST
76635: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76636: LD_ADDR_VAR 0 21
76640: PUSH
76641: LD_INT 2
76643: NEG
76644: PUSH
76645: LD_INT 1
76647: PUSH
76648: EMPTY
76649: LIST
76650: LIST
76651: PUSH
76652: LD_INT 3
76654: NEG
76655: PUSH
76656: LD_INT 0
76658: PUSH
76659: EMPTY
76660: LIST
76661: LIST
76662: PUSH
76663: LD_INT 3
76665: NEG
76666: PUSH
76667: LD_INT 1
76669: NEG
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: LIST
76679: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76680: LD_ADDR_VAR 0 22
76684: PUSH
76685: LD_INT 2
76687: NEG
76688: PUSH
76689: LD_INT 3
76691: NEG
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 3
76699: NEG
76700: PUSH
76701: LD_INT 2
76703: NEG
76704: PUSH
76705: EMPTY
76706: LIST
76707: LIST
76708: PUSH
76709: LD_INT 3
76711: NEG
76712: PUSH
76713: LD_INT 3
76715: NEG
76716: PUSH
76717: EMPTY
76718: LIST
76719: LIST
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: LIST
76725: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76726: LD_ADDR_VAR 0 23
76730: PUSH
76731: LD_INT 0
76733: PUSH
76734: LD_INT 3
76736: NEG
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PUSH
76742: LD_INT 1
76744: NEG
76745: PUSH
76746: LD_INT 4
76748: NEG
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: LD_INT 1
76756: PUSH
76757: LD_INT 3
76759: NEG
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: LIST
76769: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76770: LD_ADDR_VAR 0 24
76774: PUSH
76775: LD_INT 3
76777: PUSH
76778: LD_INT 0
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 3
76787: PUSH
76788: LD_INT 1
76790: NEG
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 4
76798: PUSH
76799: LD_INT 1
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: EMPTY
76807: LIST
76808: LIST
76809: LIST
76810: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76811: LD_ADDR_VAR 0 25
76815: PUSH
76816: LD_INT 3
76818: PUSH
76819: LD_INT 3
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 4
76828: PUSH
76829: LD_INT 3
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 3
76838: PUSH
76839: LD_INT 4
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: LIST
76850: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
76851: LD_ADDR_VAR 0 26
76855: PUSH
76856: LD_INT 0
76858: PUSH
76859: LD_INT 3
76861: PUSH
76862: EMPTY
76863: LIST
76864: LIST
76865: PUSH
76866: LD_INT 1
76868: PUSH
76869: LD_INT 4
76871: PUSH
76872: EMPTY
76873: LIST
76874: LIST
76875: PUSH
76876: LD_INT 1
76878: NEG
76879: PUSH
76880: LD_INT 3
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: LIST
76891: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
76892: LD_ADDR_VAR 0 27
76896: PUSH
76897: LD_INT 3
76899: NEG
76900: PUSH
76901: LD_INT 0
76903: PUSH
76904: EMPTY
76905: LIST
76906: LIST
76907: PUSH
76908: LD_INT 3
76910: NEG
76911: PUSH
76912: LD_INT 1
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: LD_INT 4
76921: NEG
76922: PUSH
76923: LD_INT 1
76925: NEG
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: LIST
76935: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76936: LD_ADDR_VAR 0 28
76940: PUSH
76941: LD_INT 3
76943: NEG
76944: PUSH
76945: LD_INT 3
76947: NEG
76948: PUSH
76949: EMPTY
76950: LIST
76951: LIST
76952: PUSH
76953: LD_INT 3
76955: NEG
76956: PUSH
76957: LD_INT 4
76959: NEG
76960: PUSH
76961: EMPTY
76962: LIST
76963: LIST
76964: PUSH
76965: LD_INT 4
76967: NEG
76968: PUSH
76969: LD_INT 3
76971: NEG
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: LIST
76981: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76982: LD_ADDR_VAR 0 29
76986: PUSH
76987: LD_INT 1
76989: NEG
76990: PUSH
76991: LD_INT 3
76993: NEG
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: PUSH
76999: LD_INT 0
77001: PUSH
77002: LD_INT 3
77004: NEG
77005: PUSH
77006: EMPTY
77007: LIST
77008: LIST
77009: PUSH
77010: LD_INT 1
77012: PUSH
77013: LD_INT 2
77015: NEG
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: PUSH
77021: LD_INT 1
77023: NEG
77024: PUSH
77025: LD_INT 4
77027: NEG
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: PUSH
77033: LD_INT 0
77035: PUSH
77036: LD_INT 4
77038: NEG
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: LD_INT 1
77046: PUSH
77047: LD_INT 3
77049: NEG
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: PUSH
77055: LD_INT 1
77057: NEG
77058: PUSH
77059: LD_INT 5
77061: NEG
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: LD_INT 0
77069: PUSH
77070: LD_INT 5
77072: NEG
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: LD_INT 1
77080: PUSH
77081: LD_INT 4
77083: NEG
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 1
77091: NEG
77092: PUSH
77093: LD_INT 6
77095: NEG
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PUSH
77101: LD_INT 0
77103: PUSH
77104: LD_INT 6
77106: NEG
77107: PUSH
77108: EMPTY
77109: LIST
77110: LIST
77111: PUSH
77112: LD_INT 1
77114: PUSH
77115: LD_INT 5
77117: NEG
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: LIST
77127: LIST
77128: LIST
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
77137: LD_ADDR_VAR 0 30
77141: PUSH
77142: LD_INT 2
77144: PUSH
77145: LD_INT 1
77147: NEG
77148: PUSH
77149: EMPTY
77150: LIST
77151: LIST
77152: PUSH
77153: LD_INT 3
77155: PUSH
77156: LD_INT 0
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: LD_INT 3
77165: PUSH
77166: LD_INT 1
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: PUSH
77173: LD_INT 3
77175: PUSH
77176: LD_INT 1
77178: NEG
77179: PUSH
77180: EMPTY
77181: LIST
77182: LIST
77183: PUSH
77184: LD_INT 4
77186: PUSH
77187: LD_INT 0
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: LD_INT 4
77196: PUSH
77197: LD_INT 1
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 4
77206: PUSH
77207: LD_INT 1
77209: NEG
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 5
77217: PUSH
77218: LD_INT 0
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 5
77227: PUSH
77228: LD_INT 1
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 5
77237: PUSH
77238: LD_INT 1
77240: NEG
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 6
77248: PUSH
77249: LD_INT 0
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 6
77258: PUSH
77259: LD_INT 1
77261: PUSH
77262: EMPTY
77263: LIST
77264: LIST
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: LIST
77270: LIST
77271: LIST
77272: LIST
77273: LIST
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
77280: LD_ADDR_VAR 0 31
77284: PUSH
77285: LD_INT 3
77287: PUSH
77288: LD_INT 2
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 3
77297: PUSH
77298: LD_INT 3
77300: PUSH
77301: EMPTY
77302: LIST
77303: LIST
77304: PUSH
77305: LD_INT 2
77307: PUSH
77308: LD_INT 3
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: LD_INT 4
77317: PUSH
77318: LD_INT 3
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: PUSH
77325: LD_INT 4
77327: PUSH
77328: LD_INT 4
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: PUSH
77335: LD_INT 3
77337: PUSH
77338: LD_INT 4
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 5
77347: PUSH
77348: LD_INT 4
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: PUSH
77355: LD_INT 5
77357: PUSH
77358: LD_INT 5
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 4
77367: PUSH
77368: LD_INT 5
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: LD_INT 6
77377: PUSH
77378: LD_INT 5
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: PUSH
77385: LD_INT 6
77387: PUSH
77388: LD_INT 6
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: PUSH
77395: LD_INT 5
77397: PUSH
77398: LD_INT 6
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: LIST
77409: LIST
77410: LIST
77411: LIST
77412: LIST
77413: LIST
77414: LIST
77415: LIST
77416: LIST
77417: LIST
77418: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
77419: LD_ADDR_VAR 0 32
77423: PUSH
77424: LD_INT 1
77426: PUSH
77427: LD_INT 3
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: PUSH
77434: LD_INT 0
77436: PUSH
77437: LD_INT 3
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PUSH
77444: LD_INT 1
77446: NEG
77447: PUSH
77448: LD_INT 2
77450: PUSH
77451: EMPTY
77452: LIST
77453: LIST
77454: PUSH
77455: LD_INT 1
77457: PUSH
77458: LD_INT 4
77460: PUSH
77461: EMPTY
77462: LIST
77463: LIST
77464: PUSH
77465: LD_INT 0
77467: PUSH
77468: LD_INT 4
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: PUSH
77475: LD_INT 1
77477: NEG
77478: PUSH
77479: LD_INT 3
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: LD_INT 1
77488: PUSH
77489: LD_INT 5
77491: PUSH
77492: EMPTY
77493: LIST
77494: LIST
77495: PUSH
77496: LD_INT 0
77498: PUSH
77499: LD_INT 5
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PUSH
77506: LD_INT 1
77508: NEG
77509: PUSH
77510: LD_INT 4
77512: PUSH
77513: EMPTY
77514: LIST
77515: LIST
77516: PUSH
77517: LD_INT 1
77519: PUSH
77520: LD_INT 6
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PUSH
77527: LD_INT 0
77529: PUSH
77530: LD_INT 6
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PUSH
77537: LD_INT 1
77539: NEG
77540: PUSH
77541: LD_INT 5
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: LIST
77552: LIST
77553: LIST
77554: LIST
77555: LIST
77556: LIST
77557: LIST
77558: LIST
77559: LIST
77560: LIST
77561: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
77562: LD_ADDR_VAR 0 33
77566: PUSH
77567: LD_INT 2
77569: NEG
77570: PUSH
77571: LD_INT 1
77573: PUSH
77574: EMPTY
77575: LIST
77576: LIST
77577: PUSH
77578: LD_INT 3
77580: NEG
77581: PUSH
77582: LD_INT 0
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: PUSH
77589: LD_INT 3
77591: NEG
77592: PUSH
77593: LD_INT 1
77595: NEG
77596: PUSH
77597: EMPTY
77598: LIST
77599: LIST
77600: PUSH
77601: LD_INT 3
77603: NEG
77604: PUSH
77605: LD_INT 1
77607: PUSH
77608: EMPTY
77609: LIST
77610: LIST
77611: PUSH
77612: LD_INT 4
77614: NEG
77615: PUSH
77616: LD_INT 0
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 4
77625: NEG
77626: PUSH
77627: LD_INT 1
77629: NEG
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 4
77637: NEG
77638: PUSH
77639: LD_INT 1
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: LD_INT 5
77648: NEG
77649: PUSH
77650: LD_INT 0
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: PUSH
77657: LD_INT 5
77659: NEG
77660: PUSH
77661: LD_INT 1
77663: NEG
77664: PUSH
77665: EMPTY
77666: LIST
77667: LIST
77668: PUSH
77669: LD_INT 5
77671: NEG
77672: PUSH
77673: LD_INT 1
77675: PUSH
77676: EMPTY
77677: LIST
77678: LIST
77679: PUSH
77680: LD_INT 6
77682: NEG
77683: PUSH
77684: LD_INT 0
77686: PUSH
77687: EMPTY
77688: LIST
77689: LIST
77690: PUSH
77691: LD_INT 6
77693: NEG
77694: PUSH
77695: LD_INT 1
77697: NEG
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: LIST
77707: LIST
77708: LIST
77709: LIST
77710: LIST
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: LIST
77716: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77717: LD_ADDR_VAR 0 34
77721: PUSH
77722: LD_INT 2
77724: NEG
77725: PUSH
77726: LD_INT 3
77728: NEG
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PUSH
77734: LD_INT 3
77736: NEG
77737: PUSH
77738: LD_INT 2
77740: NEG
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: PUSH
77746: LD_INT 3
77748: NEG
77749: PUSH
77750: LD_INT 3
77752: NEG
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: PUSH
77758: LD_INT 3
77760: NEG
77761: PUSH
77762: LD_INT 4
77764: NEG
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: PUSH
77770: LD_INT 4
77772: NEG
77773: PUSH
77774: LD_INT 3
77776: NEG
77777: PUSH
77778: EMPTY
77779: LIST
77780: LIST
77781: PUSH
77782: LD_INT 4
77784: NEG
77785: PUSH
77786: LD_INT 4
77788: NEG
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PUSH
77794: LD_INT 4
77796: NEG
77797: PUSH
77798: LD_INT 5
77800: NEG
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 5
77808: NEG
77809: PUSH
77810: LD_INT 4
77812: NEG
77813: PUSH
77814: EMPTY
77815: LIST
77816: LIST
77817: PUSH
77818: LD_INT 5
77820: NEG
77821: PUSH
77822: LD_INT 5
77824: NEG
77825: PUSH
77826: EMPTY
77827: LIST
77828: LIST
77829: PUSH
77830: LD_INT 5
77832: NEG
77833: PUSH
77834: LD_INT 6
77836: NEG
77837: PUSH
77838: EMPTY
77839: LIST
77840: LIST
77841: PUSH
77842: LD_INT 6
77844: NEG
77845: PUSH
77846: LD_INT 5
77848: NEG
77849: PUSH
77850: EMPTY
77851: LIST
77852: LIST
77853: PUSH
77854: LD_INT 6
77856: NEG
77857: PUSH
77858: LD_INT 6
77860: NEG
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: LIST
77870: LIST
77871: LIST
77872: LIST
77873: LIST
77874: LIST
77875: LIST
77876: LIST
77877: LIST
77878: LIST
77879: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
77880: LD_ADDR_VAR 0 41
77884: PUSH
77885: LD_INT 0
77887: PUSH
77888: LD_INT 2
77890: NEG
77891: PUSH
77892: EMPTY
77893: LIST
77894: LIST
77895: PUSH
77896: LD_INT 1
77898: NEG
77899: PUSH
77900: LD_INT 3
77902: NEG
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: PUSH
77908: LD_INT 1
77910: PUSH
77911: LD_INT 2
77913: NEG
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: EMPTY
77920: LIST
77921: LIST
77922: LIST
77923: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77924: LD_ADDR_VAR 0 42
77928: PUSH
77929: LD_INT 2
77931: PUSH
77932: LD_INT 0
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 2
77941: PUSH
77942: LD_INT 1
77944: NEG
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: LD_INT 3
77952: PUSH
77953: LD_INT 1
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: LIST
77964: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77965: LD_ADDR_VAR 0 43
77969: PUSH
77970: LD_INT 2
77972: PUSH
77973: LD_INT 2
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: PUSH
77980: LD_INT 3
77982: PUSH
77983: LD_INT 2
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: LD_INT 2
77992: PUSH
77993: LD_INT 3
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: LIST
78004: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
78005: LD_ADDR_VAR 0 44
78009: PUSH
78010: LD_INT 0
78012: PUSH
78013: LD_INT 2
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 1
78022: PUSH
78023: LD_INT 3
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: LD_INT 1
78032: NEG
78033: PUSH
78034: LD_INT 2
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: EMPTY
78042: LIST
78043: LIST
78044: LIST
78045: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78046: LD_ADDR_VAR 0 45
78050: PUSH
78051: LD_INT 2
78053: NEG
78054: PUSH
78055: LD_INT 0
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: PUSH
78062: LD_INT 2
78064: NEG
78065: PUSH
78066: LD_INT 1
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: LD_INT 3
78075: NEG
78076: PUSH
78077: LD_INT 1
78079: NEG
78080: PUSH
78081: EMPTY
78082: LIST
78083: LIST
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: LIST
78089: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78090: LD_ADDR_VAR 0 46
78094: PUSH
78095: LD_INT 2
78097: NEG
78098: PUSH
78099: LD_INT 2
78101: NEG
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: LD_INT 2
78109: NEG
78110: PUSH
78111: LD_INT 3
78113: NEG
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: PUSH
78119: LD_INT 3
78121: NEG
78122: PUSH
78123: LD_INT 2
78125: NEG
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: LIST
78135: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
78136: LD_ADDR_VAR 0 47
78140: PUSH
78141: LD_INT 2
78143: NEG
78144: PUSH
78145: LD_INT 3
78147: NEG
78148: PUSH
78149: EMPTY
78150: LIST
78151: LIST
78152: PUSH
78153: LD_INT 1
78155: NEG
78156: PUSH
78157: LD_INT 3
78159: NEG
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78169: LD_ADDR_VAR 0 48
78173: PUSH
78174: LD_INT 1
78176: PUSH
78177: LD_INT 2
78179: NEG
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: PUSH
78185: LD_INT 2
78187: PUSH
78188: LD_INT 1
78190: NEG
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
78200: LD_ADDR_VAR 0 49
78204: PUSH
78205: LD_INT 3
78207: PUSH
78208: LD_INT 1
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 3
78217: PUSH
78218: LD_INT 2
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
78229: LD_ADDR_VAR 0 50
78233: PUSH
78234: LD_INT 2
78236: PUSH
78237: LD_INT 3
78239: PUSH
78240: EMPTY
78241: LIST
78242: LIST
78243: PUSH
78244: LD_INT 1
78246: PUSH
78247: LD_INT 3
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78258: LD_ADDR_VAR 0 51
78262: PUSH
78263: LD_INT 1
78265: NEG
78266: PUSH
78267: LD_INT 2
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 2
78276: NEG
78277: PUSH
78278: LD_INT 1
78280: PUSH
78281: EMPTY
78282: LIST
78283: LIST
78284: PUSH
78285: EMPTY
78286: LIST
78287: LIST
78288: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78289: LD_ADDR_VAR 0 52
78293: PUSH
78294: LD_INT 3
78296: NEG
78297: PUSH
78298: LD_INT 1
78300: NEG
78301: PUSH
78302: EMPTY
78303: LIST
78304: LIST
78305: PUSH
78306: LD_INT 3
78308: NEG
78309: PUSH
78310: LD_INT 2
78312: NEG
78313: PUSH
78314: EMPTY
78315: LIST
78316: LIST
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78322: LD_ADDR_VAR 0 53
78326: PUSH
78327: LD_INT 1
78329: NEG
78330: PUSH
78331: LD_INT 3
78333: NEG
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 0
78341: PUSH
78342: LD_INT 3
78344: NEG
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 1
78352: PUSH
78353: LD_INT 2
78355: NEG
78356: PUSH
78357: EMPTY
78358: LIST
78359: LIST
78360: PUSH
78361: EMPTY
78362: LIST
78363: LIST
78364: LIST
78365: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78366: LD_ADDR_VAR 0 54
78370: PUSH
78371: LD_INT 2
78373: PUSH
78374: LD_INT 1
78376: NEG
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 3
78384: PUSH
78385: LD_INT 0
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: LD_INT 3
78394: PUSH
78395: LD_INT 1
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: LIST
78406: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78407: LD_ADDR_VAR 0 55
78411: PUSH
78412: LD_INT 3
78414: PUSH
78415: LD_INT 2
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 3
78424: PUSH
78425: LD_INT 3
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: PUSH
78432: LD_INT 2
78434: PUSH
78435: LD_INT 3
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: LIST
78446: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78447: LD_ADDR_VAR 0 56
78451: PUSH
78452: LD_INT 1
78454: PUSH
78455: LD_INT 3
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 0
78464: PUSH
78465: LD_INT 3
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 1
78474: NEG
78475: PUSH
78476: LD_INT 2
78478: PUSH
78479: EMPTY
78480: LIST
78481: LIST
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: LIST
78487: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78488: LD_ADDR_VAR 0 57
78492: PUSH
78493: LD_INT 2
78495: NEG
78496: PUSH
78497: LD_INT 1
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: PUSH
78504: LD_INT 3
78506: NEG
78507: PUSH
78508: LD_INT 0
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: PUSH
78515: LD_INT 3
78517: NEG
78518: PUSH
78519: LD_INT 1
78521: NEG
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: LIST
78531: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78532: LD_ADDR_VAR 0 58
78536: PUSH
78537: LD_INT 2
78539: NEG
78540: PUSH
78541: LD_INT 3
78543: NEG
78544: PUSH
78545: EMPTY
78546: LIST
78547: LIST
78548: PUSH
78549: LD_INT 3
78551: NEG
78552: PUSH
78553: LD_INT 2
78555: NEG
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: PUSH
78561: LD_INT 3
78563: NEG
78564: PUSH
78565: LD_INT 3
78567: NEG
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: LIST
78577: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
78578: LD_ADDR_VAR 0 59
78582: PUSH
78583: LD_INT 1
78585: NEG
78586: PUSH
78587: LD_INT 2
78589: NEG
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 0
78597: PUSH
78598: LD_INT 2
78600: NEG
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: LD_INT 1
78608: PUSH
78609: LD_INT 1
78611: NEG
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: PUSH
78617: EMPTY
78618: LIST
78619: LIST
78620: LIST
78621: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78622: LD_ADDR_VAR 0 60
78626: PUSH
78627: LD_INT 1
78629: PUSH
78630: LD_INT 1
78632: NEG
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PUSH
78638: LD_INT 2
78640: PUSH
78641: LD_INT 0
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: LD_INT 2
78650: PUSH
78651: LD_INT 1
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: LIST
78662: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78663: LD_ADDR_VAR 0 61
78667: PUSH
78668: LD_INT 2
78670: PUSH
78671: LD_INT 1
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: PUSH
78678: LD_INT 2
78680: PUSH
78681: LD_INT 2
78683: PUSH
78684: EMPTY
78685: LIST
78686: LIST
78687: PUSH
78688: LD_INT 1
78690: PUSH
78691: LD_INT 2
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: LIST
78702: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78703: LD_ADDR_VAR 0 62
78707: PUSH
78708: LD_INT 1
78710: PUSH
78711: LD_INT 2
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: LD_INT 0
78720: PUSH
78721: LD_INT 2
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: LD_INT 1
78730: NEG
78731: PUSH
78732: LD_INT 1
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: EMPTY
78740: LIST
78741: LIST
78742: LIST
78743: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78744: LD_ADDR_VAR 0 63
78748: PUSH
78749: LD_INT 1
78751: NEG
78752: PUSH
78753: LD_INT 1
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 2
78762: NEG
78763: PUSH
78764: LD_INT 0
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PUSH
78771: LD_INT 2
78773: NEG
78774: PUSH
78775: LD_INT 1
78777: NEG
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: LIST
78787: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78788: LD_ADDR_VAR 0 64
78792: PUSH
78793: LD_INT 1
78795: NEG
78796: PUSH
78797: LD_INT 2
78799: NEG
78800: PUSH
78801: EMPTY
78802: LIST
78803: LIST
78804: PUSH
78805: LD_INT 2
78807: NEG
78808: PUSH
78809: LD_INT 1
78811: NEG
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: PUSH
78817: LD_INT 2
78819: NEG
78820: PUSH
78821: LD_INT 2
78823: NEG
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: LIST
78833: ST_TO_ADDR
// end ; 2 :
78834: GO 82100
78836: LD_INT 2
78838: DOUBLE
78839: EQUAL
78840: IFTRUE 78844
78842: GO 82099
78844: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
78845: LD_ADDR_VAR 0 29
78849: PUSH
78850: LD_INT 4
78852: PUSH
78853: LD_INT 0
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: PUSH
78860: LD_INT 4
78862: PUSH
78863: LD_INT 1
78865: NEG
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: PUSH
78871: LD_INT 5
78873: PUSH
78874: LD_INT 0
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: LD_INT 5
78883: PUSH
78884: LD_INT 1
78886: PUSH
78887: EMPTY
78888: LIST
78889: LIST
78890: PUSH
78891: LD_INT 4
78893: PUSH
78894: LD_INT 1
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 3
78903: PUSH
78904: LD_INT 0
78906: PUSH
78907: EMPTY
78908: LIST
78909: LIST
78910: PUSH
78911: LD_INT 3
78913: PUSH
78914: LD_INT 1
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 3
78924: PUSH
78925: LD_INT 2
78927: NEG
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: LD_INT 5
78935: PUSH
78936: LD_INT 2
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 3
78945: PUSH
78946: LD_INT 3
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 3
78955: PUSH
78956: LD_INT 2
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 4
78965: PUSH
78966: LD_INT 3
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 4
78975: PUSH
78976: LD_INT 4
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: LD_INT 3
78985: PUSH
78986: LD_INT 4
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 2
78995: PUSH
78996: LD_INT 3
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: LD_INT 2
79005: PUSH
79006: LD_INT 2
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 4
79015: PUSH
79016: LD_INT 2
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: PUSH
79023: LD_INT 2
79025: PUSH
79026: LD_INT 4
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 0
79035: PUSH
79036: LD_INT 4
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 0
79045: PUSH
79046: LD_INT 3
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 1
79055: PUSH
79056: LD_INT 4
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: LD_INT 1
79065: PUSH
79066: LD_INT 5
79068: PUSH
79069: EMPTY
79070: LIST
79071: LIST
79072: PUSH
79073: LD_INT 0
79075: PUSH
79076: LD_INT 5
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 1
79085: NEG
79086: PUSH
79087: LD_INT 4
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: LD_INT 1
79096: NEG
79097: PUSH
79098: LD_INT 3
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PUSH
79105: LD_INT 2
79107: PUSH
79108: LD_INT 5
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 2
79117: NEG
79118: PUSH
79119: LD_INT 3
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 3
79128: NEG
79129: PUSH
79130: LD_INT 0
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 3
79139: NEG
79140: PUSH
79141: LD_INT 1
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 2
79151: NEG
79152: PUSH
79153: LD_INT 0
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 2
79162: NEG
79163: PUSH
79164: LD_INT 1
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 3
79173: NEG
79174: PUSH
79175: LD_INT 1
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 4
79184: NEG
79185: PUSH
79186: LD_INT 0
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 4
79195: NEG
79196: PUSH
79197: LD_INT 1
79199: NEG
79200: PUSH
79201: EMPTY
79202: LIST
79203: LIST
79204: PUSH
79205: LD_INT 4
79207: NEG
79208: PUSH
79209: LD_INT 2
79211: NEG
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 2
79219: NEG
79220: PUSH
79221: LD_INT 2
79223: PUSH
79224: EMPTY
79225: LIST
79226: LIST
79227: PUSH
79228: LD_INT 4
79230: NEG
79231: PUSH
79232: LD_INT 4
79234: NEG
79235: PUSH
79236: EMPTY
79237: LIST
79238: LIST
79239: PUSH
79240: LD_INT 4
79242: NEG
79243: PUSH
79244: LD_INT 5
79246: NEG
79247: PUSH
79248: EMPTY
79249: LIST
79250: LIST
79251: PUSH
79252: LD_INT 3
79254: NEG
79255: PUSH
79256: LD_INT 4
79258: NEG
79259: PUSH
79260: EMPTY
79261: LIST
79262: LIST
79263: PUSH
79264: LD_INT 3
79266: NEG
79267: PUSH
79268: LD_INT 3
79270: NEG
79271: PUSH
79272: EMPTY
79273: LIST
79274: LIST
79275: PUSH
79276: LD_INT 4
79278: NEG
79279: PUSH
79280: LD_INT 3
79282: NEG
79283: PUSH
79284: EMPTY
79285: LIST
79286: LIST
79287: PUSH
79288: LD_INT 5
79290: NEG
79291: PUSH
79292: LD_INT 4
79294: NEG
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 5
79302: NEG
79303: PUSH
79304: LD_INT 5
79306: NEG
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: PUSH
79312: LD_INT 3
79314: NEG
79315: PUSH
79316: LD_INT 5
79318: NEG
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: LD_INT 5
79326: NEG
79327: PUSH
79328: LD_INT 3
79330: NEG
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: LIST
79348: LIST
79349: LIST
79350: LIST
79351: LIST
79352: LIST
79353: LIST
79354: LIST
79355: LIST
79356: LIST
79357: LIST
79358: LIST
79359: LIST
79360: LIST
79361: LIST
79362: LIST
79363: LIST
79364: LIST
79365: LIST
79366: LIST
79367: LIST
79368: LIST
79369: LIST
79370: LIST
79371: LIST
79372: LIST
79373: LIST
79374: LIST
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
79383: LD_ADDR_VAR 0 30
79387: PUSH
79388: LD_INT 4
79390: PUSH
79391: LD_INT 4
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PUSH
79398: LD_INT 4
79400: PUSH
79401: LD_INT 3
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: PUSH
79408: LD_INT 5
79410: PUSH
79411: LD_INT 4
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 5
79420: PUSH
79421: LD_INT 5
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: LD_INT 4
79430: PUSH
79431: LD_INT 5
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 3
79440: PUSH
79441: LD_INT 4
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 3
79450: PUSH
79451: LD_INT 3
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 5
79460: PUSH
79461: LD_INT 3
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 3
79470: PUSH
79471: LD_INT 5
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 0
79480: PUSH
79481: LD_INT 3
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 0
79490: PUSH
79491: LD_INT 2
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: PUSH
79498: LD_INT 1
79500: PUSH
79501: LD_INT 3
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: LD_INT 1
79510: PUSH
79511: LD_INT 4
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 0
79520: PUSH
79521: LD_INT 4
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 1
79530: NEG
79531: PUSH
79532: LD_INT 3
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 1
79541: NEG
79542: PUSH
79543: LD_INT 2
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 2
79552: PUSH
79553: LD_INT 4
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 2
79562: NEG
79563: PUSH
79564: LD_INT 2
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 4
79573: NEG
79574: PUSH
79575: LD_INT 0
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 4
79584: NEG
79585: PUSH
79586: LD_INT 1
79588: NEG
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: LD_INT 3
79596: NEG
79597: PUSH
79598: LD_INT 0
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: PUSH
79605: LD_INT 3
79607: NEG
79608: PUSH
79609: LD_INT 1
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 4
79618: NEG
79619: PUSH
79620: LD_INT 1
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: LD_INT 5
79629: NEG
79630: PUSH
79631: LD_INT 0
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 5
79640: NEG
79641: PUSH
79642: LD_INT 1
79644: NEG
79645: PUSH
79646: EMPTY
79647: LIST
79648: LIST
79649: PUSH
79650: LD_INT 5
79652: NEG
79653: PUSH
79654: LD_INT 2
79656: NEG
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: LD_INT 3
79664: NEG
79665: PUSH
79666: LD_INT 2
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PUSH
79673: LD_INT 3
79675: NEG
79676: PUSH
79677: LD_INT 3
79679: NEG
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: PUSH
79685: LD_INT 3
79687: NEG
79688: PUSH
79689: LD_INT 4
79691: NEG
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PUSH
79697: LD_INT 2
79699: NEG
79700: PUSH
79701: LD_INT 3
79703: NEG
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 2
79711: NEG
79712: PUSH
79713: LD_INT 2
79715: NEG
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: PUSH
79721: LD_INT 3
79723: NEG
79724: PUSH
79725: LD_INT 2
79727: NEG
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_INT 4
79735: NEG
79736: PUSH
79737: LD_INT 3
79739: NEG
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: PUSH
79745: LD_INT 4
79747: NEG
79748: PUSH
79749: LD_INT 4
79751: NEG
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: PUSH
79757: LD_INT 2
79759: NEG
79760: PUSH
79761: LD_INT 4
79763: NEG
79764: PUSH
79765: EMPTY
79766: LIST
79767: LIST
79768: PUSH
79769: LD_INT 4
79771: NEG
79772: PUSH
79773: LD_INT 2
79775: NEG
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 0
79783: PUSH
79784: LD_INT 4
79786: NEG
79787: PUSH
79788: EMPTY
79789: LIST
79790: LIST
79791: PUSH
79792: LD_INT 0
79794: PUSH
79795: LD_INT 5
79797: NEG
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: LD_INT 1
79805: PUSH
79806: LD_INT 4
79808: NEG
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 1
79816: PUSH
79817: LD_INT 3
79819: NEG
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: LD_INT 0
79827: PUSH
79828: LD_INT 3
79830: NEG
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 1
79838: NEG
79839: PUSH
79840: LD_INT 4
79842: NEG
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: LD_INT 1
79850: NEG
79851: PUSH
79852: LD_INT 5
79854: NEG
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 2
79862: PUSH
79863: LD_INT 3
79865: NEG
79866: PUSH
79867: EMPTY
79868: LIST
79869: LIST
79870: PUSH
79871: LD_INT 2
79873: NEG
79874: PUSH
79875: LD_INT 5
79877: NEG
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: PUSH
79883: EMPTY
79884: LIST
79885: LIST
79886: LIST
79887: LIST
79888: LIST
79889: LIST
79890: LIST
79891: LIST
79892: LIST
79893: LIST
79894: LIST
79895: LIST
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: LIST
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: LIST
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: LIST
79923: LIST
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: LIST
79929: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79930: LD_ADDR_VAR 0 31
79934: PUSH
79935: LD_INT 0
79937: PUSH
79938: LD_INT 4
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 0
79947: PUSH
79948: LD_INT 3
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: LD_INT 1
79957: PUSH
79958: LD_INT 4
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: PUSH
79965: LD_INT 1
79967: PUSH
79968: LD_INT 5
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: LD_INT 0
79977: PUSH
79978: LD_INT 5
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 1
79987: NEG
79988: PUSH
79989: LD_INT 4
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: PUSH
79996: LD_INT 1
79998: NEG
79999: PUSH
80000: LD_INT 3
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 2
80009: PUSH
80010: LD_INT 5
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 2
80019: NEG
80020: PUSH
80021: LD_INT 3
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: PUSH
80028: LD_INT 3
80030: NEG
80031: PUSH
80032: LD_INT 0
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: LD_INT 3
80041: NEG
80042: PUSH
80043: LD_INT 1
80045: NEG
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PUSH
80051: LD_INT 2
80053: NEG
80054: PUSH
80055: LD_INT 0
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: PUSH
80062: LD_INT 2
80064: NEG
80065: PUSH
80066: LD_INT 1
80068: PUSH
80069: EMPTY
80070: LIST
80071: LIST
80072: PUSH
80073: LD_INT 3
80075: NEG
80076: PUSH
80077: LD_INT 1
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PUSH
80084: LD_INT 4
80086: NEG
80087: PUSH
80088: LD_INT 0
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 4
80097: NEG
80098: PUSH
80099: LD_INT 1
80101: NEG
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: PUSH
80107: LD_INT 4
80109: NEG
80110: PUSH
80111: LD_INT 2
80113: NEG
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 2
80121: NEG
80122: PUSH
80123: LD_INT 2
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: LD_INT 4
80132: NEG
80133: PUSH
80134: LD_INT 4
80136: NEG
80137: PUSH
80138: EMPTY
80139: LIST
80140: LIST
80141: PUSH
80142: LD_INT 4
80144: NEG
80145: PUSH
80146: LD_INT 5
80148: NEG
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: LD_INT 3
80156: NEG
80157: PUSH
80158: LD_INT 4
80160: NEG
80161: PUSH
80162: EMPTY
80163: LIST
80164: LIST
80165: PUSH
80166: LD_INT 3
80168: NEG
80169: PUSH
80170: LD_INT 3
80172: NEG
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: PUSH
80178: LD_INT 4
80180: NEG
80181: PUSH
80182: LD_INT 3
80184: NEG
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 5
80192: NEG
80193: PUSH
80194: LD_INT 4
80196: NEG
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 5
80204: NEG
80205: PUSH
80206: LD_INT 5
80208: NEG
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 3
80216: NEG
80217: PUSH
80218: LD_INT 5
80220: NEG
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 5
80228: NEG
80229: PUSH
80230: LD_INT 3
80232: NEG
80233: PUSH
80234: EMPTY
80235: LIST
80236: LIST
80237: PUSH
80238: LD_INT 0
80240: PUSH
80241: LD_INT 3
80243: NEG
80244: PUSH
80245: EMPTY
80246: LIST
80247: LIST
80248: PUSH
80249: LD_INT 0
80251: PUSH
80252: LD_INT 4
80254: NEG
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: LD_INT 1
80262: PUSH
80263: LD_INT 3
80265: NEG
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 1
80273: PUSH
80274: LD_INT 2
80276: NEG
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 0
80284: PUSH
80285: LD_INT 2
80287: NEG
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 1
80295: NEG
80296: PUSH
80297: LD_INT 3
80299: NEG
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 1
80307: NEG
80308: PUSH
80309: LD_INT 4
80311: NEG
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 2
80319: PUSH
80320: LD_INT 2
80322: NEG
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 2
80330: NEG
80331: PUSH
80332: LD_INT 4
80334: NEG
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: PUSH
80340: LD_INT 4
80342: PUSH
80343: LD_INT 0
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 4
80352: PUSH
80353: LD_INT 1
80355: NEG
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: PUSH
80361: LD_INT 5
80363: PUSH
80364: LD_INT 0
80366: PUSH
80367: EMPTY
80368: LIST
80369: LIST
80370: PUSH
80371: LD_INT 5
80373: PUSH
80374: LD_INT 1
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 4
80383: PUSH
80384: LD_INT 1
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 3
80393: PUSH
80394: LD_INT 0
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 3
80403: PUSH
80404: LD_INT 1
80406: NEG
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 3
80414: PUSH
80415: LD_INT 2
80417: NEG
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 5
80425: PUSH
80426: LD_INT 2
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: PUSH
80433: EMPTY
80434: LIST
80435: LIST
80436: LIST
80437: LIST
80438: LIST
80439: LIST
80440: LIST
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: LIST
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: LIST
80472: LIST
80473: LIST
80474: LIST
80475: LIST
80476: LIST
80477: LIST
80478: LIST
80479: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
80480: LD_ADDR_VAR 0 32
80484: PUSH
80485: LD_INT 4
80487: NEG
80488: PUSH
80489: LD_INT 0
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 4
80498: NEG
80499: PUSH
80500: LD_INT 1
80502: NEG
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: LD_INT 3
80510: NEG
80511: PUSH
80512: LD_INT 0
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 3
80521: NEG
80522: PUSH
80523: LD_INT 1
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 4
80532: NEG
80533: PUSH
80534: LD_INT 1
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 5
80543: NEG
80544: PUSH
80545: LD_INT 0
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: LD_INT 5
80554: NEG
80555: PUSH
80556: LD_INT 1
80558: NEG
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 5
80566: NEG
80567: PUSH
80568: LD_INT 2
80570: NEG
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: LD_INT 3
80578: NEG
80579: PUSH
80580: LD_INT 2
80582: PUSH
80583: EMPTY
80584: LIST
80585: LIST
80586: PUSH
80587: LD_INT 3
80589: NEG
80590: PUSH
80591: LD_INT 3
80593: NEG
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 3
80601: NEG
80602: PUSH
80603: LD_INT 4
80605: NEG
80606: PUSH
80607: EMPTY
80608: LIST
80609: LIST
80610: PUSH
80611: LD_INT 2
80613: NEG
80614: PUSH
80615: LD_INT 3
80617: NEG
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PUSH
80623: LD_INT 2
80625: NEG
80626: PUSH
80627: LD_INT 2
80629: NEG
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 3
80637: NEG
80638: PUSH
80639: LD_INT 2
80641: NEG
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: LD_INT 4
80649: NEG
80650: PUSH
80651: LD_INT 3
80653: NEG
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 4
80661: NEG
80662: PUSH
80663: LD_INT 4
80665: NEG
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: PUSH
80671: LD_INT 2
80673: NEG
80674: PUSH
80675: LD_INT 4
80677: NEG
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 4
80685: NEG
80686: PUSH
80687: LD_INT 2
80689: NEG
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: PUSH
80695: LD_INT 0
80697: PUSH
80698: LD_INT 4
80700: NEG
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: PUSH
80706: LD_INT 0
80708: PUSH
80709: LD_INT 5
80711: NEG
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 1
80719: PUSH
80720: LD_INT 4
80722: NEG
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 1
80730: PUSH
80731: LD_INT 3
80733: NEG
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 0
80741: PUSH
80742: LD_INT 3
80744: NEG
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 1
80752: NEG
80753: PUSH
80754: LD_INT 4
80756: NEG
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 1
80764: NEG
80765: PUSH
80766: LD_INT 5
80768: NEG
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 2
80776: PUSH
80777: LD_INT 3
80779: NEG
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 2
80787: NEG
80788: PUSH
80789: LD_INT 5
80791: NEG
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 3
80799: PUSH
80800: LD_INT 0
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 3
80809: PUSH
80810: LD_INT 1
80812: NEG
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 4
80820: PUSH
80821: LD_INT 0
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 4
80830: PUSH
80831: LD_INT 1
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 3
80840: PUSH
80841: LD_INT 1
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: LD_INT 2
80850: PUSH
80851: LD_INT 0
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 2
80860: PUSH
80861: LD_INT 1
80863: NEG
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 2
80871: PUSH
80872: LD_INT 2
80874: NEG
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: LD_INT 4
80882: PUSH
80883: LD_INT 2
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: PUSH
80890: LD_INT 4
80892: PUSH
80893: LD_INT 4
80895: PUSH
80896: EMPTY
80897: LIST
80898: LIST
80899: PUSH
80900: LD_INT 4
80902: PUSH
80903: LD_INT 3
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 5
80912: PUSH
80913: LD_INT 4
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: LD_INT 5
80922: PUSH
80923: LD_INT 5
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 4
80932: PUSH
80933: LD_INT 5
80935: PUSH
80936: EMPTY
80937: LIST
80938: LIST
80939: PUSH
80940: LD_INT 3
80942: PUSH
80943: LD_INT 4
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 3
80952: PUSH
80953: LD_INT 3
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: LD_INT 5
80962: PUSH
80963: LD_INT 3
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: PUSH
80970: LD_INT 3
80972: PUSH
80973: LD_INT 5
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: LIST
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: LIST
81006: LIST
81007: LIST
81008: LIST
81009: LIST
81010: LIST
81011: LIST
81012: LIST
81013: LIST
81014: LIST
81015: LIST
81016: LIST
81017: LIST
81018: LIST
81019: LIST
81020: LIST
81021: LIST
81022: LIST
81023: LIST
81024: LIST
81025: LIST
81026: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
81027: LD_ADDR_VAR 0 33
81031: PUSH
81032: LD_INT 4
81034: NEG
81035: PUSH
81036: LD_INT 4
81038: NEG
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: PUSH
81044: LD_INT 4
81046: NEG
81047: PUSH
81048: LD_INT 5
81050: NEG
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: PUSH
81056: LD_INT 3
81058: NEG
81059: PUSH
81060: LD_INT 4
81062: NEG
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: PUSH
81068: LD_INT 3
81070: NEG
81071: PUSH
81072: LD_INT 3
81074: NEG
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 4
81082: NEG
81083: PUSH
81084: LD_INT 3
81086: NEG
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: PUSH
81092: LD_INT 5
81094: NEG
81095: PUSH
81096: LD_INT 4
81098: NEG
81099: PUSH
81100: EMPTY
81101: LIST
81102: LIST
81103: PUSH
81104: LD_INT 5
81106: NEG
81107: PUSH
81108: LD_INT 5
81110: NEG
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PUSH
81116: LD_INT 3
81118: NEG
81119: PUSH
81120: LD_INT 5
81122: NEG
81123: PUSH
81124: EMPTY
81125: LIST
81126: LIST
81127: PUSH
81128: LD_INT 5
81130: NEG
81131: PUSH
81132: LD_INT 3
81134: NEG
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PUSH
81140: LD_INT 0
81142: PUSH
81143: LD_INT 3
81145: NEG
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 0
81153: PUSH
81154: LD_INT 4
81156: NEG
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: PUSH
81162: LD_INT 1
81164: PUSH
81165: LD_INT 3
81167: NEG
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: LD_INT 1
81175: PUSH
81176: LD_INT 2
81178: NEG
81179: PUSH
81180: EMPTY
81181: LIST
81182: LIST
81183: PUSH
81184: LD_INT 0
81186: PUSH
81187: LD_INT 2
81189: NEG
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 1
81197: NEG
81198: PUSH
81199: LD_INT 3
81201: NEG
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 1
81209: NEG
81210: PUSH
81211: LD_INT 4
81213: NEG
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 2
81221: PUSH
81222: LD_INT 2
81224: NEG
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 2
81232: NEG
81233: PUSH
81234: LD_INT 4
81236: NEG
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 4
81244: PUSH
81245: LD_INT 0
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 4
81254: PUSH
81255: LD_INT 1
81257: NEG
81258: PUSH
81259: EMPTY
81260: LIST
81261: LIST
81262: PUSH
81263: LD_INT 5
81265: PUSH
81266: LD_INT 0
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: LD_INT 5
81275: PUSH
81276: LD_INT 1
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 4
81285: PUSH
81286: LD_INT 1
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PUSH
81293: LD_INT 3
81295: PUSH
81296: LD_INT 0
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: PUSH
81303: LD_INT 3
81305: PUSH
81306: LD_INT 1
81308: NEG
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: LD_INT 3
81316: PUSH
81317: LD_INT 2
81319: NEG
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 5
81327: PUSH
81328: LD_INT 2
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 3
81337: PUSH
81338: LD_INT 3
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: LD_INT 3
81347: PUSH
81348: LD_INT 2
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 4
81357: PUSH
81358: LD_INT 3
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PUSH
81365: LD_INT 4
81367: PUSH
81368: LD_INT 4
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: PUSH
81375: LD_INT 3
81377: PUSH
81378: LD_INT 4
81380: PUSH
81381: EMPTY
81382: LIST
81383: LIST
81384: PUSH
81385: LD_INT 2
81387: PUSH
81388: LD_INT 3
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 2
81397: PUSH
81398: LD_INT 2
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 4
81407: PUSH
81408: LD_INT 2
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: LD_INT 2
81417: PUSH
81418: LD_INT 4
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 0
81427: PUSH
81428: LD_INT 4
81430: PUSH
81431: EMPTY
81432: LIST
81433: LIST
81434: PUSH
81435: LD_INT 0
81437: PUSH
81438: LD_INT 3
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: PUSH
81445: LD_INT 1
81447: PUSH
81448: LD_INT 4
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: PUSH
81455: LD_INT 1
81457: PUSH
81458: LD_INT 5
81460: PUSH
81461: EMPTY
81462: LIST
81463: LIST
81464: PUSH
81465: LD_INT 0
81467: PUSH
81468: LD_INT 5
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: PUSH
81475: LD_INT 1
81477: NEG
81478: PUSH
81479: LD_INT 4
81481: PUSH
81482: EMPTY
81483: LIST
81484: LIST
81485: PUSH
81486: LD_INT 1
81488: NEG
81489: PUSH
81490: LD_INT 3
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: PUSH
81497: LD_INT 2
81499: PUSH
81500: LD_INT 5
81502: PUSH
81503: EMPTY
81504: LIST
81505: LIST
81506: PUSH
81507: LD_INT 2
81509: NEG
81510: PUSH
81511: LD_INT 3
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: LIST
81528: LIST
81529: LIST
81530: LIST
81531: LIST
81532: LIST
81533: LIST
81534: LIST
81535: LIST
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: LIST
81556: LIST
81557: LIST
81558: LIST
81559: LIST
81560: LIST
81561: LIST
81562: LIST
81563: LIST
81564: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
81565: LD_ADDR_VAR 0 34
81569: PUSH
81570: LD_INT 0
81572: PUSH
81573: LD_INT 4
81575: NEG
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: PUSH
81581: LD_INT 0
81583: PUSH
81584: LD_INT 5
81586: NEG
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: LD_INT 1
81594: PUSH
81595: LD_INT 4
81597: NEG
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: PUSH
81603: LD_INT 1
81605: PUSH
81606: LD_INT 3
81608: NEG
81609: PUSH
81610: EMPTY
81611: LIST
81612: LIST
81613: PUSH
81614: LD_INT 0
81616: PUSH
81617: LD_INT 3
81619: NEG
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: LD_INT 1
81627: NEG
81628: PUSH
81629: LD_INT 4
81631: NEG
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 1
81639: NEG
81640: PUSH
81641: LD_INT 5
81643: NEG
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 2
81651: PUSH
81652: LD_INT 3
81654: NEG
81655: PUSH
81656: EMPTY
81657: LIST
81658: LIST
81659: PUSH
81660: LD_INT 2
81662: NEG
81663: PUSH
81664: LD_INT 5
81666: NEG
81667: PUSH
81668: EMPTY
81669: LIST
81670: LIST
81671: PUSH
81672: LD_INT 3
81674: PUSH
81675: LD_INT 0
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 3
81684: PUSH
81685: LD_INT 1
81687: NEG
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: PUSH
81693: LD_INT 4
81695: PUSH
81696: LD_INT 0
81698: PUSH
81699: EMPTY
81700: LIST
81701: LIST
81702: PUSH
81703: LD_INT 4
81705: PUSH
81706: LD_INT 1
81708: PUSH
81709: EMPTY
81710: LIST
81711: LIST
81712: PUSH
81713: LD_INT 3
81715: PUSH
81716: LD_INT 1
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: PUSH
81723: LD_INT 2
81725: PUSH
81726: LD_INT 0
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: LD_INT 2
81735: PUSH
81736: LD_INT 1
81738: NEG
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: PUSH
81744: LD_INT 2
81746: PUSH
81747: LD_INT 2
81749: NEG
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 4
81757: PUSH
81758: LD_INT 2
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 4
81767: PUSH
81768: LD_INT 4
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 4
81777: PUSH
81778: LD_INT 3
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 5
81787: PUSH
81788: LD_INT 4
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 5
81797: PUSH
81798: LD_INT 5
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 4
81807: PUSH
81808: LD_INT 5
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 3
81817: PUSH
81818: LD_INT 4
81820: PUSH
81821: EMPTY
81822: LIST
81823: LIST
81824: PUSH
81825: LD_INT 3
81827: PUSH
81828: LD_INT 3
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 5
81837: PUSH
81838: LD_INT 3
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 3
81847: PUSH
81848: LD_INT 5
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 0
81857: PUSH
81858: LD_INT 3
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 0
81867: PUSH
81868: LD_INT 2
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 1
81877: PUSH
81878: LD_INT 3
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PUSH
81885: LD_INT 1
81887: PUSH
81888: LD_INT 4
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: PUSH
81895: LD_INT 0
81897: PUSH
81898: LD_INT 4
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: PUSH
81905: LD_INT 1
81907: NEG
81908: PUSH
81909: LD_INT 3
81911: PUSH
81912: EMPTY
81913: LIST
81914: LIST
81915: PUSH
81916: LD_INT 1
81918: NEG
81919: PUSH
81920: LD_INT 2
81922: PUSH
81923: EMPTY
81924: LIST
81925: LIST
81926: PUSH
81927: LD_INT 2
81929: PUSH
81930: LD_INT 4
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 2
81939: NEG
81940: PUSH
81941: LD_INT 2
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: PUSH
81948: LD_INT 4
81950: NEG
81951: PUSH
81952: LD_INT 0
81954: PUSH
81955: EMPTY
81956: LIST
81957: LIST
81958: PUSH
81959: LD_INT 4
81961: NEG
81962: PUSH
81963: LD_INT 1
81965: NEG
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: PUSH
81971: LD_INT 3
81973: NEG
81974: PUSH
81975: LD_INT 0
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: PUSH
81982: LD_INT 3
81984: NEG
81985: PUSH
81986: LD_INT 1
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: PUSH
81993: LD_INT 4
81995: NEG
81996: PUSH
81997: LD_INT 1
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 5
82006: NEG
82007: PUSH
82008: LD_INT 0
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 5
82017: NEG
82018: PUSH
82019: LD_INT 1
82021: NEG
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 5
82029: NEG
82030: PUSH
82031: LD_INT 2
82033: NEG
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 3
82041: NEG
82042: PUSH
82043: LD_INT 2
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: LIST
82054: LIST
82055: LIST
82056: LIST
82057: LIST
82058: LIST
82059: LIST
82060: LIST
82061: LIST
82062: LIST
82063: LIST
82064: LIST
82065: LIST
82066: LIST
82067: LIST
82068: LIST
82069: LIST
82070: LIST
82071: LIST
82072: LIST
82073: LIST
82074: LIST
82075: LIST
82076: LIST
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: LIST
82082: LIST
82083: LIST
82084: LIST
82085: LIST
82086: LIST
82087: LIST
82088: LIST
82089: LIST
82090: LIST
82091: LIST
82092: LIST
82093: LIST
82094: LIST
82095: LIST
82096: ST_TO_ADDR
// end ; end ;
82097: GO 82100
82099: POP
// case btype of b_depot , b_warehouse :
82100: LD_VAR 0 1
82104: PUSH
82105: LD_INT 0
82107: DOUBLE
82108: EQUAL
82109: IFTRUE 82119
82111: LD_INT 1
82113: DOUBLE
82114: EQUAL
82115: IFTRUE 82119
82117: GO 82320
82119: POP
// case nation of nation_american :
82120: LD_VAR 0 5
82124: PUSH
82125: LD_INT 1
82127: DOUBLE
82128: EQUAL
82129: IFTRUE 82133
82131: GO 82189
82133: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
82134: LD_ADDR_VAR 0 9
82138: PUSH
82139: LD_VAR 0 11
82143: PUSH
82144: LD_VAR 0 12
82148: PUSH
82149: LD_VAR 0 13
82153: PUSH
82154: LD_VAR 0 14
82158: PUSH
82159: LD_VAR 0 15
82163: PUSH
82164: LD_VAR 0 16
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: LIST
82176: PUSH
82177: LD_VAR 0 4
82181: PUSH
82182: LD_INT 1
82184: PLUS
82185: ARRAY
82186: ST_TO_ADDR
82187: GO 82318
82189: LD_INT 2
82191: DOUBLE
82192: EQUAL
82193: IFTRUE 82197
82195: GO 82253
82197: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
82198: LD_ADDR_VAR 0 9
82202: PUSH
82203: LD_VAR 0 17
82207: PUSH
82208: LD_VAR 0 18
82212: PUSH
82213: LD_VAR 0 19
82217: PUSH
82218: LD_VAR 0 20
82222: PUSH
82223: LD_VAR 0 21
82227: PUSH
82228: LD_VAR 0 22
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: PUSH
82241: LD_VAR 0 4
82245: PUSH
82246: LD_INT 1
82248: PLUS
82249: ARRAY
82250: ST_TO_ADDR
82251: GO 82318
82253: LD_INT 3
82255: DOUBLE
82256: EQUAL
82257: IFTRUE 82261
82259: GO 82317
82261: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
82262: LD_ADDR_VAR 0 9
82266: PUSH
82267: LD_VAR 0 23
82271: PUSH
82272: LD_VAR 0 24
82276: PUSH
82277: LD_VAR 0 25
82281: PUSH
82282: LD_VAR 0 26
82286: PUSH
82287: LD_VAR 0 27
82291: PUSH
82292: LD_VAR 0 28
82296: PUSH
82297: EMPTY
82298: LIST
82299: LIST
82300: LIST
82301: LIST
82302: LIST
82303: LIST
82304: PUSH
82305: LD_VAR 0 4
82309: PUSH
82310: LD_INT 1
82312: PLUS
82313: ARRAY
82314: ST_TO_ADDR
82315: GO 82318
82317: POP
82318: GO 82873
82320: LD_INT 2
82322: DOUBLE
82323: EQUAL
82324: IFTRUE 82334
82326: LD_INT 3
82328: DOUBLE
82329: EQUAL
82330: IFTRUE 82334
82332: GO 82390
82334: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
82335: LD_ADDR_VAR 0 9
82339: PUSH
82340: LD_VAR 0 29
82344: PUSH
82345: LD_VAR 0 30
82349: PUSH
82350: LD_VAR 0 31
82354: PUSH
82355: LD_VAR 0 32
82359: PUSH
82360: LD_VAR 0 33
82364: PUSH
82365: LD_VAR 0 34
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: PUSH
82378: LD_VAR 0 4
82382: PUSH
82383: LD_INT 1
82385: PLUS
82386: ARRAY
82387: ST_TO_ADDR
82388: GO 82873
82390: LD_INT 16
82392: DOUBLE
82393: EQUAL
82394: IFTRUE 82452
82396: LD_INT 17
82398: DOUBLE
82399: EQUAL
82400: IFTRUE 82452
82402: LD_INT 18
82404: DOUBLE
82405: EQUAL
82406: IFTRUE 82452
82408: LD_INT 19
82410: DOUBLE
82411: EQUAL
82412: IFTRUE 82452
82414: LD_INT 22
82416: DOUBLE
82417: EQUAL
82418: IFTRUE 82452
82420: LD_INT 20
82422: DOUBLE
82423: EQUAL
82424: IFTRUE 82452
82426: LD_INT 21
82428: DOUBLE
82429: EQUAL
82430: IFTRUE 82452
82432: LD_INT 23
82434: DOUBLE
82435: EQUAL
82436: IFTRUE 82452
82438: LD_INT 24
82440: DOUBLE
82441: EQUAL
82442: IFTRUE 82452
82444: LD_INT 25
82446: DOUBLE
82447: EQUAL
82448: IFTRUE 82452
82450: GO 82508
82452: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
82453: LD_ADDR_VAR 0 9
82457: PUSH
82458: LD_VAR 0 35
82462: PUSH
82463: LD_VAR 0 36
82467: PUSH
82468: LD_VAR 0 37
82472: PUSH
82473: LD_VAR 0 38
82477: PUSH
82478: LD_VAR 0 39
82482: PUSH
82483: LD_VAR 0 40
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: LIST
82492: LIST
82493: LIST
82494: LIST
82495: PUSH
82496: LD_VAR 0 4
82500: PUSH
82501: LD_INT 1
82503: PLUS
82504: ARRAY
82505: ST_TO_ADDR
82506: GO 82873
82508: LD_INT 6
82510: DOUBLE
82511: EQUAL
82512: IFTRUE 82564
82514: LD_INT 7
82516: DOUBLE
82517: EQUAL
82518: IFTRUE 82564
82520: LD_INT 8
82522: DOUBLE
82523: EQUAL
82524: IFTRUE 82564
82526: LD_INT 13
82528: DOUBLE
82529: EQUAL
82530: IFTRUE 82564
82532: LD_INT 12
82534: DOUBLE
82535: EQUAL
82536: IFTRUE 82564
82538: LD_INT 15
82540: DOUBLE
82541: EQUAL
82542: IFTRUE 82564
82544: LD_INT 11
82546: DOUBLE
82547: EQUAL
82548: IFTRUE 82564
82550: LD_INT 14
82552: DOUBLE
82553: EQUAL
82554: IFTRUE 82564
82556: LD_INT 10
82558: DOUBLE
82559: EQUAL
82560: IFTRUE 82564
82562: GO 82620
82564: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
82565: LD_ADDR_VAR 0 9
82569: PUSH
82570: LD_VAR 0 41
82574: PUSH
82575: LD_VAR 0 42
82579: PUSH
82580: LD_VAR 0 43
82584: PUSH
82585: LD_VAR 0 44
82589: PUSH
82590: LD_VAR 0 45
82594: PUSH
82595: LD_VAR 0 46
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: LIST
82604: LIST
82605: LIST
82606: LIST
82607: PUSH
82608: LD_VAR 0 4
82612: PUSH
82613: LD_INT 1
82615: PLUS
82616: ARRAY
82617: ST_TO_ADDR
82618: GO 82873
82620: LD_INT 36
82622: DOUBLE
82623: EQUAL
82624: IFTRUE 82628
82626: GO 82684
82628: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82629: LD_ADDR_VAR 0 9
82633: PUSH
82634: LD_VAR 0 47
82638: PUSH
82639: LD_VAR 0 48
82643: PUSH
82644: LD_VAR 0 49
82648: PUSH
82649: LD_VAR 0 50
82653: PUSH
82654: LD_VAR 0 51
82658: PUSH
82659: LD_VAR 0 52
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: LIST
82668: LIST
82669: LIST
82670: LIST
82671: PUSH
82672: LD_VAR 0 4
82676: PUSH
82677: LD_INT 1
82679: PLUS
82680: ARRAY
82681: ST_TO_ADDR
82682: GO 82873
82684: LD_INT 4
82686: DOUBLE
82687: EQUAL
82688: IFTRUE 82710
82690: LD_INT 5
82692: DOUBLE
82693: EQUAL
82694: IFTRUE 82710
82696: LD_INT 34
82698: DOUBLE
82699: EQUAL
82700: IFTRUE 82710
82702: LD_INT 37
82704: DOUBLE
82705: EQUAL
82706: IFTRUE 82710
82708: GO 82766
82710: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82711: LD_ADDR_VAR 0 9
82715: PUSH
82716: LD_VAR 0 53
82720: PUSH
82721: LD_VAR 0 54
82725: PUSH
82726: LD_VAR 0 55
82730: PUSH
82731: LD_VAR 0 56
82735: PUSH
82736: LD_VAR 0 57
82740: PUSH
82741: LD_VAR 0 58
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: LIST
82750: LIST
82751: LIST
82752: LIST
82753: PUSH
82754: LD_VAR 0 4
82758: PUSH
82759: LD_INT 1
82761: PLUS
82762: ARRAY
82763: ST_TO_ADDR
82764: GO 82873
82766: LD_INT 31
82768: DOUBLE
82769: EQUAL
82770: IFTRUE 82816
82772: LD_INT 32
82774: DOUBLE
82775: EQUAL
82776: IFTRUE 82816
82778: LD_INT 33
82780: DOUBLE
82781: EQUAL
82782: IFTRUE 82816
82784: LD_INT 27
82786: DOUBLE
82787: EQUAL
82788: IFTRUE 82816
82790: LD_INT 26
82792: DOUBLE
82793: EQUAL
82794: IFTRUE 82816
82796: LD_INT 28
82798: DOUBLE
82799: EQUAL
82800: IFTRUE 82816
82802: LD_INT 29
82804: DOUBLE
82805: EQUAL
82806: IFTRUE 82816
82808: LD_INT 30
82810: DOUBLE
82811: EQUAL
82812: IFTRUE 82816
82814: GO 82872
82816: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
82817: LD_ADDR_VAR 0 9
82821: PUSH
82822: LD_VAR 0 59
82826: PUSH
82827: LD_VAR 0 60
82831: PUSH
82832: LD_VAR 0 61
82836: PUSH
82837: LD_VAR 0 62
82841: PUSH
82842: LD_VAR 0 63
82846: PUSH
82847: LD_VAR 0 64
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: LIST
82858: LIST
82859: PUSH
82860: LD_VAR 0 4
82864: PUSH
82865: LD_INT 1
82867: PLUS
82868: ARRAY
82869: ST_TO_ADDR
82870: GO 82873
82872: POP
// temp_list2 = [ ] ;
82873: LD_ADDR_VAR 0 10
82877: PUSH
82878: EMPTY
82879: ST_TO_ADDR
// for i in temp_list do
82880: LD_ADDR_VAR 0 8
82884: PUSH
82885: LD_VAR 0 9
82889: PUSH
82890: FOR_IN
82891: IFFALSE 82943
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
82893: LD_ADDR_VAR 0 10
82897: PUSH
82898: LD_VAR 0 10
82902: PUSH
82903: LD_VAR 0 8
82907: PUSH
82908: LD_INT 1
82910: ARRAY
82911: PUSH
82912: LD_VAR 0 2
82916: PLUS
82917: PUSH
82918: LD_VAR 0 8
82922: PUSH
82923: LD_INT 2
82925: ARRAY
82926: PUSH
82927: LD_VAR 0 3
82931: PLUS
82932: PUSH
82933: EMPTY
82934: LIST
82935: LIST
82936: PUSH
82937: EMPTY
82938: LIST
82939: ADD
82940: ST_TO_ADDR
82941: GO 82890
82943: POP
82944: POP
// result = temp_list2 ;
82945: LD_ADDR_VAR 0 7
82949: PUSH
82950: LD_VAR 0 10
82954: ST_TO_ADDR
// end ;
82955: LD_VAR 0 7
82959: RET
// export function EnemyInRange ( unit , dist ) ; begin
82960: LD_INT 0
82962: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82963: LD_ADDR_VAR 0 3
82967: PUSH
82968: LD_VAR 0 1
82972: PPUSH
82973: CALL_OW 255
82977: PPUSH
82978: LD_VAR 0 1
82982: PPUSH
82983: CALL_OW 250
82987: PPUSH
82988: LD_VAR 0 1
82992: PPUSH
82993: CALL_OW 251
82997: PPUSH
82998: LD_VAR 0 2
83002: PPUSH
83003: CALL 56731 0 4
83007: PUSH
83008: LD_INT 4
83010: ARRAY
83011: ST_TO_ADDR
// end ;
83012: LD_VAR 0 3
83016: RET
// export function PlayerSeeMe ( unit ) ; begin
83017: LD_INT 0
83019: PPUSH
// result := See ( your_side , unit ) ;
83020: LD_ADDR_VAR 0 2
83024: PUSH
83025: LD_OWVAR 2
83029: PPUSH
83030: LD_VAR 0 1
83034: PPUSH
83035: CALL_OW 292
83039: ST_TO_ADDR
// end ;
83040: LD_VAR 0 2
83044: RET
// export function ReverseDir ( unit ) ; begin
83045: LD_INT 0
83047: PPUSH
// if not unit then
83048: LD_VAR 0 1
83052: NOT
83053: IFFALSE 83057
// exit ;
83055: GO 83080
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
83057: LD_ADDR_VAR 0 2
83061: PUSH
83062: LD_VAR 0 1
83066: PPUSH
83067: CALL_OW 254
83071: PUSH
83072: LD_INT 3
83074: PLUS
83075: PUSH
83076: LD_INT 6
83078: MOD
83079: ST_TO_ADDR
// end ;
83080: LD_VAR 0 2
83084: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
83085: LD_INT 0
83087: PPUSH
83088: PPUSH
83089: PPUSH
83090: PPUSH
83091: PPUSH
// if not hexes then
83092: LD_VAR 0 2
83096: NOT
83097: IFFALSE 83101
// exit ;
83099: GO 83249
// dist := 9999 ;
83101: LD_ADDR_VAR 0 5
83105: PUSH
83106: LD_INT 9999
83108: ST_TO_ADDR
// for i = 1 to hexes do
83109: LD_ADDR_VAR 0 4
83113: PUSH
83114: DOUBLE
83115: LD_INT 1
83117: DEC
83118: ST_TO_ADDR
83119: LD_VAR 0 2
83123: PUSH
83124: FOR_TO
83125: IFFALSE 83237
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
83127: LD_VAR 0 1
83131: PPUSH
83132: LD_VAR 0 2
83136: PUSH
83137: LD_VAR 0 4
83141: ARRAY
83142: PUSH
83143: LD_INT 1
83145: ARRAY
83146: PPUSH
83147: LD_VAR 0 2
83151: PUSH
83152: LD_VAR 0 4
83156: ARRAY
83157: PUSH
83158: LD_INT 2
83160: ARRAY
83161: PPUSH
83162: CALL_OW 297
83166: PUSH
83167: LD_VAR 0 5
83171: LESS
83172: IFFALSE 83235
// begin hex := hexes [ i ] ;
83174: LD_ADDR_VAR 0 7
83178: PUSH
83179: LD_VAR 0 2
83183: PUSH
83184: LD_VAR 0 4
83188: ARRAY
83189: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83190: LD_ADDR_VAR 0 5
83194: PUSH
83195: LD_VAR 0 1
83199: PPUSH
83200: LD_VAR 0 2
83204: PUSH
83205: LD_VAR 0 4
83209: ARRAY
83210: PUSH
83211: LD_INT 1
83213: ARRAY
83214: PPUSH
83215: LD_VAR 0 2
83219: PUSH
83220: LD_VAR 0 4
83224: ARRAY
83225: PUSH
83226: LD_INT 2
83228: ARRAY
83229: PPUSH
83230: CALL_OW 297
83234: ST_TO_ADDR
// end ; end ;
83235: GO 83124
83237: POP
83238: POP
// result := hex ;
83239: LD_ADDR_VAR 0 3
83243: PUSH
83244: LD_VAR 0 7
83248: ST_TO_ADDR
// end ;
83249: LD_VAR 0 3
83253: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
83254: LD_INT 0
83256: PPUSH
83257: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83258: LD_VAR 0 1
83262: NOT
83263: PUSH
83264: LD_VAR 0 1
83268: PUSH
83269: LD_INT 21
83271: PUSH
83272: LD_INT 2
83274: PUSH
83275: EMPTY
83276: LIST
83277: LIST
83278: PUSH
83279: LD_INT 23
83281: PUSH
83282: LD_INT 2
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PPUSH
83293: CALL_OW 69
83297: IN
83298: NOT
83299: OR
83300: IFFALSE 83304
// exit ;
83302: GO 83351
// for i = 1 to 3 do
83304: LD_ADDR_VAR 0 3
83308: PUSH
83309: DOUBLE
83310: LD_INT 1
83312: DEC
83313: ST_TO_ADDR
83314: LD_INT 3
83316: PUSH
83317: FOR_TO
83318: IFFALSE 83349
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
83320: LD_VAR 0 1
83324: PPUSH
83325: CALL_OW 250
83329: PPUSH
83330: LD_VAR 0 1
83334: PPUSH
83335: CALL_OW 251
83339: PPUSH
83340: LD_INT 1
83342: PPUSH
83343: CALL_OW 453
83347: GO 83317
83349: POP
83350: POP
// end ;
83351: LD_VAR 0 2
83355: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
83356: LD_INT 0
83358: PPUSH
83359: PPUSH
83360: PPUSH
83361: PPUSH
83362: PPUSH
83363: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
83364: LD_VAR 0 1
83368: NOT
83369: PUSH
83370: LD_VAR 0 2
83374: NOT
83375: OR
83376: PUSH
83377: LD_VAR 0 1
83381: PPUSH
83382: CALL_OW 314
83386: OR
83387: IFFALSE 83391
// exit ;
83389: GO 83832
// x := GetX ( enemy_unit ) ;
83391: LD_ADDR_VAR 0 7
83395: PUSH
83396: LD_VAR 0 2
83400: PPUSH
83401: CALL_OW 250
83405: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
83406: LD_ADDR_VAR 0 8
83410: PUSH
83411: LD_VAR 0 2
83415: PPUSH
83416: CALL_OW 251
83420: ST_TO_ADDR
// if not x or not y then
83421: LD_VAR 0 7
83425: NOT
83426: PUSH
83427: LD_VAR 0 8
83431: NOT
83432: OR
83433: IFFALSE 83437
// exit ;
83435: GO 83832
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
83437: LD_ADDR_VAR 0 6
83441: PUSH
83442: LD_VAR 0 7
83446: PPUSH
83447: LD_INT 0
83449: PPUSH
83450: LD_INT 4
83452: PPUSH
83453: CALL_OW 272
83457: PUSH
83458: LD_VAR 0 8
83462: PPUSH
83463: LD_INT 0
83465: PPUSH
83466: LD_INT 4
83468: PPUSH
83469: CALL_OW 273
83473: PUSH
83474: EMPTY
83475: LIST
83476: LIST
83477: PUSH
83478: LD_VAR 0 7
83482: PPUSH
83483: LD_INT 1
83485: PPUSH
83486: LD_INT 4
83488: PPUSH
83489: CALL_OW 272
83493: PUSH
83494: LD_VAR 0 8
83498: PPUSH
83499: LD_INT 1
83501: PPUSH
83502: LD_INT 4
83504: PPUSH
83505: CALL_OW 273
83509: PUSH
83510: EMPTY
83511: LIST
83512: LIST
83513: PUSH
83514: LD_VAR 0 7
83518: PPUSH
83519: LD_INT 2
83521: PPUSH
83522: LD_INT 4
83524: PPUSH
83525: CALL_OW 272
83529: PUSH
83530: LD_VAR 0 8
83534: PPUSH
83535: LD_INT 2
83537: PPUSH
83538: LD_INT 4
83540: PPUSH
83541: CALL_OW 273
83545: PUSH
83546: EMPTY
83547: LIST
83548: LIST
83549: PUSH
83550: LD_VAR 0 7
83554: PPUSH
83555: LD_INT 3
83557: PPUSH
83558: LD_INT 4
83560: PPUSH
83561: CALL_OW 272
83565: PUSH
83566: LD_VAR 0 8
83570: PPUSH
83571: LD_INT 3
83573: PPUSH
83574: LD_INT 4
83576: PPUSH
83577: CALL_OW 273
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: PUSH
83586: LD_VAR 0 7
83590: PPUSH
83591: LD_INT 4
83593: PPUSH
83594: LD_INT 4
83596: PPUSH
83597: CALL_OW 272
83601: PUSH
83602: LD_VAR 0 8
83606: PPUSH
83607: LD_INT 4
83609: PPUSH
83610: LD_INT 4
83612: PPUSH
83613: CALL_OW 273
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PUSH
83622: LD_VAR 0 7
83626: PPUSH
83627: LD_INT 5
83629: PPUSH
83630: LD_INT 4
83632: PPUSH
83633: CALL_OW 272
83637: PUSH
83638: LD_VAR 0 8
83642: PPUSH
83643: LD_INT 5
83645: PPUSH
83646: LD_INT 4
83648: PPUSH
83649: CALL_OW 273
83653: PUSH
83654: EMPTY
83655: LIST
83656: LIST
83657: PUSH
83658: EMPTY
83659: LIST
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: ST_TO_ADDR
// for i = tmp downto 1 do
83666: LD_ADDR_VAR 0 4
83670: PUSH
83671: DOUBLE
83672: LD_VAR 0 6
83676: INC
83677: ST_TO_ADDR
83678: LD_INT 1
83680: PUSH
83681: FOR_DOWNTO
83682: IFFALSE 83783
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83684: LD_VAR 0 6
83688: PUSH
83689: LD_VAR 0 4
83693: ARRAY
83694: PUSH
83695: LD_INT 1
83697: ARRAY
83698: PPUSH
83699: LD_VAR 0 6
83703: PUSH
83704: LD_VAR 0 4
83708: ARRAY
83709: PUSH
83710: LD_INT 2
83712: ARRAY
83713: PPUSH
83714: CALL_OW 488
83718: NOT
83719: PUSH
83720: LD_VAR 0 6
83724: PUSH
83725: LD_VAR 0 4
83729: ARRAY
83730: PUSH
83731: LD_INT 1
83733: ARRAY
83734: PPUSH
83735: LD_VAR 0 6
83739: PUSH
83740: LD_VAR 0 4
83744: ARRAY
83745: PUSH
83746: LD_INT 2
83748: ARRAY
83749: PPUSH
83750: CALL_OW 428
83754: PUSH
83755: LD_INT 0
83757: NONEQUAL
83758: OR
83759: IFFALSE 83781
// tmp := Delete ( tmp , i ) ;
83761: LD_ADDR_VAR 0 6
83765: PUSH
83766: LD_VAR 0 6
83770: PPUSH
83771: LD_VAR 0 4
83775: PPUSH
83776: CALL_OW 3
83780: ST_TO_ADDR
83781: GO 83681
83783: POP
83784: POP
// j := GetClosestHex ( unit , tmp ) ;
83785: LD_ADDR_VAR 0 5
83789: PUSH
83790: LD_VAR 0 1
83794: PPUSH
83795: LD_VAR 0 6
83799: PPUSH
83800: CALL 83085 0 2
83804: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83805: LD_VAR 0 1
83809: PPUSH
83810: LD_VAR 0 5
83814: PUSH
83815: LD_INT 1
83817: ARRAY
83818: PPUSH
83819: LD_VAR 0 5
83823: PUSH
83824: LD_INT 2
83826: ARRAY
83827: PPUSH
83828: CALL_OW 111
// end ;
83832: LD_VAR 0 3
83836: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83837: LD_INT 0
83839: PPUSH
83840: PPUSH
83841: PPUSH
// uc_side = 0 ;
83842: LD_ADDR_OWVAR 20
83846: PUSH
83847: LD_INT 0
83849: ST_TO_ADDR
// uc_nation = 0 ;
83850: LD_ADDR_OWVAR 21
83854: PUSH
83855: LD_INT 0
83857: ST_TO_ADDR
// InitHc_All ( ) ;
83858: CALL_OW 584
// InitVc ;
83862: CALL_OW 20
// if mastodonts then
83866: LD_VAR 0 6
83870: IFFALSE 83937
// for i = 1 to mastodonts do
83872: LD_ADDR_VAR 0 11
83876: PUSH
83877: DOUBLE
83878: LD_INT 1
83880: DEC
83881: ST_TO_ADDR
83882: LD_VAR 0 6
83886: PUSH
83887: FOR_TO
83888: IFFALSE 83935
// begin vc_chassis := 31 ;
83890: LD_ADDR_OWVAR 37
83894: PUSH
83895: LD_INT 31
83897: ST_TO_ADDR
// vc_control := control_rider ;
83898: LD_ADDR_OWVAR 38
83902: PUSH
83903: LD_INT 4
83905: ST_TO_ADDR
// animal := CreateVehicle ;
83906: LD_ADDR_VAR 0 12
83910: PUSH
83911: CALL_OW 45
83915: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83916: LD_VAR 0 12
83920: PPUSH
83921: LD_VAR 0 8
83925: PPUSH
83926: LD_INT 0
83928: PPUSH
83929: CALL 86125 0 3
// end ;
83933: GO 83887
83935: POP
83936: POP
// if horses then
83937: LD_VAR 0 5
83941: IFFALSE 84008
// for i = 1 to horses do
83943: LD_ADDR_VAR 0 11
83947: PUSH
83948: DOUBLE
83949: LD_INT 1
83951: DEC
83952: ST_TO_ADDR
83953: LD_VAR 0 5
83957: PUSH
83958: FOR_TO
83959: IFFALSE 84006
// begin hc_class := 21 ;
83961: LD_ADDR_OWVAR 28
83965: PUSH
83966: LD_INT 21
83968: ST_TO_ADDR
// hc_gallery :=  ;
83969: LD_ADDR_OWVAR 33
83973: PUSH
83974: LD_STRING 
83976: ST_TO_ADDR
// animal := CreateHuman ;
83977: LD_ADDR_VAR 0 12
83981: PUSH
83982: CALL_OW 44
83986: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83987: LD_VAR 0 12
83991: PPUSH
83992: LD_VAR 0 8
83996: PPUSH
83997: LD_INT 0
83999: PPUSH
84000: CALL 86125 0 3
// end ;
84004: GO 83958
84006: POP
84007: POP
// if birds then
84008: LD_VAR 0 1
84012: IFFALSE 84079
// for i = 1 to birds do
84014: LD_ADDR_VAR 0 11
84018: PUSH
84019: DOUBLE
84020: LD_INT 1
84022: DEC
84023: ST_TO_ADDR
84024: LD_VAR 0 1
84028: PUSH
84029: FOR_TO
84030: IFFALSE 84077
// begin hc_class = 18 ;
84032: LD_ADDR_OWVAR 28
84036: PUSH
84037: LD_INT 18
84039: ST_TO_ADDR
// hc_gallery =  ;
84040: LD_ADDR_OWVAR 33
84044: PUSH
84045: LD_STRING 
84047: ST_TO_ADDR
// animal := CreateHuman ;
84048: LD_ADDR_VAR 0 12
84052: PUSH
84053: CALL_OW 44
84057: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84058: LD_VAR 0 12
84062: PPUSH
84063: LD_VAR 0 8
84067: PPUSH
84068: LD_INT 0
84070: PPUSH
84071: CALL 86125 0 3
// end ;
84075: GO 84029
84077: POP
84078: POP
// if tigers then
84079: LD_VAR 0 2
84083: IFFALSE 84167
// for i = 1 to tigers do
84085: LD_ADDR_VAR 0 11
84089: PUSH
84090: DOUBLE
84091: LD_INT 1
84093: DEC
84094: ST_TO_ADDR
84095: LD_VAR 0 2
84099: PUSH
84100: FOR_TO
84101: IFFALSE 84165
// begin hc_class = class_tiger ;
84103: LD_ADDR_OWVAR 28
84107: PUSH
84108: LD_INT 14
84110: ST_TO_ADDR
// hc_gallery =  ;
84111: LD_ADDR_OWVAR 33
84115: PUSH
84116: LD_STRING 
84118: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84119: LD_ADDR_OWVAR 35
84123: PUSH
84124: LD_INT 7
84126: NEG
84127: PPUSH
84128: LD_INT 7
84130: PPUSH
84131: CALL_OW 12
84135: ST_TO_ADDR
// animal := CreateHuman ;
84136: LD_ADDR_VAR 0 12
84140: PUSH
84141: CALL_OW 44
84145: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84146: LD_VAR 0 12
84150: PPUSH
84151: LD_VAR 0 8
84155: PPUSH
84156: LD_INT 0
84158: PPUSH
84159: CALL 86125 0 3
// end ;
84163: GO 84100
84165: POP
84166: POP
// if apemans then
84167: LD_VAR 0 3
84171: IFFALSE 84294
// for i = 1 to apemans do
84173: LD_ADDR_VAR 0 11
84177: PUSH
84178: DOUBLE
84179: LD_INT 1
84181: DEC
84182: ST_TO_ADDR
84183: LD_VAR 0 3
84187: PUSH
84188: FOR_TO
84189: IFFALSE 84292
// begin hc_class = class_apeman ;
84191: LD_ADDR_OWVAR 28
84195: PUSH
84196: LD_INT 12
84198: ST_TO_ADDR
// hc_gallery =  ;
84199: LD_ADDR_OWVAR 33
84203: PUSH
84204: LD_STRING 
84206: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
84207: LD_ADDR_OWVAR 35
84211: PUSH
84212: LD_INT 5
84214: NEG
84215: PPUSH
84216: LD_INT 5
84218: PPUSH
84219: CALL_OW 12
84223: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
84224: LD_ADDR_OWVAR 31
84228: PUSH
84229: LD_INT 1
84231: PPUSH
84232: LD_INT 3
84234: PPUSH
84235: CALL_OW 12
84239: PUSH
84240: LD_INT 1
84242: PPUSH
84243: LD_INT 3
84245: PPUSH
84246: CALL_OW 12
84250: PUSH
84251: LD_INT 0
84253: PUSH
84254: LD_INT 0
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: LIST
84261: LIST
84262: ST_TO_ADDR
// animal := CreateHuman ;
84263: LD_ADDR_VAR 0 12
84267: PUSH
84268: CALL_OW 44
84272: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84273: LD_VAR 0 12
84277: PPUSH
84278: LD_VAR 0 8
84282: PPUSH
84283: LD_INT 0
84285: PPUSH
84286: CALL 86125 0 3
// end ;
84290: GO 84188
84292: POP
84293: POP
// if enchidnas then
84294: LD_VAR 0 4
84298: IFFALSE 84365
// for i = 1 to enchidnas do
84300: LD_ADDR_VAR 0 11
84304: PUSH
84305: DOUBLE
84306: LD_INT 1
84308: DEC
84309: ST_TO_ADDR
84310: LD_VAR 0 4
84314: PUSH
84315: FOR_TO
84316: IFFALSE 84363
// begin hc_class = 13 ;
84318: LD_ADDR_OWVAR 28
84322: PUSH
84323: LD_INT 13
84325: ST_TO_ADDR
// hc_gallery =  ;
84326: LD_ADDR_OWVAR 33
84330: PUSH
84331: LD_STRING 
84333: ST_TO_ADDR
// animal := CreateHuman ;
84334: LD_ADDR_VAR 0 12
84338: PUSH
84339: CALL_OW 44
84343: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84344: LD_VAR 0 12
84348: PPUSH
84349: LD_VAR 0 8
84353: PPUSH
84354: LD_INT 0
84356: PPUSH
84357: CALL 86125 0 3
// end ;
84361: GO 84315
84363: POP
84364: POP
// if fishes then
84365: LD_VAR 0 7
84369: IFFALSE 84436
// for i = 1 to fishes do
84371: LD_ADDR_VAR 0 11
84375: PUSH
84376: DOUBLE
84377: LD_INT 1
84379: DEC
84380: ST_TO_ADDR
84381: LD_VAR 0 7
84385: PUSH
84386: FOR_TO
84387: IFFALSE 84434
// begin hc_class = 20 ;
84389: LD_ADDR_OWVAR 28
84393: PUSH
84394: LD_INT 20
84396: ST_TO_ADDR
// hc_gallery =  ;
84397: LD_ADDR_OWVAR 33
84401: PUSH
84402: LD_STRING 
84404: ST_TO_ADDR
// animal := CreateHuman ;
84405: LD_ADDR_VAR 0 12
84409: PUSH
84410: CALL_OW 44
84414: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84415: LD_VAR 0 12
84419: PPUSH
84420: LD_VAR 0 9
84424: PPUSH
84425: LD_INT 0
84427: PPUSH
84428: CALL 86125 0 3
// end ;
84432: GO 84386
84434: POP
84435: POP
// end ;
84436: LD_VAR 0 10
84440: RET
// export function WantHeal ( sci , unit ) ; begin
84441: LD_INT 0
84443: PPUSH
// if GetTaskList ( sci ) > 0 then
84444: LD_VAR 0 1
84448: PPUSH
84449: CALL_OW 437
84453: PUSH
84454: LD_INT 0
84456: GREATER
84457: IFFALSE 84527
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84459: LD_VAR 0 1
84463: PPUSH
84464: CALL_OW 437
84468: PUSH
84469: LD_INT 1
84471: ARRAY
84472: PUSH
84473: LD_INT 1
84475: ARRAY
84476: PUSH
84477: LD_STRING l
84479: EQUAL
84480: PUSH
84481: LD_VAR 0 1
84485: PPUSH
84486: CALL_OW 437
84490: PUSH
84491: LD_INT 1
84493: ARRAY
84494: PUSH
84495: LD_INT 4
84497: ARRAY
84498: PUSH
84499: LD_VAR 0 2
84503: EQUAL
84504: AND
84505: IFFALSE 84517
// result := true else
84507: LD_ADDR_VAR 0 3
84511: PUSH
84512: LD_INT 1
84514: ST_TO_ADDR
84515: GO 84525
// result := false ;
84517: LD_ADDR_VAR 0 3
84521: PUSH
84522: LD_INT 0
84524: ST_TO_ADDR
// end else
84525: GO 84535
// result := false ;
84527: LD_ADDR_VAR 0 3
84531: PUSH
84532: LD_INT 0
84534: ST_TO_ADDR
// end ;
84535: LD_VAR 0 3
84539: RET
// export function HealTarget ( sci ) ; begin
84540: LD_INT 0
84542: PPUSH
// if not sci then
84543: LD_VAR 0 1
84547: NOT
84548: IFFALSE 84552
// exit ;
84550: GO 84617
// result := 0 ;
84552: LD_ADDR_VAR 0 2
84556: PUSH
84557: LD_INT 0
84559: ST_TO_ADDR
// if GetTaskList ( sci ) then
84560: LD_VAR 0 1
84564: PPUSH
84565: CALL_OW 437
84569: IFFALSE 84617
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84571: LD_VAR 0 1
84575: PPUSH
84576: CALL_OW 437
84580: PUSH
84581: LD_INT 1
84583: ARRAY
84584: PUSH
84585: LD_INT 1
84587: ARRAY
84588: PUSH
84589: LD_STRING l
84591: EQUAL
84592: IFFALSE 84617
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84594: LD_ADDR_VAR 0 2
84598: PUSH
84599: LD_VAR 0 1
84603: PPUSH
84604: CALL_OW 437
84608: PUSH
84609: LD_INT 1
84611: ARRAY
84612: PUSH
84613: LD_INT 4
84615: ARRAY
84616: ST_TO_ADDR
// end ;
84617: LD_VAR 0 2
84621: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84622: LD_INT 0
84624: PPUSH
84625: PPUSH
84626: PPUSH
84627: PPUSH
// if not base_units then
84628: LD_VAR 0 1
84632: NOT
84633: IFFALSE 84637
// exit ;
84635: GO 84724
// result := false ;
84637: LD_ADDR_VAR 0 2
84641: PUSH
84642: LD_INT 0
84644: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84645: LD_ADDR_VAR 0 5
84649: PUSH
84650: LD_VAR 0 1
84654: PPUSH
84655: LD_INT 21
84657: PUSH
84658: LD_INT 3
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: PPUSH
84665: CALL_OW 72
84669: ST_TO_ADDR
// if not tmp then
84670: LD_VAR 0 5
84674: NOT
84675: IFFALSE 84679
// exit ;
84677: GO 84724
// for i in tmp do
84679: LD_ADDR_VAR 0 3
84683: PUSH
84684: LD_VAR 0 5
84688: PUSH
84689: FOR_IN
84690: IFFALSE 84722
// begin result := EnemyInRange ( i , 22 ) ;
84692: LD_ADDR_VAR 0 2
84696: PUSH
84697: LD_VAR 0 3
84701: PPUSH
84702: LD_INT 22
84704: PPUSH
84705: CALL 82960 0 2
84709: ST_TO_ADDR
// if result then
84710: LD_VAR 0 2
84714: IFFALSE 84720
// exit ;
84716: POP
84717: POP
84718: GO 84724
// end ;
84720: GO 84689
84722: POP
84723: POP
// end ;
84724: LD_VAR 0 2
84728: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
84729: LD_INT 0
84731: PPUSH
84732: PPUSH
// if not units then
84733: LD_VAR 0 1
84737: NOT
84738: IFFALSE 84742
// exit ;
84740: GO 84812
// result := [ ] ;
84742: LD_ADDR_VAR 0 3
84746: PUSH
84747: EMPTY
84748: ST_TO_ADDR
// for i in units do
84749: LD_ADDR_VAR 0 4
84753: PUSH
84754: LD_VAR 0 1
84758: PUSH
84759: FOR_IN
84760: IFFALSE 84810
// if GetTag ( i ) = tag then
84762: LD_VAR 0 4
84766: PPUSH
84767: CALL_OW 110
84771: PUSH
84772: LD_VAR 0 2
84776: EQUAL
84777: IFFALSE 84808
// result := Insert ( result , result + 1 , i ) ;
84779: LD_ADDR_VAR 0 3
84783: PUSH
84784: LD_VAR 0 3
84788: PPUSH
84789: LD_VAR 0 3
84793: PUSH
84794: LD_INT 1
84796: PLUS
84797: PPUSH
84798: LD_VAR 0 4
84802: PPUSH
84803: CALL_OW 2
84807: ST_TO_ADDR
84808: GO 84759
84810: POP
84811: POP
// end ;
84812: LD_VAR 0 3
84816: RET
// export function IsDriver ( un ) ; begin
84817: LD_INT 0
84819: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84820: LD_ADDR_VAR 0 2
84824: PUSH
84825: LD_VAR 0 1
84829: PUSH
84830: LD_INT 55
84832: PUSH
84833: EMPTY
84834: LIST
84835: PPUSH
84836: CALL_OW 69
84840: IN
84841: ST_TO_ADDR
// end ;
84842: LD_VAR 0 2
84846: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84847: LD_INT 0
84849: PPUSH
84850: PPUSH
// list := [ ] ;
84851: LD_ADDR_VAR 0 5
84855: PUSH
84856: EMPTY
84857: ST_TO_ADDR
// case d of 0 :
84858: LD_VAR 0 3
84862: PUSH
84863: LD_INT 0
84865: DOUBLE
84866: EQUAL
84867: IFTRUE 84871
84869: GO 85004
84871: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84872: LD_ADDR_VAR 0 5
84876: PUSH
84877: LD_VAR 0 1
84881: PUSH
84882: LD_INT 4
84884: MINUS
84885: PUSH
84886: LD_VAR 0 2
84890: PUSH
84891: LD_INT 4
84893: MINUS
84894: PUSH
84895: LD_INT 2
84897: PUSH
84898: EMPTY
84899: LIST
84900: LIST
84901: LIST
84902: PUSH
84903: LD_VAR 0 1
84907: PUSH
84908: LD_INT 3
84910: MINUS
84911: PUSH
84912: LD_VAR 0 2
84916: PUSH
84917: LD_INT 1
84919: PUSH
84920: EMPTY
84921: LIST
84922: LIST
84923: LIST
84924: PUSH
84925: LD_VAR 0 1
84929: PUSH
84930: LD_INT 4
84932: PLUS
84933: PUSH
84934: LD_VAR 0 2
84938: PUSH
84939: LD_INT 4
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: LIST
84946: PUSH
84947: LD_VAR 0 1
84951: PUSH
84952: LD_INT 3
84954: PLUS
84955: PUSH
84956: LD_VAR 0 2
84960: PUSH
84961: LD_INT 3
84963: PLUS
84964: PUSH
84965: LD_INT 5
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: LIST
84972: PUSH
84973: LD_VAR 0 1
84977: PUSH
84978: LD_VAR 0 2
84982: PUSH
84983: LD_INT 4
84985: PLUS
84986: PUSH
84987: LD_INT 0
84989: PUSH
84990: EMPTY
84991: LIST
84992: LIST
84993: LIST
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: LIST
84999: LIST
85000: LIST
85001: ST_TO_ADDR
// end ; 1 :
85002: GO 85702
85004: LD_INT 1
85006: DOUBLE
85007: EQUAL
85008: IFTRUE 85012
85010: GO 85145
85012: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
85013: LD_ADDR_VAR 0 5
85017: PUSH
85018: LD_VAR 0 1
85022: PUSH
85023: LD_VAR 0 2
85027: PUSH
85028: LD_INT 4
85030: MINUS
85031: PUSH
85032: LD_INT 3
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: LIST
85039: PUSH
85040: LD_VAR 0 1
85044: PUSH
85045: LD_INT 3
85047: MINUS
85048: PUSH
85049: LD_VAR 0 2
85053: PUSH
85054: LD_INT 3
85056: MINUS
85057: PUSH
85058: LD_INT 2
85060: PUSH
85061: EMPTY
85062: LIST
85063: LIST
85064: LIST
85065: PUSH
85066: LD_VAR 0 1
85070: PUSH
85071: LD_INT 4
85073: MINUS
85074: PUSH
85075: LD_VAR 0 2
85079: PUSH
85080: LD_INT 1
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: LIST
85087: PUSH
85088: LD_VAR 0 1
85092: PUSH
85093: LD_VAR 0 2
85097: PUSH
85098: LD_INT 3
85100: PLUS
85101: PUSH
85102: LD_INT 0
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: LIST
85109: PUSH
85110: LD_VAR 0 1
85114: PUSH
85115: LD_INT 4
85117: PLUS
85118: PUSH
85119: LD_VAR 0 2
85123: PUSH
85124: LD_INT 4
85126: PLUS
85127: PUSH
85128: LD_INT 5
85130: PUSH
85131: EMPTY
85132: LIST
85133: LIST
85134: LIST
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: LIST
85140: LIST
85141: LIST
85142: ST_TO_ADDR
// end ; 2 :
85143: GO 85702
85145: LD_INT 2
85147: DOUBLE
85148: EQUAL
85149: IFTRUE 85153
85151: GO 85282
85153: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
85154: LD_ADDR_VAR 0 5
85158: PUSH
85159: LD_VAR 0 1
85163: PUSH
85164: LD_VAR 0 2
85168: PUSH
85169: LD_INT 3
85171: MINUS
85172: PUSH
85173: LD_INT 3
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: LIST
85180: PUSH
85181: LD_VAR 0 1
85185: PUSH
85186: LD_INT 4
85188: PLUS
85189: PUSH
85190: LD_VAR 0 2
85194: PUSH
85195: LD_INT 4
85197: PUSH
85198: EMPTY
85199: LIST
85200: LIST
85201: LIST
85202: PUSH
85203: LD_VAR 0 1
85207: PUSH
85208: LD_VAR 0 2
85212: PUSH
85213: LD_INT 4
85215: PLUS
85216: PUSH
85217: LD_INT 0
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: LIST
85224: PUSH
85225: LD_VAR 0 1
85229: PUSH
85230: LD_INT 3
85232: MINUS
85233: PUSH
85234: LD_VAR 0 2
85238: PUSH
85239: LD_INT 1
85241: PUSH
85242: EMPTY
85243: LIST
85244: LIST
85245: LIST
85246: PUSH
85247: LD_VAR 0 1
85251: PUSH
85252: LD_INT 4
85254: MINUS
85255: PUSH
85256: LD_VAR 0 2
85260: PUSH
85261: LD_INT 4
85263: MINUS
85264: PUSH
85265: LD_INT 2
85267: PUSH
85268: EMPTY
85269: LIST
85270: LIST
85271: LIST
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: LIST
85277: LIST
85278: LIST
85279: ST_TO_ADDR
// end ; 3 :
85280: GO 85702
85282: LD_INT 3
85284: DOUBLE
85285: EQUAL
85286: IFTRUE 85290
85288: GO 85423
85290: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
85291: LD_ADDR_VAR 0 5
85295: PUSH
85296: LD_VAR 0 1
85300: PUSH
85301: LD_INT 3
85303: PLUS
85304: PUSH
85305: LD_VAR 0 2
85309: PUSH
85310: LD_INT 4
85312: PUSH
85313: EMPTY
85314: LIST
85315: LIST
85316: LIST
85317: PUSH
85318: LD_VAR 0 1
85322: PUSH
85323: LD_INT 4
85325: PLUS
85326: PUSH
85327: LD_VAR 0 2
85331: PUSH
85332: LD_INT 4
85334: PLUS
85335: PUSH
85336: LD_INT 5
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: LIST
85343: PUSH
85344: LD_VAR 0 1
85348: PUSH
85349: LD_INT 4
85351: MINUS
85352: PUSH
85353: LD_VAR 0 2
85357: PUSH
85358: LD_INT 1
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: LIST
85365: PUSH
85366: LD_VAR 0 1
85370: PUSH
85371: LD_VAR 0 2
85375: PUSH
85376: LD_INT 4
85378: MINUS
85379: PUSH
85380: LD_INT 3
85382: PUSH
85383: EMPTY
85384: LIST
85385: LIST
85386: LIST
85387: PUSH
85388: LD_VAR 0 1
85392: PUSH
85393: LD_INT 3
85395: MINUS
85396: PUSH
85397: LD_VAR 0 2
85401: PUSH
85402: LD_INT 3
85404: MINUS
85405: PUSH
85406: LD_INT 2
85408: PUSH
85409: EMPTY
85410: LIST
85411: LIST
85412: LIST
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: LIST
85418: LIST
85419: LIST
85420: ST_TO_ADDR
// end ; 4 :
85421: GO 85702
85423: LD_INT 4
85425: DOUBLE
85426: EQUAL
85427: IFTRUE 85431
85429: GO 85564
85431: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
85432: LD_ADDR_VAR 0 5
85436: PUSH
85437: LD_VAR 0 1
85441: PUSH
85442: LD_VAR 0 2
85446: PUSH
85447: LD_INT 4
85449: PLUS
85450: PUSH
85451: LD_INT 0
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: LIST
85458: PUSH
85459: LD_VAR 0 1
85463: PUSH
85464: LD_INT 3
85466: PLUS
85467: PUSH
85468: LD_VAR 0 2
85472: PUSH
85473: LD_INT 3
85475: PLUS
85476: PUSH
85477: LD_INT 5
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: LIST
85484: PUSH
85485: LD_VAR 0 1
85489: PUSH
85490: LD_INT 4
85492: PLUS
85493: PUSH
85494: LD_VAR 0 2
85498: PUSH
85499: LD_INT 4
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: LIST
85506: PUSH
85507: LD_VAR 0 1
85511: PUSH
85512: LD_VAR 0 2
85516: PUSH
85517: LD_INT 3
85519: MINUS
85520: PUSH
85521: LD_INT 3
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: LIST
85528: PUSH
85529: LD_VAR 0 1
85533: PUSH
85534: LD_INT 4
85536: MINUS
85537: PUSH
85538: LD_VAR 0 2
85542: PUSH
85543: LD_INT 4
85545: MINUS
85546: PUSH
85547: LD_INT 2
85549: PUSH
85550: EMPTY
85551: LIST
85552: LIST
85553: LIST
85554: PUSH
85555: EMPTY
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: ST_TO_ADDR
// end ; 5 :
85562: GO 85702
85564: LD_INT 5
85566: DOUBLE
85567: EQUAL
85568: IFTRUE 85572
85570: GO 85701
85572: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85573: LD_ADDR_VAR 0 5
85577: PUSH
85578: LD_VAR 0 1
85582: PUSH
85583: LD_INT 4
85585: MINUS
85586: PUSH
85587: LD_VAR 0 2
85591: PUSH
85592: LD_INT 1
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: LIST
85599: PUSH
85600: LD_VAR 0 1
85604: PUSH
85605: LD_VAR 0 2
85609: PUSH
85610: LD_INT 4
85612: MINUS
85613: PUSH
85614: LD_INT 3
85616: PUSH
85617: EMPTY
85618: LIST
85619: LIST
85620: LIST
85621: PUSH
85622: LD_VAR 0 1
85626: PUSH
85627: LD_INT 4
85629: PLUS
85630: PUSH
85631: LD_VAR 0 2
85635: PUSH
85636: LD_INT 4
85638: PLUS
85639: PUSH
85640: LD_INT 5
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: LIST
85647: PUSH
85648: LD_VAR 0 1
85652: PUSH
85653: LD_INT 3
85655: PLUS
85656: PUSH
85657: LD_VAR 0 2
85661: PUSH
85662: LD_INT 4
85664: PUSH
85665: EMPTY
85666: LIST
85667: LIST
85668: LIST
85669: PUSH
85670: LD_VAR 0 1
85674: PUSH
85675: LD_VAR 0 2
85679: PUSH
85680: LD_INT 3
85682: PLUS
85683: PUSH
85684: LD_INT 0
85686: PUSH
85687: EMPTY
85688: LIST
85689: LIST
85690: LIST
85691: PUSH
85692: EMPTY
85693: LIST
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: ST_TO_ADDR
// end ; end ;
85699: GO 85702
85701: POP
// result := list ;
85702: LD_ADDR_VAR 0 4
85706: PUSH
85707: LD_VAR 0 5
85711: ST_TO_ADDR
// end ;
85712: LD_VAR 0 4
85716: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85717: LD_INT 0
85719: PPUSH
85720: PPUSH
85721: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85722: LD_VAR 0 1
85726: NOT
85727: PUSH
85728: LD_VAR 0 2
85732: PUSH
85733: LD_INT 1
85735: PUSH
85736: LD_INT 2
85738: PUSH
85739: LD_INT 3
85741: PUSH
85742: LD_INT 4
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: IN
85751: NOT
85752: OR
85753: IFFALSE 85757
// exit ;
85755: GO 85849
// tmp := [ ] ;
85757: LD_ADDR_VAR 0 5
85761: PUSH
85762: EMPTY
85763: ST_TO_ADDR
// for i in units do
85764: LD_ADDR_VAR 0 4
85768: PUSH
85769: LD_VAR 0 1
85773: PUSH
85774: FOR_IN
85775: IFFALSE 85818
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
85777: LD_ADDR_VAR 0 5
85781: PUSH
85782: LD_VAR 0 5
85786: PPUSH
85787: LD_VAR 0 5
85791: PUSH
85792: LD_INT 1
85794: PLUS
85795: PPUSH
85796: LD_VAR 0 4
85800: PPUSH
85801: LD_VAR 0 2
85805: PPUSH
85806: CALL_OW 259
85810: PPUSH
85811: CALL_OW 2
85815: ST_TO_ADDR
85816: GO 85774
85818: POP
85819: POP
// if not tmp then
85820: LD_VAR 0 5
85824: NOT
85825: IFFALSE 85829
// exit ;
85827: GO 85849
// result := SortListByListDesc ( units , tmp ) ;
85829: LD_ADDR_VAR 0 3
85833: PUSH
85834: LD_VAR 0 1
85838: PPUSH
85839: LD_VAR 0 5
85843: PPUSH
85844: CALL_OW 77
85848: ST_TO_ADDR
// end ;
85849: LD_VAR 0 3
85853: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85854: LD_INT 0
85856: PPUSH
85857: PPUSH
85858: PPUSH
// result := false ;
85859: LD_ADDR_VAR 0 3
85863: PUSH
85864: LD_INT 0
85866: ST_TO_ADDR
// x := GetX ( building ) ;
85867: LD_ADDR_VAR 0 4
85871: PUSH
85872: LD_VAR 0 2
85876: PPUSH
85877: CALL_OW 250
85881: ST_TO_ADDR
// y := GetY ( building ) ;
85882: LD_ADDR_VAR 0 5
85886: PUSH
85887: LD_VAR 0 2
85891: PPUSH
85892: CALL_OW 251
85896: ST_TO_ADDR
// if not building or not x or not y then
85897: LD_VAR 0 2
85901: NOT
85902: PUSH
85903: LD_VAR 0 4
85907: NOT
85908: OR
85909: PUSH
85910: LD_VAR 0 5
85914: NOT
85915: OR
85916: IFFALSE 85920
// exit ;
85918: GO 86012
// if GetTaskList ( unit ) then
85920: LD_VAR 0 1
85924: PPUSH
85925: CALL_OW 437
85929: IFFALSE 86012
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85931: LD_STRING e
85933: PUSH
85934: LD_VAR 0 1
85938: PPUSH
85939: CALL_OW 437
85943: PUSH
85944: LD_INT 1
85946: ARRAY
85947: PUSH
85948: LD_INT 1
85950: ARRAY
85951: EQUAL
85952: PUSH
85953: LD_VAR 0 4
85957: PUSH
85958: LD_VAR 0 1
85962: PPUSH
85963: CALL_OW 437
85967: PUSH
85968: LD_INT 1
85970: ARRAY
85971: PUSH
85972: LD_INT 2
85974: ARRAY
85975: EQUAL
85976: AND
85977: PUSH
85978: LD_VAR 0 5
85982: PUSH
85983: LD_VAR 0 1
85987: PPUSH
85988: CALL_OW 437
85992: PUSH
85993: LD_INT 1
85995: ARRAY
85996: PUSH
85997: LD_INT 3
85999: ARRAY
86000: EQUAL
86001: AND
86002: IFFALSE 86012
// result := true end ;
86004: LD_ADDR_VAR 0 3
86008: PUSH
86009: LD_INT 1
86011: ST_TO_ADDR
// end ;
86012: LD_VAR 0 3
86016: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
86017: LD_INT 0
86019: PPUSH
// result := false ;
86020: LD_ADDR_VAR 0 4
86024: PUSH
86025: LD_INT 0
86027: ST_TO_ADDR
// if GetTaskList ( unit ) then
86028: LD_VAR 0 1
86032: PPUSH
86033: CALL_OW 437
86037: IFFALSE 86120
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86039: LD_STRING M
86041: PUSH
86042: LD_VAR 0 1
86046: PPUSH
86047: CALL_OW 437
86051: PUSH
86052: LD_INT 1
86054: ARRAY
86055: PUSH
86056: LD_INT 1
86058: ARRAY
86059: EQUAL
86060: PUSH
86061: LD_VAR 0 2
86065: PUSH
86066: LD_VAR 0 1
86070: PPUSH
86071: CALL_OW 437
86075: PUSH
86076: LD_INT 1
86078: ARRAY
86079: PUSH
86080: LD_INT 2
86082: ARRAY
86083: EQUAL
86084: AND
86085: PUSH
86086: LD_VAR 0 3
86090: PUSH
86091: LD_VAR 0 1
86095: PPUSH
86096: CALL_OW 437
86100: PUSH
86101: LD_INT 1
86103: ARRAY
86104: PUSH
86105: LD_INT 3
86107: ARRAY
86108: EQUAL
86109: AND
86110: IFFALSE 86120
// result := true ;
86112: LD_ADDR_VAR 0 4
86116: PUSH
86117: LD_INT 1
86119: ST_TO_ADDR
// end ; end ;
86120: LD_VAR 0 4
86124: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
86125: LD_INT 0
86127: PPUSH
86128: PPUSH
86129: PPUSH
86130: PPUSH
// if not unit or not area then
86131: LD_VAR 0 1
86135: NOT
86136: PUSH
86137: LD_VAR 0 2
86141: NOT
86142: OR
86143: IFFALSE 86147
// exit ;
86145: GO 86311
// tmp := AreaToList ( area , i ) ;
86147: LD_ADDR_VAR 0 6
86151: PUSH
86152: LD_VAR 0 2
86156: PPUSH
86157: LD_VAR 0 5
86161: PPUSH
86162: CALL_OW 517
86166: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
86167: LD_ADDR_VAR 0 5
86171: PUSH
86172: DOUBLE
86173: LD_INT 1
86175: DEC
86176: ST_TO_ADDR
86177: LD_VAR 0 6
86181: PUSH
86182: LD_INT 1
86184: ARRAY
86185: PUSH
86186: FOR_TO
86187: IFFALSE 86309
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
86189: LD_ADDR_VAR 0 7
86193: PUSH
86194: LD_VAR 0 6
86198: PUSH
86199: LD_INT 1
86201: ARRAY
86202: PUSH
86203: LD_VAR 0 5
86207: ARRAY
86208: PUSH
86209: LD_VAR 0 6
86213: PUSH
86214: LD_INT 2
86216: ARRAY
86217: PUSH
86218: LD_VAR 0 5
86222: ARRAY
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
86228: LD_VAR 0 7
86232: PUSH
86233: LD_INT 1
86235: ARRAY
86236: PPUSH
86237: LD_VAR 0 7
86241: PUSH
86242: LD_INT 2
86244: ARRAY
86245: PPUSH
86246: CALL_OW 428
86250: PUSH
86251: LD_INT 0
86253: EQUAL
86254: IFFALSE 86307
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
86256: LD_VAR 0 1
86260: PPUSH
86261: LD_VAR 0 7
86265: PUSH
86266: LD_INT 1
86268: ARRAY
86269: PPUSH
86270: LD_VAR 0 7
86274: PUSH
86275: LD_INT 2
86277: ARRAY
86278: PPUSH
86279: LD_VAR 0 3
86283: PPUSH
86284: CALL_OW 48
// result := IsPlaced ( unit ) ;
86288: LD_ADDR_VAR 0 4
86292: PUSH
86293: LD_VAR 0 1
86297: PPUSH
86298: CALL_OW 305
86302: ST_TO_ADDR
// exit ;
86303: POP
86304: POP
86305: GO 86311
// end ; end ;
86307: GO 86186
86309: POP
86310: POP
// end ;
86311: LD_VAR 0 4
86315: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
86316: LD_INT 0
86318: PPUSH
86319: PPUSH
86320: PPUSH
// if not side or side > 8 then
86321: LD_VAR 0 1
86325: NOT
86326: PUSH
86327: LD_VAR 0 1
86331: PUSH
86332: LD_INT 8
86334: GREATER
86335: OR
86336: IFFALSE 86340
// exit ;
86338: GO 86527
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
86340: LD_ADDR_VAR 0 4
86344: PUSH
86345: LD_INT 22
86347: PUSH
86348: LD_VAR 0 1
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 21
86359: PUSH
86360: LD_INT 3
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PPUSH
86371: CALL_OW 69
86375: ST_TO_ADDR
// if not tmp then
86376: LD_VAR 0 4
86380: NOT
86381: IFFALSE 86385
// exit ;
86383: GO 86527
// enable_addtolog := true ;
86385: LD_ADDR_OWVAR 81
86389: PUSH
86390: LD_INT 1
86392: ST_TO_ADDR
// AddToLog ( [ ) ;
86393: LD_STRING [
86395: PPUSH
86396: CALL_OW 561
// for i in tmp do
86400: LD_ADDR_VAR 0 3
86404: PUSH
86405: LD_VAR 0 4
86409: PUSH
86410: FOR_IN
86411: IFFALSE 86518
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
86413: LD_STRING [
86415: PUSH
86416: LD_VAR 0 3
86420: PPUSH
86421: CALL_OW 266
86425: STR
86426: PUSH
86427: LD_STRING , 
86429: STR
86430: PUSH
86431: LD_VAR 0 3
86435: PPUSH
86436: CALL_OW 250
86440: STR
86441: PUSH
86442: LD_STRING , 
86444: STR
86445: PUSH
86446: LD_VAR 0 3
86450: PPUSH
86451: CALL_OW 251
86455: STR
86456: PUSH
86457: LD_STRING , 
86459: STR
86460: PUSH
86461: LD_VAR 0 3
86465: PPUSH
86466: CALL_OW 254
86470: STR
86471: PUSH
86472: LD_STRING , 
86474: STR
86475: PUSH
86476: LD_VAR 0 3
86480: PPUSH
86481: LD_INT 1
86483: PPUSH
86484: CALL_OW 268
86488: STR
86489: PUSH
86490: LD_STRING , 
86492: STR
86493: PUSH
86494: LD_VAR 0 3
86498: PPUSH
86499: LD_INT 2
86501: PPUSH
86502: CALL_OW 268
86506: STR
86507: PUSH
86508: LD_STRING ],
86510: STR
86511: PPUSH
86512: CALL_OW 561
// end ;
86516: GO 86410
86518: POP
86519: POP
// AddToLog ( ]; ) ;
86520: LD_STRING ];
86522: PPUSH
86523: CALL_OW 561
// end ;
86527: LD_VAR 0 2
86531: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86532: LD_INT 0
86534: PPUSH
86535: PPUSH
86536: PPUSH
86537: PPUSH
86538: PPUSH
// if not area or not rate or not max then
86539: LD_VAR 0 1
86543: NOT
86544: PUSH
86545: LD_VAR 0 2
86549: NOT
86550: OR
86551: PUSH
86552: LD_VAR 0 4
86556: NOT
86557: OR
86558: IFFALSE 86562
// exit ;
86560: GO 86754
// while 1 do
86562: LD_INT 1
86564: IFFALSE 86754
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86566: LD_ADDR_VAR 0 9
86570: PUSH
86571: LD_VAR 0 1
86575: PPUSH
86576: LD_INT 1
86578: PPUSH
86579: CALL_OW 287
86583: PUSH
86584: LD_INT 10
86586: MUL
86587: ST_TO_ADDR
// r := rate / 10 ;
86588: LD_ADDR_VAR 0 7
86592: PUSH
86593: LD_VAR 0 2
86597: PUSH
86598: LD_INT 10
86600: DIVREAL
86601: ST_TO_ADDR
// time := 1 1$00 ;
86602: LD_ADDR_VAR 0 8
86606: PUSH
86607: LD_INT 2100
86609: ST_TO_ADDR
// if amount < min then
86610: LD_VAR 0 9
86614: PUSH
86615: LD_VAR 0 3
86619: LESS
86620: IFFALSE 86638
// r := r * 2 else
86622: LD_ADDR_VAR 0 7
86626: PUSH
86627: LD_VAR 0 7
86631: PUSH
86632: LD_INT 2
86634: MUL
86635: ST_TO_ADDR
86636: GO 86664
// if amount > max then
86638: LD_VAR 0 9
86642: PUSH
86643: LD_VAR 0 4
86647: GREATER
86648: IFFALSE 86664
// r := r / 2 ;
86650: LD_ADDR_VAR 0 7
86654: PUSH
86655: LD_VAR 0 7
86659: PUSH
86660: LD_INT 2
86662: DIVREAL
86663: ST_TO_ADDR
// time := time / r ;
86664: LD_ADDR_VAR 0 8
86668: PUSH
86669: LD_VAR 0 8
86673: PUSH
86674: LD_VAR 0 7
86678: DIVREAL
86679: ST_TO_ADDR
// if time < 0 then
86680: LD_VAR 0 8
86684: PUSH
86685: LD_INT 0
86687: LESS
86688: IFFALSE 86705
// time := time * - 1 ;
86690: LD_ADDR_VAR 0 8
86694: PUSH
86695: LD_VAR 0 8
86699: PUSH
86700: LD_INT 1
86702: NEG
86703: MUL
86704: ST_TO_ADDR
// wait ( time ) ;
86705: LD_VAR 0 8
86709: PPUSH
86710: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
86714: LD_INT 35
86716: PPUSH
86717: LD_INT 875
86719: PPUSH
86720: CALL_OW 12
86724: PPUSH
86725: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86729: LD_INT 1
86731: PPUSH
86732: LD_INT 5
86734: PPUSH
86735: CALL_OW 12
86739: PPUSH
86740: LD_VAR 0 1
86744: PPUSH
86745: LD_INT 1
86747: PPUSH
86748: CALL_OW 55
// end ;
86752: GO 86562
// end ;
86754: LD_VAR 0 5
86758: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86759: LD_INT 0
86761: PPUSH
86762: PPUSH
86763: PPUSH
86764: PPUSH
86765: PPUSH
86766: PPUSH
86767: PPUSH
86768: PPUSH
// if not turrets or not factories then
86769: LD_VAR 0 1
86773: NOT
86774: PUSH
86775: LD_VAR 0 2
86779: NOT
86780: OR
86781: IFFALSE 86785
// exit ;
86783: GO 87092
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86785: LD_ADDR_VAR 0 10
86789: PUSH
86790: LD_INT 5
86792: PUSH
86793: LD_INT 6
86795: PUSH
86796: EMPTY
86797: LIST
86798: LIST
86799: PUSH
86800: LD_INT 2
86802: PUSH
86803: LD_INT 4
86805: PUSH
86806: EMPTY
86807: LIST
86808: LIST
86809: PUSH
86810: LD_INT 3
86812: PUSH
86813: LD_INT 5
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: LIST
86824: PUSH
86825: LD_INT 24
86827: PUSH
86828: LD_INT 25
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 23
86837: PUSH
86838: LD_INT 27
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: LD_INT 42
86851: PUSH
86852: LD_INT 43
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 44
86861: PUSH
86862: LD_INT 46
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 45
86871: PUSH
86872: LD_INT 47
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: EMPTY
86880: LIST
86881: LIST
86882: LIST
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: LIST
86888: ST_TO_ADDR
// result := [ ] ;
86889: LD_ADDR_VAR 0 3
86893: PUSH
86894: EMPTY
86895: ST_TO_ADDR
// for i in turrets do
86896: LD_ADDR_VAR 0 4
86900: PUSH
86901: LD_VAR 0 1
86905: PUSH
86906: FOR_IN
86907: IFFALSE 87090
// begin nat := GetNation ( i ) ;
86909: LD_ADDR_VAR 0 7
86913: PUSH
86914: LD_VAR 0 4
86918: PPUSH
86919: CALL_OW 248
86923: ST_TO_ADDR
// weapon := 0 ;
86924: LD_ADDR_VAR 0 8
86928: PUSH
86929: LD_INT 0
86931: ST_TO_ADDR
// if not nat then
86932: LD_VAR 0 7
86936: NOT
86937: IFFALSE 86941
// continue ;
86939: GO 86906
// for j in list [ nat ] do
86941: LD_ADDR_VAR 0 5
86945: PUSH
86946: LD_VAR 0 10
86950: PUSH
86951: LD_VAR 0 7
86955: ARRAY
86956: PUSH
86957: FOR_IN
86958: IFFALSE 86999
// if GetBWeapon ( i ) = j [ 1 ] then
86960: LD_VAR 0 4
86964: PPUSH
86965: CALL_OW 269
86969: PUSH
86970: LD_VAR 0 5
86974: PUSH
86975: LD_INT 1
86977: ARRAY
86978: EQUAL
86979: IFFALSE 86997
// begin weapon := j [ 2 ] ;
86981: LD_ADDR_VAR 0 8
86985: PUSH
86986: LD_VAR 0 5
86990: PUSH
86991: LD_INT 2
86993: ARRAY
86994: ST_TO_ADDR
// break ;
86995: GO 86999
// end ;
86997: GO 86957
86999: POP
87000: POP
// if not weapon then
87001: LD_VAR 0 8
87005: NOT
87006: IFFALSE 87010
// continue ;
87008: GO 86906
// for k in factories do
87010: LD_ADDR_VAR 0 6
87014: PUSH
87015: LD_VAR 0 2
87019: PUSH
87020: FOR_IN
87021: IFFALSE 87086
// begin weapons := AvailableWeaponList ( k ) ;
87023: LD_ADDR_VAR 0 9
87027: PUSH
87028: LD_VAR 0 6
87032: PPUSH
87033: CALL_OW 478
87037: ST_TO_ADDR
// if not weapons then
87038: LD_VAR 0 9
87042: NOT
87043: IFFALSE 87047
// continue ;
87045: GO 87020
// if weapon in weapons then
87047: LD_VAR 0 8
87051: PUSH
87052: LD_VAR 0 9
87056: IN
87057: IFFALSE 87084
// begin result := [ i , weapon ] ;
87059: LD_ADDR_VAR 0 3
87063: PUSH
87064: LD_VAR 0 4
87068: PUSH
87069: LD_VAR 0 8
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: ST_TO_ADDR
// exit ;
87078: POP
87079: POP
87080: POP
87081: POP
87082: GO 87092
// end ; end ;
87084: GO 87020
87086: POP
87087: POP
// end ;
87088: GO 86906
87090: POP
87091: POP
// end ;
87092: LD_VAR 0 3
87096: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
87097: LD_INT 0
87099: PPUSH
// if not side or side > 8 then
87100: LD_VAR 0 3
87104: NOT
87105: PUSH
87106: LD_VAR 0 3
87110: PUSH
87111: LD_INT 8
87113: GREATER
87114: OR
87115: IFFALSE 87119
// exit ;
87117: GO 87178
// if not range then
87119: LD_VAR 0 4
87123: NOT
87124: IFFALSE 87135
// range := - 12 ;
87126: LD_ADDR_VAR 0 4
87130: PUSH
87131: LD_INT 12
87133: NEG
87134: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
87135: LD_VAR 0 1
87139: PPUSH
87140: LD_VAR 0 2
87144: PPUSH
87145: LD_VAR 0 3
87149: PPUSH
87150: LD_VAR 0 4
87154: PPUSH
87155: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
87159: LD_VAR 0 1
87163: PPUSH
87164: LD_VAR 0 2
87168: PPUSH
87169: LD_VAR 0 3
87173: PPUSH
87174: CALL_OW 331
// end ;
87178: LD_VAR 0 5
87182: RET
// export function Video ( mode ) ; begin
87183: LD_INT 0
87185: PPUSH
// ingame_video = mode ;
87186: LD_ADDR_OWVAR 52
87190: PUSH
87191: LD_VAR 0 1
87195: ST_TO_ADDR
// interface_hidden = mode ;
87196: LD_ADDR_OWVAR 54
87200: PUSH
87201: LD_VAR 0 1
87205: ST_TO_ADDR
// end ;
87206: LD_VAR 0 2
87210: RET
// export function Join ( array , element ) ; begin
87211: LD_INT 0
87213: PPUSH
// result := Replace ( array , array + 1 , element ) ;
87214: LD_ADDR_VAR 0 3
87218: PUSH
87219: LD_VAR 0 1
87223: PPUSH
87224: LD_VAR 0 1
87228: PUSH
87229: LD_INT 1
87231: PLUS
87232: PPUSH
87233: LD_VAR 0 2
87237: PPUSH
87238: CALL_OW 1
87242: ST_TO_ADDR
// end ;
87243: LD_VAR 0 3
87247: RET
// export function JoinUnion ( array , element ) ; begin
87248: LD_INT 0
87250: PPUSH
// result := array union element ;
87251: LD_ADDR_VAR 0 3
87255: PUSH
87256: LD_VAR 0 1
87260: PUSH
87261: LD_VAR 0 2
87265: UNION
87266: ST_TO_ADDR
// end ;
87267: LD_VAR 0 3
87271: RET
// export function GetBehemoths ( side ) ; begin
87272: LD_INT 0
87274: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
87275: LD_ADDR_VAR 0 2
87279: PUSH
87280: LD_INT 22
87282: PUSH
87283: LD_VAR 0 1
87287: PUSH
87288: EMPTY
87289: LIST
87290: LIST
87291: PUSH
87292: LD_INT 31
87294: PUSH
87295: LD_INT 25
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PPUSH
87306: CALL_OW 69
87310: ST_TO_ADDR
// end ;
87311: LD_VAR 0 2
87315: RET
// export function Shuffle ( array ) ; var i , index ; begin
87316: LD_INT 0
87318: PPUSH
87319: PPUSH
87320: PPUSH
// result := [ ] ;
87321: LD_ADDR_VAR 0 2
87325: PUSH
87326: EMPTY
87327: ST_TO_ADDR
// if not array then
87328: LD_VAR 0 1
87332: NOT
87333: IFFALSE 87337
// exit ;
87335: GO 87436
// Randomize ;
87337: CALL_OW 10
// for i = array downto 1 do
87341: LD_ADDR_VAR 0 3
87345: PUSH
87346: DOUBLE
87347: LD_VAR 0 1
87351: INC
87352: ST_TO_ADDR
87353: LD_INT 1
87355: PUSH
87356: FOR_DOWNTO
87357: IFFALSE 87434
// begin index := rand ( 1 , array ) ;
87359: LD_ADDR_VAR 0 4
87363: PUSH
87364: LD_INT 1
87366: PPUSH
87367: LD_VAR 0 1
87371: PPUSH
87372: CALL_OW 12
87376: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
87377: LD_ADDR_VAR 0 2
87381: PUSH
87382: LD_VAR 0 2
87386: PPUSH
87387: LD_VAR 0 2
87391: PUSH
87392: LD_INT 1
87394: PLUS
87395: PPUSH
87396: LD_VAR 0 1
87400: PUSH
87401: LD_VAR 0 4
87405: ARRAY
87406: PPUSH
87407: CALL_OW 2
87411: ST_TO_ADDR
// array := Delete ( array , index ) ;
87412: LD_ADDR_VAR 0 1
87416: PUSH
87417: LD_VAR 0 1
87421: PPUSH
87422: LD_VAR 0 4
87426: PPUSH
87427: CALL_OW 3
87431: ST_TO_ADDR
// end ;
87432: GO 87356
87434: POP
87435: POP
// end ;
87436: LD_VAR 0 2
87440: RET
// export function GetBaseMaterials ( base ) ; begin
87441: LD_INT 0
87443: PPUSH
// result := [ 0 , 0 , 0 ] ;
87444: LD_ADDR_VAR 0 2
87448: PUSH
87449: LD_INT 0
87451: PUSH
87452: LD_INT 0
87454: PUSH
87455: LD_INT 0
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: LIST
87462: ST_TO_ADDR
// if not base then
87463: LD_VAR 0 1
87467: NOT
87468: IFFALSE 87472
// exit ;
87470: GO 87521
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87472: LD_ADDR_VAR 0 2
87476: PUSH
87477: LD_VAR 0 1
87481: PPUSH
87482: LD_INT 1
87484: PPUSH
87485: CALL_OW 275
87489: PUSH
87490: LD_VAR 0 1
87494: PPUSH
87495: LD_INT 2
87497: PPUSH
87498: CALL_OW 275
87502: PUSH
87503: LD_VAR 0 1
87507: PPUSH
87508: LD_INT 3
87510: PPUSH
87511: CALL_OW 275
87515: PUSH
87516: EMPTY
87517: LIST
87518: LIST
87519: LIST
87520: ST_TO_ADDR
// end ;
87521: LD_VAR 0 2
87525: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87526: LD_INT 0
87528: PPUSH
87529: PPUSH
// result := array ;
87530: LD_ADDR_VAR 0 3
87534: PUSH
87535: LD_VAR 0 1
87539: ST_TO_ADDR
// if size > 0 then
87540: LD_VAR 0 2
87544: PUSH
87545: LD_INT 0
87547: GREATER
87548: IFFALSE 87594
// for i := array downto size do
87550: LD_ADDR_VAR 0 4
87554: PUSH
87555: DOUBLE
87556: LD_VAR 0 1
87560: INC
87561: ST_TO_ADDR
87562: LD_VAR 0 2
87566: PUSH
87567: FOR_DOWNTO
87568: IFFALSE 87592
// result := Delete ( result , result ) ;
87570: LD_ADDR_VAR 0 3
87574: PUSH
87575: LD_VAR 0 3
87579: PPUSH
87580: LD_VAR 0 3
87584: PPUSH
87585: CALL_OW 3
87589: ST_TO_ADDR
87590: GO 87567
87592: POP
87593: POP
// end ;
87594: LD_VAR 0 3
87598: RET
// export function ComExit ( unit ) ; var tmp ; begin
87599: LD_INT 0
87601: PPUSH
87602: PPUSH
// if not IsInUnit ( unit ) then
87603: LD_VAR 0 1
87607: PPUSH
87608: CALL_OW 310
87612: NOT
87613: IFFALSE 87617
// exit ;
87615: GO 87677
// tmp := IsInUnit ( unit ) ;
87617: LD_ADDR_VAR 0 3
87621: PUSH
87622: LD_VAR 0 1
87626: PPUSH
87627: CALL_OW 310
87631: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87632: LD_VAR 0 3
87636: PPUSH
87637: CALL_OW 247
87641: PUSH
87642: LD_INT 2
87644: EQUAL
87645: IFFALSE 87658
// ComExitVehicle ( unit ) else
87647: LD_VAR 0 1
87651: PPUSH
87652: CALL_OW 121
87656: GO 87667
// ComExitBuilding ( unit ) ;
87658: LD_VAR 0 1
87662: PPUSH
87663: CALL_OW 122
// result := tmp ;
87667: LD_ADDR_VAR 0 2
87671: PUSH
87672: LD_VAR 0 3
87676: ST_TO_ADDR
// end ;
87677: LD_VAR 0 2
87681: RET
// export function ComExitAll ( units ) ; var i ; begin
87682: LD_INT 0
87684: PPUSH
87685: PPUSH
// if not units then
87686: LD_VAR 0 1
87690: NOT
87691: IFFALSE 87695
// exit ;
87693: GO 87721
// for i in units do
87695: LD_ADDR_VAR 0 3
87699: PUSH
87700: LD_VAR 0 1
87704: PUSH
87705: FOR_IN
87706: IFFALSE 87719
// ComExit ( i ) ;
87708: LD_VAR 0 3
87712: PPUSH
87713: CALL 87599 0 1
87717: GO 87705
87719: POP
87720: POP
// end ;
87721: LD_VAR 0 2
87725: RET
// export function ResetHc ; begin
87726: LD_INT 0
87728: PPUSH
// InitHc ;
87729: CALL_OW 19
// hc_importance := 0 ;
87733: LD_ADDR_OWVAR 32
87737: PUSH
87738: LD_INT 0
87740: ST_TO_ADDR
// end ;
87741: LD_VAR 0 1
87745: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87746: LD_INT 0
87748: PPUSH
87749: PPUSH
87750: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87751: LD_ADDR_VAR 0 6
87755: PUSH
87756: LD_VAR 0 1
87760: PUSH
87761: LD_VAR 0 3
87765: PLUS
87766: PUSH
87767: LD_INT 2
87769: DIV
87770: ST_TO_ADDR
// if _x < 0 then
87771: LD_VAR 0 6
87775: PUSH
87776: LD_INT 0
87778: LESS
87779: IFFALSE 87796
// _x := _x * - 1 ;
87781: LD_ADDR_VAR 0 6
87785: PUSH
87786: LD_VAR 0 6
87790: PUSH
87791: LD_INT 1
87793: NEG
87794: MUL
87795: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87796: LD_ADDR_VAR 0 7
87800: PUSH
87801: LD_VAR 0 2
87805: PUSH
87806: LD_VAR 0 4
87810: PLUS
87811: PUSH
87812: LD_INT 2
87814: DIV
87815: ST_TO_ADDR
// if _y < 0 then
87816: LD_VAR 0 7
87820: PUSH
87821: LD_INT 0
87823: LESS
87824: IFFALSE 87841
// _y := _y * - 1 ;
87826: LD_ADDR_VAR 0 7
87830: PUSH
87831: LD_VAR 0 7
87835: PUSH
87836: LD_INT 1
87838: NEG
87839: MUL
87840: ST_TO_ADDR
// result := [ _x , _y ] ;
87841: LD_ADDR_VAR 0 5
87845: PUSH
87846: LD_VAR 0 6
87850: PUSH
87851: LD_VAR 0 7
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: ST_TO_ADDR
// end ;
87860: LD_VAR 0 5
87864: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87865: LD_INT 0
87867: PPUSH
87868: PPUSH
87869: PPUSH
87870: PPUSH
// task := GetTaskList ( unit ) ;
87871: LD_ADDR_VAR 0 7
87875: PUSH
87876: LD_VAR 0 1
87880: PPUSH
87881: CALL_OW 437
87885: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87886: LD_VAR 0 7
87890: NOT
87891: PUSH
87892: LD_VAR 0 1
87896: PPUSH
87897: LD_VAR 0 2
87901: PPUSH
87902: CALL_OW 308
87906: NOT
87907: AND
87908: IFFALSE 87912
// exit ;
87910: GO 88030
// if IsInArea ( unit , area ) then
87912: LD_VAR 0 1
87916: PPUSH
87917: LD_VAR 0 2
87921: PPUSH
87922: CALL_OW 308
87926: IFFALSE 87944
// begin ComMoveToArea ( unit , goAway ) ;
87928: LD_VAR 0 1
87932: PPUSH
87933: LD_VAR 0 3
87937: PPUSH
87938: CALL_OW 113
// exit ;
87942: GO 88030
// end ; if task [ 1 ] [ 1 ] <> M then
87944: LD_VAR 0 7
87948: PUSH
87949: LD_INT 1
87951: ARRAY
87952: PUSH
87953: LD_INT 1
87955: ARRAY
87956: PUSH
87957: LD_STRING M
87959: NONEQUAL
87960: IFFALSE 87964
// exit ;
87962: GO 88030
// x := task [ 1 ] [ 2 ] ;
87964: LD_ADDR_VAR 0 5
87968: PUSH
87969: LD_VAR 0 7
87973: PUSH
87974: LD_INT 1
87976: ARRAY
87977: PUSH
87978: LD_INT 2
87980: ARRAY
87981: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87982: LD_ADDR_VAR 0 6
87986: PUSH
87987: LD_VAR 0 7
87991: PUSH
87992: LD_INT 1
87994: ARRAY
87995: PUSH
87996: LD_INT 3
87998: ARRAY
87999: ST_TO_ADDR
// if InArea ( x , y , area ) then
88000: LD_VAR 0 5
88004: PPUSH
88005: LD_VAR 0 6
88009: PPUSH
88010: LD_VAR 0 2
88014: PPUSH
88015: CALL_OW 309
88019: IFFALSE 88030
// ComStop ( unit ) ;
88021: LD_VAR 0 1
88025: PPUSH
88026: CALL_OW 141
// end ;
88030: LD_VAR 0 4
88034: RET
// export function Abs ( value ) ; begin
88035: LD_INT 0
88037: PPUSH
// result := value ;
88038: LD_ADDR_VAR 0 2
88042: PUSH
88043: LD_VAR 0 1
88047: ST_TO_ADDR
// if value < 0 then
88048: LD_VAR 0 1
88052: PUSH
88053: LD_INT 0
88055: LESS
88056: IFFALSE 88073
// result := value * - 1 ;
88058: LD_ADDR_VAR 0 2
88062: PUSH
88063: LD_VAR 0 1
88067: PUSH
88068: LD_INT 1
88070: NEG
88071: MUL
88072: ST_TO_ADDR
// end ;
88073: LD_VAR 0 2
88077: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
88078: LD_INT 0
88080: PPUSH
88081: PPUSH
88082: PPUSH
88083: PPUSH
88084: PPUSH
88085: PPUSH
88086: PPUSH
88087: PPUSH
// if not unit or not building then
88088: LD_VAR 0 1
88092: NOT
88093: PUSH
88094: LD_VAR 0 2
88098: NOT
88099: OR
88100: IFFALSE 88104
// exit ;
88102: GO 88330
// x := GetX ( building ) ;
88104: LD_ADDR_VAR 0 4
88108: PUSH
88109: LD_VAR 0 2
88113: PPUSH
88114: CALL_OW 250
88118: ST_TO_ADDR
// y := GetY ( building ) ;
88119: LD_ADDR_VAR 0 6
88123: PUSH
88124: LD_VAR 0 2
88128: PPUSH
88129: CALL_OW 251
88133: ST_TO_ADDR
// d := GetDir ( building ) ;
88134: LD_ADDR_VAR 0 8
88138: PUSH
88139: LD_VAR 0 2
88143: PPUSH
88144: CALL_OW 254
88148: ST_TO_ADDR
// r := 4 ;
88149: LD_ADDR_VAR 0 9
88153: PUSH
88154: LD_INT 4
88156: ST_TO_ADDR
// for i := 1 to 5 do
88157: LD_ADDR_VAR 0 10
88161: PUSH
88162: DOUBLE
88163: LD_INT 1
88165: DEC
88166: ST_TO_ADDR
88167: LD_INT 5
88169: PUSH
88170: FOR_TO
88171: IFFALSE 88328
// begin _x := ShiftX ( x , d , r + i ) ;
88173: LD_ADDR_VAR 0 5
88177: PUSH
88178: LD_VAR 0 4
88182: PPUSH
88183: LD_VAR 0 8
88187: PPUSH
88188: LD_VAR 0 9
88192: PUSH
88193: LD_VAR 0 10
88197: PLUS
88198: PPUSH
88199: CALL_OW 272
88203: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
88204: LD_ADDR_VAR 0 7
88208: PUSH
88209: LD_VAR 0 6
88213: PPUSH
88214: LD_VAR 0 8
88218: PPUSH
88219: LD_VAR 0 9
88223: PUSH
88224: LD_VAR 0 10
88228: PLUS
88229: PPUSH
88230: CALL_OW 273
88234: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
88235: LD_VAR 0 5
88239: PPUSH
88240: LD_VAR 0 7
88244: PPUSH
88245: CALL_OW 488
88249: PUSH
88250: LD_VAR 0 5
88254: PPUSH
88255: LD_VAR 0 7
88259: PPUSH
88260: CALL_OW 428
88264: PPUSH
88265: CALL_OW 247
88269: PUSH
88270: LD_INT 3
88272: PUSH
88273: LD_INT 2
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: IN
88280: NOT
88281: AND
88282: IFFALSE 88326
// begin ComMoveXY ( unit , _x , _y ) ;
88284: LD_VAR 0 1
88288: PPUSH
88289: LD_VAR 0 5
88293: PPUSH
88294: LD_VAR 0 7
88298: PPUSH
88299: CALL_OW 111
// result := [ _x , _y ] ;
88303: LD_ADDR_VAR 0 3
88307: PUSH
88308: LD_VAR 0 5
88312: PUSH
88313: LD_VAR 0 7
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: ST_TO_ADDR
// exit ;
88322: POP
88323: POP
88324: GO 88330
// end ; end ;
88326: GO 88170
88328: POP
88329: POP
// end ;
88330: LD_VAR 0 3
88334: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
88335: LD_INT 0
88337: PPUSH
88338: PPUSH
88339: PPUSH
// result := 0 ;
88340: LD_ADDR_VAR 0 3
88344: PUSH
88345: LD_INT 0
88347: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
88348: LD_VAR 0 1
88352: PUSH
88353: LD_INT 0
88355: LESS
88356: PUSH
88357: LD_VAR 0 1
88361: PUSH
88362: LD_INT 8
88364: GREATER
88365: OR
88366: PUSH
88367: LD_VAR 0 2
88371: PUSH
88372: LD_INT 0
88374: LESS
88375: OR
88376: PUSH
88377: LD_VAR 0 2
88381: PUSH
88382: LD_INT 8
88384: GREATER
88385: OR
88386: IFFALSE 88390
// exit ;
88388: GO 88465
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
88390: LD_ADDR_VAR 0 4
88394: PUSH
88395: LD_INT 22
88397: PUSH
88398: LD_VAR 0 2
88402: PUSH
88403: EMPTY
88404: LIST
88405: LIST
88406: PPUSH
88407: CALL_OW 69
88411: PUSH
88412: FOR_IN
88413: IFFALSE 88463
// begin un := UnitShoot ( i ) ;
88415: LD_ADDR_VAR 0 5
88419: PUSH
88420: LD_VAR 0 4
88424: PPUSH
88425: CALL_OW 504
88429: ST_TO_ADDR
// if GetSide ( un ) = side1 then
88430: LD_VAR 0 5
88434: PPUSH
88435: CALL_OW 255
88439: PUSH
88440: LD_VAR 0 1
88444: EQUAL
88445: IFFALSE 88461
// begin result := un ;
88447: LD_ADDR_VAR 0 3
88451: PUSH
88452: LD_VAR 0 5
88456: ST_TO_ADDR
// exit ;
88457: POP
88458: POP
88459: GO 88465
// end ; end ;
88461: GO 88412
88463: POP
88464: POP
// end ;
88465: LD_VAR 0 3
88469: RET
// export function GetCargoBay ( units ) ; begin
88470: LD_INT 0
88472: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
88473: LD_ADDR_VAR 0 2
88477: PUSH
88478: LD_VAR 0 1
88482: PPUSH
88483: LD_INT 2
88485: PUSH
88486: LD_INT 34
88488: PUSH
88489: LD_INT 12
88491: PUSH
88492: EMPTY
88493: LIST
88494: LIST
88495: PUSH
88496: LD_INT 34
88498: PUSH
88499: LD_INT 51
88501: PUSH
88502: EMPTY
88503: LIST
88504: LIST
88505: PUSH
88506: LD_INT 34
88508: PUSH
88509: LD_INT 32
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: PUSH
88516: LD_INT 34
88518: PUSH
88519: LD_EXP 73
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: LIST
88532: LIST
88533: LIST
88534: PPUSH
88535: CALL_OW 72
88539: ST_TO_ADDR
// end ; end_of_file end_of_file
88540: LD_VAR 0 2
88544: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
88545: LD_VAR 0 2
88549: PUSH
88550: LD_INT 100
88552: EQUAL
88553: IFFALSE 89502
// begin if not StreamModeActive then
88555: LD_EXP 133
88559: NOT
88560: IFFALSE 88570
// StreamModeActive := true ;
88562: LD_ADDR_EXP 133
88566: PUSH
88567: LD_INT 1
88569: ST_TO_ADDR
// if p3 = 0 then
88570: LD_VAR 0 3
88574: PUSH
88575: LD_INT 0
88577: EQUAL
88578: IFFALSE 88584
// InitStreamMode ;
88580: CALL 89660 0 0
// if p3 = 1 then
88584: LD_VAR 0 3
88588: PUSH
88589: LD_INT 1
88591: EQUAL
88592: IFFALSE 88602
// sRocket := true ;
88594: LD_ADDR_EXP 138
88598: PUSH
88599: LD_INT 1
88601: ST_TO_ADDR
// if p3 = 2 then
88602: LD_VAR 0 3
88606: PUSH
88607: LD_INT 2
88609: EQUAL
88610: IFFALSE 88620
// sSpeed := true ;
88612: LD_ADDR_EXP 137
88616: PUSH
88617: LD_INT 1
88619: ST_TO_ADDR
// if p3 = 3 then
88620: LD_VAR 0 3
88624: PUSH
88625: LD_INT 3
88627: EQUAL
88628: IFFALSE 88638
// sEngine := true ;
88630: LD_ADDR_EXP 139
88634: PUSH
88635: LD_INT 1
88637: ST_TO_ADDR
// if p3 = 4 then
88638: LD_VAR 0 3
88642: PUSH
88643: LD_INT 4
88645: EQUAL
88646: IFFALSE 88656
// sSpec := true ;
88648: LD_ADDR_EXP 136
88652: PUSH
88653: LD_INT 1
88655: ST_TO_ADDR
// if p3 = 5 then
88656: LD_VAR 0 3
88660: PUSH
88661: LD_INT 5
88663: EQUAL
88664: IFFALSE 88674
// sLevel := true ;
88666: LD_ADDR_EXP 140
88670: PUSH
88671: LD_INT 1
88673: ST_TO_ADDR
// if p3 = 6 then
88674: LD_VAR 0 3
88678: PUSH
88679: LD_INT 6
88681: EQUAL
88682: IFFALSE 88692
// sArmoury := true ;
88684: LD_ADDR_EXP 141
88688: PUSH
88689: LD_INT 1
88691: ST_TO_ADDR
// if p3 = 7 then
88692: LD_VAR 0 3
88696: PUSH
88697: LD_INT 7
88699: EQUAL
88700: IFFALSE 88710
// sRadar := true ;
88702: LD_ADDR_EXP 142
88706: PUSH
88707: LD_INT 1
88709: ST_TO_ADDR
// if p3 = 8 then
88710: LD_VAR 0 3
88714: PUSH
88715: LD_INT 8
88717: EQUAL
88718: IFFALSE 88728
// sBunker := true ;
88720: LD_ADDR_EXP 143
88724: PUSH
88725: LD_INT 1
88727: ST_TO_ADDR
// if p3 = 9 then
88728: LD_VAR 0 3
88732: PUSH
88733: LD_INT 9
88735: EQUAL
88736: IFFALSE 88746
// sHack := true ;
88738: LD_ADDR_EXP 144
88742: PUSH
88743: LD_INT 1
88745: ST_TO_ADDR
// if p3 = 10 then
88746: LD_VAR 0 3
88750: PUSH
88751: LD_INT 10
88753: EQUAL
88754: IFFALSE 88764
// sFire := true ;
88756: LD_ADDR_EXP 145
88760: PUSH
88761: LD_INT 1
88763: ST_TO_ADDR
// if p3 = 11 then
88764: LD_VAR 0 3
88768: PUSH
88769: LD_INT 11
88771: EQUAL
88772: IFFALSE 88782
// sRefresh := true ;
88774: LD_ADDR_EXP 146
88778: PUSH
88779: LD_INT 1
88781: ST_TO_ADDR
// if p3 = 12 then
88782: LD_VAR 0 3
88786: PUSH
88787: LD_INT 12
88789: EQUAL
88790: IFFALSE 88800
// sExp := true ;
88792: LD_ADDR_EXP 147
88796: PUSH
88797: LD_INT 1
88799: ST_TO_ADDR
// if p3 = 13 then
88800: LD_VAR 0 3
88804: PUSH
88805: LD_INT 13
88807: EQUAL
88808: IFFALSE 88818
// sDepot := true ;
88810: LD_ADDR_EXP 148
88814: PUSH
88815: LD_INT 1
88817: ST_TO_ADDR
// if p3 = 14 then
88818: LD_VAR 0 3
88822: PUSH
88823: LD_INT 14
88825: EQUAL
88826: IFFALSE 88836
// sFlag := true ;
88828: LD_ADDR_EXP 149
88832: PUSH
88833: LD_INT 1
88835: ST_TO_ADDR
// if p3 = 15 then
88836: LD_VAR 0 3
88840: PUSH
88841: LD_INT 15
88843: EQUAL
88844: IFFALSE 88854
// sKamikadze := true ;
88846: LD_ADDR_EXP 157
88850: PUSH
88851: LD_INT 1
88853: ST_TO_ADDR
// if p3 = 16 then
88854: LD_VAR 0 3
88858: PUSH
88859: LD_INT 16
88861: EQUAL
88862: IFFALSE 88872
// sTroll := true ;
88864: LD_ADDR_EXP 158
88868: PUSH
88869: LD_INT 1
88871: ST_TO_ADDR
// if p3 = 17 then
88872: LD_VAR 0 3
88876: PUSH
88877: LD_INT 17
88879: EQUAL
88880: IFFALSE 88890
// sSlow := true ;
88882: LD_ADDR_EXP 159
88886: PUSH
88887: LD_INT 1
88889: ST_TO_ADDR
// if p3 = 18 then
88890: LD_VAR 0 3
88894: PUSH
88895: LD_INT 18
88897: EQUAL
88898: IFFALSE 88908
// sLack := true ;
88900: LD_ADDR_EXP 160
88904: PUSH
88905: LD_INT 1
88907: ST_TO_ADDR
// if p3 = 19 then
88908: LD_VAR 0 3
88912: PUSH
88913: LD_INT 19
88915: EQUAL
88916: IFFALSE 88926
// sTank := true ;
88918: LD_ADDR_EXP 162
88922: PUSH
88923: LD_INT 1
88925: ST_TO_ADDR
// if p3 = 20 then
88926: LD_VAR 0 3
88930: PUSH
88931: LD_INT 20
88933: EQUAL
88934: IFFALSE 88944
// sRemote := true ;
88936: LD_ADDR_EXP 163
88940: PUSH
88941: LD_INT 1
88943: ST_TO_ADDR
// if p3 = 21 then
88944: LD_VAR 0 3
88948: PUSH
88949: LD_INT 21
88951: EQUAL
88952: IFFALSE 88962
// sPowell := true ;
88954: LD_ADDR_EXP 164
88958: PUSH
88959: LD_INT 1
88961: ST_TO_ADDR
// if p3 = 22 then
88962: LD_VAR 0 3
88966: PUSH
88967: LD_INT 22
88969: EQUAL
88970: IFFALSE 88980
// sTeleport := true ;
88972: LD_ADDR_EXP 167
88976: PUSH
88977: LD_INT 1
88979: ST_TO_ADDR
// if p3 = 23 then
88980: LD_VAR 0 3
88984: PUSH
88985: LD_INT 23
88987: EQUAL
88988: IFFALSE 88998
// sOilTower := true ;
88990: LD_ADDR_EXP 169
88994: PUSH
88995: LD_INT 1
88997: ST_TO_ADDR
// if p3 = 24 then
88998: LD_VAR 0 3
89002: PUSH
89003: LD_INT 24
89005: EQUAL
89006: IFFALSE 89016
// sShovel := true ;
89008: LD_ADDR_EXP 170
89012: PUSH
89013: LD_INT 1
89015: ST_TO_ADDR
// if p3 = 25 then
89016: LD_VAR 0 3
89020: PUSH
89021: LD_INT 25
89023: EQUAL
89024: IFFALSE 89034
// sSheik := true ;
89026: LD_ADDR_EXP 171
89030: PUSH
89031: LD_INT 1
89033: ST_TO_ADDR
// if p3 = 26 then
89034: LD_VAR 0 3
89038: PUSH
89039: LD_INT 26
89041: EQUAL
89042: IFFALSE 89052
// sEarthquake := true ;
89044: LD_ADDR_EXP 173
89048: PUSH
89049: LD_INT 1
89051: ST_TO_ADDR
// if p3 = 27 then
89052: LD_VAR 0 3
89056: PUSH
89057: LD_INT 27
89059: EQUAL
89060: IFFALSE 89070
// sAI := true ;
89062: LD_ADDR_EXP 174
89066: PUSH
89067: LD_INT 1
89069: ST_TO_ADDR
// if p3 = 28 then
89070: LD_VAR 0 3
89074: PUSH
89075: LD_INT 28
89077: EQUAL
89078: IFFALSE 89088
// sCargo := true ;
89080: LD_ADDR_EXP 177
89084: PUSH
89085: LD_INT 1
89087: ST_TO_ADDR
// if p3 = 29 then
89088: LD_VAR 0 3
89092: PUSH
89093: LD_INT 29
89095: EQUAL
89096: IFFALSE 89106
// sDLaser := true ;
89098: LD_ADDR_EXP 178
89102: PUSH
89103: LD_INT 1
89105: ST_TO_ADDR
// if p3 = 30 then
89106: LD_VAR 0 3
89110: PUSH
89111: LD_INT 30
89113: EQUAL
89114: IFFALSE 89124
// sExchange := true ;
89116: LD_ADDR_EXP 179
89120: PUSH
89121: LD_INT 1
89123: ST_TO_ADDR
// if p3 = 31 then
89124: LD_VAR 0 3
89128: PUSH
89129: LD_INT 31
89131: EQUAL
89132: IFFALSE 89142
// sFac := true ;
89134: LD_ADDR_EXP 180
89138: PUSH
89139: LD_INT 1
89141: ST_TO_ADDR
// if p3 = 32 then
89142: LD_VAR 0 3
89146: PUSH
89147: LD_INT 32
89149: EQUAL
89150: IFFALSE 89160
// sPower := true ;
89152: LD_ADDR_EXP 181
89156: PUSH
89157: LD_INT 1
89159: ST_TO_ADDR
// if p3 = 33 then
89160: LD_VAR 0 3
89164: PUSH
89165: LD_INT 33
89167: EQUAL
89168: IFFALSE 89178
// sRandom := true ;
89170: LD_ADDR_EXP 182
89174: PUSH
89175: LD_INT 1
89177: ST_TO_ADDR
// if p3 = 34 then
89178: LD_VAR 0 3
89182: PUSH
89183: LD_INT 34
89185: EQUAL
89186: IFFALSE 89196
// sShield := true ;
89188: LD_ADDR_EXP 183
89192: PUSH
89193: LD_INT 1
89195: ST_TO_ADDR
// if p3 = 35 then
89196: LD_VAR 0 3
89200: PUSH
89201: LD_INT 35
89203: EQUAL
89204: IFFALSE 89214
// sTime := true ;
89206: LD_ADDR_EXP 184
89210: PUSH
89211: LD_INT 1
89213: ST_TO_ADDR
// if p3 = 36 then
89214: LD_VAR 0 3
89218: PUSH
89219: LD_INT 36
89221: EQUAL
89222: IFFALSE 89232
// sTools := true ;
89224: LD_ADDR_EXP 185
89228: PUSH
89229: LD_INT 1
89231: ST_TO_ADDR
// if p3 = 101 then
89232: LD_VAR 0 3
89236: PUSH
89237: LD_INT 101
89239: EQUAL
89240: IFFALSE 89250
// sSold := true ;
89242: LD_ADDR_EXP 150
89246: PUSH
89247: LD_INT 1
89249: ST_TO_ADDR
// if p3 = 102 then
89250: LD_VAR 0 3
89254: PUSH
89255: LD_INT 102
89257: EQUAL
89258: IFFALSE 89268
// sDiff := true ;
89260: LD_ADDR_EXP 151
89264: PUSH
89265: LD_INT 1
89267: ST_TO_ADDR
// if p3 = 103 then
89268: LD_VAR 0 3
89272: PUSH
89273: LD_INT 103
89275: EQUAL
89276: IFFALSE 89286
// sFog := true ;
89278: LD_ADDR_EXP 154
89282: PUSH
89283: LD_INT 1
89285: ST_TO_ADDR
// if p3 = 104 then
89286: LD_VAR 0 3
89290: PUSH
89291: LD_INT 104
89293: EQUAL
89294: IFFALSE 89304
// sReset := true ;
89296: LD_ADDR_EXP 155
89300: PUSH
89301: LD_INT 1
89303: ST_TO_ADDR
// if p3 = 105 then
89304: LD_VAR 0 3
89308: PUSH
89309: LD_INT 105
89311: EQUAL
89312: IFFALSE 89322
// sSun := true ;
89314: LD_ADDR_EXP 156
89318: PUSH
89319: LD_INT 1
89321: ST_TO_ADDR
// if p3 = 106 then
89322: LD_VAR 0 3
89326: PUSH
89327: LD_INT 106
89329: EQUAL
89330: IFFALSE 89340
// sTiger := true ;
89332: LD_ADDR_EXP 152
89336: PUSH
89337: LD_INT 1
89339: ST_TO_ADDR
// if p3 = 107 then
89340: LD_VAR 0 3
89344: PUSH
89345: LD_INT 107
89347: EQUAL
89348: IFFALSE 89358
// sBomb := true ;
89350: LD_ADDR_EXP 153
89354: PUSH
89355: LD_INT 1
89357: ST_TO_ADDR
// if p3 = 108 then
89358: LD_VAR 0 3
89362: PUSH
89363: LD_INT 108
89365: EQUAL
89366: IFFALSE 89376
// sWound := true ;
89368: LD_ADDR_EXP 161
89372: PUSH
89373: LD_INT 1
89375: ST_TO_ADDR
// if p3 = 109 then
89376: LD_VAR 0 3
89380: PUSH
89381: LD_INT 109
89383: EQUAL
89384: IFFALSE 89394
// sBetray := true ;
89386: LD_ADDR_EXP 165
89390: PUSH
89391: LD_INT 1
89393: ST_TO_ADDR
// if p3 = 110 then
89394: LD_VAR 0 3
89398: PUSH
89399: LD_INT 110
89401: EQUAL
89402: IFFALSE 89412
// sContamin := true ;
89404: LD_ADDR_EXP 166
89408: PUSH
89409: LD_INT 1
89411: ST_TO_ADDR
// if p3 = 111 then
89412: LD_VAR 0 3
89416: PUSH
89417: LD_INT 111
89419: EQUAL
89420: IFFALSE 89430
// sOil := true ;
89422: LD_ADDR_EXP 168
89426: PUSH
89427: LD_INT 1
89429: ST_TO_ADDR
// if p3 = 112 then
89430: LD_VAR 0 3
89434: PUSH
89435: LD_INT 112
89437: EQUAL
89438: IFFALSE 89448
// sStu := true ;
89440: LD_ADDR_EXP 172
89444: PUSH
89445: LD_INT 1
89447: ST_TO_ADDR
// if p3 = 113 then
89448: LD_VAR 0 3
89452: PUSH
89453: LD_INT 113
89455: EQUAL
89456: IFFALSE 89466
// sBazooka := true ;
89458: LD_ADDR_EXP 175
89462: PUSH
89463: LD_INT 1
89465: ST_TO_ADDR
// if p3 = 114 then
89466: LD_VAR 0 3
89470: PUSH
89471: LD_INT 114
89473: EQUAL
89474: IFFALSE 89484
// sMortar := true ;
89476: LD_ADDR_EXP 176
89480: PUSH
89481: LD_INT 1
89483: ST_TO_ADDR
// if p3 = 115 then
89484: LD_VAR 0 3
89488: PUSH
89489: LD_INT 115
89491: EQUAL
89492: IFFALSE 89502
// sRanger := true ;
89494: LD_ADDR_EXP 186
89498: PUSH
89499: LD_INT 1
89501: ST_TO_ADDR
// end ; if p2 = 101 then
89502: LD_VAR 0 2
89506: PUSH
89507: LD_INT 101
89509: EQUAL
89510: IFFALSE 89638
// begin case p3 of 1 :
89512: LD_VAR 0 3
89516: PUSH
89517: LD_INT 1
89519: DOUBLE
89520: EQUAL
89521: IFTRUE 89525
89523: GO 89532
89525: POP
// hHackUnlimitedResources ; 2 :
89526: CALL 100673 0 0
89530: GO 89638
89532: LD_INT 2
89534: DOUBLE
89535: EQUAL
89536: IFTRUE 89540
89538: GO 89547
89540: POP
// hHackSetLevel10 ; 3 :
89541: CALL 100806 0 0
89545: GO 89638
89547: LD_INT 3
89549: DOUBLE
89550: EQUAL
89551: IFTRUE 89555
89553: GO 89562
89555: POP
// hHackSetLevel10YourUnits ; 4 :
89556: CALL 100891 0 0
89560: GO 89638
89562: LD_INT 4
89564: DOUBLE
89565: EQUAL
89566: IFTRUE 89570
89568: GO 89577
89570: POP
// hHackInvincible ; 5 :
89571: CALL 101339 0 0
89575: GO 89638
89577: LD_INT 5
89579: DOUBLE
89580: EQUAL
89581: IFTRUE 89585
89583: GO 89592
89585: POP
// hHackInvisible ; 6 :
89586: CALL 101450 0 0
89590: GO 89638
89592: LD_INT 6
89594: DOUBLE
89595: EQUAL
89596: IFTRUE 89600
89598: GO 89607
89600: POP
// hHackChangeYourSide ; 7 :
89601: CALL 101507 0 0
89605: GO 89638
89607: LD_INT 7
89609: DOUBLE
89610: EQUAL
89611: IFTRUE 89615
89613: GO 89622
89615: POP
// hHackChangeUnitSide ; 8 :
89616: CALL 101549 0 0
89620: GO 89638
89622: LD_INT 8
89624: DOUBLE
89625: EQUAL
89626: IFTRUE 89630
89628: GO 89637
89630: POP
// hHackFog ; end ;
89631: CALL 101650 0 0
89635: GO 89638
89637: POP
// end ; end ;
89638: PPOPN 6
89640: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
89641: GO 89643
89643: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
89644: LD_STRING initStreamRollete();
89646: PPUSH
89647: CALL_OW 559
// InitStreamMode ;
89651: CALL 89660 0 0
// DefineStreamItems ( ) ;
89655: CALL 90100 0 0
// end ;
89659: END
// function InitStreamMode ; begin
89660: LD_INT 0
89662: PPUSH
// streamModeActive := false ;
89663: LD_ADDR_EXP 133
89667: PUSH
89668: LD_INT 0
89670: ST_TO_ADDR
// normalCounter := 36 ;
89671: LD_ADDR_EXP 134
89675: PUSH
89676: LD_INT 36
89678: ST_TO_ADDR
// hardcoreCounter := 16 ;
89679: LD_ADDR_EXP 135
89683: PUSH
89684: LD_INT 16
89686: ST_TO_ADDR
// sRocket := false ;
89687: LD_ADDR_EXP 138
89691: PUSH
89692: LD_INT 0
89694: ST_TO_ADDR
// sSpeed := false ;
89695: LD_ADDR_EXP 137
89699: PUSH
89700: LD_INT 0
89702: ST_TO_ADDR
// sEngine := false ;
89703: LD_ADDR_EXP 139
89707: PUSH
89708: LD_INT 0
89710: ST_TO_ADDR
// sSpec := false ;
89711: LD_ADDR_EXP 136
89715: PUSH
89716: LD_INT 0
89718: ST_TO_ADDR
// sLevel := false ;
89719: LD_ADDR_EXP 140
89723: PUSH
89724: LD_INT 0
89726: ST_TO_ADDR
// sArmoury := false ;
89727: LD_ADDR_EXP 141
89731: PUSH
89732: LD_INT 0
89734: ST_TO_ADDR
// sRadar := false ;
89735: LD_ADDR_EXP 142
89739: PUSH
89740: LD_INT 0
89742: ST_TO_ADDR
// sBunker := false ;
89743: LD_ADDR_EXP 143
89747: PUSH
89748: LD_INT 0
89750: ST_TO_ADDR
// sHack := false ;
89751: LD_ADDR_EXP 144
89755: PUSH
89756: LD_INT 0
89758: ST_TO_ADDR
// sFire := false ;
89759: LD_ADDR_EXP 145
89763: PUSH
89764: LD_INT 0
89766: ST_TO_ADDR
// sRefresh := false ;
89767: LD_ADDR_EXP 146
89771: PUSH
89772: LD_INT 0
89774: ST_TO_ADDR
// sExp := false ;
89775: LD_ADDR_EXP 147
89779: PUSH
89780: LD_INT 0
89782: ST_TO_ADDR
// sDepot := false ;
89783: LD_ADDR_EXP 148
89787: PUSH
89788: LD_INT 0
89790: ST_TO_ADDR
// sFlag := false ;
89791: LD_ADDR_EXP 149
89795: PUSH
89796: LD_INT 0
89798: ST_TO_ADDR
// sKamikadze := false ;
89799: LD_ADDR_EXP 157
89803: PUSH
89804: LD_INT 0
89806: ST_TO_ADDR
// sTroll := false ;
89807: LD_ADDR_EXP 158
89811: PUSH
89812: LD_INT 0
89814: ST_TO_ADDR
// sSlow := false ;
89815: LD_ADDR_EXP 159
89819: PUSH
89820: LD_INT 0
89822: ST_TO_ADDR
// sLack := false ;
89823: LD_ADDR_EXP 160
89827: PUSH
89828: LD_INT 0
89830: ST_TO_ADDR
// sTank := false ;
89831: LD_ADDR_EXP 162
89835: PUSH
89836: LD_INT 0
89838: ST_TO_ADDR
// sRemote := false ;
89839: LD_ADDR_EXP 163
89843: PUSH
89844: LD_INT 0
89846: ST_TO_ADDR
// sPowell := false ;
89847: LD_ADDR_EXP 164
89851: PUSH
89852: LD_INT 0
89854: ST_TO_ADDR
// sTeleport := false ;
89855: LD_ADDR_EXP 167
89859: PUSH
89860: LD_INT 0
89862: ST_TO_ADDR
// sOilTower := false ;
89863: LD_ADDR_EXP 169
89867: PUSH
89868: LD_INT 0
89870: ST_TO_ADDR
// sShovel := false ;
89871: LD_ADDR_EXP 170
89875: PUSH
89876: LD_INT 0
89878: ST_TO_ADDR
// sSheik := false ;
89879: LD_ADDR_EXP 171
89883: PUSH
89884: LD_INT 0
89886: ST_TO_ADDR
// sEarthquake := false ;
89887: LD_ADDR_EXP 173
89891: PUSH
89892: LD_INT 0
89894: ST_TO_ADDR
// sAI := false ;
89895: LD_ADDR_EXP 174
89899: PUSH
89900: LD_INT 0
89902: ST_TO_ADDR
// sCargo := false ;
89903: LD_ADDR_EXP 177
89907: PUSH
89908: LD_INT 0
89910: ST_TO_ADDR
// sDLaser := false ;
89911: LD_ADDR_EXP 178
89915: PUSH
89916: LD_INT 0
89918: ST_TO_ADDR
// sExchange := false ;
89919: LD_ADDR_EXP 179
89923: PUSH
89924: LD_INT 0
89926: ST_TO_ADDR
// sFac := false ;
89927: LD_ADDR_EXP 180
89931: PUSH
89932: LD_INT 0
89934: ST_TO_ADDR
// sPower := false ;
89935: LD_ADDR_EXP 181
89939: PUSH
89940: LD_INT 0
89942: ST_TO_ADDR
// sRandom := false ;
89943: LD_ADDR_EXP 182
89947: PUSH
89948: LD_INT 0
89950: ST_TO_ADDR
// sShield := false ;
89951: LD_ADDR_EXP 183
89955: PUSH
89956: LD_INT 0
89958: ST_TO_ADDR
// sTime := false ;
89959: LD_ADDR_EXP 184
89963: PUSH
89964: LD_INT 0
89966: ST_TO_ADDR
// sTools := false ;
89967: LD_ADDR_EXP 185
89971: PUSH
89972: LD_INT 0
89974: ST_TO_ADDR
// sSold := false ;
89975: LD_ADDR_EXP 150
89979: PUSH
89980: LD_INT 0
89982: ST_TO_ADDR
// sDiff := false ;
89983: LD_ADDR_EXP 151
89987: PUSH
89988: LD_INT 0
89990: ST_TO_ADDR
// sFog := false ;
89991: LD_ADDR_EXP 154
89995: PUSH
89996: LD_INT 0
89998: ST_TO_ADDR
// sReset := false ;
89999: LD_ADDR_EXP 155
90003: PUSH
90004: LD_INT 0
90006: ST_TO_ADDR
// sSun := false ;
90007: LD_ADDR_EXP 156
90011: PUSH
90012: LD_INT 0
90014: ST_TO_ADDR
// sTiger := false ;
90015: LD_ADDR_EXP 152
90019: PUSH
90020: LD_INT 0
90022: ST_TO_ADDR
// sBomb := false ;
90023: LD_ADDR_EXP 153
90027: PUSH
90028: LD_INT 0
90030: ST_TO_ADDR
// sWound := false ;
90031: LD_ADDR_EXP 161
90035: PUSH
90036: LD_INT 0
90038: ST_TO_ADDR
// sBetray := false ;
90039: LD_ADDR_EXP 165
90043: PUSH
90044: LD_INT 0
90046: ST_TO_ADDR
// sContamin := false ;
90047: LD_ADDR_EXP 166
90051: PUSH
90052: LD_INT 0
90054: ST_TO_ADDR
// sOil := false ;
90055: LD_ADDR_EXP 168
90059: PUSH
90060: LD_INT 0
90062: ST_TO_ADDR
// sStu := false ;
90063: LD_ADDR_EXP 172
90067: PUSH
90068: LD_INT 0
90070: ST_TO_ADDR
// sBazooka := false ;
90071: LD_ADDR_EXP 175
90075: PUSH
90076: LD_INT 0
90078: ST_TO_ADDR
// sMortar := false ;
90079: LD_ADDR_EXP 176
90083: PUSH
90084: LD_INT 0
90086: ST_TO_ADDR
// sRanger := false ;
90087: LD_ADDR_EXP 186
90091: PUSH
90092: LD_INT 0
90094: ST_TO_ADDR
// end ;
90095: LD_VAR 0 1
90099: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
90100: LD_INT 0
90102: PPUSH
90103: PPUSH
90104: PPUSH
90105: PPUSH
90106: PPUSH
// result := [ ] ;
90107: LD_ADDR_VAR 0 1
90111: PUSH
90112: EMPTY
90113: ST_TO_ADDR
// if campaign_id = 1 then
90114: LD_OWVAR 69
90118: PUSH
90119: LD_INT 1
90121: EQUAL
90122: IFFALSE 93060
// begin case mission_number of 1 :
90124: LD_OWVAR 70
90128: PUSH
90129: LD_INT 1
90131: DOUBLE
90132: EQUAL
90133: IFTRUE 90137
90135: GO 90201
90137: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
90138: LD_ADDR_VAR 0 1
90142: PUSH
90143: LD_INT 2
90145: PUSH
90146: LD_INT 4
90148: PUSH
90149: LD_INT 11
90151: PUSH
90152: LD_INT 12
90154: PUSH
90155: LD_INT 15
90157: PUSH
90158: LD_INT 16
90160: PUSH
90161: LD_INT 22
90163: PUSH
90164: LD_INT 23
90166: PUSH
90167: LD_INT 26
90169: PUSH
90170: EMPTY
90171: LIST
90172: LIST
90173: LIST
90174: LIST
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 101
90183: PUSH
90184: LD_INT 102
90186: PUSH
90187: LD_INT 106
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: LIST
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: ST_TO_ADDR
90199: GO 93058
90201: LD_INT 2
90203: DOUBLE
90204: EQUAL
90205: IFTRUE 90209
90207: GO 90281
90209: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
90210: LD_ADDR_VAR 0 1
90214: PUSH
90215: LD_INT 2
90217: PUSH
90218: LD_INT 4
90220: PUSH
90221: LD_INT 11
90223: PUSH
90224: LD_INT 12
90226: PUSH
90227: LD_INT 15
90229: PUSH
90230: LD_INT 16
90232: PUSH
90233: LD_INT 22
90235: PUSH
90236: LD_INT 23
90238: PUSH
90239: LD_INT 26
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: PUSH
90253: LD_INT 101
90255: PUSH
90256: LD_INT 102
90258: PUSH
90259: LD_INT 105
90261: PUSH
90262: LD_INT 106
90264: PUSH
90265: LD_INT 108
90267: PUSH
90268: EMPTY
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: ST_TO_ADDR
90279: GO 93058
90281: LD_INT 3
90283: DOUBLE
90284: EQUAL
90285: IFTRUE 90289
90287: GO 90365
90289: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
90290: LD_ADDR_VAR 0 1
90294: PUSH
90295: LD_INT 2
90297: PUSH
90298: LD_INT 4
90300: PUSH
90301: LD_INT 5
90303: PUSH
90304: LD_INT 11
90306: PUSH
90307: LD_INT 12
90309: PUSH
90310: LD_INT 15
90312: PUSH
90313: LD_INT 16
90315: PUSH
90316: LD_INT 22
90318: PUSH
90319: LD_INT 26
90321: PUSH
90322: LD_INT 36
90324: PUSH
90325: EMPTY
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: LIST
90331: LIST
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: PUSH
90337: LD_INT 101
90339: PUSH
90340: LD_INT 102
90342: PUSH
90343: LD_INT 105
90345: PUSH
90346: LD_INT 106
90348: PUSH
90349: LD_INT 108
90351: PUSH
90352: EMPTY
90353: LIST
90354: LIST
90355: LIST
90356: LIST
90357: LIST
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: ST_TO_ADDR
90363: GO 93058
90365: LD_INT 4
90367: DOUBLE
90368: EQUAL
90369: IFTRUE 90373
90371: GO 90457
90373: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
90374: LD_ADDR_VAR 0 1
90378: PUSH
90379: LD_INT 2
90381: PUSH
90382: LD_INT 4
90384: PUSH
90385: LD_INT 5
90387: PUSH
90388: LD_INT 8
90390: PUSH
90391: LD_INT 11
90393: PUSH
90394: LD_INT 12
90396: PUSH
90397: LD_INT 15
90399: PUSH
90400: LD_INT 16
90402: PUSH
90403: LD_INT 22
90405: PUSH
90406: LD_INT 23
90408: PUSH
90409: LD_INT 26
90411: PUSH
90412: LD_INT 36
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: PUSH
90429: LD_INT 101
90431: PUSH
90432: LD_INT 102
90434: PUSH
90435: LD_INT 105
90437: PUSH
90438: LD_INT 106
90440: PUSH
90441: LD_INT 108
90443: PUSH
90444: EMPTY
90445: LIST
90446: LIST
90447: LIST
90448: LIST
90449: LIST
90450: PUSH
90451: EMPTY
90452: LIST
90453: LIST
90454: ST_TO_ADDR
90455: GO 93058
90457: LD_INT 5
90459: DOUBLE
90460: EQUAL
90461: IFTRUE 90465
90463: GO 90565
90465: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
90466: LD_ADDR_VAR 0 1
90470: PUSH
90471: LD_INT 2
90473: PUSH
90474: LD_INT 4
90476: PUSH
90477: LD_INT 5
90479: PUSH
90480: LD_INT 6
90482: PUSH
90483: LD_INT 8
90485: PUSH
90486: LD_INT 11
90488: PUSH
90489: LD_INT 12
90491: PUSH
90492: LD_INT 15
90494: PUSH
90495: LD_INT 16
90497: PUSH
90498: LD_INT 22
90500: PUSH
90501: LD_INT 23
90503: PUSH
90504: LD_INT 25
90506: PUSH
90507: LD_INT 26
90509: PUSH
90510: LD_INT 36
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: LIST
90517: LIST
90518: LIST
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: LIST
90528: PUSH
90529: LD_INT 101
90531: PUSH
90532: LD_INT 102
90534: PUSH
90535: LD_INT 105
90537: PUSH
90538: LD_INT 106
90540: PUSH
90541: LD_INT 108
90543: PUSH
90544: LD_INT 109
90546: PUSH
90547: LD_INT 112
90549: PUSH
90550: EMPTY
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: PUSH
90559: EMPTY
90560: LIST
90561: LIST
90562: ST_TO_ADDR
90563: GO 93058
90565: LD_INT 6
90567: DOUBLE
90568: EQUAL
90569: IFTRUE 90573
90571: GO 90693
90573: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
90574: LD_ADDR_VAR 0 1
90578: PUSH
90579: LD_INT 2
90581: PUSH
90582: LD_INT 4
90584: PUSH
90585: LD_INT 5
90587: PUSH
90588: LD_INT 6
90590: PUSH
90591: LD_INT 8
90593: PUSH
90594: LD_INT 11
90596: PUSH
90597: LD_INT 12
90599: PUSH
90600: LD_INT 15
90602: PUSH
90603: LD_INT 16
90605: PUSH
90606: LD_INT 20
90608: PUSH
90609: LD_INT 21
90611: PUSH
90612: LD_INT 22
90614: PUSH
90615: LD_INT 23
90617: PUSH
90618: LD_INT 25
90620: PUSH
90621: LD_INT 26
90623: PUSH
90624: LD_INT 30
90626: PUSH
90627: LD_INT 31
90629: PUSH
90630: LD_INT 32
90632: PUSH
90633: LD_INT 36
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: PUSH
90657: LD_INT 101
90659: PUSH
90660: LD_INT 102
90662: PUSH
90663: LD_INT 105
90665: PUSH
90666: LD_INT 106
90668: PUSH
90669: LD_INT 108
90671: PUSH
90672: LD_INT 109
90674: PUSH
90675: LD_INT 112
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: LIST
90682: LIST
90683: LIST
90684: LIST
90685: LIST
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: ST_TO_ADDR
90691: GO 93058
90693: LD_INT 7
90695: DOUBLE
90696: EQUAL
90697: IFTRUE 90701
90699: GO 90801
90701: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
90702: LD_ADDR_VAR 0 1
90706: PUSH
90707: LD_INT 2
90709: PUSH
90710: LD_INT 4
90712: PUSH
90713: LD_INT 5
90715: PUSH
90716: LD_INT 7
90718: PUSH
90719: LD_INT 11
90721: PUSH
90722: LD_INT 12
90724: PUSH
90725: LD_INT 15
90727: PUSH
90728: LD_INT 16
90730: PUSH
90731: LD_INT 20
90733: PUSH
90734: LD_INT 21
90736: PUSH
90737: LD_INT 22
90739: PUSH
90740: LD_INT 23
90742: PUSH
90743: LD_INT 25
90745: PUSH
90746: LD_INT 26
90748: PUSH
90749: EMPTY
90750: LIST
90751: LIST
90752: LIST
90753: LIST
90754: LIST
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: PUSH
90765: LD_INT 101
90767: PUSH
90768: LD_INT 102
90770: PUSH
90771: LD_INT 103
90773: PUSH
90774: LD_INT 105
90776: PUSH
90777: LD_INT 106
90779: PUSH
90780: LD_INT 108
90782: PUSH
90783: LD_INT 112
90785: PUSH
90786: EMPTY
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: ST_TO_ADDR
90799: GO 93058
90801: LD_INT 8
90803: DOUBLE
90804: EQUAL
90805: IFTRUE 90809
90807: GO 90937
90809: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
90810: LD_ADDR_VAR 0 1
90814: PUSH
90815: LD_INT 2
90817: PUSH
90818: LD_INT 4
90820: PUSH
90821: LD_INT 5
90823: PUSH
90824: LD_INT 6
90826: PUSH
90827: LD_INT 7
90829: PUSH
90830: LD_INT 8
90832: PUSH
90833: LD_INT 11
90835: PUSH
90836: LD_INT 12
90838: PUSH
90839: LD_INT 15
90841: PUSH
90842: LD_INT 16
90844: PUSH
90845: LD_INT 20
90847: PUSH
90848: LD_INT 21
90850: PUSH
90851: LD_INT 22
90853: PUSH
90854: LD_INT 23
90856: PUSH
90857: LD_INT 25
90859: PUSH
90860: LD_INT 26
90862: PUSH
90863: LD_INT 30
90865: PUSH
90866: LD_INT 31
90868: PUSH
90869: LD_INT 32
90871: PUSH
90872: LD_INT 36
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: LIST
90888: LIST
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: PUSH
90897: LD_INT 101
90899: PUSH
90900: LD_INT 102
90902: PUSH
90903: LD_INT 103
90905: PUSH
90906: LD_INT 105
90908: PUSH
90909: LD_INT 106
90911: PUSH
90912: LD_INT 108
90914: PUSH
90915: LD_INT 109
90917: PUSH
90918: LD_INT 112
90920: PUSH
90921: EMPTY
90922: LIST
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: LIST
90928: LIST
90929: LIST
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: ST_TO_ADDR
90935: GO 93058
90937: LD_INT 9
90939: DOUBLE
90940: EQUAL
90941: IFTRUE 90945
90943: GO 91081
90945: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
90946: LD_ADDR_VAR 0 1
90950: PUSH
90951: LD_INT 2
90953: PUSH
90954: LD_INT 4
90956: PUSH
90957: LD_INT 5
90959: PUSH
90960: LD_INT 6
90962: PUSH
90963: LD_INT 7
90965: PUSH
90966: LD_INT 8
90968: PUSH
90969: LD_INT 11
90971: PUSH
90972: LD_INT 12
90974: PUSH
90975: LD_INT 15
90977: PUSH
90978: LD_INT 16
90980: PUSH
90981: LD_INT 20
90983: PUSH
90984: LD_INT 21
90986: PUSH
90987: LD_INT 22
90989: PUSH
90990: LD_INT 23
90992: PUSH
90993: LD_INT 25
90995: PUSH
90996: LD_INT 26
90998: PUSH
90999: LD_INT 28
91001: PUSH
91002: LD_INT 30
91004: PUSH
91005: LD_INT 31
91007: PUSH
91008: LD_INT 32
91010: PUSH
91011: LD_INT 36
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: PUSH
91037: LD_INT 101
91039: PUSH
91040: LD_INT 102
91042: PUSH
91043: LD_INT 103
91045: PUSH
91046: LD_INT 105
91048: PUSH
91049: LD_INT 106
91051: PUSH
91052: LD_INT 108
91054: PUSH
91055: LD_INT 109
91057: PUSH
91058: LD_INT 112
91060: PUSH
91061: LD_INT 114
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: LIST
91068: LIST
91069: LIST
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: PUSH
91075: EMPTY
91076: LIST
91077: LIST
91078: ST_TO_ADDR
91079: GO 93058
91081: LD_INT 10
91083: DOUBLE
91084: EQUAL
91085: IFTRUE 91089
91087: GO 91273
91089: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
91090: LD_ADDR_VAR 0 1
91094: PUSH
91095: LD_INT 2
91097: PUSH
91098: LD_INT 4
91100: PUSH
91101: LD_INT 5
91103: PUSH
91104: LD_INT 6
91106: PUSH
91107: LD_INT 7
91109: PUSH
91110: LD_INT 8
91112: PUSH
91113: LD_INT 9
91115: PUSH
91116: LD_INT 10
91118: PUSH
91119: LD_INT 11
91121: PUSH
91122: LD_INT 12
91124: PUSH
91125: LD_INT 13
91127: PUSH
91128: LD_INT 14
91130: PUSH
91131: LD_INT 15
91133: PUSH
91134: LD_INT 16
91136: PUSH
91137: LD_INT 17
91139: PUSH
91140: LD_INT 18
91142: PUSH
91143: LD_INT 19
91145: PUSH
91146: LD_INT 20
91148: PUSH
91149: LD_INT 21
91151: PUSH
91152: LD_INT 22
91154: PUSH
91155: LD_INT 23
91157: PUSH
91158: LD_INT 24
91160: PUSH
91161: LD_INT 25
91163: PUSH
91164: LD_INT 26
91166: PUSH
91167: LD_INT 28
91169: PUSH
91170: LD_INT 30
91172: PUSH
91173: LD_INT 31
91175: PUSH
91176: LD_INT 32
91178: PUSH
91179: LD_INT 36
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: LIST
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: PUSH
91213: LD_INT 101
91215: PUSH
91216: LD_INT 102
91218: PUSH
91219: LD_INT 103
91221: PUSH
91222: LD_INT 104
91224: PUSH
91225: LD_INT 105
91227: PUSH
91228: LD_INT 106
91230: PUSH
91231: LD_INT 107
91233: PUSH
91234: LD_INT 108
91236: PUSH
91237: LD_INT 109
91239: PUSH
91240: LD_INT 110
91242: PUSH
91243: LD_INT 111
91245: PUSH
91246: LD_INT 112
91248: PUSH
91249: LD_INT 114
91251: PUSH
91252: EMPTY
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: ST_TO_ADDR
91271: GO 93058
91273: LD_INT 11
91275: DOUBLE
91276: EQUAL
91277: IFTRUE 91281
91279: GO 91473
91281: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
91282: LD_ADDR_VAR 0 1
91286: PUSH
91287: LD_INT 2
91289: PUSH
91290: LD_INT 3
91292: PUSH
91293: LD_INT 4
91295: PUSH
91296: LD_INT 5
91298: PUSH
91299: LD_INT 6
91301: PUSH
91302: LD_INT 7
91304: PUSH
91305: LD_INT 8
91307: PUSH
91308: LD_INT 9
91310: PUSH
91311: LD_INT 10
91313: PUSH
91314: LD_INT 11
91316: PUSH
91317: LD_INT 12
91319: PUSH
91320: LD_INT 13
91322: PUSH
91323: LD_INT 14
91325: PUSH
91326: LD_INT 15
91328: PUSH
91329: LD_INT 16
91331: PUSH
91332: LD_INT 17
91334: PUSH
91335: LD_INT 18
91337: PUSH
91338: LD_INT 19
91340: PUSH
91341: LD_INT 20
91343: PUSH
91344: LD_INT 21
91346: PUSH
91347: LD_INT 22
91349: PUSH
91350: LD_INT 23
91352: PUSH
91353: LD_INT 24
91355: PUSH
91356: LD_INT 25
91358: PUSH
91359: LD_INT 26
91361: PUSH
91362: LD_INT 28
91364: PUSH
91365: LD_INT 30
91367: PUSH
91368: LD_INT 31
91370: PUSH
91371: LD_INT 32
91373: PUSH
91374: LD_INT 34
91376: PUSH
91377: LD_INT 36
91379: PUSH
91380: EMPTY
91381: LIST
91382: LIST
91383: LIST
91384: LIST
91385: LIST
91386: LIST
91387: LIST
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: LIST
91404: LIST
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: PUSH
91413: LD_INT 101
91415: PUSH
91416: LD_INT 102
91418: PUSH
91419: LD_INT 103
91421: PUSH
91422: LD_INT 104
91424: PUSH
91425: LD_INT 105
91427: PUSH
91428: LD_INT 106
91430: PUSH
91431: LD_INT 107
91433: PUSH
91434: LD_INT 108
91436: PUSH
91437: LD_INT 109
91439: PUSH
91440: LD_INT 110
91442: PUSH
91443: LD_INT 111
91445: PUSH
91446: LD_INT 112
91448: PUSH
91449: LD_INT 114
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: PUSH
91467: EMPTY
91468: LIST
91469: LIST
91470: ST_TO_ADDR
91471: GO 93058
91473: LD_INT 12
91475: DOUBLE
91476: EQUAL
91477: IFTRUE 91481
91479: GO 91689
91481: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
91482: LD_ADDR_VAR 0 1
91486: PUSH
91487: LD_INT 1
91489: PUSH
91490: LD_INT 2
91492: PUSH
91493: LD_INT 3
91495: PUSH
91496: LD_INT 4
91498: PUSH
91499: LD_INT 5
91501: PUSH
91502: LD_INT 6
91504: PUSH
91505: LD_INT 7
91507: PUSH
91508: LD_INT 8
91510: PUSH
91511: LD_INT 9
91513: PUSH
91514: LD_INT 10
91516: PUSH
91517: LD_INT 11
91519: PUSH
91520: LD_INT 12
91522: PUSH
91523: LD_INT 13
91525: PUSH
91526: LD_INT 14
91528: PUSH
91529: LD_INT 15
91531: PUSH
91532: LD_INT 16
91534: PUSH
91535: LD_INT 17
91537: PUSH
91538: LD_INT 18
91540: PUSH
91541: LD_INT 19
91543: PUSH
91544: LD_INT 20
91546: PUSH
91547: LD_INT 21
91549: PUSH
91550: LD_INT 22
91552: PUSH
91553: LD_INT 23
91555: PUSH
91556: LD_INT 24
91558: PUSH
91559: LD_INT 25
91561: PUSH
91562: LD_INT 26
91564: PUSH
91565: LD_INT 27
91567: PUSH
91568: LD_INT 28
91570: PUSH
91571: LD_INT 30
91573: PUSH
91574: LD_INT 31
91576: PUSH
91577: LD_INT 32
91579: PUSH
91580: LD_INT 33
91582: PUSH
91583: LD_INT 34
91585: PUSH
91586: LD_INT 36
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: LIST
91593: LIST
91594: LIST
91595: LIST
91596: LIST
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: PUSH
91625: LD_INT 101
91627: PUSH
91628: LD_INT 102
91630: PUSH
91631: LD_INT 103
91633: PUSH
91634: LD_INT 104
91636: PUSH
91637: LD_INT 105
91639: PUSH
91640: LD_INT 106
91642: PUSH
91643: LD_INT 107
91645: PUSH
91646: LD_INT 108
91648: PUSH
91649: LD_INT 109
91651: PUSH
91652: LD_INT 110
91654: PUSH
91655: LD_INT 111
91657: PUSH
91658: LD_INT 112
91660: PUSH
91661: LD_INT 113
91663: PUSH
91664: LD_INT 114
91666: PUSH
91667: EMPTY
91668: LIST
91669: LIST
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: ST_TO_ADDR
91687: GO 93058
91689: LD_INT 13
91691: DOUBLE
91692: EQUAL
91693: IFTRUE 91697
91695: GO 91893
91697: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
91698: LD_ADDR_VAR 0 1
91702: PUSH
91703: LD_INT 1
91705: PUSH
91706: LD_INT 2
91708: PUSH
91709: LD_INT 3
91711: PUSH
91712: LD_INT 4
91714: PUSH
91715: LD_INT 5
91717: PUSH
91718: LD_INT 8
91720: PUSH
91721: LD_INT 9
91723: PUSH
91724: LD_INT 10
91726: PUSH
91727: LD_INT 11
91729: PUSH
91730: LD_INT 12
91732: PUSH
91733: LD_INT 14
91735: PUSH
91736: LD_INT 15
91738: PUSH
91739: LD_INT 16
91741: PUSH
91742: LD_INT 17
91744: PUSH
91745: LD_INT 18
91747: PUSH
91748: LD_INT 19
91750: PUSH
91751: LD_INT 20
91753: PUSH
91754: LD_INT 21
91756: PUSH
91757: LD_INT 22
91759: PUSH
91760: LD_INT 23
91762: PUSH
91763: LD_INT 24
91765: PUSH
91766: LD_INT 25
91768: PUSH
91769: LD_INT 26
91771: PUSH
91772: LD_INT 27
91774: PUSH
91775: LD_INT 28
91777: PUSH
91778: LD_INT 30
91780: PUSH
91781: LD_INT 31
91783: PUSH
91784: LD_INT 32
91786: PUSH
91787: LD_INT 33
91789: PUSH
91790: LD_INT 34
91792: PUSH
91793: LD_INT 36
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: LIST
91800: LIST
91801: LIST
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: LIST
91807: LIST
91808: LIST
91809: LIST
91810: LIST
91811: LIST
91812: LIST
91813: LIST
91814: LIST
91815: LIST
91816: LIST
91817: LIST
91818: LIST
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: PUSH
91829: LD_INT 101
91831: PUSH
91832: LD_INT 102
91834: PUSH
91835: LD_INT 103
91837: PUSH
91838: LD_INT 104
91840: PUSH
91841: LD_INT 105
91843: PUSH
91844: LD_INT 106
91846: PUSH
91847: LD_INT 107
91849: PUSH
91850: LD_INT 108
91852: PUSH
91853: LD_INT 109
91855: PUSH
91856: LD_INT 110
91858: PUSH
91859: LD_INT 111
91861: PUSH
91862: LD_INT 112
91864: PUSH
91865: LD_INT 113
91867: PUSH
91868: LD_INT 114
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: LIST
91880: LIST
91881: LIST
91882: LIST
91883: LIST
91884: LIST
91885: LIST
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: ST_TO_ADDR
91891: GO 93058
91893: LD_INT 14
91895: DOUBLE
91896: EQUAL
91897: IFTRUE 91901
91899: GO 92113
91901: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
91902: LD_ADDR_VAR 0 1
91906: PUSH
91907: LD_INT 1
91909: PUSH
91910: LD_INT 2
91912: PUSH
91913: LD_INT 3
91915: PUSH
91916: LD_INT 4
91918: PUSH
91919: LD_INT 5
91921: PUSH
91922: LD_INT 6
91924: PUSH
91925: LD_INT 7
91927: PUSH
91928: LD_INT 8
91930: PUSH
91931: LD_INT 9
91933: PUSH
91934: LD_INT 10
91936: PUSH
91937: LD_INT 11
91939: PUSH
91940: LD_INT 12
91942: PUSH
91943: LD_INT 13
91945: PUSH
91946: LD_INT 14
91948: PUSH
91949: LD_INT 15
91951: PUSH
91952: LD_INT 16
91954: PUSH
91955: LD_INT 17
91957: PUSH
91958: LD_INT 18
91960: PUSH
91961: LD_INT 19
91963: PUSH
91964: LD_INT 20
91966: PUSH
91967: LD_INT 21
91969: PUSH
91970: LD_INT 22
91972: PUSH
91973: LD_INT 23
91975: PUSH
91976: LD_INT 24
91978: PUSH
91979: LD_INT 25
91981: PUSH
91982: LD_INT 26
91984: PUSH
91985: LD_INT 27
91987: PUSH
91988: LD_INT 28
91990: PUSH
91991: LD_INT 29
91993: PUSH
91994: LD_INT 30
91996: PUSH
91997: LD_INT 31
91999: PUSH
92000: LD_INT 32
92002: PUSH
92003: LD_INT 33
92005: PUSH
92006: LD_INT 34
92008: PUSH
92009: LD_INT 36
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: LIST
92018: LIST
92019: LIST
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: LIST
92040: LIST
92041: LIST
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: PUSH
92049: LD_INT 101
92051: PUSH
92052: LD_INT 102
92054: PUSH
92055: LD_INT 103
92057: PUSH
92058: LD_INT 104
92060: PUSH
92061: LD_INT 105
92063: PUSH
92064: LD_INT 106
92066: PUSH
92067: LD_INT 107
92069: PUSH
92070: LD_INT 108
92072: PUSH
92073: LD_INT 109
92075: PUSH
92076: LD_INT 110
92078: PUSH
92079: LD_INT 111
92081: PUSH
92082: LD_INT 112
92084: PUSH
92085: LD_INT 113
92087: PUSH
92088: LD_INT 114
92090: PUSH
92091: EMPTY
92092: LIST
92093: LIST
92094: LIST
92095: LIST
92096: LIST
92097: LIST
92098: LIST
92099: LIST
92100: LIST
92101: LIST
92102: LIST
92103: LIST
92104: LIST
92105: LIST
92106: PUSH
92107: EMPTY
92108: LIST
92109: LIST
92110: ST_TO_ADDR
92111: GO 93058
92113: LD_INT 15
92115: DOUBLE
92116: EQUAL
92117: IFTRUE 92121
92119: GO 92333
92121: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
92122: LD_ADDR_VAR 0 1
92126: PUSH
92127: LD_INT 1
92129: PUSH
92130: LD_INT 2
92132: PUSH
92133: LD_INT 3
92135: PUSH
92136: LD_INT 4
92138: PUSH
92139: LD_INT 5
92141: PUSH
92142: LD_INT 6
92144: PUSH
92145: LD_INT 7
92147: PUSH
92148: LD_INT 8
92150: PUSH
92151: LD_INT 9
92153: PUSH
92154: LD_INT 10
92156: PUSH
92157: LD_INT 11
92159: PUSH
92160: LD_INT 12
92162: PUSH
92163: LD_INT 13
92165: PUSH
92166: LD_INT 14
92168: PUSH
92169: LD_INT 15
92171: PUSH
92172: LD_INT 16
92174: PUSH
92175: LD_INT 17
92177: PUSH
92178: LD_INT 18
92180: PUSH
92181: LD_INT 19
92183: PUSH
92184: LD_INT 20
92186: PUSH
92187: LD_INT 21
92189: PUSH
92190: LD_INT 22
92192: PUSH
92193: LD_INT 23
92195: PUSH
92196: LD_INT 24
92198: PUSH
92199: LD_INT 25
92201: PUSH
92202: LD_INT 26
92204: PUSH
92205: LD_INT 27
92207: PUSH
92208: LD_INT 28
92210: PUSH
92211: LD_INT 29
92213: PUSH
92214: LD_INT 30
92216: PUSH
92217: LD_INT 31
92219: PUSH
92220: LD_INT 32
92222: PUSH
92223: LD_INT 33
92225: PUSH
92226: LD_INT 34
92228: PUSH
92229: LD_INT 36
92231: PUSH
92232: EMPTY
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: LIST
92268: PUSH
92269: LD_INT 101
92271: PUSH
92272: LD_INT 102
92274: PUSH
92275: LD_INT 103
92277: PUSH
92278: LD_INT 104
92280: PUSH
92281: LD_INT 105
92283: PUSH
92284: LD_INT 106
92286: PUSH
92287: LD_INT 107
92289: PUSH
92290: LD_INT 108
92292: PUSH
92293: LD_INT 109
92295: PUSH
92296: LD_INT 110
92298: PUSH
92299: LD_INT 111
92301: PUSH
92302: LD_INT 112
92304: PUSH
92305: LD_INT 113
92307: PUSH
92308: LD_INT 114
92310: PUSH
92311: EMPTY
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: LIST
92321: LIST
92322: LIST
92323: LIST
92324: LIST
92325: LIST
92326: PUSH
92327: EMPTY
92328: LIST
92329: LIST
92330: ST_TO_ADDR
92331: GO 93058
92333: LD_INT 16
92335: DOUBLE
92336: EQUAL
92337: IFTRUE 92341
92339: GO 92465
92341: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
92342: LD_ADDR_VAR 0 1
92346: PUSH
92347: LD_INT 2
92349: PUSH
92350: LD_INT 4
92352: PUSH
92353: LD_INT 5
92355: PUSH
92356: LD_INT 7
92358: PUSH
92359: LD_INT 11
92361: PUSH
92362: LD_INT 12
92364: PUSH
92365: LD_INT 15
92367: PUSH
92368: LD_INT 16
92370: PUSH
92371: LD_INT 20
92373: PUSH
92374: LD_INT 21
92376: PUSH
92377: LD_INT 22
92379: PUSH
92380: LD_INT 23
92382: PUSH
92383: LD_INT 25
92385: PUSH
92386: LD_INT 26
92388: PUSH
92389: LD_INT 30
92391: PUSH
92392: LD_INT 31
92394: PUSH
92395: LD_INT 32
92397: PUSH
92398: LD_INT 33
92400: PUSH
92401: LD_INT 34
92403: PUSH
92404: EMPTY
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: LIST
92415: LIST
92416: LIST
92417: LIST
92418: LIST
92419: LIST
92420: LIST
92421: LIST
92422: LIST
92423: LIST
92424: PUSH
92425: LD_INT 101
92427: PUSH
92428: LD_INT 102
92430: PUSH
92431: LD_INT 103
92433: PUSH
92434: LD_INT 106
92436: PUSH
92437: LD_INT 108
92439: PUSH
92440: LD_INT 112
92442: PUSH
92443: LD_INT 113
92445: PUSH
92446: LD_INT 114
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: LIST
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: ST_TO_ADDR
92463: GO 93058
92465: LD_INT 17
92467: DOUBLE
92468: EQUAL
92469: IFTRUE 92473
92471: GO 92685
92473: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
92474: LD_ADDR_VAR 0 1
92478: PUSH
92479: LD_INT 1
92481: PUSH
92482: LD_INT 2
92484: PUSH
92485: LD_INT 3
92487: PUSH
92488: LD_INT 4
92490: PUSH
92491: LD_INT 5
92493: PUSH
92494: LD_INT 6
92496: PUSH
92497: LD_INT 7
92499: PUSH
92500: LD_INT 8
92502: PUSH
92503: LD_INT 9
92505: PUSH
92506: LD_INT 10
92508: PUSH
92509: LD_INT 11
92511: PUSH
92512: LD_INT 12
92514: PUSH
92515: LD_INT 13
92517: PUSH
92518: LD_INT 14
92520: PUSH
92521: LD_INT 15
92523: PUSH
92524: LD_INT 16
92526: PUSH
92527: LD_INT 17
92529: PUSH
92530: LD_INT 18
92532: PUSH
92533: LD_INT 19
92535: PUSH
92536: LD_INT 20
92538: PUSH
92539: LD_INT 21
92541: PUSH
92542: LD_INT 22
92544: PUSH
92545: LD_INT 23
92547: PUSH
92548: LD_INT 24
92550: PUSH
92551: LD_INT 25
92553: PUSH
92554: LD_INT 26
92556: PUSH
92557: LD_INT 27
92559: PUSH
92560: LD_INT 28
92562: PUSH
92563: LD_INT 29
92565: PUSH
92566: LD_INT 30
92568: PUSH
92569: LD_INT 31
92571: PUSH
92572: LD_INT 32
92574: PUSH
92575: LD_INT 33
92577: PUSH
92578: LD_INT 34
92580: PUSH
92581: LD_INT 36
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: LIST
92592: LIST
92593: LIST
92594: LIST
92595: LIST
92596: LIST
92597: LIST
92598: LIST
92599: LIST
92600: LIST
92601: LIST
92602: LIST
92603: LIST
92604: LIST
92605: LIST
92606: LIST
92607: LIST
92608: LIST
92609: LIST
92610: LIST
92611: LIST
92612: LIST
92613: LIST
92614: LIST
92615: LIST
92616: LIST
92617: LIST
92618: LIST
92619: LIST
92620: PUSH
92621: LD_INT 101
92623: PUSH
92624: LD_INT 102
92626: PUSH
92627: LD_INT 103
92629: PUSH
92630: LD_INT 104
92632: PUSH
92633: LD_INT 105
92635: PUSH
92636: LD_INT 106
92638: PUSH
92639: LD_INT 107
92641: PUSH
92642: LD_INT 108
92644: PUSH
92645: LD_INT 109
92647: PUSH
92648: LD_INT 110
92650: PUSH
92651: LD_INT 111
92653: PUSH
92654: LD_INT 112
92656: PUSH
92657: LD_INT 113
92659: PUSH
92660: LD_INT 114
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: PUSH
92679: EMPTY
92680: LIST
92681: LIST
92682: ST_TO_ADDR
92683: GO 93058
92685: LD_INT 18
92687: DOUBLE
92688: EQUAL
92689: IFTRUE 92693
92691: GO 92829
92693: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
92694: LD_ADDR_VAR 0 1
92698: PUSH
92699: LD_INT 2
92701: PUSH
92702: LD_INT 4
92704: PUSH
92705: LD_INT 5
92707: PUSH
92708: LD_INT 7
92710: PUSH
92711: LD_INT 11
92713: PUSH
92714: LD_INT 12
92716: PUSH
92717: LD_INT 15
92719: PUSH
92720: LD_INT 16
92722: PUSH
92723: LD_INT 20
92725: PUSH
92726: LD_INT 21
92728: PUSH
92729: LD_INT 22
92731: PUSH
92732: LD_INT 23
92734: PUSH
92735: LD_INT 25
92737: PUSH
92738: LD_INT 26
92740: PUSH
92741: LD_INT 30
92743: PUSH
92744: LD_INT 31
92746: PUSH
92747: LD_INT 32
92749: PUSH
92750: LD_INT 33
92752: PUSH
92753: LD_INT 34
92755: PUSH
92756: LD_INT 35
92758: PUSH
92759: LD_INT 36
92761: PUSH
92762: EMPTY
92763: LIST
92764: LIST
92765: LIST
92766: LIST
92767: LIST
92768: LIST
92769: LIST
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: PUSH
92785: LD_INT 101
92787: PUSH
92788: LD_INT 102
92790: PUSH
92791: LD_INT 103
92793: PUSH
92794: LD_INT 106
92796: PUSH
92797: LD_INT 108
92799: PUSH
92800: LD_INT 112
92802: PUSH
92803: LD_INT 113
92805: PUSH
92806: LD_INT 114
92808: PUSH
92809: LD_INT 115
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: PUSH
92823: EMPTY
92824: LIST
92825: LIST
92826: ST_TO_ADDR
92827: GO 93058
92829: LD_INT 19
92831: DOUBLE
92832: EQUAL
92833: IFTRUE 92837
92835: GO 93057
92837: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
92838: LD_ADDR_VAR 0 1
92842: PUSH
92843: LD_INT 1
92845: PUSH
92846: LD_INT 2
92848: PUSH
92849: LD_INT 3
92851: PUSH
92852: LD_INT 4
92854: PUSH
92855: LD_INT 5
92857: PUSH
92858: LD_INT 6
92860: PUSH
92861: LD_INT 7
92863: PUSH
92864: LD_INT 8
92866: PUSH
92867: LD_INT 9
92869: PUSH
92870: LD_INT 10
92872: PUSH
92873: LD_INT 11
92875: PUSH
92876: LD_INT 12
92878: PUSH
92879: LD_INT 13
92881: PUSH
92882: LD_INT 14
92884: PUSH
92885: LD_INT 15
92887: PUSH
92888: LD_INT 16
92890: PUSH
92891: LD_INT 17
92893: PUSH
92894: LD_INT 18
92896: PUSH
92897: LD_INT 19
92899: PUSH
92900: LD_INT 20
92902: PUSH
92903: LD_INT 21
92905: PUSH
92906: LD_INT 22
92908: PUSH
92909: LD_INT 23
92911: PUSH
92912: LD_INT 24
92914: PUSH
92915: LD_INT 25
92917: PUSH
92918: LD_INT 26
92920: PUSH
92921: LD_INT 27
92923: PUSH
92924: LD_INT 28
92926: PUSH
92927: LD_INT 29
92929: PUSH
92930: LD_INT 30
92932: PUSH
92933: LD_INT 31
92935: PUSH
92936: LD_INT 32
92938: PUSH
92939: LD_INT 33
92941: PUSH
92942: LD_INT 34
92944: PUSH
92945: LD_INT 35
92947: PUSH
92948: LD_INT 36
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: LIST
92957: LIST
92958: LIST
92959: LIST
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: LIST
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: PUSH
92989: LD_INT 101
92991: PUSH
92992: LD_INT 102
92994: PUSH
92995: LD_INT 103
92997: PUSH
92998: LD_INT 104
93000: PUSH
93001: LD_INT 105
93003: PUSH
93004: LD_INT 106
93006: PUSH
93007: LD_INT 107
93009: PUSH
93010: LD_INT 108
93012: PUSH
93013: LD_INT 109
93015: PUSH
93016: LD_INT 110
93018: PUSH
93019: LD_INT 111
93021: PUSH
93022: LD_INT 112
93024: PUSH
93025: LD_INT 113
93027: PUSH
93028: LD_INT 114
93030: PUSH
93031: LD_INT 115
93033: PUSH
93034: EMPTY
93035: LIST
93036: LIST
93037: LIST
93038: LIST
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: LIST
93047: LIST
93048: LIST
93049: LIST
93050: PUSH
93051: EMPTY
93052: LIST
93053: LIST
93054: ST_TO_ADDR
93055: GO 93058
93057: POP
// end else
93058: GO 93277
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
93060: LD_ADDR_VAR 0 1
93064: PUSH
93065: LD_INT 1
93067: PUSH
93068: LD_INT 2
93070: PUSH
93071: LD_INT 3
93073: PUSH
93074: LD_INT 4
93076: PUSH
93077: LD_INT 5
93079: PUSH
93080: LD_INT 6
93082: PUSH
93083: LD_INT 7
93085: PUSH
93086: LD_INT 8
93088: PUSH
93089: LD_INT 9
93091: PUSH
93092: LD_INT 10
93094: PUSH
93095: LD_INT 11
93097: PUSH
93098: LD_INT 12
93100: PUSH
93101: LD_INT 13
93103: PUSH
93104: LD_INT 14
93106: PUSH
93107: LD_INT 15
93109: PUSH
93110: LD_INT 16
93112: PUSH
93113: LD_INT 17
93115: PUSH
93116: LD_INT 18
93118: PUSH
93119: LD_INT 19
93121: PUSH
93122: LD_INT 20
93124: PUSH
93125: LD_INT 21
93127: PUSH
93128: LD_INT 22
93130: PUSH
93131: LD_INT 23
93133: PUSH
93134: LD_INT 24
93136: PUSH
93137: LD_INT 25
93139: PUSH
93140: LD_INT 26
93142: PUSH
93143: LD_INT 27
93145: PUSH
93146: LD_INT 28
93148: PUSH
93149: LD_INT 29
93151: PUSH
93152: LD_INT 30
93154: PUSH
93155: LD_INT 31
93157: PUSH
93158: LD_INT 32
93160: PUSH
93161: LD_INT 33
93163: PUSH
93164: LD_INT 34
93166: PUSH
93167: LD_INT 35
93169: PUSH
93170: LD_INT 36
93172: PUSH
93173: EMPTY
93174: LIST
93175: LIST
93176: LIST
93177: LIST
93178: LIST
93179: LIST
93180: LIST
93181: LIST
93182: LIST
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: LIST
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: PUSH
93211: LD_INT 101
93213: PUSH
93214: LD_INT 102
93216: PUSH
93217: LD_INT 103
93219: PUSH
93220: LD_INT 104
93222: PUSH
93223: LD_INT 105
93225: PUSH
93226: LD_INT 106
93228: PUSH
93229: LD_INT 107
93231: PUSH
93232: LD_INT 108
93234: PUSH
93235: LD_INT 109
93237: PUSH
93238: LD_INT 110
93240: PUSH
93241: LD_INT 111
93243: PUSH
93244: LD_INT 112
93246: PUSH
93247: LD_INT 113
93249: PUSH
93250: LD_INT 114
93252: PUSH
93253: LD_INT 115
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: LIST
93270: LIST
93271: LIST
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: ST_TO_ADDR
// if result then
93277: LD_VAR 0 1
93281: IFFALSE 93570
// begin normal :=  ;
93283: LD_ADDR_VAR 0 3
93287: PUSH
93288: LD_STRING 
93290: ST_TO_ADDR
// hardcore :=  ;
93291: LD_ADDR_VAR 0 4
93295: PUSH
93296: LD_STRING 
93298: ST_TO_ADDR
// for i = 1 to normalCounter do
93299: LD_ADDR_VAR 0 5
93303: PUSH
93304: DOUBLE
93305: LD_INT 1
93307: DEC
93308: ST_TO_ADDR
93309: LD_EXP 134
93313: PUSH
93314: FOR_TO
93315: IFFALSE 93416
// begin tmp := 0 ;
93317: LD_ADDR_VAR 0 2
93321: PUSH
93322: LD_STRING 0
93324: ST_TO_ADDR
// if result [ 1 ] then
93325: LD_VAR 0 1
93329: PUSH
93330: LD_INT 1
93332: ARRAY
93333: IFFALSE 93398
// if result [ 1 ] [ 1 ] = i then
93335: LD_VAR 0 1
93339: PUSH
93340: LD_INT 1
93342: ARRAY
93343: PUSH
93344: LD_INT 1
93346: ARRAY
93347: PUSH
93348: LD_VAR 0 5
93352: EQUAL
93353: IFFALSE 93398
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
93355: LD_ADDR_VAR 0 1
93359: PUSH
93360: LD_VAR 0 1
93364: PPUSH
93365: LD_INT 1
93367: PPUSH
93368: LD_VAR 0 1
93372: PUSH
93373: LD_INT 1
93375: ARRAY
93376: PPUSH
93377: LD_INT 1
93379: PPUSH
93380: CALL_OW 3
93384: PPUSH
93385: CALL_OW 1
93389: ST_TO_ADDR
// tmp := 1 ;
93390: LD_ADDR_VAR 0 2
93394: PUSH
93395: LD_STRING 1
93397: ST_TO_ADDR
// end ; normal := normal & tmp ;
93398: LD_ADDR_VAR 0 3
93402: PUSH
93403: LD_VAR 0 3
93407: PUSH
93408: LD_VAR 0 2
93412: STR
93413: ST_TO_ADDR
// end ;
93414: GO 93314
93416: POP
93417: POP
// for i = 1 to hardcoreCounter do
93418: LD_ADDR_VAR 0 5
93422: PUSH
93423: DOUBLE
93424: LD_INT 1
93426: DEC
93427: ST_TO_ADDR
93428: LD_EXP 135
93432: PUSH
93433: FOR_TO
93434: IFFALSE 93539
// begin tmp := 0 ;
93436: LD_ADDR_VAR 0 2
93440: PUSH
93441: LD_STRING 0
93443: ST_TO_ADDR
// if result [ 2 ] then
93444: LD_VAR 0 1
93448: PUSH
93449: LD_INT 2
93451: ARRAY
93452: IFFALSE 93521
// if result [ 2 ] [ 1 ] = 100 + i then
93454: LD_VAR 0 1
93458: PUSH
93459: LD_INT 2
93461: ARRAY
93462: PUSH
93463: LD_INT 1
93465: ARRAY
93466: PUSH
93467: LD_INT 100
93469: PUSH
93470: LD_VAR 0 5
93474: PLUS
93475: EQUAL
93476: IFFALSE 93521
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
93478: LD_ADDR_VAR 0 1
93482: PUSH
93483: LD_VAR 0 1
93487: PPUSH
93488: LD_INT 2
93490: PPUSH
93491: LD_VAR 0 1
93495: PUSH
93496: LD_INT 2
93498: ARRAY
93499: PPUSH
93500: LD_INT 1
93502: PPUSH
93503: CALL_OW 3
93507: PPUSH
93508: CALL_OW 1
93512: ST_TO_ADDR
// tmp := 1 ;
93513: LD_ADDR_VAR 0 2
93517: PUSH
93518: LD_STRING 1
93520: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
93521: LD_ADDR_VAR 0 4
93525: PUSH
93526: LD_VAR 0 4
93530: PUSH
93531: LD_VAR 0 2
93535: STR
93536: ST_TO_ADDR
// end ;
93537: GO 93433
93539: POP
93540: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
93541: LD_STRING getStreamItemsFromMission("
93543: PUSH
93544: LD_VAR 0 3
93548: STR
93549: PUSH
93550: LD_STRING ","
93552: STR
93553: PUSH
93554: LD_VAR 0 4
93558: STR
93559: PUSH
93560: LD_STRING ")
93562: STR
93563: PPUSH
93564: CALL_OW 559
// end else
93568: GO 93577
// ToLua ( getStreamItemsFromMission("","") ) ;
93570: LD_STRING getStreamItemsFromMission("","")
93572: PPUSH
93573: CALL_OW 559
// end ;
93577: LD_VAR 0 1
93581: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93582: LD_EXP 133
93586: PUSH
93587: LD_EXP 138
93591: AND
93592: IFFALSE 93716
93594: GO 93596
93596: DISABLE
93597: LD_INT 0
93599: PPUSH
93600: PPUSH
// begin enable ;
93601: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93602: LD_ADDR_VAR 0 2
93606: PUSH
93607: LD_INT 22
93609: PUSH
93610: LD_OWVAR 2
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 2
93621: PUSH
93622: LD_INT 34
93624: PUSH
93625: LD_INT 7
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: PUSH
93632: LD_INT 34
93634: PUSH
93635: LD_INT 45
93637: PUSH
93638: EMPTY
93639: LIST
93640: LIST
93641: PUSH
93642: LD_INT 34
93644: PUSH
93645: LD_INT 28
93647: PUSH
93648: EMPTY
93649: LIST
93650: LIST
93651: PUSH
93652: LD_INT 34
93654: PUSH
93655: LD_INT 47
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: PUSH
93662: EMPTY
93663: LIST
93664: LIST
93665: LIST
93666: LIST
93667: LIST
93668: PUSH
93669: EMPTY
93670: LIST
93671: LIST
93672: PPUSH
93673: CALL_OW 69
93677: ST_TO_ADDR
// if not tmp then
93678: LD_VAR 0 2
93682: NOT
93683: IFFALSE 93687
// exit ;
93685: GO 93716
// for i in tmp do
93687: LD_ADDR_VAR 0 1
93691: PUSH
93692: LD_VAR 0 2
93696: PUSH
93697: FOR_IN
93698: IFFALSE 93714
// begin SetLives ( i , 0 ) ;
93700: LD_VAR 0 1
93704: PPUSH
93705: LD_INT 0
93707: PPUSH
93708: CALL_OW 234
// end ;
93712: GO 93697
93714: POP
93715: POP
// end ;
93716: PPOPN 2
93718: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93719: LD_EXP 133
93723: PUSH
93724: LD_EXP 139
93728: AND
93729: IFFALSE 93813
93731: GO 93733
93733: DISABLE
93734: LD_INT 0
93736: PPUSH
93737: PPUSH
// begin enable ;
93738: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93739: LD_ADDR_VAR 0 2
93743: PUSH
93744: LD_INT 22
93746: PUSH
93747: LD_OWVAR 2
93751: PUSH
93752: EMPTY
93753: LIST
93754: LIST
93755: PUSH
93756: LD_INT 32
93758: PUSH
93759: LD_INT 3
93761: PUSH
93762: EMPTY
93763: LIST
93764: LIST
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PPUSH
93770: CALL_OW 69
93774: ST_TO_ADDR
// if not tmp then
93775: LD_VAR 0 2
93779: NOT
93780: IFFALSE 93784
// exit ;
93782: GO 93813
// for i in tmp do
93784: LD_ADDR_VAR 0 1
93788: PUSH
93789: LD_VAR 0 2
93793: PUSH
93794: FOR_IN
93795: IFFALSE 93811
// begin SetLives ( i , 0 ) ;
93797: LD_VAR 0 1
93801: PPUSH
93802: LD_INT 0
93804: PPUSH
93805: CALL_OW 234
// end ;
93809: GO 93794
93811: POP
93812: POP
// end ;
93813: PPOPN 2
93815: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93816: LD_EXP 133
93820: PUSH
93821: LD_EXP 136
93825: AND
93826: IFFALSE 93919
93828: GO 93830
93830: DISABLE
93831: LD_INT 0
93833: PPUSH
// begin enable ;
93834: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93835: LD_ADDR_VAR 0 1
93839: PUSH
93840: LD_INT 22
93842: PUSH
93843: LD_OWVAR 2
93847: PUSH
93848: EMPTY
93849: LIST
93850: LIST
93851: PUSH
93852: LD_INT 2
93854: PUSH
93855: LD_INT 25
93857: PUSH
93858: LD_INT 5
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: LD_INT 25
93867: PUSH
93868: LD_INT 9
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: PUSH
93875: LD_INT 25
93877: PUSH
93878: LD_INT 8
93880: PUSH
93881: EMPTY
93882: LIST
93883: LIST
93884: PUSH
93885: EMPTY
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: PUSH
93891: EMPTY
93892: LIST
93893: LIST
93894: PPUSH
93895: CALL_OW 69
93899: PUSH
93900: FOR_IN
93901: IFFALSE 93917
// begin SetClass ( i , 1 ) ;
93903: LD_VAR 0 1
93907: PPUSH
93908: LD_INT 1
93910: PPUSH
93911: CALL_OW 336
// end ;
93915: GO 93900
93917: POP
93918: POP
// end ;
93919: PPOPN 1
93921: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93922: LD_EXP 133
93926: PUSH
93927: LD_EXP 137
93931: AND
93932: PUSH
93933: LD_OWVAR 65
93937: PUSH
93938: LD_INT 7
93940: LESS
93941: AND
93942: IFFALSE 93956
93944: GO 93946
93946: DISABLE
// begin enable ;
93947: ENABLE
// game_speed := 7 ;
93948: LD_ADDR_OWVAR 65
93952: PUSH
93953: LD_INT 7
93955: ST_TO_ADDR
// end ;
93956: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
93957: LD_EXP 133
93961: PUSH
93962: LD_EXP 140
93966: AND
93967: IFFALSE 94169
93969: GO 93971
93971: DISABLE
93972: LD_INT 0
93974: PPUSH
93975: PPUSH
93976: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
93977: LD_ADDR_VAR 0 3
93981: PUSH
93982: LD_INT 81
93984: PUSH
93985: LD_OWVAR 2
93989: PUSH
93990: EMPTY
93991: LIST
93992: LIST
93993: PUSH
93994: LD_INT 21
93996: PUSH
93997: LD_INT 1
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: PPUSH
94008: CALL_OW 69
94012: ST_TO_ADDR
// if not tmp then
94013: LD_VAR 0 3
94017: NOT
94018: IFFALSE 94022
// exit ;
94020: GO 94169
// if tmp > 5 then
94022: LD_VAR 0 3
94026: PUSH
94027: LD_INT 5
94029: GREATER
94030: IFFALSE 94042
// k := 5 else
94032: LD_ADDR_VAR 0 2
94036: PUSH
94037: LD_INT 5
94039: ST_TO_ADDR
94040: GO 94052
// k := tmp ;
94042: LD_ADDR_VAR 0 2
94046: PUSH
94047: LD_VAR 0 3
94051: ST_TO_ADDR
// for i := 1 to k do
94052: LD_ADDR_VAR 0 1
94056: PUSH
94057: DOUBLE
94058: LD_INT 1
94060: DEC
94061: ST_TO_ADDR
94062: LD_VAR 0 2
94066: PUSH
94067: FOR_TO
94068: IFFALSE 94167
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
94070: LD_VAR 0 3
94074: PUSH
94075: LD_VAR 0 1
94079: ARRAY
94080: PPUSH
94081: LD_VAR 0 1
94085: PUSH
94086: LD_INT 4
94088: MOD
94089: PUSH
94090: LD_INT 1
94092: PLUS
94093: PPUSH
94094: CALL_OW 259
94098: PUSH
94099: LD_INT 10
94101: LESS
94102: IFFALSE 94165
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
94104: LD_VAR 0 3
94108: PUSH
94109: LD_VAR 0 1
94113: ARRAY
94114: PPUSH
94115: LD_VAR 0 1
94119: PUSH
94120: LD_INT 4
94122: MOD
94123: PUSH
94124: LD_INT 1
94126: PLUS
94127: PPUSH
94128: LD_VAR 0 3
94132: PUSH
94133: LD_VAR 0 1
94137: ARRAY
94138: PPUSH
94139: LD_VAR 0 1
94143: PUSH
94144: LD_INT 4
94146: MOD
94147: PUSH
94148: LD_INT 1
94150: PLUS
94151: PPUSH
94152: CALL_OW 259
94156: PUSH
94157: LD_INT 1
94159: PLUS
94160: PPUSH
94161: CALL_OW 237
94165: GO 94067
94167: POP
94168: POP
// end ;
94169: PPOPN 3
94171: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
94172: LD_EXP 133
94176: PUSH
94177: LD_EXP 141
94181: AND
94182: IFFALSE 94202
94184: GO 94186
94186: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
94187: LD_INT 4
94189: PPUSH
94190: LD_OWVAR 2
94194: PPUSH
94195: LD_INT 0
94197: PPUSH
94198: CALL_OW 324
94202: END
// every 0 0$1 trigger StreamModeActive and sShovel do
94203: LD_EXP 133
94207: PUSH
94208: LD_EXP 170
94212: AND
94213: IFFALSE 94233
94215: GO 94217
94217: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
94218: LD_INT 19
94220: PPUSH
94221: LD_OWVAR 2
94225: PPUSH
94226: LD_INT 0
94228: PPUSH
94229: CALL_OW 324
94233: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
94234: LD_EXP 133
94238: PUSH
94239: LD_EXP 142
94243: AND
94244: IFFALSE 94346
94246: GO 94248
94248: DISABLE
94249: LD_INT 0
94251: PPUSH
94252: PPUSH
// begin enable ;
94253: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
94254: LD_ADDR_VAR 0 2
94258: PUSH
94259: LD_INT 22
94261: PUSH
94262: LD_OWVAR 2
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: LD_INT 2
94273: PUSH
94274: LD_INT 34
94276: PUSH
94277: LD_INT 11
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: PUSH
94284: LD_INT 34
94286: PUSH
94287: LD_INT 30
94289: PUSH
94290: EMPTY
94291: LIST
94292: LIST
94293: PUSH
94294: EMPTY
94295: LIST
94296: LIST
94297: LIST
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: PPUSH
94303: CALL_OW 69
94307: ST_TO_ADDR
// if not tmp then
94308: LD_VAR 0 2
94312: NOT
94313: IFFALSE 94317
// exit ;
94315: GO 94346
// for i in tmp do
94317: LD_ADDR_VAR 0 1
94321: PUSH
94322: LD_VAR 0 2
94326: PUSH
94327: FOR_IN
94328: IFFALSE 94344
// begin SetLives ( i , 0 ) ;
94330: LD_VAR 0 1
94334: PPUSH
94335: LD_INT 0
94337: PPUSH
94338: CALL_OW 234
// end ;
94342: GO 94327
94344: POP
94345: POP
// end ;
94346: PPOPN 2
94348: END
// every 0 0$1 trigger StreamModeActive and sBunker do
94349: LD_EXP 133
94353: PUSH
94354: LD_EXP 143
94358: AND
94359: IFFALSE 94379
94361: GO 94363
94363: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
94364: LD_INT 32
94366: PPUSH
94367: LD_OWVAR 2
94371: PPUSH
94372: LD_INT 0
94374: PPUSH
94375: CALL_OW 324
94379: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
94380: LD_EXP 133
94384: PUSH
94385: LD_EXP 144
94389: AND
94390: IFFALSE 94571
94392: GO 94394
94394: DISABLE
94395: LD_INT 0
94397: PPUSH
94398: PPUSH
94399: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
94400: LD_ADDR_VAR 0 2
94404: PUSH
94405: LD_INT 22
94407: PUSH
94408: LD_OWVAR 2
94412: PUSH
94413: EMPTY
94414: LIST
94415: LIST
94416: PUSH
94417: LD_INT 33
94419: PUSH
94420: LD_INT 3
94422: PUSH
94423: EMPTY
94424: LIST
94425: LIST
94426: PUSH
94427: EMPTY
94428: LIST
94429: LIST
94430: PPUSH
94431: CALL_OW 69
94435: ST_TO_ADDR
// if not tmp then
94436: LD_VAR 0 2
94440: NOT
94441: IFFALSE 94445
// exit ;
94443: GO 94571
// side := 0 ;
94445: LD_ADDR_VAR 0 3
94449: PUSH
94450: LD_INT 0
94452: ST_TO_ADDR
// for i := 1 to 8 do
94453: LD_ADDR_VAR 0 1
94457: PUSH
94458: DOUBLE
94459: LD_INT 1
94461: DEC
94462: ST_TO_ADDR
94463: LD_INT 8
94465: PUSH
94466: FOR_TO
94467: IFFALSE 94515
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
94469: LD_OWVAR 2
94473: PUSH
94474: LD_VAR 0 1
94478: NONEQUAL
94479: PUSH
94480: LD_OWVAR 2
94484: PPUSH
94485: LD_VAR 0 1
94489: PPUSH
94490: CALL_OW 81
94494: PUSH
94495: LD_INT 2
94497: EQUAL
94498: AND
94499: IFFALSE 94513
// begin side := i ;
94501: LD_ADDR_VAR 0 3
94505: PUSH
94506: LD_VAR 0 1
94510: ST_TO_ADDR
// break ;
94511: GO 94515
// end ;
94513: GO 94466
94515: POP
94516: POP
// if not side then
94517: LD_VAR 0 3
94521: NOT
94522: IFFALSE 94526
// exit ;
94524: GO 94571
// for i := 1 to tmp do
94526: LD_ADDR_VAR 0 1
94530: PUSH
94531: DOUBLE
94532: LD_INT 1
94534: DEC
94535: ST_TO_ADDR
94536: LD_VAR 0 2
94540: PUSH
94541: FOR_TO
94542: IFFALSE 94569
// if Prob ( 60 ) then
94544: LD_INT 60
94546: PPUSH
94547: CALL_OW 13
94551: IFFALSE 94567
// SetSide ( i , side ) ;
94553: LD_VAR 0 1
94557: PPUSH
94558: LD_VAR 0 3
94562: PPUSH
94563: CALL_OW 235
94567: GO 94541
94569: POP
94570: POP
// end ;
94571: PPOPN 3
94573: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94574: LD_EXP 133
94578: PUSH
94579: LD_EXP 146
94583: AND
94584: IFFALSE 94703
94586: GO 94588
94588: DISABLE
94589: LD_INT 0
94591: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94592: LD_ADDR_VAR 0 1
94596: PUSH
94597: LD_INT 22
94599: PUSH
94600: LD_OWVAR 2
94604: PUSH
94605: EMPTY
94606: LIST
94607: LIST
94608: PUSH
94609: LD_INT 21
94611: PUSH
94612: LD_INT 1
94614: PUSH
94615: EMPTY
94616: LIST
94617: LIST
94618: PUSH
94619: LD_INT 3
94621: PUSH
94622: LD_INT 23
94624: PUSH
94625: LD_INT 0
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: EMPTY
94633: LIST
94634: LIST
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: LIST
94640: PPUSH
94641: CALL_OW 69
94645: PUSH
94646: FOR_IN
94647: IFFALSE 94701
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94649: LD_VAR 0 1
94653: PPUSH
94654: CALL_OW 257
94658: PUSH
94659: LD_INT 1
94661: PUSH
94662: LD_INT 2
94664: PUSH
94665: LD_INT 3
94667: PUSH
94668: LD_INT 4
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: IN
94677: IFFALSE 94699
// SetClass ( un , rand ( 1 , 4 ) ) ;
94679: LD_VAR 0 1
94683: PPUSH
94684: LD_INT 1
94686: PPUSH
94687: LD_INT 4
94689: PPUSH
94690: CALL_OW 12
94694: PPUSH
94695: CALL_OW 336
94699: GO 94646
94701: POP
94702: POP
// end ;
94703: PPOPN 1
94705: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94706: LD_EXP 133
94710: PUSH
94711: LD_EXP 145
94715: AND
94716: IFFALSE 94795
94718: GO 94720
94720: DISABLE
94721: LD_INT 0
94723: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94724: LD_ADDR_VAR 0 1
94728: PUSH
94729: LD_INT 22
94731: PUSH
94732: LD_OWVAR 2
94736: PUSH
94737: EMPTY
94738: LIST
94739: LIST
94740: PUSH
94741: LD_INT 21
94743: PUSH
94744: LD_INT 3
94746: PUSH
94747: EMPTY
94748: LIST
94749: LIST
94750: PUSH
94751: EMPTY
94752: LIST
94753: LIST
94754: PPUSH
94755: CALL_OW 69
94759: ST_TO_ADDR
// if not tmp then
94760: LD_VAR 0 1
94764: NOT
94765: IFFALSE 94769
// exit ;
94767: GO 94795
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94769: LD_VAR 0 1
94773: PUSH
94774: LD_INT 1
94776: PPUSH
94777: LD_VAR 0 1
94781: PPUSH
94782: CALL_OW 12
94786: ARRAY
94787: PPUSH
94788: LD_INT 100
94790: PPUSH
94791: CALL_OW 234
// end ;
94795: PPOPN 1
94797: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94798: LD_EXP 133
94802: PUSH
94803: LD_EXP 147
94807: AND
94808: IFFALSE 94906
94810: GO 94812
94812: DISABLE
94813: LD_INT 0
94815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94816: LD_ADDR_VAR 0 1
94820: PUSH
94821: LD_INT 22
94823: PUSH
94824: LD_OWVAR 2
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: LD_INT 21
94835: PUSH
94836: LD_INT 1
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PPUSH
94847: CALL_OW 69
94851: ST_TO_ADDR
// if not tmp then
94852: LD_VAR 0 1
94856: NOT
94857: IFFALSE 94861
// exit ;
94859: GO 94906
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94861: LD_VAR 0 1
94865: PUSH
94866: LD_INT 1
94868: PPUSH
94869: LD_VAR 0 1
94873: PPUSH
94874: CALL_OW 12
94878: ARRAY
94879: PPUSH
94880: LD_INT 1
94882: PPUSH
94883: LD_INT 4
94885: PPUSH
94886: CALL_OW 12
94890: PPUSH
94891: LD_INT 3000
94893: PPUSH
94894: LD_INT 9000
94896: PPUSH
94897: CALL_OW 12
94901: PPUSH
94902: CALL_OW 492
// end ;
94906: PPOPN 1
94908: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94909: LD_EXP 133
94913: PUSH
94914: LD_EXP 148
94918: AND
94919: IFFALSE 94939
94921: GO 94923
94923: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94924: LD_INT 1
94926: PPUSH
94927: LD_OWVAR 2
94931: PPUSH
94932: LD_INT 0
94934: PPUSH
94935: CALL_OW 324
94939: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94940: LD_EXP 133
94944: PUSH
94945: LD_EXP 149
94949: AND
94950: IFFALSE 95033
94952: GO 94954
94954: DISABLE
94955: LD_INT 0
94957: PPUSH
94958: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94959: LD_ADDR_VAR 0 2
94963: PUSH
94964: LD_INT 22
94966: PUSH
94967: LD_OWVAR 2
94971: PUSH
94972: EMPTY
94973: LIST
94974: LIST
94975: PUSH
94976: LD_INT 21
94978: PUSH
94979: LD_INT 3
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: EMPTY
94987: LIST
94988: LIST
94989: PPUSH
94990: CALL_OW 69
94994: ST_TO_ADDR
// if not tmp then
94995: LD_VAR 0 2
94999: NOT
95000: IFFALSE 95004
// exit ;
95002: GO 95033
// for i in tmp do
95004: LD_ADDR_VAR 0 1
95008: PUSH
95009: LD_VAR 0 2
95013: PUSH
95014: FOR_IN
95015: IFFALSE 95031
// SetBLevel ( i , 10 ) ;
95017: LD_VAR 0 1
95021: PPUSH
95022: LD_INT 10
95024: PPUSH
95025: CALL_OW 241
95029: GO 95014
95031: POP
95032: POP
// end ;
95033: PPOPN 2
95035: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
95036: LD_EXP 133
95040: PUSH
95041: LD_EXP 150
95045: AND
95046: IFFALSE 95157
95048: GO 95050
95050: DISABLE
95051: LD_INT 0
95053: PPUSH
95054: PPUSH
95055: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95056: LD_ADDR_VAR 0 3
95060: PUSH
95061: LD_INT 22
95063: PUSH
95064: LD_OWVAR 2
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: LD_INT 25
95075: PUSH
95076: LD_INT 1
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: PPUSH
95087: CALL_OW 69
95091: ST_TO_ADDR
// if not tmp then
95092: LD_VAR 0 3
95096: NOT
95097: IFFALSE 95101
// exit ;
95099: GO 95157
// un := tmp [ rand ( 1 , tmp ) ] ;
95101: LD_ADDR_VAR 0 2
95105: PUSH
95106: LD_VAR 0 3
95110: PUSH
95111: LD_INT 1
95113: PPUSH
95114: LD_VAR 0 3
95118: PPUSH
95119: CALL_OW 12
95123: ARRAY
95124: ST_TO_ADDR
// if Crawls ( un ) then
95125: LD_VAR 0 2
95129: PPUSH
95130: CALL_OW 318
95134: IFFALSE 95145
// ComWalk ( un ) ;
95136: LD_VAR 0 2
95140: PPUSH
95141: CALL_OW 138
// SetClass ( un , class_sniper ) ;
95145: LD_VAR 0 2
95149: PPUSH
95150: LD_INT 5
95152: PPUSH
95153: CALL_OW 336
// end ;
95157: PPOPN 3
95159: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
95160: LD_EXP 133
95164: PUSH
95165: LD_EXP 151
95169: AND
95170: PUSH
95171: LD_OWVAR 67
95175: PUSH
95176: LD_INT 3
95178: LESS
95179: AND
95180: IFFALSE 95199
95182: GO 95184
95184: DISABLE
// Difficulty := Difficulty + 1 ;
95185: LD_ADDR_OWVAR 67
95189: PUSH
95190: LD_OWVAR 67
95194: PUSH
95195: LD_INT 1
95197: PLUS
95198: ST_TO_ADDR
95199: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
95200: LD_EXP 133
95204: PUSH
95205: LD_EXP 152
95209: AND
95210: IFFALSE 95313
95212: GO 95214
95214: DISABLE
95215: LD_INT 0
95217: PPUSH
// begin for i := 1 to 5 do
95218: LD_ADDR_VAR 0 1
95222: PUSH
95223: DOUBLE
95224: LD_INT 1
95226: DEC
95227: ST_TO_ADDR
95228: LD_INT 5
95230: PUSH
95231: FOR_TO
95232: IFFALSE 95311
// begin uc_nation := nation_nature ;
95234: LD_ADDR_OWVAR 21
95238: PUSH
95239: LD_INT 0
95241: ST_TO_ADDR
// uc_side := 0 ;
95242: LD_ADDR_OWVAR 20
95246: PUSH
95247: LD_INT 0
95249: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95250: LD_ADDR_OWVAR 29
95254: PUSH
95255: LD_INT 12
95257: PUSH
95258: LD_INT 12
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: ST_TO_ADDR
// hc_agressivity := 20 ;
95265: LD_ADDR_OWVAR 35
95269: PUSH
95270: LD_INT 20
95272: ST_TO_ADDR
// hc_class := class_tiger ;
95273: LD_ADDR_OWVAR 28
95277: PUSH
95278: LD_INT 14
95280: ST_TO_ADDR
// hc_gallery :=  ;
95281: LD_ADDR_OWVAR 33
95285: PUSH
95286: LD_STRING 
95288: ST_TO_ADDR
// hc_name :=  ;
95289: LD_ADDR_OWVAR 26
95293: PUSH
95294: LD_STRING 
95296: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
95297: CALL_OW 44
95301: PPUSH
95302: LD_INT 0
95304: PPUSH
95305: CALL_OW 51
// end ;
95309: GO 95231
95311: POP
95312: POP
// end ;
95313: PPOPN 1
95315: END
// every 0 0$1 trigger StreamModeActive and sBomb do
95316: LD_EXP 133
95320: PUSH
95321: LD_EXP 153
95325: AND
95326: IFFALSE 95335
95328: GO 95330
95330: DISABLE
// StreamSibBomb ;
95331: CALL 95336 0 0
95335: END
// export function StreamSibBomb ; var i , x , y ; begin
95336: LD_INT 0
95338: PPUSH
95339: PPUSH
95340: PPUSH
95341: PPUSH
// result := false ;
95342: LD_ADDR_VAR 0 1
95346: PUSH
95347: LD_INT 0
95349: ST_TO_ADDR
// for i := 1 to 16 do
95350: LD_ADDR_VAR 0 2
95354: PUSH
95355: DOUBLE
95356: LD_INT 1
95358: DEC
95359: ST_TO_ADDR
95360: LD_INT 16
95362: PUSH
95363: FOR_TO
95364: IFFALSE 95563
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95366: LD_ADDR_VAR 0 3
95370: PUSH
95371: LD_INT 10
95373: PUSH
95374: LD_INT 20
95376: PUSH
95377: LD_INT 30
95379: PUSH
95380: LD_INT 40
95382: PUSH
95383: LD_INT 50
95385: PUSH
95386: LD_INT 60
95388: PUSH
95389: LD_INT 70
95391: PUSH
95392: LD_INT 80
95394: PUSH
95395: LD_INT 90
95397: PUSH
95398: LD_INT 100
95400: PUSH
95401: LD_INT 110
95403: PUSH
95404: LD_INT 120
95406: PUSH
95407: LD_INT 130
95409: PUSH
95410: LD_INT 140
95412: PUSH
95413: LD_INT 150
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: PUSH
95433: LD_INT 1
95435: PPUSH
95436: LD_INT 15
95438: PPUSH
95439: CALL_OW 12
95443: ARRAY
95444: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95445: LD_ADDR_VAR 0 4
95449: PUSH
95450: LD_INT 10
95452: PUSH
95453: LD_INT 20
95455: PUSH
95456: LD_INT 30
95458: PUSH
95459: LD_INT 40
95461: PUSH
95462: LD_INT 50
95464: PUSH
95465: LD_INT 60
95467: PUSH
95468: LD_INT 70
95470: PUSH
95471: LD_INT 80
95473: PUSH
95474: LD_INT 90
95476: PUSH
95477: LD_INT 100
95479: PUSH
95480: LD_INT 110
95482: PUSH
95483: LD_INT 120
95485: PUSH
95486: LD_INT 130
95488: PUSH
95489: LD_INT 140
95491: PUSH
95492: LD_INT 150
95494: PUSH
95495: EMPTY
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: PUSH
95512: LD_INT 1
95514: PPUSH
95515: LD_INT 15
95517: PPUSH
95518: CALL_OW 12
95522: ARRAY
95523: ST_TO_ADDR
// if ValidHex ( x , y ) then
95524: LD_VAR 0 3
95528: PPUSH
95529: LD_VAR 0 4
95533: PPUSH
95534: CALL_OW 488
95538: IFFALSE 95561
// begin result := [ x , y ] ;
95540: LD_ADDR_VAR 0 1
95544: PUSH
95545: LD_VAR 0 3
95549: PUSH
95550: LD_VAR 0 4
95554: PUSH
95555: EMPTY
95556: LIST
95557: LIST
95558: ST_TO_ADDR
// break ;
95559: GO 95563
// end ; end ;
95561: GO 95363
95563: POP
95564: POP
// if result then
95565: LD_VAR 0 1
95569: IFFALSE 95629
// begin ToLua ( playSibBomb() ) ;
95571: LD_STRING playSibBomb()
95573: PPUSH
95574: CALL_OW 559
// wait ( 0 0$14 ) ;
95578: LD_INT 490
95580: PPUSH
95581: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95585: LD_VAR 0 1
95589: PUSH
95590: LD_INT 1
95592: ARRAY
95593: PPUSH
95594: LD_VAR 0 1
95598: PUSH
95599: LD_INT 2
95601: ARRAY
95602: PPUSH
95603: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95607: LD_VAR 0 1
95611: PUSH
95612: LD_INT 1
95614: ARRAY
95615: PPUSH
95616: LD_VAR 0 1
95620: PUSH
95621: LD_INT 2
95623: ARRAY
95624: PPUSH
95625: CALL_OW 429
// end ; end ;
95629: LD_VAR 0 1
95633: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95634: LD_EXP 133
95638: PUSH
95639: LD_EXP 155
95643: AND
95644: IFFALSE 95656
95646: GO 95648
95648: DISABLE
// YouLost (  ) ;
95649: LD_STRING 
95651: PPUSH
95652: CALL_OW 104
95656: END
// every 0 0$1 trigger StreamModeActive and sFog do
95657: LD_EXP 133
95661: PUSH
95662: LD_EXP 154
95666: AND
95667: IFFALSE 95681
95669: GO 95671
95671: DISABLE
// FogOff ( your_side ) ;
95672: LD_OWVAR 2
95676: PPUSH
95677: CALL_OW 344
95681: END
// every 0 0$1 trigger StreamModeActive and sSun do
95682: LD_EXP 133
95686: PUSH
95687: LD_EXP 156
95691: AND
95692: IFFALSE 95720
95694: GO 95696
95696: DISABLE
// begin solar_recharge_percent := 0 ;
95697: LD_ADDR_OWVAR 79
95701: PUSH
95702: LD_INT 0
95704: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95705: LD_INT 10500
95707: PPUSH
95708: CALL_OW 67
// solar_recharge_percent := 100 ;
95712: LD_ADDR_OWVAR 79
95716: PUSH
95717: LD_INT 100
95719: ST_TO_ADDR
// end ;
95720: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95721: LD_EXP 133
95725: PUSH
95726: LD_EXP 157
95730: AND
95731: IFFALSE 95970
95733: GO 95735
95735: DISABLE
95736: LD_INT 0
95738: PPUSH
95739: PPUSH
95740: PPUSH
// begin tmp := [ ] ;
95741: LD_ADDR_VAR 0 3
95745: PUSH
95746: EMPTY
95747: ST_TO_ADDR
// for i := 1 to 6 do
95748: LD_ADDR_VAR 0 1
95752: PUSH
95753: DOUBLE
95754: LD_INT 1
95756: DEC
95757: ST_TO_ADDR
95758: LD_INT 6
95760: PUSH
95761: FOR_TO
95762: IFFALSE 95867
// begin uc_nation := nation_nature ;
95764: LD_ADDR_OWVAR 21
95768: PUSH
95769: LD_INT 0
95771: ST_TO_ADDR
// uc_side := 0 ;
95772: LD_ADDR_OWVAR 20
95776: PUSH
95777: LD_INT 0
95779: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95780: LD_ADDR_OWVAR 29
95784: PUSH
95785: LD_INT 12
95787: PUSH
95788: LD_INT 12
95790: PUSH
95791: EMPTY
95792: LIST
95793: LIST
95794: ST_TO_ADDR
// hc_agressivity := 20 ;
95795: LD_ADDR_OWVAR 35
95799: PUSH
95800: LD_INT 20
95802: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95803: LD_ADDR_OWVAR 28
95807: PUSH
95808: LD_INT 17
95810: ST_TO_ADDR
// hc_gallery :=  ;
95811: LD_ADDR_OWVAR 33
95815: PUSH
95816: LD_STRING 
95818: ST_TO_ADDR
// hc_name :=  ;
95819: LD_ADDR_OWVAR 26
95823: PUSH
95824: LD_STRING 
95826: ST_TO_ADDR
// un := CreateHuman ;
95827: LD_ADDR_VAR 0 2
95831: PUSH
95832: CALL_OW 44
95836: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95837: LD_VAR 0 2
95841: PPUSH
95842: LD_INT 1
95844: PPUSH
95845: CALL_OW 51
// tmp := tmp ^ un ;
95849: LD_ADDR_VAR 0 3
95853: PUSH
95854: LD_VAR 0 3
95858: PUSH
95859: LD_VAR 0 2
95863: ADD
95864: ST_TO_ADDR
// end ;
95865: GO 95761
95867: POP
95868: POP
// repeat wait ( 0 0$1 ) ;
95869: LD_INT 35
95871: PPUSH
95872: CALL_OW 67
// for un in tmp do
95876: LD_ADDR_VAR 0 2
95880: PUSH
95881: LD_VAR 0 3
95885: PUSH
95886: FOR_IN
95887: IFFALSE 95961
// begin if IsDead ( un ) then
95889: LD_VAR 0 2
95893: PPUSH
95894: CALL_OW 301
95898: IFFALSE 95918
// begin tmp := tmp diff un ;
95900: LD_ADDR_VAR 0 3
95904: PUSH
95905: LD_VAR 0 3
95909: PUSH
95910: LD_VAR 0 2
95914: DIFF
95915: ST_TO_ADDR
// continue ;
95916: GO 95886
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95918: LD_VAR 0 2
95922: PPUSH
95923: LD_INT 3
95925: PUSH
95926: LD_INT 22
95928: PUSH
95929: LD_INT 0
95931: PUSH
95932: EMPTY
95933: LIST
95934: LIST
95935: PUSH
95936: EMPTY
95937: LIST
95938: LIST
95939: PPUSH
95940: CALL_OW 69
95944: PPUSH
95945: LD_VAR 0 2
95949: PPUSH
95950: CALL_OW 74
95954: PPUSH
95955: CALL_OW 115
// end ;
95959: GO 95886
95961: POP
95962: POP
// until not tmp ;
95963: LD_VAR 0 3
95967: NOT
95968: IFFALSE 95869
// end ;
95970: PPOPN 3
95972: END
// every 0 0$1 trigger StreamModeActive and sTroll do
95973: LD_EXP 133
95977: PUSH
95978: LD_EXP 158
95982: AND
95983: IFFALSE 96037
95985: GO 95987
95987: DISABLE
// begin ToLua ( displayTroll(); ) ;
95988: LD_STRING displayTroll();
95990: PPUSH
95991: CALL_OW 559
// wait ( 3 3$00 ) ;
95995: LD_INT 6300
95997: PPUSH
95998: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96002: LD_STRING hideTroll();
96004: PPUSH
96005: CALL_OW 559
// wait ( 1 1$00 ) ;
96009: LD_INT 2100
96011: PPUSH
96012: CALL_OW 67
// ToLua ( displayTroll(); ) ;
96016: LD_STRING displayTroll();
96018: PPUSH
96019: CALL_OW 559
// wait ( 1 1$00 ) ;
96023: LD_INT 2100
96025: PPUSH
96026: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96030: LD_STRING hideTroll();
96032: PPUSH
96033: CALL_OW 559
// end ;
96037: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
96038: LD_EXP 133
96042: PUSH
96043: LD_EXP 159
96047: AND
96048: IFFALSE 96111
96050: GO 96052
96052: DISABLE
96053: LD_INT 0
96055: PPUSH
// begin p := 0 ;
96056: LD_ADDR_VAR 0 1
96060: PUSH
96061: LD_INT 0
96063: ST_TO_ADDR
// repeat game_speed := 1 ;
96064: LD_ADDR_OWVAR 65
96068: PUSH
96069: LD_INT 1
96071: ST_TO_ADDR
// wait ( 0 0$1 ) ;
96072: LD_INT 35
96074: PPUSH
96075: CALL_OW 67
// p := p + 1 ;
96079: LD_ADDR_VAR 0 1
96083: PUSH
96084: LD_VAR 0 1
96088: PUSH
96089: LD_INT 1
96091: PLUS
96092: ST_TO_ADDR
// until p >= 60 ;
96093: LD_VAR 0 1
96097: PUSH
96098: LD_INT 60
96100: GREATEREQUAL
96101: IFFALSE 96064
// game_speed := 4 ;
96103: LD_ADDR_OWVAR 65
96107: PUSH
96108: LD_INT 4
96110: ST_TO_ADDR
// end ;
96111: PPOPN 1
96113: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
96114: LD_EXP 133
96118: PUSH
96119: LD_EXP 160
96123: AND
96124: IFFALSE 96270
96126: GO 96128
96128: DISABLE
96129: LD_INT 0
96131: PPUSH
96132: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96133: LD_ADDR_VAR 0 1
96137: PUSH
96138: LD_INT 22
96140: PUSH
96141: LD_OWVAR 2
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 2
96152: PUSH
96153: LD_INT 30
96155: PUSH
96156: LD_INT 0
96158: PUSH
96159: EMPTY
96160: LIST
96161: LIST
96162: PUSH
96163: LD_INT 30
96165: PUSH
96166: LD_INT 1
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: EMPTY
96174: LIST
96175: LIST
96176: LIST
96177: PUSH
96178: EMPTY
96179: LIST
96180: LIST
96181: PPUSH
96182: CALL_OW 69
96186: ST_TO_ADDR
// if not depot then
96187: LD_VAR 0 1
96191: NOT
96192: IFFALSE 96196
// exit ;
96194: GO 96270
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
96196: LD_ADDR_VAR 0 2
96200: PUSH
96201: LD_VAR 0 1
96205: PUSH
96206: LD_INT 1
96208: PPUSH
96209: LD_VAR 0 1
96213: PPUSH
96214: CALL_OW 12
96218: ARRAY
96219: PPUSH
96220: CALL_OW 274
96224: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
96225: LD_VAR 0 2
96229: PPUSH
96230: LD_INT 1
96232: PPUSH
96233: LD_INT 0
96235: PPUSH
96236: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
96240: LD_VAR 0 2
96244: PPUSH
96245: LD_INT 2
96247: PPUSH
96248: LD_INT 0
96250: PPUSH
96251: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
96255: LD_VAR 0 2
96259: PPUSH
96260: LD_INT 3
96262: PPUSH
96263: LD_INT 0
96265: PPUSH
96266: CALL_OW 277
// end ;
96270: PPOPN 2
96272: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
96273: LD_EXP 133
96277: PUSH
96278: LD_EXP 161
96282: AND
96283: IFFALSE 96380
96285: GO 96287
96287: DISABLE
96288: LD_INT 0
96290: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96291: LD_ADDR_VAR 0 1
96295: PUSH
96296: LD_INT 22
96298: PUSH
96299: LD_OWVAR 2
96303: PUSH
96304: EMPTY
96305: LIST
96306: LIST
96307: PUSH
96308: LD_INT 21
96310: PUSH
96311: LD_INT 1
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: PUSH
96318: LD_INT 3
96320: PUSH
96321: LD_INT 23
96323: PUSH
96324: LD_INT 0
96326: PUSH
96327: EMPTY
96328: LIST
96329: LIST
96330: PUSH
96331: EMPTY
96332: LIST
96333: LIST
96334: PUSH
96335: EMPTY
96336: LIST
96337: LIST
96338: LIST
96339: PPUSH
96340: CALL_OW 69
96344: ST_TO_ADDR
// if not tmp then
96345: LD_VAR 0 1
96349: NOT
96350: IFFALSE 96354
// exit ;
96352: GO 96380
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
96354: LD_VAR 0 1
96358: PUSH
96359: LD_INT 1
96361: PPUSH
96362: LD_VAR 0 1
96366: PPUSH
96367: CALL_OW 12
96371: ARRAY
96372: PPUSH
96373: LD_INT 200
96375: PPUSH
96376: CALL_OW 234
// end ;
96380: PPOPN 1
96382: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
96383: LD_EXP 133
96387: PUSH
96388: LD_EXP 162
96392: AND
96393: IFFALSE 96472
96395: GO 96397
96397: DISABLE
96398: LD_INT 0
96400: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
96401: LD_ADDR_VAR 0 1
96405: PUSH
96406: LD_INT 22
96408: PUSH
96409: LD_OWVAR 2
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: PUSH
96418: LD_INT 21
96420: PUSH
96421: LD_INT 2
96423: PUSH
96424: EMPTY
96425: LIST
96426: LIST
96427: PUSH
96428: EMPTY
96429: LIST
96430: LIST
96431: PPUSH
96432: CALL_OW 69
96436: ST_TO_ADDR
// if not tmp then
96437: LD_VAR 0 1
96441: NOT
96442: IFFALSE 96446
// exit ;
96444: GO 96472
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
96446: LD_VAR 0 1
96450: PUSH
96451: LD_INT 1
96453: PPUSH
96454: LD_VAR 0 1
96458: PPUSH
96459: CALL_OW 12
96463: ARRAY
96464: PPUSH
96465: LD_INT 60
96467: PPUSH
96468: CALL_OW 234
// end ;
96472: PPOPN 1
96474: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
96475: LD_EXP 133
96479: PUSH
96480: LD_EXP 163
96484: AND
96485: IFFALSE 96584
96487: GO 96489
96489: DISABLE
96490: LD_INT 0
96492: PPUSH
96493: PPUSH
// begin enable ;
96494: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
96495: LD_ADDR_VAR 0 1
96499: PUSH
96500: LD_INT 22
96502: PUSH
96503: LD_OWVAR 2
96507: PUSH
96508: EMPTY
96509: LIST
96510: LIST
96511: PUSH
96512: LD_INT 61
96514: PUSH
96515: EMPTY
96516: LIST
96517: PUSH
96518: LD_INT 33
96520: PUSH
96521: LD_INT 2
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: PUSH
96528: EMPTY
96529: LIST
96530: LIST
96531: LIST
96532: PPUSH
96533: CALL_OW 69
96537: ST_TO_ADDR
// if not tmp then
96538: LD_VAR 0 1
96542: NOT
96543: IFFALSE 96547
// exit ;
96545: GO 96584
// for i in tmp do
96547: LD_ADDR_VAR 0 2
96551: PUSH
96552: LD_VAR 0 1
96556: PUSH
96557: FOR_IN
96558: IFFALSE 96582
// if IsControledBy ( i ) then
96560: LD_VAR 0 2
96564: PPUSH
96565: CALL_OW 312
96569: IFFALSE 96580
// ComUnlink ( i ) ;
96571: LD_VAR 0 2
96575: PPUSH
96576: CALL_OW 136
96580: GO 96557
96582: POP
96583: POP
// end ;
96584: PPOPN 2
96586: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96587: LD_EXP 133
96591: PUSH
96592: LD_EXP 164
96596: AND
96597: IFFALSE 96737
96599: GO 96601
96601: DISABLE
96602: LD_INT 0
96604: PPUSH
96605: PPUSH
// begin ToLua ( displayPowell(); ) ;
96606: LD_STRING displayPowell();
96608: PPUSH
96609: CALL_OW 559
// uc_side := 0 ;
96613: LD_ADDR_OWVAR 20
96617: PUSH
96618: LD_INT 0
96620: ST_TO_ADDR
// uc_nation := 2 ;
96621: LD_ADDR_OWVAR 21
96625: PUSH
96626: LD_INT 2
96628: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96629: LD_ADDR_OWVAR 37
96633: PUSH
96634: LD_INT 14
96636: ST_TO_ADDR
// vc_engine := engine_siberite ;
96637: LD_ADDR_OWVAR 39
96641: PUSH
96642: LD_INT 3
96644: ST_TO_ADDR
// vc_control := control_apeman ;
96645: LD_ADDR_OWVAR 38
96649: PUSH
96650: LD_INT 5
96652: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96653: LD_ADDR_OWVAR 40
96657: PUSH
96658: LD_INT 29
96660: ST_TO_ADDR
// un := CreateVehicle ;
96661: LD_ADDR_VAR 0 2
96665: PUSH
96666: CALL_OW 45
96670: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96671: LD_VAR 0 2
96675: PPUSH
96676: LD_INT 1
96678: PPUSH
96679: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96683: LD_INT 35
96685: PPUSH
96686: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96690: LD_VAR 0 2
96694: PPUSH
96695: LD_INT 22
96697: PUSH
96698: LD_OWVAR 2
96702: PUSH
96703: EMPTY
96704: LIST
96705: LIST
96706: PPUSH
96707: CALL_OW 69
96711: PPUSH
96712: LD_VAR 0 2
96716: PPUSH
96717: CALL_OW 74
96721: PPUSH
96722: CALL_OW 115
// until IsDead ( un ) ;
96726: LD_VAR 0 2
96730: PPUSH
96731: CALL_OW 301
96735: IFFALSE 96683
// end ;
96737: PPOPN 2
96739: END
// every 0 0$1 trigger StreamModeActive and sStu do
96740: LD_EXP 133
96744: PUSH
96745: LD_EXP 172
96749: AND
96750: IFFALSE 96766
96752: GO 96754
96754: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96755: LD_STRING displayStucuk();
96757: PPUSH
96758: CALL_OW 559
// ResetFog ;
96762: CALL_OW 335
// end ;
96766: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96767: LD_EXP 133
96771: PUSH
96772: LD_EXP 165
96776: AND
96777: IFFALSE 96918
96779: GO 96781
96781: DISABLE
96782: LD_INT 0
96784: PPUSH
96785: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96786: LD_ADDR_VAR 0 2
96790: PUSH
96791: LD_INT 22
96793: PUSH
96794: LD_OWVAR 2
96798: PUSH
96799: EMPTY
96800: LIST
96801: LIST
96802: PUSH
96803: LD_INT 21
96805: PUSH
96806: LD_INT 1
96808: PUSH
96809: EMPTY
96810: LIST
96811: LIST
96812: PUSH
96813: EMPTY
96814: LIST
96815: LIST
96816: PPUSH
96817: CALL_OW 69
96821: ST_TO_ADDR
// if not tmp then
96822: LD_VAR 0 2
96826: NOT
96827: IFFALSE 96831
// exit ;
96829: GO 96918
// un := tmp [ rand ( 1 , tmp ) ] ;
96831: LD_ADDR_VAR 0 1
96835: PUSH
96836: LD_VAR 0 2
96840: PUSH
96841: LD_INT 1
96843: PPUSH
96844: LD_VAR 0 2
96848: PPUSH
96849: CALL_OW 12
96853: ARRAY
96854: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96855: LD_VAR 0 1
96859: PPUSH
96860: LD_INT 0
96862: PPUSH
96863: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96867: LD_VAR 0 1
96871: PPUSH
96872: LD_OWVAR 3
96876: PUSH
96877: LD_VAR 0 1
96881: DIFF
96882: PPUSH
96883: LD_VAR 0 1
96887: PPUSH
96888: CALL_OW 74
96892: PPUSH
96893: CALL_OW 115
// wait ( 0 0$20 ) ;
96897: LD_INT 700
96899: PPUSH
96900: CALL_OW 67
// SetSide ( un , your_side ) ;
96904: LD_VAR 0 1
96908: PPUSH
96909: LD_OWVAR 2
96913: PPUSH
96914: CALL_OW 235
// end ;
96918: PPOPN 2
96920: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96921: LD_EXP 133
96925: PUSH
96926: LD_EXP 166
96930: AND
96931: IFFALSE 97037
96933: GO 96935
96935: DISABLE
96936: LD_INT 0
96938: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96939: LD_ADDR_VAR 0 1
96943: PUSH
96944: LD_INT 22
96946: PUSH
96947: LD_OWVAR 2
96951: PUSH
96952: EMPTY
96953: LIST
96954: LIST
96955: PUSH
96956: LD_INT 2
96958: PUSH
96959: LD_INT 30
96961: PUSH
96962: LD_INT 0
96964: PUSH
96965: EMPTY
96966: LIST
96967: LIST
96968: PUSH
96969: LD_INT 30
96971: PUSH
96972: LD_INT 1
96974: PUSH
96975: EMPTY
96976: LIST
96977: LIST
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: LIST
96983: PUSH
96984: EMPTY
96985: LIST
96986: LIST
96987: PPUSH
96988: CALL_OW 69
96992: ST_TO_ADDR
// if not depot then
96993: LD_VAR 0 1
96997: NOT
96998: IFFALSE 97002
// exit ;
97000: GO 97037
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
97002: LD_VAR 0 1
97006: PUSH
97007: LD_INT 1
97009: ARRAY
97010: PPUSH
97011: CALL_OW 250
97015: PPUSH
97016: LD_VAR 0 1
97020: PUSH
97021: LD_INT 1
97023: ARRAY
97024: PPUSH
97025: CALL_OW 251
97029: PPUSH
97030: LD_INT 70
97032: PPUSH
97033: CALL_OW 495
// end ;
97037: PPOPN 1
97039: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
97040: LD_EXP 133
97044: PUSH
97045: LD_EXP 167
97049: AND
97050: IFFALSE 97261
97052: GO 97054
97054: DISABLE
97055: LD_INT 0
97057: PPUSH
97058: PPUSH
97059: PPUSH
97060: PPUSH
97061: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97062: LD_ADDR_VAR 0 5
97066: PUSH
97067: LD_INT 22
97069: PUSH
97070: LD_OWVAR 2
97074: PUSH
97075: EMPTY
97076: LIST
97077: LIST
97078: PUSH
97079: LD_INT 21
97081: PUSH
97082: LD_INT 1
97084: PUSH
97085: EMPTY
97086: LIST
97087: LIST
97088: PUSH
97089: EMPTY
97090: LIST
97091: LIST
97092: PPUSH
97093: CALL_OW 69
97097: ST_TO_ADDR
// if not tmp then
97098: LD_VAR 0 5
97102: NOT
97103: IFFALSE 97107
// exit ;
97105: GO 97261
// for i in tmp do
97107: LD_ADDR_VAR 0 1
97111: PUSH
97112: LD_VAR 0 5
97116: PUSH
97117: FOR_IN
97118: IFFALSE 97259
// begin d := rand ( 0 , 5 ) ;
97120: LD_ADDR_VAR 0 4
97124: PUSH
97125: LD_INT 0
97127: PPUSH
97128: LD_INT 5
97130: PPUSH
97131: CALL_OW 12
97135: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
97136: LD_ADDR_VAR 0 2
97140: PUSH
97141: LD_VAR 0 1
97145: PPUSH
97146: CALL_OW 250
97150: PPUSH
97151: LD_VAR 0 4
97155: PPUSH
97156: LD_INT 3
97158: PPUSH
97159: LD_INT 12
97161: PPUSH
97162: CALL_OW 12
97166: PPUSH
97167: CALL_OW 272
97171: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
97172: LD_ADDR_VAR 0 3
97176: PUSH
97177: LD_VAR 0 1
97181: PPUSH
97182: CALL_OW 251
97186: PPUSH
97187: LD_VAR 0 4
97191: PPUSH
97192: LD_INT 3
97194: PPUSH
97195: LD_INT 12
97197: PPUSH
97198: CALL_OW 12
97202: PPUSH
97203: CALL_OW 273
97207: ST_TO_ADDR
// if ValidHex ( x , y ) then
97208: LD_VAR 0 2
97212: PPUSH
97213: LD_VAR 0 3
97217: PPUSH
97218: CALL_OW 488
97222: IFFALSE 97257
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
97224: LD_VAR 0 1
97228: PPUSH
97229: LD_VAR 0 2
97233: PPUSH
97234: LD_VAR 0 3
97238: PPUSH
97239: LD_INT 3
97241: PPUSH
97242: LD_INT 6
97244: PPUSH
97245: CALL_OW 12
97249: PPUSH
97250: LD_INT 1
97252: PPUSH
97253: CALL_OW 483
// end ;
97257: GO 97117
97259: POP
97260: POP
// end ;
97261: PPOPN 5
97263: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
97264: LD_EXP 133
97268: PUSH
97269: LD_EXP 168
97273: AND
97274: IFFALSE 97368
97276: GO 97278
97278: DISABLE
97279: LD_INT 0
97281: PPUSH
97282: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
97283: LD_ADDR_VAR 0 2
97287: PUSH
97288: LD_INT 22
97290: PUSH
97291: LD_OWVAR 2
97295: PUSH
97296: EMPTY
97297: LIST
97298: LIST
97299: PUSH
97300: LD_INT 32
97302: PUSH
97303: LD_INT 1
97305: PUSH
97306: EMPTY
97307: LIST
97308: LIST
97309: PUSH
97310: LD_INT 21
97312: PUSH
97313: LD_INT 2
97315: PUSH
97316: EMPTY
97317: LIST
97318: LIST
97319: PUSH
97320: EMPTY
97321: LIST
97322: LIST
97323: LIST
97324: PPUSH
97325: CALL_OW 69
97329: ST_TO_ADDR
// if not tmp then
97330: LD_VAR 0 2
97334: NOT
97335: IFFALSE 97339
// exit ;
97337: GO 97368
// for i in tmp do
97339: LD_ADDR_VAR 0 1
97343: PUSH
97344: LD_VAR 0 2
97348: PUSH
97349: FOR_IN
97350: IFFALSE 97366
// SetFuel ( i , 0 ) ;
97352: LD_VAR 0 1
97356: PPUSH
97357: LD_INT 0
97359: PPUSH
97360: CALL_OW 240
97364: GO 97349
97366: POP
97367: POP
// end ;
97368: PPOPN 2
97370: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
97371: LD_EXP 133
97375: PUSH
97376: LD_EXP 169
97380: AND
97381: IFFALSE 97447
97383: GO 97385
97385: DISABLE
97386: LD_INT 0
97388: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97389: LD_ADDR_VAR 0 1
97393: PUSH
97394: LD_INT 22
97396: PUSH
97397: LD_OWVAR 2
97401: PUSH
97402: EMPTY
97403: LIST
97404: LIST
97405: PUSH
97406: LD_INT 30
97408: PUSH
97409: LD_INT 29
97411: PUSH
97412: EMPTY
97413: LIST
97414: LIST
97415: PUSH
97416: EMPTY
97417: LIST
97418: LIST
97419: PPUSH
97420: CALL_OW 69
97424: ST_TO_ADDR
// if not tmp then
97425: LD_VAR 0 1
97429: NOT
97430: IFFALSE 97434
// exit ;
97432: GO 97447
// DestroyUnit ( tmp [ 1 ] ) ;
97434: LD_VAR 0 1
97438: PUSH
97439: LD_INT 1
97441: ARRAY
97442: PPUSH
97443: CALL_OW 65
// end ;
97447: PPOPN 1
97449: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
97450: LD_EXP 133
97454: PUSH
97455: LD_EXP 171
97459: AND
97460: IFFALSE 97589
97462: GO 97464
97464: DISABLE
97465: LD_INT 0
97467: PPUSH
// begin uc_side := 0 ;
97468: LD_ADDR_OWVAR 20
97472: PUSH
97473: LD_INT 0
97475: ST_TO_ADDR
// uc_nation := nation_arabian ;
97476: LD_ADDR_OWVAR 21
97480: PUSH
97481: LD_INT 2
97483: ST_TO_ADDR
// hc_gallery :=  ;
97484: LD_ADDR_OWVAR 33
97488: PUSH
97489: LD_STRING 
97491: ST_TO_ADDR
// hc_name :=  ;
97492: LD_ADDR_OWVAR 26
97496: PUSH
97497: LD_STRING 
97499: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
97500: LD_INT 1
97502: PPUSH
97503: LD_INT 11
97505: PPUSH
97506: LD_INT 10
97508: PPUSH
97509: CALL_OW 380
// un := CreateHuman ;
97513: LD_ADDR_VAR 0 1
97517: PUSH
97518: CALL_OW 44
97522: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97523: LD_VAR 0 1
97527: PPUSH
97528: LD_INT 1
97530: PPUSH
97531: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97535: LD_INT 35
97537: PPUSH
97538: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97542: LD_VAR 0 1
97546: PPUSH
97547: LD_INT 22
97549: PUSH
97550: LD_OWVAR 2
97554: PUSH
97555: EMPTY
97556: LIST
97557: LIST
97558: PPUSH
97559: CALL_OW 69
97563: PPUSH
97564: LD_VAR 0 1
97568: PPUSH
97569: CALL_OW 74
97573: PPUSH
97574: CALL_OW 115
// until IsDead ( un ) ;
97578: LD_VAR 0 1
97582: PPUSH
97583: CALL_OW 301
97587: IFFALSE 97535
// end ;
97589: PPOPN 1
97591: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97592: LD_EXP 133
97596: PUSH
97597: LD_EXP 173
97601: AND
97602: IFFALSE 97614
97604: GO 97606
97606: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97607: LD_STRING earthquake(getX(game), 0, 32)
97609: PPUSH
97610: CALL_OW 559
97614: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97615: LD_EXP 133
97619: PUSH
97620: LD_EXP 174
97624: AND
97625: IFFALSE 97716
97627: GO 97629
97629: DISABLE
97630: LD_INT 0
97632: PPUSH
// begin enable ;
97633: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97634: LD_ADDR_VAR 0 1
97638: PUSH
97639: LD_INT 22
97641: PUSH
97642: LD_OWVAR 2
97646: PUSH
97647: EMPTY
97648: LIST
97649: LIST
97650: PUSH
97651: LD_INT 21
97653: PUSH
97654: LD_INT 2
97656: PUSH
97657: EMPTY
97658: LIST
97659: LIST
97660: PUSH
97661: LD_INT 33
97663: PUSH
97664: LD_INT 3
97666: PUSH
97667: EMPTY
97668: LIST
97669: LIST
97670: PUSH
97671: EMPTY
97672: LIST
97673: LIST
97674: LIST
97675: PPUSH
97676: CALL_OW 69
97680: ST_TO_ADDR
// if not tmp then
97681: LD_VAR 0 1
97685: NOT
97686: IFFALSE 97690
// exit ;
97688: GO 97716
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97690: LD_VAR 0 1
97694: PUSH
97695: LD_INT 1
97697: PPUSH
97698: LD_VAR 0 1
97702: PPUSH
97703: CALL_OW 12
97707: ARRAY
97708: PPUSH
97709: LD_INT 1
97711: PPUSH
97712: CALL_OW 234
// end ;
97716: PPOPN 1
97718: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97719: LD_EXP 133
97723: PUSH
97724: LD_EXP 175
97728: AND
97729: IFFALSE 97870
97731: GO 97733
97733: DISABLE
97734: LD_INT 0
97736: PPUSH
97737: PPUSH
97738: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97739: LD_ADDR_VAR 0 3
97743: PUSH
97744: LD_INT 22
97746: PUSH
97747: LD_OWVAR 2
97751: PUSH
97752: EMPTY
97753: LIST
97754: LIST
97755: PUSH
97756: LD_INT 25
97758: PUSH
97759: LD_INT 1
97761: PUSH
97762: EMPTY
97763: LIST
97764: LIST
97765: PUSH
97766: EMPTY
97767: LIST
97768: LIST
97769: PPUSH
97770: CALL_OW 69
97774: ST_TO_ADDR
// if not tmp then
97775: LD_VAR 0 3
97779: NOT
97780: IFFALSE 97784
// exit ;
97782: GO 97870
// un := tmp [ rand ( 1 , tmp ) ] ;
97784: LD_ADDR_VAR 0 2
97788: PUSH
97789: LD_VAR 0 3
97793: PUSH
97794: LD_INT 1
97796: PPUSH
97797: LD_VAR 0 3
97801: PPUSH
97802: CALL_OW 12
97806: ARRAY
97807: ST_TO_ADDR
// if Crawls ( un ) then
97808: LD_VAR 0 2
97812: PPUSH
97813: CALL_OW 318
97817: IFFALSE 97828
// ComWalk ( un ) ;
97819: LD_VAR 0 2
97823: PPUSH
97824: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97828: LD_VAR 0 2
97832: PPUSH
97833: LD_INT 9
97835: PPUSH
97836: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97840: LD_INT 28
97842: PPUSH
97843: LD_OWVAR 2
97847: PPUSH
97848: LD_INT 2
97850: PPUSH
97851: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97855: LD_INT 29
97857: PPUSH
97858: LD_OWVAR 2
97862: PPUSH
97863: LD_INT 2
97865: PPUSH
97866: CALL_OW 322
// end ;
97870: PPOPN 3
97872: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97873: LD_EXP 133
97877: PUSH
97878: LD_EXP 176
97882: AND
97883: IFFALSE 97994
97885: GO 97887
97887: DISABLE
97888: LD_INT 0
97890: PPUSH
97891: PPUSH
97892: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97893: LD_ADDR_VAR 0 3
97897: PUSH
97898: LD_INT 22
97900: PUSH
97901: LD_OWVAR 2
97905: PUSH
97906: EMPTY
97907: LIST
97908: LIST
97909: PUSH
97910: LD_INT 25
97912: PUSH
97913: LD_INT 1
97915: PUSH
97916: EMPTY
97917: LIST
97918: LIST
97919: PUSH
97920: EMPTY
97921: LIST
97922: LIST
97923: PPUSH
97924: CALL_OW 69
97928: ST_TO_ADDR
// if not tmp then
97929: LD_VAR 0 3
97933: NOT
97934: IFFALSE 97938
// exit ;
97936: GO 97994
// un := tmp [ rand ( 1 , tmp ) ] ;
97938: LD_ADDR_VAR 0 2
97942: PUSH
97943: LD_VAR 0 3
97947: PUSH
97948: LD_INT 1
97950: PPUSH
97951: LD_VAR 0 3
97955: PPUSH
97956: CALL_OW 12
97960: ARRAY
97961: ST_TO_ADDR
// if Crawls ( un ) then
97962: LD_VAR 0 2
97966: PPUSH
97967: CALL_OW 318
97971: IFFALSE 97982
// ComWalk ( un ) ;
97973: LD_VAR 0 2
97977: PPUSH
97978: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97982: LD_VAR 0 2
97986: PPUSH
97987: LD_INT 8
97989: PPUSH
97990: CALL_OW 336
// end ;
97994: PPOPN 3
97996: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
97997: LD_EXP 133
98001: PUSH
98002: LD_EXP 177
98006: AND
98007: IFFALSE 98151
98009: GO 98011
98011: DISABLE
98012: LD_INT 0
98014: PPUSH
98015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
98016: LD_ADDR_VAR 0 2
98020: PUSH
98021: LD_INT 22
98023: PUSH
98024: LD_OWVAR 2
98028: PUSH
98029: EMPTY
98030: LIST
98031: LIST
98032: PUSH
98033: LD_INT 21
98035: PUSH
98036: LD_INT 2
98038: PUSH
98039: EMPTY
98040: LIST
98041: LIST
98042: PUSH
98043: LD_INT 2
98045: PUSH
98046: LD_INT 34
98048: PUSH
98049: LD_INT 12
98051: PUSH
98052: EMPTY
98053: LIST
98054: LIST
98055: PUSH
98056: LD_INT 34
98058: PUSH
98059: LD_INT 51
98061: PUSH
98062: EMPTY
98063: LIST
98064: LIST
98065: PUSH
98066: LD_INT 34
98068: PUSH
98069: LD_INT 32
98071: PUSH
98072: EMPTY
98073: LIST
98074: LIST
98075: PUSH
98076: EMPTY
98077: LIST
98078: LIST
98079: LIST
98080: LIST
98081: PUSH
98082: EMPTY
98083: LIST
98084: LIST
98085: LIST
98086: PPUSH
98087: CALL_OW 69
98091: ST_TO_ADDR
// if not tmp then
98092: LD_VAR 0 2
98096: NOT
98097: IFFALSE 98101
// exit ;
98099: GO 98151
// for i in tmp do
98101: LD_ADDR_VAR 0 1
98105: PUSH
98106: LD_VAR 0 2
98110: PUSH
98111: FOR_IN
98112: IFFALSE 98149
// if GetCargo ( i , mat_artifact ) = 0 then
98114: LD_VAR 0 1
98118: PPUSH
98119: LD_INT 4
98121: PPUSH
98122: CALL_OW 289
98126: PUSH
98127: LD_INT 0
98129: EQUAL
98130: IFFALSE 98147
// SetCargo ( i , mat_siberit , 100 ) ;
98132: LD_VAR 0 1
98136: PPUSH
98137: LD_INT 3
98139: PPUSH
98140: LD_INT 100
98142: PPUSH
98143: CALL_OW 290
98147: GO 98111
98149: POP
98150: POP
// end ;
98151: PPOPN 2
98153: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
98154: LD_EXP 133
98158: PUSH
98159: LD_EXP 178
98163: AND
98164: IFFALSE 98347
98166: GO 98168
98168: DISABLE
98169: LD_INT 0
98171: PPUSH
98172: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98173: LD_ADDR_VAR 0 2
98177: PUSH
98178: LD_INT 22
98180: PUSH
98181: LD_OWVAR 2
98185: PUSH
98186: EMPTY
98187: LIST
98188: LIST
98189: PPUSH
98190: CALL_OW 69
98194: ST_TO_ADDR
// if not tmp then
98195: LD_VAR 0 2
98199: NOT
98200: IFFALSE 98204
// exit ;
98202: GO 98347
// for i := 1 to 2 do
98204: LD_ADDR_VAR 0 1
98208: PUSH
98209: DOUBLE
98210: LD_INT 1
98212: DEC
98213: ST_TO_ADDR
98214: LD_INT 2
98216: PUSH
98217: FOR_TO
98218: IFFALSE 98345
// begin uc_side := your_side ;
98220: LD_ADDR_OWVAR 20
98224: PUSH
98225: LD_OWVAR 2
98229: ST_TO_ADDR
// uc_nation := nation_american ;
98230: LD_ADDR_OWVAR 21
98234: PUSH
98235: LD_INT 1
98237: ST_TO_ADDR
// vc_chassis := us_morphling ;
98238: LD_ADDR_OWVAR 37
98242: PUSH
98243: LD_INT 5
98245: ST_TO_ADDR
// vc_engine := engine_siberite ;
98246: LD_ADDR_OWVAR 39
98250: PUSH
98251: LD_INT 3
98253: ST_TO_ADDR
// vc_control := control_computer ;
98254: LD_ADDR_OWVAR 38
98258: PUSH
98259: LD_INT 3
98261: ST_TO_ADDR
// vc_weapon := us_double_laser ;
98262: LD_ADDR_OWVAR 40
98266: PUSH
98267: LD_INT 10
98269: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
98270: LD_VAR 0 2
98274: PUSH
98275: LD_INT 1
98277: ARRAY
98278: PPUSH
98279: CALL_OW 310
98283: NOT
98284: IFFALSE 98331
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
98286: CALL_OW 45
98290: PPUSH
98291: LD_VAR 0 2
98295: PUSH
98296: LD_INT 1
98298: ARRAY
98299: PPUSH
98300: CALL_OW 250
98304: PPUSH
98305: LD_VAR 0 2
98309: PUSH
98310: LD_INT 1
98312: ARRAY
98313: PPUSH
98314: CALL_OW 251
98318: PPUSH
98319: LD_INT 12
98321: PPUSH
98322: LD_INT 1
98324: PPUSH
98325: CALL_OW 50
98329: GO 98343
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
98331: CALL_OW 45
98335: PPUSH
98336: LD_INT 1
98338: PPUSH
98339: CALL_OW 51
// end ;
98343: GO 98217
98345: POP
98346: POP
// end ;
98347: PPOPN 2
98349: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
98350: LD_EXP 133
98354: PUSH
98355: LD_EXP 179
98359: AND
98360: IFFALSE 98582
98362: GO 98364
98364: DISABLE
98365: LD_INT 0
98367: PPUSH
98368: PPUSH
98369: PPUSH
98370: PPUSH
98371: PPUSH
98372: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98373: LD_ADDR_VAR 0 6
98377: PUSH
98378: LD_INT 22
98380: PUSH
98381: LD_OWVAR 2
98385: PUSH
98386: EMPTY
98387: LIST
98388: LIST
98389: PUSH
98390: LD_INT 21
98392: PUSH
98393: LD_INT 1
98395: PUSH
98396: EMPTY
98397: LIST
98398: LIST
98399: PUSH
98400: LD_INT 3
98402: PUSH
98403: LD_INT 23
98405: PUSH
98406: LD_INT 0
98408: PUSH
98409: EMPTY
98410: LIST
98411: LIST
98412: PUSH
98413: EMPTY
98414: LIST
98415: LIST
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: LIST
98421: PPUSH
98422: CALL_OW 69
98426: ST_TO_ADDR
// if not tmp then
98427: LD_VAR 0 6
98431: NOT
98432: IFFALSE 98436
// exit ;
98434: GO 98582
// s1 := rand ( 1 , 4 ) ;
98436: LD_ADDR_VAR 0 2
98440: PUSH
98441: LD_INT 1
98443: PPUSH
98444: LD_INT 4
98446: PPUSH
98447: CALL_OW 12
98451: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
98452: LD_ADDR_VAR 0 4
98456: PUSH
98457: LD_VAR 0 6
98461: PUSH
98462: LD_INT 1
98464: ARRAY
98465: PPUSH
98466: LD_VAR 0 2
98470: PPUSH
98471: CALL_OW 259
98475: ST_TO_ADDR
// if s1 = 1 then
98476: LD_VAR 0 2
98480: PUSH
98481: LD_INT 1
98483: EQUAL
98484: IFFALSE 98504
// s2 := rand ( 2 , 4 ) else
98486: LD_ADDR_VAR 0 3
98490: PUSH
98491: LD_INT 2
98493: PPUSH
98494: LD_INT 4
98496: PPUSH
98497: CALL_OW 12
98501: ST_TO_ADDR
98502: GO 98512
// s2 := 1 ;
98504: LD_ADDR_VAR 0 3
98508: PUSH
98509: LD_INT 1
98511: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98512: LD_ADDR_VAR 0 5
98516: PUSH
98517: LD_VAR 0 6
98521: PUSH
98522: LD_INT 1
98524: ARRAY
98525: PPUSH
98526: LD_VAR 0 3
98530: PPUSH
98531: CALL_OW 259
98535: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98536: LD_VAR 0 6
98540: PUSH
98541: LD_INT 1
98543: ARRAY
98544: PPUSH
98545: LD_VAR 0 2
98549: PPUSH
98550: LD_VAR 0 5
98554: PPUSH
98555: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98559: LD_VAR 0 6
98563: PUSH
98564: LD_INT 1
98566: ARRAY
98567: PPUSH
98568: LD_VAR 0 3
98572: PPUSH
98573: LD_VAR 0 4
98577: PPUSH
98578: CALL_OW 237
// end ;
98582: PPOPN 6
98584: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98585: LD_EXP 133
98589: PUSH
98590: LD_EXP 180
98594: AND
98595: IFFALSE 98674
98597: GO 98599
98599: DISABLE
98600: LD_INT 0
98602: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98603: LD_ADDR_VAR 0 1
98607: PUSH
98608: LD_INT 22
98610: PUSH
98611: LD_OWVAR 2
98615: PUSH
98616: EMPTY
98617: LIST
98618: LIST
98619: PUSH
98620: LD_INT 30
98622: PUSH
98623: LD_INT 3
98625: PUSH
98626: EMPTY
98627: LIST
98628: LIST
98629: PUSH
98630: EMPTY
98631: LIST
98632: LIST
98633: PPUSH
98634: CALL_OW 69
98638: ST_TO_ADDR
// if not tmp then
98639: LD_VAR 0 1
98643: NOT
98644: IFFALSE 98648
// exit ;
98646: GO 98674
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98648: LD_VAR 0 1
98652: PUSH
98653: LD_INT 1
98655: PPUSH
98656: LD_VAR 0 1
98660: PPUSH
98661: CALL_OW 12
98665: ARRAY
98666: PPUSH
98667: LD_INT 1
98669: PPUSH
98670: CALL_OW 234
// end ;
98674: PPOPN 1
98676: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98677: LD_EXP 133
98681: PUSH
98682: LD_EXP 181
98686: AND
98687: IFFALSE 98799
98689: GO 98691
98691: DISABLE
98692: LD_INT 0
98694: PPUSH
98695: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98696: LD_ADDR_VAR 0 2
98700: PUSH
98701: LD_INT 22
98703: PUSH
98704: LD_OWVAR 2
98708: PUSH
98709: EMPTY
98710: LIST
98711: LIST
98712: PUSH
98713: LD_INT 2
98715: PUSH
98716: LD_INT 30
98718: PUSH
98719: LD_INT 27
98721: PUSH
98722: EMPTY
98723: LIST
98724: LIST
98725: PUSH
98726: LD_INT 30
98728: PUSH
98729: LD_INT 26
98731: PUSH
98732: EMPTY
98733: LIST
98734: LIST
98735: PUSH
98736: LD_INT 30
98738: PUSH
98739: LD_INT 28
98741: PUSH
98742: EMPTY
98743: LIST
98744: LIST
98745: PUSH
98746: EMPTY
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: PUSH
98752: EMPTY
98753: LIST
98754: LIST
98755: PPUSH
98756: CALL_OW 69
98760: ST_TO_ADDR
// if not tmp then
98761: LD_VAR 0 2
98765: NOT
98766: IFFALSE 98770
// exit ;
98768: GO 98799
// for i in tmp do
98770: LD_ADDR_VAR 0 1
98774: PUSH
98775: LD_VAR 0 2
98779: PUSH
98780: FOR_IN
98781: IFFALSE 98797
// SetLives ( i , 1 ) ;
98783: LD_VAR 0 1
98787: PPUSH
98788: LD_INT 1
98790: PPUSH
98791: CALL_OW 234
98795: GO 98780
98797: POP
98798: POP
// end ;
98799: PPOPN 2
98801: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98802: LD_EXP 133
98806: PUSH
98807: LD_EXP 182
98811: AND
98812: IFFALSE 99086
98814: GO 98816
98816: DISABLE
98817: LD_INT 0
98819: PPUSH
98820: PPUSH
98821: PPUSH
// begin i := rand ( 1 , 7 ) ;
98822: LD_ADDR_VAR 0 1
98826: PUSH
98827: LD_INT 1
98829: PPUSH
98830: LD_INT 7
98832: PPUSH
98833: CALL_OW 12
98837: ST_TO_ADDR
// case i of 1 :
98838: LD_VAR 0 1
98842: PUSH
98843: LD_INT 1
98845: DOUBLE
98846: EQUAL
98847: IFTRUE 98851
98849: GO 98861
98851: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98852: LD_STRING earthquake(getX(game), 0, 32)
98854: PPUSH
98855: CALL_OW 559
98859: GO 99086
98861: LD_INT 2
98863: DOUBLE
98864: EQUAL
98865: IFTRUE 98869
98867: GO 98883
98869: POP
// begin ToLua ( displayStucuk(); ) ;
98870: LD_STRING displayStucuk();
98872: PPUSH
98873: CALL_OW 559
// ResetFog ;
98877: CALL_OW 335
// end ; 3 :
98881: GO 99086
98883: LD_INT 3
98885: DOUBLE
98886: EQUAL
98887: IFTRUE 98891
98889: GO 98995
98891: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98892: LD_ADDR_VAR 0 2
98896: PUSH
98897: LD_INT 22
98899: PUSH
98900: LD_OWVAR 2
98904: PUSH
98905: EMPTY
98906: LIST
98907: LIST
98908: PUSH
98909: LD_INT 25
98911: PUSH
98912: LD_INT 1
98914: PUSH
98915: EMPTY
98916: LIST
98917: LIST
98918: PUSH
98919: EMPTY
98920: LIST
98921: LIST
98922: PPUSH
98923: CALL_OW 69
98927: ST_TO_ADDR
// if not tmp then
98928: LD_VAR 0 2
98932: NOT
98933: IFFALSE 98937
// exit ;
98935: GO 99086
// un := tmp [ rand ( 1 , tmp ) ] ;
98937: LD_ADDR_VAR 0 3
98941: PUSH
98942: LD_VAR 0 2
98946: PUSH
98947: LD_INT 1
98949: PPUSH
98950: LD_VAR 0 2
98954: PPUSH
98955: CALL_OW 12
98959: ARRAY
98960: ST_TO_ADDR
// if Crawls ( un ) then
98961: LD_VAR 0 3
98965: PPUSH
98966: CALL_OW 318
98970: IFFALSE 98981
// ComWalk ( un ) ;
98972: LD_VAR 0 3
98976: PPUSH
98977: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98981: LD_VAR 0 3
98985: PPUSH
98986: LD_INT 8
98988: PPUSH
98989: CALL_OW 336
// end ; 4 :
98993: GO 99086
98995: LD_INT 4
98997: DOUBLE
98998: EQUAL
98999: IFTRUE 99003
99001: GO 99064
99003: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99004: LD_ADDR_VAR 0 2
99008: PUSH
99009: LD_INT 22
99011: PUSH
99012: LD_OWVAR 2
99016: PUSH
99017: EMPTY
99018: LIST
99019: LIST
99020: PUSH
99021: LD_INT 30
99023: PUSH
99024: LD_INT 29
99026: PUSH
99027: EMPTY
99028: LIST
99029: LIST
99030: PUSH
99031: EMPTY
99032: LIST
99033: LIST
99034: PPUSH
99035: CALL_OW 69
99039: ST_TO_ADDR
// if not tmp then
99040: LD_VAR 0 2
99044: NOT
99045: IFFALSE 99049
// exit ;
99047: GO 99086
// DestroyUnit ( tmp [ 1 ] ) ;
99049: LD_VAR 0 2
99053: PUSH
99054: LD_INT 1
99056: ARRAY
99057: PPUSH
99058: CALL_OW 65
// end ; 5 .. 7 :
99062: GO 99086
99064: LD_INT 5
99066: DOUBLE
99067: GREATEREQUAL
99068: IFFALSE 99076
99070: LD_INT 7
99072: DOUBLE
99073: LESSEQUAL
99074: IFTRUE 99078
99076: GO 99085
99078: POP
// StreamSibBomb ; end ;
99079: CALL 95336 0 0
99083: GO 99086
99085: POP
// end ;
99086: PPOPN 3
99088: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
99089: LD_EXP 133
99093: PUSH
99094: LD_EXP 183
99098: AND
99099: IFFALSE 99255
99101: GO 99103
99103: DISABLE
99104: LD_INT 0
99106: PPUSH
99107: PPUSH
99108: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
99109: LD_ADDR_VAR 0 2
99113: PUSH
99114: LD_INT 81
99116: PUSH
99117: LD_OWVAR 2
99121: PUSH
99122: EMPTY
99123: LIST
99124: LIST
99125: PUSH
99126: LD_INT 2
99128: PUSH
99129: LD_INT 21
99131: PUSH
99132: LD_INT 1
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: PUSH
99139: LD_INT 21
99141: PUSH
99142: LD_INT 2
99144: PUSH
99145: EMPTY
99146: LIST
99147: LIST
99148: PUSH
99149: EMPTY
99150: LIST
99151: LIST
99152: LIST
99153: PUSH
99154: EMPTY
99155: LIST
99156: LIST
99157: PPUSH
99158: CALL_OW 69
99162: ST_TO_ADDR
// if not tmp then
99163: LD_VAR 0 2
99167: NOT
99168: IFFALSE 99172
// exit ;
99170: GO 99255
// p := 0 ;
99172: LD_ADDR_VAR 0 3
99176: PUSH
99177: LD_INT 0
99179: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99180: LD_INT 35
99182: PPUSH
99183: CALL_OW 67
// p := p + 1 ;
99187: LD_ADDR_VAR 0 3
99191: PUSH
99192: LD_VAR 0 3
99196: PUSH
99197: LD_INT 1
99199: PLUS
99200: ST_TO_ADDR
// for i in tmp do
99201: LD_ADDR_VAR 0 1
99205: PUSH
99206: LD_VAR 0 2
99210: PUSH
99211: FOR_IN
99212: IFFALSE 99243
// if GetLives ( i ) < 1000 then
99214: LD_VAR 0 1
99218: PPUSH
99219: CALL_OW 256
99223: PUSH
99224: LD_INT 1000
99226: LESS
99227: IFFALSE 99241
// SetLives ( i , 1000 ) ;
99229: LD_VAR 0 1
99233: PPUSH
99234: LD_INT 1000
99236: PPUSH
99237: CALL_OW 234
99241: GO 99211
99243: POP
99244: POP
// until p > 20 ;
99245: LD_VAR 0 3
99249: PUSH
99250: LD_INT 20
99252: GREATER
99253: IFFALSE 99180
// end ;
99255: PPOPN 3
99257: END
// every 0 0$1 trigger StreamModeActive and sTime do
99258: LD_EXP 133
99262: PUSH
99263: LD_EXP 184
99267: AND
99268: IFFALSE 99303
99270: GO 99272
99272: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
99273: LD_INT 28
99275: PPUSH
99276: LD_OWVAR 2
99280: PPUSH
99281: LD_INT 2
99283: PPUSH
99284: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
99288: LD_INT 30
99290: PPUSH
99291: LD_OWVAR 2
99295: PPUSH
99296: LD_INT 2
99298: PPUSH
99299: CALL_OW 322
// end ;
99303: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
99304: LD_EXP 133
99308: PUSH
99309: LD_EXP 185
99313: AND
99314: IFFALSE 99435
99316: GO 99318
99318: DISABLE
99319: LD_INT 0
99321: PPUSH
99322: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99323: LD_ADDR_VAR 0 2
99327: PUSH
99328: LD_INT 22
99330: PUSH
99331: LD_OWVAR 2
99335: PUSH
99336: EMPTY
99337: LIST
99338: LIST
99339: PUSH
99340: LD_INT 21
99342: PUSH
99343: LD_INT 1
99345: PUSH
99346: EMPTY
99347: LIST
99348: LIST
99349: PUSH
99350: LD_INT 3
99352: PUSH
99353: LD_INT 23
99355: PUSH
99356: LD_INT 0
99358: PUSH
99359: EMPTY
99360: LIST
99361: LIST
99362: PUSH
99363: EMPTY
99364: LIST
99365: LIST
99366: PUSH
99367: EMPTY
99368: LIST
99369: LIST
99370: LIST
99371: PPUSH
99372: CALL_OW 69
99376: ST_TO_ADDR
// if not tmp then
99377: LD_VAR 0 2
99381: NOT
99382: IFFALSE 99386
// exit ;
99384: GO 99435
// for i in tmp do
99386: LD_ADDR_VAR 0 1
99390: PUSH
99391: LD_VAR 0 2
99395: PUSH
99396: FOR_IN
99397: IFFALSE 99433
// begin if Crawls ( i ) then
99399: LD_VAR 0 1
99403: PPUSH
99404: CALL_OW 318
99408: IFFALSE 99419
// ComWalk ( i ) ;
99410: LD_VAR 0 1
99414: PPUSH
99415: CALL_OW 138
// SetClass ( i , 2 ) ;
99419: LD_VAR 0 1
99423: PPUSH
99424: LD_INT 2
99426: PPUSH
99427: CALL_OW 336
// end ;
99431: GO 99396
99433: POP
99434: POP
// end ;
99435: PPOPN 2
99437: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
99438: LD_EXP 133
99442: PUSH
99443: LD_EXP 186
99447: AND
99448: IFFALSE 99729
99450: GO 99452
99452: DISABLE
99453: LD_INT 0
99455: PPUSH
99456: PPUSH
99457: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
99458: LD_OWVAR 2
99462: PPUSH
99463: LD_INT 9
99465: PPUSH
99466: LD_INT 1
99468: PPUSH
99469: LD_INT 1
99471: PPUSH
99472: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
99476: LD_INT 9
99478: PPUSH
99479: LD_OWVAR 2
99483: PPUSH
99484: CALL_OW 343
// uc_side := 9 ;
99488: LD_ADDR_OWVAR 20
99492: PUSH
99493: LD_INT 9
99495: ST_TO_ADDR
// uc_nation := 2 ;
99496: LD_ADDR_OWVAR 21
99500: PUSH
99501: LD_INT 2
99503: ST_TO_ADDR
// hc_name := Dark Warrior ;
99504: LD_ADDR_OWVAR 26
99508: PUSH
99509: LD_STRING Dark Warrior
99511: ST_TO_ADDR
// hc_gallery :=  ;
99512: LD_ADDR_OWVAR 33
99516: PUSH
99517: LD_STRING 
99519: ST_TO_ADDR
// hc_noskilllimit := true ;
99520: LD_ADDR_OWVAR 76
99524: PUSH
99525: LD_INT 1
99527: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99528: LD_ADDR_OWVAR 31
99532: PUSH
99533: LD_INT 30
99535: PUSH
99536: LD_INT 30
99538: PUSH
99539: LD_INT 30
99541: PUSH
99542: LD_INT 30
99544: PUSH
99545: EMPTY
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: ST_TO_ADDR
// un := CreateHuman ;
99551: LD_ADDR_VAR 0 3
99555: PUSH
99556: CALL_OW 44
99560: ST_TO_ADDR
// hc_noskilllimit := false ;
99561: LD_ADDR_OWVAR 76
99565: PUSH
99566: LD_INT 0
99568: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99569: LD_VAR 0 3
99573: PPUSH
99574: LD_INT 1
99576: PPUSH
99577: CALL_OW 51
// p := 0 ;
99581: LD_ADDR_VAR 0 2
99585: PUSH
99586: LD_INT 0
99588: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99589: LD_INT 35
99591: PPUSH
99592: CALL_OW 67
// p := p + 1 ;
99596: LD_ADDR_VAR 0 2
99600: PUSH
99601: LD_VAR 0 2
99605: PUSH
99606: LD_INT 1
99608: PLUS
99609: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99610: LD_VAR 0 3
99614: PPUSH
99615: CALL_OW 256
99619: PUSH
99620: LD_INT 1000
99622: LESS
99623: IFFALSE 99637
// SetLives ( un , 1000 ) ;
99625: LD_VAR 0 3
99629: PPUSH
99630: LD_INT 1000
99632: PPUSH
99633: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99637: LD_VAR 0 3
99641: PPUSH
99642: LD_INT 81
99644: PUSH
99645: LD_OWVAR 2
99649: PUSH
99650: EMPTY
99651: LIST
99652: LIST
99653: PUSH
99654: LD_INT 91
99656: PUSH
99657: LD_VAR 0 3
99661: PUSH
99662: LD_INT 30
99664: PUSH
99665: EMPTY
99666: LIST
99667: LIST
99668: LIST
99669: PUSH
99670: EMPTY
99671: LIST
99672: LIST
99673: PPUSH
99674: CALL_OW 69
99678: PPUSH
99679: LD_VAR 0 3
99683: PPUSH
99684: CALL_OW 74
99688: PPUSH
99689: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
99693: LD_VAR 0 2
99697: PUSH
99698: LD_INT 60
99700: GREATER
99701: PUSH
99702: LD_VAR 0 3
99706: PPUSH
99707: CALL_OW 301
99711: OR
99712: IFFALSE 99589
// if un then
99714: LD_VAR 0 3
99718: IFFALSE 99729
// RemoveUnit ( un ) ;
99720: LD_VAR 0 3
99724: PPUSH
99725: CALL_OW 64
// end ;
99729: PPOPN 3
99731: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99732: LD_INT 0
99734: PPUSH
// case cmd of 301 :
99735: LD_VAR 0 1
99739: PUSH
99740: LD_INT 301
99742: DOUBLE
99743: EQUAL
99744: IFTRUE 99748
99746: GO 99780
99748: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99749: LD_VAR 0 6
99753: PPUSH
99754: LD_VAR 0 7
99758: PPUSH
99759: LD_VAR 0 8
99763: PPUSH
99764: LD_VAR 0 4
99768: PPUSH
99769: LD_VAR 0 5
99773: PPUSH
99774: CALL 100981 0 5
99778: GO 99901
99780: LD_INT 302
99782: DOUBLE
99783: EQUAL
99784: IFTRUE 99788
99786: GO 99825
99788: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99789: LD_VAR 0 6
99793: PPUSH
99794: LD_VAR 0 7
99798: PPUSH
99799: LD_VAR 0 8
99803: PPUSH
99804: LD_VAR 0 9
99808: PPUSH
99809: LD_VAR 0 4
99813: PPUSH
99814: LD_VAR 0 5
99818: PPUSH
99819: CALL 101072 0 6
99823: GO 99901
99825: LD_INT 303
99827: DOUBLE
99828: EQUAL
99829: IFTRUE 99833
99831: GO 99870
99833: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99834: LD_VAR 0 6
99838: PPUSH
99839: LD_VAR 0 7
99843: PPUSH
99844: LD_VAR 0 8
99848: PPUSH
99849: LD_VAR 0 9
99853: PPUSH
99854: LD_VAR 0 4
99858: PPUSH
99859: LD_VAR 0 5
99863: PPUSH
99864: CALL 99906 0 6
99868: GO 99901
99870: LD_INT 304
99872: DOUBLE
99873: EQUAL
99874: IFTRUE 99878
99876: GO 99900
99878: POP
// hHackTeleport ( unit , x , y ) ; end ;
99879: LD_VAR 0 2
99883: PPUSH
99884: LD_VAR 0 4
99888: PPUSH
99889: LD_VAR 0 5
99893: PPUSH
99894: CALL 101665 0 3
99898: GO 99901
99900: POP
// end ;
99901: LD_VAR 0 12
99905: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
99906: LD_INT 0
99908: PPUSH
99909: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
99910: LD_VAR 0 1
99914: PUSH
99915: LD_INT 1
99917: LESS
99918: PUSH
99919: LD_VAR 0 1
99923: PUSH
99924: LD_INT 3
99926: GREATER
99927: OR
99928: PUSH
99929: LD_VAR 0 5
99933: PPUSH
99934: LD_VAR 0 6
99938: PPUSH
99939: CALL_OW 428
99943: OR
99944: IFFALSE 99948
// exit ;
99946: GO 100668
// uc_side := your_side ;
99948: LD_ADDR_OWVAR 20
99952: PUSH
99953: LD_OWVAR 2
99957: ST_TO_ADDR
// uc_nation := nation ;
99958: LD_ADDR_OWVAR 21
99962: PUSH
99963: LD_VAR 0 1
99967: ST_TO_ADDR
// bc_level = 1 ;
99968: LD_ADDR_OWVAR 43
99972: PUSH
99973: LD_INT 1
99975: ST_TO_ADDR
// case btype of 1 :
99976: LD_VAR 0 2
99980: PUSH
99981: LD_INT 1
99983: DOUBLE
99984: EQUAL
99985: IFTRUE 99989
99987: GO 100000
99989: POP
// bc_type := b_depot ; 2 :
99990: LD_ADDR_OWVAR 42
99994: PUSH
99995: LD_INT 0
99997: ST_TO_ADDR
99998: GO 100612
100000: LD_INT 2
100002: DOUBLE
100003: EQUAL
100004: IFTRUE 100008
100006: GO 100019
100008: POP
// bc_type := b_warehouse ; 3 :
100009: LD_ADDR_OWVAR 42
100013: PUSH
100014: LD_INT 1
100016: ST_TO_ADDR
100017: GO 100612
100019: LD_INT 3
100021: DOUBLE
100022: EQUAL
100023: IFTRUE 100027
100025: GO 100038
100027: POP
// bc_type := b_lab ; 4 .. 9 :
100028: LD_ADDR_OWVAR 42
100032: PUSH
100033: LD_INT 6
100035: ST_TO_ADDR
100036: GO 100612
100038: LD_INT 4
100040: DOUBLE
100041: GREATEREQUAL
100042: IFFALSE 100050
100044: LD_INT 9
100046: DOUBLE
100047: LESSEQUAL
100048: IFTRUE 100052
100050: GO 100104
100052: POP
// begin bc_type := b_lab_half ;
100053: LD_ADDR_OWVAR 42
100057: PUSH
100058: LD_INT 7
100060: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
100061: LD_ADDR_OWVAR 44
100065: PUSH
100066: LD_INT 10
100068: PUSH
100069: LD_INT 11
100071: PUSH
100072: LD_INT 12
100074: PUSH
100075: LD_INT 15
100077: PUSH
100078: LD_INT 14
100080: PUSH
100081: LD_INT 13
100083: PUSH
100084: EMPTY
100085: LIST
100086: LIST
100087: LIST
100088: LIST
100089: LIST
100090: LIST
100091: PUSH
100092: LD_VAR 0 2
100096: PUSH
100097: LD_INT 3
100099: MINUS
100100: ARRAY
100101: ST_TO_ADDR
// end ; 10 .. 13 :
100102: GO 100612
100104: LD_INT 10
100106: DOUBLE
100107: GREATEREQUAL
100108: IFFALSE 100116
100110: LD_INT 13
100112: DOUBLE
100113: LESSEQUAL
100114: IFTRUE 100118
100116: GO 100195
100118: POP
// begin bc_type := b_lab_full ;
100119: LD_ADDR_OWVAR 42
100123: PUSH
100124: LD_INT 8
100126: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
100127: LD_ADDR_OWVAR 44
100131: PUSH
100132: LD_INT 10
100134: PUSH
100135: LD_INT 12
100137: PUSH
100138: LD_INT 14
100140: PUSH
100141: LD_INT 13
100143: PUSH
100144: EMPTY
100145: LIST
100146: LIST
100147: LIST
100148: LIST
100149: PUSH
100150: LD_VAR 0 2
100154: PUSH
100155: LD_INT 9
100157: MINUS
100158: ARRAY
100159: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
100160: LD_ADDR_OWVAR 45
100164: PUSH
100165: LD_INT 11
100167: PUSH
100168: LD_INT 15
100170: PUSH
100171: LD_INT 12
100173: PUSH
100174: LD_INT 15
100176: PUSH
100177: EMPTY
100178: LIST
100179: LIST
100180: LIST
100181: LIST
100182: PUSH
100183: LD_VAR 0 2
100187: PUSH
100188: LD_INT 9
100190: MINUS
100191: ARRAY
100192: ST_TO_ADDR
// end ; 14 :
100193: GO 100612
100195: LD_INT 14
100197: DOUBLE
100198: EQUAL
100199: IFTRUE 100203
100201: GO 100214
100203: POP
// bc_type := b_workshop ; 15 :
100204: LD_ADDR_OWVAR 42
100208: PUSH
100209: LD_INT 2
100211: ST_TO_ADDR
100212: GO 100612
100214: LD_INT 15
100216: DOUBLE
100217: EQUAL
100218: IFTRUE 100222
100220: GO 100233
100222: POP
// bc_type := b_factory ; 16 :
100223: LD_ADDR_OWVAR 42
100227: PUSH
100228: LD_INT 3
100230: ST_TO_ADDR
100231: GO 100612
100233: LD_INT 16
100235: DOUBLE
100236: EQUAL
100237: IFTRUE 100241
100239: GO 100252
100241: POP
// bc_type := b_ext_gun ; 17 :
100242: LD_ADDR_OWVAR 42
100246: PUSH
100247: LD_INT 17
100249: ST_TO_ADDR
100250: GO 100612
100252: LD_INT 17
100254: DOUBLE
100255: EQUAL
100256: IFTRUE 100260
100258: GO 100288
100260: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100261: LD_ADDR_OWVAR 42
100265: PUSH
100266: LD_INT 19
100268: PUSH
100269: LD_INT 23
100271: PUSH
100272: LD_INT 19
100274: PUSH
100275: EMPTY
100276: LIST
100277: LIST
100278: LIST
100279: PUSH
100280: LD_VAR 0 1
100284: ARRAY
100285: ST_TO_ADDR
100286: GO 100612
100288: LD_INT 18
100290: DOUBLE
100291: EQUAL
100292: IFTRUE 100296
100294: GO 100307
100296: POP
// bc_type := b_ext_radar ; 19 :
100297: LD_ADDR_OWVAR 42
100301: PUSH
100302: LD_INT 20
100304: ST_TO_ADDR
100305: GO 100612
100307: LD_INT 19
100309: DOUBLE
100310: EQUAL
100311: IFTRUE 100315
100313: GO 100326
100315: POP
// bc_type := b_ext_radio ; 20 :
100316: LD_ADDR_OWVAR 42
100320: PUSH
100321: LD_INT 22
100323: ST_TO_ADDR
100324: GO 100612
100326: LD_INT 20
100328: DOUBLE
100329: EQUAL
100330: IFTRUE 100334
100332: GO 100345
100334: POP
// bc_type := b_ext_siberium ; 21 :
100335: LD_ADDR_OWVAR 42
100339: PUSH
100340: LD_INT 21
100342: ST_TO_ADDR
100343: GO 100612
100345: LD_INT 21
100347: DOUBLE
100348: EQUAL
100349: IFTRUE 100353
100351: GO 100364
100353: POP
// bc_type := b_ext_computer ; 22 :
100354: LD_ADDR_OWVAR 42
100358: PUSH
100359: LD_INT 24
100361: ST_TO_ADDR
100362: GO 100612
100364: LD_INT 22
100366: DOUBLE
100367: EQUAL
100368: IFTRUE 100372
100370: GO 100383
100372: POP
// bc_type := b_ext_track ; 23 :
100373: LD_ADDR_OWVAR 42
100377: PUSH
100378: LD_INT 16
100380: ST_TO_ADDR
100381: GO 100612
100383: LD_INT 23
100385: DOUBLE
100386: EQUAL
100387: IFTRUE 100391
100389: GO 100402
100391: POP
// bc_type := b_ext_laser ; 24 :
100392: LD_ADDR_OWVAR 42
100396: PUSH
100397: LD_INT 25
100399: ST_TO_ADDR
100400: GO 100612
100402: LD_INT 24
100404: DOUBLE
100405: EQUAL
100406: IFTRUE 100410
100408: GO 100421
100410: POP
// bc_type := b_control_tower ; 25 :
100411: LD_ADDR_OWVAR 42
100415: PUSH
100416: LD_INT 36
100418: ST_TO_ADDR
100419: GO 100612
100421: LD_INT 25
100423: DOUBLE
100424: EQUAL
100425: IFTRUE 100429
100427: GO 100440
100429: POP
// bc_type := b_breastwork ; 26 :
100430: LD_ADDR_OWVAR 42
100434: PUSH
100435: LD_INT 31
100437: ST_TO_ADDR
100438: GO 100612
100440: LD_INT 26
100442: DOUBLE
100443: EQUAL
100444: IFTRUE 100448
100446: GO 100459
100448: POP
// bc_type := b_bunker ; 27 :
100449: LD_ADDR_OWVAR 42
100453: PUSH
100454: LD_INT 32
100456: ST_TO_ADDR
100457: GO 100612
100459: LD_INT 27
100461: DOUBLE
100462: EQUAL
100463: IFTRUE 100467
100465: GO 100478
100467: POP
// bc_type := b_turret ; 28 :
100468: LD_ADDR_OWVAR 42
100472: PUSH
100473: LD_INT 33
100475: ST_TO_ADDR
100476: GO 100612
100478: LD_INT 28
100480: DOUBLE
100481: EQUAL
100482: IFTRUE 100486
100484: GO 100497
100486: POP
// bc_type := b_armoury ; 29 :
100487: LD_ADDR_OWVAR 42
100491: PUSH
100492: LD_INT 4
100494: ST_TO_ADDR
100495: GO 100612
100497: LD_INT 29
100499: DOUBLE
100500: EQUAL
100501: IFTRUE 100505
100503: GO 100516
100505: POP
// bc_type := b_barracks ; 30 :
100506: LD_ADDR_OWVAR 42
100510: PUSH
100511: LD_INT 5
100513: ST_TO_ADDR
100514: GO 100612
100516: LD_INT 30
100518: DOUBLE
100519: EQUAL
100520: IFTRUE 100524
100522: GO 100535
100524: POP
// bc_type := b_solar_power ; 31 :
100525: LD_ADDR_OWVAR 42
100529: PUSH
100530: LD_INT 27
100532: ST_TO_ADDR
100533: GO 100612
100535: LD_INT 31
100537: DOUBLE
100538: EQUAL
100539: IFTRUE 100543
100541: GO 100554
100543: POP
// bc_type := b_oil_power ; 32 :
100544: LD_ADDR_OWVAR 42
100548: PUSH
100549: LD_INT 26
100551: ST_TO_ADDR
100552: GO 100612
100554: LD_INT 32
100556: DOUBLE
100557: EQUAL
100558: IFTRUE 100562
100560: GO 100573
100562: POP
// bc_type := b_siberite_power ; 33 :
100563: LD_ADDR_OWVAR 42
100567: PUSH
100568: LD_INT 28
100570: ST_TO_ADDR
100571: GO 100612
100573: LD_INT 33
100575: DOUBLE
100576: EQUAL
100577: IFTRUE 100581
100579: GO 100592
100581: POP
// bc_type := b_oil_mine ; 34 :
100582: LD_ADDR_OWVAR 42
100586: PUSH
100587: LD_INT 29
100589: ST_TO_ADDR
100590: GO 100612
100592: LD_INT 34
100594: DOUBLE
100595: EQUAL
100596: IFTRUE 100600
100598: GO 100611
100600: POP
// bc_type := b_siberite_mine ; end ;
100601: LD_ADDR_OWVAR 42
100605: PUSH
100606: LD_INT 30
100608: ST_TO_ADDR
100609: GO 100612
100611: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100612: LD_ADDR_VAR 0 8
100616: PUSH
100617: LD_VAR 0 5
100621: PPUSH
100622: LD_VAR 0 6
100626: PPUSH
100627: LD_VAR 0 3
100631: PPUSH
100632: CALL_OW 47
100636: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100637: LD_OWVAR 42
100641: PUSH
100642: LD_INT 32
100644: PUSH
100645: LD_INT 33
100647: PUSH
100648: EMPTY
100649: LIST
100650: LIST
100651: IN
100652: IFFALSE 100668
// PlaceWeaponTurret ( b , weapon ) ;
100654: LD_VAR 0 8
100658: PPUSH
100659: LD_VAR 0 4
100663: PPUSH
100664: CALL_OW 431
// end ;
100668: LD_VAR 0 7
100672: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100673: LD_INT 0
100675: PPUSH
100676: PPUSH
100677: PPUSH
100678: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100679: LD_ADDR_VAR 0 4
100683: PUSH
100684: LD_INT 22
100686: PUSH
100687: LD_OWVAR 2
100691: PUSH
100692: EMPTY
100693: LIST
100694: LIST
100695: PUSH
100696: LD_INT 2
100698: PUSH
100699: LD_INT 30
100701: PUSH
100702: LD_INT 0
100704: PUSH
100705: EMPTY
100706: LIST
100707: LIST
100708: PUSH
100709: LD_INT 30
100711: PUSH
100712: LD_INT 1
100714: PUSH
100715: EMPTY
100716: LIST
100717: LIST
100718: PUSH
100719: EMPTY
100720: LIST
100721: LIST
100722: LIST
100723: PUSH
100724: EMPTY
100725: LIST
100726: LIST
100727: PPUSH
100728: CALL_OW 69
100732: ST_TO_ADDR
// if not tmp then
100733: LD_VAR 0 4
100737: NOT
100738: IFFALSE 100742
// exit ;
100740: GO 100801
// for i in tmp do
100742: LD_ADDR_VAR 0 2
100746: PUSH
100747: LD_VAR 0 4
100751: PUSH
100752: FOR_IN
100753: IFFALSE 100799
// for j = 1 to 3 do
100755: LD_ADDR_VAR 0 3
100759: PUSH
100760: DOUBLE
100761: LD_INT 1
100763: DEC
100764: ST_TO_ADDR
100765: LD_INT 3
100767: PUSH
100768: FOR_TO
100769: IFFALSE 100795
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100771: LD_VAR 0 2
100775: PPUSH
100776: CALL_OW 274
100780: PPUSH
100781: LD_VAR 0 3
100785: PPUSH
100786: LD_INT 99999
100788: PPUSH
100789: CALL_OW 277
100793: GO 100768
100795: POP
100796: POP
100797: GO 100752
100799: POP
100800: POP
// end ;
100801: LD_VAR 0 1
100805: RET
// export function hHackSetLevel10 ; var i , j ; begin
100806: LD_INT 0
100808: PPUSH
100809: PPUSH
100810: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100811: LD_ADDR_VAR 0 2
100815: PUSH
100816: LD_INT 21
100818: PUSH
100819: LD_INT 1
100821: PUSH
100822: EMPTY
100823: LIST
100824: LIST
100825: PPUSH
100826: CALL_OW 69
100830: PUSH
100831: FOR_IN
100832: IFFALSE 100884
// if IsSelected ( i ) then
100834: LD_VAR 0 2
100838: PPUSH
100839: CALL_OW 306
100843: IFFALSE 100882
// begin for j := 1 to 4 do
100845: LD_ADDR_VAR 0 3
100849: PUSH
100850: DOUBLE
100851: LD_INT 1
100853: DEC
100854: ST_TO_ADDR
100855: LD_INT 4
100857: PUSH
100858: FOR_TO
100859: IFFALSE 100880
// SetSkill ( i , j , 10 ) ;
100861: LD_VAR 0 2
100865: PPUSH
100866: LD_VAR 0 3
100870: PPUSH
100871: LD_INT 10
100873: PPUSH
100874: CALL_OW 237
100878: GO 100858
100880: POP
100881: POP
// end ;
100882: GO 100831
100884: POP
100885: POP
// end ;
100886: LD_VAR 0 1
100890: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100891: LD_INT 0
100893: PPUSH
100894: PPUSH
100895: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
100896: LD_ADDR_VAR 0 2
100900: PUSH
100901: LD_INT 22
100903: PUSH
100904: LD_OWVAR 2
100908: PUSH
100909: EMPTY
100910: LIST
100911: LIST
100912: PUSH
100913: LD_INT 21
100915: PUSH
100916: LD_INT 1
100918: PUSH
100919: EMPTY
100920: LIST
100921: LIST
100922: PUSH
100923: EMPTY
100924: LIST
100925: LIST
100926: PPUSH
100927: CALL_OW 69
100931: PUSH
100932: FOR_IN
100933: IFFALSE 100974
// begin for j := 1 to 4 do
100935: LD_ADDR_VAR 0 3
100939: PUSH
100940: DOUBLE
100941: LD_INT 1
100943: DEC
100944: ST_TO_ADDR
100945: LD_INT 4
100947: PUSH
100948: FOR_TO
100949: IFFALSE 100970
// SetSkill ( i , j , 10 ) ;
100951: LD_VAR 0 2
100955: PPUSH
100956: LD_VAR 0 3
100960: PPUSH
100961: LD_INT 10
100963: PPUSH
100964: CALL_OW 237
100968: GO 100948
100970: POP
100971: POP
// end ;
100972: GO 100932
100974: POP
100975: POP
// end ;
100976: LD_VAR 0 1
100980: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
100981: LD_INT 0
100983: PPUSH
// uc_side := your_side ;
100984: LD_ADDR_OWVAR 20
100988: PUSH
100989: LD_OWVAR 2
100993: ST_TO_ADDR
// uc_nation := nation ;
100994: LD_ADDR_OWVAR 21
100998: PUSH
100999: LD_VAR 0 1
101003: ST_TO_ADDR
// InitHc ;
101004: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
101008: LD_INT 0
101010: PPUSH
101011: LD_VAR 0 2
101015: PPUSH
101016: LD_VAR 0 3
101020: PPUSH
101021: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
101025: LD_VAR 0 4
101029: PPUSH
101030: LD_VAR 0 5
101034: PPUSH
101035: CALL_OW 428
101039: PUSH
101040: LD_INT 0
101042: EQUAL
101043: IFFALSE 101067
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
101045: CALL_OW 44
101049: PPUSH
101050: LD_VAR 0 4
101054: PPUSH
101055: LD_VAR 0 5
101059: PPUSH
101060: LD_INT 1
101062: PPUSH
101063: CALL_OW 48
// end ;
101067: LD_VAR 0 6
101071: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
101072: LD_INT 0
101074: PPUSH
101075: PPUSH
// uc_side := your_side ;
101076: LD_ADDR_OWVAR 20
101080: PUSH
101081: LD_OWVAR 2
101085: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
101086: LD_VAR 0 1
101090: PUSH
101091: LD_INT 1
101093: PUSH
101094: LD_INT 2
101096: PUSH
101097: LD_INT 3
101099: PUSH
101100: LD_INT 4
101102: PUSH
101103: LD_INT 5
101105: PUSH
101106: EMPTY
101107: LIST
101108: LIST
101109: LIST
101110: LIST
101111: LIST
101112: IN
101113: IFFALSE 101125
// uc_nation := nation_american else
101115: LD_ADDR_OWVAR 21
101119: PUSH
101120: LD_INT 1
101122: ST_TO_ADDR
101123: GO 101168
// if chassis in [ 11 , 12 , 13 , 14 ] then
101125: LD_VAR 0 1
101129: PUSH
101130: LD_INT 11
101132: PUSH
101133: LD_INT 12
101135: PUSH
101136: LD_INT 13
101138: PUSH
101139: LD_INT 14
101141: PUSH
101142: EMPTY
101143: LIST
101144: LIST
101145: LIST
101146: LIST
101147: IN
101148: IFFALSE 101160
// uc_nation := nation_arabian else
101150: LD_ADDR_OWVAR 21
101154: PUSH
101155: LD_INT 2
101157: ST_TO_ADDR
101158: GO 101168
// uc_nation := nation_russian ;
101160: LD_ADDR_OWVAR 21
101164: PUSH
101165: LD_INT 3
101167: ST_TO_ADDR
// vc_chassis := chassis ;
101168: LD_ADDR_OWVAR 37
101172: PUSH
101173: LD_VAR 0 1
101177: ST_TO_ADDR
// vc_engine := engine ;
101178: LD_ADDR_OWVAR 39
101182: PUSH
101183: LD_VAR 0 2
101187: ST_TO_ADDR
// vc_control := control ;
101188: LD_ADDR_OWVAR 38
101192: PUSH
101193: LD_VAR 0 3
101197: ST_TO_ADDR
// vc_weapon := weapon ;
101198: LD_ADDR_OWVAR 40
101202: PUSH
101203: LD_VAR 0 4
101207: ST_TO_ADDR
// un := CreateVehicle ;
101208: LD_ADDR_VAR 0 8
101212: PUSH
101213: CALL_OW 45
101217: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
101218: LD_VAR 0 8
101222: PPUSH
101223: LD_INT 0
101225: PPUSH
101226: LD_INT 5
101228: PPUSH
101229: CALL_OW 12
101233: PPUSH
101234: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101238: LD_VAR 0 8
101242: PPUSH
101243: LD_VAR 0 5
101247: PPUSH
101248: LD_VAR 0 6
101252: PPUSH
101253: LD_INT 1
101255: PPUSH
101256: CALL_OW 48
// end ;
101260: LD_VAR 0 7
101264: RET
// export hInvincible ; every 1 do
101265: GO 101267
101267: DISABLE
// hInvincible := [ ] ;
101268: LD_ADDR_EXP 187
101272: PUSH
101273: EMPTY
101274: ST_TO_ADDR
101275: END
// every 10 do var i ;
101276: GO 101278
101278: DISABLE
101279: LD_INT 0
101281: PPUSH
// begin enable ;
101282: ENABLE
// if not hInvincible then
101283: LD_EXP 187
101287: NOT
101288: IFFALSE 101292
// exit ;
101290: GO 101336
// for i in hInvincible do
101292: LD_ADDR_VAR 0 1
101296: PUSH
101297: LD_EXP 187
101301: PUSH
101302: FOR_IN
101303: IFFALSE 101334
// if GetLives ( i ) < 1000 then
101305: LD_VAR 0 1
101309: PPUSH
101310: CALL_OW 256
101314: PUSH
101315: LD_INT 1000
101317: LESS
101318: IFFALSE 101332
// SetLives ( i , 1000 ) ;
101320: LD_VAR 0 1
101324: PPUSH
101325: LD_INT 1000
101327: PPUSH
101328: CALL_OW 234
101332: GO 101302
101334: POP
101335: POP
// end ;
101336: PPOPN 1
101338: END
// export function hHackInvincible ; var i ; begin
101339: LD_INT 0
101341: PPUSH
101342: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101343: LD_ADDR_VAR 0 2
101347: PUSH
101348: LD_INT 2
101350: PUSH
101351: LD_INT 21
101353: PUSH
101354: LD_INT 1
101356: PUSH
101357: EMPTY
101358: LIST
101359: LIST
101360: PUSH
101361: LD_INT 21
101363: PUSH
101364: LD_INT 2
101366: PUSH
101367: EMPTY
101368: LIST
101369: LIST
101370: PUSH
101371: EMPTY
101372: LIST
101373: LIST
101374: LIST
101375: PPUSH
101376: CALL_OW 69
101380: PUSH
101381: FOR_IN
101382: IFFALSE 101443
// if IsSelected ( i ) then
101384: LD_VAR 0 2
101388: PPUSH
101389: CALL_OW 306
101393: IFFALSE 101441
// begin if i in hInvincible then
101395: LD_VAR 0 2
101399: PUSH
101400: LD_EXP 187
101404: IN
101405: IFFALSE 101425
// hInvincible := hInvincible diff i else
101407: LD_ADDR_EXP 187
101411: PUSH
101412: LD_EXP 187
101416: PUSH
101417: LD_VAR 0 2
101421: DIFF
101422: ST_TO_ADDR
101423: GO 101441
// hInvincible := hInvincible union i ;
101425: LD_ADDR_EXP 187
101429: PUSH
101430: LD_EXP 187
101434: PUSH
101435: LD_VAR 0 2
101439: UNION
101440: ST_TO_ADDR
// end ;
101441: GO 101381
101443: POP
101444: POP
// end ;
101445: LD_VAR 0 1
101449: RET
// export function hHackInvisible ; var i , j ; begin
101450: LD_INT 0
101452: PPUSH
101453: PPUSH
101454: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101455: LD_ADDR_VAR 0 2
101459: PUSH
101460: LD_INT 21
101462: PUSH
101463: LD_INT 1
101465: PUSH
101466: EMPTY
101467: LIST
101468: LIST
101469: PPUSH
101470: CALL_OW 69
101474: PUSH
101475: FOR_IN
101476: IFFALSE 101500
// if IsSelected ( i ) then
101478: LD_VAR 0 2
101482: PPUSH
101483: CALL_OW 306
101487: IFFALSE 101498
// ComForceInvisible ( i ) ;
101489: LD_VAR 0 2
101493: PPUSH
101494: CALL_OW 496
101498: GO 101475
101500: POP
101501: POP
// end ;
101502: LD_VAR 0 1
101506: RET
// export function hHackChangeYourSide ; begin
101507: LD_INT 0
101509: PPUSH
// if your_side = 8 then
101510: LD_OWVAR 2
101514: PUSH
101515: LD_INT 8
101517: EQUAL
101518: IFFALSE 101530
// your_side := 0 else
101520: LD_ADDR_OWVAR 2
101524: PUSH
101525: LD_INT 0
101527: ST_TO_ADDR
101528: GO 101544
// your_side := your_side + 1 ;
101530: LD_ADDR_OWVAR 2
101534: PUSH
101535: LD_OWVAR 2
101539: PUSH
101540: LD_INT 1
101542: PLUS
101543: ST_TO_ADDR
// end ;
101544: LD_VAR 0 1
101548: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101549: LD_INT 0
101551: PPUSH
101552: PPUSH
101553: PPUSH
// for i in all_units do
101554: LD_ADDR_VAR 0 2
101558: PUSH
101559: LD_OWVAR 3
101563: PUSH
101564: FOR_IN
101565: IFFALSE 101643
// if IsSelected ( i ) then
101567: LD_VAR 0 2
101571: PPUSH
101572: CALL_OW 306
101576: IFFALSE 101641
// begin j := GetSide ( i ) ;
101578: LD_ADDR_VAR 0 3
101582: PUSH
101583: LD_VAR 0 2
101587: PPUSH
101588: CALL_OW 255
101592: ST_TO_ADDR
// if j = 8 then
101593: LD_VAR 0 3
101597: PUSH
101598: LD_INT 8
101600: EQUAL
101601: IFFALSE 101613
// j := 0 else
101603: LD_ADDR_VAR 0 3
101607: PUSH
101608: LD_INT 0
101610: ST_TO_ADDR
101611: GO 101627
// j := j + 1 ;
101613: LD_ADDR_VAR 0 3
101617: PUSH
101618: LD_VAR 0 3
101622: PUSH
101623: LD_INT 1
101625: PLUS
101626: ST_TO_ADDR
// SetSide ( i , j ) ;
101627: LD_VAR 0 2
101631: PPUSH
101632: LD_VAR 0 3
101636: PPUSH
101637: CALL_OW 235
// end ;
101641: GO 101564
101643: POP
101644: POP
// end ;
101645: LD_VAR 0 1
101649: RET
// export function hHackFog ; begin
101650: LD_INT 0
101652: PPUSH
// FogOff ( true ) ;
101653: LD_INT 1
101655: PPUSH
101656: CALL_OW 344
// end ;
101660: LD_VAR 0 1
101664: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101665: LD_INT 0
101667: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101668: LD_VAR 0 1
101672: PPUSH
101673: LD_VAR 0 2
101677: PPUSH
101678: LD_VAR 0 3
101682: PPUSH
101683: LD_INT 1
101685: PPUSH
101686: LD_INT 1
101688: PPUSH
101689: CALL_OW 483
// CenterOnXY ( x , y ) ;
101693: LD_VAR 0 2
101697: PPUSH
101698: LD_VAR 0 3
101702: PPUSH
101703: CALL_OW 84
// end ; end_of_file
101707: LD_VAR 0 4
101711: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
101712: LD_INT 0
101714: PPUSH
101715: PPUSH
101716: PPUSH
101717: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
101718: LD_VAR 0 1
101722: PPUSH
101723: CALL_OW 264
101727: PUSH
101728: LD_EXP 76
101732: EQUAL
101733: IFFALSE 101805
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
101735: LD_INT 68
101737: PPUSH
101738: LD_VAR 0 1
101742: PPUSH
101743: CALL_OW 255
101747: PPUSH
101748: CALL_OW 321
101752: PUSH
101753: LD_INT 2
101755: EQUAL
101756: IFFALSE 101768
// eff := 70 else
101758: LD_ADDR_VAR 0 4
101762: PUSH
101763: LD_INT 70
101765: ST_TO_ADDR
101766: GO 101776
// eff := 30 ;
101768: LD_ADDR_VAR 0 4
101772: PUSH
101773: LD_INT 30
101775: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
101776: LD_VAR 0 1
101780: PPUSH
101781: CALL_OW 250
101785: PPUSH
101786: LD_VAR 0 1
101790: PPUSH
101791: CALL_OW 251
101795: PPUSH
101796: LD_VAR 0 4
101800: PPUSH
101801: CALL_OW 495
// end ; end ;
101805: LD_VAR 0 2
101809: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
101810: LD_INT 0
101812: PPUSH
// end ;
101813: LD_VAR 0 4
101817: RET
// export function SOS_Command ( cmd ) ; begin
101818: LD_INT 0
101820: PPUSH
// end ;
101821: LD_VAR 0 2
101825: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
101826: LD_INT 0
101828: PPUSH
// if cmd = 121 then
101829: LD_VAR 0 1
101833: PUSH
101834: LD_INT 121
101836: EQUAL
101837: IFFALSE 101839
// end ;
101839: LD_VAR 0 6
101843: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
101844: LD_INT 0
101846: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
101847: LD_VAR 0 1
101851: PUSH
101852: LD_INT 250
101854: EQUAL
101855: PUSH
101856: LD_VAR 0 2
101860: PPUSH
101861: CALL_OW 264
101865: PUSH
101866: LD_EXP 79
101870: EQUAL
101871: AND
101872: IFFALSE 101893
// MinerPlaceMine ( unit , x , y ) ;
101874: LD_VAR 0 2
101878: PPUSH
101879: LD_VAR 0 4
101883: PPUSH
101884: LD_VAR 0 5
101888: PPUSH
101889: CALL 104242 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
101893: LD_VAR 0 1
101897: PUSH
101898: LD_INT 251
101900: EQUAL
101901: PUSH
101902: LD_VAR 0 2
101906: PPUSH
101907: CALL_OW 264
101911: PUSH
101912: LD_EXP 79
101916: EQUAL
101917: AND
101918: IFFALSE 101939
// MinerDetonateMine ( unit , x , y ) ;
101920: LD_VAR 0 2
101924: PPUSH
101925: LD_VAR 0 4
101929: PPUSH
101930: LD_VAR 0 5
101934: PPUSH
101935: CALL 104519 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
101939: LD_VAR 0 1
101943: PUSH
101944: LD_INT 252
101946: EQUAL
101947: PUSH
101948: LD_VAR 0 2
101952: PPUSH
101953: CALL_OW 264
101957: PUSH
101958: LD_EXP 79
101962: EQUAL
101963: AND
101964: IFFALSE 101985
// MinerCreateMinefield ( unit , x , y ) ;
101966: LD_VAR 0 2
101970: PPUSH
101971: LD_VAR 0 4
101975: PPUSH
101976: LD_VAR 0 5
101980: PPUSH
101981: CALL 104936 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
101985: LD_VAR 0 1
101989: PUSH
101990: LD_INT 253
101992: EQUAL
101993: PUSH
101994: LD_VAR 0 2
101998: PPUSH
101999: CALL_OW 257
102003: PUSH
102004: LD_INT 5
102006: EQUAL
102007: AND
102008: IFFALSE 102029
// ComBinocular ( unit , x , y ) ;
102010: LD_VAR 0 2
102014: PPUSH
102015: LD_VAR 0 4
102019: PPUSH
102020: LD_VAR 0 5
102024: PPUSH
102025: CALL 105307 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
102029: LD_VAR 0 1
102033: PUSH
102034: LD_INT 254
102036: EQUAL
102037: PUSH
102038: LD_VAR 0 2
102042: PPUSH
102043: CALL_OW 264
102047: PUSH
102048: LD_EXP 74
102052: EQUAL
102053: AND
102054: PUSH
102055: LD_VAR 0 3
102059: PPUSH
102060: CALL_OW 263
102064: PUSH
102065: LD_INT 3
102067: EQUAL
102068: AND
102069: IFFALSE 102085
// HackDestroyVehicle ( unit , selectedUnit ) ;
102071: LD_VAR 0 2
102075: PPUSH
102076: LD_VAR 0 3
102080: PPUSH
102081: CALL 103602 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
102085: LD_VAR 0 1
102089: PUSH
102090: LD_INT 255
102092: EQUAL
102093: PUSH
102094: LD_VAR 0 2
102098: PPUSH
102099: CALL_OW 264
102103: PUSH
102104: LD_INT 14
102106: PUSH
102107: LD_INT 53
102109: PUSH
102110: EMPTY
102111: LIST
102112: LIST
102113: IN
102114: AND
102115: PUSH
102116: LD_VAR 0 4
102120: PPUSH
102121: LD_VAR 0 5
102125: PPUSH
102126: CALL_OW 488
102130: AND
102131: IFFALSE 102155
// CutTreeXYR ( unit , x , y , 12 ) ;
102133: LD_VAR 0 2
102137: PPUSH
102138: LD_VAR 0 4
102142: PPUSH
102143: LD_VAR 0 5
102147: PPUSH
102148: LD_INT 12
102150: PPUSH
102151: CALL 102168 0 4
// end ;
102155: LD_VAR 0 6
102159: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
102160: LD_INT 0
102162: PPUSH
// end ;
102163: LD_VAR 0 4
102167: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
102168: LD_INT 0
102170: PPUSH
102171: PPUSH
102172: PPUSH
102173: PPUSH
102174: PPUSH
102175: PPUSH
102176: PPUSH
102177: PPUSH
102178: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
102179: LD_VAR 0 1
102183: NOT
102184: PUSH
102185: LD_VAR 0 2
102189: PPUSH
102190: LD_VAR 0 3
102194: PPUSH
102195: CALL_OW 488
102199: NOT
102200: OR
102201: PUSH
102202: LD_VAR 0 4
102206: NOT
102207: OR
102208: IFFALSE 102212
// exit ;
102210: GO 102552
// list := [ ] ;
102212: LD_ADDR_VAR 0 13
102216: PUSH
102217: EMPTY
102218: ST_TO_ADDR
// if x - r < 0 then
102219: LD_VAR 0 2
102223: PUSH
102224: LD_VAR 0 4
102228: MINUS
102229: PUSH
102230: LD_INT 0
102232: LESS
102233: IFFALSE 102245
// min_x := 0 else
102235: LD_ADDR_VAR 0 7
102239: PUSH
102240: LD_INT 0
102242: ST_TO_ADDR
102243: GO 102261
// min_x := x - r ;
102245: LD_ADDR_VAR 0 7
102249: PUSH
102250: LD_VAR 0 2
102254: PUSH
102255: LD_VAR 0 4
102259: MINUS
102260: ST_TO_ADDR
// if y - r < 0 then
102261: LD_VAR 0 3
102265: PUSH
102266: LD_VAR 0 4
102270: MINUS
102271: PUSH
102272: LD_INT 0
102274: LESS
102275: IFFALSE 102287
// min_y := 0 else
102277: LD_ADDR_VAR 0 8
102281: PUSH
102282: LD_INT 0
102284: ST_TO_ADDR
102285: GO 102303
// min_y := y - r ;
102287: LD_ADDR_VAR 0 8
102291: PUSH
102292: LD_VAR 0 3
102296: PUSH
102297: LD_VAR 0 4
102301: MINUS
102302: ST_TO_ADDR
// max_x := x + r ;
102303: LD_ADDR_VAR 0 9
102307: PUSH
102308: LD_VAR 0 2
102312: PUSH
102313: LD_VAR 0 4
102317: PLUS
102318: ST_TO_ADDR
// max_y := y + r ;
102319: LD_ADDR_VAR 0 10
102323: PUSH
102324: LD_VAR 0 3
102328: PUSH
102329: LD_VAR 0 4
102333: PLUS
102334: ST_TO_ADDR
// for _x = min_x to max_x do
102335: LD_ADDR_VAR 0 11
102339: PUSH
102340: DOUBLE
102341: LD_VAR 0 7
102345: DEC
102346: ST_TO_ADDR
102347: LD_VAR 0 9
102351: PUSH
102352: FOR_TO
102353: IFFALSE 102470
// for _y = min_y to max_y do
102355: LD_ADDR_VAR 0 12
102359: PUSH
102360: DOUBLE
102361: LD_VAR 0 8
102365: DEC
102366: ST_TO_ADDR
102367: LD_VAR 0 10
102371: PUSH
102372: FOR_TO
102373: IFFALSE 102466
// begin if not ValidHex ( _x , _y ) then
102375: LD_VAR 0 11
102379: PPUSH
102380: LD_VAR 0 12
102384: PPUSH
102385: CALL_OW 488
102389: NOT
102390: IFFALSE 102394
// continue ;
102392: GO 102372
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
102394: LD_VAR 0 11
102398: PPUSH
102399: LD_VAR 0 12
102403: PPUSH
102404: CALL_OW 351
102408: PUSH
102409: LD_VAR 0 11
102413: PPUSH
102414: LD_VAR 0 12
102418: PPUSH
102419: CALL_OW 554
102423: AND
102424: IFFALSE 102464
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
102426: LD_ADDR_VAR 0 13
102430: PUSH
102431: LD_VAR 0 13
102435: PPUSH
102436: LD_VAR 0 13
102440: PUSH
102441: LD_INT 1
102443: PLUS
102444: PPUSH
102445: LD_VAR 0 11
102449: PUSH
102450: LD_VAR 0 12
102454: PUSH
102455: EMPTY
102456: LIST
102457: LIST
102458: PPUSH
102459: CALL_OW 2
102463: ST_TO_ADDR
// end ;
102464: GO 102372
102466: POP
102467: POP
102468: GO 102352
102470: POP
102471: POP
// if not list then
102472: LD_VAR 0 13
102476: NOT
102477: IFFALSE 102481
// exit ;
102479: GO 102552
// for i in list do
102481: LD_ADDR_VAR 0 6
102485: PUSH
102486: LD_VAR 0 13
102490: PUSH
102491: FOR_IN
102492: IFFALSE 102550
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
102494: LD_VAR 0 1
102498: PPUSH
102499: LD_STRING M
102501: PUSH
102502: LD_VAR 0 6
102506: PUSH
102507: LD_INT 1
102509: ARRAY
102510: PUSH
102511: LD_VAR 0 6
102515: PUSH
102516: LD_INT 2
102518: ARRAY
102519: PUSH
102520: LD_INT 0
102522: PUSH
102523: LD_INT 0
102525: PUSH
102526: LD_INT 0
102528: PUSH
102529: LD_INT 0
102531: PUSH
102532: EMPTY
102533: LIST
102534: LIST
102535: LIST
102536: LIST
102537: LIST
102538: LIST
102539: LIST
102540: PUSH
102541: EMPTY
102542: LIST
102543: PPUSH
102544: CALL_OW 447
102548: GO 102491
102550: POP
102551: POP
// end ;
102552: LD_VAR 0 5
102556: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
102557: LD_EXP 190
102561: NOT
102562: IFFALSE 102612
102564: GO 102566
102566: DISABLE
// begin initHack := true ;
102567: LD_ADDR_EXP 190
102571: PUSH
102572: LD_INT 1
102574: ST_TO_ADDR
// hackTanks := [ ] ;
102575: LD_ADDR_EXP 191
102579: PUSH
102580: EMPTY
102581: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
102582: LD_ADDR_EXP 192
102586: PUSH
102587: EMPTY
102588: ST_TO_ADDR
// hackLimit := 3 ;
102589: LD_ADDR_EXP 193
102593: PUSH
102594: LD_INT 3
102596: ST_TO_ADDR
// hackDist := 12 ;
102597: LD_ADDR_EXP 194
102601: PUSH
102602: LD_INT 12
102604: ST_TO_ADDR
// hackCounter := [ ] ;
102605: LD_ADDR_EXP 195
102609: PUSH
102610: EMPTY
102611: ST_TO_ADDR
// end ;
102612: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
102613: LD_EXP 190
102617: PUSH
102618: LD_INT 34
102620: PUSH
102621: LD_EXP 74
102625: PUSH
102626: EMPTY
102627: LIST
102628: LIST
102629: PPUSH
102630: CALL_OW 69
102634: AND
102635: IFFALSE 102890
102637: GO 102639
102639: DISABLE
102640: LD_INT 0
102642: PPUSH
102643: PPUSH
// begin enable ;
102644: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
102645: LD_ADDR_VAR 0 1
102649: PUSH
102650: LD_INT 34
102652: PUSH
102653: LD_EXP 74
102657: PUSH
102658: EMPTY
102659: LIST
102660: LIST
102661: PPUSH
102662: CALL_OW 69
102666: PUSH
102667: FOR_IN
102668: IFFALSE 102888
// begin if not i in hackTanks then
102670: LD_VAR 0 1
102674: PUSH
102675: LD_EXP 191
102679: IN
102680: NOT
102681: IFFALSE 102764
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
102683: LD_ADDR_EXP 191
102687: PUSH
102688: LD_EXP 191
102692: PPUSH
102693: LD_EXP 191
102697: PUSH
102698: LD_INT 1
102700: PLUS
102701: PPUSH
102702: LD_VAR 0 1
102706: PPUSH
102707: CALL_OW 1
102711: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
102712: LD_ADDR_EXP 192
102716: PUSH
102717: LD_EXP 192
102721: PPUSH
102722: LD_EXP 192
102726: PUSH
102727: LD_INT 1
102729: PLUS
102730: PPUSH
102731: EMPTY
102732: PPUSH
102733: CALL_OW 1
102737: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
102738: LD_ADDR_EXP 195
102742: PUSH
102743: LD_EXP 195
102747: PPUSH
102748: LD_EXP 195
102752: PUSH
102753: LD_INT 1
102755: PLUS
102756: PPUSH
102757: EMPTY
102758: PPUSH
102759: CALL_OW 1
102763: ST_TO_ADDR
// end ; if not IsOk ( i ) then
102764: LD_VAR 0 1
102768: PPUSH
102769: CALL_OW 302
102773: NOT
102774: IFFALSE 102787
// begin HackUnlinkAll ( i ) ;
102776: LD_VAR 0 1
102780: PPUSH
102781: CALL 102893 0 1
// continue ;
102785: GO 102667
// end ; HackCheckCapturedStatus ( i ) ;
102787: LD_VAR 0 1
102791: PPUSH
102792: CALL 103336 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
102796: LD_ADDR_VAR 0 2
102800: PUSH
102801: LD_INT 81
102803: PUSH
102804: LD_VAR 0 1
102808: PPUSH
102809: CALL_OW 255
102813: PUSH
102814: EMPTY
102815: LIST
102816: LIST
102817: PUSH
102818: LD_INT 33
102820: PUSH
102821: LD_INT 3
102823: PUSH
102824: EMPTY
102825: LIST
102826: LIST
102827: PUSH
102828: LD_INT 91
102830: PUSH
102831: LD_VAR 0 1
102835: PUSH
102836: LD_EXP 194
102840: PUSH
102841: EMPTY
102842: LIST
102843: LIST
102844: LIST
102845: PUSH
102846: LD_INT 50
102848: PUSH
102849: EMPTY
102850: LIST
102851: PUSH
102852: EMPTY
102853: LIST
102854: LIST
102855: LIST
102856: LIST
102857: PPUSH
102858: CALL_OW 69
102862: ST_TO_ADDR
// if not tmp then
102863: LD_VAR 0 2
102867: NOT
102868: IFFALSE 102872
// continue ;
102870: GO 102667
// HackLink ( i , tmp ) ;
102872: LD_VAR 0 1
102876: PPUSH
102877: LD_VAR 0 2
102881: PPUSH
102882: CALL 103029 0 2
// end ;
102886: GO 102667
102888: POP
102889: POP
// end ;
102890: PPOPN 2
102892: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
102893: LD_INT 0
102895: PPUSH
102896: PPUSH
102897: PPUSH
// if not hack in hackTanks then
102898: LD_VAR 0 1
102902: PUSH
102903: LD_EXP 191
102907: IN
102908: NOT
102909: IFFALSE 102913
// exit ;
102911: GO 103024
// index := GetElementIndex ( hackTanks , hack ) ;
102913: LD_ADDR_VAR 0 4
102917: PUSH
102918: LD_EXP 191
102922: PPUSH
102923: LD_VAR 0 1
102927: PPUSH
102928: CALL 55620 0 2
102932: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
102933: LD_EXP 192
102937: PUSH
102938: LD_VAR 0 4
102942: ARRAY
102943: IFFALSE 103024
// begin for i in hackTanksCaptured [ index ] do
102945: LD_ADDR_VAR 0 3
102949: PUSH
102950: LD_EXP 192
102954: PUSH
102955: LD_VAR 0 4
102959: ARRAY
102960: PUSH
102961: FOR_IN
102962: IFFALSE 102988
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
102964: LD_VAR 0 3
102968: PUSH
102969: LD_INT 1
102971: ARRAY
102972: PPUSH
102973: LD_VAR 0 3
102977: PUSH
102978: LD_INT 2
102980: ARRAY
102981: PPUSH
102982: CALL_OW 235
102986: GO 102961
102988: POP
102989: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
102990: LD_ADDR_EXP 192
102994: PUSH
102995: LD_EXP 192
102999: PPUSH
103000: LD_VAR 0 4
103004: PPUSH
103005: EMPTY
103006: PPUSH
103007: CALL_OW 1
103011: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
103012: LD_VAR 0 1
103016: PPUSH
103017: LD_INT 0
103019: PPUSH
103020: CALL_OW 505
// end ; end ;
103024: LD_VAR 0 2
103028: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
103029: LD_INT 0
103031: PPUSH
103032: PPUSH
103033: PPUSH
// if not hack in hackTanks or not vehicles then
103034: LD_VAR 0 1
103038: PUSH
103039: LD_EXP 191
103043: IN
103044: NOT
103045: PUSH
103046: LD_VAR 0 2
103050: NOT
103051: OR
103052: IFFALSE 103056
// exit ;
103054: GO 103331
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
103056: LD_ADDR_VAR 0 2
103060: PUSH
103061: LD_VAR 0 1
103065: PPUSH
103066: LD_VAR 0 2
103070: PPUSH
103071: LD_INT 1
103073: PPUSH
103074: LD_INT 1
103076: PPUSH
103077: CALL 56270 0 4
103081: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
103082: LD_ADDR_VAR 0 5
103086: PUSH
103087: LD_EXP 191
103091: PPUSH
103092: LD_VAR 0 1
103096: PPUSH
103097: CALL 55620 0 2
103101: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
103102: LD_EXP 192
103106: PUSH
103107: LD_VAR 0 5
103111: ARRAY
103112: PUSH
103113: LD_EXP 193
103117: LESS
103118: IFFALSE 103307
// begin for i := 1 to vehicles do
103120: LD_ADDR_VAR 0 4
103124: PUSH
103125: DOUBLE
103126: LD_INT 1
103128: DEC
103129: ST_TO_ADDR
103130: LD_VAR 0 2
103134: PUSH
103135: FOR_TO
103136: IFFALSE 103305
// begin if hackTanksCaptured [ index ] = hackLimit then
103138: LD_EXP 192
103142: PUSH
103143: LD_VAR 0 5
103147: ARRAY
103148: PUSH
103149: LD_EXP 193
103153: EQUAL
103154: IFFALSE 103158
// break ;
103156: GO 103305
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
103158: LD_ADDR_EXP 195
103162: PUSH
103163: LD_EXP 195
103167: PPUSH
103168: LD_VAR 0 5
103172: PPUSH
103173: LD_EXP 195
103177: PUSH
103178: LD_VAR 0 5
103182: ARRAY
103183: PUSH
103184: LD_INT 1
103186: PLUS
103187: PPUSH
103188: CALL_OW 1
103192: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
103193: LD_ADDR_EXP 192
103197: PUSH
103198: LD_EXP 192
103202: PPUSH
103203: LD_VAR 0 5
103207: PUSH
103208: LD_EXP 192
103212: PUSH
103213: LD_VAR 0 5
103217: ARRAY
103218: PUSH
103219: LD_INT 1
103221: PLUS
103222: PUSH
103223: EMPTY
103224: LIST
103225: LIST
103226: PPUSH
103227: LD_VAR 0 2
103231: PUSH
103232: LD_VAR 0 4
103236: ARRAY
103237: PUSH
103238: LD_VAR 0 2
103242: PUSH
103243: LD_VAR 0 4
103247: ARRAY
103248: PPUSH
103249: CALL_OW 255
103253: PUSH
103254: EMPTY
103255: LIST
103256: LIST
103257: PPUSH
103258: CALL 55835 0 3
103262: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
103263: LD_VAR 0 2
103267: PUSH
103268: LD_VAR 0 4
103272: ARRAY
103273: PPUSH
103274: LD_VAR 0 1
103278: PPUSH
103279: CALL_OW 255
103283: PPUSH
103284: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
103288: LD_VAR 0 2
103292: PUSH
103293: LD_VAR 0 4
103297: ARRAY
103298: PPUSH
103299: CALL_OW 141
// end ;
103303: GO 103135
103305: POP
103306: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103307: LD_VAR 0 1
103311: PPUSH
103312: LD_EXP 192
103316: PUSH
103317: LD_VAR 0 5
103321: ARRAY
103322: PUSH
103323: LD_INT 0
103325: PLUS
103326: PPUSH
103327: CALL_OW 505
// end ;
103331: LD_VAR 0 3
103335: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
103336: LD_INT 0
103338: PPUSH
103339: PPUSH
103340: PPUSH
103341: PPUSH
// if not hack in hackTanks then
103342: LD_VAR 0 1
103346: PUSH
103347: LD_EXP 191
103351: IN
103352: NOT
103353: IFFALSE 103357
// exit ;
103355: GO 103597
// index := GetElementIndex ( hackTanks , hack ) ;
103357: LD_ADDR_VAR 0 4
103361: PUSH
103362: LD_EXP 191
103366: PPUSH
103367: LD_VAR 0 1
103371: PPUSH
103372: CALL 55620 0 2
103376: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
103377: LD_ADDR_VAR 0 3
103381: PUSH
103382: DOUBLE
103383: LD_EXP 192
103387: PUSH
103388: LD_VAR 0 4
103392: ARRAY
103393: INC
103394: ST_TO_ADDR
103395: LD_INT 1
103397: PUSH
103398: FOR_DOWNTO
103399: IFFALSE 103571
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
103401: LD_ADDR_VAR 0 5
103405: PUSH
103406: LD_EXP 192
103410: PUSH
103411: LD_VAR 0 4
103415: ARRAY
103416: PUSH
103417: LD_VAR 0 3
103421: ARRAY
103422: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
103423: LD_VAR 0 5
103427: PUSH
103428: LD_INT 1
103430: ARRAY
103431: PPUSH
103432: CALL_OW 302
103436: NOT
103437: PUSH
103438: LD_VAR 0 5
103442: PUSH
103443: LD_INT 1
103445: ARRAY
103446: PPUSH
103447: CALL_OW 255
103451: PUSH
103452: LD_VAR 0 1
103456: PPUSH
103457: CALL_OW 255
103461: NONEQUAL
103462: OR
103463: IFFALSE 103569
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
103465: LD_VAR 0 5
103469: PUSH
103470: LD_INT 1
103472: ARRAY
103473: PPUSH
103474: CALL_OW 305
103478: PUSH
103479: LD_VAR 0 5
103483: PUSH
103484: LD_INT 1
103486: ARRAY
103487: PPUSH
103488: CALL_OW 255
103492: PUSH
103493: LD_VAR 0 1
103497: PPUSH
103498: CALL_OW 255
103502: EQUAL
103503: AND
103504: IFFALSE 103528
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
103506: LD_VAR 0 5
103510: PUSH
103511: LD_INT 1
103513: ARRAY
103514: PPUSH
103515: LD_VAR 0 5
103519: PUSH
103520: LD_INT 2
103522: ARRAY
103523: PPUSH
103524: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
103528: LD_ADDR_EXP 192
103532: PUSH
103533: LD_EXP 192
103537: PPUSH
103538: LD_VAR 0 4
103542: PPUSH
103543: LD_EXP 192
103547: PUSH
103548: LD_VAR 0 4
103552: ARRAY
103553: PPUSH
103554: LD_VAR 0 3
103558: PPUSH
103559: CALL_OW 3
103563: PPUSH
103564: CALL_OW 1
103568: ST_TO_ADDR
// end ; end ;
103569: GO 103398
103571: POP
103572: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103573: LD_VAR 0 1
103577: PPUSH
103578: LD_EXP 192
103582: PUSH
103583: LD_VAR 0 4
103587: ARRAY
103588: PUSH
103589: LD_INT 0
103591: PLUS
103592: PPUSH
103593: CALL_OW 505
// end ;
103597: LD_VAR 0 2
103601: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
103602: LD_INT 0
103604: PPUSH
103605: PPUSH
103606: PPUSH
103607: PPUSH
// if not hack in hackTanks then
103608: LD_VAR 0 1
103612: PUSH
103613: LD_EXP 191
103617: IN
103618: NOT
103619: IFFALSE 103623
// exit ;
103621: GO 103708
// index := GetElementIndex ( hackTanks , hack ) ;
103623: LD_ADDR_VAR 0 5
103627: PUSH
103628: LD_EXP 191
103632: PPUSH
103633: LD_VAR 0 1
103637: PPUSH
103638: CALL 55620 0 2
103642: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
103643: LD_ADDR_VAR 0 4
103647: PUSH
103648: DOUBLE
103649: LD_INT 1
103651: DEC
103652: ST_TO_ADDR
103653: LD_EXP 192
103657: PUSH
103658: LD_VAR 0 5
103662: ARRAY
103663: PUSH
103664: FOR_TO
103665: IFFALSE 103706
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
103667: LD_EXP 192
103671: PUSH
103672: LD_VAR 0 5
103676: ARRAY
103677: PUSH
103678: LD_VAR 0 4
103682: ARRAY
103683: PUSH
103684: LD_INT 1
103686: ARRAY
103687: PUSH
103688: LD_VAR 0 2
103692: EQUAL
103693: IFFALSE 103704
// KillUnit ( vehicle ) ;
103695: LD_VAR 0 2
103699: PPUSH
103700: CALL_OW 66
103704: GO 103664
103706: POP
103707: POP
// end ;
103708: LD_VAR 0 3
103712: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
103713: LD_EXP 196
103717: NOT
103718: IFFALSE 103753
103720: GO 103722
103722: DISABLE
// begin initMiner := true ;
103723: LD_ADDR_EXP 196
103727: PUSH
103728: LD_INT 1
103730: ST_TO_ADDR
// minersList := [ ] ;
103731: LD_ADDR_EXP 197
103735: PUSH
103736: EMPTY
103737: ST_TO_ADDR
// minerMinesList := [ ] ;
103738: LD_ADDR_EXP 198
103742: PUSH
103743: EMPTY
103744: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
103745: LD_ADDR_EXP 199
103749: PUSH
103750: LD_INT 5
103752: ST_TO_ADDR
// end ;
103753: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
103754: LD_EXP 196
103758: PUSH
103759: LD_INT 34
103761: PUSH
103762: LD_EXP 79
103766: PUSH
103767: EMPTY
103768: LIST
103769: LIST
103770: PPUSH
103771: CALL_OW 69
103775: AND
103776: IFFALSE 104239
103778: GO 103780
103780: DISABLE
103781: LD_INT 0
103783: PPUSH
103784: PPUSH
103785: PPUSH
103786: PPUSH
// begin enable ;
103787: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
103788: LD_ADDR_VAR 0 1
103792: PUSH
103793: LD_INT 34
103795: PUSH
103796: LD_EXP 79
103800: PUSH
103801: EMPTY
103802: LIST
103803: LIST
103804: PPUSH
103805: CALL_OW 69
103809: PUSH
103810: FOR_IN
103811: IFFALSE 103883
// begin if not i in minersList then
103813: LD_VAR 0 1
103817: PUSH
103818: LD_EXP 197
103822: IN
103823: NOT
103824: IFFALSE 103881
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
103826: LD_ADDR_EXP 197
103830: PUSH
103831: LD_EXP 197
103835: PPUSH
103836: LD_EXP 197
103840: PUSH
103841: LD_INT 1
103843: PLUS
103844: PPUSH
103845: LD_VAR 0 1
103849: PPUSH
103850: CALL_OW 1
103854: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
103855: LD_ADDR_EXP 198
103859: PUSH
103860: LD_EXP 198
103864: PPUSH
103865: LD_EXP 198
103869: PUSH
103870: LD_INT 1
103872: PLUS
103873: PPUSH
103874: EMPTY
103875: PPUSH
103876: CALL_OW 1
103880: ST_TO_ADDR
// end end ;
103881: GO 103810
103883: POP
103884: POP
// for i := minerMinesList downto 1 do
103885: LD_ADDR_VAR 0 1
103889: PUSH
103890: DOUBLE
103891: LD_EXP 198
103895: INC
103896: ST_TO_ADDR
103897: LD_INT 1
103899: PUSH
103900: FOR_DOWNTO
103901: IFFALSE 104237
// begin if IsLive ( minersList [ i ] ) then
103903: LD_EXP 197
103907: PUSH
103908: LD_VAR 0 1
103912: ARRAY
103913: PPUSH
103914: CALL_OW 300
103918: IFFALSE 103946
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
103920: LD_EXP 197
103924: PUSH
103925: LD_VAR 0 1
103929: ARRAY
103930: PPUSH
103931: LD_EXP 198
103935: PUSH
103936: LD_VAR 0 1
103940: ARRAY
103941: PPUSH
103942: CALL_OW 505
// if not minerMinesList [ i ] then
103946: LD_EXP 198
103950: PUSH
103951: LD_VAR 0 1
103955: ARRAY
103956: NOT
103957: IFFALSE 103961
// continue ;
103959: GO 103900
// for j := minerMinesList [ i ] downto 1 do
103961: LD_ADDR_VAR 0 2
103965: PUSH
103966: DOUBLE
103967: LD_EXP 198
103971: PUSH
103972: LD_VAR 0 1
103976: ARRAY
103977: INC
103978: ST_TO_ADDR
103979: LD_INT 1
103981: PUSH
103982: FOR_DOWNTO
103983: IFFALSE 104233
// begin side := GetSide ( minersList [ i ] ) ;
103985: LD_ADDR_VAR 0 3
103989: PUSH
103990: LD_EXP 197
103994: PUSH
103995: LD_VAR 0 1
103999: ARRAY
104000: PPUSH
104001: CALL_OW 255
104005: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
104006: LD_ADDR_VAR 0 4
104010: PUSH
104011: LD_EXP 198
104015: PUSH
104016: LD_VAR 0 1
104020: ARRAY
104021: PUSH
104022: LD_VAR 0 2
104026: ARRAY
104027: PUSH
104028: LD_INT 1
104030: ARRAY
104031: PPUSH
104032: LD_EXP 198
104036: PUSH
104037: LD_VAR 0 1
104041: ARRAY
104042: PUSH
104043: LD_VAR 0 2
104047: ARRAY
104048: PUSH
104049: LD_INT 2
104051: ARRAY
104052: PPUSH
104053: CALL_OW 428
104057: ST_TO_ADDR
// if not tmp then
104058: LD_VAR 0 4
104062: NOT
104063: IFFALSE 104067
// continue ;
104065: GO 103982
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
104067: LD_VAR 0 4
104071: PUSH
104072: LD_INT 81
104074: PUSH
104075: LD_VAR 0 3
104079: PUSH
104080: EMPTY
104081: LIST
104082: LIST
104083: PPUSH
104084: CALL_OW 69
104088: IN
104089: PUSH
104090: LD_EXP 198
104094: PUSH
104095: LD_VAR 0 1
104099: ARRAY
104100: PUSH
104101: LD_VAR 0 2
104105: ARRAY
104106: PUSH
104107: LD_INT 1
104109: ARRAY
104110: PPUSH
104111: LD_EXP 198
104115: PUSH
104116: LD_VAR 0 1
104120: ARRAY
104121: PUSH
104122: LD_VAR 0 2
104126: ARRAY
104127: PUSH
104128: LD_INT 2
104130: ARRAY
104131: PPUSH
104132: CALL_OW 458
104136: AND
104137: IFFALSE 104231
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
104139: LD_EXP 198
104143: PUSH
104144: LD_VAR 0 1
104148: ARRAY
104149: PUSH
104150: LD_VAR 0 2
104154: ARRAY
104155: PUSH
104156: LD_INT 1
104158: ARRAY
104159: PPUSH
104160: LD_EXP 198
104164: PUSH
104165: LD_VAR 0 1
104169: ARRAY
104170: PUSH
104171: LD_VAR 0 2
104175: ARRAY
104176: PUSH
104177: LD_INT 2
104179: ARRAY
104180: PPUSH
104181: LD_VAR 0 3
104185: PPUSH
104186: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
104190: LD_ADDR_EXP 198
104194: PUSH
104195: LD_EXP 198
104199: PPUSH
104200: LD_VAR 0 1
104204: PPUSH
104205: LD_EXP 198
104209: PUSH
104210: LD_VAR 0 1
104214: ARRAY
104215: PPUSH
104216: LD_VAR 0 2
104220: PPUSH
104221: CALL_OW 3
104225: PPUSH
104226: CALL_OW 1
104230: ST_TO_ADDR
// end ; end ;
104231: GO 103982
104233: POP
104234: POP
// end ;
104235: GO 103900
104237: POP
104238: POP
// end ;
104239: PPOPN 4
104241: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
104242: LD_INT 0
104244: PPUSH
104245: PPUSH
// result := false ;
104246: LD_ADDR_VAR 0 4
104250: PUSH
104251: LD_INT 0
104253: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
104254: LD_VAR 0 1
104258: PPUSH
104259: CALL_OW 264
104263: PUSH
104264: LD_EXP 79
104268: EQUAL
104269: NOT
104270: IFFALSE 104274
// exit ;
104272: GO 104514
// index := GetElementIndex ( minersList , unit ) ;
104274: LD_ADDR_VAR 0 5
104278: PUSH
104279: LD_EXP 197
104283: PPUSH
104284: LD_VAR 0 1
104288: PPUSH
104289: CALL 55620 0 2
104293: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
104294: LD_EXP 198
104298: PUSH
104299: LD_VAR 0 5
104303: ARRAY
104304: PUSH
104305: LD_EXP 199
104309: GREATEREQUAL
104310: IFFALSE 104314
// exit ;
104312: GO 104514
// ComMoveXY ( unit , x , y ) ;
104314: LD_VAR 0 1
104318: PPUSH
104319: LD_VAR 0 2
104323: PPUSH
104324: LD_VAR 0 3
104328: PPUSH
104329: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104333: LD_INT 35
104335: PPUSH
104336: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
104340: LD_VAR 0 1
104344: PPUSH
104345: LD_VAR 0 2
104349: PPUSH
104350: LD_VAR 0 3
104354: PPUSH
104355: CALL 86017 0 3
104359: NOT
104360: PUSH
104361: LD_VAR 0 1
104365: PPUSH
104366: CALL_OW 314
104370: AND
104371: IFFALSE 104375
// exit ;
104373: GO 104514
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
104375: LD_VAR 0 2
104379: PPUSH
104380: LD_VAR 0 3
104384: PPUSH
104385: CALL_OW 428
104389: PUSH
104390: LD_VAR 0 1
104394: EQUAL
104395: PUSH
104396: LD_VAR 0 1
104400: PPUSH
104401: CALL_OW 314
104405: NOT
104406: AND
104407: IFFALSE 104333
// PlaySoundXY ( x , y , PlantMine ) ;
104409: LD_VAR 0 2
104413: PPUSH
104414: LD_VAR 0 3
104418: PPUSH
104419: LD_STRING PlantMine
104421: PPUSH
104422: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
104426: LD_VAR 0 2
104430: PPUSH
104431: LD_VAR 0 3
104435: PPUSH
104436: LD_VAR 0 1
104440: PPUSH
104441: CALL_OW 255
104445: PPUSH
104446: LD_INT 0
104448: PPUSH
104449: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
104453: LD_ADDR_EXP 198
104457: PUSH
104458: LD_EXP 198
104462: PPUSH
104463: LD_VAR 0 5
104467: PUSH
104468: LD_EXP 198
104472: PUSH
104473: LD_VAR 0 5
104477: ARRAY
104478: PUSH
104479: LD_INT 1
104481: PLUS
104482: PUSH
104483: EMPTY
104484: LIST
104485: LIST
104486: PPUSH
104487: LD_VAR 0 2
104491: PUSH
104492: LD_VAR 0 3
104496: PUSH
104497: EMPTY
104498: LIST
104499: LIST
104500: PPUSH
104501: CALL 55835 0 3
104505: ST_TO_ADDR
// result := true ;
104506: LD_ADDR_VAR 0 4
104510: PUSH
104511: LD_INT 1
104513: ST_TO_ADDR
// end ;
104514: LD_VAR 0 4
104518: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
104519: LD_INT 0
104521: PPUSH
104522: PPUSH
104523: PPUSH
// if not unit in minersList then
104524: LD_VAR 0 1
104528: PUSH
104529: LD_EXP 197
104533: IN
104534: NOT
104535: IFFALSE 104539
// exit ;
104537: GO 104931
// index := GetElementIndex ( minersList , unit ) ;
104539: LD_ADDR_VAR 0 6
104543: PUSH
104544: LD_EXP 197
104548: PPUSH
104549: LD_VAR 0 1
104553: PPUSH
104554: CALL 55620 0 2
104558: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
104559: LD_ADDR_VAR 0 5
104563: PUSH
104564: DOUBLE
104565: LD_EXP 198
104569: PUSH
104570: LD_VAR 0 6
104574: ARRAY
104575: INC
104576: ST_TO_ADDR
104577: LD_INT 1
104579: PUSH
104580: FOR_DOWNTO
104581: IFFALSE 104742
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
104583: LD_EXP 198
104587: PUSH
104588: LD_VAR 0 6
104592: ARRAY
104593: PUSH
104594: LD_VAR 0 5
104598: ARRAY
104599: PUSH
104600: LD_INT 1
104602: ARRAY
104603: PUSH
104604: LD_VAR 0 2
104608: EQUAL
104609: PUSH
104610: LD_EXP 198
104614: PUSH
104615: LD_VAR 0 6
104619: ARRAY
104620: PUSH
104621: LD_VAR 0 5
104625: ARRAY
104626: PUSH
104627: LD_INT 2
104629: ARRAY
104630: PUSH
104631: LD_VAR 0 3
104635: EQUAL
104636: AND
104637: IFFALSE 104740
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104639: LD_EXP 198
104643: PUSH
104644: LD_VAR 0 6
104648: ARRAY
104649: PUSH
104650: LD_VAR 0 5
104654: ARRAY
104655: PUSH
104656: LD_INT 1
104658: ARRAY
104659: PPUSH
104660: LD_EXP 198
104664: PUSH
104665: LD_VAR 0 6
104669: ARRAY
104670: PUSH
104671: LD_VAR 0 5
104675: ARRAY
104676: PUSH
104677: LD_INT 2
104679: ARRAY
104680: PPUSH
104681: LD_VAR 0 1
104685: PPUSH
104686: CALL_OW 255
104690: PPUSH
104691: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104695: LD_ADDR_EXP 198
104699: PUSH
104700: LD_EXP 198
104704: PPUSH
104705: LD_VAR 0 6
104709: PPUSH
104710: LD_EXP 198
104714: PUSH
104715: LD_VAR 0 6
104719: ARRAY
104720: PPUSH
104721: LD_VAR 0 5
104725: PPUSH
104726: CALL_OW 3
104730: PPUSH
104731: CALL_OW 1
104735: ST_TO_ADDR
// exit ;
104736: POP
104737: POP
104738: GO 104931
// end ; end ;
104740: GO 104580
104742: POP
104743: POP
// for i := minerMinesList [ index ] downto 1 do
104744: LD_ADDR_VAR 0 5
104748: PUSH
104749: DOUBLE
104750: LD_EXP 198
104754: PUSH
104755: LD_VAR 0 6
104759: ARRAY
104760: INC
104761: ST_TO_ADDR
104762: LD_INT 1
104764: PUSH
104765: FOR_DOWNTO
104766: IFFALSE 104929
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
104768: LD_EXP 198
104772: PUSH
104773: LD_VAR 0 6
104777: ARRAY
104778: PUSH
104779: LD_VAR 0 5
104783: ARRAY
104784: PUSH
104785: LD_INT 1
104787: ARRAY
104788: PPUSH
104789: LD_EXP 198
104793: PUSH
104794: LD_VAR 0 6
104798: ARRAY
104799: PUSH
104800: LD_VAR 0 5
104804: ARRAY
104805: PUSH
104806: LD_INT 2
104808: ARRAY
104809: PPUSH
104810: LD_VAR 0 2
104814: PPUSH
104815: LD_VAR 0 3
104819: PPUSH
104820: CALL_OW 298
104824: PUSH
104825: LD_INT 6
104827: LESS
104828: IFFALSE 104927
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104830: LD_EXP 198
104834: PUSH
104835: LD_VAR 0 6
104839: ARRAY
104840: PUSH
104841: LD_VAR 0 5
104845: ARRAY
104846: PUSH
104847: LD_INT 1
104849: ARRAY
104850: PPUSH
104851: LD_EXP 198
104855: PUSH
104856: LD_VAR 0 6
104860: ARRAY
104861: PUSH
104862: LD_VAR 0 5
104866: ARRAY
104867: PUSH
104868: LD_INT 2
104870: ARRAY
104871: PPUSH
104872: LD_VAR 0 1
104876: PPUSH
104877: CALL_OW 255
104881: PPUSH
104882: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104886: LD_ADDR_EXP 198
104890: PUSH
104891: LD_EXP 198
104895: PPUSH
104896: LD_VAR 0 6
104900: PPUSH
104901: LD_EXP 198
104905: PUSH
104906: LD_VAR 0 6
104910: ARRAY
104911: PPUSH
104912: LD_VAR 0 5
104916: PPUSH
104917: CALL_OW 3
104921: PPUSH
104922: CALL_OW 1
104926: ST_TO_ADDR
// end ; end ;
104927: GO 104765
104929: POP
104930: POP
// end ;
104931: LD_VAR 0 4
104935: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
104936: LD_INT 0
104938: PPUSH
104939: PPUSH
104940: PPUSH
104941: PPUSH
104942: PPUSH
104943: PPUSH
104944: PPUSH
104945: PPUSH
104946: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
104947: LD_VAR 0 1
104951: PPUSH
104952: CALL_OW 264
104956: PUSH
104957: LD_EXP 79
104961: EQUAL
104962: NOT
104963: PUSH
104964: LD_VAR 0 1
104968: PUSH
104969: LD_EXP 197
104973: IN
104974: NOT
104975: OR
104976: IFFALSE 104980
// exit ;
104978: GO 105302
// index := GetElementIndex ( minersList , unit ) ;
104980: LD_ADDR_VAR 0 6
104984: PUSH
104985: LD_EXP 197
104989: PPUSH
104990: LD_VAR 0 1
104994: PPUSH
104995: CALL 55620 0 2
104999: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
105000: LD_ADDR_VAR 0 8
105004: PUSH
105005: LD_EXP 199
105009: PUSH
105010: LD_EXP 198
105014: PUSH
105015: LD_VAR 0 6
105019: ARRAY
105020: MINUS
105021: ST_TO_ADDR
// if not minesFreeAmount then
105022: LD_VAR 0 8
105026: NOT
105027: IFFALSE 105031
// exit ;
105029: GO 105302
// tmp := [ ] ;
105031: LD_ADDR_VAR 0 7
105035: PUSH
105036: EMPTY
105037: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
105038: LD_ADDR_VAR 0 5
105042: PUSH
105043: DOUBLE
105044: LD_INT 1
105046: DEC
105047: ST_TO_ADDR
105048: LD_VAR 0 8
105052: PUSH
105053: FOR_TO
105054: IFFALSE 105249
// begin _d := rand ( 0 , 5 ) ;
105056: LD_ADDR_VAR 0 11
105060: PUSH
105061: LD_INT 0
105063: PPUSH
105064: LD_INT 5
105066: PPUSH
105067: CALL_OW 12
105071: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
105072: LD_ADDR_VAR 0 12
105076: PUSH
105077: LD_INT 2
105079: PPUSH
105080: LD_INT 6
105082: PPUSH
105083: CALL_OW 12
105087: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
105088: LD_ADDR_VAR 0 9
105092: PUSH
105093: LD_VAR 0 2
105097: PPUSH
105098: LD_VAR 0 11
105102: PPUSH
105103: LD_VAR 0 12
105107: PPUSH
105108: CALL_OW 272
105112: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
105113: LD_ADDR_VAR 0 10
105117: PUSH
105118: LD_VAR 0 3
105122: PPUSH
105123: LD_VAR 0 11
105127: PPUSH
105128: LD_VAR 0 12
105132: PPUSH
105133: CALL_OW 273
105137: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
105138: LD_VAR 0 9
105142: PPUSH
105143: LD_VAR 0 10
105147: PPUSH
105148: CALL_OW 488
105152: PUSH
105153: LD_VAR 0 9
105157: PUSH
105158: LD_VAR 0 10
105162: PUSH
105163: EMPTY
105164: LIST
105165: LIST
105166: PUSH
105167: LD_VAR 0 7
105171: IN
105172: NOT
105173: AND
105174: PUSH
105175: LD_VAR 0 9
105179: PPUSH
105180: LD_VAR 0 10
105184: PPUSH
105185: CALL_OW 458
105189: NOT
105190: AND
105191: IFFALSE 105233
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
105193: LD_ADDR_VAR 0 7
105197: PUSH
105198: LD_VAR 0 7
105202: PPUSH
105203: LD_VAR 0 7
105207: PUSH
105208: LD_INT 1
105210: PLUS
105211: PPUSH
105212: LD_VAR 0 9
105216: PUSH
105217: LD_VAR 0 10
105221: PUSH
105222: EMPTY
105223: LIST
105224: LIST
105225: PPUSH
105226: CALL_OW 1
105230: ST_TO_ADDR
105231: GO 105247
// i := i - 1 ;
105233: LD_ADDR_VAR 0 5
105237: PUSH
105238: LD_VAR 0 5
105242: PUSH
105243: LD_INT 1
105245: MINUS
105246: ST_TO_ADDR
// end ;
105247: GO 105053
105249: POP
105250: POP
// for i in tmp do
105251: LD_ADDR_VAR 0 5
105255: PUSH
105256: LD_VAR 0 7
105260: PUSH
105261: FOR_IN
105262: IFFALSE 105300
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
105264: LD_VAR 0 1
105268: PPUSH
105269: LD_VAR 0 5
105273: PUSH
105274: LD_INT 1
105276: ARRAY
105277: PPUSH
105278: LD_VAR 0 5
105282: PUSH
105283: LD_INT 2
105285: ARRAY
105286: PPUSH
105287: CALL 104242 0 3
105291: NOT
105292: IFFALSE 105298
// exit ;
105294: POP
105295: POP
105296: GO 105302
105298: GO 105261
105300: POP
105301: POP
// end ;
105302: LD_VAR 0 4
105306: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
105307: LD_INT 0
105309: PPUSH
105310: PPUSH
105311: PPUSH
105312: PPUSH
105313: PPUSH
105314: PPUSH
105315: PPUSH
// if not GetClass ( unit ) = class_sniper then
105316: LD_VAR 0 1
105320: PPUSH
105321: CALL_OW 257
105325: PUSH
105326: LD_INT 5
105328: EQUAL
105329: NOT
105330: IFFALSE 105334
// exit ;
105332: GO 105722
// dist := 8 ;
105334: LD_ADDR_VAR 0 5
105338: PUSH
105339: LD_INT 8
105341: ST_TO_ADDR
// viewRange := 12 ;
105342: LD_ADDR_VAR 0 7
105346: PUSH
105347: LD_INT 12
105349: ST_TO_ADDR
// side := GetSide ( unit ) ;
105350: LD_ADDR_VAR 0 6
105354: PUSH
105355: LD_VAR 0 1
105359: PPUSH
105360: CALL_OW 255
105364: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
105365: LD_INT 61
105367: PPUSH
105368: LD_VAR 0 6
105372: PPUSH
105373: CALL_OW 321
105377: PUSH
105378: LD_INT 2
105380: EQUAL
105381: IFFALSE 105391
// viewRange := 16 ;
105383: LD_ADDR_VAR 0 7
105387: PUSH
105388: LD_INT 16
105390: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
105391: LD_VAR 0 1
105395: PPUSH
105396: LD_VAR 0 2
105400: PPUSH
105401: LD_VAR 0 3
105405: PPUSH
105406: CALL_OW 297
105410: PUSH
105411: LD_VAR 0 5
105415: GREATER
105416: IFFALSE 105495
// begin ComMoveXY ( unit , x , y ) ;
105418: LD_VAR 0 1
105422: PPUSH
105423: LD_VAR 0 2
105427: PPUSH
105428: LD_VAR 0 3
105432: PPUSH
105433: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105437: LD_INT 35
105439: PPUSH
105440: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
105444: LD_VAR 0 1
105448: PPUSH
105449: LD_VAR 0 2
105453: PPUSH
105454: LD_VAR 0 3
105458: PPUSH
105459: CALL 86017 0 3
105463: NOT
105464: IFFALSE 105468
// exit ;
105466: GO 105722
// until GetDistUnitXY ( unit , x , y ) < dist ;
105468: LD_VAR 0 1
105472: PPUSH
105473: LD_VAR 0 2
105477: PPUSH
105478: LD_VAR 0 3
105482: PPUSH
105483: CALL_OW 297
105487: PUSH
105488: LD_VAR 0 5
105492: LESS
105493: IFFALSE 105437
// end ; ComTurnXY ( unit , x , y ) ;
105495: LD_VAR 0 1
105499: PPUSH
105500: LD_VAR 0 2
105504: PPUSH
105505: LD_VAR 0 3
105509: PPUSH
105510: CALL_OW 118
// wait ( 5 ) ;
105514: LD_INT 5
105516: PPUSH
105517: CALL_OW 67
// _d := GetDir ( unit ) ;
105521: LD_ADDR_VAR 0 10
105525: PUSH
105526: LD_VAR 0 1
105530: PPUSH
105531: CALL_OW 254
105535: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
105536: LD_ADDR_VAR 0 8
105540: PUSH
105541: LD_VAR 0 1
105545: PPUSH
105546: CALL_OW 250
105550: PPUSH
105551: LD_VAR 0 10
105555: PPUSH
105556: LD_VAR 0 5
105560: PPUSH
105561: CALL_OW 272
105565: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
105566: LD_ADDR_VAR 0 9
105570: PUSH
105571: LD_VAR 0 1
105575: PPUSH
105576: CALL_OW 251
105580: PPUSH
105581: LD_VAR 0 10
105585: PPUSH
105586: LD_VAR 0 5
105590: PPUSH
105591: CALL_OW 273
105595: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
105596: LD_VAR 0 8
105600: PPUSH
105601: LD_VAR 0 9
105605: PPUSH
105606: CALL_OW 488
105610: NOT
105611: IFFALSE 105615
// exit ;
105613: GO 105722
// ComAnimCustom ( unit , 1 ) ;
105615: LD_VAR 0 1
105619: PPUSH
105620: LD_INT 1
105622: PPUSH
105623: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
105627: LD_VAR 0 8
105631: PPUSH
105632: LD_VAR 0 9
105636: PPUSH
105637: LD_VAR 0 6
105641: PPUSH
105642: LD_VAR 0 7
105646: PPUSH
105647: CALL_OW 330
// repeat wait ( 1 ) ;
105651: LD_INT 1
105653: PPUSH
105654: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
105658: LD_VAR 0 1
105662: PPUSH
105663: CALL_OW 316
105667: PUSH
105668: LD_VAR 0 1
105672: PPUSH
105673: CALL_OW 314
105677: OR
105678: PUSH
105679: LD_VAR 0 1
105683: PPUSH
105684: CALL_OW 302
105688: NOT
105689: OR
105690: PUSH
105691: LD_VAR 0 1
105695: PPUSH
105696: CALL_OW 301
105700: OR
105701: IFFALSE 105651
// RemoveSeeing ( _x , _y , side ) ;
105703: LD_VAR 0 8
105707: PPUSH
105708: LD_VAR 0 9
105712: PPUSH
105713: LD_VAR 0 6
105717: PPUSH
105718: CALL_OW 331
// end ; end_of_file
105722: LD_VAR 0 4
105726: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
105727: LD_INT 0
105729: PPUSH
105730: PPUSH
105731: PPUSH
105732: PPUSH
105733: PPUSH
105734: PPUSH
105735: PPUSH
105736: PPUSH
105737: PPUSH
105738: PPUSH
105739: PPUSH
105740: PPUSH
105741: PPUSH
105742: PPUSH
105743: PPUSH
105744: PPUSH
105745: PPUSH
105746: PPUSH
105747: PPUSH
105748: PPUSH
105749: PPUSH
105750: PPUSH
105751: PPUSH
105752: PPUSH
105753: PPUSH
105754: PPUSH
105755: PPUSH
105756: PPUSH
105757: PPUSH
105758: PPUSH
105759: PPUSH
105760: PPUSH
105761: PPUSH
105762: PPUSH
// if not list then
105763: LD_VAR 0 1
105767: NOT
105768: IFFALSE 105772
// exit ;
105770: GO 110431
// base := list [ 1 ] ;
105772: LD_ADDR_VAR 0 3
105776: PUSH
105777: LD_VAR 0 1
105781: PUSH
105782: LD_INT 1
105784: ARRAY
105785: ST_TO_ADDR
// group := list [ 2 ] ;
105786: LD_ADDR_VAR 0 4
105790: PUSH
105791: LD_VAR 0 1
105795: PUSH
105796: LD_INT 2
105798: ARRAY
105799: ST_TO_ADDR
// path := list [ 3 ] ;
105800: LD_ADDR_VAR 0 5
105804: PUSH
105805: LD_VAR 0 1
105809: PUSH
105810: LD_INT 3
105812: ARRAY
105813: ST_TO_ADDR
// flags := list [ 4 ] ;
105814: LD_ADDR_VAR 0 6
105818: PUSH
105819: LD_VAR 0 1
105823: PUSH
105824: LD_INT 4
105826: ARRAY
105827: ST_TO_ADDR
// mined := [ ] ;
105828: LD_ADDR_VAR 0 27
105832: PUSH
105833: EMPTY
105834: ST_TO_ADDR
// bombed := [ ] ;
105835: LD_ADDR_VAR 0 28
105839: PUSH
105840: EMPTY
105841: ST_TO_ADDR
// healers := [ ] ;
105842: LD_ADDR_VAR 0 31
105846: PUSH
105847: EMPTY
105848: ST_TO_ADDR
// to_heal := [ ] ;
105849: LD_ADDR_VAR 0 30
105853: PUSH
105854: EMPTY
105855: ST_TO_ADDR
// repairs := [ ] ;
105856: LD_ADDR_VAR 0 33
105860: PUSH
105861: EMPTY
105862: ST_TO_ADDR
// to_repair := [ ] ;
105863: LD_ADDR_VAR 0 32
105867: PUSH
105868: EMPTY
105869: ST_TO_ADDR
// if not group or not path then
105870: LD_VAR 0 4
105874: NOT
105875: PUSH
105876: LD_VAR 0 5
105880: NOT
105881: OR
105882: IFFALSE 105886
// exit ;
105884: GO 110431
// side := GetSide ( group [ 1 ] ) ;
105886: LD_ADDR_VAR 0 35
105890: PUSH
105891: LD_VAR 0 4
105895: PUSH
105896: LD_INT 1
105898: ARRAY
105899: PPUSH
105900: CALL_OW 255
105904: ST_TO_ADDR
// if flags then
105905: LD_VAR 0 6
105909: IFFALSE 106053
// begin f_ignore_area := flags [ 1 ] ;
105911: LD_ADDR_VAR 0 17
105915: PUSH
105916: LD_VAR 0 6
105920: PUSH
105921: LD_INT 1
105923: ARRAY
105924: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
105925: LD_ADDR_VAR 0 18
105929: PUSH
105930: LD_VAR 0 6
105934: PUSH
105935: LD_INT 2
105937: ARRAY
105938: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
105939: LD_ADDR_VAR 0 19
105943: PUSH
105944: LD_VAR 0 6
105948: PUSH
105949: LD_INT 3
105951: ARRAY
105952: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
105953: LD_ADDR_VAR 0 20
105957: PUSH
105958: LD_VAR 0 6
105962: PUSH
105963: LD_INT 4
105965: ARRAY
105966: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
105967: LD_ADDR_VAR 0 21
105971: PUSH
105972: LD_VAR 0 6
105976: PUSH
105977: LD_INT 5
105979: ARRAY
105980: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
105981: LD_ADDR_VAR 0 22
105985: PUSH
105986: LD_VAR 0 6
105990: PUSH
105991: LD_INT 6
105993: ARRAY
105994: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
105995: LD_ADDR_VAR 0 23
105999: PUSH
106000: LD_VAR 0 6
106004: PUSH
106005: LD_INT 7
106007: ARRAY
106008: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
106009: LD_ADDR_VAR 0 24
106013: PUSH
106014: LD_VAR 0 6
106018: PUSH
106019: LD_INT 8
106021: ARRAY
106022: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
106023: LD_ADDR_VAR 0 25
106027: PUSH
106028: LD_VAR 0 6
106032: PUSH
106033: LD_INT 9
106035: ARRAY
106036: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
106037: LD_ADDR_VAR 0 26
106041: PUSH
106042: LD_VAR 0 6
106046: PUSH
106047: LD_INT 10
106049: ARRAY
106050: ST_TO_ADDR
// end else
106051: GO 106133
// begin f_ignore_area := false ;
106053: LD_ADDR_VAR 0 17
106057: PUSH
106058: LD_INT 0
106060: ST_TO_ADDR
// f_capture := false ;
106061: LD_ADDR_VAR 0 18
106065: PUSH
106066: LD_INT 0
106068: ST_TO_ADDR
// f_ignore_civ := false ;
106069: LD_ADDR_VAR 0 19
106073: PUSH
106074: LD_INT 0
106076: ST_TO_ADDR
// f_murder := false ;
106077: LD_ADDR_VAR 0 20
106081: PUSH
106082: LD_INT 0
106084: ST_TO_ADDR
// f_mines := false ;
106085: LD_ADDR_VAR 0 21
106089: PUSH
106090: LD_INT 0
106092: ST_TO_ADDR
// f_repair := false ;
106093: LD_ADDR_VAR 0 22
106097: PUSH
106098: LD_INT 0
106100: ST_TO_ADDR
// f_heal := false ;
106101: LD_ADDR_VAR 0 23
106105: PUSH
106106: LD_INT 0
106108: ST_TO_ADDR
// f_spacetime := false ;
106109: LD_ADDR_VAR 0 24
106113: PUSH
106114: LD_INT 0
106116: ST_TO_ADDR
// f_attack_depot := false ;
106117: LD_ADDR_VAR 0 25
106121: PUSH
106122: LD_INT 0
106124: ST_TO_ADDR
// f_crawl := false ;
106125: LD_ADDR_VAR 0 26
106129: PUSH
106130: LD_INT 0
106132: ST_TO_ADDR
// end ; if f_heal then
106133: LD_VAR 0 23
106137: IFFALSE 106164
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
106139: LD_ADDR_VAR 0 31
106143: PUSH
106144: LD_VAR 0 4
106148: PPUSH
106149: LD_INT 25
106151: PUSH
106152: LD_INT 4
106154: PUSH
106155: EMPTY
106156: LIST
106157: LIST
106158: PPUSH
106159: CALL_OW 72
106163: ST_TO_ADDR
// if f_repair then
106164: LD_VAR 0 22
106168: IFFALSE 106195
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
106170: LD_ADDR_VAR 0 33
106174: PUSH
106175: LD_VAR 0 4
106179: PPUSH
106180: LD_INT 25
106182: PUSH
106183: LD_INT 3
106185: PUSH
106186: EMPTY
106187: LIST
106188: LIST
106189: PPUSH
106190: CALL_OW 72
106194: ST_TO_ADDR
// units_path := [ ] ;
106195: LD_ADDR_VAR 0 16
106199: PUSH
106200: EMPTY
106201: ST_TO_ADDR
// for i = 1 to group do
106202: LD_ADDR_VAR 0 7
106206: PUSH
106207: DOUBLE
106208: LD_INT 1
106210: DEC
106211: ST_TO_ADDR
106212: LD_VAR 0 4
106216: PUSH
106217: FOR_TO
106218: IFFALSE 106247
// units_path := Replace ( units_path , i , path ) ;
106220: LD_ADDR_VAR 0 16
106224: PUSH
106225: LD_VAR 0 16
106229: PPUSH
106230: LD_VAR 0 7
106234: PPUSH
106235: LD_VAR 0 5
106239: PPUSH
106240: CALL_OW 1
106244: ST_TO_ADDR
106245: GO 106217
106247: POP
106248: POP
// repeat for i = group downto 1 do
106249: LD_ADDR_VAR 0 7
106253: PUSH
106254: DOUBLE
106255: LD_VAR 0 4
106259: INC
106260: ST_TO_ADDR
106261: LD_INT 1
106263: PUSH
106264: FOR_DOWNTO
106265: IFFALSE 110387
// begin wait ( 5 ) ;
106267: LD_INT 5
106269: PPUSH
106270: CALL_OW 67
// tmp := [ ] ;
106274: LD_ADDR_VAR 0 14
106278: PUSH
106279: EMPTY
106280: ST_TO_ADDR
// attacking := false ;
106281: LD_ADDR_VAR 0 29
106285: PUSH
106286: LD_INT 0
106288: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
106289: LD_VAR 0 4
106293: PUSH
106294: LD_VAR 0 7
106298: ARRAY
106299: PPUSH
106300: CALL_OW 301
106304: PUSH
106305: LD_VAR 0 4
106309: PUSH
106310: LD_VAR 0 7
106314: ARRAY
106315: NOT
106316: OR
106317: IFFALSE 106426
// begin if GetType ( group [ i ] ) = unit_human then
106319: LD_VAR 0 4
106323: PUSH
106324: LD_VAR 0 7
106328: ARRAY
106329: PPUSH
106330: CALL_OW 247
106334: PUSH
106335: LD_INT 1
106337: EQUAL
106338: IFFALSE 106384
// begin to_heal := to_heal diff group [ i ] ;
106340: LD_ADDR_VAR 0 30
106344: PUSH
106345: LD_VAR 0 30
106349: PUSH
106350: LD_VAR 0 4
106354: PUSH
106355: LD_VAR 0 7
106359: ARRAY
106360: DIFF
106361: ST_TO_ADDR
// healers := healers diff group [ i ] ;
106362: LD_ADDR_VAR 0 31
106366: PUSH
106367: LD_VAR 0 31
106371: PUSH
106372: LD_VAR 0 4
106376: PUSH
106377: LD_VAR 0 7
106381: ARRAY
106382: DIFF
106383: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
106384: LD_ADDR_VAR 0 4
106388: PUSH
106389: LD_VAR 0 4
106393: PPUSH
106394: LD_VAR 0 7
106398: PPUSH
106399: CALL_OW 3
106403: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
106404: LD_ADDR_VAR 0 16
106408: PUSH
106409: LD_VAR 0 16
106413: PPUSH
106414: LD_VAR 0 7
106418: PPUSH
106419: CALL_OW 3
106423: ST_TO_ADDR
// continue ;
106424: GO 106264
// end ; if f_repair then
106426: LD_VAR 0 22
106430: IFFALSE 106919
// begin if GetType ( group [ i ] ) = unit_vehicle then
106432: LD_VAR 0 4
106436: PUSH
106437: LD_VAR 0 7
106441: ARRAY
106442: PPUSH
106443: CALL_OW 247
106447: PUSH
106448: LD_INT 2
106450: EQUAL
106451: IFFALSE 106641
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
106453: LD_VAR 0 4
106457: PUSH
106458: LD_VAR 0 7
106462: ARRAY
106463: PPUSH
106464: CALL_OW 256
106468: PUSH
106469: LD_INT 700
106471: LESS
106472: PUSH
106473: LD_VAR 0 4
106477: PUSH
106478: LD_VAR 0 7
106482: ARRAY
106483: PUSH
106484: LD_VAR 0 32
106488: IN
106489: NOT
106490: AND
106491: IFFALSE 106515
// to_repair := to_repair union group [ i ] ;
106493: LD_ADDR_VAR 0 32
106497: PUSH
106498: LD_VAR 0 32
106502: PUSH
106503: LD_VAR 0 4
106507: PUSH
106508: LD_VAR 0 7
106512: ARRAY
106513: UNION
106514: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
106515: LD_VAR 0 4
106519: PUSH
106520: LD_VAR 0 7
106524: ARRAY
106525: PPUSH
106526: CALL_OW 256
106530: PUSH
106531: LD_INT 1000
106533: EQUAL
106534: PUSH
106535: LD_VAR 0 4
106539: PUSH
106540: LD_VAR 0 7
106544: ARRAY
106545: PUSH
106546: LD_VAR 0 32
106550: IN
106551: AND
106552: IFFALSE 106576
// to_repair := to_repair diff group [ i ] ;
106554: LD_ADDR_VAR 0 32
106558: PUSH
106559: LD_VAR 0 32
106563: PUSH
106564: LD_VAR 0 4
106568: PUSH
106569: LD_VAR 0 7
106573: ARRAY
106574: DIFF
106575: ST_TO_ADDR
// if group [ i ] in to_repair then
106576: LD_VAR 0 4
106580: PUSH
106581: LD_VAR 0 7
106585: ARRAY
106586: PUSH
106587: LD_VAR 0 32
106591: IN
106592: IFFALSE 106639
// begin if not IsInArea ( group [ i ] , f_repair ) then
106594: LD_VAR 0 4
106598: PUSH
106599: LD_VAR 0 7
106603: ARRAY
106604: PPUSH
106605: LD_VAR 0 22
106609: PPUSH
106610: CALL_OW 308
106614: NOT
106615: IFFALSE 106637
// ComMoveToArea ( group [ i ] , f_repair ) ;
106617: LD_VAR 0 4
106621: PUSH
106622: LD_VAR 0 7
106626: ARRAY
106627: PPUSH
106628: LD_VAR 0 22
106632: PPUSH
106633: CALL_OW 113
// continue ;
106637: GO 106264
// end ; end else
106639: GO 106919
// if group [ i ] in repairs then
106641: LD_VAR 0 4
106645: PUSH
106646: LD_VAR 0 7
106650: ARRAY
106651: PUSH
106652: LD_VAR 0 33
106656: IN
106657: IFFALSE 106919
// begin if IsInUnit ( group [ i ] ) then
106659: LD_VAR 0 4
106663: PUSH
106664: LD_VAR 0 7
106668: ARRAY
106669: PPUSH
106670: CALL_OW 310
106674: IFFALSE 106742
// begin z := IsInUnit ( group [ i ] ) ;
106676: LD_ADDR_VAR 0 13
106680: PUSH
106681: LD_VAR 0 4
106685: PUSH
106686: LD_VAR 0 7
106690: ARRAY
106691: PPUSH
106692: CALL_OW 310
106696: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
106697: LD_VAR 0 13
106701: PUSH
106702: LD_VAR 0 32
106706: IN
106707: PUSH
106708: LD_VAR 0 13
106712: PPUSH
106713: LD_VAR 0 22
106717: PPUSH
106718: CALL_OW 308
106722: AND
106723: IFFALSE 106740
// ComExitVehicle ( group [ i ] ) ;
106725: LD_VAR 0 4
106729: PUSH
106730: LD_VAR 0 7
106734: ARRAY
106735: PPUSH
106736: CALL_OW 121
// end else
106740: GO 106919
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
106742: LD_ADDR_VAR 0 13
106746: PUSH
106747: LD_VAR 0 4
106751: PPUSH
106752: LD_INT 95
106754: PUSH
106755: LD_VAR 0 22
106759: PUSH
106760: EMPTY
106761: LIST
106762: LIST
106763: PUSH
106764: LD_INT 58
106766: PUSH
106767: EMPTY
106768: LIST
106769: PUSH
106770: EMPTY
106771: LIST
106772: LIST
106773: PPUSH
106774: CALL_OW 72
106778: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
106779: LD_VAR 0 4
106783: PUSH
106784: LD_VAR 0 7
106788: ARRAY
106789: PPUSH
106790: CALL_OW 314
106794: NOT
106795: IFFALSE 106917
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
106797: LD_ADDR_VAR 0 10
106801: PUSH
106802: LD_VAR 0 13
106806: PPUSH
106807: LD_VAR 0 4
106811: PUSH
106812: LD_VAR 0 7
106816: ARRAY
106817: PPUSH
106818: CALL_OW 74
106822: ST_TO_ADDR
// if not x then
106823: LD_VAR 0 10
106827: NOT
106828: IFFALSE 106832
// continue ;
106830: GO 106264
// if GetLives ( x ) < 1000 then
106832: LD_VAR 0 10
106836: PPUSH
106837: CALL_OW 256
106841: PUSH
106842: LD_INT 1000
106844: LESS
106845: IFFALSE 106869
// ComRepairVehicle ( group [ i ] , x ) else
106847: LD_VAR 0 4
106851: PUSH
106852: LD_VAR 0 7
106856: ARRAY
106857: PPUSH
106858: LD_VAR 0 10
106862: PPUSH
106863: CALL_OW 129
106867: GO 106917
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
106869: LD_VAR 0 23
106873: PUSH
106874: LD_VAR 0 4
106878: PUSH
106879: LD_VAR 0 7
106883: ARRAY
106884: PPUSH
106885: CALL_OW 256
106889: PUSH
106890: LD_INT 1000
106892: LESS
106893: AND
106894: NOT
106895: IFFALSE 106917
// ComEnterUnit ( group [ i ] , x ) ;
106897: LD_VAR 0 4
106901: PUSH
106902: LD_VAR 0 7
106906: ARRAY
106907: PPUSH
106908: LD_VAR 0 10
106912: PPUSH
106913: CALL_OW 120
// end ; continue ;
106917: GO 106264
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
106919: LD_VAR 0 23
106923: PUSH
106924: LD_VAR 0 4
106928: PUSH
106929: LD_VAR 0 7
106933: ARRAY
106934: PPUSH
106935: CALL_OW 247
106939: PUSH
106940: LD_INT 1
106942: EQUAL
106943: AND
106944: IFFALSE 107422
// begin if group [ i ] in healers then
106946: LD_VAR 0 4
106950: PUSH
106951: LD_VAR 0 7
106955: ARRAY
106956: PUSH
106957: LD_VAR 0 31
106961: IN
106962: IFFALSE 107235
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
106964: LD_VAR 0 4
106968: PUSH
106969: LD_VAR 0 7
106973: ARRAY
106974: PPUSH
106975: LD_VAR 0 23
106979: PPUSH
106980: CALL_OW 308
106984: NOT
106985: PUSH
106986: LD_VAR 0 4
106990: PUSH
106991: LD_VAR 0 7
106995: ARRAY
106996: PPUSH
106997: CALL_OW 314
107001: NOT
107002: AND
107003: IFFALSE 107027
// ComMoveToArea ( group [ i ] , f_heal ) else
107005: LD_VAR 0 4
107009: PUSH
107010: LD_VAR 0 7
107014: ARRAY
107015: PPUSH
107016: LD_VAR 0 23
107020: PPUSH
107021: CALL_OW 113
107025: GO 107233
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
107027: LD_VAR 0 4
107031: PUSH
107032: LD_VAR 0 7
107036: ARRAY
107037: PPUSH
107038: CALL 84540 0 1
107042: PPUSH
107043: CALL_OW 256
107047: PUSH
107048: LD_INT 1000
107050: EQUAL
107051: IFFALSE 107070
// ComStop ( group [ i ] ) else
107053: LD_VAR 0 4
107057: PUSH
107058: LD_VAR 0 7
107062: ARRAY
107063: PPUSH
107064: CALL_OW 141
107068: GO 107233
// if not HasTask ( group [ i ] ) and to_heal then
107070: LD_VAR 0 4
107074: PUSH
107075: LD_VAR 0 7
107079: ARRAY
107080: PPUSH
107081: CALL_OW 314
107085: NOT
107086: PUSH
107087: LD_VAR 0 30
107091: AND
107092: IFFALSE 107233
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
107094: LD_ADDR_VAR 0 13
107098: PUSH
107099: LD_VAR 0 30
107103: PPUSH
107104: LD_INT 3
107106: PUSH
107107: LD_INT 54
107109: PUSH
107110: EMPTY
107111: LIST
107112: PUSH
107113: EMPTY
107114: LIST
107115: LIST
107116: PPUSH
107117: CALL_OW 72
107121: PPUSH
107122: LD_VAR 0 4
107126: PUSH
107127: LD_VAR 0 7
107131: ARRAY
107132: PPUSH
107133: CALL_OW 74
107137: ST_TO_ADDR
// if z then
107138: LD_VAR 0 13
107142: IFFALSE 107233
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
107144: LD_INT 91
107146: PUSH
107147: LD_VAR 0 13
107151: PUSH
107152: LD_INT 10
107154: PUSH
107155: EMPTY
107156: LIST
107157: LIST
107158: LIST
107159: PUSH
107160: LD_INT 81
107162: PUSH
107163: LD_VAR 0 13
107167: PPUSH
107168: CALL_OW 255
107172: PUSH
107173: EMPTY
107174: LIST
107175: LIST
107176: PUSH
107177: EMPTY
107178: LIST
107179: LIST
107180: PPUSH
107181: CALL_OW 69
107185: PUSH
107186: LD_INT 0
107188: EQUAL
107189: IFFALSE 107213
// ComHeal ( group [ i ] , z ) else
107191: LD_VAR 0 4
107195: PUSH
107196: LD_VAR 0 7
107200: ARRAY
107201: PPUSH
107202: LD_VAR 0 13
107206: PPUSH
107207: CALL_OW 128
107211: GO 107233
// ComMoveToArea ( group [ i ] , f_heal ) ;
107213: LD_VAR 0 4
107217: PUSH
107218: LD_VAR 0 7
107222: ARRAY
107223: PPUSH
107224: LD_VAR 0 23
107228: PPUSH
107229: CALL_OW 113
// end ; continue ;
107233: GO 106264
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
107235: LD_VAR 0 4
107239: PUSH
107240: LD_VAR 0 7
107244: ARRAY
107245: PPUSH
107246: CALL_OW 256
107250: PUSH
107251: LD_INT 700
107253: LESS
107254: PUSH
107255: LD_VAR 0 4
107259: PUSH
107260: LD_VAR 0 7
107264: ARRAY
107265: PUSH
107266: LD_VAR 0 30
107270: IN
107271: NOT
107272: AND
107273: IFFALSE 107297
// to_heal := to_heal union group [ i ] ;
107275: LD_ADDR_VAR 0 30
107279: PUSH
107280: LD_VAR 0 30
107284: PUSH
107285: LD_VAR 0 4
107289: PUSH
107290: LD_VAR 0 7
107294: ARRAY
107295: UNION
107296: ST_TO_ADDR
// if group [ i ] in to_heal then
107297: LD_VAR 0 4
107301: PUSH
107302: LD_VAR 0 7
107306: ARRAY
107307: PUSH
107308: LD_VAR 0 30
107312: IN
107313: IFFALSE 107422
// begin if GetLives ( group [ i ] ) = 1000 then
107315: LD_VAR 0 4
107319: PUSH
107320: LD_VAR 0 7
107324: ARRAY
107325: PPUSH
107326: CALL_OW 256
107330: PUSH
107331: LD_INT 1000
107333: EQUAL
107334: IFFALSE 107360
// to_heal := to_heal diff group [ i ] else
107336: LD_ADDR_VAR 0 30
107340: PUSH
107341: LD_VAR 0 30
107345: PUSH
107346: LD_VAR 0 4
107350: PUSH
107351: LD_VAR 0 7
107355: ARRAY
107356: DIFF
107357: ST_TO_ADDR
107358: GO 107422
// begin if not IsInArea ( group [ i ] , to_heal ) then
107360: LD_VAR 0 4
107364: PUSH
107365: LD_VAR 0 7
107369: ARRAY
107370: PPUSH
107371: LD_VAR 0 30
107375: PPUSH
107376: CALL_OW 308
107380: NOT
107381: IFFALSE 107405
// ComMoveToArea ( group [ i ] , f_heal ) else
107383: LD_VAR 0 4
107387: PUSH
107388: LD_VAR 0 7
107392: ARRAY
107393: PPUSH
107394: LD_VAR 0 23
107398: PPUSH
107399: CALL_OW 113
107403: GO 107420
// ComHold ( group [ i ] ) ;
107405: LD_VAR 0 4
107409: PUSH
107410: LD_VAR 0 7
107414: ARRAY
107415: PPUSH
107416: CALL_OW 140
// continue ;
107420: GO 106264
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
107422: LD_VAR 0 4
107426: PUSH
107427: LD_VAR 0 7
107431: ARRAY
107432: PPUSH
107433: LD_INT 10
107435: PPUSH
107436: CALL 82960 0 2
107440: NOT
107441: PUSH
107442: LD_VAR 0 16
107446: PUSH
107447: LD_VAR 0 7
107451: ARRAY
107452: PUSH
107453: EMPTY
107454: EQUAL
107455: NOT
107456: AND
107457: IFFALSE 107723
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
107459: LD_VAR 0 4
107463: PUSH
107464: LD_VAR 0 7
107468: ARRAY
107469: PPUSH
107470: CALL_OW 262
107474: PUSH
107475: LD_INT 1
107477: PUSH
107478: LD_INT 2
107480: PUSH
107481: EMPTY
107482: LIST
107483: LIST
107484: IN
107485: IFFALSE 107526
// if GetFuel ( group [ i ] ) < 10 then
107487: LD_VAR 0 4
107491: PUSH
107492: LD_VAR 0 7
107496: ARRAY
107497: PPUSH
107498: CALL_OW 261
107502: PUSH
107503: LD_INT 10
107505: LESS
107506: IFFALSE 107526
// SetFuel ( group [ i ] , 12 ) ;
107508: LD_VAR 0 4
107512: PUSH
107513: LD_VAR 0 7
107517: ARRAY
107518: PPUSH
107519: LD_INT 12
107521: PPUSH
107522: CALL_OW 240
// if units_path [ i ] then
107526: LD_VAR 0 16
107530: PUSH
107531: LD_VAR 0 7
107535: ARRAY
107536: IFFALSE 107721
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
107538: LD_VAR 0 4
107542: PUSH
107543: LD_VAR 0 7
107547: ARRAY
107548: PPUSH
107549: LD_VAR 0 16
107553: PUSH
107554: LD_VAR 0 7
107558: ARRAY
107559: PUSH
107560: LD_INT 1
107562: ARRAY
107563: PUSH
107564: LD_INT 1
107566: ARRAY
107567: PPUSH
107568: LD_VAR 0 16
107572: PUSH
107573: LD_VAR 0 7
107577: ARRAY
107578: PUSH
107579: LD_INT 1
107581: ARRAY
107582: PUSH
107583: LD_INT 2
107585: ARRAY
107586: PPUSH
107587: CALL_OW 297
107591: PUSH
107592: LD_INT 6
107594: GREATER
107595: IFFALSE 107670
// begin if not HasTask ( group [ i ] ) then
107597: LD_VAR 0 4
107601: PUSH
107602: LD_VAR 0 7
107606: ARRAY
107607: PPUSH
107608: CALL_OW 314
107612: NOT
107613: IFFALSE 107668
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
107615: LD_VAR 0 4
107619: PUSH
107620: LD_VAR 0 7
107624: ARRAY
107625: PPUSH
107626: LD_VAR 0 16
107630: PUSH
107631: LD_VAR 0 7
107635: ARRAY
107636: PUSH
107637: LD_INT 1
107639: ARRAY
107640: PUSH
107641: LD_INT 1
107643: ARRAY
107644: PPUSH
107645: LD_VAR 0 16
107649: PUSH
107650: LD_VAR 0 7
107654: ARRAY
107655: PUSH
107656: LD_INT 1
107658: ARRAY
107659: PUSH
107660: LD_INT 2
107662: ARRAY
107663: PPUSH
107664: CALL_OW 114
// end else
107668: GO 107721
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
107670: LD_ADDR_VAR 0 15
107674: PUSH
107675: LD_VAR 0 16
107679: PUSH
107680: LD_VAR 0 7
107684: ARRAY
107685: PPUSH
107686: LD_INT 1
107688: PPUSH
107689: CALL_OW 3
107693: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
107694: LD_ADDR_VAR 0 16
107698: PUSH
107699: LD_VAR 0 16
107703: PPUSH
107704: LD_VAR 0 7
107708: PPUSH
107709: LD_VAR 0 15
107713: PPUSH
107714: CALL_OW 1
107718: ST_TO_ADDR
// continue ;
107719: GO 106264
// end ; end ; end else
107721: GO 110385
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
107723: LD_ADDR_VAR 0 14
107727: PUSH
107728: LD_INT 81
107730: PUSH
107731: LD_VAR 0 4
107735: PUSH
107736: LD_VAR 0 7
107740: ARRAY
107741: PPUSH
107742: CALL_OW 255
107746: PUSH
107747: EMPTY
107748: LIST
107749: LIST
107750: PPUSH
107751: CALL_OW 69
107755: ST_TO_ADDR
// if not tmp then
107756: LD_VAR 0 14
107760: NOT
107761: IFFALSE 107765
// continue ;
107763: GO 106264
// if f_ignore_area then
107765: LD_VAR 0 17
107769: IFFALSE 107857
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
107771: LD_ADDR_VAR 0 15
107775: PUSH
107776: LD_VAR 0 14
107780: PPUSH
107781: LD_INT 3
107783: PUSH
107784: LD_INT 92
107786: PUSH
107787: LD_VAR 0 17
107791: PUSH
107792: LD_INT 1
107794: ARRAY
107795: PUSH
107796: LD_VAR 0 17
107800: PUSH
107801: LD_INT 2
107803: ARRAY
107804: PUSH
107805: LD_VAR 0 17
107809: PUSH
107810: LD_INT 3
107812: ARRAY
107813: PUSH
107814: EMPTY
107815: LIST
107816: LIST
107817: LIST
107818: LIST
107819: PUSH
107820: EMPTY
107821: LIST
107822: LIST
107823: PPUSH
107824: CALL_OW 72
107828: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107829: LD_VAR 0 14
107833: PUSH
107834: LD_VAR 0 15
107838: DIFF
107839: IFFALSE 107857
// tmp := tmp diff tmp2 ;
107841: LD_ADDR_VAR 0 14
107845: PUSH
107846: LD_VAR 0 14
107850: PUSH
107851: LD_VAR 0 15
107855: DIFF
107856: ST_TO_ADDR
// end ; if not f_murder then
107857: LD_VAR 0 20
107861: NOT
107862: IFFALSE 107920
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
107864: LD_ADDR_VAR 0 15
107868: PUSH
107869: LD_VAR 0 14
107873: PPUSH
107874: LD_INT 3
107876: PUSH
107877: LD_INT 50
107879: PUSH
107880: EMPTY
107881: LIST
107882: PUSH
107883: EMPTY
107884: LIST
107885: LIST
107886: PPUSH
107887: CALL_OW 72
107891: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107892: LD_VAR 0 14
107896: PUSH
107897: LD_VAR 0 15
107901: DIFF
107902: IFFALSE 107920
// tmp := tmp diff tmp2 ;
107904: LD_ADDR_VAR 0 14
107908: PUSH
107909: LD_VAR 0 14
107913: PUSH
107914: LD_VAR 0 15
107918: DIFF
107919: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
107920: LD_ADDR_VAR 0 14
107924: PUSH
107925: LD_VAR 0 4
107929: PUSH
107930: LD_VAR 0 7
107934: ARRAY
107935: PPUSH
107936: LD_VAR 0 14
107940: PPUSH
107941: LD_INT 1
107943: PPUSH
107944: LD_INT 1
107946: PPUSH
107947: CALL 56270 0 4
107951: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
107952: LD_VAR 0 4
107956: PUSH
107957: LD_VAR 0 7
107961: ARRAY
107962: PPUSH
107963: CALL_OW 257
107967: PUSH
107968: LD_INT 1
107970: EQUAL
107971: IFFALSE 108419
// begin if WantPlant ( group [ i ] ) then
107973: LD_VAR 0 4
107977: PUSH
107978: LD_VAR 0 7
107982: ARRAY
107983: PPUSH
107984: CALL 55771 0 1
107988: IFFALSE 107992
// continue ;
107990: GO 106264
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
107992: LD_VAR 0 18
107996: PUSH
107997: LD_VAR 0 4
108001: PUSH
108002: LD_VAR 0 7
108006: ARRAY
108007: PPUSH
108008: CALL_OW 310
108012: NOT
108013: AND
108014: PUSH
108015: LD_VAR 0 14
108019: PUSH
108020: LD_INT 1
108022: ARRAY
108023: PUSH
108024: LD_VAR 0 14
108028: PPUSH
108029: LD_INT 21
108031: PUSH
108032: LD_INT 2
108034: PUSH
108035: EMPTY
108036: LIST
108037: LIST
108038: PUSH
108039: LD_INT 58
108041: PUSH
108042: EMPTY
108043: LIST
108044: PUSH
108045: EMPTY
108046: LIST
108047: LIST
108048: PPUSH
108049: CALL_OW 72
108053: IN
108054: AND
108055: IFFALSE 108091
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
108057: LD_VAR 0 4
108061: PUSH
108062: LD_VAR 0 7
108066: ARRAY
108067: PPUSH
108068: LD_VAR 0 14
108072: PUSH
108073: LD_INT 1
108075: ARRAY
108076: PPUSH
108077: CALL_OW 120
// attacking := true ;
108081: LD_ADDR_VAR 0 29
108085: PUSH
108086: LD_INT 1
108088: ST_TO_ADDR
// continue ;
108089: GO 106264
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
108091: LD_VAR 0 26
108095: PUSH
108096: LD_VAR 0 4
108100: PUSH
108101: LD_VAR 0 7
108105: ARRAY
108106: PPUSH
108107: CALL_OW 257
108111: PUSH
108112: LD_INT 1
108114: EQUAL
108115: AND
108116: PUSH
108117: LD_VAR 0 4
108121: PUSH
108122: LD_VAR 0 7
108126: ARRAY
108127: PPUSH
108128: CALL_OW 256
108132: PUSH
108133: LD_INT 800
108135: LESS
108136: AND
108137: PUSH
108138: LD_VAR 0 4
108142: PUSH
108143: LD_VAR 0 7
108147: ARRAY
108148: PPUSH
108149: CALL_OW 318
108153: NOT
108154: AND
108155: IFFALSE 108172
// ComCrawl ( group [ i ] ) ;
108157: LD_VAR 0 4
108161: PUSH
108162: LD_VAR 0 7
108166: ARRAY
108167: PPUSH
108168: CALL_OW 137
// if f_mines then
108172: LD_VAR 0 21
108176: IFFALSE 108419
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
108178: LD_VAR 0 14
108182: PUSH
108183: LD_INT 1
108185: ARRAY
108186: PPUSH
108187: CALL_OW 247
108191: PUSH
108192: LD_INT 3
108194: EQUAL
108195: PUSH
108196: LD_VAR 0 14
108200: PUSH
108201: LD_INT 1
108203: ARRAY
108204: PUSH
108205: LD_VAR 0 27
108209: IN
108210: NOT
108211: AND
108212: IFFALSE 108419
// begin x := GetX ( tmp [ 1 ] ) ;
108214: LD_ADDR_VAR 0 10
108218: PUSH
108219: LD_VAR 0 14
108223: PUSH
108224: LD_INT 1
108226: ARRAY
108227: PPUSH
108228: CALL_OW 250
108232: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
108233: LD_ADDR_VAR 0 11
108237: PUSH
108238: LD_VAR 0 14
108242: PUSH
108243: LD_INT 1
108245: ARRAY
108246: PPUSH
108247: CALL_OW 251
108251: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
108252: LD_ADDR_VAR 0 12
108256: PUSH
108257: LD_VAR 0 4
108261: PUSH
108262: LD_VAR 0 7
108266: ARRAY
108267: PPUSH
108268: CALL 83045 0 1
108272: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
108273: LD_VAR 0 4
108277: PUSH
108278: LD_VAR 0 7
108282: ARRAY
108283: PPUSH
108284: LD_VAR 0 10
108288: PPUSH
108289: LD_VAR 0 11
108293: PPUSH
108294: LD_VAR 0 14
108298: PUSH
108299: LD_INT 1
108301: ARRAY
108302: PPUSH
108303: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
108307: LD_VAR 0 4
108311: PUSH
108312: LD_VAR 0 7
108316: ARRAY
108317: PPUSH
108318: LD_VAR 0 10
108322: PPUSH
108323: LD_VAR 0 12
108327: PPUSH
108328: LD_INT 7
108330: PPUSH
108331: CALL_OW 272
108335: PPUSH
108336: LD_VAR 0 11
108340: PPUSH
108341: LD_VAR 0 12
108345: PPUSH
108346: LD_INT 7
108348: PPUSH
108349: CALL_OW 273
108353: PPUSH
108354: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
108358: LD_VAR 0 4
108362: PUSH
108363: LD_VAR 0 7
108367: ARRAY
108368: PPUSH
108369: LD_INT 71
108371: PPUSH
108372: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
108376: LD_ADDR_VAR 0 27
108380: PUSH
108381: LD_VAR 0 27
108385: PPUSH
108386: LD_VAR 0 27
108390: PUSH
108391: LD_INT 1
108393: PLUS
108394: PPUSH
108395: LD_VAR 0 14
108399: PUSH
108400: LD_INT 1
108402: ARRAY
108403: PPUSH
108404: CALL_OW 1
108408: ST_TO_ADDR
// attacking := true ;
108409: LD_ADDR_VAR 0 29
108413: PUSH
108414: LD_INT 1
108416: ST_TO_ADDR
// continue ;
108417: GO 106264
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
108419: LD_VAR 0 4
108423: PUSH
108424: LD_VAR 0 7
108428: ARRAY
108429: PPUSH
108430: CALL_OW 257
108434: PUSH
108435: LD_INT 17
108437: EQUAL
108438: PUSH
108439: LD_VAR 0 4
108443: PUSH
108444: LD_VAR 0 7
108448: ARRAY
108449: PPUSH
108450: CALL_OW 110
108454: PUSH
108455: LD_INT 71
108457: EQUAL
108458: NOT
108459: AND
108460: IFFALSE 108606
// begin attacking := false ;
108462: LD_ADDR_VAR 0 29
108466: PUSH
108467: LD_INT 0
108469: ST_TO_ADDR
// k := 5 ;
108470: LD_ADDR_VAR 0 9
108474: PUSH
108475: LD_INT 5
108477: ST_TO_ADDR
// if tmp < k then
108478: LD_VAR 0 14
108482: PUSH
108483: LD_VAR 0 9
108487: LESS
108488: IFFALSE 108500
// k := tmp ;
108490: LD_ADDR_VAR 0 9
108494: PUSH
108495: LD_VAR 0 14
108499: ST_TO_ADDR
// for j = 1 to k do
108500: LD_ADDR_VAR 0 8
108504: PUSH
108505: DOUBLE
108506: LD_INT 1
108508: DEC
108509: ST_TO_ADDR
108510: LD_VAR 0 9
108514: PUSH
108515: FOR_TO
108516: IFFALSE 108604
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
108518: LD_VAR 0 14
108522: PUSH
108523: LD_VAR 0 8
108527: ARRAY
108528: PUSH
108529: LD_VAR 0 14
108533: PPUSH
108534: LD_INT 58
108536: PUSH
108537: EMPTY
108538: LIST
108539: PPUSH
108540: CALL_OW 72
108544: IN
108545: NOT
108546: IFFALSE 108602
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108548: LD_VAR 0 4
108552: PUSH
108553: LD_VAR 0 7
108557: ARRAY
108558: PPUSH
108559: LD_VAR 0 14
108563: PUSH
108564: LD_VAR 0 8
108568: ARRAY
108569: PPUSH
108570: CALL_OW 115
// attacking := true ;
108574: LD_ADDR_VAR 0 29
108578: PUSH
108579: LD_INT 1
108581: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
108582: LD_VAR 0 4
108586: PUSH
108587: LD_VAR 0 7
108591: ARRAY
108592: PPUSH
108593: LD_INT 71
108595: PPUSH
108596: CALL_OW 109
// continue ;
108600: GO 108515
// end ; end ;
108602: GO 108515
108604: POP
108605: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
108606: LD_VAR 0 4
108610: PUSH
108611: LD_VAR 0 7
108615: ARRAY
108616: PPUSH
108617: CALL_OW 257
108621: PUSH
108622: LD_INT 8
108624: EQUAL
108625: PUSH
108626: LD_VAR 0 4
108630: PUSH
108631: LD_VAR 0 7
108635: ARRAY
108636: PPUSH
108637: CALL_OW 264
108641: PUSH
108642: LD_INT 28
108644: PUSH
108645: LD_INT 45
108647: PUSH
108648: LD_INT 7
108650: PUSH
108651: LD_INT 47
108653: PUSH
108654: EMPTY
108655: LIST
108656: LIST
108657: LIST
108658: LIST
108659: IN
108660: OR
108661: IFFALSE 108917
// begin attacking := false ;
108663: LD_ADDR_VAR 0 29
108667: PUSH
108668: LD_INT 0
108670: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
108671: LD_VAR 0 14
108675: PUSH
108676: LD_INT 1
108678: ARRAY
108679: PPUSH
108680: CALL_OW 266
108684: PUSH
108685: LD_INT 32
108687: PUSH
108688: LD_INT 31
108690: PUSH
108691: LD_INT 33
108693: PUSH
108694: LD_INT 4
108696: PUSH
108697: LD_INT 5
108699: PUSH
108700: EMPTY
108701: LIST
108702: LIST
108703: LIST
108704: LIST
108705: LIST
108706: IN
108707: IFFALSE 108893
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
108709: LD_ADDR_VAR 0 9
108713: PUSH
108714: LD_VAR 0 14
108718: PUSH
108719: LD_INT 1
108721: ARRAY
108722: PPUSH
108723: CALL_OW 266
108727: PPUSH
108728: LD_VAR 0 14
108732: PUSH
108733: LD_INT 1
108735: ARRAY
108736: PPUSH
108737: CALL_OW 250
108741: PPUSH
108742: LD_VAR 0 14
108746: PUSH
108747: LD_INT 1
108749: ARRAY
108750: PPUSH
108751: CALL_OW 251
108755: PPUSH
108756: LD_VAR 0 14
108760: PUSH
108761: LD_INT 1
108763: ARRAY
108764: PPUSH
108765: CALL_OW 254
108769: PPUSH
108770: LD_VAR 0 14
108774: PUSH
108775: LD_INT 1
108777: ARRAY
108778: PPUSH
108779: CALL_OW 248
108783: PPUSH
108784: LD_INT 0
108786: PPUSH
108787: CALL 64415 0 6
108791: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
108792: LD_ADDR_VAR 0 8
108796: PUSH
108797: LD_VAR 0 4
108801: PUSH
108802: LD_VAR 0 7
108806: ARRAY
108807: PPUSH
108808: LD_VAR 0 9
108812: PPUSH
108813: CALL 83085 0 2
108817: ST_TO_ADDR
// if j then
108818: LD_VAR 0 8
108822: IFFALSE 108891
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
108824: LD_VAR 0 8
108828: PUSH
108829: LD_INT 1
108831: ARRAY
108832: PPUSH
108833: LD_VAR 0 8
108837: PUSH
108838: LD_INT 2
108840: ARRAY
108841: PPUSH
108842: CALL_OW 488
108846: IFFALSE 108891
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
108848: LD_VAR 0 4
108852: PUSH
108853: LD_VAR 0 7
108857: ARRAY
108858: PPUSH
108859: LD_VAR 0 8
108863: PUSH
108864: LD_INT 1
108866: ARRAY
108867: PPUSH
108868: LD_VAR 0 8
108872: PUSH
108873: LD_INT 2
108875: ARRAY
108876: PPUSH
108877: CALL_OW 116
// attacking := true ;
108881: LD_ADDR_VAR 0 29
108885: PUSH
108886: LD_INT 1
108888: ST_TO_ADDR
// continue ;
108889: GO 106264
// end ; end else
108891: GO 108917
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108893: LD_VAR 0 4
108897: PUSH
108898: LD_VAR 0 7
108902: ARRAY
108903: PPUSH
108904: LD_VAR 0 14
108908: PUSH
108909: LD_INT 1
108911: ARRAY
108912: PPUSH
108913: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
108917: LD_VAR 0 4
108921: PUSH
108922: LD_VAR 0 7
108926: ARRAY
108927: PPUSH
108928: CALL_OW 265
108932: PUSH
108933: LD_INT 11
108935: EQUAL
108936: IFFALSE 109214
// begin k := 10 ;
108938: LD_ADDR_VAR 0 9
108942: PUSH
108943: LD_INT 10
108945: ST_TO_ADDR
// x := 0 ;
108946: LD_ADDR_VAR 0 10
108950: PUSH
108951: LD_INT 0
108953: ST_TO_ADDR
// if tmp < k then
108954: LD_VAR 0 14
108958: PUSH
108959: LD_VAR 0 9
108963: LESS
108964: IFFALSE 108976
// k := tmp ;
108966: LD_ADDR_VAR 0 9
108970: PUSH
108971: LD_VAR 0 14
108975: ST_TO_ADDR
// for j = k downto 1 do
108976: LD_ADDR_VAR 0 8
108980: PUSH
108981: DOUBLE
108982: LD_VAR 0 9
108986: INC
108987: ST_TO_ADDR
108988: LD_INT 1
108990: PUSH
108991: FOR_DOWNTO
108992: IFFALSE 109067
// begin if GetType ( tmp [ j ] ) = unit_human then
108994: LD_VAR 0 14
108998: PUSH
108999: LD_VAR 0 8
109003: ARRAY
109004: PPUSH
109005: CALL_OW 247
109009: PUSH
109010: LD_INT 1
109012: EQUAL
109013: IFFALSE 109065
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
109015: LD_VAR 0 4
109019: PUSH
109020: LD_VAR 0 7
109024: ARRAY
109025: PPUSH
109026: LD_VAR 0 14
109030: PUSH
109031: LD_VAR 0 8
109035: ARRAY
109036: PPUSH
109037: CALL 83356 0 2
// x := tmp [ j ] ;
109041: LD_ADDR_VAR 0 10
109045: PUSH
109046: LD_VAR 0 14
109050: PUSH
109051: LD_VAR 0 8
109055: ARRAY
109056: ST_TO_ADDR
// attacking := true ;
109057: LD_ADDR_VAR 0 29
109061: PUSH
109062: LD_INT 1
109064: ST_TO_ADDR
// end ; end ;
109065: GO 108991
109067: POP
109068: POP
// if not x then
109069: LD_VAR 0 10
109073: NOT
109074: IFFALSE 109214
// begin attacking := true ;
109076: LD_ADDR_VAR 0 29
109080: PUSH
109081: LD_INT 1
109083: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
109084: LD_VAR 0 4
109088: PUSH
109089: LD_VAR 0 7
109093: ARRAY
109094: PPUSH
109095: CALL_OW 250
109099: PPUSH
109100: LD_VAR 0 4
109104: PUSH
109105: LD_VAR 0 7
109109: ARRAY
109110: PPUSH
109111: CALL_OW 251
109115: PPUSH
109116: CALL_OW 546
109120: PUSH
109121: LD_INT 2
109123: ARRAY
109124: PUSH
109125: LD_VAR 0 14
109129: PUSH
109130: LD_INT 1
109132: ARRAY
109133: PPUSH
109134: CALL_OW 250
109138: PPUSH
109139: LD_VAR 0 14
109143: PUSH
109144: LD_INT 1
109146: ARRAY
109147: PPUSH
109148: CALL_OW 251
109152: PPUSH
109153: CALL_OW 546
109157: PUSH
109158: LD_INT 2
109160: ARRAY
109161: EQUAL
109162: IFFALSE 109190
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
109164: LD_VAR 0 4
109168: PUSH
109169: LD_VAR 0 7
109173: ARRAY
109174: PPUSH
109175: LD_VAR 0 14
109179: PUSH
109180: LD_INT 1
109182: ARRAY
109183: PPUSH
109184: CALL 83356 0 2
109188: GO 109214
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109190: LD_VAR 0 4
109194: PUSH
109195: LD_VAR 0 7
109199: ARRAY
109200: PPUSH
109201: LD_VAR 0 14
109205: PUSH
109206: LD_INT 1
109208: ARRAY
109209: PPUSH
109210: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
109214: LD_VAR 0 4
109218: PUSH
109219: LD_VAR 0 7
109223: ARRAY
109224: PPUSH
109225: CALL_OW 264
109229: PUSH
109230: LD_INT 29
109232: EQUAL
109233: IFFALSE 109599
// begin if WantsToAttack ( group [ i ] ) in bombed then
109235: LD_VAR 0 4
109239: PUSH
109240: LD_VAR 0 7
109244: ARRAY
109245: PPUSH
109246: CALL_OW 319
109250: PUSH
109251: LD_VAR 0 28
109255: IN
109256: IFFALSE 109260
// continue ;
109258: GO 106264
// k := 8 ;
109260: LD_ADDR_VAR 0 9
109264: PUSH
109265: LD_INT 8
109267: ST_TO_ADDR
// x := 0 ;
109268: LD_ADDR_VAR 0 10
109272: PUSH
109273: LD_INT 0
109275: ST_TO_ADDR
// if tmp < k then
109276: LD_VAR 0 14
109280: PUSH
109281: LD_VAR 0 9
109285: LESS
109286: IFFALSE 109298
// k := tmp ;
109288: LD_ADDR_VAR 0 9
109292: PUSH
109293: LD_VAR 0 14
109297: ST_TO_ADDR
// for j = 1 to k do
109298: LD_ADDR_VAR 0 8
109302: PUSH
109303: DOUBLE
109304: LD_INT 1
109306: DEC
109307: ST_TO_ADDR
109308: LD_VAR 0 9
109312: PUSH
109313: FOR_TO
109314: IFFALSE 109446
// begin if GetType ( tmp [ j ] ) = unit_building then
109316: LD_VAR 0 14
109320: PUSH
109321: LD_VAR 0 8
109325: ARRAY
109326: PPUSH
109327: CALL_OW 247
109331: PUSH
109332: LD_INT 3
109334: EQUAL
109335: IFFALSE 109444
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
109337: LD_VAR 0 14
109341: PUSH
109342: LD_VAR 0 8
109346: ARRAY
109347: PUSH
109348: LD_VAR 0 28
109352: IN
109353: NOT
109354: PUSH
109355: LD_VAR 0 14
109359: PUSH
109360: LD_VAR 0 8
109364: ARRAY
109365: PPUSH
109366: CALL_OW 313
109370: AND
109371: IFFALSE 109444
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109373: LD_VAR 0 4
109377: PUSH
109378: LD_VAR 0 7
109382: ARRAY
109383: PPUSH
109384: LD_VAR 0 14
109388: PUSH
109389: LD_VAR 0 8
109393: ARRAY
109394: PPUSH
109395: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
109399: LD_ADDR_VAR 0 28
109403: PUSH
109404: LD_VAR 0 28
109408: PPUSH
109409: LD_VAR 0 28
109413: PUSH
109414: LD_INT 1
109416: PLUS
109417: PPUSH
109418: LD_VAR 0 14
109422: PUSH
109423: LD_VAR 0 8
109427: ARRAY
109428: PPUSH
109429: CALL_OW 1
109433: ST_TO_ADDR
// attacking := true ;
109434: LD_ADDR_VAR 0 29
109438: PUSH
109439: LD_INT 1
109441: ST_TO_ADDR
// break ;
109442: GO 109446
// end ; end ;
109444: GO 109313
109446: POP
109447: POP
// if not attacking and f_attack_depot then
109448: LD_VAR 0 29
109452: NOT
109453: PUSH
109454: LD_VAR 0 25
109458: AND
109459: IFFALSE 109554
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109461: LD_ADDR_VAR 0 13
109465: PUSH
109466: LD_VAR 0 14
109470: PPUSH
109471: LD_INT 2
109473: PUSH
109474: LD_INT 30
109476: PUSH
109477: LD_INT 0
109479: PUSH
109480: EMPTY
109481: LIST
109482: LIST
109483: PUSH
109484: LD_INT 30
109486: PUSH
109487: LD_INT 1
109489: PUSH
109490: EMPTY
109491: LIST
109492: LIST
109493: PUSH
109494: EMPTY
109495: LIST
109496: LIST
109497: LIST
109498: PPUSH
109499: CALL_OW 72
109503: ST_TO_ADDR
// if z then
109504: LD_VAR 0 13
109508: IFFALSE 109554
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
109510: LD_VAR 0 4
109514: PUSH
109515: LD_VAR 0 7
109519: ARRAY
109520: PPUSH
109521: LD_VAR 0 13
109525: PPUSH
109526: LD_VAR 0 4
109530: PUSH
109531: LD_VAR 0 7
109535: ARRAY
109536: PPUSH
109537: CALL_OW 74
109541: PPUSH
109542: CALL_OW 115
// attacking := true ;
109546: LD_ADDR_VAR 0 29
109550: PUSH
109551: LD_INT 1
109553: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
109554: LD_VAR 0 4
109558: PUSH
109559: LD_VAR 0 7
109563: ARRAY
109564: PPUSH
109565: CALL_OW 256
109569: PUSH
109570: LD_INT 500
109572: LESS
109573: IFFALSE 109599
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109575: LD_VAR 0 4
109579: PUSH
109580: LD_VAR 0 7
109584: ARRAY
109585: PPUSH
109586: LD_VAR 0 14
109590: PUSH
109591: LD_INT 1
109593: ARRAY
109594: PPUSH
109595: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
109599: LD_VAR 0 4
109603: PUSH
109604: LD_VAR 0 7
109608: ARRAY
109609: PPUSH
109610: CALL_OW 264
109614: PUSH
109615: LD_INT 49
109617: EQUAL
109618: IFFALSE 109739
// begin if not HasTask ( group [ i ] ) then
109620: LD_VAR 0 4
109624: PUSH
109625: LD_VAR 0 7
109629: ARRAY
109630: PPUSH
109631: CALL_OW 314
109635: NOT
109636: IFFALSE 109739
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
109638: LD_ADDR_VAR 0 9
109642: PUSH
109643: LD_INT 81
109645: PUSH
109646: LD_VAR 0 4
109650: PUSH
109651: LD_VAR 0 7
109655: ARRAY
109656: PPUSH
109657: CALL_OW 255
109661: PUSH
109662: EMPTY
109663: LIST
109664: LIST
109665: PPUSH
109666: CALL_OW 69
109670: PPUSH
109671: LD_VAR 0 4
109675: PUSH
109676: LD_VAR 0 7
109680: ARRAY
109681: PPUSH
109682: CALL_OW 74
109686: ST_TO_ADDR
// if k then
109687: LD_VAR 0 9
109691: IFFALSE 109739
// if GetDistUnits ( group [ i ] , k ) > 10 then
109693: LD_VAR 0 4
109697: PUSH
109698: LD_VAR 0 7
109702: ARRAY
109703: PPUSH
109704: LD_VAR 0 9
109708: PPUSH
109709: CALL_OW 296
109713: PUSH
109714: LD_INT 10
109716: GREATER
109717: IFFALSE 109739
// ComMoveUnit ( group [ i ] , k ) ;
109719: LD_VAR 0 4
109723: PUSH
109724: LD_VAR 0 7
109728: ARRAY
109729: PPUSH
109730: LD_VAR 0 9
109734: PPUSH
109735: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
109739: LD_VAR 0 4
109743: PUSH
109744: LD_VAR 0 7
109748: ARRAY
109749: PPUSH
109750: CALL_OW 256
109754: PUSH
109755: LD_INT 250
109757: LESS
109758: PUSH
109759: LD_VAR 0 4
109763: PUSH
109764: LD_VAR 0 7
109768: ARRAY
109769: PUSH
109770: LD_INT 21
109772: PUSH
109773: LD_INT 2
109775: PUSH
109776: EMPTY
109777: LIST
109778: LIST
109779: PUSH
109780: LD_INT 23
109782: PUSH
109783: LD_INT 2
109785: PUSH
109786: EMPTY
109787: LIST
109788: LIST
109789: PUSH
109790: EMPTY
109791: LIST
109792: LIST
109793: PPUSH
109794: CALL_OW 69
109798: IN
109799: AND
109800: IFFALSE 109925
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
109802: LD_ADDR_VAR 0 9
109806: PUSH
109807: LD_OWVAR 3
109811: PUSH
109812: LD_VAR 0 4
109816: PUSH
109817: LD_VAR 0 7
109821: ARRAY
109822: DIFF
109823: PPUSH
109824: LD_VAR 0 4
109828: PUSH
109829: LD_VAR 0 7
109833: ARRAY
109834: PPUSH
109835: CALL_OW 74
109839: ST_TO_ADDR
// if not k then
109840: LD_VAR 0 9
109844: NOT
109845: IFFALSE 109849
// continue ;
109847: GO 106264
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
109849: LD_VAR 0 9
109853: PUSH
109854: LD_INT 81
109856: PUSH
109857: LD_VAR 0 4
109861: PUSH
109862: LD_VAR 0 7
109866: ARRAY
109867: PPUSH
109868: CALL_OW 255
109872: PUSH
109873: EMPTY
109874: LIST
109875: LIST
109876: PPUSH
109877: CALL_OW 69
109881: IN
109882: PUSH
109883: LD_VAR 0 9
109887: PPUSH
109888: LD_VAR 0 4
109892: PUSH
109893: LD_VAR 0 7
109897: ARRAY
109898: PPUSH
109899: CALL_OW 296
109903: PUSH
109904: LD_INT 5
109906: LESS
109907: AND
109908: IFFALSE 109925
// ComAutodestruct ( group [ i ] ) ;
109910: LD_VAR 0 4
109914: PUSH
109915: LD_VAR 0 7
109919: ARRAY
109920: PPUSH
109921: CALL 83254 0 1
// end ; if f_attack_depot then
109925: LD_VAR 0 25
109929: IFFALSE 110041
// begin k := 6 ;
109931: LD_ADDR_VAR 0 9
109935: PUSH
109936: LD_INT 6
109938: ST_TO_ADDR
// if tmp < k then
109939: LD_VAR 0 14
109943: PUSH
109944: LD_VAR 0 9
109948: LESS
109949: IFFALSE 109961
// k := tmp ;
109951: LD_ADDR_VAR 0 9
109955: PUSH
109956: LD_VAR 0 14
109960: ST_TO_ADDR
// for j = 1 to k do
109961: LD_ADDR_VAR 0 8
109965: PUSH
109966: DOUBLE
109967: LD_INT 1
109969: DEC
109970: ST_TO_ADDR
109971: LD_VAR 0 9
109975: PUSH
109976: FOR_TO
109977: IFFALSE 110039
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
109979: LD_VAR 0 8
109983: PPUSH
109984: CALL_OW 266
109988: PUSH
109989: LD_INT 0
109991: PUSH
109992: LD_INT 1
109994: PUSH
109995: EMPTY
109996: LIST
109997: LIST
109998: IN
109999: IFFALSE 110037
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110001: LD_VAR 0 4
110005: PUSH
110006: LD_VAR 0 7
110010: ARRAY
110011: PPUSH
110012: LD_VAR 0 14
110016: PUSH
110017: LD_VAR 0 8
110021: ARRAY
110022: PPUSH
110023: CALL_OW 115
// attacking := true ;
110027: LD_ADDR_VAR 0 29
110031: PUSH
110032: LD_INT 1
110034: ST_TO_ADDR
// break ;
110035: GO 110039
// end ;
110037: GO 109976
110039: POP
110040: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
110041: LD_VAR 0 4
110045: PUSH
110046: LD_VAR 0 7
110050: ARRAY
110051: PPUSH
110052: CALL_OW 302
110056: PUSH
110057: LD_VAR 0 29
110061: NOT
110062: AND
110063: IFFALSE 110385
// begin if GetTag ( group [ i ] ) = 71 then
110065: LD_VAR 0 4
110069: PUSH
110070: LD_VAR 0 7
110074: ARRAY
110075: PPUSH
110076: CALL_OW 110
110080: PUSH
110081: LD_INT 71
110083: EQUAL
110084: IFFALSE 110125
// begin if HasTask ( group [ i ] ) then
110086: LD_VAR 0 4
110090: PUSH
110091: LD_VAR 0 7
110095: ARRAY
110096: PPUSH
110097: CALL_OW 314
110101: IFFALSE 110107
// continue else
110103: GO 106264
110105: GO 110125
// SetTag ( group [ i ] , 0 ) ;
110107: LD_VAR 0 4
110111: PUSH
110112: LD_VAR 0 7
110116: ARRAY
110117: PPUSH
110118: LD_INT 0
110120: PPUSH
110121: CALL_OW 109
// end ; k := 8 ;
110125: LD_ADDR_VAR 0 9
110129: PUSH
110130: LD_INT 8
110132: ST_TO_ADDR
// x := 0 ;
110133: LD_ADDR_VAR 0 10
110137: PUSH
110138: LD_INT 0
110140: ST_TO_ADDR
// if tmp < k then
110141: LD_VAR 0 14
110145: PUSH
110146: LD_VAR 0 9
110150: LESS
110151: IFFALSE 110163
// k := tmp ;
110153: LD_ADDR_VAR 0 9
110157: PUSH
110158: LD_VAR 0 14
110162: ST_TO_ADDR
// for j = 1 to k do
110163: LD_ADDR_VAR 0 8
110167: PUSH
110168: DOUBLE
110169: LD_INT 1
110171: DEC
110172: ST_TO_ADDR
110173: LD_VAR 0 9
110177: PUSH
110178: FOR_TO
110179: IFFALSE 110277
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
110181: LD_VAR 0 14
110185: PUSH
110186: LD_VAR 0 8
110190: ARRAY
110191: PPUSH
110192: CALL_OW 247
110196: PUSH
110197: LD_INT 1
110199: EQUAL
110200: PUSH
110201: LD_VAR 0 14
110205: PUSH
110206: LD_VAR 0 8
110210: ARRAY
110211: PPUSH
110212: CALL_OW 256
110216: PUSH
110217: LD_INT 250
110219: LESS
110220: PUSH
110221: LD_VAR 0 20
110225: AND
110226: PUSH
110227: LD_VAR 0 20
110231: NOT
110232: PUSH
110233: LD_VAR 0 14
110237: PUSH
110238: LD_VAR 0 8
110242: ARRAY
110243: PPUSH
110244: CALL_OW 256
110248: PUSH
110249: LD_INT 250
110251: GREATEREQUAL
110252: AND
110253: OR
110254: AND
110255: IFFALSE 110275
// begin x := tmp [ j ] ;
110257: LD_ADDR_VAR 0 10
110261: PUSH
110262: LD_VAR 0 14
110266: PUSH
110267: LD_VAR 0 8
110271: ARRAY
110272: ST_TO_ADDR
// break ;
110273: GO 110277
// end ;
110275: GO 110178
110277: POP
110278: POP
// if x then
110279: LD_VAR 0 10
110283: IFFALSE 110307
// ComAttackUnit ( group [ i ] , x ) else
110285: LD_VAR 0 4
110289: PUSH
110290: LD_VAR 0 7
110294: ARRAY
110295: PPUSH
110296: LD_VAR 0 10
110300: PPUSH
110301: CALL_OW 115
110305: GO 110331
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110307: LD_VAR 0 4
110311: PUSH
110312: LD_VAR 0 7
110316: ARRAY
110317: PPUSH
110318: LD_VAR 0 14
110322: PUSH
110323: LD_INT 1
110325: ARRAY
110326: PPUSH
110327: CALL_OW 115
// if not HasTask ( group [ i ] ) then
110331: LD_VAR 0 4
110335: PUSH
110336: LD_VAR 0 7
110340: ARRAY
110341: PPUSH
110342: CALL_OW 314
110346: NOT
110347: IFFALSE 110385
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
110349: LD_VAR 0 4
110353: PUSH
110354: LD_VAR 0 7
110358: ARRAY
110359: PPUSH
110360: LD_VAR 0 14
110364: PPUSH
110365: LD_VAR 0 4
110369: PUSH
110370: LD_VAR 0 7
110374: ARRAY
110375: PPUSH
110376: CALL_OW 74
110380: PPUSH
110381: CALL_OW 115
// end ; end ; end ;
110385: GO 106264
110387: POP
110388: POP
// wait ( 0 0$2 ) ;
110389: LD_INT 70
110391: PPUSH
110392: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
110396: LD_VAR 0 4
110400: NOT
110401: PUSH
110402: LD_VAR 0 4
110406: PUSH
110407: EMPTY
110408: EQUAL
110409: OR
110410: PUSH
110411: LD_INT 81
110413: PUSH
110414: LD_VAR 0 35
110418: PUSH
110419: EMPTY
110420: LIST
110421: LIST
110422: PPUSH
110423: CALL_OW 69
110427: NOT
110428: OR
110429: IFFALSE 106249
// end ;
110431: LD_VAR 0 2
110435: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
110436: LD_INT 0
110438: PPUSH
110439: PPUSH
110440: PPUSH
110441: PPUSH
110442: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
110443: LD_VAR 0 1
110447: NOT
110448: PUSH
110449: LD_EXP 90
110453: PUSH
110454: LD_VAR 0 1
110458: ARRAY
110459: NOT
110460: OR
110461: PUSH
110462: LD_VAR 0 2
110466: NOT
110467: OR
110468: PUSH
110469: LD_VAR 0 3
110473: NOT
110474: OR
110475: IFFALSE 110479
// exit ;
110477: GO 110992
// side := mc_sides [ base ] ;
110479: LD_ADDR_VAR 0 6
110483: PUSH
110484: LD_EXP 116
110488: PUSH
110489: LD_VAR 0 1
110493: ARRAY
110494: ST_TO_ADDR
// if not side then
110495: LD_VAR 0 6
110499: NOT
110500: IFFALSE 110504
// exit ;
110502: GO 110992
// for i in solds do
110504: LD_ADDR_VAR 0 7
110508: PUSH
110509: LD_VAR 0 2
110513: PUSH
110514: FOR_IN
110515: IFFALSE 110576
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
110517: LD_VAR 0 7
110521: PPUSH
110522: CALL_OW 310
110526: PPUSH
110527: CALL_OW 266
110531: PUSH
110532: LD_INT 32
110534: PUSH
110535: LD_INT 31
110537: PUSH
110538: EMPTY
110539: LIST
110540: LIST
110541: IN
110542: IFFALSE 110562
// solds := solds diff i else
110544: LD_ADDR_VAR 0 2
110548: PUSH
110549: LD_VAR 0 2
110553: PUSH
110554: LD_VAR 0 7
110558: DIFF
110559: ST_TO_ADDR
110560: GO 110574
// SetTag ( i , 18 ) ;
110562: LD_VAR 0 7
110566: PPUSH
110567: LD_INT 18
110569: PPUSH
110570: CALL_OW 109
110574: GO 110514
110576: POP
110577: POP
// if not solds then
110578: LD_VAR 0 2
110582: NOT
110583: IFFALSE 110587
// exit ;
110585: GO 110992
// repeat wait ( 0 0$2 ) ;
110587: LD_INT 70
110589: PPUSH
110590: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
110594: LD_ADDR_VAR 0 5
110598: PUSH
110599: LD_VAR 0 6
110603: PPUSH
110604: LD_VAR 0 3
110608: PPUSH
110609: CALL 52636 0 2
110613: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110614: LD_EXP 90
110618: PUSH
110619: LD_VAR 0 1
110623: ARRAY
110624: NOT
110625: PUSH
110626: LD_EXP 90
110630: PUSH
110631: LD_VAR 0 1
110635: ARRAY
110636: PUSH
110637: EMPTY
110638: EQUAL
110639: OR
110640: IFFALSE 110677
// begin for i in solds do
110642: LD_ADDR_VAR 0 7
110646: PUSH
110647: LD_VAR 0 2
110651: PUSH
110652: FOR_IN
110653: IFFALSE 110666
// ComStop ( i ) ;
110655: LD_VAR 0 7
110659: PPUSH
110660: CALL_OW 141
110664: GO 110652
110666: POP
110667: POP
// solds := [ ] ;
110668: LD_ADDR_VAR 0 2
110672: PUSH
110673: EMPTY
110674: ST_TO_ADDR
// exit ;
110675: GO 110992
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
110677: LD_VAR 0 5
110681: NOT
110682: PUSH
110683: LD_VAR 0 5
110687: PUSH
110688: LD_INT 3
110690: GREATER
110691: OR
110692: PUSH
110693: LD_EXP 112
110697: PUSH
110698: LD_VAR 0 1
110702: ARRAY
110703: OR
110704: IFFALSE 110745
// begin for i in solds do
110706: LD_ADDR_VAR 0 7
110710: PUSH
110711: LD_VAR 0 2
110715: PUSH
110716: FOR_IN
110717: IFFALSE 110741
// if HasTask ( i ) then
110719: LD_VAR 0 7
110723: PPUSH
110724: CALL_OW 314
110728: IFFALSE 110739
// ComStop ( i ) ;
110730: LD_VAR 0 7
110734: PPUSH
110735: CALL_OW 141
110739: GO 110716
110741: POP
110742: POP
// break ;
110743: GO 110980
// end ; for i in solds do
110745: LD_ADDR_VAR 0 7
110749: PUSH
110750: LD_VAR 0 2
110754: PUSH
110755: FOR_IN
110756: IFFALSE 110972
// begin if IsInUnit ( i ) then
110758: LD_VAR 0 7
110762: PPUSH
110763: CALL_OW 310
110767: IFFALSE 110778
// ComExitBuilding ( i ) ;
110769: LD_VAR 0 7
110773: PPUSH
110774: CALL_OW 122
// if GetLives ( i ) > 333 then
110778: LD_VAR 0 7
110782: PPUSH
110783: CALL_OW 256
110787: PUSH
110788: LD_INT 333
110790: GREATER
110791: IFFALSE 110819
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
110793: LD_VAR 0 7
110797: PPUSH
110798: LD_VAR 0 5
110802: PPUSH
110803: LD_VAR 0 7
110807: PPUSH
110808: CALL_OW 74
110812: PPUSH
110813: CALL_OW 115
110817: GO 110970
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
110819: LD_ADDR_VAR 0 8
110823: PUSH
110824: LD_EXP 90
110828: PUSH
110829: LD_VAR 0 1
110833: ARRAY
110834: PPUSH
110835: LD_INT 2
110837: PUSH
110838: LD_INT 30
110840: PUSH
110841: LD_INT 0
110843: PUSH
110844: EMPTY
110845: LIST
110846: LIST
110847: PUSH
110848: LD_INT 30
110850: PUSH
110851: LD_INT 1
110853: PUSH
110854: EMPTY
110855: LIST
110856: LIST
110857: PUSH
110858: LD_INT 30
110860: PUSH
110861: LD_INT 6
110863: PUSH
110864: EMPTY
110865: LIST
110866: LIST
110867: PUSH
110868: EMPTY
110869: LIST
110870: LIST
110871: LIST
110872: LIST
110873: PPUSH
110874: CALL_OW 72
110878: PPUSH
110879: LD_VAR 0 7
110883: PPUSH
110884: CALL_OW 74
110888: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
110889: LD_VAR 0 7
110893: PPUSH
110894: LD_VAR 0 8
110898: PPUSH
110899: CALL_OW 250
110903: PPUSH
110904: LD_INT 3
110906: PPUSH
110907: LD_INT 5
110909: PPUSH
110910: CALL_OW 272
110914: PPUSH
110915: LD_VAR 0 8
110919: PPUSH
110920: CALL_OW 251
110924: PPUSH
110925: LD_INT 3
110927: PPUSH
110928: LD_INT 5
110930: PPUSH
110931: CALL_OW 273
110935: PPUSH
110936: CALL_OW 111
// SetTag ( i , 0 ) ;
110940: LD_VAR 0 7
110944: PPUSH
110945: LD_INT 0
110947: PPUSH
110948: CALL_OW 109
// solds := solds diff i ;
110952: LD_ADDR_VAR 0 2
110956: PUSH
110957: LD_VAR 0 2
110961: PUSH
110962: LD_VAR 0 7
110966: DIFF
110967: ST_TO_ADDR
// continue ;
110968: GO 110755
// end ; end ;
110970: GO 110755
110972: POP
110973: POP
// until solds ;
110974: LD_VAR 0 2
110978: IFFALSE 110587
// MC_Reset ( base , 18 ) ;
110980: LD_VAR 0 1
110984: PPUSH
110985: LD_INT 18
110987: PPUSH
110988: CALL 24856 0 2
// end ;
110992: LD_VAR 0 4
110996: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
110997: LD_INT 0
110999: PPUSH
111000: PPUSH
111001: PPUSH
111002: PPUSH
111003: PPUSH
111004: PPUSH
111005: PPUSH
111006: PPUSH
111007: PPUSH
111008: PPUSH
111009: PPUSH
111010: PPUSH
111011: PPUSH
111012: PPUSH
111013: PPUSH
111014: PPUSH
111015: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
111016: LD_ADDR_VAR 0 13
111020: PUSH
111021: LD_EXP 90
111025: PUSH
111026: LD_VAR 0 1
111030: ARRAY
111031: PPUSH
111032: LD_INT 25
111034: PUSH
111035: LD_INT 3
111037: PUSH
111038: EMPTY
111039: LIST
111040: LIST
111041: PPUSH
111042: CALL_OW 72
111046: ST_TO_ADDR
// if mc_remote_driver [ base ] then
111047: LD_EXP 130
111051: PUSH
111052: LD_VAR 0 1
111056: ARRAY
111057: IFFALSE 111081
// mechs := mechs diff mc_remote_driver [ base ] ;
111059: LD_ADDR_VAR 0 13
111063: PUSH
111064: LD_VAR 0 13
111068: PUSH
111069: LD_EXP 130
111073: PUSH
111074: LD_VAR 0 1
111078: ARRAY
111079: DIFF
111080: ST_TO_ADDR
// for i in mechs do
111081: LD_ADDR_VAR 0 5
111085: PUSH
111086: LD_VAR 0 13
111090: PUSH
111091: FOR_IN
111092: IFFALSE 111127
// if GetTag ( i ) > 0 then
111094: LD_VAR 0 5
111098: PPUSH
111099: CALL_OW 110
111103: PUSH
111104: LD_INT 0
111106: GREATER
111107: IFFALSE 111125
// mechs := mechs diff i ;
111109: LD_ADDR_VAR 0 13
111113: PUSH
111114: LD_VAR 0 13
111118: PUSH
111119: LD_VAR 0 5
111123: DIFF
111124: ST_TO_ADDR
111125: GO 111091
111127: POP
111128: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111129: LD_ADDR_VAR 0 9
111133: PUSH
111134: LD_EXP 90
111138: PUSH
111139: LD_VAR 0 1
111143: ARRAY
111144: PPUSH
111145: LD_INT 2
111147: PUSH
111148: LD_INT 25
111150: PUSH
111151: LD_INT 1
111153: PUSH
111154: EMPTY
111155: LIST
111156: LIST
111157: PUSH
111158: LD_INT 25
111160: PUSH
111161: LD_INT 5
111163: PUSH
111164: EMPTY
111165: LIST
111166: LIST
111167: PUSH
111168: LD_INT 25
111170: PUSH
111171: LD_INT 8
111173: PUSH
111174: EMPTY
111175: LIST
111176: LIST
111177: PUSH
111178: LD_INT 25
111180: PUSH
111181: LD_INT 9
111183: PUSH
111184: EMPTY
111185: LIST
111186: LIST
111187: PUSH
111188: EMPTY
111189: LIST
111190: LIST
111191: LIST
111192: LIST
111193: LIST
111194: PPUSH
111195: CALL_OW 72
111199: ST_TO_ADDR
// if not defenders and not solds then
111200: LD_VAR 0 2
111204: NOT
111205: PUSH
111206: LD_VAR 0 9
111210: NOT
111211: AND
111212: IFFALSE 111216
// exit ;
111214: GO 112906
// depot_under_attack := false ;
111216: LD_ADDR_VAR 0 17
111220: PUSH
111221: LD_INT 0
111223: ST_TO_ADDR
// sold_defenders := [ ] ;
111224: LD_ADDR_VAR 0 18
111228: PUSH
111229: EMPTY
111230: ST_TO_ADDR
// if mechs then
111231: LD_VAR 0 13
111235: IFFALSE 111388
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
111237: LD_ADDR_VAR 0 5
111241: PUSH
111242: LD_VAR 0 2
111246: PPUSH
111247: LD_INT 21
111249: PUSH
111250: LD_INT 2
111252: PUSH
111253: EMPTY
111254: LIST
111255: LIST
111256: PPUSH
111257: CALL_OW 72
111261: PUSH
111262: FOR_IN
111263: IFFALSE 111386
// begin if GetTag ( i ) <> 20 then
111265: LD_VAR 0 5
111269: PPUSH
111270: CALL_OW 110
111274: PUSH
111275: LD_INT 20
111277: NONEQUAL
111278: IFFALSE 111292
// SetTag ( i , 20 ) ;
111280: LD_VAR 0 5
111284: PPUSH
111285: LD_INT 20
111287: PPUSH
111288: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
111292: LD_VAR 0 5
111296: PPUSH
111297: CALL_OW 263
111301: PUSH
111302: LD_INT 1
111304: EQUAL
111305: PUSH
111306: LD_VAR 0 5
111310: PPUSH
111311: CALL_OW 311
111315: NOT
111316: AND
111317: IFFALSE 111384
// begin un := mechs [ 1 ] ;
111319: LD_ADDR_VAR 0 11
111323: PUSH
111324: LD_VAR 0 13
111328: PUSH
111329: LD_INT 1
111331: ARRAY
111332: ST_TO_ADDR
// ComExit ( un ) ;
111333: LD_VAR 0 11
111337: PPUSH
111338: CALL 87599 0 1
// AddComEnterUnit ( un , i ) ;
111342: LD_VAR 0 11
111346: PPUSH
111347: LD_VAR 0 5
111351: PPUSH
111352: CALL_OW 180
// SetTag ( un , 19 ) ;
111356: LD_VAR 0 11
111360: PPUSH
111361: LD_INT 19
111363: PPUSH
111364: CALL_OW 109
// mechs := mechs diff un ;
111368: LD_ADDR_VAR 0 13
111372: PUSH
111373: LD_VAR 0 13
111377: PUSH
111378: LD_VAR 0 11
111382: DIFF
111383: ST_TO_ADDR
// end ; end ;
111384: GO 111262
111386: POP
111387: POP
// if solds then
111388: LD_VAR 0 9
111392: IFFALSE 111451
// for i in solds do
111394: LD_ADDR_VAR 0 5
111398: PUSH
111399: LD_VAR 0 9
111403: PUSH
111404: FOR_IN
111405: IFFALSE 111449
// if not GetTag ( i ) then
111407: LD_VAR 0 5
111411: PPUSH
111412: CALL_OW 110
111416: NOT
111417: IFFALSE 111447
// begin defenders := defenders union i ;
111419: LD_ADDR_VAR 0 2
111423: PUSH
111424: LD_VAR 0 2
111428: PUSH
111429: LD_VAR 0 5
111433: UNION
111434: ST_TO_ADDR
// SetTag ( i , 18 ) ;
111435: LD_VAR 0 5
111439: PPUSH
111440: LD_INT 18
111442: PPUSH
111443: CALL_OW 109
// end ;
111447: GO 111404
111449: POP
111450: POP
// repeat wait ( 0 0$2 ) ;
111451: LD_INT 70
111453: PPUSH
111454: CALL_OW 67
// enemy := mc_scan [ base ] ;
111458: LD_ADDR_VAR 0 3
111462: PUSH
111463: LD_EXP 113
111467: PUSH
111468: LD_VAR 0 1
111472: ARRAY
111473: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111474: LD_EXP 90
111478: PUSH
111479: LD_VAR 0 1
111483: ARRAY
111484: NOT
111485: PUSH
111486: LD_EXP 90
111490: PUSH
111491: LD_VAR 0 1
111495: ARRAY
111496: PUSH
111497: EMPTY
111498: EQUAL
111499: OR
111500: IFFALSE 111537
// begin for i in defenders do
111502: LD_ADDR_VAR 0 5
111506: PUSH
111507: LD_VAR 0 2
111511: PUSH
111512: FOR_IN
111513: IFFALSE 111526
// ComStop ( i ) ;
111515: LD_VAR 0 5
111519: PPUSH
111520: CALL_OW 141
111524: GO 111512
111526: POP
111527: POP
// defenders := [ ] ;
111528: LD_ADDR_VAR 0 2
111532: PUSH
111533: EMPTY
111534: ST_TO_ADDR
// exit ;
111535: GO 112906
// end ; for i in defenders do
111537: LD_ADDR_VAR 0 5
111541: PUSH
111542: LD_VAR 0 2
111546: PUSH
111547: FOR_IN
111548: IFFALSE 112366
// begin e := NearestUnitToUnit ( enemy , i ) ;
111550: LD_ADDR_VAR 0 14
111554: PUSH
111555: LD_VAR 0 3
111559: PPUSH
111560: LD_VAR 0 5
111564: PPUSH
111565: CALL_OW 74
111569: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111570: LD_ADDR_VAR 0 8
111574: PUSH
111575: LD_EXP 90
111579: PUSH
111580: LD_VAR 0 1
111584: ARRAY
111585: PPUSH
111586: LD_INT 2
111588: PUSH
111589: LD_INT 30
111591: PUSH
111592: LD_INT 0
111594: PUSH
111595: EMPTY
111596: LIST
111597: LIST
111598: PUSH
111599: LD_INT 30
111601: PUSH
111602: LD_INT 1
111604: PUSH
111605: EMPTY
111606: LIST
111607: LIST
111608: PUSH
111609: EMPTY
111610: LIST
111611: LIST
111612: LIST
111613: PPUSH
111614: CALL_OW 72
111618: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
111619: LD_ADDR_VAR 0 17
111623: PUSH
111624: LD_VAR 0 8
111628: NOT
111629: PUSH
111630: LD_VAR 0 8
111634: PPUSH
111635: LD_INT 3
111637: PUSH
111638: LD_INT 24
111640: PUSH
111641: LD_INT 600
111643: PUSH
111644: EMPTY
111645: LIST
111646: LIST
111647: PUSH
111648: EMPTY
111649: LIST
111650: LIST
111651: PPUSH
111652: CALL_OW 72
111656: OR
111657: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
111658: LD_VAR 0 5
111662: PPUSH
111663: CALL_OW 247
111667: PUSH
111668: LD_INT 2
111670: DOUBLE
111671: EQUAL
111672: IFTRUE 111676
111674: GO 112072
111676: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
111677: LD_VAR 0 5
111681: PPUSH
111682: CALL_OW 256
111686: PUSH
111687: LD_INT 650
111689: GREATER
111690: PUSH
111691: LD_VAR 0 5
111695: PPUSH
111696: LD_VAR 0 14
111700: PPUSH
111701: CALL_OW 296
111705: PUSH
111706: LD_INT 40
111708: LESS
111709: PUSH
111710: LD_VAR 0 14
111714: PPUSH
111715: LD_EXP 115
111719: PUSH
111720: LD_VAR 0 1
111724: ARRAY
111725: PPUSH
111726: CALL_OW 308
111730: OR
111731: AND
111732: IFFALSE 111854
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
111734: LD_VAR 0 5
111738: PPUSH
111739: CALL_OW 262
111743: PUSH
111744: LD_INT 1
111746: EQUAL
111747: PUSH
111748: LD_VAR 0 5
111752: PPUSH
111753: CALL_OW 261
111757: PUSH
111758: LD_INT 30
111760: LESS
111761: AND
111762: PUSH
111763: LD_VAR 0 8
111767: AND
111768: IFFALSE 111838
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
111770: LD_VAR 0 5
111774: PPUSH
111775: LD_VAR 0 8
111779: PPUSH
111780: LD_VAR 0 5
111784: PPUSH
111785: CALL_OW 74
111789: PPUSH
111790: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
111794: LD_VAR 0 5
111798: PPUSH
111799: LD_VAR 0 8
111803: PPUSH
111804: LD_VAR 0 5
111808: PPUSH
111809: CALL_OW 74
111813: PPUSH
111814: CALL_OW 296
111818: PUSH
111819: LD_INT 6
111821: LESS
111822: IFFALSE 111836
// SetFuel ( i , 100 ) ;
111824: LD_VAR 0 5
111828: PPUSH
111829: LD_INT 100
111831: PPUSH
111832: CALL_OW 240
// end else
111836: GO 111852
// ComAttackUnit ( i , e ) ;
111838: LD_VAR 0 5
111842: PPUSH
111843: LD_VAR 0 14
111847: PPUSH
111848: CALL_OW 115
// end else
111852: GO 111955
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
111854: LD_VAR 0 14
111858: PPUSH
111859: LD_EXP 115
111863: PUSH
111864: LD_VAR 0 1
111868: ARRAY
111869: PPUSH
111870: CALL_OW 308
111874: NOT
111875: PUSH
111876: LD_VAR 0 5
111880: PPUSH
111881: LD_VAR 0 14
111885: PPUSH
111886: CALL_OW 296
111890: PUSH
111891: LD_INT 40
111893: GREATEREQUAL
111894: AND
111895: PUSH
111896: LD_VAR 0 5
111900: PPUSH
111901: CALL_OW 256
111905: PUSH
111906: LD_INT 650
111908: LESSEQUAL
111909: OR
111910: PUSH
111911: LD_VAR 0 5
111915: PPUSH
111916: LD_EXP 114
111920: PUSH
111921: LD_VAR 0 1
111925: ARRAY
111926: PPUSH
111927: CALL_OW 308
111931: NOT
111932: AND
111933: IFFALSE 111955
// ComMoveToArea ( i , mc_parking [ base ] ) ;
111935: LD_VAR 0 5
111939: PPUSH
111940: LD_EXP 114
111944: PUSH
111945: LD_VAR 0 1
111949: ARRAY
111950: PPUSH
111951: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
111955: LD_VAR 0 5
111959: PPUSH
111960: CALL_OW 256
111964: PUSH
111965: LD_INT 998
111967: LESS
111968: PUSH
111969: LD_VAR 0 5
111973: PPUSH
111974: CALL_OW 263
111978: PUSH
111979: LD_INT 1
111981: EQUAL
111982: AND
111983: PUSH
111984: LD_VAR 0 5
111988: PPUSH
111989: CALL_OW 311
111993: AND
111994: PUSH
111995: LD_VAR 0 5
111999: PPUSH
112000: LD_EXP 114
112004: PUSH
112005: LD_VAR 0 1
112009: ARRAY
112010: PPUSH
112011: CALL_OW 308
112015: AND
112016: IFFALSE 112070
// begin mech := IsDrivenBy ( i ) ;
112018: LD_ADDR_VAR 0 10
112022: PUSH
112023: LD_VAR 0 5
112027: PPUSH
112028: CALL_OW 311
112032: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
112033: LD_VAR 0 10
112037: PPUSH
112038: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
112042: LD_VAR 0 10
112046: PPUSH
112047: LD_VAR 0 5
112051: PPUSH
112052: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
112056: LD_VAR 0 10
112060: PPUSH
112061: LD_VAR 0 5
112065: PPUSH
112066: CALL_OW 180
// end ; end ; unit_human :
112070: GO 112337
112072: LD_INT 1
112074: DOUBLE
112075: EQUAL
112076: IFTRUE 112080
112078: GO 112336
112080: POP
// begin b := IsInUnit ( i ) ;
112081: LD_ADDR_VAR 0 19
112085: PUSH
112086: LD_VAR 0 5
112090: PPUSH
112091: CALL_OW 310
112095: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
112096: LD_ADDR_VAR 0 20
112100: PUSH
112101: LD_VAR 0 19
112105: NOT
112106: PUSH
112107: LD_VAR 0 19
112111: PPUSH
112112: CALL_OW 266
112116: PUSH
112117: LD_INT 32
112119: PUSH
112120: LD_INT 31
112122: PUSH
112123: EMPTY
112124: LIST
112125: LIST
112126: IN
112127: OR
112128: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
112129: LD_VAR 0 17
112133: PUSH
112134: LD_VAR 0 2
112138: PPUSH
112139: LD_INT 21
112141: PUSH
112142: LD_INT 2
112144: PUSH
112145: EMPTY
112146: LIST
112147: LIST
112148: PPUSH
112149: CALL_OW 72
112153: PUSH
112154: LD_INT 1
112156: LESSEQUAL
112157: OR
112158: PUSH
112159: LD_VAR 0 20
112163: AND
112164: PUSH
112165: LD_VAR 0 5
112169: PUSH
112170: LD_VAR 0 18
112174: IN
112175: NOT
112176: AND
112177: IFFALSE 112270
// begin if b then
112179: LD_VAR 0 19
112183: IFFALSE 112232
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
112185: LD_VAR 0 19
112189: PPUSH
112190: LD_VAR 0 3
112194: PPUSH
112195: LD_VAR 0 19
112199: PPUSH
112200: CALL_OW 74
112204: PPUSH
112205: CALL_OW 296
112209: PUSH
112210: LD_INT 10
112212: LESS
112213: PUSH
112214: LD_VAR 0 19
112218: PPUSH
112219: CALL_OW 461
112223: PUSH
112224: LD_INT 7
112226: NONEQUAL
112227: AND
112228: IFFALSE 112232
// continue ;
112230: GO 111547
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
112232: LD_ADDR_VAR 0 18
112236: PUSH
112237: LD_VAR 0 18
112241: PPUSH
112242: LD_VAR 0 18
112246: PUSH
112247: LD_INT 1
112249: PLUS
112250: PPUSH
112251: LD_VAR 0 5
112255: PPUSH
112256: CALL_OW 1
112260: ST_TO_ADDR
// ComExitBuilding ( i ) ;
112261: LD_VAR 0 5
112265: PPUSH
112266: CALL_OW 122
// end ; if sold_defenders then
112270: LD_VAR 0 18
112274: IFFALSE 112334
// if i in sold_defenders then
112276: LD_VAR 0 5
112280: PUSH
112281: LD_VAR 0 18
112285: IN
112286: IFFALSE 112334
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
112288: LD_VAR 0 5
112292: PPUSH
112293: CALL_OW 314
112297: NOT
112298: PUSH
112299: LD_VAR 0 5
112303: PPUSH
112304: LD_VAR 0 14
112308: PPUSH
112309: CALL_OW 296
112313: PUSH
112314: LD_INT 30
112316: LESS
112317: AND
112318: IFFALSE 112334
// ComAttackUnit ( i , e ) ;
112320: LD_VAR 0 5
112324: PPUSH
112325: LD_VAR 0 14
112329: PPUSH
112330: CALL_OW 115
// end ; end ; end ;
112334: GO 112337
112336: POP
// if IsDead ( i ) then
112337: LD_VAR 0 5
112341: PPUSH
112342: CALL_OW 301
112346: IFFALSE 112364
// defenders := defenders diff i ;
112348: LD_ADDR_VAR 0 2
112352: PUSH
112353: LD_VAR 0 2
112357: PUSH
112358: LD_VAR 0 5
112362: DIFF
112363: ST_TO_ADDR
// end ;
112364: GO 111547
112366: POP
112367: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
112368: LD_VAR 0 3
112372: NOT
112373: PUSH
112374: LD_VAR 0 2
112378: NOT
112379: OR
112380: PUSH
112381: LD_EXP 90
112385: PUSH
112386: LD_VAR 0 1
112390: ARRAY
112391: NOT
112392: OR
112393: IFFALSE 111451
// MC_Reset ( base , 18 ) ;
112395: LD_VAR 0 1
112399: PPUSH
112400: LD_INT 18
112402: PPUSH
112403: CALL 24856 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112407: LD_ADDR_VAR 0 2
112411: PUSH
112412: LD_VAR 0 2
112416: PUSH
112417: LD_VAR 0 2
112421: PPUSH
112422: LD_INT 2
112424: PUSH
112425: LD_INT 25
112427: PUSH
112428: LD_INT 1
112430: PUSH
112431: EMPTY
112432: LIST
112433: LIST
112434: PUSH
112435: LD_INT 25
112437: PUSH
112438: LD_INT 5
112440: PUSH
112441: EMPTY
112442: LIST
112443: LIST
112444: PUSH
112445: LD_INT 25
112447: PUSH
112448: LD_INT 8
112450: PUSH
112451: EMPTY
112452: LIST
112453: LIST
112454: PUSH
112455: LD_INT 25
112457: PUSH
112458: LD_INT 9
112460: PUSH
112461: EMPTY
112462: LIST
112463: LIST
112464: PUSH
112465: EMPTY
112466: LIST
112467: LIST
112468: LIST
112469: LIST
112470: LIST
112471: PPUSH
112472: CALL_OW 72
112476: DIFF
112477: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
112478: LD_VAR 0 3
112482: NOT
112483: PUSH
112484: LD_VAR 0 2
112488: PPUSH
112489: LD_INT 21
112491: PUSH
112492: LD_INT 2
112494: PUSH
112495: EMPTY
112496: LIST
112497: LIST
112498: PPUSH
112499: CALL_OW 72
112503: AND
112504: IFFALSE 112842
// begin tmp := FilterByTag ( defenders , 19 ) ;
112506: LD_ADDR_VAR 0 12
112510: PUSH
112511: LD_VAR 0 2
112515: PPUSH
112516: LD_INT 19
112518: PPUSH
112519: CALL 84729 0 2
112523: ST_TO_ADDR
// if tmp then
112524: LD_VAR 0 12
112528: IFFALSE 112598
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
112530: LD_ADDR_VAR 0 12
112534: PUSH
112535: LD_VAR 0 12
112539: PPUSH
112540: LD_INT 25
112542: PUSH
112543: LD_INT 3
112545: PUSH
112546: EMPTY
112547: LIST
112548: LIST
112549: PPUSH
112550: CALL_OW 72
112554: ST_TO_ADDR
// if tmp then
112555: LD_VAR 0 12
112559: IFFALSE 112598
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
112561: LD_ADDR_EXP 102
112565: PUSH
112566: LD_EXP 102
112570: PPUSH
112571: LD_VAR 0 1
112575: PPUSH
112576: LD_EXP 102
112580: PUSH
112581: LD_VAR 0 1
112585: ARRAY
112586: PUSH
112587: LD_VAR 0 12
112591: UNION
112592: PPUSH
112593: CALL_OW 1
112597: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
112598: LD_VAR 0 1
112602: PPUSH
112603: LD_INT 19
112605: PPUSH
112606: CALL 24856 0 2
// repeat wait ( 0 0$1 ) ;
112610: LD_INT 35
112612: PPUSH
112613: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112617: LD_EXP 90
112621: PUSH
112622: LD_VAR 0 1
112626: ARRAY
112627: NOT
112628: PUSH
112629: LD_EXP 90
112633: PUSH
112634: LD_VAR 0 1
112638: ARRAY
112639: PUSH
112640: EMPTY
112641: EQUAL
112642: OR
112643: IFFALSE 112680
// begin for i in defenders do
112645: LD_ADDR_VAR 0 5
112649: PUSH
112650: LD_VAR 0 2
112654: PUSH
112655: FOR_IN
112656: IFFALSE 112669
// ComStop ( i ) ;
112658: LD_VAR 0 5
112662: PPUSH
112663: CALL_OW 141
112667: GO 112655
112669: POP
112670: POP
// defenders := [ ] ;
112671: LD_ADDR_VAR 0 2
112675: PUSH
112676: EMPTY
112677: ST_TO_ADDR
// exit ;
112678: GO 112906
// end ; for i in defenders do
112680: LD_ADDR_VAR 0 5
112684: PUSH
112685: LD_VAR 0 2
112689: PUSH
112690: FOR_IN
112691: IFFALSE 112780
// begin if not IsInArea ( i , mc_parking [ base ] ) then
112693: LD_VAR 0 5
112697: PPUSH
112698: LD_EXP 114
112702: PUSH
112703: LD_VAR 0 1
112707: ARRAY
112708: PPUSH
112709: CALL_OW 308
112713: NOT
112714: IFFALSE 112738
// ComMoveToArea ( i , mc_parking [ base ] ) else
112716: LD_VAR 0 5
112720: PPUSH
112721: LD_EXP 114
112725: PUSH
112726: LD_VAR 0 1
112730: ARRAY
112731: PPUSH
112732: CALL_OW 113
112736: GO 112778
// if GetControl ( i ) = control_manual then
112738: LD_VAR 0 5
112742: PPUSH
112743: CALL_OW 263
112747: PUSH
112748: LD_INT 1
112750: EQUAL
112751: IFFALSE 112778
// if IsDrivenBy ( i ) then
112753: LD_VAR 0 5
112757: PPUSH
112758: CALL_OW 311
112762: IFFALSE 112778
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
112764: LD_VAR 0 5
112768: PPUSH
112769: CALL_OW 311
112773: PPUSH
112774: CALL_OW 121
// end ;
112778: GO 112690
112780: POP
112781: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
112782: LD_VAR 0 2
112786: PPUSH
112787: LD_INT 95
112789: PUSH
112790: LD_EXP 114
112794: PUSH
112795: LD_VAR 0 1
112799: ARRAY
112800: PUSH
112801: EMPTY
112802: LIST
112803: LIST
112804: PPUSH
112805: CALL_OW 72
112809: PUSH
112810: LD_VAR 0 2
112814: EQUAL
112815: PUSH
112816: LD_EXP 113
112820: PUSH
112821: LD_VAR 0 1
112825: ARRAY
112826: OR
112827: PUSH
112828: LD_EXP 90
112832: PUSH
112833: LD_VAR 0 1
112837: ARRAY
112838: NOT
112839: OR
112840: IFFALSE 112610
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
112842: LD_ADDR_EXP 112
112846: PUSH
112847: LD_EXP 112
112851: PPUSH
112852: LD_VAR 0 1
112856: PPUSH
112857: LD_VAR 0 2
112861: PPUSH
112862: LD_INT 21
112864: PUSH
112865: LD_INT 2
112867: PUSH
112868: EMPTY
112869: LIST
112870: LIST
112871: PPUSH
112872: CALL_OW 72
112876: PPUSH
112877: CALL_OW 1
112881: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
112882: LD_VAR 0 1
112886: PPUSH
112887: LD_INT 19
112889: PPUSH
112890: CALL 24856 0 2
// MC_Reset ( base , 20 ) ;
112894: LD_VAR 0 1
112898: PPUSH
112899: LD_INT 20
112901: PPUSH
112902: CALL 24856 0 2
// end ; end_of_file
112906: LD_VAR 0 4
112910: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
112911: LD_VAR 0 1
112915: PUSH
112916: LD_INT 200
112918: DOUBLE
112919: GREATEREQUAL
112920: IFFALSE 112928
112922: LD_INT 299
112924: DOUBLE
112925: LESSEQUAL
112926: IFTRUE 112930
112928: GO 112962
112930: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; end ;
112931: LD_VAR 0 1
112935: PPUSH
112936: LD_VAR 0 2
112940: PPUSH
112941: LD_VAR 0 3
112945: PPUSH
112946: LD_VAR 0 4
112950: PPUSH
112951: LD_VAR 0 5
112955: PPUSH
112956: CALL 101844 0 5
112960: GO 112963
112962: POP
// end ;
112963: PPOPN 11
112965: END
