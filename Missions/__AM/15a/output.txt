// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 19572 0 0
// InitNature ;
  19: CALL 16244 0 0
// InitArtifact ;
  23: CALL 16857 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4072 0 0
// PrepareAlliance ;
  44: CALL 1209 0 0
// PrepareArabian ;
  48: CALL 5798 0 0
// PrepareRussian ;
  52: CALL 7747 0 0
// PrepareLegion ;
  56: CALL 6188 0 0
// Action ;
  60: CALL 10238 0 0
// MC_Start ( ) ;
  64: CALL 21684 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// end ;
 168: LD_VAR 0 1
 172: RET
// export function CustomInitMacro ( ) ; begin
 173: LD_INT 0
 175: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 176: LD_ADDR_EXP 98
 180: PUSH
 181: LD_INT 26
 183: PUSH
 184: LD_INT 1
 186: PUSH
 187: LD_INT 4
 189: PUSH
 190: LD_INT 8
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 199: LD_ADDR_EXP 99
 203: PUSH
 204: LD_INT 27
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 7
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: LIST
 221: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 222: LD_INT 1
 224: PPUSH
 225: LD_INT 6
 227: PUSH
 228: LD_INT 7
 230: PUSH
 231: LD_INT 9
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: PPUSH
 245: LD_INT 28
 247: PPUSH
 248: CALL 42789 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 252: LD_INT 1
 254: PPUSH
 255: LD_INT 10
 257: PUSH
 258: LD_INT 11
 260: PUSH
 261: LD_INT 13
 263: PUSH
 264: LD_INT 15
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: PPUSH
 273: CALL 43849 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 29
 282: PUSH
 283: EMPTY
 284: LIST
 285: PPUSH
 286: CALL 43942 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 290: LD_ADDR_EXP 103
 294: PUSH
 295: LD_EXP 103
 299: PPUSH
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 22
 305: PUSH
 306: LD_INT 2
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: PUSH
 313: LD_INT 25
 315: PUSH
 316: LD_INT 15
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: PPUSH
 327: CALL_OW 69
 331: PPUSH
 332: CALL_OW 1
 336: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 337: LD_INT 1
 339: PPUSH
 340: LD_INT 13
 342: PUSH
 343: LD_INT 2
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 31
 351: PUSH
 352: EMPTY
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: PUSH
 358: LD_INT 13
 360: PUSH
 361: LD_INT 2
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: LD_INT 31
 369: PUSH
 370: EMPTY
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 13
 378: PUSH
 379: LD_INT 1
 381: PUSH
 382: LD_INT 1
 384: PUSH
 385: LD_INT 28
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: PUSH
 394: LD_INT 13
 396: PUSH
 397: LD_INT 1
 399: PUSH
 400: LD_INT 1
 402: PUSH
 403: LD_INT 28
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: LIST
 411: PUSH
 412: LD_INT 13
 414: PUSH
 415: LD_INT 1
 417: PUSH
 418: LD_INT 1
 420: PUSH
 421: LD_INT 28
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 13
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: LD_INT 28
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PPUSH
 456: CALL 43107 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 460: LD_INT 1
 462: PPUSH
 463: LD_INT 4
 465: PPUSH
 466: CALL 43292 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 470: LD_INT 2
 472: PPUSH
 473: LD_INT 10
 475: PUSH
 476: LD_INT 11
 478: PUSH
 479: LD_INT 12
 481: PUSH
 482: LD_INT 14
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL 43849 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 495: LD_INT 2
 497: PPUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: PPUSH
 504: CALL 43942 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 508: LD_INT 2
 510: PPUSH
 511: LD_INT 21
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 51
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 22
 531: PUSH
 532: LD_INT 3
 534: PUSH
 535: LD_INT 3
 537: PUSH
 538: LD_INT 52
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 22
 549: PUSH
 550: LD_INT 3
 552: PUSH
 553: LD_INT 3
 555: PUSH
 556: LD_INT 52
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 24
 567: PUSH
 568: LD_INT 3
 570: PUSH
 571: LD_INT 3
 573: PUSH
 574: LD_INT 47
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 24
 585: PUSH
 586: LD_INT 3
 588: PUSH
 589: LD_INT 3
 591: PUSH
 592: LD_INT 47
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: LD_INT 24
 603: PUSH
 604: LD_INT 3
 606: PUSH
 607: LD_INT 3
 609: PUSH
 610: LD_INT 47
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: PUSH
 619: LD_INT 24
 621: PUSH
 622: LD_INT 3
 624: PUSH
 625: LD_INT 3
 627: PUSH
 628: LD_INT 47
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 24
 639: PUSH
 640: LD_INT 3
 642: PUSH
 643: LD_INT 3
 645: PUSH
 646: LD_INT 47
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PPUSH
 665: CALL 43107 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 669: LD_INT 2
 671: PPUSH
 672: LD_INT 5
 674: PPUSH
 675: CALL 43292 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 0
 684: PPUSH
 685: CALL 43722 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 689: LD_INT 3
 691: PPUSH
 692: LD_INT 10
 694: PUSH
 695: LD_INT 12
 697: PUSH
 698: LD_INT 15
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_OWVAR 67
 710: ARRAY
 711: PPUSH
 712: LD_INT 24
 714: PPUSH
 715: CALL 42789 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 719: LD_INT 3
 721: PPUSH
 722: LD_INT 10
 724: PUSH
 725: LD_INT 11
 727: PUSH
 728: LD_INT 13
 730: PUSH
 731: LD_INT 15
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: PPUSH
 740: CALL 43849 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 744: LD_INT 3
 746: PPUSH
 747: LD_INT 13
 749: PUSH
 750: EMPTY
 751: LIST
 752: PPUSH
 753: CALL 43942 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 757: LD_ADDR_EXP 103
 761: PUSH
 762: LD_EXP 103
 766: PPUSH
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 22
 772: PUSH
 773: LD_INT 8
 775: PUSH
 776: EMPTY
 777: LIST
 778: LIST
 779: PUSH
 780: LD_INT 25
 782: PUSH
 783: LD_INT 15
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: PPUSH
 794: CALL_OW 69
 798: PPUSH
 799: CALL_OW 1
 803: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 804: LD_INT 3
 806: PPUSH
 807: LD_INT 13
 809: PUSH
 810: LD_INT 2
 812: PUSH
 813: LD_INT 1
 815: PUSH
 816: LD_INT 31
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 13
 827: PUSH
 828: LD_INT 2
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: LD_INT 31
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 13
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 2
 851: PUSH
 852: LD_INT 32
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: LD_INT 14
 863: PUSH
 864: LD_INT 1
 866: PUSH
 867: LD_INT 1
 869: PUSH
 870: LD_INT 28
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 14
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 28
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: PUSH
 897: LD_INT 14
 899: PUSH
 900: LD_INT 1
 902: PUSH
 903: LD_INT 1
 905: PUSH
 906: LD_INT 28
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: PUSH
 915: LD_INT 14
 917: PUSH
 918: LD_INT 1
 920: PUSH
 921: LD_INT 1
 923: PUSH
 924: LD_INT 28
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 43107 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 4
 951: PPUSH
 952: CALL 43292 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 956: LD_INT 4
 958: PPUSH
 959: LD_INT 10
 961: PUSH
 962: LD_INT 12
 964: PUSH
 965: LD_INT 11
 967: PUSH
 968: LD_INT 15
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: PPUSH
 977: CALL 43849 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 981: LD_INT 4
 983: PPUSH
 984: LD_INT 33
 986: PUSH
 987: EMPTY
 988: LIST
 989: PPUSH
 990: CALL 43942 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 994: LD_INT 4
 996: PPUSH
 997: LD_INT 5
 999: PUSH
1000: LD_INT 6
1002: PUSH
1003: LD_INT 7
1005: PUSH
1006: LD_INT 9
1008: PUSH
1009: LD_INT 10
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PPUSH
1019: CALL 44260 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1023: LD_INT 4
1025: PPUSH
1026: LD_INT 54
1028: PPUSH
1029: LD_INT 85
1031: PPUSH
1032: LD_INT 2
1034: PPUSH
1035: LD_INT 25
1037: PUSH
1038: LD_INT 16
1040: PUSH
1041: LD_INT 17
1043: PUSH
1044: LD_INT 18
1046: PUSH
1047: LD_INT 22
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PPUSH
1057: CALL 44054 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1061: LD_INT 4
1063: PPUSH
1064: LD_INT 5
1066: PUSH
1067: LD_INT 1
1069: PUSH
1070: LD_INT 1
1072: PUSH
1073: LD_INT 7
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 5
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: LD_INT 1
1090: PUSH
1091: LD_INT 6
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_INT 5
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 1
1108: PUSH
1109: LD_INT 7
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: PUSH
1118: LD_INT 5
1120: PUSH
1121: LD_INT 1
1123: PUSH
1124: LD_INT 1
1126: PUSH
1127: LD_INT 6
1129: PUSH
1130: EMPTY
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: PUSH
1136: LD_INT 5
1138: PUSH
1139: LD_INT 1
1141: PUSH
1142: LD_INT 3
1144: PUSH
1145: LD_INT 12
1147: PUSH
1148: EMPTY
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: PUSH
1154: LD_INT 3
1156: PUSH
1157: LD_INT 1
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: LD_INT 13
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: EMPTY
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PPUSH
1180: CALL 43107 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1184: LD_INT 4
1186: PPUSH
1187: LD_INT 4
1189: PPUSH
1190: CALL 43292 0 2
// MC_SetTame ( 4 , powellApe ) ;
1194: LD_INT 4
1196: PPUSH
1197: LD_INT 11
1199: PPUSH
1200: CALL 43673 0 2
// end ; end_of_file
1204: LD_VAR 0 1
1208: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1209: LD_INT 0
1211: PPUSH
1212: PPUSH
1213: PPUSH
1214: PPUSH
1215: PPUSH
// uc_side := 7 ;
1216: LD_ADDR_OWVAR 20
1220: PUSH
1221: LD_INT 7
1223: ST_TO_ADDR
// tmp := [ ] ;
1224: LD_ADDR_VAR 0 5
1228: PUSH
1229: EMPTY
1230: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1231: LD_ADDR_EXP 12
1235: PUSH
1236: LD_STRING JMM
1238: PPUSH
1239: LD_EXP 1
1243: NOT
1244: PPUSH
1245: LD_STRING 14a_
1247: PPUSH
1248: CALL 49365 0 3
1252: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1253: LD_ADDR_EXP 44
1257: PUSH
1258: LD_STRING Burlak
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_STRING 14a_
1269: PPUSH
1270: CALL 49365 0 3
1274: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1275: LD_ADDR_EXP 27
1279: PUSH
1280: LD_STRING Joan
1282: PPUSH
1283: LD_EXP 1
1287: NOT
1288: PPUSH
1289: LD_STRING 13a_
1291: PPUSH
1292: CALL 49365 0 3
1296: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1297: LD_ADDR_EXP 13
1301: PUSH
1302: LD_STRING Roth
1304: PPUSH
1305: LD_EXP 1
1309: NOT
1310: PPUSH
1311: LD_STRING 13a_
1313: PPUSH
1314: CALL 49365 0 3
1318: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1319: LD_ADDR_EXP 30
1323: PUSH
1324: LD_STRING Gossudarov
1326: PPUSH
1327: LD_EXP 1
1331: NOT
1332: PPUSH
1333: LD_STRING 13a_
1335: PPUSH
1336: CALL 49365 0 3
1340: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1341: LD_ADDR_EXP 28
1345: PUSH
1346: LD_STRING DeltaDoctor
1348: PPUSH
1349: LD_EXP 1
1353: NOT
1354: PPUSH
1355: LD_STRING 13a_
1357: PPUSH
1358: CALL 49365 0 3
1362: ST_TO_ADDR
// if DeltaDoctor then
1363: LD_EXP 28
1367: IFFALSE 1385
// tmp := tmp ^ DeltaDoctor ;
1369: LD_ADDR_VAR 0 5
1373: PUSH
1374: LD_VAR 0 5
1378: PUSH
1379: LD_EXP 28
1383: ADD
1384: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1385: LD_ADDR_EXP 26
1389: PUSH
1390: LD_STRING Simms
1392: PPUSH
1393: LD_EXP 1
1397: NOT
1398: PPUSH
1399: LD_STRING 13a_
1401: PPUSH
1402: CALL 49365 0 3
1406: ST_TO_ADDR
// if Simms then
1407: LD_EXP 26
1411: IFFALSE 1429
// tmp := tmp ^ Simms ;
1413: LD_ADDR_VAR 0 5
1417: PUSH
1418: LD_VAR 0 5
1422: PUSH
1423: LD_EXP 26
1427: ADD
1428: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1429: LD_ADDR_EXP 24
1433: PUSH
1434: LD_STRING Frank
1436: PPUSH
1437: LD_EXP 1
1441: NOT
1442: PPUSH
1443: LD_STRING 13a_
1445: PPUSH
1446: CALL 49365 0 3
1450: ST_TO_ADDR
// if Frank then
1451: LD_EXP 24
1455: IFFALSE 1473
// tmp := tmp ^ Frank ;
1457: LD_ADDR_VAR 0 5
1461: PUSH
1462: LD_VAR 0 5
1466: PUSH
1467: LD_EXP 24
1471: ADD
1472: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1473: LD_ADDR_EXP 31
1477: PUSH
1478: LD_STRING Kirilenkova
1480: PPUSH
1481: LD_EXP 1
1485: NOT
1486: PPUSH
1487: LD_STRING 13a_
1489: PPUSH
1490: CALL 49365 0 3
1494: ST_TO_ADDR
// if Kirilenkova then
1495: LD_EXP 31
1499: IFFALSE 1517
// tmp := tmp ^ Kirilenkova ;
1501: LD_ADDR_VAR 0 5
1505: PUSH
1506: LD_VAR 0 5
1510: PUSH
1511: LD_EXP 31
1515: ADD
1516: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1517: LD_ADDR_EXP 32
1521: PUSH
1522: LD_STRING Titov
1524: PPUSH
1525: LD_EXP 1
1529: NOT
1530: PPUSH
1531: LD_STRING 13a_
1533: PPUSH
1534: CALL 49365 0 3
1538: ST_TO_ADDR
// if Titov then
1539: LD_EXP 32
1543: IFFALSE 1561
// tmp := tmp ^ Titov ;
1545: LD_ADDR_VAR 0 5
1549: PUSH
1550: LD_VAR 0 5
1554: PUSH
1555: LD_EXP 32
1559: ADD
1560: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1561: LD_ADDR_EXP 33
1565: PUSH
1566: LD_STRING Fadeev
1568: PPUSH
1569: LD_EXP 1
1573: NOT
1574: PPUSH
1575: LD_STRING 13a_
1577: PPUSH
1578: CALL 49365 0 3
1582: ST_TO_ADDR
// if Fadeev then
1583: LD_EXP 33
1587: IFFALSE 1605
// tmp := tmp ^ Fadeev ;
1589: LD_ADDR_VAR 0 5
1593: PUSH
1594: LD_VAR 0 5
1598: PUSH
1599: LD_EXP 33
1603: ADD
1604: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1605: LD_ADDR_EXP 34
1609: PUSH
1610: LD_STRING Dolgov
1612: PPUSH
1613: LD_EXP 1
1617: NOT
1618: PPUSH
1619: LD_STRING 13a_
1621: PPUSH
1622: CALL 49365 0 3
1626: ST_TO_ADDR
// if Dolgov then
1627: LD_EXP 34
1631: IFFALSE 1649
// tmp := tmp ^ Dolgov ;
1633: LD_ADDR_VAR 0 5
1637: PUSH
1638: LD_VAR 0 5
1642: PUSH
1643: LD_EXP 34
1647: ADD
1648: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1649: LD_ADDR_EXP 35
1653: PUSH
1654: LD_STRING Petrosyan
1656: PPUSH
1657: LD_EXP 1
1661: NOT
1662: PPUSH
1663: LD_STRING 13a_
1665: PPUSH
1666: CALL 49365 0 3
1670: ST_TO_ADDR
// if Petrosyan then
1671: LD_EXP 35
1675: IFFALSE 1693
// tmp := tmp ^ Petrosyan ;
1677: LD_ADDR_VAR 0 5
1681: PUSH
1682: LD_VAR 0 5
1686: PUSH
1687: LD_EXP 35
1691: ADD
1692: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1693: LD_ADDR_EXP 36
1697: PUSH
1698: LD_STRING Scholtze
1700: PPUSH
1701: LD_EXP 1
1705: NOT
1706: PPUSH
1707: LD_STRING 13a_
1709: PPUSH
1710: CALL 49365 0 3
1714: ST_TO_ADDR
// if Scholtze then
1715: LD_EXP 36
1719: IFFALSE 1737
// tmp := tmp ^ Scholtze ;
1721: LD_ADDR_VAR 0 5
1725: PUSH
1726: LD_VAR 0 5
1730: PUSH
1731: LD_EXP 36
1735: ADD
1736: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1737: LD_ADDR_EXP 37
1741: PUSH
1742: LD_STRING Oblukov
1744: PPUSH
1745: LD_EXP 1
1749: NOT
1750: PPUSH
1751: LD_STRING 13a_
1753: PPUSH
1754: CALL 49365 0 3
1758: ST_TO_ADDR
// if Oblukov then
1759: LD_EXP 37
1763: IFFALSE 1781
// tmp := tmp ^ Oblukov ;
1765: LD_ADDR_VAR 0 5
1769: PUSH
1770: LD_VAR 0 5
1774: PUSH
1775: LD_EXP 37
1779: ADD
1780: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1781: LD_ADDR_EXP 38
1785: PUSH
1786: LD_STRING Kapitsova
1788: PPUSH
1789: LD_EXP 1
1793: NOT
1794: PPUSH
1795: LD_STRING 13a_
1797: PPUSH
1798: CALL 49365 0 3
1802: ST_TO_ADDR
// if Kapitsova then
1803: LD_EXP 38
1807: IFFALSE 1825
// tmp := tmp ^ Kapitsova ;
1809: LD_ADDR_VAR 0 5
1813: PUSH
1814: LD_VAR 0 5
1818: PUSH
1819: LD_EXP 38
1823: ADD
1824: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1825: LD_ADDR_EXP 39
1829: PUSH
1830: LD_STRING Lipshchin
1832: PPUSH
1833: LD_EXP 1
1837: NOT
1838: PPUSH
1839: LD_STRING 13a_
1841: PPUSH
1842: CALL 49365 0 3
1846: ST_TO_ADDR
// if Lipshchin then
1847: LD_EXP 39
1851: IFFALSE 1869
// tmp := tmp ^ Lipshchin ;
1853: LD_ADDR_VAR 0 5
1857: PUSH
1858: LD_VAR 0 5
1862: PUSH
1863: LD_EXP 39
1867: ADD
1868: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
1869: LD_ADDR_EXP 40
1873: PUSH
1874: LD_STRING Petrovova
1876: PPUSH
1877: LD_EXP 1
1881: NOT
1882: PPUSH
1883: LD_STRING 13a_
1885: PPUSH
1886: CALL 49365 0 3
1890: ST_TO_ADDR
// if Petrovova then
1891: LD_EXP 40
1895: IFFALSE 1913
// tmp := tmp ^ Petrovova ;
1897: LD_ADDR_VAR 0 5
1901: PUSH
1902: LD_VAR 0 5
1906: PUSH
1907: LD_EXP 40
1911: ADD
1912: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
1913: LD_ADDR_EXP 41
1917: PUSH
1918: LD_STRING Kovalyuk
1920: PPUSH
1921: LD_EXP 1
1925: NOT
1926: PPUSH
1927: LD_STRING 13a_
1929: PPUSH
1930: CALL 49365 0 3
1934: ST_TO_ADDR
// if Kovalyuk then
1935: LD_EXP 41
1939: IFFALSE 1957
// tmp := tmp ^ Kovalyuk ;
1941: LD_ADDR_VAR 0 5
1945: PUSH
1946: LD_VAR 0 5
1950: PUSH
1951: LD_EXP 41
1955: ADD
1956: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
1957: LD_ADDR_EXP 42
1961: PUSH
1962: LD_STRING Kuzmov
1964: PPUSH
1965: LD_EXP 1
1969: NOT
1970: PPUSH
1971: LD_STRING 13a_
1973: PPUSH
1974: CALL 49365 0 3
1978: ST_TO_ADDR
// if Kuzmov then
1979: LD_EXP 42
1983: IFFALSE 2001
// tmp := tmp ^ Kuzmov ;
1985: LD_ADDR_VAR 0 5
1989: PUSH
1990: LD_VAR 0 5
1994: PUSH
1995: LD_EXP 42
1999: ADD
2000: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2001: LD_ADDR_EXP 43
2005: PUSH
2006: LD_STRING Karamazov
2008: PPUSH
2009: LD_EXP 1
2013: NOT
2014: PPUSH
2015: LD_STRING 13a_
2017: PPUSH
2018: CALL 49365 0 3
2022: ST_TO_ADDR
// if Karamazov then
2023: LD_EXP 43
2027: IFFALSE 2045
// tmp := tmp ^ Karamazov ;
2029: LD_ADDR_VAR 0 5
2033: PUSH
2034: LD_VAR 0 5
2038: PUSH
2039: LD_EXP 43
2043: ADD
2044: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2045: LD_ADDR_EXP 45
2049: PUSH
2050: LD_STRING Belkov
2052: PPUSH
2053: LD_EXP 1
2057: NOT
2058: PPUSH
2059: LD_STRING 13a_
2061: PPUSH
2062: CALL 49365 0 3
2066: ST_TO_ADDR
// if Belkov then
2067: LD_EXP 45
2071: IFFALSE 2089
// tmp := tmp ^ Belkov ;
2073: LD_ADDR_VAR 0 5
2077: PUSH
2078: LD_VAR 0 5
2082: PUSH
2083: LD_EXP 45
2087: ADD
2088: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2089: LD_ADDR_EXP 46
2093: PUSH
2094: LD_STRING Gnyevko
2096: PPUSH
2097: LD_EXP 1
2101: NOT
2102: PPUSH
2103: LD_STRING 13a_
2105: PPUSH
2106: CALL 49365 0 3
2110: ST_TO_ADDR
// if Gnyevko then
2111: LD_EXP 46
2115: IFFALSE 2133
// tmp := tmp ^ Gnyevko ;
2117: LD_ADDR_VAR 0 5
2121: PUSH
2122: LD_VAR 0 5
2126: PUSH
2127: LD_EXP 46
2131: ADD
2132: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2133: LD_ADDR_EXP 29
2137: PUSH
2138: LD_STRING Coonie
2140: PPUSH
2141: CALL_OW 25
2145: ST_TO_ADDR
// if not Lisa then
2146: LD_EXP 14
2150: NOT
2151: IFFALSE 2197
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2153: LD_ADDR_EXP 14
2157: PUSH
2158: LD_STRING Lisa
2160: PPUSH
2161: LD_EXP 1
2165: NOT
2166: PPUSH
2167: LD_STRING 13a_
2169: PPUSH
2170: CALL 49365 0 3
2174: ST_TO_ADDR
// if Lisa then
2175: LD_EXP 14
2179: IFFALSE 2197
// tmp := tmp ^ Lisa ;
2181: LD_ADDR_VAR 0 5
2185: PUSH
2186: LD_VAR 0 5
2190: PUSH
2191: LD_EXP 14
2195: ADD
2196: ST_TO_ADDR
// end ; if not Donaldson then
2197: LD_EXP 15
2201: NOT
2202: IFFALSE 2248
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2204: LD_ADDR_EXP 15
2208: PUSH
2209: LD_STRING Donaldson
2211: PPUSH
2212: LD_EXP 1
2216: NOT
2217: PPUSH
2218: LD_STRING 13a_
2220: PPUSH
2221: CALL 49365 0 3
2225: ST_TO_ADDR
// if Donaldson then
2226: LD_EXP 15
2230: IFFALSE 2248
// tmp := tmp ^ Donaldson ;
2232: LD_ADDR_VAR 0 5
2236: PUSH
2237: LD_VAR 0 5
2241: PUSH
2242: LD_EXP 15
2246: ADD
2247: ST_TO_ADDR
// end ; if not Bobby then
2248: LD_EXP 16
2252: NOT
2253: IFFALSE 2299
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2255: LD_ADDR_EXP 16
2259: PUSH
2260: LD_STRING Bobby
2262: PPUSH
2263: LD_EXP 1
2267: NOT
2268: PPUSH
2269: LD_STRING 13a_
2271: PPUSH
2272: CALL 49365 0 3
2276: ST_TO_ADDR
// if Bobby then
2277: LD_EXP 16
2281: IFFALSE 2299
// tmp := tmp ^ Bobby ;
2283: LD_ADDR_VAR 0 5
2287: PUSH
2288: LD_VAR 0 5
2292: PUSH
2293: LD_EXP 16
2297: ADD
2298: ST_TO_ADDR
// end ; if not Cyrus then
2299: LD_EXP 17
2303: NOT
2304: IFFALSE 2350
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2306: LD_ADDR_EXP 17
2310: PUSH
2311: LD_STRING Cyrus
2313: PPUSH
2314: LD_EXP 1
2318: NOT
2319: PPUSH
2320: LD_STRING 13a_
2322: PPUSH
2323: CALL 49365 0 3
2327: ST_TO_ADDR
// if Cyrus then
2328: LD_EXP 17
2332: IFFALSE 2350
// tmp := tmp ^ Cyrus ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 5
2343: PUSH
2344: LD_EXP 17
2348: ADD
2349: ST_TO_ADDR
// end ; if not Brown then
2350: LD_EXP 19
2354: NOT
2355: IFFALSE 2401
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2357: LD_ADDR_EXP 19
2361: PUSH
2362: LD_STRING Brown
2364: PPUSH
2365: LD_EXP 1
2369: NOT
2370: PPUSH
2371: LD_STRING 13a_
2373: PPUSH
2374: CALL 49365 0 3
2378: ST_TO_ADDR
// if Brown then
2379: LD_EXP 19
2383: IFFALSE 2401
// tmp := tmp ^ Brown ;
2385: LD_ADDR_VAR 0 5
2389: PUSH
2390: LD_VAR 0 5
2394: PUSH
2395: LD_EXP 19
2399: ADD
2400: ST_TO_ADDR
// end ; if not Gladstone then
2401: LD_EXP 20
2405: NOT
2406: IFFALSE 2452
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2408: LD_ADDR_EXP 20
2412: PUSH
2413: LD_STRING Gladstone
2415: PPUSH
2416: LD_EXP 1
2420: NOT
2421: PPUSH
2422: LD_STRING 13a_
2424: PPUSH
2425: CALL 49365 0 3
2429: ST_TO_ADDR
// if Gladstone then
2430: LD_EXP 20
2434: IFFALSE 2452
// tmp := tmp ^ Gladstone ;
2436: LD_ADDR_VAR 0 5
2440: PUSH
2441: LD_VAR 0 5
2445: PUSH
2446: LD_EXP 20
2450: ADD
2451: ST_TO_ADDR
// end ; if not Cornel then
2452: LD_EXP 22
2456: NOT
2457: IFFALSE 2503
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2459: LD_ADDR_EXP 22
2463: PUSH
2464: LD_STRING Cornel
2466: PPUSH
2467: LD_EXP 1
2471: NOT
2472: PPUSH
2473: LD_STRING 13a_
2475: PPUSH
2476: CALL 49365 0 3
2480: ST_TO_ADDR
// if Cornel then
2481: LD_EXP 22
2485: IFFALSE 2503
// tmp := tmp ^ Cornel ;
2487: LD_ADDR_VAR 0 5
2491: PUSH
2492: LD_VAR 0 5
2496: PUSH
2497: LD_EXP 22
2501: ADD
2502: ST_TO_ADDR
// end ; if not Houten then
2503: LD_EXP 21
2507: NOT
2508: IFFALSE 2554
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2510: LD_ADDR_EXP 21
2514: PUSH
2515: LD_STRING Houten
2517: PPUSH
2518: LD_EXP 1
2522: NOT
2523: PPUSH
2524: LD_STRING 13a_
2526: PPUSH
2527: CALL 49365 0 3
2531: ST_TO_ADDR
// if Houten then
2532: LD_EXP 21
2536: IFFALSE 2554
// tmp := tmp ^ Houten ;
2538: LD_ADDR_VAR 0 5
2542: PUSH
2543: LD_VAR 0 5
2547: PUSH
2548: LD_EXP 21
2552: ADD
2553: ST_TO_ADDR
// end ; if not Gary then
2554: LD_EXP 23
2558: NOT
2559: IFFALSE 2605
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2561: LD_ADDR_EXP 23
2565: PUSH
2566: LD_STRING Gary
2568: PPUSH
2569: LD_EXP 1
2573: NOT
2574: PPUSH
2575: LD_STRING 13a_
2577: PPUSH
2578: CALL 49365 0 3
2582: ST_TO_ADDR
// if Gary then
2583: LD_EXP 23
2587: IFFALSE 2605
// tmp := tmp ^ Gary ;
2589: LD_ADDR_VAR 0 5
2593: PUSH
2594: LD_VAR 0 5
2598: PUSH
2599: LD_EXP 23
2603: ADD
2604: ST_TO_ADDR
// end ; if not Kikuchi then
2605: LD_EXP 25
2609: NOT
2610: IFFALSE 2656
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2612: LD_ADDR_EXP 25
2616: PUSH
2617: LD_STRING Kikuchi
2619: PPUSH
2620: LD_EXP 1
2624: NOT
2625: PPUSH
2626: LD_STRING 13a_
2628: PPUSH
2629: CALL 49365 0 3
2633: ST_TO_ADDR
// if Kikuchi then
2634: LD_EXP 25
2638: IFFALSE 2656
// tmp := tmp ^ Kikuchi ;
2640: LD_ADDR_VAR 0 5
2644: PUSH
2645: LD_VAR 0 5
2649: PUSH
2650: LD_EXP 25
2654: ADD
2655: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2656: LD_ADDR_VAR 0 5
2660: PUSH
2661: LD_VAR 0 5
2665: PUSH
2666: LD_STRING 13a_others
2668: PPUSH
2669: CALL_OW 31
2673: UNION
2674: ST_TO_ADDR
// tmp := tmp diff 0 ;
2675: LD_ADDR_VAR 0 5
2679: PUSH
2680: LD_VAR 0 5
2684: PUSH
2685: LD_INT 0
2687: DIFF
2688: ST_TO_ADDR
// if tmp < 15 then
2689: LD_VAR 0 5
2693: PUSH
2694: LD_INT 15
2696: LESS
2697: IFFALSE 2785
// for i = 15 downto tmp do
2699: LD_ADDR_VAR 0 2
2703: PUSH
2704: DOUBLE
2705: LD_INT 15
2707: INC
2708: ST_TO_ADDR
2709: LD_VAR 0 5
2713: PUSH
2714: FOR_DOWNTO
2715: IFFALSE 2783
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2717: LD_ADDR_OWVAR 21
2721: PUSH
2722: LD_INT 1
2724: PUSH
2725: LD_INT 3
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: PUSH
2732: LD_INT 1
2734: PPUSH
2735: LD_INT 2
2737: PPUSH
2738: CALL_OW 12
2742: ARRAY
2743: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2744: LD_INT 0
2746: PPUSH
2747: LD_INT 1
2749: PPUSH
2750: LD_INT 4
2752: PPUSH
2753: CALL_OW 12
2757: PPUSH
2758: LD_INT 8
2760: PPUSH
2761: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2765: LD_ADDR_VAR 0 5
2769: PUSH
2770: LD_VAR 0 5
2774: PUSH
2775: CALL_OW 44
2779: ADD
2780: ST_TO_ADDR
// end ;
2781: GO 2714
2783: POP
2784: POP
// if not debug then
2785: LD_EXP 1
2789: NOT
2790: IFFALSE 2962
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2792: LD_ADDR_VAR 0 4
2796: PUSH
2797: LD_STRING 
2799: PPUSH
2800: LD_INT 15
2802: PUSH
2803: LD_INT 14
2805: PUSH
2806: LD_INT 13
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: PUSH
2814: LD_OWVAR 67
2818: ARRAY
2819: PPUSH
2820: LD_INT 15
2822: PUSH
2823: LD_INT 14
2825: PUSH
2826: LD_INT 13
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: PUSH
2834: LD_OWVAR 67
2838: ARRAY
2839: PPUSH
2840: LD_INT -6
2842: PUSH
2843: LD_EXP 12
2847: PUSH
2848: LD_EXP 44
2852: PUSH
2853: LD_EXP 13
2857: PUSH
2858: LD_EXP 27
2862: PUSH
2863: LD_EXP 18
2867: PUSH
2868: LD_EXP 30
2872: PUSH
2873: LD_INT -2
2875: PUSH
2876: LD_INT -3
2878: PUSH
2879: LD_INT -5
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: LIST
2889: LIST
2890: LIST
2891: LIST
2892: LIST
2893: PUSH
2894: LD_VAR 0 5
2898: ADD
2899: PPUSH
2900: LD_INT 1
2902: PUSH
2903: LD_INT 4
2905: PUSH
2906: LD_INT 2
2908: PUSH
2909: LD_INT 1
2911: PUSH
2912: EMPTY
2913: LIST
2914: LIST
2915: PUSH
2916: LD_INT 3
2918: PUSH
2919: LD_INT 5
2921: PUSH
2922: LD_INT 0
2924: PUSH
2925: LD_INT 3
2927: PUSH
2928: EMPTY
2929: LIST
2930: LIST
2931: LIST
2932: PUSH
2933: LD_INT 9
2935: PUSH
2936: LD_INT 0
2938: PUSH
2939: LD_INT 3
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: LIST
2951: LIST
2952: LIST
2953: LIST
2954: PPUSH
2955: CALL_OW 42
2959: ST_TO_ADDR
2960: GO 3041
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
2962: LD_ADDR_VAR 0 4
2966: PUSH
2967: LD_EXP 32
2971: PUSH
2972: LD_EXP 33
2976: PUSH
2977: LD_EXP 34
2981: PUSH
2982: LD_EXP 35
2986: PUSH
2987: LD_EXP 36
2991: PUSH
2992: LD_EXP 37
2996: PUSH
2997: LD_EXP 38
3001: PUSH
3002: LD_EXP 39
3006: PUSH
3007: LD_EXP 40
3011: PUSH
3012: LD_EXP 41
3016: PUSH
3017: LD_EXP 42
3021: PUSH
3022: LD_EXP 43
3026: PUSH
3027: EMPTY
3028: LIST
3029: LIST
3030: LIST
3031: LIST
3032: LIST
3033: LIST
3034: LIST
3035: LIST
3036: LIST
3037: LIST
3038: LIST
3039: LIST
3040: ST_TO_ADDR
// uc_nation := 1 ;
3041: LD_ADDR_OWVAR 21
3045: PUSH
3046: LD_INT 1
3048: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3049: LD_INT 5
3051: PPUSH
3052: LD_INT 3
3054: PPUSH
3055: LD_INT 1
3057: PPUSH
3058: LD_INT 6
3060: PPUSH
3061: LD_INT 100
3063: PPUSH
3064: CALL 56116 0 5
// veh := CreateVehicle ;
3068: LD_ADDR_VAR 0 3
3072: PUSH
3073: CALL_OW 45
3077: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3078: LD_VAR 0 3
3082: PPUSH
3083: LD_INT 7
3085: NEG
3086: PPUSH
3087: CALL_OW 242
// SetDir ( veh , 3 ) ;
3091: LD_VAR 0 3
3095: PPUSH
3096: LD_INT 3
3098: PPUSH
3099: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3103: LD_VAR 0 3
3107: PPUSH
3108: LD_INT 31
3110: PPUSH
3111: LD_INT 0
3113: PPUSH
3114: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3118: LD_EXP 12
3122: PPUSH
3123: LD_VAR 0 3
3127: PPUSH
3128: CALL_OW 52
// uc_nation := 3 ;
3132: LD_ADDR_OWVAR 21
3136: PUSH
3137: LD_INT 3
3139: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3140: LD_INT 22
3142: PPUSH
3143: LD_INT 3
3145: PPUSH
3146: LD_INT 1
3148: PPUSH
3149: LD_INT 45
3151: PPUSH
3152: LD_INT 100
3154: PPUSH
3155: CALL 56116 0 5
// veh := CreateVehicle ;
3159: LD_ADDR_VAR 0 3
3163: PUSH
3164: CALL_OW 45
3168: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3169: LD_VAR 0 3
3173: PPUSH
3174: LD_INT 7
3176: NEG
3177: PPUSH
3178: CALL_OW 242
// SetDir ( veh , 3 ) ;
3182: LD_VAR 0 3
3186: PPUSH
3187: LD_INT 3
3189: PPUSH
3190: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3194: LD_VAR 0 3
3198: PPUSH
3199: LD_INT 31
3201: PPUSH
3202: LD_INT 0
3204: PPUSH
3205: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3209: LD_EXP 44
3213: PPUSH
3214: LD_VAR 0 3
3218: PPUSH
3219: CALL_OW 52
// for i in selected do
3223: LD_ADDR_VAR 0 2
3227: PUSH
3228: LD_VAR 0 4
3232: PUSH
3233: FOR_IN
3234: IFFALSE 3792
// begin uc_nation := GetNation ( i ) ;
3236: LD_ADDR_OWVAR 21
3240: PUSH
3241: LD_VAR 0 2
3245: PPUSH
3246: CALL_OW 248
3250: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3251: LD_VAR 0 2
3255: PUSH
3256: LD_EXP 14
3260: PUSH
3261: LD_EXP 15
3265: PUSH
3266: LD_EXP 17
3270: PUSH
3271: LD_EXP 16
3275: PUSH
3276: EMPTY
3277: LIST
3278: LIST
3279: LIST
3280: LIST
3281: IN
3282: IFFALSE 3305
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3284: LD_INT 5
3286: PPUSH
3287: LD_INT 3
3289: PPUSH
3290: LD_INT 1
3292: PPUSH
3293: LD_INT 6
3295: PPUSH
3296: LD_INT 100
3298: PPUSH
3299: CALL 56116 0 5
3303: GO 3739
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3305: LD_VAR 0 2
3309: PUSH
3310: LD_EXP 37
3314: PUSH
3315: LD_EXP 42
3319: PUSH
3320: LD_EXP 40
3324: PUSH
3325: LD_EXP 32
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: LIST
3334: LIST
3335: IN
3336: IFFALSE 3367
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3338: LD_INT 24
3340: PPUSH
3341: LD_INT 1
3343: PPUSH
3344: LD_INT 1
3346: PPUSH
3347: LD_INT 46
3349: PPUSH
3350: LD_INT 65
3352: PPUSH
3353: LD_INT 75
3355: PPUSH
3356: CALL_OW 12
3360: PPUSH
3361: CALL 56116 0 5
3365: GO 3739
// if i = Karamazov then
3367: LD_VAR 0 2
3371: PUSH
3372: LD_EXP 43
3376: EQUAL
3377: IFFALSE 3400
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3379: LD_INT 22
3381: PPUSH
3382: LD_INT 3
3384: PPUSH
3385: LD_INT 1
3387: PPUSH
3388: LD_INT 52
3390: PPUSH
3391: LD_INT 100
3393: PPUSH
3394: CALL 56116 0 5
3398: GO 3739
// if i = Brown then
3400: LD_VAR 0 2
3404: PUSH
3405: LD_EXP 19
3409: EQUAL
3410: IFFALSE 3433
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3412: LD_INT 3
3414: PPUSH
3415: LD_INT 3
3417: PPUSH
3418: LD_INT 1
3420: PPUSH
3421: LD_INT 13
3423: PPUSH
3424: LD_INT 100
3426: PPUSH
3427: CALL 56116 0 5
3431: GO 3739
// if uc_nation = nation_american then
3433: LD_OWVAR 21
3437: PUSH
3438: LD_INT 1
3440: EQUAL
3441: IFFALSE 3592
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3443: LD_INT 3
3445: PUSH
3446: LD_INT 5
3448: PUSH
3449: LD_INT 5
3451: PUSH
3452: EMPTY
3453: LIST
3454: LIST
3455: LIST
3456: PUSH
3457: LD_OWVAR 21
3461: PUSH
3462: LD_INT 3
3464: MOD
3465: PUSH
3466: LD_INT 1
3468: PLUS
3469: ARRAY
3470: PPUSH
3471: LD_INT 1
3473: PUSH
3474: LD_INT 3
3476: PUSH
3477: LD_INT 1
3479: PUSH
3480: EMPTY
3481: LIST
3482: LIST
3483: LIST
3484: PUSH
3485: LD_OWVAR 21
3489: PUSH
3490: LD_INT 3
3492: MOD
3493: PUSH
3494: LD_INT 1
3496: PLUS
3497: ARRAY
3498: PPUSH
3499: LD_INT 1
3501: PPUSH
3502: LD_INT 11
3504: PUSH
3505: LD_INT 4
3507: PUSH
3508: LD_INT 5
3510: PUSH
3511: EMPTY
3512: LIST
3513: LIST
3514: LIST
3515: PUSH
3516: LD_INT 6
3518: PUSH
3519: LD_INT 7
3521: PUSH
3522: LD_INT 9
3524: PUSH
3525: EMPTY
3526: LIST
3527: LIST
3528: LIST
3529: PUSH
3530: LD_INT 6
3532: PUSH
3533: LD_INT 9
3535: PUSH
3536: LD_INT 12
3538: PUSH
3539: EMPTY
3540: LIST
3541: LIST
3542: LIST
3543: PUSH
3544: EMPTY
3545: LIST
3546: LIST
3547: LIST
3548: PUSH
3549: LD_OWVAR 21
3553: PUSH
3554: LD_INT 3
3556: MOD
3557: PUSH
3558: LD_INT 1
3560: PLUS
3561: ARRAY
3562: PUSH
3563: LD_INT 1
3565: PPUSH
3566: LD_INT 3
3568: PPUSH
3569: CALL_OW 12
3573: ARRAY
3574: PPUSH
3575: LD_INT 65
3577: PPUSH
3578: LD_INT 75
3580: PPUSH
3581: CALL_OW 12
3585: PPUSH
3586: CALL 56116 0 5
// end else
3590: GO 3739
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3592: LD_INT 22
3594: PUSH
3595: LD_INT 23
3597: PUSH
3598: LD_INT 23
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: LIST
3605: PUSH
3606: LD_OWVAR 21
3610: PUSH
3611: LD_INT 3
3613: MOD
3614: PUSH
3615: LD_INT 1
3617: PLUS
3618: ARRAY
3619: PPUSH
3620: LD_INT 1
3622: PUSH
3623: LD_INT 3
3625: PUSH
3626: LD_INT 1
3628: PUSH
3629: EMPTY
3630: LIST
3631: LIST
3632: LIST
3633: PUSH
3634: LD_OWVAR 21
3638: PUSH
3639: LD_INT 3
3641: MOD
3642: PUSH
3643: LD_INT 1
3645: PLUS
3646: ARRAY
3647: PPUSH
3648: LD_INT 1
3650: PPUSH
3651: LD_INT 45
3653: PUSH
3654: LD_INT 43
3656: PUSH
3657: LD_INT 44
3659: PUSH
3660: EMPTY
3661: LIST
3662: LIST
3663: LIST
3664: PUSH
3665: LD_INT 46
3667: PUSH
3668: LD_INT 45
3670: PUSH
3671: LD_INT 44
3673: PUSH
3674: EMPTY
3675: LIST
3676: LIST
3677: LIST
3678: PUSH
3679: LD_INT 46
3681: PUSH
3682: LD_INT 43
3684: PUSH
3685: LD_INT 45
3687: PUSH
3688: EMPTY
3689: LIST
3690: LIST
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: LIST
3697: PUSH
3698: LD_OWVAR 21
3702: PUSH
3703: LD_INT 3
3705: MOD
3706: PUSH
3707: LD_INT 1
3709: PLUS
3710: ARRAY
3711: PUSH
3712: LD_INT 1
3714: PPUSH
3715: LD_INT 3
3717: PPUSH
3718: CALL_OW 12
3722: ARRAY
3723: PPUSH
3724: LD_INT 65
3726: PPUSH
3727: LD_INT 75
3729: PPUSH
3730: CALL_OW 12
3734: PPUSH
3735: CALL 56116 0 5
// end ; veh := CreateVehicle ;
3739: LD_ADDR_VAR 0 3
3743: PUSH
3744: CALL_OW 45
3748: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3749: LD_VAR 0 3
3753: PPUSH
3754: LD_INT 3
3756: PPUSH
3757: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3761: LD_VAR 0 3
3765: PPUSH
3766: LD_INT 30
3768: PPUSH
3769: LD_INT 0
3771: PPUSH
3772: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
3776: LD_VAR 0 2
3780: PPUSH
3781: LD_VAR 0 3
3785: PPUSH
3786: CALL_OW 52
// end ;
3790: GO 3233
3792: POP
3793: POP
// if artifactArCaptured then
3794: LD_EXP 6
3798: IFFALSE 3884
// begin uc_nation := nation_american ;
3800: LD_ADDR_OWVAR 21
3804: PUSH
3805: LD_INT 1
3807: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
3808: LD_INT 3
3810: PPUSH
3811: LD_INT 3
3813: PPUSH
3814: LD_INT 3
3816: PPUSH
3817: LD_INT 12
3819: PPUSH
3820: LD_INT 100
3822: PPUSH
3823: CALL 56116 0 5
// veh := CreateVehicle ;
3827: LD_ADDR_VAR 0 3
3831: PUSH
3832: CALL_OW 45
3836: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3837: LD_VAR 0 3
3841: PPUSH
3842: LD_INT 3
3844: PPUSH
3845: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
3849: LD_VAR 0 3
3853: PPUSH
3854: LD_INT 198
3856: PPUSH
3857: LD_INT 22
3859: PPUSH
3860: LD_INT 0
3862: PPUSH
3863: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
3867: LD_VAR 0 3
3871: PPUSH
3872: LD_INT 4
3874: PPUSH
3875: LD_INT 50
3877: PPUSH
3878: CALL_OW 290
// end else
3882: GO 3903
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
3884: LD_INT 4
3886: PPUSH
3887: LD_INT 267
3889: PPUSH
3890: LD_INT 226
3892: PPUSH
3893: LD_INT 5
3895: PPUSH
3896: LD_INT 0
3898: PPUSH
3899: CALL_OW 58
// end ; uc_nation := nation_american ;
3903: LD_ADDR_OWVAR 21
3907: PUSH
3908: LD_INT 1
3910: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
3911: LD_INT 3
3913: PPUSH
3914: LD_INT 3
3916: PPUSH
3917: LD_INT 3
3919: PPUSH
3920: LD_INT 12
3922: PPUSH
3923: LD_INT 100
3925: PPUSH
3926: CALL 56116 0 5
// veh := CreateVehicle ;
3930: LD_ADDR_VAR 0 3
3934: PUSH
3935: CALL_OW 45
3939: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3940: LD_VAR 0 3
3944: PPUSH
3945: LD_INT 3
3947: PPUSH
3948: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
3952: LD_VAR 0 3
3956: PPUSH
3957: LD_INT 218
3959: PPUSH
3960: LD_INT 23
3962: PPUSH
3963: LD_INT 0
3965: PPUSH
3966: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
3970: LD_VAR 0 3
3974: PPUSH
3975: LD_INT 4
3977: PPUSH
3978: LD_INT 30
3980: PPUSH
3981: CALL_OW 290
// uc_nation := nation_russian ;
3985: LD_ADDR_OWVAR 21
3989: PUSH
3990: LD_INT 3
3992: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
3993: LD_INT 22
3995: PPUSH
3996: LD_INT 3
3998: PPUSH
3999: LD_INT 3
4001: PPUSH
4002: LD_INT 51
4004: PPUSH
4005: LD_INT 100
4007: PPUSH
4008: CALL 56116 0 5
// veh := CreateVehicle ;
4012: LD_ADDR_VAR 0 3
4016: PUSH
4017: CALL_OW 45
4021: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4022: LD_VAR 0 3
4026: PPUSH
4027: LD_INT 3
4029: PPUSH
4030: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4034: LD_VAR 0 3
4038: PPUSH
4039: LD_INT 214
4041: PPUSH
4042: LD_INT 20
4044: PPUSH
4045: LD_INT 0
4047: PPUSH
4048: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4052: LD_VAR 0 3
4056: PPUSH
4057: LD_INT 4
4059: PPUSH
4060: LD_INT 40
4062: PPUSH
4063: CALL_OW 290
// end ; end_of_file
4067: LD_VAR 0 1
4071: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4072: LD_INT 0
4074: PPUSH
4075: PPUSH
4076: PPUSH
4077: PPUSH
4078: PPUSH
4079: PPUSH
4080: PPUSH
4081: PPUSH
4082: PPUSH
4083: PPUSH
// uc_side := 1 ;
4084: LD_ADDR_OWVAR 20
4088: PUSH
4089: LD_INT 1
4091: ST_TO_ADDR
// uc_nation := 1 ;
4092: LD_ADDR_OWVAR 21
4096: PUSH
4097: LD_INT 1
4099: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4100: LD_INT 387
4102: PPUSH
4103: CALL_OW 274
4107: PPUSH
4108: LD_INT 1
4110: PPUSH
4111: LD_INT 25500
4113: PPUSH
4114: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4118: LD_INT 387
4120: PPUSH
4121: CALL_OW 274
4125: PPUSH
4126: LD_INT 2
4128: PPUSH
4129: LD_INT 4000
4131: PPUSH
4132: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4136: LD_INT 387
4138: PPUSH
4139: CALL_OW 274
4143: PPUSH
4144: LD_INT 3
4146: PPUSH
4147: LD_INT 50
4149: PPUSH
4150: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4154: LD_INT 476
4156: PPUSH
4157: CALL_OW 274
4161: PPUSH
4162: LD_INT 1
4164: PPUSH
4165: LD_INT 7500
4167: PPUSH
4168: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4172: LD_INT 476
4174: PPUSH
4175: CALL_OW 274
4179: PPUSH
4180: LD_INT 2
4182: PPUSH
4183: LD_INT 4000
4185: PPUSH
4186: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4190: LD_INT 476
4192: PPUSH
4193: CALL_OW 274
4197: PPUSH
4198: LD_INT 3
4200: PPUSH
4201: LD_INT 10
4203: PPUSH
4204: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4208: LD_ADDR_EXP 47
4212: PUSH
4213: LD_STRING Powell
4215: PPUSH
4216: CALL_OW 25
4220: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
4221: LD_EXP 47
4225: PPUSH
4226: LD_INT 57
4228: PPUSH
4229: LD_INT 94
4231: PPUSH
4232: LD_INT 0
4234: PPUSH
4235: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
4239: LD_EXP 47
4243: PPUSH
4244: LD_INT 58
4246: PPUSH
4247: LD_INT 94
4249: PPUSH
4250: CALL_OW 118
// tmp := [ ] ;
4254: LD_ADDR_VAR 0 6
4258: PUSH
4259: EMPTY
4260: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4261: LD_ADDR_EXP 14
4265: PUSH
4266: LD_STRING Lisa
4268: PPUSH
4269: LD_EXP 1
4273: NOT
4274: PPUSH
4275: LD_STRING 12p_
4277: PPUSH
4278: CALL 49365 0 3
4282: ST_TO_ADDR
// if Lisa then
4283: LD_EXP 14
4287: IFFALSE 4305
// tmp := tmp ^ Lisa ;
4289: LD_ADDR_VAR 0 6
4293: PUSH
4294: LD_VAR 0 6
4298: PUSH
4299: LD_EXP 14
4303: ADD
4304: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4305: LD_ADDR_EXP 15
4309: PUSH
4310: LD_STRING Donaldson
4312: PPUSH
4313: LD_EXP 1
4317: NOT
4318: PPUSH
4319: LD_STRING 12p_
4321: PPUSH
4322: CALL 49365 0 3
4326: ST_TO_ADDR
// if Donaldson then
4327: LD_EXP 15
4331: IFFALSE 4349
// tmp := tmp ^ Donaldson ;
4333: LD_ADDR_VAR 0 6
4337: PUSH
4338: LD_VAR 0 6
4342: PUSH
4343: LD_EXP 15
4347: ADD
4348: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4349: LD_ADDR_EXP 16
4353: PUSH
4354: LD_STRING Bobby
4356: PPUSH
4357: LD_EXP 1
4361: NOT
4362: PPUSH
4363: LD_STRING 12p_
4365: PPUSH
4366: CALL 49365 0 3
4370: ST_TO_ADDR
// if Bobby then
4371: LD_EXP 16
4375: IFFALSE 4393
// tmp := tmp ^ Bobby ;
4377: LD_ADDR_VAR 0 6
4381: PUSH
4382: LD_VAR 0 6
4386: PUSH
4387: LD_EXP 16
4391: ADD
4392: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4393: LD_ADDR_EXP 17
4397: PUSH
4398: LD_STRING Cyrus
4400: PPUSH
4401: LD_EXP 1
4405: NOT
4406: PPUSH
4407: LD_STRING 12p_
4409: PPUSH
4410: CALL 49365 0 3
4414: ST_TO_ADDR
// if Cyrus then
4415: LD_EXP 17
4419: IFFALSE 4437
// tmp := tmp ^ Cyrus ;
4421: LD_ADDR_VAR 0 6
4425: PUSH
4426: LD_VAR 0 6
4430: PUSH
4431: LD_EXP 17
4435: ADD
4436: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4437: LD_ADDR_EXP 19
4441: PUSH
4442: LD_STRING Brown
4444: PPUSH
4445: LD_EXP 1
4449: NOT
4450: PPUSH
4451: LD_STRING 12p_
4453: PPUSH
4454: CALL 49365 0 3
4458: ST_TO_ADDR
// if Brown then
4459: LD_EXP 19
4463: IFFALSE 4481
// tmp := tmp ^ Brown ;
4465: LD_ADDR_VAR 0 6
4469: PUSH
4470: LD_VAR 0 6
4474: PUSH
4475: LD_EXP 19
4479: ADD
4480: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4481: LD_ADDR_EXP 20
4485: PUSH
4486: LD_STRING Gladstone
4488: PPUSH
4489: LD_EXP 1
4493: NOT
4494: PPUSH
4495: LD_STRING 12p_
4497: PPUSH
4498: CALL 49365 0 3
4502: ST_TO_ADDR
// if Gladstone then
4503: LD_EXP 20
4507: IFFALSE 4525
// tmp := tmp ^ Gladstone ;
4509: LD_ADDR_VAR 0 6
4513: PUSH
4514: LD_VAR 0 6
4518: PUSH
4519: LD_EXP 20
4523: ADD
4524: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4525: LD_ADDR_EXP 21
4529: PUSH
4530: LD_STRING Houten
4532: PPUSH
4533: LD_EXP 1
4537: NOT
4538: PPUSH
4539: LD_STRING 12p_
4541: PPUSH
4542: CALL 49365 0 3
4546: ST_TO_ADDR
// if Houten then
4547: LD_EXP 21
4551: IFFALSE 4569
// tmp := tmp ^ Houten ;
4553: LD_ADDR_VAR 0 6
4557: PUSH
4558: LD_VAR 0 6
4562: PUSH
4563: LD_EXP 21
4567: ADD
4568: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
4569: LD_ADDR_EXP 22
4573: PUSH
4574: LD_STRING Cornel
4576: PPUSH
4577: LD_EXP 1
4581: NOT
4582: PPUSH
4583: LD_STRING 12p_
4585: PPUSH
4586: CALL 49365 0 3
4590: ST_TO_ADDR
// if Cornel then
4591: LD_EXP 22
4595: IFFALSE 4613
// tmp := tmp ^ Cornel ;
4597: LD_ADDR_VAR 0 6
4601: PUSH
4602: LD_VAR 0 6
4606: PUSH
4607: LD_EXP 22
4611: ADD
4612: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
4613: LD_ADDR_EXP 23
4617: PUSH
4618: LD_STRING Gary
4620: PPUSH
4621: LD_EXP 1
4625: NOT
4626: PPUSH
4627: LD_STRING 12p_
4629: PPUSH
4630: CALL 49365 0 3
4634: ST_TO_ADDR
// if Gary then
4635: LD_EXP 23
4639: IFFALSE 4657
// tmp := tmp ^ Gary ;
4641: LD_ADDR_VAR 0 6
4645: PUSH
4646: LD_VAR 0 6
4650: PUSH
4651: LD_EXP 23
4655: ADD
4656: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
4657: LD_ADDR_EXP 25
4661: PUSH
4662: LD_STRING Kikuchi
4664: PPUSH
4665: LD_EXP 1
4669: NOT
4670: PPUSH
4671: LD_STRING 12p_
4673: PPUSH
4674: CALL 49365 0 3
4678: ST_TO_ADDR
// if Kikuchi then
4679: LD_EXP 25
4683: IFFALSE 4701
// tmp := tmp ^ Kikuchi ;
4685: LD_ADDR_VAR 0 6
4689: PUSH
4690: LD_VAR 0 6
4694: PUSH
4695: LD_EXP 25
4699: ADD
4700: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
4701: LD_ADDR_VAR 0 6
4705: PUSH
4706: LD_VAR 0 6
4710: PUSH
4711: LD_STRING 12p_others
4713: PPUSH
4714: CALL_OW 31
4718: UNION
4719: ST_TO_ADDR
// if tmp < 36 then
4720: LD_VAR 0 6
4724: PUSH
4725: LD_INT 36
4727: LESS
4728: IFFALSE 4795
// for i = 1 to 36 - tmp do
4730: LD_ADDR_VAR 0 2
4734: PUSH
4735: DOUBLE
4736: LD_INT 1
4738: DEC
4739: ST_TO_ADDR
4740: LD_INT 36
4742: PUSH
4743: LD_VAR 0 6
4747: MINUS
4748: PUSH
4749: FOR_TO
4750: IFFALSE 4793
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
4752: LD_INT 1
4754: PPUSH
4755: LD_VAR 0 2
4759: PUSH
4760: LD_INT 4
4762: MOD
4763: PUSH
4764: LD_INT 1
4766: PLUS
4767: PPUSH
4768: LD_INT 10
4770: PPUSH
4771: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
4775: LD_ADDR_VAR 0 6
4779: PUSH
4780: LD_VAR 0 6
4784: PUSH
4785: CALL_OW 44
4789: ADD
4790: ST_TO_ADDR
// end ;
4791: GO 4749
4793: POP
4794: POP
// for i in tmp do
4795: LD_ADDR_VAR 0 2
4799: PUSH
4800: LD_VAR 0 6
4804: PUSH
4805: FOR_IN
4806: IFFALSE 4831
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
4808: LD_VAR 0 2
4812: PPUSH
4813: LD_INT 62
4815: PPUSH
4816: LD_INT 93
4818: PPUSH
4819: LD_INT 9
4821: PPUSH
4822: LD_INT 0
4824: PPUSH
4825: CALL_OW 50
4829: GO 4805
4831: POP
4832: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
4833: LD_ADDR_EXP 74
4837: PUSH
4838: LD_EXP 74
4842: PPUSH
4843: LD_INT 4
4845: PPUSH
4846: LD_INT 22
4848: PUSH
4849: LD_INT 1
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PPUSH
4856: CALL_OW 69
4860: PPUSH
4861: CALL_OW 1
4865: ST_TO_ADDR
// uc_side := 0 ;
4866: LD_ADDR_OWVAR 20
4870: PUSH
4871: LD_INT 0
4873: ST_TO_ADDR
// uc_nation := 0 ;
4874: LD_ADDR_OWVAR 21
4878: PUSH
4879: LD_INT 0
4881: ST_TO_ADDR
// for i = 1 to 4 do
4882: LD_ADDR_VAR 0 2
4886: PUSH
4887: DOUBLE
4888: LD_INT 1
4890: DEC
4891: ST_TO_ADDR
4892: LD_INT 4
4894: PUSH
4895: FOR_TO
4896: IFFALSE 4927
// begin InitHc ;
4898: CALL_OW 19
// hc_class := class_apeman ;
4902: LD_ADDR_OWVAR 28
4906: PUSH
4907: LD_INT 12
4909: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4910: CALL_OW 44
4914: PPUSH
4915: LD_INT 11
4917: PPUSH
4918: LD_INT 0
4920: PPUSH
4921: CALL_OW 49
// end ;
4925: GO 4895
4927: POP
4928: POP
// end ;
4929: LD_VAR 0 1
4933: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
4934: LD_EXP 4
4938: NOT
4939: PUSH
4940: LD_INT 4
4942: PPUSH
4943: LD_INT 1
4945: PPUSH
4946: CALL 44573 0 2
4950: NOT
4951: AND
4952: IFFALSE 5724
4954: GO 4956
4956: DISABLE
4957: LD_INT 0
4959: PPUSH
4960: PPUSH
4961: PPUSH
// begin enable ;
4962: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
4963: LD_INT 22
4965: PUSH
4966: LD_INT 1
4968: PUSH
4969: EMPTY
4970: LIST
4971: LIST
4972: PUSH
4973: LD_INT 23
4975: PUSH
4976: LD_INT 1
4978: PUSH
4979: EMPTY
4980: LIST
4981: LIST
4982: PUSH
4983: LD_INT 30
4985: PUSH
4986: LD_INT 3
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 69
5002: NOT
5003: IFFALSE 5007
// exit ;
5005: GO 5724
// if Prob ( 40 ) then
5007: LD_INT 40
5009: PPUSH
5010: CALL_OW 13
5014: IFFALSE 5141
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5016: LD_INT 4
5018: PPUSH
5019: LD_INT 5
5021: PUSH
5022: LD_INT 1
5024: PUSH
5025: LD_INT 2
5027: PUSH
5028: LD_INT 7
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: LIST
5035: LIST
5036: PUSH
5037: LD_INT 5
5039: PUSH
5040: LD_INT 1
5042: PUSH
5043: LD_INT 2
5045: PUSH
5046: LD_INT 7
5048: PUSH
5049: EMPTY
5050: LIST
5051: LIST
5052: LIST
5053: LIST
5054: PUSH
5055: LD_INT 5
5057: PUSH
5058: LD_INT 1
5060: PUSH
5061: LD_INT 2
5063: PUSH
5064: LD_INT 7
5066: PUSH
5067: EMPTY
5068: LIST
5069: LIST
5070: LIST
5071: LIST
5072: PUSH
5073: LD_INT 5
5075: PUSH
5076: LD_INT 1
5078: PUSH
5079: LD_INT 2
5081: PUSH
5082: LD_INT 6
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: LIST
5089: LIST
5090: PUSH
5091: LD_INT 5
5093: PUSH
5094: LD_INT 1
5096: PUSH
5097: LD_INT 2
5099: PUSH
5100: LD_INT 6
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: LIST
5107: LIST
5108: PUSH
5109: LD_INT 5
5111: PUSH
5112: LD_INT 1
5114: PUSH
5115: LD_INT 2
5117: PUSH
5118: LD_INT 6
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: LIST
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: LIST
5132: LIST
5133: LIST
5134: PPUSH
5135: CALL 43155 0 2
// end else
5139: GO 5264
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5141: LD_INT 4
5143: PPUSH
5144: LD_INT 5
5146: PUSH
5147: LD_INT 1
5149: PUSH
5150: LD_INT 2
5152: PUSH
5153: LD_INT 7
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: PUSH
5162: LD_INT 5
5164: PUSH
5165: LD_INT 1
5167: PUSH
5168: LD_INT 2
5170: PUSH
5171: LD_INT 9
5173: PUSH
5174: EMPTY
5175: LIST
5176: LIST
5177: LIST
5178: LIST
5179: PUSH
5180: LD_INT 5
5182: PUSH
5183: LD_INT 1
5185: PUSH
5186: LD_INT 2
5188: PUSH
5189: LD_INT 9
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: LIST
5196: LIST
5197: PUSH
5198: LD_INT 5
5200: PUSH
5201: LD_INT 1
5203: PUSH
5204: LD_INT 2
5206: PUSH
5207: LD_INT 6
5209: PUSH
5210: EMPTY
5211: LIST
5212: LIST
5213: LIST
5214: LIST
5215: PUSH
5216: LD_INT 5
5218: PUSH
5219: LD_INT 1
5221: PUSH
5222: LD_INT 2
5224: PUSH
5225: LD_INT 6
5227: PUSH
5228: EMPTY
5229: LIST
5230: LIST
5231: LIST
5232: LIST
5233: PUSH
5234: LD_INT 5
5236: PUSH
5237: LD_INT 1
5239: PUSH
5240: LD_INT 2
5242: PUSH
5243: LD_INT 6
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: LIST
5250: LIST
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: LIST
5257: LIST
5258: LIST
5259: PPUSH
5260: CALL 43155 0 2
// end ; repeat wait ( 0 0$1 ) ;
5264: LD_INT 35
5266: PPUSH
5267: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5271: LD_INT 4
5273: PPUSH
5274: LD_INT 1
5276: PPUSH
5277: CALL 44573 0 2
5281: PUSH
5282: LD_INT 6
5284: GREATEREQUAL
5285: IFFALSE 5264
// wait ( 0 0$30 ) ;
5287: LD_INT 1050
5289: PPUSH
5290: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5294: LD_ADDR_VAR 0 2
5298: PUSH
5299: LD_INT 4
5301: PPUSH
5302: LD_INT 1
5304: PPUSH
5305: CALL 44573 0 2
5309: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5310: LD_ADDR_EXP 93
5314: PUSH
5315: LD_EXP 93
5319: PPUSH
5320: LD_INT 4
5322: PPUSH
5323: LD_EXP 93
5327: PUSH
5328: LD_INT 4
5330: ARRAY
5331: PUSH
5332: LD_VAR 0 2
5336: DIFF
5337: PPUSH
5338: CALL_OW 1
5342: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5343: LD_ADDR_VAR 0 3
5347: PUSH
5348: LD_INT 0
5350: PPUSH
5351: LD_INT 2
5353: PPUSH
5354: CALL_OW 12
5358: ST_TO_ADDR
// if target then
5359: LD_VAR 0 3
5363: IFFALSE 5491
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5365: LD_ADDR_VAR 0 2
5369: PUSH
5370: LD_VAR 0 2
5374: PPUSH
5375: LD_INT 24
5377: PUSH
5378: LD_INT 250
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PPUSH
5385: CALL_OW 72
5389: ST_TO_ADDR
// for i in tmp do
5390: LD_ADDR_VAR 0 1
5394: PUSH
5395: LD_VAR 0 2
5399: PUSH
5400: FOR_IN
5401: IFFALSE 5441
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5403: LD_VAR 0 1
5407: PPUSH
5408: LD_INT 114
5410: PPUSH
5411: LD_INT 108
5413: PPUSH
5414: CALL_OW 297
5418: PUSH
5419: LD_INT 9
5421: GREATER
5422: IFFALSE 5439
// ComMoveXY ( i , 114 , 108 ) ;
5424: LD_VAR 0 1
5428: PPUSH
5429: LD_INT 114
5431: PPUSH
5432: LD_INT 108
5434: PPUSH
5435: CALL_OW 111
5439: GO 5400
5441: POP
5442: POP
// wait ( 0 0$1 ) ;
5443: LD_INT 35
5445: PPUSH
5446: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5450: LD_VAR 0 2
5454: PPUSH
5455: LD_INT 92
5457: PUSH
5458: LD_INT 114
5460: PUSH
5461: LD_INT 108
5463: PUSH
5464: LD_INT 9
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: PPUSH
5473: CALL_OW 72
5477: PUSH
5478: LD_VAR 0 2
5482: PUSH
5483: LD_INT 1
5485: MINUS
5486: GREATEREQUAL
5487: IFFALSE 5365
// end else
5489: GO 5615
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5491: LD_ADDR_VAR 0 2
5495: PUSH
5496: LD_VAR 0 2
5500: PPUSH
5501: LD_INT 24
5503: PUSH
5504: LD_INT 250
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: PPUSH
5511: CALL_OW 72
5515: ST_TO_ADDR
// for i in tmp do
5516: LD_ADDR_VAR 0 1
5520: PUSH
5521: LD_VAR 0 2
5525: PUSH
5526: FOR_IN
5527: IFFALSE 5567
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5529: LD_VAR 0 1
5533: PPUSH
5534: LD_INT 129
5536: PPUSH
5537: LD_INT 139
5539: PPUSH
5540: CALL_OW 297
5544: PUSH
5545: LD_INT 9
5547: GREATER
5548: IFFALSE 5565
// ComMoveXY ( i , 129 , 139 ) ;
5550: LD_VAR 0 1
5554: PPUSH
5555: LD_INT 129
5557: PPUSH
5558: LD_INT 139
5560: PPUSH
5561: CALL_OW 111
5565: GO 5526
5567: POP
5568: POP
// wait ( 0 0$1 ) ;
5569: LD_INT 35
5571: PPUSH
5572: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
5576: LD_VAR 0 2
5580: PPUSH
5581: LD_INT 92
5583: PUSH
5584: LD_INT 129
5586: PUSH
5587: LD_INT 139
5589: PUSH
5590: LD_INT 9
5592: PUSH
5593: EMPTY
5594: LIST
5595: LIST
5596: LIST
5597: LIST
5598: PPUSH
5599: CALL_OW 72
5603: PUSH
5604: LD_VAR 0 2
5608: PUSH
5609: LD_INT 1
5611: MINUS
5612: GREATEREQUAL
5613: IFFALSE 5491
// end ; repeat wait ( 0 0$1 ) ;
5615: LD_INT 35
5617: PPUSH
5618: CALL_OW 67
// for i in tmp do
5622: LD_ADDR_VAR 0 1
5626: PUSH
5627: LD_VAR 0 2
5631: PUSH
5632: FOR_IN
5633: IFFALSE 5715
// begin if GetLives ( i ) > 251 then
5635: LD_VAR 0 1
5639: PPUSH
5640: CALL_OW 256
5644: PUSH
5645: LD_INT 251
5647: GREATER
5648: IFFALSE 5686
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
5650: LD_VAR 0 1
5654: PPUSH
5655: LD_INT 81
5657: PUSH
5658: LD_INT 1
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: PPUSH
5665: CALL_OW 69
5669: PPUSH
5670: LD_VAR 0 1
5674: PPUSH
5675: CALL_OW 74
5679: PPUSH
5680: CALL_OW 115
5684: GO 5713
// if IsDead ( i ) then
5686: LD_VAR 0 1
5690: PPUSH
5691: CALL_OW 301
5695: IFFALSE 5713
// tmp := tmp diff i ;
5697: LD_ADDR_VAR 0 2
5701: PUSH
5702: LD_VAR 0 2
5706: PUSH
5707: LD_VAR 0 1
5711: DIFF
5712: ST_TO_ADDR
// end ;
5713: GO 5632
5715: POP
5716: POP
// until not tmp ;
5717: LD_VAR 0 2
5721: NOT
5722: IFFALSE 5615
// end ;
5724: PPOPN 3
5726: END
// every 30 30$00 trigger not americanDestroyed do
5727: LD_EXP 4
5731: NOT
5732: IFFALSE 5797
5734: GO 5736
5736: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
5737: LD_INT 63000
5739: PUSH
5740: LD_INT 42000
5742: PUSH
5743: LD_INT 21000
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: LIST
5750: PUSH
5751: LD_OWVAR 67
5755: ARRAY
5756: PPUSH
5757: CALL_OW 67
// if americanDestroyed then
5761: LD_EXP 4
5765: IFFALSE 5769
// exit ;
5767: GO 5797
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
5769: LD_INT 4
5771: PPUSH
5772: LD_INT 5
5774: PUSH
5775: LD_INT 3
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 8
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: LIST
5788: LIST
5789: PUSH
5790: EMPTY
5791: LIST
5792: PPUSH
5793: CALL 43155 0 2
// end ; end_of_file
5797: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
5798: LD_INT 0
5800: PPUSH
5801: PPUSH
5802: PPUSH
5803: PPUSH
5804: PPUSH
// side := 2 ;
5805: LD_ADDR_VAR 0 5
5809: PUSH
5810: LD_INT 2
5812: ST_TO_ADDR
// uc_side := side ;
5813: LD_ADDR_OWVAR 20
5817: PUSH
5818: LD_VAR 0 5
5822: ST_TO_ADDR
// uc_nation := 2 ;
5823: LD_ADDR_OWVAR 21
5827: PUSH
5828: LD_INT 2
5830: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
5831: LD_ADDR_VAR 0 4
5835: PUSH
5836: LD_INT 22
5838: PUSH
5839: LD_VAR 0 5
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: PUSH
5848: LD_INT 30
5850: PUSH
5851: LD_INT 32
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 58
5860: PUSH
5861: EMPTY
5862: LIST
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: PPUSH
5869: CALL_OW 69
5873: ST_TO_ADDR
// for i = 1 to 10 do
5874: LD_ADDR_VAR 0 2
5878: PUSH
5879: DOUBLE
5880: LD_INT 1
5882: DEC
5883: ST_TO_ADDR
5884: LD_INT 10
5886: PUSH
5887: FOR_TO
5888: IFFALSE 5960
// begin uc_nation := nation_nature ;
5890: LD_ADDR_OWVAR 21
5894: PUSH
5895: LD_INT 0
5897: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5898: LD_ADDR_OWVAR 28
5902: PUSH
5903: LD_INT 15
5905: ST_TO_ADDR
// hc_gallery :=  ;
5906: LD_ADDR_OWVAR 33
5910: PUSH
5911: LD_STRING 
5913: ST_TO_ADDR
// hc_name :=  ;
5914: LD_ADDR_OWVAR 26
5918: PUSH
5919: LD_STRING 
5921: ST_TO_ADDR
// un := CreateHuman ;
5922: LD_ADDR_VAR 0 3
5926: PUSH
5927: CALL_OW 44
5931: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5932: LD_VAR 0 3
5936: PPUSH
5937: LD_VAR 0 4
5941: PUSH
5942: LD_VAR 0 4
5946: PUSH
5947: LD_VAR 0 2
5951: MINUS
5952: ARRAY
5953: PPUSH
5954: CALL_OW 52
// end ;
5958: GO 5887
5960: POP
5961: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
5962: LD_INT 503
5964: PPUSH
5965: LD_INT 27
5967: PPUSH
5968: LD_STRING 
5970: PPUSH
5971: LD_INT 8
5973: PUSH
5974: LD_INT 9
5976: PUSH
5977: LD_INT 10
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: LIST
5984: PUSH
5985: LD_OWVAR 67
5989: ARRAY
5990: PPUSH
5991: LD_INT 3000
5993: PUSH
5994: LD_INT 500
5996: PUSH
5997: LD_INT 150
5999: PUSH
6000: EMPTY
6001: LIST
6002: LIST
6003: LIST
6004: PPUSH
6005: LD_INT 16
6007: PUSH
6008: LD_INT 6
6010: PUSH
6011: LD_INT 6
6013: PUSH
6014: LD_INT 6
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 59525 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6027: LD_ADDR_EXP 74
6031: PUSH
6032: LD_EXP 74
6036: PPUSH
6037: LD_INT 1
6039: PPUSH
6040: LD_INT 22
6042: PUSH
6043: LD_VAR 0 5
6047: PUSH
6048: EMPTY
6049: LIST
6050: LIST
6051: PUSH
6052: LD_INT 23
6054: PUSH
6055: LD_INT 2
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PUSH
6062: LD_INT 3
6064: PUSH
6065: LD_INT 21
6067: PUSH
6068: LD_INT 2
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: LIST
6083: PPUSH
6084: CALL_OW 69
6088: PPUSH
6089: CALL_OW 1
6093: ST_TO_ADDR
// end ;
6094: LD_VAR 0 1
6098: RET
// export Omar ; export function PrepareOmarAli ; begin
6099: LD_INT 0
6101: PPUSH
// uc_side := 5 ;
6102: LD_ADDR_OWVAR 20
6106: PUSH
6107: LD_INT 5
6109: ST_TO_ADDR
// uc_nation := 2 ;
6110: LD_ADDR_OWVAR 21
6114: PUSH
6115: LD_INT 2
6117: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6118: LD_ADDR_EXP 48
6122: PUSH
6123: LD_STRING Omar
6125: PPUSH
6126: CALL_OW 25
6130: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6131: LD_EXP 48
6135: PPUSH
6136: LD_INT 330
6138: PPUSH
6139: LD_INT 244
6141: PPUSH
6142: LD_INT 0
6144: PPUSH
6145: CALL_OW 48
// ComMoveUnit ( Omar , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Omar ) ) ;
6149: LD_EXP 48
6153: PPUSH
6154: LD_INT 22
6156: PUSH
6157: LD_INT 7
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: PPUSH
6164: CALL_OW 69
6168: PPUSH
6169: LD_EXP 48
6173: PPUSH
6174: CALL_OW 74
6178: PPUSH
6179: CALL_OW 112
// end ; end_of_file
6183: LD_VAR 0 1
6187: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6188: LD_INT 0
6190: PPUSH
6191: PPUSH
6192: PPUSH
6193: PPUSH
6194: PPUSH
// side := 8 ;
6195: LD_ADDR_VAR 0 3
6199: PUSH
6200: LD_INT 8
6202: ST_TO_ADDR
// uc_side := side ;
6203: LD_ADDR_OWVAR 20
6207: PUSH
6208: LD_VAR 0 3
6212: ST_TO_ADDR
// uc_nation := 2 ;
6213: LD_ADDR_OWVAR 21
6217: PUSH
6218: LD_INT 2
6220: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6221: LD_ADDR_VAR 0 2
6225: PUSH
6226: LD_INT 22
6228: PUSH
6229: LD_VAR 0 3
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 21
6240: PUSH
6241: LD_INT 3
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: PPUSH
6252: CALL_OW 69
6256: PUSH
6257: FOR_IN
6258: IFFALSE 6274
// SetBLevel ( i , 10 ) ;
6260: LD_VAR 0 2
6264: PPUSH
6265: LD_INT 10
6267: PPUSH
6268: CALL_OW 241
6272: GO 6257
6274: POP
6275: POP
// Schulz := PrepareUnit ( Schulz , false ,  ) ;
6276: LD_ADDR_EXP 49
6280: PUSH
6281: LD_STRING Schulz
6283: PPUSH
6284: LD_INT 0
6286: PPUSH
6287: LD_STRING 
6289: PPUSH
6290: CALL 49365 0 3
6294: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6295: LD_ADDR_EXP 50
6299: PUSH
6300: LD_STRING Kozlov
6302: PPUSH
6303: LD_INT 0
6305: PPUSH
6306: LD_STRING 
6308: PPUSH
6309: CALL 49365 0 3
6313: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6314: LD_EXP 50
6318: PPUSH
6319: LD_INT 22
6321: PUSH
6322: LD_INT 8
6324: PUSH
6325: EMPTY
6326: LIST
6327: LIST
6328: PUSH
6329: LD_INT 23
6331: PUSH
6332: LD_INT 3
6334: PUSH
6335: EMPTY
6336: LIST
6337: LIST
6338: PUSH
6339: LD_INT 30
6341: PUSH
6342: LD_INT 8
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PUSH
6349: EMPTY
6350: LIST
6351: LIST
6352: LIST
6353: PPUSH
6354: CALL_OW 69
6358: PUSH
6359: LD_INT 1
6361: ARRAY
6362: PPUSH
6363: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6367: LD_EXP 50
6371: PPUSH
6372: LD_INT 3
6374: PPUSH
6375: LD_INT 10
6377: PPUSH
6378: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6382: LD_ADDR_VAR 0 5
6386: PUSH
6387: LD_INT 22
6389: PUSH
6390: LD_VAR 0 3
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 30
6401: PUSH
6402: LD_INT 32
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: LD_INT 58
6411: PUSH
6412: EMPTY
6413: LIST
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: LIST
6419: PPUSH
6420: CALL_OW 69
6424: ST_TO_ADDR
// for i = 1 to 10 do
6425: LD_ADDR_VAR 0 2
6429: PUSH
6430: DOUBLE
6431: LD_INT 1
6433: DEC
6434: ST_TO_ADDR
6435: LD_INT 10
6437: PUSH
6438: FOR_TO
6439: IFFALSE 6511
// begin uc_nation := nation_nature ;
6441: LD_ADDR_OWVAR 21
6445: PUSH
6446: LD_INT 0
6448: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6449: LD_ADDR_OWVAR 28
6453: PUSH
6454: LD_INT 15
6456: ST_TO_ADDR
// hc_gallery :=  ;
6457: LD_ADDR_OWVAR 33
6461: PUSH
6462: LD_STRING 
6464: ST_TO_ADDR
// hc_name :=  ;
6465: LD_ADDR_OWVAR 26
6469: PUSH
6470: LD_STRING 
6472: ST_TO_ADDR
// un := CreateHuman ;
6473: LD_ADDR_VAR 0 4
6477: PUSH
6478: CALL_OW 44
6482: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6483: LD_VAR 0 4
6487: PPUSH
6488: LD_VAR 0 5
6492: PUSH
6493: LD_VAR 0 5
6497: PUSH
6498: LD_VAR 0 2
6502: MINUS
6503: ARRAY
6504: PPUSH
6505: CALL_OW 52
// end ;
6509: GO 6438
6511: POP
6512: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6513: LD_INT 324
6515: PPUSH
6516: LD_INT 3
6518: PPUSH
6519: LD_STRING 
6521: PPUSH
6522: LD_INT 8
6524: PUSH
6525: LD_INT 9
6527: PUSH
6528: LD_INT 10
6530: PUSH
6531: EMPTY
6532: LIST
6533: LIST
6534: LIST
6535: PUSH
6536: LD_OWVAR 67
6540: ARRAY
6541: PPUSH
6542: LD_INT 3000
6544: PUSH
6545: LD_INT 500
6547: PUSH
6548: LD_INT 150
6550: PUSH
6551: EMPTY
6552: LIST
6553: LIST
6554: LIST
6555: PPUSH
6556: LD_INT 16
6558: PUSH
6559: LD_INT 6
6561: PUSH
6562: LD_INT 6
6564: PUSH
6565: LD_INT 8
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PPUSH
6574: CALL 59525 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
6578: LD_ADDR_EXP 74
6582: PUSH
6583: LD_EXP 74
6587: PPUSH
6588: LD_INT 3
6590: PPUSH
6591: LD_INT 22
6593: PUSH
6594: LD_VAR 0 3
6598: PUSH
6599: EMPTY
6600: LIST
6601: LIST
6602: PUSH
6603: LD_INT 23
6605: PUSH
6606: LD_INT 2
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: PUSH
6613: LD_INT 3
6615: PUSH
6616: LD_INT 21
6618: PUSH
6619: LD_INT 2
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: PUSH
6626: EMPTY
6627: LIST
6628: LIST
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: PPUSH
6635: CALL_OW 69
6639: PUSH
6640: LD_EXP 49
6644: DIFF
6645: PPUSH
6646: CALL_OW 1
6650: ST_TO_ADDR
// end ;
6651: LD_VAR 0 1
6655: RET
// export function BuildKozlovBomb ; begin
6656: LD_INT 0
6658: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
6659: LD_INT 332
6661: PPUSH
6662: CALL_OW 302
6666: NOT
6667: PUSH
6668: LD_INT 336
6670: PPUSH
6671: CALL_OW 302
6675: NOT
6676: OR
6677: IFFALSE 6681
// exit ;
6679: GO 6778
// ComChangeProfession ( Kozlov , 4 ) ;
6681: LD_EXP 50
6685: PPUSH
6686: LD_INT 4
6688: PPUSH
6689: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
6693: LD_INT 336
6695: PPUSH
6696: LD_INT 25
6698: PPUSH
6699: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
6703: LD_INT 35
6705: PPUSH
6706: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
6710: LD_INT 25
6712: PPUSH
6713: LD_INT 8
6715: PPUSH
6716: CALL_OW 321
6720: PUSH
6721: LD_INT 2
6723: EQUAL
6724: IFFALSE 6703
// ComExitBuilding ( Kozlov ) ;
6726: LD_EXP 50
6730: PPUSH
6731: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
6735: LD_EXP 50
6739: PPUSH
6740: LD_INT 332
6742: PPUSH
6743: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
6747: LD_EXP 50
6751: PPUSH
6752: LD_INT 3
6754: PPUSH
6755: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
6759: LD_INT 332
6761: PPUSH
6762: LD_INT 23
6764: PPUSH
6765: LD_INT 3
6767: PPUSH
6768: LD_INT 1
6770: PPUSH
6771: LD_INT 48
6773: PPUSH
6774: CALL_OW 125
// end ;
6778: LD_VAR 0 1
6782: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
6783: LD_EXP 3
6787: NOT
6788: PUSH
6789: LD_INT 3
6791: PPUSH
6792: LD_INT 1
6794: PPUSH
6795: CALL 44573 0 2
6799: NOT
6800: AND
6801: IFFALSE 7641
6803: GO 6805
6805: DISABLE
6806: LD_INT 0
6808: PPUSH
6809: PPUSH
6810: PPUSH
// begin enable ;
6811: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6812: LD_INT 22
6814: PUSH
6815: LD_INT 8
6817: PUSH
6818: EMPTY
6819: LIST
6820: LIST
6821: PUSH
6822: LD_INT 23
6824: PUSH
6825: LD_INT 2
6827: PUSH
6828: EMPTY
6829: LIST
6830: LIST
6831: PUSH
6832: LD_INT 30
6834: PUSH
6835: LD_INT 3
6837: PUSH
6838: EMPTY
6839: LIST
6840: LIST
6841: PUSH
6842: EMPTY
6843: LIST
6844: LIST
6845: LIST
6846: PPUSH
6847: CALL_OW 69
6851: NOT
6852: IFFALSE 6856
// exit ;
6854: GO 7641
// if Prob ( 40 ) then
6856: LD_INT 40
6858: PPUSH
6859: CALL_OW 13
6863: IFFALSE 6990
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6865: LD_INT 3
6867: PPUSH
6868: LD_INT 14
6870: PUSH
6871: LD_INT 1
6873: PUSH
6874: LD_INT 2
6876: PUSH
6877: LD_INT 28
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: LIST
6884: LIST
6885: PUSH
6886: LD_INT 14
6888: PUSH
6889: LD_INT 1
6891: PUSH
6892: LD_INT 2
6894: PUSH
6895: LD_INT 28
6897: PUSH
6898: EMPTY
6899: LIST
6900: LIST
6901: LIST
6902: LIST
6903: PUSH
6904: LD_INT 14
6906: PUSH
6907: LD_INT 1
6909: PUSH
6910: LD_INT 2
6912: PUSH
6913: LD_INT 28
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: LIST
6920: LIST
6921: PUSH
6922: LD_INT 14
6924: PUSH
6925: LD_INT 1
6927: PUSH
6928: LD_INT 2
6930: PUSH
6931: LD_INT 28
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: LIST
6938: LIST
6939: PUSH
6940: LD_INT 14
6942: PUSH
6943: LD_INT 1
6945: PUSH
6946: LD_INT 2
6948: PUSH
6949: LD_INT 28
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: LIST
6956: LIST
6957: PUSH
6958: LD_INT 14
6960: PUSH
6961: LD_INT 1
6963: PUSH
6964: LD_INT 2
6966: PUSH
6967: LD_INT 26
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: LIST
6974: LIST
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: LIST
6980: LIST
6981: LIST
6982: LIST
6983: PPUSH
6984: CALL 43155 0 2
// end else
6988: GO 7181
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6990: LD_INT 3
6992: PPUSH
6993: LD_INT 14
6995: PUSH
6996: LD_INT 1
6998: PUSH
6999: LD_INT 2
7001: PUSH
7002: LD_INT 27
7004: PUSH
7005: LD_INT 26
7007: PUSH
7008: LD_INT 26
7010: PUSH
7011: EMPTY
7012: LIST
7013: LIST
7014: LIST
7015: PUSH
7016: LD_OWVAR 67
7020: ARRAY
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: LIST
7026: LIST
7027: PUSH
7028: LD_INT 14
7030: PUSH
7031: LD_INT 1
7033: PUSH
7034: LD_INT 2
7036: PUSH
7037: LD_INT 27
7039: PUSH
7040: LD_INT 26
7042: PUSH
7043: LD_INT 26
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: PUSH
7051: LD_OWVAR 67
7055: ARRAY
7056: PUSH
7057: EMPTY
7058: LIST
7059: LIST
7060: LIST
7061: LIST
7062: PUSH
7063: LD_INT 14
7065: PUSH
7066: LD_INT 1
7068: PUSH
7069: LD_INT 2
7071: PUSH
7072: LD_INT 26
7074: PUSH
7075: LD_INT 26
7077: PUSH
7078: LD_INT 29
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: PUSH
7086: LD_OWVAR 67
7090: ARRAY
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: LIST
7096: LIST
7097: PUSH
7098: LD_INT 13
7100: PUSH
7101: LD_INT 1
7103: PUSH
7104: LD_INT 2
7106: PUSH
7107: LD_INT 26
7109: PUSH
7110: LD_INT 29
7112: PUSH
7113: LD_INT 29
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: PUSH
7121: LD_OWVAR 67
7125: ARRAY
7126: PUSH
7127: EMPTY
7128: LIST
7129: LIST
7130: LIST
7131: LIST
7132: PUSH
7133: LD_INT 13
7135: PUSH
7136: LD_INT 1
7138: PUSH
7139: LD_INT 2
7141: PUSH
7142: LD_INT 29
7144: PUSH
7145: EMPTY
7146: LIST
7147: LIST
7148: LIST
7149: LIST
7150: PUSH
7151: LD_INT 14
7153: PUSH
7154: LD_INT 1
7156: PUSH
7157: LD_INT 2
7159: PUSH
7160: LD_INT 26
7162: PUSH
7163: EMPTY
7164: LIST
7165: LIST
7166: LIST
7167: LIST
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: LIST
7176: PPUSH
7177: CALL 43155 0 2
// end ; repeat wait ( 0 0$1 ) ;
7181: LD_INT 35
7183: PPUSH
7184: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7188: LD_INT 3
7190: PPUSH
7191: LD_INT 1
7193: PPUSH
7194: CALL 44573 0 2
7198: PUSH
7199: LD_INT 6
7201: GREATEREQUAL
7202: IFFALSE 7181
// wait ( 0 0$30 ) ;
7204: LD_INT 1050
7206: PPUSH
7207: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7211: LD_ADDR_VAR 0 2
7215: PUSH
7216: LD_INT 3
7218: PPUSH
7219: LD_INT 1
7221: PPUSH
7222: CALL 44573 0 2
7226: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7227: LD_ADDR_EXP 93
7231: PUSH
7232: LD_EXP 93
7236: PPUSH
7237: LD_INT 3
7239: PPUSH
7240: LD_EXP 93
7244: PUSH
7245: LD_INT 3
7247: ARRAY
7248: PUSH
7249: LD_VAR 0 2
7253: DIFF
7254: PPUSH
7255: CALL_OW 1
7259: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7260: LD_ADDR_VAR 0 3
7264: PUSH
7265: LD_INT 0
7267: PPUSH
7268: LD_INT 2
7270: PPUSH
7271: CALL_OW 12
7275: ST_TO_ADDR
// if target then
7276: LD_VAR 0 3
7280: IFFALSE 7408
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7282: LD_ADDR_VAR 0 2
7286: PUSH
7287: LD_VAR 0 2
7291: PPUSH
7292: LD_INT 24
7294: PUSH
7295: LD_INT 250
7297: PUSH
7298: EMPTY
7299: LIST
7300: LIST
7301: PPUSH
7302: CALL_OW 72
7306: ST_TO_ADDR
// for i in tmp do
7307: LD_ADDR_VAR 0 1
7311: PUSH
7312: LD_VAR 0 2
7316: PUSH
7317: FOR_IN
7318: IFFALSE 7358
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7320: LD_VAR 0 1
7324: PPUSH
7325: LD_INT 89
7327: PPUSH
7328: LD_INT 71
7330: PPUSH
7331: CALL_OW 297
7335: PUSH
7336: LD_INT 9
7338: GREATER
7339: IFFALSE 7356
// ComMoveXY ( i , 89 , 71 ) ;
7341: LD_VAR 0 1
7345: PPUSH
7346: LD_INT 89
7348: PPUSH
7349: LD_INT 71
7351: PPUSH
7352: CALL_OW 111
7356: GO 7317
7358: POP
7359: POP
// wait ( 0 0$1 ) ;
7360: LD_INT 35
7362: PPUSH
7363: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7367: LD_VAR 0 2
7371: PPUSH
7372: LD_INT 92
7374: PUSH
7375: LD_INT 89
7377: PUSH
7378: LD_INT 71
7380: PUSH
7381: LD_INT 9
7383: PUSH
7384: EMPTY
7385: LIST
7386: LIST
7387: LIST
7388: LIST
7389: PPUSH
7390: CALL_OW 72
7394: PUSH
7395: LD_VAR 0 2
7399: PUSH
7400: LD_INT 1
7402: MINUS
7403: GREATEREQUAL
7404: IFFALSE 7282
// end else
7406: GO 7532
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7408: LD_ADDR_VAR 0 2
7412: PUSH
7413: LD_VAR 0 2
7417: PPUSH
7418: LD_INT 24
7420: PUSH
7421: LD_INT 250
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: PPUSH
7428: CALL_OW 72
7432: ST_TO_ADDR
// for i in tmp do
7433: LD_ADDR_VAR 0 1
7437: PUSH
7438: LD_VAR 0 2
7442: PUSH
7443: FOR_IN
7444: IFFALSE 7484
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7446: LD_VAR 0 1
7450: PPUSH
7451: LD_INT 147
7453: PPUSH
7454: LD_INT 4
7456: PPUSH
7457: CALL_OW 297
7461: PUSH
7462: LD_INT 9
7464: GREATER
7465: IFFALSE 7482
// ComMoveXY ( i , 147 , 4 ) ;
7467: LD_VAR 0 1
7471: PPUSH
7472: LD_INT 147
7474: PPUSH
7475: LD_INT 4
7477: PPUSH
7478: CALL_OW 111
7482: GO 7443
7484: POP
7485: POP
// wait ( 0 0$1 ) ;
7486: LD_INT 35
7488: PPUSH
7489: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7493: LD_VAR 0 2
7497: PPUSH
7498: LD_INT 92
7500: PUSH
7501: LD_INT 147
7503: PUSH
7504: LD_INT 4
7506: PUSH
7507: LD_INT 9
7509: PUSH
7510: EMPTY
7511: LIST
7512: LIST
7513: LIST
7514: LIST
7515: PPUSH
7516: CALL_OW 72
7520: PUSH
7521: LD_VAR 0 2
7525: PUSH
7526: LD_INT 1
7528: MINUS
7529: GREATEREQUAL
7530: IFFALSE 7408
// end ; repeat wait ( 0 0$1 ) ;
7532: LD_INT 35
7534: PPUSH
7535: CALL_OW 67
// for i in tmp do
7539: LD_ADDR_VAR 0 1
7543: PUSH
7544: LD_VAR 0 2
7548: PUSH
7549: FOR_IN
7550: IFFALSE 7632
// begin if GetLives ( i ) > 251 then
7552: LD_VAR 0 1
7556: PPUSH
7557: CALL_OW 256
7561: PUSH
7562: LD_INT 251
7564: GREATER
7565: IFFALSE 7603
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
7567: LD_VAR 0 1
7571: PPUSH
7572: LD_INT 81
7574: PUSH
7575: LD_INT 8
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PPUSH
7582: CALL_OW 69
7586: PPUSH
7587: LD_VAR 0 1
7591: PPUSH
7592: CALL_OW 74
7596: PPUSH
7597: CALL_OW 115
7601: GO 7630
// if IsDead ( i ) then
7603: LD_VAR 0 1
7607: PPUSH
7608: CALL_OW 301
7612: IFFALSE 7630
// tmp := tmp diff i ;
7614: LD_ADDR_VAR 0 2
7618: PUSH
7619: LD_VAR 0 2
7623: PUSH
7624: LD_VAR 0 1
7628: DIFF
7629: ST_TO_ADDR
// end ;
7630: GO 7549
7632: POP
7633: POP
// until not tmp ;
7634: LD_VAR 0 2
7638: NOT
7639: IFFALSE 7532
// end ;
7641: PPOPN 3
7643: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
7644: LD_EXP 50
7648: PPUSH
7649: CALL_OW 302
7653: PUSH
7654: LD_EXP 3
7658: NOT
7659: AND
7660: IFFALSE 7669
7662: GO 7664
7664: DISABLE
// BuildKozlovBomb ;
7665: CALL 6656 0 0
7669: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
7670: LD_INT 22
7672: PUSH
7673: LD_INT 8
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: PUSH
7680: LD_INT 34
7682: PUSH
7683: LD_INT 48
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: PPUSH
7694: CALL_OW 69
7698: IFFALSE 7746
7700: GO 7702
7702: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
7703: LD_INT 22
7705: PUSH
7706: LD_INT 8
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: PUSH
7713: LD_INT 34
7715: PUSH
7716: LD_INT 48
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: PPUSH
7727: CALL_OW 69
7731: PUSH
7732: LD_INT 1
7734: ARRAY
7735: PPUSH
7736: LD_INT 173
7738: PPUSH
7739: LD_INT 96
7741: PPUSH
7742: CALL_OW 116
// end ; end_of_file
7746: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7747: LD_INT 0
7749: PPUSH
7750: PPUSH
7751: PPUSH
7752: PPUSH
7753: PPUSH
7754: PPUSH
7755: PPUSH
7756: PPUSH
7757: PPUSH
// side := 3 ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_INT 3
7765: ST_TO_ADDR
// uc_side := side ;
7766: LD_ADDR_OWVAR 20
7770: PUSH
7771: LD_VAR 0 6
7775: ST_TO_ADDR
// uc_nation := 3 ;
7776: LD_ADDR_OWVAR 21
7780: PUSH
7781: LD_INT 3
7783: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7784: LD_ADDR_VAR 0 2
7788: PUSH
7789: LD_INT 22
7791: PUSH
7792: LD_VAR 0 6
7796: PUSH
7797: EMPTY
7798: LIST
7799: LIST
7800: PUSH
7801: LD_INT 21
7803: PUSH
7804: LD_INT 3
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: PPUSH
7815: CALL_OW 69
7819: PUSH
7820: FOR_IN
7821: IFFALSE 7837
// SetBLevel ( i , 10 ) ;
7823: LD_VAR 0 2
7827: PPUSH
7828: LD_INT 10
7830: PPUSH
7831: CALL_OW 241
7835: GO 7820
7837: POP
7838: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7839: LD_ADDR_VAR 0 9
7843: PUSH
7844: LD_INT 22
7846: PUSH
7847: LD_VAR 0 6
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: PUSH
7856: LD_INT 30
7858: PUSH
7859: LD_INT 34
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PUSH
7866: EMPTY
7867: LIST
7868: LIST
7869: PPUSH
7870: CALL_OW 69
7874: ST_TO_ADDR
// if teleport then
7875: LD_VAR 0 9
7879: IFFALSE 7900
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7881: LD_VAR 0 9
7885: PUSH
7886: LD_INT 1
7888: ARRAY
7889: PPUSH
7890: LD_INT 123
7892: PPUSH
7893: LD_INT 122
7895: PPUSH
7896: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7900: LD_ADDR_EXP 51
7904: PUSH
7905: LD_STRING Platonov
7907: PPUSH
7908: CALL_OW 25
7912: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7913: LD_ADDR_EXP 52
7917: PUSH
7918: LD_STRING Yakotich
7920: PPUSH
7921: CALL_OW 25
7925: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7926: LD_ADDR_EXP 53
7930: PUSH
7931: LD_STRING Gleb
7933: PPUSH
7934: CALL_OW 25
7938: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7939: LD_STRING 03_Cornel
7941: PPUSH
7942: CALL_OW 28
7946: IFFALSE 7994
// begin Bierezov := NewCharacter ( Mikhail ) ;
7948: LD_ADDR_EXP 54
7952: PUSH
7953: LD_STRING Mikhail
7955: PPUSH
7956: CALL_OW 25
7960: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7961: LD_EXP 54
7965: PPUSH
7966: LD_INT 197
7968: PPUSH
7969: LD_INT 111
7971: PPUSH
7972: LD_INT 9
7974: PPUSH
7975: LD_INT 0
7977: PPUSH
7978: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7982: LD_EXP 54
7986: PPUSH
7987: LD_INT 3
7989: PPUSH
7990: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7994: LD_EXP 51
7998: PPUSH
7999: LD_INT 126
8001: PPUSH
8002: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8006: LD_EXP 52
8010: PPUSH
8011: LD_INT 197
8013: PPUSH
8014: LD_INT 111
8016: PPUSH
8017: LD_INT 9
8019: PPUSH
8020: LD_INT 0
8022: PPUSH
8023: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8027: LD_EXP 53
8031: PPUSH
8032: LD_INT 197
8034: PPUSH
8035: LD_INT 111
8037: PPUSH
8038: LD_INT 9
8040: PPUSH
8041: LD_INT 0
8043: PPUSH
8044: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8048: LD_ADDR_VAR 0 5
8052: PUSH
8053: LD_INT 126
8055: PPUSH
8056: LD_INT 2
8058: PPUSH
8059: LD_STRING zhukov
8061: PPUSH
8062: LD_INT 9
8064: PUSH
8065: LD_INT 10
8067: PUSH
8068: LD_INT 10
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: LIST
8075: PUSH
8076: LD_OWVAR 67
8080: ARRAY
8081: PPUSH
8082: LD_INT 90000
8084: PUSH
8085: LD_INT 1000
8087: PUSH
8088: LD_INT 300
8090: PUSH
8091: EMPTY
8092: LIST
8093: LIST
8094: LIST
8095: PPUSH
8096: LD_INT 21
8098: PUSH
8099: LD_INT 8
8101: PUSH
8102: LD_INT 13
8104: PUSH
8105: LD_INT 8
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: LIST
8112: LIST
8113: PPUSH
8114: CALL 59525 0 6
8118: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8119: LD_ADDR_VAR 0 4
8123: PUSH
8124: LD_INT 267
8126: PPUSH
8127: CALL_OW 274
8131: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8132: LD_VAR 0 4
8136: PPUSH
8137: LD_INT 1
8139: PPUSH
8140: LD_INT 5000
8142: PPUSH
8143: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8147: LD_VAR 0 4
8151: PPUSH
8152: LD_INT 2
8154: PPUSH
8155: LD_INT 200
8157: PPUSH
8158: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8162: LD_VAR 0 4
8166: PPUSH
8167: LD_INT 3
8169: PPUSH
8170: LD_INT 200
8172: PPUSH
8173: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8177: LD_ADDR_EXP 74
8181: PUSH
8182: LD_EXP 74
8186: PPUSH
8187: LD_INT 2
8189: PPUSH
8190: LD_VAR 0 5
8194: PUSH
8195: LD_INT 22
8197: PUSH
8198: LD_VAR 0 6
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: PUSH
8207: LD_INT 3
8209: PUSH
8210: LD_INT 21
8212: PUSH
8213: LD_INT 2
8215: PUSH
8216: EMPTY
8217: LIST
8218: LIST
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: PUSH
8224: EMPTY
8225: LIST
8226: LIST
8227: PPUSH
8228: CALL_OW 69
8232: UNION
8233: PUSH
8234: LD_EXP 51
8238: DIFF
8239: PPUSH
8240: CALL_OW 1
8244: ST_TO_ADDR
// behemoths := [ ] ;
8245: LD_ADDR_EXP 55
8249: PUSH
8250: EMPTY
8251: ST_TO_ADDR
// behemothBuilders := [ ] ;
8252: LD_ADDR_EXP 56
8256: PUSH
8257: EMPTY
8258: ST_TO_ADDR
// j := 3 ;
8259: LD_ADDR_VAR 0 3
8263: PUSH
8264: LD_INT 3
8266: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8267: LD_ADDR_VAR 0 2
8271: PUSH
8272: LD_INT 22
8274: PUSH
8275: LD_INT 3
8277: PUSH
8278: EMPTY
8279: LIST
8280: LIST
8281: PUSH
8282: LD_INT 25
8284: PUSH
8285: LD_INT 3
8287: PUSH
8288: EMPTY
8289: LIST
8290: LIST
8291: PUSH
8292: EMPTY
8293: LIST
8294: LIST
8295: PPUSH
8296: CALL_OW 69
8300: PUSH
8301: FOR_IN
8302: IFFALSE 8352
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8304: LD_ADDR_EXP 56
8308: PUSH
8309: LD_EXP 56
8313: PPUSH
8314: LD_VAR 0 2
8318: PPUSH
8319: CALL 91861 0 2
8323: ST_TO_ADDR
// j := j - 1 ;
8324: LD_ADDR_VAR 0 3
8328: PUSH
8329: LD_VAR 0 3
8333: PUSH
8334: LD_INT 1
8336: MINUS
8337: ST_TO_ADDR
// if j = 0 then
8338: LD_VAR 0 3
8342: PUSH
8343: LD_INT 0
8345: EQUAL
8346: IFFALSE 8350
// break ;
8348: GO 8352
// end ;
8350: GO 8301
8352: POP
8353: POP
// end ;
8354: LD_VAR 0 1
8358: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8359: LD_INT 0
8361: PPUSH
8362: PPUSH
8363: PPUSH
8364: PPUSH
8365: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8366: LD_ADDR_VAR 0 4
8370: PUSH
8371: LD_INT 209
8373: PUSH
8374: LD_INT 149
8376: PUSH
8377: EMPTY
8378: LIST
8379: LIST
8380: PUSH
8381: LD_INT 219
8383: PUSH
8384: LD_INT 154
8386: PUSH
8387: EMPTY
8388: LIST
8389: LIST
8390: PUSH
8391: LD_INT 223
8393: PUSH
8394: LD_INT 149
8396: PUSH
8397: EMPTY
8398: LIST
8399: LIST
8400: PUSH
8401: LD_INT 232
8403: PUSH
8404: LD_INT 155
8406: PUSH
8407: EMPTY
8408: LIST
8409: LIST
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: LIST
8415: LIST
8416: ST_TO_ADDR
// if not behemothBuilders then
8417: LD_EXP 56
8421: NOT
8422: IFFALSE 8426
// exit ;
8424: GO 8530
// j := 1 ;
8426: LD_ADDR_VAR 0 3
8430: PUSH
8431: LD_INT 1
8433: ST_TO_ADDR
// for i in behemothBuilders do
8434: LD_ADDR_VAR 0 2
8438: PUSH
8439: LD_EXP 56
8443: PUSH
8444: FOR_IN
8445: IFFALSE 8528
// begin if IsInUnit ( i ) then
8447: LD_VAR 0 2
8451: PPUSH
8452: CALL_OW 310
8456: IFFALSE 8467
// ComExitBuilding ( i ) ;
8458: LD_VAR 0 2
8462: PPUSH
8463: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8467: LD_VAR 0 2
8471: PPUSH
8472: LD_INT 37
8474: PPUSH
8475: LD_VAR 0 4
8479: PUSH
8480: LD_VAR 0 3
8484: ARRAY
8485: PUSH
8486: LD_INT 1
8488: ARRAY
8489: PPUSH
8490: LD_VAR 0 4
8494: PUSH
8495: LD_VAR 0 3
8499: ARRAY
8500: PUSH
8501: LD_INT 2
8503: ARRAY
8504: PPUSH
8505: LD_INT 0
8507: PPUSH
8508: CALL_OW 230
// j := j + 1 ;
8512: LD_ADDR_VAR 0 3
8516: PUSH
8517: LD_VAR 0 3
8521: PUSH
8522: LD_INT 1
8524: PLUS
8525: ST_TO_ADDR
// end ;
8526: GO 8444
8528: POP
8529: POP
// end ;
8530: LD_VAR 0 1
8534: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8535: LD_INT 3
8537: PPUSH
8538: CALL 91909 0 1
8542: PUSH
8543: LD_INT 22
8545: PUSH
8546: LD_INT 3
8548: PUSH
8549: EMPTY
8550: LIST
8551: LIST
8552: PUSH
8553: LD_INT 30
8555: PUSH
8556: LD_INT 37
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: EMPTY
8564: LIST
8565: LIST
8566: PPUSH
8567: CALL_OW 69
8571: NOT
8572: AND
8573: IFFALSE 8759
8575: GO 8577
8577: DISABLE
8578: LD_INT 0
8580: PPUSH
8581: PPUSH
// begin enable ;
8582: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8583: LD_ADDR_VAR 0 2
8587: PUSH
8588: LD_INT 3
8590: PPUSH
8591: CALL 91909 0 1
8595: ST_TO_ADDR
// for i in tmp do
8596: LD_ADDR_VAR 0 1
8600: PUSH
8601: LD_VAR 0 2
8605: PUSH
8606: FOR_IN
8607: IFFALSE 8757
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8609: LD_VAR 0 1
8613: PPUSH
8614: LD_INT 7
8616: PPUSH
8617: CALL_OW 308
8621: PUSH
8622: LD_VAR 0 1
8626: PPUSH
8627: CALL_OW 110
8631: PUSH
8632: LD_INT 2
8634: EQUAL
8635: NOT
8636: AND
8637: IFFALSE 8651
// SetTag ( i , 2 ) ;
8639: LD_VAR 0 1
8643: PPUSH
8644: LD_INT 2
8646: PPUSH
8647: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8651: LD_INT 81
8653: PUSH
8654: LD_INT 3
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: PUSH
8661: LD_INT 91
8663: PUSH
8664: LD_VAR 0 1
8668: PUSH
8669: LD_INT 12
8671: PUSH
8672: EMPTY
8673: LIST
8674: LIST
8675: LIST
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: PPUSH
8681: CALL_OW 69
8685: NOT
8686: PUSH
8687: LD_VAR 0 1
8691: PPUSH
8692: CALL_OW 110
8696: PUSH
8697: LD_INT 2
8699: EQUAL
8700: NOT
8701: AND
8702: IFFALSE 8721
// ComAgressiveMove ( i , 64 , 93 ) else
8704: LD_VAR 0 1
8708: PPUSH
8709: LD_INT 64
8711: PPUSH
8712: LD_INT 93
8714: PPUSH
8715: CALL_OW 114
8719: GO 8755
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8721: LD_VAR 0 1
8725: PPUSH
8726: LD_INT 81
8728: PUSH
8729: LD_INT 3
8731: PUSH
8732: EMPTY
8733: LIST
8734: LIST
8735: PPUSH
8736: CALL_OW 69
8740: PPUSH
8741: LD_VAR 0 1
8745: PPUSH
8746: CALL_OW 74
8750: PPUSH
8751: CALL_OW 115
// end ;
8755: GO 8606
8757: POP
8758: POP
// end ;
8759: PPOPN 2
8761: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
8762: LD_EXP 2
8766: NOT
8767: PUSH
8768: LD_INT 2
8770: PPUSH
8771: LD_INT 1
8773: PPUSH
8774: CALL 44573 0 2
8778: NOT
8779: AND
8780: IFFALSE 9700
8782: GO 8784
8784: DISABLE
8785: LD_INT 0
8787: PPUSH
8788: PPUSH
8789: PPUSH
8790: PPUSH
// begin enable ;
8791: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8792: LD_INT 22
8794: PUSH
8795: LD_INT 3
8797: PUSH
8798: EMPTY
8799: LIST
8800: LIST
8801: PUSH
8802: LD_INT 30
8804: PUSH
8805: LD_INT 3
8807: PUSH
8808: EMPTY
8809: LIST
8810: LIST
8811: PUSH
8812: EMPTY
8813: LIST
8814: LIST
8815: PPUSH
8816: CALL_OW 69
8820: NOT
8821: IFFALSE 8825
// exit ;
8823: GO 9700
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
8825: LD_ADDR_VAR 0 4
8829: PUSH
8830: LD_INT 22
8832: PUSH
8833: LD_INT 3
8835: PUSH
8836: EMPTY
8837: LIST
8838: LIST
8839: PUSH
8840: LD_INT 30
8842: PUSH
8843: LD_INT 34
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PPUSH
8854: CALL_OW 69
8858: ST_TO_ADDR
// if Prob ( 40 ) then
8859: LD_INT 40
8861: PPUSH
8862: CALL_OW 13
8866: IFFALSE 8993
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
8868: LD_INT 2
8870: PPUSH
8871: LD_INT 22
8873: PUSH
8874: LD_INT 3
8876: PUSH
8877: LD_INT 3
8879: PUSH
8880: LD_INT 49
8882: PUSH
8883: EMPTY
8884: LIST
8885: LIST
8886: LIST
8887: LIST
8888: PUSH
8889: LD_INT 22
8891: PUSH
8892: LD_INT 3
8894: PUSH
8895: LD_INT 3
8897: PUSH
8898: LD_INT 49
8900: PUSH
8901: EMPTY
8902: LIST
8903: LIST
8904: LIST
8905: LIST
8906: PUSH
8907: LD_INT 22
8909: PUSH
8910: LD_INT 3
8912: PUSH
8913: LD_INT 3
8915: PUSH
8916: LD_INT 49
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 24
8927: PUSH
8928: LD_INT 3
8930: PUSH
8931: LD_INT 3
8933: PUSH
8934: LD_INT 46
8936: PUSH
8937: EMPTY
8938: LIST
8939: LIST
8940: LIST
8941: LIST
8942: PUSH
8943: LD_INT 24
8945: PUSH
8946: LD_INT 3
8948: PUSH
8949: LD_INT 3
8951: PUSH
8952: LD_INT 46
8954: PUSH
8955: EMPTY
8956: LIST
8957: LIST
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 24
8963: PUSH
8964: LD_INT 3
8966: PUSH
8967: LD_INT 3
8969: PUSH
8970: LD_INT 46
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: LIST
8977: LIST
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: LIST
8983: LIST
8984: LIST
8985: LIST
8986: PPUSH
8987: CALL 43155 0 2
// end else
8991: GO 9116
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
8993: LD_INT 2
8995: PPUSH
8996: LD_INT 24
8998: PUSH
8999: LD_INT 3
9001: PUSH
9002: LD_INT 3
9004: PUSH
9005: LD_INT 47
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: PUSH
9014: LD_INT 24
9016: PUSH
9017: LD_INT 3
9019: PUSH
9020: LD_INT 3
9022: PUSH
9023: LD_INT 47
9025: PUSH
9026: EMPTY
9027: LIST
9028: LIST
9029: LIST
9030: LIST
9031: PUSH
9032: LD_INT 24
9034: PUSH
9035: LD_INT 3
9037: PUSH
9038: LD_INT 3
9040: PUSH
9041: LD_INT 47
9043: PUSH
9044: EMPTY
9045: LIST
9046: LIST
9047: LIST
9048: LIST
9049: PUSH
9050: LD_INT 24
9052: PUSH
9053: LD_INT 3
9055: PUSH
9056: LD_INT 3
9058: PUSH
9059: LD_INT 46
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: LIST
9066: LIST
9067: PUSH
9068: LD_INT 24
9070: PUSH
9071: LD_INT 3
9073: PUSH
9074: LD_INT 3
9076: PUSH
9077: LD_INT 46
9079: PUSH
9080: EMPTY
9081: LIST
9082: LIST
9083: LIST
9084: LIST
9085: PUSH
9086: LD_INT 24
9088: PUSH
9089: LD_INT 3
9091: PUSH
9092: LD_INT 3
9094: PUSH
9095: LD_INT 46
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: LIST
9102: LIST
9103: PUSH
9104: EMPTY
9105: LIST
9106: LIST
9107: LIST
9108: LIST
9109: LIST
9110: LIST
9111: PPUSH
9112: CALL 43155 0 2
// end ; if Difficulty > 1 then
9116: LD_OWVAR 67
9120: PUSH
9121: LD_INT 1
9123: GREATER
9124: IFFALSE 9154
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9126: LD_INT 2
9128: PPUSH
9129: LD_INT 24
9131: PUSH
9132: LD_INT 3
9134: PUSH
9135: LD_INT 3
9137: PUSH
9138: LD_INT 47
9140: PUSH
9141: EMPTY
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: PUSH
9147: EMPTY
9148: LIST
9149: PPUSH
9150: CALL 43155 0 2
// repeat wait ( 0 0$1 ) ;
9154: LD_INT 35
9156: PPUSH
9157: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9161: LD_INT 2
9163: PPUSH
9164: LD_INT 1
9166: PPUSH
9167: CALL 44573 0 2
9171: PUSH
9172: LD_INT 6
9174: PUSH
9175: LD_INT 7
9177: PUSH
9178: LD_INT 7
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: LIST
9185: PUSH
9186: LD_OWVAR 67
9190: ARRAY
9191: GREATEREQUAL
9192: IFFALSE 9154
// wait ( 0 0$30 ) ;
9194: LD_INT 1050
9196: PPUSH
9197: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9201: LD_ADDR_VAR 0 2
9205: PUSH
9206: LD_INT 2
9208: PPUSH
9209: LD_INT 1
9211: PPUSH
9212: CALL 44573 0 2
9216: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9217: LD_ADDR_EXP 93
9221: PUSH
9222: LD_EXP 93
9226: PPUSH
9227: LD_INT 2
9229: PPUSH
9230: LD_EXP 93
9234: PUSH
9235: LD_INT 2
9237: ARRAY
9238: PUSH
9239: LD_VAR 0 2
9243: DIFF
9244: PPUSH
9245: CALL_OW 1
9249: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9250: LD_ADDR_VAR 0 3
9254: PUSH
9255: LD_INT 0
9257: PPUSH
9258: LD_INT 1
9260: PPUSH
9261: CALL_OW 12
9265: ST_TO_ADDR
// if target then
9266: LD_VAR 0 3
9270: IFFALSE 9398
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9272: LD_ADDR_VAR 0 2
9276: PUSH
9277: LD_VAR 0 2
9281: PPUSH
9282: LD_INT 24
9284: PUSH
9285: LD_INT 250
9287: PUSH
9288: EMPTY
9289: LIST
9290: LIST
9291: PPUSH
9292: CALL_OW 72
9296: ST_TO_ADDR
// for i in tmp do
9297: LD_ADDR_VAR 0 1
9301: PUSH
9302: LD_VAR 0 2
9306: PUSH
9307: FOR_IN
9308: IFFALSE 9348
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9310: LD_VAR 0 1
9314: PPUSH
9315: LD_INT 139
9317: PPUSH
9318: LD_INT 89
9320: PPUSH
9321: CALL_OW 297
9325: PUSH
9326: LD_INT 9
9328: GREATER
9329: IFFALSE 9346
// ComMoveXY ( i , 139 , 89 ) ;
9331: LD_VAR 0 1
9335: PPUSH
9336: LD_INT 139
9338: PPUSH
9339: LD_INT 89
9341: PPUSH
9342: CALL_OW 111
9346: GO 9307
9348: POP
9349: POP
// wait ( 0 0$1 ) ;
9350: LD_INT 35
9352: PPUSH
9353: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9357: LD_VAR 0 2
9361: PPUSH
9362: LD_INT 92
9364: PUSH
9365: LD_INT 139
9367: PUSH
9368: LD_INT 89
9370: PUSH
9371: LD_INT 9
9373: PUSH
9374: EMPTY
9375: LIST
9376: LIST
9377: LIST
9378: LIST
9379: PPUSH
9380: CALL_OW 72
9384: PUSH
9385: LD_VAR 0 2
9389: PUSH
9390: LD_INT 1
9392: MINUS
9393: GREATEREQUAL
9394: IFFALSE 9272
// end else
9396: GO 9540
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9398: LD_VAR 0 2
9402: PPUSH
9403: LD_VAR 0 4
9407: PUSH
9408: LD_INT 1
9410: ARRAY
9411: PPUSH
9412: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9416: LD_ADDR_VAR 0 2
9420: PUSH
9421: LD_VAR 0 2
9425: PPUSH
9426: LD_INT 24
9428: PUSH
9429: LD_INT 250
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PPUSH
9436: CALL_OW 72
9440: ST_TO_ADDR
// for i in tmp do
9441: LD_ADDR_VAR 0 1
9445: PUSH
9446: LD_VAR 0 2
9450: PUSH
9451: FOR_IN
9452: IFFALSE 9492
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9454: LD_VAR 0 1
9458: PPUSH
9459: LD_INT 124
9461: PPUSH
9462: LD_INT 139
9464: PPUSH
9465: CALL_OW 297
9469: PUSH
9470: LD_INT 9
9472: GREATER
9473: IFFALSE 9490
// ComMoveXY ( i , 124 , 139 ) ;
9475: LD_VAR 0 1
9479: PPUSH
9480: LD_INT 124
9482: PPUSH
9483: LD_INT 139
9485: PPUSH
9486: CALL_OW 111
9490: GO 9451
9492: POP
9493: POP
// wait ( 0 0$1 ) ;
9494: LD_INT 35
9496: PPUSH
9497: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9501: LD_VAR 0 2
9505: PPUSH
9506: LD_INT 92
9508: PUSH
9509: LD_INT 124
9511: PUSH
9512: LD_INT 139
9514: PUSH
9515: LD_INT 9
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: LIST
9522: LIST
9523: PPUSH
9524: CALL_OW 72
9528: PUSH
9529: LD_VAR 0 2
9533: PUSH
9534: LD_INT 1
9536: MINUS
9537: GREATEREQUAL
9538: IFFALSE 9416
// end ; repeat wait ( 0 0$1 ) ;
9540: LD_INT 35
9542: PPUSH
9543: CALL_OW 67
// for i in tmp do
9547: LD_ADDR_VAR 0 1
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: FOR_IN
9558: IFFALSE 9691
// begin if GetLives ( i ) > 251 then
9560: LD_VAR 0 1
9564: PPUSH
9565: CALL_OW 256
9569: PUSH
9570: LD_INT 251
9572: GREATER
9573: IFFALSE 9662
// begin if GetWeapon ( i ) = ru_time_lapser then
9575: LD_VAR 0 1
9579: PPUSH
9580: CALL_OW 264
9584: PUSH
9585: LD_INT 49
9587: EQUAL
9588: IFFALSE 9626
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
9590: LD_VAR 0 1
9594: PPUSH
9595: LD_INT 81
9597: PUSH
9598: LD_INT 3
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: PPUSH
9605: CALL_OW 69
9609: PPUSH
9610: LD_VAR 0 1
9614: PPUSH
9615: CALL_OW 74
9619: PPUSH
9620: CALL_OW 112
9624: GO 9660
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9626: LD_VAR 0 1
9630: PPUSH
9631: LD_INT 81
9633: PUSH
9634: LD_INT 3
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: PPUSH
9641: CALL_OW 69
9645: PPUSH
9646: LD_VAR 0 1
9650: PPUSH
9651: CALL_OW 74
9655: PPUSH
9656: CALL_OW 115
// end else
9660: GO 9689
// if IsDead ( i ) then
9662: LD_VAR 0 1
9666: PPUSH
9667: CALL_OW 301
9671: IFFALSE 9689
// tmp := tmp diff i ;
9673: LD_ADDR_VAR 0 2
9677: PUSH
9678: LD_VAR 0 2
9682: PUSH
9683: LD_VAR 0 1
9687: DIFF
9688: ST_TO_ADDR
// end ;
9689: GO 9557
9691: POP
9692: POP
// until not tmp ;
9693: LD_VAR 0 2
9697: NOT
9698: IFFALSE 9540
// end ;
9700: PPOPN 4
9702: END
// every 30 30$00 trigger not russianDestroyed do
9703: LD_EXP 2
9707: NOT
9708: IFFALSE 9773
9710: GO 9712
9712: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
9713: LD_INT 105000
9715: PUSH
9716: LD_INT 84000
9718: PUSH
9719: LD_INT 63000
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: LIST
9726: PUSH
9727: LD_OWVAR 67
9731: ARRAY
9732: PPUSH
9733: CALL_OW 67
// if russianDestroyed then
9737: LD_EXP 2
9741: IFFALSE 9745
// exit ;
9743: GO 9773
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
9745: LD_INT 2
9747: PPUSH
9748: LD_INT 23
9750: PUSH
9751: LD_INT 3
9753: PUSH
9754: LD_INT 1
9756: PUSH
9757: LD_INT 48
9759: PUSH
9760: EMPTY
9761: LIST
9762: LIST
9763: LIST
9764: LIST
9765: PUSH
9766: EMPTY
9767: LIST
9768: PPUSH
9769: CALL 43155 0 2
// end ; end_of_file
9773: END
// export function CustomEvent ( event ) ; begin
9774: LD_INT 0
9776: PPUSH
// end ;
9777: LD_VAR 0 2
9781: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
9782: LD_VAR 0 2
9786: PPUSH
9787: LD_VAR 0 3
9791: PPUSH
9792: LD_INT 15
9794: PPUSH
9795: CALL_OW 309
9799: IFFALSE 9808
// YouLost ( MothContaminate ) ;
9801: LD_STRING MothContaminate
9803: PPUSH
9804: CALL_OW 104
// end ;
9808: PPOPN 3
9810: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
9811: LD_VAR 0 2
9815: PPUSH
9816: LD_VAR 0 3
9820: PPUSH
9821: LD_INT 15
9823: PPUSH
9824: CALL_OW 309
9828: IFFALSE 9844
// begin wait ( 0 0$6 ) ;
9830: LD_INT 210
9832: PPUSH
9833: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
9837: LD_STRING MothContaminateBomb
9839: PPUSH
9840: CALL_OW 104
// end ; end ;
9844: PPOPN 3
9846: END
// on UnitDestroyed ( un ) do begin if un = JMM then
9847: LD_VAR 0 1
9851: PUSH
9852: LD_EXP 12
9856: EQUAL
9857: IFFALSE 9868
// begin YouLost ( JMM ) ;
9859: LD_STRING JMM
9861: PPUSH
9862: CALL_OW 104
// exit ;
9866: GO 9917
// end ; if un = Powell then
9868: LD_VAR 0 1
9872: PUSH
9873: LD_EXP 47
9877: EQUAL
9878: IFFALSE 9888
// americanDestroyed := true ;
9880: LD_ADDR_EXP 4
9884: PUSH
9885: LD_INT 1
9887: ST_TO_ADDR
// if un = Platonov then
9888: LD_VAR 0 1
9892: PUSH
9893: LD_EXP 51
9897: EQUAL
9898: IFFALSE 9908
// russianDestroyed := true ;
9900: LD_ADDR_EXP 2
9904: PUSH
9905: LD_INT 1
9907: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
9908: LD_VAR 0 1
9912: PPUSH
9913: CALL 46547 0 1
// end ;
9917: PPOPN 1
9919: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9920: LD_VAR 0 1
9924: PPUSH
9925: LD_VAR 0 2
9929: PPUSH
9930: CALL 48747 0 2
// end ;
9934: PPOPN 2
9936: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
9937: LD_VAR 0 1
9941: PPUSH
9942: CALL 47815 0 1
// end ;
9946: PPOPN 1
9948: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
9949: LD_VAR 0 1
9953: PUSH
9954: LD_INT 22
9956: PUSH
9957: LD_INT 8
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: PUSH
9964: LD_INT 30
9966: PUSH
9967: LD_INT 2
9969: PUSH
9970: EMPTY
9971: LIST
9972: LIST
9973: PUSH
9974: LD_INT 23
9976: PUSH
9977: LD_INT 3
9979: PUSH
9980: EMPTY
9981: LIST
9982: LIST
9983: PUSH
9984: EMPTY
9985: LIST
9986: LIST
9987: LIST
9988: PPUSH
9989: CALL_OW 69
9993: IN
9994: IFFALSE 10021
// begin ComUpgrade ( building ) ;
9996: LD_VAR 0 1
10000: PPUSH
10001: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10005: LD_EXP 50
10009: PPUSH
10010: LD_VAR 0 1
10014: PPUSH
10015: CALL 59089 0 2
// exit ;
10019: GO 10030
// end ; MCE_BuildingComplete ( building ) ;
10021: LD_VAR 0 1
10025: PPUSH
10026: CALL 48056 0 1
// end ;
10030: PPOPN 1
10032: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10033: LD_VAR 0 1
10037: PPUSH
10038: LD_VAR 0 2
10042: PPUSH
10043: CALL 46243 0 2
// end ;
10047: PPOPN 2
10049: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10050: LD_VAR 0 1
10054: PPUSH
10055: LD_VAR 0 2
10059: PPUSH
10060: LD_VAR 0 3
10064: PPUSH
10065: LD_VAR 0 4
10069: PPUSH
10070: LD_VAR 0 5
10074: PPUSH
10075: CALL 45863 0 5
// end ;
10079: PPOPN 5
10081: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10082: LD_VAR 0 1
10086: PPUSH
10087: LD_VAR 0 2
10091: PPUSH
10092: CALL 45459 0 2
// end ;
10096: PPOPN 2
10098: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10099: LD_VAR 0 1
10103: PPUSH
10104: LD_VAR 0 2
10108: PPUSH
10109: LD_VAR 0 3
10113: PPUSH
10114: LD_VAR 0 4
10118: PPUSH
10119: CALL 45297 0 4
// end ;
10123: PPOPN 4
10125: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10126: LD_VAR 0 1
10130: PPUSH
10131: LD_VAR 0 2
10135: PPUSH
10136: LD_VAR 0 3
10140: PPUSH
10141: CALL 45072 0 3
// end ;
10145: PPOPN 3
10147: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10148: LD_VAR 0 1
10152: PPUSH
10153: LD_VAR 0 2
10157: PPUSH
10158: CALL 44957 0 2
// end ;
10162: PPOPN 2
10164: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10165: LD_VAR 0 1
10169: PPUSH
10170: LD_VAR 0 2
10174: PPUSH
10175: CALL 49008 0 2
// end ;
10179: PPOPN 2
10181: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10182: LD_VAR 0 1
10186: PPUSH
10187: LD_VAR 0 2
10191: PPUSH
10192: LD_VAR 0 3
10196: PPUSH
10197: LD_VAR 0 4
10201: PPUSH
10202: CALL 49224 0 4
// end ;
10206: PPOPN 4
10208: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10209: LD_VAR 0 1
10213: PPUSH
10214: LD_VAR 0 2
10218: PPUSH
10219: CALL 44766 0 2
// end ;
10223: PPOPN 2
10225: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10226: LD_VAR 0 1
10230: PPUSH
10231: CALL 92261 0 1
// end ; end_of_file
10235: PPOPN 1
10237: END
// export function Action ; begin
10238: LD_INT 0
10240: PPUSH
// InGameOn ;
10241: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10245: LD_INT 206
10247: PPUSH
10248: LD_INT 11
10250: PPUSH
10251: CALL_OW 86
// wait ( 0 0$1 ) ;
10255: LD_INT 35
10257: PPUSH
10258: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10262: LD_EXP 12
10266: PPUSH
10267: LD_STRING DStart-JMM-JMM-1
10269: PPUSH
10270: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10274: LD_EXP 44
10278: PPUSH
10279: LD_STRING DStart-JMM-Bur-1
10281: PPUSH
10282: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10286: LD_EXP 12
10290: PPUSH
10291: LD_STRING DStart-JMM-JMM-2
10293: PPUSH
10294: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10298: LD_EXP 44
10302: PPUSH
10303: LD_STRING DStart-JMM-Bur-2
10305: PPUSH
10306: CALL_OW 88
// InGameOff ;
10310: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10314: LD_STRING MStart
10316: PPUSH
10317: CALL_OW 337
// end ;
10321: LD_VAR 0 1
10325: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10326: LD_INT 7
10328: PPUSH
10329: LD_INT 255
10331: PPUSH
10332: LD_INT 219
10334: PPUSH
10335: CALL_OW 293
10339: IFFALSE 10948
10341: GO 10343
10343: DISABLE
10344: LD_INT 0
10346: PPUSH
// begin wait ( 0 0$3 ) ;
10347: LD_INT 105
10349: PPUSH
10350: CALL_OW 67
// alienSpotted := true ;
10354: LD_ADDR_EXP 7
10358: PUSH
10359: LD_INT 1
10361: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10362: LD_ADDR_VAR 0 1
10366: PUSH
10367: LD_INT 22
10369: PUSH
10370: LD_INT 7
10372: PUSH
10373: EMPTY
10374: LIST
10375: LIST
10376: PUSH
10377: LD_INT 23
10379: PUSH
10380: LD_INT 3
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: PUSH
10387: LD_INT 21
10389: PUSH
10390: LD_INT 1
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: PUSH
10397: LD_INT 26
10399: PUSH
10400: LD_INT 1
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: PUSH
10407: EMPTY
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: PPUSH
10413: CALL_OW 69
10417: PUSH
10418: LD_EXP 44
10422: PUSH
10423: LD_EXP 32
10427: PUSH
10428: LD_EXP 34
10432: PUSH
10433: LD_EXP 35
10437: PUSH
10438: LD_EXP 42
10442: PUSH
10443: LD_EXP 41
10447: PUSH
10448: LD_EXP 36
10452: PUSH
10453: EMPTY
10454: LIST
10455: LIST
10456: LIST
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: DIFF
10462: ST_TO_ADDR
// DialogueOn ;
10463: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
10467: LD_INT 255
10469: PPUSH
10470: LD_INT 219
10472: PPUSH
10473: LD_INT 7
10475: PPUSH
10476: LD_INT 20
10478: NEG
10479: PPUSH
10480: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
10484: LD_INT 255
10486: PPUSH
10487: LD_INT 219
10489: PPUSH
10490: CALL_OW 86
// if speaker then
10494: LD_VAR 0 1
10498: IFFALSE 10516
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
10500: LD_VAR 0 1
10504: PUSH
10505: LD_INT 1
10507: ARRAY
10508: PPUSH
10509: LD_STRING DAlienBase-RSol1-1
10511: PPUSH
10512: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
10516: LD_EXP 12
10520: PPUSH
10521: LD_STRING DAlienBase-JMM-1
10523: PPUSH
10524: CALL_OW 88
// if IsOk ( Burlak ) then
10528: LD_EXP 44
10532: PPUSH
10533: CALL_OW 302
10537: IFFALSE 10558
// begin dwait ( 0 0$1 ) ;
10539: LD_INT 35
10541: PPUSH
10542: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
10546: LD_EXP 44
10550: PPUSH
10551: LD_STRING DAlienBase-Bur-1
10553: PPUSH
10554: CALL_OW 88
// end ; if IsOk ( Roth ) then
10558: LD_EXP 13
10562: PPUSH
10563: CALL_OW 302
10567: IFFALSE 10581
// Say ( Roth , DAlienBase-Roth-1 ) ;
10569: LD_EXP 13
10573: PPUSH
10574: LD_STRING DAlienBase-Roth-1
10576: PPUSH
10577: CALL_OW 88
// if IsOk ( Gossudarov ) then
10581: LD_EXP 30
10585: PPUSH
10586: CALL_OW 302
10590: IFFALSE 10606
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
10592: LD_EXP 30
10596: PPUSH
10597: LD_STRING DAlienBase-Gos-1
10599: PPUSH
10600: CALL_OW 88
10604: GO 10723
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
10606: LD_ADDR_VAR 0 1
10610: PUSH
10611: LD_INT 22
10613: PUSH
10614: LD_INT 7
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 25
10623: PUSH
10624: LD_INT 4
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: LD_INT 21
10633: PUSH
10634: LD_INT 1
10636: PUSH
10637: EMPTY
10638: LIST
10639: LIST
10640: PUSH
10641: LD_INT 26
10643: PUSH
10644: LD_INT 1
10646: PUSH
10647: EMPTY
10648: LIST
10649: LIST
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: LIST
10655: LIST
10656: PPUSH
10657: CALL_OW 69
10661: PUSH
10662: LD_EXP 13
10666: PUSH
10667: LD_EXP 12
10671: PUSH
10672: LD_EXP 44
10676: PUSH
10677: LD_EXP 32
10681: PUSH
10682: LD_EXP 42
10686: PUSH
10687: LD_EXP 41
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: LIST
10698: LIST
10699: DIFF
10700: ST_TO_ADDR
// if speaker then
10701: LD_VAR 0 1
10705: IFFALSE 10723
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
10707: LD_VAR 0 1
10711: PUSH
10712: LD_INT 1
10714: ARRAY
10715: PPUSH
10716: LD_STRING DAlienBase-Sci1-1
10718: PPUSH
10719: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
10723: LD_INT 255
10725: PPUSH
10726: LD_INT 219
10728: PPUSH
10729: LD_INT 7
10731: PPUSH
10732: CALL_OW 331
// DialogueOff ;
10736: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
10740: LD_INT 35
10742: PPUSH
10743: CALL_OW 67
// until IsSelected ( alien ) ;
10747: LD_INT 1
10749: PPUSH
10750: CALL_OW 306
10754: IFFALSE 10740
// if not artifactIResearched or not artifactIIResearched then
10756: LD_EXP 9
10760: NOT
10761: PUSH
10762: LD_EXP 10
10766: NOT
10767: OR
10768: IFFALSE 10948
// begin if IsOk ( Roth ) then
10770: LD_EXP 13
10774: PPUSH
10775: CALL_OW 302
10779: IFFALSE 10795
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
10781: LD_EXP 13
10785: PPUSH
10786: LD_STRING DAlieBaseNotReady-Roth-1
10788: PPUSH
10789: CALL_OW 88
10793: GO 10948
// if IsOk ( Gossudarov ) then
10795: LD_EXP 30
10799: PPUSH
10800: CALL_OW 302
10804: IFFALSE 10820
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
10806: LD_EXP 30
10810: PPUSH
10811: LD_STRING DAlieBaseNotReady-Gos-1
10813: PPUSH
10814: CALL_OW 88
10818: GO 10948
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
10820: LD_ADDR_VAR 0 1
10824: PUSH
10825: LD_INT 22
10827: PUSH
10828: LD_INT 7
10830: PUSH
10831: EMPTY
10832: LIST
10833: LIST
10834: PUSH
10835: LD_INT 23
10837: PUSH
10838: LD_INT 3
10840: PUSH
10841: EMPTY
10842: LIST
10843: LIST
10844: PUSH
10845: LD_INT 25
10847: PUSH
10848: LD_INT 4
10850: PUSH
10851: EMPTY
10852: LIST
10853: LIST
10854: PUSH
10855: LD_INT 21
10857: PUSH
10858: LD_INT 1
10860: PUSH
10861: EMPTY
10862: LIST
10863: LIST
10864: PUSH
10865: LD_INT 26
10867: PUSH
10868: LD_INT 1
10870: PUSH
10871: EMPTY
10872: LIST
10873: LIST
10874: PUSH
10875: EMPTY
10876: LIST
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 69
10886: PUSH
10887: LD_EXP 13
10891: PUSH
10892: LD_EXP 12
10896: PUSH
10897: LD_EXP 44
10901: PUSH
10902: LD_EXP 32
10906: PUSH
10907: LD_EXP 42
10911: PUSH
10912: LD_EXP 41
10916: PUSH
10917: EMPTY
10918: LIST
10919: LIST
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: DIFF
10925: ST_TO_ADDR
// if speaker then
10926: LD_VAR 0 1
10930: IFFALSE 10948
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
10932: LD_VAR 0 1
10936: PUSH
10937: LD_INT 1
10939: ARRAY
10940: PPUSH
10941: LD_STRING DAlieBaseNotReady-RSci1-1
10943: PPUSH
10944: CALL_OW 88
// end ; end ; end ;
10948: PPOPN 1
10950: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
10951: LD_INT 24
10953: PPUSH
10954: LD_INT 7
10956: PPUSH
10957: CALL_OW 321
10961: PUSH
10962: LD_INT 2
10964: EQUAL
10965: IFFALSE 11656
10967: GO 10969
10969: DISABLE
10970: LD_INT 0
10972: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
10973: LD_ADDR_VAR 0 1
10977: PUSH
10978: LD_INT 22
10980: PUSH
10981: LD_INT 7
10983: PUSH
10984: EMPTY
10985: LIST
10986: LIST
10987: PUSH
10988: LD_INT 23
10990: PUSH
10991: LD_INT 3
10993: PUSH
10994: EMPTY
10995: LIST
10996: LIST
10997: PUSH
10998: LD_INT 25
11000: PUSH
11001: LD_INT 4
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PUSH
11008: LD_INT 21
11010: PUSH
11011: LD_INT 1
11013: PUSH
11014: EMPTY
11015: LIST
11016: LIST
11017: PUSH
11018: LD_INT 26
11020: PUSH
11021: LD_INT 1
11023: PUSH
11024: EMPTY
11025: LIST
11026: LIST
11027: PUSH
11028: EMPTY
11029: LIST
11030: LIST
11031: LIST
11032: LIST
11033: LIST
11034: PPUSH
11035: CALL_OW 69
11039: PUSH
11040: LD_EXP 13
11044: PUSH
11045: LD_EXP 12
11049: PUSH
11050: LD_EXP 44
11054: PUSH
11055: LD_EXP 32
11059: PUSH
11060: LD_EXP 42
11064: PUSH
11065: LD_EXP 41
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: LIST
11074: LIST
11075: LIST
11076: LIST
11077: DIFF
11078: ST_TO_ADDR
// if not speaker then
11079: LD_VAR 0 1
11083: NOT
11084: IFFALSE 11088
// exit ;
11086: GO 11656
// DialogueOn ;
11088: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11092: LD_VAR 0 1
11096: PUSH
11097: LD_INT 1
11099: ARRAY
11100: PPUSH
11101: LD_STRING DArtefTechnology-RSci1-1
11103: PPUSH
11104: CALL_OW 88
// if IsOk ( Burlak ) then
11108: LD_EXP 44
11112: PPUSH
11113: CALL_OW 302
11117: IFFALSE 11131
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11119: LD_EXP 44
11123: PPUSH
11124: LD_STRING DArtefTechnology-Bur-1
11126: PPUSH
11127: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11131: LD_VAR 0 1
11135: PUSH
11136: LD_INT 1
11138: ARRAY
11139: PPUSH
11140: LD_STRING DArtefTechnology-RSci1-2
11142: PPUSH
11143: CALL_OW 88
// if Denis then
11147: LD_EXP 18
11151: IFFALSE 11168
// speaker := [ Denis ] else
11153: LD_ADDR_VAR 0 1
11157: PUSH
11158: LD_EXP 18
11162: PUSH
11163: EMPTY
11164: LIST
11165: ST_TO_ADDR
11166: GO 11274
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11168: LD_ADDR_VAR 0 1
11172: PUSH
11173: LD_INT 22
11175: PUSH
11176: LD_INT 7
11178: PUSH
11179: EMPTY
11180: LIST
11181: LIST
11182: PUSH
11183: LD_INT 23
11185: PUSH
11186: LD_INT 1
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PUSH
11193: LD_INT 25
11195: PUSH
11196: LD_INT 4
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: PUSH
11203: LD_INT 21
11205: PUSH
11206: LD_INT 1
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: PUSH
11213: LD_INT 26
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PUSH
11223: EMPTY
11224: LIST
11225: LIST
11226: LIST
11227: LIST
11228: LIST
11229: PPUSH
11230: CALL_OW 69
11234: PUSH
11235: LD_EXP 13
11239: PUSH
11240: LD_EXP 12
11244: PUSH
11245: LD_EXP 44
11249: PUSH
11250: LD_EXP 32
11254: PUSH
11255: LD_EXP 42
11259: PUSH
11260: LD_EXP 41
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: DIFF
11273: ST_TO_ADDR
// if speaker then
11274: LD_VAR 0 1
11278: IFFALSE 11296
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11280: LD_VAR 0 1
11284: PUSH
11285: LD_INT 1
11287: ARRAY
11288: PPUSH
11289: LD_STRING DArtefTechnology-Sci1-2
11291: PPUSH
11292: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11296: LD_ADDR_VAR 0 1
11300: PUSH
11301: LD_INT 22
11303: PUSH
11304: LD_INT 7
11306: PUSH
11307: EMPTY
11308: LIST
11309: LIST
11310: PUSH
11311: LD_INT 23
11313: PUSH
11314: LD_INT 3
11316: PUSH
11317: EMPTY
11318: LIST
11319: LIST
11320: PUSH
11321: LD_INT 25
11323: PUSH
11324: LD_INT 4
11326: PUSH
11327: EMPTY
11328: LIST
11329: LIST
11330: PUSH
11331: LD_INT 21
11333: PUSH
11334: LD_INT 1
11336: PUSH
11337: EMPTY
11338: LIST
11339: LIST
11340: PUSH
11341: LD_INT 26
11343: PUSH
11344: LD_INT 1
11346: PUSH
11347: EMPTY
11348: LIST
11349: LIST
11350: PUSH
11351: EMPTY
11352: LIST
11353: LIST
11354: LIST
11355: LIST
11356: LIST
11357: PPUSH
11358: CALL_OW 69
11362: PUSH
11363: LD_EXP 13
11367: PUSH
11368: LD_EXP 12
11372: PUSH
11373: LD_EXP 44
11377: PUSH
11378: LD_EXP 32
11382: PUSH
11383: LD_EXP 42
11387: PUSH
11388: LD_EXP 41
11392: PUSH
11393: EMPTY
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: LIST
11400: DIFF
11401: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
11402: LD_VAR 0 1
11406: PUSH
11407: LD_EXP 6
11411: PUSH
11412: LD_EXP 5
11416: OR
11417: AND
11418: IFFALSE 11652
// begin if arabianDestroyed and IsOk ( Burlak ) then
11420: LD_EXP 5
11424: PUSH
11425: LD_EXP 44
11429: PPUSH
11430: CALL_OW 302
11434: AND
11435: IFFALSE 11451
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
11437: LD_EXP 44
11441: PPUSH
11442: LD_STRING DArtefTechnology-Bur-2
11444: PPUSH
11445: CALL_OW 88
11449: GO 11463
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
11451: LD_EXP 12
11455: PPUSH
11456: LD_STRING DArtefTechnology-JMM-2
11458: PPUSH
11459: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
11463: LD_VAR 0 1
11467: PUSH
11468: LD_INT 1
11470: ARRAY
11471: PPUSH
11472: LD_STRING DArtefTechnology-RSci1-3
11474: PPUSH
11475: CALL_OW 88
// if Denis then
11479: LD_EXP 18
11483: IFFALSE 11500
// speaker := [ Denis ] else
11485: LD_ADDR_VAR 0 1
11489: PUSH
11490: LD_EXP 18
11494: PUSH
11495: EMPTY
11496: LIST
11497: ST_TO_ADDR
11498: GO 11606
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11500: LD_ADDR_VAR 0 1
11504: PUSH
11505: LD_INT 22
11507: PUSH
11508: LD_INT 7
11510: PUSH
11511: EMPTY
11512: LIST
11513: LIST
11514: PUSH
11515: LD_INT 23
11517: PUSH
11518: LD_INT 1
11520: PUSH
11521: EMPTY
11522: LIST
11523: LIST
11524: PUSH
11525: LD_INT 25
11527: PUSH
11528: LD_INT 4
11530: PUSH
11531: EMPTY
11532: LIST
11533: LIST
11534: PUSH
11535: LD_INT 21
11537: PUSH
11538: LD_INT 1
11540: PUSH
11541: EMPTY
11542: LIST
11543: LIST
11544: PUSH
11545: LD_INT 26
11547: PUSH
11548: LD_INT 1
11550: PUSH
11551: EMPTY
11552: LIST
11553: LIST
11554: PUSH
11555: EMPTY
11556: LIST
11557: LIST
11558: LIST
11559: LIST
11560: LIST
11561: PPUSH
11562: CALL_OW 69
11566: PUSH
11567: LD_EXP 13
11571: PUSH
11572: LD_EXP 12
11576: PUSH
11577: LD_EXP 44
11581: PUSH
11582: LD_EXP 32
11586: PUSH
11587: LD_EXP 42
11591: PUSH
11592: LD_EXP 41
11596: PUSH
11597: EMPTY
11598: LIST
11599: LIST
11600: LIST
11601: LIST
11602: LIST
11603: LIST
11604: DIFF
11605: ST_TO_ADDR
// if speaker then
11606: LD_VAR 0 1
11610: IFFALSE 11652
// if alienSpotted then
11612: LD_EXP 7
11616: IFFALSE 11636
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
11618: LD_VAR 0 1
11622: PUSH
11623: LD_INT 1
11625: ARRAY
11626: PPUSH
11627: LD_STRING DArtefTechnology-Sci1-3
11629: PPUSH
11630: CALL_OW 88
11634: GO 11652
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
11636: LD_VAR 0 1
11640: PUSH
11641: LD_INT 1
11643: ARRAY
11644: PPUSH
11645: LD_STRING DArtefTechnology-Sci1-3a
11647: PPUSH
11648: CALL_OW 88
// end ; DialogueOff ;
11652: CALL_OW 7
// end ;
11656: PPOPN 1
11658: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
11659: LD_EXP 9
11663: IFFALSE 11858
11665: GO 11667
11667: DISABLE
11668: LD_INT 0
11670: PPUSH
// begin if Denis then
11671: LD_EXP 18
11675: IFFALSE 11692
// speaker := [ Denis ] else
11677: LD_ADDR_VAR 0 1
11681: PUSH
11682: LD_EXP 18
11686: PUSH
11687: EMPTY
11688: LIST
11689: ST_TO_ADDR
11690: GO 11798
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11692: LD_ADDR_VAR 0 1
11696: PUSH
11697: LD_INT 22
11699: PUSH
11700: LD_INT 7
11702: PUSH
11703: EMPTY
11704: LIST
11705: LIST
11706: PUSH
11707: LD_INT 23
11709: PUSH
11710: LD_INT 1
11712: PUSH
11713: EMPTY
11714: LIST
11715: LIST
11716: PUSH
11717: LD_INT 25
11719: PUSH
11720: LD_INT 4
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PUSH
11727: LD_INT 21
11729: PUSH
11730: LD_INT 1
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: PUSH
11737: LD_INT 26
11739: PUSH
11740: LD_INT 1
11742: PUSH
11743: EMPTY
11744: LIST
11745: LIST
11746: PUSH
11747: EMPTY
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: PPUSH
11754: CALL_OW 69
11758: PUSH
11759: LD_EXP 13
11763: PUSH
11764: LD_EXP 12
11768: PUSH
11769: LD_EXP 44
11773: PUSH
11774: LD_EXP 32
11778: PUSH
11779: LD_EXP 42
11783: PUSH
11784: LD_EXP 41
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: LIST
11793: LIST
11794: LIST
11795: LIST
11796: DIFF
11797: ST_TO_ADDR
// if not speaker then
11798: LD_VAR 0 1
11802: NOT
11803: IFFALSE 11807
// exit ;
11805: GO 11858
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
11807: LD_VAR 0 1
11811: PUSH
11812: LD_INT 1
11814: ARRAY
11815: PPUSH
11816: LD_STRING DArtefTechnologyAm-Sci1-1
11818: PPUSH
11819: CALL_OW 88
// if IsOk ( Burlak ) then
11823: LD_EXP 44
11827: PPUSH
11828: CALL_OW 302
11832: IFFALSE 11846
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
11834: LD_EXP 44
11838: PPUSH
11839: LD_STRING DArtefTechnologyAm-Bur-1
11841: PPUSH
11842: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
11846: LD_EXP 12
11850: PPUSH
11851: LD_STRING DArtefTechnologyAm-JMM-1
11853: PPUSH
11854: CALL_OW 88
// end ;
11858: PPOPN 1
11860: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
11861: LD_EXP 10
11865: IFFALSE 12076
11867: GO 11869
11869: DISABLE
11870: LD_INT 0
11872: PPUSH
// begin if Denis then
11873: LD_EXP 18
11877: IFFALSE 11894
// speaker := [ Denis ] else
11879: LD_ADDR_VAR 0 1
11883: PUSH
11884: LD_EXP 18
11888: PUSH
11889: EMPTY
11890: LIST
11891: ST_TO_ADDR
11892: GO 12000
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11894: LD_ADDR_VAR 0 1
11898: PUSH
11899: LD_INT 22
11901: PUSH
11902: LD_INT 7
11904: PUSH
11905: EMPTY
11906: LIST
11907: LIST
11908: PUSH
11909: LD_INT 23
11911: PUSH
11912: LD_INT 3
11914: PUSH
11915: EMPTY
11916: LIST
11917: LIST
11918: PUSH
11919: LD_INT 25
11921: PUSH
11922: LD_INT 4
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PUSH
11929: LD_INT 21
11931: PUSH
11932: LD_INT 1
11934: PUSH
11935: EMPTY
11936: LIST
11937: LIST
11938: PUSH
11939: LD_INT 26
11941: PUSH
11942: LD_INT 1
11944: PUSH
11945: EMPTY
11946: LIST
11947: LIST
11948: PUSH
11949: EMPTY
11950: LIST
11951: LIST
11952: LIST
11953: LIST
11954: LIST
11955: PPUSH
11956: CALL_OW 69
11960: PUSH
11961: LD_EXP 13
11965: PUSH
11966: LD_EXP 12
11970: PUSH
11971: LD_EXP 44
11975: PUSH
11976: LD_EXP 32
11980: PUSH
11981: LD_EXP 42
11985: PUSH
11986: LD_EXP 41
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: LIST
11995: LIST
11996: LIST
11997: LIST
11998: DIFF
11999: ST_TO_ADDR
// if not speaker then
12000: LD_VAR 0 1
12004: NOT
12005: IFFALSE 12009
// exit ;
12007: GO 12076
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12009: LD_VAR 0 1
12013: PUSH
12014: LD_INT 1
12016: ARRAY
12017: PPUSH
12018: LD_STRING DArtefTechnologyRu-RSci1-1
12020: PPUSH
12021: CALL_OW 88
// if IsOk ( Burlak ) then
12025: LD_EXP 44
12029: PPUSH
12030: CALL_OW 302
12034: IFFALSE 12048
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12036: LD_EXP 44
12040: PPUSH
12041: LD_STRING DArtefTechnologyRu-Bur-1
12043: PPUSH
12044: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12048: LD_VAR 0 1
12052: PUSH
12053: LD_INT 1
12055: ARRAY
12056: PPUSH
12057: LD_STRING DArtefTechnologyRu-RSci1-2
12059: PPUSH
12060: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12064: LD_EXP 12
12068: PPUSH
12069: LD_STRING DArtefTechnologyRu-JMM-1
12071: PPUSH
12072: CALL_OW 88
// end ;
12076: PPOPN 1
12078: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12079: LD_INT 24
12081: PPUSH
12082: LD_INT 7
12084: PPUSH
12085: CALL_OW 321
12089: PUSH
12090: LD_INT 2
12092: EQUAL
12093: PUSH
12094: LD_INT 1
12096: PPUSH
12097: CALL_OW 255
12101: PUSH
12102: LD_INT 7
12104: EQUAL
12105: AND
12106: IFFALSE 12266
12108: GO 12110
12110: DISABLE
12111: LD_INT 0
12113: PPUSH
// begin if Denis then
12114: LD_EXP 18
12118: IFFALSE 12135
// speaker := [ Denis ] else
12120: LD_ADDR_VAR 0 1
12124: PUSH
12125: LD_EXP 18
12129: PUSH
12130: EMPTY
12131: LIST
12132: ST_TO_ADDR
12133: GO 12241
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12135: LD_ADDR_VAR 0 1
12139: PUSH
12140: LD_INT 22
12142: PUSH
12143: LD_INT 7
12145: PUSH
12146: EMPTY
12147: LIST
12148: LIST
12149: PUSH
12150: LD_INT 23
12152: PUSH
12153: LD_INT 1
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: PUSH
12160: LD_INT 25
12162: PUSH
12163: LD_INT 4
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PUSH
12170: LD_INT 21
12172: PUSH
12173: LD_INT 1
12175: PUSH
12176: EMPTY
12177: LIST
12178: LIST
12179: PUSH
12180: LD_INT 26
12182: PUSH
12183: LD_INT 1
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: LIST
12194: LIST
12195: LIST
12196: PPUSH
12197: CALL_OW 69
12201: PUSH
12202: LD_EXP 13
12206: PUSH
12207: LD_EXP 12
12211: PUSH
12212: LD_EXP 44
12216: PUSH
12217: LD_EXP 32
12221: PUSH
12222: LD_EXP 42
12226: PUSH
12227: LD_EXP 41
12231: PUSH
12232: EMPTY
12233: LIST
12234: LIST
12235: LIST
12236: LIST
12237: LIST
12238: LIST
12239: DIFF
12240: ST_TO_ADDR
// if not speaker then
12241: LD_VAR 0 1
12245: NOT
12246: IFFALSE 12250
// exit ;
12248: GO 12266
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12250: LD_VAR 0 1
12254: PUSH
12255: LD_INT 1
12257: ARRAY
12258: PPUSH
12259: LD_STRING DArtefTechnologyArStart-Sci1-1
12261: PPUSH
12262: CALL_OW 88
// end ;
12266: PPOPN 1
12268: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12269: LD_EXP 11
12273: IFFALSE 12554
12275: GO 12277
12277: DISABLE
12278: LD_INT 0
12280: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12281: LD_ADDR_VAR 0 1
12285: PUSH
12286: LD_INT 22
12288: PUSH
12289: LD_INT 7
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: LD_INT 23
12298: PUSH
12299: LD_INT 3
12301: PUSH
12302: EMPTY
12303: LIST
12304: LIST
12305: PUSH
12306: LD_INT 25
12308: PUSH
12309: LD_INT 4
12311: PUSH
12312: EMPTY
12313: LIST
12314: LIST
12315: PUSH
12316: LD_INT 21
12318: PUSH
12319: LD_INT 1
12321: PUSH
12322: EMPTY
12323: LIST
12324: LIST
12325: PUSH
12326: LD_INT 26
12328: PUSH
12329: LD_INT 1
12331: PUSH
12332: EMPTY
12333: LIST
12334: LIST
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: LIST
12340: LIST
12341: LIST
12342: PPUSH
12343: CALL_OW 69
12347: PUSH
12348: LD_EXP 13
12352: PUSH
12353: LD_EXP 12
12357: PUSH
12358: LD_EXP 44
12362: PUSH
12363: LD_EXP 32
12367: PUSH
12368: LD_EXP 42
12372: PUSH
12373: LD_EXP 41
12377: PUSH
12378: EMPTY
12379: LIST
12380: LIST
12381: LIST
12382: LIST
12383: LIST
12384: LIST
12385: DIFF
12386: ST_TO_ADDR
// if not speaker then
12387: LD_VAR 0 1
12391: NOT
12392: IFFALSE 12396
// exit ;
12394: GO 12554
// DialogueOn ;
12396: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
12400: LD_VAR 0 1
12404: PUSH
12405: LD_INT 1
12407: ARRAY
12408: PPUSH
12409: LD_STRING DArtefTechnologyAr-RSci1-1
12411: PPUSH
12412: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
12416: LD_EXP 12
12420: PPUSH
12421: LD_STRING DArtefTechnologyAr-JMM-1
12423: PPUSH
12424: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
12428: LD_VAR 0 1
12432: PUSH
12433: LD_INT 1
12435: ARRAY
12436: PPUSH
12437: LD_STRING DArtefTechnologyAr-RSci1-2
12439: PPUSH
12440: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
12444: LD_EXP 12
12448: PPUSH
12449: LD_STRING DArtefTechnologyAr-JMM-2
12451: PPUSH
12452: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
12456: LD_VAR 0 1
12460: PUSH
12461: LD_INT 1
12463: ARRAY
12464: PPUSH
12465: LD_STRING DArtefTechnologyAr-RSci1-3
12467: PPUSH
12468: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
12472: LD_EXP 12
12476: PPUSH
12477: LD_STRING DArtefTechnologyAr-JMM-3
12479: PPUSH
12480: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
12484: LD_VAR 0 1
12488: PUSH
12489: LD_INT 1
12491: ARRAY
12492: PPUSH
12493: LD_STRING DArtefTechnologyAr-RSci1-4
12495: PPUSH
12496: CALL_OW 88
// if IsOk ( Burlak ) then
12500: LD_EXP 44
12504: PPUSH
12505: CALL_OW 302
12509: IFFALSE 12523
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
12511: LD_EXP 44
12515: PPUSH
12516: LD_STRING DArtefTechnologyAr-Bur-4
12518: PPUSH
12519: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
12523: LD_EXP 12
12527: PPUSH
12528: LD_STRING DArtefTechnologyAr-JMM-4
12530: PPUSH
12531: CALL_OW 88
// DialogueOff ;
12535: CALL_OW 7
// wait ( 0 0$45 ) ;
12539: LD_INT 1575
12541: PPUSH
12542: CALL_OW 67
// spawnOmar := true ;
12546: LD_ADDR_EXP 8
12550: PUSH
12551: LD_INT 1
12553: ST_TO_ADDR
// end ;
12554: PPOPN 1
12556: END
// every 0 0$1 trigger spawnOmar do
12557: LD_EXP 8
12561: IFFALSE 12859
12563: GO 12565
12565: DISABLE
// begin PrepareOmarAli ;
12566: CALL 6099 0 0
// if not Omar then
12570: LD_EXP 48
12574: NOT
12575: IFFALSE 12579
// exit ;
12577: GO 12859
// repeat wait ( 0 0$1 ) ;
12579: LD_INT 35
12581: PPUSH
12582: CALL_OW 67
// until See ( 7 , Omar ) ;
12586: LD_INT 7
12588: PPUSH
12589: LD_EXP 48
12593: PPUSH
12594: CALL_OW 292
12598: IFFALSE 12579
// CenterNowOnUnits ( Omar ) ;
12600: LD_EXP 48
12604: PPUSH
12605: CALL_OW 87
// DialogueOn ;
12609: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
12613: LD_EXP 48
12617: PPUSH
12618: LD_STRING DOmar-Omar-1
12620: PPUSH
12621: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
12625: LD_EXP 12
12629: PPUSH
12630: LD_STRING DOmar-JMM-1
12632: PPUSH
12633: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
12637: LD_EXP 48
12641: PPUSH
12642: LD_STRING DOmar-Omar-2
12644: PPUSH
12645: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
12649: LD_EXP 12
12653: PPUSH
12654: LD_STRING DOmar-JMM-2
12656: PPUSH
12657: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
12661: LD_EXP 48
12665: PPUSH
12666: LD_STRING DOmar-Omar-3
12668: PPUSH
12669: CALL_OW 88
// if IsOk ( Burlak ) then
12673: LD_EXP 44
12677: PPUSH
12678: CALL_OW 302
12682: IFFALSE 12698
// Say ( Burlak , DOmar-Bur-3 ) else
12684: LD_EXP 44
12688: PPUSH
12689: LD_STRING DOmar-Bur-3
12691: PPUSH
12692: CALL_OW 88
12696: GO 12710
// Say ( JMM , DOmar-JMM-3 ) ;
12698: LD_EXP 12
12702: PPUSH
12703: LD_STRING DOmar-JMM-3
12705: PPUSH
12706: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
12710: LD_EXP 48
12714: PPUSH
12715: LD_STRING DOmar-Omar-4
12717: PPUSH
12718: CALL_OW 88
// case Query ( QAccept ) of 1 :
12722: LD_STRING QAccept
12724: PPUSH
12725: CALL_OW 97
12729: PUSH
12730: LD_INT 1
12732: DOUBLE
12733: EQUAL
12734: IFTRUE 12738
12736: GO 12774
12738: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
12739: LD_EXP 12
12743: PPUSH
12744: LD_STRING DQrAccept#1-JMM-1
12746: PPUSH
12747: CALL_OW 88
// SetSide ( Omar , 7 ) ;
12751: LD_EXP 48
12755: PPUSH
12756: LD_INT 7
12758: PPUSH
12759: CALL_OW 235
// ComStop ( Omar ) ;
12763: LD_EXP 48
12767: PPUSH
12768: CALL_OW 141
// end ; 2 :
12772: GO 12823
12774: LD_INT 2
12776: DOUBLE
12777: EQUAL
12778: IFTRUE 12782
12780: GO 12822
12782: POP
// begin if IsOk ( Burlak ) then
12783: LD_EXP 44
12787: PPUSH
12788: CALL_OW 302
12792: IFFALSE 12808
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
12794: LD_EXP 44
12798: PPUSH
12799: LD_STRING DQrAccept#2-Bur-1
12801: PPUSH
12802: CALL_OW 88
12806: GO 12820
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
12808: LD_EXP 12
12812: PPUSH
12813: LD_STRING DQrAccept#2-JMM-1
12815: PPUSH
12816: CALL_OW 88
// end ; end ;
12820: GO 12823
12822: POP
// DialogueOff ;
12823: CALL_OW 7
// if GetSide ( Omar ) = 7 then
12827: LD_EXP 48
12831: PPUSH
12832: CALL_OW 255
12836: PUSH
12837: LD_INT 7
12839: EQUAL
12840: IFFALSE 12844
// exit ;
12842: GO 12859
// ComMoveXY ( Omar , 202 , 115 ) ;
12844: LD_EXP 48
12848: PPUSH
12849: LD_INT 202
12851: PPUSH
12852: LD_INT 115
12854: PPUSH
12855: CALL_OW 111
// end ;
12859: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
12860: LD_EXP 48
12864: PPUSH
12865: LD_INT 200
12867: PPUSH
12868: LD_INT 98
12870: PPUSH
12871: CALL_OW 297
12875: PUSH
12876: LD_INT 40
12878: LESS
12879: PUSH
12880: LD_EXP 2
12884: AND
12885: IFFALSE 13103
12887: GO 12889
12889: DISABLE
// begin SetSide ( Omar , 5 ) ;
12890: LD_EXP 48
12894: PPUSH
12895: LD_INT 5
12897: PPUSH
12898: CALL_OW 235
// if IsInUnit ( Omar ) then
12902: LD_EXP 48
12906: PPUSH
12907: CALL_OW 310
12911: IFFALSE 12922
// ComExitVehicle ( Omar ) ;
12913: LD_EXP 48
12917: PPUSH
12918: CALL_OW 121
// if IsInUnit ( Omar ) then
12922: LD_EXP 48
12926: PPUSH
12927: CALL_OW 310
12931: IFFALSE 12942
// ComExitBuilding ( Omar ) ;
12933: LD_EXP 48
12937: PPUSH
12938: CALL_OW 122
// wait ( 0 0$1 ) ;
12942: LD_INT 35
12944: PPUSH
12945: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
12949: LD_EXP 48
12953: PPUSH
12954: LD_INT 203
12956: PPUSH
12957: LD_INT 120
12959: PPUSH
12960: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
12964: LD_INT 35
12966: PPUSH
12967: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
12971: LD_EXP 48
12975: PPUSH
12976: CALL_OW 306
12980: PUSH
12981: LD_EXP 48
12985: PPUSH
12986: LD_INT 203
12988: PPUSH
12989: LD_INT 120
12991: PPUSH
12992: CALL_OW 297
12996: PUSH
12997: LD_INT 6
12999: LESS
13000: OR
13001: IFFALSE 12964
// CenterNowOnUnits ( Omar ) ;
13003: LD_EXP 48
13007: PPUSH
13008: CALL_OW 87
// DialogueOn ;
13012: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13016: LD_EXP 12
13020: PPUSH
13021: LD_STRING DOmarContam-JMM-1
13023: PPUSH
13024: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13028: LD_EXP 48
13032: PPUSH
13033: LD_STRING DOmarContam-Omar-1
13035: PPUSH
13036: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13040: LD_EXP 12
13044: PPUSH
13045: LD_STRING DOmarContam-JMM-2
13047: PPUSH
13048: CALL_OW 88
// DialogueOff ;
13052: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13056: LD_INT 5
13058: PPUSH
13059: LD_INT 7
13061: PPUSH
13062: LD_INT 2
13064: PPUSH
13065: LD_INT 1
13067: PPUSH
13068: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13072: LD_INT 105
13074: PPUSH
13075: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13079: LD_EXP 48
13083: PPUSH
13084: LD_INT 203
13086: PPUSH
13087: LD_INT 120
13089: PPUSH
13090: CALL_OW 307
13094: IFFALSE 13072
// YouLost ( MothContaminate ) ;
13096: LD_STRING MothContaminate
13098: PPUSH
13099: CALL_OW 104
// end ;
13103: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13104: LD_EXP 4
13108: NOT
13109: PUSH
13110: LD_INT 22
13112: PUSH
13113: LD_INT 1
13115: PUSH
13116: EMPTY
13117: LIST
13118: LIST
13119: PUSH
13120: LD_INT 34
13122: PUSH
13123: LD_INT 8
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: PUSH
13130: EMPTY
13131: LIST
13132: LIST
13133: PPUSH
13134: CALL_OW 69
13138: AND
13139: IFFALSE 13220
13141: GO 13143
13143: DISABLE
// begin if not IsOk ( Powell ) then
13144: LD_EXP 47
13148: PPUSH
13149: CALL_OW 302
13153: NOT
13154: IFFALSE 13158
// exit ;
13156: GO 13220
// DialogueOn ;
13158: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13162: LD_EXP 47
13166: PPUSH
13167: LD_STRING DWinAmericans-Pow-1
13169: PPUSH
13170: CALL_OW 94
// if IsOk ( Burlak ) then
13174: LD_EXP 44
13178: PPUSH
13179: CALL_OW 302
13183: IFFALSE 13197
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13185: LD_EXP 44
13189: PPUSH
13190: LD_STRING DWinAmericans-Bur-1
13192: PPUSH
13193: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13197: LD_EXP 12
13201: PPUSH
13202: LD_STRING DWinAmericans-JMM-1
13204: PPUSH
13205: CALL_OW 88
// DialogueOff ;
13209: CALL_OW 7
// YouLost ( AmBomb ) ;
13213: LD_STRING AmBomb
13215: PPUSH
13216: CALL_OW 104
// end ;
13220: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13221: LD_EXP 2
13225: NOT
13226: PUSH
13227: LD_INT 22
13229: PUSH
13230: LD_INT 3
13232: PUSH
13233: EMPTY
13234: LIST
13235: LIST
13236: PUSH
13237: LD_INT 34
13239: PUSH
13240: LD_INT 48
13242: PUSH
13243: EMPTY
13244: LIST
13245: LIST
13246: PUSH
13247: EMPTY
13248: LIST
13249: LIST
13250: PPUSH
13251: CALL_OW 69
13255: AND
13256: IFFALSE 13337
13258: GO 13260
13260: DISABLE
// begin if not IsOk ( Platonov ) then
13261: LD_EXP 51
13265: PPUSH
13266: CALL_OW 302
13270: NOT
13271: IFFALSE 13275
// exit ;
13273: GO 13337
// DialogueOn ;
13275: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13279: LD_EXP 51
13283: PPUSH
13284: LD_STRING DWinRussians-Pla-1
13286: PPUSH
13287: CALL_OW 94
// if IsOk ( Burlak ) then
13291: LD_EXP 44
13295: PPUSH
13296: CALL_OW 302
13300: IFFALSE 13314
// Say ( Burlak , DWinRussians-Bur-1 ) ;
13302: LD_EXP 44
13306: PPUSH
13307: LD_STRING DWinRussians-Bur-1
13309: PPUSH
13310: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
13314: LD_EXP 12
13318: PPUSH
13319: LD_STRING DWinRussians-JMM-1
13321: PPUSH
13322: CALL_OW 88
// DialogueOff ;
13326: CALL_OW 7
// YouLost ( RuBomb ) ;
13330: LD_STRING RuBomb
13332: PPUSH
13333: CALL_OW 104
// end ;
13337: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
13338: LD_INT 7
13340: PPUSH
13341: LD_INT 22
13343: PUSH
13344: LD_INT 7
13346: PUSH
13347: EMPTY
13348: LIST
13349: LIST
13350: PPUSH
13351: CALL_OW 70
13355: PUSH
13356: LD_EXP 4
13360: NOT
13361: AND
13362: IFFALSE 13391
13364: GO 13366
13366: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
13367: LD_EXP 47
13371: PPUSH
13372: LD_STRING DSurrenderAmericans-Pow-1
13374: PPUSH
13375: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
13379: LD_EXP 12
13383: PPUSH
13384: LD_STRING DSurrenderAmericans-JMM-1
13386: PPUSH
13387: CALL_OW 88
// end ;
13391: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
13392: LD_INT 2
13394: PPUSH
13395: LD_INT 22
13397: PUSH
13398: LD_INT 7
13400: PUSH
13401: EMPTY
13402: LIST
13403: LIST
13404: PPUSH
13405: CALL_OW 70
13409: PUSH
13410: LD_EXP 2
13414: NOT
13415: AND
13416: PUSH
13417: LD_EXP 44
13421: AND
13422: IFFALSE 13451
13424: GO 13426
13426: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
13427: LD_EXP 51
13431: PPUSH
13432: LD_STRING DSurrenderRussians-Pla-1
13434: PPUSH
13435: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
13439: LD_EXP 44
13443: PPUSH
13444: LD_STRING DSurrenderRussians-Bur-1
13446: PPUSH
13447: CALL_OW 88
// end ;
13451: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
13452: LD_EXP 4
13456: IFFALSE 13831
13458: GO 13460
13460: DISABLE
13461: LD_INT 0
13463: PPUSH
13464: PPUSH
13465: PPUSH
// begin MC_Kill ( 4 ) ;
13466: LD_INT 4
13468: PPUSH
13469: CALL 19807 0 1
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
13473: LD_ADDR_VAR 0 3
13477: PUSH
13478: LD_INT 22
13480: PUSH
13481: LD_INT 1
13483: PUSH
13484: EMPTY
13485: LIST
13486: LIST
13487: PUSH
13488: LD_INT 26
13490: PUSH
13491: LD_INT 1
13493: PUSH
13494: EMPTY
13495: LIST
13496: LIST
13497: PUSH
13498: LD_INT 23
13500: PUSH
13501: LD_INT 1
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: PUSH
13508: EMPTY
13509: LIST
13510: LIST
13511: LIST
13512: PPUSH
13513: CALL_OW 69
13517: PUSH
13518: LD_EXP 47
13522: PUSH
13523: LD_EXP 20
13527: PUSH
13528: LD_EXP 17
13532: PUSH
13533: LD_EXP 16
13537: PUSH
13538: LD_EXP 23
13542: PUSH
13543: LD_EXP 21
13547: PUSH
13548: EMPTY
13549: LIST
13550: LIST
13551: LIST
13552: LIST
13553: LIST
13554: LIST
13555: DIFF
13556: ST_TO_ADDR
// if speaker then
13557: LD_VAR 0 3
13561: IFFALSE 13587
// begin DialogueOn ;
13563: CALL_OW 6
// Say ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
13567: LD_VAR 0 3
13571: PUSH
13572: LD_INT 1
13574: ARRAY
13575: PPUSH
13576: LD_STRING DSurrenderAmericans-Sol1-1a
13578: PPUSH
13579: CALL_OW 88
// DialogueOff ;
13583: CALL_OW 7
// end ; SetAttitude ( 1 , 7 , att_friend , true ) ;
13587: LD_INT 1
13589: PPUSH
13590: LD_INT 7
13592: PPUSH
13593: LD_INT 1
13595: PPUSH
13596: LD_INT 1
13598: PPUSH
13599: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
13603: LD_ADDR_VAR 0 2
13607: PUSH
13608: LD_INT 22
13610: PUSH
13611: LD_INT 1
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PUSH
13618: LD_INT 21
13620: PUSH
13621: LD_INT 1
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: PUSH
13628: EMPTY
13629: LIST
13630: LIST
13631: PPUSH
13632: CALL_OW 69
13636: PUSH
13637: LD_INT 22
13639: PUSH
13640: LD_INT 1
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PUSH
13647: LD_INT 21
13649: PUSH
13650: LD_INT 2
13652: PUSH
13653: EMPTY
13654: LIST
13655: LIST
13656: PUSH
13657: LD_INT 1
13659: PUSH
13660: EMPTY
13661: LIST
13662: PUSH
13663: EMPTY
13664: LIST
13665: LIST
13666: LIST
13667: PPUSH
13668: CALL_OW 69
13672: ADD
13673: ST_TO_ADDR
// if tmp then
13674: LD_VAR 0 2
13678: IFFALSE 13831
// repeat wait ( 0 0$1 ) ;
13680: LD_INT 35
13682: PPUSH
13683: CALL_OW 67
// for i in tmp do
13687: LD_ADDR_VAR 0 1
13691: PUSH
13692: LD_VAR 0 2
13696: PUSH
13697: FOR_IN
13698: IFFALSE 13780
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
13700: LD_VAR 0 1
13704: PPUSH
13705: CALL_OW 310
13709: PUSH
13710: LD_VAR 0 1
13714: PPUSH
13715: CALL_OW 310
13719: PPUSH
13720: CALL_OW 247
13724: PUSH
13725: LD_INT 3
13727: EQUAL
13728: AND
13729: IFFALSE 13740
// ComExitBuilding ( i ) ;
13731: LD_VAR 0 1
13735: PPUSH
13736: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
13740: LD_VAR 0 1
13744: PPUSH
13745: LD_INT 122
13747: PPUSH
13748: LD_INT 242
13750: PPUSH
13751: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
13755: LD_VAR 0 1
13759: PPUSH
13760: LD_INT 35
13762: PPUSH
13763: CALL_OW 308
13767: IFFALSE 13778
// RemoveUnit ( i ) ;
13769: LD_VAR 0 1
13773: PPUSH
13774: CALL_OW 64
// end ;
13778: GO 13697
13780: POP
13781: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
13782: LD_INT 22
13784: PUSH
13785: LD_INT 1
13787: PUSH
13788: EMPTY
13789: LIST
13790: LIST
13791: PUSH
13792: LD_INT 2
13794: PUSH
13795: LD_INT 21
13797: PUSH
13798: LD_INT 1
13800: PUSH
13801: EMPTY
13802: LIST
13803: LIST
13804: PUSH
13805: LD_INT 33
13807: PUSH
13808: LD_INT 1
13810: PUSH
13811: EMPTY
13812: LIST
13813: LIST
13814: PUSH
13815: EMPTY
13816: LIST
13817: LIST
13818: LIST
13819: PUSH
13820: EMPTY
13821: LIST
13822: LIST
13823: PPUSH
13824: CALL_OW 69
13828: NOT
13829: IFFALSE 13680
// end ;
13831: PPOPN 3
13833: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
13834: LD_EXP 2
13838: IFFALSE 14231
13840: GO 13842
13842: DISABLE
13843: LD_INT 0
13845: PPUSH
13846: PPUSH
13847: PPUSH
// begin repeat wait ( 0 0$1 ) ;
13848: LD_INT 35
13850: PPUSH
13851: CALL_OW 67
// until IsDead ( Yakotich ) ;
13855: LD_EXP 52
13859: PPUSH
13860: CALL_OW 301
13864: IFFALSE 13848
// MC_Kill ( 2 ) ;
13866: LD_INT 2
13868: PPUSH
13869: CALL 19807 0 1
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
13873: LD_ADDR_VAR 0 3
13877: PUSH
13878: LD_INT 22
13880: PUSH
13881: LD_INT 3
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PUSH
13888: LD_INT 26
13890: PUSH
13891: LD_INT 1
13893: PUSH
13894: EMPTY
13895: LIST
13896: LIST
13897: PUSH
13898: LD_INT 23
13900: PUSH
13901: LD_INT 3
13903: PUSH
13904: EMPTY
13905: LIST
13906: LIST
13907: PUSH
13908: EMPTY
13909: LIST
13910: LIST
13911: LIST
13912: PPUSH
13913: CALL_OW 69
13917: PUSH
13918: LD_EXP 51
13922: PUSH
13923: LD_EXP 52
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: DIFF
13932: ST_TO_ADDR
// if speaker then
13933: LD_VAR 0 3
13937: IFFALSE 13987
// begin DialogueOn ;
13939: CALL_OW 6
// if Burlak then
13943: LD_EXP 44
13947: IFFALSE 13967
// Say ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
13949: LD_VAR 0 3
13953: PUSH
13954: LD_INT 1
13956: ARRAY
13957: PPUSH
13958: LD_STRING DSurrenderRussians-RSol1-1
13960: PPUSH
13961: CALL_OW 88
13965: GO 13983
// Say ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
13967: LD_VAR 0 3
13971: PUSH
13972: LD_INT 1
13974: ARRAY
13975: PPUSH
13976: LD_STRING DSurrenderRussians-RSol1-1a
13978: PPUSH
13979: CALL_OW 88
// DialogueOff ;
13983: CALL_OW 7
// end ; SetAttitude ( 3 , 7 , att_friend , true ) ;
13987: LD_INT 3
13989: PPUSH
13990: LD_INT 7
13992: PPUSH
13993: LD_INT 1
13995: PPUSH
13996: LD_INT 1
13998: PPUSH
13999: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14003: LD_ADDR_VAR 0 2
14007: PUSH
14008: LD_INT 22
14010: PUSH
14011: LD_INT 3
14013: PUSH
14014: EMPTY
14015: LIST
14016: LIST
14017: PUSH
14018: LD_INT 21
14020: PUSH
14021: LD_INT 1
14023: PUSH
14024: EMPTY
14025: LIST
14026: LIST
14027: PUSH
14028: EMPTY
14029: LIST
14030: LIST
14031: PPUSH
14032: CALL_OW 69
14036: PUSH
14037: LD_INT 22
14039: PUSH
14040: LD_INT 3
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PUSH
14047: LD_INT 21
14049: PUSH
14050: LD_INT 2
14052: PUSH
14053: EMPTY
14054: LIST
14055: LIST
14056: PUSH
14057: LD_INT 1
14059: PUSH
14060: EMPTY
14061: LIST
14062: PUSH
14063: EMPTY
14064: LIST
14065: LIST
14066: LIST
14067: PPUSH
14068: CALL_OW 69
14072: ADD
14073: ST_TO_ADDR
// if tmp then
14074: LD_VAR 0 2
14078: IFFALSE 14231
// repeat wait ( 0 0$1 ) ;
14080: LD_INT 35
14082: PPUSH
14083: CALL_OW 67
// for i in tmp do
14087: LD_ADDR_VAR 0 1
14091: PUSH
14092: LD_VAR 0 2
14096: PUSH
14097: FOR_IN
14098: IFFALSE 14180
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14100: LD_VAR 0 1
14104: PPUSH
14105: CALL_OW 310
14109: PUSH
14110: LD_VAR 0 1
14114: PPUSH
14115: CALL_OW 310
14119: PPUSH
14120: CALL_OW 247
14124: PUSH
14125: LD_INT 3
14127: EQUAL
14128: AND
14129: IFFALSE 14140
// ComExitBuilding ( i ) ;
14131: LD_VAR 0 1
14135: PPUSH
14136: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14140: LD_VAR 0 1
14144: PPUSH
14145: LD_INT 154
14147: PPUSH
14148: LD_INT 1
14150: PPUSH
14151: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14155: LD_VAR 0 1
14159: PPUSH
14160: LD_INT 36
14162: PPUSH
14163: CALL_OW 308
14167: IFFALSE 14178
// RemoveUnit ( i ) ;
14169: LD_VAR 0 1
14173: PPUSH
14174: CALL_OW 64
// end ;
14178: GO 14097
14180: POP
14181: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14182: LD_INT 22
14184: PUSH
14185: LD_INT 3
14187: PUSH
14188: EMPTY
14189: LIST
14190: LIST
14191: PUSH
14192: LD_INT 2
14194: PUSH
14195: LD_INT 21
14197: PUSH
14198: LD_INT 1
14200: PUSH
14201: EMPTY
14202: LIST
14203: LIST
14204: PUSH
14205: LD_INT 33
14207: PUSH
14208: LD_INT 1
14210: PUSH
14211: EMPTY
14212: LIST
14213: LIST
14214: PUSH
14215: EMPTY
14216: LIST
14217: LIST
14218: LIST
14219: PUSH
14220: EMPTY
14221: LIST
14222: LIST
14223: PPUSH
14224: CALL_OW 69
14228: NOT
14229: IFFALSE 14080
// end ;
14231: PPOPN 3
14233: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) do
14234: LD_INT 22
14236: PUSH
14237: LD_INT 8
14239: PUSH
14240: EMPTY
14241: LIST
14242: LIST
14243: PUSH
14244: LD_INT 21
14246: PUSH
14247: LD_INT 1
14249: PUSH
14250: EMPTY
14251: LIST
14252: LIST
14253: PUSH
14254: LD_INT 23
14256: PUSH
14257: LD_INT 2
14259: PUSH
14260: EMPTY
14261: LIST
14262: LIST
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: LIST
14268: PPUSH
14269: CALL_OW 69
14273: PUSH
14274: LD_INT 18
14276: LESS
14277: PUSH
14278: LD_EXP 50
14282: PPUSH
14283: CALL_OW 301
14287: OR
14288: IFFALSE 14301
14290: GO 14292
14292: DISABLE
// legionDestroyed := true ;
14293: LD_ADDR_EXP 3
14297: PUSH
14298: LD_INT 1
14300: ST_TO_ADDR
14301: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
14302: LD_INT 22
14304: PUSH
14305: LD_INT 2
14307: PUSH
14308: EMPTY
14309: LIST
14310: LIST
14311: PUSH
14312: LD_INT 21
14314: PUSH
14315: LD_INT 1
14317: PUSH
14318: EMPTY
14319: LIST
14320: LIST
14321: PUSH
14322: LD_INT 23
14324: PUSH
14325: LD_INT 2
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: PUSH
14332: EMPTY
14333: LIST
14334: LIST
14335: LIST
14336: PPUSH
14337: CALL_OW 69
14341: PUSH
14342: LD_INT 9
14344: LESS
14345: IFFALSE 14358
14347: GO 14349
14349: DISABLE
// arabianDestroyed := true ;
14350: LD_ADDR_EXP 5
14354: PUSH
14355: LD_INT 1
14357: ST_TO_ADDR
14358: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
14359: LD_EXP 5
14363: IFFALSE 14623
14365: GO 14367
14367: DISABLE
14368: LD_INT 0
14370: PPUSH
14371: PPUSH
// begin MC_Kill ( 1 ) ;
14372: LD_INT 1
14374: PPUSH
14375: CALL 19807 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
14379: LD_INT 2
14381: PPUSH
14382: LD_INT 7
14384: PPUSH
14385: LD_INT 1
14387: PPUSH
14388: LD_INT 1
14390: PPUSH
14391: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14395: LD_ADDR_VAR 0 2
14399: PUSH
14400: LD_INT 22
14402: PUSH
14403: LD_INT 2
14405: PUSH
14406: EMPTY
14407: LIST
14408: LIST
14409: PUSH
14410: LD_INT 21
14412: PUSH
14413: LD_INT 1
14415: PUSH
14416: EMPTY
14417: LIST
14418: LIST
14419: PUSH
14420: EMPTY
14421: LIST
14422: LIST
14423: PPUSH
14424: CALL_OW 69
14428: PUSH
14429: LD_INT 22
14431: PUSH
14432: LD_INT 8
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: PUSH
14439: LD_INT 21
14441: PUSH
14442: LD_INT 2
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: PUSH
14449: LD_INT 1
14451: PUSH
14452: EMPTY
14453: LIST
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: PPUSH
14460: CALL_OW 69
14464: ADD
14465: ST_TO_ADDR
// if tmp then
14466: LD_VAR 0 2
14470: IFFALSE 14623
// repeat wait ( 0 0$1 ) ;
14472: LD_INT 35
14474: PPUSH
14475: CALL_OW 67
// for i in tmp do
14479: LD_ADDR_VAR 0 1
14483: PUSH
14484: LD_VAR 0 2
14488: PUSH
14489: FOR_IN
14490: IFFALSE 14572
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14492: LD_VAR 0 1
14496: PPUSH
14497: CALL_OW 310
14501: PUSH
14502: LD_VAR 0 1
14506: PPUSH
14507: CALL_OW 310
14511: PPUSH
14512: CALL_OW 247
14516: PUSH
14517: LD_INT 3
14519: EQUAL
14520: AND
14521: IFFALSE 14532
// ComExitBuilding ( i ) ;
14523: LD_VAR 0 1
14527: PPUSH
14528: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
14532: LD_VAR 0 1
14536: PPUSH
14537: LD_INT 254
14539: PPUSH
14540: LD_INT 268
14542: PPUSH
14543: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
14547: LD_VAR 0 1
14551: PPUSH
14552: LD_INT 34
14554: PPUSH
14555: CALL_OW 308
14559: IFFALSE 14570
// RemoveUnit ( i ) ;
14561: LD_VAR 0 1
14565: PPUSH
14566: CALL_OW 64
// end ;
14570: GO 14489
14572: POP
14573: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14574: LD_INT 22
14576: PUSH
14577: LD_INT 2
14579: PUSH
14580: EMPTY
14581: LIST
14582: LIST
14583: PUSH
14584: LD_INT 2
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 1
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: LD_INT 33
14599: PUSH
14600: LD_INT 1
14602: PUSH
14603: EMPTY
14604: LIST
14605: LIST
14606: PUSH
14607: EMPTY
14608: LIST
14609: LIST
14610: LIST
14611: PUSH
14612: EMPTY
14613: LIST
14614: LIST
14615: PPUSH
14616: CALL_OW 69
14620: NOT
14621: IFFALSE 14472
// end ;
14623: PPOPN 2
14625: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
14626: LD_EXP 3
14630: IFFALSE 14982
14632: GO 14634
14634: DISABLE
14635: LD_INT 0
14637: PPUSH
14638: PPUSH
// begin MC_Kill ( 3 ) ;
14639: LD_INT 3
14641: PPUSH
14642: CALL 19807 0 1
// if IsOk ( Schulz ) then
14646: LD_EXP 49
14650: PPUSH
14651: CALL_OW 302
14655: IFFALSE 14677
// begin DialogueOn ;
14657: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
14661: LD_EXP 49
14665: PPUSH
14666: LD_STRING D15-Szulc-1
14668: PPUSH
14669: CALL_OW 94
// DialogueOff ;
14673: CALL_OW 7
// end ; SetAttitude ( 8 , 7 , att_friend , true ) ;
14677: LD_INT 8
14679: PPUSH
14680: LD_INT 7
14682: PPUSH
14683: LD_INT 1
14685: PPUSH
14686: LD_INT 1
14688: PPUSH
14689: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
14693: LD_ADDR_VAR 0 1
14697: PUSH
14698: LD_INT 22
14700: PUSH
14701: LD_INT 8
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: PUSH
14708: LD_INT 21
14710: PUSH
14711: LD_INT 3
14713: PUSH
14714: EMPTY
14715: LIST
14716: LIST
14717: PUSH
14718: LD_INT 23
14720: PUSH
14721: LD_INT 3
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PUSH
14728: EMPTY
14729: LIST
14730: LIST
14731: LIST
14732: PPUSH
14733: CALL_OW 69
14737: PUSH
14738: FOR_IN
14739: IFFALSE 14752
// DestroyUnit ( i ) ;
14741: LD_VAR 0 1
14745: PPUSH
14746: CALL_OW 65
14750: GO 14738
14752: POP
14753: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14754: LD_ADDR_VAR 0 2
14758: PUSH
14759: LD_INT 22
14761: PUSH
14762: LD_INT 8
14764: PUSH
14765: EMPTY
14766: LIST
14767: LIST
14768: PUSH
14769: LD_INT 21
14771: PUSH
14772: LD_INT 1
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: EMPTY
14780: LIST
14781: LIST
14782: PPUSH
14783: CALL_OW 69
14787: PUSH
14788: LD_INT 22
14790: PUSH
14791: LD_INT 8
14793: PUSH
14794: EMPTY
14795: LIST
14796: LIST
14797: PUSH
14798: LD_INT 21
14800: PUSH
14801: LD_INT 2
14803: PUSH
14804: EMPTY
14805: LIST
14806: LIST
14807: PUSH
14808: LD_INT 1
14810: PUSH
14811: EMPTY
14812: LIST
14813: PUSH
14814: EMPTY
14815: LIST
14816: LIST
14817: LIST
14818: PPUSH
14819: CALL_OW 69
14823: ADD
14824: ST_TO_ADDR
// if tmp then
14825: LD_VAR 0 2
14829: IFFALSE 14982
// repeat wait ( 0 0$1 ) ;
14831: LD_INT 35
14833: PPUSH
14834: CALL_OW 67
// for i in tmp do
14838: LD_ADDR_VAR 0 1
14842: PUSH
14843: LD_VAR 0 2
14847: PUSH
14848: FOR_IN
14849: IFFALSE 14931
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14851: LD_VAR 0 1
14855: PPUSH
14856: CALL_OW 310
14860: PUSH
14861: LD_VAR 0 1
14865: PPUSH
14866: CALL_OW 310
14870: PPUSH
14871: CALL_OW 247
14875: PUSH
14876: LD_INT 3
14878: EQUAL
14879: AND
14880: IFFALSE 14891
// ComExitBuilding ( i ) ;
14882: LD_VAR 0 1
14886: PPUSH
14887: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
14891: LD_VAR 0 1
14895: PPUSH
14896: LD_INT 10
14898: PPUSH
14899: LD_INT 1
14901: PPUSH
14902: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
14906: LD_VAR 0 1
14910: PPUSH
14911: LD_INT 32
14913: PPUSH
14914: CALL_OW 308
14918: IFFALSE 14929
// RemoveUnit ( i ) ;
14920: LD_VAR 0 1
14924: PPUSH
14925: CALL_OW 64
// end ;
14929: GO 14848
14931: POP
14932: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14933: LD_INT 22
14935: PUSH
14936: LD_INT 8
14938: PUSH
14939: EMPTY
14940: LIST
14941: LIST
14942: PUSH
14943: LD_INT 2
14945: PUSH
14946: LD_INT 21
14948: PUSH
14949: LD_INT 1
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: PUSH
14956: LD_INT 33
14958: PUSH
14959: LD_INT 1
14961: PUSH
14962: EMPTY
14963: LIST
14964: LIST
14965: PUSH
14966: EMPTY
14967: LIST
14968: LIST
14969: LIST
14970: PUSH
14971: EMPTY
14972: LIST
14973: LIST
14974: PPUSH
14975: CALL_OW 69
14979: NOT
14980: IFFALSE 14831
// end ;
14982: PPOPN 2
14984: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do
14985: LD_EXP 4
14989: PUSH
14990: LD_EXP 2
14994: AND
14995: PUSH
14996: LD_EXP 3
15000: AND
15001: PUSH
15002: LD_EXP 5
15006: AND
15007: IFFALSE 16243
15009: GO 15011
15011: DISABLE
// begin CenterNowOnUnits ( JMM ) ;
15012: LD_EXP 12
15016: PPUSH
15017: CALL_OW 87
// InGameOn ;
15021: CALL_OW 8
// DialogueOn ;
15025: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15029: LD_EXP 12
15033: PPUSH
15034: LD_STRING DEnd-JMM-JMM-1
15036: PPUSH
15037: CALL_OW 88
// if Joan then
15041: LD_EXP 27
15045: IFFALSE 15061
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15047: LD_EXP 27
15051: PPUSH
15052: LD_STRING DEnd-JMM-Joan-1
15054: PPUSH
15055: CALL_OW 88
15059: GO 15105
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15061: LD_EXP 14
15065: PUSH
15066: LD_EXP 14
15070: PPUSH
15071: CALL_OW 255
15075: PUSH
15076: LD_INT 7
15078: EQUAL
15079: AND
15080: PUSH
15081: LD_EXP 14
15085: PPUSH
15086: CALL_OW 305
15090: AND
15091: IFFALSE 15105
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15093: LD_EXP 14
15097: PPUSH
15098: LD_STRING DEnd-JMM-Lisa-1
15100: PPUSH
15101: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15105: LD_EXP 24
15109: PUSH
15110: LD_EXP 24
15114: PPUSH
15115: CALL_OW 305
15119: AND
15120: IFFALSE 15134
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15122: LD_EXP 24
15126: PPUSH
15127: LD_STRING DEnd-JMM-Frank-1
15129: PPUSH
15130: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15134: LD_EXP 17
15138: PUSH
15139: LD_EXP 17
15143: PPUSH
15144: CALL_OW 255
15148: PUSH
15149: LD_INT 7
15151: EQUAL
15152: AND
15153: PUSH
15154: LD_EXP 17
15158: PPUSH
15159: CALL_OW 305
15163: AND
15164: IFFALSE 15178
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15166: LD_EXP 17
15170: PPUSH
15171: LD_STRING DEnd-JMM-Cyrus-1
15173: PPUSH
15174: CALL_OW 88
// if Burlak then
15178: LD_EXP 44
15182: IFFALSE 15196
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15184: LD_EXP 44
15188: PPUSH
15189: LD_STRING DEnd-JMM-Bur-1
15191: PPUSH
15192: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15196: LD_EXP 27
15200: PUSH
15201: LD_EXP 14
15205: AND
15206: PUSH
15207: LD_EXP 14
15211: PPUSH
15212: CALL_OW 255
15216: PUSH
15217: LD_INT 7
15219: EQUAL
15220: AND
15221: PUSH
15222: LD_EXP 14
15226: PPUSH
15227: CALL_OW 305
15231: AND
15232: IFFALSE 15246
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
15234: LD_EXP 14
15238: PPUSH
15239: LD_STRING DEnd-Burlak-Lisa-1
15241: PPUSH
15242: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
15246: LD_EXP 45
15250: PUSH
15251: LD_EXP 45
15255: PPUSH
15256: CALL_OW 305
15260: AND
15261: IFFALSE 15275
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
15263: LD_EXP 45
15267: PPUSH
15268: LD_STRING DEnd-JMM-Bel-1
15270: PPUSH
15271: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
15275: LD_EXP 46
15279: PUSH
15280: LD_EXP 46
15284: PPUSH
15285: CALL_OW 305
15289: AND
15290: IFFALSE 15304
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
15292: LD_EXP 46
15296: PPUSH
15297: LD_STRING DEnd-JMM-Gny-1
15299: PPUSH
15300: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
15304: LD_EXP 22
15308: PUSH
15309: LD_EXP 22
15313: PPUSH
15314: CALL_OW 255
15318: PUSH
15319: LD_INT 7
15321: EQUAL
15322: AND
15323: PUSH
15324: LD_EXP 22
15328: PPUSH
15329: CALL_OW 305
15333: AND
15334: IFFALSE 15348
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
15336: LD_EXP 22
15340: PPUSH
15341: LD_STRING DEnd-JMM-Corn-1
15343: PPUSH
15344: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
15348: LD_EXP 15
15352: PUSH
15353: LD_EXP 15
15357: PPUSH
15358: CALL_OW 255
15362: PUSH
15363: LD_INT 7
15365: EQUAL
15366: AND
15367: PUSH
15368: LD_EXP 15
15372: PPUSH
15373: CALL_OW 305
15377: AND
15378: IFFALSE 15392
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
15380: LD_EXP 15
15384: PPUSH
15385: LD_STRING DEnd-JMM-Don-1
15387: PPUSH
15388: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
15392: LD_EXP 16
15396: PUSH
15397: LD_EXP 16
15401: PPUSH
15402: CALL_OW 255
15406: PUSH
15407: LD_INT 7
15409: EQUAL
15410: AND
15411: PUSH
15412: LD_EXP 16
15416: PPUSH
15417: CALL_OW 305
15421: AND
15422: IFFALSE 15436
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
15424: LD_EXP 16
15428: PPUSH
15429: LD_STRING DEnd-JMM-Bobby-1
15431: PPUSH
15432: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
15436: LD_EXP 18
15440: PUSH
15441: LD_EXP 18
15445: PPUSH
15446: CALL_OW 255
15450: PUSH
15451: LD_INT 7
15453: EQUAL
15454: AND
15455: PUSH
15456: LD_EXP 18
15460: PPUSH
15461: CALL_OW 305
15465: AND
15466: IFFALSE 15480
// Say ( Denis , DEnd-JMM-Den-1 ) ;
15468: LD_EXP 18
15472: PPUSH
15473: LD_STRING DEnd-JMM-Den-1
15475: PPUSH
15476: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
15480: LD_EXP 20
15484: PUSH
15485: LD_EXP 20
15489: PPUSH
15490: CALL_OW 255
15494: PUSH
15495: LD_INT 7
15497: EQUAL
15498: AND
15499: PUSH
15500: LD_EXP 20
15504: PPUSH
15505: CALL_OW 305
15509: AND
15510: IFFALSE 15524
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
15512: LD_EXP 20
15516: PPUSH
15517: LD_STRING DEnd-JMM-Glad-1
15519: PPUSH
15520: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
15524: LD_EXP 25
15528: PUSH
15529: LD_EXP 25
15533: PPUSH
15534: CALL_OW 255
15538: PUSH
15539: LD_INT 7
15541: EQUAL
15542: AND
15543: PUSH
15544: LD_EXP 25
15548: PPUSH
15549: CALL_OW 305
15553: AND
15554: IFFALSE 15568
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
15556: LD_EXP 25
15560: PPUSH
15561: LD_STRING DEnd-JMM-Yam-1
15563: PPUSH
15564: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
15568: LD_EXP 19
15572: PUSH
15573: LD_EXP 19
15577: PPUSH
15578: CALL_OW 255
15582: PUSH
15583: LD_INT 7
15585: EQUAL
15586: AND
15587: PUSH
15588: LD_EXP 19
15592: PPUSH
15593: CALL_OW 305
15597: AND
15598: IFFALSE 15612
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
15600: LD_EXP 19
15604: PPUSH
15605: LD_STRING DEnd-JMM-Brown-1
15607: PPUSH
15608: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
15612: LD_EXP 29
15616: PUSH
15617: LD_EXP 29
15621: PPUSH
15622: CALL_OW 255
15626: PUSH
15627: LD_INT 7
15629: EQUAL
15630: AND
15631: PUSH
15632: LD_EXP 29
15636: PPUSH
15637: CALL_OW 305
15641: AND
15642: IFFALSE 15656
// Say ( Connie , DEnd-JMM-Con-1 ) ;
15644: LD_EXP 29
15648: PPUSH
15649: LD_STRING DEnd-JMM-Con-1
15651: PPUSH
15652: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
15656: LD_EXP 23
15660: PUSH
15661: LD_EXP 23
15665: PPUSH
15666: CALL_OW 255
15670: PUSH
15671: LD_INT 7
15673: EQUAL
15674: AND
15675: PUSH
15676: LD_EXP 23
15680: PPUSH
15681: CALL_OW 305
15685: AND
15686: IFFALSE 15700
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
15688: LD_EXP 23
15692: PPUSH
15693: LD_STRING DEnd-JMM-Gary-1
15695: PPUSH
15696: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
15700: LD_EXP 26
15704: PUSH
15705: LD_EXP 13
15709: AND
15710: PUSH
15711: LD_EXP 26
15715: PPUSH
15716: CALL_OW 305
15720: AND
15721: IFFALSE 15735
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
15723: LD_EXP 26
15727: PPUSH
15728: LD_STRING DEnd-JMM-Sim-1
15730: PPUSH
15731: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
15735: LD_EXP 21
15739: PUSH
15740: LD_EXP 21
15744: PPUSH
15745: CALL_OW 255
15749: PUSH
15750: LD_INT 7
15752: EQUAL
15753: AND
15754: PUSH
15755: LD_EXP 21
15759: PPUSH
15760: CALL_OW 305
15764: AND
15765: IFFALSE 15779
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
15767: LD_EXP 21
15771: PPUSH
15772: LD_STRING DEnd-JMM-VanH-1
15774: PPUSH
15775: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
15779: LD_EXP 34
15783: PUSH
15784: LD_EXP 34
15788: PPUSH
15789: CALL_OW 305
15793: AND
15794: IFFALSE 15808
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
15796: LD_EXP 34
15800: PPUSH
15801: LD_STRING DEnd-JMM-Dol-1
15803: PPUSH
15804: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
15808: LD_EXP 34
15812: PUSH
15813: LD_EXP 34
15817: PPUSH
15818: CALL_OW 305
15822: AND
15823: IFFALSE 15837
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
15825: LD_EXP 34
15829: PPUSH
15830: LD_STRING DEnd-JMM-Dol-1
15832: PPUSH
15833: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
15837: LD_EXP 38
15841: PUSH
15842: LD_EXP 38
15846: PPUSH
15847: CALL_OW 305
15851: AND
15852: IFFALSE 15866
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
15854: LD_EXP 38
15858: PPUSH
15859: LD_STRING DEnd-JMM-Kap-1
15861: PPUSH
15862: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
15866: LD_EXP 41
15870: PUSH
15871: LD_EXP 41
15875: PPUSH
15876: CALL_OW 305
15880: AND
15881: IFFALSE 15895
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
15883: LD_EXP 41
15887: PPUSH
15888: LD_STRING DEnd-JMM-Kov-1
15890: PPUSH
15891: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
15895: LD_EXP 36
15899: PUSH
15900: LD_EXP 36
15904: PPUSH
15905: CALL_OW 305
15909: AND
15910: IFFALSE 15924
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
15912: LD_EXP 36
15916: PPUSH
15917: LD_STRING DEnd-JMM-Sch-1
15919: PPUSH
15920: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
15924: LD_EXP 32
15928: PUSH
15929: LD_EXP 32
15933: PPUSH
15934: CALL_OW 305
15938: AND
15939: IFFALSE 15953
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
15941: LD_EXP 32
15945: PPUSH
15946: LD_STRING DEnd-JMM-Tit-1
15948: PPUSH
15949: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
15953: LD_EXP 37
15957: PUSH
15958: LD_EXP 37
15962: PPUSH
15963: CALL_OW 305
15967: AND
15968: IFFALSE 15982
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
15970: LD_EXP 37
15974: PPUSH
15975: LD_STRING DEnd-JMM-Obl-1
15977: PPUSH
15978: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
15982: LD_EXP 39
15986: PUSH
15987: LD_EXP 39
15991: PPUSH
15992: CALL_OW 305
15996: AND
15997: IFFALSE 16011
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
15999: LD_EXP 39
16003: PPUSH
16004: LD_STRING DEnd-JMM-Lip-1
16006: PPUSH
16007: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16011: LD_EXP 33
16015: PUSH
16016: LD_EXP 33
16020: PPUSH
16021: CALL_OW 305
16025: AND
16026: PUSH
16027: LD_EXP 44
16031: AND
16032: IFFALSE 16046
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16034: LD_EXP 33
16038: PPUSH
16039: LD_STRING DEnd-Burlak-Fad-1
16041: PPUSH
16042: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16046: LD_EXP 40
16050: PUSH
16051: LD_EXP 40
16055: PPUSH
16056: CALL_OW 305
16060: AND
16061: IFFALSE 16075
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16063: LD_EXP 40
16067: PPUSH
16068: LD_STRING DEnd-Burlak-Ptr-1
16070: PPUSH
16071: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16075: LD_EXP 42
16079: PUSH
16080: LD_EXP 42
16084: PPUSH
16085: CALL_OW 305
16089: AND
16090: IFFALSE 16104
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16092: LD_EXP 42
16096: PPUSH
16097: LD_STRING DEnd-Burlak-Kuz-1
16099: PPUSH
16100: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16104: LD_EXP 31
16108: PUSH
16109: LD_EXP 31
16113: PPUSH
16114: CALL_OW 305
16118: AND
16119: PUSH
16120: LD_EXP 44
16124: AND
16125: IFFALSE 16139
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16127: LD_EXP 31
16131: PPUSH
16132: LD_STRING DEnd-Burlak-Kir-1
16134: PPUSH
16135: CALL_OW 88
// if Burlak then
16139: LD_EXP 44
16143: IFFALSE 16157
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16145: LD_EXP 12
16149: PPUSH
16150: LD_STRING DEnd-Burlak-JMM-1
16152: PPUSH
16153: CALL_OW 88
// AddMedal ( Hero , 1 ) ;
16157: LD_STRING Hero
16159: PPUSH
16160: LD_INT 1
16162: PPUSH
16163: CALL_OW 101
// AddMedal ( Artefact , [ - 1 , 1 ] [ artifactIResearched and artifactIIResearched and artifactIIIResearched ] ) ;
16167: LD_STRING Artefact
16169: PPUSH
16170: LD_INT 1
16172: NEG
16173: PUSH
16174: LD_INT 1
16176: PUSH
16177: EMPTY
16178: LIST
16179: LIST
16180: PUSH
16181: LD_EXP 9
16185: PUSH
16186: LD_EXP 10
16190: AND
16191: PUSH
16192: LD_EXP 11
16196: AND
16197: ARRAY
16198: PPUSH
16199: CALL_OW 101
// AddMedal ( ReconcileBurlak , [ - 1 , 1 ] [ IsLive ( Burlak ) ] ) ;
16203: LD_STRING ReconcileBurlak
16205: PPUSH
16206: LD_INT 1
16208: NEG
16209: PUSH
16210: LD_INT 1
16212: PUSH
16213: EMPTY
16214: LIST
16215: LIST
16216: PUSH
16217: LD_EXP 44
16221: PPUSH
16222: CALL_OW 300
16226: ARRAY
16227: PPUSH
16228: CALL_OW 101
// GiveMedals ( MAIN ) ;
16232: LD_STRING MAIN
16234: PPUSH
16235: CALL_OW 102
// YouWin ;
16239: CALL_OW 103
// end ; end_of_file
16243: END
// export function InitNature ; begin
16244: LD_INT 0
16246: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
16247: LD_INT 3
16249: PPUSH
16250: LD_INT 3
16252: PPUSH
16253: LD_INT 2
16255: PPUSH
16256: LD_INT 1
16258: PPUSH
16259: LD_INT 1
16261: PPUSH
16262: LD_INT 0
16264: PPUSH
16265: LD_INT 0
16267: PPUSH
16268: LD_INT 17
16270: PPUSH
16271: LD_INT 0
16273: PPUSH
16274: CALL 83930 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
16278: LD_INT 2
16280: PPUSH
16281: LD_INT 1
16283: PPUSH
16284: LD_INT 1
16286: PPUSH
16287: LD_INT 1
16289: PPUSH
16290: LD_INT 1
16292: PPUSH
16293: LD_INT 0
16295: PPUSH
16296: LD_INT 0
16298: PPUSH
16299: LD_INT 18
16301: PPUSH
16302: LD_INT 0
16304: PPUSH
16305: CALL 83930 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
16309: LD_INT 4
16311: PPUSH
16312: LD_INT 1
16314: PPUSH
16315: LD_INT 2
16317: PPUSH
16318: LD_INT 4
16320: PPUSH
16321: LD_INT 2
16323: PPUSH
16324: LD_INT 1
16326: PPUSH
16327: LD_INT 0
16329: PPUSH
16330: LD_INT 19
16332: PPUSH
16333: LD_INT 0
16335: PPUSH
16336: CALL 83930 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
16340: LD_INT 0
16342: PPUSH
16343: LD_INT 0
16345: PPUSH
16346: LD_INT 0
16348: PPUSH
16349: LD_INT 0
16351: PPUSH
16352: LD_INT 0
16354: PPUSH
16355: LD_INT 0
16357: PPUSH
16358: LD_INT 9
16360: PPUSH
16361: LD_INT 0
16363: PPUSH
16364: LD_INT 20
16366: PPUSH
16367: CALL 83930 0 9
// end ; end_of_file
16371: LD_VAR 0 1
16375: RET
// every 0 0$30 do var time ;
16376: GO 16378
16378: DISABLE
16379: LD_INT 0
16381: PPUSH
// begin time := 0 0$50 ;
16382: LD_ADDR_VAR 0 1
16386: PUSH
16387: LD_INT 1750
16389: ST_TO_ADDR
// repeat wait ( time ) ;
16390: LD_VAR 0 1
16394: PPUSH
16395: CALL_OW 67
// if Prob ( 50 ) then
16399: LD_INT 50
16401: PPUSH
16402: CALL_OW 13
16406: IFFALSE 16435
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
16408: LD_INT 1
16410: PPUSH
16411: LD_INT 5
16413: PPUSH
16414: CALL_OW 12
16418: PPUSH
16419: LD_INT 106
16421: PPUSH
16422: LD_INT 89
16424: PPUSH
16425: LD_INT 45
16427: PPUSH
16428: LD_INT 1
16430: PPUSH
16431: CALL_OW 56
// time := time + 0 0$3 ;
16435: LD_ADDR_VAR 0 1
16439: PUSH
16440: LD_VAR 0 1
16444: PUSH
16445: LD_INT 105
16447: PLUS
16448: ST_TO_ADDR
// if Prob ( 30 ) then
16449: LD_INT 30
16451: PPUSH
16452: CALL_OW 13
16456: IFFALSE 16502
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
16458: LD_INT 525
16460: PPUSH
16461: LD_INT 735
16463: PPUSH
16464: CALL_OW 12
16468: PPUSH
16469: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
16473: LD_INT 1
16475: PPUSH
16476: LD_INT 5
16478: PPUSH
16479: CALL_OW 12
16483: PPUSH
16484: LD_INT 21
16486: PPUSH
16487: LD_INT 26
16489: PPUSH
16490: LD_INT 12
16492: PPUSH
16493: LD_INT 1
16495: PPUSH
16496: CALL_OW 56
// end else
16500: GO 16538
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
16502: LD_INT 700
16504: PPUSH
16505: LD_INT 1225
16507: PPUSH
16508: CALL_OW 12
16512: PPUSH
16513: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
16517: LD_INT 1
16519: PPUSH
16520: LD_INT 5
16522: PPUSH
16523: CALL_OW 12
16527: PPUSH
16528: LD_INT 14
16530: PPUSH
16531: LD_INT 1
16533: PPUSH
16534: CALL_OW 55
// end ; if Prob ( 50 ) then
16538: LD_INT 50
16540: PPUSH
16541: CALL_OW 13
16545: IFFALSE 16591
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
16547: LD_INT 700
16549: PPUSH
16550: LD_INT 1050
16552: PPUSH
16553: CALL_OW 12
16557: PPUSH
16558: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
16562: LD_INT 1
16564: PPUSH
16565: LD_INT 5
16567: PPUSH
16568: CALL_OW 12
16572: PPUSH
16573: LD_INT 181
16575: PPUSH
16576: LD_INT 218
16578: PPUSH
16579: LD_INT 16
16581: PPUSH
16582: LD_INT 1
16584: PPUSH
16585: CALL_OW 56
// end else
16589: GO 16663
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
16591: LD_INT 350
16593: PPUSH
16594: LD_INT 525
16596: PPUSH
16597: CALL_OW 12
16601: PPUSH
16602: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
16606: LD_INT 1
16608: PPUSH
16609: LD_INT 5
16611: PPUSH
16612: CALL_OW 12
16616: PPUSH
16617: LD_INT 13
16619: PPUSH
16620: LD_INT 1
16622: PPUSH
16623: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
16627: LD_INT 350
16629: PPUSH
16630: LD_INT 700
16632: PPUSH
16633: CALL_OW 12
16637: PPUSH
16638: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
16642: LD_INT 1
16644: PPUSH
16645: LD_INT 5
16647: PPUSH
16648: CALL_OW 12
16652: PPUSH
16653: LD_INT 33
16655: PPUSH
16656: LD_INT 1
16658: PPUSH
16659: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
16663: LD_INT 65
16665: PUSH
16666: LD_INT 62
16668: PUSH
16669: LD_INT 55
16671: PUSH
16672: EMPTY
16673: LIST
16674: LIST
16675: LIST
16676: PUSH
16677: LD_OWVAR 67
16681: ARRAY
16682: PPUSH
16683: CALL_OW 13
16687: IFFALSE 16733
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
16689: LD_INT 525
16691: PPUSH
16692: LD_INT 875
16694: PPUSH
16695: CALL_OW 12
16699: PPUSH
16700: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
16704: LD_INT 1
16706: PPUSH
16707: LD_INT 5
16709: PPUSH
16710: CALL_OW 12
16714: PPUSH
16715: LD_INT 294
16717: PPUSH
16718: LD_INT 211
16720: PPUSH
16721: LD_INT 30
16723: PPUSH
16724: LD_INT 1
16726: PPUSH
16727: CALL_OW 56
// end else
16731: GO 16775
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
16733: LD_INT 420
16735: PPUSH
16736: LD_INT 770
16738: PPUSH
16739: CALL_OW 12
16743: PPUSH
16744: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
16748: LD_INT 1
16750: PPUSH
16751: LD_INT 5
16753: PPUSH
16754: CALL_OW 12
16758: PPUSH
16759: LD_INT 294
16761: PPUSH
16762: LD_INT 211
16764: PPUSH
16765: LD_INT 30
16767: PPUSH
16768: LD_INT 1
16770: PPUSH
16771: CALL_OW 56
// end ; if time > 2 2$20 then
16775: LD_VAR 0 1
16779: PUSH
16780: LD_INT 4900
16782: GREATER
16783: IFFALSE 16793
// time := 0 0$50 ;
16785: LD_ADDR_VAR 0 1
16789: PUSH
16790: LD_INT 1750
16792: ST_TO_ADDR
// until false ;
16793: LD_INT 0
16795: IFFALSE 16390
// end ;
16797: PPOPN 1
16799: END
// every 0 0$45 trigger tick < 10 10$00 do
16800: LD_OWVAR 1
16804: PUSH
16805: LD_INT 21000
16807: LESS
16808: IFFALSE 16856
16810: GO 16812
16812: DISABLE
// begin enable ;
16813: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
16814: LD_INT 350
16816: PPUSH
16817: LD_INT 700
16819: PPUSH
16820: CALL_OW 12
16824: PPUSH
16825: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
16829: LD_INT 3
16831: PPUSH
16832: LD_INT 5
16834: PPUSH
16835: CALL_OW 12
16839: PPUSH
16840: LD_INT 181
16842: PPUSH
16843: LD_INT 13
16845: PPUSH
16846: LD_INT 20
16848: PPUSH
16849: LD_INT 1
16851: PPUSH
16852: CALL_OW 56
// end ; end_of_file
16856: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
16857: LD_INT 0
16859: PPUSH
// SetArtifactRes ( 7 , true ) ;
16860: LD_INT 7
16862: PPUSH
16863: LD_INT 1
16865: PPUSH
16866: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
16870: LD_ADDR_EXP 57
16874: PUSH
16875: EMPTY
16876: PUSH
16877: EMPTY
16878: PUSH
16879: EMPTY
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: LIST
16885: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
16886: LD_ADDR_EXP 58
16890: PUSH
16891: LD_INT 1050
16893: PUSH
16894: LD_OWVAR 67
16898: MUL
16899: PUSH
16900: LD_INT 2800
16902: PUSH
16903: LD_OWVAR 67
16907: MUL
16908: PUSH
16909: LD_INT 1
16911: NEG
16912: PUSH
16913: EMPTY
16914: LIST
16915: LIST
16916: LIST
16917: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
16918: LD_ADDR_EXP 59
16922: PUSH
16923: LD_INT 10
16925: PUSH
16926: LD_INT 35
16928: PUSH
16929: LD_INT 100
16931: PUSH
16932: EMPTY
16933: LIST
16934: LIST
16935: LIST
16936: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
16937: LD_ADDR_EXP 60
16941: PUSH
16942: LD_INT 0
16944: PUSH
16945: LD_INT 0
16947: PUSH
16948: LD_INT 0
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: LIST
16955: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
16956: LD_ADDR_EXP 62
16960: PUSH
16961: LD_INT 300
16963: PUSH
16964: LD_INT 500
16966: PUSH
16967: LD_INT 800
16969: PUSH
16970: EMPTY
16971: LIST
16972: LIST
16973: LIST
16974: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
16975: LD_ADDR_EXP 63
16979: PUSH
16980: LD_INT 0
16982: PUSH
16983: LD_INT 0
16985: PUSH
16986: LD_INT 0
16988: PUSH
16989: EMPTY
16990: LIST
16991: LIST
16992: LIST
16993: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
16994: LD_ADDR_EXP 64
16998: PUSH
16999: LD_INT 0
17001: PUSH
17002: LD_INT 0
17004: PUSH
17005: LD_INT 0
17007: PUSH
17008: EMPTY
17009: LIST
17010: LIST
17011: LIST
17012: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17013: LD_ADDR_EXP 61
17017: PUSH
17018: LD_INT 0
17020: PUSH
17021: LD_INT 0
17023: PUSH
17024: LD_INT 0
17026: PUSH
17027: EMPTY
17028: LIST
17029: LIST
17030: LIST
17031: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17032: LD_ADDR_EXP 65
17036: PUSH
17037: LD_INT 4
17039: PUSH
17040: LD_INT 3
17042: PUSH
17043: LD_INT 1
17045: PUSH
17046: EMPTY
17047: LIST
17048: LIST
17049: LIST
17050: PUSH
17051: LD_INT 5
17053: PUSH
17054: LD_INT 4
17056: PUSH
17057: LD_INT 2
17059: PUSH
17060: EMPTY
17061: LIST
17062: LIST
17063: LIST
17064: PUSH
17065: LD_INT 6
17067: PUSH
17068: LD_INT 3
17070: PUSH
17071: LD_INT 3
17073: PUSH
17074: EMPTY
17075: LIST
17076: LIST
17077: LIST
17078: PUSH
17079: EMPTY
17080: LIST
17081: LIST
17082: LIST
17083: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17084: LD_ADDR_EXP 66
17088: PUSH
17089: LD_INT 0
17091: PUSH
17092: LD_INT 0
17094: PUSH
17095: LD_INT 0
17097: PUSH
17098: EMPTY
17099: LIST
17100: LIST
17101: LIST
17102: ST_TO_ADDR
// end ;
17103: LD_VAR 0 1
17107: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17108: LD_INT 24
17110: PPUSH
17111: LD_INT 7
17113: PPUSH
17114: CALL_OW 321
17118: PUSH
17119: LD_INT 2
17121: EQUAL
17122: IFFALSE 18048
17124: GO 17126
17126: DISABLE
17127: LD_INT 0
17129: PPUSH
17130: PPUSH
17131: PPUSH
17132: PPUSH
17133: PPUSH
// begin enable ;
17134: ENABLE
// for i = 1 to 3 do
17135: LD_ADDR_VAR 0 1
17139: PUSH
17140: DOUBLE
17141: LD_INT 1
17143: DEC
17144: ST_TO_ADDR
17145: LD_INT 3
17147: PUSH
17148: FOR_TO
17149: IFFALSE 18046
// begin pos := FindArtifact ( i + 2 ) ;
17151: LD_ADDR_VAR 0 2
17155: PUSH
17156: LD_VAR 0 1
17160: PUSH
17161: LD_INT 2
17163: PLUS
17164: PPUSH
17165: CALL_OW 469
17169: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
17170: LD_ADDR_EXP 57
17174: PUSH
17175: LD_EXP 57
17179: PPUSH
17180: LD_VAR 0 1
17184: PPUSH
17185: LD_VAR 0 2
17189: PPUSH
17190: CALL_OW 1
17194: ST_TO_ADDR
// if pos then
17195: LD_VAR 0 2
17199: IFFALSE 17907
// begin case i of 1 :
17201: LD_VAR 0 1
17205: PUSH
17206: LD_INT 1
17208: DOUBLE
17209: EQUAL
17210: IFTRUE 17214
17212: GO 17291
17214: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
17215: LD_ADDR_VAR 0 4
17219: PUSH
17220: LD_INT 22
17222: PUSH
17223: LD_INT 7
17225: PUSH
17226: EMPTY
17227: LIST
17228: LIST
17229: PUSH
17230: LD_INT 23
17232: PUSH
17233: LD_INT 1
17235: PUSH
17236: EMPTY
17237: LIST
17238: LIST
17239: PUSH
17240: LD_INT 2
17242: PUSH
17243: LD_INT 30
17245: PUSH
17246: LD_INT 8
17248: PUSH
17249: EMPTY
17250: LIST
17251: LIST
17252: PUSH
17253: LD_INT 30
17255: PUSH
17256: LD_INT 7
17258: PUSH
17259: EMPTY
17260: LIST
17261: LIST
17262: PUSH
17263: LD_INT 30
17265: PUSH
17266: LD_INT 11
17268: PUSH
17269: EMPTY
17270: LIST
17271: LIST
17272: PUSH
17273: EMPTY
17274: LIST
17275: LIST
17276: LIST
17277: LIST
17278: PUSH
17279: EMPTY
17280: LIST
17281: LIST
17282: LIST
17283: PPUSH
17284: CALL_OW 69
17288: ST_TO_ADDR
17289: GO 17399
17291: LD_INT 2
17293: DOUBLE
17294: EQUAL
17295: IFTRUE 17299
17297: GO 17376
17299: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
17300: LD_ADDR_VAR 0 4
17304: PUSH
17305: LD_INT 22
17307: PUSH
17308: LD_INT 7
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: PUSH
17315: LD_INT 23
17317: PUSH
17318: LD_INT 3
17320: PUSH
17321: EMPTY
17322: LIST
17323: LIST
17324: PUSH
17325: LD_INT 2
17327: PUSH
17328: LD_INT 30
17330: PUSH
17331: LD_INT 8
17333: PUSH
17334: EMPTY
17335: LIST
17336: LIST
17337: PUSH
17338: LD_INT 30
17340: PUSH
17341: LD_INT 7
17343: PUSH
17344: EMPTY
17345: LIST
17346: LIST
17347: PUSH
17348: LD_INT 30
17350: PUSH
17351: LD_INT 11
17353: PUSH
17354: EMPTY
17355: LIST
17356: LIST
17357: PUSH
17358: EMPTY
17359: LIST
17360: LIST
17361: LIST
17362: LIST
17363: PUSH
17364: EMPTY
17365: LIST
17366: LIST
17367: LIST
17368: PPUSH
17369: CALL_OW 69
17373: ST_TO_ADDR
17374: GO 17399
17376: LD_INT 3
17378: DOUBLE
17379: EQUAL
17380: IFTRUE 17384
17382: GO 17398
17384: POP
// labs := [ alien ] ; end ;
17385: LD_ADDR_VAR 0 4
17389: PUSH
17390: LD_INT 1
17392: PUSH
17393: EMPTY
17394: LIST
17395: ST_TO_ADDR
17396: GO 17399
17398: POP
// if not labs then
17399: LD_VAR 0 4
17403: NOT
17404: IFFALSE 17408
// continue ;
17406: GO 17148
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
17408: LD_ADDR_VAR 0 5
17412: PUSH
17413: LD_VAR 0 4
17417: PPUSH
17418: LD_EXP 57
17422: PUSH
17423: LD_VAR 0 1
17427: ARRAY
17428: PUSH
17429: LD_INT 1
17431: ARRAY
17432: PPUSH
17433: LD_EXP 57
17437: PUSH
17438: LD_VAR 0 1
17442: ARRAY
17443: PUSH
17444: LD_INT 2
17446: ARRAY
17447: PPUSH
17448: CALL_OW 73
17452: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
17453: LD_VAR 0 5
17457: NOT
17458: PUSH
17459: LD_VAR 0 5
17463: PUSH
17464: LD_EXP 64
17468: PUSH
17469: LD_VAR 0 1
17473: ARRAY
17474: NONEQUAL
17475: OR
17476: IFFALSE 17581
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
17478: LD_INT 7
17480: PPUSH
17481: LD_EXP 65
17485: PUSH
17486: LD_VAR 0 1
17490: ARRAY
17491: PUSH
17492: LD_INT 3
17494: ARRAY
17495: PPUSH
17496: LD_INT 0
17498: PPUSH
17499: LD_EXP 64
17503: PUSH
17504: LD_VAR 0 1
17508: ARRAY
17509: PPUSH
17510: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
17514: LD_INT 7
17516: PPUSH
17517: LD_EXP 65
17521: PUSH
17522: LD_VAR 0 1
17526: ARRAY
17527: PUSH
17528: LD_INT 1
17530: ARRAY
17531: PPUSH
17532: LD_INT 0
17534: PPUSH
17535: LD_EXP 64
17539: PUSH
17540: LD_VAR 0 1
17544: ARRAY
17545: PPUSH
17546: CALL_OW 468
// if nearestLab then
17550: LD_VAR 0 5
17554: IFFALSE 17581
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
17556: LD_ADDR_EXP 64
17560: PUSH
17561: LD_EXP 64
17565: PPUSH
17566: LD_VAR 0 1
17570: PPUSH
17571: LD_VAR 0 5
17575: PPUSH
17576: CALL_OW 1
17580: ST_TO_ADDR
// end ; if not nearestLab then
17581: LD_VAR 0 5
17585: NOT
17586: IFFALSE 17590
// continue ;
17588: GO 17148
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
17590: LD_VAR 0 5
17594: PPUSH
17595: LD_EXP 57
17599: PUSH
17600: LD_VAR 0 1
17604: ARRAY
17605: PUSH
17606: LD_INT 1
17608: ARRAY
17609: PPUSH
17610: LD_EXP 57
17614: PUSH
17615: LD_VAR 0 1
17619: ARRAY
17620: PUSH
17621: LD_INT 2
17623: ARRAY
17624: PPUSH
17625: CALL_OW 297
17629: PUSH
17630: LD_INT 8
17632: LESS
17633: IFFALSE 17830
// begin if not artifactsResearched [ i ] then
17635: LD_EXP 60
17639: PUSH
17640: LD_VAR 0 1
17644: ARRAY
17645: NOT
17646: IFFALSE 17727
// begin if BuildingStatus ( nearestLab ) = bs_idle then
17648: LD_VAR 0 5
17652: PPUSH
17653: CALL_OW 461
17657: PUSH
17658: LD_INT 2
17660: EQUAL
17661: IFFALSE 17695
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
17663: LD_INT 7
17665: PPUSH
17666: LD_EXP 65
17670: PUSH
17671: LD_VAR 0 1
17675: ARRAY
17676: PUSH
17677: LD_INT 3
17679: ARRAY
17680: PPUSH
17681: LD_INT 2
17683: PPUSH
17684: LD_VAR 0 5
17688: PPUSH
17689: CALL_OW 468
17693: GO 17725
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
17695: LD_INT 7
17697: PPUSH
17698: LD_EXP 65
17702: PUSH
17703: LD_VAR 0 1
17707: ARRAY
17708: PUSH
17709: LD_INT 3
17711: ARRAY
17712: PPUSH
17713: LD_INT 1
17715: PPUSH
17716: LD_VAR 0 5
17720: PPUSH
17721: CALL_OW 468
// end else
17725: GO 17828
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
17727: LD_VAR 0 5
17731: PPUSH
17732: CALL_OW 461
17736: PUSH
17737: LD_INT 2
17739: EQUAL
17740: PUSH
17741: LD_EXP 66
17745: PUSH
17746: LD_VAR 0 1
17750: ARRAY
17751: AND
17752: IFFALSE 17798
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
17754: LD_INT 7
17756: PPUSH
17757: LD_EXP 65
17761: PUSH
17762: LD_VAR 0 1
17766: ARRAY
17767: PUSH
17768: LD_INT 1
17770: ARRAY
17771: PPUSH
17772: LD_EXP 65
17776: PUSH
17777: LD_VAR 0 1
17781: ARRAY
17782: PUSH
17783: LD_INT 2
17785: ARRAY
17786: PPUSH
17787: LD_VAR 0 5
17791: PPUSH
17792: CALL_OW 468
17796: GO 17828
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
17798: LD_INT 7
17800: PPUSH
17801: LD_EXP 65
17805: PUSH
17806: LD_VAR 0 1
17810: ARRAY
17811: PUSH
17812: LD_INT 1
17814: ARRAY
17815: PPUSH
17816: LD_INT 1
17818: PPUSH
17819: LD_VAR 0 5
17823: PPUSH
17824: CALL_OW 468
// end else
17828: GO 17905
// begin if not artifactsResearched [ i ] then
17830: LD_EXP 60
17834: PUSH
17835: LD_VAR 0 1
17839: ARRAY
17840: NOT
17841: IFFALSE 17875
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
17843: LD_INT 7
17845: PPUSH
17846: LD_EXP 65
17850: PUSH
17851: LD_VAR 0 1
17855: ARRAY
17856: PUSH
17857: LD_INT 3
17859: ARRAY
17860: PPUSH
17861: LD_INT 0
17863: PPUSH
17864: LD_VAR 0 5
17868: PPUSH
17869: CALL_OW 468
17873: GO 17905
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
17875: LD_INT 7
17877: PPUSH
17878: LD_EXP 65
17882: PUSH
17883: LD_VAR 0 1
17887: ARRAY
17888: PUSH
17889: LD_INT 1
17891: ARRAY
17892: PPUSH
17893: LD_INT 0
17895: PPUSH
17896: LD_VAR 0 5
17900: PPUSH
17901: CALL_OW 468
// end ; end else
17905: GO 18044
// begin if not artifactsLabs [ i ] then
17907: LD_EXP 64
17911: PUSH
17912: LD_VAR 0 1
17916: ARRAY
17917: NOT
17918: IFFALSE 17922
// continue ;
17920: GO 17148
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
17922: LD_INT 7
17924: PPUSH
17925: LD_EXP 65
17929: PUSH
17930: LD_VAR 0 1
17934: ARRAY
17935: PUSH
17936: LD_INT 3
17938: ARRAY
17939: PPUSH
17940: LD_INT 0
17942: PPUSH
17943: LD_EXP 64
17947: PUSH
17948: LD_VAR 0 1
17952: ARRAY
17953: PPUSH
17954: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
17958: LD_INT 7
17960: PPUSH
17961: LD_EXP 65
17965: PUSH
17966: LD_VAR 0 1
17970: ARRAY
17971: PUSH
17972: LD_INT 1
17974: ARRAY
17975: PPUSH
17976: LD_INT 0
17978: PPUSH
17979: LD_EXP 64
17983: PUSH
17984: LD_VAR 0 1
17988: ARRAY
17989: PPUSH
17990: CALL_OW 468
// if artifactsLabsWorking [ i ] then
17994: LD_EXP 61
17998: PUSH
17999: LD_VAR 0 1
18003: ARRAY
18004: IFFALSE 18044
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18006: LD_ADDR_EXP 61
18010: PUSH
18011: LD_EXP 61
18015: PPUSH
18016: LD_VAR 0 1
18020: PPUSH
18021: LD_INT 0
18023: PPUSH
18024: CALL_OW 1
18028: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18029: LD_EXP 64
18033: PUSH
18034: LD_VAR 0 1
18038: ARRAY
18039: PPUSH
18040: CALL_OW 127
// end ; end ; end ;
18044: GO 17148
18046: POP
18047: POP
// end ;
18048: PPOPN 5
18050: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18051: LD_INT 0
18053: PPUSH
18054: PPUSH
18055: PPUSH
18056: PPUSH
18057: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18058: LD_VAR 0 2
18062: PUSH
18063: LD_EXP 65
18067: PUSH
18068: LD_INT 1
18070: ARRAY
18071: PUSH
18072: LD_INT 3
18074: ARRAY
18075: EQUAL
18076: IFFALSE 18199
// begin lab := artifactsLabs [ 1 ] ;
18078: LD_ADDR_VAR 0 6
18082: PUSH
18083: LD_EXP 64
18087: PUSH
18088: LD_INT 1
18090: ARRAY
18091: ST_TO_ADDR
// if not lab then
18092: LD_VAR 0 6
18096: NOT
18097: IFFALSE 18101
// exit ;
18099: GO 19133
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18101: LD_VAR 0 6
18105: PPUSH
18106: LD_EXP 62
18110: PUSH
18111: LD_INT 1
18113: ARRAY
18114: PPUSH
18115: LD_INT 1
18117: PPUSH
18118: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18122: LD_EXP 63
18126: PUSH
18127: LD_INT 1
18129: ARRAY
18130: IFFALSE 18150
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18132: LD_VAR 0 6
18136: PPUSH
18137: LD_EXP 63
18141: PUSH
18142: LD_INT 1
18144: ARRAY
18145: PPUSH
18146: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
18150: LD_ADDR_EXP 61
18154: PUSH
18155: LD_EXP 61
18159: PPUSH
18160: LD_INT 1
18162: PPUSH
18163: LD_INT 1
18165: PPUSH
18166: CALL_OW 1
18170: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
18171: LD_INT 7
18173: PPUSH
18174: LD_EXP 65
18178: PUSH
18179: LD_INT 1
18181: ARRAY
18182: PUSH
18183: LD_INT 3
18185: ARRAY
18186: PPUSH
18187: LD_INT 0
18189: PPUSH
18190: LD_VAR 0 6
18194: PPUSH
18195: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
18199: LD_VAR 0 2
18203: PUSH
18204: LD_EXP 65
18208: PUSH
18209: LD_INT 2
18211: ARRAY
18212: PUSH
18213: LD_INT 3
18215: ARRAY
18216: EQUAL
18217: IFFALSE 18340
// begin lab := artifactsLabs [ 2 ] ;
18219: LD_ADDR_VAR 0 6
18223: PUSH
18224: LD_EXP 64
18228: PUSH
18229: LD_INT 2
18231: ARRAY
18232: ST_TO_ADDR
// if not lab then
18233: LD_VAR 0 6
18237: NOT
18238: IFFALSE 18242
// exit ;
18240: GO 19133
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
18242: LD_VAR 0 6
18246: PPUSH
18247: LD_EXP 62
18251: PUSH
18252: LD_INT 2
18254: ARRAY
18255: PPUSH
18256: LD_INT 1
18258: PPUSH
18259: CALL_OW 486
// if artifactsResProgress [ 2 ] then
18263: LD_EXP 63
18267: PUSH
18268: LD_INT 2
18270: ARRAY
18271: IFFALSE 18291
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
18273: LD_VAR 0 6
18277: PPUSH
18278: LD_EXP 63
18282: PUSH
18283: LD_INT 2
18285: ARRAY
18286: PPUSH
18287: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
18291: LD_ADDR_EXP 61
18295: PUSH
18296: LD_EXP 61
18300: PPUSH
18301: LD_INT 2
18303: PPUSH
18304: LD_INT 1
18306: PPUSH
18307: CALL_OW 1
18311: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
18312: LD_INT 7
18314: PPUSH
18315: LD_EXP 65
18319: PUSH
18320: LD_INT 2
18322: ARRAY
18323: PUSH
18324: LD_INT 3
18326: ARRAY
18327: PPUSH
18328: LD_INT 0
18330: PPUSH
18331: LD_VAR 0 6
18335: PPUSH
18336: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
18340: LD_VAR 0 2
18344: PUSH
18345: LD_EXP 65
18349: PUSH
18350: LD_INT 3
18352: ARRAY
18353: PUSH
18354: LD_INT 3
18356: ARRAY
18357: EQUAL
18358: IFFALSE 18481
// begin lab := artifactsLabs [ 3 ] ;
18360: LD_ADDR_VAR 0 6
18364: PUSH
18365: LD_EXP 64
18369: PUSH
18370: LD_INT 3
18372: ARRAY
18373: ST_TO_ADDR
// if not lab then
18374: LD_VAR 0 6
18378: NOT
18379: IFFALSE 18383
// exit ;
18381: GO 19133
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
18383: LD_VAR 0 6
18387: PPUSH
18388: LD_EXP 62
18392: PUSH
18393: LD_INT 3
18395: ARRAY
18396: PPUSH
18397: LD_INT 1
18399: PPUSH
18400: CALL_OW 486
// if artifactsResProgress [ 3 ] then
18404: LD_EXP 63
18408: PUSH
18409: LD_INT 3
18411: ARRAY
18412: IFFALSE 18432
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
18414: LD_VAR 0 6
18418: PPUSH
18419: LD_EXP 63
18423: PUSH
18424: LD_INT 3
18426: ARRAY
18427: PPUSH
18428: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
18432: LD_ADDR_EXP 61
18436: PUSH
18437: LD_EXP 61
18441: PPUSH
18442: LD_INT 3
18444: PPUSH
18445: LD_INT 1
18447: PPUSH
18448: CALL_OW 1
18452: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
18453: LD_INT 7
18455: PPUSH
18456: LD_EXP 65
18460: PUSH
18461: LD_INT 3
18463: ARRAY
18464: PUSH
18465: LD_INT 3
18467: ARRAY
18468: PPUSH
18469: LD_INT 0
18471: PPUSH
18472: LD_VAR 0 6
18476: PPUSH
18477: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
18481: LD_VAR 0 2
18485: PUSH
18486: LD_EXP 65
18490: PUSH
18491: LD_INT 1
18493: ARRAY
18494: PUSH
18495: LD_INT 1
18497: ARRAY
18498: EQUAL
18499: IFFALSE 18657
// begin lab := artifactsLabs [ 1 ] ;
18501: LD_ADDR_VAR 0 6
18505: PUSH
18506: LD_EXP 64
18510: PUSH
18511: LD_INT 1
18513: ARRAY
18514: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
18515: LD_VAR 0 6
18519: PPUSH
18520: CALL_OW 274
18524: PPUSH
18525: CALL 92078 0 1
18529: PUSH
18530: LD_INT 3
18532: ARRAY
18533: PUSH
18534: LD_EXP 59
18538: PUSH
18539: LD_INT 1
18541: ARRAY
18542: LESS
18543: IFFALSE 18557
// begin HintSpec ( ArtifactCost , 2 ) ;
18545: LD_STRING ArtifactCost
18547: PPUSH
18548: LD_INT 2
18550: PPUSH
18551: CALL_OW 338
// exit ;
18555: GO 19133
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
18557: LD_ADDR_EXP 66
18561: PUSH
18562: LD_EXP 66
18566: PPUSH
18567: LD_INT 1
18569: PPUSH
18570: LD_INT 0
18572: PPUSH
18573: CALL_OW 1
18577: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
18578: LD_VAR 0 3
18582: PPUSH
18583: LD_VAR 0 4
18587: PPUSH
18588: LD_INT 7
18590: PPUSH
18591: LD_INT 12
18593: NEG
18594: PPUSH
18595: CALL_OW 330
// wait ( 0 0$30 ) ;
18599: LD_INT 1050
18601: PPUSH
18602: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
18606: LD_VAR 0 3
18610: PPUSH
18611: LD_VAR 0 4
18615: PPUSH
18616: LD_INT 7
18618: PPUSH
18619: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
18623: LD_EXP 58
18627: PUSH
18628: LD_INT 1
18630: ARRAY
18631: PPUSH
18632: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
18636: LD_ADDR_EXP 66
18640: PUSH
18641: LD_EXP 66
18645: PPUSH
18646: LD_INT 1
18648: PPUSH
18649: LD_INT 1
18651: PPUSH
18652: CALL_OW 1
18656: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
18657: LD_VAR 0 2
18661: PUSH
18662: LD_EXP 65
18666: PUSH
18667: LD_INT 2
18669: ARRAY
18670: PUSH
18671: LD_INT 1
18673: ARRAY
18674: EQUAL
18675: IFFALSE 18887
// begin lab := artifactsLabs [ 2 ] ;
18677: LD_ADDR_VAR 0 6
18681: PUSH
18682: LD_EXP 64
18686: PUSH
18687: LD_INT 2
18689: ARRAY
18690: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
18691: LD_VAR 0 3
18695: PUSH
18696: LD_INT 81
18698: PUSH
18699: LD_INT 7
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PUSH
18706: LD_INT 2
18708: PUSH
18709: LD_INT 32
18711: PUSH
18712: LD_INT 3
18714: PUSH
18715: EMPTY
18716: LIST
18717: LIST
18718: PUSH
18719: LD_INT 30
18721: PUSH
18722: LD_INT 28
18724: PUSH
18725: EMPTY
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 30
18731: PUSH
18732: LD_INT 30
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: PUSH
18739: LD_INT 35
18741: PUSH
18742: LD_INT 49
18744: PUSH
18745: EMPTY
18746: LIST
18747: LIST
18748: PUSH
18749: LD_INT 34
18751: PUSH
18752: LD_INT 49
18754: PUSH
18755: EMPTY
18756: LIST
18757: LIST
18758: PUSH
18759: EMPTY
18760: LIST
18761: LIST
18762: LIST
18763: LIST
18764: LIST
18765: LIST
18766: PUSH
18767: EMPTY
18768: LIST
18769: LIST
18770: PPUSH
18771: CALL_OW 69
18775: IN
18776: NOT
18777: IFFALSE 18781
// exit ;
18779: GO 19133
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
18781: LD_VAR 0 6
18785: PPUSH
18786: CALL_OW 274
18790: PPUSH
18791: CALL 92078 0 1
18795: PUSH
18796: LD_INT 3
18798: ARRAY
18799: PUSH
18800: LD_EXP 59
18804: PUSH
18805: LD_INT 2
18807: ARRAY
18808: LESS
18809: IFFALSE 18823
// begin HintSpec ( ArtifactCost , 2 ) ;
18811: LD_STRING ArtifactCost
18813: PPUSH
18814: LD_INT 2
18816: PPUSH
18817: CALL_OW 338
// exit ;
18821: GO 19133
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
18823: LD_ADDR_EXP 66
18827: PUSH
18828: LD_EXP 66
18832: PPUSH
18833: LD_INT 2
18835: PPUSH
18836: LD_INT 0
18838: PPUSH
18839: CALL_OW 1
18843: ST_TO_ADDR
// KillUnit ( x ) ;
18844: LD_VAR 0 3
18848: PPUSH
18849: CALL_OW 66
// wait ( artifactsRecharge [ 2 ] ) ;
18853: LD_EXP 58
18857: PUSH
18858: LD_INT 2
18860: ARRAY
18861: PPUSH
18862: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
18866: LD_ADDR_EXP 66
18870: PUSH
18871: LD_EXP 66
18875: PPUSH
18876: LD_INT 2
18878: PPUSH
18879: LD_INT 1
18881: PPUSH
18882: CALL_OW 1
18886: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
18887: LD_VAR 0 2
18891: PUSH
18892: LD_EXP 65
18896: PUSH
18897: LD_INT 3
18899: ARRAY
18900: PUSH
18901: LD_INT 1
18903: ARRAY
18904: EQUAL
18905: IFFALSE 19133
// begin lab := artifactsLabs [ 3 ] ;
18907: LD_ADDR_VAR 0 6
18911: PUSH
18912: LD_EXP 64
18916: PUSH
18917: LD_INT 3
18919: ARRAY
18920: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
18921: LD_VAR 0 6
18925: PPUSH
18926: CALL_OW 274
18930: PPUSH
18931: CALL 92078 0 1
18935: PUSH
18936: LD_INT 3
18938: ARRAY
18939: PUSH
18940: LD_EXP 59
18944: PUSH
18945: LD_INT 3
18947: ARRAY
18948: LESS
18949: IFFALSE 18963
// begin HintSpec ( ArtifactCost , 2 ) ;
18951: LD_STRING ArtifactCost
18953: PPUSH
18954: LD_INT 2
18956: PPUSH
18957: CALL_OW 338
// exit ;
18961: GO 19133
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
18963: LD_INT 37
18965: PPUSH
18966: LD_INT 1
18968: PPUSH
18969: CALL_OW 424
// time := 0 0$30 ;
18973: LD_ADDR_VAR 0 7
18977: PUSH
18978: LD_INT 1050
18980: ST_TO_ADDR
// repeat display_strings := [ Am15a-1 , time ] ;
18981: LD_ADDR_OWVAR 47
18985: PUSH
18986: LD_STRING Am15a-1
18988: PUSH
18989: LD_VAR 0 7
18993: PUSH
18994: EMPTY
18995: LIST
18996: LIST
18997: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18998: LD_INT 35
19000: PPUSH
19001: CALL_OW 67
// time := time - 0 0$1 ;
19005: LD_ADDR_VAR 0 7
19009: PUSH
19010: LD_VAR 0 7
19014: PUSH
19015: LD_INT 35
19017: MINUS
19018: ST_TO_ADDR
// until time = 0 0$00 ;
19019: LD_VAR 0 7
19023: PUSH
19024: LD_INT 0
19026: EQUAL
19027: IFFALSE 18981
// display_strings :=  ;
19029: LD_ADDR_OWVAR 47
19033: PUSH
19034: LD_STRING 
19036: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19037: LD_INT 37
19039: PPUSH
19040: LD_INT 0
19042: PPUSH
19043: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19047: LD_ADDR_VAR 0 8
19051: PUSH
19052: LD_INT 37
19054: PPUSH
19055: LD_INT 3
19057: PUSH
19058: LD_INT 21
19060: PUSH
19061: LD_INT 3
19063: PUSH
19064: EMPTY
19065: LIST
19066: LIST
19067: PUSH
19068: EMPTY
19069: LIST
19070: LIST
19071: PPUSH
19072: CALL_OW 70
19076: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19077: LD_VAR 0 3
19081: PPUSH
19082: LD_VAR 0 4
19086: PPUSH
19087: CALL_OW 84
// for un in list do
19091: LD_ADDR_VAR 0 9
19095: PUSH
19096: LD_VAR 0 8
19100: PUSH
19101: FOR_IN
19102: IFFALSE 19131
// TeleportUnit ( un , x , y , 12 , true ) ;
19104: LD_VAR 0 9
19108: PPUSH
19109: LD_VAR 0 3
19113: PPUSH
19114: LD_VAR 0 4
19118: PPUSH
19119: LD_INT 12
19121: PPUSH
19122: LD_INT 1
19124: PPUSH
19125: CALL_OW 483
19129: GO 19101
19131: POP
19132: POP
// end ; end ;
19133: PPOPN 9
19135: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
19136: LD_INT 0
19138: PPUSH
19139: PPUSH
// begin labNum := 0 ;
19140: LD_ADDR_VAR 0 4
19144: PUSH
19145: LD_INT 0
19147: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19148: LD_ADDR_VAR 0 3
19152: PUSH
19153: DOUBLE
19154: LD_INT 1
19156: DEC
19157: ST_TO_ADDR
19158: LD_EXP 64
19162: PUSH
19163: FOR_TO
19164: IFFALSE 19198
// if artifactsLabs [ i ] = lab then
19166: LD_EXP 64
19170: PUSH
19171: LD_VAR 0 3
19175: ARRAY
19176: PUSH
19177: LD_VAR 0 1
19181: EQUAL
19182: IFFALSE 19196
// begin labNum := i ;
19184: LD_ADDR_VAR 0 4
19188: PUSH
19189: LD_VAR 0 3
19193: ST_TO_ADDR
// break ;
19194: GO 19198
// end ;
19196: GO 19163
19198: POP
19199: POP
// if not labNum then
19200: LD_VAR 0 4
19204: NOT
19205: IFFALSE 19209
// exit ;
19207: GO 19287
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
19209: LD_INT 7
19211: PPUSH
19212: LD_EXP 65
19216: PUSH
19217: LD_VAR 0 4
19221: ARRAY
19222: PUSH
19223: LD_INT 3
19225: ARRAY
19226: PPUSH
19227: LD_INT 2
19229: PPUSH
19230: LD_VAR 0 1
19234: PPUSH
19235: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
19239: LD_ADDR_EXP 63
19243: PUSH
19244: LD_EXP 63
19248: PPUSH
19249: LD_VAR 0 4
19253: PPUSH
19254: LD_VAR 0 2
19258: PPUSH
19259: CALL_OW 1
19263: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
19264: LD_ADDR_EXP 61
19268: PUSH
19269: LD_EXP 61
19273: PPUSH
19274: LD_VAR 0 4
19278: PPUSH
19279: LD_INT 0
19281: PPUSH
19282: CALL_OW 1
19286: ST_TO_ADDR
// end ;
19287: PPOPN 4
19289: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
19290: LD_INT 0
19292: PPUSH
19293: PPUSH
// begin labNum := 0 ;
19294: LD_ADDR_VAR 0 3
19298: PUSH
19299: LD_INT 0
19301: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19302: LD_ADDR_VAR 0 2
19306: PUSH
19307: DOUBLE
19308: LD_INT 1
19310: DEC
19311: ST_TO_ADDR
19312: LD_EXP 64
19316: PUSH
19317: FOR_TO
19318: IFFALSE 19352
// if artifactsLabs [ i ] = lab then
19320: LD_EXP 64
19324: PUSH
19325: LD_VAR 0 2
19329: ARRAY
19330: PUSH
19331: LD_VAR 0 1
19335: EQUAL
19336: IFFALSE 19350
// begin labNum := i ;
19338: LD_ADDR_VAR 0 3
19342: PUSH
19343: LD_VAR 0 2
19347: ST_TO_ADDR
// break ;
19348: GO 19352
// end ;
19350: GO 19317
19352: POP
19353: POP
// if not labNum then
19354: LD_VAR 0 3
19358: NOT
19359: IFFALSE 19363
// exit ;
19361: GO 19525
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
19363: LD_INT 7
19365: PPUSH
19366: LD_EXP 65
19370: PUSH
19371: LD_VAR 0 3
19375: ARRAY
19376: PUSH
19377: LD_INT 3
19379: ARRAY
19380: PPUSH
19381: LD_INT 0
19383: PPUSH
19384: LD_VAR 0 1
19388: PPUSH
19389: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
19393: LD_ADDR_EXP 60
19397: PUSH
19398: LD_EXP 60
19402: PPUSH
19403: LD_VAR 0 3
19407: PPUSH
19408: LD_INT 1
19410: PPUSH
19411: CALL_OW 1
19415: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
19416: LD_ADDR_EXP 66
19420: PUSH
19421: LD_EXP 66
19425: PPUSH
19426: LD_VAR 0 3
19430: PPUSH
19431: LD_INT 1
19433: PPUSH
19434: CALL_OW 1
19438: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
19439: LD_ADDR_EXP 61
19443: PUSH
19444: LD_EXP 61
19448: PPUSH
19449: LD_VAR 0 3
19453: PPUSH
19454: LD_INT 0
19456: PPUSH
19457: CALL_OW 1
19461: ST_TO_ADDR
// case labNum of 1 :
19462: LD_VAR 0 3
19466: PUSH
19467: LD_INT 1
19469: DOUBLE
19470: EQUAL
19471: IFTRUE 19475
19473: GO 19486
19475: POP
// artifactIResearched := true ; 2 :
19476: LD_ADDR_EXP 9
19480: PUSH
19481: LD_INT 1
19483: ST_TO_ADDR
19484: GO 19525
19486: LD_INT 2
19488: DOUBLE
19489: EQUAL
19490: IFTRUE 19494
19492: GO 19505
19494: POP
// artifactIIResearched := true ; 3 :
19495: LD_ADDR_EXP 10
19499: PUSH
19500: LD_INT 1
19502: ST_TO_ADDR
19503: GO 19525
19505: LD_INT 3
19507: DOUBLE
19508: EQUAL
19509: IFTRUE 19513
19511: GO 19524
19513: POP
// artifactIIIResearched := true ; end ;
19514: LD_ADDR_EXP 11
19518: PUSH
19519: LD_INT 1
19521: ST_TO_ADDR
19522: GO 19525
19524: POP
// end ; end_of_file
19525: PPOPN 3
19527: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
19528: GO 19530
19530: DISABLE
// begin ru_radar := 98 ;
19531: LD_ADDR_EXP 67
19535: PUSH
19536: LD_INT 98
19538: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
19539: LD_ADDR_EXP 68
19543: PUSH
19544: LD_INT 89
19546: ST_TO_ADDR
// us_hack := 99 ;
19547: LD_ADDR_EXP 69
19551: PUSH
19552: LD_INT 99
19554: ST_TO_ADDR
// us_artillery := 97 ;
19555: LD_ADDR_EXP 70
19559: PUSH
19560: LD_INT 97
19562: ST_TO_ADDR
// ar_bio_bomb := 91 ;
19563: LD_ADDR_EXP 71
19567: PUSH
19568: LD_INT 91
19570: ST_TO_ADDR
// end ; end_of_file
19571: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
19572: LD_INT 0
19574: PPUSH
19575: PPUSH
// skirmish := false ;
19576: LD_ADDR_EXP 72
19580: PUSH
19581: LD_INT 0
19583: ST_TO_ADDR
// debug_mc := false ;
19584: LD_ADDR_EXP 73
19588: PUSH
19589: LD_INT 0
19591: ST_TO_ADDR
// mc_bases := [ ] ;
19592: LD_ADDR_EXP 74
19596: PUSH
19597: EMPTY
19598: ST_TO_ADDR
// mc_sides := [ ] ;
19599: LD_ADDR_EXP 100
19603: PUSH
19604: EMPTY
19605: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
19606: LD_ADDR_EXP 75
19610: PUSH
19611: EMPTY
19612: ST_TO_ADDR
// mc_building_repairs := [ ] ;
19613: LD_ADDR_EXP 76
19617: PUSH
19618: EMPTY
19619: ST_TO_ADDR
// mc_need_heal := [ ] ;
19620: LD_ADDR_EXP 77
19624: PUSH
19625: EMPTY
19626: ST_TO_ADDR
// mc_healers := [ ] ;
19627: LD_ADDR_EXP 78
19631: PUSH
19632: EMPTY
19633: ST_TO_ADDR
// mc_build_list := [ ] ;
19634: LD_ADDR_EXP 79
19638: PUSH
19639: EMPTY
19640: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
19641: LD_ADDR_EXP 106
19645: PUSH
19646: EMPTY
19647: ST_TO_ADDR
// mc_builders := [ ] ;
19648: LD_ADDR_EXP 80
19652: PUSH
19653: EMPTY
19654: ST_TO_ADDR
// mc_construct_list := [ ] ;
19655: LD_ADDR_EXP 81
19659: PUSH
19660: EMPTY
19661: ST_TO_ADDR
// mc_turret_list := [ ] ;
19662: LD_ADDR_EXP 82
19666: PUSH
19667: EMPTY
19668: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
19669: LD_ADDR_EXP 83
19673: PUSH
19674: EMPTY
19675: ST_TO_ADDR
// mc_miners := [ ] ;
19676: LD_ADDR_EXP 88
19680: PUSH
19681: EMPTY
19682: ST_TO_ADDR
// mc_mines := [ ] ;
19683: LD_ADDR_EXP 87
19687: PUSH
19688: EMPTY
19689: ST_TO_ADDR
// mc_minefields := [ ] ;
19690: LD_ADDR_EXP 89
19694: PUSH
19695: EMPTY
19696: ST_TO_ADDR
// mc_crates := [ ] ;
19697: LD_ADDR_EXP 90
19701: PUSH
19702: EMPTY
19703: ST_TO_ADDR
// mc_crates_collector := [ ] ;
19704: LD_ADDR_EXP 91
19708: PUSH
19709: EMPTY
19710: ST_TO_ADDR
// mc_crates_area := [ ] ;
19711: LD_ADDR_EXP 92
19715: PUSH
19716: EMPTY
19717: ST_TO_ADDR
// mc_vehicles := [ ] ;
19718: LD_ADDR_EXP 93
19722: PUSH
19723: EMPTY
19724: ST_TO_ADDR
// mc_attack := [ ] ;
19725: LD_ADDR_EXP 94
19729: PUSH
19730: EMPTY
19731: ST_TO_ADDR
// mc_produce := [ ] ;
19732: LD_ADDR_EXP 95
19736: PUSH
19737: EMPTY
19738: ST_TO_ADDR
// mc_defender := [ ] ;
19739: LD_ADDR_EXP 96
19743: PUSH
19744: EMPTY
19745: ST_TO_ADDR
// mc_parking := [ ] ;
19746: LD_ADDR_EXP 98
19750: PUSH
19751: EMPTY
19752: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
19753: LD_ADDR_EXP 84
19757: PUSH
19758: EMPTY
19759: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
19760: LD_ADDR_EXP 86
19764: PUSH
19765: EMPTY
19766: ST_TO_ADDR
// mc_scan := [ ] ;
19767: LD_ADDR_EXP 97
19771: PUSH
19772: EMPTY
19773: ST_TO_ADDR
// mc_scan_area := [ ] ;
19774: LD_ADDR_EXP 99
19778: PUSH
19779: EMPTY
19780: ST_TO_ADDR
// mc_tech := [ ] ;
19781: LD_ADDR_EXP 101
19785: PUSH
19786: EMPTY
19787: ST_TO_ADDR
// mc_class := [ ] ;
19788: LD_ADDR_EXP 115
19792: PUSH
19793: EMPTY
19794: ST_TO_ADDR
// mc_class_case_use := [ ] ;
19795: LD_ADDR_EXP 116
19799: PUSH
19800: EMPTY
19801: ST_TO_ADDR
// end ;
19802: LD_VAR 0 1
19806: RET
// export function MC_Kill ( base ) ; begin
19807: LD_INT 0
19809: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
19810: LD_ADDR_EXP 74
19814: PUSH
19815: LD_EXP 74
19819: PPUSH
19820: LD_VAR 0 1
19824: PPUSH
19825: EMPTY
19826: PPUSH
19827: CALL_OW 1
19831: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19832: LD_ADDR_EXP 75
19836: PUSH
19837: LD_EXP 75
19841: PPUSH
19842: LD_VAR 0 1
19846: PPUSH
19847: EMPTY
19848: PPUSH
19849: CALL_OW 1
19853: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19854: LD_ADDR_EXP 76
19858: PUSH
19859: LD_EXP 76
19863: PPUSH
19864: LD_VAR 0 1
19868: PPUSH
19869: EMPTY
19870: PPUSH
19871: CALL_OW 1
19875: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19876: LD_ADDR_EXP 77
19880: PUSH
19881: LD_EXP 77
19885: PPUSH
19886: LD_VAR 0 1
19890: PPUSH
19891: EMPTY
19892: PPUSH
19893: CALL_OW 1
19897: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19898: LD_ADDR_EXP 78
19902: PUSH
19903: LD_EXP 78
19907: PPUSH
19908: LD_VAR 0 1
19912: PPUSH
19913: EMPTY
19914: PPUSH
19915: CALL_OW 1
19919: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19920: LD_ADDR_EXP 79
19924: PUSH
19925: LD_EXP 79
19929: PPUSH
19930: LD_VAR 0 1
19934: PPUSH
19935: EMPTY
19936: PPUSH
19937: CALL_OW 1
19941: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19942: LD_ADDR_EXP 80
19946: PUSH
19947: LD_EXP 80
19951: PPUSH
19952: LD_VAR 0 1
19956: PPUSH
19957: EMPTY
19958: PPUSH
19959: CALL_OW 1
19963: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19964: LD_ADDR_EXP 81
19968: PUSH
19969: LD_EXP 81
19973: PPUSH
19974: LD_VAR 0 1
19978: PPUSH
19979: EMPTY
19980: PPUSH
19981: CALL_OW 1
19985: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19986: LD_ADDR_EXP 82
19990: PUSH
19991: LD_EXP 82
19995: PPUSH
19996: LD_VAR 0 1
20000: PPUSH
20001: EMPTY
20002: PPUSH
20003: CALL_OW 1
20007: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20008: LD_ADDR_EXP 83
20012: PUSH
20013: LD_EXP 83
20017: PPUSH
20018: LD_VAR 0 1
20022: PPUSH
20023: EMPTY
20024: PPUSH
20025: CALL_OW 1
20029: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20030: LD_ADDR_EXP 84
20034: PUSH
20035: LD_EXP 84
20039: PPUSH
20040: LD_VAR 0 1
20044: PPUSH
20045: EMPTY
20046: PPUSH
20047: CALL_OW 1
20051: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20052: LD_ADDR_EXP 85
20056: PUSH
20057: LD_EXP 85
20061: PPUSH
20062: LD_VAR 0 1
20066: PPUSH
20067: LD_INT 0
20069: PPUSH
20070: CALL_OW 1
20074: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20075: LD_ADDR_EXP 86
20079: PUSH
20080: LD_EXP 86
20084: PPUSH
20085: LD_VAR 0 1
20089: PPUSH
20090: EMPTY
20091: PPUSH
20092: CALL_OW 1
20096: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20097: LD_ADDR_EXP 87
20101: PUSH
20102: LD_EXP 87
20106: PPUSH
20107: LD_VAR 0 1
20111: PPUSH
20112: EMPTY
20113: PPUSH
20114: CALL_OW 1
20118: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20119: LD_ADDR_EXP 88
20123: PUSH
20124: LD_EXP 88
20128: PPUSH
20129: LD_VAR 0 1
20133: PPUSH
20134: EMPTY
20135: PPUSH
20136: CALL_OW 1
20140: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20141: LD_ADDR_EXP 89
20145: PUSH
20146: LD_EXP 89
20150: PPUSH
20151: LD_VAR 0 1
20155: PPUSH
20156: EMPTY
20157: PPUSH
20158: CALL_OW 1
20162: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20163: LD_ADDR_EXP 90
20167: PUSH
20168: LD_EXP 90
20172: PPUSH
20173: LD_VAR 0 1
20177: PPUSH
20178: EMPTY
20179: PPUSH
20180: CALL_OW 1
20184: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20185: LD_ADDR_EXP 91
20189: PUSH
20190: LD_EXP 91
20194: PPUSH
20195: LD_VAR 0 1
20199: PPUSH
20200: EMPTY
20201: PPUSH
20202: CALL_OW 1
20206: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20207: LD_ADDR_EXP 92
20211: PUSH
20212: LD_EXP 92
20216: PPUSH
20217: LD_VAR 0 1
20221: PPUSH
20222: EMPTY
20223: PPUSH
20224: CALL_OW 1
20228: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20229: LD_ADDR_EXP 93
20233: PUSH
20234: LD_EXP 93
20238: PPUSH
20239: LD_VAR 0 1
20243: PPUSH
20244: EMPTY
20245: PPUSH
20246: CALL_OW 1
20250: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20251: LD_ADDR_EXP 94
20255: PUSH
20256: LD_EXP 94
20260: PPUSH
20261: LD_VAR 0 1
20265: PPUSH
20266: EMPTY
20267: PPUSH
20268: CALL_OW 1
20272: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20273: LD_ADDR_EXP 95
20277: PUSH
20278: LD_EXP 95
20282: PPUSH
20283: LD_VAR 0 1
20287: PPUSH
20288: EMPTY
20289: PPUSH
20290: CALL_OW 1
20294: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20295: LD_ADDR_EXP 96
20299: PUSH
20300: LD_EXP 96
20304: PPUSH
20305: LD_VAR 0 1
20309: PPUSH
20310: EMPTY
20311: PPUSH
20312: CALL_OW 1
20316: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20317: LD_ADDR_EXP 97
20321: PUSH
20322: LD_EXP 97
20326: PPUSH
20327: LD_VAR 0 1
20331: PPUSH
20332: EMPTY
20333: PPUSH
20334: CALL_OW 1
20338: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20339: LD_ADDR_EXP 98
20343: PUSH
20344: LD_EXP 98
20348: PPUSH
20349: LD_VAR 0 1
20353: PPUSH
20354: EMPTY
20355: PPUSH
20356: CALL_OW 1
20360: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20361: LD_ADDR_EXP 99
20365: PUSH
20366: LD_EXP 99
20370: PPUSH
20371: LD_VAR 0 1
20375: PPUSH
20376: EMPTY
20377: PPUSH
20378: CALL_OW 1
20382: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20383: LD_ADDR_EXP 101
20387: PUSH
20388: LD_EXP 101
20392: PPUSH
20393: LD_VAR 0 1
20397: PPUSH
20398: EMPTY
20399: PPUSH
20400: CALL_OW 1
20404: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20405: LD_ADDR_EXP 103
20409: PUSH
20410: LD_EXP 103
20414: PPUSH
20415: LD_VAR 0 1
20419: PPUSH
20420: EMPTY
20421: PPUSH
20422: CALL_OW 1
20426: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20427: LD_ADDR_EXP 104
20431: PUSH
20432: LD_EXP 104
20436: PPUSH
20437: LD_VAR 0 1
20441: PPUSH
20442: EMPTY
20443: PPUSH
20444: CALL_OW 1
20448: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20449: LD_ADDR_EXP 105
20453: PUSH
20454: LD_EXP 105
20458: PPUSH
20459: LD_VAR 0 1
20463: PPUSH
20464: EMPTY
20465: PPUSH
20466: CALL_OW 1
20470: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20471: LD_ADDR_EXP 106
20475: PUSH
20476: LD_EXP 106
20480: PPUSH
20481: LD_VAR 0 1
20485: PPUSH
20486: EMPTY
20487: PPUSH
20488: CALL_OW 1
20492: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20493: LD_ADDR_EXP 107
20497: PUSH
20498: LD_EXP 107
20502: PPUSH
20503: LD_VAR 0 1
20507: PPUSH
20508: EMPTY
20509: PPUSH
20510: CALL_OW 1
20514: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20515: LD_ADDR_EXP 108
20519: PUSH
20520: LD_EXP 108
20524: PPUSH
20525: LD_VAR 0 1
20529: PPUSH
20530: EMPTY
20531: PPUSH
20532: CALL_OW 1
20536: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20537: LD_ADDR_EXP 109
20541: PUSH
20542: LD_EXP 109
20546: PPUSH
20547: LD_VAR 0 1
20551: PPUSH
20552: EMPTY
20553: PPUSH
20554: CALL_OW 1
20558: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20559: LD_ADDR_EXP 110
20563: PUSH
20564: LD_EXP 110
20568: PPUSH
20569: LD_VAR 0 1
20573: PPUSH
20574: EMPTY
20575: PPUSH
20576: CALL_OW 1
20580: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20581: LD_ADDR_EXP 111
20585: PUSH
20586: LD_EXP 111
20590: PPUSH
20591: LD_VAR 0 1
20595: PPUSH
20596: EMPTY
20597: PPUSH
20598: CALL_OW 1
20602: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20603: LD_ADDR_EXP 112
20607: PUSH
20608: LD_EXP 112
20612: PPUSH
20613: LD_VAR 0 1
20617: PPUSH
20618: EMPTY
20619: PPUSH
20620: CALL_OW 1
20624: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20625: LD_ADDR_EXP 113
20629: PUSH
20630: LD_EXP 113
20634: PPUSH
20635: LD_VAR 0 1
20639: PPUSH
20640: EMPTY
20641: PPUSH
20642: CALL_OW 1
20646: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20647: LD_ADDR_EXP 114
20651: PUSH
20652: LD_EXP 114
20656: PPUSH
20657: LD_VAR 0 1
20661: PPUSH
20662: EMPTY
20663: PPUSH
20664: CALL_OW 1
20668: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20669: LD_ADDR_EXP 115
20673: PUSH
20674: LD_EXP 115
20678: PPUSH
20679: LD_VAR 0 1
20683: PPUSH
20684: EMPTY
20685: PPUSH
20686: CALL_OW 1
20690: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20691: LD_ADDR_EXP 116
20695: PUSH
20696: LD_EXP 116
20700: PPUSH
20701: LD_VAR 0 1
20705: PPUSH
20706: LD_INT 0
20708: PPUSH
20709: CALL_OW 1
20713: ST_TO_ADDR
// end ;
20714: LD_VAR 0 2
20718: RET
// export function MC_Add ( side , units ) ; var base ; begin
20719: LD_INT 0
20721: PPUSH
20722: PPUSH
// base := mc_bases + 1 ;
20723: LD_ADDR_VAR 0 4
20727: PUSH
20728: LD_EXP 74
20732: PUSH
20733: LD_INT 1
20735: PLUS
20736: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
20737: LD_ADDR_EXP 100
20741: PUSH
20742: LD_EXP 100
20746: PPUSH
20747: LD_VAR 0 4
20751: PPUSH
20752: LD_VAR 0 1
20756: PPUSH
20757: CALL_OW 1
20761: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
20762: LD_ADDR_EXP 74
20766: PUSH
20767: LD_EXP 74
20771: PPUSH
20772: LD_VAR 0 4
20776: PPUSH
20777: LD_VAR 0 2
20781: PPUSH
20782: CALL_OW 1
20786: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20787: LD_ADDR_EXP 75
20791: PUSH
20792: LD_EXP 75
20796: PPUSH
20797: LD_VAR 0 4
20801: PPUSH
20802: EMPTY
20803: PPUSH
20804: CALL_OW 1
20808: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20809: LD_ADDR_EXP 76
20813: PUSH
20814: LD_EXP 76
20818: PPUSH
20819: LD_VAR 0 4
20823: PPUSH
20824: EMPTY
20825: PPUSH
20826: CALL_OW 1
20830: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20831: LD_ADDR_EXP 77
20835: PUSH
20836: LD_EXP 77
20840: PPUSH
20841: LD_VAR 0 4
20845: PPUSH
20846: EMPTY
20847: PPUSH
20848: CALL_OW 1
20852: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20853: LD_ADDR_EXP 78
20857: PUSH
20858: LD_EXP 78
20862: PPUSH
20863: LD_VAR 0 4
20867: PPUSH
20868: EMPTY
20869: PPUSH
20870: CALL_OW 1
20874: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20875: LD_ADDR_EXP 79
20879: PUSH
20880: LD_EXP 79
20884: PPUSH
20885: LD_VAR 0 4
20889: PPUSH
20890: EMPTY
20891: PPUSH
20892: CALL_OW 1
20896: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20897: LD_ADDR_EXP 80
20901: PUSH
20902: LD_EXP 80
20906: PPUSH
20907: LD_VAR 0 4
20911: PPUSH
20912: EMPTY
20913: PPUSH
20914: CALL_OW 1
20918: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20919: LD_ADDR_EXP 81
20923: PUSH
20924: LD_EXP 81
20928: PPUSH
20929: LD_VAR 0 4
20933: PPUSH
20934: EMPTY
20935: PPUSH
20936: CALL_OW 1
20940: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20941: LD_ADDR_EXP 82
20945: PUSH
20946: LD_EXP 82
20950: PPUSH
20951: LD_VAR 0 4
20955: PPUSH
20956: EMPTY
20957: PPUSH
20958: CALL_OW 1
20962: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20963: LD_ADDR_EXP 83
20967: PUSH
20968: LD_EXP 83
20972: PPUSH
20973: LD_VAR 0 4
20977: PPUSH
20978: EMPTY
20979: PPUSH
20980: CALL_OW 1
20984: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20985: LD_ADDR_EXP 84
20989: PUSH
20990: LD_EXP 84
20994: PPUSH
20995: LD_VAR 0 4
20999: PPUSH
21000: EMPTY
21001: PPUSH
21002: CALL_OW 1
21006: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21007: LD_ADDR_EXP 85
21011: PUSH
21012: LD_EXP 85
21016: PPUSH
21017: LD_VAR 0 4
21021: PPUSH
21022: LD_INT 0
21024: PPUSH
21025: CALL_OW 1
21029: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21030: LD_ADDR_EXP 86
21034: PUSH
21035: LD_EXP 86
21039: PPUSH
21040: LD_VAR 0 4
21044: PPUSH
21045: EMPTY
21046: PPUSH
21047: CALL_OW 1
21051: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21052: LD_ADDR_EXP 87
21056: PUSH
21057: LD_EXP 87
21061: PPUSH
21062: LD_VAR 0 4
21066: PPUSH
21067: EMPTY
21068: PPUSH
21069: CALL_OW 1
21073: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21074: LD_ADDR_EXP 88
21078: PUSH
21079: LD_EXP 88
21083: PPUSH
21084: LD_VAR 0 4
21088: PPUSH
21089: EMPTY
21090: PPUSH
21091: CALL_OW 1
21095: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21096: LD_ADDR_EXP 89
21100: PUSH
21101: LD_EXP 89
21105: PPUSH
21106: LD_VAR 0 4
21110: PPUSH
21111: EMPTY
21112: PPUSH
21113: CALL_OW 1
21117: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21118: LD_ADDR_EXP 90
21122: PUSH
21123: LD_EXP 90
21127: PPUSH
21128: LD_VAR 0 4
21132: PPUSH
21133: EMPTY
21134: PPUSH
21135: CALL_OW 1
21139: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21140: LD_ADDR_EXP 91
21144: PUSH
21145: LD_EXP 91
21149: PPUSH
21150: LD_VAR 0 4
21154: PPUSH
21155: EMPTY
21156: PPUSH
21157: CALL_OW 1
21161: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21162: LD_ADDR_EXP 92
21166: PUSH
21167: LD_EXP 92
21171: PPUSH
21172: LD_VAR 0 4
21176: PPUSH
21177: EMPTY
21178: PPUSH
21179: CALL_OW 1
21183: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21184: LD_ADDR_EXP 93
21188: PUSH
21189: LD_EXP 93
21193: PPUSH
21194: LD_VAR 0 4
21198: PPUSH
21199: EMPTY
21200: PPUSH
21201: CALL_OW 1
21205: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21206: LD_ADDR_EXP 94
21210: PUSH
21211: LD_EXP 94
21215: PPUSH
21216: LD_VAR 0 4
21220: PPUSH
21221: EMPTY
21222: PPUSH
21223: CALL_OW 1
21227: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21228: LD_ADDR_EXP 95
21232: PUSH
21233: LD_EXP 95
21237: PPUSH
21238: LD_VAR 0 4
21242: PPUSH
21243: EMPTY
21244: PPUSH
21245: CALL_OW 1
21249: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21250: LD_ADDR_EXP 96
21254: PUSH
21255: LD_EXP 96
21259: PPUSH
21260: LD_VAR 0 4
21264: PPUSH
21265: EMPTY
21266: PPUSH
21267: CALL_OW 1
21271: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21272: LD_ADDR_EXP 97
21276: PUSH
21277: LD_EXP 97
21281: PPUSH
21282: LD_VAR 0 4
21286: PPUSH
21287: EMPTY
21288: PPUSH
21289: CALL_OW 1
21293: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21294: LD_ADDR_EXP 98
21298: PUSH
21299: LD_EXP 98
21303: PPUSH
21304: LD_VAR 0 4
21308: PPUSH
21309: EMPTY
21310: PPUSH
21311: CALL_OW 1
21315: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21316: LD_ADDR_EXP 99
21320: PUSH
21321: LD_EXP 99
21325: PPUSH
21326: LD_VAR 0 4
21330: PPUSH
21331: EMPTY
21332: PPUSH
21333: CALL_OW 1
21337: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21338: LD_ADDR_EXP 101
21342: PUSH
21343: LD_EXP 101
21347: PPUSH
21348: LD_VAR 0 4
21352: PPUSH
21353: EMPTY
21354: PPUSH
21355: CALL_OW 1
21359: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21360: LD_ADDR_EXP 103
21364: PUSH
21365: LD_EXP 103
21369: PPUSH
21370: LD_VAR 0 4
21374: PPUSH
21375: EMPTY
21376: PPUSH
21377: CALL_OW 1
21381: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21382: LD_ADDR_EXP 104
21386: PUSH
21387: LD_EXP 104
21391: PPUSH
21392: LD_VAR 0 4
21396: PPUSH
21397: EMPTY
21398: PPUSH
21399: CALL_OW 1
21403: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21404: LD_ADDR_EXP 105
21408: PUSH
21409: LD_EXP 105
21413: PPUSH
21414: LD_VAR 0 4
21418: PPUSH
21419: EMPTY
21420: PPUSH
21421: CALL_OW 1
21425: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21426: LD_ADDR_EXP 106
21430: PUSH
21431: LD_EXP 106
21435: PPUSH
21436: LD_VAR 0 4
21440: PPUSH
21441: EMPTY
21442: PPUSH
21443: CALL_OW 1
21447: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21448: LD_ADDR_EXP 107
21452: PUSH
21453: LD_EXP 107
21457: PPUSH
21458: LD_VAR 0 4
21462: PPUSH
21463: EMPTY
21464: PPUSH
21465: CALL_OW 1
21469: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21470: LD_ADDR_EXP 108
21474: PUSH
21475: LD_EXP 108
21479: PPUSH
21480: LD_VAR 0 4
21484: PPUSH
21485: EMPTY
21486: PPUSH
21487: CALL_OW 1
21491: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21492: LD_ADDR_EXP 109
21496: PUSH
21497: LD_EXP 109
21501: PPUSH
21502: LD_VAR 0 4
21506: PPUSH
21507: EMPTY
21508: PPUSH
21509: CALL_OW 1
21513: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21514: LD_ADDR_EXP 110
21518: PUSH
21519: LD_EXP 110
21523: PPUSH
21524: LD_VAR 0 4
21528: PPUSH
21529: EMPTY
21530: PPUSH
21531: CALL_OW 1
21535: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21536: LD_ADDR_EXP 111
21540: PUSH
21541: LD_EXP 111
21545: PPUSH
21546: LD_VAR 0 4
21550: PPUSH
21551: EMPTY
21552: PPUSH
21553: CALL_OW 1
21557: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21558: LD_ADDR_EXP 112
21562: PUSH
21563: LD_EXP 112
21567: PPUSH
21568: LD_VAR 0 4
21572: PPUSH
21573: EMPTY
21574: PPUSH
21575: CALL_OW 1
21579: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21580: LD_ADDR_EXP 113
21584: PUSH
21585: LD_EXP 113
21589: PPUSH
21590: LD_VAR 0 4
21594: PPUSH
21595: EMPTY
21596: PPUSH
21597: CALL_OW 1
21601: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21602: LD_ADDR_EXP 114
21606: PUSH
21607: LD_EXP 114
21611: PPUSH
21612: LD_VAR 0 4
21616: PPUSH
21617: EMPTY
21618: PPUSH
21619: CALL_OW 1
21623: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21624: LD_ADDR_EXP 115
21628: PUSH
21629: LD_EXP 115
21633: PPUSH
21634: LD_VAR 0 4
21638: PPUSH
21639: EMPTY
21640: PPUSH
21641: CALL_OW 1
21645: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21646: LD_ADDR_EXP 116
21650: PUSH
21651: LD_EXP 116
21655: PPUSH
21656: LD_VAR 0 4
21660: PPUSH
21661: LD_INT 0
21663: PPUSH
21664: CALL_OW 1
21668: ST_TO_ADDR
// result := base ;
21669: LD_ADDR_VAR 0 3
21673: PUSH
21674: LD_VAR 0 4
21678: ST_TO_ADDR
// end ;
21679: LD_VAR 0 3
21683: RET
// export function MC_Start ( ) ; var i ; begin
21684: LD_INT 0
21686: PPUSH
21687: PPUSH
// for i = 1 to mc_bases do
21688: LD_ADDR_VAR 0 2
21692: PUSH
21693: DOUBLE
21694: LD_INT 1
21696: DEC
21697: ST_TO_ADDR
21698: LD_EXP 74
21702: PUSH
21703: FOR_TO
21704: IFFALSE 22781
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
21706: LD_ADDR_EXP 74
21710: PUSH
21711: LD_EXP 74
21715: PPUSH
21716: LD_VAR 0 2
21720: PPUSH
21721: LD_EXP 74
21725: PUSH
21726: LD_VAR 0 2
21730: ARRAY
21731: PUSH
21732: LD_INT 0
21734: DIFF
21735: PPUSH
21736: CALL_OW 1
21740: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
21741: LD_ADDR_EXP 75
21745: PUSH
21746: LD_EXP 75
21750: PPUSH
21751: LD_VAR 0 2
21755: PPUSH
21756: EMPTY
21757: PPUSH
21758: CALL_OW 1
21762: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
21763: LD_ADDR_EXP 76
21767: PUSH
21768: LD_EXP 76
21772: PPUSH
21773: LD_VAR 0 2
21777: PPUSH
21778: EMPTY
21779: PPUSH
21780: CALL_OW 1
21784: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
21785: LD_ADDR_EXP 77
21789: PUSH
21790: LD_EXP 77
21794: PPUSH
21795: LD_VAR 0 2
21799: PPUSH
21800: EMPTY
21801: PPUSH
21802: CALL_OW 1
21806: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
21807: LD_ADDR_EXP 78
21811: PUSH
21812: LD_EXP 78
21816: PPUSH
21817: LD_VAR 0 2
21821: PPUSH
21822: EMPTY
21823: PUSH
21824: EMPTY
21825: PUSH
21826: EMPTY
21827: LIST
21828: LIST
21829: PPUSH
21830: CALL_OW 1
21834: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
21835: LD_ADDR_EXP 79
21839: PUSH
21840: LD_EXP 79
21844: PPUSH
21845: LD_VAR 0 2
21849: PPUSH
21850: EMPTY
21851: PPUSH
21852: CALL_OW 1
21856: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
21857: LD_ADDR_EXP 106
21861: PUSH
21862: LD_EXP 106
21866: PPUSH
21867: LD_VAR 0 2
21871: PPUSH
21872: EMPTY
21873: PPUSH
21874: CALL_OW 1
21878: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
21879: LD_ADDR_EXP 80
21883: PUSH
21884: LD_EXP 80
21888: PPUSH
21889: LD_VAR 0 2
21893: PPUSH
21894: EMPTY
21895: PPUSH
21896: CALL_OW 1
21900: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
21901: LD_ADDR_EXP 81
21905: PUSH
21906: LD_EXP 81
21910: PPUSH
21911: LD_VAR 0 2
21915: PPUSH
21916: EMPTY
21917: PPUSH
21918: CALL_OW 1
21922: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
21923: LD_ADDR_EXP 82
21927: PUSH
21928: LD_EXP 82
21932: PPUSH
21933: LD_VAR 0 2
21937: PPUSH
21938: LD_EXP 74
21942: PUSH
21943: LD_VAR 0 2
21947: ARRAY
21948: PPUSH
21949: LD_INT 2
21951: PUSH
21952: LD_INT 30
21954: PUSH
21955: LD_INT 32
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: PUSH
21962: LD_INT 30
21964: PUSH
21965: LD_INT 33
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: LIST
21976: PPUSH
21977: CALL_OW 72
21981: PPUSH
21982: CALL_OW 1
21986: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
21987: LD_ADDR_EXP 83
21991: PUSH
21992: LD_EXP 83
21996: PPUSH
21997: LD_VAR 0 2
22001: PPUSH
22002: LD_EXP 74
22006: PUSH
22007: LD_VAR 0 2
22011: ARRAY
22012: PPUSH
22013: LD_INT 2
22015: PUSH
22016: LD_INT 30
22018: PUSH
22019: LD_INT 32
22021: PUSH
22022: EMPTY
22023: LIST
22024: LIST
22025: PUSH
22026: LD_INT 30
22028: PUSH
22029: LD_INT 31
22031: PUSH
22032: EMPTY
22033: LIST
22034: LIST
22035: PUSH
22036: EMPTY
22037: LIST
22038: LIST
22039: LIST
22040: PUSH
22041: LD_INT 58
22043: PUSH
22044: EMPTY
22045: LIST
22046: PUSH
22047: EMPTY
22048: LIST
22049: LIST
22050: PPUSH
22051: CALL_OW 72
22055: PPUSH
22056: CALL_OW 1
22060: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22061: LD_ADDR_EXP 84
22065: PUSH
22066: LD_EXP 84
22070: PPUSH
22071: LD_VAR 0 2
22075: PPUSH
22076: EMPTY
22077: PPUSH
22078: CALL_OW 1
22082: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22083: LD_ADDR_EXP 88
22087: PUSH
22088: LD_EXP 88
22092: PPUSH
22093: LD_VAR 0 2
22097: PPUSH
22098: EMPTY
22099: PPUSH
22100: CALL_OW 1
22104: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
22105: LD_ADDR_EXP 87
22109: PUSH
22110: LD_EXP 87
22114: PPUSH
22115: LD_VAR 0 2
22119: PPUSH
22120: EMPTY
22121: PPUSH
22122: CALL_OW 1
22126: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
22127: LD_ADDR_EXP 89
22131: PUSH
22132: LD_EXP 89
22136: PPUSH
22137: LD_VAR 0 2
22141: PPUSH
22142: EMPTY
22143: PPUSH
22144: CALL_OW 1
22148: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
22149: LD_ADDR_EXP 90
22153: PUSH
22154: LD_EXP 90
22158: PPUSH
22159: LD_VAR 0 2
22163: PPUSH
22164: EMPTY
22165: PPUSH
22166: CALL_OW 1
22170: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
22171: LD_ADDR_EXP 91
22175: PUSH
22176: LD_EXP 91
22180: PPUSH
22181: LD_VAR 0 2
22185: PPUSH
22186: EMPTY
22187: PPUSH
22188: CALL_OW 1
22192: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
22193: LD_ADDR_EXP 92
22197: PUSH
22198: LD_EXP 92
22202: PPUSH
22203: LD_VAR 0 2
22207: PPUSH
22208: EMPTY
22209: PPUSH
22210: CALL_OW 1
22214: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
22215: LD_ADDR_EXP 93
22219: PUSH
22220: LD_EXP 93
22224: PPUSH
22225: LD_VAR 0 2
22229: PPUSH
22230: EMPTY
22231: PPUSH
22232: CALL_OW 1
22236: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
22237: LD_ADDR_EXP 94
22241: PUSH
22242: LD_EXP 94
22246: PPUSH
22247: LD_VAR 0 2
22251: PPUSH
22252: EMPTY
22253: PPUSH
22254: CALL_OW 1
22258: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
22259: LD_ADDR_EXP 95
22263: PUSH
22264: LD_EXP 95
22268: PPUSH
22269: LD_VAR 0 2
22273: PPUSH
22274: EMPTY
22275: PPUSH
22276: CALL_OW 1
22280: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
22281: LD_ADDR_EXP 96
22285: PUSH
22286: LD_EXP 96
22290: PPUSH
22291: LD_VAR 0 2
22295: PPUSH
22296: EMPTY
22297: PPUSH
22298: CALL_OW 1
22302: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
22303: LD_ADDR_EXP 85
22307: PUSH
22308: LD_EXP 85
22312: PPUSH
22313: LD_VAR 0 2
22317: PPUSH
22318: LD_INT 0
22320: PPUSH
22321: CALL_OW 1
22325: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
22326: LD_ADDR_EXP 98
22330: PUSH
22331: LD_EXP 98
22335: PPUSH
22336: LD_VAR 0 2
22340: PPUSH
22341: LD_INT 0
22343: PPUSH
22344: CALL_OW 1
22348: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
22349: LD_ADDR_EXP 86
22353: PUSH
22354: LD_EXP 86
22358: PPUSH
22359: LD_VAR 0 2
22363: PPUSH
22364: EMPTY
22365: PPUSH
22366: CALL_OW 1
22370: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
22371: LD_ADDR_EXP 97
22375: PUSH
22376: LD_EXP 97
22380: PPUSH
22381: LD_VAR 0 2
22385: PPUSH
22386: LD_INT 0
22388: PPUSH
22389: CALL_OW 1
22393: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
22394: LD_ADDR_EXP 99
22398: PUSH
22399: LD_EXP 99
22403: PPUSH
22404: LD_VAR 0 2
22408: PPUSH
22409: EMPTY
22410: PPUSH
22411: CALL_OW 1
22415: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
22416: LD_ADDR_EXP 102
22420: PUSH
22421: LD_EXP 102
22425: PPUSH
22426: LD_VAR 0 2
22430: PPUSH
22431: LD_INT 0
22433: PPUSH
22434: CALL_OW 1
22438: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
22439: LD_ADDR_EXP 103
22443: PUSH
22444: LD_EXP 103
22448: PPUSH
22449: LD_VAR 0 2
22453: PPUSH
22454: EMPTY
22455: PPUSH
22456: CALL_OW 1
22460: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
22461: LD_ADDR_EXP 104
22465: PUSH
22466: LD_EXP 104
22470: PPUSH
22471: LD_VAR 0 2
22475: PPUSH
22476: EMPTY
22477: PPUSH
22478: CALL_OW 1
22482: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
22483: LD_ADDR_EXP 105
22487: PUSH
22488: LD_EXP 105
22492: PPUSH
22493: LD_VAR 0 2
22497: PPUSH
22498: EMPTY
22499: PPUSH
22500: CALL_OW 1
22504: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
22505: LD_ADDR_EXP 107
22509: PUSH
22510: LD_EXP 107
22514: PPUSH
22515: LD_VAR 0 2
22519: PPUSH
22520: LD_EXP 74
22524: PUSH
22525: LD_VAR 0 2
22529: ARRAY
22530: PPUSH
22531: LD_INT 2
22533: PUSH
22534: LD_INT 30
22536: PUSH
22537: LD_INT 6
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: PUSH
22544: LD_INT 30
22546: PUSH
22547: LD_INT 7
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: PUSH
22554: LD_INT 30
22556: PUSH
22557: LD_INT 8
22559: PUSH
22560: EMPTY
22561: LIST
22562: LIST
22563: PUSH
22564: EMPTY
22565: LIST
22566: LIST
22567: LIST
22568: LIST
22569: PPUSH
22570: CALL_OW 72
22574: PPUSH
22575: CALL_OW 1
22579: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
22580: LD_ADDR_EXP 108
22584: PUSH
22585: LD_EXP 108
22589: PPUSH
22590: LD_VAR 0 2
22594: PPUSH
22595: EMPTY
22596: PPUSH
22597: CALL_OW 1
22601: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
22602: LD_ADDR_EXP 109
22606: PUSH
22607: LD_EXP 109
22611: PPUSH
22612: LD_VAR 0 2
22616: PPUSH
22617: EMPTY
22618: PPUSH
22619: CALL_OW 1
22623: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
22624: LD_ADDR_EXP 110
22628: PUSH
22629: LD_EXP 110
22633: PPUSH
22634: LD_VAR 0 2
22638: PPUSH
22639: EMPTY
22640: PPUSH
22641: CALL_OW 1
22645: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
22646: LD_ADDR_EXP 111
22650: PUSH
22651: LD_EXP 111
22655: PPUSH
22656: LD_VAR 0 2
22660: PPUSH
22661: EMPTY
22662: PPUSH
22663: CALL_OW 1
22667: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
22668: LD_ADDR_EXP 112
22672: PUSH
22673: LD_EXP 112
22677: PPUSH
22678: LD_VAR 0 2
22682: PPUSH
22683: EMPTY
22684: PPUSH
22685: CALL_OW 1
22689: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
22690: LD_ADDR_EXP 113
22694: PUSH
22695: LD_EXP 113
22699: PPUSH
22700: LD_VAR 0 2
22704: PPUSH
22705: EMPTY
22706: PPUSH
22707: CALL_OW 1
22711: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
22712: LD_ADDR_EXP 114
22716: PUSH
22717: LD_EXP 114
22721: PPUSH
22722: LD_VAR 0 2
22726: PPUSH
22727: EMPTY
22728: PPUSH
22729: CALL_OW 1
22733: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
22734: LD_ADDR_EXP 115
22738: PUSH
22739: LD_EXP 115
22743: PPUSH
22744: LD_VAR 0 2
22748: PPUSH
22749: EMPTY
22750: PPUSH
22751: CALL_OW 1
22755: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
22756: LD_ADDR_EXP 116
22760: PUSH
22761: LD_EXP 116
22765: PPUSH
22766: LD_VAR 0 2
22770: PPUSH
22771: LD_INT 0
22773: PPUSH
22774: CALL_OW 1
22778: ST_TO_ADDR
// end ;
22779: GO 21703
22781: POP
22782: POP
// MC_InitSides ( ) ;
22783: CALL 23069 0 0
// MC_InitResearch ( ) ;
22787: CALL 22808 0 0
// CustomInitMacro ( ) ;
22791: CALL 173 0 0
// skirmish := true ;
22795: LD_ADDR_EXP 72
22799: PUSH
22800: LD_INT 1
22802: ST_TO_ADDR
// end ;
22803: LD_VAR 0 1
22807: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
22808: LD_INT 0
22810: PPUSH
22811: PPUSH
22812: PPUSH
22813: PPUSH
22814: PPUSH
22815: PPUSH
// if not mc_bases then
22816: LD_EXP 74
22820: NOT
22821: IFFALSE 22825
// exit ;
22823: GO 23064
// for i = 1 to 8 do
22825: LD_ADDR_VAR 0 2
22829: PUSH
22830: DOUBLE
22831: LD_INT 1
22833: DEC
22834: ST_TO_ADDR
22835: LD_INT 8
22837: PUSH
22838: FOR_TO
22839: IFFALSE 22865
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
22841: LD_ADDR_EXP 101
22845: PUSH
22846: LD_EXP 101
22850: PPUSH
22851: LD_VAR 0 2
22855: PPUSH
22856: EMPTY
22857: PPUSH
22858: CALL_OW 1
22862: ST_TO_ADDR
22863: GO 22838
22865: POP
22866: POP
// tmp := [ ] ;
22867: LD_ADDR_VAR 0 5
22871: PUSH
22872: EMPTY
22873: ST_TO_ADDR
// for i = 1 to mc_sides do
22874: LD_ADDR_VAR 0 2
22878: PUSH
22879: DOUBLE
22880: LD_INT 1
22882: DEC
22883: ST_TO_ADDR
22884: LD_EXP 100
22888: PUSH
22889: FOR_TO
22890: IFFALSE 22948
// if not mc_sides [ i ] in tmp then
22892: LD_EXP 100
22896: PUSH
22897: LD_VAR 0 2
22901: ARRAY
22902: PUSH
22903: LD_VAR 0 5
22907: IN
22908: NOT
22909: IFFALSE 22946
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
22911: LD_ADDR_VAR 0 5
22915: PUSH
22916: LD_VAR 0 5
22920: PPUSH
22921: LD_VAR 0 5
22925: PUSH
22926: LD_INT 1
22928: PLUS
22929: PPUSH
22930: LD_EXP 100
22934: PUSH
22935: LD_VAR 0 2
22939: ARRAY
22940: PPUSH
22941: CALL_OW 2
22945: ST_TO_ADDR
22946: GO 22889
22948: POP
22949: POP
// if not tmp then
22950: LD_VAR 0 5
22954: NOT
22955: IFFALSE 22959
// exit ;
22957: GO 23064
// for j in tmp do
22959: LD_ADDR_VAR 0 3
22963: PUSH
22964: LD_VAR 0 5
22968: PUSH
22969: FOR_IN
22970: IFFALSE 23062
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
22972: LD_ADDR_VAR 0 6
22976: PUSH
22977: LD_INT 22
22979: PUSH
22980: LD_VAR 0 3
22984: PUSH
22985: EMPTY
22986: LIST
22987: LIST
22988: PPUSH
22989: CALL_OW 69
22993: ST_TO_ADDR
// if not un then
22994: LD_VAR 0 6
22998: NOT
22999: IFFALSE 23003
// continue ;
23001: GO 22969
// nation := GetNation ( un [ 1 ] ) ;
23003: LD_ADDR_VAR 0 4
23007: PUSH
23008: LD_VAR 0 6
23012: PUSH
23013: LD_INT 1
23015: ARRAY
23016: PPUSH
23017: CALL_OW 248
23021: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23022: LD_ADDR_EXP 101
23026: PUSH
23027: LD_EXP 101
23031: PPUSH
23032: LD_VAR 0 3
23036: PPUSH
23037: LD_VAR 0 3
23041: PPUSH
23042: LD_VAR 0 4
23046: PPUSH
23047: LD_INT 1
23049: PPUSH
23050: CALL 49428 0 3
23054: PPUSH
23055: CALL_OW 1
23059: ST_TO_ADDR
// end ;
23060: GO 22969
23062: POP
23063: POP
// end ;
23064: LD_VAR 0 1
23068: RET
// export function MC_InitSides ( ) ; var i ; begin
23069: LD_INT 0
23071: PPUSH
23072: PPUSH
// if not mc_bases then
23073: LD_EXP 74
23077: NOT
23078: IFFALSE 23082
// exit ;
23080: GO 23156
// for i = 1 to mc_bases do
23082: LD_ADDR_VAR 0 2
23086: PUSH
23087: DOUBLE
23088: LD_INT 1
23090: DEC
23091: ST_TO_ADDR
23092: LD_EXP 74
23096: PUSH
23097: FOR_TO
23098: IFFALSE 23154
// if mc_bases [ i ] then
23100: LD_EXP 74
23104: PUSH
23105: LD_VAR 0 2
23109: ARRAY
23110: IFFALSE 23152
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
23112: LD_ADDR_EXP 100
23116: PUSH
23117: LD_EXP 100
23121: PPUSH
23122: LD_VAR 0 2
23126: PPUSH
23127: LD_EXP 74
23131: PUSH
23132: LD_VAR 0 2
23136: ARRAY
23137: PUSH
23138: LD_INT 1
23140: ARRAY
23141: PPUSH
23142: CALL_OW 255
23146: PPUSH
23147: CALL_OW 1
23151: ST_TO_ADDR
23152: GO 23097
23154: POP
23155: POP
// end ;
23156: LD_VAR 0 1
23160: RET
// every 0 0$01 trigger skirmish do
23161: LD_EXP 72
23165: IFFALSE 23319
23167: GO 23169
23169: DISABLE
// begin enable ;
23170: ENABLE
// MC_CheckBuildings ( ) ;
23171: CALL 27817 0 0
// MC_CheckPeopleLife ( ) ;
23175: CALL 27942 0 0
// RaiseSailEvent ( 100 ) ;
23179: LD_INT 100
23181: PPUSH
23182: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
23186: LD_INT 103
23188: PPUSH
23189: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
23193: LD_INT 104
23195: PPUSH
23196: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
23200: LD_INT 105
23202: PPUSH
23203: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
23207: LD_INT 106
23209: PPUSH
23210: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
23214: LD_INT 107
23216: PPUSH
23217: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
23221: LD_INT 108
23223: PPUSH
23224: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
23228: LD_INT 109
23230: PPUSH
23231: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
23235: LD_INT 110
23237: PPUSH
23238: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
23242: LD_INT 111
23244: PPUSH
23245: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
23249: LD_INT 112
23251: PPUSH
23252: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
23256: LD_INT 113
23258: PPUSH
23259: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
23263: LD_INT 120
23265: PPUSH
23266: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
23270: LD_INT 121
23272: PPUSH
23273: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
23277: LD_INT 122
23279: PPUSH
23280: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
23284: LD_INT 123
23286: PPUSH
23287: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
23291: LD_INT 124
23293: PPUSH
23294: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
23298: LD_INT 125
23300: PPUSH
23301: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
23305: LD_INT 126
23307: PPUSH
23308: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
23312: LD_INT 200
23314: PPUSH
23315: CALL_OW 427
// end ;
23319: END
// on SailEvent ( event ) do begin if event < 100 then
23320: LD_VAR 0 1
23324: PUSH
23325: LD_INT 100
23327: LESS
23328: IFFALSE 23339
// CustomEvent ( event ) ;
23330: LD_VAR 0 1
23334: PPUSH
23335: CALL 9774 0 1
// if event = 100 then
23339: LD_VAR 0 1
23343: PUSH
23344: LD_INT 100
23346: EQUAL
23347: IFFALSE 23353
// MC_ClassManager ( ) ;
23349: CALL 23745 0 0
// if event = 101 then
23353: LD_VAR 0 1
23357: PUSH
23358: LD_INT 101
23360: EQUAL
23361: IFFALSE 23367
// MC_RepairBuildings ( ) ;
23363: CALL 28538 0 0
// if event = 102 then
23367: LD_VAR 0 1
23371: PUSH
23372: LD_INT 102
23374: EQUAL
23375: IFFALSE 23381
// MC_Heal ( ) ;
23377: CALL 29270 0 0
// if event = 103 then
23381: LD_VAR 0 1
23385: PUSH
23386: LD_INT 103
23388: EQUAL
23389: IFFALSE 23395
// MC_Build ( ) ;
23391: CALL 29692 0 0
// if event = 104 then
23395: LD_VAR 0 1
23399: PUSH
23400: LD_INT 104
23402: EQUAL
23403: IFFALSE 23409
// MC_TurretWeapon ( ) ;
23405: CALL 31305 0 0
// if event = 105 then
23409: LD_VAR 0 1
23413: PUSH
23414: LD_INT 105
23416: EQUAL
23417: IFFALSE 23423
// MC_BuildUpgrade ( ) ;
23419: CALL 30856 0 0
// if event = 106 then
23423: LD_VAR 0 1
23427: PUSH
23428: LD_INT 106
23430: EQUAL
23431: IFFALSE 23437
// MC_PlantMines ( ) ;
23433: CALL 31735 0 0
// if event = 107 then
23437: LD_VAR 0 1
23441: PUSH
23442: LD_INT 107
23444: EQUAL
23445: IFFALSE 23451
// MC_CollectCrates ( ) ;
23447: CALL 32769 0 0
// if event = 108 then
23451: LD_VAR 0 1
23455: PUSH
23456: LD_INT 108
23458: EQUAL
23459: IFFALSE 23465
// MC_LinkRemoteControl ( ) ;
23461: CALL 34545 0 0
// if event = 109 then
23465: LD_VAR 0 1
23469: PUSH
23470: LD_INT 109
23472: EQUAL
23473: IFFALSE 23479
// MC_ProduceVehicle ( ) ;
23475: CALL 34726 0 0
// if event = 110 then
23479: LD_VAR 0 1
23483: PUSH
23484: LD_INT 110
23486: EQUAL
23487: IFFALSE 23493
// MC_SendAttack ( ) ;
23489: CALL 35192 0 0
// if event = 111 then
23493: LD_VAR 0 1
23497: PUSH
23498: LD_INT 111
23500: EQUAL
23501: IFFALSE 23507
// MC_Defend ( ) ;
23503: CALL 35300 0 0
// if event = 112 then
23507: LD_VAR 0 1
23511: PUSH
23512: LD_INT 112
23514: EQUAL
23515: IFFALSE 23521
// MC_Research ( ) ;
23517: CALL 35905 0 0
// if event = 113 then
23521: LD_VAR 0 1
23525: PUSH
23526: LD_INT 113
23528: EQUAL
23529: IFFALSE 23535
// MC_MinesTrigger ( ) ;
23531: CALL 37019 0 0
// if event = 120 then
23535: LD_VAR 0 1
23539: PUSH
23540: LD_INT 120
23542: EQUAL
23543: IFFALSE 23549
// MC_RepairVehicle ( ) ;
23545: CALL 37118 0 0
// if event = 121 then
23549: LD_VAR 0 1
23553: PUSH
23554: LD_INT 121
23556: EQUAL
23557: IFFALSE 23563
// MC_TameApe ( ) ;
23559: CALL 37848 0 0
// if event = 122 then
23563: LD_VAR 0 1
23567: PUSH
23568: LD_INT 122
23570: EQUAL
23571: IFFALSE 23577
// MC_ChangeApeClass ( ) ;
23573: CALL 38677 0 0
// if event = 123 then
23577: LD_VAR 0 1
23581: PUSH
23582: LD_INT 123
23584: EQUAL
23585: IFFALSE 23591
// MC_Bazooka ( ) ;
23587: CALL 39327 0 0
// if event = 124 then
23591: LD_VAR 0 1
23595: PUSH
23596: LD_INT 124
23598: EQUAL
23599: IFFALSE 23605
// MC_TeleportExit ( ) ;
23601: CALL 39525 0 0
// if event = 125 then
23605: LD_VAR 0 1
23609: PUSH
23610: LD_INT 125
23612: EQUAL
23613: IFFALSE 23619
// MC_Deposits ( ) ;
23615: CALL 40172 0 0
// if event = 126 then
23619: LD_VAR 0 1
23623: PUSH
23624: LD_INT 126
23626: EQUAL
23627: IFFALSE 23633
// MC_RemoteDriver ( ) ;
23629: CALL 40797 0 0
// if event = 200 then
23633: LD_VAR 0 1
23637: PUSH
23638: LD_INT 200
23640: EQUAL
23641: IFFALSE 23647
// MC_Idle ( ) ;
23643: CALL 42530 0 0
// end ;
23647: PPOPN 1
23649: END
// export function MC_Reset ( base , tag ) ; var i ; begin
23650: LD_INT 0
23652: PPUSH
23653: PPUSH
// if not mc_bases [ base ] or not tag then
23654: LD_EXP 74
23658: PUSH
23659: LD_VAR 0 1
23663: ARRAY
23664: NOT
23665: PUSH
23666: LD_VAR 0 2
23670: NOT
23671: OR
23672: IFFALSE 23676
// exit ;
23674: GO 23740
// for i in mc_bases [ base ] union mc_ape [ base ] do
23676: LD_ADDR_VAR 0 4
23680: PUSH
23681: LD_EXP 74
23685: PUSH
23686: LD_VAR 0 1
23690: ARRAY
23691: PUSH
23692: LD_EXP 103
23696: PUSH
23697: LD_VAR 0 1
23701: ARRAY
23702: UNION
23703: PUSH
23704: FOR_IN
23705: IFFALSE 23738
// if GetTag ( i ) = tag then
23707: LD_VAR 0 4
23711: PPUSH
23712: CALL_OW 110
23716: PUSH
23717: LD_VAR 0 2
23721: EQUAL
23722: IFFALSE 23736
// SetTag ( i , 0 ) ;
23724: LD_VAR 0 4
23728: PPUSH
23729: LD_INT 0
23731: PPUSH
23732: CALL_OW 109
23736: GO 23704
23738: POP
23739: POP
// end ;
23740: LD_VAR 0 3
23744: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
23745: LD_INT 0
23747: PPUSH
23748: PPUSH
23749: PPUSH
23750: PPUSH
23751: PPUSH
23752: PPUSH
23753: PPUSH
23754: PPUSH
// if not mc_bases then
23755: LD_EXP 74
23759: NOT
23760: IFFALSE 23764
// exit ;
23762: GO 24222
// for i = 1 to mc_bases do
23764: LD_ADDR_VAR 0 2
23768: PUSH
23769: DOUBLE
23770: LD_INT 1
23772: DEC
23773: ST_TO_ADDR
23774: LD_EXP 74
23778: PUSH
23779: FOR_TO
23780: IFFALSE 24220
// begin tmp := MC_ClassCheckReq ( i ) ;
23782: LD_ADDR_VAR 0 4
23786: PUSH
23787: LD_VAR 0 2
23791: PPUSH
23792: CALL 24227 0 1
23796: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
23797: LD_ADDR_EXP 115
23801: PUSH
23802: LD_EXP 115
23806: PPUSH
23807: LD_VAR 0 2
23811: PPUSH
23812: LD_VAR 0 4
23816: PPUSH
23817: CALL_OW 1
23821: ST_TO_ADDR
// if not tmp then
23822: LD_VAR 0 4
23826: NOT
23827: IFFALSE 23831
// continue ;
23829: GO 23779
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
23831: LD_ADDR_VAR 0 6
23835: PUSH
23836: LD_EXP 74
23840: PUSH
23841: LD_VAR 0 2
23845: ARRAY
23846: PPUSH
23847: LD_INT 2
23849: PUSH
23850: LD_INT 30
23852: PUSH
23853: LD_INT 4
23855: PUSH
23856: EMPTY
23857: LIST
23858: LIST
23859: PUSH
23860: LD_INT 30
23862: PUSH
23863: LD_INT 5
23865: PUSH
23866: EMPTY
23867: LIST
23868: LIST
23869: PUSH
23870: EMPTY
23871: LIST
23872: LIST
23873: LIST
23874: PPUSH
23875: CALL_OW 72
23879: PUSH
23880: LD_EXP 74
23884: PUSH
23885: LD_VAR 0 2
23889: ARRAY
23890: PPUSH
23891: LD_INT 2
23893: PUSH
23894: LD_INT 30
23896: PUSH
23897: LD_INT 0
23899: PUSH
23900: EMPTY
23901: LIST
23902: LIST
23903: PUSH
23904: LD_INT 30
23906: PUSH
23907: LD_INT 1
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: PUSH
23914: EMPTY
23915: LIST
23916: LIST
23917: LIST
23918: PPUSH
23919: CALL_OW 72
23923: PUSH
23924: LD_EXP 74
23928: PUSH
23929: LD_VAR 0 2
23933: ARRAY
23934: PPUSH
23935: LD_INT 30
23937: PUSH
23938: LD_INT 3
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: PPUSH
23945: CALL_OW 72
23949: PUSH
23950: LD_EXP 74
23954: PUSH
23955: LD_VAR 0 2
23959: ARRAY
23960: PPUSH
23961: LD_INT 2
23963: PUSH
23964: LD_INT 30
23966: PUSH
23967: LD_INT 6
23969: PUSH
23970: EMPTY
23971: LIST
23972: LIST
23973: PUSH
23974: LD_INT 30
23976: PUSH
23977: LD_INT 7
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PUSH
23984: LD_INT 30
23986: PUSH
23987: LD_INT 8
23989: PUSH
23990: EMPTY
23991: LIST
23992: LIST
23993: PUSH
23994: EMPTY
23995: LIST
23996: LIST
23997: LIST
23998: LIST
23999: PPUSH
24000: CALL_OW 72
24004: PUSH
24005: EMPTY
24006: LIST
24007: LIST
24008: LIST
24009: LIST
24010: ST_TO_ADDR
// for j = 1 to 4 do
24011: LD_ADDR_VAR 0 3
24015: PUSH
24016: DOUBLE
24017: LD_INT 1
24019: DEC
24020: ST_TO_ADDR
24021: LD_INT 4
24023: PUSH
24024: FOR_TO
24025: IFFALSE 24216
// begin if not tmp [ j ] then
24027: LD_VAR 0 4
24031: PUSH
24032: LD_VAR 0 3
24036: ARRAY
24037: NOT
24038: IFFALSE 24042
// continue ;
24040: GO 24024
// for p in tmp [ j ] do
24042: LD_ADDR_VAR 0 5
24046: PUSH
24047: LD_VAR 0 4
24051: PUSH
24052: LD_VAR 0 3
24056: ARRAY
24057: PUSH
24058: FOR_IN
24059: IFFALSE 24212
// begin if not b [ j ] then
24061: LD_VAR 0 6
24065: PUSH
24066: LD_VAR 0 3
24070: ARRAY
24071: NOT
24072: IFFALSE 24076
// break ;
24074: GO 24212
// e := 0 ;
24076: LD_ADDR_VAR 0 7
24080: PUSH
24081: LD_INT 0
24083: ST_TO_ADDR
// for k in b [ j ] do
24084: LD_ADDR_VAR 0 8
24088: PUSH
24089: LD_VAR 0 6
24093: PUSH
24094: LD_VAR 0 3
24098: ARRAY
24099: PUSH
24100: FOR_IN
24101: IFFALSE 24128
// if IsNotFull ( k ) then
24103: LD_VAR 0 8
24107: PPUSH
24108: CALL 53504 0 1
24112: IFFALSE 24126
// begin e := k ;
24114: LD_ADDR_VAR 0 7
24118: PUSH
24119: LD_VAR 0 8
24123: ST_TO_ADDR
// break ;
24124: GO 24128
// end ;
24126: GO 24100
24128: POP
24129: POP
// if e and not UnitGoingToBuilding ( p , e ) then
24130: LD_VAR 0 7
24134: PUSH
24135: LD_VAR 0 5
24139: PPUSH
24140: LD_VAR 0 7
24144: PPUSH
24145: CALL 90623 0 2
24149: NOT
24150: AND
24151: IFFALSE 24210
// begin if IsInUnit ( p ) then
24153: LD_VAR 0 5
24157: PPUSH
24158: CALL_OW 310
24162: IFFALSE 24173
// ComExitBuilding ( p ) ;
24164: LD_VAR 0 5
24168: PPUSH
24169: CALL_OW 122
// ComEnterUnit ( p , e ) ;
24173: LD_VAR 0 5
24177: PPUSH
24178: LD_VAR 0 7
24182: PPUSH
24183: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
24187: LD_VAR 0 5
24191: PPUSH
24192: LD_VAR 0 3
24196: PPUSH
24197: CALL_OW 183
// AddComExitBuilding ( p ) ;
24201: LD_VAR 0 5
24205: PPUSH
24206: CALL_OW 182
// end ; end ;
24210: GO 24058
24212: POP
24213: POP
// end ;
24214: GO 24024
24216: POP
24217: POP
// end ;
24218: GO 23779
24220: POP
24221: POP
// end ;
24222: LD_VAR 0 1
24226: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
24227: LD_INT 0
24229: PPUSH
24230: PPUSH
24231: PPUSH
24232: PPUSH
24233: PPUSH
24234: PPUSH
24235: PPUSH
24236: PPUSH
24237: PPUSH
24238: PPUSH
24239: PPUSH
24240: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24241: LD_VAR 0 1
24245: NOT
24246: PUSH
24247: LD_EXP 74
24251: PUSH
24252: LD_VAR 0 1
24256: ARRAY
24257: NOT
24258: OR
24259: PUSH
24260: LD_EXP 74
24264: PUSH
24265: LD_VAR 0 1
24269: ARRAY
24270: PPUSH
24271: LD_INT 2
24273: PUSH
24274: LD_INT 30
24276: PUSH
24277: LD_INT 0
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: PUSH
24284: LD_INT 30
24286: PUSH
24287: LD_INT 1
24289: PUSH
24290: EMPTY
24291: LIST
24292: LIST
24293: PUSH
24294: EMPTY
24295: LIST
24296: LIST
24297: LIST
24298: PPUSH
24299: CALL_OW 72
24303: NOT
24304: OR
24305: IFFALSE 24309
// exit ;
24307: GO 27812
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24309: LD_ADDR_VAR 0 4
24313: PUSH
24314: LD_EXP 74
24318: PUSH
24319: LD_VAR 0 1
24323: ARRAY
24324: PPUSH
24325: LD_INT 2
24327: PUSH
24328: LD_INT 25
24330: PUSH
24331: LD_INT 1
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: PUSH
24338: LD_INT 25
24340: PUSH
24341: LD_INT 2
24343: PUSH
24344: EMPTY
24345: LIST
24346: LIST
24347: PUSH
24348: LD_INT 25
24350: PUSH
24351: LD_INT 3
24353: PUSH
24354: EMPTY
24355: LIST
24356: LIST
24357: PUSH
24358: LD_INT 25
24360: PUSH
24361: LD_INT 4
24363: PUSH
24364: EMPTY
24365: LIST
24366: LIST
24367: PUSH
24368: LD_INT 25
24370: PUSH
24371: LD_INT 5
24373: PUSH
24374: EMPTY
24375: LIST
24376: LIST
24377: PUSH
24378: LD_INT 25
24380: PUSH
24381: LD_INT 8
24383: PUSH
24384: EMPTY
24385: LIST
24386: LIST
24387: PUSH
24388: LD_INT 25
24390: PUSH
24391: LD_INT 9
24393: PUSH
24394: EMPTY
24395: LIST
24396: LIST
24397: PUSH
24398: EMPTY
24399: LIST
24400: LIST
24401: LIST
24402: LIST
24403: LIST
24404: LIST
24405: LIST
24406: LIST
24407: PPUSH
24408: CALL_OW 72
24412: ST_TO_ADDR
// if not tmp then
24413: LD_VAR 0 4
24417: NOT
24418: IFFALSE 24422
// exit ;
24420: GO 27812
// for i in tmp do
24422: LD_ADDR_VAR 0 3
24426: PUSH
24427: LD_VAR 0 4
24431: PUSH
24432: FOR_IN
24433: IFFALSE 24464
// if GetTag ( i ) then
24435: LD_VAR 0 3
24439: PPUSH
24440: CALL_OW 110
24444: IFFALSE 24462
// tmp := tmp diff i ;
24446: LD_ADDR_VAR 0 4
24450: PUSH
24451: LD_VAR 0 4
24455: PUSH
24456: LD_VAR 0 3
24460: DIFF
24461: ST_TO_ADDR
24462: GO 24432
24464: POP
24465: POP
// if not tmp then
24466: LD_VAR 0 4
24470: NOT
24471: IFFALSE 24475
// exit ;
24473: GO 27812
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24475: LD_ADDR_VAR 0 5
24479: PUSH
24480: LD_EXP 74
24484: PUSH
24485: LD_VAR 0 1
24489: ARRAY
24490: PPUSH
24491: LD_INT 2
24493: PUSH
24494: LD_INT 25
24496: PUSH
24497: LD_INT 1
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: PUSH
24504: LD_INT 25
24506: PUSH
24507: LD_INT 5
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 25
24516: PUSH
24517: LD_INT 8
24519: PUSH
24520: EMPTY
24521: LIST
24522: LIST
24523: PUSH
24524: LD_INT 25
24526: PUSH
24527: LD_INT 9
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: PUSH
24534: EMPTY
24535: LIST
24536: LIST
24537: LIST
24538: LIST
24539: LIST
24540: PPUSH
24541: CALL_OW 72
24545: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
24546: LD_ADDR_VAR 0 6
24550: PUSH
24551: LD_EXP 74
24555: PUSH
24556: LD_VAR 0 1
24560: ARRAY
24561: PPUSH
24562: LD_INT 25
24564: PUSH
24565: LD_INT 2
24567: PUSH
24568: EMPTY
24569: LIST
24570: LIST
24571: PPUSH
24572: CALL_OW 72
24576: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
24577: LD_ADDR_VAR 0 7
24581: PUSH
24582: LD_EXP 74
24586: PUSH
24587: LD_VAR 0 1
24591: ARRAY
24592: PPUSH
24593: LD_INT 25
24595: PUSH
24596: LD_INT 3
24598: PUSH
24599: EMPTY
24600: LIST
24601: LIST
24602: PPUSH
24603: CALL_OW 72
24607: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
24608: LD_ADDR_VAR 0 8
24612: PUSH
24613: LD_EXP 74
24617: PUSH
24618: LD_VAR 0 1
24622: ARRAY
24623: PPUSH
24624: LD_INT 25
24626: PUSH
24627: LD_INT 4
24629: PUSH
24630: EMPTY
24631: LIST
24632: LIST
24633: PUSH
24634: LD_INT 24
24636: PUSH
24637: LD_INT 251
24639: PUSH
24640: EMPTY
24641: LIST
24642: LIST
24643: PUSH
24644: EMPTY
24645: LIST
24646: LIST
24647: PPUSH
24648: CALL_OW 72
24652: ST_TO_ADDR
// if mc_scan [ base ] then
24653: LD_EXP 97
24657: PUSH
24658: LD_VAR 0 1
24662: ARRAY
24663: IFFALSE 25124
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
24665: LD_ADDR_EXP 116
24669: PUSH
24670: LD_EXP 116
24674: PPUSH
24675: LD_VAR 0 1
24679: PPUSH
24680: LD_INT 4
24682: PPUSH
24683: CALL_OW 1
24687: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
24688: LD_ADDR_VAR 0 12
24692: PUSH
24693: LD_EXP 74
24697: PUSH
24698: LD_VAR 0 1
24702: ARRAY
24703: PPUSH
24704: LD_INT 2
24706: PUSH
24707: LD_INT 30
24709: PUSH
24710: LD_INT 4
24712: PUSH
24713: EMPTY
24714: LIST
24715: LIST
24716: PUSH
24717: LD_INT 30
24719: PUSH
24720: LD_INT 5
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: LIST
24731: PPUSH
24732: CALL_OW 72
24736: ST_TO_ADDR
// if not b then
24737: LD_VAR 0 12
24741: NOT
24742: IFFALSE 24746
// exit ;
24744: GO 27812
// p := [ ] ;
24746: LD_ADDR_VAR 0 11
24750: PUSH
24751: EMPTY
24752: ST_TO_ADDR
// if sci >= 2 then
24753: LD_VAR 0 8
24757: PUSH
24758: LD_INT 2
24760: GREATEREQUAL
24761: IFFALSE 24792
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
24763: LD_ADDR_VAR 0 8
24767: PUSH
24768: LD_VAR 0 8
24772: PUSH
24773: LD_INT 1
24775: ARRAY
24776: PUSH
24777: LD_VAR 0 8
24781: PUSH
24782: LD_INT 2
24784: ARRAY
24785: PUSH
24786: EMPTY
24787: LIST
24788: LIST
24789: ST_TO_ADDR
24790: GO 24853
// if sci = 1 then
24792: LD_VAR 0 8
24796: PUSH
24797: LD_INT 1
24799: EQUAL
24800: IFFALSE 24821
// sci := [ sci [ 1 ] ] else
24802: LD_ADDR_VAR 0 8
24806: PUSH
24807: LD_VAR 0 8
24811: PUSH
24812: LD_INT 1
24814: ARRAY
24815: PUSH
24816: EMPTY
24817: LIST
24818: ST_TO_ADDR
24819: GO 24853
// if sci = 0 then
24821: LD_VAR 0 8
24825: PUSH
24826: LD_INT 0
24828: EQUAL
24829: IFFALSE 24853
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
24831: LD_ADDR_VAR 0 11
24835: PUSH
24836: LD_VAR 0 4
24840: PPUSH
24841: LD_INT 4
24843: PPUSH
24844: CALL 90486 0 2
24848: PUSH
24849: LD_INT 1
24851: ARRAY
24852: ST_TO_ADDR
// if eng > 4 then
24853: LD_VAR 0 6
24857: PUSH
24858: LD_INT 4
24860: GREATER
24861: IFFALSE 24907
// for i = eng downto 4 do
24863: LD_ADDR_VAR 0 3
24867: PUSH
24868: DOUBLE
24869: LD_VAR 0 6
24873: INC
24874: ST_TO_ADDR
24875: LD_INT 4
24877: PUSH
24878: FOR_DOWNTO
24879: IFFALSE 24905
// eng := eng diff eng [ i ] ;
24881: LD_ADDR_VAR 0 6
24885: PUSH
24886: LD_VAR 0 6
24890: PUSH
24891: LD_VAR 0 6
24895: PUSH
24896: LD_VAR 0 3
24900: ARRAY
24901: DIFF
24902: ST_TO_ADDR
24903: GO 24878
24905: POP
24906: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
24907: LD_ADDR_VAR 0 4
24911: PUSH
24912: LD_VAR 0 4
24916: PUSH
24917: LD_VAR 0 5
24921: PUSH
24922: LD_VAR 0 6
24926: UNION
24927: PUSH
24928: LD_VAR 0 7
24932: UNION
24933: PUSH
24934: LD_VAR 0 8
24938: UNION
24939: DIFF
24940: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
24941: LD_ADDR_VAR 0 13
24945: PUSH
24946: LD_EXP 74
24950: PUSH
24951: LD_VAR 0 1
24955: ARRAY
24956: PPUSH
24957: LD_INT 2
24959: PUSH
24960: LD_INT 30
24962: PUSH
24963: LD_INT 32
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: LD_INT 30
24972: PUSH
24973: LD_INT 31
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: EMPTY
24981: LIST
24982: LIST
24983: LIST
24984: PPUSH
24985: CALL_OW 72
24989: PUSH
24990: LD_EXP 74
24994: PUSH
24995: LD_VAR 0 1
24999: ARRAY
25000: PPUSH
25001: LD_INT 2
25003: PUSH
25004: LD_INT 30
25006: PUSH
25007: LD_INT 4
25009: PUSH
25010: EMPTY
25011: LIST
25012: LIST
25013: PUSH
25014: LD_INT 30
25016: PUSH
25017: LD_INT 5
25019: PUSH
25020: EMPTY
25021: LIST
25022: LIST
25023: PUSH
25024: EMPTY
25025: LIST
25026: LIST
25027: LIST
25028: PPUSH
25029: CALL_OW 72
25033: PUSH
25034: LD_INT 6
25036: MUL
25037: PLUS
25038: ST_TO_ADDR
// if bcount < tmp then
25039: LD_VAR 0 13
25043: PUSH
25044: LD_VAR 0 4
25048: LESS
25049: IFFALSE 25095
// for i = tmp downto bcount do
25051: LD_ADDR_VAR 0 3
25055: PUSH
25056: DOUBLE
25057: LD_VAR 0 4
25061: INC
25062: ST_TO_ADDR
25063: LD_VAR 0 13
25067: PUSH
25068: FOR_DOWNTO
25069: IFFALSE 25093
// tmp := Delete ( tmp , tmp ) ;
25071: LD_ADDR_VAR 0 4
25075: PUSH
25076: LD_VAR 0 4
25080: PPUSH
25081: LD_VAR 0 4
25085: PPUSH
25086: CALL_OW 3
25090: ST_TO_ADDR
25091: GO 25068
25093: POP
25094: POP
// result := [ tmp , 0 , 0 , p ] ;
25095: LD_ADDR_VAR 0 2
25099: PUSH
25100: LD_VAR 0 4
25104: PUSH
25105: LD_INT 0
25107: PUSH
25108: LD_INT 0
25110: PUSH
25111: LD_VAR 0 11
25115: PUSH
25116: EMPTY
25117: LIST
25118: LIST
25119: LIST
25120: LIST
25121: ST_TO_ADDR
// exit ;
25122: GO 27812
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25124: LD_EXP 74
25128: PUSH
25129: LD_VAR 0 1
25133: ARRAY
25134: PPUSH
25135: LD_INT 2
25137: PUSH
25138: LD_INT 30
25140: PUSH
25141: LD_INT 6
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: PUSH
25148: LD_INT 30
25150: PUSH
25151: LD_INT 7
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: LD_INT 30
25160: PUSH
25161: LD_INT 8
25163: PUSH
25164: EMPTY
25165: LIST
25166: LIST
25167: PUSH
25168: EMPTY
25169: LIST
25170: LIST
25171: LIST
25172: LIST
25173: PPUSH
25174: CALL_OW 72
25178: NOT
25179: PUSH
25180: LD_EXP 74
25184: PUSH
25185: LD_VAR 0 1
25189: ARRAY
25190: PPUSH
25191: LD_INT 30
25193: PUSH
25194: LD_INT 3
25196: PUSH
25197: EMPTY
25198: LIST
25199: LIST
25200: PPUSH
25201: CALL_OW 72
25205: NOT
25206: AND
25207: IFFALSE 25279
// begin if eng = tmp then
25209: LD_VAR 0 6
25213: PUSH
25214: LD_VAR 0 4
25218: EQUAL
25219: IFFALSE 25223
// exit ;
25221: GO 27812
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
25223: LD_ADDR_EXP 116
25227: PUSH
25228: LD_EXP 116
25232: PPUSH
25233: LD_VAR 0 1
25237: PPUSH
25238: LD_INT 1
25240: PPUSH
25241: CALL_OW 1
25245: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
25246: LD_ADDR_VAR 0 2
25250: PUSH
25251: LD_INT 0
25253: PUSH
25254: LD_VAR 0 4
25258: PUSH
25259: LD_VAR 0 6
25263: DIFF
25264: PUSH
25265: LD_INT 0
25267: PUSH
25268: LD_INT 0
25270: PUSH
25271: EMPTY
25272: LIST
25273: LIST
25274: LIST
25275: LIST
25276: ST_TO_ADDR
// exit ;
25277: GO 27812
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25279: LD_EXP 101
25283: PUSH
25284: LD_EXP 100
25288: PUSH
25289: LD_VAR 0 1
25293: ARRAY
25294: ARRAY
25295: PUSH
25296: LD_EXP 74
25300: PUSH
25301: LD_VAR 0 1
25305: ARRAY
25306: PPUSH
25307: LD_INT 2
25309: PUSH
25310: LD_INT 30
25312: PUSH
25313: LD_INT 6
25315: PUSH
25316: EMPTY
25317: LIST
25318: LIST
25319: PUSH
25320: LD_INT 30
25322: PUSH
25323: LD_INT 7
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: PUSH
25330: LD_INT 30
25332: PUSH
25333: LD_INT 8
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: PUSH
25340: EMPTY
25341: LIST
25342: LIST
25343: LIST
25344: LIST
25345: PPUSH
25346: CALL_OW 72
25350: AND
25351: PUSH
25352: LD_EXP 74
25356: PUSH
25357: LD_VAR 0 1
25361: ARRAY
25362: PPUSH
25363: LD_INT 30
25365: PUSH
25366: LD_INT 3
25368: PUSH
25369: EMPTY
25370: LIST
25371: LIST
25372: PPUSH
25373: CALL_OW 72
25377: NOT
25378: AND
25379: IFFALSE 25593
// begin if sci >= 6 then
25381: LD_VAR 0 8
25385: PUSH
25386: LD_INT 6
25388: GREATEREQUAL
25389: IFFALSE 25393
// exit ;
25391: GO 27812
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
25393: LD_ADDR_EXP 116
25397: PUSH
25398: LD_EXP 116
25402: PPUSH
25403: LD_VAR 0 1
25407: PPUSH
25408: LD_INT 2
25410: PPUSH
25411: CALL_OW 1
25415: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
25416: LD_ADDR_VAR 0 9
25420: PUSH
25421: LD_VAR 0 4
25425: PUSH
25426: LD_VAR 0 8
25430: DIFF
25431: PPUSH
25432: LD_INT 4
25434: PPUSH
25435: CALL 90486 0 2
25439: ST_TO_ADDR
// p := [ ] ;
25440: LD_ADDR_VAR 0 11
25444: PUSH
25445: EMPTY
25446: ST_TO_ADDR
// if sci < 6 and sort > 6 then
25447: LD_VAR 0 8
25451: PUSH
25452: LD_INT 6
25454: LESS
25455: PUSH
25456: LD_VAR 0 9
25460: PUSH
25461: LD_INT 6
25463: GREATER
25464: AND
25465: IFFALSE 25546
// begin for i = 1 to 6 - sci do
25467: LD_ADDR_VAR 0 3
25471: PUSH
25472: DOUBLE
25473: LD_INT 1
25475: DEC
25476: ST_TO_ADDR
25477: LD_INT 6
25479: PUSH
25480: LD_VAR 0 8
25484: MINUS
25485: PUSH
25486: FOR_TO
25487: IFFALSE 25542
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
25489: LD_ADDR_VAR 0 11
25493: PUSH
25494: LD_VAR 0 11
25498: PPUSH
25499: LD_VAR 0 11
25503: PUSH
25504: LD_INT 1
25506: PLUS
25507: PPUSH
25508: LD_VAR 0 9
25512: PUSH
25513: LD_INT 1
25515: ARRAY
25516: PPUSH
25517: CALL_OW 2
25521: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
25522: LD_ADDR_VAR 0 9
25526: PUSH
25527: LD_VAR 0 9
25531: PPUSH
25532: LD_INT 1
25534: PPUSH
25535: CALL_OW 3
25539: ST_TO_ADDR
// end ;
25540: GO 25486
25542: POP
25543: POP
// end else
25544: GO 25566
// if sort then
25546: LD_VAR 0 9
25550: IFFALSE 25566
// p := sort [ 1 ] ;
25552: LD_ADDR_VAR 0 11
25556: PUSH
25557: LD_VAR 0 9
25561: PUSH
25562: LD_INT 1
25564: ARRAY
25565: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
25566: LD_ADDR_VAR 0 2
25570: PUSH
25571: LD_INT 0
25573: PUSH
25574: LD_INT 0
25576: PUSH
25577: LD_INT 0
25579: PUSH
25580: LD_VAR 0 11
25584: PUSH
25585: EMPTY
25586: LIST
25587: LIST
25588: LIST
25589: LIST
25590: ST_TO_ADDR
// exit ;
25591: GO 27812
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25593: LD_EXP 101
25597: PUSH
25598: LD_EXP 100
25602: PUSH
25603: LD_VAR 0 1
25607: ARRAY
25608: ARRAY
25609: PUSH
25610: LD_EXP 74
25614: PUSH
25615: LD_VAR 0 1
25619: ARRAY
25620: PPUSH
25621: LD_INT 2
25623: PUSH
25624: LD_INT 30
25626: PUSH
25627: LD_INT 6
25629: PUSH
25630: EMPTY
25631: LIST
25632: LIST
25633: PUSH
25634: LD_INT 30
25636: PUSH
25637: LD_INT 7
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: PUSH
25644: LD_INT 30
25646: PUSH
25647: LD_INT 8
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: LIST
25658: LIST
25659: PPUSH
25660: CALL_OW 72
25664: AND
25665: PUSH
25666: LD_EXP 74
25670: PUSH
25671: LD_VAR 0 1
25675: ARRAY
25676: PPUSH
25677: LD_INT 30
25679: PUSH
25680: LD_INT 3
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: PPUSH
25687: CALL_OW 72
25691: AND
25692: IFFALSE 26426
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
25694: LD_ADDR_EXP 116
25698: PUSH
25699: LD_EXP 116
25703: PPUSH
25704: LD_VAR 0 1
25708: PPUSH
25709: LD_INT 3
25711: PPUSH
25712: CALL_OW 1
25716: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25717: LD_ADDR_VAR 0 2
25721: PUSH
25722: LD_INT 0
25724: PUSH
25725: LD_INT 0
25727: PUSH
25728: LD_INT 0
25730: PUSH
25731: LD_INT 0
25733: PUSH
25734: EMPTY
25735: LIST
25736: LIST
25737: LIST
25738: LIST
25739: ST_TO_ADDR
// if not eng then
25740: LD_VAR 0 6
25744: NOT
25745: IFFALSE 25808
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
25747: LD_ADDR_VAR 0 11
25751: PUSH
25752: LD_VAR 0 4
25756: PPUSH
25757: LD_INT 2
25759: PPUSH
25760: CALL 90486 0 2
25764: PUSH
25765: LD_INT 1
25767: ARRAY
25768: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
25769: LD_ADDR_VAR 0 2
25773: PUSH
25774: LD_VAR 0 2
25778: PPUSH
25779: LD_INT 2
25781: PPUSH
25782: LD_VAR 0 11
25786: PPUSH
25787: CALL_OW 1
25791: ST_TO_ADDR
// tmp := tmp diff p ;
25792: LD_ADDR_VAR 0 4
25796: PUSH
25797: LD_VAR 0 4
25801: PUSH
25802: LD_VAR 0 11
25806: DIFF
25807: ST_TO_ADDR
// end ; if tmp and sci < 6 then
25808: LD_VAR 0 4
25812: PUSH
25813: LD_VAR 0 8
25817: PUSH
25818: LD_INT 6
25820: LESS
25821: AND
25822: IFFALSE 26010
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
25824: LD_ADDR_VAR 0 9
25828: PUSH
25829: LD_VAR 0 4
25833: PUSH
25834: LD_VAR 0 8
25838: PUSH
25839: LD_VAR 0 7
25843: UNION
25844: DIFF
25845: PPUSH
25846: LD_INT 4
25848: PPUSH
25849: CALL 90486 0 2
25853: ST_TO_ADDR
// p := [ ] ;
25854: LD_ADDR_VAR 0 11
25858: PUSH
25859: EMPTY
25860: ST_TO_ADDR
// if sort then
25861: LD_VAR 0 9
25865: IFFALSE 25981
// for i = 1 to 6 - sci do
25867: LD_ADDR_VAR 0 3
25871: PUSH
25872: DOUBLE
25873: LD_INT 1
25875: DEC
25876: ST_TO_ADDR
25877: LD_INT 6
25879: PUSH
25880: LD_VAR 0 8
25884: MINUS
25885: PUSH
25886: FOR_TO
25887: IFFALSE 25979
// begin if i = sort then
25889: LD_VAR 0 3
25893: PUSH
25894: LD_VAR 0 9
25898: EQUAL
25899: IFFALSE 25903
// break ;
25901: GO 25979
// if GetClass ( i ) = 4 then
25903: LD_VAR 0 3
25907: PPUSH
25908: CALL_OW 257
25912: PUSH
25913: LD_INT 4
25915: EQUAL
25916: IFFALSE 25920
// continue ;
25918: GO 25886
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25920: LD_ADDR_VAR 0 11
25924: PUSH
25925: LD_VAR 0 11
25929: PPUSH
25930: LD_VAR 0 11
25934: PUSH
25935: LD_INT 1
25937: PLUS
25938: PPUSH
25939: LD_VAR 0 9
25943: PUSH
25944: LD_VAR 0 3
25948: ARRAY
25949: PPUSH
25950: CALL_OW 2
25954: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25955: LD_ADDR_VAR 0 4
25959: PUSH
25960: LD_VAR 0 4
25964: PUSH
25965: LD_VAR 0 9
25969: PUSH
25970: LD_VAR 0 3
25974: ARRAY
25975: DIFF
25976: ST_TO_ADDR
// end ;
25977: GO 25886
25979: POP
25980: POP
// if p then
25981: LD_VAR 0 11
25985: IFFALSE 26010
// result := Replace ( result , 4 , p ) ;
25987: LD_ADDR_VAR 0 2
25991: PUSH
25992: LD_VAR 0 2
25996: PPUSH
25997: LD_INT 4
25999: PPUSH
26000: LD_VAR 0 11
26004: PPUSH
26005: CALL_OW 1
26009: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26010: LD_VAR 0 4
26014: PUSH
26015: LD_VAR 0 7
26019: PUSH
26020: LD_INT 6
26022: LESS
26023: AND
26024: IFFALSE 26212
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26026: LD_ADDR_VAR 0 9
26030: PUSH
26031: LD_VAR 0 4
26035: PUSH
26036: LD_VAR 0 8
26040: PUSH
26041: LD_VAR 0 7
26045: UNION
26046: DIFF
26047: PPUSH
26048: LD_INT 3
26050: PPUSH
26051: CALL 90486 0 2
26055: ST_TO_ADDR
// p := [ ] ;
26056: LD_ADDR_VAR 0 11
26060: PUSH
26061: EMPTY
26062: ST_TO_ADDR
// if sort then
26063: LD_VAR 0 9
26067: IFFALSE 26183
// for i = 1 to 6 - mech do
26069: LD_ADDR_VAR 0 3
26073: PUSH
26074: DOUBLE
26075: LD_INT 1
26077: DEC
26078: ST_TO_ADDR
26079: LD_INT 6
26081: PUSH
26082: LD_VAR 0 7
26086: MINUS
26087: PUSH
26088: FOR_TO
26089: IFFALSE 26181
// begin if i = sort then
26091: LD_VAR 0 3
26095: PUSH
26096: LD_VAR 0 9
26100: EQUAL
26101: IFFALSE 26105
// break ;
26103: GO 26181
// if GetClass ( i ) = 3 then
26105: LD_VAR 0 3
26109: PPUSH
26110: CALL_OW 257
26114: PUSH
26115: LD_INT 3
26117: EQUAL
26118: IFFALSE 26122
// continue ;
26120: GO 26088
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26122: LD_ADDR_VAR 0 11
26126: PUSH
26127: LD_VAR 0 11
26131: PPUSH
26132: LD_VAR 0 11
26136: PUSH
26137: LD_INT 1
26139: PLUS
26140: PPUSH
26141: LD_VAR 0 9
26145: PUSH
26146: LD_VAR 0 3
26150: ARRAY
26151: PPUSH
26152: CALL_OW 2
26156: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26157: LD_ADDR_VAR 0 4
26161: PUSH
26162: LD_VAR 0 4
26166: PUSH
26167: LD_VAR 0 9
26171: PUSH
26172: LD_VAR 0 3
26176: ARRAY
26177: DIFF
26178: ST_TO_ADDR
// end ;
26179: GO 26088
26181: POP
26182: POP
// if p then
26183: LD_VAR 0 11
26187: IFFALSE 26212
// result := Replace ( result , 3 , p ) ;
26189: LD_ADDR_VAR 0 2
26193: PUSH
26194: LD_VAR 0 2
26198: PPUSH
26199: LD_INT 3
26201: PPUSH
26202: LD_VAR 0 11
26206: PPUSH
26207: CALL_OW 1
26211: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
26212: LD_VAR 0 4
26216: PUSH
26217: LD_INT 6
26219: GREATER
26220: PUSH
26221: LD_VAR 0 6
26225: PUSH
26226: LD_INT 6
26228: LESS
26229: AND
26230: IFFALSE 26424
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26232: LD_ADDR_VAR 0 9
26236: PUSH
26237: LD_VAR 0 4
26241: PUSH
26242: LD_VAR 0 8
26246: PUSH
26247: LD_VAR 0 7
26251: UNION
26252: PUSH
26253: LD_VAR 0 6
26257: UNION
26258: DIFF
26259: PPUSH
26260: LD_INT 2
26262: PPUSH
26263: CALL 90486 0 2
26267: ST_TO_ADDR
// p := [ ] ;
26268: LD_ADDR_VAR 0 11
26272: PUSH
26273: EMPTY
26274: ST_TO_ADDR
// if sort then
26275: LD_VAR 0 9
26279: IFFALSE 26395
// for i = 1 to 6 - eng do
26281: LD_ADDR_VAR 0 3
26285: PUSH
26286: DOUBLE
26287: LD_INT 1
26289: DEC
26290: ST_TO_ADDR
26291: LD_INT 6
26293: PUSH
26294: LD_VAR 0 6
26298: MINUS
26299: PUSH
26300: FOR_TO
26301: IFFALSE 26393
// begin if i = sort then
26303: LD_VAR 0 3
26307: PUSH
26308: LD_VAR 0 9
26312: EQUAL
26313: IFFALSE 26317
// break ;
26315: GO 26393
// if GetClass ( i ) = 2 then
26317: LD_VAR 0 3
26321: PPUSH
26322: CALL_OW 257
26326: PUSH
26327: LD_INT 2
26329: EQUAL
26330: IFFALSE 26334
// continue ;
26332: GO 26300
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26334: LD_ADDR_VAR 0 11
26338: PUSH
26339: LD_VAR 0 11
26343: PPUSH
26344: LD_VAR 0 11
26348: PUSH
26349: LD_INT 1
26351: PLUS
26352: PPUSH
26353: LD_VAR 0 9
26357: PUSH
26358: LD_VAR 0 3
26362: ARRAY
26363: PPUSH
26364: CALL_OW 2
26368: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26369: LD_ADDR_VAR 0 4
26373: PUSH
26374: LD_VAR 0 4
26378: PUSH
26379: LD_VAR 0 9
26383: PUSH
26384: LD_VAR 0 3
26388: ARRAY
26389: DIFF
26390: ST_TO_ADDR
// end ;
26391: GO 26300
26393: POP
26394: POP
// if p then
26395: LD_VAR 0 11
26399: IFFALSE 26424
// result := Replace ( result , 2 , p ) ;
26401: LD_ADDR_VAR 0 2
26405: PUSH
26406: LD_VAR 0 2
26410: PPUSH
26411: LD_INT 2
26413: PPUSH
26414: LD_VAR 0 11
26418: PPUSH
26419: CALL_OW 1
26423: ST_TO_ADDR
// end ; exit ;
26424: GO 27812
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
26426: LD_EXP 101
26430: PUSH
26431: LD_EXP 100
26435: PUSH
26436: LD_VAR 0 1
26440: ARRAY
26441: ARRAY
26442: NOT
26443: PUSH
26444: LD_EXP 74
26448: PUSH
26449: LD_VAR 0 1
26453: ARRAY
26454: PPUSH
26455: LD_INT 30
26457: PUSH
26458: LD_INT 3
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: PPUSH
26465: CALL_OW 72
26469: AND
26470: PUSH
26471: LD_EXP 79
26475: PUSH
26476: LD_VAR 0 1
26480: ARRAY
26481: AND
26482: IFFALSE 27090
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
26484: LD_ADDR_EXP 116
26488: PUSH
26489: LD_EXP 116
26493: PPUSH
26494: LD_VAR 0 1
26498: PPUSH
26499: LD_INT 5
26501: PPUSH
26502: CALL_OW 1
26506: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26507: LD_ADDR_VAR 0 2
26511: PUSH
26512: LD_INT 0
26514: PUSH
26515: LD_INT 0
26517: PUSH
26518: LD_INT 0
26520: PUSH
26521: LD_INT 0
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: LIST
26528: LIST
26529: ST_TO_ADDR
// if sci > 1 then
26530: LD_VAR 0 8
26534: PUSH
26535: LD_INT 1
26537: GREATER
26538: IFFALSE 26566
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
26540: LD_ADDR_VAR 0 4
26544: PUSH
26545: LD_VAR 0 4
26549: PUSH
26550: LD_VAR 0 8
26554: PUSH
26555: LD_VAR 0 8
26559: PUSH
26560: LD_INT 1
26562: ARRAY
26563: DIFF
26564: DIFF
26565: ST_TO_ADDR
// if tmp and not sci then
26566: LD_VAR 0 4
26570: PUSH
26571: LD_VAR 0 8
26575: NOT
26576: AND
26577: IFFALSE 26646
// begin sort := SortBySkill ( tmp , 4 ) ;
26579: LD_ADDR_VAR 0 9
26583: PUSH
26584: LD_VAR 0 4
26588: PPUSH
26589: LD_INT 4
26591: PPUSH
26592: CALL 90486 0 2
26596: ST_TO_ADDR
// if sort then
26597: LD_VAR 0 9
26601: IFFALSE 26617
// p := sort [ 1 ] ;
26603: LD_ADDR_VAR 0 11
26607: PUSH
26608: LD_VAR 0 9
26612: PUSH
26613: LD_INT 1
26615: ARRAY
26616: ST_TO_ADDR
// if p then
26617: LD_VAR 0 11
26621: IFFALSE 26646
// result := Replace ( result , 4 , p ) ;
26623: LD_ADDR_VAR 0 2
26627: PUSH
26628: LD_VAR 0 2
26632: PPUSH
26633: LD_INT 4
26635: PPUSH
26636: LD_VAR 0 11
26640: PPUSH
26641: CALL_OW 1
26645: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26646: LD_ADDR_VAR 0 4
26650: PUSH
26651: LD_VAR 0 4
26655: PUSH
26656: LD_VAR 0 7
26660: DIFF
26661: ST_TO_ADDR
// if tmp and mech < 6 then
26662: LD_VAR 0 4
26666: PUSH
26667: LD_VAR 0 7
26671: PUSH
26672: LD_INT 6
26674: LESS
26675: AND
26676: IFFALSE 26864
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26678: LD_ADDR_VAR 0 9
26682: PUSH
26683: LD_VAR 0 4
26687: PUSH
26688: LD_VAR 0 8
26692: PUSH
26693: LD_VAR 0 7
26697: UNION
26698: DIFF
26699: PPUSH
26700: LD_INT 3
26702: PPUSH
26703: CALL 90486 0 2
26707: ST_TO_ADDR
// p := [ ] ;
26708: LD_ADDR_VAR 0 11
26712: PUSH
26713: EMPTY
26714: ST_TO_ADDR
// if sort then
26715: LD_VAR 0 9
26719: IFFALSE 26835
// for i = 1 to 6 - mech do
26721: LD_ADDR_VAR 0 3
26725: PUSH
26726: DOUBLE
26727: LD_INT 1
26729: DEC
26730: ST_TO_ADDR
26731: LD_INT 6
26733: PUSH
26734: LD_VAR 0 7
26738: MINUS
26739: PUSH
26740: FOR_TO
26741: IFFALSE 26833
// begin if i = sort then
26743: LD_VAR 0 3
26747: PUSH
26748: LD_VAR 0 9
26752: EQUAL
26753: IFFALSE 26757
// break ;
26755: GO 26833
// if GetClass ( i ) = 3 then
26757: LD_VAR 0 3
26761: PPUSH
26762: CALL_OW 257
26766: PUSH
26767: LD_INT 3
26769: EQUAL
26770: IFFALSE 26774
// continue ;
26772: GO 26740
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26774: LD_ADDR_VAR 0 11
26778: PUSH
26779: LD_VAR 0 11
26783: PPUSH
26784: LD_VAR 0 11
26788: PUSH
26789: LD_INT 1
26791: PLUS
26792: PPUSH
26793: LD_VAR 0 9
26797: PUSH
26798: LD_VAR 0 3
26802: ARRAY
26803: PPUSH
26804: CALL_OW 2
26808: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26809: LD_ADDR_VAR 0 4
26813: PUSH
26814: LD_VAR 0 4
26818: PUSH
26819: LD_VAR 0 9
26823: PUSH
26824: LD_VAR 0 3
26828: ARRAY
26829: DIFF
26830: ST_TO_ADDR
// end ;
26831: GO 26740
26833: POP
26834: POP
// if p then
26835: LD_VAR 0 11
26839: IFFALSE 26864
// result := Replace ( result , 3 , p ) ;
26841: LD_ADDR_VAR 0 2
26845: PUSH
26846: LD_VAR 0 2
26850: PPUSH
26851: LD_INT 3
26853: PPUSH
26854: LD_VAR 0 11
26858: PPUSH
26859: CALL_OW 1
26863: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26864: LD_ADDR_VAR 0 4
26868: PUSH
26869: LD_VAR 0 4
26873: PUSH
26874: LD_VAR 0 6
26878: DIFF
26879: ST_TO_ADDR
// if tmp and eng < 6 then
26880: LD_VAR 0 4
26884: PUSH
26885: LD_VAR 0 6
26889: PUSH
26890: LD_INT 6
26892: LESS
26893: AND
26894: IFFALSE 27088
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26896: LD_ADDR_VAR 0 9
26900: PUSH
26901: LD_VAR 0 4
26905: PUSH
26906: LD_VAR 0 8
26910: PUSH
26911: LD_VAR 0 7
26915: UNION
26916: PUSH
26917: LD_VAR 0 6
26921: UNION
26922: DIFF
26923: PPUSH
26924: LD_INT 2
26926: PPUSH
26927: CALL 90486 0 2
26931: ST_TO_ADDR
// p := [ ] ;
26932: LD_ADDR_VAR 0 11
26936: PUSH
26937: EMPTY
26938: ST_TO_ADDR
// if sort then
26939: LD_VAR 0 9
26943: IFFALSE 27059
// for i = 1 to 6 - eng do
26945: LD_ADDR_VAR 0 3
26949: PUSH
26950: DOUBLE
26951: LD_INT 1
26953: DEC
26954: ST_TO_ADDR
26955: LD_INT 6
26957: PUSH
26958: LD_VAR 0 6
26962: MINUS
26963: PUSH
26964: FOR_TO
26965: IFFALSE 27057
// begin if i = sort then
26967: LD_VAR 0 3
26971: PUSH
26972: LD_VAR 0 9
26976: EQUAL
26977: IFFALSE 26981
// break ;
26979: GO 27057
// if GetClass ( i ) = 2 then
26981: LD_VAR 0 3
26985: PPUSH
26986: CALL_OW 257
26990: PUSH
26991: LD_INT 2
26993: EQUAL
26994: IFFALSE 26998
// continue ;
26996: GO 26964
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26998: LD_ADDR_VAR 0 11
27002: PUSH
27003: LD_VAR 0 11
27007: PPUSH
27008: LD_VAR 0 11
27012: PUSH
27013: LD_INT 1
27015: PLUS
27016: PPUSH
27017: LD_VAR 0 9
27021: PUSH
27022: LD_VAR 0 3
27026: ARRAY
27027: PPUSH
27028: CALL_OW 2
27032: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27033: LD_ADDR_VAR 0 4
27037: PUSH
27038: LD_VAR 0 4
27042: PUSH
27043: LD_VAR 0 9
27047: PUSH
27048: LD_VAR 0 3
27052: ARRAY
27053: DIFF
27054: ST_TO_ADDR
// end ;
27055: GO 26964
27057: POP
27058: POP
// if p then
27059: LD_VAR 0 11
27063: IFFALSE 27088
// result := Replace ( result , 2 , p ) ;
27065: LD_ADDR_VAR 0 2
27069: PUSH
27070: LD_VAR 0 2
27074: PPUSH
27075: LD_INT 2
27077: PPUSH
27078: LD_VAR 0 11
27082: PPUSH
27083: CALL_OW 1
27087: ST_TO_ADDR
// end ; exit ;
27088: GO 27812
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27090: LD_EXP 101
27094: PUSH
27095: LD_EXP 100
27099: PUSH
27100: LD_VAR 0 1
27104: ARRAY
27105: ARRAY
27106: NOT
27107: PUSH
27108: LD_EXP 74
27112: PUSH
27113: LD_VAR 0 1
27117: ARRAY
27118: PPUSH
27119: LD_INT 30
27121: PUSH
27122: LD_INT 3
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PPUSH
27129: CALL_OW 72
27133: AND
27134: PUSH
27135: LD_EXP 79
27139: PUSH
27140: LD_VAR 0 1
27144: ARRAY
27145: NOT
27146: AND
27147: IFFALSE 27812
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
27149: LD_ADDR_EXP 116
27153: PUSH
27154: LD_EXP 116
27158: PPUSH
27159: LD_VAR 0 1
27163: PPUSH
27164: LD_INT 6
27166: PPUSH
27167: CALL_OW 1
27171: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27172: LD_ADDR_VAR 0 2
27176: PUSH
27177: LD_INT 0
27179: PUSH
27180: LD_INT 0
27182: PUSH
27183: LD_INT 0
27185: PUSH
27186: LD_INT 0
27188: PUSH
27189: EMPTY
27190: LIST
27191: LIST
27192: LIST
27193: LIST
27194: ST_TO_ADDR
// if sci >= 1 then
27195: LD_VAR 0 8
27199: PUSH
27200: LD_INT 1
27202: GREATEREQUAL
27203: IFFALSE 27225
// tmp := tmp diff sci [ 1 ] ;
27205: LD_ADDR_VAR 0 4
27209: PUSH
27210: LD_VAR 0 4
27214: PUSH
27215: LD_VAR 0 8
27219: PUSH
27220: LD_INT 1
27222: ARRAY
27223: DIFF
27224: ST_TO_ADDR
// if tmp and not sci then
27225: LD_VAR 0 4
27229: PUSH
27230: LD_VAR 0 8
27234: NOT
27235: AND
27236: IFFALSE 27305
// begin sort := SortBySkill ( tmp , 4 ) ;
27238: LD_ADDR_VAR 0 9
27242: PUSH
27243: LD_VAR 0 4
27247: PPUSH
27248: LD_INT 4
27250: PPUSH
27251: CALL 90486 0 2
27255: ST_TO_ADDR
// if sort then
27256: LD_VAR 0 9
27260: IFFALSE 27276
// p := sort [ 1 ] ;
27262: LD_ADDR_VAR 0 11
27266: PUSH
27267: LD_VAR 0 9
27271: PUSH
27272: LD_INT 1
27274: ARRAY
27275: ST_TO_ADDR
// if p then
27276: LD_VAR 0 11
27280: IFFALSE 27305
// result := Replace ( result , 4 , p ) ;
27282: LD_ADDR_VAR 0 2
27286: PUSH
27287: LD_VAR 0 2
27291: PPUSH
27292: LD_INT 4
27294: PPUSH
27295: LD_VAR 0 11
27299: PPUSH
27300: CALL_OW 1
27304: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27305: LD_ADDR_VAR 0 4
27309: PUSH
27310: LD_VAR 0 4
27314: PUSH
27315: LD_VAR 0 7
27319: DIFF
27320: ST_TO_ADDR
// if tmp and mech < 6 then
27321: LD_VAR 0 4
27325: PUSH
27326: LD_VAR 0 7
27330: PUSH
27331: LD_INT 6
27333: LESS
27334: AND
27335: IFFALSE 27517
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
27337: LD_ADDR_VAR 0 9
27341: PUSH
27342: LD_VAR 0 4
27346: PUSH
27347: LD_VAR 0 7
27351: DIFF
27352: PPUSH
27353: LD_INT 3
27355: PPUSH
27356: CALL 90486 0 2
27360: ST_TO_ADDR
// p := [ ] ;
27361: LD_ADDR_VAR 0 11
27365: PUSH
27366: EMPTY
27367: ST_TO_ADDR
// if sort then
27368: LD_VAR 0 9
27372: IFFALSE 27488
// for i = 1 to 6 - mech do
27374: LD_ADDR_VAR 0 3
27378: PUSH
27379: DOUBLE
27380: LD_INT 1
27382: DEC
27383: ST_TO_ADDR
27384: LD_INT 6
27386: PUSH
27387: LD_VAR 0 7
27391: MINUS
27392: PUSH
27393: FOR_TO
27394: IFFALSE 27486
// begin if i = sort then
27396: LD_VAR 0 3
27400: PUSH
27401: LD_VAR 0 9
27405: EQUAL
27406: IFFALSE 27410
// break ;
27408: GO 27486
// if GetClass ( i ) = 3 then
27410: LD_VAR 0 3
27414: PPUSH
27415: CALL_OW 257
27419: PUSH
27420: LD_INT 3
27422: EQUAL
27423: IFFALSE 27427
// continue ;
27425: GO 27393
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27427: LD_ADDR_VAR 0 11
27431: PUSH
27432: LD_VAR 0 11
27436: PPUSH
27437: LD_VAR 0 11
27441: PUSH
27442: LD_INT 1
27444: PLUS
27445: PPUSH
27446: LD_VAR 0 9
27450: PUSH
27451: LD_VAR 0 3
27455: ARRAY
27456: PPUSH
27457: CALL_OW 2
27461: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27462: LD_ADDR_VAR 0 4
27466: PUSH
27467: LD_VAR 0 4
27471: PUSH
27472: LD_VAR 0 9
27476: PUSH
27477: LD_VAR 0 3
27481: ARRAY
27482: DIFF
27483: ST_TO_ADDR
// end ;
27484: GO 27393
27486: POP
27487: POP
// if p then
27488: LD_VAR 0 11
27492: IFFALSE 27517
// result := Replace ( result , 3 , p ) ;
27494: LD_ADDR_VAR 0 2
27498: PUSH
27499: LD_VAR 0 2
27503: PPUSH
27504: LD_INT 3
27506: PPUSH
27507: LD_VAR 0 11
27511: PPUSH
27512: CALL_OW 1
27516: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27517: LD_ADDR_VAR 0 4
27521: PUSH
27522: LD_VAR 0 4
27526: PUSH
27527: LD_VAR 0 6
27531: DIFF
27532: ST_TO_ADDR
// if tmp and eng < 4 then
27533: LD_VAR 0 4
27537: PUSH
27538: LD_VAR 0 6
27542: PUSH
27543: LD_INT 4
27545: LESS
27546: AND
27547: IFFALSE 27737
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
27549: LD_ADDR_VAR 0 9
27553: PUSH
27554: LD_VAR 0 4
27558: PUSH
27559: LD_VAR 0 7
27563: PUSH
27564: LD_VAR 0 6
27568: UNION
27569: DIFF
27570: PPUSH
27571: LD_INT 2
27573: PPUSH
27574: CALL 90486 0 2
27578: ST_TO_ADDR
// p := [ ] ;
27579: LD_ADDR_VAR 0 11
27583: PUSH
27584: EMPTY
27585: ST_TO_ADDR
// if sort then
27586: LD_VAR 0 9
27590: IFFALSE 27706
// for i = 1 to 4 - eng do
27592: LD_ADDR_VAR 0 3
27596: PUSH
27597: DOUBLE
27598: LD_INT 1
27600: DEC
27601: ST_TO_ADDR
27602: LD_INT 4
27604: PUSH
27605: LD_VAR 0 6
27609: MINUS
27610: PUSH
27611: FOR_TO
27612: IFFALSE 27704
// begin if i = sort then
27614: LD_VAR 0 3
27618: PUSH
27619: LD_VAR 0 9
27623: EQUAL
27624: IFFALSE 27628
// break ;
27626: GO 27704
// if GetClass ( i ) = 2 then
27628: LD_VAR 0 3
27632: PPUSH
27633: CALL_OW 257
27637: PUSH
27638: LD_INT 2
27640: EQUAL
27641: IFFALSE 27645
// continue ;
27643: GO 27611
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27645: LD_ADDR_VAR 0 11
27649: PUSH
27650: LD_VAR 0 11
27654: PPUSH
27655: LD_VAR 0 11
27659: PUSH
27660: LD_INT 1
27662: PLUS
27663: PPUSH
27664: LD_VAR 0 9
27668: PUSH
27669: LD_VAR 0 3
27673: ARRAY
27674: PPUSH
27675: CALL_OW 2
27679: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27680: LD_ADDR_VAR 0 4
27684: PUSH
27685: LD_VAR 0 4
27689: PUSH
27690: LD_VAR 0 9
27694: PUSH
27695: LD_VAR 0 3
27699: ARRAY
27700: DIFF
27701: ST_TO_ADDR
// end ;
27702: GO 27611
27704: POP
27705: POP
// if p then
27706: LD_VAR 0 11
27710: IFFALSE 27735
// result := Replace ( result , 2 , p ) ;
27712: LD_ADDR_VAR 0 2
27716: PUSH
27717: LD_VAR 0 2
27721: PPUSH
27722: LD_INT 2
27724: PPUSH
27725: LD_VAR 0 11
27729: PPUSH
27730: CALL_OW 1
27734: ST_TO_ADDR
// end else
27735: GO 27781
// for i = eng downto 5 do
27737: LD_ADDR_VAR 0 3
27741: PUSH
27742: DOUBLE
27743: LD_VAR 0 6
27747: INC
27748: ST_TO_ADDR
27749: LD_INT 5
27751: PUSH
27752: FOR_DOWNTO
27753: IFFALSE 27779
// tmp := tmp union eng [ i ] ;
27755: LD_ADDR_VAR 0 4
27759: PUSH
27760: LD_VAR 0 4
27764: PUSH
27765: LD_VAR 0 6
27769: PUSH
27770: LD_VAR 0 3
27774: ARRAY
27775: UNION
27776: ST_TO_ADDR
27777: GO 27752
27779: POP
27780: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
27781: LD_ADDR_VAR 0 2
27785: PUSH
27786: LD_VAR 0 2
27790: PPUSH
27791: LD_INT 1
27793: PPUSH
27794: LD_VAR 0 4
27798: PUSH
27799: LD_VAR 0 5
27803: DIFF
27804: PPUSH
27805: CALL_OW 1
27809: ST_TO_ADDR
// exit ;
27810: GO 27812
// end ; end ;
27812: LD_VAR 0 2
27816: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
27817: LD_INT 0
27819: PPUSH
27820: PPUSH
27821: PPUSH
// if not mc_bases then
27822: LD_EXP 74
27826: NOT
27827: IFFALSE 27831
// exit ;
27829: GO 27937
// for i = 1 to mc_bases do
27831: LD_ADDR_VAR 0 2
27835: PUSH
27836: DOUBLE
27837: LD_INT 1
27839: DEC
27840: ST_TO_ADDR
27841: LD_EXP 74
27845: PUSH
27846: FOR_TO
27847: IFFALSE 27928
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
27849: LD_ADDR_VAR 0 3
27853: PUSH
27854: LD_EXP 74
27858: PUSH
27859: LD_VAR 0 2
27863: ARRAY
27864: PPUSH
27865: LD_INT 21
27867: PUSH
27868: LD_INT 3
27870: PUSH
27871: EMPTY
27872: LIST
27873: LIST
27874: PUSH
27875: LD_INT 3
27877: PUSH
27878: LD_INT 24
27880: PUSH
27881: LD_INT 1000
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PPUSH
27896: CALL_OW 72
27900: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
27901: LD_ADDR_EXP 75
27905: PUSH
27906: LD_EXP 75
27910: PPUSH
27911: LD_VAR 0 2
27915: PPUSH
27916: LD_VAR 0 3
27920: PPUSH
27921: CALL_OW 1
27925: ST_TO_ADDR
// end ;
27926: GO 27846
27928: POP
27929: POP
// RaiseSailEvent ( 101 ) ;
27930: LD_INT 101
27932: PPUSH
27933: CALL_OW 427
// end ;
27937: LD_VAR 0 1
27941: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
27942: LD_INT 0
27944: PPUSH
27945: PPUSH
27946: PPUSH
27947: PPUSH
27948: PPUSH
27949: PPUSH
27950: PPUSH
// if not mc_bases then
27951: LD_EXP 74
27955: NOT
27956: IFFALSE 27960
// exit ;
27958: GO 28533
// for i = 1 to mc_bases do
27960: LD_ADDR_VAR 0 2
27964: PUSH
27965: DOUBLE
27966: LD_INT 1
27968: DEC
27969: ST_TO_ADDR
27970: LD_EXP 74
27974: PUSH
27975: FOR_TO
27976: IFFALSE 28524
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
27978: LD_ADDR_VAR 0 5
27982: PUSH
27983: LD_EXP 74
27987: PUSH
27988: LD_VAR 0 2
27992: ARRAY
27993: PUSH
27994: LD_EXP 103
27998: PUSH
27999: LD_VAR 0 2
28003: ARRAY
28004: UNION
28005: PPUSH
28006: LD_INT 21
28008: PUSH
28009: LD_INT 1
28011: PUSH
28012: EMPTY
28013: LIST
28014: LIST
28015: PUSH
28016: LD_INT 1
28018: PUSH
28019: LD_INT 3
28021: PUSH
28022: LD_INT 54
28024: PUSH
28025: EMPTY
28026: LIST
28027: PUSH
28028: EMPTY
28029: LIST
28030: LIST
28031: PUSH
28032: LD_INT 3
28034: PUSH
28035: LD_INT 24
28037: PUSH
28038: LD_INT 800
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: EMPTY
28046: LIST
28047: LIST
28048: PUSH
28049: EMPTY
28050: LIST
28051: LIST
28052: LIST
28053: PUSH
28054: EMPTY
28055: LIST
28056: LIST
28057: PPUSH
28058: CALL_OW 72
28062: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28063: LD_ADDR_VAR 0 6
28067: PUSH
28068: LD_EXP 74
28072: PUSH
28073: LD_VAR 0 2
28077: ARRAY
28078: PPUSH
28079: LD_INT 21
28081: PUSH
28082: LD_INT 1
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: LD_INT 1
28091: PUSH
28092: LD_INT 3
28094: PUSH
28095: LD_INT 54
28097: PUSH
28098: EMPTY
28099: LIST
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PUSH
28105: LD_INT 3
28107: PUSH
28108: LD_INT 24
28110: PUSH
28111: LD_INT 250
28113: PUSH
28114: EMPTY
28115: LIST
28116: LIST
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: LIST
28126: PUSH
28127: EMPTY
28128: LIST
28129: LIST
28130: PPUSH
28131: CALL_OW 72
28135: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
28136: LD_ADDR_VAR 0 7
28140: PUSH
28141: LD_VAR 0 5
28145: PUSH
28146: LD_VAR 0 6
28150: DIFF
28151: ST_TO_ADDR
// if not need_heal_1 then
28152: LD_VAR 0 6
28156: NOT
28157: IFFALSE 28190
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
28159: LD_ADDR_EXP 77
28163: PUSH
28164: LD_EXP 77
28168: PPUSH
28169: LD_VAR 0 2
28173: PUSH
28174: LD_INT 1
28176: PUSH
28177: EMPTY
28178: LIST
28179: LIST
28180: PPUSH
28181: EMPTY
28182: PPUSH
28183: CALL 56238 0 3
28187: ST_TO_ADDR
28188: GO 28260
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
28190: LD_ADDR_EXP 77
28194: PUSH
28195: LD_EXP 77
28199: PPUSH
28200: LD_VAR 0 2
28204: PUSH
28205: LD_INT 1
28207: PUSH
28208: EMPTY
28209: LIST
28210: LIST
28211: PPUSH
28212: LD_EXP 77
28216: PUSH
28217: LD_VAR 0 2
28221: ARRAY
28222: PUSH
28223: LD_INT 1
28225: ARRAY
28226: PPUSH
28227: LD_INT 3
28229: PUSH
28230: LD_INT 24
28232: PUSH
28233: LD_INT 1000
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PUSH
28240: EMPTY
28241: LIST
28242: LIST
28243: PPUSH
28244: CALL_OW 72
28248: PUSH
28249: LD_VAR 0 6
28253: UNION
28254: PPUSH
28255: CALL 56238 0 3
28259: ST_TO_ADDR
// if not need_heal_2 then
28260: LD_VAR 0 7
28264: NOT
28265: IFFALSE 28298
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
28267: LD_ADDR_EXP 77
28271: PUSH
28272: LD_EXP 77
28276: PPUSH
28277: LD_VAR 0 2
28281: PUSH
28282: LD_INT 2
28284: PUSH
28285: EMPTY
28286: LIST
28287: LIST
28288: PPUSH
28289: EMPTY
28290: PPUSH
28291: CALL 56238 0 3
28295: ST_TO_ADDR
28296: GO 28330
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
28298: LD_ADDR_EXP 77
28302: PUSH
28303: LD_EXP 77
28307: PPUSH
28308: LD_VAR 0 2
28312: PUSH
28313: LD_INT 2
28315: PUSH
28316: EMPTY
28317: LIST
28318: LIST
28319: PPUSH
28320: LD_VAR 0 7
28324: PPUSH
28325: CALL 56238 0 3
28329: ST_TO_ADDR
// if need_heal_2 then
28330: LD_VAR 0 7
28334: IFFALSE 28506
// for j in need_heal_2 do
28336: LD_ADDR_VAR 0 3
28340: PUSH
28341: LD_VAR 0 7
28345: PUSH
28346: FOR_IN
28347: IFFALSE 28504
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
28349: LD_ADDR_VAR 0 5
28353: PUSH
28354: LD_EXP 74
28358: PUSH
28359: LD_VAR 0 2
28363: ARRAY
28364: PPUSH
28365: LD_INT 2
28367: PUSH
28368: LD_INT 30
28370: PUSH
28371: LD_INT 6
28373: PUSH
28374: EMPTY
28375: LIST
28376: LIST
28377: PUSH
28378: LD_INT 30
28380: PUSH
28381: LD_INT 7
28383: PUSH
28384: EMPTY
28385: LIST
28386: LIST
28387: PUSH
28388: LD_INT 30
28390: PUSH
28391: LD_INT 8
28393: PUSH
28394: EMPTY
28395: LIST
28396: LIST
28397: PUSH
28398: LD_INT 30
28400: PUSH
28401: LD_INT 0
28403: PUSH
28404: EMPTY
28405: LIST
28406: LIST
28407: PUSH
28408: LD_INT 30
28410: PUSH
28411: LD_INT 1
28413: PUSH
28414: EMPTY
28415: LIST
28416: LIST
28417: PUSH
28418: LD_INT 25
28420: PUSH
28421: LD_INT 4
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: LIST
28432: LIST
28433: LIST
28434: LIST
28435: LIST
28436: PPUSH
28437: CALL_OW 72
28441: ST_TO_ADDR
// if tmp then
28442: LD_VAR 0 5
28446: IFFALSE 28502
// begin k := NearestUnitToUnit ( tmp , j ) ;
28448: LD_ADDR_VAR 0 4
28452: PUSH
28453: LD_VAR 0 5
28457: PPUSH
28458: LD_VAR 0 3
28462: PPUSH
28463: CALL_OW 74
28467: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
28468: LD_VAR 0 3
28472: PPUSH
28473: LD_VAR 0 4
28477: PPUSH
28478: CALL_OW 296
28482: PUSH
28483: LD_INT 7
28485: GREATER
28486: IFFALSE 28502
// ComMoveUnit ( j , k ) ;
28488: LD_VAR 0 3
28492: PPUSH
28493: LD_VAR 0 4
28497: PPUSH
28498: CALL_OW 112
// end ; end ;
28502: GO 28346
28504: POP
28505: POP
// if not need_heal_1 and not need_heal_2 then
28506: LD_VAR 0 6
28510: NOT
28511: PUSH
28512: LD_VAR 0 7
28516: NOT
28517: AND
28518: IFFALSE 28522
// continue ;
28520: GO 27975
// end ;
28522: GO 27975
28524: POP
28525: POP
// RaiseSailEvent ( 102 ) ;
28526: LD_INT 102
28528: PPUSH
28529: CALL_OW 427
// end ;
28533: LD_VAR 0 1
28537: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
28538: LD_INT 0
28540: PPUSH
28541: PPUSH
28542: PPUSH
28543: PPUSH
28544: PPUSH
28545: PPUSH
// if not mc_bases then
28546: LD_EXP 74
28550: NOT
28551: IFFALSE 28555
// exit ;
28553: GO 29265
// for i = 1 to mc_bases do
28555: LD_ADDR_VAR 0 2
28559: PUSH
28560: DOUBLE
28561: LD_INT 1
28563: DEC
28564: ST_TO_ADDR
28565: LD_EXP 74
28569: PUSH
28570: FOR_TO
28571: IFFALSE 29263
// begin if not mc_building_need_repair [ i ] then
28573: LD_EXP 75
28577: PUSH
28578: LD_VAR 0 2
28582: ARRAY
28583: NOT
28584: IFFALSE 28758
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
28586: LD_ADDR_VAR 0 6
28590: PUSH
28591: LD_EXP 93
28595: PUSH
28596: LD_VAR 0 2
28600: ARRAY
28601: PPUSH
28602: LD_INT 3
28604: PUSH
28605: LD_INT 24
28607: PUSH
28608: LD_INT 1000
28610: PUSH
28611: EMPTY
28612: LIST
28613: LIST
28614: PUSH
28615: EMPTY
28616: LIST
28617: LIST
28618: PUSH
28619: LD_INT 2
28621: PUSH
28622: LD_INT 34
28624: PUSH
28625: LD_INT 13
28627: PUSH
28628: EMPTY
28629: LIST
28630: LIST
28631: PUSH
28632: LD_INT 34
28634: PUSH
28635: LD_INT 52
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: LIST
28646: PUSH
28647: EMPTY
28648: LIST
28649: LIST
28650: PPUSH
28651: CALL_OW 72
28655: ST_TO_ADDR
// if cranes then
28656: LD_VAR 0 6
28660: IFFALSE 28722
// for j in cranes do
28662: LD_ADDR_VAR 0 3
28666: PUSH
28667: LD_VAR 0 6
28671: PUSH
28672: FOR_IN
28673: IFFALSE 28720
// if not IsInArea ( j , mc_parking [ i ] ) then
28675: LD_VAR 0 3
28679: PPUSH
28680: LD_EXP 98
28684: PUSH
28685: LD_VAR 0 2
28689: ARRAY
28690: PPUSH
28691: CALL_OW 308
28695: NOT
28696: IFFALSE 28718
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28698: LD_VAR 0 3
28702: PPUSH
28703: LD_EXP 98
28707: PUSH
28708: LD_VAR 0 2
28712: ARRAY
28713: PPUSH
28714: CALL_OW 113
28718: GO 28672
28720: POP
28721: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
28722: LD_ADDR_EXP 76
28726: PUSH
28727: LD_EXP 76
28731: PPUSH
28732: LD_VAR 0 2
28736: PPUSH
28737: EMPTY
28738: PPUSH
28739: CALL_OW 1
28743: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
28744: LD_VAR 0 2
28748: PPUSH
28749: LD_INT 101
28751: PPUSH
28752: CALL 23650 0 2
// continue ;
28756: GO 28570
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
28758: LD_ADDR_EXP 80
28762: PUSH
28763: LD_EXP 80
28767: PPUSH
28768: LD_VAR 0 2
28772: PPUSH
28773: EMPTY
28774: PPUSH
28775: CALL_OW 1
28779: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28780: LD_VAR 0 2
28784: PPUSH
28785: LD_INT 103
28787: PPUSH
28788: CALL 23650 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
28792: LD_ADDR_VAR 0 5
28796: PUSH
28797: LD_EXP 74
28801: PUSH
28802: LD_VAR 0 2
28806: ARRAY
28807: PUSH
28808: LD_EXP 103
28812: PUSH
28813: LD_VAR 0 2
28817: ARRAY
28818: UNION
28819: PPUSH
28820: LD_INT 2
28822: PUSH
28823: LD_INT 25
28825: PUSH
28826: LD_INT 2
28828: PUSH
28829: EMPTY
28830: LIST
28831: LIST
28832: PUSH
28833: LD_INT 25
28835: PUSH
28836: LD_INT 16
28838: PUSH
28839: EMPTY
28840: LIST
28841: LIST
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: LIST
28847: PUSH
28848: EMPTY
28849: LIST
28850: PPUSH
28851: CALL_OW 72
28855: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
28856: LD_ADDR_VAR 0 6
28860: PUSH
28861: LD_EXP 93
28865: PUSH
28866: LD_VAR 0 2
28870: ARRAY
28871: PPUSH
28872: LD_INT 2
28874: PUSH
28875: LD_INT 34
28877: PUSH
28878: LD_INT 13
28880: PUSH
28881: EMPTY
28882: LIST
28883: LIST
28884: PUSH
28885: LD_INT 34
28887: PUSH
28888: LD_INT 52
28890: PUSH
28891: EMPTY
28892: LIST
28893: LIST
28894: PUSH
28895: EMPTY
28896: LIST
28897: LIST
28898: LIST
28899: PPUSH
28900: CALL_OW 72
28904: ST_TO_ADDR
// if cranes then
28905: LD_VAR 0 6
28909: IFFALSE 29045
// begin for j in cranes do
28911: LD_ADDR_VAR 0 3
28915: PUSH
28916: LD_VAR 0 6
28920: PUSH
28921: FOR_IN
28922: IFFALSE 29043
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
28924: LD_VAR 0 3
28928: PPUSH
28929: CALL_OW 256
28933: PUSH
28934: LD_INT 500
28936: GREATEREQUAL
28937: PUSH
28938: LD_VAR 0 3
28942: PPUSH
28943: CALL_OW 314
28947: NOT
28948: AND
28949: IFFALSE 28983
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
28951: LD_VAR 0 3
28955: PPUSH
28956: LD_EXP 75
28960: PUSH
28961: LD_VAR 0 2
28965: ARRAY
28966: PPUSH
28967: LD_VAR 0 3
28971: PPUSH
28972: CALL_OW 74
28976: PPUSH
28977: CALL_OW 130
28981: GO 29041
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28983: LD_VAR 0 3
28987: PPUSH
28988: CALL_OW 256
28992: PUSH
28993: LD_INT 500
28995: LESS
28996: PUSH
28997: LD_VAR 0 3
29001: PPUSH
29002: LD_EXP 98
29006: PUSH
29007: LD_VAR 0 2
29011: ARRAY
29012: PPUSH
29013: CALL_OW 308
29017: NOT
29018: AND
29019: IFFALSE 29041
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29021: LD_VAR 0 3
29025: PPUSH
29026: LD_EXP 98
29030: PUSH
29031: LD_VAR 0 2
29035: ARRAY
29036: PPUSH
29037: CALL_OW 113
29041: GO 28921
29043: POP
29044: POP
// end ; if not tmp then
29045: LD_VAR 0 5
29049: NOT
29050: IFFALSE 29054
// continue ;
29052: GO 28570
// for j in tmp do
29054: LD_ADDR_VAR 0 3
29058: PUSH
29059: LD_VAR 0 5
29063: PUSH
29064: FOR_IN
29065: IFFALSE 29259
// begin if mc_need_heal [ i ] then
29067: LD_EXP 77
29071: PUSH
29072: LD_VAR 0 2
29076: ARRAY
29077: IFFALSE 29125
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29079: LD_VAR 0 3
29083: PUSH
29084: LD_EXP 77
29088: PUSH
29089: LD_VAR 0 2
29093: ARRAY
29094: PUSH
29095: LD_INT 1
29097: ARRAY
29098: IN
29099: PUSH
29100: LD_VAR 0 3
29104: PUSH
29105: LD_EXP 77
29109: PUSH
29110: LD_VAR 0 2
29114: ARRAY
29115: PUSH
29116: LD_INT 2
29118: ARRAY
29119: IN
29120: OR
29121: IFFALSE 29125
// continue ;
29123: GO 29064
// if IsInUnit ( j ) then
29125: LD_VAR 0 3
29129: PPUSH
29130: CALL_OW 310
29134: IFFALSE 29145
// ComExitBuilding ( j ) ;
29136: LD_VAR 0 3
29140: PPUSH
29141: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
29145: LD_VAR 0 3
29149: PUSH
29150: LD_EXP 76
29154: PUSH
29155: LD_VAR 0 2
29159: ARRAY
29160: IN
29161: NOT
29162: IFFALSE 29220
// begin SetTag ( j , 101 ) ;
29164: LD_VAR 0 3
29168: PPUSH
29169: LD_INT 101
29171: PPUSH
29172: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
29176: LD_ADDR_EXP 76
29180: PUSH
29181: LD_EXP 76
29185: PPUSH
29186: LD_VAR 0 2
29190: PUSH
29191: LD_EXP 76
29195: PUSH
29196: LD_VAR 0 2
29200: ARRAY
29201: PUSH
29202: LD_INT 1
29204: PLUS
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PPUSH
29210: LD_VAR 0 3
29214: PPUSH
29215: CALL 56238 0 3
29219: ST_TO_ADDR
// end ; wait ( 1 ) ;
29220: LD_INT 1
29222: PPUSH
29223: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
29227: LD_VAR 0 3
29231: PPUSH
29232: LD_EXP 75
29236: PUSH
29237: LD_VAR 0 2
29241: ARRAY
29242: PPUSH
29243: LD_VAR 0 3
29247: PPUSH
29248: CALL_OW 74
29252: PPUSH
29253: CALL_OW 130
// end ;
29257: GO 29064
29259: POP
29260: POP
// end ;
29261: GO 28570
29263: POP
29264: POP
// end ;
29265: LD_VAR 0 1
29269: RET
// export function MC_Heal ; var i , j , tmp ; begin
29270: LD_INT 0
29272: PPUSH
29273: PPUSH
29274: PPUSH
29275: PPUSH
// if not mc_bases then
29276: LD_EXP 74
29280: NOT
29281: IFFALSE 29285
// exit ;
29283: GO 29687
// for i = 1 to mc_bases do
29285: LD_ADDR_VAR 0 2
29289: PUSH
29290: DOUBLE
29291: LD_INT 1
29293: DEC
29294: ST_TO_ADDR
29295: LD_EXP 74
29299: PUSH
29300: FOR_TO
29301: IFFALSE 29685
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
29303: LD_EXP 77
29307: PUSH
29308: LD_VAR 0 2
29312: ARRAY
29313: PUSH
29314: LD_INT 1
29316: ARRAY
29317: NOT
29318: PUSH
29319: LD_EXP 77
29323: PUSH
29324: LD_VAR 0 2
29328: ARRAY
29329: PUSH
29330: LD_INT 2
29332: ARRAY
29333: NOT
29334: AND
29335: IFFALSE 29373
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
29337: LD_ADDR_EXP 78
29341: PUSH
29342: LD_EXP 78
29346: PPUSH
29347: LD_VAR 0 2
29351: PPUSH
29352: EMPTY
29353: PPUSH
29354: CALL_OW 1
29358: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
29359: LD_VAR 0 2
29363: PPUSH
29364: LD_INT 102
29366: PPUSH
29367: CALL 23650 0 2
// continue ;
29371: GO 29300
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
29373: LD_ADDR_VAR 0 4
29377: PUSH
29378: LD_EXP 74
29382: PUSH
29383: LD_VAR 0 2
29387: ARRAY
29388: PPUSH
29389: LD_INT 25
29391: PUSH
29392: LD_INT 4
29394: PUSH
29395: EMPTY
29396: LIST
29397: LIST
29398: PPUSH
29399: CALL_OW 72
29403: ST_TO_ADDR
// if not tmp then
29404: LD_VAR 0 4
29408: NOT
29409: IFFALSE 29413
// continue ;
29411: GO 29300
// if mc_taming [ i ] then
29413: LD_EXP 105
29417: PUSH
29418: LD_VAR 0 2
29422: ARRAY
29423: IFFALSE 29447
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
29425: LD_ADDR_EXP 105
29429: PUSH
29430: LD_EXP 105
29434: PPUSH
29435: LD_VAR 0 2
29439: PPUSH
29440: EMPTY
29441: PPUSH
29442: CALL_OW 1
29446: ST_TO_ADDR
// for j in tmp do
29447: LD_ADDR_VAR 0 3
29451: PUSH
29452: LD_VAR 0 4
29456: PUSH
29457: FOR_IN
29458: IFFALSE 29681
// begin if IsInUnit ( j ) then
29460: LD_VAR 0 3
29464: PPUSH
29465: CALL_OW 310
29469: IFFALSE 29480
// ComExitBuilding ( j ) ;
29471: LD_VAR 0 3
29475: PPUSH
29476: CALL_OW 122
// if not j in mc_healers [ i ] then
29480: LD_VAR 0 3
29484: PUSH
29485: LD_EXP 78
29489: PUSH
29490: LD_VAR 0 2
29494: ARRAY
29495: IN
29496: NOT
29497: IFFALSE 29543
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
29499: LD_ADDR_EXP 78
29503: PUSH
29504: LD_EXP 78
29508: PPUSH
29509: LD_VAR 0 2
29513: PUSH
29514: LD_EXP 78
29518: PUSH
29519: LD_VAR 0 2
29523: ARRAY
29524: PUSH
29525: LD_INT 1
29527: PLUS
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PPUSH
29533: LD_VAR 0 3
29537: PPUSH
29538: CALL 56238 0 3
29542: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
29543: LD_VAR 0 3
29547: PPUSH
29548: CALL_OW 110
29552: PUSH
29553: LD_INT 102
29555: NONEQUAL
29556: IFFALSE 29570
// SetTag ( j , 102 ) ;
29558: LD_VAR 0 3
29562: PPUSH
29563: LD_INT 102
29565: PPUSH
29566: CALL_OW 109
// Wait ( 3 ) ;
29570: LD_INT 3
29572: PPUSH
29573: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
29577: LD_EXP 77
29581: PUSH
29582: LD_VAR 0 2
29586: ARRAY
29587: PUSH
29588: LD_INT 1
29590: ARRAY
29591: IFFALSE 29623
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
29593: LD_VAR 0 3
29597: PPUSH
29598: LD_EXP 77
29602: PUSH
29603: LD_VAR 0 2
29607: ARRAY
29608: PUSH
29609: LD_INT 1
29611: ARRAY
29612: PUSH
29613: LD_INT 1
29615: ARRAY
29616: PPUSH
29617: CALL_OW 128
29621: GO 29679
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
29623: LD_VAR 0 3
29627: PPUSH
29628: CALL_OW 314
29632: NOT
29633: PUSH
29634: LD_EXP 77
29638: PUSH
29639: LD_VAR 0 2
29643: ARRAY
29644: PUSH
29645: LD_INT 2
29647: ARRAY
29648: AND
29649: IFFALSE 29679
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
29651: LD_VAR 0 3
29655: PPUSH
29656: LD_EXP 77
29660: PUSH
29661: LD_VAR 0 2
29665: ARRAY
29666: PUSH
29667: LD_INT 2
29669: ARRAY
29670: PUSH
29671: LD_INT 1
29673: ARRAY
29674: PPUSH
29675: CALL_OW 128
// end ;
29679: GO 29457
29681: POP
29682: POP
// end ;
29683: GO 29300
29685: POP
29686: POP
// end ;
29687: LD_VAR 0 1
29691: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
29692: LD_INT 0
29694: PPUSH
29695: PPUSH
29696: PPUSH
29697: PPUSH
29698: PPUSH
// if not mc_bases then
29699: LD_EXP 74
29703: NOT
29704: IFFALSE 29708
// exit ;
29706: GO 30851
// for i = 1 to mc_bases do
29708: LD_ADDR_VAR 0 2
29712: PUSH
29713: DOUBLE
29714: LD_INT 1
29716: DEC
29717: ST_TO_ADDR
29718: LD_EXP 74
29722: PUSH
29723: FOR_TO
29724: IFFALSE 30849
// begin if mc_scan [ i ] then
29726: LD_EXP 97
29730: PUSH
29731: LD_VAR 0 2
29735: ARRAY
29736: IFFALSE 29740
// continue ;
29738: GO 29723
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
29740: LD_EXP 79
29744: PUSH
29745: LD_VAR 0 2
29749: ARRAY
29750: NOT
29751: PUSH
29752: LD_EXP 81
29756: PUSH
29757: LD_VAR 0 2
29761: ARRAY
29762: NOT
29763: AND
29764: PUSH
29765: LD_EXP 80
29769: PUSH
29770: LD_VAR 0 2
29774: ARRAY
29775: AND
29776: IFFALSE 29814
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
29778: LD_ADDR_EXP 80
29782: PUSH
29783: LD_EXP 80
29787: PPUSH
29788: LD_VAR 0 2
29792: PPUSH
29793: EMPTY
29794: PPUSH
29795: CALL_OW 1
29799: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29800: LD_VAR 0 2
29804: PPUSH
29805: LD_INT 103
29807: PPUSH
29808: CALL 23650 0 2
// continue ;
29812: GO 29723
// end ; if mc_construct_list [ i ] then
29814: LD_EXP 81
29818: PUSH
29819: LD_VAR 0 2
29823: ARRAY
29824: IFFALSE 30044
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29826: LD_ADDR_VAR 0 4
29830: PUSH
29831: LD_EXP 74
29835: PUSH
29836: LD_VAR 0 2
29840: ARRAY
29841: PPUSH
29842: LD_INT 25
29844: PUSH
29845: LD_INT 2
29847: PUSH
29848: EMPTY
29849: LIST
29850: LIST
29851: PPUSH
29852: CALL_OW 72
29856: PUSH
29857: LD_EXP 76
29861: PUSH
29862: LD_VAR 0 2
29866: ARRAY
29867: DIFF
29868: ST_TO_ADDR
// if not tmp then
29869: LD_VAR 0 4
29873: NOT
29874: IFFALSE 29878
// continue ;
29876: GO 29723
// for j in tmp do
29878: LD_ADDR_VAR 0 3
29882: PUSH
29883: LD_VAR 0 4
29887: PUSH
29888: FOR_IN
29889: IFFALSE 30040
// begin if not mc_builders [ i ] then
29891: LD_EXP 80
29895: PUSH
29896: LD_VAR 0 2
29900: ARRAY
29901: NOT
29902: IFFALSE 29960
// begin SetTag ( j , 103 ) ;
29904: LD_VAR 0 3
29908: PPUSH
29909: LD_INT 103
29911: PPUSH
29912: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29916: LD_ADDR_EXP 80
29920: PUSH
29921: LD_EXP 80
29925: PPUSH
29926: LD_VAR 0 2
29930: PUSH
29931: LD_EXP 80
29935: PUSH
29936: LD_VAR 0 2
29940: ARRAY
29941: PUSH
29942: LD_INT 1
29944: PLUS
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PPUSH
29950: LD_VAR 0 3
29954: PPUSH
29955: CALL 56238 0 3
29959: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29960: LD_VAR 0 3
29964: PPUSH
29965: CALL_OW 310
29969: IFFALSE 29980
// ComExitBuilding ( j ) ;
29971: LD_VAR 0 3
29975: PPUSH
29976: CALL_OW 122
// wait ( 3 ) ;
29980: LD_INT 3
29982: PPUSH
29983: CALL_OW 67
// if not mc_construct_list [ i ] then
29987: LD_EXP 81
29991: PUSH
29992: LD_VAR 0 2
29996: ARRAY
29997: NOT
29998: IFFALSE 30002
// break ;
30000: GO 30040
// if not HasTask ( j ) then
30002: LD_VAR 0 3
30006: PPUSH
30007: CALL_OW 314
30011: NOT
30012: IFFALSE 30038
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
30014: LD_VAR 0 3
30018: PPUSH
30019: LD_EXP 81
30023: PUSH
30024: LD_VAR 0 2
30028: ARRAY
30029: PUSH
30030: LD_INT 1
30032: ARRAY
30033: PPUSH
30034: CALL 59089 0 2
// end ;
30038: GO 29888
30040: POP
30041: POP
// end else
30042: GO 30847
// if mc_build_list [ i ] then
30044: LD_EXP 79
30048: PUSH
30049: LD_VAR 0 2
30053: ARRAY
30054: IFFALSE 30847
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30056: LD_ADDR_VAR 0 5
30060: PUSH
30061: LD_EXP 74
30065: PUSH
30066: LD_VAR 0 2
30070: ARRAY
30071: PPUSH
30072: LD_INT 2
30074: PUSH
30075: LD_INT 30
30077: PUSH
30078: LD_INT 0
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: LD_INT 30
30087: PUSH
30088: LD_INT 1
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: LIST
30099: PPUSH
30100: CALL_OW 72
30104: ST_TO_ADDR
// if depot then
30105: LD_VAR 0 5
30109: IFFALSE 30127
// depot := depot [ 1 ] else
30111: LD_ADDR_VAR 0 5
30115: PUSH
30116: LD_VAR 0 5
30120: PUSH
30121: LD_INT 1
30123: ARRAY
30124: ST_TO_ADDR
30125: GO 30135
// depot := 0 ;
30127: LD_ADDR_VAR 0 5
30131: PUSH
30132: LD_INT 0
30134: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
30135: LD_EXP 79
30139: PUSH
30140: LD_VAR 0 2
30144: ARRAY
30145: PUSH
30146: LD_INT 1
30148: ARRAY
30149: PUSH
30150: LD_INT 1
30152: ARRAY
30153: PPUSH
30154: CALL 58919 0 1
30158: PUSH
30159: LD_EXP 74
30163: PUSH
30164: LD_VAR 0 2
30168: ARRAY
30169: PPUSH
30170: LD_INT 2
30172: PUSH
30173: LD_INT 30
30175: PUSH
30176: LD_INT 2
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 30
30185: PUSH
30186: LD_INT 3
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: EMPTY
30194: LIST
30195: LIST
30196: LIST
30197: PPUSH
30198: CALL_OW 72
30202: NOT
30203: AND
30204: IFFALSE 30309
// begin for j = 1 to mc_build_list [ i ] do
30206: LD_ADDR_VAR 0 3
30210: PUSH
30211: DOUBLE
30212: LD_INT 1
30214: DEC
30215: ST_TO_ADDR
30216: LD_EXP 79
30220: PUSH
30221: LD_VAR 0 2
30225: ARRAY
30226: PUSH
30227: FOR_TO
30228: IFFALSE 30307
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
30230: LD_EXP 79
30234: PUSH
30235: LD_VAR 0 2
30239: ARRAY
30240: PUSH
30241: LD_VAR 0 3
30245: ARRAY
30246: PUSH
30247: LD_INT 1
30249: ARRAY
30250: PUSH
30251: LD_INT 2
30253: EQUAL
30254: IFFALSE 30305
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
30256: LD_ADDR_EXP 79
30260: PUSH
30261: LD_EXP 79
30265: PPUSH
30266: LD_VAR 0 2
30270: PPUSH
30271: LD_EXP 79
30275: PUSH
30276: LD_VAR 0 2
30280: ARRAY
30281: PPUSH
30282: LD_VAR 0 3
30286: PPUSH
30287: LD_INT 1
30289: PPUSH
30290: LD_INT 0
30292: PPUSH
30293: CALL 55656 0 4
30297: PPUSH
30298: CALL_OW 1
30302: ST_TO_ADDR
// break ;
30303: GO 30307
// end ;
30305: GO 30227
30307: POP
30308: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
30309: LD_EXP 79
30313: PUSH
30314: LD_VAR 0 2
30318: ARRAY
30319: PUSH
30320: LD_INT 1
30322: ARRAY
30323: PUSH
30324: LD_INT 1
30326: ARRAY
30327: PUSH
30328: LD_INT 0
30330: EQUAL
30331: PUSH
30332: LD_VAR 0 5
30336: PUSH
30337: LD_VAR 0 5
30341: PPUSH
30342: LD_EXP 79
30346: PUSH
30347: LD_VAR 0 2
30351: ARRAY
30352: PUSH
30353: LD_INT 1
30355: ARRAY
30356: PUSH
30357: LD_INT 1
30359: ARRAY
30360: PPUSH
30361: LD_EXP 79
30365: PUSH
30366: LD_VAR 0 2
30370: ARRAY
30371: PUSH
30372: LD_INT 1
30374: ARRAY
30375: PUSH
30376: LD_INT 2
30378: ARRAY
30379: PPUSH
30380: LD_EXP 79
30384: PUSH
30385: LD_VAR 0 2
30389: ARRAY
30390: PUSH
30391: LD_INT 1
30393: ARRAY
30394: PUSH
30395: LD_INT 3
30397: ARRAY
30398: PPUSH
30399: LD_EXP 79
30403: PUSH
30404: LD_VAR 0 2
30408: ARRAY
30409: PUSH
30410: LD_INT 1
30412: ARRAY
30413: PUSH
30414: LD_INT 4
30416: ARRAY
30417: PPUSH
30418: CALL 63653 0 5
30422: AND
30423: OR
30424: IFFALSE 30705
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30426: LD_ADDR_VAR 0 4
30430: PUSH
30431: LD_EXP 74
30435: PUSH
30436: LD_VAR 0 2
30440: ARRAY
30441: PPUSH
30442: LD_INT 25
30444: PUSH
30445: LD_INT 2
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PPUSH
30452: CALL_OW 72
30456: PUSH
30457: LD_EXP 76
30461: PUSH
30462: LD_VAR 0 2
30466: ARRAY
30467: DIFF
30468: ST_TO_ADDR
// if not tmp then
30469: LD_VAR 0 4
30473: NOT
30474: IFFALSE 30478
// continue ;
30476: GO 29723
// for j in tmp do
30478: LD_ADDR_VAR 0 3
30482: PUSH
30483: LD_VAR 0 4
30487: PUSH
30488: FOR_IN
30489: IFFALSE 30701
// begin if not mc_builders [ i ] then
30491: LD_EXP 80
30495: PUSH
30496: LD_VAR 0 2
30500: ARRAY
30501: NOT
30502: IFFALSE 30560
// begin SetTag ( j , 103 ) ;
30504: LD_VAR 0 3
30508: PPUSH
30509: LD_INT 103
30511: PPUSH
30512: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30516: LD_ADDR_EXP 80
30520: PUSH
30521: LD_EXP 80
30525: PPUSH
30526: LD_VAR 0 2
30530: PUSH
30531: LD_EXP 80
30535: PUSH
30536: LD_VAR 0 2
30540: ARRAY
30541: PUSH
30542: LD_INT 1
30544: PLUS
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PPUSH
30550: LD_VAR 0 3
30554: PPUSH
30555: CALL 56238 0 3
30559: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30560: LD_VAR 0 3
30564: PPUSH
30565: CALL_OW 310
30569: IFFALSE 30580
// ComExitBuilding ( j ) ;
30571: LD_VAR 0 3
30575: PPUSH
30576: CALL_OW 122
// wait ( 3 ) ;
30580: LD_INT 3
30582: PPUSH
30583: CALL_OW 67
// if not mc_build_list [ i ] then
30587: LD_EXP 79
30591: PUSH
30592: LD_VAR 0 2
30596: ARRAY
30597: NOT
30598: IFFALSE 30602
// break ;
30600: GO 30701
// if not HasTask ( j ) then
30602: LD_VAR 0 3
30606: PPUSH
30607: CALL_OW 314
30611: NOT
30612: IFFALSE 30699
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
30614: LD_VAR 0 3
30618: PPUSH
30619: LD_EXP 79
30623: PUSH
30624: LD_VAR 0 2
30628: ARRAY
30629: PUSH
30630: LD_INT 1
30632: ARRAY
30633: PUSH
30634: LD_INT 1
30636: ARRAY
30637: PPUSH
30638: LD_EXP 79
30642: PUSH
30643: LD_VAR 0 2
30647: ARRAY
30648: PUSH
30649: LD_INT 1
30651: ARRAY
30652: PUSH
30653: LD_INT 2
30655: ARRAY
30656: PPUSH
30657: LD_EXP 79
30661: PUSH
30662: LD_VAR 0 2
30666: ARRAY
30667: PUSH
30668: LD_INT 1
30670: ARRAY
30671: PUSH
30672: LD_INT 3
30674: ARRAY
30675: PPUSH
30676: LD_EXP 79
30680: PUSH
30681: LD_VAR 0 2
30685: ARRAY
30686: PUSH
30687: LD_INT 1
30689: ARRAY
30690: PUSH
30691: LD_INT 4
30693: ARRAY
30694: PPUSH
30695: CALL_OW 145
// end ;
30699: GO 30488
30701: POP
30702: POP
// end else
30703: GO 30847
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
30705: LD_EXP 74
30709: PUSH
30710: LD_VAR 0 2
30714: ARRAY
30715: PPUSH
30716: LD_EXP 79
30720: PUSH
30721: LD_VAR 0 2
30725: ARRAY
30726: PUSH
30727: LD_INT 1
30729: ARRAY
30730: PUSH
30731: LD_INT 1
30733: ARRAY
30734: PPUSH
30735: LD_EXP 79
30739: PUSH
30740: LD_VAR 0 2
30744: ARRAY
30745: PUSH
30746: LD_INT 1
30748: ARRAY
30749: PUSH
30750: LD_INT 2
30752: ARRAY
30753: PPUSH
30754: LD_EXP 79
30758: PUSH
30759: LD_VAR 0 2
30763: ARRAY
30764: PUSH
30765: LD_INT 1
30767: ARRAY
30768: PUSH
30769: LD_INT 3
30771: ARRAY
30772: PPUSH
30773: LD_EXP 79
30777: PUSH
30778: LD_VAR 0 2
30782: ARRAY
30783: PUSH
30784: LD_INT 1
30786: ARRAY
30787: PUSH
30788: LD_INT 4
30790: ARRAY
30791: PPUSH
30792: CALL 62989 0 5
30796: NOT
30797: IFFALSE 30847
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
30799: LD_ADDR_EXP 79
30803: PUSH
30804: LD_EXP 79
30808: PPUSH
30809: LD_VAR 0 2
30813: PPUSH
30814: LD_EXP 79
30818: PUSH
30819: LD_VAR 0 2
30823: ARRAY
30824: PPUSH
30825: LD_INT 1
30827: PPUSH
30828: LD_INT 1
30830: NEG
30831: PPUSH
30832: LD_INT 0
30834: PPUSH
30835: CALL 55656 0 4
30839: PPUSH
30840: CALL_OW 1
30844: ST_TO_ADDR
// continue ;
30845: GO 29723
// end ; end ; end ;
30847: GO 29723
30849: POP
30850: POP
// end ;
30851: LD_VAR 0 1
30855: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30856: LD_INT 0
30858: PPUSH
30859: PPUSH
30860: PPUSH
30861: PPUSH
30862: PPUSH
30863: PPUSH
// if not mc_bases then
30864: LD_EXP 74
30868: NOT
30869: IFFALSE 30873
// exit ;
30871: GO 31300
// for i = 1 to mc_bases do
30873: LD_ADDR_VAR 0 2
30877: PUSH
30878: DOUBLE
30879: LD_INT 1
30881: DEC
30882: ST_TO_ADDR
30883: LD_EXP 74
30887: PUSH
30888: FOR_TO
30889: IFFALSE 31298
// begin tmp := mc_build_upgrade [ i ] ;
30891: LD_ADDR_VAR 0 4
30895: PUSH
30896: LD_EXP 106
30900: PUSH
30901: LD_VAR 0 2
30905: ARRAY
30906: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30907: LD_ADDR_VAR 0 6
30911: PUSH
30912: LD_EXP 107
30916: PUSH
30917: LD_VAR 0 2
30921: ARRAY
30922: PPUSH
30923: LD_INT 2
30925: PUSH
30926: LD_INT 30
30928: PUSH
30929: LD_INT 6
30931: PUSH
30932: EMPTY
30933: LIST
30934: LIST
30935: PUSH
30936: LD_INT 30
30938: PUSH
30939: LD_INT 7
30941: PUSH
30942: EMPTY
30943: LIST
30944: LIST
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: LIST
30950: PPUSH
30951: CALL_OW 72
30955: ST_TO_ADDR
// if not tmp and not lab then
30956: LD_VAR 0 4
30960: NOT
30961: PUSH
30962: LD_VAR 0 6
30966: NOT
30967: AND
30968: IFFALSE 30972
// continue ;
30970: GO 30888
// if tmp then
30972: LD_VAR 0 4
30976: IFFALSE 31096
// for j in tmp do
30978: LD_ADDR_VAR 0 3
30982: PUSH
30983: LD_VAR 0 4
30987: PUSH
30988: FOR_IN
30989: IFFALSE 31094
// begin if UpgradeCost ( j ) then
30991: LD_VAR 0 3
30995: PPUSH
30996: CALL 62649 0 1
31000: IFFALSE 31092
// begin ComUpgrade ( j ) ;
31002: LD_VAR 0 3
31006: PPUSH
31007: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
31011: LD_ADDR_EXP 106
31015: PUSH
31016: LD_EXP 106
31020: PPUSH
31021: LD_VAR 0 2
31025: PPUSH
31026: LD_EXP 106
31030: PUSH
31031: LD_VAR 0 2
31035: ARRAY
31036: PUSH
31037: LD_VAR 0 3
31041: DIFF
31042: PPUSH
31043: CALL_OW 1
31047: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31048: LD_ADDR_EXP 81
31052: PUSH
31053: LD_EXP 81
31057: PPUSH
31058: LD_VAR 0 2
31062: PUSH
31063: LD_EXP 81
31067: PUSH
31068: LD_VAR 0 2
31072: ARRAY
31073: PUSH
31074: LD_INT 1
31076: PLUS
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PPUSH
31082: LD_VAR 0 3
31086: PPUSH
31087: CALL 56238 0 3
31091: ST_TO_ADDR
// end ; end ;
31092: GO 30988
31094: POP
31095: POP
// if not lab or not mc_lab_upgrade [ i ] then
31096: LD_VAR 0 6
31100: NOT
31101: PUSH
31102: LD_EXP 108
31106: PUSH
31107: LD_VAR 0 2
31111: ARRAY
31112: NOT
31113: OR
31114: IFFALSE 31118
// continue ;
31116: GO 30888
// for j in lab do
31118: LD_ADDR_VAR 0 3
31122: PUSH
31123: LD_VAR 0 6
31127: PUSH
31128: FOR_IN
31129: IFFALSE 31294
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
31131: LD_VAR 0 3
31135: PPUSH
31136: CALL_OW 266
31140: PUSH
31141: LD_INT 6
31143: PUSH
31144: LD_INT 7
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: IN
31151: PUSH
31152: LD_VAR 0 3
31156: PPUSH
31157: CALL_OW 461
31161: PUSH
31162: LD_INT 1
31164: NONEQUAL
31165: AND
31166: IFFALSE 31292
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
31168: LD_VAR 0 3
31172: PPUSH
31173: LD_EXP 108
31177: PUSH
31178: LD_VAR 0 2
31182: ARRAY
31183: PUSH
31184: LD_INT 1
31186: ARRAY
31187: PPUSH
31188: CALL 62854 0 2
31192: IFFALSE 31292
// begin ComCancel ( j ) ;
31194: LD_VAR 0 3
31198: PPUSH
31199: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
31203: LD_VAR 0 3
31207: PPUSH
31208: LD_EXP 108
31212: PUSH
31213: LD_VAR 0 2
31217: ARRAY
31218: PUSH
31219: LD_INT 1
31221: ARRAY
31222: PPUSH
31223: CALL_OW 207
// if not j in mc_construct_list [ i ] then
31227: LD_VAR 0 3
31231: PUSH
31232: LD_EXP 81
31236: PUSH
31237: LD_VAR 0 2
31241: ARRAY
31242: IN
31243: NOT
31244: IFFALSE 31290
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31246: LD_ADDR_EXP 81
31250: PUSH
31251: LD_EXP 81
31255: PPUSH
31256: LD_VAR 0 2
31260: PUSH
31261: LD_EXP 81
31265: PUSH
31266: LD_VAR 0 2
31270: ARRAY
31271: PUSH
31272: LD_INT 1
31274: PLUS
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PPUSH
31280: LD_VAR 0 3
31284: PPUSH
31285: CALL 56238 0 3
31289: ST_TO_ADDR
// break ;
31290: GO 31294
// end ; end ; end ;
31292: GO 31128
31294: POP
31295: POP
// end ;
31296: GO 30888
31298: POP
31299: POP
// end ;
31300: LD_VAR 0 1
31304: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
31305: LD_INT 0
31307: PPUSH
31308: PPUSH
31309: PPUSH
31310: PPUSH
31311: PPUSH
31312: PPUSH
31313: PPUSH
31314: PPUSH
31315: PPUSH
// if not mc_bases then
31316: LD_EXP 74
31320: NOT
31321: IFFALSE 31325
// exit ;
31323: GO 31730
// for i = 1 to mc_bases do
31325: LD_ADDR_VAR 0 2
31329: PUSH
31330: DOUBLE
31331: LD_INT 1
31333: DEC
31334: ST_TO_ADDR
31335: LD_EXP 74
31339: PUSH
31340: FOR_TO
31341: IFFALSE 31728
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
31343: LD_EXP 82
31347: PUSH
31348: LD_VAR 0 2
31352: ARRAY
31353: NOT
31354: PUSH
31355: LD_EXP 74
31359: PUSH
31360: LD_VAR 0 2
31364: ARRAY
31365: PPUSH
31366: LD_INT 30
31368: PUSH
31369: LD_INT 3
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PPUSH
31376: CALL_OW 72
31380: NOT
31381: OR
31382: IFFALSE 31386
// continue ;
31384: GO 31340
// busy := false ;
31386: LD_ADDR_VAR 0 8
31390: PUSH
31391: LD_INT 0
31393: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
31394: LD_ADDR_VAR 0 4
31398: PUSH
31399: LD_EXP 74
31403: PUSH
31404: LD_VAR 0 2
31408: ARRAY
31409: PPUSH
31410: LD_INT 30
31412: PUSH
31413: LD_INT 3
31415: PUSH
31416: EMPTY
31417: LIST
31418: LIST
31419: PPUSH
31420: CALL_OW 72
31424: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
31425: LD_ADDR_VAR 0 6
31429: PUSH
31430: LD_EXP 82
31434: PUSH
31435: LD_VAR 0 2
31439: ARRAY
31440: PPUSH
31441: LD_INT 2
31443: PUSH
31444: LD_INT 30
31446: PUSH
31447: LD_INT 32
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 30
31456: PUSH
31457: LD_INT 33
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: EMPTY
31465: LIST
31466: LIST
31467: LIST
31468: PPUSH
31469: CALL_OW 72
31473: ST_TO_ADDR
// if not t then
31474: LD_VAR 0 6
31478: NOT
31479: IFFALSE 31483
// continue ;
31481: GO 31340
// for j in tmp do
31483: LD_ADDR_VAR 0 3
31487: PUSH
31488: LD_VAR 0 4
31492: PUSH
31493: FOR_IN
31494: IFFALSE 31524
// if not BuildingStatus ( j ) = bs_idle then
31496: LD_VAR 0 3
31500: PPUSH
31501: CALL_OW 461
31505: PUSH
31506: LD_INT 2
31508: EQUAL
31509: NOT
31510: IFFALSE 31522
// begin busy := true ;
31512: LD_ADDR_VAR 0 8
31516: PUSH
31517: LD_INT 1
31519: ST_TO_ADDR
// break ;
31520: GO 31524
// end ;
31522: GO 31493
31524: POP
31525: POP
// if busy then
31526: LD_VAR 0 8
31530: IFFALSE 31534
// continue ;
31532: GO 31340
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
31534: LD_ADDR_VAR 0 7
31538: PUSH
31539: LD_VAR 0 6
31543: PPUSH
31544: LD_INT 35
31546: PUSH
31547: LD_INT 0
31549: PUSH
31550: EMPTY
31551: LIST
31552: LIST
31553: PPUSH
31554: CALL_OW 72
31558: ST_TO_ADDR
// if tw then
31559: LD_VAR 0 7
31563: IFFALSE 31640
// begin tw := tw [ 1 ] ;
31565: LD_ADDR_VAR 0 7
31569: PUSH
31570: LD_VAR 0 7
31574: PUSH
31575: LD_INT 1
31577: ARRAY
31578: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
31579: LD_ADDR_VAR 0 9
31583: PUSH
31584: LD_VAR 0 7
31588: PPUSH
31589: LD_EXP 99
31593: PUSH
31594: LD_VAR 0 2
31598: ARRAY
31599: PPUSH
31600: CALL 61208 0 2
31604: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
31605: LD_EXP 113
31609: PUSH
31610: LD_VAR 0 2
31614: ARRAY
31615: IFFALSE 31638
// if not weapon in mc_allowed_tower_weapons [ i ] then
31617: LD_VAR 0 9
31621: PUSH
31622: LD_EXP 113
31626: PUSH
31627: LD_VAR 0 2
31631: ARRAY
31632: IN
31633: NOT
31634: IFFALSE 31638
// continue ;
31636: GO 31340
// end else
31638: GO 31703
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
31640: LD_ADDR_VAR 0 5
31644: PUSH
31645: LD_EXP 82
31649: PUSH
31650: LD_VAR 0 2
31654: ARRAY
31655: PPUSH
31656: LD_VAR 0 4
31660: PPUSH
31661: CALL 91409 0 2
31665: ST_TO_ADDR
// if not tmp2 then
31666: LD_VAR 0 5
31670: NOT
31671: IFFALSE 31675
// continue ;
31673: GO 31340
// tw := tmp2 [ 1 ] ;
31675: LD_ADDR_VAR 0 7
31679: PUSH
31680: LD_VAR 0 5
31684: PUSH
31685: LD_INT 1
31687: ARRAY
31688: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
31689: LD_ADDR_VAR 0 9
31693: PUSH
31694: LD_VAR 0 5
31698: PUSH
31699: LD_INT 2
31701: ARRAY
31702: ST_TO_ADDR
// end ; if not weapon then
31703: LD_VAR 0 9
31707: NOT
31708: IFFALSE 31712
// continue ;
31710: GO 31340
// ComPlaceWeapon ( tw , weapon ) ;
31712: LD_VAR 0 7
31716: PPUSH
31717: LD_VAR 0 9
31721: PPUSH
31722: CALL_OW 148
// end ;
31726: GO 31340
31728: POP
31729: POP
// end ;
31730: LD_VAR 0 1
31734: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
31735: LD_INT 0
31737: PPUSH
31738: PPUSH
31739: PPUSH
31740: PPUSH
31741: PPUSH
31742: PPUSH
// if not mc_bases then
31743: LD_EXP 74
31747: NOT
31748: IFFALSE 31752
// exit ;
31750: GO 32764
// for i = 1 to mc_bases do
31752: LD_ADDR_VAR 0 2
31756: PUSH
31757: DOUBLE
31758: LD_INT 1
31760: DEC
31761: ST_TO_ADDR
31762: LD_EXP 74
31766: PUSH
31767: FOR_TO
31768: IFFALSE 32762
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
31770: LD_EXP 87
31774: PUSH
31775: LD_VAR 0 2
31779: ARRAY
31780: NOT
31781: PUSH
31782: LD_EXP 87
31786: PUSH
31787: LD_VAR 0 2
31791: ARRAY
31792: PUSH
31793: LD_EXP 88
31797: PUSH
31798: LD_VAR 0 2
31802: ARRAY
31803: EQUAL
31804: OR
31805: IFFALSE 31809
// continue ;
31807: GO 31767
// if mc_miners [ i ] then
31809: LD_EXP 88
31813: PUSH
31814: LD_VAR 0 2
31818: ARRAY
31819: IFFALSE 32449
// begin k := 1 ;
31821: LD_ADDR_VAR 0 4
31825: PUSH
31826: LD_INT 1
31828: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
31829: LD_ADDR_VAR 0 3
31833: PUSH
31834: DOUBLE
31835: LD_EXP 88
31839: PUSH
31840: LD_VAR 0 2
31844: ARRAY
31845: INC
31846: ST_TO_ADDR
31847: LD_INT 1
31849: PUSH
31850: FOR_DOWNTO
31851: IFFALSE 32447
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31853: LD_EXP 88
31857: PUSH
31858: LD_VAR 0 2
31862: ARRAY
31863: PUSH
31864: LD_VAR 0 3
31868: ARRAY
31869: PPUSH
31870: CALL_OW 301
31874: PUSH
31875: LD_EXP 88
31879: PUSH
31880: LD_VAR 0 2
31884: ARRAY
31885: PUSH
31886: LD_VAR 0 3
31890: ARRAY
31891: PPUSH
31892: CALL_OW 257
31896: PUSH
31897: LD_INT 1
31899: NONEQUAL
31900: OR
31901: IFFALSE 31964
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31903: LD_ADDR_VAR 0 5
31907: PUSH
31908: LD_EXP 88
31912: PUSH
31913: LD_VAR 0 2
31917: ARRAY
31918: PUSH
31919: LD_EXP 88
31923: PUSH
31924: LD_VAR 0 2
31928: ARRAY
31929: PUSH
31930: LD_VAR 0 3
31934: ARRAY
31935: DIFF
31936: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31937: LD_ADDR_EXP 88
31941: PUSH
31942: LD_EXP 88
31946: PPUSH
31947: LD_VAR 0 2
31951: PPUSH
31952: LD_VAR 0 5
31956: PPUSH
31957: CALL_OW 1
31961: ST_TO_ADDR
// continue ;
31962: GO 31850
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
31964: LD_EXP 88
31968: PUSH
31969: LD_VAR 0 2
31973: ARRAY
31974: PUSH
31975: LD_VAR 0 3
31979: ARRAY
31980: PPUSH
31981: CALL 56174 0 1
31985: PUSH
31986: LD_EXP 88
31990: PUSH
31991: LD_VAR 0 2
31995: ARRAY
31996: PUSH
31997: LD_VAR 0 3
32001: ARRAY
32002: PPUSH
32003: CALL_OW 255
32007: PPUSH
32008: LD_EXP 87
32012: PUSH
32013: LD_VAR 0 2
32017: ARRAY
32018: PUSH
32019: LD_VAR 0 4
32023: ARRAY
32024: PUSH
32025: LD_INT 1
32027: ARRAY
32028: PPUSH
32029: LD_EXP 87
32033: PUSH
32034: LD_VAR 0 2
32038: ARRAY
32039: PUSH
32040: LD_VAR 0 4
32044: ARRAY
32045: PUSH
32046: LD_INT 2
32048: ARRAY
32049: PPUSH
32050: LD_INT 15
32052: PPUSH
32053: CALL 57134 0 4
32057: PUSH
32058: LD_INT 4
32060: ARRAY
32061: PUSH
32062: LD_EXP 88
32066: PUSH
32067: LD_VAR 0 2
32071: ARRAY
32072: PUSH
32073: LD_VAR 0 3
32077: ARRAY
32078: PPUSH
32079: LD_INT 10
32081: PPUSH
32082: CALL 58831 0 2
32086: PUSH
32087: LD_INT 4
32089: ARRAY
32090: OR
32091: AND
32092: IFFALSE 32115
// ComStop ( mc_miners [ i ] [ j ] ) ;
32094: LD_EXP 88
32098: PUSH
32099: LD_VAR 0 2
32103: ARRAY
32104: PUSH
32105: LD_VAR 0 3
32109: ARRAY
32110: PPUSH
32111: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
32115: LD_EXP 88
32119: PUSH
32120: LD_VAR 0 2
32124: ARRAY
32125: PUSH
32126: LD_VAR 0 3
32130: ARRAY
32131: PPUSH
32132: CALL_OW 257
32136: PUSH
32137: LD_INT 1
32139: EQUAL
32140: PUSH
32141: LD_EXP 88
32145: PUSH
32146: LD_VAR 0 2
32150: ARRAY
32151: PUSH
32152: LD_VAR 0 3
32156: ARRAY
32157: PPUSH
32158: CALL_OW 459
32162: NOT
32163: AND
32164: PUSH
32165: LD_EXP 88
32169: PUSH
32170: LD_VAR 0 2
32174: ARRAY
32175: PUSH
32176: LD_VAR 0 3
32180: ARRAY
32181: PPUSH
32182: CALL_OW 255
32186: PPUSH
32187: LD_EXP 87
32191: PUSH
32192: LD_VAR 0 2
32196: ARRAY
32197: PUSH
32198: LD_VAR 0 4
32202: ARRAY
32203: PUSH
32204: LD_INT 1
32206: ARRAY
32207: PPUSH
32208: LD_EXP 87
32212: PUSH
32213: LD_VAR 0 2
32217: ARRAY
32218: PUSH
32219: LD_VAR 0 4
32223: ARRAY
32224: PUSH
32225: LD_INT 2
32227: ARRAY
32228: PPUSH
32229: LD_INT 15
32231: PPUSH
32232: CALL 57134 0 4
32236: PUSH
32237: LD_INT 4
32239: ARRAY
32240: PUSH
32241: LD_INT 0
32243: EQUAL
32244: AND
32245: PUSH
32246: LD_EXP 88
32250: PUSH
32251: LD_VAR 0 2
32255: ARRAY
32256: PUSH
32257: LD_VAR 0 3
32261: ARRAY
32262: PPUSH
32263: CALL_OW 314
32267: NOT
32268: AND
32269: IFFALSE 32445
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
32271: LD_EXP 88
32275: PUSH
32276: LD_VAR 0 2
32280: ARRAY
32281: PUSH
32282: LD_VAR 0 3
32286: ARRAY
32287: PPUSH
32288: CALL_OW 310
32292: IFFALSE 32315
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
32294: LD_EXP 88
32298: PUSH
32299: LD_VAR 0 2
32303: ARRAY
32304: PUSH
32305: LD_VAR 0 3
32309: ARRAY
32310: PPUSH
32311: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
32315: LD_EXP 88
32319: PUSH
32320: LD_VAR 0 2
32324: ARRAY
32325: PUSH
32326: LD_VAR 0 3
32330: ARRAY
32331: PPUSH
32332: CALL_OW 314
32336: NOT
32337: IFFALSE 32405
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
32339: LD_EXP 88
32343: PUSH
32344: LD_VAR 0 2
32348: ARRAY
32349: PUSH
32350: LD_VAR 0 3
32354: ARRAY
32355: PPUSH
32356: LD_EXP 87
32360: PUSH
32361: LD_VAR 0 2
32365: ARRAY
32366: PUSH
32367: LD_VAR 0 4
32371: ARRAY
32372: PUSH
32373: LD_INT 1
32375: ARRAY
32376: PPUSH
32377: LD_EXP 87
32381: PUSH
32382: LD_VAR 0 2
32386: ARRAY
32387: PUSH
32388: LD_VAR 0 4
32392: ARRAY
32393: PUSH
32394: LD_INT 2
32396: ARRAY
32397: PPUSH
32398: LD_INT 0
32400: PPUSH
32401: CALL_OW 193
// k := k + 1 ;
32405: LD_ADDR_VAR 0 4
32409: PUSH
32410: LD_VAR 0 4
32414: PUSH
32415: LD_INT 1
32417: PLUS
32418: ST_TO_ADDR
// if k > mc_mines [ i ] then
32419: LD_VAR 0 4
32423: PUSH
32424: LD_EXP 87
32428: PUSH
32429: LD_VAR 0 2
32433: ARRAY
32434: GREATER
32435: IFFALSE 32445
// k := 1 ;
32437: LD_ADDR_VAR 0 4
32441: PUSH
32442: LD_INT 1
32444: ST_TO_ADDR
// end ; end ;
32445: GO 31850
32447: POP
32448: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
32449: LD_ADDR_VAR 0 5
32453: PUSH
32454: LD_EXP 74
32458: PUSH
32459: LD_VAR 0 2
32463: ARRAY
32464: PPUSH
32465: LD_INT 2
32467: PUSH
32468: LD_INT 30
32470: PUSH
32471: LD_INT 4
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 30
32480: PUSH
32481: LD_INT 5
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: LD_INT 30
32490: PUSH
32491: LD_INT 32
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: EMPTY
32499: LIST
32500: LIST
32501: LIST
32502: LIST
32503: PPUSH
32504: CALL_OW 72
32508: ST_TO_ADDR
// if not tmp then
32509: LD_VAR 0 5
32513: NOT
32514: IFFALSE 32518
// continue ;
32516: GO 31767
// list := [ ] ;
32518: LD_ADDR_VAR 0 6
32522: PUSH
32523: EMPTY
32524: ST_TO_ADDR
// for j in tmp do
32525: LD_ADDR_VAR 0 3
32529: PUSH
32530: LD_VAR 0 5
32534: PUSH
32535: FOR_IN
32536: IFFALSE 32605
// begin for k in UnitsInside ( j ) do
32538: LD_ADDR_VAR 0 4
32542: PUSH
32543: LD_VAR 0 3
32547: PPUSH
32548: CALL_OW 313
32552: PUSH
32553: FOR_IN
32554: IFFALSE 32601
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
32556: LD_VAR 0 4
32560: PPUSH
32561: CALL_OW 257
32565: PUSH
32566: LD_INT 1
32568: EQUAL
32569: PUSH
32570: LD_VAR 0 4
32574: PPUSH
32575: CALL_OW 459
32579: NOT
32580: AND
32581: IFFALSE 32599
// list := list ^ k ;
32583: LD_ADDR_VAR 0 6
32587: PUSH
32588: LD_VAR 0 6
32592: PUSH
32593: LD_VAR 0 4
32597: ADD
32598: ST_TO_ADDR
32599: GO 32553
32601: POP
32602: POP
// end ;
32603: GO 32535
32605: POP
32606: POP
// list := list diff mc_miners [ i ] ;
32607: LD_ADDR_VAR 0 6
32611: PUSH
32612: LD_VAR 0 6
32616: PUSH
32617: LD_EXP 88
32621: PUSH
32622: LD_VAR 0 2
32626: ARRAY
32627: DIFF
32628: ST_TO_ADDR
// if not list then
32629: LD_VAR 0 6
32633: NOT
32634: IFFALSE 32638
// continue ;
32636: GO 31767
// k := mc_mines [ i ] - mc_miners [ i ] ;
32638: LD_ADDR_VAR 0 4
32642: PUSH
32643: LD_EXP 87
32647: PUSH
32648: LD_VAR 0 2
32652: ARRAY
32653: PUSH
32654: LD_EXP 88
32658: PUSH
32659: LD_VAR 0 2
32663: ARRAY
32664: MINUS
32665: ST_TO_ADDR
// if k > list then
32666: LD_VAR 0 4
32670: PUSH
32671: LD_VAR 0 6
32675: GREATER
32676: IFFALSE 32688
// k := list ;
32678: LD_ADDR_VAR 0 4
32682: PUSH
32683: LD_VAR 0 6
32687: ST_TO_ADDR
// for j = 1 to k do
32688: LD_ADDR_VAR 0 3
32692: PUSH
32693: DOUBLE
32694: LD_INT 1
32696: DEC
32697: ST_TO_ADDR
32698: LD_VAR 0 4
32702: PUSH
32703: FOR_TO
32704: IFFALSE 32758
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
32706: LD_ADDR_EXP 88
32710: PUSH
32711: LD_EXP 88
32715: PPUSH
32716: LD_VAR 0 2
32720: PUSH
32721: LD_EXP 88
32725: PUSH
32726: LD_VAR 0 2
32730: ARRAY
32731: PUSH
32732: LD_INT 1
32734: PLUS
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PPUSH
32740: LD_VAR 0 6
32744: PUSH
32745: LD_VAR 0 3
32749: ARRAY
32750: PPUSH
32751: CALL 56238 0 3
32755: ST_TO_ADDR
32756: GO 32703
32758: POP
32759: POP
// end ;
32760: GO 31767
32762: POP
32763: POP
// end ;
32764: LD_VAR 0 1
32768: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
32769: LD_INT 0
32771: PPUSH
32772: PPUSH
32773: PPUSH
32774: PPUSH
32775: PPUSH
32776: PPUSH
32777: PPUSH
32778: PPUSH
32779: PPUSH
32780: PPUSH
// if not mc_bases then
32781: LD_EXP 74
32785: NOT
32786: IFFALSE 32790
// exit ;
32788: GO 34540
// for i = 1 to mc_bases do
32790: LD_ADDR_VAR 0 2
32794: PUSH
32795: DOUBLE
32796: LD_INT 1
32798: DEC
32799: ST_TO_ADDR
32800: LD_EXP 74
32804: PUSH
32805: FOR_TO
32806: IFFALSE 34538
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
32808: LD_EXP 74
32812: PUSH
32813: LD_VAR 0 2
32817: ARRAY
32818: NOT
32819: PUSH
32820: LD_EXP 81
32824: PUSH
32825: LD_VAR 0 2
32829: ARRAY
32830: OR
32831: IFFALSE 32835
// continue ;
32833: GO 32805
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
32835: LD_EXP 90
32839: PUSH
32840: LD_VAR 0 2
32844: ARRAY
32845: NOT
32846: PUSH
32847: LD_EXP 91
32851: PUSH
32852: LD_VAR 0 2
32856: ARRAY
32857: AND
32858: IFFALSE 32896
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
32860: LD_ADDR_EXP 91
32864: PUSH
32865: LD_EXP 91
32869: PPUSH
32870: LD_VAR 0 2
32874: PPUSH
32875: EMPTY
32876: PPUSH
32877: CALL_OW 1
32881: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
32882: LD_VAR 0 2
32886: PPUSH
32887: LD_INT 107
32889: PPUSH
32890: CALL 23650 0 2
// continue ;
32894: GO 32805
// end ; target := [ ] ;
32896: LD_ADDR_VAR 0 6
32900: PUSH
32901: EMPTY
32902: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
32903: LD_ADDR_VAR 0 3
32907: PUSH
32908: DOUBLE
32909: LD_EXP 90
32913: PUSH
32914: LD_VAR 0 2
32918: ARRAY
32919: INC
32920: ST_TO_ADDR
32921: LD_INT 1
32923: PUSH
32924: FOR_DOWNTO
32925: IFFALSE 33185
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
32927: LD_EXP 90
32931: PUSH
32932: LD_VAR 0 2
32936: ARRAY
32937: PUSH
32938: LD_VAR 0 3
32942: ARRAY
32943: PUSH
32944: LD_INT 2
32946: ARRAY
32947: PPUSH
32948: LD_EXP 90
32952: PUSH
32953: LD_VAR 0 2
32957: ARRAY
32958: PUSH
32959: LD_VAR 0 3
32963: ARRAY
32964: PUSH
32965: LD_INT 3
32967: ARRAY
32968: PPUSH
32969: CALL_OW 488
32973: PUSH
32974: LD_EXP 90
32978: PUSH
32979: LD_VAR 0 2
32983: ARRAY
32984: PUSH
32985: LD_VAR 0 3
32989: ARRAY
32990: PUSH
32991: LD_INT 2
32993: ARRAY
32994: PPUSH
32995: LD_EXP 90
32999: PUSH
33000: LD_VAR 0 2
33004: ARRAY
33005: PUSH
33006: LD_VAR 0 3
33010: ARRAY
33011: PUSH
33012: LD_INT 3
33014: ARRAY
33015: PPUSH
33016: CALL_OW 284
33020: PUSH
33021: LD_INT 0
33023: EQUAL
33024: AND
33025: IFFALSE 33080
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33027: LD_ADDR_VAR 0 5
33031: PUSH
33032: LD_EXP 90
33036: PUSH
33037: LD_VAR 0 2
33041: ARRAY
33042: PPUSH
33043: LD_VAR 0 3
33047: PPUSH
33048: CALL_OW 3
33052: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33053: LD_ADDR_EXP 90
33057: PUSH
33058: LD_EXP 90
33062: PPUSH
33063: LD_VAR 0 2
33067: PPUSH
33068: LD_VAR 0 5
33072: PPUSH
33073: CALL_OW 1
33077: ST_TO_ADDR
// continue ;
33078: GO 32924
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33080: LD_EXP 74
33084: PUSH
33085: LD_VAR 0 2
33089: ARRAY
33090: PUSH
33091: LD_INT 1
33093: ARRAY
33094: PPUSH
33095: CALL_OW 255
33099: PPUSH
33100: LD_EXP 90
33104: PUSH
33105: LD_VAR 0 2
33109: ARRAY
33110: PUSH
33111: LD_VAR 0 3
33115: ARRAY
33116: PUSH
33117: LD_INT 2
33119: ARRAY
33120: PPUSH
33121: LD_EXP 90
33125: PUSH
33126: LD_VAR 0 2
33130: ARRAY
33131: PUSH
33132: LD_VAR 0 3
33136: ARRAY
33137: PUSH
33138: LD_INT 3
33140: ARRAY
33141: PPUSH
33142: LD_INT 30
33144: PPUSH
33145: CALL 57134 0 4
33149: PUSH
33150: LD_INT 4
33152: ARRAY
33153: PUSH
33154: LD_INT 0
33156: EQUAL
33157: IFFALSE 33183
// begin target := mc_crates [ i ] [ j ] ;
33159: LD_ADDR_VAR 0 6
33163: PUSH
33164: LD_EXP 90
33168: PUSH
33169: LD_VAR 0 2
33173: ARRAY
33174: PUSH
33175: LD_VAR 0 3
33179: ARRAY
33180: ST_TO_ADDR
// break ;
33181: GO 33185
// end ; end ;
33183: GO 32924
33185: POP
33186: POP
// if not target then
33187: LD_VAR 0 6
33191: NOT
33192: IFFALSE 33196
// continue ;
33194: GO 32805
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33196: LD_ADDR_VAR 0 7
33200: PUSH
33201: LD_EXP 93
33205: PUSH
33206: LD_VAR 0 2
33210: ARRAY
33211: PPUSH
33212: LD_INT 2
33214: PUSH
33215: LD_INT 3
33217: PUSH
33218: LD_INT 58
33220: PUSH
33221: EMPTY
33222: LIST
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 61
33230: PUSH
33231: EMPTY
33232: LIST
33233: PUSH
33234: LD_INT 33
33236: PUSH
33237: LD_INT 5
33239: PUSH
33240: EMPTY
33241: LIST
33242: LIST
33243: PUSH
33244: LD_INT 33
33246: PUSH
33247: LD_INT 3
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: LIST
33258: LIST
33259: LIST
33260: PUSH
33261: LD_INT 2
33263: PUSH
33264: LD_INT 34
33266: PUSH
33267: LD_INT 32
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: PUSH
33274: LD_INT 34
33276: PUSH
33277: LD_INT 51
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 34
33286: PUSH
33287: LD_INT 12
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: LIST
33298: LIST
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PPUSH
33304: CALL_OW 72
33308: ST_TO_ADDR
// if not cargo then
33309: LD_VAR 0 7
33313: NOT
33314: IFFALSE 33957
// begin if mc_crates_collector [ i ] < 5 then
33316: LD_EXP 91
33320: PUSH
33321: LD_VAR 0 2
33325: ARRAY
33326: PUSH
33327: LD_INT 5
33329: LESS
33330: IFFALSE 33696
// begin if mc_ape [ i ] then
33332: LD_EXP 103
33336: PUSH
33337: LD_VAR 0 2
33341: ARRAY
33342: IFFALSE 33389
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
33344: LD_ADDR_VAR 0 5
33348: PUSH
33349: LD_EXP 103
33353: PUSH
33354: LD_VAR 0 2
33358: ARRAY
33359: PPUSH
33360: LD_INT 25
33362: PUSH
33363: LD_INT 16
33365: PUSH
33366: EMPTY
33367: LIST
33368: LIST
33369: PUSH
33370: LD_INT 24
33372: PUSH
33373: LD_INT 750
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PPUSH
33384: CALL_OW 72
33388: ST_TO_ADDR
// if not tmp then
33389: LD_VAR 0 5
33393: NOT
33394: IFFALSE 33441
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
33396: LD_ADDR_VAR 0 5
33400: PUSH
33401: LD_EXP 74
33405: PUSH
33406: LD_VAR 0 2
33410: ARRAY
33411: PPUSH
33412: LD_INT 25
33414: PUSH
33415: LD_INT 2
33417: PUSH
33418: EMPTY
33419: LIST
33420: LIST
33421: PUSH
33422: LD_INT 24
33424: PUSH
33425: LD_INT 750
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PPUSH
33436: CALL_OW 72
33440: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
33441: LD_EXP 103
33445: PUSH
33446: LD_VAR 0 2
33450: ARRAY
33451: PUSH
33452: LD_EXP 74
33456: PUSH
33457: LD_VAR 0 2
33461: ARRAY
33462: PPUSH
33463: LD_INT 25
33465: PUSH
33466: LD_INT 2
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 24
33475: PUSH
33476: LD_INT 750
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PPUSH
33487: CALL_OW 72
33491: AND
33492: PUSH
33493: LD_VAR 0 5
33497: PUSH
33498: LD_INT 5
33500: LESS
33501: AND
33502: IFFALSE 33584
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
33504: LD_ADDR_VAR 0 3
33508: PUSH
33509: LD_EXP 74
33513: PUSH
33514: LD_VAR 0 2
33518: ARRAY
33519: PPUSH
33520: LD_INT 25
33522: PUSH
33523: LD_INT 2
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: PUSH
33530: LD_INT 24
33532: PUSH
33533: LD_INT 750
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PPUSH
33544: CALL_OW 72
33548: PUSH
33549: FOR_IN
33550: IFFALSE 33582
// begin tmp := tmp union j ;
33552: LD_ADDR_VAR 0 5
33556: PUSH
33557: LD_VAR 0 5
33561: PUSH
33562: LD_VAR 0 3
33566: UNION
33567: ST_TO_ADDR
// if tmp >= 5 then
33568: LD_VAR 0 5
33572: PUSH
33573: LD_INT 5
33575: GREATEREQUAL
33576: IFFALSE 33580
// break ;
33578: GO 33582
// end ;
33580: GO 33549
33582: POP
33583: POP
// end ; if not tmp then
33584: LD_VAR 0 5
33588: NOT
33589: IFFALSE 33593
// continue ;
33591: GO 32805
// for j in tmp do
33593: LD_ADDR_VAR 0 3
33597: PUSH
33598: LD_VAR 0 5
33602: PUSH
33603: FOR_IN
33604: IFFALSE 33694
// if not GetTag ( j ) then
33606: LD_VAR 0 3
33610: PPUSH
33611: CALL_OW 110
33615: NOT
33616: IFFALSE 33692
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
33618: LD_ADDR_EXP 91
33622: PUSH
33623: LD_EXP 91
33627: PPUSH
33628: LD_VAR 0 2
33632: PUSH
33633: LD_EXP 91
33637: PUSH
33638: LD_VAR 0 2
33642: ARRAY
33643: PUSH
33644: LD_INT 1
33646: PLUS
33647: PUSH
33648: EMPTY
33649: LIST
33650: LIST
33651: PPUSH
33652: LD_VAR 0 3
33656: PPUSH
33657: CALL 56238 0 3
33661: ST_TO_ADDR
// SetTag ( j , 107 ) ;
33662: LD_VAR 0 3
33666: PPUSH
33667: LD_INT 107
33669: PPUSH
33670: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
33674: LD_EXP 91
33678: PUSH
33679: LD_VAR 0 2
33683: ARRAY
33684: PUSH
33685: LD_INT 5
33687: GREATEREQUAL
33688: IFFALSE 33692
// break ;
33690: GO 33694
// end ;
33692: GO 33603
33694: POP
33695: POP
// end ; if mc_crates_collector [ i ] and target then
33696: LD_EXP 91
33700: PUSH
33701: LD_VAR 0 2
33705: ARRAY
33706: PUSH
33707: LD_VAR 0 6
33711: AND
33712: IFFALSE 33955
// begin if mc_crates_collector [ i ] < target [ 1 ] then
33714: LD_EXP 91
33718: PUSH
33719: LD_VAR 0 2
33723: ARRAY
33724: PUSH
33725: LD_VAR 0 6
33729: PUSH
33730: LD_INT 1
33732: ARRAY
33733: LESS
33734: IFFALSE 33754
// tmp := mc_crates_collector [ i ] else
33736: LD_ADDR_VAR 0 5
33740: PUSH
33741: LD_EXP 91
33745: PUSH
33746: LD_VAR 0 2
33750: ARRAY
33751: ST_TO_ADDR
33752: GO 33768
// tmp := target [ 1 ] ;
33754: LD_ADDR_VAR 0 5
33758: PUSH
33759: LD_VAR 0 6
33763: PUSH
33764: LD_INT 1
33766: ARRAY
33767: ST_TO_ADDR
// k := 0 ;
33768: LD_ADDR_VAR 0 4
33772: PUSH
33773: LD_INT 0
33775: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
33776: LD_ADDR_VAR 0 3
33780: PUSH
33781: LD_EXP 91
33785: PUSH
33786: LD_VAR 0 2
33790: ARRAY
33791: PUSH
33792: FOR_IN
33793: IFFALSE 33953
// begin k := k + 1 ;
33795: LD_ADDR_VAR 0 4
33799: PUSH
33800: LD_VAR 0 4
33804: PUSH
33805: LD_INT 1
33807: PLUS
33808: ST_TO_ADDR
// if k > tmp then
33809: LD_VAR 0 4
33813: PUSH
33814: LD_VAR 0 5
33818: GREATER
33819: IFFALSE 33823
// break ;
33821: GO 33953
// if not GetClass ( j ) in [ 2 , 16 ] then
33823: LD_VAR 0 3
33827: PPUSH
33828: CALL_OW 257
33832: PUSH
33833: LD_INT 2
33835: PUSH
33836: LD_INT 16
33838: PUSH
33839: EMPTY
33840: LIST
33841: LIST
33842: IN
33843: NOT
33844: IFFALSE 33897
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
33846: LD_ADDR_EXP 91
33850: PUSH
33851: LD_EXP 91
33855: PPUSH
33856: LD_VAR 0 2
33860: PPUSH
33861: LD_EXP 91
33865: PUSH
33866: LD_VAR 0 2
33870: ARRAY
33871: PUSH
33872: LD_VAR 0 3
33876: DIFF
33877: PPUSH
33878: CALL_OW 1
33882: ST_TO_ADDR
// SetTag ( j , 0 ) ;
33883: LD_VAR 0 3
33887: PPUSH
33888: LD_INT 0
33890: PPUSH
33891: CALL_OW 109
// continue ;
33895: GO 33792
// end ; if IsInUnit ( j ) then
33897: LD_VAR 0 3
33901: PPUSH
33902: CALL_OW 310
33906: IFFALSE 33917
// ComExitBuilding ( j ) ;
33908: LD_VAR 0 3
33912: PPUSH
33913: CALL_OW 122
// wait ( 3 ) ;
33917: LD_INT 3
33919: PPUSH
33920: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33924: LD_VAR 0 3
33928: PPUSH
33929: LD_VAR 0 6
33933: PUSH
33934: LD_INT 2
33936: ARRAY
33937: PPUSH
33938: LD_VAR 0 6
33942: PUSH
33943: LD_INT 3
33945: ARRAY
33946: PPUSH
33947: CALL_OW 117
// end ;
33951: GO 33792
33953: POP
33954: POP
// end ; end else
33955: GO 34536
// begin for j in cargo do
33957: LD_ADDR_VAR 0 3
33961: PUSH
33962: LD_VAR 0 7
33966: PUSH
33967: FOR_IN
33968: IFFALSE 34534
// begin if GetTag ( j ) <> 0 then
33970: LD_VAR 0 3
33974: PPUSH
33975: CALL_OW 110
33979: PUSH
33980: LD_INT 0
33982: NONEQUAL
33983: IFFALSE 33987
// continue ;
33985: GO 33967
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33987: LD_VAR 0 3
33991: PPUSH
33992: CALL_OW 256
33996: PUSH
33997: LD_INT 1000
33999: LESS
34000: PUSH
34001: LD_VAR 0 3
34005: PPUSH
34006: LD_EXP 98
34010: PUSH
34011: LD_VAR 0 2
34015: ARRAY
34016: PPUSH
34017: CALL_OW 308
34021: NOT
34022: AND
34023: IFFALSE 34045
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34025: LD_VAR 0 3
34029: PPUSH
34030: LD_EXP 98
34034: PUSH
34035: LD_VAR 0 2
34039: ARRAY
34040: PPUSH
34041: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34045: LD_VAR 0 3
34049: PPUSH
34050: CALL_OW 256
34054: PUSH
34055: LD_INT 1000
34057: LESS
34058: PUSH
34059: LD_VAR 0 3
34063: PPUSH
34064: LD_EXP 98
34068: PUSH
34069: LD_VAR 0 2
34073: ARRAY
34074: PPUSH
34075: CALL_OW 308
34079: AND
34080: IFFALSE 34084
// continue ;
34082: GO 33967
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34084: LD_VAR 0 3
34088: PPUSH
34089: CALL_OW 262
34093: PUSH
34094: LD_INT 2
34096: EQUAL
34097: PUSH
34098: LD_VAR 0 3
34102: PPUSH
34103: CALL_OW 261
34107: PUSH
34108: LD_INT 15
34110: LESS
34111: AND
34112: IFFALSE 34116
// continue ;
34114: GO 33967
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34116: LD_VAR 0 3
34120: PPUSH
34121: CALL_OW 262
34125: PUSH
34126: LD_INT 1
34128: EQUAL
34129: PUSH
34130: LD_VAR 0 3
34134: PPUSH
34135: CALL_OW 261
34139: PUSH
34140: LD_INT 10
34142: LESS
34143: AND
34144: IFFALSE 34473
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34146: LD_ADDR_VAR 0 8
34150: PUSH
34151: LD_EXP 74
34155: PUSH
34156: LD_VAR 0 2
34160: ARRAY
34161: PPUSH
34162: LD_INT 2
34164: PUSH
34165: LD_INT 30
34167: PUSH
34168: LD_INT 0
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 30
34177: PUSH
34178: LD_INT 1
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: LIST
34189: PPUSH
34190: CALL_OW 72
34194: ST_TO_ADDR
// if not depot then
34195: LD_VAR 0 8
34199: NOT
34200: IFFALSE 34204
// continue ;
34202: GO 33967
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34204: LD_VAR 0 3
34208: PPUSH
34209: LD_VAR 0 8
34213: PPUSH
34214: LD_VAR 0 3
34218: PPUSH
34219: CALL_OW 74
34223: PPUSH
34224: CALL_OW 296
34228: PUSH
34229: LD_INT 6
34231: LESS
34232: IFFALSE 34248
// SetFuel ( j , 100 ) else
34234: LD_VAR 0 3
34238: PPUSH
34239: LD_INT 100
34241: PPUSH
34242: CALL_OW 240
34246: GO 34473
// if GetFuel ( j ) = 0 then
34248: LD_VAR 0 3
34252: PPUSH
34253: CALL_OW 261
34257: PUSH
34258: LD_INT 0
34260: EQUAL
34261: IFFALSE 34473
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
34263: LD_ADDR_EXP 93
34267: PUSH
34268: LD_EXP 93
34272: PPUSH
34273: LD_VAR 0 2
34277: PPUSH
34278: LD_EXP 93
34282: PUSH
34283: LD_VAR 0 2
34287: ARRAY
34288: PUSH
34289: LD_VAR 0 3
34293: DIFF
34294: PPUSH
34295: CALL_OW 1
34299: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
34300: LD_VAR 0 3
34304: PPUSH
34305: CALL_OW 263
34309: PUSH
34310: LD_INT 1
34312: EQUAL
34313: IFFALSE 34329
// ComExitVehicle ( IsInUnit ( j ) ) ;
34315: LD_VAR 0 3
34319: PPUSH
34320: CALL_OW 310
34324: PPUSH
34325: CALL_OW 121
// if GetControl ( j ) = control_remote then
34329: LD_VAR 0 3
34333: PPUSH
34334: CALL_OW 263
34338: PUSH
34339: LD_INT 2
34341: EQUAL
34342: IFFALSE 34353
// ComUnlink ( j ) ;
34344: LD_VAR 0 3
34348: PPUSH
34349: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
34353: LD_ADDR_VAR 0 9
34357: PUSH
34358: LD_VAR 0 2
34362: PPUSH
34363: LD_INT 3
34365: PPUSH
34366: CALL 43610 0 2
34370: ST_TO_ADDR
// if fac then
34371: LD_VAR 0 9
34375: IFFALSE 34471
// begin for k in fac do
34377: LD_ADDR_VAR 0 4
34381: PUSH
34382: LD_VAR 0 9
34386: PUSH
34387: FOR_IN
34388: IFFALSE 34469
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
34390: LD_ADDR_VAR 0 10
34394: PUSH
34395: LD_VAR 0 9
34399: PPUSH
34400: LD_VAR 0 3
34404: PPUSH
34405: CALL_OW 265
34409: PPUSH
34410: LD_VAR 0 3
34414: PPUSH
34415: CALL_OW 262
34419: PPUSH
34420: LD_VAR 0 3
34424: PPUSH
34425: CALL_OW 263
34429: PPUSH
34430: LD_VAR 0 3
34434: PPUSH
34435: CALL_OW 264
34439: PPUSH
34440: CALL 53770 0 5
34444: ST_TO_ADDR
// if components then
34445: LD_VAR 0 10
34449: IFFALSE 34467
// begin MC_InsertProduceList ( i , components ) ;
34451: LD_VAR 0 2
34455: PPUSH
34456: LD_VAR 0 10
34460: PPUSH
34461: CALL 43155 0 2
// break ;
34465: GO 34469
// end ; end ;
34467: GO 34387
34469: POP
34470: POP
// end ; continue ;
34471: GO 33967
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
34473: LD_VAR 0 3
34477: PPUSH
34478: LD_INT 1
34480: PPUSH
34481: CALL_OW 289
34485: PUSH
34486: LD_INT 100
34488: LESS
34489: PUSH
34490: LD_VAR 0 3
34494: PPUSH
34495: CALL_OW 314
34499: NOT
34500: AND
34501: IFFALSE 34530
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34503: LD_VAR 0 3
34507: PPUSH
34508: LD_VAR 0 6
34512: PUSH
34513: LD_INT 2
34515: ARRAY
34516: PPUSH
34517: LD_VAR 0 6
34521: PUSH
34522: LD_INT 3
34524: ARRAY
34525: PPUSH
34526: CALL_OW 117
// break ;
34530: GO 34534
// end ;
34532: GO 33967
34534: POP
34535: POP
// end ; end ;
34536: GO 32805
34538: POP
34539: POP
// end ;
34540: LD_VAR 0 1
34544: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
34545: LD_INT 0
34547: PPUSH
34548: PPUSH
34549: PPUSH
34550: PPUSH
// if not mc_bases then
34551: LD_EXP 74
34555: NOT
34556: IFFALSE 34560
// exit ;
34558: GO 34721
// for i = 1 to mc_bases do
34560: LD_ADDR_VAR 0 2
34564: PUSH
34565: DOUBLE
34566: LD_INT 1
34568: DEC
34569: ST_TO_ADDR
34570: LD_EXP 74
34574: PUSH
34575: FOR_TO
34576: IFFALSE 34719
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
34578: LD_ADDR_VAR 0 4
34582: PUSH
34583: LD_EXP 93
34587: PUSH
34588: LD_VAR 0 2
34592: ARRAY
34593: PUSH
34594: LD_EXP 96
34598: PUSH
34599: LD_VAR 0 2
34603: ARRAY
34604: UNION
34605: PPUSH
34606: LD_INT 33
34608: PUSH
34609: LD_INT 2
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PPUSH
34616: CALL_OW 72
34620: ST_TO_ADDR
// if tmp then
34621: LD_VAR 0 4
34625: IFFALSE 34717
// for j in tmp do
34627: LD_ADDR_VAR 0 3
34631: PUSH
34632: LD_VAR 0 4
34636: PUSH
34637: FOR_IN
34638: IFFALSE 34715
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
34640: LD_VAR 0 3
34644: PPUSH
34645: CALL_OW 312
34649: NOT
34650: PUSH
34651: LD_VAR 0 3
34655: PPUSH
34656: CALL_OW 256
34660: PUSH
34661: LD_INT 250
34663: GREATEREQUAL
34664: AND
34665: IFFALSE 34678
// Connect ( j ) else
34667: LD_VAR 0 3
34671: PPUSH
34672: CALL 59171 0 1
34676: GO 34713
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
34678: LD_VAR 0 3
34682: PPUSH
34683: CALL_OW 256
34687: PUSH
34688: LD_INT 250
34690: LESS
34691: PUSH
34692: LD_VAR 0 3
34696: PPUSH
34697: CALL_OW 312
34701: AND
34702: IFFALSE 34713
// ComUnlink ( j ) ;
34704: LD_VAR 0 3
34708: PPUSH
34709: CALL_OW 136
34713: GO 34637
34715: POP
34716: POP
// end ;
34717: GO 34575
34719: POP
34720: POP
// end ;
34721: LD_VAR 0 1
34725: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
34726: LD_INT 0
34728: PPUSH
34729: PPUSH
34730: PPUSH
34731: PPUSH
34732: PPUSH
// if not mc_bases then
34733: LD_EXP 74
34737: NOT
34738: IFFALSE 34742
// exit ;
34740: GO 35187
// for i = 1 to mc_bases do
34742: LD_ADDR_VAR 0 2
34746: PUSH
34747: DOUBLE
34748: LD_INT 1
34750: DEC
34751: ST_TO_ADDR
34752: LD_EXP 74
34756: PUSH
34757: FOR_TO
34758: IFFALSE 35185
// begin if not mc_produce [ i ] then
34760: LD_EXP 95
34764: PUSH
34765: LD_VAR 0 2
34769: ARRAY
34770: NOT
34771: IFFALSE 34775
// continue ;
34773: GO 34757
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34775: LD_ADDR_VAR 0 5
34779: PUSH
34780: LD_EXP 74
34784: PUSH
34785: LD_VAR 0 2
34789: ARRAY
34790: PPUSH
34791: LD_INT 30
34793: PUSH
34794: LD_INT 3
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PPUSH
34801: CALL_OW 72
34805: ST_TO_ADDR
// if not fac then
34806: LD_VAR 0 5
34810: NOT
34811: IFFALSE 34815
// continue ;
34813: GO 34757
// for j in fac do
34815: LD_ADDR_VAR 0 3
34819: PUSH
34820: LD_VAR 0 5
34824: PUSH
34825: FOR_IN
34826: IFFALSE 35181
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
34828: LD_VAR 0 3
34832: PPUSH
34833: CALL_OW 461
34837: PUSH
34838: LD_INT 2
34840: NONEQUAL
34841: PUSH
34842: LD_VAR 0 3
34846: PPUSH
34847: LD_INT 15
34849: PPUSH
34850: CALL 58831 0 2
34854: PUSH
34855: LD_INT 4
34857: ARRAY
34858: OR
34859: IFFALSE 34863
// continue ;
34861: GO 34825
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
34863: LD_VAR 0 3
34867: PPUSH
34868: LD_EXP 95
34872: PUSH
34873: LD_VAR 0 2
34877: ARRAY
34878: PUSH
34879: LD_INT 1
34881: ARRAY
34882: PUSH
34883: LD_INT 1
34885: ARRAY
34886: PPUSH
34887: LD_EXP 95
34891: PUSH
34892: LD_VAR 0 2
34896: ARRAY
34897: PUSH
34898: LD_INT 1
34900: ARRAY
34901: PUSH
34902: LD_INT 2
34904: ARRAY
34905: PPUSH
34906: LD_EXP 95
34910: PUSH
34911: LD_VAR 0 2
34915: ARRAY
34916: PUSH
34917: LD_INT 1
34919: ARRAY
34920: PUSH
34921: LD_INT 3
34923: ARRAY
34924: PPUSH
34925: LD_EXP 95
34929: PUSH
34930: LD_VAR 0 2
34934: ARRAY
34935: PUSH
34936: LD_INT 1
34938: ARRAY
34939: PUSH
34940: LD_INT 4
34942: ARRAY
34943: PPUSH
34944: CALL_OW 448
34948: PUSH
34949: LD_VAR 0 3
34953: PPUSH
34954: LD_EXP 95
34958: PUSH
34959: LD_VAR 0 2
34963: ARRAY
34964: PUSH
34965: LD_INT 1
34967: ARRAY
34968: PUSH
34969: LD_INT 1
34971: ARRAY
34972: PUSH
34973: LD_EXP 95
34977: PUSH
34978: LD_VAR 0 2
34982: ARRAY
34983: PUSH
34984: LD_INT 1
34986: ARRAY
34987: PUSH
34988: LD_INT 2
34990: ARRAY
34991: PUSH
34992: LD_EXP 95
34996: PUSH
34997: LD_VAR 0 2
35001: ARRAY
35002: PUSH
35003: LD_INT 1
35005: ARRAY
35006: PUSH
35007: LD_INT 3
35009: ARRAY
35010: PUSH
35011: LD_EXP 95
35015: PUSH
35016: LD_VAR 0 2
35020: ARRAY
35021: PUSH
35022: LD_INT 1
35024: ARRAY
35025: PUSH
35026: LD_INT 4
35028: ARRAY
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: LIST
35034: LIST
35035: PPUSH
35036: CALL 62502 0 2
35040: AND
35041: IFFALSE 35179
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35043: LD_VAR 0 3
35047: PPUSH
35048: LD_EXP 95
35052: PUSH
35053: LD_VAR 0 2
35057: ARRAY
35058: PUSH
35059: LD_INT 1
35061: ARRAY
35062: PUSH
35063: LD_INT 1
35065: ARRAY
35066: PPUSH
35067: LD_EXP 95
35071: PUSH
35072: LD_VAR 0 2
35076: ARRAY
35077: PUSH
35078: LD_INT 1
35080: ARRAY
35081: PUSH
35082: LD_INT 2
35084: ARRAY
35085: PPUSH
35086: LD_EXP 95
35090: PUSH
35091: LD_VAR 0 2
35095: ARRAY
35096: PUSH
35097: LD_INT 1
35099: ARRAY
35100: PUSH
35101: LD_INT 3
35103: ARRAY
35104: PPUSH
35105: LD_EXP 95
35109: PUSH
35110: LD_VAR 0 2
35114: ARRAY
35115: PUSH
35116: LD_INT 1
35118: ARRAY
35119: PUSH
35120: LD_INT 4
35122: ARRAY
35123: PPUSH
35124: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35128: LD_ADDR_VAR 0 4
35132: PUSH
35133: LD_EXP 95
35137: PUSH
35138: LD_VAR 0 2
35142: ARRAY
35143: PPUSH
35144: LD_INT 1
35146: PPUSH
35147: CALL_OW 3
35151: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35152: LD_ADDR_EXP 95
35156: PUSH
35157: LD_EXP 95
35161: PPUSH
35162: LD_VAR 0 2
35166: PPUSH
35167: LD_VAR 0 4
35171: PPUSH
35172: CALL_OW 1
35176: ST_TO_ADDR
// break ;
35177: GO 35181
// end ; end ;
35179: GO 34825
35181: POP
35182: POP
// end ;
35183: GO 34757
35185: POP
35186: POP
// end ;
35187: LD_VAR 0 1
35191: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35192: LD_INT 0
35194: PPUSH
35195: PPUSH
35196: PPUSH
// if not mc_bases then
35197: LD_EXP 74
35201: NOT
35202: IFFALSE 35206
// exit ;
35204: GO 35295
// for i = 1 to mc_bases do
35206: LD_ADDR_VAR 0 2
35210: PUSH
35211: DOUBLE
35212: LD_INT 1
35214: DEC
35215: ST_TO_ADDR
35216: LD_EXP 74
35220: PUSH
35221: FOR_TO
35222: IFFALSE 35293
// begin if mc_attack [ i ] then
35224: LD_EXP 94
35228: PUSH
35229: LD_VAR 0 2
35233: ARRAY
35234: IFFALSE 35291
// begin tmp := mc_attack [ i ] [ 1 ] ;
35236: LD_ADDR_VAR 0 3
35240: PUSH
35241: LD_EXP 94
35245: PUSH
35246: LD_VAR 0 2
35250: ARRAY
35251: PUSH
35252: LD_INT 1
35254: ARRAY
35255: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35256: LD_ADDR_EXP 94
35260: PUSH
35261: LD_EXP 94
35265: PPUSH
35266: LD_VAR 0 2
35270: PPUSH
35271: EMPTY
35272: PPUSH
35273: CALL_OW 1
35277: ST_TO_ADDR
// Attack ( tmp ) ;
35278: LD_VAR 0 3
35282: PPUSH
35283: CALL 84715 0 1
// exit ;
35287: POP
35288: POP
35289: GO 35295
// end ; end ;
35291: GO 35221
35293: POP
35294: POP
// end ;
35295: LD_VAR 0 1
35299: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
35300: LD_INT 0
35302: PPUSH
35303: PPUSH
35304: PPUSH
35305: PPUSH
35306: PPUSH
35307: PPUSH
35308: PPUSH
// if not mc_bases then
35309: LD_EXP 74
35313: NOT
35314: IFFALSE 35318
// exit ;
35316: GO 35900
// for i = 1 to mc_bases do
35318: LD_ADDR_VAR 0 2
35322: PUSH
35323: DOUBLE
35324: LD_INT 1
35326: DEC
35327: ST_TO_ADDR
35328: LD_EXP 74
35332: PUSH
35333: FOR_TO
35334: IFFALSE 35898
// begin if not mc_bases [ i ] then
35336: LD_EXP 74
35340: PUSH
35341: LD_VAR 0 2
35345: ARRAY
35346: NOT
35347: IFFALSE 35351
// continue ;
35349: GO 35333
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
35351: LD_ADDR_VAR 0 7
35355: PUSH
35356: LD_EXP 74
35360: PUSH
35361: LD_VAR 0 2
35365: ARRAY
35366: PUSH
35367: LD_INT 1
35369: ARRAY
35370: PPUSH
35371: CALL 53074 0 1
35375: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
35376: LD_ADDR_EXP 97
35380: PUSH
35381: LD_EXP 97
35385: PPUSH
35386: LD_VAR 0 2
35390: PPUSH
35391: LD_EXP 74
35395: PUSH
35396: LD_VAR 0 2
35400: ARRAY
35401: PUSH
35402: LD_INT 1
35404: ARRAY
35405: PPUSH
35406: CALL_OW 255
35410: PPUSH
35411: LD_EXP 99
35415: PUSH
35416: LD_VAR 0 2
35420: ARRAY
35421: PPUSH
35422: CALL 50992 0 2
35426: PPUSH
35427: CALL_OW 1
35431: ST_TO_ADDR
// if not mc_scan [ i ] then
35432: LD_EXP 97
35436: PUSH
35437: LD_VAR 0 2
35441: ARRAY
35442: NOT
35443: IFFALSE 35598
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35445: LD_ADDR_VAR 0 4
35449: PUSH
35450: LD_EXP 74
35454: PUSH
35455: LD_VAR 0 2
35459: ARRAY
35460: PPUSH
35461: LD_INT 2
35463: PUSH
35464: LD_INT 25
35466: PUSH
35467: LD_INT 5
35469: PUSH
35470: EMPTY
35471: LIST
35472: LIST
35473: PUSH
35474: LD_INT 25
35476: PUSH
35477: LD_INT 8
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 25
35486: PUSH
35487: LD_INT 9
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: PPUSH
35500: CALL_OW 72
35504: ST_TO_ADDR
// if not tmp then
35505: LD_VAR 0 4
35509: NOT
35510: IFFALSE 35514
// continue ;
35512: GO 35333
// for j in tmp do
35514: LD_ADDR_VAR 0 3
35518: PUSH
35519: LD_VAR 0 4
35523: PUSH
35524: FOR_IN
35525: IFFALSE 35596
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
35527: LD_VAR 0 3
35531: PPUSH
35532: CALL_OW 310
35536: PPUSH
35537: CALL_OW 266
35541: PUSH
35542: LD_INT 5
35544: EQUAL
35545: PUSH
35546: LD_VAR 0 3
35550: PPUSH
35551: CALL_OW 257
35555: PUSH
35556: LD_INT 1
35558: EQUAL
35559: AND
35560: PUSH
35561: LD_VAR 0 3
35565: PPUSH
35566: CALL_OW 459
35570: NOT
35571: AND
35572: PUSH
35573: LD_VAR 0 7
35577: AND
35578: IFFALSE 35594
// ComChangeProfession ( j , class ) ;
35580: LD_VAR 0 3
35584: PPUSH
35585: LD_VAR 0 7
35589: PPUSH
35590: CALL_OW 123
35594: GO 35524
35596: POP
35597: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
35598: LD_EXP 97
35602: PUSH
35603: LD_VAR 0 2
35607: ARRAY
35608: PUSH
35609: LD_EXP 96
35613: PUSH
35614: LD_VAR 0 2
35618: ARRAY
35619: NOT
35620: AND
35621: PUSH
35622: LD_EXP 74
35626: PUSH
35627: LD_VAR 0 2
35631: ARRAY
35632: PPUSH
35633: LD_INT 30
35635: PUSH
35636: LD_INT 32
35638: PUSH
35639: EMPTY
35640: LIST
35641: LIST
35642: PPUSH
35643: CALL_OW 72
35647: NOT
35648: AND
35649: PUSH
35650: LD_EXP 74
35654: PUSH
35655: LD_VAR 0 2
35659: ARRAY
35660: PPUSH
35661: LD_INT 2
35663: PUSH
35664: LD_INT 30
35666: PUSH
35667: LD_INT 4
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 30
35676: PUSH
35677: LD_INT 5
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: EMPTY
35685: LIST
35686: LIST
35687: LIST
35688: PPUSH
35689: CALL_OW 72
35693: NOT
35694: AND
35695: IFFALSE 35827
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35697: LD_ADDR_VAR 0 4
35701: PUSH
35702: LD_EXP 74
35706: PUSH
35707: LD_VAR 0 2
35711: ARRAY
35712: PPUSH
35713: LD_INT 2
35715: PUSH
35716: LD_INT 25
35718: PUSH
35719: LD_INT 1
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 25
35728: PUSH
35729: LD_INT 5
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 25
35738: PUSH
35739: LD_INT 8
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 25
35748: PUSH
35749: LD_INT 9
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: PPUSH
35763: CALL_OW 72
35767: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
35768: LD_ADDR_VAR 0 4
35772: PUSH
35773: LD_VAR 0 4
35777: PUSH
35778: LD_VAR 0 4
35782: PPUSH
35783: LD_INT 18
35785: PPUSH
35786: CALL 89498 0 2
35790: DIFF
35791: ST_TO_ADDR
// if tmp then
35792: LD_VAR 0 4
35796: IFFALSE 35827
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
35798: LD_VAR 0 2
35802: PPUSH
35803: LD_VAR 0 4
35807: PPUSH
35808: LD_EXP 99
35812: PUSH
35813: LD_VAR 0 2
35817: ARRAY
35818: PPUSH
35819: CALL 51027 0 3
// exit ;
35823: POP
35824: POP
35825: GO 35900
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
35827: LD_EXP 97
35831: PUSH
35832: LD_VAR 0 2
35836: ARRAY
35837: PUSH
35838: LD_EXP 96
35842: PUSH
35843: LD_VAR 0 2
35847: ARRAY
35848: AND
35849: IFFALSE 35896
// begin tmp := mc_defender [ i ] ;
35851: LD_ADDR_VAR 0 4
35855: PUSH
35856: LD_EXP 96
35860: PUSH
35861: LD_VAR 0 2
35865: ARRAY
35866: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
35867: LD_VAR 0 2
35871: PPUSH
35872: LD_VAR 0 4
35876: PPUSH
35877: LD_EXP 97
35881: PUSH
35882: LD_VAR 0 2
35886: ARRAY
35887: PPUSH
35888: CALL 51525 0 3
// exit ;
35892: POP
35893: POP
35894: GO 35900
// end ; end ;
35896: GO 35333
35898: POP
35899: POP
// end ;
35900: LD_VAR 0 1
35904: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35905: LD_INT 0
35907: PPUSH
35908: PPUSH
35909: PPUSH
35910: PPUSH
35911: PPUSH
35912: PPUSH
35913: PPUSH
35914: PPUSH
35915: PPUSH
35916: PPUSH
35917: PPUSH
// if not mc_bases then
35918: LD_EXP 74
35922: NOT
35923: IFFALSE 35927
// exit ;
35925: GO 37014
// for i = 1 to mc_bases do
35927: LD_ADDR_VAR 0 2
35931: PUSH
35932: DOUBLE
35933: LD_INT 1
35935: DEC
35936: ST_TO_ADDR
35937: LD_EXP 74
35941: PUSH
35942: FOR_TO
35943: IFFALSE 37012
// begin tmp := mc_lab [ i ] ;
35945: LD_ADDR_VAR 0 6
35949: PUSH
35950: LD_EXP 107
35954: PUSH
35955: LD_VAR 0 2
35959: ARRAY
35960: ST_TO_ADDR
// if not tmp then
35961: LD_VAR 0 6
35965: NOT
35966: IFFALSE 35970
// continue ;
35968: GO 35942
// idle_lab := 0 ;
35970: LD_ADDR_VAR 0 11
35974: PUSH
35975: LD_INT 0
35977: ST_TO_ADDR
// for j in tmp do
35978: LD_ADDR_VAR 0 3
35982: PUSH
35983: LD_VAR 0 6
35987: PUSH
35988: FOR_IN
35989: IFFALSE 37008
// begin researching := false ;
35991: LD_ADDR_VAR 0 10
35995: PUSH
35996: LD_INT 0
35998: ST_TO_ADDR
// side := GetSide ( j ) ;
35999: LD_ADDR_VAR 0 4
36003: PUSH
36004: LD_VAR 0 3
36008: PPUSH
36009: CALL_OW 255
36013: ST_TO_ADDR
// if not mc_tech [ side ] then
36014: LD_EXP 101
36018: PUSH
36019: LD_VAR 0 4
36023: ARRAY
36024: NOT
36025: IFFALSE 36029
// continue ;
36027: GO 35988
// if BuildingStatus ( j ) = bs_idle then
36029: LD_VAR 0 3
36033: PPUSH
36034: CALL_OW 461
36038: PUSH
36039: LD_INT 2
36041: EQUAL
36042: IFFALSE 36230
// begin if idle_lab and UnitsInside ( j ) < 6 then
36044: LD_VAR 0 11
36048: PUSH
36049: LD_VAR 0 3
36053: PPUSH
36054: CALL_OW 313
36058: PUSH
36059: LD_INT 6
36061: LESS
36062: AND
36063: IFFALSE 36134
// begin tmp2 := UnitsInside ( idle_lab ) ;
36065: LD_ADDR_VAR 0 9
36069: PUSH
36070: LD_VAR 0 11
36074: PPUSH
36075: CALL_OW 313
36079: ST_TO_ADDR
// if tmp2 then
36080: LD_VAR 0 9
36084: IFFALSE 36126
// for x in tmp2 do
36086: LD_ADDR_VAR 0 7
36090: PUSH
36091: LD_VAR 0 9
36095: PUSH
36096: FOR_IN
36097: IFFALSE 36124
// begin ComExitBuilding ( x ) ;
36099: LD_VAR 0 7
36103: PPUSH
36104: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36108: LD_VAR 0 7
36112: PPUSH
36113: LD_VAR 0 3
36117: PPUSH
36118: CALL_OW 180
// end ;
36122: GO 36096
36124: POP
36125: POP
// idle_lab := 0 ;
36126: LD_ADDR_VAR 0 11
36130: PUSH
36131: LD_INT 0
36133: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36134: LD_ADDR_VAR 0 5
36138: PUSH
36139: LD_EXP 101
36143: PUSH
36144: LD_VAR 0 4
36148: ARRAY
36149: PUSH
36150: FOR_IN
36151: IFFALSE 36211
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36153: LD_VAR 0 3
36157: PPUSH
36158: LD_VAR 0 5
36162: PPUSH
36163: CALL_OW 430
36167: PUSH
36168: LD_VAR 0 4
36172: PPUSH
36173: LD_VAR 0 5
36177: PPUSH
36178: CALL 50097 0 2
36182: AND
36183: IFFALSE 36209
// begin researching := true ;
36185: LD_ADDR_VAR 0 10
36189: PUSH
36190: LD_INT 1
36192: ST_TO_ADDR
// ComResearch ( j , t ) ;
36193: LD_VAR 0 3
36197: PPUSH
36198: LD_VAR 0 5
36202: PPUSH
36203: CALL_OW 124
// break ;
36207: GO 36211
// end ;
36209: GO 36150
36211: POP
36212: POP
// if not researching then
36213: LD_VAR 0 10
36217: NOT
36218: IFFALSE 36230
// idle_lab := j ;
36220: LD_ADDR_VAR 0 11
36224: PUSH
36225: LD_VAR 0 3
36229: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
36230: LD_VAR 0 3
36234: PPUSH
36235: CALL_OW 461
36239: PUSH
36240: LD_INT 10
36242: EQUAL
36243: IFFALSE 36831
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
36245: LD_EXP 103
36249: PUSH
36250: LD_VAR 0 2
36254: ARRAY
36255: NOT
36256: PUSH
36257: LD_EXP 104
36261: PUSH
36262: LD_VAR 0 2
36266: ARRAY
36267: NOT
36268: AND
36269: PUSH
36270: LD_EXP 101
36274: PUSH
36275: LD_VAR 0 4
36279: ARRAY
36280: PUSH
36281: LD_INT 1
36283: GREATER
36284: AND
36285: IFFALSE 36416
// begin ComCancel ( j ) ;
36287: LD_VAR 0 3
36291: PPUSH
36292: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36296: LD_ADDR_EXP 101
36300: PUSH
36301: LD_EXP 101
36305: PPUSH
36306: LD_VAR 0 4
36310: PPUSH
36311: LD_EXP 101
36315: PUSH
36316: LD_VAR 0 4
36320: ARRAY
36321: PPUSH
36322: LD_EXP 101
36326: PUSH
36327: LD_VAR 0 4
36331: ARRAY
36332: PUSH
36333: LD_INT 1
36335: MINUS
36336: PPUSH
36337: LD_EXP 101
36341: PUSH
36342: LD_VAR 0 4
36346: ARRAY
36347: PPUSH
36348: LD_INT 0
36350: PPUSH
36351: CALL 55656 0 4
36355: PPUSH
36356: CALL_OW 1
36360: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
36361: LD_ADDR_EXP 101
36365: PUSH
36366: LD_EXP 101
36370: PPUSH
36371: LD_VAR 0 4
36375: PPUSH
36376: LD_EXP 101
36380: PUSH
36381: LD_VAR 0 4
36385: ARRAY
36386: PPUSH
36387: LD_EXP 101
36391: PUSH
36392: LD_VAR 0 4
36396: ARRAY
36397: PPUSH
36398: LD_INT 1
36400: PPUSH
36401: LD_INT 0
36403: PPUSH
36404: CALL 55656 0 4
36408: PPUSH
36409: CALL_OW 1
36413: ST_TO_ADDR
// continue ;
36414: GO 35988
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
36416: LD_EXP 103
36420: PUSH
36421: LD_VAR 0 2
36425: ARRAY
36426: PUSH
36427: LD_EXP 104
36431: PUSH
36432: LD_VAR 0 2
36436: ARRAY
36437: NOT
36438: AND
36439: IFFALSE 36566
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
36441: LD_ADDR_EXP 104
36445: PUSH
36446: LD_EXP 104
36450: PPUSH
36451: LD_VAR 0 2
36455: PUSH
36456: LD_EXP 104
36460: PUSH
36461: LD_VAR 0 2
36465: ARRAY
36466: PUSH
36467: LD_INT 1
36469: PLUS
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PPUSH
36475: LD_EXP 103
36479: PUSH
36480: LD_VAR 0 2
36484: ARRAY
36485: PUSH
36486: LD_INT 1
36488: ARRAY
36489: PPUSH
36490: CALL 56238 0 3
36494: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
36495: LD_EXP 103
36499: PUSH
36500: LD_VAR 0 2
36504: ARRAY
36505: PUSH
36506: LD_INT 1
36508: ARRAY
36509: PPUSH
36510: LD_INT 112
36512: PPUSH
36513: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
36517: LD_ADDR_VAR 0 9
36521: PUSH
36522: LD_EXP 103
36526: PUSH
36527: LD_VAR 0 2
36531: ARRAY
36532: PPUSH
36533: LD_INT 1
36535: PPUSH
36536: CALL_OW 3
36540: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
36541: LD_ADDR_EXP 103
36545: PUSH
36546: LD_EXP 103
36550: PPUSH
36551: LD_VAR 0 2
36555: PPUSH
36556: LD_VAR 0 9
36560: PPUSH
36561: CALL_OW 1
36565: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
36566: LD_EXP 103
36570: PUSH
36571: LD_VAR 0 2
36575: ARRAY
36576: PUSH
36577: LD_EXP 104
36581: PUSH
36582: LD_VAR 0 2
36586: ARRAY
36587: AND
36588: PUSH
36589: LD_EXP 104
36593: PUSH
36594: LD_VAR 0 2
36598: ARRAY
36599: PUSH
36600: LD_INT 1
36602: ARRAY
36603: PPUSH
36604: CALL_OW 310
36608: NOT
36609: AND
36610: PUSH
36611: LD_VAR 0 3
36615: PPUSH
36616: CALL_OW 313
36620: PUSH
36621: LD_INT 6
36623: EQUAL
36624: AND
36625: IFFALSE 36681
// begin tmp2 := UnitsInside ( j ) ;
36627: LD_ADDR_VAR 0 9
36631: PUSH
36632: LD_VAR 0 3
36636: PPUSH
36637: CALL_OW 313
36641: ST_TO_ADDR
// if tmp2 = 6 then
36642: LD_VAR 0 9
36646: PUSH
36647: LD_INT 6
36649: EQUAL
36650: IFFALSE 36681
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
36652: LD_VAR 0 9
36656: PUSH
36657: LD_INT 1
36659: ARRAY
36660: PPUSH
36661: LD_INT 112
36663: PPUSH
36664: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
36668: LD_VAR 0 9
36672: PUSH
36673: LD_INT 1
36675: ARRAY
36676: PPUSH
36677: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
36681: LD_EXP 104
36685: PUSH
36686: LD_VAR 0 2
36690: ARRAY
36691: PUSH
36692: LD_EXP 104
36696: PUSH
36697: LD_VAR 0 2
36701: ARRAY
36702: PUSH
36703: LD_INT 1
36705: ARRAY
36706: PPUSH
36707: CALL_OW 314
36711: NOT
36712: AND
36713: PUSH
36714: LD_EXP 104
36718: PUSH
36719: LD_VAR 0 2
36723: ARRAY
36724: PUSH
36725: LD_INT 1
36727: ARRAY
36728: PPUSH
36729: CALL_OW 310
36733: NOT
36734: AND
36735: IFFALSE 36761
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36737: LD_EXP 104
36741: PUSH
36742: LD_VAR 0 2
36746: ARRAY
36747: PUSH
36748: LD_INT 1
36750: ARRAY
36751: PPUSH
36752: LD_VAR 0 3
36756: PPUSH
36757: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36761: LD_EXP 104
36765: PUSH
36766: LD_VAR 0 2
36770: ARRAY
36771: PUSH
36772: LD_INT 1
36774: ARRAY
36775: PPUSH
36776: CALL_OW 310
36780: PUSH
36781: LD_EXP 104
36785: PUSH
36786: LD_VAR 0 2
36790: ARRAY
36791: PUSH
36792: LD_INT 1
36794: ARRAY
36795: PPUSH
36796: CALL_OW 310
36800: PPUSH
36801: CALL_OW 461
36805: PUSH
36806: LD_INT 3
36808: NONEQUAL
36809: AND
36810: IFFALSE 36831
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36812: LD_EXP 104
36816: PUSH
36817: LD_VAR 0 2
36821: ARRAY
36822: PUSH
36823: LD_INT 1
36825: ARRAY
36826: PPUSH
36827: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36831: LD_VAR 0 3
36835: PPUSH
36836: CALL_OW 461
36840: PUSH
36841: LD_INT 6
36843: EQUAL
36844: PUSH
36845: LD_VAR 0 6
36849: PUSH
36850: LD_INT 1
36852: GREATER
36853: AND
36854: IFFALSE 37006
// begin sci := [ ] ;
36856: LD_ADDR_VAR 0 8
36860: PUSH
36861: EMPTY
36862: ST_TO_ADDR
// for x in ( tmp diff j ) do
36863: LD_ADDR_VAR 0 7
36867: PUSH
36868: LD_VAR 0 6
36872: PUSH
36873: LD_VAR 0 3
36877: DIFF
36878: PUSH
36879: FOR_IN
36880: IFFALSE 36932
// begin if sci = 6 then
36882: LD_VAR 0 8
36886: PUSH
36887: LD_INT 6
36889: EQUAL
36890: IFFALSE 36894
// break ;
36892: GO 36932
// if BuildingStatus ( x ) = bs_idle then
36894: LD_VAR 0 7
36898: PPUSH
36899: CALL_OW 461
36903: PUSH
36904: LD_INT 2
36906: EQUAL
36907: IFFALSE 36930
// sci := sci ^ UnitsInside ( x ) ;
36909: LD_ADDR_VAR 0 8
36913: PUSH
36914: LD_VAR 0 8
36918: PUSH
36919: LD_VAR 0 7
36923: PPUSH
36924: CALL_OW 313
36928: ADD
36929: ST_TO_ADDR
// end ;
36930: GO 36879
36932: POP
36933: POP
// if not sci then
36934: LD_VAR 0 8
36938: NOT
36939: IFFALSE 36943
// continue ;
36941: GO 35988
// for x in sci do
36943: LD_ADDR_VAR 0 7
36947: PUSH
36948: LD_VAR 0 8
36952: PUSH
36953: FOR_IN
36954: IFFALSE 37004
// if IsInUnit ( x ) and not HasTask ( x ) then
36956: LD_VAR 0 7
36960: PPUSH
36961: CALL_OW 310
36965: PUSH
36966: LD_VAR 0 7
36970: PPUSH
36971: CALL_OW 314
36975: NOT
36976: AND
36977: IFFALSE 37002
// begin ComExitBuilding ( x ) ;
36979: LD_VAR 0 7
36983: PPUSH
36984: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36988: LD_VAR 0 7
36992: PPUSH
36993: LD_VAR 0 3
36997: PPUSH
36998: CALL_OW 180
// end ;
37002: GO 36953
37004: POP
37005: POP
// end ; end ;
37006: GO 35988
37008: POP
37009: POP
// end ;
37010: GO 35942
37012: POP
37013: POP
// end ;
37014: LD_VAR 0 1
37018: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37019: LD_INT 0
37021: PPUSH
37022: PPUSH
// if not mc_bases then
37023: LD_EXP 74
37027: NOT
37028: IFFALSE 37032
// exit ;
37030: GO 37113
// for i = 1 to mc_bases do
37032: LD_ADDR_VAR 0 2
37036: PUSH
37037: DOUBLE
37038: LD_INT 1
37040: DEC
37041: ST_TO_ADDR
37042: LD_EXP 74
37046: PUSH
37047: FOR_TO
37048: IFFALSE 37111
// if mc_mines [ i ] and mc_miners [ i ] then
37050: LD_EXP 87
37054: PUSH
37055: LD_VAR 0 2
37059: ARRAY
37060: PUSH
37061: LD_EXP 88
37065: PUSH
37066: LD_VAR 0 2
37070: ARRAY
37071: AND
37072: IFFALSE 37109
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37074: LD_EXP 88
37078: PUSH
37079: LD_VAR 0 2
37083: ARRAY
37084: PUSH
37085: LD_INT 1
37087: ARRAY
37088: PPUSH
37089: CALL_OW 255
37093: PPUSH
37094: LD_EXP 87
37098: PUSH
37099: LD_VAR 0 2
37103: ARRAY
37104: PPUSH
37105: CALL 53227 0 2
37109: GO 37047
37111: POP
37112: POP
// end ;
37113: LD_VAR 0 1
37117: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37118: LD_INT 0
37120: PPUSH
37121: PPUSH
37122: PPUSH
37123: PPUSH
37124: PPUSH
37125: PPUSH
37126: PPUSH
37127: PPUSH
// if not mc_bases or not mc_parking then
37128: LD_EXP 74
37132: NOT
37133: PUSH
37134: LD_EXP 98
37138: NOT
37139: OR
37140: IFFALSE 37144
// exit ;
37142: GO 37843
// for i = 1 to mc_bases do
37144: LD_ADDR_VAR 0 2
37148: PUSH
37149: DOUBLE
37150: LD_INT 1
37152: DEC
37153: ST_TO_ADDR
37154: LD_EXP 74
37158: PUSH
37159: FOR_TO
37160: IFFALSE 37841
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37162: LD_EXP 74
37166: PUSH
37167: LD_VAR 0 2
37171: ARRAY
37172: NOT
37173: PUSH
37174: LD_EXP 98
37178: PUSH
37179: LD_VAR 0 2
37183: ARRAY
37184: NOT
37185: OR
37186: IFFALSE 37190
// continue ;
37188: GO 37159
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37190: LD_ADDR_VAR 0 5
37194: PUSH
37195: LD_EXP 74
37199: PUSH
37200: LD_VAR 0 2
37204: ARRAY
37205: PUSH
37206: LD_INT 1
37208: ARRAY
37209: PPUSH
37210: CALL_OW 255
37214: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37215: LD_ADDR_VAR 0 6
37219: PUSH
37220: LD_EXP 74
37224: PUSH
37225: LD_VAR 0 2
37229: ARRAY
37230: PPUSH
37231: LD_INT 30
37233: PUSH
37234: LD_INT 3
37236: PUSH
37237: EMPTY
37238: LIST
37239: LIST
37240: PPUSH
37241: CALL_OW 72
37245: ST_TO_ADDR
// if not fac then
37246: LD_VAR 0 6
37250: NOT
37251: IFFALSE 37302
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37253: LD_ADDR_VAR 0 6
37257: PUSH
37258: LD_EXP 74
37262: PUSH
37263: LD_VAR 0 2
37267: ARRAY
37268: PPUSH
37269: LD_INT 2
37271: PUSH
37272: LD_INT 30
37274: PUSH
37275: LD_INT 0
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 30
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: LIST
37296: PPUSH
37297: CALL_OW 72
37301: ST_TO_ADDR
// if not fac then
37302: LD_VAR 0 6
37306: NOT
37307: IFFALSE 37311
// continue ;
37309: GO 37159
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37311: LD_ADDR_VAR 0 7
37315: PUSH
37316: LD_EXP 98
37320: PUSH
37321: LD_VAR 0 2
37325: ARRAY
37326: PPUSH
37327: LD_INT 22
37329: PUSH
37330: LD_VAR 0 5
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 21
37341: PUSH
37342: LD_INT 2
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 3
37351: PUSH
37352: LD_INT 24
37354: PUSH
37355: LD_INT 1000
37357: PUSH
37358: EMPTY
37359: LIST
37360: LIST
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: EMPTY
37367: LIST
37368: LIST
37369: LIST
37370: PPUSH
37371: CALL_OW 70
37375: ST_TO_ADDR
// for j in fac do
37376: LD_ADDR_VAR 0 3
37380: PUSH
37381: LD_VAR 0 6
37385: PUSH
37386: FOR_IN
37387: IFFALSE 37468
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37389: LD_ADDR_VAR 0 7
37393: PUSH
37394: LD_VAR 0 7
37398: PUSH
37399: LD_INT 22
37401: PUSH
37402: LD_VAR 0 5
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 91
37413: PUSH
37414: LD_VAR 0 3
37418: PUSH
37419: LD_INT 15
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: LIST
37426: PUSH
37427: LD_INT 21
37429: PUSH
37430: LD_INT 2
37432: PUSH
37433: EMPTY
37434: LIST
37435: LIST
37436: PUSH
37437: LD_INT 3
37439: PUSH
37440: LD_INT 24
37442: PUSH
37443: LD_INT 1000
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: PUSH
37454: EMPTY
37455: LIST
37456: LIST
37457: LIST
37458: LIST
37459: PPUSH
37460: CALL_OW 69
37464: UNION
37465: ST_TO_ADDR
37466: GO 37386
37468: POP
37469: POP
// if not vehs then
37470: LD_VAR 0 7
37474: NOT
37475: IFFALSE 37501
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37477: LD_ADDR_EXP 86
37481: PUSH
37482: LD_EXP 86
37486: PPUSH
37487: LD_VAR 0 2
37491: PPUSH
37492: EMPTY
37493: PPUSH
37494: CALL_OW 1
37498: ST_TO_ADDR
// continue ;
37499: GO 37159
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37501: LD_ADDR_VAR 0 8
37505: PUSH
37506: LD_EXP 74
37510: PUSH
37511: LD_VAR 0 2
37515: ARRAY
37516: PPUSH
37517: LD_INT 30
37519: PUSH
37520: LD_INT 3
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PPUSH
37527: CALL_OW 72
37531: ST_TO_ADDR
// if tmp then
37532: LD_VAR 0 8
37536: IFFALSE 37639
// begin for j in tmp do
37538: LD_ADDR_VAR 0 3
37542: PUSH
37543: LD_VAR 0 8
37547: PUSH
37548: FOR_IN
37549: IFFALSE 37637
// for k in UnitsInside ( j ) do
37551: LD_ADDR_VAR 0 4
37555: PUSH
37556: LD_VAR 0 3
37560: PPUSH
37561: CALL_OW 313
37565: PUSH
37566: FOR_IN
37567: IFFALSE 37633
// if k then
37569: LD_VAR 0 4
37573: IFFALSE 37631
// if not k in mc_repair_vehicle [ i ] then
37575: LD_VAR 0 4
37579: PUSH
37580: LD_EXP 86
37584: PUSH
37585: LD_VAR 0 2
37589: ARRAY
37590: IN
37591: NOT
37592: IFFALSE 37631
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
37594: LD_ADDR_EXP 86
37598: PUSH
37599: LD_EXP 86
37603: PPUSH
37604: LD_VAR 0 2
37608: PPUSH
37609: LD_EXP 86
37613: PUSH
37614: LD_VAR 0 2
37618: ARRAY
37619: PUSH
37620: LD_VAR 0 4
37624: UNION
37625: PPUSH
37626: CALL_OW 1
37630: ST_TO_ADDR
37631: GO 37566
37633: POP
37634: POP
37635: GO 37548
37637: POP
37638: POP
// end ; if not mc_repair_vehicle [ i ] then
37639: LD_EXP 86
37643: PUSH
37644: LD_VAR 0 2
37648: ARRAY
37649: NOT
37650: IFFALSE 37654
// continue ;
37652: GO 37159
// for j in mc_repair_vehicle [ i ] do
37654: LD_ADDR_VAR 0 3
37658: PUSH
37659: LD_EXP 86
37663: PUSH
37664: LD_VAR 0 2
37668: ARRAY
37669: PUSH
37670: FOR_IN
37671: IFFALSE 37837
// begin if GetClass ( j ) <> 3 then
37673: LD_VAR 0 3
37677: PPUSH
37678: CALL_OW 257
37682: PUSH
37683: LD_INT 3
37685: NONEQUAL
37686: IFFALSE 37727
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37688: LD_ADDR_EXP 86
37692: PUSH
37693: LD_EXP 86
37697: PPUSH
37698: LD_VAR 0 2
37702: PPUSH
37703: LD_EXP 86
37707: PUSH
37708: LD_VAR 0 2
37712: ARRAY
37713: PUSH
37714: LD_VAR 0 3
37718: DIFF
37719: PPUSH
37720: CALL_OW 1
37724: ST_TO_ADDR
// continue ;
37725: GO 37670
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37727: LD_VAR 0 3
37731: PPUSH
37732: CALL_OW 311
37736: NOT
37737: PUSH
37738: LD_VAR 0 3
37742: PUSH
37743: LD_EXP 77
37747: PUSH
37748: LD_VAR 0 2
37752: ARRAY
37753: PUSH
37754: LD_INT 1
37756: ARRAY
37757: IN
37758: NOT
37759: AND
37760: PUSH
37761: LD_VAR 0 3
37765: PUSH
37766: LD_EXP 77
37770: PUSH
37771: LD_VAR 0 2
37775: ARRAY
37776: PUSH
37777: LD_INT 2
37779: ARRAY
37780: IN
37781: NOT
37782: AND
37783: IFFALSE 37835
// begin if IsInUnit ( j ) then
37785: LD_VAR 0 3
37789: PPUSH
37790: CALL_OW 310
37794: IFFALSE 37805
// ComExitBuilding ( j ) ;
37796: LD_VAR 0 3
37800: PPUSH
37801: CALL_OW 122
// if not HasTask ( j ) then
37805: LD_VAR 0 3
37809: PPUSH
37810: CALL_OW 314
37814: NOT
37815: IFFALSE 37835
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
37817: LD_VAR 0 3
37821: PPUSH
37822: LD_VAR 0 7
37826: PUSH
37827: LD_INT 1
37829: ARRAY
37830: PPUSH
37831: CALL_OW 189
// end ; end ;
37835: GO 37670
37837: POP
37838: POP
// end ;
37839: GO 37159
37841: POP
37842: POP
// end ;
37843: LD_VAR 0 1
37847: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37848: LD_INT 0
37850: PPUSH
37851: PPUSH
37852: PPUSH
37853: PPUSH
37854: PPUSH
37855: PPUSH
37856: PPUSH
37857: PPUSH
37858: PPUSH
37859: PPUSH
37860: PPUSH
// if not mc_bases then
37861: LD_EXP 74
37865: NOT
37866: IFFALSE 37870
// exit ;
37868: GO 38672
// for i = 1 to mc_bases do
37870: LD_ADDR_VAR 0 2
37874: PUSH
37875: DOUBLE
37876: LD_INT 1
37878: DEC
37879: ST_TO_ADDR
37880: LD_EXP 74
37884: PUSH
37885: FOR_TO
37886: IFFALSE 38670
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37888: LD_EXP 102
37892: PUSH
37893: LD_VAR 0 2
37897: ARRAY
37898: NOT
37899: PUSH
37900: LD_EXP 77
37904: PUSH
37905: LD_VAR 0 2
37909: ARRAY
37910: PUSH
37911: LD_INT 1
37913: ARRAY
37914: OR
37915: PUSH
37916: LD_EXP 77
37920: PUSH
37921: LD_VAR 0 2
37925: ARRAY
37926: PUSH
37927: LD_INT 2
37929: ARRAY
37930: OR
37931: PUSH
37932: LD_EXP 100
37936: PUSH
37937: LD_VAR 0 2
37941: ARRAY
37942: PPUSH
37943: LD_INT 1
37945: PPUSH
37946: CALL_OW 325
37950: NOT
37951: OR
37952: PUSH
37953: LD_EXP 97
37957: PUSH
37958: LD_VAR 0 2
37962: ARRAY
37963: OR
37964: IFFALSE 37968
// continue ;
37966: GO 37885
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37968: LD_ADDR_VAR 0 8
37972: PUSH
37973: LD_EXP 74
37977: PUSH
37978: LD_VAR 0 2
37982: ARRAY
37983: PPUSH
37984: LD_INT 25
37986: PUSH
37987: LD_INT 4
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: LD_INT 50
37996: PUSH
37997: EMPTY
37998: LIST
37999: PUSH
38000: LD_INT 3
38002: PUSH
38003: LD_INT 60
38005: PUSH
38006: EMPTY
38007: LIST
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: LIST
38017: PPUSH
38018: CALL_OW 72
38022: PUSH
38023: LD_EXP 78
38027: PUSH
38028: LD_VAR 0 2
38032: ARRAY
38033: DIFF
38034: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38035: LD_ADDR_VAR 0 9
38039: PUSH
38040: LD_EXP 74
38044: PUSH
38045: LD_VAR 0 2
38049: ARRAY
38050: PPUSH
38051: LD_INT 2
38053: PUSH
38054: LD_INT 30
38056: PUSH
38057: LD_INT 0
38059: PUSH
38060: EMPTY
38061: LIST
38062: LIST
38063: PUSH
38064: LD_INT 30
38066: PUSH
38067: LD_INT 1
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: LIST
38078: PPUSH
38079: CALL_OW 72
38083: ST_TO_ADDR
// if not tmp or not dep then
38084: LD_VAR 0 8
38088: NOT
38089: PUSH
38090: LD_VAR 0 9
38094: NOT
38095: OR
38096: IFFALSE 38100
// continue ;
38098: GO 37885
// side := GetSide ( tmp [ 1 ] ) ;
38100: LD_ADDR_VAR 0 11
38104: PUSH
38105: LD_VAR 0 8
38109: PUSH
38110: LD_INT 1
38112: ARRAY
38113: PPUSH
38114: CALL_OW 255
38118: ST_TO_ADDR
// dep := dep [ 1 ] ;
38119: LD_ADDR_VAR 0 9
38123: PUSH
38124: LD_VAR 0 9
38128: PUSH
38129: LD_INT 1
38131: ARRAY
38132: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38133: LD_ADDR_VAR 0 7
38137: PUSH
38138: LD_EXP 102
38142: PUSH
38143: LD_VAR 0 2
38147: ARRAY
38148: PPUSH
38149: LD_INT 22
38151: PUSH
38152: LD_INT 0
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 25
38161: PUSH
38162: LD_INT 12
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PPUSH
38173: CALL_OW 70
38177: PUSH
38178: LD_INT 22
38180: PUSH
38181: LD_INT 0
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 25
38190: PUSH
38191: LD_INT 12
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 91
38200: PUSH
38201: LD_VAR 0 9
38205: PUSH
38206: LD_INT 20
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: LIST
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: LIST
38218: PPUSH
38219: CALL_OW 69
38223: UNION
38224: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38225: LD_ADDR_VAR 0 10
38229: PUSH
38230: LD_EXP 102
38234: PUSH
38235: LD_VAR 0 2
38239: ARRAY
38240: PPUSH
38241: LD_INT 81
38243: PUSH
38244: LD_VAR 0 11
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PPUSH
38253: CALL_OW 70
38257: ST_TO_ADDR
// if not apes or danger_at_area then
38258: LD_VAR 0 7
38262: NOT
38263: PUSH
38264: LD_VAR 0 10
38268: OR
38269: IFFALSE 38319
// begin if mc_taming [ i ] then
38271: LD_EXP 105
38275: PUSH
38276: LD_VAR 0 2
38280: ARRAY
38281: IFFALSE 38317
// begin MC_Reset ( i , 121 ) ;
38283: LD_VAR 0 2
38287: PPUSH
38288: LD_INT 121
38290: PPUSH
38291: CALL 23650 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38295: LD_ADDR_EXP 105
38299: PUSH
38300: LD_EXP 105
38304: PPUSH
38305: LD_VAR 0 2
38309: PPUSH
38310: EMPTY
38311: PPUSH
38312: CALL_OW 1
38316: ST_TO_ADDR
// end ; continue ;
38317: GO 37885
// end ; for j in tmp do
38319: LD_ADDR_VAR 0 3
38323: PUSH
38324: LD_VAR 0 8
38328: PUSH
38329: FOR_IN
38330: IFFALSE 38666
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
38332: LD_VAR 0 3
38336: PUSH
38337: LD_EXP 105
38341: PUSH
38342: LD_VAR 0 2
38346: ARRAY
38347: IN
38348: NOT
38349: PUSH
38350: LD_EXP 105
38354: PUSH
38355: LD_VAR 0 2
38359: ARRAY
38360: PUSH
38361: LD_INT 3
38363: LESS
38364: AND
38365: IFFALSE 38423
// begin SetTag ( j , 121 ) ;
38367: LD_VAR 0 3
38371: PPUSH
38372: LD_INT 121
38374: PPUSH
38375: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
38379: LD_ADDR_EXP 105
38383: PUSH
38384: LD_EXP 105
38388: PPUSH
38389: LD_VAR 0 2
38393: PUSH
38394: LD_EXP 105
38398: PUSH
38399: LD_VAR 0 2
38403: ARRAY
38404: PUSH
38405: LD_INT 1
38407: PLUS
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PPUSH
38413: LD_VAR 0 3
38417: PPUSH
38418: CALL 56238 0 3
38422: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
38423: LD_VAR 0 3
38427: PUSH
38428: LD_EXP 105
38432: PUSH
38433: LD_VAR 0 2
38437: ARRAY
38438: IN
38439: IFFALSE 38664
// begin if GetClass ( j ) <> 4 then
38441: LD_VAR 0 3
38445: PPUSH
38446: CALL_OW 257
38450: PUSH
38451: LD_INT 4
38453: NONEQUAL
38454: IFFALSE 38507
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
38456: LD_ADDR_EXP 105
38460: PUSH
38461: LD_EXP 105
38465: PPUSH
38466: LD_VAR 0 2
38470: PPUSH
38471: LD_EXP 105
38475: PUSH
38476: LD_VAR 0 2
38480: ARRAY
38481: PUSH
38482: LD_VAR 0 3
38486: DIFF
38487: PPUSH
38488: CALL_OW 1
38492: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38493: LD_VAR 0 3
38497: PPUSH
38498: LD_INT 0
38500: PPUSH
38501: CALL_OW 109
// continue ;
38505: GO 38329
// end ; if IsInUnit ( j ) then
38507: LD_VAR 0 3
38511: PPUSH
38512: CALL_OW 310
38516: IFFALSE 38527
// ComExitBuilding ( j ) ;
38518: LD_VAR 0 3
38522: PPUSH
38523: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
38527: LD_ADDR_VAR 0 6
38531: PUSH
38532: LD_VAR 0 7
38536: PPUSH
38537: LD_VAR 0 3
38541: PPUSH
38542: CALL_OW 74
38546: ST_TO_ADDR
// if not ape then
38547: LD_VAR 0 6
38551: NOT
38552: IFFALSE 38556
// break ;
38554: GO 38666
// x := GetX ( ape ) ;
38556: LD_ADDR_VAR 0 4
38560: PUSH
38561: LD_VAR 0 6
38565: PPUSH
38566: CALL_OW 250
38570: ST_TO_ADDR
// y := GetY ( ape ) ;
38571: LD_ADDR_VAR 0 5
38575: PUSH
38576: LD_VAR 0 6
38580: PPUSH
38581: CALL_OW 251
38585: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
38586: LD_VAR 0 4
38590: PPUSH
38591: LD_VAR 0 5
38595: PPUSH
38596: CALL_OW 488
38600: NOT
38601: PUSH
38602: LD_VAR 0 11
38606: PPUSH
38607: LD_VAR 0 4
38611: PPUSH
38612: LD_VAR 0 5
38616: PPUSH
38617: LD_INT 20
38619: PPUSH
38620: CALL 57134 0 4
38624: PUSH
38625: LD_INT 4
38627: ARRAY
38628: OR
38629: IFFALSE 38633
// break ;
38631: GO 38666
// if not HasTask ( j ) then
38633: LD_VAR 0 3
38637: PPUSH
38638: CALL_OW 314
38642: NOT
38643: IFFALSE 38664
// ComTameXY ( j , x , y ) ;
38645: LD_VAR 0 3
38649: PPUSH
38650: LD_VAR 0 4
38654: PPUSH
38655: LD_VAR 0 5
38659: PPUSH
38660: CALL_OW 131
// end ; end ;
38664: GO 38329
38666: POP
38667: POP
// end ;
38668: GO 37885
38670: POP
38671: POP
// end ;
38672: LD_VAR 0 1
38676: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38677: LD_INT 0
38679: PPUSH
38680: PPUSH
38681: PPUSH
38682: PPUSH
38683: PPUSH
38684: PPUSH
38685: PPUSH
38686: PPUSH
// if not mc_bases then
38687: LD_EXP 74
38691: NOT
38692: IFFALSE 38696
// exit ;
38694: GO 39322
// for i = 1 to mc_bases do
38696: LD_ADDR_VAR 0 2
38700: PUSH
38701: DOUBLE
38702: LD_INT 1
38704: DEC
38705: ST_TO_ADDR
38706: LD_EXP 74
38710: PUSH
38711: FOR_TO
38712: IFFALSE 39320
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38714: LD_EXP 103
38718: PUSH
38719: LD_VAR 0 2
38723: ARRAY
38724: NOT
38725: PUSH
38726: LD_EXP 103
38730: PUSH
38731: LD_VAR 0 2
38735: ARRAY
38736: PPUSH
38737: LD_INT 25
38739: PUSH
38740: LD_INT 12
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PPUSH
38747: CALL_OW 72
38751: NOT
38752: OR
38753: IFFALSE 38757
// continue ;
38755: GO 38711
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38757: LD_ADDR_VAR 0 5
38761: PUSH
38762: LD_EXP 103
38766: PUSH
38767: LD_VAR 0 2
38771: ARRAY
38772: PUSH
38773: LD_INT 1
38775: ARRAY
38776: PPUSH
38777: CALL_OW 255
38781: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38782: LD_VAR 0 5
38786: PPUSH
38787: LD_INT 2
38789: PPUSH
38790: CALL_OW 325
38794: IFFALSE 39047
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38796: LD_ADDR_VAR 0 4
38800: PUSH
38801: LD_EXP 103
38805: PUSH
38806: LD_VAR 0 2
38810: ARRAY
38811: PPUSH
38812: LD_INT 25
38814: PUSH
38815: LD_INT 16
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: PPUSH
38822: CALL_OW 72
38826: ST_TO_ADDR
// if tmp < 6 then
38827: LD_VAR 0 4
38831: PUSH
38832: LD_INT 6
38834: LESS
38835: IFFALSE 39047
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38837: LD_ADDR_VAR 0 6
38841: PUSH
38842: LD_EXP 74
38846: PUSH
38847: LD_VAR 0 2
38851: ARRAY
38852: PPUSH
38853: LD_INT 2
38855: PUSH
38856: LD_INT 30
38858: PUSH
38859: LD_INT 0
38861: PUSH
38862: EMPTY
38863: LIST
38864: LIST
38865: PUSH
38866: LD_INT 30
38868: PUSH
38869: LD_INT 1
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: LIST
38880: PPUSH
38881: CALL_OW 72
38885: ST_TO_ADDR
// if depot then
38886: LD_VAR 0 6
38890: IFFALSE 39047
// begin selected := 0 ;
38892: LD_ADDR_VAR 0 7
38896: PUSH
38897: LD_INT 0
38899: ST_TO_ADDR
// for j in depot do
38900: LD_ADDR_VAR 0 3
38904: PUSH
38905: LD_VAR 0 6
38909: PUSH
38910: FOR_IN
38911: IFFALSE 38942
// begin if UnitsInside ( j ) < 6 then
38913: LD_VAR 0 3
38917: PPUSH
38918: CALL_OW 313
38922: PUSH
38923: LD_INT 6
38925: LESS
38926: IFFALSE 38940
// begin selected := j ;
38928: LD_ADDR_VAR 0 7
38932: PUSH
38933: LD_VAR 0 3
38937: ST_TO_ADDR
// break ;
38938: GO 38942
// end ; end ;
38940: GO 38910
38942: POP
38943: POP
// if selected then
38944: LD_VAR 0 7
38948: IFFALSE 39047
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38950: LD_ADDR_VAR 0 3
38954: PUSH
38955: LD_EXP 103
38959: PUSH
38960: LD_VAR 0 2
38964: ARRAY
38965: PPUSH
38966: LD_INT 25
38968: PUSH
38969: LD_INT 12
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: PPUSH
38976: CALL_OW 72
38980: PUSH
38981: FOR_IN
38982: IFFALSE 39045
// if not HasTask ( j ) then
38984: LD_VAR 0 3
38988: PPUSH
38989: CALL_OW 314
38993: NOT
38994: IFFALSE 39043
// begin if not IsInUnit ( j ) then
38996: LD_VAR 0 3
39000: PPUSH
39001: CALL_OW 310
39005: NOT
39006: IFFALSE 39022
// ComEnterUnit ( j , selected ) ;
39008: LD_VAR 0 3
39012: PPUSH
39013: LD_VAR 0 7
39017: PPUSH
39018: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39022: LD_VAR 0 3
39026: PPUSH
39027: LD_INT 16
39029: PPUSH
39030: CALL_OW 183
// AddComExitBuilding ( j ) ;
39034: LD_VAR 0 3
39038: PPUSH
39039: CALL_OW 182
// end ;
39043: GO 38981
39045: POP
39046: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39047: LD_VAR 0 5
39051: PPUSH
39052: LD_INT 11
39054: PPUSH
39055: CALL_OW 325
39059: IFFALSE 39318
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39061: LD_ADDR_VAR 0 4
39065: PUSH
39066: LD_EXP 103
39070: PUSH
39071: LD_VAR 0 2
39075: ARRAY
39076: PPUSH
39077: LD_INT 25
39079: PUSH
39080: LD_INT 16
39082: PUSH
39083: EMPTY
39084: LIST
39085: LIST
39086: PPUSH
39087: CALL_OW 72
39091: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39092: LD_VAR 0 4
39096: PUSH
39097: LD_INT 6
39099: GREATEREQUAL
39100: PUSH
39101: LD_VAR 0 5
39105: PPUSH
39106: LD_INT 2
39108: PPUSH
39109: CALL_OW 325
39113: NOT
39114: OR
39115: IFFALSE 39318
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39117: LD_ADDR_VAR 0 8
39121: PUSH
39122: LD_EXP 74
39126: PUSH
39127: LD_VAR 0 2
39131: ARRAY
39132: PPUSH
39133: LD_INT 2
39135: PUSH
39136: LD_INT 30
39138: PUSH
39139: LD_INT 4
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 30
39148: PUSH
39149: LD_INT 5
39151: PUSH
39152: EMPTY
39153: LIST
39154: LIST
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: LIST
39160: PPUSH
39161: CALL_OW 72
39165: ST_TO_ADDR
// if barracks then
39166: LD_VAR 0 8
39170: IFFALSE 39318
// begin selected := 0 ;
39172: LD_ADDR_VAR 0 7
39176: PUSH
39177: LD_INT 0
39179: ST_TO_ADDR
// for j in barracks do
39180: LD_ADDR_VAR 0 3
39184: PUSH
39185: LD_VAR 0 8
39189: PUSH
39190: FOR_IN
39191: IFFALSE 39222
// begin if UnitsInside ( j ) < 6 then
39193: LD_VAR 0 3
39197: PPUSH
39198: CALL_OW 313
39202: PUSH
39203: LD_INT 6
39205: LESS
39206: IFFALSE 39220
// begin selected := j ;
39208: LD_ADDR_VAR 0 7
39212: PUSH
39213: LD_VAR 0 3
39217: ST_TO_ADDR
// break ;
39218: GO 39222
// end ; end ;
39220: GO 39190
39222: POP
39223: POP
// if selected then
39224: LD_VAR 0 7
39228: IFFALSE 39318
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39230: LD_ADDR_VAR 0 3
39234: PUSH
39235: LD_EXP 103
39239: PUSH
39240: LD_VAR 0 2
39244: ARRAY
39245: PPUSH
39246: LD_INT 25
39248: PUSH
39249: LD_INT 12
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PPUSH
39256: CALL_OW 72
39260: PUSH
39261: FOR_IN
39262: IFFALSE 39316
// if not IsInUnit ( j ) and not HasTask ( j ) then
39264: LD_VAR 0 3
39268: PPUSH
39269: CALL_OW 310
39273: NOT
39274: PUSH
39275: LD_VAR 0 3
39279: PPUSH
39280: CALL_OW 314
39284: NOT
39285: AND
39286: IFFALSE 39314
// begin ComEnterUnit ( j , selected ) ;
39288: LD_VAR 0 3
39292: PPUSH
39293: LD_VAR 0 7
39297: PPUSH
39298: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39302: LD_VAR 0 3
39306: PPUSH
39307: LD_INT 15
39309: PPUSH
39310: CALL_OW 183
// end ;
39314: GO 39261
39316: POP
39317: POP
// end ; end ; end ; end ; end ;
39318: GO 38711
39320: POP
39321: POP
// end ;
39322: LD_VAR 0 1
39326: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
39327: LD_INT 0
39329: PPUSH
39330: PPUSH
39331: PPUSH
39332: PPUSH
// if not mc_bases then
39333: LD_EXP 74
39337: NOT
39338: IFFALSE 39342
// exit ;
39340: GO 39520
// for i = 1 to mc_bases do
39342: LD_ADDR_VAR 0 2
39346: PUSH
39347: DOUBLE
39348: LD_INT 1
39350: DEC
39351: ST_TO_ADDR
39352: LD_EXP 74
39356: PUSH
39357: FOR_TO
39358: IFFALSE 39518
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
39360: LD_ADDR_VAR 0 4
39364: PUSH
39365: LD_EXP 74
39369: PUSH
39370: LD_VAR 0 2
39374: ARRAY
39375: PPUSH
39376: LD_INT 25
39378: PUSH
39379: LD_INT 9
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: PPUSH
39386: CALL_OW 72
39390: ST_TO_ADDR
// if not tmp then
39391: LD_VAR 0 4
39395: NOT
39396: IFFALSE 39400
// continue ;
39398: GO 39357
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
39400: LD_EXP 100
39404: PUSH
39405: LD_VAR 0 2
39409: ARRAY
39410: PPUSH
39411: LD_INT 29
39413: PPUSH
39414: CALL_OW 325
39418: NOT
39419: PUSH
39420: LD_EXP 100
39424: PUSH
39425: LD_VAR 0 2
39429: ARRAY
39430: PPUSH
39431: LD_INT 28
39433: PPUSH
39434: CALL_OW 325
39438: NOT
39439: AND
39440: IFFALSE 39444
// continue ;
39442: GO 39357
// for j in tmp do
39444: LD_ADDR_VAR 0 3
39448: PUSH
39449: LD_VAR 0 4
39453: PUSH
39454: FOR_IN
39455: IFFALSE 39514
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39457: LD_VAR 0 3
39461: PUSH
39462: LD_EXP 77
39466: PUSH
39467: LD_VAR 0 2
39471: ARRAY
39472: PUSH
39473: LD_INT 1
39475: ARRAY
39476: IN
39477: NOT
39478: PUSH
39479: LD_VAR 0 3
39483: PUSH
39484: LD_EXP 77
39488: PUSH
39489: LD_VAR 0 2
39493: ARRAY
39494: PUSH
39495: LD_INT 2
39497: ARRAY
39498: IN
39499: NOT
39500: AND
39501: IFFALSE 39512
// ComSpaceTimeShoot ( j ) ;
39503: LD_VAR 0 3
39507: PPUSH
39508: CALL 50188 0 1
39512: GO 39454
39514: POP
39515: POP
// end ;
39516: GO 39357
39518: POP
39519: POP
// end ;
39520: LD_VAR 0 1
39524: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
39525: LD_INT 0
39527: PPUSH
39528: PPUSH
39529: PPUSH
39530: PPUSH
39531: PPUSH
39532: PPUSH
39533: PPUSH
39534: PPUSH
39535: PPUSH
// if not mc_bases then
39536: LD_EXP 74
39540: NOT
39541: IFFALSE 39545
// exit ;
39543: GO 40167
// for i = 1 to mc_bases do
39545: LD_ADDR_VAR 0 2
39549: PUSH
39550: DOUBLE
39551: LD_INT 1
39553: DEC
39554: ST_TO_ADDR
39555: LD_EXP 74
39559: PUSH
39560: FOR_TO
39561: IFFALSE 40165
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
39563: LD_EXP 109
39567: PUSH
39568: LD_VAR 0 2
39572: ARRAY
39573: NOT
39574: PUSH
39575: LD_INT 38
39577: PPUSH
39578: LD_EXP 100
39582: PUSH
39583: LD_VAR 0 2
39587: ARRAY
39588: PPUSH
39589: CALL_OW 321
39593: PUSH
39594: LD_INT 2
39596: NONEQUAL
39597: OR
39598: IFFALSE 39602
// continue ;
39600: GO 39560
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
39602: LD_ADDR_VAR 0 8
39606: PUSH
39607: LD_EXP 74
39611: PUSH
39612: LD_VAR 0 2
39616: ARRAY
39617: PPUSH
39618: LD_INT 30
39620: PUSH
39621: LD_INT 34
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: PPUSH
39628: CALL_OW 72
39632: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
39633: LD_ADDR_VAR 0 9
39637: PUSH
39638: LD_EXP 74
39642: PUSH
39643: LD_VAR 0 2
39647: ARRAY
39648: PPUSH
39649: LD_INT 25
39651: PUSH
39652: LD_INT 4
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PPUSH
39659: CALL_OW 72
39663: PPUSH
39664: LD_INT 0
39666: PPUSH
39667: CALL 89498 0 2
39671: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39672: LD_VAR 0 9
39676: NOT
39677: PUSH
39678: LD_VAR 0 8
39682: NOT
39683: OR
39684: PUSH
39685: LD_EXP 74
39689: PUSH
39690: LD_VAR 0 2
39694: ARRAY
39695: PPUSH
39696: LD_INT 124
39698: PPUSH
39699: CALL 89498 0 2
39703: OR
39704: IFFALSE 39708
// continue ;
39706: GO 39560
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39708: LD_EXP 110
39712: PUSH
39713: LD_VAR 0 2
39717: ARRAY
39718: PUSH
39719: LD_EXP 109
39723: PUSH
39724: LD_VAR 0 2
39728: ARRAY
39729: LESS
39730: PUSH
39731: LD_EXP 110
39735: PUSH
39736: LD_VAR 0 2
39740: ARRAY
39741: PUSH
39742: LD_VAR 0 8
39746: LESS
39747: AND
39748: IFFALSE 40163
// begin tmp := sci [ 1 ] ;
39750: LD_ADDR_VAR 0 7
39754: PUSH
39755: LD_VAR 0 9
39759: PUSH
39760: LD_INT 1
39762: ARRAY
39763: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39764: LD_VAR 0 7
39768: PPUSH
39769: LD_INT 124
39771: PPUSH
39772: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39776: LD_ADDR_VAR 0 3
39780: PUSH
39781: DOUBLE
39782: LD_EXP 109
39786: PUSH
39787: LD_VAR 0 2
39791: ARRAY
39792: INC
39793: ST_TO_ADDR
39794: LD_EXP 109
39798: PUSH
39799: LD_VAR 0 2
39803: ARRAY
39804: PUSH
39805: FOR_DOWNTO
39806: IFFALSE 40149
// begin if IsInUnit ( tmp ) then
39808: LD_VAR 0 7
39812: PPUSH
39813: CALL_OW 310
39817: IFFALSE 39828
// ComExitBuilding ( tmp ) ;
39819: LD_VAR 0 7
39823: PPUSH
39824: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39828: LD_INT 35
39830: PPUSH
39831: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39835: LD_VAR 0 7
39839: PPUSH
39840: CALL_OW 310
39844: NOT
39845: PUSH
39846: LD_VAR 0 7
39850: PPUSH
39851: CALL_OW 314
39855: NOT
39856: AND
39857: IFFALSE 39828
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39859: LD_ADDR_VAR 0 6
39863: PUSH
39864: LD_VAR 0 7
39868: PPUSH
39869: CALL_OW 250
39873: PUSH
39874: LD_VAR 0 7
39878: PPUSH
39879: CALL_OW 251
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39888: LD_INT 35
39890: PPUSH
39891: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39895: LD_ADDR_VAR 0 4
39899: PUSH
39900: LD_EXP 109
39904: PUSH
39905: LD_VAR 0 2
39909: ARRAY
39910: PUSH
39911: LD_VAR 0 3
39915: ARRAY
39916: PUSH
39917: LD_INT 1
39919: ARRAY
39920: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39921: LD_ADDR_VAR 0 5
39925: PUSH
39926: LD_EXP 109
39930: PUSH
39931: LD_VAR 0 2
39935: ARRAY
39936: PUSH
39937: LD_VAR 0 3
39941: ARRAY
39942: PUSH
39943: LD_INT 2
39945: ARRAY
39946: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39947: LD_VAR 0 7
39951: PPUSH
39952: LD_INT 10
39954: PPUSH
39955: CALL 58831 0 2
39959: PUSH
39960: LD_INT 4
39962: ARRAY
39963: IFFALSE 40001
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39965: LD_VAR 0 7
39969: PPUSH
39970: LD_VAR 0 6
39974: PUSH
39975: LD_INT 1
39977: ARRAY
39978: PPUSH
39979: LD_VAR 0 6
39983: PUSH
39984: LD_INT 2
39986: ARRAY
39987: PPUSH
39988: CALL_OW 111
// wait ( 0 0$10 ) ;
39992: LD_INT 350
39994: PPUSH
39995: CALL_OW 67
// end else
39999: GO 40027
// begin ComMoveXY ( tmp , x , y ) ;
40001: LD_VAR 0 7
40005: PPUSH
40006: LD_VAR 0 4
40010: PPUSH
40011: LD_VAR 0 5
40015: PPUSH
40016: CALL_OW 111
// wait ( 0 0$3 ) ;
40020: LD_INT 105
40022: PPUSH
40023: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40027: LD_VAR 0 7
40031: PPUSH
40032: LD_VAR 0 4
40036: PPUSH
40037: LD_VAR 0 5
40041: PPUSH
40042: CALL_OW 307
40046: IFFALSE 39888
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40048: LD_VAR 0 7
40052: PPUSH
40053: LD_VAR 0 4
40057: PPUSH
40058: LD_VAR 0 5
40062: PPUSH
40063: LD_VAR 0 8
40067: PUSH
40068: LD_VAR 0 3
40072: ARRAY
40073: PPUSH
40074: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40078: LD_INT 35
40080: PPUSH
40081: CALL_OW 67
// until not HasTask ( tmp ) ;
40085: LD_VAR 0 7
40089: PPUSH
40090: CALL_OW 314
40094: NOT
40095: IFFALSE 40078
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40097: LD_ADDR_EXP 110
40101: PUSH
40102: LD_EXP 110
40106: PPUSH
40107: LD_VAR 0 2
40111: PUSH
40112: LD_EXP 110
40116: PUSH
40117: LD_VAR 0 2
40121: ARRAY
40122: PUSH
40123: LD_INT 1
40125: PLUS
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PPUSH
40131: LD_VAR 0 8
40135: PUSH
40136: LD_VAR 0 3
40140: ARRAY
40141: PPUSH
40142: CALL 56238 0 3
40146: ST_TO_ADDR
// end ;
40147: GO 39805
40149: POP
40150: POP
// MC_Reset ( i , 124 ) ;
40151: LD_VAR 0 2
40155: PPUSH
40156: LD_INT 124
40158: PPUSH
40159: CALL 23650 0 2
// end ; end ;
40163: GO 39560
40165: POP
40166: POP
// end ;
40167: LD_VAR 0 1
40171: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40172: LD_INT 0
40174: PPUSH
40175: PPUSH
40176: PPUSH
// if not mc_bases then
40177: LD_EXP 74
40181: NOT
40182: IFFALSE 40186
// exit ;
40184: GO 40792
// for i = 1 to mc_bases do
40186: LD_ADDR_VAR 0 2
40190: PUSH
40191: DOUBLE
40192: LD_INT 1
40194: DEC
40195: ST_TO_ADDR
40196: LD_EXP 74
40200: PUSH
40201: FOR_TO
40202: IFFALSE 40790
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40204: LD_ADDR_VAR 0 3
40208: PUSH
40209: LD_EXP 74
40213: PUSH
40214: LD_VAR 0 2
40218: ARRAY
40219: PPUSH
40220: LD_INT 25
40222: PUSH
40223: LD_INT 4
40225: PUSH
40226: EMPTY
40227: LIST
40228: LIST
40229: PPUSH
40230: CALL_OW 72
40234: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40235: LD_VAR 0 3
40239: NOT
40240: PUSH
40241: LD_EXP 111
40245: PUSH
40246: LD_VAR 0 2
40250: ARRAY
40251: NOT
40252: OR
40253: PUSH
40254: LD_EXP 74
40258: PUSH
40259: LD_VAR 0 2
40263: ARRAY
40264: PPUSH
40265: LD_INT 2
40267: PUSH
40268: LD_INT 30
40270: PUSH
40271: LD_INT 0
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: LD_INT 30
40280: PUSH
40281: LD_INT 1
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: LIST
40292: PPUSH
40293: CALL_OW 72
40297: NOT
40298: OR
40299: IFFALSE 40349
// begin if mc_deposits_finder [ i ] then
40301: LD_EXP 112
40305: PUSH
40306: LD_VAR 0 2
40310: ARRAY
40311: IFFALSE 40347
// begin MC_Reset ( i , 125 ) ;
40313: LD_VAR 0 2
40317: PPUSH
40318: LD_INT 125
40320: PPUSH
40321: CALL 23650 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40325: LD_ADDR_EXP 112
40329: PUSH
40330: LD_EXP 112
40334: PPUSH
40335: LD_VAR 0 2
40339: PPUSH
40340: EMPTY
40341: PPUSH
40342: CALL_OW 1
40346: ST_TO_ADDR
// end ; continue ;
40347: GO 40201
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
40349: LD_EXP 111
40353: PUSH
40354: LD_VAR 0 2
40358: ARRAY
40359: PUSH
40360: LD_INT 1
40362: ARRAY
40363: PUSH
40364: LD_INT 3
40366: ARRAY
40367: PUSH
40368: LD_INT 1
40370: EQUAL
40371: PUSH
40372: LD_INT 20
40374: PPUSH
40375: LD_EXP 100
40379: PUSH
40380: LD_VAR 0 2
40384: ARRAY
40385: PPUSH
40386: CALL_OW 321
40390: PUSH
40391: LD_INT 2
40393: NONEQUAL
40394: AND
40395: IFFALSE 40445
// begin if mc_deposits_finder [ i ] then
40397: LD_EXP 112
40401: PUSH
40402: LD_VAR 0 2
40406: ARRAY
40407: IFFALSE 40443
// begin MC_Reset ( i , 125 ) ;
40409: LD_VAR 0 2
40413: PPUSH
40414: LD_INT 125
40416: PPUSH
40417: CALL 23650 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40421: LD_ADDR_EXP 112
40425: PUSH
40426: LD_EXP 112
40430: PPUSH
40431: LD_VAR 0 2
40435: PPUSH
40436: EMPTY
40437: PPUSH
40438: CALL_OW 1
40442: ST_TO_ADDR
// end ; continue ;
40443: GO 40201
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
40445: LD_EXP 111
40449: PUSH
40450: LD_VAR 0 2
40454: ARRAY
40455: PUSH
40456: LD_INT 1
40458: ARRAY
40459: PUSH
40460: LD_INT 1
40462: ARRAY
40463: PPUSH
40464: LD_EXP 111
40468: PUSH
40469: LD_VAR 0 2
40473: ARRAY
40474: PUSH
40475: LD_INT 1
40477: ARRAY
40478: PUSH
40479: LD_INT 2
40481: ARRAY
40482: PPUSH
40483: LD_EXP 100
40487: PUSH
40488: LD_VAR 0 2
40492: ARRAY
40493: PPUSH
40494: CALL_OW 440
40498: IFFALSE 40541
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
40500: LD_ADDR_EXP 111
40504: PUSH
40505: LD_EXP 111
40509: PPUSH
40510: LD_VAR 0 2
40514: PPUSH
40515: LD_EXP 111
40519: PUSH
40520: LD_VAR 0 2
40524: ARRAY
40525: PPUSH
40526: LD_INT 1
40528: PPUSH
40529: CALL_OW 3
40533: PPUSH
40534: CALL_OW 1
40538: ST_TO_ADDR
40539: GO 40788
// begin if not mc_deposits_finder [ i ] then
40541: LD_EXP 112
40545: PUSH
40546: LD_VAR 0 2
40550: ARRAY
40551: NOT
40552: IFFALSE 40604
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
40554: LD_ADDR_EXP 112
40558: PUSH
40559: LD_EXP 112
40563: PPUSH
40564: LD_VAR 0 2
40568: PPUSH
40569: LD_VAR 0 3
40573: PUSH
40574: LD_INT 1
40576: ARRAY
40577: PUSH
40578: EMPTY
40579: LIST
40580: PPUSH
40581: CALL_OW 1
40585: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
40586: LD_VAR 0 3
40590: PUSH
40591: LD_INT 1
40593: ARRAY
40594: PPUSH
40595: LD_INT 125
40597: PPUSH
40598: CALL_OW 109
// end else
40602: GO 40788
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
40604: LD_EXP 112
40608: PUSH
40609: LD_VAR 0 2
40613: ARRAY
40614: PUSH
40615: LD_INT 1
40617: ARRAY
40618: PPUSH
40619: CALL_OW 310
40623: IFFALSE 40646
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
40625: LD_EXP 112
40629: PUSH
40630: LD_VAR 0 2
40634: ARRAY
40635: PUSH
40636: LD_INT 1
40638: ARRAY
40639: PPUSH
40640: CALL_OW 122
40644: GO 40788
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
40646: LD_EXP 112
40650: PUSH
40651: LD_VAR 0 2
40655: ARRAY
40656: PUSH
40657: LD_INT 1
40659: ARRAY
40660: PPUSH
40661: CALL_OW 314
40665: NOT
40666: PUSH
40667: LD_EXP 112
40671: PUSH
40672: LD_VAR 0 2
40676: ARRAY
40677: PUSH
40678: LD_INT 1
40680: ARRAY
40681: PPUSH
40682: LD_EXP 111
40686: PUSH
40687: LD_VAR 0 2
40691: ARRAY
40692: PUSH
40693: LD_INT 1
40695: ARRAY
40696: PUSH
40697: LD_INT 1
40699: ARRAY
40700: PPUSH
40701: LD_EXP 111
40705: PUSH
40706: LD_VAR 0 2
40710: ARRAY
40711: PUSH
40712: LD_INT 1
40714: ARRAY
40715: PUSH
40716: LD_INT 2
40718: ARRAY
40719: PPUSH
40720: CALL_OW 297
40724: PUSH
40725: LD_INT 6
40727: GREATER
40728: AND
40729: IFFALSE 40788
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40731: LD_EXP 112
40735: PUSH
40736: LD_VAR 0 2
40740: ARRAY
40741: PUSH
40742: LD_INT 1
40744: ARRAY
40745: PPUSH
40746: LD_EXP 111
40750: PUSH
40751: LD_VAR 0 2
40755: ARRAY
40756: PUSH
40757: LD_INT 1
40759: ARRAY
40760: PUSH
40761: LD_INT 1
40763: ARRAY
40764: PPUSH
40765: LD_EXP 111
40769: PUSH
40770: LD_VAR 0 2
40774: ARRAY
40775: PUSH
40776: LD_INT 1
40778: ARRAY
40779: PUSH
40780: LD_INT 2
40782: ARRAY
40783: PPUSH
40784: CALL_OW 111
// end ; end ; end ;
40788: GO 40201
40790: POP
40791: POP
// end ;
40792: LD_VAR 0 1
40796: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40797: LD_INT 0
40799: PPUSH
40800: PPUSH
40801: PPUSH
40802: PPUSH
40803: PPUSH
40804: PPUSH
40805: PPUSH
40806: PPUSH
40807: PPUSH
40808: PPUSH
40809: PPUSH
// if not mc_bases then
40810: LD_EXP 74
40814: NOT
40815: IFFALSE 40819
// exit ;
40817: GO 41543
// for i = 1 to mc_bases do
40819: LD_ADDR_VAR 0 2
40823: PUSH
40824: DOUBLE
40825: LD_INT 1
40827: DEC
40828: ST_TO_ADDR
40829: LD_EXP 74
40833: PUSH
40834: FOR_TO
40835: IFFALSE 41541
// begin if not mc_bases [ i ] then
40837: LD_EXP 74
40841: PUSH
40842: LD_VAR 0 2
40846: ARRAY
40847: NOT
40848: IFFALSE 40852
// continue ;
40850: GO 40834
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40852: LD_ADDR_VAR 0 7
40856: PUSH
40857: LD_EXP 74
40861: PUSH
40862: LD_VAR 0 2
40866: ARRAY
40867: PUSH
40868: LD_INT 1
40870: ARRAY
40871: PPUSH
40872: CALL_OW 248
40876: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40877: LD_VAR 0 7
40881: PUSH
40882: LD_INT 3
40884: EQUAL
40885: PUSH
40886: LD_EXP 93
40890: PUSH
40891: LD_VAR 0 2
40895: ARRAY
40896: PUSH
40897: LD_EXP 96
40901: PUSH
40902: LD_VAR 0 2
40906: ARRAY
40907: UNION
40908: PPUSH
40909: LD_INT 33
40911: PUSH
40912: LD_INT 2
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PPUSH
40919: CALL_OW 72
40923: NOT
40924: OR
40925: IFFALSE 40929
// continue ;
40927: GO 40834
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40929: LD_ADDR_VAR 0 9
40933: PUSH
40934: LD_EXP 74
40938: PUSH
40939: LD_VAR 0 2
40943: ARRAY
40944: PPUSH
40945: LD_INT 30
40947: PUSH
40948: LD_INT 36
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PPUSH
40955: CALL_OW 72
40959: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40960: LD_ADDR_VAR 0 10
40964: PUSH
40965: LD_EXP 93
40969: PUSH
40970: LD_VAR 0 2
40974: ARRAY
40975: PPUSH
40976: LD_INT 34
40978: PUSH
40979: LD_INT 31
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PPUSH
40986: CALL_OW 72
40990: ST_TO_ADDR
// if not cts and not mcts then
40991: LD_VAR 0 9
40995: NOT
40996: PUSH
40997: LD_VAR 0 10
41001: NOT
41002: AND
41003: IFFALSE 41007
// continue ;
41005: GO 40834
// x := cts ;
41007: LD_ADDR_VAR 0 11
41011: PUSH
41012: LD_VAR 0 9
41016: ST_TO_ADDR
// if not x then
41017: LD_VAR 0 11
41021: NOT
41022: IFFALSE 41034
// x := mcts ;
41024: LD_ADDR_VAR 0 11
41028: PUSH
41029: LD_VAR 0 10
41033: ST_TO_ADDR
// if mc_remote_driver [ i ] then
41034: LD_EXP 114
41038: PUSH
41039: LD_VAR 0 2
41043: ARRAY
41044: IFFALSE 41313
// for j in mc_remote_driver [ i ] do
41046: LD_ADDR_VAR 0 3
41050: PUSH
41051: LD_EXP 114
41055: PUSH
41056: LD_VAR 0 2
41060: ARRAY
41061: PUSH
41062: FOR_IN
41063: IFFALSE 41311
// begin if GetClass ( j ) <> 3 then
41065: LD_VAR 0 3
41069: PPUSH
41070: CALL_OW 257
41074: PUSH
41075: LD_INT 3
41077: NONEQUAL
41078: IFFALSE 41131
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41080: LD_ADDR_EXP 114
41084: PUSH
41085: LD_EXP 114
41089: PPUSH
41090: LD_VAR 0 2
41094: PPUSH
41095: LD_EXP 114
41099: PUSH
41100: LD_VAR 0 2
41104: ARRAY
41105: PUSH
41106: LD_VAR 0 3
41110: DIFF
41111: PPUSH
41112: CALL_OW 1
41116: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41117: LD_VAR 0 3
41121: PPUSH
41122: LD_INT 0
41124: PPUSH
41125: CALL_OW 109
// continue ;
41129: GO 41062
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41131: LD_VAR 0 3
41135: PPUSH
41136: CALL_OW 310
41140: NOT
41141: PUSH
41142: LD_VAR 0 3
41146: PPUSH
41147: CALL_OW 310
41151: PPUSH
41152: CALL_OW 266
41156: PUSH
41157: LD_INT 36
41159: NONEQUAL
41160: PUSH
41161: LD_VAR 0 3
41165: PPUSH
41166: CALL 89586 0 1
41170: NOT
41171: AND
41172: OR
41173: IFFALSE 41309
// begin if IsInUnit ( j ) then
41175: LD_VAR 0 3
41179: PPUSH
41180: CALL_OW 310
41184: IFFALSE 41195
// ComExitBuilding ( j ) ;
41186: LD_VAR 0 3
41190: PPUSH
41191: CALL_OW 122
// ct := 0 ;
41195: LD_ADDR_VAR 0 8
41199: PUSH
41200: LD_INT 0
41202: ST_TO_ADDR
// for k in x do
41203: LD_ADDR_VAR 0 4
41207: PUSH
41208: LD_VAR 0 11
41212: PUSH
41213: FOR_IN
41214: IFFALSE 41287
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
41216: LD_VAR 0 4
41220: PPUSH
41221: CALL_OW 264
41225: PUSH
41226: LD_INT 31
41228: EQUAL
41229: PUSH
41230: LD_VAR 0 4
41234: PPUSH
41235: CALL_OW 311
41239: NOT
41240: AND
41241: PUSH
41242: LD_VAR 0 4
41246: PPUSH
41247: CALL_OW 266
41251: PUSH
41252: LD_INT 36
41254: EQUAL
41255: PUSH
41256: LD_VAR 0 4
41260: PPUSH
41261: CALL_OW 313
41265: PUSH
41266: LD_INT 3
41268: LESS
41269: AND
41270: OR
41271: IFFALSE 41285
// begin ct := k ;
41273: LD_ADDR_VAR 0 8
41277: PUSH
41278: LD_VAR 0 4
41282: ST_TO_ADDR
// break ;
41283: GO 41287
// end ;
41285: GO 41213
41287: POP
41288: POP
// if ct then
41289: LD_VAR 0 8
41293: IFFALSE 41309
// ComEnterUnit ( j , ct ) ;
41295: LD_VAR 0 3
41299: PPUSH
41300: LD_VAR 0 8
41304: PPUSH
41305: CALL_OW 120
// end ; end ;
41309: GO 41062
41311: POP
41312: POP
// places := 0 ;
41313: LD_ADDR_VAR 0 5
41317: PUSH
41318: LD_INT 0
41320: ST_TO_ADDR
// for j = 1 to x do
41321: LD_ADDR_VAR 0 3
41325: PUSH
41326: DOUBLE
41327: LD_INT 1
41329: DEC
41330: ST_TO_ADDR
41331: LD_VAR 0 11
41335: PUSH
41336: FOR_TO
41337: IFFALSE 41392
// if GetWeapon ( x [ j ] ) = ar_control_tower then
41339: LD_VAR 0 11
41343: PUSH
41344: LD_VAR 0 3
41348: ARRAY
41349: PPUSH
41350: CALL_OW 264
41354: PUSH
41355: LD_INT 31
41357: EQUAL
41358: IFFALSE 41376
// places := places + 1 else
41360: LD_ADDR_VAR 0 5
41364: PUSH
41365: LD_VAR 0 5
41369: PUSH
41370: LD_INT 1
41372: PLUS
41373: ST_TO_ADDR
41374: GO 41390
// places := places + 3 ;
41376: LD_ADDR_VAR 0 5
41380: PUSH
41381: LD_VAR 0 5
41385: PUSH
41386: LD_INT 3
41388: PLUS
41389: ST_TO_ADDR
41390: GO 41336
41392: POP
41393: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
41394: LD_ADDR_VAR 0 6
41398: PUSH
41399: LD_EXP 74
41403: PUSH
41404: LD_VAR 0 2
41408: ARRAY
41409: PPUSH
41410: LD_INT 25
41412: PUSH
41413: LD_INT 3
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PPUSH
41420: CALL_OW 72
41424: PUSH
41425: LD_EXP 114
41429: PUSH
41430: LD_VAR 0 2
41434: ARRAY
41435: DIFF
41436: PPUSH
41437: LD_INT 3
41439: PPUSH
41440: CALL 90486 0 2
41444: ST_TO_ADDR
// if not tmp then
41445: LD_VAR 0 6
41449: NOT
41450: IFFALSE 41454
// continue ;
41452: GO 40834
// places := places - mc_remote_driver [ i ] ;
41454: LD_ADDR_VAR 0 5
41458: PUSH
41459: LD_VAR 0 5
41463: PUSH
41464: LD_EXP 114
41468: PUSH
41469: LD_VAR 0 2
41473: ARRAY
41474: MINUS
41475: ST_TO_ADDR
// if places then
41476: LD_VAR 0 5
41480: IFFALSE 41539
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41482: LD_ADDR_EXP 114
41486: PUSH
41487: LD_EXP 114
41491: PPUSH
41492: LD_VAR 0 2
41496: PPUSH
41497: LD_EXP 114
41501: PUSH
41502: LD_VAR 0 2
41506: ARRAY
41507: PUSH
41508: LD_VAR 0 6
41512: PUSH
41513: LD_INT 1
41515: ARRAY
41516: UNION
41517: PPUSH
41518: CALL_OW 1
41522: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41523: LD_VAR 0 6
41527: PUSH
41528: LD_INT 1
41530: ARRAY
41531: PPUSH
41532: LD_INT 126
41534: PPUSH
41535: CALL_OW 109
// end ; end ;
41539: GO 40834
41541: POP
41542: POP
// end ;
41543: LD_VAR 0 1
41547: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41548: LD_INT 0
41550: PPUSH
41551: PPUSH
41552: PPUSH
41553: PPUSH
41554: PPUSH
41555: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41556: LD_VAR 0 1
41560: NOT
41561: PUSH
41562: LD_VAR 0 2
41566: NOT
41567: OR
41568: PUSH
41569: LD_VAR 0 3
41573: NOT
41574: OR
41575: PUSH
41576: LD_VAR 0 4
41580: PUSH
41581: LD_INT 1
41583: PUSH
41584: LD_INT 2
41586: PUSH
41587: LD_INT 3
41589: PUSH
41590: LD_INT 4
41592: PUSH
41593: LD_INT 5
41595: PUSH
41596: LD_INT 8
41598: PUSH
41599: LD_INT 9
41601: PUSH
41602: LD_INT 15
41604: PUSH
41605: LD_INT 16
41607: PUSH
41608: EMPTY
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: IN
41619: NOT
41620: OR
41621: IFFALSE 41625
// exit ;
41623: GO 42525
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41625: LD_ADDR_VAR 0 2
41629: PUSH
41630: LD_VAR 0 2
41634: PPUSH
41635: LD_INT 21
41637: PUSH
41638: LD_INT 3
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PUSH
41645: LD_INT 24
41647: PUSH
41648: LD_INT 250
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PPUSH
41659: CALL_OW 72
41663: ST_TO_ADDR
// case class of 1 , 15 :
41664: LD_VAR 0 4
41668: PUSH
41669: LD_INT 1
41671: DOUBLE
41672: EQUAL
41673: IFTRUE 41683
41675: LD_INT 15
41677: DOUBLE
41678: EQUAL
41679: IFTRUE 41683
41681: GO 41768
41683: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41684: LD_ADDR_VAR 0 8
41688: PUSH
41689: LD_VAR 0 2
41693: PPUSH
41694: LD_INT 2
41696: PUSH
41697: LD_INT 30
41699: PUSH
41700: LD_INT 32
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 30
41709: PUSH
41710: LD_INT 31
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: LIST
41721: PPUSH
41722: CALL_OW 72
41726: PUSH
41727: LD_VAR 0 2
41731: PPUSH
41732: LD_INT 2
41734: PUSH
41735: LD_INT 30
41737: PUSH
41738: LD_INT 4
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: LD_INT 30
41747: PUSH
41748: LD_INT 5
41750: PUSH
41751: EMPTY
41752: LIST
41753: LIST
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: LIST
41759: PPUSH
41760: CALL_OW 72
41764: ADD
41765: ST_TO_ADDR
41766: GO 42014
41768: LD_INT 2
41770: DOUBLE
41771: EQUAL
41772: IFTRUE 41782
41774: LD_INT 16
41776: DOUBLE
41777: EQUAL
41778: IFTRUE 41782
41780: GO 41828
41782: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41783: LD_ADDR_VAR 0 8
41787: PUSH
41788: LD_VAR 0 2
41792: PPUSH
41793: LD_INT 2
41795: PUSH
41796: LD_INT 30
41798: PUSH
41799: LD_INT 0
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 30
41808: PUSH
41809: LD_INT 1
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: EMPTY
41817: LIST
41818: LIST
41819: LIST
41820: PPUSH
41821: CALL_OW 72
41825: ST_TO_ADDR
41826: GO 42014
41828: LD_INT 3
41830: DOUBLE
41831: EQUAL
41832: IFTRUE 41836
41834: GO 41882
41836: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41837: LD_ADDR_VAR 0 8
41841: PUSH
41842: LD_VAR 0 2
41846: PPUSH
41847: LD_INT 2
41849: PUSH
41850: LD_INT 30
41852: PUSH
41853: LD_INT 2
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PUSH
41860: LD_INT 30
41862: PUSH
41863: LD_INT 3
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: LIST
41874: PPUSH
41875: CALL_OW 72
41879: ST_TO_ADDR
41880: GO 42014
41882: LD_INT 4
41884: DOUBLE
41885: EQUAL
41886: IFTRUE 41890
41888: GO 41947
41890: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41891: LD_ADDR_VAR 0 8
41895: PUSH
41896: LD_VAR 0 2
41900: PPUSH
41901: LD_INT 2
41903: PUSH
41904: LD_INT 30
41906: PUSH
41907: LD_INT 6
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: LD_INT 30
41916: PUSH
41917: LD_INT 7
41919: PUSH
41920: EMPTY
41921: LIST
41922: LIST
41923: PUSH
41924: LD_INT 30
41926: PUSH
41927: LD_INT 8
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: LIST
41938: LIST
41939: PPUSH
41940: CALL_OW 72
41944: ST_TO_ADDR
41945: GO 42014
41947: LD_INT 5
41949: DOUBLE
41950: EQUAL
41951: IFTRUE 41967
41953: LD_INT 8
41955: DOUBLE
41956: EQUAL
41957: IFTRUE 41967
41959: LD_INT 9
41961: DOUBLE
41962: EQUAL
41963: IFTRUE 41967
41965: GO 42013
41967: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41968: LD_ADDR_VAR 0 8
41972: PUSH
41973: LD_VAR 0 2
41977: PPUSH
41978: LD_INT 2
41980: PUSH
41981: LD_INT 30
41983: PUSH
41984: LD_INT 4
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 30
41993: PUSH
41994: LD_INT 5
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: LIST
42005: PPUSH
42006: CALL_OW 72
42010: ST_TO_ADDR
42011: GO 42014
42013: POP
// if not tmp then
42014: LD_VAR 0 8
42018: NOT
42019: IFFALSE 42023
// exit ;
42021: GO 42525
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42023: LD_VAR 0 4
42027: PUSH
42028: LD_INT 1
42030: PUSH
42031: LD_INT 15
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: IN
42038: PUSH
42039: LD_EXP 83
42043: PUSH
42044: LD_VAR 0 1
42048: ARRAY
42049: AND
42050: IFFALSE 42206
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42052: LD_ADDR_VAR 0 9
42056: PUSH
42057: LD_EXP 83
42061: PUSH
42062: LD_VAR 0 1
42066: ARRAY
42067: PUSH
42068: LD_INT 1
42070: ARRAY
42071: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42072: LD_VAR 0 9
42076: PUSH
42077: LD_EXP 84
42081: PUSH
42082: LD_VAR 0 1
42086: ARRAY
42087: IN
42088: NOT
42089: IFFALSE 42204
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42091: LD_ADDR_EXP 84
42095: PUSH
42096: LD_EXP 84
42100: PPUSH
42101: LD_VAR 0 1
42105: PUSH
42106: LD_EXP 84
42110: PUSH
42111: LD_VAR 0 1
42115: ARRAY
42116: PUSH
42117: LD_INT 1
42119: PLUS
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PPUSH
42125: LD_VAR 0 9
42129: PPUSH
42130: CALL 56238 0 3
42134: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
42135: LD_ADDR_EXP 83
42139: PUSH
42140: LD_EXP 83
42144: PPUSH
42145: LD_VAR 0 1
42149: PPUSH
42150: LD_EXP 83
42154: PUSH
42155: LD_VAR 0 1
42159: ARRAY
42160: PUSH
42161: LD_VAR 0 9
42165: DIFF
42166: PPUSH
42167: CALL_OW 1
42171: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
42172: LD_VAR 0 3
42176: PPUSH
42177: LD_EXP 84
42181: PUSH
42182: LD_VAR 0 1
42186: ARRAY
42187: PUSH
42188: LD_EXP 84
42192: PUSH
42193: LD_VAR 0 1
42197: ARRAY
42198: ARRAY
42199: PPUSH
42200: CALL_OW 120
// end ; exit ;
42204: GO 42525
// end ; if tmp > 1 then
42206: LD_VAR 0 8
42210: PUSH
42211: LD_INT 1
42213: GREATER
42214: IFFALSE 42318
// for i = 2 to tmp do
42216: LD_ADDR_VAR 0 6
42220: PUSH
42221: DOUBLE
42222: LD_INT 2
42224: DEC
42225: ST_TO_ADDR
42226: LD_VAR 0 8
42230: PUSH
42231: FOR_TO
42232: IFFALSE 42316
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
42234: LD_VAR 0 8
42238: PUSH
42239: LD_VAR 0 6
42243: ARRAY
42244: PPUSH
42245: CALL_OW 461
42249: PUSH
42250: LD_INT 6
42252: EQUAL
42253: IFFALSE 42314
// begin x := tmp [ i ] ;
42255: LD_ADDR_VAR 0 9
42259: PUSH
42260: LD_VAR 0 8
42264: PUSH
42265: LD_VAR 0 6
42269: ARRAY
42270: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
42271: LD_ADDR_VAR 0 8
42275: PUSH
42276: LD_VAR 0 8
42280: PPUSH
42281: LD_VAR 0 6
42285: PPUSH
42286: CALL_OW 3
42290: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
42291: LD_ADDR_VAR 0 8
42295: PUSH
42296: LD_VAR 0 8
42300: PPUSH
42301: LD_INT 1
42303: PPUSH
42304: LD_VAR 0 9
42308: PPUSH
42309: CALL_OW 2
42313: ST_TO_ADDR
// end ;
42314: GO 42231
42316: POP
42317: POP
// for i in tmp do
42318: LD_ADDR_VAR 0 6
42322: PUSH
42323: LD_VAR 0 8
42327: PUSH
42328: FOR_IN
42329: IFFALSE 42398
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
42331: LD_VAR 0 6
42335: PPUSH
42336: CALL_OW 313
42340: PUSH
42341: LD_INT 6
42343: LESS
42344: PUSH
42345: LD_VAR 0 6
42349: PPUSH
42350: CALL_OW 266
42354: PUSH
42355: LD_INT 31
42357: PUSH
42358: LD_INT 32
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: IN
42365: NOT
42366: AND
42367: PUSH
42368: LD_VAR 0 6
42372: PPUSH
42373: CALL_OW 313
42377: PUSH
42378: LD_INT 0
42380: EQUAL
42381: OR
42382: IFFALSE 42396
// begin j := i ;
42384: LD_ADDR_VAR 0 7
42388: PUSH
42389: LD_VAR 0 6
42393: ST_TO_ADDR
// break ;
42394: GO 42398
// end ; end ;
42396: GO 42328
42398: POP
42399: POP
// if j then
42400: LD_VAR 0 7
42404: IFFALSE 42422
// ComEnterUnit ( unit , j ) else
42406: LD_VAR 0 3
42410: PPUSH
42411: LD_VAR 0 7
42415: PPUSH
42416: CALL_OW 120
42420: GO 42525
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42422: LD_ADDR_VAR 0 10
42426: PUSH
42427: LD_VAR 0 2
42431: PPUSH
42432: LD_INT 2
42434: PUSH
42435: LD_INT 30
42437: PUSH
42438: LD_INT 0
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: LD_INT 30
42447: PUSH
42448: LD_INT 1
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: LIST
42459: PPUSH
42460: CALL_OW 72
42464: ST_TO_ADDR
// if depot then
42465: LD_VAR 0 10
42469: IFFALSE 42525
// begin depot := NearestUnitToUnit ( depot , unit ) ;
42471: LD_ADDR_VAR 0 10
42475: PUSH
42476: LD_VAR 0 10
42480: PPUSH
42481: LD_VAR 0 3
42485: PPUSH
42486: CALL_OW 74
42490: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
42491: LD_VAR 0 3
42495: PPUSH
42496: LD_VAR 0 10
42500: PPUSH
42501: CALL_OW 296
42505: PUSH
42506: LD_INT 10
42508: GREATER
42509: IFFALSE 42525
// ComStandNearbyBuilding ( unit , depot ) ;
42511: LD_VAR 0 3
42515: PPUSH
42516: LD_VAR 0 10
42520: PPUSH
42521: CALL 50805 0 2
// end ; end ; end ;
42525: LD_VAR 0 5
42529: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42530: LD_INT 0
42532: PPUSH
42533: PPUSH
42534: PPUSH
42535: PPUSH
// if not mc_bases then
42536: LD_EXP 74
42540: NOT
42541: IFFALSE 42545
// exit ;
42543: GO 42784
// for i = 1 to mc_bases do
42545: LD_ADDR_VAR 0 2
42549: PUSH
42550: DOUBLE
42551: LD_INT 1
42553: DEC
42554: ST_TO_ADDR
42555: LD_EXP 74
42559: PUSH
42560: FOR_TO
42561: IFFALSE 42782
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42563: LD_ADDR_VAR 0 4
42567: PUSH
42568: LD_EXP 74
42572: PUSH
42573: LD_VAR 0 2
42577: ARRAY
42578: PPUSH
42579: LD_INT 21
42581: PUSH
42582: LD_INT 1
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PPUSH
42589: CALL_OW 72
42593: PUSH
42594: LD_EXP 103
42598: PUSH
42599: LD_VAR 0 2
42603: ARRAY
42604: UNION
42605: ST_TO_ADDR
// if not tmp then
42606: LD_VAR 0 4
42610: NOT
42611: IFFALSE 42615
// continue ;
42613: GO 42560
// for j in tmp do
42615: LD_ADDR_VAR 0 3
42619: PUSH
42620: LD_VAR 0 4
42624: PUSH
42625: FOR_IN
42626: IFFALSE 42778
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42628: LD_VAR 0 3
42632: PPUSH
42633: CALL_OW 110
42637: NOT
42638: PUSH
42639: LD_VAR 0 3
42643: PPUSH
42644: CALL_OW 314
42648: NOT
42649: AND
42650: PUSH
42651: LD_VAR 0 3
42655: PPUSH
42656: CALL_OW 311
42660: NOT
42661: AND
42662: PUSH
42663: LD_VAR 0 3
42667: PPUSH
42668: CALL_OW 310
42672: NOT
42673: AND
42674: PUSH
42675: LD_VAR 0 3
42679: PUSH
42680: LD_EXP 77
42684: PUSH
42685: LD_VAR 0 2
42689: ARRAY
42690: PUSH
42691: LD_INT 1
42693: ARRAY
42694: IN
42695: NOT
42696: AND
42697: PUSH
42698: LD_VAR 0 3
42702: PUSH
42703: LD_EXP 77
42707: PUSH
42708: LD_VAR 0 2
42712: ARRAY
42713: PUSH
42714: LD_INT 2
42716: ARRAY
42717: IN
42718: NOT
42719: AND
42720: PUSH
42721: LD_VAR 0 3
42725: PUSH
42726: LD_EXP 86
42730: PUSH
42731: LD_VAR 0 2
42735: ARRAY
42736: IN
42737: NOT
42738: AND
42739: IFFALSE 42776
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42741: LD_VAR 0 2
42745: PPUSH
42746: LD_EXP 74
42750: PUSH
42751: LD_VAR 0 2
42755: ARRAY
42756: PPUSH
42757: LD_VAR 0 3
42761: PPUSH
42762: LD_VAR 0 3
42766: PPUSH
42767: CALL_OW 257
42771: PPUSH
42772: CALL 41548 0 4
// end ;
42776: GO 42625
42778: POP
42779: POP
// end ;
42780: GO 42560
42782: POP
42783: POP
// end ;
42784: LD_VAR 0 1
42788: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
42789: LD_INT 0
42791: PPUSH
42792: PPUSH
42793: PPUSH
42794: PPUSH
42795: PPUSH
42796: PPUSH
// if not mc_bases [ base ] then
42797: LD_EXP 74
42801: PUSH
42802: LD_VAR 0 1
42806: ARRAY
42807: NOT
42808: IFFALSE 42812
// exit ;
42810: GO 42994
// tmp := [ ] ;
42812: LD_ADDR_VAR 0 6
42816: PUSH
42817: EMPTY
42818: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42819: LD_ADDR_VAR 0 7
42823: PUSH
42824: LD_VAR 0 3
42828: PPUSH
42829: LD_INT 0
42831: PPUSH
42832: CALL_OW 517
42836: ST_TO_ADDR
// if not list then
42837: LD_VAR 0 7
42841: NOT
42842: IFFALSE 42846
// exit ;
42844: GO 42994
// for i = 1 to amount do
42846: LD_ADDR_VAR 0 5
42850: PUSH
42851: DOUBLE
42852: LD_INT 1
42854: DEC
42855: ST_TO_ADDR
42856: LD_VAR 0 2
42860: PUSH
42861: FOR_TO
42862: IFFALSE 42942
// begin x := rand ( 1 , list [ 1 ] ) ;
42864: LD_ADDR_VAR 0 8
42868: PUSH
42869: LD_INT 1
42871: PPUSH
42872: LD_VAR 0 7
42876: PUSH
42877: LD_INT 1
42879: ARRAY
42880: PPUSH
42881: CALL_OW 12
42885: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
42886: LD_ADDR_VAR 0 6
42890: PUSH
42891: LD_VAR 0 6
42895: PPUSH
42896: LD_VAR 0 5
42900: PPUSH
42901: LD_VAR 0 7
42905: PUSH
42906: LD_INT 1
42908: ARRAY
42909: PUSH
42910: LD_VAR 0 8
42914: ARRAY
42915: PUSH
42916: LD_VAR 0 7
42920: PUSH
42921: LD_INT 2
42923: ARRAY
42924: PUSH
42925: LD_VAR 0 8
42929: ARRAY
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PPUSH
42935: CALL_OW 1
42939: ST_TO_ADDR
// end ;
42940: GO 42861
42942: POP
42943: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42944: LD_ADDR_EXP 87
42948: PUSH
42949: LD_EXP 87
42953: PPUSH
42954: LD_VAR 0 1
42958: PPUSH
42959: LD_VAR 0 6
42963: PPUSH
42964: CALL_OW 1
42968: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42969: LD_ADDR_EXP 89
42973: PUSH
42974: LD_EXP 89
42978: PPUSH
42979: LD_VAR 0 1
42983: PPUSH
42984: LD_VAR 0 3
42988: PPUSH
42989: CALL_OW 1
42993: ST_TO_ADDR
// end ;
42994: LD_VAR 0 4
42998: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42999: LD_INT 0
43001: PPUSH
// if not mc_bases [ base ] then
43002: LD_EXP 74
43006: PUSH
43007: LD_VAR 0 1
43011: ARRAY
43012: NOT
43013: IFFALSE 43017
// exit ;
43015: GO 43042
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43017: LD_ADDR_EXP 79
43021: PUSH
43022: LD_EXP 79
43026: PPUSH
43027: LD_VAR 0 1
43031: PPUSH
43032: LD_VAR 0 2
43036: PPUSH
43037: CALL_OW 1
43041: ST_TO_ADDR
// end ;
43042: LD_VAR 0 3
43046: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43047: LD_INT 0
43049: PPUSH
// if not mc_bases [ base ] then
43050: LD_EXP 74
43054: PUSH
43055: LD_VAR 0 1
43059: ARRAY
43060: NOT
43061: IFFALSE 43065
// exit ;
43063: GO 43102
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43065: LD_ADDR_EXP 79
43069: PUSH
43070: LD_EXP 79
43074: PPUSH
43075: LD_VAR 0 1
43079: PPUSH
43080: LD_EXP 79
43084: PUSH
43085: LD_VAR 0 1
43089: ARRAY
43090: PUSH
43091: LD_VAR 0 2
43095: UNION
43096: PPUSH
43097: CALL_OW 1
43101: ST_TO_ADDR
// end ;
43102: LD_VAR 0 3
43106: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
43107: LD_INT 0
43109: PPUSH
// if not mc_bases [ base ] then
43110: LD_EXP 74
43114: PUSH
43115: LD_VAR 0 1
43119: ARRAY
43120: NOT
43121: IFFALSE 43125
// exit ;
43123: GO 43150
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
43125: LD_ADDR_EXP 95
43129: PUSH
43130: LD_EXP 95
43134: PPUSH
43135: LD_VAR 0 1
43139: PPUSH
43140: LD_VAR 0 2
43144: PPUSH
43145: CALL_OW 1
43149: ST_TO_ADDR
// end ;
43150: LD_VAR 0 3
43154: RET
// export function MC_InsertProduceList ( base , components ) ; begin
43155: LD_INT 0
43157: PPUSH
// if not mc_bases [ base ] then
43158: LD_EXP 74
43162: PUSH
43163: LD_VAR 0 1
43167: ARRAY
43168: NOT
43169: IFFALSE 43173
// exit ;
43171: GO 43210
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
43173: LD_ADDR_EXP 95
43177: PUSH
43178: LD_EXP 95
43182: PPUSH
43183: LD_VAR 0 1
43187: PPUSH
43188: LD_EXP 95
43192: PUSH
43193: LD_VAR 0 1
43197: ARRAY
43198: PUSH
43199: LD_VAR 0 2
43203: ADD
43204: PPUSH
43205: CALL_OW 1
43209: ST_TO_ADDR
// end ;
43210: LD_VAR 0 3
43214: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
43215: LD_INT 0
43217: PPUSH
// if not mc_bases [ base ] then
43218: LD_EXP 74
43222: PUSH
43223: LD_VAR 0 1
43227: ARRAY
43228: NOT
43229: IFFALSE 43233
// exit ;
43231: GO 43287
// mc_defender := Replace ( mc_defender , base , deflist ) ;
43233: LD_ADDR_EXP 96
43237: PUSH
43238: LD_EXP 96
43242: PPUSH
43243: LD_VAR 0 1
43247: PPUSH
43248: LD_VAR 0 2
43252: PPUSH
43253: CALL_OW 1
43257: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
43258: LD_ADDR_EXP 85
43262: PUSH
43263: LD_EXP 85
43267: PPUSH
43268: LD_VAR 0 1
43272: PPUSH
43273: LD_VAR 0 2
43277: PUSH
43278: LD_INT 0
43280: PLUS
43281: PPUSH
43282: CALL_OW 1
43286: ST_TO_ADDR
// end ;
43287: LD_VAR 0 3
43291: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
43292: LD_INT 0
43294: PPUSH
// if not mc_bases [ base ] then
43295: LD_EXP 74
43299: PUSH
43300: LD_VAR 0 1
43304: ARRAY
43305: NOT
43306: IFFALSE 43310
// exit ;
43308: GO 43335
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
43310: LD_ADDR_EXP 85
43314: PUSH
43315: LD_EXP 85
43319: PPUSH
43320: LD_VAR 0 1
43324: PPUSH
43325: LD_VAR 0 2
43329: PPUSH
43330: CALL_OW 1
43334: ST_TO_ADDR
// end ;
43335: LD_VAR 0 3
43339: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
43340: LD_INT 0
43342: PPUSH
43343: PPUSH
43344: PPUSH
43345: PPUSH
// if not mc_bases [ base ] then
43346: LD_EXP 74
43350: PUSH
43351: LD_VAR 0 1
43355: ARRAY
43356: NOT
43357: IFFALSE 43361
// exit ;
43359: GO 43426
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
43361: LD_ADDR_EXP 94
43365: PUSH
43366: LD_EXP 94
43370: PPUSH
43371: LD_VAR 0 1
43375: PUSH
43376: LD_EXP 94
43380: PUSH
43381: LD_VAR 0 1
43385: ARRAY
43386: PUSH
43387: LD_INT 1
43389: PLUS
43390: PUSH
43391: EMPTY
43392: LIST
43393: LIST
43394: PPUSH
43395: LD_VAR 0 1
43399: PUSH
43400: LD_VAR 0 2
43404: PUSH
43405: LD_VAR 0 3
43409: PUSH
43410: LD_VAR 0 4
43414: PUSH
43415: EMPTY
43416: LIST
43417: LIST
43418: LIST
43419: LIST
43420: PPUSH
43421: CALL 56238 0 3
43425: ST_TO_ADDR
// end ;
43426: LD_VAR 0 5
43430: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
43431: LD_INT 0
43433: PPUSH
// if not mc_bases [ base ] then
43434: LD_EXP 74
43438: PUSH
43439: LD_VAR 0 1
43443: ARRAY
43444: NOT
43445: IFFALSE 43449
// exit ;
43447: GO 43474
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
43449: LD_ADDR_EXP 111
43453: PUSH
43454: LD_EXP 111
43458: PPUSH
43459: LD_VAR 0 1
43463: PPUSH
43464: LD_VAR 0 2
43468: PPUSH
43469: CALL_OW 1
43473: ST_TO_ADDR
// end ;
43474: LD_VAR 0 3
43478: RET
// export function MC_GetMinesField ( base ) ; begin
43479: LD_INT 0
43481: PPUSH
// result := mc_mines [ base ] ;
43482: LD_ADDR_VAR 0 2
43486: PUSH
43487: LD_EXP 87
43491: PUSH
43492: LD_VAR 0 1
43496: ARRAY
43497: ST_TO_ADDR
// end ;
43498: LD_VAR 0 2
43502: RET
// export function MC_GetProduceList ( base ) ; begin
43503: LD_INT 0
43505: PPUSH
// result := mc_produce [ base ] ;
43506: LD_ADDR_VAR 0 2
43510: PUSH
43511: LD_EXP 95
43515: PUSH
43516: LD_VAR 0 1
43520: ARRAY
43521: ST_TO_ADDR
// end ;
43522: LD_VAR 0 2
43526: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43527: LD_INT 0
43529: PPUSH
43530: PPUSH
// if not mc_bases then
43531: LD_EXP 74
43535: NOT
43536: IFFALSE 43540
// exit ;
43538: GO 43605
// if mc_bases [ base ] then
43540: LD_EXP 74
43544: PUSH
43545: LD_VAR 0 1
43549: ARRAY
43550: IFFALSE 43605
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43552: LD_ADDR_VAR 0 3
43556: PUSH
43557: LD_EXP 74
43561: PUSH
43562: LD_VAR 0 1
43566: ARRAY
43567: PPUSH
43568: LD_INT 30
43570: PUSH
43571: LD_VAR 0 2
43575: PUSH
43576: EMPTY
43577: LIST
43578: LIST
43579: PPUSH
43580: CALL_OW 72
43584: ST_TO_ADDR
// if result then
43585: LD_VAR 0 3
43589: IFFALSE 43605
// result := result [ 1 ] ;
43591: LD_ADDR_VAR 0 3
43595: PUSH
43596: LD_VAR 0 3
43600: PUSH
43601: LD_INT 1
43603: ARRAY
43604: ST_TO_ADDR
// end ; end ;
43605: LD_VAR 0 3
43609: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43610: LD_INT 0
43612: PPUSH
43613: PPUSH
// if not mc_bases then
43614: LD_EXP 74
43618: NOT
43619: IFFALSE 43623
// exit ;
43621: GO 43668
// if mc_bases [ base ] then
43623: LD_EXP 74
43627: PUSH
43628: LD_VAR 0 1
43632: ARRAY
43633: IFFALSE 43668
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43635: LD_ADDR_VAR 0 3
43639: PUSH
43640: LD_EXP 74
43644: PUSH
43645: LD_VAR 0 1
43649: ARRAY
43650: PPUSH
43651: LD_INT 30
43653: PUSH
43654: LD_VAR 0 2
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PPUSH
43663: CALL_OW 72
43667: ST_TO_ADDR
// end ;
43668: LD_VAR 0 3
43672: RET
// export function MC_SetTame ( base , area ) ; begin
43673: LD_INT 0
43675: PPUSH
// if not mc_bases or not base then
43676: LD_EXP 74
43680: NOT
43681: PUSH
43682: LD_VAR 0 1
43686: NOT
43687: OR
43688: IFFALSE 43692
// exit ;
43690: GO 43717
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43692: LD_ADDR_EXP 102
43696: PUSH
43697: LD_EXP 102
43701: PPUSH
43702: LD_VAR 0 1
43706: PPUSH
43707: LD_VAR 0 2
43711: PPUSH
43712: CALL_OW 1
43716: ST_TO_ADDR
// end ;
43717: LD_VAR 0 3
43721: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43722: LD_INT 0
43724: PPUSH
43725: PPUSH
// if not mc_bases or not base then
43726: LD_EXP 74
43730: NOT
43731: PUSH
43732: LD_VAR 0 1
43736: NOT
43737: OR
43738: IFFALSE 43742
// exit ;
43740: GO 43844
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43742: LD_ADDR_VAR 0 4
43746: PUSH
43747: LD_EXP 74
43751: PUSH
43752: LD_VAR 0 1
43756: ARRAY
43757: PPUSH
43758: LD_INT 30
43760: PUSH
43761: LD_VAR 0 2
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: PPUSH
43770: CALL_OW 72
43774: ST_TO_ADDR
// if not tmp then
43775: LD_VAR 0 4
43779: NOT
43780: IFFALSE 43784
// exit ;
43782: GO 43844
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43784: LD_ADDR_EXP 106
43788: PUSH
43789: LD_EXP 106
43793: PPUSH
43794: LD_VAR 0 1
43798: PPUSH
43799: LD_EXP 106
43803: PUSH
43804: LD_VAR 0 1
43808: ARRAY
43809: PPUSH
43810: LD_EXP 106
43814: PUSH
43815: LD_VAR 0 1
43819: ARRAY
43820: PUSH
43821: LD_INT 1
43823: PLUS
43824: PPUSH
43825: LD_VAR 0 4
43829: PUSH
43830: LD_INT 1
43832: ARRAY
43833: PPUSH
43834: CALL_OW 2
43838: PPUSH
43839: CALL_OW 1
43843: ST_TO_ADDR
// end ;
43844: LD_VAR 0 3
43848: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43849: LD_INT 0
43851: PPUSH
43852: PPUSH
// if not mc_bases or not base or not kinds then
43853: LD_EXP 74
43857: NOT
43858: PUSH
43859: LD_VAR 0 1
43863: NOT
43864: OR
43865: PUSH
43866: LD_VAR 0 2
43870: NOT
43871: OR
43872: IFFALSE 43876
// exit ;
43874: GO 43937
// for i in kinds do
43876: LD_ADDR_VAR 0 4
43880: PUSH
43881: LD_VAR 0 2
43885: PUSH
43886: FOR_IN
43887: IFFALSE 43935
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43889: LD_ADDR_EXP 108
43893: PUSH
43894: LD_EXP 108
43898: PPUSH
43899: LD_VAR 0 1
43903: PUSH
43904: LD_EXP 108
43908: PUSH
43909: LD_VAR 0 1
43913: ARRAY
43914: PUSH
43915: LD_INT 1
43917: PLUS
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PPUSH
43923: LD_VAR 0 4
43927: PPUSH
43928: CALL 56238 0 3
43932: ST_TO_ADDR
43933: GO 43886
43935: POP
43936: POP
// end ;
43937: LD_VAR 0 3
43941: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43942: LD_INT 0
43944: PPUSH
// if not mc_bases or not base or not areas then
43945: LD_EXP 74
43949: NOT
43950: PUSH
43951: LD_VAR 0 1
43955: NOT
43956: OR
43957: PUSH
43958: LD_VAR 0 2
43962: NOT
43963: OR
43964: IFFALSE 43968
// exit ;
43966: GO 43993
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43968: LD_ADDR_EXP 92
43972: PUSH
43973: LD_EXP 92
43977: PPUSH
43978: LD_VAR 0 1
43982: PPUSH
43983: LD_VAR 0 2
43987: PPUSH
43988: CALL_OW 1
43992: ST_TO_ADDR
// end ;
43993: LD_VAR 0 3
43997: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43998: LD_INT 0
44000: PPUSH
// if not mc_bases or not base or not teleports_exit then
44001: LD_EXP 74
44005: NOT
44006: PUSH
44007: LD_VAR 0 1
44011: NOT
44012: OR
44013: PUSH
44014: LD_VAR 0 2
44018: NOT
44019: OR
44020: IFFALSE 44024
// exit ;
44022: GO 44049
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44024: LD_ADDR_EXP 109
44028: PUSH
44029: LD_EXP 109
44033: PPUSH
44034: LD_VAR 0 1
44038: PPUSH
44039: LD_VAR 0 2
44043: PPUSH
44044: CALL_OW 1
44048: ST_TO_ADDR
// end ;
44049: LD_VAR 0 3
44053: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44054: LD_INT 0
44056: PPUSH
44057: PPUSH
44058: PPUSH
// if not mc_bases or not base or not ext_list then
44059: LD_EXP 74
44063: NOT
44064: PUSH
44065: LD_VAR 0 1
44069: NOT
44070: OR
44071: PUSH
44072: LD_VAR 0 5
44076: NOT
44077: OR
44078: IFFALSE 44082
// exit ;
44080: GO 44255
// tmp := GetFacExtXYD ( x , y , d ) ;
44082: LD_ADDR_VAR 0 8
44086: PUSH
44087: LD_VAR 0 2
44091: PPUSH
44092: LD_VAR 0 3
44096: PPUSH
44097: LD_VAR 0 4
44101: PPUSH
44102: CALL 89616 0 3
44106: ST_TO_ADDR
// if not tmp then
44107: LD_VAR 0 8
44111: NOT
44112: IFFALSE 44116
// exit ;
44114: GO 44255
// for i in tmp do
44116: LD_ADDR_VAR 0 7
44120: PUSH
44121: LD_VAR 0 8
44125: PUSH
44126: FOR_IN
44127: IFFALSE 44253
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
44129: LD_ADDR_EXP 79
44133: PUSH
44134: LD_EXP 79
44138: PPUSH
44139: LD_VAR 0 1
44143: PPUSH
44144: LD_EXP 79
44148: PUSH
44149: LD_VAR 0 1
44153: ARRAY
44154: PPUSH
44155: LD_EXP 79
44159: PUSH
44160: LD_VAR 0 1
44164: ARRAY
44165: PUSH
44166: LD_INT 1
44168: PLUS
44169: PPUSH
44170: LD_VAR 0 5
44174: PUSH
44175: LD_INT 1
44177: ARRAY
44178: PUSH
44179: LD_VAR 0 7
44183: PUSH
44184: LD_INT 1
44186: ARRAY
44187: PUSH
44188: LD_VAR 0 7
44192: PUSH
44193: LD_INT 2
44195: ARRAY
44196: PUSH
44197: LD_VAR 0 7
44201: PUSH
44202: LD_INT 3
44204: ARRAY
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: LIST
44210: LIST
44211: PPUSH
44212: CALL_OW 2
44216: PPUSH
44217: CALL_OW 1
44221: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
44222: LD_ADDR_VAR 0 5
44226: PUSH
44227: LD_VAR 0 5
44231: PPUSH
44232: LD_INT 1
44234: PPUSH
44235: CALL_OW 3
44239: ST_TO_ADDR
// if not ext_list then
44240: LD_VAR 0 5
44244: NOT
44245: IFFALSE 44251
// exit ;
44247: POP
44248: POP
44249: GO 44255
// end ;
44251: GO 44126
44253: POP
44254: POP
// end ;
44255: LD_VAR 0 6
44259: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
44260: LD_INT 0
44262: PPUSH
// if not mc_bases or not base or not weapon_list then
44263: LD_EXP 74
44267: NOT
44268: PUSH
44269: LD_VAR 0 1
44273: NOT
44274: OR
44275: PUSH
44276: LD_VAR 0 2
44280: NOT
44281: OR
44282: IFFALSE 44286
// exit ;
44284: GO 44311
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
44286: LD_ADDR_EXP 113
44290: PUSH
44291: LD_EXP 113
44295: PPUSH
44296: LD_VAR 0 1
44300: PPUSH
44301: LD_VAR 0 2
44305: PPUSH
44306: CALL_OW 1
44310: ST_TO_ADDR
// end ;
44311: LD_VAR 0 3
44315: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
44316: LD_INT 0
44318: PPUSH
// if not mc_bases or not base or not tech_list then
44319: LD_EXP 74
44323: NOT
44324: PUSH
44325: LD_VAR 0 1
44329: NOT
44330: OR
44331: PUSH
44332: LD_VAR 0 2
44336: NOT
44337: OR
44338: IFFALSE 44342
// exit ;
44340: GO 44367
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
44342: LD_ADDR_EXP 101
44346: PUSH
44347: LD_EXP 101
44351: PPUSH
44352: LD_VAR 0 1
44356: PPUSH
44357: LD_VAR 0 2
44361: PPUSH
44362: CALL_OW 1
44366: ST_TO_ADDR
// end ;
44367: LD_VAR 0 3
44371: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
44372: LD_INT 0
44374: PPUSH
// if not mc_bases or not parking_area or not base then
44375: LD_EXP 74
44379: NOT
44380: PUSH
44381: LD_VAR 0 2
44385: NOT
44386: OR
44387: PUSH
44388: LD_VAR 0 1
44392: NOT
44393: OR
44394: IFFALSE 44398
// exit ;
44396: GO 44423
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
44398: LD_ADDR_EXP 98
44402: PUSH
44403: LD_EXP 98
44407: PPUSH
44408: LD_VAR 0 1
44412: PPUSH
44413: LD_VAR 0 2
44417: PPUSH
44418: CALL_OW 1
44422: ST_TO_ADDR
// end ;
44423: LD_VAR 0 3
44427: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
44428: LD_INT 0
44430: PPUSH
// if not mc_bases or not base or not scan_area then
44431: LD_EXP 74
44435: NOT
44436: PUSH
44437: LD_VAR 0 1
44441: NOT
44442: OR
44443: PUSH
44444: LD_VAR 0 2
44448: NOT
44449: OR
44450: IFFALSE 44454
// exit ;
44452: GO 44479
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
44454: LD_ADDR_EXP 99
44458: PUSH
44459: LD_EXP 99
44463: PPUSH
44464: LD_VAR 0 1
44468: PPUSH
44469: LD_VAR 0 2
44473: PPUSH
44474: CALL_OW 1
44478: ST_TO_ADDR
// end ;
44479: LD_VAR 0 3
44483: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44484: LD_INT 0
44486: PPUSH
44487: PPUSH
// if not mc_bases or not base then
44488: LD_EXP 74
44492: NOT
44493: PUSH
44494: LD_VAR 0 1
44498: NOT
44499: OR
44500: IFFALSE 44504
// exit ;
44502: GO 44568
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44504: LD_ADDR_VAR 0 3
44508: PUSH
44509: LD_INT 1
44511: PUSH
44512: LD_INT 2
44514: PUSH
44515: LD_INT 3
44517: PUSH
44518: LD_INT 4
44520: PUSH
44521: LD_INT 11
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44531: LD_ADDR_EXP 101
44535: PUSH
44536: LD_EXP 101
44540: PPUSH
44541: LD_VAR 0 1
44545: PPUSH
44546: LD_EXP 101
44550: PUSH
44551: LD_VAR 0 1
44555: ARRAY
44556: PUSH
44557: LD_VAR 0 3
44561: DIFF
44562: PPUSH
44563: CALL_OW 1
44567: ST_TO_ADDR
// end ;
44568: LD_VAR 0 2
44572: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44573: LD_INT 0
44575: PPUSH
// result := mc_vehicles [ base ] ;
44576: LD_ADDR_VAR 0 3
44580: PUSH
44581: LD_EXP 93
44585: PUSH
44586: LD_VAR 0 1
44590: ARRAY
44591: ST_TO_ADDR
// if onlyCombat then
44592: LD_VAR 0 2
44596: IFFALSE 44761
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44598: LD_ADDR_VAR 0 3
44602: PUSH
44603: LD_VAR 0 3
44607: PUSH
44608: LD_VAR 0 3
44612: PPUSH
44613: LD_INT 2
44615: PUSH
44616: LD_INT 34
44618: PUSH
44619: LD_INT 12
44621: PUSH
44622: EMPTY
44623: LIST
44624: LIST
44625: PUSH
44626: LD_INT 34
44628: PUSH
44629: LD_INT 51
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 34
44638: PUSH
44639: LD_EXP 68
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 34
44650: PUSH
44651: LD_INT 32
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: LD_INT 34
44660: PUSH
44661: LD_INT 13
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 34
44670: PUSH
44671: LD_INT 52
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: LD_INT 34
44680: PUSH
44681: LD_INT 14
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PUSH
44688: LD_INT 34
44690: PUSH
44691: LD_INT 53
44693: PUSH
44694: EMPTY
44695: LIST
44696: LIST
44697: PUSH
44698: LD_INT 34
44700: PUSH
44701: LD_EXP 67
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: PUSH
44710: LD_INT 34
44712: PUSH
44713: LD_INT 31
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 34
44722: PUSH
44723: LD_INT 48
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: LD_INT 34
44732: PUSH
44733: LD_INT 8
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: PPUSH
44755: CALL_OW 72
44759: DIFF
44760: ST_TO_ADDR
// end ; end_of_file
44761: LD_VAR 0 3
44765: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44766: LD_INT 0
44768: PPUSH
44769: PPUSH
44770: PPUSH
// if not mc_bases or not skirmish then
44771: LD_EXP 74
44775: NOT
44776: PUSH
44777: LD_EXP 72
44781: NOT
44782: OR
44783: IFFALSE 44787
// exit ;
44785: GO 44952
// for i = 1 to mc_bases do
44787: LD_ADDR_VAR 0 4
44791: PUSH
44792: DOUBLE
44793: LD_INT 1
44795: DEC
44796: ST_TO_ADDR
44797: LD_EXP 74
44801: PUSH
44802: FOR_TO
44803: IFFALSE 44950
// begin if sci in mc_bases [ i ] then
44805: LD_VAR 0 2
44809: PUSH
44810: LD_EXP 74
44814: PUSH
44815: LD_VAR 0 4
44819: ARRAY
44820: IN
44821: IFFALSE 44948
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44823: LD_ADDR_EXP 103
44827: PUSH
44828: LD_EXP 103
44832: PPUSH
44833: LD_VAR 0 4
44837: PUSH
44838: LD_EXP 103
44842: PUSH
44843: LD_VAR 0 4
44847: ARRAY
44848: PUSH
44849: LD_INT 1
44851: PLUS
44852: PUSH
44853: EMPTY
44854: LIST
44855: LIST
44856: PPUSH
44857: LD_VAR 0 1
44861: PPUSH
44862: CALL 56238 0 3
44866: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44867: LD_ADDR_VAR 0 5
44871: PUSH
44872: LD_EXP 74
44876: PUSH
44877: LD_VAR 0 4
44881: ARRAY
44882: PPUSH
44883: LD_INT 2
44885: PUSH
44886: LD_INT 30
44888: PUSH
44889: LD_INT 0
44891: PUSH
44892: EMPTY
44893: LIST
44894: LIST
44895: PUSH
44896: LD_INT 30
44898: PUSH
44899: LD_INT 1
44901: PUSH
44902: EMPTY
44903: LIST
44904: LIST
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: LIST
44910: PPUSH
44911: CALL_OW 72
44915: PPUSH
44916: LD_VAR 0 1
44920: PPUSH
44921: CALL_OW 74
44925: ST_TO_ADDR
// if tmp then
44926: LD_VAR 0 5
44930: IFFALSE 44946
// ComStandNearbyBuilding ( ape , tmp ) ;
44932: LD_VAR 0 1
44936: PPUSH
44937: LD_VAR 0 5
44941: PPUSH
44942: CALL 50805 0 2
// break ;
44946: GO 44950
// end ; end ;
44948: GO 44802
44950: POP
44951: POP
// end ;
44952: LD_VAR 0 3
44956: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44957: LD_INT 0
44959: PPUSH
44960: PPUSH
44961: PPUSH
// if not mc_bases or not skirmish then
44962: LD_EXP 74
44966: NOT
44967: PUSH
44968: LD_EXP 72
44972: NOT
44973: OR
44974: IFFALSE 44978
// exit ;
44976: GO 45067
// for i = 1 to mc_bases do
44978: LD_ADDR_VAR 0 4
44982: PUSH
44983: DOUBLE
44984: LD_INT 1
44986: DEC
44987: ST_TO_ADDR
44988: LD_EXP 74
44992: PUSH
44993: FOR_TO
44994: IFFALSE 45065
// begin if building in mc_busy_turret_list [ i ] then
44996: LD_VAR 0 1
45000: PUSH
45001: LD_EXP 84
45005: PUSH
45006: LD_VAR 0 4
45010: ARRAY
45011: IN
45012: IFFALSE 45063
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45014: LD_ADDR_VAR 0 5
45018: PUSH
45019: LD_EXP 84
45023: PUSH
45024: LD_VAR 0 4
45028: ARRAY
45029: PUSH
45030: LD_VAR 0 1
45034: DIFF
45035: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45036: LD_ADDR_EXP 84
45040: PUSH
45041: LD_EXP 84
45045: PPUSH
45046: LD_VAR 0 4
45050: PPUSH
45051: LD_VAR 0 5
45055: PPUSH
45056: CALL_OW 1
45060: ST_TO_ADDR
// break ;
45061: GO 45065
// end ; end ;
45063: GO 44993
45065: POP
45066: POP
// end ;
45067: LD_VAR 0 3
45071: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45072: LD_INT 0
45074: PPUSH
45075: PPUSH
45076: PPUSH
// if not mc_bases or not skirmish then
45077: LD_EXP 74
45081: NOT
45082: PUSH
45083: LD_EXP 72
45087: NOT
45088: OR
45089: IFFALSE 45093
// exit ;
45091: GO 45292
// for i = 1 to mc_bases do
45093: LD_ADDR_VAR 0 5
45097: PUSH
45098: DOUBLE
45099: LD_INT 1
45101: DEC
45102: ST_TO_ADDR
45103: LD_EXP 74
45107: PUSH
45108: FOR_TO
45109: IFFALSE 45290
// if building in mc_bases [ i ] then
45111: LD_VAR 0 1
45115: PUSH
45116: LD_EXP 74
45120: PUSH
45121: LD_VAR 0 5
45125: ARRAY
45126: IN
45127: IFFALSE 45288
// begin tmp := mc_bases [ i ] diff building ;
45129: LD_ADDR_VAR 0 6
45133: PUSH
45134: LD_EXP 74
45138: PUSH
45139: LD_VAR 0 5
45143: ARRAY
45144: PUSH
45145: LD_VAR 0 1
45149: DIFF
45150: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
45151: LD_ADDR_EXP 74
45155: PUSH
45156: LD_EXP 74
45160: PPUSH
45161: LD_VAR 0 5
45165: PPUSH
45166: LD_VAR 0 6
45170: PPUSH
45171: CALL_OW 1
45175: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
45176: LD_VAR 0 1
45180: PUSH
45181: LD_EXP 82
45185: PUSH
45186: LD_VAR 0 5
45190: ARRAY
45191: IN
45192: IFFALSE 45231
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
45194: LD_ADDR_EXP 82
45198: PUSH
45199: LD_EXP 82
45203: PPUSH
45204: LD_VAR 0 5
45208: PPUSH
45209: LD_EXP 82
45213: PUSH
45214: LD_VAR 0 5
45218: ARRAY
45219: PUSH
45220: LD_VAR 0 1
45224: DIFF
45225: PPUSH
45226: CALL_OW 1
45230: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
45231: LD_VAR 0 1
45235: PUSH
45236: LD_EXP 83
45240: PUSH
45241: LD_VAR 0 5
45245: ARRAY
45246: IN
45247: IFFALSE 45286
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
45249: LD_ADDR_EXP 83
45253: PUSH
45254: LD_EXP 83
45258: PPUSH
45259: LD_VAR 0 5
45263: PPUSH
45264: LD_EXP 83
45268: PUSH
45269: LD_VAR 0 5
45273: ARRAY
45274: PUSH
45275: LD_VAR 0 1
45279: DIFF
45280: PPUSH
45281: CALL_OW 1
45285: ST_TO_ADDR
// break ;
45286: GO 45290
// end ;
45288: GO 45108
45290: POP
45291: POP
// end ;
45292: LD_VAR 0 4
45296: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
45297: LD_INT 0
45299: PPUSH
45300: PPUSH
45301: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
45302: LD_EXP 74
45306: NOT
45307: PUSH
45308: LD_EXP 72
45312: NOT
45313: OR
45314: PUSH
45315: LD_VAR 0 3
45319: PUSH
45320: LD_EXP 100
45324: IN
45325: NOT
45326: OR
45327: IFFALSE 45331
// exit ;
45329: GO 45454
// for i = 1 to mc_vehicles do
45331: LD_ADDR_VAR 0 6
45335: PUSH
45336: DOUBLE
45337: LD_INT 1
45339: DEC
45340: ST_TO_ADDR
45341: LD_EXP 93
45345: PUSH
45346: FOR_TO
45347: IFFALSE 45452
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
45349: LD_VAR 0 2
45353: PUSH
45354: LD_EXP 93
45358: PUSH
45359: LD_VAR 0 6
45363: ARRAY
45364: IN
45365: PUSH
45366: LD_VAR 0 1
45370: PUSH
45371: LD_EXP 93
45375: PUSH
45376: LD_VAR 0 6
45380: ARRAY
45381: IN
45382: OR
45383: IFFALSE 45450
// begin tmp := mc_vehicles [ i ] diff old ;
45385: LD_ADDR_VAR 0 7
45389: PUSH
45390: LD_EXP 93
45394: PUSH
45395: LD_VAR 0 6
45399: ARRAY
45400: PUSH
45401: LD_VAR 0 2
45405: DIFF
45406: ST_TO_ADDR
// tmp := tmp diff new ;
45407: LD_ADDR_VAR 0 7
45411: PUSH
45412: LD_VAR 0 7
45416: PUSH
45417: LD_VAR 0 1
45421: DIFF
45422: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
45423: LD_ADDR_EXP 93
45427: PUSH
45428: LD_EXP 93
45432: PPUSH
45433: LD_VAR 0 6
45437: PPUSH
45438: LD_VAR 0 7
45442: PPUSH
45443: CALL_OW 1
45447: ST_TO_ADDR
// break ;
45448: GO 45452
// end ;
45450: GO 45346
45452: POP
45453: POP
// end ;
45454: LD_VAR 0 5
45458: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
45459: LD_INT 0
45461: PPUSH
45462: PPUSH
45463: PPUSH
45464: PPUSH
// if not mc_bases or not skirmish then
45465: LD_EXP 74
45469: NOT
45470: PUSH
45471: LD_EXP 72
45475: NOT
45476: OR
45477: IFFALSE 45481
// exit ;
45479: GO 45858
// side := GetSide ( vehicle ) ;
45481: LD_ADDR_VAR 0 5
45485: PUSH
45486: LD_VAR 0 1
45490: PPUSH
45491: CALL_OW 255
45495: ST_TO_ADDR
// for i = 1 to mc_bases do
45496: LD_ADDR_VAR 0 4
45500: PUSH
45501: DOUBLE
45502: LD_INT 1
45504: DEC
45505: ST_TO_ADDR
45506: LD_EXP 74
45510: PUSH
45511: FOR_TO
45512: IFFALSE 45856
// begin if factory in mc_bases [ i ] then
45514: LD_VAR 0 2
45518: PUSH
45519: LD_EXP 74
45523: PUSH
45524: LD_VAR 0 4
45528: ARRAY
45529: IN
45530: IFFALSE 45854
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
45532: LD_EXP 96
45536: PUSH
45537: LD_VAR 0 4
45541: ARRAY
45542: PUSH
45543: LD_EXP 85
45547: PUSH
45548: LD_VAR 0 4
45552: ARRAY
45553: LESS
45554: PUSH
45555: LD_VAR 0 1
45559: PPUSH
45560: CALL_OW 264
45564: PUSH
45565: LD_INT 31
45567: PUSH
45568: LD_INT 32
45570: PUSH
45571: LD_INT 51
45573: PUSH
45574: LD_EXP 68
45578: PUSH
45579: LD_INT 12
45581: PUSH
45582: LD_INT 30
45584: PUSH
45585: LD_EXP 67
45589: PUSH
45590: LD_INT 11
45592: PUSH
45593: LD_INT 53
45595: PUSH
45596: LD_INT 14
45598: PUSH
45599: LD_EXP 71
45603: PUSH
45604: LD_INT 29
45606: PUSH
45607: LD_EXP 69
45611: PUSH
45612: LD_INT 13
45614: PUSH
45615: LD_INT 52
45617: PUSH
45618: LD_INT 48
45620: PUSH
45621: LD_INT 8
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: IN
45643: NOT
45644: AND
45645: IFFALSE 45693
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45647: LD_ADDR_EXP 96
45651: PUSH
45652: LD_EXP 96
45656: PPUSH
45657: LD_VAR 0 4
45661: PUSH
45662: LD_EXP 96
45666: PUSH
45667: LD_VAR 0 4
45671: ARRAY
45672: PUSH
45673: LD_INT 1
45675: PLUS
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PPUSH
45681: LD_VAR 0 1
45685: PPUSH
45686: CALL 56238 0 3
45690: ST_TO_ADDR
45691: GO 45737
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45693: LD_ADDR_EXP 93
45697: PUSH
45698: LD_EXP 93
45702: PPUSH
45703: LD_VAR 0 4
45707: PUSH
45708: LD_EXP 93
45712: PUSH
45713: LD_VAR 0 4
45717: ARRAY
45718: PUSH
45719: LD_INT 1
45721: PLUS
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PPUSH
45727: LD_VAR 0 1
45731: PPUSH
45732: CALL 56238 0 3
45736: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45737: LD_VAR 0 1
45741: PPUSH
45742: CALL_OW 263
45746: PUSH
45747: LD_INT 2
45749: EQUAL
45750: IFFALSE 45770
// begin repeat wait ( 0 0$1 ) ;
45752: LD_INT 35
45754: PPUSH
45755: CALL_OW 67
// until IsControledBy ( vehicle ) ;
45759: LD_VAR 0 1
45763: PPUSH
45764: CALL_OW 312
45768: IFFALSE 45752
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45770: LD_VAR 0 1
45774: PPUSH
45775: LD_EXP 98
45779: PUSH
45780: LD_VAR 0 4
45784: ARRAY
45785: PPUSH
45786: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45790: LD_VAR 0 1
45794: PPUSH
45795: CALL_OW 263
45799: PUSH
45800: LD_INT 1
45802: NONEQUAL
45803: IFFALSE 45807
// break ;
45805: GO 45856
// repeat wait ( 0 0$1 ) ;
45807: LD_INT 35
45809: PPUSH
45810: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45814: LD_VAR 0 1
45818: PPUSH
45819: LD_EXP 98
45823: PUSH
45824: LD_VAR 0 4
45828: ARRAY
45829: PPUSH
45830: CALL_OW 308
45834: IFFALSE 45807
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45836: LD_VAR 0 1
45840: PPUSH
45841: CALL_OW 311
45845: PPUSH
45846: CALL_OW 121
// exit ;
45850: POP
45851: POP
45852: GO 45858
// end ; end ;
45854: GO 45511
45856: POP
45857: POP
// end ;
45858: LD_VAR 0 3
45862: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45863: LD_INT 0
45865: PPUSH
45866: PPUSH
45867: PPUSH
45868: PPUSH
// if not mc_bases or not skirmish then
45869: LD_EXP 74
45873: NOT
45874: PUSH
45875: LD_EXP 72
45879: NOT
45880: OR
45881: IFFALSE 45885
// exit ;
45883: GO 46238
// repeat wait ( 0 0$1 ) ;
45885: LD_INT 35
45887: PPUSH
45888: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45892: LD_VAR 0 2
45896: PPUSH
45897: LD_VAR 0 3
45901: PPUSH
45902: CALL_OW 284
45906: IFFALSE 45885
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45908: LD_VAR 0 2
45912: PPUSH
45913: LD_VAR 0 3
45917: PPUSH
45918: CALL_OW 283
45922: PUSH
45923: LD_INT 4
45925: EQUAL
45926: IFFALSE 45930
// exit ;
45928: GO 46238
// for i = 1 to mc_bases do
45930: LD_ADDR_VAR 0 7
45934: PUSH
45935: DOUBLE
45936: LD_INT 1
45938: DEC
45939: ST_TO_ADDR
45940: LD_EXP 74
45944: PUSH
45945: FOR_TO
45946: IFFALSE 46236
// begin if mc_crates_area [ i ] then
45948: LD_EXP 92
45952: PUSH
45953: LD_VAR 0 7
45957: ARRAY
45958: IFFALSE 46069
// for j in mc_crates_area [ i ] do
45960: LD_ADDR_VAR 0 8
45964: PUSH
45965: LD_EXP 92
45969: PUSH
45970: LD_VAR 0 7
45974: ARRAY
45975: PUSH
45976: FOR_IN
45977: IFFALSE 46067
// if InArea ( x , y , j ) then
45979: LD_VAR 0 2
45983: PPUSH
45984: LD_VAR 0 3
45988: PPUSH
45989: LD_VAR 0 8
45993: PPUSH
45994: CALL_OW 309
45998: IFFALSE 46065
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46000: LD_ADDR_EXP 90
46004: PUSH
46005: LD_EXP 90
46009: PPUSH
46010: LD_VAR 0 7
46014: PUSH
46015: LD_EXP 90
46019: PUSH
46020: LD_VAR 0 7
46024: ARRAY
46025: PUSH
46026: LD_INT 1
46028: PLUS
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: PPUSH
46034: LD_VAR 0 4
46038: PUSH
46039: LD_VAR 0 2
46043: PUSH
46044: LD_VAR 0 3
46048: PUSH
46049: EMPTY
46050: LIST
46051: LIST
46052: LIST
46053: PPUSH
46054: CALL 56238 0 3
46058: ST_TO_ADDR
// exit ;
46059: POP
46060: POP
46061: POP
46062: POP
46063: GO 46238
// end ;
46065: GO 45976
46067: POP
46068: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46069: LD_ADDR_VAR 0 9
46073: PUSH
46074: LD_EXP 74
46078: PUSH
46079: LD_VAR 0 7
46083: ARRAY
46084: PPUSH
46085: LD_INT 2
46087: PUSH
46088: LD_INT 30
46090: PUSH
46091: LD_INT 0
46093: PUSH
46094: EMPTY
46095: LIST
46096: LIST
46097: PUSH
46098: LD_INT 30
46100: PUSH
46101: LD_INT 1
46103: PUSH
46104: EMPTY
46105: LIST
46106: LIST
46107: PUSH
46108: EMPTY
46109: LIST
46110: LIST
46111: LIST
46112: PPUSH
46113: CALL_OW 72
46117: ST_TO_ADDR
// if not depot then
46118: LD_VAR 0 9
46122: NOT
46123: IFFALSE 46127
// continue ;
46125: GO 45945
// for j in depot do
46127: LD_ADDR_VAR 0 8
46131: PUSH
46132: LD_VAR 0 9
46136: PUSH
46137: FOR_IN
46138: IFFALSE 46232
// if GetDistUnitXY ( j , x , y ) < 30 then
46140: LD_VAR 0 8
46144: PPUSH
46145: LD_VAR 0 2
46149: PPUSH
46150: LD_VAR 0 3
46154: PPUSH
46155: CALL_OW 297
46159: PUSH
46160: LD_INT 30
46162: LESS
46163: IFFALSE 46230
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46165: LD_ADDR_EXP 90
46169: PUSH
46170: LD_EXP 90
46174: PPUSH
46175: LD_VAR 0 7
46179: PUSH
46180: LD_EXP 90
46184: PUSH
46185: LD_VAR 0 7
46189: ARRAY
46190: PUSH
46191: LD_INT 1
46193: PLUS
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PPUSH
46199: LD_VAR 0 4
46203: PUSH
46204: LD_VAR 0 2
46208: PUSH
46209: LD_VAR 0 3
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: LIST
46218: PPUSH
46219: CALL 56238 0 3
46223: ST_TO_ADDR
// exit ;
46224: POP
46225: POP
46226: POP
46227: POP
46228: GO 46238
// end ;
46230: GO 46137
46232: POP
46233: POP
// end ;
46234: GO 45945
46236: POP
46237: POP
// end ;
46238: LD_VAR 0 6
46242: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
46243: LD_INT 0
46245: PPUSH
46246: PPUSH
46247: PPUSH
46248: PPUSH
// if not mc_bases or not skirmish then
46249: LD_EXP 74
46253: NOT
46254: PUSH
46255: LD_EXP 72
46259: NOT
46260: OR
46261: IFFALSE 46265
// exit ;
46263: GO 46542
// side := GetSide ( lab ) ;
46265: LD_ADDR_VAR 0 4
46269: PUSH
46270: LD_VAR 0 2
46274: PPUSH
46275: CALL_OW 255
46279: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
46280: LD_VAR 0 4
46284: PUSH
46285: LD_EXP 100
46289: IN
46290: NOT
46291: PUSH
46292: LD_EXP 101
46296: NOT
46297: OR
46298: PUSH
46299: LD_EXP 74
46303: NOT
46304: OR
46305: IFFALSE 46309
// exit ;
46307: GO 46542
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
46309: LD_ADDR_EXP 101
46313: PUSH
46314: LD_EXP 101
46318: PPUSH
46319: LD_VAR 0 4
46323: PPUSH
46324: LD_EXP 101
46328: PUSH
46329: LD_VAR 0 4
46333: ARRAY
46334: PUSH
46335: LD_VAR 0 1
46339: DIFF
46340: PPUSH
46341: CALL_OW 1
46345: ST_TO_ADDR
// for i = 1 to mc_bases do
46346: LD_ADDR_VAR 0 5
46350: PUSH
46351: DOUBLE
46352: LD_INT 1
46354: DEC
46355: ST_TO_ADDR
46356: LD_EXP 74
46360: PUSH
46361: FOR_TO
46362: IFFALSE 46540
// begin if lab in mc_bases [ i ] then
46364: LD_VAR 0 2
46368: PUSH
46369: LD_EXP 74
46373: PUSH
46374: LD_VAR 0 5
46378: ARRAY
46379: IN
46380: IFFALSE 46538
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
46382: LD_VAR 0 1
46386: PUSH
46387: LD_INT 11
46389: PUSH
46390: LD_INT 4
46392: PUSH
46393: LD_INT 3
46395: PUSH
46396: LD_INT 2
46398: PUSH
46399: EMPTY
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: IN
46405: PUSH
46406: LD_EXP 104
46410: PUSH
46411: LD_VAR 0 5
46415: ARRAY
46416: AND
46417: IFFALSE 46538
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
46419: LD_ADDR_VAR 0 6
46423: PUSH
46424: LD_EXP 104
46428: PUSH
46429: LD_VAR 0 5
46433: ARRAY
46434: PUSH
46435: LD_INT 1
46437: ARRAY
46438: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46439: LD_ADDR_EXP 104
46443: PUSH
46444: LD_EXP 104
46448: PPUSH
46449: LD_VAR 0 5
46453: PPUSH
46454: EMPTY
46455: PPUSH
46456: CALL_OW 1
46460: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46461: LD_VAR 0 6
46465: PPUSH
46466: LD_INT 0
46468: PPUSH
46469: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46473: LD_VAR 0 6
46477: PPUSH
46478: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46482: LD_ADDR_EXP 103
46486: PUSH
46487: LD_EXP 103
46491: PPUSH
46492: LD_VAR 0 5
46496: PPUSH
46497: LD_EXP 103
46501: PUSH
46502: LD_VAR 0 5
46506: ARRAY
46507: PPUSH
46508: LD_INT 1
46510: PPUSH
46511: LD_VAR 0 6
46515: PPUSH
46516: CALL_OW 2
46520: PPUSH
46521: CALL_OW 1
46525: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46526: LD_VAR 0 5
46530: PPUSH
46531: LD_INT 112
46533: PPUSH
46534: CALL 23650 0 2
// end ; end ; end ;
46538: GO 46361
46540: POP
46541: POP
// end ;
46542: LD_VAR 0 3
46546: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46547: LD_INT 0
46549: PPUSH
46550: PPUSH
46551: PPUSH
46552: PPUSH
46553: PPUSH
46554: PPUSH
46555: PPUSH
46556: PPUSH
// if not mc_bases or not skirmish then
46557: LD_EXP 74
46561: NOT
46562: PUSH
46563: LD_EXP 72
46567: NOT
46568: OR
46569: IFFALSE 46573
// exit ;
46571: GO 47810
// for i = 1 to mc_bases do
46573: LD_ADDR_VAR 0 3
46577: PUSH
46578: DOUBLE
46579: LD_INT 1
46581: DEC
46582: ST_TO_ADDR
46583: LD_EXP 74
46587: PUSH
46588: FOR_TO
46589: IFFALSE 47808
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46591: LD_VAR 0 1
46595: PUSH
46596: LD_EXP 74
46600: PUSH
46601: LD_VAR 0 3
46605: ARRAY
46606: IN
46607: PUSH
46608: LD_VAR 0 1
46612: PUSH
46613: LD_EXP 81
46617: PUSH
46618: LD_VAR 0 3
46622: ARRAY
46623: IN
46624: OR
46625: PUSH
46626: LD_VAR 0 1
46630: PUSH
46631: LD_EXP 96
46635: PUSH
46636: LD_VAR 0 3
46640: ARRAY
46641: IN
46642: OR
46643: PUSH
46644: LD_VAR 0 1
46648: PUSH
46649: LD_EXP 93
46653: PUSH
46654: LD_VAR 0 3
46658: ARRAY
46659: IN
46660: OR
46661: PUSH
46662: LD_VAR 0 1
46666: PUSH
46667: LD_EXP 103
46671: PUSH
46672: LD_VAR 0 3
46676: ARRAY
46677: IN
46678: OR
46679: PUSH
46680: LD_VAR 0 1
46684: PUSH
46685: LD_EXP 104
46689: PUSH
46690: LD_VAR 0 3
46694: ARRAY
46695: IN
46696: OR
46697: IFFALSE 47806
// begin if un in mc_ape [ i ] then
46699: LD_VAR 0 1
46703: PUSH
46704: LD_EXP 103
46708: PUSH
46709: LD_VAR 0 3
46713: ARRAY
46714: IN
46715: IFFALSE 46754
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46717: LD_ADDR_EXP 103
46721: PUSH
46722: LD_EXP 103
46726: PPUSH
46727: LD_VAR 0 3
46731: PPUSH
46732: LD_EXP 103
46736: PUSH
46737: LD_VAR 0 3
46741: ARRAY
46742: PUSH
46743: LD_VAR 0 1
46747: DIFF
46748: PPUSH
46749: CALL_OW 1
46753: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46754: LD_VAR 0 1
46758: PUSH
46759: LD_EXP 104
46763: PUSH
46764: LD_VAR 0 3
46768: ARRAY
46769: IN
46770: IFFALSE 46794
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46772: LD_ADDR_EXP 104
46776: PUSH
46777: LD_EXP 104
46781: PPUSH
46782: LD_VAR 0 3
46786: PPUSH
46787: EMPTY
46788: PPUSH
46789: CALL_OW 1
46793: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
46794: LD_VAR 0 1
46798: PPUSH
46799: CALL_OW 247
46803: PUSH
46804: LD_INT 2
46806: EQUAL
46807: PUSH
46808: LD_VAR 0 1
46812: PPUSH
46813: CALL_OW 110
46817: PUSH
46818: LD_INT 20
46820: EQUAL
46821: PUSH
46822: LD_VAR 0 1
46826: PUSH
46827: LD_EXP 96
46831: PUSH
46832: LD_VAR 0 3
46836: ARRAY
46837: IN
46838: OR
46839: PUSH
46840: LD_VAR 0 1
46844: PPUSH
46845: CALL_OW 264
46849: PUSH
46850: LD_INT 12
46852: PUSH
46853: LD_INT 51
46855: PUSH
46856: LD_EXP 68
46860: PUSH
46861: LD_INT 32
46863: PUSH
46864: LD_INT 13
46866: PUSH
46867: LD_INT 52
46869: PUSH
46870: EMPTY
46871: LIST
46872: LIST
46873: LIST
46874: LIST
46875: LIST
46876: LIST
46877: IN
46878: OR
46879: AND
46880: IFFALSE 47058
// begin if un in mc_defender [ i ] then
46882: LD_VAR 0 1
46886: PUSH
46887: LD_EXP 96
46891: PUSH
46892: LD_VAR 0 3
46896: ARRAY
46897: IN
46898: IFFALSE 46937
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46900: LD_ADDR_EXP 96
46904: PUSH
46905: LD_EXP 96
46909: PPUSH
46910: LD_VAR 0 3
46914: PPUSH
46915: LD_EXP 96
46919: PUSH
46920: LD_VAR 0 3
46924: ARRAY
46925: PUSH
46926: LD_VAR 0 1
46930: DIFF
46931: PPUSH
46932: CALL_OW 1
46936: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46937: LD_ADDR_VAR 0 8
46941: PUSH
46942: LD_VAR 0 3
46946: PPUSH
46947: LD_INT 3
46949: PPUSH
46950: CALL 43610 0 2
46954: ST_TO_ADDR
// if fac then
46955: LD_VAR 0 8
46959: IFFALSE 47058
// begin for j in fac do
46961: LD_ADDR_VAR 0 4
46965: PUSH
46966: LD_VAR 0 8
46970: PUSH
46971: FOR_IN
46972: IFFALSE 47056
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46974: LD_ADDR_VAR 0 9
46978: PUSH
46979: LD_VAR 0 8
46983: PPUSH
46984: LD_VAR 0 1
46988: PPUSH
46989: CALL_OW 265
46993: PPUSH
46994: LD_VAR 0 1
46998: PPUSH
46999: CALL_OW 262
47003: PPUSH
47004: LD_VAR 0 1
47008: PPUSH
47009: CALL_OW 263
47013: PPUSH
47014: LD_VAR 0 1
47018: PPUSH
47019: CALL_OW 264
47023: PPUSH
47024: CALL 53770 0 5
47028: ST_TO_ADDR
// if components then
47029: LD_VAR 0 9
47033: IFFALSE 47054
// begin MC_InsertProduceList ( i , [ components ] ) ;
47035: LD_VAR 0 3
47039: PPUSH
47040: LD_VAR 0 9
47044: PUSH
47045: EMPTY
47046: LIST
47047: PPUSH
47048: CALL 43155 0 2
// break ;
47052: GO 47056
// end ; end ;
47054: GO 46971
47056: POP
47057: POP
// end ; end ; if GetType ( un ) = unit_building then
47058: LD_VAR 0 1
47062: PPUSH
47063: CALL_OW 247
47067: PUSH
47068: LD_INT 3
47070: EQUAL
47071: IFFALSE 47474
// begin btype := GetBType ( un ) ;
47073: LD_ADDR_VAR 0 5
47077: PUSH
47078: LD_VAR 0 1
47082: PPUSH
47083: CALL_OW 266
47087: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
47088: LD_VAR 0 5
47092: PUSH
47093: LD_INT 29
47095: PUSH
47096: LD_INT 30
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: IN
47103: IFFALSE 47176
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
47105: LD_VAR 0 1
47109: PPUSH
47110: CALL_OW 250
47114: PPUSH
47115: LD_VAR 0 1
47119: PPUSH
47120: CALL_OW 251
47124: PPUSH
47125: LD_VAR 0 1
47129: PPUSH
47130: CALL_OW 255
47134: PPUSH
47135: CALL_OW 440
47139: NOT
47140: IFFALSE 47176
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
47142: LD_VAR 0 1
47146: PPUSH
47147: CALL_OW 250
47151: PPUSH
47152: LD_VAR 0 1
47156: PPUSH
47157: CALL_OW 251
47161: PPUSH
47162: LD_VAR 0 1
47166: PPUSH
47167: CALL_OW 255
47171: PPUSH
47172: CALL_OW 441
// end ; if btype = b_warehouse then
47176: LD_VAR 0 5
47180: PUSH
47181: LD_INT 1
47183: EQUAL
47184: IFFALSE 47202
// begin btype := b_depot ;
47186: LD_ADDR_VAR 0 5
47190: PUSH
47191: LD_INT 0
47193: ST_TO_ADDR
// pos := 1 ;
47194: LD_ADDR_VAR 0 6
47198: PUSH
47199: LD_INT 1
47201: ST_TO_ADDR
// end ; if btype = b_factory then
47202: LD_VAR 0 5
47206: PUSH
47207: LD_INT 3
47209: EQUAL
47210: IFFALSE 47228
// begin btype := b_workshop ;
47212: LD_ADDR_VAR 0 5
47216: PUSH
47217: LD_INT 2
47219: ST_TO_ADDR
// pos := 1 ;
47220: LD_ADDR_VAR 0 6
47224: PUSH
47225: LD_INT 1
47227: ST_TO_ADDR
// end ; if btype = b_barracks then
47228: LD_VAR 0 5
47232: PUSH
47233: LD_INT 5
47235: EQUAL
47236: IFFALSE 47246
// btype := b_armoury ;
47238: LD_ADDR_VAR 0 5
47242: PUSH
47243: LD_INT 4
47245: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
47246: LD_VAR 0 5
47250: PUSH
47251: LD_INT 7
47253: PUSH
47254: LD_INT 8
47256: PUSH
47257: EMPTY
47258: LIST
47259: LIST
47260: IN
47261: IFFALSE 47271
// btype := b_lab ;
47263: LD_ADDR_VAR 0 5
47267: PUSH
47268: LD_INT 6
47270: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
47271: LD_ADDR_EXP 79
47275: PUSH
47276: LD_EXP 79
47280: PPUSH
47281: LD_VAR 0 3
47285: PUSH
47286: LD_EXP 79
47290: PUSH
47291: LD_VAR 0 3
47295: ARRAY
47296: PUSH
47297: LD_INT 1
47299: PLUS
47300: PUSH
47301: EMPTY
47302: LIST
47303: LIST
47304: PPUSH
47305: LD_VAR 0 5
47309: PUSH
47310: LD_VAR 0 1
47314: PPUSH
47315: CALL_OW 250
47319: PUSH
47320: LD_VAR 0 1
47324: PPUSH
47325: CALL_OW 251
47329: PUSH
47330: LD_VAR 0 1
47334: PPUSH
47335: CALL_OW 254
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: LIST
47344: LIST
47345: PPUSH
47346: CALL 56238 0 3
47350: ST_TO_ADDR
// if pos = 1 then
47351: LD_VAR 0 6
47355: PUSH
47356: LD_INT 1
47358: EQUAL
47359: IFFALSE 47474
// begin tmp := mc_build_list [ i ] ;
47361: LD_ADDR_VAR 0 7
47365: PUSH
47366: LD_EXP 79
47370: PUSH
47371: LD_VAR 0 3
47375: ARRAY
47376: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47377: LD_VAR 0 7
47381: PPUSH
47382: LD_INT 2
47384: PUSH
47385: LD_INT 30
47387: PUSH
47388: LD_INT 0
47390: PUSH
47391: EMPTY
47392: LIST
47393: LIST
47394: PUSH
47395: LD_INT 30
47397: PUSH
47398: LD_INT 1
47400: PUSH
47401: EMPTY
47402: LIST
47403: LIST
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: LIST
47409: PPUSH
47410: CALL_OW 72
47414: IFFALSE 47424
// pos := 2 ;
47416: LD_ADDR_VAR 0 6
47420: PUSH
47421: LD_INT 2
47423: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47424: LD_ADDR_VAR 0 7
47428: PUSH
47429: LD_VAR 0 7
47433: PPUSH
47434: LD_VAR 0 6
47438: PPUSH
47439: LD_VAR 0 7
47443: PPUSH
47444: CALL 56564 0 3
47448: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47449: LD_ADDR_EXP 79
47453: PUSH
47454: LD_EXP 79
47458: PPUSH
47459: LD_VAR 0 3
47463: PPUSH
47464: LD_VAR 0 7
47468: PPUSH
47469: CALL_OW 1
47473: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47474: LD_VAR 0 1
47478: PUSH
47479: LD_EXP 74
47483: PUSH
47484: LD_VAR 0 3
47488: ARRAY
47489: IN
47490: IFFALSE 47529
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47492: LD_ADDR_EXP 74
47496: PUSH
47497: LD_EXP 74
47501: PPUSH
47502: LD_VAR 0 3
47506: PPUSH
47507: LD_EXP 74
47511: PUSH
47512: LD_VAR 0 3
47516: ARRAY
47517: PUSH
47518: LD_VAR 0 1
47522: DIFF
47523: PPUSH
47524: CALL_OW 1
47528: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47529: LD_VAR 0 1
47533: PUSH
47534: LD_EXP 81
47538: PUSH
47539: LD_VAR 0 3
47543: ARRAY
47544: IN
47545: IFFALSE 47584
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47547: LD_ADDR_EXP 81
47551: PUSH
47552: LD_EXP 81
47556: PPUSH
47557: LD_VAR 0 3
47561: PPUSH
47562: LD_EXP 81
47566: PUSH
47567: LD_VAR 0 3
47571: ARRAY
47572: PUSH
47573: LD_VAR 0 1
47577: DIFF
47578: PPUSH
47579: CALL_OW 1
47583: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47584: LD_VAR 0 1
47588: PUSH
47589: LD_EXP 93
47593: PUSH
47594: LD_VAR 0 3
47598: ARRAY
47599: IN
47600: IFFALSE 47639
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47602: LD_ADDR_EXP 93
47606: PUSH
47607: LD_EXP 93
47611: PPUSH
47612: LD_VAR 0 3
47616: PPUSH
47617: LD_EXP 93
47621: PUSH
47622: LD_VAR 0 3
47626: ARRAY
47627: PUSH
47628: LD_VAR 0 1
47632: DIFF
47633: PPUSH
47634: CALL_OW 1
47638: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47639: LD_VAR 0 1
47643: PUSH
47644: LD_EXP 96
47648: PUSH
47649: LD_VAR 0 3
47653: ARRAY
47654: IN
47655: IFFALSE 47694
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47657: LD_ADDR_EXP 96
47661: PUSH
47662: LD_EXP 96
47666: PPUSH
47667: LD_VAR 0 3
47671: PPUSH
47672: LD_EXP 96
47676: PUSH
47677: LD_VAR 0 3
47681: ARRAY
47682: PUSH
47683: LD_VAR 0 1
47687: DIFF
47688: PPUSH
47689: CALL_OW 1
47693: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47694: LD_VAR 0 1
47698: PUSH
47699: LD_EXP 83
47703: PUSH
47704: LD_VAR 0 3
47708: ARRAY
47709: IN
47710: IFFALSE 47749
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47712: LD_ADDR_EXP 83
47716: PUSH
47717: LD_EXP 83
47721: PPUSH
47722: LD_VAR 0 3
47726: PPUSH
47727: LD_EXP 83
47731: PUSH
47732: LD_VAR 0 3
47736: ARRAY
47737: PUSH
47738: LD_VAR 0 1
47742: DIFF
47743: PPUSH
47744: CALL_OW 1
47748: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47749: LD_VAR 0 1
47753: PUSH
47754: LD_EXP 82
47758: PUSH
47759: LD_VAR 0 3
47763: ARRAY
47764: IN
47765: IFFALSE 47804
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47767: LD_ADDR_EXP 82
47771: PUSH
47772: LD_EXP 82
47776: PPUSH
47777: LD_VAR 0 3
47781: PPUSH
47782: LD_EXP 82
47786: PUSH
47787: LD_VAR 0 3
47791: ARRAY
47792: PUSH
47793: LD_VAR 0 1
47797: DIFF
47798: PPUSH
47799: CALL_OW 1
47803: ST_TO_ADDR
// end ; break ;
47804: GO 47808
// end ;
47806: GO 46588
47808: POP
47809: POP
// end ;
47810: LD_VAR 0 2
47814: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47815: LD_INT 0
47817: PPUSH
47818: PPUSH
47819: PPUSH
// if not mc_bases or not skirmish then
47820: LD_EXP 74
47824: NOT
47825: PUSH
47826: LD_EXP 72
47830: NOT
47831: OR
47832: IFFALSE 47836
// exit ;
47834: GO 48051
// for i = 1 to mc_bases do
47836: LD_ADDR_VAR 0 3
47840: PUSH
47841: DOUBLE
47842: LD_INT 1
47844: DEC
47845: ST_TO_ADDR
47846: LD_EXP 74
47850: PUSH
47851: FOR_TO
47852: IFFALSE 48049
// begin if building in mc_construct_list [ i ] then
47854: LD_VAR 0 1
47858: PUSH
47859: LD_EXP 81
47863: PUSH
47864: LD_VAR 0 3
47868: ARRAY
47869: IN
47870: IFFALSE 48047
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47872: LD_ADDR_EXP 81
47876: PUSH
47877: LD_EXP 81
47881: PPUSH
47882: LD_VAR 0 3
47886: PPUSH
47887: LD_EXP 81
47891: PUSH
47892: LD_VAR 0 3
47896: ARRAY
47897: PUSH
47898: LD_VAR 0 1
47902: DIFF
47903: PPUSH
47904: CALL_OW 1
47908: ST_TO_ADDR
// if building in mc_lab [ i ] then
47909: LD_VAR 0 1
47913: PUSH
47914: LD_EXP 107
47918: PUSH
47919: LD_VAR 0 3
47923: ARRAY
47924: IN
47925: IFFALSE 47980
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47927: LD_ADDR_EXP 108
47931: PUSH
47932: LD_EXP 108
47936: PPUSH
47937: LD_VAR 0 3
47941: PPUSH
47942: LD_EXP 108
47946: PUSH
47947: LD_VAR 0 3
47951: ARRAY
47952: PPUSH
47953: LD_INT 1
47955: PPUSH
47956: LD_EXP 108
47960: PUSH
47961: LD_VAR 0 3
47965: ARRAY
47966: PPUSH
47967: LD_INT 0
47969: PPUSH
47970: CALL 55656 0 4
47974: PPUSH
47975: CALL_OW 1
47979: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47980: LD_VAR 0 1
47984: PUSH
47985: LD_EXP 74
47989: PUSH
47990: LD_VAR 0 3
47994: ARRAY
47995: IN
47996: NOT
47997: IFFALSE 48043
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47999: LD_ADDR_EXP 74
48003: PUSH
48004: LD_EXP 74
48008: PPUSH
48009: LD_VAR 0 3
48013: PUSH
48014: LD_EXP 74
48018: PUSH
48019: LD_VAR 0 3
48023: ARRAY
48024: PUSH
48025: LD_INT 1
48027: PLUS
48028: PUSH
48029: EMPTY
48030: LIST
48031: LIST
48032: PPUSH
48033: LD_VAR 0 1
48037: PPUSH
48038: CALL 56238 0 3
48042: ST_TO_ADDR
// exit ;
48043: POP
48044: POP
48045: GO 48051
// end ; end ;
48047: GO 47851
48049: POP
48050: POP
// end ;
48051: LD_VAR 0 2
48055: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
48056: LD_INT 0
48058: PPUSH
48059: PPUSH
48060: PPUSH
48061: PPUSH
48062: PPUSH
48063: PPUSH
48064: PPUSH
// if not mc_bases or not skirmish then
48065: LD_EXP 74
48069: NOT
48070: PUSH
48071: LD_EXP 72
48075: NOT
48076: OR
48077: IFFALSE 48081
// exit ;
48079: GO 48742
// for i = 1 to mc_bases do
48081: LD_ADDR_VAR 0 3
48085: PUSH
48086: DOUBLE
48087: LD_INT 1
48089: DEC
48090: ST_TO_ADDR
48091: LD_EXP 74
48095: PUSH
48096: FOR_TO
48097: IFFALSE 48740
// begin if building in mc_construct_list [ i ] then
48099: LD_VAR 0 1
48103: PUSH
48104: LD_EXP 81
48108: PUSH
48109: LD_VAR 0 3
48113: ARRAY
48114: IN
48115: IFFALSE 48738
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48117: LD_ADDR_EXP 81
48121: PUSH
48122: LD_EXP 81
48126: PPUSH
48127: LD_VAR 0 3
48131: PPUSH
48132: LD_EXP 81
48136: PUSH
48137: LD_VAR 0 3
48141: ARRAY
48142: PUSH
48143: LD_VAR 0 1
48147: DIFF
48148: PPUSH
48149: CALL_OW 1
48153: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48154: LD_ADDR_EXP 74
48158: PUSH
48159: LD_EXP 74
48163: PPUSH
48164: LD_VAR 0 3
48168: PUSH
48169: LD_EXP 74
48173: PUSH
48174: LD_VAR 0 3
48178: ARRAY
48179: PUSH
48180: LD_INT 1
48182: PLUS
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PPUSH
48188: LD_VAR 0 1
48192: PPUSH
48193: CALL 56238 0 3
48197: ST_TO_ADDR
// btype := GetBType ( building ) ;
48198: LD_ADDR_VAR 0 5
48202: PUSH
48203: LD_VAR 0 1
48207: PPUSH
48208: CALL_OW 266
48212: ST_TO_ADDR
// side := GetSide ( building ) ;
48213: LD_ADDR_VAR 0 8
48217: PUSH
48218: LD_VAR 0 1
48222: PPUSH
48223: CALL_OW 255
48227: ST_TO_ADDR
// if btype = b_lab then
48228: LD_VAR 0 5
48232: PUSH
48233: LD_INT 6
48235: EQUAL
48236: IFFALSE 48286
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
48238: LD_ADDR_EXP 107
48242: PUSH
48243: LD_EXP 107
48247: PPUSH
48248: LD_VAR 0 3
48252: PUSH
48253: LD_EXP 107
48257: PUSH
48258: LD_VAR 0 3
48262: ARRAY
48263: PUSH
48264: LD_INT 1
48266: PLUS
48267: PUSH
48268: EMPTY
48269: LIST
48270: LIST
48271: PPUSH
48272: LD_VAR 0 1
48276: PPUSH
48277: CALL 56238 0 3
48281: ST_TO_ADDR
// exit ;
48282: POP
48283: POP
48284: GO 48742
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
48286: LD_VAR 0 5
48290: PUSH
48291: LD_INT 0
48293: PUSH
48294: LD_INT 2
48296: PUSH
48297: LD_INT 4
48299: PUSH
48300: EMPTY
48301: LIST
48302: LIST
48303: LIST
48304: IN
48305: IFFALSE 48429
// begin if btype = b_armoury then
48307: LD_VAR 0 5
48311: PUSH
48312: LD_INT 4
48314: EQUAL
48315: IFFALSE 48325
// btype := b_barracks ;
48317: LD_ADDR_VAR 0 5
48321: PUSH
48322: LD_INT 5
48324: ST_TO_ADDR
// if btype = b_depot then
48325: LD_VAR 0 5
48329: PUSH
48330: LD_INT 0
48332: EQUAL
48333: IFFALSE 48343
// btype := b_warehouse ;
48335: LD_ADDR_VAR 0 5
48339: PUSH
48340: LD_INT 1
48342: ST_TO_ADDR
// if btype = b_workshop then
48343: LD_VAR 0 5
48347: PUSH
48348: LD_INT 2
48350: EQUAL
48351: IFFALSE 48361
// btype := b_factory ;
48353: LD_ADDR_VAR 0 5
48357: PUSH
48358: LD_INT 3
48360: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48361: LD_VAR 0 5
48365: PPUSH
48366: LD_VAR 0 8
48370: PPUSH
48371: CALL_OW 323
48375: PUSH
48376: LD_INT 1
48378: EQUAL
48379: IFFALSE 48425
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48381: LD_ADDR_EXP 106
48385: PUSH
48386: LD_EXP 106
48390: PPUSH
48391: LD_VAR 0 3
48395: PUSH
48396: LD_EXP 106
48400: PUSH
48401: LD_VAR 0 3
48405: ARRAY
48406: PUSH
48407: LD_INT 1
48409: PLUS
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PPUSH
48415: LD_VAR 0 1
48419: PPUSH
48420: CALL 56238 0 3
48424: ST_TO_ADDR
// exit ;
48425: POP
48426: POP
48427: GO 48742
// end ; if btype in [ b_bunker , b_turret ] then
48429: LD_VAR 0 5
48433: PUSH
48434: LD_INT 32
48436: PUSH
48437: LD_INT 33
48439: PUSH
48440: EMPTY
48441: LIST
48442: LIST
48443: IN
48444: IFFALSE 48734
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48446: LD_ADDR_EXP 82
48450: PUSH
48451: LD_EXP 82
48455: PPUSH
48456: LD_VAR 0 3
48460: PUSH
48461: LD_EXP 82
48465: PUSH
48466: LD_VAR 0 3
48470: ARRAY
48471: PUSH
48472: LD_INT 1
48474: PLUS
48475: PUSH
48476: EMPTY
48477: LIST
48478: LIST
48479: PPUSH
48480: LD_VAR 0 1
48484: PPUSH
48485: CALL 56238 0 3
48489: ST_TO_ADDR
// if btype = b_bunker then
48490: LD_VAR 0 5
48494: PUSH
48495: LD_INT 32
48497: EQUAL
48498: IFFALSE 48734
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48500: LD_ADDR_EXP 83
48504: PUSH
48505: LD_EXP 83
48509: PPUSH
48510: LD_VAR 0 3
48514: PUSH
48515: LD_EXP 83
48519: PUSH
48520: LD_VAR 0 3
48524: ARRAY
48525: PUSH
48526: LD_INT 1
48528: PLUS
48529: PUSH
48530: EMPTY
48531: LIST
48532: LIST
48533: PPUSH
48534: LD_VAR 0 1
48538: PPUSH
48539: CALL 56238 0 3
48543: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48544: LD_ADDR_VAR 0 6
48548: PUSH
48549: LD_EXP 74
48553: PUSH
48554: LD_VAR 0 3
48558: ARRAY
48559: PPUSH
48560: LD_INT 25
48562: PUSH
48563: LD_INT 1
48565: PUSH
48566: EMPTY
48567: LIST
48568: LIST
48569: PUSH
48570: LD_INT 3
48572: PUSH
48573: LD_INT 54
48575: PUSH
48576: EMPTY
48577: LIST
48578: PUSH
48579: EMPTY
48580: LIST
48581: LIST
48582: PUSH
48583: EMPTY
48584: LIST
48585: LIST
48586: PPUSH
48587: CALL_OW 72
48591: ST_TO_ADDR
// if tmp then
48592: LD_VAR 0 6
48596: IFFALSE 48602
// exit ;
48598: POP
48599: POP
48600: GO 48742
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48602: LD_ADDR_VAR 0 6
48606: PUSH
48607: LD_EXP 74
48611: PUSH
48612: LD_VAR 0 3
48616: ARRAY
48617: PPUSH
48618: LD_INT 2
48620: PUSH
48621: LD_INT 30
48623: PUSH
48624: LD_INT 4
48626: PUSH
48627: EMPTY
48628: LIST
48629: LIST
48630: PUSH
48631: LD_INT 30
48633: PUSH
48634: LD_INT 5
48636: PUSH
48637: EMPTY
48638: LIST
48639: LIST
48640: PUSH
48641: EMPTY
48642: LIST
48643: LIST
48644: LIST
48645: PPUSH
48646: CALL_OW 72
48650: ST_TO_ADDR
// if not tmp then
48651: LD_VAR 0 6
48655: NOT
48656: IFFALSE 48662
// exit ;
48658: POP
48659: POP
48660: GO 48742
// for j in tmp do
48662: LD_ADDR_VAR 0 4
48666: PUSH
48667: LD_VAR 0 6
48671: PUSH
48672: FOR_IN
48673: IFFALSE 48732
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48675: LD_ADDR_VAR 0 7
48679: PUSH
48680: LD_VAR 0 4
48684: PPUSH
48685: CALL_OW 313
48689: PPUSH
48690: LD_INT 25
48692: PUSH
48693: LD_INT 1
48695: PUSH
48696: EMPTY
48697: LIST
48698: LIST
48699: PPUSH
48700: CALL_OW 72
48704: ST_TO_ADDR
// if units then
48705: LD_VAR 0 7
48709: IFFALSE 48730
// begin ComExitBuilding ( units [ 1 ] ) ;
48711: LD_VAR 0 7
48715: PUSH
48716: LD_INT 1
48718: ARRAY
48719: PPUSH
48720: CALL_OW 122
// exit ;
48724: POP
48725: POP
48726: POP
48727: POP
48728: GO 48742
// end ; end ;
48730: GO 48672
48732: POP
48733: POP
// end ; end ; exit ;
48734: POP
48735: POP
48736: GO 48742
// end ; end ;
48738: GO 48096
48740: POP
48741: POP
// end ;
48742: LD_VAR 0 2
48746: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48747: LD_INT 0
48749: PPUSH
48750: PPUSH
48751: PPUSH
48752: PPUSH
48753: PPUSH
48754: PPUSH
48755: PPUSH
// if not mc_bases or not skirmish then
48756: LD_EXP 74
48760: NOT
48761: PUSH
48762: LD_EXP 72
48766: NOT
48767: OR
48768: IFFALSE 48772
// exit ;
48770: GO 49003
// btype := GetBType ( building ) ;
48772: LD_ADDR_VAR 0 6
48776: PUSH
48777: LD_VAR 0 1
48781: PPUSH
48782: CALL_OW 266
48786: ST_TO_ADDR
// x := GetX ( building ) ;
48787: LD_ADDR_VAR 0 7
48791: PUSH
48792: LD_VAR 0 1
48796: PPUSH
48797: CALL_OW 250
48801: ST_TO_ADDR
// y := GetY ( building ) ;
48802: LD_ADDR_VAR 0 8
48806: PUSH
48807: LD_VAR 0 1
48811: PPUSH
48812: CALL_OW 251
48816: ST_TO_ADDR
// d := GetDir ( building ) ;
48817: LD_ADDR_VAR 0 9
48821: PUSH
48822: LD_VAR 0 1
48826: PPUSH
48827: CALL_OW 254
48831: ST_TO_ADDR
// for i = 1 to mc_bases do
48832: LD_ADDR_VAR 0 4
48836: PUSH
48837: DOUBLE
48838: LD_INT 1
48840: DEC
48841: ST_TO_ADDR
48842: LD_EXP 74
48846: PUSH
48847: FOR_TO
48848: IFFALSE 49001
// begin if not mc_build_list [ i ] then
48850: LD_EXP 79
48854: PUSH
48855: LD_VAR 0 4
48859: ARRAY
48860: NOT
48861: IFFALSE 48865
// continue ;
48863: GO 48847
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
48865: LD_VAR 0 6
48869: PUSH
48870: LD_VAR 0 7
48874: PUSH
48875: LD_VAR 0 8
48879: PUSH
48880: LD_VAR 0 9
48884: PUSH
48885: EMPTY
48886: LIST
48887: LIST
48888: LIST
48889: LIST
48890: PPUSH
48891: LD_EXP 79
48895: PUSH
48896: LD_VAR 0 4
48900: ARRAY
48901: PUSH
48902: LD_INT 1
48904: ARRAY
48905: PPUSH
48906: CALL 62407 0 2
48910: IFFALSE 48999
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
48912: LD_ADDR_EXP 79
48916: PUSH
48917: LD_EXP 79
48921: PPUSH
48922: LD_VAR 0 4
48926: PPUSH
48927: LD_EXP 79
48931: PUSH
48932: LD_VAR 0 4
48936: ARRAY
48937: PPUSH
48938: LD_INT 1
48940: PPUSH
48941: CALL_OW 3
48945: PPUSH
48946: CALL_OW 1
48950: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48951: LD_ADDR_EXP 81
48955: PUSH
48956: LD_EXP 81
48960: PPUSH
48961: LD_VAR 0 4
48965: PUSH
48966: LD_EXP 81
48970: PUSH
48971: LD_VAR 0 4
48975: ARRAY
48976: PUSH
48977: LD_INT 1
48979: PLUS
48980: PUSH
48981: EMPTY
48982: LIST
48983: LIST
48984: PPUSH
48985: LD_VAR 0 1
48989: PPUSH
48990: CALL 56238 0 3
48994: ST_TO_ADDR
// exit ;
48995: POP
48996: POP
48997: GO 49003
// end ; end ;
48999: GO 48847
49001: POP
49002: POP
// end ;
49003: LD_VAR 0 3
49007: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
49008: LD_INT 0
49010: PPUSH
49011: PPUSH
49012: PPUSH
// if not mc_bases or not skirmish then
49013: LD_EXP 74
49017: NOT
49018: PUSH
49019: LD_EXP 72
49023: NOT
49024: OR
49025: IFFALSE 49029
// exit ;
49027: GO 49219
// for i = 1 to mc_bases do
49029: LD_ADDR_VAR 0 4
49033: PUSH
49034: DOUBLE
49035: LD_INT 1
49037: DEC
49038: ST_TO_ADDR
49039: LD_EXP 74
49043: PUSH
49044: FOR_TO
49045: IFFALSE 49132
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
49047: LD_VAR 0 1
49051: PUSH
49052: LD_EXP 82
49056: PUSH
49057: LD_VAR 0 4
49061: ARRAY
49062: IN
49063: PUSH
49064: LD_VAR 0 1
49068: PUSH
49069: LD_EXP 83
49073: PUSH
49074: LD_VAR 0 4
49078: ARRAY
49079: IN
49080: NOT
49081: AND
49082: IFFALSE 49130
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49084: LD_ADDR_EXP 83
49088: PUSH
49089: LD_EXP 83
49093: PPUSH
49094: LD_VAR 0 4
49098: PUSH
49099: LD_EXP 83
49103: PUSH
49104: LD_VAR 0 4
49108: ARRAY
49109: PUSH
49110: LD_INT 1
49112: PLUS
49113: PUSH
49114: EMPTY
49115: LIST
49116: LIST
49117: PPUSH
49118: LD_VAR 0 1
49122: PPUSH
49123: CALL 56238 0 3
49127: ST_TO_ADDR
// break ;
49128: GO 49132
// end ; end ;
49130: GO 49044
49132: POP
49133: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
49134: LD_VAR 0 1
49138: PPUSH
49139: CALL_OW 257
49143: PUSH
49144: LD_EXP 100
49148: IN
49149: PUSH
49150: LD_VAR 0 1
49154: PPUSH
49155: CALL_OW 266
49159: PUSH
49160: LD_INT 5
49162: EQUAL
49163: AND
49164: PUSH
49165: LD_VAR 0 2
49169: PPUSH
49170: CALL_OW 110
49174: PUSH
49175: LD_INT 18
49177: NONEQUAL
49178: AND
49179: IFFALSE 49219
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
49181: LD_VAR 0 2
49185: PPUSH
49186: CALL_OW 257
49190: PUSH
49191: LD_INT 5
49193: PUSH
49194: LD_INT 8
49196: PUSH
49197: LD_INT 9
49199: PUSH
49200: EMPTY
49201: LIST
49202: LIST
49203: LIST
49204: IN
49205: IFFALSE 49219
// SetClass ( unit , 1 ) ;
49207: LD_VAR 0 2
49211: PPUSH
49212: LD_INT 1
49214: PPUSH
49215: CALL_OW 336
// end ;
49219: LD_VAR 0 3
49223: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
49224: LD_INT 0
49226: PPUSH
49227: PPUSH
// if not mc_bases or not skirmish then
49228: LD_EXP 74
49232: NOT
49233: PUSH
49234: LD_EXP 72
49238: NOT
49239: OR
49240: IFFALSE 49244
// exit ;
49242: GO 49360
// if GetLives ( abandoned_vehicle ) > 250 then
49244: LD_VAR 0 2
49248: PPUSH
49249: CALL_OW 256
49253: PUSH
49254: LD_INT 250
49256: GREATER
49257: IFFALSE 49261
// exit ;
49259: GO 49360
// for i = 1 to mc_bases do
49261: LD_ADDR_VAR 0 6
49265: PUSH
49266: DOUBLE
49267: LD_INT 1
49269: DEC
49270: ST_TO_ADDR
49271: LD_EXP 74
49275: PUSH
49276: FOR_TO
49277: IFFALSE 49358
// begin if driver in mc_bases [ i ] then
49279: LD_VAR 0 1
49283: PUSH
49284: LD_EXP 74
49288: PUSH
49289: LD_VAR 0 6
49293: ARRAY
49294: IN
49295: IFFALSE 49356
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49297: LD_VAR 0 1
49301: PPUSH
49302: LD_EXP 74
49306: PUSH
49307: LD_VAR 0 6
49311: ARRAY
49312: PPUSH
49313: LD_INT 2
49315: PUSH
49316: LD_INT 30
49318: PUSH
49319: LD_INT 0
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PUSH
49326: LD_INT 30
49328: PUSH
49329: LD_INT 1
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: PUSH
49336: EMPTY
49337: LIST
49338: LIST
49339: LIST
49340: PPUSH
49341: CALL_OW 72
49345: PUSH
49346: LD_INT 1
49348: ARRAY
49349: PPUSH
49350: CALL_OW 112
// break ;
49354: GO 49358
// end ; end ;
49356: GO 49276
49358: POP
49359: POP
// end ; end_of_file
49360: LD_VAR 0 5
49364: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49365: LD_INT 0
49367: PPUSH
49368: PPUSH
// if exist_mode then
49369: LD_VAR 0 2
49373: IFFALSE 49398
// unit := CreateCharacter ( prefix & ident ) else
49375: LD_ADDR_VAR 0 5
49379: PUSH
49380: LD_VAR 0 3
49384: PUSH
49385: LD_VAR 0 1
49389: STR
49390: PPUSH
49391: CALL_OW 34
49395: ST_TO_ADDR
49396: GO 49413
// unit := NewCharacter ( ident ) ;
49398: LD_ADDR_VAR 0 5
49402: PUSH
49403: LD_VAR 0 1
49407: PPUSH
49408: CALL_OW 25
49412: ST_TO_ADDR
// result := unit ;
49413: LD_ADDR_VAR 0 4
49417: PUSH
49418: LD_VAR 0 5
49422: ST_TO_ADDR
// end ;
49423: LD_VAR 0 4
49427: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49428: LD_INT 0
49430: PPUSH
49431: PPUSH
// if not side or not nation then
49432: LD_VAR 0 1
49436: NOT
49437: PUSH
49438: LD_VAR 0 2
49442: NOT
49443: OR
49444: IFFALSE 49448
// exit ;
49446: GO 50092
// case nation of nation_american :
49448: LD_VAR 0 2
49452: PUSH
49453: LD_INT 1
49455: DOUBLE
49456: EQUAL
49457: IFTRUE 49461
49459: GO 49635
49461: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
49462: LD_ADDR_VAR 0 4
49466: PUSH
49467: LD_INT 35
49469: PUSH
49470: LD_INT 45
49472: PUSH
49473: LD_INT 46
49475: PUSH
49476: LD_INT 47
49478: PUSH
49479: LD_INT 1
49481: PUSH
49482: LD_INT 2
49484: PUSH
49485: LD_INT 6
49487: PUSH
49488: LD_INT 15
49490: PUSH
49491: LD_INT 16
49493: PUSH
49494: LD_INT 7
49496: PUSH
49497: LD_INT 12
49499: PUSH
49500: LD_INT 13
49502: PUSH
49503: LD_INT 10
49505: PUSH
49506: LD_INT 14
49508: PUSH
49509: LD_INT 20
49511: PUSH
49512: LD_INT 21
49514: PUSH
49515: LD_INT 22
49517: PUSH
49518: LD_INT 25
49520: PUSH
49521: LD_INT 32
49523: PUSH
49524: LD_INT 27
49526: PUSH
49527: LD_INT 36
49529: PUSH
49530: LD_INT 69
49532: PUSH
49533: LD_INT 39
49535: PUSH
49536: LD_INT 34
49538: PUSH
49539: LD_INT 40
49541: PUSH
49542: LD_INT 48
49544: PUSH
49545: LD_INT 49
49547: PUSH
49548: LD_INT 50
49550: PUSH
49551: LD_INT 51
49553: PUSH
49554: LD_INT 52
49556: PUSH
49557: LD_INT 53
49559: PUSH
49560: LD_INT 54
49562: PUSH
49563: LD_INT 55
49565: PUSH
49566: LD_INT 56
49568: PUSH
49569: LD_INT 57
49571: PUSH
49572: LD_INT 58
49574: PUSH
49575: LD_INT 59
49577: PUSH
49578: LD_INT 60
49580: PUSH
49581: LD_INT 61
49583: PUSH
49584: LD_INT 62
49586: PUSH
49587: LD_INT 80
49589: PUSH
49590: EMPTY
49591: LIST
49592: LIST
49593: LIST
49594: LIST
49595: LIST
49596: LIST
49597: LIST
49598: LIST
49599: LIST
49600: LIST
49601: LIST
49602: LIST
49603: LIST
49604: LIST
49605: LIST
49606: LIST
49607: LIST
49608: LIST
49609: LIST
49610: LIST
49611: LIST
49612: LIST
49613: LIST
49614: LIST
49615: LIST
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: LIST
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: LIST
49632: ST_TO_ADDR
49633: GO 50016
49635: LD_INT 2
49637: DOUBLE
49638: EQUAL
49639: IFTRUE 49643
49641: GO 49825
49643: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
49644: LD_ADDR_VAR 0 4
49648: PUSH
49649: LD_INT 35
49651: PUSH
49652: LD_INT 45
49654: PUSH
49655: LD_INT 46
49657: PUSH
49658: LD_INT 47
49660: PUSH
49661: LD_INT 70
49663: PUSH
49664: LD_INT 1
49666: PUSH
49667: LD_INT 11
49669: PUSH
49670: LD_INT 3
49672: PUSH
49673: LD_INT 4
49675: PUSH
49676: LD_INT 5
49678: PUSH
49679: LD_INT 6
49681: PUSH
49682: LD_INT 15
49684: PUSH
49685: LD_INT 18
49687: PUSH
49688: LD_INT 7
49690: PUSH
49691: LD_INT 17
49693: PUSH
49694: LD_INT 8
49696: PUSH
49697: LD_INT 20
49699: PUSH
49700: LD_INT 21
49702: PUSH
49703: LD_INT 22
49705: PUSH
49706: LD_INT 72
49708: PUSH
49709: LD_INT 26
49711: PUSH
49712: LD_INT 69
49714: PUSH
49715: LD_INT 39
49717: PUSH
49718: LD_INT 40
49720: PUSH
49721: LD_INT 41
49723: PUSH
49724: LD_INT 42
49726: PUSH
49727: LD_INT 43
49729: PUSH
49730: LD_INT 48
49732: PUSH
49733: LD_INT 49
49735: PUSH
49736: LD_INT 50
49738: PUSH
49739: LD_INT 51
49741: PUSH
49742: LD_INT 52
49744: PUSH
49745: LD_INT 53
49747: PUSH
49748: LD_INT 54
49750: PUSH
49751: LD_INT 55
49753: PUSH
49754: LD_INT 56
49756: PUSH
49757: LD_INT 60
49759: PUSH
49760: LD_INT 61
49762: PUSH
49763: LD_INT 62
49765: PUSH
49766: LD_INT 66
49768: PUSH
49769: LD_INT 67
49771: PUSH
49772: LD_INT 68
49774: PUSH
49775: LD_INT 81
49777: PUSH
49778: EMPTY
49779: LIST
49780: LIST
49781: LIST
49782: LIST
49783: LIST
49784: LIST
49785: LIST
49786: LIST
49787: LIST
49788: LIST
49789: LIST
49790: LIST
49791: LIST
49792: LIST
49793: LIST
49794: LIST
49795: LIST
49796: LIST
49797: LIST
49798: LIST
49799: LIST
49800: LIST
49801: LIST
49802: LIST
49803: LIST
49804: LIST
49805: LIST
49806: LIST
49807: LIST
49808: LIST
49809: LIST
49810: LIST
49811: LIST
49812: LIST
49813: LIST
49814: LIST
49815: LIST
49816: LIST
49817: LIST
49818: LIST
49819: LIST
49820: LIST
49821: LIST
49822: ST_TO_ADDR
49823: GO 50016
49825: LD_INT 3
49827: DOUBLE
49828: EQUAL
49829: IFTRUE 49833
49831: GO 50015
49833: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
49834: LD_ADDR_VAR 0 4
49838: PUSH
49839: LD_INT 46
49841: PUSH
49842: LD_INT 47
49844: PUSH
49845: LD_INT 1
49847: PUSH
49848: LD_INT 2
49850: PUSH
49851: LD_INT 11
49853: PUSH
49854: LD_INT 9
49856: PUSH
49857: LD_INT 20
49859: PUSH
49860: LD_INT 19
49862: PUSH
49863: LD_INT 21
49865: PUSH
49866: LD_INT 24
49868: PUSH
49869: LD_INT 22
49871: PUSH
49872: LD_INT 25
49874: PUSH
49875: LD_INT 28
49877: PUSH
49878: LD_INT 29
49880: PUSH
49881: LD_INT 30
49883: PUSH
49884: LD_INT 31
49886: PUSH
49887: LD_INT 37
49889: PUSH
49890: LD_INT 38
49892: PUSH
49893: LD_INT 32
49895: PUSH
49896: LD_INT 27
49898: PUSH
49899: LD_INT 33
49901: PUSH
49902: LD_INT 69
49904: PUSH
49905: LD_INT 39
49907: PUSH
49908: LD_INT 34
49910: PUSH
49911: LD_INT 40
49913: PUSH
49914: LD_INT 71
49916: PUSH
49917: LD_INT 23
49919: PUSH
49920: LD_INT 44
49922: PUSH
49923: LD_INT 48
49925: PUSH
49926: LD_INT 49
49928: PUSH
49929: LD_INT 50
49931: PUSH
49932: LD_INT 51
49934: PUSH
49935: LD_INT 52
49937: PUSH
49938: LD_INT 53
49940: PUSH
49941: LD_INT 54
49943: PUSH
49944: LD_INT 55
49946: PUSH
49947: LD_INT 56
49949: PUSH
49950: LD_INT 57
49952: PUSH
49953: LD_INT 58
49955: PUSH
49956: LD_INT 59
49958: PUSH
49959: LD_INT 63
49961: PUSH
49962: LD_INT 64
49964: PUSH
49965: LD_INT 65
49967: PUSH
49968: EMPTY
49969: LIST
49970: LIST
49971: LIST
49972: LIST
49973: LIST
49974: LIST
49975: LIST
49976: LIST
49977: LIST
49978: LIST
49979: LIST
49980: LIST
49981: LIST
49982: LIST
49983: LIST
49984: LIST
49985: LIST
49986: LIST
49987: LIST
49988: LIST
49989: LIST
49990: LIST
49991: LIST
49992: LIST
49993: LIST
49994: LIST
49995: LIST
49996: LIST
49997: LIST
49998: LIST
49999: LIST
50000: LIST
50001: LIST
50002: LIST
50003: LIST
50004: LIST
50005: LIST
50006: LIST
50007: LIST
50008: LIST
50009: LIST
50010: LIST
50011: LIST
50012: ST_TO_ADDR
50013: GO 50016
50015: POP
// if state > - 1 and state < 3 then
50016: LD_VAR 0 3
50020: PUSH
50021: LD_INT 1
50023: NEG
50024: GREATER
50025: PUSH
50026: LD_VAR 0 3
50030: PUSH
50031: LD_INT 3
50033: LESS
50034: AND
50035: IFFALSE 50092
// for i in result do
50037: LD_ADDR_VAR 0 5
50041: PUSH
50042: LD_VAR 0 4
50046: PUSH
50047: FOR_IN
50048: IFFALSE 50090
// if GetTech ( i , side ) <> state then
50050: LD_VAR 0 5
50054: PPUSH
50055: LD_VAR 0 1
50059: PPUSH
50060: CALL_OW 321
50064: PUSH
50065: LD_VAR 0 3
50069: NONEQUAL
50070: IFFALSE 50088
// result := result diff i ;
50072: LD_ADDR_VAR 0 4
50076: PUSH
50077: LD_VAR 0 4
50081: PUSH
50082: LD_VAR 0 5
50086: DIFF
50087: ST_TO_ADDR
50088: GO 50047
50090: POP
50091: POP
// end ;
50092: LD_VAR 0 4
50096: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50097: LD_INT 0
50099: PPUSH
50100: PPUSH
50101: PPUSH
// result := true ;
50102: LD_ADDR_VAR 0 3
50106: PUSH
50107: LD_INT 1
50109: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
50110: LD_ADDR_VAR 0 5
50114: PUSH
50115: LD_VAR 0 2
50119: PPUSH
50120: CALL_OW 480
50124: ST_TO_ADDR
// if not tmp then
50125: LD_VAR 0 5
50129: NOT
50130: IFFALSE 50134
// exit ;
50132: GO 50183
// for i in tmp do
50134: LD_ADDR_VAR 0 4
50138: PUSH
50139: LD_VAR 0 5
50143: PUSH
50144: FOR_IN
50145: IFFALSE 50181
// if GetTech ( i , side ) <> state_researched then
50147: LD_VAR 0 4
50151: PPUSH
50152: LD_VAR 0 1
50156: PPUSH
50157: CALL_OW 321
50161: PUSH
50162: LD_INT 2
50164: NONEQUAL
50165: IFFALSE 50179
// begin result := false ;
50167: LD_ADDR_VAR 0 3
50171: PUSH
50172: LD_INT 0
50174: ST_TO_ADDR
// exit ;
50175: POP
50176: POP
50177: GO 50183
// end ;
50179: GO 50144
50181: POP
50182: POP
// end ;
50183: LD_VAR 0 3
50187: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50188: LD_INT 0
50190: PPUSH
50191: PPUSH
50192: PPUSH
50193: PPUSH
50194: PPUSH
50195: PPUSH
50196: PPUSH
50197: PPUSH
50198: PPUSH
50199: PPUSH
50200: PPUSH
50201: PPUSH
50202: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50203: LD_VAR 0 1
50207: NOT
50208: PUSH
50209: LD_VAR 0 1
50213: PPUSH
50214: CALL_OW 257
50218: PUSH
50219: LD_INT 9
50221: NONEQUAL
50222: OR
50223: IFFALSE 50227
// exit ;
50225: GO 50800
// side := GetSide ( unit ) ;
50227: LD_ADDR_VAR 0 9
50231: PUSH
50232: LD_VAR 0 1
50236: PPUSH
50237: CALL_OW 255
50241: ST_TO_ADDR
// tech_space := tech_spacanom ;
50242: LD_ADDR_VAR 0 12
50246: PUSH
50247: LD_INT 29
50249: ST_TO_ADDR
// tech_time := tech_taurad ;
50250: LD_ADDR_VAR 0 13
50254: PUSH
50255: LD_INT 28
50257: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50258: LD_ADDR_VAR 0 11
50262: PUSH
50263: LD_VAR 0 1
50267: PPUSH
50268: CALL_OW 310
50272: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50273: LD_VAR 0 11
50277: PPUSH
50278: CALL_OW 247
50282: PUSH
50283: LD_INT 2
50285: EQUAL
50286: IFFALSE 50290
// exit ;
50288: GO 50800
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50290: LD_ADDR_VAR 0 8
50294: PUSH
50295: LD_INT 81
50297: PUSH
50298: LD_VAR 0 9
50302: PUSH
50303: EMPTY
50304: LIST
50305: LIST
50306: PUSH
50307: LD_INT 3
50309: PUSH
50310: LD_INT 21
50312: PUSH
50313: LD_INT 3
50315: PUSH
50316: EMPTY
50317: LIST
50318: LIST
50319: PUSH
50320: EMPTY
50321: LIST
50322: LIST
50323: PUSH
50324: EMPTY
50325: LIST
50326: LIST
50327: PPUSH
50328: CALL_OW 69
50332: ST_TO_ADDR
// if not tmp then
50333: LD_VAR 0 8
50337: NOT
50338: IFFALSE 50342
// exit ;
50340: GO 50800
// if in_unit then
50342: LD_VAR 0 11
50346: IFFALSE 50370
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50348: LD_ADDR_VAR 0 10
50352: PUSH
50353: LD_VAR 0 8
50357: PPUSH
50358: LD_VAR 0 11
50362: PPUSH
50363: CALL_OW 74
50367: ST_TO_ADDR
50368: GO 50390
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50370: LD_ADDR_VAR 0 10
50374: PUSH
50375: LD_VAR 0 8
50379: PPUSH
50380: LD_VAR 0 1
50384: PPUSH
50385: CALL_OW 74
50389: ST_TO_ADDR
// if not enemy then
50390: LD_VAR 0 10
50394: NOT
50395: IFFALSE 50399
// exit ;
50397: GO 50800
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50399: LD_VAR 0 11
50403: PUSH
50404: LD_VAR 0 11
50408: PPUSH
50409: LD_VAR 0 10
50413: PPUSH
50414: CALL_OW 296
50418: PUSH
50419: LD_INT 13
50421: GREATER
50422: AND
50423: PUSH
50424: LD_VAR 0 1
50428: PPUSH
50429: LD_VAR 0 10
50433: PPUSH
50434: CALL_OW 296
50438: PUSH
50439: LD_INT 12
50441: GREATER
50442: OR
50443: IFFALSE 50447
// exit ;
50445: GO 50800
// missile := [ 1 ] ;
50447: LD_ADDR_VAR 0 14
50451: PUSH
50452: LD_INT 1
50454: PUSH
50455: EMPTY
50456: LIST
50457: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50458: LD_VAR 0 9
50462: PPUSH
50463: LD_VAR 0 12
50467: PPUSH
50468: CALL_OW 325
50472: IFFALSE 50501
// missile := Insert ( missile , missile + 1 , 2 ) ;
50474: LD_ADDR_VAR 0 14
50478: PUSH
50479: LD_VAR 0 14
50483: PPUSH
50484: LD_VAR 0 14
50488: PUSH
50489: LD_INT 1
50491: PLUS
50492: PPUSH
50493: LD_INT 2
50495: PPUSH
50496: CALL_OW 2
50500: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50501: LD_VAR 0 9
50505: PPUSH
50506: LD_VAR 0 13
50510: PPUSH
50511: CALL_OW 325
50515: PUSH
50516: LD_VAR 0 10
50520: PPUSH
50521: CALL_OW 255
50525: PPUSH
50526: LD_VAR 0 13
50530: PPUSH
50531: CALL_OW 325
50535: NOT
50536: AND
50537: IFFALSE 50566
// missile := Insert ( missile , missile + 1 , 3 ) ;
50539: LD_ADDR_VAR 0 14
50543: PUSH
50544: LD_VAR 0 14
50548: PPUSH
50549: LD_VAR 0 14
50553: PUSH
50554: LD_INT 1
50556: PLUS
50557: PPUSH
50558: LD_INT 3
50560: PPUSH
50561: CALL_OW 2
50565: ST_TO_ADDR
// if missile < 2 then
50566: LD_VAR 0 14
50570: PUSH
50571: LD_INT 2
50573: LESS
50574: IFFALSE 50578
// exit ;
50576: GO 50800
// x := GetX ( enemy ) ;
50578: LD_ADDR_VAR 0 4
50582: PUSH
50583: LD_VAR 0 10
50587: PPUSH
50588: CALL_OW 250
50592: ST_TO_ADDR
// y := GetY ( enemy ) ;
50593: LD_ADDR_VAR 0 5
50597: PUSH
50598: LD_VAR 0 10
50602: PPUSH
50603: CALL_OW 251
50607: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50608: LD_ADDR_VAR 0 6
50612: PUSH
50613: LD_VAR 0 4
50617: PUSH
50618: LD_INT 1
50620: NEG
50621: PPUSH
50622: LD_INT 1
50624: PPUSH
50625: CALL_OW 12
50629: PLUS
50630: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50631: LD_ADDR_VAR 0 7
50635: PUSH
50636: LD_VAR 0 5
50640: PUSH
50641: LD_INT 1
50643: NEG
50644: PPUSH
50645: LD_INT 1
50647: PPUSH
50648: CALL_OW 12
50652: PLUS
50653: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50654: LD_VAR 0 6
50658: PPUSH
50659: LD_VAR 0 7
50663: PPUSH
50664: CALL_OW 488
50668: NOT
50669: IFFALSE 50691
// begin _x := x ;
50671: LD_ADDR_VAR 0 6
50675: PUSH
50676: LD_VAR 0 4
50680: ST_TO_ADDR
// _y := y ;
50681: LD_ADDR_VAR 0 7
50685: PUSH
50686: LD_VAR 0 5
50690: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50691: LD_ADDR_VAR 0 3
50695: PUSH
50696: LD_INT 1
50698: PPUSH
50699: LD_VAR 0 14
50703: PPUSH
50704: CALL_OW 12
50708: ST_TO_ADDR
// case i of 1 :
50709: LD_VAR 0 3
50713: PUSH
50714: LD_INT 1
50716: DOUBLE
50717: EQUAL
50718: IFTRUE 50722
50720: GO 50739
50722: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50723: LD_VAR 0 1
50727: PPUSH
50728: LD_VAR 0 10
50732: PPUSH
50733: CALL_OW 115
50737: GO 50800
50739: LD_INT 2
50741: DOUBLE
50742: EQUAL
50743: IFTRUE 50747
50745: GO 50769
50747: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50748: LD_VAR 0 1
50752: PPUSH
50753: LD_VAR 0 6
50757: PPUSH
50758: LD_VAR 0 7
50762: PPUSH
50763: CALL_OW 153
50767: GO 50800
50769: LD_INT 3
50771: DOUBLE
50772: EQUAL
50773: IFTRUE 50777
50775: GO 50799
50777: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50778: LD_VAR 0 1
50782: PPUSH
50783: LD_VAR 0 6
50787: PPUSH
50788: LD_VAR 0 7
50792: PPUSH
50793: CALL_OW 154
50797: GO 50800
50799: POP
// end ;
50800: LD_VAR 0 2
50804: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50805: LD_INT 0
50807: PPUSH
50808: PPUSH
50809: PPUSH
50810: PPUSH
50811: PPUSH
50812: PPUSH
// if not unit or not building then
50813: LD_VAR 0 1
50817: NOT
50818: PUSH
50819: LD_VAR 0 2
50823: NOT
50824: OR
50825: IFFALSE 50829
// exit ;
50827: GO 50987
// x := GetX ( building ) ;
50829: LD_ADDR_VAR 0 5
50833: PUSH
50834: LD_VAR 0 2
50838: PPUSH
50839: CALL_OW 250
50843: ST_TO_ADDR
// y := GetY ( building ) ;
50844: LD_ADDR_VAR 0 6
50848: PUSH
50849: LD_VAR 0 2
50853: PPUSH
50854: CALL_OW 251
50858: ST_TO_ADDR
// for i = 0 to 5 do
50859: LD_ADDR_VAR 0 4
50863: PUSH
50864: DOUBLE
50865: LD_INT 0
50867: DEC
50868: ST_TO_ADDR
50869: LD_INT 5
50871: PUSH
50872: FOR_TO
50873: IFFALSE 50985
// begin _x := ShiftX ( x , i , 3 ) ;
50875: LD_ADDR_VAR 0 7
50879: PUSH
50880: LD_VAR 0 5
50884: PPUSH
50885: LD_VAR 0 4
50889: PPUSH
50890: LD_INT 3
50892: PPUSH
50893: CALL_OW 272
50897: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50898: LD_ADDR_VAR 0 8
50902: PUSH
50903: LD_VAR 0 6
50907: PPUSH
50908: LD_VAR 0 4
50912: PPUSH
50913: LD_INT 3
50915: PPUSH
50916: CALL_OW 273
50920: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50921: LD_VAR 0 7
50925: PPUSH
50926: LD_VAR 0 8
50930: PPUSH
50931: CALL_OW 488
50935: NOT
50936: IFFALSE 50940
// continue ;
50938: GO 50872
// if HexInfo ( _x , _y ) = 0 then
50940: LD_VAR 0 7
50944: PPUSH
50945: LD_VAR 0 8
50949: PPUSH
50950: CALL_OW 428
50954: PUSH
50955: LD_INT 0
50957: EQUAL
50958: IFFALSE 50983
// begin ComMoveXY ( unit , _x , _y ) ;
50960: LD_VAR 0 1
50964: PPUSH
50965: LD_VAR 0 7
50969: PPUSH
50970: LD_VAR 0 8
50974: PPUSH
50975: CALL_OW 111
// exit ;
50979: POP
50980: POP
50981: GO 50987
// end ; end ;
50983: GO 50872
50985: POP
50986: POP
// end ;
50987: LD_VAR 0 3
50991: RET
// export function ScanBase ( side , base_area ) ; begin
50992: LD_INT 0
50994: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50995: LD_ADDR_VAR 0 3
50999: PUSH
51000: LD_VAR 0 2
51004: PPUSH
51005: LD_INT 81
51007: PUSH
51008: LD_VAR 0 1
51012: PUSH
51013: EMPTY
51014: LIST
51015: LIST
51016: PPUSH
51017: CALL_OW 70
51021: ST_TO_ADDR
// end ;
51022: LD_VAR 0 3
51026: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
51027: LD_INT 0
51029: PPUSH
51030: PPUSH
51031: PPUSH
51032: PPUSH
51033: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
51034: LD_VAR 0 1
51038: NOT
51039: PUSH
51040: LD_EXP 74
51044: PUSH
51045: LD_VAR 0 1
51049: ARRAY
51050: NOT
51051: OR
51052: PUSH
51053: LD_VAR 0 2
51057: NOT
51058: OR
51059: PUSH
51060: LD_VAR 0 3
51064: NOT
51065: OR
51066: IFFALSE 51070
// exit ;
51068: GO 51520
// side := mc_sides [ base ] ;
51070: LD_ADDR_VAR 0 6
51074: PUSH
51075: LD_EXP 100
51079: PUSH
51080: LD_VAR 0 1
51084: ARRAY
51085: ST_TO_ADDR
// if not side then
51086: LD_VAR 0 6
51090: NOT
51091: IFFALSE 51095
// exit ;
51093: GO 51520
// for i in solds do
51095: LD_ADDR_VAR 0 7
51099: PUSH
51100: LD_VAR 0 2
51104: PUSH
51105: FOR_IN
51106: IFFALSE 51167
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
51108: LD_VAR 0 7
51112: PPUSH
51113: CALL_OW 310
51117: PPUSH
51118: CALL_OW 266
51122: PUSH
51123: LD_INT 32
51125: PUSH
51126: LD_INT 31
51128: PUSH
51129: EMPTY
51130: LIST
51131: LIST
51132: IN
51133: IFFALSE 51153
// solds := solds diff i else
51135: LD_ADDR_VAR 0 2
51139: PUSH
51140: LD_VAR 0 2
51144: PUSH
51145: LD_VAR 0 7
51149: DIFF
51150: ST_TO_ADDR
51151: GO 51165
// SetTag ( i , 18 ) ;
51153: LD_VAR 0 7
51157: PPUSH
51158: LD_INT 18
51160: PPUSH
51161: CALL_OW 109
51165: GO 51105
51167: POP
51168: POP
// if not solds then
51169: LD_VAR 0 2
51173: NOT
51174: IFFALSE 51178
// exit ;
51176: GO 51520
// repeat wait ( 0 0$1 ) ;
51178: LD_INT 35
51180: PPUSH
51181: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
51185: LD_ADDR_VAR 0 5
51189: PUSH
51190: LD_VAR 0 6
51194: PPUSH
51195: LD_VAR 0 3
51199: PPUSH
51200: CALL 50992 0 2
51204: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
51205: LD_VAR 0 5
51209: NOT
51210: PUSH
51211: LD_VAR 0 5
51215: PUSH
51216: LD_INT 3
51218: GREATER
51219: OR
51220: PUSH
51221: LD_EXP 96
51225: PUSH
51226: LD_VAR 0 1
51230: ARRAY
51231: OR
51232: IFFALSE 51273
// begin for i in solds do
51234: LD_ADDR_VAR 0 7
51238: PUSH
51239: LD_VAR 0 2
51243: PUSH
51244: FOR_IN
51245: IFFALSE 51269
// if HasTask ( i ) then
51247: LD_VAR 0 7
51251: PPUSH
51252: CALL_OW 314
51256: IFFALSE 51267
// ComStop ( i ) ;
51258: LD_VAR 0 7
51262: PPUSH
51263: CALL_OW 141
51267: GO 51244
51269: POP
51270: POP
// break ;
51271: GO 51508
// end ; for i in solds do
51273: LD_ADDR_VAR 0 7
51277: PUSH
51278: LD_VAR 0 2
51282: PUSH
51283: FOR_IN
51284: IFFALSE 51500
// begin if IsInUnit ( i ) then
51286: LD_VAR 0 7
51290: PPUSH
51291: CALL_OW 310
51295: IFFALSE 51306
// ComExitBuilding ( i ) ;
51297: LD_VAR 0 7
51301: PPUSH
51302: CALL_OW 122
// if GetLives ( i ) > 333 then
51306: LD_VAR 0 7
51310: PPUSH
51311: CALL_OW 256
51315: PUSH
51316: LD_INT 333
51318: GREATER
51319: IFFALSE 51347
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51321: LD_VAR 0 7
51325: PPUSH
51326: LD_VAR 0 5
51330: PPUSH
51331: LD_VAR 0 7
51335: PPUSH
51336: CALL_OW 74
51340: PPUSH
51341: CALL_OW 115
51345: GO 51498
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
51347: LD_ADDR_VAR 0 8
51351: PUSH
51352: LD_EXP 74
51356: PUSH
51357: LD_VAR 0 1
51361: ARRAY
51362: PPUSH
51363: LD_INT 2
51365: PUSH
51366: LD_INT 30
51368: PUSH
51369: LD_INT 0
51371: PUSH
51372: EMPTY
51373: LIST
51374: LIST
51375: PUSH
51376: LD_INT 30
51378: PUSH
51379: LD_INT 1
51381: PUSH
51382: EMPTY
51383: LIST
51384: LIST
51385: PUSH
51386: LD_INT 30
51388: PUSH
51389: LD_INT 6
51391: PUSH
51392: EMPTY
51393: LIST
51394: LIST
51395: PUSH
51396: EMPTY
51397: LIST
51398: LIST
51399: LIST
51400: LIST
51401: PPUSH
51402: CALL_OW 72
51406: PPUSH
51407: LD_VAR 0 7
51411: PPUSH
51412: CALL_OW 74
51416: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
51417: LD_VAR 0 7
51421: PPUSH
51422: LD_VAR 0 8
51426: PPUSH
51427: CALL_OW 250
51431: PPUSH
51432: LD_INT 3
51434: PPUSH
51435: LD_INT 5
51437: PPUSH
51438: CALL_OW 272
51442: PPUSH
51443: LD_VAR 0 8
51447: PPUSH
51448: CALL_OW 251
51452: PPUSH
51453: LD_INT 3
51455: PPUSH
51456: LD_INT 5
51458: PPUSH
51459: CALL_OW 273
51463: PPUSH
51464: CALL_OW 111
// SetTag ( i , 0 ) ;
51468: LD_VAR 0 7
51472: PPUSH
51473: LD_INT 0
51475: PPUSH
51476: CALL_OW 109
// solds := solds diff i ;
51480: LD_ADDR_VAR 0 2
51484: PUSH
51485: LD_VAR 0 2
51489: PUSH
51490: LD_VAR 0 7
51494: DIFF
51495: ST_TO_ADDR
// continue ;
51496: GO 51283
// end ; end ;
51498: GO 51283
51500: POP
51501: POP
// until solds ;
51502: LD_VAR 0 2
51506: IFFALSE 51178
// MC_Reset ( base , 18 ) ;
51508: LD_VAR 0 1
51512: PPUSH
51513: LD_INT 18
51515: PPUSH
51516: CALL 23650 0 2
// end ;
51520: LD_VAR 0 4
51524: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
51525: LD_INT 0
51527: PPUSH
51528: PPUSH
51529: PPUSH
51530: PPUSH
51531: PPUSH
51532: PPUSH
51533: PPUSH
51534: PPUSH
51535: PPUSH
51536: PPUSH
51537: PPUSH
51538: PPUSH
51539: PPUSH
51540: PPUSH
51541: PPUSH
51542: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
51543: LD_ADDR_VAR 0 12
51547: PUSH
51548: LD_EXP 74
51552: PUSH
51553: LD_VAR 0 1
51557: ARRAY
51558: PPUSH
51559: LD_INT 25
51561: PUSH
51562: LD_INT 3
51564: PUSH
51565: EMPTY
51566: LIST
51567: LIST
51568: PPUSH
51569: CALL_OW 72
51573: ST_TO_ADDR
// if mc_remote_driver [ base ] then
51574: LD_EXP 114
51578: PUSH
51579: LD_VAR 0 1
51583: ARRAY
51584: IFFALSE 51608
// mechs := mechs diff mc_remote_driver [ base ] ;
51586: LD_ADDR_VAR 0 12
51590: PUSH
51591: LD_VAR 0 12
51595: PUSH
51596: LD_EXP 114
51600: PUSH
51601: LD_VAR 0 1
51605: ARRAY
51606: DIFF
51607: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51608: LD_ADDR_VAR 0 8
51612: PUSH
51613: LD_EXP 74
51617: PUSH
51618: LD_VAR 0 1
51622: ARRAY
51623: PPUSH
51624: LD_INT 2
51626: PUSH
51627: LD_INT 25
51629: PUSH
51630: LD_INT 1
51632: PUSH
51633: EMPTY
51634: LIST
51635: LIST
51636: PUSH
51637: LD_INT 25
51639: PUSH
51640: LD_INT 5
51642: PUSH
51643: EMPTY
51644: LIST
51645: LIST
51646: PUSH
51647: LD_INT 25
51649: PUSH
51650: LD_INT 8
51652: PUSH
51653: EMPTY
51654: LIST
51655: LIST
51656: PUSH
51657: LD_INT 25
51659: PUSH
51660: LD_INT 9
51662: PUSH
51663: EMPTY
51664: LIST
51665: LIST
51666: PUSH
51667: EMPTY
51668: LIST
51669: LIST
51670: LIST
51671: LIST
51672: LIST
51673: PPUSH
51674: CALL_OW 72
51678: ST_TO_ADDR
// if not defenders and not solds then
51679: LD_VAR 0 2
51683: NOT
51684: PUSH
51685: LD_VAR 0 8
51689: NOT
51690: AND
51691: IFFALSE 51695
// exit ;
51693: GO 53069
// depot_under_attack := false ;
51695: LD_ADDR_VAR 0 16
51699: PUSH
51700: LD_INT 0
51702: ST_TO_ADDR
// sold_defenders := [ ] ;
51703: LD_ADDR_VAR 0 17
51707: PUSH
51708: EMPTY
51709: ST_TO_ADDR
// if mechs then
51710: LD_VAR 0 12
51714: IFFALSE 51843
// for i in defenders do
51716: LD_ADDR_VAR 0 5
51720: PUSH
51721: LD_VAR 0 2
51725: PUSH
51726: FOR_IN
51727: IFFALSE 51841
// begin SetTag ( i , 20 ) ;
51729: LD_VAR 0 5
51733: PPUSH
51734: LD_INT 20
51736: PPUSH
51737: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
51741: LD_VAR 0 5
51745: PPUSH
51746: CALL_OW 263
51750: PUSH
51751: LD_INT 1
51753: EQUAL
51754: PUSH
51755: LD_VAR 0 5
51759: PPUSH
51760: CALL_OW 311
51764: NOT
51765: AND
51766: PUSH
51767: LD_VAR 0 12
51771: AND
51772: IFFALSE 51839
// begin un := mechs [ 1 ] ;
51774: LD_ADDR_VAR 0 10
51778: PUSH
51779: LD_VAR 0 12
51783: PUSH
51784: LD_INT 1
51786: ARRAY
51787: ST_TO_ADDR
// ComExitBuilding ( un ) ;
51788: LD_VAR 0 10
51792: PPUSH
51793: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
51797: LD_VAR 0 10
51801: PPUSH
51802: LD_VAR 0 5
51806: PPUSH
51807: CALL_OW 180
// SetTag ( un , 19 ) ;
51811: LD_VAR 0 10
51815: PPUSH
51816: LD_INT 19
51818: PPUSH
51819: CALL_OW 109
// mechs := mechs diff un ;
51823: LD_ADDR_VAR 0 12
51827: PUSH
51828: LD_VAR 0 12
51832: PUSH
51833: LD_VAR 0 10
51837: DIFF
51838: ST_TO_ADDR
// end ; end ;
51839: GO 51726
51841: POP
51842: POP
// if solds then
51843: LD_VAR 0 8
51847: IFFALSE 51906
// for i in solds do
51849: LD_ADDR_VAR 0 5
51853: PUSH
51854: LD_VAR 0 8
51858: PUSH
51859: FOR_IN
51860: IFFALSE 51904
// if not GetTag ( i ) then
51862: LD_VAR 0 5
51866: PPUSH
51867: CALL_OW 110
51871: NOT
51872: IFFALSE 51902
// begin defenders := defenders union i ;
51874: LD_ADDR_VAR 0 2
51878: PUSH
51879: LD_VAR 0 2
51883: PUSH
51884: LD_VAR 0 5
51888: UNION
51889: ST_TO_ADDR
// SetTag ( i , 18 ) ;
51890: LD_VAR 0 5
51894: PPUSH
51895: LD_INT 18
51897: PPUSH
51898: CALL_OW 109
// end ;
51902: GO 51859
51904: POP
51905: POP
// repeat wait ( 0 0$1 ) ;
51906: LD_INT 35
51908: PPUSH
51909: CALL_OW 67
// enemy := mc_scan [ base ] ;
51913: LD_ADDR_VAR 0 3
51917: PUSH
51918: LD_EXP 97
51922: PUSH
51923: LD_VAR 0 1
51927: ARRAY
51928: ST_TO_ADDR
// for i in defenders do
51929: LD_ADDR_VAR 0 5
51933: PUSH
51934: LD_VAR 0 2
51938: PUSH
51939: FOR_IN
51940: IFFALSE 52670
// begin e := NearestUnitToUnit ( enemy , i ) ;
51942: LD_ADDR_VAR 0 13
51946: PUSH
51947: LD_VAR 0 3
51951: PPUSH
51952: LD_VAR 0 5
51956: PPUSH
51957: CALL_OW 74
51961: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
51962: LD_ADDR_VAR 0 16
51966: PUSH
51967: LD_EXP 74
51971: PUSH
51972: LD_VAR 0 1
51976: ARRAY
51977: PPUSH
51978: LD_INT 2
51980: PUSH
51981: LD_INT 30
51983: PUSH
51984: LD_INT 0
51986: PUSH
51987: EMPTY
51988: LIST
51989: LIST
51990: PUSH
51991: LD_INT 30
51993: PUSH
51994: LD_INT 1
51996: PUSH
51997: EMPTY
51998: LIST
51999: LIST
52000: PUSH
52001: EMPTY
52002: LIST
52003: LIST
52004: LIST
52005: PPUSH
52006: CALL_OW 72
52010: NOT
52011: PUSH
52012: LD_EXP 74
52016: PUSH
52017: LD_VAR 0 1
52021: ARRAY
52022: PPUSH
52023: LD_INT 2
52025: PUSH
52026: LD_INT 30
52028: PUSH
52029: LD_INT 0
52031: PUSH
52032: EMPTY
52033: LIST
52034: LIST
52035: PUSH
52036: LD_INT 30
52038: PUSH
52039: LD_INT 1
52041: PUSH
52042: EMPTY
52043: LIST
52044: LIST
52045: PUSH
52046: EMPTY
52047: LIST
52048: LIST
52049: LIST
52050: PPUSH
52051: CALL_OW 72
52055: PPUSH
52056: CALL_OW 256
52060: PUSH
52061: LD_INT 600
52063: LESS
52064: OR
52065: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
52066: LD_VAR 0 5
52070: PPUSH
52071: CALL_OW 247
52075: PUSH
52076: LD_INT 2
52078: DOUBLE
52079: EQUAL
52080: IFTRUE 52084
52082: GO 52376
52084: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
52085: LD_VAR 0 5
52089: PPUSH
52090: CALL_OW 256
52094: PUSH
52095: LD_INT 650
52097: GREATER
52098: PUSH
52099: LD_VAR 0 5
52103: PPUSH
52104: LD_VAR 0 13
52108: PPUSH
52109: CALL_OW 296
52113: PUSH
52114: LD_INT 40
52116: LESS
52117: PUSH
52118: LD_VAR 0 13
52122: PPUSH
52123: LD_EXP 99
52127: PUSH
52128: LD_VAR 0 1
52132: ARRAY
52133: PPUSH
52134: CALL_OW 308
52138: OR
52139: AND
52140: IFFALSE 52158
// ComAttackUnit ( i , e ) else
52142: LD_VAR 0 5
52146: PPUSH
52147: LD_VAR 0 13
52151: PPUSH
52152: CALL_OW 115
52156: GO 52259
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
52158: LD_VAR 0 13
52162: PPUSH
52163: LD_EXP 99
52167: PUSH
52168: LD_VAR 0 1
52172: ARRAY
52173: PPUSH
52174: CALL_OW 308
52178: NOT
52179: PUSH
52180: LD_VAR 0 5
52184: PPUSH
52185: LD_VAR 0 13
52189: PPUSH
52190: CALL_OW 296
52194: PUSH
52195: LD_INT 40
52197: GREATEREQUAL
52198: AND
52199: PUSH
52200: LD_VAR 0 5
52204: PPUSH
52205: CALL_OW 256
52209: PUSH
52210: LD_INT 650
52212: LESSEQUAL
52213: OR
52214: PUSH
52215: LD_VAR 0 5
52219: PPUSH
52220: LD_EXP 98
52224: PUSH
52225: LD_VAR 0 1
52229: ARRAY
52230: PPUSH
52231: CALL_OW 308
52235: NOT
52236: AND
52237: IFFALSE 52259
// ComMoveToArea ( i , mc_parking [ base ] ) ;
52239: LD_VAR 0 5
52243: PPUSH
52244: LD_EXP 98
52248: PUSH
52249: LD_VAR 0 1
52253: ARRAY
52254: PPUSH
52255: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
52259: LD_VAR 0 5
52263: PPUSH
52264: CALL_OW 256
52268: PUSH
52269: LD_INT 998
52271: LESS
52272: PUSH
52273: LD_VAR 0 5
52277: PPUSH
52278: CALL_OW 263
52282: PUSH
52283: LD_INT 1
52285: EQUAL
52286: AND
52287: PUSH
52288: LD_VAR 0 5
52292: PPUSH
52293: CALL_OW 311
52297: AND
52298: PUSH
52299: LD_VAR 0 5
52303: PPUSH
52304: LD_EXP 98
52308: PUSH
52309: LD_VAR 0 1
52313: ARRAY
52314: PPUSH
52315: CALL_OW 308
52319: AND
52320: IFFALSE 52374
// begin mech := IsDrivenBy ( i ) ;
52322: LD_ADDR_VAR 0 9
52326: PUSH
52327: LD_VAR 0 5
52331: PPUSH
52332: CALL_OW 311
52336: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
52337: LD_VAR 0 9
52341: PPUSH
52342: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
52346: LD_VAR 0 9
52350: PPUSH
52351: LD_VAR 0 5
52355: PPUSH
52356: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
52360: LD_VAR 0 9
52364: PPUSH
52365: LD_VAR 0 5
52369: PPUSH
52370: CALL_OW 180
// end ; end ; unit_human :
52374: GO 52641
52376: LD_INT 1
52378: DOUBLE
52379: EQUAL
52380: IFTRUE 52384
52382: GO 52640
52384: POP
// begin b := IsInUnit ( i ) ;
52385: LD_ADDR_VAR 0 18
52389: PUSH
52390: LD_VAR 0 5
52394: PPUSH
52395: CALL_OW 310
52399: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
52400: LD_ADDR_VAR 0 19
52404: PUSH
52405: LD_VAR 0 18
52409: NOT
52410: PUSH
52411: LD_VAR 0 18
52415: PPUSH
52416: CALL_OW 266
52420: PUSH
52421: LD_INT 32
52423: PUSH
52424: LD_INT 31
52426: PUSH
52427: EMPTY
52428: LIST
52429: LIST
52430: IN
52431: OR
52432: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
52433: LD_VAR 0 16
52437: PUSH
52438: LD_VAR 0 2
52442: PPUSH
52443: LD_INT 21
52445: PUSH
52446: LD_INT 2
52448: PUSH
52449: EMPTY
52450: LIST
52451: LIST
52452: PPUSH
52453: CALL_OW 72
52457: PUSH
52458: LD_INT 1
52460: LESSEQUAL
52461: OR
52462: PUSH
52463: LD_VAR 0 19
52467: AND
52468: PUSH
52469: LD_VAR 0 5
52473: PUSH
52474: LD_VAR 0 17
52478: IN
52479: NOT
52480: AND
52481: IFFALSE 52574
// begin if b then
52483: LD_VAR 0 18
52487: IFFALSE 52536
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
52489: LD_VAR 0 18
52493: PPUSH
52494: LD_VAR 0 3
52498: PPUSH
52499: LD_VAR 0 18
52503: PPUSH
52504: CALL_OW 74
52508: PPUSH
52509: CALL_OW 296
52513: PUSH
52514: LD_INT 10
52516: LESS
52517: PUSH
52518: LD_VAR 0 18
52522: PPUSH
52523: CALL_OW 461
52527: PUSH
52528: LD_INT 7
52530: NONEQUAL
52531: AND
52532: IFFALSE 52536
// continue ;
52534: GO 51939
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
52536: LD_ADDR_VAR 0 17
52540: PUSH
52541: LD_VAR 0 17
52545: PPUSH
52546: LD_VAR 0 17
52550: PUSH
52551: LD_INT 1
52553: PLUS
52554: PPUSH
52555: LD_VAR 0 5
52559: PPUSH
52560: CALL_OW 1
52564: ST_TO_ADDR
// ComExitBuilding ( i ) ;
52565: LD_VAR 0 5
52569: PPUSH
52570: CALL_OW 122
// end ; if sold_defenders then
52574: LD_VAR 0 17
52578: IFFALSE 52638
// if i in sold_defenders then
52580: LD_VAR 0 5
52584: PUSH
52585: LD_VAR 0 17
52589: IN
52590: IFFALSE 52638
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
52592: LD_VAR 0 5
52596: PPUSH
52597: CALL_OW 314
52601: NOT
52602: PUSH
52603: LD_VAR 0 5
52607: PPUSH
52608: LD_VAR 0 13
52612: PPUSH
52613: CALL_OW 296
52617: PUSH
52618: LD_INT 30
52620: LESS
52621: AND
52622: IFFALSE 52638
// ComAttackUnit ( i , e ) ;
52624: LD_VAR 0 5
52628: PPUSH
52629: LD_VAR 0 13
52633: PPUSH
52634: CALL_OW 115
// end ; end ; end ;
52638: GO 52641
52640: POP
// if IsDead ( i ) then
52641: LD_VAR 0 5
52645: PPUSH
52646: CALL_OW 301
52650: IFFALSE 52668
// defenders := defenders diff i ;
52652: LD_ADDR_VAR 0 2
52656: PUSH
52657: LD_VAR 0 2
52661: PUSH
52662: LD_VAR 0 5
52666: DIFF
52667: ST_TO_ADDR
// end ;
52668: GO 51939
52670: POP
52671: POP
// until not enemy or not defenders ;
52672: LD_VAR 0 3
52676: NOT
52677: PUSH
52678: LD_VAR 0 2
52682: NOT
52683: OR
52684: IFFALSE 51906
// MC_Reset ( base , 18 ) ;
52686: LD_VAR 0 1
52690: PPUSH
52691: LD_INT 18
52693: PPUSH
52694: CALL 23650 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52698: LD_ADDR_VAR 0 2
52702: PUSH
52703: LD_VAR 0 2
52707: PUSH
52708: LD_VAR 0 2
52712: PPUSH
52713: LD_INT 2
52715: PUSH
52716: LD_INT 25
52718: PUSH
52719: LD_INT 1
52721: PUSH
52722: EMPTY
52723: LIST
52724: LIST
52725: PUSH
52726: LD_INT 25
52728: PUSH
52729: LD_INT 5
52731: PUSH
52732: EMPTY
52733: LIST
52734: LIST
52735: PUSH
52736: LD_INT 25
52738: PUSH
52739: LD_INT 8
52741: PUSH
52742: EMPTY
52743: LIST
52744: LIST
52745: PUSH
52746: LD_INT 25
52748: PUSH
52749: LD_INT 9
52751: PUSH
52752: EMPTY
52753: LIST
52754: LIST
52755: PUSH
52756: EMPTY
52757: LIST
52758: LIST
52759: LIST
52760: LIST
52761: LIST
52762: PPUSH
52763: CALL_OW 72
52767: DIFF
52768: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
52769: LD_VAR 0 3
52773: NOT
52774: PUSH
52775: LD_VAR 0 2
52779: PPUSH
52780: LD_INT 21
52782: PUSH
52783: LD_INT 2
52785: PUSH
52786: EMPTY
52787: LIST
52788: LIST
52789: PPUSH
52790: CALL_OW 72
52794: AND
52795: IFFALSE 53057
// begin tmp := FilterByTag ( defenders , 19 ) ;
52797: LD_ADDR_VAR 0 11
52801: PUSH
52802: LD_VAR 0 2
52806: PPUSH
52807: LD_INT 19
52809: PPUSH
52810: CALL 89498 0 2
52814: ST_TO_ADDR
// if tmp then
52815: LD_VAR 0 11
52819: IFFALSE 52889
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
52821: LD_ADDR_VAR 0 11
52825: PUSH
52826: LD_VAR 0 11
52830: PPUSH
52831: LD_INT 25
52833: PUSH
52834: LD_INT 3
52836: PUSH
52837: EMPTY
52838: LIST
52839: LIST
52840: PPUSH
52841: CALL_OW 72
52845: ST_TO_ADDR
// if tmp then
52846: LD_VAR 0 11
52850: IFFALSE 52889
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
52852: LD_ADDR_EXP 86
52856: PUSH
52857: LD_EXP 86
52861: PPUSH
52862: LD_VAR 0 1
52866: PPUSH
52867: LD_EXP 86
52871: PUSH
52872: LD_VAR 0 1
52876: ARRAY
52877: PUSH
52878: LD_VAR 0 11
52882: UNION
52883: PPUSH
52884: CALL_OW 1
52888: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
52889: LD_VAR 0 1
52893: PPUSH
52894: LD_INT 19
52896: PPUSH
52897: CALL 23650 0 2
// repeat wait ( 0 0$1 ) ;
52901: LD_INT 35
52903: PPUSH
52904: CALL_OW 67
// for i in defenders do
52908: LD_ADDR_VAR 0 5
52912: PUSH
52913: LD_VAR 0 2
52917: PUSH
52918: FOR_IN
52919: IFFALSE 53008
// begin if not IsInArea ( i , mc_parking [ base ] ) then
52921: LD_VAR 0 5
52925: PPUSH
52926: LD_EXP 98
52930: PUSH
52931: LD_VAR 0 1
52935: ARRAY
52936: PPUSH
52937: CALL_OW 308
52941: NOT
52942: IFFALSE 52966
// ComMoveToArea ( i , mc_parking [ base ] ) else
52944: LD_VAR 0 5
52948: PPUSH
52949: LD_EXP 98
52953: PUSH
52954: LD_VAR 0 1
52958: ARRAY
52959: PPUSH
52960: CALL_OW 113
52964: GO 53006
// if GetControl ( i ) = control_manual then
52966: LD_VAR 0 5
52970: PPUSH
52971: CALL_OW 263
52975: PUSH
52976: LD_INT 1
52978: EQUAL
52979: IFFALSE 53006
// if IsDrivenBy ( i ) then
52981: LD_VAR 0 5
52985: PPUSH
52986: CALL_OW 311
52990: IFFALSE 53006
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
52992: LD_VAR 0 5
52996: PPUSH
52997: CALL_OW 311
53001: PPUSH
53002: CALL_OW 121
// end ;
53006: GO 52918
53008: POP
53009: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
53010: LD_VAR 0 2
53014: PPUSH
53015: LD_INT 95
53017: PUSH
53018: LD_EXP 98
53022: PUSH
53023: LD_VAR 0 1
53027: ARRAY
53028: PUSH
53029: EMPTY
53030: LIST
53031: LIST
53032: PPUSH
53033: CALL_OW 72
53037: PUSH
53038: LD_VAR 0 2
53042: EQUAL
53043: PUSH
53044: LD_EXP 97
53048: PUSH
53049: LD_VAR 0 1
53053: ARRAY
53054: OR
53055: IFFALSE 52901
// end ; MC_Reset ( base , 20 ) ;
53057: LD_VAR 0 1
53061: PPUSH
53062: LD_INT 20
53064: PPUSH
53065: CALL 23650 0 2
// end ;
53069: LD_VAR 0 4
53073: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53074: LD_INT 0
53076: PPUSH
53077: PPUSH
53078: PPUSH
53079: PPUSH
// result := false ;
53080: LD_ADDR_VAR 0 2
53084: PUSH
53085: LD_INT 0
53087: ST_TO_ADDR
// side := GetSide ( unit ) ;
53088: LD_ADDR_VAR 0 3
53092: PUSH
53093: LD_VAR 0 1
53097: PPUSH
53098: CALL_OW 255
53102: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53103: LD_ADDR_VAR 0 4
53107: PUSH
53108: LD_VAR 0 1
53112: PPUSH
53113: CALL_OW 248
53117: ST_TO_ADDR
// case nat of 1 :
53118: LD_VAR 0 4
53122: PUSH
53123: LD_INT 1
53125: DOUBLE
53126: EQUAL
53127: IFTRUE 53131
53129: GO 53142
53131: POP
// tech := tech_lassight ; 2 :
53132: LD_ADDR_VAR 0 5
53136: PUSH
53137: LD_INT 12
53139: ST_TO_ADDR
53140: GO 53181
53142: LD_INT 2
53144: DOUBLE
53145: EQUAL
53146: IFTRUE 53150
53148: GO 53161
53150: POP
// tech := tech_mortar ; 3 :
53151: LD_ADDR_VAR 0 5
53155: PUSH
53156: LD_INT 41
53158: ST_TO_ADDR
53159: GO 53181
53161: LD_INT 3
53163: DOUBLE
53164: EQUAL
53165: IFTRUE 53169
53167: GO 53180
53169: POP
// tech := tech_bazooka ; end ;
53170: LD_ADDR_VAR 0 5
53174: PUSH
53175: LD_INT 44
53177: ST_TO_ADDR
53178: GO 53181
53180: POP
// if Researched ( side , tech ) then
53181: LD_VAR 0 3
53185: PPUSH
53186: LD_VAR 0 5
53190: PPUSH
53191: CALL_OW 325
53195: IFFALSE 53222
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53197: LD_ADDR_VAR 0 2
53201: PUSH
53202: LD_INT 5
53204: PUSH
53205: LD_INT 8
53207: PUSH
53208: LD_INT 9
53210: PUSH
53211: EMPTY
53212: LIST
53213: LIST
53214: LIST
53215: PUSH
53216: LD_VAR 0 4
53220: ARRAY
53221: ST_TO_ADDR
// end ;
53222: LD_VAR 0 2
53226: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53227: LD_INT 0
53229: PPUSH
53230: PPUSH
53231: PPUSH
// if not mines then
53232: LD_VAR 0 2
53236: NOT
53237: IFFALSE 53241
// exit ;
53239: GO 53385
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53241: LD_ADDR_VAR 0 5
53245: PUSH
53246: LD_INT 81
53248: PUSH
53249: LD_VAR 0 1
53253: PUSH
53254: EMPTY
53255: LIST
53256: LIST
53257: PUSH
53258: LD_INT 3
53260: PUSH
53261: LD_INT 21
53263: PUSH
53264: LD_INT 3
53266: PUSH
53267: EMPTY
53268: LIST
53269: LIST
53270: PUSH
53271: EMPTY
53272: LIST
53273: LIST
53274: PUSH
53275: EMPTY
53276: LIST
53277: LIST
53278: PPUSH
53279: CALL_OW 69
53283: ST_TO_ADDR
// for i in mines do
53284: LD_ADDR_VAR 0 4
53288: PUSH
53289: LD_VAR 0 2
53293: PUSH
53294: FOR_IN
53295: IFFALSE 53383
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53297: LD_VAR 0 4
53301: PUSH
53302: LD_INT 1
53304: ARRAY
53305: PPUSH
53306: LD_VAR 0 4
53310: PUSH
53311: LD_INT 2
53313: ARRAY
53314: PPUSH
53315: CALL_OW 458
53319: NOT
53320: IFFALSE 53324
// continue ;
53322: GO 53294
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53324: LD_VAR 0 4
53328: PUSH
53329: LD_INT 1
53331: ARRAY
53332: PPUSH
53333: LD_VAR 0 4
53337: PUSH
53338: LD_INT 2
53340: ARRAY
53341: PPUSH
53342: CALL_OW 428
53346: PUSH
53347: LD_VAR 0 5
53351: IN
53352: IFFALSE 53381
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53354: LD_VAR 0 4
53358: PUSH
53359: LD_INT 1
53361: ARRAY
53362: PPUSH
53363: LD_VAR 0 4
53367: PUSH
53368: LD_INT 2
53370: ARRAY
53371: PPUSH
53372: LD_VAR 0 1
53376: PPUSH
53377: CALL_OW 456
// end ;
53381: GO 53294
53383: POP
53384: POP
// end ;
53385: LD_VAR 0 3
53389: RET
// export function Count ( array ) ; var i ; begin
53390: LD_INT 0
53392: PPUSH
53393: PPUSH
// result := 0 ;
53394: LD_ADDR_VAR 0 2
53398: PUSH
53399: LD_INT 0
53401: ST_TO_ADDR
// for i in array do
53402: LD_ADDR_VAR 0 3
53406: PUSH
53407: LD_VAR 0 1
53411: PUSH
53412: FOR_IN
53413: IFFALSE 53437
// if i then
53415: LD_VAR 0 3
53419: IFFALSE 53435
// result := result + 1 ;
53421: LD_ADDR_VAR 0 2
53425: PUSH
53426: LD_VAR 0 2
53430: PUSH
53431: LD_INT 1
53433: PLUS
53434: ST_TO_ADDR
53435: GO 53412
53437: POP
53438: POP
// end ;
53439: LD_VAR 0 2
53443: RET
// export function IsEmpty ( building ) ; begin
53444: LD_INT 0
53446: PPUSH
// if not building then
53447: LD_VAR 0 1
53451: NOT
53452: IFFALSE 53456
// exit ;
53454: GO 53499
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53456: LD_ADDR_VAR 0 2
53460: PUSH
53461: LD_VAR 0 1
53465: PUSH
53466: LD_INT 22
53468: PUSH
53469: LD_VAR 0 1
53473: PPUSH
53474: CALL_OW 255
53478: PUSH
53479: EMPTY
53480: LIST
53481: LIST
53482: PUSH
53483: LD_INT 58
53485: PUSH
53486: EMPTY
53487: LIST
53488: PUSH
53489: EMPTY
53490: LIST
53491: LIST
53492: PPUSH
53493: CALL_OW 69
53497: IN
53498: ST_TO_ADDR
// end ;
53499: LD_VAR 0 2
53503: RET
// export function IsNotFull ( building ) ; begin
53504: LD_INT 0
53506: PPUSH
// if not building then
53507: LD_VAR 0 1
53511: NOT
53512: IFFALSE 53516
// exit ;
53514: GO 53535
// result := UnitsInside ( building ) < 6 ;
53516: LD_ADDR_VAR 0 2
53520: PUSH
53521: LD_VAR 0 1
53525: PPUSH
53526: CALL_OW 313
53530: PUSH
53531: LD_INT 6
53533: LESS
53534: ST_TO_ADDR
// end ;
53535: LD_VAR 0 2
53539: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53540: LD_INT 0
53542: PPUSH
53543: PPUSH
53544: PPUSH
53545: PPUSH
// tmp := [ ] ;
53546: LD_ADDR_VAR 0 3
53550: PUSH
53551: EMPTY
53552: ST_TO_ADDR
// list := [ ] ;
53553: LD_ADDR_VAR 0 5
53557: PUSH
53558: EMPTY
53559: ST_TO_ADDR
// for i = 16 to 25 do
53560: LD_ADDR_VAR 0 4
53564: PUSH
53565: DOUBLE
53566: LD_INT 16
53568: DEC
53569: ST_TO_ADDR
53570: LD_INT 25
53572: PUSH
53573: FOR_TO
53574: IFFALSE 53647
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53576: LD_ADDR_VAR 0 3
53580: PUSH
53581: LD_VAR 0 3
53585: PUSH
53586: LD_INT 22
53588: PUSH
53589: LD_VAR 0 1
53593: PPUSH
53594: CALL_OW 255
53598: PUSH
53599: EMPTY
53600: LIST
53601: LIST
53602: PUSH
53603: LD_INT 91
53605: PUSH
53606: LD_VAR 0 1
53610: PUSH
53611: LD_INT 6
53613: PUSH
53614: EMPTY
53615: LIST
53616: LIST
53617: LIST
53618: PUSH
53619: LD_INT 30
53621: PUSH
53622: LD_VAR 0 4
53626: PUSH
53627: EMPTY
53628: LIST
53629: LIST
53630: PUSH
53631: EMPTY
53632: LIST
53633: LIST
53634: LIST
53635: PUSH
53636: EMPTY
53637: LIST
53638: PPUSH
53639: CALL_OW 69
53643: ADD
53644: ST_TO_ADDR
53645: GO 53573
53647: POP
53648: POP
// for i = 1 to tmp do
53649: LD_ADDR_VAR 0 4
53653: PUSH
53654: DOUBLE
53655: LD_INT 1
53657: DEC
53658: ST_TO_ADDR
53659: LD_VAR 0 3
53663: PUSH
53664: FOR_TO
53665: IFFALSE 53753
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53667: LD_ADDR_VAR 0 5
53671: PUSH
53672: LD_VAR 0 5
53676: PUSH
53677: LD_VAR 0 3
53681: PUSH
53682: LD_VAR 0 4
53686: ARRAY
53687: PPUSH
53688: CALL_OW 266
53692: PUSH
53693: LD_VAR 0 3
53697: PUSH
53698: LD_VAR 0 4
53702: ARRAY
53703: PPUSH
53704: CALL_OW 250
53708: PUSH
53709: LD_VAR 0 3
53713: PUSH
53714: LD_VAR 0 4
53718: ARRAY
53719: PPUSH
53720: CALL_OW 251
53724: PUSH
53725: LD_VAR 0 3
53729: PUSH
53730: LD_VAR 0 4
53734: ARRAY
53735: PPUSH
53736: CALL_OW 254
53740: PUSH
53741: EMPTY
53742: LIST
53743: LIST
53744: LIST
53745: LIST
53746: PUSH
53747: EMPTY
53748: LIST
53749: ADD
53750: ST_TO_ADDR
53751: GO 53664
53753: POP
53754: POP
// result := list ;
53755: LD_ADDR_VAR 0 2
53759: PUSH
53760: LD_VAR 0 5
53764: ST_TO_ADDR
// end ;
53765: LD_VAR 0 2
53769: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53770: LD_INT 0
53772: PPUSH
53773: PPUSH
53774: PPUSH
53775: PPUSH
53776: PPUSH
53777: PPUSH
53778: PPUSH
// if not factory then
53779: LD_VAR 0 1
53783: NOT
53784: IFFALSE 53788
// exit ;
53786: GO 54381
// if control = control_apeman then
53788: LD_VAR 0 4
53792: PUSH
53793: LD_INT 5
53795: EQUAL
53796: IFFALSE 53905
// begin tmp := UnitsInside ( factory ) ;
53798: LD_ADDR_VAR 0 8
53802: PUSH
53803: LD_VAR 0 1
53807: PPUSH
53808: CALL_OW 313
53812: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53813: LD_VAR 0 8
53817: PPUSH
53818: LD_INT 25
53820: PUSH
53821: LD_INT 12
53823: PUSH
53824: EMPTY
53825: LIST
53826: LIST
53827: PPUSH
53828: CALL_OW 72
53832: NOT
53833: IFFALSE 53843
// control := control_manual ;
53835: LD_ADDR_VAR 0 4
53839: PUSH
53840: LD_INT 1
53842: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53843: LD_ADDR_VAR 0 8
53847: PUSH
53848: LD_VAR 0 1
53852: PPUSH
53853: CALL 53540 0 1
53857: ST_TO_ADDR
// if tmp then
53858: LD_VAR 0 8
53862: IFFALSE 53905
// begin for i in tmp do
53864: LD_ADDR_VAR 0 7
53868: PUSH
53869: LD_VAR 0 8
53873: PUSH
53874: FOR_IN
53875: IFFALSE 53903
// if i [ 1 ] = b_ext_radio then
53877: LD_VAR 0 7
53881: PUSH
53882: LD_INT 1
53884: ARRAY
53885: PUSH
53886: LD_INT 22
53888: EQUAL
53889: IFFALSE 53901
// begin control := control_remote ;
53891: LD_ADDR_VAR 0 4
53895: PUSH
53896: LD_INT 2
53898: ST_TO_ADDR
// break ;
53899: GO 53903
// end ;
53901: GO 53874
53903: POP
53904: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53905: LD_VAR 0 1
53909: PPUSH
53910: LD_VAR 0 2
53914: PPUSH
53915: LD_VAR 0 3
53919: PPUSH
53920: LD_VAR 0 4
53924: PPUSH
53925: LD_VAR 0 5
53929: PPUSH
53930: CALL_OW 448
53934: IFFALSE 53969
// begin result := [ chassis , engine , control , weapon ] ;
53936: LD_ADDR_VAR 0 6
53940: PUSH
53941: LD_VAR 0 2
53945: PUSH
53946: LD_VAR 0 3
53950: PUSH
53951: LD_VAR 0 4
53955: PUSH
53956: LD_VAR 0 5
53960: PUSH
53961: EMPTY
53962: LIST
53963: LIST
53964: LIST
53965: LIST
53966: ST_TO_ADDR
// exit ;
53967: GO 54381
// end ; _chassis := AvailableChassisList ( factory ) ;
53969: LD_ADDR_VAR 0 9
53973: PUSH
53974: LD_VAR 0 1
53978: PPUSH
53979: CALL_OW 475
53983: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53984: LD_ADDR_VAR 0 11
53988: PUSH
53989: LD_VAR 0 1
53993: PPUSH
53994: CALL_OW 476
53998: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53999: LD_ADDR_VAR 0 12
54003: PUSH
54004: LD_VAR 0 1
54008: PPUSH
54009: CALL_OW 477
54013: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54014: LD_ADDR_VAR 0 10
54018: PUSH
54019: LD_VAR 0 1
54023: PPUSH
54024: CALL_OW 478
54028: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54029: LD_VAR 0 9
54033: NOT
54034: PUSH
54035: LD_VAR 0 11
54039: NOT
54040: OR
54041: PUSH
54042: LD_VAR 0 12
54046: NOT
54047: OR
54048: PUSH
54049: LD_VAR 0 10
54053: NOT
54054: OR
54055: IFFALSE 54090
// begin result := [ chassis , engine , control , weapon ] ;
54057: LD_ADDR_VAR 0 6
54061: PUSH
54062: LD_VAR 0 2
54066: PUSH
54067: LD_VAR 0 3
54071: PUSH
54072: LD_VAR 0 4
54076: PUSH
54077: LD_VAR 0 5
54081: PUSH
54082: EMPTY
54083: LIST
54084: LIST
54085: LIST
54086: LIST
54087: ST_TO_ADDR
// exit ;
54088: GO 54381
// end ; if not chassis in _chassis then
54090: LD_VAR 0 2
54094: PUSH
54095: LD_VAR 0 9
54099: IN
54100: NOT
54101: IFFALSE 54127
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54103: LD_ADDR_VAR 0 2
54107: PUSH
54108: LD_VAR 0 9
54112: PUSH
54113: LD_INT 1
54115: PPUSH
54116: LD_VAR 0 9
54120: PPUSH
54121: CALL_OW 12
54125: ARRAY
54126: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54127: LD_VAR 0 2
54131: PPUSH
54132: LD_VAR 0 3
54136: PPUSH
54137: CALL 54386 0 2
54141: NOT
54142: IFFALSE 54201
// repeat engine := _engine [ 1 ] ;
54144: LD_ADDR_VAR 0 3
54148: PUSH
54149: LD_VAR 0 11
54153: PUSH
54154: LD_INT 1
54156: ARRAY
54157: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54158: LD_ADDR_VAR 0 11
54162: PUSH
54163: LD_VAR 0 11
54167: PPUSH
54168: LD_INT 1
54170: PPUSH
54171: CALL_OW 3
54175: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54176: LD_VAR 0 2
54180: PPUSH
54181: LD_VAR 0 3
54185: PPUSH
54186: CALL 54386 0 2
54190: PUSH
54191: LD_VAR 0 11
54195: PUSH
54196: EMPTY
54197: EQUAL
54198: OR
54199: IFFALSE 54144
// if not control in _control then
54201: LD_VAR 0 4
54205: PUSH
54206: LD_VAR 0 12
54210: IN
54211: NOT
54212: IFFALSE 54238
// control := _control [ rand ( 1 , _control ) ] ;
54214: LD_ADDR_VAR 0 4
54218: PUSH
54219: LD_VAR 0 12
54223: PUSH
54224: LD_INT 1
54226: PPUSH
54227: LD_VAR 0 12
54231: PPUSH
54232: CALL_OW 12
54236: ARRAY
54237: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54238: LD_VAR 0 2
54242: PPUSH
54243: LD_VAR 0 5
54247: PPUSH
54248: CALL 54606 0 2
54252: NOT
54253: IFFALSE 54312
// repeat weapon := _weapon [ 1 ] ;
54255: LD_ADDR_VAR 0 5
54259: PUSH
54260: LD_VAR 0 10
54264: PUSH
54265: LD_INT 1
54267: ARRAY
54268: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54269: LD_ADDR_VAR 0 10
54273: PUSH
54274: LD_VAR 0 10
54278: PPUSH
54279: LD_INT 1
54281: PPUSH
54282: CALL_OW 3
54286: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
54287: LD_VAR 0 2
54291: PPUSH
54292: LD_VAR 0 5
54296: PPUSH
54297: CALL 54606 0 2
54301: PUSH
54302: LD_VAR 0 10
54306: PUSH
54307: EMPTY
54308: EQUAL
54309: OR
54310: IFFALSE 54255
// result := [ ] ;
54312: LD_ADDR_VAR 0 6
54316: PUSH
54317: EMPTY
54318: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54319: LD_VAR 0 1
54323: PPUSH
54324: LD_VAR 0 2
54328: PPUSH
54329: LD_VAR 0 3
54333: PPUSH
54334: LD_VAR 0 4
54338: PPUSH
54339: LD_VAR 0 5
54343: PPUSH
54344: CALL_OW 448
54348: IFFALSE 54381
// result := [ chassis , engine , control , weapon ] ;
54350: LD_ADDR_VAR 0 6
54354: PUSH
54355: LD_VAR 0 2
54359: PUSH
54360: LD_VAR 0 3
54364: PUSH
54365: LD_VAR 0 4
54369: PUSH
54370: LD_VAR 0 5
54374: PUSH
54375: EMPTY
54376: LIST
54377: LIST
54378: LIST
54379: LIST
54380: ST_TO_ADDR
// end ;
54381: LD_VAR 0 6
54385: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
54386: LD_INT 0
54388: PPUSH
// if not chassis or not engine then
54389: LD_VAR 0 1
54393: NOT
54394: PUSH
54395: LD_VAR 0 2
54399: NOT
54400: OR
54401: IFFALSE 54405
// exit ;
54403: GO 54601
// case engine of engine_solar :
54405: LD_VAR 0 2
54409: PUSH
54410: LD_INT 2
54412: DOUBLE
54413: EQUAL
54414: IFTRUE 54418
54416: GO 54456
54418: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
54419: LD_ADDR_VAR 0 3
54423: PUSH
54424: LD_INT 11
54426: PUSH
54427: LD_INT 12
54429: PUSH
54430: LD_INT 13
54432: PUSH
54433: LD_INT 14
54435: PUSH
54436: LD_INT 1
54438: PUSH
54439: LD_INT 2
54441: PUSH
54442: LD_INT 3
54444: PUSH
54445: EMPTY
54446: LIST
54447: LIST
54448: LIST
54449: LIST
54450: LIST
54451: LIST
54452: LIST
54453: ST_TO_ADDR
54454: GO 54585
54456: LD_INT 1
54458: DOUBLE
54459: EQUAL
54460: IFTRUE 54464
54462: GO 54526
54464: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54465: LD_ADDR_VAR 0 3
54469: PUSH
54470: LD_INT 11
54472: PUSH
54473: LD_INT 12
54475: PUSH
54476: LD_INT 13
54478: PUSH
54479: LD_INT 14
54481: PUSH
54482: LD_INT 1
54484: PUSH
54485: LD_INT 2
54487: PUSH
54488: LD_INT 3
54490: PUSH
54491: LD_INT 4
54493: PUSH
54494: LD_INT 5
54496: PUSH
54497: LD_INT 21
54499: PUSH
54500: LD_INT 23
54502: PUSH
54503: LD_INT 22
54505: PUSH
54506: LD_INT 24
54508: PUSH
54509: EMPTY
54510: LIST
54511: LIST
54512: LIST
54513: LIST
54514: LIST
54515: LIST
54516: LIST
54517: LIST
54518: LIST
54519: LIST
54520: LIST
54521: LIST
54522: LIST
54523: ST_TO_ADDR
54524: GO 54585
54526: LD_INT 3
54528: DOUBLE
54529: EQUAL
54530: IFTRUE 54534
54532: GO 54584
54534: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54535: LD_ADDR_VAR 0 3
54539: PUSH
54540: LD_INT 13
54542: PUSH
54543: LD_INT 14
54545: PUSH
54546: LD_INT 2
54548: PUSH
54549: LD_INT 3
54551: PUSH
54552: LD_INT 4
54554: PUSH
54555: LD_INT 5
54557: PUSH
54558: LD_INT 21
54560: PUSH
54561: LD_INT 22
54563: PUSH
54564: LD_INT 23
54566: PUSH
54567: LD_INT 24
54569: PUSH
54570: EMPTY
54571: LIST
54572: LIST
54573: LIST
54574: LIST
54575: LIST
54576: LIST
54577: LIST
54578: LIST
54579: LIST
54580: LIST
54581: ST_TO_ADDR
54582: GO 54585
54584: POP
// result := ( chassis in result ) ;
54585: LD_ADDR_VAR 0 3
54589: PUSH
54590: LD_VAR 0 1
54594: PUSH
54595: LD_VAR 0 3
54599: IN
54600: ST_TO_ADDR
// end ;
54601: LD_VAR 0 3
54605: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54606: LD_INT 0
54608: PPUSH
// if not chassis or not weapon then
54609: LD_VAR 0 1
54613: NOT
54614: PUSH
54615: LD_VAR 0 2
54619: NOT
54620: OR
54621: IFFALSE 54625
// exit ;
54623: GO 55651
// case weapon of us_machine_gun :
54625: LD_VAR 0 2
54629: PUSH
54630: LD_INT 2
54632: DOUBLE
54633: EQUAL
54634: IFTRUE 54638
54636: GO 54668
54638: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54639: LD_ADDR_VAR 0 3
54643: PUSH
54644: LD_INT 1
54646: PUSH
54647: LD_INT 2
54649: PUSH
54650: LD_INT 3
54652: PUSH
54653: LD_INT 4
54655: PUSH
54656: LD_INT 5
54658: PUSH
54659: EMPTY
54660: LIST
54661: LIST
54662: LIST
54663: LIST
54664: LIST
54665: ST_TO_ADDR
54666: GO 55635
54668: LD_INT 3
54670: DOUBLE
54671: EQUAL
54672: IFTRUE 54676
54674: GO 54706
54676: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54677: LD_ADDR_VAR 0 3
54681: PUSH
54682: LD_INT 1
54684: PUSH
54685: LD_INT 2
54687: PUSH
54688: LD_INT 3
54690: PUSH
54691: LD_INT 4
54693: PUSH
54694: LD_INT 5
54696: PUSH
54697: EMPTY
54698: LIST
54699: LIST
54700: LIST
54701: LIST
54702: LIST
54703: ST_TO_ADDR
54704: GO 55635
54706: LD_INT 11
54708: DOUBLE
54709: EQUAL
54710: IFTRUE 54714
54712: GO 54744
54714: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54715: LD_ADDR_VAR 0 3
54719: PUSH
54720: LD_INT 1
54722: PUSH
54723: LD_INT 2
54725: PUSH
54726: LD_INT 3
54728: PUSH
54729: LD_INT 4
54731: PUSH
54732: LD_INT 5
54734: PUSH
54735: EMPTY
54736: LIST
54737: LIST
54738: LIST
54739: LIST
54740: LIST
54741: ST_TO_ADDR
54742: GO 55635
54744: LD_INT 4
54746: DOUBLE
54747: EQUAL
54748: IFTRUE 54752
54750: GO 54778
54752: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54753: LD_ADDR_VAR 0 3
54757: PUSH
54758: LD_INT 2
54760: PUSH
54761: LD_INT 3
54763: PUSH
54764: LD_INT 4
54766: PUSH
54767: LD_INT 5
54769: PUSH
54770: EMPTY
54771: LIST
54772: LIST
54773: LIST
54774: LIST
54775: ST_TO_ADDR
54776: GO 55635
54778: LD_INT 5
54780: DOUBLE
54781: EQUAL
54782: IFTRUE 54786
54784: GO 54812
54786: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54787: LD_ADDR_VAR 0 3
54791: PUSH
54792: LD_INT 2
54794: PUSH
54795: LD_INT 3
54797: PUSH
54798: LD_INT 4
54800: PUSH
54801: LD_INT 5
54803: PUSH
54804: EMPTY
54805: LIST
54806: LIST
54807: LIST
54808: LIST
54809: ST_TO_ADDR
54810: GO 55635
54812: LD_INT 9
54814: DOUBLE
54815: EQUAL
54816: IFTRUE 54820
54818: GO 54846
54820: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54821: LD_ADDR_VAR 0 3
54825: PUSH
54826: LD_INT 2
54828: PUSH
54829: LD_INT 3
54831: PUSH
54832: LD_INT 4
54834: PUSH
54835: LD_INT 5
54837: PUSH
54838: EMPTY
54839: LIST
54840: LIST
54841: LIST
54842: LIST
54843: ST_TO_ADDR
54844: GO 55635
54846: LD_INT 7
54848: DOUBLE
54849: EQUAL
54850: IFTRUE 54854
54852: GO 54880
54854: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54855: LD_ADDR_VAR 0 3
54859: PUSH
54860: LD_INT 2
54862: PUSH
54863: LD_INT 3
54865: PUSH
54866: LD_INT 4
54868: PUSH
54869: LD_INT 5
54871: PUSH
54872: EMPTY
54873: LIST
54874: LIST
54875: LIST
54876: LIST
54877: ST_TO_ADDR
54878: GO 55635
54880: LD_INT 12
54882: DOUBLE
54883: EQUAL
54884: IFTRUE 54888
54886: GO 54914
54888: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54889: LD_ADDR_VAR 0 3
54893: PUSH
54894: LD_INT 2
54896: PUSH
54897: LD_INT 3
54899: PUSH
54900: LD_INT 4
54902: PUSH
54903: LD_INT 5
54905: PUSH
54906: EMPTY
54907: LIST
54908: LIST
54909: LIST
54910: LIST
54911: ST_TO_ADDR
54912: GO 55635
54914: LD_INT 13
54916: DOUBLE
54917: EQUAL
54918: IFTRUE 54922
54920: GO 54948
54922: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54923: LD_ADDR_VAR 0 3
54927: PUSH
54928: LD_INT 2
54930: PUSH
54931: LD_INT 3
54933: PUSH
54934: LD_INT 4
54936: PUSH
54937: LD_INT 5
54939: PUSH
54940: EMPTY
54941: LIST
54942: LIST
54943: LIST
54944: LIST
54945: ST_TO_ADDR
54946: GO 55635
54948: LD_INT 14
54950: DOUBLE
54951: EQUAL
54952: IFTRUE 54956
54954: GO 54974
54956: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54957: LD_ADDR_VAR 0 3
54961: PUSH
54962: LD_INT 4
54964: PUSH
54965: LD_INT 5
54967: PUSH
54968: EMPTY
54969: LIST
54970: LIST
54971: ST_TO_ADDR
54972: GO 55635
54974: LD_INT 6
54976: DOUBLE
54977: EQUAL
54978: IFTRUE 54982
54980: GO 55000
54982: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54983: LD_ADDR_VAR 0 3
54987: PUSH
54988: LD_INT 4
54990: PUSH
54991: LD_INT 5
54993: PUSH
54994: EMPTY
54995: LIST
54996: LIST
54997: ST_TO_ADDR
54998: GO 55635
55000: LD_INT 10
55002: DOUBLE
55003: EQUAL
55004: IFTRUE 55008
55006: GO 55026
55008: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55009: LD_ADDR_VAR 0 3
55013: PUSH
55014: LD_INT 4
55016: PUSH
55017: LD_INT 5
55019: PUSH
55020: EMPTY
55021: LIST
55022: LIST
55023: ST_TO_ADDR
55024: GO 55635
55026: LD_INT 22
55028: DOUBLE
55029: EQUAL
55030: IFTRUE 55034
55032: GO 55060
55034: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55035: LD_ADDR_VAR 0 3
55039: PUSH
55040: LD_INT 11
55042: PUSH
55043: LD_INT 12
55045: PUSH
55046: LD_INT 13
55048: PUSH
55049: LD_INT 14
55051: PUSH
55052: EMPTY
55053: LIST
55054: LIST
55055: LIST
55056: LIST
55057: ST_TO_ADDR
55058: GO 55635
55060: LD_INT 23
55062: DOUBLE
55063: EQUAL
55064: IFTRUE 55068
55066: GO 55094
55068: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55069: LD_ADDR_VAR 0 3
55073: PUSH
55074: LD_INT 11
55076: PUSH
55077: LD_INT 12
55079: PUSH
55080: LD_INT 13
55082: PUSH
55083: LD_INT 14
55085: PUSH
55086: EMPTY
55087: LIST
55088: LIST
55089: LIST
55090: LIST
55091: ST_TO_ADDR
55092: GO 55635
55094: LD_INT 24
55096: DOUBLE
55097: EQUAL
55098: IFTRUE 55102
55100: GO 55128
55102: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55103: LD_ADDR_VAR 0 3
55107: PUSH
55108: LD_INT 11
55110: PUSH
55111: LD_INT 12
55113: PUSH
55114: LD_INT 13
55116: PUSH
55117: LD_INT 14
55119: PUSH
55120: EMPTY
55121: LIST
55122: LIST
55123: LIST
55124: LIST
55125: ST_TO_ADDR
55126: GO 55635
55128: LD_INT 30
55130: DOUBLE
55131: EQUAL
55132: IFTRUE 55136
55134: GO 55162
55136: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55137: LD_ADDR_VAR 0 3
55141: PUSH
55142: LD_INT 11
55144: PUSH
55145: LD_INT 12
55147: PUSH
55148: LD_INT 13
55150: PUSH
55151: LD_INT 14
55153: PUSH
55154: EMPTY
55155: LIST
55156: LIST
55157: LIST
55158: LIST
55159: ST_TO_ADDR
55160: GO 55635
55162: LD_INT 25
55164: DOUBLE
55165: EQUAL
55166: IFTRUE 55170
55168: GO 55188
55170: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55171: LD_ADDR_VAR 0 3
55175: PUSH
55176: LD_INT 13
55178: PUSH
55179: LD_INT 14
55181: PUSH
55182: EMPTY
55183: LIST
55184: LIST
55185: ST_TO_ADDR
55186: GO 55635
55188: LD_INT 27
55190: DOUBLE
55191: EQUAL
55192: IFTRUE 55196
55194: GO 55214
55196: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55197: LD_ADDR_VAR 0 3
55201: PUSH
55202: LD_INT 13
55204: PUSH
55205: LD_INT 14
55207: PUSH
55208: EMPTY
55209: LIST
55210: LIST
55211: ST_TO_ADDR
55212: GO 55635
55214: LD_INT 28
55216: DOUBLE
55217: EQUAL
55218: IFTRUE 55222
55220: GO 55240
55222: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55223: LD_ADDR_VAR 0 3
55227: PUSH
55228: LD_INT 13
55230: PUSH
55231: LD_INT 14
55233: PUSH
55234: EMPTY
55235: LIST
55236: LIST
55237: ST_TO_ADDR
55238: GO 55635
55240: LD_INT 29
55242: DOUBLE
55243: EQUAL
55244: IFTRUE 55248
55246: GO 55266
55248: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55249: LD_ADDR_VAR 0 3
55253: PUSH
55254: LD_INT 13
55256: PUSH
55257: LD_INT 14
55259: PUSH
55260: EMPTY
55261: LIST
55262: LIST
55263: ST_TO_ADDR
55264: GO 55635
55266: LD_INT 31
55268: DOUBLE
55269: EQUAL
55270: IFTRUE 55274
55272: GO 55292
55274: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
55275: LD_ADDR_VAR 0 3
55279: PUSH
55280: LD_INT 13
55282: PUSH
55283: LD_INT 14
55285: PUSH
55286: EMPTY
55287: LIST
55288: LIST
55289: ST_TO_ADDR
55290: GO 55635
55292: LD_INT 26
55294: DOUBLE
55295: EQUAL
55296: IFTRUE 55300
55298: GO 55318
55300: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
55301: LD_ADDR_VAR 0 3
55305: PUSH
55306: LD_INT 13
55308: PUSH
55309: LD_INT 14
55311: PUSH
55312: EMPTY
55313: LIST
55314: LIST
55315: ST_TO_ADDR
55316: GO 55635
55318: LD_INT 42
55320: DOUBLE
55321: EQUAL
55322: IFTRUE 55326
55324: GO 55352
55326: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
55327: LD_ADDR_VAR 0 3
55331: PUSH
55332: LD_INT 21
55334: PUSH
55335: LD_INT 22
55337: PUSH
55338: LD_INT 23
55340: PUSH
55341: LD_INT 24
55343: PUSH
55344: EMPTY
55345: LIST
55346: LIST
55347: LIST
55348: LIST
55349: ST_TO_ADDR
55350: GO 55635
55352: LD_INT 43
55354: DOUBLE
55355: EQUAL
55356: IFTRUE 55360
55358: GO 55386
55360: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
55361: LD_ADDR_VAR 0 3
55365: PUSH
55366: LD_INT 21
55368: PUSH
55369: LD_INT 22
55371: PUSH
55372: LD_INT 23
55374: PUSH
55375: LD_INT 24
55377: PUSH
55378: EMPTY
55379: LIST
55380: LIST
55381: LIST
55382: LIST
55383: ST_TO_ADDR
55384: GO 55635
55386: LD_INT 44
55388: DOUBLE
55389: EQUAL
55390: IFTRUE 55394
55392: GO 55420
55394: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
55395: LD_ADDR_VAR 0 3
55399: PUSH
55400: LD_INT 21
55402: PUSH
55403: LD_INT 22
55405: PUSH
55406: LD_INT 23
55408: PUSH
55409: LD_INT 24
55411: PUSH
55412: EMPTY
55413: LIST
55414: LIST
55415: LIST
55416: LIST
55417: ST_TO_ADDR
55418: GO 55635
55420: LD_INT 45
55422: DOUBLE
55423: EQUAL
55424: IFTRUE 55428
55426: GO 55454
55428: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55429: LD_ADDR_VAR 0 3
55433: PUSH
55434: LD_INT 21
55436: PUSH
55437: LD_INT 22
55439: PUSH
55440: LD_INT 23
55442: PUSH
55443: LD_INT 24
55445: PUSH
55446: EMPTY
55447: LIST
55448: LIST
55449: LIST
55450: LIST
55451: ST_TO_ADDR
55452: GO 55635
55454: LD_INT 49
55456: DOUBLE
55457: EQUAL
55458: IFTRUE 55462
55460: GO 55488
55462: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55463: LD_ADDR_VAR 0 3
55467: PUSH
55468: LD_INT 21
55470: PUSH
55471: LD_INT 22
55473: PUSH
55474: LD_INT 23
55476: PUSH
55477: LD_INT 24
55479: PUSH
55480: EMPTY
55481: LIST
55482: LIST
55483: LIST
55484: LIST
55485: ST_TO_ADDR
55486: GO 55635
55488: LD_INT 51
55490: DOUBLE
55491: EQUAL
55492: IFTRUE 55496
55494: GO 55522
55496: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55497: LD_ADDR_VAR 0 3
55501: PUSH
55502: LD_INT 21
55504: PUSH
55505: LD_INT 22
55507: PUSH
55508: LD_INT 23
55510: PUSH
55511: LD_INT 24
55513: PUSH
55514: EMPTY
55515: LIST
55516: LIST
55517: LIST
55518: LIST
55519: ST_TO_ADDR
55520: GO 55635
55522: LD_INT 52
55524: DOUBLE
55525: EQUAL
55526: IFTRUE 55530
55528: GO 55556
55530: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55531: LD_ADDR_VAR 0 3
55535: PUSH
55536: LD_INT 21
55538: PUSH
55539: LD_INT 22
55541: PUSH
55542: LD_INT 23
55544: PUSH
55545: LD_INT 24
55547: PUSH
55548: EMPTY
55549: LIST
55550: LIST
55551: LIST
55552: LIST
55553: ST_TO_ADDR
55554: GO 55635
55556: LD_INT 53
55558: DOUBLE
55559: EQUAL
55560: IFTRUE 55564
55562: GO 55582
55564: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55565: LD_ADDR_VAR 0 3
55569: PUSH
55570: LD_INT 23
55572: PUSH
55573: LD_INT 24
55575: PUSH
55576: EMPTY
55577: LIST
55578: LIST
55579: ST_TO_ADDR
55580: GO 55635
55582: LD_INT 46
55584: DOUBLE
55585: EQUAL
55586: IFTRUE 55590
55588: GO 55608
55590: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55591: LD_ADDR_VAR 0 3
55595: PUSH
55596: LD_INT 23
55598: PUSH
55599: LD_INT 24
55601: PUSH
55602: EMPTY
55603: LIST
55604: LIST
55605: ST_TO_ADDR
55606: GO 55635
55608: LD_INT 47
55610: DOUBLE
55611: EQUAL
55612: IFTRUE 55616
55614: GO 55634
55616: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55617: LD_ADDR_VAR 0 3
55621: PUSH
55622: LD_INT 23
55624: PUSH
55625: LD_INT 24
55627: PUSH
55628: EMPTY
55629: LIST
55630: LIST
55631: ST_TO_ADDR
55632: GO 55635
55634: POP
// result := ( chassis in result ) ;
55635: LD_ADDR_VAR 0 3
55639: PUSH
55640: LD_VAR 0 1
55644: PUSH
55645: LD_VAR 0 3
55649: IN
55650: ST_TO_ADDR
// end ;
55651: LD_VAR 0 3
55655: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55656: LD_INT 0
55658: PPUSH
55659: PPUSH
55660: PPUSH
55661: PPUSH
55662: PPUSH
55663: PPUSH
55664: PPUSH
// result := array ;
55665: LD_ADDR_VAR 0 5
55669: PUSH
55670: LD_VAR 0 1
55674: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55675: LD_VAR 0 1
55679: NOT
55680: PUSH
55681: LD_VAR 0 2
55685: NOT
55686: OR
55687: PUSH
55688: LD_VAR 0 3
55692: NOT
55693: OR
55694: PUSH
55695: LD_VAR 0 2
55699: PUSH
55700: LD_VAR 0 1
55704: GREATER
55705: OR
55706: PUSH
55707: LD_VAR 0 3
55711: PUSH
55712: LD_VAR 0 1
55716: GREATER
55717: OR
55718: IFFALSE 55722
// exit ;
55720: GO 56018
// if direction then
55722: LD_VAR 0 4
55726: IFFALSE 55790
// begin d := 1 ;
55728: LD_ADDR_VAR 0 9
55732: PUSH
55733: LD_INT 1
55735: ST_TO_ADDR
// if i_from > i_to then
55736: LD_VAR 0 2
55740: PUSH
55741: LD_VAR 0 3
55745: GREATER
55746: IFFALSE 55772
// length := ( array - i_from ) + i_to else
55748: LD_ADDR_VAR 0 11
55752: PUSH
55753: LD_VAR 0 1
55757: PUSH
55758: LD_VAR 0 2
55762: MINUS
55763: PUSH
55764: LD_VAR 0 3
55768: PLUS
55769: ST_TO_ADDR
55770: GO 55788
// length := i_to - i_from ;
55772: LD_ADDR_VAR 0 11
55776: PUSH
55777: LD_VAR 0 3
55781: PUSH
55782: LD_VAR 0 2
55786: MINUS
55787: ST_TO_ADDR
// end else
55788: GO 55851
// begin d := - 1 ;
55790: LD_ADDR_VAR 0 9
55794: PUSH
55795: LD_INT 1
55797: NEG
55798: ST_TO_ADDR
// if i_from > i_to then
55799: LD_VAR 0 2
55803: PUSH
55804: LD_VAR 0 3
55808: GREATER
55809: IFFALSE 55829
// length := i_from - i_to else
55811: LD_ADDR_VAR 0 11
55815: PUSH
55816: LD_VAR 0 2
55820: PUSH
55821: LD_VAR 0 3
55825: MINUS
55826: ST_TO_ADDR
55827: GO 55851
// length := ( array - i_to ) + i_from ;
55829: LD_ADDR_VAR 0 11
55833: PUSH
55834: LD_VAR 0 1
55838: PUSH
55839: LD_VAR 0 3
55843: MINUS
55844: PUSH
55845: LD_VAR 0 2
55849: PLUS
55850: ST_TO_ADDR
// end ; if not length then
55851: LD_VAR 0 11
55855: NOT
55856: IFFALSE 55860
// exit ;
55858: GO 56018
// tmp := array ;
55860: LD_ADDR_VAR 0 10
55864: PUSH
55865: LD_VAR 0 1
55869: ST_TO_ADDR
// for i = 1 to length do
55870: LD_ADDR_VAR 0 6
55874: PUSH
55875: DOUBLE
55876: LD_INT 1
55878: DEC
55879: ST_TO_ADDR
55880: LD_VAR 0 11
55884: PUSH
55885: FOR_TO
55886: IFFALSE 56006
// begin for j = 1 to array do
55888: LD_ADDR_VAR 0 7
55892: PUSH
55893: DOUBLE
55894: LD_INT 1
55896: DEC
55897: ST_TO_ADDR
55898: LD_VAR 0 1
55902: PUSH
55903: FOR_TO
55904: IFFALSE 55992
// begin k := j + d ;
55906: LD_ADDR_VAR 0 8
55910: PUSH
55911: LD_VAR 0 7
55915: PUSH
55916: LD_VAR 0 9
55920: PLUS
55921: ST_TO_ADDR
// if k > array then
55922: LD_VAR 0 8
55926: PUSH
55927: LD_VAR 0 1
55931: GREATER
55932: IFFALSE 55942
// k := 1 ;
55934: LD_ADDR_VAR 0 8
55938: PUSH
55939: LD_INT 1
55941: ST_TO_ADDR
// if not k then
55942: LD_VAR 0 8
55946: NOT
55947: IFFALSE 55959
// k := array ;
55949: LD_ADDR_VAR 0 8
55953: PUSH
55954: LD_VAR 0 1
55958: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55959: LD_ADDR_VAR 0 10
55963: PUSH
55964: LD_VAR 0 10
55968: PPUSH
55969: LD_VAR 0 8
55973: PPUSH
55974: LD_VAR 0 1
55978: PUSH
55979: LD_VAR 0 7
55983: ARRAY
55984: PPUSH
55985: CALL_OW 1
55989: ST_TO_ADDR
// end ;
55990: GO 55903
55992: POP
55993: POP
// array := tmp ;
55994: LD_ADDR_VAR 0 1
55998: PUSH
55999: LD_VAR 0 10
56003: ST_TO_ADDR
// end ;
56004: GO 55885
56006: POP
56007: POP
// result := array ;
56008: LD_ADDR_VAR 0 5
56012: PUSH
56013: LD_VAR 0 1
56017: ST_TO_ADDR
// end ;
56018: LD_VAR 0 5
56022: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56023: LD_INT 0
56025: PPUSH
56026: PPUSH
// result := 0 ;
56027: LD_ADDR_VAR 0 3
56031: PUSH
56032: LD_INT 0
56034: ST_TO_ADDR
// if not array or not value in array then
56035: LD_VAR 0 1
56039: NOT
56040: PUSH
56041: LD_VAR 0 2
56045: PUSH
56046: LD_VAR 0 1
56050: IN
56051: NOT
56052: OR
56053: IFFALSE 56057
// exit ;
56055: GO 56111
// for i = 1 to array do
56057: LD_ADDR_VAR 0 4
56061: PUSH
56062: DOUBLE
56063: LD_INT 1
56065: DEC
56066: ST_TO_ADDR
56067: LD_VAR 0 1
56071: PUSH
56072: FOR_TO
56073: IFFALSE 56109
// if value = array [ i ] then
56075: LD_VAR 0 2
56079: PUSH
56080: LD_VAR 0 1
56084: PUSH
56085: LD_VAR 0 4
56089: ARRAY
56090: EQUAL
56091: IFFALSE 56107
// begin result := i ;
56093: LD_ADDR_VAR 0 3
56097: PUSH
56098: LD_VAR 0 4
56102: ST_TO_ADDR
// exit ;
56103: POP
56104: POP
56105: GO 56111
// end ;
56107: GO 56072
56109: POP
56110: POP
// end ;
56111: LD_VAR 0 3
56115: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56116: LD_INT 0
56118: PPUSH
// vc_chassis := chassis ;
56119: LD_ADDR_OWVAR 37
56123: PUSH
56124: LD_VAR 0 1
56128: ST_TO_ADDR
// vc_engine := engine ;
56129: LD_ADDR_OWVAR 39
56133: PUSH
56134: LD_VAR 0 2
56138: ST_TO_ADDR
// vc_control := control ;
56139: LD_ADDR_OWVAR 38
56143: PUSH
56144: LD_VAR 0 3
56148: ST_TO_ADDR
// vc_weapon := weapon ;
56149: LD_ADDR_OWVAR 40
56153: PUSH
56154: LD_VAR 0 4
56158: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56159: LD_ADDR_OWVAR 41
56163: PUSH
56164: LD_VAR 0 5
56168: ST_TO_ADDR
// end ;
56169: LD_VAR 0 6
56173: RET
// export function WantPlant ( unit ) ; var task ; begin
56174: LD_INT 0
56176: PPUSH
56177: PPUSH
// result := false ;
56178: LD_ADDR_VAR 0 2
56182: PUSH
56183: LD_INT 0
56185: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56186: LD_ADDR_VAR 0 3
56190: PUSH
56191: LD_VAR 0 1
56195: PPUSH
56196: CALL_OW 437
56200: ST_TO_ADDR
// if task then
56201: LD_VAR 0 3
56205: IFFALSE 56233
// if task [ 1 ] [ 1 ] = p then
56207: LD_VAR 0 3
56211: PUSH
56212: LD_INT 1
56214: ARRAY
56215: PUSH
56216: LD_INT 1
56218: ARRAY
56219: PUSH
56220: LD_STRING p
56222: EQUAL
56223: IFFALSE 56233
// result := true ;
56225: LD_ADDR_VAR 0 2
56229: PUSH
56230: LD_INT 1
56232: ST_TO_ADDR
// end ;
56233: LD_VAR 0 2
56237: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56238: LD_INT 0
56240: PPUSH
56241: PPUSH
56242: PPUSH
56243: PPUSH
// if pos < 1 then
56244: LD_VAR 0 2
56248: PUSH
56249: LD_INT 1
56251: LESS
56252: IFFALSE 56256
// exit ;
56254: GO 56559
// if pos = 1 then
56256: LD_VAR 0 2
56260: PUSH
56261: LD_INT 1
56263: EQUAL
56264: IFFALSE 56297
// result := Replace ( arr , pos [ 1 ] , value ) else
56266: LD_ADDR_VAR 0 4
56270: PUSH
56271: LD_VAR 0 1
56275: PPUSH
56276: LD_VAR 0 2
56280: PUSH
56281: LD_INT 1
56283: ARRAY
56284: PPUSH
56285: LD_VAR 0 3
56289: PPUSH
56290: CALL_OW 1
56294: ST_TO_ADDR
56295: GO 56559
// begin tmp := arr ;
56297: LD_ADDR_VAR 0 6
56301: PUSH
56302: LD_VAR 0 1
56306: ST_TO_ADDR
// s_arr := [ tmp ] ;
56307: LD_ADDR_VAR 0 7
56311: PUSH
56312: LD_VAR 0 6
56316: PUSH
56317: EMPTY
56318: LIST
56319: ST_TO_ADDR
// for i = 1 to pos - 1 do
56320: LD_ADDR_VAR 0 5
56324: PUSH
56325: DOUBLE
56326: LD_INT 1
56328: DEC
56329: ST_TO_ADDR
56330: LD_VAR 0 2
56334: PUSH
56335: LD_INT 1
56337: MINUS
56338: PUSH
56339: FOR_TO
56340: IFFALSE 56385
// begin tmp := tmp [ pos [ i ] ] ;
56342: LD_ADDR_VAR 0 6
56346: PUSH
56347: LD_VAR 0 6
56351: PUSH
56352: LD_VAR 0 2
56356: PUSH
56357: LD_VAR 0 5
56361: ARRAY
56362: ARRAY
56363: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
56364: LD_ADDR_VAR 0 7
56368: PUSH
56369: LD_VAR 0 7
56373: PUSH
56374: LD_VAR 0 6
56378: PUSH
56379: EMPTY
56380: LIST
56381: ADD
56382: ST_TO_ADDR
// end ;
56383: GO 56339
56385: POP
56386: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
56387: LD_ADDR_VAR 0 6
56391: PUSH
56392: LD_VAR 0 6
56396: PPUSH
56397: LD_VAR 0 2
56401: PUSH
56402: LD_VAR 0 2
56406: ARRAY
56407: PPUSH
56408: LD_VAR 0 3
56412: PPUSH
56413: CALL_OW 1
56417: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
56418: LD_ADDR_VAR 0 7
56422: PUSH
56423: LD_VAR 0 7
56427: PPUSH
56428: LD_VAR 0 7
56432: PPUSH
56433: LD_VAR 0 6
56437: PPUSH
56438: CALL_OW 1
56442: ST_TO_ADDR
// for i = s_arr downto 2 do
56443: LD_ADDR_VAR 0 5
56447: PUSH
56448: DOUBLE
56449: LD_VAR 0 7
56453: INC
56454: ST_TO_ADDR
56455: LD_INT 2
56457: PUSH
56458: FOR_DOWNTO
56459: IFFALSE 56543
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56461: LD_ADDR_VAR 0 6
56465: PUSH
56466: LD_VAR 0 7
56470: PUSH
56471: LD_VAR 0 5
56475: PUSH
56476: LD_INT 1
56478: MINUS
56479: ARRAY
56480: PPUSH
56481: LD_VAR 0 2
56485: PUSH
56486: LD_VAR 0 5
56490: PUSH
56491: LD_INT 1
56493: MINUS
56494: ARRAY
56495: PPUSH
56496: LD_VAR 0 7
56500: PUSH
56501: LD_VAR 0 5
56505: ARRAY
56506: PPUSH
56507: CALL_OW 1
56511: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56512: LD_ADDR_VAR 0 7
56516: PUSH
56517: LD_VAR 0 7
56521: PPUSH
56522: LD_VAR 0 5
56526: PUSH
56527: LD_INT 1
56529: MINUS
56530: PPUSH
56531: LD_VAR 0 6
56535: PPUSH
56536: CALL_OW 1
56540: ST_TO_ADDR
// end ;
56541: GO 56458
56543: POP
56544: POP
// result := s_arr [ 1 ] ;
56545: LD_ADDR_VAR 0 4
56549: PUSH
56550: LD_VAR 0 7
56554: PUSH
56555: LD_INT 1
56557: ARRAY
56558: ST_TO_ADDR
// end ; end ;
56559: LD_VAR 0 4
56563: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56564: LD_INT 0
56566: PPUSH
56567: PPUSH
// if not list then
56568: LD_VAR 0 1
56572: NOT
56573: IFFALSE 56577
// exit ;
56575: GO 56668
// i := list [ pos1 ] ;
56577: LD_ADDR_VAR 0 5
56581: PUSH
56582: LD_VAR 0 1
56586: PUSH
56587: LD_VAR 0 2
56591: ARRAY
56592: ST_TO_ADDR
// if not i then
56593: LD_VAR 0 5
56597: NOT
56598: IFFALSE 56602
// exit ;
56600: GO 56668
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56602: LD_ADDR_VAR 0 1
56606: PUSH
56607: LD_VAR 0 1
56611: PPUSH
56612: LD_VAR 0 2
56616: PPUSH
56617: LD_VAR 0 1
56621: PUSH
56622: LD_VAR 0 3
56626: ARRAY
56627: PPUSH
56628: CALL_OW 1
56632: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56633: LD_ADDR_VAR 0 1
56637: PUSH
56638: LD_VAR 0 1
56642: PPUSH
56643: LD_VAR 0 3
56647: PPUSH
56648: LD_VAR 0 5
56652: PPUSH
56653: CALL_OW 1
56657: ST_TO_ADDR
// result := list ;
56658: LD_ADDR_VAR 0 4
56662: PUSH
56663: LD_VAR 0 1
56667: ST_TO_ADDR
// end ;
56668: LD_VAR 0 4
56672: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56673: LD_INT 0
56675: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56676: LD_ADDR_VAR 0 5
56680: PUSH
56681: LD_VAR 0 1
56685: PPUSH
56686: CALL_OW 250
56690: PPUSH
56691: LD_VAR 0 1
56695: PPUSH
56696: CALL_OW 251
56700: PPUSH
56701: LD_VAR 0 2
56705: PPUSH
56706: LD_VAR 0 3
56710: PPUSH
56711: LD_VAR 0 4
56715: PPUSH
56716: CALL 56726 0 5
56720: ST_TO_ADDR
// end ;
56721: LD_VAR 0 5
56725: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56726: LD_INT 0
56728: PPUSH
56729: PPUSH
56730: PPUSH
56731: PPUSH
// if not list then
56732: LD_VAR 0 3
56736: NOT
56737: IFFALSE 56741
// exit ;
56739: GO 57129
// result := [ ] ;
56741: LD_ADDR_VAR 0 6
56745: PUSH
56746: EMPTY
56747: ST_TO_ADDR
// for i in list do
56748: LD_ADDR_VAR 0 7
56752: PUSH
56753: LD_VAR 0 3
56757: PUSH
56758: FOR_IN
56759: IFFALSE 56961
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56761: LD_ADDR_VAR 0 9
56765: PUSH
56766: LD_VAR 0 7
56770: PPUSH
56771: LD_VAR 0 1
56775: PPUSH
56776: LD_VAR 0 2
56780: PPUSH
56781: CALL_OW 297
56785: ST_TO_ADDR
// if not result then
56786: LD_VAR 0 6
56790: NOT
56791: IFFALSE 56817
// result := [ [ i , tmp ] ] else
56793: LD_ADDR_VAR 0 6
56797: PUSH
56798: LD_VAR 0 7
56802: PUSH
56803: LD_VAR 0 9
56807: PUSH
56808: EMPTY
56809: LIST
56810: LIST
56811: PUSH
56812: EMPTY
56813: LIST
56814: ST_TO_ADDR
56815: GO 56959
// begin if result [ result ] [ 2 ] < tmp then
56817: LD_VAR 0 6
56821: PUSH
56822: LD_VAR 0 6
56826: ARRAY
56827: PUSH
56828: LD_INT 2
56830: ARRAY
56831: PUSH
56832: LD_VAR 0 9
56836: LESS
56837: IFFALSE 56879
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56839: LD_ADDR_VAR 0 6
56843: PUSH
56844: LD_VAR 0 6
56848: PPUSH
56849: LD_VAR 0 6
56853: PUSH
56854: LD_INT 1
56856: PLUS
56857: PPUSH
56858: LD_VAR 0 7
56862: PUSH
56863: LD_VAR 0 9
56867: PUSH
56868: EMPTY
56869: LIST
56870: LIST
56871: PPUSH
56872: CALL_OW 2
56876: ST_TO_ADDR
56877: GO 56959
// for j = 1 to result do
56879: LD_ADDR_VAR 0 8
56883: PUSH
56884: DOUBLE
56885: LD_INT 1
56887: DEC
56888: ST_TO_ADDR
56889: LD_VAR 0 6
56893: PUSH
56894: FOR_TO
56895: IFFALSE 56957
// begin if tmp < result [ j ] [ 2 ] then
56897: LD_VAR 0 9
56901: PUSH
56902: LD_VAR 0 6
56906: PUSH
56907: LD_VAR 0 8
56911: ARRAY
56912: PUSH
56913: LD_INT 2
56915: ARRAY
56916: LESS
56917: IFFALSE 56955
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56919: LD_ADDR_VAR 0 6
56923: PUSH
56924: LD_VAR 0 6
56928: PPUSH
56929: LD_VAR 0 8
56933: PPUSH
56934: LD_VAR 0 7
56938: PUSH
56939: LD_VAR 0 9
56943: PUSH
56944: EMPTY
56945: LIST
56946: LIST
56947: PPUSH
56948: CALL_OW 2
56952: ST_TO_ADDR
// break ;
56953: GO 56957
// end ; end ;
56955: GO 56894
56957: POP
56958: POP
// end ; end ;
56959: GO 56758
56961: POP
56962: POP
// if result and not asc then
56963: LD_VAR 0 6
56967: PUSH
56968: LD_VAR 0 4
56972: NOT
56973: AND
56974: IFFALSE 57049
// begin tmp := result ;
56976: LD_ADDR_VAR 0 9
56980: PUSH
56981: LD_VAR 0 6
56985: ST_TO_ADDR
// for i = tmp downto 1 do
56986: LD_ADDR_VAR 0 7
56990: PUSH
56991: DOUBLE
56992: LD_VAR 0 9
56996: INC
56997: ST_TO_ADDR
56998: LD_INT 1
57000: PUSH
57001: FOR_DOWNTO
57002: IFFALSE 57047
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57004: LD_ADDR_VAR 0 6
57008: PUSH
57009: LD_VAR 0 6
57013: PPUSH
57014: LD_VAR 0 9
57018: PUSH
57019: LD_VAR 0 7
57023: MINUS
57024: PUSH
57025: LD_INT 1
57027: PLUS
57028: PPUSH
57029: LD_VAR 0 9
57033: PUSH
57034: LD_VAR 0 7
57038: ARRAY
57039: PPUSH
57040: CALL_OW 1
57044: ST_TO_ADDR
57045: GO 57001
57047: POP
57048: POP
// end ; tmp := [ ] ;
57049: LD_ADDR_VAR 0 9
57053: PUSH
57054: EMPTY
57055: ST_TO_ADDR
// if mode then
57056: LD_VAR 0 5
57060: IFFALSE 57129
// begin for i = 1 to result do
57062: LD_ADDR_VAR 0 7
57066: PUSH
57067: DOUBLE
57068: LD_INT 1
57070: DEC
57071: ST_TO_ADDR
57072: LD_VAR 0 6
57076: PUSH
57077: FOR_TO
57078: IFFALSE 57117
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57080: LD_ADDR_VAR 0 9
57084: PUSH
57085: LD_VAR 0 9
57089: PPUSH
57090: LD_VAR 0 7
57094: PPUSH
57095: LD_VAR 0 6
57099: PUSH
57100: LD_VAR 0 7
57104: ARRAY
57105: PUSH
57106: LD_INT 1
57108: ARRAY
57109: PPUSH
57110: CALL_OW 1
57114: ST_TO_ADDR
57115: GO 57077
57117: POP
57118: POP
// result := tmp ;
57119: LD_ADDR_VAR 0 6
57123: PUSH
57124: LD_VAR 0 9
57128: ST_TO_ADDR
// end ; end ;
57129: LD_VAR 0 6
57133: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57134: LD_INT 0
57136: PPUSH
57137: PPUSH
57138: PPUSH
57139: PPUSH
57140: PPUSH
57141: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57142: LD_ADDR_VAR 0 5
57146: PUSH
57147: LD_INT 0
57149: PUSH
57150: LD_INT 0
57152: PUSH
57153: LD_INT 0
57155: PUSH
57156: EMPTY
57157: PUSH
57158: EMPTY
57159: LIST
57160: LIST
57161: LIST
57162: LIST
57163: ST_TO_ADDR
// if not x or not y then
57164: LD_VAR 0 2
57168: NOT
57169: PUSH
57170: LD_VAR 0 3
57174: NOT
57175: OR
57176: IFFALSE 57180
// exit ;
57178: GO 58826
// if not range then
57180: LD_VAR 0 4
57184: NOT
57185: IFFALSE 57195
// range := 10 ;
57187: LD_ADDR_VAR 0 4
57191: PUSH
57192: LD_INT 10
57194: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57195: LD_ADDR_VAR 0 8
57199: PUSH
57200: LD_INT 81
57202: PUSH
57203: LD_VAR 0 1
57207: PUSH
57208: EMPTY
57209: LIST
57210: LIST
57211: PUSH
57212: LD_INT 92
57214: PUSH
57215: LD_VAR 0 2
57219: PUSH
57220: LD_VAR 0 3
57224: PUSH
57225: LD_VAR 0 4
57229: PUSH
57230: EMPTY
57231: LIST
57232: LIST
57233: LIST
57234: LIST
57235: PUSH
57236: LD_INT 3
57238: PUSH
57239: LD_INT 21
57241: PUSH
57242: LD_INT 3
57244: PUSH
57245: EMPTY
57246: LIST
57247: LIST
57248: PUSH
57249: EMPTY
57250: LIST
57251: LIST
57252: PUSH
57253: EMPTY
57254: LIST
57255: LIST
57256: LIST
57257: PPUSH
57258: CALL_OW 69
57262: ST_TO_ADDR
// if not tmp then
57263: LD_VAR 0 8
57267: NOT
57268: IFFALSE 57272
// exit ;
57270: GO 58826
// for i in tmp do
57272: LD_ADDR_VAR 0 6
57276: PUSH
57277: LD_VAR 0 8
57281: PUSH
57282: FOR_IN
57283: IFFALSE 58801
// begin points := [ 0 , 0 , 0 ] ;
57285: LD_ADDR_VAR 0 9
57289: PUSH
57290: LD_INT 0
57292: PUSH
57293: LD_INT 0
57295: PUSH
57296: LD_INT 0
57298: PUSH
57299: EMPTY
57300: LIST
57301: LIST
57302: LIST
57303: ST_TO_ADDR
// bpoints := 1 ;
57304: LD_ADDR_VAR 0 10
57308: PUSH
57309: LD_INT 1
57311: ST_TO_ADDR
// case GetType ( i ) of unit_human :
57312: LD_VAR 0 6
57316: PPUSH
57317: CALL_OW 247
57321: PUSH
57322: LD_INT 1
57324: DOUBLE
57325: EQUAL
57326: IFTRUE 57330
57328: GO 57908
57330: POP
// begin if GetClass ( i ) = 1 then
57331: LD_VAR 0 6
57335: PPUSH
57336: CALL_OW 257
57340: PUSH
57341: LD_INT 1
57343: EQUAL
57344: IFFALSE 57365
// points := [ 10 , 5 , 3 ] ;
57346: LD_ADDR_VAR 0 9
57350: PUSH
57351: LD_INT 10
57353: PUSH
57354: LD_INT 5
57356: PUSH
57357: LD_INT 3
57359: PUSH
57360: EMPTY
57361: LIST
57362: LIST
57363: LIST
57364: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
57365: LD_VAR 0 6
57369: PPUSH
57370: CALL_OW 257
57374: PUSH
57375: LD_INT 2
57377: PUSH
57378: LD_INT 3
57380: PUSH
57381: LD_INT 4
57383: PUSH
57384: EMPTY
57385: LIST
57386: LIST
57387: LIST
57388: IN
57389: IFFALSE 57410
// points := [ 3 , 2 , 1 ] ;
57391: LD_ADDR_VAR 0 9
57395: PUSH
57396: LD_INT 3
57398: PUSH
57399: LD_INT 2
57401: PUSH
57402: LD_INT 1
57404: PUSH
57405: EMPTY
57406: LIST
57407: LIST
57408: LIST
57409: ST_TO_ADDR
// if GetClass ( i ) = 5 then
57410: LD_VAR 0 6
57414: PPUSH
57415: CALL_OW 257
57419: PUSH
57420: LD_INT 5
57422: EQUAL
57423: IFFALSE 57444
// points := [ 130 , 5 , 2 ] ;
57425: LD_ADDR_VAR 0 9
57429: PUSH
57430: LD_INT 130
57432: PUSH
57433: LD_INT 5
57435: PUSH
57436: LD_INT 2
57438: PUSH
57439: EMPTY
57440: LIST
57441: LIST
57442: LIST
57443: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57444: LD_VAR 0 6
57448: PPUSH
57449: CALL_OW 257
57453: PUSH
57454: LD_INT 8
57456: EQUAL
57457: IFFALSE 57478
// points := [ 35 , 35 , 30 ] ;
57459: LD_ADDR_VAR 0 9
57463: PUSH
57464: LD_INT 35
57466: PUSH
57467: LD_INT 35
57469: PUSH
57470: LD_INT 30
57472: PUSH
57473: EMPTY
57474: LIST
57475: LIST
57476: LIST
57477: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57478: LD_VAR 0 6
57482: PPUSH
57483: CALL_OW 257
57487: PUSH
57488: LD_INT 9
57490: EQUAL
57491: IFFALSE 57512
// points := [ 20 , 55 , 40 ] ;
57493: LD_ADDR_VAR 0 9
57497: PUSH
57498: LD_INT 20
57500: PUSH
57501: LD_INT 55
57503: PUSH
57504: LD_INT 40
57506: PUSH
57507: EMPTY
57508: LIST
57509: LIST
57510: LIST
57511: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57512: LD_VAR 0 6
57516: PPUSH
57517: CALL_OW 257
57521: PUSH
57522: LD_INT 12
57524: PUSH
57525: LD_INT 16
57527: PUSH
57528: EMPTY
57529: LIST
57530: LIST
57531: IN
57532: IFFALSE 57553
// points := [ 5 , 3 , 2 ] ;
57534: LD_ADDR_VAR 0 9
57538: PUSH
57539: LD_INT 5
57541: PUSH
57542: LD_INT 3
57544: PUSH
57545: LD_INT 2
57547: PUSH
57548: EMPTY
57549: LIST
57550: LIST
57551: LIST
57552: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57553: LD_VAR 0 6
57557: PPUSH
57558: CALL_OW 257
57562: PUSH
57563: LD_INT 17
57565: EQUAL
57566: IFFALSE 57587
// points := [ 100 , 50 , 75 ] ;
57568: LD_ADDR_VAR 0 9
57572: PUSH
57573: LD_INT 100
57575: PUSH
57576: LD_INT 50
57578: PUSH
57579: LD_INT 75
57581: PUSH
57582: EMPTY
57583: LIST
57584: LIST
57585: LIST
57586: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57587: LD_VAR 0 6
57591: PPUSH
57592: CALL_OW 257
57596: PUSH
57597: LD_INT 15
57599: EQUAL
57600: IFFALSE 57621
// points := [ 10 , 5 , 3 ] ;
57602: LD_ADDR_VAR 0 9
57606: PUSH
57607: LD_INT 10
57609: PUSH
57610: LD_INT 5
57612: PUSH
57613: LD_INT 3
57615: PUSH
57616: EMPTY
57617: LIST
57618: LIST
57619: LIST
57620: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57621: LD_VAR 0 6
57625: PPUSH
57626: CALL_OW 257
57630: PUSH
57631: LD_INT 14
57633: EQUAL
57634: IFFALSE 57655
// points := [ 10 , 0 , 0 ] ;
57636: LD_ADDR_VAR 0 9
57640: PUSH
57641: LD_INT 10
57643: PUSH
57644: LD_INT 0
57646: PUSH
57647: LD_INT 0
57649: PUSH
57650: EMPTY
57651: LIST
57652: LIST
57653: LIST
57654: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57655: LD_VAR 0 6
57659: PPUSH
57660: CALL_OW 257
57664: PUSH
57665: LD_INT 11
57667: EQUAL
57668: IFFALSE 57689
// points := [ 30 , 10 , 5 ] ;
57670: LD_ADDR_VAR 0 9
57674: PUSH
57675: LD_INT 30
57677: PUSH
57678: LD_INT 10
57680: PUSH
57681: LD_INT 5
57683: PUSH
57684: EMPTY
57685: LIST
57686: LIST
57687: LIST
57688: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57689: LD_VAR 0 1
57693: PPUSH
57694: LD_INT 5
57696: PPUSH
57697: CALL_OW 321
57701: PUSH
57702: LD_INT 2
57704: EQUAL
57705: IFFALSE 57722
// bpoints := bpoints * 1.8 ;
57707: LD_ADDR_VAR 0 10
57711: PUSH
57712: LD_VAR 0 10
57716: PUSH
57717: LD_REAL  1.80000000000000E+0000
57720: MUL
57721: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57722: LD_VAR 0 6
57726: PPUSH
57727: CALL_OW 257
57731: PUSH
57732: LD_INT 1
57734: PUSH
57735: LD_INT 2
57737: PUSH
57738: LD_INT 3
57740: PUSH
57741: LD_INT 4
57743: PUSH
57744: EMPTY
57745: LIST
57746: LIST
57747: LIST
57748: LIST
57749: IN
57750: PUSH
57751: LD_VAR 0 1
57755: PPUSH
57756: LD_INT 51
57758: PPUSH
57759: CALL_OW 321
57763: PUSH
57764: LD_INT 2
57766: EQUAL
57767: AND
57768: IFFALSE 57785
// bpoints := bpoints * 1.2 ;
57770: LD_ADDR_VAR 0 10
57774: PUSH
57775: LD_VAR 0 10
57779: PUSH
57780: LD_REAL  1.20000000000000E+0000
57783: MUL
57784: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57785: LD_VAR 0 6
57789: PPUSH
57790: CALL_OW 257
57794: PUSH
57795: LD_INT 5
57797: PUSH
57798: LD_INT 7
57800: PUSH
57801: LD_INT 9
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: LIST
57808: IN
57809: PUSH
57810: LD_VAR 0 1
57814: PPUSH
57815: LD_INT 52
57817: PPUSH
57818: CALL_OW 321
57822: PUSH
57823: LD_INT 2
57825: EQUAL
57826: AND
57827: IFFALSE 57844
// bpoints := bpoints * 1.5 ;
57829: LD_ADDR_VAR 0 10
57833: PUSH
57834: LD_VAR 0 10
57838: PUSH
57839: LD_REAL  1.50000000000000E+0000
57842: MUL
57843: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57844: LD_VAR 0 1
57848: PPUSH
57849: LD_INT 66
57851: PPUSH
57852: CALL_OW 321
57856: PUSH
57857: LD_INT 2
57859: EQUAL
57860: IFFALSE 57877
// bpoints := bpoints * 1.1 ;
57862: LD_ADDR_VAR 0 10
57866: PUSH
57867: LD_VAR 0 10
57871: PUSH
57872: LD_REAL  1.10000000000000E+0000
57875: MUL
57876: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57877: LD_ADDR_VAR 0 10
57881: PUSH
57882: LD_VAR 0 10
57886: PUSH
57887: LD_VAR 0 6
57891: PPUSH
57892: LD_INT 1
57894: PPUSH
57895: CALL_OW 259
57899: PUSH
57900: LD_REAL  1.15000000000000E+0000
57903: MUL
57904: MUL
57905: ST_TO_ADDR
// end ; unit_vehicle :
57906: GO 58730
57908: LD_INT 2
57910: DOUBLE
57911: EQUAL
57912: IFTRUE 57916
57914: GO 58718
57916: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57917: LD_VAR 0 6
57921: PPUSH
57922: CALL_OW 264
57926: PUSH
57927: LD_INT 2
57929: PUSH
57930: LD_INT 42
57932: PUSH
57933: LD_INT 24
57935: PUSH
57936: EMPTY
57937: LIST
57938: LIST
57939: LIST
57940: IN
57941: IFFALSE 57962
// points := [ 25 , 5 , 3 ] ;
57943: LD_ADDR_VAR 0 9
57947: PUSH
57948: LD_INT 25
57950: PUSH
57951: LD_INT 5
57953: PUSH
57954: LD_INT 3
57956: PUSH
57957: EMPTY
57958: LIST
57959: LIST
57960: LIST
57961: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57962: LD_VAR 0 6
57966: PPUSH
57967: CALL_OW 264
57971: PUSH
57972: LD_INT 4
57974: PUSH
57975: LD_INT 43
57977: PUSH
57978: LD_INT 25
57980: PUSH
57981: EMPTY
57982: LIST
57983: LIST
57984: LIST
57985: IN
57986: IFFALSE 58007
// points := [ 40 , 15 , 5 ] ;
57988: LD_ADDR_VAR 0 9
57992: PUSH
57993: LD_INT 40
57995: PUSH
57996: LD_INT 15
57998: PUSH
57999: LD_INT 5
58001: PUSH
58002: EMPTY
58003: LIST
58004: LIST
58005: LIST
58006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58007: LD_VAR 0 6
58011: PPUSH
58012: CALL_OW 264
58016: PUSH
58017: LD_INT 3
58019: PUSH
58020: LD_INT 23
58022: PUSH
58023: EMPTY
58024: LIST
58025: LIST
58026: IN
58027: IFFALSE 58048
// points := [ 7 , 25 , 8 ] ;
58029: LD_ADDR_VAR 0 9
58033: PUSH
58034: LD_INT 7
58036: PUSH
58037: LD_INT 25
58039: PUSH
58040: LD_INT 8
58042: PUSH
58043: EMPTY
58044: LIST
58045: LIST
58046: LIST
58047: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58048: LD_VAR 0 6
58052: PPUSH
58053: CALL_OW 264
58057: PUSH
58058: LD_INT 5
58060: PUSH
58061: LD_INT 27
58063: PUSH
58064: LD_INT 44
58066: PUSH
58067: EMPTY
58068: LIST
58069: LIST
58070: LIST
58071: IN
58072: IFFALSE 58093
// points := [ 14 , 50 , 16 ] ;
58074: LD_ADDR_VAR 0 9
58078: PUSH
58079: LD_INT 14
58081: PUSH
58082: LD_INT 50
58084: PUSH
58085: LD_INT 16
58087: PUSH
58088: EMPTY
58089: LIST
58090: LIST
58091: LIST
58092: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58093: LD_VAR 0 6
58097: PPUSH
58098: CALL_OW 264
58102: PUSH
58103: LD_INT 6
58105: PUSH
58106: LD_INT 46
58108: PUSH
58109: EMPTY
58110: LIST
58111: LIST
58112: IN
58113: IFFALSE 58134
// points := [ 32 , 120 , 70 ] ;
58115: LD_ADDR_VAR 0 9
58119: PUSH
58120: LD_INT 32
58122: PUSH
58123: LD_INT 120
58125: PUSH
58126: LD_INT 70
58128: PUSH
58129: EMPTY
58130: LIST
58131: LIST
58132: LIST
58133: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
58134: LD_VAR 0 6
58138: PPUSH
58139: CALL_OW 264
58143: PUSH
58144: LD_INT 7
58146: PUSH
58147: LD_INT 28
58149: PUSH
58150: LD_INT 45
58152: PUSH
58153: EMPTY
58154: LIST
58155: LIST
58156: LIST
58157: IN
58158: IFFALSE 58179
// points := [ 35 , 20 , 45 ] ;
58160: LD_ADDR_VAR 0 9
58164: PUSH
58165: LD_INT 35
58167: PUSH
58168: LD_INT 20
58170: PUSH
58171: LD_INT 45
58173: PUSH
58174: EMPTY
58175: LIST
58176: LIST
58177: LIST
58178: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58179: LD_VAR 0 6
58183: PPUSH
58184: CALL_OW 264
58188: PUSH
58189: LD_INT 47
58191: PUSH
58192: EMPTY
58193: LIST
58194: IN
58195: IFFALSE 58216
// points := [ 67 , 45 , 75 ] ;
58197: LD_ADDR_VAR 0 9
58201: PUSH
58202: LD_INT 67
58204: PUSH
58205: LD_INT 45
58207: PUSH
58208: LD_INT 75
58210: PUSH
58211: EMPTY
58212: LIST
58213: LIST
58214: LIST
58215: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58216: LD_VAR 0 6
58220: PPUSH
58221: CALL_OW 264
58225: PUSH
58226: LD_INT 26
58228: PUSH
58229: EMPTY
58230: LIST
58231: IN
58232: IFFALSE 58253
// points := [ 120 , 30 , 80 ] ;
58234: LD_ADDR_VAR 0 9
58238: PUSH
58239: LD_INT 120
58241: PUSH
58242: LD_INT 30
58244: PUSH
58245: LD_INT 80
58247: PUSH
58248: EMPTY
58249: LIST
58250: LIST
58251: LIST
58252: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58253: LD_VAR 0 6
58257: PPUSH
58258: CALL_OW 264
58262: PUSH
58263: LD_INT 22
58265: PUSH
58266: EMPTY
58267: LIST
58268: IN
58269: IFFALSE 58290
// points := [ 40 , 1 , 1 ] ;
58271: LD_ADDR_VAR 0 9
58275: PUSH
58276: LD_INT 40
58278: PUSH
58279: LD_INT 1
58281: PUSH
58282: LD_INT 1
58284: PUSH
58285: EMPTY
58286: LIST
58287: LIST
58288: LIST
58289: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
58290: LD_VAR 0 6
58294: PPUSH
58295: CALL_OW 264
58299: PUSH
58300: LD_INT 29
58302: PUSH
58303: EMPTY
58304: LIST
58305: IN
58306: IFFALSE 58327
// points := [ 70 , 200 , 400 ] ;
58308: LD_ADDR_VAR 0 9
58312: PUSH
58313: LD_INT 70
58315: PUSH
58316: LD_INT 200
58318: PUSH
58319: LD_INT 400
58321: PUSH
58322: EMPTY
58323: LIST
58324: LIST
58325: LIST
58326: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
58327: LD_VAR 0 6
58331: PPUSH
58332: CALL_OW 264
58336: PUSH
58337: LD_INT 14
58339: PUSH
58340: LD_INT 53
58342: PUSH
58343: EMPTY
58344: LIST
58345: LIST
58346: IN
58347: IFFALSE 58368
// points := [ 40 , 10 , 20 ] ;
58349: LD_ADDR_VAR 0 9
58353: PUSH
58354: LD_INT 40
58356: PUSH
58357: LD_INT 10
58359: PUSH
58360: LD_INT 20
58362: PUSH
58363: EMPTY
58364: LIST
58365: LIST
58366: LIST
58367: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
58368: LD_VAR 0 6
58372: PPUSH
58373: CALL_OW 264
58377: PUSH
58378: LD_INT 9
58380: PUSH
58381: EMPTY
58382: LIST
58383: IN
58384: IFFALSE 58405
// points := [ 5 , 70 , 20 ] ;
58386: LD_ADDR_VAR 0 9
58390: PUSH
58391: LD_INT 5
58393: PUSH
58394: LD_INT 70
58396: PUSH
58397: LD_INT 20
58399: PUSH
58400: EMPTY
58401: LIST
58402: LIST
58403: LIST
58404: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
58405: LD_VAR 0 6
58409: PPUSH
58410: CALL_OW 264
58414: PUSH
58415: LD_INT 10
58417: PUSH
58418: EMPTY
58419: LIST
58420: IN
58421: IFFALSE 58442
// points := [ 35 , 110 , 70 ] ;
58423: LD_ADDR_VAR 0 9
58427: PUSH
58428: LD_INT 35
58430: PUSH
58431: LD_INT 110
58433: PUSH
58434: LD_INT 70
58436: PUSH
58437: EMPTY
58438: LIST
58439: LIST
58440: LIST
58441: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58442: LD_VAR 0 6
58446: PPUSH
58447: CALL_OW 265
58451: PUSH
58452: LD_INT 25
58454: EQUAL
58455: IFFALSE 58476
// points := [ 80 , 65 , 100 ] ;
58457: LD_ADDR_VAR 0 9
58461: PUSH
58462: LD_INT 80
58464: PUSH
58465: LD_INT 65
58467: PUSH
58468: LD_INT 100
58470: PUSH
58471: EMPTY
58472: LIST
58473: LIST
58474: LIST
58475: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58476: LD_VAR 0 6
58480: PPUSH
58481: CALL_OW 263
58485: PUSH
58486: LD_INT 1
58488: EQUAL
58489: IFFALSE 58524
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58491: LD_ADDR_VAR 0 10
58495: PUSH
58496: LD_VAR 0 10
58500: PUSH
58501: LD_VAR 0 6
58505: PPUSH
58506: CALL_OW 311
58510: PPUSH
58511: LD_INT 3
58513: PPUSH
58514: CALL_OW 259
58518: PUSH
58519: LD_INT 4
58521: MUL
58522: MUL
58523: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58524: LD_VAR 0 6
58528: PPUSH
58529: CALL_OW 263
58533: PUSH
58534: LD_INT 2
58536: EQUAL
58537: IFFALSE 58588
// begin j := IsControledBy ( i ) ;
58539: LD_ADDR_VAR 0 7
58543: PUSH
58544: LD_VAR 0 6
58548: PPUSH
58549: CALL_OW 312
58553: ST_TO_ADDR
// if j then
58554: LD_VAR 0 7
58558: IFFALSE 58588
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58560: LD_ADDR_VAR 0 10
58564: PUSH
58565: LD_VAR 0 10
58569: PUSH
58570: LD_VAR 0 7
58574: PPUSH
58575: LD_INT 3
58577: PPUSH
58578: CALL_OW 259
58582: PUSH
58583: LD_INT 3
58585: MUL
58586: MUL
58587: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58588: LD_VAR 0 6
58592: PPUSH
58593: CALL_OW 264
58597: PUSH
58598: LD_INT 5
58600: PUSH
58601: LD_INT 6
58603: PUSH
58604: LD_INT 46
58606: PUSH
58607: LD_INT 44
58609: PUSH
58610: LD_INT 47
58612: PUSH
58613: LD_INT 45
58615: PUSH
58616: LD_INT 28
58618: PUSH
58619: LD_INT 7
58621: PUSH
58622: LD_INT 27
58624: PUSH
58625: LD_INT 29
58627: PUSH
58628: EMPTY
58629: LIST
58630: LIST
58631: LIST
58632: LIST
58633: LIST
58634: LIST
58635: LIST
58636: LIST
58637: LIST
58638: LIST
58639: IN
58640: PUSH
58641: LD_VAR 0 1
58645: PPUSH
58646: LD_INT 52
58648: PPUSH
58649: CALL_OW 321
58653: PUSH
58654: LD_INT 2
58656: EQUAL
58657: AND
58658: IFFALSE 58675
// bpoints := bpoints * 1.2 ;
58660: LD_ADDR_VAR 0 10
58664: PUSH
58665: LD_VAR 0 10
58669: PUSH
58670: LD_REAL  1.20000000000000E+0000
58673: MUL
58674: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58675: LD_VAR 0 6
58679: PPUSH
58680: CALL_OW 264
58684: PUSH
58685: LD_INT 6
58687: PUSH
58688: LD_INT 46
58690: PUSH
58691: LD_INT 47
58693: PUSH
58694: EMPTY
58695: LIST
58696: LIST
58697: LIST
58698: IN
58699: IFFALSE 58716
// bpoints := bpoints * 1.2 ;
58701: LD_ADDR_VAR 0 10
58705: PUSH
58706: LD_VAR 0 10
58710: PUSH
58711: LD_REAL  1.20000000000000E+0000
58714: MUL
58715: ST_TO_ADDR
// end ; unit_building :
58716: GO 58730
58718: LD_INT 3
58720: DOUBLE
58721: EQUAL
58722: IFTRUE 58726
58724: GO 58729
58726: POP
// ; end ;
58727: GO 58730
58729: POP
// for j = 1 to 3 do
58730: LD_ADDR_VAR 0 7
58734: PUSH
58735: DOUBLE
58736: LD_INT 1
58738: DEC
58739: ST_TO_ADDR
58740: LD_INT 3
58742: PUSH
58743: FOR_TO
58744: IFFALSE 58797
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58746: LD_ADDR_VAR 0 5
58750: PUSH
58751: LD_VAR 0 5
58755: PPUSH
58756: LD_VAR 0 7
58760: PPUSH
58761: LD_VAR 0 5
58765: PUSH
58766: LD_VAR 0 7
58770: ARRAY
58771: PUSH
58772: LD_VAR 0 9
58776: PUSH
58777: LD_VAR 0 7
58781: ARRAY
58782: PUSH
58783: LD_VAR 0 10
58787: MUL
58788: PLUS
58789: PPUSH
58790: CALL_OW 1
58794: ST_TO_ADDR
58795: GO 58743
58797: POP
58798: POP
// end ;
58799: GO 57282
58801: POP
58802: POP
// result := Replace ( result , 4 , tmp ) ;
58803: LD_ADDR_VAR 0 5
58807: PUSH
58808: LD_VAR 0 5
58812: PPUSH
58813: LD_INT 4
58815: PPUSH
58816: LD_VAR 0 8
58820: PPUSH
58821: CALL_OW 1
58825: ST_TO_ADDR
// end ;
58826: LD_VAR 0 5
58830: RET
// export function DangerAtRange ( unit , range ) ; begin
58831: LD_INT 0
58833: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58834: LD_ADDR_VAR 0 3
58838: PUSH
58839: LD_VAR 0 1
58843: PPUSH
58844: CALL_OW 255
58848: PPUSH
58849: LD_VAR 0 1
58853: PPUSH
58854: CALL_OW 250
58858: PPUSH
58859: LD_VAR 0 1
58863: PPUSH
58864: CALL_OW 251
58868: PPUSH
58869: LD_VAR 0 2
58873: PPUSH
58874: CALL 57134 0 4
58878: ST_TO_ADDR
// end ;
58879: LD_VAR 0 3
58883: RET
// export function DangerInArea ( side , area ) ; begin
58884: LD_INT 0
58886: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58887: LD_ADDR_VAR 0 3
58891: PUSH
58892: LD_VAR 0 2
58896: PPUSH
58897: LD_INT 81
58899: PUSH
58900: LD_VAR 0 1
58904: PUSH
58905: EMPTY
58906: LIST
58907: LIST
58908: PPUSH
58909: CALL_OW 70
58913: ST_TO_ADDR
// end ;
58914: LD_VAR 0 3
58918: RET
// export function IsExtension ( b ) ; begin
58919: LD_INT 0
58921: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58922: LD_ADDR_VAR 0 2
58926: PUSH
58927: LD_VAR 0 1
58931: PUSH
58932: LD_INT 23
58934: PUSH
58935: LD_INT 20
58937: PUSH
58938: LD_INT 22
58940: PUSH
58941: LD_INT 17
58943: PUSH
58944: LD_INT 24
58946: PUSH
58947: LD_INT 21
58949: PUSH
58950: LD_INT 19
58952: PUSH
58953: LD_INT 16
58955: PUSH
58956: LD_INT 25
58958: PUSH
58959: LD_INT 18
58961: PUSH
58962: EMPTY
58963: LIST
58964: LIST
58965: LIST
58966: LIST
58967: LIST
58968: LIST
58969: LIST
58970: LIST
58971: LIST
58972: LIST
58973: IN
58974: ST_TO_ADDR
// end ;
58975: LD_VAR 0 2
58979: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
58980: LD_INT 0
58982: PPUSH
58983: PPUSH
58984: PPUSH
// result := [ ] ;
58985: LD_ADDR_VAR 0 3
58989: PUSH
58990: EMPTY
58991: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58992: LD_ADDR_VAR 0 4
58996: PUSH
58997: LD_VAR 0 2
59001: PPUSH
59002: LD_INT 21
59004: PUSH
59005: LD_INT 3
59007: PUSH
59008: EMPTY
59009: LIST
59010: LIST
59011: PPUSH
59012: CALL_OW 70
59016: ST_TO_ADDR
// if not tmp then
59017: LD_VAR 0 4
59021: NOT
59022: IFFALSE 59026
// exit ;
59024: GO 59084
// for i in tmp do
59026: LD_ADDR_VAR 0 5
59030: PUSH
59031: LD_VAR 0 4
59035: PUSH
59036: FOR_IN
59037: IFFALSE 59072
// if GetBase ( i ) <> base then
59039: LD_VAR 0 5
59043: PPUSH
59044: CALL_OW 274
59048: PUSH
59049: LD_VAR 0 1
59053: NONEQUAL
59054: IFFALSE 59070
// ComLinkToBase ( base , i ) ;
59056: LD_VAR 0 1
59060: PPUSH
59061: LD_VAR 0 5
59065: PPUSH
59066: CALL_OW 169
59070: GO 59036
59072: POP
59073: POP
// result := tmp ;
59074: LD_ADDR_VAR 0 3
59078: PUSH
59079: LD_VAR 0 4
59083: ST_TO_ADDR
// end ;
59084: LD_VAR 0 3
59088: RET
// export function ComComplete ( unit , b ) ; var i ; begin
59089: LD_INT 0
59091: PPUSH
59092: PPUSH
// if BuildingStatus ( b ) = bs_build then
59093: LD_VAR 0 2
59097: PPUSH
59098: CALL_OW 461
59102: PUSH
59103: LD_INT 1
59105: EQUAL
59106: IFFALSE 59166
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59108: LD_VAR 0 1
59112: PPUSH
59113: LD_STRING h
59115: PUSH
59116: LD_VAR 0 2
59120: PPUSH
59121: CALL_OW 250
59125: PUSH
59126: LD_VAR 0 2
59130: PPUSH
59131: CALL_OW 251
59135: PUSH
59136: LD_VAR 0 2
59140: PUSH
59141: LD_INT 0
59143: PUSH
59144: LD_INT 0
59146: PUSH
59147: LD_INT 0
59149: PUSH
59150: EMPTY
59151: LIST
59152: LIST
59153: LIST
59154: LIST
59155: LIST
59156: LIST
59157: LIST
59158: PUSH
59159: EMPTY
59160: LIST
59161: PPUSH
59162: CALL_OW 446
// end ;
59166: LD_VAR 0 3
59170: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59171: LD_INT 0
59173: PPUSH
59174: PPUSH
59175: PPUSH
59176: PPUSH
59177: PPUSH
59178: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
59179: LD_VAR 0 1
59183: NOT
59184: PUSH
59185: LD_VAR 0 1
59189: PPUSH
59190: CALL_OW 263
59194: PUSH
59195: LD_INT 2
59197: EQUAL
59198: NOT
59199: OR
59200: IFFALSE 59204
// exit ;
59202: GO 59520
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59204: LD_ADDR_VAR 0 6
59208: PUSH
59209: LD_INT 22
59211: PUSH
59212: LD_VAR 0 1
59216: PPUSH
59217: CALL_OW 255
59221: PUSH
59222: EMPTY
59223: LIST
59224: LIST
59225: PUSH
59226: LD_INT 2
59228: PUSH
59229: LD_INT 30
59231: PUSH
59232: LD_INT 36
59234: PUSH
59235: EMPTY
59236: LIST
59237: LIST
59238: PUSH
59239: LD_INT 34
59241: PUSH
59242: LD_INT 31
59244: PUSH
59245: EMPTY
59246: LIST
59247: LIST
59248: PUSH
59249: EMPTY
59250: LIST
59251: LIST
59252: LIST
59253: PUSH
59254: EMPTY
59255: LIST
59256: LIST
59257: PPUSH
59258: CALL_OW 69
59262: ST_TO_ADDR
// if not tmp then
59263: LD_VAR 0 6
59267: NOT
59268: IFFALSE 59272
// exit ;
59270: GO 59520
// result := [ ] ;
59272: LD_ADDR_VAR 0 2
59276: PUSH
59277: EMPTY
59278: ST_TO_ADDR
// for i in tmp do
59279: LD_ADDR_VAR 0 3
59283: PUSH
59284: LD_VAR 0 6
59288: PUSH
59289: FOR_IN
59290: IFFALSE 59361
// begin t := UnitsInside ( i ) ;
59292: LD_ADDR_VAR 0 4
59296: PUSH
59297: LD_VAR 0 3
59301: PPUSH
59302: CALL_OW 313
59306: ST_TO_ADDR
// if t then
59307: LD_VAR 0 4
59311: IFFALSE 59359
// for j in t do
59313: LD_ADDR_VAR 0 7
59317: PUSH
59318: LD_VAR 0 4
59322: PUSH
59323: FOR_IN
59324: IFFALSE 59357
// result := Insert ( result , result + 1 , j ) ;
59326: LD_ADDR_VAR 0 2
59330: PUSH
59331: LD_VAR 0 2
59335: PPUSH
59336: LD_VAR 0 2
59340: PUSH
59341: LD_INT 1
59343: PLUS
59344: PPUSH
59345: LD_VAR 0 7
59349: PPUSH
59350: CALL_OW 2
59354: ST_TO_ADDR
59355: GO 59323
59357: POP
59358: POP
// end ;
59359: GO 59289
59361: POP
59362: POP
// if not result then
59363: LD_VAR 0 2
59367: NOT
59368: IFFALSE 59372
// exit ;
59370: GO 59520
// mech := result [ 1 ] ;
59372: LD_ADDR_VAR 0 5
59376: PUSH
59377: LD_VAR 0 2
59381: PUSH
59382: LD_INT 1
59384: ARRAY
59385: ST_TO_ADDR
// if result > 1 then
59386: LD_VAR 0 2
59390: PUSH
59391: LD_INT 1
59393: GREATER
59394: IFFALSE 59506
// for i = 2 to result do
59396: LD_ADDR_VAR 0 3
59400: PUSH
59401: DOUBLE
59402: LD_INT 2
59404: DEC
59405: ST_TO_ADDR
59406: LD_VAR 0 2
59410: PUSH
59411: FOR_TO
59412: IFFALSE 59504
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
59414: LD_ADDR_VAR 0 4
59418: PUSH
59419: LD_VAR 0 2
59423: PUSH
59424: LD_VAR 0 3
59428: ARRAY
59429: PPUSH
59430: LD_INT 3
59432: PPUSH
59433: CALL_OW 259
59437: PUSH
59438: LD_VAR 0 2
59442: PUSH
59443: LD_VAR 0 3
59447: ARRAY
59448: PPUSH
59449: CALL_OW 432
59453: MINUS
59454: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59455: LD_VAR 0 4
59459: PUSH
59460: LD_VAR 0 5
59464: PPUSH
59465: LD_INT 3
59467: PPUSH
59468: CALL_OW 259
59472: PUSH
59473: LD_VAR 0 5
59477: PPUSH
59478: CALL_OW 432
59482: MINUS
59483: GREATEREQUAL
59484: IFFALSE 59502
// mech := result [ i ] ;
59486: LD_ADDR_VAR 0 5
59490: PUSH
59491: LD_VAR 0 2
59495: PUSH
59496: LD_VAR 0 3
59500: ARRAY
59501: ST_TO_ADDR
// end ;
59502: GO 59411
59504: POP
59505: POP
// ComLinkTo ( vehicle , mech ) ;
59506: LD_VAR 0 1
59510: PPUSH
59511: LD_VAR 0 5
59515: PPUSH
59516: CALL_OW 135
// end ;
59520: LD_VAR 0 2
59524: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59525: LD_INT 0
59527: PPUSH
59528: PPUSH
59529: PPUSH
59530: PPUSH
59531: PPUSH
59532: PPUSH
59533: PPUSH
59534: PPUSH
59535: PPUSH
59536: PPUSH
59537: PPUSH
59538: PPUSH
59539: PPUSH
// result := [ ] ;
59540: LD_ADDR_VAR 0 7
59544: PUSH
59545: EMPTY
59546: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59547: LD_VAR 0 1
59551: PPUSH
59552: CALL_OW 266
59556: PUSH
59557: LD_INT 0
59559: PUSH
59560: LD_INT 1
59562: PUSH
59563: EMPTY
59564: LIST
59565: LIST
59566: IN
59567: NOT
59568: IFFALSE 59572
// exit ;
59570: GO 61203
// if name then
59572: LD_VAR 0 3
59576: IFFALSE 59592
// SetBName ( base_dep , name ) ;
59578: LD_VAR 0 1
59582: PPUSH
59583: LD_VAR 0 3
59587: PPUSH
59588: CALL_OW 500
// base := GetBase ( base_dep ) ;
59592: LD_ADDR_VAR 0 15
59596: PUSH
59597: LD_VAR 0 1
59601: PPUSH
59602: CALL_OW 274
59606: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59607: LD_ADDR_VAR 0 16
59611: PUSH
59612: LD_VAR 0 1
59616: PPUSH
59617: CALL_OW 255
59621: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59622: LD_ADDR_VAR 0 17
59626: PUSH
59627: LD_VAR 0 1
59631: PPUSH
59632: CALL_OW 248
59636: ST_TO_ADDR
// if sources then
59637: LD_VAR 0 5
59641: IFFALSE 59688
// for i = 1 to 3 do
59643: LD_ADDR_VAR 0 8
59647: PUSH
59648: DOUBLE
59649: LD_INT 1
59651: DEC
59652: ST_TO_ADDR
59653: LD_INT 3
59655: PUSH
59656: FOR_TO
59657: IFFALSE 59686
// AddResourceType ( base , i , sources [ i ] ) ;
59659: LD_VAR 0 15
59663: PPUSH
59664: LD_VAR 0 8
59668: PPUSH
59669: LD_VAR 0 5
59673: PUSH
59674: LD_VAR 0 8
59678: ARRAY
59679: PPUSH
59680: CALL_OW 276
59684: GO 59656
59686: POP
59687: POP
// buildings := GetBaseBuildings ( base , area ) ;
59688: LD_ADDR_VAR 0 18
59692: PUSH
59693: LD_VAR 0 15
59697: PPUSH
59698: LD_VAR 0 2
59702: PPUSH
59703: CALL 58980 0 2
59707: ST_TO_ADDR
// InitHc ;
59708: CALL_OW 19
// InitUc ;
59712: CALL_OW 18
// uc_side := side ;
59716: LD_ADDR_OWVAR 20
59720: PUSH
59721: LD_VAR 0 16
59725: ST_TO_ADDR
// uc_nation := nation ;
59726: LD_ADDR_OWVAR 21
59730: PUSH
59731: LD_VAR 0 17
59735: ST_TO_ADDR
// if buildings then
59736: LD_VAR 0 18
59740: IFFALSE 61062
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59742: LD_ADDR_VAR 0 19
59746: PUSH
59747: LD_VAR 0 18
59751: PPUSH
59752: LD_INT 2
59754: PUSH
59755: LD_INT 30
59757: PUSH
59758: LD_INT 29
59760: PUSH
59761: EMPTY
59762: LIST
59763: LIST
59764: PUSH
59765: LD_INT 30
59767: PUSH
59768: LD_INT 30
59770: PUSH
59771: EMPTY
59772: LIST
59773: LIST
59774: PUSH
59775: EMPTY
59776: LIST
59777: LIST
59778: LIST
59779: PPUSH
59780: CALL_OW 72
59784: ST_TO_ADDR
// if tmp then
59785: LD_VAR 0 19
59789: IFFALSE 59837
// for i in tmp do
59791: LD_ADDR_VAR 0 8
59795: PUSH
59796: LD_VAR 0 19
59800: PUSH
59801: FOR_IN
59802: IFFALSE 59835
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59804: LD_VAR 0 8
59808: PPUSH
59809: CALL_OW 250
59813: PPUSH
59814: LD_VAR 0 8
59818: PPUSH
59819: CALL_OW 251
59823: PPUSH
59824: LD_VAR 0 16
59828: PPUSH
59829: CALL_OW 441
59833: GO 59801
59835: POP
59836: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59837: LD_VAR 0 18
59841: PPUSH
59842: LD_INT 2
59844: PUSH
59845: LD_INT 30
59847: PUSH
59848: LD_INT 32
59850: PUSH
59851: EMPTY
59852: LIST
59853: LIST
59854: PUSH
59855: LD_INT 30
59857: PUSH
59858: LD_INT 33
59860: PUSH
59861: EMPTY
59862: LIST
59863: LIST
59864: PUSH
59865: EMPTY
59866: LIST
59867: LIST
59868: LIST
59869: PPUSH
59870: CALL_OW 72
59874: IFFALSE 59962
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59876: LD_ADDR_VAR 0 8
59880: PUSH
59881: LD_VAR 0 18
59885: PPUSH
59886: LD_INT 2
59888: PUSH
59889: LD_INT 30
59891: PUSH
59892: LD_INT 32
59894: PUSH
59895: EMPTY
59896: LIST
59897: LIST
59898: PUSH
59899: LD_INT 30
59901: PUSH
59902: LD_INT 33
59904: PUSH
59905: EMPTY
59906: LIST
59907: LIST
59908: PUSH
59909: EMPTY
59910: LIST
59911: LIST
59912: LIST
59913: PPUSH
59914: CALL_OW 72
59918: PUSH
59919: FOR_IN
59920: IFFALSE 59960
// begin if not GetBWeapon ( i ) then
59922: LD_VAR 0 8
59926: PPUSH
59927: CALL_OW 269
59931: NOT
59932: IFFALSE 59958
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59934: LD_VAR 0 8
59938: PPUSH
59939: LD_VAR 0 8
59943: PPUSH
59944: LD_VAR 0 2
59948: PPUSH
59949: CALL 61208 0 2
59953: PPUSH
59954: CALL_OW 431
// end ;
59958: GO 59919
59960: POP
59961: POP
// end ; for i = 1 to personel do
59962: LD_ADDR_VAR 0 8
59966: PUSH
59967: DOUBLE
59968: LD_INT 1
59970: DEC
59971: ST_TO_ADDR
59972: LD_VAR 0 6
59976: PUSH
59977: FOR_TO
59978: IFFALSE 61042
// begin if i > 4 then
59980: LD_VAR 0 8
59984: PUSH
59985: LD_INT 4
59987: GREATER
59988: IFFALSE 59992
// break ;
59990: GO 61042
// case i of 1 :
59992: LD_VAR 0 8
59996: PUSH
59997: LD_INT 1
59999: DOUBLE
60000: EQUAL
60001: IFTRUE 60005
60003: GO 60085
60005: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60006: LD_ADDR_VAR 0 12
60010: PUSH
60011: LD_VAR 0 18
60015: PPUSH
60016: LD_INT 22
60018: PUSH
60019: LD_VAR 0 16
60023: PUSH
60024: EMPTY
60025: LIST
60026: LIST
60027: PUSH
60028: LD_INT 58
60030: PUSH
60031: EMPTY
60032: LIST
60033: PUSH
60034: LD_INT 2
60036: PUSH
60037: LD_INT 30
60039: PUSH
60040: LD_INT 32
60042: PUSH
60043: EMPTY
60044: LIST
60045: LIST
60046: PUSH
60047: LD_INT 30
60049: PUSH
60050: LD_INT 4
60052: PUSH
60053: EMPTY
60054: LIST
60055: LIST
60056: PUSH
60057: LD_INT 30
60059: PUSH
60060: LD_INT 5
60062: PUSH
60063: EMPTY
60064: LIST
60065: LIST
60066: PUSH
60067: EMPTY
60068: LIST
60069: LIST
60070: LIST
60071: LIST
60072: PUSH
60073: EMPTY
60074: LIST
60075: LIST
60076: LIST
60077: PPUSH
60078: CALL_OW 72
60082: ST_TO_ADDR
60083: GO 60307
60085: LD_INT 2
60087: DOUBLE
60088: EQUAL
60089: IFTRUE 60093
60091: GO 60155
60093: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60094: LD_ADDR_VAR 0 12
60098: PUSH
60099: LD_VAR 0 18
60103: PPUSH
60104: LD_INT 22
60106: PUSH
60107: LD_VAR 0 16
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: PUSH
60116: LD_INT 2
60118: PUSH
60119: LD_INT 30
60121: PUSH
60122: LD_INT 0
60124: PUSH
60125: EMPTY
60126: LIST
60127: LIST
60128: PUSH
60129: LD_INT 30
60131: PUSH
60132: LD_INT 1
60134: PUSH
60135: EMPTY
60136: LIST
60137: LIST
60138: PUSH
60139: EMPTY
60140: LIST
60141: LIST
60142: LIST
60143: PUSH
60144: EMPTY
60145: LIST
60146: LIST
60147: PPUSH
60148: CALL_OW 72
60152: ST_TO_ADDR
60153: GO 60307
60155: LD_INT 3
60157: DOUBLE
60158: EQUAL
60159: IFTRUE 60163
60161: GO 60225
60163: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60164: LD_ADDR_VAR 0 12
60168: PUSH
60169: LD_VAR 0 18
60173: PPUSH
60174: LD_INT 22
60176: PUSH
60177: LD_VAR 0 16
60181: PUSH
60182: EMPTY
60183: LIST
60184: LIST
60185: PUSH
60186: LD_INT 2
60188: PUSH
60189: LD_INT 30
60191: PUSH
60192: LD_INT 2
60194: PUSH
60195: EMPTY
60196: LIST
60197: LIST
60198: PUSH
60199: LD_INT 30
60201: PUSH
60202: LD_INT 3
60204: PUSH
60205: EMPTY
60206: LIST
60207: LIST
60208: PUSH
60209: EMPTY
60210: LIST
60211: LIST
60212: LIST
60213: PUSH
60214: EMPTY
60215: LIST
60216: LIST
60217: PPUSH
60218: CALL_OW 72
60222: ST_TO_ADDR
60223: GO 60307
60225: LD_INT 4
60227: DOUBLE
60228: EQUAL
60229: IFTRUE 60233
60231: GO 60306
60233: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60234: LD_ADDR_VAR 0 12
60238: PUSH
60239: LD_VAR 0 18
60243: PPUSH
60244: LD_INT 22
60246: PUSH
60247: LD_VAR 0 16
60251: PUSH
60252: EMPTY
60253: LIST
60254: LIST
60255: PUSH
60256: LD_INT 2
60258: PUSH
60259: LD_INT 30
60261: PUSH
60262: LD_INT 6
60264: PUSH
60265: EMPTY
60266: LIST
60267: LIST
60268: PUSH
60269: LD_INT 30
60271: PUSH
60272: LD_INT 7
60274: PUSH
60275: EMPTY
60276: LIST
60277: LIST
60278: PUSH
60279: LD_INT 30
60281: PUSH
60282: LD_INT 8
60284: PUSH
60285: EMPTY
60286: LIST
60287: LIST
60288: PUSH
60289: EMPTY
60290: LIST
60291: LIST
60292: LIST
60293: LIST
60294: PUSH
60295: EMPTY
60296: LIST
60297: LIST
60298: PPUSH
60299: CALL_OW 72
60303: ST_TO_ADDR
60304: GO 60307
60306: POP
// if i = 1 then
60307: LD_VAR 0 8
60311: PUSH
60312: LD_INT 1
60314: EQUAL
60315: IFFALSE 60426
// begin tmp := [ ] ;
60317: LD_ADDR_VAR 0 19
60321: PUSH
60322: EMPTY
60323: ST_TO_ADDR
// for j in f do
60324: LD_ADDR_VAR 0 9
60328: PUSH
60329: LD_VAR 0 12
60333: PUSH
60334: FOR_IN
60335: IFFALSE 60408
// if GetBType ( j ) = b_bunker then
60337: LD_VAR 0 9
60341: PPUSH
60342: CALL_OW 266
60346: PUSH
60347: LD_INT 32
60349: EQUAL
60350: IFFALSE 60377
// tmp := Insert ( tmp , 1 , j ) else
60352: LD_ADDR_VAR 0 19
60356: PUSH
60357: LD_VAR 0 19
60361: PPUSH
60362: LD_INT 1
60364: PPUSH
60365: LD_VAR 0 9
60369: PPUSH
60370: CALL_OW 2
60374: ST_TO_ADDR
60375: GO 60406
// tmp := Insert ( tmp , tmp + 1 , j ) ;
60377: LD_ADDR_VAR 0 19
60381: PUSH
60382: LD_VAR 0 19
60386: PPUSH
60387: LD_VAR 0 19
60391: PUSH
60392: LD_INT 1
60394: PLUS
60395: PPUSH
60396: LD_VAR 0 9
60400: PPUSH
60401: CALL_OW 2
60405: ST_TO_ADDR
60406: GO 60334
60408: POP
60409: POP
// if tmp then
60410: LD_VAR 0 19
60414: IFFALSE 60426
// f := tmp ;
60416: LD_ADDR_VAR 0 12
60420: PUSH
60421: LD_VAR 0 19
60425: ST_TO_ADDR
// end ; x := personel [ i ] ;
60426: LD_ADDR_VAR 0 13
60430: PUSH
60431: LD_VAR 0 6
60435: PUSH
60436: LD_VAR 0 8
60440: ARRAY
60441: ST_TO_ADDR
// if x = - 1 then
60442: LD_VAR 0 13
60446: PUSH
60447: LD_INT 1
60449: NEG
60450: EQUAL
60451: IFFALSE 60660
// begin for j in f do
60453: LD_ADDR_VAR 0 9
60457: PUSH
60458: LD_VAR 0 12
60462: PUSH
60463: FOR_IN
60464: IFFALSE 60656
// repeat InitHc ;
60466: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60470: LD_VAR 0 9
60474: PPUSH
60475: CALL_OW 266
60479: PUSH
60480: LD_INT 5
60482: EQUAL
60483: IFFALSE 60553
// begin if UnitsInside ( j ) < 3 then
60485: LD_VAR 0 9
60489: PPUSH
60490: CALL_OW 313
60494: PUSH
60495: LD_INT 3
60497: LESS
60498: IFFALSE 60534
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60500: LD_INT 0
60502: PPUSH
60503: LD_INT 5
60505: PUSH
60506: LD_INT 8
60508: PUSH
60509: LD_INT 9
60511: PUSH
60512: EMPTY
60513: LIST
60514: LIST
60515: LIST
60516: PUSH
60517: LD_VAR 0 17
60521: ARRAY
60522: PPUSH
60523: LD_VAR 0 4
60527: PPUSH
60528: CALL_OW 380
60532: GO 60551
// PrepareHuman ( false , i , skill ) ;
60534: LD_INT 0
60536: PPUSH
60537: LD_VAR 0 8
60541: PPUSH
60542: LD_VAR 0 4
60546: PPUSH
60547: CALL_OW 380
// end else
60551: GO 60570
// PrepareHuman ( false , i , skill ) ;
60553: LD_INT 0
60555: PPUSH
60556: LD_VAR 0 8
60560: PPUSH
60561: LD_VAR 0 4
60565: PPUSH
60566: CALL_OW 380
// un := CreateHuman ;
60570: LD_ADDR_VAR 0 14
60574: PUSH
60575: CALL_OW 44
60579: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60580: LD_ADDR_VAR 0 7
60584: PUSH
60585: LD_VAR 0 7
60589: PPUSH
60590: LD_INT 1
60592: PPUSH
60593: LD_VAR 0 14
60597: PPUSH
60598: CALL_OW 2
60602: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60603: LD_VAR 0 14
60607: PPUSH
60608: LD_VAR 0 9
60612: PPUSH
60613: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60617: LD_VAR 0 9
60621: PPUSH
60622: CALL_OW 313
60626: PUSH
60627: LD_INT 6
60629: EQUAL
60630: PUSH
60631: LD_VAR 0 9
60635: PPUSH
60636: CALL_OW 266
60640: PUSH
60641: LD_INT 32
60643: PUSH
60644: LD_INT 31
60646: PUSH
60647: EMPTY
60648: LIST
60649: LIST
60650: IN
60651: OR
60652: IFFALSE 60466
60654: GO 60463
60656: POP
60657: POP
// end else
60658: GO 61040
// for j = 1 to x do
60660: LD_ADDR_VAR 0 9
60664: PUSH
60665: DOUBLE
60666: LD_INT 1
60668: DEC
60669: ST_TO_ADDR
60670: LD_VAR 0 13
60674: PUSH
60675: FOR_TO
60676: IFFALSE 61038
// begin InitHc ;
60678: CALL_OW 19
// if not f then
60682: LD_VAR 0 12
60686: NOT
60687: IFFALSE 60776
// begin PrepareHuman ( false , i , skill ) ;
60689: LD_INT 0
60691: PPUSH
60692: LD_VAR 0 8
60696: PPUSH
60697: LD_VAR 0 4
60701: PPUSH
60702: CALL_OW 380
// un := CreateHuman ;
60706: LD_ADDR_VAR 0 14
60710: PUSH
60711: CALL_OW 44
60715: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60716: LD_ADDR_VAR 0 7
60720: PUSH
60721: LD_VAR 0 7
60725: PPUSH
60726: LD_INT 1
60728: PPUSH
60729: LD_VAR 0 14
60733: PPUSH
60734: CALL_OW 2
60738: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60739: LD_VAR 0 14
60743: PPUSH
60744: LD_VAR 0 1
60748: PPUSH
60749: CALL_OW 250
60753: PPUSH
60754: LD_VAR 0 1
60758: PPUSH
60759: CALL_OW 251
60763: PPUSH
60764: LD_INT 10
60766: PPUSH
60767: LD_INT 0
60769: PPUSH
60770: CALL_OW 50
// continue ;
60774: GO 60675
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60776: LD_VAR 0 12
60780: PUSH
60781: LD_INT 1
60783: ARRAY
60784: PPUSH
60785: CALL_OW 313
60789: PUSH
60790: LD_VAR 0 12
60794: PUSH
60795: LD_INT 1
60797: ARRAY
60798: PPUSH
60799: CALL_OW 266
60803: PUSH
60804: LD_INT 32
60806: PUSH
60807: LD_INT 31
60809: PUSH
60810: EMPTY
60811: LIST
60812: LIST
60813: IN
60814: AND
60815: PUSH
60816: LD_VAR 0 12
60820: PUSH
60821: LD_INT 1
60823: ARRAY
60824: PPUSH
60825: CALL_OW 313
60829: PUSH
60830: LD_INT 6
60832: EQUAL
60833: OR
60834: IFFALSE 60854
// f := Delete ( f , 1 ) ;
60836: LD_ADDR_VAR 0 12
60840: PUSH
60841: LD_VAR 0 12
60845: PPUSH
60846: LD_INT 1
60848: PPUSH
60849: CALL_OW 3
60853: ST_TO_ADDR
// if not f then
60854: LD_VAR 0 12
60858: NOT
60859: IFFALSE 60877
// begin x := x + 2 ;
60861: LD_ADDR_VAR 0 13
60865: PUSH
60866: LD_VAR 0 13
60870: PUSH
60871: LD_INT 2
60873: PLUS
60874: ST_TO_ADDR
// continue ;
60875: GO 60675
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60877: LD_VAR 0 12
60881: PUSH
60882: LD_INT 1
60884: ARRAY
60885: PPUSH
60886: CALL_OW 266
60890: PUSH
60891: LD_INT 5
60893: EQUAL
60894: IFFALSE 60968
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60896: LD_VAR 0 12
60900: PUSH
60901: LD_INT 1
60903: ARRAY
60904: PPUSH
60905: CALL_OW 313
60909: PUSH
60910: LD_INT 3
60912: LESS
60913: IFFALSE 60949
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60915: LD_INT 0
60917: PPUSH
60918: LD_INT 5
60920: PUSH
60921: LD_INT 8
60923: PUSH
60924: LD_INT 9
60926: PUSH
60927: EMPTY
60928: LIST
60929: LIST
60930: LIST
60931: PUSH
60932: LD_VAR 0 17
60936: ARRAY
60937: PPUSH
60938: LD_VAR 0 4
60942: PPUSH
60943: CALL_OW 380
60947: GO 60966
// PrepareHuman ( false , i , skill ) ;
60949: LD_INT 0
60951: PPUSH
60952: LD_VAR 0 8
60956: PPUSH
60957: LD_VAR 0 4
60961: PPUSH
60962: CALL_OW 380
// end else
60966: GO 60985
// PrepareHuman ( false , i , skill ) ;
60968: LD_INT 0
60970: PPUSH
60971: LD_VAR 0 8
60975: PPUSH
60976: LD_VAR 0 4
60980: PPUSH
60981: CALL_OW 380
// un := CreateHuman ;
60985: LD_ADDR_VAR 0 14
60989: PUSH
60990: CALL_OW 44
60994: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60995: LD_ADDR_VAR 0 7
60999: PUSH
61000: LD_VAR 0 7
61004: PPUSH
61005: LD_INT 1
61007: PPUSH
61008: LD_VAR 0 14
61012: PPUSH
61013: CALL_OW 2
61017: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61018: LD_VAR 0 14
61022: PPUSH
61023: LD_VAR 0 12
61027: PUSH
61028: LD_INT 1
61030: ARRAY
61031: PPUSH
61032: CALL_OW 52
// end ;
61036: GO 60675
61038: POP
61039: POP
// end ;
61040: GO 59977
61042: POP
61043: POP
// result := result ^ buildings ;
61044: LD_ADDR_VAR 0 7
61048: PUSH
61049: LD_VAR 0 7
61053: PUSH
61054: LD_VAR 0 18
61058: ADD
61059: ST_TO_ADDR
// end else
61060: GO 61203
// begin for i = 1 to personel do
61062: LD_ADDR_VAR 0 8
61066: PUSH
61067: DOUBLE
61068: LD_INT 1
61070: DEC
61071: ST_TO_ADDR
61072: LD_VAR 0 6
61076: PUSH
61077: FOR_TO
61078: IFFALSE 61201
// begin if i > 4 then
61080: LD_VAR 0 8
61084: PUSH
61085: LD_INT 4
61087: GREATER
61088: IFFALSE 61092
// break ;
61090: GO 61201
// x := personel [ i ] ;
61092: LD_ADDR_VAR 0 13
61096: PUSH
61097: LD_VAR 0 6
61101: PUSH
61102: LD_VAR 0 8
61106: ARRAY
61107: ST_TO_ADDR
// if x = - 1 then
61108: LD_VAR 0 13
61112: PUSH
61113: LD_INT 1
61115: NEG
61116: EQUAL
61117: IFFALSE 61121
// continue ;
61119: GO 61077
// PrepareHuman ( false , i , skill ) ;
61121: LD_INT 0
61123: PPUSH
61124: LD_VAR 0 8
61128: PPUSH
61129: LD_VAR 0 4
61133: PPUSH
61134: CALL_OW 380
// un := CreateHuman ;
61138: LD_ADDR_VAR 0 14
61142: PUSH
61143: CALL_OW 44
61147: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61148: LD_VAR 0 14
61152: PPUSH
61153: LD_VAR 0 1
61157: PPUSH
61158: CALL_OW 250
61162: PPUSH
61163: LD_VAR 0 1
61167: PPUSH
61168: CALL_OW 251
61172: PPUSH
61173: LD_INT 10
61175: PPUSH
61176: LD_INT 0
61178: PPUSH
61179: CALL_OW 50
// result := result ^ un ;
61183: LD_ADDR_VAR 0 7
61187: PUSH
61188: LD_VAR 0 7
61192: PUSH
61193: LD_VAR 0 14
61197: ADD
61198: ST_TO_ADDR
// end ;
61199: GO 61077
61201: POP
61202: POP
// end ; end ;
61203: LD_VAR 0 7
61207: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61208: LD_INT 0
61210: PPUSH
61211: PPUSH
61212: PPUSH
61213: PPUSH
61214: PPUSH
61215: PPUSH
61216: PPUSH
61217: PPUSH
61218: PPUSH
61219: PPUSH
61220: PPUSH
61221: PPUSH
61222: PPUSH
61223: PPUSH
61224: PPUSH
61225: PPUSH
// result := false ;
61226: LD_ADDR_VAR 0 3
61230: PUSH
61231: LD_INT 0
61233: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61234: LD_VAR 0 1
61238: NOT
61239: PUSH
61240: LD_VAR 0 1
61244: PPUSH
61245: CALL_OW 266
61249: PUSH
61250: LD_INT 32
61252: PUSH
61253: LD_INT 33
61255: PUSH
61256: EMPTY
61257: LIST
61258: LIST
61259: IN
61260: NOT
61261: OR
61262: IFFALSE 61266
// exit ;
61264: GO 62402
// nat := GetNation ( tower ) ;
61266: LD_ADDR_VAR 0 12
61270: PUSH
61271: LD_VAR 0 1
61275: PPUSH
61276: CALL_OW 248
61280: ST_TO_ADDR
// side := GetSide ( tower ) ;
61281: LD_ADDR_VAR 0 16
61285: PUSH
61286: LD_VAR 0 1
61290: PPUSH
61291: CALL_OW 255
61295: ST_TO_ADDR
// x := GetX ( tower ) ;
61296: LD_ADDR_VAR 0 10
61300: PUSH
61301: LD_VAR 0 1
61305: PPUSH
61306: CALL_OW 250
61310: ST_TO_ADDR
// y := GetY ( tower ) ;
61311: LD_ADDR_VAR 0 11
61315: PUSH
61316: LD_VAR 0 1
61320: PPUSH
61321: CALL_OW 251
61325: ST_TO_ADDR
// if not x or not y then
61326: LD_VAR 0 10
61330: NOT
61331: PUSH
61332: LD_VAR 0 11
61336: NOT
61337: OR
61338: IFFALSE 61342
// exit ;
61340: GO 62402
// weapon := 0 ;
61342: LD_ADDR_VAR 0 18
61346: PUSH
61347: LD_INT 0
61349: ST_TO_ADDR
// fac_list := [ ] ;
61350: LD_ADDR_VAR 0 17
61354: PUSH
61355: EMPTY
61356: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
61357: LD_ADDR_VAR 0 6
61361: PUSH
61362: LD_VAR 0 1
61366: PPUSH
61367: CALL_OW 274
61371: PPUSH
61372: LD_VAR 0 2
61376: PPUSH
61377: CALL 58980 0 2
61381: PPUSH
61382: LD_INT 30
61384: PUSH
61385: LD_INT 3
61387: PUSH
61388: EMPTY
61389: LIST
61390: LIST
61391: PPUSH
61392: CALL_OW 72
61396: ST_TO_ADDR
// if not factories then
61397: LD_VAR 0 6
61401: NOT
61402: IFFALSE 61406
// exit ;
61404: GO 62402
// for i in factories do
61406: LD_ADDR_VAR 0 8
61410: PUSH
61411: LD_VAR 0 6
61415: PUSH
61416: FOR_IN
61417: IFFALSE 61442
// fac_list := fac_list union AvailableWeaponList ( i ) ;
61419: LD_ADDR_VAR 0 17
61423: PUSH
61424: LD_VAR 0 17
61428: PUSH
61429: LD_VAR 0 8
61433: PPUSH
61434: CALL_OW 478
61438: UNION
61439: ST_TO_ADDR
61440: GO 61416
61442: POP
61443: POP
// if not fac_list then
61444: LD_VAR 0 17
61448: NOT
61449: IFFALSE 61453
// exit ;
61451: GO 62402
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61453: LD_ADDR_VAR 0 5
61457: PUSH
61458: LD_INT 4
61460: PUSH
61461: LD_INT 5
61463: PUSH
61464: LD_INT 9
61466: PUSH
61467: LD_INT 10
61469: PUSH
61470: LD_INT 6
61472: PUSH
61473: LD_INT 7
61475: PUSH
61476: LD_INT 11
61478: PUSH
61479: EMPTY
61480: LIST
61481: LIST
61482: LIST
61483: LIST
61484: LIST
61485: LIST
61486: LIST
61487: PUSH
61488: LD_INT 27
61490: PUSH
61491: LD_INT 28
61493: PUSH
61494: LD_INT 26
61496: PUSH
61497: LD_INT 30
61499: PUSH
61500: EMPTY
61501: LIST
61502: LIST
61503: LIST
61504: LIST
61505: PUSH
61506: LD_INT 43
61508: PUSH
61509: LD_INT 44
61511: PUSH
61512: LD_INT 46
61514: PUSH
61515: LD_INT 45
61517: PUSH
61518: LD_INT 47
61520: PUSH
61521: LD_INT 49
61523: PUSH
61524: EMPTY
61525: LIST
61526: LIST
61527: LIST
61528: LIST
61529: LIST
61530: LIST
61531: PUSH
61532: EMPTY
61533: LIST
61534: LIST
61535: LIST
61536: PUSH
61537: LD_VAR 0 12
61541: ARRAY
61542: ST_TO_ADDR
// for i in list do
61543: LD_ADDR_VAR 0 8
61547: PUSH
61548: LD_VAR 0 5
61552: PUSH
61553: FOR_IN
61554: IFFALSE 61587
// if not i in fac_list then
61556: LD_VAR 0 8
61560: PUSH
61561: LD_VAR 0 17
61565: IN
61566: NOT
61567: IFFALSE 61585
// list := list diff i ;
61569: LD_ADDR_VAR 0 5
61573: PUSH
61574: LD_VAR 0 5
61578: PUSH
61579: LD_VAR 0 8
61583: DIFF
61584: ST_TO_ADDR
61585: GO 61553
61587: POP
61588: POP
// if not list then
61589: LD_VAR 0 5
61593: NOT
61594: IFFALSE 61598
// exit ;
61596: GO 62402
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61598: LD_VAR 0 12
61602: PUSH
61603: LD_INT 3
61605: EQUAL
61606: PUSH
61607: LD_INT 49
61609: PUSH
61610: LD_VAR 0 5
61614: IN
61615: AND
61616: PUSH
61617: LD_INT 31
61619: PPUSH
61620: LD_VAR 0 16
61624: PPUSH
61625: CALL_OW 321
61629: PUSH
61630: LD_INT 2
61632: EQUAL
61633: AND
61634: IFFALSE 61694
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61636: LD_INT 22
61638: PUSH
61639: LD_VAR 0 16
61643: PUSH
61644: EMPTY
61645: LIST
61646: LIST
61647: PUSH
61648: LD_INT 35
61650: PUSH
61651: LD_INT 49
61653: PUSH
61654: EMPTY
61655: LIST
61656: LIST
61657: PUSH
61658: LD_INT 91
61660: PUSH
61661: LD_VAR 0 1
61665: PUSH
61666: LD_INT 10
61668: PUSH
61669: EMPTY
61670: LIST
61671: LIST
61672: LIST
61673: PUSH
61674: EMPTY
61675: LIST
61676: LIST
61677: LIST
61678: PPUSH
61679: CALL_OW 69
61683: NOT
61684: IFFALSE 61694
// weapon := ru_time_lapser ;
61686: LD_ADDR_VAR 0 18
61690: PUSH
61691: LD_INT 49
61693: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61694: LD_VAR 0 12
61698: PUSH
61699: LD_INT 1
61701: PUSH
61702: LD_INT 2
61704: PUSH
61705: EMPTY
61706: LIST
61707: LIST
61708: IN
61709: PUSH
61710: LD_INT 11
61712: PUSH
61713: LD_VAR 0 5
61717: IN
61718: PUSH
61719: LD_INT 30
61721: PUSH
61722: LD_VAR 0 5
61726: IN
61727: OR
61728: AND
61729: PUSH
61730: LD_INT 6
61732: PPUSH
61733: LD_VAR 0 16
61737: PPUSH
61738: CALL_OW 321
61742: PUSH
61743: LD_INT 2
61745: EQUAL
61746: AND
61747: IFFALSE 61912
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61749: LD_INT 22
61751: PUSH
61752: LD_VAR 0 16
61756: PUSH
61757: EMPTY
61758: LIST
61759: LIST
61760: PUSH
61761: LD_INT 2
61763: PUSH
61764: LD_INT 35
61766: PUSH
61767: LD_INT 11
61769: PUSH
61770: EMPTY
61771: LIST
61772: LIST
61773: PUSH
61774: LD_INT 35
61776: PUSH
61777: LD_INT 30
61779: PUSH
61780: EMPTY
61781: LIST
61782: LIST
61783: PUSH
61784: EMPTY
61785: LIST
61786: LIST
61787: LIST
61788: PUSH
61789: LD_INT 91
61791: PUSH
61792: LD_VAR 0 1
61796: PUSH
61797: LD_INT 18
61799: PUSH
61800: EMPTY
61801: LIST
61802: LIST
61803: LIST
61804: PUSH
61805: EMPTY
61806: LIST
61807: LIST
61808: LIST
61809: PPUSH
61810: CALL_OW 69
61814: NOT
61815: PUSH
61816: LD_INT 22
61818: PUSH
61819: LD_VAR 0 16
61823: PUSH
61824: EMPTY
61825: LIST
61826: LIST
61827: PUSH
61828: LD_INT 2
61830: PUSH
61831: LD_INT 30
61833: PUSH
61834: LD_INT 32
61836: PUSH
61837: EMPTY
61838: LIST
61839: LIST
61840: PUSH
61841: LD_INT 30
61843: PUSH
61844: LD_INT 33
61846: PUSH
61847: EMPTY
61848: LIST
61849: LIST
61850: PUSH
61851: EMPTY
61852: LIST
61853: LIST
61854: LIST
61855: PUSH
61856: LD_INT 91
61858: PUSH
61859: LD_VAR 0 1
61863: PUSH
61864: LD_INT 12
61866: PUSH
61867: EMPTY
61868: LIST
61869: LIST
61870: LIST
61871: PUSH
61872: EMPTY
61873: LIST
61874: LIST
61875: LIST
61876: PUSH
61877: EMPTY
61878: LIST
61879: PPUSH
61880: CALL_OW 69
61884: PUSH
61885: LD_INT 2
61887: GREATER
61888: AND
61889: IFFALSE 61912
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61891: LD_ADDR_VAR 0 18
61895: PUSH
61896: LD_INT 11
61898: PUSH
61899: LD_INT 30
61901: PUSH
61902: EMPTY
61903: LIST
61904: LIST
61905: PUSH
61906: LD_VAR 0 12
61910: ARRAY
61911: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61912: LD_VAR 0 18
61916: NOT
61917: PUSH
61918: LD_INT 40
61920: PPUSH
61921: LD_VAR 0 16
61925: PPUSH
61926: CALL_OW 321
61930: PUSH
61931: LD_INT 2
61933: EQUAL
61934: AND
61935: PUSH
61936: LD_INT 7
61938: PUSH
61939: LD_VAR 0 5
61943: IN
61944: PUSH
61945: LD_INT 28
61947: PUSH
61948: LD_VAR 0 5
61952: IN
61953: OR
61954: PUSH
61955: LD_INT 45
61957: PUSH
61958: LD_VAR 0 5
61962: IN
61963: OR
61964: AND
61965: IFFALSE 62219
// begin hex := GetHexInfo ( x , y ) ;
61967: LD_ADDR_VAR 0 4
61971: PUSH
61972: LD_VAR 0 10
61976: PPUSH
61977: LD_VAR 0 11
61981: PPUSH
61982: CALL_OW 546
61986: ST_TO_ADDR
// if hex [ 1 ] then
61987: LD_VAR 0 4
61991: PUSH
61992: LD_INT 1
61994: ARRAY
61995: IFFALSE 61999
// exit ;
61997: GO 62402
// height := hex [ 2 ] ;
61999: LD_ADDR_VAR 0 15
62003: PUSH
62004: LD_VAR 0 4
62008: PUSH
62009: LD_INT 2
62011: ARRAY
62012: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62013: LD_ADDR_VAR 0 14
62017: PUSH
62018: LD_INT 0
62020: PUSH
62021: LD_INT 2
62023: PUSH
62024: LD_INT 3
62026: PUSH
62027: LD_INT 5
62029: PUSH
62030: EMPTY
62031: LIST
62032: LIST
62033: LIST
62034: LIST
62035: ST_TO_ADDR
// for i in tmp do
62036: LD_ADDR_VAR 0 8
62040: PUSH
62041: LD_VAR 0 14
62045: PUSH
62046: FOR_IN
62047: IFFALSE 62217
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62049: LD_ADDR_VAR 0 9
62053: PUSH
62054: LD_VAR 0 10
62058: PPUSH
62059: LD_VAR 0 8
62063: PPUSH
62064: LD_INT 5
62066: PPUSH
62067: CALL_OW 272
62071: PUSH
62072: LD_VAR 0 11
62076: PPUSH
62077: LD_VAR 0 8
62081: PPUSH
62082: LD_INT 5
62084: PPUSH
62085: CALL_OW 273
62089: PUSH
62090: EMPTY
62091: LIST
62092: LIST
62093: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62094: LD_VAR 0 9
62098: PUSH
62099: LD_INT 1
62101: ARRAY
62102: PPUSH
62103: LD_VAR 0 9
62107: PUSH
62108: LD_INT 2
62110: ARRAY
62111: PPUSH
62112: CALL_OW 488
62116: IFFALSE 62215
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62118: LD_ADDR_VAR 0 4
62122: PUSH
62123: LD_VAR 0 9
62127: PUSH
62128: LD_INT 1
62130: ARRAY
62131: PPUSH
62132: LD_VAR 0 9
62136: PUSH
62137: LD_INT 2
62139: ARRAY
62140: PPUSH
62141: CALL_OW 546
62145: ST_TO_ADDR
// if hex [ 1 ] then
62146: LD_VAR 0 4
62150: PUSH
62151: LD_INT 1
62153: ARRAY
62154: IFFALSE 62158
// continue ;
62156: GO 62046
// h := hex [ 2 ] ;
62158: LD_ADDR_VAR 0 13
62162: PUSH
62163: LD_VAR 0 4
62167: PUSH
62168: LD_INT 2
62170: ARRAY
62171: ST_TO_ADDR
// if h + 7 < height then
62172: LD_VAR 0 13
62176: PUSH
62177: LD_INT 7
62179: PLUS
62180: PUSH
62181: LD_VAR 0 15
62185: LESS
62186: IFFALSE 62215
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62188: LD_ADDR_VAR 0 18
62192: PUSH
62193: LD_INT 7
62195: PUSH
62196: LD_INT 28
62198: PUSH
62199: LD_INT 45
62201: PUSH
62202: EMPTY
62203: LIST
62204: LIST
62205: LIST
62206: PUSH
62207: LD_VAR 0 12
62211: ARRAY
62212: ST_TO_ADDR
// break ;
62213: GO 62217
// end ; end ; end ;
62215: GO 62046
62217: POP
62218: POP
// end ; if not weapon then
62219: LD_VAR 0 18
62223: NOT
62224: IFFALSE 62284
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62226: LD_ADDR_VAR 0 5
62230: PUSH
62231: LD_VAR 0 5
62235: PUSH
62236: LD_INT 11
62238: PUSH
62239: LD_INT 30
62241: PUSH
62242: LD_INT 49
62244: PUSH
62245: EMPTY
62246: LIST
62247: LIST
62248: LIST
62249: DIFF
62250: ST_TO_ADDR
// if not list then
62251: LD_VAR 0 5
62255: NOT
62256: IFFALSE 62260
// exit ;
62258: GO 62402
// weapon := list [ rand ( 1 , list ) ] ;
62260: LD_ADDR_VAR 0 18
62264: PUSH
62265: LD_VAR 0 5
62269: PUSH
62270: LD_INT 1
62272: PPUSH
62273: LD_VAR 0 5
62277: PPUSH
62278: CALL_OW 12
62282: ARRAY
62283: ST_TO_ADDR
// end ; if weapon then
62284: LD_VAR 0 18
62288: IFFALSE 62402
// begin tmp := CostOfWeapon ( weapon ) ;
62290: LD_ADDR_VAR 0 14
62294: PUSH
62295: LD_VAR 0 18
62299: PPUSH
62300: CALL_OW 451
62304: ST_TO_ADDR
// j := GetBase ( tower ) ;
62305: LD_ADDR_VAR 0 9
62309: PUSH
62310: LD_VAR 0 1
62314: PPUSH
62315: CALL_OW 274
62319: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
62320: LD_VAR 0 9
62324: PPUSH
62325: LD_INT 1
62327: PPUSH
62328: CALL_OW 275
62332: PUSH
62333: LD_VAR 0 14
62337: PUSH
62338: LD_INT 1
62340: ARRAY
62341: GREATEREQUAL
62342: PUSH
62343: LD_VAR 0 9
62347: PPUSH
62348: LD_INT 2
62350: PPUSH
62351: CALL_OW 275
62355: PUSH
62356: LD_VAR 0 14
62360: PUSH
62361: LD_INT 2
62363: ARRAY
62364: GREATEREQUAL
62365: AND
62366: PUSH
62367: LD_VAR 0 9
62371: PPUSH
62372: LD_INT 3
62374: PPUSH
62375: CALL_OW 275
62379: PUSH
62380: LD_VAR 0 14
62384: PUSH
62385: LD_INT 3
62387: ARRAY
62388: GREATEREQUAL
62389: AND
62390: IFFALSE 62402
// result := weapon ;
62392: LD_ADDR_VAR 0 3
62396: PUSH
62397: LD_VAR 0 18
62401: ST_TO_ADDR
// end ; end ;
62402: LD_VAR 0 3
62406: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
62407: LD_INT 0
62409: PPUSH
62410: PPUSH
// result := true ;
62411: LD_ADDR_VAR 0 3
62415: PUSH
62416: LD_INT 1
62418: ST_TO_ADDR
// if array1 = array2 then
62419: LD_VAR 0 1
62423: PUSH
62424: LD_VAR 0 2
62428: EQUAL
62429: IFFALSE 62489
// begin for i = 1 to array1 do
62431: LD_ADDR_VAR 0 4
62435: PUSH
62436: DOUBLE
62437: LD_INT 1
62439: DEC
62440: ST_TO_ADDR
62441: LD_VAR 0 1
62445: PUSH
62446: FOR_TO
62447: IFFALSE 62485
// if array1 [ i ] <> array2 [ i ] then
62449: LD_VAR 0 1
62453: PUSH
62454: LD_VAR 0 4
62458: ARRAY
62459: PUSH
62460: LD_VAR 0 2
62464: PUSH
62465: LD_VAR 0 4
62469: ARRAY
62470: NONEQUAL
62471: IFFALSE 62483
// begin result := false ;
62473: LD_ADDR_VAR 0 3
62477: PUSH
62478: LD_INT 0
62480: ST_TO_ADDR
// break ;
62481: GO 62485
// end ;
62483: GO 62446
62485: POP
62486: POP
// end else
62487: GO 62497
// result := false ;
62489: LD_ADDR_VAR 0 3
62493: PUSH
62494: LD_INT 0
62496: ST_TO_ADDR
// end ;
62497: LD_VAR 0 3
62501: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62502: LD_INT 0
62504: PPUSH
62505: PPUSH
62506: PPUSH
// pom := GetBase ( fac ) ;
62507: LD_ADDR_VAR 0 5
62511: PUSH
62512: LD_VAR 0 1
62516: PPUSH
62517: CALL_OW 274
62521: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62522: LD_ADDR_VAR 0 4
62526: PUSH
62527: LD_VAR 0 2
62531: PUSH
62532: LD_INT 1
62534: ARRAY
62535: PPUSH
62536: LD_VAR 0 2
62540: PUSH
62541: LD_INT 2
62543: ARRAY
62544: PPUSH
62545: LD_VAR 0 2
62549: PUSH
62550: LD_INT 3
62552: ARRAY
62553: PPUSH
62554: LD_VAR 0 2
62558: PUSH
62559: LD_INT 4
62561: ARRAY
62562: PPUSH
62563: CALL_OW 449
62567: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62568: LD_ADDR_VAR 0 3
62572: PUSH
62573: LD_VAR 0 5
62577: PPUSH
62578: LD_INT 1
62580: PPUSH
62581: CALL_OW 275
62585: PUSH
62586: LD_VAR 0 4
62590: PUSH
62591: LD_INT 1
62593: ARRAY
62594: GREATEREQUAL
62595: PUSH
62596: LD_VAR 0 5
62600: PPUSH
62601: LD_INT 2
62603: PPUSH
62604: CALL_OW 275
62608: PUSH
62609: LD_VAR 0 4
62613: PUSH
62614: LD_INT 2
62616: ARRAY
62617: GREATEREQUAL
62618: AND
62619: PUSH
62620: LD_VAR 0 5
62624: PPUSH
62625: LD_INT 3
62627: PPUSH
62628: CALL_OW 275
62632: PUSH
62633: LD_VAR 0 4
62637: PUSH
62638: LD_INT 3
62640: ARRAY
62641: GREATEREQUAL
62642: AND
62643: ST_TO_ADDR
// end ;
62644: LD_VAR 0 3
62648: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62649: LD_INT 0
62651: PPUSH
62652: PPUSH
62653: PPUSH
62654: PPUSH
// pom := GetBase ( building ) ;
62655: LD_ADDR_VAR 0 3
62659: PUSH
62660: LD_VAR 0 1
62664: PPUSH
62665: CALL_OW 274
62669: ST_TO_ADDR
// if not pom then
62670: LD_VAR 0 3
62674: NOT
62675: IFFALSE 62679
// exit ;
62677: GO 62849
// btype := GetBType ( building ) ;
62679: LD_ADDR_VAR 0 5
62683: PUSH
62684: LD_VAR 0 1
62688: PPUSH
62689: CALL_OW 266
62693: ST_TO_ADDR
// if btype = b_armoury then
62694: LD_VAR 0 5
62698: PUSH
62699: LD_INT 4
62701: EQUAL
62702: IFFALSE 62712
// btype := b_barracks ;
62704: LD_ADDR_VAR 0 5
62708: PUSH
62709: LD_INT 5
62711: ST_TO_ADDR
// if btype = b_depot then
62712: LD_VAR 0 5
62716: PUSH
62717: LD_INT 0
62719: EQUAL
62720: IFFALSE 62730
// btype := b_warehouse ;
62722: LD_ADDR_VAR 0 5
62726: PUSH
62727: LD_INT 1
62729: ST_TO_ADDR
// if btype = b_workshop then
62730: LD_VAR 0 5
62734: PUSH
62735: LD_INT 2
62737: EQUAL
62738: IFFALSE 62748
// btype := b_factory ;
62740: LD_ADDR_VAR 0 5
62744: PUSH
62745: LD_INT 3
62747: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62748: LD_ADDR_VAR 0 4
62752: PUSH
62753: LD_VAR 0 5
62757: PPUSH
62758: LD_VAR 0 1
62762: PPUSH
62763: CALL_OW 248
62767: PPUSH
62768: CALL_OW 450
62772: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62773: LD_ADDR_VAR 0 2
62777: PUSH
62778: LD_VAR 0 3
62782: PPUSH
62783: LD_INT 1
62785: PPUSH
62786: CALL_OW 275
62790: PUSH
62791: LD_VAR 0 4
62795: PUSH
62796: LD_INT 1
62798: ARRAY
62799: GREATEREQUAL
62800: PUSH
62801: LD_VAR 0 3
62805: PPUSH
62806: LD_INT 2
62808: PPUSH
62809: CALL_OW 275
62813: PUSH
62814: LD_VAR 0 4
62818: PUSH
62819: LD_INT 2
62821: ARRAY
62822: GREATEREQUAL
62823: AND
62824: PUSH
62825: LD_VAR 0 3
62829: PPUSH
62830: LD_INT 3
62832: PPUSH
62833: CALL_OW 275
62837: PUSH
62838: LD_VAR 0 4
62842: PUSH
62843: LD_INT 3
62845: ARRAY
62846: GREATEREQUAL
62847: AND
62848: ST_TO_ADDR
// end ;
62849: LD_VAR 0 2
62853: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62854: LD_INT 0
62856: PPUSH
62857: PPUSH
62858: PPUSH
// pom := GetBase ( building ) ;
62859: LD_ADDR_VAR 0 4
62863: PUSH
62864: LD_VAR 0 1
62868: PPUSH
62869: CALL_OW 274
62873: ST_TO_ADDR
// if not pom then
62874: LD_VAR 0 4
62878: NOT
62879: IFFALSE 62883
// exit ;
62881: GO 62984
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62883: LD_ADDR_VAR 0 5
62887: PUSH
62888: LD_VAR 0 2
62892: PPUSH
62893: LD_VAR 0 1
62897: PPUSH
62898: CALL_OW 248
62902: PPUSH
62903: CALL_OW 450
62907: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62908: LD_ADDR_VAR 0 3
62912: PUSH
62913: LD_VAR 0 4
62917: PPUSH
62918: LD_INT 1
62920: PPUSH
62921: CALL_OW 275
62925: PUSH
62926: LD_VAR 0 5
62930: PUSH
62931: LD_INT 1
62933: ARRAY
62934: GREATEREQUAL
62935: PUSH
62936: LD_VAR 0 4
62940: PPUSH
62941: LD_INT 2
62943: PPUSH
62944: CALL_OW 275
62948: PUSH
62949: LD_VAR 0 5
62953: PUSH
62954: LD_INT 2
62956: ARRAY
62957: GREATEREQUAL
62958: AND
62959: PUSH
62960: LD_VAR 0 4
62964: PPUSH
62965: LD_INT 3
62967: PPUSH
62968: CALL_OW 275
62972: PUSH
62973: LD_VAR 0 5
62977: PUSH
62978: LD_INT 3
62980: ARRAY
62981: GREATEREQUAL
62982: AND
62983: ST_TO_ADDR
// end ;
62984: LD_VAR 0 3
62988: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
62989: LD_INT 0
62991: PPUSH
62992: PPUSH
62993: PPUSH
62994: PPUSH
62995: PPUSH
62996: PPUSH
62997: PPUSH
62998: PPUSH
62999: PPUSH
63000: PPUSH
// result := false ;
63001: LD_ADDR_VAR 0 6
63005: PUSH
63006: LD_INT 0
63008: ST_TO_ADDR
// if not base or not btype or not x or not y then
63009: LD_VAR 0 1
63013: NOT
63014: PUSH
63015: LD_VAR 0 2
63019: NOT
63020: OR
63021: PUSH
63022: LD_VAR 0 3
63026: NOT
63027: OR
63028: PUSH
63029: LD_VAR 0 4
63033: NOT
63034: OR
63035: IFFALSE 63039
// exit ;
63037: GO 63648
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
63039: LD_ADDR_VAR 0 12
63043: PUSH
63044: LD_VAR 0 2
63048: PPUSH
63049: LD_VAR 0 3
63053: PPUSH
63054: LD_VAR 0 4
63058: PPUSH
63059: LD_VAR 0 5
63063: PPUSH
63064: LD_VAR 0 1
63068: PUSH
63069: LD_INT 1
63071: ARRAY
63072: PPUSH
63073: CALL_OW 248
63077: PPUSH
63078: LD_INT 0
63080: PPUSH
63081: CALL 64485 0 6
63085: ST_TO_ADDR
// if not hexes then
63086: LD_VAR 0 12
63090: NOT
63091: IFFALSE 63095
// exit ;
63093: GO 63648
// for i = 1 to hexes do
63095: LD_ADDR_VAR 0 7
63099: PUSH
63100: DOUBLE
63101: LD_INT 1
63103: DEC
63104: ST_TO_ADDR
63105: LD_VAR 0 12
63109: PUSH
63110: FOR_TO
63111: IFFALSE 63646
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63113: LD_ADDR_VAR 0 11
63117: PUSH
63118: LD_VAR 0 12
63122: PUSH
63123: LD_VAR 0 7
63127: ARRAY
63128: PUSH
63129: LD_INT 1
63131: ARRAY
63132: PPUSH
63133: LD_VAR 0 12
63137: PUSH
63138: LD_VAR 0 7
63142: ARRAY
63143: PUSH
63144: LD_INT 2
63146: ARRAY
63147: PPUSH
63148: CALL_OW 428
63152: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63153: LD_VAR 0 12
63157: PUSH
63158: LD_VAR 0 7
63162: ARRAY
63163: PUSH
63164: LD_INT 1
63166: ARRAY
63167: PPUSH
63168: LD_VAR 0 12
63172: PUSH
63173: LD_VAR 0 7
63177: ARRAY
63178: PUSH
63179: LD_INT 2
63181: ARRAY
63182: PPUSH
63183: CALL_OW 351
63187: PUSH
63188: LD_VAR 0 12
63192: PUSH
63193: LD_VAR 0 7
63197: ARRAY
63198: PUSH
63199: LD_INT 1
63201: ARRAY
63202: PPUSH
63203: LD_VAR 0 12
63207: PUSH
63208: LD_VAR 0 7
63212: ARRAY
63213: PUSH
63214: LD_INT 2
63216: ARRAY
63217: PPUSH
63218: CALL_OW 488
63222: NOT
63223: OR
63224: PUSH
63225: LD_VAR 0 11
63229: PPUSH
63230: CALL_OW 247
63234: PUSH
63235: LD_INT 3
63237: EQUAL
63238: OR
63239: IFFALSE 63245
// exit ;
63241: POP
63242: POP
63243: GO 63648
// if not tmp or not tmp in base then
63245: LD_VAR 0 11
63249: NOT
63250: PUSH
63251: LD_VAR 0 11
63255: PUSH
63256: LD_VAR 0 1
63260: IN
63261: NOT
63262: OR
63263: IFFALSE 63267
// continue ;
63265: GO 63110
// result := true ;
63267: LD_ADDR_VAR 0 6
63271: PUSH
63272: LD_INT 1
63274: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63275: LD_ADDR_VAR 0 15
63279: PUSH
63280: LD_VAR 0 1
63284: PPUSH
63285: LD_INT 22
63287: PUSH
63288: LD_VAR 0 11
63292: PPUSH
63293: CALL_OW 255
63297: PUSH
63298: EMPTY
63299: LIST
63300: LIST
63301: PUSH
63302: LD_INT 2
63304: PUSH
63305: LD_INT 30
63307: PUSH
63308: LD_INT 0
63310: PUSH
63311: EMPTY
63312: LIST
63313: LIST
63314: PUSH
63315: LD_INT 30
63317: PUSH
63318: LD_INT 1
63320: PUSH
63321: EMPTY
63322: LIST
63323: LIST
63324: PUSH
63325: EMPTY
63326: LIST
63327: LIST
63328: LIST
63329: PUSH
63330: EMPTY
63331: LIST
63332: LIST
63333: PPUSH
63334: CALL_OW 72
63338: ST_TO_ADDR
// if dep then
63339: LD_VAR 0 15
63343: IFFALSE 63479
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
63345: LD_ADDR_VAR 0 14
63349: PUSH
63350: LD_VAR 0 15
63354: PUSH
63355: LD_INT 1
63357: ARRAY
63358: PPUSH
63359: CALL_OW 250
63363: PPUSH
63364: LD_VAR 0 15
63368: PUSH
63369: LD_INT 1
63371: ARRAY
63372: PPUSH
63373: CALL_OW 254
63377: PPUSH
63378: LD_INT 5
63380: PPUSH
63381: CALL_OW 272
63385: PUSH
63386: LD_VAR 0 15
63390: PUSH
63391: LD_INT 1
63393: ARRAY
63394: PPUSH
63395: CALL_OW 251
63399: PPUSH
63400: LD_VAR 0 15
63404: PUSH
63405: LD_INT 1
63407: ARRAY
63408: PPUSH
63409: CALL_OW 254
63413: PPUSH
63414: LD_INT 5
63416: PPUSH
63417: CALL_OW 273
63421: PUSH
63422: EMPTY
63423: LIST
63424: LIST
63425: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63426: LD_VAR 0 14
63430: PUSH
63431: LD_INT 1
63433: ARRAY
63434: PPUSH
63435: LD_VAR 0 14
63439: PUSH
63440: LD_INT 2
63442: ARRAY
63443: PPUSH
63444: CALL_OW 488
63448: IFFALSE 63479
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63450: LD_VAR 0 11
63454: PPUSH
63455: LD_VAR 0 14
63459: PUSH
63460: LD_INT 1
63462: ARRAY
63463: PPUSH
63464: LD_VAR 0 14
63468: PUSH
63469: LD_INT 2
63471: ARRAY
63472: PPUSH
63473: CALL_OW 111
// continue ;
63477: GO 63110
// end ; end ; r := GetDir ( tmp ) ;
63479: LD_ADDR_VAR 0 13
63483: PUSH
63484: LD_VAR 0 11
63488: PPUSH
63489: CALL_OW 254
63493: ST_TO_ADDR
// if r = 5 then
63494: LD_VAR 0 13
63498: PUSH
63499: LD_INT 5
63501: EQUAL
63502: IFFALSE 63512
// r := 0 ;
63504: LD_ADDR_VAR 0 13
63508: PUSH
63509: LD_INT 0
63511: ST_TO_ADDR
// for j = r to 5 do
63512: LD_ADDR_VAR 0 8
63516: PUSH
63517: DOUBLE
63518: LD_VAR 0 13
63522: DEC
63523: ST_TO_ADDR
63524: LD_INT 5
63526: PUSH
63527: FOR_TO
63528: IFFALSE 63642
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
63530: LD_ADDR_VAR 0 9
63534: PUSH
63535: LD_VAR 0 11
63539: PPUSH
63540: CALL_OW 250
63544: PPUSH
63545: LD_VAR 0 8
63549: PPUSH
63550: LD_INT 2
63552: PPUSH
63553: CALL_OW 272
63557: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63558: LD_ADDR_VAR 0 10
63562: PUSH
63563: LD_VAR 0 11
63567: PPUSH
63568: CALL_OW 251
63572: PPUSH
63573: LD_VAR 0 8
63577: PPUSH
63578: LD_INT 2
63580: PPUSH
63581: CALL_OW 273
63585: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63586: LD_VAR 0 9
63590: PPUSH
63591: LD_VAR 0 10
63595: PPUSH
63596: CALL_OW 488
63600: PUSH
63601: LD_VAR 0 9
63605: PPUSH
63606: LD_VAR 0 10
63610: PPUSH
63611: CALL_OW 428
63615: NOT
63616: AND
63617: IFFALSE 63640
// begin ComMoveXY ( tmp , _x , _y ) ;
63619: LD_VAR 0 11
63623: PPUSH
63624: LD_VAR 0 9
63628: PPUSH
63629: LD_VAR 0 10
63633: PPUSH
63634: CALL_OW 111
// break ;
63638: GO 63642
// end ; end ;
63640: GO 63527
63642: POP
63643: POP
// end ;
63644: GO 63110
63646: POP
63647: POP
// end ;
63648: LD_VAR 0 6
63652: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
63653: LD_INT 0
63655: PPUSH
63656: PPUSH
63657: PPUSH
63658: PPUSH
63659: PPUSH
63660: PPUSH
63661: PPUSH
63662: PPUSH
63663: PPUSH
63664: PPUSH
// result := false ;
63665: LD_ADDR_VAR 0 6
63669: PUSH
63670: LD_INT 0
63672: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
63673: LD_VAR 0 1
63677: NOT
63678: PUSH
63679: LD_VAR 0 1
63683: PPUSH
63684: CALL_OW 266
63688: PUSH
63689: LD_INT 0
63691: PUSH
63692: LD_INT 1
63694: PUSH
63695: EMPTY
63696: LIST
63697: LIST
63698: IN
63699: NOT
63700: OR
63701: PUSH
63702: LD_VAR 0 2
63706: NOT
63707: OR
63708: PUSH
63709: LD_VAR 0 5
63713: PUSH
63714: LD_INT 0
63716: PUSH
63717: LD_INT 1
63719: PUSH
63720: LD_INT 2
63722: PUSH
63723: LD_INT 3
63725: PUSH
63726: LD_INT 4
63728: PUSH
63729: LD_INT 5
63731: PUSH
63732: EMPTY
63733: LIST
63734: LIST
63735: LIST
63736: LIST
63737: LIST
63738: LIST
63739: IN
63740: NOT
63741: OR
63742: PUSH
63743: LD_VAR 0 3
63747: PPUSH
63748: LD_VAR 0 4
63752: PPUSH
63753: CALL_OW 488
63757: NOT
63758: OR
63759: IFFALSE 63763
// exit ;
63761: GO 64480
// pom := GetBase ( depot ) ;
63763: LD_ADDR_VAR 0 10
63767: PUSH
63768: LD_VAR 0 1
63772: PPUSH
63773: CALL_OW 274
63777: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63778: LD_ADDR_VAR 0 11
63782: PUSH
63783: LD_VAR 0 2
63787: PPUSH
63788: LD_VAR 0 1
63792: PPUSH
63793: CALL_OW 248
63797: PPUSH
63798: CALL_OW 450
63802: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63803: LD_VAR 0 10
63807: PPUSH
63808: LD_INT 1
63810: PPUSH
63811: CALL_OW 275
63815: PUSH
63816: LD_VAR 0 11
63820: PUSH
63821: LD_INT 1
63823: ARRAY
63824: GREATEREQUAL
63825: PUSH
63826: LD_VAR 0 10
63830: PPUSH
63831: LD_INT 2
63833: PPUSH
63834: CALL_OW 275
63838: PUSH
63839: LD_VAR 0 11
63843: PUSH
63844: LD_INT 2
63846: ARRAY
63847: GREATEREQUAL
63848: AND
63849: PUSH
63850: LD_VAR 0 10
63854: PPUSH
63855: LD_INT 3
63857: PPUSH
63858: CALL_OW 275
63862: PUSH
63863: LD_VAR 0 11
63867: PUSH
63868: LD_INT 3
63870: ARRAY
63871: GREATEREQUAL
63872: AND
63873: NOT
63874: IFFALSE 63878
// exit ;
63876: GO 64480
// if GetBType ( depot ) = b_depot then
63878: LD_VAR 0 1
63882: PPUSH
63883: CALL_OW 266
63887: PUSH
63888: LD_INT 0
63890: EQUAL
63891: IFFALSE 63903
// dist := 28 else
63893: LD_ADDR_VAR 0 14
63897: PUSH
63898: LD_INT 28
63900: ST_TO_ADDR
63901: GO 63911
// dist := 36 ;
63903: LD_ADDR_VAR 0 14
63907: PUSH
63908: LD_INT 36
63910: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
63911: LD_VAR 0 1
63915: PPUSH
63916: LD_VAR 0 3
63920: PPUSH
63921: LD_VAR 0 4
63925: PPUSH
63926: CALL_OW 297
63930: PUSH
63931: LD_VAR 0 14
63935: GREATER
63936: IFFALSE 63940
// exit ;
63938: GO 64480
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
63940: LD_ADDR_VAR 0 12
63944: PUSH
63945: LD_VAR 0 2
63949: PPUSH
63950: LD_VAR 0 3
63954: PPUSH
63955: LD_VAR 0 4
63959: PPUSH
63960: LD_VAR 0 5
63964: PPUSH
63965: LD_VAR 0 1
63969: PPUSH
63970: CALL_OW 248
63974: PPUSH
63975: LD_INT 0
63977: PPUSH
63978: CALL 64485 0 6
63982: ST_TO_ADDR
// if not hexes then
63983: LD_VAR 0 12
63987: NOT
63988: IFFALSE 63992
// exit ;
63990: GO 64480
// hex := GetHexInfo ( x , y ) ;
63992: LD_ADDR_VAR 0 15
63996: PUSH
63997: LD_VAR 0 3
64001: PPUSH
64002: LD_VAR 0 4
64006: PPUSH
64007: CALL_OW 546
64011: ST_TO_ADDR
// if hex [ 1 ] then
64012: LD_VAR 0 15
64016: PUSH
64017: LD_INT 1
64019: ARRAY
64020: IFFALSE 64024
// exit ;
64022: GO 64480
// height := hex [ 2 ] ;
64024: LD_ADDR_VAR 0 13
64028: PUSH
64029: LD_VAR 0 15
64033: PUSH
64034: LD_INT 2
64036: ARRAY
64037: ST_TO_ADDR
// for i = 1 to hexes do
64038: LD_ADDR_VAR 0 7
64042: PUSH
64043: DOUBLE
64044: LD_INT 1
64046: DEC
64047: ST_TO_ADDR
64048: LD_VAR 0 12
64052: PUSH
64053: FOR_TO
64054: IFFALSE 64384
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
64056: LD_VAR 0 12
64060: PUSH
64061: LD_VAR 0 7
64065: ARRAY
64066: PUSH
64067: LD_INT 1
64069: ARRAY
64070: PPUSH
64071: LD_VAR 0 12
64075: PUSH
64076: LD_VAR 0 7
64080: ARRAY
64081: PUSH
64082: LD_INT 2
64084: ARRAY
64085: PPUSH
64086: CALL_OW 488
64090: NOT
64091: PUSH
64092: LD_VAR 0 12
64096: PUSH
64097: LD_VAR 0 7
64101: ARRAY
64102: PUSH
64103: LD_INT 1
64105: ARRAY
64106: PPUSH
64107: LD_VAR 0 12
64111: PUSH
64112: LD_VAR 0 7
64116: ARRAY
64117: PUSH
64118: LD_INT 2
64120: ARRAY
64121: PPUSH
64122: CALL_OW 428
64126: PUSH
64127: LD_INT 0
64129: GREATER
64130: OR
64131: PUSH
64132: LD_VAR 0 12
64136: PUSH
64137: LD_VAR 0 7
64141: ARRAY
64142: PUSH
64143: LD_INT 1
64145: ARRAY
64146: PPUSH
64147: LD_VAR 0 12
64151: PUSH
64152: LD_VAR 0 7
64156: ARRAY
64157: PUSH
64158: LD_INT 2
64160: ARRAY
64161: PPUSH
64162: CALL_OW 351
64166: OR
64167: IFFALSE 64173
// exit ;
64169: POP
64170: POP
64171: GO 64480
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64173: LD_ADDR_VAR 0 8
64177: PUSH
64178: LD_VAR 0 12
64182: PUSH
64183: LD_VAR 0 7
64187: ARRAY
64188: PUSH
64189: LD_INT 1
64191: ARRAY
64192: PPUSH
64193: LD_VAR 0 12
64197: PUSH
64198: LD_VAR 0 7
64202: ARRAY
64203: PUSH
64204: LD_INT 2
64206: ARRAY
64207: PPUSH
64208: CALL_OW 546
64212: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
64213: LD_VAR 0 8
64217: PUSH
64218: LD_INT 1
64220: ARRAY
64221: PUSH
64222: LD_VAR 0 8
64226: PUSH
64227: LD_INT 2
64229: ARRAY
64230: PUSH
64231: LD_VAR 0 13
64235: PUSH
64236: LD_INT 2
64238: PLUS
64239: GREATER
64240: OR
64241: PUSH
64242: LD_VAR 0 8
64246: PUSH
64247: LD_INT 2
64249: ARRAY
64250: PUSH
64251: LD_VAR 0 13
64255: PUSH
64256: LD_INT 2
64258: MINUS
64259: LESS
64260: OR
64261: PUSH
64262: LD_VAR 0 8
64266: PUSH
64267: LD_INT 3
64269: ARRAY
64270: PUSH
64271: LD_INT 0
64273: PUSH
64274: LD_INT 8
64276: PUSH
64277: LD_INT 9
64279: PUSH
64280: LD_INT 10
64282: PUSH
64283: LD_INT 11
64285: PUSH
64286: LD_INT 12
64288: PUSH
64289: LD_INT 13
64291: PUSH
64292: LD_INT 16
64294: PUSH
64295: LD_INT 17
64297: PUSH
64298: LD_INT 18
64300: PUSH
64301: LD_INT 19
64303: PUSH
64304: LD_INT 20
64306: PUSH
64307: LD_INT 21
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: LIST
64322: LIST
64323: LIST
64324: IN
64325: NOT
64326: OR
64327: PUSH
64328: LD_VAR 0 8
64332: PUSH
64333: LD_INT 5
64335: ARRAY
64336: NOT
64337: OR
64338: PUSH
64339: LD_VAR 0 8
64343: PUSH
64344: LD_INT 6
64346: ARRAY
64347: PUSH
64348: LD_INT 1
64350: PUSH
64351: LD_INT 2
64353: PUSH
64354: LD_INT 7
64356: PUSH
64357: LD_INT 9
64359: PUSH
64360: LD_INT 10
64362: PUSH
64363: LD_INT 11
64365: PUSH
64366: EMPTY
64367: LIST
64368: LIST
64369: LIST
64370: LIST
64371: LIST
64372: LIST
64373: IN
64374: NOT
64375: OR
64376: IFFALSE 64382
// exit ;
64378: POP
64379: POP
64380: GO 64480
// end ;
64382: GO 64053
64384: POP
64385: POP
// side := GetSide ( depot ) ;
64386: LD_ADDR_VAR 0 9
64390: PUSH
64391: LD_VAR 0 1
64395: PPUSH
64396: CALL_OW 255
64400: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
64401: LD_VAR 0 9
64405: PPUSH
64406: LD_VAR 0 3
64410: PPUSH
64411: LD_VAR 0 4
64415: PPUSH
64416: LD_INT 20
64418: PPUSH
64419: CALL 57134 0 4
64423: PUSH
64424: LD_INT 4
64426: ARRAY
64427: IFFALSE 64431
// exit ;
64429: GO 64480
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
64431: LD_VAR 0 2
64435: PUSH
64436: LD_INT 29
64438: PUSH
64439: LD_INT 30
64441: PUSH
64442: EMPTY
64443: LIST
64444: LIST
64445: IN
64446: PUSH
64447: LD_VAR 0 3
64451: PPUSH
64452: LD_VAR 0 4
64456: PPUSH
64457: LD_VAR 0 9
64461: PPUSH
64462: CALL_OW 440
64466: NOT
64467: AND
64468: IFFALSE 64472
// exit ;
64470: GO 64480
// result := true ;
64472: LD_ADDR_VAR 0 6
64476: PUSH
64477: LD_INT 1
64479: ST_TO_ADDR
// end ;
64480: LD_VAR 0 6
64484: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
64485: LD_INT 0
64487: PPUSH
64488: PPUSH
64489: PPUSH
64490: PPUSH
64491: PPUSH
64492: PPUSH
64493: PPUSH
64494: PPUSH
64495: PPUSH
64496: PPUSH
64497: PPUSH
64498: PPUSH
64499: PPUSH
64500: PPUSH
64501: PPUSH
64502: PPUSH
64503: PPUSH
64504: PPUSH
64505: PPUSH
64506: PPUSH
64507: PPUSH
64508: PPUSH
64509: PPUSH
64510: PPUSH
64511: PPUSH
64512: PPUSH
64513: PPUSH
64514: PPUSH
64515: PPUSH
64516: PPUSH
64517: PPUSH
64518: PPUSH
64519: PPUSH
64520: PPUSH
64521: PPUSH
64522: PPUSH
64523: PPUSH
64524: PPUSH
64525: PPUSH
64526: PPUSH
64527: PPUSH
64528: PPUSH
64529: PPUSH
64530: PPUSH
64531: PPUSH
64532: PPUSH
64533: PPUSH
64534: PPUSH
64535: PPUSH
64536: PPUSH
64537: PPUSH
64538: PPUSH
64539: PPUSH
64540: PPUSH
64541: PPUSH
64542: PPUSH
64543: PPUSH
64544: PPUSH
// result = [ ] ;
64545: LD_ADDR_VAR 0 7
64549: PUSH
64550: EMPTY
64551: ST_TO_ADDR
// temp_list = [ ] ;
64552: LD_ADDR_VAR 0 9
64556: PUSH
64557: EMPTY
64558: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
64559: LD_VAR 0 4
64563: PUSH
64564: LD_INT 0
64566: PUSH
64567: LD_INT 1
64569: PUSH
64570: LD_INT 2
64572: PUSH
64573: LD_INT 3
64575: PUSH
64576: LD_INT 4
64578: PUSH
64579: LD_INT 5
64581: PUSH
64582: EMPTY
64583: LIST
64584: LIST
64585: LIST
64586: LIST
64587: LIST
64588: LIST
64589: IN
64590: NOT
64591: PUSH
64592: LD_VAR 0 1
64596: PUSH
64597: LD_INT 0
64599: PUSH
64600: LD_INT 1
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: IN
64607: PUSH
64608: LD_VAR 0 5
64612: PUSH
64613: LD_INT 1
64615: PUSH
64616: LD_INT 2
64618: PUSH
64619: LD_INT 3
64621: PUSH
64622: EMPTY
64623: LIST
64624: LIST
64625: LIST
64626: IN
64627: NOT
64628: AND
64629: OR
64630: IFFALSE 64634
// exit ;
64632: GO 83025
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
64634: LD_VAR 0 1
64638: PUSH
64639: LD_INT 6
64641: PUSH
64642: LD_INT 7
64644: PUSH
64645: LD_INT 8
64647: PUSH
64648: LD_INT 13
64650: PUSH
64651: LD_INT 12
64653: PUSH
64654: LD_INT 15
64656: PUSH
64657: LD_INT 11
64659: PUSH
64660: LD_INT 14
64662: PUSH
64663: LD_INT 10
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: LIST
64670: LIST
64671: LIST
64672: LIST
64673: LIST
64674: LIST
64675: LIST
64676: IN
64677: IFFALSE 64687
// btype = b_lab ;
64679: LD_ADDR_VAR 0 1
64683: PUSH
64684: LD_INT 6
64686: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
64687: LD_VAR 0 6
64691: PUSH
64692: LD_INT 0
64694: PUSH
64695: LD_INT 1
64697: PUSH
64698: LD_INT 2
64700: PUSH
64701: EMPTY
64702: LIST
64703: LIST
64704: LIST
64705: IN
64706: NOT
64707: PUSH
64708: LD_VAR 0 1
64712: PUSH
64713: LD_INT 0
64715: PUSH
64716: LD_INT 1
64718: PUSH
64719: LD_INT 2
64721: PUSH
64722: LD_INT 3
64724: PUSH
64725: LD_INT 6
64727: PUSH
64728: LD_INT 36
64730: PUSH
64731: LD_INT 4
64733: PUSH
64734: LD_INT 5
64736: PUSH
64737: LD_INT 31
64739: PUSH
64740: LD_INT 32
64742: PUSH
64743: LD_INT 33
64745: PUSH
64746: EMPTY
64747: LIST
64748: LIST
64749: LIST
64750: LIST
64751: LIST
64752: LIST
64753: LIST
64754: LIST
64755: LIST
64756: LIST
64757: LIST
64758: IN
64759: NOT
64760: PUSH
64761: LD_VAR 0 6
64765: PUSH
64766: LD_INT 1
64768: EQUAL
64769: AND
64770: OR
64771: PUSH
64772: LD_VAR 0 1
64776: PUSH
64777: LD_INT 2
64779: PUSH
64780: LD_INT 3
64782: PUSH
64783: EMPTY
64784: LIST
64785: LIST
64786: IN
64787: NOT
64788: PUSH
64789: LD_VAR 0 6
64793: PUSH
64794: LD_INT 2
64796: EQUAL
64797: AND
64798: OR
64799: IFFALSE 64809
// mode = 0 ;
64801: LD_ADDR_VAR 0 6
64805: PUSH
64806: LD_INT 0
64808: ST_TO_ADDR
// case mode of 0 :
64809: LD_VAR 0 6
64813: PUSH
64814: LD_INT 0
64816: DOUBLE
64817: EQUAL
64818: IFTRUE 64822
64820: GO 76275
64822: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64823: LD_ADDR_VAR 0 11
64827: PUSH
64828: LD_INT 0
64830: PUSH
64831: LD_INT 0
64833: PUSH
64834: EMPTY
64835: LIST
64836: LIST
64837: PUSH
64838: LD_INT 0
64840: PUSH
64841: LD_INT 1
64843: NEG
64844: PUSH
64845: EMPTY
64846: LIST
64847: LIST
64848: PUSH
64849: LD_INT 1
64851: PUSH
64852: LD_INT 0
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: PUSH
64859: LD_INT 1
64861: PUSH
64862: LD_INT 1
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: PUSH
64869: LD_INT 0
64871: PUSH
64872: LD_INT 1
64874: PUSH
64875: EMPTY
64876: LIST
64877: LIST
64878: PUSH
64879: LD_INT 1
64881: NEG
64882: PUSH
64883: LD_INT 0
64885: PUSH
64886: EMPTY
64887: LIST
64888: LIST
64889: PUSH
64890: LD_INT 1
64892: NEG
64893: PUSH
64894: LD_INT 1
64896: NEG
64897: PUSH
64898: EMPTY
64899: LIST
64900: LIST
64901: PUSH
64902: LD_INT 1
64904: NEG
64905: PUSH
64906: LD_INT 2
64908: NEG
64909: PUSH
64910: EMPTY
64911: LIST
64912: LIST
64913: PUSH
64914: LD_INT 0
64916: PUSH
64917: LD_INT 2
64919: NEG
64920: PUSH
64921: EMPTY
64922: LIST
64923: LIST
64924: PUSH
64925: LD_INT 1
64927: PUSH
64928: LD_INT 1
64930: NEG
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PUSH
64936: LD_INT 1
64938: PUSH
64939: LD_INT 2
64941: PUSH
64942: EMPTY
64943: LIST
64944: LIST
64945: PUSH
64946: LD_INT 0
64948: PUSH
64949: LD_INT 2
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: PUSH
64956: LD_INT 1
64958: NEG
64959: PUSH
64960: LD_INT 1
64962: PUSH
64963: EMPTY
64964: LIST
64965: LIST
64966: PUSH
64967: LD_INT 1
64969: PUSH
64970: LD_INT 3
64972: PUSH
64973: EMPTY
64974: LIST
64975: LIST
64976: PUSH
64977: LD_INT 0
64979: PUSH
64980: LD_INT 3
64982: PUSH
64983: EMPTY
64984: LIST
64985: LIST
64986: PUSH
64987: LD_INT 1
64989: NEG
64990: PUSH
64991: LD_INT 2
64993: PUSH
64994: EMPTY
64995: LIST
64996: LIST
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: LIST
65013: LIST
65014: LIST
65015: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65016: LD_ADDR_VAR 0 12
65020: PUSH
65021: LD_INT 0
65023: PUSH
65024: LD_INT 0
65026: PUSH
65027: EMPTY
65028: LIST
65029: LIST
65030: PUSH
65031: LD_INT 0
65033: PUSH
65034: LD_INT 1
65036: NEG
65037: PUSH
65038: EMPTY
65039: LIST
65040: LIST
65041: PUSH
65042: LD_INT 1
65044: PUSH
65045: LD_INT 0
65047: PUSH
65048: EMPTY
65049: LIST
65050: LIST
65051: PUSH
65052: LD_INT 1
65054: PUSH
65055: LD_INT 1
65057: PUSH
65058: EMPTY
65059: LIST
65060: LIST
65061: PUSH
65062: LD_INT 0
65064: PUSH
65065: LD_INT 1
65067: PUSH
65068: EMPTY
65069: LIST
65070: LIST
65071: PUSH
65072: LD_INT 1
65074: NEG
65075: PUSH
65076: LD_INT 0
65078: PUSH
65079: EMPTY
65080: LIST
65081: LIST
65082: PUSH
65083: LD_INT 1
65085: NEG
65086: PUSH
65087: LD_INT 1
65089: NEG
65090: PUSH
65091: EMPTY
65092: LIST
65093: LIST
65094: PUSH
65095: LD_INT 1
65097: PUSH
65098: LD_INT 1
65100: NEG
65101: PUSH
65102: EMPTY
65103: LIST
65104: LIST
65105: PUSH
65106: LD_INT 2
65108: PUSH
65109: LD_INT 0
65111: PUSH
65112: EMPTY
65113: LIST
65114: LIST
65115: PUSH
65116: LD_INT 2
65118: PUSH
65119: LD_INT 1
65121: PUSH
65122: EMPTY
65123: LIST
65124: LIST
65125: PUSH
65126: LD_INT 1
65128: NEG
65129: PUSH
65130: LD_INT 1
65132: PUSH
65133: EMPTY
65134: LIST
65135: LIST
65136: PUSH
65137: LD_INT 2
65139: NEG
65140: PUSH
65141: LD_INT 0
65143: PUSH
65144: EMPTY
65145: LIST
65146: LIST
65147: PUSH
65148: LD_INT 2
65150: NEG
65151: PUSH
65152: LD_INT 1
65154: NEG
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: PUSH
65160: LD_INT 2
65162: NEG
65163: PUSH
65164: LD_INT 1
65166: PUSH
65167: EMPTY
65168: LIST
65169: LIST
65170: PUSH
65171: LD_INT 3
65173: NEG
65174: PUSH
65175: LD_INT 0
65177: PUSH
65178: EMPTY
65179: LIST
65180: LIST
65181: PUSH
65182: LD_INT 3
65184: NEG
65185: PUSH
65186: LD_INT 1
65188: NEG
65189: PUSH
65190: EMPTY
65191: LIST
65192: LIST
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: LIST
65198: LIST
65199: LIST
65200: LIST
65201: LIST
65202: LIST
65203: LIST
65204: LIST
65205: LIST
65206: LIST
65207: LIST
65208: LIST
65209: LIST
65210: LIST
65211: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65212: LD_ADDR_VAR 0 13
65216: PUSH
65217: LD_INT 0
65219: PUSH
65220: LD_INT 0
65222: PUSH
65223: EMPTY
65224: LIST
65225: LIST
65226: PUSH
65227: LD_INT 0
65229: PUSH
65230: LD_INT 1
65232: NEG
65233: PUSH
65234: EMPTY
65235: LIST
65236: LIST
65237: PUSH
65238: LD_INT 1
65240: PUSH
65241: LD_INT 0
65243: PUSH
65244: EMPTY
65245: LIST
65246: LIST
65247: PUSH
65248: LD_INT 1
65250: PUSH
65251: LD_INT 1
65253: PUSH
65254: EMPTY
65255: LIST
65256: LIST
65257: PUSH
65258: LD_INT 0
65260: PUSH
65261: LD_INT 1
65263: PUSH
65264: EMPTY
65265: LIST
65266: LIST
65267: PUSH
65268: LD_INT 1
65270: NEG
65271: PUSH
65272: LD_INT 0
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: LD_INT 1
65281: NEG
65282: PUSH
65283: LD_INT 1
65285: NEG
65286: PUSH
65287: EMPTY
65288: LIST
65289: LIST
65290: PUSH
65291: LD_INT 1
65293: NEG
65294: PUSH
65295: LD_INT 2
65297: NEG
65298: PUSH
65299: EMPTY
65300: LIST
65301: LIST
65302: PUSH
65303: LD_INT 2
65305: PUSH
65306: LD_INT 1
65308: PUSH
65309: EMPTY
65310: LIST
65311: LIST
65312: PUSH
65313: LD_INT 2
65315: PUSH
65316: LD_INT 2
65318: PUSH
65319: EMPTY
65320: LIST
65321: LIST
65322: PUSH
65323: LD_INT 1
65325: PUSH
65326: LD_INT 2
65328: PUSH
65329: EMPTY
65330: LIST
65331: LIST
65332: PUSH
65333: LD_INT 2
65335: NEG
65336: PUSH
65337: LD_INT 1
65339: NEG
65340: PUSH
65341: EMPTY
65342: LIST
65343: LIST
65344: PUSH
65345: LD_INT 2
65347: NEG
65348: PUSH
65349: LD_INT 2
65351: NEG
65352: PUSH
65353: EMPTY
65354: LIST
65355: LIST
65356: PUSH
65357: LD_INT 2
65359: NEG
65360: PUSH
65361: LD_INT 3
65363: NEG
65364: PUSH
65365: EMPTY
65366: LIST
65367: LIST
65368: PUSH
65369: LD_INT 3
65371: NEG
65372: PUSH
65373: LD_INT 2
65375: NEG
65376: PUSH
65377: EMPTY
65378: LIST
65379: LIST
65380: PUSH
65381: LD_INT 3
65383: NEG
65384: PUSH
65385: LD_INT 3
65387: NEG
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: LIST
65407: LIST
65408: LIST
65409: LIST
65410: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
65411: LD_ADDR_VAR 0 14
65415: PUSH
65416: LD_INT 0
65418: PUSH
65419: LD_INT 0
65421: PUSH
65422: EMPTY
65423: LIST
65424: LIST
65425: PUSH
65426: LD_INT 0
65428: PUSH
65429: LD_INT 1
65431: NEG
65432: PUSH
65433: EMPTY
65434: LIST
65435: LIST
65436: PUSH
65437: LD_INT 1
65439: PUSH
65440: LD_INT 0
65442: PUSH
65443: EMPTY
65444: LIST
65445: LIST
65446: PUSH
65447: LD_INT 1
65449: PUSH
65450: LD_INT 1
65452: PUSH
65453: EMPTY
65454: LIST
65455: LIST
65456: PUSH
65457: LD_INT 0
65459: PUSH
65460: LD_INT 1
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: PUSH
65467: LD_INT 1
65469: NEG
65470: PUSH
65471: LD_INT 0
65473: PUSH
65474: EMPTY
65475: LIST
65476: LIST
65477: PUSH
65478: LD_INT 1
65480: NEG
65481: PUSH
65482: LD_INT 1
65484: NEG
65485: PUSH
65486: EMPTY
65487: LIST
65488: LIST
65489: PUSH
65490: LD_INT 1
65492: NEG
65493: PUSH
65494: LD_INT 2
65496: NEG
65497: PUSH
65498: EMPTY
65499: LIST
65500: LIST
65501: PUSH
65502: LD_INT 0
65504: PUSH
65505: LD_INT 2
65507: NEG
65508: PUSH
65509: EMPTY
65510: LIST
65511: LIST
65512: PUSH
65513: LD_INT 1
65515: PUSH
65516: LD_INT 1
65518: NEG
65519: PUSH
65520: EMPTY
65521: LIST
65522: LIST
65523: PUSH
65524: LD_INT 1
65526: PUSH
65527: LD_INT 2
65529: PUSH
65530: EMPTY
65531: LIST
65532: LIST
65533: PUSH
65534: LD_INT 0
65536: PUSH
65537: LD_INT 2
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: PUSH
65544: LD_INT 1
65546: NEG
65547: PUSH
65548: LD_INT 1
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: PUSH
65555: LD_INT 1
65557: NEG
65558: PUSH
65559: LD_INT 3
65561: NEG
65562: PUSH
65563: EMPTY
65564: LIST
65565: LIST
65566: PUSH
65567: LD_INT 0
65569: PUSH
65570: LD_INT 3
65572: NEG
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: PUSH
65578: LD_INT 1
65580: PUSH
65581: LD_INT 2
65583: NEG
65584: PUSH
65585: EMPTY
65586: LIST
65587: LIST
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: LIST
65603: LIST
65604: LIST
65605: LIST
65606: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
65607: LD_ADDR_VAR 0 15
65611: PUSH
65612: LD_INT 0
65614: PUSH
65615: LD_INT 0
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: PUSH
65622: LD_INT 0
65624: PUSH
65625: LD_INT 1
65627: NEG
65628: PUSH
65629: EMPTY
65630: LIST
65631: LIST
65632: PUSH
65633: LD_INT 1
65635: PUSH
65636: LD_INT 0
65638: PUSH
65639: EMPTY
65640: LIST
65641: LIST
65642: PUSH
65643: LD_INT 1
65645: PUSH
65646: LD_INT 1
65648: PUSH
65649: EMPTY
65650: LIST
65651: LIST
65652: PUSH
65653: LD_INT 0
65655: PUSH
65656: LD_INT 1
65658: PUSH
65659: EMPTY
65660: LIST
65661: LIST
65662: PUSH
65663: LD_INT 1
65665: NEG
65666: PUSH
65667: LD_INT 0
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: PUSH
65674: LD_INT 1
65676: NEG
65677: PUSH
65678: LD_INT 1
65680: NEG
65681: PUSH
65682: EMPTY
65683: LIST
65684: LIST
65685: PUSH
65686: LD_INT 1
65688: PUSH
65689: LD_INT 1
65691: NEG
65692: PUSH
65693: EMPTY
65694: LIST
65695: LIST
65696: PUSH
65697: LD_INT 2
65699: PUSH
65700: LD_INT 0
65702: PUSH
65703: EMPTY
65704: LIST
65705: LIST
65706: PUSH
65707: LD_INT 2
65709: PUSH
65710: LD_INT 1
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: PUSH
65717: LD_INT 1
65719: NEG
65720: PUSH
65721: LD_INT 1
65723: PUSH
65724: EMPTY
65725: LIST
65726: LIST
65727: PUSH
65728: LD_INT 2
65730: NEG
65731: PUSH
65732: LD_INT 0
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: PUSH
65739: LD_INT 2
65741: NEG
65742: PUSH
65743: LD_INT 1
65745: NEG
65746: PUSH
65747: EMPTY
65748: LIST
65749: LIST
65750: PUSH
65751: LD_INT 2
65753: PUSH
65754: LD_INT 1
65756: NEG
65757: PUSH
65758: EMPTY
65759: LIST
65760: LIST
65761: PUSH
65762: LD_INT 3
65764: PUSH
65765: LD_INT 0
65767: PUSH
65768: EMPTY
65769: LIST
65770: LIST
65771: PUSH
65772: LD_INT 3
65774: PUSH
65775: LD_INT 1
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: EMPTY
65783: LIST
65784: LIST
65785: LIST
65786: LIST
65787: LIST
65788: LIST
65789: LIST
65790: LIST
65791: LIST
65792: LIST
65793: LIST
65794: LIST
65795: LIST
65796: LIST
65797: LIST
65798: LIST
65799: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65800: LD_ADDR_VAR 0 16
65804: PUSH
65805: LD_INT 0
65807: PUSH
65808: LD_INT 0
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: PUSH
65815: LD_INT 0
65817: PUSH
65818: LD_INT 1
65820: NEG
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: PUSH
65826: LD_INT 1
65828: PUSH
65829: LD_INT 0
65831: PUSH
65832: EMPTY
65833: LIST
65834: LIST
65835: PUSH
65836: LD_INT 1
65838: PUSH
65839: LD_INT 1
65841: PUSH
65842: EMPTY
65843: LIST
65844: LIST
65845: PUSH
65846: LD_INT 0
65848: PUSH
65849: LD_INT 1
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: LD_INT 1
65858: NEG
65859: PUSH
65860: LD_INT 0
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: PUSH
65867: LD_INT 1
65869: NEG
65870: PUSH
65871: LD_INT 1
65873: NEG
65874: PUSH
65875: EMPTY
65876: LIST
65877: LIST
65878: PUSH
65879: LD_INT 1
65881: NEG
65882: PUSH
65883: LD_INT 2
65885: NEG
65886: PUSH
65887: EMPTY
65888: LIST
65889: LIST
65890: PUSH
65891: LD_INT 2
65893: PUSH
65894: LD_INT 1
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: PUSH
65901: LD_INT 2
65903: PUSH
65904: LD_INT 2
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 1
65913: PUSH
65914: LD_INT 2
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: PUSH
65921: LD_INT 2
65923: NEG
65924: PUSH
65925: LD_INT 1
65927: NEG
65928: PUSH
65929: EMPTY
65930: LIST
65931: LIST
65932: PUSH
65933: LD_INT 2
65935: NEG
65936: PUSH
65937: LD_INT 2
65939: NEG
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: LD_INT 3
65947: PUSH
65948: LD_INT 2
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: PUSH
65955: LD_INT 3
65957: PUSH
65958: LD_INT 3
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: LD_INT 2
65967: PUSH
65968: LD_INT 3
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: EMPTY
65976: LIST
65977: LIST
65978: LIST
65979: LIST
65980: LIST
65981: LIST
65982: LIST
65983: LIST
65984: LIST
65985: LIST
65986: LIST
65987: LIST
65988: LIST
65989: LIST
65990: LIST
65991: LIST
65992: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65993: LD_ADDR_VAR 0 17
65997: PUSH
65998: LD_INT 0
66000: PUSH
66001: LD_INT 0
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PUSH
66008: LD_INT 0
66010: PUSH
66011: LD_INT 1
66013: NEG
66014: PUSH
66015: EMPTY
66016: LIST
66017: LIST
66018: PUSH
66019: LD_INT 1
66021: PUSH
66022: LD_INT 0
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: PUSH
66029: LD_INT 1
66031: PUSH
66032: LD_INT 1
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 0
66041: PUSH
66042: LD_INT 1
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: PUSH
66049: LD_INT 1
66051: NEG
66052: PUSH
66053: LD_INT 0
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: LD_INT 1
66062: NEG
66063: PUSH
66064: LD_INT 1
66066: NEG
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 1
66074: NEG
66075: PUSH
66076: LD_INT 2
66078: NEG
66079: PUSH
66080: EMPTY
66081: LIST
66082: LIST
66083: PUSH
66084: LD_INT 0
66086: PUSH
66087: LD_INT 2
66089: NEG
66090: PUSH
66091: EMPTY
66092: LIST
66093: LIST
66094: PUSH
66095: LD_INT 1
66097: PUSH
66098: LD_INT 1
66100: NEG
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PUSH
66106: LD_INT 2
66108: PUSH
66109: LD_INT 0
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: PUSH
66116: LD_INT 2
66118: PUSH
66119: LD_INT 1
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: PUSH
66126: LD_INT 2
66128: PUSH
66129: LD_INT 2
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: PUSH
66136: LD_INT 1
66138: PUSH
66139: LD_INT 2
66141: PUSH
66142: EMPTY
66143: LIST
66144: LIST
66145: PUSH
66146: LD_INT 0
66148: PUSH
66149: LD_INT 2
66151: PUSH
66152: EMPTY
66153: LIST
66154: LIST
66155: PUSH
66156: LD_INT 1
66158: NEG
66159: PUSH
66160: LD_INT 1
66162: PUSH
66163: EMPTY
66164: LIST
66165: LIST
66166: PUSH
66167: LD_INT 2
66169: NEG
66170: PUSH
66171: LD_INT 0
66173: PUSH
66174: EMPTY
66175: LIST
66176: LIST
66177: PUSH
66178: LD_INT 2
66180: NEG
66181: PUSH
66182: LD_INT 1
66184: NEG
66185: PUSH
66186: EMPTY
66187: LIST
66188: LIST
66189: PUSH
66190: LD_INT 2
66192: NEG
66193: PUSH
66194: LD_INT 2
66196: NEG
66197: PUSH
66198: EMPTY
66199: LIST
66200: LIST
66201: PUSH
66202: EMPTY
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: LIST
66213: LIST
66214: LIST
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66223: LD_ADDR_VAR 0 18
66227: PUSH
66228: LD_INT 0
66230: PUSH
66231: LD_INT 0
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PUSH
66238: LD_INT 0
66240: PUSH
66241: LD_INT 1
66243: NEG
66244: PUSH
66245: EMPTY
66246: LIST
66247: LIST
66248: PUSH
66249: LD_INT 1
66251: PUSH
66252: LD_INT 0
66254: PUSH
66255: EMPTY
66256: LIST
66257: LIST
66258: PUSH
66259: LD_INT 1
66261: PUSH
66262: LD_INT 1
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: LD_INT 0
66271: PUSH
66272: LD_INT 1
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PUSH
66279: LD_INT 1
66281: NEG
66282: PUSH
66283: LD_INT 0
66285: PUSH
66286: EMPTY
66287: LIST
66288: LIST
66289: PUSH
66290: LD_INT 1
66292: NEG
66293: PUSH
66294: LD_INT 1
66296: NEG
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: LD_INT 1
66304: NEG
66305: PUSH
66306: LD_INT 2
66308: NEG
66309: PUSH
66310: EMPTY
66311: LIST
66312: LIST
66313: PUSH
66314: LD_INT 0
66316: PUSH
66317: LD_INT 2
66319: NEG
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 1
66327: PUSH
66328: LD_INT 1
66330: NEG
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 2
66338: PUSH
66339: LD_INT 0
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: PUSH
66346: LD_INT 2
66348: PUSH
66349: LD_INT 1
66351: PUSH
66352: EMPTY
66353: LIST
66354: LIST
66355: PUSH
66356: LD_INT 2
66358: PUSH
66359: LD_INT 2
66361: PUSH
66362: EMPTY
66363: LIST
66364: LIST
66365: PUSH
66366: LD_INT 1
66368: PUSH
66369: LD_INT 2
66371: PUSH
66372: EMPTY
66373: LIST
66374: LIST
66375: PUSH
66376: LD_INT 0
66378: PUSH
66379: LD_INT 2
66381: PUSH
66382: EMPTY
66383: LIST
66384: LIST
66385: PUSH
66386: LD_INT 1
66388: NEG
66389: PUSH
66390: LD_INT 1
66392: PUSH
66393: EMPTY
66394: LIST
66395: LIST
66396: PUSH
66397: LD_INT 2
66399: NEG
66400: PUSH
66401: LD_INT 0
66403: PUSH
66404: EMPTY
66405: LIST
66406: LIST
66407: PUSH
66408: LD_INT 2
66410: NEG
66411: PUSH
66412: LD_INT 1
66414: NEG
66415: PUSH
66416: EMPTY
66417: LIST
66418: LIST
66419: PUSH
66420: LD_INT 2
66422: NEG
66423: PUSH
66424: LD_INT 2
66426: NEG
66427: PUSH
66428: EMPTY
66429: LIST
66430: LIST
66431: PUSH
66432: EMPTY
66433: LIST
66434: LIST
66435: LIST
66436: LIST
66437: LIST
66438: LIST
66439: LIST
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66453: LD_ADDR_VAR 0 19
66457: PUSH
66458: LD_INT 0
66460: PUSH
66461: LD_INT 0
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: PUSH
66468: LD_INT 0
66470: PUSH
66471: LD_INT 1
66473: NEG
66474: PUSH
66475: EMPTY
66476: LIST
66477: LIST
66478: PUSH
66479: LD_INT 1
66481: PUSH
66482: LD_INT 0
66484: PUSH
66485: EMPTY
66486: LIST
66487: LIST
66488: PUSH
66489: LD_INT 1
66491: PUSH
66492: LD_INT 1
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: PUSH
66499: LD_INT 0
66501: PUSH
66502: LD_INT 1
66504: PUSH
66505: EMPTY
66506: LIST
66507: LIST
66508: PUSH
66509: LD_INT 1
66511: NEG
66512: PUSH
66513: LD_INT 0
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: PUSH
66520: LD_INT 1
66522: NEG
66523: PUSH
66524: LD_INT 1
66526: NEG
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PUSH
66532: LD_INT 1
66534: NEG
66535: PUSH
66536: LD_INT 2
66538: NEG
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: PUSH
66544: LD_INT 0
66546: PUSH
66547: LD_INT 2
66549: NEG
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: PUSH
66555: LD_INT 1
66557: PUSH
66558: LD_INT 1
66560: NEG
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: PUSH
66566: LD_INT 2
66568: PUSH
66569: LD_INT 0
66571: PUSH
66572: EMPTY
66573: LIST
66574: LIST
66575: PUSH
66576: LD_INT 2
66578: PUSH
66579: LD_INT 1
66581: PUSH
66582: EMPTY
66583: LIST
66584: LIST
66585: PUSH
66586: LD_INT 2
66588: PUSH
66589: LD_INT 2
66591: PUSH
66592: EMPTY
66593: LIST
66594: LIST
66595: PUSH
66596: LD_INT 1
66598: PUSH
66599: LD_INT 2
66601: PUSH
66602: EMPTY
66603: LIST
66604: LIST
66605: PUSH
66606: LD_INT 0
66608: PUSH
66609: LD_INT 2
66611: PUSH
66612: EMPTY
66613: LIST
66614: LIST
66615: PUSH
66616: LD_INT 1
66618: NEG
66619: PUSH
66620: LD_INT 1
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 2
66629: NEG
66630: PUSH
66631: LD_INT 0
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: LD_INT 2
66640: NEG
66641: PUSH
66642: LD_INT 1
66644: NEG
66645: PUSH
66646: EMPTY
66647: LIST
66648: LIST
66649: PUSH
66650: LD_INT 2
66652: NEG
66653: PUSH
66654: LD_INT 2
66656: NEG
66657: PUSH
66658: EMPTY
66659: LIST
66660: LIST
66661: PUSH
66662: EMPTY
66663: LIST
66664: LIST
66665: LIST
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: LIST
66671: LIST
66672: LIST
66673: LIST
66674: LIST
66675: LIST
66676: LIST
66677: LIST
66678: LIST
66679: LIST
66680: LIST
66681: LIST
66682: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66683: LD_ADDR_VAR 0 20
66687: PUSH
66688: LD_INT 0
66690: PUSH
66691: LD_INT 0
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: PUSH
66698: LD_INT 0
66700: PUSH
66701: LD_INT 1
66703: NEG
66704: PUSH
66705: EMPTY
66706: LIST
66707: LIST
66708: PUSH
66709: LD_INT 1
66711: PUSH
66712: LD_INT 0
66714: PUSH
66715: EMPTY
66716: LIST
66717: LIST
66718: PUSH
66719: LD_INT 1
66721: PUSH
66722: LD_INT 1
66724: PUSH
66725: EMPTY
66726: LIST
66727: LIST
66728: PUSH
66729: LD_INT 0
66731: PUSH
66732: LD_INT 1
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: PUSH
66739: LD_INT 1
66741: NEG
66742: PUSH
66743: LD_INT 0
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: PUSH
66750: LD_INT 1
66752: NEG
66753: PUSH
66754: LD_INT 1
66756: NEG
66757: PUSH
66758: EMPTY
66759: LIST
66760: LIST
66761: PUSH
66762: LD_INT 1
66764: NEG
66765: PUSH
66766: LD_INT 2
66768: NEG
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PUSH
66774: LD_INT 0
66776: PUSH
66777: LD_INT 2
66779: NEG
66780: PUSH
66781: EMPTY
66782: LIST
66783: LIST
66784: PUSH
66785: LD_INT 1
66787: PUSH
66788: LD_INT 1
66790: NEG
66791: PUSH
66792: EMPTY
66793: LIST
66794: LIST
66795: PUSH
66796: LD_INT 2
66798: PUSH
66799: LD_INT 0
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: PUSH
66806: LD_INT 2
66808: PUSH
66809: LD_INT 1
66811: PUSH
66812: EMPTY
66813: LIST
66814: LIST
66815: PUSH
66816: LD_INT 2
66818: PUSH
66819: LD_INT 2
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: PUSH
66826: LD_INT 1
66828: PUSH
66829: LD_INT 2
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: PUSH
66836: LD_INT 0
66838: PUSH
66839: LD_INT 2
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: LD_INT 1
66848: NEG
66849: PUSH
66850: LD_INT 1
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: LD_INT 2
66859: NEG
66860: PUSH
66861: LD_INT 0
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 2
66870: NEG
66871: PUSH
66872: LD_INT 1
66874: NEG
66875: PUSH
66876: EMPTY
66877: LIST
66878: LIST
66879: PUSH
66880: LD_INT 2
66882: NEG
66883: PUSH
66884: LD_INT 2
66886: NEG
66887: PUSH
66888: EMPTY
66889: LIST
66890: LIST
66891: PUSH
66892: EMPTY
66893: LIST
66894: LIST
66895: LIST
66896: LIST
66897: LIST
66898: LIST
66899: LIST
66900: LIST
66901: LIST
66902: LIST
66903: LIST
66904: LIST
66905: LIST
66906: LIST
66907: LIST
66908: LIST
66909: LIST
66910: LIST
66911: LIST
66912: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66913: LD_ADDR_VAR 0 21
66917: PUSH
66918: LD_INT 0
66920: PUSH
66921: LD_INT 0
66923: PUSH
66924: EMPTY
66925: LIST
66926: LIST
66927: PUSH
66928: LD_INT 0
66930: PUSH
66931: LD_INT 1
66933: NEG
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: PUSH
66939: LD_INT 1
66941: PUSH
66942: LD_INT 0
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PUSH
66949: LD_INT 1
66951: PUSH
66952: LD_INT 1
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: LD_INT 0
66961: PUSH
66962: LD_INT 1
66964: PUSH
66965: EMPTY
66966: LIST
66967: LIST
66968: PUSH
66969: LD_INT 1
66971: NEG
66972: PUSH
66973: LD_INT 0
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: PUSH
66980: LD_INT 1
66982: NEG
66983: PUSH
66984: LD_INT 1
66986: NEG
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 1
66994: NEG
66995: PUSH
66996: LD_INT 2
66998: NEG
66999: PUSH
67000: EMPTY
67001: LIST
67002: LIST
67003: PUSH
67004: LD_INT 0
67006: PUSH
67007: LD_INT 2
67009: NEG
67010: PUSH
67011: EMPTY
67012: LIST
67013: LIST
67014: PUSH
67015: LD_INT 1
67017: PUSH
67018: LD_INT 1
67020: NEG
67021: PUSH
67022: EMPTY
67023: LIST
67024: LIST
67025: PUSH
67026: LD_INT 2
67028: PUSH
67029: LD_INT 0
67031: PUSH
67032: EMPTY
67033: LIST
67034: LIST
67035: PUSH
67036: LD_INT 2
67038: PUSH
67039: LD_INT 1
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: PUSH
67046: LD_INT 2
67048: PUSH
67049: LD_INT 2
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: LD_INT 1
67058: PUSH
67059: LD_INT 2
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PUSH
67066: LD_INT 0
67068: PUSH
67069: LD_INT 2
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 1
67078: NEG
67079: PUSH
67080: LD_INT 1
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 2
67089: NEG
67090: PUSH
67091: LD_INT 0
67093: PUSH
67094: EMPTY
67095: LIST
67096: LIST
67097: PUSH
67098: LD_INT 2
67100: NEG
67101: PUSH
67102: LD_INT 1
67104: NEG
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 2
67112: NEG
67113: PUSH
67114: LD_INT 2
67116: NEG
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: EMPTY
67123: LIST
67124: LIST
67125: LIST
67126: LIST
67127: LIST
67128: LIST
67129: LIST
67130: LIST
67131: LIST
67132: LIST
67133: LIST
67134: LIST
67135: LIST
67136: LIST
67137: LIST
67138: LIST
67139: LIST
67140: LIST
67141: LIST
67142: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67143: LD_ADDR_VAR 0 22
67147: PUSH
67148: LD_INT 0
67150: PUSH
67151: LD_INT 0
67153: PUSH
67154: EMPTY
67155: LIST
67156: LIST
67157: PUSH
67158: LD_INT 0
67160: PUSH
67161: LD_INT 1
67163: NEG
67164: PUSH
67165: EMPTY
67166: LIST
67167: LIST
67168: PUSH
67169: LD_INT 1
67171: PUSH
67172: LD_INT 0
67174: PUSH
67175: EMPTY
67176: LIST
67177: LIST
67178: PUSH
67179: LD_INT 1
67181: PUSH
67182: LD_INT 1
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 0
67191: PUSH
67192: LD_INT 1
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 1
67201: NEG
67202: PUSH
67203: LD_INT 0
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 1
67212: NEG
67213: PUSH
67214: LD_INT 1
67216: NEG
67217: PUSH
67218: EMPTY
67219: LIST
67220: LIST
67221: PUSH
67222: LD_INT 1
67224: NEG
67225: PUSH
67226: LD_INT 2
67228: NEG
67229: PUSH
67230: EMPTY
67231: LIST
67232: LIST
67233: PUSH
67234: LD_INT 0
67236: PUSH
67237: LD_INT 2
67239: NEG
67240: PUSH
67241: EMPTY
67242: LIST
67243: LIST
67244: PUSH
67245: LD_INT 1
67247: PUSH
67248: LD_INT 1
67250: NEG
67251: PUSH
67252: EMPTY
67253: LIST
67254: LIST
67255: PUSH
67256: LD_INT 2
67258: PUSH
67259: LD_INT 0
67261: PUSH
67262: EMPTY
67263: LIST
67264: LIST
67265: PUSH
67266: LD_INT 2
67268: PUSH
67269: LD_INT 1
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: PUSH
67276: LD_INT 2
67278: PUSH
67279: LD_INT 2
67281: PUSH
67282: EMPTY
67283: LIST
67284: LIST
67285: PUSH
67286: LD_INT 1
67288: PUSH
67289: LD_INT 2
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 0
67298: PUSH
67299: LD_INT 2
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: LD_INT 1
67308: NEG
67309: PUSH
67310: LD_INT 1
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 2
67319: NEG
67320: PUSH
67321: LD_INT 0
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 2
67330: NEG
67331: PUSH
67332: LD_INT 1
67334: NEG
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: PUSH
67340: LD_INT 2
67342: NEG
67343: PUSH
67344: LD_INT 2
67346: NEG
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PUSH
67352: EMPTY
67353: LIST
67354: LIST
67355: LIST
67356: LIST
67357: LIST
67358: LIST
67359: LIST
67360: LIST
67361: LIST
67362: LIST
67363: LIST
67364: LIST
67365: LIST
67366: LIST
67367: LIST
67368: LIST
67369: LIST
67370: LIST
67371: LIST
67372: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
67373: LD_ADDR_VAR 0 23
67377: PUSH
67378: LD_INT 0
67380: PUSH
67381: LD_INT 0
67383: PUSH
67384: EMPTY
67385: LIST
67386: LIST
67387: PUSH
67388: LD_INT 0
67390: PUSH
67391: LD_INT 1
67393: NEG
67394: PUSH
67395: EMPTY
67396: LIST
67397: LIST
67398: PUSH
67399: LD_INT 1
67401: PUSH
67402: LD_INT 0
67404: PUSH
67405: EMPTY
67406: LIST
67407: LIST
67408: PUSH
67409: LD_INT 1
67411: PUSH
67412: LD_INT 1
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: PUSH
67419: LD_INT 0
67421: PUSH
67422: LD_INT 1
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: PUSH
67429: LD_INT 1
67431: NEG
67432: PUSH
67433: LD_INT 0
67435: PUSH
67436: EMPTY
67437: LIST
67438: LIST
67439: PUSH
67440: LD_INT 1
67442: NEG
67443: PUSH
67444: LD_INT 1
67446: NEG
67447: PUSH
67448: EMPTY
67449: LIST
67450: LIST
67451: PUSH
67452: LD_INT 1
67454: NEG
67455: PUSH
67456: LD_INT 2
67458: NEG
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 0
67466: PUSH
67467: LD_INT 2
67469: NEG
67470: PUSH
67471: EMPTY
67472: LIST
67473: LIST
67474: PUSH
67475: LD_INT 1
67477: PUSH
67478: LD_INT 1
67480: NEG
67481: PUSH
67482: EMPTY
67483: LIST
67484: LIST
67485: PUSH
67486: LD_INT 2
67488: PUSH
67489: LD_INT 0
67491: PUSH
67492: EMPTY
67493: LIST
67494: LIST
67495: PUSH
67496: LD_INT 2
67498: PUSH
67499: LD_INT 1
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: PUSH
67506: LD_INT 2
67508: PUSH
67509: LD_INT 2
67511: PUSH
67512: EMPTY
67513: LIST
67514: LIST
67515: PUSH
67516: LD_INT 1
67518: PUSH
67519: LD_INT 2
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: PUSH
67526: LD_INT 0
67528: PUSH
67529: LD_INT 2
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 1
67538: NEG
67539: PUSH
67540: LD_INT 1
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 2
67549: NEG
67550: PUSH
67551: LD_INT 0
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: LD_INT 2
67560: NEG
67561: PUSH
67562: LD_INT 1
67564: NEG
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: PUSH
67570: LD_INT 2
67572: NEG
67573: PUSH
67574: LD_INT 2
67576: NEG
67577: PUSH
67578: EMPTY
67579: LIST
67580: LIST
67581: PUSH
67582: LD_INT 2
67584: NEG
67585: PUSH
67586: LD_INT 3
67588: NEG
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 1
67596: NEG
67597: PUSH
67598: LD_INT 3
67600: NEG
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: PUSH
67606: LD_INT 1
67608: PUSH
67609: LD_INT 2
67611: NEG
67612: PUSH
67613: EMPTY
67614: LIST
67615: LIST
67616: PUSH
67617: LD_INT 2
67619: PUSH
67620: LD_INT 1
67622: NEG
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: EMPTY
67629: LIST
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
67653: LD_ADDR_VAR 0 24
67657: PUSH
67658: LD_INT 0
67660: PUSH
67661: LD_INT 0
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: PUSH
67668: LD_INT 0
67670: PUSH
67671: LD_INT 1
67673: NEG
67674: PUSH
67675: EMPTY
67676: LIST
67677: LIST
67678: PUSH
67679: LD_INT 1
67681: PUSH
67682: LD_INT 0
67684: PUSH
67685: EMPTY
67686: LIST
67687: LIST
67688: PUSH
67689: LD_INT 1
67691: PUSH
67692: LD_INT 1
67694: PUSH
67695: EMPTY
67696: LIST
67697: LIST
67698: PUSH
67699: LD_INT 0
67701: PUSH
67702: LD_INT 1
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: PUSH
67709: LD_INT 1
67711: NEG
67712: PUSH
67713: LD_INT 0
67715: PUSH
67716: EMPTY
67717: LIST
67718: LIST
67719: PUSH
67720: LD_INT 1
67722: NEG
67723: PUSH
67724: LD_INT 1
67726: NEG
67727: PUSH
67728: EMPTY
67729: LIST
67730: LIST
67731: PUSH
67732: LD_INT 1
67734: NEG
67735: PUSH
67736: LD_INT 2
67738: NEG
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: PUSH
67744: LD_INT 0
67746: PUSH
67747: LD_INT 2
67749: NEG
67750: PUSH
67751: EMPTY
67752: LIST
67753: LIST
67754: PUSH
67755: LD_INT 1
67757: PUSH
67758: LD_INT 1
67760: NEG
67761: PUSH
67762: EMPTY
67763: LIST
67764: LIST
67765: PUSH
67766: LD_INT 2
67768: PUSH
67769: LD_INT 0
67771: PUSH
67772: EMPTY
67773: LIST
67774: LIST
67775: PUSH
67776: LD_INT 2
67778: PUSH
67779: LD_INT 1
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: PUSH
67786: LD_INT 2
67788: PUSH
67789: LD_INT 2
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PUSH
67796: LD_INT 1
67798: PUSH
67799: LD_INT 2
67801: PUSH
67802: EMPTY
67803: LIST
67804: LIST
67805: PUSH
67806: LD_INT 0
67808: PUSH
67809: LD_INT 2
67811: PUSH
67812: EMPTY
67813: LIST
67814: LIST
67815: PUSH
67816: LD_INT 1
67818: NEG
67819: PUSH
67820: LD_INT 1
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: PUSH
67827: LD_INT 2
67829: NEG
67830: PUSH
67831: LD_INT 0
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: LD_INT 2
67840: NEG
67841: PUSH
67842: LD_INT 1
67844: NEG
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: PUSH
67850: LD_INT 2
67852: NEG
67853: PUSH
67854: LD_INT 2
67856: NEG
67857: PUSH
67858: EMPTY
67859: LIST
67860: LIST
67861: PUSH
67862: LD_INT 1
67864: PUSH
67865: LD_INT 2
67867: NEG
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: LD_INT 2
67875: PUSH
67876: LD_INT 1
67878: NEG
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 3
67886: PUSH
67887: LD_INT 1
67889: PUSH
67890: EMPTY
67891: LIST
67892: LIST
67893: PUSH
67894: LD_INT 3
67896: PUSH
67897: LD_INT 2
67899: PUSH
67900: EMPTY
67901: LIST
67902: LIST
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: LIST
67908: LIST
67909: LIST
67910: LIST
67911: LIST
67912: LIST
67913: LIST
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
67929: LD_ADDR_VAR 0 25
67933: PUSH
67934: LD_INT 0
67936: PUSH
67937: LD_INT 0
67939: PUSH
67940: EMPTY
67941: LIST
67942: LIST
67943: PUSH
67944: LD_INT 0
67946: PUSH
67947: LD_INT 1
67949: NEG
67950: PUSH
67951: EMPTY
67952: LIST
67953: LIST
67954: PUSH
67955: LD_INT 1
67957: PUSH
67958: LD_INT 0
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: PUSH
67965: LD_INT 1
67967: PUSH
67968: LD_INT 1
67970: PUSH
67971: EMPTY
67972: LIST
67973: LIST
67974: PUSH
67975: LD_INT 0
67977: PUSH
67978: LD_INT 1
67980: PUSH
67981: EMPTY
67982: LIST
67983: LIST
67984: PUSH
67985: LD_INT 1
67987: NEG
67988: PUSH
67989: LD_INT 0
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 1
67998: NEG
67999: PUSH
68000: LD_INT 1
68002: NEG
68003: PUSH
68004: EMPTY
68005: LIST
68006: LIST
68007: PUSH
68008: LD_INT 1
68010: NEG
68011: PUSH
68012: LD_INT 2
68014: NEG
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: PUSH
68020: LD_INT 0
68022: PUSH
68023: LD_INT 2
68025: NEG
68026: PUSH
68027: EMPTY
68028: LIST
68029: LIST
68030: PUSH
68031: LD_INT 1
68033: PUSH
68034: LD_INT 1
68036: NEG
68037: PUSH
68038: EMPTY
68039: LIST
68040: LIST
68041: PUSH
68042: LD_INT 2
68044: PUSH
68045: LD_INT 0
68047: PUSH
68048: EMPTY
68049: LIST
68050: LIST
68051: PUSH
68052: LD_INT 2
68054: PUSH
68055: LD_INT 1
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PUSH
68062: LD_INT 2
68064: PUSH
68065: LD_INT 2
68067: PUSH
68068: EMPTY
68069: LIST
68070: LIST
68071: PUSH
68072: LD_INT 1
68074: PUSH
68075: LD_INT 2
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PUSH
68082: LD_INT 0
68084: PUSH
68085: LD_INT 2
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 1
68094: NEG
68095: PUSH
68096: LD_INT 1
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: PUSH
68103: LD_INT 2
68105: NEG
68106: PUSH
68107: LD_INT 0
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 2
68116: NEG
68117: PUSH
68118: LD_INT 1
68120: NEG
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: PUSH
68126: LD_INT 2
68128: NEG
68129: PUSH
68130: LD_INT 2
68132: NEG
68133: PUSH
68134: EMPTY
68135: LIST
68136: LIST
68137: PUSH
68138: LD_INT 3
68140: PUSH
68141: LD_INT 1
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: PUSH
68148: LD_INT 3
68150: PUSH
68151: LD_INT 2
68153: PUSH
68154: EMPTY
68155: LIST
68156: LIST
68157: PUSH
68158: LD_INT 2
68160: PUSH
68161: LD_INT 3
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: PUSH
68168: LD_INT 1
68170: PUSH
68171: LD_INT 3
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PUSH
68178: EMPTY
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: LIST
68193: LIST
68194: LIST
68195: LIST
68196: LIST
68197: LIST
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
68203: LD_ADDR_VAR 0 26
68207: PUSH
68208: LD_INT 0
68210: PUSH
68211: LD_INT 0
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 0
68220: PUSH
68221: LD_INT 1
68223: NEG
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 1
68231: PUSH
68232: LD_INT 0
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 1
68241: PUSH
68242: LD_INT 1
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 0
68251: PUSH
68252: LD_INT 1
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: LD_INT 1
68261: NEG
68262: PUSH
68263: LD_INT 0
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 1
68272: NEG
68273: PUSH
68274: LD_INT 1
68276: NEG
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: PUSH
68282: LD_INT 1
68284: NEG
68285: PUSH
68286: LD_INT 2
68288: NEG
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: PUSH
68294: LD_INT 0
68296: PUSH
68297: LD_INT 2
68299: NEG
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 1
68307: PUSH
68308: LD_INT 1
68310: NEG
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 2
68318: PUSH
68319: LD_INT 0
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: PUSH
68326: LD_INT 2
68328: PUSH
68329: LD_INT 1
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 2
68338: PUSH
68339: LD_INT 2
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 1
68348: PUSH
68349: LD_INT 2
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: PUSH
68356: LD_INT 0
68358: PUSH
68359: LD_INT 2
68361: PUSH
68362: EMPTY
68363: LIST
68364: LIST
68365: PUSH
68366: LD_INT 1
68368: NEG
68369: PUSH
68370: LD_INT 1
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: PUSH
68377: LD_INT 2
68379: NEG
68380: PUSH
68381: LD_INT 0
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 2
68390: NEG
68391: PUSH
68392: LD_INT 1
68394: NEG
68395: PUSH
68396: EMPTY
68397: LIST
68398: LIST
68399: PUSH
68400: LD_INT 2
68402: NEG
68403: PUSH
68404: LD_INT 2
68406: NEG
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 2
68414: PUSH
68415: LD_INT 3
68417: PUSH
68418: EMPTY
68419: LIST
68420: LIST
68421: PUSH
68422: LD_INT 1
68424: PUSH
68425: LD_INT 3
68427: PUSH
68428: EMPTY
68429: LIST
68430: LIST
68431: PUSH
68432: LD_INT 1
68434: NEG
68435: PUSH
68436: LD_INT 2
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: LD_INT 2
68445: NEG
68446: PUSH
68447: LD_INT 1
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: LIST
68458: LIST
68459: LIST
68460: LIST
68461: LIST
68462: LIST
68463: LIST
68464: LIST
68465: LIST
68466: LIST
68467: LIST
68468: LIST
68469: LIST
68470: LIST
68471: LIST
68472: LIST
68473: LIST
68474: LIST
68475: LIST
68476: LIST
68477: LIST
68478: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68479: LD_ADDR_VAR 0 27
68483: PUSH
68484: LD_INT 0
68486: PUSH
68487: LD_INT 0
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 0
68496: PUSH
68497: LD_INT 1
68499: NEG
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: PUSH
68505: LD_INT 1
68507: PUSH
68508: LD_INT 0
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PUSH
68515: LD_INT 1
68517: PUSH
68518: LD_INT 1
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 0
68527: PUSH
68528: LD_INT 1
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 1
68537: NEG
68538: PUSH
68539: LD_INT 0
68541: PUSH
68542: EMPTY
68543: LIST
68544: LIST
68545: PUSH
68546: LD_INT 1
68548: NEG
68549: PUSH
68550: LD_INT 1
68552: NEG
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: PUSH
68558: LD_INT 1
68560: NEG
68561: PUSH
68562: LD_INT 2
68564: NEG
68565: PUSH
68566: EMPTY
68567: LIST
68568: LIST
68569: PUSH
68570: LD_INT 0
68572: PUSH
68573: LD_INT 2
68575: NEG
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 1
68583: PUSH
68584: LD_INT 1
68586: NEG
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: LD_INT 2
68594: PUSH
68595: LD_INT 0
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 2
68604: PUSH
68605: LD_INT 1
68607: PUSH
68608: EMPTY
68609: LIST
68610: LIST
68611: PUSH
68612: LD_INT 2
68614: PUSH
68615: LD_INT 2
68617: PUSH
68618: EMPTY
68619: LIST
68620: LIST
68621: PUSH
68622: LD_INT 1
68624: PUSH
68625: LD_INT 2
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: PUSH
68632: LD_INT 0
68634: PUSH
68635: LD_INT 2
68637: PUSH
68638: EMPTY
68639: LIST
68640: LIST
68641: PUSH
68642: LD_INT 1
68644: NEG
68645: PUSH
68646: LD_INT 1
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: LD_INT 2
68655: NEG
68656: PUSH
68657: LD_INT 0
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 2
68666: NEG
68667: PUSH
68668: LD_INT 1
68670: NEG
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: LD_INT 2
68678: NEG
68679: PUSH
68680: LD_INT 2
68682: NEG
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 1
68690: NEG
68691: PUSH
68692: LD_INT 2
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: PUSH
68699: LD_INT 2
68701: NEG
68702: PUSH
68703: LD_INT 1
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: LD_INT 3
68712: NEG
68713: PUSH
68714: LD_INT 1
68716: NEG
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 3
68724: NEG
68725: PUSH
68726: LD_INT 2
68728: NEG
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: LIST
68738: LIST
68739: LIST
68740: LIST
68741: LIST
68742: LIST
68743: LIST
68744: LIST
68745: LIST
68746: LIST
68747: LIST
68748: LIST
68749: LIST
68750: LIST
68751: LIST
68752: LIST
68753: LIST
68754: LIST
68755: LIST
68756: LIST
68757: LIST
68758: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68759: LD_ADDR_VAR 0 28
68763: PUSH
68764: LD_INT 0
68766: PUSH
68767: LD_INT 0
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: PUSH
68774: LD_INT 0
68776: PUSH
68777: LD_INT 1
68779: NEG
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: LD_INT 1
68787: PUSH
68788: LD_INT 0
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 1
68797: PUSH
68798: LD_INT 1
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 0
68807: PUSH
68808: LD_INT 1
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PUSH
68815: LD_INT 1
68817: NEG
68818: PUSH
68819: LD_INT 0
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 1
68828: NEG
68829: PUSH
68830: LD_INT 1
68832: NEG
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: PUSH
68838: LD_INT 1
68840: NEG
68841: PUSH
68842: LD_INT 2
68844: NEG
68845: PUSH
68846: EMPTY
68847: LIST
68848: LIST
68849: PUSH
68850: LD_INT 0
68852: PUSH
68853: LD_INT 2
68855: NEG
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: PUSH
68861: LD_INT 1
68863: PUSH
68864: LD_INT 1
68866: NEG
68867: PUSH
68868: EMPTY
68869: LIST
68870: LIST
68871: PUSH
68872: LD_INT 2
68874: PUSH
68875: LD_INT 0
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: PUSH
68882: LD_INT 2
68884: PUSH
68885: LD_INT 1
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PUSH
68892: LD_INT 2
68894: PUSH
68895: LD_INT 2
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 1
68904: PUSH
68905: LD_INT 2
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: LD_INT 0
68914: PUSH
68915: LD_INT 2
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 1
68924: NEG
68925: PUSH
68926: LD_INT 1
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: PUSH
68933: LD_INT 2
68935: NEG
68936: PUSH
68937: LD_INT 0
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 2
68946: NEG
68947: PUSH
68948: LD_INT 1
68950: NEG
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: PUSH
68956: LD_INT 2
68958: NEG
68959: PUSH
68960: LD_INT 2
68962: NEG
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 2
68970: NEG
68971: PUSH
68972: LD_INT 3
68974: NEG
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 1
68982: NEG
68983: PUSH
68984: LD_INT 3
68986: NEG
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 3
68994: NEG
68995: PUSH
68996: LD_INT 1
68998: NEG
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 3
69006: NEG
69007: PUSH
69008: LD_INT 2
69010: NEG
69011: PUSH
69012: EMPTY
69013: LIST
69014: LIST
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: LIST
69020: LIST
69021: LIST
69022: LIST
69023: LIST
69024: LIST
69025: LIST
69026: LIST
69027: LIST
69028: LIST
69029: LIST
69030: LIST
69031: LIST
69032: LIST
69033: LIST
69034: LIST
69035: LIST
69036: LIST
69037: LIST
69038: LIST
69039: LIST
69040: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69041: LD_ADDR_VAR 0 29
69045: PUSH
69046: LD_INT 0
69048: PUSH
69049: LD_INT 0
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: LD_INT 0
69058: PUSH
69059: LD_INT 1
69061: NEG
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: LD_INT 1
69069: PUSH
69070: LD_INT 0
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: PUSH
69077: LD_INT 1
69079: PUSH
69080: LD_INT 1
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: PUSH
69087: LD_INT 0
69089: PUSH
69090: LD_INT 1
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: LD_INT 1
69099: NEG
69100: PUSH
69101: LD_INT 0
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: PUSH
69108: LD_INT 1
69110: NEG
69111: PUSH
69112: LD_INT 1
69114: NEG
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: LD_INT 1
69122: NEG
69123: PUSH
69124: LD_INT 2
69126: NEG
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 0
69134: PUSH
69135: LD_INT 2
69137: NEG
69138: PUSH
69139: EMPTY
69140: LIST
69141: LIST
69142: PUSH
69143: LD_INT 1
69145: PUSH
69146: LD_INT 1
69148: NEG
69149: PUSH
69150: EMPTY
69151: LIST
69152: LIST
69153: PUSH
69154: LD_INT 2
69156: PUSH
69157: LD_INT 0
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: PUSH
69164: LD_INT 2
69166: PUSH
69167: LD_INT 1
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: LD_INT 1
69176: PUSH
69177: LD_INT 2
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: LD_INT 0
69186: PUSH
69187: LD_INT 2
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: LD_INT 1
69196: NEG
69197: PUSH
69198: LD_INT 1
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 2
69207: NEG
69208: PUSH
69209: LD_INT 1
69211: NEG
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: PUSH
69217: LD_INT 2
69219: NEG
69220: PUSH
69221: LD_INT 2
69223: NEG
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 2
69231: NEG
69232: PUSH
69233: LD_INT 3
69235: NEG
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 2
69243: PUSH
69244: LD_INT 1
69246: NEG
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: PUSH
69252: LD_INT 3
69254: PUSH
69255: LD_INT 1
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: PUSH
69262: LD_INT 1
69264: PUSH
69265: LD_INT 3
69267: PUSH
69268: EMPTY
69269: LIST
69270: LIST
69271: PUSH
69272: LD_INT 1
69274: NEG
69275: PUSH
69276: LD_INT 2
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: LD_INT 3
69285: NEG
69286: PUSH
69287: LD_INT 2
69289: NEG
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: LIST
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: LIST
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69320: LD_ADDR_VAR 0 30
69324: PUSH
69325: LD_INT 0
69327: PUSH
69328: LD_INT 0
69330: PUSH
69331: EMPTY
69332: LIST
69333: LIST
69334: PUSH
69335: LD_INT 0
69337: PUSH
69338: LD_INT 1
69340: NEG
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: PUSH
69346: LD_INT 1
69348: PUSH
69349: LD_INT 0
69351: PUSH
69352: EMPTY
69353: LIST
69354: LIST
69355: PUSH
69356: LD_INT 1
69358: PUSH
69359: LD_INT 1
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: LD_INT 0
69368: PUSH
69369: LD_INT 1
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 1
69378: NEG
69379: PUSH
69380: LD_INT 0
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PUSH
69387: LD_INT 1
69389: NEG
69390: PUSH
69391: LD_INT 1
69393: NEG
69394: PUSH
69395: EMPTY
69396: LIST
69397: LIST
69398: PUSH
69399: LD_INT 1
69401: NEG
69402: PUSH
69403: LD_INT 2
69405: NEG
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: LD_INT 0
69413: PUSH
69414: LD_INT 2
69416: NEG
69417: PUSH
69418: EMPTY
69419: LIST
69420: LIST
69421: PUSH
69422: LD_INT 1
69424: PUSH
69425: LD_INT 1
69427: NEG
69428: PUSH
69429: EMPTY
69430: LIST
69431: LIST
69432: PUSH
69433: LD_INT 2
69435: PUSH
69436: LD_INT 0
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: PUSH
69443: LD_INT 2
69445: PUSH
69446: LD_INT 1
69448: PUSH
69449: EMPTY
69450: LIST
69451: LIST
69452: PUSH
69453: LD_INT 2
69455: PUSH
69456: LD_INT 2
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 1
69465: PUSH
69466: LD_INT 2
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: PUSH
69473: LD_INT 1
69475: NEG
69476: PUSH
69477: LD_INT 1
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PUSH
69484: LD_INT 2
69486: NEG
69487: PUSH
69488: LD_INT 0
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: PUSH
69495: LD_INT 2
69497: NEG
69498: PUSH
69499: LD_INT 1
69501: NEG
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: PUSH
69507: LD_INT 1
69509: NEG
69510: PUSH
69511: LD_INT 3
69513: NEG
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: LD_INT 1
69521: PUSH
69522: LD_INT 2
69524: NEG
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 3
69532: PUSH
69533: LD_INT 2
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: PUSH
69540: LD_INT 2
69542: PUSH
69543: LD_INT 3
69545: PUSH
69546: EMPTY
69547: LIST
69548: LIST
69549: PUSH
69550: LD_INT 2
69552: NEG
69553: PUSH
69554: LD_INT 1
69556: PUSH
69557: EMPTY
69558: LIST
69559: LIST
69560: PUSH
69561: LD_INT 3
69563: NEG
69564: PUSH
69565: LD_INT 1
69567: NEG
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PUSH
69573: EMPTY
69574: LIST
69575: LIST
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69598: LD_ADDR_VAR 0 31
69602: PUSH
69603: LD_INT 0
69605: PUSH
69606: LD_INT 0
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 0
69615: PUSH
69616: LD_INT 1
69618: NEG
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 1
69626: PUSH
69627: LD_INT 0
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: PUSH
69634: LD_INT 1
69636: PUSH
69637: LD_INT 1
69639: PUSH
69640: EMPTY
69641: LIST
69642: LIST
69643: PUSH
69644: LD_INT 0
69646: PUSH
69647: LD_INT 1
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PUSH
69654: LD_INT 1
69656: NEG
69657: PUSH
69658: LD_INT 0
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 1
69667: NEG
69668: PUSH
69669: LD_INT 1
69671: NEG
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 1
69679: NEG
69680: PUSH
69681: LD_INT 2
69683: NEG
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: PUSH
69689: LD_INT 1
69691: PUSH
69692: LD_INT 1
69694: NEG
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: PUSH
69700: LD_INT 2
69702: PUSH
69703: LD_INT 0
69705: PUSH
69706: EMPTY
69707: LIST
69708: LIST
69709: PUSH
69710: LD_INT 2
69712: PUSH
69713: LD_INT 1
69715: PUSH
69716: EMPTY
69717: LIST
69718: LIST
69719: PUSH
69720: LD_INT 2
69722: PUSH
69723: LD_INT 2
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: LD_INT 1
69732: PUSH
69733: LD_INT 2
69735: PUSH
69736: EMPTY
69737: LIST
69738: LIST
69739: PUSH
69740: LD_INT 0
69742: PUSH
69743: LD_INT 2
69745: PUSH
69746: EMPTY
69747: LIST
69748: LIST
69749: PUSH
69750: LD_INT 1
69752: NEG
69753: PUSH
69754: LD_INT 1
69756: PUSH
69757: EMPTY
69758: LIST
69759: LIST
69760: PUSH
69761: LD_INT 2
69763: NEG
69764: PUSH
69765: LD_INT 1
69767: NEG
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: PUSH
69773: LD_INT 2
69775: NEG
69776: PUSH
69777: LD_INT 2
69779: NEG
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: PUSH
69785: LD_INT 2
69787: NEG
69788: PUSH
69789: LD_INT 3
69791: NEG
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 2
69799: PUSH
69800: LD_INT 1
69802: NEG
69803: PUSH
69804: EMPTY
69805: LIST
69806: LIST
69807: PUSH
69808: LD_INT 3
69810: PUSH
69811: LD_INT 1
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: PUSH
69818: LD_INT 1
69820: PUSH
69821: LD_INT 3
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: LD_INT 1
69830: NEG
69831: PUSH
69832: LD_INT 2
69834: PUSH
69835: EMPTY
69836: LIST
69837: LIST
69838: PUSH
69839: LD_INT 3
69841: NEG
69842: PUSH
69843: LD_INT 2
69845: NEG
69846: PUSH
69847: EMPTY
69848: LIST
69849: LIST
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69876: LD_ADDR_VAR 0 32
69880: PUSH
69881: LD_INT 0
69883: PUSH
69884: LD_INT 0
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 0
69893: PUSH
69894: LD_INT 1
69896: NEG
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: PUSH
69902: LD_INT 1
69904: PUSH
69905: LD_INT 0
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: LD_INT 1
69914: PUSH
69915: LD_INT 1
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 0
69924: PUSH
69925: LD_INT 1
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PUSH
69932: LD_INT 1
69934: NEG
69935: PUSH
69936: LD_INT 0
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: LD_INT 1
69945: NEG
69946: PUSH
69947: LD_INT 1
69949: NEG
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 1
69957: NEG
69958: PUSH
69959: LD_INT 2
69961: NEG
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PUSH
69967: LD_INT 0
69969: PUSH
69970: LD_INT 2
69972: NEG
69973: PUSH
69974: EMPTY
69975: LIST
69976: LIST
69977: PUSH
69978: LD_INT 1
69980: PUSH
69981: LD_INT 1
69983: NEG
69984: PUSH
69985: EMPTY
69986: LIST
69987: LIST
69988: PUSH
69989: LD_INT 2
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: LD_INT 2
70001: PUSH
70002: LD_INT 2
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: LD_INT 1
70011: PUSH
70012: LD_INT 2
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: PUSH
70019: LD_INT 0
70021: PUSH
70022: LD_INT 2
70024: PUSH
70025: EMPTY
70026: LIST
70027: LIST
70028: PUSH
70029: LD_INT 1
70031: NEG
70032: PUSH
70033: LD_INT 1
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 2
70042: NEG
70043: PUSH
70044: LD_INT 0
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 2
70053: NEG
70054: PUSH
70055: LD_INT 1
70057: NEG
70058: PUSH
70059: EMPTY
70060: LIST
70061: LIST
70062: PUSH
70063: LD_INT 1
70065: NEG
70066: PUSH
70067: LD_INT 3
70069: NEG
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 1
70077: PUSH
70078: LD_INT 2
70080: NEG
70081: PUSH
70082: EMPTY
70083: LIST
70084: LIST
70085: PUSH
70086: LD_INT 3
70088: PUSH
70089: LD_INT 2
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: PUSH
70096: LD_INT 2
70098: PUSH
70099: LD_INT 3
70101: PUSH
70102: EMPTY
70103: LIST
70104: LIST
70105: PUSH
70106: LD_INT 2
70108: NEG
70109: PUSH
70110: LD_INT 1
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: LD_INT 3
70119: NEG
70120: PUSH
70121: LD_INT 1
70123: NEG
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: PUSH
70129: EMPTY
70130: LIST
70131: LIST
70132: LIST
70133: LIST
70134: LIST
70135: LIST
70136: LIST
70137: LIST
70138: LIST
70139: LIST
70140: LIST
70141: LIST
70142: LIST
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: LIST
70148: LIST
70149: LIST
70150: LIST
70151: LIST
70152: LIST
70153: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70154: LD_ADDR_VAR 0 33
70158: PUSH
70159: LD_INT 0
70161: PUSH
70162: LD_INT 0
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: LD_INT 0
70171: PUSH
70172: LD_INT 1
70174: NEG
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PUSH
70180: LD_INT 1
70182: PUSH
70183: LD_INT 0
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 1
70192: PUSH
70193: LD_INT 1
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PUSH
70200: LD_INT 0
70202: PUSH
70203: LD_INT 1
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PUSH
70210: LD_INT 1
70212: NEG
70213: PUSH
70214: LD_INT 0
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 1
70223: NEG
70224: PUSH
70225: LD_INT 1
70227: NEG
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 1
70235: NEG
70236: PUSH
70237: LD_INT 2
70239: NEG
70240: PUSH
70241: EMPTY
70242: LIST
70243: LIST
70244: PUSH
70245: LD_INT 1
70247: PUSH
70248: LD_INT 1
70250: NEG
70251: PUSH
70252: EMPTY
70253: LIST
70254: LIST
70255: PUSH
70256: LD_INT 2
70258: PUSH
70259: LD_INT 0
70261: PUSH
70262: EMPTY
70263: LIST
70264: LIST
70265: PUSH
70266: LD_INT 2
70268: PUSH
70269: LD_INT 1
70271: PUSH
70272: EMPTY
70273: LIST
70274: LIST
70275: PUSH
70276: LD_INT 1
70278: PUSH
70279: LD_INT 2
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: PUSH
70286: LD_INT 0
70288: PUSH
70289: LD_INT 2
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: PUSH
70296: LD_INT 1
70298: NEG
70299: PUSH
70300: LD_INT 1
70302: PUSH
70303: EMPTY
70304: LIST
70305: LIST
70306: PUSH
70307: LD_INT 2
70309: NEG
70310: PUSH
70311: LD_INT 0
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: PUSH
70318: LD_INT 2
70320: NEG
70321: PUSH
70322: LD_INT 1
70324: NEG
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: PUSH
70330: LD_INT 2
70332: NEG
70333: PUSH
70334: LD_INT 2
70336: NEG
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PUSH
70342: LD_INT 2
70344: NEG
70345: PUSH
70346: LD_INT 3
70348: NEG
70349: PUSH
70350: EMPTY
70351: LIST
70352: LIST
70353: PUSH
70354: LD_INT 2
70356: PUSH
70357: LD_INT 1
70359: NEG
70360: PUSH
70361: EMPTY
70362: LIST
70363: LIST
70364: PUSH
70365: LD_INT 3
70367: PUSH
70368: LD_INT 1
70370: PUSH
70371: EMPTY
70372: LIST
70373: LIST
70374: PUSH
70375: LD_INT 1
70377: PUSH
70378: LD_INT 3
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: PUSH
70385: LD_INT 1
70387: NEG
70388: PUSH
70389: LD_INT 2
70391: PUSH
70392: EMPTY
70393: LIST
70394: LIST
70395: PUSH
70396: LD_INT 3
70398: NEG
70399: PUSH
70400: LD_INT 2
70402: NEG
70403: PUSH
70404: EMPTY
70405: LIST
70406: LIST
70407: PUSH
70408: EMPTY
70409: LIST
70410: LIST
70411: LIST
70412: LIST
70413: LIST
70414: LIST
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: LIST
70422: LIST
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70433: LD_ADDR_VAR 0 34
70437: PUSH
70438: LD_INT 0
70440: PUSH
70441: LD_INT 0
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 0
70450: PUSH
70451: LD_INT 1
70453: NEG
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 1
70461: PUSH
70462: LD_INT 0
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: LD_INT 1
70471: PUSH
70472: LD_INT 1
70474: PUSH
70475: EMPTY
70476: LIST
70477: LIST
70478: PUSH
70479: LD_INT 0
70481: PUSH
70482: LD_INT 1
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 1
70491: NEG
70492: PUSH
70493: LD_INT 0
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PUSH
70500: LD_INT 1
70502: NEG
70503: PUSH
70504: LD_INT 1
70506: NEG
70507: PUSH
70508: EMPTY
70509: LIST
70510: LIST
70511: PUSH
70512: LD_INT 1
70514: NEG
70515: PUSH
70516: LD_INT 2
70518: NEG
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 0
70526: PUSH
70527: LD_INT 2
70529: NEG
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 1
70537: PUSH
70538: LD_INT 1
70540: NEG
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 2
70548: PUSH
70549: LD_INT 1
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 2
70558: PUSH
70559: LD_INT 2
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: LD_INT 1
70568: PUSH
70569: LD_INT 2
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 1
70578: NEG
70579: PUSH
70580: LD_INT 1
70582: PUSH
70583: EMPTY
70584: LIST
70585: LIST
70586: PUSH
70587: LD_INT 2
70589: NEG
70590: PUSH
70591: LD_INT 0
70593: PUSH
70594: EMPTY
70595: LIST
70596: LIST
70597: PUSH
70598: LD_INT 2
70600: NEG
70601: PUSH
70602: LD_INT 1
70604: NEG
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 2
70612: NEG
70613: PUSH
70614: LD_INT 2
70616: NEG
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 1
70624: NEG
70625: PUSH
70626: LD_INT 3
70628: NEG
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: PUSH
70634: LD_INT 1
70636: PUSH
70637: LD_INT 2
70639: NEG
70640: PUSH
70641: EMPTY
70642: LIST
70643: LIST
70644: PUSH
70645: LD_INT 3
70647: PUSH
70648: LD_INT 2
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: LD_INT 2
70657: PUSH
70658: LD_INT 3
70660: PUSH
70661: EMPTY
70662: LIST
70663: LIST
70664: PUSH
70665: LD_INT 2
70667: NEG
70668: PUSH
70669: LD_INT 1
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: PUSH
70676: LD_INT 3
70678: NEG
70679: PUSH
70680: LD_INT 1
70682: NEG
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: LIST
70694: LIST
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: LIST
70703: LIST
70704: LIST
70705: LIST
70706: LIST
70707: LIST
70708: LIST
70709: LIST
70710: LIST
70711: LIST
70712: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70713: LD_ADDR_VAR 0 35
70717: PUSH
70718: LD_INT 0
70720: PUSH
70721: LD_INT 0
70723: PUSH
70724: EMPTY
70725: LIST
70726: LIST
70727: PUSH
70728: LD_INT 0
70730: PUSH
70731: LD_INT 1
70733: NEG
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 1
70741: PUSH
70742: LD_INT 0
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: LD_INT 1
70751: PUSH
70752: LD_INT 1
70754: PUSH
70755: EMPTY
70756: LIST
70757: LIST
70758: PUSH
70759: LD_INT 0
70761: PUSH
70762: LD_INT 1
70764: PUSH
70765: EMPTY
70766: LIST
70767: LIST
70768: PUSH
70769: LD_INT 1
70771: NEG
70772: PUSH
70773: LD_INT 0
70775: PUSH
70776: EMPTY
70777: LIST
70778: LIST
70779: PUSH
70780: LD_INT 1
70782: NEG
70783: PUSH
70784: LD_INT 1
70786: NEG
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: PUSH
70792: LD_INT 2
70794: PUSH
70795: LD_INT 1
70797: PUSH
70798: EMPTY
70799: LIST
70800: LIST
70801: PUSH
70802: LD_INT 2
70804: NEG
70805: PUSH
70806: LD_INT 1
70808: NEG
70809: PUSH
70810: EMPTY
70811: LIST
70812: LIST
70813: PUSH
70814: EMPTY
70815: LIST
70816: LIST
70817: LIST
70818: LIST
70819: LIST
70820: LIST
70821: LIST
70822: LIST
70823: LIST
70824: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70825: LD_ADDR_VAR 0 36
70829: PUSH
70830: LD_INT 0
70832: PUSH
70833: LD_INT 0
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: LD_INT 0
70842: PUSH
70843: LD_INT 1
70845: NEG
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 1
70853: PUSH
70854: LD_INT 0
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 1
70863: PUSH
70864: LD_INT 1
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: PUSH
70871: LD_INT 0
70873: PUSH
70874: LD_INT 1
70876: PUSH
70877: EMPTY
70878: LIST
70879: LIST
70880: PUSH
70881: LD_INT 1
70883: NEG
70884: PUSH
70885: LD_INT 0
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 1
70894: NEG
70895: PUSH
70896: LD_INT 1
70898: NEG
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 1
70906: NEG
70907: PUSH
70908: LD_INT 2
70910: NEG
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: PUSH
70916: LD_INT 1
70918: PUSH
70919: LD_INT 2
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: LIST
70930: LIST
70931: LIST
70932: LIST
70933: LIST
70934: LIST
70935: LIST
70936: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70937: LD_ADDR_VAR 0 37
70941: PUSH
70942: LD_INT 0
70944: PUSH
70945: LD_INT 0
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: PUSH
70952: LD_INT 0
70954: PUSH
70955: LD_INT 1
70957: NEG
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: PUSH
70963: LD_INT 1
70965: PUSH
70966: LD_INT 0
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: LD_INT 1
70975: PUSH
70976: LD_INT 1
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: PUSH
70983: LD_INT 0
70985: PUSH
70986: LD_INT 1
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 1
70995: NEG
70996: PUSH
70997: LD_INT 0
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: PUSH
71004: LD_INT 1
71006: NEG
71007: PUSH
71008: LD_INT 1
71010: NEG
71011: PUSH
71012: EMPTY
71013: LIST
71014: LIST
71015: PUSH
71016: LD_INT 1
71018: PUSH
71019: LD_INT 1
71021: NEG
71022: PUSH
71023: EMPTY
71024: LIST
71025: LIST
71026: PUSH
71027: LD_INT 1
71029: NEG
71030: PUSH
71031: LD_INT 1
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: LIST
71045: LIST
71046: LIST
71047: LIST
71048: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71049: LD_ADDR_VAR 0 38
71053: PUSH
71054: LD_INT 0
71056: PUSH
71057: LD_INT 0
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: PUSH
71064: LD_INT 0
71066: PUSH
71067: LD_INT 1
71069: NEG
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: LD_INT 1
71077: PUSH
71078: LD_INT 0
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 1
71087: PUSH
71088: LD_INT 1
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 0
71097: PUSH
71098: LD_INT 1
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: PUSH
71105: LD_INT 1
71107: NEG
71108: PUSH
71109: LD_INT 0
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: LD_INT 1
71118: NEG
71119: PUSH
71120: LD_INT 1
71122: NEG
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: LD_INT 2
71130: PUSH
71131: LD_INT 1
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 2
71140: NEG
71141: PUSH
71142: LD_INT 1
71144: NEG
71145: PUSH
71146: EMPTY
71147: LIST
71148: LIST
71149: PUSH
71150: EMPTY
71151: LIST
71152: LIST
71153: LIST
71154: LIST
71155: LIST
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71161: LD_ADDR_VAR 0 39
71165: PUSH
71166: LD_INT 0
71168: PUSH
71169: LD_INT 0
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: PUSH
71176: LD_INT 0
71178: PUSH
71179: LD_INT 1
71181: NEG
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: PUSH
71187: LD_INT 1
71189: PUSH
71190: LD_INT 0
71192: PUSH
71193: EMPTY
71194: LIST
71195: LIST
71196: PUSH
71197: LD_INT 1
71199: PUSH
71200: LD_INT 1
71202: PUSH
71203: EMPTY
71204: LIST
71205: LIST
71206: PUSH
71207: LD_INT 0
71209: PUSH
71210: LD_INT 1
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: PUSH
71217: LD_INT 1
71219: NEG
71220: PUSH
71221: LD_INT 0
71223: PUSH
71224: EMPTY
71225: LIST
71226: LIST
71227: PUSH
71228: LD_INT 1
71230: NEG
71231: PUSH
71232: LD_INT 1
71234: NEG
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: PUSH
71240: LD_INT 1
71242: NEG
71243: PUSH
71244: LD_INT 2
71246: NEG
71247: PUSH
71248: EMPTY
71249: LIST
71250: LIST
71251: PUSH
71252: LD_INT 1
71254: PUSH
71255: LD_INT 2
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71273: LD_ADDR_VAR 0 40
71277: PUSH
71278: LD_INT 0
71280: PUSH
71281: LD_INT 0
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: LD_INT 0
71290: PUSH
71291: LD_INT 1
71293: NEG
71294: PUSH
71295: EMPTY
71296: LIST
71297: LIST
71298: PUSH
71299: LD_INT 1
71301: PUSH
71302: LD_INT 0
71304: PUSH
71305: EMPTY
71306: LIST
71307: LIST
71308: PUSH
71309: LD_INT 1
71311: PUSH
71312: LD_INT 1
71314: PUSH
71315: EMPTY
71316: LIST
71317: LIST
71318: PUSH
71319: LD_INT 0
71321: PUSH
71322: LD_INT 1
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PUSH
71329: LD_INT 1
71331: NEG
71332: PUSH
71333: LD_INT 0
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: LD_INT 1
71342: NEG
71343: PUSH
71344: LD_INT 1
71346: NEG
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: PUSH
71352: LD_INT 1
71354: PUSH
71355: LD_INT 1
71357: NEG
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 1
71365: NEG
71366: PUSH
71367: LD_INT 1
71369: PUSH
71370: EMPTY
71371: LIST
71372: LIST
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71385: LD_ADDR_VAR 0 41
71389: PUSH
71390: LD_INT 0
71392: PUSH
71393: LD_INT 0
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: LD_INT 0
71402: PUSH
71403: LD_INT 1
71405: NEG
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: PUSH
71411: LD_INT 1
71413: PUSH
71414: LD_INT 0
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: PUSH
71421: LD_INT 1
71423: PUSH
71424: LD_INT 1
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: LD_INT 0
71433: PUSH
71434: LD_INT 1
71436: PUSH
71437: EMPTY
71438: LIST
71439: LIST
71440: PUSH
71441: LD_INT 1
71443: NEG
71444: PUSH
71445: LD_INT 0
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 1
71454: NEG
71455: PUSH
71456: LD_INT 1
71458: NEG
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: LD_INT 1
71466: NEG
71467: PUSH
71468: LD_INT 2
71470: NEG
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 1
71478: PUSH
71479: LD_INT 1
71481: NEG
71482: PUSH
71483: EMPTY
71484: LIST
71485: LIST
71486: PUSH
71487: LD_INT 2
71489: PUSH
71490: LD_INT 0
71492: PUSH
71493: EMPTY
71494: LIST
71495: LIST
71496: PUSH
71497: LD_INT 2
71499: PUSH
71500: LD_INT 1
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 2
71509: PUSH
71510: LD_INT 2
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: LD_INT 1
71519: PUSH
71520: LD_INT 2
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: PUSH
71527: LD_INT 1
71529: NEG
71530: PUSH
71531: LD_INT 1
71533: PUSH
71534: EMPTY
71535: LIST
71536: LIST
71537: PUSH
71538: LD_INT 2
71540: NEG
71541: PUSH
71542: LD_INT 0
71544: PUSH
71545: EMPTY
71546: LIST
71547: LIST
71548: PUSH
71549: LD_INT 2
71551: NEG
71552: PUSH
71553: LD_INT 1
71555: NEG
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 2
71563: NEG
71564: PUSH
71565: LD_INT 2
71567: NEG
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 2
71575: NEG
71576: PUSH
71577: LD_INT 3
71579: NEG
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: PUSH
71585: LD_INT 2
71587: PUSH
71588: LD_INT 1
71590: NEG
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: PUSH
71596: LD_INT 3
71598: PUSH
71599: LD_INT 0
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 3
71608: PUSH
71609: LD_INT 1
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: PUSH
71616: LD_INT 3
71618: PUSH
71619: LD_INT 2
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: PUSH
71626: LD_INT 3
71628: PUSH
71629: LD_INT 3
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PUSH
71636: LD_INT 2
71638: PUSH
71639: LD_INT 3
71641: PUSH
71642: EMPTY
71643: LIST
71644: LIST
71645: PUSH
71646: LD_INT 2
71648: NEG
71649: PUSH
71650: LD_INT 1
71652: PUSH
71653: EMPTY
71654: LIST
71655: LIST
71656: PUSH
71657: LD_INT 3
71659: NEG
71660: PUSH
71661: LD_INT 0
71663: PUSH
71664: EMPTY
71665: LIST
71666: LIST
71667: PUSH
71668: LD_INT 3
71670: NEG
71671: PUSH
71672: LD_INT 1
71674: NEG
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: LD_INT 3
71682: NEG
71683: PUSH
71684: LD_INT 2
71686: NEG
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 3
71694: NEG
71695: PUSH
71696: LD_INT 3
71698: NEG
71699: PUSH
71700: EMPTY
71701: LIST
71702: LIST
71703: PUSH
71704: EMPTY
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: LIST
71734: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71735: LD_ADDR_VAR 0 42
71739: PUSH
71740: LD_INT 0
71742: PUSH
71743: LD_INT 0
71745: PUSH
71746: EMPTY
71747: LIST
71748: LIST
71749: PUSH
71750: LD_INT 0
71752: PUSH
71753: LD_INT 1
71755: NEG
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 1
71763: PUSH
71764: LD_INT 0
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: PUSH
71771: LD_INT 1
71773: PUSH
71774: LD_INT 1
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: LD_INT 0
71783: PUSH
71784: LD_INT 1
71786: PUSH
71787: EMPTY
71788: LIST
71789: LIST
71790: PUSH
71791: LD_INT 1
71793: NEG
71794: PUSH
71795: LD_INT 0
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: PUSH
71802: LD_INT 1
71804: NEG
71805: PUSH
71806: LD_INT 1
71808: NEG
71809: PUSH
71810: EMPTY
71811: LIST
71812: LIST
71813: PUSH
71814: LD_INT 1
71816: NEG
71817: PUSH
71818: LD_INT 2
71820: NEG
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: LD_INT 0
71828: PUSH
71829: LD_INT 2
71831: NEG
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PUSH
71837: LD_INT 1
71839: PUSH
71840: LD_INT 1
71842: NEG
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 2
71850: PUSH
71851: LD_INT 1
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: PUSH
71858: LD_INT 2
71860: PUSH
71861: LD_INT 2
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: PUSH
71868: LD_INT 1
71870: PUSH
71871: LD_INT 2
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: LD_INT 0
71880: PUSH
71881: LD_INT 2
71883: PUSH
71884: EMPTY
71885: LIST
71886: LIST
71887: PUSH
71888: LD_INT 1
71890: NEG
71891: PUSH
71892: LD_INT 1
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: PUSH
71899: LD_INT 2
71901: NEG
71902: PUSH
71903: LD_INT 1
71905: NEG
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 2
71913: NEG
71914: PUSH
71915: LD_INT 2
71917: NEG
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 2
71925: NEG
71926: PUSH
71927: LD_INT 3
71929: NEG
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: LD_INT 1
71937: NEG
71938: PUSH
71939: LD_INT 3
71941: NEG
71942: PUSH
71943: EMPTY
71944: LIST
71945: LIST
71946: PUSH
71947: LD_INT 0
71949: PUSH
71950: LD_INT 3
71952: NEG
71953: PUSH
71954: EMPTY
71955: LIST
71956: LIST
71957: PUSH
71958: LD_INT 1
71960: PUSH
71961: LD_INT 2
71963: NEG
71964: PUSH
71965: EMPTY
71966: LIST
71967: LIST
71968: PUSH
71969: LD_INT 3
71971: PUSH
71972: LD_INT 2
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: LD_INT 3
71981: PUSH
71982: LD_INT 3
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: PUSH
71989: LD_INT 2
71991: PUSH
71992: LD_INT 3
71994: PUSH
71995: EMPTY
71996: LIST
71997: LIST
71998: PUSH
71999: LD_INT 1
72001: PUSH
72002: LD_INT 3
72004: PUSH
72005: EMPTY
72006: LIST
72007: LIST
72008: PUSH
72009: LD_INT 0
72011: PUSH
72012: LD_INT 3
72014: PUSH
72015: EMPTY
72016: LIST
72017: LIST
72018: PUSH
72019: LD_INT 1
72021: NEG
72022: PUSH
72023: LD_INT 2
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: PUSH
72030: LD_INT 3
72032: NEG
72033: PUSH
72034: LD_INT 2
72036: NEG
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: PUSH
72042: LD_INT 3
72044: NEG
72045: PUSH
72046: LD_INT 3
72048: NEG
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: LIST
72058: LIST
72059: LIST
72060: LIST
72061: LIST
72062: LIST
72063: LIST
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: LIST
72077: LIST
72078: LIST
72079: LIST
72080: LIST
72081: LIST
72082: LIST
72083: LIST
72084: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72085: LD_ADDR_VAR 0 43
72089: PUSH
72090: LD_INT 0
72092: PUSH
72093: LD_INT 0
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: PUSH
72100: LD_INT 0
72102: PUSH
72103: LD_INT 1
72105: NEG
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 1
72113: PUSH
72114: LD_INT 0
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: PUSH
72121: LD_INT 1
72123: PUSH
72124: LD_INT 1
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: PUSH
72131: LD_INT 0
72133: PUSH
72134: LD_INT 1
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: PUSH
72141: LD_INT 1
72143: NEG
72144: PUSH
72145: LD_INT 0
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PUSH
72152: LD_INT 1
72154: NEG
72155: PUSH
72156: LD_INT 1
72158: NEG
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: LD_INT 1
72166: NEG
72167: PUSH
72168: LD_INT 2
72170: NEG
72171: PUSH
72172: EMPTY
72173: LIST
72174: LIST
72175: PUSH
72176: LD_INT 0
72178: PUSH
72179: LD_INT 2
72181: NEG
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: PUSH
72187: LD_INT 1
72189: PUSH
72190: LD_INT 1
72192: NEG
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 2
72200: PUSH
72201: LD_INT 0
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 2
72210: PUSH
72211: LD_INT 1
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 1
72220: PUSH
72221: LD_INT 2
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: PUSH
72228: LD_INT 0
72230: PUSH
72231: LD_INT 2
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PUSH
72238: LD_INT 1
72240: NEG
72241: PUSH
72242: LD_INT 1
72244: PUSH
72245: EMPTY
72246: LIST
72247: LIST
72248: PUSH
72249: LD_INT 2
72251: NEG
72252: PUSH
72253: LD_INT 0
72255: PUSH
72256: EMPTY
72257: LIST
72258: LIST
72259: PUSH
72260: LD_INT 2
72262: NEG
72263: PUSH
72264: LD_INT 1
72266: NEG
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: PUSH
72272: LD_INT 1
72274: NEG
72275: PUSH
72276: LD_INT 3
72278: NEG
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 0
72286: PUSH
72287: LD_INT 3
72289: NEG
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 1
72297: PUSH
72298: LD_INT 2
72300: NEG
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: PUSH
72306: LD_INT 2
72308: PUSH
72309: LD_INT 1
72311: NEG
72312: PUSH
72313: EMPTY
72314: LIST
72315: LIST
72316: PUSH
72317: LD_INT 3
72319: PUSH
72320: LD_INT 0
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 3
72329: PUSH
72330: LD_INT 1
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 1
72339: PUSH
72340: LD_INT 3
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PUSH
72347: LD_INT 0
72349: PUSH
72350: LD_INT 3
72352: PUSH
72353: EMPTY
72354: LIST
72355: LIST
72356: PUSH
72357: LD_INT 1
72359: NEG
72360: PUSH
72361: LD_INT 2
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: PUSH
72368: LD_INT 2
72370: NEG
72371: PUSH
72372: LD_INT 1
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: PUSH
72379: LD_INT 3
72381: NEG
72382: PUSH
72383: LD_INT 0
72385: PUSH
72386: EMPTY
72387: LIST
72388: LIST
72389: PUSH
72390: LD_INT 3
72392: NEG
72393: PUSH
72394: LD_INT 1
72396: NEG
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: PUSH
72402: EMPTY
72403: LIST
72404: LIST
72405: LIST
72406: LIST
72407: LIST
72408: LIST
72409: LIST
72410: LIST
72411: LIST
72412: LIST
72413: LIST
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: LIST
72419: LIST
72420: LIST
72421: LIST
72422: LIST
72423: LIST
72424: LIST
72425: LIST
72426: LIST
72427: LIST
72428: LIST
72429: LIST
72430: LIST
72431: LIST
72432: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72433: LD_ADDR_VAR 0 44
72437: PUSH
72438: LD_INT 0
72440: PUSH
72441: LD_INT 0
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: PUSH
72448: LD_INT 0
72450: PUSH
72451: LD_INT 1
72453: NEG
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: LD_INT 1
72461: PUSH
72462: LD_INT 0
72464: PUSH
72465: EMPTY
72466: LIST
72467: LIST
72468: PUSH
72469: LD_INT 1
72471: PUSH
72472: LD_INT 1
72474: PUSH
72475: EMPTY
72476: LIST
72477: LIST
72478: PUSH
72479: LD_INT 0
72481: PUSH
72482: LD_INT 1
72484: PUSH
72485: EMPTY
72486: LIST
72487: LIST
72488: PUSH
72489: LD_INT 1
72491: NEG
72492: PUSH
72493: LD_INT 0
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: PUSH
72500: LD_INT 1
72502: NEG
72503: PUSH
72504: LD_INT 1
72506: NEG
72507: PUSH
72508: EMPTY
72509: LIST
72510: LIST
72511: PUSH
72512: LD_INT 1
72514: NEG
72515: PUSH
72516: LD_INT 2
72518: NEG
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PUSH
72524: LD_INT 1
72526: PUSH
72527: LD_INT 1
72529: NEG
72530: PUSH
72531: EMPTY
72532: LIST
72533: LIST
72534: PUSH
72535: LD_INT 2
72537: PUSH
72538: LD_INT 0
72540: PUSH
72541: EMPTY
72542: LIST
72543: LIST
72544: PUSH
72545: LD_INT 2
72547: PUSH
72548: LD_INT 1
72550: PUSH
72551: EMPTY
72552: LIST
72553: LIST
72554: PUSH
72555: LD_INT 2
72557: PUSH
72558: LD_INT 2
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: LD_INT 1
72567: PUSH
72568: LD_INT 2
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: PUSH
72575: LD_INT 1
72577: NEG
72578: PUSH
72579: LD_INT 1
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: PUSH
72586: LD_INT 2
72588: NEG
72589: PUSH
72590: LD_INT 0
72592: PUSH
72593: EMPTY
72594: LIST
72595: LIST
72596: PUSH
72597: LD_INT 2
72599: NEG
72600: PUSH
72601: LD_INT 1
72603: NEG
72604: PUSH
72605: EMPTY
72606: LIST
72607: LIST
72608: PUSH
72609: LD_INT 2
72611: NEG
72612: PUSH
72613: LD_INT 2
72615: NEG
72616: PUSH
72617: EMPTY
72618: LIST
72619: LIST
72620: PUSH
72621: LD_INT 2
72623: NEG
72624: PUSH
72625: LD_INT 3
72627: NEG
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 2
72635: PUSH
72636: LD_INT 1
72638: NEG
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 3
72646: PUSH
72647: LD_INT 0
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: PUSH
72654: LD_INT 3
72656: PUSH
72657: LD_INT 1
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: PUSH
72664: LD_INT 3
72666: PUSH
72667: LD_INT 2
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PUSH
72674: LD_INT 3
72676: PUSH
72677: LD_INT 3
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: PUSH
72684: LD_INT 2
72686: PUSH
72687: LD_INT 3
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 2
72696: NEG
72697: PUSH
72698: LD_INT 1
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: LD_INT 3
72707: NEG
72708: PUSH
72709: LD_INT 0
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: LD_INT 3
72718: NEG
72719: PUSH
72720: LD_INT 1
72722: NEG
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: PUSH
72728: LD_INT 3
72730: NEG
72731: PUSH
72732: LD_INT 2
72734: NEG
72735: PUSH
72736: EMPTY
72737: LIST
72738: LIST
72739: PUSH
72740: LD_INT 3
72742: NEG
72743: PUSH
72744: LD_INT 3
72746: NEG
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: LIST
72756: LIST
72757: LIST
72758: LIST
72759: LIST
72760: LIST
72761: LIST
72762: LIST
72763: LIST
72764: LIST
72765: LIST
72766: LIST
72767: LIST
72768: LIST
72769: LIST
72770: LIST
72771: LIST
72772: LIST
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: LIST
72778: LIST
72779: LIST
72780: LIST
72781: LIST
72782: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72783: LD_ADDR_VAR 0 45
72787: PUSH
72788: LD_INT 0
72790: PUSH
72791: LD_INT 0
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: LD_INT 0
72800: PUSH
72801: LD_INT 1
72803: NEG
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: PUSH
72809: LD_INT 1
72811: PUSH
72812: LD_INT 0
72814: PUSH
72815: EMPTY
72816: LIST
72817: LIST
72818: PUSH
72819: LD_INT 1
72821: PUSH
72822: LD_INT 1
72824: PUSH
72825: EMPTY
72826: LIST
72827: LIST
72828: PUSH
72829: LD_INT 0
72831: PUSH
72832: LD_INT 1
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 1
72841: NEG
72842: PUSH
72843: LD_INT 0
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: PUSH
72850: LD_INT 1
72852: NEG
72853: PUSH
72854: LD_INT 1
72856: NEG
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 1
72864: NEG
72865: PUSH
72866: LD_INT 2
72868: NEG
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 0
72876: PUSH
72877: LD_INT 2
72879: NEG
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 1
72887: PUSH
72888: LD_INT 1
72890: NEG
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 2
72898: PUSH
72899: LD_INT 1
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: LD_INT 2
72908: PUSH
72909: LD_INT 2
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 1
72918: PUSH
72919: LD_INT 2
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: LD_INT 0
72928: PUSH
72929: LD_INT 2
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 1
72938: NEG
72939: PUSH
72940: LD_INT 1
72942: PUSH
72943: EMPTY
72944: LIST
72945: LIST
72946: PUSH
72947: LD_INT 2
72949: NEG
72950: PUSH
72951: LD_INT 1
72953: NEG
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: PUSH
72959: LD_INT 2
72961: NEG
72962: PUSH
72963: LD_INT 2
72965: NEG
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 2
72973: NEG
72974: PUSH
72975: LD_INT 3
72977: NEG
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: PUSH
72983: LD_INT 1
72985: NEG
72986: PUSH
72987: LD_INT 3
72989: NEG
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: PUSH
72995: LD_INT 0
72997: PUSH
72998: LD_INT 3
73000: NEG
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: PUSH
73006: LD_INT 1
73008: PUSH
73009: LD_INT 2
73011: NEG
73012: PUSH
73013: EMPTY
73014: LIST
73015: LIST
73016: PUSH
73017: LD_INT 3
73019: PUSH
73020: LD_INT 2
73022: PUSH
73023: EMPTY
73024: LIST
73025: LIST
73026: PUSH
73027: LD_INT 3
73029: PUSH
73030: LD_INT 3
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: PUSH
73037: LD_INT 2
73039: PUSH
73040: LD_INT 3
73042: PUSH
73043: EMPTY
73044: LIST
73045: LIST
73046: PUSH
73047: LD_INT 1
73049: PUSH
73050: LD_INT 3
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: LD_INT 0
73059: PUSH
73060: LD_INT 3
73062: PUSH
73063: EMPTY
73064: LIST
73065: LIST
73066: PUSH
73067: LD_INT 1
73069: NEG
73070: PUSH
73071: LD_INT 2
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 3
73080: NEG
73081: PUSH
73082: LD_INT 2
73084: NEG
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 3
73092: NEG
73093: PUSH
73094: LD_INT 3
73096: NEG
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: LIST
73106: LIST
73107: LIST
73108: LIST
73109: LIST
73110: LIST
73111: LIST
73112: LIST
73113: LIST
73114: LIST
73115: LIST
73116: LIST
73117: LIST
73118: LIST
73119: LIST
73120: LIST
73121: LIST
73122: LIST
73123: LIST
73124: LIST
73125: LIST
73126: LIST
73127: LIST
73128: LIST
73129: LIST
73130: LIST
73131: LIST
73132: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73133: LD_ADDR_VAR 0 46
73137: PUSH
73138: LD_INT 0
73140: PUSH
73141: LD_INT 0
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 0
73150: PUSH
73151: LD_INT 1
73153: NEG
73154: PUSH
73155: EMPTY
73156: LIST
73157: LIST
73158: PUSH
73159: LD_INT 1
73161: PUSH
73162: LD_INT 0
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: PUSH
73169: LD_INT 1
73171: PUSH
73172: LD_INT 1
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: PUSH
73179: LD_INT 0
73181: PUSH
73182: LD_INT 1
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 1
73191: NEG
73192: PUSH
73193: LD_INT 0
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: PUSH
73200: LD_INT 1
73202: NEG
73203: PUSH
73204: LD_INT 1
73206: NEG
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 1
73214: NEG
73215: PUSH
73216: LD_INT 2
73218: NEG
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 0
73226: PUSH
73227: LD_INT 2
73229: NEG
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: PUSH
73235: LD_INT 1
73237: PUSH
73238: LD_INT 1
73240: NEG
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 2
73248: PUSH
73249: LD_INT 0
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PUSH
73256: LD_INT 2
73258: PUSH
73259: LD_INT 1
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: PUSH
73266: LD_INT 1
73268: PUSH
73269: LD_INT 2
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: PUSH
73276: LD_INT 0
73278: PUSH
73279: LD_INT 2
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: PUSH
73286: LD_INT 1
73288: NEG
73289: PUSH
73290: LD_INT 1
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: PUSH
73297: LD_INT 2
73299: NEG
73300: PUSH
73301: LD_INT 0
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: LD_INT 2
73310: NEG
73311: PUSH
73312: LD_INT 1
73314: NEG
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: LD_INT 1
73322: NEG
73323: PUSH
73324: LD_INT 3
73326: NEG
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: LD_INT 0
73334: PUSH
73335: LD_INT 3
73337: NEG
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: LD_INT 1
73345: PUSH
73346: LD_INT 2
73348: NEG
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 2
73356: PUSH
73357: LD_INT 1
73359: NEG
73360: PUSH
73361: EMPTY
73362: LIST
73363: LIST
73364: PUSH
73365: LD_INT 3
73367: PUSH
73368: LD_INT 0
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: PUSH
73375: LD_INT 3
73377: PUSH
73378: LD_INT 1
73380: PUSH
73381: EMPTY
73382: LIST
73383: LIST
73384: PUSH
73385: LD_INT 1
73387: PUSH
73388: LD_INT 3
73390: PUSH
73391: EMPTY
73392: LIST
73393: LIST
73394: PUSH
73395: LD_INT 0
73397: PUSH
73398: LD_INT 3
73400: PUSH
73401: EMPTY
73402: LIST
73403: LIST
73404: PUSH
73405: LD_INT 1
73407: NEG
73408: PUSH
73409: LD_INT 2
73411: PUSH
73412: EMPTY
73413: LIST
73414: LIST
73415: PUSH
73416: LD_INT 2
73418: NEG
73419: PUSH
73420: LD_INT 1
73422: PUSH
73423: EMPTY
73424: LIST
73425: LIST
73426: PUSH
73427: LD_INT 3
73429: NEG
73430: PUSH
73431: LD_INT 0
73433: PUSH
73434: EMPTY
73435: LIST
73436: LIST
73437: PUSH
73438: LD_INT 3
73440: NEG
73441: PUSH
73442: LD_INT 1
73444: NEG
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: PUSH
73450: EMPTY
73451: LIST
73452: LIST
73453: LIST
73454: LIST
73455: LIST
73456: LIST
73457: LIST
73458: LIST
73459: LIST
73460: LIST
73461: LIST
73462: LIST
73463: LIST
73464: LIST
73465: LIST
73466: LIST
73467: LIST
73468: LIST
73469: LIST
73470: LIST
73471: LIST
73472: LIST
73473: LIST
73474: LIST
73475: LIST
73476: LIST
73477: LIST
73478: LIST
73479: LIST
73480: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73481: LD_ADDR_VAR 0 47
73485: PUSH
73486: LD_INT 0
73488: PUSH
73489: LD_INT 0
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 0
73498: PUSH
73499: LD_INT 1
73501: NEG
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: PUSH
73507: LD_INT 1
73509: PUSH
73510: LD_INT 0
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 1
73519: PUSH
73520: LD_INT 1
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 0
73529: PUSH
73530: LD_INT 1
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: LD_INT 1
73539: NEG
73540: PUSH
73541: LD_INT 0
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 1
73550: NEG
73551: PUSH
73552: LD_INT 1
73554: NEG
73555: PUSH
73556: EMPTY
73557: LIST
73558: LIST
73559: PUSH
73560: LD_INT 1
73562: NEG
73563: PUSH
73564: LD_INT 2
73566: NEG
73567: PUSH
73568: EMPTY
73569: LIST
73570: LIST
73571: PUSH
73572: LD_INT 0
73574: PUSH
73575: LD_INT 2
73577: NEG
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: PUSH
73583: LD_INT 1
73585: PUSH
73586: LD_INT 1
73588: NEG
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 2
73596: NEG
73597: PUSH
73598: LD_INT 1
73600: NEG
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 2
73608: NEG
73609: PUSH
73610: LD_INT 2
73612: NEG
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: EMPTY
73619: LIST
73620: LIST
73621: LIST
73622: LIST
73623: LIST
73624: LIST
73625: LIST
73626: LIST
73627: LIST
73628: LIST
73629: LIST
73630: LIST
73631: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73632: LD_ADDR_VAR 0 48
73636: PUSH
73637: LD_INT 0
73639: PUSH
73640: LD_INT 0
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 0
73649: PUSH
73650: LD_INT 1
73652: NEG
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: PUSH
73658: LD_INT 1
73660: PUSH
73661: LD_INT 0
73663: PUSH
73664: EMPTY
73665: LIST
73666: LIST
73667: PUSH
73668: LD_INT 1
73670: PUSH
73671: LD_INT 1
73673: PUSH
73674: EMPTY
73675: LIST
73676: LIST
73677: PUSH
73678: LD_INT 0
73680: PUSH
73681: LD_INT 1
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: PUSH
73688: LD_INT 1
73690: NEG
73691: PUSH
73692: LD_INT 0
73694: PUSH
73695: EMPTY
73696: LIST
73697: LIST
73698: PUSH
73699: LD_INT 1
73701: NEG
73702: PUSH
73703: LD_INT 1
73705: NEG
73706: PUSH
73707: EMPTY
73708: LIST
73709: LIST
73710: PUSH
73711: LD_INT 1
73713: NEG
73714: PUSH
73715: LD_INT 2
73717: NEG
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 0
73725: PUSH
73726: LD_INT 2
73728: NEG
73729: PUSH
73730: EMPTY
73731: LIST
73732: LIST
73733: PUSH
73734: LD_INT 1
73736: PUSH
73737: LD_INT 1
73739: NEG
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: LD_INT 2
73747: PUSH
73748: LD_INT 0
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: LD_INT 2
73757: PUSH
73758: LD_INT 1
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: LIST
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: LIST
73778: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73779: LD_ADDR_VAR 0 49
73783: PUSH
73784: LD_INT 0
73786: PUSH
73787: LD_INT 0
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 0
73796: PUSH
73797: LD_INT 1
73799: NEG
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: PUSH
73805: LD_INT 1
73807: PUSH
73808: LD_INT 0
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 1
73817: PUSH
73818: LD_INT 1
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: PUSH
73825: LD_INT 0
73827: PUSH
73828: LD_INT 1
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 1
73837: NEG
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 1
73848: NEG
73849: PUSH
73850: LD_INT 1
73852: NEG
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PUSH
73858: LD_INT 1
73860: PUSH
73861: LD_INT 1
73863: NEG
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 2
73871: PUSH
73872: LD_INT 0
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: PUSH
73879: LD_INT 2
73881: PUSH
73882: LD_INT 1
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: LD_INT 2
73891: PUSH
73892: LD_INT 2
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 1
73901: PUSH
73902: LD_INT 2
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: LIST
73918: LIST
73919: LIST
73920: LIST
73921: LIST
73922: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73923: LD_ADDR_VAR 0 50
73927: PUSH
73928: LD_INT 0
73930: PUSH
73931: LD_INT 0
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: PUSH
73938: LD_INT 0
73940: PUSH
73941: LD_INT 1
73943: NEG
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: PUSH
73949: LD_INT 1
73951: PUSH
73952: LD_INT 0
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: PUSH
73959: LD_INT 1
73961: PUSH
73962: LD_INT 1
73964: PUSH
73965: EMPTY
73966: LIST
73967: LIST
73968: PUSH
73969: LD_INT 0
73971: PUSH
73972: LD_INT 1
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PUSH
73979: LD_INT 1
73981: NEG
73982: PUSH
73983: LD_INT 0
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PUSH
73990: LD_INT 1
73992: NEG
73993: PUSH
73994: LD_INT 1
73996: NEG
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PUSH
74002: LD_INT 2
74004: PUSH
74005: LD_INT 1
74007: PUSH
74008: EMPTY
74009: LIST
74010: LIST
74011: PUSH
74012: LD_INT 2
74014: PUSH
74015: LD_INT 2
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: PUSH
74022: LD_INT 1
74024: PUSH
74025: LD_INT 2
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: PUSH
74032: LD_INT 0
74034: PUSH
74035: LD_INT 2
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 1
74044: NEG
74045: PUSH
74046: LD_INT 1
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74067: LD_ADDR_VAR 0 51
74071: PUSH
74072: LD_INT 0
74074: PUSH
74075: LD_INT 0
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PUSH
74082: LD_INT 0
74084: PUSH
74085: LD_INT 1
74087: NEG
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: PUSH
74093: LD_INT 1
74095: PUSH
74096: LD_INT 0
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 1
74105: PUSH
74106: LD_INT 1
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: PUSH
74113: LD_INT 0
74115: PUSH
74116: LD_INT 1
74118: PUSH
74119: EMPTY
74120: LIST
74121: LIST
74122: PUSH
74123: LD_INT 1
74125: NEG
74126: PUSH
74127: LD_INT 0
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PUSH
74134: LD_INT 1
74136: NEG
74137: PUSH
74138: LD_INT 1
74140: NEG
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 1
74148: PUSH
74149: LD_INT 2
74151: PUSH
74152: EMPTY
74153: LIST
74154: LIST
74155: PUSH
74156: LD_INT 0
74158: PUSH
74159: LD_INT 2
74161: PUSH
74162: EMPTY
74163: LIST
74164: LIST
74165: PUSH
74166: LD_INT 1
74168: NEG
74169: PUSH
74170: LD_INT 1
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: PUSH
74177: LD_INT 2
74179: NEG
74180: PUSH
74181: LD_INT 0
74183: PUSH
74184: EMPTY
74185: LIST
74186: LIST
74187: PUSH
74188: LD_INT 2
74190: NEG
74191: PUSH
74192: LD_INT 1
74194: NEG
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: PUSH
74200: EMPTY
74201: LIST
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: LIST
74207: LIST
74208: LIST
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74214: LD_ADDR_VAR 0 52
74218: PUSH
74219: LD_INT 0
74221: PUSH
74222: LD_INT 0
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: LD_INT 0
74231: PUSH
74232: LD_INT 1
74234: NEG
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: PUSH
74240: LD_INT 1
74242: PUSH
74243: LD_INT 0
74245: PUSH
74246: EMPTY
74247: LIST
74248: LIST
74249: PUSH
74250: LD_INT 1
74252: PUSH
74253: LD_INT 1
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 0
74262: PUSH
74263: LD_INT 1
74265: PUSH
74266: EMPTY
74267: LIST
74268: LIST
74269: PUSH
74270: LD_INT 1
74272: NEG
74273: PUSH
74274: LD_INT 0
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: PUSH
74281: LD_INT 1
74283: NEG
74284: PUSH
74285: LD_INT 1
74287: NEG
74288: PUSH
74289: EMPTY
74290: LIST
74291: LIST
74292: PUSH
74293: LD_INT 1
74295: NEG
74296: PUSH
74297: LD_INT 2
74299: NEG
74300: PUSH
74301: EMPTY
74302: LIST
74303: LIST
74304: PUSH
74305: LD_INT 1
74307: NEG
74308: PUSH
74309: LD_INT 1
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 2
74318: NEG
74319: PUSH
74320: LD_INT 0
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: LD_INT 2
74329: NEG
74330: PUSH
74331: LD_INT 1
74333: NEG
74334: PUSH
74335: EMPTY
74336: LIST
74337: LIST
74338: PUSH
74339: LD_INT 2
74341: NEG
74342: PUSH
74343: LD_INT 2
74345: NEG
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: LIST
74355: LIST
74356: LIST
74357: LIST
74358: LIST
74359: LIST
74360: LIST
74361: LIST
74362: LIST
74363: LIST
74364: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74365: LD_ADDR_VAR 0 53
74369: PUSH
74370: LD_INT 0
74372: PUSH
74373: LD_INT 0
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: PUSH
74380: LD_INT 0
74382: PUSH
74383: LD_INT 1
74385: NEG
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: PUSH
74391: LD_INT 1
74393: PUSH
74394: LD_INT 0
74396: PUSH
74397: EMPTY
74398: LIST
74399: LIST
74400: PUSH
74401: LD_INT 1
74403: PUSH
74404: LD_INT 1
74406: PUSH
74407: EMPTY
74408: LIST
74409: LIST
74410: PUSH
74411: LD_INT 0
74413: PUSH
74414: LD_INT 1
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: PUSH
74421: LD_INT 1
74423: NEG
74424: PUSH
74425: LD_INT 0
74427: PUSH
74428: EMPTY
74429: LIST
74430: LIST
74431: PUSH
74432: LD_INT 1
74434: NEG
74435: PUSH
74436: LD_INT 1
74438: NEG
74439: PUSH
74440: EMPTY
74441: LIST
74442: LIST
74443: PUSH
74444: LD_INT 1
74446: NEG
74447: PUSH
74448: LD_INT 2
74450: NEG
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: LD_INT 0
74458: PUSH
74459: LD_INT 2
74461: NEG
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: PUSH
74467: LD_INT 1
74469: PUSH
74470: LD_INT 1
74472: NEG
74473: PUSH
74474: EMPTY
74475: LIST
74476: LIST
74477: PUSH
74478: LD_INT 2
74480: PUSH
74481: LD_INT 0
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 2
74490: PUSH
74491: LD_INT 1
74493: PUSH
74494: EMPTY
74495: LIST
74496: LIST
74497: PUSH
74498: LD_INT 2
74500: PUSH
74501: LD_INT 2
74503: PUSH
74504: EMPTY
74505: LIST
74506: LIST
74507: PUSH
74508: LD_INT 1
74510: PUSH
74511: LD_INT 2
74513: PUSH
74514: EMPTY
74515: LIST
74516: LIST
74517: PUSH
74518: LD_INT 0
74520: PUSH
74521: LD_INT 2
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PUSH
74528: LD_INT 1
74530: NEG
74531: PUSH
74532: LD_INT 1
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: PUSH
74539: LD_INT 2
74541: NEG
74542: PUSH
74543: LD_INT 0
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 2
74552: NEG
74553: PUSH
74554: LD_INT 1
74556: NEG
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: LD_INT 2
74564: NEG
74565: PUSH
74566: LD_INT 2
74568: NEG
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: PUSH
74574: EMPTY
74575: LIST
74576: LIST
74577: LIST
74578: LIST
74579: LIST
74580: LIST
74581: LIST
74582: LIST
74583: LIST
74584: LIST
74585: LIST
74586: LIST
74587: LIST
74588: LIST
74589: LIST
74590: LIST
74591: LIST
74592: LIST
74593: LIST
74594: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74595: LD_ADDR_VAR 0 54
74599: PUSH
74600: LD_INT 0
74602: PUSH
74603: LD_INT 0
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: LD_INT 0
74612: PUSH
74613: LD_INT 1
74615: NEG
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: PUSH
74621: LD_INT 1
74623: PUSH
74624: LD_INT 0
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 1
74633: PUSH
74634: LD_INT 1
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: LD_INT 0
74643: PUSH
74644: LD_INT 1
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: PUSH
74651: LD_INT 1
74653: NEG
74654: PUSH
74655: LD_INT 0
74657: PUSH
74658: EMPTY
74659: LIST
74660: LIST
74661: PUSH
74662: LD_INT 1
74664: NEG
74665: PUSH
74666: LD_INT 1
74668: NEG
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 1
74676: NEG
74677: PUSH
74678: LD_INT 2
74680: NEG
74681: PUSH
74682: EMPTY
74683: LIST
74684: LIST
74685: PUSH
74686: LD_INT 0
74688: PUSH
74689: LD_INT 2
74691: NEG
74692: PUSH
74693: EMPTY
74694: LIST
74695: LIST
74696: PUSH
74697: LD_INT 1
74699: PUSH
74700: LD_INT 1
74702: NEG
74703: PUSH
74704: EMPTY
74705: LIST
74706: LIST
74707: PUSH
74708: LD_INT 2
74710: PUSH
74711: LD_INT 0
74713: PUSH
74714: EMPTY
74715: LIST
74716: LIST
74717: PUSH
74718: LD_INT 2
74720: PUSH
74721: LD_INT 1
74723: PUSH
74724: EMPTY
74725: LIST
74726: LIST
74727: PUSH
74728: LD_INT 2
74730: PUSH
74731: LD_INT 2
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 1
74740: PUSH
74741: LD_INT 2
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: PUSH
74748: LD_INT 0
74750: PUSH
74751: LD_INT 2
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: PUSH
74758: LD_INT 1
74760: NEG
74761: PUSH
74762: LD_INT 1
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: LD_INT 2
74771: NEG
74772: PUSH
74773: LD_INT 0
74775: PUSH
74776: EMPTY
74777: LIST
74778: LIST
74779: PUSH
74780: LD_INT 2
74782: NEG
74783: PUSH
74784: LD_INT 1
74786: NEG
74787: PUSH
74788: EMPTY
74789: LIST
74790: LIST
74791: PUSH
74792: LD_INT 2
74794: NEG
74795: PUSH
74796: LD_INT 2
74798: NEG
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: LIST
74808: LIST
74809: LIST
74810: LIST
74811: LIST
74812: LIST
74813: LIST
74814: LIST
74815: LIST
74816: LIST
74817: LIST
74818: LIST
74819: LIST
74820: LIST
74821: LIST
74822: LIST
74823: LIST
74824: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74825: LD_ADDR_VAR 0 55
74829: PUSH
74830: LD_INT 0
74832: PUSH
74833: LD_INT 0
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: LD_INT 0
74842: PUSH
74843: LD_INT 1
74845: NEG
74846: PUSH
74847: EMPTY
74848: LIST
74849: LIST
74850: PUSH
74851: LD_INT 1
74853: PUSH
74854: LD_INT 0
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: LD_INT 1
74863: PUSH
74864: LD_INT 1
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 0
74873: PUSH
74874: LD_INT 1
74876: PUSH
74877: EMPTY
74878: LIST
74879: LIST
74880: PUSH
74881: LD_INT 1
74883: NEG
74884: PUSH
74885: LD_INT 0
74887: PUSH
74888: EMPTY
74889: LIST
74890: LIST
74891: PUSH
74892: LD_INT 1
74894: NEG
74895: PUSH
74896: LD_INT 1
74898: NEG
74899: PUSH
74900: EMPTY
74901: LIST
74902: LIST
74903: PUSH
74904: LD_INT 1
74906: NEG
74907: PUSH
74908: LD_INT 2
74910: NEG
74911: PUSH
74912: EMPTY
74913: LIST
74914: LIST
74915: PUSH
74916: LD_INT 0
74918: PUSH
74919: LD_INT 2
74921: NEG
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 1
74929: PUSH
74930: LD_INT 1
74932: NEG
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: PUSH
74938: LD_INT 2
74940: PUSH
74941: LD_INT 0
74943: PUSH
74944: EMPTY
74945: LIST
74946: LIST
74947: PUSH
74948: LD_INT 2
74950: PUSH
74951: LD_INT 1
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: PUSH
74958: LD_INT 2
74960: PUSH
74961: LD_INT 2
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: PUSH
74968: LD_INT 1
74970: PUSH
74971: LD_INT 2
74973: PUSH
74974: EMPTY
74975: LIST
74976: LIST
74977: PUSH
74978: LD_INT 0
74980: PUSH
74981: LD_INT 2
74983: PUSH
74984: EMPTY
74985: LIST
74986: LIST
74987: PUSH
74988: LD_INT 1
74990: NEG
74991: PUSH
74992: LD_INT 1
74994: PUSH
74995: EMPTY
74996: LIST
74997: LIST
74998: PUSH
74999: LD_INT 2
75001: NEG
75002: PUSH
75003: LD_INT 0
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: PUSH
75010: LD_INT 2
75012: NEG
75013: PUSH
75014: LD_INT 1
75016: NEG
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: PUSH
75022: LD_INT 2
75024: NEG
75025: PUSH
75026: LD_INT 2
75028: NEG
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: LIST
75038: LIST
75039: LIST
75040: LIST
75041: LIST
75042: LIST
75043: LIST
75044: LIST
75045: LIST
75046: LIST
75047: LIST
75048: LIST
75049: LIST
75050: LIST
75051: LIST
75052: LIST
75053: LIST
75054: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75055: LD_ADDR_VAR 0 56
75059: PUSH
75060: LD_INT 0
75062: PUSH
75063: LD_INT 0
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: LD_INT 0
75072: PUSH
75073: LD_INT 1
75075: NEG
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: LD_INT 1
75083: PUSH
75084: LD_INT 0
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: LD_INT 1
75093: PUSH
75094: LD_INT 1
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 0
75103: PUSH
75104: LD_INT 1
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: PUSH
75111: LD_INT 1
75113: NEG
75114: PUSH
75115: LD_INT 0
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: PUSH
75122: LD_INT 1
75124: NEG
75125: PUSH
75126: LD_INT 1
75128: NEG
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 1
75136: NEG
75137: PUSH
75138: LD_INT 2
75140: NEG
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 0
75148: PUSH
75149: LD_INT 2
75151: NEG
75152: PUSH
75153: EMPTY
75154: LIST
75155: LIST
75156: PUSH
75157: LD_INT 1
75159: PUSH
75160: LD_INT 1
75162: NEG
75163: PUSH
75164: EMPTY
75165: LIST
75166: LIST
75167: PUSH
75168: LD_INT 2
75170: PUSH
75171: LD_INT 0
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PUSH
75178: LD_INT 2
75180: PUSH
75181: LD_INT 1
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: PUSH
75188: LD_INT 2
75190: PUSH
75191: LD_INT 2
75193: PUSH
75194: EMPTY
75195: LIST
75196: LIST
75197: PUSH
75198: LD_INT 1
75200: PUSH
75201: LD_INT 2
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PUSH
75208: LD_INT 0
75210: PUSH
75211: LD_INT 2
75213: PUSH
75214: EMPTY
75215: LIST
75216: LIST
75217: PUSH
75218: LD_INT 1
75220: NEG
75221: PUSH
75222: LD_INT 1
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 2
75231: NEG
75232: PUSH
75233: LD_INT 0
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 2
75242: NEG
75243: PUSH
75244: LD_INT 1
75246: NEG
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: LD_INT 2
75254: NEG
75255: PUSH
75256: LD_INT 2
75258: NEG
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: LIST
75268: LIST
75269: LIST
75270: LIST
75271: LIST
75272: LIST
75273: LIST
75274: LIST
75275: LIST
75276: LIST
75277: LIST
75278: LIST
75279: LIST
75280: LIST
75281: LIST
75282: LIST
75283: LIST
75284: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75285: LD_ADDR_VAR 0 57
75289: PUSH
75290: LD_INT 0
75292: PUSH
75293: LD_INT 0
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 0
75302: PUSH
75303: LD_INT 1
75305: NEG
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: PUSH
75311: LD_INT 1
75313: PUSH
75314: LD_INT 0
75316: PUSH
75317: EMPTY
75318: LIST
75319: LIST
75320: PUSH
75321: LD_INT 1
75323: PUSH
75324: LD_INT 1
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: LD_INT 0
75333: PUSH
75334: LD_INT 1
75336: PUSH
75337: EMPTY
75338: LIST
75339: LIST
75340: PUSH
75341: LD_INT 1
75343: NEG
75344: PUSH
75345: LD_INT 0
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: LD_INT 1
75354: NEG
75355: PUSH
75356: LD_INT 1
75358: NEG
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: LD_INT 1
75366: NEG
75367: PUSH
75368: LD_INT 2
75370: NEG
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 0
75378: PUSH
75379: LD_INT 2
75381: NEG
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: PUSH
75387: LD_INT 1
75389: PUSH
75390: LD_INT 1
75392: NEG
75393: PUSH
75394: EMPTY
75395: LIST
75396: LIST
75397: PUSH
75398: LD_INT 2
75400: PUSH
75401: LD_INT 0
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PUSH
75408: LD_INT 2
75410: PUSH
75411: LD_INT 1
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 2
75420: PUSH
75421: LD_INT 2
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 1
75430: PUSH
75431: LD_INT 2
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 0
75440: PUSH
75441: LD_INT 2
75443: PUSH
75444: EMPTY
75445: LIST
75446: LIST
75447: PUSH
75448: LD_INT 1
75450: NEG
75451: PUSH
75452: LD_INT 1
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: PUSH
75459: LD_INT 2
75461: NEG
75462: PUSH
75463: LD_INT 0
75465: PUSH
75466: EMPTY
75467: LIST
75468: LIST
75469: PUSH
75470: LD_INT 2
75472: NEG
75473: PUSH
75474: LD_INT 1
75476: NEG
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PUSH
75482: LD_INT 2
75484: NEG
75485: PUSH
75486: LD_INT 2
75488: NEG
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: LIST
75500: LIST
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: LIST
75506: LIST
75507: LIST
75508: LIST
75509: LIST
75510: LIST
75511: LIST
75512: LIST
75513: LIST
75514: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75515: LD_ADDR_VAR 0 58
75519: PUSH
75520: LD_INT 0
75522: PUSH
75523: LD_INT 0
75525: PUSH
75526: EMPTY
75527: LIST
75528: LIST
75529: PUSH
75530: LD_INT 0
75532: PUSH
75533: LD_INT 1
75535: NEG
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: LD_INT 1
75543: PUSH
75544: LD_INT 0
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PUSH
75551: LD_INT 1
75553: PUSH
75554: LD_INT 1
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 0
75563: PUSH
75564: LD_INT 1
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 1
75573: NEG
75574: PUSH
75575: LD_INT 0
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 1
75584: NEG
75585: PUSH
75586: LD_INT 1
75588: NEG
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 1
75596: NEG
75597: PUSH
75598: LD_INT 2
75600: NEG
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: PUSH
75606: LD_INT 0
75608: PUSH
75609: LD_INT 2
75611: NEG
75612: PUSH
75613: EMPTY
75614: LIST
75615: LIST
75616: PUSH
75617: LD_INT 1
75619: PUSH
75620: LD_INT 1
75622: NEG
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 2
75630: PUSH
75631: LD_INT 0
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 2
75640: PUSH
75641: LD_INT 1
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 2
75650: PUSH
75651: LD_INT 2
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 1
75660: PUSH
75661: LD_INT 2
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 0
75670: PUSH
75671: LD_INT 2
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: LD_INT 1
75680: NEG
75681: PUSH
75682: LD_INT 1
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PUSH
75689: LD_INT 2
75691: NEG
75692: PUSH
75693: LD_INT 0
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: LD_INT 2
75702: NEG
75703: PUSH
75704: LD_INT 1
75706: NEG
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: LD_INT 2
75714: NEG
75715: PUSH
75716: LD_INT 2
75718: NEG
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: LIST
75730: LIST
75731: LIST
75732: LIST
75733: LIST
75734: LIST
75735: LIST
75736: LIST
75737: LIST
75738: LIST
75739: LIST
75740: LIST
75741: LIST
75742: LIST
75743: LIST
75744: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75745: LD_ADDR_VAR 0 59
75749: PUSH
75750: LD_INT 0
75752: PUSH
75753: LD_INT 0
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 0
75762: PUSH
75763: LD_INT 1
75765: NEG
75766: PUSH
75767: EMPTY
75768: LIST
75769: LIST
75770: PUSH
75771: LD_INT 1
75773: PUSH
75774: LD_INT 0
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: PUSH
75781: LD_INT 1
75783: PUSH
75784: LD_INT 1
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: PUSH
75791: LD_INT 0
75793: PUSH
75794: LD_INT 1
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: LD_INT 1
75803: NEG
75804: PUSH
75805: LD_INT 0
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: PUSH
75812: LD_INT 1
75814: NEG
75815: PUSH
75816: LD_INT 1
75818: NEG
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: LIST
75828: LIST
75829: LIST
75830: LIST
75831: LIST
75832: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75833: LD_ADDR_VAR 0 60
75837: PUSH
75838: LD_INT 0
75840: PUSH
75841: LD_INT 0
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 0
75850: PUSH
75851: LD_INT 1
75853: NEG
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: LD_INT 1
75861: PUSH
75862: LD_INT 0
75864: PUSH
75865: EMPTY
75866: LIST
75867: LIST
75868: PUSH
75869: LD_INT 1
75871: PUSH
75872: LD_INT 1
75874: PUSH
75875: EMPTY
75876: LIST
75877: LIST
75878: PUSH
75879: LD_INT 0
75881: PUSH
75882: LD_INT 1
75884: PUSH
75885: EMPTY
75886: LIST
75887: LIST
75888: PUSH
75889: LD_INT 1
75891: NEG
75892: PUSH
75893: LD_INT 0
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: LD_INT 1
75902: NEG
75903: PUSH
75904: LD_INT 1
75906: NEG
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: LIST
75916: LIST
75917: LIST
75918: LIST
75919: LIST
75920: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75921: LD_ADDR_VAR 0 61
75925: PUSH
75926: LD_INT 0
75928: PUSH
75929: LD_INT 0
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: PUSH
75936: LD_INT 0
75938: PUSH
75939: LD_INT 1
75941: NEG
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: LD_INT 1
75949: PUSH
75950: LD_INT 0
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: LD_INT 1
75959: PUSH
75960: LD_INT 1
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PUSH
75967: LD_INT 0
75969: PUSH
75970: LD_INT 1
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 1
75979: NEG
75980: PUSH
75981: LD_INT 0
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 1
75990: NEG
75991: PUSH
75992: LD_INT 1
75994: NEG
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: EMPTY
76001: LIST
76002: LIST
76003: LIST
76004: LIST
76005: LIST
76006: LIST
76007: LIST
76008: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76009: LD_ADDR_VAR 0 62
76013: PUSH
76014: LD_INT 0
76016: PUSH
76017: LD_INT 0
76019: PUSH
76020: EMPTY
76021: LIST
76022: LIST
76023: PUSH
76024: LD_INT 0
76026: PUSH
76027: LD_INT 1
76029: NEG
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: PUSH
76035: LD_INT 1
76037: PUSH
76038: LD_INT 0
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: PUSH
76045: LD_INT 1
76047: PUSH
76048: LD_INT 1
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: PUSH
76055: LD_INT 0
76057: PUSH
76058: LD_INT 1
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: LD_INT 1
76067: NEG
76068: PUSH
76069: LD_INT 0
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PUSH
76076: LD_INT 1
76078: NEG
76079: PUSH
76080: LD_INT 1
76082: NEG
76083: PUSH
76084: EMPTY
76085: LIST
76086: LIST
76087: PUSH
76088: EMPTY
76089: LIST
76090: LIST
76091: LIST
76092: LIST
76093: LIST
76094: LIST
76095: LIST
76096: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76097: LD_ADDR_VAR 0 63
76101: PUSH
76102: LD_INT 0
76104: PUSH
76105: LD_INT 0
76107: PUSH
76108: EMPTY
76109: LIST
76110: LIST
76111: PUSH
76112: LD_INT 0
76114: PUSH
76115: LD_INT 1
76117: NEG
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 1
76125: PUSH
76126: LD_INT 0
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 1
76135: PUSH
76136: LD_INT 1
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 0
76145: PUSH
76146: LD_INT 1
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 1
76155: NEG
76156: PUSH
76157: LD_INT 0
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 1
76166: NEG
76167: PUSH
76168: LD_INT 1
76170: NEG
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: LIST
76180: LIST
76181: LIST
76182: LIST
76183: LIST
76184: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76185: LD_ADDR_VAR 0 64
76189: PUSH
76190: LD_INT 0
76192: PUSH
76193: LD_INT 0
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: LD_INT 0
76202: PUSH
76203: LD_INT 1
76205: NEG
76206: PUSH
76207: EMPTY
76208: LIST
76209: LIST
76210: PUSH
76211: LD_INT 1
76213: PUSH
76214: LD_INT 0
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: PUSH
76221: LD_INT 1
76223: PUSH
76224: LD_INT 1
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 0
76233: PUSH
76234: LD_INT 1
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: PUSH
76241: LD_INT 1
76243: NEG
76244: PUSH
76245: LD_INT 0
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: PUSH
76252: LD_INT 1
76254: NEG
76255: PUSH
76256: LD_INT 1
76258: NEG
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: LIST
76268: LIST
76269: LIST
76270: LIST
76271: LIST
76272: ST_TO_ADDR
// end ; 1 :
76273: GO 82170
76275: LD_INT 1
76277: DOUBLE
76278: EQUAL
76279: IFTRUE 76283
76281: GO 78906
76283: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76284: LD_ADDR_VAR 0 11
76288: PUSH
76289: LD_INT 1
76291: NEG
76292: PUSH
76293: LD_INT 3
76295: NEG
76296: PUSH
76297: EMPTY
76298: LIST
76299: LIST
76300: PUSH
76301: LD_INT 0
76303: PUSH
76304: LD_INT 3
76306: NEG
76307: PUSH
76308: EMPTY
76309: LIST
76310: LIST
76311: PUSH
76312: LD_INT 1
76314: PUSH
76315: LD_INT 2
76317: NEG
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: LIST
76327: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76328: LD_ADDR_VAR 0 12
76332: PUSH
76333: LD_INT 2
76335: PUSH
76336: LD_INT 1
76338: NEG
76339: PUSH
76340: EMPTY
76341: LIST
76342: LIST
76343: PUSH
76344: LD_INT 3
76346: PUSH
76347: LD_INT 0
76349: PUSH
76350: EMPTY
76351: LIST
76352: LIST
76353: PUSH
76354: LD_INT 3
76356: PUSH
76357: LD_INT 1
76359: PUSH
76360: EMPTY
76361: LIST
76362: LIST
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: LIST
76368: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76369: LD_ADDR_VAR 0 13
76373: PUSH
76374: LD_INT 3
76376: PUSH
76377: LD_INT 2
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: LD_INT 3
76386: PUSH
76387: LD_INT 3
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: PUSH
76394: LD_INT 2
76396: PUSH
76397: LD_INT 3
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: EMPTY
76405: LIST
76406: LIST
76407: LIST
76408: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76409: LD_ADDR_VAR 0 14
76413: PUSH
76414: LD_INT 1
76416: PUSH
76417: LD_INT 3
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: PUSH
76424: LD_INT 0
76426: PUSH
76427: LD_INT 3
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: PUSH
76434: LD_INT 1
76436: NEG
76437: PUSH
76438: LD_INT 2
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: LIST
76449: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76450: LD_ADDR_VAR 0 15
76454: PUSH
76455: LD_INT 2
76457: NEG
76458: PUSH
76459: LD_INT 1
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 3
76468: NEG
76469: PUSH
76470: LD_INT 0
76472: PUSH
76473: EMPTY
76474: LIST
76475: LIST
76476: PUSH
76477: LD_INT 3
76479: NEG
76480: PUSH
76481: LD_INT 1
76483: NEG
76484: PUSH
76485: EMPTY
76486: LIST
76487: LIST
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: LIST
76493: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76494: LD_ADDR_VAR 0 16
76498: PUSH
76499: LD_INT 2
76501: NEG
76502: PUSH
76503: LD_INT 3
76505: NEG
76506: PUSH
76507: EMPTY
76508: LIST
76509: LIST
76510: PUSH
76511: LD_INT 3
76513: NEG
76514: PUSH
76515: LD_INT 2
76517: NEG
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: LD_INT 3
76525: NEG
76526: PUSH
76527: LD_INT 3
76529: NEG
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: LIST
76539: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76540: LD_ADDR_VAR 0 17
76544: PUSH
76545: LD_INT 1
76547: NEG
76548: PUSH
76549: LD_INT 3
76551: NEG
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: PUSH
76557: LD_INT 0
76559: PUSH
76560: LD_INT 3
76562: NEG
76563: PUSH
76564: EMPTY
76565: LIST
76566: LIST
76567: PUSH
76568: LD_INT 1
76570: PUSH
76571: LD_INT 2
76573: NEG
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: LIST
76583: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76584: LD_ADDR_VAR 0 18
76588: PUSH
76589: LD_INT 2
76591: PUSH
76592: LD_INT 1
76594: NEG
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PUSH
76600: LD_INT 3
76602: PUSH
76603: LD_INT 0
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 3
76612: PUSH
76613: LD_INT 1
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: LIST
76624: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76625: LD_ADDR_VAR 0 19
76629: PUSH
76630: LD_INT 3
76632: PUSH
76633: LD_INT 2
76635: PUSH
76636: EMPTY
76637: LIST
76638: LIST
76639: PUSH
76640: LD_INT 3
76642: PUSH
76643: LD_INT 3
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 2
76652: PUSH
76653: LD_INT 3
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: LIST
76664: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76665: LD_ADDR_VAR 0 20
76669: PUSH
76670: LD_INT 1
76672: PUSH
76673: LD_INT 3
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: PUSH
76680: LD_INT 0
76682: PUSH
76683: LD_INT 3
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 1
76692: NEG
76693: PUSH
76694: LD_INT 2
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: LIST
76705: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76706: LD_ADDR_VAR 0 21
76710: PUSH
76711: LD_INT 2
76713: NEG
76714: PUSH
76715: LD_INT 1
76717: PUSH
76718: EMPTY
76719: LIST
76720: LIST
76721: PUSH
76722: LD_INT 3
76724: NEG
76725: PUSH
76726: LD_INT 0
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PUSH
76733: LD_INT 3
76735: NEG
76736: PUSH
76737: LD_INT 1
76739: NEG
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: LIST
76749: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76750: LD_ADDR_VAR 0 22
76754: PUSH
76755: LD_INT 2
76757: NEG
76758: PUSH
76759: LD_INT 3
76761: NEG
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: PUSH
76767: LD_INT 3
76769: NEG
76770: PUSH
76771: LD_INT 2
76773: NEG
76774: PUSH
76775: EMPTY
76776: LIST
76777: LIST
76778: PUSH
76779: LD_INT 3
76781: NEG
76782: PUSH
76783: LD_INT 3
76785: NEG
76786: PUSH
76787: EMPTY
76788: LIST
76789: LIST
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: LIST
76795: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76796: LD_ADDR_VAR 0 23
76800: PUSH
76801: LD_INT 0
76803: PUSH
76804: LD_INT 3
76806: NEG
76807: PUSH
76808: EMPTY
76809: LIST
76810: LIST
76811: PUSH
76812: LD_INT 1
76814: NEG
76815: PUSH
76816: LD_INT 4
76818: NEG
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PUSH
76824: LD_INT 1
76826: PUSH
76827: LD_INT 3
76829: NEG
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PUSH
76835: EMPTY
76836: LIST
76837: LIST
76838: LIST
76839: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76840: LD_ADDR_VAR 0 24
76844: PUSH
76845: LD_INT 3
76847: PUSH
76848: LD_INT 0
76850: PUSH
76851: EMPTY
76852: LIST
76853: LIST
76854: PUSH
76855: LD_INT 3
76857: PUSH
76858: LD_INT 1
76860: NEG
76861: PUSH
76862: EMPTY
76863: LIST
76864: LIST
76865: PUSH
76866: LD_INT 4
76868: PUSH
76869: LD_INT 1
76871: PUSH
76872: EMPTY
76873: LIST
76874: LIST
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: LIST
76880: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76881: LD_ADDR_VAR 0 25
76885: PUSH
76886: LD_INT 3
76888: PUSH
76889: LD_INT 3
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 4
76898: PUSH
76899: LD_INT 3
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 3
76908: PUSH
76909: LD_INT 4
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: LIST
76920: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
76921: LD_ADDR_VAR 0 26
76925: PUSH
76926: LD_INT 0
76928: PUSH
76929: LD_INT 3
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PUSH
76936: LD_INT 1
76938: PUSH
76939: LD_INT 4
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: PUSH
76946: LD_INT 1
76948: NEG
76949: PUSH
76950: LD_INT 3
76952: PUSH
76953: EMPTY
76954: LIST
76955: LIST
76956: PUSH
76957: EMPTY
76958: LIST
76959: LIST
76960: LIST
76961: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
76962: LD_ADDR_VAR 0 27
76966: PUSH
76967: LD_INT 3
76969: NEG
76970: PUSH
76971: LD_INT 0
76973: PUSH
76974: EMPTY
76975: LIST
76976: LIST
76977: PUSH
76978: LD_INT 3
76980: NEG
76981: PUSH
76982: LD_INT 1
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: PUSH
76989: LD_INT 4
76991: NEG
76992: PUSH
76993: LD_INT 1
76995: NEG
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: LIST
77005: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
77006: LD_ADDR_VAR 0 28
77010: PUSH
77011: LD_INT 3
77013: NEG
77014: PUSH
77015: LD_INT 3
77017: NEG
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: LD_INT 3
77025: NEG
77026: PUSH
77027: LD_INT 4
77029: NEG
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: PUSH
77035: LD_INT 4
77037: NEG
77038: PUSH
77039: LD_INT 3
77041: NEG
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: LIST
77051: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77052: LD_ADDR_VAR 0 29
77056: PUSH
77057: LD_INT 1
77059: NEG
77060: PUSH
77061: LD_INT 3
77063: NEG
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: PUSH
77069: LD_INT 0
77071: PUSH
77072: LD_INT 3
77074: NEG
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: PUSH
77080: LD_INT 1
77082: PUSH
77083: LD_INT 2
77085: NEG
77086: PUSH
77087: EMPTY
77088: LIST
77089: LIST
77090: PUSH
77091: LD_INT 1
77093: NEG
77094: PUSH
77095: LD_INT 4
77097: NEG
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: PUSH
77103: LD_INT 0
77105: PUSH
77106: LD_INT 4
77108: NEG
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PUSH
77114: LD_INT 1
77116: PUSH
77117: LD_INT 3
77119: NEG
77120: PUSH
77121: EMPTY
77122: LIST
77123: LIST
77124: PUSH
77125: LD_INT 1
77127: NEG
77128: PUSH
77129: LD_INT 5
77131: NEG
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 0
77139: PUSH
77140: LD_INT 5
77142: NEG
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: LD_INT 1
77150: PUSH
77151: LD_INT 4
77153: NEG
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: LD_INT 1
77161: NEG
77162: PUSH
77163: LD_INT 6
77165: NEG
77166: PUSH
77167: EMPTY
77168: LIST
77169: LIST
77170: PUSH
77171: LD_INT 0
77173: PUSH
77174: LD_INT 6
77176: NEG
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PUSH
77182: LD_INT 1
77184: PUSH
77185: LD_INT 5
77187: NEG
77188: PUSH
77189: EMPTY
77190: LIST
77191: LIST
77192: PUSH
77193: EMPTY
77194: LIST
77195: LIST
77196: LIST
77197: LIST
77198: LIST
77199: LIST
77200: LIST
77201: LIST
77202: LIST
77203: LIST
77204: LIST
77205: LIST
77206: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
77207: LD_ADDR_VAR 0 30
77211: PUSH
77212: LD_INT 2
77214: PUSH
77215: LD_INT 1
77217: NEG
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: LD_INT 3
77225: PUSH
77226: LD_INT 0
77228: PUSH
77229: EMPTY
77230: LIST
77231: LIST
77232: PUSH
77233: LD_INT 3
77235: PUSH
77236: LD_INT 1
77238: PUSH
77239: EMPTY
77240: LIST
77241: LIST
77242: PUSH
77243: LD_INT 3
77245: PUSH
77246: LD_INT 1
77248: NEG
77249: PUSH
77250: EMPTY
77251: LIST
77252: LIST
77253: PUSH
77254: LD_INT 4
77256: PUSH
77257: LD_INT 0
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: PUSH
77264: LD_INT 4
77266: PUSH
77267: LD_INT 1
77269: PUSH
77270: EMPTY
77271: LIST
77272: LIST
77273: PUSH
77274: LD_INT 4
77276: PUSH
77277: LD_INT 1
77279: NEG
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: LD_INT 5
77287: PUSH
77288: LD_INT 0
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 5
77297: PUSH
77298: LD_INT 1
77300: PUSH
77301: EMPTY
77302: LIST
77303: LIST
77304: PUSH
77305: LD_INT 5
77307: PUSH
77308: LD_INT 1
77310: NEG
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 6
77318: PUSH
77319: LD_INT 0
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 6
77328: PUSH
77329: LD_INT 1
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: LIST
77340: LIST
77341: LIST
77342: LIST
77343: LIST
77344: LIST
77345: LIST
77346: LIST
77347: LIST
77348: LIST
77349: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
77350: LD_ADDR_VAR 0 31
77354: PUSH
77355: LD_INT 3
77357: PUSH
77358: LD_INT 2
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 3
77367: PUSH
77368: LD_INT 3
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: LD_INT 2
77377: PUSH
77378: LD_INT 3
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: PUSH
77385: LD_INT 4
77387: PUSH
77388: LD_INT 3
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: PUSH
77395: LD_INT 4
77397: PUSH
77398: LD_INT 4
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 3
77407: PUSH
77408: LD_INT 4
77410: PUSH
77411: EMPTY
77412: LIST
77413: LIST
77414: PUSH
77415: LD_INT 5
77417: PUSH
77418: LD_INT 4
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: LD_INT 5
77427: PUSH
77428: LD_INT 5
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: LD_INT 4
77437: PUSH
77438: LD_INT 5
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: PUSH
77445: LD_INT 6
77447: PUSH
77448: LD_INT 5
77450: PUSH
77451: EMPTY
77452: LIST
77453: LIST
77454: PUSH
77455: LD_INT 6
77457: PUSH
77458: LD_INT 6
77460: PUSH
77461: EMPTY
77462: LIST
77463: LIST
77464: PUSH
77465: LD_INT 5
77467: PUSH
77468: LD_INT 6
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: LIST
77479: LIST
77480: LIST
77481: LIST
77482: LIST
77483: LIST
77484: LIST
77485: LIST
77486: LIST
77487: LIST
77488: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
77489: LD_ADDR_VAR 0 32
77493: PUSH
77494: LD_INT 1
77496: PUSH
77497: LD_INT 3
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: LD_INT 0
77506: PUSH
77507: LD_INT 3
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 1
77516: NEG
77517: PUSH
77518: LD_INT 2
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: LD_INT 1
77527: PUSH
77528: LD_INT 4
77530: PUSH
77531: EMPTY
77532: LIST
77533: LIST
77534: PUSH
77535: LD_INT 0
77537: PUSH
77538: LD_INT 4
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: PUSH
77545: LD_INT 1
77547: NEG
77548: PUSH
77549: LD_INT 3
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: PUSH
77556: LD_INT 1
77558: PUSH
77559: LD_INT 5
77561: PUSH
77562: EMPTY
77563: LIST
77564: LIST
77565: PUSH
77566: LD_INT 0
77568: PUSH
77569: LD_INT 5
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: PUSH
77576: LD_INT 1
77578: NEG
77579: PUSH
77580: LD_INT 4
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 1
77589: PUSH
77590: LD_INT 6
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: PUSH
77597: LD_INT 0
77599: PUSH
77600: LD_INT 6
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: PUSH
77607: LD_INT 1
77609: NEG
77610: PUSH
77611: LD_INT 5
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PUSH
77618: EMPTY
77619: LIST
77620: LIST
77621: LIST
77622: LIST
77623: LIST
77624: LIST
77625: LIST
77626: LIST
77627: LIST
77628: LIST
77629: LIST
77630: LIST
77631: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
77632: LD_ADDR_VAR 0 33
77636: PUSH
77637: LD_INT 2
77639: NEG
77640: PUSH
77641: LD_INT 1
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: PUSH
77648: LD_INT 3
77650: NEG
77651: PUSH
77652: LD_INT 0
77654: PUSH
77655: EMPTY
77656: LIST
77657: LIST
77658: PUSH
77659: LD_INT 3
77661: NEG
77662: PUSH
77663: LD_INT 1
77665: NEG
77666: PUSH
77667: EMPTY
77668: LIST
77669: LIST
77670: PUSH
77671: LD_INT 3
77673: NEG
77674: PUSH
77675: LD_INT 1
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PUSH
77682: LD_INT 4
77684: NEG
77685: PUSH
77686: LD_INT 0
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 4
77695: NEG
77696: PUSH
77697: LD_INT 1
77699: NEG
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PUSH
77705: LD_INT 4
77707: NEG
77708: PUSH
77709: LD_INT 1
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 5
77718: NEG
77719: PUSH
77720: LD_INT 0
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: LD_INT 5
77729: NEG
77730: PUSH
77731: LD_INT 1
77733: NEG
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 5
77741: NEG
77742: PUSH
77743: LD_INT 1
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: PUSH
77750: LD_INT 6
77752: NEG
77753: PUSH
77754: LD_INT 0
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PUSH
77761: LD_INT 6
77763: NEG
77764: PUSH
77765: LD_INT 1
77767: NEG
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: LIST
77781: LIST
77782: LIST
77783: LIST
77784: LIST
77785: LIST
77786: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77787: LD_ADDR_VAR 0 34
77791: PUSH
77792: LD_INT 2
77794: NEG
77795: PUSH
77796: LD_INT 3
77798: NEG
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: LD_INT 3
77806: NEG
77807: PUSH
77808: LD_INT 2
77810: NEG
77811: PUSH
77812: EMPTY
77813: LIST
77814: LIST
77815: PUSH
77816: LD_INT 3
77818: NEG
77819: PUSH
77820: LD_INT 3
77822: NEG
77823: PUSH
77824: EMPTY
77825: LIST
77826: LIST
77827: PUSH
77828: LD_INT 3
77830: NEG
77831: PUSH
77832: LD_INT 4
77834: NEG
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: PUSH
77840: LD_INT 4
77842: NEG
77843: PUSH
77844: LD_INT 3
77846: NEG
77847: PUSH
77848: EMPTY
77849: LIST
77850: LIST
77851: PUSH
77852: LD_INT 4
77854: NEG
77855: PUSH
77856: LD_INT 4
77858: NEG
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: PUSH
77864: LD_INT 4
77866: NEG
77867: PUSH
77868: LD_INT 5
77870: NEG
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: PUSH
77876: LD_INT 5
77878: NEG
77879: PUSH
77880: LD_INT 4
77882: NEG
77883: PUSH
77884: EMPTY
77885: LIST
77886: LIST
77887: PUSH
77888: LD_INT 5
77890: NEG
77891: PUSH
77892: LD_INT 5
77894: NEG
77895: PUSH
77896: EMPTY
77897: LIST
77898: LIST
77899: PUSH
77900: LD_INT 5
77902: NEG
77903: PUSH
77904: LD_INT 6
77906: NEG
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: PUSH
77912: LD_INT 6
77914: NEG
77915: PUSH
77916: LD_INT 5
77918: NEG
77919: PUSH
77920: EMPTY
77921: LIST
77922: LIST
77923: PUSH
77924: LD_INT 6
77926: NEG
77927: PUSH
77928: LD_INT 6
77930: NEG
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: LIST
77940: LIST
77941: LIST
77942: LIST
77943: LIST
77944: LIST
77945: LIST
77946: LIST
77947: LIST
77948: LIST
77949: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
77950: LD_ADDR_VAR 0 41
77954: PUSH
77955: LD_INT 0
77957: PUSH
77958: LD_INT 2
77960: NEG
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: PUSH
77966: LD_INT 1
77968: NEG
77969: PUSH
77970: LD_INT 3
77972: NEG
77973: PUSH
77974: EMPTY
77975: LIST
77976: LIST
77977: PUSH
77978: LD_INT 1
77980: PUSH
77981: LD_INT 2
77983: NEG
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: PUSH
77989: EMPTY
77990: LIST
77991: LIST
77992: LIST
77993: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77994: LD_ADDR_VAR 0 42
77998: PUSH
77999: LD_INT 2
78001: PUSH
78002: LD_INT 0
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PUSH
78009: LD_INT 2
78011: PUSH
78012: LD_INT 1
78014: NEG
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 3
78022: PUSH
78023: LD_INT 1
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: EMPTY
78031: LIST
78032: LIST
78033: LIST
78034: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78035: LD_ADDR_VAR 0 43
78039: PUSH
78040: LD_INT 2
78042: PUSH
78043: LD_INT 2
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_INT 3
78052: PUSH
78053: LD_INT 2
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 2
78062: PUSH
78063: LD_INT 3
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: PUSH
78070: EMPTY
78071: LIST
78072: LIST
78073: LIST
78074: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
78075: LD_ADDR_VAR 0 44
78079: PUSH
78080: LD_INT 0
78082: PUSH
78083: LD_INT 2
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 1
78092: PUSH
78093: LD_INT 3
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_INT 1
78102: NEG
78103: PUSH
78104: LD_INT 2
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: LIST
78115: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78116: LD_ADDR_VAR 0 45
78120: PUSH
78121: LD_INT 2
78123: NEG
78124: PUSH
78125: LD_INT 0
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 2
78134: NEG
78135: PUSH
78136: LD_INT 1
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: PUSH
78143: LD_INT 3
78145: NEG
78146: PUSH
78147: LD_INT 1
78149: NEG
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: LIST
78159: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78160: LD_ADDR_VAR 0 46
78164: PUSH
78165: LD_INT 2
78167: NEG
78168: PUSH
78169: LD_INT 2
78171: NEG
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 2
78179: NEG
78180: PUSH
78181: LD_INT 3
78183: NEG
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PUSH
78189: LD_INT 3
78191: NEG
78192: PUSH
78193: LD_INT 2
78195: NEG
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: LIST
78205: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
78206: LD_ADDR_VAR 0 47
78210: PUSH
78211: LD_INT 2
78213: NEG
78214: PUSH
78215: LD_INT 3
78217: NEG
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PUSH
78223: LD_INT 1
78225: NEG
78226: PUSH
78227: LD_INT 3
78229: NEG
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: EMPTY
78236: LIST
78237: LIST
78238: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78239: LD_ADDR_VAR 0 48
78243: PUSH
78244: LD_INT 1
78246: PUSH
78247: LD_INT 2
78249: NEG
78250: PUSH
78251: EMPTY
78252: LIST
78253: LIST
78254: PUSH
78255: LD_INT 2
78257: PUSH
78258: LD_INT 1
78260: NEG
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
78270: LD_ADDR_VAR 0 49
78274: PUSH
78275: LD_INT 3
78277: PUSH
78278: LD_INT 1
78280: PUSH
78281: EMPTY
78282: LIST
78283: LIST
78284: PUSH
78285: LD_INT 3
78287: PUSH
78288: LD_INT 2
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: EMPTY
78296: LIST
78297: LIST
78298: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
78299: LD_ADDR_VAR 0 50
78303: PUSH
78304: LD_INT 2
78306: PUSH
78307: LD_INT 3
78309: PUSH
78310: EMPTY
78311: LIST
78312: LIST
78313: PUSH
78314: LD_INT 1
78316: PUSH
78317: LD_INT 3
78319: PUSH
78320: EMPTY
78321: LIST
78322: LIST
78323: PUSH
78324: EMPTY
78325: LIST
78326: LIST
78327: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78328: LD_ADDR_VAR 0 51
78332: PUSH
78333: LD_INT 1
78335: NEG
78336: PUSH
78337: LD_INT 2
78339: PUSH
78340: EMPTY
78341: LIST
78342: LIST
78343: PUSH
78344: LD_INT 2
78346: NEG
78347: PUSH
78348: LD_INT 1
78350: PUSH
78351: EMPTY
78352: LIST
78353: LIST
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78359: LD_ADDR_VAR 0 52
78363: PUSH
78364: LD_INT 3
78366: NEG
78367: PUSH
78368: LD_INT 1
78370: NEG
78371: PUSH
78372: EMPTY
78373: LIST
78374: LIST
78375: PUSH
78376: LD_INT 3
78378: NEG
78379: PUSH
78380: LD_INT 2
78382: NEG
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78392: LD_ADDR_VAR 0 53
78396: PUSH
78397: LD_INT 1
78399: NEG
78400: PUSH
78401: LD_INT 3
78403: NEG
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 0
78411: PUSH
78412: LD_INT 3
78414: NEG
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: PUSH
78420: LD_INT 1
78422: PUSH
78423: LD_INT 2
78425: NEG
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: LIST
78435: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78436: LD_ADDR_VAR 0 54
78440: PUSH
78441: LD_INT 2
78443: PUSH
78444: LD_INT 1
78446: NEG
78447: PUSH
78448: EMPTY
78449: LIST
78450: LIST
78451: PUSH
78452: LD_INT 3
78454: PUSH
78455: LD_INT 0
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 3
78464: PUSH
78465: LD_INT 1
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: LIST
78476: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78477: LD_ADDR_VAR 0 55
78481: PUSH
78482: LD_INT 3
78484: PUSH
78485: LD_INT 2
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: LD_INT 3
78494: PUSH
78495: LD_INT 3
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: PUSH
78502: LD_INT 2
78504: PUSH
78505: LD_INT 3
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: LIST
78516: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78517: LD_ADDR_VAR 0 56
78521: PUSH
78522: LD_INT 1
78524: PUSH
78525: LD_INT 3
78527: PUSH
78528: EMPTY
78529: LIST
78530: LIST
78531: PUSH
78532: LD_INT 0
78534: PUSH
78535: LD_INT 3
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: PUSH
78542: LD_INT 1
78544: NEG
78545: PUSH
78546: LD_INT 2
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: LIST
78557: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78558: LD_ADDR_VAR 0 57
78562: PUSH
78563: LD_INT 2
78565: NEG
78566: PUSH
78567: LD_INT 1
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 3
78576: NEG
78577: PUSH
78578: LD_INT 0
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 3
78587: NEG
78588: PUSH
78589: LD_INT 1
78591: NEG
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: LIST
78601: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78602: LD_ADDR_VAR 0 58
78606: PUSH
78607: LD_INT 2
78609: NEG
78610: PUSH
78611: LD_INT 3
78613: NEG
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 3
78621: NEG
78622: PUSH
78623: LD_INT 2
78625: NEG
78626: PUSH
78627: EMPTY
78628: LIST
78629: LIST
78630: PUSH
78631: LD_INT 3
78633: NEG
78634: PUSH
78635: LD_INT 3
78637: NEG
78638: PUSH
78639: EMPTY
78640: LIST
78641: LIST
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: LIST
78647: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
78648: LD_ADDR_VAR 0 59
78652: PUSH
78653: LD_INT 1
78655: NEG
78656: PUSH
78657: LD_INT 2
78659: NEG
78660: PUSH
78661: EMPTY
78662: LIST
78663: LIST
78664: PUSH
78665: LD_INT 0
78667: PUSH
78668: LD_INT 2
78670: NEG
78671: PUSH
78672: EMPTY
78673: LIST
78674: LIST
78675: PUSH
78676: LD_INT 1
78678: PUSH
78679: LD_INT 1
78681: NEG
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: LIST
78691: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78692: LD_ADDR_VAR 0 60
78696: PUSH
78697: LD_INT 1
78699: PUSH
78700: LD_INT 1
78702: NEG
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PUSH
78708: LD_INT 2
78710: PUSH
78711: LD_INT 0
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: LD_INT 2
78720: PUSH
78721: LD_INT 1
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: LIST
78732: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78733: LD_ADDR_VAR 0 61
78737: PUSH
78738: LD_INT 2
78740: PUSH
78741: LD_INT 1
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 2
78750: PUSH
78751: LD_INT 2
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 1
78760: PUSH
78761: LD_INT 2
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: LIST
78772: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78773: LD_ADDR_VAR 0 62
78777: PUSH
78778: LD_INT 1
78780: PUSH
78781: LD_INT 2
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 0
78790: PUSH
78791: LD_INT 2
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 1
78800: NEG
78801: PUSH
78802: LD_INT 1
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: LIST
78813: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78814: LD_ADDR_VAR 0 63
78818: PUSH
78819: LD_INT 1
78821: NEG
78822: PUSH
78823: LD_INT 1
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: PUSH
78830: LD_INT 2
78832: NEG
78833: PUSH
78834: LD_INT 0
78836: PUSH
78837: EMPTY
78838: LIST
78839: LIST
78840: PUSH
78841: LD_INT 2
78843: NEG
78844: PUSH
78845: LD_INT 1
78847: NEG
78848: PUSH
78849: EMPTY
78850: LIST
78851: LIST
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: LIST
78857: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78858: LD_ADDR_VAR 0 64
78862: PUSH
78863: LD_INT 1
78865: NEG
78866: PUSH
78867: LD_INT 2
78869: NEG
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 2
78877: NEG
78878: PUSH
78879: LD_INT 1
78881: NEG
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 2
78889: NEG
78890: PUSH
78891: LD_INT 2
78893: NEG
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: LIST
78903: ST_TO_ADDR
// end ; 2 :
78904: GO 82170
78906: LD_INT 2
78908: DOUBLE
78909: EQUAL
78910: IFTRUE 78914
78912: GO 82169
78914: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
78915: LD_ADDR_VAR 0 29
78919: PUSH
78920: LD_INT 4
78922: PUSH
78923: LD_INT 0
78925: PUSH
78926: EMPTY
78927: LIST
78928: LIST
78929: PUSH
78930: LD_INT 4
78932: PUSH
78933: LD_INT 1
78935: NEG
78936: PUSH
78937: EMPTY
78938: LIST
78939: LIST
78940: PUSH
78941: LD_INT 5
78943: PUSH
78944: LD_INT 0
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: PUSH
78951: LD_INT 5
78953: PUSH
78954: LD_INT 1
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 4
78963: PUSH
78964: LD_INT 1
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PUSH
78971: LD_INT 3
78973: PUSH
78974: LD_INT 0
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 3
78983: PUSH
78984: LD_INT 1
78986: NEG
78987: PUSH
78988: EMPTY
78989: LIST
78990: LIST
78991: PUSH
78992: LD_INT 3
78994: PUSH
78995: LD_INT 2
78997: NEG
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: LD_INT 5
79005: PUSH
79006: LD_INT 2
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 3
79015: PUSH
79016: LD_INT 3
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: PUSH
79023: LD_INT 3
79025: PUSH
79026: LD_INT 2
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 4
79035: PUSH
79036: LD_INT 3
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 4
79045: PUSH
79046: LD_INT 4
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 3
79055: PUSH
79056: LD_INT 4
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: LD_INT 2
79065: PUSH
79066: LD_INT 3
79068: PUSH
79069: EMPTY
79070: LIST
79071: LIST
79072: PUSH
79073: LD_INT 2
79075: PUSH
79076: LD_INT 2
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 4
79085: PUSH
79086: LD_INT 2
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 2
79095: PUSH
79096: LD_INT 4
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: PUSH
79103: LD_INT 0
79105: PUSH
79106: LD_INT 4
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PUSH
79113: LD_INT 0
79115: PUSH
79116: LD_INT 3
79118: PUSH
79119: EMPTY
79120: LIST
79121: LIST
79122: PUSH
79123: LD_INT 1
79125: PUSH
79126: LD_INT 4
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 1
79135: PUSH
79136: LD_INT 5
79138: PUSH
79139: EMPTY
79140: LIST
79141: LIST
79142: PUSH
79143: LD_INT 0
79145: PUSH
79146: LD_INT 5
79148: PUSH
79149: EMPTY
79150: LIST
79151: LIST
79152: PUSH
79153: LD_INT 1
79155: NEG
79156: PUSH
79157: LD_INT 4
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 1
79166: NEG
79167: PUSH
79168: LD_INT 3
79170: PUSH
79171: EMPTY
79172: LIST
79173: LIST
79174: PUSH
79175: LD_INT 2
79177: PUSH
79178: LD_INT 5
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 2
79187: NEG
79188: PUSH
79189: LD_INT 3
79191: PUSH
79192: EMPTY
79193: LIST
79194: LIST
79195: PUSH
79196: LD_INT 3
79198: NEG
79199: PUSH
79200: LD_INT 0
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: LD_INT 3
79209: NEG
79210: PUSH
79211: LD_INT 1
79213: NEG
79214: PUSH
79215: EMPTY
79216: LIST
79217: LIST
79218: PUSH
79219: LD_INT 2
79221: NEG
79222: PUSH
79223: LD_INT 0
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: LD_INT 2
79232: NEG
79233: PUSH
79234: LD_INT 1
79236: PUSH
79237: EMPTY
79238: LIST
79239: LIST
79240: PUSH
79241: LD_INT 3
79243: NEG
79244: PUSH
79245: LD_INT 1
79247: PUSH
79248: EMPTY
79249: LIST
79250: LIST
79251: PUSH
79252: LD_INT 4
79254: NEG
79255: PUSH
79256: LD_INT 0
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 4
79265: NEG
79266: PUSH
79267: LD_INT 1
79269: NEG
79270: PUSH
79271: EMPTY
79272: LIST
79273: LIST
79274: PUSH
79275: LD_INT 4
79277: NEG
79278: PUSH
79279: LD_INT 2
79281: NEG
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: PUSH
79287: LD_INT 2
79289: NEG
79290: PUSH
79291: LD_INT 2
79293: PUSH
79294: EMPTY
79295: LIST
79296: LIST
79297: PUSH
79298: LD_INT 4
79300: NEG
79301: PUSH
79302: LD_INT 4
79304: NEG
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 4
79312: NEG
79313: PUSH
79314: LD_INT 5
79316: NEG
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 3
79324: NEG
79325: PUSH
79326: LD_INT 4
79328: NEG
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 3
79336: NEG
79337: PUSH
79338: LD_INT 3
79340: NEG
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: PUSH
79346: LD_INT 4
79348: NEG
79349: PUSH
79350: LD_INT 3
79352: NEG
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 5
79360: NEG
79361: PUSH
79362: LD_INT 4
79364: NEG
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: PUSH
79370: LD_INT 5
79372: NEG
79373: PUSH
79374: LD_INT 5
79376: NEG
79377: PUSH
79378: EMPTY
79379: LIST
79380: LIST
79381: PUSH
79382: LD_INT 3
79384: NEG
79385: PUSH
79386: LD_INT 5
79388: NEG
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: LD_INT 5
79396: NEG
79397: PUSH
79398: LD_INT 3
79400: NEG
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: EMPTY
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: LIST
79432: LIST
79433: LIST
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
79453: LD_ADDR_VAR 0 30
79457: PUSH
79458: LD_INT 4
79460: PUSH
79461: LD_INT 4
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 4
79470: PUSH
79471: LD_INT 3
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 5
79480: PUSH
79481: LD_INT 4
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 5
79490: PUSH
79491: LD_INT 5
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: PUSH
79498: LD_INT 4
79500: PUSH
79501: LD_INT 5
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: LD_INT 3
79510: PUSH
79511: LD_INT 4
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 3
79520: PUSH
79521: LD_INT 3
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 5
79530: PUSH
79531: LD_INT 3
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 3
79540: PUSH
79541: LD_INT 5
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: LD_INT 0
79550: PUSH
79551: LD_INT 3
79553: PUSH
79554: EMPTY
79555: LIST
79556: LIST
79557: PUSH
79558: LD_INT 0
79560: PUSH
79561: LD_INT 2
79563: PUSH
79564: EMPTY
79565: LIST
79566: LIST
79567: PUSH
79568: LD_INT 1
79570: PUSH
79571: LD_INT 3
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: PUSH
79578: LD_INT 1
79580: PUSH
79581: LD_INT 4
79583: PUSH
79584: EMPTY
79585: LIST
79586: LIST
79587: PUSH
79588: LD_INT 0
79590: PUSH
79591: LD_INT 4
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: PUSH
79598: LD_INT 1
79600: NEG
79601: PUSH
79602: LD_INT 3
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 1
79611: NEG
79612: PUSH
79613: LD_INT 2
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: LD_INT 2
79622: PUSH
79623: LD_INT 4
79625: PUSH
79626: EMPTY
79627: LIST
79628: LIST
79629: PUSH
79630: LD_INT 2
79632: NEG
79633: PUSH
79634: LD_INT 2
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: LD_INT 4
79643: NEG
79644: PUSH
79645: LD_INT 0
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 4
79654: NEG
79655: PUSH
79656: LD_INT 1
79658: NEG
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PUSH
79664: LD_INT 3
79666: NEG
79667: PUSH
79668: LD_INT 0
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: PUSH
79675: LD_INT 3
79677: NEG
79678: PUSH
79679: LD_INT 1
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 4
79688: NEG
79689: PUSH
79690: LD_INT 1
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PUSH
79697: LD_INT 5
79699: NEG
79700: PUSH
79701: LD_INT 0
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 5
79710: NEG
79711: PUSH
79712: LD_INT 1
79714: NEG
79715: PUSH
79716: EMPTY
79717: LIST
79718: LIST
79719: PUSH
79720: LD_INT 5
79722: NEG
79723: PUSH
79724: LD_INT 2
79726: NEG
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 3
79734: NEG
79735: PUSH
79736: LD_INT 2
79738: PUSH
79739: EMPTY
79740: LIST
79741: LIST
79742: PUSH
79743: LD_INT 3
79745: NEG
79746: PUSH
79747: LD_INT 3
79749: NEG
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: PUSH
79755: LD_INT 3
79757: NEG
79758: PUSH
79759: LD_INT 4
79761: NEG
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: LD_INT 2
79769: NEG
79770: PUSH
79771: LD_INT 3
79773: NEG
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: LD_INT 2
79781: NEG
79782: PUSH
79783: LD_INT 2
79785: NEG
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PUSH
79791: LD_INT 3
79793: NEG
79794: PUSH
79795: LD_INT 2
79797: NEG
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: LD_INT 4
79805: NEG
79806: PUSH
79807: LD_INT 3
79809: NEG
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: PUSH
79815: LD_INT 4
79817: NEG
79818: PUSH
79819: LD_INT 4
79821: NEG
79822: PUSH
79823: EMPTY
79824: LIST
79825: LIST
79826: PUSH
79827: LD_INT 2
79829: NEG
79830: PUSH
79831: LD_INT 4
79833: NEG
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 4
79841: NEG
79842: PUSH
79843: LD_INT 2
79845: NEG
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: PUSH
79851: LD_INT 0
79853: PUSH
79854: LD_INT 4
79856: NEG
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: LD_INT 0
79864: PUSH
79865: LD_INT 5
79867: NEG
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 1
79875: PUSH
79876: LD_INT 4
79878: NEG
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 1
79886: PUSH
79887: LD_INT 3
79889: NEG
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 0
79897: PUSH
79898: LD_INT 3
79900: NEG
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 1
79908: NEG
79909: PUSH
79910: LD_INT 4
79912: NEG
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 1
79920: NEG
79921: PUSH
79922: LD_INT 5
79924: NEG
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: LD_INT 2
79932: PUSH
79933: LD_INT 3
79935: NEG
79936: PUSH
79937: EMPTY
79938: LIST
79939: LIST
79940: PUSH
79941: LD_INT 2
79943: NEG
79944: PUSH
79945: LD_INT 5
79947: NEG
79948: PUSH
79949: EMPTY
79950: LIST
79951: LIST
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: LIST
79957: LIST
79958: LIST
79959: LIST
79960: LIST
79961: LIST
79962: LIST
79963: LIST
79964: LIST
79965: LIST
79966: LIST
79967: LIST
79968: LIST
79969: LIST
79970: LIST
79971: LIST
79972: LIST
79973: LIST
79974: LIST
79975: LIST
79976: LIST
79977: LIST
79978: LIST
79979: LIST
79980: LIST
79981: LIST
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
80000: LD_ADDR_VAR 0 31
80004: PUSH
80005: LD_INT 0
80007: PUSH
80008: LD_INT 4
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PUSH
80015: LD_INT 0
80017: PUSH
80018: LD_INT 3
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 1
80027: PUSH
80028: LD_INT 4
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: LD_INT 1
80037: PUSH
80038: LD_INT 5
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: PUSH
80045: LD_INT 0
80047: PUSH
80048: LD_INT 5
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: LD_INT 1
80057: NEG
80058: PUSH
80059: LD_INT 4
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: LD_INT 1
80068: NEG
80069: PUSH
80070: LD_INT 3
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 2
80079: PUSH
80080: LD_INT 5
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 2
80089: NEG
80090: PUSH
80091: LD_INT 3
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 3
80100: NEG
80101: PUSH
80102: LD_INT 0
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 3
80111: NEG
80112: PUSH
80113: LD_INT 1
80115: NEG
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: LD_INT 2
80123: NEG
80124: PUSH
80125: LD_INT 0
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: PUSH
80132: LD_INT 2
80134: NEG
80135: PUSH
80136: LD_INT 1
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 3
80145: NEG
80146: PUSH
80147: LD_INT 1
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: LD_INT 4
80156: NEG
80157: PUSH
80158: LD_INT 0
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: PUSH
80165: LD_INT 4
80167: NEG
80168: PUSH
80169: LD_INT 1
80171: NEG
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: LD_INT 4
80179: NEG
80180: PUSH
80181: LD_INT 2
80183: NEG
80184: PUSH
80185: EMPTY
80186: LIST
80187: LIST
80188: PUSH
80189: LD_INT 2
80191: NEG
80192: PUSH
80193: LD_INT 2
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 4
80202: NEG
80203: PUSH
80204: LD_INT 4
80206: NEG
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 4
80214: NEG
80215: PUSH
80216: LD_INT 5
80218: NEG
80219: PUSH
80220: EMPTY
80221: LIST
80222: LIST
80223: PUSH
80224: LD_INT 3
80226: NEG
80227: PUSH
80228: LD_INT 4
80230: NEG
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: LD_INT 3
80238: NEG
80239: PUSH
80240: LD_INT 3
80242: NEG
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 4
80250: NEG
80251: PUSH
80252: LD_INT 3
80254: NEG
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: LD_INT 5
80262: NEG
80263: PUSH
80264: LD_INT 4
80266: NEG
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PUSH
80272: LD_INT 5
80274: NEG
80275: PUSH
80276: LD_INT 5
80278: NEG
80279: PUSH
80280: EMPTY
80281: LIST
80282: LIST
80283: PUSH
80284: LD_INT 3
80286: NEG
80287: PUSH
80288: LD_INT 5
80290: NEG
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PUSH
80296: LD_INT 5
80298: NEG
80299: PUSH
80300: LD_INT 3
80302: NEG
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: LD_INT 0
80310: PUSH
80311: LD_INT 3
80313: NEG
80314: PUSH
80315: EMPTY
80316: LIST
80317: LIST
80318: PUSH
80319: LD_INT 0
80321: PUSH
80322: LD_INT 4
80324: NEG
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: LD_INT 1
80332: PUSH
80333: LD_INT 3
80335: NEG
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 1
80343: PUSH
80344: LD_INT 2
80346: NEG
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: PUSH
80352: LD_INT 0
80354: PUSH
80355: LD_INT 2
80357: NEG
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: PUSH
80363: LD_INT 1
80365: NEG
80366: PUSH
80367: LD_INT 3
80369: NEG
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: PUSH
80375: LD_INT 1
80377: NEG
80378: PUSH
80379: LD_INT 4
80381: NEG
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: PUSH
80387: LD_INT 2
80389: PUSH
80390: LD_INT 2
80392: NEG
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: LD_INT 2
80400: NEG
80401: PUSH
80402: LD_INT 4
80404: NEG
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: PUSH
80410: LD_INT 4
80412: PUSH
80413: LD_INT 0
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 4
80422: PUSH
80423: LD_INT 1
80425: NEG
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 5
80433: PUSH
80434: LD_INT 0
80436: PUSH
80437: EMPTY
80438: LIST
80439: LIST
80440: PUSH
80441: LD_INT 5
80443: PUSH
80444: LD_INT 1
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 4
80453: PUSH
80454: LD_INT 1
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 3
80463: PUSH
80464: LD_INT 0
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: PUSH
80471: LD_INT 3
80473: PUSH
80474: LD_INT 1
80476: NEG
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 3
80484: PUSH
80485: LD_INT 2
80487: NEG
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 5
80495: PUSH
80496: LD_INT 2
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: EMPTY
80504: LIST
80505: LIST
80506: LIST
80507: LIST
80508: LIST
80509: LIST
80510: LIST
80511: LIST
80512: LIST
80513: LIST
80514: LIST
80515: LIST
80516: LIST
80517: LIST
80518: LIST
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
80550: LD_ADDR_VAR 0 32
80554: PUSH
80555: LD_INT 4
80557: NEG
80558: PUSH
80559: LD_INT 0
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PUSH
80566: LD_INT 4
80568: NEG
80569: PUSH
80570: LD_INT 1
80572: NEG
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 3
80580: NEG
80581: PUSH
80582: LD_INT 0
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: PUSH
80589: LD_INT 3
80591: NEG
80592: PUSH
80593: LD_INT 1
80595: PUSH
80596: EMPTY
80597: LIST
80598: LIST
80599: PUSH
80600: LD_INT 4
80602: NEG
80603: PUSH
80604: LD_INT 1
80606: PUSH
80607: EMPTY
80608: LIST
80609: LIST
80610: PUSH
80611: LD_INT 5
80613: NEG
80614: PUSH
80615: LD_INT 0
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: PUSH
80622: LD_INT 5
80624: NEG
80625: PUSH
80626: LD_INT 1
80628: NEG
80629: PUSH
80630: EMPTY
80631: LIST
80632: LIST
80633: PUSH
80634: LD_INT 5
80636: NEG
80637: PUSH
80638: LD_INT 2
80640: NEG
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 3
80648: NEG
80649: PUSH
80650: LD_INT 2
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 3
80659: NEG
80660: PUSH
80661: LD_INT 3
80663: NEG
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 3
80671: NEG
80672: PUSH
80673: LD_INT 4
80675: NEG
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 2
80683: NEG
80684: PUSH
80685: LD_INT 3
80687: NEG
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_INT 2
80695: NEG
80696: PUSH
80697: LD_INT 2
80699: NEG
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: LD_INT 3
80707: NEG
80708: PUSH
80709: LD_INT 2
80711: NEG
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 4
80719: NEG
80720: PUSH
80721: LD_INT 3
80723: NEG
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: LD_INT 4
80731: NEG
80732: PUSH
80733: LD_INT 4
80735: NEG
80736: PUSH
80737: EMPTY
80738: LIST
80739: LIST
80740: PUSH
80741: LD_INT 2
80743: NEG
80744: PUSH
80745: LD_INT 4
80747: NEG
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: LD_INT 4
80755: NEG
80756: PUSH
80757: LD_INT 2
80759: NEG
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: LD_INT 0
80767: PUSH
80768: LD_INT 4
80770: NEG
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 0
80778: PUSH
80779: LD_INT 5
80781: NEG
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 1
80789: PUSH
80790: LD_INT 4
80792: NEG
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 1
80800: PUSH
80801: LD_INT 3
80803: NEG
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PUSH
80809: LD_INT 0
80811: PUSH
80812: LD_INT 3
80814: NEG
80815: PUSH
80816: EMPTY
80817: LIST
80818: LIST
80819: PUSH
80820: LD_INT 1
80822: NEG
80823: PUSH
80824: LD_INT 4
80826: NEG
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 1
80834: NEG
80835: PUSH
80836: LD_INT 5
80838: NEG
80839: PUSH
80840: EMPTY
80841: LIST
80842: LIST
80843: PUSH
80844: LD_INT 2
80846: PUSH
80847: LD_INT 3
80849: NEG
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: PUSH
80855: LD_INT 2
80857: NEG
80858: PUSH
80859: LD_INT 5
80861: NEG
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 3
80869: PUSH
80870: LD_INT 0
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 3
80879: PUSH
80880: LD_INT 1
80882: NEG
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 4
80890: PUSH
80891: LD_INT 0
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 4
80900: PUSH
80901: LD_INT 1
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 3
80910: PUSH
80911: LD_INT 1
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: PUSH
80918: LD_INT 2
80920: PUSH
80921: LD_INT 0
80923: PUSH
80924: EMPTY
80925: LIST
80926: LIST
80927: PUSH
80928: LD_INT 2
80930: PUSH
80931: LD_INT 1
80933: NEG
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 2
80941: PUSH
80942: LD_INT 2
80944: NEG
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 4
80952: PUSH
80953: LD_INT 2
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: LD_INT 4
80962: PUSH
80963: LD_INT 4
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: PUSH
80970: LD_INT 4
80972: PUSH
80973: LD_INT 3
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 5
80982: PUSH
80983: LD_INT 4
80985: PUSH
80986: EMPTY
80987: LIST
80988: LIST
80989: PUSH
80990: LD_INT 5
80992: PUSH
80993: LD_INT 5
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: PUSH
81000: LD_INT 4
81002: PUSH
81003: LD_INT 5
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 3
81012: PUSH
81013: LD_INT 4
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: LD_INT 3
81022: PUSH
81023: LD_INT 3
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 5
81032: PUSH
81033: LD_INT 3
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 3
81042: PUSH
81043: LD_INT 5
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: EMPTY
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
81097: LD_ADDR_VAR 0 33
81101: PUSH
81102: LD_INT 4
81104: NEG
81105: PUSH
81106: LD_INT 4
81108: NEG
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 4
81116: NEG
81117: PUSH
81118: LD_INT 5
81120: NEG
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 3
81128: NEG
81129: PUSH
81130: LD_INT 4
81132: NEG
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 3
81140: NEG
81141: PUSH
81142: LD_INT 3
81144: NEG
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 4
81152: NEG
81153: PUSH
81154: LD_INT 3
81156: NEG
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: PUSH
81162: LD_INT 5
81164: NEG
81165: PUSH
81166: LD_INT 4
81168: NEG
81169: PUSH
81170: EMPTY
81171: LIST
81172: LIST
81173: PUSH
81174: LD_INT 5
81176: NEG
81177: PUSH
81178: LD_INT 5
81180: NEG
81181: PUSH
81182: EMPTY
81183: LIST
81184: LIST
81185: PUSH
81186: LD_INT 3
81188: NEG
81189: PUSH
81190: LD_INT 5
81192: NEG
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PUSH
81198: LD_INT 5
81200: NEG
81201: PUSH
81202: LD_INT 3
81204: NEG
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 0
81212: PUSH
81213: LD_INT 3
81215: NEG
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 0
81223: PUSH
81224: LD_INT 4
81226: NEG
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: PUSH
81232: LD_INT 1
81234: PUSH
81235: LD_INT 3
81237: NEG
81238: PUSH
81239: EMPTY
81240: LIST
81241: LIST
81242: PUSH
81243: LD_INT 1
81245: PUSH
81246: LD_INT 2
81248: NEG
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 0
81256: PUSH
81257: LD_INT 2
81259: NEG
81260: PUSH
81261: EMPTY
81262: LIST
81263: LIST
81264: PUSH
81265: LD_INT 1
81267: NEG
81268: PUSH
81269: LD_INT 3
81271: NEG
81272: PUSH
81273: EMPTY
81274: LIST
81275: LIST
81276: PUSH
81277: LD_INT 1
81279: NEG
81280: PUSH
81281: LD_INT 4
81283: NEG
81284: PUSH
81285: EMPTY
81286: LIST
81287: LIST
81288: PUSH
81289: LD_INT 2
81291: PUSH
81292: LD_INT 2
81294: NEG
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 2
81302: NEG
81303: PUSH
81304: LD_INT 4
81306: NEG
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: PUSH
81312: LD_INT 4
81314: PUSH
81315: LD_INT 0
81317: PUSH
81318: EMPTY
81319: LIST
81320: LIST
81321: PUSH
81322: LD_INT 4
81324: PUSH
81325: LD_INT 1
81327: NEG
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: PUSH
81333: LD_INT 5
81335: PUSH
81336: LD_INT 0
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PUSH
81343: LD_INT 5
81345: PUSH
81346: LD_INT 1
81348: PUSH
81349: EMPTY
81350: LIST
81351: LIST
81352: PUSH
81353: LD_INT 4
81355: PUSH
81356: LD_INT 1
81358: PUSH
81359: EMPTY
81360: LIST
81361: LIST
81362: PUSH
81363: LD_INT 3
81365: PUSH
81366: LD_INT 0
81368: PUSH
81369: EMPTY
81370: LIST
81371: LIST
81372: PUSH
81373: LD_INT 3
81375: PUSH
81376: LD_INT 1
81378: NEG
81379: PUSH
81380: EMPTY
81381: LIST
81382: LIST
81383: PUSH
81384: LD_INT 3
81386: PUSH
81387: LD_INT 2
81389: NEG
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 5
81397: PUSH
81398: LD_INT 2
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 3
81407: PUSH
81408: LD_INT 3
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: LD_INT 3
81417: PUSH
81418: LD_INT 2
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 4
81427: PUSH
81428: LD_INT 3
81430: PUSH
81431: EMPTY
81432: LIST
81433: LIST
81434: PUSH
81435: LD_INT 4
81437: PUSH
81438: LD_INT 4
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: PUSH
81445: LD_INT 3
81447: PUSH
81448: LD_INT 4
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: PUSH
81455: LD_INT 2
81457: PUSH
81458: LD_INT 3
81460: PUSH
81461: EMPTY
81462: LIST
81463: LIST
81464: PUSH
81465: LD_INT 2
81467: PUSH
81468: LD_INT 2
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: PUSH
81475: LD_INT 4
81477: PUSH
81478: LD_INT 2
81480: PUSH
81481: EMPTY
81482: LIST
81483: LIST
81484: PUSH
81485: LD_INT 2
81487: PUSH
81488: LD_INT 4
81490: PUSH
81491: EMPTY
81492: LIST
81493: LIST
81494: PUSH
81495: LD_INT 0
81497: PUSH
81498: LD_INT 4
81500: PUSH
81501: EMPTY
81502: LIST
81503: LIST
81504: PUSH
81505: LD_INT 0
81507: PUSH
81508: LD_INT 3
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 1
81517: PUSH
81518: LD_INT 4
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 1
81527: PUSH
81528: LD_INT 5
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 0
81537: PUSH
81538: LD_INT 5
81540: PUSH
81541: EMPTY
81542: LIST
81543: LIST
81544: PUSH
81545: LD_INT 1
81547: NEG
81548: PUSH
81549: LD_INT 4
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 1
81558: NEG
81559: PUSH
81560: LD_INT 3
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 2
81569: PUSH
81570: LD_INT 5
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 2
81579: NEG
81580: PUSH
81581: LD_INT 3
81583: PUSH
81584: EMPTY
81585: LIST
81586: LIST
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: LIST
81630: LIST
81631: LIST
81632: LIST
81633: LIST
81634: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
81635: LD_ADDR_VAR 0 34
81639: PUSH
81640: LD_INT 0
81642: PUSH
81643: LD_INT 4
81645: NEG
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: PUSH
81651: LD_INT 0
81653: PUSH
81654: LD_INT 5
81656: NEG
81657: PUSH
81658: EMPTY
81659: LIST
81660: LIST
81661: PUSH
81662: LD_INT 1
81664: PUSH
81665: LD_INT 4
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 1
81675: PUSH
81676: LD_INT 3
81678: NEG
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 0
81686: PUSH
81687: LD_INT 3
81689: NEG
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: LD_INT 1
81697: NEG
81698: PUSH
81699: LD_INT 4
81701: NEG
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 1
81709: NEG
81710: PUSH
81711: LD_INT 5
81713: NEG
81714: PUSH
81715: EMPTY
81716: LIST
81717: LIST
81718: PUSH
81719: LD_INT 2
81721: PUSH
81722: LD_INT 3
81724: NEG
81725: PUSH
81726: EMPTY
81727: LIST
81728: LIST
81729: PUSH
81730: LD_INT 2
81732: NEG
81733: PUSH
81734: LD_INT 5
81736: NEG
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PUSH
81742: LD_INT 3
81744: PUSH
81745: LD_INT 0
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: LD_INT 3
81754: PUSH
81755: LD_INT 1
81757: NEG
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: PUSH
81763: LD_INT 4
81765: PUSH
81766: LD_INT 0
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: LD_INT 4
81775: PUSH
81776: LD_INT 1
81778: PUSH
81779: EMPTY
81780: LIST
81781: LIST
81782: PUSH
81783: LD_INT 3
81785: PUSH
81786: LD_INT 1
81788: PUSH
81789: EMPTY
81790: LIST
81791: LIST
81792: PUSH
81793: LD_INT 2
81795: PUSH
81796: LD_INT 0
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: LD_INT 2
81805: PUSH
81806: LD_INT 1
81808: NEG
81809: PUSH
81810: EMPTY
81811: LIST
81812: LIST
81813: PUSH
81814: LD_INT 2
81816: PUSH
81817: LD_INT 2
81819: NEG
81820: PUSH
81821: EMPTY
81822: LIST
81823: LIST
81824: PUSH
81825: LD_INT 4
81827: PUSH
81828: LD_INT 2
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 4
81837: PUSH
81838: LD_INT 4
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 4
81847: PUSH
81848: LD_INT 3
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 5
81857: PUSH
81858: LD_INT 4
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 5
81867: PUSH
81868: LD_INT 5
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 4
81877: PUSH
81878: LD_INT 5
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PUSH
81885: LD_INT 3
81887: PUSH
81888: LD_INT 4
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: PUSH
81895: LD_INT 3
81897: PUSH
81898: LD_INT 3
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: PUSH
81905: LD_INT 5
81907: PUSH
81908: LD_INT 3
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 3
81917: PUSH
81918: LD_INT 5
81920: PUSH
81921: EMPTY
81922: LIST
81923: LIST
81924: PUSH
81925: LD_INT 0
81927: PUSH
81928: LD_INT 3
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 0
81937: PUSH
81938: LD_INT 2
81940: PUSH
81941: EMPTY
81942: LIST
81943: LIST
81944: PUSH
81945: LD_INT 1
81947: PUSH
81948: LD_INT 3
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: PUSH
81955: LD_INT 1
81957: PUSH
81958: LD_INT 4
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 0
81967: PUSH
81968: LD_INT 4
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 1
81977: NEG
81978: PUSH
81979: LD_INT 3
81981: PUSH
81982: EMPTY
81983: LIST
81984: LIST
81985: PUSH
81986: LD_INT 1
81988: NEG
81989: PUSH
81990: LD_INT 2
81992: PUSH
81993: EMPTY
81994: LIST
81995: LIST
81996: PUSH
81997: LD_INT 2
81999: PUSH
82000: LD_INT 4
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: PUSH
82007: LD_INT 2
82009: NEG
82010: PUSH
82011: LD_INT 2
82013: PUSH
82014: EMPTY
82015: LIST
82016: LIST
82017: PUSH
82018: LD_INT 4
82020: NEG
82021: PUSH
82022: LD_INT 0
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: LD_INT 4
82031: NEG
82032: PUSH
82033: LD_INT 1
82035: NEG
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: PUSH
82041: LD_INT 3
82043: NEG
82044: PUSH
82045: LD_INT 0
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 3
82054: NEG
82055: PUSH
82056: LD_INT 1
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: PUSH
82063: LD_INT 4
82065: NEG
82066: PUSH
82067: LD_INT 1
82069: PUSH
82070: EMPTY
82071: LIST
82072: LIST
82073: PUSH
82074: LD_INT 5
82076: NEG
82077: PUSH
82078: LD_INT 0
82080: PUSH
82081: EMPTY
82082: LIST
82083: LIST
82084: PUSH
82085: LD_INT 5
82087: NEG
82088: PUSH
82089: LD_INT 1
82091: NEG
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: LD_INT 5
82099: NEG
82100: PUSH
82101: LD_INT 2
82103: NEG
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 3
82111: NEG
82112: PUSH
82113: LD_INT 2
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: EMPTY
82121: LIST
82122: LIST
82123: LIST
82124: LIST
82125: LIST
82126: LIST
82127: LIST
82128: LIST
82129: LIST
82130: LIST
82131: LIST
82132: LIST
82133: LIST
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: LIST
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: ST_TO_ADDR
// end ; end ;
82167: GO 82170
82169: POP
// case btype of b_depot , b_warehouse :
82170: LD_VAR 0 1
82174: PUSH
82175: LD_INT 0
82177: DOUBLE
82178: EQUAL
82179: IFTRUE 82189
82181: LD_INT 1
82183: DOUBLE
82184: EQUAL
82185: IFTRUE 82189
82187: GO 82390
82189: POP
// case nation of nation_american :
82190: LD_VAR 0 5
82194: PUSH
82195: LD_INT 1
82197: DOUBLE
82198: EQUAL
82199: IFTRUE 82203
82201: GO 82259
82203: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
82204: LD_ADDR_VAR 0 9
82208: PUSH
82209: LD_VAR 0 11
82213: PUSH
82214: LD_VAR 0 12
82218: PUSH
82219: LD_VAR 0 13
82223: PUSH
82224: LD_VAR 0 14
82228: PUSH
82229: LD_VAR 0 15
82233: PUSH
82234: LD_VAR 0 16
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: LIST
82246: PUSH
82247: LD_VAR 0 4
82251: PUSH
82252: LD_INT 1
82254: PLUS
82255: ARRAY
82256: ST_TO_ADDR
82257: GO 82388
82259: LD_INT 2
82261: DOUBLE
82262: EQUAL
82263: IFTRUE 82267
82265: GO 82323
82267: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
82268: LD_ADDR_VAR 0 9
82272: PUSH
82273: LD_VAR 0 17
82277: PUSH
82278: LD_VAR 0 18
82282: PUSH
82283: LD_VAR 0 19
82287: PUSH
82288: LD_VAR 0 20
82292: PUSH
82293: LD_VAR 0 21
82297: PUSH
82298: LD_VAR 0 22
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: PUSH
82311: LD_VAR 0 4
82315: PUSH
82316: LD_INT 1
82318: PLUS
82319: ARRAY
82320: ST_TO_ADDR
82321: GO 82388
82323: LD_INT 3
82325: DOUBLE
82326: EQUAL
82327: IFTRUE 82331
82329: GO 82387
82331: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
82332: LD_ADDR_VAR 0 9
82336: PUSH
82337: LD_VAR 0 23
82341: PUSH
82342: LD_VAR 0 24
82346: PUSH
82347: LD_VAR 0 25
82351: PUSH
82352: LD_VAR 0 26
82356: PUSH
82357: LD_VAR 0 27
82361: PUSH
82362: LD_VAR 0 28
82366: PUSH
82367: EMPTY
82368: LIST
82369: LIST
82370: LIST
82371: LIST
82372: LIST
82373: LIST
82374: PUSH
82375: LD_VAR 0 4
82379: PUSH
82380: LD_INT 1
82382: PLUS
82383: ARRAY
82384: ST_TO_ADDR
82385: GO 82388
82387: POP
82388: GO 82943
82390: LD_INT 2
82392: DOUBLE
82393: EQUAL
82394: IFTRUE 82404
82396: LD_INT 3
82398: DOUBLE
82399: EQUAL
82400: IFTRUE 82404
82402: GO 82460
82404: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
82405: LD_ADDR_VAR 0 9
82409: PUSH
82410: LD_VAR 0 29
82414: PUSH
82415: LD_VAR 0 30
82419: PUSH
82420: LD_VAR 0 31
82424: PUSH
82425: LD_VAR 0 32
82429: PUSH
82430: LD_VAR 0 33
82434: PUSH
82435: LD_VAR 0 34
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: LIST
82444: LIST
82445: LIST
82446: LIST
82447: PUSH
82448: LD_VAR 0 4
82452: PUSH
82453: LD_INT 1
82455: PLUS
82456: ARRAY
82457: ST_TO_ADDR
82458: GO 82943
82460: LD_INT 16
82462: DOUBLE
82463: EQUAL
82464: IFTRUE 82522
82466: LD_INT 17
82468: DOUBLE
82469: EQUAL
82470: IFTRUE 82522
82472: LD_INT 18
82474: DOUBLE
82475: EQUAL
82476: IFTRUE 82522
82478: LD_INT 19
82480: DOUBLE
82481: EQUAL
82482: IFTRUE 82522
82484: LD_INT 22
82486: DOUBLE
82487: EQUAL
82488: IFTRUE 82522
82490: LD_INT 20
82492: DOUBLE
82493: EQUAL
82494: IFTRUE 82522
82496: LD_INT 21
82498: DOUBLE
82499: EQUAL
82500: IFTRUE 82522
82502: LD_INT 23
82504: DOUBLE
82505: EQUAL
82506: IFTRUE 82522
82508: LD_INT 24
82510: DOUBLE
82511: EQUAL
82512: IFTRUE 82522
82514: LD_INT 25
82516: DOUBLE
82517: EQUAL
82518: IFTRUE 82522
82520: GO 82578
82522: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
82523: LD_ADDR_VAR 0 9
82527: PUSH
82528: LD_VAR 0 35
82532: PUSH
82533: LD_VAR 0 36
82537: PUSH
82538: LD_VAR 0 37
82542: PUSH
82543: LD_VAR 0 38
82547: PUSH
82548: LD_VAR 0 39
82552: PUSH
82553: LD_VAR 0 40
82557: PUSH
82558: EMPTY
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: PUSH
82566: LD_VAR 0 4
82570: PUSH
82571: LD_INT 1
82573: PLUS
82574: ARRAY
82575: ST_TO_ADDR
82576: GO 82943
82578: LD_INT 6
82580: DOUBLE
82581: EQUAL
82582: IFTRUE 82634
82584: LD_INT 7
82586: DOUBLE
82587: EQUAL
82588: IFTRUE 82634
82590: LD_INT 8
82592: DOUBLE
82593: EQUAL
82594: IFTRUE 82634
82596: LD_INT 13
82598: DOUBLE
82599: EQUAL
82600: IFTRUE 82634
82602: LD_INT 12
82604: DOUBLE
82605: EQUAL
82606: IFTRUE 82634
82608: LD_INT 15
82610: DOUBLE
82611: EQUAL
82612: IFTRUE 82634
82614: LD_INT 11
82616: DOUBLE
82617: EQUAL
82618: IFTRUE 82634
82620: LD_INT 14
82622: DOUBLE
82623: EQUAL
82624: IFTRUE 82634
82626: LD_INT 10
82628: DOUBLE
82629: EQUAL
82630: IFTRUE 82634
82632: GO 82690
82634: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
82635: LD_ADDR_VAR 0 9
82639: PUSH
82640: LD_VAR 0 41
82644: PUSH
82645: LD_VAR 0 42
82649: PUSH
82650: LD_VAR 0 43
82654: PUSH
82655: LD_VAR 0 44
82659: PUSH
82660: LD_VAR 0 45
82664: PUSH
82665: LD_VAR 0 46
82669: PUSH
82670: EMPTY
82671: LIST
82672: LIST
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: PUSH
82678: LD_VAR 0 4
82682: PUSH
82683: LD_INT 1
82685: PLUS
82686: ARRAY
82687: ST_TO_ADDR
82688: GO 82943
82690: LD_INT 36
82692: DOUBLE
82693: EQUAL
82694: IFTRUE 82698
82696: GO 82754
82698: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82699: LD_ADDR_VAR 0 9
82703: PUSH
82704: LD_VAR 0 47
82708: PUSH
82709: LD_VAR 0 48
82713: PUSH
82714: LD_VAR 0 49
82718: PUSH
82719: LD_VAR 0 50
82723: PUSH
82724: LD_VAR 0 51
82728: PUSH
82729: LD_VAR 0 52
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: PUSH
82742: LD_VAR 0 4
82746: PUSH
82747: LD_INT 1
82749: PLUS
82750: ARRAY
82751: ST_TO_ADDR
82752: GO 82943
82754: LD_INT 4
82756: DOUBLE
82757: EQUAL
82758: IFTRUE 82780
82760: LD_INT 5
82762: DOUBLE
82763: EQUAL
82764: IFTRUE 82780
82766: LD_INT 34
82768: DOUBLE
82769: EQUAL
82770: IFTRUE 82780
82772: LD_INT 37
82774: DOUBLE
82775: EQUAL
82776: IFTRUE 82780
82778: GO 82836
82780: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82781: LD_ADDR_VAR 0 9
82785: PUSH
82786: LD_VAR 0 53
82790: PUSH
82791: LD_VAR 0 54
82795: PUSH
82796: LD_VAR 0 55
82800: PUSH
82801: LD_VAR 0 56
82805: PUSH
82806: LD_VAR 0 57
82810: PUSH
82811: LD_VAR 0 58
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: PUSH
82824: LD_VAR 0 4
82828: PUSH
82829: LD_INT 1
82831: PLUS
82832: ARRAY
82833: ST_TO_ADDR
82834: GO 82943
82836: LD_INT 31
82838: DOUBLE
82839: EQUAL
82840: IFTRUE 82886
82842: LD_INT 32
82844: DOUBLE
82845: EQUAL
82846: IFTRUE 82886
82848: LD_INT 33
82850: DOUBLE
82851: EQUAL
82852: IFTRUE 82886
82854: LD_INT 27
82856: DOUBLE
82857: EQUAL
82858: IFTRUE 82886
82860: LD_INT 26
82862: DOUBLE
82863: EQUAL
82864: IFTRUE 82886
82866: LD_INT 28
82868: DOUBLE
82869: EQUAL
82870: IFTRUE 82886
82872: LD_INT 29
82874: DOUBLE
82875: EQUAL
82876: IFTRUE 82886
82878: LD_INT 30
82880: DOUBLE
82881: EQUAL
82882: IFTRUE 82886
82884: GO 82942
82886: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
82887: LD_ADDR_VAR 0 9
82891: PUSH
82892: LD_VAR 0 59
82896: PUSH
82897: LD_VAR 0 60
82901: PUSH
82902: LD_VAR 0 61
82906: PUSH
82907: LD_VAR 0 62
82911: PUSH
82912: LD_VAR 0 63
82916: PUSH
82917: LD_VAR 0 64
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: PUSH
82930: LD_VAR 0 4
82934: PUSH
82935: LD_INT 1
82937: PLUS
82938: ARRAY
82939: ST_TO_ADDR
82940: GO 82943
82942: POP
// temp_list2 = [ ] ;
82943: LD_ADDR_VAR 0 10
82947: PUSH
82948: EMPTY
82949: ST_TO_ADDR
// for i in temp_list do
82950: LD_ADDR_VAR 0 8
82954: PUSH
82955: LD_VAR 0 9
82959: PUSH
82960: FOR_IN
82961: IFFALSE 83013
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
82963: LD_ADDR_VAR 0 10
82967: PUSH
82968: LD_VAR 0 10
82972: PUSH
82973: LD_VAR 0 8
82977: PUSH
82978: LD_INT 1
82980: ARRAY
82981: PUSH
82982: LD_VAR 0 2
82986: PLUS
82987: PUSH
82988: LD_VAR 0 8
82992: PUSH
82993: LD_INT 2
82995: ARRAY
82996: PUSH
82997: LD_VAR 0 3
83001: PLUS
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: PUSH
83007: EMPTY
83008: LIST
83009: ADD
83010: ST_TO_ADDR
83011: GO 82960
83013: POP
83014: POP
// result = temp_list2 ;
83015: LD_ADDR_VAR 0 7
83019: PUSH
83020: LD_VAR 0 10
83024: ST_TO_ADDR
// end ;
83025: LD_VAR 0 7
83029: RET
// export function EnemyInRange ( unit , dist ) ; begin
83030: LD_INT 0
83032: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83033: LD_ADDR_VAR 0 3
83037: PUSH
83038: LD_VAR 0 1
83042: PPUSH
83043: CALL_OW 255
83047: PPUSH
83048: LD_VAR 0 1
83052: PPUSH
83053: CALL_OW 250
83057: PPUSH
83058: LD_VAR 0 1
83062: PPUSH
83063: CALL_OW 251
83067: PPUSH
83068: LD_VAR 0 2
83072: PPUSH
83073: CALL 57134 0 4
83077: PUSH
83078: LD_INT 4
83080: ARRAY
83081: ST_TO_ADDR
// end ;
83082: LD_VAR 0 3
83086: RET
// export function PlayerSeeMe ( unit ) ; begin
83087: LD_INT 0
83089: PPUSH
// result := See ( your_side , unit ) ;
83090: LD_ADDR_VAR 0 2
83094: PUSH
83095: LD_OWVAR 2
83099: PPUSH
83100: LD_VAR 0 1
83104: PPUSH
83105: CALL_OW 292
83109: ST_TO_ADDR
// end ;
83110: LD_VAR 0 2
83114: RET
// export function ReverseDir ( unit ) ; begin
83115: LD_INT 0
83117: PPUSH
// if not unit then
83118: LD_VAR 0 1
83122: NOT
83123: IFFALSE 83127
// exit ;
83125: GO 83173
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
83127: LD_ADDR_VAR 0 2
83131: PUSH
83132: LD_INT 3
83134: PUSH
83135: LD_INT 4
83137: PUSH
83138: LD_INT 5
83140: PUSH
83141: LD_INT 0
83143: PUSH
83144: LD_INT 1
83146: PUSH
83147: LD_INT 2
83149: PUSH
83150: EMPTY
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: PUSH
83158: LD_VAR 0 1
83162: PPUSH
83163: CALL_OW 254
83167: PUSH
83168: LD_INT 1
83170: PLUS
83171: ARRAY
83172: ST_TO_ADDR
// end ;
83173: LD_VAR 0 2
83177: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
83178: LD_INT 0
83180: PPUSH
83181: PPUSH
83182: PPUSH
83183: PPUSH
83184: PPUSH
// if not hexes then
83185: LD_VAR 0 2
83189: NOT
83190: IFFALSE 83194
// exit ;
83192: GO 83342
// dist := 9999 ;
83194: LD_ADDR_VAR 0 5
83198: PUSH
83199: LD_INT 9999
83201: ST_TO_ADDR
// for i = 1 to hexes do
83202: LD_ADDR_VAR 0 4
83206: PUSH
83207: DOUBLE
83208: LD_INT 1
83210: DEC
83211: ST_TO_ADDR
83212: LD_VAR 0 2
83216: PUSH
83217: FOR_TO
83218: IFFALSE 83330
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
83220: LD_VAR 0 1
83224: PPUSH
83225: LD_VAR 0 2
83229: PUSH
83230: LD_VAR 0 4
83234: ARRAY
83235: PUSH
83236: LD_INT 1
83238: ARRAY
83239: PPUSH
83240: LD_VAR 0 2
83244: PUSH
83245: LD_VAR 0 4
83249: ARRAY
83250: PUSH
83251: LD_INT 2
83253: ARRAY
83254: PPUSH
83255: CALL_OW 297
83259: PUSH
83260: LD_VAR 0 5
83264: LESS
83265: IFFALSE 83328
// begin hex := hexes [ i ] ;
83267: LD_ADDR_VAR 0 7
83271: PUSH
83272: LD_VAR 0 2
83276: PUSH
83277: LD_VAR 0 4
83281: ARRAY
83282: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83283: LD_ADDR_VAR 0 5
83287: PUSH
83288: LD_VAR 0 1
83292: PPUSH
83293: LD_VAR 0 2
83297: PUSH
83298: LD_VAR 0 4
83302: ARRAY
83303: PUSH
83304: LD_INT 1
83306: ARRAY
83307: PPUSH
83308: LD_VAR 0 2
83312: PUSH
83313: LD_VAR 0 4
83317: ARRAY
83318: PUSH
83319: LD_INT 2
83321: ARRAY
83322: PPUSH
83323: CALL_OW 297
83327: ST_TO_ADDR
// end ; end ;
83328: GO 83217
83330: POP
83331: POP
// result := hex ;
83332: LD_ADDR_VAR 0 3
83336: PUSH
83337: LD_VAR 0 7
83341: ST_TO_ADDR
// end ;
83342: LD_VAR 0 3
83346: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
83347: LD_INT 0
83349: PPUSH
83350: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83351: LD_VAR 0 1
83355: NOT
83356: PUSH
83357: LD_VAR 0 1
83361: PUSH
83362: LD_INT 21
83364: PUSH
83365: LD_INT 2
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 23
83374: PUSH
83375: LD_INT 2
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PPUSH
83386: CALL_OW 69
83390: IN
83391: NOT
83392: OR
83393: IFFALSE 83397
// exit ;
83395: GO 83444
// for i = 1 to 3 do
83397: LD_ADDR_VAR 0 3
83401: PUSH
83402: DOUBLE
83403: LD_INT 1
83405: DEC
83406: ST_TO_ADDR
83407: LD_INT 3
83409: PUSH
83410: FOR_TO
83411: IFFALSE 83442
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
83413: LD_VAR 0 1
83417: PPUSH
83418: CALL_OW 250
83422: PPUSH
83423: LD_VAR 0 1
83427: PPUSH
83428: CALL_OW 251
83432: PPUSH
83433: LD_INT 1
83435: PPUSH
83436: CALL_OW 453
83440: GO 83410
83442: POP
83443: POP
// end ;
83444: LD_VAR 0 2
83448: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
83449: LD_INT 0
83451: PPUSH
83452: PPUSH
83453: PPUSH
83454: PPUSH
83455: PPUSH
83456: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
83457: LD_VAR 0 1
83461: NOT
83462: PUSH
83463: LD_VAR 0 2
83467: NOT
83468: OR
83469: PUSH
83470: LD_VAR 0 1
83474: PPUSH
83475: CALL_OW 314
83479: OR
83480: IFFALSE 83484
// exit ;
83482: GO 83925
// x := GetX ( enemy_unit ) ;
83484: LD_ADDR_VAR 0 7
83488: PUSH
83489: LD_VAR 0 2
83493: PPUSH
83494: CALL_OW 250
83498: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
83499: LD_ADDR_VAR 0 8
83503: PUSH
83504: LD_VAR 0 2
83508: PPUSH
83509: CALL_OW 251
83513: ST_TO_ADDR
// if not x or not y then
83514: LD_VAR 0 7
83518: NOT
83519: PUSH
83520: LD_VAR 0 8
83524: NOT
83525: OR
83526: IFFALSE 83530
// exit ;
83528: GO 83925
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
83530: LD_ADDR_VAR 0 6
83534: PUSH
83535: LD_VAR 0 7
83539: PPUSH
83540: LD_INT 0
83542: PPUSH
83543: LD_INT 4
83545: PPUSH
83546: CALL_OW 272
83550: PUSH
83551: LD_VAR 0 8
83555: PPUSH
83556: LD_INT 0
83558: PPUSH
83559: LD_INT 4
83561: PPUSH
83562: CALL_OW 273
83566: PUSH
83567: EMPTY
83568: LIST
83569: LIST
83570: PUSH
83571: LD_VAR 0 7
83575: PPUSH
83576: LD_INT 1
83578: PPUSH
83579: LD_INT 4
83581: PPUSH
83582: CALL_OW 272
83586: PUSH
83587: LD_VAR 0 8
83591: PPUSH
83592: LD_INT 1
83594: PPUSH
83595: LD_INT 4
83597: PPUSH
83598: CALL_OW 273
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: PUSH
83607: LD_VAR 0 7
83611: PPUSH
83612: LD_INT 2
83614: PPUSH
83615: LD_INT 4
83617: PPUSH
83618: CALL_OW 272
83622: PUSH
83623: LD_VAR 0 8
83627: PPUSH
83628: LD_INT 2
83630: PPUSH
83631: LD_INT 4
83633: PPUSH
83634: CALL_OW 273
83638: PUSH
83639: EMPTY
83640: LIST
83641: LIST
83642: PUSH
83643: LD_VAR 0 7
83647: PPUSH
83648: LD_INT 3
83650: PPUSH
83651: LD_INT 4
83653: PPUSH
83654: CALL_OW 272
83658: PUSH
83659: LD_VAR 0 8
83663: PPUSH
83664: LD_INT 3
83666: PPUSH
83667: LD_INT 4
83669: PPUSH
83670: CALL_OW 273
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: PUSH
83679: LD_VAR 0 7
83683: PPUSH
83684: LD_INT 4
83686: PPUSH
83687: LD_INT 4
83689: PPUSH
83690: CALL_OW 272
83694: PUSH
83695: LD_VAR 0 8
83699: PPUSH
83700: LD_INT 4
83702: PPUSH
83703: LD_INT 4
83705: PPUSH
83706: CALL_OW 273
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_VAR 0 7
83719: PPUSH
83720: LD_INT 5
83722: PPUSH
83723: LD_INT 4
83725: PPUSH
83726: CALL_OW 272
83730: PUSH
83731: LD_VAR 0 8
83735: PPUSH
83736: LD_INT 5
83738: PPUSH
83739: LD_INT 4
83741: PPUSH
83742: CALL_OW 273
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: ST_TO_ADDR
// for i = tmp downto 1 do
83759: LD_ADDR_VAR 0 4
83763: PUSH
83764: DOUBLE
83765: LD_VAR 0 6
83769: INC
83770: ST_TO_ADDR
83771: LD_INT 1
83773: PUSH
83774: FOR_DOWNTO
83775: IFFALSE 83876
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83777: LD_VAR 0 6
83781: PUSH
83782: LD_VAR 0 4
83786: ARRAY
83787: PUSH
83788: LD_INT 1
83790: ARRAY
83791: PPUSH
83792: LD_VAR 0 6
83796: PUSH
83797: LD_VAR 0 4
83801: ARRAY
83802: PUSH
83803: LD_INT 2
83805: ARRAY
83806: PPUSH
83807: CALL_OW 488
83811: NOT
83812: PUSH
83813: LD_VAR 0 6
83817: PUSH
83818: LD_VAR 0 4
83822: ARRAY
83823: PUSH
83824: LD_INT 1
83826: ARRAY
83827: PPUSH
83828: LD_VAR 0 6
83832: PUSH
83833: LD_VAR 0 4
83837: ARRAY
83838: PUSH
83839: LD_INT 2
83841: ARRAY
83842: PPUSH
83843: CALL_OW 428
83847: PUSH
83848: LD_INT 0
83850: NONEQUAL
83851: OR
83852: IFFALSE 83874
// tmp := Delete ( tmp , i ) ;
83854: LD_ADDR_VAR 0 6
83858: PUSH
83859: LD_VAR 0 6
83863: PPUSH
83864: LD_VAR 0 4
83868: PPUSH
83869: CALL_OW 3
83873: ST_TO_ADDR
83874: GO 83774
83876: POP
83877: POP
// j := GetClosestHex ( unit , tmp ) ;
83878: LD_ADDR_VAR 0 5
83882: PUSH
83883: LD_VAR 0 1
83887: PPUSH
83888: LD_VAR 0 6
83892: PPUSH
83893: CALL 83178 0 2
83897: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83898: LD_VAR 0 1
83902: PPUSH
83903: LD_VAR 0 5
83907: PUSH
83908: LD_INT 1
83910: ARRAY
83911: PPUSH
83912: LD_VAR 0 5
83916: PUSH
83917: LD_INT 2
83919: ARRAY
83920: PPUSH
83921: CALL_OW 111
// end ;
83925: LD_VAR 0 3
83929: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83930: LD_INT 0
83932: PPUSH
83933: PPUSH
83934: PPUSH
// uc_side = 0 ;
83935: LD_ADDR_OWVAR 20
83939: PUSH
83940: LD_INT 0
83942: ST_TO_ADDR
// uc_nation = 0 ;
83943: LD_ADDR_OWVAR 21
83947: PUSH
83948: LD_INT 0
83950: ST_TO_ADDR
// InitHc ;
83951: CALL_OW 19
// InitVc ;
83955: CALL_OW 20
// if mastodonts then
83959: LD_VAR 0 6
83963: IFFALSE 84030
// for i = 1 to mastodonts do
83965: LD_ADDR_VAR 0 11
83969: PUSH
83970: DOUBLE
83971: LD_INT 1
83973: DEC
83974: ST_TO_ADDR
83975: LD_VAR 0 6
83979: PUSH
83980: FOR_TO
83981: IFFALSE 84028
// begin vc_chassis := 31 ;
83983: LD_ADDR_OWVAR 37
83987: PUSH
83988: LD_INT 31
83990: ST_TO_ADDR
// vc_control := control_rider ;
83991: LD_ADDR_OWVAR 38
83995: PUSH
83996: LD_INT 4
83998: ST_TO_ADDR
// animal := CreateVehicle ;
83999: LD_ADDR_VAR 0 12
84003: PUSH
84004: CALL_OW 45
84008: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84009: LD_VAR 0 12
84013: PPUSH
84014: LD_VAR 0 8
84018: PPUSH
84019: LD_INT 0
84021: PPUSH
84022: CALL 90775 0 3
// end ;
84026: GO 83980
84028: POP
84029: POP
// if horses then
84030: LD_VAR 0 5
84034: IFFALSE 84101
// for i = 1 to horses do
84036: LD_ADDR_VAR 0 11
84040: PUSH
84041: DOUBLE
84042: LD_INT 1
84044: DEC
84045: ST_TO_ADDR
84046: LD_VAR 0 5
84050: PUSH
84051: FOR_TO
84052: IFFALSE 84099
// begin hc_class := 21 ;
84054: LD_ADDR_OWVAR 28
84058: PUSH
84059: LD_INT 21
84061: ST_TO_ADDR
// hc_gallery :=  ;
84062: LD_ADDR_OWVAR 33
84066: PUSH
84067: LD_STRING 
84069: ST_TO_ADDR
// animal := CreateHuman ;
84070: LD_ADDR_VAR 0 12
84074: PUSH
84075: CALL_OW 44
84079: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84080: LD_VAR 0 12
84084: PPUSH
84085: LD_VAR 0 8
84089: PPUSH
84090: LD_INT 0
84092: PPUSH
84093: CALL 90775 0 3
// end ;
84097: GO 84051
84099: POP
84100: POP
// if birds then
84101: LD_VAR 0 1
84105: IFFALSE 84172
// for i = 1 to birds do
84107: LD_ADDR_VAR 0 11
84111: PUSH
84112: DOUBLE
84113: LD_INT 1
84115: DEC
84116: ST_TO_ADDR
84117: LD_VAR 0 1
84121: PUSH
84122: FOR_TO
84123: IFFALSE 84170
// begin hc_class = 18 ;
84125: LD_ADDR_OWVAR 28
84129: PUSH
84130: LD_INT 18
84132: ST_TO_ADDR
// hc_gallery =  ;
84133: LD_ADDR_OWVAR 33
84137: PUSH
84138: LD_STRING 
84140: ST_TO_ADDR
// animal := CreateHuman ;
84141: LD_ADDR_VAR 0 12
84145: PUSH
84146: CALL_OW 44
84150: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84151: LD_VAR 0 12
84155: PPUSH
84156: LD_VAR 0 8
84160: PPUSH
84161: LD_INT 0
84163: PPUSH
84164: CALL 90775 0 3
// end ;
84168: GO 84122
84170: POP
84171: POP
// if tigers then
84172: LD_VAR 0 2
84176: IFFALSE 84260
// for i = 1 to tigers do
84178: LD_ADDR_VAR 0 11
84182: PUSH
84183: DOUBLE
84184: LD_INT 1
84186: DEC
84187: ST_TO_ADDR
84188: LD_VAR 0 2
84192: PUSH
84193: FOR_TO
84194: IFFALSE 84258
// begin hc_class = class_tiger ;
84196: LD_ADDR_OWVAR 28
84200: PUSH
84201: LD_INT 14
84203: ST_TO_ADDR
// hc_gallery =  ;
84204: LD_ADDR_OWVAR 33
84208: PUSH
84209: LD_STRING 
84211: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84212: LD_ADDR_OWVAR 35
84216: PUSH
84217: LD_INT 7
84219: NEG
84220: PPUSH
84221: LD_INT 7
84223: PPUSH
84224: CALL_OW 12
84228: ST_TO_ADDR
// animal := CreateHuman ;
84229: LD_ADDR_VAR 0 12
84233: PUSH
84234: CALL_OW 44
84238: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84239: LD_VAR 0 12
84243: PPUSH
84244: LD_VAR 0 8
84248: PPUSH
84249: LD_INT 0
84251: PPUSH
84252: CALL 90775 0 3
// end ;
84256: GO 84193
84258: POP
84259: POP
// if apemans then
84260: LD_VAR 0 3
84264: IFFALSE 84387
// for i = 1 to apemans do
84266: LD_ADDR_VAR 0 11
84270: PUSH
84271: DOUBLE
84272: LD_INT 1
84274: DEC
84275: ST_TO_ADDR
84276: LD_VAR 0 3
84280: PUSH
84281: FOR_TO
84282: IFFALSE 84385
// begin hc_class = class_apeman ;
84284: LD_ADDR_OWVAR 28
84288: PUSH
84289: LD_INT 12
84291: ST_TO_ADDR
// hc_gallery =  ;
84292: LD_ADDR_OWVAR 33
84296: PUSH
84297: LD_STRING 
84299: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
84300: LD_ADDR_OWVAR 35
84304: PUSH
84305: LD_INT 5
84307: NEG
84308: PPUSH
84309: LD_INT 5
84311: PPUSH
84312: CALL_OW 12
84316: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
84317: LD_ADDR_OWVAR 31
84321: PUSH
84322: LD_INT 1
84324: PPUSH
84325: LD_INT 3
84327: PPUSH
84328: CALL_OW 12
84332: PUSH
84333: LD_INT 1
84335: PPUSH
84336: LD_INT 3
84338: PPUSH
84339: CALL_OW 12
84343: PUSH
84344: LD_INT 0
84346: PUSH
84347: LD_INT 0
84349: PUSH
84350: EMPTY
84351: LIST
84352: LIST
84353: LIST
84354: LIST
84355: ST_TO_ADDR
// animal := CreateHuman ;
84356: LD_ADDR_VAR 0 12
84360: PUSH
84361: CALL_OW 44
84365: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84366: LD_VAR 0 12
84370: PPUSH
84371: LD_VAR 0 8
84375: PPUSH
84376: LD_INT 0
84378: PPUSH
84379: CALL 90775 0 3
// end ;
84383: GO 84281
84385: POP
84386: POP
// if enchidnas then
84387: LD_VAR 0 4
84391: IFFALSE 84458
// for i = 1 to enchidnas do
84393: LD_ADDR_VAR 0 11
84397: PUSH
84398: DOUBLE
84399: LD_INT 1
84401: DEC
84402: ST_TO_ADDR
84403: LD_VAR 0 4
84407: PUSH
84408: FOR_TO
84409: IFFALSE 84456
// begin hc_class = 13 ;
84411: LD_ADDR_OWVAR 28
84415: PUSH
84416: LD_INT 13
84418: ST_TO_ADDR
// hc_gallery =  ;
84419: LD_ADDR_OWVAR 33
84423: PUSH
84424: LD_STRING 
84426: ST_TO_ADDR
// animal := CreateHuman ;
84427: LD_ADDR_VAR 0 12
84431: PUSH
84432: CALL_OW 44
84436: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84437: LD_VAR 0 12
84441: PPUSH
84442: LD_VAR 0 8
84446: PPUSH
84447: LD_INT 0
84449: PPUSH
84450: CALL 90775 0 3
// end ;
84454: GO 84408
84456: POP
84457: POP
// if fishes then
84458: LD_VAR 0 7
84462: IFFALSE 84529
// for i = 1 to fishes do
84464: LD_ADDR_VAR 0 11
84468: PUSH
84469: DOUBLE
84470: LD_INT 1
84472: DEC
84473: ST_TO_ADDR
84474: LD_VAR 0 7
84478: PUSH
84479: FOR_TO
84480: IFFALSE 84527
// begin hc_class = 20 ;
84482: LD_ADDR_OWVAR 28
84486: PUSH
84487: LD_INT 20
84489: ST_TO_ADDR
// hc_gallery =  ;
84490: LD_ADDR_OWVAR 33
84494: PUSH
84495: LD_STRING 
84497: ST_TO_ADDR
// animal := CreateHuman ;
84498: LD_ADDR_VAR 0 12
84502: PUSH
84503: CALL_OW 44
84507: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84508: LD_VAR 0 12
84512: PPUSH
84513: LD_VAR 0 9
84517: PPUSH
84518: LD_INT 0
84520: PPUSH
84521: CALL 90775 0 3
// end ;
84525: GO 84479
84527: POP
84528: POP
// end ;
84529: LD_VAR 0 10
84533: RET
// export function WantHeal ( sci , unit ) ; begin
84534: LD_INT 0
84536: PPUSH
// if GetTaskList ( sci ) > 0 then
84537: LD_VAR 0 1
84541: PPUSH
84542: CALL_OW 437
84546: PUSH
84547: LD_INT 0
84549: GREATER
84550: IFFALSE 84620
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84552: LD_VAR 0 1
84556: PPUSH
84557: CALL_OW 437
84561: PUSH
84562: LD_INT 1
84564: ARRAY
84565: PUSH
84566: LD_INT 1
84568: ARRAY
84569: PUSH
84570: LD_STRING l
84572: EQUAL
84573: PUSH
84574: LD_VAR 0 1
84578: PPUSH
84579: CALL_OW 437
84583: PUSH
84584: LD_INT 1
84586: ARRAY
84587: PUSH
84588: LD_INT 4
84590: ARRAY
84591: PUSH
84592: LD_VAR 0 2
84596: EQUAL
84597: AND
84598: IFFALSE 84610
// result := true else
84600: LD_ADDR_VAR 0 3
84604: PUSH
84605: LD_INT 1
84607: ST_TO_ADDR
84608: GO 84618
// result := false ;
84610: LD_ADDR_VAR 0 3
84614: PUSH
84615: LD_INT 0
84617: ST_TO_ADDR
// end else
84618: GO 84628
// result := false ;
84620: LD_ADDR_VAR 0 3
84624: PUSH
84625: LD_INT 0
84627: ST_TO_ADDR
// end ;
84628: LD_VAR 0 3
84632: RET
// export function HealTarget ( sci ) ; begin
84633: LD_INT 0
84635: PPUSH
// if not sci then
84636: LD_VAR 0 1
84640: NOT
84641: IFFALSE 84645
// exit ;
84643: GO 84710
// result := 0 ;
84645: LD_ADDR_VAR 0 2
84649: PUSH
84650: LD_INT 0
84652: ST_TO_ADDR
// if GetTaskList ( sci ) then
84653: LD_VAR 0 1
84657: PPUSH
84658: CALL_OW 437
84662: IFFALSE 84710
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84664: LD_VAR 0 1
84668: PPUSH
84669: CALL_OW 437
84673: PUSH
84674: LD_INT 1
84676: ARRAY
84677: PUSH
84678: LD_INT 1
84680: ARRAY
84681: PUSH
84682: LD_STRING l
84684: EQUAL
84685: IFFALSE 84710
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84687: LD_ADDR_VAR 0 2
84691: PUSH
84692: LD_VAR 0 1
84696: PPUSH
84697: CALL_OW 437
84701: PUSH
84702: LD_INT 1
84704: ARRAY
84705: PUSH
84706: LD_INT 4
84708: ARRAY
84709: ST_TO_ADDR
// end ;
84710: LD_VAR 0 2
84714: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
84715: LD_INT 0
84717: PPUSH
84718: PPUSH
84719: PPUSH
84720: PPUSH
84721: PPUSH
84722: PPUSH
84723: PPUSH
84724: PPUSH
84725: PPUSH
84726: PPUSH
84727: PPUSH
84728: PPUSH
84729: PPUSH
84730: PPUSH
84731: PPUSH
84732: PPUSH
84733: PPUSH
84734: PPUSH
84735: PPUSH
84736: PPUSH
84737: PPUSH
84738: PPUSH
84739: PPUSH
84740: PPUSH
84741: PPUSH
84742: PPUSH
84743: PPUSH
84744: PPUSH
84745: PPUSH
84746: PPUSH
84747: PPUSH
84748: PPUSH
84749: PPUSH
84750: PPUSH
// if not list then
84751: LD_VAR 0 1
84755: NOT
84756: IFFALSE 84760
// exit ;
84758: GO 89386
// base := list [ 1 ] ;
84760: LD_ADDR_VAR 0 3
84764: PUSH
84765: LD_VAR 0 1
84769: PUSH
84770: LD_INT 1
84772: ARRAY
84773: ST_TO_ADDR
// group := list [ 2 ] ;
84774: LD_ADDR_VAR 0 4
84778: PUSH
84779: LD_VAR 0 1
84783: PUSH
84784: LD_INT 2
84786: ARRAY
84787: ST_TO_ADDR
// path := list [ 3 ] ;
84788: LD_ADDR_VAR 0 5
84792: PUSH
84793: LD_VAR 0 1
84797: PUSH
84798: LD_INT 3
84800: ARRAY
84801: ST_TO_ADDR
// flags := list [ 4 ] ;
84802: LD_ADDR_VAR 0 6
84806: PUSH
84807: LD_VAR 0 1
84811: PUSH
84812: LD_INT 4
84814: ARRAY
84815: ST_TO_ADDR
// mined := [ ] ;
84816: LD_ADDR_VAR 0 27
84820: PUSH
84821: EMPTY
84822: ST_TO_ADDR
// bombed := [ ] ;
84823: LD_ADDR_VAR 0 28
84827: PUSH
84828: EMPTY
84829: ST_TO_ADDR
// healers := [ ] ;
84830: LD_ADDR_VAR 0 31
84834: PUSH
84835: EMPTY
84836: ST_TO_ADDR
// to_heal := [ ] ;
84837: LD_ADDR_VAR 0 30
84841: PUSH
84842: EMPTY
84843: ST_TO_ADDR
// repairs := [ ] ;
84844: LD_ADDR_VAR 0 33
84848: PUSH
84849: EMPTY
84850: ST_TO_ADDR
// to_repair := [ ] ;
84851: LD_ADDR_VAR 0 32
84855: PUSH
84856: EMPTY
84857: ST_TO_ADDR
// if not group or not path then
84858: LD_VAR 0 4
84862: NOT
84863: PUSH
84864: LD_VAR 0 5
84868: NOT
84869: OR
84870: IFFALSE 84874
// exit ;
84872: GO 89386
// side := GetSide ( group [ 1 ] ) ;
84874: LD_ADDR_VAR 0 35
84878: PUSH
84879: LD_VAR 0 4
84883: PUSH
84884: LD_INT 1
84886: ARRAY
84887: PPUSH
84888: CALL_OW 255
84892: ST_TO_ADDR
// if flags then
84893: LD_VAR 0 6
84897: IFFALSE 85041
// begin f_ignore_area := flags [ 1 ] ;
84899: LD_ADDR_VAR 0 17
84903: PUSH
84904: LD_VAR 0 6
84908: PUSH
84909: LD_INT 1
84911: ARRAY
84912: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
84913: LD_ADDR_VAR 0 18
84917: PUSH
84918: LD_VAR 0 6
84922: PUSH
84923: LD_INT 2
84925: ARRAY
84926: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
84927: LD_ADDR_VAR 0 19
84931: PUSH
84932: LD_VAR 0 6
84936: PUSH
84937: LD_INT 3
84939: ARRAY
84940: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
84941: LD_ADDR_VAR 0 20
84945: PUSH
84946: LD_VAR 0 6
84950: PUSH
84951: LD_INT 4
84953: ARRAY
84954: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
84955: LD_ADDR_VAR 0 21
84959: PUSH
84960: LD_VAR 0 6
84964: PUSH
84965: LD_INT 5
84967: ARRAY
84968: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
84969: LD_ADDR_VAR 0 22
84973: PUSH
84974: LD_VAR 0 6
84978: PUSH
84979: LD_INT 6
84981: ARRAY
84982: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
84983: LD_ADDR_VAR 0 23
84987: PUSH
84988: LD_VAR 0 6
84992: PUSH
84993: LD_INT 7
84995: ARRAY
84996: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
84997: LD_ADDR_VAR 0 24
85001: PUSH
85002: LD_VAR 0 6
85006: PUSH
85007: LD_INT 8
85009: ARRAY
85010: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
85011: LD_ADDR_VAR 0 25
85015: PUSH
85016: LD_VAR 0 6
85020: PUSH
85021: LD_INT 9
85023: ARRAY
85024: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
85025: LD_ADDR_VAR 0 26
85029: PUSH
85030: LD_VAR 0 6
85034: PUSH
85035: LD_INT 10
85037: ARRAY
85038: ST_TO_ADDR
// end else
85039: GO 85121
// begin f_ignore_area := false ;
85041: LD_ADDR_VAR 0 17
85045: PUSH
85046: LD_INT 0
85048: ST_TO_ADDR
// f_capture := false ;
85049: LD_ADDR_VAR 0 18
85053: PUSH
85054: LD_INT 0
85056: ST_TO_ADDR
// f_ignore_civ := false ;
85057: LD_ADDR_VAR 0 19
85061: PUSH
85062: LD_INT 0
85064: ST_TO_ADDR
// f_murder := false ;
85065: LD_ADDR_VAR 0 20
85069: PUSH
85070: LD_INT 0
85072: ST_TO_ADDR
// f_mines := false ;
85073: LD_ADDR_VAR 0 21
85077: PUSH
85078: LD_INT 0
85080: ST_TO_ADDR
// f_repair := false ;
85081: LD_ADDR_VAR 0 22
85085: PUSH
85086: LD_INT 0
85088: ST_TO_ADDR
// f_heal := false ;
85089: LD_ADDR_VAR 0 23
85093: PUSH
85094: LD_INT 0
85096: ST_TO_ADDR
// f_spacetime := false ;
85097: LD_ADDR_VAR 0 24
85101: PUSH
85102: LD_INT 0
85104: ST_TO_ADDR
// f_attack_depot := false ;
85105: LD_ADDR_VAR 0 25
85109: PUSH
85110: LD_INT 0
85112: ST_TO_ADDR
// f_crawl := false ;
85113: LD_ADDR_VAR 0 26
85117: PUSH
85118: LD_INT 0
85120: ST_TO_ADDR
// end ; if f_heal then
85121: LD_VAR 0 23
85125: IFFALSE 85152
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
85127: LD_ADDR_VAR 0 31
85131: PUSH
85132: LD_VAR 0 4
85136: PPUSH
85137: LD_INT 25
85139: PUSH
85140: LD_INT 4
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PPUSH
85147: CALL_OW 72
85151: ST_TO_ADDR
// if f_repair then
85152: LD_VAR 0 22
85156: IFFALSE 85183
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
85158: LD_ADDR_VAR 0 33
85162: PUSH
85163: LD_VAR 0 4
85167: PPUSH
85168: LD_INT 25
85170: PUSH
85171: LD_INT 3
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: PPUSH
85178: CALL_OW 72
85182: ST_TO_ADDR
// units_path := [ ] ;
85183: LD_ADDR_VAR 0 16
85187: PUSH
85188: EMPTY
85189: ST_TO_ADDR
// for i = 1 to group do
85190: LD_ADDR_VAR 0 7
85194: PUSH
85195: DOUBLE
85196: LD_INT 1
85198: DEC
85199: ST_TO_ADDR
85200: LD_VAR 0 4
85204: PUSH
85205: FOR_TO
85206: IFFALSE 85235
// units_path := Replace ( units_path , i , path ) ;
85208: LD_ADDR_VAR 0 16
85212: PUSH
85213: LD_VAR 0 16
85217: PPUSH
85218: LD_VAR 0 7
85222: PPUSH
85223: LD_VAR 0 5
85227: PPUSH
85228: CALL_OW 1
85232: ST_TO_ADDR
85233: GO 85205
85235: POP
85236: POP
// repeat for i = group downto 1 do
85237: LD_ADDR_VAR 0 7
85241: PUSH
85242: DOUBLE
85243: LD_VAR 0 4
85247: INC
85248: ST_TO_ADDR
85249: LD_INT 1
85251: PUSH
85252: FOR_DOWNTO
85253: IFFALSE 89349
// begin wait ( 5 ) ;
85255: LD_INT 5
85257: PPUSH
85258: CALL_OW 67
// tmp := [ ] ;
85262: LD_ADDR_VAR 0 14
85266: PUSH
85267: EMPTY
85268: ST_TO_ADDR
// attacking := false ;
85269: LD_ADDR_VAR 0 29
85273: PUSH
85274: LD_INT 0
85276: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
85277: LD_VAR 0 4
85281: PUSH
85282: LD_VAR 0 7
85286: ARRAY
85287: PPUSH
85288: CALL_OW 301
85292: PUSH
85293: LD_VAR 0 4
85297: PUSH
85298: LD_VAR 0 7
85302: ARRAY
85303: NOT
85304: OR
85305: IFFALSE 85414
// begin if GetType ( group [ i ] ) = unit_human then
85307: LD_VAR 0 4
85311: PUSH
85312: LD_VAR 0 7
85316: ARRAY
85317: PPUSH
85318: CALL_OW 247
85322: PUSH
85323: LD_INT 1
85325: EQUAL
85326: IFFALSE 85372
// begin to_heal := to_heal diff group [ i ] ;
85328: LD_ADDR_VAR 0 30
85332: PUSH
85333: LD_VAR 0 30
85337: PUSH
85338: LD_VAR 0 4
85342: PUSH
85343: LD_VAR 0 7
85347: ARRAY
85348: DIFF
85349: ST_TO_ADDR
// healers := healers diff group [ i ] ;
85350: LD_ADDR_VAR 0 31
85354: PUSH
85355: LD_VAR 0 31
85359: PUSH
85360: LD_VAR 0 4
85364: PUSH
85365: LD_VAR 0 7
85369: ARRAY
85370: DIFF
85371: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
85372: LD_ADDR_VAR 0 4
85376: PUSH
85377: LD_VAR 0 4
85381: PPUSH
85382: LD_VAR 0 7
85386: PPUSH
85387: CALL_OW 3
85391: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
85392: LD_ADDR_VAR 0 16
85396: PUSH
85397: LD_VAR 0 16
85401: PPUSH
85402: LD_VAR 0 7
85406: PPUSH
85407: CALL_OW 3
85411: ST_TO_ADDR
// continue ;
85412: GO 85252
// end ; if f_repair then
85414: LD_VAR 0 22
85418: IFFALSE 85907
// begin if GetType ( group [ i ] ) = unit_vehicle then
85420: LD_VAR 0 4
85424: PUSH
85425: LD_VAR 0 7
85429: ARRAY
85430: PPUSH
85431: CALL_OW 247
85435: PUSH
85436: LD_INT 2
85438: EQUAL
85439: IFFALSE 85629
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
85441: LD_VAR 0 4
85445: PUSH
85446: LD_VAR 0 7
85450: ARRAY
85451: PPUSH
85452: CALL_OW 256
85456: PUSH
85457: LD_INT 700
85459: LESS
85460: PUSH
85461: LD_VAR 0 4
85465: PUSH
85466: LD_VAR 0 7
85470: ARRAY
85471: PUSH
85472: LD_VAR 0 32
85476: IN
85477: NOT
85478: AND
85479: IFFALSE 85503
// to_repair := to_repair union group [ i ] ;
85481: LD_ADDR_VAR 0 32
85485: PUSH
85486: LD_VAR 0 32
85490: PUSH
85491: LD_VAR 0 4
85495: PUSH
85496: LD_VAR 0 7
85500: ARRAY
85501: UNION
85502: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
85503: LD_VAR 0 4
85507: PUSH
85508: LD_VAR 0 7
85512: ARRAY
85513: PPUSH
85514: CALL_OW 256
85518: PUSH
85519: LD_INT 1000
85521: EQUAL
85522: PUSH
85523: LD_VAR 0 4
85527: PUSH
85528: LD_VAR 0 7
85532: ARRAY
85533: PUSH
85534: LD_VAR 0 32
85538: IN
85539: AND
85540: IFFALSE 85564
// to_repair := to_repair diff group [ i ] ;
85542: LD_ADDR_VAR 0 32
85546: PUSH
85547: LD_VAR 0 32
85551: PUSH
85552: LD_VAR 0 4
85556: PUSH
85557: LD_VAR 0 7
85561: ARRAY
85562: DIFF
85563: ST_TO_ADDR
// if group [ i ] in to_repair then
85564: LD_VAR 0 4
85568: PUSH
85569: LD_VAR 0 7
85573: ARRAY
85574: PUSH
85575: LD_VAR 0 32
85579: IN
85580: IFFALSE 85627
// begin if not IsInArea ( group [ i ] , f_repair ) then
85582: LD_VAR 0 4
85586: PUSH
85587: LD_VAR 0 7
85591: ARRAY
85592: PPUSH
85593: LD_VAR 0 22
85597: PPUSH
85598: CALL_OW 308
85602: NOT
85603: IFFALSE 85625
// ComMoveToArea ( group [ i ] , f_repair ) ;
85605: LD_VAR 0 4
85609: PUSH
85610: LD_VAR 0 7
85614: ARRAY
85615: PPUSH
85616: LD_VAR 0 22
85620: PPUSH
85621: CALL_OW 113
// continue ;
85625: GO 85252
// end ; end else
85627: GO 85907
// if group [ i ] in repairs then
85629: LD_VAR 0 4
85633: PUSH
85634: LD_VAR 0 7
85638: ARRAY
85639: PUSH
85640: LD_VAR 0 33
85644: IN
85645: IFFALSE 85907
// begin if IsInUnit ( group [ i ] ) then
85647: LD_VAR 0 4
85651: PUSH
85652: LD_VAR 0 7
85656: ARRAY
85657: PPUSH
85658: CALL_OW 310
85662: IFFALSE 85730
// begin z := IsInUnit ( group [ i ] ) ;
85664: LD_ADDR_VAR 0 13
85668: PUSH
85669: LD_VAR 0 4
85673: PUSH
85674: LD_VAR 0 7
85678: ARRAY
85679: PPUSH
85680: CALL_OW 310
85684: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
85685: LD_VAR 0 13
85689: PUSH
85690: LD_VAR 0 32
85694: IN
85695: PUSH
85696: LD_VAR 0 13
85700: PPUSH
85701: LD_VAR 0 22
85705: PPUSH
85706: CALL_OW 308
85710: AND
85711: IFFALSE 85728
// ComExitVehicle ( group [ i ] ) ;
85713: LD_VAR 0 4
85717: PUSH
85718: LD_VAR 0 7
85722: ARRAY
85723: PPUSH
85724: CALL_OW 121
// end else
85728: GO 85907
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
85730: LD_ADDR_VAR 0 13
85734: PUSH
85735: LD_VAR 0 4
85739: PPUSH
85740: LD_INT 95
85742: PUSH
85743: LD_VAR 0 22
85747: PUSH
85748: EMPTY
85749: LIST
85750: LIST
85751: PUSH
85752: LD_INT 58
85754: PUSH
85755: EMPTY
85756: LIST
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PPUSH
85762: CALL_OW 72
85766: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
85767: LD_VAR 0 4
85771: PUSH
85772: LD_VAR 0 7
85776: ARRAY
85777: PPUSH
85778: CALL_OW 314
85782: NOT
85783: IFFALSE 85905
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
85785: LD_ADDR_VAR 0 10
85789: PUSH
85790: LD_VAR 0 13
85794: PPUSH
85795: LD_VAR 0 4
85799: PUSH
85800: LD_VAR 0 7
85804: ARRAY
85805: PPUSH
85806: CALL_OW 74
85810: ST_TO_ADDR
// if not x then
85811: LD_VAR 0 10
85815: NOT
85816: IFFALSE 85820
// continue ;
85818: GO 85252
// if GetLives ( x ) < 1000 then
85820: LD_VAR 0 10
85824: PPUSH
85825: CALL_OW 256
85829: PUSH
85830: LD_INT 1000
85832: LESS
85833: IFFALSE 85857
// ComRepairVehicle ( group [ i ] , x ) else
85835: LD_VAR 0 4
85839: PUSH
85840: LD_VAR 0 7
85844: ARRAY
85845: PPUSH
85846: LD_VAR 0 10
85850: PPUSH
85851: CALL_OW 129
85855: GO 85905
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
85857: LD_VAR 0 23
85861: PUSH
85862: LD_VAR 0 4
85866: PUSH
85867: LD_VAR 0 7
85871: ARRAY
85872: PPUSH
85873: CALL_OW 256
85877: PUSH
85878: LD_INT 1000
85880: LESS
85881: AND
85882: NOT
85883: IFFALSE 85905
// ComEnterUnit ( group [ i ] , x ) ;
85885: LD_VAR 0 4
85889: PUSH
85890: LD_VAR 0 7
85894: ARRAY
85895: PPUSH
85896: LD_VAR 0 10
85900: PPUSH
85901: CALL_OW 120
// end ; continue ;
85905: GO 85252
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
85907: LD_VAR 0 23
85911: PUSH
85912: LD_VAR 0 4
85916: PUSH
85917: LD_VAR 0 7
85921: ARRAY
85922: PPUSH
85923: CALL_OW 247
85927: PUSH
85928: LD_INT 1
85930: EQUAL
85931: AND
85932: IFFALSE 86410
// begin if group [ i ] in healers then
85934: LD_VAR 0 4
85938: PUSH
85939: LD_VAR 0 7
85943: ARRAY
85944: PUSH
85945: LD_VAR 0 31
85949: IN
85950: IFFALSE 86223
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
85952: LD_VAR 0 4
85956: PUSH
85957: LD_VAR 0 7
85961: ARRAY
85962: PPUSH
85963: LD_VAR 0 23
85967: PPUSH
85968: CALL_OW 308
85972: NOT
85973: PUSH
85974: LD_VAR 0 4
85978: PUSH
85979: LD_VAR 0 7
85983: ARRAY
85984: PPUSH
85985: CALL_OW 314
85989: NOT
85990: AND
85991: IFFALSE 86015
// ComMoveToArea ( group [ i ] , f_heal ) else
85993: LD_VAR 0 4
85997: PUSH
85998: LD_VAR 0 7
86002: ARRAY
86003: PPUSH
86004: LD_VAR 0 23
86008: PPUSH
86009: CALL_OW 113
86013: GO 86221
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
86015: LD_VAR 0 4
86019: PUSH
86020: LD_VAR 0 7
86024: ARRAY
86025: PPUSH
86026: CALL 84633 0 1
86030: PPUSH
86031: CALL_OW 256
86035: PUSH
86036: LD_INT 1000
86038: EQUAL
86039: IFFALSE 86058
// ComStop ( group [ i ] ) else
86041: LD_VAR 0 4
86045: PUSH
86046: LD_VAR 0 7
86050: ARRAY
86051: PPUSH
86052: CALL_OW 141
86056: GO 86221
// if not HasTask ( group [ i ] ) and to_heal then
86058: LD_VAR 0 4
86062: PUSH
86063: LD_VAR 0 7
86067: ARRAY
86068: PPUSH
86069: CALL_OW 314
86073: NOT
86074: PUSH
86075: LD_VAR 0 30
86079: AND
86080: IFFALSE 86221
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
86082: LD_ADDR_VAR 0 13
86086: PUSH
86087: LD_VAR 0 30
86091: PPUSH
86092: LD_INT 3
86094: PUSH
86095: LD_INT 54
86097: PUSH
86098: EMPTY
86099: LIST
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PPUSH
86105: CALL_OW 72
86109: PPUSH
86110: LD_VAR 0 4
86114: PUSH
86115: LD_VAR 0 7
86119: ARRAY
86120: PPUSH
86121: CALL_OW 74
86125: ST_TO_ADDR
// if z then
86126: LD_VAR 0 13
86130: IFFALSE 86221
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
86132: LD_INT 91
86134: PUSH
86135: LD_VAR 0 13
86139: PUSH
86140: LD_INT 10
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: LIST
86147: PUSH
86148: LD_INT 81
86150: PUSH
86151: LD_VAR 0 13
86155: PPUSH
86156: CALL_OW 255
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: EMPTY
86166: LIST
86167: LIST
86168: PPUSH
86169: CALL_OW 69
86173: PUSH
86174: LD_INT 0
86176: EQUAL
86177: IFFALSE 86201
// ComHeal ( group [ i ] , z ) else
86179: LD_VAR 0 4
86183: PUSH
86184: LD_VAR 0 7
86188: ARRAY
86189: PPUSH
86190: LD_VAR 0 13
86194: PPUSH
86195: CALL_OW 128
86199: GO 86221
// ComMoveToArea ( group [ i ] , f_heal ) ;
86201: LD_VAR 0 4
86205: PUSH
86206: LD_VAR 0 7
86210: ARRAY
86211: PPUSH
86212: LD_VAR 0 23
86216: PPUSH
86217: CALL_OW 113
// end ; continue ;
86221: GO 85252
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
86223: LD_VAR 0 4
86227: PUSH
86228: LD_VAR 0 7
86232: ARRAY
86233: PPUSH
86234: CALL_OW 256
86238: PUSH
86239: LD_INT 700
86241: LESS
86242: PUSH
86243: LD_VAR 0 4
86247: PUSH
86248: LD_VAR 0 7
86252: ARRAY
86253: PUSH
86254: LD_VAR 0 30
86258: IN
86259: NOT
86260: AND
86261: IFFALSE 86285
// to_heal := to_heal union group [ i ] ;
86263: LD_ADDR_VAR 0 30
86267: PUSH
86268: LD_VAR 0 30
86272: PUSH
86273: LD_VAR 0 4
86277: PUSH
86278: LD_VAR 0 7
86282: ARRAY
86283: UNION
86284: ST_TO_ADDR
// if group [ i ] in to_heal then
86285: LD_VAR 0 4
86289: PUSH
86290: LD_VAR 0 7
86294: ARRAY
86295: PUSH
86296: LD_VAR 0 30
86300: IN
86301: IFFALSE 86410
// begin if GetLives ( group [ i ] ) = 1000 then
86303: LD_VAR 0 4
86307: PUSH
86308: LD_VAR 0 7
86312: ARRAY
86313: PPUSH
86314: CALL_OW 256
86318: PUSH
86319: LD_INT 1000
86321: EQUAL
86322: IFFALSE 86348
// to_heal := to_heal diff group [ i ] else
86324: LD_ADDR_VAR 0 30
86328: PUSH
86329: LD_VAR 0 30
86333: PUSH
86334: LD_VAR 0 4
86338: PUSH
86339: LD_VAR 0 7
86343: ARRAY
86344: DIFF
86345: ST_TO_ADDR
86346: GO 86410
// begin if not IsInArea ( group [ i ] , to_heal ) then
86348: LD_VAR 0 4
86352: PUSH
86353: LD_VAR 0 7
86357: ARRAY
86358: PPUSH
86359: LD_VAR 0 30
86363: PPUSH
86364: CALL_OW 308
86368: NOT
86369: IFFALSE 86393
// ComMoveToArea ( group [ i ] , f_heal ) else
86371: LD_VAR 0 4
86375: PUSH
86376: LD_VAR 0 7
86380: ARRAY
86381: PPUSH
86382: LD_VAR 0 23
86386: PPUSH
86387: CALL_OW 113
86391: GO 86408
// ComHold ( group [ i ] ) ;
86393: LD_VAR 0 4
86397: PUSH
86398: LD_VAR 0 7
86402: ARRAY
86403: PPUSH
86404: CALL_OW 140
// continue ;
86408: GO 85252
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
86410: LD_VAR 0 4
86414: PUSH
86415: LD_VAR 0 7
86419: ARRAY
86420: PPUSH
86421: LD_INT 10
86423: PPUSH
86424: CALL 83030 0 2
86428: NOT
86429: PUSH
86430: LD_VAR 0 16
86434: PUSH
86435: LD_VAR 0 7
86439: ARRAY
86440: PUSH
86441: EMPTY
86442: EQUAL
86443: NOT
86444: AND
86445: IFFALSE 86711
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
86447: LD_VAR 0 4
86451: PUSH
86452: LD_VAR 0 7
86456: ARRAY
86457: PPUSH
86458: CALL_OW 262
86462: PUSH
86463: LD_INT 1
86465: PUSH
86466: LD_INT 2
86468: PUSH
86469: EMPTY
86470: LIST
86471: LIST
86472: IN
86473: IFFALSE 86514
// if GetFuel ( group [ i ] ) < 10 then
86475: LD_VAR 0 4
86479: PUSH
86480: LD_VAR 0 7
86484: ARRAY
86485: PPUSH
86486: CALL_OW 261
86490: PUSH
86491: LD_INT 10
86493: LESS
86494: IFFALSE 86514
// SetFuel ( group [ i ] , 12 ) ;
86496: LD_VAR 0 4
86500: PUSH
86501: LD_VAR 0 7
86505: ARRAY
86506: PPUSH
86507: LD_INT 12
86509: PPUSH
86510: CALL_OW 240
// if units_path [ i ] then
86514: LD_VAR 0 16
86518: PUSH
86519: LD_VAR 0 7
86523: ARRAY
86524: IFFALSE 86709
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
86526: LD_VAR 0 4
86530: PUSH
86531: LD_VAR 0 7
86535: ARRAY
86536: PPUSH
86537: LD_VAR 0 16
86541: PUSH
86542: LD_VAR 0 7
86546: ARRAY
86547: PUSH
86548: LD_INT 1
86550: ARRAY
86551: PUSH
86552: LD_INT 1
86554: ARRAY
86555: PPUSH
86556: LD_VAR 0 16
86560: PUSH
86561: LD_VAR 0 7
86565: ARRAY
86566: PUSH
86567: LD_INT 1
86569: ARRAY
86570: PUSH
86571: LD_INT 2
86573: ARRAY
86574: PPUSH
86575: CALL_OW 297
86579: PUSH
86580: LD_INT 6
86582: GREATER
86583: IFFALSE 86658
// begin if not HasTask ( group [ i ] ) then
86585: LD_VAR 0 4
86589: PUSH
86590: LD_VAR 0 7
86594: ARRAY
86595: PPUSH
86596: CALL_OW 314
86600: NOT
86601: IFFALSE 86656
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
86603: LD_VAR 0 4
86607: PUSH
86608: LD_VAR 0 7
86612: ARRAY
86613: PPUSH
86614: LD_VAR 0 16
86618: PUSH
86619: LD_VAR 0 7
86623: ARRAY
86624: PUSH
86625: LD_INT 1
86627: ARRAY
86628: PUSH
86629: LD_INT 1
86631: ARRAY
86632: PPUSH
86633: LD_VAR 0 16
86637: PUSH
86638: LD_VAR 0 7
86642: ARRAY
86643: PUSH
86644: LD_INT 1
86646: ARRAY
86647: PUSH
86648: LD_INT 2
86650: ARRAY
86651: PPUSH
86652: CALL_OW 114
// end else
86656: GO 86709
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
86658: LD_ADDR_VAR 0 15
86662: PUSH
86663: LD_VAR 0 16
86667: PUSH
86668: LD_VAR 0 7
86672: ARRAY
86673: PPUSH
86674: LD_INT 1
86676: PPUSH
86677: CALL_OW 3
86681: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
86682: LD_ADDR_VAR 0 16
86686: PUSH
86687: LD_VAR 0 16
86691: PPUSH
86692: LD_VAR 0 7
86696: PPUSH
86697: LD_VAR 0 15
86701: PPUSH
86702: CALL_OW 1
86706: ST_TO_ADDR
// continue ;
86707: GO 85252
// end ; end ; end else
86709: GO 89347
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
86711: LD_ADDR_VAR 0 14
86715: PUSH
86716: LD_INT 81
86718: PUSH
86719: LD_VAR 0 4
86723: PUSH
86724: LD_VAR 0 7
86728: ARRAY
86729: PPUSH
86730: CALL_OW 255
86734: PUSH
86735: EMPTY
86736: LIST
86737: LIST
86738: PPUSH
86739: CALL_OW 69
86743: ST_TO_ADDR
// if not tmp then
86744: LD_VAR 0 14
86748: NOT
86749: IFFALSE 86753
// continue ;
86751: GO 85252
// if f_ignore_area then
86753: LD_VAR 0 17
86757: IFFALSE 86845
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
86759: LD_ADDR_VAR 0 15
86763: PUSH
86764: LD_VAR 0 14
86768: PPUSH
86769: LD_INT 3
86771: PUSH
86772: LD_INT 92
86774: PUSH
86775: LD_VAR 0 17
86779: PUSH
86780: LD_INT 1
86782: ARRAY
86783: PUSH
86784: LD_VAR 0 17
86788: PUSH
86789: LD_INT 2
86791: ARRAY
86792: PUSH
86793: LD_VAR 0 17
86797: PUSH
86798: LD_INT 3
86800: ARRAY
86801: PUSH
86802: EMPTY
86803: LIST
86804: LIST
86805: LIST
86806: LIST
86807: PUSH
86808: EMPTY
86809: LIST
86810: LIST
86811: PPUSH
86812: CALL_OW 72
86816: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
86817: LD_VAR 0 14
86821: PUSH
86822: LD_VAR 0 15
86826: DIFF
86827: IFFALSE 86845
// tmp := tmp diff tmp2 ;
86829: LD_ADDR_VAR 0 14
86833: PUSH
86834: LD_VAR 0 14
86838: PUSH
86839: LD_VAR 0 15
86843: DIFF
86844: ST_TO_ADDR
// end ; if not f_murder then
86845: LD_VAR 0 20
86849: NOT
86850: IFFALSE 86908
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
86852: LD_ADDR_VAR 0 15
86856: PUSH
86857: LD_VAR 0 14
86861: PPUSH
86862: LD_INT 3
86864: PUSH
86865: LD_INT 50
86867: PUSH
86868: EMPTY
86869: LIST
86870: PUSH
86871: EMPTY
86872: LIST
86873: LIST
86874: PPUSH
86875: CALL_OW 72
86879: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
86880: LD_VAR 0 14
86884: PUSH
86885: LD_VAR 0 15
86889: DIFF
86890: IFFALSE 86908
// tmp := tmp diff tmp2 ;
86892: LD_ADDR_VAR 0 14
86896: PUSH
86897: LD_VAR 0 14
86901: PUSH
86902: LD_VAR 0 15
86906: DIFF
86907: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
86908: LD_ADDR_VAR 0 14
86912: PUSH
86913: LD_VAR 0 4
86917: PUSH
86918: LD_VAR 0 7
86922: ARRAY
86923: PPUSH
86924: LD_VAR 0 14
86928: PPUSH
86929: LD_INT 1
86931: PPUSH
86932: LD_INT 1
86934: PPUSH
86935: CALL 56673 0 4
86939: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
86940: LD_VAR 0 4
86944: PUSH
86945: LD_VAR 0 7
86949: ARRAY
86950: PPUSH
86951: CALL_OW 257
86955: PUSH
86956: LD_INT 1
86958: EQUAL
86959: IFFALSE 87407
// begin if WantPlant ( group [ i ] ) then
86961: LD_VAR 0 4
86965: PUSH
86966: LD_VAR 0 7
86970: ARRAY
86971: PPUSH
86972: CALL 56174 0 1
86976: IFFALSE 86980
// continue ;
86978: GO 85252
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
86980: LD_VAR 0 18
86984: PUSH
86985: LD_VAR 0 4
86989: PUSH
86990: LD_VAR 0 7
86994: ARRAY
86995: PPUSH
86996: CALL_OW 310
87000: NOT
87001: AND
87002: PUSH
87003: LD_VAR 0 14
87007: PUSH
87008: LD_INT 1
87010: ARRAY
87011: PUSH
87012: LD_VAR 0 14
87016: PPUSH
87017: LD_INT 21
87019: PUSH
87020: LD_INT 2
87022: PUSH
87023: EMPTY
87024: LIST
87025: LIST
87026: PUSH
87027: LD_INT 58
87029: PUSH
87030: EMPTY
87031: LIST
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PPUSH
87037: CALL_OW 72
87041: IN
87042: AND
87043: IFFALSE 87079
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
87045: LD_VAR 0 4
87049: PUSH
87050: LD_VAR 0 7
87054: ARRAY
87055: PPUSH
87056: LD_VAR 0 14
87060: PUSH
87061: LD_INT 1
87063: ARRAY
87064: PPUSH
87065: CALL_OW 120
// attacking := true ;
87069: LD_ADDR_VAR 0 29
87073: PUSH
87074: LD_INT 1
87076: ST_TO_ADDR
// continue ;
87077: GO 85252
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
87079: LD_VAR 0 26
87083: PUSH
87084: LD_VAR 0 4
87088: PUSH
87089: LD_VAR 0 7
87093: ARRAY
87094: PPUSH
87095: CALL_OW 257
87099: PUSH
87100: LD_INT 1
87102: EQUAL
87103: AND
87104: PUSH
87105: LD_VAR 0 4
87109: PUSH
87110: LD_VAR 0 7
87114: ARRAY
87115: PPUSH
87116: CALL_OW 256
87120: PUSH
87121: LD_INT 800
87123: LESS
87124: AND
87125: PUSH
87126: LD_VAR 0 4
87130: PUSH
87131: LD_VAR 0 7
87135: ARRAY
87136: PPUSH
87137: CALL_OW 318
87141: NOT
87142: AND
87143: IFFALSE 87160
// ComCrawl ( group [ i ] ) ;
87145: LD_VAR 0 4
87149: PUSH
87150: LD_VAR 0 7
87154: ARRAY
87155: PPUSH
87156: CALL_OW 137
// if f_mines then
87160: LD_VAR 0 21
87164: IFFALSE 87407
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
87166: LD_VAR 0 14
87170: PUSH
87171: LD_INT 1
87173: ARRAY
87174: PPUSH
87175: CALL_OW 247
87179: PUSH
87180: LD_INT 3
87182: EQUAL
87183: PUSH
87184: LD_VAR 0 14
87188: PUSH
87189: LD_INT 1
87191: ARRAY
87192: PUSH
87193: LD_VAR 0 27
87197: IN
87198: NOT
87199: AND
87200: IFFALSE 87407
// begin x := GetX ( tmp [ 1 ] ) ;
87202: LD_ADDR_VAR 0 10
87206: PUSH
87207: LD_VAR 0 14
87211: PUSH
87212: LD_INT 1
87214: ARRAY
87215: PPUSH
87216: CALL_OW 250
87220: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
87221: LD_ADDR_VAR 0 11
87225: PUSH
87226: LD_VAR 0 14
87230: PUSH
87231: LD_INT 1
87233: ARRAY
87234: PPUSH
87235: CALL_OW 251
87239: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
87240: LD_ADDR_VAR 0 12
87244: PUSH
87245: LD_VAR 0 4
87249: PUSH
87250: LD_VAR 0 7
87254: ARRAY
87255: PPUSH
87256: CALL 83115 0 1
87260: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
87261: LD_VAR 0 4
87265: PUSH
87266: LD_VAR 0 7
87270: ARRAY
87271: PPUSH
87272: LD_VAR 0 10
87276: PPUSH
87277: LD_VAR 0 11
87281: PPUSH
87282: LD_VAR 0 14
87286: PUSH
87287: LD_INT 1
87289: ARRAY
87290: PPUSH
87291: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
87295: LD_VAR 0 4
87299: PUSH
87300: LD_VAR 0 7
87304: ARRAY
87305: PPUSH
87306: LD_VAR 0 10
87310: PPUSH
87311: LD_VAR 0 12
87315: PPUSH
87316: LD_INT 7
87318: PPUSH
87319: CALL_OW 272
87323: PPUSH
87324: LD_VAR 0 11
87328: PPUSH
87329: LD_VAR 0 12
87333: PPUSH
87334: LD_INT 7
87336: PPUSH
87337: CALL_OW 273
87341: PPUSH
87342: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
87346: LD_VAR 0 4
87350: PUSH
87351: LD_VAR 0 7
87355: ARRAY
87356: PPUSH
87357: LD_INT 71
87359: PPUSH
87360: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
87364: LD_ADDR_VAR 0 27
87368: PUSH
87369: LD_VAR 0 27
87373: PPUSH
87374: LD_VAR 0 27
87378: PUSH
87379: LD_INT 1
87381: PLUS
87382: PPUSH
87383: LD_VAR 0 14
87387: PUSH
87388: LD_INT 1
87390: ARRAY
87391: PPUSH
87392: CALL_OW 1
87396: ST_TO_ADDR
// attacking := true ;
87397: LD_ADDR_VAR 0 29
87401: PUSH
87402: LD_INT 1
87404: ST_TO_ADDR
// continue ;
87405: GO 85252
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
87407: LD_VAR 0 4
87411: PUSH
87412: LD_VAR 0 7
87416: ARRAY
87417: PPUSH
87418: CALL_OW 257
87422: PUSH
87423: LD_INT 17
87425: EQUAL
87426: PUSH
87427: LD_VAR 0 4
87431: PUSH
87432: LD_VAR 0 7
87436: ARRAY
87437: PPUSH
87438: CALL_OW 110
87442: PUSH
87443: LD_INT 71
87445: EQUAL
87446: NOT
87447: AND
87448: IFFALSE 87594
// begin attacking := false ;
87450: LD_ADDR_VAR 0 29
87454: PUSH
87455: LD_INT 0
87457: ST_TO_ADDR
// k := 5 ;
87458: LD_ADDR_VAR 0 9
87462: PUSH
87463: LD_INT 5
87465: ST_TO_ADDR
// if tmp < k then
87466: LD_VAR 0 14
87470: PUSH
87471: LD_VAR 0 9
87475: LESS
87476: IFFALSE 87488
// k := tmp ;
87478: LD_ADDR_VAR 0 9
87482: PUSH
87483: LD_VAR 0 14
87487: ST_TO_ADDR
// for j = 1 to k do
87488: LD_ADDR_VAR 0 8
87492: PUSH
87493: DOUBLE
87494: LD_INT 1
87496: DEC
87497: ST_TO_ADDR
87498: LD_VAR 0 9
87502: PUSH
87503: FOR_TO
87504: IFFALSE 87592
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
87506: LD_VAR 0 14
87510: PUSH
87511: LD_VAR 0 8
87515: ARRAY
87516: PUSH
87517: LD_VAR 0 14
87521: PPUSH
87522: LD_INT 58
87524: PUSH
87525: EMPTY
87526: LIST
87527: PPUSH
87528: CALL_OW 72
87532: IN
87533: NOT
87534: IFFALSE 87590
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87536: LD_VAR 0 4
87540: PUSH
87541: LD_VAR 0 7
87545: ARRAY
87546: PPUSH
87547: LD_VAR 0 14
87551: PUSH
87552: LD_VAR 0 8
87556: ARRAY
87557: PPUSH
87558: CALL_OW 115
// attacking := true ;
87562: LD_ADDR_VAR 0 29
87566: PUSH
87567: LD_INT 1
87569: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
87570: LD_VAR 0 4
87574: PUSH
87575: LD_VAR 0 7
87579: ARRAY
87580: PPUSH
87581: LD_INT 71
87583: PPUSH
87584: CALL_OW 109
// continue ;
87588: GO 87503
// end ; end ;
87590: GO 87503
87592: POP
87593: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
87594: LD_VAR 0 4
87598: PUSH
87599: LD_VAR 0 7
87603: ARRAY
87604: PPUSH
87605: CALL_OW 257
87609: PUSH
87610: LD_INT 8
87612: EQUAL
87613: PUSH
87614: LD_VAR 0 4
87618: PUSH
87619: LD_VAR 0 7
87623: ARRAY
87624: PPUSH
87625: CALL_OW 264
87629: PUSH
87630: LD_INT 28
87632: PUSH
87633: LD_INT 45
87635: PUSH
87636: LD_INT 7
87638: PUSH
87639: LD_INT 47
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: LIST
87646: LIST
87647: IN
87648: OR
87649: IFFALSE 87879
// begin attacking := false ;
87651: LD_ADDR_VAR 0 29
87655: PUSH
87656: LD_INT 0
87658: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
87659: LD_VAR 0 14
87663: PUSH
87664: LD_INT 1
87666: ARRAY
87667: PPUSH
87668: CALL_OW 266
87672: PUSH
87673: LD_INT 32
87675: PUSH
87676: LD_INT 31
87678: PUSH
87679: LD_INT 33
87681: PUSH
87682: LD_INT 4
87684: PUSH
87685: LD_INT 5
87687: PUSH
87688: EMPTY
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: IN
87695: IFFALSE 87879
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
87697: LD_ADDR_VAR 0 9
87701: PUSH
87702: LD_VAR 0 14
87706: PUSH
87707: LD_INT 1
87709: ARRAY
87710: PPUSH
87711: CALL_OW 266
87715: PPUSH
87716: LD_VAR 0 14
87720: PUSH
87721: LD_INT 1
87723: ARRAY
87724: PPUSH
87725: CALL_OW 250
87729: PPUSH
87730: LD_VAR 0 14
87734: PUSH
87735: LD_INT 1
87737: ARRAY
87738: PPUSH
87739: CALL_OW 251
87743: PPUSH
87744: LD_VAR 0 14
87748: PUSH
87749: LD_INT 1
87751: ARRAY
87752: PPUSH
87753: CALL_OW 254
87757: PPUSH
87758: LD_VAR 0 14
87762: PUSH
87763: LD_INT 1
87765: ARRAY
87766: PPUSH
87767: CALL_OW 248
87771: PPUSH
87772: LD_INT 0
87774: PPUSH
87775: CALL 64485 0 6
87779: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
87780: LD_ADDR_VAR 0 8
87784: PUSH
87785: LD_VAR 0 4
87789: PUSH
87790: LD_VAR 0 7
87794: ARRAY
87795: PPUSH
87796: LD_VAR 0 9
87800: PPUSH
87801: CALL 83178 0 2
87805: ST_TO_ADDR
// if j then
87806: LD_VAR 0 8
87810: IFFALSE 87879
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
87812: LD_VAR 0 8
87816: PUSH
87817: LD_INT 1
87819: ARRAY
87820: PPUSH
87821: LD_VAR 0 8
87825: PUSH
87826: LD_INT 2
87828: ARRAY
87829: PPUSH
87830: CALL_OW 488
87834: IFFALSE 87879
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
87836: LD_VAR 0 4
87840: PUSH
87841: LD_VAR 0 7
87845: ARRAY
87846: PPUSH
87847: LD_VAR 0 8
87851: PUSH
87852: LD_INT 1
87854: ARRAY
87855: PPUSH
87856: LD_VAR 0 8
87860: PUSH
87861: LD_INT 2
87863: ARRAY
87864: PPUSH
87865: CALL_OW 116
// attacking := true ;
87869: LD_ADDR_VAR 0 29
87873: PUSH
87874: LD_INT 1
87876: ST_TO_ADDR
// continue ;
87877: GO 85252
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
87879: LD_VAR 0 4
87883: PUSH
87884: LD_VAR 0 7
87888: ARRAY
87889: PPUSH
87890: CALL_OW 265
87894: PUSH
87895: LD_INT 11
87897: EQUAL
87898: IFFALSE 88176
// begin k := 10 ;
87900: LD_ADDR_VAR 0 9
87904: PUSH
87905: LD_INT 10
87907: ST_TO_ADDR
// x := 0 ;
87908: LD_ADDR_VAR 0 10
87912: PUSH
87913: LD_INT 0
87915: ST_TO_ADDR
// if tmp < k then
87916: LD_VAR 0 14
87920: PUSH
87921: LD_VAR 0 9
87925: LESS
87926: IFFALSE 87938
// k := tmp ;
87928: LD_ADDR_VAR 0 9
87932: PUSH
87933: LD_VAR 0 14
87937: ST_TO_ADDR
// for j = k downto 1 do
87938: LD_ADDR_VAR 0 8
87942: PUSH
87943: DOUBLE
87944: LD_VAR 0 9
87948: INC
87949: ST_TO_ADDR
87950: LD_INT 1
87952: PUSH
87953: FOR_DOWNTO
87954: IFFALSE 88029
// begin if GetType ( tmp [ j ] ) = unit_human then
87956: LD_VAR 0 14
87960: PUSH
87961: LD_VAR 0 8
87965: ARRAY
87966: PPUSH
87967: CALL_OW 247
87971: PUSH
87972: LD_INT 1
87974: EQUAL
87975: IFFALSE 88027
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
87977: LD_VAR 0 4
87981: PUSH
87982: LD_VAR 0 7
87986: ARRAY
87987: PPUSH
87988: LD_VAR 0 14
87992: PUSH
87993: LD_VAR 0 8
87997: ARRAY
87998: PPUSH
87999: CALL 83449 0 2
// x := tmp [ j ] ;
88003: LD_ADDR_VAR 0 10
88007: PUSH
88008: LD_VAR 0 14
88012: PUSH
88013: LD_VAR 0 8
88017: ARRAY
88018: ST_TO_ADDR
// attacking := true ;
88019: LD_ADDR_VAR 0 29
88023: PUSH
88024: LD_INT 1
88026: ST_TO_ADDR
// end ; end ;
88027: GO 87953
88029: POP
88030: POP
// if not x then
88031: LD_VAR 0 10
88035: NOT
88036: IFFALSE 88176
// begin attacking := true ;
88038: LD_ADDR_VAR 0 29
88042: PUSH
88043: LD_INT 1
88045: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
88046: LD_VAR 0 4
88050: PUSH
88051: LD_VAR 0 7
88055: ARRAY
88056: PPUSH
88057: CALL_OW 250
88061: PPUSH
88062: LD_VAR 0 4
88066: PUSH
88067: LD_VAR 0 7
88071: ARRAY
88072: PPUSH
88073: CALL_OW 251
88077: PPUSH
88078: CALL_OW 546
88082: PUSH
88083: LD_INT 2
88085: ARRAY
88086: PUSH
88087: LD_VAR 0 14
88091: PUSH
88092: LD_INT 1
88094: ARRAY
88095: PPUSH
88096: CALL_OW 250
88100: PPUSH
88101: LD_VAR 0 14
88105: PUSH
88106: LD_INT 1
88108: ARRAY
88109: PPUSH
88110: CALL_OW 251
88114: PPUSH
88115: CALL_OW 546
88119: PUSH
88120: LD_INT 2
88122: ARRAY
88123: EQUAL
88124: IFFALSE 88152
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
88126: LD_VAR 0 4
88130: PUSH
88131: LD_VAR 0 7
88135: ARRAY
88136: PPUSH
88137: LD_VAR 0 14
88141: PUSH
88142: LD_INT 1
88144: ARRAY
88145: PPUSH
88146: CALL 83449 0 2
88150: GO 88176
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88152: LD_VAR 0 4
88156: PUSH
88157: LD_VAR 0 7
88161: ARRAY
88162: PPUSH
88163: LD_VAR 0 14
88167: PUSH
88168: LD_INT 1
88170: ARRAY
88171: PPUSH
88172: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
88176: LD_VAR 0 4
88180: PUSH
88181: LD_VAR 0 7
88185: ARRAY
88186: PPUSH
88187: CALL_OW 264
88191: PUSH
88192: LD_INT 29
88194: EQUAL
88195: IFFALSE 88561
// begin if WantsToAttack ( group [ i ] ) in bombed then
88197: LD_VAR 0 4
88201: PUSH
88202: LD_VAR 0 7
88206: ARRAY
88207: PPUSH
88208: CALL_OW 319
88212: PUSH
88213: LD_VAR 0 28
88217: IN
88218: IFFALSE 88222
// continue ;
88220: GO 85252
// k := 8 ;
88222: LD_ADDR_VAR 0 9
88226: PUSH
88227: LD_INT 8
88229: ST_TO_ADDR
// x := 0 ;
88230: LD_ADDR_VAR 0 10
88234: PUSH
88235: LD_INT 0
88237: ST_TO_ADDR
// if tmp < k then
88238: LD_VAR 0 14
88242: PUSH
88243: LD_VAR 0 9
88247: LESS
88248: IFFALSE 88260
// k := tmp ;
88250: LD_ADDR_VAR 0 9
88254: PUSH
88255: LD_VAR 0 14
88259: ST_TO_ADDR
// for j = 1 to k do
88260: LD_ADDR_VAR 0 8
88264: PUSH
88265: DOUBLE
88266: LD_INT 1
88268: DEC
88269: ST_TO_ADDR
88270: LD_VAR 0 9
88274: PUSH
88275: FOR_TO
88276: IFFALSE 88408
// begin if GetType ( tmp [ j ] ) = unit_building then
88278: LD_VAR 0 14
88282: PUSH
88283: LD_VAR 0 8
88287: ARRAY
88288: PPUSH
88289: CALL_OW 247
88293: PUSH
88294: LD_INT 3
88296: EQUAL
88297: IFFALSE 88406
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
88299: LD_VAR 0 14
88303: PUSH
88304: LD_VAR 0 8
88308: ARRAY
88309: PUSH
88310: LD_VAR 0 28
88314: IN
88315: NOT
88316: PUSH
88317: LD_VAR 0 14
88321: PUSH
88322: LD_VAR 0 8
88326: ARRAY
88327: PPUSH
88328: CALL_OW 313
88332: AND
88333: IFFALSE 88406
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88335: LD_VAR 0 4
88339: PUSH
88340: LD_VAR 0 7
88344: ARRAY
88345: PPUSH
88346: LD_VAR 0 14
88350: PUSH
88351: LD_VAR 0 8
88355: ARRAY
88356: PPUSH
88357: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
88361: LD_ADDR_VAR 0 28
88365: PUSH
88366: LD_VAR 0 28
88370: PPUSH
88371: LD_VAR 0 28
88375: PUSH
88376: LD_INT 1
88378: PLUS
88379: PPUSH
88380: LD_VAR 0 14
88384: PUSH
88385: LD_VAR 0 8
88389: ARRAY
88390: PPUSH
88391: CALL_OW 1
88395: ST_TO_ADDR
// attacking := true ;
88396: LD_ADDR_VAR 0 29
88400: PUSH
88401: LD_INT 1
88403: ST_TO_ADDR
// break ;
88404: GO 88408
// end ; end ;
88406: GO 88275
88408: POP
88409: POP
// if not attacking and f_attack_depot then
88410: LD_VAR 0 29
88414: NOT
88415: PUSH
88416: LD_VAR 0 25
88420: AND
88421: IFFALSE 88516
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88423: LD_ADDR_VAR 0 13
88427: PUSH
88428: LD_VAR 0 14
88432: PPUSH
88433: LD_INT 2
88435: PUSH
88436: LD_INT 30
88438: PUSH
88439: LD_INT 0
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 30
88448: PUSH
88449: LD_INT 1
88451: PUSH
88452: EMPTY
88453: LIST
88454: LIST
88455: PUSH
88456: EMPTY
88457: LIST
88458: LIST
88459: LIST
88460: PPUSH
88461: CALL_OW 72
88465: ST_TO_ADDR
// if z then
88466: LD_VAR 0 13
88470: IFFALSE 88516
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
88472: LD_VAR 0 4
88476: PUSH
88477: LD_VAR 0 7
88481: ARRAY
88482: PPUSH
88483: LD_VAR 0 13
88487: PPUSH
88488: LD_VAR 0 4
88492: PUSH
88493: LD_VAR 0 7
88497: ARRAY
88498: PPUSH
88499: CALL_OW 74
88503: PPUSH
88504: CALL_OW 115
// attacking := true ;
88508: LD_ADDR_VAR 0 29
88512: PUSH
88513: LD_INT 1
88515: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
88516: LD_VAR 0 4
88520: PUSH
88521: LD_VAR 0 7
88525: ARRAY
88526: PPUSH
88527: CALL_OW 256
88531: PUSH
88532: LD_INT 500
88534: LESS
88535: IFFALSE 88561
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88537: LD_VAR 0 4
88541: PUSH
88542: LD_VAR 0 7
88546: ARRAY
88547: PPUSH
88548: LD_VAR 0 14
88552: PUSH
88553: LD_INT 1
88555: ARRAY
88556: PPUSH
88557: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
88561: LD_VAR 0 4
88565: PUSH
88566: LD_VAR 0 7
88570: ARRAY
88571: PPUSH
88572: CALL_OW 264
88576: PUSH
88577: LD_INT 49
88579: EQUAL
88580: IFFALSE 88701
// begin if not HasTask ( group [ i ] ) then
88582: LD_VAR 0 4
88586: PUSH
88587: LD_VAR 0 7
88591: ARRAY
88592: PPUSH
88593: CALL_OW 314
88597: NOT
88598: IFFALSE 88701
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
88600: LD_ADDR_VAR 0 9
88604: PUSH
88605: LD_INT 81
88607: PUSH
88608: LD_VAR 0 4
88612: PUSH
88613: LD_VAR 0 7
88617: ARRAY
88618: PPUSH
88619: CALL_OW 255
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PPUSH
88628: CALL_OW 69
88632: PPUSH
88633: LD_VAR 0 4
88637: PUSH
88638: LD_VAR 0 7
88642: ARRAY
88643: PPUSH
88644: CALL_OW 74
88648: ST_TO_ADDR
// if k then
88649: LD_VAR 0 9
88653: IFFALSE 88701
// if GetDistUnits ( group [ i ] , k ) > 10 then
88655: LD_VAR 0 4
88659: PUSH
88660: LD_VAR 0 7
88664: ARRAY
88665: PPUSH
88666: LD_VAR 0 9
88670: PPUSH
88671: CALL_OW 296
88675: PUSH
88676: LD_INT 10
88678: GREATER
88679: IFFALSE 88701
// ComMoveUnit ( group [ i ] , k ) ;
88681: LD_VAR 0 4
88685: PUSH
88686: LD_VAR 0 7
88690: ARRAY
88691: PPUSH
88692: LD_VAR 0 9
88696: PPUSH
88697: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
88701: LD_VAR 0 4
88705: PUSH
88706: LD_VAR 0 7
88710: ARRAY
88711: PPUSH
88712: CALL_OW 256
88716: PUSH
88717: LD_INT 250
88719: LESS
88720: PUSH
88721: LD_VAR 0 4
88725: PUSH
88726: LD_VAR 0 7
88730: ARRAY
88731: PUSH
88732: LD_INT 21
88734: PUSH
88735: LD_INT 2
88737: PUSH
88738: EMPTY
88739: LIST
88740: LIST
88741: PUSH
88742: LD_INT 23
88744: PUSH
88745: LD_INT 2
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: PUSH
88752: EMPTY
88753: LIST
88754: LIST
88755: PPUSH
88756: CALL_OW 69
88760: IN
88761: AND
88762: IFFALSE 88887
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
88764: LD_ADDR_VAR 0 9
88768: PUSH
88769: LD_OWVAR 3
88773: PUSH
88774: LD_VAR 0 4
88778: PUSH
88779: LD_VAR 0 7
88783: ARRAY
88784: DIFF
88785: PPUSH
88786: LD_VAR 0 4
88790: PUSH
88791: LD_VAR 0 7
88795: ARRAY
88796: PPUSH
88797: CALL_OW 74
88801: ST_TO_ADDR
// if not k then
88802: LD_VAR 0 9
88806: NOT
88807: IFFALSE 88811
// continue ;
88809: GO 85252
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
88811: LD_VAR 0 9
88815: PUSH
88816: LD_INT 81
88818: PUSH
88819: LD_VAR 0 4
88823: PUSH
88824: LD_VAR 0 7
88828: ARRAY
88829: PPUSH
88830: CALL_OW 255
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: PPUSH
88839: CALL_OW 69
88843: IN
88844: PUSH
88845: LD_VAR 0 9
88849: PPUSH
88850: LD_VAR 0 4
88854: PUSH
88855: LD_VAR 0 7
88859: ARRAY
88860: PPUSH
88861: CALL_OW 296
88865: PUSH
88866: LD_INT 5
88868: LESS
88869: AND
88870: IFFALSE 88887
// ComAutodestruct ( group [ i ] ) ;
88872: LD_VAR 0 4
88876: PUSH
88877: LD_VAR 0 7
88881: ARRAY
88882: PPUSH
88883: CALL 83347 0 1
// end ; if f_attack_depot then
88887: LD_VAR 0 25
88891: IFFALSE 89003
// begin k := 6 ;
88893: LD_ADDR_VAR 0 9
88897: PUSH
88898: LD_INT 6
88900: ST_TO_ADDR
// if tmp < k then
88901: LD_VAR 0 14
88905: PUSH
88906: LD_VAR 0 9
88910: LESS
88911: IFFALSE 88923
// k := tmp ;
88913: LD_ADDR_VAR 0 9
88917: PUSH
88918: LD_VAR 0 14
88922: ST_TO_ADDR
// for j = 1 to k do
88923: LD_ADDR_VAR 0 8
88927: PUSH
88928: DOUBLE
88929: LD_INT 1
88931: DEC
88932: ST_TO_ADDR
88933: LD_VAR 0 9
88937: PUSH
88938: FOR_TO
88939: IFFALSE 89001
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
88941: LD_VAR 0 8
88945: PPUSH
88946: CALL_OW 266
88950: PUSH
88951: LD_INT 0
88953: PUSH
88954: LD_INT 1
88956: PUSH
88957: EMPTY
88958: LIST
88959: LIST
88960: IN
88961: IFFALSE 88999
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88963: LD_VAR 0 4
88967: PUSH
88968: LD_VAR 0 7
88972: ARRAY
88973: PPUSH
88974: LD_VAR 0 14
88978: PUSH
88979: LD_VAR 0 8
88983: ARRAY
88984: PPUSH
88985: CALL_OW 115
// attacking := true ;
88989: LD_ADDR_VAR 0 29
88993: PUSH
88994: LD_INT 1
88996: ST_TO_ADDR
// break ;
88997: GO 89001
// end ;
88999: GO 88938
89001: POP
89002: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
89003: LD_VAR 0 4
89007: PUSH
89008: LD_VAR 0 7
89012: ARRAY
89013: PPUSH
89014: CALL_OW 302
89018: PUSH
89019: LD_VAR 0 29
89023: NOT
89024: AND
89025: IFFALSE 89347
// begin if GetTag ( group [ i ] ) = 71 then
89027: LD_VAR 0 4
89031: PUSH
89032: LD_VAR 0 7
89036: ARRAY
89037: PPUSH
89038: CALL_OW 110
89042: PUSH
89043: LD_INT 71
89045: EQUAL
89046: IFFALSE 89087
// begin if HasTask ( group [ i ] ) then
89048: LD_VAR 0 4
89052: PUSH
89053: LD_VAR 0 7
89057: ARRAY
89058: PPUSH
89059: CALL_OW 314
89063: IFFALSE 89069
// continue else
89065: GO 85252
89067: GO 89087
// SetTag ( group [ i ] , 0 ) ;
89069: LD_VAR 0 4
89073: PUSH
89074: LD_VAR 0 7
89078: ARRAY
89079: PPUSH
89080: LD_INT 0
89082: PPUSH
89083: CALL_OW 109
// end ; k := 8 ;
89087: LD_ADDR_VAR 0 9
89091: PUSH
89092: LD_INT 8
89094: ST_TO_ADDR
// x := 0 ;
89095: LD_ADDR_VAR 0 10
89099: PUSH
89100: LD_INT 0
89102: ST_TO_ADDR
// if tmp < k then
89103: LD_VAR 0 14
89107: PUSH
89108: LD_VAR 0 9
89112: LESS
89113: IFFALSE 89125
// k := tmp ;
89115: LD_ADDR_VAR 0 9
89119: PUSH
89120: LD_VAR 0 14
89124: ST_TO_ADDR
// for j = 1 to k do
89125: LD_ADDR_VAR 0 8
89129: PUSH
89130: DOUBLE
89131: LD_INT 1
89133: DEC
89134: ST_TO_ADDR
89135: LD_VAR 0 9
89139: PUSH
89140: FOR_TO
89141: IFFALSE 89239
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
89143: LD_VAR 0 14
89147: PUSH
89148: LD_VAR 0 8
89152: ARRAY
89153: PPUSH
89154: CALL_OW 247
89158: PUSH
89159: LD_INT 1
89161: EQUAL
89162: PUSH
89163: LD_VAR 0 14
89167: PUSH
89168: LD_VAR 0 8
89172: ARRAY
89173: PPUSH
89174: CALL_OW 256
89178: PUSH
89179: LD_INT 250
89181: LESS
89182: PUSH
89183: LD_VAR 0 20
89187: AND
89188: PUSH
89189: LD_VAR 0 20
89193: NOT
89194: PUSH
89195: LD_VAR 0 14
89199: PUSH
89200: LD_VAR 0 8
89204: ARRAY
89205: PPUSH
89206: CALL_OW 256
89210: PUSH
89211: LD_INT 250
89213: GREATEREQUAL
89214: AND
89215: OR
89216: AND
89217: IFFALSE 89237
// begin x := tmp [ j ] ;
89219: LD_ADDR_VAR 0 10
89223: PUSH
89224: LD_VAR 0 14
89228: PUSH
89229: LD_VAR 0 8
89233: ARRAY
89234: ST_TO_ADDR
// break ;
89235: GO 89239
// end ;
89237: GO 89140
89239: POP
89240: POP
// if x then
89241: LD_VAR 0 10
89245: IFFALSE 89269
// ComAttackUnit ( group [ i ] , x ) else
89247: LD_VAR 0 4
89251: PUSH
89252: LD_VAR 0 7
89256: ARRAY
89257: PPUSH
89258: LD_VAR 0 10
89262: PPUSH
89263: CALL_OW 115
89267: GO 89293
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89269: LD_VAR 0 4
89273: PUSH
89274: LD_VAR 0 7
89278: ARRAY
89279: PPUSH
89280: LD_VAR 0 14
89284: PUSH
89285: LD_INT 1
89287: ARRAY
89288: PPUSH
89289: CALL_OW 115
// if not HasTask ( group [ i ] ) then
89293: LD_VAR 0 4
89297: PUSH
89298: LD_VAR 0 7
89302: ARRAY
89303: PPUSH
89304: CALL_OW 314
89308: NOT
89309: IFFALSE 89347
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
89311: LD_VAR 0 4
89315: PUSH
89316: LD_VAR 0 7
89320: ARRAY
89321: PPUSH
89322: LD_VAR 0 14
89326: PPUSH
89327: LD_VAR 0 4
89331: PUSH
89332: LD_VAR 0 7
89336: ARRAY
89337: PPUSH
89338: CALL_OW 74
89342: PPUSH
89343: CALL_OW 115
// end ; end ; end ;
89347: GO 85252
89349: POP
89350: POP
// wait ( 0 0$1 ) ;
89351: LD_INT 35
89353: PPUSH
89354: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
89358: LD_VAR 0 4
89362: PUSH
89363: EMPTY
89364: EQUAL
89365: PUSH
89366: LD_INT 81
89368: PUSH
89369: LD_VAR 0 35
89373: PUSH
89374: EMPTY
89375: LIST
89376: LIST
89377: PPUSH
89378: CALL_OW 69
89382: NOT
89383: OR
89384: IFFALSE 85237
// end ;
89386: LD_VAR 0 2
89390: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
89391: LD_INT 0
89393: PPUSH
89394: PPUSH
89395: PPUSH
89396: PPUSH
// if not base_units then
89397: LD_VAR 0 1
89401: NOT
89402: IFFALSE 89406
// exit ;
89404: GO 89493
// result := false ;
89406: LD_ADDR_VAR 0 2
89410: PUSH
89411: LD_INT 0
89413: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
89414: LD_ADDR_VAR 0 5
89418: PUSH
89419: LD_VAR 0 1
89423: PPUSH
89424: LD_INT 21
89426: PUSH
89427: LD_INT 3
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: PPUSH
89434: CALL_OW 72
89438: ST_TO_ADDR
// if not tmp then
89439: LD_VAR 0 5
89443: NOT
89444: IFFALSE 89448
// exit ;
89446: GO 89493
// for i in tmp do
89448: LD_ADDR_VAR 0 3
89452: PUSH
89453: LD_VAR 0 5
89457: PUSH
89458: FOR_IN
89459: IFFALSE 89491
// begin result := EnemyInRange ( i , 22 ) ;
89461: LD_ADDR_VAR 0 2
89465: PUSH
89466: LD_VAR 0 3
89470: PPUSH
89471: LD_INT 22
89473: PPUSH
89474: CALL 83030 0 2
89478: ST_TO_ADDR
// if result then
89479: LD_VAR 0 2
89483: IFFALSE 89489
// exit ;
89485: POP
89486: POP
89487: GO 89493
// end ;
89489: GO 89458
89491: POP
89492: POP
// end ;
89493: LD_VAR 0 2
89497: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
89498: LD_INT 0
89500: PPUSH
89501: PPUSH
// if not units then
89502: LD_VAR 0 1
89506: NOT
89507: IFFALSE 89511
// exit ;
89509: GO 89581
// result := [ ] ;
89511: LD_ADDR_VAR 0 3
89515: PUSH
89516: EMPTY
89517: ST_TO_ADDR
// for i in units do
89518: LD_ADDR_VAR 0 4
89522: PUSH
89523: LD_VAR 0 1
89527: PUSH
89528: FOR_IN
89529: IFFALSE 89579
// if GetTag ( i ) = tag then
89531: LD_VAR 0 4
89535: PPUSH
89536: CALL_OW 110
89540: PUSH
89541: LD_VAR 0 2
89545: EQUAL
89546: IFFALSE 89577
// result := Insert ( result , result + 1 , i ) ;
89548: LD_ADDR_VAR 0 3
89552: PUSH
89553: LD_VAR 0 3
89557: PPUSH
89558: LD_VAR 0 3
89562: PUSH
89563: LD_INT 1
89565: PLUS
89566: PPUSH
89567: LD_VAR 0 4
89571: PPUSH
89572: CALL_OW 2
89576: ST_TO_ADDR
89577: GO 89528
89579: POP
89580: POP
// end ;
89581: LD_VAR 0 3
89585: RET
// export function IsDriver ( un ) ; begin
89586: LD_INT 0
89588: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
89589: LD_ADDR_VAR 0 2
89593: PUSH
89594: LD_VAR 0 1
89598: PUSH
89599: LD_INT 55
89601: PUSH
89602: EMPTY
89603: LIST
89604: PPUSH
89605: CALL_OW 69
89609: IN
89610: ST_TO_ADDR
// end ;
89611: LD_VAR 0 2
89615: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
89616: LD_INT 0
89618: PPUSH
89619: PPUSH
// list := [ ] ;
89620: LD_ADDR_VAR 0 5
89624: PUSH
89625: EMPTY
89626: ST_TO_ADDR
// case d of 0 :
89627: LD_VAR 0 3
89631: PUSH
89632: LD_INT 0
89634: DOUBLE
89635: EQUAL
89636: IFTRUE 89640
89638: GO 89773
89640: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
89641: LD_ADDR_VAR 0 5
89645: PUSH
89646: LD_VAR 0 1
89650: PUSH
89651: LD_INT 4
89653: MINUS
89654: PUSH
89655: LD_VAR 0 2
89659: PUSH
89660: LD_INT 4
89662: MINUS
89663: PUSH
89664: LD_INT 2
89666: PUSH
89667: EMPTY
89668: LIST
89669: LIST
89670: LIST
89671: PUSH
89672: LD_VAR 0 1
89676: PUSH
89677: LD_INT 3
89679: MINUS
89680: PUSH
89681: LD_VAR 0 2
89685: PUSH
89686: LD_INT 1
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: LIST
89693: PUSH
89694: LD_VAR 0 1
89698: PUSH
89699: LD_INT 4
89701: PLUS
89702: PUSH
89703: LD_VAR 0 2
89707: PUSH
89708: LD_INT 4
89710: PUSH
89711: EMPTY
89712: LIST
89713: LIST
89714: LIST
89715: PUSH
89716: LD_VAR 0 1
89720: PUSH
89721: LD_INT 3
89723: PLUS
89724: PUSH
89725: LD_VAR 0 2
89729: PUSH
89730: LD_INT 3
89732: PLUS
89733: PUSH
89734: LD_INT 5
89736: PUSH
89737: EMPTY
89738: LIST
89739: LIST
89740: LIST
89741: PUSH
89742: LD_VAR 0 1
89746: PUSH
89747: LD_VAR 0 2
89751: PUSH
89752: LD_INT 4
89754: PLUS
89755: PUSH
89756: LD_INT 0
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: LIST
89763: PUSH
89764: EMPTY
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: ST_TO_ADDR
// end ; 1 :
89771: GO 90471
89773: LD_INT 1
89775: DOUBLE
89776: EQUAL
89777: IFTRUE 89781
89779: GO 89914
89781: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
89782: LD_ADDR_VAR 0 5
89786: PUSH
89787: LD_VAR 0 1
89791: PUSH
89792: LD_VAR 0 2
89796: PUSH
89797: LD_INT 4
89799: MINUS
89800: PUSH
89801: LD_INT 3
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: LIST
89808: PUSH
89809: LD_VAR 0 1
89813: PUSH
89814: LD_INT 3
89816: MINUS
89817: PUSH
89818: LD_VAR 0 2
89822: PUSH
89823: LD_INT 3
89825: MINUS
89826: PUSH
89827: LD_INT 2
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: LIST
89834: PUSH
89835: LD_VAR 0 1
89839: PUSH
89840: LD_INT 4
89842: MINUS
89843: PUSH
89844: LD_VAR 0 2
89848: PUSH
89849: LD_INT 1
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: LIST
89856: PUSH
89857: LD_VAR 0 1
89861: PUSH
89862: LD_VAR 0 2
89866: PUSH
89867: LD_INT 3
89869: PLUS
89870: PUSH
89871: LD_INT 0
89873: PUSH
89874: EMPTY
89875: LIST
89876: LIST
89877: LIST
89878: PUSH
89879: LD_VAR 0 1
89883: PUSH
89884: LD_INT 4
89886: PLUS
89887: PUSH
89888: LD_VAR 0 2
89892: PUSH
89893: LD_INT 4
89895: PLUS
89896: PUSH
89897: LD_INT 5
89899: PUSH
89900: EMPTY
89901: LIST
89902: LIST
89903: LIST
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: LIST
89911: ST_TO_ADDR
// end ; 2 :
89912: GO 90471
89914: LD_INT 2
89916: DOUBLE
89917: EQUAL
89918: IFTRUE 89922
89920: GO 90051
89922: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
89923: LD_ADDR_VAR 0 5
89927: PUSH
89928: LD_VAR 0 1
89932: PUSH
89933: LD_VAR 0 2
89937: PUSH
89938: LD_INT 3
89940: MINUS
89941: PUSH
89942: LD_INT 3
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: LIST
89949: PUSH
89950: LD_VAR 0 1
89954: PUSH
89955: LD_INT 4
89957: PLUS
89958: PUSH
89959: LD_VAR 0 2
89963: PUSH
89964: LD_INT 4
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: LIST
89971: PUSH
89972: LD_VAR 0 1
89976: PUSH
89977: LD_VAR 0 2
89981: PUSH
89982: LD_INT 4
89984: PLUS
89985: PUSH
89986: LD_INT 0
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: LIST
89993: PUSH
89994: LD_VAR 0 1
89998: PUSH
89999: LD_INT 3
90001: MINUS
90002: PUSH
90003: LD_VAR 0 2
90007: PUSH
90008: LD_INT 1
90010: PUSH
90011: EMPTY
90012: LIST
90013: LIST
90014: LIST
90015: PUSH
90016: LD_VAR 0 1
90020: PUSH
90021: LD_INT 4
90023: MINUS
90024: PUSH
90025: LD_VAR 0 2
90029: PUSH
90030: LD_INT 4
90032: MINUS
90033: PUSH
90034: LD_INT 2
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: LIST
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: ST_TO_ADDR
// end ; 3 :
90049: GO 90471
90051: LD_INT 3
90053: DOUBLE
90054: EQUAL
90055: IFTRUE 90059
90057: GO 90192
90059: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
90060: LD_ADDR_VAR 0 5
90064: PUSH
90065: LD_VAR 0 1
90069: PUSH
90070: LD_INT 3
90072: PLUS
90073: PUSH
90074: LD_VAR 0 2
90078: PUSH
90079: LD_INT 4
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: LIST
90086: PUSH
90087: LD_VAR 0 1
90091: PUSH
90092: LD_INT 4
90094: PLUS
90095: PUSH
90096: LD_VAR 0 2
90100: PUSH
90101: LD_INT 4
90103: PLUS
90104: PUSH
90105: LD_INT 5
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: LIST
90112: PUSH
90113: LD_VAR 0 1
90117: PUSH
90118: LD_INT 4
90120: MINUS
90121: PUSH
90122: LD_VAR 0 2
90126: PUSH
90127: LD_INT 1
90129: PUSH
90130: EMPTY
90131: LIST
90132: LIST
90133: LIST
90134: PUSH
90135: LD_VAR 0 1
90139: PUSH
90140: LD_VAR 0 2
90144: PUSH
90145: LD_INT 4
90147: MINUS
90148: PUSH
90149: LD_INT 3
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: LIST
90156: PUSH
90157: LD_VAR 0 1
90161: PUSH
90162: LD_INT 3
90164: MINUS
90165: PUSH
90166: LD_VAR 0 2
90170: PUSH
90171: LD_INT 3
90173: MINUS
90174: PUSH
90175: LD_INT 2
90177: PUSH
90178: EMPTY
90179: LIST
90180: LIST
90181: LIST
90182: PUSH
90183: EMPTY
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: ST_TO_ADDR
// end ; 4 :
90190: GO 90471
90192: LD_INT 4
90194: DOUBLE
90195: EQUAL
90196: IFTRUE 90200
90198: GO 90333
90200: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
90201: LD_ADDR_VAR 0 5
90205: PUSH
90206: LD_VAR 0 1
90210: PUSH
90211: LD_VAR 0 2
90215: PUSH
90216: LD_INT 4
90218: PLUS
90219: PUSH
90220: LD_INT 0
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: LIST
90227: PUSH
90228: LD_VAR 0 1
90232: PUSH
90233: LD_INT 3
90235: PLUS
90236: PUSH
90237: LD_VAR 0 2
90241: PUSH
90242: LD_INT 3
90244: PLUS
90245: PUSH
90246: LD_INT 5
90248: PUSH
90249: EMPTY
90250: LIST
90251: LIST
90252: LIST
90253: PUSH
90254: LD_VAR 0 1
90258: PUSH
90259: LD_INT 4
90261: PLUS
90262: PUSH
90263: LD_VAR 0 2
90267: PUSH
90268: LD_INT 4
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: LIST
90275: PUSH
90276: LD_VAR 0 1
90280: PUSH
90281: LD_VAR 0 2
90285: PUSH
90286: LD_INT 3
90288: MINUS
90289: PUSH
90290: LD_INT 3
90292: PUSH
90293: EMPTY
90294: LIST
90295: LIST
90296: LIST
90297: PUSH
90298: LD_VAR 0 1
90302: PUSH
90303: LD_INT 4
90305: MINUS
90306: PUSH
90307: LD_VAR 0 2
90311: PUSH
90312: LD_INT 4
90314: MINUS
90315: PUSH
90316: LD_INT 2
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: LIST
90323: PUSH
90324: EMPTY
90325: LIST
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: ST_TO_ADDR
// end ; 5 :
90331: GO 90471
90333: LD_INT 5
90335: DOUBLE
90336: EQUAL
90337: IFTRUE 90341
90339: GO 90470
90341: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
90342: LD_ADDR_VAR 0 5
90346: PUSH
90347: LD_VAR 0 1
90351: PUSH
90352: LD_INT 4
90354: MINUS
90355: PUSH
90356: LD_VAR 0 2
90360: PUSH
90361: LD_INT 1
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: LIST
90368: PUSH
90369: LD_VAR 0 1
90373: PUSH
90374: LD_VAR 0 2
90378: PUSH
90379: LD_INT 4
90381: MINUS
90382: PUSH
90383: LD_INT 3
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: LIST
90390: PUSH
90391: LD_VAR 0 1
90395: PUSH
90396: LD_INT 4
90398: PLUS
90399: PUSH
90400: LD_VAR 0 2
90404: PUSH
90405: LD_INT 4
90407: PLUS
90408: PUSH
90409: LD_INT 5
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: LIST
90416: PUSH
90417: LD_VAR 0 1
90421: PUSH
90422: LD_INT 3
90424: PLUS
90425: PUSH
90426: LD_VAR 0 2
90430: PUSH
90431: LD_INT 4
90433: PUSH
90434: EMPTY
90435: LIST
90436: LIST
90437: LIST
90438: PUSH
90439: LD_VAR 0 1
90443: PUSH
90444: LD_VAR 0 2
90448: PUSH
90449: LD_INT 3
90451: PLUS
90452: PUSH
90453: LD_INT 0
90455: PUSH
90456: EMPTY
90457: LIST
90458: LIST
90459: LIST
90460: PUSH
90461: EMPTY
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: LIST
90467: ST_TO_ADDR
// end ; end ;
90468: GO 90471
90470: POP
// result := list ;
90471: LD_ADDR_VAR 0 4
90475: PUSH
90476: LD_VAR 0 5
90480: ST_TO_ADDR
// end ;
90481: LD_VAR 0 4
90485: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
90486: LD_INT 0
90488: PPUSH
90489: PPUSH
90490: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
90491: LD_VAR 0 1
90495: NOT
90496: PUSH
90497: LD_VAR 0 2
90501: PUSH
90502: LD_INT 1
90504: PUSH
90505: LD_INT 2
90507: PUSH
90508: LD_INT 3
90510: PUSH
90511: LD_INT 4
90513: PUSH
90514: EMPTY
90515: LIST
90516: LIST
90517: LIST
90518: LIST
90519: IN
90520: NOT
90521: OR
90522: IFFALSE 90526
// exit ;
90524: GO 90618
// tmp := [ ] ;
90526: LD_ADDR_VAR 0 5
90530: PUSH
90531: EMPTY
90532: ST_TO_ADDR
// for i in units do
90533: LD_ADDR_VAR 0 4
90537: PUSH
90538: LD_VAR 0 1
90542: PUSH
90543: FOR_IN
90544: IFFALSE 90587
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
90546: LD_ADDR_VAR 0 5
90550: PUSH
90551: LD_VAR 0 5
90555: PPUSH
90556: LD_VAR 0 5
90560: PUSH
90561: LD_INT 1
90563: PLUS
90564: PPUSH
90565: LD_VAR 0 4
90569: PPUSH
90570: LD_VAR 0 2
90574: PPUSH
90575: CALL_OW 259
90579: PPUSH
90580: CALL_OW 2
90584: ST_TO_ADDR
90585: GO 90543
90587: POP
90588: POP
// if not tmp then
90589: LD_VAR 0 5
90593: NOT
90594: IFFALSE 90598
// exit ;
90596: GO 90618
// result := SortListByListDesc ( units , tmp ) ;
90598: LD_ADDR_VAR 0 3
90602: PUSH
90603: LD_VAR 0 1
90607: PPUSH
90608: LD_VAR 0 5
90612: PPUSH
90613: CALL_OW 77
90617: ST_TO_ADDR
// end ;
90618: LD_VAR 0 3
90622: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
90623: LD_INT 0
90625: PPUSH
90626: PPUSH
90627: PPUSH
// x := GetX ( building ) ;
90628: LD_ADDR_VAR 0 4
90632: PUSH
90633: LD_VAR 0 2
90637: PPUSH
90638: CALL_OW 250
90642: ST_TO_ADDR
// y := GetY ( building ) ;
90643: LD_ADDR_VAR 0 5
90647: PUSH
90648: LD_VAR 0 2
90652: PPUSH
90653: CALL_OW 251
90657: ST_TO_ADDR
// if GetTaskList ( unit ) then
90658: LD_VAR 0 1
90662: PPUSH
90663: CALL_OW 437
90667: IFFALSE 90762
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
90669: LD_STRING e
90671: PUSH
90672: LD_VAR 0 1
90676: PPUSH
90677: CALL_OW 437
90681: PUSH
90682: LD_INT 1
90684: ARRAY
90685: PUSH
90686: LD_INT 1
90688: ARRAY
90689: EQUAL
90690: PUSH
90691: LD_VAR 0 4
90695: PUSH
90696: LD_VAR 0 1
90700: PPUSH
90701: CALL_OW 437
90705: PUSH
90706: LD_INT 1
90708: ARRAY
90709: PUSH
90710: LD_INT 2
90712: ARRAY
90713: EQUAL
90714: AND
90715: PUSH
90716: LD_VAR 0 5
90720: PUSH
90721: LD_VAR 0 1
90725: PPUSH
90726: CALL_OW 437
90730: PUSH
90731: LD_INT 1
90733: ARRAY
90734: PUSH
90735: LD_INT 3
90737: ARRAY
90738: EQUAL
90739: AND
90740: IFFALSE 90752
// result := true else
90742: LD_ADDR_VAR 0 3
90746: PUSH
90747: LD_INT 1
90749: ST_TO_ADDR
90750: GO 90760
// result := false ;
90752: LD_ADDR_VAR 0 3
90756: PUSH
90757: LD_INT 0
90759: ST_TO_ADDR
// end else
90760: GO 90770
// result := false ;
90762: LD_ADDR_VAR 0 3
90766: PUSH
90767: LD_INT 0
90769: ST_TO_ADDR
// end ;
90770: LD_VAR 0 3
90774: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
90775: LD_INT 0
90777: PPUSH
90778: PPUSH
90779: PPUSH
90780: PPUSH
// if not unit or not area then
90781: LD_VAR 0 1
90785: NOT
90786: PUSH
90787: LD_VAR 0 2
90791: NOT
90792: OR
90793: IFFALSE 90797
// exit ;
90795: GO 90961
// tmp := AreaToList ( area , i ) ;
90797: LD_ADDR_VAR 0 6
90801: PUSH
90802: LD_VAR 0 2
90806: PPUSH
90807: LD_VAR 0 5
90811: PPUSH
90812: CALL_OW 517
90816: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
90817: LD_ADDR_VAR 0 5
90821: PUSH
90822: DOUBLE
90823: LD_INT 1
90825: DEC
90826: ST_TO_ADDR
90827: LD_VAR 0 6
90831: PUSH
90832: LD_INT 1
90834: ARRAY
90835: PUSH
90836: FOR_TO
90837: IFFALSE 90959
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
90839: LD_ADDR_VAR 0 7
90843: PUSH
90844: LD_VAR 0 6
90848: PUSH
90849: LD_INT 1
90851: ARRAY
90852: PUSH
90853: LD_VAR 0 5
90857: ARRAY
90858: PUSH
90859: LD_VAR 0 6
90863: PUSH
90864: LD_INT 2
90866: ARRAY
90867: PUSH
90868: LD_VAR 0 5
90872: ARRAY
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
90878: LD_VAR 0 7
90882: PUSH
90883: LD_INT 1
90885: ARRAY
90886: PPUSH
90887: LD_VAR 0 7
90891: PUSH
90892: LD_INT 2
90894: ARRAY
90895: PPUSH
90896: CALL_OW 428
90900: PUSH
90901: LD_INT 0
90903: EQUAL
90904: IFFALSE 90957
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
90906: LD_VAR 0 1
90910: PPUSH
90911: LD_VAR 0 7
90915: PUSH
90916: LD_INT 1
90918: ARRAY
90919: PPUSH
90920: LD_VAR 0 7
90924: PUSH
90925: LD_INT 2
90927: ARRAY
90928: PPUSH
90929: LD_VAR 0 3
90933: PPUSH
90934: CALL_OW 48
// result := IsPlaced ( unit ) ;
90938: LD_ADDR_VAR 0 4
90942: PUSH
90943: LD_VAR 0 1
90947: PPUSH
90948: CALL_OW 305
90952: ST_TO_ADDR
// exit ;
90953: POP
90954: POP
90955: GO 90961
// end ; end ;
90957: GO 90836
90959: POP
90960: POP
// end ;
90961: LD_VAR 0 4
90965: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
90966: LD_INT 0
90968: PPUSH
90969: PPUSH
90970: PPUSH
// if not side or side > 8 then
90971: LD_VAR 0 1
90975: NOT
90976: PUSH
90977: LD_VAR 0 1
90981: PUSH
90982: LD_INT 8
90984: GREATER
90985: OR
90986: IFFALSE 90990
// exit ;
90988: GO 91177
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
90990: LD_ADDR_VAR 0 4
90994: PUSH
90995: LD_INT 22
90997: PUSH
90998: LD_VAR 0 1
91002: PUSH
91003: EMPTY
91004: LIST
91005: LIST
91006: PUSH
91007: LD_INT 21
91009: PUSH
91010: LD_INT 3
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: PPUSH
91021: CALL_OW 69
91025: ST_TO_ADDR
// if not tmp then
91026: LD_VAR 0 4
91030: NOT
91031: IFFALSE 91035
// exit ;
91033: GO 91177
// enable_addtolog := true ;
91035: LD_ADDR_OWVAR 81
91039: PUSH
91040: LD_INT 1
91042: ST_TO_ADDR
// AddToLog ( [ ) ;
91043: LD_STRING [
91045: PPUSH
91046: CALL_OW 561
// for i in tmp do
91050: LD_ADDR_VAR 0 3
91054: PUSH
91055: LD_VAR 0 4
91059: PUSH
91060: FOR_IN
91061: IFFALSE 91168
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
91063: LD_STRING [
91065: PUSH
91066: LD_VAR 0 3
91070: PPUSH
91071: CALL_OW 266
91075: STR
91076: PUSH
91077: LD_STRING , 
91079: STR
91080: PUSH
91081: LD_VAR 0 3
91085: PPUSH
91086: CALL_OW 250
91090: STR
91091: PUSH
91092: LD_STRING , 
91094: STR
91095: PUSH
91096: LD_VAR 0 3
91100: PPUSH
91101: CALL_OW 251
91105: STR
91106: PUSH
91107: LD_STRING , 
91109: STR
91110: PUSH
91111: LD_VAR 0 3
91115: PPUSH
91116: CALL_OW 254
91120: STR
91121: PUSH
91122: LD_STRING , 
91124: STR
91125: PUSH
91126: LD_VAR 0 3
91130: PPUSH
91131: LD_INT 1
91133: PPUSH
91134: CALL_OW 268
91138: STR
91139: PUSH
91140: LD_STRING , 
91142: STR
91143: PUSH
91144: LD_VAR 0 3
91148: PPUSH
91149: LD_INT 2
91151: PPUSH
91152: CALL_OW 268
91156: STR
91157: PUSH
91158: LD_STRING ],
91160: STR
91161: PPUSH
91162: CALL_OW 561
// end ;
91166: GO 91060
91168: POP
91169: POP
// AddToLog ( ]; ) ;
91170: LD_STRING ];
91172: PPUSH
91173: CALL_OW 561
// end ;
91177: LD_VAR 0 2
91181: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
91182: LD_INT 0
91184: PPUSH
91185: PPUSH
91186: PPUSH
91187: PPUSH
91188: PPUSH
// if not area or not rate or not max then
91189: LD_VAR 0 1
91193: NOT
91194: PUSH
91195: LD_VAR 0 2
91199: NOT
91200: OR
91201: PUSH
91202: LD_VAR 0 4
91206: NOT
91207: OR
91208: IFFALSE 91212
// exit ;
91210: GO 91404
// while 1 do
91212: LD_INT 1
91214: IFFALSE 91404
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
91216: LD_ADDR_VAR 0 9
91220: PUSH
91221: LD_VAR 0 1
91225: PPUSH
91226: LD_INT 1
91228: PPUSH
91229: CALL_OW 287
91233: PUSH
91234: LD_INT 10
91236: MUL
91237: ST_TO_ADDR
// r := rate / 10 ;
91238: LD_ADDR_VAR 0 7
91242: PUSH
91243: LD_VAR 0 2
91247: PUSH
91248: LD_INT 10
91250: DIVREAL
91251: ST_TO_ADDR
// time := 1 1$00 ;
91252: LD_ADDR_VAR 0 8
91256: PUSH
91257: LD_INT 2100
91259: ST_TO_ADDR
// if amount < min then
91260: LD_VAR 0 9
91264: PUSH
91265: LD_VAR 0 3
91269: LESS
91270: IFFALSE 91288
// r := r * 2 else
91272: LD_ADDR_VAR 0 7
91276: PUSH
91277: LD_VAR 0 7
91281: PUSH
91282: LD_INT 2
91284: MUL
91285: ST_TO_ADDR
91286: GO 91314
// if amount > max then
91288: LD_VAR 0 9
91292: PUSH
91293: LD_VAR 0 4
91297: GREATER
91298: IFFALSE 91314
// r := r / 2 ;
91300: LD_ADDR_VAR 0 7
91304: PUSH
91305: LD_VAR 0 7
91309: PUSH
91310: LD_INT 2
91312: DIVREAL
91313: ST_TO_ADDR
// time := time / r ;
91314: LD_ADDR_VAR 0 8
91318: PUSH
91319: LD_VAR 0 8
91323: PUSH
91324: LD_VAR 0 7
91328: DIVREAL
91329: ST_TO_ADDR
// if time < 0 then
91330: LD_VAR 0 8
91334: PUSH
91335: LD_INT 0
91337: LESS
91338: IFFALSE 91355
// time := time * - 1 ;
91340: LD_ADDR_VAR 0 8
91344: PUSH
91345: LD_VAR 0 8
91349: PUSH
91350: LD_INT 1
91352: NEG
91353: MUL
91354: ST_TO_ADDR
// wait ( time ) ;
91355: LD_VAR 0 8
91359: PPUSH
91360: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
91364: LD_INT 35
91366: PPUSH
91367: LD_INT 875
91369: PPUSH
91370: CALL_OW 12
91374: PPUSH
91375: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
91379: LD_INT 1
91381: PPUSH
91382: LD_INT 5
91384: PPUSH
91385: CALL_OW 12
91389: PPUSH
91390: LD_VAR 0 1
91394: PPUSH
91395: LD_INT 1
91397: PPUSH
91398: CALL_OW 55
// end ;
91402: GO 91212
// end ;
91404: LD_VAR 0 5
91408: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
91409: LD_INT 0
91411: PPUSH
91412: PPUSH
91413: PPUSH
91414: PPUSH
91415: PPUSH
91416: PPUSH
91417: PPUSH
91418: PPUSH
// if not turrets or not factories then
91419: LD_VAR 0 1
91423: NOT
91424: PUSH
91425: LD_VAR 0 2
91429: NOT
91430: OR
91431: IFFALSE 91435
// exit ;
91433: GO 91742
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
91435: LD_ADDR_VAR 0 10
91439: PUSH
91440: LD_INT 5
91442: PUSH
91443: LD_INT 6
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: PUSH
91450: LD_INT 2
91452: PUSH
91453: LD_INT 4
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: PUSH
91460: LD_INT 3
91462: PUSH
91463: LD_INT 5
91465: PUSH
91466: EMPTY
91467: LIST
91468: LIST
91469: PUSH
91470: EMPTY
91471: LIST
91472: LIST
91473: LIST
91474: PUSH
91475: LD_INT 24
91477: PUSH
91478: LD_INT 25
91480: PUSH
91481: EMPTY
91482: LIST
91483: LIST
91484: PUSH
91485: LD_INT 23
91487: PUSH
91488: LD_INT 27
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 42
91501: PUSH
91502: LD_INT 43
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PUSH
91509: LD_INT 44
91511: PUSH
91512: LD_INT 46
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: PUSH
91519: LD_INT 45
91521: PUSH
91522: LD_INT 47
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: LIST
91533: PUSH
91534: EMPTY
91535: LIST
91536: LIST
91537: LIST
91538: ST_TO_ADDR
// result := [ ] ;
91539: LD_ADDR_VAR 0 3
91543: PUSH
91544: EMPTY
91545: ST_TO_ADDR
// for i in turrets do
91546: LD_ADDR_VAR 0 4
91550: PUSH
91551: LD_VAR 0 1
91555: PUSH
91556: FOR_IN
91557: IFFALSE 91740
// begin nat := GetNation ( i ) ;
91559: LD_ADDR_VAR 0 7
91563: PUSH
91564: LD_VAR 0 4
91568: PPUSH
91569: CALL_OW 248
91573: ST_TO_ADDR
// weapon := 0 ;
91574: LD_ADDR_VAR 0 8
91578: PUSH
91579: LD_INT 0
91581: ST_TO_ADDR
// if not nat then
91582: LD_VAR 0 7
91586: NOT
91587: IFFALSE 91591
// continue ;
91589: GO 91556
// for j in list [ nat ] do
91591: LD_ADDR_VAR 0 5
91595: PUSH
91596: LD_VAR 0 10
91600: PUSH
91601: LD_VAR 0 7
91605: ARRAY
91606: PUSH
91607: FOR_IN
91608: IFFALSE 91649
// if GetBWeapon ( i ) = j [ 1 ] then
91610: LD_VAR 0 4
91614: PPUSH
91615: CALL_OW 269
91619: PUSH
91620: LD_VAR 0 5
91624: PUSH
91625: LD_INT 1
91627: ARRAY
91628: EQUAL
91629: IFFALSE 91647
// begin weapon := j [ 2 ] ;
91631: LD_ADDR_VAR 0 8
91635: PUSH
91636: LD_VAR 0 5
91640: PUSH
91641: LD_INT 2
91643: ARRAY
91644: ST_TO_ADDR
// break ;
91645: GO 91649
// end ;
91647: GO 91607
91649: POP
91650: POP
// if not weapon then
91651: LD_VAR 0 8
91655: NOT
91656: IFFALSE 91660
// continue ;
91658: GO 91556
// for k in factories do
91660: LD_ADDR_VAR 0 6
91664: PUSH
91665: LD_VAR 0 2
91669: PUSH
91670: FOR_IN
91671: IFFALSE 91736
// begin weapons := AvailableWeaponList ( k ) ;
91673: LD_ADDR_VAR 0 9
91677: PUSH
91678: LD_VAR 0 6
91682: PPUSH
91683: CALL_OW 478
91687: ST_TO_ADDR
// if not weapons then
91688: LD_VAR 0 9
91692: NOT
91693: IFFALSE 91697
// continue ;
91695: GO 91670
// if weapon in weapons then
91697: LD_VAR 0 8
91701: PUSH
91702: LD_VAR 0 9
91706: IN
91707: IFFALSE 91734
// begin result := [ i , weapon ] ;
91709: LD_ADDR_VAR 0 3
91713: PUSH
91714: LD_VAR 0 4
91718: PUSH
91719: LD_VAR 0 8
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: ST_TO_ADDR
// exit ;
91728: POP
91729: POP
91730: POP
91731: POP
91732: GO 91742
// end ; end ;
91734: GO 91670
91736: POP
91737: POP
// end ;
91738: GO 91556
91740: POP
91741: POP
// end ;
91742: LD_VAR 0 3
91746: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
91747: LD_INT 0
91749: PPUSH
// if not side or side > 8 then
91750: LD_VAR 0 3
91754: NOT
91755: PUSH
91756: LD_VAR 0 3
91760: PUSH
91761: LD_INT 8
91763: GREATER
91764: OR
91765: IFFALSE 91769
// exit ;
91767: GO 91828
// if not range then
91769: LD_VAR 0 4
91773: NOT
91774: IFFALSE 91785
// range := - 12 ;
91776: LD_ADDR_VAR 0 4
91780: PUSH
91781: LD_INT 12
91783: NEG
91784: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
91785: LD_VAR 0 1
91789: PPUSH
91790: LD_VAR 0 2
91794: PPUSH
91795: LD_VAR 0 3
91799: PPUSH
91800: LD_VAR 0 4
91804: PPUSH
91805: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
91809: LD_VAR 0 1
91813: PPUSH
91814: LD_VAR 0 2
91818: PPUSH
91819: LD_VAR 0 3
91823: PPUSH
91824: CALL_OW 331
// end ;
91828: LD_VAR 0 5
91832: RET
// export function Video ( mode ) ; begin
91833: LD_INT 0
91835: PPUSH
// ingame_video = mode ;
91836: LD_ADDR_OWVAR 52
91840: PUSH
91841: LD_VAR 0 1
91845: ST_TO_ADDR
// interface_hidden = mode ;
91846: LD_ADDR_OWVAR 54
91850: PUSH
91851: LD_VAR 0 1
91855: ST_TO_ADDR
// end ;
91856: LD_VAR 0 2
91860: RET
// export function Join ( array , element ) ; begin
91861: LD_INT 0
91863: PPUSH
// result := array ^ element ;
91864: LD_ADDR_VAR 0 3
91868: PUSH
91869: LD_VAR 0 1
91873: PUSH
91874: LD_VAR 0 2
91878: ADD
91879: ST_TO_ADDR
// end ;
91880: LD_VAR 0 3
91884: RET
// export function JoinUnion ( array , element ) ; begin
91885: LD_INT 0
91887: PPUSH
// result := array union element ;
91888: LD_ADDR_VAR 0 3
91892: PUSH
91893: LD_VAR 0 1
91897: PUSH
91898: LD_VAR 0 2
91902: UNION
91903: ST_TO_ADDR
// end ;
91904: LD_VAR 0 3
91908: RET
// export function GetBehemoths ( side ) ; begin
91909: LD_INT 0
91911: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
91912: LD_ADDR_VAR 0 2
91916: PUSH
91917: LD_INT 22
91919: PUSH
91920: LD_VAR 0 1
91924: PUSH
91925: EMPTY
91926: LIST
91927: LIST
91928: PUSH
91929: LD_INT 31
91931: PUSH
91932: LD_INT 25
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PPUSH
91943: CALL_OW 69
91947: ST_TO_ADDR
// end ;
91948: LD_VAR 0 2
91952: RET
// export function Shuffle ( array ) ; var i , index ; begin
91953: LD_INT 0
91955: PPUSH
91956: PPUSH
91957: PPUSH
// result := [ ] ;
91958: LD_ADDR_VAR 0 2
91962: PUSH
91963: EMPTY
91964: ST_TO_ADDR
// if not array then
91965: LD_VAR 0 1
91969: NOT
91970: IFFALSE 91974
// exit ;
91972: GO 92073
// Randomize ;
91974: CALL_OW 10
// for i = array downto 1 do
91978: LD_ADDR_VAR 0 3
91982: PUSH
91983: DOUBLE
91984: LD_VAR 0 1
91988: INC
91989: ST_TO_ADDR
91990: LD_INT 1
91992: PUSH
91993: FOR_DOWNTO
91994: IFFALSE 92071
// begin index := rand ( 1 , array ) ;
91996: LD_ADDR_VAR 0 4
92000: PUSH
92001: LD_INT 1
92003: PPUSH
92004: LD_VAR 0 1
92008: PPUSH
92009: CALL_OW 12
92013: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
92014: LD_ADDR_VAR 0 2
92018: PUSH
92019: LD_VAR 0 2
92023: PPUSH
92024: LD_VAR 0 2
92028: PUSH
92029: LD_INT 1
92031: PLUS
92032: PPUSH
92033: LD_VAR 0 1
92037: PUSH
92038: LD_VAR 0 4
92042: ARRAY
92043: PPUSH
92044: CALL_OW 2
92048: ST_TO_ADDR
// array := Delete ( array , index ) ;
92049: LD_ADDR_VAR 0 1
92053: PUSH
92054: LD_VAR 0 1
92058: PPUSH
92059: LD_VAR 0 4
92063: PPUSH
92064: CALL_OW 3
92068: ST_TO_ADDR
// end ;
92069: GO 91993
92071: POP
92072: POP
// end ;
92073: LD_VAR 0 2
92077: RET
// export function GetBaseMaterials ( base ) ; begin
92078: LD_INT 0
92080: PPUSH
// result := [ 0 , 0 , 0 ] ;
92081: LD_ADDR_VAR 0 2
92085: PUSH
92086: LD_INT 0
92088: PUSH
92089: LD_INT 0
92091: PUSH
92092: LD_INT 0
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: LIST
92099: ST_TO_ADDR
// if not base then
92100: LD_VAR 0 1
92104: NOT
92105: IFFALSE 92109
// exit ;
92107: GO 92158
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
92109: LD_ADDR_VAR 0 2
92113: PUSH
92114: LD_VAR 0 1
92118: PPUSH
92119: LD_INT 1
92121: PPUSH
92122: CALL_OW 275
92126: PUSH
92127: LD_VAR 0 1
92131: PPUSH
92132: LD_INT 2
92134: PPUSH
92135: CALL_OW 275
92139: PUSH
92140: LD_VAR 0 1
92144: PPUSH
92145: LD_INT 3
92147: PPUSH
92148: CALL_OW 275
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: LIST
92157: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
92158: LD_VAR 0 2
92162: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
92163: LD_INT 0
92165: PPUSH
92166: PPUSH
92167: PPUSH
92168: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
92169: LD_VAR 0 1
92173: PPUSH
92174: CALL_OW 264
92178: PUSH
92179: LD_EXP 71
92183: EQUAL
92184: IFFALSE 92256
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
92186: LD_INT 68
92188: PPUSH
92189: LD_VAR 0 1
92193: PPUSH
92194: CALL_OW 255
92198: PPUSH
92199: CALL_OW 321
92203: PUSH
92204: LD_INT 2
92206: EQUAL
92207: IFFALSE 92219
// eff := 70 else
92209: LD_ADDR_VAR 0 6
92213: PUSH
92214: LD_INT 70
92216: ST_TO_ADDR
92217: GO 92227
// eff := 30 ;
92219: LD_ADDR_VAR 0 6
92223: PUSH
92224: LD_INT 30
92226: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
92227: LD_VAR 0 1
92231: PPUSH
92232: CALL_OW 250
92236: PPUSH
92237: LD_VAR 0 1
92241: PPUSH
92242: CALL_OW 251
92246: PPUSH
92247: LD_VAR 0 6
92251: PPUSH
92252: CALL_OW 495
// end ; end ;
92256: LD_VAR 0 4
92260: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
92261: LD_INT 0
92263: PPUSH
92264: PPUSH
92265: PPUSH
92266: PPUSH
92267: PPUSH
92268: PPUSH
// if cmd = 124 then
92269: LD_VAR 0 1
92273: PUSH
92274: LD_INT 124
92276: EQUAL
92277: IFFALSE 92483
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
92279: LD_ADDR_VAR 0 5
92283: PUSH
92284: LD_INT 2
92286: PUSH
92287: LD_INT 34
92289: PUSH
92290: LD_INT 53
92292: PUSH
92293: EMPTY
92294: LIST
92295: LIST
92296: PUSH
92297: LD_INT 34
92299: PUSH
92300: LD_INT 14
92302: PUSH
92303: EMPTY
92304: LIST
92305: LIST
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: LIST
92311: PPUSH
92312: CALL_OW 69
92316: ST_TO_ADDR
// if not tmp then
92317: LD_VAR 0 5
92321: NOT
92322: IFFALSE 92326
// exit ;
92324: GO 92483
// for i in tmp do
92326: LD_ADDR_VAR 0 3
92330: PUSH
92331: LD_VAR 0 5
92335: PUSH
92336: FOR_IN
92337: IFFALSE 92481
// begin taskList := GetTaskList ( i ) ;
92339: LD_ADDR_VAR 0 6
92343: PUSH
92344: LD_VAR 0 3
92348: PPUSH
92349: CALL_OW 437
92353: ST_TO_ADDR
// if not taskList then
92354: LD_VAR 0 6
92358: NOT
92359: IFFALSE 92363
// continue ;
92361: GO 92336
// for j = 1 to taskList do
92363: LD_ADDR_VAR 0 4
92367: PUSH
92368: DOUBLE
92369: LD_INT 1
92371: DEC
92372: ST_TO_ADDR
92373: LD_VAR 0 6
92377: PUSH
92378: FOR_TO
92379: IFFALSE 92477
// if taskList [ j ] [ 1 ] = | then
92381: LD_VAR 0 6
92385: PUSH
92386: LD_VAR 0 4
92390: ARRAY
92391: PUSH
92392: LD_INT 1
92394: ARRAY
92395: PUSH
92396: LD_STRING |
92398: EQUAL
92399: IFFALSE 92475
// begin _taskList := Delete ( taskList , 1 ) ;
92401: LD_ADDR_VAR 0 7
92405: PUSH
92406: LD_VAR 0 6
92410: PPUSH
92411: LD_INT 1
92413: PPUSH
92414: CALL_OW 3
92418: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
92419: LD_VAR 0 3
92423: PPUSH
92424: LD_VAR 0 7
92428: PPUSH
92429: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
92433: LD_VAR 0 3
92437: PPUSH
92438: LD_VAR 0 6
92442: PUSH
92443: LD_VAR 0 4
92447: ARRAY
92448: PUSH
92449: LD_INT 2
92451: ARRAY
92452: PPUSH
92453: LD_VAR 0 6
92457: PUSH
92458: LD_VAR 0 4
92462: ARRAY
92463: PUSH
92464: LD_INT 3
92466: ARRAY
92467: PPUSH
92468: LD_INT 8
92470: PPUSH
92471: CALL 92488 0 4
// end ;
92475: GO 92378
92477: POP
92478: POP
// end ;
92479: GO 92336
92481: POP
92482: POP
// end ; end ;
92483: LD_VAR 0 2
92487: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
92488: LD_INT 0
92490: PPUSH
92491: PPUSH
92492: PPUSH
92493: PPUSH
92494: PPUSH
92495: PPUSH
92496: PPUSH
92497: PPUSH
92498: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
92499: LD_VAR 0 1
92503: NOT
92504: PUSH
92505: LD_VAR 0 2
92509: PPUSH
92510: LD_VAR 0 3
92514: PPUSH
92515: CALL_OW 488
92519: NOT
92520: OR
92521: PUSH
92522: LD_VAR 0 4
92526: NOT
92527: OR
92528: IFFALSE 92532
// exit ;
92530: GO 92872
// list := [ ] ;
92532: LD_ADDR_VAR 0 13
92536: PUSH
92537: EMPTY
92538: ST_TO_ADDR
// if x - r < 0 then
92539: LD_VAR 0 2
92543: PUSH
92544: LD_VAR 0 4
92548: MINUS
92549: PUSH
92550: LD_INT 0
92552: LESS
92553: IFFALSE 92565
// min_x := 0 else
92555: LD_ADDR_VAR 0 7
92559: PUSH
92560: LD_INT 0
92562: ST_TO_ADDR
92563: GO 92581
// min_x := x - r ;
92565: LD_ADDR_VAR 0 7
92569: PUSH
92570: LD_VAR 0 2
92574: PUSH
92575: LD_VAR 0 4
92579: MINUS
92580: ST_TO_ADDR
// if y - r < 0 then
92581: LD_VAR 0 3
92585: PUSH
92586: LD_VAR 0 4
92590: MINUS
92591: PUSH
92592: LD_INT 0
92594: LESS
92595: IFFALSE 92607
// min_y := 0 else
92597: LD_ADDR_VAR 0 8
92601: PUSH
92602: LD_INT 0
92604: ST_TO_ADDR
92605: GO 92623
// min_y := y - r ;
92607: LD_ADDR_VAR 0 8
92611: PUSH
92612: LD_VAR 0 3
92616: PUSH
92617: LD_VAR 0 4
92621: MINUS
92622: ST_TO_ADDR
// max_x := x + r ;
92623: LD_ADDR_VAR 0 9
92627: PUSH
92628: LD_VAR 0 2
92632: PUSH
92633: LD_VAR 0 4
92637: PLUS
92638: ST_TO_ADDR
// max_y := y + r ;
92639: LD_ADDR_VAR 0 10
92643: PUSH
92644: LD_VAR 0 3
92648: PUSH
92649: LD_VAR 0 4
92653: PLUS
92654: ST_TO_ADDR
// for _x = min_x to max_x do
92655: LD_ADDR_VAR 0 11
92659: PUSH
92660: DOUBLE
92661: LD_VAR 0 7
92665: DEC
92666: ST_TO_ADDR
92667: LD_VAR 0 9
92671: PUSH
92672: FOR_TO
92673: IFFALSE 92790
// for _y = min_y to max_y do
92675: LD_ADDR_VAR 0 12
92679: PUSH
92680: DOUBLE
92681: LD_VAR 0 8
92685: DEC
92686: ST_TO_ADDR
92687: LD_VAR 0 10
92691: PUSH
92692: FOR_TO
92693: IFFALSE 92786
// begin if not ValidHex ( _x , _y ) then
92695: LD_VAR 0 11
92699: PPUSH
92700: LD_VAR 0 12
92704: PPUSH
92705: CALL_OW 488
92709: NOT
92710: IFFALSE 92714
// continue ;
92712: GO 92692
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
92714: LD_VAR 0 11
92718: PPUSH
92719: LD_VAR 0 12
92723: PPUSH
92724: CALL_OW 351
92728: PUSH
92729: LD_VAR 0 11
92733: PPUSH
92734: LD_VAR 0 12
92738: PPUSH
92739: CALL_OW 554
92743: AND
92744: IFFALSE 92784
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
92746: LD_ADDR_VAR 0 13
92750: PUSH
92751: LD_VAR 0 13
92755: PPUSH
92756: LD_VAR 0 13
92760: PUSH
92761: LD_INT 1
92763: PLUS
92764: PPUSH
92765: LD_VAR 0 11
92769: PUSH
92770: LD_VAR 0 12
92774: PUSH
92775: EMPTY
92776: LIST
92777: LIST
92778: PPUSH
92779: CALL_OW 2
92783: ST_TO_ADDR
// end ;
92784: GO 92692
92786: POP
92787: POP
92788: GO 92672
92790: POP
92791: POP
// if not list then
92792: LD_VAR 0 13
92796: NOT
92797: IFFALSE 92801
// exit ;
92799: GO 92872
// for i in list do
92801: LD_ADDR_VAR 0 6
92805: PUSH
92806: LD_VAR 0 13
92810: PUSH
92811: FOR_IN
92812: IFFALSE 92870
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
92814: LD_VAR 0 1
92818: PPUSH
92819: LD_STRING M
92821: PUSH
92822: LD_VAR 0 6
92826: PUSH
92827: LD_INT 1
92829: ARRAY
92830: PUSH
92831: LD_VAR 0 6
92835: PUSH
92836: LD_INT 2
92838: ARRAY
92839: PUSH
92840: LD_INT 0
92842: PUSH
92843: LD_INT 0
92845: PUSH
92846: LD_INT 0
92848: PUSH
92849: LD_INT 0
92851: PUSH
92852: EMPTY
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: PUSH
92861: EMPTY
92862: LIST
92863: PPUSH
92864: CALL_OW 447
92868: GO 92811
92870: POP
92871: POP
// end ;
92872: LD_VAR 0 5
92876: RET
