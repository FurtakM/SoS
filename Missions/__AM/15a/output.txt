// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 22154 0 0
// InitNature ;
  19: CALL 18820 0 0
// InitArtifact ;
  23: CALL 19437 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5102 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 6941 0 0
// PrepareRussian ;
  52: CALL 9061 0 0
// PrepareLegion ;
  56: CALL 7438 0 0
// Action ;
  60: CALL 11885 0 0
// MC_Start ( ) ;
  64: CALL 24334 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 102
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 103
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 46051 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 47130 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 47223 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 107
 353: PUSH
 354: LD_EXP 107
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 46388 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 46573 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 47130 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 47223 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 46388 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 46573 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 47003 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 46051 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 47130 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 47223 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 107
 843: PUSH
 844: LD_EXP 107
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 46388 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 46573 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 47130 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 47223 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 47541 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 47335 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 46388 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 46573 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 46954 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// uc_side := 7 ;
1443: LD_ADDR_OWVAR 20
1447: PUSH
1448: LD_INT 7
1450: ST_TO_ADDR
// tmp := [ ] ;
1451: LD_ADDR_VAR 0 5
1455: PUSH
1456: EMPTY
1457: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1458: LD_ADDR_EXP 19
1462: PUSH
1463: LD_STRING JMM
1465: PPUSH
1466: LD_EXP 1
1470: NOT
1471: PPUSH
1472: LD_STRING 14a_
1474: PPUSH
1475: CALL 52862 0 3
1479: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1480: LD_ADDR_EXP 52
1484: PUSH
1485: LD_STRING Burlak
1487: PPUSH
1488: LD_EXP 1
1492: NOT
1493: PPUSH
1494: LD_STRING 14a_
1496: PPUSH
1497: CALL 52862 0 3
1501: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1502: LD_ADDR_EXP 34
1506: PUSH
1507: LD_STRING Joan
1509: PPUSH
1510: LD_EXP 1
1514: NOT
1515: PPUSH
1516: LD_STRING 13a_
1518: PPUSH
1519: CALL 52862 0 3
1523: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1524: LD_ADDR_EXP 20
1528: PUSH
1529: LD_STRING Roth
1531: PPUSH
1532: LD_EXP 1
1536: NOT
1537: PPUSH
1538: LD_STRING 13a_
1540: PPUSH
1541: CALL 52862 0 3
1545: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1546: LD_ADDR_EXP 38
1550: PUSH
1551: LD_STRING Gossudarov
1553: PPUSH
1554: LD_EXP 1
1558: NOT
1559: PPUSH
1560: LD_STRING 13a_
1562: PPUSH
1563: CALL 52862 0 3
1567: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1568: LD_ADDR_EXP 25
1572: PUSH
1573: LD_STRING Denis
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 13a_
1584: PPUSH
1585: CALL 52862 0 3
1589: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1590: LD_ADDR_EXP 35
1594: PUSH
1595: LD_STRING DeltaDoctor
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 13a_
1606: PPUSH
1607: CALL 52862 0 3
1611: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1612: LD_ADDR_EXP 37
1616: PUSH
1617: LD_STRING Mike
1619: PPUSH
1620: LD_EXP 1
1624: NOT
1625: PPUSH
1626: LD_STRING 13a_
1628: PPUSH
1629: CALL 52862 0 3
1633: ST_TO_ADDR
// if DeltaDoctor then
1634: LD_EXP 35
1638: IFFALSE 1656
// tmp := tmp ^ DeltaDoctor ;
1640: LD_ADDR_VAR 0 5
1644: PUSH
1645: LD_VAR 0 5
1649: PUSH
1650: LD_EXP 35
1654: ADD
1655: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1656: LD_ADDR_EXP 33
1660: PUSH
1661: LD_STRING Simms
1663: PPUSH
1664: LD_EXP 1
1668: NOT
1669: PPUSH
1670: LD_STRING 13a_
1672: PPUSH
1673: CALL 52862 0 3
1677: ST_TO_ADDR
// if Simms then
1678: LD_EXP 33
1682: IFFALSE 1700
// tmp := tmp ^ Simms ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_VAR 0 5
1693: PUSH
1694: LD_EXP 33
1698: ADD
1699: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1700: LD_ADDR_EXP 31
1704: PUSH
1705: LD_STRING Frank
1707: PPUSH
1708: LD_EXP 1
1712: NOT
1713: PPUSH
1714: LD_STRING 13a_
1716: PPUSH
1717: CALL 52862 0 3
1721: ST_TO_ADDR
// if Frank then
1722: LD_EXP 31
1726: IFFALSE 1744
// tmp := tmp ^ Frank ;
1728: LD_ADDR_VAR 0 5
1732: PUSH
1733: LD_VAR 0 5
1737: PUSH
1738: LD_EXP 31
1742: ADD
1743: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1744: LD_ADDR_EXP 39
1748: PUSH
1749: LD_STRING Kirilenkova
1751: PPUSH
1752: LD_EXP 1
1756: NOT
1757: PPUSH
1758: LD_STRING 13a_
1760: PPUSH
1761: CALL 52862 0 3
1765: ST_TO_ADDR
// if Kirilenkova then
1766: LD_EXP 39
1770: IFFALSE 1788
// tmp := tmp ^ Kirilenkova ;
1772: LD_ADDR_VAR 0 5
1776: PUSH
1777: LD_VAR 0 5
1781: PUSH
1782: LD_EXP 39
1786: ADD
1787: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1788: LD_ADDR_EXP 40
1792: PUSH
1793: LD_STRING Titov
1795: PPUSH
1796: LD_EXP 1
1800: NOT
1801: PPUSH
1802: LD_STRING 13a_
1804: PPUSH
1805: CALL 52862 0 3
1809: ST_TO_ADDR
// if Titov then
1810: LD_EXP 40
1814: IFFALSE 1832
// tmp := tmp ^ Titov ;
1816: LD_ADDR_VAR 0 5
1820: PUSH
1821: LD_VAR 0 5
1825: PUSH
1826: LD_EXP 40
1830: ADD
1831: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1832: LD_ADDR_EXP 41
1836: PUSH
1837: LD_STRING Fadeev
1839: PPUSH
1840: LD_EXP 1
1844: NOT
1845: PPUSH
1846: LD_STRING 13a_
1848: PPUSH
1849: CALL 52862 0 3
1853: ST_TO_ADDR
// if Fadeev then
1854: LD_EXP 41
1858: IFFALSE 1876
// tmp := tmp ^ Fadeev ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_EXP 41
1874: ADD
1875: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1876: LD_ADDR_EXP 42
1880: PUSH
1881: LD_STRING Dolgov
1883: PPUSH
1884: LD_EXP 1
1888: NOT
1889: PPUSH
1890: LD_STRING 13a_
1892: PPUSH
1893: CALL 52862 0 3
1897: ST_TO_ADDR
// if Dolgov then
1898: LD_EXP 42
1902: IFFALSE 1920
// tmp := tmp ^ Dolgov ;
1904: LD_ADDR_VAR 0 5
1908: PUSH
1909: LD_VAR 0 5
1913: PUSH
1914: LD_EXP 42
1918: ADD
1919: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1920: LD_ADDR_EXP 43
1924: PUSH
1925: LD_STRING Petrosyan
1927: PPUSH
1928: LD_EXP 1
1932: NOT
1933: PPUSH
1934: LD_STRING 13a_
1936: PPUSH
1937: CALL 52862 0 3
1941: ST_TO_ADDR
// if Petrosyan then
1942: LD_EXP 43
1946: IFFALSE 1964
// tmp := tmp ^ Petrosyan ;
1948: LD_ADDR_VAR 0 5
1952: PUSH
1953: LD_VAR 0 5
1957: PUSH
1958: LD_EXP 43
1962: ADD
1963: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1964: LD_ADDR_EXP 44
1968: PUSH
1969: LD_STRING Scholtze
1971: PPUSH
1972: LD_EXP 1
1976: NOT
1977: PPUSH
1978: LD_STRING 13a_
1980: PPUSH
1981: CALL 52862 0 3
1985: ST_TO_ADDR
// if Scholtze then
1986: LD_EXP 44
1990: IFFALSE 2008
// tmp := tmp ^ Scholtze ;
1992: LD_ADDR_VAR 0 5
1996: PUSH
1997: LD_VAR 0 5
2001: PUSH
2002: LD_EXP 44
2006: ADD
2007: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2008: LD_ADDR_EXP 45
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: LD_EXP 1
2020: NOT
2021: PPUSH
2022: LD_STRING 13a_
2024: PPUSH
2025: CALL 52862 0 3
2029: ST_TO_ADDR
// if Oblukov then
2030: LD_EXP 45
2034: IFFALSE 2052
// tmp := tmp ^ Oblukov ;
2036: LD_ADDR_VAR 0 5
2040: PUSH
2041: LD_VAR 0 5
2045: PUSH
2046: LD_EXP 45
2050: ADD
2051: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2052: LD_ADDR_EXP 46
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: LD_EXP 1
2064: NOT
2065: PPUSH
2066: LD_STRING 13a_
2068: PPUSH
2069: CALL 52862 0 3
2073: ST_TO_ADDR
// if Kapitsova then
2074: LD_EXP 46
2078: IFFALSE 2096
// tmp := tmp ^ Kapitsova ;
2080: LD_ADDR_VAR 0 5
2084: PUSH
2085: LD_VAR 0 5
2089: PUSH
2090: LD_EXP 46
2094: ADD
2095: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2096: LD_ADDR_EXP 47
2100: PUSH
2101: LD_STRING Lipshchin
2103: PPUSH
2104: LD_EXP 1
2108: NOT
2109: PPUSH
2110: LD_STRING 13a_
2112: PPUSH
2113: CALL 52862 0 3
2117: ST_TO_ADDR
// if Lipshchin then
2118: LD_EXP 47
2122: IFFALSE 2140
// tmp := tmp ^ Lipshchin ;
2124: LD_ADDR_VAR 0 5
2128: PUSH
2129: LD_VAR 0 5
2133: PUSH
2134: LD_EXP 47
2138: ADD
2139: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2140: LD_ADDR_EXP 48
2144: PUSH
2145: LD_STRING Petrovova
2147: PPUSH
2148: LD_EXP 1
2152: NOT
2153: PPUSH
2154: LD_STRING 13a_
2156: PPUSH
2157: CALL 52862 0 3
2161: ST_TO_ADDR
// if Petrovova then
2162: LD_EXP 48
2166: IFFALSE 2184
// tmp := tmp ^ Petrovova ;
2168: LD_ADDR_VAR 0 5
2172: PUSH
2173: LD_VAR 0 5
2177: PUSH
2178: LD_EXP 48
2182: ADD
2183: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2184: LD_ADDR_EXP 49
2188: PUSH
2189: LD_STRING Kovalyuk
2191: PPUSH
2192: LD_EXP 1
2196: NOT
2197: PPUSH
2198: LD_STRING 13a_
2200: PPUSH
2201: CALL 52862 0 3
2205: ST_TO_ADDR
// if Kovalyuk then
2206: LD_EXP 49
2210: IFFALSE 2228
// tmp := tmp ^ Kovalyuk ;
2212: LD_ADDR_VAR 0 5
2216: PUSH
2217: LD_VAR 0 5
2221: PUSH
2222: LD_EXP 49
2226: ADD
2227: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2228: LD_ADDR_EXP 50
2232: PUSH
2233: LD_STRING Kuzmov
2235: PPUSH
2236: LD_EXP 1
2240: NOT
2241: PPUSH
2242: LD_STRING 13a_
2244: PPUSH
2245: CALL 52862 0 3
2249: ST_TO_ADDR
// if Kuzmov then
2250: LD_EXP 50
2254: IFFALSE 2272
// tmp := tmp ^ Kuzmov ;
2256: LD_ADDR_VAR 0 5
2260: PUSH
2261: LD_VAR 0 5
2265: PUSH
2266: LD_EXP 50
2270: ADD
2271: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2272: LD_ADDR_EXP 51
2276: PUSH
2277: LD_STRING Karamazov
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: LD_STRING 13a_
2288: PPUSH
2289: CALL 52862 0 3
2293: ST_TO_ADDR
// if Karamazov then
2294: LD_EXP 51
2298: IFFALSE 2316
// tmp := tmp ^ Karamazov ;
2300: LD_ADDR_VAR 0 5
2304: PUSH
2305: LD_VAR 0 5
2309: PUSH
2310: LD_EXP 51
2314: ADD
2315: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2316: LD_ADDR_EXP 53
2320: PUSH
2321: LD_STRING Belkov
2323: PPUSH
2324: LD_EXP 1
2328: NOT
2329: PPUSH
2330: LD_STRING 13a_
2332: PPUSH
2333: CALL 52862 0 3
2337: ST_TO_ADDR
// if Belkov then
2338: LD_EXP 53
2342: IFFALSE 2360
// tmp := tmp ^ Belkov ;
2344: LD_ADDR_VAR 0 5
2348: PUSH
2349: LD_VAR 0 5
2353: PUSH
2354: LD_EXP 53
2358: ADD
2359: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 54
2364: PUSH
2365: LD_STRING Gnyevko
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 52862 0 3
2381: ST_TO_ADDR
// if Gnyevko then
2382: LD_EXP 54
2386: IFFALSE 2404
// tmp := tmp ^ Gnyevko ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 54
2402: ADD
2403: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2404: LD_ADDR_EXP 36
2408: PUSH
2409: LD_STRING Coonie
2411: PPUSH
2412: CALL_OW 25
2416: ST_TO_ADDR
// if not Lisa then
2417: LD_EXP 21
2421: NOT
2422: IFFALSE 2468
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2424: LD_ADDR_EXP 21
2428: PUSH
2429: LD_STRING Lisa
2431: PPUSH
2432: LD_EXP 1
2436: NOT
2437: PPUSH
2438: LD_STRING 13a_
2440: PPUSH
2441: CALL 52862 0 3
2445: ST_TO_ADDR
// if Lisa then
2446: LD_EXP 21
2450: IFFALSE 2468
// tmp := tmp ^ Lisa ;
2452: LD_ADDR_VAR 0 5
2456: PUSH
2457: LD_VAR 0 5
2461: PUSH
2462: LD_EXP 21
2466: ADD
2467: ST_TO_ADDR
// end ; if not Donaldson then
2468: LD_EXP 22
2472: NOT
2473: IFFALSE 2519
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2475: LD_ADDR_EXP 22
2479: PUSH
2480: LD_STRING Donaldson
2482: PPUSH
2483: LD_EXP 1
2487: NOT
2488: PPUSH
2489: LD_STRING 13a_
2491: PPUSH
2492: CALL 52862 0 3
2496: ST_TO_ADDR
// if Donaldson then
2497: LD_EXP 22
2501: IFFALSE 2519
// tmp := tmp ^ Donaldson ;
2503: LD_ADDR_VAR 0 5
2507: PUSH
2508: LD_VAR 0 5
2512: PUSH
2513: LD_EXP 22
2517: ADD
2518: ST_TO_ADDR
// end ; if not Bobby then
2519: LD_EXP 23
2523: NOT
2524: IFFALSE 2570
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2526: LD_ADDR_EXP 23
2530: PUSH
2531: LD_STRING Bobby
2533: PPUSH
2534: LD_EXP 1
2538: NOT
2539: PPUSH
2540: LD_STRING 13a_
2542: PPUSH
2543: CALL 52862 0 3
2547: ST_TO_ADDR
// if Bobby then
2548: LD_EXP 23
2552: IFFALSE 2570
// tmp := tmp ^ Bobby ;
2554: LD_ADDR_VAR 0 5
2558: PUSH
2559: LD_VAR 0 5
2563: PUSH
2564: LD_EXP 23
2568: ADD
2569: ST_TO_ADDR
// end ; if not Cyrus then
2570: LD_EXP 24
2574: NOT
2575: IFFALSE 2621
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2577: LD_ADDR_EXP 24
2581: PUSH
2582: LD_STRING Cyrus
2584: PPUSH
2585: LD_EXP 1
2589: NOT
2590: PPUSH
2591: LD_STRING 13a_
2593: PPUSH
2594: CALL 52862 0 3
2598: ST_TO_ADDR
// if Cyrus then
2599: LD_EXP 24
2603: IFFALSE 2621
// tmp := tmp ^ Cyrus ;
2605: LD_ADDR_VAR 0 5
2609: PUSH
2610: LD_VAR 0 5
2614: PUSH
2615: LD_EXP 24
2619: ADD
2620: ST_TO_ADDR
// end ; if not Brown then
2621: LD_EXP 26
2625: NOT
2626: IFFALSE 2672
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2628: LD_ADDR_EXP 26
2632: PUSH
2633: LD_STRING Brown
2635: PPUSH
2636: LD_EXP 1
2640: NOT
2641: PPUSH
2642: LD_STRING 13a_
2644: PPUSH
2645: CALL 52862 0 3
2649: ST_TO_ADDR
// if Brown then
2650: LD_EXP 26
2654: IFFALSE 2672
// tmp := tmp ^ Brown ;
2656: LD_ADDR_VAR 0 5
2660: PUSH
2661: LD_VAR 0 5
2665: PUSH
2666: LD_EXP 26
2670: ADD
2671: ST_TO_ADDR
// end ; if not Gladstone then
2672: LD_EXP 27
2676: NOT
2677: IFFALSE 2723
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2679: LD_ADDR_EXP 27
2683: PUSH
2684: LD_STRING Gladstone
2686: PPUSH
2687: LD_EXP 1
2691: NOT
2692: PPUSH
2693: LD_STRING 13a_
2695: PPUSH
2696: CALL 52862 0 3
2700: ST_TO_ADDR
// if Gladstone then
2701: LD_EXP 27
2705: IFFALSE 2723
// tmp := tmp ^ Gladstone ;
2707: LD_ADDR_VAR 0 5
2711: PUSH
2712: LD_VAR 0 5
2716: PUSH
2717: LD_EXP 27
2721: ADD
2722: ST_TO_ADDR
// end ; if not Cornel then
2723: LD_EXP 29
2727: NOT
2728: IFFALSE 2774
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2730: LD_ADDR_EXP 29
2734: PUSH
2735: LD_STRING Cornel
2737: PPUSH
2738: LD_EXP 1
2742: NOT
2743: PPUSH
2744: LD_STRING 13a_
2746: PPUSH
2747: CALL 52862 0 3
2751: ST_TO_ADDR
// if Cornel then
2752: LD_EXP 29
2756: IFFALSE 2774
// tmp := tmp ^ Cornel ;
2758: LD_ADDR_VAR 0 5
2762: PUSH
2763: LD_VAR 0 5
2767: PUSH
2768: LD_EXP 29
2772: ADD
2773: ST_TO_ADDR
// end ; if not Houten then
2774: LD_EXP 28
2778: NOT
2779: IFFALSE 2825
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2781: LD_ADDR_EXP 28
2785: PUSH
2786: LD_STRING Houten
2788: PPUSH
2789: LD_EXP 1
2793: NOT
2794: PPUSH
2795: LD_STRING 13a_
2797: PPUSH
2798: CALL 52862 0 3
2802: ST_TO_ADDR
// if Houten then
2803: LD_EXP 28
2807: IFFALSE 2825
// tmp := tmp ^ Houten ;
2809: LD_ADDR_VAR 0 5
2813: PUSH
2814: LD_VAR 0 5
2818: PUSH
2819: LD_EXP 28
2823: ADD
2824: ST_TO_ADDR
// end ; if not Gary then
2825: LD_EXP 30
2829: NOT
2830: IFFALSE 2876
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2832: LD_ADDR_EXP 30
2836: PUSH
2837: LD_STRING Gary
2839: PPUSH
2840: LD_EXP 1
2844: NOT
2845: PPUSH
2846: LD_STRING 13a_
2848: PPUSH
2849: CALL 52862 0 3
2853: ST_TO_ADDR
// if Gary then
2854: LD_EXP 30
2858: IFFALSE 2876
// tmp := tmp ^ Gary ;
2860: LD_ADDR_VAR 0 5
2864: PUSH
2865: LD_VAR 0 5
2869: PUSH
2870: LD_EXP 30
2874: ADD
2875: ST_TO_ADDR
// end ; if not Kikuchi then
2876: LD_EXP 32
2880: NOT
2881: IFFALSE 2927
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2883: LD_ADDR_EXP 32
2887: PUSH
2888: LD_STRING Kikuchi
2890: PPUSH
2891: LD_EXP 1
2895: NOT
2896: PPUSH
2897: LD_STRING 13a_
2899: PPUSH
2900: CALL 52862 0 3
2904: ST_TO_ADDR
// if Kikuchi then
2905: LD_EXP 32
2909: IFFALSE 2927
// tmp := tmp ^ Kikuchi ;
2911: LD_ADDR_VAR 0 5
2915: PUSH
2916: LD_VAR 0 5
2920: PUSH
2921: LD_EXP 32
2925: ADD
2926: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2927: LD_ADDR_VAR 0 5
2931: PUSH
2932: LD_VAR 0 5
2936: PUSH
2937: LD_STRING 13a_others
2939: PPUSH
2940: CALL_OW 31
2944: UNION
2945: ST_TO_ADDR
// tmp := tmp diff 0 ;
2946: LD_ADDR_VAR 0 5
2950: PUSH
2951: LD_VAR 0 5
2955: PUSH
2956: LD_INT 0
2958: DIFF
2959: ST_TO_ADDR
// if tmp < 15 then
2960: LD_VAR 0 5
2964: PUSH
2965: LD_INT 15
2967: LESS
2968: IFFALSE 3056
// for i = 15 downto tmp do
2970: LD_ADDR_VAR 0 2
2974: PUSH
2975: DOUBLE
2976: LD_INT 15
2978: INC
2979: ST_TO_ADDR
2980: LD_VAR 0 5
2984: PUSH
2985: FOR_DOWNTO
2986: IFFALSE 3054
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2988: LD_ADDR_OWVAR 21
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 3
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: PUSH
3003: LD_INT 1
3005: PPUSH
3006: LD_INT 2
3008: PPUSH
3009: CALL_OW 12
3013: ARRAY
3014: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3015: LD_INT 0
3017: PPUSH
3018: LD_INT 1
3020: PPUSH
3021: LD_INT 4
3023: PPUSH
3024: CALL_OW 12
3028: PPUSH
3029: LD_INT 8
3031: PPUSH
3032: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3036: LD_ADDR_VAR 0 5
3040: PUSH
3041: LD_VAR 0 5
3045: PUSH
3046: CALL_OW 44
3050: ADD
3051: ST_TO_ADDR
// end ;
3052: GO 2985
3054: POP
3055: POP
// if not debug then
3056: LD_EXP 1
3060: NOT
3061: IFFALSE 3241
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3063: LD_ADDR_VAR 0 4
3067: PUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_INT 14
3073: PUSH
3074: LD_INT 13
3076: PUSH
3077: LD_INT 12
3079: PUSH
3080: LD_INT 11
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: LD_OWVAR 67
3093: ARRAY
3094: PPUSH
3095: LD_INT 14
3097: PUSH
3098: LD_INT 13
3100: PUSH
3101: LD_INT 12
3103: PUSH
3104: LD_INT 11
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: LD_INT -5
3121: PUSH
3122: LD_EXP 19
3126: PUSH
3127: LD_EXP 52
3131: PUSH
3132: LD_EXP 20
3136: PUSH
3137: LD_EXP 34
3141: PUSH
3142: LD_EXP 25
3146: PUSH
3147: LD_EXP 38
3151: PUSH
3152: LD_INT -2
3154: PUSH
3155: LD_INT -3
3157: PUSH
3158: LD_INT -5
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: PUSH
3173: LD_VAR 0 5
3177: ADD
3178: PPUSH
3179: LD_INT 1
3181: PUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 1
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 3
3197: PUSH
3198: LD_INT 5
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 9
3214: PUSH
3215: LD_INT 0
3217: PUSH
3218: LD_INT 3
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: PPUSH
3234: CALL_OW 42
3238: ST_TO_ADDR
3239: GO 3290
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3241: LD_ADDR_VAR 0 4
3245: PUSH
3246: LD_EXP 40
3250: PUSH
3251: LD_EXP 41
3255: PUSH
3256: LD_EXP 42
3260: PUSH
3261: LD_EXP 43
3265: PUSH
3266: LD_EXP 44
3270: PUSH
3271: LD_EXP 45
3275: PUSH
3276: LD_EXP 46
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3290: LD_ADDR_EXP 17
3294: PUSH
3295: LD_VAR 0 5
3299: PUSH
3300: LD_VAR 0 4
3304: DIFF
3305: ST_TO_ADDR
// uc_nation := 1 ;
3306: LD_ADDR_OWVAR 21
3310: PUSH
3311: LD_INT 1
3313: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3314: LD_INT 5
3316: PPUSH
3317: LD_INT 3
3319: PPUSH
3320: LD_INT 1
3322: PPUSH
3323: LD_INT 6
3325: PPUSH
3326: LD_INT 100
3328: PPUSH
3329: CALL 57702 0 5
// veh := CreateVehicle ;
3333: LD_ADDR_VAR 0 3
3337: PUSH
3338: CALL_OW 45
3342: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3343: LD_VAR 0 3
3347: PPUSH
3348: LD_INT 7
3350: NEG
3351: PPUSH
3352: CALL_OW 242
// SetDir ( veh , 3 ) ;
3356: LD_VAR 0 3
3360: PPUSH
3361: LD_INT 3
3363: PPUSH
3364: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3368: LD_VAR 0 3
3372: PPUSH
3373: LD_INT 31
3375: PPUSH
3376: LD_INT 0
3378: PPUSH
3379: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3383: LD_EXP 19
3387: PPUSH
3388: LD_VAR 0 3
3392: PPUSH
3393: CALL_OW 52
// if Joan then
3397: LD_EXP 34
3401: IFFALSE 3473
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3403: LD_INT 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: LD_INT 1
3411: PPUSH
3412: LD_INT 11
3414: PPUSH
3415: LD_INT 100
3417: PPUSH
3418: CALL 57702 0 5
// veh := CreateVehicle ;
3422: LD_ADDR_VAR 0 3
3426: PUSH
3427: CALL_OW 45
3431: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3432: LD_VAR 0 3
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3444: LD_VAR 0 3
3448: PPUSH
3449: LD_INT 30
3451: PPUSH
3452: LD_INT 0
3454: PPUSH
3455: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3459: LD_EXP 34
3463: PPUSH
3464: LD_VAR 0 3
3468: PPUSH
3469: CALL_OW 52
// end ; if Roth then
3473: LD_EXP 20
3477: IFFALSE 3549
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3479: LD_INT 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: LD_INT 11
3490: PPUSH
3491: LD_INT 100
3493: PPUSH
3494: CALL 57702 0 5
// veh := CreateVehicle ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: CALL_OW 45
3507: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3508: LD_VAR 0 3
3512: PPUSH
3513: LD_INT 3
3515: PPUSH
3516: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3520: LD_VAR 0 3
3524: PPUSH
3525: LD_INT 30
3527: PPUSH
3528: LD_INT 0
3530: PPUSH
3531: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3535: LD_EXP 20
3539: PPUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: CALL_OW 52
// end ; if Denis then
3549: LD_EXP 25
3553: IFFALSE 3625
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3555: LD_INT 5
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: LD_INT 1
3563: PPUSH
3564: LD_INT 9
3566: PPUSH
3567: LD_INT 100
3569: PPUSH
3570: CALL 57702 0 5
// veh := CreateVehicle ;
3574: LD_ADDR_VAR 0 3
3578: PUSH
3579: CALL_OW 45
3583: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3584: LD_VAR 0 3
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3596: LD_VAR 0 3
3600: PPUSH
3601: LD_INT 30
3603: PPUSH
3604: LD_INT 0
3606: PPUSH
3607: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3611: LD_EXP 25
3615: PPUSH
3616: LD_VAR 0 3
3620: PPUSH
3621: CALL_OW 52
// end ; uc_nation := 3 ;
3625: LD_ADDR_OWVAR 21
3629: PUSH
3630: LD_INT 3
3632: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3633: LD_INT 22
3635: PPUSH
3636: LD_INT 3
3638: PPUSH
3639: LD_INT 1
3641: PPUSH
3642: LD_INT 45
3644: PPUSH
3645: LD_INT 100
3647: PPUSH
3648: CALL 57702 0 5
// veh := CreateVehicle ;
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: CALL_OW 45
3661: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3662: LD_VAR 0 3
3666: PPUSH
3667: LD_INT 7
3669: NEG
3670: PPUSH
3671: CALL_OW 242
// SetDir ( veh , 3 ) ;
3675: LD_VAR 0 3
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3687: LD_VAR 0 3
3691: PPUSH
3692: LD_INT 31
3694: PPUSH
3695: LD_INT 0
3697: PPUSH
3698: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3702: LD_EXP 52
3706: PPUSH
3707: LD_VAR 0 3
3711: PPUSH
3712: CALL_OW 52
// if Gossudarov then
3716: LD_EXP 38
3720: IFFALSE 3807
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3722: LD_INT 22
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: LD_INT 51
3733: PPUSH
3734: LD_INT 100
3736: PPUSH
3737: CALL 57702 0 5
// veh := CreateVehicle ;
3741: LD_ADDR_VAR 0 3
3745: PUSH
3746: CALL_OW 45
3750: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3751: LD_VAR 0 3
3755: PPUSH
3756: LD_INT 3
3758: PPUSH
3759: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3763: LD_VAR 0 3
3767: PPUSH
3768: LD_INT 30
3770: PPUSH
3771: LD_INT 0
3773: PPUSH
3774: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3778: LD_EXP 38
3782: PPUSH
3783: LD_VAR 0 3
3787: PPUSH
3788: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3792: LD_VAR 0 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 100
3802: PPUSH
3803: CALL_OW 290
// end ; if Mike then
3807: LD_EXP 37
3811: IFFALSE 3828
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3813: LD_EXP 37
3817: PPUSH
3818: LD_INT 30
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 49
// for i in selected do
3828: LD_ADDR_VAR 0 2
3832: PUSH
3833: LD_VAR 0 4
3837: PUSH
3838: FOR_IN
3839: IFFALSE 4397
// begin uc_nation := GetNation ( i ) ;
3841: LD_ADDR_OWVAR 21
3845: PUSH
3846: LD_VAR 0 2
3850: PPUSH
3851: CALL_OW 248
3855: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3856: LD_VAR 0 2
3860: PUSH
3861: LD_EXP 21
3865: PUSH
3866: LD_EXP 22
3870: PUSH
3871: LD_EXP 24
3875: PUSH
3876: LD_EXP 23
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: LIST
3885: LIST
3886: IN
3887: IFFALSE 3910
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3889: LD_INT 5
3891: PPUSH
3892: LD_INT 3
3894: PPUSH
3895: LD_INT 1
3897: PPUSH
3898: LD_INT 6
3900: PPUSH
3901: LD_INT 100
3903: PPUSH
3904: CALL 57702 0 5
3908: GO 4344
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3910: LD_VAR 0 2
3914: PUSH
3915: LD_EXP 45
3919: PUSH
3920: LD_EXP 50
3924: PUSH
3925: LD_EXP 48
3929: PUSH
3930: LD_EXP 40
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: IN
3941: IFFALSE 3972
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3943: LD_INT 24
3945: PPUSH
3946: LD_INT 1
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: LD_INT 46
3954: PPUSH
3955: LD_INT 65
3957: PPUSH
3958: LD_INT 75
3960: PPUSH
3961: CALL_OW 12
3965: PPUSH
3966: CALL 57702 0 5
3970: GO 4344
// if i = Karamazov then
3972: LD_VAR 0 2
3976: PUSH
3977: LD_EXP 51
3981: EQUAL
3982: IFFALSE 4005
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3984: LD_INT 22
3986: PPUSH
3987: LD_INT 3
3989: PPUSH
3990: LD_INT 1
3992: PPUSH
3993: LD_INT 52
3995: PPUSH
3996: LD_INT 100
3998: PPUSH
3999: CALL 57702 0 5
4003: GO 4344
// if i = Brown then
4005: LD_VAR 0 2
4009: PUSH
4010: LD_EXP 26
4014: EQUAL
4015: IFFALSE 4038
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4017: LD_INT 3
4019: PPUSH
4020: LD_INT 3
4022: PPUSH
4023: LD_INT 1
4025: PPUSH
4026: LD_INT 13
4028: PPUSH
4029: LD_INT 100
4031: PPUSH
4032: CALL 57702 0 5
4036: GO 4344
// if uc_nation = nation_american then
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 1
4045: EQUAL
4046: IFFALSE 4197
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4048: LD_INT 3
4050: PUSH
4051: LD_INT 5
4053: PUSH
4054: LD_INT 5
4056: PUSH
4057: EMPTY
4058: LIST
4059: LIST
4060: LIST
4061: PUSH
4062: LD_OWVAR 21
4066: PUSH
4067: LD_INT 3
4069: MOD
4070: PUSH
4071: LD_INT 1
4073: PLUS
4074: ARRAY
4075: PPUSH
4076: LD_INT 1
4078: PUSH
4079: LD_INT 3
4081: PUSH
4082: LD_INT 1
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PUSH
4090: LD_OWVAR 21
4094: PUSH
4095: LD_INT 3
4097: MOD
4098: PUSH
4099: LD_INT 1
4101: PLUS
4102: ARRAY
4103: PPUSH
4104: LD_INT 1
4106: PPUSH
4107: LD_INT 11
4109: PUSH
4110: LD_INT 4
4112: PUSH
4113: LD_INT 5
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PUSH
4121: LD_INT 6
4123: PUSH
4124: LD_INT 7
4126: PUSH
4127: LD_INT 9
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: PUSH
4135: LD_INT 6
4137: PUSH
4138: LD_INT 9
4140: PUSH
4141: LD_INT 12
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: LIST
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: LD_OWVAR 21
4158: PUSH
4159: LD_INT 3
4161: MOD
4162: PUSH
4163: LD_INT 1
4165: PLUS
4166: ARRAY
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 3
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 65
4182: PPUSH
4183: LD_INT 75
4185: PPUSH
4186: CALL_OW 12
4190: PPUSH
4191: CALL 57702 0 5
// end else
4195: GO 4344
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4197: LD_INT 22
4199: PUSH
4200: LD_INT 23
4202: PUSH
4203: LD_INT 23
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: LIST
4210: PUSH
4211: LD_OWVAR 21
4215: PUSH
4216: LD_INT 3
4218: MOD
4219: PUSH
4220: LD_INT 1
4222: PLUS
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PUSH
4228: LD_INT 3
4230: PUSH
4231: LD_INT 1
4233: PUSH
4234: EMPTY
4235: LIST
4236: LIST
4237: LIST
4238: PUSH
4239: LD_OWVAR 21
4243: PUSH
4244: LD_INT 3
4246: MOD
4247: PUSH
4248: LD_INT 1
4250: PLUS
4251: ARRAY
4252: PPUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 43
4261: PUSH
4262: LD_INT 44
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 46
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 44
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 46
4286: PUSH
4287: LD_INT 43
4289: PUSH
4290: LD_INT 45
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: LIST
4302: PUSH
4303: LD_OWVAR 21
4307: PUSH
4308: LD_INT 3
4310: MOD
4311: PUSH
4312: LD_INT 1
4314: PLUS
4315: ARRAY
4316: PUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 3
4322: PPUSH
4323: CALL_OW 12
4327: ARRAY
4328: PPUSH
4329: LD_INT 65
4331: PPUSH
4332: LD_INT 75
4334: PPUSH
4335: CALL_OW 12
4339: PPUSH
4340: CALL 57702 0 5
// end ; veh := CreateVehicle ;
4344: LD_ADDR_VAR 0 3
4348: PUSH
4349: CALL_OW 45
4353: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4354: LD_VAR 0 3
4358: PPUSH
4359: LD_INT 3
4361: PPUSH
4362: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4366: LD_VAR 0 3
4370: PPUSH
4371: LD_INT 30
4373: PPUSH
4374: LD_INT 0
4376: PPUSH
4377: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4381: LD_VAR 0 2
4385: PPUSH
4386: LD_VAR 0 3
4390: PPUSH
4391: CALL_OW 52
// end ;
4395: GO 3838
4397: POP
4398: POP
// if artifactArCaptured then
4399: LD_EXP 9
4403: IFFALSE 4489
// begin uc_nation := nation_american ;
4405: LD_ADDR_OWVAR 21
4409: PUSH
4410: LD_INT 1
4412: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4413: LD_INT 3
4415: PPUSH
4416: LD_INT 3
4418: PPUSH
4419: LD_INT 3
4421: PPUSH
4422: LD_INT 12
4424: PPUSH
4425: LD_INT 100
4427: PPUSH
4428: CALL 57702 0 5
// veh := CreateVehicle ;
4432: LD_ADDR_VAR 0 3
4436: PUSH
4437: CALL_OW 45
4441: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4442: LD_VAR 0 3
4446: PPUSH
4447: LD_INT 3
4449: PPUSH
4450: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4454: LD_VAR 0 3
4458: PPUSH
4459: LD_INT 198
4461: PPUSH
4462: LD_INT 22
4464: PPUSH
4465: LD_INT 0
4467: PPUSH
4468: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 4
4479: PPUSH
4480: LD_INT 50
4482: PPUSH
4483: CALL_OW 290
// end else
4487: GO 4508
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4489: LD_INT 4
4491: PPUSH
4492: LD_INT 5
4494: PPUSH
4495: LD_INT 267
4497: PPUSH
4498: LD_INT 226
4500: PPUSH
4501: LD_INT 0
4503: PPUSH
4504: CALL_OW 58
// end ; uc_nation := nation_american ;
4508: LD_ADDR_OWVAR 21
4512: PUSH
4513: LD_INT 1
4515: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4516: LD_INT 3
4518: PPUSH
4519: LD_INT 3
4521: PPUSH
4522: LD_INT 3
4524: PPUSH
4525: LD_INT 12
4527: PPUSH
4528: LD_INT 100
4530: PPUSH
4531: CALL 57702 0 5
// veh := CreateVehicle ;
4535: LD_ADDR_VAR 0 3
4539: PUSH
4540: CALL_OW 45
4544: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4545: LD_VAR 0 3
4549: PPUSH
4550: LD_INT 3
4552: PPUSH
4553: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4557: LD_VAR 0 3
4561: PPUSH
4562: LD_INT 218
4564: PPUSH
4565: LD_INT 23
4567: PPUSH
4568: LD_INT 0
4570: PPUSH
4571: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 4
4582: PPUSH
4583: LD_INT 30
4585: PPUSH
4586: CALL_OW 290
// uc_nation := nation_russian ;
4590: LD_ADDR_OWVAR 21
4594: PUSH
4595: LD_INT 3
4597: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4598: LD_INT 22
4600: PPUSH
4601: LD_INT 3
4603: PPUSH
4604: LD_INT 3
4606: PPUSH
4607: LD_INT 51
4609: PPUSH
4610: LD_INT 100
4612: PPUSH
4613: CALL 57702 0 5
// veh := CreateVehicle ;
4617: LD_ADDR_VAR 0 3
4621: PUSH
4622: CALL_OW 45
4626: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4627: LD_VAR 0 3
4631: PPUSH
4632: LD_INT 3
4634: PPUSH
4635: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4639: LD_VAR 0 3
4643: PPUSH
4644: LD_INT 214
4646: PPUSH
4647: LD_INT 20
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4657: LD_VAR 0 3
4661: PPUSH
4662: LD_INT 4
4664: PPUSH
4665: LD_INT 40
4667: PPUSH
4668: CALL_OW 290
// end ;
4672: LD_VAR 0 1
4676: RET
// export function AllianceSupport ; var i , veh ; begin
4677: LD_INT 0
4679: PPUSH
4680: PPUSH
4681: PPUSH
// if not allianceTeam then
4682: LD_EXP 17
4686: NOT
4687: IFFALSE 4691
// exit ;
4689: GO 5097
// for i := 1 to 6 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 6
4703: PUSH
4704: FOR_TO
4705: IFFALSE 5001
// begin uc_side := 7 ;
4707: LD_ADDR_OWVAR 20
4711: PUSH
4712: LD_INT 7
4714: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4715: LD_ADDR_OWVAR 21
4719: PUSH
4720: LD_INT 1
4722: PUSH
4723: LD_INT 3
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_VAR 0 2
4734: PUSH
4735: LD_INT 2
4737: MOD
4738: PUSH
4739: LD_INT 1
4741: PLUS
4742: ARRAY
4743: ST_TO_ADDR
// if uc_nation = 1 then
4744: LD_OWVAR 21
4748: PUSH
4749: LD_INT 1
4751: EQUAL
4752: IFFALSE 4794
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4754: LD_INT 5
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 1
4762: PPUSH
4763: LD_INT 6
4765: PUSH
4766: LD_INT 7
4768: PUSH
4769: EMPTY
4770: LIST
4771: LIST
4772: PUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 2
4778: PPUSH
4779: CALL_OW 12
4783: ARRAY
4784: PPUSH
4785: LD_INT 100
4787: PPUSH
4788: CALL 57702 0 5
4792: GO 4832
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4794: LD_INT 23
4796: PPUSH
4797: LD_INT 3
4799: PPUSH
4800: LD_INT 1
4802: PPUSH
4803: LD_INT 46
4805: PUSH
4806: LD_INT 47
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: PUSH
4813: LD_INT 1
4815: PPUSH
4816: LD_INT 2
4818: PPUSH
4819: CALL_OW 12
4823: ARRAY
4824: PPUSH
4825: LD_INT 100
4827: PPUSH
4828: CALL 57702 0 5
// if not allianceTeam then
4832: LD_EXP 17
4836: NOT
4837: IFFALSE 4841
// break ;
4839: GO 5001
// veh := CreateVehicle ;
4841: LD_ADDR_VAR 0 3
4845: PUSH
4846: CALL_OW 45
4850: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4851: LD_VAR 0 3
4855: PPUSH
4856: LD_INT 4
4858: PPUSH
4859: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4863: LD_VAR 0 3
4867: PPUSH
4868: LD_INT 38
4870: PPUSH
4871: LD_INT 0
4873: PPUSH
4874: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4878: LD_EXP 17
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: LD_INT 3
4889: PPUSH
4890: CALL_OW 259
4894: PUSH
4895: LD_INT 4
4897: GREATER
4898: IFFALSE 4916
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4900: LD_EXP 17
4904: PUSH
4905: LD_INT 1
4907: ARRAY
4908: PPUSH
4909: LD_INT 3
4911: PPUSH
4912: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4916: LD_EXP 17
4920: PUSH
4921: LD_INT 1
4923: ARRAY
4924: PPUSH
4925: LD_INT 4
4927: PPUSH
4928: CALL_OW 259
4932: PUSH
4933: LD_INT 8
4935: GREATER
4936: IFFALSE 4954
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4938: LD_EXP 17
4942: PUSH
4943: LD_INT 1
4945: ARRAY
4946: PPUSH
4947: LD_INT 4
4949: PPUSH
4950: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4954: LD_EXP 17
4958: PUSH
4959: LD_INT 1
4961: ARRAY
4962: PPUSH
4963: LD_VAR 0 3
4967: PPUSH
4968: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4972: LD_ADDR_EXP 17
4976: PUSH
4977: LD_EXP 17
4981: PPUSH
4982: LD_INT 1
4984: PPUSH
4985: CALL_OW 3
4989: ST_TO_ADDR
// ComHold ( veh ) ;
4990: LD_VAR 0 3
4994: PPUSH
4995: CALL_OW 140
// end ;
4999: GO 4704
5001: POP
5002: POP
// uc_side := 7 ;
5003: LD_ADDR_OWVAR 20
5007: PUSH
5008: LD_INT 7
5010: ST_TO_ADDR
// uc_nation := 1 ;
5011: LD_ADDR_OWVAR 21
5015: PUSH
5016: LD_INT 1
5018: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5019: LD_INT 5
5021: PPUSH
5022: LD_INT 3
5024: PPUSH
5025: LD_INT 3
5027: PPUSH
5028: LD_INT 11
5030: PPUSH
5031: LD_INT 100
5033: PPUSH
5034: CALL 57702 0 5
// veh := CreateVehicle ;
5038: LD_ADDR_VAR 0 3
5042: PUSH
5043: CALL_OW 45
5047: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5048: LD_VAR 0 3
5052: PPUSH
5053: LD_INT 4
5055: PPUSH
5056: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5060: LD_VAR 0 3
5064: PPUSH
5065: LD_INT 305
5067: PPUSH
5068: LD_INT 218
5070: PPUSH
5071: LD_INT 0
5073: PPUSH
5074: CALL_OW 48
// ComHold ( veh ) ;
5078: LD_VAR 0 3
5082: PPUSH
5083: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5087: LD_INT 313
5089: PPUSH
5090: LD_INT 220
5092: PPUSH
5093: CALL_OW 86
// end ; end_of_file
5097: LD_VAR 0 1
5101: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5102: LD_INT 0
5104: PPUSH
5105: PPUSH
5106: PPUSH
5107: PPUSH
5108: PPUSH
5109: PPUSH
5110: PPUSH
5111: PPUSH
5112: PPUSH
5113: PPUSH
5114: PPUSH
// InitHc ;
5115: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5119: LD_INT 387
5121: PPUSH
5122: LD_STRING sigma
5124: PPUSH
5125: CALL_OW 500
// uc_side := 1 ;
5129: LD_ADDR_OWVAR 20
5133: PUSH
5134: LD_INT 1
5136: ST_TO_ADDR
// uc_nation := 1 ;
5137: LD_ADDR_OWVAR 21
5141: PUSH
5142: LD_INT 1
5144: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5145: LD_ADDR_VAR 0 2
5149: PUSH
5150: LD_INT 22
5152: PUSH
5153: LD_INT 1
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 21
5162: PUSH
5163: LD_INT 3
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: PUSH
5179: FOR_IN
5180: IFFALSE 5196
// SetBLevel ( i , 10 ) ;
5182: LD_VAR 0 2
5186: PPUSH
5187: LD_INT 10
5189: PPUSH
5190: CALL_OW 241
5194: GO 5179
5196: POP
5197: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5198: LD_INT 387
5200: PPUSH
5201: CALL_OW 274
5205: PPUSH
5206: LD_INT 1
5208: PPUSH
5209: LD_INT 7500
5211: PPUSH
5212: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5216: LD_INT 387
5218: PPUSH
5219: CALL_OW 274
5223: PPUSH
5224: LD_INT 2
5226: PPUSH
5227: LD_INT 4000
5229: PPUSH
5230: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5234: LD_INT 387
5236: PPUSH
5237: CALL_OW 274
5241: PPUSH
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 50
5247: PPUSH
5248: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5252: LD_INT 476
5254: PPUSH
5255: CALL_OW 274
5259: PPUSH
5260: LD_INT 1
5262: PPUSH
5263: LD_INT 5500
5265: PPUSH
5266: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5270: LD_INT 476
5272: PPUSH
5273: CALL_OW 274
5277: PPUSH
5278: LD_INT 2
5280: PPUSH
5281: LD_INT 4000
5283: PPUSH
5284: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5288: LD_INT 476
5290: PPUSH
5291: CALL_OW 274
5295: PPUSH
5296: LD_INT 3
5298: PPUSH
5299: LD_INT 10
5301: PPUSH
5302: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5306: LD_ADDR_EXP 55
5310: PUSH
5311: LD_STRING Powell
5313: PPUSH
5314: CALL_OW 25
5318: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5319: LD_EXP 55
5323: PPUSH
5324: LD_INT 387
5326: PPUSH
5327: CALL_OW 52
// tmp := [ ] ;
5331: LD_ADDR_VAR 0 7
5335: PUSH
5336: EMPTY
5337: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5338: LD_ADDR_EXP 21
5342: PUSH
5343: LD_STRING Lisa
5345: PPUSH
5346: LD_EXP 1
5350: NOT
5351: PPUSH
5352: LD_STRING 12p_
5354: PPUSH
5355: CALL 52862 0 3
5359: ST_TO_ADDR
// if Lisa then
5360: LD_EXP 21
5364: IFFALSE 5382
// tmp := tmp ^ Lisa ;
5366: LD_ADDR_VAR 0 7
5370: PUSH
5371: LD_VAR 0 7
5375: PUSH
5376: LD_EXP 21
5380: ADD
5381: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5382: LD_ADDR_EXP 22
5386: PUSH
5387: LD_STRING Donaldson
5389: PPUSH
5390: LD_EXP 1
5394: NOT
5395: PPUSH
5396: LD_STRING 12p_
5398: PPUSH
5399: CALL 52862 0 3
5403: ST_TO_ADDR
// if Donaldson then
5404: LD_EXP 22
5408: IFFALSE 5426
// tmp := tmp ^ Donaldson ;
5410: LD_ADDR_VAR 0 7
5414: PUSH
5415: LD_VAR 0 7
5419: PUSH
5420: LD_EXP 22
5424: ADD
5425: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5426: LD_ADDR_EXP 23
5430: PUSH
5431: LD_STRING Bobby
5433: PPUSH
5434: LD_EXP 1
5438: NOT
5439: PPUSH
5440: LD_STRING 12p_
5442: PPUSH
5443: CALL 52862 0 3
5447: ST_TO_ADDR
// if Bobby then
5448: LD_EXP 23
5452: IFFALSE 5470
// tmp := tmp ^ Bobby ;
5454: LD_ADDR_VAR 0 7
5458: PUSH
5459: LD_VAR 0 7
5463: PUSH
5464: LD_EXP 23
5468: ADD
5469: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5470: LD_ADDR_EXP 24
5474: PUSH
5475: LD_STRING Cyrus
5477: PPUSH
5478: LD_EXP 1
5482: NOT
5483: PPUSH
5484: LD_STRING 12p_
5486: PPUSH
5487: CALL 52862 0 3
5491: ST_TO_ADDR
// if Cyrus then
5492: LD_EXP 24
5496: IFFALSE 5514
// tmp := tmp ^ Cyrus ;
5498: LD_ADDR_VAR 0 7
5502: PUSH
5503: LD_VAR 0 7
5507: PUSH
5508: LD_EXP 24
5512: ADD
5513: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5514: LD_ADDR_EXP 26
5518: PUSH
5519: LD_STRING Brown
5521: PPUSH
5522: LD_EXP 1
5526: NOT
5527: PPUSH
5528: LD_STRING 12p_
5530: PPUSH
5531: CALL 52862 0 3
5535: ST_TO_ADDR
// if Brown then
5536: LD_EXP 26
5540: IFFALSE 5558
// tmp := tmp ^ Brown ;
5542: LD_ADDR_VAR 0 7
5546: PUSH
5547: LD_VAR 0 7
5551: PUSH
5552: LD_EXP 26
5556: ADD
5557: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5558: LD_ADDR_EXP 27
5562: PUSH
5563: LD_STRING Gladstone
5565: PPUSH
5566: LD_EXP 1
5570: NOT
5571: PPUSH
5572: LD_STRING 12p_
5574: PPUSH
5575: CALL 52862 0 3
5579: ST_TO_ADDR
// if Gladstone then
5580: LD_EXP 27
5584: IFFALSE 5602
// tmp := tmp ^ Gladstone ;
5586: LD_ADDR_VAR 0 7
5590: PUSH
5591: LD_VAR 0 7
5595: PUSH
5596: LD_EXP 27
5600: ADD
5601: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5602: LD_ADDR_EXP 28
5606: PUSH
5607: LD_STRING Houten
5609: PPUSH
5610: LD_EXP 1
5614: NOT
5615: PPUSH
5616: LD_STRING 12p_
5618: PPUSH
5619: CALL 52862 0 3
5623: ST_TO_ADDR
// if Houten then
5624: LD_EXP 28
5628: IFFALSE 5646
// tmp := tmp ^ Houten ;
5630: LD_ADDR_VAR 0 7
5634: PUSH
5635: LD_VAR 0 7
5639: PUSH
5640: LD_EXP 28
5644: ADD
5645: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5646: LD_ADDR_EXP 29
5650: PUSH
5651: LD_STRING Cornel
5653: PPUSH
5654: LD_EXP 1
5658: NOT
5659: PPUSH
5660: LD_STRING 12p_
5662: PPUSH
5663: CALL 52862 0 3
5667: ST_TO_ADDR
// if Cornel then
5668: LD_EXP 29
5672: IFFALSE 5690
// tmp := tmp ^ Cornel ;
5674: LD_ADDR_VAR 0 7
5678: PUSH
5679: LD_VAR 0 7
5683: PUSH
5684: LD_EXP 29
5688: ADD
5689: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5690: LD_ADDR_EXP 30
5694: PUSH
5695: LD_STRING Gary
5697: PPUSH
5698: LD_EXP 1
5702: NOT
5703: PPUSH
5704: LD_STRING 12p_
5706: PPUSH
5707: CALL 52862 0 3
5711: ST_TO_ADDR
// if Gary then
5712: LD_EXP 30
5716: IFFALSE 5734
// tmp := tmp ^ Gary ;
5718: LD_ADDR_VAR 0 7
5722: PUSH
5723: LD_VAR 0 7
5727: PUSH
5728: LD_EXP 30
5732: ADD
5733: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5734: LD_ADDR_EXP 32
5738: PUSH
5739: LD_STRING Kikuchi
5741: PPUSH
5742: LD_EXP 1
5746: NOT
5747: PPUSH
5748: LD_STRING 12p_
5750: PPUSH
5751: CALL 52862 0 3
5755: ST_TO_ADDR
// if Kikuchi then
5756: LD_EXP 32
5760: IFFALSE 5778
// tmp := tmp ^ Kikuchi ;
5762: LD_ADDR_VAR 0 7
5766: PUSH
5767: LD_VAR 0 7
5771: PUSH
5772: LD_EXP 32
5776: ADD
5777: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5778: LD_ADDR_VAR 0 7
5782: PUSH
5783: LD_VAR 0 7
5787: PUSH
5788: LD_STRING 12p_others
5790: PPUSH
5791: CALL_OW 31
5795: UNION
5796: ST_TO_ADDR
// if tmp < 36 then
5797: LD_VAR 0 7
5801: PUSH
5802: LD_INT 36
5804: LESS
5805: IFFALSE 5872
// for i = 1 to 36 - tmp do
5807: LD_ADDR_VAR 0 2
5811: PUSH
5812: DOUBLE
5813: LD_INT 1
5815: DEC
5816: ST_TO_ADDR
5817: LD_INT 36
5819: PUSH
5820: LD_VAR 0 7
5824: MINUS
5825: PUSH
5826: FOR_TO
5827: IFFALSE 5870
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5829: LD_INT 1
5831: PPUSH
5832: LD_VAR 0 2
5836: PUSH
5837: LD_INT 4
5839: MOD
5840: PUSH
5841: LD_INT 1
5843: PLUS
5844: PPUSH
5845: LD_INT 10
5847: PPUSH
5848: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5852: LD_ADDR_VAR 0 7
5856: PUSH
5857: LD_VAR 0 7
5861: PUSH
5862: CALL_OW 44
5866: ADD
5867: ST_TO_ADDR
// end ;
5868: GO 5826
5870: POP
5871: POP
// p := 0 ;
5872: LD_ADDR_VAR 0 6
5876: PUSH
5877: LD_INT 0
5879: ST_TO_ADDR
// for i in tmp do
5880: LD_ADDR_VAR 0 2
5884: PUSH
5885: LD_VAR 0 7
5889: PUSH
5890: FOR_IN
5891: IFFALSE 5943
// begin p := Inc ( p ) ;
5893: LD_ADDR_VAR 0 6
5897: PUSH
5898: LD_VAR 0 6
5902: PPUSH
5903: CALL 91544 0 1
5907: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5908: LD_VAR 0 2
5912: PPUSH
5913: LD_INT 62
5915: PPUSH
5916: LD_INT 93
5918: PPUSH
5919: LD_INT 9
5921: PPUSH
5922: LD_INT 0
5924: PPUSH
5925: CALL_OW 50
// if p > 36 then
5929: LD_VAR 0 6
5933: PUSH
5934: LD_INT 36
5936: GREATER
5937: IFFALSE 5941
// break ;
5939: GO 5943
// end ;
5941: GO 5890
5943: POP
5944: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5945: LD_ADDR_EXP 78
5949: PUSH
5950: LD_EXP 78
5954: PPUSH
5955: LD_INT 4
5957: PPUSH
5958: LD_INT 22
5960: PUSH
5961: LD_INT 1
5963: PUSH
5964: EMPTY
5965: LIST
5966: LIST
5967: PPUSH
5968: CALL_OW 69
5972: PUSH
5973: LD_EXP 55
5977: DIFF
5978: PPUSH
5979: CALL_OW 1
5983: ST_TO_ADDR
// uc_side := 0 ;
5984: LD_ADDR_OWVAR 20
5988: PUSH
5989: LD_INT 0
5991: ST_TO_ADDR
// uc_nation := 0 ;
5992: LD_ADDR_OWVAR 21
5996: PUSH
5997: LD_INT 0
5999: ST_TO_ADDR
// for i = 1 to 4 do
6000: LD_ADDR_VAR 0 2
6004: PUSH
6005: DOUBLE
6006: LD_INT 1
6008: DEC
6009: ST_TO_ADDR
6010: LD_INT 4
6012: PUSH
6013: FOR_TO
6014: IFFALSE 6045
// begin InitHc ;
6016: CALL_OW 19
// hc_class := class_apeman ;
6020: LD_ADDR_OWVAR 28
6024: PUSH
6025: LD_INT 12
6027: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6028: CALL_OW 44
6032: PPUSH
6033: LD_INT 11
6035: PPUSH
6036: LD_INT 0
6038: PPUSH
6039: CALL_OW 49
// end ;
6043: GO 6013
6045: POP
6046: POP
// end ;
6047: LD_VAR 0 1
6051: RET
// every 9 9$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6052: LD_EXP 4
6056: NOT
6057: IFFALSE 6863
6059: GO 6061
6061: DISABLE
6062: LD_INT 0
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
// begin enable ;
6068: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6069: LD_INT 22
6071: PUSH
6072: LD_INT 1
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: PUSH
6079: LD_INT 23
6081: PUSH
6082: LD_INT 1
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: PUSH
6089: LD_INT 30
6091: PUSH
6092: LD_INT 3
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: LIST
6103: PPUSH
6104: CALL_OW 69
6108: NOT
6109: IFFALSE 6113
// exit ;
6111: GO 6863
// if Prob ( 40 ) then
6113: LD_INT 40
6115: PPUSH
6116: CALL_OW 13
6120: IFFALSE 6247
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6122: LD_INT 4
6124: PPUSH
6125: LD_INT 5
6127: PUSH
6128: LD_INT 1
6130: PUSH
6131: LD_INT 2
6133: PUSH
6134: LD_INT 7
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: LIST
6141: LIST
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: LD_INT 1
6148: PUSH
6149: LD_INT 2
6151: PUSH
6152: LD_INT 7
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: LIST
6159: LIST
6160: PUSH
6161: LD_INT 5
6163: PUSH
6164: LD_INT 1
6166: PUSH
6167: LD_INT 2
6169: PUSH
6170: LD_INT 7
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 5
6181: PUSH
6182: LD_INT 1
6184: PUSH
6185: LD_INT 2
6187: PUSH
6188: LD_INT 6
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 5
6199: PUSH
6200: LD_INT 1
6202: PUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 6
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 5
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: LD_INT 2
6223: PUSH
6224: LD_INT 6
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: LIST
6240: PPUSH
6241: CALL 46436 0 2
// end else
6245: GO 6370
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6247: LD_INT 4
6249: PPUSH
6250: LD_INT 5
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: LD_INT 2
6258: PUSH
6259: LD_INT 7
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PUSH
6268: LD_INT 5
6270: PUSH
6271: LD_INT 1
6273: PUSH
6274: LD_INT 2
6276: PUSH
6277: LD_INT 9
6279: PUSH
6280: EMPTY
6281: LIST
6282: LIST
6283: LIST
6284: LIST
6285: PUSH
6286: LD_INT 5
6288: PUSH
6289: LD_INT 1
6291: PUSH
6292: LD_INT 2
6294: PUSH
6295: LD_INT 9
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 5
6306: PUSH
6307: LD_INT 1
6309: PUSH
6310: LD_INT 2
6312: PUSH
6313: LD_INT 6
6315: PUSH
6316: EMPTY
6317: LIST
6318: LIST
6319: LIST
6320: LIST
6321: PUSH
6322: LD_INT 5
6324: PUSH
6325: LD_INT 1
6327: PUSH
6328: LD_INT 2
6330: PUSH
6331: LD_INT 6
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: PUSH
6340: LD_INT 5
6342: PUSH
6343: LD_INT 1
6345: PUSH
6346: LD_INT 2
6348: PUSH
6349: LD_INT 6
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: LIST
6356: LIST
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: PPUSH
6366: CALL 46436 0 2
// end ; p := 0 ;
6370: LD_ADDR_VAR 0 4
6374: PUSH
6375: LD_INT 0
6377: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6378: LD_INT 35
6380: PPUSH
6381: CALL_OW 67
// p := Inc ( p ) ;
6385: LD_ADDR_VAR 0 4
6389: PUSH
6390: LD_VAR 0 4
6394: PPUSH
6395: CALL 91544 0 1
6399: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6400: LD_INT 4
6402: PPUSH
6403: LD_INT 1
6405: PPUSH
6406: CALL 47854 0 2
6410: PUSH
6411: LD_INT 6
6413: GREATEREQUAL
6414: PUSH
6415: LD_VAR 0 4
6419: PUSH
6420: LD_INT 100
6422: GREATER
6423: OR
6424: IFFALSE 6378
// wait ( 0 0$30 ) ;
6426: LD_INT 1050
6428: PPUSH
6429: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6433: LD_ADDR_VAR 0 2
6437: PUSH
6438: LD_INT 4
6440: PPUSH
6441: LD_INT 1
6443: PPUSH
6444: CALL 47854 0 2
6448: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6449: LD_ADDR_EXP 97
6453: PUSH
6454: LD_EXP 97
6458: PPUSH
6459: LD_INT 4
6461: PPUSH
6462: LD_EXP 97
6466: PUSH
6467: LD_INT 4
6469: ARRAY
6470: PUSH
6471: LD_VAR 0 2
6475: DIFF
6476: PPUSH
6477: CALL_OW 1
6481: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6482: LD_ADDR_VAR 0 3
6486: PUSH
6487: LD_INT 0
6489: PPUSH
6490: LD_INT 2
6492: PPUSH
6493: CALL_OW 12
6497: ST_TO_ADDR
// if target then
6498: LD_VAR 0 3
6502: IFFALSE 6630
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6504: LD_ADDR_VAR 0 2
6508: PUSH
6509: LD_VAR 0 2
6513: PPUSH
6514: LD_INT 24
6516: PUSH
6517: LD_INT 250
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: PPUSH
6524: CALL_OW 72
6528: ST_TO_ADDR
// for i in tmp do
6529: LD_ADDR_VAR 0 1
6533: PUSH
6534: LD_VAR 0 2
6538: PUSH
6539: FOR_IN
6540: IFFALSE 6580
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6542: LD_VAR 0 1
6546: PPUSH
6547: LD_INT 114
6549: PPUSH
6550: LD_INT 108
6552: PPUSH
6553: CALL_OW 297
6557: PUSH
6558: LD_INT 9
6560: GREATER
6561: IFFALSE 6578
// ComMoveXY ( i , 114 , 108 ) ;
6563: LD_VAR 0 1
6567: PPUSH
6568: LD_INT 114
6570: PPUSH
6571: LD_INT 108
6573: PPUSH
6574: CALL_OW 111
6578: GO 6539
6580: POP
6581: POP
// wait ( 0 0$1 ) ;
6582: LD_INT 35
6584: PPUSH
6585: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6589: LD_VAR 0 2
6593: PPUSH
6594: LD_INT 92
6596: PUSH
6597: LD_INT 114
6599: PUSH
6600: LD_INT 108
6602: PUSH
6603: LD_INT 9
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: LIST
6611: PPUSH
6612: CALL_OW 72
6616: PUSH
6617: LD_VAR 0 2
6621: PUSH
6622: LD_INT 1
6624: MINUS
6625: GREATEREQUAL
6626: IFFALSE 6504
// end else
6628: GO 6754
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6630: LD_ADDR_VAR 0 2
6634: PUSH
6635: LD_VAR 0 2
6639: PPUSH
6640: LD_INT 24
6642: PUSH
6643: LD_INT 250
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: PPUSH
6650: CALL_OW 72
6654: ST_TO_ADDR
// for i in tmp do
6655: LD_ADDR_VAR 0 1
6659: PUSH
6660: LD_VAR 0 2
6664: PUSH
6665: FOR_IN
6666: IFFALSE 6706
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6668: LD_VAR 0 1
6672: PPUSH
6673: LD_INT 129
6675: PPUSH
6676: LD_INT 139
6678: PPUSH
6679: CALL_OW 297
6683: PUSH
6684: LD_INT 9
6686: GREATER
6687: IFFALSE 6704
// ComMoveXY ( i , 129 , 139 ) ;
6689: LD_VAR 0 1
6693: PPUSH
6694: LD_INT 129
6696: PPUSH
6697: LD_INT 139
6699: PPUSH
6700: CALL_OW 111
6704: GO 6665
6706: POP
6707: POP
// wait ( 0 0$1 ) ;
6708: LD_INT 35
6710: PPUSH
6711: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6715: LD_VAR 0 2
6719: PPUSH
6720: LD_INT 92
6722: PUSH
6723: LD_INT 129
6725: PUSH
6726: LD_INT 139
6728: PUSH
6729: LD_INT 9
6731: PUSH
6732: EMPTY
6733: LIST
6734: LIST
6735: LIST
6736: LIST
6737: PPUSH
6738: CALL_OW 72
6742: PUSH
6743: LD_VAR 0 2
6747: PUSH
6748: LD_INT 1
6750: MINUS
6751: GREATEREQUAL
6752: IFFALSE 6630
// end ; repeat wait ( 0 0$1 ) ;
6754: LD_INT 35
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 1
6765: PUSH
6766: LD_VAR 0 2
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6854
// begin if GetLives ( i ) > 251 then
6774: LD_VAR 0 1
6778: PPUSH
6779: CALL_OW 256
6783: PUSH
6784: LD_INT 251
6786: GREATER
6787: IFFALSE 6825
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6789: LD_VAR 0 1
6793: PPUSH
6794: LD_INT 81
6796: PUSH
6797: LD_INT 1
6799: PUSH
6800: EMPTY
6801: LIST
6802: LIST
6803: PPUSH
6804: CALL_OW 69
6808: PPUSH
6809: LD_VAR 0 1
6813: PPUSH
6814: CALL_OW 74
6818: PPUSH
6819: CALL_OW 115
6823: GO 6852
// if IsDead ( i ) then
6825: LD_VAR 0 1
6829: PPUSH
6830: CALL_OW 301
6834: IFFALSE 6852
// tmp := tmp diff i ;
6836: LD_ADDR_VAR 0 2
6840: PUSH
6841: LD_VAR 0 2
6845: PUSH
6846: LD_VAR 0 1
6850: DIFF
6851: ST_TO_ADDR
// end ;
6852: GO 6771
6854: POP
6855: POP
// until not tmp ;
6856: LD_VAR 0 2
6860: NOT
6861: IFFALSE 6754
// end ;
6863: PPOPN 4
6865: END
// every 30 30$00 trigger not americanDestroyed do
6866: LD_EXP 4
6870: NOT
6871: IFFALSE 6940
6873: GO 6875
6875: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6876: LD_INT 63000
6878: PUSH
6879: LD_INT 42000
6881: PUSH
6882: LD_INT 31500
6884: PUSH
6885: LD_INT 21000
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: LIST
6892: LIST
6893: PUSH
6894: LD_OWVAR 67
6898: ARRAY
6899: PPUSH
6900: CALL_OW 67
// if americanDestroyed then
6904: LD_EXP 4
6908: IFFALSE 6912
// exit ;
6910: GO 6940
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6912: LD_INT 4
6914: PPUSH
6915: LD_INT 5
6917: PUSH
6918: LD_INT 3
6920: PUSH
6921: LD_INT 1
6923: PUSH
6924: LD_INT 8
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: LIST
6931: LIST
6932: PUSH
6933: EMPTY
6934: LIST
6935: PPUSH
6936: CALL 46436 0 2
// end ; end_of_file
6940: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6941: LD_INT 0
6943: PPUSH
6944: PPUSH
6945: PPUSH
6946: PPUSH
6947: PPUSH
// side := 2 ;
6948: LD_ADDR_VAR 0 5
6952: PUSH
6953: LD_INT 2
6955: ST_TO_ADDR
// InitHc ;
6956: CALL_OW 19
// uc_side := side ;
6960: LD_ADDR_OWVAR 20
6964: PUSH
6965: LD_VAR 0 5
6969: ST_TO_ADDR
// uc_nation := 2 ;
6970: LD_ADDR_OWVAR 21
6974: PUSH
6975: LD_INT 2
6977: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6978: LD_ADDR_VAR 0 2
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_INT 2
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 21
6995: PUSH
6996: LD_INT 3
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: PPUSH
7007: CALL_OW 69
7011: PUSH
7012: FOR_IN
7013: IFFALSE 7029
// SetBLevel ( i , 10 ) ;
7015: LD_VAR 0 2
7019: PPUSH
7020: LD_INT 10
7022: PPUSH
7023: CALL_OW 241
7027: GO 7012
7029: POP
7030: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7031: LD_ADDR_VAR 0 4
7035: PUSH
7036: LD_INT 22
7038: PUSH
7039: LD_VAR 0 5
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: LD_INT 30
7050: PUSH
7051: LD_INT 32
7053: PUSH
7054: EMPTY
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 58
7060: PUSH
7061: EMPTY
7062: LIST
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: LIST
7068: PPUSH
7069: CALL_OW 69
7073: ST_TO_ADDR
// for i = 1 to 10 do
7074: LD_ADDR_VAR 0 2
7078: PUSH
7079: DOUBLE
7080: LD_INT 1
7082: DEC
7083: ST_TO_ADDR
7084: LD_INT 10
7086: PUSH
7087: FOR_TO
7088: IFFALSE 7160
// begin uc_nation := nation_nature ;
7090: LD_ADDR_OWVAR 21
7094: PUSH
7095: LD_INT 0
7097: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7098: LD_ADDR_OWVAR 28
7102: PUSH
7103: LD_INT 15
7105: ST_TO_ADDR
// hc_gallery :=  ;
7106: LD_ADDR_OWVAR 33
7110: PUSH
7111: LD_STRING 
7113: ST_TO_ADDR
// hc_name :=  ;
7114: LD_ADDR_OWVAR 26
7118: PUSH
7119: LD_STRING 
7121: ST_TO_ADDR
// un := CreateHuman ;
7122: LD_ADDR_VAR 0 3
7126: PUSH
7127: CALL_OW 44
7131: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7132: LD_VAR 0 3
7136: PPUSH
7137: LD_VAR 0 4
7141: PUSH
7142: LD_VAR 0 4
7146: PUSH
7147: LD_VAR 0 2
7151: MINUS
7152: ARRAY
7153: PPUSH
7154: CALL_OW 52
// end ;
7158: GO 7087
7160: POP
7161: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7162: LD_INT 503
7164: PPUSH
7165: LD_INT 27
7167: PPUSH
7168: LD_STRING 
7170: PPUSH
7171: LD_INT 8
7173: PUSH
7174: LD_INT 9
7176: PUSH
7177: LD_INT 10
7179: PUSH
7180: LD_INT 10
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: LIST
7187: LIST
7188: PUSH
7189: LD_OWVAR 67
7193: ARRAY
7194: PPUSH
7195: LD_INT 3000
7197: PUSH
7198: LD_INT 500
7200: PUSH
7201: LD_INT 150
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: LIST
7208: PPUSH
7209: LD_INT 16
7211: PUSH
7212: LD_INT 6
7214: PUSH
7215: LD_INT 6
7217: PUSH
7218: LD_INT 6
7220: PUSH
7221: EMPTY
7222: LIST
7223: LIST
7224: LIST
7225: LIST
7226: PPUSH
7227: CALL 61155 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7231: LD_ADDR_EXP 78
7235: PUSH
7236: LD_EXP 78
7240: PPUSH
7241: LD_INT 1
7243: PPUSH
7244: LD_INT 22
7246: PUSH
7247: LD_VAR 0 5
7251: PUSH
7252: EMPTY
7253: LIST
7254: LIST
7255: PUSH
7256: LD_INT 23
7258: PUSH
7259: LD_INT 2
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 21
7271: PUSH
7272: LD_INT 2
7274: PUSH
7275: EMPTY
7276: LIST
7277: LIST
7278: PUSH
7279: EMPTY
7280: LIST
7281: LIST
7282: PUSH
7283: EMPTY
7284: LIST
7285: LIST
7286: LIST
7287: PPUSH
7288: CALL_OW 69
7292: PPUSH
7293: CALL_OW 1
7297: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7298: LD_INT 216
7300: PPUSH
7301: LD_INT 228
7303: PPUSH
7304: LD_INT 2
7306: PPUSH
7307: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7311: LD_INT 223
7313: PPUSH
7314: LD_INT 241
7316: PPUSH
7317: LD_INT 2
7319: PPUSH
7320: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7324: LD_INT 216
7326: PPUSH
7327: LD_INT 217
7329: PPUSH
7330: LD_INT 2
7332: PPUSH
7333: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7337: LD_INT 233
7339: PPUSH
7340: LD_INT 257
7342: PPUSH
7343: LD_INT 2
7345: PPUSH
7346: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7350: LD_INT 230
7352: PPUSH
7353: LD_INT 199
7355: PPUSH
7356: LD_INT 2
7358: PPUSH
7359: CALL_OW 244
// end ;
7363: LD_VAR 0 1
7367: RET
// export Omar ; export function PrepareOmarAli ; begin
7368: LD_INT 0
7370: PPUSH
// uc_side := 5 ;
7371: LD_ADDR_OWVAR 20
7375: PUSH
7376: LD_INT 5
7378: ST_TO_ADDR
// uc_nation := 2 ;
7379: LD_ADDR_OWVAR 21
7383: PUSH
7384: LD_INT 2
7386: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7387: LD_ADDR_EXP 56
7391: PUSH
7392: LD_STRING Omar
7394: PPUSH
7395: CALL_OW 25
7399: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7400: LD_EXP 56
7404: PPUSH
7405: LD_INT 330
7407: PPUSH
7408: LD_INT 244
7410: PPUSH
7411: LD_INT 0
7413: PPUSH
7414: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7418: LD_EXP 56
7422: PPUSH
7423: LD_INT 252
7425: PPUSH
7426: LD_INT 220
7428: PPUSH
7429: CALL_OW 111
// end ; end_of_file
7433: LD_VAR 0 1
7437: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7438: LD_INT 0
7440: PPUSH
7441: PPUSH
7442: PPUSH
7443: PPUSH
7444: PPUSH
// side := 8 ;
7445: LD_ADDR_VAR 0 3
7449: PUSH
7450: LD_INT 8
7452: ST_TO_ADDR
// InitHc ;
7453: CALL_OW 19
// uc_side := side ;
7457: LD_ADDR_OWVAR 20
7461: PUSH
7462: LD_VAR 0 3
7466: ST_TO_ADDR
// uc_nation := 2 ;
7467: LD_ADDR_OWVAR 21
7471: PUSH
7472: LD_INT 2
7474: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7475: LD_ADDR_VAR 0 2
7479: PUSH
7480: LD_INT 22
7482: PUSH
7483: LD_VAR 0 3
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PUSH
7492: LD_INT 21
7494: PUSH
7495: LD_INT 3
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PPUSH
7506: CALL_OW 69
7510: PUSH
7511: FOR_IN
7512: IFFALSE 7528
// SetBLevel ( i , 10 ) ;
7514: LD_VAR 0 2
7518: PPUSH
7519: LD_INT 10
7521: PPUSH
7522: CALL_OW 241
7526: GO 7511
7528: POP
7529: POP
// Schulz := NewCharacter ( Schulz ) ;
7530: LD_ADDR_EXP 57
7534: PUSH
7535: LD_STRING Schulz
7537: PPUSH
7538: CALL_OW 25
7542: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7543: LD_ADDR_EXP 59
7547: PUSH
7548: LD_STRING Kaia
7550: PPUSH
7551: CALL_OW 25
7555: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7556: LD_EXP 59
7560: PPUSH
7561: LD_INT 324
7563: PPUSH
7564: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7568: LD_ADDR_EXP 58
7572: PUSH
7573: LD_STRING Kozlov
7575: PPUSH
7576: LD_INT 0
7578: PPUSH
7579: LD_STRING 
7581: PPUSH
7582: CALL 52862 0 3
7586: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7587: LD_EXP 58
7591: PPUSH
7592: LD_INT 22
7594: PUSH
7595: LD_INT 8
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: LD_INT 23
7604: PUSH
7605: LD_INT 3
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 30
7614: PUSH
7615: LD_INT 8
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: LIST
7626: PPUSH
7627: CALL_OW 69
7631: PUSH
7632: LD_INT 1
7634: ARRAY
7635: PPUSH
7636: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7640: LD_EXP 58
7644: PPUSH
7645: LD_INT 3
7647: PPUSH
7648: LD_INT 10
7650: PPUSH
7651: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7655: LD_ADDR_VAR 0 5
7659: PUSH
7660: LD_INT 22
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: LD_INT 30
7674: PUSH
7675: LD_INT 32
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: LD_INT 58
7684: PUSH
7685: EMPTY
7686: LIST
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: PPUSH
7693: CALL_OW 69
7697: ST_TO_ADDR
// for i = 1 to 10 do
7698: LD_ADDR_VAR 0 2
7702: PUSH
7703: DOUBLE
7704: LD_INT 1
7706: DEC
7707: ST_TO_ADDR
7708: LD_INT 10
7710: PUSH
7711: FOR_TO
7712: IFFALSE 7784
// begin uc_nation := nation_nature ;
7714: LD_ADDR_OWVAR 21
7718: PUSH
7719: LD_INT 0
7721: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7722: LD_ADDR_OWVAR 28
7726: PUSH
7727: LD_INT 15
7729: ST_TO_ADDR
// hc_gallery :=  ;
7730: LD_ADDR_OWVAR 33
7734: PUSH
7735: LD_STRING 
7737: ST_TO_ADDR
// hc_name :=  ;
7738: LD_ADDR_OWVAR 26
7742: PUSH
7743: LD_STRING 
7745: ST_TO_ADDR
// un := CreateHuman ;
7746: LD_ADDR_VAR 0 4
7750: PUSH
7751: CALL_OW 44
7755: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7756: LD_VAR 0 4
7760: PPUSH
7761: LD_VAR 0 5
7765: PUSH
7766: LD_VAR 0 5
7770: PUSH
7771: LD_VAR 0 2
7775: MINUS
7776: ARRAY
7777: PPUSH
7778: CALL_OW 52
// end ;
7782: GO 7711
7784: POP
7785: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7786: LD_INT 324
7788: PPUSH
7789: LD_INT 3
7791: PPUSH
7792: LD_STRING 
7794: PPUSH
7795: LD_INT 8
7797: PUSH
7798: LD_INT 9
7800: PUSH
7801: LD_INT 10
7803: PUSH
7804: LD_INT 10
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: LIST
7811: LIST
7812: PUSH
7813: LD_OWVAR 67
7817: ARRAY
7818: PPUSH
7819: LD_INT 3000
7821: PUSH
7822: LD_INT 500
7824: PUSH
7825: LD_INT 150
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: LIST
7832: PPUSH
7833: LD_INT 16
7835: PUSH
7836: LD_INT 6
7838: PUSH
7839: LD_INT 6
7841: PUSH
7842: LD_INT 8
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: LIST
7849: LIST
7850: PPUSH
7851: CALL 61155 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7855: LD_ADDR_EXP 78
7859: PUSH
7860: LD_EXP 78
7864: PPUSH
7865: LD_INT 3
7867: PPUSH
7868: LD_INT 22
7870: PUSH
7871: LD_VAR 0 3
7875: PUSH
7876: EMPTY
7877: LIST
7878: LIST
7879: PUSH
7880: LD_INT 23
7882: PUSH
7883: LD_INT 2
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: PUSH
7890: LD_INT 3
7892: PUSH
7893: LD_INT 21
7895: PUSH
7896: LD_INT 2
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: EMPTY
7908: LIST
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 69
7916: PUSH
7917: LD_EXP 57
7921: DIFF
7922: PPUSH
7923: CALL_OW 1
7927: ST_TO_ADDR
// end ;
7928: LD_VAR 0 1
7932: RET
// export function BuildKozlovBomb ; begin
7933: LD_INT 0
7935: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7936: LD_INT 332
7938: PPUSH
7939: CALL_OW 302
7943: NOT
7944: PUSH
7945: LD_INT 336
7947: PPUSH
7948: CALL_OW 302
7952: NOT
7953: OR
7954: IFFALSE 7958
// exit ;
7956: GO 8055
// ComChangeProfession ( Kozlov , 4 ) ;
7958: LD_EXP 58
7962: PPUSH
7963: LD_INT 4
7965: PPUSH
7966: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7970: LD_INT 336
7972: PPUSH
7973: LD_INT 25
7975: PPUSH
7976: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7980: LD_INT 35
7982: PPUSH
7983: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7987: LD_INT 25
7989: PPUSH
7990: LD_INT 8
7992: PPUSH
7993: CALL_OW 321
7997: PUSH
7998: LD_INT 2
8000: EQUAL
8001: IFFALSE 7980
// ComExitBuilding ( Kozlov ) ;
8003: LD_EXP 58
8007: PPUSH
8008: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8012: LD_EXP 58
8016: PPUSH
8017: LD_INT 332
8019: PPUSH
8020: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8024: LD_EXP 58
8028: PPUSH
8029: LD_INT 3
8031: PPUSH
8032: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8036: LD_INT 332
8038: PPUSH
8039: LD_INT 23
8041: PPUSH
8042: LD_INT 3
8044: PPUSH
8045: LD_INT 1
8047: PPUSH
8048: LD_INT 48
8050: PPUSH
8051: CALL_OW 125
// end ;
8055: LD_VAR 0 1
8059: RET
// every 9 9$30 + 7 7$00 trigger not legionDestroyed do var i , tmp , target , p ;
8060: LD_EXP 3
8064: NOT
8065: IFFALSE 8955
8067: GO 8069
8069: DISABLE
8070: LD_INT 0
8072: PPUSH
8073: PPUSH
8074: PPUSH
8075: PPUSH
// begin enable ;
8076: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8077: LD_INT 22
8079: PUSH
8080: LD_INT 8
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: PUSH
8087: LD_INT 23
8089: PUSH
8090: LD_INT 2
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: PUSH
8097: LD_INT 30
8099: PUSH
8100: LD_INT 3
8102: PUSH
8103: EMPTY
8104: LIST
8105: LIST
8106: PUSH
8107: EMPTY
8108: LIST
8109: LIST
8110: LIST
8111: PPUSH
8112: CALL_OW 69
8116: NOT
8117: IFFALSE 8121
// exit ;
8119: GO 8955
// if Prob ( 40 ) then
8121: LD_INT 40
8123: PPUSH
8124: CALL_OW 13
8128: IFFALSE 8255
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8130: LD_INT 3
8132: PPUSH
8133: LD_INT 14
8135: PUSH
8136: LD_INT 1
8138: PUSH
8139: LD_INT 2
8141: PUSH
8142: LD_INT 28
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: LIST
8149: LIST
8150: PUSH
8151: LD_INT 14
8153: PUSH
8154: LD_INT 1
8156: PUSH
8157: LD_INT 2
8159: PUSH
8160: LD_INT 28
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: LIST
8167: LIST
8168: PUSH
8169: LD_INT 14
8171: PUSH
8172: LD_INT 1
8174: PUSH
8175: LD_INT 2
8177: PUSH
8178: LD_INT 28
8180: PUSH
8181: EMPTY
8182: LIST
8183: LIST
8184: LIST
8185: LIST
8186: PUSH
8187: LD_INT 14
8189: PUSH
8190: LD_INT 1
8192: PUSH
8193: LD_INT 2
8195: PUSH
8196: LD_INT 28
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: LIST
8203: LIST
8204: PUSH
8205: LD_INT 14
8207: PUSH
8208: LD_INT 1
8210: PUSH
8211: LD_INT 2
8213: PUSH
8214: LD_INT 28
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: LIST
8221: LIST
8222: PUSH
8223: LD_INT 14
8225: PUSH
8226: LD_INT 1
8228: PUSH
8229: LD_INT 2
8231: PUSH
8232: LD_INT 26
8234: PUSH
8235: EMPTY
8236: LIST
8237: LIST
8238: LIST
8239: LIST
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: LIST
8247: LIST
8248: PPUSH
8249: CALL 46436 0 2
// end else
8253: GO 8462
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8255: LD_INT 3
8257: PPUSH
8258: LD_INT 14
8260: PUSH
8261: LD_INT 1
8263: PUSH
8264: LD_INT 2
8266: PUSH
8267: LD_INT 27
8269: PUSH
8270: LD_INT 26
8272: PUSH
8273: LD_INT 26
8275: PUSH
8276: LD_INT 28
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: LIST
8283: LIST
8284: PUSH
8285: LD_OWVAR 67
8289: ARRAY
8290: PUSH
8291: EMPTY
8292: LIST
8293: LIST
8294: LIST
8295: LIST
8296: PUSH
8297: LD_INT 14
8299: PUSH
8300: LD_INT 1
8302: PUSH
8303: LD_INT 2
8305: PUSH
8306: LD_INT 27
8308: PUSH
8309: LD_INT 26
8311: PUSH
8312: LD_INT 26
8314: PUSH
8315: LD_INT 26
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: LIST
8322: LIST
8323: PUSH
8324: LD_OWVAR 67
8328: ARRAY
8329: PUSH
8330: EMPTY
8331: LIST
8332: LIST
8333: LIST
8334: LIST
8335: PUSH
8336: LD_INT 14
8338: PUSH
8339: LD_INT 1
8341: PUSH
8342: LD_INT 2
8344: PUSH
8345: LD_INT 26
8347: PUSH
8348: LD_INT 26
8350: PUSH
8351: LD_INT 29
8353: PUSH
8354: LD_INT 29
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: PUSH
8363: LD_OWVAR 67
8367: ARRAY
8368: PUSH
8369: EMPTY
8370: LIST
8371: LIST
8372: LIST
8373: LIST
8374: PUSH
8375: LD_INT 13
8377: PUSH
8378: LD_INT 1
8380: PUSH
8381: LD_INT 2
8383: PUSH
8384: LD_INT 26
8386: PUSH
8387: LD_INT 29
8389: PUSH
8390: LD_INT 29
8392: PUSH
8393: LD_INT 29
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: PUSH
8402: LD_OWVAR 67
8406: ARRAY
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 13
8416: PUSH
8417: LD_INT 1
8419: PUSH
8420: LD_INT 2
8422: PUSH
8423: LD_INT 29
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: LD_INT 14
8434: PUSH
8435: LD_INT 1
8437: PUSH
8438: LD_INT 2
8440: PUSH
8441: LD_INT 26
8443: PUSH
8444: EMPTY
8445: LIST
8446: LIST
8447: LIST
8448: LIST
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: LIST
8454: LIST
8455: LIST
8456: LIST
8457: PPUSH
8458: CALL 46436 0 2
// end ; p := 0 ;
8462: LD_ADDR_VAR 0 4
8466: PUSH
8467: LD_INT 0
8469: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8470: LD_INT 35
8472: PPUSH
8473: CALL_OW 67
// p := Inc ( p ) ;
8477: LD_ADDR_VAR 0 4
8481: PUSH
8482: LD_VAR 0 4
8486: PPUSH
8487: CALL 91544 0 1
8491: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8492: LD_INT 3
8494: PPUSH
8495: LD_INT 1
8497: PPUSH
8498: CALL 47854 0 2
8502: PUSH
8503: LD_INT 6
8505: GREATEREQUAL
8506: PUSH
8507: LD_VAR 0 4
8511: PUSH
8512: LD_INT 100
8514: GREATER
8515: OR
8516: IFFALSE 8470
// wait ( 0 0$30 ) ;
8518: LD_INT 1050
8520: PPUSH
8521: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8525: LD_ADDR_VAR 0 2
8529: PUSH
8530: LD_INT 3
8532: PPUSH
8533: LD_INT 1
8535: PPUSH
8536: CALL 47854 0 2
8540: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8541: LD_ADDR_EXP 97
8545: PUSH
8546: LD_EXP 97
8550: PPUSH
8551: LD_INT 3
8553: PPUSH
8554: LD_EXP 97
8558: PUSH
8559: LD_INT 3
8561: ARRAY
8562: PUSH
8563: LD_VAR 0 2
8567: DIFF
8568: PPUSH
8569: CALL_OW 1
8573: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8574: LD_ADDR_VAR 0 3
8578: PUSH
8579: LD_INT 0
8581: PPUSH
8582: LD_INT 2
8584: PPUSH
8585: CALL_OW 12
8589: ST_TO_ADDR
// if target then
8590: LD_VAR 0 3
8594: IFFALSE 8722
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8596: LD_ADDR_VAR 0 2
8600: PUSH
8601: LD_VAR 0 2
8605: PPUSH
8606: LD_INT 24
8608: PUSH
8609: LD_INT 250
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PPUSH
8616: CALL_OW 72
8620: ST_TO_ADDR
// for i in tmp do
8621: LD_ADDR_VAR 0 1
8625: PUSH
8626: LD_VAR 0 2
8630: PUSH
8631: FOR_IN
8632: IFFALSE 8672
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8634: LD_VAR 0 1
8638: PPUSH
8639: LD_INT 89
8641: PPUSH
8642: LD_INT 71
8644: PPUSH
8645: CALL_OW 297
8649: PUSH
8650: LD_INT 9
8652: GREATER
8653: IFFALSE 8670
// ComMoveXY ( i , 89 , 71 ) ;
8655: LD_VAR 0 1
8659: PPUSH
8660: LD_INT 89
8662: PPUSH
8663: LD_INT 71
8665: PPUSH
8666: CALL_OW 111
8670: GO 8631
8672: POP
8673: POP
// wait ( 0 0$1 ) ;
8674: LD_INT 35
8676: PPUSH
8677: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8681: LD_VAR 0 2
8685: PPUSH
8686: LD_INT 92
8688: PUSH
8689: LD_INT 89
8691: PUSH
8692: LD_INT 71
8694: PUSH
8695: LD_INT 9
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: LIST
8702: LIST
8703: PPUSH
8704: CALL_OW 72
8708: PUSH
8709: LD_VAR 0 2
8713: PUSH
8714: LD_INT 1
8716: MINUS
8717: GREATEREQUAL
8718: IFFALSE 8596
// end else
8720: GO 8846
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8722: LD_ADDR_VAR 0 2
8726: PUSH
8727: LD_VAR 0 2
8731: PPUSH
8732: LD_INT 24
8734: PUSH
8735: LD_INT 250
8737: PUSH
8738: EMPTY
8739: LIST
8740: LIST
8741: PPUSH
8742: CALL_OW 72
8746: ST_TO_ADDR
// for i in tmp do
8747: LD_ADDR_VAR 0 1
8751: PUSH
8752: LD_VAR 0 2
8756: PUSH
8757: FOR_IN
8758: IFFALSE 8798
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8760: LD_VAR 0 1
8764: PPUSH
8765: LD_INT 147
8767: PPUSH
8768: LD_INT 4
8770: PPUSH
8771: CALL_OW 297
8775: PUSH
8776: LD_INT 9
8778: GREATER
8779: IFFALSE 8796
// ComMoveXY ( i , 147 , 4 ) ;
8781: LD_VAR 0 1
8785: PPUSH
8786: LD_INT 147
8788: PPUSH
8789: LD_INT 4
8791: PPUSH
8792: CALL_OW 111
8796: GO 8757
8798: POP
8799: POP
// wait ( 0 0$1 ) ;
8800: LD_INT 35
8802: PPUSH
8803: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8807: LD_VAR 0 2
8811: PPUSH
8812: LD_INT 92
8814: PUSH
8815: LD_INT 147
8817: PUSH
8818: LD_INT 4
8820: PUSH
8821: LD_INT 9
8823: PUSH
8824: EMPTY
8825: LIST
8826: LIST
8827: LIST
8828: LIST
8829: PPUSH
8830: CALL_OW 72
8834: PUSH
8835: LD_VAR 0 2
8839: PUSH
8840: LD_INT 1
8842: MINUS
8843: GREATEREQUAL
8844: IFFALSE 8722
// end ; repeat wait ( 0 0$1 ) ;
8846: LD_INT 35
8848: PPUSH
8849: CALL_OW 67
// for i in tmp do
8853: LD_ADDR_VAR 0 1
8857: PUSH
8858: LD_VAR 0 2
8862: PUSH
8863: FOR_IN
8864: IFFALSE 8946
// begin if GetLives ( i ) > 251 then
8866: LD_VAR 0 1
8870: PPUSH
8871: CALL_OW 256
8875: PUSH
8876: LD_INT 251
8878: GREATER
8879: IFFALSE 8917
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8881: LD_VAR 0 1
8885: PPUSH
8886: LD_INT 81
8888: PUSH
8889: LD_INT 8
8891: PUSH
8892: EMPTY
8893: LIST
8894: LIST
8895: PPUSH
8896: CALL_OW 69
8900: PPUSH
8901: LD_VAR 0 1
8905: PPUSH
8906: CALL_OW 74
8910: PPUSH
8911: CALL_OW 115
8915: GO 8944
// if IsDead ( i ) then
8917: LD_VAR 0 1
8921: PPUSH
8922: CALL_OW 301
8926: IFFALSE 8944
// tmp := tmp diff i ;
8928: LD_ADDR_VAR 0 2
8932: PUSH
8933: LD_VAR 0 2
8937: PUSH
8938: LD_VAR 0 1
8942: DIFF
8943: ST_TO_ADDR
// end ;
8944: GO 8863
8946: POP
8947: POP
// until not tmp ;
8948: LD_VAR 0 2
8952: NOT
8953: IFFALSE 8846
// end ;
8955: PPOPN 4
8957: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8958: LD_EXP 58
8962: PPUSH
8963: CALL_OW 302
8967: PUSH
8968: LD_EXP 3
8972: NOT
8973: AND
8974: IFFALSE 8983
8976: GO 8978
8978: DISABLE
// BuildKozlovBomb ;
8979: CALL 7933 0 0
8983: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8984: LD_INT 22
8986: PUSH
8987: LD_INT 8
8989: PUSH
8990: EMPTY
8991: LIST
8992: LIST
8993: PUSH
8994: LD_INT 34
8996: PUSH
8997: LD_INT 48
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PPUSH
9008: CALL_OW 69
9012: IFFALSE 9060
9014: GO 9016
9016: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9017: LD_INT 22
9019: PUSH
9020: LD_INT 8
9022: PUSH
9023: EMPTY
9024: LIST
9025: LIST
9026: PUSH
9027: LD_INT 34
9029: PUSH
9030: LD_INT 48
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: PPUSH
9041: CALL_OW 69
9045: PUSH
9046: LD_INT 1
9048: ARRAY
9049: PPUSH
9050: LD_INT 173
9052: PPUSH
9053: LD_INT 96
9055: PPUSH
9056: CALL_OW 116
// end ; end_of_file
9060: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9061: LD_INT 0
9063: PPUSH
9064: PPUSH
9065: PPUSH
9066: PPUSH
9067: PPUSH
9068: PPUSH
9069: PPUSH
9070: PPUSH
9071: PPUSH
9072: PPUSH
// side := 3 ;
9073: LD_ADDR_VAR 0 6
9077: PUSH
9078: LD_INT 3
9080: ST_TO_ADDR
// InitHc ;
9081: CALL_OW 19
// uc_side := side ;
9085: LD_ADDR_OWVAR 20
9089: PUSH
9090: LD_VAR 0 6
9094: ST_TO_ADDR
// uc_nation := 3 ;
9095: LD_ADDR_OWVAR 21
9099: PUSH
9100: LD_INT 3
9102: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9103: LD_ADDR_VAR 0 2
9107: PUSH
9108: LD_INT 22
9110: PUSH
9111: LD_VAR 0 6
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: PUSH
9120: LD_INT 21
9122: PUSH
9123: LD_INT 3
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PPUSH
9134: CALL_OW 69
9138: PUSH
9139: FOR_IN
9140: IFFALSE 9156
// SetBLevel ( i , 10 ) ;
9142: LD_VAR 0 2
9146: PPUSH
9147: LD_INT 10
9149: PPUSH
9150: CALL_OW 241
9154: GO 9139
9156: POP
9157: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9158: LD_ADDR_VAR 0 10
9162: PUSH
9163: LD_INT 22
9165: PUSH
9166: LD_VAR 0 6
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: PUSH
9175: LD_INT 30
9177: PUSH
9178: LD_INT 34
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: PPUSH
9189: CALL_OW 69
9193: ST_TO_ADDR
// if teleport then
9194: LD_VAR 0 10
9198: IFFALSE 9219
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9200: LD_VAR 0 10
9204: PUSH
9205: LD_INT 1
9207: ARRAY
9208: PPUSH
9209: LD_INT 123
9211: PPUSH
9212: LD_INT 122
9214: PPUSH
9215: CALL_OW 243
// hc_importance := 0 ;
9219: LD_ADDR_OWVAR 32
9223: PUSH
9224: LD_INT 0
9226: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9227: LD_ADDR_EXP 60
9231: PUSH
9232: LD_STRING Platonov
9234: PPUSH
9235: CALL_OW 25
9239: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9240: LD_ADDR_EXP 61
9244: PUSH
9245: LD_STRING Yakotich
9247: PPUSH
9248: LD_EXP 1
9252: NOT
9253: PPUSH
9254: LD_STRING 09_
9256: PPUSH
9257: CALL 52862 0 3
9261: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9262: LD_ADDR_EXP 62
9266: PUSH
9267: LD_STRING Gleb
9269: PPUSH
9270: CALL_OW 25
9274: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9275: LD_STRING 03_Cornel
9277: PPUSH
9278: CALL_OW 28
9282: IFFALSE 9330
// begin Bierezov := NewCharacter ( Mikhail ) ;
9284: LD_ADDR_EXP 63
9288: PUSH
9289: LD_STRING Mikhail
9291: PPUSH
9292: CALL_OW 25
9296: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9297: LD_EXP 63
9301: PPUSH
9302: LD_INT 197
9304: PPUSH
9305: LD_INT 111
9307: PPUSH
9308: LD_INT 9
9310: PPUSH
9311: LD_INT 0
9313: PPUSH
9314: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9318: LD_EXP 63
9322: PPUSH
9323: LD_INT 3
9325: PPUSH
9326: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9330: LD_EXP 60
9334: PPUSH
9335: LD_INT 126
9337: PPUSH
9338: CALL_OW 52
// if Yakotich then
9342: LD_EXP 61
9346: IFFALSE 9369
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9348: LD_EXP 61
9352: PPUSH
9353: LD_INT 197
9355: PPUSH
9356: LD_INT 111
9358: PPUSH
9359: LD_INT 9
9361: PPUSH
9362: LD_INT 0
9364: PPUSH
9365: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9369: LD_EXP 62
9373: PPUSH
9374: LD_INT 197
9376: PPUSH
9377: LD_INT 111
9379: PPUSH
9380: LD_INT 9
9382: PPUSH
9383: LD_INT 0
9385: PPUSH
9386: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9390: LD_ADDR_VAR 0 5
9394: PUSH
9395: LD_INT 126
9397: PPUSH
9398: LD_INT 2
9400: PPUSH
9401: LD_STRING zhukov
9403: PPUSH
9404: LD_INT 9
9406: PUSH
9407: LD_INT 10
9409: PUSH
9410: LD_INT 10
9412: PUSH
9413: LD_INT 10
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: LIST
9420: LIST
9421: PUSH
9422: LD_OWVAR 67
9426: ARRAY
9427: PPUSH
9428: LD_INT 9000
9430: PUSH
9431: LD_INT 1000
9433: PUSH
9434: LD_INT 300
9436: PUSH
9437: EMPTY
9438: LIST
9439: LIST
9440: LIST
9441: PPUSH
9442: LD_INT 21
9444: PUSH
9445: LD_INT 8
9447: PUSH
9448: LD_INT 13
9450: PUSH
9451: LD_INT 8
9453: PUSH
9454: EMPTY
9455: LIST
9456: LIST
9457: LIST
9458: LIST
9459: PPUSH
9460: CALL 61155 0 6
9464: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9465: LD_ADDR_EXP 78
9469: PUSH
9470: LD_EXP 78
9474: PPUSH
9475: LD_INT 2
9477: PPUSH
9478: LD_VAR 0 5
9482: PUSH
9483: LD_EXP 61
9487: PUSH
9488: LD_EXP 62
9492: PUSH
9493: LD_EXP 63
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: UNION
9503: PPUSH
9504: CALL_OW 1
9508: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9509: LD_ADDR_VAR 0 4
9513: PUSH
9514: LD_INT 267
9516: PPUSH
9517: CALL_OW 274
9521: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9522: LD_VAR 0 4
9526: PPUSH
9527: LD_INT 1
9529: PPUSH
9530: LD_INT 5000
9532: PPUSH
9533: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9537: LD_VAR 0 4
9541: PPUSH
9542: LD_INT 2
9544: PPUSH
9545: LD_INT 200
9547: PPUSH
9548: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9552: LD_VAR 0 4
9556: PPUSH
9557: LD_INT 3
9559: PPUSH
9560: LD_INT 200
9562: PPUSH
9563: CALL_OW 277
// for i := 1 to 6 do
9567: LD_ADDR_VAR 0 2
9571: PUSH
9572: DOUBLE
9573: LD_INT 1
9575: DEC
9576: ST_TO_ADDR
9577: LD_INT 6
9579: PUSH
9580: FOR_TO
9581: IFFALSE 9664
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
9583: LD_INT 0
9585: PPUSH
9586: LD_INT 8
9588: PUSH
9589: LD_INT 9
9591: PUSH
9592: LD_INT 10
9594: PUSH
9595: LD_INT 10
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: PUSH
9604: LD_OWVAR 67
9608: ARRAY
9609: PPUSH
9610: CALL_OW 381
// un := CreateHuman ;
9614: LD_ADDR_VAR 0 8
9618: PUSH
9619: CALL_OW 44
9623: ST_TO_ADDR
// if i mod 2 = 0 then
9624: LD_VAR 0 2
9628: PUSH
9629: LD_INT 2
9631: MOD
9632: PUSH
9633: LD_INT 0
9635: EQUAL
9636: IFFALSE 9650
// SetClass ( un , class_bazooker ) ;
9638: LD_VAR 0 8
9642: PPUSH
9643: LD_INT 9
9645: PPUSH
9646: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
9650: LD_VAR 0 8
9654: PPUSH
9655: LD_INT 674
9657: PPUSH
9658: CALL_OW 52
// end ;
9662: GO 9580
9664: POP
9665: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
9666: LD_INT 21
9668: PPUSH
9669: LD_INT 3
9671: PPUSH
9672: LD_INT 3
9674: PPUSH
9675: LD_INT 52
9677: PPUSH
9678: LD_INT 100
9680: PPUSH
9681: CALL 57702 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
9685: CALL_OW 45
9689: PPUSH
9690: LD_INT 259
9692: PPUSH
9693: LD_INT 145
9695: PPUSH
9696: LD_INT 3
9698: PPUSH
9699: LD_INT 0
9701: PPUSH
9702: CALL 92323 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
9706: CALL_OW 45
9710: PPUSH
9711: LD_INT 245
9713: PPUSH
9714: LD_INT 139
9716: PPUSH
9717: LD_INT 3
9719: PPUSH
9720: LD_INT 0
9722: PPUSH
9723: CALL 92323 0 5
// behemoths := [ ] ;
9727: LD_ADDR_EXP 64
9731: PUSH
9732: EMPTY
9733: ST_TO_ADDR
// behemothBuilders := [ ] ;
9734: LD_ADDR_EXP 65
9738: PUSH
9739: EMPTY
9740: ST_TO_ADDR
// j := 3 ;
9741: LD_ADDR_VAR 0 3
9745: PUSH
9746: LD_INT 3
9748: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9749: LD_ADDR_VAR 0 2
9753: PUSH
9754: LD_INT 22
9756: PUSH
9757: LD_INT 3
9759: PUSH
9760: EMPTY
9761: LIST
9762: LIST
9763: PUSH
9764: LD_INT 25
9766: PUSH
9767: LD_INT 3
9769: PUSH
9770: EMPTY
9771: LIST
9772: LIST
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: PPUSH
9778: CALL_OW 69
9782: PUSH
9783: FOR_IN
9784: IFFALSE 9834
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9786: LD_ADDR_EXP 65
9790: PUSH
9791: LD_EXP 65
9795: PPUSH
9796: LD_VAR 0 2
9800: PPUSH
9801: CALL 90183 0 2
9805: ST_TO_ADDR
// j := j - 1 ;
9806: LD_ADDR_VAR 0 3
9810: PUSH
9811: LD_VAR 0 3
9815: PUSH
9816: LD_INT 1
9818: MINUS
9819: ST_TO_ADDR
// if j = 0 then
9820: LD_VAR 0 3
9824: PUSH
9825: LD_INT 0
9827: EQUAL
9828: IFFALSE 9832
// break ;
9830: GO 9834
// end ;
9832: GO 9783
9834: POP
9835: POP
// end ;
9836: LD_VAR 0 1
9840: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9841: LD_INT 0
9843: PPUSH
9844: PPUSH
9845: PPUSH
9846: PPUSH
9847: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9848: LD_ADDR_VAR 0 4
9852: PUSH
9853: LD_INT 209
9855: PUSH
9856: LD_INT 149
9858: PUSH
9859: EMPTY
9860: LIST
9861: LIST
9862: PUSH
9863: LD_INT 219
9865: PUSH
9866: LD_INT 154
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: PUSH
9873: LD_INT 223
9875: PUSH
9876: LD_INT 149
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: PUSH
9883: LD_INT 232
9885: PUSH
9886: LD_INT 155
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: LIST
9897: LIST
9898: ST_TO_ADDR
// if not behemothBuilders then
9899: LD_EXP 65
9903: NOT
9904: IFFALSE 9908
// exit ;
9906: GO 10012
// j := 1 ;
9908: LD_ADDR_VAR 0 3
9912: PUSH
9913: LD_INT 1
9915: ST_TO_ADDR
// for i in behemothBuilders do
9916: LD_ADDR_VAR 0 2
9920: PUSH
9921: LD_EXP 65
9925: PUSH
9926: FOR_IN
9927: IFFALSE 10010
// begin if IsInUnit ( i ) then
9929: LD_VAR 0 2
9933: PPUSH
9934: CALL_OW 310
9938: IFFALSE 9949
// ComExitBuilding ( i ) ;
9940: LD_VAR 0 2
9944: PPUSH
9945: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9949: LD_VAR 0 2
9953: PPUSH
9954: LD_INT 37
9956: PPUSH
9957: LD_VAR 0 4
9961: PUSH
9962: LD_VAR 0 3
9966: ARRAY
9967: PUSH
9968: LD_INT 1
9970: ARRAY
9971: PPUSH
9972: LD_VAR 0 4
9976: PUSH
9977: LD_VAR 0 3
9981: ARRAY
9982: PUSH
9983: LD_INT 2
9985: ARRAY
9986: PPUSH
9987: LD_INT 0
9989: PPUSH
9990: CALL_OW 230
// j := j + 1 ;
9994: LD_ADDR_VAR 0 3
9998: PUSH
9999: LD_VAR 0 3
10003: PUSH
10004: LD_INT 1
10006: PLUS
10007: ST_TO_ADDR
// end ;
10008: GO 9926
10010: POP
10011: POP
// end ;
10012: LD_VAR 0 1
10016: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10017: LD_INT 3
10019: PPUSH
10020: CALL 90244 0 1
10024: PUSH
10025: LD_INT 22
10027: PUSH
10028: LD_INT 3
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PUSH
10035: LD_INT 30
10037: PUSH
10038: LD_INT 37
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: PPUSH
10049: CALL_OW 69
10053: NOT
10054: AND
10055: IFFALSE 10241
10057: GO 10059
10059: DISABLE
10060: LD_INT 0
10062: PPUSH
10063: PPUSH
// begin enable ;
10064: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10065: LD_ADDR_VAR 0 2
10069: PUSH
10070: LD_INT 3
10072: PPUSH
10073: CALL 90244 0 1
10077: ST_TO_ADDR
// for i in tmp do
10078: LD_ADDR_VAR 0 1
10082: PUSH
10083: LD_VAR 0 2
10087: PUSH
10088: FOR_IN
10089: IFFALSE 10239
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10091: LD_VAR 0 1
10095: PPUSH
10096: LD_INT 7
10098: PPUSH
10099: CALL_OW 308
10103: PUSH
10104: LD_VAR 0 1
10108: PPUSH
10109: CALL_OW 110
10113: PUSH
10114: LD_INT 2
10116: EQUAL
10117: NOT
10118: AND
10119: IFFALSE 10133
// SetTag ( i , 2 ) ;
10121: LD_VAR 0 1
10125: PPUSH
10126: LD_INT 2
10128: PPUSH
10129: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10133: LD_INT 81
10135: PUSH
10136: LD_INT 3
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: PUSH
10143: LD_INT 91
10145: PUSH
10146: LD_VAR 0 1
10150: PUSH
10151: LD_INT 12
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: LIST
10158: PUSH
10159: EMPTY
10160: LIST
10161: LIST
10162: PPUSH
10163: CALL_OW 69
10167: NOT
10168: PUSH
10169: LD_VAR 0 1
10173: PPUSH
10174: CALL_OW 110
10178: PUSH
10179: LD_INT 2
10181: EQUAL
10182: NOT
10183: AND
10184: IFFALSE 10203
// ComAgressiveMove ( i , 64 , 93 ) else
10186: LD_VAR 0 1
10190: PPUSH
10191: LD_INT 64
10193: PPUSH
10194: LD_INT 93
10196: PPUSH
10197: CALL_OW 114
10201: GO 10237
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10203: LD_VAR 0 1
10207: PPUSH
10208: LD_INT 81
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: EMPTY
10215: LIST
10216: LIST
10217: PPUSH
10218: CALL_OW 69
10222: PPUSH
10223: LD_VAR 0 1
10227: PPUSH
10228: CALL_OW 74
10232: PPUSH
10233: CALL_OW 115
// end ;
10237: GO 10088
10239: POP
10240: POP
// end ;
10241: PPOPN 2
10243: END
// every 9 9$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10244: LD_EXP 2
10248: NOT
10249: IFFALSE 11207
10251: GO 10253
10253: DISABLE
10254: LD_INT 0
10256: PPUSH
10257: PPUSH
10258: PPUSH
10259: PPUSH
10260: PPUSH
// begin enable ;
10261: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10262: LD_INT 22
10264: PUSH
10265: LD_INT 3
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PUSH
10272: LD_INT 30
10274: PUSH
10275: LD_INT 3
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: PPUSH
10286: CALL_OW 69
10290: NOT
10291: IFFALSE 10295
// exit ;
10293: GO 11207
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10295: LD_ADDR_VAR 0 4
10299: PUSH
10300: LD_INT 22
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PUSH
10310: LD_INT 30
10312: PUSH
10313: LD_INT 34
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PPUSH
10324: CALL_OW 69
10328: ST_TO_ADDR
// if Prob ( 40 ) then
10329: LD_INT 40
10331: PPUSH
10332: CALL_OW 13
10336: IFFALSE 10463
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10338: LD_INT 2
10340: PPUSH
10341: LD_INT 22
10343: PUSH
10344: LD_INT 3
10346: PUSH
10347: LD_INT 3
10349: PUSH
10350: LD_INT 49
10352: PUSH
10353: EMPTY
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: PUSH
10359: LD_INT 22
10361: PUSH
10362: LD_INT 3
10364: PUSH
10365: LD_INT 3
10367: PUSH
10368: LD_INT 49
10370: PUSH
10371: EMPTY
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: PUSH
10377: LD_INT 22
10379: PUSH
10380: LD_INT 3
10382: PUSH
10383: LD_INT 3
10385: PUSH
10386: LD_INT 49
10388: PUSH
10389: EMPTY
10390: LIST
10391: LIST
10392: LIST
10393: LIST
10394: PUSH
10395: LD_INT 24
10397: PUSH
10398: LD_INT 3
10400: PUSH
10401: LD_INT 3
10403: PUSH
10404: LD_INT 46
10406: PUSH
10407: EMPTY
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: PUSH
10413: LD_INT 24
10415: PUSH
10416: LD_INT 3
10418: PUSH
10419: LD_INT 3
10421: PUSH
10422: LD_INT 46
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: LIST
10429: LIST
10430: PUSH
10431: LD_INT 24
10433: PUSH
10434: LD_INT 3
10436: PUSH
10437: LD_INT 3
10439: PUSH
10440: LD_INT 46
10442: PUSH
10443: EMPTY
10444: LIST
10445: LIST
10446: LIST
10447: LIST
10448: PUSH
10449: EMPTY
10450: LIST
10451: LIST
10452: LIST
10453: LIST
10454: LIST
10455: LIST
10456: PPUSH
10457: CALL 46436 0 2
// end else
10461: GO 10586
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10463: LD_INT 2
10465: PPUSH
10466: LD_INT 24
10468: PUSH
10469: LD_INT 3
10471: PUSH
10472: LD_INT 3
10474: PUSH
10475: LD_INT 47
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: PUSH
10484: LD_INT 24
10486: PUSH
10487: LD_INT 3
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 47
10495: PUSH
10496: EMPTY
10497: LIST
10498: LIST
10499: LIST
10500: LIST
10501: PUSH
10502: LD_INT 24
10504: PUSH
10505: LD_INT 3
10507: PUSH
10508: LD_INT 3
10510: PUSH
10511: LD_INT 47
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 24
10522: PUSH
10523: LD_INT 3
10525: PUSH
10526: LD_INT 3
10528: PUSH
10529: LD_INT 46
10531: PUSH
10532: EMPTY
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: PUSH
10538: LD_INT 24
10540: PUSH
10541: LD_INT 3
10543: PUSH
10544: LD_INT 3
10546: PUSH
10547: LD_INT 46
10549: PUSH
10550: EMPTY
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: PUSH
10556: LD_INT 24
10558: PUSH
10559: LD_INT 3
10561: PUSH
10562: LD_INT 3
10564: PUSH
10565: LD_INT 46
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: PPUSH
10582: CALL 46436 0 2
// end ; if Difficulty > 1 then
10586: LD_OWVAR 67
10590: PUSH
10591: LD_INT 1
10593: GREATER
10594: IFFALSE 10624
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10596: LD_INT 2
10598: PPUSH
10599: LD_INT 24
10601: PUSH
10602: LD_INT 3
10604: PUSH
10605: LD_INT 3
10607: PUSH
10608: LD_INT 47
10610: PUSH
10611: EMPTY
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: PUSH
10617: EMPTY
10618: LIST
10619: PPUSH
10620: CALL 46436 0 2
// p := 0 ;
10624: LD_ADDR_VAR 0 5
10628: PUSH
10629: LD_INT 0
10631: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10632: LD_INT 35
10634: PPUSH
10635: CALL_OW 67
// p := Inc ( p ) ;
10639: LD_ADDR_VAR 0 5
10643: PUSH
10644: LD_VAR 0 5
10648: PPUSH
10649: CALL 91544 0 1
10653: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 100 ;
10654: LD_INT 2
10656: PPUSH
10657: LD_INT 1
10659: PPUSH
10660: CALL 47854 0 2
10664: PUSH
10665: LD_INT 6
10667: PUSH
10668: LD_INT 7
10670: PUSH
10671: LD_INT 7
10673: PUSH
10674: LD_INT 7
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: LIST
10681: LIST
10682: PUSH
10683: LD_OWVAR 67
10687: ARRAY
10688: GREATEREQUAL
10689: PUSH
10690: LD_VAR 0 5
10694: PUSH
10695: LD_INT 100
10697: GREATER
10698: OR
10699: IFFALSE 10632
// wait ( 0 0$30 ) ;
10701: LD_INT 1050
10703: PPUSH
10704: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10708: LD_ADDR_VAR 0 2
10712: PUSH
10713: LD_INT 2
10715: PPUSH
10716: LD_INT 1
10718: PPUSH
10719: CALL 47854 0 2
10723: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10724: LD_ADDR_EXP 97
10728: PUSH
10729: LD_EXP 97
10733: PPUSH
10734: LD_INT 2
10736: PPUSH
10737: LD_EXP 97
10741: PUSH
10742: LD_INT 2
10744: ARRAY
10745: PUSH
10746: LD_VAR 0 2
10750: DIFF
10751: PPUSH
10752: CALL_OW 1
10756: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10757: LD_ADDR_VAR 0 3
10761: PUSH
10762: LD_INT 0
10764: PPUSH
10765: LD_INT 1
10767: PPUSH
10768: CALL_OW 12
10772: ST_TO_ADDR
// if target then
10773: LD_VAR 0 3
10777: IFFALSE 10905
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10779: LD_ADDR_VAR 0 2
10783: PUSH
10784: LD_VAR 0 2
10788: PPUSH
10789: LD_INT 24
10791: PUSH
10792: LD_INT 250
10794: PUSH
10795: EMPTY
10796: LIST
10797: LIST
10798: PPUSH
10799: CALL_OW 72
10803: ST_TO_ADDR
// for i in tmp do
10804: LD_ADDR_VAR 0 1
10808: PUSH
10809: LD_VAR 0 2
10813: PUSH
10814: FOR_IN
10815: IFFALSE 10855
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10817: LD_VAR 0 1
10821: PPUSH
10822: LD_INT 139
10824: PPUSH
10825: LD_INT 89
10827: PPUSH
10828: CALL_OW 297
10832: PUSH
10833: LD_INT 9
10835: GREATER
10836: IFFALSE 10853
// ComMoveXY ( i , 139 , 89 ) ;
10838: LD_VAR 0 1
10842: PPUSH
10843: LD_INT 139
10845: PPUSH
10846: LD_INT 89
10848: PPUSH
10849: CALL_OW 111
10853: GO 10814
10855: POP
10856: POP
// wait ( 0 0$1 ) ;
10857: LD_INT 35
10859: PPUSH
10860: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10864: LD_VAR 0 2
10868: PPUSH
10869: LD_INT 92
10871: PUSH
10872: LD_INT 139
10874: PUSH
10875: LD_INT 89
10877: PUSH
10878: LD_INT 9
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: LIST
10885: LIST
10886: PPUSH
10887: CALL_OW 72
10891: PUSH
10892: LD_VAR 0 2
10896: PUSH
10897: LD_INT 1
10899: MINUS
10900: GREATEREQUAL
10901: IFFALSE 10779
// end else
10903: GO 11047
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10905: LD_VAR 0 2
10909: PPUSH
10910: LD_VAR 0 4
10914: PUSH
10915: LD_INT 1
10917: ARRAY
10918: PPUSH
10919: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10923: LD_ADDR_VAR 0 2
10927: PUSH
10928: LD_VAR 0 2
10932: PPUSH
10933: LD_INT 24
10935: PUSH
10936: LD_INT 250
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: PPUSH
10943: CALL_OW 72
10947: ST_TO_ADDR
// for i in tmp do
10948: LD_ADDR_VAR 0 1
10952: PUSH
10953: LD_VAR 0 2
10957: PUSH
10958: FOR_IN
10959: IFFALSE 10999
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10961: LD_VAR 0 1
10965: PPUSH
10966: LD_INT 124
10968: PPUSH
10969: LD_INT 139
10971: PPUSH
10972: CALL_OW 297
10976: PUSH
10977: LD_INT 9
10979: GREATER
10980: IFFALSE 10997
// ComMoveXY ( i , 124 , 139 ) ;
10982: LD_VAR 0 1
10986: PPUSH
10987: LD_INT 124
10989: PPUSH
10990: LD_INT 139
10992: PPUSH
10993: CALL_OW 111
10997: GO 10958
10999: POP
11000: POP
// wait ( 0 0$1 ) ;
11001: LD_INT 35
11003: PPUSH
11004: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
11008: LD_VAR 0 2
11012: PPUSH
11013: LD_INT 92
11015: PUSH
11016: LD_INT 124
11018: PUSH
11019: LD_INT 139
11021: PUSH
11022: LD_INT 9
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: LIST
11029: LIST
11030: PPUSH
11031: CALL_OW 72
11035: PUSH
11036: LD_VAR 0 2
11040: PUSH
11041: LD_INT 1
11043: MINUS
11044: GREATEREQUAL
11045: IFFALSE 10923
// end ; repeat wait ( 0 0$1 ) ;
11047: LD_INT 35
11049: PPUSH
11050: CALL_OW 67
// for i in tmp do
11054: LD_ADDR_VAR 0 1
11058: PUSH
11059: LD_VAR 0 2
11063: PUSH
11064: FOR_IN
11065: IFFALSE 11198
// begin if GetLives ( i ) > 251 then
11067: LD_VAR 0 1
11071: PPUSH
11072: CALL_OW 256
11076: PUSH
11077: LD_INT 251
11079: GREATER
11080: IFFALSE 11169
// begin if GetWeapon ( i ) = ru_time_lapser then
11082: LD_VAR 0 1
11086: PPUSH
11087: CALL_OW 264
11091: PUSH
11092: LD_INT 49
11094: EQUAL
11095: IFFALSE 11133
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11097: LD_VAR 0 1
11101: PPUSH
11102: LD_INT 81
11104: PUSH
11105: LD_INT 3
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: PPUSH
11112: CALL_OW 69
11116: PPUSH
11117: LD_VAR 0 1
11121: PPUSH
11122: CALL_OW 74
11126: PPUSH
11127: CALL_OW 112
11131: GO 11167
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11133: LD_VAR 0 1
11137: PPUSH
11138: LD_INT 81
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PPUSH
11148: CALL_OW 69
11152: PPUSH
11153: LD_VAR 0 1
11157: PPUSH
11158: CALL_OW 74
11162: PPUSH
11163: CALL_OW 115
// end else
11167: GO 11196
// if IsDead ( i ) then
11169: LD_VAR 0 1
11173: PPUSH
11174: CALL_OW 301
11178: IFFALSE 11196
// tmp := tmp diff i ;
11180: LD_ADDR_VAR 0 2
11184: PUSH
11185: LD_VAR 0 2
11189: PUSH
11190: LD_VAR 0 1
11194: DIFF
11195: ST_TO_ADDR
// end ;
11196: GO 11064
11198: POP
11199: POP
// until not tmp ;
11200: LD_VAR 0 2
11204: NOT
11205: IFFALSE 11047
// end ;
11207: PPOPN 5
11209: END
// every 30 30$00 trigger not russianDestroyed do
11210: LD_EXP 2
11214: NOT
11215: IFFALSE 11284
11217: GO 11219
11219: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11220: LD_INT 105000
11222: PUSH
11223: LD_INT 84000
11225: PUSH
11226: LD_INT 63000
11228: PUSH
11229: LD_INT 52500
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: PUSH
11238: LD_OWVAR 67
11242: ARRAY
11243: PPUSH
11244: CALL_OW 67
// if russianDestroyed then
11248: LD_EXP 2
11252: IFFALSE 11256
// exit ;
11254: GO 11284
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11256: LD_INT 2
11258: PPUSH
11259: LD_INT 23
11261: PUSH
11262: LD_INT 3
11264: PUSH
11265: LD_INT 1
11267: PUSH
11268: LD_INT 48
11270: PUSH
11271: EMPTY
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: PUSH
11277: EMPTY
11278: LIST
11279: PPUSH
11280: CALL 46436 0 2
// end ; end_of_file
11284: END
// export function CustomEvent ( event ) ; begin
11285: LD_INT 0
11287: PPUSH
// end ;
11288: LD_VAR 0 2
11292: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11293: LD_VAR 0 2
11297: PPUSH
11298: LD_VAR 0 3
11302: PPUSH
11303: LD_INT 15
11305: PPUSH
11306: CALL_OW 309
11310: IFFALSE 11319
// YouLost ( MothContaminate ) ;
11312: LD_STRING MothContaminate
11314: PPUSH
11315: CALL_OW 104
// end ;
11319: PPOPN 3
11321: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11322: LD_VAR 0 2
11326: PPUSH
11327: LD_VAR 0 3
11331: PPUSH
11332: LD_INT 15
11334: PPUSH
11335: CALL_OW 309
11339: IFFALSE 11355
// begin wait ( 0 0$6 ) ;
11341: LD_INT 210
11343: PPUSH
11344: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11348: LD_STRING MothContaminateBomb
11350: PPUSH
11351: CALL_OW 104
// end ; end ;
11355: PPOPN 3
11357: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11358: LD_VAR 0 1
11362: PPUSH
11363: CALL 110207 0 1
// if un = JMM then
11367: LD_VAR 0 1
11371: PUSH
11372: LD_EXP 19
11376: EQUAL
11377: IFFALSE 11388
// begin YouLost ( JMM ) ;
11379: LD_STRING JMM
11381: PPUSH
11382: CALL_OW 104
// exit ;
11386: GO 11517
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11388: LD_VAR 0 1
11392: PPUSH
11393: CALL_OW 255
11397: PUSH
11398: LD_INT 2
11400: EQUAL
11401: PUSH
11402: LD_EXP 18
11406: NOT
11407: AND
11408: IFFALSE 11418
// arabianAttacked := true ;
11410: LD_ADDR_EXP 18
11414: PUSH
11415: LD_INT 1
11417: ST_TO_ADDR
// if un = Powell then
11418: LD_VAR 0 1
11422: PUSH
11423: LD_EXP 55
11427: EQUAL
11428: IFFALSE 11438
// americanDestroyed := true ;
11430: LD_ADDR_EXP 4
11434: PUSH
11435: LD_INT 1
11437: ST_TO_ADDR
// if un = Platonov then
11438: LD_VAR 0 1
11442: PUSH
11443: LD_EXP 60
11447: EQUAL
11448: IFFALSE 11458
// russianDestroyed := true ;
11450: LD_ADDR_EXP 2
11454: PUSH
11455: LD_INT 1
11457: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11458: LD_VAR 0 1
11462: PUSH
11463: LD_INT 22
11465: PUSH
11466: LD_INT 7
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: LD_INT 21
11475: PUSH
11476: LD_INT 2
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: EMPTY
11484: LIST
11485: LIST
11486: PPUSH
11487: CALL_OW 69
11491: IN
11492: IFFALSE 11508
// vehicleLostCounter := vehicleLostCounter + 1 ;
11494: LD_ADDR_EXP 15
11498: PUSH
11499: LD_EXP 15
11503: PUSH
11504: LD_INT 1
11506: PLUS
11507: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11508: LD_VAR 0 1
11512: PPUSH
11513: CALL 49878 0 1
// end ;
11517: PPOPN 1
11519: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11520: LD_VAR 0 1
11524: PPUSH
11525: LD_VAR 0 2
11529: PPUSH
11530: CALL 52210 0 2
// end ;
11534: PPOPN 2
11536: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11537: LD_VAR 0 1
11541: PPUSH
11542: CALL 51278 0 1
// end ;
11546: PPOPN 1
11548: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11549: LD_VAR 0 1
11553: PUSH
11554: LD_INT 22
11556: PUSH
11557: LD_INT 8
11559: PUSH
11560: EMPTY
11561: LIST
11562: LIST
11563: PUSH
11564: LD_INT 30
11566: PUSH
11567: LD_INT 2
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PUSH
11574: LD_INT 23
11576: PUSH
11577: LD_INT 3
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: LIST
11588: PPUSH
11589: CALL_OW 69
11593: IN
11594: IFFALSE 11621
// begin ComUpgrade ( building ) ;
11596: LD_VAR 0 1
11600: PPUSH
11601: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11605: LD_EXP 58
11609: PPUSH
11610: LD_VAR 0 1
11614: PPUSH
11615: CALL 60694 0 2
// exit ;
11619: GO 11630
// end ; MCE_BuildingComplete ( building ) ;
11621: LD_VAR 0 1
11625: PPUSH
11626: CALL 51519 0 1
// end ;
11630: PPOPN 1
11632: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11633: LD_VAR 0 1
11637: PPUSH
11638: LD_VAR 0 2
11642: PPUSH
11643: CALL 49574 0 2
// end ;
11647: PPOPN 2
11649: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11650: LD_VAR 0 1
11654: PPUSH
11655: LD_VAR 0 2
11659: PPUSH
11660: LD_VAR 0 3
11664: PPUSH
11665: LD_VAR 0 4
11669: PPUSH
11670: LD_VAR 0 5
11674: PPUSH
11675: CALL 49194 0 5
// end ;
11679: PPOPN 5
11681: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11682: LD_VAR 0 1
11686: PPUSH
11687: LD_VAR 0 2
11691: PPUSH
11692: CALL 110327 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11696: LD_VAR 0 1
11700: PPUSH
11701: LD_VAR 0 2
11705: PPUSH
11706: CALL 48747 0 2
// end ;
11710: PPOPN 2
11712: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11713: LD_VAR 0 1
11717: PPUSH
11718: LD_VAR 0 2
11722: PPUSH
11723: LD_VAR 0 3
11727: PPUSH
11728: LD_VAR 0 4
11732: PPUSH
11733: CALL 48585 0 4
// end ;
11737: PPOPN 4
11739: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11740: LD_VAR 0 1
11744: PPUSH
11745: LD_VAR 0 2
11749: PPUSH
11750: LD_VAR 0 3
11754: PPUSH
11755: CALL 48360 0 3
// end ;
11759: PPOPN 3
11761: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11762: LD_VAR 0 1
11766: PPUSH
11767: LD_VAR 0 2
11771: PPUSH
11772: CALL 48245 0 2
// end ;
11776: PPOPN 2
11778: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11779: LD_VAR 0 1
11783: PPUSH
11784: LD_VAR 0 2
11788: PPUSH
11789: CALL 52505 0 2
// end ;
11793: PPOPN 2
11795: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
11796: LD_VAR 0 1
11800: PUSH
11801: LD_INT 674
11803: EQUAL
11804: IFFALSE 11826
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
11806: LD_VAR 0 2
11810: PPUSH
11811: LD_INT 227
11813: PPUSH
11814: LD_INT 136
11816: PPUSH
11817: CALL_OW 428
11821: PPUSH
11822: CALL_OW 120
// end ;
11826: PPOPN 2
11828: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11829: LD_VAR 0 1
11833: PPUSH
11834: LD_VAR 0 2
11838: PPUSH
11839: LD_VAR 0 3
11843: PPUSH
11844: LD_VAR 0 4
11848: PPUSH
11849: CALL 52721 0 4
// end ;
11853: PPOPN 4
11855: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11856: LD_VAR 0 1
11860: PPUSH
11861: LD_VAR 0 2
11865: PPUSH
11866: CALL 48054 0 2
// end ;
11870: PPOPN 2
11872: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11873: LD_VAR 0 1
11877: PPUSH
11878: CALL 110311 0 1
// end ; end_of_file
11882: PPOPN 1
11884: END
// export function Action ; begin
11885: LD_INT 0
11887: PPUSH
// InGameOn ;
11888: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11892: LD_INT 206
11894: PPUSH
11895: LD_INT 11
11897: PPUSH
11898: CALL_OW 86
// wait ( 0 0$1 ) ;
11902: LD_INT 35
11904: PPUSH
11905: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11909: LD_EXP 19
11913: PPUSH
11914: LD_STRING DStart-JMM-JMM-1
11916: PPUSH
11917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11921: LD_EXP 52
11925: PPUSH
11926: LD_STRING DStart-JMM-Bur-1
11928: PPUSH
11929: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11933: LD_EXP 19
11937: PPUSH
11938: LD_STRING DStart-JMM-JMM-2
11940: PPUSH
11941: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11945: LD_EXP 52
11949: PPUSH
11950: LD_STRING DStart-JMM-Bur-2
11952: PPUSH
11953: CALL_OW 88
// InGameOff ;
11957: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11961: LD_STRING MStart
11963: PPUSH
11964: CALL_OW 337
// SaveForQuickRestart ;
11968: CALL_OW 22
// end ;
11972: LD_VAR 0 1
11976: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11977: LD_INT 7
11979: PPUSH
11980: LD_INT 255
11982: PPUSH
11983: LD_INT 219
11985: PPUSH
11986: CALL_OW 293
11990: IFFALSE 12599
11992: GO 11994
11994: DISABLE
11995: LD_INT 0
11997: PPUSH
// begin wait ( 0 0$3 ) ;
11998: LD_INT 105
12000: PPUSH
12001: CALL_OW 67
// alienSpotted := true ;
12005: LD_ADDR_EXP 10
12009: PUSH
12010: LD_INT 1
12012: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12013: LD_ADDR_VAR 0 1
12017: PUSH
12018: LD_INT 22
12020: PUSH
12021: LD_INT 7
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 23
12030: PUSH
12031: LD_INT 3
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 21
12040: PUSH
12041: LD_INT 1
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: LD_INT 26
12050: PUSH
12051: LD_INT 1
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: LIST
12062: LIST
12063: PPUSH
12064: CALL_OW 69
12068: PUSH
12069: LD_EXP 52
12073: PUSH
12074: LD_EXP 40
12078: PUSH
12079: LD_EXP 42
12083: PUSH
12084: LD_EXP 43
12088: PUSH
12089: LD_EXP 50
12093: PUSH
12094: LD_EXP 49
12098: PUSH
12099: LD_EXP 44
12103: PUSH
12104: EMPTY
12105: LIST
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: DIFF
12113: ST_TO_ADDR
// DialogueOn ;
12114: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12118: LD_INT 255
12120: PPUSH
12121: LD_INT 219
12123: PPUSH
12124: LD_INT 7
12126: PPUSH
12127: LD_INT 20
12129: NEG
12130: PPUSH
12131: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12135: LD_INT 255
12137: PPUSH
12138: LD_INT 219
12140: PPUSH
12141: CALL_OW 86
// if speaker then
12145: LD_VAR 0 1
12149: IFFALSE 12167
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12151: LD_VAR 0 1
12155: PUSH
12156: LD_INT 1
12158: ARRAY
12159: PPUSH
12160: LD_STRING DAlienBase-RSol1-1
12162: PPUSH
12163: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12167: LD_EXP 19
12171: PPUSH
12172: LD_STRING DAlienBase-JMM-1
12174: PPUSH
12175: CALL_OW 88
// if IsOk ( Burlak ) then
12179: LD_EXP 52
12183: PPUSH
12184: CALL_OW 302
12188: IFFALSE 12209
// begin dwait ( 0 0$1 ) ;
12190: LD_INT 35
12192: PPUSH
12193: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12197: LD_EXP 52
12201: PPUSH
12202: LD_STRING DAlienBase-Bur-1
12204: PPUSH
12205: CALL_OW 88
// end ; if IsOk ( Roth ) then
12209: LD_EXP 20
12213: PPUSH
12214: CALL_OW 302
12218: IFFALSE 12232
// Say ( Roth , DAlienBase-Roth-1 ) ;
12220: LD_EXP 20
12224: PPUSH
12225: LD_STRING DAlienBase-Roth-1
12227: PPUSH
12228: CALL_OW 88
// if IsOk ( Gossudarov ) then
12232: LD_EXP 38
12236: PPUSH
12237: CALL_OW 302
12241: IFFALSE 12257
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12243: LD_EXP 38
12247: PPUSH
12248: LD_STRING DAlienBase-Gos-1
12250: PPUSH
12251: CALL_OW 88
12255: GO 12374
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12257: LD_ADDR_VAR 0 1
12261: PUSH
12262: LD_INT 22
12264: PUSH
12265: LD_INT 7
12267: PUSH
12268: EMPTY
12269: LIST
12270: LIST
12271: PUSH
12272: LD_INT 25
12274: PUSH
12275: LD_INT 4
12277: PUSH
12278: EMPTY
12279: LIST
12280: LIST
12281: PUSH
12282: LD_INT 21
12284: PUSH
12285: LD_INT 1
12287: PUSH
12288: EMPTY
12289: LIST
12290: LIST
12291: PUSH
12292: LD_INT 26
12294: PUSH
12295: LD_INT 1
12297: PUSH
12298: EMPTY
12299: LIST
12300: LIST
12301: PUSH
12302: EMPTY
12303: LIST
12304: LIST
12305: LIST
12306: LIST
12307: PPUSH
12308: CALL_OW 69
12312: PUSH
12313: LD_EXP 20
12317: PUSH
12318: LD_EXP 19
12322: PUSH
12323: LD_EXP 52
12327: PUSH
12328: LD_EXP 40
12332: PUSH
12333: LD_EXP 50
12337: PUSH
12338: LD_EXP 49
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: LIST
12347: LIST
12348: LIST
12349: LIST
12350: DIFF
12351: ST_TO_ADDR
// if speaker then
12352: LD_VAR 0 1
12356: IFFALSE 12374
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12358: LD_VAR 0 1
12362: PUSH
12363: LD_INT 1
12365: ARRAY
12366: PPUSH
12367: LD_STRING DAlienBase-Sci1-1
12369: PPUSH
12370: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12374: LD_INT 255
12376: PPUSH
12377: LD_INT 219
12379: PPUSH
12380: LD_INT 7
12382: PPUSH
12383: CALL_OW 331
// DialogueOff ;
12387: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12391: LD_INT 35
12393: PPUSH
12394: CALL_OW 67
// until IsSelected ( alien ) ;
12398: LD_INT 1
12400: PPUSH
12401: CALL_OW 306
12405: IFFALSE 12391
// if not artifactIResearched or not artifactIIResearched then
12407: LD_EXP 12
12411: NOT
12412: PUSH
12413: LD_EXP 13
12417: NOT
12418: OR
12419: IFFALSE 12599
// begin if IsOk ( Roth ) then
12421: LD_EXP 20
12425: PPUSH
12426: CALL_OW 302
12430: IFFALSE 12446
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12432: LD_EXP 20
12436: PPUSH
12437: LD_STRING DAlieBaseNotReady-Roth-1
12439: PPUSH
12440: CALL_OW 88
12444: GO 12599
// if IsOk ( Gossudarov ) then
12446: LD_EXP 38
12450: PPUSH
12451: CALL_OW 302
12455: IFFALSE 12471
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12457: LD_EXP 38
12461: PPUSH
12462: LD_STRING DAlieBaseNotReady-Gos-1
12464: PPUSH
12465: CALL_OW 88
12469: GO 12599
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12471: LD_ADDR_VAR 0 1
12475: PUSH
12476: LD_INT 22
12478: PUSH
12479: LD_INT 7
12481: PUSH
12482: EMPTY
12483: LIST
12484: LIST
12485: PUSH
12486: LD_INT 23
12488: PUSH
12489: LD_INT 3
12491: PUSH
12492: EMPTY
12493: LIST
12494: LIST
12495: PUSH
12496: LD_INT 25
12498: PUSH
12499: LD_INT 4
12501: PUSH
12502: EMPTY
12503: LIST
12504: LIST
12505: PUSH
12506: LD_INT 21
12508: PUSH
12509: LD_INT 1
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: PUSH
12516: LD_INT 26
12518: PUSH
12519: LD_INT 1
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: LIST
12530: LIST
12531: LIST
12532: PPUSH
12533: CALL_OW 69
12537: PUSH
12538: LD_EXP 20
12542: PUSH
12543: LD_EXP 19
12547: PUSH
12548: LD_EXP 52
12552: PUSH
12553: LD_EXP 40
12557: PUSH
12558: LD_EXP 50
12562: PUSH
12563: LD_EXP 49
12567: PUSH
12568: EMPTY
12569: LIST
12570: LIST
12571: LIST
12572: LIST
12573: LIST
12574: LIST
12575: DIFF
12576: ST_TO_ADDR
// if speaker then
12577: LD_VAR 0 1
12581: IFFALSE 12599
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12583: LD_VAR 0 1
12587: PUSH
12588: LD_INT 1
12590: ARRAY
12591: PPUSH
12592: LD_STRING DAlieBaseNotReady-RSci1-1
12594: PPUSH
12595: CALL_OW 88
// end ; end ; end ;
12599: PPOPN 1
12601: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12602: LD_INT 24
12604: PPUSH
12605: LD_INT 7
12607: PPUSH
12608: CALL_OW 321
12612: PUSH
12613: LD_INT 2
12615: EQUAL
12616: IFFALSE 13307
12618: GO 12620
12620: DISABLE
12621: LD_INT 0
12623: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12624: LD_ADDR_VAR 0 1
12628: PUSH
12629: LD_INT 22
12631: PUSH
12632: LD_INT 7
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: LD_INT 23
12641: PUSH
12642: LD_INT 3
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: PUSH
12649: LD_INT 25
12651: PUSH
12652: LD_INT 4
12654: PUSH
12655: EMPTY
12656: LIST
12657: LIST
12658: PUSH
12659: LD_INT 21
12661: PUSH
12662: LD_INT 1
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: PUSH
12669: LD_INT 26
12671: PUSH
12672: LD_INT 1
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: PUSH
12679: EMPTY
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PPUSH
12686: CALL_OW 69
12690: PUSH
12691: LD_EXP 20
12695: PUSH
12696: LD_EXP 19
12700: PUSH
12701: LD_EXP 52
12705: PUSH
12706: LD_EXP 40
12710: PUSH
12711: LD_EXP 50
12715: PUSH
12716: LD_EXP 49
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: DIFF
12729: ST_TO_ADDR
// if not speaker then
12730: LD_VAR 0 1
12734: NOT
12735: IFFALSE 12739
// exit ;
12737: GO 13307
// DialogueOn ;
12739: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12743: LD_VAR 0 1
12747: PUSH
12748: LD_INT 1
12750: ARRAY
12751: PPUSH
12752: LD_STRING DArtefTechnology-RSci1-1
12754: PPUSH
12755: CALL_OW 88
// if IsOk ( Burlak ) then
12759: LD_EXP 52
12763: PPUSH
12764: CALL_OW 302
12768: IFFALSE 12782
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12770: LD_EXP 52
12774: PPUSH
12775: LD_STRING DArtefTechnology-Bur-1
12777: PPUSH
12778: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12782: LD_VAR 0 1
12786: PUSH
12787: LD_INT 1
12789: ARRAY
12790: PPUSH
12791: LD_STRING DArtefTechnology-RSci1-2
12793: PPUSH
12794: CALL_OW 88
// if Denis then
12798: LD_EXP 25
12802: IFFALSE 12819
// speaker := [ Denis ] else
12804: LD_ADDR_VAR 0 1
12808: PUSH
12809: LD_EXP 25
12813: PUSH
12814: EMPTY
12815: LIST
12816: ST_TO_ADDR
12817: GO 12925
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12819: LD_ADDR_VAR 0 1
12823: PUSH
12824: LD_INT 22
12826: PUSH
12827: LD_INT 7
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: PUSH
12834: LD_INT 23
12836: PUSH
12837: LD_INT 1
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: PUSH
12844: LD_INT 25
12846: PUSH
12847: LD_INT 4
12849: PUSH
12850: EMPTY
12851: LIST
12852: LIST
12853: PUSH
12854: LD_INT 21
12856: PUSH
12857: LD_INT 1
12859: PUSH
12860: EMPTY
12861: LIST
12862: LIST
12863: PUSH
12864: LD_INT 26
12866: PUSH
12867: LD_INT 1
12869: PUSH
12870: EMPTY
12871: LIST
12872: LIST
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: PPUSH
12881: CALL_OW 69
12885: PUSH
12886: LD_EXP 20
12890: PUSH
12891: LD_EXP 19
12895: PUSH
12896: LD_EXP 52
12900: PUSH
12901: LD_EXP 40
12905: PUSH
12906: LD_EXP 50
12910: PUSH
12911: LD_EXP 49
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: DIFF
12924: ST_TO_ADDR
// if speaker then
12925: LD_VAR 0 1
12929: IFFALSE 12947
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12931: LD_VAR 0 1
12935: PUSH
12936: LD_INT 1
12938: ARRAY
12939: PPUSH
12940: LD_STRING DArtefTechnology-Sci1-2
12942: PPUSH
12943: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12947: LD_ADDR_VAR 0 1
12951: PUSH
12952: LD_INT 22
12954: PUSH
12955: LD_INT 7
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: PUSH
12962: LD_INT 23
12964: PUSH
12965: LD_INT 3
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 25
12974: PUSH
12975: LD_INT 4
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 21
12984: PUSH
12985: LD_INT 1
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 26
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: LIST
13008: PPUSH
13009: CALL_OW 69
13013: PUSH
13014: LD_EXP 20
13018: PUSH
13019: LD_EXP 19
13023: PUSH
13024: LD_EXP 52
13028: PUSH
13029: LD_EXP 40
13033: PUSH
13034: LD_EXP 50
13038: PUSH
13039: LD_EXP 49
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: LIST
13048: LIST
13049: LIST
13050: LIST
13051: DIFF
13052: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13053: LD_VAR 0 1
13057: PUSH
13058: LD_EXP 9
13062: PUSH
13063: LD_EXP 5
13067: OR
13068: AND
13069: IFFALSE 13303
// begin if arabianDestroyed and IsOk ( Burlak ) then
13071: LD_EXP 5
13075: PUSH
13076: LD_EXP 52
13080: PPUSH
13081: CALL_OW 302
13085: AND
13086: IFFALSE 13102
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13088: LD_EXP 52
13092: PPUSH
13093: LD_STRING DArtefTechnology-Bur-2
13095: PPUSH
13096: CALL_OW 88
13100: GO 13114
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13102: LD_EXP 19
13106: PPUSH
13107: LD_STRING DArtefTechnology-JMM-2
13109: PPUSH
13110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13114: LD_VAR 0 1
13118: PUSH
13119: LD_INT 1
13121: ARRAY
13122: PPUSH
13123: LD_STRING DArtefTechnology-RSci1-3
13125: PPUSH
13126: CALL_OW 88
// if Denis then
13130: LD_EXP 25
13134: IFFALSE 13151
// speaker := [ Denis ] else
13136: LD_ADDR_VAR 0 1
13140: PUSH
13141: LD_EXP 25
13145: PUSH
13146: EMPTY
13147: LIST
13148: ST_TO_ADDR
13149: GO 13257
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13151: LD_ADDR_VAR 0 1
13155: PUSH
13156: LD_INT 22
13158: PUSH
13159: LD_INT 7
13161: PUSH
13162: EMPTY
13163: LIST
13164: LIST
13165: PUSH
13166: LD_INT 23
13168: PUSH
13169: LD_INT 1
13171: PUSH
13172: EMPTY
13173: LIST
13174: LIST
13175: PUSH
13176: LD_INT 25
13178: PUSH
13179: LD_INT 4
13181: PUSH
13182: EMPTY
13183: LIST
13184: LIST
13185: PUSH
13186: LD_INT 21
13188: PUSH
13189: LD_INT 1
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 26
13198: PUSH
13199: LD_INT 1
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: LIST
13210: LIST
13211: LIST
13212: PPUSH
13213: CALL_OW 69
13217: PUSH
13218: LD_EXP 20
13222: PUSH
13223: LD_EXP 19
13227: PUSH
13228: LD_EXP 52
13232: PUSH
13233: LD_EXP 40
13237: PUSH
13238: LD_EXP 50
13242: PUSH
13243: LD_EXP 49
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: LIST
13254: LIST
13255: DIFF
13256: ST_TO_ADDR
// if speaker then
13257: LD_VAR 0 1
13261: IFFALSE 13303
// if alienSpotted then
13263: LD_EXP 10
13267: IFFALSE 13287
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13269: LD_VAR 0 1
13273: PUSH
13274: LD_INT 1
13276: ARRAY
13277: PPUSH
13278: LD_STRING DArtefTechnology-Sci1-3
13280: PPUSH
13281: CALL_OW 88
13285: GO 13303
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13287: LD_VAR 0 1
13291: PUSH
13292: LD_INT 1
13294: ARRAY
13295: PPUSH
13296: LD_STRING DArtefTechnology-Sci1-3a
13298: PPUSH
13299: CALL_OW 88
// end ; DialogueOff ;
13303: CALL_OW 7
// end ;
13307: PPOPN 1
13309: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13310: LD_EXP 12
13314: IFFALSE 13517
13316: GO 13318
13318: DISABLE
13319: LD_INT 0
13321: PPUSH
// begin if Denis then
13322: LD_EXP 25
13326: IFFALSE 13343
// speaker := [ Denis ] else
13328: LD_ADDR_VAR 0 1
13332: PUSH
13333: LD_EXP 25
13337: PUSH
13338: EMPTY
13339: LIST
13340: ST_TO_ADDR
13341: GO 13449
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13343: LD_ADDR_VAR 0 1
13347: PUSH
13348: LD_INT 22
13350: PUSH
13351: LD_INT 7
13353: PUSH
13354: EMPTY
13355: LIST
13356: LIST
13357: PUSH
13358: LD_INT 23
13360: PUSH
13361: LD_INT 1
13363: PUSH
13364: EMPTY
13365: LIST
13366: LIST
13367: PUSH
13368: LD_INT 25
13370: PUSH
13371: LD_INT 4
13373: PUSH
13374: EMPTY
13375: LIST
13376: LIST
13377: PUSH
13378: LD_INT 21
13380: PUSH
13381: LD_INT 1
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: PUSH
13388: LD_INT 26
13390: PUSH
13391: LD_INT 1
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: LIST
13402: LIST
13403: LIST
13404: PPUSH
13405: CALL_OW 69
13409: PUSH
13410: LD_EXP 20
13414: PUSH
13415: LD_EXP 19
13419: PUSH
13420: LD_EXP 52
13424: PUSH
13425: LD_EXP 40
13429: PUSH
13430: LD_EXP 50
13434: PUSH
13435: LD_EXP 49
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: DIFF
13448: ST_TO_ADDR
// if not speaker then
13449: LD_VAR 0 1
13453: NOT
13454: IFFALSE 13458
// exit ;
13456: GO 13517
// DialogueOn ;
13458: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13462: LD_VAR 0 1
13466: PUSH
13467: LD_INT 1
13469: ARRAY
13470: PPUSH
13471: LD_STRING DArtefTechnologyAm-Sci1-1
13473: PPUSH
13474: CALL_OW 88
// if IsOk ( Burlak ) then
13478: LD_EXP 52
13482: PPUSH
13483: CALL_OW 302
13487: IFFALSE 13501
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13489: LD_EXP 52
13493: PPUSH
13494: LD_STRING DArtefTechnologyAm-Bur-1
13496: PPUSH
13497: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13501: LD_EXP 19
13505: PPUSH
13506: LD_STRING DArtefTechnologyAm-JMM-1
13508: PPUSH
13509: CALL_OW 88
// DialogueOff ;
13513: CALL_OW 7
// end ;
13517: PPOPN 1
13519: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13520: LD_EXP 13
13524: IFFALSE 13726
13526: GO 13528
13528: DISABLE
13529: LD_INT 0
13531: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13532: LD_ADDR_VAR 0 1
13536: PUSH
13537: LD_INT 22
13539: PUSH
13540: LD_INT 7
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: LD_INT 23
13549: PUSH
13550: LD_INT 3
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PUSH
13557: LD_INT 25
13559: PUSH
13560: LD_INT 4
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 21
13569: PUSH
13570: LD_INT 1
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: PUSH
13577: LD_INT 26
13579: PUSH
13580: LD_INT 1
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: PPUSH
13594: CALL_OW 69
13598: PUSH
13599: LD_EXP 20
13603: PUSH
13604: LD_EXP 19
13608: PUSH
13609: LD_EXP 52
13613: PUSH
13614: LD_EXP 40
13618: PUSH
13619: LD_EXP 50
13623: PUSH
13624: LD_EXP 49
13628: PUSH
13629: EMPTY
13630: LIST
13631: LIST
13632: LIST
13633: LIST
13634: LIST
13635: LIST
13636: DIFF
13637: ST_TO_ADDR
// if not speaker then
13638: LD_VAR 0 1
13642: NOT
13643: IFFALSE 13647
// exit ;
13645: GO 13726
// DialogueOn ;
13647: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13651: LD_VAR 0 1
13655: PUSH
13656: LD_VAR 0 1
13660: ARRAY
13661: PPUSH
13662: LD_STRING DArtefTechnologyRu-RSci1-1
13664: PPUSH
13665: CALL_OW 88
// if IsOk ( Burlak ) then
13669: LD_EXP 52
13673: PPUSH
13674: CALL_OW 302
13678: IFFALSE 13692
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13680: LD_EXP 52
13684: PPUSH
13685: LD_STRING DArtefTechnologyRu-Bur-1
13687: PPUSH
13688: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13692: LD_VAR 0 1
13696: PUSH
13697: LD_VAR 0 1
13701: ARRAY
13702: PPUSH
13703: LD_STRING DArtefTechnologyRu-RSci1-2
13705: PPUSH
13706: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13710: LD_EXP 19
13714: PPUSH
13715: LD_STRING DArtefTechnologyRu-JMM-1
13717: PPUSH
13718: CALL_OW 88
// DialogueOff ;
13722: CALL_OW 7
// end ;
13726: PPOPN 1
13728: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13729: LD_INT 24
13731: PPUSH
13732: LD_INT 7
13734: PPUSH
13735: CALL_OW 321
13739: PUSH
13740: LD_INT 2
13742: EQUAL
13743: PUSH
13744: LD_INT 1
13746: PPUSH
13747: CALL_OW 255
13751: PUSH
13752: LD_INT 7
13754: EQUAL
13755: AND
13756: IFFALSE 13924
13758: GO 13760
13760: DISABLE
13761: LD_INT 0
13763: PPUSH
// begin if Denis then
13764: LD_EXP 25
13768: IFFALSE 13785
// speaker := [ Denis ] else
13770: LD_ADDR_VAR 0 1
13774: PUSH
13775: LD_EXP 25
13779: PUSH
13780: EMPTY
13781: LIST
13782: ST_TO_ADDR
13783: GO 13891
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13785: LD_ADDR_VAR 0 1
13789: PUSH
13790: LD_INT 22
13792: PUSH
13793: LD_INT 7
13795: PUSH
13796: EMPTY
13797: LIST
13798: LIST
13799: PUSH
13800: LD_INT 23
13802: PUSH
13803: LD_INT 1
13805: PUSH
13806: EMPTY
13807: LIST
13808: LIST
13809: PUSH
13810: LD_INT 25
13812: PUSH
13813: LD_INT 4
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: PUSH
13820: LD_INT 21
13822: PUSH
13823: LD_INT 1
13825: PUSH
13826: EMPTY
13827: LIST
13828: LIST
13829: PUSH
13830: LD_INT 26
13832: PUSH
13833: LD_INT 1
13835: PUSH
13836: EMPTY
13837: LIST
13838: LIST
13839: PUSH
13840: EMPTY
13841: LIST
13842: LIST
13843: LIST
13844: LIST
13845: LIST
13846: PPUSH
13847: CALL_OW 69
13851: PUSH
13852: LD_EXP 20
13856: PUSH
13857: LD_EXP 19
13861: PUSH
13862: LD_EXP 52
13866: PUSH
13867: LD_EXP 40
13871: PUSH
13872: LD_EXP 50
13876: PUSH
13877: LD_EXP 49
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: DIFF
13890: ST_TO_ADDR
// if not speaker then
13891: LD_VAR 0 1
13895: NOT
13896: IFFALSE 13900
// exit ;
13898: GO 13924
// DialogueOn ;
13900: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13904: LD_VAR 0 1
13908: PUSH
13909: LD_INT 1
13911: ARRAY
13912: PPUSH
13913: LD_STRING DArtefTechnologyArStart-Sci1-1
13915: PPUSH
13916: CALL_OW 88
// DialogueOff ;
13920: CALL_OW 7
// end ;
13924: PPOPN 1
13926: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13927: LD_EXP 14
13931: IFFALSE 14212
13933: GO 13935
13935: DISABLE
13936: LD_INT 0
13938: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13939: LD_ADDR_VAR 0 1
13943: PUSH
13944: LD_INT 22
13946: PUSH
13947: LD_INT 7
13949: PUSH
13950: EMPTY
13951: LIST
13952: LIST
13953: PUSH
13954: LD_INT 23
13956: PUSH
13957: LD_INT 3
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 25
13966: PUSH
13967: LD_INT 4
13969: PUSH
13970: EMPTY
13971: LIST
13972: LIST
13973: PUSH
13974: LD_INT 21
13976: PUSH
13977: LD_INT 1
13979: PUSH
13980: EMPTY
13981: LIST
13982: LIST
13983: PUSH
13984: LD_INT 26
13986: PUSH
13987: LD_INT 1
13989: PUSH
13990: EMPTY
13991: LIST
13992: LIST
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: PPUSH
14001: CALL_OW 69
14005: PUSH
14006: LD_EXP 20
14010: PUSH
14011: LD_EXP 19
14015: PUSH
14016: LD_EXP 52
14020: PUSH
14021: LD_EXP 40
14025: PUSH
14026: LD_EXP 50
14030: PUSH
14031: LD_EXP 49
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: DIFF
14044: ST_TO_ADDR
// if not speaker then
14045: LD_VAR 0 1
14049: NOT
14050: IFFALSE 14054
// exit ;
14052: GO 14212
// DialogueOn ;
14054: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14058: LD_VAR 0 1
14062: PUSH
14063: LD_INT 1
14065: ARRAY
14066: PPUSH
14067: LD_STRING DArtefTechnologyAr-RSci1-1
14069: PPUSH
14070: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14074: LD_EXP 19
14078: PPUSH
14079: LD_STRING DArtefTechnologyAr-JMM-1
14081: PPUSH
14082: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14086: LD_VAR 0 1
14090: PUSH
14091: LD_INT 1
14093: ARRAY
14094: PPUSH
14095: LD_STRING DArtefTechnologyAr-RSci1-2
14097: PPUSH
14098: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14102: LD_EXP 19
14106: PPUSH
14107: LD_STRING DArtefTechnologyAr-JMM-2
14109: PPUSH
14110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14114: LD_VAR 0 1
14118: PUSH
14119: LD_INT 1
14121: ARRAY
14122: PPUSH
14123: LD_STRING DArtefTechnologyAr-RSci1-3
14125: PPUSH
14126: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14130: LD_EXP 19
14134: PPUSH
14135: LD_STRING DArtefTechnologyAr-JMM-3
14137: PPUSH
14138: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14142: LD_VAR 0 1
14146: PUSH
14147: LD_INT 1
14149: ARRAY
14150: PPUSH
14151: LD_STRING DArtefTechnologyAr-RSci1-4
14153: PPUSH
14154: CALL_OW 88
// if IsOk ( Burlak ) then
14158: LD_EXP 52
14162: PPUSH
14163: CALL_OW 302
14167: IFFALSE 14181
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14169: LD_EXP 52
14173: PPUSH
14174: LD_STRING DArtefTechnologyAr-Bur-4
14176: PPUSH
14177: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14181: LD_EXP 19
14185: PPUSH
14186: LD_STRING DArtefTechnologyAr-JMM-4
14188: PPUSH
14189: CALL_OW 88
// DialogueOff ;
14193: CALL_OW 7
// wait ( 0 0$45 ) ;
14197: LD_INT 1575
14199: PPUSH
14200: CALL_OW 67
// spawnOmar := true ;
14204: LD_ADDR_EXP 11
14208: PUSH
14209: LD_INT 1
14211: ST_TO_ADDR
// end ;
14212: PPOPN 1
14214: END
// every 0 0$1 trigger spawnOmar do
14215: LD_EXP 11
14219: IFFALSE 14599
14221: GO 14223
14223: DISABLE
// begin PrepareOmarAli ;
14224: CALL 7368 0 0
// if not HasTask ( Omar ) then
14228: LD_EXP 56
14232: PPUSH
14233: CALL_OW 314
14237: NOT
14238: IFFALSE 14255
// ComMoveXY ( Omar , 252 , 220 ) ;
14240: LD_EXP 56
14244: PPUSH
14245: LD_INT 252
14247: PPUSH
14248: LD_INT 220
14250: PPUSH
14251: CALL_OW 111
// if not Omar then
14255: LD_EXP 56
14259: NOT
14260: IFFALSE 14264
// exit ;
14262: GO 14599
// repeat wait ( 0 0$1 ) ;
14264: LD_INT 35
14266: PPUSH
14267: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14271: LD_EXP 56
14275: PPUSH
14276: CALL_OW 314
14280: NOT
14281: PUSH
14282: LD_EXP 56
14286: PPUSH
14287: LD_INT 252
14289: PPUSH
14290: LD_INT 220
14292: PPUSH
14293: CALL_OW 297
14297: PUSH
14298: LD_INT 6
14300: GREATER
14301: AND
14302: IFFALSE 14319
// ComMoveXY ( Omar , 252 , 220 ) ;
14304: LD_EXP 56
14308: PPUSH
14309: LD_INT 252
14311: PPUSH
14312: LD_INT 220
14314: PPUSH
14315: CALL_OW 111
// until See ( 7 , Omar ) ;
14319: LD_INT 7
14321: PPUSH
14322: LD_EXP 56
14326: PPUSH
14327: CALL_OW 292
14331: IFFALSE 14264
// CenterNowOnUnits ( Omar ) ;
14333: LD_EXP 56
14337: PPUSH
14338: CALL_OW 87
// DialogueOn ;
14342: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14346: LD_EXP 56
14350: PPUSH
14351: LD_STRING DOmar-Omar-1
14353: PPUSH
14354: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14358: LD_EXP 19
14362: PPUSH
14363: LD_STRING DOmar-JMM-1
14365: PPUSH
14366: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14370: LD_EXP 56
14374: PPUSH
14375: LD_STRING DOmar-Omar-2
14377: PPUSH
14378: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14382: LD_EXP 19
14386: PPUSH
14387: LD_STRING DOmar-JMM-2
14389: PPUSH
14390: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14394: LD_EXP 56
14398: PPUSH
14399: LD_STRING DOmar-Omar-3
14401: PPUSH
14402: CALL_OW 88
// if IsOk ( Burlak ) then
14406: LD_EXP 52
14410: PPUSH
14411: CALL_OW 302
14415: IFFALSE 14431
// Say ( Burlak , DOmar-Bur-3 ) else
14417: LD_EXP 52
14421: PPUSH
14422: LD_STRING DOmar-Bur-3
14424: PPUSH
14425: CALL_OW 88
14429: GO 14443
// Say ( JMM , DOmar-JMM-3 ) ;
14431: LD_EXP 19
14435: PPUSH
14436: LD_STRING DOmar-JMM-3
14438: PPUSH
14439: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14443: LD_EXP 56
14447: PPUSH
14448: LD_STRING DOmar-Omar-4
14450: PPUSH
14451: CALL_OW 88
// case Query ( QAccept ) of 1 :
14455: LD_STRING QAccept
14457: PPUSH
14458: CALL_OW 97
14462: PUSH
14463: LD_INT 1
14465: DOUBLE
14466: EQUAL
14467: IFTRUE 14471
14469: GO 14507
14471: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14472: LD_EXP 19
14476: PPUSH
14477: LD_STRING DQrAccept#1-JMM-1
14479: PPUSH
14480: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14484: LD_EXP 56
14488: PPUSH
14489: LD_INT 7
14491: PPUSH
14492: CALL_OW 235
// ComStop ( Omar ) ;
14496: LD_EXP 56
14500: PPUSH
14501: CALL_OW 141
// end ; 2 :
14505: GO 14556
14507: LD_INT 2
14509: DOUBLE
14510: EQUAL
14511: IFTRUE 14515
14513: GO 14555
14515: POP
// begin if IsOk ( Burlak ) then
14516: LD_EXP 52
14520: PPUSH
14521: CALL_OW 302
14525: IFFALSE 14541
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14527: LD_EXP 52
14531: PPUSH
14532: LD_STRING DQrAccept#2-Bur-1
14534: PPUSH
14535: CALL_OW 88
14539: GO 14553
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14541: LD_EXP 19
14545: PPUSH
14546: LD_STRING DQrAccept#2-JMM-1
14548: PPUSH
14549: CALL_OW 88
// end ; end ;
14553: GO 14556
14555: POP
// DialogueOff ;
14556: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14560: LD_EXP 56
14564: PPUSH
14565: CALL_OW 255
14569: PUSH
14570: LD_INT 7
14572: EQUAL
14573: IFFALSE 14584
// begin SetAchievement ( ACH_OMAR ) ;
14575: LD_STRING ACH_OMAR
14577: PPUSH
14578: CALL_OW 543
// exit ;
14582: GO 14599
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14584: LD_EXP 56
14588: PPUSH
14589: LD_INT 202
14591: PPUSH
14592: LD_INT 115
14594: PPUSH
14595: CALL_OW 111
// end ;
14599: END
// every 0 0$1 trigger IsOk ( Omar ) and russianDestroyed do var i ;
14600: LD_EXP 56
14604: PPUSH
14605: CALL_OW 302
14609: PUSH
14610: LD_EXP 2
14614: AND
14615: IFFALSE 15100
14617: GO 14619
14619: DISABLE
14620: LD_INT 0
14622: PPUSH
// begin SetSide ( Omar , 5 ) ;
14623: LD_EXP 56
14627: PPUSH
14628: LD_INT 5
14630: PPUSH
14631: CALL_OW 235
// if IsInUnit ( Omar ) then
14635: LD_EXP 56
14639: PPUSH
14640: CALL_OW 310
14644: IFFALSE 14655
// ComExitVehicle ( Omar ) ;
14646: LD_EXP 56
14650: PPUSH
14651: CALL_OW 121
// if IsInUnit ( Omar ) then
14655: LD_EXP 56
14659: PPUSH
14660: CALL_OW 310
14664: IFFALSE 14675
// ComExitBuilding ( Omar ) ;
14666: LD_EXP 56
14670: PPUSH
14671: CALL_OW 122
// wait ( 0 0$1 ) ;
14675: LD_INT 35
14677: PPUSH
14678: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14682: LD_EXP 56
14686: PPUSH
14687: LD_INT 203
14689: PPUSH
14690: LD_INT 120
14692: PPUSH
14693: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14697: LD_INT 35
14699: PPUSH
14700: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
14704: LD_EXP 56
14708: PPUSH
14709: CALL_OW 306
14713: PUSH
14714: LD_EXP 56
14718: PPUSH
14719: LD_INT 203
14721: PPUSH
14722: LD_INT 120
14724: PPUSH
14725: CALL_OW 297
14729: PUSH
14730: LD_INT 20
14732: LESS
14733: OR
14734: IFFALSE 14697
// DialogueOn ;
14736: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
14740: LD_EXP 56
14744: PPUSH
14745: CALL_OW 250
14749: PPUSH
14750: LD_EXP 56
14754: PPUSH
14755: CALL_OW 251
14759: PPUSH
14760: LD_INT 7
14762: PPUSH
14763: LD_INT 6
14765: NEG
14766: PPUSH
14767: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
14771: LD_EXP 56
14775: PPUSH
14776: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
14780: LD_EXP 19
14784: PPUSH
14785: LD_STRING DOmarContam-JMM-1
14787: PPUSH
14788: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14792: LD_EXP 56
14796: PPUSH
14797: LD_STRING DOmarContam-Omar-1
14799: PPUSH
14800: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14804: LD_EXP 19
14808: PPUSH
14809: LD_STRING DOmarContam-JMM-2
14811: PPUSH
14812: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
14816: LD_EXP 56
14820: PPUSH
14821: CALL_OW 250
14825: PPUSH
14826: LD_EXP 56
14830: PPUSH
14831: CALL_OW 251
14835: PPUSH
14836: LD_INT 7
14838: PPUSH
14839: CALL_OW 331
// DialogueOff ;
14843: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14847: LD_INT 5
14849: PPUSH
14850: LD_INT 7
14852: PPUSH
14853: LD_INT 2
14855: PPUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14863: LD_INT 105
14865: PPUSH
14866: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14870: LD_EXP 56
14874: PPUSH
14875: LD_INT 203
14877: PPUSH
14878: LD_INT 120
14880: PPUSH
14881: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) ;
14885: LD_EXP 56
14889: PPUSH
14890: LD_INT 203
14892: PPUSH
14893: LD_INT 120
14895: PPUSH
14896: CALL_OW 307
14900: IFFALSE 14863
// ComHold ( Omar ) ;
14902: LD_EXP 56
14906: PPUSH
14907: CALL_OW 140
// InGameOn ;
14911: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
14915: LD_INT 203
14917: PPUSH
14918: LD_INT 120
14920: PPUSH
14921: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
14925: LD_INT 203
14927: PPUSH
14928: LD_INT 120
14930: PPUSH
14931: LD_INT 7
14933: PPUSH
14934: LD_INT 30
14936: NEG
14937: PPUSH
14938: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
14942: LD_ADDR_VAR 0 1
14946: PUSH
14947: LD_INT 203
14949: PUSH
14950: LD_INT 120
14952: PUSH
14953: EMPTY
14954: LIST
14955: LIST
14956: PUSH
14957: LD_INT 202
14959: PUSH
14960: LD_INT 125
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PUSH
14967: LD_INT 195
14969: PUSH
14970: LD_INT 117
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: PUSH
14977: LD_INT 216
14979: PUSH
14980: LD_INT 123
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PUSH
14987: LD_INT 224
14989: PUSH
14990: LD_INT 131
14992: PUSH
14993: EMPTY
14994: LIST
14995: LIST
14996: PUSH
14997: LD_INT 212
14999: PUSH
15000: LD_INT 133
15002: PUSH
15003: EMPTY
15004: LIST
15005: LIST
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: PUSH
15015: FOR_IN
15016: IFFALSE 15052
// begin wait ( 0 0$0.5 ) ;
15018: LD_INT 18
15020: PPUSH
15021: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15025: LD_VAR 0 1
15029: PUSH
15030: LD_INT 1
15032: ARRAY
15033: PPUSH
15034: LD_VAR 0 1
15038: PUSH
15039: LD_INT 2
15041: ARRAY
15042: PPUSH
15043: LD_INT 5
15045: PPUSH
15046: CALL_OW 495
// end ;
15050: GO 15015
15052: POP
15053: POP
// KillUnit ( Omar ) ;
15054: LD_EXP 56
15058: PPUSH
15059: CALL_OW 66
// wait ( 0 0$3 ) ;
15063: LD_INT 105
15065: PPUSH
15066: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15070: LD_EXP 19
15074: PPUSH
15075: LD_STRING D16b-JMM-1
15077: PPUSH
15078: CALL_OW 91
// wait ( 0 0$2 ) ;
15082: LD_INT 70
15084: PPUSH
15085: CALL_OW 67
// InGameOff ;
15089: CALL_OW 9
// YouLost ( MothContaminate ) ;
15093: LD_STRING MothContaminate
15095: PPUSH
15096: CALL_OW 104
// end ;
15100: PPOPN 1
15102: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15103: LD_EXP 4
15107: NOT
15108: PUSH
15109: LD_INT 22
15111: PUSH
15112: LD_INT 1
15114: PUSH
15115: EMPTY
15116: LIST
15117: LIST
15118: PUSH
15119: LD_INT 34
15121: PUSH
15122: LD_INT 8
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: PUSH
15129: EMPTY
15130: LIST
15131: LIST
15132: PPUSH
15133: CALL_OW 69
15137: AND
15138: IFFALSE 15257
15140: GO 15142
15142: DISABLE
// begin wait ( 0 0$10 ) ;
15143: LD_INT 350
15145: PPUSH
15146: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15150: LD_EXP 55
15154: PPUSH
15155: CALL_OW 302
15159: NOT
15160: PUSH
15161: LD_INT 22
15163: PUSH
15164: LD_INT 1
15166: PUSH
15167: EMPTY
15168: LIST
15169: LIST
15170: PUSH
15171: LD_INT 34
15173: PUSH
15174: LD_INT 8
15176: PUSH
15177: EMPTY
15178: LIST
15179: LIST
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PPUSH
15185: CALL_OW 69
15189: NOT
15190: OR
15191: IFFALSE 15195
// exit ;
15193: GO 15257
// DialogueOn ;
15195: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
15199: LD_EXP 55
15203: PPUSH
15204: LD_STRING DWinAmericans-Pow-1
15206: PPUSH
15207: CALL_OW 94
// if IsOk ( Burlak ) then
15211: LD_EXP 52
15215: PPUSH
15216: CALL_OW 302
15220: IFFALSE 15234
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
15222: LD_EXP 52
15226: PPUSH
15227: LD_STRING DWinAmericans-Bur-1
15229: PPUSH
15230: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
15234: LD_EXP 19
15238: PPUSH
15239: LD_STRING DWinAmericans-JMM-1
15241: PPUSH
15242: CALL_OW 88
// DialogueOff ;
15246: CALL_OW 7
// YouLost ( AmBomb ) ;
15250: LD_STRING AmBomb
15252: PPUSH
15253: CALL_OW 104
// end ;
15257: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
15258: LD_EXP 2
15262: NOT
15263: PUSH
15264: LD_INT 22
15266: PUSH
15267: LD_INT 3
15269: PUSH
15270: EMPTY
15271: LIST
15272: LIST
15273: PUSH
15274: LD_INT 34
15276: PUSH
15277: LD_INT 48
15279: PUSH
15280: EMPTY
15281: LIST
15282: LIST
15283: PUSH
15284: EMPTY
15285: LIST
15286: LIST
15287: PPUSH
15288: CALL_OW 69
15292: AND
15293: IFFALSE 15412
15295: GO 15297
15297: DISABLE
// begin wait ( 0 0$10 ) ;
15298: LD_INT 350
15300: PPUSH
15301: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
15305: LD_EXP 60
15309: PPUSH
15310: CALL_OW 302
15314: NOT
15315: PUSH
15316: LD_INT 22
15318: PUSH
15319: LD_INT 3
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: LD_INT 34
15328: PUSH
15329: LD_INT 48
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: PUSH
15336: EMPTY
15337: LIST
15338: LIST
15339: PPUSH
15340: CALL_OW 69
15344: NOT
15345: OR
15346: IFFALSE 15350
// exit ;
15348: GO 15412
// DialogueOn ;
15350: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
15354: LD_EXP 60
15358: PPUSH
15359: LD_STRING DWinRussians-Pla-1
15361: PPUSH
15362: CALL_OW 94
// if IsOk ( Burlak ) then
15366: LD_EXP 52
15370: PPUSH
15371: CALL_OW 302
15375: IFFALSE 15389
// Say ( Burlak , DWinRussians-Bur-1 ) ;
15377: LD_EXP 52
15381: PPUSH
15382: LD_STRING DWinRussians-Bur-1
15384: PPUSH
15385: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
15389: LD_EXP 19
15393: PPUSH
15394: LD_STRING DWinRussians-JMM-1
15396: PPUSH
15397: CALL_OW 88
// DialogueOff ;
15401: CALL_OW 7
// YouLost ( RuBomb ) ;
15405: LD_STRING RuBomb
15407: PPUSH
15408: CALL_OW 104
// end ;
15412: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
15413: LD_INT 7
15415: PPUSH
15416: LD_INT 22
15418: PUSH
15419: LD_INT 7
15421: PUSH
15422: EMPTY
15423: LIST
15424: LIST
15425: PPUSH
15426: CALL_OW 70
15430: PUSH
15431: LD_EXP 4
15435: NOT
15436: AND
15437: IFFALSE 15466
15439: GO 15441
15441: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
15442: LD_EXP 55
15446: PPUSH
15447: LD_STRING DSurrenderAmericans-Pow-1
15449: PPUSH
15450: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
15454: LD_EXP 19
15458: PPUSH
15459: LD_STRING DSurrenderAmericans-JMM-1
15461: PPUSH
15462: CALL_OW 88
// end ;
15466: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
15467: LD_INT 2
15469: PPUSH
15470: LD_INT 22
15472: PUSH
15473: LD_INT 7
15475: PUSH
15476: EMPTY
15477: LIST
15478: LIST
15479: PPUSH
15480: CALL_OW 70
15484: PUSH
15485: LD_EXP 2
15489: NOT
15490: AND
15491: PUSH
15492: LD_EXP 52
15496: AND
15497: IFFALSE 15526
15499: GO 15501
15501: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
15502: LD_EXP 60
15506: PPUSH
15507: LD_STRING DSurrenderRussians-Pla-1
15509: PPUSH
15510: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
15514: LD_EXP 52
15518: PPUSH
15519: LD_STRING DSurrenderRussians-Bur-1
15521: PPUSH
15522: CALL_OW 88
// end ;
15526: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
15527: LD_EXP 4
15531: IFFALSE 15963
15533: GO 15535
15535: DISABLE
15536: LD_INT 0
15538: PPUSH
15539: PPUSH
15540: PPUSH
// begin MC_Kill ( 4 ) ;
15541: LD_INT 4
15543: PPUSH
15544: CALL 22411 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
15548: LD_INT 1
15550: PPUSH
15551: LD_INT 7
15553: PPUSH
15554: LD_INT 1
15556: PPUSH
15557: LD_INT 1
15559: PPUSH
15560: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
15564: LD_ADDR_VAR 0 3
15568: PUSH
15569: LD_INT 22
15571: PUSH
15572: LD_INT 1
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: PUSH
15579: LD_INT 26
15581: PUSH
15582: LD_INT 1
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: LD_INT 23
15591: PUSH
15592: LD_INT 1
15594: PUSH
15595: EMPTY
15596: LIST
15597: LIST
15598: PUSH
15599: EMPTY
15600: LIST
15601: LIST
15602: LIST
15603: PPUSH
15604: CALL_OW 69
15608: PUSH
15609: LD_EXP 55
15613: PUSH
15614: LD_EXP 27
15618: PUSH
15619: LD_EXP 24
15623: PUSH
15624: LD_EXP 23
15628: PUSH
15629: LD_EXP 30
15633: PUSH
15634: LD_EXP 28
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: LIST
15643: LIST
15644: LIST
15645: LIST
15646: DIFF
15647: ST_TO_ADDR
// if not speaker then
15648: LD_VAR 0 3
15652: NOT
15653: IFFALSE 15693
// begin uc_side := 1 ;
15655: LD_ADDR_OWVAR 20
15659: PUSH
15660: LD_INT 1
15662: ST_TO_ADDR
// uc_nation := 1 ;
15663: LD_ADDR_OWVAR 21
15667: PUSH
15668: LD_INT 1
15670: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
15671: LD_INT 1
15673: PPUSH
15674: LD_INT 0
15676: PPUSH
15677: CALL_OW 381
// speaker := CreateHuman ;
15681: LD_ADDR_VAR 0 3
15685: PUSH
15686: CALL_OW 44
15690: ST_TO_ADDR
// end else
15691: GO 15707
// speaker := speaker [ 1 ] ;
15693: LD_ADDR_VAR 0 3
15697: PUSH
15698: LD_VAR 0 3
15702: PUSH
15703: LD_INT 1
15705: ARRAY
15706: ST_TO_ADDR
// DialogueOn ;
15707: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
15711: LD_VAR 0 3
15715: PPUSH
15716: LD_STRING DSurrenderAmericans-Sol1-1a
15718: PPUSH
15719: CALL_OW 94
// DialogueOff ;
15723: CALL_OW 7
// americanCapitulated := true ;
15727: LD_ADDR_EXP 6
15731: PUSH
15732: LD_INT 1
15734: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15735: LD_ADDR_VAR 0 2
15739: PUSH
15740: LD_INT 22
15742: PUSH
15743: LD_INT 1
15745: PUSH
15746: EMPTY
15747: LIST
15748: LIST
15749: PUSH
15750: LD_INT 21
15752: PUSH
15753: LD_INT 1
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: PUSH
15760: EMPTY
15761: LIST
15762: LIST
15763: PPUSH
15764: CALL_OW 69
15768: PUSH
15769: LD_INT 22
15771: PUSH
15772: LD_INT 1
15774: PUSH
15775: EMPTY
15776: LIST
15777: LIST
15778: PUSH
15779: LD_INT 21
15781: PUSH
15782: LD_INT 2
15784: PUSH
15785: EMPTY
15786: LIST
15787: LIST
15788: PUSH
15789: LD_INT 1
15791: PUSH
15792: EMPTY
15793: LIST
15794: PUSH
15795: EMPTY
15796: LIST
15797: LIST
15798: LIST
15799: PPUSH
15800: CALL_OW 69
15804: ADD
15805: ST_TO_ADDR
// if tmp then
15806: LD_VAR 0 2
15810: IFFALSE 15963
// repeat wait ( 0 0$1 ) ;
15812: LD_INT 35
15814: PPUSH
15815: CALL_OW 67
// for i in tmp do
15819: LD_ADDR_VAR 0 1
15823: PUSH
15824: LD_VAR 0 2
15828: PUSH
15829: FOR_IN
15830: IFFALSE 15912
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15832: LD_VAR 0 1
15836: PPUSH
15837: CALL_OW 310
15841: PUSH
15842: LD_VAR 0 1
15846: PPUSH
15847: CALL_OW 310
15851: PPUSH
15852: CALL_OW 247
15856: PUSH
15857: LD_INT 3
15859: EQUAL
15860: AND
15861: IFFALSE 15872
// ComExitBuilding ( i ) ;
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15872: LD_VAR 0 1
15876: PPUSH
15877: LD_INT 122
15879: PPUSH
15880: LD_INT 242
15882: PPUSH
15883: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15887: LD_VAR 0 1
15891: PPUSH
15892: LD_INT 35
15894: PPUSH
15895: CALL_OW 308
15899: IFFALSE 15910
// RemoveUnit ( i ) ;
15901: LD_VAR 0 1
15905: PPUSH
15906: CALL_OW 64
// end ;
15910: GO 15829
15912: POP
15913: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15914: LD_INT 22
15916: PUSH
15917: LD_INT 1
15919: PUSH
15920: EMPTY
15921: LIST
15922: LIST
15923: PUSH
15924: LD_INT 2
15926: PUSH
15927: LD_INT 21
15929: PUSH
15930: LD_INT 1
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: PUSH
15937: LD_INT 33
15939: PUSH
15940: LD_INT 1
15942: PUSH
15943: EMPTY
15944: LIST
15945: LIST
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: LIST
15951: PUSH
15952: EMPTY
15953: LIST
15954: LIST
15955: PPUSH
15956: CALL_OW 69
15960: NOT
15961: IFFALSE 15812
// end ;
15963: PPOPN 3
15965: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15966: LD_EXP 2
15970: IFFALSE 16412
15972: GO 15974
15974: DISABLE
15975: LD_INT 0
15977: PPUSH
15978: PPUSH
15979: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15980: LD_INT 35
15982: PPUSH
15983: CALL_OW 67
// until IsDead ( Yakotich ) ;
15987: LD_EXP 61
15991: PPUSH
15992: CALL_OW 301
15996: IFFALSE 15980
// MC_Kill ( 2 ) ;
15998: LD_INT 2
16000: PPUSH
16001: CALL 22411 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16005: LD_INT 3
16007: PPUSH
16008: LD_INT 7
16010: PPUSH
16011: LD_INT 1
16013: PPUSH
16014: LD_INT 1
16016: PPUSH
16017: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16021: LD_ADDR_VAR 0 3
16025: PUSH
16026: LD_INT 22
16028: PUSH
16029: LD_INT 3
16031: PUSH
16032: EMPTY
16033: LIST
16034: LIST
16035: PUSH
16036: LD_INT 26
16038: PUSH
16039: LD_INT 1
16041: PUSH
16042: EMPTY
16043: LIST
16044: LIST
16045: PUSH
16046: LD_INT 23
16048: PUSH
16049: LD_INT 3
16051: PUSH
16052: EMPTY
16053: LIST
16054: LIST
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: LIST
16060: PPUSH
16061: CALL_OW 69
16065: PUSH
16066: LD_EXP 60
16070: DIFF
16071: ST_TO_ADDR
// if not speaker then
16072: LD_VAR 0 3
16076: NOT
16077: IFFALSE 16117
// begin uc_side := 3 ;
16079: LD_ADDR_OWVAR 20
16083: PUSH
16084: LD_INT 3
16086: ST_TO_ADDR
// uc_nation := 3 ;
16087: LD_ADDR_OWVAR 21
16091: PUSH
16092: LD_INT 3
16094: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16095: LD_INT 1
16097: PPUSH
16098: LD_INT 0
16100: PPUSH
16101: CALL_OW 381
// speaker := CreateHuman ;
16105: LD_ADDR_VAR 0 3
16109: PUSH
16110: CALL_OW 44
16114: ST_TO_ADDR
// end else
16115: GO 16131
// speaker := speaker [ 1 ] ;
16117: LD_ADDR_VAR 0 3
16121: PUSH
16122: LD_VAR 0 3
16126: PUSH
16127: LD_INT 1
16129: ARRAY
16130: ST_TO_ADDR
// DialogueOn ;
16131: CALL_OW 6
// if IsOK ( Burlak ) then
16135: LD_EXP 52
16139: PPUSH
16140: CALL_OW 302
16144: IFFALSE 16160
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16146: LD_VAR 0 3
16150: PPUSH
16151: LD_STRING DSurrenderRussians-RSol1-1
16153: PPUSH
16154: CALL_OW 94
16158: GO 16172
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16160: LD_VAR 0 3
16164: PPUSH
16165: LD_STRING DSurrenderRussians-RSol1-1a
16167: PPUSH
16168: CALL_OW 94
// DialogueOff ;
16172: CALL_OW 7
// russianCapitulated := true ;
16176: LD_ADDR_EXP 7
16180: PUSH
16181: LD_INT 1
16183: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16184: LD_ADDR_VAR 0 2
16188: PUSH
16189: LD_INT 22
16191: PUSH
16192: LD_INT 3
16194: PUSH
16195: EMPTY
16196: LIST
16197: LIST
16198: PUSH
16199: LD_INT 21
16201: PUSH
16202: LD_INT 1
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: PPUSH
16213: CALL_OW 69
16217: PUSH
16218: LD_INT 22
16220: PUSH
16221: LD_INT 3
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: PUSH
16228: LD_INT 21
16230: PUSH
16231: LD_INT 2
16233: PUSH
16234: EMPTY
16235: LIST
16236: LIST
16237: PUSH
16238: LD_INT 1
16240: PUSH
16241: EMPTY
16242: LIST
16243: PUSH
16244: EMPTY
16245: LIST
16246: LIST
16247: LIST
16248: PPUSH
16249: CALL_OW 69
16253: ADD
16254: ST_TO_ADDR
// if tmp then
16255: LD_VAR 0 2
16259: IFFALSE 16412
// repeat wait ( 0 0$1 ) ;
16261: LD_INT 35
16263: PPUSH
16264: CALL_OW 67
// for i in tmp do
16268: LD_ADDR_VAR 0 1
16272: PUSH
16273: LD_VAR 0 2
16277: PUSH
16278: FOR_IN
16279: IFFALSE 16361
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16281: LD_VAR 0 1
16285: PPUSH
16286: CALL_OW 310
16290: PUSH
16291: LD_VAR 0 1
16295: PPUSH
16296: CALL_OW 310
16300: PPUSH
16301: CALL_OW 247
16305: PUSH
16306: LD_INT 3
16308: EQUAL
16309: AND
16310: IFFALSE 16321
// ComExitBuilding ( i ) ;
16312: LD_VAR 0 1
16316: PPUSH
16317: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
16321: LD_VAR 0 1
16325: PPUSH
16326: LD_INT 154
16328: PPUSH
16329: LD_INT 1
16331: PPUSH
16332: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
16336: LD_VAR 0 1
16340: PPUSH
16341: LD_INT 36
16343: PPUSH
16344: CALL_OW 308
16348: IFFALSE 16359
// RemoveUnit ( i ) ;
16350: LD_VAR 0 1
16354: PPUSH
16355: CALL_OW 64
// end ;
16359: GO 16278
16361: POP
16362: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16363: LD_INT 22
16365: PUSH
16366: LD_INT 3
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PUSH
16373: LD_INT 2
16375: PUSH
16376: LD_INT 21
16378: PUSH
16379: LD_INT 1
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 33
16388: PUSH
16389: LD_INT 1
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: LIST
16400: PUSH
16401: EMPTY
16402: LIST
16403: LIST
16404: PPUSH
16405: CALL_OW 69
16409: NOT
16410: IFFALSE 16261
// end ;
16412: PPOPN 3
16414: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
16415: LD_INT 22
16417: PUSH
16418: LD_INT 8
16420: PUSH
16421: EMPTY
16422: LIST
16423: LIST
16424: PUSH
16425: LD_INT 21
16427: PUSH
16428: LD_INT 1
16430: PUSH
16431: EMPTY
16432: LIST
16433: LIST
16434: PUSH
16435: LD_INT 23
16437: PUSH
16438: LD_INT 2
16440: PUSH
16441: EMPTY
16442: LIST
16443: LIST
16444: PUSH
16445: EMPTY
16446: LIST
16447: LIST
16448: LIST
16449: PPUSH
16450: CALL_OW 69
16454: PUSH
16455: LD_INT 18
16457: LESS
16458: PUSH
16459: LD_EXP 58
16463: PPUSH
16464: CALL_OW 301
16468: OR
16469: PUSH
16470: LD_INT 324
16472: PPUSH
16473: CALL_OW 255
16477: PUSH
16478: LD_INT 7
16480: EQUAL
16481: OR
16482: IFFALSE 16495
16484: GO 16486
16486: DISABLE
// legionDestroyed := true ;
16487: LD_ADDR_EXP 3
16491: PUSH
16492: LD_INT 1
16494: ST_TO_ADDR
16495: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
16496: LD_INT 22
16498: PUSH
16499: LD_INT 2
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PUSH
16506: LD_INT 21
16508: PUSH
16509: LD_INT 1
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PUSH
16516: LD_INT 23
16518: PUSH
16519: LD_INT 2
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: LIST
16530: PPUSH
16531: CALL_OW 69
16535: PUSH
16536: LD_INT 9
16538: LESS
16539: PUSH
16540: LD_INT 503
16542: PPUSH
16543: CALL_OW 301
16547: OR
16548: PUSH
16549: LD_INT 503
16551: PPUSH
16552: CALL_OW 255
16556: PUSH
16557: LD_INT 7
16559: EQUAL
16560: OR
16561: IFFALSE 16574
16563: GO 16565
16565: DISABLE
// arabianDestroyed := true ;
16566: LD_ADDR_EXP 5
16570: PUSH
16571: LD_INT 1
16573: ST_TO_ADDR
16574: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
16575: LD_EXP 5
16579: IFFALSE 16823
16581: GO 16583
16583: DISABLE
16584: LD_INT 0
16586: PPUSH
16587: PPUSH
// begin MC_Kill ( 1 ) ;
16588: LD_INT 1
16590: PPUSH
16591: CALL 22411 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16595: LD_ADDR_VAR 0 2
16599: PUSH
16600: LD_INT 22
16602: PUSH
16603: LD_INT 2
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: PUSH
16610: LD_INT 21
16612: PUSH
16613: LD_INT 1
16615: PUSH
16616: EMPTY
16617: LIST
16618: LIST
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PPUSH
16624: CALL_OW 69
16628: PUSH
16629: LD_INT 22
16631: PUSH
16632: LD_INT 2
16634: PUSH
16635: EMPTY
16636: LIST
16637: LIST
16638: PUSH
16639: LD_INT 21
16641: PUSH
16642: LD_INT 2
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: PUSH
16649: LD_INT 1
16651: PUSH
16652: EMPTY
16653: LIST
16654: PUSH
16655: EMPTY
16656: LIST
16657: LIST
16658: LIST
16659: PPUSH
16660: CALL_OW 69
16664: ADD
16665: ST_TO_ADDR
// if tmp then
16666: LD_VAR 0 2
16670: IFFALSE 16823
// repeat wait ( 0 0$1 ) ;
16672: LD_INT 35
16674: PPUSH
16675: CALL_OW 67
// for i in tmp do
16679: LD_ADDR_VAR 0 1
16683: PUSH
16684: LD_VAR 0 2
16688: PUSH
16689: FOR_IN
16690: IFFALSE 16772
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16692: LD_VAR 0 1
16696: PPUSH
16697: CALL_OW 310
16701: PUSH
16702: LD_VAR 0 1
16706: PPUSH
16707: CALL_OW 310
16711: PPUSH
16712: CALL_OW 247
16716: PUSH
16717: LD_INT 3
16719: EQUAL
16720: AND
16721: IFFALSE 16732
// ComExitBuilding ( i ) ;
16723: LD_VAR 0 1
16727: PPUSH
16728: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
16732: LD_VAR 0 1
16736: PPUSH
16737: LD_INT 254
16739: PPUSH
16740: LD_INT 268
16742: PPUSH
16743: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
16747: LD_VAR 0 1
16751: PPUSH
16752: LD_INT 34
16754: PPUSH
16755: CALL_OW 308
16759: IFFALSE 16770
// RemoveUnit ( i ) ;
16761: LD_VAR 0 1
16765: PPUSH
16766: CALL_OW 64
// end ;
16770: GO 16689
16772: POP
16773: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16774: LD_INT 22
16776: PUSH
16777: LD_INT 2
16779: PUSH
16780: EMPTY
16781: LIST
16782: LIST
16783: PUSH
16784: LD_INT 2
16786: PUSH
16787: LD_INT 21
16789: PUSH
16790: LD_INT 1
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PUSH
16797: LD_INT 33
16799: PUSH
16800: LD_INT 1
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: LIST
16811: PUSH
16812: EMPTY
16813: LIST
16814: LIST
16815: PPUSH
16816: CALL_OW 69
16820: NOT
16821: IFFALSE 16672
// end ;
16823: PPOPN 2
16825: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16826: LD_EXP 3
16830: IFFALSE 17182
16832: GO 16834
16834: DISABLE
16835: LD_INT 0
16837: PPUSH
16838: PPUSH
// begin MC_Kill ( 3 ) ;
16839: LD_INT 3
16841: PPUSH
16842: CALL 22411 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16846: LD_INT 8
16848: PPUSH
16849: LD_INT 7
16851: PPUSH
16852: LD_INT 1
16854: PPUSH
16855: LD_INT 1
16857: PPUSH
16858: CALL_OW 80
// DialogueOn ;
16862: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16866: LD_EXP 57
16870: PPUSH
16871: LD_STRING D15-Szulc-1
16873: PPUSH
16874: CALL_OW 94
// DialogueOff ;
16878: CALL_OW 7
// legionCapitulated := true ;
16882: LD_ADDR_EXP 8
16886: PUSH
16887: LD_INT 1
16889: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16890: LD_ADDR_VAR 0 1
16894: PUSH
16895: LD_INT 22
16897: PUSH
16898: LD_INT 8
16900: PUSH
16901: EMPTY
16902: LIST
16903: LIST
16904: PUSH
16905: LD_INT 21
16907: PUSH
16908: LD_INT 3
16910: PUSH
16911: EMPTY
16912: LIST
16913: LIST
16914: PUSH
16915: LD_INT 23
16917: PUSH
16918: LD_INT 3
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: PPUSH
16930: CALL_OW 69
16934: PUSH
16935: FOR_IN
16936: IFFALSE 16952
// SetLives ( i , 3 ) ;
16938: LD_VAR 0 1
16942: PPUSH
16943: LD_INT 3
16945: PPUSH
16946: CALL_OW 234
16950: GO 16935
16952: POP
16953: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16954: LD_ADDR_VAR 0 2
16958: PUSH
16959: LD_INT 22
16961: PUSH
16962: LD_INT 8
16964: PUSH
16965: EMPTY
16966: LIST
16967: LIST
16968: PUSH
16969: LD_INT 21
16971: PUSH
16972: LD_INT 1
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PUSH
16979: EMPTY
16980: LIST
16981: LIST
16982: PPUSH
16983: CALL_OW 69
16987: PUSH
16988: LD_INT 22
16990: PUSH
16991: LD_INT 8
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PUSH
16998: LD_INT 21
17000: PUSH
17001: LD_INT 2
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PUSH
17008: LD_INT 1
17010: PUSH
17011: EMPTY
17012: LIST
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: LIST
17018: PPUSH
17019: CALL_OW 69
17023: ADD
17024: ST_TO_ADDR
// if tmp then
17025: LD_VAR 0 2
17029: IFFALSE 17182
// repeat wait ( 0 0$1 ) ;
17031: LD_INT 35
17033: PPUSH
17034: CALL_OW 67
// for i in tmp do
17038: LD_ADDR_VAR 0 1
17042: PUSH
17043: LD_VAR 0 2
17047: PUSH
17048: FOR_IN
17049: IFFALSE 17131
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17051: LD_VAR 0 1
17055: PPUSH
17056: CALL_OW 310
17060: PUSH
17061: LD_VAR 0 1
17065: PPUSH
17066: CALL_OW 310
17070: PPUSH
17071: CALL_OW 247
17075: PUSH
17076: LD_INT 3
17078: EQUAL
17079: AND
17080: IFFALSE 17091
// ComExitBuilding ( i ) ;
17082: LD_VAR 0 1
17086: PPUSH
17087: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17091: LD_VAR 0 1
17095: PPUSH
17096: LD_INT 10
17098: PPUSH
17099: LD_INT 1
17101: PPUSH
17102: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17106: LD_VAR 0 1
17110: PPUSH
17111: LD_INT 32
17113: PPUSH
17114: CALL_OW 308
17118: IFFALSE 17129
// RemoveUnit ( i ) ;
17120: LD_VAR 0 1
17124: PPUSH
17125: CALL_OW 64
// end ;
17129: GO 17048
17131: POP
17132: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17133: LD_INT 22
17135: PUSH
17136: LD_INT 8
17138: PUSH
17139: EMPTY
17140: LIST
17141: LIST
17142: PUSH
17143: LD_INT 2
17145: PUSH
17146: LD_INT 21
17148: PUSH
17149: LD_INT 1
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: PUSH
17156: LD_INT 33
17158: PUSH
17159: LD_INT 1
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: LIST
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: PPUSH
17175: CALL_OW 69
17179: NOT
17180: IFFALSE 17031
// end ;
17182: PPOPN 2
17184: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
17185: LD_EXP 5
17189: NOT
17190: PUSH
17191: LD_OWVAR 1
17195: PUSH
17196: LD_INT 63000
17198: GREATEREQUAL
17199: AND
17200: PUSH
17201: LD_OWVAR 67
17205: PUSH
17206: LD_INT 3
17208: LESS
17209: AND
17210: IFFALSE 17219
17212: GO 17214
17214: DISABLE
// AllianceSupport ;
17215: CALL 4677 0 0
17219: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
17220: LD_EXP 4
17224: PUSH
17225: LD_EXP 2
17229: AND
17230: PUSH
17231: LD_EXP 3
17235: AND
17236: PUSH
17237: LD_EXP 5
17241: AND
17242: PUSH
17243: LD_EXP 6
17247: AND
17248: PUSH
17249: LD_EXP 7
17253: AND
17254: PUSH
17255: LD_EXP 8
17259: AND
17260: PUSH
17261: LD_EXP 56
17265: PPUSH
17266: CALL_OW 255
17270: PUSH
17271: LD_INT 5
17273: NONEQUAL
17274: PUSH
17275: LD_EXP 56
17279: PPUSH
17280: CALL_OW 301
17284: OR
17285: PUSH
17286: LD_EXP 56
17290: PPUSH
17291: CALL_OW 305
17295: NOT
17296: OR
17297: AND
17298: IFFALSE 18817
17300: GO 17302
17302: DISABLE
17303: LD_INT 0
17305: PPUSH
17306: PPUSH
// begin wait ( 0 0$5 ) ;
17307: LD_INT 175
17309: PPUSH
17310: CALL_OW 67
// music_class := 5 ;
17314: LD_ADDR_OWVAR 72
17318: PUSH
17319: LD_INT 5
17321: ST_TO_ADDR
// music_nat := 5 ;
17322: LD_ADDR_OWVAR 71
17326: PUSH
17327: LD_INT 5
17329: ST_TO_ADDR
// if vehicleLostCounter < 3 then
17330: LD_EXP 15
17334: PUSH
17335: LD_INT 3
17337: LESS
17338: IFFALSE 17347
// SetAchievement ( ACH_ECONOMY ) ;
17340: LD_STRING ACH_ECONOMY
17342: PPUSH
17343: CALL_OW 543
// if tick < 60 60$00 then
17347: LD_OWVAR 1
17351: PUSH
17352: LD_INT 126000
17354: LESS
17355: IFFALSE 17371
// begin wait ( 3 ) ;
17357: LD_INT 3
17359: PPUSH
17360: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
17364: LD_STRING ACH_ASPEED_19
17366: PPUSH
17367: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
17371: LD_EXP 19
17375: PPUSH
17376: CALL_OW 87
// InGameOn ;
17380: CALL_OW 8
// DialogueOn ;
17384: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
17388: LD_EXP 19
17392: PPUSH
17393: LD_STRING DEnd-JMM-JMM-1
17395: PPUSH
17396: CALL_OW 88
// if Joan then
17400: LD_EXP 34
17404: IFFALSE 17420
// Say ( Joan , DEnd-JMM-Joan-1 ) else
17406: LD_EXP 34
17410: PPUSH
17411: LD_STRING DEnd-JMM-Joan-1
17413: PPUSH
17414: CALL_OW 88
17418: GO 17464
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
17420: LD_EXP 21
17424: PUSH
17425: LD_EXP 21
17429: PPUSH
17430: CALL_OW 255
17434: PUSH
17435: LD_INT 7
17437: EQUAL
17438: AND
17439: PUSH
17440: LD_EXP 21
17444: PPUSH
17445: CALL_OW 305
17449: AND
17450: IFFALSE 17464
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
17452: LD_EXP 21
17456: PPUSH
17457: LD_STRING DEnd-JMM-Lisa-1
17459: PPUSH
17460: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
17464: LD_EXP 31
17468: PUSH
17469: LD_EXP 31
17473: PPUSH
17474: CALL_OW 305
17478: AND
17479: IFFALSE 17493
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
17481: LD_EXP 31
17485: PPUSH
17486: LD_STRING DEnd-JMM-Frank-1
17488: PPUSH
17489: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
17493: LD_EXP 24
17497: PUSH
17498: LD_EXP 24
17502: PPUSH
17503: CALL_OW 255
17507: PUSH
17508: LD_INT 7
17510: EQUAL
17511: AND
17512: PUSH
17513: LD_EXP 24
17517: PPUSH
17518: CALL_OW 305
17522: AND
17523: IFFALSE 17537
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
17525: LD_EXP 24
17529: PPUSH
17530: LD_STRING DEnd-JMM-Cyrus-1
17532: PPUSH
17533: CALL_OW 88
// if Burlak then
17537: LD_EXP 52
17541: IFFALSE 17555
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
17543: LD_EXP 52
17547: PPUSH
17548: LD_STRING DEnd-JMM-Bur-1
17550: PPUSH
17551: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
17555: LD_EXP 34
17559: PUSH
17560: LD_EXP 21
17564: AND
17565: PUSH
17566: LD_EXP 21
17570: PPUSH
17571: CALL_OW 255
17575: PUSH
17576: LD_INT 7
17578: EQUAL
17579: AND
17580: PUSH
17581: LD_EXP 21
17585: PPUSH
17586: CALL_OW 305
17590: AND
17591: PUSH
17592: LD_EXP 52
17596: PPUSH
17597: CALL_OW 302
17601: AND
17602: IFFALSE 17616
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
17604: LD_EXP 21
17608: PPUSH
17609: LD_STRING DEnd-Burlak-Lisa-1
17611: PPUSH
17612: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
17616: LD_EXP 53
17620: PUSH
17621: LD_EXP 53
17625: PPUSH
17626: CALL_OW 305
17630: AND
17631: IFFALSE 17645
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
17633: LD_EXP 53
17637: PPUSH
17638: LD_STRING DEnd-JMM-Bel-1
17640: PPUSH
17641: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
17645: LD_EXP 54
17649: PUSH
17650: LD_EXP 54
17654: PPUSH
17655: CALL_OW 305
17659: AND
17660: IFFALSE 17674
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
17662: LD_EXP 54
17666: PPUSH
17667: LD_STRING DEnd-JMM-Gny-1
17669: PPUSH
17670: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
17674: LD_EXP 29
17678: PUSH
17679: LD_EXP 29
17683: PPUSH
17684: CALL_OW 255
17688: PUSH
17689: LD_INT 7
17691: EQUAL
17692: AND
17693: PUSH
17694: LD_EXP 29
17698: PPUSH
17699: CALL_OW 305
17703: AND
17704: IFFALSE 17718
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
17706: LD_EXP 29
17710: PPUSH
17711: LD_STRING DEnd-JMM-Corn-1
17713: PPUSH
17714: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
17718: LD_EXP 22
17722: PUSH
17723: LD_EXP 22
17727: PPUSH
17728: CALL_OW 255
17732: PUSH
17733: LD_INT 7
17735: EQUAL
17736: AND
17737: PUSH
17738: LD_EXP 22
17742: PPUSH
17743: CALL_OW 305
17747: AND
17748: IFFALSE 17762
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17750: LD_EXP 22
17754: PPUSH
17755: LD_STRING DEnd-JMM-Don-1
17757: PPUSH
17758: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
17762: LD_EXP 23
17766: PUSH
17767: LD_EXP 23
17771: PPUSH
17772: CALL_OW 255
17776: PUSH
17777: LD_INT 7
17779: EQUAL
17780: AND
17781: PUSH
17782: LD_EXP 23
17786: PPUSH
17787: CALL_OW 305
17791: AND
17792: IFFALSE 17806
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17794: LD_EXP 23
17798: PPUSH
17799: LD_STRING DEnd-JMM-Bobby-1
17801: PPUSH
17802: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17806: LD_EXP 25
17810: PUSH
17811: LD_EXP 25
17815: PPUSH
17816: CALL_OW 255
17820: PUSH
17821: LD_INT 7
17823: EQUAL
17824: AND
17825: PUSH
17826: LD_EXP 25
17830: PPUSH
17831: CALL_OW 305
17835: AND
17836: IFFALSE 17850
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17838: LD_EXP 25
17842: PPUSH
17843: LD_STRING DEnd-JMM-Den-1
17845: PPUSH
17846: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17850: LD_EXP 27
17854: PUSH
17855: LD_EXP 27
17859: PPUSH
17860: CALL_OW 255
17864: PUSH
17865: LD_INT 7
17867: EQUAL
17868: AND
17869: PUSH
17870: LD_EXP 27
17874: PPUSH
17875: CALL_OW 305
17879: AND
17880: IFFALSE 17894
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17882: LD_EXP 27
17886: PPUSH
17887: LD_STRING DEnd-JMM-Glad-1
17889: PPUSH
17890: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17894: LD_EXP 32
17898: PUSH
17899: LD_EXP 32
17903: PPUSH
17904: CALL_OW 255
17908: PUSH
17909: LD_INT 7
17911: EQUAL
17912: AND
17913: PUSH
17914: LD_EXP 32
17918: PPUSH
17919: CALL_OW 305
17923: AND
17924: IFFALSE 17938
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17926: LD_EXP 32
17930: PPUSH
17931: LD_STRING DEnd-JMM-Yam-1
17933: PPUSH
17934: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17938: LD_EXP 26
17942: PUSH
17943: LD_EXP 26
17947: PPUSH
17948: CALL_OW 255
17952: PUSH
17953: LD_INT 7
17955: EQUAL
17956: AND
17957: PUSH
17958: LD_EXP 26
17962: PPUSH
17963: CALL_OW 305
17967: AND
17968: IFFALSE 17982
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17970: LD_EXP 26
17974: PPUSH
17975: LD_STRING DEnd-JMM-Brown-1
17977: PPUSH
17978: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17982: LD_EXP 36
17986: PUSH
17987: LD_EXP 36
17991: PPUSH
17992: CALL_OW 255
17996: PUSH
17997: LD_INT 7
17999: EQUAL
18000: AND
18001: PUSH
18002: LD_EXP 36
18006: PPUSH
18007: CALL_OW 305
18011: AND
18012: IFFALSE 18026
// Say ( Connie , DEnd-JMM-Con-1 ) ;
18014: LD_EXP 36
18018: PPUSH
18019: LD_STRING DEnd-JMM-Con-1
18021: PPUSH
18022: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
18026: LD_EXP 30
18030: PUSH
18031: LD_EXP 30
18035: PPUSH
18036: CALL_OW 255
18040: PUSH
18041: LD_INT 7
18043: EQUAL
18044: AND
18045: PUSH
18046: LD_EXP 30
18050: PPUSH
18051: CALL_OW 305
18055: AND
18056: IFFALSE 18070
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18058: LD_EXP 30
18062: PPUSH
18063: LD_STRING DEnd-JMM-Gary-1
18065: PPUSH
18066: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
18070: LD_EXP 20
18074: PUSH
18075: LD_EXP 20
18079: PPUSH
18080: CALL_OW 305
18084: AND
18085: IFFALSE 18099
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18087: LD_EXP 20
18091: PPUSH
18092: LD_STRING DEnd-JMM-Roth-1
18094: PPUSH
18095: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
18099: LD_EXP 33
18103: PUSH
18104: LD_EXP 20
18108: AND
18109: PUSH
18110: LD_EXP 33
18114: PPUSH
18115: CALL_OW 305
18119: AND
18120: IFFALSE 18134
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18122: LD_EXP 33
18126: PPUSH
18127: LD_STRING DEnd-JMM-Sim-1
18129: PPUSH
18130: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
18134: LD_EXP 28
18138: PUSH
18139: LD_EXP 28
18143: PPUSH
18144: CALL_OW 255
18148: PUSH
18149: LD_INT 7
18151: EQUAL
18152: AND
18153: PUSH
18154: LD_EXP 28
18158: PPUSH
18159: CALL_OW 305
18163: AND
18164: IFFALSE 18178
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
18166: LD_EXP 28
18170: PPUSH
18171: LD_STRING DEnd-JMM-VanH-1
18173: PPUSH
18174: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
18178: LD_EXP 42
18182: PUSH
18183: LD_EXP 42
18187: PPUSH
18188: CALL_OW 305
18192: AND
18193: IFFALSE 18207
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18195: LD_EXP 42
18199: PPUSH
18200: LD_STRING DEnd-JMM-Dol-1
18202: PPUSH
18203: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18207: LD_EXP 32
18211: PUSH
18212: LD_EXP 32
18216: PPUSH
18217: CALL_OW 255
18221: PUSH
18222: LD_INT 7
18224: EQUAL
18225: AND
18226: PUSH
18227: LD_EXP 32
18231: PPUSH
18232: CALL_OW 305
18236: AND
18237: IFFALSE 18251
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18239: LD_EXP 32
18243: PPUSH
18244: LD_STRING DEnd-JMM-Yam-1
18246: PPUSH
18247: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
18251: LD_EXP 46
18255: PUSH
18256: LD_EXP 46
18260: PPUSH
18261: CALL_OW 305
18265: AND
18266: IFFALSE 18280
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18268: LD_EXP 46
18272: PPUSH
18273: LD_STRING DEnd-JMM-Kap-1
18275: PPUSH
18276: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
18280: LD_EXP 49
18284: PUSH
18285: LD_EXP 49
18289: PPUSH
18290: CALL_OW 305
18294: AND
18295: IFFALSE 18309
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
18297: LD_EXP 49
18301: PPUSH
18302: LD_STRING DEnd-JMM-Kov-1
18304: PPUSH
18305: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
18309: LD_EXP 44
18313: PUSH
18314: LD_EXP 44
18318: PPUSH
18319: CALL_OW 305
18323: AND
18324: IFFALSE 18338
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18326: LD_EXP 44
18330: PPUSH
18331: LD_STRING DEnd-JMM-Sch-1
18333: PPUSH
18334: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
18338: LD_EXP 40
18342: PUSH
18343: LD_EXP 40
18347: PPUSH
18348: CALL_OW 305
18352: AND
18353: PUSH
18354: LD_EXP 52
18358: PPUSH
18359: CALL_OW 302
18363: AND
18364: IFFALSE 18378
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18366: LD_EXP 40
18370: PPUSH
18371: LD_STRING DEnd-JMM-Tit-1
18373: PPUSH
18374: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
18378: LD_EXP 45
18382: PUSH
18383: LD_EXP 45
18387: PPUSH
18388: CALL_OW 305
18392: AND
18393: IFFALSE 18407
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
18395: LD_EXP 45
18399: PPUSH
18400: LD_STRING DEnd-JMM-Obl-1
18402: PPUSH
18403: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
18407: LD_EXP 47
18411: PUSH
18412: LD_EXP 47
18416: PPUSH
18417: CALL_OW 305
18421: AND
18422: IFFALSE 18436
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
18424: LD_EXP 47
18428: PPUSH
18429: LD_STRING DEnd-JMM-Lip-1
18431: PPUSH
18432: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
18436: LD_EXP 41
18440: PUSH
18441: LD_EXP 41
18445: PPUSH
18446: CALL_OW 305
18450: AND
18451: PUSH
18452: LD_EXP 52
18456: PPUSH
18457: CALL_OW 302
18461: AND
18462: IFFALSE 18476
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
18464: LD_EXP 41
18468: PPUSH
18469: LD_STRING DEnd-Burlak-Fad-1
18471: PPUSH
18472: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
18476: LD_EXP 48
18480: PUSH
18481: LD_EXP 48
18485: PPUSH
18486: CALL_OW 305
18490: AND
18491: IFFALSE 18505
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
18493: LD_EXP 48
18497: PPUSH
18498: LD_STRING DEnd-Burlak-Ptr-1
18500: PPUSH
18501: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
18505: LD_EXP 50
18509: PUSH
18510: LD_EXP 50
18514: PPUSH
18515: CALL_OW 305
18519: AND
18520: IFFALSE 18534
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
18522: LD_EXP 50
18526: PPUSH
18527: LD_STRING DEnd-Burlak-Kuz-1
18529: PPUSH
18530: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
18534: LD_EXP 39
18538: PUSH
18539: LD_EXP 39
18543: PPUSH
18544: CALL_OW 305
18548: AND
18549: PUSH
18550: LD_EXP 52
18554: PPUSH
18555: CALL_OW 302
18559: AND
18560: IFFALSE 18574
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
18562: LD_EXP 39
18566: PPUSH
18567: LD_STRING DEnd-Burlak-Kir-1
18569: PPUSH
18570: CALL_OW 88
// if Joan then
18574: LD_EXP 34
18578: IFFALSE 18592
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
18580: LD_EXP 34
18584: PPUSH
18585: LD_STRING DEnd-Burlak-Joan-1
18587: PPUSH
18588: CALL_OW 88
// if IsOk ( Burlak ) then
18592: LD_EXP 52
18596: PPUSH
18597: CALL_OW 302
18601: IFFALSE 18615
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
18603: LD_EXP 19
18607: PPUSH
18608: LD_STRING DEnd-Burlak-JMM-1
18610: PPUSH
18611: CALL_OW 88
// dwait ( 0 0$2 ) ;
18615: LD_INT 70
18617: PPUSH
18618: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
18622: LD_EXP 57
18626: PPUSH
18627: LD_STRING DEnd-Szulc
18629: PPUSH
18630: CALL_OW 94
// dwait ( 0 0$1 ) ;
18634: LD_INT 35
18636: PPUSH
18637: CALL_OW 68
// if IsLive ( Burlak ) then
18641: LD_EXP 52
18645: PPUSH
18646: CALL_OW 300
18650: IFFALSE 18662
// med1 := 1 else
18652: LD_ADDR_VAR 0 1
18656: PUSH
18657: LD_INT 1
18659: ST_TO_ADDR
18660: GO 18671
// med1 := - 1 ;
18662: LD_ADDR_VAR 0 1
18666: PUSH
18667: LD_INT 1
18669: NEG
18670: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
18671: LD_EXP 12
18675: PUSH
18676: LD_EXP 13
18680: AND
18681: PUSH
18682: LD_EXP 14
18686: AND
18687: IFFALSE 18699
// med2 := 1 else
18689: LD_ADDR_VAR 0 2
18693: PUSH
18694: LD_INT 1
18696: ST_TO_ADDR
18697: GO 18708
// med2 := - 1 ;
18699: LD_ADDR_VAR 0 2
18703: PUSH
18704: LD_INT 1
18706: NEG
18707: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
18708: LD_STRING Hero
18710: PPUSH
18711: LD_INT 1
18713: PPUSH
18714: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
18718: LD_STRING Artefact
18720: PPUSH
18721: LD_VAR 0 2
18725: PPUSH
18726: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
18730: LD_STRING ReconcileBurlak
18732: PPUSH
18733: LD_VAR 0 1
18737: PPUSH
18738: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
18742: LD_OWVAR 67
18746: PUSH
18747: LD_INT 3
18749: GREATEREQUAL
18750: PUSH
18751: LD_VAR 0 1
18755: PUSH
18756: LD_INT 1
18758: EQUAL
18759: AND
18760: PUSH
18761: LD_VAR 0 2
18765: PUSH
18766: LD_INT 1
18768: EQUAL
18769: AND
18770: IFFALSE 18782
// SetAchievementEX ( ACH_AMER , 19 ) ;
18772: LD_STRING ACH_AMER
18774: PPUSH
18775: LD_INT 19
18777: PPUSH
18778: CALL_OW 564
// GiveMedals ( MAIN ) ;
18782: LD_STRING MAIN
18784: PPUSH
18785: CALL_OW 102
// InGameOff ;
18789: CALL_OW 9
// DialogueOff ;
18793: CALL_OW 7
// music_nat := 1 ;
18797: LD_ADDR_OWVAR 71
18801: PUSH
18802: LD_INT 1
18804: ST_TO_ADDR
// music_class := 4 ;
18805: LD_ADDR_OWVAR 72
18809: PUSH
18810: LD_INT 4
18812: ST_TO_ADDR
// YouWin ;
18813: CALL_OW 103
// end ; end_of_file
18817: PPOPN 2
18819: END
// export function InitNature ; begin
18820: LD_INT 0
18822: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
18823: LD_INT 3
18825: PPUSH
18826: LD_INT 3
18828: PPUSH
18829: LD_INT 2
18831: PPUSH
18832: LD_INT 1
18834: PPUSH
18835: LD_INT 1
18837: PPUSH
18838: LD_INT 0
18840: PPUSH
18841: LD_INT 0
18843: PPUSH
18844: LD_INT 17
18846: PPUSH
18847: LD_INT 0
18849: PPUSH
18850: CALL 86873 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
18854: LD_INT 2
18856: PPUSH
18857: LD_INT 1
18859: PPUSH
18860: LD_INT 1
18862: PPUSH
18863: LD_INT 1
18865: PPUSH
18866: LD_INT 1
18868: PPUSH
18869: LD_INT 0
18871: PPUSH
18872: LD_INT 0
18874: PPUSH
18875: LD_INT 18
18877: PPUSH
18878: LD_INT 0
18880: PPUSH
18881: CALL 86873 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
18885: LD_INT 4
18887: PPUSH
18888: LD_INT 1
18890: PPUSH
18891: LD_INT 2
18893: PPUSH
18894: LD_INT 4
18896: PPUSH
18897: LD_INT 2
18899: PPUSH
18900: LD_INT 1
18902: PPUSH
18903: LD_INT 0
18905: PPUSH
18906: LD_INT 19
18908: PPUSH
18909: LD_INT 0
18911: PPUSH
18912: CALL 86873 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18916: LD_INT 0
18918: PPUSH
18919: LD_INT 0
18921: PPUSH
18922: LD_INT 0
18924: PPUSH
18925: LD_INT 0
18927: PPUSH
18928: LD_INT 0
18930: PPUSH
18931: LD_INT 0
18933: PPUSH
18934: LD_INT 9
18936: PPUSH
18937: LD_INT 0
18939: PPUSH
18940: LD_INT 20
18942: PPUSH
18943: CALL 86873 0 9
// end ; end_of_file
18947: LD_VAR 0 1
18951: RET
// every 0 0$30 do var time ;
18952: GO 18954
18954: DISABLE
18955: LD_INT 0
18957: PPUSH
// begin time := 0 0$30 ;
18958: LD_ADDR_VAR 0 1
18962: PUSH
18963: LD_INT 1050
18965: ST_TO_ADDR
// repeat wait ( time ) ;
18966: LD_VAR 0 1
18970: PPUSH
18971: CALL_OW 67
// if Prob ( 50 ) then
18975: LD_INT 50
18977: PPUSH
18978: CALL_OW 13
18982: IFFALSE 19011
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18984: LD_INT 1
18986: PPUSH
18987: LD_INT 5
18989: PPUSH
18990: CALL_OW 12
18994: PPUSH
18995: LD_INT 106
18997: PPUSH
18998: LD_INT 89
19000: PPUSH
19001: LD_INT 45
19003: PPUSH
19004: LD_INT 1
19006: PPUSH
19007: CALL_OW 56
// time := time + 0 0$3 ;
19011: LD_ADDR_VAR 0 1
19015: PUSH
19016: LD_VAR 0 1
19020: PUSH
19021: LD_INT 105
19023: PLUS
19024: ST_TO_ADDR
// if Prob ( 30 ) then
19025: LD_INT 30
19027: PPUSH
19028: CALL_OW 13
19032: IFFALSE 19078
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
19034: LD_INT 525
19036: PPUSH
19037: LD_INT 735
19039: PPUSH
19040: CALL_OW 12
19044: PPUSH
19045: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
19049: LD_INT 1
19051: PPUSH
19052: LD_INT 5
19054: PPUSH
19055: CALL_OW 12
19059: PPUSH
19060: LD_INT 21
19062: PPUSH
19063: LD_INT 26
19065: PPUSH
19066: LD_INT 12
19068: PPUSH
19069: LD_INT 1
19071: PPUSH
19072: CALL_OW 56
// end else
19076: GO 19114
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
19078: LD_INT 700
19080: PPUSH
19081: LD_INT 1225
19083: PPUSH
19084: CALL_OW 12
19088: PPUSH
19089: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
19093: LD_INT 1
19095: PPUSH
19096: LD_INT 5
19098: PPUSH
19099: CALL_OW 12
19103: PPUSH
19104: LD_INT 14
19106: PPUSH
19107: LD_INT 1
19109: PPUSH
19110: CALL_OW 55
// end ; if Prob ( 50 ) then
19114: LD_INT 50
19116: PPUSH
19117: CALL_OW 13
19121: IFFALSE 19167
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
19123: LD_INT 700
19125: PPUSH
19126: LD_INT 1050
19128: PPUSH
19129: CALL_OW 12
19133: PPUSH
19134: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
19138: LD_INT 1
19140: PPUSH
19141: LD_INT 5
19143: PPUSH
19144: CALL_OW 12
19148: PPUSH
19149: LD_INT 181
19151: PPUSH
19152: LD_INT 218
19154: PPUSH
19155: LD_INT 16
19157: PPUSH
19158: LD_INT 1
19160: PPUSH
19161: CALL_OW 56
// end else
19165: GO 19239
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
19167: LD_INT 350
19169: PPUSH
19170: LD_INT 525
19172: PPUSH
19173: CALL_OW 12
19177: PPUSH
19178: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
19182: LD_INT 1
19184: PPUSH
19185: LD_INT 5
19187: PPUSH
19188: CALL_OW 12
19192: PPUSH
19193: LD_INT 13
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19203: LD_INT 350
19205: PPUSH
19206: LD_INT 700
19208: PPUSH
19209: CALL_OW 12
19213: PPUSH
19214: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
19218: LD_INT 1
19220: PPUSH
19221: LD_INT 5
19223: PPUSH
19224: CALL_OW 12
19228: PPUSH
19229: LD_INT 33
19231: PPUSH
19232: LD_INT 1
19234: PPUSH
19235: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
19239: LD_INT 65
19241: PUSH
19242: LD_INT 62
19244: PUSH
19245: LD_INT 55
19247: PUSH
19248: LD_INT 50
19250: PUSH
19251: EMPTY
19252: LIST
19253: LIST
19254: LIST
19255: LIST
19256: PUSH
19257: LD_OWVAR 67
19261: ARRAY
19262: PPUSH
19263: CALL_OW 13
19267: IFFALSE 19313
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
19269: LD_INT 525
19271: PPUSH
19272: LD_INT 875
19274: PPUSH
19275: CALL_OW 12
19279: PPUSH
19280: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19284: LD_INT 1
19286: PPUSH
19287: LD_INT 5
19289: PPUSH
19290: CALL_OW 12
19294: PPUSH
19295: LD_INT 294
19297: PPUSH
19298: LD_INT 211
19300: PPUSH
19301: LD_INT 30
19303: PPUSH
19304: LD_INT 1
19306: PPUSH
19307: CALL_OW 56
// end else
19311: GO 19355
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
19313: LD_INT 420
19315: PPUSH
19316: LD_INT 770
19318: PPUSH
19319: CALL_OW 12
19323: PPUSH
19324: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19328: LD_INT 1
19330: PPUSH
19331: LD_INT 5
19333: PPUSH
19334: CALL_OW 12
19338: PPUSH
19339: LD_INT 294
19341: PPUSH
19342: LD_INT 211
19344: PPUSH
19345: LD_INT 30
19347: PPUSH
19348: LD_INT 1
19350: PPUSH
19351: CALL_OW 56
// end ; if time > 2 2$20 then
19355: LD_VAR 0 1
19359: PUSH
19360: LD_INT 4900
19362: GREATER
19363: IFFALSE 19373
// time := 0 0$50 ;
19365: LD_ADDR_VAR 0 1
19369: PUSH
19370: LD_INT 1750
19372: ST_TO_ADDR
// until false ;
19373: LD_INT 0
19375: IFFALSE 18966
// end ;
19377: PPOPN 1
19379: END
// every 0 0$45 trigger tick < 10 10$00 do
19380: LD_OWVAR 1
19384: PUSH
19385: LD_INT 21000
19387: LESS
19388: IFFALSE 19436
19390: GO 19392
19392: DISABLE
// begin enable ;
19393: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19394: LD_INT 350
19396: PPUSH
19397: LD_INT 700
19399: PPUSH
19400: CALL_OW 12
19404: PPUSH
19405: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
19409: LD_INT 3
19411: PPUSH
19412: LD_INT 5
19414: PPUSH
19415: CALL_OW 12
19419: PPUSH
19420: LD_INT 181
19422: PPUSH
19423: LD_INT 13
19425: PPUSH
19426: LD_INT 20
19428: PPUSH
19429: LD_INT 1
19431: PPUSH
19432: CALL_OW 56
// end ; end_of_file
19436: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
19437: LD_INT 0
19439: PPUSH
// SetArtifactRes ( 7 , true ) ;
19440: LD_INT 7
19442: PPUSH
19443: LD_INT 1
19445: PPUSH
19446: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
19450: LD_ADDR_EXP 66
19454: PUSH
19455: EMPTY
19456: PUSH
19457: EMPTY
19458: PUSH
19459: EMPTY
19460: PUSH
19461: EMPTY
19462: LIST
19463: LIST
19464: LIST
19465: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
19466: LD_ADDR_EXP 67
19470: PUSH
19471: LD_INT 1050
19473: PUSH
19474: LD_OWVAR 67
19478: MUL
19479: PUSH
19480: LD_INT 2800
19482: PUSH
19483: LD_OWVAR 67
19487: MUL
19488: PUSH
19489: LD_INT 1
19491: NEG
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: LIST
19497: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
19498: LD_ADDR_EXP 68
19502: PUSH
19503: LD_INT 10
19505: PUSH
19506: LD_INT 35
19508: PUSH
19509: LD_INT 100
19511: PUSH
19512: EMPTY
19513: LIST
19514: LIST
19515: LIST
19516: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
19517: LD_ADDR_EXP 69
19521: PUSH
19522: LD_INT 0
19524: PUSH
19525: LD_INT 0
19527: PUSH
19528: LD_INT 0
19530: PUSH
19531: EMPTY
19532: LIST
19533: LIST
19534: LIST
19535: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
19536: LD_ADDR_EXP 71
19540: PUSH
19541: LD_INT 300
19543: PUSH
19544: LD_INT 500
19546: PUSH
19547: LD_INT 800
19549: PUSH
19550: EMPTY
19551: LIST
19552: LIST
19553: LIST
19554: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
19555: LD_ADDR_EXP 72
19559: PUSH
19560: LD_INT 0
19562: PUSH
19563: LD_INT 0
19565: PUSH
19566: LD_INT 0
19568: PUSH
19569: EMPTY
19570: LIST
19571: LIST
19572: LIST
19573: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
19574: LD_ADDR_EXP 73
19578: PUSH
19579: LD_INT 0
19581: PUSH
19582: LD_INT 0
19584: PUSH
19585: LD_INT 0
19587: PUSH
19588: EMPTY
19589: LIST
19590: LIST
19591: LIST
19592: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
19593: LD_ADDR_EXP 70
19597: PUSH
19598: LD_INT 0
19600: PUSH
19601: LD_INT 0
19603: PUSH
19604: LD_INT 0
19606: PUSH
19607: EMPTY
19608: LIST
19609: LIST
19610: LIST
19611: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
19612: LD_ADDR_EXP 74
19616: PUSH
19617: LD_INT 4
19619: PUSH
19620: LD_INT 3
19622: PUSH
19623: LD_INT 1
19625: PUSH
19626: EMPTY
19627: LIST
19628: LIST
19629: LIST
19630: PUSH
19631: LD_INT 5
19633: PUSH
19634: LD_INT 4
19636: PUSH
19637: LD_INT 2
19639: PUSH
19640: EMPTY
19641: LIST
19642: LIST
19643: LIST
19644: PUSH
19645: LD_INT 6
19647: PUSH
19648: LD_INT 3
19650: PUSH
19651: LD_INT 3
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: LIST
19658: PUSH
19659: EMPTY
19660: LIST
19661: LIST
19662: LIST
19663: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
19664: LD_ADDR_EXP 75
19668: PUSH
19669: LD_INT 0
19671: PUSH
19672: LD_INT 0
19674: PUSH
19675: LD_INT 0
19677: PUSH
19678: EMPTY
19679: LIST
19680: LIST
19681: LIST
19682: ST_TO_ADDR
// end ;
19683: LD_VAR 0 1
19687: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
19688: LD_INT 24
19690: PPUSH
19691: LD_INT 7
19693: PPUSH
19694: CALL_OW 321
19698: PUSH
19699: LD_INT 2
19701: EQUAL
19702: IFFALSE 20628
19704: GO 19706
19706: DISABLE
19707: LD_INT 0
19709: PPUSH
19710: PPUSH
19711: PPUSH
19712: PPUSH
19713: PPUSH
// begin enable ;
19714: ENABLE
// for i = 1 to 3 do
19715: LD_ADDR_VAR 0 1
19719: PUSH
19720: DOUBLE
19721: LD_INT 1
19723: DEC
19724: ST_TO_ADDR
19725: LD_INT 3
19727: PUSH
19728: FOR_TO
19729: IFFALSE 20626
// begin pos := FindArtifact ( i + 2 ) ;
19731: LD_ADDR_VAR 0 2
19735: PUSH
19736: LD_VAR 0 1
19740: PUSH
19741: LD_INT 2
19743: PLUS
19744: PPUSH
19745: CALL_OW 469
19749: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
19750: LD_ADDR_EXP 66
19754: PUSH
19755: LD_EXP 66
19759: PPUSH
19760: LD_VAR 0 1
19764: PPUSH
19765: LD_VAR 0 2
19769: PPUSH
19770: CALL_OW 1
19774: ST_TO_ADDR
// if pos then
19775: LD_VAR 0 2
19779: IFFALSE 20487
// begin case i of 1 :
19781: LD_VAR 0 1
19785: PUSH
19786: LD_INT 1
19788: DOUBLE
19789: EQUAL
19790: IFTRUE 19794
19792: GO 19871
19794: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
19795: LD_ADDR_VAR 0 4
19799: PUSH
19800: LD_INT 22
19802: PUSH
19803: LD_INT 7
19805: PUSH
19806: EMPTY
19807: LIST
19808: LIST
19809: PUSH
19810: LD_INT 23
19812: PUSH
19813: LD_INT 1
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: PUSH
19820: LD_INT 2
19822: PUSH
19823: LD_INT 30
19825: PUSH
19826: LD_INT 8
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: PUSH
19833: LD_INT 30
19835: PUSH
19836: LD_INT 7
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: PUSH
19843: LD_INT 30
19845: PUSH
19846: LD_INT 11
19848: PUSH
19849: EMPTY
19850: LIST
19851: LIST
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: PUSH
19859: EMPTY
19860: LIST
19861: LIST
19862: LIST
19863: PPUSH
19864: CALL_OW 69
19868: ST_TO_ADDR
19869: GO 19979
19871: LD_INT 2
19873: DOUBLE
19874: EQUAL
19875: IFTRUE 19879
19877: GO 19956
19879: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
19880: LD_ADDR_VAR 0 4
19884: PUSH
19885: LD_INT 22
19887: PUSH
19888: LD_INT 7
19890: PUSH
19891: EMPTY
19892: LIST
19893: LIST
19894: PUSH
19895: LD_INT 23
19897: PUSH
19898: LD_INT 3
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PUSH
19905: LD_INT 2
19907: PUSH
19908: LD_INT 30
19910: PUSH
19911: LD_INT 8
19913: PUSH
19914: EMPTY
19915: LIST
19916: LIST
19917: PUSH
19918: LD_INT 30
19920: PUSH
19921: LD_INT 7
19923: PUSH
19924: EMPTY
19925: LIST
19926: LIST
19927: PUSH
19928: LD_INT 30
19930: PUSH
19931: LD_INT 11
19933: PUSH
19934: EMPTY
19935: LIST
19936: LIST
19937: PUSH
19938: EMPTY
19939: LIST
19940: LIST
19941: LIST
19942: LIST
19943: PUSH
19944: EMPTY
19945: LIST
19946: LIST
19947: LIST
19948: PPUSH
19949: CALL_OW 69
19953: ST_TO_ADDR
19954: GO 19979
19956: LD_INT 3
19958: DOUBLE
19959: EQUAL
19960: IFTRUE 19964
19962: GO 19978
19964: POP
// labs := [ alien ] ; end ;
19965: LD_ADDR_VAR 0 4
19969: PUSH
19970: LD_INT 1
19972: PUSH
19973: EMPTY
19974: LIST
19975: ST_TO_ADDR
19976: GO 19979
19978: POP
// if not labs then
19979: LD_VAR 0 4
19983: NOT
19984: IFFALSE 19988
// continue ;
19986: GO 19728
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19988: LD_ADDR_VAR 0 5
19992: PUSH
19993: LD_VAR 0 4
19997: PPUSH
19998: LD_EXP 66
20002: PUSH
20003: LD_VAR 0 1
20007: ARRAY
20008: PUSH
20009: LD_INT 1
20011: ARRAY
20012: PPUSH
20013: LD_EXP 66
20017: PUSH
20018: LD_VAR 0 1
20022: ARRAY
20023: PUSH
20024: LD_INT 2
20026: ARRAY
20027: PPUSH
20028: CALL_OW 73
20032: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
20033: LD_VAR 0 5
20037: NOT
20038: PUSH
20039: LD_VAR 0 5
20043: PUSH
20044: LD_EXP 73
20048: PUSH
20049: LD_VAR 0 1
20053: ARRAY
20054: NONEQUAL
20055: OR
20056: IFFALSE 20161
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20058: LD_INT 7
20060: PPUSH
20061: LD_EXP 74
20065: PUSH
20066: LD_VAR 0 1
20070: ARRAY
20071: PUSH
20072: LD_INT 3
20074: ARRAY
20075: PPUSH
20076: LD_INT 0
20078: PPUSH
20079: LD_EXP 73
20083: PUSH
20084: LD_VAR 0 1
20088: ARRAY
20089: PPUSH
20090: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20094: LD_INT 7
20096: PPUSH
20097: LD_EXP 74
20101: PUSH
20102: LD_VAR 0 1
20106: ARRAY
20107: PUSH
20108: LD_INT 1
20110: ARRAY
20111: PPUSH
20112: LD_INT 0
20114: PPUSH
20115: LD_EXP 73
20119: PUSH
20120: LD_VAR 0 1
20124: ARRAY
20125: PPUSH
20126: CALL_OW 468
// if nearestLab then
20130: LD_VAR 0 5
20134: IFFALSE 20161
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
20136: LD_ADDR_EXP 73
20140: PUSH
20141: LD_EXP 73
20145: PPUSH
20146: LD_VAR 0 1
20150: PPUSH
20151: LD_VAR 0 5
20155: PPUSH
20156: CALL_OW 1
20160: ST_TO_ADDR
// end ; if not nearestLab then
20161: LD_VAR 0 5
20165: NOT
20166: IFFALSE 20170
// continue ;
20168: GO 19728
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
20170: LD_VAR 0 5
20174: PPUSH
20175: LD_EXP 66
20179: PUSH
20180: LD_VAR 0 1
20184: ARRAY
20185: PUSH
20186: LD_INT 1
20188: ARRAY
20189: PPUSH
20190: LD_EXP 66
20194: PUSH
20195: LD_VAR 0 1
20199: ARRAY
20200: PUSH
20201: LD_INT 2
20203: ARRAY
20204: PPUSH
20205: CALL_OW 297
20209: PUSH
20210: LD_INT 8
20212: LESS
20213: IFFALSE 20410
// begin if not artifactsResearched [ i ] then
20215: LD_EXP 69
20219: PUSH
20220: LD_VAR 0 1
20224: ARRAY
20225: NOT
20226: IFFALSE 20307
// begin if BuildingStatus ( nearestLab ) = bs_idle then
20228: LD_VAR 0 5
20232: PPUSH
20233: CALL_OW 461
20237: PUSH
20238: LD_INT 2
20240: EQUAL
20241: IFFALSE 20275
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
20243: LD_INT 7
20245: PPUSH
20246: LD_EXP 74
20250: PUSH
20251: LD_VAR 0 1
20255: ARRAY
20256: PUSH
20257: LD_INT 3
20259: ARRAY
20260: PPUSH
20261: LD_INT 2
20263: PPUSH
20264: LD_VAR 0 5
20268: PPUSH
20269: CALL_OW 468
20273: GO 20305
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
20275: LD_INT 7
20277: PPUSH
20278: LD_EXP 74
20282: PUSH
20283: LD_VAR 0 1
20287: ARRAY
20288: PUSH
20289: LD_INT 3
20291: ARRAY
20292: PPUSH
20293: LD_INT 1
20295: PPUSH
20296: LD_VAR 0 5
20300: PPUSH
20301: CALL_OW 468
// end else
20305: GO 20408
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
20307: LD_VAR 0 5
20311: PPUSH
20312: CALL_OW 461
20316: PUSH
20317: LD_INT 2
20319: EQUAL
20320: PUSH
20321: LD_EXP 75
20325: PUSH
20326: LD_VAR 0 1
20330: ARRAY
20331: AND
20332: IFFALSE 20378
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
20334: LD_INT 7
20336: PPUSH
20337: LD_EXP 74
20341: PUSH
20342: LD_VAR 0 1
20346: ARRAY
20347: PUSH
20348: LD_INT 1
20350: ARRAY
20351: PPUSH
20352: LD_EXP 74
20356: PUSH
20357: LD_VAR 0 1
20361: ARRAY
20362: PUSH
20363: LD_INT 2
20365: ARRAY
20366: PPUSH
20367: LD_VAR 0 5
20371: PPUSH
20372: CALL_OW 468
20376: GO 20408
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
20378: LD_INT 7
20380: PPUSH
20381: LD_EXP 74
20385: PUSH
20386: LD_VAR 0 1
20390: ARRAY
20391: PUSH
20392: LD_INT 1
20394: ARRAY
20395: PPUSH
20396: LD_INT 1
20398: PPUSH
20399: LD_VAR 0 5
20403: PPUSH
20404: CALL_OW 468
// end else
20408: GO 20485
// begin if not artifactsResearched [ i ] then
20410: LD_EXP 69
20414: PUSH
20415: LD_VAR 0 1
20419: ARRAY
20420: NOT
20421: IFFALSE 20455
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
20423: LD_INT 7
20425: PPUSH
20426: LD_EXP 74
20430: PUSH
20431: LD_VAR 0 1
20435: ARRAY
20436: PUSH
20437: LD_INT 3
20439: ARRAY
20440: PPUSH
20441: LD_INT 0
20443: PPUSH
20444: LD_VAR 0 5
20448: PPUSH
20449: CALL_OW 468
20453: GO 20485
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
20455: LD_INT 7
20457: PPUSH
20458: LD_EXP 74
20462: PUSH
20463: LD_VAR 0 1
20467: ARRAY
20468: PUSH
20469: LD_INT 1
20471: ARRAY
20472: PPUSH
20473: LD_INT 0
20475: PPUSH
20476: LD_VAR 0 5
20480: PPUSH
20481: CALL_OW 468
// end ; end else
20485: GO 20624
// begin if not artifactsLabs [ i ] then
20487: LD_EXP 73
20491: PUSH
20492: LD_VAR 0 1
20496: ARRAY
20497: NOT
20498: IFFALSE 20502
// continue ;
20500: GO 19728
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20502: LD_INT 7
20504: PPUSH
20505: LD_EXP 74
20509: PUSH
20510: LD_VAR 0 1
20514: ARRAY
20515: PUSH
20516: LD_INT 3
20518: ARRAY
20519: PPUSH
20520: LD_INT 0
20522: PPUSH
20523: LD_EXP 73
20527: PUSH
20528: LD_VAR 0 1
20532: ARRAY
20533: PPUSH
20534: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20538: LD_INT 7
20540: PPUSH
20541: LD_EXP 74
20545: PUSH
20546: LD_VAR 0 1
20550: ARRAY
20551: PUSH
20552: LD_INT 1
20554: ARRAY
20555: PPUSH
20556: LD_INT 0
20558: PPUSH
20559: LD_EXP 73
20563: PUSH
20564: LD_VAR 0 1
20568: ARRAY
20569: PPUSH
20570: CALL_OW 468
// if artifactsLabsWorking [ i ] then
20574: LD_EXP 70
20578: PUSH
20579: LD_VAR 0 1
20583: ARRAY
20584: IFFALSE 20624
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
20586: LD_ADDR_EXP 70
20590: PUSH
20591: LD_EXP 70
20595: PPUSH
20596: LD_VAR 0 1
20600: PPUSH
20601: LD_INT 0
20603: PPUSH
20604: CALL_OW 1
20608: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
20609: LD_EXP 73
20613: PUSH
20614: LD_VAR 0 1
20618: ARRAY
20619: PPUSH
20620: CALL_OW 127
// end ; end ; end ;
20624: GO 19728
20626: POP
20627: POP
// end ;
20628: PPOPN 5
20630: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
20631: LD_INT 0
20633: PPUSH
20634: PPUSH
20635: PPUSH
20636: PPUSH
20637: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
20638: LD_VAR 0 2
20642: PUSH
20643: LD_EXP 74
20647: PUSH
20648: LD_INT 1
20650: ARRAY
20651: PUSH
20652: LD_INT 3
20654: ARRAY
20655: EQUAL
20656: IFFALSE 20779
// begin lab := artifactsLabs [ 1 ] ;
20658: LD_ADDR_VAR 0 6
20662: PUSH
20663: LD_EXP 73
20667: PUSH
20668: LD_INT 1
20670: ARRAY
20671: ST_TO_ADDR
// if not lab then
20672: LD_VAR 0 6
20676: NOT
20677: IFFALSE 20681
// exit ;
20679: GO 21759
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
20681: LD_VAR 0 6
20685: PPUSH
20686: LD_EXP 71
20690: PUSH
20691: LD_INT 1
20693: ARRAY
20694: PPUSH
20695: LD_INT 1
20697: PPUSH
20698: CALL_OW 486
// if artifactsResProgress [ 1 ] then
20702: LD_EXP 72
20706: PUSH
20707: LD_INT 1
20709: ARRAY
20710: IFFALSE 20730
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
20712: LD_VAR 0 6
20716: PPUSH
20717: LD_EXP 72
20721: PUSH
20722: LD_INT 1
20724: ARRAY
20725: PPUSH
20726: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
20730: LD_ADDR_EXP 70
20734: PUSH
20735: LD_EXP 70
20739: PPUSH
20740: LD_INT 1
20742: PPUSH
20743: LD_INT 1
20745: PPUSH
20746: CALL_OW 1
20750: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
20751: LD_INT 7
20753: PPUSH
20754: LD_EXP 74
20758: PUSH
20759: LD_INT 1
20761: ARRAY
20762: PUSH
20763: LD_INT 3
20765: ARRAY
20766: PPUSH
20767: LD_INT 0
20769: PPUSH
20770: LD_VAR 0 6
20774: PPUSH
20775: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
20779: LD_VAR 0 2
20783: PUSH
20784: LD_EXP 74
20788: PUSH
20789: LD_INT 2
20791: ARRAY
20792: PUSH
20793: LD_INT 3
20795: ARRAY
20796: EQUAL
20797: IFFALSE 20920
// begin lab := artifactsLabs [ 2 ] ;
20799: LD_ADDR_VAR 0 6
20803: PUSH
20804: LD_EXP 73
20808: PUSH
20809: LD_INT 2
20811: ARRAY
20812: ST_TO_ADDR
// if not lab then
20813: LD_VAR 0 6
20817: NOT
20818: IFFALSE 20822
// exit ;
20820: GO 21759
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
20822: LD_VAR 0 6
20826: PPUSH
20827: LD_EXP 71
20831: PUSH
20832: LD_INT 2
20834: ARRAY
20835: PPUSH
20836: LD_INT 1
20838: PPUSH
20839: CALL_OW 486
// if artifactsResProgress [ 2 ] then
20843: LD_EXP 72
20847: PUSH
20848: LD_INT 2
20850: ARRAY
20851: IFFALSE 20871
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
20853: LD_VAR 0 6
20857: PPUSH
20858: LD_EXP 72
20862: PUSH
20863: LD_INT 2
20865: ARRAY
20866: PPUSH
20867: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
20871: LD_ADDR_EXP 70
20875: PUSH
20876: LD_EXP 70
20880: PPUSH
20881: LD_INT 2
20883: PPUSH
20884: LD_INT 1
20886: PPUSH
20887: CALL_OW 1
20891: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
20892: LD_INT 7
20894: PPUSH
20895: LD_EXP 74
20899: PUSH
20900: LD_INT 2
20902: ARRAY
20903: PUSH
20904: LD_INT 3
20906: ARRAY
20907: PPUSH
20908: LD_INT 0
20910: PPUSH
20911: LD_VAR 0 6
20915: PPUSH
20916: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20920: LD_VAR 0 2
20924: PUSH
20925: LD_EXP 74
20929: PUSH
20930: LD_INT 3
20932: ARRAY
20933: PUSH
20934: LD_INT 3
20936: ARRAY
20937: EQUAL
20938: IFFALSE 21061
// begin lab := artifactsLabs [ 3 ] ;
20940: LD_ADDR_VAR 0 6
20944: PUSH
20945: LD_EXP 73
20949: PUSH
20950: LD_INT 3
20952: ARRAY
20953: ST_TO_ADDR
// if not lab then
20954: LD_VAR 0 6
20958: NOT
20959: IFFALSE 20963
// exit ;
20961: GO 21759
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20963: LD_VAR 0 6
20967: PPUSH
20968: LD_EXP 71
20972: PUSH
20973: LD_INT 3
20975: ARRAY
20976: PPUSH
20977: LD_INT 1
20979: PPUSH
20980: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20984: LD_EXP 72
20988: PUSH
20989: LD_INT 3
20991: ARRAY
20992: IFFALSE 21012
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20994: LD_VAR 0 6
20998: PPUSH
20999: LD_EXP 72
21003: PUSH
21004: LD_INT 3
21006: ARRAY
21007: PPUSH
21008: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
21012: LD_ADDR_EXP 70
21016: PUSH
21017: LD_EXP 70
21021: PPUSH
21022: LD_INT 3
21024: PPUSH
21025: LD_INT 1
21027: PPUSH
21028: CALL_OW 1
21032: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
21033: LD_INT 7
21035: PPUSH
21036: LD_EXP 74
21040: PUSH
21041: LD_INT 3
21043: ARRAY
21044: PUSH
21045: LD_INT 3
21047: ARRAY
21048: PPUSH
21049: LD_INT 0
21051: PPUSH
21052: LD_VAR 0 6
21056: PPUSH
21057: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
21061: LD_VAR 0 2
21065: PUSH
21066: LD_EXP 74
21070: PUSH
21071: LD_INT 1
21073: ARRAY
21074: PUSH
21075: LD_INT 1
21077: ARRAY
21078: EQUAL
21079: IFFALSE 21237
// begin lab := artifactsLabs [ 1 ] ;
21081: LD_ADDR_VAR 0 6
21085: PUSH
21086: LD_EXP 73
21090: PUSH
21091: LD_INT 1
21093: ARRAY
21094: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
21095: LD_VAR 0 6
21099: PPUSH
21100: CALL_OW 274
21104: PPUSH
21105: CALL 90413 0 1
21109: PUSH
21110: LD_INT 3
21112: ARRAY
21113: PUSH
21114: LD_EXP 68
21118: PUSH
21119: LD_INT 1
21121: ARRAY
21122: LESS
21123: IFFALSE 21137
// begin HintSpec ( ArtifactCost , 2 ) ;
21125: LD_STRING ArtifactCost
21127: PPUSH
21128: LD_INT 2
21130: PPUSH
21131: CALL_OW 338
// exit ;
21135: GO 21759
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
21137: LD_ADDR_EXP 75
21141: PUSH
21142: LD_EXP 75
21146: PPUSH
21147: LD_INT 1
21149: PPUSH
21150: LD_INT 0
21152: PPUSH
21153: CALL_OW 1
21157: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
21158: LD_VAR 0 3
21162: PPUSH
21163: LD_VAR 0 4
21167: PPUSH
21168: LD_INT 7
21170: PPUSH
21171: LD_INT 12
21173: NEG
21174: PPUSH
21175: CALL_OW 330
// wait ( 0 0$30 ) ;
21179: LD_INT 1050
21181: PPUSH
21182: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
21186: LD_VAR 0 3
21190: PPUSH
21191: LD_VAR 0 4
21195: PPUSH
21196: LD_INT 7
21198: PPUSH
21199: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
21203: LD_EXP 67
21207: PUSH
21208: LD_INT 1
21210: ARRAY
21211: PPUSH
21212: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
21216: LD_ADDR_EXP 75
21220: PUSH
21221: LD_EXP 75
21225: PPUSH
21226: LD_INT 1
21228: PPUSH
21229: LD_INT 1
21231: PPUSH
21232: CALL_OW 1
21236: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
21237: LD_VAR 0 2
21241: PUSH
21242: LD_EXP 74
21246: PUSH
21247: LD_INT 2
21249: ARRAY
21250: PUSH
21251: LD_INT 1
21253: ARRAY
21254: EQUAL
21255: IFFALSE 21492
// begin lab := artifactsLabs [ 2 ] ;
21257: LD_ADDR_VAR 0 6
21261: PUSH
21262: LD_EXP 73
21266: PUSH
21267: LD_INT 2
21269: ARRAY
21270: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
21271: LD_VAR 0 3
21275: PUSH
21276: LD_INT 81
21278: PUSH
21279: LD_INT 7
21281: PUSH
21282: EMPTY
21283: LIST
21284: LIST
21285: PUSH
21286: LD_INT 2
21288: PUSH
21289: LD_INT 32
21291: PUSH
21292: LD_INT 3
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: PUSH
21299: LD_INT 30
21301: PUSH
21302: LD_INT 28
21304: PUSH
21305: EMPTY
21306: LIST
21307: LIST
21308: PUSH
21309: LD_INT 30
21311: PUSH
21312: LD_INT 30
21314: PUSH
21315: EMPTY
21316: LIST
21317: LIST
21318: PUSH
21319: LD_INT 35
21321: PUSH
21322: LD_INT 49
21324: PUSH
21325: EMPTY
21326: LIST
21327: LIST
21328: PUSH
21329: LD_INT 34
21331: PUSH
21332: LD_INT 49
21334: PUSH
21335: EMPTY
21336: LIST
21337: LIST
21338: PUSH
21339: LD_INT 30
21341: PUSH
21342: LD_INT 21
21344: PUSH
21345: EMPTY
21346: LIST
21347: LIST
21348: PUSH
21349: EMPTY
21350: LIST
21351: LIST
21352: LIST
21353: LIST
21354: LIST
21355: LIST
21356: LIST
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: PPUSH
21362: CALL_OW 69
21366: IN
21367: NOT
21368: IFFALSE 21372
// exit ;
21370: GO 21759
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
21372: LD_VAR 0 6
21376: PPUSH
21377: CALL_OW 274
21381: PPUSH
21382: CALL 90413 0 1
21386: PUSH
21387: LD_INT 3
21389: ARRAY
21390: PUSH
21391: LD_EXP 68
21395: PUSH
21396: LD_INT 2
21398: ARRAY
21399: LESS
21400: IFFALSE 21414
// begin HintSpec ( ArtifactCost , 2 ) ;
21402: LD_STRING ArtifactCost
21404: PPUSH
21405: LD_INT 2
21407: PPUSH
21408: CALL_OW 338
// exit ;
21412: GO 21759
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
21414: LD_ADDR_EXP 75
21418: PUSH
21419: LD_EXP 75
21423: PPUSH
21424: LD_INT 2
21426: PPUSH
21427: LD_INT 0
21429: PPUSH
21430: CALL_OW 1
21434: ST_TO_ADDR
// KillUnit ( x ) ;
21435: LD_VAR 0 3
21439: PPUSH
21440: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
21444: LD_ADDR_EXP 16
21448: PUSH
21449: LD_EXP 16
21453: PUSH
21454: LD_INT 1
21456: PLUS
21457: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
21458: LD_EXP 67
21462: PUSH
21463: LD_INT 2
21465: ARRAY
21466: PPUSH
21467: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
21471: LD_ADDR_EXP 75
21475: PUSH
21476: LD_EXP 75
21480: PPUSH
21481: LD_INT 2
21483: PPUSH
21484: LD_INT 1
21486: PPUSH
21487: CALL_OW 1
21491: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
21492: LD_VAR 0 2
21496: PUSH
21497: LD_EXP 74
21501: PUSH
21502: LD_INT 3
21504: ARRAY
21505: PUSH
21506: LD_INT 1
21508: ARRAY
21509: EQUAL
21510: IFFALSE 21759
// begin lab := artifactsLabs [ 3 ] ;
21512: LD_ADDR_VAR 0 6
21516: PUSH
21517: LD_EXP 73
21521: PUSH
21522: LD_INT 3
21524: ARRAY
21525: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
21526: LD_VAR 0 6
21530: PPUSH
21531: CALL_OW 274
21535: PPUSH
21536: CALL 90413 0 1
21540: PUSH
21541: LD_INT 3
21543: ARRAY
21544: PUSH
21545: LD_EXP 68
21549: PUSH
21550: LD_INT 3
21552: ARRAY
21553: LESS
21554: IFFALSE 21568
// begin HintSpec ( ArtifactCost , 2 ) ;
21556: LD_STRING ArtifactCost
21558: PPUSH
21559: LD_INT 2
21561: PPUSH
21562: CALL_OW 338
// exit ;
21566: GO 21759
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
21568: LD_INT 37
21570: PPUSH
21571: LD_INT 1
21573: PPUSH
21574: CALL_OW 424
// time := 0 0$30 ;
21578: LD_ADDR_VAR 0 7
21582: PUSH
21583: LD_INT 1050
21585: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
21586: LD_ADDR_EXP 75
21590: PUSH
21591: LD_EXP 75
21595: PPUSH
21596: LD_INT 3
21598: PPUSH
21599: LD_INT 0
21601: PPUSH
21602: CALL_OW 1
21606: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
21607: LD_ADDR_OWVAR 47
21611: PUSH
21612: LD_STRING #Am15a-1
21614: PUSH
21615: LD_VAR 0 7
21619: PUSH
21620: EMPTY
21621: LIST
21622: LIST
21623: ST_TO_ADDR
// wait ( 0 0$1 ) ;
21624: LD_INT 35
21626: PPUSH
21627: CALL_OW 67
// time := time - 0 0$1 ;
21631: LD_ADDR_VAR 0 7
21635: PUSH
21636: LD_VAR 0 7
21640: PUSH
21641: LD_INT 35
21643: MINUS
21644: ST_TO_ADDR
// until time = 0 0$00 ;
21645: LD_VAR 0 7
21649: PUSH
21650: LD_INT 0
21652: EQUAL
21653: IFFALSE 21607
// display_strings :=  ;
21655: LD_ADDR_OWVAR 47
21659: PUSH
21660: LD_STRING 
21662: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
21663: LD_INT 37
21665: PPUSH
21666: LD_INT 0
21668: PPUSH
21669: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
21673: LD_ADDR_VAR 0 8
21677: PUSH
21678: LD_INT 37
21680: PPUSH
21681: LD_INT 3
21683: PUSH
21684: LD_INT 21
21686: PUSH
21687: LD_INT 3
21689: PUSH
21690: EMPTY
21691: LIST
21692: LIST
21693: PUSH
21694: EMPTY
21695: LIST
21696: LIST
21697: PPUSH
21698: CALL_OW 70
21702: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
21703: LD_VAR 0 3
21707: PPUSH
21708: LD_VAR 0 4
21712: PPUSH
21713: CALL_OW 84
// for un in list do
21717: LD_ADDR_VAR 0 9
21721: PUSH
21722: LD_VAR 0 8
21726: PUSH
21727: FOR_IN
21728: IFFALSE 21757
// TeleportUnit ( un , x , y , 12 , true ) ;
21730: LD_VAR 0 9
21734: PPUSH
21735: LD_VAR 0 3
21739: PPUSH
21740: LD_VAR 0 4
21744: PPUSH
21745: LD_INT 12
21747: PPUSH
21748: LD_INT 1
21750: PPUSH
21751: CALL_OW 483
21755: GO 21727
21757: POP
21758: POP
// end ; end ;
21759: PPOPN 9
21761: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
21762: LD_INT 0
21764: PPUSH
21765: PPUSH
// begin labNum := 0 ;
21766: LD_ADDR_VAR 0 4
21770: PUSH
21771: LD_INT 0
21773: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21774: LD_ADDR_VAR 0 3
21778: PUSH
21779: DOUBLE
21780: LD_INT 1
21782: DEC
21783: ST_TO_ADDR
21784: LD_EXP 73
21788: PUSH
21789: FOR_TO
21790: IFFALSE 21824
// if artifactsLabs [ i ] = lab then
21792: LD_EXP 73
21796: PUSH
21797: LD_VAR 0 3
21801: ARRAY
21802: PUSH
21803: LD_VAR 0 1
21807: EQUAL
21808: IFFALSE 21822
// begin labNum := i ;
21810: LD_ADDR_VAR 0 4
21814: PUSH
21815: LD_VAR 0 3
21819: ST_TO_ADDR
// break ;
21820: GO 21824
// end ;
21822: GO 21789
21824: POP
21825: POP
// if not labNum then
21826: LD_VAR 0 4
21830: NOT
21831: IFFALSE 21835
// exit ;
21833: GO 21913
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
21835: LD_INT 7
21837: PPUSH
21838: LD_EXP 74
21842: PUSH
21843: LD_VAR 0 4
21847: ARRAY
21848: PUSH
21849: LD_INT 3
21851: ARRAY
21852: PPUSH
21853: LD_INT 2
21855: PPUSH
21856: LD_VAR 0 1
21860: PPUSH
21861: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
21865: LD_ADDR_EXP 72
21869: PUSH
21870: LD_EXP 72
21874: PPUSH
21875: LD_VAR 0 4
21879: PPUSH
21880: LD_VAR 0 2
21884: PPUSH
21885: CALL_OW 1
21889: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
21890: LD_ADDR_EXP 70
21894: PUSH
21895: LD_EXP 70
21899: PPUSH
21900: LD_VAR 0 4
21904: PPUSH
21905: LD_INT 0
21907: PPUSH
21908: CALL_OW 1
21912: ST_TO_ADDR
// end ;
21913: PPOPN 4
21915: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21916: LD_INT 0
21918: PPUSH
21919: PPUSH
// begin labNum := 0 ;
21920: LD_ADDR_VAR 0 3
21924: PUSH
21925: LD_INT 0
21927: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21928: LD_ADDR_VAR 0 2
21932: PUSH
21933: DOUBLE
21934: LD_INT 1
21936: DEC
21937: ST_TO_ADDR
21938: LD_EXP 73
21942: PUSH
21943: FOR_TO
21944: IFFALSE 21978
// if artifactsLabs [ i ] = lab then
21946: LD_EXP 73
21950: PUSH
21951: LD_VAR 0 2
21955: ARRAY
21956: PUSH
21957: LD_VAR 0 1
21961: EQUAL
21962: IFFALSE 21976
// begin labNum := i ;
21964: LD_ADDR_VAR 0 3
21968: PUSH
21969: LD_VAR 0 2
21973: ST_TO_ADDR
// break ;
21974: GO 21978
// end ;
21976: GO 21943
21978: POP
21979: POP
// if not labNum then
21980: LD_VAR 0 3
21984: NOT
21985: IFFALSE 21989
// exit ;
21987: GO 22151
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21989: LD_INT 7
21991: PPUSH
21992: LD_EXP 74
21996: PUSH
21997: LD_VAR 0 3
22001: ARRAY
22002: PUSH
22003: LD_INT 3
22005: ARRAY
22006: PPUSH
22007: LD_INT 0
22009: PPUSH
22010: LD_VAR 0 1
22014: PPUSH
22015: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
22019: LD_ADDR_EXP 69
22023: PUSH
22024: LD_EXP 69
22028: PPUSH
22029: LD_VAR 0 3
22033: PPUSH
22034: LD_INT 1
22036: PPUSH
22037: CALL_OW 1
22041: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
22042: LD_ADDR_EXP 75
22046: PUSH
22047: LD_EXP 75
22051: PPUSH
22052: LD_VAR 0 3
22056: PPUSH
22057: LD_INT 1
22059: PPUSH
22060: CALL_OW 1
22064: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
22065: LD_ADDR_EXP 70
22069: PUSH
22070: LD_EXP 70
22074: PPUSH
22075: LD_VAR 0 3
22079: PPUSH
22080: LD_INT 0
22082: PPUSH
22083: CALL_OW 1
22087: ST_TO_ADDR
// case labNum of 1 :
22088: LD_VAR 0 3
22092: PUSH
22093: LD_INT 1
22095: DOUBLE
22096: EQUAL
22097: IFTRUE 22101
22099: GO 22112
22101: POP
// artifactIResearched := true ; 2 :
22102: LD_ADDR_EXP 12
22106: PUSH
22107: LD_INT 1
22109: ST_TO_ADDR
22110: GO 22151
22112: LD_INT 2
22114: DOUBLE
22115: EQUAL
22116: IFTRUE 22120
22118: GO 22131
22120: POP
// artifactIIResearched := true ; 3 :
22121: LD_ADDR_EXP 13
22125: PUSH
22126: LD_INT 1
22128: ST_TO_ADDR
22129: GO 22151
22131: LD_INT 3
22133: DOUBLE
22134: EQUAL
22135: IFTRUE 22139
22137: GO 22150
22139: POP
// artifactIIIResearched := true ; end ;
22140: LD_ADDR_EXP 14
22144: PUSH
22145: LD_INT 1
22147: ST_TO_ADDR
22148: GO 22151
22150: POP
// end ; end_of_file
22151: PPOPN 3
22153: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
22154: LD_INT 0
22156: PPUSH
22157: PPUSH
// skirmish := false ;
22158: LD_ADDR_EXP 76
22162: PUSH
22163: LD_INT 0
22165: ST_TO_ADDR
// debug_mc := false ;
22166: LD_ADDR_EXP 77
22170: PUSH
22171: LD_INT 0
22173: ST_TO_ADDR
// mc_bases := [ ] ;
22174: LD_ADDR_EXP 78
22178: PUSH
22179: EMPTY
22180: ST_TO_ADDR
// mc_sides := [ ] ;
22181: LD_ADDR_EXP 104
22185: PUSH
22186: EMPTY
22187: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
22188: LD_ADDR_EXP 79
22192: PUSH
22193: EMPTY
22194: ST_TO_ADDR
// mc_building_repairs := [ ] ;
22195: LD_ADDR_EXP 80
22199: PUSH
22200: EMPTY
22201: ST_TO_ADDR
// mc_need_heal := [ ] ;
22202: LD_ADDR_EXP 81
22206: PUSH
22207: EMPTY
22208: ST_TO_ADDR
// mc_healers := [ ] ;
22209: LD_ADDR_EXP 82
22213: PUSH
22214: EMPTY
22215: ST_TO_ADDR
// mc_build_list := [ ] ;
22216: LD_ADDR_EXP 83
22220: PUSH
22221: EMPTY
22222: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
22223: LD_ADDR_EXP 110
22227: PUSH
22228: EMPTY
22229: ST_TO_ADDR
// mc_builders := [ ] ;
22230: LD_ADDR_EXP 84
22234: PUSH
22235: EMPTY
22236: ST_TO_ADDR
// mc_construct_list := [ ] ;
22237: LD_ADDR_EXP 85
22241: PUSH
22242: EMPTY
22243: ST_TO_ADDR
// mc_turret_list := [ ] ;
22244: LD_ADDR_EXP 86
22248: PUSH
22249: EMPTY
22250: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
22251: LD_ADDR_EXP 87
22255: PUSH
22256: EMPTY
22257: ST_TO_ADDR
// mc_miners := [ ] ;
22258: LD_ADDR_EXP 92
22262: PUSH
22263: EMPTY
22264: ST_TO_ADDR
// mc_mines := [ ] ;
22265: LD_ADDR_EXP 91
22269: PUSH
22270: EMPTY
22271: ST_TO_ADDR
// mc_minefields := [ ] ;
22272: LD_ADDR_EXP 93
22276: PUSH
22277: EMPTY
22278: ST_TO_ADDR
// mc_crates := [ ] ;
22279: LD_ADDR_EXP 94
22283: PUSH
22284: EMPTY
22285: ST_TO_ADDR
// mc_crates_collector := [ ] ;
22286: LD_ADDR_EXP 95
22290: PUSH
22291: EMPTY
22292: ST_TO_ADDR
// mc_crates_area := [ ] ;
22293: LD_ADDR_EXP 96
22297: PUSH
22298: EMPTY
22299: ST_TO_ADDR
// mc_vehicles := [ ] ;
22300: LD_ADDR_EXP 97
22304: PUSH
22305: EMPTY
22306: ST_TO_ADDR
// mc_attack := [ ] ;
22307: LD_ADDR_EXP 98
22311: PUSH
22312: EMPTY
22313: ST_TO_ADDR
// mc_produce := [ ] ;
22314: LD_ADDR_EXP 99
22318: PUSH
22319: EMPTY
22320: ST_TO_ADDR
// mc_defender := [ ] ;
22321: LD_ADDR_EXP 100
22325: PUSH
22326: EMPTY
22327: ST_TO_ADDR
// mc_parking := [ ] ;
22328: LD_ADDR_EXP 102
22332: PUSH
22333: EMPTY
22334: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
22335: LD_ADDR_EXP 88
22339: PUSH
22340: EMPTY
22341: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
22342: LD_ADDR_EXP 90
22346: PUSH
22347: EMPTY
22348: ST_TO_ADDR
// mc_scan := [ ] ;
22349: LD_ADDR_EXP 101
22353: PUSH
22354: EMPTY
22355: ST_TO_ADDR
// mc_scan_area := [ ] ;
22356: LD_ADDR_EXP 103
22360: PUSH
22361: EMPTY
22362: ST_TO_ADDR
// mc_tech := [ ] ;
22363: LD_ADDR_EXP 105
22367: PUSH
22368: EMPTY
22369: ST_TO_ADDR
// mc_class := [ ] ;
22370: LD_ADDR_EXP 119
22374: PUSH
22375: EMPTY
22376: ST_TO_ADDR
// mc_class_case_use := [ ] ;
22377: LD_ADDR_EXP 120
22381: PUSH
22382: EMPTY
22383: ST_TO_ADDR
// mc_is_defending := [ ] ;
22384: LD_ADDR_EXP 121
22388: PUSH
22389: EMPTY
22390: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
22391: LD_ADDR_EXP 112
22395: PUSH
22396: EMPTY
22397: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
22398: LD_ADDR_EXP 122
22402: PUSH
22403: LD_INT 0
22405: ST_TO_ADDR
// end ;
22406: LD_VAR 0 1
22410: RET
// export function MC_Kill ( base ) ; begin
22411: LD_INT 0
22413: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
22414: LD_ADDR_EXP 78
22418: PUSH
22419: LD_EXP 78
22423: PPUSH
22424: LD_VAR 0 1
22428: PPUSH
22429: EMPTY
22430: PPUSH
22431: CALL_OW 1
22435: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22436: LD_ADDR_EXP 79
22440: PUSH
22441: LD_EXP 79
22445: PPUSH
22446: LD_VAR 0 1
22450: PPUSH
22451: EMPTY
22452: PPUSH
22453: CALL_OW 1
22457: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22458: LD_ADDR_EXP 80
22462: PUSH
22463: LD_EXP 80
22467: PPUSH
22468: LD_VAR 0 1
22472: PPUSH
22473: EMPTY
22474: PPUSH
22475: CALL_OW 1
22479: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22480: LD_ADDR_EXP 81
22484: PUSH
22485: LD_EXP 81
22489: PPUSH
22490: LD_VAR 0 1
22494: PPUSH
22495: EMPTY
22496: PPUSH
22497: CALL_OW 1
22501: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22502: LD_ADDR_EXP 82
22506: PUSH
22507: LD_EXP 82
22511: PPUSH
22512: LD_VAR 0 1
22516: PPUSH
22517: EMPTY
22518: PPUSH
22519: CALL_OW 1
22523: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22524: LD_ADDR_EXP 83
22528: PUSH
22529: LD_EXP 83
22533: PPUSH
22534: LD_VAR 0 1
22538: PPUSH
22539: EMPTY
22540: PPUSH
22541: CALL_OW 1
22545: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22546: LD_ADDR_EXP 84
22550: PUSH
22551: LD_EXP 84
22555: PPUSH
22556: LD_VAR 0 1
22560: PPUSH
22561: EMPTY
22562: PPUSH
22563: CALL_OW 1
22567: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22568: LD_ADDR_EXP 85
22572: PUSH
22573: LD_EXP 85
22577: PPUSH
22578: LD_VAR 0 1
22582: PPUSH
22583: EMPTY
22584: PPUSH
22585: CALL_OW 1
22589: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22590: LD_ADDR_EXP 86
22594: PUSH
22595: LD_EXP 86
22599: PPUSH
22600: LD_VAR 0 1
22604: PPUSH
22605: EMPTY
22606: PPUSH
22607: CALL_OW 1
22611: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22612: LD_ADDR_EXP 87
22616: PUSH
22617: LD_EXP 87
22621: PPUSH
22622: LD_VAR 0 1
22626: PPUSH
22627: EMPTY
22628: PPUSH
22629: CALL_OW 1
22633: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22634: LD_ADDR_EXP 88
22638: PUSH
22639: LD_EXP 88
22643: PPUSH
22644: LD_VAR 0 1
22648: PPUSH
22649: EMPTY
22650: PPUSH
22651: CALL_OW 1
22655: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22656: LD_ADDR_EXP 89
22660: PUSH
22661: LD_EXP 89
22665: PPUSH
22666: LD_VAR 0 1
22670: PPUSH
22671: LD_INT 0
22673: PPUSH
22674: CALL_OW 1
22678: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22679: LD_ADDR_EXP 90
22683: PUSH
22684: LD_EXP 90
22688: PPUSH
22689: LD_VAR 0 1
22693: PPUSH
22694: EMPTY
22695: PPUSH
22696: CALL_OW 1
22700: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22701: LD_ADDR_EXP 91
22705: PUSH
22706: LD_EXP 91
22710: PPUSH
22711: LD_VAR 0 1
22715: PPUSH
22716: EMPTY
22717: PPUSH
22718: CALL_OW 1
22722: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22723: LD_ADDR_EXP 92
22727: PUSH
22728: LD_EXP 92
22732: PPUSH
22733: LD_VAR 0 1
22737: PPUSH
22738: EMPTY
22739: PPUSH
22740: CALL_OW 1
22744: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22745: LD_ADDR_EXP 93
22749: PUSH
22750: LD_EXP 93
22754: PPUSH
22755: LD_VAR 0 1
22759: PPUSH
22760: EMPTY
22761: PPUSH
22762: CALL_OW 1
22766: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22767: LD_ADDR_EXP 94
22771: PUSH
22772: LD_EXP 94
22776: PPUSH
22777: LD_VAR 0 1
22781: PPUSH
22782: EMPTY
22783: PPUSH
22784: CALL_OW 1
22788: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22789: LD_ADDR_EXP 95
22793: PUSH
22794: LD_EXP 95
22798: PPUSH
22799: LD_VAR 0 1
22803: PPUSH
22804: EMPTY
22805: PPUSH
22806: CALL_OW 1
22810: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22811: LD_ADDR_EXP 96
22815: PUSH
22816: LD_EXP 96
22820: PPUSH
22821: LD_VAR 0 1
22825: PPUSH
22826: EMPTY
22827: PPUSH
22828: CALL_OW 1
22832: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22833: LD_ADDR_EXP 97
22837: PUSH
22838: LD_EXP 97
22842: PPUSH
22843: LD_VAR 0 1
22847: PPUSH
22848: EMPTY
22849: PPUSH
22850: CALL_OW 1
22854: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22855: LD_ADDR_EXP 98
22859: PUSH
22860: LD_EXP 98
22864: PPUSH
22865: LD_VAR 0 1
22869: PPUSH
22870: EMPTY
22871: PPUSH
22872: CALL_OW 1
22876: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22877: LD_ADDR_EXP 99
22881: PUSH
22882: LD_EXP 99
22886: PPUSH
22887: LD_VAR 0 1
22891: PPUSH
22892: EMPTY
22893: PPUSH
22894: CALL_OW 1
22898: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22899: LD_ADDR_EXP 100
22903: PUSH
22904: LD_EXP 100
22908: PPUSH
22909: LD_VAR 0 1
22913: PPUSH
22914: EMPTY
22915: PPUSH
22916: CALL_OW 1
22920: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22921: LD_ADDR_EXP 101
22925: PUSH
22926: LD_EXP 101
22930: PPUSH
22931: LD_VAR 0 1
22935: PPUSH
22936: EMPTY
22937: PPUSH
22938: CALL_OW 1
22942: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22943: LD_ADDR_EXP 102
22947: PUSH
22948: LD_EXP 102
22952: PPUSH
22953: LD_VAR 0 1
22957: PPUSH
22958: EMPTY
22959: PPUSH
22960: CALL_OW 1
22964: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22965: LD_ADDR_EXP 103
22969: PUSH
22970: LD_EXP 103
22974: PPUSH
22975: LD_VAR 0 1
22979: PPUSH
22980: EMPTY
22981: PPUSH
22982: CALL_OW 1
22986: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22987: LD_ADDR_EXP 105
22991: PUSH
22992: LD_EXP 105
22996: PPUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: EMPTY
23003: PPUSH
23004: CALL_OW 1
23008: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23009: LD_ADDR_EXP 107
23013: PUSH
23014: LD_EXP 107
23018: PPUSH
23019: LD_VAR 0 1
23023: PPUSH
23024: EMPTY
23025: PPUSH
23026: CALL_OW 1
23030: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23031: LD_ADDR_EXP 108
23035: PUSH
23036: LD_EXP 108
23040: PPUSH
23041: LD_VAR 0 1
23045: PPUSH
23046: EMPTY
23047: PPUSH
23048: CALL_OW 1
23052: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23053: LD_ADDR_EXP 109
23057: PUSH
23058: LD_EXP 109
23062: PPUSH
23063: LD_VAR 0 1
23067: PPUSH
23068: EMPTY
23069: PPUSH
23070: CALL_OW 1
23074: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23075: LD_ADDR_EXP 110
23079: PUSH
23080: LD_EXP 110
23084: PPUSH
23085: LD_VAR 0 1
23089: PPUSH
23090: EMPTY
23091: PPUSH
23092: CALL_OW 1
23096: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23097: LD_ADDR_EXP 111
23101: PUSH
23102: LD_EXP 111
23106: PPUSH
23107: LD_VAR 0 1
23111: PPUSH
23112: EMPTY
23113: PPUSH
23114: CALL_OW 1
23118: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23119: LD_ADDR_EXP 112
23123: PUSH
23124: LD_EXP 112
23128: PPUSH
23129: LD_VAR 0 1
23133: PPUSH
23134: EMPTY
23135: PPUSH
23136: CALL_OW 1
23140: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23141: LD_ADDR_EXP 113
23145: PUSH
23146: LD_EXP 113
23150: PPUSH
23151: LD_VAR 0 1
23155: PPUSH
23156: EMPTY
23157: PPUSH
23158: CALL_OW 1
23162: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23163: LD_ADDR_EXP 114
23167: PUSH
23168: LD_EXP 114
23172: PPUSH
23173: LD_VAR 0 1
23177: PPUSH
23178: EMPTY
23179: PPUSH
23180: CALL_OW 1
23184: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23185: LD_ADDR_EXP 115
23189: PUSH
23190: LD_EXP 115
23194: PPUSH
23195: LD_VAR 0 1
23199: PPUSH
23200: EMPTY
23201: PPUSH
23202: CALL_OW 1
23206: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23207: LD_ADDR_EXP 116
23211: PUSH
23212: LD_EXP 116
23216: PPUSH
23217: LD_VAR 0 1
23221: PPUSH
23222: EMPTY
23223: PPUSH
23224: CALL_OW 1
23228: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23229: LD_ADDR_EXP 117
23233: PUSH
23234: LD_EXP 117
23238: PPUSH
23239: LD_VAR 0 1
23243: PPUSH
23244: EMPTY
23245: PPUSH
23246: CALL_OW 1
23250: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23251: LD_ADDR_EXP 118
23255: PUSH
23256: LD_EXP 118
23260: PPUSH
23261: LD_VAR 0 1
23265: PPUSH
23266: EMPTY
23267: PPUSH
23268: CALL_OW 1
23272: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23273: LD_ADDR_EXP 119
23277: PUSH
23278: LD_EXP 119
23282: PPUSH
23283: LD_VAR 0 1
23287: PPUSH
23288: EMPTY
23289: PPUSH
23290: CALL_OW 1
23294: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23295: LD_ADDR_EXP 120
23299: PUSH
23300: LD_EXP 120
23304: PPUSH
23305: LD_VAR 0 1
23309: PPUSH
23310: LD_INT 0
23312: PPUSH
23313: CALL_OW 1
23317: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23318: LD_ADDR_EXP 121
23322: PUSH
23323: LD_EXP 121
23327: PPUSH
23328: LD_VAR 0 1
23332: PPUSH
23333: LD_INT 0
23335: PPUSH
23336: CALL_OW 1
23340: ST_TO_ADDR
// end ;
23341: LD_VAR 0 2
23345: RET
// export function MC_Add ( side , units ) ; var base ; begin
23346: LD_INT 0
23348: PPUSH
23349: PPUSH
// base := mc_bases + 1 ;
23350: LD_ADDR_VAR 0 4
23354: PUSH
23355: LD_EXP 78
23359: PUSH
23360: LD_INT 1
23362: PLUS
23363: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
23364: LD_ADDR_EXP 104
23368: PUSH
23369: LD_EXP 104
23373: PPUSH
23374: LD_VAR 0 4
23378: PPUSH
23379: LD_VAR 0 1
23383: PPUSH
23384: CALL_OW 1
23388: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
23389: LD_ADDR_EXP 78
23393: PUSH
23394: LD_EXP 78
23398: PPUSH
23399: LD_VAR 0 4
23403: PPUSH
23404: LD_VAR 0 2
23408: PPUSH
23409: CALL_OW 1
23413: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23414: LD_ADDR_EXP 79
23418: PUSH
23419: LD_EXP 79
23423: PPUSH
23424: LD_VAR 0 4
23428: PPUSH
23429: EMPTY
23430: PPUSH
23431: CALL_OW 1
23435: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23436: LD_ADDR_EXP 80
23440: PUSH
23441: LD_EXP 80
23445: PPUSH
23446: LD_VAR 0 4
23450: PPUSH
23451: EMPTY
23452: PPUSH
23453: CALL_OW 1
23457: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23458: LD_ADDR_EXP 81
23462: PUSH
23463: LD_EXP 81
23467: PPUSH
23468: LD_VAR 0 4
23472: PPUSH
23473: EMPTY
23474: PPUSH
23475: CALL_OW 1
23479: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23480: LD_ADDR_EXP 82
23484: PUSH
23485: LD_EXP 82
23489: PPUSH
23490: LD_VAR 0 4
23494: PPUSH
23495: EMPTY
23496: PPUSH
23497: CALL_OW 1
23501: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23502: LD_ADDR_EXP 83
23506: PUSH
23507: LD_EXP 83
23511: PPUSH
23512: LD_VAR 0 4
23516: PPUSH
23517: EMPTY
23518: PPUSH
23519: CALL_OW 1
23523: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23524: LD_ADDR_EXP 84
23528: PUSH
23529: LD_EXP 84
23533: PPUSH
23534: LD_VAR 0 4
23538: PPUSH
23539: EMPTY
23540: PPUSH
23541: CALL_OW 1
23545: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23546: LD_ADDR_EXP 85
23550: PUSH
23551: LD_EXP 85
23555: PPUSH
23556: LD_VAR 0 4
23560: PPUSH
23561: EMPTY
23562: PPUSH
23563: CALL_OW 1
23567: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23568: LD_ADDR_EXP 86
23572: PUSH
23573: LD_EXP 86
23577: PPUSH
23578: LD_VAR 0 4
23582: PPUSH
23583: EMPTY
23584: PPUSH
23585: CALL_OW 1
23589: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23590: LD_ADDR_EXP 87
23594: PUSH
23595: LD_EXP 87
23599: PPUSH
23600: LD_VAR 0 4
23604: PPUSH
23605: EMPTY
23606: PPUSH
23607: CALL_OW 1
23611: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23612: LD_ADDR_EXP 88
23616: PUSH
23617: LD_EXP 88
23621: PPUSH
23622: LD_VAR 0 4
23626: PPUSH
23627: EMPTY
23628: PPUSH
23629: CALL_OW 1
23633: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23634: LD_ADDR_EXP 89
23638: PUSH
23639: LD_EXP 89
23643: PPUSH
23644: LD_VAR 0 4
23648: PPUSH
23649: LD_INT 0
23651: PPUSH
23652: CALL_OW 1
23656: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23657: LD_ADDR_EXP 90
23661: PUSH
23662: LD_EXP 90
23666: PPUSH
23667: LD_VAR 0 4
23671: PPUSH
23672: EMPTY
23673: PPUSH
23674: CALL_OW 1
23678: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23679: LD_ADDR_EXP 91
23683: PUSH
23684: LD_EXP 91
23688: PPUSH
23689: LD_VAR 0 4
23693: PPUSH
23694: EMPTY
23695: PPUSH
23696: CALL_OW 1
23700: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23701: LD_ADDR_EXP 92
23705: PUSH
23706: LD_EXP 92
23710: PPUSH
23711: LD_VAR 0 4
23715: PPUSH
23716: EMPTY
23717: PPUSH
23718: CALL_OW 1
23722: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23723: LD_ADDR_EXP 93
23727: PUSH
23728: LD_EXP 93
23732: PPUSH
23733: LD_VAR 0 4
23737: PPUSH
23738: EMPTY
23739: PPUSH
23740: CALL_OW 1
23744: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23745: LD_ADDR_EXP 94
23749: PUSH
23750: LD_EXP 94
23754: PPUSH
23755: LD_VAR 0 4
23759: PPUSH
23760: EMPTY
23761: PPUSH
23762: CALL_OW 1
23766: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23767: LD_ADDR_EXP 95
23771: PUSH
23772: LD_EXP 95
23776: PPUSH
23777: LD_VAR 0 4
23781: PPUSH
23782: EMPTY
23783: PPUSH
23784: CALL_OW 1
23788: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23789: LD_ADDR_EXP 96
23793: PUSH
23794: LD_EXP 96
23798: PPUSH
23799: LD_VAR 0 4
23803: PPUSH
23804: EMPTY
23805: PPUSH
23806: CALL_OW 1
23810: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23811: LD_ADDR_EXP 97
23815: PUSH
23816: LD_EXP 97
23820: PPUSH
23821: LD_VAR 0 4
23825: PPUSH
23826: EMPTY
23827: PPUSH
23828: CALL_OW 1
23832: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23833: LD_ADDR_EXP 98
23837: PUSH
23838: LD_EXP 98
23842: PPUSH
23843: LD_VAR 0 4
23847: PPUSH
23848: EMPTY
23849: PPUSH
23850: CALL_OW 1
23854: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23855: LD_ADDR_EXP 99
23859: PUSH
23860: LD_EXP 99
23864: PPUSH
23865: LD_VAR 0 4
23869: PPUSH
23870: EMPTY
23871: PPUSH
23872: CALL_OW 1
23876: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23877: LD_ADDR_EXP 100
23881: PUSH
23882: LD_EXP 100
23886: PPUSH
23887: LD_VAR 0 4
23891: PPUSH
23892: EMPTY
23893: PPUSH
23894: CALL_OW 1
23898: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23899: LD_ADDR_EXP 101
23903: PUSH
23904: LD_EXP 101
23908: PPUSH
23909: LD_VAR 0 4
23913: PPUSH
23914: EMPTY
23915: PPUSH
23916: CALL_OW 1
23920: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23921: LD_ADDR_EXP 102
23925: PUSH
23926: LD_EXP 102
23930: PPUSH
23931: LD_VAR 0 4
23935: PPUSH
23936: EMPTY
23937: PPUSH
23938: CALL_OW 1
23942: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23943: LD_ADDR_EXP 103
23947: PUSH
23948: LD_EXP 103
23952: PPUSH
23953: LD_VAR 0 4
23957: PPUSH
23958: EMPTY
23959: PPUSH
23960: CALL_OW 1
23964: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23965: LD_ADDR_EXP 105
23969: PUSH
23970: LD_EXP 105
23974: PPUSH
23975: LD_VAR 0 4
23979: PPUSH
23980: EMPTY
23981: PPUSH
23982: CALL_OW 1
23986: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23987: LD_ADDR_EXP 107
23991: PUSH
23992: LD_EXP 107
23996: PPUSH
23997: LD_VAR 0 4
24001: PPUSH
24002: EMPTY
24003: PPUSH
24004: CALL_OW 1
24008: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24009: LD_ADDR_EXP 108
24013: PUSH
24014: LD_EXP 108
24018: PPUSH
24019: LD_VAR 0 4
24023: PPUSH
24024: EMPTY
24025: PPUSH
24026: CALL_OW 1
24030: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24031: LD_ADDR_EXP 109
24035: PUSH
24036: LD_EXP 109
24040: PPUSH
24041: LD_VAR 0 4
24045: PPUSH
24046: EMPTY
24047: PPUSH
24048: CALL_OW 1
24052: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24053: LD_ADDR_EXP 110
24057: PUSH
24058: LD_EXP 110
24062: PPUSH
24063: LD_VAR 0 4
24067: PPUSH
24068: EMPTY
24069: PPUSH
24070: CALL_OW 1
24074: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24075: LD_ADDR_EXP 111
24079: PUSH
24080: LD_EXP 111
24084: PPUSH
24085: LD_VAR 0 4
24089: PPUSH
24090: EMPTY
24091: PPUSH
24092: CALL_OW 1
24096: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24097: LD_ADDR_EXP 112
24101: PUSH
24102: LD_EXP 112
24106: PPUSH
24107: LD_VAR 0 4
24111: PPUSH
24112: EMPTY
24113: PPUSH
24114: CALL_OW 1
24118: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24119: LD_ADDR_EXP 113
24123: PUSH
24124: LD_EXP 113
24128: PPUSH
24129: LD_VAR 0 4
24133: PPUSH
24134: EMPTY
24135: PPUSH
24136: CALL_OW 1
24140: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24141: LD_ADDR_EXP 114
24145: PUSH
24146: LD_EXP 114
24150: PPUSH
24151: LD_VAR 0 4
24155: PPUSH
24156: EMPTY
24157: PPUSH
24158: CALL_OW 1
24162: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24163: LD_ADDR_EXP 115
24167: PUSH
24168: LD_EXP 115
24172: PPUSH
24173: LD_VAR 0 4
24177: PPUSH
24178: EMPTY
24179: PPUSH
24180: CALL_OW 1
24184: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24185: LD_ADDR_EXP 116
24189: PUSH
24190: LD_EXP 116
24194: PPUSH
24195: LD_VAR 0 4
24199: PPUSH
24200: EMPTY
24201: PPUSH
24202: CALL_OW 1
24206: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24207: LD_ADDR_EXP 117
24211: PUSH
24212: LD_EXP 117
24216: PPUSH
24217: LD_VAR 0 4
24221: PPUSH
24222: EMPTY
24223: PPUSH
24224: CALL_OW 1
24228: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24229: LD_ADDR_EXP 118
24233: PUSH
24234: LD_EXP 118
24238: PPUSH
24239: LD_VAR 0 4
24243: PPUSH
24244: EMPTY
24245: PPUSH
24246: CALL_OW 1
24250: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24251: LD_ADDR_EXP 119
24255: PUSH
24256: LD_EXP 119
24260: PPUSH
24261: LD_VAR 0 4
24265: PPUSH
24266: EMPTY
24267: PPUSH
24268: CALL_OW 1
24272: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24273: LD_ADDR_EXP 120
24277: PUSH
24278: LD_EXP 120
24282: PPUSH
24283: LD_VAR 0 4
24287: PPUSH
24288: LD_INT 0
24290: PPUSH
24291: CALL_OW 1
24295: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24296: LD_ADDR_EXP 121
24300: PUSH
24301: LD_EXP 121
24305: PPUSH
24306: LD_VAR 0 4
24310: PPUSH
24311: LD_INT 0
24313: PPUSH
24314: CALL_OW 1
24318: ST_TO_ADDR
// result := base ;
24319: LD_ADDR_VAR 0 3
24323: PUSH
24324: LD_VAR 0 4
24328: ST_TO_ADDR
// end ;
24329: LD_VAR 0 3
24333: RET
// export function MC_Start ( ) ; var i ; begin
24334: LD_INT 0
24336: PPUSH
24337: PPUSH
// for i = 1 to mc_bases do
24338: LD_ADDR_VAR 0 2
24342: PUSH
24343: DOUBLE
24344: LD_INT 1
24346: DEC
24347: ST_TO_ADDR
24348: LD_EXP 78
24352: PUSH
24353: FOR_TO
24354: IFFALSE 25454
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
24356: LD_ADDR_EXP 78
24360: PUSH
24361: LD_EXP 78
24365: PPUSH
24366: LD_VAR 0 2
24370: PPUSH
24371: LD_EXP 78
24375: PUSH
24376: LD_VAR 0 2
24380: ARRAY
24381: PUSH
24382: LD_INT 0
24384: DIFF
24385: PPUSH
24386: CALL_OW 1
24390: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
24391: LD_ADDR_EXP 79
24395: PUSH
24396: LD_EXP 79
24400: PPUSH
24401: LD_VAR 0 2
24405: PPUSH
24406: EMPTY
24407: PPUSH
24408: CALL_OW 1
24412: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
24413: LD_ADDR_EXP 80
24417: PUSH
24418: LD_EXP 80
24422: PPUSH
24423: LD_VAR 0 2
24427: PPUSH
24428: EMPTY
24429: PPUSH
24430: CALL_OW 1
24434: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
24435: LD_ADDR_EXP 81
24439: PUSH
24440: LD_EXP 81
24444: PPUSH
24445: LD_VAR 0 2
24449: PPUSH
24450: EMPTY
24451: PPUSH
24452: CALL_OW 1
24456: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
24457: LD_ADDR_EXP 82
24461: PUSH
24462: LD_EXP 82
24466: PPUSH
24467: LD_VAR 0 2
24471: PPUSH
24472: EMPTY
24473: PUSH
24474: EMPTY
24475: PUSH
24476: EMPTY
24477: LIST
24478: LIST
24479: PPUSH
24480: CALL_OW 1
24484: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
24485: LD_ADDR_EXP 83
24489: PUSH
24490: LD_EXP 83
24494: PPUSH
24495: LD_VAR 0 2
24499: PPUSH
24500: EMPTY
24501: PPUSH
24502: CALL_OW 1
24506: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
24507: LD_ADDR_EXP 110
24511: PUSH
24512: LD_EXP 110
24516: PPUSH
24517: LD_VAR 0 2
24521: PPUSH
24522: EMPTY
24523: PPUSH
24524: CALL_OW 1
24528: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
24529: LD_ADDR_EXP 84
24533: PUSH
24534: LD_EXP 84
24538: PPUSH
24539: LD_VAR 0 2
24543: PPUSH
24544: EMPTY
24545: PPUSH
24546: CALL_OW 1
24550: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
24551: LD_ADDR_EXP 85
24555: PUSH
24556: LD_EXP 85
24560: PPUSH
24561: LD_VAR 0 2
24565: PPUSH
24566: EMPTY
24567: PPUSH
24568: CALL_OW 1
24572: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
24573: LD_ADDR_EXP 86
24577: PUSH
24578: LD_EXP 86
24582: PPUSH
24583: LD_VAR 0 2
24587: PPUSH
24588: LD_EXP 78
24592: PUSH
24593: LD_VAR 0 2
24597: ARRAY
24598: PPUSH
24599: LD_INT 2
24601: PUSH
24602: LD_INT 30
24604: PUSH
24605: LD_INT 32
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: PUSH
24612: LD_INT 30
24614: PUSH
24615: LD_INT 33
24617: PUSH
24618: EMPTY
24619: LIST
24620: LIST
24621: PUSH
24622: EMPTY
24623: LIST
24624: LIST
24625: LIST
24626: PPUSH
24627: CALL_OW 72
24631: PPUSH
24632: CALL_OW 1
24636: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
24637: LD_ADDR_EXP 87
24641: PUSH
24642: LD_EXP 87
24646: PPUSH
24647: LD_VAR 0 2
24651: PPUSH
24652: LD_EXP 78
24656: PUSH
24657: LD_VAR 0 2
24661: ARRAY
24662: PPUSH
24663: LD_INT 2
24665: PUSH
24666: LD_INT 30
24668: PUSH
24669: LD_INT 32
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: PUSH
24676: LD_INT 30
24678: PUSH
24679: LD_INT 31
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: PUSH
24686: EMPTY
24687: LIST
24688: LIST
24689: LIST
24690: PUSH
24691: LD_INT 58
24693: PUSH
24694: EMPTY
24695: LIST
24696: PUSH
24697: EMPTY
24698: LIST
24699: LIST
24700: PPUSH
24701: CALL_OW 72
24705: PPUSH
24706: CALL_OW 1
24710: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
24711: LD_ADDR_EXP 88
24715: PUSH
24716: LD_EXP 88
24720: PPUSH
24721: LD_VAR 0 2
24725: PPUSH
24726: EMPTY
24727: PPUSH
24728: CALL_OW 1
24732: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
24733: LD_ADDR_EXP 92
24737: PUSH
24738: LD_EXP 92
24742: PPUSH
24743: LD_VAR 0 2
24747: PPUSH
24748: EMPTY
24749: PPUSH
24750: CALL_OW 1
24754: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
24755: LD_ADDR_EXP 91
24759: PUSH
24760: LD_EXP 91
24764: PPUSH
24765: LD_VAR 0 2
24769: PPUSH
24770: EMPTY
24771: PPUSH
24772: CALL_OW 1
24776: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
24777: LD_ADDR_EXP 93
24781: PUSH
24782: LD_EXP 93
24786: PPUSH
24787: LD_VAR 0 2
24791: PPUSH
24792: EMPTY
24793: PPUSH
24794: CALL_OW 1
24798: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
24799: LD_ADDR_EXP 94
24803: PUSH
24804: LD_EXP 94
24808: PPUSH
24809: LD_VAR 0 2
24813: PPUSH
24814: EMPTY
24815: PPUSH
24816: CALL_OW 1
24820: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24821: LD_ADDR_EXP 95
24825: PUSH
24826: LD_EXP 95
24830: PPUSH
24831: LD_VAR 0 2
24835: PPUSH
24836: EMPTY
24837: PPUSH
24838: CALL_OW 1
24842: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24843: LD_ADDR_EXP 96
24847: PUSH
24848: LD_EXP 96
24852: PPUSH
24853: LD_VAR 0 2
24857: PPUSH
24858: EMPTY
24859: PPUSH
24860: CALL_OW 1
24864: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24865: LD_ADDR_EXP 97
24869: PUSH
24870: LD_EXP 97
24874: PPUSH
24875: LD_VAR 0 2
24879: PPUSH
24880: EMPTY
24881: PPUSH
24882: CALL_OW 1
24886: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24887: LD_ADDR_EXP 98
24891: PUSH
24892: LD_EXP 98
24896: PPUSH
24897: LD_VAR 0 2
24901: PPUSH
24902: EMPTY
24903: PPUSH
24904: CALL_OW 1
24908: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24909: LD_ADDR_EXP 99
24913: PUSH
24914: LD_EXP 99
24918: PPUSH
24919: LD_VAR 0 2
24923: PPUSH
24924: EMPTY
24925: PPUSH
24926: CALL_OW 1
24930: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24931: LD_ADDR_EXP 100
24935: PUSH
24936: LD_EXP 100
24940: PPUSH
24941: LD_VAR 0 2
24945: PPUSH
24946: EMPTY
24947: PPUSH
24948: CALL_OW 1
24952: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24953: LD_ADDR_EXP 89
24957: PUSH
24958: LD_EXP 89
24962: PPUSH
24963: LD_VAR 0 2
24967: PPUSH
24968: LD_INT 0
24970: PPUSH
24971: CALL_OW 1
24975: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24976: LD_ADDR_EXP 102
24980: PUSH
24981: LD_EXP 102
24985: PPUSH
24986: LD_VAR 0 2
24990: PPUSH
24991: LD_INT 0
24993: PPUSH
24994: CALL_OW 1
24998: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24999: LD_ADDR_EXP 90
25003: PUSH
25004: LD_EXP 90
25008: PPUSH
25009: LD_VAR 0 2
25013: PPUSH
25014: EMPTY
25015: PPUSH
25016: CALL_OW 1
25020: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
25021: LD_ADDR_EXP 101
25025: PUSH
25026: LD_EXP 101
25030: PPUSH
25031: LD_VAR 0 2
25035: PPUSH
25036: LD_INT 0
25038: PPUSH
25039: CALL_OW 1
25043: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
25044: LD_ADDR_EXP 103
25048: PUSH
25049: LD_EXP 103
25053: PPUSH
25054: LD_VAR 0 2
25058: PPUSH
25059: EMPTY
25060: PPUSH
25061: CALL_OW 1
25065: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
25066: LD_ADDR_EXP 106
25070: PUSH
25071: LD_EXP 106
25075: PPUSH
25076: LD_VAR 0 2
25080: PPUSH
25081: LD_INT 0
25083: PPUSH
25084: CALL_OW 1
25088: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
25089: LD_ADDR_EXP 107
25093: PUSH
25094: LD_EXP 107
25098: PPUSH
25099: LD_VAR 0 2
25103: PPUSH
25104: EMPTY
25105: PPUSH
25106: CALL_OW 1
25110: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25111: LD_ADDR_EXP 108
25115: PUSH
25116: LD_EXP 108
25120: PPUSH
25121: LD_VAR 0 2
25125: PPUSH
25126: EMPTY
25127: PPUSH
25128: CALL_OW 1
25132: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25133: LD_ADDR_EXP 109
25137: PUSH
25138: LD_EXP 109
25142: PPUSH
25143: LD_VAR 0 2
25147: PPUSH
25148: EMPTY
25149: PPUSH
25150: CALL_OW 1
25154: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
25155: LD_ADDR_EXP 111
25159: PUSH
25160: LD_EXP 111
25164: PPUSH
25165: LD_VAR 0 2
25169: PPUSH
25170: LD_EXP 78
25174: PUSH
25175: LD_VAR 0 2
25179: ARRAY
25180: PPUSH
25181: LD_INT 2
25183: PUSH
25184: LD_INT 30
25186: PUSH
25187: LD_INT 6
25189: PUSH
25190: EMPTY
25191: LIST
25192: LIST
25193: PUSH
25194: LD_INT 30
25196: PUSH
25197: LD_INT 7
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: PUSH
25204: LD_INT 30
25206: PUSH
25207: LD_INT 8
25209: PUSH
25210: EMPTY
25211: LIST
25212: LIST
25213: PUSH
25214: EMPTY
25215: LIST
25216: LIST
25217: LIST
25218: LIST
25219: PPUSH
25220: CALL_OW 72
25224: PPUSH
25225: CALL_OW 1
25229: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
25230: LD_ADDR_EXP 112
25234: PUSH
25235: LD_EXP 112
25239: PPUSH
25240: LD_VAR 0 2
25244: PPUSH
25245: EMPTY
25246: PPUSH
25247: CALL_OW 1
25251: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
25252: LD_ADDR_EXP 113
25256: PUSH
25257: LD_EXP 113
25261: PPUSH
25262: LD_VAR 0 2
25266: PPUSH
25267: EMPTY
25268: PPUSH
25269: CALL_OW 1
25273: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
25274: LD_ADDR_EXP 114
25278: PUSH
25279: LD_EXP 114
25283: PPUSH
25284: LD_VAR 0 2
25288: PPUSH
25289: EMPTY
25290: PPUSH
25291: CALL_OW 1
25295: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
25296: LD_ADDR_EXP 115
25300: PUSH
25301: LD_EXP 115
25305: PPUSH
25306: LD_VAR 0 2
25310: PPUSH
25311: EMPTY
25312: PPUSH
25313: CALL_OW 1
25317: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
25318: LD_ADDR_EXP 116
25322: PUSH
25323: LD_EXP 116
25327: PPUSH
25328: LD_VAR 0 2
25332: PPUSH
25333: EMPTY
25334: PPUSH
25335: CALL_OW 1
25339: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
25340: LD_ADDR_EXP 117
25344: PUSH
25345: LD_EXP 117
25349: PPUSH
25350: LD_VAR 0 2
25354: PPUSH
25355: EMPTY
25356: PPUSH
25357: CALL_OW 1
25361: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
25362: LD_ADDR_EXP 118
25366: PUSH
25367: LD_EXP 118
25371: PPUSH
25372: LD_VAR 0 2
25376: PPUSH
25377: EMPTY
25378: PPUSH
25379: CALL_OW 1
25383: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
25384: LD_ADDR_EXP 119
25388: PUSH
25389: LD_EXP 119
25393: PPUSH
25394: LD_VAR 0 2
25398: PPUSH
25399: EMPTY
25400: PPUSH
25401: CALL_OW 1
25405: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
25406: LD_ADDR_EXP 120
25410: PUSH
25411: LD_EXP 120
25415: PPUSH
25416: LD_VAR 0 2
25420: PPUSH
25421: LD_INT 0
25423: PPUSH
25424: CALL_OW 1
25428: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
25429: LD_ADDR_EXP 121
25433: PUSH
25434: LD_EXP 121
25438: PPUSH
25439: LD_VAR 0 2
25443: PPUSH
25444: LD_INT 0
25446: PPUSH
25447: CALL_OW 1
25451: ST_TO_ADDR
// end ;
25452: GO 24353
25454: POP
25455: POP
// MC_InitSides ( ) ;
25456: CALL 25742 0 0
// MC_InitResearch ( ) ;
25460: CALL 25481 0 0
// CustomInitMacro ( ) ;
25464: CALL 228 0 0
// skirmish := true ;
25468: LD_ADDR_EXP 76
25472: PUSH
25473: LD_INT 1
25475: ST_TO_ADDR
// end ;
25476: LD_VAR 0 1
25480: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
25481: LD_INT 0
25483: PPUSH
25484: PPUSH
25485: PPUSH
25486: PPUSH
25487: PPUSH
25488: PPUSH
// if not mc_bases then
25489: LD_EXP 78
25493: NOT
25494: IFFALSE 25498
// exit ;
25496: GO 25737
// for i = 1 to 8 do
25498: LD_ADDR_VAR 0 2
25502: PUSH
25503: DOUBLE
25504: LD_INT 1
25506: DEC
25507: ST_TO_ADDR
25508: LD_INT 8
25510: PUSH
25511: FOR_TO
25512: IFFALSE 25538
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
25514: LD_ADDR_EXP 105
25518: PUSH
25519: LD_EXP 105
25523: PPUSH
25524: LD_VAR 0 2
25528: PPUSH
25529: EMPTY
25530: PPUSH
25531: CALL_OW 1
25535: ST_TO_ADDR
25536: GO 25511
25538: POP
25539: POP
// tmp := [ ] ;
25540: LD_ADDR_VAR 0 5
25544: PUSH
25545: EMPTY
25546: ST_TO_ADDR
// for i = 1 to mc_sides do
25547: LD_ADDR_VAR 0 2
25551: PUSH
25552: DOUBLE
25553: LD_INT 1
25555: DEC
25556: ST_TO_ADDR
25557: LD_EXP 104
25561: PUSH
25562: FOR_TO
25563: IFFALSE 25621
// if not mc_sides [ i ] in tmp then
25565: LD_EXP 104
25569: PUSH
25570: LD_VAR 0 2
25574: ARRAY
25575: PUSH
25576: LD_VAR 0 5
25580: IN
25581: NOT
25582: IFFALSE 25619
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
25584: LD_ADDR_VAR 0 5
25588: PUSH
25589: LD_VAR 0 5
25593: PPUSH
25594: LD_VAR 0 5
25598: PUSH
25599: LD_INT 1
25601: PLUS
25602: PPUSH
25603: LD_EXP 104
25607: PUSH
25608: LD_VAR 0 2
25612: ARRAY
25613: PPUSH
25614: CALL_OW 2
25618: ST_TO_ADDR
25619: GO 25562
25621: POP
25622: POP
// if not tmp then
25623: LD_VAR 0 5
25627: NOT
25628: IFFALSE 25632
// exit ;
25630: GO 25737
// for j in tmp do
25632: LD_ADDR_VAR 0 3
25636: PUSH
25637: LD_VAR 0 5
25641: PUSH
25642: FOR_IN
25643: IFFALSE 25735
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
25645: LD_ADDR_VAR 0 6
25649: PUSH
25650: LD_INT 22
25652: PUSH
25653: LD_VAR 0 3
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: ST_TO_ADDR
// if not un then
25667: LD_VAR 0 6
25671: NOT
25672: IFFALSE 25676
// continue ;
25674: GO 25642
// nation := GetNation ( un [ 1 ] ) ;
25676: LD_ADDR_VAR 0 4
25680: PUSH
25681: LD_VAR 0 6
25685: PUSH
25686: LD_INT 1
25688: ARRAY
25689: PPUSH
25690: CALL_OW 248
25694: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
25695: LD_ADDR_EXP 105
25699: PUSH
25700: LD_EXP 105
25704: PPUSH
25705: LD_VAR 0 3
25709: PPUSH
25710: LD_VAR 0 3
25714: PPUSH
25715: LD_VAR 0 4
25719: PPUSH
25720: LD_INT 1
25722: PPUSH
25723: CALL 52925 0 3
25727: PPUSH
25728: CALL_OW 1
25732: ST_TO_ADDR
// end ;
25733: GO 25642
25735: POP
25736: POP
// end ;
25737: LD_VAR 0 1
25741: RET
// export function MC_InitSides ( ) ; var i ; begin
25742: LD_INT 0
25744: PPUSH
25745: PPUSH
// if not mc_bases then
25746: LD_EXP 78
25750: NOT
25751: IFFALSE 25755
// exit ;
25753: GO 25829
// for i = 1 to mc_bases do
25755: LD_ADDR_VAR 0 2
25759: PUSH
25760: DOUBLE
25761: LD_INT 1
25763: DEC
25764: ST_TO_ADDR
25765: LD_EXP 78
25769: PUSH
25770: FOR_TO
25771: IFFALSE 25827
// if mc_bases [ i ] then
25773: LD_EXP 78
25777: PUSH
25778: LD_VAR 0 2
25782: ARRAY
25783: IFFALSE 25825
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
25785: LD_ADDR_EXP 104
25789: PUSH
25790: LD_EXP 104
25794: PPUSH
25795: LD_VAR 0 2
25799: PPUSH
25800: LD_EXP 78
25804: PUSH
25805: LD_VAR 0 2
25809: ARRAY
25810: PUSH
25811: LD_INT 1
25813: ARRAY
25814: PPUSH
25815: CALL_OW 255
25819: PPUSH
25820: CALL_OW 1
25824: ST_TO_ADDR
25825: GO 25770
25827: POP
25828: POP
// end ;
25829: LD_VAR 0 1
25833: RET
// every 0 0$03 trigger skirmish do
25834: LD_EXP 76
25838: IFFALSE 25992
25840: GO 25842
25842: DISABLE
// begin enable ;
25843: ENABLE
// MC_CheckBuildings ( ) ;
25844: CALL 30504 0 0
// MC_CheckPeopleLife ( ) ;
25848: CALL 30665 0 0
// RaiseSailEvent ( 100 ) ;
25852: LD_INT 100
25854: PPUSH
25855: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25859: LD_INT 103
25861: PPUSH
25862: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25866: LD_INT 104
25868: PPUSH
25869: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25873: LD_INT 105
25875: PPUSH
25876: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25880: LD_INT 106
25882: PPUSH
25883: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25887: LD_INT 107
25889: PPUSH
25890: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25894: LD_INT 108
25896: PPUSH
25897: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25901: LD_INT 109
25903: PPUSH
25904: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25908: LD_INT 110
25910: PPUSH
25911: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25915: LD_INT 111
25917: PPUSH
25918: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25922: LD_INT 112
25924: PPUSH
25925: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25929: LD_INT 113
25931: PPUSH
25932: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25936: LD_INT 120
25938: PPUSH
25939: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25943: LD_INT 121
25945: PPUSH
25946: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25950: LD_INT 122
25952: PPUSH
25953: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25957: LD_INT 123
25959: PPUSH
25960: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25964: LD_INT 124
25966: PPUSH
25967: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25971: LD_INT 125
25973: PPUSH
25974: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25978: LD_INT 126
25980: PPUSH
25981: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25985: LD_INT 200
25987: PPUSH
25988: CALL_OW 427
// end ;
25992: END
// on SailEvent ( event ) do begin if event < 100 then
25993: LD_VAR 0 1
25997: PUSH
25998: LD_INT 100
26000: LESS
26001: IFFALSE 26012
// CustomEvent ( event ) ;
26003: LD_VAR 0 1
26007: PPUSH
26008: CALL 11285 0 1
// if event = 100 then
26012: LD_VAR 0 1
26016: PUSH
26017: LD_INT 100
26019: EQUAL
26020: IFFALSE 26026
// MC_ClassManager ( ) ;
26022: CALL 26418 0 0
// if event = 101 then
26026: LD_VAR 0 1
26030: PUSH
26031: LD_INT 101
26033: EQUAL
26034: IFFALSE 26040
// MC_RepairBuildings ( ) ;
26036: CALL 31250 0 0
// if event = 102 then
26040: LD_VAR 0 1
26044: PUSH
26045: LD_INT 102
26047: EQUAL
26048: IFFALSE 26054
// MC_Heal ( ) ;
26050: CALL 32185 0 0
// if event = 103 then
26054: LD_VAR 0 1
26058: PUSH
26059: LD_INT 103
26061: EQUAL
26062: IFFALSE 26068
// MC_Build ( ) ;
26064: CALL 32607 0 0
// if event = 104 then
26068: LD_VAR 0 1
26072: PUSH
26073: LD_INT 104
26075: EQUAL
26076: IFFALSE 26082
// MC_TurretWeapon ( ) ;
26078: CALL 34241 0 0
// if event = 105 then
26082: LD_VAR 0 1
26086: PUSH
26087: LD_INT 105
26089: EQUAL
26090: IFFALSE 26096
// MC_BuildUpgrade ( ) ;
26092: CALL 33792 0 0
// if event = 106 then
26096: LD_VAR 0 1
26100: PUSH
26101: LD_INT 106
26103: EQUAL
26104: IFFALSE 26110
// MC_PlantMines ( ) ;
26106: CALL 34671 0 0
// if event = 107 then
26110: LD_VAR 0 1
26114: PUSH
26115: LD_INT 107
26117: EQUAL
26118: IFFALSE 26124
// MC_CollectCrates ( ) ;
26120: CALL 35469 0 0
// if event = 108 then
26124: LD_VAR 0 1
26128: PUSH
26129: LD_INT 108
26131: EQUAL
26132: IFFALSE 26138
// MC_LinkRemoteControl ( ) ;
26134: CALL 37319 0 0
// if event = 109 then
26138: LD_VAR 0 1
26142: PUSH
26143: LD_INT 109
26145: EQUAL
26146: IFFALSE 26152
// MC_ProduceVehicle ( ) ;
26148: CALL 37500 0 0
// if event = 110 then
26152: LD_VAR 0 1
26156: PUSH
26157: LD_INT 110
26159: EQUAL
26160: IFFALSE 26166
// MC_SendAttack ( ) ;
26162: CALL 37966 0 0
// if event = 111 then
26166: LD_VAR 0 1
26170: PUSH
26171: LD_INT 111
26173: EQUAL
26174: IFFALSE 26180
// MC_Defend ( ) ;
26176: CALL 38074 0 0
// if event = 112 then
26180: LD_VAR 0 1
26184: PUSH
26185: LD_INT 112
26187: EQUAL
26188: IFFALSE 26194
// MC_Research ( ) ;
26190: CALL 38954 0 0
// if event = 113 then
26194: LD_VAR 0 1
26198: PUSH
26199: LD_INT 113
26201: EQUAL
26202: IFFALSE 26208
// MC_MinesTrigger ( ) ;
26204: CALL 40068 0 0
// if event = 120 then
26208: LD_VAR 0 1
26212: PUSH
26213: LD_INT 120
26215: EQUAL
26216: IFFALSE 26222
// MC_RepairVehicle ( ) ;
26218: CALL 40167 0 0
// if event = 121 then
26222: LD_VAR 0 1
26226: PUSH
26227: LD_INT 121
26229: EQUAL
26230: IFFALSE 26236
// MC_TameApe ( ) ;
26232: CALL 40936 0 0
// if event = 122 then
26236: LD_VAR 0 1
26240: PUSH
26241: LD_INT 122
26243: EQUAL
26244: IFFALSE 26250
// MC_ChangeApeClass ( ) ;
26246: CALL 41765 0 0
// if event = 123 then
26250: LD_VAR 0 1
26254: PUSH
26255: LD_INT 123
26257: EQUAL
26258: IFFALSE 26264
// MC_Bazooka ( ) ;
26260: CALL 42415 0 0
// if event = 124 then
26264: LD_VAR 0 1
26268: PUSH
26269: LD_INT 124
26271: EQUAL
26272: IFFALSE 26278
// MC_TeleportExit ( ) ;
26274: CALL 42613 0 0
// if event = 125 then
26278: LD_VAR 0 1
26282: PUSH
26283: LD_INT 125
26285: EQUAL
26286: IFFALSE 26292
// MC_Deposits ( ) ;
26288: CALL 43260 0 0
// if event = 126 then
26292: LD_VAR 0 1
26296: PUSH
26297: LD_INT 126
26299: EQUAL
26300: IFFALSE 26306
// MC_RemoteDriver ( ) ;
26302: CALL 43885 0 0
// if event = 200 then
26306: LD_VAR 0 1
26310: PUSH
26311: LD_INT 200
26313: EQUAL
26314: IFFALSE 26320
// MC_Idle ( ) ;
26316: CALL 45792 0 0
// end ;
26320: PPOPN 1
26322: END
// export function MC_Reset ( base , tag ) ; var i ; begin
26323: LD_INT 0
26325: PPUSH
26326: PPUSH
// if not mc_bases [ base ] or not tag then
26327: LD_EXP 78
26331: PUSH
26332: LD_VAR 0 1
26336: ARRAY
26337: NOT
26338: PUSH
26339: LD_VAR 0 2
26343: NOT
26344: OR
26345: IFFALSE 26349
// exit ;
26347: GO 26413
// for i in mc_bases [ base ] union mc_ape [ base ] do
26349: LD_ADDR_VAR 0 4
26353: PUSH
26354: LD_EXP 78
26358: PUSH
26359: LD_VAR 0 1
26363: ARRAY
26364: PUSH
26365: LD_EXP 107
26369: PUSH
26370: LD_VAR 0 1
26374: ARRAY
26375: UNION
26376: PUSH
26377: FOR_IN
26378: IFFALSE 26411
// if GetTag ( i ) = tag then
26380: LD_VAR 0 4
26384: PPUSH
26385: CALL_OW 110
26389: PUSH
26390: LD_VAR 0 2
26394: EQUAL
26395: IFFALSE 26409
// SetTag ( i , 0 ) ;
26397: LD_VAR 0 4
26401: PPUSH
26402: LD_INT 0
26404: PPUSH
26405: CALL_OW 109
26409: GO 26377
26411: POP
26412: POP
// end ;
26413: LD_VAR 0 3
26417: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
26418: LD_INT 0
26420: PPUSH
26421: PPUSH
26422: PPUSH
26423: PPUSH
26424: PPUSH
26425: PPUSH
26426: PPUSH
26427: PPUSH
// if not mc_bases then
26428: LD_EXP 78
26432: NOT
26433: IFFALSE 26437
// exit ;
26435: GO 26886
// for i = 1 to mc_bases do
26437: LD_ADDR_VAR 0 2
26441: PUSH
26442: DOUBLE
26443: LD_INT 1
26445: DEC
26446: ST_TO_ADDR
26447: LD_EXP 78
26451: PUSH
26452: FOR_TO
26453: IFFALSE 26884
// begin tmp := MC_ClassCheckReq ( i ) ;
26455: LD_ADDR_VAR 0 4
26459: PUSH
26460: LD_VAR 0 2
26464: PPUSH
26465: CALL 26891 0 1
26469: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
26470: LD_ADDR_EXP 119
26474: PUSH
26475: LD_EXP 119
26479: PPUSH
26480: LD_VAR 0 2
26484: PPUSH
26485: LD_VAR 0 4
26489: PPUSH
26490: CALL_OW 1
26494: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
26495: LD_ADDR_VAR 0 6
26499: PUSH
26500: LD_EXP 78
26504: PUSH
26505: LD_VAR 0 2
26509: ARRAY
26510: PPUSH
26511: LD_INT 2
26513: PUSH
26514: LD_INT 30
26516: PUSH
26517: LD_INT 4
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: PUSH
26524: LD_INT 30
26526: PUSH
26527: LD_INT 5
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: LIST
26538: PPUSH
26539: CALL_OW 72
26543: PUSH
26544: LD_EXP 78
26548: PUSH
26549: LD_VAR 0 2
26553: ARRAY
26554: PPUSH
26555: LD_INT 2
26557: PUSH
26558: LD_INT 30
26560: PUSH
26561: LD_INT 0
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: PUSH
26568: LD_INT 30
26570: PUSH
26571: LD_INT 1
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: LIST
26582: PPUSH
26583: CALL_OW 72
26587: PUSH
26588: LD_EXP 78
26592: PUSH
26593: LD_VAR 0 2
26597: ARRAY
26598: PPUSH
26599: LD_INT 30
26601: PUSH
26602: LD_INT 3
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: PPUSH
26609: CALL_OW 72
26613: PUSH
26614: LD_EXP 78
26618: PUSH
26619: LD_VAR 0 2
26623: ARRAY
26624: PPUSH
26625: LD_INT 2
26627: PUSH
26628: LD_INT 30
26630: PUSH
26631: LD_INT 6
26633: PUSH
26634: EMPTY
26635: LIST
26636: LIST
26637: PUSH
26638: LD_INT 30
26640: PUSH
26641: LD_INT 7
26643: PUSH
26644: EMPTY
26645: LIST
26646: LIST
26647: PUSH
26648: LD_INT 30
26650: PUSH
26651: LD_INT 8
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: LIST
26662: LIST
26663: PPUSH
26664: CALL_OW 72
26668: PUSH
26669: EMPTY
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: ST_TO_ADDR
// for j := 1 to 4 do
26675: LD_ADDR_VAR 0 3
26679: PUSH
26680: DOUBLE
26681: LD_INT 1
26683: DEC
26684: ST_TO_ADDR
26685: LD_INT 4
26687: PUSH
26688: FOR_TO
26689: IFFALSE 26880
// begin if not tmp [ j ] then
26691: LD_VAR 0 4
26695: PUSH
26696: LD_VAR 0 3
26700: ARRAY
26701: NOT
26702: IFFALSE 26706
// continue ;
26704: GO 26688
// for p in tmp [ j ] do
26706: LD_ADDR_VAR 0 5
26710: PUSH
26711: LD_VAR 0 4
26715: PUSH
26716: LD_VAR 0 3
26720: ARRAY
26721: PUSH
26722: FOR_IN
26723: IFFALSE 26876
// begin if not b [ j ] then
26725: LD_VAR 0 6
26729: PUSH
26730: LD_VAR 0 3
26734: ARRAY
26735: NOT
26736: IFFALSE 26740
// break ;
26738: GO 26876
// e := 0 ;
26740: LD_ADDR_VAR 0 7
26744: PUSH
26745: LD_INT 0
26747: ST_TO_ADDR
// for k in b [ j ] do
26748: LD_ADDR_VAR 0 8
26752: PUSH
26753: LD_VAR 0 6
26757: PUSH
26758: LD_VAR 0 3
26762: ARRAY
26763: PUSH
26764: FOR_IN
26765: IFFALSE 26792
// if IsNotFull ( k ) then
26767: LD_VAR 0 8
26771: PPUSH
26772: CALL 55046 0 1
26776: IFFALSE 26790
// begin e := k ;
26778: LD_ADDR_VAR 0 7
26782: PUSH
26783: LD_VAR 0 8
26787: ST_TO_ADDR
// break ;
26788: GO 26792
// end ;
26790: GO 26764
26792: POP
26793: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26794: LD_VAR 0 7
26798: PUSH
26799: LD_VAR 0 5
26803: PPUSH
26804: LD_VAR 0 7
26808: PPUSH
26809: CALL 88828 0 2
26813: NOT
26814: AND
26815: IFFALSE 26874
// begin if IsInUnit ( p ) then
26817: LD_VAR 0 5
26821: PPUSH
26822: CALL_OW 310
26826: IFFALSE 26837
// ComExitBuilding ( p ) ;
26828: LD_VAR 0 5
26832: PPUSH
26833: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26837: LD_VAR 0 5
26841: PPUSH
26842: LD_VAR 0 7
26846: PPUSH
26847: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26851: LD_VAR 0 5
26855: PPUSH
26856: LD_VAR 0 3
26860: PPUSH
26861: CALL_OW 183
// AddComExitBuilding ( p ) ;
26865: LD_VAR 0 5
26869: PPUSH
26870: CALL_OW 182
// end ; end ;
26874: GO 26722
26876: POP
26877: POP
// end ;
26878: GO 26688
26880: POP
26881: POP
// end ;
26882: GO 26452
26884: POP
26885: POP
// end ;
26886: LD_VAR 0 1
26890: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26891: LD_INT 0
26893: PPUSH
26894: PPUSH
26895: PPUSH
26896: PPUSH
26897: PPUSH
26898: PPUSH
26899: PPUSH
26900: PPUSH
26901: PPUSH
26902: PPUSH
26903: PPUSH
26904: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
26905: LD_ADDR_VAR 0 2
26909: PUSH
26910: LD_INT 0
26912: PUSH
26913: LD_INT 0
26915: PUSH
26916: LD_INT 0
26918: PUSH
26919: LD_INT 0
26921: PUSH
26922: EMPTY
26923: LIST
26924: LIST
26925: LIST
26926: LIST
26927: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26928: LD_VAR 0 1
26932: NOT
26933: PUSH
26934: LD_EXP 78
26938: PUSH
26939: LD_VAR 0 1
26943: ARRAY
26944: NOT
26945: OR
26946: PUSH
26947: LD_EXP 78
26951: PUSH
26952: LD_VAR 0 1
26956: ARRAY
26957: PPUSH
26958: LD_INT 2
26960: PUSH
26961: LD_INT 30
26963: PUSH
26964: LD_INT 0
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: PUSH
26971: LD_INT 30
26973: PUSH
26974: LD_INT 1
26976: PUSH
26977: EMPTY
26978: LIST
26979: LIST
26980: PUSH
26981: EMPTY
26982: LIST
26983: LIST
26984: LIST
26985: PPUSH
26986: CALL_OW 72
26990: NOT
26991: OR
26992: IFFALSE 26996
// exit ;
26994: GO 30499
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26996: LD_ADDR_VAR 0 4
27000: PUSH
27001: LD_EXP 78
27005: PUSH
27006: LD_VAR 0 1
27010: ARRAY
27011: PPUSH
27012: LD_INT 2
27014: PUSH
27015: LD_INT 25
27017: PUSH
27018: LD_INT 1
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PUSH
27025: LD_INT 25
27027: PUSH
27028: LD_INT 2
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: PUSH
27035: LD_INT 25
27037: PUSH
27038: LD_INT 3
27040: PUSH
27041: EMPTY
27042: LIST
27043: LIST
27044: PUSH
27045: LD_INT 25
27047: PUSH
27048: LD_INT 4
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PUSH
27055: LD_INT 25
27057: PUSH
27058: LD_INT 5
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: PUSH
27065: LD_INT 25
27067: PUSH
27068: LD_INT 8
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: PUSH
27075: LD_INT 25
27077: PUSH
27078: LD_INT 9
27080: PUSH
27081: EMPTY
27082: LIST
27083: LIST
27084: PUSH
27085: EMPTY
27086: LIST
27087: LIST
27088: LIST
27089: LIST
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: PPUSH
27095: CALL_OW 72
27099: ST_TO_ADDR
// if not tmp then
27100: LD_VAR 0 4
27104: NOT
27105: IFFALSE 27109
// exit ;
27107: GO 30499
// for i in tmp do
27109: LD_ADDR_VAR 0 3
27113: PUSH
27114: LD_VAR 0 4
27118: PUSH
27119: FOR_IN
27120: IFFALSE 27151
// if GetTag ( i ) then
27122: LD_VAR 0 3
27126: PPUSH
27127: CALL_OW 110
27131: IFFALSE 27149
// tmp := tmp diff i ;
27133: LD_ADDR_VAR 0 4
27137: PUSH
27138: LD_VAR 0 4
27142: PUSH
27143: LD_VAR 0 3
27147: DIFF
27148: ST_TO_ADDR
27149: GO 27119
27151: POP
27152: POP
// if not tmp then
27153: LD_VAR 0 4
27157: NOT
27158: IFFALSE 27162
// exit ;
27160: GO 30499
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27162: LD_ADDR_VAR 0 5
27166: PUSH
27167: LD_EXP 78
27171: PUSH
27172: LD_VAR 0 1
27176: ARRAY
27177: PPUSH
27178: LD_INT 2
27180: PUSH
27181: LD_INT 25
27183: PUSH
27184: LD_INT 1
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 25
27193: PUSH
27194: LD_INT 5
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: PUSH
27201: LD_INT 25
27203: PUSH
27204: LD_INT 8
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: LD_INT 25
27213: PUSH
27214: LD_INT 9
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: LIST
27225: LIST
27226: LIST
27227: PPUSH
27228: CALL_OW 72
27232: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
27233: LD_ADDR_VAR 0 6
27237: PUSH
27238: LD_EXP 78
27242: PUSH
27243: LD_VAR 0 1
27247: ARRAY
27248: PPUSH
27249: LD_INT 25
27251: PUSH
27252: LD_INT 2
27254: PUSH
27255: EMPTY
27256: LIST
27257: LIST
27258: PPUSH
27259: CALL_OW 72
27263: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
27264: LD_ADDR_VAR 0 7
27268: PUSH
27269: LD_EXP 78
27273: PUSH
27274: LD_VAR 0 1
27278: ARRAY
27279: PPUSH
27280: LD_INT 25
27282: PUSH
27283: LD_INT 3
27285: PUSH
27286: EMPTY
27287: LIST
27288: LIST
27289: PPUSH
27290: CALL_OW 72
27294: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
27295: LD_ADDR_VAR 0 8
27299: PUSH
27300: LD_EXP 78
27304: PUSH
27305: LD_VAR 0 1
27309: ARRAY
27310: PPUSH
27311: LD_INT 25
27313: PUSH
27314: LD_INT 4
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: PUSH
27321: LD_INT 24
27323: PUSH
27324: LD_INT 251
27326: PUSH
27327: EMPTY
27328: LIST
27329: LIST
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PPUSH
27335: CALL_OW 72
27339: ST_TO_ADDR
// if mc_is_defending [ base ] then
27340: LD_EXP 121
27344: PUSH
27345: LD_VAR 0 1
27349: ARRAY
27350: IFFALSE 27811
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
27352: LD_ADDR_EXP 120
27356: PUSH
27357: LD_EXP 120
27361: PPUSH
27362: LD_VAR 0 1
27366: PPUSH
27367: LD_INT 4
27369: PPUSH
27370: CALL_OW 1
27374: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
27375: LD_ADDR_VAR 0 12
27379: PUSH
27380: LD_EXP 78
27384: PUSH
27385: LD_VAR 0 1
27389: ARRAY
27390: PPUSH
27391: LD_INT 2
27393: PUSH
27394: LD_INT 30
27396: PUSH
27397: LD_INT 4
27399: PUSH
27400: EMPTY
27401: LIST
27402: LIST
27403: PUSH
27404: LD_INT 30
27406: PUSH
27407: LD_INT 5
27409: PUSH
27410: EMPTY
27411: LIST
27412: LIST
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: LIST
27418: PPUSH
27419: CALL_OW 72
27423: ST_TO_ADDR
// if not b then
27424: LD_VAR 0 12
27428: NOT
27429: IFFALSE 27433
// exit ;
27431: GO 30499
// p := [ ] ;
27433: LD_ADDR_VAR 0 11
27437: PUSH
27438: EMPTY
27439: ST_TO_ADDR
// if sci >= 2 then
27440: LD_VAR 0 8
27444: PUSH
27445: LD_INT 2
27447: GREATEREQUAL
27448: IFFALSE 27479
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
27450: LD_ADDR_VAR 0 8
27454: PUSH
27455: LD_VAR 0 8
27459: PUSH
27460: LD_INT 1
27462: ARRAY
27463: PUSH
27464: LD_VAR 0 8
27468: PUSH
27469: LD_INT 2
27471: ARRAY
27472: PUSH
27473: EMPTY
27474: LIST
27475: LIST
27476: ST_TO_ADDR
27477: GO 27540
// if sci = 1 then
27479: LD_VAR 0 8
27483: PUSH
27484: LD_INT 1
27486: EQUAL
27487: IFFALSE 27508
// sci := [ sci [ 1 ] ] else
27489: LD_ADDR_VAR 0 8
27493: PUSH
27494: LD_VAR 0 8
27498: PUSH
27499: LD_INT 1
27501: ARRAY
27502: PUSH
27503: EMPTY
27504: LIST
27505: ST_TO_ADDR
27506: GO 27540
// if sci = 0 then
27508: LD_VAR 0 8
27512: PUSH
27513: LD_INT 0
27515: EQUAL
27516: IFFALSE 27540
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
27518: LD_ADDR_VAR 0 11
27522: PUSH
27523: LD_VAR 0 4
27527: PPUSH
27528: LD_INT 4
27530: PPUSH
27531: CALL 88700 0 2
27535: PUSH
27536: LD_INT 1
27538: ARRAY
27539: ST_TO_ADDR
// if eng > 4 then
27540: LD_VAR 0 6
27544: PUSH
27545: LD_INT 4
27547: GREATER
27548: IFFALSE 27594
// for i = eng downto 4 do
27550: LD_ADDR_VAR 0 3
27554: PUSH
27555: DOUBLE
27556: LD_VAR 0 6
27560: INC
27561: ST_TO_ADDR
27562: LD_INT 4
27564: PUSH
27565: FOR_DOWNTO
27566: IFFALSE 27592
// eng := eng diff eng [ i ] ;
27568: LD_ADDR_VAR 0 6
27572: PUSH
27573: LD_VAR 0 6
27577: PUSH
27578: LD_VAR 0 6
27582: PUSH
27583: LD_VAR 0 3
27587: ARRAY
27588: DIFF
27589: ST_TO_ADDR
27590: GO 27565
27592: POP
27593: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
27594: LD_ADDR_VAR 0 4
27598: PUSH
27599: LD_VAR 0 4
27603: PUSH
27604: LD_VAR 0 5
27608: PUSH
27609: LD_VAR 0 6
27613: UNION
27614: PUSH
27615: LD_VAR 0 7
27619: UNION
27620: PUSH
27621: LD_VAR 0 8
27625: UNION
27626: DIFF
27627: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
27628: LD_ADDR_VAR 0 13
27632: PUSH
27633: LD_EXP 78
27637: PUSH
27638: LD_VAR 0 1
27642: ARRAY
27643: PPUSH
27644: LD_INT 2
27646: PUSH
27647: LD_INT 30
27649: PUSH
27650: LD_INT 32
27652: PUSH
27653: EMPTY
27654: LIST
27655: LIST
27656: PUSH
27657: LD_INT 30
27659: PUSH
27660: LD_INT 31
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: EMPTY
27668: LIST
27669: LIST
27670: LIST
27671: PPUSH
27672: CALL_OW 72
27676: PUSH
27677: LD_EXP 78
27681: PUSH
27682: LD_VAR 0 1
27686: ARRAY
27687: PPUSH
27688: LD_INT 2
27690: PUSH
27691: LD_INT 30
27693: PUSH
27694: LD_INT 4
27696: PUSH
27697: EMPTY
27698: LIST
27699: LIST
27700: PUSH
27701: LD_INT 30
27703: PUSH
27704: LD_INT 5
27706: PUSH
27707: EMPTY
27708: LIST
27709: LIST
27710: PUSH
27711: EMPTY
27712: LIST
27713: LIST
27714: LIST
27715: PPUSH
27716: CALL_OW 72
27720: PUSH
27721: LD_INT 6
27723: MUL
27724: PLUS
27725: ST_TO_ADDR
// if bcount < tmp then
27726: LD_VAR 0 13
27730: PUSH
27731: LD_VAR 0 4
27735: LESS
27736: IFFALSE 27782
// for i = tmp downto bcount do
27738: LD_ADDR_VAR 0 3
27742: PUSH
27743: DOUBLE
27744: LD_VAR 0 4
27748: INC
27749: ST_TO_ADDR
27750: LD_VAR 0 13
27754: PUSH
27755: FOR_DOWNTO
27756: IFFALSE 27780
// tmp := Delete ( tmp , tmp ) ;
27758: LD_ADDR_VAR 0 4
27762: PUSH
27763: LD_VAR 0 4
27767: PPUSH
27768: LD_VAR 0 4
27772: PPUSH
27773: CALL_OW 3
27777: ST_TO_ADDR
27778: GO 27755
27780: POP
27781: POP
// result := [ tmp , 0 , 0 , p ] ;
27782: LD_ADDR_VAR 0 2
27786: PUSH
27787: LD_VAR 0 4
27791: PUSH
27792: LD_INT 0
27794: PUSH
27795: LD_INT 0
27797: PUSH
27798: LD_VAR 0 11
27802: PUSH
27803: EMPTY
27804: LIST
27805: LIST
27806: LIST
27807: LIST
27808: ST_TO_ADDR
// exit ;
27809: GO 30499
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27811: LD_EXP 78
27815: PUSH
27816: LD_VAR 0 1
27820: ARRAY
27821: PPUSH
27822: LD_INT 2
27824: PUSH
27825: LD_INT 30
27827: PUSH
27828: LD_INT 6
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: PUSH
27835: LD_INT 30
27837: PUSH
27838: LD_INT 7
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: PUSH
27845: LD_INT 30
27847: PUSH
27848: LD_INT 8
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: LIST
27859: LIST
27860: PPUSH
27861: CALL_OW 72
27865: NOT
27866: PUSH
27867: LD_EXP 78
27871: PUSH
27872: LD_VAR 0 1
27876: ARRAY
27877: PPUSH
27878: LD_INT 30
27880: PUSH
27881: LD_INT 3
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PPUSH
27888: CALL_OW 72
27892: NOT
27893: AND
27894: IFFALSE 27966
// begin if eng = tmp then
27896: LD_VAR 0 6
27900: PUSH
27901: LD_VAR 0 4
27905: EQUAL
27906: IFFALSE 27910
// exit ;
27908: GO 30499
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27910: LD_ADDR_EXP 120
27914: PUSH
27915: LD_EXP 120
27919: PPUSH
27920: LD_VAR 0 1
27924: PPUSH
27925: LD_INT 1
27927: PPUSH
27928: CALL_OW 1
27932: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27933: LD_ADDR_VAR 0 2
27937: PUSH
27938: LD_INT 0
27940: PUSH
27941: LD_VAR 0 4
27945: PUSH
27946: LD_VAR 0 6
27950: DIFF
27951: PUSH
27952: LD_INT 0
27954: PUSH
27955: LD_INT 0
27957: PUSH
27958: EMPTY
27959: LIST
27960: LIST
27961: LIST
27962: LIST
27963: ST_TO_ADDR
// exit ;
27964: GO 30499
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27966: LD_EXP 105
27970: PUSH
27971: LD_EXP 104
27975: PUSH
27976: LD_VAR 0 1
27980: ARRAY
27981: ARRAY
27982: PUSH
27983: LD_EXP 78
27987: PUSH
27988: LD_VAR 0 1
27992: ARRAY
27993: PPUSH
27994: LD_INT 2
27996: PUSH
27997: LD_INT 30
27999: PUSH
28000: LD_INT 6
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: LD_INT 30
28009: PUSH
28010: LD_INT 7
28012: PUSH
28013: EMPTY
28014: LIST
28015: LIST
28016: PUSH
28017: LD_INT 30
28019: PUSH
28020: LD_INT 8
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: PUSH
28027: EMPTY
28028: LIST
28029: LIST
28030: LIST
28031: LIST
28032: PPUSH
28033: CALL_OW 72
28037: AND
28038: PUSH
28039: LD_EXP 78
28043: PUSH
28044: LD_VAR 0 1
28048: ARRAY
28049: PPUSH
28050: LD_INT 30
28052: PUSH
28053: LD_INT 3
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PPUSH
28060: CALL_OW 72
28064: NOT
28065: AND
28066: IFFALSE 28280
// begin if sci >= 6 then
28068: LD_VAR 0 8
28072: PUSH
28073: LD_INT 6
28075: GREATEREQUAL
28076: IFFALSE 28080
// exit ;
28078: GO 30499
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
28080: LD_ADDR_EXP 120
28084: PUSH
28085: LD_EXP 120
28089: PPUSH
28090: LD_VAR 0 1
28094: PPUSH
28095: LD_INT 2
28097: PPUSH
28098: CALL_OW 1
28102: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
28103: LD_ADDR_VAR 0 9
28107: PUSH
28108: LD_VAR 0 4
28112: PUSH
28113: LD_VAR 0 8
28117: DIFF
28118: PPUSH
28119: LD_INT 4
28121: PPUSH
28122: CALL 88700 0 2
28126: ST_TO_ADDR
// p := [ ] ;
28127: LD_ADDR_VAR 0 11
28131: PUSH
28132: EMPTY
28133: ST_TO_ADDR
// if sci < 6 and sort > 6 then
28134: LD_VAR 0 8
28138: PUSH
28139: LD_INT 6
28141: LESS
28142: PUSH
28143: LD_VAR 0 9
28147: PUSH
28148: LD_INT 6
28150: GREATER
28151: AND
28152: IFFALSE 28233
// begin for i = 1 to 6 - sci do
28154: LD_ADDR_VAR 0 3
28158: PUSH
28159: DOUBLE
28160: LD_INT 1
28162: DEC
28163: ST_TO_ADDR
28164: LD_INT 6
28166: PUSH
28167: LD_VAR 0 8
28171: MINUS
28172: PUSH
28173: FOR_TO
28174: IFFALSE 28229
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
28176: LD_ADDR_VAR 0 11
28180: PUSH
28181: LD_VAR 0 11
28185: PPUSH
28186: LD_VAR 0 11
28190: PUSH
28191: LD_INT 1
28193: PLUS
28194: PPUSH
28195: LD_VAR 0 9
28199: PUSH
28200: LD_INT 1
28202: ARRAY
28203: PPUSH
28204: CALL_OW 2
28208: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
28209: LD_ADDR_VAR 0 9
28213: PUSH
28214: LD_VAR 0 9
28218: PPUSH
28219: LD_INT 1
28221: PPUSH
28222: CALL_OW 3
28226: ST_TO_ADDR
// end ;
28227: GO 28173
28229: POP
28230: POP
// end else
28231: GO 28253
// if sort then
28233: LD_VAR 0 9
28237: IFFALSE 28253
// p := sort [ 1 ] ;
28239: LD_ADDR_VAR 0 11
28243: PUSH
28244: LD_VAR 0 9
28248: PUSH
28249: LD_INT 1
28251: ARRAY
28252: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
28253: LD_ADDR_VAR 0 2
28257: PUSH
28258: LD_INT 0
28260: PUSH
28261: LD_INT 0
28263: PUSH
28264: LD_INT 0
28266: PUSH
28267: LD_VAR 0 11
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: LIST
28276: LIST
28277: ST_TO_ADDR
// exit ;
28278: GO 30499
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28280: LD_EXP 105
28284: PUSH
28285: LD_EXP 104
28289: PUSH
28290: LD_VAR 0 1
28294: ARRAY
28295: ARRAY
28296: PUSH
28297: LD_EXP 78
28301: PUSH
28302: LD_VAR 0 1
28306: ARRAY
28307: PPUSH
28308: LD_INT 2
28310: PUSH
28311: LD_INT 30
28313: PUSH
28314: LD_INT 6
28316: PUSH
28317: EMPTY
28318: LIST
28319: LIST
28320: PUSH
28321: LD_INT 30
28323: PUSH
28324: LD_INT 7
28326: PUSH
28327: EMPTY
28328: LIST
28329: LIST
28330: PUSH
28331: LD_INT 30
28333: PUSH
28334: LD_INT 8
28336: PUSH
28337: EMPTY
28338: LIST
28339: LIST
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: LIST
28345: LIST
28346: PPUSH
28347: CALL_OW 72
28351: AND
28352: PUSH
28353: LD_EXP 78
28357: PUSH
28358: LD_VAR 0 1
28362: ARRAY
28363: PPUSH
28364: LD_INT 30
28366: PUSH
28367: LD_INT 3
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PPUSH
28374: CALL_OW 72
28378: AND
28379: IFFALSE 29113
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
28381: LD_ADDR_EXP 120
28385: PUSH
28386: LD_EXP 120
28390: PPUSH
28391: LD_VAR 0 1
28395: PPUSH
28396: LD_INT 3
28398: PPUSH
28399: CALL_OW 1
28403: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28404: LD_ADDR_VAR 0 2
28408: PUSH
28409: LD_INT 0
28411: PUSH
28412: LD_INT 0
28414: PUSH
28415: LD_INT 0
28417: PUSH
28418: LD_INT 0
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: LIST
28425: LIST
28426: ST_TO_ADDR
// if not eng then
28427: LD_VAR 0 6
28431: NOT
28432: IFFALSE 28495
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
28434: LD_ADDR_VAR 0 11
28438: PUSH
28439: LD_VAR 0 4
28443: PPUSH
28444: LD_INT 2
28446: PPUSH
28447: CALL 88700 0 2
28451: PUSH
28452: LD_INT 1
28454: ARRAY
28455: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
28456: LD_ADDR_VAR 0 2
28460: PUSH
28461: LD_VAR 0 2
28465: PPUSH
28466: LD_INT 2
28468: PPUSH
28469: LD_VAR 0 11
28473: PPUSH
28474: CALL_OW 1
28478: ST_TO_ADDR
// tmp := tmp diff p ;
28479: LD_ADDR_VAR 0 4
28483: PUSH
28484: LD_VAR 0 4
28488: PUSH
28489: LD_VAR 0 11
28493: DIFF
28494: ST_TO_ADDR
// end ; if tmp and sci < 6 then
28495: LD_VAR 0 4
28499: PUSH
28500: LD_VAR 0 8
28504: PUSH
28505: LD_INT 6
28507: LESS
28508: AND
28509: IFFALSE 28697
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
28511: LD_ADDR_VAR 0 9
28515: PUSH
28516: LD_VAR 0 4
28520: PUSH
28521: LD_VAR 0 8
28525: PUSH
28526: LD_VAR 0 7
28530: UNION
28531: DIFF
28532: PPUSH
28533: LD_INT 4
28535: PPUSH
28536: CALL 88700 0 2
28540: ST_TO_ADDR
// p := [ ] ;
28541: LD_ADDR_VAR 0 11
28545: PUSH
28546: EMPTY
28547: ST_TO_ADDR
// if sort then
28548: LD_VAR 0 9
28552: IFFALSE 28668
// for i = 1 to 6 - sci do
28554: LD_ADDR_VAR 0 3
28558: PUSH
28559: DOUBLE
28560: LD_INT 1
28562: DEC
28563: ST_TO_ADDR
28564: LD_INT 6
28566: PUSH
28567: LD_VAR 0 8
28571: MINUS
28572: PUSH
28573: FOR_TO
28574: IFFALSE 28666
// begin if i = sort then
28576: LD_VAR 0 3
28580: PUSH
28581: LD_VAR 0 9
28585: EQUAL
28586: IFFALSE 28590
// break ;
28588: GO 28666
// if GetClass ( i ) = 4 then
28590: LD_VAR 0 3
28594: PPUSH
28595: CALL_OW 257
28599: PUSH
28600: LD_INT 4
28602: EQUAL
28603: IFFALSE 28607
// continue ;
28605: GO 28573
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28607: LD_ADDR_VAR 0 11
28611: PUSH
28612: LD_VAR 0 11
28616: PPUSH
28617: LD_VAR 0 11
28621: PUSH
28622: LD_INT 1
28624: PLUS
28625: PPUSH
28626: LD_VAR 0 9
28630: PUSH
28631: LD_VAR 0 3
28635: ARRAY
28636: PPUSH
28637: CALL_OW 2
28641: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28642: LD_ADDR_VAR 0 4
28646: PUSH
28647: LD_VAR 0 4
28651: PUSH
28652: LD_VAR 0 9
28656: PUSH
28657: LD_VAR 0 3
28661: ARRAY
28662: DIFF
28663: ST_TO_ADDR
// end ;
28664: GO 28573
28666: POP
28667: POP
// if p then
28668: LD_VAR 0 11
28672: IFFALSE 28697
// result := Replace ( result , 4 , p ) ;
28674: LD_ADDR_VAR 0 2
28678: PUSH
28679: LD_VAR 0 2
28683: PPUSH
28684: LD_INT 4
28686: PPUSH
28687: LD_VAR 0 11
28691: PPUSH
28692: CALL_OW 1
28696: ST_TO_ADDR
// end ; if tmp and mech < 6 then
28697: LD_VAR 0 4
28701: PUSH
28702: LD_VAR 0 7
28706: PUSH
28707: LD_INT 6
28709: LESS
28710: AND
28711: IFFALSE 28899
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28713: LD_ADDR_VAR 0 9
28717: PUSH
28718: LD_VAR 0 4
28722: PUSH
28723: LD_VAR 0 8
28727: PUSH
28728: LD_VAR 0 7
28732: UNION
28733: DIFF
28734: PPUSH
28735: LD_INT 3
28737: PPUSH
28738: CALL 88700 0 2
28742: ST_TO_ADDR
// p := [ ] ;
28743: LD_ADDR_VAR 0 11
28747: PUSH
28748: EMPTY
28749: ST_TO_ADDR
// if sort then
28750: LD_VAR 0 9
28754: IFFALSE 28870
// for i = 1 to 6 - mech do
28756: LD_ADDR_VAR 0 3
28760: PUSH
28761: DOUBLE
28762: LD_INT 1
28764: DEC
28765: ST_TO_ADDR
28766: LD_INT 6
28768: PUSH
28769: LD_VAR 0 7
28773: MINUS
28774: PUSH
28775: FOR_TO
28776: IFFALSE 28868
// begin if i = sort then
28778: LD_VAR 0 3
28782: PUSH
28783: LD_VAR 0 9
28787: EQUAL
28788: IFFALSE 28792
// break ;
28790: GO 28868
// if GetClass ( i ) = 3 then
28792: LD_VAR 0 3
28796: PPUSH
28797: CALL_OW 257
28801: PUSH
28802: LD_INT 3
28804: EQUAL
28805: IFFALSE 28809
// continue ;
28807: GO 28775
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28809: LD_ADDR_VAR 0 11
28813: PUSH
28814: LD_VAR 0 11
28818: PPUSH
28819: LD_VAR 0 11
28823: PUSH
28824: LD_INT 1
28826: PLUS
28827: PPUSH
28828: LD_VAR 0 9
28832: PUSH
28833: LD_VAR 0 3
28837: ARRAY
28838: PPUSH
28839: CALL_OW 2
28843: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28844: LD_ADDR_VAR 0 4
28848: PUSH
28849: LD_VAR 0 4
28853: PUSH
28854: LD_VAR 0 9
28858: PUSH
28859: LD_VAR 0 3
28863: ARRAY
28864: DIFF
28865: ST_TO_ADDR
// end ;
28866: GO 28775
28868: POP
28869: POP
// if p then
28870: LD_VAR 0 11
28874: IFFALSE 28899
// result := Replace ( result , 3 , p ) ;
28876: LD_ADDR_VAR 0 2
28880: PUSH
28881: LD_VAR 0 2
28885: PPUSH
28886: LD_INT 3
28888: PPUSH
28889: LD_VAR 0 11
28893: PPUSH
28894: CALL_OW 1
28898: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28899: LD_VAR 0 4
28903: PUSH
28904: LD_INT 6
28906: GREATER
28907: PUSH
28908: LD_VAR 0 6
28912: PUSH
28913: LD_INT 6
28915: LESS
28916: AND
28917: IFFALSE 29111
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28919: LD_ADDR_VAR 0 9
28923: PUSH
28924: LD_VAR 0 4
28928: PUSH
28929: LD_VAR 0 8
28933: PUSH
28934: LD_VAR 0 7
28938: UNION
28939: PUSH
28940: LD_VAR 0 6
28944: UNION
28945: DIFF
28946: PPUSH
28947: LD_INT 2
28949: PPUSH
28950: CALL 88700 0 2
28954: ST_TO_ADDR
// p := [ ] ;
28955: LD_ADDR_VAR 0 11
28959: PUSH
28960: EMPTY
28961: ST_TO_ADDR
// if sort then
28962: LD_VAR 0 9
28966: IFFALSE 29082
// for i = 1 to 6 - eng do
28968: LD_ADDR_VAR 0 3
28972: PUSH
28973: DOUBLE
28974: LD_INT 1
28976: DEC
28977: ST_TO_ADDR
28978: LD_INT 6
28980: PUSH
28981: LD_VAR 0 6
28985: MINUS
28986: PUSH
28987: FOR_TO
28988: IFFALSE 29080
// begin if i = sort then
28990: LD_VAR 0 3
28994: PUSH
28995: LD_VAR 0 9
28999: EQUAL
29000: IFFALSE 29004
// break ;
29002: GO 29080
// if GetClass ( i ) = 2 then
29004: LD_VAR 0 3
29008: PPUSH
29009: CALL_OW 257
29013: PUSH
29014: LD_INT 2
29016: EQUAL
29017: IFFALSE 29021
// continue ;
29019: GO 28987
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29021: LD_ADDR_VAR 0 11
29025: PUSH
29026: LD_VAR 0 11
29030: PPUSH
29031: LD_VAR 0 11
29035: PUSH
29036: LD_INT 1
29038: PLUS
29039: PPUSH
29040: LD_VAR 0 9
29044: PUSH
29045: LD_VAR 0 3
29049: ARRAY
29050: PPUSH
29051: CALL_OW 2
29055: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29056: LD_ADDR_VAR 0 4
29060: PUSH
29061: LD_VAR 0 4
29065: PUSH
29066: LD_VAR 0 9
29070: PUSH
29071: LD_VAR 0 3
29075: ARRAY
29076: DIFF
29077: ST_TO_ADDR
// end ;
29078: GO 28987
29080: POP
29081: POP
// if p then
29082: LD_VAR 0 11
29086: IFFALSE 29111
// result := Replace ( result , 2 , p ) ;
29088: LD_ADDR_VAR 0 2
29092: PUSH
29093: LD_VAR 0 2
29097: PPUSH
29098: LD_INT 2
29100: PPUSH
29101: LD_VAR 0 11
29105: PPUSH
29106: CALL_OW 1
29110: ST_TO_ADDR
// end ; exit ;
29111: GO 30499
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
29113: LD_EXP 105
29117: PUSH
29118: LD_EXP 104
29122: PUSH
29123: LD_VAR 0 1
29127: ARRAY
29128: ARRAY
29129: NOT
29130: PUSH
29131: LD_EXP 78
29135: PUSH
29136: LD_VAR 0 1
29140: ARRAY
29141: PPUSH
29142: LD_INT 30
29144: PUSH
29145: LD_INT 3
29147: PUSH
29148: EMPTY
29149: LIST
29150: LIST
29151: PPUSH
29152: CALL_OW 72
29156: AND
29157: PUSH
29158: LD_EXP 83
29162: PUSH
29163: LD_VAR 0 1
29167: ARRAY
29168: AND
29169: IFFALSE 29777
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
29171: LD_ADDR_EXP 120
29175: PUSH
29176: LD_EXP 120
29180: PPUSH
29181: LD_VAR 0 1
29185: PPUSH
29186: LD_INT 5
29188: PPUSH
29189: CALL_OW 1
29193: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29194: LD_ADDR_VAR 0 2
29198: PUSH
29199: LD_INT 0
29201: PUSH
29202: LD_INT 0
29204: PUSH
29205: LD_INT 0
29207: PUSH
29208: LD_INT 0
29210: PUSH
29211: EMPTY
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: ST_TO_ADDR
// if sci > 1 then
29217: LD_VAR 0 8
29221: PUSH
29222: LD_INT 1
29224: GREATER
29225: IFFALSE 29253
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
29227: LD_ADDR_VAR 0 4
29231: PUSH
29232: LD_VAR 0 4
29236: PUSH
29237: LD_VAR 0 8
29241: PUSH
29242: LD_VAR 0 8
29246: PUSH
29247: LD_INT 1
29249: ARRAY
29250: DIFF
29251: DIFF
29252: ST_TO_ADDR
// if tmp and not sci then
29253: LD_VAR 0 4
29257: PUSH
29258: LD_VAR 0 8
29262: NOT
29263: AND
29264: IFFALSE 29333
// begin sort := SortBySkill ( tmp , 4 ) ;
29266: LD_ADDR_VAR 0 9
29270: PUSH
29271: LD_VAR 0 4
29275: PPUSH
29276: LD_INT 4
29278: PPUSH
29279: CALL 88700 0 2
29283: ST_TO_ADDR
// if sort then
29284: LD_VAR 0 9
29288: IFFALSE 29304
// p := sort [ 1 ] ;
29290: LD_ADDR_VAR 0 11
29294: PUSH
29295: LD_VAR 0 9
29299: PUSH
29300: LD_INT 1
29302: ARRAY
29303: ST_TO_ADDR
// if p then
29304: LD_VAR 0 11
29308: IFFALSE 29333
// result := Replace ( result , 4 , p ) ;
29310: LD_ADDR_VAR 0 2
29314: PUSH
29315: LD_VAR 0 2
29319: PPUSH
29320: LD_INT 4
29322: PPUSH
29323: LD_VAR 0 11
29327: PPUSH
29328: CALL_OW 1
29332: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29333: LD_ADDR_VAR 0 4
29337: PUSH
29338: LD_VAR 0 4
29342: PUSH
29343: LD_VAR 0 7
29347: DIFF
29348: ST_TO_ADDR
// if tmp and mech < 6 then
29349: LD_VAR 0 4
29353: PUSH
29354: LD_VAR 0 7
29358: PUSH
29359: LD_INT 6
29361: LESS
29362: AND
29363: IFFALSE 29551
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29365: LD_ADDR_VAR 0 9
29369: PUSH
29370: LD_VAR 0 4
29374: PUSH
29375: LD_VAR 0 8
29379: PUSH
29380: LD_VAR 0 7
29384: UNION
29385: DIFF
29386: PPUSH
29387: LD_INT 3
29389: PPUSH
29390: CALL 88700 0 2
29394: ST_TO_ADDR
// p := [ ] ;
29395: LD_ADDR_VAR 0 11
29399: PUSH
29400: EMPTY
29401: ST_TO_ADDR
// if sort then
29402: LD_VAR 0 9
29406: IFFALSE 29522
// for i = 1 to 6 - mech do
29408: LD_ADDR_VAR 0 3
29412: PUSH
29413: DOUBLE
29414: LD_INT 1
29416: DEC
29417: ST_TO_ADDR
29418: LD_INT 6
29420: PUSH
29421: LD_VAR 0 7
29425: MINUS
29426: PUSH
29427: FOR_TO
29428: IFFALSE 29520
// begin if i = sort then
29430: LD_VAR 0 3
29434: PUSH
29435: LD_VAR 0 9
29439: EQUAL
29440: IFFALSE 29444
// break ;
29442: GO 29520
// if GetClass ( i ) = 3 then
29444: LD_VAR 0 3
29448: PPUSH
29449: CALL_OW 257
29453: PUSH
29454: LD_INT 3
29456: EQUAL
29457: IFFALSE 29461
// continue ;
29459: GO 29427
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29461: LD_ADDR_VAR 0 11
29465: PUSH
29466: LD_VAR 0 11
29470: PPUSH
29471: LD_VAR 0 11
29475: PUSH
29476: LD_INT 1
29478: PLUS
29479: PPUSH
29480: LD_VAR 0 9
29484: PUSH
29485: LD_VAR 0 3
29489: ARRAY
29490: PPUSH
29491: CALL_OW 2
29495: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29496: LD_ADDR_VAR 0 4
29500: PUSH
29501: LD_VAR 0 4
29505: PUSH
29506: LD_VAR 0 9
29510: PUSH
29511: LD_VAR 0 3
29515: ARRAY
29516: DIFF
29517: ST_TO_ADDR
// end ;
29518: GO 29427
29520: POP
29521: POP
// if p then
29522: LD_VAR 0 11
29526: IFFALSE 29551
// result := Replace ( result , 3 , p ) ;
29528: LD_ADDR_VAR 0 2
29532: PUSH
29533: LD_VAR 0 2
29537: PPUSH
29538: LD_INT 3
29540: PPUSH
29541: LD_VAR 0 11
29545: PPUSH
29546: CALL_OW 1
29550: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29551: LD_ADDR_VAR 0 4
29555: PUSH
29556: LD_VAR 0 4
29560: PUSH
29561: LD_VAR 0 6
29565: DIFF
29566: ST_TO_ADDR
// if tmp and eng < 6 then
29567: LD_VAR 0 4
29571: PUSH
29572: LD_VAR 0 6
29576: PUSH
29577: LD_INT 6
29579: LESS
29580: AND
29581: IFFALSE 29775
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29583: LD_ADDR_VAR 0 9
29587: PUSH
29588: LD_VAR 0 4
29592: PUSH
29593: LD_VAR 0 8
29597: PUSH
29598: LD_VAR 0 7
29602: UNION
29603: PUSH
29604: LD_VAR 0 6
29608: UNION
29609: DIFF
29610: PPUSH
29611: LD_INT 2
29613: PPUSH
29614: CALL 88700 0 2
29618: ST_TO_ADDR
// p := [ ] ;
29619: LD_ADDR_VAR 0 11
29623: PUSH
29624: EMPTY
29625: ST_TO_ADDR
// if sort then
29626: LD_VAR 0 9
29630: IFFALSE 29746
// for i = 1 to 6 - eng do
29632: LD_ADDR_VAR 0 3
29636: PUSH
29637: DOUBLE
29638: LD_INT 1
29640: DEC
29641: ST_TO_ADDR
29642: LD_INT 6
29644: PUSH
29645: LD_VAR 0 6
29649: MINUS
29650: PUSH
29651: FOR_TO
29652: IFFALSE 29744
// begin if i = sort then
29654: LD_VAR 0 3
29658: PUSH
29659: LD_VAR 0 9
29663: EQUAL
29664: IFFALSE 29668
// break ;
29666: GO 29744
// if GetClass ( i ) = 2 then
29668: LD_VAR 0 3
29672: PPUSH
29673: CALL_OW 257
29677: PUSH
29678: LD_INT 2
29680: EQUAL
29681: IFFALSE 29685
// continue ;
29683: GO 29651
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29685: LD_ADDR_VAR 0 11
29689: PUSH
29690: LD_VAR 0 11
29694: PPUSH
29695: LD_VAR 0 11
29699: PUSH
29700: LD_INT 1
29702: PLUS
29703: PPUSH
29704: LD_VAR 0 9
29708: PUSH
29709: LD_VAR 0 3
29713: ARRAY
29714: PPUSH
29715: CALL_OW 2
29719: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29720: LD_ADDR_VAR 0 4
29724: PUSH
29725: LD_VAR 0 4
29729: PUSH
29730: LD_VAR 0 9
29734: PUSH
29735: LD_VAR 0 3
29739: ARRAY
29740: DIFF
29741: ST_TO_ADDR
// end ;
29742: GO 29651
29744: POP
29745: POP
// if p then
29746: LD_VAR 0 11
29750: IFFALSE 29775
// result := Replace ( result , 2 , p ) ;
29752: LD_ADDR_VAR 0 2
29756: PUSH
29757: LD_VAR 0 2
29761: PPUSH
29762: LD_INT 2
29764: PPUSH
29765: LD_VAR 0 11
29769: PPUSH
29770: CALL_OW 1
29774: ST_TO_ADDR
// end ; exit ;
29775: GO 30499
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
29777: LD_EXP 105
29781: PUSH
29782: LD_EXP 104
29786: PUSH
29787: LD_VAR 0 1
29791: ARRAY
29792: ARRAY
29793: NOT
29794: PUSH
29795: LD_EXP 78
29799: PUSH
29800: LD_VAR 0 1
29804: ARRAY
29805: PPUSH
29806: LD_INT 30
29808: PUSH
29809: LD_INT 3
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PPUSH
29816: CALL_OW 72
29820: AND
29821: PUSH
29822: LD_EXP 83
29826: PUSH
29827: LD_VAR 0 1
29831: ARRAY
29832: NOT
29833: AND
29834: IFFALSE 30499
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29836: LD_ADDR_EXP 120
29840: PUSH
29841: LD_EXP 120
29845: PPUSH
29846: LD_VAR 0 1
29850: PPUSH
29851: LD_INT 6
29853: PPUSH
29854: CALL_OW 1
29858: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29859: LD_ADDR_VAR 0 2
29863: PUSH
29864: LD_INT 0
29866: PUSH
29867: LD_INT 0
29869: PUSH
29870: LD_INT 0
29872: PUSH
29873: LD_INT 0
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: ST_TO_ADDR
// if sci >= 1 then
29882: LD_VAR 0 8
29886: PUSH
29887: LD_INT 1
29889: GREATEREQUAL
29890: IFFALSE 29912
// tmp := tmp diff sci [ 1 ] ;
29892: LD_ADDR_VAR 0 4
29896: PUSH
29897: LD_VAR 0 4
29901: PUSH
29902: LD_VAR 0 8
29906: PUSH
29907: LD_INT 1
29909: ARRAY
29910: DIFF
29911: ST_TO_ADDR
// if tmp and not sci then
29912: LD_VAR 0 4
29916: PUSH
29917: LD_VAR 0 8
29921: NOT
29922: AND
29923: IFFALSE 29992
// begin sort := SortBySkill ( tmp , 4 ) ;
29925: LD_ADDR_VAR 0 9
29929: PUSH
29930: LD_VAR 0 4
29934: PPUSH
29935: LD_INT 4
29937: PPUSH
29938: CALL 88700 0 2
29942: ST_TO_ADDR
// if sort then
29943: LD_VAR 0 9
29947: IFFALSE 29963
// p := sort [ 1 ] ;
29949: LD_ADDR_VAR 0 11
29953: PUSH
29954: LD_VAR 0 9
29958: PUSH
29959: LD_INT 1
29961: ARRAY
29962: ST_TO_ADDR
// if p then
29963: LD_VAR 0 11
29967: IFFALSE 29992
// result := Replace ( result , 4 , p ) ;
29969: LD_ADDR_VAR 0 2
29973: PUSH
29974: LD_VAR 0 2
29978: PPUSH
29979: LD_INT 4
29981: PPUSH
29982: LD_VAR 0 11
29986: PPUSH
29987: CALL_OW 1
29991: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29992: LD_ADDR_VAR 0 4
29996: PUSH
29997: LD_VAR 0 4
30001: PUSH
30002: LD_VAR 0 7
30006: DIFF
30007: ST_TO_ADDR
// if tmp and mech < 6 then
30008: LD_VAR 0 4
30012: PUSH
30013: LD_VAR 0 7
30017: PUSH
30018: LD_INT 6
30020: LESS
30021: AND
30022: IFFALSE 30204
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
30024: LD_ADDR_VAR 0 9
30028: PUSH
30029: LD_VAR 0 4
30033: PUSH
30034: LD_VAR 0 7
30038: DIFF
30039: PPUSH
30040: LD_INT 3
30042: PPUSH
30043: CALL 88700 0 2
30047: ST_TO_ADDR
// p := [ ] ;
30048: LD_ADDR_VAR 0 11
30052: PUSH
30053: EMPTY
30054: ST_TO_ADDR
// if sort then
30055: LD_VAR 0 9
30059: IFFALSE 30175
// for i = 1 to 6 - mech do
30061: LD_ADDR_VAR 0 3
30065: PUSH
30066: DOUBLE
30067: LD_INT 1
30069: DEC
30070: ST_TO_ADDR
30071: LD_INT 6
30073: PUSH
30074: LD_VAR 0 7
30078: MINUS
30079: PUSH
30080: FOR_TO
30081: IFFALSE 30173
// begin if i = sort then
30083: LD_VAR 0 3
30087: PUSH
30088: LD_VAR 0 9
30092: EQUAL
30093: IFFALSE 30097
// break ;
30095: GO 30173
// if GetClass ( i ) = 3 then
30097: LD_VAR 0 3
30101: PPUSH
30102: CALL_OW 257
30106: PUSH
30107: LD_INT 3
30109: EQUAL
30110: IFFALSE 30114
// continue ;
30112: GO 30080
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30114: LD_ADDR_VAR 0 11
30118: PUSH
30119: LD_VAR 0 11
30123: PPUSH
30124: LD_VAR 0 11
30128: PUSH
30129: LD_INT 1
30131: PLUS
30132: PPUSH
30133: LD_VAR 0 9
30137: PUSH
30138: LD_VAR 0 3
30142: ARRAY
30143: PPUSH
30144: CALL_OW 2
30148: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30149: LD_ADDR_VAR 0 4
30153: PUSH
30154: LD_VAR 0 4
30158: PUSH
30159: LD_VAR 0 9
30163: PUSH
30164: LD_VAR 0 3
30168: ARRAY
30169: DIFF
30170: ST_TO_ADDR
// end ;
30171: GO 30080
30173: POP
30174: POP
// if p then
30175: LD_VAR 0 11
30179: IFFALSE 30204
// result := Replace ( result , 3 , p ) ;
30181: LD_ADDR_VAR 0 2
30185: PUSH
30186: LD_VAR 0 2
30190: PPUSH
30191: LD_INT 3
30193: PPUSH
30194: LD_VAR 0 11
30198: PPUSH
30199: CALL_OW 1
30203: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30204: LD_ADDR_VAR 0 4
30208: PUSH
30209: LD_VAR 0 4
30213: PUSH
30214: LD_VAR 0 6
30218: DIFF
30219: ST_TO_ADDR
// if tmp and eng < 4 then
30220: LD_VAR 0 4
30224: PUSH
30225: LD_VAR 0 6
30229: PUSH
30230: LD_INT 4
30232: LESS
30233: AND
30234: IFFALSE 30424
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
30236: LD_ADDR_VAR 0 9
30240: PUSH
30241: LD_VAR 0 4
30245: PUSH
30246: LD_VAR 0 7
30250: PUSH
30251: LD_VAR 0 6
30255: UNION
30256: DIFF
30257: PPUSH
30258: LD_INT 2
30260: PPUSH
30261: CALL 88700 0 2
30265: ST_TO_ADDR
// p := [ ] ;
30266: LD_ADDR_VAR 0 11
30270: PUSH
30271: EMPTY
30272: ST_TO_ADDR
// if sort then
30273: LD_VAR 0 9
30277: IFFALSE 30393
// for i = 1 to 4 - eng do
30279: LD_ADDR_VAR 0 3
30283: PUSH
30284: DOUBLE
30285: LD_INT 1
30287: DEC
30288: ST_TO_ADDR
30289: LD_INT 4
30291: PUSH
30292: LD_VAR 0 6
30296: MINUS
30297: PUSH
30298: FOR_TO
30299: IFFALSE 30391
// begin if i = sort then
30301: LD_VAR 0 3
30305: PUSH
30306: LD_VAR 0 9
30310: EQUAL
30311: IFFALSE 30315
// break ;
30313: GO 30391
// if GetClass ( i ) = 2 then
30315: LD_VAR 0 3
30319: PPUSH
30320: CALL_OW 257
30324: PUSH
30325: LD_INT 2
30327: EQUAL
30328: IFFALSE 30332
// continue ;
30330: GO 30298
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30332: LD_ADDR_VAR 0 11
30336: PUSH
30337: LD_VAR 0 11
30341: PPUSH
30342: LD_VAR 0 11
30346: PUSH
30347: LD_INT 1
30349: PLUS
30350: PPUSH
30351: LD_VAR 0 9
30355: PUSH
30356: LD_VAR 0 3
30360: ARRAY
30361: PPUSH
30362: CALL_OW 2
30366: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30367: LD_ADDR_VAR 0 4
30371: PUSH
30372: LD_VAR 0 4
30376: PUSH
30377: LD_VAR 0 9
30381: PUSH
30382: LD_VAR 0 3
30386: ARRAY
30387: DIFF
30388: ST_TO_ADDR
// end ;
30389: GO 30298
30391: POP
30392: POP
// if p then
30393: LD_VAR 0 11
30397: IFFALSE 30422
// result := Replace ( result , 2 , p ) ;
30399: LD_ADDR_VAR 0 2
30403: PUSH
30404: LD_VAR 0 2
30408: PPUSH
30409: LD_INT 2
30411: PPUSH
30412: LD_VAR 0 11
30416: PPUSH
30417: CALL_OW 1
30421: ST_TO_ADDR
// end else
30422: GO 30468
// for i = eng downto 5 do
30424: LD_ADDR_VAR 0 3
30428: PUSH
30429: DOUBLE
30430: LD_VAR 0 6
30434: INC
30435: ST_TO_ADDR
30436: LD_INT 5
30438: PUSH
30439: FOR_DOWNTO
30440: IFFALSE 30466
// tmp := tmp union eng [ i ] ;
30442: LD_ADDR_VAR 0 4
30446: PUSH
30447: LD_VAR 0 4
30451: PUSH
30452: LD_VAR 0 6
30456: PUSH
30457: LD_VAR 0 3
30461: ARRAY
30462: UNION
30463: ST_TO_ADDR
30464: GO 30439
30466: POP
30467: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
30468: LD_ADDR_VAR 0 2
30472: PUSH
30473: LD_VAR 0 2
30477: PPUSH
30478: LD_INT 1
30480: PPUSH
30481: LD_VAR 0 4
30485: PUSH
30486: LD_VAR 0 5
30490: DIFF
30491: PPUSH
30492: CALL_OW 1
30496: ST_TO_ADDR
// exit ;
30497: GO 30499
// end ; end ;
30499: LD_VAR 0 2
30503: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
30504: LD_INT 0
30506: PPUSH
30507: PPUSH
30508: PPUSH
// if not mc_bases then
30509: LD_EXP 78
30513: NOT
30514: IFFALSE 30518
// exit ;
30516: GO 30660
// for i = 1 to mc_bases do
30518: LD_ADDR_VAR 0 2
30522: PUSH
30523: DOUBLE
30524: LD_INT 1
30526: DEC
30527: ST_TO_ADDR
30528: LD_EXP 78
30532: PUSH
30533: FOR_TO
30534: IFFALSE 30651
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
30536: LD_ADDR_VAR 0 3
30540: PUSH
30541: LD_EXP 78
30545: PUSH
30546: LD_VAR 0 2
30550: ARRAY
30551: PPUSH
30552: LD_INT 21
30554: PUSH
30555: LD_INT 3
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 3
30564: PUSH
30565: LD_INT 2
30567: PUSH
30568: LD_INT 30
30570: PUSH
30571: LD_INT 29
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 30
30580: PUSH
30581: LD_INT 30
30583: PUSH
30584: EMPTY
30585: LIST
30586: LIST
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: LIST
30592: PUSH
30593: EMPTY
30594: LIST
30595: LIST
30596: PUSH
30597: LD_INT 3
30599: PUSH
30600: LD_INT 24
30602: PUSH
30603: LD_INT 1000
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: LIST
30618: PPUSH
30619: CALL_OW 72
30623: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
30624: LD_ADDR_EXP 79
30628: PUSH
30629: LD_EXP 79
30633: PPUSH
30634: LD_VAR 0 2
30638: PPUSH
30639: LD_VAR 0 3
30643: PPUSH
30644: CALL_OW 1
30648: ST_TO_ADDR
// end ;
30649: GO 30533
30651: POP
30652: POP
// RaiseSailEvent ( 101 ) ;
30653: LD_INT 101
30655: PPUSH
30656: CALL_OW 427
// end ;
30660: LD_VAR 0 1
30664: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
30665: LD_INT 0
30667: PPUSH
30668: PPUSH
30669: PPUSH
30670: PPUSH
30671: PPUSH
30672: PPUSH
30673: PPUSH
// if not mc_bases then
30674: LD_EXP 78
30678: NOT
30679: IFFALSE 30683
// exit ;
30681: GO 31245
// for i = 1 to mc_bases do
30683: LD_ADDR_VAR 0 2
30687: PUSH
30688: DOUBLE
30689: LD_INT 1
30691: DEC
30692: ST_TO_ADDR
30693: LD_EXP 78
30697: PUSH
30698: FOR_TO
30699: IFFALSE 31236
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
30701: LD_ADDR_VAR 0 5
30705: PUSH
30706: LD_EXP 78
30710: PUSH
30711: LD_VAR 0 2
30715: ARRAY
30716: PUSH
30717: LD_EXP 107
30721: PUSH
30722: LD_VAR 0 2
30726: ARRAY
30727: UNION
30728: PPUSH
30729: LD_INT 21
30731: PUSH
30732: LD_INT 1
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 1
30741: PUSH
30742: LD_INT 3
30744: PUSH
30745: LD_INT 54
30747: PUSH
30748: EMPTY
30749: LIST
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 3
30757: PUSH
30758: LD_INT 24
30760: PUSH
30761: LD_INT 1000
30763: PUSH
30764: EMPTY
30765: LIST
30766: LIST
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: LIST
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PPUSH
30781: CALL_OW 72
30785: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
30786: LD_ADDR_VAR 0 6
30790: PUSH
30791: LD_EXP 78
30795: PUSH
30796: LD_VAR 0 2
30800: ARRAY
30801: PPUSH
30802: LD_INT 21
30804: PUSH
30805: LD_INT 1
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 1
30814: PUSH
30815: LD_INT 3
30817: PUSH
30818: LD_INT 54
30820: PUSH
30821: EMPTY
30822: LIST
30823: PUSH
30824: EMPTY
30825: LIST
30826: LIST
30827: PUSH
30828: LD_INT 3
30830: PUSH
30831: LD_INT 24
30833: PUSH
30834: LD_INT 250
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: LIST
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PPUSH
30854: CALL_OW 72
30858: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30859: LD_ADDR_VAR 0 7
30863: PUSH
30864: LD_VAR 0 5
30868: PUSH
30869: LD_VAR 0 6
30873: DIFF
30874: ST_TO_ADDR
// if not need_heal_1 then
30875: LD_VAR 0 6
30879: NOT
30880: IFFALSE 30913
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30882: LD_ADDR_EXP 81
30886: PUSH
30887: LD_EXP 81
30891: PPUSH
30892: LD_VAR 0 2
30896: PUSH
30897: LD_INT 1
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PPUSH
30904: EMPTY
30905: PPUSH
30906: CALL 57824 0 3
30910: ST_TO_ADDR
30911: GO 30983
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30913: LD_ADDR_EXP 81
30917: PUSH
30918: LD_EXP 81
30922: PPUSH
30923: LD_VAR 0 2
30927: PUSH
30928: LD_INT 1
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: PPUSH
30935: LD_EXP 81
30939: PUSH
30940: LD_VAR 0 2
30944: ARRAY
30945: PUSH
30946: LD_INT 1
30948: ARRAY
30949: PPUSH
30950: LD_INT 3
30952: PUSH
30953: LD_INT 24
30955: PUSH
30956: LD_INT 1000
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PPUSH
30967: CALL_OW 72
30971: PUSH
30972: LD_VAR 0 6
30976: UNION
30977: PPUSH
30978: CALL 57824 0 3
30982: ST_TO_ADDR
// if not need_heal_2 then
30983: LD_VAR 0 7
30987: NOT
30988: IFFALSE 31021
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30990: LD_ADDR_EXP 81
30994: PUSH
30995: LD_EXP 81
30999: PPUSH
31000: LD_VAR 0 2
31004: PUSH
31005: LD_INT 2
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PPUSH
31012: EMPTY
31013: PPUSH
31014: CALL 57824 0 3
31018: ST_TO_ADDR
31019: GO 31053
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
31021: LD_ADDR_EXP 81
31025: PUSH
31026: LD_EXP 81
31030: PPUSH
31031: LD_VAR 0 2
31035: PUSH
31036: LD_INT 2
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PPUSH
31043: LD_VAR 0 7
31047: PPUSH
31048: CALL 57824 0 3
31052: ST_TO_ADDR
// if need_heal_2 then
31053: LD_VAR 0 7
31057: IFFALSE 31218
// for j in need_heal_2 do
31059: LD_ADDR_VAR 0 3
31063: PUSH
31064: LD_VAR 0 7
31068: PUSH
31069: FOR_IN
31070: IFFALSE 31216
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31072: LD_ADDR_VAR 0 5
31076: PUSH
31077: LD_EXP 78
31081: PUSH
31082: LD_VAR 0 2
31086: ARRAY
31087: PPUSH
31088: LD_INT 2
31090: PUSH
31091: LD_INT 30
31093: PUSH
31094: LD_INT 6
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PUSH
31101: LD_INT 30
31103: PUSH
31104: LD_INT 7
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 30
31113: PUSH
31114: LD_INT 8
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 30
31123: PUSH
31124: LD_INT 0
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PUSH
31131: LD_INT 30
31133: PUSH
31134: LD_INT 1
31136: PUSH
31137: EMPTY
31138: LIST
31139: LIST
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: PPUSH
31149: CALL_OW 72
31153: ST_TO_ADDR
// if tmp then
31154: LD_VAR 0 5
31158: IFFALSE 31214
// begin k := NearestUnitToUnit ( tmp , j ) ;
31160: LD_ADDR_VAR 0 4
31164: PUSH
31165: LD_VAR 0 5
31169: PPUSH
31170: LD_VAR 0 3
31174: PPUSH
31175: CALL_OW 74
31179: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
31180: LD_VAR 0 3
31184: PPUSH
31185: LD_VAR 0 4
31189: PPUSH
31190: CALL_OW 296
31194: PUSH
31195: LD_INT 5
31197: GREATER
31198: IFFALSE 31214
// ComMoveToNearbyEntrance ( j , k ) ;
31200: LD_VAR 0 3
31204: PPUSH
31205: LD_VAR 0 4
31209: PPUSH
31210: CALL 91060 0 2
// end ; end ;
31214: GO 31069
31216: POP
31217: POP
// if not need_heal_1 and not need_heal_2 then
31218: LD_VAR 0 6
31222: NOT
31223: PUSH
31224: LD_VAR 0 7
31228: NOT
31229: AND
31230: IFFALSE 31234
// continue ;
31232: GO 30698
// end ;
31234: GO 30698
31236: POP
31237: POP
// RaiseSailEvent ( 102 ) ;
31238: LD_INT 102
31240: PPUSH
31241: CALL_OW 427
// end ;
31245: LD_VAR 0 1
31249: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
31250: LD_INT 0
31252: PPUSH
31253: PPUSH
31254: PPUSH
31255: PPUSH
31256: PPUSH
31257: PPUSH
31258: PPUSH
31259: PPUSH
// if not mc_bases then
31260: LD_EXP 78
31264: NOT
31265: IFFALSE 31269
// exit ;
31267: GO 32180
// for i = 1 to mc_bases do
31269: LD_ADDR_VAR 0 2
31273: PUSH
31274: DOUBLE
31275: LD_INT 1
31277: DEC
31278: ST_TO_ADDR
31279: LD_EXP 78
31283: PUSH
31284: FOR_TO
31285: IFFALSE 32178
// begin if not mc_building_need_repair [ i ] then
31287: LD_EXP 79
31291: PUSH
31292: LD_VAR 0 2
31296: ARRAY
31297: NOT
31298: IFFALSE 31483
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
31300: LD_ADDR_VAR 0 6
31304: PUSH
31305: LD_EXP 97
31309: PUSH
31310: LD_VAR 0 2
31314: ARRAY
31315: PPUSH
31316: LD_INT 3
31318: PUSH
31319: LD_INT 24
31321: PUSH
31322: LD_INT 1000
31324: PUSH
31325: EMPTY
31326: LIST
31327: LIST
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 2
31335: PUSH
31336: LD_INT 34
31338: PUSH
31339: LD_INT 13
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 34
31348: PUSH
31349: LD_INT 52
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PUSH
31356: LD_INT 34
31358: PUSH
31359: LD_INT 88
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PPUSH
31376: CALL_OW 72
31380: ST_TO_ADDR
// if cranes then
31381: LD_VAR 0 6
31385: IFFALSE 31447
// for j in cranes do
31387: LD_ADDR_VAR 0 3
31391: PUSH
31392: LD_VAR 0 6
31396: PUSH
31397: FOR_IN
31398: IFFALSE 31445
// if not IsInArea ( j , mc_parking [ i ] ) then
31400: LD_VAR 0 3
31404: PPUSH
31405: LD_EXP 102
31409: PUSH
31410: LD_VAR 0 2
31414: ARRAY
31415: PPUSH
31416: CALL_OW 308
31420: NOT
31421: IFFALSE 31443
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31423: LD_VAR 0 3
31427: PPUSH
31428: LD_EXP 102
31432: PUSH
31433: LD_VAR 0 2
31437: ARRAY
31438: PPUSH
31439: CALL_OW 113
31443: GO 31397
31445: POP
31446: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
31447: LD_ADDR_EXP 80
31451: PUSH
31452: LD_EXP 80
31456: PPUSH
31457: LD_VAR 0 2
31461: PPUSH
31462: EMPTY
31463: PPUSH
31464: CALL_OW 1
31468: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
31469: LD_VAR 0 2
31473: PPUSH
31474: LD_INT 101
31476: PPUSH
31477: CALL 26323 0 2
// continue ;
31481: GO 31284
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
31483: LD_ADDR_EXP 84
31487: PUSH
31488: LD_EXP 84
31492: PPUSH
31493: LD_VAR 0 2
31497: PPUSH
31498: EMPTY
31499: PPUSH
31500: CALL_OW 1
31504: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31505: LD_VAR 0 2
31509: PPUSH
31510: LD_INT 103
31512: PPUSH
31513: CALL 26323 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
31517: LD_ADDR_VAR 0 5
31521: PUSH
31522: LD_EXP 78
31526: PUSH
31527: LD_VAR 0 2
31531: ARRAY
31532: PUSH
31533: LD_EXP 107
31537: PUSH
31538: LD_VAR 0 2
31542: ARRAY
31543: UNION
31544: PPUSH
31545: LD_INT 2
31547: PUSH
31548: LD_INT 25
31550: PUSH
31551: LD_INT 2
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 25
31560: PUSH
31561: LD_INT 16
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: LIST
31572: PUSH
31573: EMPTY
31574: LIST
31575: PPUSH
31576: CALL_OW 72
31580: ST_TO_ADDR
// if mc_need_heal [ i ] then
31581: LD_EXP 81
31585: PUSH
31586: LD_VAR 0 2
31590: ARRAY
31591: IFFALSE 31635
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
31593: LD_ADDR_VAR 0 5
31597: PUSH
31598: LD_VAR 0 5
31602: PUSH
31603: LD_EXP 81
31607: PUSH
31608: LD_VAR 0 2
31612: ARRAY
31613: PUSH
31614: LD_INT 1
31616: ARRAY
31617: PUSH
31618: LD_EXP 81
31622: PUSH
31623: LD_VAR 0 2
31627: ARRAY
31628: PUSH
31629: LD_INT 2
31631: ARRAY
31632: UNION
31633: DIFF
31634: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
31635: LD_ADDR_VAR 0 6
31639: PUSH
31640: LD_EXP 97
31644: PUSH
31645: LD_VAR 0 2
31649: ARRAY
31650: PPUSH
31651: LD_INT 2
31653: PUSH
31654: LD_INT 34
31656: PUSH
31657: LD_INT 13
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PUSH
31664: LD_INT 34
31666: PUSH
31667: LD_INT 52
31669: PUSH
31670: EMPTY
31671: LIST
31672: LIST
31673: PUSH
31674: LD_INT 34
31676: PUSH
31677: LD_INT 88
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: PPUSH
31690: CALL_OW 72
31694: ST_TO_ADDR
// if cranes then
31695: LD_VAR 0 6
31699: IFFALSE 31867
// begin for j in cranes do
31701: LD_ADDR_VAR 0 3
31705: PUSH
31706: LD_VAR 0 6
31710: PUSH
31711: FOR_IN
31712: IFFALSE 31865
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
31714: LD_VAR 0 3
31718: PPUSH
31719: CALL_OW 256
31723: PUSH
31724: LD_INT 1000
31726: EQUAL
31727: PUSH
31728: LD_VAR 0 3
31732: PPUSH
31733: CALL_OW 314
31737: NOT
31738: AND
31739: IFFALSE 31805
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
31741: LD_ADDR_VAR 0 8
31745: PUSH
31746: LD_EXP 79
31750: PUSH
31751: LD_VAR 0 2
31755: ARRAY
31756: PPUSH
31757: LD_VAR 0 3
31761: PPUSH
31762: CALL_OW 74
31766: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31767: LD_VAR 0 8
31771: PPUSH
31772: LD_INT 16
31774: PPUSH
31775: CALL 60421 0 2
31779: PUSH
31780: LD_INT 4
31782: ARRAY
31783: PUSH
31784: LD_INT 10
31786: LESS
31787: IFFALSE 31803
// ComRepairBuilding ( j , to_repair ) ;
31789: LD_VAR 0 3
31793: PPUSH
31794: LD_VAR 0 8
31798: PPUSH
31799: CALL_OW 130
// end else
31803: GO 31863
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
31805: LD_VAR 0 3
31809: PPUSH
31810: CALL_OW 256
31814: PUSH
31815: LD_INT 500
31817: LESS
31818: PUSH
31819: LD_VAR 0 3
31823: PPUSH
31824: LD_EXP 102
31828: PUSH
31829: LD_VAR 0 2
31833: ARRAY
31834: PPUSH
31835: CALL_OW 308
31839: NOT
31840: AND
31841: IFFALSE 31863
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31843: LD_VAR 0 3
31847: PPUSH
31848: LD_EXP 102
31852: PUSH
31853: LD_VAR 0 2
31857: ARRAY
31858: PPUSH
31859: CALL_OW 113
// end ;
31863: GO 31711
31865: POP
31866: POP
// end ; if tmp > 3 then
31867: LD_VAR 0 5
31871: PUSH
31872: LD_INT 3
31874: GREATER
31875: IFFALSE 31895
// tmp := ShrinkArray ( tmp , 4 ) ;
31877: LD_ADDR_VAR 0 5
31881: PUSH
31882: LD_VAR 0 5
31886: PPUSH
31887: LD_INT 4
31889: PPUSH
31890: CALL 90498 0 2
31894: ST_TO_ADDR
// if not tmp then
31895: LD_VAR 0 5
31899: NOT
31900: IFFALSE 31904
// continue ;
31902: GO 31284
// for j in tmp do
31904: LD_ADDR_VAR 0 3
31908: PUSH
31909: LD_VAR 0 5
31913: PUSH
31914: FOR_IN
31915: IFFALSE 32174
// begin if IsInUnit ( j ) then
31917: LD_VAR 0 3
31921: PPUSH
31922: CALL_OW 310
31926: IFFALSE 31937
// ComExitBuilding ( j ) ;
31928: LD_VAR 0 3
31932: PPUSH
31933: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31937: LD_VAR 0 3
31941: PUSH
31942: LD_EXP 80
31946: PUSH
31947: LD_VAR 0 2
31951: ARRAY
31952: IN
31953: NOT
31954: IFFALSE 32012
// begin SetTag ( j , 101 ) ;
31956: LD_VAR 0 3
31960: PPUSH
31961: LD_INT 101
31963: PPUSH
31964: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31968: LD_ADDR_EXP 80
31972: PUSH
31973: LD_EXP 80
31977: PPUSH
31978: LD_VAR 0 2
31982: PUSH
31983: LD_EXP 80
31987: PUSH
31988: LD_VAR 0 2
31992: ARRAY
31993: PUSH
31994: LD_INT 1
31996: PLUS
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PPUSH
32002: LD_VAR 0 3
32006: PPUSH
32007: CALL 57824 0 3
32011: ST_TO_ADDR
// end ; wait ( 1 ) ;
32012: LD_INT 1
32014: PPUSH
32015: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
32019: LD_ADDR_VAR 0 7
32023: PUSH
32024: LD_EXP 79
32028: PUSH
32029: LD_VAR 0 2
32033: ARRAY
32034: ST_TO_ADDR
// if mc_scan [ i ] then
32035: LD_EXP 101
32039: PUSH
32040: LD_VAR 0 2
32044: ARRAY
32045: IFFALSE 32107
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
32047: LD_ADDR_VAR 0 7
32051: PUSH
32052: LD_EXP 79
32056: PUSH
32057: LD_VAR 0 2
32061: ARRAY
32062: PPUSH
32063: LD_INT 3
32065: PUSH
32066: LD_INT 30
32068: PUSH
32069: LD_INT 32
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 30
32078: PUSH
32079: LD_INT 33
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 30
32088: PUSH
32089: LD_INT 31
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: EMPTY
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: PPUSH
32102: CALL_OW 72
32106: ST_TO_ADDR
// if not to_repair_tmp then
32107: LD_VAR 0 7
32111: NOT
32112: IFFALSE 32116
// continue ;
32114: GO 31914
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
32116: LD_ADDR_VAR 0 8
32120: PUSH
32121: LD_VAR 0 7
32125: PPUSH
32126: LD_VAR 0 3
32130: PPUSH
32131: CALL_OW 74
32135: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
32136: LD_VAR 0 8
32140: PPUSH
32141: LD_INT 16
32143: PPUSH
32144: CALL 60421 0 2
32148: PUSH
32149: LD_INT 4
32151: ARRAY
32152: PUSH
32153: LD_INT 14
32155: LESS
32156: IFFALSE 32172
// ComRepairBuilding ( j , to_repair ) ;
32158: LD_VAR 0 3
32162: PPUSH
32163: LD_VAR 0 8
32167: PPUSH
32168: CALL_OW 130
// end ;
32172: GO 31914
32174: POP
32175: POP
// end ;
32176: GO 31284
32178: POP
32179: POP
// end ;
32180: LD_VAR 0 1
32184: RET
// export function MC_Heal ; var i , j , tmp ; begin
32185: LD_INT 0
32187: PPUSH
32188: PPUSH
32189: PPUSH
32190: PPUSH
// if not mc_bases then
32191: LD_EXP 78
32195: NOT
32196: IFFALSE 32200
// exit ;
32198: GO 32602
// for i = 1 to mc_bases do
32200: LD_ADDR_VAR 0 2
32204: PUSH
32205: DOUBLE
32206: LD_INT 1
32208: DEC
32209: ST_TO_ADDR
32210: LD_EXP 78
32214: PUSH
32215: FOR_TO
32216: IFFALSE 32600
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
32218: LD_EXP 81
32222: PUSH
32223: LD_VAR 0 2
32227: ARRAY
32228: PUSH
32229: LD_INT 1
32231: ARRAY
32232: NOT
32233: PUSH
32234: LD_EXP 81
32238: PUSH
32239: LD_VAR 0 2
32243: ARRAY
32244: PUSH
32245: LD_INT 2
32247: ARRAY
32248: NOT
32249: AND
32250: IFFALSE 32288
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
32252: LD_ADDR_EXP 82
32256: PUSH
32257: LD_EXP 82
32261: PPUSH
32262: LD_VAR 0 2
32266: PPUSH
32267: EMPTY
32268: PPUSH
32269: CALL_OW 1
32273: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
32274: LD_VAR 0 2
32278: PPUSH
32279: LD_INT 102
32281: PPUSH
32282: CALL 26323 0 2
// continue ;
32286: GO 32215
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
32288: LD_ADDR_VAR 0 4
32292: PUSH
32293: LD_EXP 78
32297: PUSH
32298: LD_VAR 0 2
32302: ARRAY
32303: PPUSH
32304: LD_INT 25
32306: PUSH
32307: LD_INT 4
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PPUSH
32314: CALL_OW 72
32318: ST_TO_ADDR
// if not tmp then
32319: LD_VAR 0 4
32323: NOT
32324: IFFALSE 32328
// continue ;
32326: GO 32215
// if mc_taming [ i ] then
32328: LD_EXP 109
32332: PUSH
32333: LD_VAR 0 2
32337: ARRAY
32338: IFFALSE 32362
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
32340: LD_ADDR_EXP 109
32344: PUSH
32345: LD_EXP 109
32349: PPUSH
32350: LD_VAR 0 2
32354: PPUSH
32355: EMPTY
32356: PPUSH
32357: CALL_OW 1
32361: ST_TO_ADDR
// for j in tmp do
32362: LD_ADDR_VAR 0 3
32366: PUSH
32367: LD_VAR 0 4
32371: PUSH
32372: FOR_IN
32373: IFFALSE 32596
// begin if IsInUnit ( j ) then
32375: LD_VAR 0 3
32379: PPUSH
32380: CALL_OW 310
32384: IFFALSE 32395
// ComExitBuilding ( j ) ;
32386: LD_VAR 0 3
32390: PPUSH
32391: CALL_OW 122
// if not j in mc_healers [ i ] then
32395: LD_VAR 0 3
32399: PUSH
32400: LD_EXP 82
32404: PUSH
32405: LD_VAR 0 2
32409: ARRAY
32410: IN
32411: NOT
32412: IFFALSE 32458
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
32414: LD_ADDR_EXP 82
32418: PUSH
32419: LD_EXP 82
32423: PPUSH
32424: LD_VAR 0 2
32428: PUSH
32429: LD_EXP 82
32433: PUSH
32434: LD_VAR 0 2
32438: ARRAY
32439: PUSH
32440: LD_INT 1
32442: PLUS
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PPUSH
32448: LD_VAR 0 3
32452: PPUSH
32453: CALL 57824 0 3
32457: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
32458: LD_VAR 0 3
32462: PPUSH
32463: CALL_OW 110
32467: PUSH
32468: LD_INT 102
32470: NONEQUAL
32471: IFFALSE 32485
// SetTag ( j , 102 ) ;
32473: LD_VAR 0 3
32477: PPUSH
32478: LD_INT 102
32480: PPUSH
32481: CALL_OW 109
// Wait ( 3 ) ;
32485: LD_INT 3
32487: PPUSH
32488: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
32492: LD_EXP 81
32496: PUSH
32497: LD_VAR 0 2
32501: ARRAY
32502: PUSH
32503: LD_INT 1
32505: ARRAY
32506: IFFALSE 32538
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
32508: LD_VAR 0 3
32512: PPUSH
32513: LD_EXP 81
32517: PUSH
32518: LD_VAR 0 2
32522: ARRAY
32523: PUSH
32524: LD_INT 1
32526: ARRAY
32527: PUSH
32528: LD_INT 1
32530: ARRAY
32531: PPUSH
32532: CALL_OW 128
32536: GO 32594
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
32538: LD_VAR 0 3
32542: PPUSH
32543: CALL_OW 314
32547: NOT
32548: PUSH
32549: LD_EXP 81
32553: PUSH
32554: LD_VAR 0 2
32558: ARRAY
32559: PUSH
32560: LD_INT 2
32562: ARRAY
32563: AND
32564: IFFALSE 32594
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
32566: LD_VAR 0 3
32570: PPUSH
32571: LD_EXP 81
32575: PUSH
32576: LD_VAR 0 2
32580: ARRAY
32581: PUSH
32582: LD_INT 2
32584: ARRAY
32585: PUSH
32586: LD_INT 1
32588: ARRAY
32589: PPUSH
32590: CALL_OW 128
// end ;
32594: GO 32372
32596: POP
32597: POP
// end ;
32598: GO 32215
32600: POP
32601: POP
// end ;
32602: LD_VAR 0 1
32606: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
32607: LD_INT 0
32609: PPUSH
32610: PPUSH
32611: PPUSH
32612: PPUSH
32613: PPUSH
32614: PPUSH
// if not mc_bases then
32615: LD_EXP 78
32619: NOT
32620: IFFALSE 32624
// exit ;
32622: GO 33787
// for i = 1 to mc_bases do
32624: LD_ADDR_VAR 0 2
32628: PUSH
32629: DOUBLE
32630: LD_INT 1
32632: DEC
32633: ST_TO_ADDR
32634: LD_EXP 78
32638: PUSH
32639: FOR_TO
32640: IFFALSE 33785
// begin if mc_scan [ i ] then
32642: LD_EXP 101
32646: PUSH
32647: LD_VAR 0 2
32651: ARRAY
32652: IFFALSE 32656
// continue ;
32654: GO 32639
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
32656: LD_EXP 83
32660: PUSH
32661: LD_VAR 0 2
32665: ARRAY
32666: NOT
32667: PUSH
32668: LD_EXP 85
32672: PUSH
32673: LD_VAR 0 2
32677: ARRAY
32678: NOT
32679: AND
32680: PUSH
32681: LD_EXP 84
32685: PUSH
32686: LD_VAR 0 2
32690: ARRAY
32691: AND
32692: IFFALSE 32730
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
32694: LD_ADDR_EXP 84
32698: PUSH
32699: LD_EXP 84
32703: PPUSH
32704: LD_VAR 0 2
32708: PPUSH
32709: EMPTY
32710: PPUSH
32711: CALL_OW 1
32715: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32716: LD_VAR 0 2
32720: PPUSH
32721: LD_INT 103
32723: PPUSH
32724: CALL 26323 0 2
// continue ;
32728: GO 32639
// end ; if mc_construct_list [ i ] then
32730: LD_EXP 85
32734: PUSH
32735: LD_VAR 0 2
32739: ARRAY
32740: IFFALSE 32960
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32742: LD_ADDR_VAR 0 5
32746: PUSH
32747: LD_EXP 78
32751: PUSH
32752: LD_VAR 0 2
32756: ARRAY
32757: PPUSH
32758: LD_INT 25
32760: PUSH
32761: LD_INT 2
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PPUSH
32768: CALL_OW 72
32772: PUSH
32773: LD_EXP 80
32777: PUSH
32778: LD_VAR 0 2
32782: ARRAY
32783: DIFF
32784: ST_TO_ADDR
// if not tmp then
32785: LD_VAR 0 5
32789: NOT
32790: IFFALSE 32794
// continue ;
32792: GO 32639
// for j in tmp do
32794: LD_ADDR_VAR 0 3
32798: PUSH
32799: LD_VAR 0 5
32803: PUSH
32804: FOR_IN
32805: IFFALSE 32956
// begin if not mc_builders [ i ] then
32807: LD_EXP 84
32811: PUSH
32812: LD_VAR 0 2
32816: ARRAY
32817: NOT
32818: IFFALSE 32876
// begin SetTag ( j , 103 ) ;
32820: LD_VAR 0 3
32824: PPUSH
32825: LD_INT 103
32827: PPUSH
32828: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32832: LD_ADDR_EXP 84
32836: PUSH
32837: LD_EXP 84
32841: PPUSH
32842: LD_VAR 0 2
32846: PUSH
32847: LD_EXP 84
32851: PUSH
32852: LD_VAR 0 2
32856: ARRAY
32857: PUSH
32858: LD_INT 1
32860: PLUS
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PPUSH
32866: LD_VAR 0 3
32870: PPUSH
32871: CALL 57824 0 3
32875: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32876: LD_VAR 0 3
32880: PPUSH
32881: CALL_OW 310
32885: IFFALSE 32896
// ComExitBuilding ( j ) ;
32887: LD_VAR 0 3
32891: PPUSH
32892: CALL_OW 122
// wait ( 3 ) ;
32896: LD_INT 3
32898: PPUSH
32899: CALL_OW 67
// if not mc_construct_list [ i ] then
32903: LD_EXP 85
32907: PUSH
32908: LD_VAR 0 2
32912: ARRAY
32913: NOT
32914: IFFALSE 32918
// break ;
32916: GO 32956
// if not HasTask ( j ) then
32918: LD_VAR 0 3
32922: PPUSH
32923: CALL_OW 314
32927: NOT
32928: IFFALSE 32954
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32930: LD_VAR 0 3
32934: PPUSH
32935: LD_EXP 85
32939: PUSH
32940: LD_VAR 0 2
32944: ARRAY
32945: PUSH
32946: LD_INT 1
32948: ARRAY
32949: PPUSH
32950: CALL 60694 0 2
// end ;
32954: GO 32804
32956: POP
32957: POP
// end else
32958: GO 33783
// if mc_build_list [ i ] then
32960: LD_EXP 83
32964: PUSH
32965: LD_VAR 0 2
32969: ARRAY
32970: IFFALSE 33783
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32972: LD_EXP 83
32976: PUSH
32977: LD_VAR 0 2
32981: ARRAY
32982: PUSH
32983: LD_INT 1
32985: ARRAY
32986: PUSH
32987: LD_INT 1
32989: ARRAY
32990: PPUSH
32991: CALL 60518 0 1
32995: PUSH
32996: LD_EXP 78
33000: PUSH
33001: LD_VAR 0 2
33005: ARRAY
33006: PPUSH
33007: LD_INT 2
33009: PUSH
33010: LD_INT 30
33012: PUSH
33013: LD_INT 2
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 30
33022: PUSH
33023: LD_INT 3
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: LIST
33034: PPUSH
33035: CALL_OW 72
33039: NOT
33040: AND
33041: IFFALSE 33146
// begin for j = 1 to mc_build_list [ i ] do
33043: LD_ADDR_VAR 0 3
33047: PUSH
33048: DOUBLE
33049: LD_INT 1
33051: DEC
33052: ST_TO_ADDR
33053: LD_EXP 83
33057: PUSH
33058: LD_VAR 0 2
33062: ARRAY
33063: PUSH
33064: FOR_TO
33065: IFFALSE 33144
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
33067: LD_EXP 83
33071: PUSH
33072: LD_VAR 0 2
33076: ARRAY
33077: PUSH
33078: LD_VAR 0 3
33082: ARRAY
33083: PUSH
33084: LD_INT 1
33086: ARRAY
33087: PUSH
33088: LD_INT 2
33090: EQUAL
33091: IFFALSE 33142
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
33093: LD_ADDR_EXP 83
33097: PUSH
33098: LD_EXP 83
33102: PPUSH
33103: LD_VAR 0 2
33107: PPUSH
33108: LD_EXP 83
33112: PUSH
33113: LD_VAR 0 2
33117: ARRAY
33118: PPUSH
33119: LD_VAR 0 3
33123: PPUSH
33124: LD_INT 1
33126: PPUSH
33127: LD_INT 0
33129: PPUSH
33130: CALL 57242 0 4
33134: PPUSH
33135: CALL_OW 1
33139: ST_TO_ADDR
// break ;
33140: GO 33144
// end ;
33142: GO 33064
33144: POP
33145: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33146: LD_ADDR_VAR 0 6
33150: PUSH
33151: LD_EXP 78
33155: PUSH
33156: LD_VAR 0 2
33160: ARRAY
33161: PPUSH
33162: LD_INT 2
33164: PUSH
33165: LD_INT 30
33167: PUSH
33168: LD_INT 0
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 30
33177: PUSH
33178: LD_INT 1
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: LIST
33189: PPUSH
33190: CALL_OW 72
33194: ST_TO_ADDR
// for k := 1 to depot do
33195: LD_ADDR_VAR 0 4
33199: PUSH
33200: DOUBLE
33201: LD_INT 1
33203: DEC
33204: ST_TO_ADDR
33205: LD_VAR 0 6
33209: PUSH
33210: FOR_TO
33211: IFFALSE 33781
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
33213: LD_EXP 83
33217: PUSH
33218: LD_VAR 0 2
33222: ARRAY
33223: PUSH
33224: LD_INT 1
33226: ARRAY
33227: PUSH
33228: LD_INT 1
33230: ARRAY
33231: PUSH
33232: LD_INT 0
33234: EQUAL
33235: PUSH
33236: LD_VAR 0 6
33240: PUSH
33241: LD_VAR 0 4
33245: ARRAY
33246: PPUSH
33247: LD_EXP 83
33251: PUSH
33252: LD_VAR 0 2
33256: ARRAY
33257: PUSH
33258: LD_INT 1
33260: ARRAY
33261: PUSH
33262: LD_INT 1
33264: ARRAY
33265: PPUSH
33266: LD_EXP 83
33270: PUSH
33271: LD_VAR 0 2
33275: ARRAY
33276: PUSH
33277: LD_INT 1
33279: ARRAY
33280: PUSH
33281: LD_INT 2
33283: ARRAY
33284: PPUSH
33285: LD_EXP 83
33289: PUSH
33290: LD_VAR 0 2
33294: ARRAY
33295: PUSH
33296: LD_INT 1
33298: ARRAY
33299: PUSH
33300: LD_INT 3
33302: ARRAY
33303: PPUSH
33304: LD_EXP 83
33308: PUSH
33309: LD_VAR 0 2
33313: ARRAY
33314: PUSH
33315: LD_INT 1
33317: ARRAY
33318: PUSH
33319: LD_INT 4
33321: ARRAY
33322: PPUSH
33323: CALL 65930 0 5
33327: OR
33328: IFFALSE 33609
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33330: LD_ADDR_VAR 0 5
33334: PUSH
33335: LD_EXP 78
33339: PUSH
33340: LD_VAR 0 2
33344: ARRAY
33345: PPUSH
33346: LD_INT 25
33348: PUSH
33349: LD_INT 2
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PPUSH
33356: CALL_OW 72
33360: PUSH
33361: LD_EXP 80
33365: PUSH
33366: LD_VAR 0 2
33370: ARRAY
33371: DIFF
33372: ST_TO_ADDR
// if not tmp then
33373: LD_VAR 0 5
33377: NOT
33378: IFFALSE 33382
// continue ;
33380: GO 33210
// for j in tmp do
33382: LD_ADDR_VAR 0 3
33386: PUSH
33387: LD_VAR 0 5
33391: PUSH
33392: FOR_IN
33393: IFFALSE 33605
// begin if not mc_builders [ i ] then
33395: LD_EXP 84
33399: PUSH
33400: LD_VAR 0 2
33404: ARRAY
33405: NOT
33406: IFFALSE 33464
// begin SetTag ( j , 103 ) ;
33408: LD_VAR 0 3
33412: PPUSH
33413: LD_INT 103
33415: PPUSH
33416: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33420: LD_ADDR_EXP 84
33424: PUSH
33425: LD_EXP 84
33429: PPUSH
33430: LD_VAR 0 2
33434: PUSH
33435: LD_EXP 84
33439: PUSH
33440: LD_VAR 0 2
33444: ARRAY
33445: PUSH
33446: LD_INT 1
33448: PLUS
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PPUSH
33454: LD_VAR 0 3
33458: PPUSH
33459: CALL 57824 0 3
33463: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33464: LD_VAR 0 3
33468: PPUSH
33469: CALL_OW 310
33473: IFFALSE 33484
// ComExitBuilding ( j ) ;
33475: LD_VAR 0 3
33479: PPUSH
33480: CALL_OW 122
// wait ( 3 ) ;
33484: LD_INT 3
33486: PPUSH
33487: CALL_OW 67
// if not mc_build_list [ i ] then
33491: LD_EXP 83
33495: PUSH
33496: LD_VAR 0 2
33500: ARRAY
33501: NOT
33502: IFFALSE 33506
// break ;
33504: GO 33605
// if not HasTask ( j ) then
33506: LD_VAR 0 3
33510: PPUSH
33511: CALL_OW 314
33515: NOT
33516: IFFALSE 33603
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
33518: LD_VAR 0 3
33522: PPUSH
33523: LD_EXP 83
33527: PUSH
33528: LD_VAR 0 2
33532: ARRAY
33533: PUSH
33534: LD_INT 1
33536: ARRAY
33537: PUSH
33538: LD_INT 1
33540: ARRAY
33541: PPUSH
33542: LD_EXP 83
33546: PUSH
33547: LD_VAR 0 2
33551: ARRAY
33552: PUSH
33553: LD_INT 1
33555: ARRAY
33556: PUSH
33557: LD_INT 2
33559: ARRAY
33560: PPUSH
33561: LD_EXP 83
33565: PUSH
33566: LD_VAR 0 2
33570: ARRAY
33571: PUSH
33572: LD_INT 1
33574: ARRAY
33575: PUSH
33576: LD_INT 3
33578: ARRAY
33579: PPUSH
33580: LD_EXP 83
33584: PUSH
33585: LD_VAR 0 2
33589: ARRAY
33590: PUSH
33591: LD_INT 1
33593: ARRAY
33594: PUSH
33595: LD_INT 4
33597: ARRAY
33598: PPUSH
33599: CALL_OW 145
// end ;
33603: GO 33392
33605: POP
33606: POP
// end else
33607: GO 33779
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
33609: LD_EXP 78
33613: PUSH
33614: LD_VAR 0 2
33618: ARRAY
33619: PPUSH
33620: LD_EXP 83
33624: PUSH
33625: LD_VAR 0 2
33629: ARRAY
33630: PUSH
33631: LD_INT 1
33633: ARRAY
33634: PUSH
33635: LD_INT 1
33637: ARRAY
33638: PPUSH
33639: LD_EXP 83
33643: PUSH
33644: LD_VAR 0 2
33648: ARRAY
33649: PUSH
33650: LD_INT 1
33652: ARRAY
33653: PUSH
33654: LD_INT 2
33656: ARRAY
33657: PPUSH
33658: LD_EXP 83
33662: PUSH
33663: LD_VAR 0 2
33667: ARRAY
33668: PUSH
33669: LD_INT 1
33671: ARRAY
33672: PUSH
33673: LD_INT 3
33675: ARRAY
33676: PPUSH
33677: LD_EXP 83
33681: PUSH
33682: LD_VAR 0 2
33686: ARRAY
33687: PUSH
33688: LD_INT 1
33690: ARRAY
33691: PUSH
33692: LD_INT 4
33694: ARRAY
33695: PPUSH
33696: LD_EXP 78
33700: PUSH
33701: LD_VAR 0 2
33705: ARRAY
33706: PPUSH
33707: LD_INT 21
33709: PUSH
33710: LD_INT 3
33712: PUSH
33713: EMPTY
33714: LIST
33715: LIST
33716: PPUSH
33717: CALL_OW 72
33721: PPUSH
33722: EMPTY
33723: PPUSH
33724: CALL 64684 0 7
33728: NOT
33729: IFFALSE 33779
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
33731: LD_ADDR_EXP 83
33735: PUSH
33736: LD_EXP 83
33740: PPUSH
33741: LD_VAR 0 2
33745: PPUSH
33746: LD_EXP 83
33750: PUSH
33751: LD_VAR 0 2
33755: ARRAY
33756: PPUSH
33757: LD_INT 1
33759: PPUSH
33760: LD_INT 1
33762: NEG
33763: PPUSH
33764: LD_INT 0
33766: PPUSH
33767: CALL 57242 0 4
33771: PPUSH
33772: CALL_OW 1
33776: ST_TO_ADDR
// continue ;
33777: GO 33210
// end ; end ;
33779: GO 33210
33781: POP
33782: POP
// end ; end ;
33783: GO 32639
33785: POP
33786: POP
// end ;
33787: LD_VAR 0 1
33791: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
33792: LD_INT 0
33794: PPUSH
33795: PPUSH
33796: PPUSH
33797: PPUSH
33798: PPUSH
33799: PPUSH
// if not mc_bases then
33800: LD_EXP 78
33804: NOT
33805: IFFALSE 33809
// exit ;
33807: GO 34236
// for i = 1 to mc_bases do
33809: LD_ADDR_VAR 0 2
33813: PUSH
33814: DOUBLE
33815: LD_INT 1
33817: DEC
33818: ST_TO_ADDR
33819: LD_EXP 78
33823: PUSH
33824: FOR_TO
33825: IFFALSE 34234
// begin tmp := mc_build_upgrade [ i ] ;
33827: LD_ADDR_VAR 0 4
33831: PUSH
33832: LD_EXP 110
33836: PUSH
33837: LD_VAR 0 2
33841: ARRAY
33842: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33843: LD_ADDR_VAR 0 6
33847: PUSH
33848: LD_EXP 111
33852: PUSH
33853: LD_VAR 0 2
33857: ARRAY
33858: PPUSH
33859: LD_INT 2
33861: PUSH
33862: LD_INT 30
33864: PUSH
33865: LD_INT 6
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 30
33874: PUSH
33875: LD_INT 7
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: LIST
33886: PPUSH
33887: CALL_OW 72
33891: ST_TO_ADDR
// if not tmp and not lab then
33892: LD_VAR 0 4
33896: NOT
33897: PUSH
33898: LD_VAR 0 6
33902: NOT
33903: AND
33904: IFFALSE 33908
// continue ;
33906: GO 33824
// if tmp then
33908: LD_VAR 0 4
33912: IFFALSE 34032
// for j in tmp do
33914: LD_ADDR_VAR 0 3
33918: PUSH
33919: LD_VAR 0 4
33923: PUSH
33924: FOR_IN
33925: IFFALSE 34030
// begin if UpgradeCost ( j ) then
33927: LD_VAR 0 3
33931: PPUSH
33932: CALL 64344 0 1
33936: IFFALSE 34028
// begin ComUpgrade ( j ) ;
33938: LD_VAR 0 3
33942: PPUSH
33943: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33947: LD_ADDR_EXP 110
33951: PUSH
33952: LD_EXP 110
33956: PPUSH
33957: LD_VAR 0 2
33961: PPUSH
33962: LD_EXP 110
33966: PUSH
33967: LD_VAR 0 2
33971: ARRAY
33972: PUSH
33973: LD_VAR 0 3
33977: DIFF
33978: PPUSH
33979: CALL_OW 1
33983: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33984: LD_ADDR_EXP 85
33988: PUSH
33989: LD_EXP 85
33993: PPUSH
33994: LD_VAR 0 2
33998: PUSH
33999: LD_EXP 85
34003: PUSH
34004: LD_VAR 0 2
34008: ARRAY
34009: PUSH
34010: LD_INT 1
34012: PLUS
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PPUSH
34018: LD_VAR 0 3
34022: PPUSH
34023: CALL 57824 0 3
34027: ST_TO_ADDR
// end ; end ;
34028: GO 33924
34030: POP
34031: POP
// if not lab or not mc_lab_upgrade [ i ] then
34032: LD_VAR 0 6
34036: NOT
34037: PUSH
34038: LD_EXP 112
34042: PUSH
34043: LD_VAR 0 2
34047: ARRAY
34048: NOT
34049: OR
34050: IFFALSE 34054
// continue ;
34052: GO 33824
// for j in lab do
34054: LD_ADDR_VAR 0 3
34058: PUSH
34059: LD_VAR 0 6
34063: PUSH
34064: FOR_IN
34065: IFFALSE 34230
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
34067: LD_VAR 0 3
34071: PPUSH
34072: CALL_OW 266
34076: PUSH
34077: LD_INT 6
34079: PUSH
34080: LD_INT 7
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: IN
34087: PUSH
34088: LD_VAR 0 3
34092: PPUSH
34093: CALL_OW 461
34097: PUSH
34098: LD_INT 1
34100: NONEQUAL
34101: AND
34102: IFFALSE 34228
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
34104: LD_VAR 0 3
34108: PPUSH
34109: LD_EXP 112
34113: PUSH
34114: LD_VAR 0 2
34118: ARRAY
34119: PUSH
34120: LD_INT 1
34122: ARRAY
34123: PPUSH
34124: CALL 64549 0 2
34128: IFFALSE 34228
// begin ComCancel ( j ) ;
34130: LD_VAR 0 3
34134: PPUSH
34135: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
34139: LD_VAR 0 3
34143: PPUSH
34144: LD_EXP 112
34148: PUSH
34149: LD_VAR 0 2
34153: ARRAY
34154: PUSH
34155: LD_INT 1
34157: ARRAY
34158: PPUSH
34159: CALL_OW 207
// if not j in mc_construct_list [ i ] then
34163: LD_VAR 0 3
34167: PUSH
34168: LD_EXP 85
34172: PUSH
34173: LD_VAR 0 2
34177: ARRAY
34178: IN
34179: NOT
34180: IFFALSE 34226
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34182: LD_ADDR_EXP 85
34186: PUSH
34187: LD_EXP 85
34191: PPUSH
34192: LD_VAR 0 2
34196: PUSH
34197: LD_EXP 85
34201: PUSH
34202: LD_VAR 0 2
34206: ARRAY
34207: PUSH
34208: LD_INT 1
34210: PLUS
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PPUSH
34216: LD_VAR 0 3
34220: PPUSH
34221: CALL 57824 0 3
34225: ST_TO_ADDR
// break ;
34226: GO 34230
// end ; end ; end ;
34228: GO 34064
34230: POP
34231: POP
// end ;
34232: GO 33824
34234: POP
34235: POP
// end ;
34236: LD_VAR 0 1
34240: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
34241: LD_INT 0
34243: PPUSH
34244: PPUSH
34245: PPUSH
34246: PPUSH
34247: PPUSH
34248: PPUSH
34249: PPUSH
34250: PPUSH
34251: PPUSH
// if not mc_bases then
34252: LD_EXP 78
34256: NOT
34257: IFFALSE 34261
// exit ;
34259: GO 34666
// for i = 1 to mc_bases do
34261: LD_ADDR_VAR 0 2
34265: PUSH
34266: DOUBLE
34267: LD_INT 1
34269: DEC
34270: ST_TO_ADDR
34271: LD_EXP 78
34275: PUSH
34276: FOR_TO
34277: IFFALSE 34664
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
34279: LD_EXP 86
34283: PUSH
34284: LD_VAR 0 2
34288: ARRAY
34289: NOT
34290: PUSH
34291: LD_EXP 78
34295: PUSH
34296: LD_VAR 0 2
34300: ARRAY
34301: PPUSH
34302: LD_INT 30
34304: PUSH
34305: LD_INT 3
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PPUSH
34312: CALL_OW 72
34316: NOT
34317: OR
34318: IFFALSE 34322
// continue ;
34320: GO 34276
// busy := false ;
34322: LD_ADDR_VAR 0 8
34326: PUSH
34327: LD_INT 0
34329: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34330: LD_ADDR_VAR 0 4
34334: PUSH
34335: LD_EXP 78
34339: PUSH
34340: LD_VAR 0 2
34344: ARRAY
34345: PPUSH
34346: LD_INT 30
34348: PUSH
34349: LD_INT 3
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PPUSH
34356: CALL_OW 72
34360: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
34361: LD_ADDR_VAR 0 6
34365: PUSH
34366: LD_EXP 86
34370: PUSH
34371: LD_VAR 0 2
34375: ARRAY
34376: PPUSH
34377: LD_INT 2
34379: PUSH
34380: LD_INT 30
34382: PUSH
34383: LD_INT 32
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: PUSH
34390: LD_INT 30
34392: PUSH
34393: LD_INT 33
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: EMPTY
34401: LIST
34402: LIST
34403: LIST
34404: PPUSH
34405: CALL_OW 72
34409: ST_TO_ADDR
// if not t then
34410: LD_VAR 0 6
34414: NOT
34415: IFFALSE 34419
// continue ;
34417: GO 34276
// for j in tmp do
34419: LD_ADDR_VAR 0 3
34423: PUSH
34424: LD_VAR 0 4
34428: PUSH
34429: FOR_IN
34430: IFFALSE 34460
// if not BuildingStatus ( j ) = bs_idle then
34432: LD_VAR 0 3
34436: PPUSH
34437: CALL_OW 461
34441: PUSH
34442: LD_INT 2
34444: EQUAL
34445: NOT
34446: IFFALSE 34458
// begin busy := true ;
34448: LD_ADDR_VAR 0 8
34452: PUSH
34453: LD_INT 1
34455: ST_TO_ADDR
// break ;
34456: GO 34460
// end ;
34458: GO 34429
34460: POP
34461: POP
// if busy then
34462: LD_VAR 0 8
34466: IFFALSE 34470
// continue ;
34468: GO 34276
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
34470: LD_ADDR_VAR 0 7
34474: PUSH
34475: LD_VAR 0 6
34479: PPUSH
34480: LD_INT 35
34482: PUSH
34483: LD_INT 0
34485: PUSH
34486: EMPTY
34487: LIST
34488: LIST
34489: PPUSH
34490: CALL_OW 72
34494: ST_TO_ADDR
// if tw then
34495: LD_VAR 0 7
34499: IFFALSE 34576
// begin tw := tw [ 1 ] ;
34501: LD_ADDR_VAR 0 7
34505: PUSH
34506: LD_VAR 0 7
34510: PUSH
34511: LD_INT 1
34513: ARRAY
34514: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
34515: LD_ADDR_VAR 0 9
34519: PUSH
34520: LD_VAR 0 7
34524: PPUSH
34525: LD_EXP 103
34529: PUSH
34530: LD_VAR 0 2
34534: ARRAY
34535: PPUSH
34536: CALL 62841 0 2
34540: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
34541: LD_EXP 117
34545: PUSH
34546: LD_VAR 0 2
34550: ARRAY
34551: IFFALSE 34574
// if not weapon in mc_allowed_tower_weapons [ i ] then
34553: LD_VAR 0 9
34557: PUSH
34558: LD_EXP 117
34562: PUSH
34563: LD_VAR 0 2
34567: ARRAY
34568: IN
34569: NOT
34570: IFFALSE 34574
// continue ;
34572: GO 34276
// end else
34574: GO 34639
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
34576: LD_ADDR_VAR 0 5
34580: PUSH
34581: LD_EXP 86
34585: PUSH
34586: LD_VAR 0 2
34590: ARRAY
34591: PPUSH
34592: LD_VAR 0 4
34596: PPUSH
34597: CALL 89731 0 2
34601: ST_TO_ADDR
// if not tmp2 then
34602: LD_VAR 0 5
34606: NOT
34607: IFFALSE 34611
// continue ;
34609: GO 34276
// tw := tmp2 [ 1 ] ;
34611: LD_ADDR_VAR 0 7
34615: PUSH
34616: LD_VAR 0 5
34620: PUSH
34621: LD_INT 1
34623: ARRAY
34624: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
34625: LD_ADDR_VAR 0 9
34629: PUSH
34630: LD_VAR 0 5
34634: PUSH
34635: LD_INT 2
34637: ARRAY
34638: ST_TO_ADDR
// end ; if not weapon then
34639: LD_VAR 0 9
34643: NOT
34644: IFFALSE 34648
// continue ;
34646: GO 34276
// ComPlaceWeapon ( tw , weapon ) ;
34648: LD_VAR 0 7
34652: PPUSH
34653: LD_VAR 0 9
34657: PPUSH
34658: CALL_OW 148
// end ;
34662: GO 34276
34664: POP
34665: POP
// end ;
34666: LD_VAR 0 1
34670: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
34671: LD_INT 0
34673: PPUSH
34674: PPUSH
34675: PPUSH
34676: PPUSH
34677: PPUSH
34678: PPUSH
34679: PPUSH
// if not mc_bases then
34680: LD_EXP 78
34684: NOT
34685: IFFALSE 34689
// exit ;
34687: GO 35464
// for i = 1 to mc_bases do
34689: LD_ADDR_VAR 0 2
34693: PUSH
34694: DOUBLE
34695: LD_INT 1
34697: DEC
34698: ST_TO_ADDR
34699: LD_EXP 78
34703: PUSH
34704: FOR_TO
34705: IFFALSE 35462
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
34707: LD_EXP 91
34711: PUSH
34712: LD_VAR 0 2
34716: ARRAY
34717: NOT
34718: PUSH
34719: LD_EXP 91
34723: PUSH
34724: LD_VAR 0 2
34728: ARRAY
34729: PUSH
34730: LD_EXP 92
34734: PUSH
34735: LD_VAR 0 2
34739: ARRAY
34740: EQUAL
34741: OR
34742: PUSH
34743: LD_EXP 101
34747: PUSH
34748: LD_VAR 0 2
34752: ARRAY
34753: OR
34754: IFFALSE 34758
// continue ;
34756: GO 34704
// if mc_miners [ i ] then
34758: LD_EXP 92
34762: PUSH
34763: LD_VAR 0 2
34767: ARRAY
34768: IFFALSE 35149
// begin for j = mc_miners [ i ] downto 1 do
34770: LD_ADDR_VAR 0 3
34774: PUSH
34775: DOUBLE
34776: LD_EXP 92
34780: PUSH
34781: LD_VAR 0 2
34785: ARRAY
34786: INC
34787: ST_TO_ADDR
34788: LD_INT 1
34790: PUSH
34791: FOR_DOWNTO
34792: IFFALSE 35147
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
34794: LD_EXP 92
34798: PUSH
34799: LD_VAR 0 2
34803: ARRAY
34804: PUSH
34805: LD_VAR 0 3
34809: ARRAY
34810: PPUSH
34811: CALL_OW 301
34815: PUSH
34816: LD_EXP 92
34820: PUSH
34821: LD_VAR 0 2
34825: ARRAY
34826: PUSH
34827: LD_VAR 0 3
34831: ARRAY
34832: PPUSH
34833: CALL_OW 257
34837: PUSH
34838: LD_INT 1
34840: NONEQUAL
34841: OR
34842: IFFALSE 34905
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34844: LD_ADDR_VAR 0 5
34848: PUSH
34849: LD_EXP 92
34853: PUSH
34854: LD_VAR 0 2
34858: ARRAY
34859: PUSH
34860: LD_EXP 92
34864: PUSH
34865: LD_VAR 0 2
34869: ARRAY
34870: PUSH
34871: LD_VAR 0 3
34875: ARRAY
34876: DIFF
34877: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34878: LD_ADDR_EXP 92
34882: PUSH
34883: LD_EXP 92
34887: PPUSH
34888: LD_VAR 0 2
34892: PPUSH
34893: LD_VAR 0 5
34897: PPUSH
34898: CALL_OW 1
34902: ST_TO_ADDR
// continue ;
34903: GO 34791
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34905: LD_EXP 92
34909: PUSH
34910: LD_VAR 0 2
34914: ARRAY
34915: PUSH
34916: LD_VAR 0 3
34920: ARRAY
34921: PPUSH
34922: CALL_OW 257
34926: PUSH
34927: LD_INT 1
34929: EQUAL
34930: PUSH
34931: LD_EXP 92
34935: PUSH
34936: LD_VAR 0 2
34940: ARRAY
34941: PUSH
34942: LD_VAR 0 3
34946: ARRAY
34947: PPUSH
34948: CALL_OW 459
34952: NOT
34953: AND
34954: PUSH
34955: LD_EXP 92
34959: PUSH
34960: LD_VAR 0 2
34964: ARRAY
34965: PUSH
34966: LD_VAR 0 3
34970: ARRAY
34971: PPUSH
34972: CALL_OW 314
34976: NOT
34977: AND
34978: IFFALSE 35145
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34980: LD_EXP 92
34984: PUSH
34985: LD_VAR 0 2
34989: ARRAY
34990: PUSH
34991: LD_VAR 0 3
34995: ARRAY
34996: PPUSH
34997: CALL_OW 310
35001: IFFALSE 35024
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
35003: LD_EXP 92
35007: PUSH
35008: LD_VAR 0 2
35012: ARRAY
35013: PUSH
35014: LD_VAR 0 3
35018: ARRAY
35019: PPUSH
35020: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
35024: LD_EXP 92
35028: PUSH
35029: LD_VAR 0 2
35033: ARRAY
35034: PUSH
35035: LD_VAR 0 3
35039: ARRAY
35040: PPUSH
35041: CALL_OW 314
35045: NOT
35046: IFFALSE 35145
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
35048: LD_ADDR_VAR 0 7
35052: PUSH
35053: LD_VAR 0 3
35057: PUSH
35058: LD_EXP 91
35062: PUSH
35063: LD_VAR 0 2
35067: ARRAY
35068: PPUSH
35069: CALL 54964 0 1
35073: MOD
35074: PUSH
35075: LD_INT 1
35077: PLUS
35078: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
35079: LD_EXP 92
35083: PUSH
35084: LD_VAR 0 2
35088: ARRAY
35089: PUSH
35090: LD_VAR 0 3
35094: ARRAY
35095: PPUSH
35096: LD_EXP 91
35100: PUSH
35101: LD_VAR 0 2
35105: ARRAY
35106: PUSH
35107: LD_VAR 0 7
35111: ARRAY
35112: PUSH
35113: LD_INT 1
35115: ARRAY
35116: PPUSH
35117: LD_EXP 91
35121: PUSH
35122: LD_VAR 0 2
35126: ARRAY
35127: PUSH
35128: LD_VAR 0 7
35132: ARRAY
35133: PUSH
35134: LD_INT 2
35136: ARRAY
35137: PPUSH
35138: LD_INT 0
35140: PPUSH
35141: CALL_OW 193
// end ; end ; end ;
35145: GO 34791
35147: POP
35148: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
35149: LD_ADDR_VAR 0 5
35153: PUSH
35154: LD_EXP 78
35158: PUSH
35159: LD_VAR 0 2
35163: ARRAY
35164: PPUSH
35165: LD_INT 2
35167: PUSH
35168: LD_INT 30
35170: PUSH
35171: LD_INT 4
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 30
35180: PUSH
35181: LD_INT 5
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 30
35190: PUSH
35191: LD_INT 32
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: LIST
35202: LIST
35203: PPUSH
35204: CALL_OW 72
35208: ST_TO_ADDR
// if not tmp then
35209: LD_VAR 0 5
35213: NOT
35214: IFFALSE 35218
// continue ;
35216: GO 34704
// list := [ ] ;
35218: LD_ADDR_VAR 0 6
35222: PUSH
35223: EMPTY
35224: ST_TO_ADDR
// for j in tmp do
35225: LD_ADDR_VAR 0 3
35229: PUSH
35230: LD_VAR 0 5
35234: PUSH
35235: FOR_IN
35236: IFFALSE 35305
// begin for k in UnitsInside ( j ) do
35238: LD_ADDR_VAR 0 4
35242: PUSH
35243: LD_VAR 0 3
35247: PPUSH
35248: CALL_OW 313
35252: PUSH
35253: FOR_IN
35254: IFFALSE 35301
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
35256: LD_VAR 0 4
35260: PPUSH
35261: CALL_OW 257
35265: PUSH
35266: LD_INT 1
35268: EQUAL
35269: PUSH
35270: LD_VAR 0 4
35274: PPUSH
35275: CALL_OW 459
35279: NOT
35280: AND
35281: IFFALSE 35299
// list := list ^ k ;
35283: LD_ADDR_VAR 0 6
35287: PUSH
35288: LD_VAR 0 6
35292: PUSH
35293: LD_VAR 0 4
35297: ADD
35298: ST_TO_ADDR
35299: GO 35253
35301: POP
35302: POP
// end ;
35303: GO 35235
35305: POP
35306: POP
// list := list diff mc_miners [ i ] ;
35307: LD_ADDR_VAR 0 6
35311: PUSH
35312: LD_VAR 0 6
35316: PUSH
35317: LD_EXP 92
35321: PUSH
35322: LD_VAR 0 2
35326: ARRAY
35327: DIFF
35328: ST_TO_ADDR
// if not list then
35329: LD_VAR 0 6
35333: NOT
35334: IFFALSE 35338
// continue ;
35336: GO 34704
// k := mc_mines [ i ] - mc_miners [ i ] ;
35338: LD_ADDR_VAR 0 4
35342: PUSH
35343: LD_EXP 91
35347: PUSH
35348: LD_VAR 0 2
35352: ARRAY
35353: PUSH
35354: LD_EXP 92
35358: PUSH
35359: LD_VAR 0 2
35363: ARRAY
35364: MINUS
35365: ST_TO_ADDR
// if k > list then
35366: LD_VAR 0 4
35370: PUSH
35371: LD_VAR 0 6
35375: GREATER
35376: IFFALSE 35388
// k := list ;
35378: LD_ADDR_VAR 0 4
35382: PUSH
35383: LD_VAR 0 6
35387: ST_TO_ADDR
// for j = 1 to k do
35388: LD_ADDR_VAR 0 3
35392: PUSH
35393: DOUBLE
35394: LD_INT 1
35396: DEC
35397: ST_TO_ADDR
35398: LD_VAR 0 4
35402: PUSH
35403: FOR_TO
35404: IFFALSE 35458
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
35406: LD_ADDR_EXP 92
35410: PUSH
35411: LD_EXP 92
35415: PPUSH
35416: LD_VAR 0 2
35420: PUSH
35421: LD_EXP 92
35425: PUSH
35426: LD_VAR 0 2
35430: ARRAY
35431: PUSH
35432: LD_INT 1
35434: PLUS
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PPUSH
35440: LD_VAR 0 6
35444: PUSH
35445: LD_VAR 0 3
35449: ARRAY
35450: PPUSH
35451: CALL 57824 0 3
35455: ST_TO_ADDR
35456: GO 35403
35458: POP
35459: POP
// end ;
35460: GO 34704
35462: POP
35463: POP
// end ;
35464: LD_VAR 0 1
35468: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
35469: LD_INT 0
35471: PPUSH
35472: PPUSH
35473: PPUSH
35474: PPUSH
35475: PPUSH
35476: PPUSH
35477: PPUSH
35478: PPUSH
35479: PPUSH
35480: PPUSH
35481: PPUSH
// if not mc_bases then
35482: LD_EXP 78
35486: NOT
35487: IFFALSE 35491
// exit ;
35489: GO 37314
// for i = 1 to mc_bases do
35491: LD_ADDR_VAR 0 2
35495: PUSH
35496: DOUBLE
35497: LD_INT 1
35499: DEC
35500: ST_TO_ADDR
35501: LD_EXP 78
35505: PUSH
35506: FOR_TO
35507: IFFALSE 37312
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
35509: LD_EXP 78
35513: PUSH
35514: LD_VAR 0 2
35518: ARRAY
35519: NOT
35520: PUSH
35521: LD_EXP 85
35525: PUSH
35526: LD_VAR 0 2
35530: ARRAY
35531: OR
35532: IFFALSE 35536
// continue ;
35534: GO 35506
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
35536: LD_EXP 94
35540: PUSH
35541: LD_VAR 0 2
35545: ARRAY
35546: NOT
35547: PUSH
35548: LD_EXP 95
35552: PUSH
35553: LD_VAR 0 2
35557: ARRAY
35558: AND
35559: IFFALSE 35597
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
35561: LD_ADDR_EXP 95
35565: PUSH
35566: LD_EXP 95
35570: PPUSH
35571: LD_VAR 0 2
35575: PPUSH
35576: EMPTY
35577: PPUSH
35578: CALL_OW 1
35582: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
35583: LD_VAR 0 2
35587: PPUSH
35588: LD_INT 107
35590: PPUSH
35591: CALL 26323 0 2
// continue ;
35595: GO 35506
// end ; target := [ ] ;
35597: LD_ADDR_VAR 0 7
35601: PUSH
35602: EMPTY
35603: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35604: LD_ADDR_VAR 0 6
35608: PUSH
35609: LD_EXP 78
35613: PUSH
35614: LD_VAR 0 2
35618: ARRAY
35619: PUSH
35620: LD_INT 1
35622: ARRAY
35623: PPUSH
35624: CALL_OW 255
35628: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35629: LD_ADDR_VAR 0 9
35633: PUSH
35634: LD_EXP 78
35638: PUSH
35639: LD_VAR 0 2
35643: ARRAY
35644: PPUSH
35645: LD_INT 2
35647: PUSH
35648: LD_INT 30
35650: PUSH
35651: LD_INT 0
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 30
35660: PUSH
35661: LD_INT 1
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: LIST
35672: PPUSH
35673: CALL_OW 72
35677: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
35678: LD_ADDR_VAR 0 3
35682: PUSH
35683: DOUBLE
35684: LD_EXP 94
35688: PUSH
35689: LD_VAR 0 2
35693: ARRAY
35694: INC
35695: ST_TO_ADDR
35696: LD_INT 1
35698: PUSH
35699: FOR_DOWNTO
35700: IFFALSE 35945
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
35702: LD_EXP 94
35706: PUSH
35707: LD_VAR 0 2
35711: ARRAY
35712: PUSH
35713: LD_VAR 0 3
35717: ARRAY
35718: PUSH
35719: LD_INT 2
35721: ARRAY
35722: PPUSH
35723: LD_EXP 94
35727: PUSH
35728: LD_VAR 0 2
35732: ARRAY
35733: PUSH
35734: LD_VAR 0 3
35738: ARRAY
35739: PUSH
35740: LD_INT 3
35742: ARRAY
35743: PPUSH
35744: CALL_OW 488
35748: PUSH
35749: LD_EXP 94
35753: PUSH
35754: LD_VAR 0 2
35758: ARRAY
35759: PUSH
35760: LD_VAR 0 3
35764: ARRAY
35765: PUSH
35766: LD_INT 2
35768: ARRAY
35769: PPUSH
35770: LD_EXP 94
35774: PUSH
35775: LD_VAR 0 2
35779: ARRAY
35780: PUSH
35781: LD_VAR 0 3
35785: ARRAY
35786: PUSH
35787: LD_INT 3
35789: ARRAY
35790: PPUSH
35791: CALL_OW 284
35795: PUSH
35796: LD_INT 0
35798: EQUAL
35799: AND
35800: IFFALSE 35855
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
35802: LD_ADDR_VAR 0 5
35806: PUSH
35807: LD_EXP 94
35811: PUSH
35812: LD_VAR 0 2
35816: ARRAY
35817: PPUSH
35818: LD_VAR 0 3
35822: PPUSH
35823: CALL_OW 3
35827: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35828: LD_ADDR_EXP 94
35832: PUSH
35833: LD_EXP 94
35837: PPUSH
35838: LD_VAR 0 2
35842: PPUSH
35843: LD_VAR 0 5
35847: PPUSH
35848: CALL_OW 1
35852: ST_TO_ADDR
// continue ;
35853: GO 35699
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35855: LD_VAR 0 6
35859: PPUSH
35860: LD_EXP 94
35864: PUSH
35865: LD_VAR 0 2
35869: ARRAY
35870: PUSH
35871: LD_VAR 0 3
35875: ARRAY
35876: PUSH
35877: LD_INT 2
35879: ARRAY
35880: PPUSH
35881: LD_EXP 94
35885: PUSH
35886: LD_VAR 0 2
35890: ARRAY
35891: PUSH
35892: LD_VAR 0 3
35896: ARRAY
35897: PUSH
35898: LD_INT 3
35900: ARRAY
35901: PPUSH
35902: LD_INT 30
35904: PPUSH
35905: CALL 58720 0 4
35909: PUSH
35910: LD_INT 4
35912: ARRAY
35913: PUSH
35914: LD_INT 0
35916: EQUAL
35917: IFFALSE 35943
// begin target := mc_crates [ i ] [ j ] ;
35919: LD_ADDR_VAR 0 7
35923: PUSH
35924: LD_EXP 94
35928: PUSH
35929: LD_VAR 0 2
35933: ARRAY
35934: PUSH
35935: LD_VAR 0 3
35939: ARRAY
35940: ST_TO_ADDR
// break ;
35941: GO 35945
// end ; end ;
35943: GO 35699
35945: POP
35946: POP
// if not target then
35947: LD_VAR 0 7
35951: NOT
35952: IFFALSE 35956
// continue ;
35954: GO 35506
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35956: LD_ADDR_VAR 0 8
35960: PUSH
35961: LD_EXP 97
35965: PUSH
35966: LD_VAR 0 2
35970: ARRAY
35971: PPUSH
35972: LD_INT 2
35974: PUSH
35975: LD_INT 3
35977: PUSH
35978: LD_INT 58
35980: PUSH
35981: EMPTY
35982: LIST
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 61
35990: PUSH
35991: EMPTY
35992: LIST
35993: PUSH
35994: LD_INT 33
35996: PUSH
35997: LD_INT 5
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: LD_INT 33
36006: PUSH
36007: LD_INT 3
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: LIST
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 2
36023: PUSH
36024: LD_INT 34
36026: PUSH
36027: LD_INT 32
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 34
36036: PUSH
36037: LD_INT 51
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 34
36046: PUSH
36047: LD_INT 12
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: LIST
36058: LIST
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PPUSH
36064: CALL_OW 72
36068: ST_TO_ADDR
// if not cargo then
36069: LD_VAR 0 8
36073: NOT
36074: IFFALSE 36780
// begin if mc_crates_collector [ i ] < 5 then
36076: LD_EXP 95
36080: PUSH
36081: LD_VAR 0 2
36085: ARRAY
36086: PUSH
36087: LD_INT 5
36089: LESS
36090: IFFALSE 36456
// begin if mc_ape [ i ] then
36092: LD_EXP 107
36096: PUSH
36097: LD_VAR 0 2
36101: ARRAY
36102: IFFALSE 36149
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
36104: LD_ADDR_VAR 0 5
36108: PUSH
36109: LD_EXP 107
36113: PUSH
36114: LD_VAR 0 2
36118: ARRAY
36119: PPUSH
36120: LD_INT 25
36122: PUSH
36123: LD_INT 16
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 24
36132: PUSH
36133: LD_INT 750
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PPUSH
36144: CALL_OW 72
36148: ST_TO_ADDR
// if not tmp then
36149: LD_VAR 0 5
36153: NOT
36154: IFFALSE 36201
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
36156: LD_ADDR_VAR 0 5
36160: PUSH
36161: LD_EXP 78
36165: PUSH
36166: LD_VAR 0 2
36170: ARRAY
36171: PPUSH
36172: LD_INT 25
36174: PUSH
36175: LD_INT 2
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 24
36184: PUSH
36185: LD_INT 750
36187: PUSH
36188: EMPTY
36189: LIST
36190: LIST
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PPUSH
36196: CALL_OW 72
36200: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
36201: LD_EXP 107
36205: PUSH
36206: LD_VAR 0 2
36210: ARRAY
36211: PUSH
36212: LD_EXP 78
36216: PUSH
36217: LD_VAR 0 2
36221: ARRAY
36222: PPUSH
36223: LD_INT 25
36225: PUSH
36226: LD_INT 2
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: LD_INT 24
36235: PUSH
36236: LD_INT 750
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PPUSH
36247: CALL_OW 72
36251: AND
36252: PUSH
36253: LD_VAR 0 5
36257: PUSH
36258: LD_INT 5
36260: LESS
36261: AND
36262: IFFALSE 36344
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
36264: LD_ADDR_VAR 0 3
36268: PUSH
36269: LD_EXP 78
36273: PUSH
36274: LD_VAR 0 2
36278: ARRAY
36279: PPUSH
36280: LD_INT 25
36282: PUSH
36283: LD_INT 2
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 24
36292: PUSH
36293: LD_INT 750
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PPUSH
36304: CALL_OW 72
36308: PUSH
36309: FOR_IN
36310: IFFALSE 36342
// begin tmp := tmp union j ;
36312: LD_ADDR_VAR 0 5
36316: PUSH
36317: LD_VAR 0 5
36321: PUSH
36322: LD_VAR 0 3
36326: UNION
36327: ST_TO_ADDR
// if tmp >= 5 then
36328: LD_VAR 0 5
36332: PUSH
36333: LD_INT 5
36335: GREATEREQUAL
36336: IFFALSE 36340
// break ;
36338: GO 36342
// end ;
36340: GO 36309
36342: POP
36343: POP
// end ; if not tmp then
36344: LD_VAR 0 5
36348: NOT
36349: IFFALSE 36353
// continue ;
36351: GO 35506
// for j in tmp do
36353: LD_ADDR_VAR 0 3
36357: PUSH
36358: LD_VAR 0 5
36362: PUSH
36363: FOR_IN
36364: IFFALSE 36454
// if not GetTag ( j ) then
36366: LD_VAR 0 3
36370: PPUSH
36371: CALL_OW 110
36375: NOT
36376: IFFALSE 36452
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
36378: LD_ADDR_EXP 95
36382: PUSH
36383: LD_EXP 95
36387: PPUSH
36388: LD_VAR 0 2
36392: PUSH
36393: LD_EXP 95
36397: PUSH
36398: LD_VAR 0 2
36402: ARRAY
36403: PUSH
36404: LD_INT 1
36406: PLUS
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PPUSH
36412: LD_VAR 0 3
36416: PPUSH
36417: CALL 57824 0 3
36421: ST_TO_ADDR
// SetTag ( j , 107 ) ;
36422: LD_VAR 0 3
36426: PPUSH
36427: LD_INT 107
36429: PPUSH
36430: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
36434: LD_EXP 95
36438: PUSH
36439: LD_VAR 0 2
36443: ARRAY
36444: PUSH
36445: LD_INT 5
36447: GREATEREQUAL
36448: IFFALSE 36452
// break ;
36450: GO 36454
// end ;
36452: GO 36363
36454: POP
36455: POP
// end ; if mc_crates_collector [ i ] and target then
36456: LD_EXP 95
36460: PUSH
36461: LD_VAR 0 2
36465: ARRAY
36466: PUSH
36467: LD_VAR 0 7
36471: AND
36472: IFFALSE 36778
// begin if mc_crates_collector [ i ] < target [ 1 ] then
36474: LD_EXP 95
36478: PUSH
36479: LD_VAR 0 2
36483: ARRAY
36484: PUSH
36485: LD_VAR 0 7
36489: PUSH
36490: LD_INT 1
36492: ARRAY
36493: LESS
36494: IFFALSE 36514
// tmp := mc_crates_collector [ i ] else
36496: LD_ADDR_VAR 0 5
36500: PUSH
36501: LD_EXP 95
36505: PUSH
36506: LD_VAR 0 2
36510: ARRAY
36511: ST_TO_ADDR
36512: GO 36528
// tmp := target [ 1 ] ;
36514: LD_ADDR_VAR 0 5
36518: PUSH
36519: LD_VAR 0 7
36523: PUSH
36524: LD_INT 1
36526: ARRAY
36527: ST_TO_ADDR
// k := 0 ;
36528: LD_ADDR_VAR 0 4
36532: PUSH
36533: LD_INT 0
36535: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
36536: LD_ADDR_VAR 0 3
36540: PUSH
36541: LD_EXP 95
36545: PUSH
36546: LD_VAR 0 2
36550: ARRAY
36551: PUSH
36552: FOR_IN
36553: IFFALSE 36776
// begin k := k + 1 ;
36555: LD_ADDR_VAR 0 4
36559: PUSH
36560: LD_VAR 0 4
36564: PUSH
36565: LD_INT 1
36567: PLUS
36568: ST_TO_ADDR
// if k > tmp then
36569: LD_VAR 0 4
36573: PUSH
36574: LD_VAR 0 5
36578: GREATER
36579: IFFALSE 36583
// break ;
36581: GO 36776
// if not GetClass ( j ) in [ 2 , 16 ] then
36583: LD_VAR 0 3
36587: PPUSH
36588: CALL_OW 257
36592: PUSH
36593: LD_INT 2
36595: PUSH
36596: LD_INT 16
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: IN
36603: NOT
36604: IFFALSE 36657
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
36606: LD_ADDR_EXP 95
36610: PUSH
36611: LD_EXP 95
36615: PPUSH
36616: LD_VAR 0 2
36620: PPUSH
36621: LD_EXP 95
36625: PUSH
36626: LD_VAR 0 2
36630: ARRAY
36631: PUSH
36632: LD_VAR 0 3
36636: DIFF
36637: PPUSH
36638: CALL_OW 1
36642: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36643: LD_VAR 0 3
36647: PPUSH
36648: LD_INT 0
36650: PPUSH
36651: CALL_OW 109
// continue ;
36655: GO 36552
// end ; if IsInUnit ( j ) then
36657: LD_VAR 0 3
36661: PPUSH
36662: CALL_OW 310
36666: IFFALSE 36677
// ComExitBuilding ( j ) ;
36668: LD_VAR 0 3
36672: PPUSH
36673: CALL_OW 122
// wait ( 3 ) ;
36677: LD_INT 3
36679: PPUSH
36680: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
36684: LD_VAR 0 3
36688: PPUSH
36689: CALL_OW 314
36693: PUSH
36694: LD_VAR 0 6
36698: PPUSH
36699: LD_VAR 0 7
36703: PUSH
36704: LD_INT 2
36706: ARRAY
36707: PPUSH
36708: LD_VAR 0 7
36712: PUSH
36713: LD_INT 3
36715: ARRAY
36716: PPUSH
36717: LD_INT 30
36719: PPUSH
36720: CALL 58720 0 4
36724: PUSH
36725: LD_INT 4
36727: ARRAY
36728: AND
36729: IFFALSE 36747
// ComStandNearbyBuilding ( j , depot ) else
36731: LD_VAR 0 3
36735: PPUSH
36736: LD_VAR 0 9
36740: PPUSH
36741: CALL 54426 0 2
36745: GO 36774
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36747: LD_VAR 0 3
36751: PPUSH
36752: LD_VAR 0 7
36756: PUSH
36757: LD_INT 2
36759: ARRAY
36760: PPUSH
36761: LD_VAR 0 7
36765: PUSH
36766: LD_INT 3
36768: ARRAY
36769: PPUSH
36770: CALL_OW 117
// end ;
36774: GO 36552
36776: POP
36777: POP
// end ; end else
36778: GO 37310
// begin for j in cargo do
36780: LD_ADDR_VAR 0 3
36784: PUSH
36785: LD_VAR 0 8
36789: PUSH
36790: FOR_IN
36791: IFFALSE 37308
// begin if GetTag ( j ) <> 0 then
36793: LD_VAR 0 3
36797: PPUSH
36798: CALL_OW 110
36802: PUSH
36803: LD_INT 0
36805: NONEQUAL
36806: IFFALSE 36810
// continue ;
36808: GO 36790
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
36810: LD_VAR 0 3
36814: PPUSH
36815: CALL_OW 256
36819: PUSH
36820: LD_INT 1000
36822: LESS
36823: PUSH
36824: LD_VAR 0 3
36828: PPUSH
36829: LD_EXP 102
36833: PUSH
36834: LD_VAR 0 2
36838: ARRAY
36839: PPUSH
36840: CALL_OW 308
36844: NOT
36845: AND
36846: IFFALSE 36868
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36848: LD_VAR 0 3
36852: PPUSH
36853: LD_EXP 102
36857: PUSH
36858: LD_VAR 0 2
36862: ARRAY
36863: PPUSH
36864: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36868: LD_VAR 0 3
36872: PPUSH
36873: CALL_OW 256
36877: PUSH
36878: LD_INT 1000
36880: LESS
36881: PUSH
36882: LD_VAR 0 3
36886: PPUSH
36887: LD_EXP 102
36891: PUSH
36892: LD_VAR 0 2
36896: ARRAY
36897: PPUSH
36898: CALL_OW 308
36902: AND
36903: IFFALSE 36907
// continue ;
36905: GO 36790
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36907: LD_VAR 0 3
36911: PPUSH
36912: CALL_OW 262
36916: PUSH
36917: LD_INT 2
36919: EQUAL
36920: PUSH
36921: LD_VAR 0 3
36925: PPUSH
36926: CALL_OW 261
36930: PUSH
36931: LD_INT 15
36933: LESS
36934: AND
36935: IFFALSE 36939
// continue ;
36937: GO 36790
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36939: LD_VAR 0 3
36943: PPUSH
36944: CALL_OW 262
36948: PUSH
36949: LD_INT 1
36951: EQUAL
36952: PUSH
36953: LD_VAR 0 3
36957: PPUSH
36958: CALL_OW 261
36962: PUSH
36963: LD_INT 10
36965: LESS
36966: AND
36967: IFFALSE 37247
// begin if not depot then
36969: LD_VAR 0 9
36973: NOT
36974: IFFALSE 36978
// continue ;
36976: GO 36790
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36978: LD_VAR 0 3
36982: PPUSH
36983: LD_VAR 0 9
36987: PPUSH
36988: LD_VAR 0 3
36992: PPUSH
36993: CALL_OW 74
36997: PPUSH
36998: CALL_OW 296
37002: PUSH
37003: LD_INT 6
37005: LESS
37006: IFFALSE 37022
// SetFuel ( j , 100 ) else
37008: LD_VAR 0 3
37012: PPUSH
37013: LD_INT 100
37015: PPUSH
37016: CALL_OW 240
37020: GO 37247
// if GetFuel ( j ) = 0 then
37022: LD_VAR 0 3
37026: PPUSH
37027: CALL_OW 261
37031: PUSH
37032: LD_INT 0
37034: EQUAL
37035: IFFALSE 37247
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
37037: LD_ADDR_EXP 97
37041: PUSH
37042: LD_EXP 97
37046: PPUSH
37047: LD_VAR 0 2
37051: PPUSH
37052: LD_EXP 97
37056: PUSH
37057: LD_VAR 0 2
37061: ARRAY
37062: PUSH
37063: LD_VAR 0 3
37067: DIFF
37068: PPUSH
37069: CALL_OW 1
37073: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
37074: LD_VAR 0 3
37078: PPUSH
37079: CALL_OW 263
37083: PUSH
37084: LD_INT 1
37086: EQUAL
37087: IFFALSE 37103
// ComExitVehicle ( IsInUnit ( j ) ) ;
37089: LD_VAR 0 3
37093: PPUSH
37094: CALL_OW 310
37098: PPUSH
37099: CALL_OW 121
// if GetControl ( j ) = control_remote then
37103: LD_VAR 0 3
37107: PPUSH
37108: CALL_OW 263
37112: PUSH
37113: LD_INT 2
37115: EQUAL
37116: IFFALSE 37127
// ComUnlink ( j ) ;
37118: LD_VAR 0 3
37122: PPUSH
37123: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
37127: LD_ADDR_VAR 0 10
37131: PUSH
37132: LD_VAR 0 2
37136: PPUSH
37137: LD_INT 3
37139: PPUSH
37140: CALL 46891 0 2
37144: ST_TO_ADDR
// if fac then
37145: LD_VAR 0 10
37149: IFFALSE 37245
// begin for k in fac do
37151: LD_ADDR_VAR 0 4
37155: PUSH
37156: LD_VAR 0 10
37160: PUSH
37161: FOR_IN
37162: IFFALSE 37243
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
37164: LD_ADDR_VAR 0 11
37168: PUSH
37169: LD_VAR 0 10
37173: PPUSH
37174: LD_VAR 0 3
37178: PPUSH
37179: CALL_OW 265
37183: PPUSH
37184: LD_VAR 0 3
37188: PPUSH
37189: CALL_OW 262
37193: PPUSH
37194: LD_VAR 0 3
37198: PPUSH
37199: CALL_OW 263
37203: PPUSH
37204: LD_VAR 0 3
37208: PPUSH
37209: CALL_OW 264
37213: PPUSH
37214: CALL 55322 0 5
37218: ST_TO_ADDR
// if components then
37219: LD_VAR 0 11
37223: IFFALSE 37241
// begin MC_InsertProduceList ( i , components ) ;
37225: LD_VAR 0 2
37229: PPUSH
37230: LD_VAR 0 11
37234: PPUSH
37235: CALL 46436 0 2
// break ;
37239: GO 37243
// end ; end ;
37241: GO 37161
37243: POP
37244: POP
// end ; continue ;
37245: GO 36790
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
37247: LD_VAR 0 3
37251: PPUSH
37252: LD_INT 1
37254: PPUSH
37255: CALL_OW 289
37259: PUSH
37260: LD_INT 100
37262: LESS
37263: PUSH
37264: LD_VAR 0 3
37268: PPUSH
37269: CALL_OW 314
37273: NOT
37274: AND
37275: IFFALSE 37304
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37277: LD_VAR 0 3
37281: PPUSH
37282: LD_VAR 0 7
37286: PUSH
37287: LD_INT 2
37289: ARRAY
37290: PPUSH
37291: LD_VAR 0 7
37295: PUSH
37296: LD_INT 3
37298: ARRAY
37299: PPUSH
37300: CALL_OW 117
// break ;
37304: GO 37308
// end ;
37306: GO 36790
37308: POP
37309: POP
// end ; end ;
37310: GO 35506
37312: POP
37313: POP
// end ;
37314: LD_VAR 0 1
37318: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
37319: LD_INT 0
37321: PPUSH
37322: PPUSH
37323: PPUSH
37324: PPUSH
// if not mc_bases then
37325: LD_EXP 78
37329: NOT
37330: IFFALSE 37334
// exit ;
37332: GO 37495
// for i = 1 to mc_bases do
37334: LD_ADDR_VAR 0 2
37338: PUSH
37339: DOUBLE
37340: LD_INT 1
37342: DEC
37343: ST_TO_ADDR
37344: LD_EXP 78
37348: PUSH
37349: FOR_TO
37350: IFFALSE 37493
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
37352: LD_ADDR_VAR 0 4
37356: PUSH
37357: LD_EXP 97
37361: PUSH
37362: LD_VAR 0 2
37366: ARRAY
37367: PUSH
37368: LD_EXP 100
37372: PUSH
37373: LD_VAR 0 2
37377: ARRAY
37378: UNION
37379: PPUSH
37380: LD_INT 33
37382: PUSH
37383: LD_INT 2
37385: PUSH
37386: EMPTY
37387: LIST
37388: LIST
37389: PPUSH
37390: CALL_OW 72
37394: ST_TO_ADDR
// if tmp then
37395: LD_VAR 0 4
37399: IFFALSE 37491
// for j in tmp do
37401: LD_ADDR_VAR 0 3
37405: PUSH
37406: LD_VAR 0 4
37410: PUSH
37411: FOR_IN
37412: IFFALSE 37489
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
37414: LD_VAR 0 3
37418: PPUSH
37419: CALL_OW 312
37423: NOT
37424: PUSH
37425: LD_VAR 0 3
37429: PPUSH
37430: CALL_OW 256
37434: PUSH
37435: LD_INT 250
37437: GREATEREQUAL
37438: AND
37439: IFFALSE 37452
// Connect ( j ) else
37441: LD_VAR 0 3
37445: PPUSH
37446: CALL 60802 0 1
37450: GO 37487
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
37452: LD_VAR 0 3
37456: PPUSH
37457: CALL_OW 256
37461: PUSH
37462: LD_INT 250
37464: LESS
37465: PUSH
37466: LD_VAR 0 3
37470: PPUSH
37471: CALL_OW 312
37475: AND
37476: IFFALSE 37487
// ComUnlink ( j ) ;
37478: LD_VAR 0 3
37482: PPUSH
37483: CALL_OW 136
37487: GO 37411
37489: POP
37490: POP
// end ;
37491: GO 37349
37493: POP
37494: POP
// end ;
37495: LD_VAR 0 1
37499: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
37500: LD_INT 0
37502: PPUSH
37503: PPUSH
37504: PPUSH
37505: PPUSH
37506: PPUSH
// if not mc_bases then
37507: LD_EXP 78
37511: NOT
37512: IFFALSE 37516
// exit ;
37514: GO 37961
// for i = 1 to mc_bases do
37516: LD_ADDR_VAR 0 2
37520: PUSH
37521: DOUBLE
37522: LD_INT 1
37524: DEC
37525: ST_TO_ADDR
37526: LD_EXP 78
37530: PUSH
37531: FOR_TO
37532: IFFALSE 37959
// begin if not mc_produce [ i ] then
37534: LD_EXP 99
37538: PUSH
37539: LD_VAR 0 2
37543: ARRAY
37544: NOT
37545: IFFALSE 37549
// continue ;
37547: GO 37531
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37549: LD_ADDR_VAR 0 5
37553: PUSH
37554: LD_EXP 78
37558: PUSH
37559: LD_VAR 0 2
37563: ARRAY
37564: PPUSH
37565: LD_INT 30
37567: PUSH
37568: LD_INT 3
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PPUSH
37575: CALL_OW 72
37579: ST_TO_ADDR
// if not fac then
37580: LD_VAR 0 5
37584: NOT
37585: IFFALSE 37589
// continue ;
37587: GO 37531
// for j in fac do
37589: LD_ADDR_VAR 0 3
37593: PUSH
37594: LD_VAR 0 5
37598: PUSH
37599: FOR_IN
37600: IFFALSE 37955
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
37602: LD_VAR 0 3
37606: PPUSH
37607: CALL_OW 461
37611: PUSH
37612: LD_INT 2
37614: NONEQUAL
37615: PUSH
37616: LD_VAR 0 3
37620: PPUSH
37621: LD_INT 15
37623: PPUSH
37624: CALL 60421 0 2
37628: PUSH
37629: LD_INT 4
37631: ARRAY
37632: OR
37633: IFFALSE 37637
// continue ;
37635: GO 37599
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
37637: LD_VAR 0 3
37641: PPUSH
37642: LD_EXP 99
37646: PUSH
37647: LD_VAR 0 2
37651: ARRAY
37652: PUSH
37653: LD_INT 1
37655: ARRAY
37656: PUSH
37657: LD_INT 1
37659: ARRAY
37660: PPUSH
37661: LD_EXP 99
37665: PUSH
37666: LD_VAR 0 2
37670: ARRAY
37671: PUSH
37672: LD_INT 1
37674: ARRAY
37675: PUSH
37676: LD_INT 2
37678: ARRAY
37679: PPUSH
37680: LD_EXP 99
37684: PUSH
37685: LD_VAR 0 2
37689: ARRAY
37690: PUSH
37691: LD_INT 1
37693: ARRAY
37694: PUSH
37695: LD_INT 3
37697: ARRAY
37698: PPUSH
37699: LD_EXP 99
37703: PUSH
37704: LD_VAR 0 2
37708: ARRAY
37709: PUSH
37710: LD_INT 1
37712: ARRAY
37713: PUSH
37714: LD_INT 4
37716: ARRAY
37717: PPUSH
37718: CALL_OW 448
37722: PUSH
37723: LD_VAR 0 3
37727: PPUSH
37728: LD_EXP 99
37732: PUSH
37733: LD_VAR 0 2
37737: ARRAY
37738: PUSH
37739: LD_INT 1
37741: ARRAY
37742: PUSH
37743: LD_INT 1
37745: ARRAY
37746: PUSH
37747: LD_EXP 99
37751: PUSH
37752: LD_VAR 0 2
37756: ARRAY
37757: PUSH
37758: LD_INT 1
37760: ARRAY
37761: PUSH
37762: LD_INT 2
37764: ARRAY
37765: PUSH
37766: LD_EXP 99
37770: PUSH
37771: LD_VAR 0 2
37775: ARRAY
37776: PUSH
37777: LD_INT 1
37779: ARRAY
37780: PUSH
37781: LD_INT 3
37783: ARRAY
37784: PUSH
37785: LD_EXP 99
37789: PUSH
37790: LD_VAR 0 2
37794: ARRAY
37795: PUSH
37796: LD_INT 1
37798: ARRAY
37799: PUSH
37800: LD_INT 4
37802: ARRAY
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: PPUSH
37810: CALL 64197 0 2
37814: AND
37815: IFFALSE 37953
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
37817: LD_VAR 0 3
37821: PPUSH
37822: LD_EXP 99
37826: PUSH
37827: LD_VAR 0 2
37831: ARRAY
37832: PUSH
37833: LD_INT 1
37835: ARRAY
37836: PUSH
37837: LD_INT 1
37839: ARRAY
37840: PPUSH
37841: LD_EXP 99
37845: PUSH
37846: LD_VAR 0 2
37850: ARRAY
37851: PUSH
37852: LD_INT 1
37854: ARRAY
37855: PUSH
37856: LD_INT 2
37858: ARRAY
37859: PPUSH
37860: LD_EXP 99
37864: PUSH
37865: LD_VAR 0 2
37869: ARRAY
37870: PUSH
37871: LD_INT 1
37873: ARRAY
37874: PUSH
37875: LD_INT 3
37877: ARRAY
37878: PPUSH
37879: LD_EXP 99
37883: PUSH
37884: LD_VAR 0 2
37888: ARRAY
37889: PUSH
37890: LD_INT 1
37892: ARRAY
37893: PUSH
37894: LD_INT 4
37896: ARRAY
37897: PPUSH
37898: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37902: LD_ADDR_VAR 0 4
37906: PUSH
37907: LD_EXP 99
37911: PUSH
37912: LD_VAR 0 2
37916: ARRAY
37917: PPUSH
37918: LD_INT 1
37920: PPUSH
37921: CALL_OW 3
37925: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37926: LD_ADDR_EXP 99
37930: PUSH
37931: LD_EXP 99
37935: PPUSH
37936: LD_VAR 0 2
37940: PPUSH
37941: LD_VAR 0 4
37945: PPUSH
37946: CALL_OW 1
37950: ST_TO_ADDR
// break ;
37951: GO 37955
// end ; end ;
37953: GO 37599
37955: POP
37956: POP
// end ;
37957: GO 37531
37959: POP
37960: POP
// end ;
37961: LD_VAR 0 1
37965: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37966: LD_INT 0
37968: PPUSH
37969: PPUSH
37970: PPUSH
// if not mc_bases then
37971: LD_EXP 78
37975: NOT
37976: IFFALSE 37980
// exit ;
37978: GO 38069
// for i = 1 to mc_bases do
37980: LD_ADDR_VAR 0 2
37984: PUSH
37985: DOUBLE
37986: LD_INT 1
37988: DEC
37989: ST_TO_ADDR
37990: LD_EXP 78
37994: PUSH
37995: FOR_TO
37996: IFFALSE 38067
// begin if mc_attack [ i ] then
37998: LD_EXP 98
38002: PUSH
38003: LD_VAR 0 2
38007: ARRAY
38008: IFFALSE 38065
// begin tmp := mc_attack [ i ] [ 1 ] ;
38010: LD_ADDR_VAR 0 3
38014: PUSH
38015: LD_EXP 98
38019: PUSH
38020: LD_VAR 0 2
38024: ARRAY
38025: PUSH
38026: LD_INT 1
38028: ARRAY
38029: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38030: LD_ADDR_EXP 98
38034: PUSH
38035: LD_EXP 98
38039: PPUSH
38040: LD_VAR 0 2
38044: PPUSH
38045: EMPTY
38046: PPUSH
38047: CALL_OW 1
38051: ST_TO_ADDR
// Attack ( tmp ) ;
38052: LD_VAR 0 3
38056: PPUSH
38057: CALL 114496 0 1
// exit ;
38061: POP
38062: POP
38063: GO 38069
// end ; end ;
38065: GO 37995
38067: POP
38068: POP
// end ;
38069: LD_VAR 0 1
38073: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
38074: LD_INT 0
38076: PPUSH
38077: PPUSH
38078: PPUSH
38079: PPUSH
38080: PPUSH
38081: PPUSH
38082: PPUSH
// if not mc_bases then
38083: LD_EXP 78
38087: NOT
38088: IFFALSE 38092
// exit ;
38090: GO 38949
// for i = 1 to mc_bases do
38092: LD_ADDR_VAR 0 2
38096: PUSH
38097: DOUBLE
38098: LD_INT 1
38100: DEC
38101: ST_TO_ADDR
38102: LD_EXP 78
38106: PUSH
38107: FOR_TO
38108: IFFALSE 38947
// begin if not mc_bases [ i ] then
38110: LD_EXP 78
38114: PUSH
38115: LD_VAR 0 2
38119: ARRAY
38120: NOT
38121: IFFALSE 38125
// continue ;
38123: GO 38107
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
38125: LD_ADDR_VAR 0 7
38129: PUSH
38130: LD_EXP 78
38134: PUSH
38135: LD_VAR 0 2
38139: ARRAY
38140: PUSH
38141: LD_INT 1
38143: ARRAY
38144: PPUSH
38145: CALL 54648 0 1
38149: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
38150: LD_ADDR_EXP 101
38154: PUSH
38155: LD_EXP 101
38159: PPUSH
38160: LD_VAR 0 2
38164: PPUSH
38165: LD_EXP 78
38169: PUSH
38170: LD_VAR 0 2
38174: ARRAY
38175: PUSH
38176: LD_INT 1
38178: ARRAY
38179: PPUSH
38180: CALL_OW 255
38184: PPUSH
38185: LD_EXP 103
38189: PUSH
38190: LD_VAR 0 2
38194: ARRAY
38195: PPUSH
38196: CALL 54613 0 2
38200: PPUSH
38201: CALL_OW 1
38205: ST_TO_ADDR
// if not mc_scan [ i ] then
38206: LD_EXP 101
38210: PUSH
38211: LD_VAR 0 2
38215: ARRAY
38216: NOT
38217: IFFALSE 38395
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38219: LD_ADDR_EXP 121
38223: PUSH
38224: LD_EXP 121
38228: PPUSH
38229: LD_VAR 0 2
38233: PPUSH
38234: LD_INT 0
38236: PPUSH
38237: CALL_OW 1
38241: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38242: LD_ADDR_VAR 0 4
38246: PUSH
38247: LD_EXP 78
38251: PUSH
38252: LD_VAR 0 2
38256: ARRAY
38257: PPUSH
38258: LD_INT 2
38260: PUSH
38261: LD_INT 25
38263: PUSH
38264: LD_INT 5
38266: PUSH
38267: EMPTY
38268: LIST
38269: LIST
38270: PUSH
38271: LD_INT 25
38273: PUSH
38274: LD_INT 8
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PUSH
38281: LD_INT 25
38283: PUSH
38284: LD_INT 9
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: LIST
38295: LIST
38296: PPUSH
38297: CALL_OW 72
38301: ST_TO_ADDR
// if not tmp then
38302: LD_VAR 0 4
38306: NOT
38307: IFFALSE 38311
// continue ;
38309: GO 38107
// for j in tmp do
38311: LD_ADDR_VAR 0 3
38315: PUSH
38316: LD_VAR 0 4
38320: PUSH
38321: FOR_IN
38322: IFFALSE 38393
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
38324: LD_VAR 0 3
38328: PPUSH
38329: CALL_OW 310
38333: PPUSH
38334: CALL_OW 266
38338: PUSH
38339: LD_INT 5
38341: EQUAL
38342: PUSH
38343: LD_VAR 0 3
38347: PPUSH
38348: CALL_OW 257
38352: PUSH
38353: LD_INT 1
38355: EQUAL
38356: AND
38357: PUSH
38358: LD_VAR 0 3
38362: PPUSH
38363: CALL_OW 459
38367: NOT
38368: AND
38369: PUSH
38370: LD_VAR 0 7
38374: AND
38375: IFFALSE 38391
// ComChangeProfession ( j , class ) ;
38377: LD_VAR 0 3
38381: PPUSH
38382: LD_VAR 0 7
38386: PPUSH
38387: CALL_OW 123
38391: GO 38321
38393: POP
38394: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
38395: LD_EXP 101
38399: PUSH
38400: LD_VAR 0 2
38404: ARRAY
38405: PUSH
38406: LD_EXP 121
38410: PUSH
38411: LD_VAR 0 2
38415: ARRAY
38416: NOT
38417: AND
38418: PUSH
38419: LD_EXP 100
38423: PUSH
38424: LD_VAR 0 2
38428: ARRAY
38429: NOT
38430: AND
38431: PUSH
38432: LD_EXP 78
38436: PUSH
38437: LD_VAR 0 2
38441: ARRAY
38442: PPUSH
38443: LD_INT 50
38445: PUSH
38446: EMPTY
38447: LIST
38448: PUSH
38449: LD_INT 2
38451: PUSH
38452: LD_INT 30
38454: PUSH
38455: LD_INT 32
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 30
38464: PUSH
38465: LD_INT 33
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 30
38474: PUSH
38475: LD_INT 4
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 30
38484: PUSH
38485: LD_INT 5
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: LIST
38496: LIST
38497: LIST
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PPUSH
38503: CALL_OW 72
38507: PUSH
38508: LD_INT 4
38510: LESS
38511: PUSH
38512: LD_EXP 78
38516: PUSH
38517: LD_VAR 0 2
38521: ARRAY
38522: PPUSH
38523: LD_INT 3
38525: PUSH
38526: LD_INT 24
38528: PUSH
38529: LD_INT 1000
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 2
38542: PUSH
38543: LD_INT 30
38545: PUSH
38546: LD_INT 0
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 30
38555: PUSH
38556: LD_INT 1
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: LIST
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PPUSH
38572: CALL_OW 72
38576: OR
38577: AND
38578: IFFALSE 38829
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38580: LD_ADDR_EXP 121
38584: PUSH
38585: LD_EXP 121
38589: PPUSH
38590: LD_VAR 0 2
38594: PPUSH
38595: LD_INT 1
38597: PPUSH
38598: CALL_OW 1
38602: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38603: LD_ADDR_VAR 0 4
38607: PUSH
38608: LD_EXP 78
38612: PUSH
38613: LD_VAR 0 2
38617: ARRAY
38618: PPUSH
38619: LD_INT 2
38621: PUSH
38622: LD_INT 25
38624: PUSH
38625: LD_INT 1
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 25
38634: PUSH
38635: LD_INT 5
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: LD_INT 25
38644: PUSH
38645: LD_INT 8
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 25
38654: PUSH
38655: LD_INT 9
38657: PUSH
38658: EMPTY
38659: LIST
38660: LIST
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: LIST
38666: LIST
38667: LIST
38668: PPUSH
38669: CALL_OW 72
38673: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
38674: LD_ADDR_VAR 0 4
38678: PUSH
38679: LD_VAR 0 4
38683: PUSH
38684: LD_VAR 0 4
38688: PPUSH
38689: LD_INT 18
38691: PPUSH
38692: CALL 87765 0 2
38696: DIFF
38697: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
38698: LD_VAR 0 4
38702: NOT
38703: PUSH
38704: LD_EXP 78
38708: PUSH
38709: LD_VAR 0 2
38713: ARRAY
38714: PPUSH
38715: LD_INT 2
38717: PUSH
38718: LD_INT 30
38720: PUSH
38721: LD_INT 4
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PUSH
38728: LD_INT 30
38730: PUSH
38731: LD_INT 5
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: LIST
38742: PPUSH
38743: CALL_OW 72
38747: NOT
38748: AND
38749: IFFALSE 38811
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
38751: LD_ADDR_VAR 0 4
38755: PUSH
38756: LD_EXP 78
38760: PUSH
38761: LD_VAR 0 2
38765: ARRAY
38766: PPUSH
38767: LD_INT 2
38769: PUSH
38770: LD_INT 25
38772: PUSH
38773: LD_INT 2
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: LD_INT 25
38782: PUSH
38783: LD_INT 3
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: LD_INT 25
38792: PUSH
38793: LD_INT 4
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: LIST
38804: LIST
38805: PPUSH
38806: CALL_OW 72
38810: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
38811: LD_VAR 0 2
38815: PPUSH
38816: LD_VAR 0 4
38820: PPUSH
38821: CALL 119205 0 2
// exit ;
38825: POP
38826: POP
38827: GO 38949
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38829: LD_EXP 101
38833: PUSH
38834: LD_VAR 0 2
38838: ARRAY
38839: PUSH
38840: LD_EXP 121
38844: PUSH
38845: LD_VAR 0 2
38849: ARRAY
38850: NOT
38851: AND
38852: PUSH
38853: LD_EXP 100
38857: PUSH
38858: LD_VAR 0 2
38862: ARRAY
38863: AND
38864: IFFALSE 38945
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38866: LD_ADDR_EXP 121
38870: PUSH
38871: LD_EXP 121
38875: PPUSH
38876: LD_VAR 0 2
38880: PPUSH
38881: LD_INT 1
38883: PPUSH
38884: CALL_OW 1
38888: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38889: LD_ADDR_VAR 0 4
38893: PUSH
38894: LD_EXP 100
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38905: LD_ADDR_EXP 100
38909: PUSH
38910: LD_EXP 100
38914: PPUSH
38915: LD_VAR 0 2
38919: PPUSH
38920: EMPTY
38921: PPUSH
38922: CALL_OW 1
38926: ST_TO_ADDR
// Defend ( i , tmp ) ;
38927: LD_VAR 0 2
38931: PPUSH
38932: LD_VAR 0 4
38936: PPUSH
38937: CALL 119801 0 2
// exit ;
38941: POP
38942: POP
38943: GO 38949
// end ; end ;
38945: GO 38107
38947: POP
38948: POP
// end ;
38949: LD_VAR 0 1
38953: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38954: LD_INT 0
38956: PPUSH
38957: PPUSH
38958: PPUSH
38959: PPUSH
38960: PPUSH
38961: PPUSH
38962: PPUSH
38963: PPUSH
38964: PPUSH
38965: PPUSH
38966: PPUSH
// if not mc_bases then
38967: LD_EXP 78
38971: NOT
38972: IFFALSE 38976
// exit ;
38974: GO 40063
// for i = 1 to mc_bases do
38976: LD_ADDR_VAR 0 2
38980: PUSH
38981: DOUBLE
38982: LD_INT 1
38984: DEC
38985: ST_TO_ADDR
38986: LD_EXP 78
38990: PUSH
38991: FOR_TO
38992: IFFALSE 40061
// begin tmp := mc_lab [ i ] ;
38994: LD_ADDR_VAR 0 6
38998: PUSH
38999: LD_EXP 111
39003: PUSH
39004: LD_VAR 0 2
39008: ARRAY
39009: ST_TO_ADDR
// if not tmp then
39010: LD_VAR 0 6
39014: NOT
39015: IFFALSE 39019
// continue ;
39017: GO 38991
// idle_lab := 0 ;
39019: LD_ADDR_VAR 0 11
39023: PUSH
39024: LD_INT 0
39026: ST_TO_ADDR
// for j in tmp do
39027: LD_ADDR_VAR 0 3
39031: PUSH
39032: LD_VAR 0 6
39036: PUSH
39037: FOR_IN
39038: IFFALSE 40057
// begin researching := false ;
39040: LD_ADDR_VAR 0 10
39044: PUSH
39045: LD_INT 0
39047: ST_TO_ADDR
// side := GetSide ( j ) ;
39048: LD_ADDR_VAR 0 4
39052: PUSH
39053: LD_VAR 0 3
39057: PPUSH
39058: CALL_OW 255
39062: ST_TO_ADDR
// if not mc_tech [ side ] then
39063: LD_EXP 105
39067: PUSH
39068: LD_VAR 0 4
39072: ARRAY
39073: NOT
39074: IFFALSE 39078
// continue ;
39076: GO 39037
// if BuildingStatus ( j ) = bs_idle then
39078: LD_VAR 0 3
39082: PPUSH
39083: CALL_OW 461
39087: PUSH
39088: LD_INT 2
39090: EQUAL
39091: IFFALSE 39279
// begin if idle_lab and UnitsInside ( j ) < 6 then
39093: LD_VAR 0 11
39097: PUSH
39098: LD_VAR 0 3
39102: PPUSH
39103: CALL_OW 313
39107: PUSH
39108: LD_INT 6
39110: LESS
39111: AND
39112: IFFALSE 39183
// begin tmp2 := UnitsInside ( idle_lab ) ;
39114: LD_ADDR_VAR 0 9
39118: PUSH
39119: LD_VAR 0 11
39123: PPUSH
39124: CALL_OW 313
39128: ST_TO_ADDR
// if tmp2 then
39129: LD_VAR 0 9
39133: IFFALSE 39175
// for x in tmp2 do
39135: LD_ADDR_VAR 0 7
39139: PUSH
39140: LD_VAR 0 9
39144: PUSH
39145: FOR_IN
39146: IFFALSE 39173
// begin ComExitBuilding ( x ) ;
39148: LD_VAR 0 7
39152: PPUSH
39153: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39157: LD_VAR 0 7
39161: PPUSH
39162: LD_VAR 0 3
39166: PPUSH
39167: CALL_OW 180
// end ;
39171: GO 39145
39173: POP
39174: POP
// idle_lab := 0 ;
39175: LD_ADDR_VAR 0 11
39179: PUSH
39180: LD_INT 0
39182: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
39183: LD_ADDR_VAR 0 5
39187: PUSH
39188: LD_EXP 105
39192: PUSH
39193: LD_VAR 0 4
39197: ARRAY
39198: PUSH
39199: FOR_IN
39200: IFFALSE 39260
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
39202: LD_VAR 0 3
39206: PPUSH
39207: LD_VAR 0 5
39211: PPUSH
39212: CALL_OW 430
39216: PUSH
39217: LD_VAR 0 4
39221: PPUSH
39222: LD_VAR 0 5
39226: PPUSH
39227: CALL 53718 0 2
39231: AND
39232: IFFALSE 39258
// begin researching := true ;
39234: LD_ADDR_VAR 0 10
39238: PUSH
39239: LD_INT 1
39241: ST_TO_ADDR
// ComResearch ( j , t ) ;
39242: LD_VAR 0 3
39246: PPUSH
39247: LD_VAR 0 5
39251: PPUSH
39252: CALL_OW 124
// break ;
39256: GO 39260
// end ;
39258: GO 39199
39260: POP
39261: POP
// if not researching then
39262: LD_VAR 0 10
39266: NOT
39267: IFFALSE 39279
// idle_lab := j ;
39269: LD_ADDR_VAR 0 11
39273: PUSH
39274: LD_VAR 0 3
39278: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
39279: LD_VAR 0 3
39283: PPUSH
39284: CALL_OW 461
39288: PUSH
39289: LD_INT 10
39291: EQUAL
39292: IFFALSE 39880
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
39294: LD_EXP 107
39298: PUSH
39299: LD_VAR 0 2
39303: ARRAY
39304: NOT
39305: PUSH
39306: LD_EXP 108
39310: PUSH
39311: LD_VAR 0 2
39315: ARRAY
39316: NOT
39317: AND
39318: PUSH
39319: LD_EXP 105
39323: PUSH
39324: LD_VAR 0 4
39328: ARRAY
39329: PUSH
39330: LD_INT 1
39332: GREATER
39333: AND
39334: IFFALSE 39465
// begin ComCancel ( j ) ;
39336: LD_VAR 0 3
39340: PPUSH
39341: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
39345: LD_ADDR_EXP 105
39349: PUSH
39350: LD_EXP 105
39354: PPUSH
39355: LD_VAR 0 4
39359: PPUSH
39360: LD_EXP 105
39364: PUSH
39365: LD_VAR 0 4
39369: ARRAY
39370: PPUSH
39371: LD_EXP 105
39375: PUSH
39376: LD_VAR 0 4
39380: ARRAY
39381: PUSH
39382: LD_INT 1
39384: MINUS
39385: PPUSH
39386: LD_EXP 105
39390: PUSH
39391: LD_VAR 0 4
39395: ARRAY
39396: PPUSH
39397: LD_INT 0
39399: PPUSH
39400: CALL 57242 0 4
39404: PPUSH
39405: CALL_OW 1
39409: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
39410: LD_ADDR_EXP 105
39414: PUSH
39415: LD_EXP 105
39419: PPUSH
39420: LD_VAR 0 4
39424: PPUSH
39425: LD_EXP 105
39429: PUSH
39430: LD_VAR 0 4
39434: ARRAY
39435: PPUSH
39436: LD_EXP 105
39440: PUSH
39441: LD_VAR 0 4
39445: ARRAY
39446: PPUSH
39447: LD_INT 1
39449: PPUSH
39450: LD_INT 0
39452: PPUSH
39453: CALL 57242 0 4
39457: PPUSH
39458: CALL_OW 1
39462: ST_TO_ADDR
// continue ;
39463: GO 39037
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
39465: LD_EXP 107
39469: PUSH
39470: LD_VAR 0 2
39474: ARRAY
39475: PUSH
39476: LD_EXP 108
39480: PUSH
39481: LD_VAR 0 2
39485: ARRAY
39486: NOT
39487: AND
39488: IFFALSE 39615
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
39490: LD_ADDR_EXP 108
39494: PUSH
39495: LD_EXP 108
39499: PPUSH
39500: LD_VAR 0 2
39504: PUSH
39505: LD_EXP 108
39509: PUSH
39510: LD_VAR 0 2
39514: ARRAY
39515: PUSH
39516: LD_INT 1
39518: PLUS
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PPUSH
39524: LD_EXP 107
39528: PUSH
39529: LD_VAR 0 2
39533: ARRAY
39534: PUSH
39535: LD_INT 1
39537: ARRAY
39538: PPUSH
39539: CALL 57824 0 3
39543: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
39544: LD_EXP 107
39548: PUSH
39549: LD_VAR 0 2
39553: ARRAY
39554: PUSH
39555: LD_INT 1
39557: ARRAY
39558: PPUSH
39559: LD_INT 112
39561: PPUSH
39562: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
39566: LD_ADDR_VAR 0 9
39570: PUSH
39571: LD_EXP 107
39575: PUSH
39576: LD_VAR 0 2
39580: ARRAY
39581: PPUSH
39582: LD_INT 1
39584: PPUSH
39585: CALL_OW 3
39589: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
39590: LD_ADDR_EXP 107
39594: PUSH
39595: LD_EXP 107
39599: PPUSH
39600: LD_VAR 0 2
39604: PPUSH
39605: LD_VAR 0 9
39609: PPUSH
39610: CALL_OW 1
39614: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
39615: LD_EXP 107
39619: PUSH
39620: LD_VAR 0 2
39624: ARRAY
39625: PUSH
39626: LD_EXP 108
39630: PUSH
39631: LD_VAR 0 2
39635: ARRAY
39636: AND
39637: PUSH
39638: LD_EXP 108
39642: PUSH
39643: LD_VAR 0 2
39647: ARRAY
39648: PUSH
39649: LD_INT 1
39651: ARRAY
39652: PPUSH
39653: CALL_OW 310
39657: NOT
39658: AND
39659: PUSH
39660: LD_VAR 0 3
39664: PPUSH
39665: CALL_OW 313
39669: PUSH
39670: LD_INT 6
39672: EQUAL
39673: AND
39674: IFFALSE 39730
// begin tmp2 := UnitsInside ( j ) ;
39676: LD_ADDR_VAR 0 9
39680: PUSH
39681: LD_VAR 0 3
39685: PPUSH
39686: CALL_OW 313
39690: ST_TO_ADDR
// if tmp2 = 6 then
39691: LD_VAR 0 9
39695: PUSH
39696: LD_INT 6
39698: EQUAL
39699: IFFALSE 39730
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
39701: LD_VAR 0 9
39705: PUSH
39706: LD_INT 1
39708: ARRAY
39709: PPUSH
39710: LD_INT 112
39712: PPUSH
39713: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
39717: LD_VAR 0 9
39721: PUSH
39722: LD_INT 1
39724: ARRAY
39725: PPUSH
39726: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
39730: LD_EXP 108
39734: PUSH
39735: LD_VAR 0 2
39739: ARRAY
39740: PUSH
39741: LD_EXP 108
39745: PUSH
39746: LD_VAR 0 2
39750: ARRAY
39751: PUSH
39752: LD_INT 1
39754: ARRAY
39755: PPUSH
39756: CALL_OW 314
39760: NOT
39761: AND
39762: PUSH
39763: LD_EXP 108
39767: PUSH
39768: LD_VAR 0 2
39772: ARRAY
39773: PUSH
39774: LD_INT 1
39776: ARRAY
39777: PPUSH
39778: CALL_OW 310
39782: NOT
39783: AND
39784: IFFALSE 39810
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
39786: LD_EXP 108
39790: PUSH
39791: LD_VAR 0 2
39795: ARRAY
39796: PUSH
39797: LD_INT 1
39799: ARRAY
39800: PPUSH
39801: LD_VAR 0 3
39805: PPUSH
39806: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
39810: LD_EXP 108
39814: PUSH
39815: LD_VAR 0 2
39819: ARRAY
39820: PUSH
39821: LD_INT 1
39823: ARRAY
39824: PPUSH
39825: CALL_OW 310
39829: PUSH
39830: LD_EXP 108
39834: PUSH
39835: LD_VAR 0 2
39839: ARRAY
39840: PUSH
39841: LD_INT 1
39843: ARRAY
39844: PPUSH
39845: CALL_OW 310
39849: PPUSH
39850: CALL_OW 461
39854: PUSH
39855: LD_INT 3
39857: NONEQUAL
39858: AND
39859: IFFALSE 39880
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39861: LD_EXP 108
39865: PUSH
39866: LD_VAR 0 2
39870: ARRAY
39871: PUSH
39872: LD_INT 1
39874: ARRAY
39875: PPUSH
39876: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39880: LD_VAR 0 3
39884: PPUSH
39885: CALL_OW 461
39889: PUSH
39890: LD_INT 6
39892: EQUAL
39893: PUSH
39894: LD_VAR 0 6
39898: PUSH
39899: LD_INT 1
39901: GREATER
39902: AND
39903: IFFALSE 40055
// begin sci := [ ] ;
39905: LD_ADDR_VAR 0 8
39909: PUSH
39910: EMPTY
39911: ST_TO_ADDR
// for x in ( tmp diff j ) do
39912: LD_ADDR_VAR 0 7
39916: PUSH
39917: LD_VAR 0 6
39921: PUSH
39922: LD_VAR 0 3
39926: DIFF
39927: PUSH
39928: FOR_IN
39929: IFFALSE 39981
// begin if sci = 6 then
39931: LD_VAR 0 8
39935: PUSH
39936: LD_INT 6
39938: EQUAL
39939: IFFALSE 39943
// break ;
39941: GO 39981
// if BuildingStatus ( x ) = bs_idle then
39943: LD_VAR 0 7
39947: PPUSH
39948: CALL_OW 461
39952: PUSH
39953: LD_INT 2
39955: EQUAL
39956: IFFALSE 39979
// sci := sci ^ UnitsInside ( x ) ;
39958: LD_ADDR_VAR 0 8
39962: PUSH
39963: LD_VAR 0 8
39967: PUSH
39968: LD_VAR 0 7
39972: PPUSH
39973: CALL_OW 313
39977: ADD
39978: ST_TO_ADDR
// end ;
39979: GO 39928
39981: POP
39982: POP
// if not sci then
39983: LD_VAR 0 8
39987: NOT
39988: IFFALSE 39992
// continue ;
39990: GO 39037
// for x in sci do
39992: LD_ADDR_VAR 0 7
39996: PUSH
39997: LD_VAR 0 8
40001: PUSH
40002: FOR_IN
40003: IFFALSE 40053
// if IsInUnit ( x ) and not HasTask ( x ) then
40005: LD_VAR 0 7
40009: PPUSH
40010: CALL_OW 310
40014: PUSH
40015: LD_VAR 0 7
40019: PPUSH
40020: CALL_OW 314
40024: NOT
40025: AND
40026: IFFALSE 40051
// begin ComExitBuilding ( x ) ;
40028: LD_VAR 0 7
40032: PPUSH
40033: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40037: LD_VAR 0 7
40041: PPUSH
40042: LD_VAR 0 3
40046: PPUSH
40047: CALL_OW 180
// end ;
40051: GO 40002
40053: POP
40054: POP
// end ; end ;
40055: GO 39037
40057: POP
40058: POP
// end ;
40059: GO 38991
40061: POP
40062: POP
// end ;
40063: LD_VAR 0 1
40067: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
40068: LD_INT 0
40070: PPUSH
40071: PPUSH
// if not mc_bases then
40072: LD_EXP 78
40076: NOT
40077: IFFALSE 40081
// exit ;
40079: GO 40162
// for i = 1 to mc_bases do
40081: LD_ADDR_VAR 0 2
40085: PUSH
40086: DOUBLE
40087: LD_INT 1
40089: DEC
40090: ST_TO_ADDR
40091: LD_EXP 78
40095: PUSH
40096: FOR_TO
40097: IFFALSE 40160
// if mc_mines [ i ] and mc_miners [ i ] then
40099: LD_EXP 91
40103: PUSH
40104: LD_VAR 0 2
40108: ARRAY
40109: PUSH
40110: LD_EXP 92
40114: PUSH
40115: LD_VAR 0 2
40119: ARRAY
40120: AND
40121: IFFALSE 40158
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
40123: LD_EXP 92
40127: PUSH
40128: LD_VAR 0 2
40132: ARRAY
40133: PUSH
40134: LD_INT 1
40136: ARRAY
40137: PPUSH
40138: CALL_OW 255
40142: PPUSH
40143: LD_EXP 91
40147: PUSH
40148: LD_VAR 0 2
40152: ARRAY
40153: PPUSH
40154: CALL 54801 0 2
40158: GO 40096
40160: POP
40161: POP
// end ;
40162: LD_VAR 0 1
40166: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
40167: LD_INT 0
40169: PPUSH
40170: PPUSH
40171: PPUSH
40172: PPUSH
40173: PPUSH
40174: PPUSH
40175: PPUSH
40176: PPUSH
// if not mc_bases or not mc_parking then
40177: LD_EXP 78
40181: NOT
40182: PUSH
40183: LD_EXP 102
40187: NOT
40188: OR
40189: IFFALSE 40193
// exit ;
40191: GO 40931
// for i = 1 to mc_bases do
40193: LD_ADDR_VAR 0 2
40197: PUSH
40198: DOUBLE
40199: LD_INT 1
40201: DEC
40202: ST_TO_ADDR
40203: LD_EXP 78
40207: PUSH
40208: FOR_TO
40209: IFFALSE 40929
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
40211: LD_EXP 78
40215: PUSH
40216: LD_VAR 0 2
40220: ARRAY
40221: NOT
40222: PUSH
40223: LD_EXP 102
40227: PUSH
40228: LD_VAR 0 2
40232: ARRAY
40233: NOT
40234: OR
40235: IFFALSE 40239
// continue ;
40237: GO 40208
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
40239: LD_ADDR_VAR 0 5
40243: PUSH
40244: LD_EXP 78
40248: PUSH
40249: LD_VAR 0 2
40253: ARRAY
40254: PUSH
40255: LD_INT 1
40257: ARRAY
40258: PPUSH
40259: CALL_OW 255
40263: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40264: LD_ADDR_VAR 0 6
40268: PUSH
40269: LD_EXP 78
40273: PUSH
40274: LD_VAR 0 2
40278: ARRAY
40279: PPUSH
40280: LD_INT 30
40282: PUSH
40283: LD_INT 3
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PPUSH
40290: CALL_OW 72
40294: ST_TO_ADDR
// if not fac then
40295: LD_VAR 0 6
40299: NOT
40300: IFFALSE 40351
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40302: LD_ADDR_VAR 0 6
40306: PUSH
40307: LD_EXP 78
40311: PUSH
40312: LD_VAR 0 2
40316: ARRAY
40317: PPUSH
40318: LD_INT 2
40320: PUSH
40321: LD_INT 30
40323: PUSH
40324: LD_INT 0
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: LD_INT 30
40333: PUSH
40334: LD_INT 1
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: LIST
40345: PPUSH
40346: CALL_OW 72
40350: ST_TO_ADDR
// if not fac then
40351: LD_VAR 0 6
40355: NOT
40356: IFFALSE 40360
// continue ;
40358: GO 40208
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40360: LD_ADDR_VAR 0 7
40364: PUSH
40365: LD_EXP 102
40369: PUSH
40370: LD_VAR 0 2
40374: ARRAY
40375: PPUSH
40376: LD_INT 22
40378: PUSH
40379: LD_VAR 0 5
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: PUSH
40388: LD_INT 21
40390: PUSH
40391: LD_INT 2
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 3
40400: PUSH
40401: LD_INT 60
40403: PUSH
40404: EMPTY
40405: LIST
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 3
40413: PUSH
40414: LD_INT 24
40416: PUSH
40417: LD_INT 1000
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: LIST
40432: LIST
40433: PPUSH
40434: CALL_OW 70
40438: ST_TO_ADDR
// for j in fac do
40439: LD_ADDR_VAR 0 3
40443: PUSH
40444: LD_VAR 0 6
40448: PUSH
40449: FOR_IN
40450: IFFALSE 40545
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40452: LD_ADDR_VAR 0 7
40456: PUSH
40457: LD_VAR 0 7
40461: PUSH
40462: LD_INT 22
40464: PUSH
40465: LD_VAR 0 5
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 91
40476: PUSH
40477: LD_VAR 0 3
40481: PUSH
40482: LD_INT 15
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 21
40492: PUSH
40493: LD_INT 2
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 3
40502: PUSH
40503: LD_INT 60
40505: PUSH
40506: EMPTY
40507: LIST
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: LD_INT 3
40515: PUSH
40516: LD_INT 24
40518: PUSH
40519: LD_INT 1000
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: EMPTY
40527: LIST
40528: LIST
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: PPUSH
40537: CALL_OW 69
40541: UNION
40542: ST_TO_ADDR
40543: GO 40449
40545: POP
40546: POP
// if not vehs then
40547: LD_VAR 0 7
40551: NOT
40552: IFFALSE 40578
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
40554: LD_ADDR_EXP 90
40558: PUSH
40559: LD_EXP 90
40563: PPUSH
40564: LD_VAR 0 2
40568: PPUSH
40569: EMPTY
40570: PPUSH
40571: CALL_OW 1
40575: ST_TO_ADDR
// continue ;
40576: GO 40208
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40578: LD_ADDR_VAR 0 8
40582: PUSH
40583: LD_EXP 78
40587: PUSH
40588: LD_VAR 0 2
40592: ARRAY
40593: PPUSH
40594: LD_INT 30
40596: PUSH
40597: LD_INT 3
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PPUSH
40604: CALL_OW 72
40608: ST_TO_ADDR
// if tmp then
40609: LD_VAR 0 8
40613: IFFALSE 40716
// begin for j in tmp do
40615: LD_ADDR_VAR 0 3
40619: PUSH
40620: LD_VAR 0 8
40624: PUSH
40625: FOR_IN
40626: IFFALSE 40714
// for k in UnitsInside ( j ) do
40628: LD_ADDR_VAR 0 4
40632: PUSH
40633: LD_VAR 0 3
40637: PPUSH
40638: CALL_OW 313
40642: PUSH
40643: FOR_IN
40644: IFFALSE 40710
// if k then
40646: LD_VAR 0 4
40650: IFFALSE 40708
// if not k in mc_repair_vehicle [ i ] then
40652: LD_VAR 0 4
40656: PUSH
40657: LD_EXP 90
40661: PUSH
40662: LD_VAR 0 2
40666: ARRAY
40667: IN
40668: NOT
40669: IFFALSE 40708
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
40671: LD_ADDR_EXP 90
40675: PUSH
40676: LD_EXP 90
40680: PPUSH
40681: LD_VAR 0 2
40685: PPUSH
40686: LD_EXP 90
40690: PUSH
40691: LD_VAR 0 2
40695: ARRAY
40696: PUSH
40697: LD_VAR 0 4
40701: UNION
40702: PPUSH
40703: CALL_OW 1
40707: ST_TO_ADDR
40708: GO 40643
40710: POP
40711: POP
40712: GO 40625
40714: POP
40715: POP
// end ; if not mc_repair_vehicle [ i ] then
40716: LD_EXP 90
40720: PUSH
40721: LD_VAR 0 2
40725: ARRAY
40726: NOT
40727: IFFALSE 40731
// continue ;
40729: GO 40208
// for j in mc_repair_vehicle [ i ] do
40731: LD_ADDR_VAR 0 3
40735: PUSH
40736: LD_EXP 90
40740: PUSH
40741: LD_VAR 0 2
40745: ARRAY
40746: PUSH
40747: FOR_IN
40748: IFFALSE 40925
// begin if GetClass ( j ) <> 3 then
40750: LD_VAR 0 3
40754: PPUSH
40755: CALL_OW 257
40759: PUSH
40760: LD_INT 3
40762: NONEQUAL
40763: IFFALSE 40804
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
40765: LD_ADDR_EXP 90
40769: PUSH
40770: LD_EXP 90
40774: PPUSH
40775: LD_VAR 0 2
40779: PPUSH
40780: LD_EXP 90
40784: PUSH
40785: LD_VAR 0 2
40789: ARRAY
40790: PUSH
40791: LD_VAR 0 3
40795: DIFF
40796: PPUSH
40797: CALL_OW 1
40801: ST_TO_ADDR
// continue ;
40802: GO 40747
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40804: LD_VAR 0 3
40808: PPUSH
40809: CALL_OW 311
40813: NOT
40814: PUSH
40815: LD_VAR 0 3
40819: PUSH
40820: LD_EXP 81
40824: PUSH
40825: LD_VAR 0 2
40829: ARRAY
40830: PUSH
40831: LD_INT 1
40833: ARRAY
40834: IN
40835: NOT
40836: AND
40837: PUSH
40838: LD_VAR 0 3
40842: PUSH
40843: LD_EXP 81
40847: PUSH
40848: LD_VAR 0 2
40852: ARRAY
40853: PUSH
40854: LD_INT 2
40856: ARRAY
40857: IN
40858: NOT
40859: AND
40860: IFFALSE 40923
// begin if IsInUnit ( j ) then
40862: LD_VAR 0 3
40866: PPUSH
40867: CALL_OW 310
40871: IFFALSE 40884
// ComExitBuilding ( j ) else
40873: LD_VAR 0 3
40877: PPUSH
40878: CALL_OW 122
40882: GO 40923
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40884: LD_VAR 0 3
40888: PPUSH
40889: LD_VAR 0 7
40893: PUSH
40894: LD_INT 1
40896: ARRAY
40897: PPUSH
40898: CALL 92248 0 2
40902: NOT
40903: IFFALSE 40923
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40905: LD_VAR 0 3
40909: PPUSH
40910: LD_VAR 0 7
40914: PUSH
40915: LD_INT 1
40917: ARRAY
40918: PPUSH
40919: CALL_OW 129
// end ; end ;
40923: GO 40747
40925: POP
40926: POP
// end ;
40927: GO 40208
40929: POP
40930: POP
// end ;
40931: LD_VAR 0 1
40935: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40936: LD_INT 0
40938: PPUSH
40939: PPUSH
40940: PPUSH
40941: PPUSH
40942: PPUSH
40943: PPUSH
40944: PPUSH
40945: PPUSH
40946: PPUSH
40947: PPUSH
40948: PPUSH
// if not mc_bases then
40949: LD_EXP 78
40953: NOT
40954: IFFALSE 40958
// exit ;
40956: GO 41760
// for i = 1 to mc_bases do
40958: LD_ADDR_VAR 0 2
40962: PUSH
40963: DOUBLE
40964: LD_INT 1
40966: DEC
40967: ST_TO_ADDR
40968: LD_EXP 78
40972: PUSH
40973: FOR_TO
40974: IFFALSE 41758
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40976: LD_EXP 106
40980: PUSH
40981: LD_VAR 0 2
40985: ARRAY
40986: NOT
40987: PUSH
40988: LD_EXP 81
40992: PUSH
40993: LD_VAR 0 2
40997: ARRAY
40998: PUSH
40999: LD_INT 1
41001: ARRAY
41002: OR
41003: PUSH
41004: LD_EXP 81
41008: PUSH
41009: LD_VAR 0 2
41013: ARRAY
41014: PUSH
41015: LD_INT 2
41017: ARRAY
41018: OR
41019: PUSH
41020: LD_EXP 104
41024: PUSH
41025: LD_VAR 0 2
41029: ARRAY
41030: PPUSH
41031: LD_INT 1
41033: PPUSH
41034: CALL_OW 325
41038: NOT
41039: OR
41040: PUSH
41041: LD_EXP 101
41045: PUSH
41046: LD_VAR 0 2
41050: ARRAY
41051: OR
41052: IFFALSE 41056
// continue ;
41054: GO 40973
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
41056: LD_ADDR_VAR 0 8
41060: PUSH
41061: LD_EXP 78
41065: PUSH
41066: LD_VAR 0 2
41070: ARRAY
41071: PPUSH
41072: LD_INT 25
41074: PUSH
41075: LD_INT 4
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 50
41084: PUSH
41085: EMPTY
41086: LIST
41087: PUSH
41088: LD_INT 3
41090: PUSH
41091: LD_INT 60
41093: PUSH
41094: EMPTY
41095: LIST
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: LIST
41105: PPUSH
41106: CALL_OW 72
41110: PUSH
41111: LD_EXP 82
41115: PUSH
41116: LD_VAR 0 2
41120: ARRAY
41121: DIFF
41122: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41123: LD_ADDR_VAR 0 9
41127: PUSH
41128: LD_EXP 78
41132: PUSH
41133: LD_VAR 0 2
41137: ARRAY
41138: PPUSH
41139: LD_INT 2
41141: PUSH
41142: LD_INT 30
41144: PUSH
41145: LD_INT 0
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 30
41154: PUSH
41155: LD_INT 1
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: LIST
41166: PPUSH
41167: CALL_OW 72
41171: ST_TO_ADDR
// if not tmp or not dep then
41172: LD_VAR 0 8
41176: NOT
41177: PUSH
41178: LD_VAR 0 9
41182: NOT
41183: OR
41184: IFFALSE 41188
// continue ;
41186: GO 40973
// side := GetSide ( tmp [ 1 ] ) ;
41188: LD_ADDR_VAR 0 11
41192: PUSH
41193: LD_VAR 0 8
41197: PUSH
41198: LD_INT 1
41200: ARRAY
41201: PPUSH
41202: CALL_OW 255
41206: ST_TO_ADDR
// dep := dep [ 1 ] ;
41207: LD_ADDR_VAR 0 9
41211: PUSH
41212: LD_VAR 0 9
41216: PUSH
41217: LD_INT 1
41219: ARRAY
41220: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
41221: LD_ADDR_VAR 0 7
41225: PUSH
41226: LD_EXP 106
41230: PUSH
41231: LD_VAR 0 2
41235: ARRAY
41236: PPUSH
41237: LD_INT 22
41239: PUSH
41240: LD_INT 0
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 25
41249: PUSH
41250: LD_INT 12
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PPUSH
41261: CALL_OW 70
41265: PUSH
41266: LD_INT 22
41268: PUSH
41269: LD_INT 0
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 25
41278: PUSH
41279: LD_INT 12
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 91
41288: PUSH
41289: LD_VAR 0 9
41293: PUSH
41294: LD_INT 20
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: LIST
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL_OW 69
41311: UNION
41312: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
41313: LD_ADDR_VAR 0 10
41317: PUSH
41318: LD_EXP 106
41322: PUSH
41323: LD_VAR 0 2
41327: ARRAY
41328: PPUSH
41329: LD_INT 81
41331: PUSH
41332: LD_VAR 0 11
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PPUSH
41341: CALL_OW 70
41345: ST_TO_ADDR
// if not apes or danger_at_area then
41346: LD_VAR 0 7
41350: NOT
41351: PUSH
41352: LD_VAR 0 10
41356: OR
41357: IFFALSE 41407
// begin if mc_taming [ i ] then
41359: LD_EXP 109
41363: PUSH
41364: LD_VAR 0 2
41368: ARRAY
41369: IFFALSE 41405
// begin MC_Reset ( i , 121 ) ;
41371: LD_VAR 0 2
41375: PPUSH
41376: LD_INT 121
41378: PPUSH
41379: CALL 26323 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41383: LD_ADDR_EXP 109
41387: PUSH
41388: LD_EXP 109
41392: PPUSH
41393: LD_VAR 0 2
41397: PPUSH
41398: EMPTY
41399: PPUSH
41400: CALL_OW 1
41404: ST_TO_ADDR
// end ; continue ;
41405: GO 40973
// end ; for j in tmp do
41407: LD_ADDR_VAR 0 3
41411: PUSH
41412: LD_VAR 0 8
41416: PUSH
41417: FOR_IN
41418: IFFALSE 41754
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
41420: LD_VAR 0 3
41424: PUSH
41425: LD_EXP 109
41429: PUSH
41430: LD_VAR 0 2
41434: ARRAY
41435: IN
41436: NOT
41437: PUSH
41438: LD_EXP 109
41442: PUSH
41443: LD_VAR 0 2
41447: ARRAY
41448: PUSH
41449: LD_INT 3
41451: LESS
41452: AND
41453: IFFALSE 41511
// begin SetTag ( j , 121 ) ;
41455: LD_VAR 0 3
41459: PPUSH
41460: LD_INT 121
41462: PPUSH
41463: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
41467: LD_ADDR_EXP 109
41471: PUSH
41472: LD_EXP 109
41476: PPUSH
41477: LD_VAR 0 2
41481: PUSH
41482: LD_EXP 109
41486: PUSH
41487: LD_VAR 0 2
41491: ARRAY
41492: PUSH
41493: LD_INT 1
41495: PLUS
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: PPUSH
41501: LD_VAR 0 3
41505: PPUSH
41506: CALL 57824 0 3
41510: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
41511: LD_VAR 0 3
41515: PUSH
41516: LD_EXP 109
41520: PUSH
41521: LD_VAR 0 2
41525: ARRAY
41526: IN
41527: IFFALSE 41752
// begin if GetClass ( j ) <> 4 then
41529: LD_VAR 0 3
41533: PPUSH
41534: CALL_OW 257
41538: PUSH
41539: LD_INT 4
41541: NONEQUAL
41542: IFFALSE 41595
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
41544: LD_ADDR_EXP 109
41548: PUSH
41549: LD_EXP 109
41553: PPUSH
41554: LD_VAR 0 2
41558: PPUSH
41559: LD_EXP 109
41563: PUSH
41564: LD_VAR 0 2
41568: ARRAY
41569: PUSH
41570: LD_VAR 0 3
41574: DIFF
41575: PPUSH
41576: CALL_OW 1
41580: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41581: LD_VAR 0 3
41585: PPUSH
41586: LD_INT 0
41588: PPUSH
41589: CALL_OW 109
// continue ;
41593: GO 41417
// end ; if IsInUnit ( j ) then
41595: LD_VAR 0 3
41599: PPUSH
41600: CALL_OW 310
41604: IFFALSE 41615
// ComExitBuilding ( j ) ;
41606: LD_VAR 0 3
41610: PPUSH
41611: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
41615: LD_ADDR_VAR 0 6
41619: PUSH
41620: LD_VAR 0 7
41624: PPUSH
41625: LD_VAR 0 3
41629: PPUSH
41630: CALL_OW 74
41634: ST_TO_ADDR
// if not ape then
41635: LD_VAR 0 6
41639: NOT
41640: IFFALSE 41644
// break ;
41642: GO 41754
// x := GetX ( ape ) ;
41644: LD_ADDR_VAR 0 4
41648: PUSH
41649: LD_VAR 0 6
41653: PPUSH
41654: CALL_OW 250
41658: ST_TO_ADDR
// y := GetY ( ape ) ;
41659: LD_ADDR_VAR 0 5
41663: PUSH
41664: LD_VAR 0 6
41668: PPUSH
41669: CALL_OW 251
41673: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
41674: LD_VAR 0 4
41678: PPUSH
41679: LD_VAR 0 5
41683: PPUSH
41684: CALL_OW 488
41688: NOT
41689: PUSH
41690: LD_VAR 0 11
41694: PPUSH
41695: LD_VAR 0 4
41699: PPUSH
41700: LD_VAR 0 5
41704: PPUSH
41705: LD_INT 20
41707: PPUSH
41708: CALL 58720 0 4
41712: PUSH
41713: LD_INT 4
41715: ARRAY
41716: OR
41717: IFFALSE 41721
// break ;
41719: GO 41754
// if not HasTask ( j ) then
41721: LD_VAR 0 3
41725: PPUSH
41726: CALL_OW 314
41730: NOT
41731: IFFALSE 41752
// ComTameXY ( j , x , y ) ;
41733: LD_VAR 0 3
41737: PPUSH
41738: LD_VAR 0 4
41742: PPUSH
41743: LD_VAR 0 5
41747: PPUSH
41748: CALL_OW 131
// end ; end ;
41752: GO 41417
41754: POP
41755: POP
// end ;
41756: GO 40973
41758: POP
41759: POP
// end ;
41760: LD_VAR 0 1
41764: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
41765: LD_INT 0
41767: PPUSH
41768: PPUSH
41769: PPUSH
41770: PPUSH
41771: PPUSH
41772: PPUSH
41773: PPUSH
41774: PPUSH
// if not mc_bases then
41775: LD_EXP 78
41779: NOT
41780: IFFALSE 41784
// exit ;
41782: GO 42410
// for i = 1 to mc_bases do
41784: LD_ADDR_VAR 0 2
41788: PUSH
41789: DOUBLE
41790: LD_INT 1
41792: DEC
41793: ST_TO_ADDR
41794: LD_EXP 78
41798: PUSH
41799: FOR_TO
41800: IFFALSE 42408
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
41802: LD_EXP 107
41806: PUSH
41807: LD_VAR 0 2
41811: ARRAY
41812: NOT
41813: PUSH
41814: LD_EXP 107
41818: PUSH
41819: LD_VAR 0 2
41823: ARRAY
41824: PPUSH
41825: LD_INT 25
41827: PUSH
41828: LD_INT 12
41830: PUSH
41831: EMPTY
41832: LIST
41833: LIST
41834: PPUSH
41835: CALL_OW 72
41839: NOT
41840: OR
41841: IFFALSE 41845
// continue ;
41843: GO 41799
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41845: LD_ADDR_VAR 0 5
41849: PUSH
41850: LD_EXP 107
41854: PUSH
41855: LD_VAR 0 2
41859: ARRAY
41860: PUSH
41861: LD_INT 1
41863: ARRAY
41864: PPUSH
41865: CALL_OW 255
41869: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41870: LD_VAR 0 5
41874: PPUSH
41875: LD_INT 2
41877: PPUSH
41878: CALL_OW 325
41882: IFFALSE 42135
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41884: LD_ADDR_VAR 0 4
41888: PUSH
41889: LD_EXP 107
41893: PUSH
41894: LD_VAR 0 2
41898: ARRAY
41899: PPUSH
41900: LD_INT 25
41902: PUSH
41903: LD_INT 16
41905: PUSH
41906: EMPTY
41907: LIST
41908: LIST
41909: PPUSH
41910: CALL_OW 72
41914: ST_TO_ADDR
// if tmp < 6 then
41915: LD_VAR 0 4
41919: PUSH
41920: LD_INT 6
41922: LESS
41923: IFFALSE 42135
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41925: LD_ADDR_VAR 0 6
41929: PUSH
41930: LD_EXP 78
41934: PUSH
41935: LD_VAR 0 2
41939: ARRAY
41940: PPUSH
41941: LD_INT 2
41943: PUSH
41944: LD_INT 30
41946: PUSH
41947: LD_INT 0
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 30
41956: PUSH
41957: LD_INT 1
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: LIST
41968: PPUSH
41969: CALL_OW 72
41973: ST_TO_ADDR
// if depot then
41974: LD_VAR 0 6
41978: IFFALSE 42135
// begin selected := 0 ;
41980: LD_ADDR_VAR 0 7
41984: PUSH
41985: LD_INT 0
41987: ST_TO_ADDR
// for j in depot do
41988: LD_ADDR_VAR 0 3
41992: PUSH
41993: LD_VAR 0 6
41997: PUSH
41998: FOR_IN
41999: IFFALSE 42030
// begin if UnitsInside ( j ) < 6 then
42001: LD_VAR 0 3
42005: PPUSH
42006: CALL_OW 313
42010: PUSH
42011: LD_INT 6
42013: LESS
42014: IFFALSE 42028
// begin selected := j ;
42016: LD_ADDR_VAR 0 7
42020: PUSH
42021: LD_VAR 0 3
42025: ST_TO_ADDR
// break ;
42026: GO 42030
// end ; end ;
42028: GO 41998
42030: POP
42031: POP
// if selected then
42032: LD_VAR 0 7
42036: IFFALSE 42135
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42038: LD_ADDR_VAR 0 3
42042: PUSH
42043: LD_EXP 107
42047: PUSH
42048: LD_VAR 0 2
42052: ARRAY
42053: PPUSH
42054: LD_INT 25
42056: PUSH
42057: LD_INT 12
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PPUSH
42064: CALL_OW 72
42068: PUSH
42069: FOR_IN
42070: IFFALSE 42133
// if not HasTask ( j ) then
42072: LD_VAR 0 3
42076: PPUSH
42077: CALL_OW 314
42081: NOT
42082: IFFALSE 42131
// begin if not IsInUnit ( j ) then
42084: LD_VAR 0 3
42088: PPUSH
42089: CALL_OW 310
42093: NOT
42094: IFFALSE 42110
// ComEnterUnit ( j , selected ) ;
42096: LD_VAR 0 3
42100: PPUSH
42101: LD_VAR 0 7
42105: PPUSH
42106: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
42110: LD_VAR 0 3
42114: PPUSH
42115: LD_INT 16
42117: PPUSH
42118: CALL_OW 183
// AddComExitBuilding ( j ) ;
42122: LD_VAR 0 3
42126: PPUSH
42127: CALL_OW 182
// end ;
42131: GO 42069
42133: POP
42134: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
42135: LD_VAR 0 5
42139: PPUSH
42140: LD_INT 11
42142: PPUSH
42143: CALL_OW 325
42147: IFFALSE 42406
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42149: LD_ADDR_VAR 0 4
42153: PUSH
42154: LD_EXP 107
42158: PUSH
42159: LD_VAR 0 2
42163: ARRAY
42164: PPUSH
42165: LD_INT 25
42167: PUSH
42168: LD_INT 16
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PPUSH
42175: CALL_OW 72
42179: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
42180: LD_VAR 0 4
42184: PUSH
42185: LD_INT 6
42187: GREATEREQUAL
42188: PUSH
42189: LD_VAR 0 5
42193: PPUSH
42194: LD_INT 2
42196: PPUSH
42197: CALL_OW 325
42201: NOT
42202: OR
42203: IFFALSE 42406
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42205: LD_ADDR_VAR 0 8
42209: PUSH
42210: LD_EXP 78
42214: PUSH
42215: LD_VAR 0 2
42219: ARRAY
42220: PPUSH
42221: LD_INT 2
42223: PUSH
42224: LD_INT 30
42226: PUSH
42227: LD_INT 4
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: PUSH
42234: LD_INT 30
42236: PUSH
42237: LD_INT 5
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: EMPTY
42245: LIST
42246: LIST
42247: LIST
42248: PPUSH
42249: CALL_OW 72
42253: ST_TO_ADDR
// if barracks then
42254: LD_VAR 0 8
42258: IFFALSE 42406
// begin selected := 0 ;
42260: LD_ADDR_VAR 0 7
42264: PUSH
42265: LD_INT 0
42267: ST_TO_ADDR
// for j in barracks do
42268: LD_ADDR_VAR 0 3
42272: PUSH
42273: LD_VAR 0 8
42277: PUSH
42278: FOR_IN
42279: IFFALSE 42310
// begin if UnitsInside ( j ) < 6 then
42281: LD_VAR 0 3
42285: PPUSH
42286: CALL_OW 313
42290: PUSH
42291: LD_INT 6
42293: LESS
42294: IFFALSE 42308
// begin selected := j ;
42296: LD_ADDR_VAR 0 7
42300: PUSH
42301: LD_VAR 0 3
42305: ST_TO_ADDR
// break ;
42306: GO 42310
// end ; end ;
42308: GO 42278
42310: POP
42311: POP
// if selected then
42312: LD_VAR 0 7
42316: IFFALSE 42406
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42318: LD_ADDR_VAR 0 3
42322: PUSH
42323: LD_EXP 107
42327: PUSH
42328: LD_VAR 0 2
42332: ARRAY
42333: PPUSH
42334: LD_INT 25
42336: PUSH
42337: LD_INT 12
42339: PUSH
42340: EMPTY
42341: LIST
42342: LIST
42343: PPUSH
42344: CALL_OW 72
42348: PUSH
42349: FOR_IN
42350: IFFALSE 42404
// if not IsInUnit ( j ) and not HasTask ( j ) then
42352: LD_VAR 0 3
42356: PPUSH
42357: CALL_OW 310
42361: NOT
42362: PUSH
42363: LD_VAR 0 3
42367: PPUSH
42368: CALL_OW 314
42372: NOT
42373: AND
42374: IFFALSE 42402
// begin ComEnterUnit ( j , selected ) ;
42376: LD_VAR 0 3
42380: PPUSH
42381: LD_VAR 0 7
42385: PPUSH
42386: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
42390: LD_VAR 0 3
42394: PPUSH
42395: LD_INT 15
42397: PPUSH
42398: CALL_OW 183
// end ;
42402: GO 42349
42404: POP
42405: POP
// end ; end ; end ; end ; end ;
42406: GO 41799
42408: POP
42409: POP
// end ;
42410: LD_VAR 0 1
42414: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
42415: LD_INT 0
42417: PPUSH
42418: PPUSH
42419: PPUSH
42420: PPUSH
// if not mc_bases then
42421: LD_EXP 78
42425: NOT
42426: IFFALSE 42430
// exit ;
42428: GO 42608
// for i = 1 to mc_bases do
42430: LD_ADDR_VAR 0 2
42434: PUSH
42435: DOUBLE
42436: LD_INT 1
42438: DEC
42439: ST_TO_ADDR
42440: LD_EXP 78
42444: PUSH
42445: FOR_TO
42446: IFFALSE 42606
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
42448: LD_ADDR_VAR 0 4
42452: PUSH
42453: LD_EXP 78
42457: PUSH
42458: LD_VAR 0 2
42462: ARRAY
42463: PPUSH
42464: LD_INT 25
42466: PUSH
42467: LD_INT 9
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PPUSH
42474: CALL_OW 72
42478: ST_TO_ADDR
// if not tmp then
42479: LD_VAR 0 4
42483: NOT
42484: IFFALSE 42488
// continue ;
42486: GO 42445
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
42488: LD_EXP 104
42492: PUSH
42493: LD_VAR 0 2
42497: ARRAY
42498: PPUSH
42499: LD_INT 29
42501: PPUSH
42502: CALL_OW 325
42506: NOT
42507: PUSH
42508: LD_EXP 104
42512: PUSH
42513: LD_VAR 0 2
42517: ARRAY
42518: PPUSH
42519: LD_INT 28
42521: PPUSH
42522: CALL_OW 325
42526: NOT
42527: AND
42528: IFFALSE 42532
// continue ;
42530: GO 42445
// for j in tmp do
42532: LD_ADDR_VAR 0 3
42536: PUSH
42537: LD_VAR 0 4
42541: PUSH
42542: FOR_IN
42543: IFFALSE 42602
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
42545: LD_VAR 0 3
42549: PUSH
42550: LD_EXP 81
42554: PUSH
42555: LD_VAR 0 2
42559: ARRAY
42560: PUSH
42561: LD_INT 1
42563: ARRAY
42564: IN
42565: NOT
42566: PUSH
42567: LD_VAR 0 3
42571: PUSH
42572: LD_EXP 81
42576: PUSH
42577: LD_VAR 0 2
42581: ARRAY
42582: PUSH
42583: LD_INT 2
42585: ARRAY
42586: IN
42587: NOT
42588: AND
42589: IFFALSE 42600
// ComSpaceTimeShoot ( j ) ;
42591: LD_VAR 0 3
42595: PPUSH
42596: CALL 53809 0 1
42600: GO 42542
42602: POP
42603: POP
// end ;
42604: GO 42445
42606: POP
42607: POP
// end ;
42608: LD_VAR 0 1
42612: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
42613: LD_INT 0
42615: PPUSH
42616: PPUSH
42617: PPUSH
42618: PPUSH
42619: PPUSH
42620: PPUSH
42621: PPUSH
42622: PPUSH
42623: PPUSH
// if not mc_bases then
42624: LD_EXP 78
42628: NOT
42629: IFFALSE 42633
// exit ;
42631: GO 43255
// for i = 1 to mc_bases do
42633: LD_ADDR_VAR 0 2
42637: PUSH
42638: DOUBLE
42639: LD_INT 1
42641: DEC
42642: ST_TO_ADDR
42643: LD_EXP 78
42647: PUSH
42648: FOR_TO
42649: IFFALSE 43253
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
42651: LD_EXP 113
42655: PUSH
42656: LD_VAR 0 2
42660: ARRAY
42661: NOT
42662: PUSH
42663: LD_INT 38
42665: PPUSH
42666: LD_EXP 104
42670: PUSH
42671: LD_VAR 0 2
42675: ARRAY
42676: PPUSH
42677: CALL_OW 321
42681: PUSH
42682: LD_INT 2
42684: NONEQUAL
42685: OR
42686: IFFALSE 42690
// continue ;
42688: GO 42648
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
42690: LD_ADDR_VAR 0 8
42694: PUSH
42695: LD_EXP 78
42699: PUSH
42700: LD_VAR 0 2
42704: ARRAY
42705: PPUSH
42706: LD_INT 30
42708: PUSH
42709: LD_INT 34
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PPUSH
42716: CALL_OW 72
42720: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
42721: LD_ADDR_VAR 0 9
42725: PUSH
42726: LD_EXP 78
42730: PUSH
42731: LD_VAR 0 2
42735: ARRAY
42736: PPUSH
42737: LD_INT 25
42739: PUSH
42740: LD_INT 4
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PPUSH
42747: CALL_OW 72
42751: PPUSH
42752: LD_INT 0
42754: PPUSH
42755: CALL 87765 0 2
42759: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
42760: LD_VAR 0 9
42764: NOT
42765: PUSH
42766: LD_VAR 0 8
42770: NOT
42771: OR
42772: PUSH
42773: LD_EXP 78
42777: PUSH
42778: LD_VAR 0 2
42782: ARRAY
42783: PPUSH
42784: LD_INT 124
42786: PPUSH
42787: CALL 87765 0 2
42791: OR
42792: IFFALSE 42796
// continue ;
42794: GO 42648
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
42796: LD_EXP 114
42800: PUSH
42801: LD_VAR 0 2
42805: ARRAY
42806: PUSH
42807: LD_EXP 113
42811: PUSH
42812: LD_VAR 0 2
42816: ARRAY
42817: LESS
42818: PUSH
42819: LD_EXP 114
42823: PUSH
42824: LD_VAR 0 2
42828: ARRAY
42829: PUSH
42830: LD_VAR 0 8
42834: LESS
42835: AND
42836: IFFALSE 43251
// begin tmp := sci [ 1 ] ;
42838: LD_ADDR_VAR 0 7
42842: PUSH
42843: LD_VAR 0 9
42847: PUSH
42848: LD_INT 1
42850: ARRAY
42851: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42852: LD_VAR 0 7
42856: PPUSH
42857: LD_INT 124
42859: PPUSH
42860: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42864: LD_ADDR_VAR 0 3
42868: PUSH
42869: DOUBLE
42870: LD_EXP 113
42874: PUSH
42875: LD_VAR 0 2
42879: ARRAY
42880: INC
42881: ST_TO_ADDR
42882: LD_EXP 113
42886: PUSH
42887: LD_VAR 0 2
42891: ARRAY
42892: PUSH
42893: FOR_DOWNTO
42894: IFFALSE 43237
// begin if IsInUnit ( tmp ) then
42896: LD_VAR 0 7
42900: PPUSH
42901: CALL_OW 310
42905: IFFALSE 42916
// ComExitBuilding ( tmp ) ;
42907: LD_VAR 0 7
42911: PPUSH
42912: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42916: LD_INT 35
42918: PPUSH
42919: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42923: LD_VAR 0 7
42927: PPUSH
42928: CALL_OW 310
42932: NOT
42933: PUSH
42934: LD_VAR 0 7
42938: PPUSH
42939: CALL_OW 314
42943: NOT
42944: AND
42945: IFFALSE 42916
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42947: LD_ADDR_VAR 0 6
42951: PUSH
42952: LD_VAR 0 7
42956: PPUSH
42957: CALL_OW 250
42961: PUSH
42962: LD_VAR 0 7
42966: PPUSH
42967: CALL_OW 251
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42976: LD_INT 35
42978: PPUSH
42979: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42983: LD_ADDR_VAR 0 4
42987: PUSH
42988: LD_EXP 113
42992: PUSH
42993: LD_VAR 0 2
42997: ARRAY
42998: PUSH
42999: LD_VAR 0 3
43003: ARRAY
43004: PUSH
43005: LD_INT 1
43007: ARRAY
43008: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
43009: LD_ADDR_VAR 0 5
43013: PUSH
43014: LD_EXP 113
43018: PUSH
43019: LD_VAR 0 2
43023: ARRAY
43024: PUSH
43025: LD_VAR 0 3
43029: ARRAY
43030: PUSH
43031: LD_INT 2
43033: ARRAY
43034: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
43035: LD_VAR 0 7
43039: PPUSH
43040: LD_INT 10
43042: PPUSH
43043: CALL 60421 0 2
43047: PUSH
43048: LD_INT 4
43050: ARRAY
43051: IFFALSE 43089
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
43053: LD_VAR 0 7
43057: PPUSH
43058: LD_VAR 0 6
43062: PUSH
43063: LD_INT 1
43065: ARRAY
43066: PPUSH
43067: LD_VAR 0 6
43071: PUSH
43072: LD_INT 2
43074: ARRAY
43075: PPUSH
43076: CALL_OW 111
// wait ( 0 0$10 ) ;
43080: LD_INT 350
43082: PPUSH
43083: CALL_OW 67
// end else
43087: GO 43115
// begin ComMoveXY ( tmp , x , y ) ;
43089: LD_VAR 0 7
43093: PPUSH
43094: LD_VAR 0 4
43098: PPUSH
43099: LD_VAR 0 5
43103: PPUSH
43104: CALL_OW 111
// wait ( 0 0$3 ) ;
43108: LD_INT 105
43110: PPUSH
43111: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
43115: LD_VAR 0 7
43119: PPUSH
43120: LD_VAR 0 4
43124: PPUSH
43125: LD_VAR 0 5
43129: PPUSH
43130: CALL_OW 307
43134: IFFALSE 42976
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
43136: LD_VAR 0 7
43140: PPUSH
43141: LD_VAR 0 4
43145: PPUSH
43146: LD_VAR 0 5
43150: PPUSH
43151: LD_VAR 0 8
43155: PUSH
43156: LD_VAR 0 3
43160: ARRAY
43161: PPUSH
43162: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
43166: LD_INT 35
43168: PPUSH
43169: CALL_OW 67
// until not HasTask ( tmp ) ;
43173: LD_VAR 0 7
43177: PPUSH
43178: CALL_OW 314
43182: NOT
43183: IFFALSE 43166
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
43185: LD_ADDR_EXP 114
43189: PUSH
43190: LD_EXP 114
43194: PPUSH
43195: LD_VAR 0 2
43199: PUSH
43200: LD_EXP 114
43204: PUSH
43205: LD_VAR 0 2
43209: ARRAY
43210: PUSH
43211: LD_INT 1
43213: PLUS
43214: PUSH
43215: EMPTY
43216: LIST
43217: LIST
43218: PPUSH
43219: LD_VAR 0 8
43223: PUSH
43224: LD_VAR 0 3
43228: ARRAY
43229: PPUSH
43230: CALL 57824 0 3
43234: ST_TO_ADDR
// end ;
43235: GO 42893
43237: POP
43238: POP
// MC_Reset ( i , 124 ) ;
43239: LD_VAR 0 2
43243: PPUSH
43244: LD_INT 124
43246: PPUSH
43247: CALL 26323 0 2
// end ; end ;
43251: GO 42648
43253: POP
43254: POP
// end ;
43255: LD_VAR 0 1
43259: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
43260: LD_INT 0
43262: PPUSH
43263: PPUSH
43264: PPUSH
// if not mc_bases then
43265: LD_EXP 78
43269: NOT
43270: IFFALSE 43274
// exit ;
43272: GO 43880
// for i = 1 to mc_bases do
43274: LD_ADDR_VAR 0 2
43278: PUSH
43279: DOUBLE
43280: LD_INT 1
43282: DEC
43283: ST_TO_ADDR
43284: LD_EXP 78
43288: PUSH
43289: FOR_TO
43290: IFFALSE 43878
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43292: LD_ADDR_VAR 0 3
43296: PUSH
43297: LD_EXP 78
43301: PUSH
43302: LD_VAR 0 2
43306: ARRAY
43307: PPUSH
43308: LD_INT 25
43310: PUSH
43311: LD_INT 4
43313: PUSH
43314: EMPTY
43315: LIST
43316: LIST
43317: PPUSH
43318: CALL_OW 72
43322: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43323: LD_VAR 0 3
43327: NOT
43328: PUSH
43329: LD_EXP 115
43333: PUSH
43334: LD_VAR 0 2
43338: ARRAY
43339: NOT
43340: OR
43341: PUSH
43342: LD_EXP 78
43346: PUSH
43347: LD_VAR 0 2
43351: ARRAY
43352: PPUSH
43353: LD_INT 2
43355: PUSH
43356: LD_INT 30
43358: PUSH
43359: LD_INT 0
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 30
43368: PUSH
43369: LD_INT 1
43371: PUSH
43372: EMPTY
43373: LIST
43374: LIST
43375: PUSH
43376: EMPTY
43377: LIST
43378: LIST
43379: LIST
43380: PPUSH
43381: CALL_OW 72
43385: NOT
43386: OR
43387: IFFALSE 43437
// begin if mc_deposits_finder [ i ] then
43389: LD_EXP 116
43393: PUSH
43394: LD_VAR 0 2
43398: ARRAY
43399: IFFALSE 43435
// begin MC_Reset ( i , 125 ) ;
43401: LD_VAR 0 2
43405: PPUSH
43406: LD_INT 125
43408: PPUSH
43409: CALL 26323 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43413: LD_ADDR_EXP 116
43417: PUSH
43418: LD_EXP 116
43422: PPUSH
43423: LD_VAR 0 2
43427: PPUSH
43428: EMPTY
43429: PPUSH
43430: CALL_OW 1
43434: ST_TO_ADDR
// end ; continue ;
43435: GO 43289
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
43437: LD_EXP 115
43441: PUSH
43442: LD_VAR 0 2
43446: ARRAY
43447: PUSH
43448: LD_INT 1
43450: ARRAY
43451: PUSH
43452: LD_INT 3
43454: ARRAY
43455: PUSH
43456: LD_INT 1
43458: EQUAL
43459: PUSH
43460: LD_INT 20
43462: PPUSH
43463: LD_EXP 104
43467: PUSH
43468: LD_VAR 0 2
43472: ARRAY
43473: PPUSH
43474: CALL_OW 321
43478: PUSH
43479: LD_INT 2
43481: NONEQUAL
43482: AND
43483: IFFALSE 43533
// begin if mc_deposits_finder [ i ] then
43485: LD_EXP 116
43489: PUSH
43490: LD_VAR 0 2
43494: ARRAY
43495: IFFALSE 43531
// begin MC_Reset ( i , 125 ) ;
43497: LD_VAR 0 2
43501: PPUSH
43502: LD_INT 125
43504: PPUSH
43505: CALL 26323 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43509: LD_ADDR_EXP 116
43513: PUSH
43514: LD_EXP 116
43518: PPUSH
43519: LD_VAR 0 2
43523: PPUSH
43524: EMPTY
43525: PPUSH
43526: CALL_OW 1
43530: ST_TO_ADDR
// end ; continue ;
43531: GO 43289
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
43533: LD_EXP 115
43537: PUSH
43538: LD_VAR 0 2
43542: ARRAY
43543: PUSH
43544: LD_INT 1
43546: ARRAY
43547: PUSH
43548: LD_INT 1
43550: ARRAY
43551: PPUSH
43552: LD_EXP 115
43556: PUSH
43557: LD_VAR 0 2
43561: ARRAY
43562: PUSH
43563: LD_INT 1
43565: ARRAY
43566: PUSH
43567: LD_INT 2
43569: ARRAY
43570: PPUSH
43571: LD_EXP 104
43575: PUSH
43576: LD_VAR 0 2
43580: ARRAY
43581: PPUSH
43582: CALL_OW 440
43586: IFFALSE 43629
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
43588: LD_ADDR_EXP 115
43592: PUSH
43593: LD_EXP 115
43597: PPUSH
43598: LD_VAR 0 2
43602: PPUSH
43603: LD_EXP 115
43607: PUSH
43608: LD_VAR 0 2
43612: ARRAY
43613: PPUSH
43614: LD_INT 1
43616: PPUSH
43617: CALL_OW 3
43621: PPUSH
43622: CALL_OW 1
43626: ST_TO_ADDR
43627: GO 43876
// begin if not mc_deposits_finder [ i ] then
43629: LD_EXP 116
43633: PUSH
43634: LD_VAR 0 2
43638: ARRAY
43639: NOT
43640: IFFALSE 43692
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
43642: LD_ADDR_EXP 116
43646: PUSH
43647: LD_EXP 116
43651: PPUSH
43652: LD_VAR 0 2
43656: PPUSH
43657: LD_VAR 0 3
43661: PUSH
43662: LD_INT 1
43664: ARRAY
43665: PUSH
43666: EMPTY
43667: LIST
43668: PPUSH
43669: CALL_OW 1
43673: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
43674: LD_VAR 0 3
43678: PUSH
43679: LD_INT 1
43681: ARRAY
43682: PPUSH
43683: LD_INT 125
43685: PPUSH
43686: CALL_OW 109
// end else
43690: GO 43876
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
43692: LD_EXP 116
43696: PUSH
43697: LD_VAR 0 2
43701: ARRAY
43702: PUSH
43703: LD_INT 1
43705: ARRAY
43706: PPUSH
43707: CALL_OW 310
43711: IFFALSE 43734
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
43713: LD_EXP 116
43717: PUSH
43718: LD_VAR 0 2
43722: ARRAY
43723: PUSH
43724: LD_INT 1
43726: ARRAY
43727: PPUSH
43728: CALL_OW 122
43732: GO 43876
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
43734: LD_EXP 116
43738: PUSH
43739: LD_VAR 0 2
43743: ARRAY
43744: PUSH
43745: LD_INT 1
43747: ARRAY
43748: PPUSH
43749: CALL_OW 314
43753: NOT
43754: PUSH
43755: LD_EXP 116
43759: PUSH
43760: LD_VAR 0 2
43764: ARRAY
43765: PUSH
43766: LD_INT 1
43768: ARRAY
43769: PPUSH
43770: LD_EXP 115
43774: PUSH
43775: LD_VAR 0 2
43779: ARRAY
43780: PUSH
43781: LD_INT 1
43783: ARRAY
43784: PUSH
43785: LD_INT 1
43787: ARRAY
43788: PPUSH
43789: LD_EXP 115
43793: PUSH
43794: LD_VAR 0 2
43798: ARRAY
43799: PUSH
43800: LD_INT 1
43802: ARRAY
43803: PUSH
43804: LD_INT 2
43806: ARRAY
43807: PPUSH
43808: CALL_OW 297
43812: PUSH
43813: LD_INT 6
43815: GREATER
43816: AND
43817: IFFALSE 43876
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
43819: LD_EXP 116
43823: PUSH
43824: LD_VAR 0 2
43828: ARRAY
43829: PUSH
43830: LD_INT 1
43832: ARRAY
43833: PPUSH
43834: LD_EXP 115
43838: PUSH
43839: LD_VAR 0 2
43843: ARRAY
43844: PUSH
43845: LD_INT 1
43847: ARRAY
43848: PUSH
43849: LD_INT 1
43851: ARRAY
43852: PPUSH
43853: LD_EXP 115
43857: PUSH
43858: LD_VAR 0 2
43862: ARRAY
43863: PUSH
43864: LD_INT 1
43866: ARRAY
43867: PUSH
43868: LD_INT 2
43870: ARRAY
43871: PPUSH
43872: CALL_OW 111
// end ; end ; end ;
43876: GO 43289
43878: POP
43879: POP
// end ;
43880: LD_VAR 0 1
43884: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43885: LD_INT 0
43887: PPUSH
43888: PPUSH
43889: PPUSH
43890: PPUSH
43891: PPUSH
43892: PPUSH
43893: PPUSH
43894: PPUSH
43895: PPUSH
43896: PPUSH
43897: PPUSH
// if not mc_bases then
43898: LD_EXP 78
43902: NOT
43903: IFFALSE 43907
// exit ;
43905: GO 44847
// for i = 1 to mc_bases do
43907: LD_ADDR_VAR 0 2
43911: PUSH
43912: DOUBLE
43913: LD_INT 1
43915: DEC
43916: ST_TO_ADDR
43917: LD_EXP 78
43921: PUSH
43922: FOR_TO
43923: IFFALSE 44845
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43925: LD_EXP 78
43929: PUSH
43930: LD_VAR 0 2
43934: ARRAY
43935: NOT
43936: PUSH
43937: LD_EXP 101
43941: PUSH
43942: LD_VAR 0 2
43946: ARRAY
43947: OR
43948: IFFALSE 43952
// continue ;
43950: GO 43922
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43952: LD_ADDR_VAR 0 7
43956: PUSH
43957: LD_EXP 78
43961: PUSH
43962: LD_VAR 0 2
43966: ARRAY
43967: PUSH
43968: LD_INT 1
43970: ARRAY
43971: PPUSH
43972: CALL_OW 248
43976: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43977: LD_VAR 0 7
43981: PUSH
43982: LD_INT 3
43984: EQUAL
43985: PUSH
43986: LD_EXP 97
43990: PUSH
43991: LD_VAR 0 2
43995: ARRAY
43996: PUSH
43997: LD_EXP 100
44001: PUSH
44002: LD_VAR 0 2
44006: ARRAY
44007: UNION
44008: PPUSH
44009: LD_INT 33
44011: PUSH
44012: LD_INT 2
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PPUSH
44019: CALL_OW 72
44023: NOT
44024: OR
44025: IFFALSE 44029
// continue ;
44027: GO 43922
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
44029: LD_ADDR_VAR 0 9
44033: PUSH
44034: LD_EXP 78
44038: PUSH
44039: LD_VAR 0 2
44043: ARRAY
44044: PPUSH
44045: LD_INT 30
44047: PUSH
44048: LD_INT 36
44050: PUSH
44051: EMPTY
44052: LIST
44053: LIST
44054: PPUSH
44055: CALL_OW 72
44059: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
44060: LD_ADDR_VAR 0 10
44064: PUSH
44065: LD_EXP 97
44069: PUSH
44070: LD_VAR 0 2
44074: ARRAY
44075: PPUSH
44076: LD_INT 34
44078: PUSH
44079: LD_INT 31
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PPUSH
44086: CALL_OW 72
44090: ST_TO_ADDR
// if not cts and not mcts then
44091: LD_VAR 0 9
44095: NOT
44096: PUSH
44097: LD_VAR 0 10
44101: NOT
44102: AND
44103: IFFALSE 44107
// continue ;
44105: GO 43922
// x := cts ;
44107: LD_ADDR_VAR 0 11
44111: PUSH
44112: LD_VAR 0 9
44116: ST_TO_ADDR
// if not x then
44117: LD_VAR 0 11
44121: NOT
44122: IFFALSE 44134
// x := mcts ;
44124: LD_ADDR_VAR 0 11
44128: PUSH
44129: LD_VAR 0 10
44133: ST_TO_ADDR
// if not x then
44134: LD_VAR 0 11
44138: NOT
44139: IFFALSE 44143
// continue ;
44141: GO 43922
// if mc_remote_driver [ i ] then
44143: LD_EXP 118
44147: PUSH
44148: LD_VAR 0 2
44152: ARRAY
44153: IFFALSE 44540
// for j in mc_remote_driver [ i ] do
44155: LD_ADDR_VAR 0 3
44159: PUSH
44160: LD_EXP 118
44164: PUSH
44165: LD_VAR 0 2
44169: ARRAY
44170: PUSH
44171: FOR_IN
44172: IFFALSE 44538
// begin if GetClass ( j ) <> 3 then
44174: LD_VAR 0 3
44178: PPUSH
44179: CALL_OW 257
44183: PUSH
44184: LD_INT 3
44186: NONEQUAL
44187: IFFALSE 44240
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
44189: LD_ADDR_EXP 118
44193: PUSH
44194: LD_EXP 118
44198: PPUSH
44199: LD_VAR 0 2
44203: PPUSH
44204: LD_EXP 118
44208: PUSH
44209: LD_VAR 0 2
44213: ARRAY
44214: PUSH
44215: LD_VAR 0 3
44219: DIFF
44220: PPUSH
44221: CALL_OW 1
44225: ST_TO_ADDR
// SetTag ( j , 0 ) ;
44226: LD_VAR 0 3
44230: PPUSH
44231: LD_INT 0
44233: PPUSH
44234: CALL_OW 109
// continue ;
44238: GO 44171
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
44240: LD_EXP 97
44244: PUSH
44245: LD_VAR 0 2
44249: ARRAY
44250: PPUSH
44251: LD_INT 34
44253: PUSH
44254: LD_INT 31
44256: PUSH
44257: EMPTY
44258: LIST
44259: LIST
44260: PUSH
44261: LD_INT 58
44263: PUSH
44264: EMPTY
44265: LIST
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PPUSH
44271: CALL_OW 72
44275: PUSH
44276: LD_VAR 0 3
44280: PPUSH
44281: CALL 87800 0 1
44285: NOT
44286: AND
44287: IFFALSE 44358
// begin if IsInUnit ( j ) then
44289: LD_VAR 0 3
44293: PPUSH
44294: CALL_OW 310
44298: IFFALSE 44309
// ComExitBuilding ( j ) ;
44300: LD_VAR 0 3
44304: PPUSH
44305: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
44309: LD_VAR 0 3
44313: PPUSH
44314: LD_EXP 97
44318: PUSH
44319: LD_VAR 0 2
44323: ARRAY
44324: PPUSH
44325: LD_INT 34
44327: PUSH
44328: LD_INT 31
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: LD_INT 58
44337: PUSH
44338: EMPTY
44339: LIST
44340: PUSH
44341: EMPTY
44342: LIST
44343: LIST
44344: PPUSH
44345: CALL_OW 72
44349: PUSH
44350: LD_INT 1
44352: ARRAY
44353: PPUSH
44354: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
44358: LD_VAR 0 3
44362: PPUSH
44363: CALL_OW 310
44367: NOT
44368: PUSH
44369: LD_VAR 0 3
44373: PPUSH
44374: CALL_OW 310
44378: PPUSH
44379: CALL_OW 266
44383: PUSH
44384: LD_INT 36
44386: NONEQUAL
44387: PUSH
44388: LD_VAR 0 3
44392: PPUSH
44393: CALL 87800 0 1
44397: NOT
44398: AND
44399: OR
44400: IFFALSE 44536
// begin if IsInUnit ( j ) then
44402: LD_VAR 0 3
44406: PPUSH
44407: CALL_OW 310
44411: IFFALSE 44422
// ComExitBuilding ( j ) ;
44413: LD_VAR 0 3
44417: PPUSH
44418: CALL_OW 122
// ct := 0 ;
44422: LD_ADDR_VAR 0 8
44426: PUSH
44427: LD_INT 0
44429: ST_TO_ADDR
// for k in x do
44430: LD_ADDR_VAR 0 4
44434: PUSH
44435: LD_VAR 0 11
44439: PUSH
44440: FOR_IN
44441: IFFALSE 44514
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
44443: LD_VAR 0 4
44447: PPUSH
44448: CALL_OW 264
44452: PUSH
44453: LD_INT 31
44455: EQUAL
44456: PUSH
44457: LD_VAR 0 4
44461: PPUSH
44462: CALL_OW 311
44466: NOT
44467: AND
44468: PUSH
44469: LD_VAR 0 4
44473: PPUSH
44474: CALL_OW 266
44478: PUSH
44479: LD_INT 36
44481: EQUAL
44482: PUSH
44483: LD_VAR 0 4
44487: PPUSH
44488: CALL_OW 313
44492: PUSH
44493: LD_INT 3
44495: LESS
44496: AND
44497: OR
44498: IFFALSE 44512
// begin ct := k ;
44500: LD_ADDR_VAR 0 8
44504: PUSH
44505: LD_VAR 0 4
44509: ST_TO_ADDR
// break ;
44510: GO 44514
// end ;
44512: GO 44440
44514: POP
44515: POP
// if ct then
44516: LD_VAR 0 8
44520: IFFALSE 44536
// ComEnterUnit ( j , ct ) ;
44522: LD_VAR 0 3
44526: PPUSH
44527: LD_VAR 0 8
44531: PPUSH
44532: CALL_OW 120
// end ; end ;
44536: GO 44171
44538: POP
44539: POP
// places := 0 ;
44540: LD_ADDR_VAR 0 5
44544: PUSH
44545: LD_INT 0
44547: ST_TO_ADDR
// for j = 1 to x do
44548: LD_ADDR_VAR 0 3
44552: PUSH
44553: DOUBLE
44554: LD_INT 1
44556: DEC
44557: ST_TO_ADDR
44558: LD_VAR 0 11
44562: PUSH
44563: FOR_TO
44564: IFFALSE 44640
// if GetWeapon ( x [ j ] ) = ar_control_tower then
44566: LD_VAR 0 11
44570: PUSH
44571: LD_VAR 0 3
44575: ARRAY
44576: PPUSH
44577: CALL_OW 264
44581: PUSH
44582: LD_INT 31
44584: EQUAL
44585: IFFALSE 44603
// places := places + 1 else
44587: LD_ADDR_VAR 0 5
44591: PUSH
44592: LD_VAR 0 5
44596: PUSH
44597: LD_INT 1
44599: PLUS
44600: ST_TO_ADDR
44601: GO 44638
// if GetBType ( x [ j ] ) = b_control_tower then
44603: LD_VAR 0 11
44607: PUSH
44608: LD_VAR 0 3
44612: ARRAY
44613: PPUSH
44614: CALL_OW 266
44618: PUSH
44619: LD_INT 36
44621: EQUAL
44622: IFFALSE 44638
// places := places + 3 ;
44624: LD_ADDR_VAR 0 5
44628: PUSH
44629: LD_VAR 0 5
44633: PUSH
44634: LD_INT 3
44636: PLUS
44637: ST_TO_ADDR
44638: GO 44563
44640: POP
44641: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
44642: LD_VAR 0 5
44646: PUSH
44647: LD_INT 0
44649: EQUAL
44650: PUSH
44651: LD_VAR 0 5
44655: PUSH
44656: LD_EXP 118
44660: PUSH
44661: LD_VAR 0 2
44665: ARRAY
44666: LESSEQUAL
44667: OR
44668: IFFALSE 44672
// continue ;
44670: GO 43922
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
44672: LD_ADDR_VAR 0 6
44676: PUSH
44677: LD_EXP 78
44681: PUSH
44682: LD_VAR 0 2
44686: ARRAY
44687: PPUSH
44688: LD_INT 25
44690: PUSH
44691: LD_INT 3
44693: PUSH
44694: EMPTY
44695: LIST
44696: LIST
44697: PPUSH
44698: CALL_OW 72
44702: PUSH
44703: LD_EXP 118
44707: PUSH
44708: LD_VAR 0 2
44712: ARRAY
44713: DIFF
44714: PPUSH
44715: LD_INT 3
44717: PPUSH
44718: CALL 88700 0 2
44722: ST_TO_ADDR
// for j in tmp do
44723: LD_ADDR_VAR 0 3
44727: PUSH
44728: LD_VAR 0 6
44732: PUSH
44733: FOR_IN
44734: IFFALSE 44769
// if GetTag ( j ) > 0 then
44736: LD_VAR 0 3
44740: PPUSH
44741: CALL_OW 110
44745: PUSH
44746: LD_INT 0
44748: GREATER
44749: IFFALSE 44767
// tmp := tmp diff j ;
44751: LD_ADDR_VAR 0 6
44755: PUSH
44756: LD_VAR 0 6
44760: PUSH
44761: LD_VAR 0 3
44765: DIFF
44766: ST_TO_ADDR
44767: GO 44733
44769: POP
44770: POP
// if not tmp then
44771: LD_VAR 0 6
44775: NOT
44776: IFFALSE 44780
// continue ;
44778: GO 43922
// if places then
44780: LD_VAR 0 5
44784: IFFALSE 44843
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
44786: LD_ADDR_EXP 118
44790: PUSH
44791: LD_EXP 118
44795: PPUSH
44796: LD_VAR 0 2
44800: PPUSH
44801: LD_EXP 118
44805: PUSH
44806: LD_VAR 0 2
44810: ARRAY
44811: PUSH
44812: LD_VAR 0 6
44816: PUSH
44817: LD_INT 1
44819: ARRAY
44820: UNION
44821: PPUSH
44822: CALL_OW 1
44826: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
44827: LD_VAR 0 6
44831: PUSH
44832: LD_INT 1
44834: ARRAY
44835: PPUSH
44836: LD_INT 126
44838: PPUSH
44839: CALL_OW 109
// end ; end ;
44843: GO 43922
44845: POP
44846: POP
// end ;
44847: LD_VAR 0 1
44851: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44852: LD_INT 0
44854: PPUSH
44855: PPUSH
44856: PPUSH
44857: PPUSH
44858: PPUSH
44859: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44860: LD_VAR 0 1
44864: NOT
44865: PUSH
44866: LD_VAR 0 2
44870: NOT
44871: OR
44872: PUSH
44873: LD_VAR 0 3
44877: NOT
44878: OR
44879: PUSH
44880: LD_VAR 0 4
44884: PUSH
44885: LD_INT 1
44887: PUSH
44888: LD_INT 2
44890: PUSH
44891: LD_INT 3
44893: PUSH
44894: LD_INT 4
44896: PUSH
44897: LD_INT 5
44899: PUSH
44900: LD_INT 8
44902: PUSH
44903: LD_INT 9
44905: PUSH
44906: LD_INT 15
44908: PUSH
44909: LD_INT 16
44911: PUSH
44912: EMPTY
44913: LIST
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: IN
44923: NOT
44924: OR
44925: IFFALSE 44929
// exit ;
44927: GO 45787
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44929: LD_ADDR_VAR 0 2
44933: PUSH
44934: LD_VAR 0 2
44938: PPUSH
44939: LD_INT 21
44941: PUSH
44942: LD_INT 3
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: PUSH
44949: LD_INT 24
44951: PUSH
44952: LD_INT 250
44954: PUSH
44955: EMPTY
44956: LIST
44957: LIST
44958: PUSH
44959: EMPTY
44960: LIST
44961: LIST
44962: PPUSH
44963: CALL_OW 72
44967: ST_TO_ADDR
// case class of 1 , 15 :
44968: LD_VAR 0 4
44972: PUSH
44973: LD_INT 1
44975: DOUBLE
44976: EQUAL
44977: IFTRUE 44987
44979: LD_INT 15
44981: DOUBLE
44982: EQUAL
44983: IFTRUE 44987
44985: GO 45072
44987: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44988: LD_ADDR_VAR 0 8
44992: PUSH
44993: LD_VAR 0 2
44997: PPUSH
44998: LD_INT 2
45000: PUSH
45001: LD_INT 30
45003: PUSH
45004: LD_INT 32
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 30
45013: PUSH
45014: LD_INT 31
45016: PUSH
45017: EMPTY
45018: LIST
45019: LIST
45020: PUSH
45021: EMPTY
45022: LIST
45023: LIST
45024: LIST
45025: PPUSH
45026: CALL_OW 72
45030: PUSH
45031: LD_VAR 0 2
45035: PPUSH
45036: LD_INT 2
45038: PUSH
45039: LD_INT 30
45041: PUSH
45042: LD_INT 4
45044: PUSH
45045: EMPTY
45046: LIST
45047: LIST
45048: PUSH
45049: LD_INT 30
45051: PUSH
45052: LD_INT 5
45054: PUSH
45055: EMPTY
45056: LIST
45057: LIST
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: LIST
45063: PPUSH
45064: CALL_OW 72
45068: ADD
45069: ST_TO_ADDR
45070: GO 45318
45072: LD_INT 2
45074: DOUBLE
45075: EQUAL
45076: IFTRUE 45086
45078: LD_INT 16
45080: DOUBLE
45081: EQUAL
45082: IFTRUE 45086
45084: GO 45132
45086: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
45087: LD_ADDR_VAR 0 8
45091: PUSH
45092: LD_VAR 0 2
45096: PPUSH
45097: LD_INT 2
45099: PUSH
45100: LD_INT 30
45102: PUSH
45103: LD_INT 0
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 30
45112: PUSH
45113: LD_INT 1
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: LIST
45124: PPUSH
45125: CALL_OW 72
45129: ST_TO_ADDR
45130: GO 45318
45132: LD_INT 3
45134: DOUBLE
45135: EQUAL
45136: IFTRUE 45140
45138: GO 45186
45140: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
45141: LD_ADDR_VAR 0 8
45145: PUSH
45146: LD_VAR 0 2
45150: PPUSH
45151: LD_INT 2
45153: PUSH
45154: LD_INT 30
45156: PUSH
45157: LD_INT 2
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 30
45166: PUSH
45167: LD_INT 3
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: LIST
45178: PPUSH
45179: CALL_OW 72
45183: ST_TO_ADDR
45184: GO 45318
45186: LD_INT 4
45188: DOUBLE
45189: EQUAL
45190: IFTRUE 45194
45192: GO 45251
45194: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
45195: LD_ADDR_VAR 0 8
45199: PUSH
45200: LD_VAR 0 2
45204: PPUSH
45205: LD_INT 2
45207: PUSH
45208: LD_INT 30
45210: PUSH
45211: LD_INT 6
45213: PUSH
45214: EMPTY
45215: LIST
45216: LIST
45217: PUSH
45218: LD_INT 30
45220: PUSH
45221: LD_INT 7
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: PUSH
45228: LD_INT 30
45230: PUSH
45231: LD_INT 8
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: PUSH
45238: EMPTY
45239: LIST
45240: LIST
45241: LIST
45242: LIST
45243: PPUSH
45244: CALL_OW 72
45248: ST_TO_ADDR
45249: GO 45318
45251: LD_INT 5
45253: DOUBLE
45254: EQUAL
45255: IFTRUE 45271
45257: LD_INT 8
45259: DOUBLE
45260: EQUAL
45261: IFTRUE 45271
45263: LD_INT 9
45265: DOUBLE
45266: EQUAL
45267: IFTRUE 45271
45269: GO 45317
45271: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
45272: LD_ADDR_VAR 0 8
45276: PUSH
45277: LD_VAR 0 2
45281: PPUSH
45282: LD_INT 2
45284: PUSH
45285: LD_INT 30
45287: PUSH
45288: LD_INT 4
45290: PUSH
45291: EMPTY
45292: LIST
45293: LIST
45294: PUSH
45295: LD_INT 30
45297: PUSH
45298: LD_INT 5
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: LIST
45309: PPUSH
45310: CALL_OW 72
45314: ST_TO_ADDR
45315: GO 45318
45317: POP
// if not tmp then
45318: LD_VAR 0 8
45322: NOT
45323: IFFALSE 45327
// exit ;
45325: GO 45787
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
45327: LD_VAR 0 4
45331: PUSH
45332: LD_INT 1
45334: PUSH
45335: LD_INT 15
45337: PUSH
45338: EMPTY
45339: LIST
45340: LIST
45341: IN
45342: PUSH
45343: LD_EXP 87
45347: PUSH
45348: LD_VAR 0 1
45352: ARRAY
45353: AND
45354: IFFALSE 45510
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
45356: LD_ADDR_VAR 0 9
45360: PUSH
45361: LD_EXP 87
45365: PUSH
45366: LD_VAR 0 1
45370: ARRAY
45371: PUSH
45372: LD_INT 1
45374: ARRAY
45375: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
45376: LD_VAR 0 9
45380: PUSH
45381: LD_EXP 88
45385: PUSH
45386: LD_VAR 0 1
45390: ARRAY
45391: IN
45392: NOT
45393: IFFALSE 45508
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
45395: LD_ADDR_EXP 88
45399: PUSH
45400: LD_EXP 88
45404: PPUSH
45405: LD_VAR 0 1
45409: PUSH
45410: LD_EXP 88
45414: PUSH
45415: LD_VAR 0 1
45419: ARRAY
45420: PUSH
45421: LD_INT 1
45423: PLUS
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PPUSH
45429: LD_VAR 0 9
45433: PPUSH
45434: CALL 57824 0 3
45438: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
45439: LD_ADDR_EXP 87
45443: PUSH
45444: LD_EXP 87
45448: PPUSH
45449: LD_VAR 0 1
45453: PPUSH
45454: LD_EXP 87
45458: PUSH
45459: LD_VAR 0 1
45463: ARRAY
45464: PUSH
45465: LD_VAR 0 9
45469: DIFF
45470: PPUSH
45471: CALL_OW 1
45475: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
45476: LD_VAR 0 3
45480: PPUSH
45481: LD_EXP 88
45485: PUSH
45486: LD_VAR 0 1
45490: ARRAY
45491: PUSH
45492: LD_EXP 88
45496: PUSH
45497: LD_VAR 0 1
45501: ARRAY
45502: ARRAY
45503: PPUSH
45504: CALL_OW 120
// end ; exit ;
45508: GO 45787
// end ; if tmp > 1 then
45510: LD_VAR 0 8
45514: PUSH
45515: LD_INT 1
45517: GREATER
45518: IFFALSE 45622
// for i = 2 to tmp do
45520: LD_ADDR_VAR 0 6
45524: PUSH
45525: DOUBLE
45526: LD_INT 2
45528: DEC
45529: ST_TO_ADDR
45530: LD_VAR 0 8
45534: PUSH
45535: FOR_TO
45536: IFFALSE 45620
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
45538: LD_VAR 0 8
45542: PUSH
45543: LD_VAR 0 6
45547: ARRAY
45548: PPUSH
45549: CALL_OW 461
45553: PUSH
45554: LD_INT 6
45556: EQUAL
45557: IFFALSE 45618
// begin x := tmp [ i ] ;
45559: LD_ADDR_VAR 0 9
45563: PUSH
45564: LD_VAR 0 8
45568: PUSH
45569: LD_VAR 0 6
45573: ARRAY
45574: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
45575: LD_ADDR_VAR 0 8
45579: PUSH
45580: LD_VAR 0 8
45584: PPUSH
45585: LD_VAR 0 6
45589: PPUSH
45590: CALL_OW 3
45594: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
45595: LD_ADDR_VAR 0 8
45599: PUSH
45600: LD_VAR 0 8
45604: PPUSH
45605: LD_INT 1
45607: PPUSH
45608: LD_VAR 0 9
45612: PPUSH
45613: CALL_OW 2
45617: ST_TO_ADDR
// end ;
45618: GO 45535
45620: POP
45621: POP
// for i in tmp do
45622: LD_ADDR_VAR 0 6
45626: PUSH
45627: LD_VAR 0 8
45631: PUSH
45632: FOR_IN
45633: IFFALSE 45660
// begin if IsNotFull ( i ) then
45635: LD_VAR 0 6
45639: PPUSH
45640: CALL 55046 0 1
45644: IFFALSE 45658
// begin j := i ;
45646: LD_ADDR_VAR 0 7
45650: PUSH
45651: LD_VAR 0 6
45655: ST_TO_ADDR
// break ;
45656: GO 45660
// end ; end ;
45658: GO 45632
45660: POP
45661: POP
// if j then
45662: LD_VAR 0 7
45666: IFFALSE 45684
// ComEnterUnit ( unit , j ) else
45668: LD_VAR 0 3
45672: PPUSH
45673: LD_VAR 0 7
45677: PPUSH
45678: CALL_OW 120
45682: GO 45787
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45684: LD_ADDR_VAR 0 10
45688: PUSH
45689: LD_VAR 0 2
45693: PPUSH
45694: LD_INT 2
45696: PUSH
45697: LD_INT 30
45699: PUSH
45700: LD_INT 0
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: PUSH
45707: LD_INT 30
45709: PUSH
45710: LD_INT 1
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: LIST
45721: PPUSH
45722: CALL_OW 72
45726: ST_TO_ADDR
// if depot then
45727: LD_VAR 0 10
45731: IFFALSE 45787
// begin depot := NearestUnitToUnit ( depot , unit ) ;
45733: LD_ADDR_VAR 0 10
45737: PUSH
45738: LD_VAR 0 10
45742: PPUSH
45743: LD_VAR 0 3
45747: PPUSH
45748: CALL_OW 74
45752: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
45753: LD_VAR 0 3
45757: PPUSH
45758: LD_VAR 0 10
45762: PPUSH
45763: CALL_OW 296
45767: PUSH
45768: LD_INT 10
45770: GREATER
45771: IFFALSE 45787
// ComStandNearbyBuilding ( unit , depot ) ;
45773: LD_VAR 0 3
45777: PPUSH
45778: LD_VAR 0 10
45782: PPUSH
45783: CALL 54426 0 2
// end ; end ; end ;
45787: LD_VAR 0 5
45791: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
45792: LD_INT 0
45794: PPUSH
45795: PPUSH
45796: PPUSH
45797: PPUSH
// if not mc_bases then
45798: LD_EXP 78
45802: NOT
45803: IFFALSE 45807
// exit ;
45805: GO 46046
// for i = 1 to mc_bases do
45807: LD_ADDR_VAR 0 2
45811: PUSH
45812: DOUBLE
45813: LD_INT 1
45815: DEC
45816: ST_TO_ADDR
45817: LD_EXP 78
45821: PUSH
45822: FOR_TO
45823: IFFALSE 46044
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45825: LD_ADDR_VAR 0 4
45829: PUSH
45830: LD_EXP 78
45834: PUSH
45835: LD_VAR 0 2
45839: ARRAY
45840: PPUSH
45841: LD_INT 21
45843: PUSH
45844: LD_INT 1
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PPUSH
45851: CALL_OW 72
45855: PUSH
45856: LD_EXP 107
45860: PUSH
45861: LD_VAR 0 2
45865: ARRAY
45866: UNION
45867: ST_TO_ADDR
// if not tmp then
45868: LD_VAR 0 4
45872: NOT
45873: IFFALSE 45877
// continue ;
45875: GO 45822
// for j in tmp do
45877: LD_ADDR_VAR 0 3
45881: PUSH
45882: LD_VAR 0 4
45886: PUSH
45887: FOR_IN
45888: IFFALSE 46040
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45890: LD_VAR 0 3
45894: PPUSH
45895: CALL_OW 110
45899: NOT
45900: PUSH
45901: LD_VAR 0 3
45905: PPUSH
45906: CALL_OW 314
45910: NOT
45911: AND
45912: PUSH
45913: LD_VAR 0 3
45917: PPUSH
45918: CALL_OW 311
45922: NOT
45923: AND
45924: PUSH
45925: LD_VAR 0 3
45929: PPUSH
45930: CALL_OW 310
45934: NOT
45935: AND
45936: PUSH
45937: LD_VAR 0 3
45941: PUSH
45942: LD_EXP 81
45946: PUSH
45947: LD_VAR 0 2
45951: ARRAY
45952: PUSH
45953: LD_INT 1
45955: ARRAY
45956: IN
45957: NOT
45958: AND
45959: PUSH
45960: LD_VAR 0 3
45964: PUSH
45965: LD_EXP 81
45969: PUSH
45970: LD_VAR 0 2
45974: ARRAY
45975: PUSH
45976: LD_INT 2
45978: ARRAY
45979: IN
45980: NOT
45981: AND
45982: PUSH
45983: LD_VAR 0 3
45987: PUSH
45988: LD_EXP 90
45992: PUSH
45993: LD_VAR 0 2
45997: ARRAY
45998: IN
45999: NOT
46000: AND
46001: IFFALSE 46038
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
46003: LD_VAR 0 2
46007: PPUSH
46008: LD_EXP 78
46012: PUSH
46013: LD_VAR 0 2
46017: ARRAY
46018: PPUSH
46019: LD_VAR 0 3
46023: PPUSH
46024: LD_VAR 0 3
46028: PPUSH
46029: CALL_OW 257
46033: PPUSH
46034: CALL 44852 0 4
// end ;
46038: GO 45887
46040: POP
46041: POP
// end ;
46042: GO 45822
46044: POP
46045: POP
// end ;
46046: LD_VAR 0 1
46050: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
46051: LD_INT 0
46053: PPUSH
46054: PPUSH
46055: PPUSH
46056: PPUSH
46057: PPUSH
46058: PPUSH
// if not mc_bases [ base ] then
46059: LD_EXP 78
46063: PUSH
46064: LD_VAR 0 1
46068: ARRAY
46069: NOT
46070: IFFALSE 46074
// exit ;
46072: GO 46275
// tmp := [ ] ;
46074: LD_ADDR_VAR 0 6
46078: PUSH
46079: EMPTY
46080: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
46081: LD_ADDR_VAR 0 7
46085: PUSH
46086: LD_VAR 0 3
46090: PPUSH
46091: LD_INT 0
46093: PPUSH
46094: CALL_OW 517
46098: ST_TO_ADDR
// if not list then
46099: LD_VAR 0 7
46103: NOT
46104: IFFALSE 46108
// exit ;
46106: GO 46275
// c := Count ( list [ 1 ] ) ;
46108: LD_ADDR_VAR 0 9
46112: PUSH
46113: LD_VAR 0 7
46117: PUSH
46118: LD_INT 1
46120: ARRAY
46121: PPUSH
46122: CALL 54964 0 1
46126: ST_TO_ADDR
// if amount > c then
46127: LD_VAR 0 2
46131: PUSH
46132: LD_VAR 0 9
46136: GREATER
46137: IFFALSE 46149
// amount := c ;
46139: LD_ADDR_VAR 0 2
46143: PUSH
46144: LD_VAR 0 9
46148: ST_TO_ADDR
// for i := 1 to amount do
46149: LD_ADDR_VAR 0 5
46153: PUSH
46154: DOUBLE
46155: LD_INT 1
46157: DEC
46158: ST_TO_ADDR
46159: LD_VAR 0 2
46163: PUSH
46164: FOR_TO
46165: IFFALSE 46223
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
46167: LD_ADDR_VAR 0 6
46171: PUSH
46172: LD_VAR 0 6
46176: PPUSH
46177: LD_VAR 0 5
46181: PPUSH
46182: LD_VAR 0 7
46186: PUSH
46187: LD_INT 1
46189: ARRAY
46190: PUSH
46191: LD_VAR 0 5
46195: ARRAY
46196: PUSH
46197: LD_VAR 0 7
46201: PUSH
46202: LD_INT 2
46204: ARRAY
46205: PUSH
46206: LD_VAR 0 5
46210: ARRAY
46211: PUSH
46212: EMPTY
46213: LIST
46214: LIST
46215: PPUSH
46216: CALL_OW 1
46220: ST_TO_ADDR
46221: GO 46164
46223: POP
46224: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
46225: LD_ADDR_EXP 91
46229: PUSH
46230: LD_EXP 91
46234: PPUSH
46235: LD_VAR 0 1
46239: PPUSH
46240: LD_VAR 0 6
46244: PPUSH
46245: CALL_OW 1
46249: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
46250: LD_ADDR_EXP 93
46254: PUSH
46255: LD_EXP 93
46259: PPUSH
46260: LD_VAR 0 1
46264: PPUSH
46265: LD_VAR 0 3
46269: PPUSH
46270: CALL_OW 1
46274: ST_TO_ADDR
// end ;
46275: LD_VAR 0 4
46279: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
46280: LD_INT 0
46282: PPUSH
// if not mc_bases [ base ] then
46283: LD_EXP 78
46287: PUSH
46288: LD_VAR 0 1
46292: ARRAY
46293: NOT
46294: IFFALSE 46298
// exit ;
46296: GO 46323
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
46298: LD_ADDR_EXP 83
46302: PUSH
46303: LD_EXP 83
46307: PPUSH
46308: LD_VAR 0 1
46312: PPUSH
46313: LD_VAR 0 2
46317: PPUSH
46318: CALL_OW 1
46322: ST_TO_ADDR
// end ;
46323: LD_VAR 0 3
46327: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
46328: LD_INT 0
46330: PPUSH
// if not mc_bases [ base ] then
46331: LD_EXP 78
46335: PUSH
46336: LD_VAR 0 1
46340: ARRAY
46341: NOT
46342: IFFALSE 46346
// exit ;
46344: GO 46383
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
46346: LD_ADDR_EXP 83
46350: PUSH
46351: LD_EXP 83
46355: PPUSH
46356: LD_VAR 0 1
46360: PPUSH
46361: LD_EXP 83
46365: PUSH
46366: LD_VAR 0 1
46370: ARRAY
46371: PUSH
46372: LD_VAR 0 2
46376: UNION
46377: PPUSH
46378: CALL_OW 1
46382: ST_TO_ADDR
// end ;
46383: LD_VAR 0 3
46387: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
46388: LD_INT 0
46390: PPUSH
// if not mc_bases [ base ] then
46391: LD_EXP 78
46395: PUSH
46396: LD_VAR 0 1
46400: ARRAY
46401: NOT
46402: IFFALSE 46406
// exit ;
46404: GO 46431
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
46406: LD_ADDR_EXP 99
46410: PUSH
46411: LD_EXP 99
46415: PPUSH
46416: LD_VAR 0 1
46420: PPUSH
46421: LD_VAR 0 2
46425: PPUSH
46426: CALL_OW 1
46430: ST_TO_ADDR
// end ;
46431: LD_VAR 0 3
46435: RET
// export function MC_InsertProduceList ( base , components ) ; begin
46436: LD_INT 0
46438: PPUSH
// if not mc_bases [ base ] then
46439: LD_EXP 78
46443: PUSH
46444: LD_VAR 0 1
46448: ARRAY
46449: NOT
46450: IFFALSE 46454
// exit ;
46452: GO 46491
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
46454: LD_ADDR_EXP 99
46458: PUSH
46459: LD_EXP 99
46463: PPUSH
46464: LD_VAR 0 1
46468: PPUSH
46469: LD_EXP 99
46473: PUSH
46474: LD_VAR 0 1
46478: ARRAY
46479: PUSH
46480: LD_VAR 0 2
46484: ADD
46485: PPUSH
46486: CALL_OW 1
46490: ST_TO_ADDR
// end ;
46491: LD_VAR 0 3
46495: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
46496: LD_INT 0
46498: PPUSH
// if not mc_bases [ base ] then
46499: LD_EXP 78
46503: PUSH
46504: LD_VAR 0 1
46508: ARRAY
46509: NOT
46510: IFFALSE 46514
// exit ;
46512: GO 46568
// mc_defender := Replace ( mc_defender , base , deflist ) ;
46514: LD_ADDR_EXP 100
46518: PUSH
46519: LD_EXP 100
46523: PPUSH
46524: LD_VAR 0 1
46528: PPUSH
46529: LD_VAR 0 2
46533: PPUSH
46534: CALL_OW 1
46538: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
46539: LD_ADDR_EXP 89
46543: PUSH
46544: LD_EXP 89
46548: PPUSH
46549: LD_VAR 0 1
46553: PPUSH
46554: LD_VAR 0 2
46558: PUSH
46559: LD_INT 0
46561: PLUS
46562: PPUSH
46563: CALL_OW 1
46567: ST_TO_ADDR
// end ;
46568: LD_VAR 0 3
46572: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
46573: LD_INT 0
46575: PPUSH
// if not mc_bases [ base ] then
46576: LD_EXP 78
46580: PUSH
46581: LD_VAR 0 1
46585: ARRAY
46586: NOT
46587: IFFALSE 46591
// exit ;
46589: GO 46616
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
46591: LD_ADDR_EXP 89
46595: PUSH
46596: LD_EXP 89
46600: PPUSH
46601: LD_VAR 0 1
46605: PPUSH
46606: LD_VAR 0 2
46610: PPUSH
46611: CALL_OW 1
46615: ST_TO_ADDR
// end ;
46616: LD_VAR 0 3
46620: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
46621: LD_INT 0
46623: PPUSH
46624: PPUSH
46625: PPUSH
46626: PPUSH
// if not mc_bases [ base ] then
46627: LD_EXP 78
46631: PUSH
46632: LD_VAR 0 1
46636: ARRAY
46637: NOT
46638: IFFALSE 46642
// exit ;
46640: GO 46707
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
46642: LD_ADDR_EXP 98
46646: PUSH
46647: LD_EXP 98
46651: PPUSH
46652: LD_VAR 0 1
46656: PUSH
46657: LD_EXP 98
46661: PUSH
46662: LD_VAR 0 1
46666: ARRAY
46667: PUSH
46668: LD_INT 1
46670: PLUS
46671: PUSH
46672: EMPTY
46673: LIST
46674: LIST
46675: PPUSH
46676: LD_VAR 0 1
46680: PUSH
46681: LD_VAR 0 2
46685: PUSH
46686: LD_VAR 0 3
46690: PUSH
46691: LD_VAR 0 4
46695: PUSH
46696: EMPTY
46697: LIST
46698: LIST
46699: LIST
46700: LIST
46701: PPUSH
46702: CALL 57824 0 3
46706: ST_TO_ADDR
// end ;
46707: LD_VAR 0 5
46711: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
46712: LD_INT 0
46714: PPUSH
// if not mc_bases [ base ] then
46715: LD_EXP 78
46719: PUSH
46720: LD_VAR 0 1
46724: ARRAY
46725: NOT
46726: IFFALSE 46730
// exit ;
46728: GO 46755
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
46730: LD_ADDR_EXP 115
46734: PUSH
46735: LD_EXP 115
46739: PPUSH
46740: LD_VAR 0 1
46744: PPUSH
46745: LD_VAR 0 2
46749: PPUSH
46750: CALL_OW 1
46754: ST_TO_ADDR
// end ;
46755: LD_VAR 0 3
46759: RET
// export function MC_GetMinesField ( base ) ; begin
46760: LD_INT 0
46762: PPUSH
// result := mc_mines [ base ] ;
46763: LD_ADDR_VAR 0 2
46767: PUSH
46768: LD_EXP 91
46772: PUSH
46773: LD_VAR 0 1
46777: ARRAY
46778: ST_TO_ADDR
// end ;
46779: LD_VAR 0 2
46783: RET
// export function MC_GetProduceList ( base ) ; begin
46784: LD_INT 0
46786: PPUSH
// result := mc_produce [ base ] ;
46787: LD_ADDR_VAR 0 2
46791: PUSH
46792: LD_EXP 99
46796: PUSH
46797: LD_VAR 0 1
46801: ARRAY
46802: ST_TO_ADDR
// end ;
46803: LD_VAR 0 2
46807: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
46808: LD_INT 0
46810: PPUSH
46811: PPUSH
// if not mc_bases then
46812: LD_EXP 78
46816: NOT
46817: IFFALSE 46821
// exit ;
46819: GO 46886
// if mc_bases [ base ] then
46821: LD_EXP 78
46825: PUSH
46826: LD_VAR 0 1
46830: ARRAY
46831: IFFALSE 46886
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46833: LD_ADDR_VAR 0 3
46837: PUSH
46838: LD_EXP 78
46842: PUSH
46843: LD_VAR 0 1
46847: ARRAY
46848: PPUSH
46849: LD_INT 30
46851: PUSH
46852: LD_VAR 0 2
46856: PUSH
46857: EMPTY
46858: LIST
46859: LIST
46860: PPUSH
46861: CALL_OW 72
46865: ST_TO_ADDR
// if result then
46866: LD_VAR 0 3
46870: IFFALSE 46886
// result := result [ 1 ] ;
46872: LD_ADDR_VAR 0 3
46876: PUSH
46877: LD_VAR 0 3
46881: PUSH
46882: LD_INT 1
46884: ARRAY
46885: ST_TO_ADDR
// end ; end ;
46886: LD_VAR 0 3
46890: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46891: LD_INT 0
46893: PPUSH
46894: PPUSH
// if not mc_bases then
46895: LD_EXP 78
46899: NOT
46900: IFFALSE 46904
// exit ;
46902: GO 46949
// if mc_bases [ base ] then
46904: LD_EXP 78
46908: PUSH
46909: LD_VAR 0 1
46913: ARRAY
46914: IFFALSE 46949
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46916: LD_ADDR_VAR 0 3
46920: PUSH
46921: LD_EXP 78
46925: PUSH
46926: LD_VAR 0 1
46930: ARRAY
46931: PPUSH
46932: LD_INT 30
46934: PUSH
46935: LD_VAR 0 2
46939: PUSH
46940: EMPTY
46941: LIST
46942: LIST
46943: PPUSH
46944: CALL_OW 72
46948: ST_TO_ADDR
// end ;
46949: LD_VAR 0 3
46953: RET
// export function MC_SetTame ( base , area ) ; begin
46954: LD_INT 0
46956: PPUSH
// if not mc_bases or not base then
46957: LD_EXP 78
46961: NOT
46962: PUSH
46963: LD_VAR 0 1
46967: NOT
46968: OR
46969: IFFALSE 46973
// exit ;
46971: GO 46998
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46973: LD_ADDR_EXP 106
46977: PUSH
46978: LD_EXP 106
46982: PPUSH
46983: LD_VAR 0 1
46987: PPUSH
46988: LD_VAR 0 2
46992: PPUSH
46993: CALL_OW 1
46997: ST_TO_ADDR
// end ;
46998: LD_VAR 0 3
47002: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
47003: LD_INT 0
47005: PPUSH
47006: PPUSH
// if not mc_bases or not base then
47007: LD_EXP 78
47011: NOT
47012: PUSH
47013: LD_VAR 0 1
47017: NOT
47018: OR
47019: IFFALSE 47023
// exit ;
47021: GO 47125
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47023: LD_ADDR_VAR 0 4
47027: PUSH
47028: LD_EXP 78
47032: PUSH
47033: LD_VAR 0 1
47037: ARRAY
47038: PPUSH
47039: LD_INT 30
47041: PUSH
47042: LD_VAR 0 2
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PPUSH
47051: CALL_OW 72
47055: ST_TO_ADDR
// if not tmp then
47056: LD_VAR 0 4
47060: NOT
47061: IFFALSE 47065
// exit ;
47063: GO 47125
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
47065: LD_ADDR_EXP 110
47069: PUSH
47070: LD_EXP 110
47074: PPUSH
47075: LD_VAR 0 1
47079: PPUSH
47080: LD_EXP 110
47084: PUSH
47085: LD_VAR 0 1
47089: ARRAY
47090: PPUSH
47091: LD_EXP 110
47095: PUSH
47096: LD_VAR 0 1
47100: ARRAY
47101: PUSH
47102: LD_INT 1
47104: PLUS
47105: PPUSH
47106: LD_VAR 0 4
47110: PUSH
47111: LD_INT 1
47113: ARRAY
47114: PPUSH
47115: CALL_OW 2
47119: PPUSH
47120: CALL_OW 1
47124: ST_TO_ADDR
// end ;
47125: LD_VAR 0 3
47129: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
47130: LD_INT 0
47132: PPUSH
47133: PPUSH
// if not mc_bases or not base or not kinds then
47134: LD_EXP 78
47138: NOT
47139: PUSH
47140: LD_VAR 0 1
47144: NOT
47145: OR
47146: PUSH
47147: LD_VAR 0 2
47151: NOT
47152: OR
47153: IFFALSE 47157
// exit ;
47155: GO 47218
// for i in kinds do
47157: LD_ADDR_VAR 0 4
47161: PUSH
47162: LD_VAR 0 2
47166: PUSH
47167: FOR_IN
47168: IFFALSE 47216
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
47170: LD_ADDR_EXP 112
47174: PUSH
47175: LD_EXP 112
47179: PPUSH
47180: LD_VAR 0 1
47184: PUSH
47185: LD_EXP 112
47189: PUSH
47190: LD_VAR 0 1
47194: ARRAY
47195: PUSH
47196: LD_INT 1
47198: PLUS
47199: PUSH
47200: EMPTY
47201: LIST
47202: LIST
47203: PPUSH
47204: LD_VAR 0 4
47208: PPUSH
47209: CALL 57824 0 3
47213: ST_TO_ADDR
47214: GO 47167
47216: POP
47217: POP
// end ;
47218: LD_VAR 0 3
47222: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
47223: LD_INT 0
47225: PPUSH
// if not mc_bases or not base or not areas then
47226: LD_EXP 78
47230: NOT
47231: PUSH
47232: LD_VAR 0 1
47236: NOT
47237: OR
47238: PUSH
47239: LD_VAR 0 2
47243: NOT
47244: OR
47245: IFFALSE 47249
// exit ;
47247: GO 47274
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
47249: LD_ADDR_EXP 96
47253: PUSH
47254: LD_EXP 96
47258: PPUSH
47259: LD_VAR 0 1
47263: PPUSH
47264: LD_VAR 0 2
47268: PPUSH
47269: CALL_OW 1
47273: ST_TO_ADDR
// end ;
47274: LD_VAR 0 3
47278: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
47279: LD_INT 0
47281: PPUSH
// if not mc_bases or not base or not teleports_exit then
47282: LD_EXP 78
47286: NOT
47287: PUSH
47288: LD_VAR 0 1
47292: NOT
47293: OR
47294: PUSH
47295: LD_VAR 0 2
47299: NOT
47300: OR
47301: IFFALSE 47305
// exit ;
47303: GO 47330
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
47305: LD_ADDR_EXP 113
47309: PUSH
47310: LD_EXP 113
47314: PPUSH
47315: LD_VAR 0 1
47319: PPUSH
47320: LD_VAR 0 2
47324: PPUSH
47325: CALL_OW 1
47329: ST_TO_ADDR
// end ;
47330: LD_VAR 0 3
47334: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
47335: LD_INT 0
47337: PPUSH
47338: PPUSH
47339: PPUSH
// if not mc_bases or not base or not ext_list then
47340: LD_EXP 78
47344: NOT
47345: PUSH
47346: LD_VAR 0 1
47350: NOT
47351: OR
47352: PUSH
47353: LD_VAR 0 5
47357: NOT
47358: OR
47359: IFFALSE 47363
// exit ;
47361: GO 47536
// tmp := GetFacExtXYD ( x , y , d ) ;
47363: LD_ADDR_VAR 0 8
47367: PUSH
47368: LD_VAR 0 2
47372: PPUSH
47373: LD_VAR 0 3
47377: PPUSH
47378: LD_VAR 0 4
47382: PPUSH
47383: CALL 87830 0 3
47387: ST_TO_ADDR
// if not tmp then
47388: LD_VAR 0 8
47392: NOT
47393: IFFALSE 47397
// exit ;
47395: GO 47536
// for i in tmp do
47397: LD_ADDR_VAR 0 7
47401: PUSH
47402: LD_VAR 0 8
47406: PUSH
47407: FOR_IN
47408: IFFALSE 47534
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
47410: LD_ADDR_EXP 83
47414: PUSH
47415: LD_EXP 83
47419: PPUSH
47420: LD_VAR 0 1
47424: PPUSH
47425: LD_EXP 83
47429: PUSH
47430: LD_VAR 0 1
47434: ARRAY
47435: PPUSH
47436: LD_EXP 83
47440: PUSH
47441: LD_VAR 0 1
47445: ARRAY
47446: PUSH
47447: LD_INT 1
47449: PLUS
47450: PPUSH
47451: LD_VAR 0 5
47455: PUSH
47456: LD_INT 1
47458: ARRAY
47459: PUSH
47460: LD_VAR 0 7
47464: PUSH
47465: LD_INT 1
47467: ARRAY
47468: PUSH
47469: LD_VAR 0 7
47473: PUSH
47474: LD_INT 2
47476: ARRAY
47477: PUSH
47478: LD_VAR 0 7
47482: PUSH
47483: LD_INT 3
47485: ARRAY
47486: PUSH
47487: EMPTY
47488: LIST
47489: LIST
47490: LIST
47491: LIST
47492: PPUSH
47493: CALL_OW 2
47497: PPUSH
47498: CALL_OW 1
47502: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
47503: LD_ADDR_VAR 0 5
47507: PUSH
47508: LD_VAR 0 5
47512: PPUSH
47513: LD_INT 1
47515: PPUSH
47516: CALL_OW 3
47520: ST_TO_ADDR
// if not ext_list then
47521: LD_VAR 0 5
47525: NOT
47526: IFFALSE 47532
// exit ;
47528: POP
47529: POP
47530: GO 47536
// end ;
47532: GO 47407
47534: POP
47535: POP
// end ;
47536: LD_VAR 0 6
47540: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
47541: LD_INT 0
47543: PPUSH
// if not mc_bases or not base or not weapon_list then
47544: LD_EXP 78
47548: NOT
47549: PUSH
47550: LD_VAR 0 1
47554: NOT
47555: OR
47556: PUSH
47557: LD_VAR 0 2
47561: NOT
47562: OR
47563: IFFALSE 47567
// exit ;
47565: GO 47592
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
47567: LD_ADDR_EXP 117
47571: PUSH
47572: LD_EXP 117
47576: PPUSH
47577: LD_VAR 0 1
47581: PPUSH
47582: LD_VAR 0 2
47586: PPUSH
47587: CALL_OW 1
47591: ST_TO_ADDR
// end ;
47592: LD_VAR 0 3
47596: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
47597: LD_INT 0
47599: PPUSH
// if not mc_bases or not base or not tech_list then
47600: LD_EXP 78
47604: NOT
47605: PUSH
47606: LD_VAR 0 1
47610: NOT
47611: OR
47612: PUSH
47613: LD_VAR 0 2
47617: NOT
47618: OR
47619: IFFALSE 47623
// exit ;
47621: GO 47648
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
47623: LD_ADDR_EXP 105
47627: PUSH
47628: LD_EXP 105
47632: PPUSH
47633: LD_VAR 0 1
47637: PPUSH
47638: LD_VAR 0 2
47642: PPUSH
47643: CALL_OW 1
47647: ST_TO_ADDR
// end ;
47648: LD_VAR 0 3
47652: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
47653: LD_INT 0
47655: PPUSH
// if not mc_bases or not parking_area or not base then
47656: LD_EXP 78
47660: NOT
47661: PUSH
47662: LD_VAR 0 2
47666: NOT
47667: OR
47668: PUSH
47669: LD_VAR 0 1
47673: NOT
47674: OR
47675: IFFALSE 47679
// exit ;
47677: GO 47704
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
47679: LD_ADDR_EXP 102
47683: PUSH
47684: LD_EXP 102
47688: PPUSH
47689: LD_VAR 0 1
47693: PPUSH
47694: LD_VAR 0 2
47698: PPUSH
47699: CALL_OW 1
47703: ST_TO_ADDR
// end ;
47704: LD_VAR 0 3
47708: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
47709: LD_INT 0
47711: PPUSH
// if not mc_bases or not base or not scan_area then
47712: LD_EXP 78
47716: NOT
47717: PUSH
47718: LD_VAR 0 1
47722: NOT
47723: OR
47724: PUSH
47725: LD_VAR 0 2
47729: NOT
47730: OR
47731: IFFALSE 47735
// exit ;
47733: GO 47760
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
47735: LD_ADDR_EXP 103
47739: PUSH
47740: LD_EXP 103
47744: PPUSH
47745: LD_VAR 0 1
47749: PPUSH
47750: LD_VAR 0 2
47754: PPUSH
47755: CALL_OW 1
47759: ST_TO_ADDR
// end ;
47760: LD_VAR 0 3
47764: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
47765: LD_INT 0
47767: PPUSH
47768: PPUSH
// if not mc_bases or not base then
47769: LD_EXP 78
47773: NOT
47774: PUSH
47775: LD_VAR 0 1
47779: NOT
47780: OR
47781: IFFALSE 47785
// exit ;
47783: GO 47849
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
47785: LD_ADDR_VAR 0 3
47789: PUSH
47790: LD_INT 1
47792: PUSH
47793: LD_INT 2
47795: PUSH
47796: LD_INT 3
47798: PUSH
47799: LD_INT 4
47801: PUSH
47802: LD_INT 11
47804: PUSH
47805: EMPTY
47806: LIST
47807: LIST
47808: LIST
47809: LIST
47810: LIST
47811: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
47812: LD_ADDR_EXP 105
47816: PUSH
47817: LD_EXP 105
47821: PPUSH
47822: LD_VAR 0 1
47826: PPUSH
47827: LD_EXP 105
47831: PUSH
47832: LD_VAR 0 1
47836: ARRAY
47837: PUSH
47838: LD_VAR 0 3
47842: DIFF
47843: PPUSH
47844: CALL_OW 1
47848: ST_TO_ADDR
// end ;
47849: LD_VAR 0 2
47853: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47854: LD_INT 0
47856: PPUSH
// result := mc_vehicles [ base ] ;
47857: LD_ADDR_VAR 0 3
47861: PUSH
47862: LD_EXP 97
47866: PUSH
47867: LD_VAR 0 1
47871: ARRAY
47872: ST_TO_ADDR
// if onlyCombat then
47873: LD_VAR 0 2
47877: IFFALSE 48049
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47879: LD_ADDR_VAR 0 3
47883: PUSH
47884: LD_VAR 0 3
47888: PUSH
47889: LD_VAR 0 3
47893: PPUSH
47894: LD_INT 2
47896: PUSH
47897: LD_INT 34
47899: PUSH
47900: LD_INT 12
47902: PUSH
47903: EMPTY
47904: LIST
47905: LIST
47906: PUSH
47907: LD_INT 34
47909: PUSH
47910: LD_INT 51
47912: PUSH
47913: EMPTY
47914: LIST
47915: LIST
47916: PUSH
47917: LD_INT 34
47919: PUSH
47920: LD_INT 89
47922: PUSH
47923: EMPTY
47924: LIST
47925: LIST
47926: PUSH
47927: LD_INT 34
47929: PUSH
47930: LD_INT 32
47932: PUSH
47933: EMPTY
47934: LIST
47935: LIST
47936: PUSH
47937: LD_INT 34
47939: PUSH
47940: LD_INT 13
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 34
47949: PUSH
47950: LD_INT 52
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: LD_INT 34
47959: PUSH
47960: LD_INT 88
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: LD_INT 34
47969: PUSH
47970: LD_INT 14
47972: PUSH
47973: EMPTY
47974: LIST
47975: LIST
47976: PUSH
47977: LD_INT 34
47979: PUSH
47980: LD_INT 53
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 34
47989: PUSH
47990: LD_INT 98
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: LD_INT 34
47999: PUSH
48000: LD_INT 31
48002: PUSH
48003: EMPTY
48004: LIST
48005: LIST
48006: PUSH
48007: LD_INT 34
48009: PUSH
48010: LD_INT 48
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 34
48019: PUSH
48020: LD_INT 8
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: EMPTY
48028: LIST
48029: LIST
48030: LIST
48031: LIST
48032: LIST
48033: LIST
48034: LIST
48035: LIST
48036: LIST
48037: LIST
48038: LIST
48039: LIST
48040: LIST
48041: LIST
48042: PPUSH
48043: CALL_OW 72
48047: DIFF
48048: ST_TO_ADDR
// end ; end_of_file
48049: LD_VAR 0 3
48053: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
48054: LD_INT 0
48056: PPUSH
48057: PPUSH
48058: PPUSH
// if not mc_bases or not skirmish then
48059: LD_EXP 78
48063: NOT
48064: PUSH
48065: LD_EXP 76
48069: NOT
48070: OR
48071: IFFALSE 48075
// exit ;
48073: GO 48240
// for i = 1 to mc_bases do
48075: LD_ADDR_VAR 0 4
48079: PUSH
48080: DOUBLE
48081: LD_INT 1
48083: DEC
48084: ST_TO_ADDR
48085: LD_EXP 78
48089: PUSH
48090: FOR_TO
48091: IFFALSE 48238
// begin if sci in mc_bases [ i ] then
48093: LD_VAR 0 2
48097: PUSH
48098: LD_EXP 78
48102: PUSH
48103: LD_VAR 0 4
48107: ARRAY
48108: IN
48109: IFFALSE 48236
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
48111: LD_ADDR_EXP 107
48115: PUSH
48116: LD_EXP 107
48120: PPUSH
48121: LD_VAR 0 4
48125: PUSH
48126: LD_EXP 107
48130: PUSH
48131: LD_VAR 0 4
48135: ARRAY
48136: PUSH
48137: LD_INT 1
48139: PLUS
48140: PUSH
48141: EMPTY
48142: LIST
48143: LIST
48144: PPUSH
48145: LD_VAR 0 1
48149: PPUSH
48150: CALL 57824 0 3
48154: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
48155: LD_ADDR_VAR 0 5
48159: PUSH
48160: LD_EXP 78
48164: PUSH
48165: LD_VAR 0 4
48169: ARRAY
48170: PPUSH
48171: LD_INT 2
48173: PUSH
48174: LD_INT 30
48176: PUSH
48177: LD_INT 0
48179: PUSH
48180: EMPTY
48181: LIST
48182: LIST
48183: PUSH
48184: LD_INT 30
48186: PUSH
48187: LD_INT 1
48189: PUSH
48190: EMPTY
48191: LIST
48192: LIST
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: LIST
48198: PPUSH
48199: CALL_OW 72
48203: PPUSH
48204: LD_VAR 0 1
48208: PPUSH
48209: CALL_OW 74
48213: ST_TO_ADDR
// if tmp then
48214: LD_VAR 0 5
48218: IFFALSE 48234
// ComStandNearbyBuilding ( ape , tmp ) ;
48220: LD_VAR 0 1
48224: PPUSH
48225: LD_VAR 0 5
48229: PPUSH
48230: CALL 54426 0 2
// break ;
48234: GO 48238
// end ; end ;
48236: GO 48090
48238: POP
48239: POP
// end ;
48240: LD_VAR 0 3
48244: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
48245: LD_INT 0
48247: PPUSH
48248: PPUSH
48249: PPUSH
// if not mc_bases or not skirmish then
48250: LD_EXP 78
48254: NOT
48255: PUSH
48256: LD_EXP 76
48260: NOT
48261: OR
48262: IFFALSE 48266
// exit ;
48264: GO 48355
// for i = 1 to mc_bases do
48266: LD_ADDR_VAR 0 4
48270: PUSH
48271: DOUBLE
48272: LD_INT 1
48274: DEC
48275: ST_TO_ADDR
48276: LD_EXP 78
48280: PUSH
48281: FOR_TO
48282: IFFALSE 48353
// begin if building in mc_busy_turret_list [ i ] then
48284: LD_VAR 0 1
48288: PUSH
48289: LD_EXP 88
48293: PUSH
48294: LD_VAR 0 4
48298: ARRAY
48299: IN
48300: IFFALSE 48351
// begin tmp := mc_busy_turret_list [ i ] diff building ;
48302: LD_ADDR_VAR 0 5
48306: PUSH
48307: LD_EXP 88
48311: PUSH
48312: LD_VAR 0 4
48316: ARRAY
48317: PUSH
48318: LD_VAR 0 1
48322: DIFF
48323: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
48324: LD_ADDR_EXP 88
48328: PUSH
48329: LD_EXP 88
48333: PPUSH
48334: LD_VAR 0 4
48338: PPUSH
48339: LD_VAR 0 5
48343: PPUSH
48344: CALL_OW 1
48348: ST_TO_ADDR
// break ;
48349: GO 48353
// end ; end ;
48351: GO 48281
48353: POP
48354: POP
// end ;
48355: LD_VAR 0 3
48359: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
48360: LD_INT 0
48362: PPUSH
48363: PPUSH
48364: PPUSH
// if not mc_bases or not skirmish then
48365: LD_EXP 78
48369: NOT
48370: PUSH
48371: LD_EXP 76
48375: NOT
48376: OR
48377: IFFALSE 48381
// exit ;
48379: GO 48580
// for i = 1 to mc_bases do
48381: LD_ADDR_VAR 0 5
48385: PUSH
48386: DOUBLE
48387: LD_INT 1
48389: DEC
48390: ST_TO_ADDR
48391: LD_EXP 78
48395: PUSH
48396: FOR_TO
48397: IFFALSE 48578
// if building in mc_bases [ i ] then
48399: LD_VAR 0 1
48403: PUSH
48404: LD_EXP 78
48408: PUSH
48409: LD_VAR 0 5
48413: ARRAY
48414: IN
48415: IFFALSE 48576
// begin tmp := mc_bases [ i ] diff building ;
48417: LD_ADDR_VAR 0 6
48421: PUSH
48422: LD_EXP 78
48426: PUSH
48427: LD_VAR 0 5
48431: ARRAY
48432: PUSH
48433: LD_VAR 0 1
48437: DIFF
48438: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
48439: LD_ADDR_EXP 78
48443: PUSH
48444: LD_EXP 78
48448: PPUSH
48449: LD_VAR 0 5
48453: PPUSH
48454: LD_VAR 0 6
48458: PPUSH
48459: CALL_OW 1
48463: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
48464: LD_VAR 0 1
48468: PUSH
48469: LD_EXP 86
48473: PUSH
48474: LD_VAR 0 5
48478: ARRAY
48479: IN
48480: IFFALSE 48519
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
48482: LD_ADDR_EXP 86
48486: PUSH
48487: LD_EXP 86
48491: PPUSH
48492: LD_VAR 0 5
48496: PPUSH
48497: LD_EXP 86
48501: PUSH
48502: LD_VAR 0 5
48506: ARRAY
48507: PUSH
48508: LD_VAR 0 1
48512: DIFF
48513: PPUSH
48514: CALL_OW 1
48518: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
48519: LD_VAR 0 1
48523: PUSH
48524: LD_EXP 87
48528: PUSH
48529: LD_VAR 0 5
48533: ARRAY
48534: IN
48535: IFFALSE 48574
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
48537: LD_ADDR_EXP 87
48541: PUSH
48542: LD_EXP 87
48546: PPUSH
48547: LD_VAR 0 5
48551: PPUSH
48552: LD_EXP 87
48556: PUSH
48557: LD_VAR 0 5
48561: ARRAY
48562: PUSH
48563: LD_VAR 0 1
48567: DIFF
48568: PPUSH
48569: CALL_OW 1
48573: ST_TO_ADDR
// break ;
48574: GO 48578
// end ;
48576: GO 48396
48578: POP
48579: POP
// end ;
48580: LD_VAR 0 4
48584: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
48585: LD_INT 0
48587: PPUSH
48588: PPUSH
48589: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
48590: LD_EXP 78
48594: NOT
48595: PUSH
48596: LD_EXP 76
48600: NOT
48601: OR
48602: PUSH
48603: LD_VAR 0 3
48607: PUSH
48608: LD_EXP 104
48612: IN
48613: NOT
48614: OR
48615: IFFALSE 48619
// exit ;
48617: GO 48742
// for i = 1 to mc_vehicles do
48619: LD_ADDR_VAR 0 6
48623: PUSH
48624: DOUBLE
48625: LD_INT 1
48627: DEC
48628: ST_TO_ADDR
48629: LD_EXP 97
48633: PUSH
48634: FOR_TO
48635: IFFALSE 48740
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
48637: LD_VAR 0 2
48641: PUSH
48642: LD_EXP 97
48646: PUSH
48647: LD_VAR 0 6
48651: ARRAY
48652: IN
48653: PUSH
48654: LD_VAR 0 1
48658: PUSH
48659: LD_EXP 97
48663: PUSH
48664: LD_VAR 0 6
48668: ARRAY
48669: IN
48670: OR
48671: IFFALSE 48738
// begin tmp := mc_vehicles [ i ] diff old ;
48673: LD_ADDR_VAR 0 7
48677: PUSH
48678: LD_EXP 97
48682: PUSH
48683: LD_VAR 0 6
48687: ARRAY
48688: PUSH
48689: LD_VAR 0 2
48693: DIFF
48694: ST_TO_ADDR
// tmp := tmp diff new ;
48695: LD_ADDR_VAR 0 7
48699: PUSH
48700: LD_VAR 0 7
48704: PUSH
48705: LD_VAR 0 1
48709: DIFF
48710: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
48711: LD_ADDR_EXP 97
48715: PUSH
48716: LD_EXP 97
48720: PPUSH
48721: LD_VAR 0 6
48725: PPUSH
48726: LD_VAR 0 7
48730: PPUSH
48731: CALL_OW 1
48735: ST_TO_ADDR
// break ;
48736: GO 48740
// end ;
48738: GO 48634
48740: POP
48741: POP
// end ;
48742: LD_VAR 0 5
48746: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
48747: LD_INT 0
48749: PPUSH
48750: PPUSH
48751: PPUSH
48752: PPUSH
// if not mc_bases or not skirmish then
48753: LD_EXP 78
48757: NOT
48758: PUSH
48759: LD_EXP 76
48763: NOT
48764: OR
48765: IFFALSE 48769
// exit ;
48767: GO 49189
// repeat wait ( 0 0$1 ) ;
48769: LD_INT 35
48771: PPUSH
48772: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
48776: LD_EXP 122
48780: NOT
48781: IFFALSE 48769
// mc_block_vehicle_constructed_thread := true ;
48783: LD_ADDR_EXP 122
48787: PUSH
48788: LD_INT 1
48790: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
48791: LD_ADDR_VAR 0 5
48795: PUSH
48796: LD_VAR 0 1
48800: PPUSH
48801: CALL_OW 255
48805: ST_TO_ADDR
// for i = 1 to mc_bases do
48806: LD_ADDR_VAR 0 4
48810: PUSH
48811: DOUBLE
48812: LD_INT 1
48814: DEC
48815: ST_TO_ADDR
48816: LD_EXP 78
48820: PUSH
48821: FOR_TO
48822: IFFALSE 49179
// begin if factory in mc_bases [ i ] then
48824: LD_VAR 0 2
48828: PUSH
48829: LD_EXP 78
48833: PUSH
48834: LD_VAR 0 4
48838: ARRAY
48839: IN
48840: IFFALSE 49177
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48842: LD_EXP 100
48846: PUSH
48847: LD_VAR 0 4
48851: ARRAY
48852: PUSH
48853: LD_EXP 89
48857: PUSH
48858: LD_VAR 0 4
48862: ARRAY
48863: LESS
48864: PUSH
48865: LD_VAR 0 1
48869: PPUSH
48870: CALL_OW 264
48874: PUSH
48875: LD_INT 31
48877: PUSH
48878: LD_INT 32
48880: PUSH
48881: LD_INT 51
48883: PUSH
48884: LD_INT 89
48886: PUSH
48887: LD_INT 12
48889: PUSH
48890: LD_INT 30
48892: PUSH
48893: LD_INT 98
48895: PUSH
48896: LD_INT 11
48898: PUSH
48899: LD_INT 53
48901: PUSH
48902: LD_INT 14
48904: PUSH
48905: LD_INT 91
48907: PUSH
48908: LD_INT 29
48910: PUSH
48911: LD_INT 99
48913: PUSH
48914: LD_INT 13
48916: PUSH
48917: LD_INT 52
48919: PUSH
48920: LD_INT 88
48922: PUSH
48923: LD_INT 48
48925: PUSH
48926: LD_INT 8
48928: PUSH
48929: EMPTY
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: LIST
48939: LIST
48940: LIST
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: LIST
48947: LIST
48948: IN
48949: NOT
48950: AND
48951: IFFALSE 48999
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48953: LD_ADDR_EXP 100
48957: PUSH
48958: LD_EXP 100
48962: PPUSH
48963: LD_VAR 0 4
48967: PUSH
48968: LD_EXP 100
48972: PUSH
48973: LD_VAR 0 4
48977: ARRAY
48978: PUSH
48979: LD_INT 1
48981: PLUS
48982: PUSH
48983: EMPTY
48984: LIST
48985: LIST
48986: PPUSH
48987: LD_VAR 0 1
48991: PPUSH
48992: CALL 57824 0 3
48996: ST_TO_ADDR
48997: GO 49043
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48999: LD_ADDR_EXP 97
49003: PUSH
49004: LD_EXP 97
49008: PPUSH
49009: LD_VAR 0 4
49013: PUSH
49014: LD_EXP 97
49018: PUSH
49019: LD_VAR 0 4
49023: ARRAY
49024: PUSH
49025: LD_INT 1
49027: PLUS
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: PPUSH
49033: LD_VAR 0 1
49037: PPUSH
49038: CALL 57824 0 3
49042: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
49043: LD_ADDR_EXP 122
49047: PUSH
49048: LD_INT 0
49050: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
49051: LD_VAR 0 1
49055: PPUSH
49056: CALL_OW 263
49060: PUSH
49061: LD_INT 2
49063: EQUAL
49064: IFFALSE 49093
// begin repeat wait ( 0 0$3 ) ;
49066: LD_INT 105
49068: PPUSH
49069: CALL_OW 67
// Connect ( vehicle ) ;
49073: LD_VAR 0 1
49077: PPUSH
49078: CALL 60802 0 1
// until IsControledBy ( vehicle ) ;
49082: LD_VAR 0 1
49086: PPUSH
49087: CALL_OW 312
49091: IFFALSE 49066
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
49093: LD_VAR 0 1
49097: PPUSH
49098: LD_EXP 102
49102: PUSH
49103: LD_VAR 0 4
49107: ARRAY
49108: PPUSH
49109: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
49113: LD_VAR 0 1
49117: PPUSH
49118: CALL_OW 263
49122: PUSH
49123: LD_INT 1
49125: NONEQUAL
49126: IFFALSE 49130
// break ;
49128: GO 49179
// repeat wait ( 0 0$1 ) ;
49130: LD_INT 35
49132: PPUSH
49133: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
49137: LD_VAR 0 1
49141: PPUSH
49142: LD_EXP 102
49146: PUSH
49147: LD_VAR 0 4
49151: ARRAY
49152: PPUSH
49153: CALL_OW 308
49157: IFFALSE 49130
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
49159: LD_VAR 0 1
49163: PPUSH
49164: CALL_OW 311
49168: PPUSH
49169: CALL_OW 121
// exit ;
49173: POP
49174: POP
49175: GO 49189
// end ; end ;
49177: GO 48821
49179: POP
49180: POP
// mc_block_vehicle_constructed_thread := false ;
49181: LD_ADDR_EXP 122
49185: PUSH
49186: LD_INT 0
49188: ST_TO_ADDR
// end ;
49189: LD_VAR 0 3
49193: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
49194: LD_INT 0
49196: PPUSH
49197: PPUSH
49198: PPUSH
49199: PPUSH
// if not mc_bases or not skirmish then
49200: LD_EXP 78
49204: NOT
49205: PUSH
49206: LD_EXP 76
49210: NOT
49211: OR
49212: IFFALSE 49216
// exit ;
49214: GO 49569
// repeat wait ( 0 0$1 ) ;
49216: LD_INT 35
49218: PPUSH
49219: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
49223: LD_VAR 0 2
49227: PPUSH
49228: LD_VAR 0 3
49232: PPUSH
49233: CALL_OW 284
49237: IFFALSE 49216
// if GetResourceTypeXY ( x , y ) = mat_artefact then
49239: LD_VAR 0 2
49243: PPUSH
49244: LD_VAR 0 3
49248: PPUSH
49249: CALL_OW 283
49253: PUSH
49254: LD_INT 4
49256: EQUAL
49257: IFFALSE 49261
// exit ;
49259: GO 49569
// for i = 1 to mc_bases do
49261: LD_ADDR_VAR 0 7
49265: PUSH
49266: DOUBLE
49267: LD_INT 1
49269: DEC
49270: ST_TO_ADDR
49271: LD_EXP 78
49275: PUSH
49276: FOR_TO
49277: IFFALSE 49567
// begin if mc_crates_area [ i ] then
49279: LD_EXP 96
49283: PUSH
49284: LD_VAR 0 7
49288: ARRAY
49289: IFFALSE 49400
// for j in mc_crates_area [ i ] do
49291: LD_ADDR_VAR 0 8
49295: PUSH
49296: LD_EXP 96
49300: PUSH
49301: LD_VAR 0 7
49305: ARRAY
49306: PUSH
49307: FOR_IN
49308: IFFALSE 49398
// if InArea ( x , y , j ) then
49310: LD_VAR 0 2
49314: PPUSH
49315: LD_VAR 0 3
49319: PPUSH
49320: LD_VAR 0 8
49324: PPUSH
49325: CALL_OW 309
49329: IFFALSE 49396
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49331: LD_ADDR_EXP 94
49335: PUSH
49336: LD_EXP 94
49340: PPUSH
49341: LD_VAR 0 7
49345: PUSH
49346: LD_EXP 94
49350: PUSH
49351: LD_VAR 0 7
49355: ARRAY
49356: PUSH
49357: LD_INT 1
49359: PLUS
49360: PUSH
49361: EMPTY
49362: LIST
49363: LIST
49364: PPUSH
49365: LD_VAR 0 4
49369: PUSH
49370: LD_VAR 0 2
49374: PUSH
49375: LD_VAR 0 3
49379: PUSH
49380: EMPTY
49381: LIST
49382: LIST
49383: LIST
49384: PPUSH
49385: CALL 57824 0 3
49389: ST_TO_ADDR
// exit ;
49390: POP
49391: POP
49392: POP
49393: POP
49394: GO 49569
// end ;
49396: GO 49307
49398: POP
49399: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49400: LD_ADDR_VAR 0 9
49404: PUSH
49405: LD_EXP 78
49409: PUSH
49410: LD_VAR 0 7
49414: ARRAY
49415: PPUSH
49416: LD_INT 2
49418: PUSH
49419: LD_INT 30
49421: PUSH
49422: LD_INT 0
49424: PUSH
49425: EMPTY
49426: LIST
49427: LIST
49428: PUSH
49429: LD_INT 30
49431: PUSH
49432: LD_INT 1
49434: PUSH
49435: EMPTY
49436: LIST
49437: LIST
49438: PUSH
49439: EMPTY
49440: LIST
49441: LIST
49442: LIST
49443: PPUSH
49444: CALL_OW 72
49448: ST_TO_ADDR
// if not depot then
49449: LD_VAR 0 9
49453: NOT
49454: IFFALSE 49458
// continue ;
49456: GO 49276
// for j in depot do
49458: LD_ADDR_VAR 0 8
49462: PUSH
49463: LD_VAR 0 9
49467: PUSH
49468: FOR_IN
49469: IFFALSE 49563
// if GetDistUnitXY ( j , x , y ) < 30 then
49471: LD_VAR 0 8
49475: PPUSH
49476: LD_VAR 0 2
49480: PPUSH
49481: LD_VAR 0 3
49485: PPUSH
49486: CALL_OW 297
49490: PUSH
49491: LD_INT 30
49493: LESS
49494: IFFALSE 49561
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49496: LD_ADDR_EXP 94
49500: PUSH
49501: LD_EXP 94
49505: PPUSH
49506: LD_VAR 0 7
49510: PUSH
49511: LD_EXP 94
49515: PUSH
49516: LD_VAR 0 7
49520: ARRAY
49521: PUSH
49522: LD_INT 1
49524: PLUS
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PPUSH
49530: LD_VAR 0 4
49534: PUSH
49535: LD_VAR 0 2
49539: PUSH
49540: LD_VAR 0 3
49544: PUSH
49545: EMPTY
49546: LIST
49547: LIST
49548: LIST
49549: PPUSH
49550: CALL 57824 0 3
49554: ST_TO_ADDR
// exit ;
49555: POP
49556: POP
49557: POP
49558: POP
49559: GO 49569
// end ;
49561: GO 49468
49563: POP
49564: POP
// end ;
49565: GO 49276
49567: POP
49568: POP
// end ;
49569: LD_VAR 0 6
49573: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
49574: LD_INT 0
49576: PPUSH
49577: PPUSH
49578: PPUSH
49579: PPUSH
// if not mc_bases or not skirmish then
49580: LD_EXP 78
49584: NOT
49585: PUSH
49586: LD_EXP 76
49590: NOT
49591: OR
49592: IFFALSE 49596
// exit ;
49594: GO 49873
// side := GetSide ( lab ) ;
49596: LD_ADDR_VAR 0 4
49600: PUSH
49601: LD_VAR 0 2
49605: PPUSH
49606: CALL_OW 255
49610: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
49611: LD_VAR 0 4
49615: PUSH
49616: LD_EXP 104
49620: IN
49621: NOT
49622: PUSH
49623: LD_EXP 105
49627: NOT
49628: OR
49629: PUSH
49630: LD_EXP 78
49634: NOT
49635: OR
49636: IFFALSE 49640
// exit ;
49638: GO 49873
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
49640: LD_ADDR_EXP 105
49644: PUSH
49645: LD_EXP 105
49649: PPUSH
49650: LD_VAR 0 4
49654: PPUSH
49655: LD_EXP 105
49659: PUSH
49660: LD_VAR 0 4
49664: ARRAY
49665: PUSH
49666: LD_VAR 0 1
49670: DIFF
49671: PPUSH
49672: CALL_OW 1
49676: ST_TO_ADDR
// for i = 1 to mc_bases do
49677: LD_ADDR_VAR 0 5
49681: PUSH
49682: DOUBLE
49683: LD_INT 1
49685: DEC
49686: ST_TO_ADDR
49687: LD_EXP 78
49691: PUSH
49692: FOR_TO
49693: IFFALSE 49871
// begin if lab in mc_bases [ i ] then
49695: LD_VAR 0 2
49699: PUSH
49700: LD_EXP 78
49704: PUSH
49705: LD_VAR 0 5
49709: ARRAY
49710: IN
49711: IFFALSE 49869
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
49713: LD_VAR 0 1
49717: PUSH
49718: LD_INT 11
49720: PUSH
49721: LD_INT 4
49723: PUSH
49724: LD_INT 3
49726: PUSH
49727: LD_INT 2
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: LIST
49734: LIST
49735: IN
49736: PUSH
49737: LD_EXP 108
49741: PUSH
49742: LD_VAR 0 5
49746: ARRAY
49747: AND
49748: IFFALSE 49869
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
49750: LD_ADDR_VAR 0 6
49754: PUSH
49755: LD_EXP 108
49759: PUSH
49760: LD_VAR 0 5
49764: ARRAY
49765: PUSH
49766: LD_INT 1
49768: ARRAY
49769: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49770: LD_ADDR_EXP 108
49774: PUSH
49775: LD_EXP 108
49779: PPUSH
49780: LD_VAR 0 5
49784: PPUSH
49785: EMPTY
49786: PPUSH
49787: CALL_OW 1
49791: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
49792: LD_VAR 0 6
49796: PPUSH
49797: LD_INT 0
49799: PPUSH
49800: CALL_OW 109
// ComExitBuilding ( tmp ) ;
49804: LD_VAR 0 6
49808: PPUSH
49809: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
49813: LD_ADDR_EXP 107
49817: PUSH
49818: LD_EXP 107
49822: PPUSH
49823: LD_VAR 0 5
49827: PPUSH
49828: LD_EXP 107
49832: PUSH
49833: LD_VAR 0 5
49837: ARRAY
49838: PPUSH
49839: LD_INT 1
49841: PPUSH
49842: LD_VAR 0 6
49846: PPUSH
49847: CALL_OW 2
49851: PPUSH
49852: CALL_OW 1
49856: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49857: LD_VAR 0 5
49861: PPUSH
49862: LD_INT 112
49864: PPUSH
49865: CALL 26323 0 2
// end ; end ; end ;
49869: GO 49692
49871: POP
49872: POP
// end ;
49873: LD_VAR 0 3
49877: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49878: LD_INT 0
49880: PPUSH
49881: PPUSH
49882: PPUSH
49883: PPUSH
49884: PPUSH
49885: PPUSH
49886: PPUSH
49887: PPUSH
// if not mc_bases or not skirmish then
49888: LD_EXP 78
49892: NOT
49893: PUSH
49894: LD_EXP 76
49898: NOT
49899: OR
49900: IFFALSE 49904
// exit ;
49902: GO 51273
// for i = 1 to mc_bases do
49904: LD_ADDR_VAR 0 3
49908: PUSH
49909: DOUBLE
49910: LD_INT 1
49912: DEC
49913: ST_TO_ADDR
49914: LD_EXP 78
49918: PUSH
49919: FOR_TO
49920: IFFALSE 51271
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49922: LD_VAR 0 1
49926: PUSH
49927: LD_EXP 78
49931: PUSH
49932: LD_VAR 0 3
49936: ARRAY
49937: IN
49938: PUSH
49939: LD_VAR 0 1
49943: PUSH
49944: LD_EXP 85
49948: PUSH
49949: LD_VAR 0 3
49953: ARRAY
49954: IN
49955: OR
49956: PUSH
49957: LD_VAR 0 1
49961: PUSH
49962: LD_EXP 100
49966: PUSH
49967: LD_VAR 0 3
49971: ARRAY
49972: IN
49973: OR
49974: PUSH
49975: LD_VAR 0 1
49979: PUSH
49980: LD_EXP 97
49984: PUSH
49985: LD_VAR 0 3
49989: ARRAY
49990: IN
49991: OR
49992: PUSH
49993: LD_VAR 0 1
49997: PUSH
49998: LD_EXP 107
50002: PUSH
50003: LD_VAR 0 3
50007: ARRAY
50008: IN
50009: OR
50010: PUSH
50011: LD_VAR 0 1
50015: PUSH
50016: LD_EXP 108
50020: PUSH
50021: LD_VAR 0 3
50025: ARRAY
50026: IN
50027: OR
50028: IFFALSE 51269
// begin if un in mc_ape [ i ] then
50030: LD_VAR 0 1
50034: PUSH
50035: LD_EXP 107
50039: PUSH
50040: LD_VAR 0 3
50044: ARRAY
50045: IN
50046: IFFALSE 50085
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
50048: LD_ADDR_EXP 107
50052: PUSH
50053: LD_EXP 107
50057: PPUSH
50058: LD_VAR 0 3
50062: PPUSH
50063: LD_EXP 107
50067: PUSH
50068: LD_VAR 0 3
50072: ARRAY
50073: PUSH
50074: LD_VAR 0 1
50078: DIFF
50079: PPUSH
50080: CALL_OW 1
50084: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
50085: LD_VAR 0 1
50089: PUSH
50090: LD_EXP 108
50094: PUSH
50095: LD_VAR 0 3
50099: ARRAY
50100: IN
50101: IFFALSE 50125
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50103: LD_ADDR_EXP 108
50107: PUSH
50108: LD_EXP 108
50112: PPUSH
50113: LD_VAR 0 3
50117: PPUSH
50118: EMPTY
50119: PPUSH
50120: CALL_OW 1
50124: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
50125: LD_VAR 0 1
50129: PPUSH
50130: CALL_OW 247
50134: PUSH
50135: LD_INT 2
50137: EQUAL
50138: PUSH
50139: LD_VAR 0 1
50143: PPUSH
50144: CALL_OW 110
50148: PUSH
50149: LD_INT 20
50151: EQUAL
50152: PUSH
50153: LD_VAR 0 1
50157: PUSH
50158: LD_EXP 100
50162: PUSH
50163: LD_VAR 0 3
50167: ARRAY
50168: IN
50169: OR
50170: PUSH
50171: LD_VAR 0 1
50175: PPUSH
50176: CALL_OW 264
50180: PUSH
50181: LD_INT 12
50183: PUSH
50184: LD_INT 51
50186: PUSH
50187: LD_INT 89
50189: PUSH
50190: LD_INT 32
50192: PUSH
50193: LD_INT 13
50195: PUSH
50196: LD_INT 52
50198: PUSH
50199: LD_INT 31
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: LIST
50206: LIST
50207: LIST
50208: LIST
50209: LIST
50210: IN
50211: OR
50212: AND
50213: IFFALSE 50521
// begin if un in mc_defender [ i ] then
50215: LD_VAR 0 1
50219: PUSH
50220: LD_EXP 100
50224: PUSH
50225: LD_VAR 0 3
50229: ARRAY
50230: IN
50231: IFFALSE 50270
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50233: LD_ADDR_EXP 100
50237: PUSH
50238: LD_EXP 100
50242: PPUSH
50243: LD_VAR 0 3
50247: PPUSH
50248: LD_EXP 100
50252: PUSH
50253: LD_VAR 0 3
50257: ARRAY
50258: PUSH
50259: LD_VAR 0 1
50263: DIFF
50264: PPUSH
50265: CALL_OW 1
50269: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
50270: LD_ADDR_VAR 0 8
50274: PUSH
50275: LD_VAR 0 3
50279: PPUSH
50280: LD_INT 3
50282: PPUSH
50283: CALL 46891 0 2
50287: ST_TO_ADDR
// if fac then
50288: LD_VAR 0 8
50292: IFFALSE 50521
// begin for j in fac do
50294: LD_ADDR_VAR 0 4
50298: PUSH
50299: LD_VAR 0 8
50303: PUSH
50304: FOR_IN
50305: IFFALSE 50519
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
50307: LD_ADDR_VAR 0 9
50311: PUSH
50312: LD_VAR 0 8
50316: PPUSH
50317: LD_VAR 0 1
50321: PPUSH
50322: CALL_OW 265
50326: PPUSH
50327: LD_VAR 0 1
50331: PPUSH
50332: CALL_OW 262
50336: PPUSH
50337: LD_VAR 0 1
50341: PPUSH
50342: CALL_OW 263
50346: PPUSH
50347: LD_VAR 0 1
50351: PPUSH
50352: CALL_OW 264
50356: PPUSH
50357: CALL 55322 0 5
50361: ST_TO_ADDR
// if components then
50362: LD_VAR 0 9
50366: IFFALSE 50517
// begin if GetWeapon ( un ) = ar_control_tower then
50368: LD_VAR 0 1
50372: PPUSH
50373: CALL_OW 264
50377: PUSH
50378: LD_INT 31
50380: EQUAL
50381: IFFALSE 50498
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
50383: LD_VAR 0 1
50387: PPUSH
50388: CALL_OW 311
50392: PPUSH
50393: LD_INT 0
50395: PPUSH
50396: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
50400: LD_ADDR_EXP 118
50404: PUSH
50405: LD_EXP 118
50409: PPUSH
50410: LD_VAR 0 3
50414: PPUSH
50415: LD_EXP 118
50419: PUSH
50420: LD_VAR 0 3
50424: ARRAY
50425: PUSH
50426: LD_VAR 0 1
50430: PPUSH
50431: CALL_OW 311
50435: DIFF
50436: PPUSH
50437: CALL_OW 1
50441: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
50442: LD_ADDR_VAR 0 7
50446: PUSH
50447: LD_EXP 99
50451: PUSH
50452: LD_VAR 0 3
50456: ARRAY
50457: PPUSH
50458: LD_INT 1
50460: PPUSH
50461: LD_VAR 0 9
50465: PPUSH
50466: CALL_OW 2
50470: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50471: LD_ADDR_EXP 99
50475: PUSH
50476: LD_EXP 99
50480: PPUSH
50481: LD_VAR 0 3
50485: PPUSH
50486: LD_VAR 0 7
50490: PPUSH
50491: CALL_OW 1
50495: ST_TO_ADDR
// end else
50496: GO 50515
// MC_InsertProduceList ( i , [ components ] ) ;
50498: LD_VAR 0 3
50502: PPUSH
50503: LD_VAR 0 9
50507: PUSH
50508: EMPTY
50509: LIST
50510: PPUSH
50511: CALL 46436 0 2
// break ;
50515: GO 50519
// end ; end ;
50517: GO 50304
50519: POP
50520: POP
// end ; end ; if GetType ( un ) = unit_building then
50521: LD_VAR 0 1
50525: PPUSH
50526: CALL_OW 247
50530: PUSH
50531: LD_INT 3
50533: EQUAL
50534: IFFALSE 50937
// begin btype := GetBType ( un ) ;
50536: LD_ADDR_VAR 0 5
50540: PUSH
50541: LD_VAR 0 1
50545: PPUSH
50546: CALL_OW 266
50550: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
50551: LD_VAR 0 5
50555: PUSH
50556: LD_INT 29
50558: PUSH
50559: LD_INT 30
50561: PUSH
50562: EMPTY
50563: LIST
50564: LIST
50565: IN
50566: IFFALSE 50639
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
50568: LD_VAR 0 1
50572: PPUSH
50573: CALL_OW 250
50577: PPUSH
50578: LD_VAR 0 1
50582: PPUSH
50583: CALL_OW 251
50587: PPUSH
50588: LD_VAR 0 1
50592: PPUSH
50593: CALL_OW 255
50597: PPUSH
50598: CALL_OW 440
50602: NOT
50603: IFFALSE 50639
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
50605: LD_VAR 0 1
50609: PPUSH
50610: CALL_OW 250
50614: PPUSH
50615: LD_VAR 0 1
50619: PPUSH
50620: CALL_OW 251
50624: PPUSH
50625: LD_VAR 0 1
50629: PPUSH
50630: CALL_OW 255
50634: PPUSH
50635: CALL_OW 441
// end ; if btype = b_warehouse then
50639: LD_VAR 0 5
50643: PUSH
50644: LD_INT 1
50646: EQUAL
50647: IFFALSE 50665
// begin btype := b_depot ;
50649: LD_ADDR_VAR 0 5
50653: PUSH
50654: LD_INT 0
50656: ST_TO_ADDR
// pos := 1 ;
50657: LD_ADDR_VAR 0 6
50661: PUSH
50662: LD_INT 1
50664: ST_TO_ADDR
// end ; if btype = b_factory then
50665: LD_VAR 0 5
50669: PUSH
50670: LD_INT 3
50672: EQUAL
50673: IFFALSE 50691
// begin btype := b_workshop ;
50675: LD_ADDR_VAR 0 5
50679: PUSH
50680: LD_INT 2
50682: ST_TO_ADDR
// pos := 1 ;
50683: LD_ADDR_VAR 0 6
50687: PUSH
50688: LD_INT 1
50690: ST_TO_ADDR
// end ; if btype = b_barracks then
50691: LD_VAR 0 5
50695: PUSH
50696: LD_INT 5
50698: EQUAL
50699: IFFALSE 50709
// btype := b_armoury ;
50701: LD_ADDR_VAR 0 5
50705: PUSH
50706: LD_INT 4
50708: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
50709: LD_VAR 0 5
50713: PUSH
50714: LD_INT 7
50716: PUSH
50717: LD_INT 8
50719: PUSH
50720: EMPTY
50721: LIST
50722: LIST
50723: IN
50724: IFFALSE 50734
// btype := b_lab ;
50726: LD_ADDR_VAR 0 5
50730: PUSH
50731: LD_INT 6
50733: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
50734: LD_ADDR_EXP 83
50738: PUSH
50739: LD_EXP 83
50743: PPUSH
50744: LD_VAR 0 3
50748: PUSH
50749: LD_EXP 83
50753: PUSH
50754: LD_VAR 0 3
50758: ARRAY
50759: PUSH
50760: LD_INT 1
50762: PLUS
50763: PUSH
50764: EMPTY
50765: LIST
50766: LIST
50767: PPUSH
50768: LD_VAR 0 5
50772: PUSH
50773: LD_VAR 0 1
50777: PPUSH
50778: CALL_OW 250
50782: PUSH
50783: LD_VAR 0 1
50787: PPUSH
50788: CALL_OW 251
50792: PUSH
50793: LD_VAR 0 1
50797: PPUSH
50798: CALL_OW 254
50802: PUSH
50803: EMPTY
50804: LIST
50805: LIST
50806: LIST
50807: LIST
50808: PPUSH
50809: CALL 57824 0 3
50813: ST_TO_ADDR
// if pos = 1 then
50814: LD_VAR 0 6
50818: PUSH
50819: LD_INT 1
50821: EQUAL
50822: IFFALSE 50937
// begin tmp := mc_build_list [ i ] ;
50824: LD_ADDR_VAR 0 7
50828: PUSH
50829: LD_EXP 83
50833: PUSH
50834: LD_VAR 0 3
50838: ARRAY
50839: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50840: LD_VAR 0 7
50844: PPUSH
50845: LD_INT 2
50847: PUSH
50848: LD_INT 30
50850: PUSH
50851: LD_INT 0
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: PUSH
50858: LD_INT 30
50860: PUSH
50861: LD_INT 1
50863: PUSH
50864: EMPTY
50865: LIST
50866: LIST
50867: PUSH
50868: EMPTY
50869: LIST
50870: LIST
50871: LIST
50872: PPUSH
50873: CALL_OW 72
50877: IFFALSE 50887
// pos := 2 ;
50879: LD_ADDR_VAR 0 6
50883: PUSH
50884: LD_INT 2
50886: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50887: LD_ADDR_VAR 0 7
50891: PUSH
50892: LD_VAR 0 7
50896: PPUSH
50897: LD_VAR 0 6
50901: PPUSH
50902: LD_VAR 0 7
50906: PPUSH
50907: CALL 58150 0 3
50911: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50912: LD_ADDR_EXP 83
50916: PUSH
50917: LD_EXP 83
50921: PPUSH
50922: LD_VAR 0 3
50926: PPUSH
50927: LD_VAR 0 7
50931: PPUSH
50932: CALL_OW 1
50936: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50937: LD_VAR 0 1
50941: PUSH
50942: LD_EXP 78
50946: PUSH
50947: LD_VAR 0 3
50951: ARRAY
50952: IN
50953: IFFALSE 50992
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50955: LD_ADDR_EXP 78
50959: PUSH
50960: LD_EXP 78
50964: PPUSH
50965: LD_VAR 0 3
50969: PPUSH
50970: LD_EXP 78
50974: PUSH
50975: LD_VAR 0 3
50979: ARRAY
50980: PUSH
50981: LD_VAR 0 1
50985: DIFF
50986: PPUSH
50987: CALL_OW 1
50991: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50992: LD_VAR 0 1
50996: PUSH
50997: LD_EXP 85
51001: PUSH
51002: LD_VAR 0 3
51006: ARRAY
51007: IN
51008: IFFALSE 51047
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
51010: LD_ADDR_EXP 85
51014: PUSH
51015: LD_EXP 85
51019: PPUSH
51020: LD_VAR 0 3
51024: PPUSH
51025: LD_EXP 85
51029: PUSH
51030: LD_VAR 0 3
51034: ARRAY
51035: PUSH
51036: LD_VAR 0 1
51040: DIFF
51041: PPUSH
51042: CALL_OW 1
51046: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
51047: LD_VAR 0 1
51051: PUSH
51052: LD_EXP 97
51056: PUSH
51057: LD_VAR 0 3
51061: ARRAY
51062: IN
51063: IFFALSE 51102
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
51065: LD_ADDR_EXP 97
51069: PUSH
51070: LD_EXP 97
51074: PPUSH
51075: LD_VAR 0 3
51079: PPUSH
51080: LD_EXP 97
51084: PUSH
51085: LD_VAR 0 3
51089: ARRAY
51090: PUSH
51091: LD_VAR 0 1
51095: DIFF
51096: PPUSH
51097: CALL_OW 1
51101: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
51102: LD_VAR 0 1
51106: PUSH
51107: LD_EXP 100
51111: PUSH
51112: LD_VAR 0 3
51116: ARRAY
51117: IN
51118: IFFALSE 51157
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51120: LD_ADDR_EXP 100
51124: PUSH
51125: LD_EXP 100
51129: PPUSH
51130: LD_VAR 0 3
51134: PPUSH
51135: LD_EXP 100
51139: PUSH
51140: LD_VAR 0 3
51144: ARRAY
51145: PUSH
51146: LD_VAR 0 1
51150: DIFF
51151: PPUSH
51152: CALL_OW 1
51156: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
51157: LD_VAR 0 1
51161: PUSH
51162: LD_EXP 87
51166: PUSH
51167: LD_VAR 0 3
51171: ARRAY
51172: IN
51173: IFFALSE 51212
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
51175: LD_ADDR_EXP 87
51179: PUSH
51180: LD_EXP 87
51184: PPUSH
51185: LD_VAR 0 3
51189: PPUSH
51190: LD_EXP 87
51194: PUSH
51195: LD_VAR 0 3
51199: ARRAY
51200: PUSH
51201: LD_VAR 0 1
51205: DIFF
51206: PPUSH
51207: CALL_OW 1
51211: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
51212: LD_VAR 0 1
51216: PUSH
51217: LD_EXP 86
51221: PUSH
51222: LD_VAR 0 3
51226: ARRAY
51227: IN
51228: IFFALSE 51267
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
51230: LD_ADDR_EXP 86
51234: PUSH
51235: LD_EXP 86
51239: PPUSH
51240: LD_VAR 0 3
51244: PPUSH
51245: LD_EXP 86
51249: PUSH
51250: LD_VAR 0 3
51254: ARRAY
51255: PUSH
51256: LD_VAR 0 1
51260: DIFF
51261: PPUSH
51262: CALL_OW 1
51266: ST_TO_ADDR
// end ; break ;
51267: GO 51271
// end ;
51269: GO 49919
51271: POP
51272: POP
// end ;
51273: LD_VAR 0 2
51277: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
51278: LD_INT 0
51280: PPUSH
51281: PPUSH
51282: PPUSH
// if not mc_bases or not skirmish then
51283: LD_EXP 78
51287: NOT
51288: PUSH
51289: LD_EXP 76
51293: NOT
51294: OR
51295: IFFALSE 51299
// exit ;
51297: GO 51514
// for i = 1 to mc_bases do
51299: LD_ADDR_VAR 0 3
51303: PUSH
51304: DOUBLE
51305: LD_INT 1
51307: DEC
51308: ST_TO_ADDR
51309: LD_EXP 78
51313: PUSH
51314: FOR_TO
51315: IFFALSE 51512
// begin if building in mc_construct_list [ i ] then
51317: LD_VAR 0 1
51321: PUSH
51322: LD_EXP 85
51326: PUSH
51327: LD_VAR 0 3
51331: ARRAY
51332: IN
51333: IFFALSE 51510
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51335: LD_ADDR_EXP 85
51339: PUSH
51340: LD_EXP 85
51344: PPUSH
51345: LD_VAR 0 3
51349: PPUSH
51350: LD_EXP 85
51354: PUSH
51355: LD_VAR 0 3
51359: ARRAY
51360: PUSH
51361: LD_VAR 0 1
51365: DIFF
51366: PPUSH
51367: CALL_OW 1
51371: ST_TO_ADDR
// if building in mc_lab [ i ] then
51372: LD_VAR 0 1
51376: PUSH
51377: LD_EXP 111
51381: PUSH
51382: LD_VAR 0 3
51386: ARRAY
51387: IN
51388: IFFALSE 51443
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
51390: LD_ADDR_EXP 112
51394: PUSH
51395: LD_EXP 112
51399: PPUSH
51400: LD_VAR 0 3
51404: PPUSH
51405: LD_EXP 112
51409: PUSH
51410: LD_VAR 0 3
51414: ARRAY
51415: PPUSH
51416: LD_INT 1
51418: PPUSH
51419: LD_EXP 112
51423: PUSH
51424: LD_VAR 0 3
51428: ARRAY
51429: PPUSH
51430: LD_INT 0
51432: PPUSH
51433: CALL 57242 0 4
51437: PPUSH
51438: CALL_OW 1
51442: ST_TO_ADDR
// if not building in mc_bases [ i ] then
51443: LD_VAR 0 1
51447: PUSH
51448: LD_EXP 78
51452: PUSH
51453: LD_VAR 0 3
51457: ARRAY
51458: IN
51459: NOT
51460: IFFALSE 51506
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51462: LD_ADDR_EXP 78
51466: PUSH
51467: LD_EXP 78
51471: PPUSH
51472: LD_VAR 0 3
51476: PUSH
51477: LD_EXP 78
51481: PUSH
51482: LD_VAR 0 3
51486: ARRAY
51487: PUSH
51488: LD_INT 1
51490: PLUS
51491: PUSH
51492: EMPTY
51493: LIST
51494: LIST
51495: PPUSH
51496: LD_VAR 0 1
51500: PPUSH
51501: CALL 57824 0 3
51505: ST_TO_ADDR
// exit ;
51506: POP
51507: POP
51508: GO 51514
// end ; end ;
51510: GO 51314
51512: POP
51513: POP
// end ;
51514: LD_VAR 0 2
51518: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
51519: LD_INT 0
51521: PPUSH
51522: PPUSH
51523: PPUSH
51524: PPUSH
51525: PPUSH
51526: PPUSH
51527: PPUSH
// if not mc_bases or not skirmish then
51528: LD_EXP 78
51532: NOT
51533: PUSH
51534: LD_EXP 76
51538: NOT
51539: OR
51540: IFFALSE 51544
// exit ;
51542: GO 52205
// for i = 1 to mc_bases do
51544: LD_ADDR_VAR 0 3
51548: PUSH
51549: DOUBLE
51550: LD_INT 1
51552: DEC
51553: ST_TO_ADDR
51554: LD_EXP 78
51558: PUSH
51559: FOR_TO
51560: IFFALSE 52203
// begin if building in mc_construct_list [ i ] then
51562: LD_VAR 0 1
51566: PUSH
51567: LD_EXP 85
51571: PUSH
51572: LD_VAR 0 3
51576: ARRAY
51577: IN
51578: IFFALSE 52201
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51580: LD_ADDR_EXP 85
51584: PUSH
51585: LD_EXP 85
51589: PPUSH
51590: LD_VAR 0 3
51594: PPUSH
51595: LD_EXP 85
51599: PUSH
51600: LD_VAR 0 3
51604: ARRAY
51605: PUSH
51606: LD_VAR 0 1
51610: DIFF
51611: PPUSH
51612: CALL_OW 1
51616: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
51617: LD_ADDR_EXP 78
51621: PUSH
51622: LD_EXP 78
51626: PPUSH
51627: LD_VAR 0 3
51631: PUSH
51632: LD_EXP 78
51636: PUSH
51637: LD_VAR 0 3
51641: ARRAY
51642: PUSH
51643: LD_INT 1
51645: PLUS
51646: PUSH
51647: EMPTY
51648: LIST
51649: LIST
51650: PPUSH
51651: LD_VAR 0 1
51655: PPUSH
51656: CALL 57824 0 3
51660: ST_TO_ADDR
// btype := GetBType ( building ) ;
51661: LD_ADDR_VAR 0 5
51665: PUSH
51666: LD_VAR 0 1
51670: PPUSH
51671: CALL_OW 266
51675: ST_TO_ADDR
// side := GetSide ( building ) ;
51676: LD_ADDR_VAR 0 8
51680: PUSH
51681: LD_VAR 0 1
51685: PPUSH
51686: CALL_OW 255
51690: ST_TO_ADDR
// if btype = b_lab then
51691: LD_VAR 0 5
51695: PUSH
51696: LD_INT 6
51698: EQUAL
51699: IFFALSE 51749
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
51701: LD_ADDR_EXP 111
51705: PUSH
51706: LD_EXP 111
51710: PPUSH
51711: LD_VAR 0 3
51715: PUSH
51716: LD_EXP 111
51720: PUSH
51721: LD_VAR 0 3
51725: ARRAY
51726: PUSH
51727: LD_INT 1
51729: PLUS
51730: PUSH
51731: EMPTY
51732: LIST
51733: LIST
51734: PPUSH
51735: LD_VAR 0 1
51739: PPUSH
51740: CALL 57824 0 3
51744: ST_TO_ADDR
// exit ;
51745: POP
51746: POP
51747: GO 52205
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
51749: LD_VAR 0 5
51753: PUSH
51754: LD_INT 0
51756: PUSH
51757: LD_INT 2
51759: PUSH
51760: LD_INT 4
51762: PUSH
51763: EMPTY
51764: LIST
51765: LIST
51766: LIST
51767: IN
51768: IFFALSE 51892
// begin if btype = b_armoury then
51770: LD_VAR 0 5
51774: PUSH
51775: LD_INT 4
51777: EQUAL
51778: IFFALSE 51788
// btype := b_barracks ;
51780: LD_ADDR_VAR 0 5
51784: PUSH
51785: LD_INT 5
51787: ST_TO_ADDR
// if btype = b_depot then
51788: LD_VAR 0 5
51792: PUSH
51793: LD_INT 0
51795: EQUAL
51796: IFFALSE 51806
// btype := b_warehouse ;
51798: LD_ADDR_VAR 0 5
51802: PUSH
51803: LD_INT 1
51805: ST_TO_ADDR
// if btype = b_workshop then
51806: LD_VAR 0 5
51810: PUSH
51811: LD_INT 2
51813: EQUAL
51814: IFFALSE 51824
// btype := b_factory ;
51816: LD_ADDR_VAR 0 5
51820: PUSH
51821: LD_INT 3
51823: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
51824: LD_VAR 0 5
51828: PPUSH
51829: LD_VAR 0 8
51833: PPUSH
51834: CALL_OW 323
51838: PUSH
51839: LD_INT 1
51841: EQUAL
51842: IFFALSE 51888
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51844: LD_ADDR_EXP 110
51848: PUSH
51849: LD_EXP 110
51853: PPUSH
51854: LD_VAR 0 3
51858: PUSH
51859: LD_EXP 110
51863: PUSH
51864: LD_VAR 0 3
51868: ARRAY
51869: PUSH
51870: LD_INT 1
51872: PLUS
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: PPUSH
51878: LD_VAR 0 1
51882: PPUSH
51883: CALL 57824 0 3
51887: ST_TO_ADDR
// exit ;
51888: POP
51889: POP
51890: GO 52205
// end ; if btype in [ b_bunker , b_turret ] then
51892: LD_VAR 0 5
51896: PUSH
51897: LD_INT 32
51899: PUSH
51900: LD_INT 33
51902: PUSH
51903: EMPTY
51904: LIST
51905: LIST
51906: IN
51907: IFFALSE 52197
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51909: LD_ADDR_EXP 86
51913: PUSH
51914: LD_EXP 86
51918: PPUSH
51919: LD_VAR 0 3
51923: PUSH
51924: LD_EXP 86
51928: PUSH
51929: LD_VAR 0 3
51933: ARRAY
51934: PUSH
51935: LD_INT 1
51937: PLUS
51938: PUSH
51939: EMPTY
51940: LIST
51941: LIST
51942: PPUSH
51943: LD_VAR 0 1
51947: PPUSH
51948: CALL 57824 0 3
51952: ST_TO_ADDR
// if btype = b_bunker then
51953: LD_VAR 0 5
51957: PUSH
51958: LD_INT 32
51960: EQUAL
51961: IFFALSE 52197
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51963: LD_ADDR_EXP 87
51967: PUSH
51968: LD_EXP 87
51972: PPUSH
51973: LD_VAR 0 3
51977: PUSH
51978: LD_EXP 87
51982: PUSH
51983: LD_VAR 0 3
51987: ARRAY
51988: PUSH
51989: LD_INT 1
51991: PLUS
51992: PUSH
51993: EMPTY
51994: LIST
51995: LIST
51996: PPUSH
51997: LD_VAR 0 1
52001: PPUSH
52002: CALL 57824 0 3
52006: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
52007: LD_ADDR_VAR 0 6
52011: PUSH
52012: LD_EXP 78
52016: PUSH
52017: LD_VAR 0 3
52021: ARRAY
52022: PPUSH
52023: LD_INT 25
52025: PUSH
52026: LD_INT 1
52028: PUSH
52029: EMPTY
52030: LIST
52031: LIST
52032: PUSH
52033: LD_INT 3
52035: PUSH
52036: LD_INT 54
52038: PUSH
52039: EMPTY
52040: LIST
52041: PUSH
52042: EMPTY
52043: LIST
52044: LIST
52045: PUSH
52046: EMPTY
52047: LIST
52048: LIST
52049: PPUSH
52050: CALL_OW 72
52054: ST_TO_ADDR
// if tmp then
52055: LD_VAR 0 6
52059: IFFALSE 52065
// exit ;
52061: POP
52062: POP
52063: GO 52205
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52065: LD_ADDR_VAR 0 6
52069: PUSH
52070: LD_EXP 78
52074: PUSH
52075: LD_VAR 0 3
52079: ARRAY
52080: PPUSH
52081: LD_INT 2
52083: PUSH
52084: LD_INT 30
52086: PUSH
52087: LD_INT 4
52089: PUSH
52090: EMPTY
52091: LIST
52092: LIST
52093: PUSH
52094: LD_INT 30
52096: PUSH
52097: LD_INT 5
52099: PUSH
52100: EMPTY
52101: LIST
52102: LIST
52103: PUSH
52104: EMPTY
52105: LIST
52106: LIST
52107: LIST
52108: PPUSH
52109: CALL_OW 72
52113: ST_TO_ADDR
// if not tmp then
52114: LD_VAR 0 6
52118: NOT
52119: IFFALSE 52125
// exit ;
52121: POP
52122: POP
52123: GO 52205
// for j in tmp do
52125: LD_ADDR_VAR 0 4
52129: PUSH
52130: LD_VAR 0 6
52134: PUSH
52135: FOR_IN
52136: IFFALSE 52195
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
52138: LD_ADDR_VAR 0 7
52142: PUSH
52143: LD_VAR 0 4
52147: PPUSH
52148: CALL_OW 313
52152: PPUSH
52153: LD_INT 25
52155: PUSH
52156: LD_INT 1
52158: PUSH
52159: EMPTY
52160: LIST
52161: LIST
52162: PPUSH
52163: CALL_OW 72
52167: ST_TO_ADDR
// if units then
52168: LD_VAR 0 7
52172: IFFALSE 52193
// begin ComExitBuilding ( units [ 1 ] ) ;
52174: LD_VAR 0 7
52178: PUSH
52179: LD_INT 1
52181: ARRAY
52182: PPUSH
52183: CALL_OW 122
// exit ;
52187: POP
52188: POP
52189: POP
52190: POP
52191: GO 52205
// end ; end ;
52193: GO 52135
52195: POP
52196: POP
// end ; end ; exit ;
52197: POP
52198: POP
52199: GO 52205
// end ; end ;
52201: GO 51559
52203: POP
52204: POP
// end ;
52205: LD_VAR 0 2
52209: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
52210: LD_INT 0
52212: PPUSH
52213: PPUSH
52214: PPUSH
52215: PPUSH
52216: PPUSH
52217: PPUSH
52218: PPUSH
// if not mc_bases or not skirmish then
52219: LD_EXP 78
52223: NOT
52224: PUSH
52225: LD_EXP 76
52229: NOT
52230: OR
52231: IFFALSE 52235
// exit ;
52233: GO 52500
// btype := GetBType ( building ) ;
52235: LD_ADDR_VAR 0 6
52239: PUSH
52240: LD_VAR 0 1
52244: PPUSH
52245: CALL_OW 266
52249: ST_TO_ADDR
// x := GetX ( building ) ;
52250: LD_ADDR_VAR 0 7
52254: PUSH
52255: LD_VAR 0 1
52259: PPUSH
52260: CALL_OW 250
52264: ST_TO_ADDR
// y := GetY ( building ) ;
52265: LD_ADDR_VAR 0 8
52269: PUSH
52270: LD_VAR 0 1
52274: PPUSH
52275: CALL_OW 251
52279: ST_TO_ADDR
// d := GetDir ( building ) ;
52280: LD_ADDR_VAR 0 9
52284: PUSH
52285: LD_VAR 0 1
52289: PPUSH
52290: CALL_OW 254
52294: ST_TO_ADDR
// for i = 1 to mc_bases do
52295: LD_ADDR_VAR 0 4
52299: PUSH
52300: DOUBLE
52301: LD_INT 1
52303: DEC
52304: ST_TO_ADDR
52305: LD_EXP 78
52309: PUSH
52310: FOR_TO
52311: IFFALSE 52498
// begin if not mc_build_list [ i ] then
52313: LD_EXP 83
52317: PUSH
52318: LD_VAR 0 4
52322: ARRAY
52323: NOT
52324: IFFALSE 52328
// continue ;
52326: GO 52310
// for j := 1 to mc_build_list [ i ] do
52328: LD_ADDR_VAR 0 5
52332: PUSH
52333: DOUBLE
52334: LD_INT 1
52336: DEC
52337: ST_TO_ADDR
52338: LD_EXP 83
52342: PUSH
52343: LD_VAR 0 4
52347: ARRAY
52348: PUSH
52349: FOR_TO
52350: IFFALSE 52494
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
52352: LD_VAR 0 6
52356: PUSH
52357: LD_VAR 0 7
52361: PUSH
52362: LD_VAR 0 8
52366: PUSH
52367: LD_VAR 0 9
52371: PUSH
52372: EMPTY
52373: LIST
52374: LIST
52375: LIST
52376: LIST
52377: PPUSH
52378: LD_EXP 83
52382: PUSH
52383: LD_VAR 0 4
52387: ARRAY
52388: PUSH
52389: LD_VAR 0 5
52393: ARRAY
52394: PPUSH
52395: CALL 64013 0 2
52399: IFFALSE 52492
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
52401: LD_ADDR_EXP 83
52405: PUSH
52406: LD_EXP 83
52410: PPUSH
52411: LD_VAR 0 4
52415: PPUSH
52416: LD_EXP 83
52420: PUSH
52421: LD_VAR 0 4
52425: ARRAY
52426: PPUSH
52427: LD_VAR 0 5
52431: PPUSH
52432: CALL_OW 3
52436: PPUSH
52437: CALL_OW 1
52441: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
52442: LD_ADDR_EXP 85
52446: PUSH
52447: LD_EXP 85
52451: PPUSH
52452: LD_VAR 0 4
52456: PUSH
52457: LD_EXP 85
52461: PUSH
52462: LD_VAR 0 4
52466: ARRAY
52467: PUSH
52468: LD_INT 1
52470: PLUS
52471: PUSH
52472: EMPTY
52473: LIST
52474: LIST
52475: PPUSH
52476: LD_VAR 0 1
52480: PPUSH
52481: CALL 57824 0 3
52485: ST_TO_ADDR
// exit ;
52486: POP
52487: POP
52488: POP
52489: POP
52490: GO 52500
// end ;
52492: GO 52349
52494: POP
52495: POP
// end ;
52496: GO 52310
52498: POP
52499: POP
// end ;
52500: LD_VAR 0 3
52504: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
52505: LD_INT 0
52507: PPUSH
52508: PPUSH
52509: PPUSH
// if not mc_bases or not skirmish then
52510: LD_EXP 78
52514: NOT
52515: PUSH
52516: LD_EXP 76
52520: NOT
52521: OR
52522: IFFALSE 52526
// exit ;
52524: GO 52716
// for i = 1 to mc_bases do
52526: LD_ADDR_VAR 0 4
52530: PUSH
52531: DOUBLE
52532: LD_INT 1
52534: DEC
52535: ST_TO_ADDR
52536: LD_EXP 78
52540: PUSH
52541: FOR_TO
52542: IFFALSE 52629
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
52544: LD_VAR 0 1
52548: PUSH
52549: LD_EXP 86
52553: PUSH
52554: LD_VAR 0 4
52558: ARRAY
52559: IN
52560: PUSH
52561: LD_VAR 0 1
52565: PUSH
52566: LD_EXP 87
52570: PUSH
52571: LD_VAR 0 4
52575: ARRAY
52576: IN
52577: NOT
52578: AND
52579: IFFALSE 52627
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52581: LD_ADDR_EXP 87
52585: PUSH
52586: LD_EXP 87
52590: PPUSH
52591: LD_VAR 0 4
52595: PUSH
52596: LD_EXP 87
52600: PUSH
52601: LD_VAR 0 4
52605: ARRAY
52606: PUSH
52607: LD_INT 1
52609: PLUS
52610: PUSH
52611: EMPTY
52612: LIST
52613: LIST
52614: PPUSH
52615: LD_VAR 0 1
52619: PPUSH
52620: CALL 57824 0 3
52624: ST_TO_ADDR
// break ;
52625: GO 52629
// end ; end ;
52627: GO 52541
52629: POP
52630: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
52631: LD_VAR 0 1
52635: PPUSH
52636: CALL_OW 257
52640: PUSH
52641: LD_EXP 104
52645: IN
52646: PUSH
52647: LD_VAR 0 1
52651: PPUSH
52652: CALL_OW 266
52656: PUSH
52657: LD_INT 5
52659: EQUAL
52660: AND
52661: PUSH
52662: LD_VAR 0 2
52666: PPUSH
52667: CALL_OW 110
52671: PUSH
52672: LD_INT 18
52674: NONEQUAL
52675: AND
52676: IFFALSE 52716
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
52678: LD_VAR 0 2
52682: PPUSH
52683: CALL_OW 257
52687: PUSH
52688: LD_INT 5
52690: PUSH
52691: LD_INT 8
52693: PUSH
52694: LD_INT 9
52696: PUSH
52697: EMPTY
52698: LIST
52699: LIST
52700: LIST
52701: IN
52702: IFFALSE 52716
// SetClass ( unit , 1 ) ;
52704: LD_VAR 0 2
52708: PPUSH
52709: LD_INT 1
52711: PPUSH
52712: CALL_OW 336
// end ;
52716: LD_VAR 0 3
52720: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
52721: LD_INT 0
52723: PPUSH
52724: PPUSH
// if not mc_bases or not skirmish then
52725: LD_EXP 78
52729: NOT
52730: PUSH
52731: LD_EXP 76
52735: NOT
52736: OR
52737: IFFALSE 52741
// exit ;
52739: GO 52857
// if GetLives ( abandoned_vehicle ) > 250 then
52741: LD_VAR 0 2
52745: PPUSH
52746: CALL_OW 256
52750: PUSH
52751: LD_INT 250
52753: GREATER
52754: IFFALSE 52758
// exit ;
52756: GO 52857
// for i = 1 to mc_bases do
52758: LD_ADDR_VAR 0 6
52762: PUSH
52763: DOUBLE
52764: LD_INT 1
52766: DEC
52767: ST_TO_ADDR
52768: LD_EXP 78
52772: PUSH
52773: FOR_TO
52774: IFFALSE 52855
// begin if driver in mc_bases [ i ] then
52776: LD_VAR 0 1
52780: PUSH
52781: LD_EXP 78
52785: PUSH
52786: LD_VAR 0 6
52790: ARRAY
52791: IN
52792: IFFALSE 52853
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
52794: LD_VAR 0 1
52798: PPUSH
52799: LD_EXP 78
52803: PUSH
52804: LD_VAR 0 6
52808: ARRAY
52809: PPUSH
52810: LD_INT 2
52812: PUSH
52813: LD_INT 30
52815: PUSH
52816: LD_INT 0
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: PUSH
52823: LD_INT 30
52825: PUSH
52826: LD_INT 1
52828: PUSH
52829: EMPTY
52830: LIST
52831: LIST
52832: PUSH
52833: EMPTY
52834: LIST
52835: LIST
52836: LIST
52837: PPUSH
52838: CALL_OW 72
52842: PUSH
52843: LD_INT 1
52845: ARRAY
52846: PPUSH
52847: CALL 91060 0 2
// break ;
52851: GO 52855
// end ; end ;
52853: GO 52773
52855: POP
52856: POP
// end ; end_of_file
52857: LD_VAR 0 5
52861: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52862: LD_INT 0
52864: PPUSH
52865: PPUSH
// if exist_mode then
52866: LD_VAR 0 2
52870: IFFALSE 52895
// unit := CreateCharacter ( prefix & ident ) else
52872: LD_ADDR_VAR 0 5
52876: PUSH
52877: LD_VAR 0 3
52881: PUSH
52882: LD_VAR 0 1
52886: STR
52887: PPUSH
52888: CALL_OW 34
52892: ST_TO_ADDR
52893: GO 52910
// unit := NewCharacter ( ident ) ;
52895: LD_ADDR_VAR 0 5
52899: PUSH
52900: LD_VAR 0 1
52904: PPUSH
52905: CALL_OW 25
52909: ST_TO_ADDR
// result := unit ;
52910: LD_ADDR_VAR 0 4
52914: PUSH
52915: LD_VAR 0 5
52919: ST_TO_ADDR
// end ;
52920: LD_VAR 0 4
52924: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52925: LD_INT 0
52927: PPUSH
52928: PPUSH
// if not side or not nation then
52929: LD_VAR 0 1
52933: NOT
52934: PUSH
52935: LD_VAR 0 2
52939: NOT
52940: OR
52941: IFFALSE 52945
// exit ;
52943: GO 53713
// case nation of nation_american :
52945: LD_VAR 0 2
52949: PUSH
52950: LD_INT 1
52952: DOUBLE
52953: EQUAL
52954: IFTRUE 52958
52956: GO 53172
52958: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52959: LD_ADDR_VAR 0 4
52963: PUSH
52964: LD_INT 35
52966: PUSH
52967: LD_INT 45
52969: PUSH
52970: LD_INT 46
52972: PUSH
52973: LD_INT 47
52975: PUSH
52976: LD_INT 82
52978: PUSH
52979: LD_INT 83
52981: PUSH
52982: LD_INT 84
52984: PUSH
52985: LD_INT 85
52987: PUSH
52988: LD_INT 86
52990: PUSH
52991: LD_INT 1
52993: PUSH
52994: LD_INT 2
52996: PUSH
52997: LD_INT 6
52999: PUSH
53000: LD_INT 15
53002: PUSH
53003: LD_INT 16
53005: PUSH
53006: LD_INT 7
53008: PUSH
53009: LD_INT 12
53011: PUSH
53012: LD_INT 13
53014: PUSH
53015: LD_INT 10
53017: PUSH
53018: LD_INT 14
53020: PUSH
53021: LD_INT 20
53023: PUSH
53024: LD_INT 21
53026: PUSH
53027: LD_INT 22
53029: PUSH
53030: LD_INT 25
53032: PUSH
53033: LD_INT 32
53035: PUSH
53036: LD_INT 27
53038: PUSH
53039: LD_INT 36
53041: PUSH
53042: LD_INT 69
53044: PUSH
53045: LD_INT 39
53047: PUSH
53048: LD_INT 34
53050: PUSH
53051: LD_INT 40
53053: PUSH
53054: LD_INT 48
53056: PUSH
53057: LD_INT 49
53059: PUSH
53060: LD_INT 50
53062: PUSH
53063: LD_INT 51
53065: PUSH
53066: LD_INT 52
53068: PUSH
53069: LD_INT 53
53071: PUSH
53072: LD_INT 54
53074: PUSH
53075: LD_INT 55
53077: PUSH
53078: LD_INT 56
53080: PUSH
53081: LD_INT 57
53083: PUSH
53084: LD_INT 58
53086: PUSH
53087: LD_INT 59
53089: PUSH
53090: LD_INT 60
53092: PUSH
53093: LD_INT 61
53095: PUSH
53096: LD_INT 62
53098: PUSH
53099: LD_INT 80
53101: PUSH
53102: LD_INT 82
53104: PUSH
53105: LD_INT 83
53107: PUSH
53108: LD_INT 84
53110: PUSH
53111: LD_INT 85
53113: PUSH
53114: LD_INT 86
53116: PUSH
53117: EMPTY
53118: LIST
53119: LIST
53120: LIST
53121: LIST
53122: LIST
53123: LIST
53124: LIST
53125: LIST
53126: LIST
53127: LIST
53128: LIST
53129: LIST
53130: LIST
53131: LIST
53132: LIST
53133: LIST
53134: LIST
53135: LIST
53136: LIST
53137: LIST
53138: LIST
53139: LIST
53140: LIST
53141: LIST
53142: LIST
53143: LIST
53144: LIST
53145: LIST
53146: LIST
53147: LIST
53148: LIST
53149: LIST
53150: LIST
53151: LIST
53152: LIST
53153: LIST
53154: LIST
53155: LIST
53156: LIST
53157: LIST
53158: LIST
53159: LIST
53160: LIST
53161: LIST
53162: LIST
53163: LIST
53164: LIST
53165: LIST
53166: LIST
53167: LIST
53168: LIST
53169: ST_TO_ADDR
53170: GO 53637
53172: LD_INT 2
53174: DOUBLE
53175: EQUAL
53176: IFTRUE 53180
53178: GO 53406
53180: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
53181: LD_ADDR_VAR 0 4
53185: PUSH
53186: LD_INT 35
53188: PUSH
53189: LD_INT 45
53191: PUSH
53192: LD_INT 46
53194: PUSH
53195: LD_INT 47
53197: PUSH
53198: LD_INT 82
53200: PUSH
53201: LD_INT 83
53203: PUSH
53204: LD_INT 84
53206: PUSH
53207: LD_INT 85
53209: PUSH
53210: LD_INT 87
53212: PUSH
53213: LD_INT 70
53215: PUSH
53216: LD_INT 1
53218: PUSH
53219: LD_INT 11
53221: PUSH
53222: LD_INT 3
53224: PUSH
53225: LD_INT 4
53227: PUSH
53228: LD_INT 5
53230: PUSH
53231: LD_INT 6
53233: PUSH
53234: LD_INT 15
53236: PUSH
53237: LD_INT 18
53239: PUSH
53240: LD_INT 7
53242: PUSH
53243: LD_INT 17
53245: PUSH
53246: LD_INT 8
53248: PUSH
53249: LD_INT 20
53251: PUSH
53252: LD_INT 21
53254: PUSH
53255: LD_INT 22
53257: PUSH
53258: LD_INT 72
53260: PUSH
53261: LD_INT 26
53263: PUSH
53264: LD_INT 69
53266: PUSH
53267: LD_INT 39
53269: PUSH
53270: LD_INT 40
53272: PUSH
53273: LD_INT 41
53275: PUSH
53276: LD_INT 42
53278: PUSH
53279: LD_INT 43
53281: PUSH
53282: LD_INT 48
53284: PUSH
53285: LD_INT 49
53287: PUSH
53288: LD_INT 50
53290: PUSH
53291: LD_INT 51
53293: PUSH
53294: LD_INT 52
53296: PUSH
53297: LD_INT 53
53299: PUSH
53300: LD_INT 54
53302: PUSH
53303: LD_INT 55
53305: PUSH
53306: LD_INT 56
53308: PUSH
53309: LD_INT 60
53311: PUSH
53312: LD_INT 61
53314: PUSH
53315: LD_INT 62
53317: PUSH
53318: LD_INT 66
53320: PUSH
53321: LD_INT 67
53323: PUSH
53324: LD_INT 68
53326: PUSH
53327: LD_INT 81
53329: PUSH
53330: LD_INT 82
53332: PUSH
53333: LD_INT 83
53335: PUSH
53336: LD_INT 84
53338: PUSH
53339: LD_INT 85
53341: PUSH
53342: LD_INT 87
53344: PUSH
53345: LD_INT 88
53347: PUSH
53348: EMPTY
53349: LIST
53350: LIST
53351: LIST
53352: LIST
53353: LIST
53354: LIST
53355: LIST
53356: LIST
53357: LIST
53358: LIST
53359: LIST
53360: LIST
53361: LIST
53362: LIST
53363: LIST
53364: LIST
53365: LIST
53366: LIST
53367: LIST
53368: LIST
53369: LIST
53370: LIST
53371: LIST
53372: LIST
53373: LIST
53374: LIST
53375: LIST
53376: LIST
53377: LIST
53378: LIST
53379: LIST
53380: LIST
53381: LIST
53382: LIST
53383: LIST
53384: LIST
53385: LIST
53386: LIST
53387: LIST
53388: LIST
53389: LIST
53390: LIST
53391: LIST
53392: LIST
53393: LIST
53394: LIST
53395: LIST
53396: LIST
53397: LIST
53398: LIST
53399: LIST
53400: LIST
53401: LIST
53402: LIST
53403: ST_TO_ADDR
53404: GO 53637
53406: LD_INT 3
53408: DOUBLE
53409: EQUAL
53410: IFTRUE 53414
53412: GO 53636
53414: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
53415: LD_ADDR_VAR 0 4
53419: PUSH
53420: LD_INT 46
53422: PUSH
53423: LD_INT 47
53425: PUSH
53426: LD_INT 1
53428: PUSH
53429: LD_INT 2
53431: PUSH
53432: LD_INT 82
53434: PUSH
53435: LD_INT 83
53437: PUSH
53438: LD_INT 84
53440: PUSH
53441: LD_INT 85
53443: PUSH
53444: LD_INT 86
53446: PUSH
53447: LD_INT 11
53449: PUSH
53450: LD_INT 9
53452: PUSH
53453: LD_INT 20
53455: PUSH
53456: LD_INT 19
53458: PUSH
53459: LD_INT 21
53461: PUSH
53462: LD_INT 24
53464: PUSH
53465: LD_INT 22
53467: PUSH
53468: LD_INT 25
53470: PUSH
53471: LD_INT 28
53473: PUSH
53474: LD_INT 29
53476: PUSH
53477: LD_INT 30
53479: PUSH
53480: LD_INT 31
53482: PUSH
53483: LD_INT 37
53485: PUSH
53486: LD_INT 38
53488: PUSH
53489: LD_INT 32
53491: PUSH
53492: LD_INT 27
53494: PUSH
53495: LD_INT 33
53497: PUSH
53498: LD_INT 69
53500: PUSH
53501: LD_INT 39
53503: PUSH
53504: LD_INT 34
53506: PUSH
53507: LD_INT 40
53509: PUSH
53510: LD_INT 71
53512: PUSH
53513: LD_INT 23
53515: PUSH
53516: LD_INT 44
53518: PUSH
53519: LD_INT 48
53521: PUSH
53522: LD_INT 49
53524: PUSH
53525: LD_INT 50
53527: PUSH
53528: LD_INT 51
53530: PUSH
53531: LD_INT 52
53533: PUSH
53534: LD_INT 53
53536: PUSH
53537: LD_INT 54
53539: PUSH
53540: LD_INT 55
53542: PUSH
53543: LD_INT 56
53545: PUSH
53546: LD_INT 57
53548: PUSH
53549: LD_INT 58
53551: PUSH
53552: LD_INT 59
53554: PUSH
53555: LD_INT 63
53557: PUSH
53558: LD_INT 64
53560: PUSH
53561: LD_INT 65
53563: PUSH
53564: LD_INT 82
53566: PUSH
53567: LD_INT 83
53569: PUSH
53570: LD_INT 84
53572: PUSH
53573: LD_INT 85
53575: PUSH
53576: LD_INT 86
53578: PUSH
53579: EMPTY
53580: LIST
53581: LIST
53582: LIST
53583: LIST
53584: LIST
53585: LIST
53586: LIST
53587: LIST
53588: LIST
53589: LIST
53590: LIST
53591: LIST
53592: LIST
53593: LIST
53594: LIST
53595: LIST
53596: LIST
53597: LIST
53598: LIST
53599: LIST
53600: LIST
53601: LIST
53602: LIST
53603: LIST
53604: LIST
53605: LIST
53606: LIST
53607: LIST
53608: LIST
53609: LIST
53610: LIST
53611: LIST
53612: LIST
53613: LIST
53614: LIST
53615: LIST
53616: LIST
53617: LIST
53618: LIST
53619: LIST
53620: LIST
53621: LIST
53622: LIST
53623: LIST
53624: LIST
53625: LIST
53626: LIST
53627: LIST
53628: LIST
53629: LIST
53630: LIST
53631: LIST
53632: LIST
53633: ST_TO_ADDR
53634: GO 53637
53636: POP
// if state > - 1 and state < 3 then
53637: LD_VAR 0 3
53641: PUSH
53642: LD_INT 1
53644: NEG
53645: GREATER
53646: PUSH
53647: LD_VAR 0 3
53651: PUSH
53652: LD_INT 3
53654: LESS
53655: AND
53656: IFFALSE 53713
// for i in result do
53658: LD_ADDR_VAR 0 5
53662: PUSH
53663: LD_VAR 0 4
53667: PUSH
53668: FOR_IN
53669: IFFALSE 53711
// if GetTech ( i , side ) <> state then
53671: LD_VAR 0 5
53675: PPUSH
53676: LD_VAR 0 1
53680: PPUSH
53681: CALL_OW 321
53685: PUSH
53686: LD_VAR 0 3
53690: NONEQUAL
53691: IFFALSE 53709
// result := result diff i ;
53693: LD_ADDR_VAR 0 4
53697: PUSH
53698: LD_VAR 0 4
53702: PUSH
53703: LD_VAR 0 5
53707: DIFF
53708: ST_TO_ADDR
53709: GO 53668
53711: POP
53712: POP
// end ;
53713: LD_VAR 0 4
53717: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
53718: LD_INT 0
53720: PPUSH
53721: PPUSH
53722: PPUSH
// result := true ;
53723: LD_ADDR_VAR 0 3
53727: PUSH
53728: LD_INT 1
53730: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
53731: LD_ADDR_VAR 0 5
53735: PUSH
53736: LD_VAR 0 2
53740: PPUSH
53741: CALL_OW 480
53745: ST_TO_ADDR
// if not tmp then
53746: LD_VAR 0 5
53750: NOT
53751: IFFALSE 53755
// exit ;
53753: GO 53804
// for i in tmp do
53755: LD_ADDR_VAR 0 4
53759: PUSH
53760: LD_VAR 0 5
53764: PUSH
53765: FOR_IN
53766: IFFALSE 53802
// if GetTech ( i , side ) <> state_researched then
53768: LD_VAR 0 4
53772: PPUSH
53773: LD_VAR 0 1
53777: PPUSH
53778: CALL_OW 321
53782: PUSH
53783: LD_INT 2
53785: NONEQUAL
53786: IFFALSE 53800
// begin result := false ;
53788: LD_ADDR_VAR 0 3
53792: PUSH
53793: LD_INT 0
53795: ST_TO_ADDR
// exit ;
53796: POP
53797: POP
53798: GO 53804
// end ;
53800: GO 53765
53802: POP
53803: POP
// end ;
53804: LD_VAR 0 3
53808: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
53809: LD_INT 0
53811: PPUSH
53812: PPUSH
53813: PPUSH
53814: PPUSH
53815: PPUSH
53816: PPUSH
53817: PPUSH
53818: PPUSH
53819: PPUSH
53820: PPUSH
53821: PPUSH
53822: PPUSH
53823: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
53824: LD_VAR 0 1
53828: NOT
53829: PUSH
53830: LD_VAR 0 1
53834: PPUSH
53835: CALL_OW 257
53839: PUSH
53840: LD_INT 9
53842: NONEQUAL
53843: OR
53844: IFFALSE 53848
// exit ;
53846: GO 54421
// side := GetSide ( unit ) ;
53848: LD_ADDR_VAR 0 9
53852: PUSH
53853: LD_VAR 0 1
53857: PPUSH
53858: CALL_OW 255
53862: ST_TO_ADDR
// tech_space := tech_spacanom ;
53863: LD_ADDR_VAR 0 12
53867: PUSH
53868: LD_INT 29
53870: ST_TO_ADDR
// tech_time := tech_taurad ;
53871: LD_ADDR_VAR 0 13
53875: PUSH
53876: LD_INT 28
53878: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53879: LD_ADDR_VAR 0 11
53883: PUSH
53884: LD_VAR 0 1
53888: PPUSH
53889: CALL_OW 310
53893: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53894: LD_VAR 0 11
53898: PPUSH
53899: CALL_OW 247
53903: PUSH
53904: LD_INT 2
53906: EQUAL
53907: IFFALSE 53911
// exit ;
53909: GO 54421
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53911: LD_ADDR_VAR 0 8
53915: PUSH
53916: LD_INT 81
53918: PUSH
53919: LD_VAR 0 9
53923: PUSH
53924: EMPTY
53925: LIST
53926: LIST
53927: PUSH
53928: LD_INT 3
53930: PUSH
53931: LD_INT 21
53933: PUSH
53934: LD_INT 3
53936: PUSH
53937: EMPTY
53938: LIST
53939: LIST
53940: PUSH
53941: EMPTY
53942: LIST
53943: LIST
53944: PUSH
53945: EMPTY
53946: LIST
53947: LIST
53948: PPUSH
53949: CALL_OW 69
53953: ST_TO_ADDR
// if not tmp then
53954: LD_VAR 0 8
53958: NOT
53959: IFFALSE 53963
// exit ;
53961: GO 54421
// if in_unit then
53963: LD_VAR 0 11
53967: IFFALSE 53991
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53969: LD_ADDR_VAR 0 10
53973: PUSH
53974: LD_VAR 0 8
53978: PPUSH
53979: LD_VAR 0 11
53983: PPUSH
53984: CALL_OW 74
53988: ST_TO_ADDR
53989: GO 54011
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53991: LD_ADDR_VAR 0 10
53995: PUSH
53996: LD_VAR 0 8
54000: PPUSH
54001: LD_VAR 0 1
54005: PPUSH
54006: CALL_OW 74
54010: ST_TO_ADDR
// if not enemy then
54011: LD_VAR 0 10
54015: NOT
54016: IFFALSE 54020
// exit ;
54018: GO 54421
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
54020: LD_VAR 0 11
54024: PUSH
54025: LD_VAR 0 11
54029: PPUSH
54030: LD_VAR 0 10
54034: PPUSH
54035: CALL_OW 296
54039: PUSH
54040: LD_INT 13
54042: GREATER
54043: AND
54044: PUSH
54045: LD_VAR 0 1
54049: PPUSH
54050: LD_VAR 0 10
54054: PPUSH
54055: CALL_OW 296
54059: PUSH
54060: LD_INT 12
54062: GREATER
54063: OR
54064: IFFALSE 54068
// exit ;
54066: GO 54421
// missile := [ 1 ] ;
54068: LD_ADDR_VAR 0 14
54072: PUSH
54073: LD_INT 1
54075: PUSH
54076: EMPTY
54077: LIST
54078: ST_TO_ADDR
// if Researched ( side , tech_space ) then
54079: LD_VAR 0 9
54083: PPUSH
54084: LD_VAR 0 12
54088: PPUSH
54089: CALL_OW 325
54093: IFFALSE 54122
// missile := Replace ( missile , missile + 1 , 2 ) ;
54095: LD_ADDR_VAR 0 14
54099: PUSH
54100: LD_VAR 0 14
54104: PPUSH
54105: LD_VAR 0 14
54109: PUSH
54110: LD_INT 1
54112: PLUS
54113: PPUSH
54114: LD_INT 2
54116: PPUSH
54117: CALL_OW 1
54121: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
54122: LD_VAR 0 9
54126: PPUSH
54127: LD_VAR 0 13
54131: PPUSH
54132: CALL_OW 325
54136: PUSH
54137: LD_VAR 0 10
54141: PPUSH
54142: CALL_OW 255
54146: PPUSH
54147: LD_VAR 0 13
54151: PPUSH
54152: CALL_OW 325
54156: NOT
54157: AND
54158: IFFALSE 54187
// missile := Replace ( missile , missile + 1 , 3 ) ;
54160: LD_ADDR_VAR 0 14
54164: PUSH
54165: LD_VAR 0 14
54169: PPUSH
54170: LD_VAR 0 14
54174: PUSH
54175: LD_INT 1
54177: PLUS
54178: PPUSH
54179: LD_INT 3
54181: PPUSH
54182: CALL_OW 1
54186: ST_TO_ADDR
// if missile < 2 then
54187: LD_VAR 0 14
54191: PUSH
54192: LD_INT 2
54194: LESS
54195: IFFALSE 54199
// exit ;
54197: GO 54421
// x := GetX ( enemy ) ;
54199: LD_ADDR_VAR 0 4
54203: PUSH
54204: LD_VAR 0 10
54208: PPUSH
54209: CALL_OW 250
54213: ST_TO_ADDR
// y := GetY ( enemy ) ;
54214: LD_ADDR_VAR 0 5
54218: PUSH
54219: LD_VAR 0 10
54223: PPUSH
54224: CALL_OW 251
54228: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
54229: LD_ADDR_VAR 0 6
54233: PUSH
54234: LD_VAR 0 4
54238: PUSH
54239: LD_INT 1
54241: NEG
54242: PPUSH
54243: LD_INT 1
54245: PPUSH
54246: CALL_OW 12
54250: PLUS
54251: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
54252: LD_ADDR_VAR 0 7
54256: PUSH
54257: LD_VAR 0 5
54261: PUSH
54262: LD_INT 1
54264: NEG
54265: PPUSH
54266: LD_INT 1
54268: PPUSH
54269: CALL_OW 12
54273: PLUS
54274: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54275: LD_VAR 0 6
54279: PPUSH
54280: LD_VAR 0 7
54284: PPUSH
54285: CALL_OW 488
54289: NOT
54290: IFFALSE 54312
// begin _x := x ;
54292: LD_ADDR_VAR 0 6
54296: PUSH
54297: LD_VAR 0 4
54301: ST_TO_ADDR
// _y := y ;
54302: LD_ADDR_VAR 0 7
54306: PUSH
54307: LD_VAR 0 5
54311: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
54312: LD_ADDR_VAR 0 3
54316: PUSH
54317: LD_INT 1
54319: PPUSH
54320: LD_VAR 0 14
54324: PPUSH
54325: CALL_OW 12
54329: ST_TO_ADDR
// case i of 1 :
54330: LD_VAR 0 3
54334: PUSH
54335: LD_INT 1
54337: DOUBLE
54338: EQUAL
54339: IFTRUE 54343
54341: GO 54360
54343: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
54344: LD_VAR 0 1
54348: PPUSH
54349: LD_VAR 0 10
54353: PPUSH
54354: CALL_OW 115
54358: GO 54421
54360: LD_INT 2
54362: DOUBLE
54363: EQUAL
54364: IFTRUE 54368
54366: GO 54390
54368: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
54369: LD_VAR 0 1
54373: PPUSH
54374: LD_VAR 0 6
54378: PPUSH
54379: LD_VAR 0 7
54383: PPUSH
54384: CALL_OW 153
54388: GO 54421
54390: LD_INT 3
54392: DOUBLE
54393: EQUAL
54394: IFTRUE 54398
54396: GO 54420
54398: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
54399: LD_VAR 0 1
54403: PPUSH
54404: LD_VAR 0 6
54408: PPUSH
54409: LD_VAR 0 7
54413: PPUSH
54414: CALL_OW 154
54418: GO 54421
54420: POP
// end ;
54421: LD_VAR 0 2
54425: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
54426: LD_INT 0
54428: PPUSH
54429: PPUSH
54430: PPUSH
54431: PPUSH
54432: PPUSH
54433: PPUSH
// if not unit or not building then
54434: LD_VAR 0 1
54438: NOT
54439: PUSH
54440: LD_VAR 0 2
54444: NOT
54445: OR
54446: IFFALSE 54450
// exit ;
54448: GO 54608
// x := GetX ( building ) ;
54450: LD_ADDR_VAR 0 5
54454: PUSH
54455: LD_VAR 0 2
54459: PPUSH
54460: CALL_OW 250
54464: ST_TO_ADDR
// y := GetY ( building ) ;
54465: LD_ADDR_VAR 0 6
54469: PUSH
54470: LD_VAR 0 2
54474: PPUSH
54475: CALL_OW 251
54479: ST_TO_ADDR
// for i = 0 to 5 do
54480: LD_ADDR_VAR 0 4
54484: PUSH
54485: DOUBLE
54486: LD_INT 0
54488: DEC
54489: ST_TO_ADDR
54490: LD_INT 5
54492: PUSH
54493: FOR_TO
54494: IFFALSE 54606
// begin _x := ShiftX ( x , i , 3 ) ;
54496: LD_ADDR_VAR 0 7
54500: PUSH
54501: LD_VAR 0 5
54505: PPUSH
54506: LD_VAR 0 4
54510: PPUSH
54511: LD_INT 3
54513: PPUSH
54514: CALL_OW 272
54518: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
54519: LD_ADDR_VAR 0 8
54523: PUSH
54524: LD_VAR 0 6
54528: PPUSH
54529: LD_VAR 0 4
54533: PPUSH
54534: LD_INT 3
54536: PPUSH
54537: CALL_OW 273
54541: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54542: LD_VAR 0 7
54546: PPUSH
54547: LD_VAR 0 8
54551: PPUSH
54552: CALL_OW 488
54556: NOT
54557: IFFALSE 54561
// continue ;
54559: GO 54493
// if HexInfo ( _x , _y ) = 0 then
54561: LD_VAR 0 7
54565: PPUSH
54566: LD_VAR 0 8
54570: PPUSH
54571: CALL_OW 428
54575: PUSH
54576: LD_INT 0
54578: EQUAL
54579: IFFALSE 54604
// begin ComMoveXY ( unit , _x , _y ) ;
54581: LD_VAR 0 1
54585: PPUSH
54586: LD_VAR 0 7
54590: PPUSH
54591: LD_VAR 0 8
54595: PPUSH
54596: CALL_OW 111
// exit ;
54600: POP
54601: POP
54602: GO 54608
// end ; end ;
54604: GO 54493
54606: POP
54607: POP
// end ;
54608: LD_VAR 0 3
54612: RET
// export function ScanBase ( side , base_area ) ; begin
54613: LD_INT 0
54615: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
54616: LD_ADDR_VAR 0 3
54620: PUSH
54621: LD_VAR 0 2
54625: PPUSH
54626: LD_INT 81
54628: PUSH
54629: LD_VAR 0 1
54633: PUSH
54634: EMPTY
54635: LIST
54636: LIST
54637: PPUSH
54638: CALL_OW 70
54642: ST_TO_ADDR
// end ;
54643: LD_VAR 0 3
54647: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54648: LD_INT 0
54650: PPUSH
54651: PPUSH
54652: PPUSH
54653: PPUSH
// result := false ;
54654: LD_ADDR_VAR 0 2
54658: PUSH
54659: LD_INT 0
54661: ST_TO_ADDR
// side := GetSide ( unit ) ;
54662: LD_ADDR_VAR 0 3
54666: PUSH
54667: LD_VAR 0 1
54671: PPUSH
54672: CALL_OW 255
54676: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54677: LD_ADDR_VAR 0 4
54681: PUSH
54682: LD_VAR 0 1
54686: PPUSH
54687: CALL_OW 248
54691: ST_TO_ADDR
// case nat of 1 :
54692: LD_VAR 0 4
54696: PUSH
54697: LD_INT 1
54699: DOUBLE
54700: EQUAL
54701: IFTRUE 54705
54703: GO 54716
54705: POP
// tech := tech_lassight ; 2 :
54706: LD_ADDR_VAR 0 5
54710: PUSH
54711: LD_INT 12
54713: ST_TO_ADDR
54714: GO 54755
54716: LD_INT 2
54718: DOUBLE
54719: EQUAL
54720: IFTRUE 54724
54722: GO 54735
54724: POP
// tech := tech_mortar ; 3 :
54725: LD_ADDR_VAR 0 5
54729: PUSH
54730: LD_INT 41
54732: ST_TO_ADDR
54733: GO 54755
54735: LD_INT 3
54737: DOUBLE
54738: EQUAL
54739: IFTRUE 54743
54741: GO 54754
54743: POP
// tech := tech_bazooka ; end ;
54744: LD_ADDR_VAR 0 5
54748: PUSH
54749: LD_INT 44
54751: ST_TO_ADDR
54752: GO 54755
54754: POP
// if Researched ( side , tech ) then
54755: LD_VAR 0 3
54759: PPUSH
54760: LD_VAR 0 5
54764: PPUSH
54765: CALL_OW 325
54769: IFFALSE 54796
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54771: LD_ADDR_VAR 0 2
54775: PUSH
54776: LD_INT 5
54778: PUSH
54779: LD_INT 8
54781: PUSH
54782: LD_INT 9
54784: PUSH
54785: EMPTY
54786: LIST
54787: LIST
54788: LIST
54789: PUSH
54790: LD_VAR 0 4
54794: ARRAY
54795: ST_TO_ADDR
// end ;
54796: LD_VAR 0 2
54800: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54801: LD_INT 0
54803: PPUSH
54804: PPUSH
54805: PPUSH
// if not mines then
54806: LD_VAR 0 2
54810: NOT
54811: IFFALSE 54815
// exit ;
54813: GO 54959
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54815: LD_ADDR_VAR 0 5
54819: PUSH
54820: LD_INT 81
54822: PUSH
54823: LD_VAR 0 1
54827: PUSH
54828: EMPTY
54829: LIST
54830: LIST
54831: PUSH
54832: LD_INT 3
54834: PUSH
54835: LD_INT 21
54837: PUSH
54838: LD_INT 3
54840: PUSH
54841: EMPTY
54842: LIST
54843: LIST
54844: PUSH
54845: EMPTY
54846: LIST
54847: LIST
54848: PUSH
54849: EMPTY
54850: LIST
54851: LIST
54852: PPUSH
54853: CALL_OW 69
54857: ST_TO_ADDR
// for i in mines do
54858: LD_ADDR_VAR 0 4
54862: PUSH
54863: LD_VAR 0 2
54867: PUSH
54868: FOR_IN
54869: IFFALSE 54957
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54871: LD_VAR 0 4
54875: PUSH
54876: LD_INT 1
54878: ARRAY
54879: PPUSH
54880: LD_VAR 0 4
54884: PUSH
54885: LD_INT 2
54887: ARRAY
54888: PPUSH
54889: CALL_OW 458
54893: NOT
54894: IFFALSE 54898
// continue ;
54896: GO 54868
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54898: LD_VAR 0 4
54902: PUSH
54903: LD_INT 1
54905: ARRAY
54906: PPUSH
54907: LD_VAR 0 4
54911: PUSH
54912: LD_INT 2
54914: ARRAY
54915: PPUSH
54916: CALL_OW 428
54920: PUSH
54921: LD_VAR 0 5
54925: IN
54926: IFFALSE 54955
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54928: LD_VAR 0 4
54932: PUSH
54933: LD_INT 1
54935: ARRAY
54936: PPUSH
54937: LD_VAR 0 4
54941: PUSH
54942: LD_INT 2
54944: ARRAY
54945: PPUSH
54946: LD_VAR 0 1
54950: PPUSH
54951: CALL_OW 456
// end ;
54955: GO 54868
54957: POP
54958: POP
// end ;
54959: LD_VAR 0 3
54963: RET
// export function Count ( array ) ; begin
54964: LD_INT 0
54966: PPUSH
// result := array + 0 ;
54967: LD_ADDR_VAR 0 2
54971: PUSH
54972: LD_VAR 0 1
54976: PUSH
54977: LD_INT 0
54979: PLUS
54980: ST_TO_ADDR
// end ;
54981: LD_VAR 0 2
54985: RET
// export function IsEmpty ( building ) ; begin
54986: LD_INT 0
54988: PPUSH
// if not building then
54989: LD_VAR 0 1
54993: NOT
54994: IFFALSE 54998
// exit ;
54996: GO 55041
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54998: LD_ADDR_VAR 0 2
55002: PUSH
55003: LD_VAR 0 1
55007: PUSH
55008: LD_INT 22
55010: PUSH
55011: LD_VAR 0 1
55015: PPUSH
55016: CALL_OW 255
55020: PUSH
55021: EMPTY
55022: LIST
55023: LIST
55024: PUSH
55025: LD_INT 58
55027: PUSH
55028: EMPTY
55029: LIST
55030: PUSH
55031: EMPTY
55032: LIST
55033: LIST
55034: PPUSH
55035: CALL_OW 69
55039: IN
55040: ST_TO_ADDR
// end ;
55041: LD_VAR 0 2
55045: RET
// export function IsNotFull ( building ) ; var places ; begin
55046: LD_INT 0
55048: PPUSH
55049: PPUSH
// if not building then
55050: LD_VAR 0 1
55054: NOT
55055: IFFALSE 55059
// exit ;
55057: GO 55087
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
55059: LD_ADDR_VAR 0 2
55063: PUSH
55064: LD_VAR 0 1
55068: PPUSH
55069: LD_INT 3
55071: PUSH
55072: LD_INT 62
55074: PUSH
55075: EMPTY
55076: LIST
55077: PUSH
55078: EMPTY
55079: LIST
55080: LIST
55081: PPUSH
55082: CALL_OW 72
55086: ST_TO_ADDR
// end ;
55087: LD_VAR 0 2
55091: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55092: LD_INT 0
55094: PPUSH
55095: PPUSH
55096: PPUSH
55097: PPUSH
// tmp := [ ] ;
55098: LD_ADDR_VAR 0 3
55102: PUSH
55103: EMPTY
55104: ST_TO_ADDR
// list := [ ] ;
55105: LD_ADDR_VAR 0 5
55109: PUSH
55110: EMPTY
55111: ST_TO_ADDR
// for i = 16 to 25 do
55112: LD_ADDR_VAR 0 4
55116: PUSH
55117: DOUBLE
55118: LD_INT 16
55120: DEC
55121: ST_TO_ADDR
55122: LD_INT 25
55124: PUSH
55125: FOR_TO
55126: IFFALSE 55199
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55128: LD_ADDR_VAR 0 3
55132: PUSH
55133: LD_VAR 0 3
55137: PUSH
55138: LD_INT 22
55140: PUSH
55141: LD_VAR 0 1
55145: PPUSH
55146: CALL_OW 255
55150: PUSH
55151: EMPTY
55152: LIST
55153: LIST
55154: PUSH
55155: LD_INT 91
55157: PUSH
55158: LD_VAR 0 1
55162: PUSH
55163: LD_INT 6
55165: PUSH
55166: EMPTY
55167: LIST
55168: LIST
55169: LIST
55170: PUSH
55171: LD_INT 30
55173: PUSH
55174: LD_VAR 0 4
55178: PUSH
55179: EMPTY
55180: LIST
55181: LIST
55182: PUSH
55183: EMPTY
55184: LIST
55185: LIST
55186: LIST
55187: PUSH
55188: EMPTY
55189: LIST
55190: PPUSH
55191: CALL_OW 69
55195: ADD
55196: ST_TO_ADDR
55197: GO 55125
55199: POP
55200: POP
// for i = 1 to tmp do
55201: LD_ADDR_VAR 0 4
55205: PUSH
55206: DOUBLE
55207: LD_INT 1
55209: DEC
55210: ST_TO_ADDR
55211: LD_VAR 0 3
55215: PUSH
55216: FOR_TO
55217: IFFALSE 55305
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55219: LD_ADDR_VAR 0 5
55223: PUSH
55224: LD_VAR 0 5
55228: PUSH
55229: LD_VAR 0 3
55233: PUSH
55234: LD_VAR 0 4
55238: ARRAY
55239: PPUSH
55240: CALL_OW 266
55244: PUSH
55245: LD_VAR 0 3
55249: PUSH
55250: LD_VAR 0 4
55254: ARRAY
55255: PPUSH
55256: CALL_OW 250
55260: PUSH
55261: LD_VAR 0 3
55265: PUSH
55266: LD_VAR 0 4
55270: ARRAY
55271: PPUSH
55272: CALL_OW 251
55276: PUSH
55277: LD_VAR 0 3
55281: PUSH
55282: LD_VAR 0 4
55286: ARRAY
55287: PPUSH
55288: CALL_OW 254
55292: PUSH
55293: EMPTY
55294: LIST
55295: LIST
55296: LIST
55297: LIST
55298: PUSH
55299: EMPTY
55300: LIST
55301: ADD
55302: ST_TO_ADDR
55303: GO 55216
55305: POP
55306: POP
// result := list ;
55307: LD_ADDR_VAR 0 2
55311: PUSH
55312: LD_VAR 0 5
55316: ST_TO_ADDR
// end ;
55317: LD_VAR 0 2
55321: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55322: LD_INT 0
55324: PPUSH
55325: PPUSH
55326: PPUSH
55327: PPUSH
55328: PPUSH
55329: PPUSH
55330: PPUSH
// if not factory then
55331: LD_VAR 0 1
55335: NOT
55336: IFFALSE 55340
// exit ;
55338: GO 55933
// if control = control_apeman then
55340: LD_VAR 0 4
55344: PUSH
55345: LD_INT 5
55347: EQUAL
55348: IFFALSE 55457
// begin tmp := UnitsInside ( factory ) ;
55350: LD_ADDR_VAR 0 8
55354: PUSH
55355: LD_VAR 0 1
55359: PPUSH
55360: CALL_OW 313
55364: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55365: LD_VAR 0 8
55369: PPUSH
55370: LD_INT 25
55372: PUSH
55373: LD_INT 12
55375: PUSH
55376: EMPTY
55377: LIST
55378: LIST
55379: PPUSH
55380: CALL_OW 72
55384: NOT
55385: IFFALSE 55395
// control := control_manual ;
55387: LD_ADDR_VAR 0 4
55391: PUSH
55392: LD_INT 1
55394: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55395: LD_ADDR_VAR 0 8
55399: PUSH
55400: LD_VAR 0 1
55404: PPUSH
55405: CALL 55092 0 1
55409: ST_TO_ADDR
// if tmp then
55410: LD_VAR 0 8
55414: IFFALSE 55457
// begin for i in tmp do
55416: LD_ADDR_VAR 0 7
55420: PUSH
55421: LD_VAR 0 8
55425: PUSH
55426: FOR_IN
55427: IFFALSE 55455
// if i [ 1 ] = b_ext_radio then
55429: LD_VAR 0 7
55433: PUSH
55434: LD_INT 1
55436: ARRAY
55437: PUSH
55438: LD_INT 22
55440: EQUAL
55441: IFFALSE 55453
// begin control := control_remote ;
55443: LD_ADDR_VAR 0 4
55447: PUSH
55448: LD_INT 2
55450: ST_TO_ADDR
// break ;
55451: GO 55455
// end ;
55453: GO 55426
55455: POP
55456: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55457: LD_VAR 0 1
55461: PPUSH
55462: LD_VAR 0 2
55466: PPUSH
55467: LD_VAR 0 3
55471: PPUSH
55472: LD_VAR 0 4
55476: PPUSH
55477: LD_VAR 0 5
55481: PPUSH
55482: CALL_OW 448
55486: IFFALSE 55521
// begin result := [ chassis , engine , control , weapon ] ;
55488: LD_ADDR_VAR 0 6
55492: PUSH
55493: LD_VAR 0 2
55497: PUSH
55498: LD_VAR 0 3
55502: PUSH
55503: LD_VAR 0 4
55507: PUSH
55508: LD_VAR 0 5
55512: PUSH
55513: EMPTY
55514: LIST
55515: LIST
55516: LIST
55517: LIST
55518: ST_TO_ADDR
// exit ;
55519: GO 55933
// end ; _chassis := AvailableChassisList ( factory ) ;
55521: LD_ADDR_VAR 0 9
55525: PUSH
55526: LD_VAR 0 1
55530: PPUSH
55531: CALL_OW 475
55535: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55536: LD_ADDR_VAR 0 11
55540: PUSH
55541: LD_VAR 0 1
55545: PPUSH
55546: CALL_OW 476
55550: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55551: LD_ADDR_VAR 0 12
55555: PUSH
55556: LD_VAR 0 1
55560: PPUSH
55561: CALL_OW 477
55565: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55566: LD_ADDR_VAR 0 10
55570: PUSH
55571: LD_VAR 0 1
55575: PPUSH
55576: CALL_OW 478
55580: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55581: LD_VAR 0 9
55585: NOT
55586: PUSH
55587: LD_VAR 0 11
55591: NOT
55592: OR
55593: PUSH
55594: LD_VAR 0 12
55598: NOT
55599: OR
55600: PUSH
55601: LD_VAR 0 10
55605: NOT
55606: OR
55607: IFFALSE 55642
// begin result := [ chassis , engine , control , weapon ] ;
55609: LD_ADDR_VAR 0 6
55613: PUSH
55614: LD_VAR 0 2
55618: PUSH
55619: LD_VAR 0 3
55623: PUSH
55624: LD_VAR 0 4
55628: PUSH
55629: LD_VAR 0 5
55633: PUSH
55634: EMPTY
55635: LIST
55636: LIST
55637: LIST
55638: LIST
55639: ST_TO_ADDR
// exit ;
55640: GO 55933
// end ; if not chassis in _chassis then
55642: LD_VAR 0 2
55646: PUSH
55647: LD_VAR 0 9
55651: IN
55652: NOT
55653: IFFALSE 55679
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55655: LD_ADDR_VAR 0 2
55659: PUSH
55660: LD_VAR 0 9
55664: PUSH
55665: LD_INT 1
55667: PPUSH
55668: LD_VAR 0 9
55672: PPUSH
55673: CALL_OW 12
55677: ARRAY
55678: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55679: LD_VAR 0 2
55683: PPUSH
55684: LD_VAR 0 3
55688: PPUSH
55689: CALL 55938 0 2
55693: NOT
55694: IFFALSE 55753
// repeat engine := _engine [ 1 ] ;
55696: LD_ADDR_VAR 0 3
55700: PUSH
55701: LD_VAR 0 11
55705: PUSH
55706: LD_INT 1
55708: ARRAY
55709: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55710: LD_ADDR_VAR 0 11
55714: PUSH
55715: LD_VAR 0 11
55719: PPUSH
55720: LD_INT 1
55722: PPUSH
55723: CALL_OW 3
55727: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55728: LD_VAR 0 2
55732: PPUSH
55733: LD_VAR 0 3
55737: PPUSH
55738: CALL 55938 0 2
55742: PUSH
55743: LD_VAR 0 11
55747: PUSH
55748: EMPTY
55749: EQUAL
55750: OR
55751: IFFALSE 55696
// if not control in _control then
55753: LD_VAR 0 4
55757: PUSH
55758: LD_VAR 0 12
55762: IN
55763: NOT
55764: IFFALSE 55790
// control := _control [ rand ( 1 , _control ) ] ;
55766: LD_ADDR_VAR 0 4
55770: PUSH
55771: LD_VAR 0 12
55775: PUSH
55776: LD_INT 1
55778: PPUSH
55779: LD_VAR 0 12
55783: PPUSH
55784: CALL_OW 12
55788: ARRAY
55789: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55790: LD_VAR 0 2
55794: PPUSH
55795: LD_VAR 0 5
55799: PPUSH
55800: CALL 56158 0 2
55804: NOT
55805: IFFALSE 55864
// repeat weapon := _weapon [ 1 ] ;
55807: LD_ADDR_VAR 0 5
55811: PUSH
55812: LD_VAR 0 10
55816: PUSH
55817: LD_INT 1
55819: ARRAY
55820: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55821: LD_ADDR_VAR 0 10
55825: PUSH
55826: LD_VAR 0 10
55830: PPUSH
55831: LD_INT 1
55833: PPUSH
55834: CALL_OW 3
55838: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55839: LD_VAR 0 2
55843: PPUSH
55844: LD_VAR 0 5
55848: PPUSH
55849: CALL 56158 0 2
55853: PUSH
55854: LD_VAR 0 10
55858: PUSH
55859: EMPTY
55860: EQUAL
55861: OR
55862: IFFALSE 55807
// result := [ ] ;
55864: LD_ADDR_VAR 0 6
55868: PUSH
55869: EMPTY
55870: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55871: LD_VAR 0 1
55875: PPUSH
55876: LD_VAR 0 2
55880: PPUSH
55881: LD_VAR 0 3
55885: PPUSH
55886: LD_VAR 0 4
55890: PPUSH
55891: LD_VAR 0 5
55895: PPUSH
55896: CALL_OW 448
55900: IFFALSE 55933
// result := [ chassis , engine , control , weapon ] ;
55902: LD_ADDR_VAR 0 6
55906: PUSH
55907: LD_VAR 0 2
55911: PUSH
55912: LD_VAR 0 3
55916: PUSH
55917: LD_VAR 0 4
55921: PUSH
55922: LD_VAR 0 5
55926: PUSH
55927: EMPTY
55928: LIST
55929: LIST
55930: LIST
55931: LIST
55932: ST_TO_ADDR
// end ;
55933: LD_VAR 0 6
55937: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55938: LD_INT 0
55940: PPUSH
// if not chassis or not engine then
55941: LD_VAR 0 1
55945: NOT
55946: PUSH
55947: LD_VAR 0 2
55951: NOT
55952: OR
55953: IFFALSE 55957
// exit ;
55955: GO 56153
// case engine of engine_solar :
55957: LD_VAR 0 2
55961: PUSH
55962: LD_INT 2
55964: DOUBLE
55965: EQUAL
55966: IFTRUE 55970
55968: GO 56008
55970: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55971: LD_ADDR_VAR 0 3
55975: PUSH
55976: LD_INT 11
55978: PUSH
55979: LD_INT 12
55981: PUSH
55982: LD_INT 13
55984: PUSH
55985: LD_INT 14
55987: PUSH
55988: LD_INT 1
55990: PUSH
55991: LD_INT 2
55993: PUSH
55994: LD_INT 3
55996: PUSH
55997: EMPTY
55998: LIST
55999: LIST
56000: LIST
56001: LIST
56002: LIST
56003: LIST
56004: LIST
56005: ST_TO_ADDR
56006: GO 56137
56008: LD_INT 1
56010: DOUBLE
56011: EQUAL
56012: IFTRUE 56016
56014: GO 56078
56016: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56017: LD_ADDR_VAR 0 3
56021: PUSH
56022: LD_INT 11
56024: PUSH
56025: LD_INT 12
56027: PUSH
56028: LD_INT 13
56030: PUSH
56031: LD_INT 14
56033: PUSH
56034: LD_INT 1
56036: PUSH
56037: LD_INT 2
56039: PUSH
56040: LD_INT 3
56042: PUSH
56043: LD_INT 4
56045: PUSH
56046: LD_INT 5
56048: PUSH
56049: LD_INT 21
56051: PUSH
56052: LD_INT 23
56054: PUSH
56055: LD_INT 22
56057: PUSH
56058: LD_INT 24
56060: PUSH
56061: EMPTY
56062: LIST
56063: LIST
56064: LIST
56065: LIST
56066: LIST
56067: LIST
56068: LIST
56069: LIST
56070: LIST
56071: LIST
56072: LIST
56073: LIST
56074: LIST
56075: ST_TO_ADDR
56076: GO 56137
56078: LD_INT 3
56080: DOUBLE
56081: EQUAL
56082: IFTRUE 56086
56084: GO 56136
56086: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56087: LD_ADDR_VAR 0 3
56091: PUSH
56092: LD_INT 13
56094: PUSH
56095: LD_INT 14
56097: PUSH
56098: LD_INT 2
56100: PUSH
56101: LD_INT 3
56103: PUSH
56104: LD_INT 4
56106: PUSH
56107: LD_INT 5
56109: PUSH
56110: LD_INT 21
56112: PUSH
56113: LD_INT 22
56115: PUSH
56116: LD_INT 23
56118: PUSH
56119: LD_INT 24
56121: PUSH
56122: EMPTY
56123: LIST
56124: LIST
56125: LIST
56126: LIST
56127: LIST
56128: LIST
56129: LIST
56130: LIST
56131: LIST
56132: LIST
56133: ST_TO_ADDR
56134: GO 56137
56136: POP
// result := ( chassis in result ) ;
56137: LD_ADDR_VAR 0 3
56141: PUSH
56142: LD_VAR 0 1
56146: PUSH
56147: LD_VAR 0 3
56151: IN
56152: ST_TO_ADDR
// end ;
56153: LD_VAR 0 3
56157: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56158: LD_INT 0
56160: PPUSH
// if not chassis or not weapon then
56161: LD_VAR 0 1
56165: NOT
56166: PUSH
56167: LD_VAR 0 2
56171: NOT
56172: OR
56173: IFFALSE 56177
// exit ;
56175: GO 57237
// case weapon of us_machine_gun :
56177: LD_VAR 0 2
56181: PUSH
56182: LD_INT 2
56184: DOUBLE
56185: EQUAL
56186: IFTRUE 56190
56188: GO 56220
56190: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56191: LD_ADDR_VAR 0 3
56195: PUSH
56196: LD_INT 1
56198: PUSH
56199: LD_INT 2
56201: PUSH
56202: LD_INT 3
56204: PUSH
56205: LD_INT 4
56207: PUSH
56208: LD_INT 5
56210: PUSH
56211: EMPTY
56212: LIST
56213: LIST
56214: LIST
56215: LIST
56216: LIST
56217: ST_TO_ADDR
56218: GO 57221
56220: LD_INT 3
56222: DOUBLE
56223: EQUAL
56224: IFTRUE 56228
56226: GO 56258
56228: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56229: LD_ADDR_VAR 0 3
56233: PUSH
56234: LD_INT 1
56236: PUSH
56237: LD_INT 2
56239: PUSH
56240: LD_INT 3
56242: PUSH
56243: LD_INT 4
56245: PUSH
56246: LD_INT 5
56248: PUSH
56249: EMPTY
56250: LIST
56251: LIST
56252: LIST
56253: LIST
56254: LIST
56255: ST_TO_ADDR
56256: GO 57221
56258: LD_INT 11
56260: DOUBLE
56261: EQUAL
56262: IFTRUE 56266
56264: GO 56296
56266: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56267: LD_ADDR_VAR 0 3
56271: PUSH
56272: LD_INT 1
56274: PUSH
56275: LD_INT 2
56277: PUSH
56278: LD_INT 3
56280: PUSH
56281: LD_INT 4
56283: PUSH
56284: LD_INT 5
56286: PUSH
56287: EMPTY
56288: LIST
56289: LIST
56290: LIST
56291: LIST
56292: LIST
56293: ST_TO_ADDR
56294: GO 57221
56296: LD_INT 4
56298: DOUBLE
56299: EQUAL
56300: IFTRUE 56304
56302: GO 56330
56304: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56305: LD_ADDR_VAR 0 3
56309: PUSH
56310: LD_INT 2
56312: PUSH
56313: LD_INT 3
56315: PUSH
56316: LD_INT 4
56318: PUSH
56319: LD_INT 5
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: LIST
56326: LIST
56327: ST_TO_ADDR
56328: GO 57221
56330: LD_INT 5
56332: DOUBLE
56333: EQUAL
56334: IFTRUE 56338
56336: GO 56364
56338: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56339: LD_ADDR_VAR 0 3
56343: PUSH
56344: LD_INT 2
56346: PUSH
56347: LD_INT 3
56349: PUSH
56350: LD_INT 4
56352: PUSH
56353: LD_INT 5
56355: PUSH
56356: EMPTY
56357: LIST
56358: LIST
56359: LIST
56360: LIST
56361: ST_TO_ADDR
56362: GO 57221
56364: LD_INT 9
56366: DOUBLE
56367: EQUAL
56368: IFTRUE 56372
56370: GO 56398
56372: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56373: LD_ADDR_VAR 0 3
56377: PUSH
56378: LD_INT 2
56380: PUSH
56381: LD_INT 3
56383: PUSH
56384: LD_INT 4
56386: PUSH
56387: LD_INT 5
56389: PUSH
56390: EMPTY
56391: LIST
56392: LIST
56393: LIST
56394: LIST
56395: ST_TO_ADDR
56396: GO 57221
56398: LD_INT 7
56400: DOUBLE
56401: EQUAL
56402: IFTRUE 56406
56404: GO 56432
56406: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56407: LD_ADDR_VAR 0 3
56411: PUSH
56412: LD_INT 2
56414: PUSH
56415: LD_INT 3
56417: PUSH
56418: LD_INT 4
56420: PUSH
56421: LD_INT 5
56423: PUSH
56424: EMPTY
56425: LIST
56426: LIST
56427: LIST
56428: LIST
56429: ST_TO_ADDR
56430: GO 57221
56432: LD_INT 12
56434: DOUBLE
56435: EQUAL
56436: IFTRUE 56440
56438: GO 56466
56440: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56441: LD_ADDR_VAR 0 3
56445: PUSH
56446: LD_INT 2
56448: PUSH
56449: LD_INT 3
56451: PUSH
56452: LD_INT 4
56454: PUSH
56455: LD_INT 5
56457: PUSH
56458: EMPTY
56459: LIST
56460: LIST
56461: LIST
56462: LIST
56463: ST_TO_ADDR
56464: GO 57221
56466: LD_INT 13
56468: DOUBLE
56469: EQUAL
56470: IFTRUE 56474
56472: GO 56500
56474: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56475: LD_ADDR_VAR 0 3
56479: PUSH
56480: LD_INT 2
56482: PUSH
56483: LD_INT 3
56485: PUSH
56486: LD_INT 4
56488: PUSH
56489: LD_INT 5
56491: PUSH
56492: EMPTY
56493: LIST
56494: LIST
56495: LIST
56496: LIST
56497: ST_TO_ADDR
56498: GO 57221
56500: LD_INT 14
56502: DOUBLE
56503: EQUAL
56504: IFTRUE 56508
56506: GO 56526
56508: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56509: LD_ADDR_VAR 0 3
56513: PUSH
56514: LD_INT 4
56516: PUSH
56517: LD_INT 5
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: ST_TO_ADDR
56524: GO 57221
56526: LD_INT 6
56528: DOUBLE
56529: EQUAL
56530: IFTRUE 56534
56532: GO 56552
56534: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56535: LD_ADDR_VAR 0 3
56539: PUSH
56540: LD_INT 4
56542: PUSH
56543: LD_INT 5
56545: PUSH
56546: EMPTY
56547: LIST
56548: LIST
56549: ST_TO_ADDR
56550: GO 57221
56552: LD_INT 10
56554: DOUBLE
56555: EQUAL
56556: IFTRUE 56560
56558: GO 56578
56560: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56561: LD_ADDR_VAR 0 3
56565: PUSH
56566: LD_INT 4
56568: PUSH
56569: LD_INT 5
56571: PUSH
56572: EMPTY
56573: LIST
56574: LIST
56575: ST_TO_ADDR
56576: GO 57221
56578: LD_INT 22
56580: DOUBLE
56581: EQUAL
56582: IFTRUE 56586
56584: GO 56612
56586: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56587: LD_ADDR_VAR 0 3
56591: PUSH
56592: LD_INT 11
56594: PUSH
56595: LD_INT 12
56597: PUSH
56598: LD_INT 13
56600: PUSH
56601: LD_INT 14
56603: PUSH
56604: EMPTY
56605: LIST
56606: LIST
56607: LIST
56608: LIST
56609: ST_TO_ADDR
56610: GO 57221
56612: LD_INT 23
56614: DOUBLE
56615: EQUAL
56616: IFTRUE 56620
56618: GO 56646
56620: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56621: LD_ADDR_VAR 0 3
56625: PUSH
56626: LD_INT 11
56628: PUSH
56629: LD_INT 12
56631: PUSH
56632: LD_INT 13
56634: PUSH
56635: LD_INT 14
56637: PUSH
56638: EMPTY
56639: LIST
56640: LIST
56641: LIST
56642: LIST
56643: ST_TO_ADDR
56644: GO 57221
56646: LD_INT 24
56648: DOUBLE
56649: EQUAL
56650: IFTRUE 56654
56652: GO 56680
56654: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56655: LD_ADDR_VAR 0 3
56659: PUSH
56660: LD_INT 11
56662: PUSH
56663: LD_INT 12
56665: PUSH
56666: LD_INT 13
56668: PUSH
56669: LD_INT 14
56671: PUSH
56672: EMPTY
56673: LIST
56674: LIST
56675: LIST
56676: LIST
56677: ST_TO_ADDR
56678: GO 57221
56680: LD_INT 30
56682: DOUBLE
56683: EQUAL
56684: IFTRUE 56688
56686: GO 56714
56688: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56689: LD_ADDR_VAR 0 3
56693: PUSH
56694: LD_INT 11
56696: PUSH
56697: LD_INT 12
56699: PUSH
56700: LD_INT 13
56702: PUSH
56703: LD_INT 14
56705: PUSH
56706: EMPTY
56707: LIST
56708: LIST
56709: LIST
56710: LIST
56711: ST_TO_ADDR
56712: GO 57221
56714: LD_INT 25
56716: DOUBLE
56717: EQUAL
56718: IFTRUE 56722
56720: GO 56740
56722: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56723: LD_ADDR_VAR 0 3
56727: PUSH
56728: LD_INT 13
56730: PUSH
56731: LD_INT 14
56733: PUSH
56734: EMPTY
56735: LIST
56736: LIST
56737: ST_TO_ADDR
56738: GO 57221
56740: LD_INT 27
56742: DOUBLE
56743: EQUAL
56744: IFTRUE 56748
56746: GO 56766
56748: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
56749: LD_ADDR_VAR 0 3
56753: PUSH
56754: LD_INT 13
56756: PUSH
56757: LD_INT 14
56759: PUSH
56760: EMPTY
56761: LIST
56762: LIST
56763: ST_TO_ADDR
56764: GO 57221
56766: LD_INT 92
56768: DOUBLE
56769: EQUAL
56770: IFTRUE 56774
56772: GO 56800
56774: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56775: LD_ADDR_VAR 0 3
56779: PUSH
56780: LD_INT 11
56782: PUSH
56783: LD_INT 12
56785: PUSH
56786: LD_INT 13
56788: PUSH
56789: LD_INT 14
56791: PUSH
56792: EMPTY
56793: LIST
56794: LIST
56795: LIST
56796: LIST
56797: ST_TO_ADDR
56798: GO 57221
56800: LD_INT 28
56802: DOUBLE
56803: EQUAL
56804: IFTRUE 56808
56806: GO 56826
56808: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56809: LD_ADDR_VAR 0 3
56813: PUSH
56814: LD_INT 13
56816: PUSH
56817: LD_INT 14
56819: PUSH
56820: EMPTY
56821: LIST
56822: LIST
56823: ST_TO_ADDR
56824: GO 57221
56826: LD_INT 29
56828: DOUBLE
56829: EQUAL
56830: IFTRUE 56834
56832: GO 56852
56834: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56835: LD_ADDR_VAR 0 3
56839: PUSH
56840: LD_INT 13
56842: PUSH
56843: LD_INT 14
56845: PUSH
56846: EMPTY
56847: LIST
56848: LIST
56849: ST_TO_ADDR
56850: GO 57221
56852: LD_INT 31
56854: DOUBLE
56855: EQUAL
56856: IFTRUE 56860
56858: GO 56878
56860: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56861: LD_ADDR_VAR 0 3
56865: PUSH
56866: LD_INT 13
56868: PUSH
56869: LD_INT 14
56871: PUSH
56872: EMPTY
56873: LIST
56874: LIST
56875: ST_TO_ADDR
56876: GO 57221
56878: LD_INT 26
56880: DOUBLE
56881: EQUAL
56882: IFTRUE 56886
56884: GO 56904
56886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56887: LD_ADDR_VAR 0 3
56891: PUSH
56892: LD_INT 13
56894: PUSH
56895: LD_INT 14
56897: PUSH
56898: EMPTY
56899: LIST
56900: LIST
56901: ST_TO_ADDR
56902: GO 57221
56904: LD_INT 42
56906: DOUBLE
56907: EQUAL
56908: IFTRUE 56912
56910: GO 56938
56912: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56913: LD_ADDR_VAR 0 3
56917: PUSH
56918: LD_INT 21
56920: PUSH
56921: LD_INT 22
56923: PUSH
56924: LD_INT 23
56926: PUSH
56927: LD_INT 24
56929: PUSH
56930: EMPTY
56931: LIST
56932: LIST
56933: LIST
56934: LIST
56935: ST_TO_ADDR
56936: GO 57221
56938: LD_INT 43
56940: DOUBLE
56941: EQUAL
56942: IFTRUE 56946
56944: GO 56972
56946: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56947: LD_ADDR_VAR 0 3
56951: PUSH
56952: LD_INT 21
56954: PUSH
56955: LD_INT 22
56957: PUSH
56958: LD_INT 23
56960: PUSH
56961: LD_INT 24
56963: PUSH
56964: EMPTY
56965: LIST
56966: LIST
56967: LIST
56968: LIST
56969: ST_TO_ADDR
56970: GO 57221
56972: LD_INT 44
56974: DOUBLE
56975: EQUAL
56976: IFTRUE 56980
56978: GO 57006
56980: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56981: LD_ADDR_VAR 0 3
56985: PUSH
56986: LD_INT 21
56988: PUSH
56989: LD_INT 22
56991: PUSH
56992: LD_INT 23
56994: PUSH
56995: LD_INT 24
56997: PUSH
56998: EMPTY
56999: LIST
57000: LIST
57001: LIST
57002: LIST
57003: ST_TO_ADDR
57004: GO 57221
57006: LD_INT 45
57008: DOUBLE
57009: EQUAL
57010: IFTRUE 57014
57012: GO 57040
57014: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
57015: LD_ADDR_VAR 0 3
57019: PUSH
57020: LD_INT 21
57022: PUSH
57023: LD_INT 22
57025: PUSH
57026: LD_INT 23
57028: PUSH
57029: LD_INT 24
57031: PUSH
57032: EMPTY
57033: LIST
57034: LIST
57035: LIST
57036: LIST
57037: ST_TO_ADDR
57038: GO 57221
57040: LD_INT 49
57042: DOUBLE
57043: EQUAL
57044: IFTRUE 57048
57046: GO 57074
57048: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57049: LD_ADDR_VAR 0 3
57053: PUSH
57054: LD_INT 21
57056: PUSH
57057: LD_INT 22
57059: PUSH
57060: LD_INT 23
57062: PUSH
57063: LD_INT 24
57065: PUSH
57066: EMPTY
57067: LIST
57068: LIST
57069: LIST
57070: LIST
57071: ST_TO_ADDR
57072: GO 57221
57074: LD_INT 51
57076: DOUBLE
57077: EQUAL
57078: IFTRUE 57082
57080: GO 57108
57082: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57083: LD_ADDR_VAR 0 3
57087: PUSH
57088: LD_INT 21
57090: PUSH
57091: LD_INT 22
57093: PUSH
57094: LD_INT 23
57096: PUSH
57097: LD_INT 24
57099: PUSH
57100: EMPTY
57101: LIST
57102: LIST
57103: LIST
57104: LIST
57105: ST_TO_ADDR
57106: GO 57221
57108: LD_INT 52
57110: DOUBLE
57111: EQUAL
57112: IFTRUE 57116
57114: GO 57142
57116: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57117: LD_ADDR_VAR 0 3
57121: PUSH
57122: LD_INT 21
57124: PUSH
57125: LD_INT 22
57127: PUSH
57128: LD_INT 23
57130: PUSH
57131: LD_INT 24
57133: PUSH
57134: EMPTY
57135: LIST
57136: LIST
57137: LIST
57138: LIST
57139: ST_TO_ADDR
57140: GO 57221
57142: LD_INT 53
57144: DOUBLE
57145: EQUAL
57146: IFTRUE 57150
57148: GO 57168
57150: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57151: LD_ADDR_VAR 0 3
57155: PUSH
57156: LD_INT 23
57158: PUSH
57159: LD_INT 24
57161: PUSH
57162: EMPTY
57163: LIST
57164: LIST
57165: ST_TO_ADDR
57166: GO 57221
57168: LD_INT 46
57170: DOUBLE
57171: EQUAL
57172: IFTRUE 57176
57174: GO 57194
57176: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57177: LD_ADDR_VAR 0 3
57181: PUSH
57182: LD_INT 23
57184: PUSH
57185: LD_INT 24
57187: PUSH
57188: EMPTY
57189: LIST
57190: LIST
57191: ST_TO_ADDR
57192: GO 57221
57194: LD_INT 47
57196: DOUBLE
57197: EQUAL
57198: IFTRUE 57202
57200: GO 57220
57202: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57203: LD_ADDR_VAR 0 3
57207: PUSH
57208: LD_INT 23
57210: PUSH
57211: LD_INT 24
57213: PUSH
57214: EMPTY
57215: LIST
57216: LIST
57217: ST_TO_ADDR
57218: GO 57221
57220: POP
// result := ( chassis in result ) ;
57221: LD_ADDR_VAR 0 3
57225: PUSH
57226: LD_VAR 0 1
57230: PUSH
57231: LD_VAR 0 3
57235: IN
57236: ST_TO_ADDR
// end ;
57237: LD_VAR 0 3
57241: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57242: LD_INT 0
57244: PPUSH
57245: PPUSH
57246: PPUSH
57247: PPUSH
57248: PPUSH
57249: PPUSH
57250: PPUSH
// result := array ;
57251: LD_ADDR_VAR 0 5
57255: PUSH
57256: LD_VAR 0 1
57260: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57261: LD_VAR 0 1
57265: NOT
57266: PUSH
57267: LD_VAR 0 2
57271: NOT
57272: OR
57273: PUSH
57274: LD_VAR 0 3
57278: NOT
57279: OR
57280: PUSH
57281: LD_VAR 0 2
57285: PUSH
57286: LD_VAR 0 1
57290: GREATER
57291: OR
57292: PUSH
57293: LD_VAR 0 3
57297: PUSH
57298: LD_VAR 0 1
57302: GREATER
57303: OR
57304: IFFALSE 57308
// exit ;
57306: GO 57604
// if direction then
57308: LD_VAR 0 4
57312: IFFALSE 57376
// begin d := 1 ;
57314: LD_ADDR_VAR 0 9
57318: PUSH
57319: LD_INT 1
57321: ST_TO_ADDR
// if i_from > i_to then
57322: LD_VAR 0 2
57326: PUSH
57327: LD_VAR 0 3
57331: GREATER
57332: IFFALSE 57358
// length := ( array - i_from ) + i_to else
57334: LD_ADDR_VAR 0 11
57338: PUSH
57339: LD_VAR 0 1
57343: PUSH
57344: LD_VAR 0 2
57348: MINUS
57349: PUSH
57350: LD_VAR 0 3
57354: PLUS
57355: ST_TO_ADDR
57356: GO 57374
// length := i_to - i_from ;
57358: LD_ADDR_VAR 0 11
57362: PUSH
57363: LD_VAR 0 3
57367: PUSH
57368: LD_VAR 0 2
57372: MINUS
57373: ST_TO_ADDR
// end else
57374: GO 57437
// begin d := - 1 ;
57376: LD_ADDR_VAR 0 9
57380: PUSH
57381: LD_INT 1
57383: NEG
57384: ST_TO_ADDR
// if i_from > i_to then
57385: LD_VAR 0 2
57389: PUSH
57390: LD_VAR 0 3
57394: GREATER
57395: IFFALSE 57415
// length := i_from - i_to else
57397: LD_ADDR_VAR 0 11
57401: PUSH
57402: LD_VAR 0 2
57406: PUSH
57407: LD_VAR 0 3
57411: MINUS
57412: ST_TO_ADDR
57413: GO 57437
// length := ( array - i_to ) + i_from ;
57415: LD_ADDR_VAR 0 11
57419: PUSH
57420: LD_VAR 0 1
57424: PUSH
57425: LD_VAR 0 3
57429: MINUS
57430: PUSH
57431: LD_VAR 0 2
57435: PLUS
57436: ST_TO_ADDR
// end ; if not length then
57437: LD_VAR 0 11
57441: NOT
57442: IFFALSE 57446
// exit ;
57444: GO 57604
// tmp := array ;
57446: LD_ADDR_VAR 0 10
57450: PUSH
57451: LD_VAR 0 1
57455: ST_TO_ADDR
// for i = 1 to length do
57456: LD_ADDR_VAR 0 6
57460: PUSH
57461: DOUBLE
57462: LD_INT 1
57464: DEC
57465: ST_TO_ADDR
57466: LD_VAR 0 11
57470: PUSH
57471: FOR_TO
57472: IFFALSE 57592
// begin for j = 1 to array do
57474: LD_ADDR_VAR 0 7
57478: PUSH
57479: DOUBLE
57480: LD_INT 1
57482: DEC
57483: ST_TO_ADDR
57484: LD_VAR 0 1
57488: PUSH
57489: FOR_TO
57490: IFFALSE 57578
// begin k := j + d ;
57492: LD_ADDR_VAR 0 8
57496: PUSH
57497: LD_VAR 0 7
57501: PUSH
57502: LD_VAR 0 9
57506: PLUS
57507: ST_TO_ADDR
// if k > array then
57508: LD_VAR 0 8
57512: PUSH
57513: LD_VAR 0 1
57517: GREATER
57518: IFFALSE 57528
// k := 1 ;
57520: LD_ADDR_VAR 0 8
57524: PUSH
57525: LD_INT 1
57527: ST_TO_ADDR
// if not k then
57528: LD_VAR 0 8
57532: NOT
57533: IFFALSE 57545
// k := array ;
57535: LD_ADDR_VAR 0 8
57539: PUSH
57540: LD_VAR 0 1
57544: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57545: LD_ADDR_VAR 0 10
57549: PUSH
57550: LD_VAR 0 10
57554: PPUSH
57555: LD_VAR 0 8
57559: PPUSH
57560: LD_VAR 0 1
57564: PUSH
57565: LD_VAR 0 7
57569: ARRAY
57570: PPUSH
57571: CALL_OW 1
57575: ST_TO_ADDR
// end ;
57576: GO 57489
57578: POP
57579: POP
// array := tmp ;
57580: LD_ADDR_VAR 0 1
57584: PUSH
57585: LD_VAR 0 10
57589: ST_TO_ADDR
// end ;
57590: GO 57471
57592: POP
57593: POP
// result := array ;
57594: LD_ADDR_VAR 0 5
57598: PUSH
57599: LD_VAR 0 1
57603: ST_TO_ADDR
// end ;
57604: LD_VAR 0 5
57608: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57609: LD_INT 0
57611: PPUSH
57612: PPUSH
// result := 0 ;
57613: LD_ADDR_VAR 0 3
57617: PUSH
57618: LD_INT 0
57620: ST_TO_ADDR
// if not array or not value in array then
57621: LD_VAR 0 1
57625: NOT
57626: PUSH
57627: LD_VAR 0 2
57631: PUSH
57632: LD_VAR 0 1
57636: IN
57637: NOT
57638: OR
57639: IFFALSE 57643
// exit ;
57641: GO 57697
// for i = 1 to array do
57643: LD_ADDR_VAR 0 4
57647: PUSH
57648: DOUBLE
57649: LD_INT 1
57651: DEC
57652: ST_TO_ADDR
57653: LD_VAR 0 1
57657: PUSH
57658: FOR_TO
57659: IFFALSE 57695
// if value = array [ i ] then
57661: LD_VAR 0 2
57665: PUSH
57666: LD_VAR 0 1
57670: PUSH
57671: LD_VAR 0 4
57675: ARRAY
57676: EQUAL
57677: IFFALSE 57693
// begin result := i ;
57679: LD_ADDR_VAR 0 3
57683: PUSH
57684: LD_VAR 0 4
57688: ST_TO_ADDR
// exit ;
57689: POP
57690: POP
57691: GO 57697
// end ;
57693: GO 57658
57695: POP
57696: POP
// end ;
57697: LD_VAR 0 3
57701: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57702: LD_INT 0
57704: PPUSH
// vc_chassis := chassis ;
57705: LD_ADDR_OWVAR 37
57709: PUSH
57710: LD_VAR 0 1
57714: ST_TO_ADDR
// vc_engine := engine ;
57715: LD_ADDR_OWVAR 39
57719: PUSH
57720: LD_VAR 0 2
57724: ST_TO_ADDR
// vc_control := control ;
57725: LD_ADDR_OWVAR 38
57729: PUSH
57730: LD_VAR 0 3
57734: ST_TO_ADDR
// vc_weapon := weapon ;
57735: LD_ADDR_OWVAR 40
57739: PUSH
57740: LD_VAR 0 4
57744: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57745: LD_ADDR_OWVAR 41
57749: PUSH
57750: LD_VAR 0 5
57754: ST_TO_ADDR
// end ;
57755: LD_VAR 0 6
57759: RET
// export function WantPlant ( unit ) ; var task ; begin
57760: LD_INT 0
57762: PPUSH
57763: PPUSH
// result := false ;
57764: LD_ADDR_VAR 0 2
57768: PUSH
57769: LD_INT 0
57771: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57772: LD_ADDR_VAR 0 3
57776: PUSH
57777: LD_VAR 0 1
57781: PPUSH
57782: CALL_OW 437
57786: ST_TO_ADDR
// if task then
57787: LD_VAR 0 3
57791: IFFALSE 57819
// if task [ 1 ] [ 1 ] = p then
57793: LD_VAR 0 3
57797: PUSH
57798: LD_INT 1
57800: ARRAY
57801: PUSH
57802: LD_INT 1
57804: ARRAY
57805: PUSH
57806: LD_STRING p
57808: EQUAL
57809: IFFALSE 57819
// result := true ;
57811: LD_ADDR_VAR 0 2
57815: PUSH
57816: LD_INT 1
57818: ST_TO_ADDR
// end ;
57819: LD_VAR 0 2
57823: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57824: LD_INT 0
57826: PPUSH
57827: PPUSH
57828: PPUSH
57829: PPUSH
// if pos < 1 then
57830: LD_VAR 0 2
57834: PUSH
57835: LD_INT 1
57837: LESS
57838: IFFALSE 57842
// exit ;
57840: GO 58145
// if pos = 1 then
57842: LD_VAR 0 2
57846: PUSH
57847: LD_INT 1
57849: EQUAL
57850: IFFALSE 57883
// result := Replace ( arr , pos [ 1 ] , value ) else
57852: LD_ADDR_VAR 0 4
57856: PUSH
57857: LD_VAR 0 1
57861: PPUSH
57862: LD_VAR 0 2
57866: PUSH
57867: LD_INT 1
57869: ARRAY
57870: PPUSH
57871: LD_VAR 0 3
57875: PPUSH
57876: CALL_OW 1
57880: ST_TO_ADDR
57881: GO 58145
// begin tmp := arr ;
57883: LD_ADDR_VAR 0 6
57887: PUSH
57888: LD_VAR 0 1
57892: ST_TO_ADDR
// s_arr := [ tmp ] ;
57893: LD_ADDR_VAR 0 7
57897: PUSH
57898: LD_VAR 0 6
57902: PUSH
57903: EMPTY
57904: LIST
57905: ST_TO_ADDR
// for i = 1 to pos - 1 do
57906: LD_ADDR_VAR 0 5
57910: PUSH
57911: DOUBLE
57912: LD_INT 1
57914: DEC
57915: ST_TO_ADDR
57916: LD_VAR 0 2
57920: PUSH
57921: LD_INT 1
57923: MINUS
57924: PUSH
57925: FOR_TO
57926: IFFALSE 57971
// begin tmp := tmp [ pos [ i ] ] ;
57928: LD_ADDR_VAR 0 6
57932: PUSH
57933: LD_VAR 0 6
57937: PUSH
57938: LD_VAR 0 2
57942: PUSH
57943: LD_VAR 0 5
57947: ARRAY
57948: ARRAY
57949: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57950: LD_ADDR_VAR 0 7
57954: PUSH
57955: LD_VAR 0 7
57959: PUSH
57960: LD_VAR 0 6
57964: PUSH
57965: EMPTY
57966: LIST
57967: ADD
57968: ST_TO_ADDR
// end ;
57969: GO 57925
57971: POP
57972: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57973: LD_ADDR_VAR 0 6
57977: PUSH
57978: LD_VAR 0 6
57982: PPUSH
57983: LD_VAR 0 2
57987: PUSH
57988: LD_VAR 0 2
57992: ARRAY
57993: PPUSH
57994: LD_VAR 0 3
57998: PPUSH
57999: CALL_OW 1
58003: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
58004: LD_ADDR_VAR 0 7
58008: PUSH
58009: LD_VAR 0 7
58013: PPUSH
58014: LD_VAR 0 7
58018: PPUSH
58019: LD_VAR 0 6
58023: PPUSH
58024: CALL_OW 1
58028: ST_TO_ADDR
// for i = s_arr downto 2 do
58029: LD_ADDR_VAR 0 5
58033: PUSH
58034: DOUBLE
58035: LD_VAR 0 7
58039: INC
58040: ST_TO_ADDR
58041: LD_INT 2
58043: PUSH
58044: FOR_DOWNTO
58045: IFFALSE 58129
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58047: LD_ADDR_VAR 0 6
58051: PUSH
58052: LD_VAR 0 7
58056: PUSH
58057: LD_VAR 0 5
58061: PUSH
58062: LD_INT 1
58064: MINUS
58065: ARRAY
58066: PPUSH
58067: LD_VAR 0 2
58071: PUSH
58072: LD_VAR 0 5
58076: PUSH
58077: LD_INT 1
58079: MINUS
58080: ARRAY
58081: PPUSH
58082: LD_VAR 0 7
58086: PUSH
58087: LD_VAR 0 5
58091: ARRAY
58092: PPUSH
58093: CALL_OW 1
58097: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58098: LD_ADDR_VAR 0 7
58102: PUSH
58103: LD_VAR 0 7
58107: PPUSH
58108: LD_VAR 0 5
58112: PUSH
58113: LD_INT 1
58115: MINUS
58116: PPUSH
58117: LD_VAR 0 6
58121: PPUSH
58122: CALL_OW 1
58126: ST_TO_ADDR
// end ;
58127: GO 58044
58129: POP
58130: POP
// result := s_arr [ 1 ] ;
58131: LD_ADDR_VAR 0 4
58135: PUSH
58136: LD_VAR 0 7
58140: PUSH
58141: LD_INT 1
58143: ARRAY
58144: ST_TO_ADDR
// end ; end ;
58145: LD_VAR 0 4
58149: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58150: LD_INT 0
58152: PPUSH
58153: PPUSH
// if not list then
58154: LD_VAR 0 1
58158: NOT
58159: IFFALSE 58163
// exit ;
58161: GO 58254
// i := list [ pos1 ] ;
58163: LD_ADDR_VAR 0 5
58167: PUSH
58168: LD_VAR 0 1
58172: PUSH
58173: LD_VAR 0 2
58177: ARRAY
58178: ST_TO_ADDR
// if not i then
58179: LD_VAR 0 5
58183: NOT
58184: IFFALSE 58188
// exit ;
58186: GO 58254
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58188: LD_ADDR_VAR 0 1
58192: PUSH
58193: LD_VAR 0 1
58197: PPUSH
58198: LD_VAR 0 2
58202: PPUSH
58203: LD_VAR 0 1
58207: PUSH
58208: LD_VAR 0 3
58212: ARRAY
58213: PPUSH
58214: CALL_OW 1
58218: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58219: LD_ADDR_VAR 0 1
58223: PUSH
58224: LD_VAR 0 1
58228: PPUSH
58229: LD_VAR 0 3
58233: PPUSH
58234: LD_VAR 0 5
58238: PPUSH
58239: CALL_OW 1
58243: ST_TO_ADDR
// result := list ;
58244: LD_ADDR_VAR 0 4
58248: PUSH
58249: LD_VAR 0 1
58253: ST_TO_ADDR
// end ;
58254: LD_VAR 0 4
58258: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58259: LD_INT 0
58261: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58262: LD_ADDR_VAR 0 5
58266: PUSH
58267: LD_VAR 0 1
58271: PPUSH
58272: CALL_OW 250
58276: PPUSH
58277: LD_VAR 0 1
58281: PPUSH
58282: CALL_OW 251
58286: PPUSH
58287: LD_VAR 0 2
58291: PPUSH
58292: LD_VAR 0 3
58296: PPUSH
58297: LD_VAR 0 4
58301: PPUSH
58302: CALL 58312 0 5
58306: ST_TO_ADDR
// end ;
58307: LD_VAR 0 5
58311: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58312: LD_INT 0
58314: PPUSH
58315: PPUSH
58316: PPUSH
58317: PPUSH
// if not list then
58318: LD_VAR 0 3
58322: NOT
58323: IFFALSE 58327
// exit ;
58325: GO 58715
// result := [ ] ;
58327: LD_ADDR_VAR 0 6
58331: PUSH
58332: EMPTY
58333: ST_TO_ADDR
// for i in list do
58334: LD_ADDR_VAR 0 7
58338: PUSH
58339: LD_VAR 0 3
58343: PUSH
58344: FOR_IN
58345: IFFALSE 58547
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58347: LD_ADDR_VAR 0 9
58351: PUSH
58352: LD_VAR 0 7
58356: PPUSH
58357: LD_VAR 0 1
58361: PPUSH
58362: LD_VAR 0 2
58366: PPUSH
58367: CALL_OW 297
58371: ST_TO_ADDR
// if not result then
58372: LD_VAR 0 6
58376: NOT
58377: IFFALSE 58403
// result := [ [ i , tmp ] ] else
58379: LD_ADDR_VAR 0 6
58383: PUSH
58384: LD_VAR 0 7
58388: PUSH
58389: LD_VAR 0 9
58393: PUSH
58394: EMPTY
58395: LIST
58396: LIST
58397: PUSH
58398: EMPTY
58399: LIST
58400: ST_TO_ADDR
58401: GO 58545
// begin if result [ result ] [ 2 ] < tmp then
58403: LD_VAR 0 6
58407: PUSH
58408: LD_VAR 0 6
58412: ARRAY
58413: PUSH
58414: LD_INT 2
58416: ARRAY
58417: PUSH
58418: LD_VAR 0 9
58422: LESS
58423: IFFALSE 58465
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58425: LD_ADDR_VAR 0 6
58429: PUSH
58430: LD_VAR 0 6
58434: PPUSH
58435: LD_VAR 0 6
58439: PUSH
58440: LD_INT 1
58442: PLUS
58443: PPUSH
58444: LD_VAR 0 7
58448: PUSH
58449: LD_VAR 0 9
58453: PUSH
58454: EMPTY
58455: LIST
58456: LIST
58457: PPUSH
58458: CALL_OW 2
58462: ST_TO_ADDR
58463: GO 58545
// for j = 1 to result do
58465: LD_ADDR_VAR 0 8
58469: PUSH
58470: DOUBLE
58471: LD_INT 1
58473: DEC
58474: ST_TO_ADDR
58475: LD_VAR 0 6
58479: PUSH
58480: FOR_TO
58481: IFFALSE 58543
// begin if tmp < result [ j ] [ 2 ] then
58483: LD_VAR 0 9
58487: PUSH
58488: LD_VAR 0 6
58492: PUSH
58493: LD_VAR 0 8
58497: ARRAY
58498: PUSH
58499: LD_INT 2
58501: ARRAY
58502: LESS
58503: IFFALSE 58541
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58505: LD_ADDR_VAR 0 6
58509: PUSH
58510: LD_VAR 0 6
58514: PPUSH
58515: LD_VAR 0 8
58519: PPUSH
58520: LD_VAR 0 7
58524: PUSH
58525: LD_VAR 0 9
58529: PUSH
58530: EMPTY
58531: LIST
58532: LIST
58533: PPUSH
58534: CALL_OW 2
58538: ST_TO_ADDR
// break ;
58539: GO 58543
// end ; end ;
58541: GO 58480
58543: POP
58544: POP
// end ; end ;
58545: GO 58344
58547: POP
58548: POP
// if result and not asc then
58549: LD_VAR 0 6
58553: PUSH
58554: LD_VAR 0 4
58558: NOT
58559: AND
58560: IFFALSE 58635
// begin tmp := result ;
58562: LD_ADDR_VAR 0 9
58566: PUSH
58567: LD_VAR 0 6
58571: ST_TO_ADDR
// for i = tmp downto 1 do
58572: LD_ADDR_VAR 0 7
58576: PUSH
58577: DOUBLE
58578: LD_VAR 0 9
58582: INC
58583: ST_TO_ADDR
58584: LD_INT 1
58586: PUSH
58587: FOR_DOWNTO
58588: IFFALSE 58633
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58590: LD_ADDR_VAR 0 6
58594: PUSH
58595: LD_VAR 0 6
58599: PPUSH
58600: LD_VAR 0 9
58604: PUSH
58605: LD_VAR 0 7
58609: MINUS
58610: PUSH
58611: LD_INT 1
58613: PLUS
58614: PPUSH
58615: LD_VAR 0 9
58619: PUSH
58620: LD_VAR 0 7
58624: ARRAY
58625: PPUSH
58626: CALL_OW 1
58630: ST_TO_ADDR
58631: GO 58587
58633: POP
58634: POP
// end ; tmp := [ ] ;
58635: LD_ADDR_VAR 0 9
58639: PUSH
58640: EMPTY
58641: ST_TO_ADDR
// if mode then
58642: LD_VAR 0 5
58646: IFFALSE 58715
// begin for i = 1 to result do
58648: LD_ADDR_VAR 0 7
58652: PUSH
58653: DOUBLE
58654: LD_INT 1
58656: DEC
58657: ST_TO_ADDR
58658: LD_VAR 0 6
58662: PUSH
58663: FOR_TO
58664: IFFALSE 58703
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58666: LD_ADDR_VAR 0 9
58670: PUSH
58671: LD_VAR 0 9
58675: PPUSH
58676: LD_VAR 0 7
58680: PPUSH
58681: LD_VAR 0 6
58685: PUSH
58686: LD_VAR 0 7
58690: ARRAY
58691: PUSH
58692: LD_INT 1
58694: ARRAY
58695: PPUSH
58696: CALL_OW 1
58700: ST_TO_ADDR
58701: GO 58663
58703: POP
58704: POP
// result := tmp ;
58705: LD_ADDR_VAR 0 6
58709: PUSH
58710: LD_VAR 0 9
58714: ST_TO_ADDR
// end ; end ;
58715: LD_VAR 0 6
58719: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58720: LD_INT 0
58722: PPUSH
58723: PPUSH
58724: PPUSH
58725: PPUSH
58726: PPUSH
58727: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58728: LD_ADDR_VAR 0 5
58732: PUSH
58733: LD_INT 0
58735: PUSH
58736: LD_INT 0
58738: PUSH
58739: LD_INT 0
58741: PUSH
58742: EMPTY
58743: PUSH
58744: EMPTY
58745: LIST
58746: LIST
58747: LIST
58748: LIST
58749: ST_TO_ADDR
// if not x or not y then
58750: LD_VAR 0 2
58754: NOT
58755: PUSH
58756: LD_VAR 0 3
58760: NOT
58761: OR
58762: IFFALSE 58766
// exit ;
58764: GO 60416
// if not range then
58766: LD_VAR 0 4
58770: NOT
58771: IFFALSE 58781
// range := 10 ;
58773: LD_ADDR_VAR 0 4
58777: PUSH
58778: LD_INT 10
58780: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58781: LD_ADDR_VAR 0 8
58785: PUSH
58786: LD_INT 81
58788: PUSH
58789: LD_VAR 0 1
58793: PUSH
58794: EMPTY
58795: LIST
58796: LIST
58797: PUSH
58798: LD_INT 92
58800: PUSH
58801: LD_VAR 0 2
58805: PUSH
58806: LD_VAR 0 3
58810: PUSH
58811: LD_VAR 0 4
58815: PUSH
58816: EMPTY
58817: LIST
58818: LIST
58819: LIST
58820: LIST
58821: PUSH
58822: LD_INT 3
58824: PUSH
58825: LD_INT 21
58827: PUSH
58828: LD_INT 3
58830: PUSH
58831: EMPTY
58832: LIST
58833: LIST
58834: PUSH
58835: EMPTY
58836: LIST
58837: LIST
58838: PUSH
58839: EMPTY
58840: LIST
58841: LIST
58842: LIST
58843: PPUSH
58844: CALL_OW 69
58848: ST_TO_ADDR
// if not tmp then
58849: LD_VAR 0 8
58853: NOT
58854: IFFALSE 58858
// exit ;
58856: GO 60416
// for i in tmp do
58858: LD_ADDR_VAR 0 6
58862: PUSH
58863: LD_VAR 0 8
58867: PUSH
58868: FOR_IN
58869: IFFALSE 60391
// begin points := [ 0 , 0 , 0 ] ;
58871: LD_ADDR_VAR 0 9
58875: PUSH
58876: LD_INT 0
58878: PUSH
58879: LD_INT 0
58881: PUSH
58882: LD_INT 0
58884: PUSH
58885: EMPTY
58886: LIST
58887: LIST
58888: LIST
58889: ST_TO_ADDR
// bpoints := 1 ;
58890: LD_ADDR_VAR 0 10
58894: PUSH
58895: LD_INT 1
58897: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58898: LD_VAR 0 6
58902: PPUSH
58903: CALL_OW 247
58907: PUSH
58908: LD_INT 1
58910: DOUBLE
58911: EQUAL
58912: IFTRUE 58916
58914: GO 59494
58916: POP
// begin if GetClass ( i ) = 1 then
58917: LD_VAR 0 6
58921: PPUSH
58922: CALL_OW 257
58926: PUSH
58927: LD_INT 1
58929: EQUAL
58930: IFFALSE 58951
// points := [ 10 , 5 , 3 ] ;
58932: LD_ADDR_VAR 0 9
58936: PUSH
58937: LD_INT 10
58939: PUSH
58940: LD_INT 5
58942: PUSH
58943: LD_INT 3
58945: PUSH
58946: EMPTY
58947: LIST
58948: LIST
58949: LIST
58950: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58951: LD_VAR 0 6
58955: PPUSH
58956: CALL_OW 257
58960: PUSH
58961: LD_INT 2
58963: PUSH
58964: LD_INT 3
58966: PUSH
58967: LD_INT 4
58969: PUSH
58970: EMPTY
58971: LIST
58972: LIST
58973: LIST
58974: IN
58975: IFFALSE 58996
// points := [ 3 , 2 , 1 ] ;
58977: LD_ADDR_VAR 0 9
58981: PUSH
58982: LD_INT 3
58984: PUSH
58985: LD_INT 2
58987: PUSH
58988: LD_INT 1
58990: PUSH
58991: EMPTY
58992: LIST
58993: LIST
58994: LIST
58995: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58996: LD_VAR 0 6
59000: PPUSH
59001: CALL_OW 257
59005: PUSH
59006: LD_INT 5
59008: EQUAL
59009: IFFALSE 59030
// points := [ 130 , 5 , 2 ] ;
59011: LD_ADDR_VAR 0 9
59015: PUSH
59016: LD_INT 130
59018: PUSH
59019: LD_INT 5
59021: PUSH
59022: LD_INT 2
59024: PUSH
59025: EMPTY
59026: LIST
59027: LIST
59028: LIST
59029: ST_TO_ADDR
// if GetClass ( i ) = 8 then
59030: LD_VAR 0 6
59034: PPUSH
59035: CALL_OW 257
59039: PUSH
59040: LD_INT 8
59042: EQUAL
59043: IFFALSE 59064
// points := [ 35 , 35 , 30 ] ;
59045: LD_ADDR_VAR 0 9
59049: PUSH
59050: LD_INT 35
59052: PUSH
59053: LD_INT 35
59055: PUSH
59056: LD_INT 30
59058: PUSH
59059: EMPTY
59060: LIST
59061: LIST
59062: LIST
59063: ST_TO_ADDR
// if GetClass ( i ) = 9 then
59064: LD_VAR 0 6
59068: PPUSH
59069: CALL_OW 257
59073: PUSH
59074: LD_INT 9
59076: EQUAL
59077: IFFALSE 59098
// points := [ 20 , 55 , 40 ] ;
59079: LD_ADDR_VAR 0 9
59083: PUSH
59084: LD_INT 20
59086: PUSH
59087: LD_INT 55
59089: PUSH
59090: LD_INT 40
59092: PUSH
59093: EMPTY
59094: LIST
59095: LIST
59096: LIST
59097: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
59098: LD_VAR 0 6
59102: PPUSH
59103: CALL_OW 257
59107: PUSH
59108: LD_INT 12
59110: PUSH
59111: LD_INT 16
59113: PUSH
59114: EMPTY
59115: LIST
59116: LIST
59117: IN
59118: IFFALSE 59139
// points := [ 5 , 3 , 2 ] ;
59120: LD_ADDR_VAR 0 9
59124: PUSH
59125: LD_INT 5
59127: PUSH
59128: LD_INT 3
59130: PUSH
59131: LD_INT 2
59133: PUSH
59134: EMPTY
59135: LIST
59136: LIST
59137: LIST
59138: ST_TO_ADDR
// if GetClass ( i ) = 17 then
59139: LD_VAR 0 6
59143: PPUSH
59144: CALL_OW 257
59148: PUSH
59149: LD_INT 17
59151: EQUAL
59152: IFFALSE 59173
// points := [ 100 , 50 , 75 ] ;
59154: LD_ADDR_VAR 0 9
59158: PUSH
59159: LD_INT 100
59161: PUSH
59162: LD_INT 50
59164: PUSH
59165: LD_INT 75
59167: PUSH
59168: EMPTY
59169: LIST
59170: LIST
59171: LIST
59172: ST_TO_ADDR
// if GetClass ( i ) = 15 then
59173: LD_VAR 0 6
59177: PPUSH
59178: CALL_OW 257
59182: PUSH
59183: LD_INT 15
59185: EQUAL
59186: IFFALSE 59207
// points := [ 10 , 5 , 3 ] ;
59188: LD_ADDR_VAR 0 9
59192: PUSH
59193: LD_INT 10
59195: PUSH
59196: LD_INT 5
59198: PUSH
59199: LD_INT 3
59201: PUSH
59202: EMPTY
59203: LIST
59204: LIST
59205: LIST
59206: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59207: LD_VAR 0 6
59211: PPUSH
59212: CALL_OW 257
59216: PUSH
59217: LD_INT 14
59219: EQUAL
59220: IFFALSE 59241
// points := [ 10 , 0 , 0 ] ;
59222: LD_ADDR_VAR 0 9
59226: PUSH
59227: LD_INT 10
59229: PUSH
59230: LD_INT 0
59232: PUSH
59233: LD_INT 0
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: LIST
59240: ST_TO_ADDR
// if GetClass ( i ) = 11 then
59241: LD_VAR 0 6
59245: PPUSH
59246: CALL_OW 257
59250: PUSH
59251: LD_INT 11
59253: EQUAL
59254: IFFALSE 59275
// points := [ 30 , 10 , 5 ] ;
59256: LD_ADDR_VAR 0 9
59260: PUSH
59261: LD_INT 30
59263: PUSH
59264: LD_INT 10
59266: PUSH
59267: LD_INT 5
59269: PUSH
59270: EMPTY
59271: LIST
59272: LIST
59273: LIST
59274: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
59275: LD_VAR 0 1
59279: PPUSH
59280: LD_INT 5
59282: PPUSH
59283: CALL_OW 321
59287: PUSH
59288: LD_INT 2
59290: EQUAL
59291: IFFALSE 59308
// bpoints := bpoints * 1.8 ;
59293: LD_ADDR_VAR 0 10
59297: PUSH
59298: LD_VAR 0 10
59302: PUSH
59303: LD_REAL  1.80000000000000E+0000
59306: MUL
59307: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59308: LD_VAR 0 6
59312: PPUSH
59313: CALL_OW 257
59317: PUSH
59318: LD_INT 1
59320: PUSH
59321: LD_INT 2
59323: PUSH
59324: LD_INT 3
59326: PUSH
59327: LD_INT 4
59329: PUSH
59330: EMPTY
59331: LIST
59332: LIST
59333: LIST
59334: LIST
59335: IN
59336: PUSH
59337: LD_VAR 0 1
59341: PPUSH
59342: LD_INT 51
59344: PPUSH
59345: CALL_OW 321
59349: PUSH
59350: LD_INT 2
59352: EQUAL
59353: AND
59354: IFFALSE 59371
// bpoints := bpoints * 1.2 ;
59356: LD_ADDR_VAR 0 10
59360: PUSH
59361: LD_VAR 0 10
59365: PUSH
59366: LD_REAL  1.20000000000000E+0000
59369: MUL
59370: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59371: LD_VAR 0 6
59375: PPUSH
59376: CALL_OW 257
59380: PUSH
59381: LD_INT 5
59383: PUSH
59384: LD_INT 7
59386: PUSH
59387: LD_INT 9
59389: PUSH
59390: EMPTY
59391: LIST
59392: LIST
59393: LIST
59394: IN
59395: PUSH
59396: LD_VAR 0 1
59400: PPUSH
59401: LD_INT 52
59403: PPUSH
59404: CALL_OW 321
59408: PUSH
59409: LD_INT 2
59411: EQUAL
59412: AND
59413: IFFALSE 59430
// bpoints := bpoints * 1.5 ;
59415: LD_ADDR_VAR 0 10
59419: PUSH
59420: LD_VAR 0 10
59424: PUSH
59425: LD_REAL  1.50000000000000E+0000
59428: MUL
59429: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59430: LD_VAR 0 1
59434: PPUSH
59435: LD_INT 66
59437: PPUSH
59438: CALL_OW 321
59442: PUSH
59443: LD_INT 2
59445: EQUAL
59446: IFFALSE 59463
// bpoints := bpoints * 1.1 ;
59448: LD_ADDR_VAR 0 10
59452: PUSH
59453: LD_VAR 0 10
59457: PUSH
59458: LD_REAL  1.10000000000000E+0000
59461: MUL
59462: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59463: LD_ADDR_VAR 0 10
59467: PUSH
59468: LD_VAR 0 10
59472: PUSH
59473: LD_VAR 0 6
59477: PPUSH
59478: LD_INT 1
59480: PPUSH
59481: CALL_OW 259
59485: PUSH
59486: LD_REAL  1.15000000000000E+0000
59489: MUL
59490: MUL
59491: ST_TO_ADDR
// end ; unit_vehicle :
59492: GO 60320
59494: LD_INT 2
59496: DOUBLE
59497: EQUAL
59498: IFTRUE 59502
59500: GO 60308
59502: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59503: LD_VAR 0 6
59507: PPUSH
59508: CALL_OW 264
59512: PUSH
59513: LD_INT 2
59515: PUSH
59516: LD_INT 42
59518: PUSH
59519: LD_INT 24
59521: PUSH
59522: EMPTY
59523: LIST
59524: LIST
59525: LIST
59526: IN
59527: IFFALSE 59548
// points := [ 25 , 5 , 3 ] ;
59529: LD_ADDR_VAR 0 9
59533: PUSH
59534: LD_INT 25
59536: PUSH
59537: LD_INT 5
59539: PUSH
59540: LD_INT 3
59542: PUSH
59543: EMPTY
59544: LIST
59545: LIST
59546: LIST
59547: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59548: LD_VAR 0 6
59552: PPUSH
59553: CALL_OW 264
59557: PUSH
59558: LD_INT 4
59560: PUSH
59561: LD_INT 43
59563: PUSH
59564: LD_INT 25
59566: PUSH
59567: EMPTY
59568: LIST
59569: LIST
59570: LIST
59571: IN
59572: IFFALSE 59593
// points := [ 40 , 15 , 5 ] ;
59574: LD_ADDR_VAR 0 9
59578: PUSH
59579: LD_INT 40
59581: PUSH
59582: LD_INT 15
59584: PUSH
59585: LD_INT 5
59587: PUSH
59588: EMPTY
59589: LIST
59590: LIST
59591: LIST
59592: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59593: LD_VAR 0 6
59597: PPUSH
59598: CALL_OW 264
59602: PUSH
59603: LD_INT 3
59605: PUSH
59606: LD_INT 23
59608: PUSH
59609: EMPTY
59610: LIST
59611: LIST
59612: IN
59613: IFFALSE 59634
// points := [ 7 , 25 , 8 ] ;
59615: LD_ADDR_VAR 0 9
59619: PUSH
59620: LD_INT 7
59622: PUSH
59623: LD_INT 25
59625: PUSH
59626: LD_INT 8
59628: PUSH
59629: EMPTY
59630: LIST
59631: LIST
59632: LIST
59633: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59634: LD_VAR 0 6
59638: PPUSH
59639: CALL_OW 264
59643: PUSH
59644: LD_INT 5
59646: PUSH
59647: LD_INT 27
59649: PUSH
59650: LD_INT 44
59652: PUSH
59653: EMPTY
59654: LIST
59655: LIST
59656: LIST
59657: IN
59658: IFFALSE 59679
// points := [ 14 , 50 , 16 ] ;
59660: LD_ADDR_VAR 0 9
59664: PUSH
59665: LD_INT 14
59667: PUSH
59668: LD_INT 50
59670: PUSH
59671: LD_INT 16
59673: PUSH
59674: EMPTY
59675: LIST
59676: LIST
59677: LIST
59678: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59679: LD_VAR 0 6
59683: PPUSH
59684: CALL_OW 264
59688: PUSH
59689: LD_INT 6
59691: PUSH
59692: LD_INT 46
59694: PUSH
59695: EMPTY
59696: LIST
59697: LIST
59698: IN
59699: IFFALSE 59720
// points := [ 32 , 120 , 70 ] ;
59701: LD_ADDR_VAR 0 9
59705: PUSH
59706: LD_INT 32
59708: PUSH
59709: LD_INT 120
59711: PUSH
59712: LD_INT 70
59714: PUSH
59715: EMPTY
59716: LIST
59717: LIST
59718: LIST
59719: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
59720: LD_VAR 0 6
59724: PPUSH
59725: CALL_OW 264
59729: PUSH
59730: LD_INT 7
59732: PUSH
59733: LD_INT 28
59735: PUSH
59736: LD_INT 45
59738: PUSH
59739: LD_INT 92
59741: PUSH
59742: EMPTY
59743: LIST
59744: LIST
59745: LIST
59746: LIST
59747: IN
59748: IFFALSE 59769
// points := [ 35 , 20 , 45 ] ;
59750: LD_ADDR_VAR 0 9
59754: PUSH
59755: LD_INT 35
59757: PUSH
59758: LD_INT 20
59760: PUSH
59761: LD_INT 45
59763: PUSH
59764: EMPTY
59765: LIST
59766: LIST
59767: LIST
59768: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59769: LD_VAR 0 6
59773: PPUSH
59774: CALL_OW 264
59778: PUSH
59779: LD_INT 47
59781: PUSH
59782: EMPTY
59783: LIST
59784: IN
59785: IFFALSE 59806
// points := [ 67 , 45 , 75 ] ;
59787: LD_ADDR_VAR 0 9
59791: PUSH
59792: LD_INT 67
59794: PUSH
59795: LD_INT 45
59797: PUSH
59798: LD_INT 75
59800: PUSH
59801: EMPTY
59802: LIST
59803: LIST
59804: LIST
59805: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59806: LD_VAR 0 6
59810: PPUSH
59811: CALL_OW 264
59815: PUSH
59816: LD_INT 26
59818: PUSH
59819: EMPTY
59820: LIST
59821: IN
59822: IFFALSE 59843
// points := [ 120 , 30 , 80 ] ;
59824: LD_ADDR_VAR 0 9
59828: PUSH
59829: LD_INT 120
59831: PUSH
59832: LD_INT 30
59834: PUSH
59835: LD_INT 80
59837: PUSH
59838: EMPTY
59839: LIST
59840: LIST
59841: LIST
59842: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59843: LD_VAR 0 6
59847: PPUSH
59848: CALL_OW 264
59852: PUSH
59853: LD_INT 22
59855: PUSH
59856: EMPTY
59857: LIST
59858: IN
59859: IFFALSE 59880
// points := [ 40 , 1 , 1 ] ;
59861: LD_ADDR_VAR 0 9
59865: PUSH
59866: LD_INT 40
59868: PUSH
59869: LD_INT 1
59871: PUSH
59872: LD_INT 1
59874: PUSH
59875: EMPTY
59876: LIST
59877: LIST
59878: LIST
59879: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59880: LD_VAR 0 6
59884: PPUSH
59885: CALL_OW 264
59889: PUSH
59890: LD_INT 29
59892: PUSH
59893: EMPTY
59894: LIST
59895: IN
59896: IFFALSE 59917
// points := [ 70 , 200 , 400 ] ;
59898: LD_ADDR_VAR 0 9
59902: PUSH
59903: LD_INT 70
59905: PUSH
59906: LD_INT 200
59908: PUSH
59909: LD_INT 400
59911: PUSH
59912: EMPTY
59913: LIST
59914: LIST
59915: LIST
59916: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59917: LD_VAR 0 6
59921: PPUSH
59922: CALL_OW 264
59926: PUSH
59927: LD_INT 14
59929: PUSH
59930: LD_INT 53
59932: PUSH
59933: EMPTY
59934: LIST
59935: LIST
59936: IN
59937: IFFALSE 59958
// points := [ 40 , 10 , 20 ] ;
59939: LD_ADDR_VAR 0 9
59943: PUSH
59944: LD_INT 40
59946: PUSH
59947: LD_INT 10
59949: PUSH
59950: LD_INT 20
59952: PUSH
59953: EMPTY
59954: LIST
59955: LIST
59956: LIST
59957: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59958: LD_VAR 0 6
59962: PPUSH
59963: CALL_OW 264
59967: PUSH
59968: LD_INT 9
59970: PUSH
59971: EMPTY
59972: LIST
59973: IN
59974: IFFALSE 59995
// points := [ 5 , 70 , 20 ] ;
59976: LD_ADDR_VAR 0 9
59980: PUSH
59981: LD_INT 5
59983: PUSH
59984: LD_INT 70
59986: PUSH
59987: LD_INT 20
59989: PUSH
59990: EMPTY
59991: LIST
59992: LIST
59993: LIST
59994: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59995: LD_VAR 0 6
59999: PPUSH
60000: CALL_OW 264
60004: PUSH
60005: LD_INT 10
60007: PUSH
60008: EMPTY
60009: LIST
60010: IN
60011: IFFALSE 60032
// points := [ 35 , 110 , 70 ] ;
60013: LD_ADDR_VAR 0 9
60017: PUSH
60018: LD_INT 35
60020: PUSH
60021: LD_INT 110
60023: PUSH
60024: LD_INT 70
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: LIST
60031: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
60032: LD_VAR 0 6
60036: PPUSH
60037: CALL_OW 265
60041: PUSH
60042: LD_INT 25
60044: EQUAL
60045: IFFALSE 60066
// points := [ 80 , 65 , 100 ] ;
60047: LD_ADDR_VAR 0 9
60051: PUSH
60052: LD_INT 80
60054: PUSH
60055: LD_INT 65
60057: PUSH
60058: LD_INT 100
60060: PUSH
60061: EMPTY
60062: LIST
60063: LIST
60064: LIST
60065: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
60066: LD_VAR 0 6
60070: PPUSH
60071: CALL_OW 263
60075: PUSH
60076: LD_INT 1
60078: EQUAL
60079: IFFALSE 60114
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
60081: LD_ADDR_VAR 0 10
60085: PUSH
60086: LD_VAR 0 10
60090: PUSH
60091: LD_VAR 0 6
60095: PPUSH
60096: CALL_OW 311
60100: PPUSH
60101: LD_INT 3
60103: PPUSH
60104: CALL_OW 259
60108: PUSH
60109: LD_INT 4
60111: MUL
60112: MUL
60113: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
60114: LD_VAR 0 6
60118: PPUSH
60119: CALL_OW 263
60123: PUSH
60124: LD_INT 2
60126: EQUAL
60127: IFFALSE 60178
// begin j := IsControledBy ( i ) ;
60129: LD_ADDR_VAR 0 7
60133: PUSH
60134: LD_VAR 0 6
60138: PPUSH
60139: CALL_OW 312
60143: ST_TO_ADDR
// if j then
60144: LD_VAR 0 7
60148: IFFALSE 60178
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
60150: LD_ADDR_VAR 0 10
60154: PUSH
60155: LD_VAR 0 10
60159: PUSH
60160: LD_VAR 0 7
60164: PPUSH
60165: LD_INT 3
60167: PPUSH
60168: CALL_OW 259
60172: PUSH
60173: LD_INT 3
60175: MUL
60176: MUL
60177: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
60178: LD_VAR 0 6
60182: PPUSH
60183: CALL_OW 264
60187: PUSH
60188: LD_INT 5
60190: PUSH
60191: LD_INT 6
60193: PUSH
60194: LD_INT 46
60196: PUSH
60197: LD_INT 44
60199: PUSH
60200: LD_INT 47
60202: PUSH
60203: LD_INT 45
60205: PUSH
60206: LD_INT 28
60208: PUSH
60209: LD_INT 7
60211: PUSH
60212: LD_INT 27
60214: PUSH
60215: LD_INT 29
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: LIST
60222: LIST
60223: LIST
60224: LIST
60225: LIST
60226: LIST
60227: LIST
60228: LIST
60229: IN
60230: PUSH
60231: LD_VAR 0 1
60235: PPUSH
60236: LD_INT 52
60238: PPUSH
60239: CALL_OW 321
60243: PUSH
60244: LD_INT 2
60246: EQUAL
60247: AND
60248: IFFALSE 60265
// bpoints := bpoints * 1.2 ;
60250: LD_ADDR_VAR 0 10
60254: PUSH
60255: LD_VAR 0 10
60259: PUSH
60260: LD_REAL  1.20000000000000E+0000
60263: MUL
60264: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
60265: LD_VAR 0 6
60269: PPUSH
60270: CALL_OW 264
60274: PUSH
60275: LD_INT 6
60277: PUSH
60278: LD_INT 46
60280: PUSH
60281: LD_INT 47
60283: PUSH
60284: EMPTY
60285: LIST
60286: LIST
60287: LIST
60288: IN
60289: IFFALSE 60306
// bpoints := bpoints * 1.2 ;
60291: LD_ADDR_VAR 0 10
60295: PUSH
60296: LD_VAR 0 10
60300: PUSH
60301: LD_REAL  1.20000000000000E+0000
60304: MUL
60305: ST_TO_ADDR
// end ; unit_building :
60306: GO 60320
60308: LD_INT 3
60310: DOUBLE
60311: EQUAL
60312: IFTRUE 60316
60314: GO 60319
60316: POP
// ; end ;
60317: GO 60320
60319: POP
// for j = 1 to 3 do
60320: LD_ADDR_VAR 0 7
60324: PUSH
60325: DOUBLE
60326: LD_INT 1
60328: DEC
60329: ST_TO_ADDR
60330: LD_INT 3
60332: PUSH
60333: FOR_TO
60334: IFFALSE 60387
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60336: LD_ADDR_VAR 0 5
60340: PUSH
60341: LD_VAR 0 5
60345: PPUSH
60346: LD_VAR 0 7
60350: PPUSH
60351: LD_VAR 0 5
60355: PUSH
60356: LD_VAR 0 7
60360: ARRAY
60361: PUSH
60362: LD_VAR 0 9
60366: PUSH
60367: LD_VAR 0 7
60371: ARRAY
60372: PUSH
60373: LD_VAR 0 10
60377: MUL
60378: PLUS
60379: PPUSH
60380: CALL_OW 1
60384: ST_TO_ADDR
60385: GO 60333
60387: POP
60388: POP
// end ;
60389: GO 58868
60391: POP
60392: POP
// result := Replace ( result , 4 , tmp ) ;
60393: LD_ADDR_VAR 0 5
60397: PUSH
60398: LD_VAR 0 5
60402: PPUSH
60403: LD_INT 4
60405: PPUSH
60406: LD_VAR 0 8
60410: PPUSH
60411: CALL_OW 1
60415: ST_TO_ADDR
// end ;
60416: LD_VAR 0 5
60420: RET
// export function DangerAtRange ( unit , range ) ; begin
60421: LD_INT 0
60423: PPUSH
// if not unit then
60424: LD_VAR 0 1
60428: NOT
60429: IFFALSE 60433
// exit ;
60431: GO 60478
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60433: LD_ADDR_VAR 0 3
60437: PUSH
60438: LD_VAR 0 1
60442: PPUSH
60443: CALL_OW 255
60447: PPUSH
60448: LD_VAR 0 1
60452: PPUSH
60453: CALL_OW 250
60457: PPUSH
60458: LD_VAR 0 1
60462: PPUSH
60463: CALL_OW 251
60467: PPUSH
60468: LD_VAR 0 2
60472: PPUSH
60473: CALL 58720 0 4
60477: ST_TO_ADDR
// end ;
60478: LD_VAR 0 3
60482: RET
// export function DangerInArea ( side , area ) ; begin
60483: LD_INT 0
60485: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60486: LD_ADDR_VAR 0 3
60490: PUSH
60491: LD_VAR 0 2
60495: PPUSH
60496: LD_INT 81
60498: PUSH
60499: LD_VAR 0 1
60503: PUSH
60504: EMPTY
60505: LIST
60506: LIST
60507: PPUSH
60508: CALL_OW 70
60512: ST_TO_ADDR
// end ;
60513: LD_VAR 0 3
60517: RET
// export function IsExtension ( b ) ; begin
60518: LD_INT 0
60520: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60521: LD_ADDR_VAR 0 2
60525: PUSH
60526: LD_VAR 0 1
60530: PUSH
60531: LD_INT 23
60533: PUSH
60534: LD_INT 20
60536: PUSH
60537: LD_INT 22
60539: PUSH
60540: LD_INT 17
60542: PUSH
60543: LD_INT 24
60545: PUSH
60546: LD_INT 21
60548: PUSH
60549: LD_INT 19
60551: PUSH
60552: LD_INT 16
60554: PUSH
60555: LD_INT 25
60557: PUSH
60558: LD_INT 18
60560: PUSH
60561: EMPTY
60562: LIST
60563: LIST
60564: LIST
60565: LIST
60566: LIST
60567: LIST
60568: LIST
60569: LIST
60570: LIST
60571: LIST
60572: IN
60573: ST_TO_ADDR
// end ;
60574: LD_VAR 0 2
60578: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
60579: LD_INT 0
60581: PPUSH
60582: PPUSH
60583: PPUSH
// result := [ ] ;
60584: LD_ADDR_VAR 0 4
60588: PUSH
60589: EMPTY
60590: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60591: LD_ADDR_VAR 0 5
60595: PUSH
60596: LD_VAR 0 2
60600: PPUSH
60601: LD_INT 21
60603: PUSH
60604: LD_INT 3
60606: PUSH
60607: EMPTY
60608: LIST
60609: LIST
60610: PPUSH
60611: CALL_OW 70
60615: ST_TO_ADDR
// if not tmp then
60616: LD_VAR 0 5
60620: NOT
60621: IFFALSE 60625
// exit ;
60623: GO 60689
// if checkLink then
60625: LD_VAR 0 3
60629: IFFALSE 60679
// begin for i in tmp do
60631: LD_ADDR_VAR 0 6
60635: PUSH
60636: LD_VAR 0 5
60640: PUSH
60641: FOR_IN
60642: IFFALSE 60677
// if GetBase ( i ) <> base then
60644: LD_VAR 0 6
60648: PPUSH
60649: CALL_OW 274
60653: PUSH
60654: LD_VAR 0 1
60658: NONEQUAL
60659: IFFALSE 60675
// ComLinkToBase ( base , i ) ;
60661: LD_VAR 0 1
60665: PPUSH
60666: LD_VAR 0 6
60670: PPUSH
60671: CALL_OW 169
60675: GO 60641
60677: POP
60678: POP
// end ; result := tmp ;
60679: LD_ADDR_VAR 0 4
60683: PUSH
60684: LD_VAR 0 5
60688: ST_TO_ADDR
// end ;
60689: LD_VAR 0 4
60693: RET
// export function ComComplete ( units , b ) ; var i ; begin
60694: LD_INT 0
60696: PPUSH
60697: PPUSH
// if not units then
60698: LD_VAR 0 1
60702: NOT
60703: IFFALSE 60707
// exit ;
60705: GO 60797
// for i in units do
60707: LD_ADDR_VAR 0 4
60711: PUSH
60712: LD_VAR 0 1
60716: PUSH
60717: FOR_IN
60718: IFFALSE 60795
// if BuildingStatus ( b ) = bs_build then
60720: LD_VAR 0 2
60724: PPUSH
60725: CALL_OW 461
60729: PUSH
60730: LD_INT 1
60732: EQUAL
60733: IFFALSE 60793
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60735: LD_VAR 0 4
60739: PPUSH
60740: LD_STRING h
60742: PUSH
60743: LD_VAR 0 2
60747: PPUSH
60748: CALL_OW 250
60752: PUSH
60753: LD_VAR 0 2
60757: PPUSH
60758: CALL_OW 251
60762: PUSH
60763: LD_VAR 0 2
60767: PUSH
60768: LD_INT 0
60770: PUSH
60771: LD_INT 0
60773: PUSH
60774: LD_INT 0
60776: PUSH
60777: EMPTY
60778: LIST
60779: LIST
60780: LIST
60781: LIST
60782: LIST
60783: LIST
60784: LIST
60785: PUSH
60786: EMPTY
60787: LIST
60788: PPUSH
60789: CALL_OW 446
60793: GO 60717
60795: POP
60796: POP
// end ;
60797: LD_VAR 0 3
60801: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60802: LD_INT 0
60804: PPUSH
60805: PPUSH
60806: PPUSH
60807: PPUSH
60808: PPUSH
60809: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
60810: LD_VAR 0 1
60814: NOT
60815: PUSH
60816: LD_VAR 0 1
60820: PPUSH
60821: CALL_OW 263
60825: PUSH
60826: LD_INT 2
60828: NONEQUAL
60829: OR
60830: IFFALSE 60834
// exit ;
60832: GO 61150
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60834: LD_ADDR_VAR 0 6
60838: PUSH
60839: LD_INT 22
60841: PUSH
60842: LD_VAR 0 1
60846: PPUSH
60847: CALL_OW 255
60851: PUSH
60852: EMPTY
60853: LIST
60854: LIST
60855: PUSH
60856: LD_INT 2
60858: PUSH
60859: LD_INT 30
60861: PUSH
60862: LD_INT 36
60864: PUSH
60865: EMPTY
60866: LIST
60867: LIST
60868: PUSH
60869: LD_INT 34
60871: PUSH
60872: LD_INT 31
60874: PUSH
60875: EMPTY
60876: LIST
60877: LIST
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: LIST
60883: PUSH
60884: EMPTY
60885: LIST
60886: LIST
60887: PPUSH
60888: CALL_OW 69
60892: ST_TO_ADDR
// if not tmp then
60893: LD_VAR 0 6
60897: NOT
60898: IFFALSE 60902
// exit ;
60900: GO 61150
// result := [ ] ;
60902: LD_ADDR_VAR 0 2
60906: PUSH
60907: EMPTY
60908: ST_TO_ADDR
// for i in tmp do
60909: LD_ADDR_VAR 0 3
60913: PUSH
60914: LD_VAR 0 6
60918: PUSH
60919: FOR_IN
60920: IFFALSE 60991
// begin t := UnitsInside ( i ) ;
60922: LD_ADDR_VAR 0 4
60926: PUSH
60927: LD_VAR 0 3
60931: PPUSH
60932: CALL_OW 313
60936: ST_TO_ADDR
// if t then
60937: LD_VAR 0 4
60941: IFFALSE 60989
// for j in t do
60943: LD_ADDR_VAR 0 7
60947: PUSH
60948: LD_VAR 0 4
60952: PUSH
60953: FOR_IN
60954: IFFALSE 60987
// result := Replace ( result , result + 1 , j ) ;
60956: LD_ADDR_VAR 0 2
60960: PUSH
60961: LD_VAR 0 2
60965: PPUSH
60966: LD_VAR 0 2
60970: PUSH
60971: LD_INT 1
60973: PLUS
60974: PPUSH
60975: LD_VAR 0 7
60979: PPUSH
60980: CALL_OW 1
60984: ST_TO_ADDR
60985: GO 60953
60987: POP
60988: POP
// end ;
60989: GO 60919
60991: POP
60992: POP
// if not result then
60993: LD_VAR 0 2
60997: NOT
60998: IFFALSE 61002
// exit ;
61000: GO 61150
// mech := result [ 1 ] ;
61002: LD_ADDR_VAR 0 5
61006: PUSH
61007: LD_VAR 0 2
61011: PUSH
61012: LD_INT 1
61014: ARRAY
61015: ST_TO_ADDR
// if result > 1 then
61016: LD_VAR 0 2
61020: PUSH
61021: LD_INT 1
61023: GREATER
61024: IFFALSE 61136
// begin for i = 2 to result do
61026: LD_ADDR_VAR 0 3
61030: PUSH
61031: DOUBLE
61032: LD_INT 2
61034: DEC
61035: ST_TO_ADDR
61036: LD_VAR 0 2
61040: PUSH
61041: FOR_TO
61042: IFFALSE 61134
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
61044: LD_ADDR_VAR 0 4
61048: PUSH
61049: LD_VAR 0 2
61053: PUSH
61054: LD_VAR 0 3
61058: ARRAY
61059: PPUSH
61060: LD_INT 3
61062: PPUSH
61063: CALL_OW 259
61067: PUSH
61068: LD_VAR 0 2
61072: PUSH
61073: LD_VAR 0 3
61077: ARRAY
61078: PPUSH
61079: CALL_OW 432
61083: MINUS
61084: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
61085: LD_VAR 0 4
61089: PUSH
61090: LD_VAR 0 5
61094: PPUSH
61095: LD_INT 3
61097: PPUSH
61098: CALL_OW 259
61102: PUSH
61103: LD_VAR 0 5
61107: PPUSH
61108: CALL_OW 432
61112: MINUS
61113: GREATEREQUAL
61114: IFFALSE 61132
// mech := result [ i ] ;
61116: LD_ADDR_VAR 0 5
61120: PUSH
61121: LD_VAR 0 2
61125: PUSH
61126: LD_VAR 0 3
61130: ARRAY
61131: ST_TO_ADDR
// end ;
61132: GO 61041
61134: POP
61135: POP
// end ; ComLinkTo ( vehicle , mech ) ;
61136: LD_VAR 0 1
61140: PPUSH
61141: LD_VAR 0 5
61145: PPUSH
61146: CALL_OW 135
// end ;
61150: LD_VAR 0 2
61154: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
61155: LD_INT 0
61157: PPUSH
61158: PPUSH
61159: PPUSH
61160: PPUSH
61161: PPUSH
61162: PPUSH
61163: PPUSH
61164: PPUSH
61165: PPUSH
61166: PPUSH
61167: PPUSH
61168: PPUSH
61169: PPUSH
// result := [ ] ;
61170: LD_ADDR_VAR 0 7
61174: PUSH
61175: EMPTY
61176: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
61177: LD_VAR 0 1
61181: PPUSH
61182: CALL_OW 266
61186: PUSH
61187: LD_INT 0
61189: PUSH
61190: LD_INT 1
61192: PUSH
61193: EMPTY
61194: LIST
61195: LIST
61196: IN
61197: NOT
61198: IFFALSE 61202
// exit ;
61200: GO 62836
// if name then
61202: LD_VAR 0 3
61206: IFFALSE 61222
// SetBName ( base_dep , name ) ;
61208: LD_VAR 0 1
61212: PPUSH
61213: LD_VAR 0 3
61217: PPUSH
61218: CALL_OW 500
// base := GetBase ( base_dep ) ;
61222: LD_ADDR_VAR 0 15
61226: PUSH
61227: LD_VAR 0 1
61231: PPUSH
61232: CALL_OW 274
61236: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
61237: LD_ADDR_VAR 0 16
61241: PUSH
61242: LD_VAR 0 1
61246: PPUSH
61247: CALL_OW 255
61251: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
61252: LD_ADDR_VAR 0 17
61256: PUSH
61257: LD_VAR 0 1
61261: PPUSH
61262: CALL_OW 248
61266: ST_TO_ADDR
// if sources then
61267: LD_VAR 0 5
61271: IFFALSE 61318
// for i = 1 to 3 do
61273: LD_ADDR_VAR 0 8
61277: PUSH
61278: DOUBLE
61279: LD_INT 1
61281: DEC
61282: ST_TO_ADDR
61283: LD_INT 3
61285: PUSH
61286: FOR_TO
61287: IFFALSE 61316
// AddResourceType ( base , i , sources [ i ] ) ;
61289: LD_VAR 0 15
61293: PPUSH
61294: LD_VAR 0 8
61298: PPUSH
61299: LD_VAR 0 5
61303: PUSH
61304: LD_VAR 0 8
61308: ARRAY
61309: PPUSH
61310: CALL_OW 276
61314: GO 61286
61316: POP
61317: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
61318: LD_ADDR_VAR 0 18
61322: PUSH
61323: LD_VAR 0 15
61327: PPUSH
61328: LD_VAR 0 2
61332: PPUSH
61333: LD_INT 1
61335: PPUSH
61336: CALL 60579 0 3
61340: ST_TO_ADDR
// InitHc ;
61341: CALL_OW 19
// InitUc ;
61345: CALL_OW 18
// uc_side := side ;
61349: LD_ADDR_OWVAR 20
61353: PUSH
61354: LD_VAR 0 16
61358: ST_TO_ADDR
// uc_nation := nation ;
61359: LD_ADDR_OWVAR 21
61363: PUSH
61364: LD_VAR 0 17
61368: ST_TO_ADDR
// if buildings then
61369: LD_VAR 0 18
61373: IFFALSE 62695
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61375: LD_ADDR_VAR 0 19
61379: PUSH
61380: LD_VAR 0 18
61384: PPUSH
61385: LD_INT 2
61387: PUSH
61388: LD_INT 30
61390: PUSH
61391: LD_INT 29
61393: PUSH
61394: EMPTY
61395: LIST
61396: LIST
61397: PUSH
61398: LD_INT 30
61400: PUSH
61401: LD_INT 30
61403: PUSH
61404: EMPTY
61405: LIST
61406: LIST
61407: PUSH
61408: EMPTY
61409: LIST
61410: LIST
61411: LIST
61412: PPUSH
61413: CALL_OW 72
61417: ST_TO_ADDR
// if tmp then
61418: LD_VAR 0 19
61422: IFFALSE 61470
// for i in tmp do
61424: LD_ADDR_VAR 0 8
61428: PUSH
61429: LD_VAR 0 19
61433: PUSH
61434: FOR_IN
61435: IFFALSE 61468
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61437: LD_VAR 0 8
61441: PPUSH
61442: CALL_OW 250
61446: PPUSH
61447: LD_VAR 0 8
61451: PPUSH
61452: CALL_OW 251
61456: PPUSH
61457: LD_VAR 0 16
61461: PPUSH
61462: CALL_OW 441
61466: GO 61434
61468: POP
61469: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61470: LD_VAR 0 18
61474: PPUSH
61475: LD_INT 2
61477: PUSH
61478: LD_INT 30
61480: PUSH
61481: LD_INT 32
61483: PUSH
61484: EMPTY
61485: LIST
61486: LIST
61487: PUSH
61488: LD_INT 30
61490: PUSH
61491: LD_INT 33
61493: PUSH
61494: EMPTY
61495: LIST
61496: LIST
61497: PUSH
61498: EMPTY
61499: LIST
61500: LIST
61501: LIST
61502: PPUSH
61503: CALL_OW 72
61507: IFFALSE 61595
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61509: LD_ADDR_VAR 0 8
61513: PUSH
61514: LD_VAR 0 18
61518: PPUSH
61519: LD_INT 2
61521: PUSH
61522: LD_INT 30
61524: PUSH
61525: LD_INT 32
61527: PUSH
61528: EMPTY
61529: LIST
61530: LIST
61531: PUSH
61532: LD_INT 30
61534: PUSH
61535: LD_INT 33
61537: PUSH
61538: EMPTY
61539: LIST
61540: LIST
61541: PUSH
61542: EMPTY
61543: LIST
61544: LIST
61545: LIST
61546: PPUSH
61547: CALL_OW 72
61551: PUSH
61552: FOR_IN
61553: IFFALSE 61593
// begin if not GetBWeapon ( i ) then
61555: LD_VAR 0 8
61559: PPUSH
61560: CALL_OW 269
61564: NOT
61565: IFFALSE 61591
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61567: LD_VAR 0 8
61571: PPUSH
61572: LD_VAR 0 8
61576: PPUSH
61577: LD_VAR 0 2
61581: PPUSH
61582: CALL 62841 0 2
61586: PPUSH
61587: CALL_OW 431
// end ;
61591: GO 61552
61593: POP
61594: POP
// end ; for i = 1 to personel do
61595: LD_ADDR_VAR 0 8
61599: PUSH
61600: DOUBLE
61601: LD_INT 1
61603: DEC
61604: ST_TO_ADDR
61605: LD_VAR 0 6
61609: PUSH
61610: FOR_TO
61611: IFFALSE 62675
// begin if i > 4 then
61613: LD_VAR 0 8
61617: PUSH
61618: LD_INT 4
61620: GREATER
61621: IFFALSE 61625
// break ;
61623: GO 62675
// case i of 1 :
61625: LD_VAR 0 8
61629: PUSH
61630: LD_INT 1
61632: DOUBLE
61633: EQUAL
61634: IFTRUE 61638
61636: GO 61718
61638: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61639: LD_ADDR_VAR 0 12
61643: PUSH
61644: LD_VAR 0 18
61648: PPUSH
61649: LD_INT 22
61651: PUSH
61652: LD_VAR 0 16
61656: PUSH
61657: EMPTY
61658: LIST
61659: LIST
61660: PUSH
61661: LD_INT 58
61663: PUSH
61664: EMPTY
61665: LIST
61666: PUSH
61667: LD_INT 2
61669: PUSH
61670: LD_INT 30
61672: PUSH
61673: LD_INT 32
61675: PUSH
61676: EMPTY
61677: LIST
61678: LIST
61679: PUSH
61680: LD_INT 30
61682: PUSH
61683: LD_INT 4
61685: PUSH
61686: EMPTY
61687: LIST
61688: LIST
61689: PUSH
61690: LD_INT 30
61692: PUSH
61693: LD_INT 5
61695: PUSH
61696: EMPTY
61697: LIST
61698: LIST
61699: PUSH
61700: EMPTY
61701: LIST
61702: LIST
61703: LIST
61704: LIST
61705: PUSH
61706: EMPTY
61707: LIST
61708: LIST
61709: LIST
61710: PPUSH
61711: CALL_OW 72
61715: ST_TO_ADDR
61716: GO 61940
61718: LD_INT 2
61720: DOUBLE
61721: EQUAL
61722: IFTRUE 61726
61724: GO 61788
61726: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61727: LD_ADDR_VAR 0 12
61731: PUSH
61732: LD_VAR 0 18
61736: PPUSH
61737: LD_INT 22
61739: PUSH
61740: LD_VAR 0 16
61744: PUSH
61745: EMPTY
61746: LIST
61747: LIST
61748: PUSH
61749: LD_INT 2
61751: PUSH
61752: LD_INT 30
61754: PUSH
61755: LD_INT 0
61757: PUSH
61758: EMPTY
61759: LIST
61760: LIST
61761: PUSH
61762: LD_INT 30
61764: PUSH
61765: LD_INT 1
61767: PUSH
61768: EMPTY
61769: LIST
61770: LIST
61771: PUSH
61772: EMPTY
61773: LIST
61774: LIST
61775: LIST
61776: PUSH
61777: EMPTY
61778: LIST
61779: LIST
61780: PPUSH
61781: CALL_OW 72
61785: ST_TO_ADDR
61786: GO 61940
61788: LD_INT 3
61790: DOUBLE
61791: EQUAL
61792: IFTRUE 61796
61794: GO 61858
61796: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61797: LD_ADDR_VAR 0 12
61801: PUSH
61802: LD_VAR 0 18
61806: PPUSH
61807: LD_INT 22
61809: PUSH
61810: LD_VAR 0 16
61814: PUSH
61815: EMPTY
61816: LIST
61817: LIST
61818: PUSH
61819: LD_INT 2
61821: PUSH
61822: LD_INT 30
61824: PUSH
61825: LD_INT 2
61827: PUSH
61828: EMPTY
61829: LIST
61830: LIST
61831: PUSH
61832: LD_INT 30
61834: PUSH
61835: LD_INT 3
61837: PUSH
61838: EMPTY
61839: LIST
61840: LIST
61841: PUSH
61842: EMPTY
61843: LIST
61844: LIST
61845: LIST
61846: PUSH
61847: EMPTY
61848: LIST
61849: LIST
61850: PPUSH
61851: CALL_OW 72
61855: ST_TO_ADDR
61856: GO 61940
61858: LD_INT 4
61860: DOUBLE
61861: EQUAL
61862: IFTRUE 61866
61864: GO 61939
61866: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61867: LD_ADDR_VAR 0 12
61871: PUSH
61872: LD_VAR 0 18
61876: PPUSH
61877: LD_INT 22
61879: PUSH
61880: LD_VAR 0 16
61884: PUSH
61885: EMPTY
61886: LIST
61887: LIST
61888: PUSH
61889: LD_INT 2
61891: PUSH
61892: LD_INT 30
61894: PUSH
61895: LD_INT 6
61897: PUSH
61898: EMPTY
61899: LIST
61900: LIST
61901: PUSH
61902: LD_INT 30
61904: PUSH
61905: LD_INT 7
61907: PUSH
61908: EMPTY
61909: LIST
61910: LIST
61911: PUSH
61912: LD_INT 30
61914: PUSH
61915: LD_INT 8
61917: PUSH
61918: EMPTY
61919: LIST
61920: LIST
61921: PUSH
61922: EMPTY
61923: LIST
61924: LIST
61925: LIST
61926: LIST
61927: PUSH
61928: EMPTY
61929: LIST
61930: LIST
61931: PPUSH
61932: CALL_OW 72
61936: ST_TO_ADDR
61937: GO 61940
61939: POP
// if i = 1 then
61940: LD_VAR 0 8
61944: PUSH
61945: LD_INT 1
61947: EQUAL
61948: IFFALSE 62059
// begin tmp := [ ] ;
61950: LD_ADDR_VAR 0 19
61954: PUSH
61955: EMPTY
61956: ST_TO_ADDR
// for j in f do
61957: LD_ADDR_VAR 0 9
61961: PUSH
61962: LD_VAR 0 12
61966: PUSH
61967: FOR_IN
61968: IFFALSE 62041
// if GetBType ( j ) = b_bunker then
61970: LD_VAR 0 9
61974: PPUSH
61975: CALL_OW 266
61979: PUSH
61980: LD_INT 32
61982: EQUAL
61983: IFFALSE 62010
// tmp := Insert ( tmp , 1 , j ) else
61985: LD_ADDR_VAR 0 19
61989: PUSH
61990: LD_VAR 0 19
61994: PPUSH
61995: LD_INT 1
61997: PPUSH
61998: LD_VAR 0 9
62002: PPUSH
62003: CALL_OW 2
62007: ST_TO_ADDR
62008: GO 62039
// tmp := Insert ( tmp , tmp + 1 , j ) ;
62010: LD_ADDR_VAR 0 19
62014: PUSH
62015: LD_VAR 0 19
62019: PPUSH
62020: LD_VAR 0 19
62024: PUSH
62025: LD_INT 1
62027: PLUS
62028: PPUSH
62029: LD_VAR 0 9
62033: PPUSH
62034: CALL_OW 2
62038: ST_TO_ADDR
62039: GO 61967
62041: POP
62042: POP
// if tmp then
62043: LD_VAR 0 19
62047: IFFALSE 62059
// f := tmp ;
62049: LD_ADDR_VAR 0 12
62053: PUSH
62054: LD_VAR 0 19
62058: ST_TO_ADDR
// end ; x := personel [ i ] ;
62059: LD_ADDR_VAR 0 13
62063: PUSH
62064: LD_VAR 0 6
62068: PUSH
62069: LD_VAR 0 8
62073: ARRAY
62074: ST_TO_ADDR
// if x = - 1 then
62075: LD_VAR 0 13
62079: PUSH
62080: LD_INT 1
62082: NEG
62083: EQUAL
62084: IFFALSE 62293
// begin for j in f do
62086: LD_ADDR_VAR 0 9
62090: PUSH
62091: LD_VAR 0 12
62095: PUSH
62096: FOR_IN
62097: IFFALSE 62289
// repeat InitHc ;
62099: CALL_OW 19
// if GetBType ( j ) = b_barracks then
62103: LD_VAR 0 9
62107: PPUSH
62108: CALL_OW 266
62112: PUSH
62113: LD_INT 5
62115: EQUAL
62116: IFFALSE 62186
// begin if UnitsInside ( j ) < 3 then
62118: LD_VAR 0 9
62122: PPUSH
62123: CALL_OW 313
62127: PUSH
62128: LD_INT 3
62130: LESS
62131: IFFALSE 62167
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62133: LD_INT 0
62135: PPUSH
62136: LD_INT 5
62138: PUSH
62139: LD_INT 8
62141: PUSH
62142: LD_INT 9
62144: PUSH
62145: EMPTY
62146: LIST
62147: LIST
62148: LIST
62149: PUSH
62150: LD_VAR 0 17
62154: ARRAY
62155: PPUSH
62156: LD_VAR 0 4
62160: PPUSH
62161: CALL_OW 380
62165: GO 62184
// PrepareHuman ( false , i , skill ) ;
62167: LD_INT 0
62169: PPUSH
62170: LD_VAR 0 8
62174: PPUSH
62175: LD_VAR 0 4
62179: PPUSH
62180: CALL_OW 380
// end else
62184: GO 62203
// PrepareHuman ( false , i , skill ) ;
62186: LD_INT 0
62188: PPUSH
62189: LD_VAR 0 8
62193: PPUSH
62194: LD_VAR 0 4
62198: PPUSH
62199: CALL_OW 380
// un := CreateHuman ;
62203: LD_ADDR_VAR 0 14
62207: PUSH
62208: CALL_OW 44
62212: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62213: LD_ADDR_VAR 0 7
62217: PUSH
62218: LD_VAR 0 7
62222: PPUSH
62223: LD_INT 1
62225: PPUSH
62226: LD_VAR 0 14
62230: PPUSH
62231: CALL_OW 2
62235: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
62236: LD_VAR 0 14
62240: PPUSH
62241: LD_VAR 0 9
62245: PPUSH
62246: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
62250: LD_VAR 0 9
62254: PPUSH
62255: CALL_OW 313
62259: PUSH
62260: LD_INT 6
62262: EQUAL
62263: PUSH
62264: LD_VAR 0 9
62268: PPUSH
62269: CALL_OW 266
62273: PUSH
62274: LD_INT 32
62276: PUSH
62277: LD_INT 31
62279: PUSH
62280: EMPTY
62281: LIST
62282: LIST
62283: IN
62284: OR
62285: IFFALSE 62099
62287: GO 62096
62289: POP
62290: POP
// end else
62291: GO 62673
// for j = 1 to x do
62293: LD_ADDR_VAR 0 9
62297: PUSH
62298: DOUBLE
62299: LD_INT 1
62301: DEC
62302: ST_TO_ADDR
62303: LD_VAR 0 13
62307: PUSH
62308: FOR_TO
62309: IFFALSE 62671
// begin InitHc ;
62311: CALL_OW 19
// if not f then
62315: LD_VAR 0 12
62319: NOT
62320: IFFALSE 62409
// begin PrepareHuman ( false , i , skill ) ;
62322: LD_INT 0
62324: PPUSH
62325: LD_VAR 0 8
62329: PPUSH
62330: LD_VAR 0 4
62334: PPUSH
62335: CALL_OW 380
// un := CreateHuman ;
62339: LD_ADDR_VAR 0 14
62343: PUSH
62344: CALL_OW 44
62348: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62349: LD_ADDR_VAR 0 7
62353: PUSH
62354: LD_VAR 0 7
62358: PPUSH
62359: LD_INT 1
62361: PPUSH
62362: LD_VAR 0 14
62366: PPUSH
62367: CALL_OW 2
62371: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62372: LD_VAR 0 14
62376: PPUSH
62377: LD_VAR 0 1
62381: PPUSH
62382: CALL_OW 250
62386: PPUSH
62387: LD_VAR 0 1
62391: PPUSH
62392: CALL_OW 251
62396: PPUSH
62397: LD_INT 10
62399: PPUSH
62400: LD_INT 0
62402: PPUSH
62403: CALL_OW 50
// continue ;
62407: GO 62308
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62409: LD_VAR 0 12
62413: PUSH
62414: LD_INT 1
62416: ARRAY
62417: PPUSH
62418: CALL_OW 313
62422: PUSH
62423: LD_VAR 0 12
62427: PUSH
62428: LD_INT 1
62430: ARRAY
62431: PPUSH
62432: CALL_OW 266
62436: PUSH
62437: LD_INT 32
62439: PUSH
62440: LD_INT 31
62442: PUSH
62443: EMPTY
62444: LIST
62445: LIST
62446: IN
62447: AND
62448: PUSH
62449: LD_VAR 0 12
62453: PUSH
62454: LD_INT 1
62456: ARRAY
62457: PPUSH
62458: CALL_OW 313
62462: PUSH
62463: LD_INT 6
62465: EQUAL
62466: OR
62467: IFFALSE 62487
// f := Delete ( f , 1 ) ;
62469: LD_ADDR_VAR 0 12
62473: PUSH
62474: LD_VAR 0 12
62478: PPUSH
62479: LD_INT 1
62481: PPUSH
62482: CALL_OW 3
62486: ST_TO_ADDR
// if not f then
62487: LD_VAR 0 12
62491: NOT
62492: IFFALSE 62510
// begin x := x + 2 ;
62494: LD_ADDR_VAR 0 13
62498: PUSH
62499: LD_VAR 0 13
62503: PUSH
62504: LD_INT 2
62506: PLUS
62507: ST_TO_ADDR
// continue ;
62508: GO 62308
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62510: LD_VAR 0 12
62514: PUSH
62515: LD_INT 1
62517: ARRAY
62518: PPUSH
62519: CALL_OW 266
62523: PUSH
62524: LD_INT 5
62526: EQUAL
62527: IFFALSE 62601
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62529: LD_VAR 0 12
62533: PUSH
62534: LD_INT 1
62536: ARRAY
62537: PPUSH
62538: CALL_OW 313
62542: PUSH
62543: LD_INT 3
62545: LESS
62546: IFFALSE 62582
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62548: LD_INT 0
62550: PPUSH
62551: LD_INT 5
62553: PUSH
62554: LD_INT 8
62556: PUSH
62557: LD_INT 9
62559: PUSH
62560: EMPTY
62561: LIST
62562: LIST
62563: LIST
62564: PUSH
62565: LD_VAR 0 17
62569: ARRAY
62570: PPUSH
62571: LD_VAR 0 4
62575: PPUSH
62576: CALL_OW 380
62580: GO 62599
// PrepareHuman ( false , i , skill ) ;
62582: LD_INT 0
62584: PPUSH
62585: LD_VAR 0 8
62589: PPUSH
62590: LD_VAR 0 4
62594: PPUSH
62595: CALL_OW 380
// end else
62599: GO 62618
// PrepareHuman ( false , i , skill ) ;
62601: LD_INT 0
62603: PPUSH
62604: LD_VAR 0 8
62608: PPUSH
62609: LD_VAR 0 4
62613: PPUSH
62614: CALL_OW 380
// un := CreateHuman ;
62618: LD_ADDR_VAR 0 14
62622: PUSH
62623: CALL_OW 44
62627: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62628: LD_ADDR_VAR 0 7
62632: PUSH
62633: LD_VAR 0 7
62637: PPUSH
62638: LD_INT 1
62640: PPUSH
62641: LD_VAR 0 14
62645: PPUSH
62646: CALL_OW 2
62650: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62651: LD_VAR 0 14
62655: PPUSH
62656: LD_VAR 0 12
62660: PUSH
62661: LD_INT 1
62663: ARRAY
62664: PPUSH
62665: CALL_OW 52
// end ;
62669: GO 62308
62671: POP
62672: POP
// end ;
62673: GO 61610
62675: POP
62676: POP
// result := result ^ buildings ;
62677: LD_ADDR_VAR 0 7
62681: PUSH
62682: LD_VAR 0 7
62686: PUSH
62687: LD_VAR 0 18
62691: ADD
62692: ST_TO_ADDR
// end else
62693: GO 62836
// begin for i = 1 to personel do
62695: LD_ADDR_VAR 0 8
62699: PUSH
62700: DOUBLE
62701: LD_INT 1
62703: DEC
62704: ST_TO_ADDR
62705: LD_VAR 0 6
62709: PUSH
62710: FOR_TO
62711: IFFALSE 62834
// begin if i > 4 then
62713: LD_VAR 0 8
62717: PUSH
62718: LD_INT 4
62720: GREATER
62721: IFFALSE 62725
// break ;
62723: GO 62834
// x := personel [ i ] ;
62725: LD_ADDR_VAR 0 13
62729: PUSH
62730: LD_VAR 0 6
62734: PUSH
62735: LD_VAR 0 8
62739: ARRAY
62740: ST_TO_ADDR
// if x = - 1 then
62741: LD_VAR 0 13
62745: PUSH
62746: LD_INT 1
62748: NEG
62749: EQUAL
62750: IFFALSE 62754
// continue ;
62752: GO 62710
// PrepareHuman ( false , i , skill ) ;
62754: LD_INT 0
62756: PPUSH
62757: LD_VAR 0 8
62761: PPUSH
62762: LD_VAR 0 4
62766: PPUSH
62767: CALL_OW 380
// un := CreateHuman ;
62771: LD_ADDR_VAR 0 14
62775: PUSH
62776: CALL_OW 44
62780: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62781: LD_VAR 0 14
62785: PPUSH
62786: LD_VAR 0 1
62790: PPUSH
62791: CALL_OW 250
62795: PPUSH
62796: LD_VAR 0 1
62800: PPUSH
62801: CALL_OW 251
62805: PPUSH
62806: LD_INT 10
62808: PPUSH
62809: LD_INT 0
62811: PPUSH
62812: CALL_OW 50
// result := result ^ un ;
62816: LD_ADDR_VAR 0 7
62820: PUSH
62821: LD_VAR 0 7
62825: PUSH
62826: LD_VAR 0 14
62830: ADD
62831: ST_TO_ADDR
// end ;
62832: GO 62710
62834: POP
62835: POP
// end ; end ;
62836: LD_VAR 0 7
62840: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62841: LD_INT 0
62843: PPUSH
62844: PPUSH
62845: PPUSH
62846: PPUSH
62847: PPUSH
62848: PPUSH
62849: PPUSH
62850: PPUSH
62851: PPUSH
62852: PPUSH
62853: PPUSH
62854: PPUSH
62855: PPUSH
62856: PPUSH
62857: PPUSH
62858: PPUSH
// result := false ;
62859: LD_ADDR_VAR 0 3
62863: PUSH
62864: LD_INT 0
62866: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62867: LD_VAR 0 1
62871: NOT
62872: PUSH
62873: LD_VAR 0 1
62877: PPUSH
62878: CALL_OW 266
62882: PUSH
62883: LD_INT 32
62885: PUSH
62886: LD_INT 33
62888: PUSH
62889: EMPTY
62890: LIST
62891: LIST
62892: IN
62893: NOT
62894: OR
62895: IFFALSE 62899
// exit ;
62897: GO 64008
// nat := GetNation ( tower ) ;
62899: LD_ADDR_VAR 0 12
62903: PUSH
62904: LD_VAR 0 1
62908: PPUSH
62909: CALL_OW 248
62913: ST_TO_ADDR
// side := GetSide ( tower ) ;
62914: LD_ADDR_VAR 0 16
62918: PUSH
62919: LD_VAR 0 1
62923: PPUSH
62924: CALL_OW 255
62928: ST_TO_ADDR
// x := GetX ( tower ) ;
62929: LD_ADDR_VAR 0 10
62933: PUSH
62934: LD_VAR 0 1
62938: PPUSH
62939: CALL_OW 250
62943: ST_TO_ADDR
// y := GetY ( tower ) ;
62944: LD_ADDR_VAR 0 11
62948: PUSH
62949: LD_VAR 0 1
62953: PPUSH
62954: CALL_OW 251
62958: ST_TO_ADDR
// if not x or not y then
62959: LD_VAR 0 10
62963: NOT
62964: PUSH
62965: LD_VAR 0 11
62969: NOT
62970: OR
62971: IFFALSE 62975
// exit ;
62973: GO 64008
// weapon := 0 ;
62975: LD_ADDR_VAR 0 18
62979: PUSH
62980: LD_INT 0
62982: ST_TO_ADDR
// fac_list := [ ] ;
62983: LD_ADDR_VAR 0 17
62987: PUSH
62988: EMPTY
62989: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62990: LD_ADDR_VAR 0 6
62994: PUSH
62995: LD_VAR 0 1
62999: PPUSH
63000: CALL_OW 274
63004: PPUSH
63005: LD_VAR 0 2
63009: PPUSH
63010: LD_INT 0
63012: PPUSH
63013: CALL 60579 0 3
63017: PPUSH
63018: LD_INT 30
63020: PUSH
63021: LD_INT 3
63023: PUSH
63024: EMPTY
63025: LIST
63026: LIST
63027: PPUSH
63028: CALL_OW 72
63032: ST_TO_ADDR
// if not factories then
63033: LD_VAR 0 6
63037: NOT
63038: IFFALSE 63042
// exit ;
63040: GO 64008
// for i in factories do
63042: LD_ADDR_VAR 0 8
63046: PUSH
63047: LD_VAR 0 6
63051: PUSH
63052: FOR_IN
63053: IFFALSE 63078
// fac_list := fac_list union AvailableWeaponList ( i ) ;
63055: LD_ADDR_VAR 0 17
63059: PUSH
63060: LD_VAR 0 17
63064: PUSH
63065: LD_VAR 0 8
63069: PPUSH
63070: CALL_OW 478
63074: UNION
63075: ST_TO_ADDR
63076: GO 63052
63078: POP
63079: POP
// if not fac_list then
63080: LD_VAR 0 17
63084: NOT
63085: IFFALSE 63089
// exit ;
63087: GO 64008
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
63089: LD_ADDR_VAR 0 5
63093: PUSH
63094: LD_INT 4
63096: PUSH
63097: LD_INT 5
63099: PUSH
63100: LD_INT 9
63102: PUSH
63103: LD_INT 10
63105: PUSH
63106: LD_INT 6
63108: PUSH
63109: LD_INT 7
63111: PUSH
63112: LD_INT 11
63114: PUSH
63115: EMPTY
63116: LIST
63117: LIST
63118: LIST
63119: LIST
63120: LIST
63121: LIST
63122: LIST
63123: PUSH
63124: LD_INT 27
63126: PUSH
63127: LD_INT 28
63129: PUSH
63130: LD_INT 26
63132: PUSH
63133: LD_INT 30
63135: PUSH
63136: EMPTY
63137: LIST
63138: LIST
63139: LIST
63140: LIST
63141: PUSH
63142: LD_INT 43
63144: PUSH
63145: LD_INT 44
63147: PUSH
63148: LD_INT 46
63150: PUSH
63151: LD_INT 45
63153: PUSH
63154: LD_INT 47
63156: PUSH
63157: LD_INT 49
63159: PUSH
63160: EMPTY
63161: LIST
63162: LIST
63163: LIST
63164: LIST
63165: LIST
63166: LIST
63167: PUSH
63168: EMPTY
63169: LIST
63170: LIST
63171: LIST
63172: PUSH
63173: LD_VAR 0 12
63177: ARRAY
63178: ST_TO_ADDR
// list := list isect fac_list ;
63179: LD_ADDR_VAR 0 5
63183: PUSH
63184: LD_VAR 0 5
63188: PUSH
63189: LD_VAR 0 17
63193: ISECT
63194: ST_TO_ADDR
// if not list then
63195: LD_VAR 0 5
63199: NOT
63200: IFFALSE 63204
// exit ;
63202: GO 64008
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
63204: LD_VAR 0 12
63208: PUSH
63209: LD_INT 3
63211: EQUAL
63212: PUSH
63213: LD_INT 49
63215: PUSH
63216: LD_VAR 0 5
63220: IN
63221: AND
63222: PUSH
63223: LD_INT 31
63225: PPUSH
63226: LD_VAR 0 16
63230: PPUSH
63231: CALL_OW 321
63235: PUSH
63236: LD_INT 2
63238: EQUAL
63239: AND
63240: IFFALSE 63300
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
63242: LD_INT 22
63244: PUSH
63245: LD_VAR 0 16
63249: PUSH
63250: EMPTY
63251: LIST
63252: LIST
63253: PUSH
63254: LD_INT 35
63256: PUSH
63257: LD_INT 49
63259: PUSH
63260: EMPTY
63261: LIST
63262: LIST
63263: PUSH
63264: LD_INT 91
63266: PUSH
63267: LD_VAR 0 1
63271: PUSH
63272: LD_INT 10
63274: PUSH
63275: EMPTY
63276: LIST
63277: LIST
63278: LIST
63279: PUSH
63280: EMPTY
63281: LIST
63282: LIST
63283: LIST
63284: PPUSH
63285: CALL_OW 69
63289: NOT
63290: IFFALSE 63300
// weapon := ru_time_lapser ;
63292: LD_ADDR_VAR 0 18
63296: PUSH
63297: LD_INT 49
63299: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
63300: LD_VAR 0 12
63304: PUSH
63305: LD_INT 1
63307: PUSH
63308: LD_INT 2
63310: PUSH
63311: EMPTY
63312: LIST
63313: LIST
63314: IN
63315: PUSH
63316: LD_INT 11
63318: PUSH
63319: LD_VAR 0 5
63323: IN
63324: PUSH
63325: LD_INT 30
63327: PUSH
63328: LD_VAR 0 5
63332: IN
63333: OR
63334: AND
63335: PUSH
63336: LD_INT 6
63338: PPUSH
63339: LD_VAR 0 16
63343: PPUSH
63344: CALL_OW 321
63348: PUSH
63349: LD_INT 2
63351: EQUAL
63352: AND
63353: IFFALSE 63518
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63355: LD_INT 22
63357: PUSH
63358: LD_VAR 0 16
63362: PUSH
63363: EMPTY
63364: LIST
63365: LIST
63366: PUSH
63367: LD_INT 2
63369: PUSH
63370: LD_INT 35
63372: PUSH
63373: LD_INT 11
63375: PUSH
63376: EMPTY
63377: LIST
63378: LIST
63379: PUSH
63380: LD_INT 35
63382: PUSH
63383: LD_INT 30
63385: PUSH
63386: EMPTY
63387: LIST
63388: LIST
63389: PUSH
63390: EMPTY
63391: LIST
63392: LIST
63393: LIST
63394: PUSH
63395: LD_INT 91
63397: PUSH
63398: LD_VAR 0 1
63402: PUSH
63403: LD_INT 18
63405: PUSH
63406: EMPTY
63407: LIST
63408: LIST
63409: LIST
63410: PUSH
63411: EMPTY
63412: LIST
63413: LIST
63414: LIST
63415: PPUSH
63416: CALL_OW 69
63420: NOT
63421: PUSH
63422: LD_INT 22
63424: PUSH
63425: LD_VAR 0 16
63429: PUSH
63430: EMPTY
63431: LIST
63432: LIST
63433: PUSH
63434: LD_INT 2
63436: PUSH
63437: LD_INT 30
63439: PUSH
63440: LD_INT 32
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PUSH
63447: LD_INT 30
63449: PUSH
63450: LD_INT 33
63452: PUSH
63453: EMPTY
63454: LIST
63455: LIST
63456: PUSH
63457: EMPTY
63458: LIST
63459: LIST
63460: LIST
63461: PUSH
63462: LD_INT 91
63464: PUSH
63465: LD_VAR 0 1
63469: PUSH
63470: LD_INT 12
63472: PUSH
63473: EMPTY
63474: LIST
63475: LIST
63476: LIST
63477: PUSH
63478: EMPTY
63479: LIST
63480: LIST
63481: LIST
63482: PUSH
63483: EMPTY
63484: LIST
63485: PPUSH
63486: CALL_OW 69
63490: PUSH
63491: LD_INT 2
63493: GREATER
63494: AND
63495: IFFALSE 63518
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63497: LD_ADDR_VAR 0 18
63501: PUSH
63502: LD_INT 11
63504: PUSH
63505: LD_INT 30
63507: PUSH
63508: EMPTY
63509: LIST
63510: LIST
63511: PUSH
63512: LD_VAR 0 12
63516: ARRAY
63517: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63518: LD_VAR 0 18
63522: NOT
63523: PUSH
63524: LD_INT 40
63526: PPUSH
63527: LD_VAR 0 16
63531: PPUSH
63532: CALL_OW 321
63536: PUSH
63537: LD_INT 2
63539: EQUAL
63540: AND
63541: PUSH
63542: LD_INT 7
63544: PUSH
63545: LD_VAR 0 5
63549: IN
63550: PUSH
63551: LD_INT 28
63553: PUSH
63554: LD_VAR 0 5
63558: IN
63559: OR
63560: PUSH
63561: LD_INT 45
63563: PUSH
63564: LD_VAR 0 5
63568: IN
63569: OR
63570: AND
63571: IFFALSE 63825
// begin hex := GetHexInfo ( x , y ) ;
63573: LD_ADDR_VAR 0 4
63577: PUSH
63578: LD_VAR 0 10
63582: PPUSH
63583: LD_VAR 0 11
63587: PPUSH
63588: CALL_OW 546
63592: ST_TO_ADDR
// if hex [ 1 ] then
63593: LD_VAR 0 4
63597: PUSH
63598: LD_INT 1
63600: ARRAY
63601: IFFALSE 63605
// exit ;
63603: GO 64008
// height := hex [ 2 ] ;
63605: LD_ADDR_VAR 0 15
63609: PUSH
63610: LD_VAR 0 4
63614: PUSH
63615: LD_INT 2
63617: ARRAY
63618: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63619: LD_ADDR_VAR 0 14
63623: PUSH
63624: LD_INT 0
63626: PUSH
63627: LD_INT 2
63629: PUSH
63630: LD_INT 3
63632: PUSH
63633: LD_INT 5
63635: PUSH
63636: EMPTY
63637: LIST
63638: LIST
63639: LIST
63640: LIST
63641: ST_TO_ADDR
// for i in tmp do
63642: LD_ADDR_VAR 0 8
63646: PUSH
63647: LD_VAR 0 14
63651: PUSH
63652: FOR_IN
63653: IFFALSE 63823
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63655: LD_ADDR_VAR 0 9
63659: PUSH
63660: LD_VAR 0 10
63664: PPUSH
63665: LD_VAR 0 8
63669: PPUSH
63670: LD_INT 5
63672: PPUSH
63673: CALL_OW 272
63677: PUSH
63678: LD_VAR 0 11
63682: PPUSH
63683: LD_VAR 0 8
63687: PPUSH
63688: LD_INT 5
63690: PPUSH
63691: CALL_OW 273
63695: PUSH
63696: EMPTY
63697: LIST
63698: LIST
63699: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63700: LD_VAR 0 9
63704: PUSH
63705: LD_INT 1
63707: ARRAY
63708: PPUSH
63709: LD_VAR 0 9
63713: PUSH
63714: LD_INT 2
63716: ARRAY
63717: PPUSH
63718: CALL_OW 488
63722: IFFALSE 63821
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63724: LD_ADDR_VAR 0 4
63728: PUSH
63729: LD_VAR 0 9
63733: PUSH
63734: LD_INT 1
63736: ARRAY
63737: PPUSH
63738: LD_VAR 0 9
63742: PUSH
63743: LD_INT 2
63745: ARRAY
63746: PPUSH
63747: CALL_OW 546
63751: ST_TO_ADDR
// if hex [ 1 ] then
63752: LD_VAR 0 4
63756: PUSH
63757: LD_INT 1
63759: ARRAY
63760: IFFALSE 63764
// continue ;
63762: GO 63652
// h := hex [ 2 ] ;
63764: LD_ADDR_VAR 0 13
63768: PUSH
63769: LD_VAR 0 4
63773: PUSH
63774: LD_INT 2
63776: ARRAY
63777: ST_TO_ADDR
// if h + 7 < height then
63778: LD_VAR 0 13
63782: PUSH
63783: LD_INT 7
63785: PLUS
63786: PUSH
63787: LD_VAR 0 15
63791: LESS
63792: IFFALSE 63821
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63794: LD_ADDR_VAR 0 18
63798: PUSH
63799: LD_INT 7
63801: PUSH
63802: LD_INT 28
63804: PUSH
63805: LD_INT 45
63807: PUSH
63808: EMPTY
63809: LIST
63810: LIST
63811: LIST
63812: PUSH
63813: LD_VAR 0 12
63817: ARRAY
63818: ST_TO_ADDR
// break ;
63819: GO 63823
// end ; end ; end ;
63821: GO 63652
63823: POP
63824: POP
// end ; if not weapon then
63825: LD_VAR 0 18
63829: NOT
63830: IFFALSE 63890
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63832: LD_ADDR_VAR 0 5
63836: PUSH
63837: LD_VAR 0 5
63841: PUSH
63842: LD_INT 11
63844: PUSH
63845: LD_INT 30
63847: PUSH
63848: LD_INT 49
63850: PUSH
63851: EMPTY
63852: LIST
63853: LIST
63854: LIST
63855: DIFF
63856: ST_TO_ADDR
// if not list then
63857: LD_VAR 0 5
63861: NOT
63862: IFFALSE 63866
// exit ;
63864: GO 64008
// weapon := list [ rand ( 1 , list ) ] ;
63866: LD_ADDR_VAR 0 18
63870: PUSH
63871: LD_VAR 0 5
63875: PUSH
63876: LD_INT 1
63878: PPUSH
63879: LD_VAR 0 5
63883: PPUSH
63884: CALL_OW 12
63888: ARRAY
63889: ST_TO_ADDR
// end ; if weapon then
63890: LD_VAR 0 18
63894: IFFALSE 64008
// begin tmp := CostOfWeapon ( weapon ) ;
63896: LD_ADDR_VAR 0 14
63900: PUSH
63901: LD_VAR 0 18
63905: PPUSH
63906: CALL_OW 451
63910: ST_TO_ADDR
// j := GetBase ( tower ) ;
63911: LD_ADDR_VAR 0 9
63915: PUSH
63916: LD_VAR 0 1
63920: PPUSH
63921: CALL_OW 274
63925: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63926: LD_VAR 0 9
63930: PPUSH
63931: LD_INT 1
63933: PPUSH
63934: CALL_OW 275
63938: PUSH
63939: LD_VAR 0 14
63943: PUSH
63944: LD_INT 1
63946: ARRAY
63947: GREATEREQUAL
63948: PUSH
63949: LD_VAR 0 9
63953: PPUSH
63954: LD_INT 2
63956: PPUSH
63957: CALL_OW 275
63961: PUSH
63962: LD_VAR 0 14
63966: PUSH
63967: LD_INT 2
63969: ARRAY
63970: GREATEREQUAL
63971: AND
63972: PUSH
63973: LD_VAR 0 9
63977: PPUSH
63978: LD_INT 3
63980: PPUSH
63981: CALL_OW 275
63985: PUSH
63986: LD_VAR 0 14
63990: PUSH
63991: LD_INT 3
63993: ARRAY
63994: GREATEREQUAL
63995: AND
63996: IFFALSE 64008
// result := weapon ;
63998: LD_ADDR_VAR 0 3
64002: PUSH
64003: LD_VAR 0 18
64007: ST_TO_ADDR
// end ; end ;
64008: LD_VAR 0 3
64012: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
64013: LD_INT 0
64015: PPUSH
64016: PPUSH
// result := true ;
64017: LD_ADDR_VAR 0 3
64021: PUSH
64022: LD_INT 1
64024: ST_TO_ADDR
// if array1 = array2 then
64025: LD_VAR 0 1
64029: PUSH
64030: LD_VAR 0 2
64034: EQUAL
64035: IFFALSE 64095
// begin for i = 1 to array1 do
64037: LD_ADDR_VAR 0 4
64041: PUSH
64042: DOUBLE
64043: LD_INT 1
64045: DEC
64046: ST_TO_ADDR
64047: LD_VAR 0 1
64051: PUSH
64052: FOR_TO
64053: IFFALSE 64091
// if array1 [ i ] <> array2 [ i ] then
64055: LD_VAR 0 1
64059: PUSH
64060: LD_VAR 0 4
64064: ARRAY
64065: PUSH
64066: LD_VAR 0 2
64070: PUSH
64071: LD_VAR 0 4
64075: ARRAY
64076: NONEQUAL
64077: IFFALSE 64089
// begin result := false ;
64079: LD_ADDR_VAR 0 3
64083: PUSH
64084: LD_INT 0
64086: ST_TO_ADDR
// break ;
64087: GO 64091
// end ;
64089: GO 64052
64091: POP
64092: POP
// end else
64093: GO 64103
// result := false ;
64095: LD_ADDR_VAR 0 3
64099: PUSH
64100: LD_INT 0
64102: ST_TO_ADDR
// end ;
64103: LD_VAR 0 3
64107: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
64108: LD_INT 0
64110: PPUSH
64111: PPUSH
// if not array1 or not array2 then
64112: LD_VAR 0 1
64116: NOT
64117: PUSH
64118: LD_VAR 0 2
64122: NOT
64123: OR
64124: IFFALSE 64128
// exit ;
64126: GO 64192
// result := true ;
64128: LD_ADDR_VAR 0 3
64132: PUSH
64133: LD_INT 1
64135: ST_TO_ADDR
// for i = 1 to array1 do
64136: LD_ADDR_VAR 0 4
64140: PUSH
64141: DOUBLE
64142: LD_INT 1
64144: DEC
64145: ST_TO_ADDR
64146: LD_VAR 0 1
64150: PUSH
64151: FOR_TO
64152: IFFALSE 64190
// if array1 [ i ] <> array2 [ i ] then
64154: LD_VAR 0 1
64158: PUSH
64159: LD_VAR 0 4
64163: ARRAY
64164: PUSH
64165: LD_VAR 0 2
64169: PUSH
64170: LD_VAR 0 4
64174: ARRAY
64175: NONEQUAL
64176: IFFALSE 64188
// begin result := false ;
64178: LD_ADDR_VAR 0 3
64182: PUSH
64183: LD_INT 0
64185: ST_TO_ADDR
// break ;
64186: GO 64190
// end ;
64188: GO 64151
64190: POP
64191: POP
// end ;
64192: LD_VAR 0 3
64196: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
64197: LD_INT 0
64199: PPUSH
64200: PPUSH
64201: PPUSH
// pom := GetBase ( fac ) ;
64202: LD_ADDR_VAR 0 5
64206: PUSH
64207: LD_VAR 0 1
64211: PPUSH
64212: CALL_OW 274
64216: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
64217: LD_ADDR_VAR 0 4
64221: PUSH
64222: LD_VAR 0 2
64226: PUSH
64227: LD_INT 1
64229: ARRAY
64230: PPUSH
64231: LD_VAR 0 2
64235: PUSH
64236: LD_INT 2
64238: ARRAY
64239: PPUSH
64240: LD_VAR 0 2
64244: PUSH
64245: LD_INT 3
64247: ARRAY
64248: PPUSH
64249: LD_VAR 0 2
64253: PUSH
64254: LD_INT 4
64256: ARRAY
64257: PPUSH
64258: CALL_OW 449
64262: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64263: LD_ADDR_VAR 0 3
64267: PUSH
64268: LD_VAR 0 5
64272: PPUSH
64273: LD_INT 1
64275: PPUSH
64276: CALL_OW 275
64280: PUSH
64281: LD_VAR 0 4
64285: PUSH
64286: LD_INT 1
64288: ARRAY
64289: GREATEREQUAL
64290: PUSH
64291: LD_VAR 0 5
64295: PPUSH
64296: LD_INT 2
64298: PPUSH
64299: CALL_OW 275
64303: PUSH
64304: LD_VAR 0 4
64308: PUSH
64309: LD_INT 2
64311: ARRAY
64312: GREATEREQUAL
64313: AND
64314: PUSH
64315: LD_VAR 0 5
64319: PPUSH
64320: LD_INT 3
64322: PPUSH
64323: CALL_OW 275
64327: PUSH
64328: LD_VAR 0 4
64332: PUSH
64333: LD_INT 3
64335: ARRAY
64336: GREATEREQUAL
64337: AND
64338: ST_TO_ADDR
// end ;
64339: LD_VAR 0 3
64343: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
64344: LD_INT 0
64346: PPUSH
64347: PPUSH
64348: PPUSH
64349: PPUSH
// pom := GetBase ( building ) ;
64350: LD_ADDR_VAR 0 3
64354: PUSH
64355: LD_VAR 0 1
64359: PPUSH
64360: CALL_OW 274
64364: ST_TO_ADDR
// if not pom then
64365: LD_VAR 0 3
64369: NOT
64370: IFFALSE 64374
// exit ;
64372: GO 64544
// btype := GetBType ( building ) ;
64374: LD_ADDR_VAR 0 5
64378: PUSH
64379: LD_VAR 0 1
64383: PPUSH
64384: CALL_OW 266
64388: ST_TO_ADDR
// if btype = b_armoury then
64389: LD_VAR 0 5
64393: PUSH
64394: LD_INT 4
64396: EQUAL
64397: IFFALSE 64407
// btype := b_barracks ;
64399: LD_ADDR_VAR 0 5
64403: PUSH
64404: LD_INT 5
64406: ST_TO_ADDR
// if btype = b_depot then
64407: LD_VAR 0 5
64411: PUSH
64412: LD_INT 0
64414: EQUAL
64415: IFFALSE 64425
// btype := b_warehouse ;
64417: LD_ADDR_VAR 0 5
64421: PUSH
64422: LD_INT 1
64424: ST_TO_ADDR
// if btype = b_workshop then
64425: LD_VAR 0 5
64429: PUSH
64430: LD_INT 2
64432: EQUAL
64433: IFFALSE 64443
// btype := b_factory ;
64435: LD_ADDR_VAR 0 5
64439: PUSH
64440: LD_INT 3
64442: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64443: LD_ADDR_VAR 0 4
64447: PUSH
64448: LD_VAR 0 5
64452: PPUSH
64453: LD_VAR 0 1
64457: PPUSH
64458: CALL_OW 248
64462: PPUSH
64463: CALL_OW 450
64467: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64468: LD_ADDR_VAR 0 2
64472: PUSH
64473: LD_VAR 0 3
64477: PPUSH
64478: LD_INT 1
64480: PPUSH
64481: CALL_OW 275
64485: PUSH
64486: LD_VAR 0 4
64490: PUSH
64491: LD_INT 1
64493: ARRAY
64494: GREATEREQUAL
64495: PUSH
64496: LD_VAR 0 3
64500: PPUSH
64501: LD_INT 2
64503: PPUSH
64504: CALL_OW 275
64508: PUSH
64509: LD_VAR 0 4
64513: PUSH
64514: LD_INT 2
64516: ARRAY
64517: GREATEREQUAL
64518: AND
64519: PUSH
64520: LD_VAR 0 3
64524: PPUSH
64525: LD_INT 3
64527: PPUSH
64528: CALL_OW 275
64532: PUSH
64533: LD_VAR 0 4
64537: PUSH
64538: LD_INT 3
64540: ARRAY
64541: GREATEREQUAL
64542: AND
64543: ST_TO_ADDR
// end ;
64544: LD_VAR 0 2
64548: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64549: LD_INT 0
64551: PPUSH
64552: PPUSH
64553: PPUSH
// pom := GetBase ( building ) ;
64554: LD_ADDR_VAR 0 4
64558: PUSH
64559: LD_VAR 0 1
64563: PPUSH
64564: CALL_OW 274
64568: ST_TO_ADDR
// if not pom then
64569: LD_VAR 0 4
64573: NOT
64574: IFFALSE 64578
// exit ;
64576: GO 64679
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64578: LD_ADDR_VAR 0 5
64582: PUSH
64583: LD_VAR 0 2
64587: PPUSH
64588: LD_VAR 0 1
64592: PPUSH
64593: CALL_OW 248
64597: PPUSH
64598: CALL_OW 450
64602: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64603: LD_ADDR_VAR 0 3
64607: PUSH
64608: LD_VAR 0 4
64612: PPUSH
64613: LD_INT 1
64615: PPUSH
64616: CALL_OW 275
64620: PUSH
64621: LD_VAR 0 5
64625: PUSH
64626: LD_INT 1
64628: ARRAY
64629: GREATEREQUAL
64630: PUSH
64631: LD_VAR 0 4
64635: PPUSH
64636: LD_INT 2
64638: PPUSH
64639: CALL_OW 275
64643: PUSH
64644: LD_VAR 0 5
64648: PUSH
64649: LD_INT 2
64651: ARRAY
64652: GREATEREQUAL
64653: AND
64654: PUSH
64655: LD_VAR 0 4
64659: PPUSH
64660: LD_INT 3
64662: PPUSH
64663: CALL_OW 275
64667: PUSH
64668: LD_VAR 0 5
64672: PUSH
64673: LD_INT 3
64675: ARRAY
64676: GREATEREQUAL
64677: AND
64678: ST_TO_ADDR
// end ;
64679: LD_VAR 0 3
64683: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
64684: LD_INT 0
64686: PPUSH
64687: PPUSH
64688: PPUSH
64689: PPUSH
64690: PPUSH
64691: PPUSH
64692: PPUSH
64693: PPUSH
64694: PPUSH
64695: PPUSH
64696: PPUSH
// result := false ;
64697: LD_ADDR_VAR 0 8
64701: PUSH
64702: LD_INT 0
64704: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
64705: LD_VAR 0 5
64709: NOT
64710: PUSH
64711: LD_VAR 0 1
64715: NOT
64716: OR
64717: PUSH
64718: LD_VAR 0 2
64722: NOT
64723: OR
64724: PUSH
64725: LD_VAR 0 3
64729: NOT
64730: OR
64731: IFFALSE 64735
// exit ;
64733: GO 65549
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
64735: LD_ADDR_VAR 0 14
64739: PUSH
64740: LD_VAR 0 1
64744: PPUSH
64745: LD_VAR 0 2
64749: PPUSH
64750: LD_VAR 0 3
64754: PPUSH
64755: LD_VAR 0 4
64759: PPUSH
64760: LD_VAR 0 5
64764: PUSH
64765: LD_INT 1
64767: ARRAY
64768: PPUSH
64769: CALL_OW 248
64773: PPUSH
64774: LD_INT 0
64776: PPUSH
64777: CALL 66802 0 6
64781: ST_TO_ADDR
// if not hexes then
64782: LD_VAR 0 14
64786: NOT
64787: IFFALSE 64791
// exit ;
64789: GO 65549
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64791: LD_ADDR_VAR 0 17
64795: PUSH
64796: LD_VAR 0 5
64800: PPUSH
64801: LD_INT 22
64803: PUSH
64804: LD_VAR 0 13
64808: PPUSH
64809: CALL_OW 255
64813: PUSH
64814: EMPTY
64815: LIST
64816: LIST
64817: PUSH
64818: LD_INT 2
64820: PUSH
64821: LD_INT 30
64823: PUSH
64824: LD_INT 0
64826: PUSH
64827: EMPTY
64828: LIST
64829: LIST
64830: PUSH
64831: LD_INT 30
64833: PUSH
64834: LD_INT 1
64836: PUSH
64837: EMPTY
64838: LIST
64839: LIST
64840: PUSH
64841: EMPTY
64842: LIST
64843: LIST
64844: LIST
64845: PUSH
64846: EMPTY
64847: LIST
64848: LIST
64849: PPUSH
64850: CALL_OW 72
64854: ST_TO_ADDR
// for i = 1 to hexes do
64855: LD_ADDR_VAR 0 9
64859: PUSH
64860: DOUBLE
64861: LD_INT 1
64863: DEC
64864: ST_TO_ADDR
64865: LD_VAR 0 14
64869: PUSH
64870: FOR_TO
64871: IFFALSE 65547
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64873: LD_ADDR_VAR 0 13
64877: PUSH
64878: LD_VAR 0 14
64882: PUSH
64883: LD_VAR 0 9
64887: ARRAY
64888: PUSH
64889: LD_INT 1
64891: ARRAY
64892: PPUSH
64893: LD_VAR 0 14
64897: PUSH
64898: LD_VAR 0 9
64902: ARRAY
64903: PUSH
64904: LD_INT 2
64906: ARRAY
64907: PPUSH
64908: CALL_OW 428
64912: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64913: LD_VAR 0 14
64917: PUSH
64918: LD_VAR 0 9
64922: ARRAY
64923: PUSH
64924: LD_INT 1
64926: ARRAY
64927: PPUSH
64928: LD_VAR 0 14
64932: PUSH
64933: LD_VAR 0 9
64937: ARRAY
64938: PUSH
64939: LD_INT 2
64941: ARRAY
64942: PPUSH
64943: CALL_OW 351
64947: PUSH
64948: LD_VAR 0 14
64952: PUSH
64953: LD_VAR 0 9
64957: ARRAY
64958: PUSH
64959: LD_INT 1
64961: ARRAY
64962: PPUSH
64963: LD_VAR 0 14
64967: PUSH
64968: LD_VAR 0 9
64972: ARRAY
64973: PUSH
64974: LD_INT 2
64976: ARRAY
64977: PPUSH
64978: CALL_OW 488
64982: NOT
64983: OR
64984: PUSH
64985: LD_VAR 0 13
64989: PPUSH
64990: CALL_OW 247
64994: PUSH
64995: LD_INT 3
64997: EQUAL
64998: OR
64999: IFFALSE 65005
// exit ;
65001: POP
65002: POP
65003: GO 65549
// if not tmp then
65005: LD_VAR 0 13
65009: NOT
65010: IFFALSE 65014
// continue ;
65012: GO 64870
// result := true ;
65014: LD_ADDR_VAR 0 8
65018: PUSH
65019: LD_INT 1
65021: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
65022: LD_VAR 0 6
65026: PUSH
65027: LD_VAR 0 13
65031: PPUSH
65032: CALL_OW 247
65036: PUSH
65037: LD_INT 2
65039: EQUAL
65040: AND
65041: PUSH
65042: LD_VAR 0 13
65046: PPUSH
65047: CALL_OW 263
65051: PUSH
65052: LD_INT 1
65054: EQUAL
65055: AND
65056: IFFALSE 65220
// begin if IsDrivenBy ( tmp ) then
65058: LD_VAR 0 13
65062: PPUSH
65063: CALL_OW 311
65067: IFFALSE 65071
// continue ;
65069: GO 64870
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
65071: LD_VAR 0 6
65075: PPUSH
65076: LD_INT 3
65078: PUSH
65079: LD_INT 60
65081: PUSH
65082: EMPTY
65083: LIST
65084: PUSH
65085: EMPTY
65086: LIST
65087: LIST
65088: PUSH
65089: LD_INT 3
65091: PUSH
65092: LD_INT 55
65094: PUSH
65095: EMPTY
65096: LIST
65097: PUSH
65098: EMPTY
65099: LIST
65100: LIST
65101: PUSH
65102: EMPTY
65103: LIST
65104: LIST
65105: PPUSH
65106: CALL_OW 72
65110: IFFALSE 65218
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
65112: LD_ADDR_VAR 0 18
65116: PUSH
65117: LD_VAR 0 6
65121: PPUSH
65122: LD_INT 3
65124: PUSH
65125: LD_INT 60
65127: PUSH
65128: EMPTY
65129: LIST
65130: PUSH
65131: EMPTY
65132: LIST
65133: LIST
65134: PUSH
65135: LD_INT 3
65137: PUSH
65138: LD_INT 55
65140: PUSH
65141: EMPTY
65142: LIST
65143: PUSH
65144: EMPTY
65145: LIST
65146: LIST
65147: PUSH
65148: EMPTY
65149: LIST
65150: LIST
65151: PPUSH
65152: CALL_OW 72
65156: PUSH
65157: LD_INT 1
65159: ARRAY
65160: ST_TO_ADDR
// if IsInUnit ( driver ) then
65161: LD_VAR 0 18
65165: PPUSH
65166: CALL_OW 310
65170: IFFALSE 65181
// ComExit ( driver ) ;
65172: LD_VAR 0 18
65176: PPUSH
65177: CALL 90581 0 1
// AddComEnterUnit ( driver , tmp ) ;
65181: LD_VAR 0 18
65185: PPUSH
65186: LD_VAR 0 13
65190: PPUSH
65191: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
65195: LD_VAR 0 18
65199: PPUSH
65200: LD_VAR 0 7
65204: PPUSH
65205: CALL_OW 173
// AddComExitVehicle ( driver ) ;
65209: LD_VAR 0 18
65213: PPUSH
65214: CALL_OW 181
// end ; continue ;
65218: GO 64870
// end ; if not cleaners or not tmp in cleaners then
65220: LD_VAR 0 6
65224: NOT
65225: PUSH
65226: LD_VAR 0 13
65230: PUSH
65231: LD_VAR 0 6
65235: IN
65236: NOT
65237: OR
65238: IFFALSE 65545
// begin if dep then
65240: LD_VAR 0 17
65244: IFFALSE 65380
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
65246: LD_ADDR_VAR 0 16
65250: PUSH
65251: LD_VAR 0 17
65255: PUSH
65256: LD_INT 1
65258: ARRAY
65259: PPUSH
65260: CALL_OW 250
65264: PPUSH
65265: LD_VAR 0 17
65269: PUSH
65270: LD_INT 1
65272: ARRAY
65273: PPUSH
65274: CALL_OW 254
65278: PPUSH
65279: LD_INT 5
65281: PPUSH
65282: CALL_OW 272
65286: PUSH
65287: LD_VAR 0 17
65291: PUSH
65292: LD_INT 1
65294: ARRAY
65295: PPUSH
65296: CALL_OW 251
65300: PPUSH
65301: LD_VAR 0 17
65305: PUSH
65306: LD_INT 1
65308: ARRAY
65309: PPUSH
65310: CALL_OW 254
65314: PPUSH
65315: LD_INT 5
65317: PPUSH
65318: CALL_OW 273
65322: PUSH
65323: EMPTY
65324: LIST
65325: LIST
65326: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
65327: LD_VAR 0 16
65331: PUSH
65332: LD_INT 1
65334: ARRAY
65335: PPUSH
65336: LD_VAR 0 16
65340: PUSH
65341: LD_INT 2
65343: ARRAY
65344: PPUSH
65345: CALL_OW 488
65349: IFFALSE 65380
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
65351: LD_VAR 0 13
65355: PPUSH
65356: LD_VAR 0 16
65360: PUSH
65361: LD_INT 1
65363: ARRAY
65364: PPUSH
65365: LD_VAR 0 16
65369: PUSH
65370: LD_INT 2
65372: ARRAY
65373: PPUSH
65374: CALL_OW 111
// continue ;
65378: GO 64870
// end ; end ; r := GetDir ( tmp ) ;
65380: LD_ADDR_VAR 0 15
65384: PUSH
65385: LD_VAR 0 13
65389: PPUSH
65390: CALL_OW 254
65394: ST_TO_ADDR
// if r = 5 then
65395: LD_VAR 0 15
65399: PUSH
65400: LD_INT 5
65402: EQUAL
65403: IFFALSE 65413
// r := 0 ;
65405: LD_ADDR_VAR 0 15
65409: PUSH
65410: LD_INT 0
65412: ST_TO_ADDR
// for j = r to 5 do
65413: LD_ADDR_VAR 0 10
65417: PUSH
65418: DOUBLE
65419: LD_VAR 0 15
65423: DEC
65424: ST_TO_ADDR
65425: LD_INT 5
65427: PUSH
65428: FOR_TO
65429: IFFALSE 65543
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
65431: LD_ADDR_VAR 0 11
65435: PUSH
65436: LD_VAR 0 13
65440: PPUSH
65441: CALL_OW 250
65445: PPUSH
65446: LD_VAR 0 10
65450: PPUSH
65451: LD_INT 2
65453: PPUSH
65454: CALL_OW 272
65458: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
65459: LD_ADDR_VAR 0 12
65463: PUSH
65464: LD_VAR 0 13
65468: PPUSH
65469: CALL_OW 251
65473: PPUSH
65474: LD_VAR 0 10
65478: PPUSH
65479: LD_INT 2
65481: PPUSH
65482: CALL_OW 273
65486: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
65487: LD_VAR 0 11
65491: PPUSH
65492: LD_VAR 0 12
65496: PPUSH
65497: CALL_OW 488
65501: PUSH
65502: LD_VAR 0 11
65506: PPUSH
65507: LD_VAR 0 12
65511: PPUSH
65512: CALL_OW 428
65516: NOT
65517: AND
65518: IFFALSE 65541
// begin ComMoveXY ( tmp , _x , _y ) ;
65520: LD_VAR 0 13
65524: PPUSH
65525: LD_VAR 0 11
65529: PPUSH
65530: LD_VAR 0 12
65534: PPUSH
65535: CALL_OW 111
// break ;
65539: GO 65543
// end ; end ;
65541: GO 65428
65543: POP
65544: POP
// end ; end ;
65545: GO 64870
65547: POP
65548: POP
// end ;
65549: LD_VAR 0 8
65553: RET
// export function BuildingTechInvented ( side , btype ) ; begin
65554: LD_INT 0
65556: PPUSH
// result := true ;
65557: LD_ADDR_VAR 0 3
65561: PUSH
65562: LD_INT 1
65564: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
65565: LD_VAR 0 2
65569: PUSH
65570: LD_INT 24
65572: DOUBLE
65573: EQUAL
65574: IFTRUE 65584
65576: LD_INT 33
65578: DOUBLE
65579: EQUAL
65580: IFTRUE 65584
65582: GO 65609
65584: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
65585: LD_ADDR_VAR 0 3
65589: PUSH
65590: LD_INT 32
65592: PPUSH
65593: LD_VAR 0 1
65597: PPUSH
65598: CALL_OW 321
65602: PUSH
65603: LD_INT 2
65605: EQUAL
65606: ST_TO_ADDR
65607: GO 65925
65609: LD_INT 20
65611: DOUBLE
65612: EQUAL
65613: IFTRUE 65617
65615: GO 65642
65617: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
65618: LD_ADDR_VAR 0 3
65622: PUSH
65623: LD_INT 6
65625: PPUSH
65626: LD_VAR 0 1
65630: PPUSH
65631: CALL_OW 321
65635: PUSH
65636: LD_INT 2
65638: EQUAL
65639: ST_TO_ADDR
65640: GO 65925
65642: LD_INT 22
65644: DOUBLE
65645: EQUAL
65646: IFTRUE 65656
65648: LD_INT 36
65650: DOUBLE
65651: EQUAL
65652: IFTRUE 65656
65654: GO 65681
65656: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
65657: LD_ADDR_VAR 0 3
65661: PUSH
65662: LD_INT 15
65664: PPUSH
65665: LD_VAR 0 1
65669: PPUSH
65670: CALL_OW 321
65674: PUSH
65675: LD_INT 2
65677: EQUAL
65678: ST_TO_ADDR
65679: GO 65925
65681: LD_INT 30
65683: DOUBLE
65684: EQUAL
65685: IFTRUE 65689
65687: GO 65714
65689: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
65690: LD_ADDR_VAR 0 3
65694: PUSH
65695: LD_INT 20
65697: PPUSH
65698: LD_VAR 0 1
65702: PPUSH
65703: CALL_OW 321
65707: PUSH
65708: LD_INT 2
65710: EQUAL
65711: ST_TO_ADDR
65712: GO 65925
65714: LD_INT 28
65716: DOUBLE
65717: EQUAL
65718: IFTRUE 65728
65720: LD_INT 21
65722: DOUBLE
65723: EQUAL
65724: IFTRUE 65728
65726: GO 65753
65728: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
65729: LD_ADDR_VAR 0 3
65733: PUSH
65734: LD_INT 21
65736: PPUSH
65737: LD_VAR 0 1
65741: PPUSH
65742: CALL_OW 321
65746: PUSH
65747: LD_INT 2
65749: EQUAL
65750: ST_TO_ADDR
65751: GO 65925
65753: LD_INT 16
65755: DOUBLE
65756: EQUAL
65757: IFTRUE 65761
65759: GO 65786
65761: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
65762: LD_ADDR_VAR 0 3
65766: PUSH
65767: LD_INT 84
65769: PPUSH
65770: LD_VAR 0 1
65774: PPUSH
65775: CALL_OW 321
65779: PUSH
65780: LD_INT 2
65782: EQUAL
65783: ST_TO_ADDR
65784: GO 65925
65786: LD_INT 19
65788: DOUBLE
65789: EQUAL
65790: IFTRUE 65800
65792: LD_INT 23
65794: DOUBLE
65795: EQUAL
65796: IFTRUE 65800
65798: GO 65825
65800: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
65801: LD_ADDR_VAR 0 3
65805: PUSH
65806: LD_INT 83
65808: PPUSH
65809: LD_VAR 0 1
65813: PPUSH
65814: CALL_OW 321
65818: PUSH
65819: LD_INT 2
65821: EQUAL
65822: ST_TO_ADDR
65823: GO 65925
65825: LD_INT 17
65827: DOUBLE
65828: EQUAL
65829: IFTRUE 65833
65831: GO 65858
65833: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65834: LD_ADDR_VAR 0 3
65838: PUSH
65839: LD_INT 39
65841: PPUSH
65842: LD_VAR 0 1
65846: PPUSH
65847: CALL_OW 321
65851: PUSH
65852: LD_INT 2
65854: EQUAL
65855: ST_TO_ADDR
65856: GO 65925
65858: LD_INT 18
65860: DOUBLE
65861: EQUAL
65862: IFTRUE 65866
65864: GO 65891
65866: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65867: LD_ADDR_VAR 0 3
65871: PUSH
65872: LD_INT 40
65874: PPUSH
65875: LD_VAR 0 1
65879: PPUSH
65880: CALL_OW 321
65884: PUSH
65885: LD_INT 2
65887: EQUAL
65888: ST_TO_ADDR
65889: GO 65925
65891: LD_INT 27
65893: DOUBLE
65894: EQUAL
65895: IFTRUE 65899
65897: GO 65924
65899: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65900: LD_ADDR_VAR 0 3
65904: PUSH
65905: LD_INT 35
65907: PPUSH
65908: LD_VAR 0 1
65912: PPUSH
65913: CALL_OW 321
65917: PUSH
65918: LD_INT 2
65920: EQUAL
65921: ST_TO_ADDR
65922: GO 65925
65924: POP
// end ;
65925: LD_VAR 0 3
65929: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65930: LD_INT 0
65932: PPUSH
65933: PPUSH
65934: PPUSH
65935: PPUSH
65936: PPUSH
65937: PPUSH
65938: PPUSH
65939: PPUSH
65940: PPUSH
65941: PPUSH
65942: PPUSH
// result := false ;
65943: LD_ADDR_VAR 0 6
65947: PUSH
65948: LD_INT 0
65950: ST_TO_ADDR
// if btype = b_depot then
65951: LD_VAR 0 2
65955: PUSH
65956: LD_INT 0
65958: EQUAL
65959: IFFALSE 65971
// begin result := true ;
65961: LD_ADDR_VAR 0 6
65965: PUSH
65966: LD_INT 1
65968: ST_TO_ADDR
// exit ;
65969: GO 66797
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65971: LD_VAR 0 1
65975: NOT
65976: PUSH
65977: LD_VAR 0 1
65981: PPUSH
65982: CALL_OW 266
65986: PUSH
65987: LD_INT 0
65989: PUSH
65990: LD_INT 1
65992: PUSH
65993: EMPTY
65994: LIST
65995: LIST
65996: IN
65997: NOT
65998: OR
65999: PUSH
66000: LD_VAR 0 2
66004: NOT
66005: OR
66006: PUSH
66007: LD_VAR 0 5
66011: PUSH
66012: LD_INT 0
66014: PUSH
66015: LD_INT 1
66017: PUSH
66018: LD_INT 2
66020: PUSH
66021: LD_INT 3
66023: PUSH
66024: LD_INT 4
66026: PUSH
66027: LD_INT 5
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: LIST
66034: LIST
66035: LIST
66036: LIST
66037: IN
66038: NOT
66039: OR
66040: PUSH
66041: LD_VAR 0 3
66045: PPUSH
66046: LD_VAR 0 4
66050: PPUSH
66051: CALL_OW 488
66055: NOT
66056: OR
66057: IFFALSE 66061
// exit ;
66059: GO 66797
// side := GetSide ( depot ) ;
66061: LD_ADDR_VAR 0 9
66065: PUSH
66066: LD_VAR 0 1
66070: PPUSH
66071: CALL_OW 255
66075: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
66076: LD_VAR 0 9
66080: PPUSH
66081: LD_VAR 0 2
66085: PPUSH
66086: CALL 65554 0 2
66090: NOT
66091: IFFALSE 66095
// exit ;
66093: GO 66797
// pom := GetBase ( depot ) ;
66095: LD_ADDR_VAR 0 10
66099: PUSH
66100: LD_VAR 0 1
66104: PPUSH
66105: CALL_OW 274
66109: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
66110: LD_ADDR_VAR 0 11
66114: PUSH
66115: LD_VAR 0 2
66119: PPUSH
66120: LD_VAR 0 1
66124: PPUSH
66125: CALL_OW 248
66129: PPUSH
66130: CALL_OW 450
66134: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
66135: LD_VAR 0 10
66139: PPUSH
66140: LD_INT 1
66142: PPUSH
66143: CALL_OW 275
66147: PUSH
66148: LD_VAR 0 11
66152: PUSH
66153: LD_INT 1
66155: ARRAY
66156: GREATEREQUAL
66157: PUSH
66158: LD_VAR 0 10
66162: PPUSH
66163: LD_INT 2
66165: PPUSH
66166: CALL_OW 275
66170: PUSH
66171: LD_VAR 0 11
66175: PUSH
66176: LD_INT 2
66178: ARRAY
66179: GREATEREQUAL
66180: AND
66181: PUSH
66182: LD_VAR 0 10
66186: PPUSH
66187: LD_INT 3
66189: PPUSH
66190: CALL_OW 275
66194: PUSH
66195: LD_VAR 0 11
66199: PUSH
66200: LD_INT 3
66202: ARRAY
66203: GREATEREQUAL
66204: AND
66205: NOT
66206: IFFALSE 66210
// exit ;
66208: GO 66797
// if GetBType ( depot ) = b_depot then
66210: LD_VAR 0 1
66214: PPUSH
66215: CALL_OW 266
66219: PUSH
66220: LD_INT 0
66222: EQUAL
66223: IFFALSE 66235
// dist := 28 else
66225: LD_ADDR_VAR 0 14
66229: PUSH
66230: LD_INT 28
66232: ST_TO_ADDR
66233: GO 66243
// dist := 36 ;
66235: LD_ADDR_VAR 0 14
66239: PUSH
66240: LD_INT 36
66242: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
66243: LD_VAR 0 1
66247: PPUSH
66248: LD_VAR 0 3
66252: PPUSH
66253: LD_VAR 0 4
66257: PPUSH
66258: CALL_OW 297
66262: PUSH
66263: LD_VAR 0 14
66267: GREATER
66268: IFFALSE 66272
// exit ;
66270: GO 66797
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
66272: LD_ADDR_VAR 0 12
66276: PUSH
66277: LD_VAR 0 2
66281: PPUSH
66282: LD_VAR 0 3
66286: PPUSH
66287: LD_VAR 0 4
66291: PPUSH
66292: LD_VAR 0 5
66296: PPUSH
66297: LD_VAR 0 1
66301: PPUSH
66302: CALL_OW 248
66306: PPUSH
66307: LD_INT 0
66309: PPUSH
66310: CALL 66802 0 6
66314: ST_TO_ADDR
// if not hexes then
66315: LD_VAR 0 12
66319: NOT
66320: IFFALSE 66324
// exit ;
66322: GO 66797
// hex := GetHexInfo ( x , y ) ;
66324: LD_ADDR_VAR 0 15
66328: PUSH
66329: LD_VAR 0 3
66333: PPUSH
66334: LD_VAR 0 4
66338: PPUSH
66339: CALL_OW 546
66343: ST_TO_ADDR
// if hex [ 1 ] then
66344: LD_VAR 0 15
66348: PUSH
66349: LD_INT 1
66351: ARRAY
66352: IFFALSE 66356
// exit ;
66354: GO 66797
// height := hex [ 2 ] ;
66356: LD_ADDR_VAR 0 13
66360: PUSH
66361: LD_VAR 0 15
66365: PUSH
66366: LD_INT 2
66368: ARRAY
66369: ST_TO_ADDR
// for i = 1 to hexes do
66370: LD_ADDR_VAR 0 7
66374: PUSH
66375: DOUBLE
66376: LD_INT 1
66378: DEC
66379: ST_TO_ADDR
66380: LD_VAR 0 12
66384: PUSH
66385: FOR_TO
66386: IFFALSE 66716
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
66388: LD_VAR 0 12
66392: PUSH
66393: LD_VAR 0 7
66397: ARRAY
66398: PUSH
66399: LD_INT 1
66401: ARRAY
66402: PPUSH
66403: LD_VAR 0 12
66407: PUSH
66408: LD_VAR 0 7
66412: ARRAY
66413: PUSH
66414: LD_INT 2
66416: ARRAY
66417: PPUSH
66418: CALL_OW 488
66422: NOT
66423: PUSH
66424: LD_VAR 0 12
66428: PUSH
66429: LD_VAR 0 7
66433: ARRAY
66434: PUSH
66435: LD_INT 1
66437: ARRAY
66438: PPUSH
66439: LD_VAR 0 12
66443: PUSH
66444: LD_VAR 0 7
66448: ARRAY
66449: PUSH
66450: LD_INT 2
66452: ARRAY
66453: PPUSH
66454: CALL_OW 428
66458: PUSH
66459: LD_INT 0
66461: GREATER
66462: OR
66463: PUSH
66464: LD_VAR 0 12
66468: PUSH
66469: LD_VAR 0 7
66473: ARRAY
66474: PUSH
66475: LD_INT 1
66477: ARRAY
66478: PPUSH
66479: LD_VAR 0 12
66483: PUSH
66484: LD_VAR 0 7
66488: ARRAY
66489: PUSH
66490: LD_INT 2
66492: ARRAY
66493: PPUSH
66494: CALL_OW 351
66498: OR
66499: IFFALSE 66505
// exit ;
66501: POP
66502: POP
66503: GO 66797
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
66505: LD_ADDR_VAR 0 8
66509: PUSH
66510: LD_VAR 0 12
66514: PUSH
66515: LD_VAR 0 7
66519: ARRAY
66520: PUSH
66521: LD_INT 1
66523: ARRAY
66524: PPUSH
66525: LD_VAR 0 12
66529: PUSH
66530: LD_VAR 0 7
66534: ARRAY
66535: PUSH
66536: LD_INT 2
66538: ARRAY
66539: PPUSH
66540: CALL_OW 546
66544: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
66545: LD_VAR 0 8
66549: PUSH
66550: LD_INT 1
66552: ARRAY
66553: PUSH
66554: LD_VAR 0 8
66558: PUSH
66559: LD_INT 2
66561: ARRAY
66562: PUSH
66563: LD_VAR 0 13
66567: PUSH
66568: LD_INT 2
66570: PLUS
66571: GREATER
66572: OR
66573: PUSH
66574: LD_VAR 0 8
66578: PUSH
66579: LD_INT 2
66581: ARRAY
66582: PUSH
66583: LD_VAR 0 13
66587: PUSH
66588: LD_INT 2
66590: MINUS
66591: LESS
66592: OR
66593: PUSH
66594: LD_VAR 0 8
66598: PUSH
66599: LD_INT 3
66601: ARRAY
66602: PUSH
66603: LD_INT 0
66605: PUSH
66606: LD_INT 8
66608: PUSH
66609: LD_INT 9
66611: PUSH
66612: LD_INT 10
66614: PUSH
66615: LD_INT 11
66617: PUSH
66618: LD_INT 12
66620: PUSH
66621: LD_INT 13
66623: PUSH
66624: LD_INT 16
66626: PUSH
66627: LD_INT 17
66629: PUSH
66630: LD_INT 18
66632: PUSH
66633: LD_INT 19
66635: PUSH
66636: LD_INT 20
66638: PUSH
66639: LD_INT 21
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: IN
66657: NOT
66658: OR
66659: PUSH
66660: LD_VAR 0 8
66664: PUSH
66665: LD_INT 5
66667: ARRAY
66668: NOT
66669: OR
66670: PUSH
66671: LD_VAR 0 8
66675: PUSH
66676: LD_INT 6
66678: ARRAY
66679: PUSH
66680: LD_INT 1
66682: PUSH
66683: LD_INT 2
66685: PUSH
66686: LD_INT 7
66688: PUSH
66689: LD_INT 9
66691: PUSH
66692: LD_INT 10
66694: PUSH
66695: LD_INT 11
66697: PUSH
66698: EMPTY
66699: LIST
66700: LIST
66701: LIST
66702: LIST
66703: LIST
66704: LIST
66705: IN
66706: NOT
66707: OR
66708: IFFALSE 66714
// exit ;
66710: POP
66711: POP
66712: GO 66797
// end ;
66714: GO 66385
66716: POP
66717: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66718: LD_VAR 0 9
66722: PPUSH
66723: LD_VAR 0 3
66727: PPUSH
66728: LD_VAR 0 4
66732: PPUSH
66733: LD_INT 20
66735: PPUSH
66736: CALL 58720 0 4
66740: PUSH
66741: LD_INT 4
66743: ARRAY
66744: IFFALSE 66748
// exit ;
66746: GO 66797
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
66748: LD_VAR 0 2
66752: PUSH
66753: LD_INT 29
66755: PUSH
66756: LD_INT 30
66758: PUSH
66759: EMPTY
66760: LIST
66761: LIST
66762: IN
66763: PUSH
66764: LD_VAR 0 3
66768: PPUSH
66769: LD_VAR 0 4
66773: PPUSH
66774: LD_VAR 0 9
66778: PPUSH
66779: CALL_OW 440
66783: NOT
66784: AND
66785: IFFALSE 66789
// exit ;
66787: GO 66797
// result := true ;
66789: LD_ADDR_VAR 0 6
66793: PUSH
66794: LD_INT 1
66796: ST_TO_ADDR
// end ;
66797: LD_VAR 0 6
66801: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
66802: LD_INT 0
66804: PPUSH
66805: PPUSH
66806: PPUSH
66807: PPUSH
66808: PPUSH
66809: PPUSH
66810: PPUSH
66811: PPUSH
66812: PPUSH
66813: PPUSH
66814: PPUSH
66815: PPUSH
66816: PPUSH
66817: PPUSH
66818: PPUSH
66819: PPUSH
66820: PPUSH
66821: PPUSH
66822: PPUSH
66823: PPUSH
66824: PPUSH
66825: PPUSH
66826: PPUSH
66827: PPUSH
66828: PPUSH
66829: PPUSH
66830: PPUSH
66831: PPUSH
66832: PPUSH
66833: PPUSH
66834: PPUSH
66835: PPUSH
66836: PPUSH
66837: PPUSH
66838: PPUSH
66839: PPUSH
66840: PPUSH
66841: PPUSH
66842: PPUSH
66843: PPUSH
66844: PPUSH
66845: PPUSH
66846: PPUSH
66847: PPUSH
66848: PPUSH
66849: PPUSH
66850: PPUSH
66851: PPUSH
66852: PPUSH
66853: PPUSH
66854: PPUSH
66855: PPUSH
66856: PPUSH
66857: PPUSH
66858: PPUSH
66859: PPUSH
66860: PPUSH
66861: PPUSH
// result = [ ] ;
66862: LD_ADDR_VAR 0 7
66866: PUSH
66867: EMPTY
66868: ST_TO_ADDR
// temp_list = [ ] ;
66869: LD_ADDR_VAR 0 9
66873: PUSH
66874: EMPTY
66875: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66876: LD_VAR 0 4
66880: PUSH
66881: LD_INT 0
66883: PUSH
66884: LD_INT 1
66886: PUSH
66887: LD_INT 2
66889: PUSH
66890: LD_INT 3
66892: PUSH
66893: LD_INT 4
66895: PUSH
66896: LD_INT 5
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: LIST
66903: LIST
66904: LIST
66905: LIST
66906: IN
66907: NOT
66908: PUSH
66909: LD_VAR 0 1
66913: PUSH
66914: LD_INT 0
66916: PUSH
66917: LD_INT 1
66919: PUSH
66920: EMPTY
66921: LIST
66922: LIST
66923: IN
66924: PUSH
66925: LD_VAR 0 5
66929: PUSH
66930: LD_INT 1
66932: PUSH
66933: LD_INT 2
66935: PUSH
66936: LD_INT 3
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: LIST
66943: IN
66944: NOT
66945: AND
66946: OR
66947: IFFALSE 66951
// exit ;
66949: GO 85342
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66951: LD_VAR 0 1
66955: PUSH
66956: LD_INT 6
66958: PUSH
66959: LD_INT 7
66961: PUSH
66962: LD_INT 8
66964: PUSH
66965: LD_INT 13
66967: PUSH
66968: LD_INT 12
66970: PUSH
66971: LD_INT 15
66973: PUSH
66974: LD_INT 11
66976: PUSH
66977: LD_INT 14
66979: PUSH
66980: LD_INT 10
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: LIST
66987: LIST
66988: LIST
66989: LIST
66990: LIST
66991: LIST
66992: LIST
66993: IN
66994: IFFALSE 67004
// btype = b_lab ;
66996: LD_ADDR_VAR 0 1
67000: PUSH
67001: LD_INT 6
67003: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
67004: LD_VAR 0 6
67008: PUSH
67009: LD_INT 0
67011: PUSH
67012: LD_INT 1
67014: PUSH
67015: LD_INT 2
67017: PUSH
67018: EMPTY
67019: LIST
67020: LIST
67021: LIST
67022: IN
67023: NOT
67024: PUSH
67025: LD_VAR 0 1
67029: PUSH
67030: LD_INT 0
67032: PUSH
67033: LD_INT 1
67035: PUSH
67036: LD_INT 2
67038: PUSH
67039: LD_INT 3
67041: PUSH
67042: LD_INT 6
67044: PUSH
67045: LD_INT 36
67047: PUSH
67048: LD_INT 4
67050: PUSH
67051: LD_INT 5
67053: PUSH
67054: LD_INT 31
67056: PUSH
67057: LD_INT 32
67059: PUSH
67060: LD_INT 33
67062: PUSH
67063: EMPTY
67064: LIST
67065: LIST
67066: LIST
67067: LIST
67068: LIST
67069: LIST
67070: LIST
67071: LIST
67072: LIST
67073: LIST
67074: LIST
67075: IN
67076: NOT
67077: PUSH
67078: LD_VAR 0 6
67082: PUSH
67083: LD_INT 1
67085: EQUAL
67086: AND
67087: OR
67088: PUSH
67089: LD_VAR 0 1
67093: PUSH
67094: LD_INT 2
67096: PUSH
67097: LD_INT 3
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: IN
67104: NOT
67105: PUSH
67106: LD_VAR 0 6
67110: PUSH
67111: LD_INT 2
67113: EQUAL
67114: AND
67115: OR
67116: IFFALSE 67126
// mode = 0 ;
67118: LD_ADDR_VAR 0 6
67122: PUSH
67123: LD_INT 0
67125: ST_TO_ADDR
// case mode of 0 :
67126: LD_VAR 0 6
67130: PUSH
67131: LD_INT 0
67133: DOUBLE
67134: EQUAL
67135: IFTRUE 67139
67137: GO 78592
67139: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67140: LD_ADDR_VAR 0 11
67144: PUSH
67145: LD_INT 0
67147: PUSH
67148: LD_INT 0
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: LD_INT 0
67157: PUSH
67158: LD_INT 1
67160: NEG
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 1
67168: PUSH
67169: LD_INT 0
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: LD_INT 1
67178: PUSH
67179: LD_INT 1
67181: PUSH
67182: EMPTY
67183: LIST
67184: LIST
67185: PUSH
67186: LD_INT 0
67188: PUSH
67189: LD_INT 1
67191: PUSH
67192: EMPTY
67193: LIST
67194: LIST
67195: PUSH
67196: LD_INT 1
67198: NEG
67199: PUSH
67200: LD_INT 0
67202: PUSH
67203: EMPTY
67204: LIST
67205: LIST
67206: PUSH
67207: LD_INT 1
67209: NEG
67210: PUSH
67211: LD_INT 1
67213: NEG
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: PUSH
67219: LD_INT 1
67221: NEG
67222: PUSH
67223: LD_INT 2
67225: NEG
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: PUSH
67231: LD_INT 0
67233: PUSH
67234: LD_INT 2
67236: NEG
67237: PUSH
67238: EMPTY
67239: LIST
67240: LIST
67241: PUSH
67242: LD_INT 1
67244: PUSH
67245: LD_INT 1
67247: NEG
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: PUSH
67253: LD_INT 1
67255: PUSH
67256: LD_INT 2
67258: PUSH
67259: EMPTY
67260: LIST
67261: LIST
67262: PUSH
67263: LD_INT 0
67265: PUSH
67266: LD_INT 2
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 1
67275: NEG
67276: PUSH
67277: LD_INT 1
67279: PUSH
67280: EMPTY
67281: LIST
67282: LIST
67283: PUSH
67284: LD_INT 1
67286: PUSH
67287: LD_INT 3
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: LD_INT 0
67296: PUSH
67297: LD_INT 3
67299: PUSH
67300: EMPTY
67301: LIST
67302: LIST
67303: PUSH
67304: LD_INT 1
67306: NEG
67307: PUSH
67308: LD_INT 2
67310: PUSH
67311: EMPTY
67312: LIST
67313: LIST
67314: PUSH
67315: EMPTY
67316: LIST
67317: LIST
67318: LIST
67319: LIST
67320: LIST
67321: LIST
67322: LIST
67323: LIST
67324: LIST
67325: LIST
67326: LIST
67327: LIST
67328: LIST
67329: LIST
67330: LIST
67331: LIST
67332: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67333: LD_ADDR_VAR 0 12
67337: PUSH
67338: LD_INT 0
67340: PUSH
67341: LD_INT 0
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: PUSH
67348: LD_INT 0
67350: PUSH
67351: LD_INT 1
67353: NEG
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: LD_INT 1
67361: PUSH
67362: LD_INT 0
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: PUSH
67369: LD_INT 1
67371: PUSH
67372: LD_INT 1
67374: PUSH
67375: EMPTY
67376: LIST
67377: LIST
67378: PUSH
67379: LD_INT 0
67381: PUSH
67382: LD_INT 1
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: PUSH
67389: LD_INT 1
67391: NEG
67392: PUSH
67393: LD_INT 0
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 1
67402: NEG
67403: PUSH
67404: LD_INT 1
67406: NEG
67407: PUSH
67408: EMPTY
67409: LIST
67410: LIST
67411: PUSH
67412: LD_INT 1
67414: PUSH
67415: LD_INT 1
67417: NEG
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: PUSH
67423: LD_INT 2
67425: PUSH
67426: LD_INT 0
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: PUSH
67433: LD_INT 2
67435: PUSH
67436: LD_INT 1
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: LD_INT 1
67445: NEG
67446: PUSH
67447: LD_INT 1
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: PUSH
67454: LD_INT 2
67456: NEG
67457: PUSH
67458: LD_INT 0
67460: PUSH
67461: EMPTY
67462: LIST
67463: LIST
67464: PUSH
67465: LD_INT 2
67467: NEG
67468: PUSH
67469: LD_INT 1
67471: NEG
67472: PUSH
67473: EMPTY
67474: LIST
67475: LIST
67476: PUSH
67477: LD_INT 2
67479: NEG
67480: PUSH
67481: LD_INT 1
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: PUSH
67488: LD_INT 3
67490: NEG
67491: PUSH
67492: LD_INT 0
67494: PUSH
67495: EMPTY
67496: LIST
67497: LIST
67498: PUSH
67499: LD_INT 3
67501: NEG
67502: PUSH
67503: LD_INT 1
67505: NEG
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: LIST
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: LIST
67520: LIST
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: LIST
67527: LIST
67528: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67529: LD_ADDR_VAR 0 13
67533: PUSH
67534: LD_INT 0
67536: PUSH
67537: LD_INT 0
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 0
67546: PUSH
67547: LD_INT 1
67549: NEG
67550: PUSH
67551: EMPTY
67552: LIST
67553: LIST
67554: PUSH
67555: LD_INT 1
67557: PUSH
67558: LD_INT 0
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 1
67567: PUSH
67568: LD_INT 1
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: LD_INT 0
67577: PUSH
67578: LD_INT 1
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 1
67587: NEG
67588: PUSH
67589: LD_INT 0
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: LD_INT 1
67598: NEG
67599: PUSH
67600: LD_INT 1
67602: NEG
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 1
67610: NEG
67611: PUSH
67612: LD_INT 2
67614: NEG
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: PUSH
67620: LD_INT 2
67622: PUSH
67623: LD_INT 1
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 2
67632: PUSH
67633: LD_INT 2
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 1
67642: PUSH
67643: LD_INT 2
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: LD_INT 2
67652: NEG
67653: PUSH
67654: LD_INT 1
67656: NEG
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 2
67664: NEG
67665: PUSH
67666: LD_INT 2
67668: NEG
67669: PUSH
67670: EMPTY
67671: LIST
67672: LIST
67673: PUSH
67674: LD_INT 2
67676: NEG
67677: PUSH
67678: LD_INT 3
67680: NEG
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: PUSH
67686: LD_INT 3
67688: NEG
67689: PUSH
67690: LD_INT 2
67692: NEG
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: PUSH
67698: LD_INT 3
67700: NEG
67701: PUSH
67702: LD_INT 3
67704: NEG
67705: PUSH
67706: EMPTY
67707: LIST
67708: LIST
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: LIST
67714: LIST
67715: LIST
67716: LIST
67717: LIST
67718: LIST
67719: LIST
67720: LIST
67721: LIST
67722: LIST
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67728: LD_ADDR_VAR 0 14
67732: PUSH
67733: LD_INT 0
67735: PUSH
67736: LD_INT 0
67738: PUSH
67739: EMPTY
67740: LIST
67741: LIST
67742: PUSH
67743: LD_INT 0
67745: PUSH
67746: LD_INT 1
67748: NEG
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 1
67756: PUSH
67757: LD_INT 0
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PUSH
67764: LD_INT 1
67766: PUSH
67767: LD_INT 1
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: PUSH
67774: LD_INT 0
67776: PUSH
67777: LD_INT 1
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 1
67786: NEG
67787: PUSH
67788: LD_INT 0
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: PUSH
67795: LD_INT 1
67797: NEG
67798: PUSH
67799: LD_INT 1
67801: NEG
67802: PUSH
67803: EMPTY
67804: LIST
67805: LIST
67806: PUSH
67807: LD_INT 1
67809: NEG
67810: PUSH
67811: LD_INT 2
67813: NEG
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 0
67821: PUSH
67822: LD_INT 2
67824: NEG
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PUSH
67830: LD_INT 1
67832: PUSH
67833: LD_INT 1
67835: NEG
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: PUSH
67841: LD_INT 1
67843: PUSH
67844: LD_INT 2
67846: PUSH
67847: EMPTY
67848: LIST
67849: LIST
67850: PUSH
67851: LD_INT 0
67853: PUSH
67854: LD_INT 2
67856: PUSH
67857: EMPTY
67858: LIST
67859: LIST
67860: PUSH
67861: LD_INT 1
67863: NEG
67864: PUSH
67865: LD_INT 1
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: LD_INT 1
67874: NEG
67875: PUSH
67876: LD_INT 3
67878: NEG
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 0
67886: PUSH
67887: LD_INT 3
67889: NEG
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 1
67897: PUSH
67898: LD_INT 2
67900: NEG
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: LIST
67910: LIST
67911: LIST
67912: LIST
67913: LIST
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67924: LD_ADDR_VAR 0 15
67928: PUSH
67929: LD_INT 0
67931: PUSH
67932: LD_INT 0
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: LD_INT 0
67941: PUSH
67942: LD_INT 1
67944: NEG
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 1
67952: PUSH
67953: LD_INT 0
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: PUSH
67960: LD_INT 1
67962: PUSH
67963: LD_INT 1
67965: PUSH
67966: EMPTY
67967: LIST
67968: LIST
67969: PUSH
67970: LD_INT 0
67972: PUSH
67973: LD_INT 1
67975: PUSH
67976: EMPTY
67977: LIST
67978: LIST
67979: PUSH
67980: LD_INT 1
67982: NEG
67983: PUSH
67984: LD_INT 0
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PUSH
67991: LD_INT 1
67993: NEG
67994: PUSH
67995: LD_INT 1
67997: NEG
67998: PUSH
67999: EMPTY
68000: LIST
68001: LIST
68002: PUSH
68003: LD_INT 1
68005: PUSH
68006: LD_INT 1
68008: NEG
68009: PUSH
68010: EMPTY
68011: LIST
68012: LIST
68013: PUSH
68014: LD_INT 2
68016: PUSH
68017: LD_INT 0
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: PUSH
68024: LD_INT 2
68026: PUSH
68027: LD_INT 1
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: PUSH
68034: LD_INT 1
68036: NEG
68037: PUSH
68038: LD_INT 1
68040: PUSH
68041: EMPTY
68042: LIST
68043: LIST
68044: PUSH
68045: LD_INT 2
68047: NEG
68048: PUSH
68049: LD_INT 0
68051: PUSH
68052: EMPTY
68053: LIST
68054: LIST
68055: PUSH
68056: LD_INT 2
68058: NEG
68059: PUSH
68060: LD_INT 1
68062: NEG
68063: PUSH
68064: EMPTY
68065: LIST
68066: LIST
68067: PUSH
68068: LD_INT 2
68070: PUSH
68071: LD_INT 1
68073: NEG
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PUSH
68079: LD_INT 3
68081: PUSH
68082: LD_INT 0
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: PUSH
68089: LD_INT 3
68091: PUSH
68092: LD_INT 1
68094: PUSH
68095: EMPTY
68096: LIST
68097: LIST
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: LIST
68103: LIST
68104: LIST
68105: LIST
68106: LIST
68107: LIST
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: LIST
68116: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
68117: LD_ADDR_VAR 0 16
68121: PUSH
68122: LD_INT 0
68124: PUSH
68125: LD_INT 0
68127: PUSH
68128: EMPTY
68129: LIST
68130: LIST
68131: PUSH
68132: LD_INT 0
68134: PUSH
68135: LD_INT 1
68137: NEG
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PUSH
68143: LD_INT 1
68145: PUSH
68146: LD_INT 0
68148: PUSH
68149: EMPTY
68150: LIST
68151: LIST
68152: PUSH
68153: LD_INT 1
68155: PUSH
68156: LD_INT 1
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PUSH
68163: LD_INT 0
68165: PUSH
68166: LD_INT 1
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: PUSH
68173: LD_INT 1
68175: NEG
68176: PUSH
68177: LD_INT 0
68179: PUSH
68180: EMPTY
68181: LIST
68182: LIST
68183: PUSH
68184: LD_INT 1
68186: NEG
68187: PUSH
68188: LD_INT 1
68190: NEG
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: PUSH
68196: LD_INT 1
68198: NEG
68199: PUSH
68200: LD_INT 2
68202: NEG
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 2
68210: PUSH
68211: LD_INT 1
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 2
68220: PUSH
68221: LD_INT 2
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: LD_INT 1
68230: PUSH
68231: LD_INT 2
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: PUSH
68238: LD_INT 2
68240: NEG
68241: PUSH
68242: LD_INT 1
68244: NEG
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 2
68252: NEG
68253: PUSH
68254: LD_INT 2
68256: NEG
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PUSH
68262: LD_INT 3
68264: PUSH
68265: LD_INT 2
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: LD_INT 3
68274: PUSH
68275: LD_INT 3
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: PUSH
68282: LD_INT 2
68284: PUSH
68285: LD_INT 3
68287: PUSH
68288: EMPTY
68289: LIST
68290: LIST
68291: PUSH
68292: EMPTY
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68310: LD_ADDR_VAR 0 17
68314: PUSH
68315: LD_INT 0
68317: PUSH
68318: LD_INT 0
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: LD_INT 0
68327: PUSH
68328: LD_INT 1
68330: NEG
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 1
68338: PUSH
68339: LD_INT 0
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 1
68348: PUSH
68349: LD_INT 1
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: PUSH
68356: LD_INT 0
68358: PUSH
68359: LD_INT 1
68361: PUSH
68362: EMPTY
68363: LIST
68364: LIST
68365: PUSH
68366: LD_INT 1
68368: NEG
68369: PUSH
68370: LD_INT 0
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: PUSH
68377: LD_INT 1
68379: NEG
68380: PUSH
68381: LD_INT 1
68383: NEG
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: PUSH
68389: LD_INT 1
68391: NEG
68392: PUSH
68393: LD_INT 2
68395: NEG
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 0
68403: PUSH
68404: LD_INT 2
68406: NEG
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 1
68414: PUSH
68415: LD_INT 1
68417: NEG
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 2
68425: PUSH
68426: LD_INT 0
68428: PUSH
68429: EMPTY
68430: LIST
68431: LIST
68432: PUSH
68433: LD_INT 2
68435: PUSH
68436: LD_INT 1
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: LD_INT 2
68445: PUSH
68446: LD_INT 2
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 1
68455: PUSH
68456: LD_INT 2
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PUSH
68463: LD_INT 0
68465: PUSH
68466: LD_INT 2
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: PUSH
68473: LD_INT 1
68475: NEG
68476: PUSH
68477: LD_INT 1
68479: PUSH
68480: EMPTY
68481: LIST
68482: LIST
68483: PUSH
68484: LD_INT 2
68486: NEG
68487: PUSH
68488: LD_INT 0
68490: PUSH
68491: EMPTY
68492: LIST
68493: LIST
68494: PUSH
68495: LD_INT 2
68497: NEG
68498: PUSH
68499: LD_INT 1
68501: NEG
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PUSH
68507: LD_INT 2
68509: NEG
68510: PUSH
68511: LD_INT 2
68513: NEG
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: LIST
68538: LIST
68539: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68540: LD_ADDR_VAR 0 18
68544: PUSH
68545: LD_INT 0
68547: PUSH
68548: LD_INT 0
68550: PUSH
68551: EMPTY
68552: LIST
68553: LIST
68554: PUSH
68555: LD_INT 0
68557: PUSH
68558: LD_INT 1
68560: NEG
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: PUSH
68566: LD_INT 1
68568: PUSH
68569: LD_INT 0
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: LD_INT 1
68578: PUSH
68579: LD_INT 1
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 0
68588: PUSH
68589: LD_INT 1
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: PUSH
68596: LD_INT 1
68598: NEG
68599: PUSH
68600: LD_INT 0
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: LD_INT 1
68609: NEG
68610: PUSH
68611: LD_INT 1
68613: NEG
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: LD_INT 1
68621: NEG
68622: PUSH
68623: LD_INT 2
68625: NEG
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: PUSH
68631: LD_INT 0
68633: PUSH
68634: LD_INT 2
68636: NEG
68637: PUSH
68638: EMPTY
68639: LIST
68640: LIST
68641: PUSH
68642: LD_INT 1
68644: PUSH
68645: LD_INT 1
68647: NEG
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: LD_INT 2
68655: PUSH
68656: LD_INT 0
68658: PUSH
68659: EMPTY
68660: LIST
68661: LIST
68662: PUSH
68663: LD_INT 2
68665: PUSH
68666: LD_INT 1
68668: PUSH
68669: EMPTY
68670: LIST
68671: LIST
68672: PUSH
68673: LD_INT 2
68675: PUSH
68676: LD_INT 2
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: PUSH
68683: LD_INT 1
68685: PUSH
68686: LD_INT 2
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: PUSH
68693: LD_INT 0
68695: PUSH
68696: LD_INT 2
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: LD_INT 1
68705: NEG
68706: PUSH
68707: LD_INT 1
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: PUSH
68714: LD_INT 2
68716: NEG
68717: PUSH
68718: LD_INT 0
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PUSH
68725: LD_INT 2
68727: NEG
68728: PUSH
68729: LD_INT 1
68731: NEG
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: PUSH
68737: LD_INT 2
68739: NEG
68740: PUSH
68741: LD_INT 2
68743: NEG
68744: PUSH
68745: EMPTY
68746: LIST
68747: LIST
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: LIST
68753: LIST
68754: LIST
68755: LIST
68756: LIST
68757: LIST
68758: LIST
68759: LIST
68760: LIST
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: LIST
68768: LIST
68769: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68770: LD_ADDR_VAR 0 19
68774: PUSH
68775: LD_INT 0
68777: PUSH
68778: LD_INT 0
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: LD_INT 0
68787: PUSH
68788: LD_INT 1
68790: NEG
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: PUSH
68796: LD_INT 1
68798: PUSH
68799: LD_INT 0
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 1
68808: PUSH
68809: LD_INT 1
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 0
68818: PUSH
68819: LD_INT 1
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 1
68828: NEG
68829: PUSH
68830: LD_INT 0
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 1
68839: NEG
68840: PUSH
68841: LD_INT 1
68843: NEG
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: PUSH
68849: LD_INT 1
68851: NEG
68852: PUSH
68853: LD_INT 2
68855: NEG
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: PUSH
68861: LD_INT 0
68863: PUSH
68864: LD_INT 2
68866: NEG
68867: PUSH
68868: EMPTY
68869: LIST
68870: LIST
68871: PUSH
68872: LD_INT 1
68874: PUSH
68875: LD_INT 1
68877: NEG
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 2
68885: PUSH
68886: LD_INT 0
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: LD_INT 2
68895: PUSH
68896: LD_INT 1
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: LD_INT 2
68905: PUSH
68906: LD_INT 2
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PUSH
68913: LD_INT 1
68915: PUSH
68916: LD_INT 2
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: PUSH
68923: LD_INT 0
68925: PUSH
68926: LD_INT 2
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: PUSH
68933: LD_INT 1
68935: NEG
68936: PUSH
68937: LD_INT 1
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 2
68946: NEG
68947: PUSH
68948: LD_INT 0
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 2
68957: NEG
68958: PUSH
68959: LD_INT 1
68961: NEG
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: PUSH
68967: LD_INT 2
68969: NEG
68970: PUSH
68971: LD_INT 2
68973: NEG
68974: PUSH
68975: EMPTY
68976: LIST
68977: LIST
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: LIST
68983: LIST
68984: LIST
68985: LIST
68986: LIST
68987: LIST
68988: LIST
68989: LIST
68990: LIST
68991: LIST
68992: LIST
68993: LIST
68994: LIST
68995: LIST
68996: LIST
68997: LIST
68998: LIST
68999: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69000: LD_ADDR_VAR 0 20
69004: PUSH
69005: LD_INT 0
69007: PUSH
69008: LD_INT 0
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 0
69017: PUSH
69018: LD_INT 1
69020: NEG
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: PUSH
69026: LD_INT 1
69028: PUSH
69029: LD_INT 0
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: LD_INT 1
69038: PUSH
69039: LD_INT 1
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: PUSH
69046: LD_INT 0
69048: PUSH
69049: LD_INT 1
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: LD_INT 1
69058: NEG
69059: PUSH
69060: LD_INT 0
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: LD_INT 1
69069: NEG
69070: PUSH
69071: LD_INT 1
69073: NEG
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: LD_INT 1
69081: NEG
69082: PUSH
69083: LD_INT 2
69085: NEG
69086: PUSH
69087: EMPTY
69088: LIST
69089: LIST
69090: PUSH
69091: LD_INT 0
69093: PUSH
69094: LD_INT 2
69096: NEG
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: PUSH
69102: LD_INT 1
69104: PUSH
69105: LD_INT 1
69107: NEG
69108: PUSH
69109: EMPTY
69110: LIST
69111: LIST
69112: PUSH
69113: LD_INT 2
69115: PUSH
69116: LD_INT 0
69118: PUSH
69119: EMPTY
69120: LIST
69121: LIST
69122: PUSH
69123: LD_INT 2
69125: PUSH
69126: LD_INT 1
69128: PUSH
69129: EMPTY
69130: LIST
69131: LIST
69132: PUSH
69133: LD_INT 2
69135: PUSH
69136: LD_INT 2
69138: PUSH
69139: EMPTY
69140: LIST
69141: LIST
69142: PUSH
69143: LD_INT 1
69145: PUSH
69146: LD_INT 2
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 0
69155: PUSH
69156: LD_INT 2
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: LD_INT 1
69165: NEG
69166: PUSH
69167: LD_INT 1
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: LD_INT 2
69176: NEG
69177: PUSH
69178: LD_INT 0
69180: PUSH
69181: EMPTY
69182: LIST
69183: LIST
69184: PUSH
69185: LD_INT 2
69187: NEG
69188: PUSH
69189: LD_INT 1
69191: NEG
69192: PUSH
69193: EMPTY
69194: LIST
69195: LIST
69196: PUSH
69197: LD_INT 2
69199: NEG
69200: PUSH
69201: LD_INT 2
69203: NEG
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: LIST
69213: LIST
69214: LIST
69215: LIST
69216: LIST
69217: LIST
69218: LIST
69219: LIST
69220: LIST
69221: LIST
69222: LIST
69223: LIST
69224: LIST
69225: LIST
69226: LIST
69227: LIST
69228: LIST
69229: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69230: LD_ADDR_VAR 0 21
69234: PUSH
69235: LD_INT 0
69237: PUSH
69238: LD_INT 0
69240: PUSH
69241: EMPTY
69242: LIST
69243: LIST
69244: PUSH
69245: LD_INT 0
69247: PUSH
69248: LD_INT 1
69250: NEG
69251: PUSH
69252: EMPTY
69253: LIST
69254: LIST
69255: PUSH
69256: LD_INT 1
69258: PUSH
69259: LD_INT 0
69261: PUSH
69262: EMPTY
69263: LIST
69264: LIST
69265: PUSH
69266: LD_INT 1
69268: PUSH
69269: LD_INT 1
69271: PUSH
69272: EMPTY
69273: LIST
69274: LIST
69275: PUSH
69276: LD_INT 0
69278: PUSH
69279: LD_INT 1
69281: PUSH
69282: EMPTY
69283: LIST
69284: LIST
69285: PUSH
69286: LD_INT 1
69288: NEG
69289: PUSH
69290: LD_INT 0
69292: PUSH
69293: EMPTY
69294: LIST
69295: LIST
69296: PUSH
69297: LD_INT 1
69299: NEG
69300: PUSH
69301: LD_INT 1
69303: NEG
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PUSH
69309: LD_INT 1
69311: NEG
69312: PUSH
69313: LD_INT 2
69315: NEG
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PUSH
69321: LD_INT 0
69323: PUSH
69324: LD_INT 2
69326: NEG
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 1
69334: PUSH
69335: LD_INT 1
69337: NEG
69338: PUSH
69339: EMPTY
69340: LIST
69341: LIST
69342: PUSH
69343: LD_INT 2
69345: PUSH
69346: LD_INT 0
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: PUSH
69353: LD_INT 2
69355: PUSH
69356: LD_INT 1
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PUSH
69363: LD_INT 2
69365: PUSH
69366: LD_INT 2
69368: PUSH
69369: EMPTY
69370: LIST
69371: LIST
69372: PUSH
69373: LD_INT 1
69375: PUSH
69376: LD_INT 2
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 0
69385: PUSH
69386: LD_INT 2
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: LD_INT 1
69395: NEG
69396: PUSH
69397: LD_INT 1
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: LD_INT 2
69406: NEG
69407: PUSH
69408: LD_INT 0
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: PUSH
69415: LD_INT 2
69417: NEG
69418: PUSH
69419: LD_INT 1
69421: NEG
69422: PUSH
69423: EMPTY
69424: LIST
69425: LIST
69426: PUSH
69427: LD_INT 2
69429: NEG
69430: PUSH
69431: LD_INT 2
69433: NEG
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: LIST
69443: LIST
69444: LIST
69445: LIST
69446: LIST
69447: LIST
69448: LIST
69449: LIST
69450: LIST
69451: LIST
69452: LIST
69453: LIST
69454: LIST
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69460: LD_ADDR_VAR 0 22
69464: PUSH
69465: LD_INT 0
69467: PUSH
69468: LD_INT 0
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: PUSH
69475: LD_INT 0
69477: PUSH
69478: LD_INT 1
69480: NEG
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: LD_INT 1
69488: PUSH
69489: LD_INT 0
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 1
69498: PUSH
69499: LD_INT 1
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 0
69508: PUSH
69509: LD_INT 1
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: LD_INT 1
69518: NEG
69519: PUSH
69520: LD_INT 0
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PUSH
69527: LD_INT 1
69529: NEG
69530: PUSH
69531: LD_INT 1
69533: NEG
69534: PUSH
69535: EMPTY
69536: LIST
69537: LIST
69538: PUSH
69539: LD_INT 1
69541: NEG
69542: PUSH
69543: LD_INT 2
69545: NEG
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: LD_INT 0
69553: PUSH
69554: LD_INT 2
69556: NEG
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: LD_INT 1
69564: PUSH
69565: LD_INT 1
69567: NEG
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PUSH
69573: LD_INT 2
69575: PUSH
69576: LD_INT 0
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PUSH
69583: LD_INT 2
69585: PUSH
69586: LD_INT 1
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: LD_INT 2
69595: PUSH
69596: LD_INT 2
69598: PUSH
69599: EMPTY
69600: LIST
69601: LIST
69602: PUSH
69603: LD_INT 1
69605: PUSH
69606: LD_INT 2
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 0
69615: PUSH
69616: LD_INT 2
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: PUSH
69623: LD_INT 1
69625: NEG
69626: PUSH
69627: LD_INT 1
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: PUSH
69634: LD_INT 2
69636: NEG
69637: PUSH
69638: LD_INT 0
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: LD_INT 2
69647: NEG
69648: PUSH
69649: LD_INT 1
69651: NEG
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 2
69659: NEG
69660: PUSH
69661: LD_INT 2
69663: NEG
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: LIST
69673: LIST
69674: LIST
69675: LIST
69676: LIST
69677: LIST
69678: LIST
69679: LIST
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: LIST
69689: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
69690: LD_ADDR_VAR 0 23
69694: PUSH
69695: LD_INT 0
69697: PUSH
69698: LD_INT 0
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 0
69707: PUSH
69708: LD_INT 1
69710: NEG
69711: PUSH
69712: EMPTY
69713: LIST
69714: LIST
69715: PUSH
69716: LD_INT 1
69718: PUSH
69719: LD_INT 0
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: PUSH
69726: LD_INT 1
69728: PUSH
69729: LD_INT 1
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 0
69738: PUSH
69739: LD_INT 1
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 1
69748: NEG
69749: PUSH
69750: LD_INT 0
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: PUSH
69757: LD_INT 1
69759: NEG
69760: PUSH
69761: LD_INT 1
69763: NEG
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: PUSH
69769: LD_INT 1
69771: NEG
69772: PUSH
69773: LD_INT 2
69775: NEG
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 0
69783: PUSH
69784: LD_INT 2
69786: NEG
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 1
69794: PUSH
69795: LD_INT 1
69797: NEG
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: PUSH
69803: LD_INT 2
69805: PUSH
69806: LD_INT 0
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: PUSH
69813: LD_INT 2
69815: PUSH
69816: LD_INT 1
69818: PUSH
69819: EMPTY
69820: LIST
69821: LIST
69822: PUSH
69823: LD_INT 2
69825: PUSH
69826: LD_INT 2
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: PUSH
69833: LD_INT 1
69835: PUSH
69836: LD_INT 2
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 0
69845: PUSH
69846: LD_INT 2
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: LD_INT 1
69855: NEG
69856: PUSH
69857: LD_INT 1
69859: PUSH
69860: EMPTY
69861: LIST
69862: LIST
69863: PUSH
69864: LD_INT 2
69866: NEG
69867: PUSH
69868: LD_INT 0
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PUSH
69875: LD_INT 2
69877: NEG
69878: PUSH
69879: LD_INT 1
69881: NEG
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 2
69889: NEG
69890: PUSH
69891: LD_INT 2
69893: NEG
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: LD_INT 2
69901: NEG
69902: PUSH
69903: LD_INT 3
69905: NEG
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 1
69913: NEG
69914: PUSH
69915: LD_INT 3
69917: NEG
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: LD_INT 1
69925: PUSH
69926: LD_INT 2
69928: NEG
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: LD_INT 2
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: LIST
69952: LIST
69953: LIST
69954: LIST
69955: LIST
69956: LIST
69957: LIST
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69970: LD_ADDR_VAR 0 24
69974: PUSH
69975: LD_INT 0
69977: PUSH
69978: LD_INT 0
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PUSH
69985: LD_INT 0
69987: PUSH
69988: LD_INT 1
69990: NEG
69991: PUSH
69992: EMPTY
69993: LIST
69994: LIST
69995: PUSH
69996: LD_INT 1
69998: PUSH
69999: LD_INT 0
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: LD_INT 1
70008: PUSH
70009: LD_INT 1
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: LD_INT 0
70018: PUSH
70019: LD_INT 1
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: PUSH
70026: LD_INT 1
70028: NEG
70029: PUSH
70030: LD_INT 0
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: LD_INT 1
70039: NEG
70040: PUSH
70041: LD_INT 1
70043: NEG
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: PUSH
70049: LD_INT 1
70051: NEG
70052: PUSH
70053: LD_INT 2
70055: NEG
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PUSH
70061: LD_INT 0
70063: PUSH
70064: LD_INT 2
70066: NEG
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 1
70074: PUSH
70075: LD_INT 1
70077: NEG
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: PUSH
70083: LD_INT 2
70085: PUSH
70086: LD_INT 0
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: PUSH
70093: LD_INT 2
70095: PUSH
70096: LD_INT 1
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: LD_INT 2
70105: PUSH
70106: LD_INT 2
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 1
70115: PUSH
70116: LD_INT 2
70118: PUSH
70119: EMPTY
70120: LIST
70121: LIST
70122: PUSH
70123: LD_INT 0
70125: PUSH
70126: LD_INT 2
70128: PUSH
70129: EMPTY
70130: LIST
70131: LIST
70132: PUSH
70133: LD_INT 1
70135: NEG
70136: PUSH
70137: LD_INT 1
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: PUSH
70144: LD_INT 2
70146: NEG
70147: PUSH
70148: LD_INT 0
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PUSH
70155: LD_INT 2
70157: NEG
70158: PUSH
70159: LD_INT 1
70161: NEG
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: PUSH
70167: LD_INT 2
70169: NEG
70170: PUSH
70171: LD_INT 2
70173: NEG
70174: PUSH
70175: EMPTY
70176: LIST
70177: LIST
70178: PUSH
70179: LD_INT 1
70181: PUSH
70182: LD_INT 2
70184: NEG
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 2
70192: PUSH
70193: LD_INT 1
70195: NEG
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 3
70203: PUSH
70204: LD_INT 1
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 3
70213: PUSH
70214: LD_INT 2
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: LIST
70233: LIST
70234: LIST
70235: LIST
70236: LIST
70237: LIST
70238: LIST
70239: LIST
70240: LIST
70241: LIST
70242: LIST
70243: LIST
70244: LIST
70245: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
70246: LD_ADDR_VAR 0 25
70250: PUSH
70251: LD_INT 0
70253: PUSH
70254: LD_INT 0
70256: PUSH
70257: EMPTY
70258: LIST
70259: LIST
70260: PUSH
70261: LD_INT 0
70263: PUSH
70264: LD_INT 1
70266: NEG
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: LD_INT 1
70274: PUSH
70275: LD_INT 0
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: LD_INT 1
70284: PUSH
70285: LD_INT 1
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: PUSH
70292: LD_INT 0
70294: PUSH
70295: LD_INT 1
70297: PUSH
70298: EMPTY
70299: LIST
70300: LIST
70301: PUSH
70302: LD_INT 1
70304: NEG
70305: PUSH
70306: LD_INT 0
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: LD_INT 1
70315: NEG
70316: PUSH
70317: LD_INT 1
70319: NEG
70320: PUSH
70321: EMPTY
70322: LIST
70323: LIST
70324: PUSH
70325: LD_INT 1
70327: NEG
70328: PUSH
70329: LD_INT 2
70331: NEG
70332: PUSH
70333: EMPTY
70334: LIST
70335: LIST
70336: PUSH
70337: LD_INT 0
70339: PUSH
70340: LD_INT 2
70342: NEG
70343: PUSH
70344: EMPTY
70345: LIST
70346: LIST
70347: PUSH
70348: LD_INT 1
70350: PUSH
70351: LD_INT 1
70353: NEG
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 2
70361: PUSH
70362: LD_INT 0
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 2
70371: PUSH
70372: LD_INT 1
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: PUSH
70379: LD_INT 2
70381: PUSH
70382: LD_INT 2
70384: PUSH
70385: EMPTY
70386: LIST
70387: LIST
70388: PUSH
70389: LD_INT 1
70391: PUSH
70392: LD_INT 2
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: LD_INT 0
70401: PUSH
70402: LD_INT 2
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 1
70411: NEG
70412: PUSH
70413: LD_INT 1
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 2
70422: NEG
70423: PUSH
70424: LD_INT 0
70426: PUSH
70427: EMPTY
70428: LIST
70429: LIST
70430: PUSH
70431: LD_INT 2
70433: NEG
70434: PUSH
70435: LD_INT 1
70437: NEG
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: LD_INT 2
70445: NEG
70446: PUSH
70447: LD_INT 2
70449: NEG
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: PUSH
70455: LD_INT 3
70457: PUSH
70458: LD_INT 1
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: PUSH
70465: LD_INT 3
70467: PUSH
70468: LD_INT 2
70470: PUSH
70471: EMPTY
70472: LIST
70473: LIST
70474: PUSH
70475: LD_INT 2
70477: PUSH
70478: LD_INT 3
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PUSH
70485: LD_INT 1
70487: PUSH
70488: LD_INT 3
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: LIST
70499: LIST
70500: LIST
70501: LIST
70502: LIST
70503: LIST
70504: LIST
70505: LIST
70506: LIST
70507: LIST
70508: LIST
70509: LIST
70510: LIST
70511: LIST
70512: LIST
70513: LIST
70514: LIST
70515: LIST
70516: LIST
70517: LIST
70518: LIST
70519: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
70520: LD_ADDR_VAR 0 26
70524: PUSH
70525: LD_INT 0
70527: PUSH
70528: LD_INT 0
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 0
70537: PUSH
70538: LD_INT 1
70540: NEG
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 1
70548: PUSH
70549: LD_INT 0
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 1
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: LD_INT 0
70568: PUSH
70569: LD_INT 1
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 1
70578: NEG
70579: PUSH
70580: LD_INT 0
70582: PUSH
70583: EMPTY
70584: LIST
70585: LIST
70586: PUSH
70587: LD_INT 1
70589: NEG
70590: PUSH
70591: LD_INT 1
70593: NEG
70594: PUSH
70595: EMPTY
70596: LIST
70597: LIST
70598: PUSH
70599: LD_INT 1
70601: NEG
70602: PUSH
70603: LD_INT 2
70605: NEG
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 0
70613: PUSH
70614: LD_INT 2
70616: NEG
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 1
70624: PUSH
70625: LD_INT 1
70627: NEG
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: LD_INT 2
70635: PUSH
70636: LD_INT 0
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 2
70645: PUSH
70646: LD_INT 1
70648: PUSH
70649: EMPTY
70650: LIST
70651: LIST
70652: PUSH
70653: LD_INT 2
70655: PUSH
70656: LD_INT 2
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: LD_INT 1
70665: PUSH
70666: LD_INT 2
70668: PUSH
70669: EMPTY
70670: LIST
70671: LIST
70672: PUSH
70673: LD_INT 0
70675: PUSH
70676: LD_INT 2
70678: PUSH
70679: EMPTY
70680: LIST
70681: LIST
70682: PUSH
70683: LD_INT 1
70685: NEG
70686: PUSH
70687: LD_INT 1
70689: PUSH
70690: EMPTY
70691: LIST
70692: LIST
70693: PUSH
70694: LD_INT 2
70696: NEG
70697: PUSH
70698: LD_INT 0
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: PUSH
70705: LD_INT 2
70707: NEG
70708: PUSH
70709: LD_INT 1
70711: NEG
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: PUSH
70717: LD_INT 2
70719: NEG
70720: PUSH
70721: LD_INT 2
70723: NEG
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: LD_INT 2
70731: PUSH
70732: LD_INT 3
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 1
70741: PUSH
70742: LD_INT 3
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: LD_INT 1
70751: NEG
70752: PUSH
70753: LD_INT 2
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PUSH
70760: LD_INT 2
70762: NEG
70763: PUSH
70764: LD_INT 1
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70796: LD_ADDR_VAR 0 27
70800: PUSH
70801: LD_INT 0
70803: PUSH
70804: LD_INT 0
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 0
70813: PUSH
70814: LD_INT 1
70816: NEG
70817: PUSH
70818: EMPTY
70819: LIST
70820: LIST
70821: PUSH
70822: LD_INT 1
70824: PUSH
70825: LD_INT 0
70827: PUSH
70828: EMPTY
70829: LIST
70830: LIST
70831: PUSH
70832: LD_INT 1
70834: PUSH
70835: LD_INT 1
70837: PUSH
70838: EMPTY
70839: LIST
70840: LIST
70841: PUSH
70842: LD_INT 0
70844: PUSH
70845: LD_INT 1
70847: PUSH
70848: EMPTY
70849: LIST
70850: LIST
70851: PUSH
70852: LD_INT 1
70854: NEG
70855: PUSH
70856: LD_INT 0
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: PUSH
70863: LD_INT 1
70865: NEG
70866: PUSH
70867: LD_INT 1
70869: NEG
70870: PUSH
70871: EMPTY
70872: LIST
70873: LIST
70874: PUSH
70875: LD_INT 1
70877: NEG
70878: PUSH
70879: LD_INT 2
70881: NEG
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 0
70889: PUSH
70890: LD_INT 2
70892: NEG
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: PUSH
70898: LD_INT 1
70900: PUSH
70901: LD_INT 1
70903: NEG
70904: PUSH
70905: EMPTY
70906: LIST
70907: LIST
70908: PUSH
70909: LD_INT 2
70911: PUSH
70912: LD_INT 0
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: PUSH
70919: LD_INT 2
70921: PUSH
70922: LD_INT 1
70924: PUSH
70925: EMPTY
70926: LIST
70927: LIST
70928: PUSH
70929: LD_INT 2
70931: PUSH
70932: LD_INT 2
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 1
70941: PUSH
70942: LD_INT 2
70944: PUSH
70945: EMPTY
70946: LIST
70947: LIST
70948: PUSH
70949: LD_INT 0
70951: PUSH
70952: LD_INT 2
70954: PUSH
70955: EMPTY
70956: LIST
70957: LIST
70958: PUSH
70959: LD_INT 1
70961: NEG
70962: PUSH
70963: LD_INT 1
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 2
70972: NEG
70973: PUSH
70974: LD_INT 0
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: PUSH
70981: LD_INT 2
70983: NEG
70984: PUSH
70985: LD_INT 1
70987: NEG
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 2
70995: NEG
70996: PUSH
70997: LD_INT 2
70999: NEG
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 1
71007: NEG
71008: PUSH
71009: LD_INT 2
71011: PUSH
71012: EMPTY
71013: LIST
71014: LIST
71015: PUSH
71016: LD_INT 2
71018: NEG
71019: PUSH
71020: LD_INT 1
71022: PUSH
71023: EMPTY
71024: LIST
71025: LIST
71026: PUSH
71027: LD_INT 3
71029: NEG
71030: PUSH
71031: LD_INT 1
71033: NEG
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: LD_INT 3
71041: NEG
71042: PUSH
71043: LD_INT 2
71045: NEG
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: LIST
71055: LIST
71056: LIST
71057: LIST
71058: LIST
71059: LIST
71060: LIST
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: LIST
71067: LIST
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71076: LD_ADDR_VAR 0 28
71080: PUSH
71081: LD_INT 0
71083: PUSH
71084: LD_INT 0
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PUSH
71091: LD_INT 0
71093: PUSH
71094: LD_INT 1
71096: NEG
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: PUSH
71102: LD_INT 1
71104: PUSH
71105: LD_INT 0
71107: PUSH
71108: EMPTY
71109: LIST
71110: LIST
71111: PUSH
71112: LD_INT 1
71114: PUSH
71115: LD_INT 1
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PUSH
71122: LD_INT 0
71124: PUSH
71125: LD_INT 1
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: LD_INT 1
71134: NEG
71135: PUSH
71136: LD_INT 0
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: PUSH
71143: LD_INT 1
71145: NEG
71146: PUSH
71147: LD_INT 1
71149: NEG
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: LD_INT 1
71157: NEG
71158: PUSH
71159: LD_INT 2
71161: NEG
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 0
71169: PUSH
71170: LD_INT 2
71172: NEG
71173: PUSH
71174: EMPTY
71175: LIST
71176: LIST
71177: PUSH
71178: LD_INT 1
71180: PUSH
71181: LD_INT 1
71183: NEG
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 2
71191: PUSH
71192: LD_INT 0
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 2
71201: PUSH
71202: LD_INT 1
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: PUSH
71209: LD_INT 2
71211: PUSH
71212: LD_INT 2
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: PUSH
71219: LD_INT 1
71221: PUSH
71222: LD_INT 2
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: PUSH
71229: LD_INT 0
71231: PUSH
71232: LD_INT 2
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 1
71241: NEG
71242: PUSH
71243: LD_INT 1
71245: PUSH
71246: EMPTY
71247: LIST
71248: LIST
71249: PUSH
71250: LD_INT 2
71252: NEG
71253: PUSH
71254: LD_INT 0
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 2
71263: NEG
71264: PUSH
71265: LD_INT 1
71267: NEG
71268: PUSH
71269: EMPTY
71270: LIST
71271: LIST
71272: PUSH
71273: LD_INT 2
71275: NEG
71276: PUSH
71277: LD_INT 2
71279: NEG
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PUSH
71285: LD_INT 2
71287: NEG
71288: PUSH
71289: LD_INT 3
71291: NEG
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 1
71299: NEG
71300: PUSH
71301: LD_INT 3
71303: NEG
71304: PUSH
71305: EMPTY
71306: LIST
71307: LIST
71308: PUSH
71309: LD_INT 3
71311: NEG
71312: PUSH
71313: LD_INT 1
71315: NEG
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 3
71323: NEG
71324: PUSH
71325: LD_INT 2
71327: NEG
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: LIST
71347: LIST
71348: LIST
71349: LIST
71350: LIST
71351: LIST
71352: LIST
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71358: LD_ADDR_VAR 0 29
71362: PUSH
71363: LD_INT 0
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 0
71375: PUSH
71376: LD_INT 1
71378: NEG
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 1
71386: PUSH
71387: LD_INT 0
71389: PUSH
71390: EMPTY
71391: LIST
71392: LIST
71393: PUSH
71394: LD_INT 1
71396: PUSH
71397: LD_INT 1
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PUSH
71404: LD_INT 0
71406: PUSH
71407: LD_INT 1
71409: PUSH
71410: EMPTY
71411: LIST
71412: LIST
71413: PUSH
71414: LD_INT 1
71416: NEG
71417: PUSH
71418: LD_INT 0
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: LD_INT 1
71427: NEG
71428: PUSH
71429: LD_INT 1
71431: NEG
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: PUSH
71437: LD_INT 1
71439: NEG
71440: PUSH
71441: LD_INT 2
71443: NEG
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 0
71451: PUSH
71452: LD_INT 2
71454: NEG
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: LD_INT 1
71462: PUSH
71463: LD_INT 1
71465: NEG
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: PUSH
71471: LD_INT 2
71473: PUSH
71474: LD_INT 0
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 2
71483: PUSH
71484: LD_INT 1
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 1
71493: PUSH
71494: LD_INT 2
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: PUSH
71501: LD_INT 0
71503: PUSH
71504: LD_INT 2
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 1
71513: NEG
71514: PUSH
71515: LD_INT 1
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: LD_INT 2
71524: NEG
71525: PUSH
71526: LD_INT 1
71528: NEG
71529: PUSH
71530: EMPTY
71531: LIST
71532: LIST
71533: PUSH
71534: LD_INT 2
71536: NEG
71537: PUSH
71538: LD_INT 2
71540: NEG
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: LD_INT 2
71548: NEG
71549: PUSH
71550: LD_INT 3
71552: NEG
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: PUSH
71558: LD_INT 2
71560: PUSH
71561: LD_INT 1
71563: NEG
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: LD_INT 3
71571: PUSH
71572: LD_INT 1
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PUSH
71579: LD_INT 1
71581: PUSH
71582: LD_INT 3
71584: PUSH
71585: EMPTY
71586: LIST
71587: LIST
71588: PUSH
71589: LD_INT 1
71591: NEG
71592: PUSH
71593: LD_INT 2
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: PUSH
71600: LD_INT 3
71602: NEG
71603: PUSH
71604: LD_INT 2
71606: NEG
71607: PUSH
71608: EMPTY
71609: LIST
71610: LIST
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: LIST
71623: LIST
71624: LIST
71625: LIST
71626: LIST
71627: LIST
71628: LIST
71629: LIST
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: LIST
71636: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71637: LD_ADDR_VAR 0 30
71641: PUSH
71642: LD_INT 0
71644: PUSH
71645: LD_INT 0
71647: PUSH
71648: EMPTY
71649: LIST
71650: LIST
71651: PUSH
71652: LD_INT 0
71654: PUSH
71655: LD_INT 1
71657: NEG
71658: PUSH
71659: EMPTY
71660: LIST
71661: LIST
71662: PUSH
71663: LD_INT 1
71665: PUSH
71666: LD_INT 0
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: PUSH
71673: LD_INT 1
71675: PUSH
71676: LD_INT 1
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PUSH
71683: LD_INT 0
71685: PUSH
71686: LD_INT 1
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PUSH
71693: LD_INT 1
71695: NEG
71696: PUSH
71697: LD_INT 0
71699: PUSH
71700: EMPTY
71701: LIST
71702: LIST
71703: PUSH
71704: LD_INT 1
71706: NEG
71707: PUSH
71708: LD_INT 1
71710: NEG
71711: PUSH
71712: EMPTY
71713: LIST
71714: LIST
71715: PUSH
71716: LD_INT 1
71718: NEG
71719: PUSH
71720: LD_INT 2
71722: NEG
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: LD_INT 0
71730: PUSH
71731: LD_INT 2
71733: NEG
71734: PUSH
71735: EMPTY
71736: LIST
71737: LIST
71738: PUSH
71739: LD_INT 1
71741: PUSH
71742: LD_INT 1
71744: NEG
71745: PUSH
71746: EMPTY
71747: LIST
71748: LIST
71749: PUSH
71750: LD_INT 2
71752: PUSH
71753: LD_INT 0
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: PUSH
71760: LD_INT 2
71762: PUSH
71763: LD_INT 1
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: PUSH
71770: LD_INT 2
71772: PUSH
71773: LD_INT 2
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 1
71782: PUSH
71783: LD_INT 2
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 1
71792: NEG
71793: PUSH
71794: LD_INT 1
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: PUSH
71801: LD_INT 2
71803: NEG
71804: PUSH
71805: LD_INT 0
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 2
71814: NEG
71815: PUSH
71816: LD_INT 1
71818: NEG
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: PUSH
71824: LD_INT 1
71826: NEG
71827: PUSH
71828: LD_INT 3
71830: NEG
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 1
71838: PUSH
71839: LD_INT 2
71841: NEG
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: LD_INT 3
71849: PUSH
71850: LD_INT 2
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 2
71859: PUSH
71860: LD_INT 3
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PUSH
71867: LD_INT 2
71869: NEG
71870: PUSH
71871: LD_INT 1
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: LD_INT 3
71880: NEG
71881: PUSH
71882: LD_INT 1
71884: NEG
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: LIST
71894: LIST
71895: LIST
71896: LIST
71897: LIST
71898: LIST
71899: LIST
71900: LIST
71901: LIST
71902: LIST
71903: LIST
71904: LIST
71905: LIST
71906: LIST
71907: LIST
71908: LIST
71909: LIST
71910: LIST
71911: LIST
71912: LIST
71913: LIST
71914: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71915: LD_ADDR_VAR 0 31
71919: PUSH
71920: LD_INT 0
71922: PUSH
71923: LD_INT 0
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: PUSH
71930: LD_INT 0
71932: PUSH
71933: LD_INT 1
71935: NEG
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PUSH
71941: LD_INT 1
71943: PUSH
71944: LD_INT 0
71946: PUSH
71947: EMPTY
71948: LIST
71949: LIST
71950: PUSH
71951: LD_INT 1
71953: PUSH
71954: LD_INT 1
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: PUSH
71961: LD_INT 0
71963: PUSH
71964: LD_INT 1
71966: PUSH
71967: EMPTY
71968: LIST
71969: LIST
71970: PUSH
71971: LD_INT 1
71973: NEG
71974: PUSH
71975: LD_INT 0
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: LD_INT 1
71984: NEG
71985: PUSH
71986: LD_INT 1
71988: NEG
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: PUSH
71994: LD_INT 1
71996: NEG
71997: PUSH
71998: LD_INT 2
72000: NEG
72001: PUSH
72002: EMPTY
72003: LIST
72004: LIST
72005: PUSH
72006: LD_INT 1
72008: PUSH
72009: LD_INT 1
72011: NEG
72012: PUSH
72013: EMPTY
72014: LIST
72015: LIST
72016: PUSH
72017: LD_INT 2
72019: PUSH
72020: LD_INT 0
72022: PUSH
72023: EMPTY
72024: LIST
72025: LIST
72026: PUSH
72027: LD_INT 2
72029: PUSH
72030: LD_INT 1
72032: PUSH
72033: EMPTY
72034: LIST
72035: LIST
72036: PUSH
72037: LD_INT 2
72039: PUSH
72040: LD_INT 2
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: LD_INT 1
72049: PUSH
72050: LD_INT 2
72052: PUSH
72053: EMPTY
72054: LIST
72055: LIST
72056: PUSH
72057: LD_INT 0
72059: PUSH
72060: LD_INT 2
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: LD_INT 1
72069: NEG
72070: PUSH
72071: LD_INT 1
72073: PUSH
72074: EMPTY
72075: LIST
72076: LIST
72077: PUSH
72078: LD_INT 2
72080: NEG
72081: PUSH
72082: LD_INT 1
72084: NEG
72085: PUSH
72086: EMPTY
72087: LIST
72088: LIST
72089: PUSH
72090: LD_INT 2
72092: NEG
72093: PUSH
72094: LD_INT 2
72096: NEG
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: PUSH
72102: LD_INT 2
72104: NEG
72105: PUSH
72106: LD_INT 3
72108: NEG
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: PUSH
72114: LD_INT 2
72116: PUSH
72117: LD_INT 1
72119: NEG
72120: PUSH
72121: EMPTY
72122: LIST
72123: LIST
72124: PUSH
72125: LD_INT 3
72127: PUSH
72128: LD_INT 1
72130: PUSH
72131: EMPTY
72132: LIST
72133: LIST
72134: PUSH
72135: LD_INT 1
72137: PUSH
72138: LD_INT 3
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: LD_INT 1
72147: NEG
72148: PUSH
72149: LD_INT 2
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PUSH
72156: LD_INT 3
72158: NEG
72159: PUSH
72160: LD_INT 2
72162: NEG
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: EMPTY
72169: LIST
72170: LIST
72171: LIST
72172: LIST
72173: LIST
72174: LIST
72175: LIST
72176: LIST
72177: LIST
72178: LIST
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: LIST
72184: LIST
72185: LIST
72186: LIST
72187: LIST
72188: LIST
72189: LIST
72190: LIST
72191: LIST
72192: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72193: LD_ADDR_VAR 0 32
72197: PUSH
72198: LD_INT 0
72200: PUSH
72201: LD_INT 0
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 0
72210: PUSH
72211: LD_INT 1
72213: NEG
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: PUSH
72219: LD_INT 1
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 1
72231: PUSH
72232: LD_INT 1
72234: PUSH
72235: EMPTY
72236: LIST
72237: LIST
72238: PUSH
72239: LD_INT 0
72241: PUSH
72242: LD_INT 1
72244: PUSH
72245: EMPTY
72246: LIST
72247: LIST
72248: PUSH
72249: LD_INT 1
72251: NEG
72252: PUSH
72253: LD_INT 0
72255: PUSH
72256: EMPTY
72257: LIST
72258: LIST
72259: PUSH
72260: LD_INT 1
72262: NEG
72263: PUSH
72264: LD_INT 1
72266: NEG
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: PUSH
72272: LD_INT 1
72274: NEG
72275: PUSH
72276: LD_INT 2
72278: NEG
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 0
72286: PUSH
72287: LD_INT 2
72289: NEG
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 1
72297: PUSH
72298: LD_INT 1
72300: NEG
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: PUSH
72306: LD_INT 2
72308: PUSH
72309: LD_INT 1
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: LD_INT 2
72318: PUSH
72319: LD_INT 2
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: LD_INT 1
72328: PUSH
72329: LD_INT 2
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: PUSH
72336: LD_INT 0
72338: PUSH
72339: LD_INT 2
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: PUSH
72346: LD_INT 1
72348: NEG
72349: PUSH
72350: LD_INT 1
72352: PUSH
72353: EMPTY
72354: LIST
72355: LIST
72356: PUSH
72357: LD_INT 2
72359: NEG
72360: PUSH
72361: LD_INT 0
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: PUSH
72368: LD_INT 2
72370: NEG
72371: PUSH
72372: LD_INT 1
72374: NEG
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: LD_INT 1
72382: NEG
72383: PUSH
72384: LD_INT 3
72386: NEG
72387: PUSH
72388: EMPTY
72389: LIST
72390: LIST
72391: PUSH
72392: LD_INT 1
72394: PUSH
72395: LD_INT 2
72397: NEG
72398: PUSH
72399: EMPTY
72400: LIST
72401: LIST
72402: PUSH
72403: LD_INT 3
72405: PUSH
72406: LD_INT 2
72408: PUSH
72409: EMPTY
72410: LIST
72411: LIST
72412: PUSH
72413: LD_INT 2
72415: PUSH
72416: LD_INT 3
72418: PUSH
72419: EMPTY
72420: LIST
72421: LIST
72422: PUSH
72423: LD_INT 2
72425: NEG
72426: PUSH
72427: LD_INT 1
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PUSH
72434: LD_INT 3
72436: NEG
72437: PUSH
72438: LD_INT 1
72440: NEG
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: LIST
72450: LIST
72451: LIST
72452: LIST
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: LIST
72468: LIST
72469: LIST
72470: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72471: LD_ADDR_VAR 0 33
72475: PUSH
72476: LD_INT 0
72478: PUSH
72479: LD_INT 0
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: PUSH
72486: LD_INT 0
72488: PUSH
72489: LD_INT 1
72491: NEG
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: PUSH
72497: LD_INT 1
72499: PUSH
72500: LD_INT 0
72502: PUSH
72503: EMPTY
72504: LIST
72505: LIST
72506: PUSH
72507: LD_INT 1
72509: PUSH
72510: LD_INT 1
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: LD_INT 0
72519: PUSH
72520: LD_INT 1
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: PUSH
72527: LD_INT 1
72529: NEG
72530: PUSH
72531: LD_INT 0
72533: PUSH
72534: EMPTY
72535: LIST
72536: LIST
72537: PUSH
72538: LD_INT 1
72540: NEG
72541: PUSH
72542: LD_INT 1
72544: NEG
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 1
72552: NEG
72553: PUSH
72554: LD_INT 2
72556: NEG
72557: PUSH
72558: EMPTY
72559: LIST
72560: LIST
72561: PUSH
72562: LD_INT 1
72564: PUSH
72565: LD_INT 1
72567: NEG
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: LD_INT 2
72575: PUSH
72576: LD_INT 0
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: LD_INT 2
72585: PUSH
72586: LD_INT 1
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PUSH
72593: LD_INT 1
72595: PUSH
72596: LD_INT 2
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 0
72605: PUSH
72606: LD_INT 2
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PUSH
72613: LD_INT 1
72615: NEG
72616: PUSH
72617: LD_INT 1
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 2
72626: NEG
72627: PUSH
72628: LD_INT 0
72630: PUSH
72631: EMPTY
72632: LIST
72633: LIST
72634: PUSH
72635: LD_INT 2
72637: NEG
72638: PUSH
72639: LD_INT 1
72641: NEG
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: PUSH
72647: LD_INT 2
72649: NEG
72650: PUSH
72651: LD_INT 2
72653: NEG
72654: PUSH
72655: EMPTY
72656: LIST
72657: LIST
72658: PUSH
72659: LD_INT 2
72661: NEG
72662: PUSH
72663: LD_INT 3
72665: NEG
72666: PUSH
72667: EMPTY
72668: LIST
72669: LIST
72670: PUSH
72671: LD_INT 2
72673: PUSH
72674: LD_INT 1
72676: NEG
72677: PUSH
72678: EMPTY
72679: LIST
72680: LIST
72681: PUSH
72682: LD_INT 3
72684: PUSH
72685: LD_INT 1
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: PUSH
72692: LD_INT 1
72694: PUSH
72695: LD_INT 3
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: PUSH
72702: LD_INT 1
72704: NEG
72705: PUSH
72706: LD_INT 2
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: PUSH
72713: LD_INT 3
72715: NEG
72716: PUSH
72717: LD_INT 2
72719: NEG
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: LIST
72733: LIST
72734: LIST
72735: LIST
72736: LIST
72737: LIST
72738: LIST
72739: LIST
72740: LIST
72741: LIST
72742: LIST
72743: LIST
72744: LIST
72745: LIST
72746: LIST
72747: LIST
72748: LIST
72749: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72750: LD_ADDR_VAR 0 34
72754: PUSH
72755: LD_INT 0
72757: PUSH
72758: LD_INT 0
72760: PUSH
72761: EMPTY
72762: LIST
72763: LIST
72764: PUSH
72765: LD_INT 0
72767: PUSH
72768: LD_INT 1
72770: NEG
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: PUSH
72776: LD_INT 1
72778: PUSH
72779: LD_INT 0
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 1
72788: PUSH
72789: LD_INT 1
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PUSH
72796: LD_INT 0
72798: PUSH
72799: LD_INT 1
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 1
72808: NEG
72809: PUSH
72810: LD_INT 0
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PUSH
72817: LD_INT 1
72819: NEG
72820: PUSH
72821: LD_INT 1
72823: NEG
72824: PUSH
72825: EMPTY
72826: LIST
72827: LIST
72828: PUSH
72829: LD_INT 1
72831: NEG
72832: PUSH
72833: LD_INT 2
72835: NEG
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: PUSH
72841: LD_INT 0
72843: PUSH
72844: LD_INT 2
72846: NEG
72847: PUSH
72848: EMPTY
72849: LIST
72850: LIST
72851: PUSH
72852: LD_INT 1
72854: PUSH
72855: LD_INT 1
72857: NEG
72858: PUSH
72859: EMPTY
72860: LIST
72861: LIST
72862: PUSH
72863: LD_INT 2
72865: PUSH
72866: LD_INT 1
72868: PUSH
72869: EMPTY
72870: LIST
72871: LIST
72872: PUSH
72873: LD_INT 2
72875: PUSH
72876: LD_INT 2
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: PUSH
72883: LD_INT 1
72885: PUSH
72886: LD_INT 2
72888: PUSH
72889: EMPTY
72890: LIST
72891: LIST
72892: PUSH
72893: LD_INT 1
72895: NEG
72896: PUSH
72897: LD_INT 1
72899: PUSH
72900: EMPTY
72901: LIST
72902: LIST
72903: PUSH
72904: LD_INT 2
72906: NEG
72907: PUSH
72908: LD_INT 0
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 2
72917: NEG
72918: PUSH
72919: LD_INT 1
72921: NEG
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 2
72929: NEG
72930: PUSH
72931: LD_INT 2
72933: NEG
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: PUSH
72939: LD_INT 1
72941: NEG
72942: PUSH
72943: LD_INT 3
72945: NEG
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 1
72953: PUSH
72954: LD_INT 2
72956: NEG
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 3
72964: PUSH
72965: LD_INT 2
72967: PUSH
72968: EMPTY
72969: LIST
72970: LIST
72971: PUSH
72972: LD_INT 2
72974: PUSH
72975: LD_INT 3
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: LD_INT 2
72984: NEG
72985: PUSH
72986: LD_INT 1
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 3
72995: NEG
72996: PUSH
72997: LD_INT 1
72999: NEG
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: LIST
73013: LIST
73014: LIST
73015: LIST
73016: LIST
73017: LIST
73018: LIST
73019: LIST
73020: LIST
73021: LIST
73022: LIST
73023: LIST
73024: LIST
73025: LIST
73026: LIST
73027: LIST
73028: LIST
73029: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
73030: LD_ADDR_VAR 0 35
73034: PUSH
73035: LD_INT 0
73037: PUSH
73038: LD_INT 0
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: LD_INT 0
73047: PUSH
73048: LD_INT 1
73050: NEG
73051: PUSH
73052: EMPTY
73053: LIST
73054: LIST
73055: PUSH
73056: LD_INT 1
73058: PUSH
73059: LD_INT 0
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: PUSH
73066: LD_INT 1
73068: PUSH
73069: LD_INT 1
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: PUSH
73076: LD_INT 0
73078: PUSH
73079: LD_INT 1
73081: PUSH
73082: EMPTY
73083: LIST
73084: LIST
73085: PUSH
73086: LD_INT 1
73088: NEG
73089: PUSH
73090: LD_INT 0
73092: PUSH
73093: EMPTY
73094: LIST
73095: LIST
73096: PUSH
73097: LD_INT 1
73099: NEG
73100: PUSH
73101: LD_INT 1
73103: NEG
73104: PUSH
73105: EMPTY
73106: LIST
73107: LIST
73108: PUSH
73109: LD_INT 2
73111: PUSH
73112: LD_INT 1
73114: PUSH
73115: EMPTY
73116: LIST
73117: LIST
73118: PUSH
73119: LD_INT 2
73121: NEG
73122: PUSH
73123: LD_INT 1
73125: NEG
73126: PUSH
73127: EMPTY
73128: LIST
73129: LIST
73130: PUSH
73131: EMPTY
73132: LIST
73133: LIST
73134: LIST
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73142: LD_ADDR_VAR 0 36
73146: PUSH
73147: LD_INT 0
73149: PUSH
73150: LD_INT 0
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 0
73159: PUSH
73160: LD_INT 1
73162: NEG
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 1
73170: PUSH
73171: LD_INT 0
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 1
73180: PUSH
73181: LD_INT 1
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: LD_INT 0
73190: PUSH
73191: LD_INT 1
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: LD_INT 1
73200: NEG
73201: PUSH
73202: LD_INT 0
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: LD_INT 1
73211: NEG
73212: PUSH
73213: LD_INT 1
73215: NEG
73216: PUSH
73217: EMPTY
73218: LIST
73219: LIST
73220: PUSH
73221: LD_INT 1
73223: NEG
73224: PUSH
73225: LD_INT 2
73227: NEG
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 1
73235: PUSH
73236: LD_INT 2
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: LIST
73247: LIST
73248: LIST
73249: LIST
73250: LIST
73251: LIST
73252: LIST
73253: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
73254: LD_ADDR_VAR 0 37
73258: PUSH
73259: LD_INT 0
73261: PUSH
73262: LD_INT 0
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: LD_INT 0
73271: PUSH
73272: LD_INT 1
73274: NEG
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: PUSH
73280: LD_INT 1
73282: PUSH
73283: LD_INT 0
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 1
73292: PUSH
73293: LD_INT 1
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: PUSH
73300: LD_INT 0
73302: PUSH
73303: LD_INT 1
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: LD_INT 1
73312: NEG
73313: PUSH
73314: LD_INT 0
73316: PUSH
73317: EMPTY
73318: LIST
73319: LIST
73320: PUSH
73321: LD_INT 1
73323: NEG
73324: PUSH
73325: LD_INT 1
73327: NEG
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: PUSH
73333: LD_INT 1
73335: PUSH
73336: LD_INT 1
73338: NEG
73339: PUSH
73340: EMPTY
73341: LIST
73342: LIST
73343: PUSH
73344: LD_INT 1
73346: NEG
73347: PUSH
73348: LD_INT 1
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
73366: LD_ADDR_VAR 0 38
73370: PUSH
73371: LD_INT 0
73373: PUSH
73374: LD_INT 0
73376: PUSH
73377: EMPTY
73378: LIST
73379: LIST
73380: PUSH
73381: LD_INT 0
73383: PUSH
73384: LD_INT 1
73386: NEG
73387: PUSH
73388: EMPTY
73389: LIST
73390: LIST
73391: PUSH
73392: LD_INT 1
73394: PUSH
73395: LD_INT 0
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PUSH
73402: LD_INT 1
73404: PUSH
73405: LD_INT 1
73407: PUSH
73408: EMPTY
73409: LIST
73410: LIST
73411: PUSH
73412: LD_INT 0
73414: PUSH
73415: LD_INT 1
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: PUSH
73422: LD_INT 1
73424: NEG
73425: PUSH
73426: LD_INT 0
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: LD_INT 1
73435: NEG
73436: PUSH
73437: LD_INT 1
73439: NEG
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: PUSH
73445: LD_INT 2
73447: PUSH
73448: LD_INT 1
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 2
73457: NEG
73458: PUSH
73459: LD_INT 1
73461: NEG
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: LIST
73471: LIST
73472: LIST
73473: LIST
73474: LIST
73475: LIST
73476: LIST
73477: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
73478: LD_ADDR_VAR 0 39
73482: PUSH
73483: LD_INT 0
73485: PUSH
73486: LD_INT 0
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: LD_INT 0
73495: PUSH
73496: LD_INT 1
73498: NEG
73499: PUSH
73500: EMPTY
73501: LIST
73502: LIST
73503: PUSH
73504: LD_INT 1
73506: PUSH
73507: LD_INT 0
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PUSH
73514: LD_INT 1
73516: PUSH
73517: LD_INT 1
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 0
73526: PUSH
73527: LD_INT 1
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 1
73536: NEG
73537: PUSH
73538: LD_INT 0
73540: PUSH
73541: EMPTY
73542: LIST
73543: LIST
73544: PUSH
73545: LD_INT 1
73547: NEG
73548: PUSH
73549: LD_INT 1
73551: NEG
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: PUSH
73557: LD_INT 1
73559: NEG
73560: PUSH
73561: LD_INT 2
73563: NEG
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: PUSH
73569: LD_INT 1
73571: PUSH
73572: LD_INT 2
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: LIST
73583: LIST
73584: LIST
73585: LIST
73586: LIST
73587: LIST
73588: LIST
73589: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
73590: LD_ADDR_VAR 0 40
73594: PUSH
73595: LD_INT 0
73597: PUSH
73598: LD_INT 0
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 0
73607: PUSH
73608: LD_INT 1
73610: NEG
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: LD_INT 0
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: PUSH
73626: LD_INT 1
73628: PUSH
73629: LD_INT 1
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 0
73638: PUSH
73639: LD_INT 1
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: PUSH
73646: LD_INT 1
73648: NEG
73649: PUSH
73650: LD_INT 0
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: PUSH
73657: LD_INT 1
73659: NEG
73660: PUSH
73661: LD_INT 1
73663: NEG
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 1
73671: PUSH
73672: LD_INT 1
73674: NEG
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: PUSH
73680: LD_INT 1
73682: NEG
73683: PUSH
73684: LD_INT 1
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: LIST
73695: LIST
73696: LIST
73697: LIST
73698: LIST
73699: LIST
73700: LIST
73701: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73702: LD_ADDR_VAR 0 41
73706: PUSH
73707: LD_INT 0
73709: PUSH
73710: LD_INT 0
73712: PUSH
73713: EMPTY
73714: LIST
73715: LIST
73716: PUSH
73717: LD_INT 0
73719: PUSH
73720: LD_INT 1
73722: NEG
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: PUSH
73728: LD_INT 1
73730: PUSH
73731: LD_INT 0
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 1
73740: PUSH
73741: LD_INT 1
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: PUSH
73748: LD_INT 0
73750: PUSH
73751: LD_INT 1
73753: PUSH
73754: EMPTY
73755: LIST
73756: LIST
73757: PUSH
73758: LD_INT 1
73760: NEG
73761: PUSH
73762: LD_INT 0
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: PUSH
73769: LD_INT 1
73771: NEG
73772: PUSH
73773: LD_INT 1
73775: NEG
73776: PUSH
73777: EMPTY
73778: LIST
73779: LIST
73780: PUSH
73781: LD_INT 1
73783: NEG
73784: PUSH
73785: LD_INT 2
73787: NEG
73788: PUSH
73789: EMPTY
73790: LIST
73791: LIST
73792: PUSH
73793: LD_INT 1
73795: PUSH
73796: LD_INT 1
73798: NEG
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 2
73806: PUSH
73807: LD_INT 0
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: LD_INT 2
73816: PUSH
73817: LD_INT 1
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 2
73826: PUSH
73827: LD_INT 2
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 1
73836: PUSH
73837: LD_INT 2
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: PUSH
73844: LD_INT 1
73846: NEG
73847: PUSH
73848: LD_INT 1
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: PUSH
73855: LD_INT 2
73857: NEG
73858: PUSH
73859: LD_INT 0
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 2
73868: NEG
73869: PUSH
73870: LD_INT 1
73872: NEG
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: PUSH
73878: LD_INT 2
73880: NEG
73881: PUSH
73882: LD_INT 2
73884: NEG
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: PUSH
73890: LD_INT 2
73892: NEG
73893: PUSH
73894: LD_INT 3
73896: NEG
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 2
73904: PUSH
73905: LD_INT 1
73907: NEG
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 3
73915: PUSH
73916: LD_INT 0
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 3
73925: PUSH
73926: LD_INT 1
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 3
73935: PUSH
73936: LD_INT 2
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: LD_INT 3
73945: PUSH
73946: LD_INT 3
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 2
73955: PUSH
73956: LD_INT 3
73958: PUSH
73959: EMPTY
73960: LIST
73961: LIST
73962: PUSH
73963: LD_INT 2
73965: NEG
73966: PUSH
73967: LD_INT 1
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: PUSH
73974: LD_INT 3
73976: NEG
73977: PUSH
73978: LD_INT 0
73980: PUSH
73981: EMPTY
73982: LIST
73983: LIST
73984: PUSH
73985: LD_INT 3
73987: NEG
73988: PUSH
73989: LD_INT 1
73991: NEG
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: LD_INT 3
73999: NEG
74000: PUSH
74001: LD_INT 2
74003: NEG
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 3
74011: NEG
74012: PUSH
74013: LD_INT 3
74015: NEG
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: LIST
74025: LIST
74026: LIST
74027: LIST
74028: LIST
74029: LIST
74030: LIST
74031: LIST
74032: LIST
74033: LIST
74034: LIST
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: LIST
74040: LIST
74041: LIST
74042: LIST
74043: LIST
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74052: LD_ADDR_VAR 0 42
74056: PUSH
74057: LD_INT 0
74059: PUSH
74060: LD_INT 0
74062: PUSH
74063: EMPTY
74064: LIST
74065: LIST
74066: PUSH
74067: LD_INT 0
74069: PUSH
74070: LD_INT 1
74072: NEG
74073: PUSH
74074: EMPTY
74075: LIST
74076: LIST
74077: PUSH
74078: LD_INT 1
74080: PUSH
74081: LD_INT 0
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_INT 1
74090: PUSH
74091: LD_INT 1
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: PUSH
74098: LD_INT 0
74100: PUSH
74101: LD_INT 1
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: LD_INT 1
74110: NEG
74111: PUSH
74112: LD_INT 0
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: LD_INT 1
74121: NEG
74122: PUSH
74123: LD_INT 1
74125: NEG
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: PUSH
74131: LD_INT 1
74133: NEG
74134: PUSH
74135: LD_INT 2
74137: NEG
74138: PUSH
74139: EMPTY
74140: LIST
74141: LIST
74142: PUSH
74143: LD_INT 0
74145: PUSH
74146: LD_INT 2
74148: NEG
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: PUSH
74154: LD_INT 1
74156: PUSH
74157: LD_INT 1
74159: NEG
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: LD_INT 2
74167: PUSH
74168: LD_INT 1
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 2
74177: PUSH
74178: LD_INT 2
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PUSH
74185: LD_INT 1
74187: PUSH
74188: LD_INT 2
74190: PUSH
74191: EMPTY
74192: LIST
74193: LIST
74194: PUSH
74195: LD_INT 0
74197: PUSH
74198: LD_INT 2
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: PUSH
74205: LD_INT 1
74207: NEG
74208: PUSH
74209: LD_INT 1
74211: PUSH
74212: EMPTY
74213: LIST
74214: LIST
74215: PUSH
74216: LD_INT 2
74218: NEG
74219: PUSH
74220: LD_INT 1
74222: NEG
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: LD_INT 2
74230: NEG
74231: PUSH
74232: LD_INT 2
74234: NEG
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: PUSH
74240: LD_INT 2
74242: NEG
74243: PUSH
74244: LD_INT 3
74246: NEG
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 1
74254: NEG
74255: PUSH
74256: LD_INT 3
74258: NEG
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 0
74266: PUSH
74267: LD_INT 3
74269: NEG
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 1
74277: PUSH
74278: LD_INT 2
74280: NEG
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 3
74288: PUSH
74289: LD_INT 2
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: LD_INT 3
74298: PUSH
74299: LD_INT 3
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 2
74308: PUSH
74309: LD_INT 3
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 1
74318: PUSH
74319: LD_INT 3
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 0
74328: PUSH
74329: LD_INT 3
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: LD_INT 1
74338: NEG
74339: PUSH
74340: LD_INT 2
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 3
74349: NEG
74350: PUSH
74351: LD_INT 2
74353: NEG
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PUSH
74359: LD_INT 3
74361: NEG
74362: PUSH
74363: LD_INT 3
74365: NEG
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: LIST
74375: LIST
74376: LIST
74377: LIST
74378: LIST
74379: LIST
74380: LIST
74381: LIST
74382: LIST
74383: LIST
74384: LIST
74385: LIST
74386: LIST
74387: LIST
74388: LIST
74389: LIST
74390: LIST
74391: LIST
74392: LIST
74393: LIST
74394: LIST
74395: LIST
74396: LIST
74397: LIST
74398: LIST
74399: LIST
74400: LIST
74401: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74402: LD_ADDR_VAR 0 43
74406: PUSH
74407: LD_INT 0
74409: PUSH
74410: LD_INT 0
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PUSH
74417: LD_INT 0
74419: PUSH
74420: LD_INT 1
74422: NEG
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: PUSH
74428: LD_INT 1
74430: PUSH
74431: LD_INT 0
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 1
74440: PUSH
74441: LD_INT 1
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PUSH
74448: LD_INT 0
74450: PUSH
74451: LD_INT 1
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: PUSH
74458: LD_INT 1
74460: NEG
74461: PUSH
74462: LD_INT 0
74464: PUSH
74465: EMPTY
74466: LIST
74467: LIST
74468: PUSH
74469: LD_INT 1
74471: NEG
74472: PUSH
74473: LD_INT 1
74475: NEG
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: LD_INT 1
74483: NEG
74484: PUSH
74485: LD_INT 2
74487: NEG
74488: PUSH
74489: EMPTY
74490: LIST
74491: LIST
74492: PUSH
74493: LD_INT 0
74495: PUSH
74496: LD_INT 2
74498: NEG
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: PUSH
74504: LD_INT 1
74506: PUSH
74507: LD_INT 1
74509: NEG
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: PUSH
74515: LD_INT 2
74517: PUSH
74518: LD_INT 0
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: LD_INT 2
74527: PUSH
74528: LD_INT 1
74530: PUSH
74531: EMPTY
74532: LIST
74533: LIST
74534: PUSH
74535: LD_INT 1
74537: PUSH
74538: LD_INT 2
74540: PUSH
74541: EMPTY
74542: LIST
74543: LIST
74544: PUSH
74545: LD_INT 0
74547: PUSH
74548: LD_INT 2
74550: PUSH
74551: EMPTY
74552: LIST
74553: LIST
74554: PUSH
74555: LD_INT 1
74557: NEG
74558: PUSH
74559: LD_INT 1
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PUSH
74566: LD_INT 2
74568: NEG
74569: PUSH
74570: LD_INT 0
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 2
74579: NEG
74580: PUSH
74581: LD_INT 1
74583: NEG
74584: PUSH
74585: EMPTY
74586: LIST
74587: LIST
74588: PUSH
74589: LD_INT 1
74591: NEG
74592: PUSH
74593: LD_INT 3
74595: NEG
74596: PUSH
74597: EMPTY
74598: LIST
74599: LIST
74600: PUSH
74601: LD_INT 0
74603: PUSH
74604: LD_INT 3
74606: NEG
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 1
74614: PUSH
74615: LD_INT 2
74617: NEG
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: PUSH
74623: LD_INT 2
74625: PUSH
74626: LD_INT 1
74628: NEG
74629: PUSH
74630: EMPTY
74631: LIST
74632: LIST
74633: PUSH
74634: LD_INT 3
74636: PUSH
74637: LD_INT 0
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: PUSH
74644: LD_INT 3
74646: PUSH
74647: LD_INT 1
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 1
74656: PUSH
74657: LD_INT 3
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PUSH
74664: LD_INT 0
74666: PUSH
74667: LD_INT 3
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 1
74676: NEG
74677: PUSH
74678: LD_INT 2
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: PUSH
74685: LD_INT 2
74687: NEG
74688: PUSH
74689: LD_INT 1
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: PUSH
74696: LD_INT 3
74698: NEG
74699: PUSH
74700: LD_INT 0
74702: PUSH
74703: EMPTY
74704: LIST
74705: LIST
74706: PUSH
74707: LD_INT 3
74709: NEG
74710: PUSH
74711: LD_INT 1
74713: NEG
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: EMPTY
74720: LIST
74721: LIST
74722: LIST
74723: LIST
74724: LIST
74725: LIST
74726: LIST
74727: LIST
74728: LIST
74729: LIST
74730: LIST
74731: LIST
74732: LIST
74733: LIST
74734: LIST
74735: LIST
74736: LIST
74737: LIST
74738: LIST
74739: LIST
74740: LIST
74741: LIST
74742: LIST
74743: LIST
74744: LIST
74745: LIST
74746: LIST
74747: LIST
74748: LIST
74749: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74750: LD_ADDR_VAR 0 44
74754: PUSH
74755: LD_INT 0
74757: PUSH
74758: LD_INT 0
74760: PUSH
74761: EMPTY
74762: LIST
74763: LIST
74764: PUSH
74765: LD_INT 0
74767: PUSH
74768: LD_INT 1
74770: NEG
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 1
74778: PUSH
74779: LD_INT 0
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: PUSH
74786: LD_INT 1
74788: PUSH
74789: LD_INT 1
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: PUSH
74796: LD_INT 0
74798: PUSH
74799: LD_INT 1
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: LD_INT 1
74808: NEG
74809: PUSH
74810: LD_INT 0
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: LD_INT 1
74819: NEG
74820: PUSH
74821: LD_INT 1
74823: NEG
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: PUSH
74829: LD_INT 1
74831: NEG
74832: PUSH
74833: LD_INT 2
74835: NEG
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: LD_INT 1
74843: PUSH
74844: LD_INT 1
74846: NEG
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 2
74854: PUSH
74855: LD_INT 0
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PUSH
74862: LD_INT 2
74864: PUSH
74865: LD_INT 1
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 2
74874: PUSH
74875: LD_INT 2
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 1
74884: PUSH
74885: LD_INT 2
74887: PUSH
74888: EMPTY
74889: LIST
74890: LIST
74891: PUSH
74892: LD_INT 1
74894: NEG
74895: PUSH
74896: LD_INT 1
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 2
74905: NEG
74906: PUSH
74907: LD_INT 0
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: LD_INT 2
74916: NEG
74917: PUSH
74918: LD_INT 1
74920: NEG
74921: PUSH
74922: EMPTY
74923: LIST
74924: LIST
74925: PUSH
74926: LD_INT 2
74928: NEG
74929: PUSH
74930: LD_INT 2
74932: NEG
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: PUSH
74938: LD_INT 2
74940: NEG
74941: PUSH
74942: LD_INT 3
74944: NEG
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: LD_INT 2
74952: PUSH
74953: LD_INT 1
74955: NEG
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: PUSH
74961: LD_INT 3
74963: PUSH
74964: LD_INT 0
74966: PUSH
74967: EMPTY
74968: LIST
74969: LIST
74970: PUSH
74971: LD_INT 3
74973: PUSH
74974: LD_INT 1
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: PUSH
74981: LD_INT 3
74983: PUSH
74984: LD_INT 2
74986: PUSH
74987: EMPTY
74988: LIST
74989: LIST
74990: PUSH
74991: LD_INT 3
74993: PUSH
74994: LD_INT 3
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: PUSH
75001: LD_INT 2
75003: PUSH
75004: LD_INT 3
75006: PUSH
75007: EMPTY
75008: LIST
75009: LIST
75010: PUSH
75011: LD_INT 2
75013: NEG
75014: PUSH
75015: LD_INT 1
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: PUSH
75022: LD_INT 3
75024: NEG
75025: PUSH
75026: LD_INT 0
75028: PUSH
75029: EMPTY
75030: LIST
75031: LIST
75032: PUSH
75033: LD_INT 3
75035: NEG
75036: PUSH
75037: LD_INT 1
75039: NEG
75040: PUSH
75041: EMPTY
75042: LIST
75043: LIST
75044: PUSH
75045: LD_INT 3
75047: NEG
75048: PUSH
75049: LD_INT 2
75051: NEG
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 3
75059: NEG
75060: PUSH
75061: LD_INT 3
75063: NEG
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: LIST
75073: LIST
75074: LIST
75075: LIST
75076: LIST
75077: LIST
75078: LIST
75079: LIST
75080: LIST
75081: LIST
75082: LIST
75083: LIST
75084: LIST
75085: LIST
75086: LIST
75087: LIST
75088: LIST
75089: LIST
75090: LIST
75091: LIST
75092: LIST
75093: LIST
75094: LIST
75095: LIST
75096: LIST
75097: LIST
75098: LIST
75099: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75100: LD_ADDR_VAR 0 45
75104: PUSH
75105: LD_INT 0
75107: PUSH
75108: LD_INT 0
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 0
75117: PUSH
75118: LD_INT 1
75120: NEG
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: PUSH
75126: LD_INT 1
75128: PUSH
75129: LD_INT 0
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 1
75138: PUSH
75139: LD_INT 1
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 0
75148: PUSH
75149: LD_INT 1
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: LD_INT 1
75158: NEG
75159: PUSH
75160: LD_INT 0
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: PUSH
75167: LD_INT 1
75169: NEG
75170: PUSH
75171: LD_INT 1
75173: NEG
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: PUSH
75179: LD_INT 1
75181: NEG
75182: PUSH
75183: LD_INT 2
75185: NEG
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: PUSH
75191: LD_INT 0
75193: PUSH
75194: LD_INT 2
75196: NEG
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: LD_INT 1
75204: PUSH
75205: LD_INT 1
75207: NEG
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: LD_INT 2
75215: PUSH
75216: LD_INT 1
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 2
75225: PUSH
75226: LD_INT 2
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 1
75235: PUSH
75236: LD_INT 2
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 0
75245: PUSH
75246: LD_INT 2
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: PUSH
75253: LD_INT 1
75255: NEG
75256: PUSH
75257: LD_INT 1
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: PUSH
75264: LD_INT 2
75266: NEG
75267: PUSH
75268: LD_INT 1
75270: NEG
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: LD_INT 2
75278: NEG
75279: PUSH
75280: LD_INT 2
75282: NEG
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 2
75290: NEG
75291: PUSH
75292: LD_INT 3
75294: NEG
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 1
75302: NEG
75303: PUSH
75304: LD_INT 3
75306: NEG
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 0
75314: PUSH
75315: LD_INT 3
75317: NEG
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 1
75325: PUSH
75326: LD_INT 2
75328: NEG
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: PUSH
75334: LD_INT 3
75336: PUSH
75337: LD_INT 2
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: PUSH
75344: LD_INT 3
75346: PUSH
75347: LD_INT 3
75349: PUSH
75350: EMPTY
75351: LIST
75352: LIST
75353: PUSH
75354: LD_INT 2
75356: PUSH
75357: LD_INT 3
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: LD_INT 1
75366: PUSH
75367: LD_INT 3
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: LD_INT 0
75376: PUSH
75377: LD_INT 3
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: PUSH
75384: LD_INT 1
75386: NEG
75387: PUSH
75388: LD_INT 2
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PUSH
75395: LD_INT 3
75397: NEG
75398: PUSH
75399: LD_INT 2
75401: NEG
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PUSH
75407: LD_INT 3
75409: NEG
75410: PUSH
75411: LD_INT 3
75413: NEG
75414: PUSH
75415: EMPTY
75416: LIST
75417: LIST
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: LIST
75423: LIST
75424: LIST
75425: LIST
75426: LIST
75427: LIST
75428: LIST
75429: LIST
75430: LIST
75431: LIST
75432: LIST
75433: LIST
75434: LIST
75435: LIST
75436: LIST
75437: LIST
75438: LIST
75439: LIST
75440: LIST
75441: LIST
75442: LIST
75443: LIST
75444: LIST
75445: LIST
75446: LIST
75447: LIST
75448: LIST
75449: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75450: LD_ADDR_VAR 0 46
75454: PUSH
75455: LD_INT 0
75457: PUSH
75458: LD_INT 0
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 0
75467: PUSH
75468: LD_INT 1
75470: NEG
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 1
75478: PUSH
75479: LD_INT 0
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: LD_INT 1
75488: PUSH
75489: LD_INT 1
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: PUSH
75496: LD_INT 0
75498: PUSH
75499: LD_INT 1
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 1
75508: NEG
75509: PUSH
75510: LD_INT 0
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: LD_INT 1
75519: NEG
75520: PUSH
75521: LD_INT 1
75523: NEG
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 1
75531: NEG
75532: PUSH
75533: LD_INT 2
75535: NEG
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: LD_INT 0
75543: PUSH
75544: LD_INT 2
75546: NEG
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 1
75554: PUSH
75555: LD_INT 1
75557: NEG
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: PUSH
75563: LD_INT 2
75565: PUSH
75566: LD_INT 0
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PUSH
75573: LD_INT 2
75575: PUSH
75576: LD_INT 1
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: PUSH
75583: LD_INT 1
75585: PUSH
75586: LD_INT 2
75588: PUSH
75589: EMPTY
75590: LIST
75591: LIST
75592: PUSH
75593: LD_INT 0
75595: PUSH
75596: LD_INT 2
75598: PUSH
75599: EMPTY
75600: LIST
75601: LIST
75602: PUSH
75603: LD_INT 1
75605: NEG
75606: PUSH
75607: LD_INT 1
75609: PUSH
75610: EMPTY
75611: LIST
75612: LIST
75613: PUSH
75614: LD_INT 2
75616: NEG
75617: PUSH
75618: LD_INT 0
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: PUSH
75625: LD_INT 2
75627: NEG
75628: PUSH
75629: LD_INT 1
75631: NEG
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: LD_INT 1
75639: NEG
75640: PUSH
75641: LD_INT 3
75643: NEG
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: LD_INT 0
75651: PUSH
75652: LD_INT 3
75654: NEG
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: PUSH
75660: LD_INT 1
75662: PUSH
75663: LD_INT 2
75665: NEG
75666: PUSH
75667: EMPTY
75668: LIST
75669: LIST
75670: PUSH
75671: LD_INT 2
75673: PUSH
75674: LD_INT 1
75676: NEG
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 3
75684: PUSH
75685: LD_INT 0
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: LD_INT 3
75694: PUSH
75695: LD_INT 1
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: PUSH
75702: LD_INT 1
75704: PUSH
75705: LD_INT 3
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: LD_INT 0
75714: PUSH
75715: LD_INT 3
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 1
75724: NEG
75725: PUSH
75726: LD_INT 2
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 2
75735: NEG
75736: PUSH
75737: LD_INT 1
75739: PUSH
75740: EMPTY
75741: LIST
75742: LIST
75743: PUSH
75744: LD_INT 3
75746: NEG
75747: PUSH
75748: LD_INT 0
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: PUSH
75755: LD_INT 3
75757: NEG
75758: PUSH
75759: LD_INT 1
75761: NEG
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: PUSH
75767: EMPTY
75768: LIST
75769: LIST
75770: LIST
75771: LIST
75772: LIST
75773: LIST
75774: LIST
75775: LIST
75776: LIST
75777: LIST
75778: LIST
75779: LIST
75780: LIST
75781: LIST
75782: LIST
75783: LIST
75784: LIST
75785: LIST
75786: LIST
75787: LIST
75788: LIST
75789: LIST
75790: LIST
75791: LIST
75792: LIST
75793: LIST
75794: LIST
75795: LIST
75796: LIST
75797: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75798: LD_ADDR_VAR 0 47
75802: PUSH
75803: LD_INT 0
75805: PUSH
75806: LD_INT 0
75808: PUSH
75809: EMPTY
75810: LIST
75811: LIST
75812: PUSH
75813: LD_INT 0
75815: PUSH
75816: LD_INT 1
75818: NEG
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 1
75826: PUSH
75827: LD_INT 0
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: LD_INT 1
75836: PUSH
75837: LD_INT 1
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: LD_INT 0
75846: PUSH
75847: LD_INT 1
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: PUSH
75854: LD_INT 1
75856: NEG
75857: PUSH
75858: LD_INT 0
75860: PUSH
75861: EMPTY
75862: LIST
75863: LIST
75864: PUSH
75865: LD_INT 1
75867: NEG
75868: PUSH
75869: LD_INT 1
75871: NEG
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: PUSH
75877: LD_INT 1
75879: NEG
75880: PUSH
75881: LD_INT 2
75883: NEG
75884: PUSH
75885: EMPTY
75886: LIST
75887: LIST
75888: PUSH
75889: LD_INT 0
75891: PUSH
75892: LD_INT 2
75894: NEG
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: LD_INT 1
75902: PUSH
75903: LD_INT 1
75905: NEG
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: PUSH
75911: LD_INT 2
75913: NEG
75914: PUSH
75915: LD_INT 1
75917: NEG
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 2
75925: NEG
75926: PUSH
75927: LD_INT 2
75929: NEG
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: LIST
75939: LIST
75940: LIST
75941: LIST
75942: LIST
75943: LIST
75944: LIST
75945: LIST
75946: LIST
75947: LIST
75948: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75949: LD_ADDR_VAR 0 48
75953: PUSH
75954: LD_INT 0
75956: PUSH
75957: LD_INT 0
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: PUSH
75964: LD_INT 0
75966: PUSH
75967: LD_INT 1
75969: NEG
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: LD_INT 1
75977: PUSH
75978: LD_INT 0
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: PUSH
75985: LD_INT 1
75987: PUSH
75988: LD_INT 1
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 0
75997: PUSH
75998: LD_INT 1
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: PUSH
76005: LD_INT 1
76007: NEG
76008: PUSH
76009: LD_INT 0
76011: PUSH
76012: EMPTY
76013: LIST
76014: LIST
76015: PUSH
76016: LD_INT 1
76018: NEG
76019: PUSH
76020: LD_INT 1
76022: NEG
76023: PUSH
76024: EMPTY
76025: LIST
76026: LIST
76027: PUSH
76028: LD_INT 1
76030: NEG
76031: PUSH
76032: LD_INT 2
76034: NEG
76035: PUSH
76036: EMPTY
76037: LIST
76038: LIST
76039: PUSH
76040: LD_INT 0
76042: PUSH
76043: LD_INT 2
76045: NEG
76046: PUSH
76047: EMPTY
76048: LIST
76049: LIST
76050: PUSH
76051: LD_INT 1
76053: PUSH
76054: LD_INT 1
76056: NEG
76057: PUSH
76058: EMPTY
76059: LIST
76060: LIST
76061: PUSH
76062: LD_INT 2
76064: PUSH
76065: LD_INT 0
76067: PUSH
76068: EMPTY
76069: LIST
76070: LIST
76071: PUSH
76072: LD_INT 2
76074: PUSH
76075: LD_INT 1
76077: PUSH
76078: EMPTY
76079: LIST
76080: LIST
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: LIST
76086: LIST
76087: LIST
76088: LIST
76089: LIST
76090: LIST
76091: LIST
76092: LIST
76093: LIST
76094: LIST
76095: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76096: LD_ADDR_VAR 0 49
76100: PUSH
76101: LD_INT 0
76103: PUSH
76104: LD_INT 0
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PUSH
76111: LD_INT 0
76113: PUSH
76114: LD_INT 1
76116: NEG
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: PUSH
76122: LD_INT 1
76124: PUSH
76125: LD_INT 0
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PUSH
76132: LD_INT 1
76134: PUSH
76135: LD_INT 1
76137: PUSH
76138: EMPTY
76139: LIST
76140: LIST
76141: PUSH
76142: LD_INT 0
76144: PUSH
76145: LD_INT 1
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: PUSH
76152: LD_INT 1
76154: NEG
76155: PUSH
76156: LD_INT 0
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: PUSH
76163: LD_INT 1
76165: NEG
76166: PUSH
76167: LD_INT 1
76169: NEG
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_INT 1
76177: PUSH
76178: LD_INT 1
76180: NEG
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PUSH
76186: LD_INT 2
76188: PUSH
76189: LD_INT 0
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 2
76198: PUSH
76199: LD_INT 1
76201: PUSH
76202: EMPTY
76203: LIST
76204: LIST
76205: PUSH
76206: LD_INT 2
76208: PUSH
76209: LD_INT 2
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: PUSH
76216: LD_INT 1
76218: PUSH
76219: LD_INT 2
76221: PUSH
76222: EMPTY
76223: LIST
76224: LIST
76225: PUSH
76226: EMPTY
76227: LIST
76228: LIST
76229: LIST
76230: LIST
76231: LIST
76232: LIST
76233: LIST
76234: LIST
76235: LIST
76236: LIST
76237: LIST
76238: LIST
76239: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76240: LD_ADDR_VAR 0 50
76244: PUSH
76245: LD_INT 0
76247: PUSH
76248: LD_INT 0
76250: PUSH
76251: EMPTY
76252: LIST
76253: LIST
76254: PUSH
76255: LD_INT 0
76257: PUSH
76258: LD_INT 1
76260: NEG
76261: PUSH
76262: EMPTY
76263: LIST
76264: LIST
76265: PUSH
76266: LD_INT 1
76268: PUSH
76269: LD_INT 0
76271: PUSH
76272: EMPTY
76273: LIST
76274: LIST
76275: PUSH
76276: LD_INT 1
76278: PUSH
76279: LD_INT 1
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: LD_INT 0
76288: PUSH
76289: LD_INT 1
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 1
76298: NEG
76299: PUSH
76300: LD_INT 0
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: PUSH
76307: LD_INT 1
76309: NEG
76310: PUSH
76311: LD_INT 1
76313: NEG
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: LD_INT 2
76321: PUSH
76322: LD_INT 1
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: PUSH
76329: LD_INT 2
76331: PUSH
76332: LD_INT 2
76334: PUSH
76335: EMPTY
76336: LIST
76337: LIST
76338: PUSH
76339: LD_INT 1
76341: PUSH
76342: LD_INT 2
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: LD_INT 0
76351: PUSH
76352: LD_INT 2
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: LD_INT 1
76361: NEG
76362: PUSH
76363: LD_INT 1
76365: PUSH
76366: EMPTY
76367: LIST
76368: LIST
76369: PUSH
76370: EMPTY
76371: LIST
76372: LIST
76373: LIST
76374: LIST
76375: LIST
76376: LIST
76377: LIST
76378: LIST
76379: LIST
76380: LIST
76381: LIST
76382: LIST
76383: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76384: LD_ADDR_VAR 0 51
76388: PUSH
76389: LD_INT 0
76391: PUSH
76392: LD_INT 0
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: LD_INT 0
76401: PUSH
76402: LD_INT 1
76404: NEG
76405: PUSH
76406: EMPTY
76407: LIST
76408: LIST
76409: PUSH
76410: LD_INT 1
76412: PUSH
76413: LD_INT 0
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 1
76422: PUSH
76423: LD_INT 1
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 0
76432: PUSH
76433: LD_INT 1
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: LD_INT 1
76442: NEG
76443: PUSH
76444: LD_INT 0
76446: PUSH
76447: EMPTY
76448: LIST
76449: LIST
76450: PUSH
76451: LD_INT 1
76453: NEG
76454: PUSH
76455: LD_INT 1
76457: NEG
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 1
76465: PUSH
76466: LD_INT 2
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: LD_INT 0
76475: PUSH
76476: LD_INT 2
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: LD_INT 1
76485: NEG
76486: PUSH
76487: LD_INT 1
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PUSH
76494: LD_INT 2
76496: NEG
76497: PUSH
76498: LD_INT 0
76500: PUSH
76501: EMPTY
76502: LIST
76503: LIST
76504: PUSH
76505: LD_INT 2
76507: NEG
76508: PUSH
76509: LD_INT 1
76511: NEG
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: PUSH
76517: EMPTY
76518: LIST
76519: LIST
76520: LIST
76521: LIST
76522: LIST
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76531: LD_ADDR_VAR 0 52
76535: PUSH
76536: LD_INT 0
76538: PUSH
76539: LD_INT 0
76541: PUSH
76542: EMPTY
76543: LIST
76544: LIST
76545: PUSH
76546: LD_INT 0
76548: PUSH
76549: LD_INT 1
76551: NEG
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: PUSH
76557: LD_INT 1
76559: PUSH
76560: LD_INT 0
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 1
76569: PUSH
76570: LD_INT 1
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: LD_INT 0
76579: PUSH
76580: LD_INT 1
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: PUSH
76587: LD_INT 1
76589: NEG
76590: PUSH
76591: LD_INT 0
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: PUSH
76598: LD_INT 1
76600: NEG
76601: PUSH
76602: LD_INT 1
76604: NEG
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 1
76612: NEG
76613: PUSH
76614: LD_INT 2
76616: NEG
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 1
76624: NEG
76625: PUSH
76626: LD_INT 1
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 2
76635: NEG
76636: PUSH
76637: LD_INT 0
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 2
76646: NEG
76647: PUSH
76648: LD_INT 1
76650: NEG
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 2
76658: NEG
76659: PUSH
76660: LD_INT 2
76662: NEG
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: LIST
76678: LIST
76679: LIST
76680: LIST
76681: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76682: LD_ADDR_VAR 0 53
76686: PUSH
76687: LD_INT 0
76689: PUSH
76690: LD_INT 0
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 0
76699: PUSH
76700: LD_INT 1
76702: NEG
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 1
76710: PUSH
76711: LD_INT 0
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PUSH
76718: LD_INT 1
76720: PUSH
76721: LD_INT 1
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: LD_INT 0
76730: PUSH
76731: LD_INT 1
76733: PUSH
76734: EMPTY
76735: LIST
76736: LIST
76737: PUSH
76738: LD_INT 1
76740: NEG
76741: PUSH
76742: LD_INT 0
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: PUSH
76749: LD_INT 1
76751: NEG
76752: PUSH
76753: LD_INT 1
76755: NEG
76756: PUSH
76757: EMPTY
76758: LIST
76759: LIST
76760: PUSH
76761: LD_INT 1
76763: NEG
76764: PUSH
76765: LD_INT 2
76767: NEG
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: LD_INT 0
76775: PUSH
76776: LD_INT 2
76778: NEG
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: LD_INT 1
76786: PUSH
76787: LD_INT 1
76789: NEG
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: LD_INT 2
76797: PUSH
76798: LD_INT 0
76800: PUSH
76801: EMPTY
76802: LIST
76803: LIST
76804: PUSH
76805: LD_INT 2
76807: PUSH
76808: LD_INT 1
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 2
76817: PUSH
76818: LD_INT 2
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: PUSH
76825: LD_INT 1
76827: PUSH
76828: LD_INT 2
76830: PUSH
76831: EMPTY
76832: LIST
76833: LIST
76834: PUSH
76835: LD_INT 0
76837: PUSH
76838: LD_INT 2
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: LD_INT 1
76847: NEG
76848: PUSH
76849: LD_INT 1
76851: PUSH
76852: EMPTY
76853: LIST
76854: LIST
76855: PUSH
76856: LD_INT 2
76858: NEG
76859: PUSH
76860: LD_INT 0
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: PUSH
76867: LD_INT 2
76869: NEG
76870: PUSH
76871: LD_INT 1
76873: NEG
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: PUSH
76879: LD_INT 2
76881: NEG
76882: PUSH
76883: LD_INT 2
76885: NEG
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: LIST
76895: LIST
76896: LIST
76897: LIST
76898: LIST
76899: LIST
76900: LIST
76901: LIST
76902: LIST
76903: LIST
76904: LIST
76905: LIST
76906: LIST
76907: LIST
76908: LIST
76909: LIST
76910: LIST
76911: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76912: LD_ADDR_VAR 0 54
76916: PUSH
76917: LD_INT 0
76919: PUSH
76920: LD_INT 0
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 0
76929: PUSH
76930: LD_INT 1
76932: NEG
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: LD_INT 1
76940: PUSH
76941: LD_INT 0
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 1
76950: PUSH
76951: LD_INT 1
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: PUSH
76958: LD_INT 0
76960: PUSH
76961: LD_INT 1
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 1
76970: NEG
76971: PUSH
76972: LD_INT 0
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: LD_INT 1
76981: NEG
76982: PUSH
76983: LD_INT 1
76985: NEG
76986: PUSH
76987: EMPTY
76988: LIST
76989: LIST
76990: PUSH
76991: LD_INT 1
76993: NEG
76994: PUSH
76995: LD_INT 2
76997: NEG
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: PUSH
77003: LD_INT 0
77005: PUSH
77006: LD_INT 2
77008: NEG
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 1
77016: PUSH
77017: LD_INT 1
77019: NEG
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: PUSH
77025: LD_INT 2
77027: PUSH
77028: LD_INT 0
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: PUSH
77035: LD_INT 2
77037: PUSH
77038: LD_INT 1
77040: PUSH
77041: EMPTY
77042: LIST
77043: LIST
77044: PUSH
77045: LD_INT 2
77047: PUSH
77048: LD_INT 2
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: PUSH
77055: LD_INT 1
77057: PUSH
77058: LD_INT 2
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PUSH
77065: LD_INT 0
77067: PUSH
77068: LD_INT 2
77070: PUSH
77071: EMPTY
77072: LIST
77073: LIST
77074: PUSH
77075: LD_INT 1
77077: NEG
77078: PUSH
77079: LD_INT 1
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: PUSH
77086: LD_INT 2
77088: NEG
77089: PUSH
77090: LD_INT 0
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: LD_INT 2
77099: NEG
77100: PUSH
77101: LD_INT 1
77103: NEG
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PUSH
77109: LD_INT 2
77111: NEG
77112: PUSH
77113: LD_INT 2
77115: NEG
77116: PUSH
77117: EMPTY
77118: LIST
77119: LIST
77120: PUSH
77121: EMPTY
77122: LIST
77123: LIST
77124: LIST
77125: LIST
77126: LIST
77127: LIST
77128: LIST
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: LIST
77137: LIST
77138: LIST
77139: LIST
77140: LIST
77141: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77142: LD_ADDR_VAR 0 55
77146: PUSH
77147: LD_INT 0
77149: PUSH
77150: LD_INT 0
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: LD_INT 0
77159: PUSH
77160: LD_INT 1
77162: NEG
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: PUSH
77168: LD_INT 1
77170: PUSH
77171: LD_INT 0
77173: PUSH
77174: EMPTY
77175: LIST
77176: LIST
77177: PUSH
77178: LD_INT 1
77180: PUSH
77181: LD_INT 1
77183: PUSH
77184: EMPTY
77185: LIST
77186: LIST
77187: PUSH
77188: LD_INT 0
77190: PUSH
77191: LD_INT 1
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: PUSH
77198: LD_INT 1
77200: NEG
77201: PUSH
77202: LD_INT 0
77204: PUSH
77205: EMPTY
77206: LIST
77207: LIST
77208: PUSH
77209: LD_INT 1
77211: NEG
77212: PUSH
77213: LD_INT 1
77215: NEG
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: PUSH
77221: LD_INT 1
77223: NEG
77224: PUSH
77225: LD_INT 2
77227: NEG
77228: PUSH
77229: EMPTY
77230: LIST
77231: LIST
77232: PUSH
77233: LD_INT 0
77235: PUSH
77236: LD_INT 2
77238: NEG
77239: PUSH
77240: EMPTY
77241: LIST
77242: LIST
77243: PUSH
77244: LD_INT 1
77246: PUSH
77247: LD_INT 1
77249: NEG
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: PUSH
77255: LD_INT 2
77257: PUSH
77258: LD_INT 0
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 2
77267: PUSH
77268: LD_INT 1
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: LD_INT 2
77277: PUSH
77278: LD_INT 2
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: LD_INT 1
77287: PUSH
77288: LD_INT 2
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 0
77297: PUSH
77298: LD_INT 2
77300: PUSH
77301: EMPTY
77302: LIST
77303: LIST
77304: PUSH
77305: LD_INT 1
77307: NEG
77308: PUSH
77309: LD_INT 1
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 2
77318: NEG
77319: PUSH
77320: LD_INT 0
77322: PUSH
77323: EMPTY
77324: LIST
77325: LIST
77326: PUSH
77327: LD_INT 2
77329: NEG
77330: PUSH
77331: LD_INT 1
77333: NEG
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: PUSH
77339: LD_INT 2
77341: NEG
77342: PUSH
77343: LD_INT 2
77345: NEG
77346: PUSH
77347: EMPTY
77348: LIST
77349: LIST
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: LIST
77355: LIST
77356: LIST
77357: LIST
77358: LIST
77359: LIST
77360: LIST
77361: LIST
77362: LIST
77363: LIST
77364: LIST
77365: LIST
77366: LIST
77367: LIST
77368: LIST
77369: LIST
77370: LIST
77371: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77372: LD_ADDR_VAR 0 56
77376: PUSH
77377: LD_INT 0
77379: PUSH
77380: LD_INT 0
77382: PUSH
77383: EMPTY
77384: LIST
77385: LIST
77386: PUSH
77387: LD_INT 0
77389: PUSH
77390: LD_INT 1
77392: NEG
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: PUSH
77398: LD_INT 1
77400: PUSH
77401: LD_INT 0
77403: PUSH
77404: EMPTY
77405: LIST
77406: LIST
77407: PUSH
77408: LD_INT 1
77410: PUSH
77411: LD_INT 1
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 0
77420: PUSH
77421: LD_INT 1
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 1
77430: NEG
77431: PUSH
77432: LD_INT 0
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: PUSH
77439: LD_INT 1
77441: NEG
77442: PUSH
77443: LD_INT 1
77445: NEG
77446: PUSH
77447: EMPTY
77448: LIST
77449: LIST
77450: PUSH
77451: LD_INT 1
77453: NEG
77454: PUSH
77455: LD_INT 2
77457: NEG
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: PUSH
77463: LD_INT 0
77465: PUSH
77466: LD_INT 2
77468: NEG
77469: PUSH
77470: EMPTY
77471: LIST
77472: LIST
77473: PUSH
77474: LD_INT 1
77476: PUSH
77477: LD_INT 1
77479: NEG
77480: PUSH
77481: EMPTY
77482: LIST
77483: LIST
77484: PUSH
77485: LD_INT 2
77487: PUSH
77488: LD_INT 0
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 2
77497: PUSH
77498: LD_INT 1
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: LD_INT 2
77507: PUSH
77508: LD_INT 2
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PUSH
77515: LD_INT 1
77517: PUSH
77518: LD_INT 2
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: LD_INT 0
77527: PUSH
77528: LD_INT 2
77530: PUSH
77531: EMPTY
77532: LIST
77533: LIST
77534: PUSH
77535: LD_INT 1
77537: NEG
77538: PUSH
77539: LD_INT 1
77541: PUSH
77542: EMPTY
77543: LIST
77544: LIST
77545: PUSH
77546: LD_INT 2
77548: NEG
77549: PUSH
77550: LD_INT 0
77552: PUSH
77553: EMPTY
77554: LIST
77555: LIST
77556: PUSH
77557: LD_INT 2
77559: NEG
77560: PUSH
77561: LD_INT 1
77563: NEG
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 2
77571: NEG
77572: PUSH
77573: LD_INT 2
77575: NEG
77576: PUSH
77577: EMPTY
77578: LIST
77579: LIST
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: LIST
77589: LIST
77590: LIST
77591: LIST
77592: LIST
77593: LIST
77594: LIST
77595: LIST
77596: LIST
77597: LIST
77598: LIST
77599: LIST
77600: LIST
77601: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77602: LD_ADDR_VAR 0 57
77606: PUSH
77607: LD_INT 0
77609: PUSH
77610: LD_INT 0
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: PUSH
77617: LD_INT 0
77619: PUSH
77620: LD_INT 1
77622: NEG
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: PUSH
77628: LD_INT 1
77630: PUSH
77631: LD_INT 0
77633: PUSH
77634: EMPTY
77635: LIST
77636: LIST
77637: PUSH
77638: LD_INT 1
77640: PUSH
77641: LD_INT 1
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: PUSH
77648: LD_INT 0
77650: PUSH
77651: LD_INT 1
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: PUSH
77658: LD_INT 1
77660: NEG
77661: PUSH
77662: LD_INT 0
77664: PUSH
77665: EMPTY
77666: LIST
77667: LIST
77668: PUSH
77669: LD_INT 1
77671: NEG
77672: PUSH
77673: LD_INT 1
77675: NEG
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: PUSH
77681: LD_INT 1
77683: NEG
77684: PUSH
77685: LD_INT 2
77687: NEG
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 0
77695: PUSH
77696: LD_INT 2
77698: NEG
77699: PUSH
77700: EMPTY
77701: LIST
77702: LIST
77703: PUSH
77704: LD_INT 1
77706: PUSH
77707: LD_INT 1
77709: NEG
77710: PUSH
77711: EMPTY
77712: LIST
77713: LIST
77714: PUSH
77715: LD_INT 2
77717: PUSH
77718: LD_INT 0
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: PUSH
77725: LD_INT 2
77727: PUSH
77728: LD_INT 1
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: PUSH
77735: LD_INT 2
77737: PUSH
77738: LD_INT 2
77740: PUSH
77741: EMPTY
77742: LIST
77743: LIST
77744: PUSH
77745: LD_INT 1
77747: PUSH
77748: LD_INT 2
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: PUSH
77755: LD_INT 0
77757: PUSH
77758: LD_INT 2
77760: PUSH
77761: EMPTY
77762: LIST
77763: LIST
77764: PUSH
77765: LD_INT 1
77767: NEG
77768: PUSH
77769: LD_INT 1
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: LD_INT 2
77778: NEG
77779: PUSH
77780: LD_INT 0
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: PUSH
77787: LD_INT 2
77789: NEG
77790: PUSH
77791: LD_INT 1
77793: NEG
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 2
77801: NEG
77802: PUSH
77803: LD_INT 2
77805: NEG
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: LIST
77815: LIST
77816: LIST
77817: LIST
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: LIST
77823: LIST
77824: LIST
77825: LIST
77826: LIST
77827: LIST
77828: LIST
77829: LIST
77830: LIST
77831: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77832: LD_ADDR_VAR 0 58
77836: PUSH
77837: LD_INT 0
77839: PUSH
77840: LD_INT 0
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: PUSH
77847: LD_INT 0
77849: PUSH
77850: LD_INT 1
77852: NEG
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 1
77860: PUSH
77861: LD_INT 0
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: LD_INT 1
77870: PUSH
77871: LD_INT 1
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: LD_INT 0
77880: PUSH
77881: LD_INT 1
77883: PUSH
77884: EMPTY
77885: LIST
77886: LIST
77887: PUSH
77888: LD_INT 1
77890: NEG
77891: PUSH
77892: LD_INT 0
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 1
77901: NEG
77902: PUSH
77903: LD_INT 1
77905: NEG
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: PUSH
77911: LD_INT 1
77913: NEG
77914: PUSH
77915: LD_INT 2
77917: NEG
77918: PUSH
77919: EMPTY
77920: LIST
77921: LIST
77922: PUSH
77923: LD_INT 0
77925: PUSH
77926: LD_INT 2
77928: NEG
77929: PUSH
77930: EMPTY
77931: LIST
77932: LIST
77933: PUSH
77934: LD_INT 1
77936: PUSH
77937: LD_INT 1
77939: NEG
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PUSH
77945: LD_INT 2
77947: PUSH
77948: LD_INT 0
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: PUSH
77955: LD_INT 2
77957: PUSH
77958: LD_INT 1
77960: PUSH
77961: EMPTY
77962: LIST
77963: LIST
77964: PUSH
77965: LD_INT 2
77967: PUSH
77968: LD_INT 2
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PUSH
77975: LD_INT 1
77977: PUSH
77978: LD_INT 2
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 0
77987: PUSH
77988: LD_INT 2
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: LD_INT 1
77997: NEG
77998: PUSH
77999: LD_INT 1
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: PUSH
78006: LD_INT 2
78008: NEG
78009: PUSH
78010: LD_INT 0
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: LD_INT 2
78019: NEG
78020: PUSH
78021: LD_INT 1
78023: NEG
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: PUSH
78029: LD_INT 2
78031: NEG
78032: PUSH
78033: LD_INT 2
78035: NEG
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: EMPTY
78042: LIST
78043: LIST
78044: LIST
78045: LIST
78046: LIST
78047: LIST
78048: LIST
78049: LIST
78050: LIST
78051: LIST
78052: LIST
78053: LIST
78054: LIST
78055: LIST
78056: LIST
78057: LIST
78058: LIST
78059: LIST
78060: LIST
78061: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78062: LD_ADDR_VAR 0 59
78066: PUSH
78067: LD_INT 0
78069: PUSH
78070: LD_INT 0
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: PUSH
78077: LD_INT 0
78079: PUSH
78080: LD_INT 1
78082: NEG
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 1
78090: PUSH
78091: LD_INT 0
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: PUSH
78098: LD_INT 1
78100: PUSH
78101: LD_INT 1
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 0
78110: PUSH
78111: LD_INT 1
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 1
78120: NEG
78121: PUSH
78122: LD_INT 0
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 1
78131: NEG
78132: PUSH
78133: LD_INT 1
78135: NEG
78136: PUSH
78137: EMPTY
78138: LIST
78139: LIST
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78150: LD_ADDR_VAR 0 60
78154: PUSH
78155: LD_INT 0
78157: PUSH
78158: LD_INT 0
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: LD_INT 0
78167: PUSH
78168: LD_INT 1
78170: NEG
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PUSH
78176: LD_INT 1
78178: PUSH
78179: LD_INT 0
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: LD_INT 1
78188: PUSH
78189: LD_INT 1
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: PUSH
78196: LD_INT 0
78198: PUSH
78199: LD_INT 1
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 1
78208: NEG
78209: PUSH
78210: LD_INT 0
78212: PUSH
78213: EMPTY
78214: LIST
78215: LIST
78216: PUSH
78217: LD_INT 1
78219: NEG
78220: PUSH
78221: LD_INT 1
78223: NEG
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: PUSH
78229: EMPTY
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78238: LD_ADDR_VAR 0 61
78242: PUSH
78243: LD_INT 0
78245: PUSH
78246: LD_INT 0
78248: PUSH
78249: EMPTY
78250: LIST
78251: LIST
78252: PUSH
78253: LD_INT 0
78255: PUSH
78256: LD_INT 1
78258: NEG
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: PUSH
78264: LD_INT 1
78266: PUSH
78267: LD_INT 0
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 1
78276: PUSH
78277: LD_INT 1
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: PUSH
78284: LD_INT 0
78286: PUSH
78287: LD_INT 1
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: PUSH
78294: LD_INT 1
78296: NEG
78297: PUSH
78298: LD_INT 0
78300: PUSH
78301: EMPTY
78302: LIST
78303: LIST
78304: PUSH
78305: LD_INT 1
78307: NEG
78308: PUSH
78309: LD_INT 1
78311: NEG
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: LIST
78321: LIST
78322: LIST
78323: LIST
78324: LIST
78325: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78326: LD_ADDR_VAR 0 62
78330: PUSH
78331: LD_INT 0
78333: PUSH
78334: LD_INT 0
78336: PUSH
78337: EMPTY
78338: LIST
78339: LIST
78340: PUSH
78341: LD_INT 0
78343: PUSH
78344: LD_INT 1
78346: NEG
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 1
78354: PUSH
78355: LD_INT 0
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: LD_INT 1
78364: PUSH
78365: LD_INT 1
78367: PUSH
78368: EMPTY
78369: LIST
78370: LIST
78371: PUSH
78372: LD_INT 0
78374: PUSH
78375: LD_INT 1
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 1
78384: NEG
78385: PUSH
78386: LD_INT 0
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PUSH
78393: LD_INT 1
78395: NEG
78396: PUSH
78397: LD_INT 1
78399: NEG
78400: PUSH
78401: EMPTY
78402: LIST
78403: LIST
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: LIST
78409: LIST
78410: LIST
78411: LIST
78412: LIST
78413: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78414: LD_ADDR_VAR 0 63
78418: PUSH
78419: LD_INT 0
78421: PUSH
78422: LD_INT 0
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PUSH
78429: LD_INT 0
78431: PUSH
78432: LD_INT 1
78434: NEG
78435: PUSH
78436: EMPTY
78437: LIST
78438: LIST
78439: PUSH
78440: LD_INT 1
78442: PUSH
78443: LD_INT 0
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 1
78452: PUSH
78453: LD_INT 1
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 0
78462: PUSH
78463: LD_INT 1
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: PUSH
78470: LD_INT 1
78472: NEG
78473: PUSH
78474: LD_INT 0
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: PUSH
78481: LD_INT 1
78483: NEG
78484: PUSH
78485: LD_INT 1
78487: NEG
78488: PUSH
78489: EMPTY
78490: LIST
78491: LIST
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: LIST
78497: LIST
78498: LIST
78499: LIST
78500: LIST
78501: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
78502: LD_ADDR_VAR 0 64
78506: PUSH
78507: LD_INT 0
78509: PUSH
78510: LD_INT 0
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 0
78519: PUSH
78520: LD_INT 1
78522: NEG
78523: PUSH
78524: EMPTY
78525: LIST
78526: LIST
78527: PUSH
78528: LD_INT 1
78530: PUSH
78531: LD_INT 0
78533: PUSH
78534: EMPTY
78535: LIST
78536: LIST
78537: PUSH
78538: LD_INT 1
78540: PUSH
78541: LD_INT 1
78543: PUSH
78544: EMPTY
78545: LIST
78546: LIST
78547: PUSH
78548: LD_INT 0
78550: PUSH
78551: LD_INT 1
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: PUSH
78558: LD_INT 1
78560: NEG
78561: PUSH
78562: LD_INT 0
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 1
78571: NEG
78572: PUSH
78573: LD_INT 1
78575: NEG
78576: PUSH
78577: EMPTY
78578: LIST
78579: LIST
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: LIST
78585: LIST
78586: LIST
78587: LIST
78588: LIST
78589: ST_TO_ADDR
// end ; 1 :
78590: GO 84487
78592: LD_INT 1
78594: DOUBLE
78595: EQUAL
78596: IFTRUE 78600
78598: GO 81223
78600: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78601: LD_ADDR_VAR 0 11
78605: PUSH
78606: LD_INT 1
78608: NEG
78609: PUSH
78610: LD_INT 3
78612: NEG
78613: PUSH
78614: EMPTY
78615: LIST
78616: LIST
78617: PUSH
78618: LD_INT 0
78620: PUSH
78621: LD_INT 3
78623: NEG
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 1
78631: PUSH
78632: LD_INT 2
78634: NEG
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: EMPTY
78641: LIST
78642: LIST
78643: LIST
78644: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78645: LD_ADDR_VAR 0 12
78649: PUSH
78650: LD_INT 2
78652: PUSH
78653: LD_INT 1
78655: NEG
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 3
78663: PUSH
78664: LD_INT 0
78666: PUSH
78667: EMPTY
78668: LIST
78669: LIST
78670: PUSH
78671: LD_INT 3
78673: PUSH
78674: LD_INT 1
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: LIST
78685: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78686: LD_ADDR_VAR 0 13
78690: PUSH
78691: LD_INT 3
78693: PUSH
78694: LD_INT 2
78696: PUSH
78697: EMPTY
78698: LIST
78699: LIST
78700: PUSH
78701: LD_INT 3
78703: PUSH
78704: LD_INT 3
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: PUSH
78711: LD_INT 2
78713: PUSH
78714: LD_INT 3
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: LIST
78725: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78726: LD_ADDR_VAR 0 14
78730: PUSH
78731: LD_INT 1
78733: PUSH
78734: LD_INT 3
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: PUSH
78741: LD_INT 0
78743: PUSH
78744: LD_INT 3
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: PUSH
78751: LD_INT 1
78753: NEG
78754: PUSH
78755: LD_INT 2
78757: PUSH
78758: EMPTY
78759: LIST
78760: LIST
78761: PUSH
78762: EMPTY
78763: LIST
78764: LIST
78765: LIST
78766: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78767: LD_ADDR_VAR 0 15
78771: PUSH
78772: LD_INT 2
78774: NEG
78775: PUSH
78776: LD_INT 1
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 3
78785: NEG
78786: PUSH
78787: LD_INT 0
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: LD_INT 3
78796: NEG
78797: PUSH
78798: LD_INT 1
78800: NEG
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: LIST
78810: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78811: LD_ADDR_VAR 0 16
78815: PUSH
78816: LD_INT 2
78818: NEG
78819: PUSH
78820: LD_INT 3
78822: NEG
78823: PUSH
78824: EMPTY
78825: LIST
78826: LIST
78827: PUSH
78828: LD_INT 3
78830: NEG
78831: PUSH
78832: LD_INT 2
78834: NEG
78835: PUSH
78836: EMPTY
78837: LIST
78838: LIST
78839: PUSH
78840: LD_INT 3
78842: NEG
78843: PUSH
78844: LD_INT 3
78846: NEG
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: LIST
78856: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78857: LD_ADDR_VAR 0 17
78861: PUSH
78862: LD_INT 1
78864: NEG
78865: PUSH
78866: LD_INT 3
78868: NEG
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: PUSH
78874: LD_INT 0
78876: PUSH
78877: LD_INT 3
78879: NEG
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: PUSH
78885: LD_INT 1
78887: PUSH
78888: LD_INT 2
78890: NEG
78891: PUSH
78892: EMPTY
78893: LIST
78894: LIST
78895: PUSH
78896: EMPTY
78897: LIST
78898: LIST
78899: LIST
78900: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78901: LD_ADDR_VAR 0 18
78905: PUSH
78906: LD_INT 2
78908: PUSH
78909: LD_INT 1
78911: NEG
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 3
78919: PUSH
78920: LD_INT 0
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: PUSH
78927: LD_INT 3
78929: PUSH
78930: LD_INT 1
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: EMPTY
78938: LIST
78939: LIST
78940: LIST
78941: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78942: LD_ADDR_VAR 0 19
78946: PUSH
78947: LD_INT 3
78949: PUSH
78950: LD_INT 2
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PUSH
78957: LD_INT 3
78959: PUSH
78960: LD_INT 3
78962: PUSH
78963: EMPTY
78964: LIST
78965: LIST
78966: PUSH
78967: LD_INT 2
78969: PUSH
78970: LD_INT 3
78972: PUSH
78973: EMPTY
78974: LIST
78975: LIST
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: LIST
78981: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78982: LD_ADDR_VAR 0 20
78986: PUSH
78987: LD_INT 1
78989: PUSH
78990: LD_INT 3
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PUSH
78997: LD_INT 0
78999: PUSH
79000: LD_INT 3
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: PUSH
79007: LD_INT 1
79009: NEG
79010: PUSH
79011: LD_INT 2
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: LIST
79022: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79023: LD_ADDR_VAR 0 21
79027: PUSH
79028: LD_INT 2
79030: NEG
79031: PUSH
79032: LD_INT 1
79034: PUSH
79035: EMPTY
79036: LIST
79037: LIST
79038: PUSH
79039: LD_INT 3
79041: NEG
79042: PUSH
79043: LD_INT 0
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: LD_INT 3
79052: NEG
79053: PUSH
79054: LD_INT 1
79056: NEG
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: EMPTY
79063: LIST
79064: LIST
79065: LIST
79066: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79067: LD_ADDR_VAR 0 22
79071: PUSH
79072: LD_INT 2
79074: NEG
79075: PUSH
79076: LD_INT 3
79078: NEG
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: LD_INT 3
79086: NEG
79087: PUSH
79088: LD_INT 2
79090: NEG
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 3
79098: NEG
79099: PUSH
79100: LD_INT 3
79102: NEG
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: LIST
79112: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
79113: LD_ADDR_VAR 0 23
79117: PUSH
79118: LD_INT 0
79120: PUSH
79121: LD_INT 3
79123: NEG
79124: PUSH
79125: EMPTY
79126: LIST
79127: LIST
79128: PUSH
79129: LD_INT 1
79131: NEG
79132: PUSH
79133: LD_INT 4
79135: NEG
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 1
79143: PUSH
79144: LD_INT 3
79146: NEG
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PUSH
79152: EMPTY
79153: LIST
79154: LIST
79155: LIST
79156: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
79157: LD_ADDR_VAR 0 24
79161: PUSH
79162: LD_INT 3
79164: PUSH
79165: LD_INT 0
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: LD_INT 3
79174: PUSH
79175: LD_INT 1
79177: NEG
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 4
79185: PUSH
79186: LD_INT 1
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: LIST
79197: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
79198: LD_ADDR_VAR 0 25
79202: PUSH
79203: LD_INT 3
79205: PUSH
79206: LD_INT 3
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: LD_INT 4
79215: PUSH
79216: LD_INT 3
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 3
79225: PUSH
79226: LD_INT 4
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: LIST
79237: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
79238: LD_ADDR_VAR 0 26
79242: PUSH
79243: LD_INT 0
79245: PUSH
79246: LD_INT 3
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 1
79255: PUSH
79256: LD_INT 4
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 1
79265: NEG
79266: PUSH
79267: LD_INT 3
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: LIST
79278: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
79279: LD_ADDR_VAR 0 27
79283: PUSH
79284: LD_INT 3
79286: NEG
79287: PUSH
79288: LD_INT 0
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 3
79297: NEG
79298: PUSH
79299: LD_INT 1
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PUSH
79306: LD_INT 4
79308: NEG
79309: PUSH
79310: LD_INT 1
79312: NEG
79313: PUSH
79314: EMPTY
79315: LIST
79316: LIST
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: LIST
79322: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
79323: LD_ADDR_VAR 0 28
79327: PUSH
79328: LD_INT 3
79330: NEG
79331: PUSH
79332: LD_INT 3
79334: NEG
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: LD_INT 3
79342: NEG
79343: PUSH
79344: LD_INT 4
79346: NEG
79347: PUSH
79348: EMPTY
79349: LIST
79350: LIST
79351: PUSH
79352: LD_INT 4
79354: NEG
79355: PUSH
79356: LD_INT 3
79358: NEG
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: LIST
79368: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
79369: LD_ADDR_VAR 0 29
79373: PUSH
79374: LD_INT 1
79376: NEG
79377: PUSH
79378: LD_INT 3
79380: NEG
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 0
79388: PUSH
79389: LD_INT 3
79391: NEG
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: LD_INT 1
79399: PUSH
79400: LD_INT 2
79402: NEG
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: PUSH
79408: LD_INT 1
79410: NEG
79411: PUSH
79412: LD_INT 4
79414: NEG
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: PUSH
79420: LD_INT 0
79422: PUSH
79423: LD_INT 4
79425: NEG
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: LD_INT 1
79433: PUSH
79434: LD_INT 3
79436: NEG
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: PUSH
79442: LD_INT 1
79444: NEG
79445: PUSH
79446: LD_INT 5
79448: NEG
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: PUSH
79454: LD_INT 0
79456: PUSH
79457: LD_INT 5
79459: NEG
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 1
79467: PUSH
79468: LD_INT 4
79470: NEG
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 1
79478: NEG
79479: PUSH
79480: LD_INT 6
79482: NEG
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 0
79490: PUSH
79491: LD_INT 6
79493: NEG
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 1
79501: PUSH
79502: LD_INT 5
79504: NEG
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
79524: LD_ADDR_VAR 0 30
79528: PUSH
79529: LD_INT 2
79531: PUSH
79532: LD_INT 1
79534: NEG
79535: PUSH
79536: EMPTY
79537: LIST
79538: LIST
79539: PUSH
79540: LD_INT 3
79542: PUSH
79543: LD_INT 0
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 3
79552: PUSH
79553: LD_INT 1
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 3
79562: PUSH
79563: LD_INT 1
79565: NEG
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 4
79573: PUSH
79574: LD_INT 0
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PUSH
79581: LD_INT 4
79583: PUSH
79584: LD_INT 1
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: PUSH
79591: LD_INT 4
79593: PUSH
79594: LD_INT 1
79596: NEG
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: LD_INT 5
79604: PUSH
79605: LD_INT 0
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 5
79614: PUSH
79615: LD_INT 1
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: PUSH
79622: LD_INT 5
79624: PUSH
79625: LD_INT 1
79627: NEG
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: LD_INT 6
79635: PUSH
79636: LD_INT 0
79638: PUSH
79639: EMPTY
79640: LIST
79641: LIST
79642: PUSH
79643: LD_INT 6
79645: PUSH
79646: LD_INT 1
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: LIST
79657: LIST
79658: LIST
79659: LIST
79660: LIST
79661: LIST
79662: LIST
79663: LIST
79664: LIST
79665: LIST
79666: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
79667: LD_ADDR_VAR 0 31
79671: PUSH
79672: LD_INT 3
79674: PUSH
79675: LD_INT 2
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: PUSH
79682: LD_INT 3
79684: PUSH
79685: LD_INT 3
79687: PUSH
79688: EMPTY
79689: LIST
79690: LIST
79691: PUSH
79692: LD_INT 2
79694: PUSH
79695: LD_INT 3
79697: PUSH
79698: EMPTY
79699: LIST
79700: LIST
79701: PUSH
79702: LD_INT 4
79704: PUSH
79705: LD_INT 3
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: LD_INT 4
79714: PUSH
79715: LD_INT 4
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 3
79724: PUSH
79725: LD_INT 4
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 5
79734: PUSH
79735: LD_INT 4
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 5
79744: PUSH
79745: LD_INT 5
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: LD_INT 4
79754: PUSH
79755: LD_INT 5
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: PUSH
79762: LD_INT 6
79764: PUSH
79765: LD_INT 5
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 6
79774: PUSH
79775: LD_INT 6
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: LD_INT 5
79784: PUSH
79785: LD_INT 6
79787: PUSH
79788: EMPTY
79789: LIST
79790: LIST
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: LIST
79796: LIST
79797: LIST
79798: LIST
79799: LIST
79800: LIST
79801: LIST
79802: LIST
79803: LIST
79804: LIST
79805: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
79806: LD_ADDR_VAR 0 32
79810: PUSH
79811: LD_INT 1
79813: PUSH
79814: LD_INT 3
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: PUSH
79821: LD_INT 0
79823: PUSH
79824: LD_INT 3
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: LD_INT 1
79833: NEG
79834: PUSH
79835: LD_INT 2
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: LD_INT 1
79844: PUSH
79845: LD_INT 4
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 0
79854: PUSH
79855: LD_INT 4
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: LD_INT 1
79864: NEG
79865: PUSH
79866: LD_INT 3
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 1
79875: PUSH
79876: LD_INT 5
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: PUSH
79883: LD_INT 0
79885: PUSH
79886: LD_INT 5
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: LD_INT 1
79895: NEG
79896: PUSH
79897: LD_INT 4
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: LD_INT 1
79906: PUSH
79907: LD_INT 6
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: PUSH
79914: LD_INT 0
79916: PUSH
79917: LD_INT 6
79919: PUSH
79920: EMPTY
79921: LIST
79922: LIST
79923: PUSH
79924: LD_INT 1
79926: NEG
79927: PUSH
79928: LD_INT 5
79930: PUSH
79931: EMPTY
79932: LIST
79933: LIST
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: LIST
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: LIST
79944: LIST
79945: LIST
79946: LIST
79947: LIST
79948: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79949: LD_ADDR_VAR 0 33
79953: PUSH
79954: LD_INT 2
79956: NEG
79957: PUSH
79958: LD_INT 1
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: PUSH
79965: LD_INT 3
79967: NEG
79968: PUSH
79969: LD_INT 0
79971: PUSH
79972: EMPTY
79973: LIST
79974: LIST
79975: PUSH
79976: LD_INT 3
79978: NEG
79979: PUSH
79980: LD_INT 1
79982: NEG
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: LD_INT 3
79990: NEG
79991: PUSH
79992: LD_INT 1
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: PUSH
79999: LD_INT 4
80001: NEG
80002: PUSH
80003: LD_INT 0
80005: PUSH
80006: EMPTY
80007: LIST
80008: LIST
80009: PUSH
80010: LD_INT 4
80012: NEG
80013: PUSH
80014: LD_INT 1
80016: NEG
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: PUSH
80022: LD_INT 4
80024: NEG
80025: PUSH
80026: LD_INT 1
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: PUSH
80033: LD_INT 5
80035: NEG
80036: PUSH
80037: LD_INT 0
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 5
80046: NEG
80047: PUSH
80048: LD_INT 1
80050: NEG
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 5
80058: NEG
80059: PUSH
80060: LD_INT 1
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 6
80069: NEG
80070: PUSH
80071: LD_INT 0
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 6
80080: NEG
80081: PUSH
80082: LD_INT 1
80084: NEG
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: EMPTY
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
80104: LD_ADDR_VAR 0 34
80108: PUSH
80109: LD_INT 2
80111: NEG
80112: PUSH
80113: LD_INT 3
80115: NEG
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: LD_INT 3
80123: NEG
80124: PUSH
80125: LD_INT 2
80127: NEG
80128: PUSH
80129: EMPTY
80130: LIST
80131: LIST
80132: PUSH
80133: LD_INT 3
80135: NEG
80136: PUSH
80137: LD_INT 3
80139: NEG
80140: PUSH
80141: EMPTY
80142: LIST
80143: LIST
80144: PUSH
80145: LD_INT 3
80147: NEG
80148: PUSH
80149: LD_INT 4
80151: NEG
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: PUSH
80157: LD_INT 4
80159: NEG
80160: PUSH
80161: LD_INT 3
80163: NEG
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: LD_INT 4
80171: NEG
80172: PUSH
80173: LD_INT 4
80175: NEG
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 4
80183: NEG
80184: PUSH
80185: LD_INT 5
80187: NEG
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 5
80195: NEG
80196: PUSH
80197: LD_INT 4
80199: NEG
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 5
80207: NEG
80208: PUSH
80209: LD_INT 5
80211: NEG
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 5
80219: NEG
80220: PUSH
80221: LD_INT 6
80223: NEG
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 6
80231: NEG
80232: PUSH
80233: LD_INT 5
80235: NEG
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: LD_INT 6
80243: NEG
80244: PUSH
80245: LD_INT 6
80247: NEG
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: EMPTY
80254: LIST
80255: LIST
80256: LIST
80257: LIST
80258: LIST
80259: LIST
80260: LIST
80261: LIST
80262: LIST
80263: LIST
80264: LIST
80265: LIST
80266: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
80267: LD_ADDR_VAR 0 41
80271: PUSH
80272: LD_INT 0
80274: PUSH
80275: LD_INT 2
80277: NEG
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 1
80285: NEG
80286: PUSH
80287: LD_INT 3
80289: NEG
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PUSH
80295: LD_INT 1
80297: PUSH
80298: LD_INT 2
80300: NEG
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: LIST
80310: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
80311: LD_ADDR_VAR 0 42
80315: PUSH
80316: LD_INT 2
80318: PUSH
80319: LD_INT 0
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: PUSH
80326: LD_INT 2
80328: PUSH
80329: LD_INT 1
80331: NEG
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: PUSH
80337: LD_INT 3
80339: PUSH
80340: LD_INT 1
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: LIST
80351: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
80352: LD_ADDR_VAR 0 43
80356: PUSH
80357: LD_INT 2
80359: PUSH
80360: LD_INT 2
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 3
80369: PUSH
80370: LD_INT 2
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: PUSH
80377: LD_INT 2
80379: PUSH
80380: LD_INT 3
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: LIST
80391: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
80392: LD_ADDR_VAR 0 44
80396: PUSH
80397: LD_INT 0
80399: PUSH
80400: LD_INT 2
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: PUSH
80407: LD_INT 1
80409: PUSH
80410: LD_INT 3
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 1
80419: NEG
80420: PUSH
80421: LD_INT 2
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: LIST
80432: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80433: LD_ADDR_VAR 0 45
80437: PUSH
80438: LD_INT 2
80440: NEG
80441: PUSH
80442: LD_INT 0
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: LD_INT 2
80451: NEG
80452: PUSH
80453: LD_INT 1
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: PUSH
80460: LD_INT 3
80462: NEG
80463: PUSH
80464: LD_INT 1
80466: NEG
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: EMPTY
80473: LIST
80474: LIST
80475: LIST
80476: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
80477: LD_ADDR_VAR 0 46
80481: PUSH
80482: LD_INT 2
80484: NEG
80485: PUSH
80486: LD_INT 2
80488: NEG
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PUSH
80494: LD_INT 2
80496: NEG
80497: PUSH
80498: LD_INT 3
80500: NEG
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 3
80508: NEG
80509: PUSH
80510: LD_INT 2
80512: NEG
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: LIST
80522: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
80523: LD_ADDR_VAR 0 47
80527: PUSH
80528: LD_INT 2
80530: NEG
80531: PUSH
80532: LD_INT 3
80534: NEG
80535: PUSH
80536: EMPTY
80537: LIST
80538: LIST
80539: PUSH
80540: LD_INT 1
80542: NEG
80543: PUSH
80544: LD_INT 3
80546: NEG
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80556: LD_ADDR_VAR 0 48
80560: PUSH
80561: LD_INT 1
80563: PUSH
80564: LD_INT 2
80566: NEG
80567: PUSH
80568: EMPTY
80569: LIST
80570: LIST
80571: PUSH
80572: LD_INT 2
80574: PUSH
80575: LD_INT 1
80577: NEG
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: PUSH
80583: EMPTY
80584: LIST
80585: LIST
80586: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
80587: LD_ADDR_VAR 0 49
80591: PUSH
80592: LD_INT 3
80594: PUSH
80595: LD_INT 1
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 3
80604: PUSH
80605: LD_INT 2
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
80616: LD_ADDR_VAR 0 50
80620: PUSH
80621: LD_INT 2
80623: PUSH
80624: LD_INT 3
80626: PUSH
80627: EMPTY
80628: LIST
80629: LIST
80630: PUSH
80631: LD_INT 1
80633: PUSH
80634: LD_INT 3
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
80645: LD_ADDR_VAR 0 51
80649: PUSH
80650: LD_INT 1
80652: NEG
80653: PUSH
80654: LD_INT 2
80656: PUSH
80657: EMPTY
80658: LIST
80659: LIST
80660: PUSH
80661: LD_INT 2
80663: NEG
80664: PUSH
80665: LD_INT 1
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
80676: LD_ADDR_VAR 0 52
80680: PUSH
80681: LD_INT 3
80683: NEG
80684: PUSH
80685: LD_INT 1
80687: NEG
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_INT 3
80695: NEG
80696: PUSH
80697: LD_INT 2
80699: NEG
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80709: LD_ADDR_VAR 0 53
80713: PUSH
80714: LD_INT 1
80716: NEG
80717: PUSH
80718: LD_INT 3
80720: NEG
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 0
80728: PUSH
80729: LD_INT 3
80731: NEG
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PUSH
80737: LD_INT 1
80739: PUSH
80740: LD_INT 2
80742: NEG
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: LIST
80752: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80753: LD_ADDR_VAR 0 54
80757: PUSH
80758: LD_INT 2
80760: PUSH
80761: LD_INT 1
80763: NEG
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 3
80771: PUSH
80772: LD_INT 0
80774: PUSH
80775: EMPTY
80776: LIST
80777: LIST
80778: PUSH
80779: LD_INT 3
80781: PUSH
80782: LD_INT 1
80784: PUSH
80785: EMPTY
80786: LIST
80787: LIST
80788: PUSH
80789: EMPTY
80790: LIST
80791: LIST
80792: LIST
80793: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80794: LD_ADDR_VAR 0 55
80798: PUSH
80799: LD_INT 3
80801: PUSH
80802: LD_INT 2
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PUSH
80809: LD_INT 3
80811: PUSH
80812: LD_INT 3
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 2
80821: PUSH
80822: LD_INT 3
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: EMPTY
80830: LIST
80831: LIST
80832: LIST
80833: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80834: LD_ADDR_VAR 0 56
80838: PUSH
80839: LD_INT 1
80841: PUSH
80842: LD_INT 3
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: LD_INT 0
80851: PUSH
80852: LD_INT 3
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: LD_INT 1
80861: NEG
80862: PUSH
80863: LD_INT 2
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: LIST
80874: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80875: LD_ADDR_VAR 0 57
80879: PUSH
80880: LD_INT 2
80882: NEG
80883: PUSH
80884: LD_INT 1
80886: PUSH
80887: EMPTY
80888: LIST
80889: LIST
80890: PUSH
80891: LD_INT 3
80893: NEG
80894: PUSH
80895: LD_INT 0
80897: PUSH
80898: EMPTY
80899: LIST
80900: LIST
80901: PUSH
80902: LD_INT 3
80904: NEG
80905: PUSH
80906: LD_INT 1
80908: NEG
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: LIST
80918: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80919: LD_ADDR_VAR 0 58
80923: PUSH
80924: LD_INT 2
80926: NEG
80927: PUSH
80928: LD_INT 3
80930: NEG
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PUSH
80936: LD_INT 3
80938: NEG
80939: PUSH
80940: LD_INT 2
80942: NEG
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 3
80950: NEG
80951: PUSH
80952: LD_INT 3
80954: NEG
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: EMPTY
80961: LIST
80962: LIST
80963: LIST
80964: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80965: LD_ADDR_VAR 0 59
80969: PUSH
80970: LD_INT 1
80972: NEG
80973: PUSH
80974: LD_INT 2
80976: NEG
80977: PUSH
80978: EMPTY
80979: LIST
80980: LIST
80981: PUSH
80982: LD_INT 0
80984: PUSH
80985: LD_INT 2
80987: NEG
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: LD_INT 1
80995: PUSH
80996: LD_INT 1
80998: NEG
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: LIST
81008: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
81009: LD_ADDR_VAR 0 60
81013: PUSH
81014: LD_INT 1
81016: PUSH
81017: LD_INT 1
81019: NEG
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: PUSH
81025: LD_INT 2
81027: PUSH
81028: LD_INT 0
81030: PUSH
81031: EMPTY
81032: LIST
81033: LIST
81034: PUSH
81035: LD_INT 2
81037: PUSH
81038: LD_INT 1
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: LIST
81049: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
81050: LD_ADDR_VAR 0 61
81054: PUSH
81055: LD_INT 2
81057: PUSH
81058: LD_INT 1
81060: PUSH
81061: EMPTY
81062: LIST
81063: LIST
81064: PUSH
81065: LD_INT 2
81067: PUSH
81068: LD_INT 2
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: PUSH
81075: LD_INT 1
81077: PUSH
81078: LD_INT 2
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: PUSH
81085: EMPTY
81086: LIST
81087: LIST
81088: LIST
81089: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
81090: LD_ADDR_VAR 0 62
81094: PUSH
81095: LD_INT 1
81097: PUSH
81098: LD_INT 2
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 0
81107: PUSH
81108: LD_INT 2
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: LD_INT 1
81117: NEG
81118: PUSH
81119: LD_INT 1
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: LIST
81130: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
81131: LD_ADDR_VAR 0 63
81135: PUSH
81136: LD_INT 1
81138: NEG
81139: PUSH
81140: LD_INT 1
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PUSH
81147: LD_INT 2
81149: NEG
81150: PUSH
81151: LD_INT 0
81153: PUSH
81154: EMPTY
81155: LIST
81156: LIST
81157: PUSH
81158: LD_INT 2
81160: NEG
81161: PUSH
81162: LD_INT 1
81164: NEG
81165: PUSH
81166: EMPTY
81167: LIST
81168: LIST
81169: PUSH
81170: EMPTY
81171: LIST
81172: LIST
81173: LIST
81174: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81175: LD_ADDR_VAR 0 64
81179: PUSH
81180: LD_INT 1
81182: NEG
81183: PUSH
81184: LD_INT 2
81186: NEG
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: LD_INT 2
81194: NEG
81195: PUSH
81196: LD_INT 1
81198: NEG
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 2
81206: NEG
81207: PUSH
81208: LD_INT 2
81210: NEG
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: LIST
81220: ST_TO_ADDR
// end ; 2 :
81221: GO 84487
81223: LD_INT 2
81225: DOUBLE
81226: EQUAL
81227: IFTRUE 81231
81229: GO 84486
81231: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
81232: LD_ADDR_VAR 0 29
81236: PUSH
81237: LD_INT 4
81239: PUSH
81240: LD_INT 0
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 4
81249: PUSH
81250: LD_INT 1
81252: NEG
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 5
81260: PUSH
81261: LD_INT 0
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 5
81270: PUSH
81271: LD_INT 1
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 4
81280: PUSH
81281: LD_INT 1
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 3
81290: PUSH
81291: LD_INT 0
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: PUSH
81298: LD_INT 3
81300: PUSH
81301: LD_INT 1
81303: NEG
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 3
81311: PUSH
81312: LD_INT 2
81314: NEG
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 5
81322: PUSH
81323: LD_INT 2
81325: PUSH
81326: EMPTY
81327: LIST
81328: LIST
81329: PUSH
81330: LD_INT 3
81332: PUSH
81333: LD_INT 3
81335: PUSH
81336: EMPTY
81337: LIST
81338: LIST
81339: PUSH
81340: LD_INT 3
81342: PUSH
81343: LD_INT 2
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: PUSH
81350: LD_INT 4
81352: PUSH
81353: LD_INT 3
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 4
81362: PUSH
81363: LD_INT 4
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 3
81372: PUSH
81373: LD_INT 4
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 2
81382: PUSH
81383: LD_INT 3
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 2
81392: PUSH
81393: LD_INT 2
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: PUSH
81400: LD_INT 4
81402: PUSH
81403: LD_INT 2
81405: PUSH
81406: EMPTY
81407: LIST
81408: LIST
81409: PUSH
81410: LD_INT 2
81412: PUSH
81413: LD_INT 4
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 0
81422: PUSH
81423: LD_INT 4
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 0
81432: PUSH
81433: LD_INT 3
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PUSH
81440: LD_INT 1
81442: PUSH
81443: LD_INT 4
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 1
81452: PUSH
81453: LD_INT 5
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 0
81462: PUSH
81463: LD_INT 5
81465: PUSH
81466: EMPTY
81467: LIST
81468: LIST
81469: PUSH
81470: LD_INT 1
81472: NEG
81473: PUSH
81474: LD_INT 4
81476: PUSH
81477: EMPTY
81478: LIST
81479: LIST
81480: PUSH
81481: LD_INT 1
81483: NEG
81484: PUSH
81485: LD_INT 3
81487: PUSH
81488: EMPTY
81489: LIST
81490: LIST
81491: PUSH
81492: LD_INT 2
81494: PUSH
81495: LD_INT 5
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 2
81504: NEG
81505: PUSH
81506: LD_INT 3
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_INT 3
81515: NEG
81516: PUSH
81517: LD_INT 0
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 3
81526: NEG
81527: PUSH
81528: LD_INT 1
81530: NEG
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 2
81538: NEG
81539: PUSH
81540: LD_INT 0
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 2
81549: NEG
81550: PUSH
81551: LD_INT 1
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 3
81560: NEG
81561: PUSH
81562: LD_INT 1
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 4
81571: NEG
81572: PUSH
81573: LD_INT 0
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: PUSH
81580: LD_INT 4
81582: NEG
81583: PUSH
81584: LD_INT 1
81586: NEG
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: LD_INT 4
81594: NEG
81595: PUSH
81596: LD_INT 2
81598: NEG
81599: PUSH
81600: EMPTY
81601: LIST
81602: LIST
81603: PUSH
81604: LD_INT 2
81606: NEG
81607: PUSH
81608: LD_INT 2
81610: PUSH
81611: EMPTY
81612: LIST
81613: LIST
81614: PUSH
81615: LD_INT 4
81617: NEG
81618: PUSH
81619: LD_INT 4
81621: NEG
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 4
81629: NEG
81630: PUSH
81631: LD_INT 5
81633: NEG
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 3
81641: NEG
81642: PUSH
81643: LD_INT 4
81645: NEG
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: PUSH
81651: LD_INT 3
81653: NEG
81654: PUSH
81655: LD_INT 3
81657: NEG
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 4
81665: NEG
81666: PUSH
81667: LD_INT 3
81669: NEG
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PUSH
81675: LD_INT 5
81677: NEG
81678: PUSH
81679: LD_INT 4
81681: NEG
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: LD_INT 5
81689: NEG
81690: PUSH
81691: LD_INT 5
81693: NEG
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: LD_INT 3
81701: NEG
81702: PUSH
81703: LD_INT 5
81705: NEG
81706: PUSH
81707: EMPTY
81708: LIST
81709: LIST
81710: PUSH
81711: LD_INT 5
81713: NEG
81714: PUSH
81715: LD_INT 3
81717: NEG
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: LIST
81752: LIST
81753: LIST
81754: LIST
81755: LIST
81756: LIST
81757: LIST
81758: LIST
81759: LIST
81760: LIST
81761: LIST
81762: LIST
81763: LIST
81764: LIST
81765: LIST
81766: LIST
81767: LIST
81768: LIST
81769: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
81770: LD_ADDR_VAR 0 30
81774: PUSH
81775: LD_INT 4
81777: PUSH
81778: LD_INT 4
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 4
81787: PUSH
81788: LD_INT 3
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 5
81797: PUSH
81798: LD_INT 4
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 5
81807: PUSH
81808: LD_INT 5
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: PUSH
81815: LD_INT 4
81817: PUSH
81818: LD_INT 5
81820: PUSH
81821: EMPTY
81822: LIST
81823: LIST
81824: PUSH
81825: LD_INT 3
81827: PUSH
81828: LD_INT 4
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 3
81837: PUSH
81838: LD_INT 3
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 5
81847: PUSH
81848: LD_INT 3
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 3
81857: PUSH
81858: LD_INT 5
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 0
81867: PUSH
81868: LD_INT 3
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 0
81877: PUSH
81878: LD_INT 2
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PUSH
81885: LD_INT 1
81887: PUSH
81888: LD_INT 3
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: PUSH
81895: LD_INT 1
81897: PUSH
81898: LD_INT 4
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: PUSH
81905: LD_INT 0
81907: PUSH
81908: LD_INT 4
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 1
81917: NEG
81918: PUSH
81919: LD_INT 3
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 1
81928: NEG
81929: PUSH
81930: LD_INT 2
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 2
81939: PUSH
81940: LD_INT 4
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 2
81949: NEG
81950: PUSH
81951: LD_INT 2
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 4
81960: NEG
81961: PUSH
81962: LD_INT 0
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 4
81971: NEG
81972: PUSH
81973: LD_INT 1
81975: NEG
81976: PUSH
81977: EMPTY
81978: LIST
81979: LIST
81980: PUSH
81981: LD_INT 3
81983: NEG
81984: PUSH
81985: LD_INT 0
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: PUSH
81992: LD_INT 3
81994: NEG
81995: PUSH
81996: LD_INT 1
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: LD_INT 4
82005: NEG
82006: PUSH
82007: LD_INT 1
82009: PUSH
82010: EMPTY
82011: LIST
82012: LIST
82013: PUSH
82014: LD_INT 5
82016: NEG
82017: PUSH
82018: LD_INT 0
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PUSH
82025: LD_INT 5
82027: NEG
82028: PUSH
82029: LD_INT 1
82031: NEG
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 5
82039: NEG
82040: PUSH
82041: LD_INT 2
82043: NEG
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 3
82051: NEG
82052: PUSH
82053: LD_INT 2
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 3
82062: NEG
82063: PUSH
82064: LD_INT 3
82066: NEG
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: PUSH
82072: LD_INT 3
82074: NEG
82075: PUSH
82076: LD_INT 4
82078: NEG
82079: PUSH
82080: EMPTY
82081: LIST
82082: LIST
82083: PUSH
82084: LD_INT 2
82086: NEG
82087: PUSH
82088: LD_INT 3
82090: NEG
82091: PUSH
82092: EMPTY
82093: LIST
82094: LIST
82095: PUSH
82096: LD_INT 2
82098: NEG
82099: PUSH
82100: LD_INT 2
82102: NEG
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 3
82110: NEG
82111: PUSH
82112: LD_INT 2
82114: NEG
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 4
82122: NEG
82123: PUSH
82124: LD_INT 3
82126: NEG
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PUSH
82132: LD_INT 4
82134: NEG
82135: PUSH
82136: LD_INT 4
82138: NEG
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PUSH
82144: LD_INT 2
82146: NEG
82147: PUSH
82148: LD_INT 4
82150: NEG
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 4
82158: NEG
82159: PUSH
82160: LD_INT 2
82162: NEG
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 0
82170: PUSH
82171: LD_INT 4
82173: NEG
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 0
82181: PUSH
82182: LD_INT 5
82184: NEG
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 1
82192: PUSH
82193: LD_INT 4
82195: NEG
82196: PUSH
82197: EMPTY
82198: LIST
82199: LIST
82200: PUSH
82201: LD_INT 1
82203: PUSH
82204: LD_INT 3
82206: NEG
82207: PUSH
82208: EMPTY
82209: LIST
82210: LIST
82211: PUSH
82212: LD_INT 0
82214: PUSH
82215: LD_INT 3
82217: NEG
82218: PUSH
82219: EMPTY
82220: LIST
82221: LIST
82222: PUSH
82223: LD_INT 1
82225: NEG
82226: PUSH
82227: LD_INT 4
82229: NEG
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: PUSH
82235: LD_INT 1
82237: NEG
82238: PUSH
82239: LD_INT 5
82241: NEG
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: PUSH
82247: LD_INT 2
82249: PUSH
82250: LD_INT 3
82252: NEG
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 2
82260: NEG
82261: PUSH
82262: LD_INT 5
82264: NEG
82265: PUSH
82266: EMPTY
82267: LIST
82268: LIST
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: LIST
82274: LIST
82275: LIST
82276: LIST
82277: LIST
82278: LIST
82279: LIST
82280: LIST
82281: LIST
82282: LIST
82283: LIST
82284: LIST
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: LIST
82293: LIST
82294: LIST
82295: LIST
82296: LIST
82297: LIST
82298: LIST
82299: LIST
82300: LIST
82301: LIST
82302: LIST
82303: LIST
82304: LIST
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
82317: LD_ADDR_VAR 0 31
82321: PUSH
82322: LD_INT 0
82324: PUSH
82325: LD_INT 4
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 0
82334: PUSH
82335: LD_INT 3
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 1
82344: PUSH
82345: LD_INT 4
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: LD_INT 1
82354: PUSH
82355: LD_INT 5
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 0
82364: PUSH
82365: LD_INT 5
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 1
82374: NEG
82375: PUSH
82376: LD_INT 4
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 1
82385: NEG
82386: PUSH
82387: LD_INT 3
82389: PUSH
82390: EMPTY
82391: LIST
82392: LIST
82393: PUSH
82394: LD_INT 2
82396: PUSH
82397: LD_INT 5
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: PUSH
82404: LD_INT 2
82406: NEG
82407: PUSH
82408: LD_INT 3
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 3
82417: NEG
82418: PUSH
82419: LD_INT 0
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 3
82428: NEG
82429: PUSH
82430: LD_INT 1
82432: NEG
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 2
82440: NEG
82441: PUSH
82442: LD_INT 0
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 2
82451: NEG
82452: PUSH
82453: LD_INT 1
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 3
82462: NEG
82463: PUSH
82464: LD_INT 1
82466: PUSH
82467: EMPTY
82468: LIST
82469: LIST
82470: PUSH
82471: LD_INT 4
82473: NEG
82474: PUSH
82475: LD_INT 0
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 4
82484: NEG
82485: PUSH
82486: LD_INT 1
82488: NEG
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 4
82496: NEG
82497: PUSH
82498: LD_INT 2
82500: NEG
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 2
82508: NEG
82509: PUSH
82510: LD_INT 2
82512: PUSH
82513: EMPTY
82514: LIST
82515: LIST
82516: PUSH
82517: LD_INT 4
82519: NEG
82520: PUSH
82521: LD_INT 4
82523: NEG
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PUSH
82529: LD_INT 4
82531: NEG
82532: PUSH
82533: LD_INT 5
82535: NEG
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 3
82543: NEG
82544: PUSH
82545: LD_INT 4
82547: NEG
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: LD_INT 3
82555: NEG
82556: PUSH
82557: LD_INT 3
82559: NEG
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 4
82567: NEG
82568: PUSH
82569: LD_INT 3
82571: NEG
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: PUSH
82577: LD_INT 5
82579: NEG
82580: PUSH
82581: LD_INT 4
82583: NEG
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 5
82591: NEG
82592: PUSH
82593: LD_INT 5
82595: NEG
82596: PUSH
82597: EMPTY
82598: LIST
82599: LIST
82600: PUSH
82601: LD_INT 3
82603: NEG
82604: PUSH
82605: LD_INT 5
82607: NEG
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 5
82615: NEG
82616: PUSH
82617: LD_INT 3
82619: NEG
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 0
82627: PUSH
82628: LD_INT 3
82630: NEG
82631: PUSH
82632: EMPTY
82633: LIST
82634: LIST
82635: PUSH
82636: LD_INT 0
82638: PUSH
82639: LD_INT 4
82641: NEG
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 1
82649: PUSH
82650: LD_INT 3
82652: NEG
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 1
82660: PUSH
82661: LD_INT 2
82663: NEG
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: LD_INT 0
82671: PUSH
82672: LD_INT 2
82674: NEG
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 1
82682: NEG
82683: PUSH
82684: LD_INT 3
82686: NEG
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 1
82694: NEG
82695: PUSH
82696: LD_INT 4
82698: NEG
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 2
82706: PUSH
82707: LD_INT 2
82709: NEG
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 2
82717: NEG
82718: PUSH
82719: LD_INT 4
82721: NEG
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 4
82729: PUSH
82730: LD_INT 0
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 4
82739: PUSH
82740: LD_INT 1
82742: NEG
82743: PUSH
82744: EMPTY
82745: LIST
82746: LIST
82747: PUSH
82748: LD_INT 5
82750: PUSH
82751: LD_INT 0
82753: PUSH
82754: EMPTY
82755: LIST
82756: LIST
82757: PUSH
82758: LD_INT 5
82760: PUSH
82761: LD_INT 1
82763: PUSH
82764: EMPTY
82765: LIST
82766: LIST
82767: PUSH
82768: LD_INT 4
82770: PUSH
82771: LD_INT 1
82773: PUSH
82774: EMPTY
82775: LIST
82776: LIST
82777: PUSH
82778: LD_INT 3
82780: PUSH
82781: LD_INT 0
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 3
82790: PUSH
82791: LD_INT 1
82793: NEG
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 3
82801: PUSH
82802: LD_INT 2
82804: NEG
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 5
82812: PUSH
82813: LD_INT 2
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: PUSH
82820: EMPTY
82821: LIST
82822: LIST
82823: LIST
82824: LIST
82825: LIST
82826: LIST
82827: LIST
82828: LIST
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: LIST
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: LIST
82858: LIST
82859: LIST
82860: LIST
82861: LIST
82862: LIST
82863: LIST
82864: LIST
82865: LIST
82866: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82867: LD_ADDR_VAR 0 32
82871: PUSH
82872: LD_INT 4
82874: NEG
82875: PUSH
82876: LD_INT 0
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: PUSH
82883: LD_INT 4
82885: NEG
82886: PUSH
82887: LD_INT 1
82889: NEG
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: LD_INT 3
82897: NEG
82898: PUSH
82899: LD_INT 0
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: LD_INT 3
82908: NEG
82909: PUSH
82910: LD_INT 1
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 4
82919: NEG
82920: PUSH
82921: LD_INT 1
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 5
82930: NEG
82931: PUSH
82932: LD_INT 0
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 5
82941: NEG
82942: PUSH
82943: LD_INT 1
82945: NEG
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: LD_INT 5
82953: NEG
82954: PUSH
82955: LD_INT 2
82957: NEG
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 3
82965: NEG
82966: PUSH
82967: LD_INT 2
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 3
82976: NEG
82977: PUSH
82978: LD_INT 3
82980: NEG
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: LD_INT 3
82988: NEG
82989: PUSH
82990: LD_INT 4
82992: NEG
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: LD_INT 2
83000: NEG
83001: PUSH
83002: LD_INT 3
83004: NEG
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 2
83012: NEG
83013: PUSH
83014: LD_INT 2
83016: NEG
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 3
83024: NEG
83025: PUSH
83026: LD_INT 2
83028: NEG
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: PUSH
83034: LD_INT 4
83036: NEG
83037: PUSH
83038: LD_INT 3
83040: NEG
83041: PUSH
83042: EMPTY
83043: LIST
83044: LIST
83045: PUSH
83046: LD_INT 4
83048: NEG
83049: PUSH
83050: LD_INT 4
83052: NEG
83053: PUSH
83054: EMPTY
83055: LIST
83056: LIST
83057: PUSH
83058: LD_INT 2
83060: NEG
83061: PUSH
83062: LD_INT 4
83064: NEG
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 4
83072: NEG
83073: PUSH
83074: LD_INT 2
83076: NEG
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 0
83084: PUSH
83085: LD_INT 4
83087: NEG
83088: PUSH
83089: EMPTY
83090: LIST
83091: LIST
83092: PUSH
83093: LD_INT 0
83095: PUSH
83096: LD_INT 5
83098: NEG
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: PUSH
83104: LD_INT 1
83106: PUSH
83107: LD_INT 4
83109: NEG
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: PUSH
83115: LD_INT 1
83117: PUSH
83118: LD_INT 3
83120: NEG
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: PUSH
83126: LD_INT 0
83128: PUSH
83129: LD_INT 3
83131: NEG
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: PUSH
83137: LD_INT 1
83139: NEG
83140: PUSH
83141: LD_INT 4
83143: NEG
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 1
83151: NEG
83152: PUSH
83153: LD_INT 5
83155: NEG
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: PUSH
83161: LD_INT 2
83163: PUSH
83164: LD_INT 3
83166: NEG
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 2
83174: NEG
83175: PUSH
83176: LD_INT 5
83178: NEG
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: PUSH
83184: LD_INT 3
83186: PUSH
83187: LD_INT 0
83189: PUSH
83190: EMPTY
83191: LIST
83192: LIST
83193: PUSH
83194: LD_INT 3
83196: PUSH
83197: LD_INT 1
83199: NEG
83200: PUSH
83201: EMPTY
83202: LIST
83203: LIST
83204: PUSH
83205: LD_INT 4
83207: PUSH
83208: LD_INT 0
83210: PUSH
83211: EMPTY
83212: LIST
83213: LIST
83214: PUSH
83215: LD_INT 4
83217: PUSH
83218: LD_INT 1
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: PUSH
83225: LD_INT 3
83227: PUSH
83228: LD_INT 1
83230: PUSH
83231: EMPTY
83232: LIST
83233: LIST
83234: PUSH
83235: LD_INT 2
83237: PUSH
83238: LD_INT 0
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 2
83247: PUSH
83248: LD_INT 1
83250: NEG
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: PUSH
83256: LD_INT 2
83258: PUSH
83259: LD_INT 2
83261: NEG
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 4
83269: PUSH
83270: LD_INT 2
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 4
83279: PUSH
83280: LD_INT 4
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 4
83289: PUSH
83290: LD_INT 3
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: PUSH
83297: LD_INT 5
83299: PUSH
83300: LD_INT 4
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 5
83309: PUSH
83310: LD_INT 5
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 4
83319: PUSH
83320: LD_INT 5
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 3
83329: PUSH
83330: LD_INT 4
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 3
83339: PUSH
83340: LD_INT 3
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 5
83349: PUSH
83350: LD_INT 3
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PUSH
83357: LD_INT 3
83359: PUSH
83360: LD_INT 5
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: LIST
83398: LIST
83399: LIST
83400: LIST
83401: LIST
83402: LIST
83403: LIST
83404: LIST
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: LIST
83412: LIST
83413: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
83414: LD_ADDR_VAR 0 33
83418: PUSH
83419: LD_INT 4
83421: NEG
83422: PUSH
83423: LD_INT 4
83425: NEG
83426: PUSH
83427: EMPTY
83428: LIST
83429: LIST
83430: PUSH
83431: LD_INT 4
83433: NEG
83434: PUSH
83435: LD_INT 5
83437: NEG
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 3
83445: NEG
83446: PUSH
83447: LD_INT 4
83449: NEG
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 3
83457: NEG
83458: PUSH
83459: LD_INT 3
83461: NEG
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PUSH
83467: LD_INT 4
83469: NEG
83470: PUSH
83471: LD_INT 3
83473: NEG
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 5
83481: NEG
83482: PUSH
83483: LD_INT 4
83485: NEG
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 5
83493: NEG
83494: PUSH
83495: LD_INT 5
83497: NEG
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PUSH
83503: LD_INT 3
83505: NEG
83506: PUSH
83507: LD_INT 5
83509: NEG
83510: PUSH
83511: EMPTY
83512: LIST
83513: LIST
83514: PUSH
83515: LD_INT 5
83517: NEG
83518: PUSH
83519: LD_INT 3
83521: NEG
83522: PUSH
83523: EMPTY
83524: LIST
83525: LIST
83526: PUSH
83527: LD_INT 0
83529: PUSH
83530: LD_INT 3
83532: NEG
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: LD_INT 0
83540: PUSH
83541: LD_INT 4
83543: NEG
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 1
83551: PUSH
83552: LD_INT 3
83554: NEG
83555: PUSH
83556: EMPTY
83557: LIST
83558: LIST
83559: PUSH
83560: LD_INT 1
83562: PUSH
83563: LD_INT 2
83565: NEG
83566: PUSH
83567: EMPTY
83568: LIST
83569: LIST
83570: PUSH
83571: LD_INT 0
83573: PUSH
83574: LD_INT 2
83576: NEG
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 1
83584: NEG
83585: PUSH
83586: LD_INT 3
83588: NEG
83589: PUSH
83590: EMPTY
83591: LIST
83592: LIST
83593: PUSH
83594: LD_INT 1
83596: NEG
83597: PUSH
83598: LD_INT 4
83600: NEG
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: PUSH
83606: LD_INT 2
83608: PUSH
83609: LD_INT 2
83611: NEG
83612: PUSH
83613: EMPTY
83614: LIST
83615: LIST
83616: PUSH
83617: LD_INT 2
83619: NEG
83620: PUSH
83621: LD_INT 4
83623: NEG
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: PUSH
83629: LD_INT 4
83631: PUSH
83632: LD_INT 0
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PUSH
83639: LD_INT 4
83641: PUSH
83642: LD_INT 1
83644: NEG
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: PUSH
83650: LD_INT 5
83652: PUSH
83653: LD_INT 0
83655: PUSH
83656: EMPTY
83657: LIST
83658: LIST
83659: PUSH
83660: LD_INT 5
83662: PUSH
83663: LD_INT 1
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: LD_INT 4
83672: PUSH
83673: LD_INT 1
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 3
83682: PUSH
83683: LD_INT 0
83685: PUSH
83686: EMPTY
83687: LIST
83688: LIST
83689: PUSH
83690: LD_INT 3
83692: PUSH
83693: LD_INT 1
83695: NEG
83696: PUSH
83697: EMPTY
83698: LIST
83699: LIST
83700: PUSH
83701: LD_INT 3
83703: PUSH
83704: LD_INT 2
83706: NEG
83707: PUSH
83708: EMPTY
83709: LIST
83710: LIST
83711: PUSH
83712: LD_INT 5
83714: PUSH
83715: LD_INT 2
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PUSH
83722: LD_INT 3
83724: PUSH
83725: LD_INT 3
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PUSH
83732: LD_INT 3
83734: PUSH
83735: LD_INT 2
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: PUSH
83742: LD_INT 4
83744: PUSH
83745: LD_INT 3
83747: PUSH
83748: EMPTY
83749: LIST
83750: LIST
83751: PUSH
83752: LD_INT 4
83754: PUSH
83755: LD_INT 4
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 3
83764: PUSH
83765: LD_INT 4
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 2
83774: PUSH
83775: LD_INT 3
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 2
83784: PUSH
83785: LD_INT 2
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 4
83794: PUSH
83795: LD_INT 2
83797: PUSH
83798: EMPTY
83799: LIST
83800: LIST
83801: PUSH
83802: LD_INT 2
83804: PUSH
83805: LD_INT 4
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: PUSH
83812: LD_INT 0
83814: PUSH
83815: LD_INT 4
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: PUSH
83822: LD_INT 0
83824: PUSH
83825: LD_INT 3
83827: PUSH
83828: EMPTY
83829: LIST
83830: LIST
83831: PUSH
83832: LD_INT 1
83834: PUSH
83835: LD_INT 4
83837: PUSH
83838: EMPTY
83839: LIST
83840: LIST
83841: PUSH
83842: LD_INT 1
83844: PUSH
83845: LD_INT 5
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: PUSH
83852: LD_INT 0
83854: PUSH
83855: LD_INT 5
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: PUSH
83862: LD_INT 1
83864: NEG
83865: PUSH
83866: LD_INT 4
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: PUSH
83873: LD_INT 1
83875: NEG
83876: PUSH
83877: LD_INT 3
83879: PUSH
83880: EMPTY
83881: LIST
83882: LIST
83883: PUSH
83884: LD_INT 2
83886: PUSH
83887: LD_INT 5
83889: PUSH
83890: EMPTY
83891: LIST
83892: LIST
83893: PUSH
83894: LD_INT 2
83896: NEG
83897: PUSH
83898: LD_INT 3
83900: PUSH
83901: EMPTY
83902: LIST
83903: LIST
83904: PUSH
83905: EMPTY
83906: LIST
83907: LIST
83908: LIST
83909: LIST
83910: LIST
83911: LIST
83912: LIST
83913: LIST
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: LIST
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83952: LD_ADDR_VAR 0 34
83956: PUSH
83957: LD_INT 0
83959: PUSH
83960: LD_INT 4
83962: NEG
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: PUSH
83968: LD_INT 0
83970: PUSH
83971: LD_INT 5
83973: NEG
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PUSH
83979: LD_INT 1
83981: PUSH
83982: LD_INT 4
83984: NEG
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 1
83992: PUSH
83993: LD_INT 3
83995: NEG
83996: PUSH
83997: EMPTY
83998: LIST
83999: LIST
84000: PUSH
84001: LD_INT 0
84003: PUSH
84004: LD_INT 3
84006: NEG
84007: PUSH
84008: EMPTY
84009: LIST
84010: LIST
84011: PUSH
84012: LD_INT 1
84014: NEG
84015: PUSH
84016: LD_INT 4
84018: NEG
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: PUSH
84024: LD_INT 1
84026: NEG
84027: PUSH
84028: LD_INT 5
84030: NEG
84031: PUSH
84032: EMPTY
84033: LIST
84034: LIST
84035: PUSH
84036: LD_INT 2
84038: PUSH
84039: LD_INT 3
84041: NEG
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: PUSH
84047: LD_INT 2
84049: NEG
84050: PUSH
84051: LD_INT 5
84053: NEG
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: PUSH
84059: LD_INT 3
84061: PUSH
84062: LD_INT 0
84064: PUSH
84065: EMPTY
84066: LIST
84067: LIST
84068: PUSH
84069: LD_INT 3
84071: PUSH
84072: LD_INT 1
84074: NEG
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: LD_INT 4
84082: PUSH
84083: LD_INT 0
84085: PUSH
84086: EMPTY
84087: LIST
84088: LIST
84089: PUSH
84090: LD_INT 4
84092: PUSH
84093: LD_INT 1
84095: PUSH
84096: EMPTY
84097: LIST
84098: LIST
84099: PUSH
84100: LD_INT 3
84102: PUSH
84103: LD_INT 1
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: PUSH
84110: LD_INT 2
84112: PUSH
84113: LD_INT 0
84115: PUSH
84116: EMPTY
84117: LIST
84118: LIST
84119: PUSH
84120: LD_INT 2
84122: PUSH
84123: LD_INT 1
84125: NEG
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PUSH
84131: LD_INT 2
84133: PUSH
84134: LD_INT 2
84136: NEG
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PUSH
84142: LD_INT 4
84144: PUSH
84145: LD_INT 2
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 4
84154: PUSH
84155: LD_INT 4
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 4
84164: PUSH
84165: LD_INT 3
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: PUSH
84172: LD_INT 5
84174: PUSH
84175: LD_INT 4
84177: PUSH
84178: EMPTY
84179: LIST
84180: LIST
84181: PUSH
84182: LD_INT 5
84184: PUSH
84185: LD_INT 5
84187: PUSH
84188: EMPTY
84189: LIST
84190: LIST
84191: PUSH
84192: LD_INT 4
84194: PUSH
84195: LD_INT 5
84197: PUSH
84198: EMPTY
84199: LIST
84200: LIST
84201: PUSH
84202: LD_INT 3
84204: PUSH
84205: LD_INT 4
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: PUSH
84212: LD_INT 3
84214: PUSH
84215: LD_INT 3
84217: PUSH
84218: EMPTY
84219: LIST
84220: LIST
84221: PUSH
84222: LD_INT 5
84224: PUSH
84225: LD_INT 3
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 3
84234: PUSH
84235: LD_INT 5
84237: PUSH
84238: EMPTY
84239: LIST
84240: LIST
84241: PUSH
84242: LD_INT 0
84244: PUSH
84245: LD_INT 3
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: LD_INT 0
84254: PUSH
84255: LD_INT 2
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 1
84264: PUSH
84265: LD_INT 3
84267: PUSH
84268: EMPTY
84269: LIST
84270: LIST
84271: PUSH
84272: LD_INT 1
84274: PUSH
84275: LD_INT 4
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 0
84284: PUSH
84285: LD_INT 4
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: LD_INT 1
84294: NEG
84295: PUSH
84296: LD_INT 3
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 1
84305: NEG
84306: PUSH
84307: LD_INT 2
84309: PUSH
84310: EMPTY
84311: LIST
84312: LIST
84313: PUSH
84314: LD_INT 2
84316: PUSH
84317: LD_INT 4
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: PUSH
84324: LD_INT 2
84326: NEG
84327: PUSH
84328: LD_INT 2
84330: PUSH
84331: EMPTY
84332: LIST
84333: LIST
84334: PUSH
84335: LD_INT 4
84337: NEG
84338: PUSH
84339: LD_INT 0
84341: PUSH
84342: EMPTY
84343: LIST
84344: LIST
84345: PUSH
84346: LD_INT 4
84348: NEG
84349: PUSH
84350: LD_INT 1
84352: NEG
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 3
84360: NEG
84361: PUSH
84362: LD_INT 0
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: PUSH
84369: LD_INT 3
84371: NEG
84372: PUSH
84373: LD_INT 1
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: LD_INT 4
84382: NEG
84383: PUSH
84384: LD_INT 1
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: PUSH
84391: LD_INT 5
84393: NEG
84394: PUSH
84395: LD_INT 0
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: PUSH
84402: LD_INT 5
84404: NEG
84405: PUSH
84406: LD_INT 1
84408: NEG
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PUSH
84414: LD_INT 5
84416: NEG
84417: PUSH
84418: LD_INT 2
84420: NEG
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 3
84428: NEG
84429: PUSH
84430: LD_INT 2
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: LIST
84443: LIST
84444: LIST
84445: LIST
84446: LIST
84447: LIST
84448: LIST
84449: LIST
84450: LIST
84451: LIST
84452: LIST
84453: LIST
84454: LIST
84455: LIST
84456: LIST
84457: LIST
84458: LIST
84459: LIST
84460: LIST
84461: LIST
84462: LIST
84463: LIST
84464: LIST
84465: LIST
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: ST_TO_ADDR
// end ; end ;
84484: GO 84487
84486: POP
// case btype of b_depot , b_warehouse :
84487: LD_VAR 0 1
84491: PUSH
84492: LD_INT 0
84494: DOUBLE
84495: EQUAL
84496: IFTRUE 84506
84498: LD_INT 1
84500: DOUBLE
84501: EQUAL
84502: IFTRUE 84506
84504: GO 84707
84506: POP
// case nation of nation_american :
84507: LD_VAR 0 5
84511: PUSH
84512: LD_INT 1
84514: DOUBLE
84515: EQUAL
84516: IFTRUE 84520
84518: GO 84576
84520: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
84521: LD_ADDR_VAR 0 9
84525: PUSH
84526: LD_VAR 0 11
84530: PUSH
84531: LD_VAR 0 12
84535: PUSH
84536: LD_VAR 0 13
84540: PUSH
84541: LD_VAR 0 14
84545: PUSH
84546: LD_VAR 0 15
84550: PUSH
84551: LD_VAR 0 16
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: LIST
84560: LIST
84561: LIST
84562: LIST
84563: PUSH
84564: LD_VAR 0 4
84568: PUSH
84569: LD_INT 1
84571: PLUS
84572: ARRAY
84573: ST_TO_ADDR
84574: GO 84705
84576: LD_INT 2
84578: DOUBLE
84579: EQUAL
84580: IFTRUE 84584
84582: GO 84640
84584: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
84585: LD_ADDR_VAR 0 9
84589: PUSH
84590: LD_VAR 0 17
84594: PUSH
84595: LD_VAR 0 18
84599: PUSH
84600: LD_VAR 0 19
84604: PUSH
84605: LD_VAR 0 20
84609: PUSH
84610: LD_VAR 0 21
84614: PUSH
84615: LD_VAR 0 22
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: LIST
84624: LIST
84625: LIST
84626: LIST
84627: PUSH
84628: LD_VAR 0 4
84632: PUSH
84633: LD_INT 1
84635: PLUS
84636: ARRAY
84637: ST_TO_ADDR
84638: GO 84705
84640: LD_INT 3
84642: DOUBLE
84643: EQUAL
84644: IFTRUE 84648
84646: GO 84704
84648: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
84649: LD_ADDR_VAR 0 9
84653: PUSH
84654: LD_VAR 0 23
84658: PUSH
84659: LD_VAR 0 24
84663: PUSH
84664: LD_VAR 0 25
84668: PUSH
84669: LD_VAR 0 26
84673: PUSH
84674: LD_VAR 0 27
84678: PUSH
84679: LD_VAR 0 28
84683: PUSH
84684: EMPTY
84685: LIST
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: LIST
84691: PUSH
84692: LD_VAR 0 4
84696: PUSH
84697: LD_INT 1
84699: PLUS
84700: ARRAY
84701: ST_TO_ADDR
84702: GO 84705
84704: POP
84705: GO 85260
84707: LD_INT 2
84709: DOUBLE
84710: EQUAL
84711: IFTRUE 84721
84713: LD_INT 3
84715: DOUBLE
84716: EQUAL
84717: IFTRUE 84721
84719: GO 84777
84721: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
84722: LD_ADDR_VAR 0 9
84726: PUSH
84727: LD_VAR 0 29
84731: PUSH
84732: LD_VAR 0 30
84736: PUSH
84737: LD_VAR 0 31
84741: PUSH
84742: LD_VAR 0 32
84746: PUSH
84747: LD_VAR 0 33
84751: PUSH
84752: LD_VAR 0 34
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: LIST
84764: PUSH
84765: LD_VAR 0 4
84769: PUSH
84770: LD_INT 1
84772: PLUS
84773: ARRAY
84774: ST_TO_ADDR
84775: GO 85260
84777: LD_INT 16
84779: DOUBLE
84780: EQUAL
84781: IFTRUE 84839
84783: LD_INT 17
84785: DOUBLE
84786: EQUAL
84787: IFTRUE 84839
84789: LD_INT 18
84791: DOUBLE
84792: EQUAL
84793: IFTRUE 84839
84795: LD_INT 19
84797: DOUBLE
84798: EQUAL
84799: IFTRUE 84839
84801: LD_INT 22
84803: DOUBLE
84804: EQUAL
84805: IFTRUE 84839
84807: LD_INT 20
84809: DOUBLE
84810: EQUAL
84811: IFTRUE 84839
84813: LD_INT 21
84815: DOUBLE
84816: EQUAL
84817: IFTRUE 84839
84819: LD_INT 23
84821: DOUBLE
84822: EQUAL
84823: IFTRUE 84839
84825: LD_INT 24
84827: DOUBLE
84828: EQUAL
84829: IFTRUE 84839
84831: LD_INT 25
84833: DOUBLE
84834: EQUAL
84835: IFTRUE 84839
84837: GO 84895
84839: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84840: LD_ADDR_VAR 0 9
84844: PUSH
84845: LD_VAR 0 35
84849: PUSH
84850: LD_VAR 0 36
84854: PUSH
84855: LD_VAR 0 37
84859: PUSH
84860: LD_VAR 0 38
84864: PUSH
84865: LD_VAR 0 39
84869: PUSH
84870: LD_VAR 0 40
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: PUSH
84883: LD_VAR 0 4
84887: PUSH
84888: LD_INT 1
84890: PLUS
84891: ARRAY
84892: ST_TO_ADDR
84893: GO 85260
84895: LD_INT 6
84897: DOUBLE
84898: EQUAL
84899: IFTRUE 84951
84901: LD_INT 7
84903: DOUBLE
84904: EQUAL
84905: IFTRUE 84951
84907: LD_INT 8
84909: DOUBLE
84910: EQUAL
84911: IFTRUE 84951
84913: LD_INT 13
84915: DOUBLE
84916: EQUAL
84917: IFTRUE 84951
84919: LD_INT 12
84921: DOUBLE
84922: EQUAL
84923: IFTRUE 84951
84925: LD_INT 15
84927: DOUBLE
84928: EQUAL
84929: IFTRUE 84951
84931: LD_INT 11
84933: DOUBLE
84934: EQUAL
84935: IFTRUE 84951
84937: LD_INT 14
84939: DOUBLE
84940: EQUAL
84941: IFTRUE 84951
84943: LD_INT 10
84945: DOUBLE
84946: EQUAL
84947: IFTRUE 84951
84949: GO 85007
84951: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84952: LD_ADDR_VAR 0 9
84956: PUSH
84957: LD_VAR 0 41
84961: PUSH
84962: LD_VAR 0 42
84966: PUSH
84967: LD_VAR 0 43
84971: PUSH
84972: LD_VAR 0 44
84976: PUSH
84977: LD_VAR 0 45
84981: PUSH
84982: LD_VAR 0 46
84986: PUSH
84987: EMPTY
84988: LIST
84989: LIST
84990: LIST
84991: LIST
84992: LIST
84993: LIST
84994: PUSH
84995: LD_VAR 0 4
84999: PUSH
85000: LD_INT 1
85002: PLUS
85003: ARRAY
85004: ST_TO_ADDR
85005: GO 85260
85007: LD_INT 36
85009: DOUBLE
85010: EQUAL
85011: IFTRUE 85015
85013: GO 85071
85015: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
85016: LD_ADDR_VAR 0 9
85020: PUSH
85021: LD_VAR 0 47
85025: PUSH
85026: LD_VAR 0 48
85030: PUSH
85031: LD_VAR 0 49
85035: PUSH
85036: LD_VAR 0 50
85040: PUSH
85041: LD_VAR 0 51
85045: PUSH
85046: LD_VAR 0 52
85050: PUSH
85051: EMPTY
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: PUSH
85059: LD_VAR 0 4
85063: PUSH
85064: LD_INT 1
85066: PLUS
85067: ARRAY
85068: ST_TO_ADDR
85069: GO 85260
85071: LD_INT 4
85073: DOUBLE
85074: EQUAL
85075: IFTRUE 85097
85077: LD_INT 5
85079: DOUBLE
85080: EQUAL
85081: IFTRUE 85097
85083: LD_INT 34
85085: DOUBLE
85086: EQUAL
85087: IFTRUE 85097
85089: LD_INT 37
85091: DOUBLE
85092: EQUAL
85093: IFTRUE 85097
85095: GO 85153
85097: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
85098: LD_ADDR_VAR 0 9
85102: PUSH
85103: LD_VAR 0 53
85107: PUSH
85108: LD_VAR 0 54
85112: PUSH
85113: LD_VAR 0 55
85117: PUSH
85118: LD_VAR 0 56
85122: PUSH
85123: LD_VAR 0 57
85127: PUSH
85128: LD_VAR 0 58
85132: PUSH
85133: EMPTY
85134: LIST
85135: LIST
85136: LIST
85137: LIST
85138: LIST
85139: LIST
85140: PUSH
85141: LD_VAR 0 4
85145: PUSH
85146: LD_INT 1
85148: PLUS
85149: ARRAY
85150: ST_TO_ADDR
85151: GO 85260
85153: LD_INT 31
85155: DOUBLE
85156: EQUAL
85157: IFTRUE 85203
85159: LD_INT 32
85161: DOUBLE
85162: EQUAL
85163: IFTRUE 85203
85165: LD_INT 33
85167: DOUBLE
85168: EQUAL
85169: IFTRUE 85203
85171: LD_INT 27
85173: DOUBLE
85174: EQUAL
85175: IFTRUE 85203
85177: LD_INT 26
85179: DOUBLE
85180: EQUAL
85181: IFTRUE 85203
85183: LD_INT 28
85185: DOUBLE
85186: EQUAL
85187: IFTRUE 85203
85189: LD_INT 29
85191: DOUBLE
85192: EQUAL
85193: IFTRUE 85203
85195: LD_INT 30
85197: DOUBLE
85198: EQUAL
85199: IFTRUE 85203
85201: GO 85259
85203: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
85204: LD_ADDR_VAR 0 9
85208: PUSH
85209: LD_VAR 0 59
85213: PUSH
85214: LD_VAR 0 60
85218: PUSH
85219: LD_VAR 0 61
85223: PUSH
85224: LD_VAR 0 62
85228: PUSH
85229: LD_VAR 0 63
85233: PUSH
85234: LD_VAR 0 64
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: LIST
85243: LIST
85244: LIST
85245: LIST
85246: PUSH
85247: LD_VAR 0 4
85251: PUSH
85252: LD_INT 1
85254: PLUS
85255: ARRAY
85256: ST_TO_ADDR
85257: GO 85260
85259: POP
// temp_list2 = [ ] ;
85260: LD_ADDR_VAR 0 10
85264: PUSH
85265: EMPTY
85266: ST_TO_ADDR
// for i in temp_list do
85267: LD_ADDR_VAR 0 8
85271: PUSH
85272: LD_VAR 0 9
85276: PUSH
85277: FOR_IN
85278: IFFALSE 85330
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
85280: LD_ADDR_VAR 0 10
85284: PUSH
85285: LD_VAR 0 10
85289: PUSH
85290: LD_VAR 0 8
85294: PUSH
85295: LD_INT 1
85297: ARRAY
85298: PUSH
85299: LD_VAR 0 2
85303: PLUS
85304: PUSH
85305: LD_VAR 0 8
85309: PUSH
85310: LD_INT 2
85312: ARRAY
85313: PUSH
85314: LD_VAR 0 3
85318: PLUS
85319: PUSH
85320: EMPTY
85321: LIST
85322: LIST
85323: PUSH
85324: EMPTY
85325: LIST
85326: ADD
85327: ST_TO_ADDR
85328: GO 85277
85330: POP
85331: POP
// result = temp_list2 ;
85332: LD_ADDR_VAR 0 7
85336: PUSH
85337: LD_VAR 0 10
85341: ST_TO_ADDR
// end ;
85342: LD_VAR 0 7
85346: RET
// export function EnemyInRange ( unit , dist ) ; begin
85347: LD_INT 0
85349: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
85350: LD_ADDR_VAR 0 3
85354: PUSH
85355: LD_VAR 0 1
85359: PPUSH
85360: CALL_OW 255
85364: PPUSH
85365: LD_VAR 0 1
85369: PPUSH
85370: CALL_OW 250
85374: PPUSH
85375: LD_VAR 0 1
85379: PPUSH
85380: CALL_OW 251
85384: PPUSH
85385: LD_VAR 0 2
85389: PPUSH
85390: CALL 58720 0 4
85394: PUSH
85395: LD_INT 4
85397: ARRAY
85398: ST_TO_ADDR
// end ;
85399: LD_VAR 0 3
85403: RET
// export function PlayerSeeMe ( unit ) ; begin
85404: LD_INT 0
85406: PPUSH
// result := See ( your_side , unit ) ;
85407: LD_ADDR_VAR 0 2
85411: PUSH
85412: LD_OWVAR 2
85416: PPUSH
85417: LD_VAR 0 1
85421: PPUSH
85422: CALL_OW 292
85426: ST_TO_ADDR
// end ;
85427: LD_VAR 0 2
85431: RET
// export function ReverseDir ( unit ) ; begin
85432: LD_INT 0
85434: PPUSH
// if not unit then
85435: LD_VAR 0 1
85439: NOT
85440: IFFALSE 85444
// exit ;
85442: GO 85467
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
85444: LD_ADDR_VAR 0 2
85448: PUSH
85449: LD_VAR 0 1
85453: PPUSH
85454: CALL_OW 254
85458: PUSH
85459: LD_INT 3
85461: PLUS
85462: PUSH
85463: LD_INT 6
85465: MOD
85466: ST_TO_ADDR
// end ;
85467: LD_VAR 0 2
85471: RET
// export function ReverseArray ( array ) ; var i ; begin
85472: LD_INT 0
85474: PPUSH
85475: PPUSH
// if not array then
85476: LD_VAR 0 1
85480: NOT
85481: IFFALSE 85485
// exit ;
85483: GO 85540
// result := [ ] ;
85485: LD_ADDR_VAR 0 2
85489: PUSH
85490: EMPTY
85491: ST_TO_ADDR
// for i := array downto 1 do
85492: LD_ADDR_VAR 0 3
85496: PUSH
85497: DOUBLE
85498: LD_VAR 0 1
85502: INC
85503: ST_TO_ADDR
85504: LD_INT 1
85506: PUSH
85507: FOR_DOWNTO
85508: IFFALSE 85538
// result := Join ( result , array [ i ] ) ;
85510: LD_ADDR_VAR 0 2
85514: PUSH
85515: LD_VAR 0 2
85519: PPUSH
85520: LD_VAR 0 1
85524: PUSH
85525: LD_VAR 0 3
85529: ARRAY
85530: PPUSH
85531: CALL 90183 0 2
85535: ST_TO_ADDR
85536: GO 85507
85538: POP
85539: POP
// end ;
85540: LD_VAR 0 2
85544: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
85545: LD_INT 0
85547: PPUSH
85548: PPUSH
85549: PPUSH
85550: PPUSH
85551: PPUSH
85552: PPUSH
// if not unit or not hexes then
85553: LD_VAR 0 1
85557: NOT
85558: PUSH
85559: LD_VAR 0 2
85563: NOT
85564: OR
85565: IFFALSE 85569
// exit ;
85567: GO 85692
// dist := 9999 ;
85569: LD_ADDR_VAR 0 5
85573: PUSH
85574: LD_INT 9999
85576: ST_TO_ADDR
// for i = 1 to hexes do
85577: LD_ADDR_VAR 0 4
85581: PUSH
85582: DOUBLE
85583: LD_INT 1
85585: DEC
85586: ST_TO_ADDR
85587: LD_VAR 0 2
85591: PUSH
85592: FOR_TO
85593: IFFALSE 85680
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
85595: LD_ADDR_VAR 0 6
85599: PUSH
85600: LD_VAR 0 1
85604: PPUSH
85605: LD_VAR 0 2
85609: PUSH
85610: LD_VAR 0 4
85614: ARRAY
85615: PUSH
85616: LD_INT 1
85618: ARRAY
85619: PPUSH
85620: LD_VAR 0 2
85624: PUSH
85625: LD_VAR 0 4
85629: ARRAY
85630: PUSH
85631: LD_INT 2
85633: ARRAY
85634: PPUSH
85635: CALL_OW 297
85639: ST_TO_ADDR
// if tdist < dist then
85640: LD_VAR 0 6
85644: PUSH
85645: LD_VAR 0 5
85649: LESS
85650: IFFALSE 85678
// begin hex := hexes [ i ] ;
85652: LD_ADDR_VAR 0 8
85656: PUSH
85657: LD_VAR 0 2
85661: PUSH
85662: LD_VAR 0 4
85666: ARRAY
85667: ST_TO_ADDR
// dist := tdist ;
85668: LD_ADDR_VAR 0 5
85672: PUSH
85673: LD_VAR 0 6
85677: ST_TO_ADDR
// end ; end ;
85678: GO 85592
85680: POP
85681: POP
// result := hex ;
85682: LD_ADDR_VAR 0 3
85686: PUSH
85687: LD_VAR 0 8
85691: ST_TO_ADDR
// end ;
85692: LD_VAR 0 3
85696: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
85697: LD_INT 0
85699: PPUSH
85700: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85701: LD_VAR 0 1
85705: NOT
85706: PUSH
85707: LD_VAR 0 1
85711: PUSH
85712: LD_INT 21
85714: PUSH
85715: LD_INT 2
85717: PUSH
85718: EMPTY
85719: LIST
85720: LIST
85721: PUSH
85722: LD_INT 23
85724: PUSH
85725: LD_INT 2
85727: PUSH
85728: EMPTY
85729: LIST
85730: LIST
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PPUSH
85736: CALL_OW 69
85740: IN
85741: NOT
85742: OR
85743: IFFALSE 85747
// exit ;
85745: GO 85794
// for i = 1 to 3 do
85747: LD_ADDR_VAR 0 3
85751: PUSH
85752: DOUBLE
85753: LD_INT 1
85755: DEC
85756: ST_TO_ADDR
85757: LD_INT 3
85759: PUSH
85760: FOR_TO
85761: IFFALSE 85792
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
85763: LD_VAR 0 1
85767: PPUSH
85768: CALL_OW 250
85772: PPUSH
85773: LD_VAR 0 1
85777: PPUSH
85778: CALL_OW 251
85782: PPUSH
85783: LD_INT 1
85785: PPUSH
85786: CALL_OW 453
85790: GO 85760
85792: POP
85793: POP
// end ;
85794: LD_VAR 0 2
85798: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
85799: LD_INT 0
85801: PPUSH
85802: PPUSH
85803: PPUSH
85804: PPUSH
85805: PPUSH
85806: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
85807: LD_VAR 0 1
85811: NOT
85812: PUSH
85813: LD_VAR 0 2
85817: NOT
85818: OR
85819: PUSH
85820: LD_VAR 0 1
85824: PPUSH
85825: CALL_OW 314
85829: OR
85830: IFFALSE 85834
// exit ;
85832: GO 86301
// if GetLives ( i ) < 250 then
85834: LD_VAR 0 4
85838: PPUSH
85839: CALL_OW 256
85843: PUSH
85844: LD_INT 250
85846: LESS
85847: IFFALSE 85860
// begin ComAutodestruct ( i ) ;
85849: LD_VAR 0 4
85853: PPUSH
85854: CALL 85697 0 1
// exit ;
85858: GO 86301
// end ; x := GetX ( enemy_unit ) ;
85860: LD_ADDR_VAR 0 7
85864: PUSH
85865: LD_VAR 0 2
85869: PPUSH
85870: CALL_OW 250
85874: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85875: LD_ADDR_VAR 0 8
85879: PUSH
85880: LD_VAR 0 2
85884: PPUSH
85885: CALL_OW 251
85889: ST_TO_ADDR
// if not x or not y then
85890: LD_VAR 0 7
85894: NOT
85895: PUSH
85896: LD_VAR 0 8
85900: NOT
85901: OR
85902: IFFALSE 85906
// exit ;
85904: GO 86301
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85906: LD_ADDR_VAR 0 6
85910: PUSH
85911: LD_VAR 0 7
85915: PPUSH
85916: LD_INT 0
85918: PPUSH
85919: LD_INT 4
85921: PPUSH
85922: CALL_OW 272
85926: PUSH
85927: LD_VAR 0 8
85931: PPUSH
85932: LD_INT 0
85934: PPUSH
85935: LD_INT 4
85937: PPUSH
85938: CALL_OW 273
85942: PUSH
85943: EMPTY
85944: LIST
85945: LIST
85946: PUSH
85947: LD_VAR 0 7
85951: PPUSH
85952: LD_INT 1
85954: PPUSH
85955: LD_INT 4
85957: PPUSH
85958: CALL_OW 272
85962: PUSH
85963: LD_VAR 0 8
85967: PPUSH
85968: LD_INT 1
85970: PPUSH
85971: LD_INT 4
85973: PPUSH
85974: CALL_OW 273
85978: PUSH
85979: EMPTY
85980: LIST
85981: LIST
85982: PUSH
85983: LD_VAR 0 7
85987: PPUSH
85988: LD_INT 2
85990: PPUSH
85991: LD_INT 4
85993: PPUSH
85994: CALL_OW 272
85998: PUSH
85999: LD_VAR 0 8
86003: PPUSH
86004: LD_INT 2
86006: PPUSH
86007: LD_INT 4
86009: PPUSH
86010: CALL_OW 273
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: LD_VAR 0 7
86023: PPUSH
86024: LD_INT 3
86026: PPUSH
86027: LD_INT 4
86029: PPUSH
86030: CALL_OW 272
86034: PUSH
86035: LD_VAR 0 8
86039: PPUSH
86040: LD_INT 3
86042: PPUSH
86043: LD_INT 4
86045: PPUSH
86046: CALL_OW 273
86050: PUSH
86051: EMPTY
86052: LIST
86053: LIST
86054: PUSH
86055: LD_VAR 0 7
86059: PPUSH
86060: LD_INT 4
86062: PPUSH
86063: LD_INT 4
86065: PPUSH
86066: CALL_OW 272
86070: PUSH
86071: LD_VAR 0 8
86075: PPUSH
86076: LD_INT 4
86078: PPUSH
86079: LD_INT 4
86081: PPUSH
86082: CALL_OW 273
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: PUSH
86091: LD_VAR 0 7
86095: PPUSH
86096: LD_INT 5
86098: PPUSH
86099: LD_INT 4
86101: PPUSH
86102: CALL_OW 272
86106: PUSH
86107: LD_VAR 0 8
86111: PPUSH
86112: LD_INT 5
86114: PPUSH
86115: LD_INT 4
86117: PPUSH
86118: CALL_OW 273
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: LIST
86131: LIST
86132: LIST
86133: LIST
86134: ST_TO_ADDR
// for i = tmp downto 1 do
86135: LD_ADDR_VAR 0 4
86139: PUSH
86140: DOUBLE
86141: LD_VAR 0 6
86145: INC
86146: ST_TO_ADDR
86147: LD_INT 1
86149: PUSH
86150: FOR_DOWNTO
86151: IFFALSE 86252
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
86153: LD_VAR 0 6
86157: PUSH
86158: LD_VAR 0 4
86162: ARRAY
86163: PUSH
86164: LD_INT 1
86166: ARRAY
86167: PPUSH
86168: LD_VAR 0 6
86172: PUSH
86173: LD_VAR 0 4
86177: ARRAY
86178: PUSH
86179: LD_INT 2
86181: ARRAY
86182: PPUSH
86183: CALL_OW 488
86187: NOT
86188: PUSH
86189: LD_VAR 0 6
86193: PUSH
86194: LD_VAR 0 4
86198: ARRAY
86199: PUSH
86200: LD_INT 1
86202: ARRAY
86203: PPUSH
86204: LD_VAR 0 6
86208: PUSH
86209: LD_VAR 0 4
86213: ARRAY
86214: PUSH
86215: LD_INT 2
86217: ARRAY
86218: PPUSH
86219: CALL_OW 428
86223: PUSH
86224: LD_INT 0
86226: NONEQUAL
86227: OR
86228: IFFALSE 86250
// tmp := Delete ( tmp , i ) ;
86230: LD_ADDR_VAR 0 6
86234: PUSH
86235: LD_VAR 0 6
86239: PPUSH
86240: LD_VAR 0 4
86244: PPUSH
86245: CALL_OW 3
86249: ST_TO_ADDR
86250: GO 86150
86252: POP
86253: POP
// j := GetClosestHex ( unit , tmp ) ;
86254: LD_ADDR_VAR 0 5
86258: PUSH
86259: LD_VAR 0 1
86263: PPUSH
86264: LD_VAR 0 6
86268: PPUSH
86269: CALL 85545 0 2
86273: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
86274: LD_VAR 0 1
86278: PPUSH
86279: LD_VAR 0 5
86283: PUSH
86284: LD_INT 1
86286: ARRAY
86287: PPUSH
86288: LD_VAR 0 5
86292: PUSH
86293: LD_INT 2
86295: ARRAY
86296: PPUSH
86297: CALL_OW 111
// end ;
86301: LD_VAR 0 3
86305: RET
// export function PrepareApemanSoldier ( ) ; begin
86306: LD_INT 0
86308: PPUSH
// uc_nation := 0 ;
86309: LD_ADDR_OWVAR 21
86313: PUSH
86314: LD_INT 0
86316: ST_TO_ADDR
// hc_sex := sex_male ;
86317: LD_ADDR_OWVAR 27
86321: PUSH
86322: LD_INT 1
86324: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
86325: LD_ADDR_OWVAR 28
86329: PUSH
86330: LD_INT 15
86332: ST_TO_ADDR
// hc_gallery :=  ;
86333: LD_ADDR_OWVAR 33
86337: PUSH
86338: LD_STRING 
86340: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86341: LD_ADDR_OWVAR 31
86345: PUSH
86346: LD_INT 0
86348: PPUSH
86349: LD_INT 3
86351: PPUSH
86352: CALL_OW 12
86356: PUSH
86357: LD_INT 0
86359: PPUSH
86360: LD_INT 3
86362: PPUSH
86363: CALL_OW 12
86367: PUSH
86368: LD_INT 0
86370: PUSH
86371: LD_INT 0
86373: PUSH
86374: EMPTY
86375: LIST
86376: LIST
86377: LIST
86378: LIST
86379: ST_TO_ADDR
// end ;
86380: LD_VAR 0 1
86384: RET
// export function PrepareApemanEngineer ( ) ; begin
86385: LD_INT 0
86387: PPUSH
// uc_nation := 0 ;
86388: LD_ADDR_OWVAR 21
86392: PUSH
86393: LD_INT 0
86395: ST_TO_ADDR
// hc_sex := sex_male ;
86396: LD_ADDR_OWVAR 27
86400: PUSH
86401: LD_INT 1
86403: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
86404: LD_ADDR_OWVAR 28
86408: PUSH
86409: LD_INT 16
86411: ST_TO_ADDR
// hc_gallery :=  ;
86412: LD_ADDR_OWVAR 33
86416: PUSH
86417: LD_STRING 
86419: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86420: LD_ADDR_OWVAR 31
86424: PUSH
86425: LD_INT 0
86427: PPUSH
86428: LD_INT 3
86430: PPUSH
86431: CALL_OW 12
86435: PUSH
86436: LD_INT 0
86438: PPUSH
86439: LD_INT 3
86441: PPUSH
86442: CALL_OW 12
86446: PUSH
86447: LD_INT 0
86449: PUSH
86450: LD_INT 0
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: LIST
86457: LIST
86458: ST_TO_ADDR
// end ;
86459: LD_VAR 0 1
86463: RET
// export function PrepareApeman ( agressivity ) ; begin
86464: LD_INT 0
86466: PPUSH
// uc_side := 0 ;
86467: LD_ADDR_OWVAR 20
86471: PUSH
86472: LD_INT 0
86474: ST_TO_ADDR
// uc_nation := 0 ;
86475: LD_ADDR_OWVAR 21
86479: PUSH
86480: LD_INT 0
86482: ST_TO_ADDR
// hc_sex := sex_male ;
86483: LD_ADDR_OWVAR 27
86487: PUSH
86488: LD_INT 1
86490: ST_TO_ADDR
// hc_class := class_apeman ;
86491: LD_ADDR_OWVAR 28
86495: PUSH
86496: LD_INT 12
86498: ST_TO_ADDR
// hc_gallery :=  ;
86499: LD_ADDR_OWVAR 33
86503: PUSH
86504: LD_STRING 
86506: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
86507: LD_ADDR_OWVAR 35
86511: PUSH
86512: LD_VAR 0 1
86516: NEG
86517: PPUSH
86518: LD_VAR 0 1
86522: PPUSH
86523: CALL_OW 12
86527: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
86528: LD_ADDR_OWVAR 31
86532: PUSH
86533: LD_INT 0
86535: PPUSH
86536: LD_INT 3
86538: PPUSH
86539: CALL_OW 12
86543: PUSH
86544: LD_INT 0
86546: PPUSH
86547: LD_INT 3
86549: PPUSH
86550: CALL_OW 12
86554: PUSH
86555: LD_INT 0
86557: PUSH
86558: LD_INT 0
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: ST_TO_ADDR
// end ;
86567: LD_VAR 0 2
86571: RET
// export function PrepareTiger ( agressivity ) ; begin
86572: LD_INT 0
86574: PPUSH
// uc_side := 0 ;
86575: LD_ADDR_OWVAR 20
86579: PUSH
86580: LD_INT 0
86582: ST_TO_ADDR
// uc_nation := 0 ;
86583: LD_ADDR_OWVAR 21
86587: PUSH
86588: LD_INT 0
86590: ST_TO_ADDR
// hc_class := class_tiger ;
86591: LD_ADDR_OWVAR 28
86595: PUSH
86596: LD_INT 14
86598: ST_TO_ADDR
// hc_gallery :=  ;
86599: LD_ADDR_OWVAR 33
86603: PUSH
86604: LD_STRING 
86606: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
86607: LD_ADDR_OWVAR 35
86611: PUSH
86612: LD_VAR 0 1
86616: NEG
86617: PPUSH
86618: LD_VAR 0 1
86622: PPUSH
86623: CALL_OW 12
86627: ST_TO_ADDR
// end ;
86628: LD_VAR 0 2
86632: RET
// export function PrepareEnchidna ( ) ; begin
86633: LD_INT 0
86635: PPUSH
// uc_side := 0 ;
86636: LD_ADDR_OWVAR 20
86640: PUSH
86641: LD_INT 0
86643: ST_TO_ADDR
// uc_nation := 0 ;
86644: LD_ADDR_OWVAR 21
86648: PUSH
86649: LD_INT 0
86651: ST_TO_ADDR
// hc_class := class_baggie ;
86652: LD_ADDR_OWVAR 28
86656: PUSH
86657: LD_INT 13
86659: ST_TO_ADDR
// hc_gallery :=  ;
86660: LD_ADDR_OWVAR 33
86664: PUSH
86665: LD_STRING 
86667: ST_TO_ADDR
// end ;
86668: LD_VAR 0 1
86672: RET
// export function PrepareFrog ( ) ; begin
86673: LD_INT 0
86675: PPUSH
// uc_side := 0 ;
86676: LD_ADDR_OWVAR 20
86680: PUSH
86681: LD_INT 0
86683: ST_TO_ADDR
// uc_nation := 0 ;
86684: LD_ADDR_OWVAR 21
86688: PUSH
86689: LD_INT 0
86691: ST_TO_ADDR
// hc_class := class_frog ;
86692: LD_ADDR_OWVAR 28
86696: PUSH
86697: LD_INT 19
86699: ST_TO_ADDR
// hc_gallery :=  ;
86700: LD_ADDR_OWVAR 33
86704: PUSH
86705: LD_STRING 
86707: ST_TO_ADDR
// end ;
86708: LD_VAR 0 1
86712: RET
// export function PrepareFish ( ) ; begin
86713: LD_INT 0
86715: PPUSH
// uc_side := 0 ;
86716: LD_ADDR_OWVAR 20
86720: PUSH
86721: LD_INT 0
86723: ST_TO_ADDR
// uc_nation := 0 ;
86724: LD_ADDR_OWVAR 21
86728: PUSH
86729: LD_INT 0
86731: ST_TO_ADDR
// hc_class := class_fish ;
86732: LD_ADDR_OWVAR 28
86736: PUSH
86737: LD_INT 20
86739: ST_TO_ADDR
// hc_gallery :=  ;
86740: LD_ADDR_OWVAR 33
86744: PUSH
86745: LD_STRING 
86747: ST_TO_ADDR
// end ;
86748: LD_VAR 0 1
86752: RET
// export function PrepareBird ( ) ; begin
86753: LD_INT 0
86755: PPUSH
// uc_side := 0 ;
86756: LD_ADDR_OWVAR 20
86760: PUSH
86761: LD_INT 0
86763: ST_TO_ADDR
// uc_nation := 0 ;
86764: LD_ADDR_OWVAR 21
86768: PUSH
86769: LD_INT 0
86771: ST_TO_ADDR
// hc_class := class_phororhacos ;
86772: LD_ADDR_OWVAR 28
86776: PUSH
86777: LD_INT 18
86779: ST_TO_ADDR
// hc_gallery :=  ;
86780: LD_ADDR_OWVAR 33
86784: PUSH
86785: LD_STRING 
86787: ST_TO_ADDR
// end ;
86788: LD_VAR 0 1
86792: RET
// export function PrepareHorse ( ) ; begin
86793: LD_INT 0
86795: PPUSH
// uc_side := 0 ;
86796: LD_ADDR_OWVAR 20
86800: PUSH
86801: LD_INT 0
86803: ST_TO_ADDR
// uc_nation := 0 ;
86804: LD_ADDR_OWVAR 21
86808: PUSH
86809: LD_INT 0
86811: ST_TO_ADDR
// hc_class := class_horse ;
86812: LD_ADDR_OWVAR 28
86816: PUSH
86817: LD_INT 21
86819: ST_TO_ADDR
// hc_gallery :=  ;
86820: LD_ADDR_OWVAR 33
86824: PUSH
86825: LD_STRING 
86827: ST_TO_ADDR
// end ;
86828: LD_VAR 0 1
86832: RET
// export function PrepareMastodont ( ) ; begin
86833: LD_INT 0
86835: PPUSH
// uc_side := 0 ;
86836: LD_ADDR_OWVAR 20
86840: PUSH
86841: LD_INT 0
86843: ST_TO_ADDR
// uc_nation := 0 ;
86844: LD_ADDR_OWVAR 21
86848: PUSH
86849: LD_INT 0
86851: ST_TO_ADDR
// vc_chassis := class_mastodont ;
86852: LD_ADDR_OWVAR 37
86856: PUSH
86857: LD_INT 31
86859: ST_TO_ADDR
// vc_control := control_rider ;
86860: LD_ADDR_OWVAR 38
86864: PUSH
86865: LD_INT 4
86867: ST_TO_ADDR
// end ;
86868: LD_VAR 0 1
86872: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
86873: LD_INT 0
86875: PPUSH
86876: PPUSH
86877: PPUSH
// uc_side = 0 ;
86878: LD_ADDR_OWVAR 20
86882: PUSH
86883: LD_INT 0
86885: ST_TO_ADDR
// uc_nation = 0 ;
86886: LD_ADDR_OWVAR 21
86890: PUSH
86891: LD_INT 0
86893: ST_TO_ADDR
// InitHc_All ( ) ;
86894: CALL_OW 584
// InitVc ;
86898: CALL_OW 20
// if mastodonts then
86902: LD_VAR 0 6
86906: IFFALSE 86973
// for i = 1 to mastodonts do
86908: LD_ADDR_VAR 0 11
86912: PUSH
86913: DOUBLE
86914: LD_INT 1
86916: DEC
86917: ST_TO_ADDR
86918: LD_VAR 0 6
86922: PUSH
86923: FOR_TO
86924: IFFALSE 86971
// begin vc_chassis := 31 ;
86926: LD_ADDR_OWVAR 37
86930: PUSH
86931: LD_INT 31
86933: ST_TO_ADDR
// vc_control := control_rider ;
86934: LD_ADDR_OWVAR 38
86938: PUSH
86939: LD_INT 4
86941: ST_TO_ADDR
// animal := CreateVehicle ;
86942: LD_ADDR_VAR 0 12
86946: PUSH
86947: CALL_OW 45
86951: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86952: LD_VAR 0 12
86956: PPUSH
86957: LD_VAR 0 8
86961: PPUSH
86962: LD_INT 0
86964: PPUSH
86965: CALL 89101 0 3
// end ;
86969: GO 86923
86971: POP
86972: POP
// if horses then
86973: LD_VAR 0 5
86977: IFFALSE 87044
// for i = 1 to horses do
86979: LD_ADDR_VAR 0 11
86983: PUSH
86984: DOUBLE
86985: LD_INT 1
86987: DEC
86988: ST_TO_ADDR
86989: LD_VAR 0 5
86993: PUSH
86994: FOR_TO
86995: IFFALSE 87042
// begin hc_class := 21 ;
86997: LD_ADDR_OWVAR 28
87001: PUSH
87002: LD_INT 21
87004: ST_TO_ADDR
// hc_gallery :=  ;
87005: LD_ADDR_OWVAR 33
87009: PUSH
87010: LD_STRING 
87012: ST_TO_ADDR
// animal := CreateHuman ;
87013: LD_ADDR_VAR 0 12
87017: PUSH
87018: CALL_OW 44
87022: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87023: LD_VAR 0 12
87027: PPUSH
87028: LD_VAR 0 8
87032: PPUSH
87033: LD_INT 0
87035: PPUSH
87036: CALL 89101 0 3
// end ;
87040: GO 86994
87042: POP
87043: POP
// if birds then
87044: LD_VAR 0 1
87048: IFFALSE 87115
// for i = 1 to birds do
87050: LD_ADDR_VAR 0 11
87054: PUSH
87055: DOUBLE
87056: LD_INT 1
87058: DEC
87059: ST_TO_ADDR
87060: LD_VAR 0 1
87064: PUSH
87065: FOR_TO
87066: IFFALSE 87113
// begin hc_class := 18 ;
87068: LD_ADDR_OWVAR 28
87072: PUSH
87073: LD_INT 18
87075: ST_TO_ADDR
// hc_gallery =  ;
87076: LD_ADDR_OWVAR 33
87080: PUSH
87081: LD_STRING 
87083: ST_TO_ADDR
// animal := CreateHuman ;
87084: LD_ADDR_VAR 0 12
87088: PUSH
87089: CALL_OW 44
87093: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87094: LD_VAR 0 12
87098: PPUSH
87099: LD_VAR 0 8
87103: PPUSH
87104: LD_INT 0
87106: PPUSH
87107: CALL 89101 0 3
// end ;
87111: GO 87065
87113: POP
87114: POP
// if tigers then
87115: LD_VAR 0 2
87119: IFFALSE 87203
// for i = 1 to tigers do
87121: LD_ADDR_VAR 0 11
87125: PUSH
87126: DOUBLE
87127: LD_INT 1
87129: DEC
87130: ST_TO_ADDR
87131: LD_VAR 0 2
87135: PUSH
87136: FOR_TO
87137: IFFALSE 87201
// begin hc_class = class_tiger ;
87139: LD_ADDR_OWVAR 28
87143: PUSH
87144: LD_INT 14
87146: ST_TO_ADDR
// hc_gallery =  ;
87147: LD_ADDR_OWVAR 33
87151: PUSH
87152: LD_STRING 
87154: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
87155: LD_ADDR_OWVAR 35
87159: PUSH
87160: LD_INT 7
87162: NEG
87163: PPUSH
87164: LD_INT 7
87166: PPUSH
87167: CALL_OW 12
87171: ST_TO_ADDR
// animal := CreateHuman ;
87172: LD_ADDR_VAR 0 12
87176: PUSH
87177: CALL_OW 44
87181: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87182: LD_VAR 0 12
87186: PPUSH
87187: LD_VAR 0 8
87191: PPUSH
87192: LD_INT 0
87194: PPUSH
87195: CALL 89101 0 3
// end ;
87199: GO 87136
87201: POP
87202: POP
// if apemans then
87203: LD_VAR 0 3
87207: IFFALSE 87330
// for i = 1 to apemans do
87209: LD_ADDR_VAR 0 11
87213: PUSH
87214: DOUBLE
87215: LD_INT 1
87217: DEC
87218: ST_TO_ADDR
87219: LD_VAR 0 3
87223: PUSH
87224: FOR_TO
87225: IFFALSE 87328
// begin hc_class = class_apeman ;
87227: LD_ADDR_OWVAR 28
87231: PUSH
87232: LD_INT 12
87234: ST_TO_ADDR
// hc_gallery =  ;
87235: LD_ADDR_OWVAR 33
87239: PUSH
87240: LD_STRING 
87242: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
87243: LD_ADDR_OWVAR 35
87247: PUSH
87248: LD_INT 2
87250: NEG
87251: PPUSH
87252: LD_INT 2
87254: PPUSH
87255: CALL_OW 12
87259: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
87260: LD_ADDR_OWVAR 31
87264: PUSH
87265: LD_INT 1
87267: PPUSH
87268: LD_INT 3
87270: PPUSH
87271: CALL_OW 12
87275: PUSH
87276: LD_INT 1
87278: PPUSH
87279: LD_INT 3
87281: PPUSH
87282: CALL_OW 12
87286: PUSH
87287: LD_INT 0
87289: PUSH
87290: LD_INT 0
87292: PUSH
87293: EMPTY
87294: LIST
87295: LIST
87296: LIST
87297: LIST
87298: ST_TO_ADDR
// animal := CreateHuman ;
87299: LD_ADDR_VAR 0 12
87303: PUSH
87304: CALL_OW 44
87308: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87309: LD_VAR 0 12
87313: PPUSH
87314: LD_VAR 0 8
87318: PPUSH
87319: LD_INT 0
87321: PPUSH
87322: CALL 89101 0 3
// end ;
87326: GO 87224
87328: POP
87329: POP
// if enchidnas then
87330: LD_VAR 0 4
87334: IFFALSE 87401
// for i = 1 to enchidnas do
87336: LD_ADDR_VAR 0 11
87340: PUSH
87341: DOUBLE
87342: LD_INT 1
87344: DEC
87345: ST_TO_ADDR
87346: LD_VAR 0 4
87350: PUSH
87351: FOR_TO
87352: IFFALSE 87399
// begin hc_class = 13 ;
87354: LD_ADDR_OWVAR 28
87358: PUSH
87359: LD_INT 13
87361: ST_TO_ADDR
// hc_gallery =  ;
87362: LD_ADDR_OWVAR 33
87366: PUSH
87367: LD_STRING 
87369: ST_TO_ADDR
// animal := CreateHuman ;
87370: LD_ADDR_VAR 0 12
87374: PUSH
87375: CALL_OW 44
87379: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87380: LD_VAR 0 12
87384: PPUSH
87385: LD_VAR 0 8
87389: PPUSH
87390: LD_INT 0
87392: PPUSH
87393: CALL 89101 0 3
// end ;
87397: GO 87351
87399: POP
87400: POP
// if fishes then
87401: LD_VAR 0 7
87405: IFFALSE 87472
// for i = 1 to fishes do
87407: LD_ADDR_VAR 0 11
87411: PUSH
87412: DOUBLE
87413: LD_INT 1
87415: DEC
87416: ST_TO_ADDR
87417: LD_VAR 0 7
87421: PUSH
87422: FOR_TO
87423: IFFALSE 87470
// begin hc_class = 20 ;
87425: LD_ADDR_OWVAR 28
87429: PUSH
87430: LD_INT 20
87432: ST_TO_ADDR
// hc_gallery =  ;
87433: LD_ADDR_OWVAR 33
87437: PUSH
87438: LD_STRING 
87440: ST_TO_ADDR
// animal := CreateHuman ;
87441: LD_ADDR_VAR 0 12
87445: PUSH
87446: CALL_OW 44
87450: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
87451: LD_VAR 0 12
87455: PPUSH
87456: LD_VAR 0 9
87460: PPUSH
87461: LD_INT 0
87463: PPUSH
87464: CALL 89101 0 3
// end ;
87468: GO 87422
87470: POP
87471: POP
// end ;
87472: LD_VAR 0 10
87476: RET
// export function WantHeal ( sci , unit ) ; begin
87477: LD_INT 0
87479: PPUSH
// if GetTaskList ( sci ) > 0 then
87480: LD_VAR 0 1
87484: PPUSH
87485: CALL_OW 437
87489: PUSH
87490: LD_INT 0
87492: GREATER
87493: IFFALSE 87563
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
87495: LD_VAR 0 1
87499: PPUSH
87500: CALL_OW 437
87504: PUSH
87505: LD_INT 1
87507: ARRAY
87508: PUSH
87509: LD_INT 1
87511: ARRAY
87512: PUSH
87513: LD_STRING l
87515: EQUAL
87516: PUSH
87517: LD_VAR 0 1
87521: PPUSH
87522: CALL_OW 437
87526: PUSH
87527: LD_INT 1
87529: ARRAY
87530: PUSH
87531: LD_INT 4
87533: ARRAY
87534: PUSH
87535: LD_VAR 0 2
87539: EQUAL
87540: AND
87541: IFFALSE 87553
// result := true else
87543: LD_ADDR_VAR 0 3
87547: PUSH
87548: LD_INT 1
87550: ST_TO_ADDR
87551: GO 87561
// result := false ;
87553: LD_ADDR_VAR 0 3
87557: PUSH
87558: LD_INT 0
87560: ST_TO_ADDR
// end else
87561: GO 87571
// result := false ;
87563: LD_ADDR_VAR 0 3
87567: PUSH
87568: LD_INT 0
87570: ST_TO_ADDR
// end ;
87571: LD_VAR 0 3
87575: RET
// export function HealTarget ( sci ) ; begin
87576: LD_INT 0
87578: PPUSH
// if not sci then
87579: LD_VAR 0 1
87583: NOT
87584: IFFALSE 87588
// exit ;
87586: GO 87653
// result := 0 ;
87588: LD_ADDR_VAR 0 2
87592: PUSH
87593: LD_INT 0
87595: ST_TO_ADDR
// if GetTaskList ( sci ) then
87596: LD_VAR 0 1
87600: PPUSH
87601: CALL_OW 437
87605: IFFALSE 87653
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
87607: LD_VAR 0 1
87611: PPUSH
87612: CALL_OW 437
87616: PUSH
87617: LD_INT 1
87619: ARRAY
87620: PUSH
87621: LD_INT 1
87623: ARRAY
87624: PUSH
87625: LD_STRING l
87627: EQUAL
87628: IFFALSE 87653
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
87630: LD_ADDR_VAR 0 2
87634: PUSH
87635: LD_VAR 0 1
87639: PPUSH
87640: CALL_OW 437
87644: PUSH
87645: LD_INT 1
87647: ARRAY
87648: PUSH
87649: LD_INT 4
87651: ARRAY
87652: ST_TO_ADDR
// end ;
87653: LD_VAR 0 2
87657: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
87658: LD_INT 0
87660: PPUSH
87661: PPUSH
87662: PPUSH
87663: PPUSH
// if not base_units then
87664: LD_VAR 0 1
87668: NOT
87669: IFFALSE 87673
// exit ;
87671: GO 87760
// result := false ;
87673: LD_ADDR_VAR 0 2
87677: PUSH
87678: LD_INT 0
87680: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
87681: LD_ADDR_VAR 0 5
87685: PUSH
87686: LD_VAR 0 1
87690: PPUSH
87691: LD_INT 21
87693: PUSH
87694: LD_INT 3
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PPUSH
87701: CALL_OW 72
87705: ST_TO_ADDR
// if not tmp then
87706: LD_VAR 0 5
87710: NOT
87711: IFFALSE 87715
// exit ;
87713: GO 87760
// for i in tmp do
87715: LD_ADDR_VAR 0 3
87719: PUSH
87720: LD_VAR 0 5
87724: PUSH
87725: FOR_IN
87726: IFFALSE 87758
// begin result := EnemyInRange ( i , 22 ) ;
87728: LD_ADDR_VAR 0 2
87732: PUSH
87733: LD_VAR 0 3
87737: PPUSH
87738: LD_INT 22
87740: PPUSH
87741: CALL 85347 0 2
87745: ST_TO_ADDR
// if result then
87746: LD_VAR 0 2
87750: IFFALSE 87756
// exit ;
87752: POP
87753: POP
87754: GO 87760
// end ;
87756: GO 87725
87758: POP
87759: POP
// end ;
87760: LD_VAR 0 2
87764: RET
// export function FilterByTag ( units , tag ) ; begin
87765: LD_INT 0
87767: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
87768: LD_ADDR_VAR 0 3
87772: PUSH
87773: LD_VAR 0 1
87777: PPUSH
87778: LD_INT 120
87780: PUSH
87781: LD_VAR 0 2
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PPUSH
87790: CALL_OW 72
87794: ST_TO_ADDR
// end ;
87795: LD_VAR 0 3
87799: RET
// export function IsDriver ( un ) ; begin
87800: LD_INT 0
87802: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87803: LD_ADDR_VAR 0 2
87807: PUSH
87808: LD_VAR 0 1
87812: PUSH
87813: LD_INT 55
87815: PUSH
87816: EMPTY
87817: LIST
87818: PPUSH
87819: CALL_OW 69
87823: IN
87824: ST_TO_ADDR
// end ;
87825: LD_VAR 0 2
87829: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87830: LD_INT 0
87832: PPUSH
87833: PPUSH
// list := [ ] ;
87834: LD_ADDR_VAR 0 5
87838: PUSH
87839: EMPTY
87840: ST_TO_ADDR
// case d of 0 :
87841: LD_VAR 0 3
87845: PUSH
87846: LD_INT 0
87848: DOUBLE
87849: EQUAL
87850: IFTRUE 87854
87852: GO 87987
87854: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87855: LD_ADDR_VAR 0 5
87859: PUSH
87860: LD_VAR 0 1
87864: PUSH
87865: LD_INT 4
87867: MINUS
87868: PUSH
87869: LD_VAR 0 2
87873: PUSH
87874: LD_INT 4
87876: MINUS
87877: PUSH
87878: LD_INT 2
87880: PUSH
87881: EMPTY
87882: LIST
87883: LIST
87884: LIST
87885: PUSH
87886: LD_VAR 0 1
87890: PUSH
87891: LD_INT 3
87893: MINUS
87894: PUSH
87895: LD_VAR 0 2
87899: PUSH
87900: LD_INT 1
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: LIST
87907: PUSH
87908: LD_VAR 0 1
87912: PUSH
87913: LD_INT 4
87915: PLUS
87916: PUSH
87917: LD_VAR 0 2
87921: PUSH
87922: LD_INT 4
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: LIST
87929: PUSH
87930: LD_VAR 0 1
87934: PUSH
87935: LD_INT 3
87937: PLUS
87938: PUSH
87939: LD_VAR 0 2
87943: PUSH
87944: LD_INT 3
87946: PLUS
87947: PUSH
87948: LD_INT 5
87950: PUSH
87951: EMPTY
87952: LIST
87953: LIST
87954: LIST
87955: PUSH
87956: LD_VAR 0 1
87960: PUSH
87961: LD_VAR 0 2
87965: PUSH
87966: LD_INT 4
87968: PLUS
87969: PUSH
87970: LD_INT 0
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: LIST
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: ST_TO_ADDR
// end ; 1 :
87985: GO 88685
87987: LD_INT 1
87989: DOUBLE
87990: EQUAL
87991: IFTRUE 87995
87993: GO 88128
87995: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87996: LD_ADDR_VAR 0 5
88000: PUSH
88001: LD_VAR 0 1
88005: PUSH
88006: LD_VAR 0 2
88010: PUSH
88011: LD_INT 4
88013: MINUS
88014: PUSH
88015: LD_INT 3
88017: PUSH
88018: EMPTY
88019: LIST
88020: LIST
88021: LIST
88022: PUSH
88023: LD_VAR 0 1
88027: PUSH
88028: LD_INT 3
88030: MINUS
88031: PUSH
88032: LD_VAR 0 2
88036: PUSH
88037: LD_INT 3
88039: MINUS
88040: PUSH
88041: LD_INT 2
88043: PUSH
88044: EMPTY
88045: LIST
88046: LIST
88047: LIST
88048: PUSH
88049: LD_VAR 0 1
88053: PUSH
88054: LD_INT 4
88056: MINUS
88057: PUSH
88058: LD_VAR 0 2
88062: PUSH
88063: LD_INT 1
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: LIST
88070: PUSH
88071: LD_VAR 0 1
88075: PUSH
88076: LD_VAR 0 2
88080: PUSH
88081: LD_INT 3
88083: PLUS
88084: PUSH
88085: LD_INT 0
88087: PUSH
88088: EMPTY
88089: LIST
88090: LIST
88091: LIST
88092: PUSH
88093: LD_VAR 0 1
88097: PUSH
88098: LD_INT 4
88100: PLUS
88101: PUSH
88102: LD_VAR 0 2
88106: PUSH
88107: LD_INT 4
88109: PLUS
88110: PUSH
88111: LD_INT 5
88113: PUSH
88114: EMPTY
88115: LIST
88116: LIST
88117: LIST
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: ST_TO_ADDR
// end ; 2 :
88126: GO 88685
88128: LD_INT 2
88130: DOUBLE
88131: EQUAL
88132: IFTRUE 88136
88134: GO 88265
88136: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
88137: LD_ADDR_VAR 0 5
88141: PUSH
88142: LD_VAR 0 1
88146: PUSH
88147: LD_VAR 0 2
88151: PUSH
88152: LD_INT 3
88154: MINUS
88155: PUSH
88156: LD_INT 3
88158: PUSH
88159: EMPTY
88160: LIST
88161: LIST
88162: LIST
88163: PUSH
88164: LD_VAR 0 1
88168: PUSH
88169: LD_INT 4
88171: PLUS
88172: PUSH
88173: LD_VAR 0 2
88177: PUSH
88178: LD_INT 4
88180: PUSH
88181: EMPTY
88182: LIST
88183: LIST
88184: LIST
88185: PUSH
88186: LD_VAR 0 1
88190: PUSH
88191: LD_VAR 0 2
88195: PUSH
88196: LD_INT 4
88198: PLUS
88199: PUSH
88200: LD_INT 0
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: LIST
88207: PUSH
88208: LD_VAR 0 1
88212: PUSH
88213: LD_INT 3
88215: MINUS
88216: PUSH
88217: LD_VAR 0 2
88221: PUSH
88222: LD_INT 1
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: LIST
88229: PUSH
88230: LD_VAR 0 1
88234: PUSH
88235: LD_INT 4
88237: MINUS
88238: PUSH
88239: LD_VAR 0 2
88243: PUSH
88244: LD_INT 4
88246: MINUS
88247: PUSH
88248: LD_INT 2
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: LIST
88255: PUSH
88256: EMPTY
88257: LIST
88258: LIST
88259: LIST
88260: LIST
88261: LIST
88262: ST_TO_ADDR
// end ; 3 :
88263: GO 88685
88265: LD_INT 3
88267: DOUBLE
88268: EQUAL
88269: IFTRUE 88273
88271: GO 88406
88273: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
88274: LD_ADDR_VAR 0 5
88278: PUSH
88279: LD_VAR 0 1
88283: PUSH
88284: LD_INT 3
88286: PLUS
88287: PUSH
88288: LD_VAR 0 2
88292: PUSH
88293: LD_INT 4
88295: PUSH
88296: EMPTY
88297: LIST
88298: LIST
88299: LIST
88300: PUSH
88301: LD_VAR 0 1
88305: PUSH
88306: LD_INT 4
88308: PLUS
88309: PUSH
88310: LD_VAR 0 2
88314: PUSH
88315: LD_INT 4
88317: PLUS
88318: PUSH
88319: LD_INT 5
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: LIST
88326: PUSH
88327: LD_VAR 0 1
88331: PUSH
88332: LD_INT 4
88334: MINUS
88335: PUSH
88336: LD_VAR 0 2
88340: PUSH
88341: LD_INT 1
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: LIST
88348: PUSH
88349: LD_VAR 0 1
88353: PUSH
88354: LD_VAR 0 2
88358: PUSH
88359: LD_INT 4
88361: MINUS
88362: PUSH
88363: LD_INT 3
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: LIST
88370: PUSH
88371: LD_VAR 0 1
88375: PUSH
88376: LD_INT 3
88378: MINUS
88379: PUSH
88380: LD_VAR 0 2
88384: PUSH
88385: LD_INT 3
88387: MINUS
88388: PUSH
88389: LD_INT 2
88391: PUSH
88392: EMPTY
88393: LIST
88394: LIST
88395: LIST
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: ST_TO_ADDR
// end ; 4 :
88404: GO 88685
88406: LD_INT 4
88408: DOUBLE
88409: EQUAL
88410: IFTRUE 88414
88412: GO 88547
88414: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
88415: LD_ADDR_VAR 0 5
88419: PUSH
88420: LD_VAR 0 1
88424: PUSH
88425: LD_VAR 0 2
88429: PUSH
88430: LD_INT 4
88432: PLUS
88433: PUSH
88434: LD_INT 0
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: LIST
88441: PUSH
88442: LD_VAR 0 1
88446: PUSH
88447: LD_INT 3
88449: PLUS
88450: PUSH
88451: LD_VAR 0 2
88455: PUSH
88456: LD_INT 3
88458: PLUS
88459: PUSH
88460: LD_INT 5
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: LIST
88467: PUSH
88468: LD_VAR 0 1
88472: PUSH
88473: LD_INT 4
88475: PLUS
88476: PUSH
88477: LD_VAR 0 2
88481: PUSH
88482: LD_INT 4
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: LIST
88489: PUSH
88490: LD_VAR 0 1
88494: PUSH
88495: LD_VAR 0 2
88499: PUSH
88500: LD_INT 3
88502: MINUS
88503: PUSH
88504: LD_INT 3
88506: PUSH
88507: EMPTY
88508: LIST
88509: LIST
88510: LIST
88511: PUSH
88512: LD_VAR 0 1
88516: PUSH
88517: LD_INT 4
88519: MINUS
88520: PUSH
88521: LD_VAR 0 2
88525: PUSH
88526: LD_INT 4
88528: MINUS
88529: PUSH
88530: LD_INT 2
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: LIST
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: LIST
88542: LIST
88543: LIST
88544: ST_TO_ADDR
// end ; 5 :
88545: GO 88685
88547: LD_INT 5
88549: DOUBLE
88550: EQUAL
88551: IFTRUE 88555
88553: GO 88684
88555: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
88556: LD_ADDR_VAR 0 5
88560: PUSH
88561: LD_VAR 0 1
88565: PUSH
88566: LD_INT 4
88568: MINUS
88569: PUSH
88570: LD_VAR 0 2
88574: PUSH
88575: LD_INT 1
88577: PUSH
88578: EMPTY
88579: LIST
88580: LIST
88581: LIST
88582: PUSH
88583: LD_VAR 0 1
88587: PUSH
88588: LD_VAR 0 2
88592: PUSH
88593: LD_INT 4
88595: MINUS
88596: PUSH
88597: LD_INT 3
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: LIST
88604: PUSH
88605: LD_VAR 0 1
88609: PUSH
88610: LD_INT 4
88612: PLUS
88613: PUSH
88614: LD_VAR 0 2
88618: PUSH
88619: LD_INT 4
88621: PLUS
88622: PUSH
88623: LD_INT 5
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: LIST
88630: PUSH
88631: LD_VAR 0 1
88635: PUSH
88636: LD_INT 3
88638: PLUS
88639: PUSH
88640: LD_VAR 0 2
88644: PUSH
88645: LD_INT 4
88647: PUSH
88648: EMPTY
88649: LIST
88650: LIST
88651: LIST
88652: PUSH
88653: LD_VAR 0 1
88657: PUSH
88658: LD_VAR 0 2
88662: PUSH
88663: LD_INT 3
88665: PLUS
88666: PUSH
88667: LD_INT 0
88669: PUSH
88670: EMPTY
88671: LIST
88672: LIST
88673: LIST
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: ST_TO_ADDR
// end ; end ;
88682: GO 88685
88684: POP
// result := list ;
88685: LD_ADDR_VAR 0 4
88689: PUSH
88690: LD_VAR 0 5
88694: ST_TO_ADDR
// end ;
88695: LD_VAR 0 4
88699: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
88700: LD_INT 0
88702: PPUSH
88703: PPUSH
88704: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
88705: LD_VAR 0 1
88709: NOT
88710: PUSH
88711: LD_VAR 0 2
88715: PUSH
88716: LD_INT 1
88718: PUSH
88719: LD_INT 2
88721: PUSH
88722: LD_INT 3
88724: PUSH
88725: LD_INT 4
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: IN
88734: NOT
88735: OR
88736: IFFALSE 88740
// exit ;
88738: GO 88823
// tmp := [ ] ;
88740: LD_ADDR_VAR 0 5
88744: PUSH
88745: EMPTY
88746: ST_TO_ADDR
// for i in units do
88747: LD_ADDR_VAR 0 4
88751: PUSH
88752: LD_VAR 0 1
88756: PUSH
88757: FOR_IN
88758: IFFALSE 88792
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
88760: LD_ADDR_VAR 0 5
88764: PUSH
88765: LD_VAR 0 5
88769: PPUSH
88770: LD_VAR 0 4
88774: PPUSH
88775: LD_VAR 0 2
88779: PPUSH
88780: CALL_OW 259
88784: PPUSH
88785: CALL 90183 0 2
88789: ST_TO_ADDR
88790: GO 88757
88792: POP
88793: POP
// if not tmp then
88794: LD_VAR 0 5
88798: NOT
88799: IFFALSE 88803
// exit ;
88801: GO 88823
// result := SortListByListDesc ( units , tmp ) ;
88803: LD_ADDR_VAR 0 3
88807: PUSH
88808: LD_VAR 0 1
88812: PPUSH
88813: LD_VAR 0 5
88817: PPUSH
88818: CALL_OW 77
88822: ST_TO_ADDR
// end ;
88823: LD_VAR 0 3
88827: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88828: LD_INT 0
88830: PPUSH
88831: PPUSH
88832: PPUSH
// result := false ;
88833: LD_ADDR_VAR 0 3
88837: PUSH
88838: LD_INT 0
88840: ST_TO_ADDR
// if not building then
88841: LD_VAR 0 2
88845: NOT
88846: IFFALSE 88850
// exit ;
88848: GO 88988
// x := GetX ( building ) ;
88850: LD_ADDR_VAR 0 4
88854: PUSH
88855: LD_VAR 0 2
88859: PPUSH
88860: CALL_OW 250
88864: ST_TO_ADDR
// y := GetY ( building ) ;
88865: LD_ADDR_VAR 0 5
88869: PUSH
88870: LD_VAR 0 2
88874: PPUSH
88875: CALL_OW 251
88879: ST_TO_ADDR
// if not x or not y then
88880: LD_VAR 0 4
88884: NOT
88885: PUSH
88886: LD_VAR 0 5
88890: NOT
88891: OR
88892: IFFALSE 88896
// exit ;
88894: GO 88988
// if GetTaskList ( unit ) then
88896: LD_VAR 0 1
88900: PPUSH
88901: CALL_OW 437
88905: IFFALSE 88988
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88907: LD_STRING e
88909: PUSH
88910: LD_VAR 0 1
88914: PPUSH
88915: CALL_OW 437
88919: PUSH
88920: LD_INT 1
88922: ARRAY
88923: PUSH
88924: LD_INT 1
88926: ARRAY
88927: EQUAL
88928: PUSH
88929: LD_VAR 0 4
88933: PUSH
88934: LD_VAR 0 1
88938: PPUSH
88939: CALL_OW 437
88943: PUSH
88944: LD_INT 1
88946: ARRAY
88947: PUSH
88948: LD_INT 2
88950: ARRAY
88951: EQUAL
88952: AND
88953: PUSH
88954: LD_VAR 0 5
88958: PUSH
88959: LD_VAR 0 1
88963: PPUSH
88964: CALL_OW 437
88968: PUSH
88969: LD_INT 1
88971: ARRAY
88972: PUSH
88973: LD_INT 3
88975: ARRAY
88976: EQUAL
88977: AND
88978: IFFALSE 88988
// result := true end ;
88980: LD_ADDR_VAR 0 3
88984: PUSH
88985: LD_INT 1
88987: ST_TO_ADDR
// end ;
88988: LD_VAR 0 3
88992: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
88993: LD_INT 0
88995: PPUSH
// result := false ;
88996: LD_ADDR_VAR 0 4
89000: PUSH
89001: LD_INT 0
89003: ST_TO_ADDR
// if GetTaskList ( unit ) then
89004: LD_VAR 0 1
89008: PPUSH
89009: CALL_OW 437
89013: IFFALSE 89096
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89015: LD_STRING M
89017: PUSH
89018: LD_VAR 0 1
89022: PPUSH
89023: CALL_OW 437
89027: PUSH
89028: LD_INT 1
89030: ARRAY
89031: PUSH
89032: LD_INT 1
89034: ARRAY
89035: EQUAL
89036: PUSH
89037: LD_VAR 0 2
89041: PUSH
89042: LD_VAR 0 1
89046: PPUSH
89047: CALL_OW 437
89051: PUSH
89052: LD_INT 1
89054: ARRAY
89055: PUSH
89056: LD_INT 2
89058: ARRAY
89059: EQUAL
89060: AND
89061: PUSH
89062: LD_VAR 0 3
89066: PUSH
89067: LD_VAR 0 1
89071: PPUSH
89072: CALL_OW 437
89076: PUSH
89077: LD_INT 1
89079: ARRAY
89080: PUSH
89081: LD_INT 3
89083: ARRAY
89084: EQUAL
89085: AND
89086: IFFALSE 89096
// result := true ;
89088: LD_ADDR_VAR 0 4
89092: PUSH
89093: LD_INT 1
89095: ST_TO_ADDR
// end ; end ;
89096: LD_VAR 0 4
89100: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
89101: LD_INT 0
89103: PPUSH
89104: PPUSH
89105: PPUSH
89106: PPUSH
// if not unit or not area then
89107: LD_VAR 0 1
89111: NOT
89112: PUSH
89113: LD_VAR 0 2
89117: NOT
89118: OR
89119: IFFALSE 89123
// exit ;
89121: GO 89286
// tmp := AreaToList ( area , i ) ;
89123: LD_ADDR_VAR 0 6
89127: PUSH
89128: LD_VAR 0 2
89132: PPUSH
89133: LD_VAR 0 5
89137: PPUSH
89138: CALL_OW 517
89142: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
89143: LD_ADDR_VAR 0 5
89147: PUSH
89148: DOUBLE
89149: LD_INT 1
89151: DEC
89152: ST_TO_ADDR
89153: LD_VAR 0 6
89157: PUSH
89158: LD_INT 1
89160: ARRAY
89161: PUSH
89162: FOR_TO
89163: IFFALSE 89284
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
89165: LD_ADDR_VAR 0 7
89169: PUSH
89170: LD_VAR 0 6
89174: PUSH
89175: LD_INT 1
89177: ARRAY
89178: PUSH
89179: LD_VAR 0 5
89183: ARRAY
89184: PUSH
89185: LD_VAR 0 6
89189: PUSH
89190: LD_INT 2
89192: ARRAY
89193: PUSH
89194: LD_VAR 0 5
89198: ARRAY
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
89204: LD_INT 92
89206: PUSH
89207: LD_VAR 0 7
89211: PUSH
89212: LD_INT 1
89214: ARRAY
89215: PUSH
89216: LD_VAR 0 7
89220: PUSH
89221: LD_INT 2
89223: ARRAY
89224: PUSH
89225: LD_INT 3
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: PPUSH
89234: CALL_OW 69
89238: PUSH
89239: LD_INT 0
89241: EQUAL
89242: IFFALSE 89282
// begin PlaceUnitArea ( unit , area , mode ) ;
89244: LD_VAR 0 1
89248: PPUSH
89249: LD_VAR 0 2
89253: PPUSH
89254: LD_VAR 0 3
89258: PPUSH
89259: CALL_OW 49
// result := IsPlaced ( unit ) ;
89263: LD_ADDR_VAR 0 4
89267: PUSH
89268: LD_VAR 0 1
89272: PPUSH
89273: CALL_OW 305
89277: ST_TO_ADDR
// exit ;
89278: POP
89279: POP
89280: GO 89286
// end ; end ;
89282: GO 89162
89284: POP
89285: POP
// end ;
89286: LD_VAR 0 4
89290: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
89291: LD_INT 0
89293: PPUSH
89294: PPUSH
89295: PPUSH
// if not side or side > 8 then
89296: LD_VAR 0 1
89300: NOT
89301: PUSH
89302: LD_VAR 0 1
89306: PUSH
89307: LD_INT 8
89309: GREATER
89310: OR
89311: IFFALSE 89315
// exit ;
89313: GO 89502
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
89315: LD_ADDR_VAR 0 4
89319: PUSH
89320: LD_INT 22
89322: PUSH
89323: LD_VAR 0 1
89327: PUSH
89328: EMPTY
89329: LIST
89330: LIST
89331: PUSH
89332: LD_INT 21
89334: PUSH
89335: LD_INT 3
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PPUSH
89346: CALL_OW 69
89350: ST_TO_ADDR
// if not tmp then
89351: LD_VAR 0 4
89355: NOT
89356: IFFALSE 89360
// exit ;
89358: GO 89502
// enable_addtolog := true ;
89360: LD_ADDR_OWVAR 81
89364: PUSH
89365: LD_INT 1
89367: ST_TO_ADDR
// AddToLog ( [ ) ;
89368: LD_STRING [
89370: PPUSH
89371: CALL_OW 561
// for i in tmp do
89375: LD_ADDR_VAR 0 3
89379: PUSH
89380: LD_VAR 0 4
89384: PUSH
89385: FOR_IN
89386: IFFALSE 89493
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
89388: LD_STRING [
89390: PUSH
89391: LD_VAR 0 3
89395: PPUSH
89396: CALL_OW 266
89400: STR
89401: PUSH
89402: LD_STRING , 
89404: STR
89405: PUSH
89406: LD_VAR 0 3
89410: PPUSH
89411: CALL_OW 250
89415: STR
89416: PUSH
89417: LD_STRING , 
89419: STR
89420: PUSH
89421: LD_VAR 0 3
89425: PPUSH
89426: CALL_OW 251
89430: STR
89431: PUSH
89432: LD_STRING , 
89434: STR
89435: PUSH
89436: LD_VAR 0 3
89440: PPUSH
89441: CALL_OW 254
89445: STR
89446: PUSH
89447: LD_STRING , 
89449: STR
89450: PUSH
89451: LD_VAR 0 3
89455: PPUSH
89456: LD_INT 1
89458: PPUSH
89459: CALL_OW 268
89463: STR
89464: PUSH
89465: LD_STRING , 
89467: STR
89468: PUSH
89469: LD_VAR 0 3
89473: PPUSH
89474: LD_INT 2
89476: PPUSH
89477: CALL_OW 268
89481: STR
89482: PUSH
89483: LD_STRING ],
89485: STR
89486: PPUSH
89487: CALL_OW 561
// end ;
89491: GO 89385
89493: POP
89494: POP
// AddToLog ( ]; ) ;
89495: LD_STRING ];
89497: PPUSH
89498: CALL_OW 561
// end ;
89502: LD_VAR 0 2
89506: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
89507: LD_INT 0
89509: PPUSH
89510: PPUSH
89511: PPUSH
89512: PPUSH
89513: PPUSH
// if not area or not rate or not max then
89514: LD_VAR 0 1
89518: NOT
89519: PUSH
89520: LD_VAR 0 2
89524: NOT
89525: OR
89526: PUSH
89527: LD_VAR 0 4
89531: NOT
89532: OR
89533: IFFALSE 89537
// exit ;
89535: GO 89726
// while 1 do
89537: LD_INT 1
89539: IFFALSE 89726
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
89541: LD_ADDR_VAR 0 9
89545: PUSH
89546: LD_VAR 0 1
89550: PPUSH
89551: LD_INT 1
89553: PPUSH
89554: CALL_OW 287
89558: PUSH
89559: LD_INT 10
89561: MUL
89562: ST_TO_ADDR
// r := rate / 10 ;
89563: LD_ADDR_VAR 0 7
89567: PUSH
89568: LD_VAR 0 2
89572: PUSH
89573: LD_INT 10
89575: DIVREAL
89576: ST_TO_ADDR
// time := 1 1$00 ;
89577: LD_ADDR_VAR 0 8
89581: PUSH
89582: LD_INT 2100
89584: ST_TO_ADDR
// if amount < min then
89585: LD_VAR 0 9
89589: PUSH
89590: LD_VAR 0 3
89594: LESS
89595: IFFALSE 89613
// r := r * 2 else
89597: LD_ADDR_VAR 0 7
89601: PUSH
89602: LD_VAR 0 7
89606: PUSH
89607: LD_INT 2
89609: MUL
89610: ST_TO_ADDR
89611: GO 89639
// if amount > max then
89613: LD_VAR 0 9
89617: PUSH
89618: LD_VAR 0 4
89622: GREATER
89623: IFFALSE 89639
// r := r / 2 ;
89625: LD_ADDR_VAR 0 7
89629: PUSH
89630: LD_VAR 0 7
89634: PUSH
89635: LD_INT 2
89637: DIVREAL
89638: ST_TO_ADDR
// time := time / r ;
89639: LD_ADDR_VAR 0 8
89643: PUSH
89644: LD_VAR 0 8
89648: PUSH
89649: LD_VAR 0 7
89653: DIVREAL
89654: ST_TO_ADDR
// if time < 0 then
89655: LD_VAR 0 8
89659: PUSH
89660: LD_INT 0
89662: LESS
89663: IFFALSE 89680
// time := time * - 1 ;
89665: LD_ADDR_VAR 0 8
89669: PUSH
89670: LD_VAR 0 8
89674: PUSH
89675: LD_INT 1
89677: NEG
89678: MUL
89679: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
89680: LD_VAR 0 8
89684: PUSH
89685: LD_INT 35
89687: PPUSH
89688: LD_INT 875
89690: PPUSH
89691: CALL_OW 12
89695: PLUS
89696: PPUSH
89697: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
89701: LD_INT 1
89703: PPUSH
89704: LD_INT 5
89706: PPUSH
89707: CALL_OW 12
89711: PPUSH
89712: LD_VAR 0 1
89716: PPUSH
89717: LD_INT 1
89719: PPUSH
89720: CALL_OW 55
// end ;
89724: GO 89537
// end ;
89726: LD_VAR 0 5
89730: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
89731: LD_INT 0
89733: PPUSH
89734: PPUSH
89735: PPUSH
89736: PPUSH
89737: PPUSH
89738: PPUSH
89739: PPUSH
89740: PPUSH
// if not turrets or not factories then
89741: LD_VAR 0 1
89745: NOT
89746: PUSH
89747: LD_VAR 0 2
89751: NOT
89752: OR
89753: IFFALSE 89757
// exit ;
89755: GO 90064
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
89757: LD_ADDR_VAR 0 10
89761: PUSH
89762: LD_INT 5
89764: PUSH
89765: LD_INT 6
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: PUSH
89772: LD_INT 2
89774: PUSH
89775: LD_INT 4
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PUSH
89782: LD_INT 3
89784: PUSH
89785: LD_INT 5
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: PUSH
89792: EMPTY
89793: LIST
89794: LIST
89795: LIST
89796: PUSH
89797: LD_INT 24
89799: PUSH
89800: LD_INT 25
89802: PUSH
89803: EMPTY
89804: LIST
89805: LIST
89806: PUSH
89807: LD_INT 23
89809: PUSH
89810: LD_INT 27
89812: PUSH
89813: EMPTY
89814: LIST
89815: LIST
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 42
89823: PUSH
89824: LD_INT 43
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: LD_INT 44
89833: PUSH
89834: LD_INT 46
89836: PUSH
89837: EMPTY
89838: LIST
89839: LIST
89840: PUSH
89841: LD_INT 45
89843: PUSH
89844: LD_INT 47
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: PUSH
89851: EMPTY
89852: LIST
89853: LIST
89854: LIST
89855: PUSH
89856: EMPTY
89857: LIST
89858: LIST
89859: LIST
89860: ST_TO_ADDR
// result := [ ] ;
89861: LD_ADDR_VAR 0 3
89865: PUSH
89866: EMPTY
89867: ST_TO_ADDR
// for i in turrets do
89868: LD_ADDR_VAR 0 4
89872: PUSH
89873: LD_VAR 0 1
89877: PUSH
89878: FOR_IN
89879: IFFALSE 90062
// begin nat := GetNation ( i ) ;
89881: LD_ADDR_VAR 0 7
89885: PUSH
89886: LD_VAR 0 4
89890: PPUSH
89891: CALL_OW 248
89895: ST_TO_ADDR
// weapon := 0 ;
89896: LD_ADDR_VAR 0 8
89900: PUSH
89901: LD_INT 0
89903: ST_TO_ADDR
// if not nat then
89904: LD_VAR 0 7
89908: NOT
89909: IFFALSE 89913
// continue ;
89911: GO 89878
// for j in list [ nat ] do
89913: LD_ADDR_VAR 0 5
89917: PUSH
89918: LD_VAR 0 10
89922: PUSH
89923: LD_VAR 0 7
89927: ARRAY
89928: PUSH
89929: FOR_IN
89930: IFFALSE 89971
// if GetBWeapon ( i ) = j [ 1 ] then
89932: LD_VAR 0 4
89936: PPUSH
89937: CALL_OW 269
89941: PUSH
89942: LD_VAR 0 5
89946: PUSH
89947: LD_INT 1
89949: ARRAY
89950: EQUAL
89951: IFFALSE 89969
// begin weapon := j [ 2 ] ;
89953: LD_ADDR_VAR 0 8
89957: PUSH
89958: LD_VAR 0 5
89962: PUSH
89963: LD_INT 2
89965: ARRAY
89966: ST_TO_ADDR
// break ;
89967: GO 89971
// end ;
89969: GO 89929
89971: POP
89972: POP
// if not weapon then
89973: LD_VAR 0 8
89977: NOT
89978: IFFALSE 89982
// continue ;
89980: GO 89878
// for k in factories do
89982: LD_ADDR_VAR 0 6
89986: PUSH
89987: LD_VAR 0 2
89991: PUSH
89992: FOR_IN
89993: IFFALSE 90058
// begin weapons := AvailableWeaponList ( k ) ;
89995: LD_ADDR_VAR 0 9
89999: PUSH
90000: LD_VAR 0 6
90004: PPUSH
90005: CALL_OW 478
90009: ST_TO_ADDR
// if not weapons then
90010: LD_VAR 0 9
90014: NOT
90015: IFFALSE 90019
// continue ;
90017: GO 89992
// if weapon in weapons then
90019: LD_VAR 0 8
90023: PUSH
90024: LD_VAR 0 9
90028: IN
90029: IFFALSE 90056
// begin result := [ i , weapon ] ;
90031: LD_ADDR_VAR 0 3
90035: PUSH
90036: LD_VAR 0 4
90040: PUSH
90041: LD_VAR 0 8
90045: PUSH
90046: EMPTY
90047: LIST
90048: LIST
90049: ST_TO_ADDR
// exit ;
90050: POP
90051: POP
90052: POP
90053: POP
90054: GO 90064
// end ; end ;
90056: GO 89992
90058: POP
90059: POP
// end ;
90060: GO 89878
90062: POP
90063: POP
// end ;
90064: LD_VAR 0 3
90068: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
90069: LD_INT 0
90071: PPUSH
// if not side or side > 8 then
90072: LD_VAR 0 3
90076: NOT
90077: PUSH
90078: LD_VAR 0 3
90082: PUSH
90083: LD_INT 8
90085: GREATER
90086: OR
90087: IFFALSE 90091
// exit ;
90089: GO 90150
// if not range then
90091: LD_VAR 0 4
90095: NOT
90096: IFFALSE 90107
// range := - 12 ;
90098: LD_ADDR_VAR 0 4
90102: PUSH
90103: LD_INT 12
90105: NEG
90106: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
90107: LD_VAR 0 1
90111: PPUSH
90112: LD_VAR 0 2
90116: PPUSH
90117: LD_VAR 0 3
90121: PPUSH
90122: LD_VAR 0 4
90126: PPUSH
90127: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
90131: LD_VAR 0 1
90135: PPUSH
90136: LD_VAR 0 2
90140: PPUSH
90141: LD_VAR 0 3
90145: PPUSH
90146: CALL_OW 331
// end ;
90150: LD_VAR 0 5
90154: RET
// export function Video ( mode ) ; begin
90155: LD_INT 0
90157: PPUSH
// ingame_video = mode ;
90158: LD_ADDR_OWVAR 52
90162: PUSH
90163: LD_VAR 0 1
90167: ST_TO_ADDR
// interface_hidden = mode ;
90168: LD_ADDR_OWVAR 54
90172: PUSH
90173: LD_VAR 0 1
90177: ST_TO_ADDR
// end ;
90178: LD_VAR 0 2
90182: RET
// export function Join ( array , element ) ; begin
90183: LD_INT 0
90185: PPUSH
// result := Replace ( array , array + 1 , element ) ;
90186: LD_ADDR_VAR 0 3
90190: PUSH
90191: LD_VAR 0 1
90195: PPUSH
90196: LD_VAR 0 1
90200: PUSH
90201: LD_INT 1
90203: PLUS
90204: PPUSH
90205: LD_VAR 0 2
90209: PPUSH
90210: CALL_OW 1
90214: ST_TO_ADDR
// end ;
90215: LD_VAR 0 3
90219: RET
// export function JoinUnion ( array , element ) ; begin
90220: LD_INT 0
90222: PPUSH
// result := array union element ;
90223: LD_ADDR_VAR 0 3
90227: PUSH
90228: LD_VAR 0 1
90232: PUSH
90233: LD_VAR 0 2
90237: UNION
90238: ST_TO_ADDR
// end ;
90239: LD_VAR 0 3
90243: RET
// export function GetBehemoths ( side ) ; begin
90244: LD_INT 0
90246: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
90247: LD_ADDR_VAR 0 2
90251: PUSH
90252: LD_INT 22
90254: PUSH
90255: LD_VAR 0 1
90259: PUSH
90260: EMPTY
90261: LIST
90262: LIST
90263: PUSH
90264: LD_INT 31
90266: PUSH
90267: LD_INT 25
90269: PUSH
90270: EMPTY
90271: LIST
90272: LIST
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: PPUSH
90278: CALL_OW 69
90282: ST_TO_ADDR
// end ;
90283: LD_VAR 0 2
90287: RET
// export function Shuffle ( array ) ; var i , index ; begin
90288: LD_INT 0
90290: PPUSH
90291: PPUSH
90292: PPUSH
// result := [ ] ;
90293: LD_ADDR_VAR 0 2
90297: PUSH
90298: EMPTY
90299: ST_TO_ADDR
// if not array then
90300: LD_VAR 0 1
90304: NOT
90305: IFFALSE 90309
// exit ;
90307: GO 90408
// Randomize ;
90309: CALL_OW 10
// for i = array downto 1 do
90313: LD_ADDR_VAR 0 3
90317: PUSH
90318: DOUBLE
90319: LD_VAR 0 1
90323: INC
90324: ST_TO_ADDR
90325: LD_INT 1
90327: PUSH
90328: FOR_DOWNTO
90329: IFFALSE 90406
// begin index := rand ( 1 , array ) ;
90331: LD_ADDR_VAR 0 4
90335: PUSH
90336: LD_INT 1
90338: PPUSH
90339: LD_VAR 0 1
90343: PPUSH
90344: CALL_OW 12
90348: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
90349: LD_ADDR_VAR 0 2
90353: PUSH
90354: LD_VAR 0 2
90358: PPUSH
90359: LD_VAR 0 2
90363: PUSH
90364: LD_INT 1
90366: PLUS
90367: PPUSH
90368: LD_VAR 0 1
90372: PUSH
90373: LD_VAR 0 4
90377: ARRAY
90378: PPUSH
90379: CALL_OW 2
90383: ST_TO_ADDR
// array := Delete ( array , index ) ;
90384: LD_ADDR_VAR 0 1
90388: PUSH
90389: LD_VAR 0 1
90393: PPUSH
90394: LD_VAR 0 4
90398: PPUSH
90399: CALL_OW 3
90403: ST_TO_ADDR
// end ;
90404: GO 90328
90406: POP
90407: POP
// end ;
90408: LD_VAR 0 2
90412: RET
// export function GetBaseMaterials ( base ) ; begin
90413: LD_INT 0
90415: PPUSH
// result := [ 0 , 0 , 0 ] ;
90416: LD_ADDR_VAR 0 2
90420: PUSH
90421: LD_INT 0
90423: PUSH
90424: LD_INT 0
90426: PUSH
90427: LD_INT 0
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: LIST
90434: ST_TO_ADDR
// if not base then
90435: LD_VAR 0 1
90439: NOT
90440: IFFALSE 90444
// exit ;
90442: GO 90493
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
90444: LD_ADDR_VAR 0 2
90448: PUSH
90449: LD_VAR 0 1
90453: PPUSH
90454: LD_INT 1
90456: PPUSH
90457: CALL_OW 275
90461: PUSH
90462: LD_VAR 0 1
90466: PPUSH
90467: LD_INT 2
90469: PPUSH
90470: CALL_OW 275
90474: PUSH
90475: LD_VAR 0 1
90479: PPUSH
90480: LD_INT 3
90482: PPUSH
90483: CALL_OW 275
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: LIST
90492: ST_TO_ADDR
// end ;
90493: LD_VAR 0 2
90497: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
90498: LD_INT 0
90500: PPUSH
90501: PPUSH
// result := array ;
90502: LD_ADDR_VAR 0 3
90506: PUSH
90507: LD_VAR 0 1
90511: ST_TO_ADDR
// if size >= result then
90512: LD_VAR 0 2
90516: PUSH
90517: LD_VAR 0 3
90521: GREATEREQUAL
90522: IFFALSE 90526
// exit ;
90524: GO 90576
// if size then
90526: LD_VAR 0 2
90530: IFFALSE 90576
// for i := array downto size do
90532: LD_ADDR_VAR 0 4
90536: PUSH
90537: DOUBLE
90538: LD_VAR 0 1
90542: INC
90543: ST_TO_ADDR
90544: LD_VAR 0 2
90548: PUSH
90549: FOR_DOWNTO
90550: IFFALSE 90574
// result := Delete ( result , result ) ;
90552: LD_ADDR_VAR 0 3
90556: PUSH
90557: LD_VAR 0 3
90561: PPUSH
90562: LD_VAR 0 3
90566: PPUSH
90567: CALL_OW 3
90571: ST_TO_ADDR
90572: GO 90549
90574: POP
90575: POP
// end ;
90576: LD_VAR 0 3
90580: RET
// export function ComExit ( unit ) ; var tmp ; begin
90581: LD_INT 0
90583: PPUSH
90584: PPUSH
// if not IsInUnit ( unit ) then
90585: LD_VAR 0 1
90589: PPUSH
90590: CALL_OW 310
90594: NOT
90595: IFFALSE 90599
// exit ;
90597: GO 90659
// tmp := IsInUnit ( unit ) ;
90599: LD_ADDR_VAR 0 3
90603: PUSH
90604: LD_VAR 0 1
90608: PPUSH
90609: CALL_OW 310
90613: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
90614: LD_VAR 0 3
90618: PPUSH
90619: CALL_OW 247
90623: PUSH
90624: LD_INT 2
90626: EQUAL
90627: IFFALSE 90640
// ComExitVehicle ( unit ) else
90629: LD_VAR 0 1
90633: PPUSH
90634: CALL_OW 121
90638: GO 90649
// ComExitBuilding ( unit ) ;
90640: LD_VAR 0 1
90644: PPUSH
90645: CALL_OW 122
// result := tmp ;
90649: LD_ADDR_VAR 0 2
90653: PUSH
90654: LD_VAR 0 3
90658: ST_TO_ADDR
// end ;
90659: LD_VAR 0 2
90663: RET
// export function ComExitAll ( units ) ; var i ; begin
90664: LD_INT 0
90666: PPUSH
90667: PPUSH
// if not units then
90668: LD_VAR 0 1
90672: NOT
90673: IFFALSE 90677
// exit ;
90675: GO 90703
// for i in units do
90677: LD_ADDR_VAR 0 3
90681: PUSH
90682: LD_VAR 0 1
90686: PUSH
90687: FOR_IN
90688: IFFALSE 90701
// ComExit ( i ) ;
90690: LD_VAR 0 3
90694: PPUSH
90695: CALL 90581 0 1
90699: GO 90687
90701: POP
90702: POP
// end ;
90703: LD_VAR 0 2
90707: RET
// export function ResetHc ; begin
90708: LD_INT 0
90710: PPUSH
// InitHc ;
90711: CALL_OW 19
// hc_importance := 0 ;
90715: LD_ADDR_OWVAR 32
90719: PUSH
90720: LD_INT 0
90722: ST_TO_ADDR
// end ;
90723: LD_VAR 0 1
90727: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
90728: LD_INT 0
90730: PPUSH
90731: PPUSH
90732: PPUSH
// _x := ( x1 + x2 ) div 2 ;
90733: LD_ADDR_VAR 0 6
90737: PUSH
90738: LD_VAR 0 1
90742: PUSH
90743: LD_VAR 0 3
90747: PLUS
90748: PUSH
90749: LD_INT 2
90751: DIV
90752: ST_TO_ADDR
// if _x < 0 then
90753: LD_VAR 0 6
90757: PUSH
90758: LD_INT 0
90760: LESS
90761: IFFALSE 90778
// _x := _x * - 1 ;
90763: LD_ADDR_VAR 0 6
90767: PUSH
90768: LD_VAR 0 6
90772: PUSH
90773: LD_INT 1
90775: NEG
90776: MUL
90777: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
90778: LD_ADDR_VAR 0 7
90782: PUSH
90783: LD_VAR 0 2
90787: PUSH
90788: LD_VAR 0 4
90792: PLUS
90793: PUSH
90794: LD_INT 2
90796: DIV
90797: ST_TO_ADDR
// if _y < 0 then
90798: LD_VAR 0 7
90802: PUSH
90803: LD_INT 0
90805: LESS
90806: IFFALSE 90823
// _y := _y * - 1 ;
90808: LD_ADDR_VAR 0 7
90812: PUSH
90813: LD_VAR 0 7
90817: PUSH
90818: LD_INT 1
90820: NEG
90821: MUL
90822: ST_TO_ADDR
// result := [ _x , _y ] ;
90823: LD_ADDR_VAR 0 5
90827: PUSH
90828: LD_VAR 0 6
90832: PUSH
90833: LD_VAR 0 7
90837: PUSH
90838: EMPTY
90839: LIST
90840: LIST
90841: ST_TO_ADDR
// end ;
90842: LD_VAR 0 5
90846: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
90847: LD_INT 0
90849: PPUSH
90850: PPUSH
90851: PPUSH
90852: PPUSH
// task := GetTaskList ( unit ) ;
90853: LD_ADDR_VAR 0 7
90857: PUSH
90858: LD_VAR 0 1
90862: PPUSH
90863: CALL_OW 437
90867: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
90868: LD_VAR 0 7
90872: NOT
90873: PUSH
90874: LD_VAR 0 1
90878: PPUSH
90879: LD_VAR 0 2
90883: PPUSH
90884: CALL_OW 308
90888: NOT
90889: AND
90890: IFFALSE 90894
// exit ;
90892: GO 91012
// if IsInArea ( unit , area ) then
90894: LD_VAR 0 1
90898: PPUSH
90899: LD_VAR 0 2
90903: PPUSH
90904: CALL_OW 308
90908: IFFALSE 90926
// begin ComMoveToArea ( unit , goAway ) ;
90910: LD_VAR 0 1
90914: PPUSH
90915: LD_VAR 0 3
90919: PPUSH
90920: CALL_OW 113
// exit ;
90924: GO 91012
// end ; if task [ 1 ] [ 1 ] <> M then
90926: LD_VAR 0 7
90930: PUSH
90931: LD_INT 1
90933: ARRAY
90934: PUSH
90935: LD_INT 1
90937: ARRAY
90938: PUSH
90939: LD_STRING M
90941: NONEQUAL
90942: IFFALSE 90946
// exit ;
90944: GO 91012
// x := task [ 1 ] [ 2 ] ;
90946: LD_ADDR_VAR 0 5
90950: PUSH
90951: LD_VAR 0 7
90955: PUSH
90956: LD_INT 1
90958: ARRAY
90959: PUSH
90960: LD_INT 2
90962: ARRAY
90963: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
90964: LD_ADDR_VAR 0 6
90968: PUSH
90969: LD_VAR 0 7
90973: PUSH
90974: LD_INT 1
90976: ARRAY
90977: PUSH
90978: LD_INT 3
90980: ARRAY
90981: ST_TO_ADDR
// if InArea ( x , y , area ) then
90982: LD_VAR 0 5
90986: PPUSH
90987: LD_VAR 0 6
90991: PPUSH
90992: LD_VAR 0 2
90996: PPUSH
90997: CALL_OW 309
91001: IFFALSE 91012
// ComStop ( unit ) ;
91003: LD_VAR 0 1
91007: PPUSH
91008: CALL_OW 141
// end ;
91012: LD_VAR 0 4
91016: RET
// export function Abs ( value ) ; begin
91017: LD_INT 0
91019: PPUSH
// result := value ;
91020: LD_ADDR_VAR 0 2
91024: PUSH
91025: LD_VAR 0 1
91029: ST_TO_ADDR
// if value < 0 then
91030: LD_VAR 0 1
91034: PUSH
91035: LD_INT 0
91037: LESS
91038: IFFALSE 91055
// result := value * - 1 ;
91040: LD_ADDR_VAR 0 2
91044: PUSH
91045: LD_VAR 0 1
91049: PUSH
91050: LD_INT 1
91052: NEG
91053: MUL
91054: ST_TO_ADDR
// end ;
91055: LD_VAR 0 2
91059: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
91060: LD_INT 0
91062: PPUSH
91063: PPUSH
91064: PPUSH
91065: PPUSH
91066: PPUSH
91067: PPUSH
91068: PPUSH
91069: PPUSH
// if not unit or not building then
91070: LD_VAR 0 1
91074: NOT
91075: PUSH
91076: LD_VAR 0 2
91080: NOT
91081: OR
91082: IFFALSE 91086
// exit ;
91084: GO 91312
// x := GetX ( building ) ;
91086: LD_ADDR_VAR 0 4
91090: PUSH
91091: LD_VAR 0 2
91095: PPUSH
91096: CALL_OW 250
91100: ST_TO_ADDR
// y := GetY ( building ) ;
91101: LD_ADDR_VAR 0 6
91105: PUSH
91106: LD_VAR 0 2
91110: PPUSH
91111: CALL_OW 251
91115: ST_TO_ADDR
// d := GetDir ( building ) ;
91116: LD_ADDR_VAR 0 8
91120: PUSH
91121: LD_VAR 0 2
91125: PPUSH
91126: CALL_OW 254
91130: ST_TO_ADDR
// r := 4 ;
91131: LD_ADDR_VAR 0 9
91135: PUSH
91136: LD_INT 4
91138: ST_TO_ADDR
// for i := 1 to 5 do
91139: LD_ADDR_VAR 0 10
91143: PUSH
91144: DOUBLE
91145: LD_INT 1
91147: DEC
91148: ST_TO_ADDR
91149: LD_INT 5
91151: PUSH
91152: FOR_TO
91153: IFFALSE 91310
// begin _x := ShiftX ( x , d , r + i ) ;
91155: LD_ADDR_VAR 0 5
91159: PUSH
91160: LD_VAR 0 4
91164: PPUSH
91165: LD_VAR 0 8
91169: PPUSH
91170: LD_VAR 0 9
91174: PUSH
91175: LD_VAR 0 10
91179: PLUS
91180: PPUSH
91181: CALL_OW 272
91185: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
91186: LD_ADDR_VAR 0 7
91190: PUSH
91191: LD_VAR 0 6
91195: PPUSH
91196: LD_VAR 0 8
91200: PPUSH
91201: LD_VAR 0 9
91205: PUSH
91206: LD_VAR 0 10
91210: PLUS
91211: PPUSH
91212: CALL_OW 273
91216: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
91217: LD_VAR 0 5
91221: PPUSH
91222: LD_VAR 0 7
91226: PPUSH
91227: CALL_OW 488
91231: PUSH
91232: LD_VAR 0 5
91236: PPUSH
91237: LD_VAR 0 7
91241: PPUSH
91242: CALL_OW 428
91246: PPUSH
91247: CALL_OW 247
91251: PUSH
91252: LD_INT 3
91254: PUSH
91255: LD_INT 2
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: IN
91262: NOT
91263: AND
91264: IFFALSE 91308
// begin ComMoveXY ( unit , _x , _y ) ;
91266: LD_VAR 0 1
91270: PPUSH
91271: LD_VAR 0 5
91275: PPUSH
91276: LD_VAR 0 7
91280: PPUSH
91281: CALL_OW 111
// result := [ _x , _y ] ;
91285: LD_ADDR_VAR 0 3
91289: PUSH
91290: LD_VAR 0 5
91294: PUSH
91295: LD_VAR 0 7
91299: PUSH
91300: EMPTY
91301: LIST
91302: LIST
91303: ST_TO_ADDR
// exit ;
91304: POP
91305: POP
91306: GO 91312
// end ; end ;
91308: GO 91152
91310: POP
91311: POP
// end ;
91312: LD_VAR 0 3
91316: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
91317: LD_INT 0
91319: PPUSH
91320: PPUSH
91321: PPUSH
// result := 0 ;
91322: LD_ADDR_VAR 0 3
91326: PUSH
91327: LD_INT 0
91329: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
91330: LD_VAR 0 1
91334: PUSH
91335: LD_INT 0
91337: LESS
91338: PUSH
91339: LD_VAR 0 1
91343: PUSH
91344: LD_INT 8
91346: GREATER
91347: OR
91348: PUSH
91349: LD_VAR 0 2
91353: PUSH
91354: LD_INT 0
91356: LESS
91357: OR
91358: PUSH
91359: LD_VAR 0 2
91363: PUSH
91364: LD_INT 8
91366: GREATER
91367: OR
91368: IFFALSE 91372
// exit ;
91370: GO 91447
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
91372: LD_ADDR_VAR 0 4
91376: PUSH
91377: LD_INT 22
91379: PUSH
91380: LD_VAR 0 2
91384: PUSH
91385: EMPTY
91386: LIST
91387: LIST
91388: PPUSH
91389: CALL_OW 69
91393: PUSH
91394: FOR_IN
91395: IFFALSE 91445
// begin un := UnitShoot ( i ) ;
91397: LD_ADDR_VAR 0 5
91401: PUSH
91402: LD_VAR 0 4
91406: PPUSH
91407: CALL_OW 504
91411: ST_TO_ADDR
// if GetSide ( un ) = side1 then
91412: LD_VAR 0 5
91416: PPUSH
91417: CALL_OW 255
91421: PUSH
91422: LD_VAR 0 1
91426: EQUAL
91427: IFFALSE 91443
// begin result := un ;
91429: LD_ADDR_VAR 0 3
91433: PUSH
91434: LD_VAR 0 5
91438: ST_TO_ADDR
// exit ;
91439: POP
91440: POP
91441: GO 91447
// end ; end ;
91443: GO 91394
91445: POP
91446: POP
// end ;
91447: LD_VAR 0 3
91451: RET
// export function GetCargoBay ( units ) ; begin
91452: LD_INT 0
91454: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
91455: LD_ADDR_VAR 0 2
91459: PUSH
91460: LD_VAR 0 1
91464: PPUSH
91465: LD_INT 2
91467: PUSH
91468: LD_INT 34
91470: PUSH
91471: LD_INT 12
91473: PUSH
91474: EMPTY
91475: LIST
91476: LIST
91477: PUSH
91478: LD_INT 34
91480: PUSH
91481: LD_INT 51
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: PUSH
91488: LD_INT 34
91490: PUSH
91491: LD_INT 32
91493: PUSH
91494: EMPTY
91495: LIST
91496: LIST
91497: PUSH
91498: LD_INT 34
91500: PUSH
91501: LD_INT 89
91503: PUSH
91504: EMPTY
91505: LIST
91506: LIST
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: PPUSH
91515: CALL_OW 72
91519: ST_TO_ADDR
// end ;
91520: LD_VAR 0 2
91524: RET
// export function Negate ( value ) ; begin
91525: LD_INT 0
91527: PPUSH
// result := not value ;
91528: LD_ADDR_VAR 0 2
91532: PUSH
91533: LD_VAR 0 1
91537: NOT
91538: ST_TO_ADDR
// end ;
91539: LD_VAR 0 2
91543: RET
// export function Inc ( value ) ; begin
91544: LD_INT 0
91546: PPUSH
// result := value + 1 ;
91547: LD_ADDR_VAR 0 2
91551: PUSH
91552: LD_VAR 0 1
91556: PUSH
91557: LD_INT 1
91559: PLUS
91560: ST_TO_ADDR
// end ;
91561: LD_VAR 0 2
91565: RET
// export function Dec ( value ) ; begin
91566: LD_INT 0
91568: PPUSH
// result := value - 1 ;
91569: LD_ADDR_VAR 0 2
91573: PUSH
91574: LD_VAR 0 1
91578: PUSH
91579: LD_INT 1
91581: MINUS
91582: ST_TO_ADDR
// end ;
91583: LD_VAR 0 2
91587: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
91588: LD_INT 0
91590: PPUSH
91591: PPUSH
91592: PPUSH
91593: PPUSH
91594: PPUSH
91595: PPUSH
91596: PPUSH
91597: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
91598: LD_VAR 0 1
91602: PPUSH
91603: LD_VAR 0 2
91607: PPUSH
91608: CALL_OW 488
91612: NOT
91613: PUSH
91614: LD_VAR 0 3
91618: PPUSH
91619: LD_VAR 0 4
91623: PPUSH
91624: CALL_OW 488
91628: NOT
91629: OR
91630: IFFALSE 91643
// begin result := - 1 ;
91632: LD_ADDR_VAR 0 5
91636: PUSH
91637: LD_INT 1
91639: NEG
91640: ST_TO_ADDR
// exit ;
91641: GO 91878
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
91643: LD_ADDR_VAR 0 12
91647: PUSH
91648: LD_VAR 0 1
91652: PPUSH
91653: LD_VAR 0 2
91657: PPUSH
91658: LD_VAR 0 3
91662: PPUSH
91663: LD_VAR 0 4
91667: PPUSH
91668: CALL 90728 0 4
91672: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
91673: LD_ADDR_VAR 0 11
91677: PUSH
91678: LD_VAR 0 1
91682: PPUSH
91683: LD_VAR 0 2
91687: PPUSH
91688: LD_VAR 0 12
91692: PUSH
91693: LD_INT 1
91695: ARRAY
91696: PPUSH
91697: LD_VAR 0 12
91701: PUSH
91702: LD_INT 2
91704: ARRAY
91705: PPUSH
91706: CALL_OW 298
91710: ST_TO_ADDR
// distance := 9999 ;
91711: LD_ADDR_VAR 0 10
91715: PUSH
91716: LD_INT 9999
91718: ST_TO_ADDR
// for i := 0 to 5 do
91719: LD_ADDR_VAR 0 6
91723: PUSH
91724: DOUBLE
91725: LD_INT 0
91727: DEC
91728: ST_TO_ADDR
91729: LD_INT 5
91731: PUSH
91732: FOR_TO
91733: IFFALSE 91876
// begin _x := ShiftX ( x1 , i , centerDist ) ;
91735: LD_ADDR_VAR 0 7
91739: PUSH
91740: LD_VAR 0 1
91744: PPUSH
91745: LD_VAR 0 6
91749: PPUSH
91750: LD_VAR 0 11
91754: PPUSH
91755: CALL_OW 272
91759: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
91760: LD_ADDR_VAR 0 8
91764: PUSH
91765: LD_VAR 0 2
91769: PPUSH
91770: LD_VAR 0 6
91774: PPUSH
91775: LD_VAR 0 11
91779: PPUSH
91780: CALL_OW 273
91784: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
91785: LD_VAR 0 7
91789: PPUSH
91790: LD_VAR 0 8
91794: PPUSH
91795: CALL_OW 488
91799: NOT
91800: IFFALSE 91804
// continue ;
91802: GO 91732
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
91804: LD_ADDR_VAR 0 9
91808: PUSH
91809: LD_VAR 0 12
91813: PUSH
91814: LD_INT 1
91816: ARRAY
91817: PPUSH
91818: LD_VAR 0 12
91822: PUSH
91823: LD_INT 2
91825: ARRAY
91826: PPUSH
91827: LD_VAR 0 7
91831: PPUSH
91832: LD_VAR 0 8
91836: PPUSH
91837: CALL_OW 298
91841: ST_TO_ADDR
// if tmp < distance then
91842: LD_VAR 0 9
91846: PUSH
91847: LD_VAR 0 10
91851: LESS
91852: IFFALSE 91874
// begin result := i ;
91854: LD_ADDR_VAR 0 5
91858: PUSH
91859: LD_VAR 0 6
91863: ST_TO_ADDR
// distance := tmp ;
91864: LD_ADDR_VAR 0 10
91868: PUSH
91869: LD_VAR 0 9
91873: ST_TO_ADDR
// end ; end ;
91874: GO 91732
91876: POP
91877: POP
// end ;
91878: LD_VAR 0 5
91882: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91883: LD_INT 0
91885: PPUSH
91886: PPUSH
// if not driver or not IsInUnit ( driver ) then
91887: LD_VAR 0 1
91891: NOT
91892: PUSH
91893: LD_VAR 0 1
91897: PPUSH
91898: CALL_OW 310
91902: NOT
91903: OR
91904: IFFALSE 91908
// exit ;
91906: GO 91998
// vehicle := IsInUnit ( driver ) ;
91908: LD_ADDR_VAR 0 3
91912: PUSH
91913: LD_VAR 0 1
91917: PPUSH
91918: CALL_OW 310
91922: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91923: LD_VAR 0 1
91927: PPUSH
91928: LD_STRING \
91930: PUSH
91931: LD_INT 0
91933: PUSH
91934: LD_INT 0
91936: PUSH
91937: LD_INT 0
91939: PUSH
91940: LD_INT 0
91942: PUSH
91943: LD_INT 0
91945: PUSH
91946: LD_INT 0
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: LIST
91953: LIST
91954: LIST
91955: LIST
91956: LIST
91957: PUSH
91958: LD_STRING E
91960: PUSH
91961: LD_INT 0
91963: PUSH
91964: LD_INT 0
91966: PUSH
91967: LD_VAR 0 3
91971: PUSH
91972: LD_INT 0
91974: PUSH
91975: LD_INT 0
91977: PUSH
91978: LD_INT 0
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PPUSH
91994: CALL_OW 446
// end ;
91998: LD_VAR 0 2
92002: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92003: LD_INT 0
92005: PPUSH
92006: PPUSH
// if not driver or not IsInUnit ( driver ) then
92007: LD_VAR 0 1
92011: NOT
92012: PUSH
92013: LD_VAR 0 1
92017: PPUSH
92018: CALL_OW 310
92022: NOT
92023: OR
92024: IFFALSE 92028
// exit ;
92026: GO 92118
// vehicle := IsInUnit ( driver ) ;
92028: LD_ADDR_VAR 0 3
92032: PUSH
92033: LD_VAR 0 1
92037: PPUSH
92038: CALL_OW 310
92042: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
92043: LD_VAR 0 1
92047: PPUSH
92048: LD_STRING \
92050: PUSH
92051: LD_INT 0
92053: PUSH
92054: LD_INT 0
92056: PUSH
92057: LD_INT 0
92059: PUSH
92060: LD_INT 0
92062: PUSH
92063: LD_INT 0
92065: PUSH
92066: LD_INT 0
92068: PUSH
92069: EMPTY
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: PUSH
92078: LD_STRING E
92080: PUSH
92081: LD_INT 0
92083: PUSH
92084: LD_INT 0
92086: PUSH
92087: LD_VAR 0 3
92091: PUSH
92092: LD_INT 0
92094: PUSH
92095: LD_INT 0
92097: PUSH
92098: LD_INT 0
92100: PUSH
92101: EMPTY
92102: LIST
92103: LIST
92104: LIST
92105: LIST
92106: LIST
92107: LIST
92108: LIST
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PPUSH
92114: CALL_OW 447
// end ;
92118: LD_VAR 0 2
92122: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
92123: LD_INT 0
92125: PPUSH
92126: PPUSH
92127: PPUSH
// tmp := [ ] ;
92128: LD_ADDR_VAR 0 5
92132: PUSH
92133: EMPTY
92134: ST_TO_ADDR
// for i in units do
92135: LD_ADDR_VAR 0 4
92139: PUSH
92140: LD_VAR 0 1
92144: PUSH
92145: FOR_IN
92146: IFFALSE 92184
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
92148: LD_ADDR_VAR 0 5
92152: PUSH
92153: LD_VAR 0 5
92157: PPUSH
92158: LD_VAR 0 5
92162: PUSH
92163: LD_INT 1
92165: PLUS
92166: PPUSH
92167: LD_VAR 0 4
92171: PPUSH
92172: CALL_OW 256
92176: PPUSH
92177: CALL_OW 2
92181: ST_TO_ADDR
92182: GO 92145
92184: POP
92185: POP
// if not tmp then
92186: LD_VAR 0 5
92190: NOT
92191: IFFALSE 92195
// exit ;
92193: GO 92243
// if asc then
92195: LD_VAR 0 2
92199: IFFALSE 92223
// result := SortListByListAsc ( units , tmp ) else
92201: LD_ADDR_VAR 0 3
92205: PUSH
92206: LD_VAR 0 1
92210: PPUSH
92211: LD_VAR 0 5
92215: PPUSH
92216: CALL_OW 76
92220: ST_TO_ADDR
92221: GO 92243
// result := SortListByListDesc ( units , tmp ) ;
92223: LD_ADDR_VAR 0 3
92227: PUSH
92228: LD_VAR 0 1
92232: PPUSH
92233: LD_VAR 0 5
92237: PPUSH
92238: CALL_OW 77
92242: ST_TO_ADDR
// end ;
92243: LD_VAR 0 3
92247: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
92248: LD_INT 0
92250: PPUSH
92251: PPUSH
// task := GetTaskList ( mech ) ;
92252: LD_ADDR_VAR 0 4
92256: PUSH
92257: LD_VAR 0 1
92261: PPUSH
92262: CALL_OW 437
92266: ST_TO_ADDR
// if not task then
92267: LD_VAR 0 4
92271: NOT
92272: IFFALSE 92276
// exit ;
92274: GO 92318
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
92276: LD_ADDR_VAR 0 3
92280: PUSH
92281: LD_VAR 0 4
92285: PUSH
92286: LD_INT 1
92288: ARRAY
92289: PUSH
92290: LD_INT 1
92292: ARRAY
92293: PUSH
92294: LD_STRING r
92296: EQUAL
92297: PUSH
92298: LD_VAR 0 4
92302: PUSH
92303: LD_INT 1
92305: ARRAY
92306: PUSH
92307: LD_INT 4
92309: ARRAY
92310: PUSH
92311: LD_VAR 0 2
92315: EQUAL
92316: AND
92317: ST_TO_ADDR
// end ;
92318: LD_VAR 0 3
92322: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
92323: LD_INT 0
92325: PPUSH
// SetDir ( unit , d ) ;
92326: LD_VAR 0 1
92330: PPUSH
92331: LD_VAR 0 4
92335: PPUSH
92336: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
92340: LD_VAR 0 1
92344: PPUSH
92345: LD_VAR 0 2
92349: PPUSH
92350: LD_VAR 0 3
92354: PPUSH
92355: LD_VAR 0 5
92359: PPUSH
92360: CALL_OW 48
// end ;
92364: LD_VAR 0 6
92368: RET
// export function ToNaturalNumber ( number ) ; begin
92369: LD_INT 0
92371: PPUSH
// result := number div 1 ;
92372: LD_ADDR_VAR 0 2
92376: PUSH
92377: LD_VAR 0 1
92381: PUSH
92382: LD_INT 1
92384: DIV
92385: ST_TO_ADDR
// if number < 0 then
92386: LD_VAR 0 1
92390: PUSH
92391: LD_INT 0
92393: LESS
92394: IFFALSE 92404
// result := 0 ;
92396: LD_ADDR_VAR 0 2
92400: PUSH
92401: LD_INT 0
92403: ST_TO_ADDR
// end ;
92404: LD_VAR 0 2
92408: RET
// export function SortByClass ( units , class ) ; var un ; begin
92409: LD_INT 0
92411: PPUSH
92412: PPUSH
// if not units or not class then
92413: LD_VAR 0 1
92417: NOT
92418: PUSH
92419: LD_VAR 0 2
92423: NOT
92424: OR
92425: IFFALSE 92429
// exit ;
92427: GO 92524
// result := [ ] ;
92429: LD_ADDR_VAR 0 3
92433: PUSH
92434: EMPTY
92435: ST_TO_ADDR
// for un in units do
92436: LD_ADDR_VAR 0 4
92440: PUSH
92441: LD_VAR 0 1
92445: PUSH
92446: FOR_IN
92447: IFFALSE 92522
// if GetClass ( un ) = class then
92449: LD_VAR 0 4
92453: PPUSH
92454: CALL_OW 257
92458: PUSH
92459: LD_VAR 0 2
92463: EQUAL
92464: IFFALSE 92491
// result := Insert ( result , 1 , un ) else
92466: LD_ADDR_VAR 0 3
92470: PUSH
92471: LD_VAR 0 3
92475: PPUSH
92476: LD_INT 1
92478: PPUSH
92479: LD_VAR 0 4
92483: PPUSH
92484: CALL_OW 2
92488: ST_TO_ADDR
92489: GO 92520
// result := Replace ( result , result + 1 , un ) ;
92491: LD_ADDR_VAR 0 3
92495: PUSH
92496: LD_VAR 0 3
92500: PPUSH
92501: LD_VAR 0 3
92505: PUSH
92506: LD_INT 1
92508: PLUS
92509: PPUSH
92510: LD_VAR 0 4
92514: PPUSH
92515: CALL_OW 1
92519: ST_TO_ADDR
92520: GO 92446
92522: POP
92523: POP
// end ;
92524: LD_VAR 0 3
92528: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
92529: LD_INT 0
92531: PPUSH
92532: PPUSH
92533: PPUSH
92534: PPUSH
92535: PPUSH
92536: PPUSH
92537: PPUSH
// result := [ ] ;
92538: LD_ADDR_VAR 0 4
92542: PUSH
92543: EMPTY
92544: ST_TO_ADDR
// if x - r < 0 then
92545: LD_VAR 0 1
92549: PUSH
92550: LD_VAR 0 3
92554: MINUS
92555: PUSH
92556: LD_INT 0
92558: LESS
92559: IFFALSE 92571
// min_x := 0 else
92561: LD_ADDR_VAR 0 8
92565: PUSH
92566: LD_INT 0
92568: ST_TO_ADDR
92569: GO 92587
// min_x := x - r ;
92571: LD_ADDR_VAR 0 8
92575: PUSH
92576: LD_VAR 0 1
92580: PUSH
92581: LD_VAR 0 3
92585: MINUS
92586: ST_TO_ADDR
// if y - r < 0 then
92587: LD_VAR 0 2
92591: PUSH
92592: LD_VAR 0 3
92596: MINUS
92597: PUSH
92598: LD_INT 0
92600: LESS
92601: IFFALSE 92613
// min_y := 0 else
92603: LD_ADDR_VAR 0 7
92607: PUSH
92608: LD_INT 0
92610: ST_TO_ADDR
92611: GO 92629
// min_y := y - r ;
92613: LD_ADDR_VAR 0 7
92617: PUSH
92618: LD_VAR 0 2
92622: PUSH
92623: LD_VAR 0 3
92627: MINUS
92628: ST_TO_ADDR
// max_x := x + r ;
92629: LD_ADDR_VAR 0 9
92633: PUSH
92634: LD_VAR 0 1
92638: PUSH
92639: LD_VAR 0 3
92643: PLUS
92644: ST_TO_ADDR
// max_y := y + r ;
92645: LD_ADDR_VAR 0 10
92649: PUSH
92650: LD_VAR 0 2
92654: PUSH
92655: LD_VAR 0 3
92659: PLUS
92660: ST_TO_ADDR
// for _x = min_x to max_x do
92661: LD_ADDR_VAR 0 5
92665: PUSH
92666: DOUBLE
92667: LD_VAR 0 8
92671: DEC
92672: ST_TO_ADDR
92673: LD_VAR 0 9
92677: PUSH
92678: FOR_TO
92679: IFFALSE 92780
// for _y = min_y to max_y do
92681: LD_ADDR_VAR 0 6
92685: PUSH
92686: DOUBLE
92687: LD_VAR 0 7
92691: DEC
92692: ST_TO_ADDR
92693: LD_VAR 0 10
92697: PUSH
92698: FOR_TO
92699: IFFALSE 92776
// begin if not ValidHex ( _x , _y ) then
92701: LD_VAR 0 5
92705: PPUSH
92706: LD_VAR 0 6
92710: PPUSH
92711: CALL_OW 488
92715: NOT
92716: IFFALSE 92720
// continue ;
92718: GO 92698
// if GetResourceTypeXY ( _x , _y ) then
92720: LD_VAR 0 5
92724: PPUSH
92725: LD_VAR 0 6
92729: PPUSH
92730: CALL_OW 283
92734: IFFALSE 92774
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
92736: LD_ADDR_VAR 0 4
92740: PUSH
92741: LD_VAR 0 4
92745: PPUSH
92746: LD_VAR 0 4
92750: PUSH
92751: LD_INT 1
92753: PLUS
92754: PPUSH
92755: LD_VAR 0 5
92759: PUSH
92760: LD_VAR 0 6
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PPUSH
92769: CALL_OW 1
92773: ST_TO_ADDR
// end ;
92774: GO 92698
92776: POP
92777: POP
92778: GO 92678
92780: POP
92781: POP
// end ;
92782: LD_VAR 0 4
92786: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
92787: LD_INT 0
92789: PPUSH
92790: PPUSH
92791: PPUSH
92792: PPUSH
92793: PPUSH
92794: PPUSH
92795: PPUSH
92796: PPUSH
// if not units then
92797: LD_VAR 0 1
92801: NOT
92802: IFFALSE 92806
// exit ;
92804: GO 93330
// result := UnitFilter ( units , [ f_ok ] ) ;
92806: LD_ADDR_VAR 0 3
92810: PUSH
92811: LD_VAR 0 1
92815: PPUSH
92816: LD_INT 50
92818: PUSH
92819: EMPTY
92820: LIST
92821: PPUSH
92822: CALL_OW 72
92826: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
92827: LD_ADDR_VAR 0 8
92831: PUSH
92832: LD_VAR 0 1
92836: PUSH
92837: LD_INT 1
92839: ARRAY
92840: PPUSH
92841: CALL_OW 255
92845: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
92846: LD_ADDR_VAR 0 10
92850: PUSH
92851: LD_INT 29
92853: PUSH
92854: LD_INT 91
92856: PUSH
92857: LD_INT 49
92859: PUSH
92860: EMPTY
92861: LIST
92862: LIST
92863: LIST
92864: ST_TO_ADDR
// if not result then
92865: LD_VAR 0 3
92869: NOT
92870: IFFALSE 92874
// exit ;
92872: GO 93330
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
92874: LD_ADDR_VAR 0 5
92878: PUSH
92879: LD_INT 81
92881: PUSH
92882: LD_VAR 0 8
92886: PUSH
92887: EMPTY
92888: LIST
92889: LIST
92890: PPUSH
92891: CALL_OW 69
92895: ST_TO_ADDR
// for i in result do
92896: LD_ADDR_VAR 0 4
92900: PUSH
92901: LD_VAR 0 3
92905: PUSH
92906: FOR_IN
92907: IFFALSE 93328
// begin tag := GetTag ( i ) + 1 ;
92909: LD_ADDR_VAR 0 9
92913: PUSH
92914: LD_VAR 0 4
92918: PPUSH
92919: CALL_OW 110
92923: PUSH
92924: LD_INT 1
92926: PLUS
92927: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
92928: LD_ADDR_VAR 0 7
92932: PUSH
92933: LD_VAR 0 4
92937: PPUSH
92938: CALL_OW 250
92942: PPUSH
92943: LD_VAR 0 4
92947: PPUSH
92948: CALL_OW 251
92952: PPUSH
92953: LD_INT 6
92955: PPUSH
92956: CALL 92529 0 3
92960: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
92961: LD_VAR 0 4
92965: PPUSH
92966: CALL_OW 247
92970: PUSH
92971: LD_INT 2
92973: EQUAL
92974: PUSH
92975: LD_VAR 0 7
92979: AND
92980: PUSH
92981: LD_VAR 0 4
92985: PPUSH
92986: CALL_OW 264
92990: PUSH
92991: LD_VAR 0 10
92995: IN
92996: NOT
92997: AND
92998: IFFALSE 93037
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
93000: LD_VAR 0 4
93004: PPUSH
93005: LD_VAR 0 7
93009: PUSH
93010: LD_INT 1
93012: ARRAY
93013: PUSH
93014: LD_INT 1
93016: ARRAY
93017: PPUSH
93018: LD_VAR 0 7
93022: PUSH
93023: LD_INT 1
93025: ARRAY
93026: PUSH
93027: LD_INT 2
93029: ARRAY
93030: PPUSH
93031: CALL_OW 116
93035: GO 93326
// if path > tag then
93037: LD_VAR 0 2
93041: PUSH
93042: LD_VAR 0 9
93046: GREATER
93047: IFFALSE 93255
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
93049: LD_ADDR_VAR 0 6
93053: PUSH
93054: LD_VAR 0 5
93058: PPUSH
93059: LD_INT 91
93061: PUSH
93062: LD_VAR 0 4
93066: PUSH
93067: LD_INT 8
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: LIST
93074: PPUSH
93075: CALL_OW 72
93079: ST_TO_ADDR
// if nearEnemy then
93080: LD_VAR 0 6
93084: IFFALSE 93153
// begin if GetWeapon ( i ) = ru_time_lapser then
93086: LD_VAR 0 4
93090: PPUSH
93091: CALL_OW 264
93095: PUSH
93096: LD_INT 49
93098: EQUAL
93099: IFFALSE 93127
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
93101: LD_VAR 0 4
93105: PPUSH
93106: LD_VAR 0 6
93110: PPUSH
93111: LD_VAR 0 4
93115: PPUSH
93116: CALL_OW 74
93120: PPUSH
93121: CALL_OW 112
93125: GO 93151
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
93127: LD_VAR 0 4
93131: PPUSH
93132: LD_VAR 0 6
93136: PPUSH
93137: LD_VAR 0 4
93141: PPUSH
93142: CALL_OW 74
93146: PPUSH
93147: CALL 94255 0 2
// end else
93151: GO 93253
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
93153: LD_VAR 0 4
93157: PPUSH
93158: LD_VAR 0 2
93162: PUSH
93163: LD_VAR 0 9
93167: ARRAY
93168: PUSH
93169: LD_INT 1
93171: ARRAY
93172: PPUSH
93173: LD_VAR 0 2
93177: PUSH
93178: LD_VAR 0 9
93182: ARRAY
93183: PUSH
93184: LD_INT 2
93186: ARRAY
93187: PPUSH
93188: CALL_OW 297
93192: PUSH
93193: LD_INT 6
93195: GREATER
93196: IFFALSE 93239
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
93198: LD_VAR 0 4
93202: PPUSH
93203: LD_VAR 0 2
93207: PUSH
93208: LD_VAR 0 9
93212: ARRAY
93213: PUSH
93214: LD_INT 1
93216: ARRAY
93217: PPUSH
93218: LD_VAR 0 2
93222: PUSH
93223: LD_VAR 0 9
93227: ARRAY
93228: PUSH
93229: LD_INT 2
93231: ARRAY
93232: PPUSH
93233: CALL_OW 114
93237: GO 93253
// SetTag ( i , tag ) ;
93239: LD_VAR 0 4
93243: PPUSH
93244: LD_VAR 0 9
93248: PPUSH
93249: CALL_OW 109
// end else
93253: GO 93326
// if enemy then
93255: LD_VAR 0 5
93259: IFFALSE 93326
// begin if GetWeapon ( i ) = ru_time_lapser then
93261: LD_VAR 0 4
93265: PPUSH
93266: CALL_OW 264
93270: PUSH
93271: LD_INT 49
93273: EQUAL
93274: IFFALSE 93302
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
93276: LD_VAR 0 4
93280: PPUSH
93281: LD_VAR 0 5
93285: PPUSH
93286: LD_VAR 0 4
93290: PPUSH
93291: CALL_OW 74
93295: PPUSH
93296: CALL_OW 112
93300: GO 93326
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
93302: LD_VAR 0 4
93306: PPUSH
93307: LD_VAR 0 5
93311: PPUSH
93312: LD_VAR 0 4
93316: PPUSH
93317: CALL_OW 74
93321: PPUSH
93322: CALL 94255 0 2
// end ; end ;
93326: GO 92906
93328: POP
93329: POP
// end ;
93330: LD_VAR 0 3
93334: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
93335: LD_INT 0
93337: PPUSH
93338: PPUSH
93339: PPUSH
// if not unit or IsInUnit ( unit ) then
93340: LD_VAR 0 1
93344: NOT
93345: PUSH
93346: LD_VAR 0 1
93350: PPUSH
93351: CALL_OW 310
93355: OR
93356: IFFALSE 93360
// exit ;
93358: GO 93451
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
93360: LD_ADDR_VAR 0 4
93364: PUSH
93365: LD_VAR 0 1
93369: PPUSH
93370: CALL_OW 250
93374: PPUSH
93375: LD_VAR 0 2
93379: PPUSH
93380: LD_INT 1
93382: PPUSH
93383: CALL_OW 272
93387: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
93388: LD_ADDR_VAR 0 5
93392: PUSH
93393: LD_VAR 0 1
93397: PPUSH
93398: CALL_OW 251
93402: PPUSH
93403: LD_VAR 0 2
93407: PPUSH
93408: LD_INT 1
93410: PPUSH
93411: CALL_OW 273
93415: ST_TO_ADDR
// if ValidHex ( x , y ) then
93416: LD_VAR 0 4
93420: PPUSH
93421: LD_VAR 0 5
93425: PPUSH
93426: CALL_OW 488
93430: IFFALSE 93451
// ComTurnXY ( unit , x , y ) ;
93432: LD_VAR 0 1
93436: PPUSH
93437: LD_VAR 0 4
93441: PPUSH
93442: LD_VAR 0 5
93446: PPUSH
93447: CALL_OW 118
// end ;
93451: LD_VAR 0 3
93455: RET
// export function SeeUnits ( side , units ) ; var i ; begin
93456: LD_INT 0
93458: PPUSH
93459: PPUSH
// result := false ;
93460: LD_ADDR_VAR 0 3
93464: PUSH
93465: LD_INT 0
93467: ST_TO_ADDR
// if not units then
93468: LD_VAR 0 2
93472: NOT
93473: IFFALSE 93477
// exit ;
93475: GO 93522
// for i in units do
93477: LD_ADDR_VAR 0 4
93481: PUSH
93482: LD_VAR 0 2
93486: PUSH
93487: FOR_IN
93488: IFFALSE 93520
// if See ( side , i ) then
93490: LD_VAR 0 1
93494: PPUSH
93495: LD_VAR 0 4
93499: PPUSH
93500: CALL_OW 292
93504: IFFALSE 93518
// begin result := true ;
93506: LD_ADDR_VAR 0 3
93510: PUSH
93511: LD_INT 1
93513: ST_TO_ADDR
// exit ;
93514: POP
93515: POP
93516: GO 93522
// end ;
93518: GO 93487
93520: POP
93521: POP
// end ;
93522: LD_VAR 0 3
93526: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
93527: LD_INT 0
93529: PPUSH
93530: PPUSH
93531: PPUSH
93532: PPUSH
// if not unit or not points then
93533: LD_VAR 0 1
93537: NOT
93538: PUSH
93539: LD_VAR 0 2
93543: NOT
93544: OR
93545: IFFALSE 93549
// exit ;
93547: GO 93639
// dist := 99999 ;
93549: LD_ADDR_VAR 0 5
93553: PUSH
93554: LD_INT 99999
93556: ST_TO_ADDR
// for i in points do
93557: LD_ADDR_VAR 0 4
93561: PUSH
93562: LD_VAR 0 2
93566: PUSH
93567: FOR_IN
93568: IFFALSE 93637
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
93570: LD_ADDR_VAR 0 6
93574: PUSH
93575: LD_VAR 0 1
93579: PPUSH
93580: LD_VAR 0 4
93584: PUSH
93585: LD_INT 1
93587: ARRAY
93588: PPUSH
93589: LD_VAR 0 4
93593: PUSH
93594: LD_INT 2
93596: ARRAY
93597: PPUSH
93598: CALL_OW 297
93602: ST_TO_ADDR
// if tmpDist < dist then
93603: LD_VAR 0 6
93607: PUSH
93608: LD_VAR 0 5
93612: LESS
93613: IFFALSE 93635
// begin result := i ;
93615: LD_ADDR_VAR 0 3
93619: PUSH
93620: LD_VAR 0 4
93624: ST_TO_ADDR
// dist := tmpDist ;
93625: LD_ADDR_VAR 0 5
93629: PUSH
93630: LD_VAR 0 6
93634: ST_TO_ADDR
// end ; end ;
93635: GO 93567
93637: POP
93638: POP
// end ;
93639: LD_VAR 0 3
93643: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
93644: LD_INT 0
93646: PPUSH
// uc_side := side ;
93647: LD_ADDR_OWVAR 20
93651: PUSH
93652: LD_VAR 0 1
93656: ST_TO_ADDR
// uc_nation := 3 ;
93657: LD_ADDR_OWVAR 21
93661: PUSH
93662: LD_INT 3
93664: ST_TO_ADDR
// vc_chassis := 25 ;
93665: LD_ADDR_OWVAR 37
93669: PUSH
93670: LD_INT 25
93672: ST_TO_ADDR
// vc_engine := engine_siberite ;
93673: LD_ADDR_OWVAR 39
93677: PUSH
93678: LD_INT 3
93680: ST_TO_ADDR
// vc_control := control_computer ;
93681: LD_ADDR_OWVAR 38
93685: PUSH
93686: LD_INT 3
93688: ST_TO_ADDR
// vc_weapon := 59 ;
93689: LD_ADDR_OWVAR 40
93693: PUSH
93694: LD_INT 59
93696: ST_TO_ADDR
// result := CreateVehicle ;
93697: LD_ADDR_VAR 0 5
93701: PUSH
93702: CALL_OW 45
93706: ST_TO_ADDR
// SetDir ( result , d ) ;
93707: LD_VAR 0 5
93711: PPUSH
93712: LD_VAR 0 4
93716: PPUSH
93717: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
93721: LD_VAR 0 5
93725: PPUSH
93726: LD_VAR 0 2
93730: PPUSH
93731: LD_VAR 0 3
93735: PPUSH
93736: LD_INT 0
93738: PPUSH
93739: CALL_OW 48
// end ;
93743: LD_VAR 0 5
93747: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
93748: LD_INT 0
93750: PPUSH
93751: PPUSH
93752: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
93753: LD_ADDR_VAR 0 2
93757: PUSH
93758: LD_INT 0
93760: PUSH
93761: LD_INT 0
93763: PUSH
93764: LD_INT 0
93766: PUSH
93767: LD_INT 0
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
93776: LD_VAR 0 1
93780: NOT
93781: PUSH
93782: LD_VAR 0 1
93786: PPUSH
93787: CALL_OW 264
93791: PUSH
93792: LD_INT 12
93794: PUSH
93795: LD_INT 51
93797: PUSH
93798: LD_INT 32
93800: PUSH
93801: LD_INT 89
93803: PUSH
93804: EMPTY
93805: LIST
93806: LIST
93807: LIST
93808: LIST
93809: IN
93810: NOT
93811: OR
93812: IFFALSE 93816
// exit ;
93814: GO 93914
// for i := 1 to 3 do
93816: LD_ADDR_VAR 0 3
93820: PUSH
93821: DOUBLE
93822: LD_INT 1
93824: DEC
93825: ST_TO_ADDR
93826: LD_INT 3
93828: PUSH
93829: FOR_TO
93830: IFFALSE 93912
// begin tmp := GetCargo ( cargo , i ) ;
93832: LD_ADDR_VAR 0 4
93836: PUSH
93837: LD_VAR 0 1
93841: PPUSH
93842: LD_VAR 0 3
93846: PPUSH
93847: CALL_OW 289
93851: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
93852: LD_ADDR_VAR 0 2
93856: PUSH
93857: LD_VAR 0 2
93861: PPUSH
93862: LD_VAR 0 3
93866: PPUSH
93867: LD_VAR 0 4
93871: PPUSH
93872: CALL_OW 1
93876: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
93877: LD_ADDR_VAR 0 2
93881: PUSH
93882: LD_VAR 0 2
93886: PPUSH
93887: LD_INT 4
93889: PPUSH
93890: LD_VAR 0 2
93894: PUSH
93895: LD_INT 4
93897: ARRAY
93898: PUSH
93899: LD_VAR 0 4
93903: PLUS
93904: PPUSH
93905: CALL_OW 1
93909: ST_TO_ADDR
// end ;
93910: GO 93829
93912: POP
93913: POP
// end ;
93914: LD_VAR 0 2
93918: RET
// export function Length ( array ) ; begin
93919: LD_INT 0
93921: PPUSH
// result := array + 0 ;
93922: LD_ADDR_VAR 0 2
93926: PUSH
93927: LD_VAR 0 1
93931: PUSH
93932: LD_INT 0
93934: PLUS
93935: ST_TO_ADDR
// end ;
93936: LD_VAR 0 2
93940: RET
// export function PrepareArray ( array ) ; begin
93941: LD_INT 0
93943: PPUSH
// result := array diff 0 ;
93944: LD_ADDR_VAR 0 2
93948: PUSH
93949: LD_VAR 0 1
93953: PUSH
93954: LD_INT 0
93956: DIFF
93957: ST_TO_ADDR
// if not result [ 1 ] then
93958: LD_VAR 0 2
93962: PUSH
93963: LD_INT 1
93965: ARRAY
93966: NOT
93967: IFFALSE 93987
// result := Delete ( result , 1 ) ;
93969: LD_ADDR_VAR 0 2
93973: PUSH
93974: LD_VAR 0 2
93978: PPUSH
93979: LD_INT 1
93981: PPUSH
93982: CALL_OW 3
93986: ST_TO_ADDR
// end ;
93987: LD_VAR 0 2
93991: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
93992: LD_INT 0
93994: PPUSH
93995: PPUSH
93996: PPUSH
93997: PPUSH
// sibRocketRange := 25 ;
93998: LD_ADDR_VAR 0 6
94002: PUSH
94003: LD_INT 25
94005: ST_TO_ADDR
// result := false ;
94006: LD_ADDR_VAR 0 4
94010: PUSH
94011: LD_INT 0
94013: ST_TO_ADDR
// for i := 0 to 5 do
94014: LD_ADDR_VAR 0 5
94018: PUSH
94019: DOUBLE
94020: LD_INT 0
94022: DEC
94023: ST_TO_ADDR
94024: LD_INT 5
94026: PUSH
94027: FOR_TO
94028: IFFALSE 94095
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
94030: LD_VAR 0 1
94034: PPUSH
94035: LD_VAR 0 5
94039: PPUSH
94040: LD_VAR 0 6
94044: PPUSH
94045: CALL_OW 272
94049: PPUSH
94050: LD_VAR 0 2
94054: PPUSH
94055: LD_VAR 0 5
94059: PPUSH
94060: LD_VAR 0 6
94064: PPUSH
94065: CALL_OW 273
94069: PPUSH
94070: LD_VAR 0 3
94074: PPUSH
94075: CALL_OW 309
94079: IFFALSE 94093
// begin result := true ;
94081: LD_ADDR_VAR 0 4
94085: PUSH
94086: LD_INT 1
94088: ST_TO_ADDR
// exit ;
94089: POP
94090: POP
94091: GO 94097
// end ;
94093: GO 94027
94095: POP
94096: POP
// end ;
94097: LD_VAR 0 4
94101: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
94102: LD_INT 0
94104: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
94105: LD_VAR 0 1
94109: PPUSH
94110: LD_VAR 0 2
94114: PPUSH
94115: LD_INT 0
94117: PPUSH
94118: LD_INT 0
94120: PPUSH
94121: LD_INT 1
94123: PPUSH
94124: LD_INT 0
94126: PPUSH
94127: CALL_OW 587
// end ;
94131: LD_VAR 0 3
94135: RET
// export function CenterOnNow ( unit ) ; begin
94136: LD_INT 0
94138: PPUSH
// result := IsInUnit ( unit ) ;
94139: LD_ADDR_VAR 0 2
94143: PUSH
94144: LD_VAR 0 1
94148: PPUSH
94149: CALL_OW 310
94153: ST_TO_ADDR
// if not result then
94154: LD_VAR 0 2
94158: NOT
94159: IFFALSE 94171
// result := unit ;
94161: LD_ADDR_VAR 0 2
94165: PUSH
94166: LD_VAR 0 1
94170: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
94171: LD_VAR 0 1
94175: PPUSH
94176: CALL_OW 87
// end ;
94180: LD_VAR 0 2
94184: RET
// export function ComMoveHex ( unit , hex ) ; begin
94185: LD_INT 0
94187: PPUSH
// if not hex then
94188: LD_VAR 0 2
94192: NOT
94193: IFFALSE 94197
// exit ;
94195: GO 94250
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
94197: LD_VAR 0 2
94201: PUSH
94202: LD_INT 1
94204: ARRAY
94205: PPUSH
94206: LD_VAR 0 2
94210: PUSH
94211: LD_INT 2
94213: ARRAY
94214: PPUSH
94215: CALL_OW 428
94219: IFFALSE 94223
// exit ;
94221: GO 94250
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
94223: LD_VAR 0 1
94227: PPUSH
94228: LD_VAR 0 2
94232: PUSH
94233: LD_INT 1
94235: ARRAY
94236: PPUSH
94237: LD_VAR 0 2
94241: PUSH
94242: LD_INT 2
94244: ARRAY
94245: PPUSH
94246: CALL_OW 111
// end ;
94250: LD_VAR 0 3
94254: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
94255: LD_INT 0
94257: PPUSH
94258: PPUSH
94259: PPUSH
// if not unit or not enemy then
94260: LD_VAR 0 1
94264: NOT
94265: PUSH
94266: LD_VAR 0 2
94270: NOT
94271: OR
94272: IFFALSE 94276
// exit ;
94274: GO 94400
// x := GetX ( enemy ) ;
94276: LD_ADDR_VAR 0 4
94280: PUSH
94281: LD_VAR 0 2
94285: PPUSH
94286: CALL_OW 250
94290: ST_TO_ADDR
// y := GetY ( enemy ) ;
94291: LD_ADDR_VAR 0 5
94295: PUSH
94296: LD_VAR 0 2
94300: PPUSH
94301: CALL_OW 251
94305: ST_TO_ADDR
// if ValidHex ( x , y ) then
94306: LD_VAR 0 4
94310: PPUSH
94311: LD_VAR 0 5
94315: PPUSH
94316: CALL_OW 488
94320: IFFALSE 94400
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
94322: LD_VAR 0 2
94326: PPUSH
94327: CALL_OW 247
94331: PUSH
94332: LD_INT 3
94334: PUSH
94335: LD_INT 2
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: IN
94342: PUSH
94343: LD_VAR 0 1
94347: PPUSH
94348: CALL_OW 255
94352: PPUSH
94353: LD_VAR 0 2
94357: PPUSH
94358: CALL_OW 292
94362: AND
94363: IFFALSE 94381
// ComAttackUnit ( unit , enemy ) else
94365: LD_VAR 0 1
94369: PPUSH
94370: LD_VAR 0 2
94374: PPUSH
94375: CALL_OW 115
94379: GO 94400
// ComAgressiveMove ( unit , x , y ) ;
94381: LD_VAR 0 1
94385: PPUSH
94386: LD_VAR 0 4
94390: PPUSH
94391: LD_VAR 0 5
94395: PPUSH
94396: CALL_OW 114
// end ; end_of_file end_of_file
94400: LD_VAR 0 3
94404: RET
// export globalGameSaveCounter ; every 0 0$1 do
94405: GO 94407
94407: DISABLE
// begin enable ;
94408: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94409: LD_STRING updateTimer(
94411: PUSH
94412: LD_OWVAR 1
94416: STR
94417: PUSH
94418: LD_STRING );
94420: STR
94421: PPUSH
94422: CALL_OW 559
// end ;
94426: END
// every 0 0$1 do
94427: GO 94429
94429: DISABLE
// begin globalGameSaveCounter := 0 ;
94430: LD_ADDR_EXP 123
94434: PUSH
94435: LD_INT 0
94437: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
94438: LD_STRING setGameSaveCounter(0)
94440: PPUSH
94441: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
94445: LD_STRING initStreamRollete();
94447: PPUSH
94448: CALL_OW 559
// InitStreamMode ;
94452: CALL 95778 0 0
// DefineStreamItems ( false ) ;
94456: LD_INT 0
94458: PPUSH
94459: CALL 96242 0 1
// end ;
94463: END
// export function SOS_MapStart ( ) ; begin
94464: LD_INT 0
94466: PPUSH
// if streamModeActive then
94467: LD_EXP 124
94471: IFFALSE 94480
// DefineStreamItems ( true ) ;
94473: LD_INT 1
94475: PPUSH
94476: CALL 96242 0 1
// UpdateLuaVariables ( ) ;
94480: CALL 94497 0 0
// UpdateFactoryWaypoints ( ) ;
94484: CALL 109111 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94488: CALL 109368 0 0
// end ;
94492: LD_VAR 0 1
94496: RET
// function UpdateLuaVariables ( ) ; begin
94497: LD_INT 0
94499: PPUSH
// if globalGameSaveCounter then
94500: LD_EXP 123
94504: IFFALSE 94538
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
94506: LD_ADDR_EXP 123
94510: PUSH
94511: LD_EXP 123
94515: PPUSH
94516: CALL 91544 0 1
94520: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94521: LD_STRING setGameSaveCounter(
94523: PUSH
94524: LD_EXP 123
94528: STR
94529: PUSH
94530: LD_STRING )
94532: STR
94533: PPUSH
94534: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
94538: LD_STRING setGameDifficulty(
94540: PUSH
94541: LD_OWVAR 67
94545: STR
94546: PUSH
94547: LD_STRING )
94549: STR
94550: PPUSH
94551: CALL_OW 559
// end ;
94555: LD_VAR 0 1
94559: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94560: LD_INT 0
94562: PPUSH
// if p2 = stream_mode then
94563: LD_VAR 0 2
94567: PUSH
94568: LD_INT 100
94570: EQUAL
94571: IFFALSE 95574
// begin if not StreamModeActive then
94573: LD_EXP 124
94577: NOT
94578: IFFALSE 94588
// StreamModeActive := true ;
94580: LD_ADDR_EXP 124
94584: PUSH
94585: LD_INT 1
94587: ST_TO_ADDR
// if p3 = 0 then
94588: LD_VAR 0 3
94592: PUSH
94593: LD_INT 0
94595: EQUAL
94596: IFFALSE 94602
// InitStreamMode ;
94598: CALL 95778 0 0
// if p3 = 1 then
94602: LD_VAR 0 3
94606: PUSH
94607: LD_INT 1
94609: EQUAL
94610: IFFALSE 94620
// sRocket := true ;
94612: LD_ADDR_EXP 129
94616: PUSH
94617: LD_INT 1
94619: ST_TO_ADDR
// if p3 = 2 then
94620: LD_VAR 0 3
94624: PUSH
94625: LD_INT 2
94627: EQUAL
94628: IFFALSE 94638
// sSpeed := true ;
94630: LD_ADDR_EXP 128
94634: PUSH
94635: LD_INT 1
94637: ST_TO_ADDR
// if p3 = 3 then
94638: LD_VAR 0 3
94642: PUSH
94643: LD_INT 3
94645: EQUAL
94646: IFFALSE 94656
// sEngine := true ;
94648: LD_ADDR_EXP 130
94652: PUSH
94653: LD_INT 1
94655: ST_TO_ADDR
// if p3 = 4 then
94656: LD_VAR 0 3
94660: PUSH
94661: LD_INT 4
94663: EQUAL
94664: IFFALSE 94674
// sSpec := true ;
94666: LD_ADDR_EXP 127
94670: PUSH
94671: LD_INT 1
94673: ST_TO_ADDR
// if p3 = 5 then
94674: LD_VAR 0 3
94678: PUSH
94679: LD_INT 5
94681: EQUAL
94682: IFFALSE 94692
// sLevel := true ;
94684: LD_ADDR_EXP 131
94688: PUSH
94689: LD_INT 1
94691: ST_TO_ADDR
// if p3 = 6 then
94692: LD_VAR 0 3
94696: PUSH
94697: LD_INT 6
94699: EQUAL
94700: IFFALSE 94710
// sArmoury := true ;
94702: LD_ADDR_EXP 132
94706: PUSH
94707: LD_INT 1
94709: ST_TO_ADDR
// if p3 = 7 then
94710: LD_VAR 0 3
94714: PUSH
94715: LD_INT 7
94717: EQUAL
94718: IFFALSE 94728
// sRadar := true ;
94720: LD_ADDR_EXP 133
94724: PUSH
94725: LD_INT 1
94727: ST_TO_ADDR
// if p3 = 8 then
94728: LD_VAR 0 3
94732: PUSH
94733: LD_INT 8
94735: EQUAL
94736: IFFALSE 94746
// sBunker := true ;
94738: LD_ADDR_EXP 134
94742: PUSH
94743: LD_INT 1
94745: ST_TO_ADDR
// if p3 = 9 then
94746: LD_VAR 0 3
94750: PUSH
94751: LD_INT 9
94753: EQUAL
94754: IFFALSE 94764
// sHack := true ;
94756: LD_ADDR_EXP 135
94760: PUSH
94761: LD_INT 1
94763: ST_TO_ADDR
// if p3 = 10 then
94764: LD_VAR 0 3
94768: PUSH
94769: LD_INT 10
94771: EQUAL
94772: IFFALSE 94782
// sFire := true ;
94774: LD_ADDR_EXP 136
94778: PUSH
94779: LD_INT 1
94781: ST_TO_ADDR
// if p3 = 11 then
94782: LD_VAR 0 3
94786: PUSH
94787: LD_INT 11
94789: EQUAL
94790: IFFALSE 94800
// sRefresh := true ;
94792: LD_ADDR_EXP 137
94796: PUSH
94797: LD_INT 1
94799: ST_TO_ADDR
// if p3 = 12 then
94800: LD_VAR 0 3
94804: PUSH
94805: LD_INT 12
94807: EQUAL
94808: IFFALSE 94818
// sExp := true ;
94810: LD_ADDR_EXP 138
94814: PUSH
94815: LD_INT 1
94817: ST_TO_ADDR
// if p3 = 13 then
94818: LD_VAR 0 3
94822: PUSH
94823: LD_INT 13
94825: EQUAL
94826: IFFALSE 94836
// sDepot := true ;
94828: LD_ADDR_EXP 139
94832: PUSH
94833: LD_INT 1
94835: ST_TO_ADDR
// if p3 = 14 then
94836: LD_VAR 0 3
94840: PUSH
94841: LD_INT 14
94843: EQUAL
94844: IFFALSE 94854
// sFlag := true ;
94846: LD_ADDR_EXP 140
94850: PUSH
94851: LD_INT 1
94853: ST_TO_ADDR
// if p3 = 15 then
94854: LD_VAR 0 3
94858: PUSH
94859: LD_INT 15
94861: EQUAL
94862: IFFALSE 94872
// sKamikadze := true ;
94864: LD_ADDR_EXP 148
94868: PUSH
94869: LD_INT 1
94871: ST_TO_ADDR
// if p3 = 16 then
94872: LD_VAR 0 3
94876: PUSH
94877: LD_INT 16
94879: EQUAL
94880: IFFALSE 94890
// sTroll := true ;
94882: LD_ADDR_EXP 149
94886: PUSH
94887: LD_INT 1
94889: ST_TO_ADDR
// if p3 = 17 then
94890: LD_VAR 0 3
94894: PUSH
94895: LD_INT 17
94897: EQUAL
94898: IFFALSE 94908
// sSlow := true ;
94900: LD_ADDR_EXP 150
94904: PUSH
94905: LD_INT 1
94907: ST_TO_ADDR
// if p3 = 18 then
94908: LD_VAR 0 3
94912: PUSH
94913: LD_INT 18
94915: EQUAL
94916: IFFALSE 94926
// sLack := true ;
94918: LD_ADDR_EXP 151
94922: PUSH
94923: LD_INT 1
94925: ST_TO_ADDR
// if p3 = 19 then
94926: LD_VAR 0 3
94930: PUSH
94931: LD_INT 19
94933: EQUAL
94934: IFFALSE 94944
// sTank := true ;
94936: LD_ADDR_EXP 153
94940: PUSH
94941: LD_INT 1
94943: ST_TO_ADDR
// if p3 = 20 then
94944: LD_VAR 0 3
94948: PUSH
94949: LD_INT 20
94951: EQUAL
94952: IFFALSE 94962
// sRemote := true ;
94954: LD_ADDR_EXP 154
94958: PUSH
94959: LD_INT 1
94961: ST_TO_ADDR
// if p3 = 21 then
94962: LD_VAR 0 3
94966: PUSH
94967: LD_INT 21
94969: EQUAL
94970: IFFALSE 94980
// sPowell := true ;
94972: LD_ADDR_EXP 155
94976: PUSH
94977: LD_INT 1
94979: ST_TO_ADDR
// if p3 = 22 then
94980: LD_VAR 0 3
94984: PUSH
94985: LD_INT 22
94987: EQUAL
94988: IFFALSE 94998
// sTeleport := true ;
94990: LD_ADDR_EXP 158
94994: PUSH
94995: LD_INT 1
94997: ST_TO_ADDR
// if p3 = 23 then
94998: LD_VAR 0 3
95002: PUSH
95003: LD_INT 23
95005: EQUAL
95006: IFFALSE 95016
// sOilTower := true ;
95008: LD_ADDR_EXP 160
95012: PUSH
95013: LD_INT 1
95015: ST_TO_ADDR
// if p3 = 24 then
95016: LD_VAR 0 3
95020: PUSH
95021: LD_INT 24
95023: EQUAL
95024: IFFALSE 95034
// sShovel := true ;
95026: LD_ADDR_EXP 161
95030: PUSH
95031: LD_INT 1
95033: ST_TO_ADDR
// if p3 = 25 then
95034: LD_VAR 0 3
95038: PUSH
95039: LD_INT 25
95041: EQUAL
95042: IFFALSE 95052
// sSheik := true ;
95044: LD_ADDR_EXP 162
95048: PUSH
95049: LD_INT 1
95051: ST_TO_ADDR
// if p3 = 26 then
95052: LD_VAR 0 3
95056: PUSH
95057: LD_INT 26
95059: EQUAL
95060: IFFALSE 95070
// sEarthquake := true ;
95062: LD_ADDR_EXP 164
95066: PUSH
95067: LD_INT 1
95069: ST_TO_ADDR
// if p3 = 27 then
95070: LD_VAR 0 3
95074: PUSH
95075: LD_INT 27
95077: EQUAL
95078: IFFALSE 95088
// sAI := true ;
95080: LD_ADDR_EXP 165
95084: PUSH
95085: LD_INT 1
95087: ST_TO_ADDR
// if p3 = 28 then
95088: LD_VAR 0 3
95092: PUSH
95093: LD_INT 28
95095: EQUAL
95096: IFFALSE 95106
// sCargo := true ;
95098: LD_ADDR_EXP 168
95102: PUSH
95103: LD_INT 1
95105: ST_TO_ADDR
// if p3 = 29 then
95106: LD_VAR 0 3
95110: PUSH
95111: LD_INT 29
95113: EQUAL
95114: IFFALSE 95124
// sDLaser := true ;
95116: LD_ADDR_EXP 169
95120: PUSH
95121: LD_INT 1
95123: ST_TO_ADDR
// if p3 = 30 then
95124: LD_VAR 0 3
95128: PUSH
95129: LD_INT 30
95131: EQUAL
95132: IFFALSE 95142
// sExchange := true ;
95134: LD_ADDR_EXP 170
95138: PUSH
95139: LD_INT 1
95141: ST_TO_ADDR
// if p3 = 31 then
95142: LD_VAR 0 3
95146: PUSH
95147: LD_INT 31
95149: EQUAL
95150: IFFALSE 95160
// sFac := true ;
95152: LD_ADDR_EXP 171
95156: PUSH
95157: LD_INT 1
95159: ST_TO_ADDR
// if p3 = 32 then
95160: LD_VAR 0 3
95164: PUSH
95165: LD_INT 32
95167: EQUAL
95168: IFFALSE 95178
// sPower := true ;
95170: LD_ADDR_EXP 172
95174: PUSH
95175: LD_INT 1
95177: ST_TO_ADDR
// if p3 = 33 then
95178: LD_VAR 0 3
95182: PUSH
95183: LD_INT 33
95185: EQUAL
95186: IFFALSE 95196
// sRandom := true ;
95188: LD_ADDR_EXP 173
95192: PUSH
95193: LD_INT 1
95195: ST_TO_ADDR
// if p3 = 34 then
95196: LD_VAR 0 3
95200: PUSH
95201: LD_INT 34
95203: EQUAL
95204: IFFALSE 95214
// sShield := true ;
95206: LD_ADDR_EXP 174
95210: PUSH
95211: LD_INT 1
95213: ST_TO_ADDR
// if p3 = 35 then
95214: LD_VAR 0 3
95218: PUSH
95219: LD_INT 35
95221: EQUAL
95222: IFFALSE 95232
// sTime := true ;
95224: LD_ADDR_EXP 175
95228: PUSH
95229: LD_INT 1
95231: ST_TO_ADDR
// if p3 = 36 then
95232: LD_VAR 0 3
95236: PUSH
95237: LD_INT 36
95239: EQUAL
95240: IFFALSE 95250
// sTools := true ;
95242: LD_ADDR_EXP 176
95246: PUSH
95247: LD_INT 1
95249: ST_TO_ADDR
// if p3 = 101 then
95250: LD_VAR 0 3
95254: PUSH
95255: LD_INT 101
95257: EQUAL
95258: IFFALSE 95268
// sSold := true ;
95260: LD_ADDR_EXP 141
95264: PUSH
95265: LD_INT 1
95267: ST_TO_ADDR
// if p3 = 102 then
95268: LD_VAR 0 3
95272: PUSH
95273: LD_INT 102
95275: EQUAL
95276: IFFALSE 95286
// sDiff := true ;
95278: LD_ADDR_EXP 142
95282: PUSH
95283: LD_INT 1
95285: ST_TO_ADDR
// if p3 = 103 then
95286: LD_VAR 0 3
95290: PUSH
95291: LD_INT 103
95293: EQUAL
95294: IFFALSE 95304
// sFog := true ;
95296: LD_ADDR_EXP 145
95300: PUSH
95301: LD_INT 1
95303: ST_TO_ADDR
// if p3 = 104 then
95304: LD_VAR 0 3
95308: PUSH
95309: LD_INT 104
95311: EQUAL
95312: IFFALSE 95322
// sReset := true ;
95314: LD_ADDR_EXP 146
95318: PUSH
95319: LD_INT 1
95321: ST_TO_ADDR
// if p3 = 105 then
95322: LD_VAR 0 3
95326: PUSH
95327: LD_INT 105
95329: EQUAL
95330: IFFALSE 95340
// sSun := true ;
95332: LD_ADDR_EXP 147
95336: PUSH
95337: LD_INT 1
95339: ST_TO_ADDR
// if p3 = 106 then
95340: LD_VAR 0 3
95344: PUSH
95345: LD_INT 106
95347: EQUAL
95348: IFFALSE 95358
// sTiger := true ;
95350: LD_ADDR_EXP 143
95354: PUSH
95355: LD_INT 1
95357: ST_TO_ADDR
// if p3 = 107 then
95358: LD_VAR 0 3
95362: PUSH
95363: LD_INT 107
95365: EQUAL
95366: IFFALSE 95376
// sBomb := true ;
95368: LD_ADDR_EXP 144
95372: PUSH
95373: LD_INT 1
95375: ST_TO_ADDR
// if p3 = 108 then
95376: LD_VAR 0 3
95380: PUSH
95381: LD_INT 108
95383: EQUAL
95384: IFFALSE 95394
// sWound := true ;
95386: LD_ADDR_EXP 152
95390: PUSH
95391: LD_INT 1
95393: ST_TO_ADDR
// if p3 = 109 then
95394: LD_VAR 0 3
95398: PUSH
95399: LD_INT 109
95401: EQUAL
95402: IFFALSE 95412
// sBetray := true ;
95404: LD_ADDR_EXP 156
95408: PUSH
95409: LD_INT 1
95411: ST_TO_ADDR
// if p3 = 110 then
95412: LD_VAR 0 3
95416: PUSH
95417: LD_INT 110
95419: EQUAL
95420: IFFALSE 95430
// sContamin := true ;
95422: LD_ADDR_EXP 157
95426: PUSH
95427: LD_INT 1
95429: ST_TO_ADDR
// if p3 = 111 then
95430: LD_VAR 0 3
95434: PUSH
95435: LD_INT 111
95437: EQUAL
95438: IFFALSE 95448
// sOil := true ;
95440: LD_ADDR_EXP 159
95444: PUSH
95445: LD_INT 1
95447: ST_TO_ADDR
// if p3 = 112 then
95448: LD_VAR 0 3
95452: PUSH
95453: LD_INT 112
95455: EQUAL
95456: IFFALSE 95466
// sStu := true ;
95458: LD_ADDR_EXP 163
95462: PUSH
95463: LD_INT 1
95465: ST_TO_ADDR
// if p3 = 113 then
95466: LD_VAR 0 3
95470: PUSH
95471: LD_INT 113
95473: EQUAL
95474: IFFALSE 95484
// sBazooka := true ;
95476: LD_ADDR_EXP 166
95480: PUSH
95481: LD_INT 1
95483: ST_TO_ADDR
// if p3 = 114 then
95484: LD_VAR 0 3
95488: PUSH
95489: LD_INT 114
95491: EQUAL
95492: IFFALSE 95502
// sMortar := true ;
95494: LD_ADDR_EXP 167
95498: PUSH
95499: LD_INT 1
95501: ST_TO_ADDR
// if p3 = 115 then
95502: LD_VAR 0 3
95506: PUSH
95507: LD_INT 115
95509: EQUAL
95510: IFFALSE 95520
// sRanger := true ;
95512: LD_ADDR_EXP 177
95516: PUSH
95517: LD_INT 1
95519: ST_TO_ADDR
// if p3 = 116 then
95520: LD_VAR 0 3
95524: PUSH
95525: LD_INT 116
95527: EQUAL
95528: IFFALSE 95538
// sComputer := true ;
95530: LD_ADDR_EXP 178
95534: PUSH
95535: LD_INT 1
95537: ST_TO_ADDR
// if p3 = 117 then
95538: LD_VAR 0 3
95542: PUSH
95543: LD_INT 117
95545: EQUAL
95546: IFFALSE 95556
// s30 := true ;
95548: LD_ADDR_EXP 179
95552: PUSH
95553: LD_INT 1
95555: ST_TO_ADDR
// if p3 = 118 then
95556: LD_VAR 0 3
95560: PUSH
95561: LD_INT 118
95563: EQUAL
95564: IFFALSE 95574
// s60 := true ;
95566: LD_ADDR_EXP 180
95570: PUSH
95571: LD_INT 1
95573: ST_TO_ADDR
// end ; if p2 = hack_mode then
95574: LD_VAR 0 2
95578: PUSH
95579: LD_INT 101
95581: EQUAL
95582: IFFALSE 95710
// begin case p3 of 1 :
95584: LD_VAR 0 3
95588: PUSH
95589: LD_INT 1
95591: DOUBLE
95592: EQUAL
95593: IFTRUE 95597
95595: GO 95604
95597: POP
// hHackUnlimitedResources ; 2 :
95598: CALL 107857 0 0
95602: GO 95710
95604: LD_INT 2
95606: DOUBLE
95607: EQUAL
95608: IFTRUE 95612
95610: GO 95619
95612: POP
// hHackSetLevel10 ; 3 :
95613: CALL 107990 0 0
95617: GO 95710
95619: LD_INT 3
95621: DOUBLE
95622: EQUAL
95623: IFTRUE 95627
95625: GO 95634
95627: POP
// hHackSetLevel10YourUnits ; 4 :
95628: CALL 108075 0 0
95632: GO 95710
95634: LD_INT 4
95636: DOUBLE
95637: EQUAL
95638: IFTRUE 95642
95640: GO 95649
95642: POP
// hHackInvincible ; 5 :
95643: CALL 108523 0 0
95647: GO 95710
95649: LD_INT 5
95651: DOUBLE
95652: EQUAL
95653: IFTRUE 95657
95655: GO 95664
95657: POP
// hHackInvisible ; 6 :
95658: CALL 108634 0 0
95662: GO 95710
95664: LD_INT 6
95666: DOUBLE
95667: EQUAL
95668: IFTRUE 95672
95670: GO 95679
95672: POP
// hHackChangeYourSide ; 7 :
95673: CALL 108691 0 0
95677: GO 95710
95679: LD_INT 7
95681: DOUBLE
95682: EQUAL
95683: IFTRUE 95687
95685: GO 95694
95687: POP
// hHackChangeUnitSide ; 8 :
95688: CALL 108733 0 0
95692: GO 95710
95694: LD_INT 8
95696: DOUBLE
95697: EQUAL
95698: IFTRUE 95702
95700: GO 95709
95702: POP
// hHackFog ; end ;
95703: CALL 108834 0 0
95707: GO 95710
95709: POP
// end ; if p2 = game_save_mode then
95710: LD_VAR 0 2
95714: PUSH
95715: LD_INT 102
95717: EQUAL
95718: IFFALSE 95773
// begin if p3 = 1 then
95720: LD_VAR 0 3
95724: PUSH
95725: LD_INT 1
95727: EQUAL
95728: IFFALSE 95740
// globalGameSaveCounter := p4 ;
95730: LD_ADDR_EXP 123
95734: PUSH
95735: LD_VAR 0 4
95739: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
95740: LD_VAR 0 3
95744: PUSH
95745: LD_INT 2
95747: EQUAL
95748: PUSH
95749: LD_EXP 123
95753: AND
95754: IFFALSE 95773
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95756: LD_STRING setGameSaveCounter(
95758: PUSH
95759: LD_EXP 123
95763: STR
95764: PUSH
95765: LD_STRING )
95767: STR
95768: PPUSH
95769: CALL_OW 559
// end ; end ;
95773: LD_VAR 0 7
95777: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
95778: LD_INT 0
95780: PPUSH
// streamModeActive := false ;
95781: LD_ADDR_EXP 124
95785: PUSH
95786: LD_INT 0
95788: ST_TO_ADDR
// normalCounter := 36 ;
95789: LD_ADDR_EXP 125
95793: PUSH
95794: LD_INT 36
95796: ST_TO_ADDR
// hardcoreCounter := 18 ;
95797: LD_ADDR_EXP 126
95801: PUSH
95802: LD_INT 18
95804: ST_TO_ADDR
// sRocket := false ;
95805: LD_ADDR_EXP 129
95809: PUSH
95810: LD_INT 0
95812: ST_TO_ADDR
// sSpeed := false ;
95813: LD_ADDR_EXP 128
95817: PUSH
95818: LD_INT 0
95820: ST_TO_ADDR
// sEngine := false ;
95821: LD_ADDR_EXP 130
95825: PUSH
95826: LD_INT 0
95828: ST_TO_ADDR
// sSpec := false ;
95829: LD_ADDR_EXP 127
95833: PUSH
95834: LD_INT 0
95836: ST_TO_ADDR
// sLevel := false ;
95837: LD_ADDR_EXP 131
95841: PUSH
95842: LD_INT 0
95844: ST_TO_ADDR
// sArmoury := false ;
95845: LD_ADDR_EXP 132
95849: PUSH
95850: LD_INT 0
95852: ST_TO_ADDR
// sRadar := false ;
95853: LD_ADDR_EXP 133
95857: PUSH
95858: LD_INT 0
95860: ST_TO_ADDR
// sBunker := false ;
95861: LD_ADDR_EXP 134
95865: PUSH
95866: LD_INT 0
95868: ST_TO_ADDR
// sHack := false ;
95869: LD_ADDR_EXP 135
95873: PUSH
95874: LD_INT 0
95876: ST_TO_ADDR
// sFire := false ;
95877: LD_ADDR_EXP 136
95881: PUSH
95882: LD_INT 0
95884: ST_TO_ADDR
// sRefresh := false ;
95885: LD_ADDR_EXP 137
95889: PUSH
95890: LD_INT 0
95892: ST_TO_ADDR
// sExp := false ;
95893: LD_ADDR_EXP 138
95897: PUSH
95898: LD_INT 0
95900: ST_TO_ADDR
// sDepot := false ;
95901: LD_ADDR_EXP 139
95905: PUSH
95906: LD_INT 0
95908: ST_TO_ADDR
// sFlag := false ;
95909: LD_ADDR_EXP 140
95913: PUSH
95914: LD_INT 0
95916: ST_TO_ADDR
// sKamikadze := false ;
95917: LD_ADDR_EXP 148
95921: PUSH
95922: LD_INT 0
95924: ST_TO_ADDR
// sTroll := false ;
95925: LD_ADDR_EXP 149
95929: PUSH
95930: LD_INT 0
95932: ST_TO_ADDR
// sSlow := false ;
95933: LD_ADDR_EXP 150
95937: PUSH
95938: LD_INT 0
95940: ST_TO_ADDR
// sLack := false ;
95941: LD_ADDR_EXP 151
95945: PUSH
95946: LD_INT 0
95948: ST_TO_ADDR
// sTank := false ;
95949: LD_ADDR_EXP 153
95953: PUSH
95954: LD_INT 0
95956: ST_TO_ADDR
// sRemote := false ;
95957: LD_ADDR_EXP 154
95961: PUSH
95962: LD_INT 0
95964: ST_TO_ADDR
// sPowell := false ;
95965: LD_ADDR_EXP 155
95969: PUSH
95970: LD_INT 0
95972: ST_TO_ADDR
// sTeleport := false ;
95973: LD_ADDR_EXP 158
95977: PUSH
95978: LD_INT 0
95980: ST_TO_ADDR
// sOilTower := false ;
95981: LD_ADDR_EXP 160
95985: PUSH
95986: LD_INT 0
95988: ST_TO_ADDR
// sShovel := false ;
95989: LD_ADDR_EXP 161
95993: PUSH
95994: LD_INT 0
95996: ST_TO_ADDR
// sSheik := false ;
95997: LD_ADDR_EXP 162
96001: PUSH
96002: LD_INT 0
96004: ST_TO_ADDR
// sEarthquake := false ;
96005: LD_ADDR_EXP 164
96009: PUSH
96010: LD_INT 0
96012: ST_TO_ADDR
// sAI := false ;
96013: LD_ADDR_EXP 165
96017: PUSH
96018: LD_INT 0
96020: ST_TO_ADDR
// sCargo := false ;
96021: LD_ADDR_EXP 168
96025: PUSH
96026: LD_INT 0
96028: ST_TO_ADDR
// sDLaser := false ;
96029: LD_ADDR_EXP 169
96033: PUSH
96034: LD_INT 0
96036: ST_TO_ADDR
// sExchange := false ;
96037: LD_ADDR_EXP 170
96041: PUSH
96042: LD_INT 0
96044: ST_TO_ADDR
// sFac := false ;
96045: LD_ADDR_EXP 171
96049: PUSH
96050: LD_INT 0
96052: ST_TO_ADDR
// sPower := false ;
96053: LD_ADDR_EXP 172
96057: PUSH
96058: LD_INT 0
96060: ST_TO_ADDR
// sRandom := false ;
96061: LD_ADDR_EXP 173
96065: PUSH
96066: LD_INT 0
96068: ST_TO_ADDR
// sShield := false ;
96069: LD_ADDR_EXP 174
96073: PUSH
96074: LD_INT 0
96076: ST_TO_ADDR
// sTime := false ;
96077: LD_ADDR_EXP 175
96081: PUSH
96082: LD_INT 0
96084: ST_TO_ADDR
// sTools := false ;
96085: LD_ADDR_EXP 176
96089: PUSH
96090: LD_INT 0
96092: ST_TO_ADDR
// sSold := false ;
96093: LD_ADDR_EXP 141
96097: PUSH
96098: LD_INT 0
96100: ST_TO_ADDR
// sDiff := false ;
96101: LD_ADDR_EXP 142
96105: PUSH
96106: LD_INT 0
96108: ST_TO_ADDR
// sFog := false ;
96109: LD_ADDR_EXP 145
96113: PUSH
96114: LD_INT 0
96116: ST_TO_ADDR
// sReset := false ;
96117: LD_ADDR_EXP 146
96121: PUSH
96122: LD_INT 0
96124: ST_TO_ADDR
// sSun := false ;
96125: LD_ADDR_EXP 147
96129: PUSH
96130: LD_INT 0
96132: ST_TO_ADDR
// sTiger := false ;
96133: LD_ADDR_EXP 143
96137: PUSH
96138: LD_INT 0
96140: ST_TO_ADDR
// sBomb := false ;
96141: LD_ADDR_EXP 144
96145: PUSH
96146: LD_INT 0
96148: ST_TO_ADDR
// sWound := false ;
96149: LD_ADDR_EXP 152
96153: PUSH
96154: LD_INT 0
96156: ST_TO_ADDR
// sBetray := false ;
96157: LD_ADDR_EXP 156
96161: PUSH
96162: LD_INT 0
96164: ST_TO_ADDR
// sContamin := false ;
96165: LD_ADDR_EXP 157
96169: PUSH
96170: LD_INT 0
96172: ST_TO_ADDR
// sOil := false ;
96173: LD_ADDR_EXP 159
96177: PUSH
96178: LD_INT 0
96180: ST_TO_ADDR
// sStu := false ;
96181: LD_ADDR_EXP 163
96185: PUSH
96186: LD_INT 0
96188: ST_TO_ADDR
// sBazooka := false ;
96189: LD_ADDR_EXP 166
96193: PUSH
96194: LD_INT 0
96196: ST_TO_ADDR
// sMortar := false ;
96197: LD_ADDR_EXP 167
96201: PUSH
96202: LD_INT 0
96204: ST_TO_ADDR
// sRanger := false ;
96205: LD_ADDR_EXP 177
96209: PUSH
96210: LD_INT 0
96212: ST_TO_ADDR
// sComputer := false ;
96213: LD_ADDR_EXP 178
96217: PUSH
96218: LD_INT 0
96220: ST_TO_ADDR
// s30 := false ;
96221: LD_ADDR_EXP 179
96225: PUSH
96226: LD_INT 0
96228: ST_TO_ADDR
// s60 := false ;
96229: LD_ADDR_EXP 180
96233: PUSH
96234: LD_INT 0
96236: ST_TO_ADDR
// end ;
96237: LD_VAR 0 1
96241: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96242: LD_INT 0
96244: PPUSH
96245: PPUSH
96246: PPUSH
96247: PPUSH
96248: PPUSH
96249: PPUSH
96250: PPUSH
// result := [ ] ;
96251: LD_ADDR_VAR 0 2
96255: PUSH
96256: EMPTY
96257: ST_TO_ADDR
// if campaign_id = 1 then
96258: LD_OWVAR 69
96262: PUSH
96263: LD_INT 1
96265: EQUAL
96266: IFFALSE 99432
// begin case mission_number of 1 :
96268: LD_OWVAR 70
96272: PUSH
96273: LD_INT 1
96275: DOUBLE
96276: EQUAL
96277: IFTRUE 96281
96279: GO 96357
96281: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96282: LD_ADDR_VAR 0 2
96286: PUSH
96287: LD_INT 2
96289: PUSH
96290: LD_INT 4
96292: PUSH
96293: LD_INT 11
96295: PUSH
96296: LD_INT 12
96298: PUSH
96299: LD_INT 15
96301: PUSH
96302: LD_INT 16
96304: PUSH
96305: LD_INT 22
96307: PUSH
96308: LD_INT 23
96310: PUSH
96311: LD_INT 26
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: LIST
96318: LIST
96319: LIST
96320: LIST
96321: LIST
96322: LIST
96323: LIST
96324: PUSH
96325: LD_INT 101
96327: PUSH
96328: LD_INT 102
96330: PUSH
96331: LD_INT 106
96333: PUSH
96334: LD_INT 116
96336: PUSH
96337: LD_INT 117
96339: PUSH
96340: LD_INT 118
96342: PUSH
96343: EMPTY
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: ST_TO_ADDR
96355: GO 99430
96357: LD_INT 2
96359: DOUBLE
96360: EQUAL
96361: IFTRUE 96365
96363: GO 96449
96365: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96366: LD_ADDR_VAR 0 2
96370: PUSH
96371: LD_INT 2
96373: PUSH
96374: LD_INT 4
96376: PUSH
96377: LD_INT 11
96379: PUSH
96380: LD_INT 12
96382: PUSH
96383: LD_INT 15
96385: PUSH
96386: LD_INT 16
96388: PUSH
96389: LD_INT 22
96391: PUSH
96392: LD_INT 23
96394: PUSH
96395: LD_INT 26
96397: PUSH
96398: EMPTY
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: PUSH
96409: LD_INT 101
96411: PUSH
96412: LD_INT 102
96414: PUSH
96415: LD_INT 105
96417: PUSH
96418: LD_INT 106
96420: PUSH
96421: LD_INT 108
96423: PUSH
96424: LD_INT 116
96426: PUSH
96427: LD_INT 117
96429: PUSH
96430: LD_INT 118
96432: PUSH
96433: EMPTY
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: ST_TO_ADDR
96447: GO 99430
96449: LD_INT 3
96451: DOUBLE
96452: EQUAL
96453: IFTRUE 96457
96455: GO 96545
96457: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96458: LD_ADDR_VAR 0 2
96462: PUSH
96463: LD_INT 2
96465: PUSH
96466: LD_INT 4
96468: PUSH
96469: LD_INT 5
96471: PUSH
96472: LD_INT 11
96474: PUSH
96475: LD_INT 12
96477: PUSH
96478: LD_INT 15
96480: PUSH
96481: LD_INT 16
96483: PUSH
96484: LD_INT 22
96486: PUSH
96487: LD_INT 26
96489: PUSH
96490: LD_INT 36
96492: PUSH
96493: EMPTY
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: PUSH
96505: LD_INT 101
96507: PUSH
96508: LD_INT 102
96510: PUSH
96511: LD_INT 105
96513: PUSH
96514: LD_INT 106
96516: PUSH
96517: LD_INT 108
96519: PUSH
96520: LD_INT 116
96522: PUSH
96523: LD_INT 117
96525: PUSH
96526: LD_INT 118
96528: PUSH
96529: EMPTY
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: ST_TO_ADDR
96543: GO 99430
96545: LD_INT 4
96547: DOUBLE
96548: EQUAL
96549: IFTRUE 96553
96551: GO 96649
96553: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96554: LD_ADDR_VAR 0 2
96558: PUSH
96559: LD_INT 2
96561: PUSH
96562: LD_INT 4
96564: PUSH
96565: LD_INT 5
96567: PUSH
96568: LD_INT 8
96570: PUSH
96571: LD_INT 11
96573: PUSH
96574: LD_INT 12
96576: PUSH
96577: LD_INT 15
96579: PUSH
96580: LD_INT 16
96582: PUSH
96583: LD_INT 22
96585: PUSH
96586: LD_INT 23
96588: PUSH
96589: LD_INT 26
96591: PUSH
96592: LD_INT 36
96594: PUSH
96595: EMPTY
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: PUSH
96609: LD_INT 101
96611: PUSH
96612: LD_INT 102
96614: PUSH
96615: LD_INT 105
96617: PUSH
96618: LD_INT 106
96620: PUSH
96621: LD_INT 108
96623: PUSH
96624: LD_INT 116
96626: PUSH
96627: LD_INT 117
96629: PUSH
96630: LD_INT 118
96632: PUSH
96633: EMPTY
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: PUSH
96643: EMPTY
96644: LIST
96645: LIST
96646: ST_TO_ADDR
96647: GO 99430
96649: LD_INT 5
96651: DOUBLE
96652: EQUAL
96653: IFTRUE 96657
96655: GO 96769
96657: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96658: LD_ADDR_VAR 0 2
96662: PUSH
96663: LD_INT 2
96665: PUSH
96666: LD_INT 4
96668: PUSH
96669: LD_INT 5
96671: PUSH
96672: LD_INT 6
96674: PUSH
96675: LD_INT 8
96677: PUSH
96678: LD_INT 11
96680: PUSH
96681: LD_INT 12
96683: PUSH
96684: LD_INT 15
96686: PUSH
96687: LD_INT 16
96689: PUSH
96690: LD_INT 22
96692: PUSH
96693: LD_INT 23
96695: PUSH
96696: LD_INT 25
96698: PUSH
96699: LD_INT 26
96701: PUSH
96702: LD_INT 36
96704: PUSH
96705: EMPTY
96706: LIST
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: LIST
96714: LIST
96715: LIST
96716: LIST
96717: LIST
96718: LIST
96719: LIST
96720: PUSH
96721: LD_INT 101
96723: PUSH
96724: LD_INT 102
96726: PUSH
96727: LD_INT 105
96729: PUSH
96730: LD_INT 106
96732: PUSH
96733: LD_INT 108
96735: PUSH
96736: LD_INT 109
96738: PUSH
96739: LD_INT 112
96741: PUSH
96742: LD_INT 116
96744: PUSH
96745: LD_INT 117
96747: PUSH
96748: LD_INT 118
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: LIST
96755: LIST
96756: LIST
96757: LIST
96758: LIST
96759: LIST
96760: LIST
96761: LIST
96762: PUSH
96763: EMPTY
96764: LIST
96765: LIST
96766: ST_TO_ADDR
96767: GO 99430
96769: LD_INT 6
96771: DOUBLE
96772: EQUAL
96773: IFTRUE 96777
96775: GO 96909
96777: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96778: LD_ADDR_VAR 0 2
96782: PUSH
96783: LD_INT 2
96785: PUSH
96786: LD_INT 4
96788: PUSH
96789: LD_INT 5
96791: PUSH
96792: LD_INT 6
96794: PUSH
96795: LD_INT 8
96797: PUSH
96798: LD_INT 11
96800: PUSH
96801: LD_INT 12
96803: PUSH
96804: LD_INT 15
96806: PUSH
96807: LD_INT 16
96809: PUSH
96810: LD_INT 20
96812: PUSH
96813: LD_INT 21
96815: PUSH
96816: LD_INT 22
96818: PUSH
96819: LD_INT 23
96821: PUSH
96822: LD_INT 25
96824: PUSH
96825: LD_INT 26
96827: PUSH
96828: LD_INT 30
96830: PUSH
96831: LD_INT 31
96833: PUSH
96834: LD_INT 32
96836: PUSH
96837: LD_INT 36
96839: PUSH
96840: EMPTY
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: PUSH
96861: LD_INT 101
96863: PUSH
96864: LD_INT 102
96866: PUSH
96867: LD_INT 105
96869: PUSH
96870: LD_INT 106
96872: PUSH
96873: LD_INT 108
96875: PUSH
96876: LD_INT 109
96878: PUSH
96879: LD_INT 112
96881: PUSH
96882: LD_INT 116
96884: PUSH
96885: LD_INT 117
96887: PUSH
96888: LD_INT 118
96890: PUSH
96891: EMPTY
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: PUSH
96903: EMPTY
96904: LIST
96905: LIST
96906: ST_TO_ADDR
96907: GO 99430
96909: LD_INT 7
96911: DOUBLE
96912: EQUAL
96913: IFTRUE 96917
96915: GO 97029
96917: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
96918: LD_ADDR_VAR 0 2
96922: PUSH
96923: LD_INT 2
96925: PUSH
96926: LD_INT 4
96928: PUSH
96929: LD_INT 5
96931: PUSH
96932: LD_INT 7
96934: PUSH
96935: LD_INT 11
96937: PUSH
96938: LD_INT 12
96940: PUSH
96941: LD_INT 15
96943: PUSH
96944: LD_INT 16
96946: PUSH
96947: LD_INT 20
96949: PUSH
96950: LD_INT 21
96952: PUSH
96953: LD_INT 22
96955: PUSH
96956: LD_INT 23
96958: PUSH
96959: LD_INT 25
96961: PUSH
96962: LD_INT 26
96964: PUSH
96965: EMPTY
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: PUSH
96981: LD_INT 101
96983: PUSH
96984: LD_INT 102
96986: PUSH
96987: LD_INT 103
96989: PUSH
96990: LD_INT 105
96992: PUSH
96993: LD_INT 106
96995: PUSH
96996: LD_INT 108
96998: PUSH
96999: LD_INT 112
97001: PUSH
97002: LD_INT 116
97004: PUSH
97005: LD_INT 117
97007: PUSH
97008: LD_INT 118
97010: PUSH
97011: EMPTY
97012: LIST
97013: LIST
97014: LIST
97015: LIST
97016: LIST
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: ST_TO_ADDR
97027: GO 99430
97029: LD_INT 8
97031: DOUBLE
97032: EQUAL
97033: IFTRUE 97037
97035: GO 97177
97037: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97038: LD_ADDR_VAR 0 2
97042: PUSH
97043: LD_INT 2
97045: PUSH
97046: LD_INT 4
97048: PUSH
97049: LD_INT 5
97051: PUSH
97052: LD_INT 6
97054: PUSH
97055: LD_INT 7
97057: PUSH
97058: LD_INT 8
97060: PUSH
97061: LD_INT 11
97063: PUSH
97064: LD_INT 12
97066: PUSH
97067: LD_INT 15
97069: PUSH
97070: LD_INT 16
97072: PUSH
97073: LD_INT 20
97075: PUSH
97076: LD_INT 21
97078: PUSH
97079: LD_INT 22
97081: PUSH
97082: LD_INT 23
97084: PUSH
97085: LD_INT 25
97087: PUSH
97088: LD_INT 26
97090: PUSH
97091: LD_INT 30
97093: PUSH
97094: LD_INT 31
97096: PUSH
97097: LD_INT 32
97099: PUSH
97100: LD_INT 36
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: PUSH
97125: LD_INT 101
97127: PUSH
97128: LD_INT 102
97130: PUSH
97131: LD_INT 103
97133: PUSH
97134: LD_INT 105
97136: PUSH
97137: LD_INT 106
97139: PUSH
97140: LD_INT 108
97142: PUSH
97143: LD_INT 109
97145: PUSH
97146: LD_INT 112
97148: PUSH
97149: LD_INT 116
97151: PUSH
97152: LD_INT 117
97154: PUSH
97155: LD_INT 118
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: ST_TO_ADDR
97175: GO 99430
97177: LD_INT 9
97179: DOUBLE
97180: EQUAL
97181: IFTRUE 97185
97183: GO 97333
97185: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97186: LD_ADDR_VAR 0 2
97190: PUSH
97191: LD_INT 2
97193: PUSH
97194: LD_INT 4
97196: PUSH
97197: LD_INT 5
97199: PUSH
97200: LD_INT 6
97202: PUSH
97203: LD_INT 7
97205: PUSH
97206: LD_INT 8
97208: PUSH
97209: LD_INT 11
97211: PUSH
97212: LD_INT 12
97214: PUSH
97215: LD_INT 15
97217: PUSH
97218: LD_INT 16
97220: PUSH
97221: LD_INT 20
97223: PUSH
97224: LD_INT 21
97226: PUSH
97227: LD_INT 22
97229: PUSH
97230: LD_INT 23
97232: PUSH
97233: LD_INT 25
97235: PUSH
97236: LD_INT 26
97238: PUSH
97239: LD_INT 28
97241: PUSH
97242: LD_INT 30
97244: PUSH
97245: LD_INT 31
97247: PUSH
97248: LD_INT 32
97250: PUSH
97251: LD_INT 36
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: LIST
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: PUSH
97277: LD_INT 101
97279: PUSH
97280: LD_INT 102
97282: PUSH
97283: LD_INT 103
97285: PUSH
97286: LD_INT 105
97288: PUSH
97289: LD_INT 106
97291: PUSH
97292: LD_INT 108
97294: PUSH
97295: LD_INT 109
97297: PUSH
97298: LD_INT 112
97300: PUSH
97301: LD_INT 114
97303: PUSH
97304: LD_INT 116
97306: PUSH
97307: LD_INT 117
97309: PUSH
97310: LD_INT 118
97312: PUSH
97313: EMPTY
97314: LIST
97315: LIST
97316: LIST
97317: LIST
97318: LIST
97319: LIST
97320: LIST
97321: LIST
97322: LIST
97323: LIST
97324: LIST
97325: LIST
97326: PUSH
97327: EMPTY
97328: LIST
97329: LIST
97330: ST_TO_ADDR
97331: GO 99430
97333: LD_INT 10
97335: DOUBLE
97336: EQUAL
97337: IFTRUE 97341
97339: GO 97537
97341: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97342: LD_ADDR_VAR 0 2
97346: PUSH
97347: LD_INT 2
97349: PUSH
97350: LD_INT 4
97352: PUSH
97353: LD_INT 5
97355: PUSH
97356: LD_INT 6
97358: PUSH
97359: LD_INT 7
97361: PUSH
97362: LD_INT 8
97364: PUSH
97365: LD_INT 9
97367: PUSH
97368: LD_INT 10
97370: PUSH
97371: LD_INT 11
97373: PUSH
97374: LD_INT 12
97376: PUSH
97377: LD_INT 13
97379: PUSH
97380: LD_INT 14
97382: PUSH
97383: LD_INT 15
97385: PUSH
97386: LD_INT 16
97388: PUSH
97389: LD_INT 17
97391: PUSH
97392: LD_INT 18
97394: PUSH
97395: LD_INT 19
97397: PUSH
97398: LD_INT 20
97400: PUSH
97401: LD_INT 21
97403: PUSH
97404: LD_INT 22
97406: PUSH
97407: LD_INT 23
97409: PUSH
97410: LD_INT 24
97412: PUSH
97413: LD_INT 25
97415: PUSH
97416: LD_INT 26
97418: PUSH
97419: LD_INT 28
97421: PUSH
97422: LD_INT 30
97424: PUSH
97425: LD_INT 31
97427: PUSH
97428: LD_INT 32
97430: PUSH
97431: LD_INT 36
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: LIST
97441: LIST
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: LIST
97453: LIST
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: PUSH
97465: LD_INT 101
97467: PUSH
97468: LD_INT 102
97470: PUSH
97471: LD_INT 103
97473: PUSH
97474: LD_INT 104
97476: PUSH
97477: LD_INT 105
97479: PUSH
97480: LD_INT 106
97482: PUSH
97483: LD_INT 107
97485: PUSH
97486: LD_INT 108
97488: PUSH
97489: LD_INT 109
97491: PUSH
97492: LD_INT 110
97494: PUSH
97495: LD_INT 111
97497: PUSH
97498: LD_INT 112
97500: PUSH
97501: LD_INT 114
97503: PUSH
97504: LD_INT 116
97506: PUSH
97507: LD_INT 117
97509: PUSH
97510: LD_INT 118
97512: PUSH
97513: EMPTY
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: LIST
97527: LIST
97528: LIST
97529: LIST
97530: PUSH
97531: EMPTY
97532: LIST
97533: LIST
97534: ST_TO_ADDR
97535: GO 99430
97537: LD_INT 11
97539: DOUBLE
97540: EQUAL
97541: IFTRUE 97545
97543: GO 97749
97545: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97546: LD_ADDR_VAR 0 2
97550: PUSH
97551: LD_INT 2
97553: PUSH
97554: LD_INT 3
97556: PUSH
97557: LD_INT 4
97559: PUSH
97560: LD_INT 5
97562: PUSH
97563: LD_INT 6
97565: PUSH
97566: LD_INT 7
97568: PUSH
97569: LD_INT 8
97571: PUSH
97572: LD_INT 9
97574: PUSH
97575: LD_INT 10
97577: PUSH
97578: LD_INT 11
97580: PUSH
97581: LD_INT 12
97583: PUSH
97584: LD_INT 13
97586: PUSH
97587: LD_INT 14
97589: PUSH
97590: LD_INT 15
97592: PUSH
97593: LD_INT 16
97595: PUSH
97596: LD_INT 17
97598: PUSH
97599: LD_INT 18
97601: PUSH
97602: LD_INT 19
97604: PUSH
97605: LD_INT 20
97607: PUSH
97608: LD_INT 21
97610: PUSH
97611: LD_INT 22
97613: PUSH
97614: LD_INT 23
97616: PUSH
97617: LD_INT 24
97619: PUSH
97620: LD_INT 25
97622: PUSH
97623: LD_INT 26
97625: PUSH
97626: LD_INT 28
97628: PUSH
97629: LD_INT 30
97631: PUSH
97632: LD_INT 31
97634: PUSH
97635: LD_INT 32
97637: PUSH
97638: LD_INT 34
97640: PUSH
97641: LD_INT 36
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: PUSH
97677: LD_INT 101
97679: PUSH
97680: LD_INT 102
97682: PUSH
97683: LD_INT 103
97685: PUSH
97686: LD_INT 104
97688: PUSH
97689: LD_INT 105
97691: PUSH
97692: LD_INT 106
97694: PUSH
97695: LD_INT 107
97697: PUSH
97698: LD_INT 108
97700: PUSH
97701: LD_INT 109
97703: PUSH
97704: LD_INT 110
97706: PUSH
97707: LD_INT 111
97709: PUSH
97710: LD_INT 112
97712: PUSH
97713: LD_INT 114
97715: PUSH
97716: LD_INT 116
97718: PUSH
97719: LD_INT 117
97721: PUSH
97722: LD_INT 118
97724: PUSH
97725: EMPTY
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: PUSH
97743: EMPTY
97744: LIST
97745: LIST
97746: ST_TO_ADDR
97747: GO 99430
97749: LD_INT 12
97751: DOUBLE
97752: EQUAL
97753: IFTRUE 97757
97755: GO 97977
97757: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97758: LD_ADDR_VAR 0 2
97762: PUSH
97763: LD_INT 1
97765: PUSH
97766: LD_INT 2
97768: PUSH
97769: LD_INT 3
97771: PUSH
97772: LD_INT 4
97774: PUSH
97775: LD_INT 5
97777: PUSH
97778: LD_INT 6
97780: PUSH
97781: LD_INT 7
97783: PUSH
97784: LD_INT 8
97786: PUSH
97787: LD_INT 9
97789: PUSH
97790: LD_INT 10
97792: PUSH
97793: LD_INT 11
97795: PUSH
97796: LD_INT 12
97798: PUSH
97799: LD_INT 13
97801: PUSH
97802: LD_INT 14
97804: PUSH
97805: LD_INT 15
97807: PUSH
97808: LD_INT 16
97810: PUSH
97811: LD_INT 17
97813: PUSH
97814: LD_INT 18
97816: PUSH
97817: LD_INT 19
97819: PUSH
97820: LD_INT 20
97822: PUSH
97823: LD_INT 21
97825: PUSH
97826: LD_INT 22
97828: PUSH
97829: LD_INT 23
97831: PUSH
97832: LD_INT 24
97834: PUSH
97835: LD_INT 25
97837: PUSH
97838: LD_INT 26
97840: PUSH
97841: LD_INT 27
97843: PUSH
97844: LD_INT 28
97846: PUSH
97847: LD_INT 30
97849: PUSH
97850: LD_INT 31
97852: PUSH
97853: LD_INT 32
97855: PUSH
97856: LD_INT 33
97858: PUSH
97859: LD_INT 34
97861: PUSH
97862: LD_INT 36
97864: PUSH
97865: EMPTY
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: PUSH
97901: LD_INT 101
97903: PUSH
97904: LD_INT 102
97906: PUSH
97907: LD_INT 103
97909: PUSH
97910: LD_INT 104
97912: PUSH
97913: LD_INT 105
97915: PUSH
97916: LD_INT 106
97918: PUSH
97919: LD_INT 107
97921: PUSH
97922: LD_INT 108
97924: PUSH
97925: LD_INT 109
97927: PUSH
97928: LD_INT 110
97930: PUSH
97931: LD_INT 111
97933: PUSH
97934: LD_INT 112
97936: PUSH
97937: LD_INT 113
97939: PUSH
97940: LD_INT 114
97942: PUSH
97943: LD_INT 116
97945: PUSH
97946: LD_INT 117
97948: PUSH
97949: LD_INT 118
97951: PUSH
97952: EMPTY
97953: LIST
97954: LIST
97955: LIST
97956: LIST
97957: LIST
97958: LIST
97959: LIST
97960: LIST
97961: LIST
97962: LIST
97963: LIST
97964: LIST
97965: LIST
97966: LIST
97967: LIST
97968: LIST
97969: LIST
97970: PUSH
97971: EMPTY
97972: LIST
97973: LIST
97974: ST_TO_ADDR
97975: GO 99430
97977: LD_INT 13
97979: DOUBLE
97980: EQUAL
97981: IFTRUE 97985
97983: GO 98193
97985: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
97986: LD_ADDR_VAR 0 2
97990: PUSH
97991: LD_INT 1
97993: PUSH
97994: LD_INT 2
97996: PUSH
97997: LD_INT 3
97999: PUSH
98000: LD_INT 4
98002: PUSH
98003: LD_INT 5
98005: PUSH
98006: LD_INT 8
98008: PUSH
98009: LD_INT 9
98011: PUSH
98012: LD_INT 10
98014: PUSH
98015: LD_INT 11
98017: PUSH
98018: LD_INT 12
98020: PUSH
98021: LD_INT 14
98023: PUSH
98024: LD_INT 15
98026: PUSH
98027: LD_INT 16
98029: PUSH
98030: LD_INT 17
98032: PUSH
98033: LD_INT 18
98035: PUSH
98036: LD_INT 19
98038: PUSH
98039: LD_INT 20
98041: PUSH
98042: LD_INT 21
98044: PUSH
98045: LD_INT 22
98047: PUSH
98048: LD_INT 23
98050: PUSH
98051: LD_INT 24
98053: PUSH
98054: LD_INT 25
98056: PUSH
98057: LD_INT 26
98059: PUSH
98060: LD_INT 27
98062: PUSH
98063: LD_INT 28
98065: PUSH
98066: LD_INT 30
98068: PUSH
98069: LD_INT 31
98071: PUSH
98072: LD_INT 32
98074: PUSH
98075: LD_INT 33
98077: PUSH
98078: LD_INT 34
98080: PUSH
98081: LD_INT 36
98083: PUSH
98084: EMPTY
98085: LIST
98086: LIST
98087: LIST
98088: LIST
98089: LIST
98090: LIST
98091: LIST
98092: LIST
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: PUSH
98117: LD_INT 101
98119: PUSH
98120: LD_INT 102
98122: PUSH
98123: LD_INT 103
98125: PUSH
98126: LD_INT 104
98128: PUSH
98129: LD_INT 105
98131: PUSH
98132: LD_INT 106
98134: PUSH
98135: LD_INT 107
98137: PUSH
98138: LD_INT 108
98140: PUSH
98141: LD_INT 109
98143: PUSH
98144: LD_INT 110
98146: PUSH
98147: LD_INT 111
98149: PUSH
98150: LD_INT 112
98152: PUSH
98153: LD_INT 113
98155: PUSH
98156: LD_INT 114
98158: PUSH
98159: LD_INT 116
98161: PUSH
98162: LD_INT 117
98164: PUSH
98165: LD_INT 118
98167: PUSH
98168: EMPTY
98169: LIST
98170: LIST
98171: LIST
98172: LIST
98173: LIST
98174: LIST
98175: LIST
98176: LIST
98177: LIST
98178: LIST
98179: LIST
98180: LIST
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: LIST
98186: PUSH
98187: EMPTY
98188: LIST
98189: LIST
98190: ST_TO_ADDR
98191: GO 99430
98193: LD_INT 14
98195: DOUBLE
98196: EQUAL
98197: IFTRUE 98201
98199: GO 98425
98201: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98202: LD_ADDR_VAR 0 2
98206: PUSH
98207: LD_INT 1
98209: PUSH
98210: LD_INT 2
98212: PUSH
98213: LD_INT 3
98215: PUSH
98216: LD_INT 4
98218: PUSH
98219: LD_INT 5
98221: PUSH
98222: LD_INT 6
98224: PUSH
98225: LD_INT 7
98227: PUSH
98228: LD_INT 8
98230: PUSH
98231: LD_INT 9
98233: PUSH
98234: LD_INT 10
98236: PUSH
98237: LD_INT 11
98239: PUSH
98240: LD_INT 12
98242: PUSH
98243: LD_INT 13
98245: PUSH
98246: LD_INT 14
98248: PUSH
98249: LD_INT 15
98251: PUSH
98252: LD_INT 16
98254: PUSH
98255: LD_INT 17
98257: PUSH
98258: LD_INT 18
98260: PUSH
98261: LD_INT 19
98263: PUSH
98264: LD_INT 20
98266: PUSH
98267: LD_INT 21
98269: PUSH
98270: LD_INT 22
98272: PUSH
98273: LD_INT 23
98275: PUSH
98276: LD_INT 24
98278: PUSH
98279: LD_INT 25
98281: PUSH
98282: LD_INT 26
98284: PUSH
98285: LD_INT 27
98287: PUSH
98288: LD_INT 28
98290: PUSH
98291: LD_INT 29
98293: PUSH
98294: LD_INT 30
98296: PUSH
98297: LD_INT 31
98299: PUSH
98300: LD_INT 32
98302: PUSH
98303: LD_INT 33
98305: PUSH
98306: LD_INT 34
98308: PUSH
98309: LD_INT 36
98311: PUSH
98312: EMPTY
98313: LIST
98314: LIST
98315: LIST
98316: LIST
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: PUSH
98349: LD_INT 101
98351: PUSH
98352: LD_INT 102
98354: PUSH
98355: LD_INT 103
98357: PUSH
98358: LD_INT 104
98360: PUSH
98361: LD_INT 105
98363: PUSH
98364: LD_INT 106
98366: PUSH
98367: LD_INT 107
98369: PUSH
98370: LD_INT 108
98372: PUSH
98373: LD_INT 109
98375: PUSH
98376: LD_INT 110
98378: PUSH
98379: LD_INT 111
98381: PUSH
98382: LD_INT 112
98384: PUSH
98385: LD_INT 113
98387: PUSH
98388: LD_INT 114
98390: PUSH
98391: LD_INT 116
98393: PUSH
98394: LD_INT 117
98396: PUSH
98397: LD_INT 118
98399: PUSH
98400: EMPTY
98401: LIST
98402: LIST
98403: LIST
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: LIST
98409: LIST
98410: LIST
98411: LIST
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: LIST
98418: PUSH
98419: EMPTY
98420: LIST
98421: LIST
98422: ST_TO_ADDR
98423: GO 99430
98425: LD_INT 15
98427: DOUBLE
98428: EQUAL
98429: IFTRUE 98433
98431: GO 98657
98433: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98434: LD_ADDR_VAR 0 2
98438: PUSH
98439: LD_INT 1
98441: PUSH
98442: LD_INT 2
98444: PUSH
98445: LD_INT 3
98447: PUSH
98448: LD_INT 4
98450: PUSH
98451: LD_INT 5
98453: PUSH
98454: LD_INT 6
98456: PUSH
98457: LD_INT 7
98459: PUSH
98460: LD_INT 8
98462: PUSH
98463: LD_INT 9
98465: PUSH
98466: LD_INT 10
98468: PUSH
98469: LD_INT 11
98471: PUSH
98472: LD_INT 12
98474: PUSH
98475: LD_INT 13
98477: PUSH
98478: LD_INT 14
98480: PUSH
98481: LD_INT 15
98483: PUSH
98484: LD_INT 16
98486: PUSH
98487: LD_INT 17
98489: PUSH
98490: LD_INT 18
98492: PUSH
98493: LD_INT 19
98495: PUSH
98496: LD_INT 20
98498: PUSH
98499: LD_INT 21
98501: PUSH
98502: LD_INT 22
98504: PUSH
98505: LD_INT 23
98507: PUSH
98508: LD_INT 24
98510: PUSH
98511: LD_INT 25
98513: PUSH
98514: LD_INT 26
98516: PUSH
98517: LD_INT 27
98519: PUSH
98520: LD_INT 28
98522: PUSH
98523: LD_INT 29
98525: PUSH
98526: LD_INT 30
98528: PUSH
98529: LD_INT 31
98531: PUSH
98532: LD_INT 32
98534: PUSH
98535: LD_INT 33
98537: PUSH
98538: LD_INT 34
98540: PUSH
98541: LD_INT 36
98543: PUSH
98544: EMPTY
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: LIST
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: LIST
98573: LIST
98574: LIST
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: LIST
98580: PUSH
98581: LD_INT 101
98583: PUSH
98584: LD_INT 102
98586: PUSH
98587: LD_INT 103
98589: PUSH
98590: LD_INT 104
98592: PUSH
98593: LD_INT 105
98595: PUSH
98596: LD_INT 106
98598: PUSH
98599: LD_INT 107
98601: PUSH
98602: LD_INT 108
98604: PUSH
98605: LD_INT 109
98607: PUSH
98608: LD_INT 110
98610: PUSH
98611: LD_INT 111
98613: PUSH
98614: LD_INT 112
98616: PUSH
98617: LD_INT 113
98619: PUSH
98620: LD_INT 114
98622: PUSH
98623: LD_INT 116
98625: PUSH
98626: LD_INT 117
98628: PUSH
98629: LD_INT 118
98631: PUSH
98632: EMPTY
98633: LIST
98634: LIST
98635: LIST
98636: LIST
98637: LIST
98638: LIST
98639: LIST
98640: LIST
98641: LIST
98642: LIST
98643: LIST
98644: LIST
98645: LIST
98646: LIST
98647: LIST
98648: LIST
98649: LIST
98650: PUSH
98651: EMPTY
98652: LIST
98653: LIST
98654: ST_TO_ADDR
98655: GO 99430
98657: LD_INT 16
98659: DOUBLE
98660: EQUAL
98661: IFTRUE 98665
98663: GO 98801
98665: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98666: LD_ADDR_VAR 0 2
98670: PUSH
98671: LD_INT 2
98673: PUSH
98674: LD_INT 4
98676: PUSH
98677: LD_INT 5
98679: PUSH
98680: LD_INT 7
98682: PUSH
98683: LD_INT 11
98685: PUSH
98686: LD_INT 12
98688: PUSH
98689: LD_INT 15
98691: PUSH
98692: LD_INT 16
98694: PUSH
98695: LD_INT 20
98697: PUSH
98698: LD_INT 21
98700: PUSH
98701: LD_INT 22
98703: PUSH
98704: LD_INT 23
98706: PUSH
98707: LD_INT 25
98709: PUSH
98710: LD_INT 26
98712: PUSH
98713: LD_INT 30
98715: PUSH
98716: LD_INT 31
98718: PUSH
98719: LD_INT 32
98721: PUSH
98722: LD_INT 33
98724: PUSH
98725: LD_INT 34
98727: PUSH
98728: EMPTY
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: PUSH
98749: LD_INT 101
98751: PUSH
98752: LD_INT 102
98754: PUSH
98755: LD_INT 103
98757: PUSH
98758: LD_INT 106
98760: PUSH
98761: LD_INT 108
98763: PUSH
98764: LD_INT 112
98766: PUSH
98767: LD_INT 113
98769: PUSH
98770: LD_INT 114
98772: PUSH
98773: LD_INT 116
98775: PUSH
98776: LD_INT 117
98778: PUSH
98779: LD_INT 118
98781: PUSH
98782: EMPTY
98783: LIST
98784: LIST
98785: LIST
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: LIST
98791: LIST
98792: LIST
98793: LIST
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: ST_TO_ADDR
98799: GO 99430
98801: LD_INT 17
98803: DOUBLE
98804: EQUAL
98805: IFTRUE 98809
98807: GO 99033
98809: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
98810: LD_ADDR_VAR 0 2
98814: PUSH
98815: LD_INT 1
98817: PUSH
98818: LD_INT 2
98820: PUSH
98821: LD_INT 3
98823: PUSH
98824: LD_INT 4
98826: PUSH
98827: LD_INT 5
98829: PUSH
98830: LD_INT 6
98832: PUSH
98833: LD_INT 7
98835: PUSH
98836: LD_INT 8
98838: PUSH
98839: LD_INT 9
98841: PUSH
98842: LD_INT 10
98844: PUSH
98845: LD_INT 11
98847: PUSH
98848: LD_INT 12
98850: PUSH
98851: LD_INT 13
98853: PUSH
98854: LD_INT 14
98856: PUSH
98857: LD_INT 15
98859: PUSH
98860: LD_INT 16
98862: PUSH
98863: LD_INT 17
98865: PUSH
98866: LD_INT 18
98868: PUSH
98869: LD_INT 19
98871: PUSH
98872: LD_INT 20
98874: PUSH
98875: LD_INT 21
98877: PUSH
98878: LD_INT 22
98880: PUSH
98881: LD_INT 23
98883: PUSH
98884: LD_INT 24
98886: PUSH
98887: LD_INT 25
98889: PUSH
98890: LD_INT 26
98892: PUSH
98893: LD_INT 27
98895: PUSH
98896: LD_INT 28
98898: PUSH
98899: LD_INT 29
98901: PUSH
98902: LD_INT 30
98904: PUSH
98905: LD_INT 31
98907: PUSH
98908: LD_INT 32
98910: PUSH
98911: LD_INT 33
98913: PUSH
98914: LD_INT 34
98916: PUSH
98917: LD_INT 36
98919: PUSH
98920: EMPTY
98921: LIST
98922: LIST
98923: LIST
98924: LIST
98925: LIST
98926: LIST
98927: LIST
98928: LIST
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: LIST
98946: LIST
98947: LIST
98948: LIST
98949: LIST
98950: LIST
98951: LIST
98952: LIST
98953: LIST
98954: LIST
98955: LIST
98956: PUSH
98957: LD_INT 101
98959: PUSH
98960: LD_INT 102
98962: PUSH
98963: LD_INT 103
98965: PUSH
98966: LD_INT 104
98968: PUSH
98969: LD_INT 105
98971: PUSH
98972: LD_INT 106
98974: PUSH
98975: LD_INT 107
98977: PUSH
98978: LD_INT 108
98980: PUSH
98981: LD_INT 109
98983: PUSH
98984: LD_INT 110
98986: PUSH
98987: LD_INT 111
98989: PUSH
98990: LD_INT 112
98992: PUSH
98993: LD_INT 113
98995: PUSH
98996: LD_INT 114
98998: PUSH
98999: LD_INT 116
99001: PUSH
99002: LD_INT 117
99004: PUSH
99005: LD_INT 118
99007: PUSH
99008: EMPTY
99009: LIST
99010: LIST
99011: LIST
99012: LIST
99013: LIST
99014: LIST
99015: LIST
99016: LIST
99017: LIST
99018: LIST
99019: LIST
99020: LIST
99021: LIST
99022: LIST
99023: LIST
99024: LIST
99025: LIST
99026: PUSH
99027: EMPTY
99028: LIST
99029: LIST
99030: ST_TO_ADDR
99031: GO 99430
99033: LD_INT 18
99035: DOUBLE
99036: EQUAL
99037: IFTRUE 99041
99039: GO 99189
99041: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99042: LD_ADDR_VAR 0 2
99046: PUSH
99047: LD_INT 2
99049: PUSH
99050: LD_INT 4
99052: PUSH
99053: LD_INT 5
99055: PUSH
99056: LD_INT 7
99058: PUSH
99059: LD_INT 11
99061: PUSH
99062: LD_INT 12
99064: PUSH
99065: LD_INT 15
99067: PUSH
99068: LD_INT 16
99070: PUSH
99071: LD_INT 20
99073: PUSH
99074: LD_INT 21
99076: PUSH
99077: LD_INT 22
99079: PUSH
99080: LD_INT 23
99082: PUSH
99083: LD_INT 25
99085: PUSH
99086: LD_INT 26
99088: PUSH
99089: LD_INT 30
99091: PUSH
99092: LD_INT 31
99094: PUSH
99095: LD_INT 32
99097: PUSH
99098: LD_INT 33
99100: PUSH
99101: LD_INT 34
99103: PUSH
99104: LD_INT 35
99106: PUSH
99107: LD_INT 36
99109: PUSH
99110: EMPTY
99111: LIST
99112: LIST
99113: LIST
99114: LIST
99115: LIST
99116: LIST
99117: LIST
99118: LIST
99119: LIST
99120: LIST
99121: LIST
99122: LIST
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: LIST
99128: LIST
99129: LIST
99130: LIST
99131: LIST
99132: PUSH
99133: LD_INT 101
99135: PUSH
99136: LD_INT 102
99138: PUSH
99139: LD_INT 103
99141: PUSH
99142: LD_INT 106
99144: PUSH
99145: LD_INT 108
99147: PUSH
99148: LD_INT 112
99150: PUSH
99151: LD_INT 113
99153: PUSH
99154: LD_INT 114
99156: PUSH
99157: LD_INT 115
99159: PUSH
99160: LD_INT 116
99162: PUSH
99163: LD_INT 117
99165: PUSH
99166: LD_INT 118
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: LIST
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: LIST
99181: LIST
99182: PUSH
99183: EMPTY
99184: LIST
99185: LIST
99186: ST_TO_ADDR
99187: GO 99430
99189: LD_INT 19
99191: DOUBLE
99192: EQUAL
99193: IFTRUE 99197
99195: GO 99429
99197: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99198: LD_ADDR_VAR 0 2
99202: PUSH
99203: LD_INT 1
99205: PUSH
99206: LD_INT 2
99208: PUSH
99209: LD_INT 3
99211: PUSH
99212: LD_INT 4
99214: PUSH
99215: LD_INT 5
99217: PUSH
99218: LD_INT 6
99220: PUSH
99221: LD_INT 7
99223: PUSH
99224: LD_INT 8
99226: PUSH
99227: LD_INT 9
99229: PUSH
99230: LD_INT 10
99232: PUSH
99233: LD_INT 11
99235: PUSH
99236: LD_INT 12
99238: PUSH
99239: LD_INT 13
99241: PUSH
99242: LD_INT 14
99244: PUSH
99245: LD_INT 15
99247: PUSH
99248: LD_INT 16
99250: PUSH
99251: LD_INT 17
99253: PUSH
99254: LD_INT 18
99256: PUSH
99257: LD_INT 19
99259: PUSH
99260: LD_INT 20
99262: PUSH
99263: LD_INT 21
99265: PUSH
99266: LD_INT 22
99268: PUSH
99269: LD_INT 23
99271: PUSH
99272: LD_INT 24
99274: PUSH
99275: LD_INT 25
99277: PUSH
99278: LD_INT 26
99280: PUSH
99281: LD_INT 27
99283: PUSH
99284: LD_INT 28
99286: PUSH
99287: LD_INT 29
99289: PUSH
99290: LD_INT 30
99292: PUSH
99293: LD_INT 31
99295: PUSH
99296: LD_INT 32
99298: PUSH
99299: LD_INT 33
99301: PUSH
99302: LD_INT 34
99304: PUSH
99305: LD_INT 35
99307: PUSH
99308: LD_INT 36
99310: PUSH
99311: EMPTY
99312: LIST
99313: LIST
99314: LIST
99315: LIST
99316: LIST
99317: LIST
99318: LIST
99319: LIST
99320: LIST
99321: LIST
99322: LIST
99323: LIST
99324: LIST
99325: LIST
99326: LIST
99327: LIST
99328: LIST
99329: LIST
99330: LIST
99331: LIST
99332: LIST
99333: LIST
99334: LIST
99335: LIST
99336: LIST
99337: LIST
99338: LIST
99339: LIST
99340: LIST
99341: LIST
99342: LIST
99343: LIST
99344: LIST
99345: LIST
99346: LIST
99347: LIST
99348: PUSH
99349: LD_INT 101
99351: PUSH
99352: LD_INT 102
99354: PUSH
99355: LD_INT 103
99357: PUSH
99358: LD_INT 104
99360: PUSH
99361: LD_INT 105
99363: PUSH
99364: LD_INT 106
99366: PUSH
99367: LD_INT 107
99369: PUSH
99370: LD_INT 108
99372: PUSH
99373: LD_INT 109
99375: PUSH
99376: LD_INT 110
99378: PUSH
99379: LD_INT 111
99381: PUSH
99382: LD_INT 112
99384: PUSH
99385: LD_INT 113
99387: PUSH
99388: LD_INT 114
99390: PUSH
99391: LD_INT 115
99393: PUSH
99394: LD_INT 116
99396: PUSH
99397: LD_INT 117
99399: PUSH
99400: LD_INT 118
99402: PUSH
99403: EMPTY
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: LIST
99416: LIST
99417: LIST
99418: LIST
99419: LIST
99420: LIST
99421: LIST
99422: PUSH
99423: EMPTY
99424: LIST
99425: LIST
99426: ST_TO_ADDR
99427: GO 99430
99429: POP
// end else
99430: GO 99661
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99432: LD_ADDR_VAR 0 2
99436: PUSH
99437: LD_INT 1
99439: PUSH
99440: LD_INT 2
99442: PUSH
99443: LD_INT 3
99445: PUSH
99446: LD_INT 4
99448: PUSH
99449: LD_INT 5
99451: PUSH
99452: LD_INT 6
99454: PUSH
99455: LD_INT 7
99457: PUSH
99458: LD_INT 8
99460: PUSH
99461: LD_INT 9
99463: PUSH
99464: LD_INT 10
99466: PUSH
99467: LD_INT 11
99469: PUSH
99470: LD_INT 12
99472: PUSH
99473: LD_INT 13
99475: PUSH
99476: LD_INT 14
99478: PUSH
99479: LD_INT 15
99481: PUSH
99482: LD_INT 16
99484: PUSH
99485: LD_INT 17
99487: PUSH
99488: LD_INT 18
99490: PUSH
99491: LD_INT 19
99493: PUSH
99494: LD_INT 20
99496: PUSH
99497: LD_INT 21
99499: PUSH
99500: LD_INT 22
99502: PUSH
99503: LD_INT 23
99505: PUSH
99506: LD_INT 24
99508: PUSH
99509: LD_INT 25
99511: PUSH
99512: LD_INT 26
99514: PUSH
99515: LD_INT 27
99517: PUSH
99518: LD_INT 28
99520: PUSH
99521: LD_INT 29
99523: PUSH
99524: LD_INT 30
99526: PUSH
99527: LD_INT 31
99529: PUSH
99530: LD_INT 32
99532: PUSH
99533: LD_INT 33
99535: PUSH
99536: LD_INT 34
99538: PUSH
99539: LD_INT 35
99541: PUSH
99542: LD_INT 36
99544: PUSH
99545: EMPTY
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: LIST
99563: LIST
99564: LIST
99565: LIST
99566: LIST
99567: LIST
99568: LIST
99569: LIST
99570: LIST
99571: LIST
99572: LIST
99573: LIST
99574: LIST
99575: LIST
99576: LIST
99577: LIST
99578: LIST
99579: LIST
99580: LIST
99581: LIST
99582: PUSH
99583: LD_INT 101
99585: PUSH
99586: LD_INT 102
99588: PUSH
99589: LD_INT 103
99591: PUSH
99592: LD_INT 104
99594: PUSH
99595: LD_INT 105
99597: PUSH
99598: LD_INT 106
99600: PUSH
99601: LD_INT 107
99603: PUSH
99604: LD_INT 108
99606: PUSH
99607: LD_INT 109
99609: PUSH
99610: LD_INT 110
99612: PUSH
99613: LD_INT 111
99615: PUSH
99616: LD_INT 112
99618: PUSH
99619: LD_INT 113
99621: PUSH
99622: LD_INT 114
99624: PUSH
99625: LD_INT 115
99627: PUSH
99628: LD_INT 116
99630: PUSH
99631: LD_INT 117
99633: PUSH
99634: LD_INT 118
99636: PUSH
99637: EMPTY
99638: LIST
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: LIST
99647: LIST
99648: LIST
99649: LIST
99650: LIST
99651: LIST
99652: LIST
99653: LIST
99654: LIST
99655: LIST
99656: PUSH
99657: EMPTY
99658: LIST
99659: LIST
99660: ST_TO_ADDR
// if result then
99661: LD_VAR 0 2
99665: IFFALSE 100451
// begin normal :=  ;
99667: LD_ADDR_VAR 0 5
99671: PUSH
99672: LD_STRING 
99674: ST_TO_ADDR
// hardcore :=  ;
99675: LD_ADDR_VAR 0 6
99679: PUSH
99680: LD_STRING 
99682: ST_TO_ADDR
// active :=  ;
99683: LD_ADDR_VAR 0 7
99687: PUSH
99688: LD_STRING 
99690: ST_TO_ADDR
// for i = 1 to normalCounter do
99691: LD_ADDR_VAR 0 8
99695: PUSH
99696: DOUBLE
99697: LD_INT 1
99699: DEC
99700: ST_TO_ADDR
99701: LD_EXP 125
99705: PUSH
99706: FOR_TO
99707: IFFALSE 99808
// begin tmp := 0 ;
99709: LD_ADDR_VAR 0 3
99713: PUSH
99714: LD_STRING 0
99716: ST_TO_ADDR
// if result [ 1 ] then
99717: LD_VAR 0 2
99721: PUSH
99722: LD_INT 1
99724: ARRAY
99725: IFFALSE 99790
// if result [ 1 ] [ 1 ] = i then
99727: LD_VAR 0 2
99731: PUSH
99732: LD_INT 1
99734: ARRAY
99735: PUSH
99736: LD_INT 1
99738: ARRAY
99739: PUSH
99740: LD_VAR 0 8
99744: EQUAL
99745: IFFALSE 99790
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99747: LD_ADDR_VAR 0 2
99751: PUSH
99752: LD_VAR 0 2
99756: PPUSH
99757: LD_INT 1
99759: PPUSH
99760: LD_VAR 0 2
99764: PUSH
99765: LD_INT 1
99767: ARRAY
99768: PPUSH
99769: LD_INT 1
99771: PPUSH
99772: CALL_OW 3
99776: PPUSH
99777: CALL_OW 1
99781: ST_TO_ADDR
// tmp := 1 ;
99782: LD_ADDR_VAR 0 3
99786: PUSH
99787: LD_STRING 1
99789: ST_TO_ADDR
// end ; normal := normal & tmp ;
99790: LD_ADDR_VAR 0 5
99794: PUSH
99795: LD_VAR 0 5
99799: PUSH
99800: LD_VAR 0 3
99804: STR
99805: ST_TO_ADDR
// end ;
99806: GO 99706
99808: POP
99809: POP
// for i = 1 to hardcoreCounter do
99810: LD_ADDR_VAR 0 8
99814: PUSH
99815: DOUBLE
99816: LD_INT 1
99818: DEC
99819: ST_TO_ADDR
99820: LD_EXP 126
99824: PUSH
99825: FOR_TO
99826: IFFALSE 99931
// begin tmp := 0 ;
99828: LD_ADDR_VAR 0 3
99832: PUSH
99833: LD_STRING 0
99835: ST_TO_ADDR
// if result [ 2 ] then
99836: LD_VAR 0 2
99840: PUSH
99841: LD_INT 2
99843: ARRAY
99844: IFFALSE 99913
// if result [ 2 ] [ 1 ] = 100 + i then
99846: LD_VAR 0 2
99850: PUSH
99851: LD_INT 2
99853: ARRAY
99854: PUSH
99855: LD_INT 1
99857: ARRAY
99858: PUSH
99859: LD_INT 100
99861: PUSH
99862: LD_VAR 0 8
99866: PLUS
99867: EQUAL
99868: IFFALSE 99913
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
99870: LD_ADDR_VAR 0 2
99874: PUSH
99875: LD_VAR 0 2
99879: PPUSH
99880: LD_INT 2
99882: PPUSH
99883: LD_VAR 0 2
99887: PUSH
99888: LD_INT 2
99890: ARRAY
99891: PPUSH
99892: LD_INT 1
99894: PPUSH
99895: CALL_OW 3
99899: PPUSH
99900: CALL_OW 1
99904: ST_TO_ADDR
// tmp := 1 ;
99905: LD_ADDR_VAR 0 3
99909: PUSH
99910: LD_STRING 1
99912: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
99913: LD_ADDR_VAR 0 6
99917: PUSH
99918: LD_VAR 0 6
99922: PUSH
99923: LD_VAR 0 3
99927: STR
99928: ST_TO_ADDR
// end ;
99929: GO 99825
99931: POP
99932: POP
// if isGameLoad then
99933: LD_VAR 0 1
99937: IFFALSE 100412
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
99939: LD_ADDR_VAR 0 4
99943: PUSH
99944: LD_EXP 129
99948: PUSH
99949: LD_EXP 128
99953: PUSH
99954: LD_EXP 130
99958: PUSH
99959: LD_EXP 127
99963: PUSH
99964: LD_EXP 131
99968: PUSH
99969: LD_EXP 132
99973: PUSH
99974: LD_EXP 133
99978: PUSH
99979: LD_EXP 134
99983: PUSH
99984: LD_EXP 135
99988: PUSH
99989: LD_EXP 136
99993: PUSH
99994: LD_EXP 137
99998: PUSH
99999: LD_EXP 138
100003: PUSH
100004: LD_EXP 139
100008: PUSH
100009: LD_EXP 140
100013: PUSH
100014: LD_EXP 148
100018: PUSH
100019: LD_EXP 149
100023: PUSH
100024: LD_EXP 150
100028: PUSH
100029: LD_EXP 151
100033: PUSH
100034: LD_EXP 153
100038: PUSH
100039: LD_EXP 154
100043: PUSH
100044: LD_EXP 155
100048: PUSH
100049: LD_EXP 158
100053: PUSH
100054: LD_EXP 160
100058: PUSH
100059: LD_EXP 161
100063: PUSH
100064: LD_EXP 162
100068: PUSH
100069: LD_EXP 164
100073: PUSH
100074: LD_EXP 165
100078: PUSH
100079: LD_EXP 168
100083: PUSH
100084: LD_EXP 169
100088: PUSH
100089: LD_EXP 170
100093: PUSH
100094: LD_EXP 171
100098: PUSH
100099: LD_EXP 172
100103: PUSH
100104: LD_EXP 173
100108: PUSH
100109: LD_EXP 174
100113: PUSH
100114: LD_EXP 175
100118: PUSH
100119: LD_EXP 176
100123: PUSH
100124: LD_EXP 141
100128: PUSH
100129: LD_EXP 142
100133: PUSH
100134: LD_EXP 145
100138: PUSH
100139: LD_EXP 146
100143: PUSH
100144: LD_EXP 147
100148: PUSH
100149: LD_EXP 143
100153: PUSH
100154: LD_EXP 144
100158: PUSH
100159: LD_EXP 152
100163: PUSH
100164: LD_EXP 156
100168: PUSH
100169: LD_EXP 157
100173: PUSH
100174: LD_EXP 159
100178: PUSH
100179: LD_EXP 163
100183: PUSH
100184: LD_EXP 166
100188: PUSH
100189: LD_EXP 167
100193: PUSH
100194: LD_EXP 177
100198: PUSH
100199: LD_EXP 178
100203: PUSH
100204: LD_EXP 179
100208: PUSH
100209: LD_EXP 180
100213: PUSH
100214: EMPTY
100215: LIST
100216: LIST
100217: LIST
100218: LIST
100219: LIST
100220: LIST
100221: LIST
100222: LIST
100223: LIST
100224: LIST
100225: LIST
100226: LIST
100227: LIST
100228: LIST
100229: LIST
100230: LIST
100231: LIST
100232: LIST
100233: LIST
100234: LIST
100235: LIST
100236: LIST
100237: LIST
100238: LIST
100239: LIST
100240: LIST
100241: LIST
100242: LIST
100243: LIST
100244: LIST
100245: LIST
100246: LIST
100247: LIST
100248: LIST
100249: LIST
100250: LIST
100251: LIST
100252: LIST
100253: LIST
100254: LIST
100255: LIST
100256: LIST
100257: LIST
100258: LIST
100259: LIST
100260: LIST
100261: LIST
100262: LIST
100263: LIST
100264: LIST
100265: LIST
100266: LIST
100267: LIST
100268: LIST
100269: ST_TO_ADDR
// tmp :=  ;
100270: LD_ADDR_VAR 0 3
100274: PUSH
100275: LD_STRING 
100277: ST_TO_ADDR
// for i = 1 to normalCounter do
100278: LD_ADDR_VAR 0 8
100282: PUSH
100283: DOUBLE
100284: LD_INT 1
100286: DEC
100287: ST_TO_ADDR
100288: LD_EXP 125
100292: PUSH
100293: FOR_TO
100294: IFFALSE 100330
// begin if flags [ i ] then
100296: LD_VAR 0 4
100300: PUSH
100301: LD_VAR 0 8
100305: ARRAY
100306: IFFALSE 100328
// tmp := tmp & i & ; ;
100308: LD_ADDR_VAR 0 3
100312: PUSH
100313: LD_VAR 0 3
100317: PUSH
100318: LD_VAR 0 8
100322: STR
100323: PUSH
100324: LD_STRING ;
100326: STR
100327: ST_TO_ADDR
// end ;
100328: GO 100293
100330: POP
100331: POP
// for i = 1 to hardcoreCounter do
100332: LD_ADDR_VAR 0 8
100336: PUSH
100337: DOUBLE
100338: LD_INT 1
100340: DEC
100341: ST_TO_ADDR
100342: LD_EXP 126
100346: PUSH
100347: FOR_TO
100348: IFFALSE 100394
// begin if flags [ normalCounter + i ] then
100350: LD_VAR 0 4
100354: PUSH
100355: LD_EXP 125
100359: PUSH
100360: LD_VAR 0 8
100364: PLUS
100365: ARRAY
100366: IFFALSE 100392
// tmp := tmp & ( 100 + i ) & ; ;
100368: LD_ADDR_VAR 0 3
100372: PUSH
100373: LD_VAR 0 3
100377: PUSH
100378: LD_INT 100
100380: PUSH
100381: LD_VAR 0 8
100385: PLUS
100386: STR
100387: PUSH
100388: LD_STRING ;
100390: STR
100391: ST_TO_ADDR
// end ;
100392: GO 100347
100394: POP
100395: POP
// if tmp then
100396: LD_VAR 0 3
100400: IFFALSE 100412
// active := tmp ;
100402: LD_ADDR_VAR 0 7
100406: PUSH
100407: LD_VAR 0 3
100411: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100412: LD_STRING getStreamItemsFromMission("
100414: PUSH
100415: LD_VAR 0 5
100419: STR
100420: PUSH
100421: LD_STRING ","
100423: STR
100424: PUSH
100425: LD_VAR 0 6
100429: STR
100430: PUSH
100431: LD_STRING ","
100433: STR
100434: PUSH
100435: LD_VAR 0 7
100439: STR
100440: PUSH
100441: LD_STRING ")
100443: STR
100444: PPUSH
100445: CALL_OW 559
// end else
100449: GO 100458
// ToLua ( getStreamItemsFromMission("","","") ) ;
100451: LD_STRING getStreamItemsFromMission("","","")
100453: PPUSH
100454: CALL_OW 559
// end ;
100458: LD_VAR 0 2
100462: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100463: LD_EXP 124
100467: PUSH
100468: LD_EXP 129
100472: AND
100473: IFFALSE 100597
100475: GO 100477
100477: DISABLE
100478: LD_INT 0
100480: PPUSH
100481: PPUSH
// begin enable ;
100482: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100483: LD_ADDR_VAR 0 2
100487: PUSH
100488: LD_INT 22
100490: PUSH
100491: LD_OWVAR 2
100495: PUSH
100496: EMPTY
100497: LIST
100498: LIST
100499: PUSH
100500: LD_INT 2
100502: PUSH
100503: LD_INT 34
100505: PUSH
100506: LD_INT 7
100508: PUSH
100509: EMPTY
100510: LIST
100511: LIST
100512: PUSH
100513: LD_INT 34
100515: PUSH
100516: LD_INT 45
100518: PUSH
100519: EMPTY
100520: LIST
100521: LIST
100522: PUSH
100523: LD_INT 34
100525: PUSH
100526: LD_INT 28
100528: PUSH
100529: EMPTY
100530: LIST
100531: LIST
100532: PUSH
100533: LD_INT 34
100535: PUSH
100536: LD_INT 47
100538: PUSH
100539: EMPTY
100540: LIST
100541: LIST
100542: PUSH
100543: EMPTY
100544: LIST
100545: LIST
100546: LIST
100547: LIST
100548: LIST
100549: PUSH
100550: EMPTY
100551: LIST
100552: LIST
100553: PPUSH
100554: CALL_OW 69
100558: ST_TO_ADDR
// if not tmp then
100559: LD_VAR 0 2
100563: NOT
100564: IFFALSE 100568
// exit ;
100566: GO 100597
// for i in tmp do
100568: LD_ADDR_VAR 0 1
100572: PUSH
100573: LD_VAR 0 2
100577: PUSH
100578: FOR_IN
100579: IFFALSE 100595
// begin SetLives ( i , 0 ) ;
100581: LD_VAR 0 1
100585: PPUSH
100586: LD_INT 0
100588: PPUSH
100589: CALL_OW 234
// end ;
100593: GO 100578
100595: POP
100596: POP
// end ;
100597: PPOPN 2
100599: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100600: LD_EXP 124
100604: PUSH
100605: LD_EXP 130
100609: AND
100610: IFFALSE 100694
100612: GO 100614
100614: DISABLE
100615: LD_INT 0
100617: PPUSH
100618: PPUSH
// begin enable ;
100619: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100620: LD_ADDR_VAR 0 2
100624: PUSH
100625: LD_INT 22
100627: PUSH
100628: LD_OWVAR 2
100632: PUSH
100633: EMPTY
100634: LIST
100635: LIST
100636: PUSH
100637: LD_INT 32
100639: PUSH
100640: LD_INT 3
100642: PUSH
100643: EMPTY
100644: LIST
100645: LIST
100646: PUSH
100647: EMPTY
100648: LIST
100649: LIST
100650: PPUSH
100651: CALL_OW 69
100655: ST_TO_ADDR
// if not tmp then
100656: LD_VAR 0 2
100660: NOT
100661: IFFALSE 100665
// exit ;
100663: GO 100694
// for i in tmp do
100665: LD_ADDR_VAR 0 1
100669: PUSH
100670: LD_VAR 0 2
100674: PUSH
100675: FOR_IN
100676: IFFALSE 100692
// begin SetLives ( i , 0 ) ;
100678: LD_VAR 0 1
100682: PPUSH
100683: LD_INT 0
100685: PPUSH
100686: CALL_OW 234
// end ;
100690: GO 100675
100692: POP
100693: POP
// end ;
100694: PPOPN 2
100696: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100697: LD_EXP 124
100701: PUSH
100702: LD_EXP 127
100706: AND
100707: IFFALSE 100800
100709: GO 100711
100711: DISABLE
100712: LD_INT 0
100714: PPUSH
// begin enable ;
100715: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100716: LD_ADDR_VAR 0 1
100720: PUSH
100721: LD_INT 22
100723: PUSH
100724: LD_OWVAR 2
100728: PUSH
100729: EMPTY
100730: LIST
100731: LIST
100732: PUSH
100733: LD_INT 2
100735: PUSH
100736: LD_INT 25
100738: PUSH
100739: LD_INT 5
100741: PUSH
100742: EMPTY
100743: LIST
100744: LIST
100745: PUSH
100746: LD_INT 25
100748: PUSH
100749: LD_INT 9
100751: PUSH
100752: EMPTY
100753: LIST
100754: LIST
100755: PUSH
100756: LD_INT 25
100758: PUSH
100759: LD_INT 8
100761: PUSH
100762: EMPTY
100763: LIST
100764: LIST
100765: PUSH
100766: EMPTY
100767: LIST
100768: LIST
100769: LIST
100770: LIST
100771: PUSH
100772: EMPTY
100773: LIST
100774: LIST
100775: PPUSH
100776: CALL_OW 69
100780: PUSH
100781: FOR_IN
100782: IFFALSE 100798
// begin SetClass ( i , 1 ) ;
100784: LD_VAR 0 1
100788: PPUSH
100789: LD_INT 1
100791: PPUSH
100792: CALL_OW 336
// end ;
100796: GO 100781
100798: POP
100799: POP
// end ;
100800: PPOPN 1
100802: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
100803: LD_EXP 124
100807: PUSH
100808: LD_EXP 128
100812: AND
100813: PUSH
100814: LD_OWVAR 65
100818: PUSH
100819: LD_INT 7
100821: LESS
100822: AND
100823: IFFALSE 100837
100825: GO 100827
100827: DISABLE
// begin enable ;
100828: ENABLE
// game_speed := 7 ;
100829: LD_ADDR_OWVAR 65
100833: PUSH
100834: LD_INT 7
100836: ST_TO_ADDR
// end ;
100837: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100838: LD_EXP 124
100842: PUSH
100843: LD_EXP 131
100847: AND
100848: IFFALSE 101050
100850: GO 100852
100852: DISABLE
100853: LD_INT 0
100855: PPUSH
100856: PPUSH
100857: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100858: LD_ADDR_VAR 0 3
100862: PUSH
100863: LD_INT 81
100865: PUSH
100866: LD_OWVAR 2
100870: PUSH
100871: EMPTY
100872: LIST
100873: LIST
100874: PUSH
100875: LD_INT 21
100877: PUSH
100878: LD_INT 1
100880: PUSH
100881: EMPTY
100882: LIST
100883: LIST
100884: PUSH
100885: EMPTY
100886: LIST
100887: LIST
100888: PPUSH
100889: CALL_OW 69
100893: ST_TO_ADDR
// if not tmp then
100894: LD_VAR 0 3
100898: NOT
100899: IFFALSE 100903
// exit ;
100901: GO 101050
// if tmp > 5 then
100903: LD_VAR 0 3
100907: PUSH
100908: LD_INT 5
100910: GREATER
100911: IFFALSE 100923
// k := 5 else
100913: LD_ADDR_VAR 0 2
100917: PUSH
100918: LD_INT 5
100920: ST_TO_ADDR
100921: GO 100933
// k := tmp ;
100923: LD_ADDR_VAR 0 2
100927: PUSH
100928: LD_VAR 0 3
100932: ST_TO_ADDR
// for i := 1 to k do
100933: LD_ADDR_VAR 0 1
100937: PUSH
100938: DOUBLE
100939: LD_INT 1
100941: DEC
100942: ST_TO_ADDR
100943: LD_VAR 0 2
100947: PUSH
100948: FOR_TO
100949: IFFALSE 101048
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
100951: LD_VAR 0 3
100955: PUSH
100956: LD_VAR 0 1
100960: ARRAY
100961: PPUSH
100962: LD_VAR 0 1
100966: PUSH
100967: LD_INT 4
100969: MOD
100970: PUSH
100971: LD_INT 1
100973: PLUS
100974: PPUSH
100975: CALL_OW 259
100979: PUSH
100980: LD_INT 10
100982: LESS
100983: IFFALSE 101046
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
100985: LD_VAR 0 3
100989: PUSH
100990: LD_VAR 0 1
100994: ARRAY
100995: PPUSH
100996: LD_VAR 0 1
101000: PUSH
101001: LD_INT 4
101003: MOD
101004: PUSH
101005: LD_INT 1
101007: PLUS
101008: PPUSH
101009: LD_VAR 0 3
101013: PUSH
101014: LD_VAR 0 1
101018: ARRAY
101019: PPUSH
101020: LD_VAR 0 1
101024: PUSH
101025: LD_INT 4
101027: MOD
101028: PUSH
101029: LD_INT 1
101031: PLUS
101032: PPUSH
101033: CALL_OW 259
101037: PUSH
101038: LD_INT 1
101040: PLUS
101041: PPUSH
101042: CALL_OW 237
101046: GO 100948
101048: POP
101049: POP
// end ;
101050: PPOPN 3
101052: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101053: LD_EXP 124
101057: PUSH
101058: LD_EXP 132
101062: AND
101063: IFFALSE 101083
101065: GO 101067
101067: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101068: LD_INT 4
101070: PPUSH
101071: LD_OWVAR 2
101075: PPUSH
101076: LD_INT 0
101078: PPUSH
101079: CALL_OW 324
101083: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101084: LD_EXP 124
101088: PUSH
101089: LD_EXP 161
101093: AND
101094: IFFALSE 101114
101096: GO 101098
101098: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101099: LD_INT 19
101101: PPUSH
101102: LD_OWVAR 2
101106: PPUSH
101107: LD_INT 0
101109: PPUSH
101110: CALL_OW 324
101114: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101115: LD_EXP 124
101119: PUSH
101120: LD_EXP 133
101124: AND
101125: IFFALSE 101227
101127: GO 101129
101129: DISABLE
101130: LD_INT 0
101132: PPUSH
101133: PPUSH
// begin enable ;
101134: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101135: LD_ADDR_VAR 0 2
101139: PUSH
101140: LD_INT 22
101142: PUSH
101143: LD_OWVAR 2
101147: PUSH
101148: EMPTY
101149: LIST
101150: LIST
101151: PUSH
101152: LD_INT 2
101154: PUSH
101155: LD_INT 34
101157: PUSH
101158: LD_INT 11
101160: PUSH
101161: EMPTY
101162: LIST
101163: LIST
101164: PUSH
101165: LD_INT 34
101167: PUSH
101168: LD_INT 30
101170: PUSH
101171: EMPTY
101172: LIST
101173: LIST
101174: PUSH
101175: EMPTY
101176: LIST
101177: LIST
101178: LIST
101179: PUSH
101180: EMPTY
101181: LIST
101182: LIST
101183: PPUSH
101184: CALL_OW 69
101188: ST_TO_ADDR
// if not tmp then
101189: LD_VAR 0 2
101193: NOT
101194: IFFALSE 101198
// exit ;
101196: GO 101227
// for i in tmp do
101198: LD_ADDR_VAR 0 1
101202: PUSH
101203: LD_VAR 0 2
101207: PUSH
101208: FOR_IN
101209: IFFALSE 101225
// begin SetLives ( i , 0 ) ;
101211: LD_VAR 0 1
101215: PPUSH
101216: LD_INT 0
101218: PPUSH
101219: CALL_OW 234
// end ;
101223: GO 101208
101225: POP
101226: POP
// end ;
101227: PPOPN 2
101229: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101230: LD_EXP 124
101234: PUSH
101235: LD_EXP 134
101239: AND
101240: IFFALSE 101260
101242: GO 101244
101244: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101245: LD_INT 32
101247: PPUSH
101248: LD_OWVAR 2
101252: PPUSH
101253: LD_INT 0
101255: PPUSH
101256: CALL_OW 324
101260: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101261: LD_EXP 124
101265: PUSH
101266: LD_EXP 135
101270: AND
101271: IFFALSE 101452
101273: GO 101275
101275: DISABLE
101276: LD_INT 0
101278: PPUSH
101279: PPUSH
101280: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101281: LD_ADDR_VAR 0 2
101285: PUSH
101286: LD_INT 22
101288: PUSH
101289: LD_OWVAR 2
101293: PUSH
101294: EMPTY
101295: LIST
101296: LIST
101297: PUSH
101298: LD_INT 33
101300: PUSH
101301: LD_INT 3
101303: PUSH
101304: EMPTY
101305: LIST
101306: LIST
101307: PUSH
101308: EMPTY
101309: LIST
101310: LIST
101311: PPUSH
101312: CALL_OW 69
101316: ST_TO_ADDR
// if not tmp then
101317: LD_VAR 0 2
101321: NOT
101322: IFFALSE 101326
// exit ;
101324: GO 101452
// side := 0 ;
101326: LD_ADDR_VAR 0 3
101330: PUSH
101331: LD_INT 0
101333: ST_TO_ADDR
// for i := 1 to 8 do
101334: LD_ADDR_VAR 0 1
101338: PUSH
101339: DOUBLE
101340: LD_INT 1
101342: DEC
101343: ST_TO_ADDR
101344: LD_INT 8
101346: PUSH
101347: FOR_TO
101348: IFFALSE 101396
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101350: LD_OWVAR 2
101354: PUSH
101355: LD_VAR 0 1
101359: NONEQUAL
101360: PUSH
101361: LD_OWVAR 2
101365: PPUSH
101366: LD_VAR 0 1
101370: PPUSH
101371: CALL_OW 81
101375: PUSH
101376: LD_INT 2
101378: EQUAL
101379: AND
101380: IFFALSE 101394
// begin side := i ;
101382: LD_ADDR_VAR 0 3
101386: PUSH
101387: LD_VAR 0 1
101391: ST_TO_ADDR
// break ;
101392: GO 101396
// end ;
101394: GO 101347
101396: POP
101397: POP
// if not side then
101398: LD_VAR 0 3
101402: NOT
101403: IFFALSE 101407
// exit ;
101405: GO 101452
// for i := 1 to tmp do
101407: LD_ADDR_VAR 0 1
101411: PUSH
101412: DOUBLE
101413: LD_INT 1
101415: DEC
101416: ST_TO_ADDR
101417: LD_VAR 0 2
101421: PUSH
101422: FOR_TO
101423: IFFALSE 101450
// if Prob ( 60 ) then
101425: LD_INT 60
101427: PPUSH
101428: CALL_OW 13
101432: IFFALSE 101448
// SetSide ( i , side ) ;
101434: LD_VAR 0 1
101438: PPUSH
101439: LD_VAR 0 3
101443: PPUSH
101444: CALL_OW 235
101448: GO 101422
101450: POP
101451: POP
// end ;
101452: PPOPN 3
101454: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101455: LD_EXP 124
101459: PUSH
101460: LD_EXP 137
101464: AND
101465: IFFALSE 101584
101467: GO 101469
101469: DISABLE
101470: LD_INT 0
101472: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101473: LD_ADDR_VAR 0 1
101477: PUSH
101478: LD_INT 22
101480: PUSH
101481: LD_OWVAR 2
101485: PUSH
101486: EMPTY
101487: LIST
101488: LIST
101489: PUSH
101490: LD_INT 21
101492: PUSH
101493: LD_INT 1
101495: PUSH
101496: EMPTY
101497: LIST
101498: LIST
101499: PUSH
101500: LD_INT 3
101502: PUSH
101503: LD_INT 23
101505: PUSH
101506: LD_INT 0
101508: PUSH
101509: EMPTY
101510: LIST
101511: LIST
101512: PUSH
101513: EMPTY
101514: LIST
101515: LIST
101516: PUSH
101517: EMPTY
101518: LIST
101519: LIST
101520: LIST
101521: PPUSH
101522: CALL_OW 69
101526: PUSH
101527: FOR_IN
101528: IFFALSE 101582
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101530: LD_VAR 0 1
101534: PPUSH
101535: CALL_OW 257
101539: PUSH
101540: LD_INT 1
101542: PUSH
101543: LD_INT 2
101545: PUSH
101546: LD_INT 3
101548: PUSH
101549: LD_INT 4
101551: PUSH
101552: EMPTY
101553: LIST
101554: LIST
101555: LIST
101556: LIST
101557: IN
101558: IFFALSE 101580
// SetClass ( un , rand ( 1 , 4 ) ) ;
101560: LD_VAR 0 1
101564: PPUSH
101565: LD_INT 1
101567: PPUSH
101568: LD_INT 4
101570: PPUSH
101571: CALL_OW 12
101575: PPUSH
101576: CALL_OW 336
101580: GO 101527
101582: POP
101583: POP
// end ;
101584: PPOPN 1
101586: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101587: LD_EXP 124
101591: PUSH
101592: LD_EXP 136
101596: AND
101597: IFFALSE 101676
101599: GO 101601
101601: DISABLE
101602: LD_INT 0
101604: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101605: LD_ADDR_VAR 0 1
101609: PUSH
101610: LD_INT 22
101612: PUSH
101613: LD_OWVAR 2
101617: PUSH
101618: EMPTY
101619: LIST
101620: LIST
101621: PUSH
101622: LD_INT 21
101624: PUSH
101625: LD_INT 3
101627: PUSH
101628: EMPTY
101629: LIST
101630: LIST
101631: PUSH
101632: EMPTY
101633: LIST
101634: LIST
101635: PPUSH
101636: CALL_OW 69
101640: ST_TO_ADDR
// if not tmp then
101641: LD_VAR 0 1
101645: NOT
101646: IFFALSE 101650
// exit ;
101648: GO 101676
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101650: LD_VAR 0 1
101654: PUSH
101655: LD_INT 1
101657: PPUSH
101658: LD_VAR 0 1
101662: PPUSH
101663: CALL_OW 12
101667: ARRAY
101668: PPUSH
101669: LD_INT 100
101671: PPUSH
101672: CALL_OW 234
// end ;
101676: PPOPN 1
101678: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101679: LD_EXP 124
101683: PUSH
101684: LD_EXP 138
101688: AND
101689: IFFALSE 101787
101691: GO 101693
101693: DISABLE
101694: LD_INT 0
101696: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101697: LD_ADDR_VAR 0 1
101701: PUSH
101702: LD_INT 22
101704: PUSH
101705: LD_OWVAR 2
101709: PUSH
101710: EMPTY
101711: LIST
101712: LIST
101713: PUSH
101714: LD_INT 21
101716: PUSH
101717: LD_INT 1
101719: PUSH
101720: EMPTY
101721: LIST
101722: LIST
101723: PUSH
101724: EMPTY
101725: LIST
101726: LIST
101727: PPUSH
101728: CALL_OW 69
101732: ST_TO_ADDR
// if not tmp then
101733: LD_VAR 0 1
101737: NOT
101738: IFFALSE 101742
// exit ;
101740: GO 101787
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101742: LD_VAR 0 1
101746: PUSH
101747: LD_INT 1
101749: PPUSH
101750: LD_VAR 0 1
101754: PPUSH
101755: CALL_OW 12
101759: ARRAY
101760: PPUSH
101761: LD_INT 1
101763: PPUSH
101764: LD_INT 4
101766: PPUSH
101767: CALL_OW 12
101771: PPUSH
101772: LD_INT 3000
101774: PPUSH
101775: LD_INT 9000
101777: PPUSH
101778: CALL_OW 12
101782: PPUSH
101783: CALL_OW 492
// end ;
101787: PPOPN 1
101789: END
// every 0 0$1 trigger StreamModeActive and sDepot do
101790: LD_EXP 124
101794: PUSH
101795: LD_EXP 139
101799: AND
101800: IFFALSE 101820
101802: GO 101804
101804: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
101805: LD_INT 1
101807: PPUSH
101808: LD_OWVAR 2
101812: PPUSH
101813: LD_INT 0
101815: PPUSH
101816: CALL_OW 324
101820: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
101821: LD_EXP 124
101825: PUSH
101826: LD_EXP 140
101830: AND
101831: IFFALSE 101914
101833: GO 101835
101835: DISABLE
101836: LD_INT 0
101838: PPUSH
101839: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101840: LD_ADDR_VAR 0 2
101844: PUSH
101845: LD_INT 22
101847: PUSH
101848: LD_OWVAR 2
101852: PUSH
101853: EMPTY
101854: LIST
101855: LIST
101856: PUSH
101857: LD_INT 21
101859: PUSH
101860: LD_INT 3
101862: PUSH
101863: EMPTY
101864: LIST
101865: LIST
101866: PUSH
101867: EMPTY
101868: LIST
101869: LIST
101870: PPUSH
101871: CALL_OW 69
101875: ST_TO_ADDR
// if not tmp then
101876: LD_VAR 0 2
101880: NOT
101881: IFFALSE 101885
// exit ;
101883: GO 101914
// for i in tmp do
101885: LD_ADDR_VAR 0 1
101889: PUSH
101890: LD_VAR 0 2
101894: PUSH
101895: FOR_IN
101896: IFFALSE 101912
// SetBLevel ( i , 10 ) ;
101898: LD_VAR 0 1
101902: PPUSH
101903: LD_INT 10
101905: PPUSH
101906: CALL_OW 241
101910: GO 101895
101912: POP
101913: POP
// end ;
101914: PPOPN 2
101916: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
101917: LD_EXP 124
101921: PUSH
101922: LD_EXP 141
101926: AND
101927: IFFALSE 102038
101929: GO 101931
101931: DISABLE
101932: LD_INT 0
101934: PPUSH
101935: PPUSH
101936: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101937: LD_ADDR_VAR 0 3
101941: PUSH
101942: LD_INT 22
101944: PUSH
101945: LD_OWVAR 2
101949: PUSH
101950: EMPTY
101951: LIST
101952: LIST
101953: PUSH
101954: LD_INT 25
101956: PUSH
101957: LD_INT 1
101959: PUSH
101960: EMPTY
101961: LIST
101962: LIST
101963: PUSH
101964: EMPTY
101965: LIST
101966: LIST
101967: PPUSH
101968: CALL_OW 69
101972: ST_TO_ADDR
// if not tmp then
101973: LD_VAR 0 3
101977: NOT
101978: IFFALSE 101982
// exit ;
101980: GO 102038
// un := tmp [ rand ( 1 , tmp ) ] ;
101982: LD_ADDR_VAR 0 2
101986: PUSH
101987: LD_VAR 0 3
101991: PUSH
101992: LD_INT 1
101994: PPUSH
101995: LD_VAR 0 3
101999: PPUSH
102000: CALL_OW 12
102004: ARRAY
102005: ST_TO_ADDR
// if Crawls ( un ) then
102006: LD_VAR 0 2
102010: PPUSH
102011: CALL_OW 318
102015: IFFALSE 102026
// ComWalk ( un ) ;
102017: LD_VAR 0 2
102021: PPUSH
102022: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102026: LD_VAR 0 2
102030: PPUSH
102031: LD_INT 5
102033: PPUSH
102034: CALL_OW 336
// end ;
102038: PPOPN 3
102040: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102041: LD_EXP 124
102045: PUSH
102046: LD_EXP 142
102050: AND
102051: PUSH
102052: LD_OWVAR 67
102056: PUSH
102057: LD_INT 4
102059: LESS
102060: AND
102061: IFFALSE 102080
102063: GO 102065
102065: DISABLE
// begin Difficulty := Difficulty + 1 ;
102066: LD_ADDR_OWVAR 67
102070: PUSH
102071: LD_OWVAR 67
102075: PUSH
102076: LD_INT 1
102078: PLUS
102079: ST_TO_ADDR
// end ;
102080: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102081: LD_EXP 124
102085: PUSH
102086: LD_EXP 143
102090: AND
102091: IFFALSE 102194
102093: GO 102095
102095: DISABLE
102096: LD_INT 0
102098: PPUSH
// begin for i := 1 to 5 do
102099: LD_ADDR_VAR 0 1
102103: PUSH
102104: DOUBLE
102105: LD_INT 1
102107: DEC
102108: ST_TO_ADDR
102109: LD_INT 5
102111: PUSH
102112: FOR_TO
102113: IFFALSE 102192
// begin uc_nation := nation_nature ;
102115: LD_ADDR_OWVAR 21
102119: PUSH
102120: LD_INT 0
102122: ST_TO_ADDR
// uc_side := 0 ;
102123: LD_ADDR_OWVAR 20
102127: PUSH
102128: LD_INT 0
102130: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102131: LD_ADDR_OWVAR 29
102135: PUSH
102136: LD_INT 12
102138: PUSH
102139: LD_INT 12
102141: PUSH
102142: EMPTY
102143: LIST
102144: LIST
102145: ST_TO_ADDR
// hc_agressivity := 20 ;
102146: LD_ADDR_OWVAR 35
102150: PUSH
102151: LD_INT 20
102153: ST_TO_ADDR
// hc_class := class_tiger ;
102154: LD_ADDR_OWVAR 28
102158: PUSH
102159: LD_INT 14
102161: ST_TO_ADDR
// hc_gallery :=  ;
102162: LD_ADDR_OWVAR 33
102166: PUSH
102167: LD_STRING 
102169: ST_TO_ADDR
// hc_name :=  ;
102170: LD_ADDR_OWVAR 26
102174: PUSH
102175: LD_STRING 
102177: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102178: CALL_OW 44
102182: PPUSH
102183: LD_INT 0
102185: PPUSH
102186: CALL_OW 51
// end ;
102190: GO 102112
102192: POP
102193: POP
// end ;
102194: PPOPN 1
102196: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102197: LD_EXP 124
102201: PUSH
102202: LD_EXP 144
102206: AND
102207: IFFALSE 102216
102209: GO 102211
102211: DISABLE
// StreamSibBomb ;
102212: CALL 102217 0 0
102216: END
// export function StreamSibBomb ; var i , x , y ; begin
102217: LD_INT 0
102219: PPUSH
102220: PPUSH
102221: PPUSH
102222: PPUSH
// result := false ;
102223: LD_ADDR_VAR 0 1
102227: PUSH
102228: LD_INT 0
102230: ST_TO_ADDR
// for i := 1 to 16 do
102231: LD_ADDR_VAR 0 2
102235: PUSH
102236: DOUBLE
102237: LD_INT 1
102239: DEC
102240: ST_TO_ADDR
102241: LD_INT 16
102243: PUSH
102244: FOR_TO
102245: IFFALSE 102444
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102247: LD_ADDR_VAR 0 3
102251: PUSH
102252: LD_INT 10
102254: PUSH
102255: LD_INT 20
102257: PUSH
102258: LD_INT 30
102260: PUSH
102261: LD_INT 40
102263: PUSH
102264: LD_INT 50
102266: PUSH
102267: LD_INT 60
102269: PUSH
102270: LD_INT 70
102272: PUSH
102273: LD_INT 80
102275: PUSH
102276: LD_INT 90
102278: PUSH
102279: LD_INT 100
102281: PUSH
102282: LD_INT 110
102284: PUSH
102285: LD_INT 120
102287: PUSH
102288: LD_INT 130
102290: PUSH
102291: LD_INT 140
102293: PUSH
102294: LD_INT 150
102296: PUSH
102297: EMPTY
102298: LIST
102299: LIST
102300: LIST
102301: LIST
102302: LIST
102303: LIST
102304: LIST
102305: LIST
102306: LIST
102307: LIST
102308: LIST
102309: LIST
102310: LIST
102311: LIST
102312: LIST
102313: PUSH
102314: LD_INT 1
102316: PPUSH
102317: LD_INT 15
102319: PPUSH
102320: CALL_OW 12
102324: ARRAY
102325: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102326: LD_ADDR_VAR 0 4
102330: PUSH
102331: LD_INT 10
102333: PUSH
102334: LD_INT 20
102336: PUSH
102337: LD_INT 30
102339: PUSH
102340: LD_INT 40
102342: PUSH
102343: LD_INT 50
102345: PUSH
102346: LD_INT 60
102348: PUSH
102349: LD_INT 70
102351: PUSH
102352: LD_INT 80
102354: PUSH
102355: LD_INT 90
102357: PUSH
102358: LD_INT 100
102360: PUSH
102361: LD_INT 110
102363: PUSH
102364: LD_INT 120
102366: PUSH
102367: LD_INT 130
102369: PUSH
102370: LD_INT 140
102372: PUSH
102373: LD_INT 150
102375: PUSH
102376: EMPTY
102377: LIST
102378: LIST
102379: LIST
102380: LIST
102381: LIST
102382: LIST
102383: LIST
102384: LIST
102385: LIST
102386: LIST
102387: LIST
102388: LIST
102389: LIST
102390: LIST
102391: LIST
102392: PUSH
102393: LD_INT 1
102395: PPUSH
102396: LD_INT 15
102398: PPUSH
102399: CALL_OW 12
102403: ARRAY
102404: ST_TO_ADDR
// if ValidHex ( x , y ) then
102405: LD_VAR 0 3
102409: PPUSH
102410: LD_VAR 0 4
102414: PPUSH
102415: CALL_OW 488
102419: IFFALSE 102442
// begin result := [ x , y ] ;
102421: LD_ADDR_VAR 0 1
102425: PUSH
102426: LD_VAR 0 3
102430: PUSH
102431: LD_VAR 0 4
102435: PUSH
102436: EMPTY
102437: LIST
102438: LIST
102439: ST_TO_ADDR
// break ;
102440: GO 102444
// end ; end ;
102442: GO 102244
102444: POP
102445: POP
// if result then
102446: LD_VAR 0 1
102450: IFFALSE 102510
// begin ToLua ( playSibBomb() ) ;
102452: LD_STRING playSibBomb()
102454: PPUSH
102455: CALL_OW 559
// wait ( 0 0$14 ) ;
102459: LD_INT 490
102461: PPUSH
102462: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102466: LD_VAR 0 1
102470: PUSH
102471: LD_INT 1
102473: ARRAY
102474: PPUSH
102475: LD_VAR 0 1
102479: PUSH
102480: LD_INT 2
102482: ARRAY
102483: PPUSH
102484: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102488: LD_VAR 0 1
102492: PUSH
102493: LD_INT 1
102495: ARRAY
102496: PPUSH
102497: LD_VAR 0 1
102501: PUSH
102502: LD_INT 2
102504: ARRAY
102505: PPUSH
102506: CALL_OW 429
// end ; end ;
102510: LD_VAR 0 1
102514: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102515: LD_EXP 124
102519: PUSH
102520: LD_EXP 146
102524: AND
102525: IFFALSE 102537
102527: GO 102529
102529: DISABLE
// YouLost (  ) ;
102530: LD_STRING 
102532: PPUSH
102533: CALL_OW 104
102537: END
// every 0 0$1 trigger StreamModeActive and sFog do
102538: LD_EXP 124
102542: PUSH
102543: LD_EXP 145
102547: AND
102548: IFFALSE 102562
102550: GO 102552
102552: DISABLE
// FogOff ( your_side ) ;
102553: LD_OWVAR 2
102557: PPUSH
102558: CALL_OW 344
102562: END
// every 0 0$1 trigger StreamModeActive and sSun do
102563: LD_EXP 124
102567: PUSH
102568: LD_EXP 147
102572: AND
102573: IFFALSE 102601
102575: GO 102577
102577: DISABLE
// begin solar_recharge_percent := 0 ;
102578: LD_ADDR_OWVAR 79
102582: PUSH
102583: LD_INT 0
102585: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102586: LD_INT 10500
102588: PPUSH
102589: CALL_OW 67
// solar_recharge_percent := 100 ;
102593: LD_ADDR_OWVAR 79
102597: PUSH
102598: LD_INT 100
102600: ST_TO_ADDR
// end ;
102601: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102602: LD_EXP 124
102606: PUSH
102607: LD_EXP 148
102611: AND
102612: IFFALSE 102851
102614: GO 102616
102616: DISABLE
102617: LD_INT 0
102619: PPUSH
102620: PPUSH
102621: PPUSH
// begin tmp := [ ] ;
102622: LD_ADDR_VAR 0 3
102626: PUSH
102627: EMPTY
102628: ST_TO_ADDR
// for i := 1 to 6 do
102629: LD_ADDR_VAR 0 1
102633: PUSH
102634: DOUBLE
102635: LD_INT 1
102637: DEC
102638: ST_TO_ADDR
102639: LD_INT 6
102641: PUSH
102642: FOR_TO
102643: IFFALSE 102748
// begin uc_nation := nation_nature ;
102645: LD_ADDR_OWVAR 21
102649: PUSH
102650: LD_INT 0
102652: ST_TO_ADDR
// uc_side := 0 ;
102653: LD_ADDR_OWVAR 20
102657: PUSH
102658: LD_INT 0
102660: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102661: LD_ADDR_OWVAR 29
102665: PUSH
102666: LD_INT 12
102668: PUSH
102669: LD_INT 12
102671: PUSH
102672: EMPTY
102673: LIST
102674: LIST
102675: ST_TO_ADDR
// hc_agressivity := 20 ;
102676: LD_ADDR_OWVAR 35
102680: PUSH
102681: LD_INT 20
102683: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102684: LD_ADDR_OWVAR 28
102688: PUSH
102689: LD_INT 17
102691: ST_TO_ADDR
// hc_gallery :=  ;
102692: LD_ADDR_OWVAR 33
102696: PUSH
102697: LD_STRING 
102699: ST_TO_ADDR
// hc_name :=  ;
102700: LD_ADDR_OWVAR 26
102704: PUSH
102705: LD_STRING 
102707: ST_TO_ADDR
// un := CreateHuman ;
102708: LD_ADDR_VAR 0 2
102712: PUSH
102713: CALL_OW 44
102717: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102718: LD_VAR 0 2
102722: PPUSH
102723: LD_INT 1
102725: PPUSH
102726: CALL_OW 51
// tmp := tmp ^ un ;
102730: LD_ADDR_VAR 0 3
102734: PUSH
102735: LD_VAR 0 3
102739: PUSH
102740: LD_VAR 0 2
102744: ADD
102745: ST_TO_ADDR
// end ;
102746: GO 102642
102748: POP
102749: POP
// repeat wait ( 0 0$1 ) ;
102750: LD_INT 35
102752: PPUSH
102753: CALL_OW 67
// for un in tmp do
102757: LD_ADDR_VAR 0 2
102761: PUSH
102762: LD_VAR 0 3
102766: PUSH
102767: FOR_IN
102768: IFFALSE 102842
// begin if IsDead ( un ) then
102770: LD_VAR 0 2
102774: PPUSH
102775: CALL_OW 301
102779: IFFALSE 102799
// begin tmp := tmp diff un ;
102781: LD_ADDR_VAR 0 3
102785: PUSH
102786: LD_VAR 0 3
102790: PUSH
102791: LD_VAR 0 2
102795: DIFF
102796: ST_TO_ADDR
// continue ;
102797: GO 102767
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
102799: LD_VAR 0 2
102803: PPUSH
102804: LD_INT 3
102806: PUSH
102807: LD_INT 22
102809: PUSH
102810: LD_INT 0
102812: PUSH
102813: EMPTY
102814: LIST
102815: LIST
102816: PUSH
102817: EMPTY
102818: LIST
102819: LIST
102820: PPUSH
102821: CALL_OW 69
102825: PPUSH
102826: LD_VAR 0 2
102830: PPUSH
102831: CALL_OW 74
102835: PPUSH
102836: CALL_OW 115
// end ;
102840: GO 102767
102842: POP
102843: POP
// until not tmp ;
102844: LD_VAR 0 3
102848: NOT
102849: IFFALSE 102750
// end ;
102851: PPOPN 3
102853: END
// every 0 0$1 trigger StreamModeActive and sTroll do
102854: LD_EXP 124
102858: PUSH
102859: LD_EXP 149
102863: AND
102864: IFFALSE 102918
102866: GO 102868
102868: DISABLE
// begin ToLua ( displayTroll(); ) ;
102869: LD_STRING displayTroll();
102871: PPUSH
102872: CALL_OW 559
// wait ( 3 3$00 ) ;
102876: LD_INT 6300
102878: PPUSH
102879: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102883: LD_STRING hideTroll();
102885: PPUSH
102886: CALL_OW 559
// wait ( 1 1$00 ) ;
102890: LD_INT 2100
102892: PPUSH
102893: CALL_OW 67
// ToLua ( displayTroll(); ) ;
102897: LD_STRING displayTroll();
102899: PPUSH
102900: CALL_OW 559
// wait ( 1 1$00 ) ;
102904: LD_INT 2100
102906: PPUSH
102907: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102911: LD_STRING hideTroll();
102913: PPUSH
102914: CALL_OW 559
// end ;
102918: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
102919: LD_EXP 124
102923: PUSH
102924: LD_EXP 150
102928: AND
102929: IFFALSE 102992
102931: GO 102933
102933: DISABLE
102934: LD_INT 0
102936: PPUSH
// begin p := 0 ;
102937: LD_ADDR_VAR 0 1
102941: PUSH
102942: LD_INT 0
102944: ST_TO_ADDR
// repeat game_speed := 1 ;
102945: LD_ADDR_OWVAR 65
102949: PUSH
102950: LD_INT 1
102952: ST_TO_ADDR
// wait ( 0 0$1 ) ;
102953: LD_INT 35
102955: PPUSH
102956: CALL_OW 67
// p := p + 1 ;
102960: LD_ADDR_VAR 0 1
102964: PUSH
102965: LD_VAR 0 1
102969: PUSH
102970: LD_INT 1
102972: PLUS
102973: ST_TO_ADDR
// until p >= 60 ;
102974: LD_VAR 0 1
102978: PUSH
102979: LD_INT 60
102981: GREATEREQUAL
102982: IFFALSE 102945
// game_speed := 4 ;
102984: LD_ADDR_OWVAR 65
102988: PUSH
102989: LD_INT 4
102991: ST_TO_ADDR
// end ;
102992: PPOPN 1
102994: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
102995: LD_EXP 124
102999: PUSH
103000: LD_EXP 151
103004: AND
103005: IFFALSE 103151
103007: GO 103009
103009: DISABLE
103010: LD_INT 0
103012: PPUSH
103013: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103014: LD_ADDR_VAR 0 1
103018: PUSH
103019: LD_INT 22
103021: PUSH
103022: LD_OWVAR 2
103026: PUSH
103027: EMPTY
103028: LIST
103029: LIST
103030: PUSH
103031: LD_INT 2
103033: PUSH
103034: LD_INT 30
103036: PUSH
103037: LD_INT 0
103039: PUSH
103040: EMPTY
103041: LIST
103042: LIST
103043: PUSH
103044: LD_INT 30
103046: PUSH
103047: LD_INT 1
103049: PUSH
103050: EMPTY
103051: LIST
103052: LIST
103053: PUSH
103054: EMPTY
103055: LIST
103056: LIST
103057: LIST
103058: PUSH
103059: EMPTY
103060: LIST
103061: LIST
103062: PPUSH
103063: CALL_OW 69
103067: ST_TO_ADDR
// if not depot then
103068: LD_VAR 0 1
103072: NOT
103073: IFFALSE 103077
// exit ;
103075: GO 103151
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103077: LD_ADDR_VAR 0 2
103081: PUSH
103082: LD_VAR 0 1
103086: PUSH
103087: LD_INT 1
103089: PPUSH
103090: LD_VAR 0 1
103094: PPUSH
103095: CALL_OW 12
103099: ARRAY
103100: PPUSH
103101: CALL_OW 274
103105: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103106: LD_VAR 0 2
103110: PPUSH
103111: LD_INT 1
103113: PPUSH
103114: LD_INT 0
103116: PPUSH
103117: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103121: LD_VAR 0 2
103125: PPUSH
103126: LD_INT 2
103128: PPUSH
103129: LD_INT 0
103131: PPUSH
103132: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103136: LD_VAR 0 2
103140: PPUSH
103141: LD_INT 3
103143: PPUSH
103144: LD_INT 0
103146: PPUSH
103147: CALL_OW 277
// end ;
103151: PPOPN 2
103153: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103154: LD_EXP 124
103158: PUSH
103159: LD_EXP 152
103163: AND
103164: IFFALSE 103261
103166: GO 103168
103168: DISABLE
103169: LD_INT 0
103171: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103172: LD_ADDR_VAR 0 1
103176: PUSH
103177: LD_INT 22
103179: PUSH
103180: LD_OWVAR 2
103184: PUSH
103185: EMPTY
103186: LIST
103187: LIST
103188: PUSH
103189: LD_INT 21
103191: PUSH
103192: LD_INT 1
103194: PUSH
103195: EMPTY
103196: LIST
103197: LIST
103198: PUSH
103199: LD_INT 3
103201: PUSH
103202: LD_INT 23
103204: PUSH
103205: LD_INT 0
103207: PUSH
103208: EMPTY
103209: LIST
103210: LIST
103211: PUSH
103212: EMPTY
103213: LIST
103214: LIST
103215: PUSH
103216: EMPTY
103217: LIST
103218: LIST
103219: LIST
103220: PPUSH
103221: CALL_OW 69
103225: ST_TO_ADDR
// if not tmp then
103226: LD_VAR 0 1
103230: NOT
103231: IFFALSE 103235
// exit ;
103233: GO 103261
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103235: LD_VAR 0 1
103239: PUSH
103240: LD_INT 1
103242: PPUSH
103243: LD_VAR 0 1
103247: PPUSH
103248: CALL_OW 12
103252: ARRAY
103253: PPUSH
103254: LD_INT 200
103256: PPUSH
103257: CALL_OW 234
// end ;
103261: PPOPN 1
103263: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103264: LD_EXP 124
103268: PUSH
103269: LD_EXP 153
103273: AND
103274: IFFALSE 103353
103276: GO 103278
103278: DISABLE
103279: LD_INT 0
103281: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103282: LD_ADDR_VAR 0 1
103286: PUSH
103287: LD_INT 22
103289: PUSH
103290: LD_OWVAR 2
103294: PUSH
103295: EMPTY
103296: LIST
103297: LIST
103298: PUSH
103299: LD_INT 21
103301: PUSH
103302: LD_INT 2
103304: PUSH
103305: EMPTY
103306: LIST
103307: LIST
103308: PUSH
103309: EMPTY
103310: LIST
103311: LIST
103312: PPUSH
103313: CALL_OW 69
103317: ST_TO_ADDR
// if not tmp then
103318: LD_VAR 0 1
103322: NOT
103323: IFFALSE 103327
// exit ;
103325: GO 103353
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103327: LD_VAR 0 1
103331: PUSH
103332: LD_INT 1
103334: PPUSH
103335: LD_VAR 0 1
103339: PPUSH
103340: CALL_OW 12
103344: ARRAY
103345: PPUSH
103346: LD_INT 60
103348: PPUSH
103349: CALL_OW 234
// end ;
103353: PPOPN 1
103355: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103356: LD_EXP 124
103360: PUSH
103361: LD_EXP 154
103365: AND
103366: IFFALSE 103465
103368: GO 103370
103370: DISABLE
103371: LD_INT 0
103373: PPUSH
103374: PPUSH
// begin enable ;
103375: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103376: LD_ADDR_VAR 0 1
103380: PUSH
103381: LD_INT 22
103383: PUSH
103384: LD_OWVAR 2
103388: PUSH
103389: EMPTY
103390: LIST
103391: LIST
103392: PUSH
103393: LD_INT 61
103395: PUSH
103396: EMPTY
103397: LIST
103398: PUSH
103399: LD_INT 33
103401: PUSH
103402: LD_INT 2
103404: PUSH
103405: EMPTY
103406: LIST
103407: LIST
103408: PUSH
103409: EMPTY
103410: LIST
103411: LIST
103412: LIST
103413: PPUSH
103414: CALL_OW 69
103418: ST_TO_ADDR
// if not tmp then
103419: LD_VAR 0 1
103423: NOT
103424: IFFALSE 103428
// exit ;
103426: GO 103465
// for i in tmp do
103428: LD_ADDR_VAR 0 2
103432: PUSH
103433: LD_VAR 0 1
103437: PUSH
103438: FOR_IN
103439: IFFALSE 103463
// if IsControledBy ( i ) then
103441: LD_VAR 0 2
103445: PPUSH
103446: CALL_OW 312
103450: IFFALSE 103461
// ComUnlink ( i ) ;
103452: LD_VAR 0 2
103456: PPUSH
103457: CALL_OW 136
103461: GO 103438
103463: POP
103464: POP
// end ;
103465: PPOPN 2
103467: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103468: LD_EXP 124
103472: PUSH
103473: LD_EXP 155
103477: AND
103478: IFFALSE 103618
103480: GO 103482
103482: DISABLE
103483: LD_INT 0
103485: PPUSH
103486: PPUSH
// begin ToLua ( displayPowell(); ) ;
103487: LD_STRING displayPowell();
103489: PPUSH
103490: CALL_OW 559
// uc_side := 0 ;
103494: LD_ADDR_OWVAR 20
103498: PUSH
103499: LD_INT 0
103501: ST_TO_ADDR
// uc_nation := 2 ;
103502: LD_ADDR_OWVAR 21
103506: PUSH
103507: LD_INT 2
103509: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103510: LD_ADDR_OWVAR 37
103514: PUSH
103515: LD_INT 14
103517: ST_TO_ADDR
// vc_engine := engine_siberite ;
103518: LD_ADDR_OWVAR 39
103522: PUSH
103523: LD_INT 3
103525: ST_TO_ADDR
// vc_control := control_apeman ;
103526: LD_ADDR_OWVAR 38
103530: PUSH
103531: LD_INT 5
103533: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103534: LD_ADDR_OWVAR 40
103538: PUSH
103539: LD_INT 29
103541: ST_TO_ADDR
// un := CreateVehicle ;
103542: LD_ADDR_VAR 0 2
103546: PUSH
103547: CALL_OW 45
103551: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103552: LD_VAR 0 2
103556: PPUSH
103557: LD_INT 1
103559: PPUSH
103560: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103564: LD_INT 35
103566: PPUSH
103567: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103571: LD_VAR 0 2
103575: PPUSH
103576: LD_INT 22
103578: PUSH
103579: LD_OWVAR 2
103583: PUSH
103584: EMPTY
103585: LIST
103586: LIST
103587: PPUSH
103588: CALL_OW 69
103592: PPUSH
103593: LD_VAR 0 2
103597: PPUSH
103598: CALL_OW 74
103602: PPUSH
103603: CALL_OW 115
// until IsDead ( un ) ;
103607: LD_VAR 0 2
103611: PPUSH
103612: CALL_OW 301
103616: IFFALSE 103564
// end ;
103618: PPOPN 2
103620: END
// every 0 0$1 trigger StreamModeActive and sStu do
103621: LD_EXP 124
103625: PUSH
103626: LD_EXP 163
103630: AND
103631: IFFALSE 103647
103633: GO 103635
103635: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103636: LD_STRING displayStucuk();
103638: PPUSH
103639: CALL_OW 559
// ResetFog ;
103643: CALL_OW 335
// end ;
103647: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103648: LD_EXP 124
103652: PUSH
103653: LD_EXP 156
103657: AND
103658: IFFALSE 103799
103660: GO 103662
103662: DISABLE
103663: LD_INT 0
103665: PPUSH
103666: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103667: LD_ADDR_VAR 0 2
103671: PUSH
103672: LD_INT 22
103674: PUSH
103675: LD_OWVAR 2
103679: PUSH
103680: EMPTY
103681: LIST
103682: LIST
103683: PUSH
103684: LD_INT 21
103686: PUSH
103687: LD_INT 1
103689: PUSH
103690: EMPTY
103691: LIST
103692: LIST
103693: PUSH
103694: EMPTY
103695: LIST
103696: LIST
103697: PPUSH
103698: CALL_OW 69
103702: ST_TO_ADDR
// if not tmp then
103703: LD_VAR 0 2
103707: NOT
103708: IFFALSE 103712
// exit ;
103710: GO 103799
// un := tmp [ rand ( 1 , tmp ) ] ;
103712: LD_ADDR_VAR 0 1
103716: PUSH
103717: LD_VAR 0 2
103721: PUSH
103722: LD_INT 1
103724: PPUSH
103725: LD_VAR 0 2
103729: PPUSH
103730: CALL_OW 12
103734: ARRAY
103735: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103736: LD_VAR 0 1
103740: PPUSH
103741: LD_INT 0
103743: PPUSH
103744: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103748: LD_VAR 0 1
103752: PPUSH
103753: LD_OWVAR 3
103757: PUSH
103758: LD_VAR 0 1
103762: DIFF
103763: PPUSH
103764: LD_VAR 0 1
103768: PPUSH
103769: CALL_OW 74
103773: PPUSH
103774: CALL_OW 115
// wait ( 0 0$20 ) ;
103778: LD_INT 700
103780: PPUSH
103781: CALL_OW 67
// SetSide ( un , your_side ) ;
103785: LD_VAR 0 1
103789: PPUSH
103790: LD_OWVAR 2
103794: PPUSH
103795: CALL_OW 235
// end ;
103799: PPOPN 2
103801: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
103802: LD_EXP 124
103806: PUSH
103807: LD_EXP 157
103811: AND
103812: IFFALSE 103918
103814: GO 103816
103816: DISABLE
103817: LD_INT 0
103819: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103820: LD_ADDR_VAR 0 1
103824: PUSH
103825: LD_INT 22
103827: PUSH
103828: LD_OWVAR 2
103832: PUSH
103833: EMPTY
103834: LIST
103835: LIST
103836: PUSH
103837: LD_INT 2
103839: PUSH
103840: LD_INT 30
103842: PUSH
103843: LD_INT 0
103845: PUSH
103846: EMPTY
103847: LIST
103848: LIST
103849: PUSH
103850: LD_INT 30
103852: PUSH
103853: LD_INT 1
103855: PUSH
103856: EMPTY
103857: LIST
103858: LIST
103859: PUSH
103860: EMPTY
103861: LIST
103862: LIST
103863: LIST
103864: PUSH
103865: EMPTY
103866: LIST
103867: LIST
103868: PPUSH
103869: CALL_OW 69
103873: ST_TO_ADDR
// if not depot then
103874: LD_VAR 0 1
103878: NOT
103879: IFFALSE 103883
// exit ;
103881: GO 103918
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
103883: LD_VAR 0 1
103887: PUSH
103888: LD_INT 1
103890: ARRAY
103891: PPUSH
103892: CALL_OW 250
103896: PPUSH
103897: LD_VAR 0 1
103901: PUSH
103902: LD_INT 1
103904: ARRAY
103905: PPUSH
103906: CALL_OW 251
103910: PPUSH
103911: LD_INT 70
103913: PPUSH
103914: CALL_OW 495
// end ;
103918: PPOPN 1
103920: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
103921: LD_EXP 124
103925: PUSH
103926: LD_EXP 158
103930: AND
103931: IFFALSE 104142
103933: GO 103935
103935: DISABLE
103936: LD_INT 0
103938: PPUSH
103939: PPUSH
103940: PPUSH
103941: PPUSH
103942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103943: LD_ADDR_VAR 0 5
103947: PUSH
103948: LD_INT 22
103950: PUSH
103951: LD_OWVAR 2
103955: PUSH
103956: EMPTY
103957: LIST
103958: LIST
103959: PUSH
103960: LD_INT 21
103962: PUSH
103963: LD_INT 1
103965: PUSH
103966: EMPTY
103967: LIST
103968: LIST
103969: PUSH
103970: EMPTY
103971: LIST
103972: LIST
103973: PPUSH
103974: CALL_OW 69
103978: ST_TO_ADDR
// if not tmp then
103979: LD_VAR 0 5
103983: NOT
103984: IFFALSE 103988
// exit ;
103986: GO 104142
// for i in tmp do
103988: LD_ADDR_VAR 0 1
103992: PUSH
103993: LD_VAR 0 5
103997: PUSH
103998: FOR_IN
103999: IFFALSE 104140
// begin d := rand ( 0 , 5 ) ;
104001: LD_ADDR_VAR 0 4
104005: PUSH
104006: LD_INT 0
104008: PPUSH
104009: LD_INT 5
104011: PPUSH
104012: CALL_OW 12
104016: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104017: LD_ADDR_VAR 0 2
104021: PUSH
104022: LD_VAR 0 1
104026: PPUSH
104027: CALL_OW 250
104031: PPUSH
104032: LD_VAR 0 4
104036: PPUSH
104037: LD_INT 3
104039: PPUSH
104040: LD_INT 12
104042: PPUSH
104043: CALL_OW 12
104047: PPUSH
104048: CALL_OW 272
104052: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104053: LD_ADDR_VAR 0 3
104057: PUSH
104058: LD_VAR 0 1
104062: PPUSH
104063: CALL_OW 251
104067: PPUSH
104068: LD_VAR 0 4
104072: PPUSH
104073: LD_INT 3
104075: PPUSH
104076: LD_INT 12
104078: PPUSH
104079: CALL_OW 12
104083: PPUSH
104084: CALL_OW 273
104088: ST_TO_ADDR
// if ValidHex ( x , y ) then
104089: LD_VAR 0 2
104093: PPUSH
104094: LD_VAR 0 3
104098: PPUSH
104099: CALL_OW 488
104103: IFFALSE 104138
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104105: LD_VAR 0 1
104109: PPUSH
104110: LD_VAR 0 2
104114: PPUSH
104115: LD_VAR 0 3
104119: PPUSH
104120: LD_INT 3
104122: PPUSH
104123: LD_INT 6
104125: PPUSH
104126: CALL_OW 12
104130: PPUSH
104131: LD_INT 1
104133: PPUSH
104134: CALL_OW 483
// end ;
104138: GO 103998
104140: POP
104141: POP
// end ;
104142: PPOPN 5
104144: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104145: LD_EXP 124
104149: PUSH
104150: LD_EXP 159
104154: AND
104155: IFFALSE 104249
104157: GO 104159
104159: DISABLE
104160: LD_INT 0
104162: PPUSH
104163: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104164: LD_ADDR_VAR 0 2
104168: PUSH
104169: LD_INT 22
104171: PUSH
104172: LD_OWVAR 2
104176: PUSH
104177: EMPTY
104178: LIST
104179: LIST
104180: PUSH
104181: LD_INT 32
104183: PUSH
104184: LD_INT 1
104186: PUSH
104187: EMPTY
104188: LIST
104189: LIST
104190: PUSH
104191: LD_INT 21
104193: PUSH
104194: LD_INT 2
104196: PUSH
104197: EMPTY
104198: LIST
104199: LIST
104200: PUSH
104201: EMPTY
104202: LIST
104203: LIST
104204: LIST
104205: PPUSH
104206: CALL_OW 69
104210: ST_TO_ADDR
// if not tmp then
104211: LD_VAR 0 2
104215: NOT
104216: IFFALSE 104220
// exit ;
104218: GO 104249
// for i in tmp do
104220: LD_ADDR_VAR 0 1
104224: PUSH
104225: LD_VAR 0 2
104229: PUSH
104230: FOR_IN
104231: IFFALSE 104247
// SetFuel ( i , 0 ) ;
104233: LD_VAR 0 1
104237: PPUSH
104238: LD_INT 0
104240: PPUSH
104241: CALL_OW 240
104245: GO 104230
104247: POP
104248: POP
// end ;
104249: PPOPN 2
104251: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104252: LD_EXP 124
104256: PUSH
104257: LD_EXP 160
104261: AND
104262: IFFALSE 104328
104264: GO 104266
104266: DISABLE
104267: LD_INT 0
104269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104270: LD_ADDR_VAR 0 1
104274: PUSH
104275: LD_INT 22
104277: PUSH
104278: LD_OWVAR 2
104282: PUSH
104283: EMPTY
104284: LIST
104285: LIST
104286: PUSH
104287: LD_INT 30
104289: PUSH
104290: LD_INT 29
104292: PUSH
104293: EMPTY
104294: LIST
104295: LIST
104296: PUSH
104297: EMPTY
104298: LIST
104299: LIST
104300: PPUSH
104301: CALL_OW 69
104305: ST_TO_ADDR
// if not tmp then
104306: LD_VAR 0 1
104310: NOT
104311: IFFALSE 104315
// exit ;
104313: GO 104328
// DestroyUnit ( tmp [ 1 ] ) ;
104315: LD_VAR 0 1
104319: PUSH
104320: LD_INT 1
104322: ARRAY
104323: PPUSH
104324: CALL_OW 65
// end ;
104328: PPOPN 1
104330: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104331: LD_EXP 124
104335: PUSH
104336: LD_EXP 162
104340: AND
104341: IFFALSE 104470
104343: GO 104345
104345: DISABLE
104346: LD_INT 0
104348: PPUSH
// begin uc_side := 0 ;
104349: LD_ADDR_OWVAR 20
104353: PUSH
104354: LD_INT 0
104356: ST_TO_ADDR
// uc_nation := nation_arabian ;
104357: LD_ADDR_OWVAR 21
104361: PUSH
104362: LD_INT 2
104364: ST_TO_ADDR
// hc_gallery :=  ;
104365: LD_ADDR_OWVAR 33
104369: PUSH
104370: LD_STRING 
104372: ST_TO_ADDR
// hc_name :=  ;
104373: LD_ADDR_OWVAR 26
104377: PUSH
104378: LD_STRING 
104380: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104381: LD_INT 1
104383: PPUSH
104384: LD_INT 11
104386: PPUSH
104387: LD_INT 10
104389: PPUSH
104390: CALL_OW 380
// un := CreateHuman ;
104394: LD_ADDR_VAR 0 1
104398: PUSH
104399: CALL_OW 44
104403: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104404: LD_VAR 0 1
104408: PPUSH
104409: LD_INT 1
104411: PPUSH
104412: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104416: LD_INT 35
104418: PPUSH
104419: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104423: LD_VAR 0 1
104427: PPUSH
104428: LD_INT 22
104430: PUSH
104431: LD_OWVAR 2
104435: PUSH
104436: EMPTY
104437: LIST
104438: LIST
104439: PPUSH
104440: CALL_OW 69
104444: PPUSH
104445: LD_VAR 0 1
104449: PPUSH
104450: CALL_OW 74
104454: PPUSH
104455: CALL_OW 115
// until IsDead ( un ) ;
104459: LD_VAR 0 1
104463: PPUSH
104464: CALL_OW 301
104468: IFFALSE 104416
// end ;
104470: PPOPN 1
104472: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104473: LD_EXP 124
104477: PUSH
104478: LD_EXP 164
104482: AND
104483: IFFALSE 104495
104485: GO 104487
104487: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104488: LD_STRING earthquake(getX(game), 0, 32)
104490: PPUSH
104491: CALL_OW 559
104495: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104496: LD_EXP 124
104500: PUSH
104501: LD_EXP 165
104505: AND
104506: IFFALSE 104597
104508: GO 104510
104510: DISABLE
104511: LD_INT 0
104513: PPUSH
// begin enable ;
104514: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104515: LD_ADDR_VAR 0 1
104519: PUSH
104520: LD_INT 22
104522: PUSH
104523: LD_OWVAR 2
104527: PUSH
104528: EMPTY
104529: LIST
104530: LIST
104531: PUSH
104532: LD_INT 21
104534: PUSH
104535: LD_INT 2
104537: PUSH
104538: EMPTY
104539: LIST
104540: LIST
104541: PUSH
104542: LD_INT 33
104544: PUSH
104545: LD_INT 3
104547: PUSH
104548: EMPTY
104549: LIST
104550: LIST
104551: PUSH
104552: EMPTY
104553: LIST
104554: LIST
104555: LIST
104556: PPUSH
104557: CALL_OW 69
104561: ST_TO_ADDR
// if not tmp then
104562: LD_VAR 0 1
104566: NOT
104567: IFFALSE 104571
// exit ;
104569: GO 104597
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104571: LD_VAR 0 1
104575: PUSH
104576: LD_INT 1
104578: PPUSH
104579: LD_VAR 0 1
104583: PPUSH
104584: CALL_OW 12
104588: ARRAY
104589: PPUSH
104590: LD_INT 1
104592: PPUSH
104593: CALL_OW 234
// end ;
104597: PPOPN 1
104599: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104600: LD_EXP 124
104604: PUSH
104605: LD_EXP 166
104609: AND
104610: IFFALSE 104751
104612: GO 104614
104614: DISABLE
104615: LD_INT 0
104617: PPUSH
104618: PPUSH
104619: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104620: LD_ADDR_VAR 0 3
104624: PUSH
104625: LD_INT 22
104627: PUSH
104628: LD_OWVAR 2
104632: PUSH
104633: EMPTY
104634: LIST
104635: LIST
104636: PUSH
104637: LD_INT 25
104639: PUSH
104640: LD_INT 1
104642: PUSH
104643: EMPTY
104644: LIST
104645: LIST
104646: PUSH
104647: EMPTY
104648: LIST
104649: LIST
104650: PPUSH
104651: CALL_OW 69
104655: ST_TO_ADDR
// if not tmp then
104656: LD_VAR 0 3
104660: NOT
104661: IFFALSE 104665
// exit ;
104663: GO 104751
// un := tmp [ rand ( 1 , tmp ) ] ;
104665: LD_ADDR_VAR 0 2
104669: PUSH
104670: LD_VAR 0 3
104674: PUSH
104675: LD_INT 1
104677: PPUSH
104678: LD_VAR 0 3
104682: PPUSH
104683: CALL_OW 12
104687: ARRAY
104688: ST_TO_ADDR
// if Crawls ( un ) then
104689: LD_VAR 0 2
104693: PPUSH
104694: CALL_OW 318
104698: IFFALSE 104709
// ComWalk ( un ) ;
104700: LD_VAR 0 2
104704: PPUSH
104705: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104709: LD_VAR 0 2
104713: PPUSH
104714: LD_INT 9
104716: PPUSH
104717: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104721: LD_INT 28
104723: PPUSH
104724: LD_OWVAR 2
104728: PPUSH
104729: LD_INT 2
104731: PPUSH
104732: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104736: LD_INT 29
104738: PPUSH
104739: LD_OWVAR 2
104743: PPUSH
104744: LD_INT 2
104746: PPUSH
104747: CALL_OW 322
// end ;
104751: PPOPN 3
104753: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104754: LD_EXP 124
104758: PUSH
104759: LD_EXP 167
104763: AND
104764: IFFALSE 104875
104766: GO 104768
104768: DISABLE
104769: LD_INT 0
104771: PPUSH
104772: PPUSH
104773: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104774: LD_ADDR_VAR 0 3
104778: PUSH
104779: LD_INT 22
104781: PUSH
104782: LD_OWVAR 2
104786: PUSH
104787: EMPTY
104788: LIST
104789: LIST
104790: PUSH
104791: LD_INT 25
104793: PUSH
104794: LD_INT 1
104796: PUSH
104797: EMPTY
104798: LIST
104799: LIST
104800: PUSH
104801: EMPTY
104802: LIST
104803: LIST
104804: PPUSH
104805: CALL_OW 69
104809: ST_TO_ADDR
// if not tmp then
104810: LD_VAR 0 3
104814: NOT
104815: IFFALSE 104819
// exit ;
104817: GO 104875
// un := tmp [ rand ( 1 , tmp ) ] ;
104819: LD_ADDR_VAR 0 2
104823: PUSH
104824: LD_VAR 0 3
104828: PUSH
104829: LD_INT 1
104831: PPUSH
104832: LD_VAR 0 3
104836: PPUSH
104837: CALL_OW 12
104841: ARRAY
104842: ST_TO_ADDR
// if Crawls ( un ) then
104843: LD_VAR 0 2
104847: PPUSH
104848: CALL_OW 318
104852: IFFALSE 104863
// ComWalk ( un ) ;
104854: LD_VAR 0 2
104858: PPUSH
104859: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104863: LD_VAR 0 2
104867: PPUSH
104868: LD_INT 8
104870: PPUSH
104871: CALL_OW 336
// end ;
104875: PPOPN 3
104877: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
104878: LD_EXP 124
104882: PUSH
104883: LD_EXP 168
104887: AND
104888: IFFALSE 105032
104890: GO 104892
104892: DISABLE
104893: LD_INT 0
104895: PPUSH
104896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
104897: LD_ADDR_VAR 0 2
104901: PUSH
104902: LD_INT 22
104904: PUSH
104905: LD_OWVAR 2
104909: PUSH
104910: EMPTY
104911: LIST
104912: LIST
104913: PUSH
104914: LD_INT 21
104916: PUSH
104917: LD_INT 2
104919: PUSH
104920: EMPTY
104921: LIST
104922: LIST
104923: PUSH
104924: LD_INT 2
104926: PUSH
104927: LD_INT 34
104929: PUSH
104930: LD_INT 12
104932: PUSH
104933: EMPTY
104934: LIST
104935: LIST
104936: PUSH
104937: LD_INT 34
104939: PUSH
104940: LD_INT 51
104942: PUSH
104943: EMPTY
104944: LIST
104945: LIST
104946: PUSH
104947: LD_INT 34
104949: PUSH
104950: LD_INT 32
104952: PUSH
104953: EMPTY
104954: LIST
104955: LIST
104956: PUSH
104957: EMPTY
104958: LIST
104959: LIST
104960: LIST
104961: LIST
104962: PUSH
104963: EMPTY
104964: LIST
104965: LIST
104966: LIST
104967: PPUSH
104968: CALL_OW 69
104972: ST_TO_ADDR
// if not tmp then
104973: LD_VAR 0 2
104977: NOT
104978: IFFALSE 104982
// exit ;
104980: GO 105032
// for i in tmp do
104982: LD_ADDR_VAR 0 1
104986: PUSH
104987: LD_VAR 0 2
104991: PUSH
104992: FOR_IN
104993: IFFALSE 105030
// if GetCargo ( i , mat_artifact ) = 0 then
104995: LD_VAR 0 1
104999: PPUSH
105000: LD_INT 4
105002: PPUSH
105003: CALL_OW 289
105007: PUSH
105008: LD_INT 0
105010: EQUAL
105011: IFFALSE 105028
// SetCargo ( i , mat_siberit , 100 ) ;
105013: LD_VAR 0 1
105017: PPUSH
105018: LD_INT 3
105020: PPUSH
105021: LD_INT 100
105023: PPUSH
105024: CALL_OW 290
105028: GO 104992
105030: POP
105031: POP
// end ;
105032: PPOPN 2
105034: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105035: LD_EXP 124
105039: PUSH
105040: LD_EXP 169
105044: AND
105045: IFFALSE 105228
105047: GO 105049
105049: DISABLE
105050: LD_INT 0
105052: PPUSH
105053: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105054: LD_ADDR_VAR 0 2
105058: PUSH
105059: LD_INT 22
105061: PUSH
105062: LD_OWVAR 2
105066: PUSH
105067: EMPTY
105068: LIST
105069: LIST
105070: PPUSH
105071: CALL_OW 69
105075: ST_TO_ADDR
// if not tmp then
105076: LD_VAR 0 2
105080: NOT
105081: IFFALSE 105085
// exit ;
105083: GO 105228
// for i := 1 to 2 do
105085: LD_ADDR_VAR 0 1
105089: PUSH
105090: DOUBLE
105091: LD_INT 1
105093: DEC
105094: ST_TO_ADDR
105095: LD_INT 2
105097: PUSH
105098: FOR_TO
105099: IFFALSE 105226
// begin uc_side := your_side ;
105101: LD_ADDR_OWVAR 20
105105: PUSH
105106: LD_OWVAR 2
105110: ST_TO_ADDR
// uc_nation := nation_american ;
105111: LD_ADDR_OWVAR 21
105115: PUSH
105116: LD_INT 1
105118: ST_TO_ADDR
// vc_chassis := us_morphling ;
105119: LD_ADDR_OWVAR 37
105123: PUSH
105124: LD_INT 5
105126: ST_TO_ADDR
// vc_engine := engine_siberite ;
105127: LD_ADDR_OWVAR 39
105131: PUSH
105132: LD_INT 3
105134: ST_TO_ADDR
// vc_control := control_computer ;
105135: LD_ADDR_OWVAR 38
105139: PUSH
105140: LD_INT 3
105142: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105143: LD_ADDR_OWVAR 40
105147: PUSH
105148: LD_INT 10
105150: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105151: LD_VAR 0 2
105155: PUSH
105156: LD_INT 1
105158: ARRAY
105159: PPUSH
105160: CALL_OW 310
105164: NOT
105165: IFFALSE 105212
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105167: CALL_OW 45
105171: PPUSH
105172: LD_VAR 0 2
105176: PUSH
105177: LD_INT 1
105179: ARRAY
105180: PPUSH
105181: CALL_OW 250
105185: PPUSH
105186: LD_VAR 0 2
105190: PUSH
105191: LD_INT 1
105193: ARRAY
105194: PPUSH
105195: CALL_OW 251
105199: PPUSH
105200: LD_INT 12
105202: PPUSH
105203: LD_INT 1
105205: PPUSH
105206: CALL_OW 50
105210: GO 105224
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105212: CALL_OW 45
105216: PPUSH
105217: LD_INT 1
105219: PPUSH
105220: CALL_OW 51
// end ;
105224: GO 105098
105226: POP
105227: POP
// end ;
105228: PPOPN 2
105230: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105231: LD_EXP 124
105235: PUSH
105236: LD_EXP 170
105240: AND
105241: IFFALSE 105463
105243: GO 105245
105245: DISABLE
105246: LD_INT 0
105248: PPUSH
105249: PPUSH
105250: PPUSH
105251: PPUSH
105252: PPUSH
105253: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105254: LD_ADDR_VAR 0 6
105258: PUSH
105259: LD_INT 22
105261: PUSH
105262: LD_OWVAR 2
105266: PUSH
105267: EMPTY
105268: LIST
105269: LIST
105270: PUSH
105271: LD_INT 21
105273: PUSH
105274: LD_INT 1
105276: PUSH
105277: EMPTY
105278: LIST
105279: LIST
105280: PUSH
105281: LD_INT 3
105283: PUSH
105284: LD_INT 23
105286: PUSH
105287: LD_INT 0
105289: PUSH
105290: EMPTY
105291: LIST
105292: LIST
105293: PUSH
105294: EMPTY
105295: LIST
105296: LIST
105297: PUSH
105298: EMPTY
105299: LIST
105300: LIST
105301: LIST
105302: PPUSH
105303: CALL_OW 69
105307: ST_TO_ADDR
// if not tmp then
105308: LD_VAR 0 6
105312: NOT
105313: IFFALSE 105317
// exit ;
105315: GO 105463
// s1 := rand ( 1 , 4 ) ;
105317: LD_ADDR_VAR 0 2
105321: PUSH
105322: LD_INT 1
105324: PPUSH
105325: LD_INT 4
105327: PPUSH
105328: CALL_OW 12
105332: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105333: LD_ADDR_VAR 0 4
105337: PUSH
105338: LD_VAR 0 6
105342: PUSH
105343: LD_INT 1
105345: ARRAY
105346: PPUSH
105347: LD_VAR 0 2
105351: PPUSH
105352: CALL_OW 259
105356: ST_TO_ADDR
// if s1 = 1 then
105357: LD_VAR 0 2
105361: PUSH
105362: LD_INT 1
105364: EQUAL
105365: IFFALSE 105385
// s2 := rand ( 2 , 4 ) else
105367: LD_ADDR_VAR 0 3
105371: PUSH
105372: LD_INT 2
105374: PPUSH
105375: LD_INT 4
105377: PPUSH
105378: CALL_OW 12
105382: ST_TO_ADDR
105383: GO 105393
// s2 := 1 ;
105385: LD_ADDR_VAR 0 3
105389: PUSH
105390: LD_INT 1
105392: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105393: LD_ADDR_VAR 0 5
105397: PUSH
105398: LD_VAR 0 6
105402: PUSH
105403: LD_INT 1
105405: ARRAY
105406: PPUSH
105407: LD_VAR 0 3
105411: PPUSH
105412: CALL_OW 259
105416: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105417: LD_VAR 0 6
105421: PUSH
105422: LD_INT 1
105424: ARRAY
105425: PPUSH
105426: LD_VAR 0 2
105430: PPUSH
105431: LD_VAR 0 5
105435: PPUSH
105436: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105440: LD_VAR 0 6
105444: PUSH
105445: LD_INT 1
105447: ARRAY
105448: PPUSH
105449: LD_VAR 0 3
105453: PPUSH
105454: LD_VAR 0 4
105458: PPUSH
105459: CALL_OW 237
// end ;
105463: PPOPN 6
105465: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105466: LD_EXP 124
105470: PUSH
105471: LD_EXP 171
105475: AND
105476: IFFALSE 105555
105478: GO 105480
105480: DISABLE
105481: LD_INT 0
105483: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105484: LD_ADDR_VAR 0 1
105488: PUSH
105489: LD_INT 22
105491: PUSH
105492: LD_OWVAR 2
105496: PUSH
105497: EMPTY
105498: LIST
105499: LIST
105500: PUSH
105501: LD_INT 30
105503: PUSH
105504: LD_INT 3
105506: PUSH
105507: EMPTY
105508: LIST
105509: LIST
105510: PUSH
105511: EMPTY
105512: LIST
105513: LIST
105514: PPUSH
105515: CALL_OW 69
105519: ST_TO_ADDR
// if not tmp then
105520: LD_VAR 0 1
105524: NOT
105525: IFFALSE 105529
// exit ;
105527: GO 105555
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105529: LD_VAR 0 1
105533: PUSH
105534: LD_INT 1
105536: PPUSH
105537: LD_VAR 0 1
105541: PPUSH
105542: CALL_OW 12
105546: ARRAY
105547: PPUSH
105548: LD_INT 1
105550: PPUSH
105551: CALL_OW 234
// end ;
105555: PPOPN 1
105557: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105558: LD_EXP 124
105562: PUSH
105563: LD_EXP 172
105567: AND
105568: IFFALSE 105680
105570: GO 105572
105572: DISABLE
105573: LD_INT 0
105575: PPUSH
105576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105577: LD_ADDR_VAR 0 2
105581: PUSH
105582: LD_INT 22
105584: PUSH
105585: LD_OWVAR 2
105589: PUSH
105590: EMPTY
105591: LIST
105592: LIST
105593: PUSH
105594: LD_INT 2
105596: PUSH
105597: LD_INT 30
105599: PUSH
105600: LD_INT 27
105602: PUSH
105603: EMPTY
105604: LIST
105605: LIST
105606: PUSH
105607: LD_INT 30
105609: PUSH
105610: LD_INT 26
105612: PUSH
105613: EMPTY
105614: LIST
105615: LIST
105616: PUSH
105617: LD_INT 30
105619: PUSH
105620: LD_INT 28
105622: PUSH
105623: EMPTY
105624: LIST
105625: LIST
105626: PUSH
105627: EMPTY
105628: LIST
105629: LIST
105630: LIST
105631: LIST
105632: PUSH
105633: EMPTY
105634: LIST
105635: LIST
105636: PPUSH
105637: CALL_OW 69
105641: ST_TO_ADDR
// if not tmp then
105642: LD_VAR 0 2
105646: NOT
105647: IFFALSE 105651
// exit ;
105649: GO 105680
// for i in tmp do
105651: LD_ADDR_VAR 0 1
105655: PUSH
105656: LD_VAR 0 2
105660: PUSH
105661: FOR_IN
105662: IFFALSE 105678
// SetLives ( i , 1 ) ;
105664: LD_VAR 0 1
105668: PPUSH
105669: LD_INT 1
105671: PPUSH
105672: CALL_OW 234
105676: GO 105661
105678: POP
105679: POP
// end ;
105680: PPOPN 2
105682: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105683: LD_EXP 124
105687: PUSH
105688: LD_EXP 173
105692: AND
105693: IFFALSE 105980
105695: GO 105697
105697: DISABLE
105698: LD_INT 0
105700: PPUSH
105701: PPUSH
105702: PPUSH
// begin i := rand ( 1 , 7 ) ;
105703: LD_ADDR_VAR 0 1
105707: PUSH
105708: LD_INT 1
105710: PPUSH
105711: LD_INT 7
105713: PPUSH
105714: CALL_OW 12
105718: ST_TO_ADDR
// case i of 1 :
105719: LD_VAR 0 1
105723: PUSH
105724: LD_INT 1
105726: DOUBLE
105727: EQUAL
105728: IFTRUE 105732
105730: GO 105742
105732: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105733: LD_STRING earthquake(getX(game), 0, 32)
105735: PPUSH
105736: CALL_OW 559
105740: GO 105980
105742: LD_INT 2
105744: DOUBLE
105745: EQUAL
105746: IFTRUE 105750
105748: GO 105764
105750: POP
// begin ToLua ( displayStucuk(); ) ;
105751: LD_STRING displayStucuk();
105753: PPUSH
105754: CALL_OW 559
// ResetFog ;
105758: CALL_OW 335
// end ; 3 :
105762: GO 105980
105764: LD_INT 3
105766: DOUBLE
105767: EQUAL
105768: IFTRUE 105772
105770: GO 105876
105772: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105773: LD_ADDR_VAR 0 2
105777: PUSH
105778: LD_INT 22
105780: PUSH
105781: LD_OWVAR 2
105785: PUSH
105786: EMPTY
105787: LIST
105788: LIST
105789: PUSH
105790: LD_INT 25
105792: PUSH
105793: LD_INT 1
105795: PUSH
105796: EMPTY
105797: LIST
105798: LIST
105799: PUSH
105800: EMPTY
105801: LIST
105802: LIST
105803: PPUSH
105804: CALL_OW 69
105808: ST_TO_ADDR
// if not tmp then
105809: LD_VAR 0 2
105813: NOT
105814: IFFALSE 105818
// exit ;
105816: GO 105980
// un := tmp [ rand ( 1 , tmp ) ] ;
105818: LD_ADDR_VAR 0 3
105822: PUSH
105823: LD_VAR 0 2
105827: PUSH
105828: LD_INT 1
105830: PPUSH
105831: LD_VAR 0 2
105835: PPUSH
105836: CALL_OW 12
105840: ARRAY
105841: ST_TO_ADDR
// if Crawls ( un ) then
105842: LD_VAR 0 3
105846: PPUSH
105847: CALL_OW 318
105851: IFFALSE 105862
// ComWalk ( un ) ;
105853: LD_VAR 0 3
105857: PPUSH
105858: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105862: LD_VAR 0 3
105866: PPUSH
105867: LD_INT 8
105869: PPUSH
105870: CALL_OW 336
// end ; 4 :
105874: GO 105980
105876: LD_INT 4
105878: DOUBLE
105879: EQUAL
105880: IFTRUE 105884
105882: GO 105958
105884: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105885: LD_ADDR_VAR 0 2
105889: PUSH
105890: LD_INT 22
105892: PUSH
105893: LD_OWVAR 2
105897: PUSH
105898: EMPTY
105899: LIST
105900: LIST
105901: PUSH
105902: LD_INT 30
105904: PUSH
105905: LD_INT 29
105907: PUSH
105908: EMPTY
105909: LIST
105910: LIST
105911: PUSH
105912: EMPTY
105913: LIST
105914: LIST
105915: PPUSH
105916: CALL_OW 69
105920: ST_TO_ADDR
// if not tmp then
105921: LD_VAR 0 2
105925: NOT
105926: IFFALSE 105930
// exit ;
105928: GO 105980
// CenterNowOnUnits ( tmp [ 1 ] ) ;
105930: LD_VAR 0 2
105934: PUSH
105935: LD_INT 1
105937: ARRAY
105938: PPUSH
105939: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
105943: LD_VAR 0 2
105947: PUSH
105948: LD_INT 1
105950: ARRAY
105951: PPUSH
105952: CALL_OW 65
// end ; 5 .. 7 :
105956: GO 105980
105958: LD_INT 5
105960: DOUBLE
105961: GREATEREQUAL
105962: IFFALSE 105970
105964: LD_INT 7
105966: DOUBLE
105967: LESSEQUAL
105968: IFTRUE 105972
105970: GO 105979
105972: POP
// StreamSibBomb ; end ;
105973: CALL 102217 0 0
105977: GO 105980
105979: POP
// end ;
105980: PPOPN 3
105982: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105983: LD_EXP 124
105987: PUSH
105988: LD_EXP 174
105992: AND
105993: IFFALSE 106149
105995: GO 105997
105997: DISABLE
105998: LD_INT 0
106000: PPUSH
106001: PPUSH
106002: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106003: LD_ADDR_VAR 0 2
106007: PUSH
106008: LD_INT 81
106010: PUSH
106011: LD_OWVAR 2
106015: PUSH
106016: EMPTY
106017: LIST
106018: LIST
106019: PUSH
106020: LD_INT 2
106022: PUSH
106023: LD_INT 21
106025: PUSH
106026: LD_INT 1
106028: PUSH
106029: EMPTY
106030: LIST
106031: LIST
106032: PUSH
106033: LD_INT 21
106035: PUSH
106036: LD_INT 2
106038: PUSH
106039: EMPTY
106040: LIST
106041: LIST
106042: PUSH
106043: EMPTY
106044: LIST
106045: LIST
106046: LIST
106047: PUSH
106048: EMPTY
106049: LIST
106050: LIST
106051: PPUSH
106052: CALL_OW 69
106056: ST_TO_ADDR
// if not tmp then
106057: LD_VAR 0 2
106061: NOT
106062: IFFALSE 106066
// exit ;
106064: GO 106149
// p := 0 ;
106066: LD_ADDR_VAR 0 3
106070: PUSH
106071: LD_INT 0
106073: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106074: LD_INT 35
106076: PPUSH
106077: CALL_OW 67
// p := p + 1 ;
106081: LD_ADDR_VAR 0 3
106085: PUSH
106086: LD_VAR 0 3
106090: PUSH
106091: LD_INT 1
106093: PLUS
106094: ST_TO_ADDR
// for i in tmp do
106095: LD_ADDR_VAR 0 1
106099: PUSH
106100: LD_VAR 0 2
106104: PUSH
106105: FOR_IN
106106: IFFALSE 106137
// if GetLives ( i ) < 1000 then
106108: LD_VAR 0 1
106112: PPUSH
106113: CALL_OW 256
106117: PUSH
106118: LD_INT 1000
106120: LESS
106121: IFFALSE 106135
// SetLives ( i , 1000 ) ;
106123: LD_VAR 0 1
106127: PPUSH
106128: LD_INT 1000
106130: PPUSH
106131: CALL_OW 234
106135: GO 106105
106137: POP
106138: POP
// until p > 20 ;
106139: LD_VAR 0 3
106143: PUSH
106144: LD_INT 20
106146: GREATER
106147: IFFALSE 106074
// end ;
106149: PPOPN 3
106151: END
// every 0 0$1 trigger StreamModeActive and sTime do
106152: LD_EXP 124
106156: PUSH
106157: LD_EXP 175
106161: AND
106162: IFFALSE 106197
106164: GO 106166
106166: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106167: LD_INT 28
106169: PPUSH
106170: LD_OWVAR 2
106174: PPUSH
106175: LD_INT 2
106177: PPUSH
106178: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106182: LD_INT 30
106184: PPUSH
106185: LD_OWVAR 2
106189: PPUSH
106190: LD_INT 2
106192: PPUSH
106193: CALL_OW 322
// end ;
106197: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106198: LD_EXP 124
106202: PUSH
106203: LD_EXP 176
106207: AND
106208: IFFALSE 106329
106210: GO 106212
106212: DISABLE
106213: LD_INT 0
106215: PPUSH
106216: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106217: LD_ADDR_VAR 0 2
106221: PUSH
106222: LD_INT 22
106224: PUSH
106225: LD_OWVAR 2
106229: PUSH
106230: EMPTY
106231: LIST
106232: LIST
106233: PUSH
106234: LD_INT 21
106236: PUSH
106237: LD_INT 1
106239: PUSH
106240: EMPTY
106241: LIST
106242: LIST
106243: PUSH
106244: LD_INT 3
106246: PUSH
106247: LD_INT 23
106249: PUSH
106250: LD_INT 0
106252: PUSH
106253: EMPTY
106254: LIST
106255: LIST
106256: PUSH
106257: EMPTY
106258: LIST
106259: LIST
106260: PUSH
106261: EMPTY
106262: LIST
106263: LIST
106264: LIST
106265: PPUSH
106266: CALL_OW 69
106270: ST_TO_ADDR
// if not tmp then
106271: LD_VAR 0 2
106275: NOT
106276: IFFALSE 106280
// exit ;
106278: GO 106329
// for i in tmp do
106280: LD_ADDR_VAR 0 1
106284: PUSH
106285: LD_VAR 0 2
106289: PUSH
106290: FOR_IN
106291: IFFALSE 106327
// begin if Crawls ( i ) then
106293: LD_VAR 0 1
106297: PPUSH
106298: CALL_OW 318
106302: IFFALSE 106313
// ComWalk ( i ) ;
106304: LD_VAR 0 1
106308: PPUSH
106309: CALL_OW 138
// SetClass ( i , 2 ) ;
106313: LD_VAR 0 1
106317: PPUSH
106318: LD_INT 2
106320: PPUSH
106321: CALL_OW 336
// end ;
106325: GO 106290
106327: POP
106328: POP
// end ;
106329: PPOPN 2
106331: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106332: LD_EXP 124
106336: PUSH
106337: LD_EXP 177
106341: AND
106342: IFFALSE 106630
106344: GO 106346
106346: DISABLE
106347: LD_INT 0
106349: PPUSH
106350: PPUSH
106351: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106352: LD_OWVAR 2
106356: PPUSH
106357: LD_INT 9
106359: PPUSH
106360: LD_INT 1
106362: PPUSH
106363: LD_INT 1
106365: PPUSH
106366: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106370: LD_INT 9
106372: PPUSH
106373: LD_OWVAR 2
106377: PPUSH
106378: CALL_OW 343
// uc_side := 9 ;
106382: LD_ADDR_OWVAR 20
106386: PUSH
106387: LD_INT 9
106389: ST_TO_ADDR
// uc_nation := 2 ;
106390: LD_ADDR_OWVAR 21
106394: PUSH
106395: LD_INT 2
106397: ST_TO_ADDR
// hc_name := Dark Warrior ;
106398: LD_ADDR_OWVAR 26
106402: PUSH
106403: LD_STRING Dark Warrior
106405: ST_TO_ADDR
// hc_gallery :=  ;
106406: LD_ADDR_OWVAR 33
106410: PUSH
106411: LD_STRING 
106413: ST_TO_ADDR
// hc_noskilllimit := true ;
106414: LD_ADDR_OWVAR 76
106418: PUSH
106419: LD_INT 1
106421: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106422: LD_ADDR_OWVAR 31
106426: PUSH
106427: LD_INT 30
106429: PUSH
106430: LD_INT 30
106432: PUSH
106433: LD_INT 30
106435: PUSH
106436: LD_INT 30
106438: PUSH
106439: EMPTY
106440: LIST
106441: LIST
106442: LIST
106443: LIST
106444: ST_TO_ADDR
// un := CreateHuman ;
106445: LD_ADDR_VAR 0 3
106449: PUSH
106450: CALL_OW 44
106454: ST_TO_ADDR
// hc_noskilllimit := false ;
106455: LD_ADDR_OWVAR 76
106459: PUSH
106460: LD_INT 0
106462: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106463: LD_VAR 0 3
106467: PPUSH
106468: LD_INT 1
106470: PPUSH
106471: CALL_OW 51
// ToLua ( playRanger() ) ;
106475: LD_STRING playRanger()
106477: PPUSH
106478: CALL_OW 559
// p := 0 ;
106482: LD_ADDR_VAR 0 2
106486: PUSH
106487: LD_INT 0
106489: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106490: LD_INT 35
106492: PPUSH
106493: CALL_OW 67
// p := p + 1 ;
106497: LD_ADDR_VAR 0 2
106501: PUSH
106502: LD_VAR 0 2
106506: PUSH
106507: LD_INT 1
106509: PLUS
106510: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106511: LD_VAR 0 3
106515: PPUSH
106516: CALL_OW 256
106520: PUSH
106521: LD_INT 1000
106523: LESS
106524: IFFALSE 106538
// SetLives ( un , 1000 ) ;
106526: LD_VAR 0 3
106530: PPUSH
106531: LD_INT 1000
106533: PPUSH
106534: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106538: LD_VAR 0 3
106542: PPUSH
106543: LD_INT 81
106545: PUSH
106546: LD_OWVAR 2
106550: PUSH
106551: EMPTY
106552: LIST
106553: LIST
106554: PUSH
106555: LD_INT 91
106557: PUSH
106558: LD_VAR 0 3
106562: PUSH
106563: LD_INT 30
106565: PUSH
106566: EMPTY
106567: LIST
106568: LIST
106569: LIST
106570: PUSH
106571: EMPTY
106572: LIST
106573: LIST
106574: PPUSH
106575: CALL_OW 69
106579: PPUSH
106580: LD_VAR 0 3
106584: PPUSH
106585: CALL_OW 74
106589: PPUSH
106590: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106594: LD_VAR 0 2
106598: PUSH
106599: LD_INT 80
106601: GREATER
106602: PUSH
106603: LD_VAR 0 3
106607: PPUSH
106608: CALL_OW 301
106612: OR
106613: IFFALSE 106490
// if un then
106615: LD_VAR 0 3
106619: IFFALSE 106630
// RemoveUnit ( un ) ;
106621: LD_VAR 0 3
106625: PPUSH
106626: CALL_OW 64
// end ;
106630: PPOPN 3
106632: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106633: LD_EXP 178
106637: IFFALSE 106753
106639: GO 106641
106641: DISABLE
106642: LD_INT 0
106644: PPUSH
106645: PPUSH
106646: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106647: LD_ADDR_VAR 0 2
106651: PUSH
106652: LD_INT 81
106654: PUSH
106655: LD_OWVAR 2
106659: PUSH
106660: EMPTY
106661: LIST
106662: LIST
106663: PUSH
106664: LD_INT 21
106666: PUSH
106667: LD_INT 1
106669: PUSH
106670: EMPTY
106671: LIST
106672: LIST
106673: PUSH
106674: EMPTY
106675: LIST
106676: LIST
106677: PPUSH
106678: CALL_OW 69
106682: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106683: LD_STRING playComputer()
106685: PPUSH
106686: CALL_OW 559
// if not tmp then
106690: LD_VAR 0 2
106694: NOT
106695: IFFALSE 106699
// exit ;
106697: GO 106753
// for i in tmp do
106699: LD_ADDR_VAR 0 1
106703: PUSH
106704: LD_VAR 0 2
106708: PUSH
106709: FOR_IN
106710: IFFALSE 106751
// for j := 1 to 4 do
106712: LD_ADDR_VAR 0 3
106716: PUSH
106717: DOUBLE
106718: LD_INT 1
106720: DEC
106721: ST_TO_ADDR
106722: LD_INT 4
106724: PUSH
106725: FOR_TO
106726: IFFALSE 106747
// SetSkill ( i , j , 10 ) ;
106728: LD_VAR 0 1
106732: PPUSH
106733: LD_VAR 0 3
106737: PPUSH
106738: LD_INT 10
106740: PPUSH
106741: CALL_OW 237
106745: GO 106725
106747: POP
106748: POP
106749: GO 106709
106751: POP
106752: POP
// end ;
106753: PPOPN 3
106755: END
// every 0 0$1 trigger s30 do var i , tmp ;
106756: LD_EXP 179
106760: IFFALSE 106829
106762: GO 106764
106764: DISABLE
106765: LD_INT 0
106767: PPUSH
106768: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106769: LD_ADDR_VAR 0 2
106773: PUSH
106774: LD_INT 22
106776: PUSH
106777: LD_OWVAR 2
106781: PUSH
106782: EMPTY
106783: LIST
106784: LIST
106785: PPUSH
106786: CALL_OW 69
106790: ST_TO_ADDR
// if not tmp then
106791: LD_VAR 0 2
106795: NOT
106796: IFFALSE 106800
// exit ;
106798: GO 106829
// for i in tmp do
106800: LD_ADDR_VAR 0 1
106804: PUSH
106805: LD_VAR 0 2
106809: PUSH
106810: FOR_IN
106811: IFFALSE 106827
// SetLives ( i , 300 ) ;
106813: LD_VAR 0 1
106817: PPUSH
106818: LD_INT 300
106820: PPUSH
106821: CALL_OW 234
106825: GO 106810
106827: POP
106828: POP
// end ;
106829: PPOPN 2
106831: END
// every 0 0$1 trigger s60 do var i , tmp ;
106832: LD_EXP 180
106836: IFFALSE 106905
106838: GO 106840
106840: DISABLE
106841: LD_INT 0
106843: PPUSH
106844: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106845: LD_ADDR_VAR 0 2
106849: PUSH
106850: LD_INT 22
106852: PUSH
106853: LD_OWVAR 2
106857: PUSH
106858: EMPTY
106859: LIST
106860: LIST
106861: PPUSH
106862: CALL_OW 69
106866: ST_TO_ADDR
// if not tmp then
106867: LD_VAR 0 2
106871: NOT
106872: IFFALSE 106876
// exit ;
106874: GO 106905
// for i in tmp do
106876: LD_ADDR_VAR 0 1
106880: PUSH
106881: LD_VAR 0 2
106885: PUSH
106886: FOR_IN
106887: IFFALSE 106903
// SetLives ( i , 600 ) ;
106889: LD_VAR 0 1
106893: PPUSH
106894: LD_INT 600
106896: PPUSH
106897: CALL_OW 234
106901: GO 106886
106903: POP
106904: POP
// end ;
106905: PPOPN 2
106907: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106908: LD_INT 0
106910: PPUSH
// case cmd of 301 :
106911: LD_VAR 0 1
106915: PUSH
106916: LD_INT 301
106918: DOUBLE
106919: EQUAL
106920: IFTRUE 106924
106922: GO 106956
106924: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
106925: LD_VAR 0 6
106929: PPUSH
106930: LD_VAR 0 7
106934: PPUSH
106935: LD_VAR 0 8
106939: PPUSH
106940: LD_VAR 0 4
106944: PPUSH
106945: LD_VAR 0 5
106949: PPUSH
106950: CALL 108165 0 5
106954: GO 107077
106956: LD_INT 302
106958: DOUBLE
106959: EQUAL
106960: IFTRUE 106964
106962: GO 107001
106964: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
106965: LD_VAR 0 6
106969: PPUSH
106970: LD_VAR 0 7
106974: PPUSH
106975: LD_VAR 0 8
106979: PPUSH
106980: LD_VAR 0 9
106984: PPUSH
106985: LD_VAR 0 4
106989: PPUSH
106990: LD_VAR 0 5
106994: PPUSH
106995: CALL 108256 0 6
106999: GO 107077
107001: LD_INT 303
107003: DOUBLE
107004: EQUAL
107005: IFTRUE 107009
107007: GO 107046
107009: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107010: LD_VAR 0 6
107014: PPUSH
107015: LD_VAR 0 7
107019: PPUSH
107020: LD_VAR 0 8
107024: PPUSH
107025: LD_VAR 0 9
107029: PPUSH
107030: LD_VAR 0 4
107034: PPUSH
107035: LD_VAR 0 5
107039: PPUSH
107040: CALL 107082 0 6
107044: GO 107077
107046: LD_INT 304
107048: DOUBLE
107049: EQUAL
107050: IFTRUE 107054
107052: GO 107076
107054: POP
// hHackTeleport ( unit , x , y ) ; end ;
107055: LD_VAR 0 2
107059: PPUSH
107060: LD_VAR 0 4
107064: PPUSH
107065: LD_VAR 0 5
107069: PPUSH
107070: CALL 108849 0 3
107074: GO 107077
107076: POP
// end ;
107077: LD_VAR 0 12
107081: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107082: LD_INT 0
107084: PPUSH
107085: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107086: LD_VAR 0 1
107090: PUSH
107091: LD_INT 1
107093: LESS
107094: PUSH
107095: LD_VAR 0 1
107099: PUSH
107100: LD_INT 3
107102: GREATER
107103: OR
107104: PUSH
107105: LD_VAR 0 5
107109: PPUSH
107110: LD_VAR 0 6
107114: PPUSH
107115: CALL_OW 428
107119: OR
107120: IFFALSE 107124
// exit ;
107122: GO 107852
// uc_side := your_side ;
107124: LD_ADDR_OWVAR 20
107128: PUSH
107129: LD_OWVAR 2
107133: ST_TO_ADDR
// uc_nation := nation ;
107134: LD_ADDR_OWVAR 21
107138: PUSH
107139: LD_VAR 0 1
107143: ST_TO_ADDR
// bc_level = 1 ;
107144: LD_ADDR_OWVAR 43
107148: PUSH
107149: LD_INT 1
107151: ST_TO_ADDR
// case btype of 1 :
107152: LD_VAR 0 2
107156: PUSH
107157: LD_INT 1
107159: DOUBLE
107160: EQUAL
107161: IFTRUE 107165
107163: GO 107176
107165: POP
// bc_type := b_depot ; 2 :
107166: LD_ADDR_OWVAR 42
107170: PUSH
107171: LD_INT 0
107173: ST_TO_ADDR
107174: GO 107796
107176: LD_INT 2
107178: DOUBLE
107179: EQUAL
107180: IFTRUE 107184
107182: GO 107195
107184: POP
// bc_type := b_warehouse ; 3 :
107185: LD_ADDR_OWVAR 42
107189: PUSH
107190: LD_INT 1
107192: ST_TO_ADDR
107193: GO 107796
107195: LD_INT 3
107197: DOUBLE
107198: EQUAL
107199: IFTRUE 107203
107201: GO 107214
107203: POP
// bc_type := b_lab ; 4 .. 9 :
107204: LD_ADDR_OWVAR 42
107208: PUSH
107209: LD_INT 6
107211: ST_TO_ADDR
107212: GO 107796
107214: LD_INT 4
107216: DOUBLE
107217: GREATEREQUAL
107218: IFFALSE 107226
107220: LD_INT 9
107222: DOUBLE
107223: LESSEQUAL
107224: IFTRUE 107228
107226: GO 107288
107228: POP
// begin bc_type := b_lab_half ;
107229: LD_ADDR_OWVAR 42
107233: PUSH
107234: LD_INT 7
107236: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107237: LD_ADDR_OWVAR 44
107241: PUSH
107242: LD_INT 10
107244: PUSH
107245: LD_INT 11
107247: PUSH
107248: LD_INT 12
107250: PUSH
107251: LD_INT 15
107253: PUSH
107254: LD_INT 14
107256: PUSH
107257: LD_INT 13
107259: PUSH
107260: EMPTY
107261: LIST
107262: LIST
107263: LIST
107264: LIST
107265: LIST
107266: LIST
107267: PUSH
107268: LD_VAR 0 2
107272: PUSH
107273: LD_INT 3
107275: MINUS
107276: ARRAY
107277: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
107278: LD_ADDR_OWVAR 45
107282: PUSH
107283: LD_INT 9
107285: ST_TO_ADDR
// end ; 10 .. 13 :
107286: GO 107796
107288: LD_INT 10
107290: DOUBLE
107291: GREATEREQUAL
107292: IFFALSE 107300
107294: LD_INT 13
107296: DOUBLE
107297: LESSEQUAL
107298: IFTRUE 107302
107300: GO 107379
107302: POP
// begin bc_type := b_lab_full ;
107303: LD_ADDR_OWVAR 42
107307: PUSH
107308: LD_INT 8
107310: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107311: LD_ADDR_OWVAR 44
107315: PUSH
107316: LD_INT 10
107318: PUSH
107319: LD_INT 12
107321: PUSH
107322: LD_INT 14
107324: PUSH
107325: LD_INT 13
107327: PUSH
107328: EMPTY
107329: LIST
107330: LIST
107331: LIST
107332: LIST
107333: PUSH
107334: LD_VAR 0 2
107338: PUSH
107339: LD_INT 9
107341: MINUS
107342: ARRAY
107343: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107344: LD_ADDR_OWVAR 45
107348: PUSH
107349: LD_INT 11
107351: PUSH
107352: LD_INT 15
107354: PUSH
107355: LD_INT 12
107357: PUSH
107358: LD_INT 15
107360: PUSH
107361: EMPTY
107362: LIST
107363: LIST
107364: LIST
107365: LIST
107366: PUSH
107367: LD_VAR 0 2
107371: PUSH
107372: LD_INT 9
107374: MINUS
107375: ARRAY
107376: ST_TO_ADDR
// end ; 14 :
107377: GO 107796
107379: LD_INT 14
107381: DOUBLE
107382: EQUAL
107383: IFTRUE 107387
107385: GO 107398
107387: POP
// bc_type := b_workshop ; 15 :
107388: LD_ADDR_OWVAR 42
107392: PUSH
107393: LD_INT 2
107395: ST_TO_ADDR
107396: GO 107796
107398: LD_INT 15
107400: DOUBLE
107401: EQUAL
107402: IFTRUE 107406
107404: GO 107417
107406: POP
// bc_type := b_factory ; 16 :
107407: LD_ADDR_OWVAR 42
107411: PUSH
107412: LD_INT 3
107414: ST_TO_ADDR
107415: GO 107796
107417: LD_INT 16
107419: DOUBLE
107420: EQUAL
107421: IFTRUE 107425
107423: GO 107436
107425: POP
// bc_type := b_ext_gun ; 17 :
107426: LD_ADDR_OWVAR 42
107430: PUSH
107431: LD_INT 17
107433: ST_TO_ADDR
107434: GO 107796
107436: LD_INT 17
107438: DOUBLE
107439: EQUAL
107440: IFTRUE 107444
107442: GO 107472
107444: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107445: LD_ADDR_OWVAR 42
107449: PUSH
107450: LD_INT 19
107452: PUSH
107453: LD_INT 23
107455: PUSH
107456: LD_INT 19
107458: PUSH
107459: EMPTY
107460: LIST
107461: LIST
107462: LIST
107463: PUSH
107464: LD_VAR 0 1
107468: ARRAY
107469: ST_TO_ADDR
107470: GO 107796
107472: LD_INT 18
107474: DOUBLE
107475: EQUAL
107476: IFTRUE 107480
107478: GO 107491
107480: POP
// bc_type := b_ext_radar ; 19 :
107481: LD_ADDR_OWVAR 42
107485: PUSH
107486: LD_INT 20
107488: ST_TO_ADDR
107489: GO 107796
107491: LD_INT 19
107493: DOUBLE
107494: EQUAL
107495: IFTRUE 107499
107497: GO 107510
107499: POP
// bc_type := b_ext_radio ; 20 :
107500: LD_ADDR_OWVAR 42
107504: PUSH
107505: LD_INT 22
107507: ST_TO_ADDR
107508: GO 107796
107510: LD_INT 20
107512: DOUBLE
107513: EQUAL
107514: IFTRUE 107518
107516: GO 107529
107518: POP
// bc_type := b_ext_siberium ; 21 :
107519: LD_ADDR_OWVAR 42
107523: PUSH
107524: LD_INT 21
107526: ST_TO_ADDR
107527: GO 107796
107529: LD_INT 21
107531: DOUBLE
107532: EQUAL
107533: IFTRUE 107537
107535: GO 107548
107537: POP
// bc_type := b_ext_computer ; 22 :
107538: LD_ADDR_OWVAR 42
107542: PUSH
107543: LD_INT 24
107545: ST_TO_ADDR
107546: GO 107796
107548: LD_INT 22
107550: DOUBLE
107551: EQUAL
107552: IFTRUE 107556
107554: GO 107567
107556: POP
// bc_type := b_ext_track ; 23 :
107557: LD_ADDR_OWVAR 42
107561: PUSH
107562: LD_INT 16
107564: ST_TO_ADDR
107565: GO 107796
107567: LD_INT 23
107569: DOUBLE
107570: EQUAL
107571: IFTRUE 107575
107573: GO 107586
107575: POP
// bc_type := b_ext_laser ; 24 :
107576: LD_ADDR_OWVAR 42
107580: PUSH
107581: LD_INT 25
107583: ST_TO_ADDR
107584: GO 107796
107586: LD_INT 24
107588: DOUBLE
107589: EQUAL
107590: IFTRUE 107594
107592: GO 107605
107594: POP
// bc_type := b_control_tower ; 25 :
107595: LD_ADDR_OWVAR 42
107599: PUSH
107600: LD_INT 36
107602: ST_TO_ADDR
107603: GO 107796
107605: LD_INT 25
107607: DOUBLE
107608: EQUAL
107609: IFTRUE 107613
107611: GO 107624
107613: POP
// bc_type := b_breastwork ; 26 :
107614: LD_ADDR_OWVAR 42
107618: PUSH
107619: LD_INT 31
107621: ST_TO_ADDR
107622: GO 107796
107624: LD_INT 26
107626: DOUBLE
107627: EQUAL
107628: IFTRUE 107632
107630: GO 107643
107632: POP
// bc_type := b_bunker ; 27 :
107633: LD_ADDR_OWVAR 42
107637: PUSH
107638: LD_INT 32
107640: ST_TO_ADDR
107641: GO 107796
107643: LD_INT 27
107645: DOUBLE
107646: EQUAL
107647: IFTRUE 107651
107649: GO 107662
107651: POP
// bc_type := b_turret ; 28 :
107652: LD_ADDR_OWVAR 42
107656: PUSH
107657: LD_INT 33
107659: ST_TO_ADDR
107660: GO 107796
107662: LD_INT 28
107664: DOUBLE
107665: EQUAL
107666: IFTRUE 107670
107668: GO 107681
107670: POP
// bc_type := b_armoury ; 29 :
107671: LD_ADDR_OWVAR 42
107675: PUSH
107676: LD_INT 4
107678: ST_TO_ADDR
107679: GO 107796
107681: LD_INT 29
107683: DOUBLE
107684: EQUAL
107685: IFTRUE 107689
107687: GO 107700
107689: POP
// bc_type := b_barracks ; 30 :
107690: LD_ADDR_OWVAR 42
107694: PUSH
107695: LD_INT 5
107697: ST_TO_ADDR
107698: GO 107796
107700: LD_INT 30
107702: DOUBLE
107703: EQUAL
107704: IFTRUE 107708
107706: GO 107719
107708: POP
// bc_type := b_solar_power ; 31 :
107709: LD_ADDR_OWVAR 42
107713: PUSH
107714: LD_INT 27
107716: ST_TO_ADDR
107717: GO 107796
107719: LD_INT 31
107721: DOUBLE
107722: EQUAL
107723: IFTRUE 107727
107725: GO 107738
107727: POP
// bc_type := b_oil_power ; 32 :
107728: LD_ADDR_OWVAR 42
107732: PUSH
107733: LD_INT 26
107735: ST_TO_ADDR
107736: GO 107796
107738: LD_INT 32
107740: DOUBLE
107741: EQUAL
107742: IFTRUE 107746
107744: GO 107757
107746: POP
// bc_type := b_siberite_power ; 33 :
107747: LD_ADDR_OWVAR 42
107751: PUSH
107752: LD_INT 28
107754: ST_TO_ADDR
107755: GO 107796
107757: LD_INT 33
107759: DOUBLE
107760: EQUAL
107761: IFTRUE 107765
107763: GO 107776
107765: POP
// bc_type := b_oil_mine ; 34 :
107766: LD_ADDR_OWVAR 42
107770: PUSH
107771: LD_INT 29
107773: ST_TO_ADDR
107774: GO 107796
107776: LD_INT 34
107778: DOUBLE
107779: EQUAL
107780: IFTRUE 107784
107782: GO 107795
107784: POP
// bc_type := b_siberite_mine ; end ;
107785: LD_ADDR_OWVAR 42
107789: PUSH
107790: LD_INT 30
107792: ST_TO_ADDR
107793: GO 107796
107795: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
107796: LD_ADDR_VAR 0 8
107800: PUSH
107801: LD_VAR 0 5
107805: PPUSH
107806: LD_VAR 0 6
107810: PPUSH
107811: LD_VAR 0 3
107815: PPUSH
107816: CALL_OW 47
107820: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
107821: LD_OWVAR 42
107825: PUSH
107826: LD_INT 32
107828: PUSH
107829: LD_INT 33
107831: PUSH
107832: EMPTY
107833: LIST
107834: LIST
107835: IN
107836: IFFALSE 107852
// PlaceWeaponTurret ( b , weapon ) ;
107838: LD_VAR 0 8
107842: PPUSH
107843: LD_VAR 0 4
107847: PPUSH
107848: CALL_OW 431
// end ;
107852: LD_VAR 0 7
107856: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
107857: LD_INT 0
107859: PPUSH
107860: PPUSH
107861: PPUSH
107862: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107863: LD_ADDR_VAR 0 4
107867: PUSH
107868: LD_INT 22
107870: PUSH
107871: LD_OWVAR 2
107875: PUSH
107876: EMPTY
107877: LIST
107878: LIST
107879: PUSH
107880: LD_INT 2
107882: PUSH
107883: LD_INT 30
107885: PUSH
107886: LD_INT 0
107888: PUSH
107889: EMPTY
107890: LIST
107891: LIST
107892: PUSH
107893: LD_INT 30
107895: PUSH
107896: LD_INT 1
107898: PUSH
107899: EMPTY
107900: LIST
107901: LIST
107902: PUSH
107903: EMPTY
107904: LIST
107905: LIST
107906: LIST
107907: PUSH
107908: EMPTY
107909: LIST
107910: LIST
107911: PPUSH
107912: CALL_OW 69
107916: ST_TO_ADDR
// if not tmp then
107917: LD_VAR 0 4
107921: NOT
107922: IFFALSE 107926
// exit ;
107924: GO 107985
// for i in tmp do
107926: LD_ADDR_VAR 0 2
107930: PUSH
107931: LD_VAR 0 4
107935: PUSH
107936: FOR_IN
107937: IFFALSE 107983
// for j = 1 to 3 do
107939: LD_ADDR_VAR 0 3
107943: PUSH
107944: DOUBLE
107945: LD_INT 1
107947: DEC
107948: ST_TO_ADDR
107949: LD_INT 3
107951: PUSH
107952: FOR_TO
107953: IFFALSE 107979
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
107955: LD_VAR 0 2
107959: PPUSH
107960: CALL_OW 274
107964: PPUSH
107965: LD_VAR 0 3
107969: PPUSH
107970: LD_INT 99999
107972: PPUSH
107973: CALL_OW 277
107977: GO 107952
107979: POP
107980: POP
107981: GO 107936
107983: POP
107984: POP
// end ;
107985: LD_VAR 0 1
107989: RET
// export function hHackSetLevel10 ; var i , j ; begin
107990: LD_INT 0
107992: PPUSH
107993: PPUSH
107994: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107995: LD_ADDR_VAR 0 2
107999: PUSH
108000: LD_INT 21
108002: PUSH
108003: LD_INT 1
108005: PUSH
108006: EMPTY
108007: LIST
108008: LIST
108009: PPUSH
108010: CALL_OW 69
108014: PUSH
108015: FOR_IN
108016: IFFALSE 108068
// if IsSelected ( i ) then
108018: LD_VAR 0 2
108022: PPUSH
108023: CALL_OW 306
108027: IFFALSE 108066
// begin for j := 1 to 4 do
108029: LD_ADDR_VAR 0 3
108033: PUSH
108034: DOUBLE
108035: LD_INT 1
108037: DEC
108038: ST_TO_ADDR
108039: LD_INT 4
108041: PUSH
108042: FOR_TO
108043: IFFALSE 108064
// SetSkill ( i , j , 10 ) ;
108045: LD_VAR 0 2
108049: PPUSH
108050: LD_VAR 0 3
108054: PPUSH
108055: LD_INT 10
108057: PPUSH
108058: CALL_OW 237
108062: GO 108042
108064: POP
108065: POP
// end ;
108066: GO 108015
108068: POP
108069: POP
// end ;
108070: LD_VAR 0 1
108074: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108075: LD_INT 0
108077: PPUSH
108078: PPUSH
108079: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108080: LD_ADDR_VAR 0 2
108084: PUSH
108085: LD_INT 22
108087: PUSH
108088: LD_OWVAR 2
108092: PUSH
108093: EMPTY
108094: LIST
108095: LIST
108096: PUSH
108097: LD_INT 21
108099: PUSH
108100: LD_INT 1
108102: PUSH
108103: EMPTY
108104: LIST
108105: LIST
108106: PUSH
108107: EMPTY
108108: LIST
108109: LIST
108110: PPUSH
108111: CALL_OW 69
108115: PUSH
108116: FOR_IN
108117: IFFALSE 108158
// begin for j := 1 to 4 do
108119: LD_ADDR_VAR 0 3
108123: PUSH
108124: DOUBLE
108125: LD_INT 1
108127: DEC
108128: ST_TO_ADDR
108129: LD_INT 4
108131: PUSH
108132: FOR_TO
108133: IFFALSE 108154
// SetSkill ( i , j , 10 ) ;
108135: LD_VAR 0 2
108139: PPUSH
108140: LD_VAR 0 3
108144: PPUSH
108145: LD_INT 10
108147: PPUSH
108148: CALL_OW 237
108152: GO 108132
108154: POP
108155: POP
// end ;
108156: GO 108116
108158: POP
108159: POP
// end ;
108160: LD_VAR 0 1
108164: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108165: LD_INT 0
108167: PPUSH
// uc_side := your_side ;
108168: LD_ADDR_OWVAR 20
108172: PUSH
108173: LD_OWVAR 2
108177: ST_TO_ADDR
// uc_nation := nation ;
108178: LD_ADDR_OWVAR 21
108182: PUSH
108183: LD_VAR 0 1
108187: ST_TO_ADDR
// InitHc ;
108188: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108192: LD_INT 0
108194: PPUSH
108195: LD_VAR 0 2
108199: PPUSH
108200: LD_VAR 0 3
108204: PPUSH
108205: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108209: LD_VAR 0 4
108213: PPUSH
108214: LD_VAR 0 5
108218: PPUSH
108219: CALL_OW 428
108223: PUSH
108224: LD_INT 0
108226: EQUAL
108227: IFFALSE 108251
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108229: CALL_OW 44
108233: PPUSH
108234: LD_VAR 0 4
108238: PPUSH
108239: LD_VAR 0 5
108243: PPUSH
108244: LD_INT 1
108246: PPUSH
108247: CALL_OW 48
// end ;
108251: LD_VAR 0 6
108255: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108256: LD_INT 0
108258: PPUSH
108259: PPUSH
// uc_side := your_side ;
108260: LD_ADDR_OWVAR 20
108264: PUSH
108265: LD_OWVAR 2
108269: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108270: LD_VAR 0 1
108274: PUSH
108275: LD_INT 1
108277: PUSH
108278: LD_INT 2
108280: PUSH
108281: LD_INT 3
108283: PUSH
108284: LD_INT 4
108286: PUSH
108287: LD_INT 5
108289: PUSH
108290: EMPTY
108291: LIST
108292: LIST
108293: LIST
108294: LIST
108295: LIST
108296: IN
108297: IFFALSE 108309
// uc_nation := nation_american else
108299: LD_ADDR_OWVAR 21
108303: PUSH
108304: LD_INT 1
108306: ST_TO_ADDR
108307: GO 108352
// if chassis in [ 11 , 12 , 13 , 14 ] then
108309: LD_VAR 0 1
108313: PUSH
108314: LD_INT 11
108316: PUSH
108317: LD_INT 12
108319: PUSH
108320: LD_INT 13
108322: PUSH
108323: LD_INT 14
108325: PUSH
108326: EMPTY
108327: LIST
108328: LIST
108329: LIST
108330: LIST
108331: IN
108332: IFFALSE 108344
// uc_nation := nation_arabian else
108334: LD_ADDR_OWVAR 21
108338: PUSH
108339: LD_INT 2
108341: ST_TO_ADDR
108342: GO 108352
// uc_nation := nation_russian ;
108344: LD_ADDR_OWVAR 21
108348: PUSH
108349: LD_INT 3
108351: ST_TO_ADDR
// vc_chassis := chassis ;
108352: LD_ADDR_OWVAR 37
108356: PUSH
108357: LD_VAR 0 1
108361: ST_TO_ADDR
// vc_engine := engine ;
108362: LD_ADDR_OWVAR 39
108366: PUSH
108367: LD_VAR 0 2
108371: ST_TO_ADDR
// vc_control := control ;
108372: LD_ADDR_OWVAR 38
108376: PUSH
108377: LD_VAR 0 3
108381: ST_TO_ADDR
// vc_weapon := weapon ;
108382: LD_ADDR_OWVAR 40
108386: PUSH
108387: LD_VAR 0 4
108391: ST_TO_ADDR
// un := CreateVehicle ;
108392: LD_ADDR_VAR 0 8
108396: PUSH
108397: CALL_OW 45
108401: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108402: LD_VAR 0 8
108406: PPUSH
108407: LD_INT 0
108409: PPUSH
108410: LD_INT 5
108412: PPUSH
108413: CALL_OW 12
108417: PPUSH
108418: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108422: LD_VAR 0 8
108426: PPUSH
108427: LD_VAR 0 5
108431: PPUSH
108432: LD_VAR 0 6
108436: PPUSH
108437: LD_INT 1
108439: PPUSH
108440: CALL_OW 48
// end ;
108444: LD_VAR 0 7
108448: RET
// export hInvincible ; every 1 do
108449: GO 108451
108451: DISABLE
// hInvincible := [ ] ;
108452: LD_ADDR_EXP 181
108456: PUSH
108457: EMPTY
108458: ST_TO_ADDR
108459: END
// every 10 do var i ;
108460: GO 108462
108462: DISABLE
108463: LD_INT 0
108465: PPUSH
// begin enable ;
108466: ENABLE
// if not hInvincible then
108467: LD_EXP 181
108471: NOT
108472: IFFALSE 108476
// exit ;
108474: GO 108520
// for i in hInvincible do
108476: LD_ADDR_VAR 0 1
108480: PUSH
108481: LD_EXP 181
108485: PUSH
108486: FOR_IN
108487: IFFALSE 108518
// if GetLives ( i ) < 1000 then
108489: LD_VAR 0 1
108493: PPUSH
108494: CALL_OW 256
108498: PUSH
108499: LD_INT 1000
108501: LESS
108502: IFFALSE 108516
// SetLives ( i , 1000 ) ;
108504: LD_VAR 0 1
108508: PPUSH
108509: LD_INT 1000
108511: PPUSH
108512: CALL_OW 234
108516: GO 108486
108518: POP
108519: POP
// end ;
108520: PPOPN 1
108522: END
// export function hHackInvincible ; var i ; begin
108523: LD_INT 0
108525: PPUSH
108526: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108527: LD_ADDR_VAR 0 2
108531: PUSH
108532: LD_INT 2
108534: PUSH
108535: LD_INT 21
108537: PUSH
108538: LD_INT 1
108540: PUSH
108541: EMPTY
108542: LIST
108543: LIST
108544: PUSH
108545: LD_INT 21
108547: PUSH
108548: LD_INT 2
108550: PUSH
108551: EMPTY
108552: LIST
108553: LIST
108554: PUSH
108555: EMPTY
108556: LIST
108557: LIST
108558: LIST
108559: PPUSH
108560: CALL_OW 69
108564: PUSH
108565: FOR_IN
108566: IFFALSE 108627
// if IsSelected ( i ) then
108568: LD_VAR 0 2
108572: PPUSH
108573: CALL_OW 306
108577: IFFALSE 108625
// begin if i in hInvincible then
108579: LD_VAR 0 2
108583: PUSH
108584: LD_EXP 181
108588: IN
108589: IFFALSE 108609
// hInvincible := hInvincible diff i else
108591: LD_ADDR_EXP 181
108595: PUSH
108596: LD_EXP 181
108600: PUSH
108601: LD_VAR 0 2
108605: DIFF
108606: ST_TO_ADDR
108607: GO 108625
// hInvincible := hInvincible union i ;
108609: LD_ADDR_EXP 181
108613: PUSH
108614: LD_EXP 181
108618: PUSH
108619: LD_VAR 0 2
108623: UNION
108624: ST_TO_ADDR
// end ;
108625: GO 108565
108627: POP
108628: POP
// end ;
108629: LD_VAR 0 1
108633: RET
// export function hHackInvisible ; var i , j ; begin
108634: LD_INT 0
108636: PPUSH
108637: PPUSH
108638: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108639: LD_ADDR_VAR 0 2
108643: PUSH
108644: LD_INT 21
108646: PUSH
108647: LD_INT 1
108649: PUSH
108650: EMPTY
108651: LIST
108652: LIST
108653: PPUSH
108654: CALL_OW 69
108658: PUSH
108659: FOR_IN
108660: IFFALSE 108684
// if IsSelected ( i ) then
108662: LD_VAR 0 2
108666: PPUSH
108667: CALL_OW 306
108671: IFFALSE 108682
// ComForceInvisible ( i ) ;
108673: LD_VAR 0 2
108677: PPUSH
108678: CALL_OW 496
108682: GO 108659
108684: POP
108685: POP
// end ;
108686: LD_VAR 0 1
108690: RET
// export function hHackChangeYourSide ; begin
108691: LD_INT 0
108693: PPUSH
// if your_side = 8 then
108694: LD_OWVAR 2
108698: PUSH
108699: LD_INT 8
108701: EQUAL
108702: IFFALSE 108714
// your_side := 0 else
108704: LD_ADDR_OWVAR 2
108708: PUSH
108709: LD_INT 0
108711: ST_TO_ADDR
108712: GO 108728
// your_side := your_side + 1 ;
108714: LD_ADDR_OWVAR 2
108718: PUSH
108719: LD_OWVAR 2
108723: PUSH
108724: LD_INT 1
108726: PLUS
108727: ST_TO_ADDR
// end ;
108728: LD_VAR 0 1
108732: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108733: LD_INT 0
108735: PPUSH
108736: PPUSH
108737: PPUSH
// for i in all_units do
108738: LD_ADDR_VAR 0 2
108742: PUSH
108743: LD_OWVAR 3
108747: PUSH
108748: FOR_IN
108749: IFFALSE 108827
// if IsSelected ( i ) then
108751: LD_VAR 0 2
108755: PPUSH
108756: CALL_OW 306
108760: IFFALSE 108825
// begin j := GetSide ( i ) ;
108762: LD_ADDR_VAR 0 3
108766: PUSH
108767: LD_VAR 0 2
108771: PPUSH
108772: CALL_OW 255
108776: ST_TO_ADDR
// if j = 8 then
108777: LD_VAR 0 3
108781: PUSH
108782: LD_INT 8
108784: EQUAL
108785: IFFALSE 108797
// j := 0 else
108787: LD_ADDR_VAR 0 3
108791: PUSH
108792: LD_INT 0
108794: ST_TO_ADDR
108795: GO 108811
// j := j + 1 ;
108797: LD_ADDR_VAR 0 3
108801: PUSH
108802: LD_VAR 0 3
108806: PUSH
108807: LD_INT 1
108809: PLUS
108810: ST_TO_ADDR
// SetSide ( i , j ) ;
108811: LD_VAR 0 2
108815: PPUSH
108816: LD_VAR 0 3
108820: PPUSH
108821: CALL_OW 235
// end ;
108825: GO 108748
108827: POP
108828: POP
// end ;
108829: LD_VAR 0 1
108833: RET
// export function hHackFog ; begin
108834: LD_INT 0
108836: PPUSH
// FogOff ( true ) ;
108837: LD_INT 1
108839: PPUSH
108840: CALL_OW 344
// end ;
108844: LD_VAR 0 1
108848: RET
// export function hHackTeleport ( unit , x , y ) ; begin
108849: LD_INT 0
108851: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
108852: LD_VAR 0 1
108856: PPUSH
108857: LD_VAR 0 2
108861: PPUSH
108862: LD_VAR 0 3
108866: PPUSH
108867: LD_INT 1
108869: PPUSH
108870: LD_INT 1
108872: PPUSH
108873: CALL_OW 483
// CenterOnXY ( x , y ) ;
108877: LD_VAR 0 2
108881: PPUSH
108882: LD_VAR 0 3
108886: PPUSH
108887: CALL_OW 84
// end ;
108891: LD_VAR 0 4
108895: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
108896: LD_INT 0
108898: PPUSH
108899: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
108900: LD_VAR 0 1
108904: NOT
108905: PUSH
108906: LD_VAR 0 2
108910: PPUSH
108911: LD_VAR 0 3
108915: PPUSH
108916: CALL_OW 488
108920: NOT
108921: OR
108922: PUSH
108923: LD_VAR 0 1
108927: PPUSH
108928: CALL_OW 266
108932: PUSH
108933: LD_INT 3
108935: NONEQUAL
108936: PUSH
108937: LD_VAR 0 1
108941: PPUSH
108942: CALL_OW 247
108946: PUSH
108947: LD_INT 1
108949: EQUAL
108950: NOT
108951: AND
108952: OR
108953: IFFALSE 108957
// exit ;
108955: GO 109106
// if GetType ( factory ) = unit_human then
108957: LD_VAR 0 1
108961: PPUSH
108962: CALL_OW 247
108966: PUSH
108967: LD_INT 1
108969: EQUAL
108970: IFFALSE 108987
// factory := IsInUnit ( factory ) ;
108972: LD_ADDR_VAR 0 1
108976: PUSH
108977: LD_VAR 0 1
108981: PPUSH
108982: CALL_OW 310
108986: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
108987: LD_VAR 0 1
108991: PPUSH
108992: CALL_OW 266
108996: PUSH
108997: LD_INT 3
108999: NONEQUAL
109000: IFFALSE 109004
// exit ;
109002: GO 109106
// if HexInfo ( x , y ) = factory then
109004: LD_VAR 0 2
109008: PPUSH
109009: LD_VAR 0 3
109013: PPUSH
109014: CALL_OW 428
109018: PUSH
109019: LD_VAR 0 1
109023: EQUAL
109024: IFFALSE 109051
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109026: LD_ADDR_EXP 182
109030: PUSH
109031: LD_EXP 182
109035: PPUSH
109036: LD_VAR 0 1
109040: PPUSH
109041: LD_INT 0
109043: PPUSH
109044: CALL_OW 1
109048: ST_TO_ADDR
109049: GO 109102
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109051: LD_ADDR_EXP 182
109055: PUSH
109056: LD_EXP 182
109060: PPUSH
109061: LD_VAR 0 1
109065: PPUSH
109066: LD_VAR 0 1
109070: PPUSH
109071: CALL_OW 255
109075: PUSH
109076: LD_VAR 0 1
109080: PUSH
109081: LD_VAR 0 2
109085: PUSH
109086: LD_VAR 0 3
109090: PUSH
109091: EMPTY
109092: LIST
109093: LIST
109094: LIST
109095: LIST
109096: PPUSH
109097: CALL_OW 1
109101: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109102: CALL 109111 0 0
// end ;
109106: LD_VAR 0 4
109110: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109111: LD_INT 0
109113: PPUSH
109114: PPUSH
109115: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109116: LD_STRING resetFactoryWaypoint();
109118: PPUSH
109119: CALL_OW 559
// if factoryWaypoints then
109123: LD_EXP 182
109127: IFFALSE 109253
// begin list := PrepareArray ( factoryWaypoints ) ;
109129: LD_ADDR_VAR 0 3
109133: PUSH
109134: LD_EXP 182
109138: PPUSH
109139: CALL 93941 0 1
109143: ST_TO_ADDR
// for i := 1 to list do
109144: LD_ADDR_VAR 0 2
109148: PUSH
109149: DOUBLE
109150: LD_INT 1
109152: DEC
109153: ST_TO_ADDR
109154: LD_VAR 0 3
109158: PUSH
109159: FOR_TO
109160: IFFALSE 109251
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109162: LD_STRING setFactoryWaypointXY(
109164: PUSH
109165: LD_VAR 0 3
109169: PUSH
109170: LD_VAR 0 2
109174: ARRAY
109175: PUSH
109176: LD_INT 1
109178: ARRAY
109179: STR
109180: PUSH
109181: LD_STRING ,
109183: STR
109184: PUSH
109185: LD_VAR 0 3
109189: PUSH
109190: LD_VAR 0 2
109194: ARRAY
109195: PUSH
109196: LD_INT 2
109198: ARRAY
109199: STR
109200: PUSH
109201: LD_STRING ,
109203: STR
109204: PUSH
109205: LD_VAR 0 3
109209: PUSH
109210: LD_VAR 0 2
109214: ARRAY
109215: PUSH
109216: LD_INT 3
109218: ARRAY
109219: STR
109220: PUSH
109221: LD_STRING ,
109223: STR
109224: PUSH
109225: LD_VAR 0 3
109229: PUSH
109230: LD_VAR 0 2
109234: ARRAY
109235: PUSH
109236: LD_INT 4
109238: ARRAY
109239: STR
109240: PUSH
109241: LD_STRING )
109243: STR
109244: PPUSH
109245: CALL_OW 559
109249: GO 109159
109251: POP
109252: POP
// end ; end ;
109253: LD_VAR 0 1
109257: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109258: LD_INT 0
109260: PPUSH
// if HexInfo ( x , y ) = warehouse then
109261: LD_VAR 0 2
109265: PPUSH
109266: LD_VAR 0 3
109270: PPUSH
109271: CALL_OW 428
109275: PUSH
109276: LD_VAR 0 1
109280: EQUAL
109281: IFFALSE 109308
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109283: LD_ADDR_EXP 183
109287: PUSH
109288: LD_EXP 183
109292: PPUSH
109293: LD_VAR 0 1
109297: PPUSH
109298: LD_INT 0
109300: PPUSH
109301: CALL_OW 1
109305: ST_TO_ADDR
109306: GO 109359
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109308: LD_ADDR_EXP 183
109312: PUSH
109313: LD_EXP 183
109317: PPUSH
109318: LD_VAR 0 1
109322: PPUSH
109323: LD_VAR 0 1
109327: PPUSH
109328: CALL_OW 255
109332: PUSH
109333: LD_VAR 0 1
109337: PUSH
109338: LD_VAR 0 2
109342: PUSH
109343: LD_VAR 0 3
109347: PUSH
109348: EMPTY
109349: LIST
109350: LIST
109351: LIST
109352: LIST
109353: PPUSH
109354: CALL_OW 1
109358: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109359: CALL 109368 0 0
// end ;
109363: LD_VAR 0 4
109367: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109368: LD_INT 0
109370: PPUSH
109371: PPUSH
109372: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109373: LD_STRING resetWarehouseGatheringPoints();
109375: PPUSH
109376: CALL_OW 559
// if warehouseGatheringPoints then
109380: LD_EXP 183
109384: IFFALSE 109510
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109386: LD_ADDR_VAR 0 3
109390: PUSH
109391: LD_EXP 183
109395: PPUSH
109396: CALL 93941 0 1
109400: ST_TO_ADDR
// for i := 1 to list do
109401: LD_ADDR_VAR 0 2
109405: PUSH
109406: DOUBLE
109407: LD_INT 1
109409: DEC
109410: ST_TO_ADDR
109411: LD_VAR 0 3
109415: PUSH
109416: FOR_TO
109417: IFFALSE 109508
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109419: LD_STRING setWarehouseGatheringPointXY(
109421: PUSH
109422: LD_VAR 0 3
109426: PUSH
109427: LD_VAR 0 2
109431: ARRAY
109432: PUSH
109433: LD_INT 1
109435: ARRAY
109436: STR
109437: PUSH
109438: LD_STRING ,
109440: STR
109441: PUSH
109442: LD_VAR 0 3
109446: PUSH
109447: LD_VAR 0 2
109451: ARRAY
109452: PUSH
109453: LD_INT 2
109455: ARRAY
109456: STR
109457: PUSH
109458: LD_STRING ,
109460: STR
109461: PUSH
109462: LD_VAR 0 3
109466: PUSH
109467: LD_VAR 0 2
109471: ARRAY
109472: PUSH
109473: LD_INT 3
109475: ARRAY
109476: STR
109477: PUSH
109478: LD_STRING ,
109480: STR
109481: PUSH
109482: LD_VAR 0 3
109486: PUSH
109487: LD_VAR 0 2
109491: ARRAY
109492: PUSH
109493: LD_INT 4
109495: ARRAY
109496: STR
109497: PUSH
109498: LD_STRING )
109500: STR
109501: PPUSH
109502: CALL_OW 559
109506: GO 109416
109508: POP
109509: POP
// end ; end ;
109510: LD_VAR 0 1
109514: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109515: LD_EXP 183
109519: IFFALSE 110204
109521: GO 109523
109523: DISABLE
109524: LD_INT 0
109526: PPUSH
109527: PPUSH
109528: PPUSH
109529: PPUSH
109530: PPUSH
109531: PPUSH
109532: PPUSH
109533: PPUSH
109534: PPUSH
// begin enable ;
109535: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109536: LD_ADDR_VAR 0 3
109540: PUSH
109541: LD_EXP 183
109545: PPUSH
109546: CALL 93941 0 1
109550: ST_TO_ADDR
// if not list then
109551: LD_VAR 0 3
109555: NOT
109556: IFFALSE 109560
// exit ;
109558: GO 110204
// for i := 1 to list do
109560: LD_ADDR_VAR 0 1
109564: PUSH
109565: DOUBLE
109566: LD_INT 1
109568: DEC
109569: ST_TO_ADDR
109570: LD_VAR 0 3
109574: PUSH
109575: FOR_TO
109576: IFFALSE 110202
// begin depot := list [ i ] [ 2 ] ;
109578: LD_ADDR_VAR 0 8
109582: PUSH
109583: LD_VAR 0 3
109587: PUSH
109588: LD_VAR 0 1
109592: ARRAY
109593: PUSH
109594: LD_INT 2
109596: ARRAY
109597: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109598: LD_ADDR_VAR 0 5
109602: PUSH
109603: LD_VAR 0 3
109607: PUSH
109608: LD_VAR 0 1
109612: ARRAY
109613: PUSH
109614: LD_INT 1
109616: ARRAY
109617: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
109618: LD_VAR 0 8
109622: PPUSH
109623: CALL_OW 301
109627: PUSH
109628: LD_VAR 0 5
109632: PUSH
109633: LD_VAR 0 8
109637: PPUSH
109638: CALL_OW 255
109642: NONEQUAL
109643: OR
109644: IFFALSE 109673
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
109646: LD_ADDR_EXP 183
109650: PUSH
109651: LD_EXP 183
109655: PPUSH
109656: LD_VAR 0 8
109660: PPUSH
109661: LD_INT 0
109663: PPUSH
109664: CALL_OW 1
109668: ST_TO_ADDR
// exit ;
109669: POP
109670: POP
109671: GO 110204
// end ; x := list [ i ] [ 3 ] ;
109673: LD_ADDR_VAR 0 6
109677: PUSH
109678: LD_VAR 0 3
109682: PUSH
109683: LD_VAR 0 1
109687: ARRAY
109688: PUSH
109689: LD_INT 3
109691: ARRAY
109692: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
109693: LD_ADDR_VAR 0 7
109697: PUSH
109698: LD_VAR 0 3
109702: PUSH
109703: LD_VAR 0 1
109707: ARRAY
109708: PUSH
109709: LD_INT 4
109711: ARRAY
109712: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109713: LD_ADDR_VAR 0 9
109717: PUSH
109718: LD_VAR 0 6
109722: PPUSH
109723: LD_VAR 0 7
109727: PPUSH
109728: LD_INT 16
109730: PPUSH
109731: CALL 92529 0 3
109735: ST_TO_ADDR
// if not cratesNearbyPoint then
109736: LD_VAR 0 9
109740: NOT
109741: IFFALSE 109747
// exit ;
109743: POP
109744: POP
109745: GO 110204
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109747: LD_ADDR_VAR 0 4
109751: PUSH
109752: LD_INT 22
109754: PUSH
109755: LD_VAR 0 5
109759: PUSH
109760: EMPTY
109761: LIST
109762: LIST
109763: PUSH
109764: LD_INT 3
109766: PUSH
109767: LD_INT 60
109769: PUSH
109770: EMPTY
109771: LIST
109772: PUSH
109773: EMPTY
109774: LIST
109775: LIST
109776: PUSH
109777: LD_INT 91
109779: PUSH
109780: LD_VAR 0 8
109784: PUSH
109785: LD_INT 6
109787: PUSH
109788: EMPTY
109789: LIST
109790: LIST
109791: LIST
109792: PUSH
109793: LD_INT 2
109795: PUSH
109796: LD_INT 25
109798: PUSH
109799: LD_INT 2
109801: PUSH
109802: EMPTY
109803: LIST
109804: LIST
109805: PUSH
109806: LD_INT 25
109808: PUSH
109809: LD_INT 16
109811: PUSH
109812: EMPTY
109813: LIST
109814: LIST
109815: PUSH
109816: EMPTY
109817: LIST
109818: LIST
109819: LIST
109820: PUSH
109821: EMPTY
109822: LIST
109823: LIST
109824: LIST
109825: LIST
109826: PPUSH
109827: CALL_OW 69
109831: PUSH
109832: LD_VAR 0 8
109836: PPUSH
109837: CALL_OW 313
109841: PPUSH
109842: LD_INT 3
109844: PUSH
109845: LD_INT 60
109847: PUSH
109848: EMPTY
109849: LIST
109850: PUSH
109851: EMPTY
109852: LIST
109853: LIST
109854: PUSH
109855: LD_INT 2
109857: PUSH
109858: LD_INT 25
109860: PUSH
109861: LD_INT 2
109863: PUSH
109864: EMPTY
109865: LIST
109866: LIST
109867: PUSH
109868: LD_INT 25
109870: PUSH
109871: LD_INT 16
109873: PUSH
109874: EMPTY
109875: LIST
109876: LIST
109877: PUSH
109878: EMPTY
109879: LIST
109880: LIST
109881: LIST
109882: PUSH
109883: EMPTY
109884: LIST
109885: LIST
109886: PPUSH
109887: CALL_OW 72
109891: UNION
109892: ST_TO_ADDR
// if tmp then
109893: LD_VAR 0 4
109897: IFFALSE 109977
// begin tmp := ShrinkArray ( tmp , 3 ) ;
109899: LD_ADDR_VAR 0 4
109903: PUSH
109904: LD_VAR 0 4
109908: PPUSH
109909: LD_INT 3
109911: PPUSH
109912: CALL 90498 0 2
109916: ST_TO_ADDR
// for j in tmp do
109917: LD_ADDR_VAR 0 2
109921: PUSH
109922: LD_VAR 0 4
109926: PUSH
109927: FOR_IN
109928: IFFALSE 109971
// begin if IsInUnit ( j ) then
109930: LD_VAR 0 2
109934: PPUSH
109935: CALL_OW 310
109939: IFFALSE 109950
// ComExit ( j ) ;
109941: LD_VAR 0 2
109945: PPUSH
109946: CALL 90581 0 1
// AddComCollect ( j , x , y ) ;
109950: LD_VAR 0 2
109954: PPUSH
109955: LD_VAR 0 6
109959: PPUSH
109960: LD_VAR 0 7
109964: PPUSH
109965: CALL_OW 177
// end ;
109969: GO 109927
109971: POP
109972: POP
// exit ;
109973: POP
109974: POP
109975: GO 110204
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
109977: LD_ADDR_VAR 0 4
109981: PUSH
109982: LD_INT 22
109984: PUSH
109985: LD_VAR 0 5
109989: PUSH
109990: EMPTY
109991: LIST
109992: LIST
109993: PUSH
109994: LD_INT 91
109996: PUSH
109997: LD_VAR 0 8
110001: PUSH
110002: LD_INT 8
110004: PUSH
110005: EMPTY
110006: LIST
110007: LIST
110008: LIST
110009: PUSH
110010: LD_INT 2
110012: PUSH
110013: LD_INT 34
110015: PUSH
110016: LD_INT 12
110018: PUSH
110019: EMPTY
110020: LIST
110021: LIST
110022: PUSH
110023: LD_INT 34
110025: PUSH
110026: LD_INT 51
110028: PUSH
110029: EMPTY
110030: LIST
110031: LIST
110032: PUSH
110033: LD_INT 34
110035: PUSH
110036: LD_INT 32
110038: PUSH
110039: EMPTY
110040: LIST
110041: LIST
110042: PUSH
110043: LD_INT 34
110045: PUSH
110046: LD_INT 89
110048: PUSH
110049: EMPTY
110050: LIST
110051: LIST
110052: PUSH
110053: EMPTY
110054: LIST
110055: LIST
110056: LIST
110057: LIST
110058: LIST
110059: PUSH
110060: EMPTY
110061: LIST
110062: LIST
110063: LIST
110064: PPUSH
110065: CALL_OW 69
110069: ST_TO_ADDR
// if tmp then
110070: LD_VAR 0 4
110074: IFFALSE 110200
// begin for j in tmp do
110076: LD_ADDR_VAR 0 2
110080: PUSH
110081: LD_VAR 0 4
110085: PUSH
110086: FOR_IN
110087: IFFALSE 110198
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110089: LD_VAR 0 2
110093: PPUSH
110094: CALL_OW 262
110098: PUSH
110099: LD_INT 3
110101: EQUAL
110102: PUSH
110103: LD_VAR 0 2
110107: PPUSH
110108: CALL_OW 261
110112: PUSH
110113: LD_INT 20
110115: GREATER
110116: OR
110117: PUSH
110118: LD_VAR 0 2
110122: PPUSH
110123: CALL_OW 314
110127: NOT
110128: AND
110129: PUSH
110130: LD_VAR 0 2
110134: PPUSH
110135: CALL_OW 263
110139: PUSH
110140: LD_INT 1
110142: NONEQUAL
110143: PUSH
110144: LD_VAR 0 2
110148: PPUSH
110149: CALL_OW 311
110153: OR
110154: AND
110155: IFFALSE 110196
// begin ComCollect ( j , x , y ) ;
110157: LD_VAR 0 2
110161: PPUSH
110162: LD_VAR 0 6
110166: PPUSH
110167: LD_VAR 0 7
110171: PPUSH
110172: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110176: LD_VAR 0 2
110180: PPUSH
110181: LD_VAR 0 8
110185: PPUSH
110186: CALL_OW 172
// exit ;
110190: POP
110191: POP
110192: POP
110193: POP
110194: GO 110204
// end ;
110196: GO 110086
110198: POP
110199: POP
// end ; end ;
110200: GO 109575
110202: POP
110203: POP
// end ; end_of_file
110204: PPOPN 9
110206: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
110207: LD_INT 0
110209: PPUSH
110210: PPUSH
110211: PPUSH
110212: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
110213: LD_VAR 0 1
110217: PPUSH
110218: CALL_OW 264
110222: PUSH
110223: LD_INT 91
110225: EQUAL
110226: IFFALSE 110298
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
110228: LD_INT 68
110230: PPUSH
110231: LD_VAR 0 1
110235: PPUSH
110236: CALL_OW 255
110240: PPUSH
110241: CALL_OW 321
110245: PUSH
110246: LD_INT 2
110248: EQUAL
110249: IFFALSE 110261
// eff := 70 else
110251: LD_ADDR_VAR 0 4
110255: PUSH
110256: LD_INT 70
110258: ST_TO_ADDR
110259: GO 110269
// eff := 30 ;
110261: LD_ADDR_VAR 0 4
110265: PUSH
110266: LD_INT 30
110268: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
110269: LD_VAR 0 1
110273: PPUSH
110274: CALL_OW 250
110278: PPUSH
110279: LD_VAR 0 1
110283: PPUSH
110284: CALL_OW 251
110288: PPUSH
110289: LD_VAR 0 4
110293: PPUSH
110294: CALL_OW 495
// end ; end ;
110298: LD_VAR 0 2
110302: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
110303: LD_INT 0
110305: PPUSH
// end ;
110306: LD_VAR 0 4
110310: RET
// export function SOS_Command ( cmd ) ; begin
110311: LD_INT 0
110313: PPUSH
// end ;
110314: LD_VAR 0 2
110318: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
110319: LD_INT 0
110321: PPUSH
// end ;
110322: LD_VAR 0 6
110326: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
110327: LD_INT 0
110329: PPUSH
110330: PPUSH
// if not vehicle or not factory then
110331: LD_VAR 0 1
110335: NOT
110336: PUSH
110337: LD_VAR 0 2
110341: NOT
110342: OR
110343: IFFALSE 110347
// exit ;
110345: GO 110578
// if factoryWaypoints >= factory then
110347: LD_EXP 182
110351: PUSH
110352: LD_VAR 0 2
110356: GREATEREQUAL
110357: IFFALSE 110578
// if factoryWaypoints [ factory ] then
110359: LD_EXP 182
110363: PUSH
110364: LD_VAR 0 2
110368: ARRAY
110369: IFFALSE 110578
// begin if GetControl ( vehicle ) = control_manual then
110371: LD_VAR 0 1
110375: PPUSH
110376: CALL_OW 263
110380: PUSH
110381: LD_INT 1
110383: EQUAL
110384: IFFALSE 110465
// begin driver := IsDrivenBy ( vehicle ) ;
110386: LD_ADDR_VAR 0 4
110390: PUSH
110391: LD_VAR 0 1
110395: PPUSH
110396: CALL_OW 311
110400: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110401: LD_VAR 0 4
110405: PPUSH
110406: LD_EXP 182
110410: PUSH
110411: LD_VAR 0 2
110415: ARRAY
110416: PUSH
110417: LD_INT 3
110419: ARRAY
110420: PPUSH
110421: LD_EXP 182
110425: PUSH
110426: LD_VAR 0 2
110430: ARRAY
110431: PUSH
110432: LD_INT 4
110434: ARRAY
110435: PPUSH
110436: CALL_OW 171
// AddComExitVehicle ( driver ) ;
110440: LD_VAR 0 4
110444: PPUSH
110445: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
110449: LD_VAR 0 4
110453: PPUSH
110454: LD_VAR 0 2
110458: PPUSH
110459: CALL_OW 180
// end else
110463: GO 110578
// if GetControl ( vehicle ) = control_remote then
110465: LD_VAR 0 1
110469: PPUSH
110470: CALL_OW 263
110474: PUSH
110475: LD_INT 2
110477: EQUAL
110478: IFFALSE 110539
// begin wait ( 0 0$2 ) ;
110480: LD_INT 70
110482: PPUSH
110483: CALL_OW 67
// if Connect ( vehicle ) then
110487: LD_VAR 0 1
110491: PPUSH
110492: CALL 60802 0 1
110496: IFFALSE 110537
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110498: LD_VAR 0 1
110502: PPUSH
110503: LD_EXP 182
110507: PUSH
110508: LD_VAR 0 2
110512: ARRAY
110513: PUSH
110514: LD_INT 3
110516: ARRAY
110517: PPUSH
110518: LD_EXP 182
110522: PUSH
110523: LD_VAR 0 2
110527: ARRAY
110528: PUSH
110529: LD_INT 4
110531: ARRAY
110532: PPUSH
110533: CALL_OW 171
// end else
110537: GO 110578
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
110539: LD_VAR 0 1
110543: PPUSH
110544: LD_EXP 182
110548: PUSH
110549: LD_VAR 0 2
110553: ARRAY
110554: PUSH
110555: LD_INT 3
110557: ARRAY
110558: PPUSH
110559: LD_EXP 182
110563: PUSH
110564: LD_VAR 0 2
110568: ARRAY
110569: PUSH
110570: LD_INT 4
110572: ARRAY
110573: PPUSH
110574: CALL_OW 171
// end ; end ;
110578: LD_VAR 0 3
110582: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
110583: LD_INT 0
110585: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
110586: LD_VAR 0 1
110590: PUSH
110591: LD_INT 250
110593: EQUAL
110594: PUSH
110595: LD_VAR 0 2
110599: PPUSH
110600: CALL_OW 264
110604: PUSH
110605: LD_INT 81
110607: EQUAL
110608: AND
110609: IFFALSE 110630
// MinerPlaceMine ( unit , x , y ) ;
110611: LD_VAR 0 2
110615: PPUSH
110616: LD_VAR 0 4
110620: PPUSH
110621: LD_VAR 0 5
110625: PPUSH
110626: CALL 113015 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
110630: LD_VAR 0 1
110634: PUSH
110635: LD_INT 251
110637: EQUAL
110638: PUSH
110639: LD_VAR 0 2
110643: PPUSH
110644: CALL_OW 264
110648: PUSH
110649: LD_INT 81
110651: EQUAL
110652: AND
110653: IFFALSE 110674
// MinerDetonateMine ( unit , x , y ) ;
110655: LD_VAR 0 2
110659: PPUSH
110660: LD_VAR 0 4
110664: PPUSH
110665: LD_VAR 0 5
110669: PPUSH
110670: CALL 113290 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
110674: LD_VAR 0 1
110678: PUSH
110679: LD_INT 252
110681: EQUAL
110682: PUSH
110683: LD_VAR 0 2
110687: PPUSH
110688: CALL_OW 264
110692: PUSH
110693: LD_INT 81
110695: EQUAL
110696: AND
110697: IFFALSE 110718
// MinerCreateMinefield ( unit , x , y ) ;
110699: LD_VAR 0 2
110703: PPUSH
110704: LD_VAR 0 4
110708: PPUSH
110709: LD_VAR 0 5
110713: PPUSH
110714: CALL 113707 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
110718: LD_VAR 0 1
110722: PUSH
110723: LD_INT 253
110725: EQUAL
110726: PUSH
110727: LD_VAR 0 2
110731: PPUSH
110732: CALL_OW 257
110736: PUSH
110737: LD_INT 5
110739: EQUAL
110740: AND
110741: IFFALSE 110762
// ComBinocular ( unit , x , y ) ;
110743: LD_VAR 0 2
110747: PPUSH
110748: LD_VAR 0 4
110752: PPUSH
110753: LD_VAR 0 5
110757: PPUSH
110758: CALL 114076 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
110762: LD_VAR 0 1
110766: PUSH
110767: LD_INT 254
110769: EQUAL
110770: PUSH
110771: LD_VAR 0 2
110775: PPUSH
110776: CALL_OW 264
110780: PUSH
110781: LD_INT 99
110783: EQUAL
110784: AND
110785: PUSH
110786: LD_VAR 0 3
110790: PPUSH
110791: CALL_OW 263
110795: PUSH
110796: LD_INT 3
110798: EQUAL
110799: AND
110800: IFFALSE 110816
// HackDestroyVehicle ( unit , selectedUnit ) ;
110802: LD_VAR 0 2
110806: PPUSH
110807: LD_VAR 0 3
110811: PPUSH
110812: CALL 112379 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
110816: LD_VAR 0 1
110820: PUSH
110821: LD_INT 255
110823: EQUAL
110824: PUSH
110825: LD_VAR 0 2
110829: PPUSH
110830: CALL_OW 264
110834: PUSH
110835: LD_INT 14
110837: PUSH
110838: LD_INT 53
110840: PUSH
110841: EMPTY
110842: LIST
110843: LIST
110844: IN
110845: AND
110846: PUSH
110847: LD_VAR 0 4
110851: PPUSH
110852: LD_VAR 0 5
110856: PPUSH
110857: CALL_OW 488
110861: AND
110862: IFFALSE 110886
// CutTreeXYR ( unit , x , y , 12 ) ;
110864: LD_VAR 0 2
110868: PPUSH
110869: LD_VAR 0 4
110873: PPUSH
110874: LD_VAR 0 5
110878: PPUSH
110879: LD_INT 12
110881: PPUSH
110882: CALL 110949 0 4
// if cmd = 256 then
110886: LD_VAR 0 1
110890: PUSH
110891: LD_INT 256
110893: EQUAL
110894: IFFALSE 110915
// SetFactoryWaypoint ( unit , x , y ) ;
110896: LD_VAR 0 2
110900: PPUSH
110901: LD_VAR 0 4
110905: PPUSH
110906: LD_VAR 0 5
110910: PPUSH
110911: CALL 108896 0 3
// if cmd = 257 then
110915: LD_VAR 0 1
110919: PUSH
110920: LD_INT 257
110922: EQUAL
110923: IFFALSE 110944
// SetWarehouseGatheringPoint ( unit , x , y ) ;
110925: LD_VAR 0 2
110929: PPUSH
110930: LD_VAR 0 4
110934: PPUSH
110935: LD_VAR 0 5
110939: PPUSH
110940: CALL 109258 0 3
// end ;
110944: LD_VAR 0 6
110948: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
110949: LD_INT 0
110951: PPUSH
110952: PPUSH
110953: PPUSH
110954: PPUSH
110955: PPUSH
110956: PPUSH
110957: PPUSH
110958: PPUSH
110959: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
110960: LD_VAR 0 1
110964: NOT
110965: PUSH
110966: LD_VAR 0 2
110970: PPUSH
110971: LD_VAR 0 3
110975: PPUSH
110976: CALL_OW 488
110980: NOT
110981: OR
110982: PUSH
110983: LD_VAR 0 4
110987: NOT
110988: OR
110989: IFFALSE 110993
// exit ;
110991: GO 111333
// list := [ ] ;
110993: LD_ADDR_VAR 0 13
110997: PUSH
110998: EMPTY
110999: ST_TO_ADDR
// if x - r < 0 then
111000: LD_VAR 0 2
111004: PUSH
111005: LD_VAR 0 4
111009: MINUS
111010: PUSH
111011: LD_INT 0
111013: LESS
111014: IFFALSE 111026
// min_x := 0 else
111016: LD_ADDR_VAR 0 7
111020: PUSH
111021: LD_INT 0
111023: ST_TO_ADDR
111024: GO 111042
// min_x := x - r ;
111026: LD_ADDR_VAR 0 7
111030: PUSH
111031: LD_VAR 0 2
111035: PUSH
111036: LD_VAR 0 4
111040: MINUS
111041: ST_TO_ADDR
// if y - r < 0 then
111042: LD_VAR 0 3
111046: PUSH
111047: LD_VAR 0 4
111051: MINUS
111052: PUSH
111053: LD_INT 0
111055: LESS
111056: IFFALSE 111068
// min_y := 0 else
111058: LD_ADDR_VAR 0 8
111062: PUSH
111063: LD_INT 0
111065: ST_TO_ADDR
111066: GO 111084
// min_y := y - r ;
111068: LD_ADDR_VAR 0 8
111072: PUSH
111073: LD_VAR 0 3
111077: PUSH
111078: LD_VAR 0 4
111082: MINUS
111083: ST_TO_ADDR
// max_x := x + r ;
111084: LD_ADDR_VAR 0 9
111088: PUSH
111089: LD_VAR 0 2
111093: PUSH
111094: LD_VAR 0 4
111098: PLUS
111099: ST_TO_ADDR
// max_y := y + r ;
111100: LD_ADDR_VAR 0 10
111104: PUSH
111105: LD_VAR 0 3
111109: PUSH
111110: LD_VAR 0 4
111114: PLUS
111115: ST_TO_ADDR
// for _x = min_x to max_x do
111116: LD_ADDR_VAR 0 11
111120: PUSH
111121: DOUBLE
111122: LD_VAR 0 7
111126: DEC
111127: ST_TO_ADDR
111128: LD_VAR 0 9
111132: PUSH
111133: FOR_TO
111134: IFFALSE 111251
// for _y = min_y to max_y do
111136: LD_ADDR_VAR 0 12
111140: PUSH
111141: DOUBLE
111142: LD_VAR 0 8
111146: DEC
111147: ST_TO_ADDR
111148: LD_VAR 0 10
111152: PUSH
111153: FOR_TO
111154: IFFALSE 111247
// begin if not ValidHex ( _x , _y ) then
111156: LD_VAR 0 11
111160: PPUSH
111161: LD_VAR 0 12
111165: PPUSH
111166: CALL_OW 488
111170: NOT
111171: IFFALSE 111175
// continue ;
111173: GO 111153
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
111175: LD_VAR 0 11
111179: PPUSH
111180: LD_VAR 0 12
111184: PPUSH
111185: CALL_OW 351
111189: PUSH
111190: LD_VAR 0 11
111194: PPUSH
111195: LD_VAR 0 12
111199: PPUSH
111200: CALL_OW 554
111204: AND
111205: IFFALSE 111245
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
111207: LD_ADDR_VAR 0 13
111211: PUSH
111212: LD_VAR 0 13
111216: PPUSH
111217: LD_VAR 0 13
111221: PUSH
111222: LD_INT 1
111224: PLUS
111225: PPUSH
111226: LD_VAR 0 11
111230: PUSH
111231: LD_VAR 0 12
111235: PUSH
111236: EMPTY
111237: LIST
111238: LIST
111239: PPUSH
111240: CALL_OW 2
111244: ST_TO_ADDR
// end ;
111245: GO 111153
111247: POP
111248: POP
111249: GO 111133
111251: POP
111252: POP
// if not list then
111253: LD_VAR 0 13
111257: NOT
111258: IFFALSE 111262
// exit ;
111260: GO 111333
// for i in list do
111262: LD_ADDR_VAR 0 6
111266: PUSH
111267: LD_VAR 0 13
111271: PUSH
111272: FOR_IN
111273: IFFALSE 111331
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
111275: LD_VAR 0 1
111279: PPUSH
111280: LD_STRING M
111282: PUSH
111283: LD_VAR 0 6
111287: PUSH
111288: LD_INT 1
111290: ARRAY
111291: PUSH
111292: LD_VAR 0 6
111296: PUSH
111297: LD_INT 2
111299: ARRAY
111300: PUSH
111301: LD_INT 0
111303: PUSH
111304: LD_INT 0
111306: PUSH
111307: LD_INT 0
111309: PUSH
111310: LD_INT 0
111312: PUSH
111313: EMPTY
111314: LIST
111315: LIST
111316: LIST
111317: LIST
111318: LIST
111319: LIST
111320: LIST
111321: PUSH
111322: EMPTY
111323: LIST
111324: PPUSH
111325: CALL_OW 447
111329: GO 111272
111331: POP
111332: POP
// end ;
111333: LD_VAR 0 5
111337: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
111338: LD_EXP 185
111342: NOT
111343: IFFALSE 111393
111345: GO 111347
111347: DISABLE
// begin initHack := true ;
111348: LD_ADDR_EXP 185
111352: PUSH
111353: LD_INT 1
111355: ST_TO_ADDR
// hackTanks := [ ] ;
111356: LD_ADDR_EXP 186
111360: PUSH
111361: EMPTY
111362: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
111363: LD_ADDR_EXP 187
111367: PUSH
111368: EMPTY
111369: ST_TO_ADDR
// hackLimit := 3 ;
111370: LD_ADDR_EXP 188
111374: PUSH
111375: LD_INT 3
111377: ST_TO_ADDR
// hackDist := 12 ;
111378: LD_ADDR_EXP 189
111382: PUSH
111383: LD_INT 12
111385: ST_TO_ADDR
// hackCounter := [ ] ;
111386: LD_ADDR_EXP 190
111390: PUSH
111391: EMPTY
111392: ST_TO_ADDR
// end ;
111393: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
111394: LD_EXP 185
111398: PUSH
111399: LD_INT 34
111401: PUSH
111402: LD_INT 99
111404: PUSH
111405: EMPTY
111406: LIST
111407: LIST
111408: PPUSH
111409: CALL_OW 69
111413: AND
111414: IFFALSE 111667
111416: GO 111418
111418: DISABLE
111419: LD_INT 0
111421: PPUSH
111422: PPUSH
// begin enable ;
111423: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
111424: LD_ADDR_VAR 0 1
111428: PUSH
111429: LD_INT 34
111431: PUSH
111432: LD_INT 99
111434: PUSH
111435: EMPTY
111436: LIST
111437: LIST
111438: PPUSH
111439: CALL_OW 69
111443: PUSH
111444: FOR_IN
111445: IFFALSE 111665
// begin if not i in hackTanks then
111447: LD_VAR 0 1
111451: PUSH
111452: LD_EXP 186
111456: IN
111457: NOT
111458: IFFALSE 111541
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
111460: LD_ADDR_EXP 186
111464: PUSH
111465: LD_EXP 186
111469: PPUSH
111470: LD_EXP 186
111474: PUSH
111475: LD_INT 1
111477: PLUS
111478: PPUSH
111479: LD_VAR 0 1
111483: PPUSH
111484: CALL_OW 1
111488: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
111489: LD_ADDR_EXP 187
111493: PUSH
111494: LD_EXP 187
111498: PPUSH
111499: LD_EXP 187
111503: PUSH
111504: LD_INT 1
111506: PLUS
111507: PPUSH
111508: EMPTY
111509: PPUSH
111510: CALL_OW 1
111514: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
111515: LD_ADDR_EXP 190
111519: PUSH
111520: LD_EXP 190
111524: PPUSH
111525: LD_EXP 190
111529: PUSH
111530: LD_INT 1
111532: PLUS
111533: PPUSH
111534: EMPTY
111535: PPUSH
111536: CALL_OW 1
111540: ST_TO_ADDR
// end ; if not IsOk ( i ) then
111541: LD_VAR 0 1
111545: PPUSH
111546: CALL_OW 302
111550: NOT
111551: IFFALSE 111564
// begin HackUnlinkAll ( i ) ;
111553: LD_VAR 0 1
111557: PPUSH
111558: CALL 111670 0 1
// continue ;
111562: GO 111444
// end ; HackCheckCapturedStatus ( i ) ;
111564: LD_VAR 0 1
111568: PPUSH
111569: CALL 112113 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
111573: LD_ADDR_VAR 0 2
111577: PUSH
111578: LD_INT 81
111580: PUSH
111581: LD_VAR 0 1
111585: PPUSH
111586: CALL_OW 255
111590: PUSH
111591: EMPTY
111592: LIST
111593: LIST
111594: PUSH
111595: LD_INT 33
111597: PUSH
111598: LD_INT 3
111600: PUSH
111601: EMPTY
111602: LIST
111603: LIST
111604: PUSH
111605: LD_INT 91
111607: PUSH
111608: LD_VAR 0 1
111612: PUSH
111613: LD_EXP 189
111617: PUSH
111618: EMPTY
111619: LIST
111620: LIST
111621: LIST
111622: PUSH
111623: LD_INT 50
111625: PUSH
111626: EMPTY
111627: LIST
111628: PUSH
111629: EMPTY
111630: LIST
111631: LIST
111632: LIST
111633: LIST
111634: PPUSH
111635: CALL_OW 69
111639: ST_TO_ADDR
// if not tmp then
111640: LD_VAR 0 2
111644: NOT
111645: IFFALSE 111649
// continue ;
111647: GO 111444
// HackLink ( i , tmp ) ;
111649: LD_VAR 0 1
111653: PPUSH
111654: LD_VAR 0 2
111658: PPUSH
111659: CALL 111806 0 2
// end ;
111663: GO 111444
111665: POP
111666: POP
// end ;
111667: PPOPN 2
111669: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
111670: LD_INT 0
111672: PPUSH
111673: PPUSH
111674: PPUSH
// if not hack in hackTanks then
111675: LD_VAR 0 1
111679: PUSH
111680: LD_EXP 186
111684: IN
111685: NOT
111686: IFFALSE 111690
// exit ;
111688: GO 111801
// index := GetElementIndex ( hackTanks , hack ) ;
111690: LD_ADDR_VAR 0 4
111694: PUSH
111695: LD_EXP 186
111699: PPUSH
111700: LD_VAR 0 1
111704: PPUSH
111705: CALL 57609 0 2
111709: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
111710: LD_EXP 187
111714: PUSH
111715: LD_VAR 0 4
111719: ARRAY
111720: IFFALSE 111801
// begin for i in hackTanksCaptured [ index ] do
111722: LD_ADDR_VAR 0 3
111726: PUSH
111727: LD_EXP 187
111731: PUSH
111732: LD_VAR 0 4
111736: ARRAY
111737: PUSH
111738: FOR_IN
111739: IFFALSE 111765
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
111741: LD_VAR 0 3
111745: PUSH
111746: LD_INT 1
111748: ARRAY
111749: PPUSH
111750: LD_VAR 0 3
111754: PUSH
111755: LD_INT 2
111757: ARRAY
111758: PPUSH
111759: CALL_OW 235
111763: GO 111738
111765: POP
111766: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
111767: LD_ADDR_EXP 187
111771: PUSH
111772: LD_EXP 187
111776: PPUSH
111777: LD_VAR 0 4
111781: PPUSH
111782: EMPTY
111783: PPUSH
111784: CALL_OW 1
111788: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
111789: LD_VAR 0 1
111793: PPUSH
111794: LD_INT 0
111796: PPUSH
111797: CALL_OW 505
// end ; end ;
111801: LD_VAR 0 2
111805: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
111806: LD_INT 0
111808: PPUSH
111809: PPUSH
111810: PPUSH
// if not hack in hackTanks or not vehicles then
111811: LD_VAR 0 1
111815: PUSH
111816: LD_EXP 186
111820: IN
111821: NOT
111822: PUSH
111823: LD_VAR 0 2
111827: NOT
111828: OR
111829: IFFALSE 111833
// exit ;
111831: GO 112108
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
111833: LD_ADDR_VAR 0 2
111837: PUSH
111838: LD_VAR 0 1
111842: PPUSH
111843: LD_VAR 0 2
111847: PPUSH
111848: LD_INT 1
111850: PPUSH
111851: LD_INT 1
111853: PPUSH
111854: CALL 58259 0 4
111858: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
111859: LD_ADDR_VAR 0 5
111863: PUSH
111864: LD_EXP 186
111868: PPUSH
111869: LD_VAR 0 1
111873: PPUSH
111874: CALL 57609 0 2
111878: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
111879: LD_EXP 187
111883: PUSH
111884: LD_VAR 0 5
111888: ARRAY
111889: PUSH
111890: LD_EXP 188
111894: LESS
111895: IFFALSE 112084
// begin for i := 1 to vehicles do
111897: LD_ADDR_VAR 0 4
111901: PUSH
111902: DOUBLE
111903: LD_INT 1
111905: DEC
111906: ST_TO_ADDR
111907: LD_VAR 0 2
111911: PUSH
111912: FOR_TO
111913: IFFALSE 112082
// begin if hackTanksCaptured [ index ] = hackLimit then
111915: LD_EXP 187
111919: PUSH
111920: LD_VAR 0 5
111924: ARRAY
111925: PUSH
111926: LD_EXP 188
111930: EQUAL
111931: IFFALSE 111935
// break ;
111933: GO 112082
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
111935: LD_ADDR_EXP 190
111939: PUSH
111940: LD_EXP 190
111944: PPUSH
111945: LD_VAR 0 5
111949: PPUSH
111950: LD_EXP 190
111954: PUSH
111955: LD_VAR 0 5
111959: ARRAY
111960: PUSH
111961: LD_INT 1
111963: PLUS
111964: PPUSH
111965: CALL_OW 1
111969: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
111970: LD_ADDR_EXP 187
111974: PUSH
111975: LD_EXP 187
111979: PPUSH
111980: LD_VAR 0 5
111984: PUSH
111985: LD_EXP 187
111989: PUSH
111990: LD_VAR 0 5
111994: ARRAY
111995: PUSH
111996: LD_INT 1
111998: PLUS
111999: PUSH
112000: EMPTY
112001: LIST
112002: LIST
112003: PPUSH
112004: LD_VAR 0 2
112008: PUSH
112009: LD_VAR 0 4
112013: ARRAY
112014: PUSH
112015: LD_VAR 0 2
112019: PUSH
112020: LD_VAR 0 4
112024: ARRAY
112025: PPUSH
112026: CALL_OW 255
112030: PUSH
112031: EMPTY
112032: LIST
112033: LIST
112034: PPUSH
112035: CALL 57824 0 3
112039: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
112040: LD_VAR 0 2
112044: PUSH
112045: LD_VAR 0 4
112049: ARRAY
112050: PPUSH
112051: LD_VAR 0 1
112055: PPUSH
112056: CALL_OW 255
112060: PPUSH
112061: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
112065: LD_VAR 0 2
112069: PUSH
112070: LD_VAR 0 4
112074: ARRAY
112075: PPUSH
112076: CALL_OW 141
// end ;
112080: GO 111912
112082: POP
112083: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
112084: LD_VAR 0 1
112088: PPUSH
112089: LD_EXP 187
112093: PUSH
112094: LD_VAR 0 5
112098: ARRAY
112099: PUSH
112100: LD_INT 0
112102: PLUS
112103: PPUSH
112104: CALL_OW 505
// end ;
112108: LD_VAR 0 3
112112: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
112113: LD_INT 0
112115: PPUSH
112116: PPUSH
112117: PPUSH
112118: PPUSH
// if not hack in hackTanks then
112119: LD_VAR 0 1
112123: PUSH
112124: LD_EXP 186
112128: IN
112129: NOT
112130: IFFALSE 112134
// exit ;
112132: GO 112374
// index := GetElementIndex ( hackTanks , hack ) ;
112134: LD_ADDR_VAR 0 4
112138: PUSH
112139: LD_EXP 186
112143: PPUSH
112144: LD_VAR 0 1
112148: PPUSH
112149: CALL 57609 0 2
112153: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
112154: LD_ADDR_VAR 0 3
112158: PUSH
112159: DOUBLE
112160: LD_EXP 187
112164: PUSH
112165: LD_VAR 0 4
112169: ARRAY
112170: INC
112171: ST_TO_ADDR
112172: LD_INT 1
112174: PUSH
112175: FOR_DOWNTO
112176: IFFALSE 112348
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
112178: LD_ADDR_VAR 0 5
112182: PUSH
112183: LD_EXP 187
112187: PUSH
112188: LD_VAR 0 4
112192: ARRAY
112193: PUSH
112194: LD_VAR 0 3
112198: ARRAY
112199: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
112200: LD_VAR 0 5
112204: PUSH
112205: LD_INT 1
112207: ARRAY
112208: PPUSH
112209: CALL_OW 302
112213: NOT
112214: PUSH
112215: LD_VAR 0 5
112219: PUSH
112220: LD_INT 1
112222: ARRAY
112223: PPUSH
112224: CALL_OW 255
112228: PUSH
112229: LD_VAR 0 1
112233: PPUSH
112234: CALL_OW 255
112238: NONEQUAL
112239: OR
112240: IFFALSE 112346
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
112242: LD_VAR 0 5
112246: PUSH
112247: LD_INT 1
112249: ARRAY
112250: PPUSH
112251: CALL_OW 305
112255: PUSH
112256: LD_VAR 0 5
112260: PUSH
112261: LD_INT 1
112263: ARRAY
112264: PPUSH
112265: CALL_OW 255
112269: PUSH
112270: LD_VAR 0 1
112274: PPUSH
112275: CALL_OW 255
112279: EQUAL
112280: AND
112281: IFFALSE 112305
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
112283: LD_VAR 0 5
112287: PUSH
112288: LD_INT 1
112290: ARRAY
112291: PPUSH
112292: LD_VAR 0 5
112296: PUSH
112297: LD_INT 2
112299: ARRAY
112300: PPUSH
112301: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
112305: LD_ADDR_EXP 187
112309: PUSH
112310: LD_EXP 187
112314: PPUSH
112315: LD_VAR 0 4
112319: PPUSH
112320: LD_EXP 187
112324: PUSH
112325: LD_VAR 0 4
112329: ARRAY
112330: PPUSH
112331: LD_VAR 0 3
112335: PPUSH
112336: CALL_OW 3
112340: PPUSH
112341: CALL_OW 1
112345: ST_TO_ADDR
// end ; end ;
112346: GO 112175
112348: POP
112349: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
112350: LD_VAR 0 1
112354: PPUSH
112355: LD_EXP 187
112359: PUSH
112360: LD_VAR 0 4
112364: ARRAY
112365: PUSH
112366: LD_INT 0
112368: PLUS
112369: PPUSH
112370: CALL_OW 505
// end ;
112374: LD_VAR 0 2
112378: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
112379: LD_INT 0
112381: PPUSH
112382: PPUSH
112383: PPUSH
112384: PPUSH
// if not hack in hackTanks then
112385: LD_VAR 0 1
112389: PUSH
112390: LD_EXP 186
112394: IN
112395: NOT
112396: IFFALSE 112400
// exit ;
112398: GO 112485
// index := GetElementIndex ( hackTanks , hack ) ;
112400: LD_ADDR_VAR 0 5
112404: PUSH
112405: LD_EXP 186
112409: PPUSH
112410: LD_VAR 0 1
112414: PPUSH
112415: CALL 57609 0 2
112419: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
112420: LD_ADDR_VAR 0 4
112424: PUSH
112425: DOUBLE
112426: LD_INT 1
112428: DEC
112429: ST_TO_ADDR
112430: LD_EXP 187
112434: PUSH
112435: LD_VAR 0 5
112439: ARRAY
112440: PUSH
112441: FOR_TO
112442: IFFALSE 112483
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
112444: LD_EXP 187
112448: PUSH
112449: LD_VAR 0 5
112453: ARRAY
112454: PUSH
112455: LD_VAR 0 4
112459: ARRAY
112460: PUSH
112461: LD_INT 1
112463: ARRAY
112464: PUSH
112465: LD_VAR 0 2
112469: EQUAL
112470: IFFALSE 112481
// KillUnit ( vehicle ) ;
112472: LD_VAR 0 2
112476: PPUSH
112477: CALL_OW 66
112481: GO 112441
112483: POP
112484: POP
// end ;
112485: LD_VAR 0 3
112489: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
112490: LD_EXP 191
112494: NOT
112495: IFFALSE 112530
112497: GO 112499
112499: DISABLE
// begin initMiner := true ;
112500: LD_ADDR_EXP 191
112504: PUSH
112505: LD_INT 1
112507: ST_TO_ADDR
// minersList := [ ] ;
112508: LD_ADDR_EXP 192
112512: PUSH
112513: EMPTY
112514: ST_TO_ADDR
// minerMinesList := [ ] ;
112515: LD_ADDR_EXP 193
112519: PUSH
112520: EMPTY
112521: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
112522: LD_ADDR_EXP 194
112526: PUSH
112527: LD_INT 5
112529: ST_TO_ADDR
// end ;
112530: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
112531: LD_EXP 191
112535: PUSH
112536: LD_INT 34
112538: PUSH
112539: LD_INT 81
112541: PUSH
112542: EMPTY
112543: LIST
112544: LIST
112545: PPUSH
112546: CALL_OW 69
112550: AND
112551: IFFALSE 113012
112553: GO 112555
112555: DISABLE
112556: LD_INT 0
112558: PPUSH
112559: PPUSH
112560: PPUSH
112561: PPUSH
// begin enable ;
112562: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
112563: LD_ADDR_VAR 0 1
112567: PUSH
112568: LD_INT 34
112570: PUSH
112571: LD_INT 81
112573: PUSH
112574: EMPTY
112575: LIST
112576: LIST
112577: PPUSH
112578: CALL_OW 69
112582: PUSH
112583: FOR_IN
112584: IFFALSE 112656
// begin if not i in minersList then
112586: LD_VAR 0 1
112590: PUSH
112591: LD_EXP 192
112595: IN
112596: NOT
112597: IFFALSE 112654
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
112599: LD_ADDR_EXP 192
112603: PUSH
112604: LD_EXP 192
112608: PPUSH
112609: LD_EXP 192
112613: PUSH
112614: LD_INT 1
112616: PLUS
112617: PPUSH
112618: LD_VAR 0 1
112622: PPUSH
112623: CALL_OW 1
112627: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
112628: LD_ADDR_EXP 193
112632: PUSH
112633: LD_EXP 193
112637: PPUSH
112638: LD_EXP 193
112642: PUSH
112643: LD_INT 1
112645: PLUS
112646: PPUSH
112647: EMPTY
112648: PPUSH
112649: CALL_OW 1
112653: ST_TO_ADDR
// end end ;
112654: GO 112583
112656: POP
112657: POP
// for i := minerMinesList downto 1 do
112658: LD_ADDR_VAR 0 1
112662: PUSH
112663: DOUBLE
112664: LD_EXP 193
112668: INC
112669: ST_TO_ADDR
112670: LD_INT 1
112672: PUSH
112673: FOR_DOWNTO
112674: IFFALSE 113010
// begin if IsLive ( minersList [ i ] ) then
112676: LD_EXP 192
112680: PUSH
112681: LD_VAR 0 1
112685: ARRAY
112686: PPUSH
112687: CALL_OW 300
112691: IFFALSE 112719
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
112693: LD_EXP 192
112697: PUSH
112698: LD_VAR 0 1
112702: ARRAY
112703: PPUSH
112704: LD_EXP 193
112708: PUSH
112709: LD_VAR 0 1
112713: ARRAY
112714: PPUSH
112715: CALL_OW 505
// if not minerMinesList [ i ] then
112719: LD_EXP 193
112723: PUSH
112724: LD_VAR 0 1
112728: ARRAY
112729: NOT
112730: IFFALSE 112734
// continue ;
112732: GO 112673
// for j := minerMinesList [ i ] downto 1 do
112734: LD_ADDR_VAR 0 2
112738: PUSH
112739: DOUBLE
112740: LD_EXP 193
112744: PUSH
112745: LD_VAR 0 1
112749: ARRAY
112750: INC
112751: ST_TO_ADDR
112752: LD_INT 1
112754: PUSH
112755: FOR_DOWNTO
112756: IFFALSE 113006
// begin side := GetSide ( minersList [ i ] ) ;
112758: LD_ADDR_VAR 0 3
112762: PUSH
112763: LD_EXP 192
112767: PUSH
112768: LD_VAR 0 1
112772: ARRAY
112773: PPUSH
112774: CALL_OW 255
112778: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
112779: LD_ADDR_VAR 0 4
112783: PUSH
112784: LD_EXP 193
112788: PUSH
112789: LD_VAR 0 1
112793: ARRAY
112794: PUSH
112795: LD_VAR 0 2
112799: ARRAY
112800: PUSH
112801: LD_INT 1
112803: ARRAY
112804: PPUSH
112805: LD_EXP 193
112809: PUSH
112810: LD_VAR 0 1
112814: ARRAY
112815: PUSH
112816: LD_VAR 0 2
112820: ARRAY
112821: PUSH
112822: LD_INT 2
112824: ARRAY
112825: PPUSH
112826: CALL_OW 428
112830: ST_TO_ADDR
// if not tmp then
112831: LD_VAR 0 4
112835: NOT
112836: IFFALSE 112840
// continue ;
112838: GO 112755
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
112840: LD_VAR 0 4
112844: PUSH
112845: LD_INT 81
112847: PUSH
112848: LD_VAR 0 3
112852: PUSH
112853: EMPTY
112854: LIST
112855: LIST
112856: PPUSH
112857: CALL_OW 69
112861: IN
112862: PUSH
112863: LD_EXP 193
112867: PUSH
112868: LD_VAR 0 1
112872: ARRAY
112873: PUSH
112874: LD_VAR 0 2
112878: ARRAY
112879: PUSH
112880: LD_INT 1
112882: ARRAY
112883: PPUSH
112884: LD_EXP 193
112888: PUSH
112889: LD_VAR 0 1
112893: ARRAY
112894: PUSH
112895: LD_VAR 0 2
112899: ARRAY
112900: PUSH
112901: LD_INT 2
112903: ARRAY
112904: PPUSH
112905: CALL_OW 458
112909: AND
112910: IFFALSE 113004
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
112912: LD_EXP 193
112916: PUSH
112917: LD_VAR 0 1
112921: ARRAY
112922: PUSH
112923: LD_VAR 0 2
112927: ARRAY
112928: PUSH
112929: LD_INT 1
112931: ARRAY
112932: PPUSH
112933: LD_EXP 193
112937: PUSH
112938: LD_VAR 0 1
112942: ARRAY
112943: PUSH
112944: LD_VAR 0 2
112948: ARRAY
112949: PUSH
112950: LD_INT 2
112952: ARRAY
112953: PPUSH
112954: LD_VAR 0 3
112958: PPUSH
112959: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
112963: LD_ADDR_EXP 193
112967: PUSH
112968: LD_EXP 193
112972: PPUSH
112973: LD_VAR 0 1
112977: PPUSH
112978: LD_EXP 193
112982: PUSH
112983: LD_VAR 0 1
112987: ARRAY
112988: PPUSH
112989: LD_VAR 0 2
112993: PPUSH
112994: CALL_OW 3
112998: PPUSH
112999: CALL_OW 1
113003: ST_TO_ADDR
// end ; end ;
113004: GO 112755
113006: POP
113007: POP
// end ;
113008: GO 112673
113010: POP
113011: POP
// end ;
113012: PPOPN 4
113014: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
113015: LD_INT 0
113017: PPUSH
113018: PPUSH
// result := false ;
113019: LD_ADDR_VAR 0 4
113023: PUSH
113024: LD_INT 0
113026: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
113027: LD_VAR 0 1
113031: PPUSH
113032: CALL_OW 264
113036: PUSH
113037: LD_INT 81
113039: EQUAL
113040: NOT
113041: IFFALSE 113045
// exit ;
113043: GO 113285
// index := GetElementIndex ( minersList , unit ) ;
113045: LD_ADDR_VAR 0 5
113049: PUSH
113050: LD_EXP 192
113054: PPUSH
113055: LD_VAR 0 1
113059: PPUSH
113060: CALL 57609 0 2
113064: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
113065: LD_EXP 193
113069: PUSH
113070: LD_VAR 0 5
113074: ARRAY
113075: PUSH
113076: LD_EXP 194
113080: GREATEREQUAL
113081: IFFALSE 113085
// exit ;
113083: GO 113285
// ComMoveXY ( unit , x , y ) ;
113085: LD_VAR 0 1
113089: PPUSH
113090: LD_VAR 0 2
113094: PPUSH
113095: LD_VAR 0 3
113099: PPUSH
113100: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
113104: LD_INT 35
113106: PPUSH
113107: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
113111: LD_VAR 0 1
113115: PPUSH
113116: LD_VAR 0 2
113120: PPUSH
113121: LD_VAR 0 3
113125: PPUSH
113126: CALL 88993 0 3
113130: NOT
113131: PUSH
113132: LD_VAR 0 1
113136: PPUSH
113137: CALL_OW 314
113141: AND
113142: IFFALSE 113146
// exit ;
113144: GO 113285
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
113146: LD_VAR 0 2
113150: PPUSH
113151: LD_VAR 0 3
113155: PPUSH
113156: CALL_OW 428
113160: PUSH
113161: LD_VAR 0 1
113165: EQUAL
113166: PUSH
113167: LD_VAR 0 1
113171: PPUSH
113172: CALL_OW 314
113176: NOT
113177: AND
113178: IFFALSE 113104
// PlaySoundXY ( x , y , PlantMine ) ;
113180: LD_VAR 0 2
113184: PPUSH
113185: LD_VAR 0 3
113189: PPUSH
113190: LD_STRING PlantMine
113192: PPUSH
113193: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
113197: LD_VAR 0 2
113201: PPUSH
113202: LD_VAR 0 3
113206: PPUSH
113207: LD_VAR 0 1
113211: PPUSH
113212: CALL_OW 255
113216: PPUSH
113217: LD_INT 0
113219: PPUSH
113220: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
113224: LD_ADDR_EXP 193
113228: PUSH
113229: LD_EXP 193
113233: PPUSH
113234: LD_VAR 0 5
113238: PUSH
113239: LD_EXP 193
113243: PUSH
113244: LD_VAR 0 5
113248: ARRAY
113249: PUSH
113250: LD_INT 1
113252: PLUS
113253: PUSH
113254: EMPTY
113255: LIST
113256: LIST
113257: PPUSH
113258: LD_VAR 0 2
113262: PUSH
113263: LD_VAR 0 3
113267: PUSH
113268: EMPTY
113269: LIST
113270: LIST
113271: PPUSH
113272: CALL 57824 0 3
113276: ST_TO_ADDR
// result := true ;
113277: LD_ADDR_VAR 0 4
113281: PUSH
113282: LD_INT 1
113284: ST_TO_ADDR
// end ;
113285: LD_VAR 0 4
113289: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
113290: LD_INT 0
113292: PPUSH
113293: PPUSH
113294: PPUSH
// if not unit in minersList then
113295: LD_VAR 0 1
113299: PUSH
113300: LD_EXP 192
113304: IN
113305: NOT
113306: IFFALSE 113310
// exit ;
113308: GO 113702
// index := GetElementIndex ( minersList , unit ) ;
113310: LD_ADDR_VAR 0 6
113314: PUSH
113315: LD_EXP 192
113319: PPUSH
113320: LD_VAR 0 1
113324: PPUSH
113325: CALL 57609 0 2
113329: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
113330: LD_ADDR_VAR 0 5
113334: PUSH
113335: DOUBLE
113336: LD_EXP 193
113340: PUSH
113341: LD_VAR 0 6
113345: ARRAY
113346: INC
113347: ST_TO_ADDR
113348: LD_INT 1
113350: PUSH
113351: FOR_DOWNTO
113352: IFFALSE 113513
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
113354: LD_EXP 193
113358: PUSH
113359: LD_VAR 0 6
113363: ARRAY
113364: PUSH
113365: LD_VAR 0 5
113369: ARRAY
113370: PUSH
113371: LD_INT 1
113373: ARRAY
113374: PUSH
113375: LD_VAR 0 2
113379: EQUAL
113380: PUSH
113381: LD_EXP 193
113385: PUSH
113386: LD_VAR 0 6
113390: ARRAY
113391: PUSH
113392: LD_VAR 0 5
113396: ARRAY
113397: PUSH
113398: LD_INT 2
113400: ARRAY
113401: PUSH
113402: LD_VAR 0 3
113406: EQUAL
113407: AND
113408: IFFALSE 113511
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
113410: LD_EXP 193
113414: PUSH
113415: LD_VAR 0 6
113419: ARRAY
113420: PUSH
113421: LD_VAR 0 5
113425: ARRAY
113426: PUSH
113427: LD_INT 1
113429: ARRAY
113430: PPUSH
113431: LD_EXP 193
113435: PUSH
113436: LD_VAR 0 6
113440: ARRAY
113441: PUSH
113442: LD_VAR 0 5
113446: ARRAY
113447: PUSH
113448: LD_INT 2
113450: ARRAY
113451: PPUSH
113452: LD_VAR 0 1
113456: PPUSH
113457: CALL_OW 255
113461: PPUSH
113462: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
113466: LD_ADDR_EXP 193
113470: PUSH
113471: LD_EXP 193
113475: PPUSH
113476: LD_VAR 0 6
113480: PPUSH
113481: LD_EXP 193
113485: PUSH
113486: LD_VAR 0 6
113490: ARRAY
113491: PPUSH
113492: LD_VAR 0 5
113496: PPUSH
113497: CALL_OW 3
113501: PPUSH
113502: CALL_OW 1
113506: ST_TO_ADDR
// exit ;
113507: POP
113508: POP
113509: GO 113702
// end ; end ;
113511: GO 113351
113513: POP
113514: POP
// for i := minerMinesList [ index ] downto 1 do
113515: LD_ADDR_VAR 0 5
113519: PUSH
113520: DOUBLE
113521: LD_EXP 193
113525: PUSH
113526: LD_VAR 0 6
113530: ARRAY
113531: INC
113532: ST_TO_ADDR
113533: LD_INT 1
113535: PUSH
113536: FOR_DOWNTO
113537: IFFALSE 113700
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
113539: LD_EXP 193
113543: PUSH
113544: LD_VAR 0 6
113548: ARRAY
113549: PUSH
113550: LD_VAR 0 5
113554: ARRAY
113555: PUSH
113556: LD_INT 1
113558: ARRAY
113559: PPUSH
113560: LD_EXP 193
113564: PUSH
113565: LD_VAR 0 6
113569: ARRAY
113570: PUSH
113571: LD_VAR 0 5
113575: ARRAY
113576: PUSH
113577: LD_INT 2
113579: ARRAY
113580: PPUSH
113581: LD_VAR 0 2
113585: PPUSH
113586: LD_VAR 0 3
113590: PPUSH
113591: CALL_OW 298
113595: PUSH
113596: LD_INT 6
113598: LESS
113599: IFFALSE 113698
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
113601: LD_EXP 193
113605: PUSH
113606: LD_VAR 0 6
113610: ARRAY
113611: PUSH
113612: LD_VAR 0 5
113616: ARRAY
113617: PUSH
113618: LD_INT 1
113620: ARRAY
113621: PPUSH
113622: LD_EXP 193
113626: PUSH
113627: LD_VAR 0 6
113631: ARRAY
113632: PUSH
113633: LD_VAR 0 5
113637: ARRAY
113638: PUSH
113639: LD_INT 2
113641: ARRAY
113642: PPUSH
113643: LD_VAR 0 1
113647: PPUSH
113648: CALL_OW 255
113652: PPUSH
113653: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
113657: LD_ADDR_EXP 193
113661: PUSH
113662: LD_EXP 193
113666: PPUSH
113667: LD_VAR 0 6
113671: PPUSH
113672: LD_EXP 193
113676: PUSH
113677: LD_VAR 0 6
113681: ARRAY
113682: PPUSH
113683: LD_VAR 0 5
113687: PPUSH
113688: CALL_OW 3
113692: PPUSH
113693: CALL_OW 1
113697: ST_TO_ADDR
// end ; end ;
113698: GO 113536
113700: POP
113701: POP
// end ;
113702: LD_VAR 0 4
113706: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
113707: LD_INT 0
113709: PPUSH
113710: PPUSH
113711: PPUSH
113712: PPUSH
113713: PPUSH
113714: PPUSH
113715: PPUSH
113716: PPUSH
113717: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
113718: LD_VAR 0 1
113722: PPUSH
113723: CALL_OW 264
113727: PUSH
113728: LD_INT 81
113730: EQUAL
113731: NOT
113732: PUSH
113733: LD_VAR 0 1
113737: PUSH
113738: LD_EXP 192
113742: IN
113743: NOT
113744: OR
113745: IFFALSE 113749
// exit ;
113747: GO 114071
// index := GetElementIndex ( minersList , unit ) ;
113749: LD_ADDR_VAR 0 6
113753: PUSH
113754: LD_EXP 192
113758: PPUSH
113759: LD_VAR 0 1
113763: PPUSH
113764: CALL 57609 0 2
113768: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
113769: LD_ADDR_VAR 0 8
113773: PUSH
113774: LD_EXP 194
113778: PUSH
113779: LD_EXP 193
113783: PUSH
113784: LD_VAR 0 6
113788: ARRAY
113789: MINUS
113790: ST_TO_ADDR
// if not minesFreeAmount then
113791: LD_VAR 0 8
113795: NOT
113796: IFFALSE 113800
// exit ;
113798: GO 114071
// tmp := [ ] ;
113800: LD_ADDR_VAR 0 7
113804: PUSH
113805: EMPTY
113806: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
113807: LD_ADDR_VAR 0 5
113811: PUSH
113812: DOUBLE
113813: LD_INT 1
113815: DEC
113816: ST_TO_ADDR
113817: LD_VAR 0 8
113821: PUSH
113822: FOR_TO
113823: IFFALSE 114018
// begin _d := rand ( 0 , 5 ) ;
113825: LD_ADDR_VAR 0 11
113829: PUSH
113830: LD_INT 0
113832: PPUSH
113833: LD_INT 5
113835: PPUSH
113836: CALL_OW 12
113840: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
113841: LD_ADDR_VAR 0 12
113845: PUSH
113846: LD_INT 2
113848: PPUSH
113849: LD_INT 6
113851: PPUSH
113852: CALL_OW 12
113856: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
113857: LD_ADDR_VAR 0 9
113861: PUSH
113862: LD_VAR 0 2
113866: PPUSH
113867: LD_VAR 0 11
113871: PPUSH
113872: LD_VAR 0 12
113876: PPUSH
113877: CALL_OW 272
113881: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
113882: LD_ADDR_VAR 0 10
113886: PUSH
113887: LD_VAR 0 3
113891: PPUSH
113892: LD_VAR 0 11
113896: PPUSH
113897: LD_VAR 0 12
113901: PPUSH
113902: CALL_OW 273
113906: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
113907: LD_VAR 0 9
113911: PPUSH
113912: LD_VAR 0 10
113916: PPUSH
113917: CALL_OW 488
113921: PUSH
113922: LD_VAR 0 9
113926: PUSH
113927: LD_VAR 0 10
113931: PUSH
113932: EMPTY
113933: LIST
113934: LIST
113935: PUSH
113936: LD_VAR 0 7
113940: IN
113941: NOT
113942: AND
113943: PUSH
113944: LD_VAR 0 9
113948: PPUSH
113949: LD_VAR 0 10
113953: PPUSH
113954: CALL_OW 458
113958: NOT
113959: AND
113960: IFFALSE 114002
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
113962: LD_ADDR_VAR 0 7
113966: PUSH
113967: LD_VAR 0 7
113971: PPUSH
113972: LD_VAR 0 7
113976: PUSH
113977: LD_INT 1
113979: PLUS
113980: PPUSH
113981: LD_VAR 0 9
113985: PUSH
113986: LD_VAR 0 10
113990: PUSH
113991: EMPTY
113992: LIST
113993: LIST
113994: PPUSH
113995: CALL_OW 1
113999: ST_TO_ADDR
114000: GO 114016
// i := i - 1 ;
114002: LD_ADDR_VAR 0 5
114006: PUSH
114007: LD_VAR 0 5
114011: PUSH
114012: LD_INT 1
114014: MINUS
114015: ST_TO_ADDR
// end ;
114016: GO 113822
114018: POP
114019: POP
// for i in tmp do
114020: LD_ADDR_VAR 0 5
114024: PUSH
114025: LD_VAR 0 7
114029: PUSH
114030: FOR_IN
114031: IFFALSE 114069
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
114033: LD_VAR 0 1
114037: PPUSH
114038: LD_VAR 0 5
114042: PUSH
114043: LD_INT 1
114045: ARRAY
114046: PPUSH
114047: LD_VAR 0 5
114051: PUSH
114052: LD_INT 2
114054: ARRAY
114055: PPUSH
114056: CALL 113015 0 3
114060: NOT
114061: IFFALSE 114067
// exit ;
114063: POP
114064: POP
114065: GO 114071
114067: GO 114030
114069: POP
114070: POP
// end ;
114071: LD_VAR 0 4
114075: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
114076: LD_INT 0
114078: PPUSH
114079: PPUSH
114080: PPUSH
114081: PPUSH
114082: PPUSH
114083: PPUSH
114084: PPUSH
// if not GetClass ( unit ) = class_sniper then
114085: LD_VAR 0 1
114089: PPUSH
114090: CALL_OW 257
114094: PUSH
114095: LD_INT 5
114097: EQUAL
114098: NOT
114099: IFFALSE 114103
// exit ;
114101: GO 114491
// dist := 8 ;
114103: LD_ADDR_VAR 0 5
114107: PUSH
114108: LD_INT 8
114110: ST_TO_ADDR
// viewRange := 12 ;
114111: LD_ADDR_VAR 0 7
114115: PUSH
114116: LD_INT 12
114118: ST_TO_ADDR
// side := GetSide ( unit ) ;
114119: LD_ADDR_VAR 0 6
114123: PUSH
114124: LD_VAR 0 1
114128: PPUSH
114129: CALL_OW 255
114133: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
114134: LD_INT 61
114136: PPUSH
114137: LD_VAR 0 6
114141: PPUSH
114142: CALL_OW 321
114146: PUSH
114147: LD_INT 2
114149: EQUAL
114150: IFFALSE 114160
// viewRange := 16 ;
114152: LD_ADDR_VAR 0 7
114156: PUSH
114157: LD_INT 16
114159: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
114160: LD_VAR 0 1
114164: PPUSH
114165: LD_VAR 0 2
114169: PPUSH
114170: LD_VAR 0 3
114174: PPUSH
114175: CALL_OW 297
114179: PUSH
114180: LD_VAR 0 5
114184: GREATER
114185: IFFALSE 114264
// begin ComMoveXY ( unit , x , y ) ;
114187: LD_VAR 0 1
114191: PPUSH
114192: LD_VAR 0 2
114196: PPUSH
114197: LD_VAR 0 3
114201: PPUSH
114202: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
114206: LD_INT 35
114208: PPUSH
114209: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
114213: LD_VAR 0 1
114217: PPUSH
114218: LD_VAR 0 2
114222: PPUSH
114223: LD_VAR 0 3
114227: PPUSH
114228: CALL 88993 0 3
114232: NOT
114233: IFFALSE 114237
// exit ;
114235: GO 114491
// until GetDistUnitXY ( unit , x , y ) < dist ;
114237: LD_VAR 0 1
114241: PPUSH
114242: LD_VAR 0 2
114246: PPUSH
114247: LD_VAR 0 3
114251: PPUSH
114252: CALL_OW 297
114256: PUSH
114257: LD_VAR 0 5
114261: LESS
114262: IFFALSE 114206
// end ; ComTurnXY ( unit , x , y ) ;
114264: LD_VAR 0 1
114268: PPUSH
114269: LD_VAR 0 2
114273: PPUSH
114274: LD_VAR 0 3
114278: PPUSH
114279: CALL_OW 118
// wait ( 5 ) ;
114283: LD_INT 5
114285: PPUSH
114286: CALL_OW 67
// _d := GetDir ( unit ) ;
114290: LD_ADDR_VAR 0 10
114294: PUSH
114295: LD_VAR 0 1
114299: PPUSH
114300: CALL_OW 254
114304: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
114305: LD_ADDR_VAR 0 8
114309: PUSH
114310: LD_VAR 0 1
114314: PPUSH
114315: CALL_OW 250
114319: PPUSH
114320: LD_VAR 0 10
114324: PPUSH
114325: LD_VAR 0 5
114329: PPUSH
114330: CALL_OW 272
114334: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
114335: LD_ADDR_VAR 0 9
114339: PUSH
114340: LD_VAR 0 1
114344: PPUSH
114345: CALL_OW 251
114349: PPUSH
114350: LD_VAR 0 10
114354: PPUSH
114355: LD_VAR 0 5
114359: PPUSH
114360: CALL_OW 273
114364: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
114365: LD_VAR 0 8
114369: PPUSH
114370: LD_VAR 0 9
114374: PPUSH
114375: CALL_OW 488
114379: NOT
114380: IFFALSE 114384
// exit ;
114382: GO 114491
// ComAnimCustom ( unit , 1 ) ;
114384: LD_VAR 0 1
114388: PPUSH
114389: LD_INT 1
114391: PPUSH
114392: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
114396: LD_VAR 0 8
114400: PPUSH
114401: LD_VAR 0 9
114405: PPUSH
114406: LD_VAR 0 6
114410: PPUSH
114411: LD_VAR 0 7
114415: PPUSH
114416: CALL_OW 330
// repeat wait ( 1 ) ;
114420: LD_INT 1
114422: PPUSH
114423: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
114427: LD_VAR 0 1
114431: PPUSH
114432: CALL_OW 316
114436: PUSH
114437: LD_VAR 0 1
114441: PPUSH
114442: CALL_OW 314
114446: OR
114447: PUSH
114448: LD_VAR 0 1
114452: PPUSH
114453: CALL_OW 302
114457: NOT
114458: OR
114459: PUSH
114460: LD_VAR 0 1
114464: PPUSH
114465: CALL_OW 301
114469: OR
114470: IFFALSE 114420
// RemoveSeeing ( _x , _y , side ) ;
114472: LD_VAR 0 8
114476: PPUSH
114477: LD_VAR 0 9
114481: PPUSH
114482: LD_VAR 0 6
114486: PPUSH
114487: CALL_OW 331
// end ; end_of_file
114491: LD_VAR 0 4
114495: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
114496: LD_INT 0
114498: PPUSH
114499: PPUSH
114500: PPUSH
114501: PPUSH
114502: PPUSH
114503: PPUSH
114504: PPUSH
114505: PPUSH
114506: PPUSH
114507: PPUSH
114508: PPUSH
114509: PPUSH
114510: PPUSH
114511: PPUSH
114512: PPUSH
114513: PPUSH
114514: PPUSH
114515: PPUSH
114516: PPUSH
114517: PPUSH
114518: PPUSH
114519: PPUSH
114520: PPUSH
114521: PPUSH
114522: PPUSH
114523: PPUSH
114524: PPUSH
114525: PPUSH
114526: PPUSH
114527: PPUSH
114528: PPUSH
114529: PPUSH
114530: PPUSH
114531: PPUSH
// if not list then
114532: LD_VAR 0 1
114536: NOT
114537: IFFALSE 114541
// exit ;
114539: GO 119200
// base := list [ 1 ] ;
114541: LD_ADDR_VAR 0 3
114545: PUSH
114546: LD_VAR 0 1
114550: PUSH
114551: LD_INT 1
114553: ARRAY
114554: ST_TO_ADDR
// group := list [ 2 ] ;
114555: LD_ADDR_VAR 0 4
114559: PUSH
114560: LD_VAR 0 1
114564: PUSH
114565: LD_INT 2
114567: ARRAY
114568: ST_TO_ADDR
// path := list [ 3 ] ;
114569: LD_ADDR_VAR 0 5
114573: PUSH
114574: LD_VAR 0 1
114578: PUSH
114579: LD_INT 3
114581: ARRAY
114582: ST_TO_ADDR
// flags := list [ 4 ] ;
114583: LD_ADDR_VAR 0 6
114587: PUSH
114588: LD_VAR 0 1
114592: PUSH
114593: LD_INT 4
114595: ARRAY
114596: ST_TO_ADDR
// mined := [ ] ;
114597: LD_ADDR_VAR 0 27
114601: PUSH
114602: EMPTY
114603: ST_TO_ADDR
// bombed := [ ] ;
114604: LD_ADDR_VAR 0 28
114608: PUSH
114609: EMPTY
114610: ST_TO_ADDR
// healers := [ ] ;
114611: LD_ADDR_VAR 0 31
114615: PUSH
114616: EMPTY
114617: ST_TO_ADDR
// to_heal := [ ] ;
114618: LD_ADDR_VAR 0 30
114622: PUSH
114623: EMPTY
114624: ST_TO_ADDR
// repairs := [ ] ;
114625: LD_ADDR_VAR 0 33
114629: PUSH
114630: EMPTY
114631: ST_TO_ADDR
// to_repair := [ ] ;
114632: LD_ADDR_VAR 0 32
114636: PUSH
114637: EMPTY
114638: ST_TO_ADDR
// if not group or not path then
114639: LD_VAR 0 4
114643: NOT
114644: PUSH
114645: LD_VAR 0 5
114649: NOT
114650: OR
114651: IFFALSE 114655
// exit ;
114653: GO 119200
// side := GetSide ( group [ 1 ] ) ;
114655: LD_ADDR_VAR 0 35
114659: PUSH
114660: LD_VAR 0 4
114664: PUSH
114665: LD_INT 1
114667: ARRAY
114668: PPUSH
114669: CALL_OW 255
114673: ST_TO_ADDR
// if flags then
114674: LD_VAR 0 6
114678: IFFALSE 114822
// begin f_ignore_area := flags [ 1 ] ;
114680: LD_ADDR_VAR 0 17
114684: PUSH
114685: LD_VAR 0 6
114689: PUSH
114690: LD_INT 1
114692: ARRAY
114693: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
114694: LD_ADDR_VAR 0 18
114698: PUSH
114699: LD_VAR 0 6
114703: PUSH
114704: LD_INT 2
114706: ARRAY
114707: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
114708: LD_ADDR_VAR 0 19
114712: PUSH
114713: LD_VAR 0 6
114717: PUSH
114718: LD_INT 3
114720: ARRAY
114721: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
114722: LD_ADDR_VAR 0 20
114726: PUSH
114727: LD_VAR 0 6
114731: PUSH
114732: LD_INT 4
114734: ARRAY
114735: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
114736: LD_ADDR_VAR 0 21
114740: PUSH
114741: LD_VAR 0 6
114745: PUSH
114746: LD_INT 5
114748: ARRAY
114749: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
114750: LD_ADDR_VAR 0 22
114754: PUSH
114755: LD_VAR 0 6
114759: PUSH
114760: LD_INT 6
114762: ARRAY
114763: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
114764: LD_ADDR_VAR 0 23
114768: PUSH
114769: LD_VAR 0 6
114773: PUSH
114774: LD_INT 7
114776: ARRAY
114777: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
114778: LD_ADDR_VAR 0 24
114782: PUSH
114783: LD_VAR 0 6
114787: PUSH
114788: LD_INT 8
114790: ARRAY
114791: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
114792: LD_ADDR_VAR 0 25
114796: PUSH
114797: LD_VAR 0 6
114801: PUSH
114802: LD_INT 9
114804: ARRAY
114805: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
114806: LD_ADDR_VAR 0 26
114810: PUSH
114811: LD_VAR 0 6
114815: PUSH
114816: LD_INT 10
114818: ARRAY
114819: ST_TO_ADDR
// end else
114820: GO 114902
// begin f_ignore_area := false ;
114822: LD_ADDR_VAR 0 17
114826: PUSH
114827: LD_INT 0
114829: ST_TO_ADDR
// f_capture := false ;
114830: LD_ADDR_VAR 0 18
114834: PUSH
114835: LD_INT 0
114837: ST_TO_ADDR
// f_ignore_civ := false ;
114838: LD_ADDR_VAR 0 19
114842: PUSH
114843: LD_INT 0
114845: ST_TO_ADDR
// f_murder := false ;
114846: LD_ADDR_VAR 0 20
114850: PUSH
114851: LD_INT 0
114853: ST_TO_ADDR
// f_mines := false ;
114854: LD_ADDR_VAR 0 21
114858: PUSH
114859: LD_INT 0
114861: ST_TO_ADDR
// f_repair := false ;
114862: LD_ADDR_VAR 0 22
114866: PUSH
114867: LD_INT 0
114869: ST_TO_ADDR
// f_heal := false ;
114870: LD_ADDR_VAR 0 23
114874: PUSH
114875: LD_INT 0
114877: ST_TO_ADDR
// f_spacetime := false ;
114878: LD_ADDR_VAR 0 24
114882: PUSH
114883: LD_INT 0
114885: ST_TO_ADDR
// f_attack_depot := false ;
114886: LD_ADDR_VAR 0 25
114890: PUSH
114891: LD_INT 0
114893: ST_TO_ADDR
// f_crawl := false ;
114894: LD_ADDR_VAR 0 26
114898: PUSH
114899: LD_INT 0
114901: ST_TO_ADDR
// end ; if f_heal then
114902: LD_VAR 0 23
114906: IFFALSE 114933
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
114908: LD_ADDR_VAR 0 31
114912: PUSH
114913: LD_VAR 0 4
114917: PPUSH
114918: LD_INT 25
114920: PUSH
114921: LD_INT 4
114923: PUSH
114924: EMPTY
114925: LIST
114926: LIST
114927: PPUSH
114928: CALL_OW 72
114932: ST_TO_ADDR
// if f_repair then
114933: LD_VAR 0 22
114937: IFFALSE 114964
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
114939: LD_ADDR_VAR 0 33
114943: PUSH
114944: LD_VAR 0 4
114948: PPUSH
114949: LD_INT 25
114951: PUSH
114952: LD_INT 3
114954: PUSH
114955: EMPTY
114956: LIST
114957: LIST
114958: PPUSH
114959: CALL_OW 72
114963: ST_TO_ADDR
// units_path := [ ] ;
114964: LD_ADDR_VAR 0 16
114968: PUSH
114969: EMPTY
114970: ST_TO_ADDR
// for i = 1 to group do
114971: LD_ADDR_VAR 0 7
114975: PUSH
114976: DOUBLE
114977: LD_INT 1
114979: DEC
114980: ST_TO_ADDR
114981: LD_VAR 0 4
114985: PUSH
114986: FOR_TO
114987: IFFALSE 115016
// units_path := Replace ( units_path , i , path ) ;
114989: LD_ADDR_VAR 0 16
114993: PUSH
114994: LD_VAR 0 16
114998: PPUSH
114999: LD_VAR 0 7
115003: PPUSH
115004: LD_VAR 0 5
115008: PPUSH
115009: CALL_OW 1
115013: ST_TO_ADDR
115014: GO 114986
115016: POP
115017: POP
// repeat for i = group downto 1 do
115018: LD_ADDR_VAR 0 7
115022: PUSH
115023: DOUBLE
115024: LD_VAR 0 4
115028: INC
115029: ST_TO_ADDR
115030: LD_INT 1
115032: PUSH
115033: FOR_DOWNTO
115034: IFFALSE 119156
// begin wait ( 5 ) ;
115036: LD_INT 5
115038: PPUSH
115039: CALL_OW 67
// tmp := [ ] ;
115043: LD_ADDR_VAR 0 14
115047: PUSH
115048: EMPTY
115049: ST_TO_ADDR
// attacking := false ;
115050: LD_ADDR_VAR 0 29
115054: PUSH
115055: LD_INT 0
115057: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
115058: LD_VAR 0 4
115062: PUSH
115063: LD_VAR 0 7
115067: ARRAY
115068: PPUSH
115069: CALL_OW 301
115073: PUSH
115074: LD_VAR 0 4
115078: PUSH
115079: LD_VAR 0 7
115083: ARRAY
115084: NOT
115085: OR
115086: IFFALSE 115195
// begin if GetType ( group [ i ] ) = unit_human then
115088: LD_VAR 0 4
115092: PUSH
115093: LD_VAR 0 7
115097: ARRAY
115098: PPUSH
115099: CALL_OW 247
115103: PUSH
115104: LD_INT 1
115106: EQUAL
115107: IFFALSE 115153
// begin to_heal := to_heal diff group [ i ] ;
115109: LD_ADDR_VAR 0 30
115113: PUSH
115114: LD_VAR 0 30
115118: PUSH
115119: LD_VAR 0 4
115123: PUSH
115124: LD_VAR 0 7
115128: ARRAY
115129: DIFF
115130: ST_TO_ADDR
// healers := healers diff group [ i ] ;
115131: LD_ADDR_VAR 0 31
115135: PUSH
115136: LD_VAR 0 31
115140: PUSH
115141: LD_VAR 0 4
115145: PUSH
115146: LD_VAR 0 7
115150: ARRAY
115151: DIFF
115152: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
115153: LD_ADDR_VAR 0 4
115157: PUSH
115158: LD_VAR 0 4
115162: PPUSH
115163: LD_VAR 0 7
115167: PPUSH
115168: CALL_OW 3
115172: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
115173: LD_ADDR_VAR 0 16
115177: PUSH
115178: LD_VAR 0 16
115182: PPUSH
115183: LD_VAR 0 7
115187: PPUSH
115188: CALL_OW 3
115192: ST_TO_ADDR
// continue ;
115193: GO 115033
// end ; if f_repair then
115195: LD_VAR 0 22
115199: IFFALSE 115688
// begin if GetType ( group [ i ] ) = unit_vehicle then
115201: LD_VAR 0 4
115205: PUSH
115206: LD_VAR 0 7
115210: ARRAY
115211: PPUSH
115212: CALL_OW 247
115216: PUSH
115217: LD_INT 2
115219: EQUAL
115220: IFFALSE 115410
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
115222: LD_VAR 0 4
115226: PUSH
115227: LD_VAR 0 7
115231: ARRAY
115232: PPUSH
115233: CALL_OW 256
115237: PUSH
115238: LD_INT 700
115240: LESS
115241: PUSH
115242: LD_VAR 0 4
115246: PUSH
115247: LD_VAR 0 7
115251: ARRAY
115252: PUSH
115253: LD_VAR 0 32
115257: IN
115258: NOT
115259: AND
115260: IFFALSE 115284
// to_repair := to_repair union group [ i ] ;
115262: LD_ADDR_VAR 0 32
115266: PUSH
115267: LD_VAR 0 32
115271: PUSH
115272: LD_VAR 0 4
115276: PUSH
115277: LD_VAR 0 7
115281: ARRAY
115282: UNION
115283: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
115284: LD_VAR 0 4
115288: PUSH
115289: LD_VAR 0 7
115293: ARRAY
115294: PPUSH
115295: CALL_OW 256
115299: PUSH
115300: LD_INT 1000
115302: EQUAL
115303: PUSH
115304: LD_VAR 0 4
115308: PUSH
115309: LD_VAR 0 7
115313: ARRAY
115314: PUSH
115315: LD_VAR 0 32
115319: IN
115320: AND
115321: IFFALSE 115345
// to_repair := to_repair diff group [ i ] ;
115323: LD_ADDR_VAR 0 32
115327: PUSH
115328: LD_VAR 0 32
115332: PUSH
115333: LD_VAR 0 4
115337: PUSH
115338: LD_VAR 0 7
115342: ARRAY
115343: DIFF
115344: ST_TO_ADDR
// if group [ i ] in to_repair then
115345: LD_VAR 0 4
115349: PUSH
115350: LD_VAR 0 7
115354: ARRAY
115355: PUSH
115356: LD_VAR 0 32
115360: IN
115361: IFFALSE 115408
// begin if not IsInArea ( group [ i ] , f_repair ) then
115363: LD_VAR 0 4
115367: PUSH
115368: LD_VAR 0 7
115372: ARRAY
115373: PPUSH
115374: LD_VAR 0 22
115378: PPUSH
115379: CALL_OW 308
115383: NOT
115384: IFFALSE 115406
// ComMoveToArea ( group [ i ] , f_repair ) ;
115386: LD_VAR 0 4
115390: PUSH
115391: LD_VAR 0 7
115395: ARRAY
115396: PPUSH
115397: LD_VAR 0 22
115401: PPUSH
115402: CALL_OW 113
// continue ;
115406: GO 115033
// end ; end else
115408: GO 115688
// if group [ i ] in repairs then
115410: LD_VAR 0 4
115414: PUSH
115415: LD_VAR 0 7
115419: ARRAY
115420: PUSH
115421: LD_VAR 0 33
115425: IN
115426: IFFALSE 115688
// begin if IsInUnit ( group [ i ] ) then
115428: LD_VAR 0 4
115432: PUSH
115433: LD_VAR 0 7
115437: ARRAY
115438: PPUSH
115439: CALL_OW 310
115443: IFFALSE 115511
// begin z := IsInUnit ( group [ i ] ) ;
115445: LD_ADDR_VAR 0 13
115449: PUSH
115450: LD_VAR 0 4
115454: PUSH
115455: LD_VAR 0 7
115459: ARRAY
115460: PPUSH
115461: CALL_OW 310
115465: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
115466: LD_VAR 0 13
115470: PUSH
115471: LD_VAR 0 32
115475: IN
115476: PUSH
115477: LD_VAR 0 13
115481: PPUSH
115482: LD_VAR 0 22
115486: PPUSH
115487: CALL_OW 308
115491: AND
115492: IFFALSE 115509
// ComExitVehicle ( group [ i ] ) ;
115494: LD_VAR 0 4
115498: PUSH
115499: LD_VAR 0 7
115503: ARRAY
115504: PPUSH
115505: CALL_OW 121
// end else
115509: GO 115688
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
115511: LD_ADDR_VAR 0 13
115515: PUSH
115516: LD_VAR 0 4
115520: PPUSH
115521: LD_INT 95
115523: PUSH
115524: LD_VAR 0 22
115528: PUSH
115529: EMPTY
115530: LIST
115531: LIST
115532: PUSH
115533: LD_INT 58
115535: PUSH
115536: EMPTY
115537: LIST
115538: PUSH
115539: EMPTY
115540: LIST
115541: LIST
115542: PPUSH
115543: CALL_OW 72
115547: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
115548: LD_VAR 0 4
115552: PUSH
115553: LD_VAR 0 7
115557: ARRAY
115558: PPUSH
115559: CALL_OW 314
115563: NOT
115564: IFFALSE 115686
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
115566: LD_ADDR_VAR 0 10
115570: PUSH
115571: LD_VAR 0 13
115575: PPUSH
115576: LD_VAR 0 4
115580: PUSH
115581: LD_VAR 0 7
115585: ARRAY
115586: PPUSH
115587: CALL_OW 74
115591: ST_TO_ADDR
// if not x then
115592: LD_VAR 0 10
115596: NOT
115597: IFFALSE 115601
// continue ;
115599: GO 115033
// if GetLives ( x ) < 1000 then
115601: LD_VAR 0 10
115605: PPUSH
115606: CALL_OW 256
115610: PUSH
115611: LD_INT 1000
115613: LESS
115614: IFFALSE 115638
// ComRepairVehicle ( group [ i ] , x ) else
115616: LD_VAR 0 4
115620: PUSH
115621: LD_VAR 0 7
115625: ARRAY
115626: PPUSH
115627: LD_VAR 0 10
115631: PPUSH
115632: CALL_OW 129
115636: GO 115686
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
115638: LD_VAR 0 23
115642: PUSH
115643: LD_VAR 0 4
115647: PUSH
115648: LD_VAR 0 7
115652: ARRAY
115653: PPUSH
115654: CALL_OW 256
115658: PUSH
115659: LD_INT 1000
115661: LESS
115662: AND
115663: NOT
115664: IFFALSE 115686
// ComEnterUnit ( group [ i ] , x ) ;
115666: LD_VAR 0 4
115670: PUSH
115671: LD_VAR 0 7
115675: ARRAY
115676: PPUSH
115677: LD_VAR 0 10
115681: PPUSH
115682: CALL_OW 120
// end ; continue ;
115686: GO 115033
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
115688: LD_VAR 0 23
115692: PUSH
115693: LD_VAR 0 4
115697: PUSH
115698: LD_VAR 0 7
115702: ARRAY
115703: PPUSH
115704: CALL_OW 247
115708: PUSH
115709: LD_INT 1
115711: EQUAL
115712: AND
115713: IFFALSE 116191
// begin if group [ i ] in healers then
115715: LD_VAR 0 4
115719: PUSH
115720: LD_VAR 0 7
115724: ARRAY
115725: PUSH
115726: LD_VAR 0 31
115730: IN
115731: IFFALSE 116004
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
115733: LD_VAR 0 4
115737: PUSH
115738: LD_VAR 0 7
115742: ARRAY
115743: PPUSH
115744: LD_VAR 0 23
115748: PPUSH
115749: CALL_OW 308
115753: NOT
115754: PUSH
115755: LD_VAR 0 4
115759: PUSH
115760: LD_VAR 0 7
115764: ARRAY
115765: PPUSH
115766: CALL_OW 314
115770: NOT
115771: AND
115772: IFFALSE 115796
// ComMoveToArea ( group [ i ] , f_heal ) else
115774: LD_VAR 0 4
115778: PUSH
115779: LD_VAR 0 7
115783: ARRAY
115784: PPUSH
115785: LD_VAR 0 23
115789: PPUSH
115790: CALL_OW 113
115794: GO 116002
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
115796: LD_VAR 0 4
115800: PUSH
115801: LD_VAR 0 7
115805: ARRAY
115806: PPUSH
115807: CALL 87576 0 1
115811: PPUSH
115812: CALL_OW 256
115816: PUSH
115817: LD_INT 1000
115819: EQUAL
115820: IFFALSE 115839
// ComStop ( group [ i ] ) else
115822: LD_VAR 0 4
115826: PUSH
115827: LD_VAR 0 7
115831: ARRAY
115832: PPUSH
115833: CALL_OW 141
115837: GO 116002
// if not HasTask ( group [ i ] ) and to_heal then
115839: LD_VAR 0 4
115843: PUSH
115844: LD_VAR 0 7
115848: ARRAY
115849: PPUSH
115850: CALL_OW 314
115854: NOT
115855: PUSH
115856: LD_VAR 0 30
115860: AND
115861: IFFALSE 116002
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
115863: LD_ADDR_VAR 0 13
115867: PUSH
115868: LD_VAR 0 30
115872: PPUSH
115873: LD_INT 3
115875: PUSH
115876: LD_INT 54
115878: PUSH
115879: EMPTY
115880: LIST
115881: PUSH
115882: EMPTY
115883: LIST
115884: LIST
115885: PPUSH
115886: CALL_OW 72
115890: PPUSH
115891: LD_VAR 0 4
115895: PUSH
115896: LD_VAR 0 7
115900: ARRAY
115901: PPUSH
115902: CALL_OW 74
115906: ST_TO_ADDR
// if z then
115907: LD_VAR 0 13
115911: IFFALSE 116002
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
115913: LD_INT 91
115915: PUSH
115916: LD_VAR 0 13
115920: PUSH
115921: LD_INT 10
115923: PUSH
115924: EMPTY
115925: LIST
115926: LIST
115927: LIST
115928: PUSH
115929: LD_INT 81
115931: PUSH
115932: LD_VAR 0 13
115936: PPUSH
115937: CALL_OW 255
115941: PUSH
115942: EMPTY
115943: LIST
115944: LIST
115945: PUSH
115946: EMPTY
115947: LIST
115948: LIST
115949: PPUSH
115950: CALL_OW 69
115954: PUSH
115955: LD_INT 0
115957: EQUAL
115958: IFFALSE 115982
// ComHeal ( group [ i ] , z ) else
115960: LD_VAR 0 4
115964: PUSH
115965: LD_VAR 0 7
115969: ARRAY
115970: PPUSH
115971: LD_VAR 0 13
115975: PPUSH
115976: CALL_OW 128
115980: GO 116002
// ComMoveToArea ( group [ i ] , f_heal ) ;
115982: LD_VAR 0 4
115986: PUSH
115987: LD_VAR 0 7
115991: ARRAY
115992: PPUSH
115993: LD_VAR 0 23
115997: PPUSH
115998: CALL_OW 113
// end ; continue ;
116002: GO 115033
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
116004: LD_VAR 0 4
116008: PUSH
116009: LD_VAR 0 7
116013: ARRAY
116014: PPUSH
116015: CALL_OW 256
116019: PUSH
116020: LD_INT 700
116022: LESS
116023: PUSH
116024: LD_VAR 0 4
116028: PUSH
116029: LD_VAR 0 7
116033: ARRAY
116034: PUSH
116035: LD_VAR 0 30
116039: IN
116040: NOT
116041: AND
116042: IFFALSE 116066
// to_heal := to_heal union group [ i ] ;
116044: LD_ADDR_VAR 0 30
116048: PUSH
116049: LD_VAR 0 30
116053: PUSH
116054: LD_VAR 0 4
116058: PUSH
116059: LD_VAR 0 7
116063: ARRAY
116064: UNION
116065: ST_TO_ADDR
// if group [ i ] in to_heal then
116066: LD_VAR 0 4
116070: PUSH
116071: LD_VAR 0 7
116075: ARRAY
116076: PUSH
116077: LD_VAR 0 30
116081: IN
116082: IFFALSE 116191
// begin if GetLives ( group [ i ] ) = 1000 then
116084: LD_VAR 0 4
116088: PUSH
116089: LD_VAR 0 7
116093: ARRAY
116094: PPUSH
116095: CALL_OW 256
116099: PUSH
116100: LD_INT 1000
116102: EQUAL
116103: IFFALSE 116129
// to_heal := to_heal diff group [ i ] else
116105: LD_ADDR_VAR 0 30
116109: PUSH
116110: LD_VAR 0 30
116114: PUSH
116115: LD_VAR 0 4
116119: PUSH
116120: LD_VAR 0 7
116124: ARRAY
116125: DIFF
116126: ST_TO_ADDR
116127: GO 116191
// begin if not IsInArea ( group [ i ] , to_heal ) then
116129: LD_VAR 0 4
116133: PUSH
116134: LD_VAR 0 7
116138: ARRAY
116139: PPUSH
116140: LD_VAR 0 30
116144: PPUSH
116145: CALL_OW 308
116149: NOT
116150: IFFALSE 116174
// ComMoveToArea ( group [ i ] , f_heal ) else
116152: LD_VAR 0 4
116156: PUSH
116157: LD_VAR 0 7
116161: ARRAY
116162: PPUSH
116163: LD_VAR 0 23
116167: PPUSH
116168: CALL_OW 113
116172: GO 116189
// ComHold ( group [ i ] ) ;
116174: LD_VAR 0 4
116178: PUSH
116179: LD_VAR 0 7
116183: ARRAY
116184: PPUSH
116185: CALL_OW 140
// continue ;
116189: GO 115033
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
116191: LD_VAR 0 4
116195: PUSH
116196: LD_VAR 0 7
116200: ARRAY
116201: PPUSH
116202: LD_INT 10
116204: PPUSH
116205: CALL 85347 0 2
116209: NOT
116210: PUSH
116211: LD_VAR 0 16
116215: PUSH
116216: LD_VAR 0 7
116220: ARRAY
116221: PUSH
116222: EMPTY
116223: EQUAL
116224: NOT
116225: AND
116226: IFFALSE 116492
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
116228: LD_VAR 0 4
116232: PUSH
116233: LD_VAR 0 7
116237: ARRAY
116238: PPUSH
116239: CALL_OW 262
116243: PUSH
116244: LD_INT 1
116246: PUSH
116247: LD_INT 2
116249: PUSH
116250: EMPTY
116251: LIST
116252: LIST
116253: IN
116254: IFFALSE 116295
// if GetFuel ( group [ i ] ) < 10 then
116256: LD_VAR 0 4
116260: PUSH
116261: LD_VAR 0 7
116265: ARRAY
116266: PPUSH
116267: CALL_OW 261
116271: PUSH
116272: LD_INT 10
116274: LESS
116275: IFFALSE 116295
// SetFuel ( group [ i ] , 12 ) ;
116277: LD_VAR 0 4
116281: PUSH
116282: LD_VAR 0 7
116286: ARRAY
116287: PPUSH
116288: LD_INT 12
116290: PPUSH
116291: CALL_OW 240
// if units_path [ i ] then
116295: LD_VAR 0 16
116299: PUSH
116300: LD_VAR 0 7
116304: ARRAY
116305: IFFALSE 116490
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
116307: LD_VAR 0 4
116311: PUSH
116312: LD_VAR 0 7
116316: ARRAY
116317: PPUSH
116318: LD_VAR 0 16
116322: PUSH
116323: LD_VAR 0 7
116327: ARRAY
116328: PUSH
116329: LD_INT 1
116331: ARRAY
116332: PUSH
116333: LD_INT 1
116335: ARRAY
116336: PPUSH
116337: LD_VAR 0 16
116341: PUSH
116342: LD_VAR 0 7
116346: ARRAY
116347: PUSH
116348: LD_INT 1
116350: ARRAY
116351: PUSH
116352: LD_INT 2
116354: ARRAY
116355: PPUSH
116356: CALL_OW 297
116360: PUSH
116361: LD_INT 6
116363: GREATER
116364: IFFALSE 116439
// begin if not HasTask ( group [ i ] ) then
116366: LD_VAR 0 4
116370: PUSH
116371: LD_VAR 0 7
116375: ARRAY
116376: PPUSH
116377: CALL_OW 314
116381: NOT
116382: IFFALSE 116437
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
116384: LD_VAR 0 4
116388: PUSH
116389: LD_VAR 0 7
116393: ARRAY
116394: PPUSH
116395: LD_VAR 0 16
116399: PUSH
116400: LD_VAR 0 7
116404: ARRAY
116405: PUSH
116406: LD_INT 1
116408: ARRAY
116409: PUSH
116410: LD_INT 1
116412: ARRAY
116413: PPUSH
116414: LD_VAR 0 16
116418: PUSH
116419: LD_VAR 0 7
116423: ARRAY
116424: PUSH
116425: LD_INT 1
116427: ARRAY
116428: PUSH
116429: LD_INT 2
116431: ARRAY
116432: PPUSH
116433: CALL_OW 114
// end else
116437: GO 116490
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
116439: LD_ADDR_VAR 0 15
116443: PUSH
116444: LD_VAR 0 16
116448: PUSH
116449: LD_VAR 0 7
116453: ARRAY
116454: PPUSH
116455: LD_INT 1
116457: PPUSH
116458: CALL_OW 3
116462: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
116463: LD_ADDR_VAR 0 16
116467: PUSH
116468: LD_VAR 0 16
116472: PPUSH
116473: LD_VAR 0 7
116477: PPUSH
116478: LD_VAR 0 15
116482: PPUSH
116483: CALL_OW 1
116487: ST_TO_ADDR
// continue ;
116488: GO 115033
// end ; end ; end else
116490: GO 119154
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
116492: LD_ADDR_VAR 0 14
116496: PUSH
116497: LD_INT 81
116499: PUSH
116500: LD_VAR 0 4
116504: PUSH
116505: LD_VAR 0 7
116509: ARRAY
116510: PPUSH
116511: CALL_OW 255
116515: PUSH
116516: EMPTY
116517: LIST
116518: LIST
116519: PPUSH
116520: CALL_OW 69
116524: ST_TO_ADDR
// if not tmp then
116525: LD_VAR 0 14
116529: NOT
116530: IFFALSE 116534
// continue ;
116532: GO 115033
// if f_ignore_area then
116534: LD_VAR 0 17
116538: IFFALSE 116626
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
116540: LD_ADDR_VAR 0 15
116544: PUSH
116545: LD_VAR 0 14
116549: PPUSH
116550: LD_INT 3
116552: PUSH
116553: LD_INT 92
116555: PUSH
116556: LD_VAR 0 17
116560: PUSH
116561: LD_INT 1
116563: ARRAY
116564: PUSH
116565: LD_VAR 0 17
116569: PUSH
116570: LD_INT 2
116572: ARRAY
116573: PUSH
116574: LD_VAR 0 17
116578: PUSH
116579: LD_INT 3
116581: ARRAY
116582: PUSH
116583: EMPTY
116584: LIST
116585: LIST
116586: LIST
116587: LIST
116588: PUSH
116589: EMPTY
116590: LIST
116591: LIST
116592: PPUSH
116593: CALL_OW 72
116597: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116598: LD_VAR 0 14
116602: PUSH
116603: LD_VAR 0 15
116607: DIFF
116608: IFFALSE 116626
// tmp := tmp diff tmp2 ;
116610: LD_ADDR_VAR 0 14
116614: PUSH
116615: LD_VAR 0 14
116619: PUSH
116620: LD_VAR 0 15
116624: DIFF
116625: ST_TO_ADDR
// end ; if not f_murder then
116626: LD_VAR 0 20
116630: NOT
116631: IFFALSE 116689
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
116633: LD_ADDR_VAR 0 15
116637: PUSH
116638: LD_VAR 0 14
116642: PPUSH
116643: LD_INT 3
116645: PUSH
116646: LD_INT 50
116648: PUSH
116649: EMPTY
116650: LIST
116651: PUSH
116652: EMPTY
116653: LIST
116654: LIST
116655: PPUSH
116656: CALL_OW 72
116660: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116661: LD_VAR 0 14
116665: PUSH
116666: LD_VAR 0 15
116670: DIFF
116671: IFFALSE 116689
// tmp := tmp diff tmp2 ;
116673: LD_ADDR_VAR 0 14
116677: PUSH
116678: LD_VAR 0 14
116682: PUSH
116683: LD_VAR 0 15
116687: DIFF
116688: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
116689: LD_ADDR_VAR 0 14
116693: PUSH
116694: LD_VAR 0 4
116698: PUSH
116699: LD_VAR 0 7
116703: ARRAY
116704: PPUSH
116705: LD_VAR 0 14
116709: PPUSH
116710: LD_INT 1
116712: PPUSH
116713: LD_INT 1
116715: PPUSH
116716: CALL 58259 0 4
116720: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
116721: LD_VAR 0 4
116725: PUSH
116726: LD_VAR 0 7
116730: ARRAY
116731: PPUSH
116732: CALL_OW 257
116736: PUSH
116737: LD_INT 1
116739: EQUAL
116740: IFFALSE 117188
// begin if WantPlant ( group [ i ] ) then
116742: LD_VAR 0 4
116746: PUSH
116747: LD_VAR 0 7
116751: ARRAY
116752: PPUSH
116753: CALL 57760 0 1
116757: IFFALSE 116761
// continue ;
116759: GO 115033
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
116761: LD_VAR 0 18
116765: PUSH
116766: LD_VAR 0 4
116770: PUSH
116771: LD_VAR 0 7
116775: ARRAY
116776: PPUSH
116777: CALL_OW 310
116781: NOT
116782: AND
116783: PUSH
116784: LD_VAR 0 14
116788: PUSH
116789: LD_INT 1
116791: ARRAY
116792: PUSH
116793: LD_VAR 0 14
116797: PPUSH
116798: LD_INT 21
116800: PUSH
116801: LD_INT 2
116803: PUSH
116804: EMPTY
116805: LIST
116806: LIST
116807: PUSH
116808: LD_INT 58
116810: PUSH
116811: EMPTY
116812: LIST
116813: PUSH
116814: EMPTY
116815: LIST
116816: LIST
116817: PPUSH
116818: CALL_OW 72
116822: IN
116823: AND
116824: IFFALSE 116860
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
116826: LD_VAR 0 4
116830: PUSH
116831: LD_VAR 0 7
116835: ARRAY
116836: PPUSH
116837: LD_VAR 0 14
116841: PUSH
116842: LD_INT 1
116844: ARRAY
116845: PPUSH
116846: CALL_OW 120
// attacking := true ;
116850: LD_ADDR_VAR 0 29
116854: PUSH
116855: LD_INT 1
116857: ST_TO_ADDR
// continue ;
116858: GO 115033
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
116860: LD_VAR 0 26
116864: PUSH
116865: LD_VAR 0 4
116869: PUSH
116870: LD_VAR 0 7
116874: ARRAY
116875: PPUSH
116876: CALL_OW 257
116880: PUSH
116881: LD_INT 1
116883: EQUAL
116884: AND
116885: PUSH
116886: LD_VAR 0 4
116890: PUSH
116891: LD_VAR 0 7
116895: ARRAY
116896: PPUSH
116897: CALL_OW 256
116901: PUSH
116902: LD_INT 800
116904: LESS
116905: AND
116906: PUSH
116907: LD_VAR 0 4
116911: PUSH
116912: LD_VAR 0 7
116916: ARRAY
116917: PPUSH
116918: CALL_OW 318
116922: NOT
116923: AND
116924: IFFALSE 116941
// ComCrawl ( group [ i ] ) ;
116926: LD_VAR 0 4
116930: PUSH
116931: LD_VAR 0 7
116935: ARRAY
116936: PPUSH
116937: CALL_OW 137
// if f_mines then
116941: LD_VAR 0 21
116945: IFFALSE 117188
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
116947: LD_VAR 0 14
116951: PUSH
116952: LD_INT 1
116954: ARRAY
116955: PPUSH
116956: CALL_OW 247
116960: PUSH
116961: LD_INT 3
116963: EQUAL
116964: PUSH
116965: LD_VAR 0 14
116969: PUSH
116970: LD_INT 1
116972: ARRAY
116973: PUSH
116974: LD_VAR 0 27
116978: IN
116979: NOT
116980: AND
116981: IFFALSE 117188
// begin x := GetX ( tmp [ 1 ] ) ;
116983: LD_ADDR_VAR 0 10
116987: PUSH
116988: LD_VAR 0 14
116992: PUSH
116993: LD_INT 1
116995: ARRAY
116996: PPUSH
116997: CALL_OW 250
117001: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
117002: LD_ADDR_VAR 0 11
117006: PUSH
117007: LD_VAR 0 14
117011: PUSH
117012: LD_INT 1
117014: ARRAY
117015: PPUSH
117016: CALL_OW 251
117020: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
117021: LD_ADDR_VAR 0 12
117025: PUSH
117026: LD_VAR 0 4
117030: PUSH
117031: LD_VAR 0 7
117035: ARRAY
117036: PPUSH
117037: CALL 85432 0 1
117041: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
117042: LD_VAR 0 4
117046: PUSH
117047: LD_VAR 0 7
117051: ARRAY
117052: PPUSH
117053: LD_VAR 0 10
117057: PPUSH
117058: LD_VAR 0 11
117062: PPUSH
117063: LD_VAR 0 14
117067: PUSH
117068: LD_INT 1
117070: ARRAY
117071: PPUSH
117072: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
117076: LD_VAR 0 4
117080: PUSH
117081: LD_VAR 0 7
117085: ARRAY
117086: PPUSH
117087: LD_VAR 0 10
117091: PPUSH
117092: LD_VAR 0 12
117096: PPUSH
117097: LD_INT 7
117099: PPUSH
117100: CALL_OW 272
117104: PPUSH
117105: LD_VAR 0 11
117109: PPUSH
117110: LD_VAR 0 12
117114: PPUSH
117115: LD_INT 7
117117: PPUSH
117118: CALL_OW 273
117122: PPUSH
117123: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
117127: LD_VAR 0 4
117131: PUSH
117132: LD_VAR 0 7
117136: ARRAY
117137: PPUSH
117138: LD_INT 71
117140: PPUSH
117141: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
117145: LD_ADDR_VAR 0 27
117149: PUSH
117150: LD_VAR 0 27
117154: PPUSH
117155: LD_VAR 0 27
117159: PUSH
117160: LD_INT 1
117162: PLUS
117163: PPUSH
117164: LD_VAR 0 14
117168: PUSH
117169: LD_INT 1
117171: ARRAY
117172: PPUSH
117173: CALL_OW 1
117177: ST_TO_ADDR
// attacking := true ;
117178: LD_ADDR_VAR 0 29
117182: PUSH
117183: LD_INT 1
117185: ST_TO_ADDR
// continue ;
117186: GO 115033
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
117188: LD_VAR 0 4
117192: PUSH
117193: LD_VAR 0 7
117197: ARRAY
117198: PPUSH
117199: CALL_OW 257
117203: PUSH
117204: LD_INT 17
117206: EQUAL
117207: PUSH
117208: LD_VAR 0 4
117212: PUSH
117213: LD_VAR 0 7
117217: ARRAY
117218: PPUSH
117219: CALL_OW 110
117223: PUSH
117224: LD_INT 71
117226: EQUAL
117227: NOT
117228: AND
117229: IFFALSE 117375
// begin attacking := false ;
117231: LD_ADDR_VAR 0 29
117235: PUSH
117236: LD_INT 0
117238: ST_TO_ADDR
// k := 5 ;
117239: LD_ADDR_VAR 0 9
117243: PUSH
117244: LD_INT 5
117246: ST_TO_ADDR
// if tmp < k then
117247: LD_VAR 0 14
117251: PUSH
117252: LD_VAR 0 9
117256: LESS
117257: IFFALSE 117269
// k := tmp ;
117259: LD_ADDR_VAR 0 9
117263: PUSH
117264: LD_VAR 0 14
117268: ST_TO_ADDR
// for j = 1 to k do
117269: LD_ADDR_VAR 0 8
117273: PUSH
117274: DOUBLE
117275: LD_INT 1
117277: DEC
117278: ST_TO_ADDR
117279: LD_VAR 0 9
117283: PUSH
117284: FOR_TO
117285: IFFALSE 117373
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
117287: LD_VAR 0 14
117291: PUSH
117292: LD_VAR 0 8
117296: ARRAY
117297: PUSH
117298: LD_VAR 0 14
117302: PPUSH
117303: LD_INT 58
117305: PUSH
117306: EMPTY
117307: LIST
117308: PPUSH
117309: CALL_OW 72
117313: IN
117314: NOT
117315: IFFALSE 117371
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117317: LD_VAR 0 4
117321: PUSH
117322: LD_VAR 0 7
117326: ARRAY
117327: PPUSH
117328: LD_VAR 0 14
117332: PUSH
117333: LD_VAR 0 8
117337: ARRAY
117338: PPUSH
117339: CALL_OW 115
// attacking := true ;
117343: LD_ADDR_VAR 0 29
117347: PUSH
117348: LD_INT 1
117350: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
117351: LD_VAR 0 4
117355: PUSH
117356: LD_VAR 0 7
117360: ARRAY
117361: PPUSH
117362: LD_INT 71
117364: PPUSH
117365: CALL_OW 109
// continue ;
117369: GO 117284
// end ; end ;
117371: GO 117284
117373: POP
117374: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
117375: LD_VAR 0 4
117379: PUSH
117380: LD_VAR 0 7
117384: ARRAY
117385: PPUSH
117386: CALL_OW 257
117390: PUSH
117391: LD_INT 8
117393: EQUAL
117394: PUSH
117395: LD_VAR 0 4
117399: PUSH
117400: LD_VAR 0 7
117404: ARRAY
117405: PPUSH
117406: CALL_OW 264
117410: PUSH
117411: LD_INT 28
117413: PUSH
117414: LD_INT 45
117416: PUSH
117417: LD_INT 7
117419: PUSH
117420: LD_INT 47
117422: PUSH
117423: EMPTY
117424: LIST
117425: LIST
117426: LIST
117427: LIST
117428: IN
117429: OR
117430: IFFALSE 117686
// begin attacking := false ;
117432: LD_ADDR_VAR 0 29
117436: PUSH
117437: LD_INT 0
117439: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
117440: LD_VAR 0 14
117444: PUSH
117445: LD_INT 1
117447: ARRAY
117448: PPUSH
117449: CALL_OW 266
117453: PUSH
117454: LD_INT 32
117456: PUSH
117457: LD_INT 31
117459: PUSH
117460: LD_INT 33
117462: PUSH
117463: LD_INT 4
117465: PUSH
117466: LD_INT 5
117468: PUSH
117469: EMPTY
117470: LIST
117471: LIST
117472: LIST
117473: LIST
117474: LIST
117475: IN
117476: IFFALSE 117662
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
117478: LD_ADDR_VAR 0 9
117482: PUSH
117483: LD_VAR 0 14
117487: PUSH
117488: LD_INT 1
117490: ARRAY
117491: PPUSH
117492: CALL_OW 266
117496: PPUSH
117497: LD_VAR 0 14
117501: PUSH
117502: LD_INT 1
117504: ARRAY
117505: PPUSH
117506: CALL_OW 250
117510: PPUSH
117511: LD_VAR 0 14
117515: PUSH
117516: LD_INT 1
117518: ARRAY
117519: PPUSH
117520: CALL_OW 251
117524: PPUSH
117525: LD_VAR 0 14
117529: PUSH
117530: LD_INT 1
117532: ARRAY
117533: PPUSH
117534: CALL_OW 254
117538: PPUSH
117539: LD_VAR 0 14
117543: PUSH
117544: LD_INT 1
117546: ARRAY
117547: PPUSH
117548: CALL_OW 248
117552: PPUSH
117553: LD_INT 0
117555: PPUSH
117556: CALL 66802 0 6
117560: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
117561: LD_ADDR_VAR 0 8
117565: PUSH
117566: LD_VAR 0 4
117570: PUSH
117571: LD_VAR 0 7
117575: ARRAY
117576: PPUSH
117577: LD_VAR 0 9
117581: PPUSH
117582: CALL 85545 0 2
117586: ST_TO_ADDR
// if j then
117587: LD_VAR 0 8
117591: IFFALSE 117660
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
117593: LD_VAR 0 8
117597: PUSH
117598: LD_INT 1
117600: ARRAY
117601: PPUSH
117602: LD_VAR 0 8
117606: PUSH
117607: LD_INT 2
117609: ARRAY
117610: PPUSH
117611: CALL_OW 488
117615: IFFALSE 117660
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
117617: LD_VAR 0 4
117621: PUSH
117622: LD_VAR 0 7
117626: ARRAY
117627: PPUSH
117628: LD_VAR 0 8
117632: PUSH
117633: LD_INT 1
117635: ARRAY
117636: PPUSH
117637: LD_VAR 0 8
117641: PUSH
117642: LD_INT 2
117644: ARRAY
117645: PPUSH
117646: CALL_OW 116
// attacking := true ;
117650: LD_ADDR_VAR 0 29
117654: PUSH
117655: LD_INT 1
117657: ST_TO_ADDR
// continue ;
117658: GO 115033
// end ; end else
117660: GO 117686
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117662: LD_VAR 0 4
117666: PUSH
117667: LD_VAR 0 7
117671: ARRAY
117672: PPUSH
117673: LD_VAR 0 14
117677: PUSH
117678: LD_INT 1
117680: ARRAY
117681: PPUSH
117682: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
117686: LD_VAR 0 4
117690: PUSH
117691: LD_VAR 0 7
117695: ARRAY
117696: PPUSH
117697: CALL_OW 265
117701: PUSH
117702: LD_INT 11
117704: EQUAL
117705: IFFALSE 117983
// begin k := 10 ;
117707: LD_ADDR_VAR 0 9
117711: PUSH
117712: LD_INT 10
117714: ST_TO_ADDR
// x := 0 ;
117715: LD_ADDR_VAR 0 10
117719: PUSH
117720: LD_INT 0
117722: ST_TO_ADDR
// if tmp < k then
117723: LD_VAR 0 14
117727: PUSH
117728: LD_VAR 0 9
117732: LESS
117733: IFFALSE 117745
// k := tmp ;
117735: LD_ADDR_VAR 0 9
117739: PUSH
117740: LD_VAR 0 14
117744: ST_TO_ADDR
// for j = k downto 1 do
117745: LD_ADDR_VAR 0 8
117749: PUSH
117750: DOUBLE
117751: LD_VAR 0 9
117755: INC
117756: ST_TO_ADDR
117757: LD_INT 1
117759: PUSH
117760: FOR_DOWNTO
117761: IFFALSE 117836
// begin if GetType ( tmp [ j ] ) = unit_human then
117763: LD_VAR 0 14
117767: PUSH
117768: LD_VAR 0 8
117772: ARRAY
117773: PPUSH
117774: CALL_OW 247
117778: PUSH
117779: LD_INT 1
117781: EQUAL
117782: IFFALSE 117834
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
117784: LD_VAR 0 4
117788: PUSH
117789: LD_VAR 0 7
117793: ARRAY
117794: PPUSH
117795: LD_VAR 0 14
117799: PUSH
117800: LD_VAR 0 8
117804: ARRAY
117805: PPUSH
117806: CALL 85799 0 2
// x := tmp [ j ] ;
117810: LD_ADDR_VAR 0 10
117814: PUSH
117815: LD_VAR 0 14
117819: PUSH
117820: LD_VAR 0 8
117824: ARRAY
117825: ST_TO_ADDR
// attacking := true ;
117826: LD_ADDR_VAR 0 29
117830: PUSH
117831: LD_INT 1
117833: ST_TO_ADDR
// end ; end ;
117834: GO 117760
117836: POP
117837: POP
// if not x then
117838: LD_VAR 0 10
117842: NOT
117843: IFFALSE 117983
// begin attacking := true ;
117845: LD_ADDR_VAR 0 29
117849: PUSH
117850: LD_INT 1
117852: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
117853: LD_VAR 0 4
117857: PUSH
117858: LD_VAR 0 7
117862: ARRAY
117863: PPUSH
117864: CALL_OW 250
117868: PPUSH
117869: LD_VAR 0 4
117873: PUSH
117874: LD_VAR 0 7
117878: ARRAY
117879: PPUSH
117880: CALL_OW 251
117884: PPUSH
117885: CALL_OW 546
117889: PUSH
117890: LD_INT 2
117892: ARRAY
117893: PUSH
117894: LD_VAR 0 14
117898: PUSH
117899: LD_INT 1
117901: ARRAY
117902: PPUSH
117903: CALL_OW 250
117907: PPUSH
117908: LD_VAR 0 14
117912: PUSH
117913: LD_INT 1
117915: ARRAY
117916: PPUSH
117917: CALL_OW 251
117921: PPUSH
117922: CALL_OW 546
117926: PUSH
117927: LD_INT 2
117929: ARRAY
117930: EQUAL
117931: IFFALSE 117959
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
117933: LD_VAR 0 4
117937: PUSH
117938: LD_VAR 0 7
117942: ARRAY
117943: PPUSH
117944: LD_VAR 0 14
117948: PUSH
117949: LD_INT 1
117951: ARRAY
117952: PPUSH
117953: CALL 85799 0 2
117957: GO 117983
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117959: LD_VAR 0 4
117963: PUSH
117964: LD_VAR 0 7
117968: ARRAY
117969: PPUSH
117970: LD_VAR 0 14
117974: PUSH
117975: LD_INT 1
117977: ARRAY
117978: PPUSH
117979: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
117983: LD_VAR 0 4
117987: PUSH
117988: LD_VAR 0 7
117992: ARRAY
117993: PPUSH
117994: CALL_OW 264
117998: PUSH
117999: LD_INT 29
118001: EQUAL
118002: IFFALSE 118368
// begin if WantsToAttack ( group [ i ] ) in bombed then
118004: LD_VAR 0 4
118008: PUSH
118009: LD_VAR 0 7
118013: ARRAY
118014: PPUSH
118015: CALL_OW 319
118019: PUSH
118020: LD_VAR 0 28
118024: IN
118025: IFFALSE 118029
// continue ;
118027: GO 115033
// k := 8 ;
118029: LD_ADDR_VAR 0 9
118033: PUSH
118034: LD_INT 8
118036: ST_TO_ADDR
// x := 0 ;
118037: LD_ADDR_VAR 0 10
118041: PUSH
118042: LD_INT 0
118044: ST_TO_ADDR
// if tmp < k then
118045: LD_VAR 0 14
118049: PUSH
118050: LD_VAR 0 9
118054: LESS
118055: IFFALSE 118067
// k := tmp ;
118057: LD_ADDR_VAR 0 9
118061: PUSH
118062: LD_VAR 0 14
118066: ST_TO_ADDR
// for j = 1 to k do
118067: LD_ADDR_VAR 0 8
118071: PUSH
118072: DOUBLE
118073: LD_INT 1
118075: DEC
118076: ST_TO_ADDR
118077: LD_VAR 0 9
118081: PUSH
118082: FOR_TO
118083: IFFALSE 118215
// begin if GetType ( tmp [ j ] ) = unit_building then
118085: LD_VAR 0 14
118089: PUSH
118090: LD_VAR 0 8
118094: ARRAY
118095: PPUSH
118096: CALL_OW 247
118100: PUSH
118101: LD_INT 3
118103: EQUAL
118104: IFFALSE 118213
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
118106: LD_VAR 0 14
118110: PUSH
118111: LD_VAR 0 8
118115: ARRAY
118116: PUSH
118117: LD_VAR 0 28
118121: IN
118122: NOT
118123: PUSH
118124: LD_VAR 0 14
118128: PUSH
118129: LD_VAR 0 8
118133: ARRAY
118134: PPUSH
118135: CALL_OW 313
118139: AND
118140: IFFALSE 118213
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118142: LD_VAR 0 4
118146: PUSH
118147: LD_VAR 0 7
118151: ARRAY
118152: PPUSH
118153: LD_VAR 0 14
118157: PUSH
118158: LD_VAR 0 8
118162: ARRAY
118163: PPUSH
118164: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
118168: LD_ADDR_VAR 0 28
118172: PUSH
118173: LD_VAR 0 28
118177: PPUSH
118178: LD_VAR 0 28
118182: PUSH
118183: LD_INT 1
118185: PLUS
118186: PPUSH
118187: LD_VAR 0 14
118191: PUSH
118192: LD_VAR 0 8
118196: ARRAY
118197: PPUSH
118198: CALL_OW 1
118202: ST_TO_ADDR
// attacking := true ;
118203: LD_ADDR_VAR 0 29
118207: PUSH
118208: LD_INT 1
118210: ST_TO_ADDR
// break ;
118211: GO 118215
// end ; end ;
118213: GO 118082
118215: POP
118216: POP
// if not attacking and f_attack_depot then
118217: LD_VAR 0 29
118221: NOT
118222: PUSH
118223: LD_VAR 0 25
118227: AND
118228: IFFALSE 118323
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118230: LD_ADDR_VAR 0 13
118234: PUSH
118235: LD_VAR 0 14
118239: PPUSH
118240: LD_INT 2
118242: PUSH
118243: LD_INT 30
118245: PUSH
118246: LD_INT 0
118248: PUSH
118249: EMPTY
118250: LIST
118251: LIST
118252: PUSH
118253: LD_INT 30
118255: PUSH
118256: LD_INT 1
118258: PUSH
118259: EMPTY
118260: LIST
118261: LIST
118262: PUSH
118263: EMPTY
118264: LIST
118265: LIST
118266: LIST
118267: PPUSH
118268: CALL_OW 72
118272: ST_TO_ADDR
// if z then
118273: LD_VAR 0 13
118277: IFFALSE 118323
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
118279: LD_VAR 0 4
118283: PUSH
118284: LD_VAR 0 7
118288: ARRAY
118289: PPUSH
118290: LD_VAR 0 13
118294: PPUSH
118295: LD_VAR 0 4
118299: PUSH
118300: LD_VAR 0 7
118304: ARRAY
118305: PPUSH
118306: CALL_OW 74
118310: PPUSH
118311: CALL_OW 115
// attacking := true ;
118315: LD_ADDR_VAR 0 29
118319: PUSH
118320: LD_INT 1
118322: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
118323: LD_VAR 0 4
118327: PUSH
118328: LD_VAR 0 7
118332: ARRAY
118333: PPUSH
118334: CALL_OW 256
118338: PUSH
118339: LD_INT 500
118341: LESS
118342: IFFALSE 118368
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118344: LD_VAR 0 4
118348: PUSH
118349: LD_VAR 0 7
118353: ARRAY
118354: PPUSH
118355: LD_VAR 0 14
118359: PUSH
118360: LD_INT 1
118362: ARRAY
118363: PPUSH
118364: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
118368: LD_VAR 0 4
118372: PUSH
118373: LD_VAR 0 7
118377: ARRAY
118378: PPUSH
118379: CALL_OW 264
118383: PUSH
118384: LD_INT 49
118386: EQUAL
118387: IFFALSE 118508
// begin if not HasTask ( group [ i ] ) then
118389: LD_VAR 0 4
118393: PUSH
118394: LD_VAR 0 7
118398: ARRAY
118399: PPUSH
118400: CALL_OW 314
118404: NOT
118405: IFFALSE 118508
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
118407: LD_ADDR_VAR 0 9
118411: PUSH
118412: LD_INT 81
118414: PUSH
118415: LD_VAR 0 4
118419: PUSH
118420: LD_VAR 0 7
118424: ARRAY
118425: PPUSH
118426: CALL_OW 255
118430: PUSH
118431: EMPTY
118432: LIST
118433: LIST
118434: PPUSH
118435: CALL_OW 69
118439: PPUSH
118440: LD_VAR 0 4
118444: PUSH
118445: LD_VAR 0 7
118449: ARRAY
118450: PPUSH
118451: CALL_OW 74
118455: ST_TO_ADDR
// if k then
118456: LD_VAR 0 9
118460: IFFALSE 118508
// if GetDistUnits ( group [ i ] , k ) > 10 then
118462: LD_VAR 0 4
118466: PUSH
118467: LD_VAR 0 7
118471: ARRAY
118472: PPUSH
118473: LD_VAR 0 9
118477: PPUSH
118478: CALL_OW 296
118482: PUSH
118483: LD_INT 10
118485: GREATER
118486: IFFALSE 118508
// ComMoveUnit ( group [ i ] , k ) ;
118488: LD_VAR 0 4
118492: PUSH
118493: LD_VAR 0 7
118497: ARRAY
118498: PPUSH
118499: LD_VAR 0 9
118503: PPUSH
118504: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
118508: LD_VAR 0 4
118512: PUSH
118513: LD_VAR 0 7
118517: ARRAY
118518: PPUSH
118519: CALL_OW 256
118523: PUSH
118524: LD_INT 250
118526: LESS
118527: PUSH
118528: LD_VAR 0 4
118532: PUSH
118533: LD_VAR 0 7
118537: ARRAY
118538: PUSH
118539: LD_INT 21
118541: PUSH
118542: LD_INT 2
118544: PUSH
118545: EMPTY
118546: LIST
118547: LIST
118548: PUSH
118549: LD_INT 23
118551: PUSH
118552: LD_INT 2
118554: PUSH
118555: EMPTY
118556: LIST
118557: LIST
118558: PUSH
118559: EMPTY
118560: LIST
118561: LIST
118562: PPUSH
118563: CALL_OW 69
118567: IN
118568: AND
118569: IFFALSE 118694
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
118571: LD_ADDR_VAR 0 9
118575: PUSH
118576: LD_OWVAR 3
118580: PUSH
118581: LD_VAR 0 4
118585: PUSH
118586: LD_VAR 0 7
118590: ARRAY
118591: DIFF
118592: PPUSH
118593: LD_VAR 0 4
118597: PUSH
118598: LD_VAR 0 7
118602: ARRAY
118603: PPUSH
118604: CALL_OW 74
118608: ST_TO_ADDR
// if not k then
118609: LD_VAR 0 9
118613: NOT
118614: IFFALSE 118618
// continue ;
118616: GO 115033
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
118618: LD_VAR 0 9
118622: PUSH
118623: LD_INT 81
118625: PUSH
118626: LD_VAR 0 4
118630: PUSH
118631: LD_VAR 0 7
118635: ARRAY
118636: PPUSH
118637: CALL_OW 255
118641: PUSH
118642: EMPTY
118643: LIST
118644: LIST
118645: PPUSH
118646: CALL_OW 69
118650: IN
118651: PUSH
118652: LD_VAR 0 9
118656: PPUSH
118657: LD_VAR 0 4
118661: PUSH
118662: LD_VAR 0 7
118666: ARRAY
118667: PPUSH
118668: CALL_OW 296
118672: PUSH
118673: LD_INT 5
118675: LESS
118676: AND
118677: IFFALSE 118694
// ComAutodestruct ( group [ i ] ) ;
118679: LD_VAR 0 4
118683: PUSH
118684: LD_VAR 0 7
118688: ARRAY
118689: PPUSH
118690: CALL 85697 0 1
// end ; if f_attack_depot then
118694: LD_VAR 0 25
118698: IFFALSE 118810
// begin k := 6 ;
118700: LD_ADDR_VAR 0 9
118704: PUSH
118705: LD_INT 6
118707: ST_TO_ADDR
// if tmp < k then
118708: LD_VAR 0 14
118712: PUSH
118713: LD_VAR 0 9
118717: LESS
118718: IFFALSE 118730
// k := tmp ;
118720: LD_ADDR_VAR 0 9
118724: PUSH
118725: LD_VAR 0 14
118729: ST_TO_ADDR
// for j = 1 to k do
118730: LD_ADDR_VAR 0 8
118734: PUSH
118735: DOUBLE
118736: LD_INT 1
118738: DEC
118739: ST_TO_ADDR
118740: LD_VAR 0 9
118744: PUSH
118745: FOR_TO
118746: IFFALSE 118808
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
118748: LD_VAR 0 8
118752: PPUSH
118753: CALL_OW 266
118757: PUSH
118758: LD_INT 0
118760: PUSH
118761: LD_INT 1
118763: PUSH
118764: EMPTY
118765: LIST
118766: LIST
118767: IN
118768: IFFALSE 118806
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118770: LD_VAR 0 4
118774: PUSH
118775: LD_VAR 0 7
118779: ARRAY
118780: PPUSH
118781: LD_VAR 0 14
118785: PUSH
118786: LD_VAR 0 8
118790: ARRAY
118791: PPUSH
118792: CALL_OW 115
// attacking := true ;
118796: LD_ADDR_VAR 0 29
118800: PUSH
118801: LD_INT 1
118803: ST_TO_ADDR
// break ;
118804: GO 118808
// end ;
118806: GO 118745
118808: POP
118809: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
118810: LD_VAR 0 4
118814: PUSH
118815: LD_VAR 0 7
118819: ARRAY
118820: PPUSH
118821: CALL_OW 302
118825: PUSH
118826: LD_VAR 0 29
118830: NOT
118831: AND
118832: IFFALSE 119154
// begin if GetTag ( group [ i ] ) = 71 then
118834: LD_VAR 0 4
118838: PUSH
118839: LD_VAR 0 7
118843: ARRAY
118844: PPUSH
118845: CALL_OW 110
118849: PUSH
118850: LD_INT 71
118852: EQUAL
118853: IFFALSE 118894
// begin if HasTask ( group [ i ] ) then
118855: LD_VAR 0 4
118859: PUSH
118860: LD_VAR 0 7
118864: ARRAY
118865: PPUSH
118866: CALL_OW 314
118870: IFFALSE 118876
// continue else
118872: GO 115033
118874: GO 118894
// SetTag ( group [ i ] , 0 ) ;
118876: LD_VAR 0 4
118880: PUSH
118881: LD_VAR 0 7
118885: ARRAY
118886: PPUSH
118887: LD_INT 0
118889: PPUSH
118890: CALL_OW 109
// end ; k := 8 ;
118894: LD_ADDR_VAR 0 9
118898: PUSH
118899: LD_INT 8
118901: ST_TO_ADDR
// x := 0 ;
118902: LD_ADDR_VAR 0 10
118906: PUSH
118907: LD_INT 0
118909: ST_TO_ADDR
// if tmp < k then
118910: LD_VAR 0 14
118914: PUSH
118915: LD_VAR 0 9
118919: LESS
118920: IFFALSE 118932
// k := tmp ;
118922: LD_ADDR_VAR 0 9
118926: PUSH
118927: LD_VAR 0 14
118931: ST_TO_ADDR
// for j = 1 to k do
118932: LD_ADDR_VAR 0 8
118936: PUSH
118937: DOUBLE
118938: LD_INT 1
118940: DEC
118941: ST_TO_ADDR
118942: LD_VAR 0 9
118946: PUSH
118947: FOR_TO
118948: IFFALSE 119046
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
118950: LD_VAR 0 14
118954: PUSH
118955: LD_VAR 0 8
118959: ARRAY
118960: PPUSH
118961: CALL_OW 247
118965: PUSH
118966: LD_INT 1
118968: EQUAL
118969: PUSH
118970: LD_VAR 0 14
118974: PUSH
118975: LD_VAR 0 8
118979: ARRAY
118980: PPUSH
118981: CALL_OW 256
118985: PUSH
118986: LD_INT 250
118988: LESS
118989: PUSH
118990: LD_VAR 0 20
118994: AND
118995: PUSH
118996: LD_VAR 0 20
119000: NOT
119001: PUSH
119002: LD_VAR 0 14
119006: PUSH
119007: LD_VAR 0 8
119011: ARRAY
119012: PPUSH
119013: CALL_OW 256
119017: PUSH
119018: LD_INT 250
119020: GREATEREQUAL
119021: AND
119022: OR
119023: AND
119024: IFFALSE 119044
// begin x := tmp [ j ] ;
119026: LD_ADDR_VAR 0 10
119030: PUSH
119031: LD_VAR 0 14
119035: PUSH
119036: LD_VAR 0 8
119040: ARRAY
119041: ST_TO_ADDR
// break ;
119042: GO 119046
// end ;
119044: GO 118947
119046: POP
119047: POP
// if x then
119048: LD_VAR 0 10
119052: IFFALSE 119076
// ComAttackUnit ( group [ i ] , x ) else
119054: LD_VAR 0 4
119058: PUSH
119059: LD_VAR 0 7
119063: ARRAY
119064: PPUSH
119065: LD_VAR 0 10
119069: PPUSH
119070: CALL_OW 115
119074: GO 119100
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119076: LD_VAR 0 4
119080: PUSH
119081: LD_VAR 0 7
119085: ARRAY
119086: PPUSH
119087: LD_VAR 0 14
119091: PUSH
119092: LD_INT 1
119094: ARRAY
119095: PPUSH
119096: CALL_OW 115
// if not HasTask ( group [ i ] ) then
119100: LD_VAR 0 4
119104: PUSH
119105: LD_VAR 0 7
119109: ARRAY
119110: PPUSH
119111: CALL_OW 314
119115: NOT
119116: IFFALSE 119154
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
119118: LD_VAR 0 4
119122: PUSH
119123: LD_VAR 0 7
119127: ARRAY
119128: PPUSH
119129: LD_VAR 0 14
119133: PPUSH
119134: LD_VAR 0 4
119138: PUSH
119139: LD_VAR 0 7
119143: ARRAY
119144: PPUSH
119145: CALL_OW 74
119149: PPUSH
119150: CALL_OW 115
// end ; end ; end ;
119154: GO 115033
119156: POP
119157: POP
// wait ( 0 0$2 ) ;
119158: LD_INT 70
119160: PPUSH
119161: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
119165: LD_VAR 0 4
119169: NOT
119170: PUSH
119171: LD_VAR 0 4
119175: PUSH
119176: EMPTY
119177: EQUAL
119178: OR
119179: PUSH
119180: LD_INT 81
119182: PUSH
119183: LD_VAR 0 35
119187: PUSH
119188: EMPTY
119189: LIST
119190: LIST
119191: PPUSH
119192: CALL_OW 69
119196: NOT
119197: OR
119198: IFFALSE 115018
// end ;
119200: LD_VAR 0 2
119204: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
119205: LD_INT 0
119207: PPUSH
119208: PPUSH
119209: PPUSH
119210: PPUSH
119211: PPUSH
119212: PPUSH
// if not base or not mc_bases [ base ] or not solds then
119213: LD_VAR 0 1
119217: NOT
119218: PUSH
119219: LD_EXP 78
119223: PUSH
119224: LD_VAR 0 1
119228: ARRAY
119229: NOT
119230: OR
119231: PUSH
119232: LD_VAR 0 2
119236: NOT
119237: OR
119238: IFFALSE 119242
// exit ;
119240: GO 119796
// side := mc_sides [ base ] ;
119242: LD_ADDR_VAR 0 6
119246: PUSH
119247: LD_EXP 104
119251: PUSH
119252: LD_VAR 0 1
119256: ARRAY
119257: ST_TO_ADDR
// if not side then
119258: LD_VAR 0 6
119262: NOT
119263: IFFALSE 119267
// exit ;
119265: GO 119796
// for i in solds do
119267: LD_ADDR_VAR 0 7
119271: PUSH
119272: LD_VAR 0 2
119276: PUSH
119277: FOR_IN
119278: IFFALSE 119339
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
119280: LD_VAR 0 7
119284: PPUSH
119285: CALL_OW 310
119289: PPUSH
119290: CALL_OW 266
119294: PUSH
119295: LD_INT 32
119297: PUSH
119298: LD_INT 31
119300: PUSH
119301: EMPTY
119302: LIST
119303: LIST
119304: IN
119305: IFFALSE 119325
// solds := solds diff i else
119307: LD_ADDR_VAR 0 2
119311: PUSH
119312: LD_VAR 0 2
119316: PUSH
119317: LD_VAR 0 7
119321: DIFF
119322: ST_TO_ADDR
119323: GO 119337
// SetTag ( i , 18 ) ;
119325: LD_VAR 0 7
119329: PPUSH
119330: LD_INT 18
119332: PPUSH
119333: CALL_OW 109
119337: GO 119277
119339: POP
119340: POP
// if not solds then
119341: LD_VAR 0 2
119345: NOT
119346: IFFALSE 119350
// exit ;
119348: GO 119796
// repeat wait ( 0 0$2 ) ;
119350: LD_INT 70
119352: PPUSH
119353: CALL_OW 67
// enemy := mc_scan [ base ] ;
119357: LD_ADDR_VAR 0 4
119361: PUSH
119362: LD_EXP 101
119366: PUSH
119367: LD_VAR 0 1
119371: ARRAY
119372: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119373: LD_EXP 78
119377: PUSH
119378: LD_VAR 0 1
119382: ARRAY
119383: NOT
119384: PUSH
119385: LD_EXP 78
119389: PUSH
119390: LD_VAR 0 1
119394: ARRAY
119395: PUSH
119396: EMPTY
119397: EQUAL
119398: OR
119399: IFFALSE 119436
// begin for i in solds do
119401: LD_ADDR_VAR 0 7
119405: PUSH
119406: LD_VAR 0 2
119410: PUSH
119411: FOR_IN
119412: IFFALSE 119425
// ComStop ( i ) ;
119414: LD_VAR 0 7
119418: PPUSH
119419: CALL_OW 141
119423: GO 119411
119425: POP
119426: POP
// solds := [ ] ;
119427: LD_ADDR_VAR 0 2
119431: PUSH
119432: EMPTY
119433: ST_TO_ADDR
// exit ;
119434: GO 119796
// end ; for i in solds do
119436: LD_ADDR_VAR 0 7
119440: PUSH
119441: LD_VAR 0 2
119445: PUSH
119446: FOR_IN
119447: IFFALSE 119768
// begin if IsInUnit ( i ) then
119449: LD_VAR 0 7
119453: PPUSH
119454: CALL_OW 310
119458: IFFALSE 119469
// ComExitBuilding ( i ) ;
119460: LD_VAR 0 7
119464: PPUSH
119465: CALL_OW 122
// if GetLives ( i ) > 500 then
119469: LD_VAR 0 7
119473: PPUSH
119474: CALL_OW 256
119478: PUSH
119479: LD_INT 500
119481: GREATER
119482: IFFALSE 119535
// begin e := NearestUnitToUnit ( enemy , i ) ;
119484: LD_ADDR_VAR 0 5
119488: PUSH
119489: LD_VAR 0 4
119493: PPUSH
119494: LD_VAR 0 7
119498: PPUSH
119499: CALL_OW 74
119503: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
119504: LD_VAR 0 7
119508: PPUSH
119509: LD_VAR 0 5
119513: PPUSH
119514: CALL_OW 250
119518: PPUSH
119519: LD_VAR 0 5
119523: PPUSH
119524: CALL_OW 251
119528: PPUSH
119529: CALL_OW 114
// end else
119533: GO 119766
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
119535: LD_VAR 0 7
119539: PPUSH
119540: LD_EXP 78
119544: PUSH
119545: LD_VAR 0 1
119549: ARRAY
119550: PPUSH
119551: LD_INT 2
119553: PUSH
119554: LD_INT 30
119556: PUSH
119557: LD_INT 0
119559: PUSH
119560: EMPTY
119561: LIST
119562: LIST
119563: PUSH
119564: LD_INT 30
119566: PUSH
119567: LD_INT 1
119569: PUSH
119570: EMPTY
119571: LIST
119572: LIST
119573: PUSH
119574: LD_INT 30
119576: PUSH
119577: LD_INT 6
119579: PUSH
119580: EMPTY
119581: LIST
119582: LIST
119583: PUSH
119584: EMPTY
119585: LIST
119586: LIST
119587: LIST
119588: LIST
119589: PPUSH
119590: CALL_OW 72
119594: PPUSH
119595: LD_VAR 0 7
119599: PPUSH
119600: CALL_OW 74
119604: PPUSH
119605: CALL_OW 296
119609: PUSH
119610: LD_INT 10
119612: GREATER
119613: IFFALSE 119766
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
119615: LD_ADDR_VAR 0 8
119619: PUSH
119620: LD_EXP 78
119624: PUSH
119625: LD_VAR 0 1
119629: ARRAY
119630: PPUSH
119631: LD_INT 2
119633: PUSH
119634: LD_INT 30
119636: PUSH
119637: LD_INT 0
119639: PUSH
119640: EMPTY
119641: LIST
119642: LIST
119643: PUSH
119644: LD_INT 30
119646: PUSH
119647: LD_INT 1
119649: PUSH
119650: EMPTY
119651: LIST
119652: LIST
119653: PUSH
119654: LD_INT 30
119656: PUSH
119657: LD_INT 6
119659: PUSH
119660: EMPTY
119661: LIST
119662: LIST
119663: PUSH
119664: EMPTY
119665: LIST
119666: LIST
119667: LIST
119668: LIST
119669: PPUSH
119670: CALL_OW 72
119674: PPUSH
119675: LD_VAR 0 7
119679: PPUSH
119680: CALL_OW 74
119684: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
119685: LD_VAR 0 7
119689: PPUSH
119690: LD_VAR 0 8
119694: PPUSH
119695: CALL_OW 250
119699: PPUSH
119700: LD_INT 3
119702: PPUSH
119703: LD_INT 5
119705: PPUSH
119706: CALL_OW 272
119710: PPUSH
119711: LD_VAR 0 8
119715: PPUSH
119716: CALL_OW 251
119720: PPUSH
119721: LD_INT 3
119723: PPUSH
119724: LD_INT 5
119726: PPUSH
119727: CALL_OW 273
119731: PPUSH
119732: CALL_OW 111
// SetTag ( i , 0 ) ;
119736: LD_VAR 0 7
119740: PPUSH
119741: LD_INT 0
119743: PPUSH
119744: CALL_OW 109
// solds := solds diff i ;
119748: LD_ADDR_VAR 0 2
119752: PUSH
119753: LD_VAR 0 2
119757: PUSH
119758: LD_VAR 0 7
119762: DIFF
119763: ST_TO_ADDR
// continue ;
119764: GO 119446
// end ; end ;
119766: GO 119446
119768: POP
119769: POP
// until not solds or not enemy ;
119770: LD_VAR 0 2
119774: NOT
119775: PUSH
119776: LD_VAR 0 4
119780: NOT
119781: OR
119782: IFFALSE 119350
// MC_Reset ( base , 18 ) ;
119784: LD_VAR 0 1
119788: PPUSH
119789: LD_INT 18
119791: PPUSH
119792: CALL 26323 0 2
// end ;
119796: LD_VAR 0 3
119800: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
119801: LD_INT 0
119803: PPUSH
119804: PPUSH
119805: PPUSH
119806: PPUSH
119807: PPUSH
119808: PPUSH
119809: PPUSH
119810: PPUSH
119811: PPUSH
119812: PPUSH
119813: PPUSH
119814: PPUSH
119815: PPUSH
119816: PPUSH
119817: PPUSH
119818: PPUSH
119819: PPUSH
119820: PPUSH
119821: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
119822: LD_ADDR_VAR 0 12
119826: PUSH
119827: LD_EXP 78
119831: PUSH
119832: LD_VAR 0 1
119836: ARRAY
119837: PPUSH
119838: LD_INT 25
119840: PUSH
119841: LD_INT 3
119843: PUSH
119844: EMPTY
119845: LIST
119846: LIST
119847: PPUSH
119848: CALL_OW 72
119852: ST_TO_ADDR
// if mc_remote_driver [ base ] then
119853: LD_EXP 118
119857: PUSH
119858: LD_VAR 0 1
119862: ARRAY
119863: IFFALSE 119887
// mechs := mechs diff mc_remote_driver [ base ] ;
119865: LD_ADDR_VAR 0 12
119869: PUSH
119870: LD_VAR 0 12
119874: PUSH
119875: LD_EXP 118
119879: PUSH
119880: LD_VAR 0 1
119884: ARRAY
119885: DIFF
119886: ST_TO_ADDR
// for i in mechs do
119887: LD_ADDR_VAR 0 4
119891: PUSH
119892: LD_VAR 0 12
119896: PUSH
119897: FOR_IN
119898: IFFALSE 119933
// if GetTag ( i ) > 0 then
119900: LD_VAR 0 4
119904: PPUSH
119905: CALL_OW 110
119909: PUSH
119910: LD_INT 0
119912: GREATER
119913: IFFALSE 119931
// mechs := mechs diff i ;
119915: LD_ADDR_VAR 0 12
119919: PUSH
119920: LD_VAR 0 12
119924: PUSH
119925: LD_VAR 0 4
119929: DIFF
119930: ST_TO_ADDR
119931: GO 119897
119933: POP
119934: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119935: LD_ADDR_VAR 0 8
119939: PUSH
119940: LD_EXP 78
119944: PUSH
119945: LD_VAR 0 1
119949: ARRAY
119950: PPUSH
119951: LD_INT 2
119953: PUSH
119954: LD_INT 25
119956: PUSH
119957: LD_INT 1
119959: PUSH
119960: EMPTY
119961: LIST
119962: LIST
119963: PUSH
119964: LD_INT 25
119966: PUSH
119967: LD_INT 5
119969: PUSH
119970: EMPTY
119971: LIST
119972: LIST
119973: PUSH
119974: LD_INT 25
119976: PUSH
119977: LD_INT 8
119979: PUSH
119980: EMPTY
119981: LIST
119982: LIST
119983: PUSH
119984: LD_INT 25
119986: PUSH
119987: LD_INT 9
119989: PUSH
119990: EMPTY
119991: LIST
119992: LIST
119993: PUSH
119994: EMPTY
119995: LIST
119996: LIST
119997: LIST
119998: LIST
119999: LIST
120000: PPUSH
120001: CALL_OW 72
120005: ST_TO_ADDR
// if not defenders and not solds then
120006: LD_VAR 0 2
120010: NOT
120011: PUSH
120012: LD_VAR 0 8
120016: NOT
120017: AND
120018: IFFALSE 120022
// exit ;
120020: GO 121792
// depot_under_attack := false ;
120022: LD_ADDR_VAR 0 16
120026: PUSH
120027: LD_INT 0
120029: ST_TO_ADDR
// sold_defenders := [ ] ;
120030: LD_ADDR_VAR 0 17
120034: PUSH
120035: EMPTY
120036: ST_TO_ADDR
// if mechs then
120037: LD_VAR 0 12
120041: IFFALSE 120194
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
120043: LD_ADDR_VAR 0 4
120047: PUSH
120048: LD_VAR 0 2
120052: PPUSH
120053: LD_INT 21
120055: PUSH
120056: LD_INT 2
120058: PUSH
120059: EMPTY
120060: LIST
120061: LIST
120062: PPUSH
120063: CALL_OW 72
120067: PUSH
120068: FOR_IN
120069: IFFALSE 120192
// begin if GetTag ( i ) <> 20 then
120071: LD_VAR 0 4
120075: PPUSH
120076: CALL_OW 110
120080: PUSH
120081: LD_INT 20
120083: NONEQUAL
120084: IFFALSE 120098
// SetTag ( i , 20 ) ;
120086: LD_VAR 0 4
120090: PPUSH
120091: LD_INT 20
120093: PPUSH
120094: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
120098: LD_VAR 0 4
120102: PPUSH
120103: CALL_OW 263
120107: PUSH
120108: LD_INT 1
120110: EQUAL
120111: PUSH
120112: LD_VAR 0 4
120116: PPUSH
120117: CALL_OW 311
120121: NOT
120122: AND
120123: IFFALSE 120190
// begin un := mechs [ 1 ] ;
120125: LD_ADDR_VAR 0 10
120129: PUSH
120130: LD_VAR 0 12
120134: PUSH
120135: LD_INT 1
120137: ARRAY
120138: ST_TO_ADDR
// ComExit ( un ) ;
120139: LD_VAR 0 10
120143: PPUSH
120144: CALL 90581 0 1
// AddComEnterUnit ( un , i ) ;
120148: LD_VAR 0 10
120152: PPUSH
120153: LD_VAR 0 4
120157: PPUSH
120158: CALL_OW 180
// SetTag ( un , 19 ) ;
120162: LD_VAR 0 10
120166: PPUSH
120167: LD_INT 19
120169: PPUSH
120170: CALL_OW 109
// mechs := mechs diff un ;
120174: LD_ADDR_VAR 0 12
120178: PUSH
120179: LD_VAR 0 12
120183: PUSH
120184: LD_VAR 0 10
120188: DIFF
120189: ST_TO_ADDR
// end ; end ;
120190: GO 120068
120192: POP
120193: POP
// if solds then
120194: LD_VAR 0 8
120198: IFFALSE 120257
// for i in solds do
120200: LD_ADDR_VAR 0 4
120204: PUSH
120205: LD_VAR 0 8
120209: PUSH
120210: FOR_IN
120211: IFFALSE 120255
// if not GetTag ( i ) then
120213: LD_VAR 0 4
120217: PPUSH
120218: CALL_OW 110
120222: NOT
120223: IFFALSE 120253
// begin defenders := defenders union i ;
120225: LD_ADDR_VAR 0 2
120229: PUSH
120230: LD_VAR 0 2
120234: PUSH
120235: LD_VAR 0 4
120239: UNION
120240: ST_TO_ADDR
// SetTag ( i , 18 ) ;
120241: LD_VAR 0 4
120245: PPUSH
120246: LD_INT 18
120248: PPUSH
120249: CALL_OW 109
// end ;
120253: GO 120210
120255: POP
120256: POP
// repeat wait ( 0 0$2 ) ;
120257: LD_INT 70
120259: PPUSH
120260: CALL_OW 67
// enemy := mc_scan [ base ] ;
120264: LD_ADDR_VAR 0 21
120268: PUSH
120269: LD_EXP 101
120273: PUSH
120274: LD_VAR 0 1
120278: ARRAY
120279: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120280: LD_EXP 78
120284: PUSH
120285: LD_VAR 0 1
120289: ARRAY
120290: NOT
120291: PUSH
120292: LD_EXP 78
120296: PUSH
120297: LD_VAR 0 1
120301: ARRAY
120302: PUSH
120303: EMPTY
120304: EQUAL
120305: OR
120306: IFFALSE 120343
// begin for i in defenders do
120308: LD_ADDR_VAR 0 4
120312: PUSH
120313: LD_VAR 0 2
120317: PUSH
120318: FOR_IN
120319: IFFALSE 120332
// ComStop ( i ) ;
120321: LD_VAR 0 4
120325: PPUSH
120326: CALL_OW 141
120330: GO 120318
120332: POP
120333: POP
// defenders := [ ] ;
120334: LD_ADDR_VAR 0 2
120338: PUSH
120339: EMPTY
120340: ST_TO_ADDR
// exit ;
120341: GO 121792
// end ; for i in defenders do
120343: LD_ADDR_VAR 0 4
120347: PUSH
120348: LD_VAR 0 2
120352: PUSH
120353: FOR_IN
120354: IFFALSE 121252
// begin e := NearestUnitToUnit ( enemy , i ) ;
120356: LD_ADDR_VAR 0 13
120360: PUSH
120361: LD_VAR 0 21
120365: PPUSH
120366: LD_VAR 0 4
120370: PPUSH
120371: CALL_OW 74
120375: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
120376: LD_ADDR_VAR 0 7
120380: PUSH
120381: LD_EXP 78
120385: PUSH
120386: LD_VAR 0 1
120390: ARRAY
120391: PPUSH
120392: LD_INT 2
120394: PUSH
120395: LD_INT 30
120397: PUSH
120398: LD_INT 0
120400: PUSH
120401: EMPTY
120402: LIST
120403: LIST
120404: PUSH
120405: LD_INT 30
120407: PUSH
120408: LD_INT 1
120410: PUSH
120411: EMPTY
120412: LIST
120413: LIST
120414: PUSH
120415: EMPTY
120416: LIST
120417: LIST
120418: LIST
120419: PPUSH
120420: CALL_OW 72
120424: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
120425: LD_ADDR_VAR 0 16
120429: PUSH
120430: LD_VAR 0 7
120434: NOT
120435: PUSH
120436: LD_VAR 0 7
120440: PPUSH
120441: LD_INT 3
120443: PUSH
120444: LD_INT 24
120446: PUSH
120447: LD_INT 600
120449: PUSH
120450: EMPTY
120451: LIST
120452: LIST
120453: PUSH
120454: EMPTY
120455: LIST
120456: LIST
120457: PPUSH
120458: CALL_OW 72
120462: OR
120463: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
120464: LD_VAR 0 4
120468: PPUSH
120469: CALL_OW 247
120473: PUSH
120474: LD_INT 2
120476: DOUBLE
120477: EQUAL
120478: IFTRUE 120482
120480: GO 120878
120482: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
120483: LD_VAR 0 4
120487: PPUSH
120488: CALL_OW 256
120492: PUSH
120493: LD_INT 1000
120495: EQUAL
120496: PUSH
120497: LD_VAR 0 4
120501: PPUSH
120502: LD_VAR 0 13
120506: PPUSH
120507: CALL_OW 296
120511: PUSH
120512: LD_INT 40
120514: LESS
120515: PUSH
120516: LD_VAR 0 13
120520: PPUSH
120521: LD_EXP 103
120525: PUSH
120526: LD_VAR 0 1
120530: ARRAY
120531: PPUSH
120532: CALL_OW 308
120536: OR
120537: AND
120538: IFFALSE 120660
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
120540: LD_VAR 0 4
120544: PPUSH
120545: CALL_OW 262
120549: PUSH
120550: LD_INT 1
120552: EQUAL
120553: PUSH
120554: LD_VAR 0 4
120558: PPUSH
120559: CALL_OW 261
120563: PUSH
120564: LD_INT 30
120566: LESS
120567: AND
120568: PUSH
120569: LD_VAR 0 7
120573: AND
120574: IFFALSE 120644
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
120576: LD_VAR 0 4
120580: PPUSH
120581: LD_VAR 0 7
120585: PPUSH
120586: LD_VAR 0 4
120590: PPUSH
120591: CALL_OW 74
120595: PPUSH
120596: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
120600: LD_VAR 0 4
120604: PPUSH
120605: LD_VAR 0 7
120609: PPUSH
120610: LD_VAR 0 4
120614: PPUSH
120615: CALL_OW 74
120619: PPUSH
120620: CALL_OW 296
120624: PUSH
120625: LD_INT 6
120627: LESS
120628: IFFALSE 120642
// SetFuel ( i , 100 ) ;
120630: LD_VAR 0 4
120634: PPUSH
120635: LD_INT 100
120637: PPUSH
120638: CALL_OW 240
// end else
120642: GO 120658
// ComAttackUnit ( i , e ) ;
120644: LD_VAR 0 4
120648: PPUSH
120649: LD_VAR 0 13
120653: PPUSH
120654: CALL_OW 115
// end else
120658: GO 120761
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
120660: LD_VAR 0 13
120664: PPUSH
120665: LD_EXP 103
120669: PUSH
120670: LD_VAR 0 1
120674: ARRAY
120675: PPUSH
120676: CALL_OW 308
120680: NOT
120681: PUSH
120682: LD_VAR 0 4
120686: PPUSH
120687: LD_VAR 0 13
120691: PPUSH
120692: CALL_OW 296
120696: PUSH
120697: LD_INT 40
120699: GREATEREQUAL
120700: AND
120701: PUSH
120702: LD_VAR 0 4
120706: PPUSH
120707: CALL_OW 256
120711: PUSH
120712: LD_INT 650
120714: LESSEQUAL
120715: OR
120716: PUSH
120717: LD_VAR 0 4
120721: PPUSH
120722: LD_EXP 102
120726: PUSH
120727: LD_VAR 0 1
120731: ARRAY
120732: PPUSH
120733: CALL_OW 308
120737: NOT
120738: AND
120739: IFFALSE 120761
// ComMoveToArea ( i , mc_parking [ base ] ) ;
120741: LD_VAR 0 4
120745: PPUSH
120746: LD_EXP 102
120750: PUSH
120751: LD_VAR 0 1
120755: ARRAY
120756: PPUSH
120757: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
120761: LD_VAR 0 4
120765: PPUSH
120766: CALL_OW 256
120770: PUSH
120771: LD_INT 1000
120773: LESS
120774: PUSH
120775: LD_VAR 0 4
120779: PPUSH
120780: CALL_OW 263
120784: PUSH
120785: LD_INT 1
120787: EQUAL
120788: AND
120789: PUSH
120790: LD_VAR 0 4
120794: PPUSH
120795: CALL_OW 311
120799: AND
120800: PUSH
120801: LD_VAR 0 4
120805: PPUSH
120806: LD_EXP 102
120810: PUSH
120811: LD_VAR 0 1
120815: ARRAY
120816: PPUSH
120817: CALL_OW 308
120821: AND
120822: IFFALSE 120876
// begin mech := IsDrivenBy ( i ) ;
120824: LD_ADDR_VAR 0 9
120828: PUSH
120829: LD_VAR 0 4
120833: PPUSH
120834: CALL_OW 311
120838: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
120839: LD_VAR 0 9
120843: PPUSH
120844: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
120848: LD_VAR 0 9
120852: PPUSH
120853: LD_VAR 0 4
120857: PPUSH
120858: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
120862: LD_VAR 0 9
120866: PPUSH
120867: LD_VAR 0 4
120871: PPUSH
120872: CALL_OW 180
// end ; end ; unit_human :
120876: GO 121223
120878: LD_INT 1
120880: DOUBLE
120881: EQUAL
120882: IFTRUE 120886
120884: GO 121222
120886: POP
// begin b := IsInUnit ( i ) ;
120887: LD_ADDR_VAR 0 18
120891: PUSH
120892: LD_VAR 0 4
120896: PPUSH
120897: CALL_OW 310
120901: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
120902: LD_ADDR_VAR 0 19
120906: PUSH
120907: LD_VAR 0 18
120911: NOT
120912: PUSH
120913: LD_VAR 0 18
120917: PPUSH
120918: CALL_OW 266
120922: PUSH
120923: LD_INT 32
120925: PUSH
120926: LD_INT 31
120928: PUSH
120929: EMPTY
120930: LIST
120931: LIST
120932: IN
120933: OR
120934: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
120935: LD_VAR 0 18
120939: PPUSH
120940: CALL_OW 266
120944: PUSH
120945: LD_INT 5
120947: EQUAL
120948: PUSH
120949: LD_VAR 0 4
120953: PPUSH
120954: CALL_OW 257
120958: PUSH
120959: LD_INT 1
120961: PUSH
120962: LD_INT 2
120964: PUSH
120965: LD_INT 3
120967: PUSH
120968: LD_INT 4
120970: PUSH
120971: EMPTY
120972: LIST
120973: LIST
120974: LIST
120975: LIST
120976: IN
120977: AND
120978: IFFALSE 121015
// begin class := AllowSpecClass ( i ) ;
120980: LD_ADDR_VAR 0 20
120984: PUSH
120985: LD_VAR 0 4
120989: PPUSH
120990: CALL 54648 0 1
120994: ST_TO_ADDR
// if class then
120995: LD_VAR 0 20
120999: IFFALSE 121015
// ComChangeProfession ( i , class ) ;
121001: LD_VAR 0 4
121005: PPUSH
121006: LD_VAR 0 20
121010: PPUSH
121011: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
121015: LD_VAR 0 16
121019: PUSH
121020: LD_VAR 0 2
121024: PPUSH
121025: LD_INT 21
121027: PUSH
121028: LD_INT 2
121030: PUSH
121031: EMPTY
121032: LIST
121033: LIST
121034: PPUSH
121035: CALL_OW 72
121039: PUSH
121040: LD_INT 1
121042: LESSEQUAL
121043: OR
121044: PUSH
121045: LD_VAR 0 19
121049: AND
121050: PUSH
121051: LD_VAR 0 4
121055: PUSH
121056: LD_VAR 0 17
121060: IN
121061: NOT
121062: AND
121063: IFFALSE 121156
// begin if b then
121065: LD_VAR 0 18
121069: IFFALSE 121118
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
121071: LD_VAR 0 18
121075: PPUSH
121076: LD_VAR 0 21
121080: PPUSH
121081: LD_VAR 0 18
121085: PPUSH
121086: CALL_OW 74
121090: PPUSH
121091: CALL_OW 296
121095: PUSH
121096: LD_INT 10
121098: LESS
121099: PUSH
121100: LD_VAR 0 18
121104: PPUSH
121105: CALL_OW 461
121109: PUSH
121110: LD_INT 7
121112: NONEQUAL
121113: AND
121114: IFFALSE 121118
// continue ;
121116: GO 120353
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
121118: LD_ADDR_VAR 0 17
121122: PUSH
121123: LD_VAR 0 17
121127: PPUSH
121128: LD_VAR 0 17
121132: PUSH
121133: LD_INT 1
121135: PLUS
121136: PPUSH
121137: LD_VAR 0 4
121141: PPUSH
121142: CALL_OW 1
121146: ST_TO_ADDR
// ComExitBuilding ( i ) ;
121147: LD_VAR 0 4
121151: PPUSH
121152: CALL_OW 122
// end ; if sold_defenders then
121156: LD_VAR 0 17
121160: IFFALSE 121220
// if i in sold_defenders then
121162: LD_VAR 0 4
121166: PUSH
121167: LD_VAR 0 17
121171: IN
121172: IFFALSE 121220
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
121174: LD_VAR 0 4
121178: PPUSH
121179: CALL_OW 314
121183: NOT
121184: PUSH
121185: LD_VAR 0 4
121189: PPUSH
121190: LD_VAR 0 13
121194: PPUSH
121195: CALL_OW 296
121199: PUSH
121200: LD_INT 30
121202: LESS
121203: AND
121204: IFFALSE 121220
// ComAttackUnit ( i , e ) ;
121206: LD_VAR 0 4
121210: PPUSH
121211: LD_VAR 0 13
121215: PPUSH
121216: CALL_OW 115
// end ; end ; end ;
121220: GO 121223
121222: POP
// if IsDead ( i ) then
121223: LD_VAR 0 4
121227: PPUSH
121228: CALL_OW 301
121232: IFFALSE 121250
// defenders := defenders diff i ;
121234: LD_ADDR_VAR 0 2
121238: PUSH
121239: LD_VAR 0 2
121243: PUSH
121244: LD_VAR 0 4
121248: DIFF
121249: ST_TO_ADDR
// end ;
121250: GO 120353
121252: POP
121253: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
121254: LD_VAR 0 21
121258: NOT
121259: PUSH
121260: LD_VAR 0 2
121264: NOT
121265: OR
121266: PUSH
121267: LD_EXP 78
121271: PUSH
121272: LD_VAR 0 1
121276: ARRAY
121277: NOT
121278: OR
121279: IFFALSE 120257
// MC_Reset ( base , 18 ) ;
121281: LD_VAR 0 1
121285: PPUSH
121286: LD_INT 18
121288: PPUSH
121289: CALL 26323 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
121293: LD_ADDR_VAR 0 2
121297: PUSH
121298: LD_VAR 0 2
121302: PUSH
121303: LD_VAR 0 2
121307: PPUSH
121308: LD_INT 2
121310: PUSH
121311: LD_INT 25
121313: PUSH
121314: LD_INT 1
121316: PUSH
121317: EMPTY
121318: LIST
121319: LIST
121320: PUSH
121321: LD_INT 25
121323: PUSH
121324: LD_INT 5
121326: PUSH
121327: EMPTY
121328: LIST
121329: LIST
121330: PUSH
121331: LD_INT 25
121333: PUSH
121334: LD_INT 8
121336: PUSH
121337: EMPTY
121338: LIST
121339: LIST
121340: PUSH
121341: LD_INT 25
121343: PUSH
121344: LD_INT 9
121346: PUSH
121347: EMPTY
121348: LIST
121349: LIST
121350: PUSH
121351: EMPTY
121352: LIST
121353: LIST
121354: LIST
121355: LIST
121356: LIST
121357: PPUSH
121358: CALL_OW 72
121362: DIFF
121363: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
121364: LD_VAR 0 21
121368: NOT
121369: PUSH
121370: LD_VAR 0 2
121374: PPUSH
121375: LD_INT 21
121377: PUSH
121378: LD_INT 2
121380: PUSH
121381: EMPTY
121382: LIST
121383: LIST
121384: PPUSH
121385: CALL_OW 72
121389: AND
121390: IFFALSE 121728
// begin tmp := FilterByTag ( defenders , 19 ) ;
121392: LD_ADDR_VAR 0 11
121396: PUSH
121397: LD_VAR 0 2
121401: PPUSH
121402: LD_INT 19
121404: PPUSH
121405: CALL 87765 0 2
121409: ST_TO_ADDR
// if tmp then
121410: LD_VAR 0 11
121414: IFFALSE 121484
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
121416: LD_ADDR_VAR 0 11
121420: PUSH
121421: LD_VAR 0 11
121425: PPUSH
121426: LD_INT 25
121428: PUSH
121429: LD_INT 3
121431: PUSH
121432: EMPTY
121433: LIST
121434: LIST
121435: PPUSH
121436: CALL_OW 72
121440: ST_TO_ADDR
// if tmp then
121441: LD_VAR 0 11
121445: IFFALSE 121484
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
121447: LD_ADDR_EXP 90
121451: PUSH
121452: LD_EXP 90
121456: PPUSH
121457: LD_VAR 0 1
121461: PPUSH
121462: LD_EXP 90
121466: PUSH
121467: LD_VAR 0 1
121471: ARRAY
121472: PUSH
121473: LD_VAR 0 11
121477: UNION
121478: PPUSH
121479: CALL_OW 1
121483: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
121484: LD_VAR 0 1
121488: PPUSH
121489: LD_INT 19
121491: PPUSH
121492: CALL 26323 0 2
// repeat wait ( 0 0$1 ) ;
121496: LD_INT 35
121498: PPUSH
121499: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121503: LD_EXP 78
121507: PUSH
121508: LD_VAR 0 1
121512: ARRAY
121513: NOT
121514: PUSH
121515: LD_EXP 78
121519: PUSH
121520: LD_VAR 0 1
121524: ARRAY
121525: PUSH
121526: EMPTY
121527: EQUAL
121528: OR
121529: IFFALSE 121566
// begin for i in defenders do
121531: LD_ADDR_VAR 0 4
121535: PUSH
121536: LD_VAR 0 2
121540: PUSH
121541: FOR_IN
121542: IFFALSE 121555
// ComStop ( i ) ;
121544: LD_VAR 0 4
121548: PPUSH
121549: CALL_OW 141
121553: GO 121541
121555: POP
121556: POP
// defenders := [ ] ;
121557: LD_ADDR_VAR 0 2
121561: PUSH
121562: EMPTY
121563: ST_TO_ADDR
// exit ;
121564: GO 121792
// end ; for i in defenders do
121566: LD_ADDR_VAR 0 4
121570: PUSH
121571: LD_VAR 0 2
121575: PUSH
121576: FOR_IN
121577: IFFALSE 121666
// begin if not IsInArea ( i , mc_parking [ base ] ) then
121579: LD_VAR 0 4
121583: PPUSH
121584: LD_EXP 102
121588: PUSH
121589: LD_VAR 0 1
121593: ARRAY
121594: PPUSH
121595: CALL_OW 308
121599: NOT
121600: IFFALSE 121624
// ComMoveToArea ( i , mc_parking [ base ] ) else
121602: LD_VAR 0 4
121606: PPUSH
121607: LD_EXP 102
121611: PUSH
121612: LD_VAR 0 1
121616: ARRAY
121617: PPUSH
121618: CALL_OW 113
121622: GO 121664
// if GetControl ( i ) = control_manual then
121624: LD_VAR 0 4
121628: PPUSH
121629: CALL_OW 263
121633: PUSH
121634: LD_INT 1
121636: EQUAL
121637: IFFALSE 121664
// if IsDrivenBy ( i ) then
121639: LD_VAR 0 4
121643: PPUSH
121644: CALL_OW 311
121648: IFFALSE 121664
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
121650: LD_VAR 0 4
121654: PPUSH
121655: CALL_OW 311
121659: PPUSH
121660: CALL_OW 121
// end ;
121664: GO 121576
121666: POP
121667: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
121668: LD_VAR 0 2
121672: PPUSH
121673: LD_INT 95
121675: PUSH
121676: LD_EXP 102
121680: PUSH
121681: LD_VAR 0 1
121685: ARRAY
121686: PUSH
121687: EMPTY
121688: LIST
121689: LIST
121690: PPUSH
121691: CALL_OW 72
121695: PUSH
121696: LD_VAR 0 2
121700: EQUAL
121701: PUSH
121702: LD_EXP 101
121706: PUSH
121707: LD_VAR 0 1
121711: ARRAY
121712: OR
121713: PUSH
121714: LD_EXP 78
121718: PUSH
121719: LD_VAR 0 1
121723: ARRAY
121724: NOT
121725: OR
121726: IFFALSE 121496
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
121728: LD_ADDR_EXP 100
121732: PUSH
121733: LD_EXP 100
121737: PPUSH
121738: LD_VAR 0 1
121742: PPUSH
121743: LD_VAR 0 2
121747: PPUSH
121748: LD_INT 21
121750: PUSH
121751: LD_INT 2
121753: PUSH
121754: EMPTY
121755: LIST
121756: LIST
121757: PPUSH
121758: CALL_OW 72
121762: PPUSH
121763: CALL_OW 1
121767: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
121768: LD_VAR 0 1
121772: PPUSH
121773: LD_INT 19
121775: PPUSH
121776: CALL 26323 0 2
// MC_Reset ( base , 20 ) ;
121780: LD_VAR 0 1
121784: PPUSH
121785: LD_INT 20
121787: PPUSH
121788: CALL 26323 0 2
// end ; end_of_file
121792: LD_VAR 0 3
121796: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
121797: LD_VAR 0 1
121801: PUSH
121802: LD_INT 200
121804: DOUBLE
121805: GREATEREQUAL
121806: IFFALSE 121814
121808: LD_INT 299
121810: DOUBLE
121811: LESSEQUAL
121812: IFTRUE 121816
121814: GO 121848
121816: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
121817: LD_VAR 0 1
121821: PPUSH
121822: LD_VAR 0 2
121826: PPUSH
121827: LD_VAR 0 3
121831: PPUSH
121832: LD_VAR 0 4
121836: PPUSH
121837: LD_VAR 0 5
121841: PPUSH
121842: CALL 110583 0 5
121846: GO 121925
121848: LD_INT 300
121850: DOUBLE
121851: GREATEREQUAL
121852: IFFALSE 121860
121854: LD_INT 399
121856: DOUBLE
121857: LESSEQUAL
121858: IFTRUE 121862
121860: GO 121924
121862: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
121863: LD_VAR 0 1
121867: PPUSH
121868: LD_VAR 0 2
121872: PPUSH
121873: LD_VAR 0 3
121877: PPUSH
121878: LD_VAR 0 4
121882: PPUSH
121883: LD_VAR 0 5
121887: PPUSH
121888: LD_VAR 0 6
121892: PPUSH
121893: LD_VAR 0 7
121897: PPUSH
121898: LD_VAR 0 8
121902: PPUSH
121903: LD_VAR 0 9
121907: PPUSH
121908: LD_VAR 0 10
121912: PPUSH
121913: LD_VAR 0 11
121917: PPUSH
121918: CALL 106908 0 11
121922: GO 121925
121924: POP
// end ;
121925: PPOPN 11
121927: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
121928: LD_VAR 0 1
121932: PPUSH
121933: LD_VAR 0 2
121937: PPUSH
121938: LD_VAR 0 3
121942: PPUSH
121943: LD_VAR 0 4
121947: PPUSH
121948: LD_VAR 0 5
121952: PPUSH
121953: CALL 110319 0 5
// end ; end_of_file
121957: PPOPN 5
121959: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
121960: LD_VAR 0 1
121964: PPUSH
121965: LD_VAR 0 2
121969: PPUSH
121970: LD_VAR 0 3
121974: PPUSH
121975: LD_VAR 0 4
121979: PPUSH
121980: LD_VAR 0 5
121984: PPUSH
121985: LD_VAR 0 6
121989: PPUSH
121990: CALL 94560 0 6
// end ;
121994: PPOPN 6
121996: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
121997: LD_INT 0
121999: PPUSH
// begin if not units then
122000: LD_VAR 0 1
122004: NOT
122005: IFFALSE 122009
// exit ;
122007: GO 122009
// end ;
122009: PPOPN 7
122011: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
122012: CALL 94464 0 0
// end ;
122016: PPOPN 1
122018: END
