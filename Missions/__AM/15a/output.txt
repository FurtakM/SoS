// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 23349 0 0
// InitNature ;
  19: CALL 19860 0 0
// InitArtifact ;
  23: CALL 20477 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5136 0 0
// PrepareAlliance ;
  44: CALL 1460 0 0
// PrepareArabian ;
  48: CALL 7185 0 0
// PrepareRussian ;
  52: CALL 9502 0 0
// PrepareLegion ;
  56: CALL 7752 0 0
// Action ;
  60: CALL 12488 0 0
// MC_Start ( ) ;
  64: CALL 25529 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked , negotiationWithArabs , omarKilled ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// negotiationWithArabs := LoadVariable ( 13a_negotiationWithArabs , false ) ;
  96: LD_ADDR_EXP 19
 100: PUSH
 101: LD_STRING 13a_negotiationWithArabs
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// omarKilled := false ;
 112: LD_ADDR_EXP 20
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// russianDestroyed := false ;
 120: LD_ADDR_EXP 2
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// legionDestroyed := false ;
 128: LD_ADDR_EXP 3
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// americanDestroyed := false ;
 136: LD_ADDR_EXP 4
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// arabianDestroyed := false ;
 144: LD_ADDR_EXP 5
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// americanCapitulated := false ;
 152: LD_ADDR_EXP 6
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// russianCapitulated := false ;
 160: LD_ADDR_EXP 7
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// legionCapitulated := false ;
 168: LD_ADDR_EXP 8
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// artifactIResearched := false ;
 176: LD_ADDR_EXP 12
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// artifactIIResearched := false ;
 184: LD_ADDR_EXP 13
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// artifactIIIResearched := false ;
 192: LD_ADDR_EXP 14
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// alienSpotted := false ;
 200: LD_ADDR_EXP 10
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// spawnOmar := false ;
 208: LD_ADDR_EXP 11
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 224: LD_ADDR_EXP 16
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// allianceTeam := [ ] ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// arabianAttacked := false ;
 239: LD_ADDR_EXP 18
 243: PUSH
 244: LD_INT 0
 246: ST_TO_ADDR
// end ;
 247: LD_VAR 0 1
 251: RET
// export function CustomInitMacro ( ) ; begin
 252: LD_INT 0
 254: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 255: LD_ADDR_EXP 104
 259: PUSH
 260: LD_INT 26
 262: PUSH
 263: LD_INT 1
 265: PUSH
 266: LD_INT 4
 268: PUSH
 269: LD_INT 8
 271: PUSH
 272: EMPTY
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 278: LD_ADDR_EXP 105
 282: PUSH
 283: LD_INT 27
 285: PUSH
 286: LD_INT 2
 288: PUSH
 289: LD_INT 3
 291: PUSH
 292: LD_INT 7
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 301: LD_INT 1
 303: PPUSH
 304: LD_INT 6
 306: PUSH
 307: LD_INT 7
 309: PUSH
 310: LD_INT 9
 312: PUSH
 313: LD_INT 10
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PUSH
 322: LD_OWVAR 67
 326: ARRAY
 327: PPUSH
 328: LD_INT 28
 330: PPUSH
 331: CALL 47502 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 335: LD_INT 1
 337: PPUSH
 338: LD_INT 10
 340: PUSH
 341: LD_INT 11
 343: PUSH
 344: LD_INT 13
 346: PUSH
 347: LD_INT 15
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: LIST
 354: LIST
 355: PPUSH
 356: CALL 48585 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 29
 365: PUSH
 366: EMPTY
 367: LIST
 368: PPUSH
 369: CALL 48682 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 373: LD_ADDR_EXP 109
 377: PUSH
 378: LD_EXP 109
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: LD_INT 22
 388: PUSH
 389: LD_INT 2
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: PUSH
 396: LD_INT 25
 398: PUSH
 399: LD_INT 15
 401: PUSH
 402: EMPTY
 403: LIST
 404: LIST
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: PPUSH
 410: CALL_OW 69
 414: PPUSH
 415: CALL_OW 1
 419: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 420: LD_INT 1
 422: PPUSH
 423: LD_INT 13
 425: PUSH
 426: LD_INT 2
 428: PUSH
 429: LD_INT 1
 431: PUSH
 432: LD_INT 31
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: PUSH
 441: LD_INT 13
 443: PUSH
 444: LD_INT 2
 446: PUSH
 447: LD_INT 1
 449: PUSH
 450: LD_INT 31
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: PUSH
 459: LD_INT 13
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 1
 467: PUSH
 468: LD_INT 28
 470: PUSH
 471: EMPTY
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 13
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 1
 485: PUSH
 486: LD_INT 28
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: PUSH
 495: LD_INT 13
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 28
 506: PUSH
 507: EMPTY
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 13
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: LD_INT 1
 521: PUSH
 522: LD_INT 28
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_INT 13
 533: PUSH
 534: LD_INT 1
 536: PUSH
 537: LD_INT 2
 539: PUSH
 540: LD_INT 88
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: LIST
 547: LIST
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: CALL 47839 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 4
 567: PPUSH
 568: CALL 48024 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 572: LD_INT 2
 574: PPUSH
 575: LD_INT 10
 577: PUSH
 578: LD_INT 11
 580: PUSH
 581: LD_INT 12
 583: PUSH
 584: LD_INT 14
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PPUSH
 593: CALL 48585 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 597: LD_INT 2
 599: PPUSH
 600: LD_INT 14
 602: PUSH
 603: EMPTY
 604: LIST
 605: PPUSH
 606: CALL 48682 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 610: LD_INT 2
 612: PPUSH
 613: LD_INT 21
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 51
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 22
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 52
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: LD_INT 24
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 3
 747: PUSH
 748: LD_INT 47
 750: PUSH
 751: EMPTY
 752: LIST
 753: LIST
 754: LIST
 755: LIST
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PPUSH
 767: CALL 47839 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 771: LD_INT 2
 773: PPUSH
 774: LD_INT 5
 776: PPUSH
 777: CALL 48024 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 781: LD_INT 2
 783: PPUSH
 784: LD_INT 0
 786: PPUSH
 787: CALL 48456 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 791: LD_INT 3
 793: PPUSH
 794: LD_INT 10
 796: PUSH
 797: LD_INT 12
 799: PUSH
 800: LD_INT 14
 802: PUSH
 803: LD_INT 15
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: PUSH
 812: LD_OWVAR 67
 816: ARRAY
 817: PPUSH
 818: LD_INT 24
 820: PPUSH
 821: CALL 47502 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 825: LD_INT 3
 827: PPUSH
 828: LD_INT 10
 830: PUSH
 831: LD_INT 11
 833: PUSH
 834: LD_INT 13
 836: PUSH
 837: LD_INT 15
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PPUSH
 846: CALL 48585 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 850: LD_INT 3
 852: PPUSH
 853: LD_INT 13
 855: PUSH
 856: EMPTY
 857: LIST
 858: PPUSH
 859: CALL 48682 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 863: LD_ADDR_EXP 109
 867: PUSH
 868: LD_EXP 109
 872: PPUSH
 873: LD_INT 3
 875: PPUSH
 876: LD_INT 22
 878: PUSH
 879: LD_INT 8
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: PUSH
 886: LD_INT 25
 888: PUSH
 889: LD_INT 15
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: PPUSH
 900: CALL_OW 69
 904: PPUSH
 905: CALL_OW 1
 909: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 910: LD_INT 3
 912: PPUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 2
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 31
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 13
 951: PUSH
 952: LD_INT 3
 954: PUSH
 955: LD_INT 2
 957: PUSH
 958: LD_INT 32
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 28
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: PUSH
1039: LD_INT 14
1041: PUSH
1042: LD_INT 1
1044: PUSH
1045: LD_INT 2
1047: PUSH
1048: LD_INT 88
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: LIST
1066: PPUSH
1067: CALL 47839 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1071: LD_INT 3
1073: PPUSH
1074: LD_INT 4
1076: PPUSH
1077: CALL 48024 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 10
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 11
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: EMPTY
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 48585 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 33
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 48682 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 6
1127: PUSH
1128: LD_INT 7
1130: PUSH
1131: LD_INT 9
1133: PUSH
1134: LD_INT 10
1136: PUSH
1137: EMPTY
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 49012 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1148: LD_INT 4
1150: PPUSH
1151: LD_INT 54
1153: PPUSH
1154: LD_INT 85
1156: PPUSH
1157: LD_INT 2
1159: PPUSH
1160: LD_INT 25
1162: PUSH
1163: LD_INT 16
1165: PUSH
1166: LD_INT 17
1168: PUSH
1169: LD_INT 18
1171: PUSH
1172: LD_INT 22
1174: PUSH
1175: EMPTY
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 48802 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 5
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 1
1197: PUSH
1198: LD_INT 7
1200: PUSH
1201: EMPTY
1202: LIST
1203: LIST
1204: LIST
1205: LIST
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 1
1215: PUSH
1216: LD_INT 6
1218: PUSH
1219: EMPTY
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: PUSH
1225: LD_INT 5
1227: PUSH
1228: LD_INT 1
1230: PUSH
1231: LD_INT 1
1233: PUSH
1234: LD_INT 7
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: LD_INT 1
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: LD_INT 6
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: LD_INT 1
1266: PUSH
1267: LD_INT 3
1269: PUSH
1270: LD_INT 12
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: PUSH
1279: LD_INT 3
1281: PUSH
1282: LD_INT 1
1284: PUSH
1285: LD_INT 3
1287: PUSH
1288: LD_INT 13
1290: PUSH
1291: EMPTY
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PUSH
1297: EMPTY
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: LIST
1304: PPUSH
1305: CALL 47839 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1309: LD_INT 4
1311: PPUSH
1312: LD_INT 4
1314: PPUSH
1315: CALL 48024 0 2
// MC_SetTame ( 4 , powellApe ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 11
1324: PPUSH
1325: CALL 48405 0 2
// end ;
1329: LD_VAR 0 1
1333: RET
// every 0 0$1 trigger debug do var i ;
1334: LD_EXP 1
1338: IFFALSE 1436
1340: GO 1342
1342: DISABLE
1343: LD_INT 0
1345: PPUSH
// begin enable ;
1346: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1347: LD_ADDR_VAR 0 1
1351: PUSH
1352: LD_INT 22
1354: PUSH
1355: LD_INT 7
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: LD_INT 21
1367: PUSH
1368: LD_INT 1
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: PUSH
1375: LD_INT 21
1377: PUSH
1378: LD_INT 2
1380: PUSH
1381: EMPTY
1382: LIST
1383: LIST
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: PUSH
1390: LD_INT 3
1392: PUSH
1393: LD_INT 24
1395: PUSH
1396: LD_INT 1000
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PPUSH
1412: CALL_OW 69
1416: PUSH
1417: FOR_IN
1418: IFFALSE 1434
// SetLives ( i , 1000 ) ;
1420: LD_VAR 0 1
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 234
1432: GO 1417
1434: POP
1435: POP
// end ;
1436: PPOPN 1
1438: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1439: LD_EXP 16
1443: PUSH
1444: LD_INT 5
1446: GREATEREQUAL
1447: IFFALSE 1459
1449: GO 1451
1451: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1452: LD_STRING ACH_ARTIFACT
1454: PPUSH
1455: CALL_OW 543
1459: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1460: LD_INT 0
1462: PPUSH
1463: PPUSH
1464: PPUSH
1465: PPUSH
1466: PPUSH
// SetInvulnrability ( alien , true ) ;
1467: LD_INT 1
1469: PPUSH
1470: LD_INT 1
1472: PPUSH
1473: CALL_OW 607
// uc_side := 7 ;
1477: LD_ADDR_OWVAR 20
1481: PUSH
1482: LD_INT 7
1484: ST_TO_ADDR
// tmp := [ ] ;
1485: LD_ADDR_VAR 0 5
1489: PUSH
1490: EMPTY
1491: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1492: LD_ADDR_EXP 21
1496: PUSH
1497: LD_STRING JMM
1499: PPUSH
1500: LD_EXP 1
1504: NOT
1505: PPUSH
1506: LD_STRING 14a_
1508: PPUSH
1509: CALL 54411 0 3
1513: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1514: LD_ADDR_EXP 54
1518: PUSH
1519: LD_STRING Burlak
1521: PPUSH
1522: LD_EXP 1
1526: NOT
1527: PPUSH
1528: LD_STRING 14a_
1530: PPUSH
1531: CALL 54411 0 3
1535: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1536: LD_ADDR_EXP 36
1540: PUSH
1541: LD_STRING Joan
1543: PPUSH
1544: LD_EXP 1
1548: NOT
1549: PPUSH
1550: LD_STRING 13a_
1552: PPUSH
1553: CALL 54411 0 3
1557: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1558: LD_ADDR_EXP 22
1562: PUSH
1563: LD_STRING Roth
1565: PPUSH
1566: LD_EXP 1
1570: NOT
1571: PPUSH
1572: LD_STRING 13a_
1574: PPUSH
1575: CALL 54411 0 3
1579: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1580: LD_ADDR_EXP 40
1584: PUSH
1585: LD_STRING Gossudarov
1587: PPUSH
1588: LD_EXP 1
1592: NOT
1593: PPUSH
1594: LD_STRING 13a_
1596: PPUSH
1597: CALL 54411 0 3
1601: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1602: LD_ADDR_EXP 27
1606: PUSH
1607: LD_STRING Denis
1609: PPUSH
1610: LD_EXP 1
1614: NOT
1615: PPUSH
1616: LD_STRING 13a_
1618: PPUSH
1619: CALL 54411 0 3
1623: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1624: LD_ADDR_EXP 37
1628: PUSH
1629: LD_STRING DeltaDoctor
1631: PPUSH
1632: LD_EXP 1
1636: NOT
1637: PPUSH
1638: LD_STRING 13a_
1640: PPUSH
1641: CALL 54411 0 3
1645: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1646: LD_ADDR_EXP 39
1650: PUSH
1651: LD_STRING Mike
1653: PPUSH
1654: LD_EXP 1
1658: NOT
1659: PPUSH
1660: LD_STRING 13a_
1662: PPUSH
1663: CALL 54411 0 3
1667: ST_TO_ADDR
// if DeltaDoctor then
1668: LD_EXP 37
1672: IFFALSE 1690
// tmp := tmp ^ DeltaDoctor ;
1674: LD_ADDR_VAR 0 5
1678: PUSH
1679: LD_VAR 0 5
1683: PUSH
1684: LD_EXP 37
1688: ADD
1689: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1690: LD_ADDR_EXP 35
1694: PUSH
1695: LD_STRING Simms
1697: PPUSH
1698: LD_EXP 1
1702: NOT
1703: PPUSH
1704: LD_STRING 13a_
1706: PPUSH
1707: CALL 54411 0 3
1711: ST_TO_ADDR
// if Simms then
1712: LD_EXP 35
1716: IFFALSE 1734
// tmp := tmp ^ Simms ;
1718: LD_ADDR_VAR 0 5
1722: PUSH
1723: LD_VAR 0 5
1727: PUSH
1728: LD_EXP 35
1732: ADD
1733: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1734: LD_ADDR_EXP 33
1738: PUSH
1739: LD_STRING Frank
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 13a_
1750: PPUSH
1751: CALL 54411 0 3
1755: ST_TO_ADDR
// if Frank then
1756: LD_EXP 33
1760: IFFALSE 1778
// tmp := tmp ^ Frank ;
1762: LD_ADDR_VAR 0 5
1766: PUSH
1767: LD_VAR 0 5
1771: PUSH
1772: LD_EXP 33
1776: ADD
1777: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1778: LD_ADDR_EXP 41
1782: PUSH
1783: LD_STRING Kirilenkova
1785: PPUSH
1786: LD_EXP 1
1790: NOT
1791: PPUSH
1792: LD_STRING 13a_
1794: PPUSH
1795: CALL 54411 0 3
1799: ST_TO_ADDR
// if Kirilenkova then
1800: LD_EXP 41
1804: IFFALSE 1822
// tmp := tmp ^ Kirilenkova ;
1806: LD_ADDR_VAR 0 5
1810: PUSH
1811: LD_VAR 0 5
1815: PUSH
1816: LD_EXP 41
1820: ADD
1821: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1822: LD_ADDR_EXP 42
1826: PUSH
1827: LD_STRING Titov
1829: PPUSH
1830: LD_EXP 1
1834: NOT
1835: PPUSH
1836: LD_STRING 13a_
1838: PPUSH
1839: CALL 54411 0 3
1843: ST_TO_ADDR
// if Titov then
1844: LD_EXP 42
1848: IFFALSE 1866
// tmp := tmp ^ Titov ;
1850: LD_ADDR_VAR 0 5
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 42
1864: ADD
1865: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1866: LD_ADDR_EXP 43
1870: PUSH
1871: LD_STRING Fadeev
1873: PPUSH
1874: LD_EXP 1
1878: NOT
1879: PPUSH
1880: LD_STRING 13a_
1882: PPUSH
1883: CALL 54411 0 3
1887: ST_TO_ADDR
// if Fadeev then
1888: LD_EXP 43
1892: IFFALSE 1910
// tmp := tmp ^ Fadeev ;
1894: LD_ADDR_VAR 0 5
1898: PUSH
1899: LD_VAR 0 5
1903: PUSH
1904: LD_EXP 43
1908: ADD
1909: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1910: LD_ADDR_EXP 44
1914: PUSH
1915: LD_STRING Dolgov
1917: PPUSH
1918: LD_EXP 1
1922: NOT
1923: PPUSH
1924: LD_STRING 13a_
1926: PPUSH
1927: CALL 54411 0 3
1931: ST_TO_ADDR
// if Dolgov then
1932: LD_EXP 44
1936: IFFALSE 1954
// tmp := tmp ^ Dolgov ;
1938: LD_ADDR_VAR 0 5
1942: PUSH
1943: LD_VAR 0 5
1947: PUSH
1948: LD_EXP 44
1952: ADD
1953: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1954: LD_ADDR_EXP 45
1958: PUSH
1959: LD_STRING Petrosyan
1961: PPUSH
1962: LD_EXP 1
1966: NOT
1967: PPUSH
1968: LD_STRING 13a_
1970: PPUSH
1971: CALL 54411 0 3
1975: ST_TO_ADDR
// if Petrosyan then
1976: LD_EXP 45
1980: IFFALSE 1998
// tmp := tmp ^ Petrosyan ;
1982: LD_ADDR_VAR 0 5
1986: PUSH
1987: LD_VAR 0 5
1991: PUSH
1992: LD_EXP 45
1996: ADD
1997: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1998: LD_ADDR_EXP 46
2002: PUSH
2003: LD_STRING Scholtze
2005: PPUSH
2006: LD_EXP 1
2010: NOT
2011: PPUSH
2012: LD_STRING 13a_
2014: PPUSH
2015: CALL 54411 0 3
2019: ST_TO_ADDR
// if Scholtze then
2020: LD_EXP 46
2024: IFFALSE 2042
// tmp := tmp ^ Scholtze ;
2026: LD_ADDR_VAR 0 5
2030: PUSH
2031: LD_VAR 0 5
2035: PUSH
2036: LD_EXP 46
2040: ADD
2041: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2042: LD_ADDR_EXP 47
2046: PUSH
2047: LD_STRING Oblukov
2049: PPUSH
2050: LD_EXP 1
2054: NOT
2055: PPUSH
2056: LD_STRING 13a_
2058: PPUSH
2059: CALL 54411 0 3
2063: ST_TO_ADDR
// if Oblukov then
2064: LD_EXP 47
2068: IFFALSE 2086
// tmp := tmp ^ Oblukov ;
2070: LD_ADDR_VAR 0 5
2074: PUSH
2075: LD_VAR 0 5
2079: PUSH
2080: LD_EXP 47
2084: ADD
2085: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2086: LD_ADDR_EXP 48
2090: PUSH
2091: LD_STRING Kapitsova
2093: PPUSH
2094: LD_EXP 1
2098: NOT
2099: PPUSH
2100: LD_STRING 13a_
2102: PPUSH
2103: CALL 54411 0 3
2107: ST_TO_ADDR
// if Kapitsova then
2108: LD_EXP 48
2112: IFFALSE 2130
// tmp := tmp ^ Kapitsova ;
2114: LD_ADDR_VAR 0 5
2118: PUSH
2119: LD_VAR 0 5
2123: PUSH
2124: LD_EXP 48
2128: ADD
2129: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2130: LD_ADDR_EXP 49
2134: PUSH
2135: LD_STRING Lipshchin
2137: PPUSH
2138: LD_EXP 1
2142: NOT
2143: PPUSH
2144: LD_STRING 13a_
2146: PPUSH
2147: CALL 54411 0 3
2151: ST_TO_ADDR
// if Lipshchin then
2152: LD_EXP 49
2156: IFFALSE 2174
// tmp := tmp ^ Lipshchin ;
2158: LD_ADDR_VAR 0 5
2162: PUSH
2163: LD_VAR 0 5
2167: PUSH
2168: LD_EXP 49
2172: ADD
2173: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2174: LD_ADDR_EXP 50
2178: PUSH
2179: LD_STRING Petrovova
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13a_
2190: PPUSH
2191: CALL 54411 0 3
2195: ST_TO_ADDR
// if Petrovova then
2196: LD_EXP 50
2200: IFFALSE 2218
// tmp := tmp ^ Petrovova ;
2202: LD_ADDR_VAR 0 5
2206: PUSH
2207: LD_VAR 0 5
2211: PUSH
2212: LD_EXP 50
2216: ADD
2217: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2218: LD_ADDR_EXP 51
2222: PUSH
2223: LD_STRING Kovalyuk
2225: PPUSH
2226: LD_EXP 1
2230: NOT
2231: PPUSH
2232: LD_STRING 13a_
2234: PPUSH
2235: CALL 54411 0 3
2239: ST_TO_ADDR
// if Kovalyuk then
2240: LD_EXP 51
2244: IFFALSE 2262
// tmp := tmp ^ Kovalyuk ;
2246: LD_ADDR_VAR 0 5
2250: PUSH
2251: LD_VAR 0 5
2255: PUSH
2256: LD_EXP 51
2260: ADD
2261: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2262: LD_ADDR_EXP 52
2266: PUSH
2267: LD_STRING Kuzmov
2269: PPUSH
2270: LD_EXP 1
2274: NOT
2275: PPUSH
2276: LD_STRING 13a_
2278: PPUSH
2279: CALL 54411 0 3
2283: ST_TO_ADDR
// if Kuzmov then
2284: LD_EXP 52
2288: IFFALSE 2306
// tmp := tmp ^ Kuzmov ;
2290: LD_ADDR_VAR 0 5
2294: PUSH
2295: LD_VAR 0 5
2299: PUSH
2300: LD_EXP 52
2304: ADD
2305: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2306: LD_ADDR_EXP 53
2310: PUSH
2311: LD_STRING Karamazov
2313: PPUSH
2314: LD_EXP 1
2318: NOT
2319: PPUSH
2320: LD_STRING 13a_
2322: PPUSH
2323: CALL 54411 0 3
2327: ST_TO_ADDR
// if Karamazov then
2328: LD_EXP 53
2332: IFFALSE 2350
// tmp := tmp ^ Karamazov ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 5
2343: PUSH
2344: LD_EXP 53
2348: ADD
2349: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2350: LD_ADDR_EXP 55
2354: PUSH
2355: LD_STRING Belkov
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13a_
2366: PPUSH
2367: CALL 54411 0 3
2371: ST_TO_ADDR
// if Belkov then
2372: LD_EXP 55
2376: IFFALSE 2394
// tmp := tmp ^ Belkov ;
2378: LD_ADDR_VAR 0 5
2382: PUSH
2383: LD_VAR 0 5
2387: PUSH
2388: LD_EXP 55
2392: ADD
2393: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2394: LD_ADDR_EXP 56
2398: PUSH
2399: LD_STRING Gnyevko
2401: PPUSH
2402: LD_EXP 1
2406: NOT
2407: PPUSH
2408: LD_STRING 13a_
2410: PPUSH
2411: CALL 54411 0 3
2415: ST_TO_ADDR
// if Gnyevko then
2416: LD_EXP 56
2420: IFFALSE 2438
// tmp := tmp ^ Gnyevko ;
2422: LD_ADDR_VAR 0 5
2426: PUSH
2427: LD_VAR 0 5
2431: PUSH
2432: LD_EXP 56
2436: ADD
2437: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2438: LD_ADDR_EXP 38
2442: PUSH
2443: LD_STRING Coonie
2445: PPUSH
2446: CALL_OW 25
2450: ST_TO_ADDR
// if not Lisa then
2451: LD_EXP 23
2455: NOT
2456: IFFALSE 2502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2458: LD_ADDR_EXP 23
2462: PUSH
2463: LD_STRING Lisa
2465: PPUSH
2466: LD_EXP 1
2470: NOT
2471: PPUSH
2472: LD_STRING 13a_
2474: PPUSH
2475: CALL 54411 0 3
2479: ST_TO_ADDR
// if Lisa then
2480: LD_EXP 23
2484: IFFALSE 2502
// tmp := tmp ^ Lisa ;
2486: LD_ADDR_VAR 0 5
2490: PUSH
2491: LD_VAR 0 5
2495: PUSH
2496: LD_EXP 23
2500: ADD
2501: ST_TO_ADDR
// end ; if not Donaldson then
2502: LD_EXP 24
2506: NOT
2507: IFFALSE 2553
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2509: LD_ADDR_EXP 24
2513: PUSH
2514: LD_STRING Donaldson
2516: PPUSH
2517: LD_EXP 1
2521: NOT
2522: PPUSH
2523: LD_STRING 13a_
2525: PPUSH
2526: CALL 54411 0 3
2530: ST_TO_ADDR
// if Donaldson then
2531: LD_EXP 24
2535: IFFALSE 2553
// tmp := tmp ^ Donaldson ;
2537: LD_ADDR_VAR 0 5
2541: PUSH
2542: LD_VAR 0 5
2546: PUSH
2547: LD_EXP 24
2551: ADD
2552: ST_TO_ADDR
// end ; if not Bobby then
2553: LD_EXP 25
2557: NOT
2558: IFFALSE 2604
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2560: LD_ADDR_EXP 25
2564: PUSH
2565: LD_STRING Bobby
2567: PPUSH
2568: LD_EXP 1
2572: NOT
2573: PPUSH
2574: LD_STRING 13a_
2576: PPUSH
2577: CALL 54411 0 3
2581: ST_TO_ADDR
// if Bobby then
2582: LD_EXP 25
2586: IFFALSE 2604
// tmp := tmp ^ Bobby ;
2588: LD_ADDR_VAR 0 5
2592: PUSH
2593: LD_VAR 0 5
2597: PUSH
2598: LD_EXP 25
2602: ADD
2603: ST_TO_ADDR
// end ; if not Cyrus then
2604: LD_EXP 26
2608: NOT
2609: IFFALSE 2655
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2611: LD_ADDR_EXP 26
2615: PUSH
2616: LD_STRING Cyrus
2618: PPUSH
2619: LD_EXP 1
2623: NOT
2624: PPUSH
2625: LD_STRING 13a_
2627: PPUSH
2628: CALL 54411 0 3
2632: ST_TO_ADDR
// if Cyrus then
2633: LD_EXP 26
2637: IFFALSE 2655
// tmp := tmp ^ Cyrus ;
2639: LD_ADDR_VAR 0 5
2643: PUSH
2644: LD_VAR 0 5
2648: PUSH
2649: LD_EXP 26
2653: ADD
2654: ST_TO_ADDR
// end ; if not Brown then
2655: LD_EXP 28
2659: NOT
2660: IFFALSE 2706
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2662: LD_ADDR_EXP 28
2666: PUSH
2667: LD_STRING Brown
2669: PPUSH
2670: LD_EXP 1
2674: NOT
2675: PPUSH
2676: LD_STRING 13a_
2678: PPUSH
2679: CALL 54411 0 3
2683: ST_TO_ADDR
// if Brown then
2684: LD_EXP 28
2688: IFFALSE 2706
// tmp := tmp ^ Brown ;
2690: LD_ADDR_VAR 0 5
2694: PUSH
2695: LD_VAR 0 5
2699: PUSH
2700: LD_EXP 28
2704: ADD
2705: ST_TO_ADDR
// end ; if not Gladstone then
2706: LD_EXP 29
2710: NOT
2711: IFFALSE 2757
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2713: LD_ADDR_EXP 29
2717: PUSH
2718: LD_STRING Gladstone
2720: PPUSH
2721: LD_EXP 1
2725: NOT
2726: PPUSH
2727: LD_STRING 13a_
2729: PPUSH
2730: CALL 54411 0 3
2734: ST_TO_ADDR
// if Gladstone then
2735: LD_EXP 29
2739: IFFALSE 2757
// tmp := tmp ^ Gladstone ;
2741: LD_ADDR_VAR 0 5
2745: PUSH
2746: LD_VAR 0 5
2750: PUSH
2751: LD_EXP 29
2755: ADD
2756: ST_TO_ADDR
// end ; if not Cornel then
2757: LD_EXP 31
2761: NOT
2762: IFFALSE 2808
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2764: LD_ADDR_EXP 31
2768: PUSH
2769: LD_STRING Cornel
2771: PPUSH
2772: LD_EXP 1
2776: NOT
2777: PPUSH
2778: LD_STRING 13a_
2780: PPUSH
2781: CALL 54411 0 3
2785: ST_TO_ADDR
// if Cornel then
2786: LD_EXP 31
2790: IFFALSE 2808
// tmp := tmp ^ Cornel ;
2792: LD_ADDR_VAR 0 5
2796: PUSH
2797: LD_VAR 0 5
2801: PUSH
2802: LD_EXP 31
2806: ADD
2807: ST_TO_ADDR
// end ; if not Houten then
2808: LD_EXP 30
2812: NOT
2813: IFFALSE 2859
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2815: LD_ADDR_EXP 30
2819: PUSH
2820: LD_STRING Houten
2822: PPUSH
2823: LD_EXP 1
2827: NOT
2828: PPUSH
2829: LD_STRING 13a_
2831: PPUSH
2832: CALL 54411 0 3
2836: ST_TO_ADDR
// if Houten then
2837: LD_EXP 30
2841: IFFALSE 2859
// tmp := tmp ^ Houten ;
2843: LD_ADDR_VAR 0 5
2847: PUSH
2848: LD_VAR 0 5
2852: PUSH
2853: LD_EXP 30
2857: ADD
2858: ST_TO_ADDR
// end ; if not Gary then
2859: LD_EXP 32
2863: NOT
2864: IFFALSE 2910
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2866: LD_ADDR_EXP 32
2870: PUSH
2871: LD_STRING Gary
2873: PPUSH
2874: LD_EXP 1
2878: NOT
2879: PPUSH
2880: LD_STRING 13a_
2882: PPUSH
2883: CALL 54411 0 3
2887: ST_TO_ADDR
// if Gary then
2888: LD_EXP 32
2892: IFFALSE 2910
// tmp := tmp ^ Gary ;
2894: LD_ADDR_VAR 0 5
2898: PUSH
2899: LD_VAR 0 5
2903: PUSH
2904: LD_EXP 32
2908: ADD
2909: ST_TO_ADDR
// end ; if not Kikuchi then
2910: LD_EXP 34
2914: NOT
2915: IFFALSE 2961
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2917: LD_ADDR_EXP 34
2921: PUSH
2922: LD_STRING Kikuchi
2924: PPUSH
2925: LD_EXP 1
2929: NOT
2930: PPUSH
2931: LD_STRING 13a_
2933: PPUSH
2934: CALL 54411 0 3
2938: ST_TO_ADDR
// if Kikuchi then
2939: LD_EXP 34
2943: IFFALSE 2961
// tmp := tmp ^ Kikuchi ;
2945: LD_ADDR_VAR 0 5
2949: PUSH
2950: LD_VAR 0 5
2954: PUSH
2955: LD_EXP 34
2959: ADD
2960: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2961: LD_ADDR_VAR 0 5
2965: PUSH
2966: LD_VAR 0 5
2970: PUSH
2971: LD_STRING 13a_others
2973: PPUSH
2974: CALL_OW 31
2978: UNION
2979: ST_TO_ADDR
// tmp := tmp diff 0 ;
2980: LD_ADDR_VAR 0 5
2984: PUSH
2985: LD_VAR 0 5
2989: PUSH
2990: LD_INT 0
2992: DIFF
2993: ST_TO_ADDR
// if tmp < 15 then
2994: LD_VAR 0 5
2998: PUSH
2999: LD_INT 15
3001: LESS
3002: IFFALSE 3090
// for i = 15 downto tmp do
3004: LD_ADDR_VAR 0 2
3008: PUSH
3009: DOUBLE
3010: LD_INT 15
3012: INC
3013: ST_TO_ADDR
3014: LD_VAR 0 5
3018: PUSH
3019: FOR_DOWNTO
3020: IFFALSE 3088
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
3022: LD_ADDR_OWVAR 21
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 1
3039: PPUSH
3040: LD_INT 2
3042: PPUSH
3043: CALL_OW 12
3047: ARRAY
3048: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3049: LD_INT 0
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: LD_INT 4
3057: PPUSH
3058: CALL_OW 12
3062: PPUSH
3063: LD_INT 8
3065: PPUSH
3066: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3070: LD_ADDR_VAR 0 5
3074: PUSH
3075: LD_VAR 0 5
3079: PUSH
3080: CALL_OW 44
3084: ADD
3085: ST_TO_ADDR
// end ;
3086: GO 3019
3088: POP
3089: POP
// if not debug then
3090: LD_EXP 1
3094: NOT
3095: IFFALSE 3275
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3097: LD_ADDR_VAR 0 4
3101: PUSH
3102: LD_STRING 
3104: PPUSH
3105: LD_INT 14
3107: PUSH
3108: LD_INT 13
3110: PUSH
3111: LD_INT 12
3113: PUSH
3114: LD_INT 11
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_OWVAR 67
3127: ARRAY
3128: PPUSH
3129: LD_INT 14
3131: PUSH
3132: LD_INT 13
3134: PUSH
3135: LD_INT 12
3137: PUSH
3138: LD_INT 11
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: PUSH
3147: LD_OWVAR 67
3151: ARRAY
3152: PPUSH
3153: LD_INT -5
3155: PUSH
3156: LD_EXP 21
3160: PUSH
3161: LD_EXP 54
3165: PUSH
3166: LD_EXP 22
3170: PUSH
3171: LD_EXP 36
3175: PUSH
3176: LD_EXP 27
3180: PUSH
3181: LD_EXP 40
3185: PUSH
3186: LD_INT -2
3188: PUSH
3189: LD_INT -3
3191: PUSH
3192: LD_INT -5
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: LIST
3203: LIST
3204: LIST
3205: LIST
3206: PUSH
3207: LD_VAR 0 5
3211: ADD
3212: PPUSH
3213: LD_INT 1
3215: PUSH
3216: LD_INT 4
3218: PUSH
3219: LD_INT 2
3221: PUSH
3222: LD_INT 1
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: PUSH
3229: LD_INT 3
3231: PUSH
3232: LD_INT 5
3234: PUSH
3235: LD_INT 0
3237: PUSH
3238: LD_INT 3
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: LIST
3245: PUSH
3246: LD_INT 9
3248: PUSH
3249: LD_INT 0
3251: PUSH
3252: LD_INT 3
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: LIST
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: PPUSH
3268: CALL_OW 42
3272: ST_TO_ADDR
3273: GO 3324
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3275: LD_ADDR_VAR 0 4
3279: PUSH
3280: LD_EXP 42
3284: PUSH
3285: LD_EXP 43
3289: PUSH
3290: LD_EXP 44
3294: PUSH
3295: LD_EXP 45
3299: PUSH
3300: LD_EXP 46
3304: PUSH
3305: LD_EXP 47
3309: PUSH
3310: LD_EXP 48
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: LIST
3319: LIST
3320: LIST
3321: LIST
3322: LIST
3323: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3324: LD_ADDR_EXP 17
3328: PUSH
3329: LD_VAR 0 5
3333: PUSH
3334: LD_VAR 0 4
3338: DIFF
3339: ST_TO_ADDR
// uc_nation := 1 ;
3340: LD_ADDR_OWVAR 21
3344: PUSH
3345: LD_INT 1
3347: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3348: LD_INT 5
3350: PPUSH
3351: LD_INT 3
3353: PPUSH
3354: LD_INT 1
3356: PPUSH
3357: LD_INT 6
3359: PPUSH
3360: LD_INT 100
3362: PPUSH
3363: CALL 59431 0 5
// veh := CreateVehicle ;
3367: LD_ADDR_VAR 0 3
3371: PUSH
3372: CALL_OW 45
3376: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3377: LD_VAR 0 3
3381: PPUSH
3382: LD_INT 7
3384: NEG
3385: PPUSH
3386: CALL_OW 242
// SetDir ( veh , 3 ) ;
3390: LD_VAR 0 3
3394: PPUSH
3395: LD_INT 3
3397: PPUSH
3398: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3402: LD_VAR 0 3
3406: PPUSH
3407: LD_INT 31
3409: PPUSH
3410: LD_INT 0
3412: PPUSH
3413: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3417: LD_EXP 21
3421: PPUSH
3422: LD_VAR 0 3
3426: PPUSH
3427: CALL_OW 52
// if Joan then
3431: LD_EXP 36
3435: IFFALSE 3507
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3437: LD_INT 3
3439: PPUSH
3440: LD_INT 3
3442: PPUSH
3443: LD_INT 1
3445: PPUSH
3446: LD_INT 11
3448: PPUSH
3449: LD_INT 100
3451: PPUSH
3452: CALL 59431 0 5
// veh := CreateVehicle ;
3456: LD_ADDR_VAR 0 3
3460: PUSH
3461: CALL_OW 45
3465: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3466: LD_VAR 0 3
3470: PPUSH
3471: LD_INT 3
3473: PPUSH
3474: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3478: LD_VAR 0 3
3482: PPUSH
3483: LD_INT 30
3485: PPUSH
3486: LD_INT 0
3488: PPUSH
3489: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3493: LD_EXP 36
3497: PPUSH
3498: LD_VAR 0 3
3502: PPUSH
3503: CALL_OW 52
// end ; if Roth then
3507: LD_EXP 22
3511: IFFALSE 3583
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 1
3521: PPUSH
3522: LD_INT 11
3524: PPUSH
3525: LD_INT 100
3527: PPUSH
3528: CALL 59431 0 5
// veh := CreateVehicle ;
3532: LD_ADDR_VAR 0 3
3536: PUSH
3537: CALL_OW 45
3541: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3542: LD_VAR 0 3
3546: PPUSH
3547: LD_INT 3
3549: PPUSH
3550: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3554: LD_VAR 0 3
3558: PPUSH
3559: LD_INT 30
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3569: LD_EXP 22
3573: PPUSH
3574: LD_VAR 0 3
3578: PPUSH
3579: CALL_OW 52
// end ; if Denis then
3583: LD_EXP 27
3587: IFFALSE 3659
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3589: LD_INT 5
3591: PPUSH
3592: LD_INT 3
3594: PPUSH
3595: LD_INT 1
3597: PPUSH
3598: LD_INT 9
3600: PPUSH
3601: LD_INT 100
3603: PPUSH
3604: CALL 59431 0 5
// veh := CreateVehicle ;
3608: LD_ADDR_VAR 0 3
3612: PUSH
3613: CALL_OW 45
3617: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3618: LD_VAR 0 3
3622: PPUSH
3623: LD_INT 3
3625: PPUSH
3626: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3630: LD_VAR 0 3
3634: PPUSH
3635: LD_INT 30
3637: PPUSH
3638: LD_INT 0
3640: PPUSH
3641: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3645: LD_EXP 27
3649: PPUSH
3650: LD_VAR 0 3
3654: PPUSH
3655: CALL_OW 52
// end ; uc_nation := 3 ;
3659: LD_ADDR_OWVAR 21
3663: PUSH
3664: LD_INT 3
3666: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3667: LD_INT 22
3669: PPUSH
3670: LD_INT 3
3672: PPUSH
3673: LD_INT 1
3675: PPUSH
3676: LD_INT 45
3678: PPUSH
3679: LD_INT 100
3681: PPUSH
3682: CALL 59431 0 5
// veh := CreateVehicle ;
3686: LD_ADDR_VAR 0 3
3690: PUSH
3691: CALL_OW 45
3695: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3696: LD_VAR 0 3
3700: PPUSH
3701: LD_INT 7
3703: NEG
3704: PPUSH
3705: CALL_OW 242
// SetDir ( veh , 3 ) ;
3709: LD_VAR 0 3
3713: PPUSH
3714: LD_INT 3
3716: PPUSH
3717: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3721: LD_VAR 0 3
3725: PPUSH
3726: LD_INT 31
3728: PPUSH
3729: LD_INT 0
3731: PPUSH
3732: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3736: LD_EXP 54
3740: PPUSH
3741: LD_VAR 0 3
3745: PPUSH
3746: CALL_OW 52
// if Gossudarov then
3750: LD_EXP 40
3754: IFFALSE 3841
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3756: LD_INT 22
3758: PPUSH
3759: LD_INT 3
3761: PPUSH
3762: LD_INT 1
3764: PPUSH
3765: LD_INT 51
3767: PPUSH
3768: LD_INT 100
3770: PPUSH
3771: CALL 59431 0 5
// veh := CreateVehicle ;
3775: LD_ADDR_VAR 0 3
3779: PUSH
3780: CALL_OW 45
3784: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3785: LD_VAR 0 3
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3797: LD_VAR 0 3
3801: PPUSH
3802: LD_INT 30
3804: PPUSH
3805: LD_INT 0
3807: PPUSH
3808: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3812: LD_EXP 40
3816: PPUSH
3817: LD_VAR 0 3
3821: PPUSH
3822: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3826: LD_VAR 0 3
3830: PPUSH
3831: LD_INT 1
3833: PPUSH
3834: LD_INT 100
3836: PPUSH
3837: CALL_OW 290
// end ; if Mike then
3841: LD_EXP 39
3845: IFFALSE 3862
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3847: LD_EXP 39
3851: PPUSH
3852: LD_INT 30
3854: PPUSH
3855: LD_INT 0
3857: PPUSH
3858: CALL_OW 49
// for i in selected do
3862: LD_ADDR_VAR 0 2
3866: PUSH
3867: LD_VAR 0 4
3871: PUSH
3872: FOR_IN
3873: IFFALSE 4431
// begin uc_nation := GetNation ( i ) ;
3875: LD_ADDR_OWVAR 21
3879: PUSH
3880: LD_VAR 0 2
3884: PPUSH
3885: CALL_OW 248
3889: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3890: LD_VAR 0 2
3894: PUSH
3895: LD_EXP 23
3899: PUSH
3900: LD_EXP 24
3904: PUSH
3905: LD_EXP 26
3909: PUSH
3910: LD_EXP 25
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: LIST
3919: LIST
3920: IN
3921: IFFALSE 3944
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3923: LD_INT 5
3925: PPUSH
3926: LD_INT 3
3928: PPUSH
3929: LD_INT 1
3931: PPUSH
3932: LD_INT 6
3934: PPUSH
3935: LD_INT 100
3937: PPUSH
3938: CALL 59431 0 5
3942: GO 4378
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3944: LD_VAR 0 2
3948: PUSH
3949: LD_EXP 47
3953: PUSH
3954: LD_EXP 52
3958: PUSH
3959: LD_EXP 50
3963: PUSH
3964: LD_EXP 42
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: LIST
3973: LIST
3974: IN
3975: IFFALSE 4006
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3977: LD_INT 24
3979: PPUSH
3980: LD_INT 1
3982: PPUSH
3983: LD_INT 1
3985: PPUSH
3986: LD_INT 46
3988: PPUSH
3989: LD_INT 65
3991: PPUSH
3992: LD_INT 75
3994: PPUSH
3995: CALL_OW 12
3999: PPUSH
4000: CALL 59431 0 5
4004: GO 4378
// if i = Karamazov then
4006: LD_VAR 0 2
4010: PUSH
4011: LD_EXP 53
4015: EQUAL
4016: IFFALSE 4039
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
4018: LD_INT 22
4020: PPUSH
4021: LD_INT 3
4023: PPUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 52
4029: PPUSH
4030: LD_INT 100
4032: PPUSH
4033: CALL 59431 0 5
4037: GO 4378
// if i = Brown then
4039: LD_VAR 0 2
4043: PUSH
4044: LD_EXP 28
4048: EQUAL
4049: IFFALSE 4072
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 3
4056: PPUSH
4057: LD_INT 1
4059: PPUSH
4060: LD_INT 13
4062: PPUSH
4063: LD_INT 100
4065: PPUSH
4066: CALL 59431 0 5
4070: GO 4378
// if uc_nation = nation_american then
4072: LD_OWVAR 21
4076: PUSH
4077: LD_INT 1
4079: EQUAL
4080: IFFALSE 4231
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4082: LD_INT 3
4084: PUSH
4085: LD_INT 5
4087: PUSH
4088: LD_INT 5
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: LIST
4095: PUSH
4096: LD_OWVAR 21
4100: PUSH
4101: LD_INT 3
4103: MOD
4104: PUSH
4105: LD_INT 1
4107: PLUS
4108: ARRAY
4109: PPUSH
4110: LD_INT 1
4112: PUSH
4113: LD_INT 3
4115: PUSH
4116: LD_INT 1
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: LIST
4123: PUSH
4124: LD_OWVAR 21
4128: PUSH
4129: LD_INT 3
4131: MOD
4132: PUSH
4133: LD_INT 1
4135: PLUS
4136: ARRAY
4137: PPUSH
4138: LD_INT 1
4140: PPUSH
4141: LD_INT 11
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: LD_INT 5
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: LIST
4154: PUSH
4155: LD_INT 6
4157: PUSH
4158: LD_INT 7
4160: PUSH
4161: LD_INT 9
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: LIST
4168: PUSH
4169: LD_INT 6
4171: PUSH
4172: LD_INT 9
4174: PUSH
4175: LD_INT 12
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: LIST
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: LIST
4187: PUSH
4188: LD_OWVAR 21
4192: PUSH
4193: LD_INT 3
4195: MOD
4196: PUSH
4197: LD_INT 1
4199: PLUS
4200: ARRAY
4201: PUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 3
4207: PPUSH
4208: CALL_OW 12
4212: ARRAY
4213: PPUSH
4214: LD_INT 65
4216: PPUSH
4217: LD_INT 75
4219: PPUSH
4220: CALL_OW 12
4224: PPUSH
4225: CALL 59431 0 5
// end else
4229: GO 4378
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4231: LD_INT 22
4233: PUSH
4234: LD_INT 23
4236: PUSH
4237: LD_INT 23
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: PUSH
4245: LD_OWVAR 21
4249: PUSH
4250: LD_INT 3
4252: MOD
4253: PUSH
4254: LD_INT 1
4256: PLUS
4257: ARRAY
4258: PPUSH
4259: LD_INT 1
4261: PUSH
4262: LD_INT 3
4264: PUSH
4265: LD_INT 1
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: LIST
4272: PUSH
4273: LD_OWVAR 21
4277: PUSH
4278: LD_INT 3
4280: MOD
4281: PUSH
4282: LD_INT 1
4284: PLUS
4285: ARRAY
4286: PPUSH
4287: LD_INT 1
4289: PPUSH
4290: LD_INT 45
4292: PUSH
4293: LD_INT 43
4295: PUSH
4296: LD_INT 44
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 46
4306: PUSH
4307: LD_INT 45
4309: PUSH
4310: LD_INT 44
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: PUSH
4318: LD_INT 46
4320: PUSH
4321: LD_INT 43
4323: PUSH
4324: LD_INT 45
4326: PUSH
4327: EMPTY
4328: LIST
4329: LIST
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: LIST
4336: PUSH
4337: LD_OWVAR 21
4341: PUSH
4342: LD_INT 3
4344: MOD
4345: PUSH
4346: LD_INT 1
4348: PLUS
4349: ARRAY
4350: PUSH
4351: LD_INT 1
4353: PPUSH
4354: LD_INT 3
4356: PPUSH
4357: CALL_OW 12
4361: ARRAY
4362: PPUSH
4363: LD_INT 65
4365: PPUSH
4366: LD_INT 75
4368: PPUSH
4369: CALL_OW 12
4373: PPUSH
4374: CALL 59431 0 5
// end ; veh := CreateVehicle ;
4378: LD_ADDR_VAR 0 3
4382: PUSH
4383: CALL_OW 45
4387: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4388: LD_VAR 0 3
4392: PPUSH
4393: LD_INT 3
4395: PPUSH
4396: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4400: LD_VAR 0 3
4404: PPUSH
4405: LD_INT 30
4407: PPUSH
4408: LD_INT 0
4410: PPUSH
4411: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4415: LD_VAR 0 2
4419: PPUSH
4420: LD_VAR 0 3
4424: PPUSH
4425: CALL_OW 52
// end ;
4429: GO 3872
4431: POP
4432: POP
// if artifactArCaptured then
4433: LD_EXP 9
4437: IFFALSE 4523
// begin uc_nation := nation_american ;
4439: LD_ADDR_OWVAR 21
4443: PUSH
4444: LD_INT 1
4446: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4447: LD_INT 3
4449: PPUSH
4450: LD_INT 3
4452: PPUSH
4453: LD_INT 3
4455: PPUSH
4456: LD_INT 12
4458: PPUSH
4459: LD_INT 100
4461: PPUSH
4462: CALL 59431 0 5
// veh := CreateVehicle ;
4466: LD_ADDR_VAR 0 3
4470: PUSH
4471: CALL_OW 45
4475: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4476: LD_VAR 0 3
4480: PPUSH
4481: LD_INT 3
4483: PPUSH
4484: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4488: LD_VAR 0 3
4492: PPUSH
4493: LD_INT 198
4495: PPUSH
4496: LD_INT 22
4498: PPUSH
4499: LD_INT 0
4501: PPUSH
4502: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4506: LD_VAR 0 3
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: LD_INT 50
4516: PPUSH
4517: CALL_OW 290
// end else
4521: GO 4542
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4523: LD_INT 4
4525: PPUSH
4526: LD_INT 5
4528: PPUSH
4529: LD_INT 267
4531: PPUSH
4532: LD_INT 226
4534: PPUSH
4535: LD_INT 0
4537: PPUSH
4538: CALL_OW 58
// end ; uc_nation := nation_american ;
4542: LD_ADDR_OWVAR 21
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4550: LD_INT 3
4552: PPUSH
4553: LD_INT 3
4555: PPUSH
4556: LD_INT 3
4558: PPUSH
4559: LD_INT 12
4561: PPUSH
4562: LD_INT 100
4564: PPUSH
4565: CALL 59431 0 5
// veh := CreateVehicle ;
4569: LD_ADDR_VAR 0 3
4573: PUSH
4574: CALL_OW 45
4578: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4579: LD_VAR 0 3
4583: PPUSH
4584: LD_INT 3
4586: PPUSH
4587: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4591: LD_VAR 0 3
4595: PPUSH
4596: LD_INT 218
4598: PPUSH
4599: LD_INT 23
4601: PPUSH
4602: LD_INT 0
4604: PPUSH
4605: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4609: LD_VAR 0 3
4613: PPUSH
4614: LD_INT 4
4616: PPUSH
4617: LD_INT 30
4619: PPUSH
4620: CALL_OW 290
// uc_nation := nation_russian ;
4624: LD_ADDR_OWVAR 21
4628: PUSH
4629: LD_INT 3
4631: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4632: LD_INT 22
4634: PPUSH
4635: LD_INT 3
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 51
4643: PPUSH
4644: LD_INT 100
4646: PPUSH
4647: CALL 59431 0 5
// veh := CreateVehicle ;
4651: LD_ADDR_VAR 0 3
4655: PUSH
4656: CALL_OW 45
4660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4661: LD_VAR 0 3
4665: PPUSH
4666: LD_INT 3
4668: PPUSH
4669: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4673: LD_VAR 0 3
4677: PPUSH
4678: LD_INT 214
4680: PPUSH
4681: LD_INT 20
4683: PPUSH
4684: LD_INT 0
4686: PPUSH
4687: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4691: LD_VAR 0 3
4695: PPUSH
4696: LD_INT 4
4698: PPUSH
4699: LD_INT 40
4701: PPUSH
4702: CALL_OW 290
// end ;
4706: LD_VAR 0 1
4710: RET
// export function AllianceSupport ; var i , veh ; begin
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
// if not allianceTeam then
4716: LD_EXP 17
4720: NOT
4721: IFFALSE 4725
// exit ;
4723: GO 5131
// for i := 1 to 6 do
4725: LD_ADDR_VAR 0 2
4729: PUSH
4730: DOUBLE
4731: LD_INT 1
4733: DEC
4734: ST_TO_ADDR
4735: LD_INT 6
4737: PUSH
4738: FOR_TO
4739: IFFALSE 5035
// begin uc_side := 7 ;
4741: LD_ADDR_OWVAR 20
4745: PUSH
4746: LD_INT 7
4748: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4749: LD_ADDR_OWVAR 21
4753: PUSH
4754: LD_INT 1
4756: PUSH
4757: LD_INT 3
4759: PUSH
4760: EMPTY
4761: LIST
4762: LIST
4763: PUSH
4764: LD_VAR 0 2
4768: PUSH
4769: LD_INT 2
4771: MOD
4772: PUSH
4773: LD_INT 1
4775: PLUS
4776: ARRAY
4777: ST_TO_ADDR
// if uc_nation = 1 then
4778: LD_OWVAR 21
4782: PUSH
4783: LD_INT 1
4785: EQUAL
4786: IFFALSE 4828
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4788: LD_INT 5
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 6
4799: PUSH
4800: LD_INT 7
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: PUSH
4807: LD_INT 1
4809: PPUSH
4810: LD_INT 2
4812: PPUSH
4813: CALL_OW 12
4817: ARRAY
4818: PPUSH
4819: LD_INT 100
4821: PPUSH
4822: CALL 59431 0 5
4826: GO 4866
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4828: LD_INT 23
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 46
4839: PUSH
4840: LD_INT 47
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: LD_INT 1
4849: PPUSH
4850: LD_INT 2
4852: PPUSH
4853: CALL_OW 12
4857: ARRAY
4858: PPUSH
4859: LD_INT 100
4861: PPUSH
4862: CALL 59431 0 5
// if not allianceTeam then
4866: LD_EXP 17
4870: NOT
4871: IFFALSE 4875
// break ;
4873: GO 5035
// veh := CreateVehicle ;
4875: LD_ADDR_VAR 0 3
4879: PUSH
4880: CALL_OW 45
4884: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4885: LD_VAR 0 3
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4897: LD_VAR 0 3
4901: PPUSH
4902: LD_INT 38
4904: PPUSH
4905: LD_INT 0
4907: PPUSH
4908: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4912: LD_EXP 17
4916: PUSH
4917: LD_INT 1
4919: ARRAY
4920: PPUSH
4921: LD_INT 3
4923: PPUSH
4924: CALL_OW 259
4928: PUSH
4929: LD_INT 4
4931: GREATER
4932: IFFALSE 4950
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4934: LD_EXP 17
4938: PUSH
4939: LD_INT 1
4941: ARRAY
4942: PPUSH
4943: LD_INT 3
4945: PPUSH
4946: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4950: LD_EXP 17
4954: PUSH
4955: LD_INT 1
4957: ARRAY
4958: PPUSH
4959: LD_INT 4
4961: PPUSH
4962: CALL_OW 259
4966: PUSH
4967: LD_INT 8
4969: GREATER
4970: IFFALSE 4988
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4972: LD_EXP 17
4976: PUSH
4977: LD_INT 1
4979: ARRAY
4980: PPUSH
4981: LD_INT 4
4983: PPUSH
4984: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4988: LD_EXP 17
4992: PUSH
4993: LD_INT 1
4995: ARRAY
4996: PPUSH
4997: LD_VAR 0 3
5001: PPUSH
5002: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
5006: LD_ADDR_EXP 17
5010: PUSH
5011: LD_EXP 17
5015: PPUSH
5016: LD_INT 1
5018: PPUSH
5019: CALL_OW 3
5023: ST_TO_ADDR
// ComHold ( veh ) ;
5024: LD_VAR 0 3
5028: PPUSH
5029: CALL_OW 140
// end ;
5033: GO 4738
5035: POP
5036: POP
// uc_side := 7 ;
5037: LD_ADDR_OWVAR 20
5041: PUSH
5042: LD_INT 7
5044: ST_TO_ADDR
// uc_nation := 1 ;
5045: LD_ADDR_OWVAR 21
5049: PUSH
5050: LD_INT 1
5052: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5053: LD_INT 5
5055: PPUSH
5056: LD_INT 3
5058: PPUSH
5059: LD_INT 3
5061: PPUSH
5062: LD_INT 11
5064: PPUSH
5065: LD_INT 100
5067: PPUSH
5068: CALL 59431 0 5
// veh := CreateVehicle ;
5072: LD_ADDR_VAR 0 3
5076: PUSH
5077: CALL_OW 45
5081: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5082: LD_VAR 0 3
5086: PPUSH
5087: LD_INT 4
5089: PPUSH
5090: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5094: LD_VAR 0 3
5098: PPUSH
5099: LD_INT 305
5101: PPUSH
5102: LD_INT 218
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 48
// ComHold ( veh ) ;
5112: LD_VAR 0 3
5116: PPUSH
5117: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5121: LD_INT 313
5123: PPUSH
5124: LD_INT 220
5126: PPUSH
5127: CALL_OW 86
// end ; end_of_file
5131: LD_VAR 0 1
5135: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5136: LD_INT 0
5138: PPUSH
5139: PPUSH
5140: PPUSH
5141: PPUSH
5142: PPUSH
5143: PPUSH
5144: PPUSH
5145: PPUSH
5146: PPUSH
5147: PPUSH
5148: PPUSH
// if Difficulty = 1 then
5149: LD_OWVAR 67
5153: PUSH
5154: LD_INT 1
5156: EQUAL
5157: IFFALSE 5195
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
5159: LD_ADDR_VAR 0 2
5163: PUSH
5164: LD_INT 95
5166: PUSH
5167: LD_INT 39
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: PUSH
5179: FOR_IN
5180: IFFALSE 5193
// RemoveUnit ( i ) ;
5182: LD_VAR 0 2
5186: PPUSH
5187: CALL_OW 64
5191: GO 5179
5193: POP
5194: POP
// InitHc ;
5195: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5199: LD_INT 387
5201: PPUSH
5202: LD_STRING sigma
5204: PPUSH
5205: CALL_OW 500
// uc_side := 1 ;
5209: LD_ADDR_OWVAR 20
5213: PUSH
5214: LD_INT 1
5216: ST_TO_ADDR
// uc_nation := 1 ;
5217: LD_ADDR_OWVAR 21
5221: PUSH
5222: LD_INT 1
5224: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5225: LD_ADDR_VAR 0 2
5229: PUSH
5230: LD_INT 22
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 21
5242: PUSH
5243: LD_INT 3
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL_OW 69
5258: PUSH
5259: FOR_IN
5260: IFFALSE 5276
// SetBLevel ( i , 10 ) ;
5262: LD_VAR 0 2
5266: PPUSH
5267: LD_INT 10
5269: PPUSH
5270: CALL_OW 241
5274: GO 5259
5276: POP
5277: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5278: LD_INT 387
5280: PPUSH
5281: CALL_OW 274
5285: PPUSH
5286: LD_INT 1
5288: PPUSH
5289: LD_INT 7500
5291: PPUSH
5292: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5296: LD_INT 387
5298: PPUSH
5299: CALL_OW 274
5303: PPUSH
5304: LD_INT 2
5306: PPUSH
5307: LD_INT 4000
5309: PPUSH
5310: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5314: LD_INT 387
5316: PPUSH
5317: CALL_OW 274
5321: PPUSH
5322: LD_INT 3
5324: PPUSH
5325: LD_INT 50
5327: PPUSH
5328: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5332: LD_INT 476
5334: PPUSH
5335: CALL_OW 274
5339: PPUSH
5340: LD_INT 1
5342: PPUSH
5343: LD_INT 5500
5345: PPUSH
5346: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5350: LD_INT 476
5352: PPUSH
5353: CALL_OW 274
5357: PPUSH
5358: LD_INT 2
5360: PPUSH
5361: LD_INT 4000
5363: PPUSH
5364: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5368: LD_INT 476
5370: PPUSH
5371: CALL_OW 274
5375: PPUSH
5376: LD_INT 3
5378: PPUSH
5379: LD_INT 10
5381: PPUSH
5382: CALL_OW 277
// if LoadVariable ( 12a_PowellKilled , false ) then
5386: LD_STRING 12a_PowellKilled
5388: PPUSH
5389: LD_INT 0
5391: PPUSH
5392: CALL_OW 30
5396: IFFALSE 5423
// begin PrepareHuman ( sex_male , class_soldier , 10 ) ;
5398: LD_INT 1
5400: PPUSH
5401: LD_INT 1
5403: PPUSH
5404: LD_INT 10
5406: PPUSH
5407: CALL_OW 380
// Powell := CreateHuman ;
5411: LD_ADDR_EXP 57
5415: PUSH
5416: CALL_OW 44
5420: ST_TO_ADDR
// end else
5421: GO 5436
// Powell := NewCharacter ( Powell ) ;
5423: LD_ADDR_EXP 57
5427: PUSH
5428: LD_STRING Powell
5430: PPUSH
5431: CALL_OW 25
5435: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5436: LD_EXP 57
5440: PPUSH
5441: LD_INT 387
5443: PPUSH
5444: CALL_OW 52
// tmp := [ ] ;
5448: LD_ADDR_VAR 0 7
5452: PUSH
5453: EMPTY
5454: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5455: LD_ADDR_EXP 23
5459: PUSH
5460: LD_STRING Lisa
5462: PPUSH
5463: LD_EXP 1
5467: NOT
5468: PPUSH
5469: LD_STRING 12p_
5471: PPUSH
5472: CALL 54411 0 3
5476: ST_TO_ADDR
// if Lisa then
5477: LD_EXP 23
5481: IFFALSE 5499
// tmp := tmp ^ Lisa ;
5483: LD_ADDR_VAR 0 7
5487: PUSH
5488: LD_VAR 0 7
5492: PUSH
5493: LD_EXP 23
5497: ADD
5498: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5499: LD_ADDR_EXP 24
5503: PUSH
5504: LD_STRING Donaldson
5506: PPUSH
5507: LD_EXP 1
5511: NOT
5512: PPUSH
5513: LD_STRING 12p_
5515: PPUSH
5516: CALL 54411 0 3
5520: ST_TO_ADDR
// if Donaldson then
5521: LD_EXP 24
5525: IFFALSE 5543
// tmp := tmp ^ Donaldson ;
5527: LD_ADDR_VAR 0 7
5531: PUSH
5532: LD_VAR 0 7
5536: PUSH
5537: LD_EXP 24
5541: ADD
5542: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5543: LD_ADDR_EXP 25
5547: PUSH
5548: LD_STRING Bobby
5550: PPUSH
5551: LD_EXP 1
5555: NOT
5556: PPUSH
5557: LD_STRING 12p_
5559: PPUSH
5560: CALL 54411 0 3
5564: ST_TO_ADDR
// if Bobby then
5565: LD_EXP 25
5569: IFFALSE 5587
// tmp := tmp ^ Bobby ;
5571: LD_ADDR_VAR 0 7
5575: PUSH
5576: LD_VAR 0 7
5580: PUSH
5581: LD_EXP 25
5585: ADD
5586: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5587: LD_ADDR_EXP 26
5591: PUSH
5592: LD_STRING Cyrus
5594: PPUSH
5595: LD_EXP 1
5599: NOT
5600: PPUSH
5601: LD_STRING 12p_
5603: PPUSH
5604: CALL 54411 0 3
5608: ST_TO_ADDR
// if Cyrus then
5609: LD_EXP 26
5613: IFFALSE 5631
// tmp := tmp ^ Cyrus ;
5615: LD_ADDR_VAR 0 7
5619: PUSH
5620: LD_VAR 0 7
5624: PUSH
5625: LD_EXP 26
5629: ADD
5630: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5631: LD_ADDR_EXP 28
5635: PUSH
5636: LD_STRING Brown
5638: PPUSH
5639: LD_EXP 1
5643: NOT
5644: PPUSH
5645: LD_STRING 12p_
5647: PPUSH
5648: CALL 54411 0 3
5652: ST_TO_ADDR
// if Brown then
5653: LD_EXP 28
5657: IFFALSE 5675
// tmp := tmp ^ Brown ;
5659: LD_ADDR_VAR 0 7
5663: PUSH
5664: LD_VAR 0 7
5668: PUSH
5669: LD_EXP 28
5673: ADD
5674: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5675: LD_ADDR_EXP 29
5679: PUSH
5680: LD_STRING Gladstone
5682: PPUSH
5683: LD_EXP 1
5687: NOT
5688: PPUSH
5689: LD_STRING 12p_
5691: PPUSH
5692: CALL 54411 0 3
5696: ST_TO_ADDR
// if Gladstone then
5697: LD_EXP 29
5701: IFFALSE 5719
// tmp := tmp ^ Gladstone ;
5703: LD_ADDR_VAR 0 7
5707: PUSH
5708: LD_VAR 0 7
5712: PUSH
5713: LD_EXP 29
5717: ADD
5718: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5719: LD_ADDR_EXP 30
5723: PUSH
5724: LD_STRING Houten
5726: PPUSH
5727: LD_EXP 1
5731: NOT
5732: PPUSH
5733: LD_STRING 12p_
5735: PPUSH
5736: CALL 54411 0 3
5740: ST_TO_ADDR
// if Houten then
5741: LD_EXP 30
5745: IFFALSE 5763
// tmp := tmp ^ Houten ;
5747: LD_ADDR_VAR 0 7
5751: PUSH
5752: LD_VAR 0 7
5756: PUSH
5757: LD_EXP 30
5761: ADD
5762: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5763: LD_ADDR_EXP 31
5767: PUSH
5768: LD_STRING Cornel
5770: PPUSH
5771: LD_EXP 1
5775: NOT
5776: PPUSH
5777: LD_STRING 12p_
5779: PPUSH
5780: CALL 54411 0 3
5784: ST_TO_ADDR
// if Cornel then
5785: LD_EXP 31
5789: IFFALSE 5807
// tmp := tmp ^ Cornel ;
5791: LD_ADDR_VAR 0 7
5795: PUSH
5796: LD_VAR 0 7
5800: PUSH
5801: LD_EXP 31
5805: ADD
5806: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5807: LD_ADDR_EXP 32
5811: PUSH
5812: LD_STRING Gary
5814: PPUSH
5815: LD_EXP 1
5819: NOT
5820: PPUSH
5821: LD_STRING 12p_
5823: PPUSH
5824: CALL 54411 0 3
5828: ST_TO_ADDR
// if Gary then
5829: LD_EXP 32
5833: IFFALSE 5851
// tmp := tmp ^ Gary ;
5835: LD_ADDR_VAR 0 7
5839: PUSH
5840: LD_VAR 0 7
5844: PUSH
5845: LD_EXP 32
5849: ADD
5850: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5851: LD_ADDR_EXP 34
5855: PUSH
5856: LD_STRING Kikuchi
5858: PPUSH
5859: LD_EXP 1
5863: NOT
5864: PPUSH
5865: LD_STRING 12p_
5867: PPUSH
5868: CALL 54411 0 3
5872: ST_TO_ADDR
// if Kikuchi then
5873: LD_EXP 34
5877: IFFALSE 5895
// tmp := tmp ^ Kikuchi ;
5879: LD_ADDR_VAR 0 7
5883: PUSH
5884: LD_VAR 0 7
5888: PUSH
5889: LD_EXP 34
5893: ADD
5894: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5895: LD_ADDR_VAR 0 7
5899: PUSH
5900: LD_VAR 0 7
5904: PUSH
5905: LD_STRING 12p_others
5907: PPUSH
5908: CALL_OW 31
5912: UNION
5913: ST_TO_ADDR
// InitHc_All ( ) ;
5914: CALL_OW 584
// if tmp < 36 then
5918: LD_VAR 0 7
5922: PUSH
5923: LD_INT 36
5925: LESS
5926: IFFALSE 5993
// for i = 1 to 36 - tmp do
5928: LD_ADDR_VAR 0 2
5932: PUSH
5933: DOUBLE
5934: LD_INT 1
5936: DEC
5937: ST_TO_ADDR
5938: LD_INT 36
5940: PUSH
5941: LD_VAR 0 7
5945: MINUS
5946: PUSH
5947: FOR_TO
5948: IFFALSE 5991
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5950: LD_INT 1
5952: PPUSH
5953: LD_VAR 0 2
5957: PUSH
5958: LD_INT 4
5960: MOD
5961: PUSH
5962: LD_INT 1
5964: PLUS
5965: PPUSH
5966: LD_INT 10
5968: PPUSH
5969: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5973: LD_ADDR_VAR 0 7
5977: PUSH
5978: LD_VAR 0 7
5982: PUSH
5983: CALL_OW 44
5987: ADD
5988: ST_TO_ADDR
// end ;
5989: GO 5947
5991: POP
5992: POP
// p := 0 ;
5993: LD_ADDR_VAR 0 6
5997: PUSH
5998: LD_INT 0
6000: ST_TO_ADDR
// for i in tmp do
6001: LD_ADDR_VAR 0 2
6005: PUSH
6006: LD_VAR 0 7
6010: PUSH
6011: FOR_IN
6012: IFFALSE 6064
// begin p := Inc ( p ) ;
6014: LD_ADDR_VAR 0 6
6018: PUSH
6019: LD_VAR 0 6
6023: PPUSH
6024: CALL 93974 0 1
6028: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
6029: LD_VAR 0 2
6033: PPUSH
6034: LD_INT 62
6036: PPUSH
6037: LD_INT 93
6039: PPUSH
6040: LD_INT 9
6042: PPUSH
6043: LD_INT 0
6045: PPUSH
6046: CALL_OW 50
// if p > 36 then
6050: LD_VAR 0 6
6054: PUSH
6055: LD_INT 36
6057: GREATER
6058: IFFALSE 6062
// break ;
6060: GO 6064
// end ;
6062: GO 6011
6064: POP
6065: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
6066: LD_ADDR_EXP 80
6070: PUSH
6071: LD_EXP 80
6075: PPUSH
6076: LD_INT 4
6078: PPUSH
6079: LD_INT 22
6081: PUSH
6082: LD_INT 1
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: PPUSH
6089: CALL_OW 69
6093: PUSH
6094: LD_EXP 57
6098: DIFF
6099: PPUSH
6100: CALL_OW 1
6104: ST_TO_ADDR
// uc_side := 0 ;
6105: LD_ADDR_OWVAR 20
6109: PUSH
6110: LD_INT 0
6112: ST_TO_ADDR
// uc_nation := 0 ;
6113: LD_ADDR_OWVAR 21
6117: PUSH
6118: LD_INT 0
6120: ST_TO_ADDR
// for i = 1 to 4 do
6121: LD_ADDR_VAR 0 2
6125: PUSH
6126: DOUBLE
6127: LD_INT 1
6129: DEC
6130: ST_TO_ADDR
6131: LD_INT 4
6133: PUSH
6134: FOR_TO
6135: IFFALSE 6166
// begin InitHc ;
6137: CALL_OW 19
// hc_class := class_apeman ;
6141: LD_ADDR_OWVAR 28
6145: PUSH
6146: LD_INT 12
6148: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6149: CALL_OW 44
6153: PPUSH
6154: LD_INT 11
6156: PPUSH
6157: LD_INT 0
6159: PPUSH
6160: CALL_OW 49
// end ;
6164: GO 6134
6166: POP
6167: POP
// end ;
6168: LD_VAR 0 1
6172: RET
// every 6 6$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6173: LD_EXP 4
6177: NOT
6178: IFFALSE 7107
6180: GO 6182
6182: DISABLE
6183: LD_INT 0
6185: PPUSH
6186: PPUSH
6187: PPUSH
6188: PPUSH
// begin enable ;
6189: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6190: LD_INT 22
6192: PUSH
6193: LD_INT 1
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: PUSH
6200: LD_INT 23
6202: PUSH
6203: LD_INT 1
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 30
6212: PUSH
6213: LD_INT 3
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: PPUSH
6225: CALL_OW 69
6229: NOT
6230: IFFALSE 6234
// exit ;
6232: GO 7107
// if Prob ( 40 ) then
6234: LD_INT 40
6236: PPUSH
6237: CALL_OW 13
6241: IFFALSE 6368
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6243: LD_INT 4
6245: PPUSH
6246: LD_INT 5
6248: PUSH
6249: LD_INT 1
6251: PUSH
6252: LD_INT 2
6254: PUSH
6255: LD_INT 7
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 5
6266: PUSH
6267: LD_INT 1
6269: PUSH
6270: LD_INT 2
6272: PUSH
6273: LD_INT 7
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: LIST
6280: LIST
6281: PUSH
6282: LD_INT 5
6284: PUSH
6285: LD_INT 1
6287: PUSH
6288: LD_INT 2
6290: PUSH
6291: LD_INT 7
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_INT 5
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: LD_INT 2
6308: PUSH
6309: LD_INT 6
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: LIST
6317: PUSH
6318: LD_INT 5
6320: PUSH
6321: LD_INT 1
6323: PUSH
6324: LD_INT 2
6326: PUSH
6327: LD_INT 6
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PUSH
6336: LD_INT 5
6338: PUSH
6339: LD_INT 1
6341: PUSH
6342: LD_INT 2
6344: PUSH
6345: LD_INT 6
6347: PUSH
6348: EMPTY
6349: LIST
6350: LIST
6351: LIST
6352: LIST
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: LIST
6360: LIST
6361: PPUSH
6362: CALL 47887 0 2
// end else
6366: GO 6491
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6368: LD_INT 4
6370: PPUSH
6371: LD_INT 5
6373: PUSH
6374: LD_INT 1
6376: PUSH
6377: LD_INT 2
6379: PUSH
6380: LD_INT 7
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: LIST
6387: LIST
6388: PUSH
6389: LD_INT 5
6391: PUSH
6392: LD_INT 1
6394: PUSH
6395: LD_INT 2
6397: PUSH
6398: LD_INT 9
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 5
6409: PUSH
6410: LD_INT 1
6412: PUSH
6413: LD_INT 2
6415: PUSH
6416: LD_INT 9
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: PUSH
6425: LD_INT 5
6427: PUSH
6428: LD_INT 1
6430: PUSH
6431: LD_INT 2
6433: PUSH
6434: LD_INT 6
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: LIST
6441: LIST
6442: PUSH
6443: LD_INT 5
6445: PUSH
6446: LD_INT 1
6448: PUSH
6449: LD_INT 2
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: LIST
6459: LIST
6460: PUSH
6461: LD_INT 5
6463: PUSH
6464: LD_INT 1
6466: PUSH
6467: LD_INT 2
6469: PUSH
6470: LD_INT 6
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: LIST
6477: LIST
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: PPUSH
6487: CALL 47887 0 2
// end ; p := 0 ;
6491: LD_ADDR_VAR 0 4
6495: PUSH
6496: LD_INT 0
6498: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6499: LD_INT 35
6501: PPUSH
6502: CALL_OW 67
// p := Inc ( p ) ;
6506: LD_ADDR_VAR 0 4
6510: PUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 93974 0 1
6520: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6521: LD_INT 4
6523: PPUSH
6524: LD_INT 1
6526: PPUSH
6527: CALL 49343 0 2
6531: PUSH
6532: LD_INT 6
6534: GREATEREQUAL
6535: IFTRUE 6547
6537: PUSH
6538: LD_VAR 0 4
6542: PUSH
6543: LD_INT 100
6545: GREATER
6546: OR
6547: IFFALSE 6499
// wait ( 0 0$30 ) ;
6549: LD_INT 1050
6551: PPUSH
6552: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_siberium_rocket ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , us_crane ] ] ] ) diff mc_defender [ 4 ] ;
6556: LD_ADDR_VAR 0 2
6560: PUSH
6561: LD_INT 22
6563: PUSH
6564: LD_INT 1
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: PUSH
6571: LD_INT 21
6573: PUSH
6574: LD_INT 2
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: LD_INT 3
6583: PUSH
6584: LD_INT 34
6586: PUSH
6587: LD_INT 8
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: PUSH
6598: LD_INT 3
6600: PUSH
6601: LD_INT 34
6603: PUSH
6604: LD_INT 12
6606: PUSH
6607: EMPTY
6608: LIST
6609: LIST
6610: PUSH
6611: EMPTY
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 3
6617: PUSH
6618: LD_INT 34
6620: PUSH
6621: LD_INT 13
6623: PUSH
6624: EMPTY
6625: LIST
6626: LIST
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: LIST
6636: LIST
6637: LIST
6638: PPUSH
6639: CALL_OW 69
6643: PUSH
6644: LD_EXP 102
6648: PUSH
6649: LD_INT 4
6651: ARRAY
6652: DIFF
6653: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6654: LD_ADDR_EXP 99
6658: PUSH
6659: LD_EXP 99
6663: PPUSH
6664: LD_INT 4
6666: PPUSH
6667: LD_EXP 99
6671: PUSH
6672: LD_INT 4
6674: ARRAY
6675: PUSH
6676: LD_VAR 0 2
6680: DIFF
6681: PPUSH
6682: CALL_OW 1
6686: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6687: LD_ADDR_VAR 0 3
6691: PUSH
6692: LD_INT 0
6694: PPUSH
6695: LD_INT 2
6697: PPUSH
6698: CALL_OW 12
6702: ST_TO_ADDR
// p := 0 ;
6703: LD_ADDR_VAR 0 4
6707: PUSH
6708: LD_INT 0
6710: ST_TO_ADDR
// if target then
6711: LD_VAR 0 3
6715: IFFALSE 6870
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6717: LD_ADDR_VAR 0 2
6721: PUSH
6722: LD_VAR 0 2
6726: PPUSH
6727: LD_INT 24
6729: PUSH
6730: LD_INT 250
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PPUSH
6737: CALL_OW 72
6741: ST_TO_ADDR
// for i in tmp do
6742: LD_ADDR_VAR 0 1
6746: PUSH
6747: LD_VAR 0 2
6751: PUSH
6752: FOR_IN
6753: IFFALSE 6793
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6755: LD_VAR 0 1
6759: PPUSH
6760: LD_INT 114
6762: PPUSH
6763: LD_INT 108
6765: PPUSH
6766: CALL_OW 297
6770: PUSH
6771: LD_INT 9
6773: GREATER
6774: IFFALSE 6791
// ComMoveXY ( i , 114 , 108 ) ;
6776: LD_VAR 0 1
6780: PPUSH
6781: LD_INT 114
6783: PPUSH
6784: LD_INT 108
6786: PPUSH
6787: CALL_OW 111
6791: GO 6752
6793: POP
6794: POP
// wait ( 0 0$1 ) ;
6795: LD_INT 35
6797: PPUSH
6798: CALL_OW 67
// p := Inc ( p ) ;
6802: LD_ADDR_VAR 0 4
6806: PUSH
6807: LD_VAR 0 4
6811: PPUSH
6812: CALL 93974 0 1
6816: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6817: LD_VAR 0 2
6821: PPUSH
6822: LD_INT 92
6824: PUSH
6825: LD_INT 114
6827: PUSH
6828: LD_INT 108
6830: PUSH
6831: LD_INT 9
6833: PUSH
6834: EMPTY
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PPUSH
6840: CALL_OW 72
6844: PUSH
6845: LD_VAR 0 2
6849: PUSH
6850: LD_INT 1
6852: MINUS
6853: GREATEREQUAL
6854: IFTRUE 6866
6856: PUSH
6857: LD_VAR 0 4
6861: PUSH
6862: LD_INT 30
6864: GREATER
6865: OR
6866: IFFALSE 6717
// end else
6868: GO 7021
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6870: LD_ADDR_VAR 0 2
6874: PUSH
6875: LD_VAR 0 2
6879: PPUSH
6880: LD_INT 24
6882: PUSH
6883: LD_INT 250
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: PPUSH
6890: CALL_OW 72
6894: ST_TO_ADDR
// for i in tmp do
6895: LD_ADDR_VAR 0 1
6899: PUSH
6900: LD_VAR 0 2
6904: PUSH
6905: FOR_IN
6906: IFFALSE 6946
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6908: LD_VAR 0 1
6912: PPUSH
6913: LD_INT 129
6915: PPUSH
6916: LD_INT 139
6918: PPUSH
6919: CALL_OW 297
6923: PUSH
6924: LD_INT 9
6926: GREATER
6927: IFFALSE 6944
// ComMoveXY ( i , 129 , 139 ) ;
6929: LD_VAR 0 1
6933: PPUSH
6934: LD_INT 129
6936: PPUSH
6937: LD_INT 139
6939: PPUSH
6940: CALL_OW 111
6944: GO 6905
6946: POP
6947: POP
// wait ( 0 0$1 ) ;
6948: LD_INT 35
6950: PPUSH
6951: CALL_OW 67
// p := Inc ( p ) ;
6955: LD_ADDR_VAR 0 4
6959: PUSH
6960: LD_VAR 0 4
6964: PPUSH
6965: CALL 93974 0 1
6969: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6970: LD_VAR 0 2
6974: PPUSH
6975: LD_INT 92
6977: PUSH
6978: LD_INT 129
6980: PUSH
6981: LD_INT 139
6983: PUSH
6984: LD_INT 9
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: LIST
6991: LIST
6992: PPUSH
6993: CALL_OW 72
6997: PUSH
6998: LD_VAR 0 2
7002: PUSH
7003: LD_INT 1
7005: MINUS
7006: GREATEREQUAL
7007: IFTRUE 7019
7009: PUSH
7010: LD_VAR 0 4
7014: PUSH
7015: LD_INT 30
7017: GREATER
7018: OR
7019: IFFALSE 6870
// end ; repeat wait ( 0 0$1 ) ;
7021: LD_INT 35
7023: PPUSH
7024: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
7028: LD_ADDR_VAR 0 2
7032: PUSH
7033: LD_VAR 0 2
7037: PPUSH
7038: LD_INT 50
7040: PUSH
7041: EMPTY
7042: LIST
7043: PPUSH
7044: CALL_OW 72
7048: ST_TO_ADDR
// for i in tmp do
7049: LD_ADDR_VAR 0 1
7053: PUSH
7054: LD_VAR 0 2
7058: PUSH
7059: FOR_IN
7060: IFFALSE 7098
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
7062: LD_VAR 0 1
7066: PPUSH
7067: LD_INT 81
7069: PUSH
7070: LD_INT 1
7072: PUSH
7073: EMPTY
7074: LIST
7075: LIST
7076: PPUSH
7077: CALL_OW 69
7081: PPUSH
7082: LD_VAR 0 1
7086: PPUSH
7087: CALL_OW 74
7091: PPUSH
7092: CALL_OW 115
7096: GO 7059
7098: POP
7099: POP
// until not tmp ;
7100: LD_VAR 0 2
7104: NOT
7105: IFFALSE 7021
// end ;
7107: PPOPN 4
7109: END
// every 30 30$00 trigger not americanDestroyed do
7110: LD_EXP 4
7114: NOT
7115: IFFALSE 7184
7117: GO 7119
7119: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
7120: LD_INT 63000
7122: PUSH
7123: LD_INT 42000
7125: PUSH
7126: LD_INT 31500
7128: PUSH
7129: LD_INT 21000
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: ARRAY
7143: PPUSH
7144: CALL_OW 67
// if americanDestroyed then
7148: LD_EXP 4
7152: IFFALSE 7156
// exit ;
7154: GO 7184
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
7156: LD_INT 4
7158: PPUSH
7159: LD_INT 5
7161: PUSH
7162: LD_INT 3
7164: PUSH
7165: LD_INT 1
7167: PUSH
7168: LD_INT 8
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: LIST
7175: LIST
7176: PUSH
7177: EMPTY
7178: LIST
7179: PPUSH
7180: CALL 47887 0 2
// end ; end_of_file
7184: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
7185: LD_INT 0
7187: PPUSH
7188: PPUSH
7189: PPUSH
7190: PPUSH
7191: PPUSH
// side := 2 ;
7192: LD_ADDR_VAR 0 5
7196: PUSH
7197: LD_INT 2
7199: ST_TO_ADDR
// InitHc ;
7200: CALL_OW 19
// uc_side := side ;
7204: LD_ADDR_OWVAR 20
7208: PUSH
7209: LD_VAR 0 5
7213: ST_TO_ADDR
// uc_nation := 2 ;
7214: LD_ADDR_OWVAR 21
7218: PUSH
7219: LD_INT 2
7221: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
7222: LD_ADDR_VAR 0 2
7226: PUSH
7227: LD_INT 22
7229: PUSH
7230: LD_INT 2
7232: PUSH
7233: EMPTY
7234: LIST
7235: LIST
7236: PUSH
7237: LD_INT 21
7239: PUSH
7240: LD_INT 3
7242: PUSH
7243: EMPTY
7244: LIST
7245: LIST
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PPUSH
7251: CALL_OW 69
7255: PUSH
7256: FOR_IN
7257: IFFALSE 7273
// SetBLevel ( i , 10 ) ;
7259: LD_VAR 0 2
7263: PPUSH
7264: LD_INT 10
7266: PPUSH
7267: CALL_OW 241
7271: GO 7256
7273: POP
7274: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7275: LD_ADDR_VAR 0 4
7279: PUSH
7280: LD_INT 22
7282: PUSH
7283: LD_VAR 0 5
7287: PUSH
7288: EMPTY
7289: LIST
7290: LIST
7291: PUSH
7292: LD_INT 30
7294: PUSH
7295: LD_INT 32
7297: PUSH
7298: EMPTY
7299: LIST
7300: LIST
7301: PUSH
7302: LD_INT 58
7304: PUSH
7305: EMPTY
7306: LIST
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: PPUSH
7313: CALL_OW 69
7317: ST_TO_ADDR
// for i = 1 to 10 do
7318: LD_ADDR_VAR 0 2
7322: PUSH
7323: DOUBLE
7324: LD_INT 1
7326: DEC
7327: ST_TO_ADDR
7328: LD_INT 10
7330: PUSH
7331: FOR_TO
7332: IFFALSE 7404
// begin uc_nation := nation_nature ;
7334: LD_ADDR_OWVAR 21
7338: PUSH
7339: LD_INT 0
7341: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7342: LD_ADDR_OWVAR 28
7346: PUSH
7347: LD_INT 15
7349: ST_TO_ADDR
// hc_gallery :=  ;
7350: LD_ADDR_OWVAR 33
7354: PUSH
7355: LD_STRING 
7357: ST_TO_ADDR
// hc_name :=  ;
7358: LD_ADDR_OWVAR 26
7362: PUSH
7363: LD_STRING 
7365: ST_TO_ADDR
// un := CreateHuman ;
7366: LD_ADDR_VAR 0 3
7370: PUSH
7371: CALL_OW 44
7375: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7376: LD_VAR 0 3
7380: PPUSH
7381: LD_VAR 0 4
7385: PUSH
7386: LD_VAR 0 4
7390: PUSH
7391: LD_VAR 0 2
7395: MINUS
7396: ARRAY
7397: PPUSH
7398: CALL_OW 52
// end ;
7402: GO 7331
7404: POP
7405: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7406: LD_INT 503
7408: PPUSH
7409: LD_INT 27
7411: PPUSH
7412: LD_STRING 
7414: PPUSH
7415: LD_INT 8
7417: PUSH
7418: LD_INT 9
7420: PUSH
7421: LD_INT 10
7423: PUSH
7424: LD_INT 10
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: LIST
7432: PUSH
7433: LD_OWVAR 67
7437: ARRAY
7438: PPUSH
7439: LD_INT 3000
7441: PUSH
7442: LD_INT 500
7444: PUSH
7445: LD_INT 150
7447: PUSH
7448: EMPTY
7449: LIST
7450: LIST
7451: LIST
7452: PPUSH
7453: LD_INT 16
7455: PUSH
7456: LD_INT 6
7458: PUSH
7459: LD_INT 6
7461: PUSH
7462: LD_INT 6
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: PPUSH
7471: CALL 63268 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7475: LD_ADDR_EXP 80
7479: PUSH
7480: LD_EXP 80
7484: PPUSH
7485: LD_INT 1
7487: PPUSH
7488: LD_INT 22
7490: PUSH
7491: LD_VAR 0 5
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: PUSH
7500: LD_INT 23
7502: PUSH
7503: LD_INT 2
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: PUSH
7510: LD_INT 3
7512: PUSH
7513: LD_INT 21
7515: PUSH
7516: LD_INT 2
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: PUSH
7527: EMPTY
7528: LIST
7529: LIST
7530: LIST
7531: PPUSH
7532: CALL_OW 69
7536: PPUSH
7537: CALL_OW 1
7541: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7542: LD_INT 216
7544: PPUSH
7545: LD_INT 228
7547: PPUSH
7548: LD_INT 2
7550: PPUSH
7551: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7555: LD_INT 223
7557: PPUSH
7558: LD_INT 241
7560: PPUSH
7561: LD_INT 2
7563: PPUSH
7564: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7568: LD_INT 216
7570: PPUSH
7571: LD_INT 217
7573: PPUSH
7574: LD_INT 2
7576: PPUSH
7577: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7581: LD_INT 233
7583: PPUSH
7584: LD_INT 257
7586: PPUSH
7587: LD_INT 2
7589: PPUSH
7590: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7594: LD_INT 230
7596: PPUSH
7597: LD_INT 199
7599: PPUSH
7600: LD_INT 2
7602: PPUSH
7603: CALL_OW 244
// end ;
7607: LD_VAR 0 1
7611: RET
// export Omar ; export function PrepareOmarAli ; begin
7612: LD_INT 0
7614: PPUSH
// uc_side := 5 ;
7615: LD_ADDR_OWVAR 20
7619: PUSH
7620: LD_INT 5
7622: ST_TO_ADDR
// uc_nation := 2 ;
7623: LD_ADDR_OWVAR 21
7627: PUSH
7628: LD_INT 2
7630: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7631: LD_ADDR_EXP 58
7635: PUSH
7636: LD_STRING Omar
7638: PPUSH
7639: CALL_OW 25
7643: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7644: LD_EXP 58
7648: PPUSH
7649: LD_INT 330
7651: PPUSH
7652: LD_INT 244
7654: PPUSH
7655: LD_INT 0
7657: PPUSH
7658: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7662: LD_EXP 58
7666: PPUSH
7667: LD_INT 252
7669: PPUSH
7670: LD_INT 220
7672: PPUSH
7673: CALL_OW 111
// end ;
7677: LD_VAR 0 1
7681: RET
// export function PrepareOmarAli2 ; begin
7682: LD_INT 0
7684: PPUSH
// uc_side := 5 ;
7685: LD_ADDR_OWVAR 20
7689: PUSH
7690: LD_INT 5
7692: ST_TO_ADDR
// uc_nation := 2 ;
7693: LD_ADDR_OWVAR 21
7697: PUSH
7698: LD_INT 2
7700: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7701: LD_ADDR_EXP 58
7705: PUSH
7706: LD_STRING Omar
7708: PPUSH
7709: CALL_OW 25
7713: ST_TO_ADDR
// PlaceUnitXY ( Omar , 289 , 164 , false ) ;
7714: LD_EXP 58
7718: PPUSH
7719: LD_INT 289
7721: PPUSH
7722: LD_INT 164
7724: PPUSH
7725: LD_INT 0
7727: PPUSH
7728: CALL_OW 48
// ComMoveXY ( Omar , 254 , 166 ) ;
7732: LD_EXP 58
7736: PPUSH
7737: LD_INT 254
7739: PPUSH
7740: LD_INT 166
7742: PPUSH
7743: CALL_OW 111
// end ; end_of_file
7747: LD_VAR 0 1
7751: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7752: LD_INT 0
7754: PPUSH
7755: PPUSH
7756: PPUSH
7757: PPUSH
7758: PPUSH
// side := 8 ;
7759: LD_ADDR_VAR 0 3
7763: PUSH
7764: LD_INT 8
7766: ST_TO_ADDR
// InitHc ;
7767: CALL_OW 19
// uc_side := side ;
7771: LD_ADDR_OWVAR 20
7775: PUSH
7776: LD_VAR 0 3
7780: ST_TO_ADDR
// uc_nation := 2 ;
7781: LD_ADDR_OWVAR 21
7785: PUSH
7786: LD_INT 2
7788: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7789: LD_ADDR_VAR 0 2
7793: PUSH
7794: LD_INT 22
7796: PUSH
7797: LD_VAR 0 3
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PUSH
7806: LD_INT 21
7808: PUSH
7809: LD_INT 3
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PPUSH
7820: CALL_OW 69
7824: PUSH
7825: FOR_IN
7826: IFFALSE 7842
// SetBLevel ( i , 10 ) ;
7828: LD_VAR 0 2
7832: PPUSH
7833: LD_INT 10
7835: PPUSH
7836: CALL_OW 241
7840: GO 7825
7842: POP
7843: POP
// Schulz := NewCharacter ( Schulz ) ;
7844: LD_ADDR_EXP 59
7848: PUSH
7849: LD_STRING Schulz
7851: PPUSH
7852: CALL_OW 25
7856: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7857: LD_ADDR_EXP 61
7861: PUSH
7862: LD_STRING Kaia
7864: PPUSH
7865: CALL_OW 25
7869: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7870: LD_EXP 61
7874: PPUSH
7875: LD_INT 324
7877: PPUSH
7878: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7882: LD_ADDR_EXP 60
7886: PUSH
7887: LD_STRING Kozlov
7889: PPUSH
7890: LD_INT 0
7892: PPUSH
7893: LD_STRING 
7895: PPUSH
7896: CALL 54411 0 3
7900: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7901: LD_EXP 60
7905: PPUSH
7906: LD_INT 22
7908: PUSH
7909: LD_INT 8
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PUSH
7916: LD_INT 23
7918: PUSH
7919: LD_INT 3
7921: PUSH
7922: EMPTY
7923: LIST
7924: LIST
7925: PUSH
7926: LD_INT 30
7928: PUSH
7929: LD_INT 8
7931: PUSH
7932: EMPTY
7933: LIST
7934: LIST
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: PPUSH
7941: CALL_OW 69
7945: PUSH
7946: LD_INT 1
7948: ARRAY
7949: PPUSH
7950: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7954: LD_EXP 60
7958: PPUSH
7959: LD_INT 3
7961: PPUSH
7962: LD_INT 10
7964: PPUSH
7965: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7969: LD_ADDR_VAR 0 5
7973: PUSH
7974: LD_INT 22
7976: PUSH
7977: LD_VAR 0 3
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: PUSH
7986: LD_INT 30
7988: PUSH
7989: LD_INT 32
7991: PUSH
7992: EMPTY
7993: LIST
7994: LIST
7995: PUSH
7996: LD_INT 58
7998: PUSH
7999: EMPTY
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: LIST
8006: PPUSH
8007: CALL_OW 69
8011: ST_TO_ADDR
// for i = 1 to 10 do
8012: LD_ADDR_VAR 0 2
8016: PUSH
8017: DOUBLE
8018: LD_INT 1
8020: DEC
8021: ST_TO_ADDR
8022: LD_INT 10
8024: PUSH
8025: FOR_TO
8026: IFFALSE 8098
// begin uc_nation := nation_nature ;
8028: LD_ADDR_OWVAR 21
8032: PUSH
8033: LD_INT 0
8035: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
8036: LD_ADDR_OWVAR 28
8040: PUSH
8041: LD_INT 15
8043: ST_TO_ADDR
// hc_gallery :=  ;
8044: LD_ADDR_OWVAR 33
8048: PUSH
8049: LD_STRING 
8051: ST_TO_ADDR
// hc_name :=  ;
8052: LD_ADDR_OWVAR 26
8056: PUSH
8057: LD_STRING 
8059: ST_TO_ADDR
// un := CreateHuman ;
8060: LD_ADDR_VAR 0 4
8064: PUSH
8065: CALL_OW 44
8069: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
8070: LD_VAR 0 4
8074: PPUSH
8075: LD_VAR 0 5
8079: PUSH
8080: LD_VAR 0 5
8084: PUSH
8085: LD_VAR 0 2
8089: MINUS
8090: ARRAY
8091: PPUSH
8092: CALL_OW 52
// end ;
8096: GO 8025
8098: POP
8099: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
8100: LD_INT 324
8102: PPUSH
8103: LD_INT 3
8105: PPUSH
8106: LD_STRING 
8108: PPUSH
8109: LD_INT 8
8111: PUSH
8112: LD_INT 9
8114: PUSH
8115: LD_INT 10
8117: PUSH
8118: LD_INT 10
8120: PUSH
8121: EMPTY
8122: LIST
8123: LIST
8124: LIST
8125: LIST
8126: PUSH
8127: LD_OWVAR 67
8131: ARRAY
8132: PPUSH
8133: LD_INT 3000
8135: PUSH
8136: LD_INT 500
8138: PUSH
8139: LD_INT 150
8141: PUSH
8142: EMPTY
8143: LIST
8144: LIST
8145: LIST
8146: PPUSH
8147: LD_INT 16
8149: PUSH
8150: LD_INT 6
8152: PUSH
8153: LD_INT 6
8155: PUSH
8156: LD_INT 8
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: LIST
8163: LIST
8164: PPUSH
8165: CALL 63268 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
8169: LD_ADDR_EXP 80
8173: PUSH
8174: LD_EXP 80
8178: PPUSH
8179: LD_INT 3
8181: PPUSH
8182: LD_INT 22
8184: PUSH
8185: LD_VAR 0 3
8189: PUSH
8190: EMPTY
8191: LIST
8192: LIST
8193: PUSH
8194: LD_INT 23
8196: PUSH
8197: LD_INT 2
8199: PUSH
8200: EMPTY
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 3
8206: PUSH
8207: LD_INT 21
8209: PUSH
8210: LD_INT 2
8212: PUSH
8213: EMPTY
8214: LIST
8215: LIST
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: LIST
8225: PPUSH
8226: CALL_OW 69
8230: PUSH
8231: LD_EXP 59
8235: DIFF
8236: PPUSH
8237: CALL_OW 1
8241: ST_TO_ADDR
// end ;
8242: LD_VAR 0 1
8246: RET
// export function BuildKozlovBomb ; begin
8247: LD_INT 0
8249: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
8250: LD_INT 332
8252: PPUSH
8253: CALL_OW 302
8257: NOT
8258: IFTRUE 8270
8260: PUSH
8261: LD_INT 336
8263: PPUSH
8264: CALL_OW 302
8268: NOT
8269: OR
8270: IFFALSE 8274
// exit ;
8272: GO 8371
// ComChangeProfession ( Kozlov , 4 ) ;
8274: LD_EXP 60
8278: PPUSH
8279: LD_INT 4
8281: PPUSH
8282: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
8286: LD_INT 336
8288: PPUSH
8289: LD_INT 25
8291: PPUSH
8292: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
8296: LD_INT 35
8298: PPUSH
8299: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
8303: LD_INT 25
8305: PPUSH
8306: LD_INT 8
8308: PPUSH
8309: CALL_OW 321
8313: PUSH
8314: LD_INT 2
8316: EQUAL
8317: IFFALSE 8296
// ComExitBuilding ( Kozlov ) ;
8319: LD_EXP 60
8323: PPUSH
8324: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8328: LD_EXP 60
8332: PPUSH
8333: LD_INT 332
8335: PPUSH
8336: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8340: LD_EXP 60
8344: PPUSH
8345: LD_INT 3
8347: PPUSH
8348: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8352: LD_INT 332
8354: PPUSH
8355: LD_INT 23
8357: PPUSH
8358: LD_INT 3
8360: PPUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 48
8366: PPUSH
8367: CALL_OW 125
// end ;
8371: LD_VAR 0 1
8375: RET
// every 5 5$30 + 4 4$00 trigger not legionDestroyed do var i , tmp , target , p ;
8376: LD_EXP 3
8380: NOT
8381: IFFALSE 9394
8383: GO 8385
8385: DISABLE
8386: LD_INT 0
8388: PPUSH
8389: PPUSH
8390: PPUSH
8391: PPUSH
// begin enable ;
8392: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8393: LD_INT 22
8395: PUSH
8396: LD_INT 8
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: PUSH
8403: LD_INT 23
8405: PUSH
8406: LD_INT 2
8408: PUSH
8409: EMPTY
8410: LIST
8411: LIST
8412: PUSH
8413: LD_INT 30
8415: PUSH
8416: LD_INT 3
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: LIST
8427: PPUSH
8428: CALL_OW 69
8432: NOT
8433: IFFALSE 8437
// exit ;
8435: GO 9394
// if Prob ( 40 ) then
8437: LD_INT 40
8439: PPUSH
8440: CALL_OW 13
8444: IFFALSE 8571
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8446: LD_INT 3
8448: PPUSH
8449: LD_INT 14
8451: PUSH
8452: LD_INT 1
8454: PUSH
8455: LD_INT 2
8457: PUSH
8458: LD_INT 28
8460: PUSH
8461: EMPTY
8462: LIST
8463: LIST
8464: LIST
8465: LIST
8466: PUSH
8467: LD_INT 14
8469: PUSH
8470: LD_INT 1
8472: PUSH
8473: LD_INT 2
8475: PUSH
8476: LD_INT 28
8478: PUSH
8479: EMPTY
8480: LIST
8481: LIST
8482: LIST
8483: LIST
8484: PUSH
8485: LD_INT 14
8487: PUSH
8488: LD_INT 1
8490: PUSH
8491: LD_INT 2
8493: PUSH
8494: LD_INT 28
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: LIST
8501: LIST
8502: PUSH
8503: LD_INT 14
8505: PUSH
8506: LD_INT 1
8508: PUSH
8509: LD_INT 2
8511: PUSH
8512: LD_INT 28
8514: PUSH
8515: EMPTY
8516: LIST
8517: LIST
8518: LIST
8519: LIST
8520: PUSH
8521: LD_INT 14
8523: PUSH
8524: LD_INT 1
8526: PUSH
8527: LD_INT 2
8529: PUSH
8530: LD_INT 28
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_INT 14
8541: PUSH
8542: LD_INT 1
8544: PUSH
8545: LD_INT 2
8547: PUSH
8548: LD_INT 26
8550: PUSH
8551: EMPTY
8552: LIST
8553: LIST
8554: LIST
8555: LIST
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: LIST
8564: PPUSH
8565: CALL 47887 0 2
// end else
8569: GO 8778
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8571: LD_INT 3
8573: PPUSH
8574: LD_INT 14
8576: PUSH
8577: LD_INT 1
8579: PUSH
8580: LD_INT 2
8582: PUSH
8583: LD_INT 27
8585: PUSH
8586: LD_INT 26
8588: PUSH
8589: LD_INT 26
8591: PUSH
8592: LD_INT 28
8594: PUSH
8595: EMPTY
8596: LIST
8597: LIST
8598: LIST
8599: LIST
8600: PUSH
8601: LD_OWVAR 67
8605: ARRAY
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: LIST
8611: LIST
8612: PUSH
8613: LD_INT 14
8615: PUSH
8616: LD_INT 1
8618: PUSH
8619: LD_INT 2
8621: PUSH
8622: LD_INT 27
8624: PUSH
8625: LD_INT 26
8627: PUSH
8628: LD_INT 26
8630: PUSH
8631: LD_INT 26
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: LIST
8638: LIST
8639: PUSH
8640: LD_OWVAR 67
8644: ARRAY
8645: PUSH
8646: EMPTY
8647: LIST
8648: LIST
8649: LIST
8650: LIST
8651: PUSH
8652: LD_INT 14
8654: PUSH
8655: LD_INT 1
8657: PUSH
8658: LD_INT 2
8660: PUSH
8661: LD_INT 26
8663: PUSH
8664: LD_INT 26
8666: PUSH
8667: LD_INT 29
8669: PUSH
8670: LD_INT 29
8672: PUSH
8673: EMPTY
8674: LIST
8675: LIST
8676: LIST
8677: LIST
8678: PUSH
8679: LD_OWVAR 67
8683: ARRAY
8684: PUSH
8685: EMPTY
8686: LIST
8687: LIST
8688: LIST
8689: LIST
8690: PUSH
8691: LD_INT 13
8693: PUSH
8694: LD_INT 1
8696: PUSH
8697: LD_INT 2
8699: PUSH
8700: LD_INT 26
8702: PUSH
8703: LD_INT 29
8705: PUSH
8706: LD_INT 29
8708: PUSH
8709: LD_INT 29
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: PUSH
8718: LD_OWVAR 67
8722: ARRAY
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: LIST
8728: LIST
8729: PUSH
8730: LD_INT 13
8732: PUSH
8733: LD_INT 1
8735: PUSH
8736: LD_INT 2
8738: PUSH
8739: LD_INT 29
8741: PUSH
8742: EMPTY
8743: LIST
8744: LIST
8745: LIST
8746: LIST
8747: PUSH
8748: LD_INT 14
8750: PUSH
8751: LD_INT 1
8753: PUSH
8754: LD_INT 2
8756: PUSH
8757: LD_INT 26
8759: PUSH
8760: EMPTY
8761: LIST
8762: LIST
8763: LIST
8764: LIST
8765: PUSH
8766: EMPTY
8767: LIST
8768: LIST
8769: LIST
8770: LIST
8771: LIST
8772: LIST
8773: PPUSH
8774: CALL 47887 0 2
// end ; p := 0 ;
8778: LD_ADDR_VAR 0 4
8782: PUSH
8783: LD_INT 0
8785: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8786: LD_INT 35
8788: PPUSH
8789: CALL_OW 67
// p := Inc ( p ) ;
8793: LD_ADDR_VAR 0 4
8797: PUSH
8798: LD_VAR 0 4
8802: PPUSH
8803: CALL 93974 0 1
8807: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8808: LD_INT 3
8810: PPUSH
8811: LD_INT 1
8813: PPUSH
8814: CALL 49343 0 2
8818: PUSH
8819: LD_INT 6
8821: GREATEREQUAL
8822: IFTRUE 8834
8824: PUSH
8825: LD_VAR 0 4
8829: PUSH
8830: LD_INT 100
8832: GREATER
8833: OR
8834: IFFALSE 8786
// wait ( 0 0$30 ) ;
8836: LD_INT 1050
8838: PPUSH
8839: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
8843: LD_ADDR_VAR 0 2
8847: PUSH
8848: LD_INT 22
8850: PUSH
8851: LD_INT 8
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 21
8860: PUSH
8861: LD_INT 2
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: LD_INT 3
8870: PUSH
8871: LD_INT 34
8873: PUSH
8874: LD_INT 31
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: PUSH
8885: LD_INT 3
8887: PUSH
8888: LD_INT 34
8890: PUSH
8891: LD_INT 32
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: PUSH
8902: LD_INT 3
8904: PUSH
8905: LD_INT 34
8907: PUSH
8908: LD_INT 88
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: LIST
8925: PPUSH
8926: CALL_OW 69
8930: PUSH
8931: LD_EXP 102
8935: PUSH
8936: LD_INT 3
8938: ARRAY
8939: DIFF
8940: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8941: LD_ADDR_EXP 99
8945: PUSH
8946: LD_EXP 99
8950: PPUSH
8951: LD_INT 3
8953: PPUSH
8954: LD_EXP 99
8958: PUSH
8959: LD_INT 3
8961: ARRAY
8962: PUSH
8963: LD_VAR 0 2
8967: DIFF
8968: PPUSH
8969: CALL_OW 1
8973: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8974: LD_ADDR_VAR 0 3
8978: PUSH
8979: LD_INT 0
8981: PPUSH
8982: LD_INT 2
8984: PPUSH
8985: CALL_OW 12
8989: ST_TO_ADDR
// p := 0 ;
8990: LD_ADDR_VAR 0 4
8994: PUSH
8995: LD_INT 0
8997: ST_TO_ADDR
// if target then
8998: LD_VAR 0 3
9002: IFFALSE 9157
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9004: LD_ADDR_VAR 0 2
9008: PUSH
9009: LD_VAR 0 2
9013: PPUSH
9014: LD_INT 24
9016: PUSH
9017: LD_INT 250
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PPUSH
9024: CALL_OW 72
9028: ST_TO_ADDR
// for i in tmp do
9029: LD_ADDR_VAR 0 1
9033: PUSH
9034: LD_VAR 0 2
9038: PUSH
9039: FOR_IN
9040: IFFALSE 9080
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
9042: LD_VAR 0 1
9046: PPUSH
9047: LD_INT 89
9049: PPUSH
9050: LD_INT 71
9052: PPUSH
9053: CALL_OW 297
9057: PUSH
9058: LD_INT 9
9060: GREATER
9061: IFFALSE 9078
// ComMoveXY ( i , 89 , 71 ) ;
9063: LD_VAR 0 1
9067: PPUSH
9068: LD_INT 89
9070: PPUSH
9071: LD_INT 71
9073: PPUSH
9074: CALL_OW 111
9078: GO 9039
9080: POP
9081: POP
// wait ( 0 0$1 ) ;
9082: LD_INT 35
9084: PPUSH
9085: CALL_OW 67
// p := Inc ( p ) ;
9089: LD_ADDR_VAR 0 4
9093: PUSH
9094: LD_VAR 0 4
9098: PPUSH
9099: CALL 93974 0 1
9103: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9104: LD_VAR 0 2
9108: PPUSH
9109: LD_INT 92
9111: PUSH
9112: LD_INT 89
9114: PUSH
9115: LD_INT 71
9117: PUSH
9118: LD_INT 9
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: LIST
9125: LIST
9126: PPUSH
9127: CALL_OW 72
9131: PUSH
9132: LD_VAR 0 2
9136: PUSH
9137: LD_INT 1
9139: MINUS
9140: GREATEREQUAL
9141: IFTRUE 9153
9143: PUSH
9144: LD_VAR 0 4
9148: PUSH
9149: LD_INT 30
9151: GREATER
9152: OR
9153: IFFALSE 9004
// end else
9155: GO 9308
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9157: LD_ADDR_VAR 0 2
9161: PUSH
9162: LD_VAR 0 2
9166: PPUSH
9167: LD_INT 24
9169: PUSH
9170: LD_INT 250
9172: PUSH
9173: EMPTY
9174: LIST
9175: LIST
9176: PPUSH
9177: CALL_OW 72
9181: ST_TO_ADDR
// for i in tmp do
9182: LD_ADDR_VAR 0 1
9186: PUSH
9187: LD_VAR 0 2
9191: PUSH
9192: FOR_IN
9193: IFFALSE 9233
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
9195: LD_VAR 0 1
9199: PPUSH
9200: LD_INT 147
9202: PPUSH
9203: LD_INT 4
9205: PPUSH
9206: CALL_OW 297
9210: PUSH
9211: LD_INT 9
9213: GREATER
9214: IFFALSE 9231
// ComMoveXY ( i , 147 , 4 ) ;
9216: LD_VAR 0 1
9220: PPUSH
9221: LD_INT 147
9223: PPUSH
9224: LD_INT 4
9226: PPUSH
9227: CALL_OW 111
9231: GO 9192
9233: POP
9234: POP
// wait ( 0 0$1 ) ;
9235: LD_INT 35
9237: PPUSH
9238: CALL_OW 67
// p := Inc ( p ) ;
9242: LD_ADDR_VAR 0 4
9246: PUSH
9247: LD_VAR 0 4
9251: PPUSH
9252: CALL 93974 0 1
9256: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9257: LD_VAR 0 2
9261: PPUSH
9262: LD_INT 92
9264: PUSH
9265: LD_INT 147
9267: PUSH
9268: LD_INT 4
9270: PUSH
9271: LD_INT 9
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: LIST
9278: LIST
9279: PPUSH
9280: CALL_OW 72
9284: PUSH
9285: LD_VAR 0 2
9289: PUSH
9290: LD_INT 1
9292: MINUS
9293: GREATEREQUAL
9294: IFTRUE 9306
9296: PUSH
9297: LD_VAR 0 4
9301: PUSH
9302: LD_INT 30
9304: GREATER
9305: OR
9306: IFFALSE 9157
// end ; repeat wait ( 0 0$1 ) ;
9308: LD_INT 35
9310: PPUSH
9311: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
9315: LD_ADDR_VAR 0 2
9319: PUSH
9320: LD_VAR 0 2
9324: PPUSH
9325: LD_INT 50
9327: PUSH
9328: EMPTY
9329: LIST
9330: PPUSH
9331: CALL_OW 72
9335: ST_TO_ADDR
// for i in tmp do
9336: LD_ADDR_VAR 0 1
9340: PUSH
9341: LD_VAR 0 2
9345: PUSH
9346: FOR_IN
9347: IFFALSE 9385
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
9349: LD_VAR 0 1
9353: PPUSH
9354: LD_INT 81
9356: PUSH
9357: LD_INT 8
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: PPUSH
9364: CALL_OW 69
9368: PPUSH
9369: LD_VAR 0 1
9373: PPUSH
9374: CALL_OW 74
9378: PPUSH
9379: CALL_OW 115
9383: GO 9346
9385: POP
9386: POP
// until not tmp ;
9387: LD_VAR 0 2
9391: NOT
9392: IFFALSE 9308
// end ;
9394: PPOPN 4
9396: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
9397: LD_EXP 60
9401: PPUSH
9402: CALL_OW 302
9406: IFFALSE 9415
9408: PUSH
9409: LD_EXP 3
9413: NOT
9414: AND
9415: IFFALSE 9424
9417: GO 9419
9419: DISABLE
// BuildKozlovBomb ;
9420: CALL 8247 0 0
9424: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
9425: LD_INT 22
9427: PUSH
9428: LD_INT 8
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: PUSH
9435: LD_INT 34
9437: PUSH
9438: LD_INT 48
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: PPUSH
9449: CALL_OW 69
9453: IFFALSE 9501
9455: GO 9457
9457: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9458: LD_INT 22
9460: PUSH
9461: LD_INT 8
9463: PUSH
9464: EMPTY
9465: LIST
9466: LIST
9467: PUSH
9468: LD_INT 34
9470: PUSH
9471: LD_INT 48
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: PUSH
9478: EMPTY
9479: LIST
9480: LIST
9481: PPUSH
9482: CALL_OW 69
9486: PUSH
9487: LD_INT 1
9489: ARRAY
9490: PPUSH
9491: LD_INT 173
9493: PPUSH
9494: LD_INT 96
9496: PPUSH
9497: CALL_OW 116
// end ; end_of_file
9501: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9502: LD_INT 0
9504: PPUSH
9505: PPUSH
9506: PPUSH
9507: PPUSH
9508: PPUSH
9509: PPUSH
9510: PPUSH
9511: PPUSH
9512: PPUSH
9513: PPUSH
// side := 3 ;
9514: LD_ADDR_VAR 0 6
9518: PUSH
9519: LD_INT 3
9521: ST_TO_ADDR
// InitHc ;
9522: CALL_OW 19
// uc_side := side ;
9526: LD_ADDR_OWVAR 20
9530: PUSH
9531: LD_VAR 0 6
9535: ST_TO_ADDR
// uc_nation := 3 ;
9536: LD_ADDR_OWVAR 21
9540: PUSH
9541: LD_INT 3
9543: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9544: LD_ADDR_VAR 0 2
9548: PUSH
9549: LD_INT 22
9551: PUSH
9552: LD_VAR 0 6
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PUSH
9561: LD_INT 21
9563: PUSH
9564: LD_INT 3
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: PUSH
9571: EMPTY
9572: LIST
9573: LIST
9574: PPUSH
9575: CALL_OW 69
9579: PUSH
9580: FOR_IN
9581: IFFALSE 9597
// SetBLevel ( i , 10 ) ;
9583: LD_VAR 0 2
9587: PPUSH
9588: LD_INT 10
9590: PPUSH
9591: CALL_OW 241
9595: GO 9580
9597: POP
9598: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9599: LD_ADDR_VAR 0 10
9603: PUSH
9604: LD_INT 22
9606: PUSH
9607: LD_VAR 0 6
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: PUSH
9616: LD_INT 30
9618: PUSH
9619: LD_INT 34
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: PUSH
9626: EMPTY
9627: LIST
9628: LIST
9629: PPUSH
9630: CALL_OW 69
9634: ST_TO_ADDR
// if teleport then
9635: LD_VAR 0 10
9639: IFFALSE 9660
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9641: LD_VAR 0 10
9645: PUSH
9646: LD_INT 1
9648: ARRAY
9649: PPUSH
9650: LD_INT 123
9652: PPUSH
9653: LD_INT 122
9655: PPUSH
9656: CALL_OW 243
// hc_importance := 0 ;
9660: LD_ADDR_OWVAR 32
9664: PUSH
9665: LD_INT 0
9667: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9668: LD_ADDR_EXP 62
9672: PUSH
9673: LD_STRING Platonov
9675: PPUSH
9676: CALL_OW 25
9680: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9681: LD_ADDR_EXP 63
9685: PUSH
9686: LD_STRING Yakotich
9688: PPUSH
9689: LD_EXP 1
9693: NOT
9694: PPUSH
9695: LD_STRING 09_
9697: PPUSH
9698: CALL 54411 0 3
9702: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9703: LD_ADDR_EXP 64
9707: PUSH
9708: LD_STRING Gleb
9710: PPUSH
9711: CALL_OW 25
9715: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9716: LD_STRING 03_Cornel
9718: PPUSH
9719: CALL_OW 28
9723: IFFALSE 9771
// begin Bierezov := NewCharacter ( Mikhail ) ;
9725: LD_ADDR_EXP 65
9729: PUSH
9730: LD_STRING Mikhail
9732: PPUSH
9733: CALL_OW 25
9737: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9738: LD_EXP 65
9742: PPUSH
9743: LD_INT 197
9745: PPUSH
9746: LD_INT 111
9748: PPUSH
9749: LD_INT 9
9751: PPUSH
9752: LD_INT 0
9754: PPUSH
9755: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9759: LD_EXP 65
9763: PPUSH
9764: LD_INT 3
9766: PPUSH
9767: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9771: LD_EXP 62
9775: PPUSH
9776: LD_INT 126
9778: PPUSH
9779: CALL_OW 52
// if Yakotich then
9783: LD_EXP 63
9787: IFFALSE 9810
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9789: LD_EXP 63
9793: PPUSH
9794: LD_INT 197
9796: PPUSH
9797: LD_INT 111
9799: PPUSH
9800: LD_INT 9
9802: PPUSH
9803: LD_INT 0
9805: PPUSH
9806: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9810: LD_EXP 64
9814: PPUSH
9815: LD_INT 197
9817: PPUSH
9818: LD_INT 111
9820: PPUSH
9821: LD_INT 9
9823: PPUSH
9824: LD_INT 0
9826: PPUSH
9827: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9831: LD_ADDR_VAR 0 5
9835: PUSH
9836: LD_INT 126
9838: PPUSH
9839: LD_INT 2
9841: PPUSH
9842: LD_STRING zhukov
9844: PPUSH
9845: LD_INT 9
9847: PUSH
9848: LD_INT 10
9850: PUSH
9851: LD_INT 10
9853: PUSH
9854: LD_INT 10
9856: PUSH
9857: EMPTY
9858: LIST
9859: LIST
9860: LIST
9861: LIST
9862: PUSH
9863: LD_OWVAR 67
9867: ARRAY
9868: PPUSH
9869: LD_INT 9000
9871: PUSH
9872: LD_INT 1000
9874: PUSH
9875: LD_INT 300
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: LIST
9882: PPUSH
9883: LD_INT 21
9885: PUSH
9886: LD_INT 8
9888: PUSH
9889: LD_INT 13
9891: PUSH
9892: LD_INT 8
9894: PUSH
9895: EMPTY
9896: LIST
9897: LIST
9898: LIST
9899: LIST
9900: PPUSH
9901: CALL 63268 0 6
9905: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9906: LD_ADDR_EXP 80
9910: PUSH
9911: LD_EXP 80
9915: PPUSH
9916: LD_INT 2
9918: PPUSH
9919: LD_VAR 0 5
9923: PUSH
9924: LD_EXP 63
9928: PUSH
9929: LD_EXP 64
9933: PUSH
9934: LD_EXP 65
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: LIST
9943: UNION
9944: PPUSH
9945: CALL_OW 1
9949: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9950: LD_ADDR_VAR 0 4
9954: PUSH
9955: LD_INT 267
9957: PPUSH
9958: CALL_OW 274
9962: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9963: LD_VAR 0 4
9967: PPUSH
9968: LD_INT 1
9970: PPUSH
9971: LD_INT 5000
9973: PPUSH
9974: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9978: LD_VAR 0 4
9982: PPUSH
9983: LD_INT 2
9985: PPUSH
9986: LD_INT 200
9988: PPUSH
9989: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9993: LD_VAR 0 4
9997: PPUSH
9998: LD_INT 3
10000: PPUSH
10001: LD_INT 200
10003: PPUSH
10004: CALL_OW 277
// for i := 1 to 6 do
10008: LD_ADDR_VAR 0 2
10012: PUSH
10013: DOUBLE
10014: LD_INT 1
10016: DEC
10017: ST_TO_ADDR
10018: LD_INT 6
10020: PUSH
10021: FOR_TO
10022: IFFALSE 10105
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
10024: LD_INT 0
10026: PPUSH
10027: LD_INT 8
10029: PUSH
10030: LD_INT 9
10032: PUSH
10033: LD_INT 10
10035: PUSH
10036: LD_INT 10
10038: PUSH
10039: EMPTY
10040: LIST
10041: LIST
10042: LIST
10043: LIST
10044: PUSH
10045: LD_OWVAR 67
10049: ARRAY
10050: PPUSH
10051: CALL_OW 381
// un := CreateHuman ;
10055: LD_ADDR_VAR 0 8
10059: PUSH
10060: CALL_OW 44
10064: ST_TO_ADDR
// if i mod 2 = 0 then
10065: LD_VAR 0 2
10069: PUSH
10070: LD_INT 2
10072: MOD
10073: PUSH
10074: LD_INT 0
10076: EQUAL
10077: IFFALSE 10091
// SetClass ( un , class_bazooker ) ;
10079: LD_VAR 0 8
10083: PPUSH
10084: LD_INT 9
10086: PPUSH
10087: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
10091: LD_VAR 0 8
10095: PPUSH
10096: LD_INT 674
10098: PPUSH
10099: CALL_OW 52
// end ;
10103: GO 10021
10105: POP
10106: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
10107: LD_INT 21
10109: PPUSH
10110: LD_INT 3
10112: PPUSH
10113: LD_INT 3
10115: PPUSH
10116: LD_INT 52
10118: PPUSH
10119: LD_INT 100
10121: PPUSH
10122: CALL 59431 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
10126: CALL_OW 45
10130: PPUSH
10131: LD_INT 259
10133: PPUSH
10134: LD_INT 145
10136: PPUSH
10137: LD_INT 3
10139: PPUSH
10140: LD_INT 0
10142: PPUSH
10143: CALL 94761 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
10147: CALL_OW 45
10151: PPUSH
10152: LD_INT 245
10154: PPUSH
10155: LD_INT 139
10157: PPUSH
10158: LD_INT 3
10160: PPUSH
10161: LD_INT 0
10163: PPUSH
10164: CALL 94761 0 5
// behemoths := [ ] ;
10168: LD_ADDR_EXP 66
10172: PUSH
10173: EMPTY
10174: ST_TO_ADDR
// behemothBuilders := [ ] ;
10175: LD_ADDR_EXP 67
10179: PUSH
10180: EMPTY
10181: ST_TO_ADDR
// j := 3 ;
10182: LD_ADDR_VAR 0 3
10186: PUSH
10187: LD_INT 3
10189: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
10190: LD_ADDR_VAR 0 2
10194: PUSH
10195: LD_INT 22
10197: PUSH
10198: LD_INT 3
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PUSH
10205: LD_INT 25
10207: PUSH
10208: LD_INT 3
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: PPUSH
10219: CALL_OW 69
10223: PUSH
10224: FOR_IN
10225: IFFALSE 10275
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
10227: LD_ADDR_EXP 67
10231: PUSH
10232: LD_EXP 67
10236: PPUSH
10237: LD_VAR 0 2
10241: PPUSH
10242: CALL 92601 0 2
10246: ST_TO_ADDR
// j := j - 1 ;
10247: LD_ADDR_VAR 0 3
10251: PUSH
10252: LD_VAR 0 3
10256: PUSH
10257: LD_INT 1
10259: MINUS
10260: ST_TO_ADDR
// if j = 0 then
10261: LD_VAR 0 3
10265: PUSH
10266: LD_INT 0
10268: EQUAL
10269: IFFALSE 10273
// break ;
10271: GO 10275
// end ;
10273: GO 10224
10275: POP
10276: POP
// end ;
10277: LD_VAR 0 1
10281: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
10282: LD_INT 0
10284: PPUSH
10285: PPUSH
10286: PPUSH
10287: PPUSH
10288: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
10289: LD_ADDR_VAR 0 4
10293: PUSH
10294: LD_INT 209
10296: PUSH
10297: LD_INT 149
10299: PUSH
10300: EMPTY
10301: LIST
10302: LIST
10303: PUSH
10304: LD_INT 219
10306: PUSH
10307: LD_INT 154
10309: PUSH
10310: EMPTY
10311: LIST
10312: LIST
10313: PUSH
10314: LD_INT 223
10316: PUSH
10317: LD_INT 149
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PUSH
10324: LD_INT 232
10326: PUSH
10327: LD_INT 155
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: ST_TO_ADDR
// if not behemothBuilders then
10340: LD_EXP 67
10344: NOT
10345: IFFALSE 10349
// exit ;
10347: GO 10453
// j := 1 ;
10349: LD_ADDR_VAR 0 3
10353: PUSH
10354: LD_INT 1
10356: ST_TO_ADDR
// for i in behemothBuilders do
10357: LD_ADDR_VAR 0 2
10361: PUSH
10362: LD_EXP 67
10366: PUSH
10367: FOR_IN
10368: IFFALSE 10451
// begin if IsInUnit ( i ) then
10370: LD_VAR 0 2
10374: PPUSH
10375: CALL_OW 310
10379: IFFALSE 10390
// ComExitBuilding ( i ) ;
10381: LD_VAR 0 2
10385: PPUSH
10386: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
10390: LD_VAR 0 2
10394: PPUSH
10395: LD_INT 37
10397: PPUSH
10398: LD_VAR 0 4
10402: PUSH
10403: LD_VAR 0 3
10407: ARRAY
10408: PUSH
10409: LD_INT 1
10411: ARRAY
10412: PPUSH
10413: LD_VAR 0 4
10417: PUSH
10418: LD_VAR 0 3
10422: ARRAY
10423: PUSH
10424: LD_INT 2
10426: ARRAY
10427: PPUSH
10428: LD_INT 0
10430: PPUSH
10431: CALL_OW 230
// j := j + 1 ;
10435: LD_ADDR_VAR 0 3
10439: PUSH
10440: LD_VAR 0 3
10444: PUSH
10445: LD_INT 1
10447: PLUS
10448: ST_TO_ADDR
// end ;
10449: GO 10367
10451: POP
10452: POP
// end ;
10453: LD_VAR 0 1
10457: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10458: LD_INT 3
10460: PPUSH
10461: CALL 92662 0 1
10465: IFFALSE 10498
10467: PUSH
10468: LD_INT 22
10470: PUSH
10471: LD_INT 3
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: PUSH
10478: LD_INT 30
10480: PUSH
10481: LD_INT 37
10483: PUSH
10484: EMPTY
10485: LIST
10486: LIST
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: PPUSH
10492: CALL_OW 69
10496: NOT
10497: AND
10498: IFFALSE 10688
10500: GO 10502
10502: DISABLE
10503: LD_INT 0
10505: PPUSH
10506: PPUSH
// begin enable ;
10507: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10508: LD_ADDR_VAR 0 2
10512: PUSH
10513: LD_INT 3
10515: PPUSH
10516: CALL 92662 0 1
10520: ST_TO_ADDR
// for i in tmp do
10521: LD_ADDR_VAR 0 1
10525: PUSH
10526: LD_VAR 0 2
10530: PUSH
10531: FOR_IN
10532: IFFALSE 10686
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10534: LD_VAR 0 1
10538: PPUSH
10539: LD_INT 7
10541: PPUSH
10542: CALL_OW 308
10546: IFFALSE 10564
10548: PUSH
10549: LD_VAR 0 1
10553: PPUSH
10554: CALL_OW 110
10558: PUSH
10559: LD_INT 2
10561: EQUAL
10562: NOT
10563: AND
10564: IFFALSE 10578
// SetTag ( i , 2 ) ;
10566: LD_VAR 0 1
10570: PPUSH
10571: LD_INT 2
10573: PPUSH
10574: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10578: LD_INT 81
10580: PUSH
10581: LD_INT 3
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PUSH
10588: LD_INT 91
10590: PUSH
10591: LD_VAR 0 1
10595: PUSH
10596: LD_INT 12
10598: PUSH
10599: EMPTY
10600: LIST
10601: LIST
10602: LIST
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PPUSH
10608: CALL_OW 69
10612: NOT
10613: IFFALSE 10631
10615: PUSH
10616: LD_VAR 0 1
10620: PPUSH
10621: CALL_OW 110
10625: PUSH
10626: LD_INT 2
10628: EQUAL
10629: NOT
10630: AND
10631: IFFALSE 10650
// ComAgressiveMove ( i , 64 , 93 ) else
10633: LD_VAR 0 1
10637: PPUSH
10638: LD_INT 64
10640: PPUSH
10641: LD_INT 93
10643: PPUSH
10644: CALL_OW 114
10648: GO 10684
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10650: LD_VAR 0 1
10654: PPUSH
10655: LD_INT 81
10657: PUSH
10658: LD_INT 3
10660: PUSH
10661: EMPTY
10662: LIST
10663: LIST
10664: PPUSH
10665: CALL_OW 69
10669: PPUSH
10670: LD_VAR 0 1
10674: PPUSH
10675: CALL_OW 74
10679: PPUSH
10680: CALL_OW 115
// end ;
10684: GO 10531
10686: POP
10687: POP
// end ;
10688: PPOPN 2
10690: END
// every 6 6$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10691: LD_EXP 2
10695: NOT
10696: IFFALSE 11788
10698: GO 10700
10700: DISABLE
10701: LD_INT 0
10703: PPUSH
10704: PPUSH
10705: PPUSH
10706: PPUSH
10707: PPUSH
// begin enable ;
10708: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10709: LD_INT 22
10711: PUSH
10712: LD_INT 3
10714: PUSH
10715: EMPTY
10716: LIST
10717: LIST
10718: PUSH
10719: LD_INT 30
10721: PUSH
10722: LD_INT 3
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PPUSH
10733: CALL_OW 69
10737: NOT
10738: IFFALSE 10742
// exit ;
10740: GO 11788
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10742: LD_ADDR_VAR 0 4
10746: PUSH
10747: LD_INT 22
10749: PUSH
10750: LD_INT 3
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PUSH
10757: LD_INT 30
10759: PUSH
10760: LD_INT 34
10762: PUSH
10763: EMPTY
10764: LIST
10765: LIST
10766: PUSH
10767: EMPTY
10768: LIST
10769: LIST
10770: PPUSH
10771: CALL_OW 69
10775: ST_TO_ADDR
// if Prob ( 40 ) then
10776: LD_INT 40
10778: PPUSH
10779: CALL_OW 13
10783: IFFALSE 10910
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10785: LD_INT 2
10787: PPUSH
10788: LD_INT 22
10790: PUSH
10791: LD_INT 3
10793: PUSH
10794: LD_INT 3
10796: PUSH
10797: LD_INT 49
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: LIST
10804: LIST
10805: PUSH
10806: LD_INT 22
10808: PUSH
10809: LD_INT 3
10811: PUSH
10812: LD_INT 3
10814: PUSH
10815: LD_INT 49
10817: PUSH
10818: EMPTY
10819: LIST
10820: LIST
10821: LIST
10822: LIST
10823: PUSH
10824: LD_INT 22
10826: PUSH
10827: LD_INT 3
10829: PUSH
10830: LD_INT 3
10832: PUSH
10833: LD_INT 49
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: PUSH
10842: LD_INT 24
10844: PUSH
10845: LD_INT 3
10847: PUSH
10848: LD_INT 3
10850: PUSH
10851: LD_INT 46
10853: PUSH
10854: EMPTY
10855: LIST
10856: LIST
10857: LIST
10858: LIST
10859: PUSH
10860: LD_INT 24
10862: PUSH
10863: LD_INT 3
10865: PUSH
10866: LD_INT 3
10868: PUSH
10869: LD_INT 46
10871: PUSH
10872: EMPTY
10873: LIST
10874: LIST
10875: LIST
10876: LIST
10877: PUSH
10878: LD_INT 24
10880: PUSH
10881: LD_INT 3
10883: PUSH
10884: LD_INT 3
10886: PUSH
10887: LD_INT 46
10889: PUSH
10890: EMPTY
10891: LIST
10892: LIST
10893: LIST
10894: LIST
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: PPUSH
10904: CALL 47887 0 2
// end else
10908: GO 11033
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10910: LD_INT 2
10912: PPUSH
10913: LD_INT 24
10915: PUSH
10916: LD_INT 3
10918: PUSH
10919: LD_INT 3
10921: PUSH
10922: LD_INT 47
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: PUSH
10931: LD_INT 24
10933: PUSH
10934: LD_INT 3
10936: PUSH
10937: LD_INT 3
10939: PUSH
10940: LD_INT 47
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: LIST
10947: LIST
10948: PUSH
10949: LD_INT 24
10951: PUSH
10952: LD_INT 3
10954: PUSH
10955: LD_INT 3
10957: PUSH
10958: LD_INT 47
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: LIST
10965: LIST
10966: PUSH
10967: LD_INT 24
10969: PUSH
10970: LD_INT 3
10972: PUSH
10973: LD_INT 3
10975: PUSH
10976: LD_INT 46
10978: PUSH
10979: EMPTY
10980: LIST
10981: LIST
10982: LIST
10983: LIST
10984: PUSH
10985: LD_INT 24
10987: PUSH
10988: LD_INT 3
10990: PUSH
10991: LD_INT 3
10993: PUSH
10994: LD_INT 46
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: LIST
11001: LIST
11002: PUSH
11003: LD_INT 24
11005: PUSH
11006: LD_INT 3
11008: PUSH
11009: LD_INT 3
11011: PUSH
11012: LD_INT 46
11014: PUSH
11015: EMPTY
11016: LIST
11017: LIST
11018: LIST
11019: LIST
11020: PUSH
11021: EMPTY
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: PPUSH
11029: CALL 47887 0 2
// end ; if Difficulty > 1 then
11033: LD_OWVAR 67
11037: PUSH
11038: LD_INT 1
11040: GREATER
11041: IFFALSE 11071
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
11043: LD_INT 2
11045: PPUSH
11046: LD_INT 24
11048: PUSH
11049: LD_INT 3
11051: PUSH
11052: LD_INT 3
11054: PUSH
11055: LD_INT 47
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: LIST
11062: LIST
11063: PUSH
11064: EMPTY
11065: LIST
11066: PPUSH
11067: CALL 47887 0 2
// p := 0 ;
11071: LD_ADDR_VAR 0 5
11075: PUSH
11076: LD_INT 0
11078: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11079: LD_INT 35
11081: PPUSH
11082: CALL_OW 67
// p := Inc ( p ) ;
11086: LD_ADDR_VAR 0 5
11090: PUSH
11091: LD_VAR 0 5
11095: PPUSH
11096: CALL 93974 0 1
11100: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 120 ;
11101: LD_INT 2
11103: PPUSH
11104: LD_INT 1
11106: PPUSH
11107: CALL 49343 0 2
11111: PUSH
11112: LD_INT 6
11114: PUSH
11115: LD_INT 7
11117: PUSH
11118: LD_INT 7
11120: PUSH
11121: LD_INT 7
11123: PUSH
11124: EMPTY
11125: LIST
11126: LIST
11127: LIST
11128: LIST
11129: PUSH
11130: LD_OWVAR 67
11134: ARRAY
11135: GREATEREQUAL
11136: IFTRUE 11148
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: LD_INT 120
11146: GREATER
11147: OR
11148: IFFALSE 11079
// wait ( 0 0$30 ) ;
11150: LD_INT 1050
11152: PPUSH
11153: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11157: LD_ADDR_VAR 0 2
11161: PUSH
11162: LD_INT 22
11164: PUSH
11165: LD_INT 3
11167: PUSH
11168: EMPTY
11169: LIST
11170: LIST
11171: PUSH
11172: LD_INT 23
11174: PUSH
11175: LD_INT 3
11177: PUSH
11178: EMPTY
11179: LIST
11180: LIST
11181: PUSH
11182: LD_INT 21
11184: PUSH
11185: LD_INT 2
11187: PUSH
11188: EMPTY
11189: LIST
11190: LIST
11191: PUSH
11192: LD_INT 3
11194: PUSH
11195: LD_INT 34
11197: PUSH
11198: LD_INT 48
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PUSH
11205: EMPTY
11206: LIST
11207: LIST
11208: PUSH
11209: LD_INT 3
11211: PUSH
11212: LD_INT 34
11214: PUSH
11215: LD_INT 51
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PUSH
11226: LD_INT 3
11228: PUSH
11229: LD_INT 34
11231: PUSH
11232: LD_INT 52
11234: PUSH
11235: EMPTY
11236: LIST
11237: LIST
11238: PUSH
11239: EMPTY
11240: LIST
11241: LIST
11242: PUSH
11243: EMPTY
11244: LIST
11245: LIST
11246: LIST
11247: LIST
11248: LIST
11249: LIST
11250: PPUSH
11251: CALL_OW 69
11255: PUSH
11256: LD_EXP 102
11260: PUSH
11261: LD_INT 2
11263: ARRAY
11264: DIFF
11265: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11266: LD_ADDR_EXP 99
11270: PUSH
11271: LD_EXP 99
11275: PPUSH
11276: LD_INT 2
11278: PPUSH
11279: LD_EXP 99
11283: PUSH
11284: LD_INT 2
11286: ARRAY
11287: PUSH
11288: LD_VAR 0 2
11292: DIFF
11293: PPUSH
11294: CALL_OW 1
11298: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11299: LD_ADDR_VAR 0 3
11303: PUSH
11304: LD_INT 0
11306: PPUSH
11307: LD_INT 1
11309: PPUSH
11310: CALL_OW 12
11314: ST_TO_ADDR
// p := 0 ;
11315: LD_ADDR_VAR 0 5
11319: PUSH
11320: LD_INT 0
11322: ST_TO_ADDR
// if target then
11323: LD_VAR 0 3
11327: IFFALSE 11482
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11329: LD_ADDR_VAR 0 2
11333: PUSH
11334: LD_VAR 0 2
11338: PPUSH
11339: LD_INT 24
11341: PUSH
11342: LD_INT 250
11344: PUSH
11345: EMPTY
11346: LIST
11347: LIST
11348: PPUSH
11349: CALL_OW 72
11353: ST_TO_ADDR
// for i in tmp do
11354: LD_ADDR_VAR 0 1
11358: PUSH
11359: LD_VAR 0 2
11363: PUSH
11364: FOR_IN
11365: IFFALSE 11405
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11367: LD_VAR 0 1
11371: PPUSH
11372: LD_INT 139
11374: PPUSH
11375: LD_INT 89
11377: PPUSH
11378: CALL_OW 297
11382: PUSH
11383: LD_INT 9
11385: GREATER
11386: IFFALSE 11403
// ComMoveXY ( i , 139 , 89 ) ;
11388: LD_VAR 0 1
11392: PPUSH
11393: LD_INT 139
11395: PPUSH
11396: LD_INT 89
11398: PPUSH
11399: CALL_OW 111
11403: GO 11364
11405: POP
11406: POP
// wait ( 0 0$1 ) ;
11407: LD_INT 35
11409: PPUSH
11410: CALL_OW 67
// p := Inc ( p ) ;
11414: LD_ADDR_VAR 0 5
11418: PUSH
11419: LD_VAR 0 5
11423: PPUSH
11424: CALL 93974 0 1
11428: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11429: LD_VAR 0 2
11433: PPUSH
11434: LD_INT 92
11436: PUSH
11437: LD_INT 139
11439: PUSH
11440: LD_INT 89
11442: PUSH
11443: LD_INT 9
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: PPUSH
11452: CALL_OW 72
11456: PUSH
11457: LD_VAR 0 2
11461: PUSH
11462: LD_INT 1
11464: MINUS
11465: GREATEREQUAL
11466: IFTRUE 11478
11468: PUSH
11469: LD_VAR 0 5
11473: PUSH
11474: LD_INT 30
11476: GREATER
11477: OR
11478: IFFALSE 11329
// end else
11480: GO 11651
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11482: LD_VAR 0 2
11486: PPUSH
11487: LD_VAR 0 4
11491: PUSH
11492: LD_INT 1
11494: ARRAY
11495: PPUSH
11496: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11500: LD_ADDR_VAR 0 2
11504: PUSH
11505: LD_VAR 0 2
11509: PPUSH
11510: LD_INT 24
11512: PUSH
11513: LD_INT 250
11515: PUSH
11516: EMPTY
11517: LIST
11518: LIST
11519: PPUSH
11520: CALL_OW 72
11524: ST_TO_ADDR
// for i in tmp do
11525: LD_ADDR_VAR 0 1
11529: PUSH
11530: LD_VAR 0 2
11534: PUSH
11535: FOR_IN
11536: IFFALSE 11576
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11538: LD_VAR 0 1
11542: PPUSH
11543: LD_INT 124
11545: PPUSH
11546: LD_INT 139
11548: PPUSH
11549: CALL_OW 297
11553: PUSH
11554: LD_INT 9
11556: GREATER
11557: IFFALSE 11574
// ComMoveXY ( i , 124 , 139 ) ;
11559: LD_VAR 0 1
11563: PPUSH
11564: LD_INT 124
11566: PPUSH
11567: LD_INT 139
11569: PPUSH
11570: CALL_OW 111
11574: GO 11535
11576: POP
11577: POP
// wait ( 0 0$1 ) ;
11578: LD_INT 35
11580: PPUSH
11581: CALL_OW 67
// p := Inc ( p ) ;
11585: LD_ADDR_VAR 0 5
11589: PUSH
11590: LD_VAR 0 5
11594: PPUSH
11595: CALL 93974 0 1
11599: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11600: LD_VAR 0 2
11604: PPUSH
11605: LD_INT 92
11607: PUSH
11608: LD_INT 124
11610: PUSH
11611: LD_INT 139
11613: PUSH
11614: LD_INT 9
11616: PUSH
11617: EMPTY
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: PPUSH
11623: CALL_OW 72
11627: PUSH
11628: LD_VAR 0 2
11632: PUSH
11633: LD_INT 1
11635: MINUS
11636: GREATEREQUAL
11637: IFTRUE 11649
11639: PUSH
11640: LD_VAR 0 5
11644: PUSH
11645: LD_INT 30
11647: GREATER
11648: OR
11649: IFFALSE 11500
// end ; repeat wait ( 0 0$1 ) ;
11651: LD_INT 35
11653: PPUSH
11654: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11658: LD_ADDR_VAR 0 2
11662: PUSH
11663: LD_VAR 0 2
11667: PPUSH
11668: LD_INT 50
11670: PUSH
11671: EMPTY
11672: LIST
11673: PPUSH
11674: CALL_OW 72
11678: ST_TO_ADDR
// for i in tmp do
11679: LD_ADDR_VAR 0 1
11683: PUSH
11684: LD_VAR 0 2
11688: PUSH
11689: FOR_IN
11690: IFFALSE 11779
// begin if GetWeapon ( i ) = ru_time_lapser then
11692: LD_VAR 0 1
11696: PPUSH
11697: CALL_OW 264
11701: PUSH
11702: LD_INT 49
11704: EQUAL
11705: IFFALSE 11743
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11707: LD_VAR 0 1
11711: PPUSH
11712: LD_INT 81
11714: PUSH
11715: LD_INT 3
11717: PUSH
11718: EMPTY
11719: LIST
11720: LIST
11721: PPUSH
11722: CALL_OW 69
11726: PPUSH
11727: LD_VAR 0 1
11731: PPUSH
11732: CALL_OW 74
11736: PPUSH
11737: CALL_OW 112
11741: GO 11777
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11743: LD_VAR 0 1
11747: PPUSH
11748: LD_INT 81
11750: PUSH
11751: LD_INT 3
11753: PUSH
11754: EMPTY
11755: LIST
11756: LIST
11757: PPUSH
11758: CALL_OW 69
11762: PPUSH
11763: LD_VAR 0 1
11767: PPUSH
11768: CALL_OW 74
11772: PPUSH
11773: CALL_OW 115
// end ;
11777: GO 11689
11779: POP
11780: POP
// until not tmp ;
11781: LD_VAR 0 2
11785: NOT
11786: IFFALSE 11651
// end ;
11788: PPOPN 5
11790: END
// every 30 30$00 trigger not russianDestroyed do
11791: LD_EXP 2
11795: NOT
11796: IFFALSE 11865
11798: GO 11800
11800: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11801: LD_INT 105000
11803: PUSH
11804: LD_INT 84000
11806: PUSH
11807: LD_INT 63000
11809: PUSH
11810: LD_INT 52500
11812: PUSH
11813: EMPTY
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: PUSH
11819: LD_OWVAR 67
11823: ARRAY
11824: PPUSH
11825: CALL_OW 67
// if russianDestroyed then
11829: LD_EXP 2
11833: IFFALSE 11837
// exit ;
11835: GO 11865
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11837: LD_INT 2
11839: PPUSH
11840: LD_INT 23
11842: PUSH
11843: LD_INT 3
11845: PUSH
11846: LD_INT 1
11848: PUSH
11849: LD_INT 48
11851: PUSH
11852: EMPTY
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: PUSH
11858: EMPTY
11859: LIST
11860: PPUSH
11861: CALL 47887 0 2
// end ; end_of_file
11865: END
// export function CustomEvent ( event ) ; begin
11866: LD_INT 0
11868: PPUSH
// end ;
11869: LD_VAR 0 2
11873: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11874: LD_VAR 0 2
11878: PPUSH
11879: LD_VAR 0 3
11883: PPUSH
11884: LD_INT 15
11886: PPUSH
11887: CALL_OW 309
11891: IFFALSE 11900
// YouLost ( MothContaminate ) ;
11893: LD_STRING MothContaminate
11895: PPUSH
11896: CALL_OW 104
// end ;
11900: PPOPN 3
11902: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11903: LD_VAR 0 2
11907: PPUSH
11908: LD_VAR 0 3
11912: PPUSH
11913: LD_INT 15
11915: PPUSH
11916: CALL_OW 309
11920: IFFALSE 11936
// begin wait ( 0 0$6 ) ;
11922: LD_INT 210
11924: PPUSH
11925: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11929: LD_STRING MothContaminateBomb
11931: PPUSH
11932: CALL_OW 104
// end ; end ;
11936: PPOPN 3
11938: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11939: LD_VAR 0 1
11943: PPUSH
11944: CALL 114034 0 1
// if un = JMM then
11948: LD_VAR 0 1
11952: PUSH
11953: LD_EXP 21
11957: EQUAL
11958: IFFALSE 11969
// begin YouLost ( JMM ) ;
11960: LD_STRING JMM
11962: PPUSH
11963: CALL_OW 104
// exit ;
11967: GO 12120
// end ; if un = Omar then
11969: LD_VAR 0 1
11973: PUSH
11974: LD_EXP 58
11978: EQUAL
11979: IFFALSE 11989
// omarKilled := true ;
11981: LD_ADDR_EXP 20
11985: PUSH
11986: LD_INT 1
11988: ST_TO_ADDR
// if GetSide ( un ) = 2 and not arabianAttacked then
11989: LD_VAR 0 1
11993: PPUSH
11994: CALL_OW 255
11998: PUSH
11999: LD_INT 2
12001: EQUAL
12002: IFFALSE 12011
12004: PUSH
12005: LD_EXP 18
12009: NOT
12010: AND
12011: IFFALSE 12021
// arabianAttacked := true ;
12013: LD_ADDR_EXP 18
12017: PUSH
12018: LD_INT 1
12020: ST_TO_ADDR
// if un = Powell then
12021: LD_VAR 0 1
12025: PUSH
12026: LD_EXP 57
12030: EQUAL
12031: IFFALSE 12041
// americanDestroyed := true ;
12033: LD_ADDR_EXP 4
12037: PUSH
12038: LD_INT 1
12040: ST_TO_ADDR
// if un = Platonov then
12041: LD_VAR 0 1
12045: PUSH
12046: LD_EXP 62
12050: EQUAL
12051: IFFALSE 12061
// russianDestroyed := true ;
12053: LD_ADDR_EXP 2
12057: PUSH
12058: LD_INT 1
12060: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
12061: LD_VAR 0 1
12065: PUSH
12066: LD_INT 22
12068: PUSH
12069: LD_INT 7
12071: PUSH
12072: EMPTY
12073: LIST
12074: LIST
12075: PUSH
12076: LD_INT 21
12078: PUSH
12079: LD_INT 2
12081: PUSH
12082: EMPTY
12083: LIST
12084: LIST
12085: PUSH
12086: EMPTY
12087: LIST
12088: LIST
12089: PPUSH
12090: CALL_OW 69
12094: IN
12095: IFFALSE 12111
// vehicleLostCounter := vehicleLostCounter + 1 ;
12097: LD_ADDR_EXP 15
12101: PUSH
12102: LD_EXP 15
12106: PUSH
12107: LD_INT 1
12109: PLUS
12110: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
12111: LD_VAR 0 1
12115: PPUSH
12116: CALL 51393 0 1
// end ;
12120: PPOPN 1
12122: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12123: LD_VAR 0 1
12127: PPUSH
12128: LD_VAR 0 2
12132: PPUSH
12133: CALL 53747 0 2
// end ;
12137: PPOPN 2
12139: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12140: LD_VAR 0 1
12144: PPUSH
12145: CALL 52811 0 1
// end ;
12149: PPOPN 1
12151: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
12152: LD_VAR 0 1
12156: PUSH
12157: LD_INT 22
12159: PUSH
12160: LD_INT 8
12162: PUSH
12163: EMPTY
12164: LIST
12165: LIST
12166: PUSH
12167: LD_INT 30
12169: PUSH
12170: LD_INT 2
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: PUSH
12177: LD_INT 23
12179: PUSH
12180: LD_INT 3
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: PUSH
12187: EMPTY
12188: LIST
12189: LIST
12190: LIST
12191: PPUSH
12192: CALL_OW 69
12196: IN
12197: IFFALSE 12224
// begin ComUpgrade ( building ) ;
12199: LD_VAR 0 1
12203: PPUSH
12204: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
12208: LD_EXP 60
12212: PPUSH
12213: LD_VAR 0 1
12217: PPUSH
12218: CALL 62805 0 2
// exit ;
12222: GO 12233
// end ; MCE_BuildingComplete ( building ) ;
12224: LD_VAR 0 1
12228: PPUSH
12229: CALL 53054 0 1
// end ;
12233: PPOPN 1
12235: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12236: LD_VAR 0 1
12240: PPUSH
12241: LD_VAR 0 2
12245: PPUSH
12246: CALL 51081 0 2
// end ;
12250: PPOPN 2
12252: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12253: LD_VAR 0 1
12257: PPUSH
12258: LD_VAR 0 2
12262: PPUSH
12263: LD_VAR 0 3
12267: PPUSH
12268: LD_VAR 0 4
12272: PPUSH
12273: LD_VAR 0 5
12277: PPUSH
12278: CALL 50699 0 5
// end ;
12282: PPOPN 5
12284: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
12285: LD_VAR 0 1
12289: PPUSH
12290: LD_VAR 0 2
12294: PPUSH
12295: CALL 114092 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
12299: LD_VAR 0 1
12303: PPUSH
12304: LD_VAR 0 2
12308: PPUSH
12309: CALL 50248 0 2
// end ;
12313: PPOPN 2
12315: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12316: LD_VAR 0 1
12320: PPUSH
12321: LD_VAR 0 2
12325: PPUSH
12326: LD_VAR 0 3
12330: PPUSH
12331: LD_VAR 0 4
12335: PPUSH
12336: CALL 50080 0 4
// end ;
12340: PPOPN 4
12342: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12343: LD_VAR 0 1
12347: PPUSH
12348: LD_VAR 0 2
12352: PPUSH
12353: LD_VAR 0 3
12357: PPUSH
12358: CALL 49853 0 3
// end ;
12362: PPOPN 3
12364: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12365: LD_VAR 0 1
12369: PPUSH
12370: LD_VAR 0 2
12374: PPUSH
12375: CALL 49736 0 2
// end ;
12379: PPOPN 2
12381: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12382: LD_VAR 0 1
12386: PPUSH
12387: LD_VAR 0 2
12391: PPUSH
12392: CALL 54044 0 2
// end ;
12396: PPOPN 2
12398: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
12399: LD_VAR 0 1
12403: PUSH
12404: LD_INT 674
12406: EQUAL
12407: IFFALSE 12429
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
12409: LD_VAR 0 2
12413: PPUSH
12414: LD_INT 227
12416: PPUSH
12417: LD_INT 136
12419: PPUSH
12420: CALL_OW 428
12424: PPUSH
12425: CALL_OW 120
// end ;
12429: PPOPN 2
12431: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12432: LD_VAR 0 1
12436: PPUSH
12437: LD_VAR 0 2
12441: PPUSH
12442: LD_VAR 0 3
12446: PPUSH
12447: LD_VAR 0 4
12451: PPUSH
12452: CALL 54268 0 4
// end ;
12456: PPOPN 4
12458: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12459: LD_VAR 0 1
12463: PPUSH
12464: LD_VAR 0 2
12468: PPUSH
12469: CALL 49543 0 2
// end ;
12473: PPOPN 2
12475: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12476: LD_VAR 0 1
12480: PPUSH
12481: CALL 114076 0 1
// end ; end_of_file
12485: PPOPN 1
12487: END
// export function Action ; begin
12488: LD_INT 0
12490: PPUSH
// InGameOn ;
12491: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
12495: LD_INT 206
12497: PPUSH
12498: LD_INT 11
12500: PPUSH
12501: CALL_OW 86
// wait ( 0 0$1 ) ;
12505: LD_INT 35
12507: PPUSH
12508: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
12512: LD_EXP 21
12516: PPUSH
12517: LD_STRING DStart-JMM-JMM-1
12519: PPUSH
12520: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
12524: LD_EXP 54
12528: PPUSH
12529: LD_STRING DStart-JMM-Bur-1
12531: PPUSH
12532: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
12536: LD_EXP 21
12540: PPUSH
12541: LD_STRING DStart-JMM-JMM-2
12543: PPUSH
12544: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
12548: LD_EXP 54
12552: PPUSH
12553: LD_STRING DStart-JMM-Bur-2
12555: PPUSH
12556: CALL_OW 88
// InGameOff ;
12560: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
12564: LD_STRING MStart
12566: PPUSH
12567: CALL_OW 337
// SaveForQuickRestart ;
12571: CALL_OW 22
// end ;
12575: LD_VAR 0 1
12579: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
12580: LD_INT 7
12582: PPUSH
12583: LD_INT 255
12585: PPUSH
12586: LD_INT 219
12588: PPUSH
12589: CALL_OW 293
12593: IFFALSE 13204
12595: GO 12597
12597: DISABLE
12598: LD_INT 0
12600: PPUSH
// begin wait ( 0 0$3 ) ;
12601: LD_INT 105
12603: PPUSH
12604: CALL_OW 67
// alienSpotted := true ;
12608: LD_ADDR_EXP 10
12612: PUSH
12613: LD_INT 1
12615: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12616: LD_ADDR_VAR 0 1
12620: PUSH
12621: LD_INT 22
12623: PUSH
12624: LD_INT 7
12626: PUSH
12627: EMPTY
12628: LIST
12629: LIST
12630: PUSH
12631: LD_INT 23
12633: PUSH
12634: LD_INT 3
12636: PUSH
12637: EMPTY
12638: LIST
12639: LIST
12640: PUSH
12641: LD_INT 21
12643: PUSH
12644: LD_INT 1
12646: PUSH
12647: EMPTY
12648: LIST
12649: LIST
12650: PUSH
12651: LD_INT 26
12653: PUSH
12654: LD_INT 1
12656: PUSH
12657: EMPTY
12658: LIST
12659: LIST
12660: PUSH
12661: EMPTY
12662: LIST
12663: LIST
12664: LIST
12665: LIST
12666: PPUSH
12667: CALL_OW 69
12671: PUSH
12672: LD_EXP 54
12676: PUSH
12677: LD_EXP 42
12681: PUSH
12682: LD_EXP 44
12686: PUSH
12687: LD_EXP 45
12691: PUSH
12692: LD_EXP 52
12696: PUSH
12697: LD_EXP 51
12701: PUSH
12702: LD_EXP 46
12706: PUSH
12707: EMPTY
12708: LIST
12709: LIST
12710: LIST
12711: LIST
12712: LIST
12713: LIST
12714: LIST
12715: DIFF
12716: ST_TO_ADDR
// DialogueOn ;
12717: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12721: LD_INT 255
12723: PPUSH
12724: LD_INT 219
12726: PPUSH
12727: LD_INT 7
12729: PPUSH
12730: LD_INT 20
12732: NEG
12733: PPUSH
12734: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12738: LD_INT 255
12740: PPUSH
12741: LD_INT 219
12743: PPUSH
12744: CALL_OW 86
// if speaker then
12748: LD_VAR 0 1
12752: IFFALSE 12770
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12754: LD_VAR 0 1
12758: PUSH
12759: LD_INT 1
12761: ARRAY
12762: PPUSH
12763: LD_STRING DAlienBase-RSol1-1
12765: PPUSH
12766: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12770: LD_EXP 21
12774: PPUSH
12775: LD_STRING DAlienBase-JMM-1
12777: PPUSH
12778: CALL_OW 88
// if IsOk ( Burlak ) then
12782: LD_EXP 54
12786: PPUSH
12787: CALL_OW 302
12791: IFFALSE 12812
// begin dwait ( 0 0$1 ) ;
12793: LD_INT 35
12795: PPUSH
12796: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12800: LD_EXP 54
12804: PPUSH
12805: LD_STRING DAlienBase-Bur-1
12807: PPUSH
12808: CALL_OW 88
// end ; if IsOk ( Roth ) then
12812: LD_EXP 22
12816: PPUSH
12817: CALL_OW 302
12821: IFFALSE 12835
// Say ( Roth , DAlienBase-Roth-1 ) ;
12823: LD_EXP 22
12827: PPUSH
12828: LD_STRING DAlienBase-Roth-1
12830: PPUSH
12831: CALL_OW 88
// if IsOk ( Gossudarov ) then
12835: LD_EXP 40
12839: PPUSH
12840: CALL_OW 302
12844: IFFALSE 12860
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12846: LD_EXP 40
12850: PPUSH
12851: LD_STRING DAlienBase-Gos-1
12853: PPUSH
12854: CALL_OW 88
12858: GO 12977
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12860: LD_ADDR_VAR 0 1
12864: PUSH
12865: LD_INT 22
12867: PUSH
12868: LD_INT 7
12870: PUSH
12871: EMPTY
12872: LIST
12873: LIST
12874: PUSH
12875: LD_INT 25
12877: PUSH
12878: LD_INT 4
12880: PUSH
12881: EMPTY
12882: LIST
12883: LIST
12884: PUSH
12885: LD_INT 21
12887: PUSH
12888: LD_INT 1
12890: PUSH
12891: EMPTY
12892: LIST
12893: LIST
12894: PUSH
12895: LD_INT 26
12897: PUSH
12898: LD_INT 1
12900: PUSH
12901: EMPTY
12902: LIST
12903: LIST
12904: PUSH
12905: EMPTY
12906: LIST
12907: LIST
12908: LIST
12909: LIST
12910: PPUSH
12911: CALL_OW 69
12915: PUSH
12916: LD_EXP 22
12920: PUSH
12921: LD_EXP 21
12925: PUSH
12926: LD_EXP 54
12930: PUSH
12931: LD_EXP 42
12935: PUSH
12936: LD_EXP 52
12940: PUSH
12941: LD_EXP 51
12945: PUSH
12946: EMPTY
12947: LIST
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: LIST
12953: DIFF
12954: ST_TO_ADDR
// if speaker then
12955: LD_VAR 0 1
12959: IFFALSE 12977
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12961: LD_VAR 0 1
12965: PUSH
12966: LD_INT 1
12968: ARRAY
12969: PPUSH
12970: LD_STRING DAlienBase-Sci1-1
12972: PPUSH
12973: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12977: LD_INT 255
12979: PPUSH
12980: LD_INT 219
12982: PPUSH
12983: LD_INT 7
12985: PPUSH
12986: CALL_OW 331
// DialogueOff ;
12990: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12994: LD_INT 35
12996: PPUSH
12997: CALL_OW 67
// until IsSelected ( alien ) ;
13001: LD_INT 1
13003: PPUSH
13004: CALL_OW 306
13008: IFFALSE 12994
// if not artifactIResearched or not artifactIIResearched then
13010: LD_EXP 12
13014: NOT
13015: IFTRUE 13024
13017: PUSH
13018: LD_EXP 13
13022: NOT
13023: OR
13024: IFFALSE 13204
// begin if IsOk ( Roth ) then
13026: LD_EXP 22
13030: PPUSH
13031: CALL_OW 302
13035: IFFALSE 13051
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
13037: LD_EXP 22
13041: PPUSH
13042: LD_STRING DAlieBaseNotReady-Roth-1
13044: PPUSH
13045: CALL_OW 88
13049: GO 13204
// if IsOk ( Gossudarov ) then
13051: LD_EXP 40
13055: PPUSH
13056: CALL_OW 302
13060: IFFALSE 13076
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
13062: LD_EXP 40
13066: PPUSH
13067: LD_STRING DAlieBaseNotReady-Gos-1
13069: PPUSH
13070: CALL_OW 88
13074: GO 13204
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13076: LD_ADDR_VAR 0 1
13080: PUSH
13081: LD_INT 22
13083: PUSH
13084: LD_INT 7
13086: PUSH
13087: EMPTY
13088: LIST
13089: LIST
13090: PUSH
13091: LD_INT 23
13093: PUSH
13094: LD_INT 3
13096: PUSH
13097: EMPTY
13098: LIST
13099: LIST
13100: PUSH
13101: LD_INT 25
13103: PUSH
13104: LD_INT 4
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: PUSH
13111: LD_INT 21
13113: PUSH
13114: LD_INT 1
13116: PUSH
13117: EMPTY
13118: LIST
13119: LIST
13120: PUSH
13121: LD_INT 26
13123: PUSH
13124: LD_INT 1
13126: PUSH
13127: EMPTY
13128: LIST
13129: LIST
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: PPUSH
13138: CALL_OW 69
13142: PUSH
13143: LD_EXP 22
13147: PUSH
13148: LD_EXP 21
13152: PUSH
13153: LD_EXP 54
13157: PUSH
13158: LD_EXP 42
13162: PUSH
13163: LD_EXP 52
13167: PUSH
13168: LD_EXP 51
13172: PUSH
13173: EMPTY
13174: LIST
13175: LIST
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: DIFF
13181: ST_TO_ADDR
// if speaker then
13182: LD_VAR 0 1
13186: IFFALSE 13204
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
13188: LD_VAR 0 1
13192: PUSH
13193: LD_INT 1
13195: ARRAY
13196: PPUSH
13197: LD_STRING DAlieBaseNotReady-RSci1-1
13199: PPUSH
13200: CALL_OW 88
// end ; end ; end ;
13204: PPOPN 1
13206: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
13207: LD_INT 24
13209: PPUSH
13210: LD_INT 7
13212: PPUSH
13213: CALL_OW 321
13217: PUSH
13218: LD_INT 2
13220: EQUAL
13221: IFFALSE 13918
13223: GO 13225
13225: DISABLE
13226: LD_INT 0
13228: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13229: LD_ADDR_VAR 0 1
13233: PUSH
13234: LD_INT 22
13236: PUSH
13237: LD_INT 7
13239: PUSH
13240: EMPTY
13241: LIST
13242: LIST
13243: PUSH
13244: LD_INT 23
13246: PUSH
13247: LD_INT 3
13249: PUSH
13250: EMPTY
13251: LIST
13252: LIST
13253: PUSH
13254: LD_INT 25
13256: PUSH
13257: LD_INT 4
13259: PUSH
13260: EMPTY
13261: LIST
13262: LIST
13263: PUSH
13264: LD_INT 21
13266: PUSH
13267: LD_INT 1
13269: PUSH
13270: EMPTY
13271: LIST
13272: LIST
13273: PUSH
13274: LD_INT 26
13276: PUSH
13277: LD_INT 1
13279: PUSH
13280: EMPTY
13281: LIST
13282: LIST
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: LIST
13288: LIST
13289: LIST
13290: PPUSH
13291: CALL_OW 69
13295: PUSH
13296: LD_EXP 22
13300: PUSH
13301: LD_EXP 21
13305: PUSH
13306: LD_EXP 54
13310: PUSH
13311: LD_EXP 42
13315: PUSH
13316: LD_EXP 52
13320: PUSH
13321: LD_EXP 51
13325: PUSH
13326: EMPTY
13327: LIST
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: LIST
13333: DIFF
13334: ST_TO_ADDR
// if not speaker then
13335: LD_VAR 0 1
13339: NOT
13340: IFFALSE 13344
// exit ;
13342: GO 13918
// DialogueOn ;
13344: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
13348: LD_VAR 0 1
13352: PUSH
13353: LD_INT 1
13355: ARRAY
13356: PPUSH
13357: LD_STRING DArtefTechnology-RSci1-1
13359: PPUSH
13360: CALL_OW 88
// if IsOk ( Burlak ) then
13364: LD_EXP 54
13368: PPUSH
13369: CALL_OW 302
13373: IFFALSE 13387
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
13375: LD_EXP 54
13379: PPUSH
13380: LD_STRING DArtefTechnology-Bur-1
13382: PPUSH
13383: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
13387: LD_VAR 0 1
13391: PUSH
13392: LD_INT 1
13394: ARRAY
13395: PPUSH
13396: LD_STRING DArtefTechnology-RSci1-2
13398: PPUSH
13399: CALL_OW 88
// if Denis then
13403: LD_EXP 27
13407: IFFALSE 13424
// speaker := [ Denis ] else
13409: LD_ADDR_VAR 0 1
13413: PUSH
13414: LD_EXP 27
13418: PUSH
13419: EMPTY
13420: LIST
13421: ST_TO_ADDR
13422: GO 13530
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13424: LD_ADDR_VAR 0 1
13428: PUSH
13429: LD_INT 22
13431: PUSH
13432: LD_INT 7
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PUSH
13439: LD_INT 23
13441: PUSH
13442: LD_INT 1
13444: PUSH
13445: EMPTY
13446: LIST
13447: LIST
13448: PUSH
13449: LD_INT 25
13451: PUSH
13452: LD_INT 4
13454: PUSH
13455: EMPTY
13456: LIST
13457: LIST
13458: PUSH
13459: LD_INT 21
13461: PUSH
13462: LD_INT 1
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: PUSH
13469: LD_INT 26
13471: PUSH
13472: LD_INT 1
13474: PUSH
13475: EMPTY
13476: LIST
13477: LIST
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: LIST
13483: LIST
13484: LIST
13485: PPUSH
13486: CALL_OW 69
13490: PUSH
13491: LD_EXP 22
13495: PUSH
13496: LD_EXP 21
13500: PUSH
13501: LD_EXP 54
13505: PUSH
13506: LD_EXP 42
13510: PUSH
13511: LD_EXP 52
13515: PUSH
13516: LD_EXP 51
13520: PUSH
13521: EMPTY
13522: LIST
13523: LIST
13524: LIST
13525: LIST
13526: LIST
13527: LIST
13528: DIFF
13529: ST_TO_ADDR
// if speaker then
13530: LD_VAR 0 1
13534: IFFALSE 13552
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
13536: LD_VAR 0 1
13540: PUSH
13541: LD_INT 1
13543: ARRAY
13544: PPUSH
13545: LD_STRING DArtefTechnology-Sci1-2
13547: PPUSH
13548: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13552: LD_ADDR_VAR 0 1
13556: PUSH
13557: LD_INT 22
13559: PUSH
13560: LD_INT 7
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 23
13569: PUSH
13570: LD_INT 3
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: PUSH
13577: LD_INT 25
13579: PUSH
13580: LD_INT 4
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: PUSH
13587: LD_INT 21
13589: PUSH
13590: LD_INT 1
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PUSH
13597: LD_INT 26
13599: PUSH
13600: LD_INT 1
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 69
13618: PUSH
13619: LD_EXP 22
13623: PUSH
13624: LD_EXP 21
13628: PUSH
13629: LD_EXP 54
13633: PUSH
13634: LD_EXP 42
13638: PUSH
13639: LD_EXP 52
13643: PUSH
13644: LD_EXP 51
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: LIST
13653: LIST
13654: LIST
13655: LIST
13656: DIFF
13657: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13658: LD_VAR 0 1
13662: IFFALSE 13678
13664: PUSH
13665: LD_EXP 9
13669: IFTRUE 13677
13671: PUSH
13672: LD_EXP 5
13676: OR
13677: AND
13678: IFFALSE 13914
// begin if arabianDestroyed and IsOk ( Burlak ) then
13680: LD_EXP 5
13684: IFFALSE 13697
13686: PUSH
13687: LD_EXP 54
13691: PPUSH
13692: CALL_OW 302
13696: AND
13697: IFFALSE 13713
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13699: LD_EXP 54
13703: PPUSH
13704: LD_STRING DArtefTechnology-Bur-2
13706: PPUSH
13707: CALL_OW 88
13711: GO 13725
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13713: LD_EXP 21
13717: PPUSH
13718: LD_STRING DArtefTechnology-JMM-2
13720: PPUSH
13721: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13725: LD_VAR 0 1
13729: PUSH
13730: LD_INT 1
13732: ARRAY
13733: PPUSH
13734: LD_STRING DArtefTechnology-RSci1-3
13736: PPUSH
13737: CALL_OW 88
// if Denis then
13741: LD_EXP 27
13745: IFFALSE 13762
// speaker := [ Denis ] else
13747: LD_ADDR_VAR 0 1
13751: PUSH
13752: LD_EXP 27
13756: PUSH
13757: EMPTY
13758: LIST
13759: ST_TO_ADDR
13760: GO 13868
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13762: LD_ADDR_VAR 0 1
13766: PUSH
13767: LD_INT 22
13769: PUSH
13770: LD_INT 7
13772: PUSH
13773: EMPTY
13774: LIST
13775: LIST
13776: PUSH
13777: LD_INT 23
13779: PUSH
13780: LD_INT 1
13782: PUSH
13783: EMPTY
13784: LIST
13785: LIST
13786: PUSH
13787: LD_INT 25
13789: PUSH
13790: LD_INT 4
13792: PUSH
13793: EMPTY
13794: LIST
13795: LIST
13796: PUSH
13797: LD_INT 21
13799: PUSH
13800: LD_INT 1
13802: PUSH
13803: EMPTY
13804: LIST
13805: LIST
13806: PUSH
13807: LD_INT 26
13809: PUSH
13810: LD_INT 1
13812: PUSH
13813: EMPTY
13814: LIST
13815: LIST
13816: PUSH
13817: EMPTY
13818: LIST
13819: LIST
13820: LIST
13821: LIST
13822: LIST
13823: PPUSH
13824: CALL_OW 69
13828: PUSH
13829: LD_EXP 22
13833: PUSH
13834: LD_EXP 21
13838: PUSH
13839: LD_EXP 54
13843: PUSH
13844: LD_EXP 42
13848: PUSH
13849: LD_EXP 52
13853: PUSH
13854: LD_EXP 51
13858: PUSH
13859: EMPTY
13860: LIST
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: LIST
13866: DIFF
13867: ST_TO_ADDR
// if speaker then
13868: LD_VAR 0 1
13872: IFFALSE 13914
// if alienSpotted then
13874: LD_EXP 10
13878: IFFALSE 13898
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13880: LD_VAR 0 1
13884: PUSH
13885: LD_INT 1
13887: ARRAY
13888: PPUSH
13889: LD_STRING DArtefTechnology-Sci1-3
13891: PPUSH
13892: CALL_OW 88
13896: GO 13914
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13898: LD_VAR 0 1
13902: PUSH
13903: LD_INT 1
13905: ARRAY
13906: PPUSH
13907: LD_STRING DArtefTechnology-Sci1-3a
13909: PPUSH
13910: CALL_OW 88
// end ; DialogueOff ;
13914: CALL_OW 7
// end ;
13918: PPOPN 1
13920: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13921: LD_EXP 12
13925: IFFALSE 14128
13927: GO 13929
13929: DISABLE
13930: LD_INT 0
13932: PPUSH
// begin if Denis then
13933: LD_EXP 27
13937: IFFALSE 13954
// speaker := [ Denis ] else
13939: LD_ADDR_VAR 0 1
13943: PUSH
13944: LD_EXP 27
13948: PUSH
13949: EMPTY
13950: LIST
13951: ST_TO_ADDR
13952: GO 14060
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13954: LD_ADDR_VAR 0 1
13958: PUSH
13959: LD_INT 22
13961: PUSH
13962: LD_INT 7
13964: PUSH
13965: EMPTY
13966: LIST
13967: LIST
13968: PUSH
13969: LD_INT 23
13971: PUSH
13972: LD_INT 1
13974: PUSH
13975: EMPTY
13976: LIST
13977: LIST
13978: PUSH
13979: LD_INT 25
13981: PUSH
13982: LD_INT 4
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: PUSH
13989: LD_INT 21
13991: PUSH
13992: LD_INT 1
13994: PUSH
13995: EMPTY
13996: LIST
13997: LIST
13998: PUSH
13999: LD_INT 26
14001: PUSH
14002: LD_INT 1
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: LIST
14013: LIST
14014: LIST
14015: PPUSH
14016: CALL_OW 69
14020: PUSH
14021: LD_EXP 22
14025: PUSH
14026: LD_EXP 21
14030: PUSH
14031: LD_EXP 54
14035: PUSH
14036: LD_EXP 42
14040: PUSH
14041: LD_EXP 52
14045: PUSH
14046: LD_EXP 51
14050: PUSH
14051: EMPTY
14052: LIST
14053: LIST
14054: LIST
14055: LIST
14056: LIST
14057: LIST
14058: DIFF
14059: ST_TO_ADDR
// if not speaker then
14060: LD_VAR 0 1
14064: NOT
14065: IFFALSE 14069
// exit ;
14067: GO 14128
// DialogueOn ;
14069: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
14073: LD_VAR 0 1
14077: PUSH
14078: LD_INT 1
14080: ARRAY
14081: PPUSH
14082: LD_STRING DArtefTechnologyAm-Sci1-1
14084: PPUSH
14085: CALL_OW 88
// if IsOk ( Burlak ) then
14089: LD_EXP 54
14093: PPUSH
14094: CALL_OW 302
14098: IFFALSE 14112
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
14100: LD_EXP 54
14104: PPUSH
14105: LD_STRING DArtefTechnologyAm-Bur-1
14107: PPUSH
14108: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
14112: LD_EXP 21
14116: PPUSH
14117: LD_STRING DArtefTechnologyAm-JMM-1
14119: PPUSH
14120: CALL_OW 88
// DialogueOff ;
14124: CALL_OW 7
// end ;
14128: PPOPN 1
14130: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
14131: LD_EXP 13
14135: IFFALSE 14337
14137: GO 14139
14139: DISABLE
14140: LD_INT 0
14142: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14143: LD_ADDR_VAR 0 1
14147: PUSH
14148: LD_INT 22
14150: PUSH
14151: LD_INT 7
14153: PUSH
14154: EMPTY
14155: LIST
14156: LIST
14157: PUSH
14158: LD_INT 23
14160: PUSH
14161: LD_INT 3
14163: PUSH
14164: EMPTY
14165: LIST
14166: LIST
14167: PUSH
14168: LD_INT 25
14170: PUSH
14171: LD_INT 4
14173: PUSH
14174: EMPTY
14175: LIST
14176: LIST
14177: PUSH
14178: LD_INT 21
14180: PUSH
14181: LD_INT 1
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_INT 26
14190: PUSH
14191: LD_INT 1
14193: PUSH
14194: EMPTY
14195: LIST
14196: LIST
14197: PUSH
14198: EMPTY
14199: LIST
14200: LIST
14201: LIST
14202: LIST
14203: LIST
14204: PPUSH
14205: CALL_OW 69
14209: PUSH
14210: LD_EXP 22
14214: PUSH
14215: LD_EXP 21
14219: PUSH
14220: LD_EXP 54
14224: PUSH
14225: LD_EXP 42
14229: PUSH
14230: LD_EXP 52
14234: PUSH
14235: LD_EXP 51
14239: PUSH
14240: EMPTY
14241: LIST
14242: LIST
14243: LIST
14244: LIST
14245: LIST
14246: LIST
14247: DIFF
14248: ST_TO_ADDR
// if not speaker then
14249: LD_VAR 0 1
14253: NOT
14254: IFFALSE 14258
// exit ;
14256: GO 14337
// DialogueOn ;
14258: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
14262: LD_VAR 0 1
14266: PUSH
14267: LD_VAR 0 1
14271: ARRAY
14272: PPUSH
14273: LD_STRING DArtefTechnologyRu-RSci1-1
14275: PPUSH
14276: CALL_OW 88
// if IsOk ( Burlak ) then
14280: LD_EXP 54
14284: PPUSH
14285: CALL_OW 302
14289: IFFALSE 14303
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
14291: LD_EXP 54
14295: PPUSH
14296: LD_STRING DArtefTechnologyRu-Bur-1
14298: PPUSH
14299: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
14303: LD_VAR 0 1
14307: PUSH
14308: LD_VAR 0 1
14312: ARRAY
14313: PPUSH
14314: LD_STRING DArtefTechnologyRu-RSci1-2
14316: PPUSH
14317: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
14321: LD_EXP 21
14325: PPUSH
14326: LD_STRING DArtefTechnologyRu-JMM-1
14328: PPUSH
14329: CALL_OW 88
// DialogueOff ;
14333: CALL_OW 7
// end ;
14337: PPOPN 1
14339: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
14340: LD_INT 24
14342: PPUSH
14343: LD_INT 7
14345: PPUSH
14346: CALL_OW 321
14350: PUSH
14351: LD_INT 2
14353: EQUAL
14354: IFFALSE 14369
14356: PUSH
14357: LD_INT 1
14359: PPUSH
14360: CALL_OW 255
14364: PUSH
14365: LD_INT 7
14367: EQUAL
14368: AND
14369: IFFALSE 14537
14371: GO 14373
14373: DISABLE
14374: LD_INT 0
14376: PPUSH
// begin if Denis then
14377: LD_EXP 27
14381: IFFALSE 14398
// speaker := [ Denis ] else
14383: LD_ADDR_VAR 0 1
14387: PUSH
14388: LD_EXP 27
14392: PUSH
14393: EMPTY
14394: LIST
14395: ST_TO_ADDR
14396: GO 14504
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14398: LD_ADDR_VAR 0 1
14402: PUSH
14403: LD_INT 22
14405: PUSH
14406: LD_INT 7
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: PUSH
14413: LD_INT 23
14415: PUSH
14416: LD_INT 1
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: PUSH
14423: LD_INT 25
14425: PUSH
14426: LD_INT 4
14428: PUSH
14429: EMPTY
14430: LIST
14431: LIST
14432: PUSH
14433: LD_INT 21
14435: PUSH
14436: LD_INT 1
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: PUSH
14443: LD_INT 26
14445: PUSH
14446: LD_INT 1
14448: PUSH
14449: EMPTY
14450: LIST
14451: LIST
14452: PUSH
14453: EMPTY
14454: LIST
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: PPUSH
14460: CALL_OW 69
14464: PUSH
14465: LD_EXP 22
14469: PUSH
14470: LD_EXP 21
14474: PUSH
14475: LD_EXP 54
14479: PUSH
14480: LD_EXP 42
14484: PUSH
14485: LD_EXP 52
14489: PUSH
14490: LD_EXP 51
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: LIST
14501: LIST
14502: DIFF
14503: ST_TO_ADDR
// if not speaker then
14504: LD_VAR 0 1
14508: NOT
14509: IFFALSE 14513
// exit ;
14511: GO 14537
// DialogueOn ;
14513: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
14517: LD_VAR 0 1
14521: PUSH
14522: LD_INT 1
14524: ARRAY
14525: PPUSH
14526: LD_STRING DArtefTechnologyArStart-Sci1-1
14528: PPUSH
14529: CALL_OW 88
// DialogueOff ;
14533: CALL_OW 7
// end ;
14537: PPOPN 1
14539: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
14540: LD_EXP 14
14544: IFFALSE 14825
14546: GO 14548
14548: DISABLE
14549: LD_INT 0
14551: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14552: LD_ADDR_VAR 0 1
14556: PUSH
14557: LD_INT 22
14559: PUSH
14560: LD_INT 7
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PUSH
14567: LD_INT 23
14569: PUSH
14570: LD_INT 3
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PUSH
14577: LD_INT 25
14579: PUSH
14580: LD_INT 4
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 1
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: LD_INT 26
14599: PUSH
14600: LD_INT 1
14602: PUSH
14603: EMPTY
14604: LIST
14605: LIST
14606: PUSH
14607: EMPTY
14608: LIST
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: PPUSH
14614: CALL_OW 69
14618: PUSH
14619: LD_EXP 22
14623: PUSH
14624: LD_EXP 21
14628: PUSH
14629: LD_EXP 54
14633: PUSH
14634: LD_EXP 42
14638: PUSH
14639: LD_EXP 52
14643: PUSH
14644: LD_EXP 51
14648: PUSH
14649: EMPTY
14650: LIST
14651: LIST
14652: LIST
14653: LIST
14654: LIST
14655: LIST
14656: DIFF
14657: ST_TO_ADDR
// if not speaker then
14658: LD_VAR 0 1
14662: NOT
14663: IFFALSE 14667
// exit ;
14665: GO 14825
// DialogueOn ;
14667: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14671: LD_VAR 0 1
14675: PUSH
14676: LD_INT 1
14678: ARRAY
14679: PPUSH
14680: LD_STRING DArtefTechnologyAr-RSci1-1
14682: PPUSH
14683: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14687: LD_EXP 21
14691: PPUSH
14692: LD_STRING DArtefTechnologyAr-JMM-1
14694: PPUSH
14695: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14699: LD_VAR 0 1
14703: PUSH
14704: LD_INT 1
14706: ARRAY
14707: PPUSH
14708: LD_STRING DArtefTechnologyAr-RSci1-2
14710: PPUSH
14711: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14715: LD_EXP 21
14719: PPUSH
14720: LD_STRING DArtefTechnologyAr-JMM-2
14722: PPUSH
14723: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14727: LD_VAR 0 1
14731: PUSH
14732: LD_INT 1
14734: ARRAY
14735: PPUSH
14736: LD_STRING DArtefTechnologyAr-RSci1-3
14738: PPUSH
14739: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14743: LD_EXP 21
14747: PPUSH
14748: LD_STRING DArtefTechnologyAr-JMM-3
14750: PPUSH
14751: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14755: LD_VAR 0 1
14759: PUSH
14760: LD_INT 1
14762: ARRAY
14763: PPUSH
14764: LD_STRING DArtefTechnologyAr-RSci1-4
14766: PPUSH
14767: CALL_OW 88
// if IsOk ( Burlak ) then
14771: LD_EXP 54
14775: PPUSH
14776: CALL_OW 302
14780: IFFALSE 14794
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14782: LD_EXP 54
14786: PPUSH
14787: LD_STRING DArtefTechnologyAr-Bur-4
14789: PPUSH
14790: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14794: LD_EXP 21
14798: PPUSH
14799: LD_STRING DArtefTechnologyAr-JMM-4
14801: PPUSH
14802: CALL_OW 88
// DialogueOff ;
14806: CALL_OW 7
// wait ( 0 0$45 ) ;
14810: LD_INT 1575
14812: PPUSH
14813: CALL_OW 67
// spawnOmar := true ;
14817: LD_ADDR_EXP 11
14821: PUSH
14822: LD_INT 1
14824: ST_TO_ADDR
// end ;
14825: PPOPN 1
14827: END
// every 0 0$1 trigger spawnOmar and negotiationWithArabs do
14828: LD_EXP 11
14832: IFFALSE 14840
14834: PUSH
14835: LD_EXP 19
14839: AND
14840: IFFALSE 15277
14842: GO 14844
14844: DISABLE
// begin PrepareOmarAli ;
14845: CALL 7612 0 0
// if not HasTask ( Omar ) then
14849: LD_EXP 58
14853: PPUSH
14854: CALL_OW 314
14858: NOT
14859: IFFALSE 14876
// ComMoveXY ( Omar , 252 , 220 ) ;
14861: LD_EXP 58
14865: PPUSH
14866: LD_INT 252
14868: PPUSH
14869: LD_INT 220
14871: PPUSH
14872: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14876: LD_INT 35
14878: PPUSH
14879: CALL_OW 67
// if omarKilled then
14883: LD_EXP 20
14887: IFFALSE 14891
// exit ;
14889: GO 15277
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14891: LD_EXP 58
14895: PPUSH
14896: CALL_OW 314
14900: NOT
14901: IFFALSE 14924
14903: PUSH
14904: LD_EXP 58
14908: PPUSH
14909: LD_INT 252
14911: PPUSH
14912: LD_INT 220
14914: PPUSH
14915: CALL_OW 297
14919: PUSH
14920: LD_INT 6
14922: GREATER
14923: AND
14924: IFFALSE 14941
// ComMoveXY ( Omar , 252 , 220 ) ;
14926: LD_EXP 58
14930: PPUSH
14931: LD_INT 252
14933: PPUSH
14934: LD_INT 220
14936: PPUSH
14937: CALL_OW 111
// until See ( 7 , Omar ) ;
14941: LD_INT 7
14943: PPUSH
14944: LD_EXP 58
14948: PPUSH
14949: CALL_OW 292
14953: IFFALSE 14876
// CenterNowOnUnits ( Omar ) ;
14955: LD_EXP 58
14959: PPUSH
14960: CALL_OW 87
// DialogueOn ;
14964: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14968: LD_EXP 58
14972: PPUSH
14973: LD_STRING DOmar-Omar-1
14975: PPUSH
14976: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14980: LD_EXP 21
14984: PPUSH
14985: LD_STRING DOmar-JMM-1
14987: PPUSH
14988: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14992: LD_EXP 58
14996: PPUSH
14997: LD_STRING DOmar-Omar-2
14999: PPUSH
15000: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
15004: LD_EXP 21
15008: PPUSH
15009: LD_STRING DOmar-JMM-2
15011: PPUSH
15012: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
15016: LD_EXP 58
15020: PPUSH
15021: LD_STRING DOmar-Omar-3
15023: PPUSH
15024: CALL_OW 88
// if IsOk ( Burlak ) then
15028: LD_EXP 54
15032: PPUSH
15033: CALL_OW 302
15037: IFFALSE 15053
// Say ( Burlak , DOmar-Bur-3 ) else
15039: LD_EXP 54
15043: PPUSH
15044: LD_STRING DOmar-Bur-3
15046: PPUSH
15047: CALL_OW 88
15051: GO 15065
// Say ( JMM , DOmar-JMM-3 ) ;
15053: LD_EXP 21
15057: PPUSH
15058: LD_STRING DOmar-JMM-3
15060: PPUSH
15061: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
15065: LD_EXP 58
15069: PPUSH
15070: LD_STRING DOmar-Omar-4
15072: PPUSH
15073: CALL_OW 88
// case Query ( QAccept ) of 1 :
15077: LD_STRING QAccept
15079: PPUSH
15080: CALL_OW 97
15084: PUSH
15085: LD_INT 1
15087: DOUBLE
15088: EQUAL
15089: IFTRUE 15093
15091: GO 15129
15093: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
15094: LD_EXP 21
15098: PPUSH
15099: LD_STRING DQrAccept#1-JMM-1
15101: PPUSH
15102: CALL_OW 88
// SetSide ( Omar , 7 ) ;
15106: LD_EXP 58
15110: PPUSH
15111: LD_INT 7
15113: PPUSH
15114: CALL_OW 235
// ComStop ( Omar ) ;
15118: LD_EXP 58
15122: PPUSH
15123: CALL_OW 141
// end ; 2 :
15127: GO 15178
15129: LD_INT 2
15131: DOUBLE
15132: EQUAL
15133: IFTRUE 15137
15135: GO 15177
15137: POP
// begin if IsOk ( Burlak ) then
15138: LD_EXP 54
15142: PPUSH
15143: CALL_OW 302
15147: IFFALSE 15163
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
15149: LD_EXP 54
15153: PPUSH
15154: LD_STRING DQrAccept#2-Bur-1
15156: PPUSH
15157: CALL_OW 88
15161: GO 15175
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
15163: LD_EXP 21
15167: PPUSH
15168: LD_STRING DQrAccept#2-JMM-1
15170: PPUSH
15171: CALL_OW 88
// end ; end ;
15175: GO 15178
15177: POP
// DialogueOff ;
15178: CALL_OW 7
// if GetSide ( Omar ) = 7 then
15182: LD_EXP 58
15186: PPUSH
15187: CALL_OW 255
15191: PUSH
15192: LD_INT 7
15194: EQUAL
15195: IFFALSE 15206
// begin SetAchievement ( ACH_OMAR ) ;
15197: LD_STRING ACH_OMAR
15199: PPUSH
15200: CALL_OW 543
// exit ;
15204: GO 15277
// end ; ComMoveXY ( Omar , 219 , 161 ) ;
15206: LD_EXP 58
15210: PPUSH
15211: LD_INT 219
15213: PPUSH
15214: LD_INT 161
15216: PPUSH
15217: CALL_OW 111
// AddComMoveXY ( Omar , 186 , 113 ) ;
15221: LD_EXP 58
15225: PPUSH
15226: LD_INT 186
15228: PPUSH
15229: LD_INT 113
15231: PPUSH
15232: CALL_OW 171
// wait ( 0 0$2 ) ;
15236: LD_INT 70
15238: PPUSH
15239: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15243: LD_INT 35
15245: PPUSH
15246: CALL_OW 67
// ComMoveXY ( Omar , 186 , 113 ) ;
15250: LD_EXP 58
15254: PPUSH
15255: LD_INT 186
15257: PPUSH
15258: LD_INT 113
15260: PPUSH
15261: CALL_OW 111
// until not HasTask ( Omar ) ;
15265: LD_EXP 58
15269: PPUSH
15270: CALL_OW 314
15274: NOT
15275: IFFALSE 15243
// end ;
15277: END
// every 0 0$1 trigger not omarKilled and russianCapitulated and ( ( IsOk ( Omar ) and GetSide ( Omar ) = 7 ) or not negotiationWithArabs ) do var i ;
15278: LD_EXP 20
15282: NOT
15283: IFFALSE 15291
15285: PUSH
15286: LD_EXP 7
15290: AND
15291: IFFALSE 15330
15293: PUSH
15294: LD_EXP 58
15298: PPUSH
15299: CALL_OW 302
15303: IFFALSE 15320
15305: PUSH
15306: LD_EXP 58
15310: PPUSH
15311: CALL_OW 255
15315: PUSH
15316: LD_INT 7
15318: EQUAL
15319: AND
15320: IFTRUE 15329
15322: PUSH
15323: LD_EXP 19
15327: NOT
15328: OR
15329: AND
15330: IFFALSE 15905
15332: GO 15334
15334: DISABLE
15335: LD_INT 0
15337: PPUSH
// begin if not negotiationWithArabs and not omarKilled then
15338: LD_EXP 19
15342: NOT
15343: IFFALSE 15352
15345: PUSH
15346: LD_EXP 20
15350: NOT
15351: AND
15352: IFFALSE 15358
// PrepareOmarAli2 ;
15354: CALL 7682 0 0
// wait ( 0 0$2 ) ;
15358: LD_INT 70
15360: PPUSH
15361: CALL_OW 67
// SetSide ( Omar , 5 ) ;
15365: LD_EXP 58
15369: PPUSH
15370: LD_INT 5
15372: PPUSH
15373: CALL_OW 235
// if IsInUnit ( Omar ) then
15377: LD_EXP 58
15381: PPUSH
15382: CALL_OW 310
15386: IFFALSE 15397
// ComExitVehicle ( Omar ) ;
15388: LD_EXP 58
15392: PPUSH
15393: CALL_OW 121
// if IsInUnit ( Omar ) then
15397: LD_EXP 58
15401: PPUSH
15402: CALL_OW 310
15406: IFFALSE 15417
// ComExitBuilding ( Omar ) ;
15408: LD_EXP 58
15412: PPUSH
15413: CALL_OW 122
// wait ( 0 0$1 ) ;
15417: LD_INT 35
15419: PPUSH
15420: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15424: LD_EXP 58
15428: PPUSH
15429: LD_INT 203
15431: PPUSH
15432: LD_INT 120
15434: PPUSH
15435: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
15439: LD_INT 35
15441: PPUSH
15442: CALL_OW 67
// if omarKilled then
15446: LD_EXP 20
15450: IFFALSE 15454
// exit ;
15452: GO 15905
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
15454: LD_EXP 58
15458: PPUSH
15459: CALL_OW 306
15463: IFTRUE 15486
15465: PUSH
15466: LD_EXP 58
15470: PPUSH
15471: LD_INT 203
15473: PPUSH
15474: LD_INT 120
15476: PPUSH
15477: CALL_OW 297
15481: PUSH
15482: LD_INT 20
15484: LESS
15485: OR
15486: IFFALSE 15439
// DialogueOn ;
15488: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
15492: LD_EXP 58
15496: PPUSH
15497: CALL_OW 250
15501: PPUSH
15502: LD_EXP 58
15506: PPUSH
15507: CALL_OW 251
15511: PPUSH
15512: LD_INT 7
15514: PPUSH
15515: LD_INT 6
15517: NEG
15518: PPUSH
15519: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
15523: LD_EXP 58
15527: PPUSH
15528: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
15532: LD_EXP 21
15536: PPUSH
15537: LD_STRING DOmarContam-JMM-1
15539: PPUSH
15540: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
15544: LD_EXP 58
15548: PPUSH
15549: LD_STRING DOmarContam-Omar-1
15551: PPUSH
15552: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
15556: LD_EXP 21
15560: PPUSH
15561: LD_STRING DOmarContam-JMM-2
15563: PPUSH
15564: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
15568: LD_EXP 58
15572: PPUSH
15573: CALL_OW 250
15577: PPUSH
15578: LD_EXP 58
15582: PPUSH
15583: CALL_OW 251
15587: PPUSH
15588: LD_INT 7
15590: PPUSH
15591: CALL_OW 331
// DialogueOff ;
15595: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
15599: LD_INT 5
15601: PPUSH
15602: LD_INT 7
15604: PPUSH
15605: LD_INT 2
15607: PPUSH
15608: LD_INT 1
15610: PPUSH
15611: CALL_OW 80
// repeat wait ( 0 0$2 ) ;
15615: LD_INT 70
15617: PPUSH
15618: CALL_OW 67
// if not HexInfo ( 203 , 120 ) then
15622: LD_INT 203
15624: PPUSH
15625: LD_INT 120
15627: PPUSH
15628: CALL_OW 428
15632: NOT
15633: IFFALSE 15652
// ComMoveXY ( Omar , 203 , 120 ) else
15635: LD_EXP 58
15639: PPUSH
15640: LD_INT 203
15642: PPUSH
15643: LD_INT 120
15645: PPUSH
15646: CALL_OW 111
15650: GO 15667
// ComMoveXY ( Omar , 188 , 115 ) ;
15652: LD_EXP 58
15656: PPUSH
15657: LD_INT 188
15659: PPUSH
15660: LD_INT 115
15662: PPUSH
15663: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) or GetDistUnitXY ( Omar , 188 , 115 ) < 5 ;
15667: LD_EXP 58
15671: PPUSH
15672: LD_INT 203
15674: PPUSH
15675: LD_INT 120
15677: PPUSH
15678: CALL_OW 307
15682: IFTRUE 15705
15684: PUSH
15685: LD_EXP 58
15689: PPUSH
15690: LD_INT 188
15692: PPUSH
15693: LD_INT 115
15695: PPUSH
15696: CALL_OW 297
15700: PUSH
15701: LD_INT 5
15703: LESS
15704: OR
15705: IFFALSE 15615
// ComHold ( Omar ) ;
15707: LD_EXP 58
15711: PPUSH
15712: CALL_OW 140
// InGameOn ;
15716: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
15720: LD_INT 203
15722: PPUSH
15723: LD_INT 120
15725: PPUSH
15726: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
15730: LD_INT 203
15732: PPUSH
15733: LD_INT 120
15735: PPUSH
15736: LD_INT 7
15738: PPUSH
15739: LD_INT 30
15741: NEG
15742: PPUSH
15743: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
15747: LD_ADDR_VAR 0 1
15751: PUSH
15752: LD_INT 203
15754: PUSH
15755: LD_INT 120
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 202
15764: PUSH
15765: LD_INT 125
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: LD_INT 195
15774: PUSH
15775: LD_INT 117
15777: PUSH
15778: EMPTY
15779: LIST
15780: LIST
15781: PUSH
15782: LD_INT 216
15784: PUSH
15785: LD_INT 123
15787: PUSH
15788: EMPTY
15789: LIST
15790: LIST
15791: PUSH
15792: LD_INT 224
15794: PUSH
15795: LD_INT 131
15797: PUSH
15798: EMPTY
15799: LIST
15800: LIST
15801: PUSH
15802: LD_INT 212
15804: PUSH
15805: LD_INT 133
15807: PUSH
15808: EMPTY
15809: LIST
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: LIST
15816: LIST
15817: LIST
15818: LIST
15819: PUSH
15820: FOR_IN
15821: IFFALSE 15857
// begin wait ( 0 0$0.5 ) ;
15823: LD_INT 18
15825: PPUSH
15826: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15830: LD_VAR 0 1
15834: PUSH
15835: LD_INT 1
15837: ARRAY
15838: PPUSH
15839: LD_VAR 0 1
15843: PUSH
15844: LD_INT 2
15846: ARRAY
15847: PPUSH
15848: LD_INT 5
15850: PPUSH
15851: CALL_OW 495
// end ;
15855: GO 15820
15857: POP
15858: POP
// KillUnit ( Omar ) ;
15859: LD_EXP 58
15863: PPUSH
15864: CALL_OW 66
// wait ( 0 0$3 ) ;
15868: LD_INT 105
15870: PPUSH
15871: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15875: LD_EXP 21
15879: PPUSH
15880: LD_STRING D16b-JMM-1
15882: PPUSH
15883: CALL_OW 91
// wait ( 0 0$2 ) ;
15887: LD_INT 70
15889: PPUSH
15890: CALL_OW 67
// InGameOff ;
15894: CALL_OW 9
// YouLost ( MothContaminate ) ;
15898: LD_STRING MothContaminate
15900: PPUSH
15901: CALL_OW 104
// end ;
15905: PPOPN 1
15907: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15908: LD_EXP 4
15912: NOT
15913: IFFALSE 15945
15915: PUSH
15916: LD_INT 22
15918: PUSH
15919: LD_INT 1
15921: PUSH
15922: EMPTY
15923: LIST
15924: LIST
15925: PUSH
15926: LD_INT 34
15928: PUSH
15929: LD_INT 8
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: PUSH
15936: EMPTY
15937: LIST
15938: LIST
15939: PPUSH
15940: CALL_OW 69
15944: AND
15945: IFFALSE 16066
15947: GO 15949
15949: DISABLE
// begin wait ( 0 0$10 ) ;
15950: LD_INT 350
15952: PPUSH
15953: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15957: LD_EXP 57
15961: PPUSH
15962: CALL_OW 302
15966: NOT
15967: IFTRUE 16000
15969: PUSH
15970: LD_INT 22
15972: PUSH
15973: LD_INT 1
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: PUSH
15980: LD_INT 34
15982: PUSH
15983: LD_INT 8
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PPUSH
15994: CALL_OW 69
15998: NOT
15999: OR
16000: IFFALSE 16004
// exit ;
16002: GO 16066
// DialogueOn ;
16004: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
16008: LD_EXP 57
16012: PPUSH
16013: LD_STRING DWinAmericans-Pow-1
16015: PPUSH
16016: CALL_OW 94
// if IsOk ( Burlak ) then
16020: LD_EXP 54
16024: PPUSH
16025: CALL_OW 302
16029: IFFALSE 16043
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
16031: LD_EXP 54
16035: PPUSH
16036: LD_STRING DWinAmericans-Bur-1
16038: PPUSH
16039: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
16043: LD_EXP 21
16047: PPUSH
16048: LD_STRING DWinAmericans-JMM-1
16050: PPUSH
16051: CALL_OW 88
// DialogueOff ;
16055: CALL_OW 7
// YouLost ( AmBomb ) ;
16059: LD_STRING AmBomb
16061: PPUSH
16062: CALL_OW 104
// end ;
16066: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
16067: LD_EXP 2
16071: NOT
16072: IFFALSE 16104
16074: PUSH
16075: LD_INT 22
16077: PUSH
16078: LD_INT 3
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PUSH
16085: LD_INT 34
16087: PUSH
16088: LD_INT 48
16090: PUSH
16091: EMPTY
16092: LIST
16093: LIST
16094: PUSH
16095: EMPTY
16096: LIST
16097: LIST
16098: PPUSH
16099: CALL_OW 69
16103: AND
16104: IFFALSE 16225
16106: GO 16108
16108: DISABLE
// begin wait ( 0 0$10 ) ;
16109: LD_INT 350
16111: PPUSH
16112: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
16116: LD_EXP 62
16120: PPUSH
16121: CALL_OW 302
16125: NOT
16126: IFTRUE 16159
16128: PUSH
16129: LD_INT 22
16131: PUSH
16132: LD_INT 3
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: LD_INT 34
16141: PUSH
16142: LD_INT 48
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: PPUSH
16153: CALL_OW 69
16157: NOT
16158: OR
16159: IFFALSE 16163
// exit ;
16161: GO 16225
// DialogueOn ;
16163: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
16167: LD_EXP 62
16171: PPUSH
16172: LD_STRING DWinRussians-Pla-1
16174: PPUSH
16175: CALL_OW 94
// if IsOk ( Burlak ) then
16179: LD_EXP 54
16183: PPUSH
16184: CALL_OW 302
16188: IFFALSE 16202
// Say ( Burlak , DWinRussians-Bur-1 ) ;
16190: LD_EXP 54
16194: PPUSH
16195: LD_STRING DWinRussians-Bur-1
16197: PPUSH
16198: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
16202: LD_EXP 21
16206: PPUSH
16207: LD_STRING DWinRussians-JMM-1
16209: PPUSH
16210: CALL_OW 88
// DialogueOff ;
16214: CALL_OW 7
// YouLost ( RuBomb ) ;
16218: LD_STRING RuBomb
16220: PPUSH
16221: CALL_OW 104
// end ;
16225: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
16226: LD_INT 7
16228: PPUSH
16229: LD_INT 22
16231: PUSH
16232: LD_INT 7
16234: PUSH
16235: EMPTY
16236: LIST
16237: LIST
16238: PPUSH
16239: CALL_OW 70
16243: IFFALSE 16252
16245: PUSH
16246: LD_EXP 4
16250: NOT
16251: AND
16252: IFFALSE 16281
16254: GO 16256
16256: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
16257: LD_EXP 57
16261: PPUSH
16262: LD_STRING DSurrenderAmericans-Pow-1
16264: PPUSH
16265: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
16269: LD_EXP 21
16273: PPUSH
16274: LD_STRING DSurrenderAmericans-JMM-1
16276: PPUSH
16277: CALL_OW 88
// end ;
16281: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
16282: LD_INT 2
16284: PPUSH
16285: LD_INT 22
16287: PUSH
16288: LD_INT 7
16290: PUSH
16291: EMPTY
16292: LIST
16293: LIST
16294: PPUSH
16295: CALL_OW 70
16299: IFFALSE 16308
16301: PUSH
16302: LD_EXP 2
16306: NOT
16307: AND
16308: IFFALSE 16316
16310: PUSH
16311: LD_EXP 54
16315: AND
16316: IFFALSE 16345
16318: GO 16320
16320: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
16321: LD_EXP 62
16325: PPUSH
16326: LD_STRING DSurrenderRussians-Pla-1
16328: PPUSH
16329: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
16333: LD_EXP 54
16337: PPUSH
16338: LD_STRING DSurrenderRussians-Bur-1
16340: PPUSH
16341: CALL_OW 88
// end ;
16345: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
16346: LD_EXP 4
16350: IFFALSE 16791
16352: GO 16354
16354: DISABLE
16355: LD_INT 0
16357: PPUSH
16358: PPUSH
16359: PPUSH
// begin MC_Kill ( 4 ) ;
16360: LD_INT 4
16362: PPUSH
16363: CALL 23606 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
16367: LD_INT 1
16369: PPUSH
16370: LD_INT 7
16372: PPUSH
16373: LD_INT 1
16375: PPUSH
16376: LD_INT 1
16378: PPUSH
16379: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
16383: LD_ADDR_VAR 0 3
16387: PUSH
16388: LD_INT 22
16390: PUSH
16391: LD_INT 1
16393: PUSH
16394: EMPTY
16395: LIST
16396: LIST
16397: PUSH
16398: LD_INT 50
16400: PUSH
16401: EMPTY
16402: LIST
16403: PUSH
16404: LD_INT 26
16406: PUSH
16407: LD_INT 1
16409: PUSH
16410: EMPTY
16411: LIST
16412: LIST
16413: PUSH
16414: LD_INT 23
16416: PUSH
16417: LD_INT 1
16419: PUSH
16420: EMPTY
16421: LIST
16422: LIST
16423: PUSH
16424: EMPTY
16425: LIST
16426: LIST
16427: LIST
16428: LIST
16429: PPUSH
16430: CALL_OW 69
16434: PUSH
16435: LD_EXP 57
16439: PUSH
16440: LD_EXP 29
16444: PUSH
16445: LD_EXP 26
16449: PUSH
16450: LD_EXP 25
16454: PUSH
16455: LD_EXP 32
16459: PUSH
16460: LD_EXP 30
16464: PUSH
16465: EMPTY
16466: LIST
16467: LIST
16468: LIST
16469: LIST
16470: LIST
16471: LIST
16472: DIFF
16473: ST_TO_ADDR
// if not speaker then
16474: LD_VAR 0 3
16478: NOT
16479: IFFALSE 16519
// begin uc_side := 1 ;
16481: LD_ADDR_OWVAR 20
16485: PUSH
16486: LD_INT 1
16488: ST_TO_ADDR
// uc_nation := 1 ;
16489: LD_ADDR_OWVAR 21
16493: PUSH
16494: LD_INT 1
16496: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16497: LD_INT 1
16499: PPUSH
16500: LD_INT 0
16502: PPUSH
16503: CALL_OW 381
// speaker := CreateHuman ;
16507: LD_ADDR_VAR 0 3
16511: PUSH
16512: CALL_OW 44
16516: ST_TO_ADDR
// end else
16517: GO 16533
// speaker := speaker [ 1 ] ;
16519: LD_ADDR_VAR 0 3
16523: PUSH
16524: LD_VAR 0 3
16528: PUSH
16529: LD_INT 1
16531: ARRAY
16532: ST_TO_ADDR
// DialogueOn ;
16533: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
16537: LD_VAR 0 3
16541: PPUSH
16542: LD_STRING DSurrenderAmericans-Sol1-1a
16544: PPUSH
16545: CALL_OW 94
// DialogueOff ;
16549: CALL_OW 7
// americanCapitulated := true ;
16553: LD_ADDR_EXP 6
16557: PUSH
16558: LD_INT 1
16560: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16561: LD_ADDR_VAR 0 2
16565: PUSH
16566: LD_INT 22
16568: PUSH
16569: LD_INT 1
16571: PUSH
16572: EMPTY
16573: LIST
16574: LIST
16575: PUSH
16576: LD_INT 21
16578: PUSH
16579: LD_INT 1
16581: PUSH
16582: EMPTY
16583: LIST
16584: LIST
16585: PUSH
16586: EMPTY
16587: LIST
16588: LIST
16589: PPUSH
16590: CALL_OW 69
16594: PUSH
16595: LD_INT 22
16597: PUSH
16598: LD_INT 1
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: PUSH
16605: LD_INT 21
16607: PUSH
16608: LD_INT 2
16610: PUSH
16611: EMPTY
16612: LIST
16613: LIST
16614: PUSH
16615: LD_INT 1
16617: PUSH
16618: EMPTY
16619: LIST
16620: PUSH
16621: EMPTY
16622: LIST
16623: LIST
16624: LIST
16625: PPUSH
16626: CALL_OW 69
16630: ADD
16631: ST_TO_ADDR
// if tmp then
16632: LD_VAR 0 2
16636: IFFALSE 16791
// repeat wait ( 0 0$1 ) ;
16638: LD_INT 35
16640: PPUSH
16641: CALL_OW 67
// for i in tmp do
16645: LD_ADDR_VAR 0 1
16649: PUSH
16650: LD_VAR 0 2
16654: PUSH
16655: FOR_IN
16656: IFFALSE 16740
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16658: LD_VAR 0 1
16662: PPUSH
16663: CALL_OW 310
16667: IFFALSE 16689
16669: PUSH
16670: LD_VAR 0 1
16674: PPUSH
16675: CALL_OW 310
16679: PPUSH
16680: CALL_OW 247
16684: PUSH
16685: LD_INT 3
16687: EQUAL
16688: AND
16689: IFFALSE 16700
// ComExitBuilding ( i ) ;
16691: LD_VAR 0 1
16695: PPUSH
16696: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
16700: LD_VAR 0 1
16704: PPUSH
16705: LD_INT 122
16707: PPUSH
16708: LD_INT 242
16710: PPUSH
16711: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
16715: LD_VAR 0 1
16719: PPUSH
16720: LD_INT 35
16722: PPUSH
16723: CALL_OW 308
16727: IFFALSE 16738
// RemoveUnit ( i ) ;
16729: LD_VAR 0 1
16733: PPUSH
16734: CALL_OW 64
// end ;
16738: GO 16655
16740: POP
16741: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16742: LD_INT 22
16744: PUSH
16745: LD_INT 1
16747: PUSH
16748: EMPTY
16749: LIST
16750: LIST
16751: PUSH
16752: LD_INT 2
16754: PUSH
16755: LD_INT 21
16757: PUSH
16758: LD_INT 1
16760: PUSH
16761: EMPTY
16762: LIST
16763: LIST
16764: PUSH
16765: LD_INT 33
16767: PUSH
16768: LD_INT 1
16770: PUSH
16771: EMPTY
16772: LIST
16773: LIST
16774: PUSH
16775: EMPTY
16776: LIST
16777: LIST
16778: LIST
16779: PUSH
16780: EMPTY
16781: LIST
16782: LIST
16783: PPUSH
16784: CALL_OW 69
16788: NOT
16789: IFFALSE 16638
// end ;
16791: PPOPN 3
16793: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
16794: LD_EXP 2
16798: IFFALSE 17249
16800: GO 16802
16802: DISABLE
16803: LD_INT 0
16805: PPUSH
16806: PPUSH
16807: PPUSH
// begin repeat wait ( 0 0$1 ) ;
16808: LD_INT 35
16810: PPUSH
16811: CALL_OW 67
// until IsDead ( Yakotich ) ;
16815: LD_EXP 63
16819: PPUSH
16820: CALL_OW 301
16824: IFFALSE 16808
// MC_Kill ( 2 ) ;
16826: LD_INT 2
16828: PPUSH
16829: CALL 23606 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16833: LD_INT 3
16835: PPUSH
16836: LD_INT 7
16838: PPUSH
16839: LD_INT 1
16841: PPUSH
16842: LD_INT 1
16844: PPUSH
16845: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16849: LD_ADDR_VAR 0 3
16853: PUSH
16854: LD_INT 22
16856: PUSH
16857: LD_INT 3
16859: PUSH
16860: EMPTY
16861: LIST
16862: LIST
16863: PUSH
16864: LD_INT 50
16866: PUSH
16867: EMPTY
16868: LIST
16869: PUSH
16870: LD_INT 26
16872: PUSH
16873: LD_INT 1
16875: PUSH
16876: EMPTY
16877: LIST
16878: LIST
16879: PUSH
16880: LD_INT 23
16882: PUSH
16883: LD_INT 3
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: LIST
16894: LIST
16895: PPUSH
16896: CALL_OW 69
16900: PUSH
16901: LD_EXP 62
16905: DIFF
16906: ST_TO_ADDR
// if not speaker then
16907: LD_VAR 0 3
16911: NOT
16912: IFFALSE 16952
// begin uc_side := 3 ;
16914: LD_ADDR_OWVAR 20
16918: PUSH
16919: LD_INT 3
16921: ST_TO_ADDR
// uc_nation := 3 ;
16922: LD_ADDR_OWVAR 21
16926: PUSH
16927: LD_INT 3
16929: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16930: LD_INT 1
16932: PPUSH
16933: LD_INT 0
16935: PPUSH
16936: CALL_OW 381
// speaker := CreateHuman ;
16940: LD_ADDR_VAR 0 3
16944: PUSH
16945: CALL_OW 44
16949: ST_TO_ADDR
// end else
16950: GO 16966
// speaker := speaker [ 1 ] ;
16952: LD_ADDR_VAR 0 3
16956: PUSH
16957: LD_VAR 0 3
16961: PUSH
16962: LD_INT 1
16964: ARRAY
16965: ST_TO_ADDR
// DialogueOn ;
16966: CALL_OW 6
// if IsOK ( Burlak ) then
16970: LD_EXP 54
16974: PPUSH
16975: CALL_OW 302
16979: IFFALSE 16995
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16981: LD_VAR 0 3
16985: PPUSH
16986: LD_STRING DSurrenderRussians-RSol1-1
16988: PPUSH
16989: CALL_OW 94
16993: GO 17007
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16995: LD_VAR 0 3
16999: PPUSH
17000: LD_STRING DSurrenderRussians-RSol1-1a
17002: PPUSH
17003: CALL_OW 94
// DialogueOff ;
17007: CALL_OW 7
// russianCapitulated := true ;
17011: LD_ADDR_EXP 7
17015: PUSH
17016: LD_INT 1
17018: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17019: LD_ADDR_VAR 0 2
17023: PUSH
17024: LD_INT 22
17026: PUSH
17027: LD_INT 3
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: PUSH
17034: LD_INT 21
17036: PUSH
17037: LD_INT 1
17039: PUSH
17040: EMPTY
17041: LIST
17042: LIST
17043: PUSH
17044: EMPTY
17045: LIST
17046: LIST
17047: PPUSH
17048: CALL_OW 69
17052: PUSH
17053: LD_INT 22
17055: PUSH
17056: LD_INT 3
17058: PUSH
17059: EMPTY
17060: LIST
17061: LIST
17062: PUSH
17063: LD_INT 21
17065: PUSH
17066: LD_INT 2
17068: PUSH
17069: EMPTY
17070: LIST
17071: LIST
17072: PUSH
17073: LD_INT 1
17075: PUSH
17076: EMPTY
17077: LIST
17078: PUSH
17079: EMPTY
17080: LIST
17081: LIST
17082: LIST
17083: PPUSH
17084: CALL_OW 69
17088: ADD
17089: ST_TO_ADDR
// if tmp then
17090: LD_VAR 0 2
17094: IFFALSE 17249
// repeat wait ( 0 0$1 ) ;
17096: LD_INT 35
17098: PPUSH
17099: CALL_OW 67
// for i in tmp do
17103: LD_ADDR_VAR 0 1
17107: PUSH
17108: LD_VAR 0 2
17112: PUSH
17113: FOR_IN
17114: IFFALSE 17198
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17116: LD_VAR 0 1
17120: PPUSH
17121: CALL_OW 310
17125: IFFALSE 17147
17127: PUSH
17128: LD_VAR 0 1
17132: PPUSH
17133: CALL_OW 310
17137: PPUSH
17138: CALL_OW 247
17142: PUSH
17143: LD_INT 3
17145: EQUAL
17146: AND
17147: IFFALSE 17158
// ComExitBuilding ( i ) ;
17149: LD_VAR 0 1
17153: PPUSH
17154: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
17158: LD_VAR 0 1
17162: PPUSH
17163: LD_INT 154
17165: PPUSH
17166: LD_INT 1
17168: PPUSH
17169: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
17173: LD_VAR 0 1
17177: PPUSH
17178: LD_INT 36
17180: PPUSH
17181: CALL_OW 308
17185: IFFALSE 17196
// RemoveUnit ( i ) ;
17187: LD_VAR 0 1
17191: PPUSH
17192: CALL_OW 64
// end ;
17196: GO 17113
17198: POP
17199: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17200: LD_INT 22
17202: PUSH
17203: LD_INT 3
17205: PUSH
17206: EMPTY
17207: LIST
17208: LIST
17209: PUSH
17210: LD_INT 2
17212: PUSH
17213: LD_INT 21
17215: PUSH
17216: LD_INT 1
17218: PUSH
17219: EMPTY
17220: LIST
17221: LIST
17222: PUSH
17223: LD_INT 33
17225: PUSH
17226: LD_INT 1
17228: PUSH
17229: EMPTY
17230: LIST
17231: LIST
17232: PUSH
17233: EMPTY
17234: LIST
17235: LIST
17236: LIST
17237: PUSH
17238: EMPTY
17239: LIST
17240: LIST
17241: PPUSH
17242: CALL_OW 69
17246: NOT
17247: IFFALSE 17096
// end ;
17249: PPOPN 3
17251: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
17252: LD_INT 22
17254: PUSH
17255: LD_INT 8
17257: PUSH
17258: EMPTY
17259: LIST
17260: LIST
17261: PUSH
17262: LD_INT 21
17264: PUSH
17265: LD_INT 1
17267: PUSH
17268: EMPTY
17269: LIST
17270: LIST
17271: PUSH
17272: LD_INT 23
17274: PUSH
17275: LD_INT 2
17277: PUSH
17278: EMPTY
17279: LIST
17280: LIST
17281: PUSH
17282: EMPTY
17283: LIST
17284: LIST
17285: LIST
17286: PPUSH
17287: CALL_OW 69
17291: PUSH
17292: LD_INT 18
17294: LESS
17295: IFTRUE 17308
17297: PUSH
17298: LD_EXP 60
17302: PPUSH
17303: CALL_OW 301
17307: OR
17308: IFTRUE 17323
17310: PUSH
17311: LD_INT 324
17313: PPUSH
17314: CALL_OW 255
17318: PUSH
17319: LD_INT 7
17321: EQUAL
17322: OR
17323: IFFALSE 17336
17325: GO 17327
17327: DISABLE
// legionDestroyed := true ;
17328: LD_ADDR_EXP 3
17332: PUSH
17333: LD_INT 1
17335: ST_TO_ADDR
17336: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
17337: LD_INT 22
17339: PUSH
17340: LD_INT 2
17342: PUSH
17343: EMPTY
17344: LIST
17345: LIST
17346: PUSH
17347: LD_INT 21
17349: PUSH
17350: LD_INT 1
17352: PUSH
17353: EMPTY
17354: LIST
17355: LIST
17356: PUSH
17357: LD_INT 23
17359: PUSH
17360: LD_INT 2
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: PUSH
17367: EMPTY
17368: LIST
17369: LIST
17370: LIST
17371: PPUSH
17372: CALL_OW 69
17376: PUSH
17377: LD_INT 9
17379: LESS
17380: IFTRUE 17391
17382: PUSH
17383: LD_INT 503
17385: PPUSH
17386: CALL_OW 301
17390: OR
17391: IFTRUE 17406
17393: PUSH
17394: LD_INT 503
17396: PPUSH
17397: CALL_OW 255
17401: PUSH
17402: LD_INT 7
17404: EQUAL
17405: OR
17406: IFFALSE 17419
17408: GO 17410
17410: DISABLE
// arabianDestroyed := true ;
17411: LD_ADDR_EXP 5
17415: PUSH
17416: LD_INT 1
17418: ST_TO_ADDR
17419: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
17420: LD_EXP 5
17424: IFFALSE 17670
17426: GO 17428
17428: DISABLE
17429: LD_INT 0
17431: PPUSH
17432: PPUSH
// begin MC_Kill ( 1 ) ;
17433: LD_INT 1
17435: PPUSH
17436: CALL 23606 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17440: LD_ADDR_VAR 0 2
17444: PUSH
17445: LD_INT 22
17447: PUSH
17448: LD_INT 2
17450: PUSH
17451: EMPTY
17452: LIST
17453: LIST
17454: PUSH
17455: LD_INT 21
17457: PUSH
17458: LD_INT 1
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: PUSH
17465: EMPTY
17466: LIST
17467: LIST
17468: PPUSH
17469: CALL_OW 69
17473: PUSH
17474: LD_INT 22
17476: PUSH
17477: LD_INT 2
17479: PUSH
17480: EMPTY
17481: LIST
17482: LIST
17483: PUSH
17484: LD_INT 21
17486: PUSH
17487: LD_INT 2
17489: PUSH
17490: EMPTY
17491: LIST
17492: LIST
17493: PUSH
17494: LD_INT 1
17496: PUSH
17497: EMPTY
17498: LIST
17499: PUSH
17500: EMPTY
17501: LIST
17502: LIST
17503: LIST
17504: PPUSH
17505: CALL_OW 69
17509: ADD
17510: ST_TO_ADDR
// if tmp then
17511: LD_VAR 0 2
17515: IFFALSE 17670
// repeat wait ( 0 0$1 ) ;
17517: LD_INT 35
17519: PPUSH
17520: CALL_OW 67
// for i in tmp do
17524: LD_ADDR_VAR 0 1
17528: PUSH
17529: LD_VAR 0 2
17533: PUSH
17534: FOR_IN
17535: IFFALSE 17619
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17537: LD_VAR 0 1
17541: PPUSH
17542: CALL_OW 310
17546: IFFALSE 17568
17548: PUSH
17549: LD_VAR 0 1
17553: PPUSH
17554: CALL_OW 310
17558: PPUSH
17559: CALL_OW 247
17563: PUSH
17564: LD_INT 3
17566: EQUAL
17567: AND
17568: IFFALSE 17579
// ComExitBuilding ( i ) ;
17570: LD_VAR 0 1
17574: PPUSH
17575: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
17579: LD_VAR 0 1
17583: PPUSH
17584: LD_INT 254
17586: PPUSH
17587: LD_INT 268
17589: PPUSH
17590: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
17594: LD_VAR 0 1
17598: PPUSH
17599: LD_INT 34
17601: PPUSH
17602: CALL_OW 308
17606: IFFALSE 17617
// RemoveUnit ( i ) ;
17608: LD_VAR 0 1
17612: PPUSH
17613: CALL_OW 64
// end ;
17617: GO 17534
17619: POP
17620: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17621: LD_INT 22
17623: PUSH
17624: LD_INT 2
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: PUSH
17631: LD_INT 2
17633: PUSH
17634: LD_INT 21
17636: PUSH
17637: LD_INT 1
17639: PUSH
17640: EMPTY
17641: LIST
17642: LIST
17643: PUSH
17644: LD_INT 33
17646: PUSH
17647: LD_INT 1
17649: PUSH
17650: EMPTY
17651: LIST
17652: LIST
17653: PUSH
17654: EMPTY
17655: LIST
17656: LIST
17657: LIST
17658: PUSH
17659: EMPTY
17660: LIST
17661: LIST
17662: PPUSH
17663: CALL_OW 69
17667: NOT
17668: IFFALSE 17517
// end ;
17670: PPOPN 2
17672: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
17673: LD_EXP 3
17677: IFFALSE 18031
17679: GO 17681
17681: DISABLE
17682: LD_INT 0
17684: PPUSH
17685: PPUSH
// begin MC_Kill ( 3 ) ;
17686: LD_INT 3
17688: PPUSH
17689: CALL 23606 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
17693: LD_INT 8
17695: PPUSH
17696: LD_INT 7
17698: PPUSH
17699: LD_INT 1
17701: PPUSH
17702: LD_INT 1
17704: PPUSH
17705: CALL_OW 80
// DialogueOn ;
17709: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
17713: LD_EXP 59
17717: PPUSH
17718: LD_STRING D15-Szulc-1
17720: PPUSH
17721: CALL_OW 94
// DialogueOff ;
17725: CALL_OW 7
// legionCapitulated := true ;
17729: LD_ADDR_EXP 8
17733: PUSH
17734: LD_INT 1
17736: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
17737: LD_ADDR_VAR 0 1
17741: PUSH
17742: LD_INT 22
17744: PUSH
17745: LD_INT 8
17747: PUSH
17748: EMPTY
17749: LIST
17750: LIST
17751: PUSH
17752: LD_INT 21
17754: PUSH
17755: LD_INT 3
17757: PUSH
17758: EMPTY
17759: LIST
17760: LIST
17761: PUSH
17762: LD_INT 23
17764: PUSH
17765: LD_INT 3
17767: PUSH
17768: EMPTY
17769: LIST
17770: LIST
17771: PUSH
17772: EMPTY
17773: LIST
17774: LIST
17775: LIST
17776: PPUSH
17777: CALL_OW 69
17781: PUSH
17782: FOR_IN
17783: IFFALSE 17799
// SetLives ( i , 3 ) ;
17785: LD_VAR 0 1
17789: PPUSH
17790: LD_INT 3
17792: PPUSH
17793: CALL_OW 234
17797: GO 17782
17799: POP
17800: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17801: LD_ADDR_VAR 0 2
17805: PUSH
17806: LD_INT 22
17808: PUSH
17809: LD_INT 8
17811: PUSH
17812: EMPTY
17813: LIST
17814: LIST
17815: PUSH
17816: LD_INT 21
17818: PUSH
17819: LD_INT 1
17821: PUSH
17822: EMPTY
17823: LIST
17824: LIST
17825: PUSH
17826: EMPTY
17827: LIST
17828: LIST
17829: PPUSH
17830: CALL_OW 69
17834: PUSH
17835: LD_INT 22
17837: PUSH
17838: LD_INT 8
17840: PUSH
17841: EMPTY
17842: LIST
17843: LIST
17844: PUSH
17845: LD_INT 21
17847: PUSH
17848: LD_INT 2
17850: PUSH
17851: EMPTY
17852: LIST
17853: LIST
17854: PUSH
17855: LD_INT 1
17857: PUSH
17858: EMPTY
17859: LIST
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: LIST
17865: PPUSH
17866: CALL_OW 69
17870: ADD
17871: ST_TO_ADDR
// if tmp then
17872: LD_VAR 0 2
17876: IFFALSE 18031
// repeat wait ( 0 0$1 ) ;
17878: LD_INT 35
17880: PPUSH
17881: CALL_OW 67
// for i in tmp do
17885: LD_ADDR_VAR 0 1
17889: PUSH
17890: LD_VAR 0 2
17894: PUSH
17895: FOR_IN
17896: IFFALSE 17980
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17898: LD_VAR 0 1
17902: PPUSH
17903: CALL_OW 310
17907: IFFALSE 17929
17909: PUSH
17910: LD_VAR 0 1
17914: PPUSH
17915: CALL_OW 310
17919: PPUSH
17920: CALL_OW 247
17924: PUSH
17925: LD_INT 3
17927: EQUAL
17928: AND
17929: IFFALSE 17940
// ComExitBuilding ( i ) ;
17931: LD_VAR 0 1
17935: PPUSH
17936: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17940: LD_VAR 0 1
17944: PPUSH
17945: LD_INT 10
17947: PPUSH
17948: LD_INT 1
17950: PPUSH
17951: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17955: LD_VAR 0 1
17959: PPUSH
17960: LD_INT 32
17962: PPUSH
17963: CALL_OW 308
17967: IFFALSE 17978
// RemoveUnit ( i ) ;
17969: LD_VAR 0 1
17973: PPUSH
17974: CALL_OW 64
// end ;
17978: GO 17895
17980: POP
17981: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17982: LD_INT 22
17984: PUSH
17985: LD_INT 8
17987: PUSH
17988: EMPTY
17989: LIST
17990: LIST
17991: PUSH
17992: LD_INT 2
17994: PUSH
17995: LD_INT 21
17997: PUSH
17998: LD_INT 1
18000: PUSH
18001: EMPTY
18002: LIST
18003: LIST
18004: PUSH
18005: LD_INT 33
18007: PUSH
18008: LD_INT 1
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: LIST
18019: PUSH
18020: EMPTY
18021: LIST
18022: LIST
18023: PPUSH
18024: CALL_OW 69
18028: NOT
18029: IFFALSE 17878
// end ;
18031: PPOPN 2
18033: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
18034: LD_EXP 5
18038: NOT
18039: IFFALSE 18051
18041: PUSH
18042: LD_OWVAR 1
18046: PUSH
18047: LD_INT 63000
18049: GREATEREQUAL
18050: AND
18051: IFFALSE 18063
18053: PUSH
18054: LD_OWVAR 67
18058: PUSH
18059: LD_INT 3
18061: LESS
18062: AND
18063: IFFALSE 18072
18065: GO 18067
18067: DISABLE
// AllianceSupport ;
18068: CALL 4711 0 0
18072: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or omarKilled or not IsPlaced ( Omar ) ) do var med1 , med2 ;
18073: LD_EXP 4
18077: IFFALSE 18085
18079: PUSH
18080: LD_EXP 2
18084: AND
18085: IFFALSE 18093
18087: PUSH
18088: LD_EXP 3
18092: AND
18093: IFFALSE 18101
18095: PUSH
18096: LD_EXP 5
18100: AND
18101: IFFALSE 18109
18103: PUSH
18104: LD_EXP 6
18108: AND
18109: IFFALSE 18117
18111: PUSH
18112: LD_EXP 7
18116: AND
18117: IFFALSE 18125
18119: PUSH
18120: LD_EXP 8
18124: AND
18125: IFFALSE 18164
18127: PUSH
18128: LD_EXP 58
18132: PPUSH
18133: CALL_OW 255
18137: PUSH
18138: LD_INT 5
18140: NONEQUAL
18141: IFTRUE 18149
18143: PUSH
18144: LD_EXP 20
18148: OR
18149: IFTRUE 18163
18151: PUSH
18152: LD_EXP 58
18156: PPUSH
18157: CALL_OW 305
18161: NOT
18162: OR
18163: AND
18164: IFFALSE 19857
18166: GO 18168
18168: DISABLE
18169: LD_INT 0
18171: PPUSH
18172: PPUSH
// begin wait ( 0 0$5 ) ;
18173: LD_INT 175
18175: PPUSH
18176: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 3 then
18180: LD_INT 22
18182: PUSH
18183: LD_INT 7
18185: PUSH
18186: EMPTY
18187: LIST
18188: LIST
18189: PUSH
18190: LD_INT 21
18192: PUSH
18193: LD_INT 1
18195: PUSH
18196: EMPTY
18197: LIST
18198: LIST
18199: PUSH
18200: LD_INT 23
18202: PUSH
18203: LD_INT 1
18205: PUSH
18206: EMPTY
18207: LIST
18208: LIST
18209: PUSH
18210: LD_INT 50
18212: PUSH
18213: EMPTY
18214: LIST
18215: PUSH
18216: EMPTY
18217: LIST
18218: LIST
18219: LIST
18220: LIST
18221: PPUSH
18222: CALL_OW 69
18226: PPUSH
18227: CALL 56635 0 1
18231: PUSH
18232: LD_INT 3
18234: LESS
18235: IFFALSE 18246
// begin YouLost ( LostVictory ) ;
18237: LD_STRING LostVictory
18239: PPUSH
18240: CALL_OW 104
// exit ;
18244: GO 19857
// end ; music_class := 5 ;
18246: LD_ADDR_OWVAR 72
18250: PUSH
18251: LD_INT 5
18253: ST_TO_ADDR
// music_nat := 5 ;
18254: LD_ADDR_OWVAR 71
18258: PUSH
18259: LD_INT 5
18261: ST_TO_ADDR
// if vehicleLostCounter < 3 then
18262: LD_EXP 15
18266: PUSH
18267: LD_INT 3
18269: LESS
18270: IFFALSE 18279
// SetAchievement ( ACH_ECONOMY ) ;
18272: LD_STRING ACH_ECONOMY
18274: PPUSH
18275: CALL_OW 543
// if tick < 60 60$00 then
18279: LD_OWVAR 1
18283: PUSH
18284: LD_INT 126000
18286: LESS
18287: IFFALSE 18303
// begin wait ( 3 ) ;
18289: LD_INT 3
18291: PPUSH
18292: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
18296: LD_STRING ACH_ASPEED_19
18298: PPUSH
18299: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
18303: LD_EXP 21
18307: PPUSH
18308: CALL_OW 87
// InGameOn ;
18312: CALL_OW 8
// DialogueOn ;
18316: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
18320: LD_EXP 21
18324: PPUSH
18325: LD_STRING DEnd-JMM-JMM-1
18327: PPUSH
18328: CALL_OW 88
// if Joan then
18332: LD_EXP 36
18336: IFFALSE 18352
// Say ( Joan , DEnd-JMM-Joan-1 ) else
18338: LD_EXP 36
18342: PPUSH
18343: LD_STRING DEnd-JMM-Joan-1
18345: PPUSH
18346: CALL_OW 88
18350: GO 18400
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
18352: LD_EXP 23
18356: IFFALSE 18373
18358: PUSH
18359: LD_EXP 23
18363: PPUSH
18364: CALL_OW 255
18368: PUSH
18369: LD_INT 7
18371: EQUAL
18372: AND
18373: IFFALSE 18386
18375: PUSH
18376: LD_EXP 23
18380: PPUSH
18381: CALL_OW 305
18385: AND
18386: IFFALSE 18400
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
18388: LD_EXP 23
18392: PPUSH
18393: LD_STRING DEnd-JMM-Lisa-1
18395: PPUSH
18396: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
18400: LD_EXP 33
18404: IFFALSE 18417
18406: PUSH
18407: LD_EXP 33
18411: PPUSH
18412: CALL_OW 305
18416: AND
18417: IFFALSE 18431
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
18419: LD_EXP 33
18423: PPUSH
18424: LD_STRING DEnd-JMM-Frank-1
18426: PPUSH
18427: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
18431: LD_EXP 26
18435: IFFALSE 18452
18437: PUSH
18438: LD_EXP 26
18442: PPUSH
18443: CALL_OW 255
18447: PUSH
18448: LD_INT 7
18450: EQUAL
18451: AND
18452: IFFALSE 18465
18454: PUSH
18455: LD_EXP 26
18459: PPUSH
18460: CALL_OW 305
18464: AND
18465: IFFALSE 18479
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
18467: LD_EXP 26
18471: PPUSH
18472: LD_STRING DEnd-JMM-Cyrus-1
18474: PPUSH
18475: CALL_OW 88
// if Burlak then
18479: LD_EXP 54
18483: IFFALSE 18497
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
18485: LD_EXP 54
18489: PPUSH
18490: LD_STRING DEnd-JMM-Bur-1
18492: PPUSH
18493: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
18497: LD_EXP 36
18501: IFFALSE 18509
18503: PUSH
18504: LD_EXP 23
18508: AND
18509: IFFALSE 18526
18511: PUSH
18512: LD_EXP 23
18516: PPUSH
18517: CALL_OW 255
18521: PUSH
18522: LD_INT 7
18524: EQUAL
18525: AND
18526: IFFALSE 18539
18528: PUSH
18529: LD_EXP 23
18533: PPUSH
18534: CALL_OW 305
18538: AND
18539: IFFALSE 18552
18541: PUSH
18542: LD_EXP 54
18546: PPUSH
18547: CALL_OW 302
18551: AND
18552: IFFALSE 18566
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
18554: LD_EXP 23
18558: PPUSH
18559: LD_STRING DEnd-Burlak-Lisa-1
18561: PPUSH
18562: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
18566: LD_EXP 55
18570: IFFALSE 18583
18572: PUSH
18573: LD_EXP 55
18577: PPUSH
18578: CALL_OW 305
18582: AND
18583: IFFALSE 18597
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
18585: LD_EXP 55
18589: PPUSH
18590: LD_STRING DEnd-JMM-Bel-1
18592: PPUSH
18593: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
18597: LD_EXP 56
18601: IFFALSE 18614
18603: PUSH
18604: LD_EXP 56
18608: PPUSH
18609: CALL_OW 305
18613: AND
18614: IFFALSE 18628
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
18616: LD_EXP 56
18620: PPUSH
18621: LD_STRING DEnd-JMM-Gny-1
18623: PPUSH
18624: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
18628: LD_EXP 31
18632: IFFALSE 18649
18634: PUSH
18635: LD_EXP 31
18639: PPUSH
18640: CALL_OW 255
18644: PUSH
18645: LD_INT 7
18647: EQUAL
18648: AND
18649: IFFALSE 18662
18651: PUSH
18652: LD_EXP 31
18656: PPUSH
18657: CALL_OW 305
18661: AND
18662: IFFALSE 18676
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
18664: LD_EXP 31
18668: PPUSH
18669: LD_STRING DEnd-JMM-Corn-1
18671: PPUSH
18672: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
18676: LD_EXP 24
18680: IFFALSE 18697
18682: PUSH
18683: LD_EXP 24
18687: PPUSH
18688: CALL_OW 255
18692: PUSH
18693: LD_INT 7
18695: EQUAL
18696: AND
18697: IFFALSE 18710
18699: PUSH
18700: LD_EXP 24
18704: PPUSH
18705: CALL_OW 305
18709: AND
18710: IFFALSE 18724
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
18712: LD_EXP 24
18716: PPUSH
18717: LD_STRING DEnd-JMM-Don-1
18719: PPUSH
18720: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
18724: LD_EXP 25
18728: IFFALSE 18745
18730: PUSH
18731: LD_EXP 25
18735: PPUSH
18736: CALL_OW 255
18740: PUSH
18741: LD_INT 7
18743: EQUAL
18744: AND
18745: IFFALSE 18758
18747: PUSH
18748: LD_EXP 25
18752: PPUSH
18753: CALL_OW 305
18757: AND
18758: IFFALSE 18772
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
18760: LD_EXP 25
18764: PPUSH
18765: LD_STRING DEnd-JMM-Bobby-1
18767: PPUSH
18768: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
18772: LD_EXP 27
18776: IFFALSE 18793
18778: PUSH
18779: LD_EXP 27
18783: PPUSH
18784: CALL_OW 255
18788: PUSH
18789: LD_INT 7
18791: EQUAL
18792: AND
18793: IFFALSE 18806
18795: PUSH
18796: LD_EXP 27
18800: PPUSH
18801: CALL_OW 305
18805: AND
18806: IFFALSE 18820
// Say ( Denis , DEnd-JMM-Den-1 ) ;
18808: LD_EXP 27
18812: PPUSH
18813: LD_STRING DEnd-JMM-Den-1
18815: PPUSH
18816: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
18820: LD_EXP 29
18824: IFFALSE 18841
18826: PUSH
18827: LD_EXP 29
18831: PPUSH
18832: CALL_OW 255
18836: PUSH
18837: LD_INT 7
18839: EQUAL
18840: AND
18841: IFFALSE 18854
18843: PUSH
18844: LD_EXP 29
18848: PPUSH
18849: CALL_OW 305
18853: AND
18854: IFFALSE 18868
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
18856: LD_EXP 29
18860: PPUSH
18861: LD_STRING DEnd-JMM-Glad-1
18863: PPUSH
18864: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18868: LD_EXP 34
18872: IFFALSE 18889
18874: PUSH
18875: LD_EXP 34
18879: PPUSH
18880: CALL_OW 255
18884: PUSH
18885: LD_INT 7
18887: EQUAL
18888: AND
18889: IFFALSE 18902
18891: PUSH
18892: LD_EXP 34
18896: PPUSH
18897: CALL_OW 305
18901: AND
18902: IFFALSE 18916
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18904: LD_EXP 34
18908: PPUSH
18909: LD_STRING DEnd-JMM-Yam-1
18911: PPUSH
18912: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
18916: LD_EXP 28
18920: IFFALSE 18937
18922: PUSH
18923: LD_EXP 28
18927: PPUSH
18928: CALL_OW 255
18932: PUSH
18933: LD_INT 7
18935: EQUAL
18936: AND
18937: IFFALSE 18950
18939: PUSH
18940: LD_EXP 28
18944: PPUSH
18945: CALL_OW 305
18949: AND
18950: IFFALSE 18964
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
18952: LD_EXP 28
18956: PPUSH
18957: LD_STRING DEnd-JMM-Brown-1
18959: PPUSH
18960: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
18964: LD_EXP 38
18968: IFFALSE 18985
18970: PUSH
18971: LD_EXP 38
18975: PPUSH
18976: CALL_OW 255
18980: PUSH
18981: LD_INT 7
18983: EQUAL
18984: AND
18985: IFFALSE 18998
18987: PUSH
18988: LD_EXP 38
18992: PPUSH
18993: CALL_OW 305
18997: AND
18998: IFFALSE 19012
// Say ( Connie , DEnd-JMM-Con-1 ) ;
19000: LD_EXP 38
19004: PPUSH
19005: LD_STRING DEnd-JMM-Con-1
19007: PPUSH
19008: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
19012: LD_EXP 32
19016: IFFALSE 19033
19018: PUSH
19019: LD_EXP 32
19023: PPUSH
19024: CALL_OW 255
19028: PUSH
19029: LD_INT 7
19031: EQUAL
19032: AND
19033: IFFALSE 19046
19035: PUSH
19036: LD_EXP 32
19040: PPUSH
19041: CALL_OW 305
19045: AND
19046: IFFALSE 19060
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
19048: LD_EXP 32
19052: PPUSH
19053: LD_STRING DEnd-JMM-Gary-1
19055: PPUSH
19056: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
19060: LD_EXP 22
19064: IFFALSE 19077
19066: PUSH
19067: LD_EXP 22
19071: PPUSH
19072: CALL_OW 305
19076: AND
19077: IFFALSE 19091
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
19079: LD_EXP 22
19083: PPUSH
19084: LD_STRING DEnd-JMM-Roth-1
19086: PPUSH
19087: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
19091: LD_EXP 35
19095: IFFALSE 19103
19097: PUSH
19098: LD_EXP 22
19102: AND
19103: IFFALSE 19116
19105: PUSH
19106: LD_EXP 35
19110: PPUSH
19111: CALL_OW 305
19115: AND
19116: IFFALSE 19130
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
19118: LD_EXP 35
19122: PPUSH
19123: LD_STRING DEnd-JMM-Sim-1
19125: PPUSH
19126: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
19130: LD_EXP 30
19134: IFFALSE 19151
19136: PUSH
19137: LD_EXP 30
19141: PPUSH
19142: CALL_OW 255
19146: PUSH
19147: LD_INT 7
19149: EQUAL
19150: AND
19151: IFFALSE 19164
19153: PUSH
19154: LD_EXP 30
19158: PPUSH
19159: CALL_OW 305
19163: AND
19164: IFFALSE 19178
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
19166: LD_EXP 30
19170: PPUSH
19171: LD_STRING DEnd-JMM-VanH-1
19173: PPUSH
19174: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
19178: LD_EXP 44
19182: IFFALSE 19195
19184: PUSH
19185: LD_EXP 44
19189: PPUSH
19190: CALL_OW 305
19194: AND
19195: IFFALSE 19209
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
19197: LD_EXP 44
19201: PPUSH
19202: LD_STRING DEnd-JMM-Dol-1
19204: PPUSH
19205: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
19209: LD_EXP 34
19213: IFFALSE 19230
19215: PUSH
19216: LD_EXP 34
19220: PPUSH
19221: CALL_OW 255
19225: PUSH
19226: LD_INT 7
19228: EQUAL
19229: AND
19230: IFFALSE 19243
19232: PUSH
19233: LD_EXP 34
19237: PPUSH
19238: CALL_OW 305
19242: AND
19243: IFFALSE 19257
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
19245: LD_EXP 34
19249: PPUSH
19250: LD_STRING DEnd-JMM-Yam-1
19252: PPUSH
19253: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
19257: LD_EXP 48
19261: IFFALSE 19274
19263: PUSH
19264: LD_EXP 48
19268: PPUSH
19269: CALL_OW 305
19273: AND
19274: IFFALSE 19288
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
19276: LD_EXP 48
19280: PPUSH
19281: LD_STRING DEnd-JMM-Kap-1
19283: PPUSH
19284: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
19288: LD_EXP 51
19292: IFFALSE 19305
19294: PUSH
19295: LD_EXP 51
19299: PPUSH
19300: CALL_OW 305
19304: AND
19305: IFFALSE 19319
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
19307: LD_EXP 51
19311: PPUSH
19312: LD_STRING DEnd-JMM-Kov-1
19314: PPUSH
19315: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
19319: LD_EXP 46
19323: IFFALSE 19336
19325: PUSH
19326: LD_EXP 46
19330: PPUSH
19331: CALL_OW 305
19335: AND
19336: IFFALSE 19350
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
19338: LD_EXP 46
19342: PPUSH
19343: LD_STRING DEnd-JMM-Sch-1
19345: PPUSH
19346: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
19350: LD_EXP 42
19354: IFFALSE 19367
19356: PUSH
19357: LD_EXP 42
19361: PPUSH
19362: CALL_OW 305
19366: AND
19367: IFFALSE 19380
19369: PUSH
19370: LD_EXP 54
19374: PPUSH
19375: CALL_OW 302
19379: AND
19380: IFFALSE 19394
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
19382: LD_EXP 42
19386: PPUSH
19387: LD_STRING DEnd-JMM-Tit-1
19389: PPUSH
19390: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
19394: LD_EXP 47
19398: IFFALSE 19411
19400: PUSH
19401: LD_EXP 47
19405: PPUSH
19406: CALL_OW 305
19410: AND
19411: IFFALSE 19425
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
19413: LD_EXP 47
19417: PPUSH
19418: LD_STRING DEnd-JMM-Obl-1
19420: PPUSH
19421: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
19425: LD_EXP 49
19429: IFFALSE 19442
19431: PUSH
19432: LD_EXP 49
19436: PPUSH
19437: CALL_OW 305
19441: AND
19442: IFFALSE 19456
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
19444: LD_EXP 49
19448: PPUSH
19449: LD_STRING DEnd-JMM-Lip-1
19451: PPUSH
19452: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
19456: LD_EXP 43
19460: IFFALSE 19473
19462: PUSH
19463: LD_EXP 43
19467: PPUSH
19468: CALL_OW 305
19472: AND
19473: IFFALSE 19486
19475: PUSH
19476: LD_EXP 54
19480: PPUSH
19481: CALL_OW 302
19485: AND
19486: IFFALSE 19500
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
19488: LD_EXP 43
19492: PPUSH
19493: LD_STRING DEnd-Burlak-Fad-1
19495: PPUSH
19496: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
19500: LD_EXP 50
19504: IFFALSE 19517
19506: PUSH
19507: LD_EXP 50
19511: PPUSH
19512: CALL_OW 305
19516: AND
19517: IFFALSE 19531
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
19519: LD_EXP 50
19523: PPUSH
19524: LD_STRING DEnd-Burlak-Ptr-1
19526: PPUSH
19527: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
19531: LD_EXP 52
19535: IFFALSE 19548
19537: PUSH
19538: LD_EXP 52
19542: PPUSH
19543: CALL_OW 305
19547: AND
19548: IFFALSE 19562
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
19550: LD_EXP 52
19554: PPUSH
19555: LD_STRING DEnd-Burlak-Kuz-1
19557: PPUSH
19558: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
19562: LD_EXP 41
19566: IFFALSE 19579
19568: PUSH
19569: LD_EXP 41
19573: PPUSH
19574: CALL_OW 305
19578: AND
19579: IFFALSE 19592
19581: PUSH
19582: LD_EXP 54
19586: PPUSH
19587: CALL_OW 302
19591: AND
19592: IFFALSE 19606
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
19594: LD_EXP 41
19598: PPUSH
19599: LD_STRING DEnd-Burlak-Kir-1
19601: PPUSH
19602: CALL_OW 88
// if Joan then
19606: LD_EXP 36
19610: IFFALSE 19624
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
19612: LD_EXP 36
19616: PPUSH
19617: LD_STRING DEnd-Burlak-Joan-1
19619: PPUSH
19620: CALL_OW 88
// if IsOk ( Burlak ) then
19624: LD_EXP 54
19628: PPUSH
19629: CALL_OW 302
19633: IFFALSE 19647
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
19635: LD_EXP 21
19639: PPUSH
19640: LD_STRING DEnd-Burlak-JMM-1
19642: PPUSH
19643: CALL_OW 88
// dwait ( 0 0$2 ) ;
19647: LD_INT 70
19649: PPUSH
19650: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
19654: LD_EXP 59
19658: PPUSH
19659: LD_STRING DEnd-Szulc
19661: PPUSH
19662: CALL_OW 94
// dwait ( 0 0$1 ) ;
19666: LD_INT 35
19668: PPUSH
19669: CALL_OW 68
// if IsLive ( Burlak ) then
19673: LD_EXP 54
19677: PPUSH
19678: CALL_OW 300
19682: IFFALSE 19694
// med1 := 1 else
19684: LD_ADDR_VAR 0 1
19688: PUSH
19689: LD_INT 1
19691: ST_TO_ADDR
19692: GO 19703
// med1 := - 1 ;
19694: LD_ADDR_VAR 0 1
19698: PUSH
19699: LD_INT 1
19701: NEG
19702: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
19703: LD_EXP 12
19707: IFFALSE 19715
19709: PUSH
19710: LD_EXP 13
19714: AND
19715: IFFALSE 19723
19717: PUSH
19718: LD_EXP 14
19722: AND
19723: IFFALSE 19735
// med2 := 1 else
19725: LD_ADDR_VAR 0 2
19729: PUSH
19730: LD_INT 1
19732: ST_TO_ADDR
19733: GO 19744
// med2 := - 1 ;
19735: LD_ADDR_VAR 0 2
19739: PUSH
19740: LD_INT 1
19742: NEG
19743: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
19744: LD_STRING Hero
19746: PPUSH
19747: LD_INT 1
19749: PPUSH
19750: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
19754: LD_STRING Artefact
19756: PPUSH
19757: LD_VAR 0 2
19761: PPUSH
19762: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
19766: LD_STRING ReconcileBurlak
19768: PPUSH
19769: LD_VAR 0 1
19773: PPUSH
19774: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
19778: LD_OWVAR 67
19782: PUSH
19783: LD_INT 3
19785: GREATEREQUAL
19786: IFFALSE 19798
19788: PUSH
19789: LD_VAR 0 1
19793: PUSH
19794: LD_INT 1
19796: EQUAL
19797: AND
19798: IFFALSE 19810
19800: PUSH
19801: LD_VAR 0 2
19805: PUSH
19806: LD_INT 1
19808: EQUAL
19809: AND
19810: IFFALSE 19822
// SetAchievementEX ( ACH_AMER , 19 ) ;
19812: LD_STRING ACH_AMER
19814: PPUSH
19815: LD_INT 19
19817: PPUSH
19818: CALL_OW 564
// GiveMedals ( MAIN ) ;
19822: LD_STRING MAIN
19824: PPUSH
19825: CALL_OW 102
// InGameOff ;
19829: CALL_OW 9
// DialogueOff ;
19833: CALL_OW 7
// music_nat := 1 ;
19837: LD_ADDR_OWVAR 71
19841: PUSH
19842: LD_INT 1
19844: ST_TO_ADDR
// music_class := 4 ;
19845: LD_ADDR_OWVAR 72
19849: PUSH
19850: LD_INT 4
19852: ST_TO_ADDR
// YouWin ;
19853: CALL_OW 103
// end ; end_of_file
19857: PPOPN 2
19859: END
// export function InitNature ; begin
19860: LD_INT 0
19862: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
19863: LD_INT 3
19865: PPUSH
19866: LD_INT 3
19868: PPUSH
19869: LD_INT 2
19871: PPUSH
19872: LD_INT 1
19874: PPUSH
19875: LD_INT 1
19877: PPUSH
19878: LD_INT 0
19880: PPUSH
19881: LD_INT 0
19883: PPUSH
19884: LD_INT 17
19886: PPUSH
19887: LD_INT 0
19889: PPUSH
19890: CALL 89252 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
19894: LD_INT 2
19896: PPUSH
19897: LD_INT 1
19899: PPUSH
19900: LD_INT 1
19902: PPUSH
19903: LD_INT 1
19905: PPUSH
19906: LD_INT 1
19908: PPUSH
19909: LD_INT 0
19911: PPUSH
19912: LD_INT 0
19914: PPUSH
19915: LD_INT 18
19917: PPUSH
19918: LD_INT 0
19920: PPUSH
19921: CALL 89252 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
19925: LD_INT 4
19927: PPUSH
19928: LD_INT 1
19930: PPUSH
19931: LD_INT 2
19933: PPUSH
19934: LD_INT 4
19936: PPUSH
19937: LD_INT 2
19939: PPUSH
19940: LD_INT 1
19942: PPUSH
19943: LD_INT 0
19945: PPUSH
19946: LD_INT 19
19948: PPUSH
19949: LD_INT 0
19951: PPUSH
19952: CALL 89252 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
19956: LD_INT 0
19958: PPUSH
19959: LD_INT 0
19961: PPUSH
19962: LD_INT 0
19964: PPUSH
19965: LD_INT 0
19967: PPUSH
19968: LD_INT 0
19970: PPUSH
19971: LD_INT 0
19973: PPUSH
19974: LD_INT 9
19976: PPUSH
19977: LD_INT 0
19979: PPUSH
19980: LD_INT 20
19982: PPUSH
19983: CALL 89252 0 9
// end ; end_of_file
19987: LD_VAR 0 1
19991: RET
// every 0 0$30 do var time ;
19992: GO 19994
19994: DISABLE
19995: LD_INT 0
19997: PPUSH
// begin time := 0 0$30 ;
19998: LD_ADDR_VAR 0 1
20002: PUSH
20003: LD_INT 1050
20005: ST_TO_ADDR
// repeat wait ( time ) ;
20006: LD_VAR 0 1
20010: PPUSH
20011: CALL_OW 67
// if Prob ( 50 ) then
20015: LD_INT 50
20017: PPUSH
20018: CALL_OW 13
20022: IFFALSE 20051
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
20024: LD_INT 1
20026: PPUSH
20027: LD_INT 5
20029: PPUSH
20030: CALL_OW 12
20034: PPUSH
20035: LD_INT 106
20037: PPUSH
20038: LD_INT 89
20040: PPUSH
20041: LD_INT 45
20043: PPUSH
20044: LD_INT 1
20046: PPUSH
20047: CALL_OW 56
// time := time + 0 0$3 ;
20051: LD_ADDR_VAR 0 1
20055: PUSH
20056: LD_VAR 0 1
20060: PUSH
20061: LD_INT 105
20063: PLUS
20064: ST_TO_ADDR
// if Prob ( 30 ) then
20065: LD_INT 30
20067: PPUSH
20068: CALL_OW 13
20072: IFFALSE 20118
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
20074: LD_INT 525
20076: PPUSH
20077: LD_INT 735
20079: PPUSH
20080: CALL_OW 12
20084: PPUSH
20085: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
20089: LD_INT 1
20091: PPUSH
20092: LD_INT 5
20094: PPUSH
20095: CALL_OW 12
20099: PPUSH
20100: LD_INT 21
20102: PPUSH
20103: LD_INT 26
20105: PPUSH
20106: LD_INT 12
20108: PPUSH
20109: LD_INT 1
20111: PPUSH
20112: CALL_OW 56
// end else
20116: GO 20154
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
20118: LD_INT 700
20120: PPUSH
20121: LD_INT 1225
20123: PPUSH
20124: CALL_OW 12
20128: PPUSH
20129: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
20133: LD_INT 1
20135: PPUSH
20136: LD_INT 5
20138: PPUSH
20139: CALL_OW 12
20143: PPUSH
20144: LD_INT 14
20146: PPUSH
20147: LD_INT 1
20149: PPUSH
20150: CALL_OW 55
// end ; if Prob ( 50 ) then
20154: LD_INT 50
20156: PPUSH
20157: CALL_OW 13
20161: IFFALSE 20207
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
20163: LD_INT 700
20165: PPUSH
20166: LD_INT 1050
20168: PPUSH
20169: CALL_OW 12
20173: PPUSH
20174: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
20178: LD_INT 1
20180: PPUSH
20181: LD_INT 5
20183: PPUSH
20184: CALL_OW 12
20188: PPUSH
20189: LD_INT 181
20191: PPUSH
20192: LD_INT 218
20194: PPUSH
20195: LD_INT 16
20197: PPUSH
20198: LD_INT 1
20200: PPUSH
20201: CALL_OW 56
// end else
20205: GO 20279
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
20207: LD_INT 350
20209: PPUSH
20210: LD_INT 525
20212: PPUSH
20213: CALL_OW 12
20217: PPUSH
20218: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
20222: LD_INT 1
20224: PPUSH
20225: LD_INT 5
20227: PPUSH
20228: CALL_OW 12
20232: PPUSH
20233: LD_INT 13
20235: PPUSH
20236: LD_INT 1
20238: PPUSH
20239: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
20243: LD_INT 350
20245: PPUSH
20246: LD_INT 700
20248: PPUSH
20249: CALL_OW 12
20253: PPUSH
20254: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
20258: LD_INT 1
20260: PPUSH
20261: LD_INT 5
20263: PPUSH
20264: CALL_OW 12
20268: PPUSH
20269: LD_INT 33
20271: PPUSH
20272: LD_INT 1
20274: PPUSH
20275: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
20279: LD_INT 65
20281: PUSH
20282: LD_INT 62
20284: PUSH
20285: LD_INT 55
20287: PUSH
20288: LD_INT 50
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: LIST
20295: LIST
20296: PUSH
20297: LD_OWVAR 67
20301: ARRAY
20302: PPUSH
20303: CALL_OW 13
20307: IFFALSE 20353
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
20309: LD_INT 525
20311: PPUSH
20312: LD_INT 875
20314: PPUSH
20315: CALL_OW 12
20319: PPUSH
20320: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
20324: LD_INT 1
20326: PPUSH
20327: LD_INT 5
20329: PPUSH
20330: CALL_OW 12
20334: PPUSH
20335: LD_INT 294
20337: PPUSH
20338: LD_INT 211
20340: PPUSH
20341: LD_INT 30
20343: PPUSH
20344: LD_INT 1
20346: PPUSH
20347: CALL_OW 56
// end else
20351: GO 20395
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
20353: LD_INT 420
20355: PPUSH
20356: LD_INT 770
20358: PPUSH
20359: CALL_OW 12
20363: PPUSH
20364: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
20368: LD_INT 1
20370: PPUSH
20371: LD_INT 5
20373: PPUSH
20374: CALL_OW 12
20378: PPUSH
20379: LD_INT 294
20381: PPUSH
20382: LD_INT 211
20384: PPUSH
20385: LD_INT 30
20387: PPUSH
20388: LD_INT 1
20390: PPUSH
20391: CALL_OW 56
// end ; if time > 2 2$20 then
20395: LD_VAR 0 1
20399: PUSH
20400: LD_INT 4900
20402: GREATER
20403: IFFALSE 20413
// time := 0 0$50 ;
20405: LD_ADDR_VAR 0 1
20409: PUSH
20410: LD_INT 1750
20412: ST_TO_ADDR
// until false ;
20413: LD_INT 0
20415: IFFALSE 20006
// end ;
20417: PPOPN 1
20419: END
// every 0 0$45 trigger tick < 10 10$00 do
20420: LD_OWVAR 1
20424: PUSH
20425: LD_INT 21000
20427: LESS
20428: IFFALSE 20476
20430: GO 20432
20432: DISABLE
// begin enable ;
20433: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
20434: LD_INT 350
20436: PPUSH
20437: LD_INT 700
20439: PPUSH
20440: CALL_OW 12
20444: PPUSH
20445: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
20449: LD_INT 3
20451: PPUSH
20452: LD_INT 5
20454: PPUSH
20455: CALL_OW 12
20459: PPUSH
20460: LD_INT 181
20462: PPUSH
20463: LD_INT 13
20465: PPUSH
20466: LD_INT 20
20468: PPUSH
20469: LD_INT 1
20471: PPUSH
20472: CALL_OW 56
// end ; end_of_file
20476: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
20477: LD_INT 0
20479: PPUSH
// SetArtifactRes ( 7 , true ) ;
20480: LD_INT 7
20482: PPUSH
20483: LD_INT 1
20485: PPUSH
20486: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
20490: LD_ADDR_EXP 68
20494: PUSH
20495: EMPTY
20496: PUSH
20497: EMPTY
20498: PUSH
20499: EMPTY
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: LIST
20505: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
20506: LD_ADDR_EXP 69
20510: PUSH
20511: LD_INT 1050
20513: PUSH
20514: LD_OWVAR 67
20518: MUL
20519: PUSH
20520: LD_INT 2800
20522: PUSH
20523: LD_OWVAR 67
20527: MUL
20528: PUSH
20529: LD_INT 1
20531: NEG
20532: PUSH
20533: EMPTY
20534: LIST
20535: LIST
20536: LIST
20537: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
20538: LD_ADDR_EXP 70
20542: PUSH
20543: LD_INT 10
20545: PUSH
20546: LD_INT 35
20548: PUSH
20549: LD_INT 100
20551: PUSH
20552: EMPTY
20553: LIST
20554: LIST
20555: LIST
20556: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
20557: LD_ADDR_EXP 71
20561: PUSH
20562: LD_INT 0
20564: PUSH
20565: LD_INT 0
20567: PUSH
20568: LD_INT 0
20570: PUSH
20571: EMPTY
20572: LIST
20573: LIST
20574: LIST
20575: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
20576: LD_ADDR_EXP 73
20580: PUSH
20581: LD_INT 300
20583: PUSH
20584: LD_INT 500
20586: PUSH
20587: LD_INT 800
20589: PUSH
20590: EMPTY
20591: LIST
20592: LIST
20593: LIST
20594: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
20595: LD_ADDR_EXP 74
20599: PUSH
20600: LD_INT 0
20602: PUSH
20603: LD_INT 0
20605: PUSH
20606: LD_INT 0
20608: PUSH
20609: EMPTY
20610: LIST
20611: LIST
20612: LIST
20613: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
20614: LD_ADDR_EXP 75
20618: PUSH
20619: LD_INT 0
20621: PUSH
20622: LD_INT 0
20624: PUSH
20625: LD_INT 0
20627: PUSH
20628: EMPTY
20629: LIST
20630: LIST
20631: LIST
20632: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
20633: LD_ADDR_EXP 72
20637: PUSH
20638: LD_INT 0
20640: PUSH
20641: LD_INT 0
20643: PUSH
20644: LD_INT 0
20646: PUSH
20647: EMPTY
20648: LIST
20649: LIST
20650: LIST
20651: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
20652: LD_ADDR_EXP 76
20656: PUSH
20657: LD_INT 4
20659: PUSH
20660: LD_INT 3
20662: PUSH
20663: LD_INT 1
20665: PUSH
20666: EMPTY
20667: LIST
20668: LIST
20669: LIST
20670: PUSH
20671: LD_INT 5
20673: PUSH
20674: LD_INT 4
20676: PUSH
20677: LD_INT 2
20679: PUSH
20680: EMPTY
20681: LIST
20682: LIST
20683: LIST
20684: PUSH
20685: LD_INT 6
20687: PUSH
20688: LD_INT 3
20690: PUSH
20691: LD_INT 3
20693: PUSH
20694: EMPTY
20695: LIST
20696: LIST
20697: LIST
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: LIST
20703: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
20704: LD_ADDR_EXP 77
20708: PUSH
20709: LD_INT 0
20711: PUSH
20712: LD_INT 0
20714: PUSH
20715: LD_INT 0
20717: PUSH
20718: EMPTY
20719: LIST
20720: LIST
20721: LIST
20722: ST_TO_ADDR
// end ;
20723: LD_VAR 0 1
20727: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
20728: LD_INT 24
20730: PPUSH
20731: LD_INT 7
20733: PPUSH
20734: CALL_OW 321
20738: PUSH
20739: LD_INT 2
20741: EQUAL
20742: IFFALSE 21672
20744: GO 20746
20746: DISABLE
20747: LD_INT 0
20749: PPUSH
20750: PPUSH
20751: PPUSH
20752: PPUSH
20753: PPUSH
// begin enable ;
20754: ENABLE
// for i = 1 to 3 do
20755: LD_ADDR_VAR 0 1
20759: PUSH
20760: DOUBLE
20761: LD_INT 1
20763: DEC
20764: ST_TO_ADDR
20765: LD_INT 3
20767: PUSH
20768: FOR_TO
20769: IFFALSE 21670
// begin pos := FindArtifact ( i + 2 ) ;
20771: LD_ADDR_VAR 0 2
20775: PUSH
20776: LD_VAR 0 1
20780: PUSH
20781: LD_INT 2
20783: PLUS
20784: PPUSH
20785: CALL_OW 469
20789: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
20790: LD_ADDR_EXP 68
20794: PUSH
20795: LD_EXP 68
20799: PPUSH
20800: LD_VAR 0 1
20804: PPUSH
20805: LD_VAR 0 2
20809: PPUSH
20810: CALL_OW 1
20814: ST_TO_ADDR
// if pos then
20815: LD_VAR 0 2
20819: IFFALSE 21531
// begin case i of 1 :
20821: LD_VAR 0 1
20825: PUSH
20826: LD_INT 1
20828: DOUBLE
20829: EQUAL
20830: IFTRUE 20834
20832: GO 20911
20834: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
20835: LD_ADDR_VAR 0 4
20839: PUSH
20840: LD_INT 22
20842: PUSH
20843: LD_INT 7
20845: PUSH
20846: EMPTY
20847: LIST
20848: LIST
20849: PUSH
20850: LD_INT 23
20852: PUSH
20853: LD_INT 1
20855: PUSH
20856: EMPTY
20857: LIST
20858: LIST
20859: PUSH
20860: LD_INT 2
20862: PUSH
20863: LD_INT 30
20865: PUSH
20866: LD_INT 8
20868: PUSH
20869: EMPTY
20870: LIST
20871: LIST
20872: PUSH
20873: LD_INT 30
20875: PUSH
20876: LD_INT 7
20878: PUSH
20879: EMPTY
20880: LIST
20881: LIST
20882: PUSH
20883: LD_INT 30
20885: PUSH
20886: LD_INT 11
20888: PUSH
20889: EMPTY
20890: LIST
20891: LIST
20892: PUSH
20893: EMPTY
20894: LIST
20895: LIST
20896: LIST
20897: LIST
20898: PUSH
20899: EMPTY
20900: LIST
20901: LIST
20902: LIST
20903: PPUSH
20904: CALL_OW 69
20908: ST_TO_ADDR
20909: GO 21019
20911: LD_INT 2
20913: DOUBLE
20914: EQUAL
20915: IFTRUE 20919
20917: GO 20996
20919: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
20920: LD_ADDR_VAR 0 4
20924: PUSH
20925: LD_INT 22
20927: PUSH
20928: LD_INT 7
20930: PUSH
20931: EMPTY
20932: LIST
20933: LIST
20934: PUSH
20935: LD_INT 23
20937: PUSH
20938: LD_INT 3
20940: PUSH
20941: EMPTY
20942: LIST
20943: LIST
20944: PUSH
20945: LD_INT 2
20947: PUSH
20948: LD_INT 30
20950: PUSH
20951: LD_INT 8
20953: PUSH
20954: EMPTY
20955: LIST
20956: LIST
20957: PUSH
20958: LD_INT 30
20960: PUSH
20961: LD_INT 7
20963: PUSH
20964: EMPTY
20965: LIST
20966: LIST
20967: PUSH
20968: LD_INT 30
20970: PUSH
20971: LD_INT 11
20973: PUSH
20974: EMPTY
20975: LIST
20976: LIST
20977: PUSH
20978: EMPTY
20979: LIST
20980: LIST
20981: LIST
20982: LIST
20983: PUSH
20984: EMPTY
20985: LIST
20986: LIST
20987: LIST
20988: PPUSH
20989: CALL_OW 69
20993: ST_TO_ADDR
20994: GO 21019
20996: LD_INT 3
20998: DOUBLE
20999: EQUAL
21000: IFTRUE 21004
21002: GO 21018
21004: POP
// labs := [ alien ] ; end ;
21005: LD_ADDR_VAR 0 4
21009: PUSH
21010: LD_INT 1
21012: PUSH
21013: EMPTY
21014: LIST
21015: ST_TO_ADDR
21016: GO 21019
21018: POP
// if not labs then
21019: LD_VAR 0 4
21023: NOT
21024: IFFALSE 21028
// continue ;
21026: GO 20768
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
21028: LD_ADDR_VAR 0 5
21032: PUSH
21033: LD_VAR 0 4
21037: PPUSH
21038: LD_EXP 68
21042: PUSH
21043: LD_VAR 0 1
21047: ARRAY
21048: PUSH
21049: LD_INT 1
21051: ARRAY
21052: PPUSH
21053: LD_EXP 68
21057: PUSH
21058: LD_VAR 0 1
21062: ARRAY
21063: PUSH
21064: LD_INT 2
21066: ARRAY
21067: PPUSH
21068: CALL_OW 73
21072: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
21073: LD_VAR 0 5
21077: NOT
21078: IFTRUE 21098
21080: PUSH
21081: LD_VAR 0 5
21085: PUSH
21086: LD_EXP 75
21090: PUSH
21091: LD_VAR 0 1
21095: ARRAY
21096: NONEQUAL
21097: OR
21098: IFFALSE 21203
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
21100: LD_INT 7
21102: PPUSH
21103: LD_EXP 76
21107: PUSH
21108: LD_VAR 0 1
21112: ARRAY
21113: PUSH
21114: LD_INT 3
21116: ARRAY
21117: PPUSH
21118: LD_INT 0
21120: PPUSH
21121: LD_EXP 75
21125: PUSH
21126: LD_VAR 0 1
21130: ARRAY
21131: PPUSH
21132: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
21136: LD_INT 7
21138: PPUSH
21139: LD_EXP 76
21143: PUSH
21144: LD_VAR 0 1
21148: ARRAY
21149: PUSH
21150: LD_INT 1
21152: ARRAY
21153: PPUSH
21154: LD_INT 0
21156: PPUSH
21157: LD_EXP 75
21161: PUSH
21162: LD_VAR 0 1
21166: ARRAY
21167: PPUSH
21168: CALL_OW 468
// if nearestLab then
21172: LD_VAR 0 5
21176: IFFALSE 21203
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
21178: LD_ADDR_EXP 75
21182: PUSH
21183: LD_EXP 75
21187: PPUSH
21188: LD_VAR 0 1
21192: PPUSH
21193: LD_VAR 0 5
21197: PPUSH
21198: CALL_OW 1
21202: ST_TO_ADDR
// end ; if not nearestLab then
21203: LD_VAR 0 5
21207: NOT
21208: IFFALSE 21212
// continue ;
21210: GO 20768
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
21212: LD_VAR 0 5
21216: PPUSH
21217: LD_EXP 68
21221: PUSH
21222: LD_VAR 0 1
21226: ARRAY
21227: PUSH
21228: LD_INT 1
21230: ARRAY
21231: PPUSH
21232: LD_EXP 68
21236: PUSH
21237: LD_VAR 0 1
21241: ARRAY
21242: PUSH
21243: LD_INT 2
21245: ARRAY
21246: PPUSH
21247: CALL_OW 297
21251: PUSH
21252: LD_INT 8
21254: LESS
21255: IFFALSE 21454
// begin if not artifactsResearched [ i ] then
21257: LD_EXP 71
21261: PUSH
21262: LD_VAR 0 1
21266: ARRAY
21267: NOT
21268: IFFALSE 21349
// begin if BuildingStatus ( nearestLab ) = bs_idle then
21270: LD_VAR 0 5
21274: PPUSH
21275: CALL_OW 461
21279: PUSH
21280: LD_INT 2
21282: EQUAL
21283: IFFALSE 21317
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
21285: LD_INT 7
21287: PPUSH
21288: LD_EXP 76
21292: PUSH
21293: LD_VAR 0 1
21297: ARRAY
21298: PUSH
21299: LD_INT 3
21301: ARRAY
21302: PPUSH
21303: LD_INT 2
21305: PPUSH
21306: LD_VAR 0 5
21310: PPUSH
21311: CALL_OW 468
21315: GO 21347
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
21317: LD_INT 7
21319: PPUSH
21320: LD_EXP 76
21324: PUSH
21325: LD_VAR 0 1
21329: ARRAY
21330: PUSH
21331: LD_INT 3
21333: ARRAY
21334: PPUSH
21335: LD_INT 1
21337: PPUSH
21338: LD_VAR 0 5
21342: PPUSH
21343: CALL_OW 468
// end else
21347: GO 21452
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
21349: LD_VAR 0 5
21353: PPUSH
21354: CALL_OW 461
21358: PUSH
21359: LD_INT 2
21361: EQUAL
21362: IFFALSE 21376
21364: PUSH
21365: LD_EXP 77
21369: PUSH
21370: LD_VAR 0 1
21374: ARRAY
21375: AND
21376: IFFALSE 21422
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
21378: LD_INT 7
21380: PPUSH
21381: LD_EXP 76
21385: PUSH
21386: LD_VAR 0 1
21390: ARRAY
21391: PUSH
21392: LD_INT 1
21394: ARRAY
21395: PPUSH
21396: LD_EXP 76
21400: PUSH
21401: LD_VAR 0 1
21405: ARRAY
21406: PUSH
21407: LD_INT 2
21409: ARRAY
21410: PPUSH
21411: LD_VAR 0 5
21415: PPUSH
21416: CALL_OW 468
21420: GO 21452
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
21422: LD_INT 7
21424: PPUSH
21425: LD_EXP 76
21429: PUSH
21430: LD_VAR 0 1
21434: ARRAY
21435: PUSH
21436: LD_INT 1
21438: ARRAY
21439: PPUSH
21440: LD_INT 1
21442: PPUSH
21443: LD_VAR 0 5
21447: PPUSH
21448: CALL_OW 468
// end else
21452: GO 21529
// begin if not artifactsResearched [ i ] then
21454: LD_EXP 71
21458: PUSH
21459: LD_VAR 0 1
21463: ARRAY
21464: NOT
21465: IFFALSE 21499
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
21467: LD_INT 7
21469: PPUSH
21470: LD_EXP 76
21474: PUSH
21475: LD_VAR 0 1
21479: ARRAY
21480: PUSH
21481: LD_INT 3
21483: ARRAY
21484: PPUSH
21485: LD_INT 0
21487: PPUSH
21488: LD_VAR 0 5
21492: PPUSH
21493: CALL_OW 468
21497: GO 21529
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
21499: LD_INT 7
21501: PPUSH
21502: LD_EXP 76
21506: PUSH
21507: LD_VAR 0 1
21511: ARRAY
21512: PUSH
21513: LD_INT 1
21515: ARRAY
21516: PPUSH
21517: LD_INT 0
21519: PPUSH
21520: LD_VAR 0 5
21524: PPUSH
21525: CALL_OW 468
// end ; end else
21529: GO 21668
// begin if not artifactsLabs [ i ] then
21531: LD_EXP 75
21535: PUSH
21536: LD_VAR 0 1
21540: ARRAY
21541: NOT
21542: IFFALSE 21546
// continue ;
21544: GO 20768
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
21546: LD_INT 7
21548: PPUSH
21549: LD_EXP 76
21553: PUSH
21554: LD_VAR 0 1
21558: ARRAY
21559: PUSH
21560: LD_INT 3
21562: ARRAY
21563: PPUSH
21564: LD_INT 0
21566: PPUSH
21567: LD_EXP 75
21571: PUSH
21572: LD_VAR 0 1
21576: ARRAY
21577: PPUSH
21578: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
21582: LD_INT 7
21584: PPUSH
21585: LD_EXP 76
21589: PUSH
21590: LD_VAR 0 1
21594: ARRAY
21595: PUSH
21596: LD_INT 1
21598: ARRAY
21599: PPUSH
21600: LD_INT 0
21602: PPUSH
21603: LD_EXP 75
21607: PUSH
21608: LD_VAR 0 1
21612: ARRAY
21613: PPUSH
21614: CALL_OW 468
// if artifactsLabsWorking [ i ] then
21618: LD_EXP 72
21622: PUSH
21623: LD_VAR 0 1
21627: ARRAY
21628: IFFALSE 21668
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
21630: LD_ADDR_EXP 72
21634: PUSH
21635: LD_EXP 72
21639: PPUSH
21640: LD_VAR 0 1
21644: PPUSH
21645: LD_INT 0
21647: PPUSH
21648: CALL_OW 1
21652: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
21653: LD_EXP 75
21657: PUSH
21658: LD_VAR 0 1
21662: ARRAY
21663: PPUSH
21664: CALL_OW 127
// end ; end ; end ;
21668: GO 20768
21670: POP
21671: POP
// end ;
21672: PPOPN 5
21674: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un , base ;
21675: LD_INT 0
21677: PPUSH
21678: PPUSH
21679: PPUSH
21680: PPUSH
21681: PPUSH
21682: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
21683: LD_VAR 0 2
21687: PUSH
21688: LD_EXP 76
21692: PUSH
21693: LD_INT 1
21695: ARRAY
21696: PUSH
21697: LD_INT 3
21699: ARRAY
21700: EQUAL
21701: IFFALSE 21824
// begin lab := artifactsLabs [ 1 ] ;
21703: LD_ADDR_VAR 0 6
21707: PUSH
21708: LD_EXP 75
21712: PUSH
21713: LD_INT 1
21715: ARRAY
21716: ST_TO_ADDR
// if not lab then
21717: LD_VAR 0 6
21721: NOT
21722: IFFALSE 21726
// exit ;
21724: GO 22954
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
21726: LD_VAR 0 6
21730: PPUSH
21731: LD_EXP 73
21735: PUSH
21736: LD_INT 1
21738: ARRAY
21739: PPUSH
21740: LD_INT 1
21742: PPUSH
21743: CALL_OW 486
// if artifactsResProgress [ 1 ] then
21747: LD_EXP 74
21751: PUSH
21752: LD_INT 1
21754: ARRAY
21755: IFFALSE 21775
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
21757: LD_VAR 0 6
21761: PPUSH
21762: LD_EXP 74
21766: PUSH
21767: LD_INT 1
21769: ARRAY
21770: PPUSH
21771: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
21775: LD_ADDR_EXP 72
21779: PUSH
21780: LD_EXP 72
21784: PPUSH
21785: LD_INT 1
21787: PPUSH
21788: LD_INT 1
21790: PPUSH
21791: CALL_OW 1
21795: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
21796: LD_INT 7
21798: PPUSH
21799: LD_EXP 76
21803: PUSH
21804: LD_INT 1
21806: ARRAY
21807: PUSH
21808: LD_INT 3
21810: ARRAY
21811: PPUSH
21812: LD_INT 0
21814: PPUSH
21815: LD_VAR 0 6
21819: PPUSH
21820: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
21824: LD_VAR 0 2
21828: PUSH
21829: LD_EXP 76
21833: PUSH
21834: LD_INT 2
21836: ARRAY
21837: PUSH
21838: LD_INT 3
21840: ARRAY
21841: EQUAL
21842: IFFALSE 21965
// begin lab := artifactsLabs [ 2 ] ;
21844: LD_ADDR_VAR 0 6
21848: PUSH
21849: LD_EXP 75
21853: PUSH
21854: LD_INT 2
21856: ARRAY
21857: ST_TO_ADDR
// if not lab then
21858: LD_VAR 0 6
21862: NOT
21863: IFFALSE 21867
// exit ;
21865: GO 22954
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
21867: LD_VAR 0 6
21871: PPUSH
21872: LD_EXP 73
21876: PUSH
21877: LD_INT 2
21879: ARRAY
21880: PPUSH
21881: LD_INT 1
21883: PPUSH
21884: CALL_OW 486
// if artifactsResProgress [ 2 ] then
21888: LD_EXP 74
21892: PUSH
21893: LD_INT 2
21895: ARRAY
21896: IFFALSE 21916
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
21898: LD_VAR 0 6
21902: PPUSH
21903: LD_EXP 74
21907: PUSH
21908: LD_INT 2
21910: ARRAY
21911: PPUSH
21912: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
21916: LD_ADDR_EXP 72
21920: PUSH
21921: LD_EXP 72
21925: PPUSH
21926: LD_INT 2
21928: PPUSH
21929: LD_INT 1
21931: PPUSH
21932: CALL_OW 1
21936: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
21937: LD_INT 7
21939: PPUSH
21940: LD_EXP 76
21944: PUSH
21945: LD_INT 2
21947: ARRAY
21948: PUSH
21949: LD_INT 3
21951: ARRAY
21952: PPUSH
21953: LD_INT 0
21955: PPUSH
21956: LD_VAR 0 6
21960: PPUSH
21961: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
21965: LD_VAR 0 2
21969: PUSH
21970: LD_EXP 76
21974: PUSH
21975: LD_INT 3
21977: ARRAY
21978: PUSH
21979: LD_INT 3
21981: ARRAY
21982: EQUAL
21983: IFFALSE 22106
// begin lab := artifactsLabs [ 3 ] ;
21985: LD_ADDR_VAR 0 6
21989: PUSH
21990: LD_EXP 75
21994: PUSH
21995: LD_INT 3
21997: ARRAY
21998: ST_TO_ADDR
// if not lab then
21999: LD_VAR 0 6
22003: NOT
22004: IFFALSE 22008
// exit ;
22006: GO 22954
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
22008: LD_VAR 0 6
22012: PPUSH
22013: LD_EXP 73
22017: PUSH
22018: LD_INT 3
22020: ARRAY
22021: PPUSH
22022: LD_INT 1
22024: PPUSH
22025: CALL_OW 486
// if artifactsResProgress [ 3 ] then
22029: LD_EXP 74
22033: PUSH
22034: LD_INT 3
22036: ARRAY
22037: IFFALSE 22057
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
22039: LD_VAR 0 6
22043: PPUSH
22044: LD_EXP 74
22048: PUSH
22049: LD_INT 3
22051: ARRAY
22052: PPUSH
22053: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
22057: LD_ADDR_EXP 72
22061: PUSH
22062: LD_EXP 72
22066: PPUSH
22067: LD_INT 3
22069: PPUSH
22070: LD_INT 1
22072: PPUSH
22073: CALL_OW 1
22077: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
22078: LD_INT 7
22080: PPUSH
22081: LD_EXP 76
22085: PUSH
22086: LD_INT 3
22088: ARRAY
22089: PUSH
22090: LD_INT 3
22092: ARRAY
22093: PPUSH
22094: LD_INT 0
22096: PPUSH
22097: LD_VAR 0 6
22101: PPUSH
22102: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
22106: LD_VAR 0 2
22110: PUSH
22111: LD_EXP 76
22115: PUSH
22116: LD_INT 1
22118: ARRAY
22119: PUSH
22120: LD_INT 1
22122: ARRAY
22123: EQUAL
22124: IFFALSE 22332
// begin lab := artifactsLabs [ 1 ] ;
22126: LD_ADDR_VAR 0 6
22130: PUSH
22131: LD_EXP 75
22135: PUSH
22136: LD_INT 1
22138: ARRAY
22139: ST_TO_ADDR
// base := GetBase ( lab ) ;
22140: LD_ADDR_VAR 0 10
22144: PUSH
22145: LD_VAR 0 6
22149: PPUSH
22150: CALL_OW 274
22154: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
22155: LD_VAR 0 6
22159: PPUSH
22160: CALL_OW 274
22164: PPUSH
22165: CALL 92831 0 1
22169: PUSH
22170: LD_INT 3
22172: ARRAY
22173: PUSH
22174: LD_EXP 70
22178: PUSH
22179: LD_INT 1
22181: ARRAY
22182: LESS
22183: IFFALSE 22197
// begin HintSpec ( ArtifactCost , 2 ) ;
22185: LD_STRING ArtifactCost
22187: PPUSH
22188: LD_INT 2
22190: PPUSH
22191: CALL_OW 338
// exit ;
22195: GO 22954
// end ; SetResourceType ( base , mat_siberit , ( GetResourceType ( base , mat_siberit ) - artifactsSibCost [ 1 ] ) ) ;
22197: LD_VAR 0 10
22201: PPUSH
22202: LD_INT 3
22204: PPUSH
22205: LD_VAR 0 10
22209: PPUSH
22210: LD_INT 3
22212: PPUSH
22213: CALL_OW 275
22217: PUSH
22218: LD_EXP 70
22222: PUSH
22223: LD_INT 1
22225: ARRAY
22226: MINUS
22227: PPUSH
22228: CALL_OW 277
// artifactsReady := Replace ( artifactsReady , 1 , false ) ;
22232: LD_ADDR_EXP 77
22236: PUSH
22237: LD_EXP 77
22241: PPUSH
22242: LD_INT 1
22244: PPUSH
22245: LD_INT 0
22247: PPUSH
22248: CALL_OW 1
22252: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
22253: LD_VAR 0 3
22257: PPUSH
22258: LD_VAR 0 4
22262: PPUSH
22263: LD_INT 7
22265: PPUSH
22266: LD_INT 12
22268: NEG
22269: PPUSH
22270: CALL_OW 330
// wait ( 0 0$30 ) ;
22274: LD_INT 1050
22276: PPUSH
22277: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
22281: LD_VAR 0 3
22285: PPUSH
22286: LD_VAR 0 4
22290: PPUSH
22291: LD_INT 7
22293: PPUSH
22294: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
22298: LD_EXP 69
22302: PUSH
22303: LD_INT 1
22305: ARRAY
22306: PPUSH
22307: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
22311: LD_ADDR_EXP 77
22315: PUSH
22316: LD_EXP 77
22320: PPUSH
22321: LD_INT 1
22323: PPUSH
22324: LD_INT 1
22326: PPUSH
22327: CALL_OW 1
22331: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
22332: LD_VAR 0 2
22336: PUSH
22337: LD_EXP 76
22341: PUSH
22342: LD_INT 2
22344: ARRAY
22345: PUSH
22346: LD_INT 1
22348: ARRAY
22349: EQUAL
22350: IFFALSE 22637
// begin lab := artifactsLabs [ 2 ] ;
22352: LD_ADDR_VAR 0 6
22356: PUSH
22357: LD_EXP 75
22361: PUSH
22362: LD_INT 2
22364: ARRAY
22365: ST_TO_ADDR
// base := GetBase ( lab ) ;
22366: LD_ADDR_VAR 0 10
22370: PUSH
22371: LD_VAR 0 6
22375: PPUSH
22376: CALL_OW 274
22380: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
22381: LD_VAR 0 3
22385: PUSH
22386: LD_INT 81
22388: PUSH
22389: LD_INT 7
22391: PUSH
22392: EMPTY
22393: LIST
22394: LIST
22395: PUSH
22396: LD_INT 2
22398: PUSH
22399: LD_INT 32
22401: PUSH
22402: LD_INT 3
22404: PUSH
22405: EMPTY
22406: LIST
22407: LIST
22408: PUSH
22409: LD_INT 30
22411: PUSH
22412: LD_INT 28
22414: PUSH
22415: EMPTY
22416: LIST
22417: LIST
22418: PUSH
22419: LD_INT 30
22421: PUSH
22422: LD_INT 30
22424: PUSH
22425: EMPTY
22426: LIST
22427: LIST
22428: PUSH
22429: LD_INT 35
22431: PUSH
22432: LD_INT 49
22434: PUSH
22435: EMPTY
22436: LIST
22437: LIST
22438: PUSH
22439: LD_INT 34
22441: PUSH
22442: LD_INT 49
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: PUSH
22449: LD_INT 30
22451: PUSH
22452: LD_INT 21
22454: PUSH
22455: EMPTY
22456: LIST
22457: LIST
22458: PUSH
22459: EMPTY
22460: LIST
22461: LIST
22462: LIST
22463: LIST
22464: LIST
22465: LIST
22466: LIST
22467: PUSH
22468: EMPTY
22469: LIST
22470: LIST
22471: PPUSH
22472: CALL_OW 69
22476: IN
22477: NOT
22478: IFFALSE 22482
// exit ;
22480: GO 22954
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
22482: LD_VAR 0 6
22486: PPUSH
22487: CALL_OW 274
22491: PPUSH
22492: CALL 92831 0 1
22496: PUSH
22497: LD_INT 3
22499: ARRAY
22500: PUSH
22501: LD_EXP 70
22505: PUSH
22506: LD_INT 2
22508: ARRAY
22509: LESS
22510: IFFALSE 22524
// begin HintSpec ( ArtifactCost , 2 ) ;
22512: LD_STRING ArtifactCost
22514: PPUSH
22515: LD_INT 2
22517: PPUSH
22518: CALL_OW 338
// exit ;
22522: GO 22954
// end ; SetResourceType ( base , mat_siberit , ( GetResourceType ( base , mat_siberit ) - artifactsSibCost [ 2 ] ) ) ;
22524: LD_VAR 0 10
22528: PPUSH
22529: LD_INT 3
22531: PPUSH
22532: LD_VAR 0 10
22536: PPUSH
22537: LD_INT 3
22539: PPUSH
22540: CALL_OW 275
22544: PUSH
22545: LD_EXP 70
22549: PUSH
22550: LD_INT 2
22552: ARRAY
22553: MINUS
22554: PPUSH
22555: CALL_OW 277
// artifactsReady := Replace ( artifactsReady , 2 , false ) ;
22559: LD_ADDR_EXP 77
22563: PUSH
22564: LD_EXP 77
22568: PPUSH
22569: LD_INT 2
22571: PPUSH
22572: LD_INT 0
22574: PPUSH
22575: CALL_OW 1
22579: ST_TO_ADDR
// KillUnit ( x ) ;
22580: LD_VAR 0 3
22584: PPUSH
22585: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
22589: LD_ADDR_EXP 16
22593: PUSH
22594: LD_EXP 16
22598: PUSH
22599: LD_INT 1
22601: PLUS
22602: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
22603: LD_EXP 69
22607: PUSH
22608: LD_INT 2
22610: ARRAY
22611: PPUSH
22612: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
22616: LD_ADDR_EXP 77
22620: PUSH
22621: LD_EXP 77
22625: PPUSH
22626: LD_INT 2
22628: PPUSH
22629: LD_INT 1
22631: PPUSH
22632: CALL_OW 1
22636: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
22637: LD_VAR 0 2
22641: PUSH
22642: LD_EXP 76
22646: PUSH
22647: LD_INT 3
22649: ARRAY
22650: PUSH
22651: LD_INT 1
22653: ARRAY
22654: EQUAL
22655: IFFALSE 22954
// begin lab := artifactsLabs [ 3 ] ;
22657: LD_ADDR_VAR 0 6
22661: PUSH
22662: LD_EXP 75
22666: PUSH
22667: LD_INT 3
22669: ARRAY
22670: ST_TO_ADDR
// base := GetBase ( lab ) ;
22671: LD_ADDR_VAR 0 10
22675: PUSH
22676: LD_VAR 0 6
22680: PPUSH
22681: CALL_OW 274
22685: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
22686: LD_VAR 0 6
22690: PPUSH
22691: CALL_OW 274
22695: PPUSH
22696: CALL 92831 0 1
22700: PUSH
22701: LD_INT 3
22703: ARRAY
22704: PUSH
22705: LD_EXP 70
22709: PUSH
22710: LD_INT 3
22712: ARRAY
22713: LESS
22714: IFFALSE 22728
// begin HintSpec ( ArtifactCost , 2 ) ;
22716: LD_STRING ArtifactCost
22718: PPUSH
22719: LD_INT 2
22721: PPUSH
22722: CALL_OW 338
// exit ;
22726: GO 22954
// end ; SetResourceType ( base , mat_siberit , ( GetResourceType ( base , mat_siberit ) - artifactsSibCost [ 3 ] ) ) ;
22728: LD_VAR 0 10
22732: PPUSH
22733: LD_INT 3
22735: PPUSH
22736: LD_VAR 0 10
22740: PPUSH
22741: LD_INT 3
22743: PPUSH
22744: CALL_OW 275
22748: PUSH
22749: LD_EXP 70
22753: PUSH
22754: LD_INT 3
22756: ARRAY
22757: MINUS
22758: PPUSH
22759: CALL_OW 277
// SetAreaMapShow ( teleportArea , 1 ) ;
22763: LD_INT 37
22765: PPUSH
22766: LD_INT 1
22768: PPUSH
22769: CALL_OW 424
// time := 0 0$30 ;
22773: LD_ADDR_VAR 0 7
22777: PUSH
22778: LD_INT 1050
22780: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
22781: LD_ADDR_EXP 77
22785: PUSH
22786: LD_EXP 77
22790: PPUSH
22791: LD_INT 3
22793: PPUSH
22794: LD_INT 0
22796: PPUSH
22797: CALL_OW 1
22801: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
22802: LD_ADDR_OWVAR 47
22806: PUSH
22807: LD_STRING #Am15a-1
22809: PUSH
22810: LD_VAR 0 7
22814: PUSH
22815: EMPTY
22816: LIST
22817: LIST
22818: ST_TO_ADDR
// wait ( 0 0$1 ) ;
22819: LD_INT 35
22821: PPUSH
22822: CALL_OW 67
// time := time - 0 0$1 ;
22826: LD_ADDR_VAR 0 7
22830: PUSH
22831: LD_VAR 0 7
22835: PUSH
22836: LD_INT 35
22838: MINUS
22839: ST_TO_ADDR
// until time = 0 0$00 ;
22840: LD_VAR 0 7
22844: PUSH
22845: LD_INT 0
22847: EQUAL
22848: IFFALSE 22802
// display_strings :=  ;
22850: LD_ADDR_OWVAR 47
22854: PUSH
22855: LD_STRING 
22857: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
22858: LD_INT 37
22860: PPUSH
22861: LD_INT 0
22863: PPUSH
22864: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
22868: LD_ADDR_VAR 0 8
22872: PUSH
22873: LD_INT 37
22875: PPUSH
22876: LD_INT 3
22878: PUSH
22879: LD_INT 21
22881: PUSH
22882: LD_INT 3
22884: PUSH
22885: EMPTY
22886: LIST
22887: LIST
22888: PUSH
22889: EMPTY
22890: LIST
22891: LIST
22892: PPUSH
22893: CALL_OW 70
22897: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
22898: LD_VAR 0 3
22902: PPUSH
22903: LD_VAR 0 4
22907: PPUSH
22908: CALL_OW 84
// for un in list do
22912: LD_ADDR_VAR 0 9
22916: PUSH
22917: LD_VAR 0 8
22921: PUSH
22922: FOR_IN
22923: IFFALSE 22952
// TeleportUnit ( un , x , y , 12 , true ) ;
22925: LD_VAR 0 9
22929: PPUSH
22930: LD_VAR 0 3
22934: PPUSH
22935: LD_VAR 0 4
22939: PPUSH
22940: LD_INT 12
22942: PPUSH
22943: LD_INT 1
22945: PPUSH
22946: CALL_OW 483
22950: GO 22922
22952: POP
22953: POP
// end ; end ;
22954: PPOPN 10
22956: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
22957: LD_INT 0
22959: PPUSH
22960: PPUSH
// begin labNum := 0 ;
22961: LD_ADDR_VAR 0 4
22965: PUSH
22966: LD_INT 0
22968: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22969: LD_ADDR_VAR 0 3
22973: PUSH
22974: DOUBLE
22975: LD_INT 1
22977: DEC
22978: ST_TO_ADDR
22979: LD_EXP 75
22983: PUSH
22984: FOR_TO
22985: IFFALSE 23019
// if artifactsLabs [ i ] = lab then
22987: LD_EXP 75
22991: PUSH
22992: LD_VAR 0 3
22996: ARRAY
22997: PUSH
22998: LD_VAR 0 1
23002: EQUAL
23003: IFFALSE 23017
// begin labNum := i ;
23005: LD_ADDR_VAR 0 4
23009: PUSH
23010: LD_VAR 0 3
23014: ST_TO_ADDR
// break ;
23015: GO 23019
// end ;
23017: GO 22984
23019: POP
23020: POP
// if not labNum then
23021: LD_VAR 0 4
23025: NOT
23026: IFFALSE 23030
// exit ;
23028: GO 23108
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
23030: LD_INT 7
23032: PPUSH
23033: LD_EXP 76
23037: PUSH
23038: LD_VAR 0 4
23042: ARRAY
23043: PUSH
23044: LD_INT 3
23046: ARRAY
23047: PPUSH
23048: LD_INT 2
23050: PPUSH
23051: LD_VAR 0 1
23055: PPUSH
23056: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
23060: LD_ADDR_EXP 74
23064: PUSH
23065: LD_EXP 74
23069: PPUSH
23070: LD_VAR 0 4
23074: PPUSH
23075: LD_VAR 0 2
23079: PPUSH
23080: CALL_OW 1
23084: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
23085: LD_ADDR_EXP 72
23089: PUSH
23090: LD_EXP 72
23094: PPUSH
23095: LD_VAR 0 4
23099: PPUSH
23100: LD_INT 0
23102: PPUSH
23103: CALL_OW 1
23107: ST_TO_ADDR
// end ;
23108: PPOPN 4
23110: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
23111: LD_INT 0
23113: PPUSH
23114: PPUSH
// begin labNum := 0 ;
23115: LD_ADDR_VAR 0 3
23119: PUSH
23120: LD_INT 0
23122: ST_TO_ADDR
// for i = 1 to artifactsLabs do
23123: LD_ADDR_VAR 0 2
23127: PUSH
23128: DOUBLE
23129: LD_INT 1
23131: DEC
23132: ST_TO_ADDR
23133: LD_EXP 75
23137: PUSH
23138: FOR_TO
23139: IFFALSE 23173
// if artifactsLabs [ i ] = lab then
23141: LD_EXP 75
23145: PUSH
23146: LD_VAR 0 2
23150: ARRAY
23151: PUSH
23152: LD_VAR 0 1
23156: EQUAL
23157: IFFALSE 23171
// begin labNum := i ;
23159: LD_ADDR_VAR 0 3
23163: PUSH
23164: LD_VAR 0 2
23168: ST_TO_ADDR
// break ;
23169: GO 23173
// end ;
23171: GO 23138
23173: POP
23174: POP
// if not labNum then
23175: LD_VAR 0 3
23179: NOT
23180: IFFALSE 23184
// exit ;
23182: GO 23346
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
23184: LD_INT 7
23186: PPUSH
23187: LD_EXP 76
23191: PUSH
23192: LD_VAR 0 3
23196: ARRAY
23197: PUSH
23198: LD_INT 3
23200: ARRAY
23201: PPUSH
23202: LD_INT 0
23204: PPUSH
23205: LD_VAR 0 1
23209: PPUSH
23210: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
23214: LD_ADDR_EXP 71
23218: PUSH
23219: LD_EXP 71
23223: PPUSH
23224: LD_VAR 0 3
23228: PPUSH
23229: LD_INT 1
23231: PPUSH
23232: CALL_OW 1
23236: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
23237: LD_ADDR_EXP 77
23241: PUSH
23242: LD_EXP 77
23246: PPUSH
23247: LD_VAR 0 3
23251: PPUSH
23252: LD_INT 1
23254: PPUSH
23255: CALL_OW 1
23259: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
23260: LD_ADDR_EXP 72
23264: PUSH
23265: LD_EXP 72
23269: PPUSH
23270: LD_VAR 0 3
23274: PPUSH
23275: LD_INT 0
23277: PPUSH
23278: CALL_OW 1
23282: ST_TO_ADDR
// case labNum of 1 :
23283: LD_VAR 0 3
23287: PUSH
23288: LD_INT 1
23290: DOUBLE
23291: EQUAL
23292: IFTRUE 23296
23294: GO 23307
23296: POP
// artifactIResearched := true ; 2 :
23297: LD_ADDR_EXP 12
23301: PUSH
23302: LD_INT 1
23304: ST_TO_ADDR
23305: GO 23346
23307: LD_INT 2
23309: DOUBLE
23310: EQUAL
23311: IFTRUE 23315
23313: GO 23326
23315: POP
// artifactIIResearched := true ; 3 :
23316: LD_ADDR_EXP 13
23320: PUSH
23321: LD_INT 1
23323: ST_TO_ADDR
23324: GO 23346
23326: LD_INT 3
23328: DOUBLE
23329: EQUAL
23330: IFTRUE 23334
23332: GO 23345
23334: POP
// artifactIIIResearched := true ; end ;
23335: LD_ADDR_EXP 14
23339: PUSH
23340: LD_INT 1
23342: ST_TO_ADDR
23343: GO 23346
23345: POP
// end ; end_of_file
23346: PPOPN 3
23348: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
23349: LD_INT 0
23351: PPUSH
23352: PPUSH
// skirmish := false ;
23353: LD_ADDR_EXP 78
23357: PUSH
23358: LD_INT 0
23360: ST_TO_ADDR
// debug_mc := false ;
23361: LD_ADDR_EXP 79
23365: PUSH
23366: LD_INT 0
23368: ST_TO_ADDR
// mc_bases := [ ] ;
23369: LD_ADDR_EXP 80
23373: PUSH
23374: EMPTY
23375: ST_TO_ADDR
// mc_sides := [ ] ;
23376: LD_ADDR_EXP 106
23380: PUSH
23381: EMPTY
23382: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
23383: LD_ADDR_EXP 81
23387: PUSH
23388: EMPTY
23389: ST_TO_ADDR
// mc_building_repairs := [ ] ;
23390: LD_ADDR_EXP 82
23394: PUSH
23395: EMPTY
23396: ST_TO_ADDR
// mc_need_heal := [ ] ;
23397: LD_ADDR_EXP 83
23401: PUSH
23402: EMPTY
23403: ST_TO_ADDR
// mc_healers := [ ] ;
23404: LD_ADDR_EXP 84
23408: PUSH
23409: EMPTY
23410: ST_TO_ADDR
// mc_build_list := [ ] ;
23411: LD_ADDR_EXP 85
23415: PUSH
23416: EMPTY
23417: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
23418: LD_ADDR_EXP 112
23422: PUSH
23423: EMPTY
23424: ST_TO_ADDR
// mc_builders := [ ] ;
23425: LD_ADDR_EXP 86
23429: PUSH
23430: EMPTY
23431: ST_TO_ADDR
// mc_construct_list := [ ] ;
23432: LD_ADDR_EXP 87
23436: PUSH
23437: EMPTY
23438: ST_TO_ADDR
// mc_turret_list := [ ] ;
23439: LD_ADDR_EXP 88
23443: PUSH
23444: EMPTY
23445: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
23446: LD_ADDR_EXP 89
23450: PUSH
23451: EMPTY
23452: ST_TO_ADDR
// mc_miners := [ ] ;
23453: LD_ADDR_EXP 94
23457: PUSH
23458: EMPTY
23459: ST_TO_ADDR
// mc_mines := [ ] ;
23460: LD_ADDR_EXP 93
23464: PUSH
23465: EMPTY
23466: ST_TO_ADDR
// mc_minefields := [ ] ;
23467: LD_ADDR_EXP 95
23471: PUSH
23472: EMPTY
23473: ST_TO_ADDR
// mc_crates := [ ] ;
23474: LD_ADDR_EXP 96
23478: PUSH
23479: EMPTY
23480: ST_TO_ADDR
// mc_crates_collector := [ ] ;
23481: LD_ADDR_EXP 97
23485: PUSH
23486: EMPTY
23487: ST_TO_ADDR
// mc_crates_area := [ ] ;
23488: LD_ADDR_EXP 98
23492: PUSH
23493: EMPTY
23494: ST_TO_ADDR
// mc_vehicles := [ ] ;
23495: LD_ADDR_EXP 99
23499: PUSH
23500: EMPTY
23501: ST_TO_ADDR
// mc_attack := [ ] ;
23502: LD_ADDR_EXP 100
23506: PUSH
23507: EMPTY
23508: ST_TO_ADDR
// mc_produce := [ ] ;
23509: LD_ADDR_EXP 101
23513: PUSH
23514: EMPTY
23515: ST_TO_ADDR
// mc_defender := [ ] ;
23516: LD_ADDR_EXP 102
23520: PUSH
23521: EMPTY
23522: ST_TO_ADDR
// mc_parking := [ ] ;
23523: LD_ADDR_EXP 104
23527: PUSH
23528: EMPTY
23529: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
23530: LD_ADDR_EXP 90
23534: PUSH
23535: EMPTY
23536: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
23537: LD_ADDR_EXP 92
23541: PUSH
23542: EMPTY
23543: ST_TO_ADDR
// mc_scan := [ ] ;
23544: LD_ADDR_EXP 103
23548: PUSH
23549: EMPTY
23550: ST_TO_ADDR
// mc_scan_area := [ ] ;
23551: LD_ADDR_EXP 105
23555: PUSH
23556: EMPTY
23557: ST_TO_ADDR
// mc_tech := [ ] ;
23558: LD_ADDR_EXP 107
23562: PUSH
23563: EMPTY
23564: ST_TO_ADDR
// mc_class := [ ] ;
23565: LD_ADDR_EXP 121
23569: PUSH
23570: EMPTY
23571: ST_TO_ADDR
// mc_class_case_use := [ ] ;
23572: LD_ADDR_EXP 122
23576: PUSH
23577: EMPTY
23578: ST_TO_ADDR
// mc_is_defending := [ ] ;
23579: LD_ADDR_EXP 123
23583: PUSH
23584: EMPTY
23585: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
23586: LD_ADDR_EXP 114
23590: PUSH
23591: EMPTY
23592: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
23593: LD_ADDR_EXP 124
23597: PUSH
23598: LD_INT 0
23600: ST_TO_ADDR
// end ;
23601: LD_VAR 0 1
23605: RET
// export function MC_Kill ( base ) ; begin
23606: LD_INT 0
23608: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
23609: LD_ADDR_EXP 80
23613: PUSH
23614: LD_EXP 80
23618: PPUSH
23619: LD_VAR 0 1
23623: PPUSH
23624: EMPTY
23625: PPUSH
23626: CALL_OW 1
23630: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23631: LD_ADDR_EXP 81
23635: PUSH
23636: LD_EXP 81
23640: PPUSH
23641: LD_VAR 0 1
23645: PPUSH
23646: EMPTY
23647: PPUSH
23648: CALL_OW 1
23652: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23653: LD_ADDR_EXP 82
23657: PUSH
23658: LD_EXP 82
23662: PPUSH
23663: LD_VAR 0 1
23667: PPUSH
23668: EMPTY
23669: PPUSH
23670: CALL_OW 1
23674: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23675: LD_ADDR_EXP 83
23679: PUSH
23680: LD_EXP 83
23684: PPUSH
23685: LD_VAR 0 1
23689: PPUSH
23690: EMPTY
23691: PPUSH
23692: CALL_OW 1
23696: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23697: LD_ADDR_EXP 84
23701: PUSH
23702: LD_EXP 84
23706: PPUSH
23707: LD_VAR 0 1
23711: PPUSH
23712: EMPTY
23713: PPUSH
23714: CALL_OW 1
23718: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23719: LD_ADDR_EXP 85
23723: PUSH
23724: LD_EXP 85
23728: PPUSH
23729: LD_VAR 0 1
23733: PPUSH
23734: EMPTY
23735: PPUSH
23736: CALL_OW 1
23740: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23741: LD_ADDR_EXP 86
23745: PUSH
23746: LD_EXP 86
23750: PPUSH
23751: LD_VAR 0 1
23755: PPUSH
23756: EMPTY
23757: PPUSH
23758: CALL_OW 1
23762: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23763: LD_ADDR_EXP 87
23767: PUSH
23768: LD_EXP 87
23772: PPUSH
23773: LD_VAR 0 1
23777: PPUSH
23778: EMPTY
23779: PPUSH
23780: CALL_OW 1
23784: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23785: LD_ADDR_EXP 88
23789: PUSH
23790: LD_EXP 88
23794: PPUSH
23795: LD_VAR 0 1
23799: PPUSH
23800: EMPTY
23801: PPUSH
23802: CALL_OW 1
23806: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23807: LD_ADDR_EXP 89
23811: PUSH
23812: LD_EXP 89
23816: PPUSH
23817: LD_VAR 0 1
23821: PPUSH
23822: EMPTY
23823: PPUSH
23824: CALL_OW 1
23828: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23829: LD_ADDR_EXP 90
23833: PUSH
23834: LD_EXP 90
23838: PPUSH
23839: LD_VAR 0 1
23843: PPUSH
23844: EMPTY
23845: PPUSH
23846: CALL_OW 1
23850: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23851: LD_ADDR_EXP 91
23855: PUSH
23856: LD_EXP 91
23860: PPUSH
23861: LD_VAR 0 1
23865: PPUSH
23866: LD_INT 0
23868: PPUSH
23869: CALL_OW 1
23873: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23874: LD_ADDR_EXP 92
23878: PUSH
23879: LD_EXP 92
23883: PPUSH
23884: LD_VAR 0 1
23888: PPUSH
23889: EMPTY
23890: PPUSH
23891: CALL_OW 1
23895: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23896: LD_ADDR_EXP 93
23900: PUSH
23901: LD_EXP 93
23905: PPUSH
23906: LD_VAR 0 1
23910: PPUSH
23911: EMPTY
23912: PPUSH
23913: CALL_OW 1
23917: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23918: LD_ADDR_EXP 94
23922: PUSH
23923: LD_EXP 94
23927: PPUSH
23928: LD_VAR 0 1
23932: PPUSH
23933: EMPTY
23934: PPUSH
23935: CALL_OW 1
23939: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23940: LD_ADDR_EXP 95
23944: PUSH
23945: LD_EXP 95
23949: PPUSH
23950: LD_VAR 0 1
23954: PPUSH
23955: EMPTY
23956: PPUSH
23957: CALL_OW 1
23961: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23962: LD_ADDR_EXP 96
23966: PUSH
23967: LD_EXP 96
23971: PPUSH
23972: LD_VAR 0 1
23976: PPUSH
23977: EMPTY
23978: PPUSH
23979: CALL_OW 1
23983: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23984: LD_ADDR_EXP 97
23988: PUSH
23989: LD_EXP 97
23993: PPUSH
23994: LD_VAR 0 1
23998: PPUSH
23999: EMPTY
24000: PPUSH
24001: CALL_OW 1
24005: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
24006: LD_ADDR_EXP 98
24010: PUSH
24011: LD_EXP 98
24015: PPUSH
24016: LD_VAR 0 1
24020: PPUSH
24021: EMPTY
24022: PPUSH
24023: CALL_OW 1
24027: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
24028: LD_ADDR_EXP 99
24032: PUSH
24033: LD_EXP 99
24037: PPUSH
24038: LD_VAR 0 1
24042: PPUSH
24043: EMPTY
24044: PPUSH
24045: CALL_OW 1
24049: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
24050: LD_ADDR_EXP 100
24054: PUSH
24055: LD_EXP 100
24059: PPUSH
24060: LD_VAR 0 1
24064: PPUSH
24065: EMPTY
24066: PPUSH
24067: CALL_OW 1
24071: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
24072: LD_ADDR_EXP 101
24076: PUSH
24077: LD_EXP 101
24081: PPUSH
24082: LD_VAR 0 1
24086: PPUSH
24087: EMPTY
24088: PPUSH
24089: CALL_OW 1
24093: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
24094: LD_ADDR_EXP 102
24098: PUSH
24099: LD_EXP 102
24103: PPUSH
24104: LD_VAR 0 1
24108: PPUSH
24109: EMPTY
24110: PPUSH
24111: CALL_OW 1
24115: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
24116: LD_ADDR_EXP 103
24120: PUSH
24121: LD_EXP 103
24125: PPUSH
24126: LD_VAR 0 1
24130: PPUSH
24131: EMPTY
24132: PPUSH
24133: CALL_OW 1
24137: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
24138: LD_ADDR_EXP 104
24142: PUSH
24143: LD_EXP 104
24147: PPUSH
24148: LD_VAR 0 1
24152: PPUSH
24153: EMPTY
24154: PPUSH
24155: CALL_OW 1
24159: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
24160: LD_ADDR_EXP 105
24164: PUSH
24165: LD_EXP 105
24169: PPUSH
24170: LD_VAR 0 1
24174: PPUSH
24175: EMPTY
24176: PPUSH
24177: CALL_OW 1
24181: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
24182: LD_ADDR_EXP 107
24186: PUSH
24187: LD_EXP 107
24191: PPUSH
24192: LD_VAR 0 1
24196: PPUSH
24197: EMPTY
24198: PPUSH
24199: CALL_OW 1
24203: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
24204: LD_ADDR_EXP 109
24208: PUSH
24209: LD_EXP 109
24213: PPUSH
24214: LD_VAR 0 1
24218: PPUSH
24219: EMPTY
24220: PPUSH
24221: CALL_OW 1
24225: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24226: LD_ADDR_EXP 110
24230: PUSH
24231: LD_EXP 110
24235: PPUSH
24236: LD_VAR 0 1
24240: PPUSH
24241: EMPTY
24242: PPUSH
24243: CALL_OW 1
24247: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24248: LD_ADDR_EXP 111
24252: PUSH
24253: LD_EXP 111
24257: PPUSH
24258: LD_VAR 0 1
24262: PPUSH
24263: EMPTY
24264: PPUSH
24265: CALL_OW 1
24269: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24270: LD_ADDR_EXP 112
24274: PUSH
24275: LD_EXP 112
24279: PPUSH
24280: LD_VAR 0 1
24284: PPUSH
24285: EMPTY
24286: PPUSH
24287: CALL_OW 1
24291: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24292: LD_ADDR_EXP 113
24296: PUSH
24297: LD_EXP 113
24301: PPUSH
24302: LD_VAR 0 1
24306: PPUSH
24307: EMPTY
24308: PPUSH
24309: CALL_OW 1
24313: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24314: LD_ADDR_EXP 114
24318: PUSH
24319: LD_EXP 114
24323: PPUSH
24324: LD_VAR 0 1
24328: PPUSH
24329: EMPTY
24330: PPUSH
24331: CALL_OW 1
24335: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24336: LD_ADDR_EXP 115
24340: PUSH
24341: LD_EXP 115
24345: PPUSH
24346: LD_VAR 0 1
24350: PPUSH
24351: EMPTY
24352: PPUSH
24353: CALL_OW 1
24357: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24358: LD_ADDR_EXP 116
24362: PUSH
24363: LD_EXP 116
24367: PPUSH
24368: LD_VAR 0 1
24372: PPUSH
24373: EMPTY
24374: PPUSH
24375: CALL_OW 1
24379: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24380: LD_ADDR_EXP 117
24384: PUSH
24385: LD_EXP 117
24389: PPUSH
24390: LD_VAR 0 1
24394: PPUSH
24395: EMPTY
24396: PPUSH
24397: CALL_OW 1
24401: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24402: LD_ADDR_EXP 118
24406: PUSH
24407: LD_EXP 118
24411: PPUSH
24412: LD_VAR 0 1
24416: PPUSH
24417: EMPTY
24418: PPUSH
24419: CALL_OW 1
24423: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24424: LD_ADDR_EXP 119
24428: PUSH
24429: LD_EXP 119
24433: PPUSH
24434: LD_VAR 0 1
24438: PPUSH
24439: EMPTY
24440: PPUSH
24441: CALL_OW 1
24445: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24446: LD_ADDR_EXP 120
24450: PUSH
24451: LD_EXP 120
24455: PPUSH
24456: LD_VAR 0 1
24460: PPUSH
24461: EMPTY
24462: PPUSH
24463: CALL_OW 1
24467: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24468: LD_ADDR_EXP 121
24472: PUSH
24473: LD_EXP 121
24477: PPUSH
24478: LD_VAR 0 1
24482: PPUSH
24483: EMPTY
24484: PPUSH
24485: CALL_OW 1
24489: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24490: LD_ADDR_EXP 122
24494: PUSH
24495: LD_EXP 122
24499: PPUSH
24500: LD_VAR 0 1
24504: PPUSH
24505: LD_INT 0
24507: PPUSH
24508: CALL_OW 1
24512: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24513: LD_ADDR_EXP 123
24517: PUSH
24518: LD_EXP 123
24522: PPUSH
24523: LD_VAR 0 1
24527: PPUSH
24528: LD_INT 0
24530: PPUSH
24531: CALL_OW 1
24535: ST_TO_ADDR
// end ;
24536: LD_VAR 0 2
24540: RET
// export function MC_Add ( side , units ) ; var base ; begin
24541: LD_INT 0
24543: PPUSH
24544: PPUSH
// base := mc_bases + 1 ;
24545: LD_ADDR_VAR 0 4
24549: PUSH
24550: LD_EXP 80
24554: PUSH
24555: LD_INT 1
24557: PLUS
24558: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
24559: LD_ADDR_EXP 106
24563: PUSH
24564: LD_EXP 106
24568: PPUSH
24569: LD_VAR 0 4
24573: PPUSH
24574: LD_VAR 0 1
24578: PPUSH
24579: CALL_OW 1
24583: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
24584: LD_ADDR_EXP 80
24588: PUSH
24589: LD_EXP 80
24593: PPUSH
24594: LD_VAR 0 4
24598: PPUSH
24599: LD_VAR 0 2
24603: PPUSH
24604: CALL_OW 1
24608: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
24609: LD_ADDR_EXP 81
24613: PUSH
24614: LD_EXP 81
24618: PPUSH
24619: LD_VAR 0 4
24623: PPUSH
24624: EMPTY
24625: PPUSH
24626: CALL_OW 1
24630: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
24631: LD_ADDR_EXP 82
24635: PUSH
24636: LD_EXP 82
24640: PPUSH
24641: LD_VAR 0 4
24645: PPUSH
24646: EMPTY
24647: PPUSH
24648: CALL_OW 1
24652: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
24653: LD_ADDR_EXP 83
24657: PUSH
24658: LD_EXP 83
24662: PPUSH
24663: LD_VAR 0 4
24667: PPUSH
24668: EMPTY
24669: PPUSH
24670: CALL_OW 1
24674: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
24675: LD_ADDR_EXP 84
24679: PUSH
24680: LD_EXP 84
24684: PPUSH
24685: LD_VAR 0 4
24689: PPUSH
24690: EMPTY
24691: PPUSH
24692: CALL_OW 1
24696: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
24697: LD_ADDR_EXP 85
24701: PUSH
24702: LD_EXP 85
24706: PPUSH
24707: LD_VAR 0 4
24711: PPUSH
24712: EMPTY
24713: PPUSH
24714: CALL_OW 1
24718: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
24719: LD_ADDR_EXP 86
24723: PUSH
24724: LD_EXP 86
24728: PPUSH
24729: LD_VAR 0 4
24733: PPUSH
24734: EMPTY
24735: PPUSH
24736: CALL_OW 1
24740: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
24741: LD_ADDR_EXP 87
24745: PUSH
24746: LD_EXP 87
24750: PPUSH
24751: LD_VAR 0 4
24755: PPUSH
24756: EMPTY
24757: PPUSH
24758: CALL_OW 1
24762: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
24763: LD_ADDR_EXP 88
24767: PUSH
24768: LD_EXP 88
24772: PPUSH
24773: LD_VAR 0 4
24777: PPUSH
24778: EMPTY
24779: PPUSH
24780: CALL_OW 1
24784: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
24785: LD_ADDR_EXP 89
24789: PUSH
24790: LD_EXP 89
24794: PPUSH
24795: LD_VAR 0 4
24799: PPUSH
24800: EMPTY
24801: PPUSH
24802: CALL_OW 1
24806: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
24807: LD_ADDR_EXP 90
24811: PUSH
24812: LD_EXP 90
24816: PPUSH
24817: LD_VAR 0 4
24821: PPUSH
24822: EMPTY
24823: PPUSH
24824: CALL_OW 1
24828: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
24829: LD_ADDR_EXP 91
24833: PUSH
24834: LD_EXP 91
24838: PPUSH
24839: LD_VAR 0 4
24843: PPUSH
24844: LD_INT 0
24846: PPUSH
24847: CALL_OW 1
24851: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
24852: LD_ADDR_EXP 92
24856: PUSH
24857: LD_EXP 92
24861: PPUSH
24862: LD_VAR 0 4
24866: PPUSH
24867: EMPTY
24868: PPUSH
24869: CALL_OW 1
24873: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
24874: LD_ADDR_EXP 93
24878: PUSH
24879: LD_EXP 93
24883: PPUSH
24884: LD_VAR 0 4
24888: PPUSH
24889: EMPTY
24890: PPUSH
24891: CALL_OW 1
24895: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
24896: LD_ADDR_EXP 94
24900: PUSH
24901: LD_EXP 94
24905: PPUSH
24906: LD_VAR 0 4
24910: PPUSH
24911: EMPTY
24912: PPUSH
24913: CALL_OW 1
24917: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
24918: LD_ADDR_EXP 95
24922: PUSH
24923: LD_EXP 95
24927: PPUSH
24928: LD_VAR 0 4
24932: PPUSH
24933: EMPTY
24934: PPUSH
24935: CALL_OW 1
24939: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
24940: LD_ADDR_EXP 96
24944: PUSH
24945: LD_EXP 96
24949: PPUSH
24950: LD_VAR 0 4
24954: PPUSH
24955: EMPTY
24956: PPUSH
24957: CALL_OW 1
24961: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
24962: LD_ADDR_EXP 97
24966: PUSH
24967: LD_EXP 97
24971: PPUSH
24972: LD_VAR 0 4
24976: PPUSH
24977: EMPTY
24978: PPUSH
24979: CALL_OW 1
24983: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
24984: LD_ADDR_EXP 98
24988: PUSH
24989: LD_EXP 98
24993: PPUSH
24994: LD_VAR 0 4
24998: PPUSH
24999: EMPTY
25000: PPUSH
25001: CALL_OW 1
25005: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
25006: LD_ADDR_EXP 99
25010: PUSH
25011: LD_EXP 99
25015: PPUSH
25016: LD_VAR 0 4
25020: PPUSH
25021: EMPTY
25022: PPUSH
25023: CALL_OW 1
25027: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
25028: LD_ADDR_EXP 100
25032: PUSH
25033: LD_EXP 100
25037: PPUSH
25038: LD_VAR 0 4
25042: PPUSH
25043: EMPTY
25044: PPUSH
25045: CALL_OW 1
25049: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
25050: LD_ADDR_EXP 101
25054: PUSH
25055: LD_EXP 101
25059: PPUSH
25060: LD_VAR 0 4
25064: PPUSH
25065: EMPTY
25066: PPUSH
25067: CALL_OW 1
25071: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
25072: LD_ADDR_EXP 102
25076: PUSH
25077: LD_EXP 102
25081: PPUSH
25082: LD_VAR 0 4
25086: PPUSH
25087: EMPTY
25088: PPUSH
25089: CALL_OW 1
25093: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
25094: LD_ADDR_EXP 103
25098: PUSH
25099: LD_EXP 103
25103: PPUSH
25104: LD_VAR 0 4
25108: PPUSH
25109: EMPTY
25110: PPUSH
25111: CALL_OW 1
25115: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
25116: LD_ADDR_EXP 104
25120: PUSH
25121: LD_EXP 104
25125: PPUSH
25126: LD_VAR 0 4
25130: PPUSH
25131: EMPTY
25132: PPUSH
25133: CALL_OW 1
25137: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
25138: LD_ADDR_EXP 105
25142: PUSH
25143: LD_EXP 105
25147: PPUSH
25148: LD_VAR 0 4
25152: PPUSH
25153: EMPTY
25154: PPUSH
25155: CALL_OW 1
25159: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
25160: LD_ADDR_EXP 107
25164: PUSH
25165: LD_EXP 107
25169: PPUSH
25170: LD_VAR 0 4
25174: PPUSH
25175: EMPTY
25176: PPUSH
25177: CALL_OW 1
25181: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
25182: LD_ADDR_EXP 109
25186: PUSH
25187: LD_EXP 109
25191: PPUSH
25192: LD_VAR 0 4
25196: PPUSH
25197: EMPTY
25198: PPUSH
25199: CALL_OW 1
25203: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
25204: LD_ADDR_EXP 110
25208: PUSH
25209: LD_EXP 110
25213: PPUSH
25214: LD_VAR 0 4
25218: PPUSH
25219: EMPTY
25220: PPUSH
25221: CALL_OW 1
25225: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
25226: LD_ADDR_EXP 111
25230: PUSH
25231: LD_EXP 111
25235: PPUSH
25236: LD_VAR 0 4
25240: PPUSH
25241: EMPTY
25242: PPUSH
25243: CALL_OW 1
25247: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
25248: LD_ADDR_EXP 112
25252: PUSH
25253: LD_EXP 112
25257: PPUSH
25258: LD_VAR 0 4
25262: PPUSH
25263: EMPTY
25264: PPUSH
25265: CALL_OW 1
25269: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
25270: LD_ADDR_EXP 113
25274: PUSH
25275: LD_EXP 113
25279: PPUSH
25280: LD_VAR 0 4
25284: PPUSH
25285: EMPTY
25286: PPUSH
25287: CALL_OW 1
25291: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
25292: LD_ADDR_EXP 114
25296: PUSH
25297: LD_EXP 114
25301: PPUSH
25302: LD_VAR 0 4
25306: PPUSH
25307: EMPTY
25308: PPUSH
25309: CALL_OW 1
25313: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
25314: LD_ADDR_EXP 115
25318: PUSH
25319: LD_EXP 115
25323: PPUSH
25324: LD_VAR 0 4
25328: PPUSH
25329: EMPTY
25330: PPUSH
25331: CALL_OW 1
25335: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
25336: LD_ADDR_EXP 116
25340: PUSH
25341: LD_EXP 116
25345: PPUSH
25346: LD_VAR 0 4
25350: PPUSH
25351: EMPTY
25352: PPUSH
25353: CALL_OW 1
25357: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
25358: LD_ADDR_EXP 117
25362: PUSH
25363: LD_EXP 117
25367: PPUSH
25368: LD_VAR 0 4
25372: PPUSH
25373: EMPTY
25374: PPUSH
25375: CALL_OW 1
25379: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
25380: LD_ADDR_EXP 118
25384: PUSH
25385: LD_EXP 118
25389: PPUSH
25390: LD_VAR 0 4
25394: PPUSH
25395: EMPTY
25396: PPUSH
25397: CALL_OW 1
25401: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
25402: LD_ADDR_EXP 119
25406: PUSH
25407: LD_EXP 119
25411: PPUSH
25412: LD_VAR 0 4
25416: PPUSH
25417: EMPTY
25418: PPUSH
25419: CALL_OW 1
25423: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
25424: LD_ADDR_EXP 120
25428: PUSH
25429: LD_EXP 120
25433: PPUSH
25434: LD_VAR 0 4
25438: PPUSH
25439: EMPTY
25440: PPUSH
25441: CALL_OW 1
25445: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
25446: LD_ADDR_EXP 121
25450: PUSH
25451: LD_EXP 121
25455: PPUSH
25456: LD_VAR 0 4
25460: PPUSH
25461: EMPTY
25462: PPUSH
25463: CALL_OW 1
25467: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
25468: LD_ADDR_EXP 122
25472: PUSH
25473: LD_EXP 122
25477: PPUSH
25478: LD_VAR 0 4
25482: PPUSH
25483: LD_INT 0
25485: PPUSH
25486: CALL_OW 1
25490: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
25491: LD_ADDR_EXP 123
25495: PUSH
25496: LD_EXP 123
25500: PPUSH
25501: LD_VAR 0 4
25505: PPUSH
25506: LD_INT 0
25508: PPUSH
25509: CALL_OW 1
25513: ST_TO_ADDR
// result := base ;
25514: LD_ADDR_VAR 0 3
25518: PUSH
25519: LD_VAR 0 4
25523: ST_TO_ADDR
// end ;
25524: LD_VAR 0 3
25528: RET
// export function MC_Start ( ) ; var i ; begin
25529: LD_INT 0
25531: PPUSH
25532: PPUSH
// for i = 1 to mc_bases do
25533: LD_ADDR_VAR 0 2
25537: PUSH
25538: DOUBLE
25539: LD_INT 1
25541: DEC
25542: ST_TO_ADDR
25543: LD_EXP 80
25547: PUSH
25548: FOR_TO
25549: IFFALSE 26649
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
25551: LD_ADDR_EXP 80
25555: PUSH
25556: LD_EXP 80
25560: PPUSH
25561: LD_VAR 0 2
25565: PPUSH
25566: LD_EXP 80
25570: PUSH
25571: LD_VAR 0 2
25575: ARRAY
25576: PUSH
25577: LD_INT 0
25579: DIFF
25580: PPUSH
25581: CALL_OW 1
25585: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
25586: LD_ADDR_EXP 81
25590: PUSH
25591: LD_EXP 81
25595: PPUSH
25596: LD_VAR 0 2
25600: PPUSH
25601: EMPTY
25602: PPUSH
25603: CALL_OW 1
25607: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
25608: LD_ADDR_EXP 82
25612: PUSH
25613: LD_EXP 82
25617: PPUSH
25618: LD_VAR 0 2
25622: PPUSH
25623: EMPTY
25624: PPUSH
25625: CALL_OW 1
25629: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
25630: LD_ADDR_EXP 83
25634: PUSH
25635: LD_EXP 83
25639: PPUSH
25640: LD_VAR 0 2
25644: PPUSH
25645: EMPTY
25646: PPUSH
25647: CALL_OW 1
25651: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
25652: LD_ADDR_EXP 84
25656: PUSH
25657: LD_EXP 84
25661: PPUSH
25662: LD_VAR 0 2
25666: PPUSH
25667: EMPTY
25668: PUSH
25669: EMPTY
25670: PUSH
25671: EMPTY
25672: LIST
25673: LIST
25674: PPUSH
25675: CALL_OW 1
25679: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
25680: LD_ADDR_EXP 85
25684: PUSH
25685: LD_EXP 85
25689: PPUSH
25690: LD_VAR 0 2
25694: PPUSH
25695: EMPTY
25696: PPUSH
25697: CALL_OW 1
25701: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
25702: LD_ADDR_EXP 112
25706: PUSH
25707: LD_EXP 112
25711: PPUSH
25712: LD_VAR 0 2
25716: PPUSH
25717: EMPTY
25718: PPUSH
25719: CALL_OW 1
25723: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
25724: LD_ADDR_EXP 86
25728: PUSH
25729: LD_EXP 86
25733: PPUSH
25734: LD_VAR 0 2
25738: PPUSH
25739: EMPTY
25740: PPUSH
25741: CALL_OW 1
25745: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
25746: LD_ADDR_EXP 87
25750: PUSH
25751: LD_EXP 87
25755: PPUSH
25756: LD_VAR 0 2
25760: PPUSH
25761: EMPTY
25762: PPUSH
25763: CALL_OW 1
25767: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
25768: LD_ADDR_EXP 88
25772: PUSH
25773: LD_EXP 88
25777: PPUSH
25778: LD_VAR 0 2
25782: PPUSH
25783: LD_EXP 80
25787: PUSH
25788: LD_VAR 0 2
25792: ARRAY
25793: PPUSH
25794: LD_INT 2
25796: PUSH
25797: LD_INT 30
25799: PUSH
25800: LD_INT 32
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: PUSH
25807: LD_INT 30
25809: PUSH
25810: LD_INT 33
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: EMPTY
25818: LIST
25819: LIST
25820: LIST
25821: PPUSH
25822: CALL_OW 72
25826: PPUSH
25827: CALL_OW 1
25831: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
25832: LD_ADDR_EXP 89
25836: PUSH
25837: LD_EXP 89
25841: PPUSH
25842: LD_VAR 0 2
25846: PPUSH
25847: LD_EXP 80
25851: PUSH
25852: LD_VAR 0 2
25856: ARRAY
25857: PPUSH
25858: LD_INT 2
25860: PUSH
25861: LD_INT 30
25863: PUSH
25864: LD_INT 32
25866: PUSH
25867: EMPTY
25868: LIST
25869: LIST
25870: PUSH
25871: LD_INT 30
25873: PUSH
25874: LD_INT 31
25876: PUSH
25877: EMPTY
25878: LIST
25879: LIST
25880: PUSH
25881: EMPTY
25882: LIST
25883: LIST
25884: LIST
25885: PUSH
25886: LD_INT 58
25888: PUSH
25889: EMPTY
25890: LIST
25891: PUSH
25892: EMPTY
25893: LIST
25894: LIST
25895: PPUSH
25896: CALL_OW 72
25900: PPUSH
25901: CALL_OW 1
25905: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
25906: LD_ADDR_EXP 90
25910: PUSH
25911: LD_EXP 90
25915: PPUSH
25916: LD_VAR 0 2
25920: PPUSH
25921: EMPTY
25922: PPUSH
25923: CALL_OW 1
25927: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
25928: LD_ADDR_EXP 94
25932: PUSH
25933: LD_EXP 94
25937: PPUSH
25938: LD_VAR 0 2
25942: PPUSH
25943: EMPTY
25944: PPUSH
25945: CALL_OW 1
25949: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
25950: LD_ADDR_EXP 93
25954: PUSH
25955: LD_EXP 93
25959: PPUSH
25960: LD_VAR 0 2
25964: PPUSH
25965: EMPTY
25966: PPUSH
25967: CALL_OW 1
25971: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
25972: LD_ADDR_EXP 95
25976: PUSH
25977: LD_EXP 95
25981: PPUSH
25982: LD_VAR 0 2
25986: PPUSH
25987: EMPTY
25988: PPUSH
25989: CALL_OW 1
25993: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
25994: LD_ADDR_EXP 96
25998: PUSH
25999: LD_EXP 96
26003: PPUSH
26004: LD_VAR 0 2
26008: PPUSH
26009: EMPTY
26010: PPUSH
26011: CALL_OW 1
26015: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
26016: LD_ADDR_EXP 97
26020: PUSH
26021: LD_EXP 97
26025: PPUSH
26026: LD_VAR 0 2
26030: PPUSH
26031: EMPTY
26032: PPUSH
26033: CALL_OW 1
26037: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
26038: LD_ADDR_EXP 98
26042: PUSH
26043: LD_EXP 98
26047: PPUSH
26048: LD_VAR 0 2
26052: PPUSH
26053: EMPTY
26054: PPUSH
26055: CALL_OW 1
26059: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
26060: LD_ADDR_EXP 99
26064: PUSH
26065: LD_EXP 99
26069: PPUSH
26070: LD_VAR 0 2
26074: PPUSH
26075: EMPTY
26076: PPUSH
26077: CALL_OW 1
26081: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
26082: LD_ADDR_EXP 100
26086: PUSH
26087: LD_EXP 100
26091: PPUSH
26092: LD_VAR 0 2
26096: PPUSH
26097: EMPTY
26098: PPUSH
26099: CALL_OW 1
26103: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
26104: LD_ADDR_EXP 101
26108: PUSH
26109: LD_EXP 101
26113: PPUSH
26114: LD_VAR 0 2
26118: PPUSH
26119: EMPTY
26120: PPUSH
26121: CALL_OW 1
26125: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
26126: LD_ADDR_EXP 102
26130: PUSH
26131: LD_EXP 102
26135: PPUSH
26136: LD_VAR 0 2
26140: PPUSH
26141: EMPTY
26142: PPUSH
26143: CALL_OW 1
26147: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
26148: LD_ADDR_EXP 91
26152: PUSH
26153: LD_EXP 91
26157: PPUSH
26158: LD_VAR 0 2
26162: PPUSH
26163: LD_INT 0
26165: PPUSH
26166: CALL_OW 1
26170: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
26171: LD_ADDR_EXP 104
26175: PUSH
26176: LD_EXP 104
26180: PPUSH
26181: LD_VAR 0 2
26185: PPUSH
26186: LD_INT 0
26188: PPUSH
26189: CALL_OW 1
26193: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
26194: LD_ADDR_EXP 92
26198: PUSH
26199: LD_EXP 92
26203: PPUSH
26204: LD_VAR 0 2
26208: PPUSH
26209: EMPTY
26210: PPUSH
26211: CALL_OW 1
26215: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
26216: LD_ADDR_EXP 103
26220: PUSH
26221: LD_EXP 103
26225: PPUSH
26226: LD_VAR 0 2
26230: PPUSH
26231: LD_INT 0
26233: PPUSH
26234: CALL_OW 1
26238: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
26239: LD_ADDR_EXP 105
26243: PUSH
26244: LD_EXP 105
26248: PPUSH
26249: LD_VAR 0 2
26253: PPUSH
26254: EMPTY
26255: PPUSH
26256: CALL_OW 1
26260: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
26261: LD_ADDR_EXP 108
26265: PUSH
26266: LD_EXP 108
26270: PPUSH
26271: LD_VAR 0 2
26275: PPUSH
26276: LD_INT 0
26278: PPUSH
26279: CALL_OW 1
26283: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
26284: LD_ADDR_EXP 109
26288: PUSH
26289: LD_EXP 109
26293: PPUSH
26294: LD_VAR 0 2
26298: PPUSH
26299: EMPTY
26300: PPUSH
26301: CALL_OW 1
26305: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
26306: LD_ADDR_EXP 110
26310: PUSH
26311: LD_EXP 110
26315: PPUSH
26316: LD_VAR 0 2
26320: PPUSH
26321: EMPTY
26322: PPUSH
26323: CALL_OW 1
26327: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
26328: LD_ADDR_EXP 111
26332: PUSH
26333: LD_EXP 111
26337: PPUSH
26338: LD_VAR 0 2
26342: PPUSH
26343: EMPTY
26344: PPUSH
26345: CALL_OW 1
26349: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
26350: LD_ADDR_EXP 113
26354: PUSH
26355: LD_EXP 113
26359: PPUSH
26360: LD_VAR 0 2
26364: PPUSH
26365: LD_EXP 80
26369: PUSH
26370: LD_VAR 0 2
26374: ARRAY
26375: PPUSH
26376: LD_INT 2
26378: PUSH
26379: LD_INT 30
26381: PUSH
26382: LD_INT 6
26384: PUSH
26385: EMPTY
26386: LIST
26387: LIST
26388: PUSH
26389: LD_INT 30
26391: PUSH
26392: LD_INT 7
26394: PUSH
26395: EMPTY
26396: LIST
26397: LIST
26398: PUSH
26399: LD_INT 30
26401: PUSH
26402: LD_INT 8
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: PUSH
26409: EMPTY
26410: LIST
26411: LIST
26412: LIST
26413: LIST
26414: PPUSH
26415: CALL_OW 72
26419: PPUSH
26420: CALL_OW 1
26424: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
26425: LD_ADDR_EXP 114
26429: PUSH
26430: LD_EXP 114
26434: PPUSH
26435: LD_VAR 0 2
26439: PPUSH
26440: EMPTY
26441: PPUSH
26442: CALL_OW 1
26446: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
26447: LD_ADDR_EXP 115
26451: PUSH
26452: LD_EXP 115
26456: PPUSH
26457: LD_VAR 0 2
26461: PPUSH
26462: EMPTY
26463: PPUSH
26464: CALL_OW 1
26468: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
26469: LD_ADDR_EXP 116
26473: PUSH
26474: LD_EXP 116
26478: PPUSH
26479: LD_VAR 0 2
26483: PPUSH
26484: EMPTY
26485: PPUSH
26486: CALL_OW 1
26490: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
26491: LD_ADDR_EXP 117
26495: PUSH
26496: LD_EXP 117
26500: PPUSH
26501: LD_VAR 0 2
26505: PPUSH
26506: EMPTY
26507: PPUSH
26508: CALL_OW 1
26512: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
26513: LD_ADDR_EXP 118
26517: PUSH
26518: LD_EXP 118
26522: PPUSH
26523: LD_VAR 0 2
26527: PPUSH
26528: EMPTY
26529: PPUSH
26530: CALL_OW 1
26534: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
26535: LD_ADDR_EXP 119
26539: PUSH
26540: LD_EXP 119
26544: PPUSH
26545: LD_VAR 0 2
26549: PPUSH
26550: EMPTY
26551: PPUSH
26552: CALL_OW 1
26556: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
26557: LD_ADDR_EXP 120
26561: PUSH
26562: LD_EXP 120
26566: PPUSH
26567: LD_VAR 0 2
26571: PPUSH
26572: EMPTY
26573: PPUSH
26574: CALL_OW 1
26578: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
26579: LD_ADDR_EXP 121
26583: PUSH
26584: LD_EXP 121
26588: PPUSH
26589: LD_VAR 0 2
26593: PPUSH
26594: EMPTY
26595: PPUSH
26596: CALL_OW 1
26600: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
26601: LD_ADDR_EXP 122
26605: PUSH
26606: LD_EXP 122
26610: PPUSH
26611: LD_VAR 0 2
26615: PPUSH
26616: LD_INT 0
26618: PPUSH
26619: CALL_OW 1
26623: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
26624: LD_ADDR_EXP 123
26628: PUSH
26629: LD_EXP 123
26633: PPUSH
26634: LD_VAR 0 2
26638: PPUSH
26639: LD_INT 0
26641: PPUSH
26642: CALL_OW 1
26646: ST_TO_ADDR
// end ;
26647: GO 25548
26649: POP
26650: POP
// MC_InitSides ( ) ;
26651: CALL 26937 0 0
// MC_InitResearch ( ) ;
26655: CALL 26676 0 0
// CustomInitMacro ( ) ;
26659: CALL 252 0 0
// skirmish := true ;
26663: LD_ADDR_EXP 78
26667: PUSH
26668: LD_INT 1
26670: ST_TO_ADDR
// end ;
26671: LD_VAR 0 1
26675: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
26676: LD_INT 0
26678: PPUSH
26679: PPUSH
26680: PPUSH
26681: PPUSH
26682: PPUSH
26683: PPUSH
// if not mc_bases then
26684: LD_EXP 80
26688: NOT
26689: IFFALSE 26693
// exit ;
26691: GO 26932
// for i = 1 to 8 do
26693: LD_ADDR_VAR 0 2
26697: PUSH
26698: DOUBLE
26699: LD_INT 1
26701: DEC
26702: ST_TO_ADDR
26703: LD_INT 8
26705: PUSH
26706: FOR_TO
26707: IFFALSE 26733
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
26709: LD_ADDR_EXP 107
26713: PUSH
26714: LD_EXP 107
26718: PPUSH
26719: LD_VAR 0 2
26723: PPUSH
26724: EMPTY
26725: PPUSH
26726: CALL_OW 1
26730: ST_TO_ADDR
26731: GO 26706
26733: POP
26734: POP
// tmp := [ ] ;
26735: LD_ADDR_VAR 0 5
26739: PUSH
26740: EMPTY
26741: ST_TO_ADDR
// for i = 1 to mc_sides do
26742: LD_ADDR_VAR 0 2
26746: PUSH
26747: DOUBLE
26748: LD_INT 1
26750: DEC
26751: ST_TO_ADDR
26752: LD_EXP 106
26756: PUSH
26757: FOR_TO
26758: IFFALSE 26816
// if not mc_sides [ i ] in tmp then
26760: LD_EXP 106
26764: PUSH
26765: LD_VAR 0 2
26769: ARRAY
26770: PUSH
26771: LD_VAR 0 5
26775: IN
26776: NOT
26777: IFFALSE 26814
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
26779: LD_ADDR_VAR 0 5
26783: PUSH
26784: LD_VAR 0 5
26788: PPUSH
26789: LD_VAR 0 5
26793: PUSH
26794: LD_INT 1
26796: PLUS
26797: PPUSH
26798: LD_EXP 106
26802: PUSH
26803: LD_VAR 0 2
26807: ARRAY
26808: PPUSH
26809: CALL_OW 2
26813: ST_TO_ADDR
26814: GO 26757
26816: POP
26817: POP
// if not tmp then
26818: LD_VAR 0 5
26822: NOT
26823: IFFALSE 26827
// exit ;
26825: GO 26932
// for j in tmp do
26827: LD_ADDR_VAR 0 3
26831: PUSH
26832: LD_VAR 0 5
26836: PUSH
26837: FOR_IN
26838: IFFALSE 26930
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
26840: LD_ADDR_VAR 0 6
26844: PUSH
26845: LD_INT 22
26847: PUSH
26848: LD_VAR 0 3
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PPUSH
26857: CALL_OW 69
26861: ST_TO_ADDR
// if not un then
26862: LD_VAR 0 6
26866: NOT
26867: IFFALSE 26871
// continue ;
26869: GO 26837
// nation := GetNation ( un [ 1 ] ) ;
26871: LD_ADDR_VAR 0 4
26875: PUSH
26876: LD_VAR 0 6
26880: PUSH
26881: LD_INT 1
26883: ARRAY
26884: PPUSH
26885: CALL_OW 248
26889: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
26890: LD_ADDR_EXP 107
26894: PUSH
26895: LD_EXP 107
26899: PPUSH
26900: LD_VAR 0 3
26904: PPUSH
26905: LD_VAR 0 3
26909: PPUSH
26910: LD_VAR 0 4
26914: PPUSH
26915: LD_INT 1
26917: PPUSH
26918: CALL 54558 0 3
26922: PPUSH
26923: CALL_OW 1
26927: ST_TO_ADDR
// end ;
26928: GO 26837
26930: POP
26931: POP
// end ;
26932: LD_VAR 0 1
26936: RET
// export function MC_InitSides ( ) ; var i ; begin
26937: LD_INT 0
26939: PPUSH
26940: PPUSH
// if not mc_bases then
26941: LD_EXP 80
26945: NOT
26946: IFFALSE 26950
// exit ;
26948: GO 27024
// for i = 1 to mc_bases do
26950: LD_ADDR_VAR 0 2
26954: PUSH
26955: DOUBLE
26956: LD_INT 1
26958: DEC
26959: ST_TO_ADDR
26960: LD_EXP 80
26964: PUSH
26965: FOR_TO
26966: IFFALSE 27022
// if mc_bases [ i ] then
26968: LD_EXP 80
26972: PUSH
26973: LD_VAR 0 2
26977: ARRAY
26978: IFFALSE 27020
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
26980: LD_ADDR_EXP 106
26984: PUSH
26985: LD_EXP 106
26989: PPUSH
26990: LD_VAR 0 2
26994: PPUSH
26995: LD_EXP 80
26999: PUSH
27000: LD_VAR 0 2
27004: ARRAY
27005: PUSH
27006: LD_INT 1
27008: ARRAY
27009: PPUSH
27010: CALL_OW 255
27014: PPUSH
27015: CALL_OW 1
27019: ST_TO_ADDR
27020: GO 26965
27022: POP
27023: POP
// end ;
27024: LD_VAR 0 1
27028: RET
// every 0 0$03 trigger skirmish do
27029: LD_EXP 78
27033: IFFALSE 27187
27035: GO 27037
27037: DISABLE
// begin enable ;
27038: ENABLE
// MC_CheckBuildings ( ) ;
27039: CALL 31745 0 0
// MC_CheckPeopleLife ( ) ;
27043: CALL 31906 0 0
// RaiseSailEvent ( 100 ) ;
27047: LD_INT 100
27049: PPUSH
27050: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
27054: LD_INT 103
27056: PPUSH
27057: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
27061: LD_INT 104
27063: PPUSH
27064: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
27068: LD_INT 105
27070: PPUSH
27071: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
27075: LD_INT 106
27077: PPUSH
27078: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
27082: LD_INT 107
27084: PPUSH
27085: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
27089: LD_INT 108
27091: PPUSH
27092: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
27096: LD_INT 109
27098: PPUSH
27099: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
27103: LD_INT 110
27105: PPUSH
27106: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
27110: LD_INT 111
27112: PPUSH
27113: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
27117: LD_INT 112
27119: PPUSH
27120: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
27124: LD_INT 113
27126: PPUSH
27127: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
27131: LD_INT 120
27133: PPUSH
27134: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
27138: LD_INT 121
27140: PPUSH
27141: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
27145: LD_INT 122
27147: PPUSH
27148: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
27152: LD_INT 123
27154: PPUSH
27155: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
27159: LD_INT 124
27161: PPUSH
27162: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
27166: LD_INT 125
27168: PPUSH
27169: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
27173: LD_INT 126
27175: PPUSH
27176: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
27180: LD_INT 200
27182: PPUSH
27183: CALL_OW 427
// end ;
27187: END
// on SailEvent ( event ) do begin if event < 100 then
27188: LD_VAR 0 1
27192: PUSH
27193: LD_INT 100
27195: LESS
27196: IFFALSE 27207
// CustomEvent ( event ) ;
27198: LD_VAR 0 1
27202: PPUSH
27203: CALL 11866 0 1
// if event = 100 then
27207: LD_VAR 0 1
27211: PUSH
27212: LD_INT 100
27214: EQUAL
27215: IFFALSE 27221
// MC_ClassManager ( ) ;
27217: CALL 27615 0 0
// if event = 101 then
27221: LD_VAR 0 1
27225: PUSH
27226: LD_INT 101
27228: EQUAL
27229: IFFALSE 27235
// MC_RepairBuildings ( ) ;
27231: CALL 32493 0 0
// if event = 102 then
27235: LD_VAR 0 1
27239: PUSH
27240: LD_INT 102
27242: EQUAL
27243: IFFALSE 27249
// MC_Heal ( ) ;
27245: CALL 33432 0 0
// if event = 103 then
27249: LD_VAR 0 1
27253: PUSH
27254: LD_INT 103
27256: EQUAL
27257: IFFALSE 27263
// MC_Build ( ) ;
27259: CALL 33858 0 0
// if event = 104 then
27263: LD_VAR 0 1
27267: PUSH
27268: LD_INT 104
27270: EQUAL
27271: IFFALSE 27277
// MC_TurretWeapon ( ) ;
27273: CALL 35506 0 0
// if event = 105 then
27277: LD_VAR 0 1
27281: PUSH
27282: LD_INT 105
27284: EQUAL
27285: IFFALSE 27291
// MC_BuildUpgrade ( ) ;
27287: CALL 35051 0 0
// if event = 106 then
27291: LD_VAR 0 1
27295: PUSH
27296: LD_INT 106
27298: EQUAL
27299: IFFALSE 27305
// MC_PlantMines ( ) ;
27301: CALL 35938 0 0
// if event = 107 then
27305: LD_VAR 0 1
27309: PUSH
27310: LD_INT 107
27312: EQUAL
27313: IFFALSE 27319
// MC_CollectCrates ( ) ;
27315: CALL 36748 0 0
// if event = 108 then
27319: LD_VAR 0 1
27323: PUSH
27324: LD_INT 108
27326: EQUAL
27327: IFFALSE 27333
// MC_LinkRemoteControl ( ) ;
27329: CALL 38622 0 0
// if event = 109 then
27333: LD_VAR 0 1
27337: PUSH
27338: LD_INT 109
27340: EQUAL
27341: IFFALSE 27347
// MC_ProduceVehicle ( ) ;
27343: CALL 38807 0 0
// if event = 110 then
27347: LD_VAR 0 1
27351: PUSH
27352: LD_INT 110
27354: EQUAL
27355: IFFALSE 27361
// MC_SendAttack ( ) ;
27357: CALL 39277 0 0
// if event = 111 then
27361: LD_VAR 0 1
27365: PUSH
27366: LD_INT 111
27368: EQUAL
27369: IFFALSE 27375
// MC_Defend ( ) ;
27371: CALL 39385 0 0
// if event = 112 then
27375: LD_VAR 0 1
27379: PUSH
27380: LD_INT 112
27382: EQUAL
27383: IFFALSE 27389
// MC_Research ( ) ;
27385: CALL 40285 0 0
// if event = 113 then
27389: LD_VAR 0 1
27393: PUSH
27394: LD_INT 113
27396: EQUAL
27397: IFFALSE 27403
// MC_MinesTrigger ( ) ;
27399: CALL 41425 0 0
// if event = 120 then
27403: LD_VAR 0 1
27407: PUSH
27408: LD_INT 120
27410: EQUAL
27411: IFFALSE 27417
// MC_RepairVehicle ( ) ;
27413: CALL 41526 0 0
// if event = 121 then
27417: LD_VAR 0 1
27421: PUSH
27422: LD_INT 121
27424: EQUAL
27425: IFFALSE 27431
// MC_TameApe ( ) ;
27427: CALL 42303 0 0
// if event = 122 then
27431: LD_VAR 0 1
27435: PUSH
27436: LD_INT 122
27438: EQUAL
27439: IFFALSE 27445
// MC_ChangeApeClass ( ) ;
27441: CALL 43148 0 0
// if event = 123 then
27445: LD_VAR 0 1
27449: PUSH
27450: LD_INT 123
27452: EQUAL
27453: IFFALSE 27459
// MC_Bazooka ( ) ;
27455: CALL 43804 0 0
// if event = 124 then
27459: LD_VAR 0 1
27463: PUSH
27464: LD_INT 124
27466: EQUAL
27467: IFFALSE 27473
// MC_TeleportExit ( ) ;
27469: CALL 44006 0 0
// if event = 125 then
27473: LD_VAR 0 1
27477: PUSH
27478: LD_INT 125
27480: EQUAL
27481: IFFALSE 27487
// MC_Deposits ( ) ;
27483: CALL 44663 0 0
// if event = 126 then
27487: LD_VAR 0 1
27491: PUSH
27492: LD_INT 126
27494: EQUAL
27495: IFFALSE 27501
// MC_RemoteDriver ( ) ;
27497: CALL 45296 0 0
// if event = 200 then
27501: LD_VAR 0 1
27505: PUSH
27506: LD_INT 200
27508: EQUAL
27509: IFFALSE 27515
// MC_Idle ( ) ;
27511: CALL 47231 0 0
// end ;
27515: PPOPN 1
27517: END
// export function MC_Reset ( base , tag ) ; var i ; begin
27518: LD_INT 0
27520: PPUSH
27521: PPUSH
// if not mc_bases [ base ] or not tag then
27522: LD_EXP 80
27526: PUSH
27527: LD_VAR 0 1
27531: ARRAY
27532: NOT
27533: IFTRUE 27542
27535: PUSH
27536: LD_VAR 0 2
27540: NOT
27541: OR
27542: IFFALSE 27546
// exit ;
27544: GO 27610
// for i in mc_bases [ base ] union mc_ape [ base ] do
27546: LD_ADDR_VAR 0 4
27550: PUSH
27551: LD_EXP 80
27555: PUSH
27556: LD_VAR 0 1
27560: ARRAY
27561: PUSH
27562: LD_EXP 109
27566: PUSH
27567: LD_VAR 0 1
27571: ARRAY
27572: UNION
27573: PUSH
27574: FOR_IN
27575: IFFALSE 27608
// if GetTag ( i ) = tag then
27577: LD_VAR 0 4
27581: PPUSH
27582: CALL_OW 110
27586: PUSH
27587: LD_VAR 0 2
27591: EQUAL
27592: IFFALSE 27606
// SetTag ( i , 0 ) ;
27594: LD_VAR 0 4
27598: PPUSH
27599: LD_INT 0
27601: PPUSH
27602: CALL_OW 109
27606: GO 27574
27608: POP
27609: POP
// end ;
27610: LD_VAR 0 3
27614: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
27615: LD_INT 0
27617: PPUSH
27618: PPUSH
27619: PPUSH
27620: PPUSH
27621: PPUSH
27622: PPUSH
27623: PPUSH
27624: PPUSH
// if not mc_bases then
27625: LD_EXP 80
27629: NOT
27630: IFFALSE 27634
// exit ;
27632: GO 28085
// for i = 1 to mc_bases do
27634: LD_ADDR_VAR 0 2
27638: PUSH
27639: DOUBLE
27640: LD_INT 1
27642: DEC
27643: ST_TO_ADDR
27644: LD_EXP 80
27648: PUSH
27649: FOR_TO
27650: IFFALSE 28083
// begin tmp := MC_ClassCheckReq ( i ) ;
27652: LD_ADDR_VAR 0 4
27656: PUSH
27657: LD_VAR 0 2
27661: PPUSH
27662: CALL 28090 0 1
27666: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
27667: LD_ADDR_EXP 121
27671: PUSH
27672: LD_EXP 121
27676: PPUSH
27677: LD_VAR 0 2
27681: PPUSH
27682: LD_VAR 0 4
27686: PPUSH
27687: CALL_OW 1
27691: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
27692: LD_ADDR_VAR 0 6
27696: PUSH
27697: LD_EXP 80
27701: PUSH
27702: LD_VAR 0 2
27706: ARRAY
27707: PPUSH
27708: LD_INT 2
27710: PUSH
27711: LD_INT 30
27713: PUSH
27714: LD_INT 4
27716: PUSH
27717: EMPTY
27718: LIST
27719: LIST
27720: PUSH
27721: LD_INT 30
27723: PUSH
27724: LD_INT 5
27726: PUSH
27727: EMPTY
27728: LIST
27729: LIST
27730: PUSH
27731: EMPTY
27732: LIST
27733: LIST
27734: LIST
27735: PPUSH
27736: CALL_OW 72
27740: PUSH
27741: LD_EXP 80
27745: PUSH
27746: LD_VAR 0 2
27750: ARRAY
27751: PPUSH
27752: LD_INT 2
27754: PUSH
27755: LD_INT 30
27757: PUSH
27758: LD_INT 0
27760: PUSH
27761: EMPTY
27762: LIST
27763: LIST
27764: PUSH
27765: LD_INT 30
27767: PUSH
27768: LD_INT 1
27770: PUSH
27771: EMPTY
27772: LIST
27773: LIST
27774: PUSH
27775: EMPTY
27776: LIST
27777: LIST
27778: LIST
27779: PPUSH
27780: CALL_OW 72
27784: PUSH
27785: LD_EXP 80
27789: PUSH
27790: LD_VAR 0 2
27794: ARRAY
27795: PPUSH
27796: LD_INT 30
27798: PUSH
27799: LD_INT 3
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PPUSH
27806: CALL_OW 72
27810: PUSH
27811: LD_EXP 80
27815: PUSH
27816: LD_VAR 0 2
27820: ARRAY
27821: PPUSH
27822: LD_INT 2
27824: PUSH
27825: LD_INT 30
27827: PUSH
27828: LD_INT 6
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: PUSH
27835: LD_INT 30
27837: PUSH
27838: LD_INT 7
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: PUSH
27845: LD_INT 30
27847: PUSH
27848: LD_INT 8
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: LIST
27859: LIST
27860: PPUSH
27861: CALL_OW 72
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: LIST
27870: LIST
27871: ST_TO_ADDR
// for j := 1 to 4 do
27872: LD_ADDR_VAR 0 3
27876: PUSH
27877: DOUBLE
27878: LD_INT 1
27880: DEC
27881: ST_TO_ADDR
27882: LD_INT 4
27884: PUSH
27885: FOR_TO
27886: IFFALSE 28079
// begin if not tmp [ j ] then
27888: LD_VAR 0 4
27892: PUSH
27893: LD_VAR 0 3
27897: ARRAY
27898: NOT
27899: IFFALSE 27903
// continue ;
27901: GO 27885
// for p in tmp [ j ] do
27903: LD_ADDR_VAR 0 5
27907: PUSH
27908: LD_VAR 0 4
27912: PUSH
27913: LD_VAR 0 3
27917: ARRAY
27918: PUSH
27919: FOR_IN
27920: IFFALSE 28075
// begin if not b [ j ] then
27922: LD_VAR 0 6
27926: PUSH
27927: LD_VAR 0 3
27931: ARRAY
27932: NOT
27933: IFFALSE 27937
// break ;
27935: GO 28075
// e := 0 ;
27937: LD_ADDR_VAR 0 7
27941: PUSH
27942: LD_INT 0
27944: ST_TO_ADDR
// for k in b [ j ] do
27945: LD_ADDR_VAR 0 8
27949: PUSH
27950: LD_VAR 0 6
27954: PUSH
27955: LD_VAR 0 3
27959: ARRAY
27960: PUSH
27961: FOR_IN
27962: IFFALSE 27989
// if IsNotFull ( k ) then
27964: LD_VAR 0 8
27968: PPUSH
27969: CALL 56717 0 1
27973: IFFALSE 27987
// begin e := k ;
27975: LD_ADDR_VAR 0 7
27979: PUSH
27980: LD_VAR 0 8
27984: ST_TO_ADDR
// break ;
27985: GO 27989
// end ;
27987: GO 27961
27989: POP
27990: POP
// if e and not UnitGoingToBuilding ( p , e ) then
27991: LD_VAR 0 7
27995: IFFALSE 28014
27997: PUSH
27998: LD_VAR 0 5
28002: PPUSH
28003: LD_VAR 0 7
28007: PPUSH
28008: CALL 91211 0 2
28012: NOT
28013: AND
28014: IFFALSE 28073
// begin if IsInUnit ( p ) then
28016: LD_VAR 0 5
28020: PPUSH
28021: CALL_OW 310
28025: IFFALSE 28036
// ComExitBuilding ( p ) ;
28027: LD_VAR 0 5
28031: PPUSH
28032: CALL_OW 122
// ComEnterUnit ( p , e ) ;
28036: LD_VAR 0 5
28040: PPUSH
28041: LD_VAR 0 7
28045: PPUSH
28046: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
28050: LD_VAR 0 5
28054: PPUSH
28055: LD_VAR 0 3
28059: PPUSH
28060: CALL_OW 183
// AddComExitBuilding ( p ) ;
28064: LD_VAR 0 5
28068: PPUSH
28069: CALL_OW 182
// end ; end ;
28073: GO 27919
28075: POP
28076: POP
// end ;
28077: GO 27885
28079: POP
28080: POP
// end ;
28081: GO 27649
28083: POP
28084: POP
// end ;
28085: LD_VAR 0 1
28089: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
28090: LD_INT 0
28092: PPUSH
28093: PPUSH
28094: PPUSH
28095: PPUSH
28096: PPUSH
28097: PPUSH
28098: PPUSH
28099: PPUSH
28100: PPUSH
28101: PPUSH
28102: PPUSH
28103: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
28104: LD_ADDR_VAR 0 2
28108: PUSH
28109: LD_INT 0
28111: PUSH
28112: LD_INT 0
28114: PUSH
28115: LD_INT 0
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: EMPTY
28122: LIST
28123: LIST
28124: LIST
28125: LIST
28126: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
28127: LD_VAR 0 1
28131: NOT
28132: IFTRUE 28147
28134: PUSH
28135: LD_EXP 80
28139: PUSH
28140: LD_VAR 0 1
28144: ARRAY
28145: NOT
28146: OR
28147: IFTRUE 28195
28149: PUSH
28150: LD_EXP 80
28154: PUSH
28155: LD_VAR 0 1
28159: ARRAY
28160: PPUSH
28161: LD_INT 2
28163: PUSH
28164: LD_INT 30
28166: PUSH
28167: LD_INT 0
28169: PUSH
28170: EMPTY
28171: LIST
28172: LIST
28173: PUSH
28174: LD_INT 30
28176: PUSH
28177: LD_INT 1
28179: PUSH
28180: EMPTY
28181: LIST
28182: LIST
28183: PUSH
28184: EMPTY
28185: LIST
28186: LIST
28187: LIST
28188: PPUSH
28189: CALL_OW 72
28193: NOT
28194: OR
28195: IFFALSE 28199
// exit ;
28197: GO 31740
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
28199: LD_ADDR_VAR 0 4
28203: PUSH
28204: LD_EXP 80
28208: PUSH
28209: LD_VAR 0 1
28213: ARRAY
28214: PPUSH
28215: LD_INT 2
28217: PUSH
28218: LD_INT 25
28220: PUSH
28221: LD_INT 1
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: PUSH
28228: LD_INT 25
28230: PUSH
28231: LD_INT 2
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: PUSH
28238: LD_INT 25
28240: PUSH
28241: LD_INT 3
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 25
28250: PUSH
28251: LD_INT 4
28253: PUSH
28254: EMPTY
28255: LIST
28256: LIST
28257: PUSH
28258: LD_INT 25
28260: PUSH
28261: LD_INT 5
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 25
28270: PUSH
28271: LD_INT 8
28273: PUSH
28274: EMPTY
28275: LIST
28276: LIST
28277: PUSH
28278: LD_INT 25
28280: PUSH
28281: LD_INT 9
28283: PUSH
28284: EMPTY
28285: LIST
28286: LIST
28287: PUSH
28288: EMPTY
28289: LIST
28290: LIST
28291: LIST
28292: LIST
28293: LIST
28294: LIST
28295: LIST
28296: LIST
28297: PPUSH
28298: CALL_OW 72
28302: ST_TO_ADDR
// if not tmp then
28303: LD_VAR 0 4
28307: NOT
28308: IFFALSE 28312
// exit ;
28310: GO 31740
// for i in tmp do
28312: LD_ADDR_VAR 0 3
28316: PUSH
28317: LD_VAR 0 4
28321: PUSH
28322: FOR_IN
28323: IFFALSE 28354
// if GetTag ( i ) then
28325: LD_VAR 0 3
28329: PPUSH
28330: CALL_OW 110
28334: IFFALSE 28352
// tmp := tmp diff i ;
28336: LD_ADDR_VAR 0 4
28340: PUSH
28341: LD_VAR 0 4
28345: PUSH
28346: LD_VAR 0 3
28350: DIFF
28351: ST_TO_ADDR
28352: GO 28322
28354: POP
28355: POP
// if not tmp then
28356: LD_VAR 0 4
28360: NOT
28361: IFFALSE 28365
// exit ;
28363: GO 31740
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
28365: LD_ADDR_VAR 0 5
28369: PUSH
28370: LD_EXP 80
28374: PUSH
28375: LD_VAR 0 1
28379: ARRAY
28380: PPUSH
28381: LD_INT 2
28383: PUSH
28384: LD_INT 25
28386: PUSH
28387: LD_INT 1
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 25
28396: PUSH
28397: LD_INT 5
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 25
28406: PUSH
28407: LD_INT 8
28409: PUSH
28410: EMPTY
28411: LIST
28412: LIST
28413: PUSH
28414: LD_INT 25
28416: PUSH
28417: LD_INT 9
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: PPUSH
28431: CALL_OW 72
28435: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
28436: LD_ADDR_VAR 0 6
28440: PUSH
28441: LD_EXP 80
28445: PUSH
28446: LD_VAR 0 1
28450: ARRAY
28451: PPUSH
28452: LD_INT 25
28454: PUSH
28455: LD_INT 2
28457: PUSH
28458: EMPTY
28459: LIST
28460: LIST
28461: PPUSH
28462: CALL_OW 72
28466: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
28467: LD_ADDR_VAR 0 7
28471: PUSH
28472: LD_EXP 80
28476: PUSH
28477: LD_VAR 0 1
28481: ARRAY
28482: PPUSH
28483: LD_INT 25
28485: PUSH
28486: LD_INT 3
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: PPUSH
28493: CALL_OW 72
28497: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
28498: LD_ADDR_VAR 0 8
28502: PUSH
28503: LD_EXP 80
28507: PUSH
28508: LD_VAR 0 1
28512: ARRAY
28513: PPUSH
28514: LD_INT 25
28516: PUSH
28517: LD_INT 4
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: LD_INT 24
28526: PUSH
28527: LD_INT 251
28529: PUSH
28530: EMPTY
28531: LIST
28532: LIST
28533: PUSH
28534: EMPTY
28535: LIST
28536: LIST
28537: PPUSH
28538: CALL_OW 72
28542: ST_TO_ADDR
// if mc_is_defending [ base ] then
28543: LD_EXP 123
28547: PUSH
28548: LD_VAR 0 1
28552: ARRAY
28553: IFFALSE 29014
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
28555: LD_ADDR_EXP 122
28559: PUSH
28560: LD_EXP 122
28564: PPUSH
28565: LD_VAR 0 1
28569: PPUSH
28570: LD_INT 4
28572: PPUSH
28573: CALL_OW 1
28577: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
28578: LD_ADDR_VAR 0 12
28582: PUSH
28583: LD_EXP 80
28587: PUSH
28588: LD_VAR 0 1
28592: ARRAY
28593: PPUSH
28594: LD_INT 2
28596: PUSH
28597: LD_INT 30
28599: PUSH
28600: LD_INT 4
28602: PUSH
28603: EMPTY
28604: LIST
28605: LIST
28606: PUSH
28607: LD_INT 30
28609: PUSH
28610: LD_INT 5
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: LIST
28621: PPUSH
28622: CALL_OW 72
28626: ST_TO_ADDR
// if not b then
28627: LD_VAR 0 12
28631: NOT
28632: IFFALSE 28636
// exit ;
28634: GO 31740
// p := [ ] ;
28636: LD_ADDR_VAR 0 11
28640: PUSH
28641: EMPTY
28642: ST_TO_ADDR
// if sci >= 2 then
28643: LD_VAR 0 8
28647: PUSH
28648: LD_INT 2
28650: GREATEREQUAL
28651: IFFALSE 28682
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
28653: LD_ADDR_VAR 0 8
28657: PUSH
28658: LD_VAR 0 8
28662: PUSH
28663: LD_INT 1
28665: ARRAY
28666: PUSH
28667: LD_VAR 0 8
28671: PUSH
28672: LD_INT 2
28674: ARRAY
28675: PUSH
28676: EMPTY
28677: LIST
28678: LIST
28679: ST_TO_ADDR
28680: GO 28743
// if sci = 1 then
28682: LD_VAR 0 8
28686: PUSH
28687: LD_INT 1
28689: EQUAL
28690: IFFALSE 28711
// sci := [ sci [ 1 ] ] else
28692: LD_ADDR_VAR 0 8
28696: PUSH
28697: LD_VAR 0 8
28701: PUSH
28702: LD_INT 1
28704: ARRAY
28705: PUSH
28706: EMPTY
28707: LIST
28708: ST_TO_ADDR
28709: GO 28743
// if sci = 0 then
28711: LD_VAR 0 8
28715: PUSH
28716: LD_INT 0
28718: EQUAL
28719: IFFALSE 28743
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
28721: LD_ADDR_VAR 0 11
28725: PUSH
28726: LD_VAR 0 4
28730: PPUSH
28731: LD_INT 4
28733: PPUSH
28734: CALL 91081 0 2
28738: PUSH
28739: LD_INT 1
28741: ARRAY
28742: ST_TO_ADDR
// if eng > 4 then
28743: LD_VAR 0 6
28747: PUSH
28748: LD_INT 4
28750: GREATER
28751: IFFALSE 28797
// for i = eng downto 4 do
28753: LD_ADDR_VAR 0 3
28757: PUSH
28758: DOUBLE
28759: LD_VAR 0 6
28763: INC
28764: ST_TO_ADDR
28765: LD_INT 4
28767: PUSH
28768: FOR_DOWNTO
28769: IFFALSE 28795
// eng := eng diff eng [ i ] ;
28771: LD_ADDR_VAR 0 6
28775: PUSH
28776: LD_VAR 0 6
28780: PUSH
28781: LD_VAR 0 6
28785: PUSH
28786: LD_VAR 0 3
28790: ARRAY
28791: DIFF
28792: ST_TO_ADDR
28793: GO 28768
28795: POP
28796: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
28797: LD_ADDR_VAR 0 4
28801: PUSH
28802: LD_VAR 0 4
28806: PUSH
28807: LD_VAR 0 5
28811: PUSH
28812: LD_VAR 0 6
28816: UNION
28817: PUSH
28818: LD_VAR 0 7
28822: UNION
28823: PUSH
28824: LD_VAR 0 8
28828: UNION
28829: DIFF
28830: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
28831: LD_ADDR_VAR 0 13
28835: PUSH
28836: LD_EXP 80
28840: PUSH
28841: LD_VAR 0 1
28845: ARRAY
28846: PPUSH
28847: LD_INT 2
28849: PUSH
28850: LD_INT 30
28852: PUSH
28853: LD_INT 32
28855: PUSH
28856: EMPTY
28857: LIST
28858: LIST
28859: PUSH
28860: LD_INT 30
28862: PUSH
28863: LD_INT 31
28865: PUSH
28866: EMPTY
28867: LIST
28868: LIST
28869: PUSH
28870: EMPTY
28871: LIST
28872: LIST
28873: LIST
28874: PPUSH
28875: CALL_OW 72
28879: PUSH
28880: LD_EXP 80
28884: PUSH
28885: LD_VAR 0 1
28889: ARRAY
28890: PPUSH
28891: LD_INT 2
28893: PUSH
28894: LD_INT 30
28896: PUSH
28897: LD_INT 4
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 30
28906: PUSH
28907: LD_INT 5
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: LIST
28918: PPUSH
28919: CALL_OW 72
28923: PUSH
28924: LD_INT 6
28926: MUL
28927: PLUS
28928: ST_TO_ADDR
// if bcount < tmp then
28929: LD_VAR 0 13
28933: PUSH
28934: LD_VAR 0 4
28938: LESS
28939: IFFALSE 28985
// for i = tmp downto bcount do
28941: LD_ADDR_VAR 0 3
28945: PUSH
28946: DOUBLE
28947: LD_VAR 0 4
28951: INC
28952: ST_TO_ADDR
28953: LD_VAR 0 13
28957: PUSH
28958: FOR_DOWNTO
28959: IFFALSE 28983
// tmp := Delete ( tmp , tmp ) ;
28961: LD_ADDR_VAR 0 4
28965: PUSH
28966: LD_VAR 0 4
28970: PPUSH
28971: LD_VAR 0 4
28975: PPUSH
28976: CALL_OW 3
28980: ST_TO_ADDR
28981: GO 28958
28983: POP
28984: POP
// result := [ tmp , 0 , 0 , p ] ;
28985: LD_ADDR_VAR 0 2
28989: PUSH
28990: LD_VAR 0 4
28994: PUSH
28995: LD_INT 0
28997: PUSH
28998: LD_INT 0
29000: PUSH
29001: LD_VAR 0 11
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: LIST
29010: LIST
29011: ST_TO_ADDR
// exit ;
29012: GO 31740
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
29014: LD_EXP 80
29018: PUSH
29019: LD_VAR 0 1
29023: ARRAY
29024: PPUSH
29025: LD_INT 2
29027: PUSH
29028: LD_INT 30
29030: PUSH
29031: LD_INT 6
29033: PUSH
29034: EMPTY
29035: LIST
29036: LIST
29037: PUSH
29038: LD_INT 30
29040: PUSH
29041: LD_INT 7
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: LD_INT 30
29050: PUSH
29051: LD_INT 8
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: PUSH
29058: EMPTY
29059: LIST
29060: LIST
29061: LIST
29062: LIST
29063: PPUSH
29064: CALL_OW 72
29068: NOT
29069: IFFALSE 29099
29071: PUSH
29072: LD_EXP 80
29076: PUSH
29077: LD_VAR 0 1
29081: ARRAY
29082: PPUSH
29083: LD_INT 30
29085: PUSH
29086: LD_INT 3
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PPUSH
29093: CALL_OW 72
29097: NOT
29098: AND
29099: IFFALSE 29171
// begin if eng = tmp then
29101: LD_VAR 0 6
29105: PUSH
29106: LD_VAR 0 4
29110: EQUAL
29111: IFFALSE 29115
// exit ;
29113: GO 31740
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
29115: LD_ADDR_EXP 122
29119: PUSH
29120: LD_EXP 122
29124: PPUSH
29125: LD_VAR 0 1
29129: PPUSH
29130: LD_INT 1
29132: PPUSH
29133: CALL_OW 1
29137: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
29138: LD_ADDR_VAR 0 2
29142: PUSH
29143: LD_INT 0
29145: PUSH
29146: LD_VAR 0 4
29150: PUSH
29151: LD_VAR 0 6
29155: DIFF
29156: PUSH
29157: LD_INT 0
29159: PUSH
29160: LD_INT 0
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: LIST
29167: LIST
29168: ST_TO_ADDR
// exit ;
29169: GO 31740
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
29171: LD_EXP 107
29175: PUSH
29176: LD_EXP 106
29180: PUSH
29181: LD_VAR 0 1
29185: ARRAY
29186: ARRAY
29187: IFFALSE 29245
29189: PUSH
29190: LD_EXP 80
29194: PUSH
29195: LD_VAR 0 1
29199: ARRAY
29200: PPUSH
29201: LD_INT 2
29203: PUSH
29204: LD_INT 30
29206: PUSH
29207: LD_INT 6
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: PUSH
29214: LD_INT 30
29216: PUSH
29217: LD_INT 7
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: PUSH
29224: LD_INT 30
29226: PUSH
29227: LD_INT 8
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: PPUSH
29240: CALL_OW 72
29244: AND
29245: IFFALSE 29275
29247: PUSH
29248: LD_EXP 80
29252: PUSH
29253: LD_VAR 0 1
29257: ARRAY
29258: PPUSH
29259: LD_INT 30
29261: PUSH
29262: LD_INT 3
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PPUSH
29269: CALL_OW 72
29273: NOT
29274: AND
29275: IFFALSE 29491
// begin if sci >= 6 then
29277: LD_VAR 0 8
29281: PUSH
29282: LD_INT 6
29284: GREATEREQUAL
29285: IFFALSE 29289
// exit ;
29287: GO 31740
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
29289: LD_ADDR_EXP 122
29293: PUSH
29294: LD_EXP 122
29298: PPUSH
29299: LD_VAR 0 1
29303: PPUSH
29304: LD_INT 2
29306: PPUSH
29307: CALL_OW 1
29311: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
29312: LD_ADDR_VAR 0 9
29316: PUSH
29317: LD_VAR 0 4
29321: PUSH
29322: LD_VAR 0 8
29326: DIFF
29327: PPUSH
29328: LD_INT 4
29330: PPUSH
29331: CALL 91081 0 2
29335: ST_TO_ADDR
// p := [ ] ;
29336: LD_ADDR_VAR 0 11
29340: PUSH
29341: EMPTY
29342: ST_TO_ADDR
// if sci < 6 and sort > 6 then
29343: LD_VAR 0 8
29347: PUSH
29348: LD_INT 6
29350: LESS
29351: IFFALSE 29363
29353: PUSH
29354: LD_VAR 0 9
29358: PUSH
29359: LD_INT 6
29361: GREATER
29362: AND
29363: IFFALSE 29444
// begin for i = 1 to 6 - sci do
29365: LD_ADDR_VAR 0 3
29369: PUSH
29370: DOUBLE
29371: LD_INT 1
29373: DEC
29374: ST_TO_ADDR
29375: LD_INT 6
29377: PUSH
29378: LD_VAR 0 8
29382: MINUS
29383: PUSH
29384: FOR_TO
29385: IFFALSE 29440
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
29387: LD_ADDR_VAR 0 11
29391: PUSH
29392: LD_VAR 0 11
29396: PPUSH
29397: LD_VAR 0 11
29401: PUSH
29402: LD_INT 1
29404: PLUS
29405: PPUSH
29406: LD_VAR 0 9
29410: PUSH
29411: LD_INT 1
29413: ARRAY
29414: PPUSH
29415: CALL_OW 2
29419: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
29420: LD_ADDR_VAR 0 9
29424: PUSH
29425: LD_VAR 0 9
29429: PPUSH
29430: LD_INT 1
29432: PPUSH
29433: CALL_OW 3
29437: ST_TO_ADDR
// end ;
29438: GO 29384
29440: POP
29441: POP
// end else
29442: GO 29464
// if sort then
29444: LD_VAR 0 9
29448: IFFALSE 29464
// p := sort [ 1 ] ;
29450: LD_ADDR_VAR 0 11
29454: PUSH
29455: LD_VAR 0 9
29459: PUSH
29460: LD_INT 1
29462: ARRAY
29463: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
29464: LD_ADDR_VAR 0 2
29468: PUSH
29469: LD_INT 0
29471: PUSH
29472: LD_INT 0
29474: PUSH
29475: LD_INT 0
29477: PUSH
29478: LD_VAR 0 11
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: LIST
29487: LIST
29488: ST_TO_ADDR
// exit ;
29489: GO 31740
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
29491: LD_EXP 107
29495: PUSH
29496: LD_EXP 106
29500: PUSH
29501: LD_VAR 0 1
29505: ARRAY
29506: ARRAY
29507: IFFALSE 29565
29509: PUSH
29510: LD_EXP 80
29514: PUSH
29515: LD_VAR 0 1
29519: ARRAY
29520: PPUSH
29521: LD_INT 2
29523: PUSH
29524: LD_INT 30
29526: PUSH
29527: LD_INT 6
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PUSH
29534: LD_INT 30
29536: PUSH
29537: LD_INT 7
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 30
29546: PUSH
29547: LD_INT 8
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: LIST
29558: LIST
29559: PPUSH
29560: CALL_OW 72
29564: AND
29565: IFFALSE 29594
29567: PUSH
29568: LD_EXP 80
29572: PUSH
29573: LD_VAR 0 1
29577: ARRAY
29578: PPUSH
29579: LD_INT 30
29581: PUSH
29582: LD_INT 3
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PPUSH
29589: CALL_OW 72
29593: AND
29594: IFFALSE 30334
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
29596: LD_ADDR_EXP 122
29600: PUSH
29601: LD_EXP 122
29605: PPUSH
29606: LD_VAR 0 1
29610: PPUSH
29611: LD_INT 3
29613: PPUSH
29614: CALL_OW 1
29618: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29619: LD_ADDR_VAR 0 2
29623: PUSH
29624: LD_INT 0
29626: PUSH
29627: LD_INT 0
29629: PUSH
29630: LD_INT 0
29632: PUSH
29633: LD_INT 0
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: LIST
29640: LIST
29641: ST_TO_ADDR
// if not eng then
29642: LD_VAR 0 6
29646: NOT
29647: IFFALSE 29710
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
29649: LD_ADDR_VAR 0 11
29653: PUSH
29654: LD_VAR 0 4
29658: PPUSH
29659: LD_INT 2
29661: PPUSH
29662: CALL 91081 0 2
29666: PUSH
29667: LD_INT 1
29669: ARRAY
29670: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
29671: LD_ADDR_VAR 0 2
29675: PUSH
29676: LD_VAR 0 2
29680: PPUSH
29681: LD_INT 2
29683: PPUSH
29684: LD_VAR 0 11
29688: PPUSH
29689: CALL_OW 1
29693: ST_TO_ADDR
// tmp := tmp diff p ;
29694: LD_ADDR_VAR 0 4
29698: PUSH
29699: LD_VAR 0 4
29703: PUSH
29704: LD_VAR 0 11
29708: DIFF
29709: ST_TO_ADDR
// end ; if tmp and sci < 6 then
29710: LD_VAR 0 4
29714: IFFALSE 29726
29716: PUSH
29717: LD_VAR 0 8
29721: PUSH
29722: LD_INT 6
29724: LESS
29725: AND
29726: IFFALSE 29914
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
29728: LD_ADDR_VAR 0 9
29732: PUSH
29733: LD_VAR 0 4
29737: PUSH
29738: LD_VAR 0 8
29742: PUSH
29743: LD_VAR 0 7
29747: UNION
29748: DIFF
29749: PPUSH
29750: LD_INT 4
29752: PPUSH
29753: CALL 91081 0 2
29757: ST_TO_ADDR
// p := [ ] ;
29758: LD_ADDR_VAR 0 11
29762: PUSH
29763: EMPTY
29764: ST_TO_ADDR
// if sort then
29765: LD_VAR 0 9
29769: IFFALSE 29885
// for i = 1 to 6 - sci do
29771: LD_ADDR_VAR 0 3
29775: PUSH
29776: DOUBLE
29777: LD_INT 1
29779: DEC
29780: ST_TO_ADDR
29781: LD_INT 6
29783: PUSH
29784: LD_VAR 0 8
29788: MINUS
29789: PUSH
29790: FOR_TO
29791: IFFALSE 29883
// begin if i = sort then
29793: LD_VAR 0 3
29797: PUSH
29798: LD_VAR 0 9
29802: EQUAL
29803: IFFALSE 29807
// break ;
29805: GO 29883
// if GetClass ( i ) = 4 then
29807: LD_VAR 0 3
29811: PPUSH
29812: CALL_OW 257
29816: PUSH
29817: LD_INT 4
29819: EQUAL
29820: IFFALSE 29824
// continue ;
29822: GO 29790
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29824: LD_ADDR_VAR 0 11
29828: PUSH
29829: LD_VAR 0 11
29833: PPUSH
29834: LD_VAR 0 11
29838: PUSH
29839: LD_INT 1
29841: PLUS
29842: PPUSH
29843: LD_VAR 0 9
29847: PUSH
29848: LD_VAR 0 3
29852: ARRAY
29853: PPUSH
29854: CALL_OW 2
29858: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29859: LD_ADDR_VAR 0 4
29863: PUSH
29864: LD_VAR 0 4
29868: PUSH
29869: LD_VAR 0 9
29873: PUSH
29874: LD_VAR 0 3
29878: ARRAY
29879: DIFF
29880: ST_TO_ADDR
// end ;
29881: GO 29790
29883: POP
29884: POP
// if p then
29885: LD_VAR 0 11
29889: IFFALSE 29914
// result := Replace ( result , 4 , p ) ;
29891: LD_ADDR_VAR 0 2
29895: PUSH
29896: LD_VAR 0 2
29900: PPUSH
29901: LD_INT 4
29903: PPUSH
29904: LD_VAR 0 11
29908: PPUSH
29909: CALL_OW 1
29913: ST_TO_ADDR
// end ; if tmp and mech < 6 then
29914: LD_VAR 0 4
29918: IFFALSE 29930
29920: PUSH
29921: LD_VAR 0 7
29925: PUSH
29926: LD_INT 6
29928: LESS
29929: AND
29930: IFFALSE 30118
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29932: LD_ADDR_VAR 0 9
29936: PUSH
29937: LD_VAR 0 4
29941: PUSH
29942: LD_VAR 0 8
29946: PUSH
29947: LD_VAR 0 7
29951: UNION
29952: DIFF
29953: PPUSH
29954: LD_INT 3
29956: PPUSH
29957: CALL 91081 0 2
29961: ST_TO_ADDR
// p := [ ] ;
29962: LD_ADDR_VAR 0 11
29966: PUSH
29967: EMPTY
29968: ST_TO_ADDR
// if sort then
29969: LD_VAR 0 9
29973: IFFALSE 30089
// for i = 1 to 6 - mech do
29975: LD_ADDR_VAR 0 3
29979: PUSH
29980: DOUBLE
29981: LD_INT 1
29983: DEC
29984: ST_TO_ADDR
29985: LD_INT 6
29987: PUSH
29988: LD_VAR 0 7
29992: MINUS
29993: PUSH
29994: FOR_TO
29995: IFFALSE 30087
// begin if i = sort then
29997: LD_VAR 0 3
30001: PUSH
30002: LD_VAR 0 9
30006: EQUAL
30007: IFFALSE 30011
// break ;
30009: GO 30087
// if GetClass ( i ) = 3 then
30011: LD_VAR 0 3
30015: PPUSH
30016: CALL_OW 257
30020: PUSH
30021: LD_INT 3
30023: EQUAL
30024: IFFALSE 30028
// continue ;
30026: GO 29994
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30028: LD_ADDR_VAR 0 11
30032: PUSH
30033: LD_VAR 0 11
30037: PPUSH
30038: LD_VAR 0 11
30042: PUSH
30043: LD_INT 1
30045: PLUS
30046: PPUSH
30047: LD_VAR 0 9
30051: PUSH
30052: LD_VAR 0 3
30056: ARRAY
30057: PPUSH
30058: CALL_OW 2
30062: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30063: LD_ADDR_VAR 0 4
30067: PUSH
30068: LD_VAR 0 4
30072: PUSH
30073: LD_VAR 0 9
30077: PUSH
30078: LD_VAR 0 3
30082: ARRAY
30083: DIFF
30084: ST_TO_ADDR
// end ;
30085: GO 29994
30087: POP
30088: POP
// if p then
30089: LD_VAR 0 11
30093: IFFALSE 30118
// result := Replace ( result , 3 , p ) ;
30095: LD_ADDR_VAR 0 2
30099: PUSH
30100: LD_VAR 0 2
30104: PPUSH
30105: LD_INT 3
30107: PPUSH
30108: LD_VAR 0 11
30112: PPUSH
30113: CALL_OW 1
30117: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
30118: LD_VAR 0 4
30122: PUSH
30123: LD_INT 6
30125: GREATER
30126: IFFALSE 30138
30128: PUSH
30129: LD_VAR 0 6
30133: PUSH
30134: LD_INT 6
30136: LESS
30137: AND
30138: IFFALSE 30332
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
30140: LD_ADDR_VAR 0 9
30144: PUSH
30145: LD_VAR 0 4
30149: PUSH
30150: LD_VAR 0 8
30154: PUSH
30155: LD_VAR 0 7
30159: UNION
30160: PUSH
30161: LD_VAR 0 6
30165: UNION
30166: DIFF
30167: PPUSH
30168: LD_INT 2
30170: PPUSH
30171: CALL 91081 0 2
30175: ST_TO_ADDR
// p := [ ] ;
30176: LD_ADDR_VAR 0 11
30180: PUSH
30181: EMPTY
30182: ST_TO_ADDR
// if sort then
30183: LD_VAR 0 9
30187: IFFALSE 30303
// for i = 1 to 6 - eng do
30189: LD_ADDR_VAR 0 3
30193: PUSH
30194: DOUBLE
30195: LD_INT 1
30197: DEC
30198: ST_TO_ADDR
30199: LD_INT 6
30201: PUSH
30202: LD_VAR 0 6
30206: MINUS
30207: PUSH
30208: FOR_TO
30209: IFFALSE 30301
// begin if i = sort then
30211: LD_VAR 0 3
30215: PUSH
30216: LD_VAR 0 9
30220: EQUAL
30221: IFFALSE 30225
// break ;
30223: GO 30301
// if GetClass ( i ) = 2 then
30225: LD_VAR 0 3
30229: PPUSH
30230: CALL_OW 257
30234: PUSH
30235: LD_INT 2
30237: EQUAL
30238: IFFALSE 30242
// continue ;
30240: GO 30208
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30242: LD_ADDR_VAR 0 11
30246: PUSH
30247: LD_VAR 0 11
30251: PPUSH
30252: LD_VAR 0 11
30256: PUSH
30257: LD_INT 1
30259: PLUS
30260: PPUSH
30261: LD_VAR 0 9
30265: PUSH
30266: LD_VAR 0 3
30270: ARRAY
30271: PPUSH
30272: CALL_OW 2
30276: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30277: LD_ADDR_VAR 0 4
30281: PUSH
30282: LD_VAR 0 4
30286: PUSH
30287: LD_VAR 0 9
30291: PUSH
30292: LD_VAR 0 3
30296: ARRAY
30297: DIFF
30298: ST_TO_ADDR
// end ;
30299: GO 30208
30301: POP
30302: POP
// if p then
30303: LD_VAR 0 11
30307: IFFALSE 30332
// result := Replace ( result , 2 , p ) ;
30309: LD_ADDR_VAR 0 2
30313: PUSH
30314: LD_VAR 0 2
30318: PPUSH
30319: LD_INT 2
30321: PPUSH
30322: LD_VAR 0 11
30326: PPUSH
30327: CALL_OW 1
30331: ST_TO_ADDR
// end ; exit ;
30332: GO 31740
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
30334: LD_EXP 107
30338: PUSH
30339: LD_EXP 106
30343: PUSH
30344: LD_VAR 0 1
30348: ARRAY
30349: ARRAY
30350: NOT
30351: IFFALSE 30380
30353: PUSH
30354: LD_EXP 80
30358: PUSH
30359: LD_VAR 0 1
30363: ARRAY
30364: PPUSH
30365: LD_INT 30
30367: PUSH
30368: LD_INT 3
30370: PUSH
30371: EMPTY
30372: LIST
30373: LIST
30374: PPUSH
30375: CALL_OW 72
30379: AND
30380: IFFALSE 30394
30382: PUSH
30383: LD_EXP 85
30387: PUSH
30388: LD_VAR 0 1
30392: ARRAY
30393: AND
30394: IFFALSE 31008
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
30396: LD_ADDR_EXP 122
30400: PUSH
30401: LD_EXP 122
30405: PPUSH
30406: LD_VAR 0 1
30410: PPUSH
30411: LD_INT 5
30413: PPUSH
30414: CALL_OW 1
30418: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
30419: LD_ADDR_VAR 0 2
30423: PUSH
30424: LD_INT 0
30426: PUSH
30427: LD_INT 0
30429: PUSH
30430: LD_INT 0
30432: PUSH
30433: LD_INT 0
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: LIST
30440: LIST
30441: ST_TO_ADDR
// if sci > 1 then
30442: LD_VAR 0 8
30446: PUSH
30447: LD_INT 1
30449: GREATER
30450: IFFALSE 30478
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
30452: LD_ADDR_VAR 0 4
30456: PUSH
30457: LD_VAR 0 4
30461: PUSH
30462: LD_VAR 0 8
30466: PUSH
30467: LD_VAR 0 8
30471: PUSH
30472: LD_INT 1
30474: ARRAY
30475: DIFF
30476: DIFF
30477: ST_TO_ADDR
// if tmp and not sci then
30478: LD_VAR 0 4
30482: IFFALSE 30491
30484: PUSH
30485: LD_VAR 0 8
30489: NOT
30490: AND
30491: IFFALSE 30560
// begin sort := SortBySkill ( tmp , 4 ) ;
30493: LD_ADDR_VAR 0 9
30497: PUSH
30498: LD_VAR 0 4
30502: PPUSH
30503: LD_INT 4
30505: PPUSH
30506: CALL 91081 0 2
30510: ST_TO_ADDR
// if sort then
30511: LD_VAR 0 9
30515: IFFALSE 30531
// p := sort [ 1 ] ;
30517: LD_ADDR_VAR 0 11
30521: PUSH
30522: LD_VAR 0 9
30526: PUSH
30527: LD_INT 1
30529: ARRAY
30530: ST_TO_ADDR
// if p then
30531: LD_VAR 0 11
30535: IFFALSE 30560
// result := Replace ( result , 4 , p ) ;
30537: LD_ADDR_VAR 0 2
30541: PUSH
30542: LD_VAR 0 2
30546: PPUSH
30547: LD_INT 4
30549: PPUSH
30550: LD_VAR 0 11
30554: PPUSH
30555: CALL_OW 1
30559: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30560: LD_ADDR_VAR 0 4
30564: PUSH
30565: LD_VAR 0 4
30569: PUSH
30570: LD_VAR 0 7
30574: DIFF
30575: ST_TO_ADDR
// if tmp and mech < 6 then
30576: LD_VAR 0 4
30580: IFFALSE 30592
30582: PUSH
30583: LD_VAR 0 7
30587: PUSH
30588: LD_INT 6
30590: LESS
30591: AND
30592: IFFALSE 30780
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
30594: LD_ADDR_VAR 0 9
30598: PUSH
30599: LD_VAR 0 4
30603: PUSH
30604: LD_VAR 0 8
30608: PUSH
30609: LD_VAR 0 7
30613: UNION
30614: DIFF
30615: PPUSH
30616: LD_INT 3
30618: PPUSH
30619: CALL 91081 0 2
30623: ST_TO_ADDR
// p := [ ] ;
30624: LD_ADDR_VAR 0 11
30628: PUSH
30629: EMPTY
30630: ST_TO_ADDR
// if sort then
30631: LD_VAR 0 9
30635: IFFALSE 30751
// for i = 1 to 6 - mech do
30637: LD_ADDR_VAR 0 3
30641: PUSH
30642: DOUBLE
30643: LD_INT 1
30645: DEC
30646: ST_TO_ADDR
30647: LD_INT 6
30649: PUSH
30650: LD_VAR 0 7
30654: MINUS
30655: PUSH
30656: FOR_TO
30657: IFFALSE 30749
// begin if i = sort then
30659: LD_VAR 0 3
30663: PUSH
30664: LD_VAR 0 9
30668: EQUAL
30669: IFFALSE 30673
// break ;
30671: GO 30749
// if GetClass ( i ) = 3 then
30673: LD_VAR 0 3
30677: PPUSH
30678: CALL_OW 257
30682: PUSH
30683: LD_INT 3
30685: EQUAL
30686: IFFALSE 30690
// continue ;
30688: GO 30656
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30690: LD_ADDR_VAR 0 11
30694: PUSH
30695: LD_VAR 0 11
30699: PPUSH
30700: LD_VAR 0 11
30704: PUSH
30705: LD_INT 1
30707: PLUS
30708: PPUSH
30709: LD_VAR 0 9
30713: PUSH
30714: LD_VAR 0 3
30718: ARRAY
30719: PPUSH
30720: CALL_OW 2
30724: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30725: LD_ADDR_VAR 0 4
30729: PUSH
30730: LD_VAR 0 4
30734: PUSH
30735: LD_VAR 0 9
30739: PUSH
30740: LD_VAR 0 3
30744: ARRAY
30745: DIFF
30746: ST_TO_ADDR
// end ;
30747: GO 30656
30749: POP
30750: POP
// if p then
30751: LD_VAR 0 11
30755: IFFALSE 30780
// result := Replace ( result , 3 , p ) ;
30757: LD_ADDR_VAR 0 2
30761: PUSH
30762: LD_VAR 0 2
30766: PPUSH
30767: LD_INT 3
30769: PPUSH
30770: LD_VAR 0 11
30774: PPUSH
30775: CALL_OW 1
30779: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30780: LD_ADDR_VAR 0 4
30784: PUSH
30785: LD_VAR 0 4
30789: PUSH
30790: LD_VAR 0 6
30794: DIFF
30795: ST_TO_ADDR
// if tmp and eng < 6 then
30796: LD_VAR 0 4
30800: IFFALSE 30812
30802: PUSH
30803: LD_VAR 0 6
30807: PUSH
30808: LD_INT 6
30810: LESS
30811: AND
30812: IFFALSE 31006
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
30814: LD_ADDR_VAR 0 9
30818: PUSH
30819: LD_VAR 0 4
30823: PUSH
30824: LD_VAR 0 8
30828: PUSH
30829: LD_VAR 0 7
30833: UNION
30834: PUSH
30835: LD_VAR 0 6
30839: UNION
30840: DIFF
30841: PPUSH
30842: LD_INT 2
30844: PPUSH
30845: CALL 91081 0 2
30849: ST_TO_ADDR
// p := [ ] ;
30850: LD_ADDR_VAR 0 11
30854: PUSH
30855: EMPTY
30856: ST_TO_ADDR
// if sort then
30857: LD_VAR 0 9
30861: IFFALSE 30977
// for i = 1 to 6 - eng do
30863: LD_ADDR_VAR 0 3
30867: PUSH
30868: DOUBLE
30869: LD_INT 1
30871: DEC
30872: ST_TO_ADDR
30873: LD_INT 6
30875: PUSH
30876: LD_VAR 0 6
30880: MINUS
30881: PUSH
30882: FOR_TO
30883: IFFALSE 30975
// begin if i = sort then
30885: LD_VAR 0 3
30889: PUSH
30890: LD_VAR 0 9
30894: EQUAL
30895: IFFALSE 30899
// break ;
30897: GO 30975
// if GetClass ( i ) = 2 then
30899: LD_VAR 0 3
30903: PPUSH
30904: CALL_OW 257
30908: PUSH
30909: LD_INT 2
30911: EQUAL
30912: IFFALSE 30916
// continue ;
30914: GO 30882
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30916: LD_ADDR_VAR 0 11
30920: PUSH
30921: LD_VAR 0 11
30925: PPUSH
30926: LD_VAR 0 11
30930: PUSH
30931: LD_INT 1
30933: PLUS
30934: PPUSH
30935: LD_VAR 0 9
30939: PUSH
30940: LD_VAR 0 3
30944: ARRAY
30945: PPUSH
30946: CALL_OW 2
30950: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30951: LD_ADDR_VAR 0 4
30955: PUSH
30956: LD_VAR 0 4
30960: PUSH
30961: LD_VAR 0 9
30965: PUSH
30966: LD_VAR 0 3
30970: ARRAY
30971: DIFF
30972: ST_TO_ADDR
// end ;
30973: GO 30882
30975: POP
30976: POP
// if p then
30977: LD_VAR 0 11
30981: IFFALSE 31006
// result := Replace ( result , 2 , p ) ;
30983: LD_ADDR_VAR 0 2
30987: PUSH
30988: LD_VAR 0 2
30992: PPUSH
30993: LD_INT 2
30995: PPUSH
30996: LD_VAR 0 11
31000: PPUSH
31001: CALL_OW 1
31005: ST_TO_ADDR
// end ; exit ;
31006: GO 31740
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
31008: LD_EXP 107
31012: PUSH
31013: LD_EXP 106
31017: PUSH
31018: LD_VAR 0 1
31022: ARRAY
31023: ARRAY
31024: NOT
31025: IFFALSE 31054
31027: PUSH
31028: LD_EXP 80
31032: PUSH
31033: LD_VAR 0 1
31037: ARRAY
31038: PPUSH
31039: LD_INT 30
31041: PUSH
31042: LD_INT 3
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: PPUSH
31049: CALL_OW 72
31053: AND
31054: IFFALSE 31069
31056: PUSH
31057: LD_EXP 85
31061: PUSH
31062: LD_VAR 0 1
31066: ARRAY
31067: NOT
31068: AND
31069: IFFALSE 31740
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
31071: LD_ADDR_EXP 122
31075: PUSH
31076: LD_EXP 122
31080: PPUSH
31081: LD_VAR 0 1
31085: PPUSH
31086: LD_INT 6
31088: PPUSH
31089: CALL_OW 1
31093: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
31094: LD_ADDR_VAR 0 2
31098: PUSH
31099: LD_INT 0
31101: PUSH
31102: LD_INT 0
31104: PUSH
31105: LD_INT 0
31107: PUSH
31108: LD_INT 0
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: LIST
31115: LIST
31116: ST_TO_ADDR
// if sci >= 1 then
31117: LD_VAR 0 8
31121: PUSH
31122: LD_INT 1
31124: GREATEREQUAL
31125: IFFALSE 31147
// tmp := tmp diff sci [ 1 ] ;
31127: LD_ADDR_VAR 0 4
31131: PUSH
31132: LD_VAR 0 4
31136: PUSH
31137: LD_VAR 0 8
31141: PUSH
31142: LD_INT 1
31144: ARRAY
31145: DIFF
31146: ST_TO_ADDR
// if tmp and not sci then
31147: LD_VAR 0 4
31151: IFFALSE 31160
31153: PUSH
31154: LD_VAR 0 8
31158: NOT
31159: AND
31160: IFFALSE 31229
// begin sort := SortBySkill ( tmp , 4 ) ;
31162: LD_ADDR_VAR 0 9
31166: PUSH
31167: LD_VAR 0 4
31171: PPUSH
31172: LD_INT 4
31174: PPUSH
31175: CALL 91081 0 2
31179: ST_TO_ADDR
// if sort then
31180: LD_VAR 0 9
31184: IFFALSE 31200
// p := sort [ 1 ] ;
31186: LD_ADDR_VAR 0 11
31190: PUSH
31191: LD_VAR 0 9
31195: PUSH
31196: LD_INT 1
31198: ARRAY
31199: ST_TO_ADDR
// if p then
31200: LD_VAR 0 11
31204: IFFALSE 31229
// result := Replace ( result , 4 , p ) ;
31206: LD_ADDR_VAR 0 2
31210: PUSH
31211: LD_VAR 0 2
31215: PPUSH
31216: LD_INT 4
31218: PPUSH
31219: LD_VAR 0 11
31223: PPUSH
31224: CALL_OW 1
31228: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
31229: LD_ADDR_VAR 0 4
31233: PUSH
31234: LD_VAR 0 4
31238: PUSH
31239: LD_VAR 0 7
31243: DIFF
31244: ST_TO_ADDR
// if tmp and mech < 6 then
31245: LD_VAR 0 4
31249: IFFALSE 31261
31251: PUSH
31252: LD_VAR 0 7
31256: PUSH
31257: LD_INT 6
31259: LESS
31260: AND
31261: IFFALSE 31443
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
31263: LD_ADDR_VAR 0 9
31267: PUSH
31268: LD_VAR 0 4
31272: PUSH
31273: LD_VAR 0 7
31277: DIFF
31278: PPUSH
31279: LD_INT 3
31281: PPUSH
31282: CALL 91081 0 2
31286: ST_TO_ADDR
// p := [ ] ;
31287: LD_ADDR_VAR 0 11
31291: PUSH
31292: EMPTY
31293: ST_TO_ADDR
// if sort then
31294: LD_VAR 0 9
31298: IFFALSE 31414
// for i = 1 to 6 - mech do
31300: LD_ADDR_VAR 0 3
31304: PUSH
31305: DOUBLE
31306: LD_INT 1
31308: DEC
31309: ST_TO_ADDR
31310: LD_INT 6
31312: PUSH
31313: LD_VAR 0 7
31317: MINUS
31318: PUSH
31319: FOR_TO
31320: IFFALSE 31412
// begin if i = sort then
31322: LD_VAR 0 3
31326: PUSH
31327: LD_VAR 0 9
31331: EQUAL
31332: IFFALSE 31336
// break ;
31334: GO 31412
// if GetClass ( i ) = 3 then
31336: LD_VAR 0 3
31340: PPUSH
31341: CALL_OW 257
31345: PUSH
31346: LD_INT 3
31348: EQUAL
31349: IFFALSE 31353
// continue ;
31351: GO 31319
// p := Insert ( p , p + 1 , sort [ i ] ) ;
31353: LD_ADDR_VAR 0 11
31357: PUSH
31358: LD_VAR 0 11
31362: PPUSH
31363: LD_VAR 0 11
31367: PUSH
31368: LD_INT 1
31370: PLUS
31371: PPUSH
31372: LD_VAR 0 9
31376: PUSH
31377: LD_VAR 0 3
31381: ARRAY
31382: PPUSH
31383: CALL_OW 2
31387: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31388: LD_ADDR_VAR 0 4
31392: PUSH
31393: LD_VAR 0 4
31397: PUSH
31398: LD_VAR 0 9
31402: PUSH
31403: LD_VAR 0 3
31407: ARRAY
31408: DIFF
31409: ST_TO_ADDR
// end ;
31410: GO 31319
31412: POP
31413: POP
// if p then
31414: LD_VAR 0 11
31418: IFFALSE 31443
// result := Replace ( result , 3 , p ) ;
31420: LD_ADDR_VAR 0 2
31424: PUSH
31425: LD_VAR 0 2
31429: PPUSH
31430: LD_INT 3
31432: PPUSH
31433: LD_VAR 0 11
31437: PPUSH
31438: CALL_OW 1
31442: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
31443: LD_ADDR_VAR 0 4
31447: PUSH
31448: LD_VAR 0 4
31452: PUSH
31453: LD_VAR 0 6
31457: DIFF
31458: ST_TO_ADDR
// if tmp and eng < 4 then
31459: LD_VAR 0 4
31463: IFFALSE 31475
31465: PUSH
31466: LD_VAR 0 6
31470: PUSH
31471: LD_INT 4
31473: LESS
31474: AND
31475: IFFALSE 31665
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
31477: LD_ADDR_VAR 0 9
31481: PUSH
31482: LD_VAR 0 4
31486: PUSH
31487: LD_VAR 0 7
31491: PUSH
31492: LD_VAR 0 6
31496: UNION
31497: DIFF
31498: PPUSH
31499: LD_INT 2
31501: PPUSH
31502: CALL 91081 0 2
31506: ST_TO_ADDR
// p := [ ] ;
31507: LD_ADDR_VAR 0 11
31511: PUSH
31512: EMPTY
31513: ST_TO_ADDR
// if sort then
31514: LD_VAR 0 9
31518: IFFALSE 31634
// for i = 1 to 4 - eng do
31520: LD_ADDR_VAR 0 3
31524: PUSH
31525: DOUBLE
31526: LD_INT 1
31528: DEC
31529: ST_TO_ADDR
31530: LD_INT 4
31532: PUSH
31533: LD_VAR 0 6
31537: MINUS
31538: PUSH
31539: FOR_TO
31540: IFFALSE 31632
// begin if i = sort then
31542: LD_VAR 0 3
31546: PUSH
31547: LD_VAR 0 9
31551: EQUAL
31552: IFFALSE 31556
// break ;
31554: GO 31632
// if GetClass ( i ) = 2 then
31556: LD_VAR 0 3
31560: PPUSH
31561: CALL_OW 257
31565: PUSH
31566: LD_INT 2
31568: EQUAL
31569: IFFALSE 31573
// continue ;
31571: GO 31539
// p := Insert ( p , p + 1 , sort [ i ] ) ;
31573: LD_ADDR_VAR 0 11
31577: PUSH
31578: LD_VAR 0 11
31582: PPUSH
31583: LD_VAR 0 11
31587: PUSH
31588: LD_INT 1
31590: PLUS
31591: PPUSH
31592: LD_VAR 0 9
31596: PUSH
31597: LD_VAR 0 3
31601: ARRAY
31602: PPUSH
31603: CALL_OW 2
31607: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31608: LD_ADDR_VAR 0 4
31612: PUSH
31613: LD_VAR 0 4
31617: PUSH
31618: LD_VAR 0 9
31622: PUSH
31623: LD_VAR 0 3
31627: ARRAY
31628: DIFF
31629: ST_TO_ADDR
// end ;
31630: GO 31539
31632: POP
31633: POP
// if p then
31634: LD_VAR 0 11
31638: IFFALSE 31663
// result := Replace ( result , 2 , p ) ;
31640: LD_ADDR_VAR 0 2
31644: PUSH
31645: LD_VAR 0 2
31649: PPUSH
31650: LD_INT 2
31652: PPUSH
31653: LD_VAR 0 11
31657: PPUSH
31658: CALL_OW 1
31662: ST_TO_ADDR
// end else
31663: GO 31709
// for i = eng downto 5 do
31665: LD_ADDR_VAR 0 3
31669: PUSH
31670: DOUBLE
31671: LD_VAR 0 6
31675: INC
31676: ST_TO_ADDR
31677: LD_INT 5
31679: PUSH
31680: FOR_DOWNTO
31681: IFFALSE 31707
// tmp := tmp union eng [ i ] ;
31683: LD_ADDR_VAR 0 4
31687: PUSH
31688: LD_VAR 0 4
31692: PUSH
31693: LD_VAR 0 6
31697: PUSH
31698: LD_VAR 0 3
31702: ARRAY
31703: UNION
31704: ST_TO_ADDR
31705: GO 31680
31707: POP
31708: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
31709: LD_ADDR_VAR 0 2
31713: PUSH
31714: LD_VAR 0 2
31718: PPUSH
31719: LD_INT 1
31721: PPUSH
31722: LD_VAR 0 4
31726: PUSH
31727: LD_VAR 0 5
31731: DIFF
31732: PPUSH
31733: CALL_OW 1
31737: ST_TO_ADDR
// exit ;
31738: GO 31740
// end ; end ;
31740: LD_VAR 0 2
31744: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
31745: LD_INT 0
31747: PPUSH
31748: PPUSH
31749: PPUSH
// if not mc_bases then
31750: LD_EXP 80
31754: NOT
31755: IFFALSE 31759
// exit ;
31757: GO 31901
// for i = 1 to mc_bases do
31759: LD_ADDR_VAR 0 2
31763: PUSH
31764: DOUBLE
31765: LD_INT 1
31767: DEC
31768: ST_TO_ADDR
31769: LD_EXP 80
31773: PUSH
31774: FOR_TO
31775: IFFALSE 31892
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
31777: LD_ADDR_VAR 0 3
31781: PUSH
31782: LD_EXP 80
31786: PUSH
31787: LD_VAR 0 2
31791: ARRAY
31792: PPUSH
31793: LD_INT 21
31795: PUSH
31796: LD_INT 3
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: PUSH
31803: LD_INT 3
31805: PUSH
31806: LD_INT 2
31808: PUSH
31809: LD_INT 30
31811: PUSH
31812: LD_INT 29
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: LD_INT 30
31821: PUSH
31822: LD_INT 30
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: LIST
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 3
31840: PUSH
31841: LD_INT 24
31843: PUSH
31844: LD_INT 1000
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: LIST
31859: PPUSH
31860: CALL_OW 72
31864: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
31865: LD_ADDR_EXP 81
31869: PUSH
31870: LD_EXP 81
31874: PPUSH
31875: LD_VAR 0 2
31879: PPUSH
31880: LD_VAR 0 3
31884: PPUSH
31885: CALL_OW 1
31889: ST_TO_ADDR
// end ;
31890: GO 31774
31892: POP
31893: POP
// RaiseSailEvent ( 101 ) ;
31894: LD_INT 101
31896: PPUSH
31897: CALL_OW 427
// end ;
31901: LD_VAR 0 1
31905: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
31906: LD_INT 0
31908: PPUSH
31909: PPUSH
31910: PPUSH
31911: PPUSH
31912: PPUSH
31913: PPUSH
31914: PPUSH
// if not mc_bases then
31915: LD_EXP 80
31919: NOT
31920: IFFALSE 31924
// exit ;
31922: GO 32488
// for i = 1 to mc_bases do
31924: LD_ADDR_VAR 0 2
31928: PUSH
31929: DOUBLE
31930: LD_INT 1
31932: DEC
31933: ST_TO_ADDR
31934: LD_EXP 80
31938: PUSH
31939: FOR_TO
31940: IFFALSE 32479
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
31942: LD_ADDR_VAR 0 5
31946: PUSH
31947: LD_EXP 80
31951: PUSH
31952: LD_VAR 0 2
31956: ARRAY
31957: PUSH
31958: LD_EXP 109
31962: PUSH
31963: LD_VAR 0 2
31967: ARRAY
31968: UNION
31969: PPUSH
31970: LD_INT 21
31972: PUSH
31973: LD_INT 1
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: PUSH
31983: LD_INT 3
31985: PUSH
31986: LD_INT 54
31988: PUSH
31989: EMPTY
31990: LIST
31991: PUSH
31992: EMPTY
31993: LIST
31994: LIST
31995: PUSH
31996: LD_INT 3
31998: PUSH
31999: LD_INT 24
32001: PUSH
32002: LD_INT 1000
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: LIST
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PPUSH
32022: CALL_OW 72
32026: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
32027: LD_ADDR_VAR 0 6
32031: PUSH
32032: LD_EXP 80
32036: PUSH
32037: LD_VAR 0 2
32041: ARRAY
32042: PPUSH
32043: LD_INT 21
32045: PUSH
32046: LD_INT 1
32048: PUSH
32049: EMPTY
32050: LIST
32051: LIST
32052: PUSH
32053: LD_INT 1
32055: PUSH
32056: LD_INT 3
32058: PUSH
32059: LD_INT 54
32061: PUSH
32062: EMPTY
32063: LIST
32064: PUSH
32065: EMPTY
32066: LIST
32067: LIST
32068: PUSH
32069: LD_INT 3
32071: PUSH
32072: LD_INT 24
32074: PUSH
32075: LD_INT 250
32077: PUSH
32078: EMPTY
32079: LIST
32080: LIST
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: LIST
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PPUSH
32095: CALL_OW 72
32099: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
32100: LD_ADDR_VAR 0 7
32104: PUSH
32105: LD_VAR 0 5
32109: PUSH
32110: LD_VAR 0 6
32114: DIFF
32115: ST_TO_ADDR
// if not need_heal_1 then
32116: LD_VAR 0 6
32120: NOT
32121: IFFALSE 32154
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
32123: LD_ADDR_EXP 83
32127: PUSH
32128: LD_EXP 83
32132: PPUSH
32133: LD_VAR 0 2
32137: PUSH
32138: LD_INT 1
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PPUSH
32145: EMPTY
32146: PPUSH
32147: CALL 59553 0 3
32151: ST_TO_ADDR
32152: GO 32224
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
32154: LD_ADDR_EXP 83
32158: PUSH
32159: LD_EXP 83
32163: PPUSH
32164: LD_VAR 0 2
32168: PUSH
32169: LD_INT 1
32171: PUSH
32172: EMPTY
32173: LIST
32174: LIST
32175: PPUSH
32176: LD_EXP 83
32180: PUSH
32181: LD_VAR 0 2
32185: ARRAY
32186: PUSH
32187: LD_INT 1
32189: ARRAY
32190: PPUSH
32191: LD_INT 3
32193: PUSH
32194: LD_INT 24
32196: PUSH
32197: LD_INT 1000
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: PPUSH
32208: CALL_OW 72
32212: PUSH
32213: LD_VAR 0 6
32217: UNION
32218: PPUSH
32219: CALL 59553 0 3
32223: ST_TO_ADDR
// if not need_heal_2 then
32224: LD_VAR 0 7
32228: NOT
32229: IFFALSE 32262
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
32231: LD_ADDR_EXP 83
32235: PUSH
32236: LD_EXP 83
32240: PPUSH
32241: LD_VAR 0 2
32245: PUSH
32246: LD_INT 2
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PPUSH
32253: EMPTY
32254: PPUSH
32255: CALL 59553 0 3
32259: ST_TO_ADDR
32260: GO 32294
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
32262: LD_ADDR_EXP 83
32266: PUSH
32267: LD_EXP 83
32271: PPUSH
32272: LD_VAR 0 2
32276: PUSH
32277: LD_INT 2
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PPUSH
32284: LD_VAR 0 7
32288: PPUSH
32289: CALL 59553 0 3
32293: ST_TO_ADDR
// if need_heal_2 then
32294: LD_VAR 0 7
32298: IFFALSE 32459
// for j in need_heal_2 do
32300: LD_ADDR_VAR 0 3
32304: PUSH
32305: LD_VAR 0 7
32309: PUSH
32310: FOR_IN
32311: IFFALSE 32457
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32313: LD_ADDR_VAR 0 5
32317: PUSH
32318: LD_EXP 80
32322: PUSH
32323: LD_VAR 0 2
32327: ARRAY
32328: PPUSH
32329: LD_INT 2
32331: PUSH
32332: LD_INT 30
32334: PUSH
32335: LD_INT 6
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 30
32344: PUSH
32345: LD_INT 7
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 30
32354: PUSH
32355: LD_INT 8
32357: PUSH
32358: EMPTY
32359: LIST
32360: LIST
32361: PUSH
32362: LD_INT 30
32364: PUSH
32365: LD_INT 0
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 30
32374: PUSH
32375: LD_INT 1
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: LIST
32386: LIST
32387: LIST
32388: LIST
32389: PPUSH
32390: CALL_OW 72
32394: ST_TO_ADDR
// if tmp then
32395: LD_VAR 0 5
32399: IFFALSE 32455
// begin k := NearestUnitToUnit ( tmp , j ) ;
32401: LD_ADDR_VAR 0 4
32405: PUSH
32406: LD_VAR 0 5
32410: PPUSH
32411: LD_VAR 0 3
32415: PPUSH
32416: CALL_OW 74
32420: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
32421: LD_VAR 0 3
32425: PPUSH
32426: LD_VAR 0 4
32430: PPUSH
32431: CALL_OW 296
32435: PUSH
32436: LD_INT 5
32438: GREATER
32439: IFFALSE 32455
// ComMoveToNearbyEntrance ( j , k ) ;
32441: LD_VAR 0 3
32445: PPUSH
32446: LD_VAR 0 4
32450: PPUSH
32451: CALL 93480 0 2
// end ; end ;
32455: GO 32310
32457: POP
32458: POP
// if not need_heal_1 and not need_heal_2 then
32459: LD_VAR 0 6
32463: NOT
32464: IFFALSE 32473
32466: PUSH
32467: LD_VAR 0 7
32471: NOT
32472: AND
32473: IFFALSE 32477
// continue ;
32475: GO 31939
// end ;
32477: GO 31939
32479: POP
32480: POP
// RaiseSailEvent ( 102 ) ;
32481: LD_INT 102
32483: PPUSH
32484: CALL_OW 427
// end ;
32488: LD_VAR 0 1
32492: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
32493: LD_INT 0
32495: PPUSH
32496: PPUSH
32497: PPUSH
32498: PPUSH
32499: PPUSH
32500: PPUSH
32501: PPUSH
32502: PPUSH
// if not mc_bases then
32503: LD_EXP 80
32507: NOT
32508: IFFALSE 32512
// exit ;
32510: GO 33427
// for i = 1 to mc_bases do
32512: LD_ADDR_VAR 0 2
32516: PUSH
32517: DOUBLE
32518: LD_INT 1
32520: DEC
32521: ST_TO_ADDR
32522: LD_EXP 80
32526: PUSH
32527: FOR_TO
32528: IFFALSE 33425
// begin if not mc_building_need_repair [ i ] then
32530: LD_EXP 81
32534: PUSH
32535: LD_VAR 0 2
32539: ARRAY
32540: NOT
32541: IFFALSE 32726
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
32543: LD_ADDR_VAR 0 6
32547: PUSH
32548: LD_EXP 99
32552: PUSH
32553: LD_VAR 0 2
32557: ARRAY
32558: PPUSH
32559: LD_INT 3
32561: PUSH
32562: LD_INT 24
32564: PUSH
32565: LD_INT 1000
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 2
32578: PUSH
32579: LD_INT 34
32581: PUSH
32582: LD_INT 13
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: PUSH
32589: LD_INT 34
32591: PUSH
32592: LD_INT 52
32594: PUSH
32595: EMPTY
32596: LIST
32597: LIST
32598: PUSH
32599: LD_INT 34
32601: PUSH
32602: LD_INT 88
32604: PUSH
32605: EMPTY
32606: LIST
32607: LIST
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: LIST
32613: LIST
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PPUSH
32619: CALL_OW 72
32623: ST_TO_ADDR
// if cranes then
32624: LD_VAR 0 6
32628: IFFALSE 32690
// for j in cranes do
32630: LD_ADDR_VAR 0 3
32634: PUSH
32635: LD_VAR 0 6
32639: PUSH
32640: FOR_IN
32641: IFFALSE 32688
// if not IsInArea ( j , mc_parking [ i ] ) then
32643: LD_VAR 0 3
32647: PPUSH
32648: LD_EXP 104
32652: PUSH
32653: LD_VAR 0 2
32657: ARRAY
32658: PPUSH
32659: CALL_OW 308
32663: NOT
32664: IFFALSE 32686
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32666: LD_VAR 0 3
32670: PPUSH
32671: LD_EXP 104
32675: PUSH
32676: LD_VAR 0 2
32680: ARRAY
32681: PPUSH
32682: CALL_OW 113
32686: GO 32640
32688: POP
32689: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
32690: LD_ADDR_EXP 82
32694: PUSH
32695: LD_EXP 82
32699: PPUSH
32700: LD_VAR 0 2
32704: PPUSH
32705: EMPTY
32706: PPUSH
32707: CALL_OW 1
32711: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
32712: LD_VAR 0 2
32716: PPUSH
32717: LD_INT 101
32719: PPUSH
32720: CALL 27518 0 2
// continue ;
32724: GO 32527
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
32726: LD_ADDR_EXP 86
32730: PUSH
32731: LD_EXP 86
32735: PPUSH
32736: LD_VAR 0 2
32740: PPUSH
32741: EMPTY
32742: PPUSH
32743: CALL_OW 1
32747: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32748: LD_VAR 0 2
32752: PPUSH
32753: LD_INT 103
32755: PPUSH
32756: CALL 27518 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
32760: LD_ADDR_VAR 0 5
32764: PUSH
32765: LD_EXP 80
32769: PUSH
32770: LD_VAR 0 2
32774: ARRAY
32775: PUSH
32776: LD_EXP 109
32780: PUSH
32781: LD_VAR 0 2
32785: ARRAY
32786: UNION
32787: PPUSH
32788: LD_INT 2
32790: PUSH
32791: LD_INT 25
32793: PUSH
32794: LD_INT 2
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 25
32803: PUSH
32804: LD_INT 16
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: LIST
32815: PUSH
32816: EMPTY
32817: LIST
32818: PPUSH
32819: CALL_OW 72
32823: ST_TO_ADDR
// if mc_need_heal [ i ] then
32824: LD_EXP 83
32828: PUSH
32829: LD_VAR 0 2
32833: ARRAY
32834: IFFALSE 32878
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
32836: LD_ADDR_VAR 0 5
32840: PUSH
32841: LD_VAR 0 5
32845: PUSH
32846: LD_EXP 83
32850: PUSH
32851: LD_VAR 0 2
32855: ARRAY
32856: PUSH
32857: LD_INT 1
32859: ARRAY
32860: PUSH
32861: LD_EXP 83
32865: PUSH
32866: LD_VAR 0 2
32870: ARRAY
32871: PUSH
32872: LD_INT 2
32874: ARRAY
32875: UNION
32876: DIFF
32877: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
32878: LD_ADDR_VAR 0 6
32882: PUSH
32883: LD_EXP 99
32887: PUSH
32888: LD_VAR 0 2
32892: ARRAY
32893: PPUSH
32894: LD_INT 2
32896: PUSH
32897: LD_INT 34
32899: PUSH
32900: LD_INT 13
32902: PUSH
32903: EMPTY
32904: LIST
32905: LIST
32906: PUSH
32907: LD_INT 34
32909: PUSH
32910: LD_INT 52
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: LD_INT 34
32919: PUSH
32920: LD_INT 88
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: PPUSH
32933: CALL_OW 72
32937: ST_TO_ADDR
// if cranes then
32938: LD_VAR 0 6
32942: IFFALSE 33114
// begin for j in cranes do
32944: LD_ADDR_VAR 0 3
32948: PUSH
32949: LD_VAR 0 6
32953: PUSH
32954: FOR_IN
32955: IFFALSE 33112
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
32957: LD_VAR 0 3
32961: PPUSH
32962: CALL_OW 256
32966: PUSH
32967: LD_INT 1000
32969: EQUAL
32970: IFFALSE 32984
32972: PUSH
32973: LD_VAR 0 3
32977: PPUSH
32978: CALL_OW 314
32982: NOT
32983: AND
32984: IFFALSE 33050
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
32986: LD_ADDR_VAR 0 8
32990: PUSH
32991: LD_EXP 81
32995: PUSH
32996: LD_VAR 0 2
33000: ARRAY
33001: PPUSH
33002: LD_VAR 0 3
33006: PPUSH
33007: CALL_OW 74
33011: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
33012: LD_VAR 0 8
33016: PPUSH
33017: LD_INT 16
33019: PPUSH
33020: CALL 62532 0 2
33024: PUSH
33025: LD_INT 4
33027: ARRAY
33028: PUSH
33029: LD_INT 10
33031: LESS
33032: IFFALSE 33048
// ComRepairBuilding ( j , to_repair ) ;
33034: LD_VAR 0 3
33038: PPUSH
33039: LD_VAR 0 8
33043: PPUSH
33044: CALL_OW 130
// end else
33048: GO 33110
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
33050: LD_VAR 0 3
33054: PPUSH
33055: CALL_OW 256
33059: PUSH
33060: LD_INT 500
33062: LESS
33063: IFFALSE 33088
33065: PUSH
33066: LD_VAR 0 3
33070: PPUSH
33071: LD_EXP 104
33075: PUSH
33076: LD_VAR 0 2
33080: ARRAY
33081: PPUSH
33082: CALL_OW 308
33086: NOT
33087: AND
33088: IFFALSE 33110
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33090: LD_VAR 0 3
33094: PPUSH
33095: LD_EXP 104
33099: PUSH
33100: LD_VAR 0 2
33104: ARRAY
33105: PPUSH
33106: CALL_OW 113
// end ;
33110: GO 32954
33112: POP
33113: POP
// end ; if tmp > 3 then
33114: LD_VAR 0 5
33118: PUSH
33119: LD_INT 3
33121: GREATER
33122: IFFALSE 33142
// tmp := ShrinkArray ( tmp , 4 ) ;
33124: LD_ADDR_VAR 0 5
33128: PUSH
33129: LD_VAR 0 5
33133: PPUSH
33134: LD_INT 4
33136: PPUSH
33137: CALL 92916 0 2
33141: ST_TO_ADDR
// if not tmp then
33142: LD_VAR 0 5
33146: NOT
33147: IFFALSE 33151
// continue ;
33149: GO 32527
// for j in tmp do
33151: LD_ADDR_VAR 0 3
33155: PUSH
33156: LD_VAR 0 5
33160: PUSH
33161: FOR_IN
33162: IFFALSE 33421
// begin if IsInUnit ( j ) then
33164: LD_VAR 0 3
33168: PPUSH
33169: CALL_OW 310
33173: IFFALSE 33184
// ComExitBuilding ( j ) ;
33175: LD_VAR 0 3
33179: PPUSH
33180: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
33184: LD_VAR 0 3
33188: PUSH
33189: LD_EXP 82
33193: PUSH
33194: LD_VAR 0 2
33198: ARRAY
33199: IN
33200: NOT
33201: IFFALSE 33259
// begin SetTag ( j , 101 ) ;
33203: LD_VAR 0 3
33207: PPUSH
33208: LD_INT 101
33210: PPUSH
33211: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
33215: LD_ADDR_EXP 82
33219: PUSH
33220: LD_EXP 82
33224: PPUSH
33225: LD_VAR 0 2
33229: PUSH
33230: LD_EXP 82
33234: PUSH
33235: LD_VAR 0 2
33239: ARRAY
33240: PUSH
33241: LD_INT 1
33243: PLUS
33244: PUSH
33245: EMPTY
33246: LIST
33247: LIST
33248: PPUSH
33249: LD_VAR 0 3
33253: PPUSH
33254: CALL 59553 0 3
33258: ST_TO_ADDR
// end ; wait ( 1 ) ;
33259: LD_INT 1
33261: PPUSH
33262: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
33266: LD_ADDR_VAR 0 7
33270: PUSH
33271: LD_EXP 81
33275: PUSH
33276: LD_VAR 0 2
33280: ARRAY
33281: ST_TO_ADDR
// if mc_scan [ i ] then
33282: LD_EXP 103
33286: PUSH
33287: LD_VAR 0 2
33291: ARRAY
33292: IFFALSE 33354
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
33294: LD_ADDR_VAR 0 7
33298: PUSH
33299: LD_EXP 81
33303: PUSH
33304: LD_VAR 0 2
33308: ARRAY
33309: PPUSH
33310: LD_INT 3
33312: PUSH
33313: LD_INT 30
33315: PUSH
33316: LD_INT 32
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: PUSH
33323: LD_INT 30
33325: PUSH
33326: LD_INT 33
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PUSH
33333: LD_INT 30
33335: PUSH
33336: LD_INT 31
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: PUSH
33343: EMPTY
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: PPUSH
33349: CALL_OW 72
33353: ST_TO_ADDR
// if not to_repair_tmp then
33354: LD_VAR 0 7
33358: NOT
33359: IFFALSE 33363
// continue ;
33361: GO 33161
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
33363: LD_ADDR_VAR 0 8
33367: PUSH
33368: LD_VAR 0 7
33372: PPUSH
33373: LD_VAR 0 3
33377: PPUSH
33378: CALL_OW 74
33382: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
33383: LD_VAR 0 8
33387: PPUSH
33388: LD_INT 16
33390: PPUSH
33391: CALL 62532 0 2
33395: PUSH
33396: LD_INT 4
33398: ARRAY
33399: PUSH
33400: LD_INT 14
33402: LESS
33403: IFFALSE 33419
// ComRepairBuilding ( j , to_repair ) ;
33405: LD_VAR 0 3
33409: PPUSH
33410: LD_VAR 0 8
33414: PPUSH
33415: CALL_OW 130
// end ;
33419: GO 33161
33421: POP
33422: POP
// end ;
33423: GO 32527
33425: POP
33426: POP
// end ;
33427: LD_VAR 0 1
33431: RET
// export function MC_Heal ; var i , j , tmp ; begin
33432: LD_INT 0
33434: PPUSH
33435: PPUSH
33436: PPUSH
33437: PPUSH
// if not mc_bases then
33438: LD_EXP 80
33442: NOT
33443: IFFALSE 33447
// exit ;
33445: GO 33853
// for i = 1 to mc_bases do
33447: LD_ADDR_VAR 0 2
33451: PUSH
33452: DOUBLE
33453: LD_INT 1
33455: DEC
33456: ST_TO_ADDR
33457: LD_EXP 80
33461: PUSH
33462: FOR_TO
33463: IFFALSE 33851
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
33465: LD_EXP 83
33469: PUSH
33470: LD_VAR 0 2
33474: ARRAY
33475: PUSH
33476: LD_INT 1
33478: ARRAY
33479: NOT
33480: IFFALSE 33499
33482: PUSH
33483: LD_EXP 83
33487: PUSH
33488: LD_VAR 0 2
33492: ARRAY
33493: PUSH
33494: LD_INT 2
33496: ARRAY
33497: NOT
33498: AND
33499: IFFALSE 33537
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
33501: LD_ADDR_EXP 84
33505: PUSH
33506: LD_EXP 84
33510: PPUSH
33511: LD_VAR 0 2
33515: PPUSH
33516: EMPTY
33517: PPUSH
33518: CALL_OW 1
33522: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
33523: LD_VAR 0 2
33527: PPUSH
33528: LD_INT 102
33530: PPUSH
33531: CALL 27518 0 2
// continue ;
33535: GO 33462
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
33537: LD_ADDR_VAR 0 4
33541: PUSH
33542: LD_EXP 80
33546: PUSH
33547: LD_VAR 0 2
33551: ARRAY
33552: PPUSH
33553: LD_INT 25
33555: PUSH
33556: LD_INT 4
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PPUSH
33563: CALL_OW 72
33567: ST_TO_ADDR
// if not tmp then
33568: LD_VAR 0 4
33572: NOT
33573: IFFALSE 33577
// continue ;
33575: GO 33462
// if mc_taming [ i ] then
33577: LD_EXP 111
33581: PUSH
33582: LD_VAR 0 2
33586: ARRAY
33587: IFFALSE 33611
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
33589: LD_ADDR_EXP 111
33593: PUSH
33594: LD_EXP 111
33598: PPUSH
33599: LD_VAR 0 2
33603: PPUSH
33604: EMPTY
33605: PPUSH
33606: CALL_OW 1
33610: ST_TO_ADDR
// for j in tmp do
33611: LD_ADDR_VAR 0 3
33615: PUSH
33616: LD_VAR 0 4
33620: PUSH
33621: FOR_IN
33622: IFFALSE 33847
// begin if IsInUnit ( j ) then
33624: LD_VAR 0 3
33628: PPUSH
33629: CALL_OW 310
33633: IFFALSE 33644
// ComExitBuilding ( j ) ;
33635: LD_VAR 0 3
33639: PPUSH
33640: CALL_OW 122
// if not j in mc_healers [ i ] then
33644: LD_VAR 0 3
33648: PUSH
33649: LD_EXP 84
33653: PUSH
33654: LD_VAR 0 2
33658: ARRAY
33659: IN
33660: NOT
33661: IFFALSE 33707
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
33663: LD_ADDR_EXP 84
33667: PUSH
33668: LD_EXP 84
33672: PPUSH
33673: LD_VAR 0 2
33677: PUSH
33678: LD_EXP 84
33682: PUSH
33683: LD_VAR 0 2
33687: ARRAY
33688: PUSH
33689: LD_INT 1
33691: PLUS
33692: PUSH
33693: EMPTY
33694: LIST
33695: LIST
33696: PPUSH
33697: LD_VAR 0 3
33701: PPUSH
33702: CALL 59553 0 3
33706: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
33707: LD_VAR 0 3
33711: PPUSH
33712: CALL_OW 110
33716: PUSH
33717: LD_INT 102
33719: NONEQUAL
33720: IFFALSE 33734
// SetTag ( j , 102 ) ;
33722: LD_VAR 0 3
33726: PPUSH
33727: LD_INT 102
33729: PPUSH
33730: CALL_OW 109
// Wait ( 3 ) ;
33734: LD_INT 3
33736: PPUSH
33737: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
33741: LD_EXP 83
33745: PUSH
33746: LD_VAR 0 2
33750: ARRAY
33751: PUSH
33752: LD_INT 1
33754: ARRAY
33755: IFFALSE 33787
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
33757: LD_VAR 0 3
33761: PPUSH
33762: LD_EXP 83
33766: PUSH
33767: LD_VAR 0 2
33771: ARRAY
33772: PUSH
33773: LD_INT 1
33775: ARRAY
33776: PUSH
33777: LD_INT 1
33779: ARRAY
33780: PPUSH
33781: CALL_OW 128
33785: GO 33845
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
33787: LD_VAR 0 3
33791: PPUSH
33792: CALL_OW 314
33796: NOT
33797: IFFALSE 33815
33799: PUSH
33800: LD_EXP 83
33804: PUSH
33805: LD_VAR 0 2
33809: ARRAY
33810: PUSH
33811: LD_INT 2
33813: ARRAY
33814: AND
33815: IFFALSE 33845
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
33817: LD_VAR 0 3
33821: PPUSH
33822: LD_EXP 83
33826: PUSH
33827: LD_VAR 0 2
33831: ARRAY
33832: PUSH
33833: LD_INT 2
33835: ARRAY
33836: PUSH
33837: LD_INT 1
33839: ARRAY
33840: PPUSH
33841: CALL_OW 128
// end ;
33845: GO 33621
33847: POP
33848: POP
// end ;
33849: GO 33462
33851: POP
33852: POP
// end ;
33853: LD_VAR 0 1
33857: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
33858: LD_INT 0
33860: PPUSH
33861: PPUSH
33862: PPUSH
33863: PPUSH
33864: PPUSH
33865: PPUSH
// if not mc_bases then
33866: LD_EXP 80
33870: NOT
33871: IFFALSE 33875
// exit ;
33873: GO 35046
// for i = 1 to mc_bases do
33875: LD_ADDR_VAR 0 2
33879: PUSH
33880: DOUBLE
33881: LD_INT 1
33883: DEC
33884: ST_TO_ADDR
33885: LD_EXP 80
33889: PUSH
33890: FOR_TO
33891: IFFALSE 35044
// begin if mc_scan [ i ] then
33893: LD_EXP 103
33897: PUSH
33898: LD_VAR 0 2
33902: ARRAY
33903: IFFALSE 33907
// continue ;
33905: GO 33890
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
33907: LD_EXP 85
33911: PUSH
33912: LD_VAR 0 2
33916: ARRAY
33917: NOT
33918: IFFALSE 33933
33920: PUSH
33921: LD_EXP 87
33925: PUSH
33926: LD_VAR 0 2
33930: ARRAY
33931: NOT
33932: AND
33933: IFFALSE 33947
33935: PUSH
33936: LD_EXP 86
33940: PUSH
33941: LD_VAR 0 2
33945: ARRAY
33946: AND
33947: IFFALSE 33985
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
33949: LD_ADDR_EXP 86
33953: PUSH
33954: LD_EXP 86
33958: PPUSH
33959: LD_VAR 0 2
33963: PPUSH
33964: EMPTY
33965: PPUSH
33966: CALL_OW 1
33970: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
33971: LD_VAR 0 2
33975: PPUSH
33976: LD_INT 103
33978: PPUSH
33979: CALL 27518 0 2
// continue ;
33983: GO 33890
// end ; if mc_construct_list [ i ] then
33985: LD_EXP 87
33989: PUSH
33990: LD_VAR 0 2
33994: ARRAY
33995: IFFALSE 34215
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33997: LD_ADDR_VAR 0 5
34001: PUSH
34002: LD_EXP 80
34006: PUSH
34007: LD_VAR 0 2
34011: ARRAY
34012: PPUSH
34013: LD_INT 25
34015: PUSH
34016: LD_INT 2
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PPUSH
34023: CALL_OW 72
34027: PUSH
34028: LD_EXP 82
34032: PUSH
34033: LD_VAR 0 2
34037: ARRAY
34038: DIFF
34039: ST_TO_ADDR
// if not tmp then
34040: LD_VAR 0 5
34044: NOT
34045: IFFALSE 34049
// continue ;
34047: GO 33890
// for j in tmp do
34049: LD_ADDR_VAR 0 3
34053: PUSH
34054: LD_VAR 0 5
34058: PUSH
34059: FOR_IN
34060: IFFALSE 34211
// begin if not mc_builders [ i ] then
34062: LD_EXP 86
34066: PUSH
34067: LD_VAR 0 2
34071: ARRAY
34072: NOT
34073: IFFALSE 34131
// begin SetTag ( j , 103 ) ;
34075: LD_VAR 0 3
34079: PPUSH
34080: LD_INT 103
34082: PPUSH
34083: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
34087: LD_ADDR_EXP 86
34091: PUSH
34092: LD_EXP 86
34096: PPUSH
34097: LD_VAR 0 2
34101: PUSH
34102: LD_EXP 86
34106: PUSH
34107: LD_VAR 0 2
34111: ARRAY
34112: PUSH
34113: LD_INT 1
34115: PLUS
34116: PUSH
34117: EMPTY
34118: LIST
34119: LIST
34120: PPUSH
34121: LD_VAR 0 3
34125: PPUSH
34126: CALL 59553 0 3
34130: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
34131: LD_VAR 0 3
34135: PPUSH
34136: CALL_OW 310
34140: IFFALSE 34151
// ComExitBuilding ( j ) ;
34142: LD_VAR 0 3
34146: PPUSH
34147: CALL_OW 122
// wait ( 3 ) ;
34151: LD_INT 3
34153: PPUSH
34154: CALL_OW 67
// if not mc_construct_list [ i ] then
34158: LD_EXP 87
34162: PUSH
34163: LD_VAR 0 2
34167: ARRAY
34168: NOT
34169: IFFALSE 34173
// break ;
34171: GO 34211
// if not HasTask ( j ) then
34173: LD_VAR 0 3
34177: PPUSH
34178: CALL_OW 314
34182: NOT
34183: IFFALSE 34209
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
34185: LD_VAR 0 3
34189: PPUSH
34190: LD_EXP 87
34194: PUSH
34195: LD_VAR 0 2
34199: ARRAY
34200: PUSH
34201: LD_INT 1
34203: ARRAY
34204: PPUSH
34205: CALL 62805 0 2
// end ;
34209: GO 34059
34211: POP
34212: POP
// end else
34213: GO 35042
// if mc_build_list [ i ] then
34215: LD_EXP 85
34219: PUSH
34220: LD_VAR 0 2
34224: ARRAY
34225: IFFALSE 35042
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
34227: LD_EXP 85
34231: PUSH
34232: LD_VAR 0 2
34236: ARRAY
34237: PUSH
34238: LD_INT 1
34240: ARRAY
34241: PUSH
34242: LD_INT 1
34244: ARRAY
34245: PPUSH
34246: CALL 62629 0 1
34250: IFFALSE 34298
34252: PUSH
34253: LD_EXP 80
34257: PUSH
34258: LD_VAR 0 2
34262: ARRAY
34263: PPUSH
34264: LD_INT 2
34266: PUSH
34267: LD_INT 30
34269: PUSH
34270: LD_INT 2
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PUSH
34277: LD_INT 30
34279: PUSH
34280: LD_INT 3
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: LIST
34291: PPUSH
34292: CALL_OW 72
34296: NOT
34297: AND
34298: IFFALSE 34403
// begin for j = 1 to mc_build_list [ i ] do
34300: LD_ADDR_VAR 0 3
34304: PUSH
34305: DOUBLE
34306: LD_INT 1
34308: DEC
34309: ST_TO_ADDR
34310: LD_EXP 85
34314: PUSH
34315: LD_VAR 0 2
34319: ARRAY
34320: PUSH
34321: FOR_TO
34322: IFFALSE 34401
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
34324: LD_EXP 85
34328: PUSH
34329: LD_VAR 0 2
34333: ARRAY
34334: PUSH
34335: LD_VAR 0 3
34339: ARRAY
34340: PUSH
34341: LD_INT 1
34343: ARRAY
34344: PUSH
34345: LD_INT 2
34347: EQUAL
34348: IFFALSE 34399
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
34350: LD_ADDR_EXP 85
34354: PUSH
34355: LD_EXP 85
34359: PPUSH
34360: LD_VAR 0 2
34364: PPUSH
34365: LD_EXP 85
34369: PUSH
34370: LD_VAR 0 2
34374: ARRAY
34375: PPUSH
34376: LD_VAR 0 3
34380: PPUSH
34381: LD_INT 1
34383: PPUSH
34384: LD_INT 0
34386: PPUSH
34387: CALL 58961 0 4
34391: PPUSH
34392: CALL_OW 1
34396: ST_TO_ADDR
// break ;
34397: GO 34401
// end ;
34399: GO 34321
34401: POP
34402: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34403: LD_ADDR_VAR 0 6
34407: PUSH
34408: LD_EXP 80
34412: PUSH
34413: LD_VAR 0 2
34417: ARRAY
34418: PPUSH
34419: LD_INT 2
34421: PUSH
34422: LD_INT 30
34424: PUSH
34425: LD_INT 0
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: LD_INT 30
34434: PUSH
34435: LD_INT 1
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: EMPTY
34443: LIST
34444: LIST
34445: LIST
34446: PPUSH
34447: CALL_OW 72
34451: ST_TO_ADDR
// for k := 1 to depot do
34452: LD_ADDR_VAR 0 4
34456: PUSH
34457: DOUBLE
34458: LD_INT 1
34460: DEC
34461: ST_TO_ADDR
34462: LD_VAR 0 6
34466: PUSH
34467: FOR_TO
34468: IFFALSE 35040
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
34470: LD_EXP 85
34474: PUSH
34475: LD_VAR 0 2
34479: ARRAY
34480: PUSH
34481: LD_INT 1
34483: ARRAY
34484: PUSH
34485: LD_INT 1
34487: ARRAY
34488: PUSH
34489: LD_INT 0
34491: EQUAL
34492: IFTRUE 34587
34494: PUSH
34495: LD_VAR 0 6
34499: PUSH
34500: LD_VAR 0 4
34504: ARRAY
34505: PPUSH
34506: LD_EXP 85
34510: PUSH
34511: LD_VAR 0 2
34515: ARRAY
34516: PUSH
34517: LD_INT 1
34519: ARRAY
34520: PUSH
34521: LD_INT 1
34523: ARRAY
34524: PPUSH
34525: LD_EXP 85
34529: PUSH
34530: LD_VAR 0 2
34534: ARRAY
34535: PUSH
34536: LD_INT 1
34538: ARRAY
34539: PUSH
34540: LD_INT 2
34542: ARRAY
34543: PPUSH
34544: LD_EXP 85
34548: PUSH
34549: LD_VAR 0 2
34553: ARRAY
34554: PUSH
34555: LD_INT 1
34557: ARRAY
34558: PUSH
34559: LD_INT 3
34561: ARRAY
34562: PPUSH
34563: LD_EXP 85
34567: PUSH
34568: LD_VAR 0 2
34572: ARRAY
34573: PUSH
34574: LD_INT 1
34576: ARRAY
34577: PUSH
34578: LD_INT 4
34580: ARRAY
34581: PPUSH
34582: CALL 68109 0 5
34586: OR
34587: IFFALSE 34868
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
34589: LD_ADDR_VAR 0 5
34593: PUSH
34594: LD_EXP 80
34598: PUSH
34599: LD_VAR 0 2
34603: ARRAY
34604: PPUSH
34605: LD_INT 25
34607: PUSH
34608: LD_INT 2
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PPUSH
34615: CALL_OW 72
34619: PUSH
34620: LD_EXP 82
34624: PUSH
34625: LD_VAR 0 2
34629: ARRAY
34630: DIFF
34631: ST_TO_ADDR
// if not tmp then
34632: LD_VAR 0 5
34636: NOT
34637: IFFALSE 34641
// continue ;
34639: GO 34467
// for j in tmp do
34641: LD_ADDR_VAR 0 3
34645: PUSH
34646: LD_VAR 0 5
34650: PUSH
34651: FOR_IN
34652: IFFALSE 34864
// begin if not mc_builders [ i ] then
34654: LD_EXP 86
34658: PUSH
34659: LD_VAR 0 2
34663: ARRAY
34664: NOT
34665: IFFALSE 34723
// begin SetTag ( j , 103 ) ;
34667: LD_VAR 0 3
34671: PPUSH
34672: LD_INT 103
34674: PPUSH
34675: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
34679: LD_ADDR_EXP 86
34683: PUSH
34684: LD_EXP 86
34688: PPUSH
34689: LD_VAR 0 2
34693: PUSH
34694: LD_EXP 86
34698: PUSH
34699: LD_VAR 0 2
34703: ARRAY
34704: PUSH
34705: LD_INT 1
34707: PLUS
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PPUSH
34713: LD_VAR 0 3
34717: PPUSH
34718: CALL 59553 0 3
34722: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
34723: LD_VAR 0 3
34727: PPUSH
34728: CALL_OW 310
34732: IFFALSE 34743
// ComExitBuilding ( j ) ;
34734: LD_VAR 0 3
34738: PPUSH
34739: CALL_OW 122
// wait ( 3 ) ;
34743: LD_INT 3
34745: PPUSH
34746: CALL_OW 67
// if not mc_build_list [ i ] then
34750: LD_EXP 85
34754: PUSH
34755: LD_VAR 0 2
34759: ARRAY
34760: NOT
34761: IFFALSE 34765
// break ;
34763: GO 34864
// if not HasTask ( j ) then
34765: LD_VAR 0 3
34769: PPUSH
34770: CALL_OW 314
34774: NOT
34775: IFFALSE 34862
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
34777: LD_VAR 0 3
34781: PPUSH
34782: LD_EXP 85
34786: PUSH
34787: LD_VAR 0 2
34791: ARRAY
34792: PUSH
34793: LD_INT 1
34795: ARRAY
34796: PUSH
34797: LD_INT 1
34799: ARRAY
34800: PPUSH
34801: LD_EXP 85
34805: PUSH
34806: LD_VAR 0 2
34810: ARRAY
34811: PUSH
34812: LD_INT 1
34814: ARRAY
34815: PUSH
34816: LD_INT 2
34818: ARRAY
34819: PPUSH
34820: LD_EXP 85
34824: PUSH
34825: LD_VAR 0 2
34829: ARRAY
34830: PUSH
34831: LD_INT 1
34833: ARRAY
34834: PUSH
34835: LD_INT 3
34837: ARRAY
34838: PPUSH
34839: LD_EXP 85
34843: PUSH
34844: LD_VAR 0 2
34848: ARRAY
34849: PUSH
34850: LD_INT 1
34852: ARRAY
34853: PUSH
34854: LD_INT 4
34856: ARRAY
34857: PPUSH
34858: CALL_OW 145
// end ;
34862: GO 34651
34864: POP
34865: POP
// end else
34866: GO 35038
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
34868: LD_EXP 80
34872: PUSH
34873: LD_VAR 0 2
34877: ARRAY
34878: PPUSH
34879: LD_EXP 85
34883: PUSH
34884: LD_VAR 0 2
34888: ARRAY
34889: PUSH
34890: LD_INT 1
34892: ARRAY
34893: PUSH
34894: LD_INT 1
34896: ARRAY
34897: PPUSH
34898: LD_EXP 85
34902: PUSH
34903: LD_VAR 0 2
34907: ARRAY
34908: PUSH
34909: LD_INT 1
34911: ARRAY
34912: PUSH
34913: LD_INT 2
34915: ARRAY
34916: PPUSH
34917: LD_EXP 85
34921: PUSH
34922: LD_VAR 0 2
34926: ARRAY
34927: PUSH
34928: LD_INT 1
34930: ARRAY
34931: PUSH
34932: LD_INT 3
34934: ARRAY
34935: PPUSH
34936: LD_EXP 85
34940: PUSH
34941: LD_VAR 0 2
34945: ARRAY
34946: PUSH
34947: LD_INT 1
34949: ARRAY
34950: PUSH
34951: LD_INT 4
34953: ARRAY
34954: PPUSH
34955: LD_EXP 80
34959: PUSH
34960: LD_VAR 0 2
34964: ARRAY
34965: PPUSH
34966: LD_INT 21
34968: PUSH
34969: LD_INT 3
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PPUSH
34976: CALL_OW 72
34980: PPUSH
34981: EMPTY
34982: PPUSH
34983: CALL 66845 0 7
34987: NOT
34988: IFFALSE 35038
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
34990: LD_ADDR_EXP 85
34994: PUSH
34995: LD_EXP 85
34999: PPUSH
35000: LD_VAR 0 2
35004: PPUSH
35005: LD_EXP 85
35009: PUSH
35010: LD_VAR 0 2
35014: ARRAY
35015: PPUSH
35016: LD_INT 1
35018: PPUSH
35019: LD_INT 1
35021: NEG
35022: PPUSH
35023: LD_INT 0
35025: PPUSH
35026: CALL 58961 0 4
35030: PPUSH
35031: CALL_OW 1
35035: ST_TO_ADDR
// continue ;
35036: GO 34467
// end ; end ;
35038: GO 34467
35040: POP
35041: POP
// end ; end ;
35042: GO 33890
35044: POP
35045: POP
// end ;
35046: LD_VAR 0 1
35050: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
35051: LD_INT 0
35053: PPUSH
35054: PPUSH
35055: PPUSH
35056: PPUSH
35057: PPUSH
35058: PPUSH
// if not mc_bases then
35059: LD_EXP 80
35063: NOT
35064: IFFALSE 35068
// exit ;
35066: GO 35501
// for i = 1 to mc_bases do
35068: LD_ADDR_VAR 0 2
35072: PUSH
35073: DOUBLE
35074: LD_INT 1
35076: DEC
35077: ST_TO_ADDR
35078: LD_EXP 80
35082: PUSH
35083: FOR_TO
35084: IFFALSE 35499
// begin tmp := mc_build_upgrade [ i ] ;
35086: LD_ADDR_VAR 0 4
35090: PUSH
35091: LD_EXP 112
35095: PUSH
35096: LD_VAR 0 2
35100: ARRAY
35101: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
35102: LD_ADDR_VAR 0 6
35106: PUSH
35107: LD_EXP 113
35111: PUSH
35112: LD_VAR 0 2
35116: ARRAY
35117: PPUSH
35118: LD_INT 2
35120: PUSH
35121: LD_INT 30
35123: PUSH
35124: LD_INT 6
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 30
35133: PUSH
35134: LD_INT 7
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: EMPTY
35142: LIST
35143: LIST
35144: LIST
35145: PPUSH
35146: CALL_OW 72
35150: ST_TO_ADDR
// if not tmp and not lab then
35151: LD_VAR 0 4
35155: NOT
35156: IFFALSE 35165
35158: PUSH
35159: LD_VAR 0 6
35163: NOT
35164: AND
35165: IFFALSE 35169
// continue ;
35167: GO 35083
// if tmp then
35169: LD_VAR 0 4
35173: IFFALSE 35293
// for j in tmp do
35175: LD_ADDR_VAR 0 3
35179: PUSH
35180: LD_VAR 0 4
35184: PUSH
35185: FOR_IN
35186: IFFALSE 35291
// begin if UpgradeCost ( j ) then
35188: LD_VAR 0 3
35192: PPUSH
35193: CALL 66497 0 1
35197: IFFALSE 35289
// begin ComUpgrade ( j ) ;
35199: LD_VAR 0 3
35203: PPUSH
35204: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
35208: LD_ADDR_EXP 112
35212: PUSH
35213: LD_EXP 112
35217: PPUSH
35218: LD_VAR 0 2
35222: PPUSH
35223: LD_EXP 112
35227: PUSH
35228: LD_VAR 0 2
35232: ARRAY
35233: PUSH
35234: LD_VAR 0 3
35238: DIFF
35239: PPUSH
35240: CALL_OW 1
35244: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
35245: LD_ADDR_EXP 87
35249: PUSH
35250: LD_EXP 87
35254: PPUSH
35255: LD_VAR 0 2
35259: PUSH
35260: LD_EXP 87
35264: PUSH
35265: LD_VAR 0 2
35269: ARRAY
35270: PUSH
35271: LD_INT 1
35273: PLUS
35274: PUSH
35275: EMPTY
35276: LIST
35277: LIST
35278: PPUSH
35279: LD_VAR 0 3
35283: PPUSH
35284: CALL 59553 0 3
35288: ST_TO_ADDR
// end ; end ;
35289: GO 35185
35291: POP
35292: POP
// if not lab or not mc_lab_upgrade [ i ] then
35293: LD_VAR 0 6
35297: NOT
35298: IFTRUE 35313
35300: PUSH
35301: LD_EXP 114
35305: PUSH
35306: LD_VAR 0 2
35310: ARRAY
35311: NOT
35312: OR
35313: IFFALSE 35317
// continue ;
35315: GO 35083
// for j in lab do
35317: LD_ADDR_VAR 0 3
35321: PUSH
35322: LD_VAR 0 6
35326: PUSH
35327: FOR_IN
35328: IFFALSE 35495
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
35330: LD_VAR 0 3
35334: PPUSH
35335: CALL_OW 266
35339: PUSH
35340: LD_INT 6
35342: PUSH
35343: LD_INT 7
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: IN
35350: IFFALSE 35367
35352: PUSH
35353: LD_VAR 0 3
35357: PPUSH
35358: CALL_OW 461
35362: PUSH
35363: LD_INT 1
35365: NONEQUAL
35366: AND
35367: IFFALSE 35493
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
35369: LD_VAR 0 3
35373: PPUSH
35374: LD_EXP 114
35378: PUSH
35379: LD_VAR 0 2
35383: ARRAY
35384: PUSH
35385: LD_INT 1
35387: ARRAY
35388: PPUSH
35389: CALL 66706 0 2
35393: IFFALSE 35493
// begin ComCancel ( j ) ;
35395: LD_VAR 0 3
35399: PPUSH
35400: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
35404: LD_VAR 0 3
35408: PPUSH
35409: LD_EXP 114
35413: PUSH
35414: LD_VAR 0 2
35418: ARRAY
35419: PUSH
35420: LD_INT 1
35422: ARRAY
35423: PPUSH
35424: CALL_OW 207
// if not j in mc_construct_list [ i ] then
35428: LD_VAR 0 3
35432: PUSH
35433: LD_EXP 87
35437: PUSH
35438: LD_VAR 0 2
35442: ARRAY
35443: IN
35444: NOT
35445: IFFALSE 35491
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
35447: LD_ADDR_EXP 87
35451: PUSH
35452: LD_EXP 87
35456: PPUSH
35457: LD_VAR 0 2
35461: PUSH
35462: LD_EXP 87
35466: PUSH
35467: LD_VAR 0 2
35471: ARRAY
35472: PUSH
35473: LD_INT 1
35475: PLUS
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PPUSH
35481: LD_VAR 0 3
35485: PPUSH
35486: CALL 59553 0 3
35490: ST_TO_ADDR
// break ;
35491: GO 35495
// end ; end ; end ;
35493: GO 35327
35495: POP
35496: POP
// end ;
35497: GO 35083
35499: POP
35500: POP
// end ;
35501: LD_VAR 0 1
35505: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
35506: LD_INT 0
35508: PPUSH
35509: PPUSH
35510: PPUSH
35511: PPUSH
35512: PPUSH
35513: PPUSH
35514: PPUSH
35515: PPUSH
35516: PPUSH
// if not mc_bases then
35517: LD_EXP 80
35521: NOT
35522: IFFALSE 35526
// exit ;
35524: GO 35933
// for i = 1 to mc_bases do
35526: LD_ADDR_VAR 0 2
35530: PUSH
35531: DOUBLE
35532: LD_INT 1
35534: DEC
35535: ST_TO_ADDR
35536: LD_EXP 80
35540: PUSH
35541: FOR_TO
35542: IFFALSE 35931
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
35544: LD_EXP 88
35548: PUSH
35549: LD_VAR 0 2
35553: ARRAY
35554: NOT
35555: IFTRUE 35585
35557: PUSH
35558: LD_EXP 80
35562: PUSH
35563: LD_VAR 0 2
35567: ARRAY
35568: PPUSH
35569: LD_INT 30
35571: PUSH
35572: LD_INT 3
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PPUSH
35579: CALL_OW 72
35583: NOT
35584: OR
35585: IFFALSE 35589
// continue ;
35587: GO 35541
// busy := false ;
35589: LD_ADDR_VAR 0 8
35593: PUSH
35594: LD_INT 0
35596: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35597: LD_ADDR_VAR 0 4
35601: PUSH
35602: LD_EXP 80
35606: PUSH
35607: LD_VAR 0 2
35611: ARRAY
35612: PPUSH
35613: LD_INT 30
35615: PUSH
35616: LD_INT 3
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PPUSH
35623: CALL_OW 72
35627: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
35628: LD_ADDR_VAR 0 6
35632: PUSH
35633: LD_EXP 88
35637: PUSH
35638: LD_VAR 0 2
35642: ARRAY
35643: PPUSH
35644: LD_INT 2
35646: PUSH
35647: LD_INT 30
35649: PUSH
35650: LD_INT 32
35652: PUSH
35653: EMPTY
35654: LIST
35655: LIST
35656: PUSH
35657: LD_INT 30
35659: PUSH
35660: LD_INT 33
35662: PUSH
35663: EMPTY
35664: LIST
35665: LIST
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: LIST
35671: PPUSH
35672: CALL_OW 72
35676: ST_TO_ADDR
// if not t then
35677: LD_VAR 0 6
35681: NOT
35682: IFFALSE 35686
// continue ;
35684: GO 35541
// for j in tmp do
35686: LD_ADDR_VAR 0 3
35690: PUSH
35691: LD_VAR 0 4
35695: PUSH
35696: FOR_IN
35697: IFFALSE 35727
// if not BuildingStatus ( j ) = bs_idle then
35699: LD_VAR 0 3
35703: PPUSH
35704: CALL_OW 461
35708: PUSH
35709: LD_INT 2
35711: EQUAL
35712: NOT
35713: IFFALSE 35725
// begin busy := true ;
35715: LD_ADDR_VAR 0 8
35719: PUSH
35720: LD_INT 1
35722: ST_TO_ADDR
// break ;
35723: GO 35727
// end ;
35725: GO 35696
35727: POP
35728: POP
// if busy then
35729: LD_VAR 0 8
35733: IFFALSE 35737
// continue ;
35735: GO 35541
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
35737: LD_ADDR_VAR 0 7
35741: PUSH
35742: LD_VAR 0 6
35746: PPUSH
35747: LD_INT 35
35749: PUSH
35750: LD_INT 0
35752: PUSH
35753: EMPTY
35754: LIST
35755: LIST
35756: PPUSH
35757: CALL_OW 72
35761: ST_TO_ADDR
// if tw then
35762: LD_VAR 0 7
35766: IFFALSE 35843
// begin tw := tw [ 1 ] ;
35768: LD_ADDR_VAR 0 7
35772: PUSH
35773: LD_VAR 0 7
35777: PUSH
35778: LD_INT 1
35780: ARRAY
35781: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
35782: LD_ADDR_VAR 0 9
35786: PUSH
35787: LD_VAR 0 7
35791: PPUSH
35792: LD_EXP 105
35796: PUSH
35797: LD_VAR 0 2
35801: ARRAY
35802: PPUSH
35803: CALL 64960 0 2
35807: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
35808: LD_EXP 119
35812: PUSH
35813: LD_VAR 0 2
35817: ARRAY
35818: IFFALSE 35841
// if not weapon in mc_allowed_tower_weapons [ i ] then
35820: LD_VAR 0 9
35824: PUSH
35825: LD_EXP 119
35829: PUSH
35830: LD_VAR 0 2
35834: ARRAY
35835: IN
35836: NOT
35837: IFFALSE 35841
// continue ;
35839: GO 35541
// end else
35841: GO 35906
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
35843: LD_ADDR_VAR 0 5
35847: PUSH
35848: LD_EXP 88
35852: PUSH
35853: LD_VAR 0 2
35857: ARRAY
35858: PPUSH
35859: LD_VAR 0 4
35863: PPUSH
35864: CALL 92145 0 2
35868: ST_TO_ADDR
// if not tmp2 then
35869: LD_VAR 0 5
35873: NOT
35874: IFFALSE 35878
// continue ;
35876: GO 35541
// tw := tmp2 [ 1 ] ;
35878: LD_ADDR_VAR 0 7
35882: PUSH
35883: LD_VAR 0 5
35887: PUSH
35888: LD_INT 1
35890: ARRAY
35891: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
35892: LD_ADDR_VAR 0 9
35896: PUSH
35897: LD_VAR 0 5
35901: PUSH
35902: LD_INT 2
35904: ARRAY
35905: ST_TO_ADDR
// end ; if not weapon then
35906: LD_VAR 0 9
35910: NOT
35911: IFFALSE 35915
// continue ;
35913: GO 35541
// ComPlaceWeapon ( tw , weapon ) ;
35915: LD_VAR 0 7
35919: PPUSH
35920: LD_VAR 0 9
35924: PPUSH
35925: CALL_OW 148
// end ;
35929: GO 35541
35931: POP
35932: POP
// end ;
35933: LD_VAR 0 1
35937: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
35938: LD_INT 0
35940: PPUSH
35941: PPUSH
35942: PPUSH
35943: PPUSH
35944: PPUSH
35945: PPUSH
35946: PPUSH
// if not mc_bases then
35947: LD_EXP 80
35951: NOT
35952: IFFALSE 35956
// exit ;
35954: GO 36743
// for i = 1 to mc_bases do
35956: LD_ADDR_VAR 0 2
35960: PUSH
35961: DOUBLE
35962: LD_INT 1
35964: DEC
35965: ST_TO_ADDR
35966: LD_EXP 80
35970: PUSH
35971: FOR_TO
35972: IFFALSE 36741
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
35974: LD_EXP 93
35978: PUSH
35979: LD_VAR 0 2
35983: ARRAY
35984: NOT
35985: IFTRUE 36011
35987: PUSH
35988: LD_EXP 93
35992: PUSH
35993: LD_VAR 0 2
35997: ARRAY
35998: PUSH
35999: LD_EXP 94
36003: PUSH
36004: LD_VAR 0 2
36008: ARRAY
36009: EQUAL
36010: OR
36011: IFTRUE 36025
36013: PUSH
36014: LD_EXP 103
36018: PUSH
36019: LD_VAR 0 2
36023: ARRAY
36024: OR
36025: IFFALSE 36029
// continue ;
36027: GO 35971
// if mc_miners [ i ] then
36029: LD_EXP 94
36033: PUSH
36034: LD_VAR 0 2
36038: ARRAY
36039: IFFALSE 36426
// begin for j = mc_miners [ i ] downto 1 do
36041: LD_ADDR_VAR 0 3
36045: PUSH
36046: DOUBLE
36047: LD_EXP 94
36051: PUSH
36052: LD_VAR 0 2
36056: ARRAY
36057: INC
36058: ST_TO_ADDR
36059: LD_INT 1
36061: PUSH
36062: FOR_DOWNTO
36063: IFFALSE 36424
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
36065: LD_EXP 94
36069: PUSH
36070: LD_VAR 0 2
36074: ARRAY
36075: PUSH
36076: LD_VAR 0 3
36080: ARRAY
36081: PPUSH
36082: CALL_OW 301
36086: IFTRUE 36115
36088: PUSH
36089: LD_EXP 94
36093: PUSH
36094: LD_VAR 0 2
36098: ARRAY
36099: PUSH
36100: LD_VAR 0 3
36104: ARRAY
36105: PPUSH
36106: CALL_OW 257
36110: PUSH
36111: LD_INT 1
36113: NONEQUAL
36114: OR
36115: IFFALSE 36178
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
36117: LD_ADDR_VAR 0 5
36121: PUSH
36122: LD_EXP 94
36126: PUSH
36127: LD_VAR 0 2
36131: ARRAY
36132: PUSH
36133: LD_EXP 94
36137: PUSH
36138: LD_VAR 0 2
36142: ARRAY
36143: PUSH
36144: LD_VAR 0 3
36148: ARRAY
36149: DIFF
36150: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
36151: LD_ADDR_EXP 94
36155: PUSH
36156: LD_EXP 94
36160: PPUSH
36161: LD_VAR 0 2
36165: PPUSH
36166: LD_VAR 0 5
36170: PPUSH
36171: CALL_OW 1
36175: ST_TO_ADDR
// continue ;
36176: GO 36062
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
36178: LD_EXP 94
36182: PUSH
36183: LD_VAR 0 2
36187: ARRAY
36188: PUSH
36189: LD_VAR 0 3
36193: ARRAY
36194: PPUSH
36195: CALL_OW 257
36199: PUSH
36200: LD_INT 1
36202: EQUAL
36203: IFFALSE 36229
36205: PUSH
36206: LD_EXP 94
36210: PUSH
36211: LD_VAR 0 2
36215: ARRAY
36216: PUSH
36217: LD_VAR 0 3
36221: ARRAY
36222: PPUSH
36223: CALL_OW 459
36227: NOT
36228: AND
36229: IFFALSE 36255
36231: PUSH
36232: LD_EXP 94
36236: PUSH
36237: LD_VAR 0 2
36241: ARRAY
36242: PUSH
36243: LD_VAR 0 3
36247: ARRAY
36248: PPUSH
36249: CALL_OW 314
36253: NOT
36254: AND
36255: IFFALSE 36422
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
36257: LD_EXP 94
36261: PUSH
36262: LD_VAR 0 2
36266: ARRAY
36267: PUSH
36268: LD_VAR 0 3
36272: ARRAY
36273: PPUSH
36274: CALL_OW 310
36278: IFFALSE 36301
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
36280: LD_EXP 94
36284: PUSH
36285: LD_VAR 0 2
36289: ARRAY
36290: PUSH
36291: LD_VAR 0 3
36295: ARRAY
36296: PPUSH
36297: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
36301: LD_EXP 94
36305: PUSH
36306: LD_VAR 0 2
36310: ARRAY
36311: PUSH
36312: LD_VAR 0 3
36316: ARRAY
36317: PPUSH
36318: CALL_OW 314
36322: NOT
36323: IFFALSE 36422
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
36325: LD_ADDR_VAR 0 7
36329: PUSH
36330: LD_VAR 0 3
36334: PUSH
36335: LD_EXP 93
36339: PUSH
36340: LD_VAR 0 2
36344: ARRAY
36345: PPUSH
36346: CALL 56635 0 1
36350: MOD
36351: PUSH
36352: LD_INT 1
36354: PLUS
36355: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
36356: LD_EXP 94
36360: PUSH
36361: LD_VAR 0 2
36365: ARRAY
36366: PUSH
36367: LD_VAR 0 3
36371: ARRAY
36372: PPUSH
36373: LD_EXP 93
36377: PUSH
36378: LD_VAR 0 2
36382: ARRAY
36383: PUSH
36384: LD_VAR 0 7
36388: ARRAY
36389: PUSH
36390: LD_INT 1
36392: ARRAY
36393: PPUSH
36394: LD_EXP 93
36398: PUSH
36399: LD_VAR 0 2
36403: ARRAY
36404: PUSH
36405: LD_VAR 0 7
36409: ARRAY
36410: PUSH
36411: LD_INT 2
36413: ARRAY
36414: PPUSH
36415: LD_INT 0
36417: PPUSH
36418: CALL_OW 193
// end ; end ; end ;
36422: GO 36062
36424: POP
36425: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
36426: LD_ADDR_VAR 0 5
36430: PUSH
36431: LD_EXP 80
36435: PUSH
36436: LD_VAR 0 2
36440: ARRAY
36441: PPUSH
36442: LD_INT 2
36444: PUSH
36445: LD_INT 30
36447: PUSH
36448: LD_INT 4
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 30
36457: PUSH
36458: LD_INT 5
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: PUSH
36465: LD_INT 30
36467: PUSH
36468: LD_INT 32
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: PPUSH
36481: CALL_OW 72
36485: ST_TO_ADDR
// if not tmp then
36486: LD_VAR 0 5
36490: NOT
36491: IFFALSE 36495
// continue ;
36493: GO 35971
// list := [ ] ;
36495: LD_ADDR_VAR 0 6
36499: PUSH
36500: EMPTY
36501: ST_TO_ADDR
// for j in tmp do
36502: LD_ADDR_VAR 0 3
36506: PUSH
36507: LD_VAR 0 5
36511: PUSH
36512: FOR_IN
36513: IFFALSE 36584
// begin for k in UnitsInside ( j ) do
36515: LD_ADDR_VAR 0 4
36519: PUSH
36520: LD_VAR 0 3
36524: PPUSH
36525: CALL_OW 313
36529: PUSH
36530: FOR_IN
36531: IFFALSE 36580
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
36533: LD_VAR 0 4
36537: PPUSH
36538: CALL_OW 257
36542: PUSH
36543: LD_INT 1
36545: EQUAL
36546: IFFALSE 36560
36548: PUSH
36549: LD_VAR 0 4
36553: PPUSH
36554: CALL_OW 459
36558: NOT
36559: AND
36560: IFFALSE 36578
// list := list ^ k ;
36562: LD_ADDR_VAR 0 6
36566: PUSH
36567: LD_VAR 0 6
36571: PUSH
36572: LD_VAR 0 4
36576: ADD
36577: ST_TO_ADDR
36578: GO 36530
36580: POP
36581: POP
// end ;
36582: GO 36512
36584: POP
36585: POP
// list := list diff mc_miners [ i ] ;
36586: LD_ADDR_VAR 0 6
36590: PUSH
36591: LD_VAR 0 6
36595: PUSH
36596: LD_EXP 94
36600: PUSH
36601: LD_VAR 0 2
36605: ARRAY
36606: DIFF
36607: ST_TO_ADDR
// if not list then
36608: LD_VAR 0 6
36612: NOT
36613: IFFALSE 36617
// continue ;
36615: GO 35971
// k := mc_mines [ i ] - mc_miners [ i ] ;
36617: LD_ADDR_VAR 0 4
36621: PUSH
36622: LD_EXP 93
36626: PUSH
36627: LD_VAR 0 2
36631: ARRAY
36632: PUSH
36633: LD_EXP 94
36637: PUSH
36638: LD_VAR 0 2
36642: ARRAY
36643: MINUS
36644: ST_TO_ADDR
// if k > list then
36645: LD_VAR 0 4
36649: PUSH
36650: LD_VAR 0 6
36654: GREATER
36655: IFFALSE 36667
// k := list ;
36657: LD_ADDR_VAR 0 4
36661: PUSH
36662: LD_VAR 0 6
36666: ST_TO_ADDR
// for j = 1 to k do
36667: LD_ADDR_VAR 0 3
36671: PUSH
36672: DOUBLE
36673: LD_INT 1
36675: DEC
36676: ST_TO_ADDR
36677: LD_VAR 0 4
36681: PUSH
36682: FOR_TO
36683: IFFALSE 36737
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
36685: LD_ADDR_EXP 94
36689: PUSH
36690: LD_EXP 94
36694: PPUSH
36695: LD_VAR 0 2
36699: PUSH
36700: LD_EXP 94
36704: PUSH
36705: LD_VAR 0 2
36709: ARRAY
36710: PUSH
36711: LD_INT 1
36713: PLUS
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PPUSH
36719: LD_VAR 0 6
36723: PUSH
36724: LD_VAR 0 3
36728: ARRAY
36729: PPUSH
36730: CALL 59553 0 3
36734: ST_TO_ADDR
36735: GO 36682
36737: POP
36738: POP
// end ;
36739: GO 35971
36741: POP
36742: POP
// end ;
36743: LD_VAR 0 1
36747: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
36748: LD_INT 0
36750: PPUSH
36751: PPUSH
36752: PPUSH
36753: PPUSH
36754: PPUSH
36755: PPUSH
36756: PPUSH
36757: PPUSH
36758: PPUSH
36759: PPUSH
36760: PPUSH
// if not mc_bases then
36761: LD_EXP 80
36765: NOT
36766: IFFALSE 36770
// exit ;
36768: GO 38617
// for i = 1 to mc_bases do
36770: LD_ADDR_VAR 0 2
36774: PUSH
36775: DOUBLE
36776: LD_INT 1
36778: DEC
36779: ST_TO_ADDR
36780: LD_EXP 80
36784: PUSH
36785: FOR_TO
36786: IFFALSE 38615
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
36788: LD_EXP 80
36792: PUSH
36793: LD_VAR 0 2
36797: ARRAY
36798: NOT
36799: IFTRUE 36813
36801: PUSH
36802: LD_EXP 87
36806: PUSH
36807: LD_VAR 0 2
36811: ARRAY
36812: OR
36813: IFFALSE 36817
// continue ;
36815: GO 36785
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
36817: LD_EXP 96
36821: PUSH
36822: LD_VAR 0 2
36826: ARRAY
36827: NOT
36828: IFFALSE 36842
36830: PUSH
36831: LD_EXP 97
36835: PUSH
36836: LD_VAR 0 2
36840: ARRAY
36841: AND
36842: IFFALSE 36880
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36844: LD_ADDR_EXP 97
36848: PUSH
36849: LD_EXP 97
36853: PPUSH
36854: LD_VAR 0 2
36858: PPUSH
36859: EMPTY
36860: PPUSH
36861: CALL_OW 1
36865: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
36866: LD_VAR 0 2
36870: PPUSH
36871: LD_INT 107
36873: PPUSH
36874: CALL 27518 0 2
// continue ;
36878: GO 36785
// end ; target := [ ] ;
36880: LD_ADDR_VAR 0 7
36884: PUSH
36885: EMPTY
36886: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36887: LD_ADDR_VAR 0 6
36891: PUSH
36892: LD_EXP 80
36896: PUSH
36897: LD_VAR 0 2
36901: ARRAY
36902: PUSH
36903: LD_INT 1
36905: ARRAY
36906: PPUSH
36907: CALL_OW 255
36911: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36912: LD_ADDR_VAR 0 9
36916: PUSH
36917: LD_EXP 80
36921: PUSH
36922: LD_VAR 0 2
36926: ARRAY
36927: PPUSH
36928: LD_INT 2
36930: PUSH
36931: LD_INT 30
36933: PUSH
36934: LD_INT 0
36936: PUSH
36937: EMPTY
36938: LIST
36939: LIST
36940: PUSH
36941: LD_INT 30
36943: PUSH
36944: LD_INT 1
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: LIST
36955: PPUSH
36956: CALL_OW 72
36960: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
36961: LD_ADDR_VAR 0 3
36965: PUSH
36966: DOUBLE
36967: LD_EXP 96
36971: PUSH
36972: LD_VAR 0 2
36976: ARRAY
36977: INC
36978: ST_TO_ADDR
36979: LD_INT 1
36981: PUSH
36982: FOR_DOWNTO
36983: IFFALSE 37230
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
36985: LD_EXP 96
36989: PUSH
36990: LD_VAR 0 2
36994: ARRAY
36995: PUSH
36996: LD_VAR 0 3
37000: ARRAY
37001: PUSH
37002: LD_INT 2
37004: ARRAY
37005: PPUSH
37006: LD_EXP 96
37010: PUSH
37011: LD_VAR 0 2
37015: ARRAY
37016: PUSH
37017: LD_VAR 0 3
37021: ARRAY
37022: PUSH
37023: LD_INT 3
37025: ARRAY
37026: PPUSH
37027: CALL_OW 488
37031: IFFALSE 37085
37033: PUSH
37034: LD_EXP 96
37038: PUSH
37039: LD_VAR 0 2
37043: ARRAY
37044: PUSH
37045: LD_VAR 0 3
37049: ARRAY
37050: PUSH
37051: LD_INT 2
37053: ARRAY
37054: PPUSH
37055: LD_EXP 96
37059: PUSH
37060: LD_VAR 0 2
37064: ARRAY
37065: PUSH
37066: LD_VAR 0 3
37070: ARRAY
37071: PUSH
37072: LD_INT 3
37074: ARRAY
37075: PPUSH
37076: CALL_OW 284
37080: PUSH
37081: LD_INT 0
37083: EQUAL
37084: AND
37085: IFFALSE 37140
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
37087: LD_ADDR_VAR 0 5
37091: PUSH
37092: LD_EXP 96
37096: PUSH
37097: LD_VAR 0 2
37101: ARRAY
37102: PPUSH
37103: LD_VAR 0 3
37107: PPUSH
37108: CALL_OW 3
37112: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
37113: LD_ADDR_EXP 96
37117: PUSH
37118: LD_EXP 96
37122: PPUSH
37123: LD_VAR 0 2
37127: PPUSH
37128: LD_VAR 0 5
37132: PPUSH
37133: CALL_OW 1
37137: ST_TO_ADDR
// continue ;
37138: GO 36982
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
37140: LD_VAR 0 6
37144: PPUSH
37145: LD_EXP 96
37149: PUSH
37150: LD_VAR 0 2
37154: ARRAY
37155: PUSH
37156: LD_VAR 0 3
37160: ARRAY
37161: PUSH
37162: LD_INT 2
37164: ARRAY
37165: PPUSH
37166: LD_EXP 96
37170: PUSH
37171: LD_VAR 0 2
37175: ARRAY
37176: PUSH
37177: LD_VAR 0 3
37181: ARRAY
37182: PUSH
37183: LD_INT 3
37185: ARRAY
37186: PPUSH
37187: LD_INT 30
37189: PPUSH
37190: CALL 60823 0 4
37194: PUSH
37195: LD_INT 4
37197: ARRAY
37198: PUSH
37199: LD_INT 0
37201: EQUAL
37202: IFFALSE 37228
// begin target := mc_crates [ i ] [ j ] ;
37204: LD_ADDR_VAR 0 7
37208: PUSH
37209: LD_EXP 96
37213: PUSH
37214: LD_VAR 0 2
37218: ARRAY
37219: PUSH
37220: LD_VAR 0 3
37224: ARRAY
37225: ST_TO_ADDR
// break ;
37226: GO 37230
// end ; end ;
37228: GO 36982
37230: POP
37231: POP
// if not target then
37232: LD_VAR 0 7
37236: NOT
37237: IFFALSE 37241
// continue ;
37239: GO 36785
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
37241: LD_ADDR_VAR 0 8
37245: PUSH
37246: LD_EXP 99
37250: PUSH
37251: LD_VAR 0 2
37255: ARRAY
37256: PPUSH
37257: LD_INT 2
37259: PUSH
37260: LD_INT 3
37262: PUSH
37263: LD_INT 58
37265: PUSH
37266: EMPTY
37267: LIST
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 61
37275: PUSH
37276: EMPTY
37277: LIST
37278: PUSH
37279: LD_INT 33
37281: PUSH
37282: LD_INT 5
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 33
37291: PUSH
37292: LD_INT 3
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 2
37308: PUSH
37309: LD_INT 34
37311: PUSH
37312: LD_INT 32
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: LD_INT 34
37321: PUSH
37322: LD_INT 51
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PUSH
37329: LD_INT 34
37331: PUSH
37332: LD_INT 12
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: LIST
37343: LIST
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PPUSH
37349: CALL_OW 72
37353: ST_TO_ADDR
// if not cargo then
37354: LD_VAR 0 8
37358: NOT
37359: IFFALSE 38073
// begin if mc_crates_collector [ i ] < 5 then
37361: LD_EXP 97
37365: PUSH
37366: LD_VAR 0 2
37370: ARRAY
37371: PUSH
37372: LD_INT 5
37374: LESS
37375: IFFALSE 37745
// begin if mc_ape [ i ] then
37377: LD_EXP 109
37381: PUSH
37382: LD_VAR 0 2
37386: ARRAY
37387: IFFALSE 37434
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
37389: LD_ADDR_VAR 0 5
37393: PUSH
37394: LD_EXP 109
37398: PUSH
37399: LD_VAR 0 2
37403: ARRAY
37404: PPUSH
37405: LD_INT 25
37407: PUSH
37408: LD_INT 16
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 24
37417: PUSH
37418: LD_INT 750
37420: PUSH
37421: EMPTY
37422: LIST
37423: LIST
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PPUSH
37429: CALL_OW 72
37433: ST_TO_ADDR
// if not tmp then
37434: LD_VAR 0 5
37438: NOT
37439: IFFALSE 37486
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
37441: LD_ADDR_VAR 0 5
37445: PUSH
37446: LD_EXP 80
37450: PUSH
37451: LD_VAR 0 2
37455: ARRAY
37456: PPUSH
37457: LD_INT 25
37459: PUSH
37460: LD_INT 2
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 24
37469: PUSH
37470: LD_INT 750
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PPUSH
37481: CALL_OW 72
37485: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
37486: LD_EXP 109
37490: PUSH
37491: LD_VAR 0 2
37495: ARRAY
37496: IFFALSE 37539
37498: PUSH
37499: LD_EXP 80
37503: PUSH
37504: LD_VAR 0 2
37508: ARRAY
37509: PPUSH
37510: LD_INT 25
37512: PUSH
37513: LD_INT 2
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 24
37522: PUSH
37523: LD_INT 750
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: PPUSH
37534: CALL_OW 72
37538: AND
37539: IFFALSE 37551
37541: PUSH
37542: LD_VAR 0 5
37546: PUSH
37547: LD_INT 5
37549: LESS
37550: AND
37551: IFFALSE 37633
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
37553: LD_ADDR_VAR 0 3
37557: PUSH
37558: LD_EXP 80
37562: PUSH
37563: LD_VAR 0 2
37567: ARRAY
37568: PPUSH
37569: LD_INT 25
37571: PUSH
37572: LD_INT 2
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 24
37581: PUSH
37582: LD_INT 750
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PUSH
37589: EMPTY
37590: LIST
37591: LIST
37592: PPUSH
37593: CALL_OW 72
37597: PUSH
37598: FOR_IN
37599: IFFALSE 37631
// begin tmp := tmp union j ;
37601: LD_ADDR_VAR 0 5
37605: PUSH
37606: LD_VAR 0 5
37610: PUSH
37611: LD_VAR 0 3
37615: UNION
37616: ST_TO_ADDR
// if tmp >= 5 then
37617: LD_VAR 0 5
37621: PUSH
37622: LD_INT 5
37624: GREATEREQUAL
37625: IFFALSE 37629
// break ;
37627: GO 37631
// end ;
37629: GO 37598
37631: POP
37632: POP
// end ; if not tmp then
37633: LD_VAR 0 5
37637: NOT
37638: IFFALSE 37642
// continue ;
37640: GO 36785
// for j in tmp do
37642: LD_ADDR_VAR 0 3
37646: PUSH
37647: LD_VAR 0 5
37651: PUSH
37652: FOR_IN
37653: IFFALSE 37743
// if not GetTag ( j ) then
37655: LD_VAR 0 3
37659: PPUSH
37660: CALL_OW 110
37664: NOT
37665: IFFALSE 37741
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
37667: LD_ADDR_EXP 97
37671: PUSH
37672: LD_EXP 97
37676: PPUSH
37677: LD_VAR 0 2
37681: PUSH
37682: LD_EXP 97
37686: PUSH
37687: LD_VAR 0 2
37691: ARRAY
37692: PUSH
37693: LD_INT 1
37695: PLUS
37696: PUSH
37697: EMPTY
37698: LIST
37699: LIST
37700: PPUSH
37701: LD_VAR 0 3
37705: PPUSH
37706: CALL 59553 0 3
37710: ST_TO_ADDR
// SetTag ( j , 107 ) ;
37711: LD_VAR 0 3
37715: PPUSH
37716: LD_INT 107
37718: PPUSH
37719: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
37723: LD_EXP 97
37727: PUSH
37728: LD_VAR 0 2
37732: ARRAY
37733: PUSH
37734: LD_INT 5
37736: GREATEREQUAL
37737: IFFALSE 37741
// break ;
37739: GO 37743
// end ;
37741: GO 37652
37743: POP
37744: POP
// end ; if mc_crates_collector [ i ] and target then
37745: LD_EXP 97
37749: PUSH
37750: LD_VAR 0 2
37754: ARRAY
37755: IFFALSE 37763
37757: PUSH
37758: LD_VAR 0 7
37762: AND
37763: IFFALSE 38071
// begin if mc_crates_collector [ i ] < target [ 1 ] then
37765: LD_EXP 97
37769: PUSH
37770: LD_VAR 0 2
37774: ARRAY
37775: PUSH
37776: LD_VAR 0 7
37780: PUSH
37781: LD_INT 1
37783: ARRAY
37784: LESS
37785: IFFALSE 37805
// tmp := mc_crates_collector [ i ] else
37787: LD_ADDR_VAR 0 5
37791: PUSH
37792: LD_EXP 97
37796: PUSH
37797: LD_VAR 0 2
37801: ARRAY
37802: ST_TO_ADDR
37803: GO 37819
// tmp := target [ 1 ] ;
37805: LD_ADDR_VAR 0 5
37809: PUSH
37810: LD_VAR 0 7
37814: PUSH
37815: LD_INT 1
37817: ARRAY
37818: ST_TO_ADDR
// k := 0 ;
37819: LD_ADDR_VAR 0 4
37823: PUSH
37824: LD_INT 0
37826: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
37827: LD_ADDR_VAR 0 3
37831: PUSH
37832: LD_EXP 97
37836: PUSH
37837: LD_VAR 0 2
37841: ARRAY
37842: PUSH
37843: FOR_IN
37844: IFFALSE 38069
// begin k := k + 1 ;
37846: LD_ADDR_VAR 0 4
37850: PUSH
37851: LD_VAR 0 4
37855: PUSH
37856: LD_INT 1
37858: PLUS
37859: ST_TO_ADDR
// if k > tmp then
37860: LD_VAR 0 4
37864: PUSH
37865: LD_VAR 0 5
37869: GREATER
37870: IFFALSE 37874
// break ;
37872: GO 38069
// if not GetClass ( j ) in [ 2 , 16 ] then
37874: LD_VAR 0 3
37878: PPUSH
37879: CALL_OW 257
37883: PUSH
37884: LD_INT 2
37886: PUSH
37887: LD_INT 16
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: IN
37894: NOT
37895: IFFALSE 37948
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
37897: LD_ADDR_EXP 97
37901: PUSH
37902: LD_EXP 97
37906: PPUSH
37907: LD_VAR 0 2
37911: PPUSH
37912: LD_EXP 97
37916: PUSH
37917: LD_VAR 0 2
37921: ARRAY
37922: PUSH
37923: LD_VAR 0 3
37927: DIFF
37928: PPUSH
37929: CALL_OW 1
37933: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37934: LD_VAR 0 3
37938: PPUSH
37939: LD_INT 0
37941: PPUSH
37942: CALL_OW 109
// continue ;
37946: GO 37843
// end ; if IsInUnit ( j ) then
37948: LD_VAR 0 3
37952: PPUSH
37953: CALL_OW 310
37957: IFFALSE 37968
// ComExitBuilding ( j ) ;
37959: LD_VAR 0 3
37963: PPUSH
37964: CALL_OW 122
// wait ( 3 ) ;
37968: LD_INT 3
37970: PPUSH
37971: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
37975: LD_VAR 0 3
37979: PPUSH
37980: CALL_OW 314
37984: IFFALSE 38022
37986: PUSH
37987: LD_VAR 0 6
37991: PPUSH
37992: LD_VAR 0 7
37996: PUSH
37997: LD_INT 2
37999: ARRAY
38000: PPUSH
38001: LD_VAR 0 7
38005: PUSH
38006: LD_INT 3
38008: ARRAY
38009: PPUSH
38010: LD_INT 30
38012: PPUSH
38013: CALL 60823 0 4
38017: PUSH
38018: LD_INT 4
38020: ARRAY
38021: AND
38022: IFFALSE 38040
// ComStandNearbyBuilding ( j , depot ) else
38024: LD_VAR 0 3
38028: PPUSH
38029: LD_VAR 0 9
38033: PPUSH
38034: CALL 56095 0 2
38038: GO 38067
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
38040: LD_VAR 0 3
38044: PPUSH
38045: LD_VAR 0 7
38049: PUSH
38050: LD_INT 2
38052: ARRAY
38053: PPUSH
38054: LD_VAR 0 7
38058: PUSH
38059: LD_INT 3
38061: ARRAY
38062: PPUSH
38063: CALL_OW 117
// end ;
38067: GO 37843
38069: POP
38070: POP
// end ; end else
38071: GO 38613
// begin for j in cargo do
38073: LD_ADDR_VAR 0 3
38077: PUSH
38078: LD_VAR 0 8
38082: PUSH
38083: FOR_IN
38084: IFFALSE 38611
// begin if GetTag ( j ) <> 0 then
38086: LD_VAR 0 3
38090: PPUSH
38091: CALL_OW 110
38095: PUSH
38096: LD_INT 0
38098: NONEQUAL
38099: IFFALSE 38103
// continue ;
38101: GO 38083
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
38103: LD_VAR 0 3
38107: PPUSH
38108: CALL_OW 256
38112: PUSH
38113: LD_INT 1000
38115: LESS
38116: IFFALSE 38141
38118: PUSH
38119: LD_VAR 0 3
38123: PPUSH
38124: LD_EXP 104
38128: PUSH
38129: LD_VAR 0 2
38133: ARRAY
38134: PPUSH
38135: CALL_OW 308
38139: NOT
38140: AND
38141: IFFALSE 38163
// ComMoveToArea ( j , mc_parking [ i ] ) ;
38143: LD_VAR 0 3
38147: PPUSH
38148: LD_EXP 104
38152: PUSH
38153: LD_VAR 0 2
38157: ARRAY
38158: PPUSH
38159: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
38163: LD_VAR 0 3
38167: PPUSH
38168: CALL_OW 256
38172: PUSH
38173: LD_INT 1000
38175: LESS
38176: IFFALSE 38200
38178: PUSH
38179: LD_VAR 0 3
38183: PPUSH
38184: LD_EXP 104
38188: PUSH
38189: LD_VAR 0 2
38193: ARRAY
38194: PPUSH
38195: CALL_OW 308
38199: AND
38200: IFFALSE 38204
// continue ;
38202: GO 38083
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
38204: LD_VAR 0 3
38208: PPUSH
38209: CALL_OW 262
38213: PUSH
38214: LD_INT 2
38216: EQUAL
38217: IFFALSE 38234
38219: PUSH
38220: LD_VAR 0 3
38224: PPUSH
38225: CALL_OW 261
38229: PUSH
38230: LD_INT 15
38232: LESS
38233: AND
38234: IFFALSE 38238
// continue ;
38236: GO 38083
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
38238: LD_VAR 0 3
38242: PPUSH
38243: CALL_OW 262
38247: PUSH
38248: LD_INT 1
38250: EQUAL
38251: IFFALSE 38268
38253: PUSH
38254: LD_VAR 0 3
38258: PPUSH
38259: CALL_OW 261
38263: PUSH
38264: LD_INT 10
38266: LESS
38267: AND
38268: IFFALSE 38548
// begin if not depot then
38270: LD_VAR 0 9
38274: NOT
38275: IFFALSE 38279
// continue ;
38277: GO 38083
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
38279: LD_VAR 0 3
38283: PPUSH
38284: LD_VAR 0 9
38288: PPUSH
38289: LD_VAR 0 3
38293: PPUSH
38294: CALL_OW 74
38298: PPUSH
38299: CALL_OW 296
38303: PUSH
38304: LD_INT 6
38306: LESS
38307: IFFALSE 38323
// SetFuel ( j , 100 ) else
38309: LD_VAR 0 3
38313: PPUSH
38314: LD_INT 100
38316: PPUSH
38317: CALL_OW 240
38321: GO 38548
// if GetFuel ( j ) = 0 then
38323: LD_VAR 0 3
38327: PPUSH
38328: CALL_OW 261
38332: PUSH
38333: LD_INT 0
38335: EQUAL
38336: IFFALSE 38548
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
38338: LD_ADDR_EXP 99
38342: PUSH
38343: LD_EXP 99
38347: PPUSH
38348: LD_VAR 0 2
38352: PPUSH
38353: LD_EXP 99
38357: PUSH
38358: LD_VAR 0 2
38362: ARRAY
38363: PUSH
38364: LD_VAR 0 3
38368: DIFF
38369: PPUSH
38370: CALL_OW 1
38374: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
38375: LD_VAR 0 3
38379: PPUSH
38380: CALL_OW 263
38384: PUSH
38385: LD_INT 1
38387: EQUAL
38388: IFFALSE 38404
// ComExitVehicle ( IsInUnit ( j ) ) ;
38390: LD_VAR 0 3
38394: PPUSH
38395: CALL_OW 310
38399: PPUSH
38400: CALL_OW 121
// if GetControl ( j ) = control_remote then
38404: LD_VAR 0 3
38408: PPUSH
38409: CALL_OW 263
38413: PUSH
38414: LD_INT 2
38416: EQUAL
38417: IFFALSE 38428
// ComUnlink ( j ) ;
38419: LD_VAR 0 3
38423: PPUSH
38424: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
38428: LD_ADDR_VAR 0 10
38432: PUSH
38433: LD_VAR 0 2
38437: PPUSH
38438: LD_INT 3
38440: PPUSH
38441: CALL 48342 0 2
38445: ST_TO_ADDR
// if fac then
38446: LD_VAR 0 10
38450: IFFALSE 38546
// begin for k in fac do
38452: LD_ADDR_VAR 0 4
38456: PUSH
38457: LD_VAR 0 10
38461: PUSH
38462: FOR_IN
38463: IFFALSE 38544
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
38465: LD_ADDR_VAR 0 11
38469: PUSH
38470: LD_VAR 0 10
38474: PPUSH
38475: LD_VAR 0 3
38479: PPUSH
38480: CALL_OW 265
38484: PPUSH
38485: LD_VAR 0 3
38489: PPUSH
38490: CALL_OW 262
38494: PPUSH
38495: LD_VAR 0 3
38499: PPUSH
38500: CALL_OW 263
38504: PPUSH
38505: LD_VAR 0 3
38509: PPUSH
38510: CALL_OW 264
38514: PPUSH
38515: CALL 56993 0 5
38519: ST_TO_ADDR
// if components then
38520: LD_VAR 0 11
38524: IFFALSE 38542
// begin MC_InsertProduceList ( i , components ) ;
38526: LD_VAR 0 2
38530: PPUSH
38531: LD_VAR 0 11
38535: PPUSH
38536: CALL 47887 0 2
// break ;
38540: GO 38544
// end ; end ;
38542: GO 38462
38544: POP
38545: POP
// end ; continue ;
38546: GO 38083
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
38548: LD_VAR 0 3
38552: PPUSH
38553: LD_INT 1
38555: PPUSH
38556: CALL_OW 289
38560: PUSH
38561: LD_INT 100
38563: LESS
38564: IFFALSE 38578
38566: PUSH
38567: LD_VAR 0 3
38571: PPUSH
38572: CALL_OW 314
38576: NOT
38577: AND
38578: IFFALSE 38607
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
38580: LD_VAR 0 3
38584: PPUSH
38585: LD_VAR 0 7
38589: PUSH
38590: LD_INT 2
38592: ARRAY
38593: PPUSH
38594: LD_VAR 0 7
38598: PUSH
38599: LD_INT 3
38601: ARRAY
38602: PPUSH
38603: CALL_OW 117
// break ;
38607: GO 38611
// end ;
38609: GO 38083
38611: POP
38612: POP
// end ; end ;
38613: GO 36785
38615: POP
38616: POP
// end ;
38617: LD_VAR 0 1
38621: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
38622: LD_INT 0
38624: PPUSH
38625: PPUSH
38626: PPUSH
38627: PPUSH
// if not mc_bases then
38628: LD_EXP 80
38632: NOT
38633: IFFALSE 38637
// exit ;
38635: GO 38802
// for i = 1 to mc_bases do
38637: LD_ADDR_VAR 0 2
38641: PUSH
38642: DOUBLE
38643: LD_INT 1
38645: DEC
38646: ST_TO_ADDR
38647: LD_EXP 80
38651: PUSH
38652: FOR_TO
38653: IFFALSE 38800
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
38655: LD_ADDR_VAR 0 4
38659: PUSH
38660: LD_EXP 99
38664: PUSH
38665: LD_VAR 0 2
38669: ARRAY
38670: PUSH
38671: LD_EXP 102
38675: PUSH
38676: LD_VAR 0 2
38680: ARRAY
38681: UNION
38682: PPUSH
38683: LD_INT 33
38685: PUSH
38686: LD_INT 2
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PPUSH
38693: CALL_OW 72
38697: ST_TO_ADDR
// if tmp then
38698: LD_VAR 0 4
38702: IFFALSE 38798
// for j in tmp do
38704: LD_ADDR_VAR 0 3
38708: PUSH
38709: LD_VAR 0 4
38713: PUSH
38714: FOR_IN
38715: IFFALSE 38796
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
38717: LD_VAR 0 3
38721: PPUSH
38722: CALL_OW 312
38726: NOT
38727: IFFALSE 38744
38729: PUSH
38730: LD_VAR 0 3
38734: PPUSH
38735: CALL_OW 256
38739: PUSH
38740: LD_INT 250
38742: GREATEREQUAL
38743: AND
38744: IFFALSE 38757
// Connect ( j ) else
38746: LD_VAR 0 3
38750: PPUSH
38751: CALL 62913 0 1
38755: GO 38794
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
38757: LD_VAR 0 3
38761: PPUSH
38762: CALL_OW 256
38766: PUSH
38767: LD_INT 250
38769: LESS
38770: IFFALSE 38783
38772: PUSH
38773: LD_VAR 0 3
38777: PPUSH
38778: CALL_OW 312
38782: AND
38783: IFFALSE 38794
// ComUnlink ( j ) ;
38785: LD_VAR 0 3
38789: PPUSH
38790: CALL_OW 136
38794: GO 38714
38796: POP
38797: POP
// end ;
38798: GO 38652
38800: POP
38801: POP
// end ;
38802: LD_VAR 0 1
38806: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
38807: LD_INT 0
38809: PPUSH
38810: PPUSH
38811: PPUSH
38812: PPUSH
38813: PPUSH
// if not mc_bases then
38814: LD_EXP 80
38818: NOT
38819: IFFALSE 38823
// exit ;
38821: GO 39272
// for i = 1 to mc_bases do
38823: LD_ADDR_VAR 0 2
38827: PUSH
38828: DOUBLE
38829: LD_INT 1
38831: DEC
38832: ST_TO_ADDR
38833: LD_EXP 80
38837: PUSH
38838: FOR_TO
38839: IFFALSE 39270
// begin if not mc_produce [ i ] then
38841: LD_EXP 101
38845: PUSH
38846: LD_VAR 0 2
38850: ARRAY
38851: NOT
38852: IFFALSE 38856
// continue ;
38854: GO 38838
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38856: LD_ADDR_VAR 0 5
38860: PUSH
38861: LD_EXP 80
38865: PUSH
38866: LD_VAR 0 2
38870: ARRAY
38871: PPUSH
38872: LD_INT 30
38874: PUSH
38875: LD_INT 3
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PPUSH
38882: CALL_OW 72
38886: ST_TO_ADDR
// if not fac then
38887: LD_VAR 0 5
38891: NOT
38892: IFFALSE 38896
// continue ;
38894: GO 38838
// for j in fac do
38896: LD_ADDR_VAR 0 3
38900: PUSH
38901: LD_VAR 0 5
38905: PUSH
38906: FOR_IN
38907: IFFALSE 39266
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
38909: LD_VAR 0 3
38913: PPUSH
38914: CALL_OW 461
38918: PUSH
38919: LD_INT 2
38921: NONEQUAL
38922: IFTRUE 38942
38924: PUSH
38925: LD_VAR 0 3
38929: PPUSH
38930: LD_INT 15
38932: PPUSH
38933: CALL 62532 0 2
38937: PUSH
38938: LD_INT 4
38940: ARRAY
38941: OR
38942: IFFALSE 38946
// continue ;
38944: GO 38906
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
38946: LD_VAR 0 3
38950: PPUSH
38951: LD_EXP 101
38955: PUSH
38956: LD_VAR 0 2
38960: ARRAY
38961: PUSH
38962: LD_INT 1
38964: ARRAY
38965: PUSH
38966: LD_INT 1
38968: ARRAY
38969: PPUSH
38970: LD_EXP 101
38974: PUSH
38975: LD_VAR 0 2
38979: ARRAY
38980: PUSH
38981: LD_INT 1
38983: ARRAY
38984: PUSH
38985: LD_INT 2
38987: ARRAY
38988: PPUSH
38989: LD_EXP 101
38993: PUSH
38994: LD_VAR 0 2
38998: ARRAY
38999: PUSH
39000: LD_INT 1
39002: ARRAY
39003: PUSH
39004: LD_INT 3
39006: ARRAY
39007: PPUSH
39008: LD_EXP 101
39012: PUSH
39013: LD_VAR 0 2
39017: ARRAY
39018: PUSH
39019: LD_INT 1
39021: ARRAY
39022: PUSH
39023: LD_INT 4
39025: ARRAY
39026: PPUSH
39027: CALL_OW 448
39031: IFFALSE 39126
39033: PUSH
39034: LD_VAR 0 3
39038: PPUSH
39039: LD_EXP 101
39043: PUSH
39044: LD_VAR 0 2
39048: ARRAY
39049: PUSH
39050: LD_INT 1
39052: ARRAY
39053: PUSH
39054: LD_INT 1
39056: ARRAY
39057: PUSH
39058: LD_EXP 101
39062: PUSH
39063: LD_VAR 0 2
39067: ARRAY
39068: PUSH
39069: LD_INT 1
39071: ARRAY
39072: PUSH
39073: LD_INT 2
39075: ARRAY
39076: PUSH
39077: LD_EXP 101
39081: PUSH
39082: LD_VAR 0 2
39086: ARRAY
39087: PUSH
39088: LD_INT 1
39090: ARRAY
39091: PUSH
39092: LD_INT 3
39094: ARRAY
39095: PUSH
39096: LD_EXP 101
39100: PUSH
39101: LD_VAR 0 2
39105: ARRAY
39106: PUSH
39107: LD_INT 1
39109: ARRAY
39110: PUSH
39111: LD_INT 4
39113: ARRAY
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: LIST
39119: LIST
39120: PPUSH
39121: CALL 66346 0 2
39125: AND
39126: IFFALSE 39264
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
39128: LD_VAR 0 3
39132: PPUSH
39133: LD_EXP 101
39137: PUSH
39138: LD_VAR 0 2
39142: ARRAY
39143: PUSH
39144: LD_INT 1
39146: ARRAY
39147: PUSH
39148: LD_INT 1
39150: ARRAY
39151: PPUSH
39152: LD_EXP 101
39156: PUSH
39157: LD_VAR 0 2
39161: ARRAY
39162: PUSH
39163: LD_INT 1
39165: ARRAY
39166: PUSH
39167: LD_INT 2
39169: ARRAY
39170: PPUSH
39171: LD_EXP 101
39175: PUSH
39176: LD_VAR 0 2
39180: ARRAY
39181: PUSH
39182: LD_INT 1
39184: ARRAY
39185: PUSH
39186: LD_INT 3
39188: ARRAY
39189: PPUSH
39190: LD_EXP 101
39194: PUSH
39195: LD_VAR 0 2
39199: ARRAY
39200: PUSH
39201: LD_INT 1
39203: ARRAY
39204: PUSH
39205: LD_INT 4
39207: ARRAY
39208: PPUSH
39209: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
39213: LD_ADDR_VAR 0 4
39217: PUSH
39218: LD_EXP 101
39222: PUSH
39223: LD_VAR 0 2
39227: ARRAY
39228: PPUSH
39229: LD_INT 1
39231: PPUSH
39232: CALL_OW 3
39236: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
39237: LD_ADDR_EXP 101
39241: PUSH
39242: LD_EXP 101
39246: PPUSH
39247: LD_VAR 0 2
39251: PPUSH
39252: LD_VAR 0 4
39256: PPUSH
39257: CALL_OW 1
39261: ST_TO_ADDR
// break ;
39262: GO 39266
// end ; end ;
39264: GO 38906
39266: POP
39267: POP
// end ;
39268: GO 38838
39270: POP
39271: POP
// end ;
39272: LD_VAR 0 1
39276: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
39277: LD_INT 0
39279: PPUSH
39280: PPUSH
39281: PPUSH
// if not mc_bases then
39282: LD_EXP 80
39286: NOT
39287: IFFALSE 39291
// exit ;
39289: GO 39380
// for i = 1 to mc_bases do
39291: LD_ADDR_VAR 0 2
39295: PUSH
39296: DOUBLE
39297: LD_INT 1
39299: DEC
39300: ST_TO_ADDR
39301: LD_EXP 80
39305: PUSH
39306: FOR_TO
39307: IFFALSE 39378
// begin if mc_attack [ i ] then
39309: LD_EXP 100
39313: PUSH
39314: LD_VAR 0 2
39318: ARRAY
39319: IFFALSE 39376
// begin tmp := mc_attack [ i ] [ 1 ] ;
39321: LD_ADDR_VAR 0 3
39325: PUSH
39326: LD_EXP 100
39330: PUSH
39331: LD_VAR 0 2
39335: ARRAY
39336: PUSH
39337: LD_INT 1
39339: ARRAY
39340: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
39341: LD_ADDR_EXP 100
39345: PUSH
39346: LD_EXP 100
39350: PPUSH
39351: LD_VAR 0 2
39355: PPUSH
39356: EMPTY
39357: PPUSH
39358: CALL_OW 1
39362: ST_TO_ADDR
// Attack ( tmp ) ;
39363: LD_VAR 0 3
39367: PPUSH
39368: CALL 120408 0 1
// exit ;
39372: POP
39373: POP
39374: GO 39380
// end ; end ;
39376: GO 39306
39378: POP
39379: POP
// end ;
39380: LD_VAR 0 1
39384: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
39385: LD_INT 0
39387: PPUSH
39388: PPUSH
39389: PPUSH
39390: PPUSH
39391: PPUSH
39392: PPUSH
39393: PPUSH
// if not mc_bases then
39394: LD_EXP 80
39398: NOT
39399: IFFALSE 39403
// exit ;
39401: GO 40280
// for i = 1 to mc_bases do
39403: LD_ADDR_VAR 0 2
39407: PUSH
39408: DOUBLE
39409: LD_INT 1
39411: DEC
39412: ST_TO_ADDR
39413: LD_EXP 80
39417: PUSH
39418: FOR_TO
39419: IFFALSE 40278
// begin if not mc_bases [ i ] then
39421: LD_EXP 80
39425: PUSH
39426: LD_VAR 0 2
39430: ARRAY
39431: NOT
39432: IFFALSE 39436
// continue ;
39434: GO 39418
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
39436: LD_ADDR_VAR 0 7
39440: PUSH
39441: LD_EXP 80
39445: PUSH
39446: LD_VAR 0 2
39450: ARRAY
39451: PUSH
39452: LD_INT 1
39454: ARRAY
39455: PPUSH
39456: CALL 56319 0 1
39460: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
39461: LD_ADDR_EXP 103
39465: PUSH
39466: LD_EXP 103
39470: PPUSH
39471: LD_VAR 0 2
39475: PPUSH
39476: LD_EXP 80
39480: PUSH
39481: LD_VAR 0 2
39485: ARRAY
39486: PUSH
39487: LD_INT 1
39489: ARRAY
39490: PPUSH
39491: CALL_OW 255
39495: PPUSH
39496: LD_EXP 105
39500: PUSH
39501: LD_VAR 0 2
39505: ARRAY
39506: PPUSH
39507: CALL 56284 0 2
39511: PPUSH
39512: CALL_OW 1
39516: ST_TO_ADDR
// if not mc_scan [ i ] then
39517: LD_EXP 103
39521: PUSH
39522: LD_VAR 0 2
39526: ARRAY
39527: NOT
39528: IFFALSE 39712
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
39530: LD_ADDR_EXP 123
39534: PUSH
39535: LD_EXP 123
39539: PPUSH
39540: LD_VAR 0 2
39544: PPUSH
39545: LD_INT 0
39547: PPUSH
39548: CALL_OW 1
39552: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39553: LD_ADDR_VAR 0 4
39557: PUSH
39558: LD_EXP 80
39562: PUSH
39563: LD_VAR 0 2
39567: ARRAY
39568: PPUSH
39569: LD_INT 2
39571: PUSH
39572: LD_INT 25
39574: PUSH
39575: LD_INT 5
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 25
39584: PUSH
39585: LD_INT 8
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PUSH
39592: LD_INT 25
39594: PUSH
39595: LD_INT 9
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: LIST
39606: LIST
39607: PPUSH
39608: CALL_OW 72
39612: ST_TO_ADDR
// if not tmp then
39613: LD_VAR 0 4
39617: NOT
39618: IFFALSE 39622
// continue ;
39620: GO 39418
// for j in tmp do
39622: LD_ADDR_VAR 0 3
39626: PUSH
39627: LD_VAR 0 4
39631: PUSH
39632: FOR_IN
39633: IFFALSE 39710
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
39635: LD_VAR 0 3
39639: PPUSH
39640: CALL_OW 310
39644: PPUSH
39645: CALL_OW 266
39649: PUSH
39650: LD_INT 5
39652: EQUAL
39653: IFFALSE 39670
39655: PUSH
39656: LD_VAR 0 3
39660: PPUSH
39661: CALL_OW 257
39665: PUSH
39666: LD_INT 1
39668: EQUAL
39669: AND
39670: IFFALSE 39684
39672: PUSH
39673: LD_VAR 0 3
39677: PPUSH
39678: CALL_OW 459
39682: NOT
39683: AND
39684: IFFALSE 39692
39686: PUSH
39687: LD_VAR 0 7
39691: AND
39692: IFFALSE 39708
// ComChangeProfession ( j , class ) ;
39694: LD_VAR 0 3
39698: PPUSH
39699: LD_VAR 0 7
39703: PPUSH
39704: CALL_OW 123
39708: GO 39632
39710: POP
39711: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
39712: LD_EXP 103
39716: PUSH
39717: LD_VAR 0 2
39721: ARRAY
39722: IFFALSE 39737
39724: PUSH
39725: LD_EXP 123
39729: PUSH
39730: LD_VAR 0 2
39734: ARRAY
39735: NOT
39736: AND
39737: IFFALSE 39752
39739: PUSH
39740: LD_EXP 102
39744: PUSH
39745: LD_VAR 0 2
39749: ARRAY
39750: NOT
39751: AND
39752: IFFALSE 39903
39754: PUSH
39755: LD_EXP 80
39759: PUSH
39760: LD_VAR 0 2
39764: ARRAY
39765: PPUSH
39766: LD_INT 50
39768: PUSH
39769: EMPTY
39770: LIST
39771: PUSH
39772: LD_INT 2
39774: PUSH
39775: LD_INT 30
39777: PUSH
39778: LD_INT 32
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 30
39787: PUSH
39788: LD_INT 33
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 30
39797: PUSH
39798: LD_INT 4
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 30
39807: PUSH
39808: LD_INT 5
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: LIST
39819: LIST
39820: LIST
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PPUSH
39826: CALL_OW 72
39830: PUSH
39831: LD_INT 4
39833: LESS
39834: IFTRUE 39902
39836: PUSH
39837: LD_EXP 80
39841: PUSH
39842: LD_VAR 0 2
39846: ARRAY
39847: PPUSH
39848: LD_INT 3
39850: PUSH
39851: LD_INT 24
39853: PUSH
39854: LD_INT 1000
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 2
39867: PUSH
39868: LD_INT 30
39870: PUSH
39871: LD_INT 0
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: PUSH
39878: LD_INT 30
39880: PUSH
39881: LD_INT 1
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: EMPTY
39889: LIST
39890: LIST
39891: LIST
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PPUSH
39897: CALL_OW 72
39901: OR
39902: AND
39903: IFFALSE 40156
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39905: LD_ADDR_EXP 123
39909: PUSH
39910: LD_EXP 123
39914: PPUSH
39915: LD_VAR 0 2
39919: PPUSH
39920: LD_INT 1
39922: PPUSH
39923: CALL_OW 1
39927: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39928: LD_ADDR_VAR 0 4
39932: PUSH
39933: LD_EXP 80
39937: PUSH
39938: LD_VAR 0 2
39942: ARRAY
39943: PPUSH
39944: LD_INT 2
39946: PUSH
39947: LD_INT 25
39949: PUSH
39950: LD_INT 1
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: LD_INT 25
39959: PUSH
39960: LD_INT 5
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: PUSH
39967: LD_INT 25
39969: PUSH
39970: LD_INT 8
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 25
39979: PUSH
39980: LD_INT 9
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: PPUSH
39994: CALL_OW 72
39998: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
39999: LD_ADDR_VAR 0 4
40003: PUSH
40004: LD_VAR 0 4
40008: PUSH
40009: LD_VAR 0 4
40013: PPUSH
40014: LD_INT 18
40016: PPUSH
40017: CALL 90146 0 2
40021: DIFF
40022: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
40023: LD_VAR 0 4
40027: NOT
40028: IFFALSE 40076
40030: PUSH
40031: LD_EXP 80
40035: PUSH
40036: LD_VAR 0 2
40040: ARRAY
40041: PPUSH
40042: LD_INT 2
40044: PUSH
40045: LD_INT 30
40047: PUSH
40048: LD_INT 4
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: LD_INT 30
40057: PUSH
40058: LD_INT 5
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: LIST
40069: PPUSH
40070: CALL_OW 72
40074: NOT
40075: AND
40076: IFFALSE 40138
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
40078: LD_ADDR_VAR 0 4
40082: PUSH
40083: LD_EXP 80
40087: PUSH
40088: LD_VAR 0 2
40092: ARRAY
40093: PPUSH
40094: LD_INT 2
40096: PUSH
40097: LD_INT 25
40099: PUSH
40100: LD_INT 2
40102: PUSH
40103: EMPTY
40104: LIST
40105: LIST
40106: PUSH
40107: LD_INT 25
40109: PUSH
40110: LD_INT 3
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: PUSH
40117: LD_INT 25
40119: PUSH
40120: LD_INT 4
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: LIST
40131: LIST
40132: PPUSH
40133: CALL_OW 72
40137: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
40138: LD_VAR 0 2
40142: PPUSH
40143: LD_VAR 0 4
40147: PPUSH
40148: CALL 125177 0 2
// exit ;
40152: POP
40153: POP
40154: GO 40280
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
40156: LD_EXP 103
40160: PUSH
40161: LD_VAR 0 2
40165: ARRAY
40166: IFFALSE 40181
40168: PUSH
40169: LD_EXP 123
40173: PUSH
40174: LD_VAR 0 2
40178: ARRAY
40179: NOT
40180: AND
40181: IFFALSE 40195
40183: PUSH
40184: LD_EXP 102
40188: PUSH
40189: LD_VAR 0 2
40193: ARRAY
40194: AND
40195: IFFALSE 40276
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
40197: LD_ADDR_EXP 123
40201: PUSH
40202: LD_EXP 123
40206: PPUSH
40207: LD_VAR 0 2
40211: PPUSH
40212: LD_INT 1
40214: PPUSH
40215: CALL_OW 1
40219: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
40220: LD_ADDR_VAR 0 4
40224: PUSH
40225: LD_EXP 102
40229: PUSH
40230: LD_VAR 0 2
40234: ARRAY
40235: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
40236: LD_ADDR_EXP 102
40240: PUSH
40241: LD_EXP 102
40245: PPUSH
40246: LD_VAR 0 2
40250: PPUSH
40251: EMPTY
40252: PPUSH
40253: CALL_OW 1
40257: ST_TO_ADDR
// Defend ( i , tmp ) ;
40258: LD_VAR 0 2
40262: PPUSH
40263: LD_VAR 0 4
40267: PPUSH
40268: CALL 125781 0 2
// exit ;
40272: POP
40273: POP
40274: GO 40280
// end ; end ;
40276: GO 39418
40278: POP
40279: POP
// end ;
40280: LD_VAR 0 1
40284: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
40285: LD_INT 0
40287: PPUSH
40288: PPUSH
40289: PPUSH
40290: PPUSH
40291: PPUSH
40292: PPUSH
40293: PPUSH
40294: PPUSH
40295: PPUSH
40296: PPUSH
40297: PPUSH
// if not mc_bases then
40298: LD_EXP 80
40302: NOT
40303: IFFALSE 40307
// exit ;
40305: GO 41420
// for i = 1 to mc_bases do
40307: LD_ADDR_VAR 0 2
40311: PUSH
40312: DOUBLE
40313: LD_INT 1
40315: DEC
40316: ST_TO_ADDR
40317: LD_EXP 80
40321: PUSH
40322: FOR_TO
40323: IFFALSE 41418
// begin tmp := mc_lab [ i ] ;
40325: LD_ADDR_VAR 0 6
40329: PUSH
40330: LD_EXP 113
40334: PUSH
40335: LD_VAR 0 2
40339: ARRAY
40340: ST_TO_ADDR
// if not tmp then
40341: LD_VAR 0 6
40345: NOT
40346: IFFALSE 40350
// continue ;
40348: GO 40322
// idle_lab := 0 ;
40350: LD_ADDR_VAR 0 11
40354: PUSH
40355: LD_INT 0
40357: ST_TO_ADDR
// for j in tmp do
40358: LD_ADDR_VAR 0 3
40362: PUSH
40363: LD_VAR 0 6
40367: PUSH
40368: FOR_IN
40369: IFFALSE 41414
// begin researching := false ;
40371: LD_ADDR_VAR 0 10
40375: PUSH
40376: LD_INT 0
40378: ST_TO_ADDR
// side := GetSide ( j ) ;
40379: LD_ADDR_VAR 0 4
40383: PUSH
40384: LD_VAR 0 3
40388: PPUSH
40389: CALL_OW 255
40393: ST_TO_ADDR
// if not mc_tech [ side ] then
40394: LD_EXP 107
40398: PUSH
40399: LD_VAR 0 4
40403: ARRAY
40404: NOT
40405: IFFALSE 40409
// continue ;
40407: GO 40368
// if BuildingStatus ( j ) = bs_idle then
40409: LD_VAR 0 3
40413: PPUSH
40414: CALL_OW 461
40418: PUSH
40419: LD_INT 2
40421: EQUAL
40422: IFFALSE 40614
// begin if idle_lab and UnitsInside ( j ) < 6 then
40424: LD_VAR 0 11
40428: IFFALSE 40445
40430: PUSH
40431: LD_VAR 0 3
40435: PPUSH
40436: CALL_OW 313
40440: PUSH
40441: LD_INT 6
40443: LESS
40444: AND
40445: IFFALSE 40516
// begin tmp2 := UnitsInside ( idle_lab ) ;
40447: LD_ADDR_VAR 0 9
40451: PUSH
40452: LD_VAR 0 11
40456: PPUSH
40457: CALL_OW 313
40461: ST_TO_ADDR
// if tmp2 then
40462: LD_VAR 0 9
40466: IFFALSE 40508
// for x in tmp2 do
40468: LD_ADDR_VAR 0 7
40472: PUSH
40473: LD_VAR 0 9
40477: PUSH
40478: FOR_IN
40479: IFFALSE 40506
// begin ComExitBuilding ( x ) ;
40481: LD_VAR 0 7
40485: PPUSH
40486: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40490: LD_VAR 0 7
40494: PPUSH
40495: LD_VAR 0 3
40499: PPUSH
40500: CALL_OW 180
// end ;
40504: GO 40478
40506: POP
40507: POP
// idle_lab := 0 ;
40508: LD_ADDR_VAR 0 11
40512: PUSH
40513: LD_INT 0
40515: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
40516: LD_ADDR_VAR 0 5
40520: PUSH
40521: LD_EXP 107
40525: PUSH
40526: LD_VAR 0 4
40530: ARRAY
40531: PUSH
40532: FOR_IN
40533: IFFALSE 40595
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
40535: LD_VAR 0 3
40539: PPUSH
40540: LD_VAR 0 5
40544: PPUSH
40545: CALL_OW 430
40549: IFFALSE 40567
40551: PUSH
40552: LD_VAR 0 4
40556: PPUSH
40557: LD_VAR 0 5
40561: PPUSH
40562: CALL 55379 0 2
40566: AND
40567: IFFALSE 40593
// begin researching := true ;
40569: LD_ADDR_VAR 0 10
40573: PUSH
40574: LD_INT 1
40576: ST_TO_ADDR
// ComResearch ( j , t ) ;
40577: LD_VAR 0 3
40581: PPUSH
40582: LD_VAR 0 5
40586: PPUSH
40587: CALL_OW 124
// break ;
40591: GO 40595
// end ;
40593: GO 40532
40595: POP
40596: POP
// if not researching then
40597: LD_VAR 0 10
40601: NOT
40602: IFFALSE 40614
// idle_lab := j ;
40604: LD_ADDR_VAR 0 11
40608: PUSH
40609: LD_VAR 0 3
40613: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
40614: LD_VAR 0 3
40618: PPUSH
40619: CALL_OW 461
40623: PUSH
40624: LD_INT 10
40626: EQUAL
40627: IFFALSE 41233
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
40629: LD_EXP 109
40633: PUSH
40634: LD_VAR 0 2
40638: ARRAY
40639: NOT
40640: IFFALSE 40655
40642: PUSH
40643: LD_EXP 110
40647: PUSH
40648: LD_VAR 0 2
40652: ARRAY
40653: NOT
40654: AND
40655: IFFALSE 40673
40657: PUSH
40658: LD_EXP 107
40662: PUSH
40663: LD_VAR 0 4
40667: ARRAY
40668: PUSH
40669: LD_INT 1
40671: GREATER
40672: AND
40673: IFFALSE 40804
// begin ComCancel ( j ) ;
40675: LD_VAR 0 3
40679: PPUSH
40680: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
40684: LD_ADDR_EXP 107
40688: PUSH
40689: LD_EXP 107
40693: PPUSH
40694: LD_VAR 0 4
40698: PPUSH
40699: LD_EXP 107
40703: PUSH
40704: LD_VAR 0 4
40708: ARRAY
40709: PPUSH
40710: LD_EXP 107
40714: PUSH
40715: LD_VAR 0 4
40719: ARRAY
40720: PUSH
40721: LD_INT 1
40723: MINUS
40724: PPUSH
40725: LD_EXP 107
40729: PUSH
40730: LD_VAR 0 4
40734: ARRAY
40735: PPUSH
40736: LD_INT 0
40738: PPUSH
40739: CALL 58961 0 4
40743: PPUSH
40744: CALL_OW 1
40748: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
40749: LD_ADDR_EXP 107
40753: PUSH
40754: LD_EXP 107
40758: PPUSH
40759: LD_VAR 0 4
40763: PPUSH
40764: LD_EXP 107
40768: PUSH
40769: LD_VAR 0 4
40773: ARRAY
40774: PPUSH
40775: LD_EXP 107
40779: PUSH
40780: LD_VAR 0 4
40784: ARRAY
40785: PPUSH
40786: LD_INT 1
40788: PPUSH
40789: LD_INT 0
40791: PPUSH
40792: CALL 58961 0 4
40796: PPUSH
40797: CALL_OW 1
40801: ST_TO_ADDR
// continue ;
40802: GO 40368
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
40804: LD_EXP 109
40808: PUSH
40809: LD_VAR 0 2
40813: ARRAY
40814: IFFALSE 40829
40816: PUSH
40817: LD_EXP 110
40821: PUSH
40822: LD_VAR 0 2
40826: ARRAY
40827: NOT
40828: AND
40829: IFFALSE 40956
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
40831: LD_ADDR_EXP 110
40835: PUSH
40836: LD_EXP 110
40840: PPUSH
40841: LD_VAR 0 2
40845: PUSH
40846: LD_EXP 110
40850: PUSH
40851: LD_VAR 0 2
40855: ARRAY
40856: PUSH
40857: LD_INT 1
40859: PLUS
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PPUSH
40865: LD_EXP 109
40869: PUSH
40870: LD_VAR 0 2
40874: ARRAY
40875: PUSH
40876: LD_INT 1
40878: ARRAY
40879: PPUSH
40880: CALL 59553 0 3
40884: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
40885: LD_EXP 109
40889: PUSH
40890: LD_VAR 0 2
40894: ARRAY
40895: PUSH
40896: LD_INT 1
40898: ARRAY
40899: PPUSH
40900: LD_INT 112
40902: PPUSH
40903: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
40907: LD_ADDR_VAR 0 9
40911: PUSH
40912: LD_EXP 109
40916: PUSH
40917: LD_VAR 0 2
40921: ARRAY
40922: PPUSH
40923: LD_INT 1
40925: PPUSH
40926: CALL_OW 3
40930: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
40931: LD_ADDR_EXP 109
40935: PUSH
40936: LD_EXP 109
40940: PPUSH
40941: LD_VAR 0 2
40945: PPUSH
40946: LD_VAR 0 9
40950: PPUSH
40951: CALL_OW 1
40955: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
40956: LD_EXP 109
40960: PUSH
40961: LD_VAR 0 2
40965: ARRAY
40966: IFFALSE 40980
40968: PUSH
40969: LD_EXP 110
40973: PUSH
40974: LD_VAR 0 2
40978: ARRAY
40979: AND
40980: IFFALSE 41004
40982: PUSH
40983: LD_EXP 110
40987: PUSH
40988: LD_VAR 0 2
40992: ARRAY
40993: PUSH
40994: LD_INT 1
40996: ARRAY
40997: PPUSH
40998: CALL_OW 310
41002: NOT
41003: AND
41004: IFFALSE 41021
41006: PUSH
41007: LD_VAR 0 3
41011: PPUSH
41012: CALL_OW 313
41016: PUSH
41017: LD_INT 6
41019: EQUAL
41020: AND
41021: IFFALSE 41077
// begin tmp2 := UnitsInside ( j ) ;
41023: LD_ADDR_VAR 0 9
41027: PUSH
41028: LD_VAR 0 3
41032: PPUSH
41033: CALL_OW 313
41037: ST_TO_ADDR
// if tmp2 = 6 then
41038: LD_VAR 0 9
41042: PUSH
41043: LD_INT 6
41045: EQUAL
41046: IFFALSE 41077
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
41048: LD_VAR 0 9
41052: PUSH
41053: LD_INT 1
41055: ARRAY
41056: PPUSH
41057: LD_INT 112
41059: PPUSH
41060: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
41064: LD_VAR 0 9
41068: PUSH
41069: LD_INT 1
41071: ARRAY
41072: PPUSH
41073: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
41077: LD_EXP 110
41081: PUSH
41082: LD_VAR 0 2
41086: ARRAY
41087: IFFALSE 41111
41089: PUSH
41090: LD_EXP 110
41094: PUSH
41095: LD_VAR 0 2
41099: ARRAY
41100: PUSH
41101: LD_INT 1
41103: ARRAY
41104: PPUSH
41105: CALL_OW 314
41109: NOT
41110: AND
41111: IFFALSE 41135
41113: PUSH
41114: LD_EXP 110
41118: PUSH
41119: LD_VAR 0 2
41123: ARRAY
41124: PUSH
41125: LD_INT 1
41127: ARRAY
41128: PPUSH
41129: CALL_OW 310
41133: NOT
41134: AND
41135: IFFALSE 41161
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
41137: LD_EXP 110
41141: PUSH
41142: LD_VAR 0 2
41146: ARRAY
41147: PUSH
41148: LD_INT 1
41150: ARRAY
41151: PPUSH
41152: LD_VAR 0 3
41156: PPUSH
41157: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
41161: LD_EXP 110
41165: PUSH
41166: LD_VAR 0 2
41170: ARRAY
41171: PUSH
41172: LD_INT 1
41174: ARRAY
41175: PPUSH
41176: CALL_OW 310
41180: IFFALSE 41212
41182: PUSH
41183: LD_EXP 110
41187: PUSH
41188: LD_VAR 0 2
41192: ARRAY
41193: PUSH
41194: LD_INT 1
41196: ARRAY
41197: PPUSH
41198: CALL_OW 310
41202: PPUSH
41203: CALL_OW 461
41207: PUSH
41208: LD_INT 3
41210: NONEQUAL
41211: AND
41212: IFFALSE 41233
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
41214: LD_EXP 110
41218: PUSH
41219: LD_VAR 0 2
41223: ARRAY
41224: PUSH
41225: LD_INT 1
41227: ARRAY
41228: PPUSH
41229: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
41233: LD_VAR 0 3
41237: PPUSH
41238: CALL_OW 461
41242: PUSH
41243: LD_INT 6
41245: EQUAL
41246: IFFALSE 41258
41248: PUSH
41249: LD_VAR 0 6
41253: PUSH
41254: LD_INT 1
41256: GREATER
41257: AND
41258: IFFALSE 41412
// begin sci := [ ] ;
41260: LD_ADDR_VAR 0 8
41264: PUSH
41265: EMPTY
41266: ST_TO_ADDR
// for x in ( tmp diff j ) do
41267: LD_ADDR_VAR 0 7
41271: PUSH
41272: LD_VAR 0 6
41276: PUSH
41277: LD_VAR 0 3
41281: DIFF
41282: PUSH
41283: FOR_IN
41284: IFFALSE 41336
// begin if sci = 6 then
41286: LD_VAR 0 8
41290: PUSH
41291: LD_INT 6
41293: EQUAL
41294: IFFALSE 41298
// break ;
41296: GO 41336
// if BuildingStatus ( x ) = bs_idle then
41298: LD_VAR 0 7
41302: PPUSH
41303: CALL_OW 461
41307: PUSH
41308: LD_INT 2
41310: EQUAL
41311: IFFALSE 41334
// sci := sci ^ UnitsInside ( x ) ;
41313: LD_ADDR_VAR 0 8
41317: PUSH
41318: LD_VAR 0 8
41322: PUSH
41323: LD_VAR 0 7
41327: PPUSH
41328: CALL_OW 313
41332: ADD
41333: ST_TO_ADDR
// end ;
41334: GO 41283
41336: POP
41337: POP
// if not sci then
41338: LD_VAR 0 8
41342: NOT
41343: IFFALSE 41347
// continue ;
41345: GO 40368
// for x in sci do
41347: LD_ADDR_VAR 0 7
41351: PUSH
41352: LD_VAR 0 8
41356: PUSH
41357: FOR_IN
41358: IFFALSE 41410
// if IsInUnit ( x ) and not HasTask ( x ) then
41360: LD_VAR 0 7
41364: PPUSH
41365: CALL_OW 310
41369: IFFALSE 41383
41371: PUSH
41372: LD_VAR 0 7
41376: PPUSH
41377: CALL_OW 314
41381: NOT
41382: AND
41383: IFFALSE 41408
// begin ComExitBuilding ( x ) ;
41385: LD_VAR 0 7
41389: PPUSH
41390: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
41394: LD_VAR 0 7
41398: PPUSH
41399: LD_VAR 0 3
41403: PPUSH
41404: CALL_OW 180
// end ;
41408: GO 41357
41410: POP
41411: POP
// end ; end ;
41412: GO 40368
41414: POP
41415: POP
// end ;
41416: GO 40322
41418: POP
41419: POP
// end ;
41420: LD_VAR 0 1
41424: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
41425: LD_INT 0
41427: PPUSH
41428: PPUSH
// if not mc_bases then
41429: LD_EXP 80
41433: NOT
41434: IFFALSE 41438
// exit ;
41436: GO 41521
// for i = 1 to mc_bases do
41438: LD_ADDR_VAR 0 2
41442: PUSH
41443: DOUBLE
41444: LD_INT 1
41446: DEC
41447: ST_TO_ADDR
41448: LD_EXP 80
41452: PUSH
41453: FOR_TO
41454: IFFALSE 41519
// if mc_mines [ i ] and mc_miners [ i ] then
41456: LD_EXP 93
41460: PUSH
41461: LD_VAR 0 2
41465: ARRAY
41466: IFFALSE 41480
41468: PUSH
41469: LD_EXP 94
41473: PUSH
41474: LD_VAR 0 2
41478: ARRAY
41479: AND
41480: IFFALSE 41517
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
41482: LD_EXP 94
41486: PUSH
41487: LD_VAR 0 2
41491: ARRAY
41492: PUSH
41493: LD_INT 1
41495: ARRAY
41496: PPUSH
41497: CALL_OW 255
41501: PPUSH
41502: LD_EXP 93
41506: PUSH
41507: LD_VAR 0 2
41511: ARRAY
41512: PPUSH
41513: CALL 56472 0 2
41517: GO 41453
41519: POP
41520: POP
// end ;
41521: LD_VAR 0 1
41525: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
41526: LD_INT 0
41528: PPUSH
41529: PPUSH
41530: PPUSH
41531: PPUSH
41532: PPUSH
41533: PPUSH
41534: PPUSH
41535: PPUSH
// if not mc_bases or not mc_parking then
41536: LD_EXP 80
41540: NOT
41541: IFTRUE 41550
41543: PUSH
41544: LD_EXP 104
41548: NOT
41549: OR
41550: IFFALSE 41554
// exit ;
41552: GO 42298
// for i = 1 to mc_bases do
41554: LD_ADDR_VAR 0 2
41558: PUSH
41559: DOUBLE
41560: LD_INT 1
41562: DEC
41563: ST_TO_ADDR
41564: LD_EXP 80
41568: PUSH
41569: FOR_TO
41570: IFFALSE 42296
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
41572: LD_EXP 80
41576: PUSH
41577: LD_VAR 0 2
41581: ARRAY
41582: NOT
41583: IFTRUE 41598
41585: PUSH
41586: LD_EXP 104
41590: PUSH
41591: LD_VAR 0 2
41595: ARRAY
41596: NOT
41597: OR
41598: IFFALSE 41602
// continue ;
41600: GO 41569
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
41602: LD_ADDR_VAR 0 5
41606: PUSH
41607: LD_EXP 80
41611: PUSH
41612: LD_VAR 0 2
41616: ARRAY
41617: PUSH
41618: LD_INT 1
41620: ARRAY
41621: PPUSH
41622: CALL_OW 255
41626: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
41627: LD_ADDR_VAR 0 6
41631: PUSH
41632: LD_EXP 80
41636: PUSH
41637: LD_VAR 0 2
41641: ARRAY
41642: PPUSH
41643: LD_INT 30
41645: PUSH
41646: LD_INT 3
41648: PUSH
41649: EMPTY
41650: LIST
41651: LIST
41652: PPUSH
41653: CALL_OW 72
41657: ST_TO_ADDR
// if not fac then
41658: LD_VAR 0 6
41662: NOT
41663: IFFALSE 41714
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41665: LD_ADDR_VAR 0 6
41669: PUSH
41670: LD_EXP 80
41674: PUSH
41675: LD_VAR 0 2
41679: ARRAY
41680: PPUSH
41681: LD_INT 2
41683: PUSH
41684: LD_INT 30
41686: PUSH
41687: LD_INT 0
41689: PUSH
41690: EMPTY
41691: LIST
41692: LIST
41693: PUSH
41694: LD_INT 30
41696: PUSH
41697: LD_INT 1
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: LIST
41708: PPUSH
41709: CALL_OW 72
41713: ST_TO_ADDR
// if not fac then
41714: LD_VAR 0 6
41718: NOT
41719: IFFALSE 41723
// continue ;
41721: GO 41569
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41723: LD_ADDR_VAR 0 7
41727: PUSH
41728: LD_EXP 104
41732: PUSH
41733: LD_VAR 0 2
41737: ARRAY
41738: PPUSH
41739: LD_INT 22
41741: PUSH
41742: LD_VAR 0 5
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: PUSH
41751: LD_INT 21
41753: PUSH
41754: LD_INT 2
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: PUSH
41761: LD_INT 3
41763: PUSH
41764: LD_INT 60
41766: PUSH
41767: EMPTY
41768: LIST
41769: PUSH
41770: EMPTY
41771: LIST
41772: LIST
41773: PUSH
41774: LD_INT 3
41776: PUSH
41777: LD_INT 24
41779: PUSH
41780: LD_INT 1000
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: EMPTY
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: PPUSH
41797: CALL_OW 70
41801: ST_TO_ADDR
// for j in fac do
41802: LD_ADDR_VAR 0 3
41806: PUSH
41807: LD_VAR 0 6
41811: PUSH
41812: FOR_IN
41813: IFFALSE 41908
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41815: LD_ADDR_VAR 0 7
41819: PUSH
41820: LD_VAR 0 7
41824: PUSH
41825: LD_INT 22
41827: PUSH
41828: LD_VAR 0 5
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PUSH
41837: LD_INT 91
41839: PUSH
41840: LD_VAR 0 3
41844: PUSH
41845: LD_INT 15
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: LIST
41852: PUSH
41853: LD_INT 21
41855: PUSH
41856: LD_INT 2
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: LD_INT 3
41865: PUSH
41866: LD_INT 60
41868: PUSH
41869: EMPTY
41870: LIST
41871: PUSH
41872: EMPTY
41873: LIST
41874: LIST
41875: PUSH
41876: LD_INT 3
41878: PUSH
41879: LD_INT 24
41881: PUSH
41882: LD_INT 1000
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: PPUSH
41900: CALL_OW 69
41904: UNION
41905: ST_TO_ADDR
41906: GO 41812
41908: POP
41909: POP
// if not vehs then
41910: LD_VAR 0 7
41914: NOT
41915: IFFALSE 41941
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41917: LD_ADDR_EXP 92
41921: PUSH
41922: LD_EXP 92
41926: PPUSH
41927: LD_VAR 0 2
41931: PPUSH
41932: EMPTY
41933: PPUSH
41934: CALL_OW 1
41938: ST_TO_ADDR
// continue ;
41939: GO 41569
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
41941: LD_ADDR_VAR 0 8
41945: PUSH
41946: LD_EXP 80
41950: PUSH
41951: LD_VAR 0 2
41955: ARRAY
41956: PPUSH
41957: LD_INT 30
41959: PUSH
41960: LD_INT 3
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: PPUSH
41967: CALL_OW 72
41971: ST_TO_ADDR
// if tmp then
41972: LD_VAR 0 8
41976: IFFALSE 42079
// begin for j in tmp do
41978: LD_ADDR_VAR 0 3
41982: PUSH
41983: LD_VAR 0 8
41987: PUSH
41988: FOR_IN
41989: IFFALSE 42077
// for k in UnitsInside ( j ) do
41991: LD_ADDR_VAR 0 4
41995: PUSH
41996: LD_VAR 0 3
42000: PPUSH
42001: CALL_OW 313
42005: PUSH
42006: FOR_IN
42007: IFFALSE 42073
// if k then
42009: LD_VAR 0 4
42013: IFFALSE 42071
// if not k in mc_repair_vehicle [ i ] then
42015: LD_VAR 0 4
42019: PUSH
42020: LD_EXP 92
42024: PUSH
42025: LD_VAR 0 2
42029: ARRAY
42030: IN
42031: NOT
42032: IFFALSE 42071
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
42034: LD_ADDR_EXP 92
42038: PUSH
42039: LD_EXP 92
42043: PPUSH
42044: LD_VAR 0 2
42048: PPUSH
42049: LD_EXP 92
42053: PUSH
42054: LD_VAR 0 2
42058: ARRAY
42059: PUSH
42060: LD_VAR 0 4
42064: UNION
42065: PPUSH
42066: CALL_OW 1
42070: ST_TO_ADDR
42071: GO 42006
42073: POP
42074: POP
42075: GO 41988
42077: POP
42078: POP
// end ; if not mc_repair_vehicle [ i ] then
42079: LD_EXP 92
42083: PUSH
42084: LD_VAR 0 2
42088: ARRAY
42089: NOT
42090: IFFALSE 42094
// continue ;
42092: GO 41569
// for j in mc_repair_vehicle [ i ] do
42094: LD_ADDR_VAR 0 3
42098: PUSH
42099: LD_EXP 92
42103: PUSH
42104: LD_VAR 0 2
42108: ARRAY
42109: PUSH
42110: FOR_IN
42111: IFFALSE 42292
// begin if GetClass ( j ) <> 3 then
42113: LD_VAR 0 3
42117: PPUSH
42118: CALL_OW 257
42122: PUSH
42123: LD_INT 3
42125: NONEQUAL
42126: IFFALSE 42167
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
42128: LD_ADDR_EXP 92
42132: PUSH
42133: LD_EXP 92
42137: PPUSH
42138: LD_VAR 0 2
42142: PPUSH
42143: LD_EXP 92
42147: PUSH
42148: LD_VAR 0 2
42152: ARRAY
42153: PUSH
42154: LD_VAR 0 3
42158: DIFF
42159: PPUSH
42160: CALL_OW 1
42164: ST_TO_ADDR
// continue ;
42165: GO 42110
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
42167: LD_VAR 0 3
42171: PPUSH
42172: CALL_OW 311
42176: NOT
42177: IFFALSE 42202
42179: PUSH
42180: LD_VAR 0 3
42184: PUSH
42185: LD_EXP 83
42189: PUSH
42190: LD_VAR 0 2
42194: ARRAY
42195: PUSH
42196: LD_INT 1
42198: ARRAY
42199: IN
42200: NOT
42201: AND
42202: IFFALSE 42227
42204: PUSH
42205: LD_VAR 0 3
42209: PUSH
42210: LD_EXP 83
42214: PUSH
42215: LD_VAR 0 2
42219: ARRAY
42220: PUSH
42221: LD_INT 2
42223: ARRAY
42224: IN
42225: NOT
42226: AND
42227: IFFALSE 42290
// begin if IsInUnit ( j ) then
42229: LD_VAR 0 3
42233: PPUSH
42234: CALL_OW 310
42238: IFFALSE 42251
// ComExitBuilding ( j ) else
42240: LD_VAR 0 3
42244: PPUSH
42245: CALL_OW 122
42249: GO 42290
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
42251: LD_VAR 0 3
42255: PPUSH
42256: LD_VAR 0 7
42260: PUSH
42261: LD_INT 1
42263: ARRAY
42264: PPUSH
42265: CALL 94684 0 2
42269: NOT
42270: IFFALSE 42290
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
42272: LD_VAR 0 3
42276: PPUSH
42277: LD_VAR 0 7
42281: PUSH
42282: LD_INT 1
42284: ARRAY
42285: PPUSH
42286: CALL_OW 129
// end ; end ;
42290: GO 42110
42292: POP
42293: POP
// end ;
42294: GO 41569
42296: POP
42297: POP
// end ;
42298: LD_VAR 0 1
42302: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
42303: LD_INT 0
42305: PPUSH
42306: PPUSH
42307: PPUSH
42308: PPUSH
42309: PPUSH
42310: PPUSH
42311: PPUSH
42312: PPUSH
42313: PPUSH
42314: PPUSH
42315: PPUSH
// if not mc_bases then
42316: LD_EXP 80
42320: NOT
42321: IFFALSE 42325
// exit ;
42323: GO 43143
// for i = 1 to mc_bases do
42325: LD_ADDR_VAR 0 2
42329: PUSH
42330: DOUBLE
42331: LD_INT 1
42333: DEC
42334: ST_TO_ADDR
42335: LD_EXP 80
42339: PUSH
42340: FOR_TO
42341: IFFALSE 43141
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
42343: LD_EXP 108
42347: PUSH
42348: LD_VAR 0 2
42352: ARRAY
42353: NOT
42354: IFTRUE 42372
42356: PUSH
42357: LD_EXP 83
42361: PUSH
42362: LD_VAR 0 2
42366: ARRAY
42367: PUSH
42368: LD_INT 1
42370: ARRAY
42371: OR
42372: IFTRUE 42390
42374: PUSH
42375: LD_EXP 83
42379: PUSH
42380: LD_VAR 0 2
42384: ARRAY
42385: PUSH
42386: LD_INT 2
42388: ARRAY
42389: OR
42390: IFTRUE 42413
42392: PUSH
42393: LD_EXP 106
42397: PUSH
42398: LD_VAR 0 2
42402: ARRAY
42403: PPUSH
42404: LD_INT 1
42406: PPUSH
42407: CALL_OW 325
42411: NOT
42412: OR
42413: IFTRUE 42427
42415: PUSH
42416: LD_EXP 103
42420: PUSH
42421: LD_VAR 0 2
42425: ARRAY
42426: OR
42427: IFFALSE 42431
// continue ;
42429: GO 42340
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
42431: LD_ADDR_VAR 0 8
42435: PUSH
42436: LD_EXP 80
42440: PUSH
42441: LD_VAR 0 2
42445: ARRAY
42446: PPUSH
42447: LD_INT 25
42449: PUSH
42450: LD_INT 4
42452: PUSH
42453: EMPTY
42454: LIST
42455: LIST
42456: PUSH
42457: LD_INT 50
42459: PUSH
42460: EMPTY
42461: LIST
42462: PUSH
42463: LD_INT 3
42465: PUSH
42466: LD_INT 60
42468: PUSH
42469: EMPTY
42470: LIST
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: LIST
42480: PPUSH
42481: CALL_OW 72
42485: PUSH
42486: LD_EXP 84
42490: PUSH
42491: LD_VAR 0 2
42495: ARRAY
42496: DIFF
42497: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42498: LD_ADDR_VAR 0 9
42502: PUSH
42503: LD_EXP 80
42507: PUSH
42508: LD_VAR 0 2
42512: ARRAY
42513: PPUSH
42514: LD_INT 2
42516: PUSH
42517: LD_INT 30
42519: PUSH
42520: LD_INT 0
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: PUSH
42527: LD_INT 30
42529: PUSH
42530: LD_INT 1
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: LIST
42541: PPUSH
42542: CALL_OW 72
42546: ST_TO_ADDR
// if not tmp or not dep then
42547: LD_VAR 0 8
42551: NOT
42552: IFTRUE 42561
42554: PUSH
42555: LD_VAR 0 9
42559: NOT
42560: OR
42561: IFFALSE 42565
// continue ;
42563: GO 42340
// side := GetSide ( tmp [ 1 ] ) ;
42565: LD_ADDR_VAR 0 11
42569: PUSH
42570: LD_VAR 0 8
42574: PUSH
42575: LD_INT 1
42577: ARRAY
42578: PPUSH
42579: CALL_OW 255
42583: ST_TO_ADDR
// dep := dep [ 1 ] ;
42584: LD_ADDR_VAR 0 9
42588: PUSH
42589: LD_VAR 0 9
42593: PUSH
42594: LD_INT 1
42596: ARRAY
42597: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
42598: LD_ADDR_VAR 0 7
42602: PUSH
42603: LD_EXP 108
42607: PUSH
42608: LD_VAR 0 2
42612: ARRAY
42613: PPUSH
42614: LD_INT 22
42616: PUSH
42617: LD_INT 0
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: PUSH
42624: LD_INT 25
42626: PUSH
42627: LD_INT 12
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PPUSH
42638: CALL_OW 70
42642: PUSH
42643: LD_INT 22
42645: PUSH
42646: LD_INT 0
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: LD_INT 25
42655: PUSH
42656: LD_INT 12
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: PUSH
42663: LD_INT 91
42665: PUSH
42666: LD_VAR 0 9
42670: PUSH
42671: LD_INT 20
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: LIST
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: LIST
42683: PPUSH
42684: CALL_OW 69
42688: UNION
42689: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
42690: LD_ADDR_VAR 0 10
42694: PUSH
42695: LD_EXP 108
42699: PUSH
42700: LD_VAR 0 2
42704: ARRAY
42705: PPUSH
42706: LD_INT 81
42708: PUSH
42709: LD_VAR 0 11
42713: PUSH
42714: EMPTY
42715: LIST
42716: LIST
42717: PPUSH
42718: CALL_OW 70
42722: ST_TO_ADDR
// if not apes or danger_at_area then
42723: LD_VAR 0 7
42727: NOT
42728: IFTRUE 42736
42730: PUSH
42731: LD_VAR 0 10
42735: OR
42736: IFFALSE 42786
// begin if mc_taming [ i ] then
42738: LD_EXP 111
42742: PUSH
42743: LD_VAR 0 2
42747: ARRAY
42748: IFFALSE 42784
// begin MC_Reset ( i , 121 ) ;
42750: LD_VAR 0 2
42754: PPUSH
42755: LD_INT 121
42757: PPUSH
42758: CALL 27518 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42762: LD_ADDR_EXP 111
42766: PUSH
42767: LD_EXP 111
42771: PPUSH
42772: LD_VAR 0 2
42776: PPUSH
42777: EMPTY
42778: PPUSH
42779: CALL_OW 1
42783: ST_TO_ADDR
// end ; continue ;
42784: GO 42340
// end ; for j in tmp do
42786: LD_ADDR_VAR 0 3
42790: PUSH
42791: LD_VAR 0 8
42795: PUSH
42796: FOR_IN
42797: IFFALSE 43137
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
42799: LD_VAR 0 3
42803: PUSH
42804: LD_EXP 111
42808: PUSH
42809: LD_VAR 0 2
42813: ARRAY
42814: IN
42815: NOT
42816: IFFALSE 42834
42818: PUSH
42819: LD_EXP 111
42823: PUSH
42824: LD_VAR 0 2
42828: ARRAY
42829: PUSH
42830: LD_INT 3
42832: LESS
42833: AND
42834: IFFALSE 42892
// begin SetTag ( j , 121 ) ;
42836: LD_VAR 0 3
42840: PPUSH
42841: LD_INT 121
42843: PPUSH
42844: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
42848: LD_ADDR_EXP 111
42852: PUSH
42853: LD_EXP 111
42857: PPUSH
42858: LD_VAR 0 2
42862: PUSH
42863: LD_EXP 111
42867: PUSH
42868: LD_VAR 0 2
42872: ARRAY
42873: PUSH
42874: LD_INT 1
42876: PLUS
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: PPUSH
42882: LD_VAR 0 3
42886: PPUSH
42887: CALL 59553 0 3
42891: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
42892: LD_VAR 0 3
42896: PUSH
42897: LD_EXP 111
42901: PUSH
42902: LD_VAR 0 2
42906: ARRAY
42907: IN
42908: IFFALSE 43135
// begin if GetClass ( j ) <> 4 then
42910: LD_VAR 0 3
42914: PPUSH
42915: CALL_OW 257
42919: PUSH
42920: LD_INT 4
42922: NONEQUAL
42923: IFFALSE 42976
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
42925: LD_ADDR_EXP 111
42929: PUSH
42930: LD_EXP 111
42934: PPUSH
42935: LD_VAR 0 2
42939: PPUSH
42940: LD_EXP 111
42944: PUSH
42945: LD_VAR 0 2
42949: ARRAY
42950: PUSH
42951: LD_VAR 0 3
42955: DIFF
42956: PPUSH
42957: CALL_OW 1
42961: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42962: LD_VAR 0 3
42966: PPUSH
42967: LD_INT 0
42969: PPUSH
42970: CALL_OW 109
// continue ;
42974: GO 42796
// end ; if IsInUnit ( j ) then
42976: LD_VAR 0 3
42980: PPUSH
42981: CALL_OW 310
42985: IFFALSE 42996
// ComExitBuilding ( j ) ;
42987: LD_VAR 0 3
42991: PPUSH
42992: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
42996: LD_ADDR_VAR 0 6
43000: PUSH
43001: LD_VAR 0 7
43005: PPUSH
43006: LD_VAR 0 3
43010: PPUSH
43011: CALL_OW 74
43015: ST_TO_ADDR
// if not ape then
43016: LD_VAR 0 6
43020: NOT
43021: IFFALSE 43025
// break ;
43023: GO 43137
// x := GetX ( ape ) ;
43025: LD_ADDR_VAR 0 4
43029: PUSH
43030: LD_VAR 0 6
43034: PPUSH
43035: CALL_OW 250
43039: ST_TO_ADDR
// y := GetY ( ape ) ;
43040: LD_ADDR_VAR 0 5
43044: PUSH
43045: LD_VAR 0 6
43049: PPUSH
43050: CALL_OW 251
43054: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
43055: LD_VAR 0 4
43059: PPUSH
43060: LD_VAR 0 5
43064: PPUSH
43065: CALL_OW 488
43069: NOT
43070: IFTRUE 43100
43072: PUSH
43073: LD_VAR 0 11
43077: PPUSH
43078: LD_VAR 0 4
43082: PPUSH
43083: LD_VAR 0 5
43087: PPUSH
43088: LD_INT 20
43090: PPUSH
43091: CALL 60823 0 4
43095: PUSH
43096: LD_INT 4
43098: ARRAY
43099: OR
43100: IFFALSE 43104
// break ;
43102: GO 43137
// if not HasTask ( j ) then
43104: LD_VAR 0 3
43108: PPUSH
43109: CALL_OW 314
43113: NOT
43114: IFFALSE 43135
// ComTameXY ( j , x , y ) ;
43116: LD_VAR 0 3
43120: PPUSH
43121: LD_VAR 0 4
43125: PPUSH
43126: LD_VAR 0 5
43130: PPUSH
43131: CALL_OW 131
// end ; end ;
43135: GO 42796
43137: POP
43138: POP
// end ;
43139: GO 42340
43141: POP
43142: POP
// end ;
43143: LD_VAR 0 1
43147: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
43148: LD_INT 0
43150: PPUSH
43151: PPUSH
43152: PPUSH
43153: PPUSH
43154: PPUSH
43155: PPUSH
43156: PPUSH
43157: PPUSH
// if not mc_bases then
43158: LD_EXP 80
43162: NOT
43163: IFFALSE 43167
// exit ;
43165: GO 43799
// for i = 1 to mc_bases do
43167: LD_ADDR_VAR 0 2
43171: PUSH
43172: DOUBLE
43173: LD_INT 1
43175: DEC
43176: ST_TO_ADDR
43177: LD_EXP 80
43181: PUSH
43182: FOR_TO
43183: IFFALSE 43797
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
43185: LD_EXP 109
43189: PUSH
43190: LD_VAR 0 2
43194: ARRAY
43195: NOT
43196: IFTRUE 43226
43198: PUSH
43199: LD_EXP 109
43203: PUSH
43204: LD_VAR 0 2
43208: ARRAY
43209: PPUSH
43210: LD_INT 25
43212: PUSH
43213: LD_INT 12
43215: PUSH
43216: EMPTY
43217: LIST
43218: LIST
43219: PPUSH
43220: CALL_OW 72
43224: NOT
43225: OR
43226: IFFALSE 43230
// continue ;
43228: GO 43182
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
43230: LD_ADDR_VAR 0 5
43234: PUSH
43235: LD_EXP 109
43239: PUSH
43240: LD_VAR 0 2
43244: ARRAY
43245: PUSH
43246: LD_INT 1
43248: ARRAY
43249: PPUSH
43250: CALL_OW 255
43254: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
43255: LD_VAR 0 5
43259: PPUSH
43260: LD_INT 2
43262: PPUSH
43263: CALL_OW 325
43267: IFFALSE 43520
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
43269: LD_ADDR_VAR 0 4
43273: PUSH
43274: LD_EXP 109
43278: PUSH
43279: LD_VAR 0 2
43283: ARRAY
43284: PPUSH
43285: LD_INT 25
43287: PUSH
43288: LD_INT 16
43290: PUSH
43291: EMPTY
43292: LIST
43293: LIST
43294: PPUSH
43295: CALL_OW 72
43299: ST_TO_ADDR
// if tmp < 6 then
43300: LD_VAR 0 4
43304: PUSH
43305: LD_INT 6
43307: LESS
43308: IFFALSE 43520
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43310: LD_ADDR_VAR 0 6
43314: PUSH
43315: LD_EXP 80
43319: PUSH
43320: LD_VAR 0 2
43324: ARRAY
43325: PPUSH
43326: LD_INT 2
43328: PUSH
43329: LD_INT 30
43331: PUSH
43332: LD_INT 0
43334: PUSH
43335: EMPTY
43336: LIST
43337: LIST
43338: PUSH
43339: LD_INT 30
43341: PUSH
43342: LD_INT 1
43344: PUSH
43345: EMPTY
43346: LIST
43347: LIST
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: LIST
43353: PPUSH
43354: CALL_OW 72
43358: ST_TO_ADDR
// if depot then
43359: LD_VAR 0 6
43363: IFFALSE 43520
// begin selected := 0 ;
43365: LD_ADDR_VAR 0 7
43369: PUSH
43370: LD_INT 0
43372: ST_TO_ADDR
// for j in depot do
43373: LD_ADDR_VAR 0 3
43377: PUSH
43378: LD_VAR 0 6
43382: PUSH
43383: FOR_IN
43384: IFFALSE 43415
// begin if UnitsInside ( j ) < 6 then
43386: LD_VAR 0 3
43390: PPUSH
43391: CALL_OW 313
43395: PUSH
43396: LD_INT 6
43398: LESS
43399: IFFALSE 43413
// begin selected := j ;
43401: LD_ADDR_VAR 0 7
43405: PUSH
43406: LD_VAR 0 3
43410: ST_TO_ADDR
// break ;
43411: GO 43415
// end ; end ;
43413: GO 43383
43415: POP
43416: POP
// if selected then
43417: LD_VAR 0 7
43421: IFFALSE 43520
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
43423: LD_ADDR_VAR 0 3
43427: PUSH
43428: LD_EXP 109
43432: PUSH
43433: LD_VAR 0 2
43437: ARRAY
43438: PPUSH
43439: LD_INT 25
43441: PUSH
43442: LD_INT 12
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PPUSH
43449: CALL_OW 72
43453: PUSH
43454: FOR_IN
43455: IFFALSE 43518
// if not HasTask ( j ) then
43457: LD_VAR 0 3
43461: PPUSH
43462: CALL_OW 314
43466: NOT
43467: IFFALSE 43516
// begin if not IsInUnit ( j ) then
43469: LD_VAR 0 3
43473: PPUSH
43474: CALL_OW 310
43478: NOT
43479: IFFALSE 43495
// ComEnterUnit ( j , selected ) ;
43481: LD_VAR 0 3
43485: PPUSH
43486: LD_VAR 0 7
43490: PPUSH
43491: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
43495: LD_VAR 0 3
43499: PPUSH
43500: LD_INT 16
43502: PPUSH
43503: CALL_OW 183
// AddComExitBuilding ( j ) ;
43507: LD_VAR 0 3
43511: PPUSH
43512: CALL_OW 182
// end ;
43516: GO 43454
43518: POP
43519: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
43520: LD_VAR 0 5
43524: PPUSH
43525: LD_INT 11
43527: PPUSH
43528: CALL_OW 325
43532: IFFALSE 43795
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
43534: LD_ADDR_VAR 0 4
43538: PUSH
43539: LD_EXP 109
43543: PUSH
43544: LD_VAR 0 2
43548: ARRAY
43549: PPUSH
43550: LD_INT 25
43552: PUSH
43553: LD_INT 16
43555: PUSH
43556: EMPTY
43557: LIST
43558: LIST
43559: PPUSH
43560: CALL_OW 72
43564: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
43565: LD_VAR 0 4
43569: PUSH
43570: LD_INT 6
43572: GREATEREQUAL
43573: IFTRUE 43590
43575: PUSH
43576: LD_VAR 0 5
43580: PPUSH
43581: LD_INT 2
43583: PPUSH
43584: CALL_OW 325
43588: NOT
43589: OR
43590: IFFALSE 43795
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43592: LD_ADDR_VAR 0 8
43596: PUSH
43597: LD_EXP 80
43601: PUSH
43602: LD_VAR 0 2
43606: ARRAY
43607: PPUSH
43608: LD_INT 2
43610: PUSH
43611: LD_INT 30
43613: PUSH
43614: LD_INT 4
43616: PUSH
43617: EMPTY
43618: LIST
43619: LIST
43620: PUSH
43621: LD_INT 30
43623: PUSH
43624: LD_INT 5
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: LIST
43635: PPUSH
43636: CALL_OW 72
43640: ST_TO_ADDR
// if barracks then
43641: LD_VAR 0 8
43645: IFFALSE 43795
// begin selected := 0 ;
43647: LD_ADDR_VAR 0 7
43651: PUSH
43652: LD_INT 0
43654: ST_TO_ADDR
// for j in barracks do
43655: LD_ADDR_VAR 0 3
43659: PUSH
43660: LD_VAR 0 8
43664: PUSH
43665: FOR_IN
43666: IFFALSE 43697
// begin if UnitsInside ( j ) < 6 then
43668: LD_VAR 0 3
43672: PPUSH
43673: CALL_OW 313
43677: PUSH
43678: LD_INT 6
43680: LESS
43681: IFFALSE 43695
// begin selected := j ;
43683: LD_ADDR_VAR 0 7
43687: PUSH
43688: LD_VAR 0 3
43692: ST_TO_ADDR
// break ;
43693: GO 43697
// end ; end ;
43695: GO 43665
43697: POP
43698: POP
// if selected then
43699: LD_VAR 0 7
43703: IFFALSE 43795
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
43705: LD_ADDR_VAR 0 3
43709: PUSH
43710: LD_EXP 109
43714: PUSH
43715: LD_VAR 0 2
43719: ARRAY
43720: PPUSH
43721: LD_INT 25
43723: PUSH
43724: LD_INT 12
43726: PUSH
43727: EMPTY
43728: LIST
43729: LIST
43730: PPUSH
43731: CALL_OW 72
43735: PUSH
43736: FOR_IN
43737: IFFALSE 43793
// if not IsInUnit ( j ) and not HasTask ( j ) then
43739: LD_VAR 0 3
43743: PPUSH
43744: CALL_OW 310
43748: NOT
43749: IFFALSE 43763
43751: PUSH
43752: LD_VAR 0 3
43756: PPUSH
43757: CALL_OW 314
43761: NOT
43762: AND
43763: IFFALSE 43791
// begin ComEnterUnit ( j , selected ) ;
43765: LD_VAR 0 3
43769: PPUSH
43770: LD_VAR 0 7
43774: PPUSH
43775: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
43779: LD_VAR 0 3
43783: PPUSH
43784: LD_INT 15
43786: PPUSH
43787: CALL_OW 183
// end ;
43791: GO 43736
43793: POP
43794: POP
// end ; end ; end ; end ; end ;
43795: GO 43182
43797: POP
43798: POP
// end ;
43799: LD_VAR 0 1
43803: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
43804: LD_INT 0
43806: PPUSH
43807: PPUSH
43808: PPUSH
43809: PPUSH
// if not mc_bases then
43810: LD_EXP 80
43814: NOT
43815: IFFALSE 43819
// exit ;
43817: GO 44001
// for i = 1 to mc_bases do
43819: LD_ADDR_VAR 0 2
43823: PUSH
43824: DOUBLE
43825: LD_INT 1
43827: DEC
43828: ST_TO_ADDR
43829: LD_EXP 80
43833: PUSH
43834: FOR_TO
43835: IFFALSE 43999
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
43837: LD_ADDR_VAR 0 4
43841: PUSH
43842: LD_EXP 80
43846: PUSH
43847: LD_VAR 0 2
43851: ARRAY
43852: PPUSH
43853: LD_INT 25
43855: PUSH
43856: LD_INT 9
43858: PUSH
43859: EMPTY
43860: LIST
43861: LIST
43862: PPUSH
43863: CALL_OW 72
43867: ST_TO_ADDR
// if not tmp then
43868: LD_VAR 0 4
43872: NOT
43873: IFFALSE 43877
// continue ;
43875: GO 43834
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
43877: LD_EXP 106
43881: PUSH
43882: LD_VAR 0 2
43886: ARRAY
43887: PPUSH
43888: LD_INT 29
43890: PPUSH
43891: CALL_OW 325
43895: NOT
43896: IFFALSE 43919
43898: PUSH
43899: LD_EXP 106
43903: PUSH
43904: LD_VAR 0 2
43908: ARRAY
43909: PPUSH
43910: LD_INT 28
43912: PPUSH
43913: CALL_OW 325
43917: NOT
43918: AND
43919: IFFALSE 43923
// continue ;
43921: GO 43834
// for j in tmp do
43923: LD_ADDR_VAR 0 3
43927: PUSH
43928: LD_VAR 0 4
43932: PUSH
43933: FOR_IN
43934: IFFALSE 43995
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
43936: LD_VAR 0 3
43940: PUSH
43941: LD_EXP 83
43945: PUSH
43946: LD_VAR 0 2
43950: ARRAY
43951: PUSH
43952: LD_INT 1
43954: ARRAY
43955: IN
43956: NOT
43957: IFFALSE 43982
43959: PUSH
43960: LD_VAR 0 3
43964: PUSH
43965: LD_EXP 83
43969: PUSH
43970: LD_VAR 0 2
43974: ARRAY
43975: PUSH
43976: LD_INT 2
43978: ARRAY
43979: IN
43980: NOT
43981: AND
43982: IFFALSE 43993
// ComSpaceTimeShoot ( j ) ;
43984: LD_VAR 0 3
43988: PPUSH
43989: CALL 55470 0 1
43993: GO 43933
43995: POP
43996: POP
// end ;
43997: GO 43834
43999: POP
44000: POP
// end ;
44001: LD_VAR 0 1
44005: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
44006: LD_INT 0
44008: PPUSH
44009: PPUSH
44010: PPUSH
44011: PPUSH
44012: PPUSH
44013: PPUSH
44014: PPUSH
44015: PPUSH
44016: PPUSH
// if not mc_bases then
44017: LD_EXP 80
44021: NOT
44022: IFFALSE 44026
// exit ;
44024: GO 44658
// for i = 1 to mc_bases do
44026: LD_ADDR_VAR 0 2
44030: PUSH
44031: DOUBLE
44032: LD_INT 1
44034: DEC
44035: ST_TO_ADDR
44036: LD_EXP 80
44040: PUSH
44041: FOR_TO
44042: IFFALSE 44656
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
44044: LD_EXP 115
44048: PUSH
44049: LD_VAR 0 2
44053: ARRAY
44054: NOT
44055: IFTRUE 44081
44057: PUSH
44058: LD_INT 38
44060: PPUSH
44061: LD_EXP 106
44065: PUSH
44066: LD_VAR 0 2
44070: ARRAY
44071: PPUSH
44072: CALL_OW 321
44076: PUSH
44077: LD_INT 2
44079: NONEQUAL
44080: OR
44081: IFFALSE 44085
// continue ;
44083: GO 44041
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
44085: LD_ADDR_VAR 0 8
44089: PUSH
44090: LD_EXP 80
44094: PUSH
44095: LD_VAR 0 2
44099: ARRAY
44100: PPUSH
44101: LD_INT 30
44103: PUSH
44104: LD_INT 34
44106: PUSH
44107: EMPTY
44108: LIST
44109: LIST
44110: PPUSH
44111: CALL_OW 72
44115: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
44116: LD_ADDR_VAR 0 9
44120: PUSH
44121: LD_EXP 80
44125: PUSH
44126: LD_VAR 0 2
44130: ARRAY
44131: PPUSH
44132: LD_INT 25
44134: PUSH
44135: LD_INT 4
44137: PUSH
44138: EMPTY
44139: LIST
44140: LIST
44141: PPUSH
44142: CALL_OW 72
44146: PPUSH
44147: LD_INT 0
44149: PPUSH
44150: CALL 90146 0 2
44154: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
44155: LD_VAR 0 9
44159: NOT
44160: IFTRUE 44169
44162: PUSH
44163: LD_VAR 0 8
44167: NOT
44168: OR
44169: IFTRUE 44191
44171: PUSH
44172: LD_EXP 80
44176: PUSH
44177: LD_VAR 0 2
44181: ARRAY
44182: PPUSH
44183: LD_INT 124
44185: PPUSH
44186: CALL 90146 0 2
44190: OR
44191: IFFALSE 44195
// continue ;
44193: GO 44041
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
44195: LD_EXP 116
44199: PUSH
44200: LD_VAR 0 2
44204: ARRAY
44205: PUSH
44206: LD_EXP 115
44210: PUSH
44211: LD_VAR 0 2
44215: ARRAY
44216: LESS
44217: IFFALSE 44237
44219: PUSH
44220: LD_EXP 116
44224: PUSH
44225: LD_VAR 0 2
44229: ARRAY
44230: PUSH
44231: LD_VAR 0 8
44235: LESS
44236: AND
44237: IFFALSE 44654
// begin tmp := sci [ 1 ] ;
44239: LD_ADDR_VAR 0 7
44243: PUSH
44244: LD_VAR 0 9
44248: PUSH
44249: LD_INT 1
44251: ARRAY
44252: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
44253: LD_VAR 0 7
44257: PPUSH
44258: LD_INT 124
44260: PPUSH
44261: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
44265: LD_ADDR_VAR 0 3
44269: PUSH
44270: DOUBLE
44271: LD_EXP 115
44275: PUSH
44276: LD_VAR 0 2
44280: ARRAY
44281: INC
44282: ST_TO_ADDR
44283: LD_EXP 115
44287: PUSH
44288: LD_VAR 0 2
44292: ARRAY
44293: PUSH
44294: FOR_DOWNTO
44295: IFFALSE 44640
// begin if IsInUnit ( tmp ) then
44297: LD_VAR 0 7
44301: PPUSH
44302: CALL_OW 310
44306: IFFALSE 44317
// ComExitBuilding ( tmp ) ;
44308: LD_VAR 0 7
44312: PPUSH
44313: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
44317: LD_INT 35
44319: PPUSH
44320: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
44324: LD_VAR 0 7
44328: PPUSH
44329: CALL_OW 310
44333: NOT
44334: IFFALSE 44348
44336: PUSH
44337: LD_VAR 0 7
44341: PPUSH
44342: CALL_OW 314
44346: NOT
44347: AND
44348: IFFALSE 44317
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
44350: LD_ADDR_VAR 0 6
44354: PUSH
44355: LD_VAR 0 7
44359: PPUSH
44360: CALL_OW 250
44364: PUSH
44365: LD_VAR 0 7
44369: PPUSH
44370: CALL_OW 251
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
44379: LD_INT 35
44381: PPUSH
44382: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
44386: LD_ADDR_VAR 0 4
44390: PUSH
44391: LD_EXP 115
44395: PUSH
44396: LD_VAR 0 2
44400: ARRAY
44401: PUSH
44402: LD_VAR 0 3
44406: ARRAY
44407: PUSH
44408: LD_INT 1
44410: ARRAY
44411: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
44412: LD_ADDR_VAR 0 5
44416: PUSH
44417: LD_EXP 115
44421: PUSH
44422: LD_VAR 0 2
44426: ARRAY
44427: PUSH
44428: LD_VAR 0 3
44432: ARRAY
44433: PUSH
44434: LD_INT 2
44436: ARRAY
44437: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
44438: LD_VAR 0 7
44442: PPUSH
44443: LD_INT 10
44445: PPUSH
44446: CALL 62532 0 2
44450: PUSH
44451: LD_INT 4
44453: ARRAY
44454: IFFALSE 44492
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
44456: LD_VAR 0 7
44460: PPUSH
44461: LD_VAR 0 6
44465: PUSH
44466: LD_INT 1
44468: ARRAY
44469: PPUSH
44470: LD_VAR 0 6
44474: PUSH
44475: LD_INT 2
44477: ARRAY
44478: PPUSH
44479: CALL_OW 111
// wait ( 0 0$10 ) ;
44483: LD_INT 350
44485: PPUSH
44486: CALL_OW 67
// end else
44490: GO 44518
// begin ComMoveXY ( tmp , x , y ) ;
44492: LD_VAR 0 7
44496: PPUSH
44497: LD_VAR 0 4
44501: PPUSH
44502: LD_VAR 0 5
44506: PPUSH
44507: CALL_OW 111
// wait ( 0 0$3 ) ;
44511: LD_INT 105
44513: PPUSH
44514: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
44518: LD_VAR 0 7
44522: PPUSH
44523: LD_VAR 0 4
44527: PPUSH
44528: LD_VAR 0 5
44532: PPUSH
44533: CALL_OW 307
44537: IFFALSE 44379
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
44539: LD_VAR 0 7
44543: PPUSH
44544: LD_VAR 0 4
44548: PPUSH
44549: LD_VAR 0 5
44553: PPUSH
44554: LD_VAR 0 8
44558: PUSH
44559: LD_VAR 0 3
44563: ARRAY
44564: PPUSH
44565: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
44569: LD_INT 35
44571: PPUSH
44572: CALL_OW 67
// until not HasTask ( tmp ) ;
44576: LD_VAR 0 7
44580: PPUSH
44581: CALL_OW 314
44585: NOT
44586: IFFALSE 44569
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
44588: LD_ADDR_EXP 116
44592: PUSH
44593: LD_EXP 116
44597: PPUSH
44598: LD_VAR 0 2
44602: PUSH
44603: LD_EXP 116
44607: PUSH
44608: LD_VAR 0 2
44612: ARRAY
44613: PUSH
44614: LD_INT 1
44616: PLUS
44617: PUSH
44618: EMPTY
44619: LIST
44620: LIST
44621: PPUSH
44622: LD_VAR 0 8
44626: PUSH
44627: LD_VAR 0 3
44631: ARRAY
44632: PPUSH
44633: CALL 59553 0 3
44637: ST_TO_ADDR
// end ;
44638: GO 44294
44640: POP
44641: POP
// MC_Reset ( i , 124 ) ;
44642: LD_VAR 0 2
44646: PPUSH
44647: LD_INT 124
44649: PPUSH
44650: CALL 27518 0 2
// end ; end ;
44654: GO 44041
44656: POP
44657: POP
// end ;
44658: LD_VAR 0 1
44662: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
44663: LD_INT 0
44665: PPUSH
44666: PPUSH
44667: PPUSH
// if not mc_bases then
44668: LD_EXP 80
44672: NOT
44673: IFFALSE 44677
// exit ;
44675: GO 45291
// for i = 1 to mc_bases do
44677: LD_ADDR_VAR 0 2
44681: PUSH
44682: DOUBLE
44683: LD_INT 1
44685: DEC
44686: ST_TO_ADDR
44687: LD_EXP 80
44691: PUSH
44692: FOR_TO
44693: IFFALSE 45289
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44695: LD_ADDR_VAR 0 3
44699: PUSH
44700: LD_EXP 80
44704: PUSH
44705: LD_VAR 0 2
44709: ARRAY
44710: PPUSH
44711: LD_INT 25
44713: PUSH
44714: LD_INT 4
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: PPUSH
44721: CALL_OW 72
44725: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44726: LD_VAR 0 3
44730: NOT
44731: IFTRUE 44746
44733: PUSH
44734: LD_EXP 117
44738: PUSH
44739: LD_VAR 0 2
44743: ARRAY
44744: NOT
44745: OR
44746: IFTRUE 44794
44748: PUSH
44749: LD_EXP 80
44753: PUSH
44754: LD_VAR 0 2
44758: ARRAY
44759: PPUSH
44760: LD_INT 2
44762: PUSH
44763: LD_INT 30
44765: PUSH
44766: LD_INT 0
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: PUSH
44773: LD_INT 30
44775: PUSH
44776: LD_INT 1
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PUSH
44783: EMPTY
44784: LIST
44785: LIST
44786: LIST
44787: PPUSH
44788: CALL_OW 72
44792: NOT
44793: OR
44794: IFFALSE 44844
// begin if mc_deposits_finder [ i ] then
44796: LD_EXP 118
44800: PUSH
44801: LD_VAR 0 2
44805: ARRAY
44806: IFFALSE 44842
// begin MC_Reset ( i , 125 ) ;
44808: LD_VAR 0 2
44812: PPUSH
44813: LD_INT 125
44815: PPUSH
44816: CALL 27518 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44820: LD_ADDR_EXP 118
44824: PUSH
44825: LD_EXP 118
44829: PPUSH
44830: LD_VAR 0 2
44834: PPUSH
44835: EMPTY
44836: PPUSH
44837: CALL_OW 1
44841: ST_TO_ADDR
// end ; continue ;
44842: GO 44692
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
44844: LD_EXP 117
44848: PUSH
44849: LD_VAR 0 2
44853: ARRAY
44854: PUSH
44855: LD_INT 1
44857: ARRAY
44858: PUSH
44859: LD_INT 3
44861: ARRAY
44862: PUSH
44863: LD_INT 1
44865: EQUAL
44866: IFFALSE 44892
44868: PUSH
44869: LD_INT 20
44871: PPUSH
44872: LD_EXP 106
44876: PUSH
44877: LD_VAR 0 2
44881: ARRAY
44882: PPUSH
44883: CALL_OW 321
44887: PUSH
44888: LD_INT 2
44890: NONEQUAL
44891: AND
44892: IFFALSE 44942
// begin if mc_deposits_finder [ i ] then
44894: LD_EXP 118
44898: PUSH
44899: LD_VAR 0 2
44903: ARRAY
44904: IFFALSE 44940
// begin MC_Reset ( i , 125 ) ;
44906: LD_VAR 0 2
44910: PPUSH
44911: LD_INT 125
44913: PPUSH
44914: CALL 27518 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44918: LD_ADDR_EXP 118
44922: PUSH
44923: LD_EXP 118
44927: PPUSH
44928: LD_VAR 0 2
44932: PPUSH
44933: EMPTY
44934: PPUSH
44935: CALL_OW 1
44939: ST_TO_ADDR
// end ; continue ;
44940: GO 44692
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
44942: LD_EXP 117
44946: PUSH
44947: LD_VAR 0 2
44951: ARRAY
44952: PUSH
44953: LD_INT 1
44955: ARRAY
44956: PUSH
44957: LD_INT 1
44959: ARRAY
44960: PPUSH
44961: LD_EXP 117
44965: PUSH
44966: LD_VAR 0 2
44970: ARRAY
44971: PUSH
44972: LD_INT 1
44974: ARRAY
44975: PUSH
44976: LD_INT 2
44978: ARRAY
44979: PPUSH
44980: LD_EXP 106
44984: PUSH
44985: LD_VAR 0 2
44989: ARRAY
44990: PPUSH
44991: CALL_OW 440
44995: IFFALSE 45038
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
44997: LD_ADDR_EXP 117
45001: PUSH
45002: LD_EXP 117
45006: PPUSH
45007: LD_VAR 0 2
45011: PPUSH
45012: LD_EXP 117
45016: PUSH
45017: LD_VAR 0 2
45021: ARRAY
45022: PPUSH
45023: LD_INT 1
45025: PPUSH
45026: CALL_OW 3
45030: PPUSH
45031: CALL_OW 1
45035: ST_TO_ADDR
45036: GO 45287
// begin if not mc_deposits_finder [ i ] then
45038: LD_EXP 118
45042: PUSH
45043: LD_VAR 0 2
45047: ARRAY
45048: NOT
45049: IFFALSE 45101
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
45051: LD_ADDR_EXP 118
45055: PUSH
45056: LD_EXP 118
45060: PPUSH
45061: LD_VAR 0 2
45065: PPUSH
45066: LD_VAR 0 3
45070: PUSH
45071: LD_INT 1
45073: ARRAY
45074: PUSH
45075: EMPTY
45076: LIST
45077: PPUSH
45078: CALL_OW 1
45082: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
45083: LD_VAR 0 3
45087: PUSH
45088: LD_INT 1
45090: ARRAY
45091: PPUSH
45092: LD_INT 125
45094: PPUSH
45095: CALL_OW 109
// end else
45099: GO 45287
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
45101: LD_EXP 118
45105: PUSH
45106: LD_VAR 0 2
45110: ARRAY
45111: PUSH
45112: LD_INT 1
45114: ARRAY
45115: PPUSH
45116: CALL_OW 310
45120: IFFALSE 45143
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
45122: LD_EXP 118
45126: PUSH
45127: LD_VAR 0 2
45131: ARRAY
45132: PUSH
45133: LD_INT 1
45135: ARRAY
45136: PPUSH
45137: CALL_OW 122
45141: GO 45287
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
45143: LD_EXP 118
45147: PUSH
45148: LD_VAR 0 2
45152: ARRAY
45153: PUSH
45154: LD_INT 1
45156: ARRAY
45157: PPUSH
45158: CALL_OW 314
45162: NOT
45163: IFFALSE 45228
45165: PUSH
45166: LD_EXP 118
45170: PUSH
45171: LD_VAR 0 2
45175: ARRAY
45176: PUSH
45177: LD_INT 1
45179: ARRAY
45180: PPUSH
45181: LD_EXP 117
45185: PUSH
45186: LD_VAR 0 2
45190: ARRAY
45191: PUSH
45192: LD_INT 1
45194: ARRAY
45195: PUSH
45196: LD_INT 1
45198: ARRAY
45199: PPUSH
45200: LD_EXP 117
45204: PUSH
45205: LD_VAR 0 2
45209: ARRAY
45210: PUSH
45211: LD_INT 1
45213: ARRAY
45214: PUSH
45215: LD_INT 2
45217: ARRAY
45218: PPUSH
45219: CALL_OW 297
45223: PUSH
45224: LD_INT 6
45226: GREATER
45227: AND
45228: IFFALSE 45287
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
45230: LD_EXP 118
45234: PUSH
45235: LD_VAR 0 2
45239: ARRAY
45240: PUSH
45241: LD_INT 1
45243: ARRAY
45244: PPUSH
45245: LD_EXP 117
45249: PUSH
45250: LD_VAR 0 2
45254: ARRAY
45255: PUSH
45256: LD_INT 1
45258: ARRAY
45259: PUSH
45260: LD_INT 1
45262: ARRAY
45263: PPUSH
45264: LD_EXP 117
45268: PUSH
45269: LD_VAR 0 2
45273: ARRAY
45274: PUSH
45275: LD_INT 1
45277: ARRAY
45278: PUSH
45279: LD_INT 2
45281: ARRAY
45282: PPUSH
45283: CALL_OW 111
// end ; end ; end ;
45287: GO 44692
45289: POP
45290: POP
// end ;
45291: LD_VAR 0 1
45295: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
45296: LD_INT 0
45298: PPUSH
45299: PPUSH
45300: PPUSH
45301: PPUSH
45302: PPUSH
45303: PPUSH
45304: PPUSH
45305: PPUSH
45306: PPUSH
45307: PPUSH
45308: PPUSH
// if not mc_bases then
45309: LD_EXP 80
45313: NOT
45314: IFFALSE 45318
// exit ;
45316: GO 46278
// for i = 1 to mc_bases do
45318: LD_ADDR_VAR 0 2
45322: PUSH
45323: DOUBLE
45324: LD_INT 1
45326: DEC
45327: ST_TO_ADDR
45328: LD_EXP 80
45332: PUSH
45333: FOR_TO
45334: IFFALSE 46276
// begin if not mc_bases [ i ] or mc_scan [ i ] then
45336: LD_EXP 80
45340: PUSH
45341: LD_VAR 0 2
45345: ARRAY
45346: NOT
45347: IFTRUE 45361
45349: PUSH
45350: LD_EXP 103
45354: PUSH
45355: LD_VAR 0 2
45359: ARRAY
45360: OR
45361: IFFALSE 45365
// continue ;
45363: GO 45333
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
45365: LD_ADDR_VAR 0 7
45369: PUSH
45370: LD_EXP 80
45374: PUSH
45375: LD_VAR 0 2
45379: ARRAY
45380: PUSH
45381: LD_INT 1
45383: ARRAY
45384: PPUSH
45385: CALL_OW 248
45389: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
45390: LD_VAR 0 7
45394: PUSH
45395: LD_INT 3
45397: EQUAL
45398: IFTRUE 45440
45400: PUSH
45401: LD_EXP 99
45405: PUSH
45406: LD_VAR 0 2
45410: ARRAY
45411: PUSH
45412: LD_EXP 102
45416: PUSH
45417: LD_VAR 0 2
45421: ARRAY
45422: UNION
45423: PPUSH
45424: LD_INT 33
45426: PUSH
45427: LD_INT 2
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PPUSH
45434: CALL_OW 72
45438: NOT
45439: OR
45440: IFFALSE 45444
// continue ;
45442: GO 45333
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
45444: LD_ADDR_VAR 0 9
45448: PUSH
45449: LD_EXP 80
45453: PUSH
45454: LD_VAR 0 2
45458: ARRAY
45459: PPUSH
45460: LD_INT 30
45462: PUSH
45463: LD_INT 36
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: PPUSH
45470: CALL_OW 72
45474: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
45475: LD_ADDR_VAR 0 10
45479: PUSH
45480: LD_EXP 99
45484: PUSH
45485: LD_VAR 0 2
45489: ARRAY
45490: PPUSH
45491: LD_INT 34
45493: PUSH
45494: LD_INT 31
45496: PUSH
45497: EMPTY
45498: LIST
45499: LIST
45500: PPUSH
45501: CALL_OW 72
45505: ST_TO_ADDR
// if not cts and not mcts then
45506: LD_VAR 0 9
45510: NOT
45511: IFFALSE 45520
45513: PUSH
45514: LD_VAR 0 10
45518: NOT
45519: AND
45520: IFFALSE 45524
// continue ;
45522: GO 45333
// x := cts ;
45524: LD_ADDR_VAR 0 11
45528: PUSH
45529: LD_VAR 0 9
45533: ST_TO_ADDR
// if not x then
45534: LD_VAR 0 11
45538: NOT
45539: IFFALSE 45551
// x := mcts ;
45541: LD_ADDR_VAR 0 11
45545: PUSH
45546: LD_VAR 0 10
45550: ST_TO_ADDR
// if not x then
45551: LD_VAR 0 11
45555: NOT
45556: IFFALSE 45560
// continue ;
45558: GO 45333
// if mc_remote_driver [ i ] then
45560: LD_EXP 120
45564: PUSH
45565: LD_VAR 0 2
45569: ARRAY
45570: IFFALSE 45969
// for j in mc_remote_driver [ i ] do
45572: LD_ADDR_VAR 0 3
45576: PUSH
45577: LD_EXP 120
45581: PUSH
45582: LD_VAR 0 2
45586: ARRAY
45587: PUSH
45588: FOR_IN
45589: IFFALSE 45967
// begin if GetClass ( j ) <> 3 then
45591: LD_VAR 0 3
45595: PPUSH
45596: CALL_OW 257
45600: PUSH
45601: LD_INT 3
45603: NONEQUAL
45604: IFFALSE 45657
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
45606: LD_ADDR_EXP 120
45610: PUSH
45611: LD_EXP 120
45615: PPUSH
45616: LD_VAR 0 2
45620: PPUSH
45621: LD_EXP 120
45625: PUSH
45626: LD_VAR 0 2
45630: ARRAY
45631: PUSH
45632: LD_VAR 0 3
45636: DIFF
45637: PPUSH
45638: CALL_OW 1
45642: ST_TO_ADDR
// SetTag ( j , 0 ) ;
45643: LD_VAR 0 3
45647: PPUSH
45648: LD_INT 0
45650: PPUSH
45651: CALL_OW 109
// continue ;
45655: GO 45588
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
45657: LD_EXP 99
45661: PUSH
45662: LD_VAR 0 2
45666: ARRAY
45667: PPUSH
45668: LD_INT 34
45670: PUSH
45671: LD_INT 31
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: PUSH
45678: LD_INT 58
45680: PUSH
45681: EMPTY
45682: LIST
45683: PUSH
45684: EMPTY
45685: LIST
45686: LIST
45687: PPUSH
45688: CALL_OW 72
45692: IFFALSE 45706
45694: PUSH
45695: LD_VAR 0 3
45699: PPUSH
45700: CALL 90181 0 1
45704: NOT
45705: AND
45706: IFFALSE 45777
// begin if IsInUnit ( j ) then
45708: LD_VAR 0 3
45712: PPUSH
45713: CALL_OW 310
45717: IFFALSE 45728
// ComExitBuilding ( j ) ;
45719: LD_VAR 0 3
45723: PPUSH
45724: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
45728: LD_VAR 0 3
45732: PPUSH
45733: LD_EXP 99
45737: PUSH
45738: LD_VAR 0 2
45742: ARRAY
45743: PPUSH
45744: LD_INT 34
45746: PUSH
45747: LD_INT 31
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: PUSH
45754: LD_INT 58
45756: PUSH
45757: EMPTY
45758: LIST
45759: PUSH
45760: EMPTY
45761: LIST
45762: LIST
45763: PPUSH
45764: CALL_OW 72
45768: PUSH
45769: LD_INT 1
45771: ARRAY
45772: PPUSH
45773: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
45777: LD_VAR 0 3
45781: PPUSH
45782: CALL_OW 310
45786: NOT
45787: IFTRUE 45823
45789: PUSH
45790: LD_VAR 0 3
45794: PPUSH
45795: CALL_OW 310
45799: PPUSH
45800: CALL_OW 266
45804: PUSH
45805: LD_INT 36
45807: NONEQUAL
45808: IFFALSE 45822
45810: PUSH
45811: LD_VAR 0 3
45815: PPUSH
45816: CALL 90181 0 1
45820: NOT
45821: AND
45822: OR
45823: IFFALSE 45965
// begin if IsInUnit ( j ) then
45825: LD_VAR 0 3
45829: PPUSH
45830: CALL_OW 310
45834: IFFALSE 45845
// ComExitBuilding ( j ) ;
45836: LD_VAR 0 3
45840: PPUSH
45841: CALL_OW 122
// ct := 0 ;
45845: LD_ADDR_VAR 0 8
45849: PUSH
45850: LD_INT 0
45852: ST_TO_ADDR
// for k in x do
45853: LD_ADDR_VAR 0 4
45857: PUSH
45858: LD_VAR 0 11
45862: PUSH
45863: FOR_IN
45864: IFFALSE 45943
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
45866: LD_VAR 0 4
45870: PPUSH
45871: CALL_OW 264
45875: PUSH
45876: LD_INT 31
45878: EQUAL
45879: IFFALSE 45893
45881: PUSH
45882: LD_VAR 0 4
45886: PPUSH
45887: CALL_OW 311
45891: NOT
45892: AND
45893: IFTRUE 45927
45895: PUSH
45896: LD_VAR 0 4
45900: PPUSH
45901: CALL_OW 266
45905: PUSH
45906: LD_INT 36
45908: EQUAL
45909: IFFALSE 45926
45911: PUSH
45912: LD_VAR 0 4
45916: PPUSH
45917: CALL_OW 313
45921: PUSH
45922: LD_INT 3
45924: LESS
45925: AND
45926: OR
45927: IFFALSE 45941
// begin ct := k ;
45929: LD_ADDR_VAR 0 8
45933: PUSH
45934: LD_VAR 0 4
45938: ST_TO_ADDR
// break ;
45939: GO 45943
// end ;
45941: GO 45863
45943: POP
45944: POP
// if ct then
45945: LD_VAR 0 8
45949: IFFALSE 45965
// ComEnterUnit ( j , ct ) ;
45951: LD_VAR 0 3
45955: PPUSH
45956: LD_VAR 0 8
45960: PPUSH
45961: CALL_OW 120
// end ; end ;
45965: GO 45588
45967: POP
45968: POP
// places := 0 ;
45969: LD_ADDR_VAR 0 5
45973: PUSH
45974: LD_INT 0
45976: ST_TO_ADDR
// for j = 1 to x do
45977: LD_ADDR_VAR 0 3
45981: PUSH
45982: DOUBLE
45983: LD_INT 1
45985: DEC
45986: ST_TO_ADDR
45987: LD_VAR 0 11
45991: PUSH
45992: FOR_TO
45993: IFFALSE 46069
// if GetWeapon ( x [ j ] ) = ar_control_tower then
45995: LD_VAR 0 11
45999: PUSH
46000: LD_VAR 0 3
46004: ARRAY
46005: PPUSH
46006: CALL_OW 264
46010: PUSH
46011: LD_INT 31
46013: EQUAL
46014: IFFALSE 46032
// places := places + 1 else
46016: LD_ADDR_VAR 0 5
46020: PUSH
46021: LD_VAR 0 5
46025: PUSH
46026: LD_INT 1
46028: PLUS
46029: ST_TO_ADDR
46030: GO 46067
// if GetBType ( x [ j ] ) = b_control_tower then
46032: LD_VAR 0 11
46036: PUSH
46037: LD_VAR 0 3
46041: ARRAY
46042: PPUSH
46043: CALL_OW 266
46047: PUSH
46048: LD_INT 36
46050: EQUAL
46051: IFFALSE 46067
// places := places + 3 ;
46053: LD_ADDR_VAR 0 5
46057: PUSH
46058: LD_VAR 0 5
46062: PUSH
46063: LD_INT 3
46065: PLUS
46066: ST_TO_ADDR
46067: GO 45992
46069: POP
46070: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
46071: LD_VAR 0 5
46075: PUSH
46076: LD_INT 0
46078: EQUAL
46079: IFTRUE 46099
46081: PUSH
46082: LD_VAR 0 5
46086: PUSH
46087: LD_EXP 120
46091: PUSH
46092: LD_VAR 0 2
46096: ARRAY
46097: LESSEQUAL
46098: OR
46099: IFFALSE 46103
// continue ;
46101: GO 45333
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
46103: LD_ADDR_VAR 0 6
46107: PUSH
46108: LD_EXP 80
46112: PUSH
46113: LD_VAR 0 2
46117: ARRAY
46118: PPUSH
46119: LD_INT 25
46121: PUSH
46122: LD_INT 3
46124: PUSH
46125: EMPTY
46126: LIST
46127: LIST
46128: PPUSH
46129: CALL_OW 72
46133: PUSH
46134: LD_EXP 120
46138: PUSH
46139: LD_VAR 0 2
46143: ARRAY
46144: DIFF
46145: PPUSH
46146: LD_INT 3
46148: PPUSH
46149: CALL 91081 0 2
46153: ST_TO_ADDR
// for j in tmp do
46154: LD_ADDR_VAR 0 3
46158: PUSH
46159: LD_VAR 0 6
46163: PUSH
46164: FOR_IN
46165: IFFALSE 46200
// if GetTag ( j ) > 0 then
46167: LD_VAR 0 3
46171: PPUSH
46172: CALL_OW 110
46176: PUSH
46177: LD_INT 0
46179: GREATER
46180: IFFALSE 46198
// tmp := tmp diff j ;
46182: LD_ADDR_VAR 0 6
46186: PUSH
46187: LD_VAR 0 6
46191: PUSH
46192: LD_VAR 0 3
46196: DIFF
46197: ST_TO_ADDR
46198: GO 46164
46200: POP
46201: POP
// if not tmp then
46202: LD_VAR 0 6
46206: NOT
46207: IFFALSE 46211
// continue ;
46209: GO 45333
// if places then
46211: LD_VAR 0 5
46215: IFFALSE 46274
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
46217: LD_ADDR_EXP 120
46221: PUSH
46222: LD_EXP 120
46226: PPUSH
46227: LD_VAR 0 2
46231: PPUSH
46232: LD_EXP 120
46236: PUSH
46237: LD_VAR 0 2
46241: ARRAY
46242: PUSH
46243: LD_VAR 0 6
46247: PUSH
46248: LD_INT 1
46250: ARRAY
46251: UNION
46252: PPUSH
46253: CALL_OW 1
46257: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
46258: LD_VAR 0 6
46262: PUSH
46263: LD_INT 1
46265: ARRAY
46266: PPUSH
46267: LD_INT 126
46269: PPUSH
46270: CALL_OW 109
// end ; end ;
46274: GO 45333
46276: POP
46277: POP
// end ;
46278: LD_VAR 0 1
46282: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
46283: LD_INT 0
46285: PPUSH
46286: PPUSH
46287: PPUSH
46288: PPUSH
46289: PPUSH
46290: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
46291: LD_VAR 0 1
46295: NOT
46296: IFTRUE 46305
46298: PUSH
46299: LD_VAR 0 2
46303: NOT
46304: OR
46305: IFTRUE 46314
46307: PUSH
46308: LD_VAR 0 3
46312: NOT
46313: OR
46314: IFTRUE 46362
46316: PUSH
46317: LD_VAR 0 4
46321: PUSH
46322: LD_INT 1
46324: PUSH
46325: LD_INT 2
46327: PUSH
46328: LD_INT 3
46330: PUSH
46331: LD_INT 4
46333: PUSH
46334: LD_INT 5
46336: PUSH
46337: LD_INT 8
46339: PUSH
46340: LD_INT 9
46342: PUSH
46343: LD_INT 15
46345: PUSH
46346: LD_INT 16
46348: PUSH
46349: EMPTY
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: LIST
46359: IN
46360: NOT
46361: OR
46362: IFFALSE 46366
// exit ;
46364: GO 47226
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
46366: LD_ADDR_VAR 0 2
46370: PUSH
46371: LD_VAR 0 2
46375: PPUSH
46376: LD_INT 21
46378: PUSH
46379: LD_INT 3
46381: PUSH
46382: EMPTY
46383: LIST
46384: LIST
46385: PUSH
46386: LD_INT 24
46388: PUSH
46389: LD_INT 250
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: PPUSH
46400: CALL_OW 72
46404: ST_TO_ADDR
// case class of 1 , 15 :
46405: LD_VAR 0 4
46409: PUSH
46410: LD_INT 1
46412: DOUBLE
46413: EQUAL
46414: IFTRUE 46424
46416: LD_INT 15
46418: DOUBLE
46419: EQUAL
46420: IFTRUE 46424
46422: GO 46509
46424: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
46425: LD_ADDR_VAR 0 8
46429: PUSH
46430: LD_VAR 0 2
46434: PPUSH
46435: LD_INT 2
46437: PUSH
46438: LD_INT 30
46440: PUSH
46441: LD_INT 32
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: PUSH
46448: LD_INT 30
46450: PUSH
46451: LD_INT 31
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: EMPTY
46459: LIST
46460: LIST
46461: LIST
46462: PPUSH
46463: CALL_OW 72
46467: PUSH
46468: LD_VAR 0 2
46472: PPUSH
46473: LD_INT 2
46475: PUSH
46476: LD_INT 30
46478: PUSH
46479: LD_INT 4
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: LD_INT 30
46488: PUSH
46489: LD_INT 5
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: EMPTY
46497: LIST
46498: LIST
46499: LIST
46500: PPUSH
46501: CALL_OW 72
46505: ADD
46506: ST_TO_ADDR
46507: GO 46755
46509: LD_INT 2
46511: DOUBLE
46512: EQUAL
46513: IFTRUE 46523
46515: LD_INT 16
46517: DOUBLE
46518: EQUAL
46519: IFTRUE 46523
46521: GO 46569
46523: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
46524: LD_ADDR_VAR 0 8
46528: PUSH
46529: LD_VAR 0 2
46533: PPUSH
46534: LD_INT 2
46536: PUSH
46537: LD_INT 30
46539: PUSH
46540: LD_INT 0
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: PUSH
46547: LD_INT 30
46549: PUSH
46550: LD_INT 1
46552: PUSH
46553: EMPTY
46554: LIST
46555: LIST
46556: PUSH
46557: EMPTY
46558: LIST
46559: LIST
46560: LIST
46561: PPUSH
46562: CALL_OW 72
46566: ST_TO_ADDR
46567: GO 46755
46569: LD_INT 3
46571: DOUBLE
46572: EQUAL
46573: IFTRUE 46577
46575: GO 46623
46577: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
46578: LD_ADDR_VAR 0 8
46582: PUSH
46583: LD_VAR 0 2
46587: PPUSH
46588: LD_INT 2
46590: PUSH
46591: LD_INT 30
46593: PUSH
46594: LD_INT 2
46596: PUSH
46597: EMPTY
46598: LIST
46599: LIST
46600: PUSH
46601: LD_INT 30
46603: PUSH
46604: LD_INT 3
46606: PUSH
46607: EMPTY
46608: LIST
46609: LIST
46610: PUSH
46611: EMPTY
46612: LIST
46613: LIST
46614: LIST
46615: PPUSH
46616: CALL_OW 72
46620: ST_TO_ADDR
46621: GO 46755
46623: LD_INT 4
46625: DOUBLE
46626: EQUAL
46627: IFTRUE 46631
46629: GO 46688
46631: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
46632: LD_ADDR_VAR 0 8
46636: PUSH
46637: LD_VAR 0 2
46641: PPUSH
46642: LD_INT 2
46644: PUSH
46645: LD_INT 30
46647: PUSH
46648: LD_INT 6
46650: PUSH
46651: EMPTY
46652: LIST
46653: LIST
46654: PUSH
46655: LD_INT 30
46657: PUSH
46658: LD_INT 7
46660: PUSH
46661: EMPTY
46662: LIST
46663: LIST
46664: PUSH
46665: LD_INT 30
46667: PUSH
46668: LD_INT 8
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: PUSH
46675: EMPTY
46676: LIST
46677: LIST
46678: LIST
46679: LIST
46680: PPUSH
46681: CALL_OW 72
46685: ST_TO_ADDR
46686: GO 46755
46688: LD_INT 5
46690: DOUBLE
46691: EQUAL
46692: IFTRUE 46708
46694: LD_INT 8
46696: DOUBLE
46697: EQUAL
46698: IFTRUE 46708
46700: LD_INT 9
46702: DOUBLE
46703: EQUAL
46704: IFTRUE 46708
46706: GO 46754
46708: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
46709: LD_ADDR_VAR 0 8
46713: PUSH
46714: LD_VAR 0 2
46718: PPUSH
46719: LD_INT 2
46721: PUSH
46722: LD_INT 30
46724: PUSH
46725: LD_INT 4
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: PUSH
46732: LD_INT 30
46734: PUSH
46735: LD_INT 5
46737: PUSH
46738: EMPTY
46739: LIST
46740: LIST
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: LIST
46746: PPUSH
46747: CALL_OW 72
46751: ST_TO_ADDR
46752: GO 46755
46754: POP
// if not tmp then
46755: LD_VAR 0 8
46759: NOT
46760: IFFALSE 46764
// exit ;
46762: GO 47226
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
46764: LD_VAR 0 4
46768: PUSH
46769: LD_INT 1
46771: PUSH
46772: LD_INT 15
46774: PUSH
46775: EMPTY
46776: LIST
46777: LIST
46778: IN
46779: IFFALSE 46793
46781: PUSH
46782: LD_EXP 89
46786: PUSH
46787: LD_VAR 0 1
46791: ARRAY
46792: AND
46793: IFFALSE 46949
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
46795: LD_ADDR_VAR 0 9
46799: PUSH
46800: LD_EXP 89
46804: PUSH
46805: LD_VAR 0 1
46809: ARRAY
46810: PUSH
46811: LD_INT 1
46813: ARRAY
46814: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
46815: LD_VAR 0 9
46819: PUSH
46820: LD_EXP 90
46824: PUSH
46825: LD_VAR 0 1
46829: ARRAY
46830: IN
46831: NOT
46832: IFFALSE 46947
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
46834: LD_ADDR_EXP 90
46838: PUSH
46839: LD_EXP 90
46843: PPUSH
46844: LD_VAR 0 1
46848: PUSH
46849: LD_EXP 90
46853: PUSH
46854: LD_VAR 0 1
46858: ARRAY
46859: PUSH
46860: LD_INT 1
46862: PLUS
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: PPUSH
46868: LD_VAR 0 9
46872: PPUSH
46873: CALL 59553 0 3
46877: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
46878: LD_ADDR_EXP 89
46882: PUSH
46883: LD_EXP 89
46887: PPUSH
46888: LD_VAR 0 1
46892: PPUSH
46893: LD_EXP 89
46897: PUSH
46898: LD_VAR 0 1
46902: ARRAY
46903: PUSH
46904: LD_VAR 0 9
46908: DIFF
46909: PPUSH
46910: CALL_OW 1
46914: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
46915: LD_VAR 0 3
46919: PPUSH
46920: LD_EXP 90
46924: PUSH
46925: LD_VAR 0 1
46929: ARRAY
46930: PUSH
46931: LD_EXP 90
46935: PUSH
46936: LD_VAR 0 1
46940: ARRAY
46941: ARRAY
46942: PPUSH
46943: CALL_OW 120
// end ; exit ;
46947: GO 47226
// end ; if tmp > 1 then
46949: LD_VAR 0 8
46953: PUSH
46954: LD_INT 1
46956: GREATER
46957: IFFALSE 47061
// for i = 2 to tmp do
46959: LD_ADDR_VAR 0 6
46963: PUSH
46964: DOUBLE
46965: LD_INT 2
46967: DEC
46968: ST_TO_ADDR
46969: LD_VAR 0 8
46973: PUSH
46974: FOR_TO
46975: IFFALSE 47059
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
46977: LD_VAR 0 8
46981: PUSH
46982: LD_VAR 0 6
46986: ARRAY
46987: PPUSH
46988: CALL_OW 461
46992: PUSH
46993: LD_INT 6
46995: EQUAL
46996: IFFALSE 47057
// begin x := tmp [ i ] ;
46998: LD_ADDR_VAR 0 9
47002: PUSH
47003: LD_VAR 0 8
47007: PUSH
47008: LD_VAR 0 6
47012: ARRAY
47013: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
47014: LD_ADDR_VAR 0 8
47018: PUSH
47019: LD_VAR 0 8
47023: PPUSH
47024: LD_VAR 0 6
47028: PPUSH
47029: CALL_OW 3
47033: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
47034: LD_ADDR_VAR 0 8
47038: PUSH
47039: LD_VAR 0 8
47043: PPUSH
47044: LD_INT 1
47046: PPUSH
47047: LD_VAR 0 9
47051: PPUSH
47052: CALL_OW 2
47056: ST_TO_ADDR
// end ;
47057: GO 46974
47059: POP
47060: POP
// for i in tmp do
47061: LD_ADDR_VAR 0 6
47065: PUSH
47066: LD_VAR 0 8
47070: PUSH
47071: FOR_IN
47072: IFFALSE 47099
// begin if IsNotFull ( i ) then
47074: LD_VAR 0 6
47078: PPUSH
47079: CALL 56717 0 1
47083: IFFALSE 47097
// begin j := i ;
47085: LD_ADDR_VAR 0 7
47089: PUSH
47090: LD_VAR 0 6
47094: ST_TO_ADDR
// break ;
47095: GO 47099
// end ; end ;
47097: GO 47071
47099: POP
47100: POP
// if j then
47101: LD_VAR 0 7
47105: IFFALSE 47123
// ComEnterUnit ( unit , j ) else
47107: LD_VAR 0 3
47111: PPUSH
47112: LD_VAR 0 7
47116: PPUSH
47117: CALL_OW 120
47121: GO 47226
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47123: LD_ADDR_VAR 0 10
47127: PUSH
47128: LD_VAR 0 2
47132: PPUSH
47133: LD_INT 2
47135: PUSH
47136: LD_INT 30
47138: PUSH
47139: LD_INT 0
47141: PUSH
47142: EMPTY
47143: LIST
47144: LIST
47145: PUSH
47146: LD_INT 30
47148: PUSH
47149: LD_INT 1
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: PUSH
47156: EMPTY
47157: LIST
47158: LIST
47159: LIST
47160: PPUSH
47161: CALL_OW 72
47165: ST_TO_ADDR
// if depot then
47166: LD_VAR 0 10
47170: IFFALSE 47226
// begin depot := NearestUnitToUnit ( depot , unit ) ;
47172: LD_ADDR_VAR 0 10
47176: PUSH
47177: LD_VAR 0 10
47181: PPUSH
47182: LD_VAR 0 3
47186: PPUSH
47187: CALL_OW 74
47191: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
47192: LD_VAR 0 3
47196: PPUSH
47197: LD_VAR 0 10
47201: PPUSH
47202: CALL_OW 296
47206: PUSH
47207: LD_INT 10
47209: GREATER
47210: IFFALSE 47226
// ComStandNearbyBuilding ( unit , depot ) ;
47212: LD_VAR 0 3
47216: PPUSH
47217: LD_VAR 0 10
47221: PPUSH
47222: CALL 56095 0 2
// end ; end ; end ;
47226: LD_VAR 0 5
47230: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
47231: LD_INT 0
47233: PPUSH
47234: PPUSH
47235: PPUSH
47236: PPUSH
// if not mc_bases then
47237: LD_EXP 80
47241: NOT
47242: IFFALSE 47246
// exit ;
47244: GO 47497
// for i = 1 to mc_bases do
47246: LD_ADDR_VAR 0 2
47250: PUSH
47251: DOUBLE
47252: LD_INT 1
47254: DEC
47255: ST_TO_ADDR
47256: LD_EXP 80
47260: PUSH
47261: FOR_TO
47262: IFFALSE 47495
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
47264: LD_ADDR_VAR 0 4
47268: PUSH
47269: LD_EXP 80
47273: PUSH
47274: LD_VAR 0 2
47278: ARRAY
47279: PPUSH
47280: LD_INT 21
47282: PUSH
47283: LD_INT 1
47285: PUSH
47286: EMPTY
47287: LIST
47288: LIST
47289: PPUSH
47290: CALL_OW 72
47294: PUSH
47295: LD_EXP 109
47299: PUSH
47300: LD_VAR 0 2
47304: ARRAY
47305: UNION
47306: ST_TO_ADDR
// if not tmp then
47307: LD_VAR 0 4
47311: NOT
47312: IFFALSE 47316
// continue ;
47314: GO 47261
// for j in tmp do
47316: LD_ADDR_VAR 0 3
47320: PUSH
47321: LD_VAR 0 4
47325: PUSH
47326: FOR_IN
47327: IFFALSE 47491
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
47329: LD_VAR 0 3
47333: PPUSH
47334: CALL_OW 110
47338: NOT
47339: IFFALSE 47353
47341: PUSH
47342: LD_VAR 0 3
47346: PPUSH
47347: CALL_OW 314
47351: NOT
47352: AND
47353: IFFALSE 47367
47355: PUSH
47356: LD_VAR 0 3
47360: PPUSH
47361: CALL_OW 311
47365: NOT
47366: AND
47367: IFFALSE 47381
47369: PUSH
47370: LD_VAR 0 3
47374: PPUSH
47375: CALL_OW 310
47379: NOT
47380: AND
47381: IFFALSE 47406
47383: PUSH
47384: LD_VAR 0 3
47388: PUSH
47389: LD_EXP 83
47393: PUSH
47394: LD_VAR 0 2
47398: ARRAY
47399: PUSH
47400: LD_INT 1
47402: ARRAY
47403: IN
47404: NOT
47405: AND
47406: IFFALSE 47431
47408: PUSH
47409: LD_VAR 0 3
47413: PUSH
47414: LD_EXP 83
47418: PUSH
47419: LD_VAR 0 2
47423: ARRAY
47424: PUSH
47425: LD_INT 2
47427: ARRAY
47428: IN
47429: NOT
47430: AND
47431: IFFALSE 47452
47433: PUSH
47434: LD_VAR 0 3
47438: PUSH
47439: LD_EXP 92
47443: PUSH
47444: LD_VAR 0 2
47448: ARRAY
47449: IN
47450: NOT
47451: AND
47452: IFFALSE 47489
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
47454: LD_VAR 0 2
47458: PPUSH
47459: LD_EXP 80
47463: PUSH
47464: LD_VAR 0 2
47468: ARRAY
47469: PPUSH
47470: LD_VAR 0 3
47474: PPUSH
47475: LD_VAR 0 3
47479: PPUSH
47480: CALL_OW 257
47484: PPUSH
47485: CALL 46283 0 4
// end ;
47489: GO 47326
47491: POP
47492: POP
// end ;
47493: GO 47261
47495: POP
47496: POP
// end ;
47497: LD_VAR 0 1
47501: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
47502: LD_INT 0
47504: PPUSH
47505: PPUSH
47506: PPUSH
47507: PPUSH
47508: PPUSH
47509: PPUSH
// if not mc_bases [ base ] then
47510: LD_EXP 80
47514: PUSH
47515: LD_VAR 0 1
47519: ARRAY
47520: NOT
47521: IFFALSE 47525
// exit ;
47523: GO 47726
// tmp := [ ] ;
47525: LD_ADDR_VAR 0 6
47529: PUSH
47530: EMPTY
47531: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
47532: LD_ADDR_VAR 0 7
47536: PUSH
47537: LD_VAR 0 3
47541: PPUSH
47542: LD_INT 0
47544: PPUSH
47545: CALL_OW 517
47549: ST_TO_ADDR
// if not list then
47550: LD_VAR 0 7
47554: NOT
47555: IFFALSE 47559
// exit ;
47557: GO 47726
// c := Count ( list [ 1 ] ) ;
47559: LD_ADDR_VAR 0 9
47563: PUSH
47564: LD_VAR 0 7
47568: PUSH
47569: LD_INT 1
47571: ARRAY
47572: PPUSH
47573: CALL 56635 0 1
47577: ST_TO_ADDR
// if amount > c then
47578: LD_VAR 0 2
47582: PUSH
47583: LD_VAR 0 9
47587: GREATER
47588: IFFALSE 47600
// amount := c ;
47590: LD_ADDR_VAR 0 2
47594: PUSH
47595: LD_VAR 0 9
47599: ST_TO_ADDR
// for i := 1 to amount do
47600: LD_ADDR_VAR 0 5
47604: PUSH
47605: DOUBLE
47606: LD_INT 1
47608: DEC
47609: ST_TO_ADDR
47610: LD_VAR 0 2
47614: PUSH
47615: FOR_TO
47616: IFFALSE 47674
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
47618: LD_ADDR_VAR 0 6
47622: PUSH
47623: LD_VAR 0 6
47627: PPUSH
47628: LD_VAR 0 5
47632: PPUSH
47633: LD_VAR 0 7
47637: PUSH
47638: LD_INT 1
47640: ARRAY
47641: PUSH
47642: LD_VAR 0 5
47646: ARRAY
47647: PUSH
47648: LD_VAR 0 7
47652: PUSH
47653: LD_INT 2
47655: ARRAY
47656: PUSH
47657: LD_VAR 0 5
47661: ARRAY
47662: PUSH
47663: EMPTY
47664: LIST
47665: LIST
47666: PPUSH
47667: CALL_OW 1
47671: ST_TO_ADDR
47672: GO 47615
47674: POP
47675: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
47676: LD_ADDR_EXP 93
47680: PUSH
47681: LD_EXP 93
47685: PPUSH
47686: LD_VAR 0 1
47690: PPUSH
47691: LD_VAR 0 6
47695: PPUSH
47696: CALL_OW 1
47700: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
47701: LD_ADDR_EXP 95
47705: PUSH
47706: LD_EXP 95
47710: PPUSH
47711: LD_VAR 0 1
47715: PPUSH
47716: LD_VAR 0 3
47720: PPUSH
47721: CALL_OW 1
47725: ST_TO_ADDR
// end ;
47726: LD_VAR 0 4
47730: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
47731: LD_INT 0
47733: PPUSH
// if not mc_bases [ base ] then
47734: LD_EXP 80
47738: PUSH
47739: LD_VAR 0 1
47743: ARRAY
47744: NOT
47745: IFFALSE 47749
// exit ;
47747: GO 47774
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
47749: LD_ADDR_EXP 85
47753: PUSH
47754: LD_EXP 85
47758: PPUSH
47759: LD_VAR 0 1
47763: PPUSH
47764: LD_VAR 0 2
47768: PPUSH
47769: CALL_OW 1
47773: ST_TO_ADDR
// end ;
47774: LD_VAR 0 3
47778: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
47779: LD_INT 0
47781: PPUSH
// if not mc_bases [ base ] then
47782: LD_EXP 80
47786: PUSH
47787: LD_VAR 0 1
47791: ARRAY
47792: NOT
47793: IFFALSE 47797
// exit ;
47795: GO 47834
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
47797: LD_ADDR_EXP 85
47801: PUSH
47802: LD_EXP 85
47806: PPUSH
47807: LD_VAR 0 1
47811: PPUSH
47812: LD_EXP 85
47816: PUSH
47817: LD_VAR 0 1
47821: ARRAY
47822: PUSH
47823: LD_VAR 0 2
47827: UNION
47828: PPUSH
47829: CALL_OW 1
47833: ST_TO_ADDR
// end ;
47834: LD_VAR 0 3
47838: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
47839: LD_INT 0
47841: PPUSH
// if not mc_bases [ base ] then
47842: LD_EXP 80
47846: PUSH
47847: LD_VAR 0 1
47851: ARRAY
47852: NOT
47853: IFFALSE 47857
// exit ;
47855: GO 47882
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
47857: LD_ADDR_EXP 101
47861: PUSH
47862: LD_EXP 101
47866: PPUSH
47867: LD_VAR 0 1
47871: PPUSH
47872: LD_VAR 0 2
47876: PPUSH
47877: CALL_OW 1
47881: ST_TO_ADDR
// end ;
47882: LD_VAR 0 3
47886: RET
// export function MC_InsertProduceList ( base , components ) ; begin
47887: LD_INT 0
47889: PPUSH
// if not mc_bases [ base ] then
47890: LD_EXP 80
47894: PUSH
47895: LD_VAR 0 1
47899: ARRAY
47900: NOT
47901: IFFALSE 47905
// exit ;
47903: GO 47942
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
47905: LD_ADDR_EXP 101
47909: PUSH
47910: LD_EXP 101
47914: PPUSH
47915: LD_VAR 0 1
47919: PPUSH
47920: LD_EXP 101
47924: PUSH
47925: LD_VAR 0 1
47929: ARRAY
47930: PUSH
47931: LD_VAR 0 2
47935: ADD
47936: PPUSH
47937: CALL_OW 1
47941: ST_TO_ADDR
// end ;
47942: LD_VAR 0 3
47946: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
47947: LD_INT 0
47949: PPUSH
// if not mc_bases [ base ] then
47950: LD_EXP 80
47954: PUSH
47955: LD_VAR 0 1
47959: ARRAY
47960: NOT
47961: IFFALSE 47965
// exit ;
47963: GO 48019
// mc_defender := Replace ( mc_defender , base , deflist ) ;
47965: LD_ADDR_EXP 102
47969: PUSH
47970: LD_EXP 102
47974: PPUSH
47975: LD_VAR 0 1
47979: PPUSH
47980: LD_VAR 0 2
47984: PPUSH
47985: CALL_OW 1
47989: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
47990: LD_ADDR_EXP 91
47994: PUSH
47995: LD_EXP 91
47999: PPUSH
48000: LD_VAR 0 1
48004: PPUSH
48005: LD_VAR 0 2
48009: PUSH
48010: LD_INT 0
48012: PLUS
48013: PPUSH
48014: CALL_OW 1
48018: ST_TO_ADDR
// end ;
48019: LD_VAR 0 3
48023: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
48024: LD_INT 0
48026: PPUSH
// if not mc_bases [ base ] then
48027: LD_EXP 80
48031: PUSH
48032: LD_VAR 0 1
48036: ARRAY
48037: NOT
48038: IFFALSE 48042
// exit ;
48040: GO 48067
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
48042: LD_ADDR_EXP 91
48046: PUSH
48047: LD_EXP 91
48051: PPUSH
48052: LD_VAR 0 1
48056: PPUSH
48057: LD_VAR 0 2
48061: PPUSH
48062: CALL_OW 1
48066: ST_TO_ADDR
// end ;
48067: LD_VAR 0 3
48071: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
48072: LD_INT 0
48074: PPUSH
48075: PPUSH
48076: PPUSH
48077: PPUSH
// if not mc_bases [ base ] then
48078: LD_EXP 80
48082: PUSH
48083: LD_VAR 0 1
48087: ARRAY
48088: NOT
48089: IFFALSE 48093
// exit ;
48091: GO 48158
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
48093: LD_ADDR_EXP 100
48097: PUSH
48098: LD_EXP 100
48102: PPUSH
48103: LD_VAR 0 1
48107: PUSH
48108: LD_EXP 100
48112: PUSH
48113: LD_VAR 0 1
48117: ARRAY
48118: PUSH
48119: LD_INT 1
48121: PLUS
48122: PUSH
48123: EMPTY
48124: LIST
48125: LIST
48126: PPUSH
48127: LD_VAR 0 1
48131: PUSH
48132: LD_VAR 0 2
48136: PUSH
48137: LD_VAR 0 3
48141: PUSH
48142: LD_VAR 0 4
48146: PUSH
48147: EMPTY
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: PPUSH
48153: CALL 59553 0 3
48157: ST_TO_ADDR
// end ;
48158: LD_VAR 0 5
48162: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
48163: LD_INT 0
48165: PPUSH
// if not mc_bases [ base ] then
48166: LD_EXP 80
48170: PUSH
48171: LD_VAR 0 1
48175: ARRAY
48176: NOT
48177: IFFALSE 48181
// exit ;
48179: GO 48206
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
48181: LD_ADDR_EXP 117
48185: PUSH
48186: LD_EXP 117
48190: PPUSH
48191: LD_VAR 0 1
48195: PPUSH
48196: LD_VAR 0 2
48200: PPUSH
48201: CALL_OW 1
48205: ST_TO_ADDR
// end ;
48206: LD_VAR 0 3
48210: RET
// export function MC_GetMinesField ( base ) ; begin
48211: LD_INT 0
48213: PPUSH
// result := mc_mines [ base ] ;
48214: LD_ADDR_VAR 0 2
48218: PUSH
48219: LD_EXP 93
48223: PUSH
48224: LD_VAR 0 1
48228: ARRAY
48229: ST_TO_ADDR
// end ;
48230: LD_VAR 0 2
48234: RET
// export function MC_GetProduceList ( base ) ; begin
48235: LD_INT 0
48237: PPUSH
// result := mc_produce [ base ] ;
48238: LD_ADDR_VAR 0 2
48242: PUSH
48243: LD_EXP 101
48247: PUSH
48248: LD_VAR 0 1
48252: ARRAY
48253: ST_TO_ADDR
// end ;
48254: LD_VAR 0 2
48258: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
48259: LD_INT 0
48261: PPUSH
48262: PPUSH
// if not mc_bases then
48263: LD_EXP 80
48267: NOT
48268: IFFALSE 48272
// exit ;
48270: GO 48337
// if mc_bases [ base ] then
48272: LD_EXP 80
48276: PUSH
48277: LD_VAR 0 1
48281: ARRAY
48282: IFFALSE 48337
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
48284: LD_ADDR_VAR 0 3
48288: PUSH
48289: LD_EXP 80
48293: PUSH
48294: LD_VAR 0 1
48298: ARRAY
48299: PPUSH
48300: LD_INT 30
48302: PUSH
48303: LD_VAR 0 2
48307: PUSH
48308: EMPTY
48309: LIST
48310: LIST
48311: PPUSH
48312: CALL_OW 72
48316: ST_TO_ADDR
// if result then
48317: LD_VAR 0 3
48321: IFFALSE 48337
// result := result [ 1 ] ;
48323: LD_ADDR_VAR 0 3
48327: PUSH
48328: LD_VAR 0 3
48332: PUSH
48333: LD_INT 1
48335: ARRAY
48336: ST_TO_ADDR
// end ; end ;
48337: LD_VAR 0 3
48341: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
48342: LD_INT 0
48344: PPUSH
48345: PPUSH
// if not mc_bases then
48346: LD_EXP 80
48350: NOT
48351: IFFALSE 48355
// exit ;
48353: GO 48400
// if mc_bases [ base ] then
48355: LD_EXP 80
48359: PUSH
48360: LD_VAR 0 1
48364: ARRAY
48365: IFFALSE 48400
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
48367: LD_ADDR_VAR 0 3
48371: PUSH
48372: LD_EXP 80
48376: PUSH
48377: LD_VAR 0 1
48381: ARRAY
48382: PPUSH
48383: LD_INT 30
48385: PUSH
48386: LD_VAR 0 2
48390: PUSH
48391: EMPTY
48392: LIST
48393: LIST
48394: PPUSH
48395: CALL_OW 72
48399: ST_TO_ADDR
// end ;
48400: LD_VAR 0 3
48404: RET
// export function MC_SetTame ( base , area ) ; begin
48405: LD_INT 0
48407: PPUSH
// if not mc_bases or not base then
48408: LD_EXP 80
48412: NOT
48413: IFTRUE 48422
48415: PUSH
48416: LD_VAR 0 1
48420: NOT
48421: OR
48422: IFFALSE 48426
// exit ;
48424: GO 48451
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
48426: LD_ADDR_EXP 108
48430: PUSH
48431: LD_EXP 108
48435: PPUSH
48436: LD_VAR 0 1
48440: PPUSH
48441: LD_VAR 0 2
48445: PPUSH
48446: CALL_OW 1
48450: ST_TO_ADDR
// end ;
48451: LD_VAR 0 3
48455: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
48456: LD_INT 0
48458: PPUSH
48459: PPUSH
// if not mc_bases or not base then
48460: LD_EXP 80
48464: NOT
48465: IFTRUE 48474
48467: PUSH
48468: LD_VAR 0 1
48472: NOT
48473: OR
48474: IFFALSE 48478
// exit ;
48476: GO 48580
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
48478: LD_ADDR_VAR 0 4
48482: PUSH
48483: LD_EXP 80
48487: PUSH
48488: LD_VAR 0 1
48492: ARRAY
48493: PPUSH
48494: LD_INT 30
48496: PUSH
48497: LD_VAR 0 2
48501: PUSH
48502: EMPTY
48503: LIST
48504: LIST
48505: PPUSH
48506: CALL_OW 72
48510: ST_TO_ADDR
// if not tmp then
48511: LD_VAR 0 4
48515: NOT
48516: IFFALSE 48520
// exit ;
48518: GO 48580
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
48520: LD_ADDR_EXP 112
48524: PUSH
48525: LD_EXP 112
48529: PPUSH
48530: LD_VAR 0 1
48534: PPUSH
48535: LD_EXP 112
48539: PUSH
48540: LD_VAR 0 1
48544: ARRAY
48545: PPUSH
48546: LD_EXP 112
48550: PUSH
48551: LD_VAR 0 1
48555: ARRAY
48556: PUSH
48557: LD_INT 1
48559: PLUS
48560: PPUSH
48561: LD_VAR 0 4
48565: PUSH
48566: LD_INT 1
48568: ARRAY
48569: PPUSH
48570: CALL_OW 2
48574: PPUSH
48575: CALL_OW 1
48579: ST_TO_ADDR
// end ;
48580: LD_VAR 0 3
48584: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
48585: LD_INT 0
48587: PPUSH
48588: PPUSH
// if not mc_bases or not base or not kinds then
48589: LD_EXP 80
48593: NOT
48594: IFTRUE 48603
48596: PUSH
48597: LD_VAR 0 1
48601: NOT
48602: OR
48603: IFTRUE 48612
48605: PUSH
48606: LD_VAR 0 2
48610: NOT
48611: OR
48612: IFFALSE 48616
// exit ;
48614: GO 48677
// for i in kinds do
48616: LD_ADDR_VAR 0 4
48620: PUSH
48621: LD_VAR 0 2
48625: PUSH
48626: FOR_IN
48627: IFFALSE 48675
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
48629: LD_ADDR_EXP 114
48633: PUSH
48634: LD_EXP 114
48638: PPUSH
48639: LD_VAR 0 1
48643: PUSH
48644: LD_EXP 114
48648: PUSH
48649: LD_VAR 0 1
48653: ARRAY
48654: PUSH
48655: LD_INT 1
48657: PLUS
48658: PUSH
48659: EMPTY
48660: LIST
48661: LIST
48662: PPUSH
48663: LD_VAR 0 4
48667: PPUSH
48668: CALL 59553 0 3
48672: ST_TO_ADDR
48673: GO 48626
48675: POP
48676: POP
// end ;
48677: LD_VAR 0 3
48681: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
48682: LD_INT 0
48684: PPUSH
// if not mc_bases or not base or not areas then
48685: LD_EXP 80
48689: NOT
48690: IFTRUE 48699
48692: PUSH
48693: LD_VAR 0 1
48697: NOT
48698: OR
48699: IFTRUE 48708
48701: PUSH
48702: LD_VAR 0 2
48706: NOT
48707: OR
48708: IFFALSE 48712
// exit ;
48710: GO 48737
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
48712: LD_ADDR_EXP 98
48716: PUSH
48717: LD_EXP 98
48721: PPUSH
48722: LD_VAR 0 1
48726: PPUSH
48727: LD_VAR 0 2
48731: PPUSH
48732: CALL_OW 1
48736: ST_TO_ADDR
// end ;
48737: LD_VAR 0 3
48741: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
48742: LD_INT 0
48744: PPUSH
// if not mc_bases or not base or not teleports_exit then
48745: LD_EXP 80
48749: NOT
48750: IFTRUE 48759
48752: PUSH
48753: LD_VAR 0 1
48757: NOT
48758: OR
48759: IFTRUE 48768
48761: PUSH
48762: LD_VAR 0 2
48766: NOT
48767: OR
48768: IFFALSE 48772
// exit ;
48770: GO 48797
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
48772: LD_ADDR_EXP 115
48776: PUSH
48777: LD_EXP 115
48781: PPUSH
48782: LD_VAR 0 1
48786: PPUSH
48787: LD_VAR 0 2
48791: PPUSH
48792: CALL_OW 1
48796: ST_TO_ADDR
// end ;
48797: LD_VAR 0 3
48801: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
48802: LD_INT 0
48804: PPUSH
48805: PPUSH
48806: PPUSH
// if not mc_bases or not base or not ext_list then
48807: LD_EXP 80
48811: NOT
48812: IFTRUE 48821
48814: PUSH
48815: LD_VAR 0 1
48819: NOT
48820: OR
48821: IFTRUE 48830
48823: PUSH
48824: LD_VAR 0 5
48828: NOT
48829: OR
48830: IFFALSE 48834
// exit ;
48832: GO 49007
// tmp := GetFacExtXYD ( x , y , d ) ;
48834: LD_ADDR_VAR 0 8
48838: PUSH
48839: LD_VAR 0 2
48843: PPUSH
48844: LD_VAR 0 3
48848: PPUSH
48849: LD_VAR 0 4
48853: PPUSH
48854: CALL 90211 0 3
48858: ST_TO_ADDR
// if not tmp then
48859: LD_VAR 0 8
48863: NOT
48864: IFFALSE 48868
// exit ;
48866: GO 49007
// for i in tmp do
48868: LD_ADDR_VAR 0 7
48872: PUSH
48873: LD_VAR 0 8
48877: PUSH
48878: FOR_IN
48879: IFFALSE 49005
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
48881: LD_ADDR_EXP 85
48885: PUSH
48886: LD_EXP 85
48890: PPUSH
48891: LD_VAR 0 1
48895: PPUSH
48896: LD_EXP 85
48900: PUSH
48901: LD_VAR 0 1
48905: ARRAY
48906: PPUSH
48907: LD_EXP 85
48911: PUSH
48912: LD_VAR 0 1
48916: ARRAY
48917: PUSH
48918: LD_INT 1
48920: PLUS
48921: PPUSH
48922: LD_VAR 0 5
48926: PUSH
48927: LD_INT 1
48929: ARRAY
48930: PUSH
48931: LD_VAR 0 7
48935: PUSH
48936: LD_INT 1
48938: ARRAY
48939: PUSH
48940: LD_VAR 0 7
48944: PUSH
48945: LD_INT 2
48947: ARRAY
48948: PUSH
48949: LD_VAR 0 7
48953: PUSH
48954: LD_INT 3
48956: ARRAY
48957: PUSH
48958: EMPTY
48959: LIST
48960: LIST
48961: LIST
48962: LIST
48963: PPUSH
48964: CALL_OW 2
48968: PPUSH
48969: CALL_OW 1
48973: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
48974: LD_ADDR_VAR 0 5
48978: PUSH
48979: LD_VAR 0 5
48983: PPUSH
48984: LD_INT 1
48986: PPUSH
48987: CALL_OW 3
48991: ST_TO_ADDR
// if not ext_list then
48992: LD_VAR 0 5
48996: NOT
48997: IFFALSE 49003
// exit ;
48999: POP
49000: POP
49001: GO 49007
// end ;
49003: GO 48878
49005: POP
49006: POP
// end ;
49007: LD_VAR 0 6
49011: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
49012: LD_INT 0
49014: PPUSH
// if not mc_bases or not base or not weapon_list then
49015: LD_EXP 80
49019: NOT
49020: IFTRUE 49029
49022: PUSH
49023: LD_VAR 0 1
49027: NOT
49028: OR
49029: IFTRUE 49038
49031: PUSH
49032: LD_VAR 0 2
49036: NOT
49037: OR
49038: IFFALSE 49042
// exit ;
49040: GO 49067
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
49042: LD_ADDR_EXP 119
49046: PUSH
49047: LD_EXP 119
49051: PPUSH
49052: LD_VAR 0 1
49056: PPUSH
49057: LD_VAR 0 2
49061: PPUSH
49062: CALL_OW 1
49066: ST_TO_ADDR
// end ;
49067: LD_VAR 0 3
49071: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
49072: LD_INT 0
49074: PPUSH
// if not mc_bases or not base or not tech_list then
49075: LD_EXP 80
49079: NOT
49080: IFTRUE 49089
49082: PUSH
49083: LD_VAR 0 1
49087: NOT
49088: OR
49089: IFTRUE 49098
49091: PUSH
49092: LD_VAR 0 2
49096: NOT
49097: OR
49098: IFFALSE 49102
// exit ;
49100: GO 49127
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
49102: LD_ADDR_EXP 107
49106: PUSH
49107: LD_EXP 107
49111: PPUSH
49112: LD_VAR 0 1
49116: PPUSH
49117: LD_VAR 0 2
49121: PPUSH
49122: CALL_OW 1
49126: ST_TO_ADDR
// end ;
49127: LD_VAR 0 3
49131: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
49132: LD_INT 0
49134: PPUSH
// if not mc_bases or not parking_area or not base then
49135: LD_EXP 80
49139: NOT
49140: IFTRUE 49149
49142: PUSH
49143: LD_VAR 0 2
49147: NOT
49148: OR
49149: IFTRUE 49158
49151: PUSH
49152: LD_VAR 0 1
49156: NOT
49157: OR
49158: IFFALSE 49162
// exit ;
49160: GO 49187
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
49162: LD_ADDR_EXP 104
49166: PUSH
49167: LD_EXP 104
49171: PPUSH
49172: LD_VAR 0 1
49176: PPUSH
49177: LD_VAR 0 2
49181: PPUSH
49182: CALL_OW 1
49186: ST_TO_ADDR
// end ;
49187: LD_VAR 0 3
49191: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
49192: LD_INT 0
49194: PPUSH
// if not mc_bases or not base or not scan_area then
49195: LD_EXP 80
49199: NOT
49200: IFTRUE 49209
49202: PUSH
49203: LD_VAR 0 1
49207: NOT
49208: OR
49209: IFTRUE 49218
49211: PUSH
49212: LD_VAR 0 2
49216: NOT
49217: OR
49218: IFFALSE 49222
// exit ;
49220: GO 49247
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
49222: LD_ADDR_EXP 105
49226: PUSH
49227: LD_EXP 105
49231: PPUSH
49232: LD_VAR 0 1
49236: PPUSH
49237: LD_VAR 0 2
49241: PPUSH
49242: CALL_OW 1
49246: ST_TO_ADDR
// end ;
49247: LD_VAR 0 3
49251: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
49252: LD_INT 0
49254: PPUSH
49255: PPUSH
// if not mc_bases or not base then
49256: LD_EXP 80
49260: NOT
49261: IFTRUE 49270
49263: PUSH
49264: LD_VAR 0 1
49268: NOT
49269: OR
49270: IFFALSE 49274
// exit ;
49272: GO 49338
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
49274: LD_ADDR_VAR 0 3
49278: PUSH
49279: LD_INT 1
49281: PUSH
49282: LD_INT 2
49284: PUSH
49285: LD_INT 3
49287: PUSH
49288: LD_INT 4
49290: PUSH
49291: LD_INT 11
49293: PUSH
49294: EMPTY
49295: LIST
49296: LIST
49297: LIST
49298: LIST
49299: LIST
49300: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
49301: LD_ADDR_EXP 107
49305: PUSH
49306: LD_EXP 107
49310: PPUSH
49311: LD_VAR 0 1
49315: PPUSH
49316: LD_EXP 107
49320: PUSH
49321: LD_VAR 0 1
49325: ARRAY
49326: PUSH
49327: LD_VAR 0 3
49331: DIFF
49332: PPUSH
49333: CALL_OW 1
49337: ST_TO_ADDR
// end ;
49338: LD_VAR 0 2
49342: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
49343: LD_INT 0
49345: PPUSH
// result := mc_vehicles [ base ] ;
49346: LD_ADDR_VAR 0 3
49350: PUSH
49351: LD_EXP 99
49355: PUSH
49356: LD_VAR 0 1
49360: ARRAY
49361: ST_TO_ADDR
// if onlyCombat then
49362: LD_VAR 0 2
49366: IFFALSE 49538
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
49368: LD_ADDR_VAR 0 3
49372: PUSH
49373: LD_VAR 0 3
49377: PUSH
49378: LD_VAR 0 3
49382: PPUSH
49383: LD_INT 2
49385: PUSH
49386: LD_INT 34
49388: PUSH
49389: LD_INT 12
49391: PUSH
49392: EMPTY
49393: LIST
49394: LIST
49395: PUSH
49396: LD_INT 34
49398: PUSH
49399: LD_INT 51
49401: PUSH
49402: EMPTY
49403: LIST
49404: LIST
49405: PUSH
49406: LD_INT 34
49408: PUSH
49409: LD_INT 89
49411: PUSH
49412: EMPTY
49413: LIST
49414: LIST
49415: PUSH
49416: LD_INT 34
49418: PUSH
49419: LD_INT 32
49421: PUSH
49422: EMPTY
49423: LIST
49424: LIST
49425: PUSH
49426: LD_INT 34
49428: PUSH
49429: LD_INT 13
49431: PUSH
49432: EMPTY
49433: LIST
49434: LIST
49435: PUSH
49436: LD_INT 34
49438: PUSH
49439: LD_INT 52
49441: PUSH
49442: EMPTY
49443: LIST
49444: LIST
49445: PUSH
49446: LD_INT 34
49448: PUSH
49449: LD_INT 88
49451: PUSH
49452: EMPTY
49453: LIST
49454: LIST
49455: PUSH
49456: LD_INT 34
49458: PUSH
49459: LD_INT 14
49461: PUSH
49462: EMPTY
49463: LIST
49464: LIST
49465: PUSH
49466: LD_INT 34
49468: PUSH
49469: LD_INT 53
49471: PUSH
49472: EMPTY
49473: LIST
49474: LIST
49475: PUSH
49476: LD_INT 34
49478: PUSH
49479: LD_INT 98
49481: PUSH
49482: EMPTY
49483: LIST
49484: LIST
49485: PUSH
49486: LD_INT 34
49488: PUSH
49489: LD_INT 31
49491: PUSH
49492: EMPTY
49493: LIST
49494: LIST
49495: PUSH
49496: LD_INT 34
49498: PUSH
49499: LD_INT 48
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PUSH
49506: LD_INT 34
49508: PUSH
49509: LD_INT 8
49511: PUSH
49512: EMPTY
49513: LIST
49514: LIST
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: LIST
49520: LIST
49521: LIST
49522: LIST
49523: LIST
49524: LIST
49525: LIST
49526: LIST
49527: LIST
49528: LIST
49529: LIST
49530: LIST
49531: PPUSH
49532: CALL_OW 72
49536: DIFF
49537: ST_TO_ADDR
// end ; end_of_file
49538: LD_VAR 0 3
49542: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
49543: LD_INT 0
49545: PPUSH
49546: PPUSH
49547: PPUSH
// if not mc_bases or not skirmish then
49548: LD_EXP 80
49552: NOT
49553: IFTRUE 49562
49555: PUSH
49556: LD_EXP 78
49560: NOT
49561: OR
49562: IFFALSE 49566
// exit ;
49564: GO 49731
// for i = 1 to mc_bases do
49566: LD_ADDR_VAR 0 4
49570: PUSH
49571: DOUBLE
49572: LD_INT 1
49574: DEC
49575: ST_TO_ADDR
49576: LD_EXP 80
49580: PUSH
49581: FOR_TO
49582: IFFALSE 49729
// begin if sci in mc_bases [ i ] then
49584: LD_VAR 0 2
49588: PUSH
49589: LD_EXP 80
49593: PUSH
49594: LD_VAR 0 4
49598: ARRAY
49599: IN
49600: IFFALSE 49727
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
49602: LD_ADDR_EXP 109
49606: PUSH
49607: LD_EXP 109
49611: PPUSH
49612: LD_VAR 0 4
49616: PUSH
49617: LD_EXP 109
49621: PUSH
49622: LD_VAR 0 4
49626: ARRAY
49627: PUSH
49628: LD_INT 1
49630: PLUS
49631: PUSH
49632: EMPTY
49633: LIST
49634: LIST
49635: PPUSH
49636: LD_VAR 0 1
49640: PPUSH
49641: CALL 59553 0 3
49645: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
49646: LD_ADDR_VAR 0 5
49650: PUSH
49651: LD_EXP 80
49655: PUSH
49656: LD_VAR 0 4
49660: ARRAY
49661: PPUSH
49662: LD_INT 2
49664: PUSH
49665: LD_INT 30
49667: PUSH
49668: LD_INT 0
49670: PUSH
49671: EMPTY
49672: LIST
49673: LIST
49674: PUSH
49675: LD_INT 30
49677: PUSH
49678: LD_INT 1
49680: PUSH
49681: EMPTY
49682: LIST
49683: LIST
49684: PUSH
49685: EMPTY
49686: LIST
49687: LIST
49688: LIST
49689: PPUSH
49690: CALL_OW 72
49694: PPUSH
49695: LD_VAR 0 1
49699: PPUSH
49700: CALL_OW 74
49704: ST_TO_ADDR
// if tmp then
49705: LD_VAR 0 5
49709: IFFALSE 49725
// ComStandNearbyBuilding ( ape , tmp ) ;
49711: LD_VAR 0 1
49715: PPUSH
49716: LD_VAR 0 5
49720: PPUSH
49721: CALL 56095 0 2
// break ;
49725: GO 49729
// end ; end ;
49727: GO 49581
49729: POP
49730: POP
// end ;
49731: LD_VAR 0 3
49735: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
49736: LD_INT 0
49738: PPUSH
49739: PPUSH
49740: PPUSH
// if not mc_bases or not skirmish then
49741: LD_EXP 80
49745: NOT
49746: IFTRUE 49755
49748: PUSH
49749: LD_EXP 78
49753: NOT
49754: OR
49755: IFFALSE 49759
// exit ;
49757: GO 49848
// for i = 1 to mc_bases do
49759: LD_ADDR_VAR 0 4
49763: PUSH
49764: DOUBLE
49765: LD_INT 1
49767: DEC
49768: ST_TO_ADDR
49769: LD_EXP 80
49773: PUSH
49774: FOR_TO
49775: IFFALSE 49846
// begin if building in mc_busy_turret_list [ i ] then
49777: LD_VAR 0 1
49781: PUSH
49782: LD_EXP 90
49786: PUSH
49787: LD_VAR 0 4
49791: ARRAY
49792: IN
49793: IFFALSE 49844
// begin tmp := mc_busy_turret_list [ i ] diff building ;
49795: LD_ADDR_VAR 0 5
49799: PUSH
49800: LD_EXP 90
49804: PUSH
49805: LD_VAR 0 4
49809: ARRAY
49810: PUSH
49811: LD_VAR 0 1
49815: DIFF
49816: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
49817: LD_ADDR_EXP 90
49821: PUSH
49822: LD_EXP 90
49826: PPUSH
49827: LD_VAR 0 4
49831: PPUSH
49832: LD_VAR 0 5
49836: PPUSH
49837: CALL_OW 1
49841: ST_TO_ADDR
// break ;
49842: GO 49846
// end ; end ;
49844: GO 49774
49846: POP
49847: POP
// end ;
49848: LD_VAR 0 3
49852: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
49853: LD_INT 0
49855: PPUSH
49856: PPUSH
49857: PPUSH
// if not mc_bases or not skirmish then
49858: LD_EXP 80
49862: NOT
49863: IFTRUE 49872
49865: PUSH
49866: LD_EXP 78
49870: NOT
49871: OR
49872: IFFALSE 49876
// exit ;
49874: GO 50075
// for i = 1 to mc_bases do
49876: LD_ADDR_VAR 0 5
49880: PUSH
49881: DOUBLE
49882: LD_INT 1
49884: DEC
49885: ST_TO_ADDR
49886: LD_EXP 80
49890: PUSH
49891: FOR_TO
49892: IFFALSE 50073
// if building in mc_bases [ i ] then
49894: LD_VAR 0 1
49898: PUSH
49899: LD_EXP 80
49903: PUSH
49904: LD_VAR 0 5
49908: ARRAY
49909: IN
49910: IFFALSE 50071
// begin tmp := mc_bases [ i ] diff building ;
49912: LD_ADDR_VAR 0 6
49916: PUSH
49917: LD_EXP 80
49921: PUSH
49922: LD_VAR 0 5
49926: ARRAY
49927: PUSH
49928: LD_VAR 0 1
49932: DIFF
49933: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
49934: LD_ADDR_EXP 80
49938: PUSH
49939: LD_EXP 80
49943: PPUSH
49944: LD_VAR 0 5
49948: PPUSH
49949: LD_VAR 0 6
49953: PPUSH
49954: CALL_OW 1
49958: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
49959: LD_VAR 0 1
49963: PUSH
49964: LD_EXP 88
49968: PUSH
49969: LD_VAR 0 5
49973: ARRAY
49974: IN
49975: IFFALSE 50014
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
49977: LD_ADDR_EXP 88
49981: PUSH
49982: LD_EXP 88
49986: PPUSH
49987: LD_VAR 0 5
49991: PPUSH
49992: LD_EXP 88
49996: PUSH
49997: LD_VAR 0 5
50001: ARRAY
50002: PUSH
50003: LD_VAR 0 1
50007: DIFF
50008: PPUSH
50009: CALL_OW 1
50013: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
50014: LD_VAR 0 1
50018: PUSH
50019: LD_EXP 89
50023: PUSH
50024: LD_VAR 0 5
50028: ARRAY
50029: IN
50030: IFFALSE 50069
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
50032: LD_ADDR_EXP 89
50036: PUSH
50037: LD_EXP 89
50041: PPUSH
50042: LD_VAR 0 5
50046: PPUSH
50047: LD_EXP 89
50051: PUSH
50052: LD_VAR 0 5
50056: ARRAY
50057: PUSH
50058: LD_VAR 0 1
50062: DIFF
50063: PPUSH
50064: CALL_OW 1
50068: ST_TO_ADDR
// break ;
50069: GO 50073
// end ;
50071: GO 49891
50073: POP
50074: POP
// end ;
50075: LD_VAR 0 4
50079: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
50080: LD_INT 0
50082: PPUSH
50083: PPUSH
50084: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
50085: LD_EXP 80
50089: NOT
50090: IFTRUE 50099
50092: PUSH
50093: LD_EXP 78
50097: NOT
50098: OR
50099: IFTRUE 50114
50101: PUSH
50102: LD_VAR 0 3
50106: PUSH
50107: LD_EXP 106
50111: IN
50112: NOT
50113: OR
50114: IFFALSE 50118
// exit ;
50116: GO 50243
// for i = 1 to mc_vehicles do
50118: LD_ADDR_VAR 0 6
50122: PUSH
50123: DOUBLE
50124: LD_INT 1
50126: DEC
50127: ST_TO_ADDR
50128: LD_EXP 99
50132: PUSH
50133: FOR_TO
50134: IFFALSE 50241
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
50136: LD_VAR 0 2
50140: PUSH
50141: LD_EXP 99
50145: PUSH
50146: LD_VAR 0 6
50150: ARRAY
50151: IN
50152: IFTRUE 50172
50154: PUSH
50155: LD_VAR 0 1
50159: PUSH
50160: LD_EXP 99
50164: PUSH
50165: LD_VAR 0 6
50169: ARRAY
50170: IN
50171: OR
50172: IFFALSE 50239
// begin tmp := mc_vehicles [ i ] diff old ;
50174: LD_ADDR_VAR 0 7
50178: PUSH
50179: LD_EXP 99
50183: PUSH
50184: LD_VAR 0 6
50188: ARRAY
50189: PUSH
50190: LD_VAR 0 2
50194: DIFF
50195: ST_TO_ADDR
// tmp := tmp diff new ;
50196: LD_ADDR_VAR 0 7
50200: PUSH
50201: LD_VAR 0 7
50205: PUSH
50206: LD_VAR 0 1
50210: DIFF
50211: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
50212: LD_ADDR_EXP 99
50216: PUSH
50217: LD_EXP 99
50221: PPUSH
50222: LD_VAR 0 6
50226: PPUSH
50227: LD_VAR 0 7
50231: PPUSH
50232: CALL_OW 1
50236: ST_TO_ADDR
// break ;
50237: GO 50241
// end ;
50239: GO 50133
50241: POP
50242: POP
// end ;
50243: LD_VAR 0 5
50247: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
50248: LD_INT 0
50250: PPUSH
50251: PPUSH
50252: PPUSH
50253: PPUSH
// if not mc_bases or not skirmish then
50254: LD_EXP 80
50258: NOT
50259: IFTRUE 50268
50261: PUSH
50262: LD_EXP 78
50266: NOT
50267: OR
50268: IFFALSE 50272
// exit ;
50270: GO 50694
// repeat wait ( 0 0$1 ) ;
50272: LD_INT 35
50274: PPUSH
50275: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
50279: LD_EXP 124
50283: NOT
50284: IFFALSE 50272
// mc_block_vehicle_constructed_thread := true ;
50286: LD_ADDR_EXP 124
50290: PUSH
50291: LD_INT 1
50293: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
50294: LD_ADDR_VAR 0 5
50298: PUSH
50299: LD_VAR 0 1
50303: PPUSH
50304: CALL_OW 255
50308: ST_TO_ADDR
// for i = 1 to mc_bases do
50309: LD_ADDR_VAR 0 4
50313: PUSH
50314: DOUBLE
50315: LD_INT 1
50317: DEC
50318: ST_TO_ADDR
50319: LD_EXP 80
50323: PUSH
50324: FOR_TO
50325: IFFALSE 50684
// begin if factory in mc_bases [ i ] then
50327: LD_VAR 0 2
50331: PUSH
50332: LD_EXP 80
50336: PUSH
50337: LD_VAR 0 4
50341: ARRAY
50342: IN
50343: IFFALSE 50682
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
50345: LD_EXP 102
50349: PUSH
50350: LD_VAR 0 4
50354: ARRAY
50355: PUSH
50356: LD_EXP 91
50360: PUSH
50361: LD_VAR 0 4
50365: ARRAY
50366: LESS
50367: IFFALSE 50456
50369: PUSH
50370: LD_VAR 0 1
50374: PPUSH
50375: CALL_OW 264
50379: PUSH
50380: LD_INT 31
50382: PUSH
50383: LD_INT 32
50385: PUSH
50386: LD_INT 51
50388: PUSH
50389: LD_INT 89
50391: PUSH
50392: LD_INT 12
50394: PUSH
50395: LD_INT 30
50397: PUSH
50398: LD_INT 98
50400: PUSH
50401: LD_INT 11
50403: PUSH
50404: LD_INT 53
50406: PUSH
50407: LD_INT 14
50409: PUSH
50410: LD_INT 91
50412: PUSH
50413: LD_INT 29
50415: PUSH
50416: LD_INT 99
50418: PUSH
50419: LD_INT 13
50421: PUSH
50422: LD_INT 52
50424: PUSH
50425: LD_INT 88
50427: PUSH
50428: LD_INT 48
50430: PUSH
50431: LD_INT 8
50433: PUSH
50434: EMPTY
50435: LIST
50436: LIST
50437: LIST
50438: LIST
50439: LIST
50440: LIST
50441: LIST
50442: LIST
50443: LIST
50444: LIST
50445: LIST
50446: LIST
50447: LIST
50448: LIST
50449: LIST
50450: LIST
50451: LIST
50452: LIST
50453: IN
50454: NOT
50455: AND
50456: IFFALSE 50504
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
50458: LD_ADDR_EXP 102
50462: PUSH
50463: LD_EXP 102
50467: PPUSH
50468: LD_VAR 0 4
50472: PUSH
50473: LD_EXP 102
50477: PUSH
50478: LD_VAR 0 4
50482: ARRAY
50483: PUSH
50484: LD_INT 1
50486: PLUS
50487: PUSH
50488: EMPTY
50489: LIST
50490: LIST
50491: PPUSH
50492: LD_VAR 0 1
50496: PPUSH
50497: CALL 59553 0 3
50501: ST_TO_ADDR
50502: GO 50548
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
50504: LD_ADDR_EXP 99
50508: PUSH
50509: LD_EXP 99
50513: PPUSH
50514: LD_VAR 0 4
50518: PUSH
50519: LD_EXP 99
50523: PUSH
50524: LD_VAR 0 4
50528: ARRAY
50529: PUSH
50530: LD_INT 1
50532: PLUS
50533: PUSH
50534: EMPTY
50535: LIST
50536: LIST
50537: PPUSH
50538: LD_VAR 0 1
50542: PPUSH
50543: CALL 59553 0 3
50547: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
50548: LD_ADDR_EXP 124
50552: PUSH
50553: LD_INT 0
50555: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
50556: LD_VAR 0 1
50560: PPUSH
50561: CALL_OW 263
50565: PUSH
50566: LD_INT 2
50568: EQUAL
50569: IFFALSE 50598
// begin repeat wait ( 0 0$3 ) ;
50571: LD_INT 105
50573: PPUSH
50574: CALL_OW 67
// Connect ( vehicle ) ;
50578: LD_VAR 0 1
50582: PPUSH
50583: CALL 62913 0 1
// until IsControledBy ( vehicle ) ;
50587: LD_VAR 0 1
50591: PPUSH
50592: CALL_OW 312
50596: IFFALSE 50571
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
50598: LD_VAR 0 1
50602: PPUSH
50603: LD_EXP 104
50607: PUSH
50608: LD_VAR 0 4
50612: ARRAY
50613: PPUSH
50614: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
50618: LD_VAR 0 1
50622: PPUSH
50623: CALL_OW 263
50627: PUSH
50628: LD_INT 1
50630: NONEQUAL
50631: IFFALSE 50635
// break ;
50633: GO 50684
// repeat wait ( 0 0$1 ) ;
50635: LD_INT 35
50637: PPUSH
50638: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
50642: LD_VAR 0 1
50646: PPUSH
50647: LD_EXP 104
50651: PUSH
50652: LD_VAR 0 4
50656: ARRAY
50657: PPUSH
50658: CALL_OW 308
50662: IFFALSE 50635
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
50664: LD_VAR 0 1
50668: PPUSH
50669: CALL_OW 311
50673: PPUSH
50674: CALL_OW 121
// exit ;
50678: POP
50679: POP
50680: GO 50694
// end ; end ;
50682: GO 50324
50684: POP
50685: POP
// mc_block_vehicle_constructed_thread := false ;
50686: LD_ADDR_EXP 124
50690: PUSH
50691: LD_INT 0
50693: ST_TO_ADDR
// end ;
50694: LD_VAR 0 3
50698: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
50699: LD_INT 0
50701: PPUSH
50702: PPUSH
50703: PPUSH
50704: PPUSH
// if not mc_bases or not skirmish then
50705: LD_EXP 80
50709: NOT
50710: IFTRUE 50719
50712: PUSH
50713: LD_EXP 78
50717: NOT
50718: OR
50719: IFFALSE 50723
// exit ;
50721: GO 51076
// repeat wait ( 0 0$1 ) ;
50723: LD_INT 35
50725: PPUSH
50726: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
50730: LD_VAR 0 2
50734: PPUSH
50735: LD_VAR 0 3
50739: PPUSH
50740: CALL_OW 284
50744: IFFALSE 50723
// if GetResourceTypeXY ( x , y ) = mat_artefact then
50746: LD_VAR 0 2
50750: PPUSH
50751: LD_VAR 0 3
50755: PPUSH
50756: CALL_OW 283
50760: PUSH
50761: LD_INT 4
50763: EQUAL
50764: IFFALSE 50768
// exit ;
50766: GO 51076
// for i = 1 to mc_bases do
50768: LD_ADDR_VAR 0 7
50772: PUSH
50773: DOUBLE
50774: LD_INT 1
50776: DEC
50777: ST_TO_ADDR
50778: LD_EXP 80
50782: PUSH
50783: FOR_TO
50784: IFFALSE 51074
// begin if mc_crates_area [ i ] then
50786: LD_EXP 98
50790: PUSH
50791: LD_VAR 0 7
50795: ARRAY
50796: IFFALSE 50907
// for j in mc_crates_area [ i ] do
50798: LD_ADDR_VAR 0 8
50802: PUSH
50803: LD_EXP 98
50807: PUSH
50808: LD_VAR 0 7
50812: ARRAY
50813: PUSH
50814: FOR_IN
50815: IFFALSE 50905
// if InArea ( x , y , j ) then
50817: LD_VAR 0 2
50821: PPUSH
50822: LD_VAR 0 3
50826: PPUSH
50827: LD_VAR 0 8
50831: PPUSH
50832: CALL_OW 309
50836: IFFALSE 50903
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
50838: LD_ADDR_EXP 96
50842: PUSH
50843: LD_EXP 96
50847: PPUSH
50848: LD_VAR 0 7
50852: PUSH
50853: LD_EXP 96
50857: PUSH
50858: LD_VAR 0 7
50862: ARRAY
50863: PUSH
50864: LD_INT 1
50866: PLUS
50867: PUSH
50868: EMPTY
50869: LIST
50870: LIST
50871: PPUSH
50872: LD_VAR 0 4
50876: PUSH
50877: LD_VAR 0 2
50881: PUSH
50882: LD_VAR 0 3
50886: PUSH
50887: EMPTY
50888: LIST
50889: LIST
50890: LIST
50891: PPUSH
50892: CALL 59553 0 3
50896: ST_TO_ADDR
// exit ;
50897: POP
50898: POP
50899: POP
50900: POP
50901: GO 51076
// end ;
50903: GO 50814
50905: POP
50906: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50907: LD_ADDR_VAR 0 9
50911: PUSH
50912: LD_EXP 80
50916: PUSH
50917: LD_VAR 0 7
50921: ARRAY
50922: PPUSH
50923: LD_INT 2
50925: PUSH
50926: LD_INT 30
50928: PUSH
50929: LD_INT 0
50931: PUSH
50932: EMPTY
50933: LIST
50934: LIST
50935: PUSH
50936: LD_INT 30
50938: PUSH
50939: LD_INT 1
50941: PUSH
50942: EMPTY
50943: LIST
50944: LIST
50945: PUSH
50946: EMPTY
50947: LIST
50948: LIST
50949: LIST
50950: PPUSH
50951: CALL_OW 72
50955: ST_TO_ADDR
// if not depot then
50956: LD_VAR 0 9
50960: NOT
50961: IFFALSE 50965
// continue ;
50963: GO 50783
// for j in depot do
50965: LD_ADDR_VAR 0 8
50969: PUSH
50970: LD_VAR 0 9
50974: PUSH
50975: FOR_IN
50976: IFFALSE 51070
// if GetDistUnitXY ( j , x , y ) < 30 then
50978: LD_VAR 0 8
50982: PPUSH
50983: LD_VAR 0 2
50987: PPUSH
50988: LD_VAR 0 3
50992: PPUSH
50993: CALL_OW 297
50997: PUSH
50998: LD_INT 30
51000: LESS
51001: IFFALSE 51068
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
51003: LD_ADDR_EXP 96
51007: PUSH
51008: LD_EXP 96
51012: PPUSH
51013: LD_VAR 0 7
51017: PUSH
51018: LD_EXP 96
51022: PUSH
51023: LD_VAR 0 7
51027: ARRAY
51028: PUSH
51029: LD_INT 1
51031: PLUS
51032: PUSH
51033: EMPTY
51034: LIST
51035: LIST
51036: PPUSH
51037: LD_VAR 0 4
51041: PUSH
51042: LD_VAR 0 2
51046: PUSH
51047: LD_VAR 0 3
51051: PUSH
51052: EMPTY
51053: LIST
51054: LIST
51055: LIST
51056: PPUSH
51057: CALL 59553 0 3
51061: ST_TO_ADDR
// exit ;
51062: POP
51063: POP
51064: POP
51065: POP
51066: GO 51076
// end ;
51068: GO 50975
51070: POP
51071: POP
// end ;
51072: GO 50783
51074: POP
51075: POP
// end ;
51076: LD_VAR 0 6
51080: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
51081: LD_INT 0
51083: PPUSH
51084: PPUSH
51085: PPUSH
51086: PPUSH
// if not mc_bases or not skirmish then
51087: LD_EXP 80
51091: NOT
51092: IFTRUE 51101
51094: PUSH
51095: LD_EXP 78
51099: NOT
51100: OR
51101: IFFALSE 51105
// exit ;
51103: GO 51388
// side := GetSide ( lab ) ;
51105: LD_ADDR_VAR 0 4
51109: PUSH
51110: LD_VAR 0 2
51114: PPUSH
51115: CALL_OW 255
51119: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
51120: LD_VAR 0 4
51124: PUSH
51125: LD_EXP 106
51129: IN
51130: NOT
51131: IFTRUE 51140
51133: PUSH
51134: LD_EXP 107
51138: NOT
51139: OR
51140: IFTRUE 51149
51142: PUSH
51143: LD_EXP 80
51147: NOT
51148: OR
51149: IFFALSE 51153
// exit ;
51151: GO 51388
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
51153: LD_ADDR_EXP 107
51157: PUSH
51158: LD_EXP 107
51162: PPUSH
51163: LD_VAR 0 4
51167: PPUSH
51168: LD_EXP 107
51172: PUSH
51173: LD_VAR 0 4
51177: ARRAY
51178: PUSH
51179: LD_VAR 0 1
51183: DIFF
51184: PPUSH
51185: CALL_OW 1
51189: ST_TO_ADDR
// for i = 1 to mc_bases do
51190: LD_ADDR_VAR 0 5
51194: PUSH
51195: DOUBLE
51196: LD_INT 1
51198: DEC
51199: ST_TO_ADDR
51200: LD_EXP 80
51204: PUSH
51205: FOR_TO
51206: IFFALSE 51386
// begin if lab in mc_bases [ i ] then
51208: LD_VAR 0 2
51212: PUSH
51213: LD_EXP 80
51217: PUSH
51218: LD_VAR 0 5
51222: ARRAY
51223: IN
51224: IFFALSE 51384
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
51226: LD_VAR 0 1
51230: PUSH
51231: LD_INT 11
51233: PUSH
51234: LD_INT 4
51236: PUSH
51237: LD_INT 3
51239: PUSH
51240: LD_INT 2
51242: PUSH
51243: EMPTY
51244: LIST
51245: LIST
51246: LIST
51247: LIST
51248: IN
51249: IFFALSE 51263
51251: PUSH
51252: LD_EXP 110
51256: PUSH
51257: LD_VAR 0 5
51261: ARRAY
51262: AND
51263: IFFALSE 51384
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
51265: LD_ADDR_VAR 0 6
51269: PUSH
51270: LD_EXP 110
51274: PUSH
51275: LD_VAR 0 5
51279: ARRAY
51280: PUSH
51281: LD_INT 1
51283: ARRAY
51284: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
51285: LD_ADDR_EXP 110
51289: PUSH
51290: LD_EXP 110
51294: PPUSH
51295: LD_VAR 0 5
51299: PPUSH
51300: EMPTY
51301: PPUSH
51302: CALL_OW 1
51306: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
51307: LD_VAR 0 6
51311: PPUSH
51312: LD_INT 0
51314: PPUSH
51315: CALL_OW 109
// ComExitBuilding ( tmp ) ;
51319: LD_VAR 0 6
51323: PPUSH
51324: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
51328: LD_ADDR_EXP 109
51332: PUSH
51333: LD_EXP 109
51337: PPUSH
51338: LD_VAR 0 5
51342: PPUSH
51343: LD_EXP 109
51347: PUSH
51348: LD_VAR 0 5
51352: ARRAY
51353: PPUSH
51354: LD_INT 1
51356: PPUSH
51357: LD_VAR 0 6
51361: PPUSH
51362: CALL_OW 2
51366: PPUSH
51367: CALL_OW 1
51371: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
51372: LD_VAR 0 5
51376: PPUSH
51377: LD_INT 112
51379: PPUSH
51380: CALL 27518 0 2
// end ; end ; end ;
51384: GO 51205
51386: POP
51387: POP
// end ;
51388: LD_VAR 0 3
51392: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
51393: LD_INT 0
51395: PPUSH
51396: PPUSH
51397: PPUSH
51398: PPUSH
51399: PPUSH
51400: PPUSH
51401: PPUSH
51402: PPUSH
// if not mc_bases or not skirmish then
51403: LD_EXP 80
51407: NOT
51408: IFTRUE 51417
51410: PUSH
51411: LD_EXP 78
51415: NOT
51416: OR
51417: IFFALSE 51421
// exit ;
51419: GO 52806
// for i = 1 to mc_bases do
51421: LD_ADDR_VAR 0 3
51425: PUSH
51426: DOUBLE
51427: LD_INT 1
51429: DEC
51430: ST_TO_ADDR
51431: LD_EXP 80
51435: PUSH
51436: FOR_TO
51437: IFFALSE 52804
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
51439: LD_VAR 0 1
51443: PUSH
51444: LD_EXP 80
51448: PUSH
51449: LD_VAR 0 3
51453: ARRAY
51454: IN
51455: IFTRUE 51475
51457: PUSH
51458: LD_VAR 0 1
51462: PUSH
51463: LD_EXP 87
51467: PUSH
51468: LD_VAR 0 3
51472: ARRAY
51473: IN
51474: OR
51475: IFTRUE 51495
51477: PUSH
51478: LD_VAR 0 1
51482: PUSH
51483: LD_EXP 102
51487: PUSH
51488: LD_VAR 0 3
51492: ARRAY
51493: IN
51494: OR
51495: IFTRUE 51515
51497: PUSH
51498: LD_VAR 0 1
51502: PUSH
51503: LD_EXP 99
51507: PUSH
51508: LD_VAR 0 3
51512: ARRAY
51513: IN
51514: OR
51515: IFTRUE 51535
51517: PUSH
51518: LD_VAR 0 1
51522: PUSH
51523: LD_EXP 109
51527: PUSH
51528: LD_VAR 0 3
51532: ARRAY
51533: IN
51534: OR
51535: IFTRUE 51555
51537: PUSH
51538: LD_VAR 0 1
51542: PUSH
51543: LD_EXP 110
51547: PUSH
51548: LD_VAR 0 3
51552: ARRAY
51553: IN
51554: OR
51555: IFFALSE 52802
// begin if un in mc_ape [ i ] then
51557: LD_VAR 0 1
51561: PUSH
51562: LD_EXP 109
51566: PUSH
51567: LD_VAR 0 3
51571: ARRAY
51572: IN
51573: IFFALSE 51612
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
51575: LD_ADDR_EXP 109
51579: PUSH
51580: LD_EXP 109
51584: PPUSH
51585: LD_VAR 0 3
51589: PPUSH
51590: LD_EXP 109
51594: PUSH
51595: LD_VAR 0 3
51599: ARRAY
51600: PUSH
51601: LD_VAR 0 1
51605: DIFF
51606: PPUSH
51607: CALL_OW 1
51611: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
51612: LD_VAR 0 1
51616: PUSH
51617: LD_EXP 110
51621: PUSH
51622: LD_VAR 0 3
51626: ARRAY
51627: IN
51628: IFFALSE 51652
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
51630: LD_ADDR_EXP 110
51634: PUSH
51635: LD_EXP 110
51639: PPUSH
51640: LD_VAR 0 3
51644: PPUSH
51645: EMPTY
51646: PPUSH
51647: CALL_OW 1
51651: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
51652: LD_VAR 0 1
51656: PPUSH
51657: CALL_OW 247
51661: PUSH
51662: LD_INT 2
51664: EQUAL
51665: IFFALSE 51746
51667: PUSH
51668: LD_VAR 0 1
51672: PPUSH
51673: CALL_OW 110
51677: PUSH
51678: LD_INT 20
51680: EQUAL
51681: IFTRUE 51701
51683: PUSH
51684: LD_VAR 0 1
51688: PUSH
51689: LD_EXP 102
51693: PUSH
51694: LD_VAR 0 3
51698: ARRAY
51699: IN
51700: OR
51701: IFTRUE 51745
51703: PUSH
51704: LD_VAR 0 1
51708: PPUSH
51709: CALL_OW 264
51713: PUSH
51714: LD_INT 12
51716: PUSH
51717: LD_INT 51
51719: PUSH
51720: LD_INT 89
51722: PUSH
51723: LD_INT 32
51725: PUSH
51726: LD_INT 13
51728: PUSH
51729: LD_INT 52
51731: PUSH
51732: LD_INT 31
51734: PUSH
51735: EMPTY
51736: LIST
51737: LIST
51738: LIST
51739: LIST
51740: LIST
51741: LIST
51742: LIST
51743: IN
51744: OR
51745: AND
51746: IFFALSE 52054
// begin if un in mc_defender [ i ] then
51748: LD_VAR 0 1
51752: PUSH
51753: LD_EXP 102
51757: PUSH
51758: LD_VAR 0 3
51762: ARRAY
51763: IN
51764: IFFALSE 51803
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51766: LD_ADDR_EXP 102
51770: PUSH
51771: LD_EXP 102
51775: PPUSH
51776: LD_VAR 0 3
51780: PPUSH
51781: LD_EXP 102
51785: PUSH
51786: LD_VAR 0 3
51790: ARRAY
51791: PUSH
51792: LD_VAR 0 1
51796: DIFF
51797: PPUSH
51798: CALL_OW 1
51802: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
51803: LD_ADDR_VAR 0 8
51807: PUSH
51808: LD_VAR 0 3
51812: PPUSH
51813: LD_INT 3
51815: PPUSH
51816: CALL 48342 0 2
51820: ST_TO_ADDR
// if fac then
51821: LD_VAR 0 8
51825: IFFALSE 52054
// begin for j in fac do
51827: LD_ADDR_VAR 0 4
51831: PUSH
51832: LD_VAR 0 8
51836: PUSH
51837: FOR_IN
51838: IFFALSE 52052
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
51840: LD_ADDR_VAR 0 9
51844: PUSH
51845: LD_VAR 0 8
51849: PPUSH
51850: LD_VAR 0 1
51854: PPUSH
51855: CALL_OW 265
51859: PPUSH
51860: LD_VAR 0 1
51864: PPUSH
51865: CALL_OW 262
51869: PPUSH
51870: LD_VAR 0 1
51874: PPUSH
51875: CALL_OW 263
51879: PPUSH
51880: LD_VAR 0 1
51884: PPUSH
51885: CALL_OW 264
51889: PPUSH
51890: CALL 56993 0 5
51894: ST_TO_ADDR
// if components then
51895: LD_VAR 0 9
51899: IFFALSE 52050
// begin if GetWeapon ( un ) = ar_control_tower then
51901: LD_VAR 0 1
51905: PPUSH
51906: CALL_OW 264
51910: PUSH
51911: LD_INT 31
51913: EQUAL
51914: IFFALSE 52031
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
51916: LD_VAR 0 1
51920: PPUSH
51921: CALL_OW 311
51925: PPUSH
51926: LD_INT 0
51928: PPUSH
51929: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
51933: LD_ADDR_EXP 120
51937: PUSH
51938: LD_EXP 120
51942: PPUSH
51943: LD_VAR 0 3
51947: PPUSH
51948: LD_EXP 120
51952: PUSH
51953: LD_VAR 0 3
51957: ARRAY
51958: PUSH
51959: LD_VAR 0 1
51963: PPUSH
51964: CALL_OW 311
51968: DIFF
51969: PPUSH
51970: CALL_OW 1
51974: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
51975: LD_ADDR_VAR 0 7
51979: PUSH
51980: LD_EXP 101
51984: PUSH
51985: LD_VAR 0 3
51989: ARRAY
51990: PPUSH
51991: LD_INT 1
51993: PPUSH
51994: LD_VAR 0 9
51998: PPUSH
51999: CALL_OW 2
52003: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
52004: LD_ADDR_EXP 101
52008: PUSH
52009: LD_EXP 101
52013: PPUSH
52014: LD_VAR 0 3
52018: PPUSH
52019: LD_VAR 0 7
52023: PPUSH
52024: CALL_OW 1
52028: ST_TO_ADDR
// end else
52029: GO 52048
// MC_InsertProduceList ( i , [ components ] ) ;
52031: LD_VAR 0 3
52035: PPUSH
52036: LD_VAR 0 9
52040: PUSH
52041: EMPTY
52042: LIST
52043: PPUSH
52044: CALL 47887 0 2
// break ;
52048: GO 52052
// end ; end ;
52050: GO 51837
52052: POP
52053: POP
// end ; end ; if GetType ( un ) = unit_building then
52054: LD_VAR 0 1
52058: PPUSH
52059: CALL_OW 247
52063: PUSH
52064: LD_INT 3
52066: EQUAL
52067: IFFALSE 52470
// begin btype := GetBType ( un ) ;
52069: LD_ADDR_VAR 0 5
52073: PUSH
52074: LD_VAR 0 1
52078: PPUSH
52079: CALL_OW 266
52083: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
52084: LD_VAR 0 5
52088: PUSH
52089: LD_INT 29
52091: PUSH
52092: LD_INT 30
52094: PUSH
52095: EMPTY
52096: LIST
52097: LIST
52098: IN
52099: IFFALSE 52172
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
52101: LD_VAR 0 1
52105: PPUSH
52106: CALL_OW 250
52110: PPUSH
52111: LD_VAR 0 1
52115: PPUSH
52116: CALL_OW 251
52120: PPUSH
52121: LD_VAR 0 1
52125: PPUSH
52126: CALL_OW 255
52130: PPUSH
52131: CALL_OW 440
52135: NOT
52136: IFFALSE 52172
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
52138: LD_VAR 0 1
52142: PPUSH
52143: CALL_OW 250
52147: PPUSH
52148: LD_VAR 0 1
52152: PPUSH
52153: CALL_OW 251
52157: PPUSH
52158: LD_VAR 0 1
52162: PPUSH
52163: CALL_OW 255
52167: PPUSH
52168: CALL_OW 441
// end ; if btype = b_warehouse then
52172: LD_VAR 0 5
52176: PUSH
52177: LD_INT 1
52179: EQUAL
52180: IFFALSE 52198
// begin btype := b_depot ;
52182: LD_ADDR_VAR 0 5
52186: PUSH
52187: LD_INT 0
52189: ST_TO_ADDR
// pos := 1 ;
52190: LD_ADDR_VAR 0 6
52194: PUSH
52195: LD_INT 1
52197: ST_TO_ADDR
// end ; if btype = b_factory then
52198: LD_VAR 0 5
52202: PUSH
52203: LD_INT 3
52205: EQUAL
52206: IFFALSE 52224
// begin btype := b_workshop ;
52208: LD_ADDR_VAR 0 5
52212: PUSH
52213: LD_INT 2
52215: ST_TO_ADDR
// pos := 1 ;
52216: LD_ADDR_VAR 0 6
52220: PUSH
52221: LD_INT 1
52223: ST_TO_ADDR
// end ; if btype = b_barracks then
52224: LD_VAR 0 5
52228: PUSH
52229: LD_INT 5
52231: EQUAL
52232: IFFALSE 52242
// btype := b_armoury ;
52234: LD_ADDR_VAR 0 5
52238: PUSH
52239: LD_INT 4
52241: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
52242: LD_VAR 0 5
52246: PUSH
52247: LD_INT 7
52249: PUSH
52250: LD_INT 8
52252: PUSH
52253: EMPTY
52254: LIST
52255: LIST
52256: IN
52257: IFFALSE 52267
// btype := b_lab ;
52259: LD_ADDR_VAR 0 5
52263: PUSH
52264: LD_INT 6
52266: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
52267: LD_ADDR_EXP 85
52271: PUSH
52272: LD_EXP 85
52276: PPUSH
52277: LD_VAR 0 3
52281: PUSH
52282: LD_EXP 85
52286: PUSH
52287: LD_VAR 0 3
52291: ARRAY
52292: PUSH
52293: LD_INT 1
52295: PLUS
52296: PUSH
52297: EMPTY
52298: LIST
52299: LIST
52300: PPUSH
52301: LD_VAR 0 5
52305: PUSH
52306: LD_VAR 0 1
52310: PPUSH
52311: CALL_OW 250
52315: PUSH
52316: LD_VAR 0 1
52320: PPUSH
52321: CALL_OW 251
52325: PUSH
52326: LD_VAR 0 1
52330: PPUSH
52331: CALL_OW 254
52335: PUSH
52336: EMPTY
52337: LIST
52338: LIST
52339: LIST
52340: LIST
52341: PPUSH
52342: CALL 59553 0 3
52346: ST_TO_ADDR
// if pos = 1 then
52347: LD_VAR 0 6
52351: PUSH
52352: LD_INT 1
52354: EQUAL
52355: IFFALSE 52470
// begin tmp := mc_build_list [ i ] ;
52357: LD_ADDR_VAR 0 7
52361: PUSH
52362: LD_EXP 85
52366: PUSH
52367: LD_VAR 0 3
52371: ARRAY
52372: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
52373: LD_VAR 0 7
52377: PPUSH
52378: LD_INT 2
52380: PUSH
52381: LD_INT 30
52383: PUSH
52384: LD_INT 0
52386: PUSH
52387: EMPTY
52388: LIST
52389: LIST
52390: PUSH
52391: LD_INT 30
52393: PUSH
52394: LD_INT 1
52396: PUSH
52397: EMPTY
52398: LIST
52399: LIST
52400: PUSH
52401: EMPTY
52402: LIST
52403: LIST
52404: LIST
52405: PPUSH
52406: CALL_OW 72
52410: IFFALSE 52420
// pos := 2 ;
52412: LD_ADDR_VAR 0 6
52416: PUSH
52417: LD_INT 2
52419: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
52420: LD_ADDR_VAR 0 7
52424: PUSH
52425: LD_VAR 0 7
52429: PPUSH
52430: LD_VAR 0 6
52434: PPUSH
52435: LD_VAR 0 7
52439: PPUSH
52440: CALL 59879 0 3
52444: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
52445: LD_ADDR_EXP 85
52449: PUSH
52450: LD_EXP 85
52454: PPUSH
52455: LD_VAR 0 3
52459: PPUSH
52460: LD_VAR 0 7
52464: PPUSH
52465: CALL_OW 1
52469: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
52470: LD_VAR 0 1
52474: PUSH
52475: LD_EXP 80
52479: PUSH
52480: LD_VAR 0 3
52484: ARRAY
52485: IN
52486: IFFALSE 52525
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
52488: LD_ADDR_EXP 80
52492: PUSH
52493: LD_EXP 80
52497: PPUSH
52498: LD_VAR 0 3
52502: PPUSH
52503: LD_EXP 80
52507: PUSH
52508: LD_VAR 0 3
52512: ARRAY
52513: PUSH
52514: LD_VAR 0 1
52518: DIFF
52519: PPUSH
52520: CALL_OW 1
52524: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
52525: LD_VAR 0 1
52529: PUSH
52530: LD_EXP 87
52534: PUSH
52535: LD_VAR 0 3
52539: ARRAY
52540: IN
52541: IFFALSE 52580
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
52543: LD_ADDR_EXP 87
52547: PUSH
52548: LD_EXP 87
52552: PPUSH
52553: LD_VAR 0 3
52557: PPUSH
52558: LD_EXP 87
52562: PUSH
52563: LD_VAR 0 3
52567: ARRAY
52568: PUSH
52569: LD_VAR 0 1
52573: DIFF
52574: PPUSH
52575: CALL_OW 1
52579: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
52580: LD_VAR 0 1
52584: PUSH
52585: LD_EXP 99
52589: PUSH
52590: LD_VAR 0 3
52594: ARRAY
52595: IN
52596: IFFALSE 52635
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
52598: LD_ADDR_EXP 99
52602: PUSH
52603: LD_EXP 99
52607: PPUSH
52608: LD_VAR 0 3
52612: PPUSH
52613: LD_EXP 99
52617: PUSH
52618: LD_VAR 0 3
52622: ARRAY
52623: PUSH
52624: LD_VAR 0 1
52628: DIFF
52629: PPUSH
52630: CALL_OW 1
52634: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
52635: LD_VAR 0 1
52639: PUSH
52640: LD_EXP 102
52644: PUSH
52645: LD_VAR 0 3
52649: ARRAY
52650: IN
52651: IFFALSE 52690
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
52653: LD_ADDR_EXP 102
52657: PUSH
52658: LD_EXP 102
52662: PPUSH
52663: LD_VAR 0 3
52667: PPUSH
52668: LD_EXP 102
52672: PUSH
52673: LD_VAR 0 3
52677: ARRAY
52678: PUSH
52679: LD_VAR 0 1
52683: DIFF
52684: PPUSH
52685: CALL_OW 1
52689: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
52690: LD_VAR 0 1
52694: PUSH
52695: LD_EXP 89
52699: PUSH
52700: LD_VAR 0 3
52704: ARRAY
52705: IN
52706: IFFALSE 52745
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
52708: LD_ADDR_EXP 89
52712: PUSH
52713: LD_EXP 89
52717: PPUSH
52718: LD_VAR 0 3
52722: PPUSH
52723: LD_EXP 89
52727: PUSH
52728: LD_VAR 0 3
52732: ARRAY
52733: PUSH
52734: LD_VAR 0 1
52738: DIFF
52739: PPUSH
52740: CALL_OW 1
52744: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
52745: LD_VAR 0 1
52749: PUSH
52750: LD_EXP 88
52754: PUSH
52755: LD_VAR 0 3
52759: ARRAY
52760: IN
52761: IFFALSE 52800
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
52763: LD_ADDR_EXP 88
52767: PUSH
52768: LD_EXP 88
52772: PPUSH
52773: LD_VAR 0 3
52777: PPUSH
52778: LD_EXP 88
52782: PUSH
52783: LD_VAR 0 3
52787: ARRAY
52788: PUSH
52789: LD_VAR 0 1
52793: DIFF
52794: PPUSH
52795: CALL_OW 1
52799: ST_TO_ADDR
// end ; break ;
52800: GO 52804
// end ;
52802: GO 51436
52804: POP
52805: POP
// end ;
52806: LD_VAR 0 2
52810: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
52811: LD_INT 0
52813: PPUSH
52814: PPUSH
52815: PPUSH
// if not mc_bases or not skirmish then
52816: LD_EXP 80
52820: NOT
52821: IFTRUE 52830
52823: PUSH
52824: LD_EXP 78
52828: NOT
52829: OR
52830: IFFALSE 52834
// exit ;
52832: GO 53049
// for i = 1 to mc_bases do
52834: LD_ADDR_VAR 0 3
52838: PUSH
52839: DOUBLE
52840: LD_INT 1
52842: DEC
52843: ST_TO_ADDR
52844: LD_EXP 80
52848: PUSH
52849: FOR_TO
52850: IFFALSE 53047
// begin if building in mc_construct_list [ i ] then
52852: LD_VAR 0 1
52856: PUSH
52857: LD_EXP 87
52861: PUSH
52862: LD_VAR 0 3
52866: ARRAY
52867: IN
52868: IFFALSE 53045
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52870: LD_ADDR_EXP 87
52874: PUSH
52875: LD_EXP 87
52879: PPUSH
52880: LD_VAR 0 3
52884: PPUSH
52885: LD_EXP 87
52889: PUSH
52890: LD_VAR 0 3
52894: ARRAY
52895: PUSH
52896: LD_VAR 0 1
52900: DIFF
52901: PPUSH
52902: CALL_OW 1
52906: ST_TO_ADDR
// if building in mc_lab [ i ] then
52907: LD_VAR 0 1
52911: PUSH
52912: LD_EXP 113
52916: PUSH
52917: LD_VAR 0 3
52921: ARRAY
52922: IN
52923: IFFALSE 52978
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
52925: LD_ADDR_EXP 114
52929: PUSH
52930: LD_EXP 114
52934: PPUSH
52935: LD_VAR 0 3
52939: PPUSH
52940: LD_EXP 114
52944: PUSH
52945: LD_VAR 0 3
52949: ARRAY
52950: PPUSH
52951: LD_INT 1
52953: PPUSH
52954: LD_EXP 114
52958: PUSH
52959: LD_VAR 0 3
52963: ARRAY
52964: PPUSH
52965: LD_INT 0
52967: PPUSH
52968: CALL 58961 0 4
52972: PPUSH
52973: CALL_OW 1
52977: ST_TO_ADDR
// if not building in mc_bases [ i ] then
52978: LD_VAR 0 1
52982: PUSH
52983: LD_EXP 80
52987: PUSH
52988: LD_VAR 0 3
52992: ARRAY
52993: IN
52994: NOT
52995: IFFALSE 53041
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52997: LD_ADDR_EXP 80
53001: PUSH
53002: LD_EXP 80
53006: PPUSH
53007: LD_VAR 0 3
53011: PUSH
53012: LD_EXP 80
53016: PUSH
53017: LD_VAR 0 3
53021: ARRAY
53022: PUSH
53023: LD_INT 1
53025: PLUS
53026: PUSH
53027: EMPTY
53028: LIST
53029: LIST
53030: PPUSH
53031: LD_VAR 0 1
53035: PPUSH
53036: CALL 59553 0 3
53040: ST_TO_ADDR
// exit ;
53041: POP
53042: POP
53043: GO 53049
// end ; end ;
53045: GO 52849
53047: POP
53048: POP
// end ;
53049: LD_VAR 0 2
53053: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
53054: LD_INT 0
53056: PPUSH
53057: PPUSH
53058: PPUSH
53059: PPUSH
53060: PPUSH
53061: PPUSH
53062: PPUSH
// if not mc_bases or not skirmish then
53063: LD_EXP 80
53067: NOT
53068: IFTRUE 53077
53070: PUSH
53071: LD_EXP 78
53075: NOT
53076: OR
53077: IFFALSE 53081
// exit ;
53079: GO 53742
// for i = 1 to mc_bases do
53081: LD_ADDR_VAR 0 3
53085: PUSH
53086: DOUBLE
53087: LD_INT 1
53089: DEC
53090: ST_TO_ADDR
53091: LD_EXP 80
53095: PUSH
53096: FOR_TO
53097: IFFALSE 53740
// begin if building in mc_construct_list [ i ] then
53099: LD_VAR 0 1
53103: PUSH
53104: LD_EXP 87
53108: PUSH
53109: LD_VAR 0 3
53113: ARRAY
53114: IN
53115: IFFALSE 53738
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
53117: LD_ADDR_EXP 87
53121: PUSH
53122: LD_EXP 87
53126: PPUSH
53127: LD_VAR 0 3
53131: PPUSH
53132: LD_EXP 87
53136: PUSH
53137: LD_VAR 0 3
53141: ARRAY
53142: PUSH
53143: LD_VAR 0 1
53147: DIFF
53148: PPUSH
53149: CALL_OW 1
53153: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
53154: LD_ADDR_EXP 80
53158: PUSH
53159: LD_EXP 80
53163: PPUSH
53164: LD_VAR 0 3
53168: PUSH
53169: LD_EXP 80
53173: PUSH
53174: LD_VAR 0 3
53178: ARRAY
53179: PUSH
53180: LD_INT 1
53182: PLUS
53183: PUSH
53184: EMPTY
53185: LIST
53186: LIST
53187: PPUSH
53188: LD_VAR 0 1
53192: PPUSH
53193: CALL 59553 0 3
53197: ST_TO_ADDR
// btype := GetBType ( building ) ;
53198: LD_ADDR_VAR 0 5
53202: PUSH
53203: LD_VAR 0 1
53207: PPUSH
53208: CALL_OW 266
53212: ST_TO_ADDR
// side := GetSide ( building ) ;
53213: LD_ADDR_VAR 0 8
53217: PUSH
53218: LD_VAR 0 1
53222: PPUSH
53223: CALL_OW 255
53227: ST_TO_ADDR
// if btype = b_lab then
53228: LD_VAR 0 5
53232: PUSH
53233: LD_INT 6
53235: EQUAL
53236: IFFALSE 53286
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
53238: LD_ADDR_EXP 113
53242: PUSH
53243: LD_EXP 113
53247: PPUSH
53248: LD_VAR 0 3
53252: PUSH
53253: LD_EXP 113
53257: PUSH
53258: LD_VAR 0 3
53262: ARRAY
53263: PUSH
53264: LD_INT 1
53266: PLUS
53267: PUSH
53268: EMPTY
53269: LIST
53270: LIST
53271: PPUSH
53272: LD_VAR 0 1
53276: PPUSH
53277: CALL 59553 0 3
53281: ST_TO_ADDR
// exit ;
53282: POP
53283: POP
53284: GO 53742
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
53286: LD_VAR 0 5
53290: PUSH
53291: LD_INT 0
53293: PUSH
53294: LD_INT 2
53296: PUSH
53297: LD_INT 4
53299: PUSH
53300: EMPTY
53301: LIST
53302: LIST
53303: LIST
53304: IN
53305: IFFALSE 53429
// begin if btype = b_armoury then
53307: LD_VAR 0 5
53311: PUSH
53312: LD_INT 4
53314: EQUAL
53315: IFFALSE 53325
// btype := b_barracks ;
53317: LD_ADDR_VAR 0 5
53321: PUSH
53322: LD_INT 5
53324: ST_TO_ADDR
// if btype = b_depot then
53325: LD_VAR 0 5
53329: PUSH
53330: LD_INT 0
53332: EQUAL
53333: IFFALSE 53343
// btype := b_warehouse ;
53335: LD_ADDR_VAR 0 5
53339: PUSH
53340: LD_INT 1
53342: ST_TO_ADDR
// if btype = b_workshop then
53343: LD_VAR 0 5
53347: PUSH
53348: LD_INT 2
53350: EQUAL
53351: IFFALSE 53361
// btype := b_factory ;
53353: LD_ADDR_VAR 0 5
53357: PUSH
53358: LD_INT 3
53360: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
53361: LD_VAR 0 5
53365: PPUSH
53366: LD_VAR 0 8
53370: PPUSH
53371: CALL_OW 323
53375: PUSH
53376: LD_INT 1
53378: EQUAL
53379: IFFALSE 53425
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
53381: LD_ADDR_EXP 112
53385: PUSH
53386: LD_EXP 112
53390: PPUSH
53391: LD_VAR 0 3
53395: PUSH
53396: LD_EXP 112
53400: PUSH
53401: LD_VAR 0 3
53405: ARRAY
53406: PUSH
53407: LD_INT 1
53409: PLUS
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: PPUSH
53415: LD_VAR 0 1
53419: PPUSH
53420: CALL 59553 0 3
53424: ST_TO_ADDR
// exit ;
53425: POP
53426: POP
53427: GO 53742
// end ; if btype in [ b_bunker , b_turret ] then
53429: LD_VAR 0 5
53433: PUSH
53434: LD_INT 32
53436: PUSH
53437: LD_INT 33
53439: PUSH
53440: EMPTY
53441: LIST
53442: LIST
53443: IN
53444: IFFALSE 53734
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
53446: LD_ADDR_EXP 88
53450: PUSH
53451: LD_EXP 88
53455: PPUSH
53456: LD_VAR 0 3
53460: PUSH
53461: LD_EXP 88
53465: PUSH
53466: LD_VAR 0 3
53470: ARRAY
53471: PUSH
53472: LD_INT 1
53474: PLUS
53475: PUSH
53476: EMPTY
53477: LIST
53478: LIST
53479: PPUSH
53480: LD_VAR 0 1
53484: PPUSH
53485: CALL 59553 0 3
53489: ST_TO_ADDR
// if btype = b_bunker then
53490: LD_VAR 0 5
53494: PUSH
53495: LD_INT 32
53497: EQUAL
53498: IFFALSE 53734
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
53500: LD_ADDR_EXP 89
53504: PUSH
53505: LD_EXP 89
53509: PPUSH
53510: LD_VAR 0 3
53514: PUSH
53515: LD_EXP 89
53519: PUSH
53520: LD_VAR 0 3
53524: ARRAY
53525: PUSH
53526: LD_INT 1
53528: PLUS
53529: PUSH
53530: EMPTY
53531: LIST
53532: LIST
53533: PPUSH
53534: LD_VAR 0 1
53538: PPUSH
53539: CALL 59553 0 3
53543: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
53544: LD_ADDR_VAR 0 6
53548: PUSH
53549: LD_EXP 80
53553: PUSH
53554: LD_VAR 0 3
53558: ARRAY
53559: PPUSH
53560: LD_INT 25
53562: PUSH
53563: LD_INT 1
53565: PUSH
53566: EMPTY
53567: LIST
53568: LIST
53569: PUSH
53570: LD_INT 3
53572: PUSH
53573: LD_INT 54
53575: PUSH
53576: EMPTY
53577: LIST
53578: PUSH
53579: EMPTY
53580: LIST
53581: LIST
53582: PUSH
53583: EMPTY
53584: LIST
53585: LIST
53586: PPUSH
53587: CALL_OW 72
53591: ST_TO_ADDR
// if tmp then
53592: LD_VAR 0 6
53596: IFFALSE 53602
// exit ;
53598: POP
53599: POP
53600: GO 53742
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53602: LD_ADDR_VAR 0 6
53606: PUSH
53607: LD_EXP 80
53611: PUSH
53612: LD_VAR 0 3
53616: ARRAY
53617: PPUSH
53618: LD_INT 2
53620: PUSH
53621: LD_INT 30
53623: PUSH
53624: LD_INT 4
53626: PUSH
53627: EMPTY
53628: LIST
53629: LIST
53630: PUSH
53631: LD_INT 30
53633: PUSH
53634: LD_INT 5
53636: PUSH
53637: EMPTY
53638: LIST
53639: LIST
53640: PUSH
53641: EMPTY
53642: LIST
53643: LIST
53644: LIST
53645: PPUSH
53646: CALL_OW 72
53650: ST_TO_ADDR
// if not tmp then
53651: LD_VAR 0 6
53655: NOT
53656: IFFALSE 53662
// exit ;
53658: POP
53659: POP
53660: GO 53742
// for j in tmp do
53662: LD_ADDR_VAR 0 4
53666: PUSH
53667: LD_VAR 0 6
53671: PUSH
53672: FOR_IN
53673: IFFALSE 53732
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
53675: LD_ADDR_VAR 0 7
53679: PUSH
53680: LD_VAR 0 4
53684: PPUSH
53685: CALL_OW 313
53689: PPUSH
53690: LD_INT 25
53692: PUSH
53693: LD_INT 1
53695: PUSH
53696: EMPTY
53697: LIST
53698: LIST
53699: PPUSH
53700: CALL_OW 72
53704: ST_TO_ADDR
// if units then
53705: LD_VAR 0 7
53709: IFFALSE 53730
// begin ComExitBuilding ( units [ 1 ] ) ;
53711: LD_VAR 0 7
53715: PUSH
53716: LD_INT 1
53718: ARRAY
53719: PPUSH
53720: CALL_OW 122
// exit ;
53724: POP
53725: POP
53726: POP
53727: POP
53728: GO 53742
// end ; end ;
53730: GO 53672
53732: POP
53733: POP
// end ; end ; exit ;
53734: POP
53735: POP
53736: GO 53742
// end ; end ;
53738: GO 53096
53740: POP
53741: POP
// end ;
53742: LD_VAR 0 2
53746: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
53747: LD_INT 0
53749: PPUSH
53750: PPUSH
53751: PPUSH
53752: PPUSH
53753: PPUSH
53754: PPUSH
53755: PPUSH
// if not mc_bases or not skirmish then
53756: LD_EXP 80
53760: NOT
53761: IFTRUE 53770
53763: PUSH
53764: LD_EXP 78
53768: NOT
53769: OR
53770: IFFALSE 53774
// exit ;
53772: GO 54039
// btype := GetBType ( building ) ;
53774: LD_ADDR_VAR 0 6
53778: PUSH
53779: LD_VAR 0 1
53783: PPUSH
53784: CALL_OW 266
53788: ST_TO_ADDR
// x := GetX ( building ) ;
53789: LD_ADDR_VAR 0 7
53793: PUSH
53794: LD_VAR 0 1
53798: PPUSH
53799: CALL_OW 250
53803: ST_TO_ADDR
// y := GetY ( building ) ;
53804: LD_ADDR_VAR 0 8
53808: PUSH
53809: LD_VAR 0 1
53813: PPUSH
53814: CALL_OW 251
53818: ST_TO_ADDR
// d := GetDir ( building ) ;
53819: LD_ADDR_VAR 0 9
53823: PUSH
53824: LD_VAR 0 1
53828: PPUSH
53829: CALL_OW 254
53833: ST_TO_ADDR
// for i = 1 to mc_bases do
53834: LD_ADDR_VAR 0 4
53838: PUSH
53839: DOUBLE
53840: LD_INT 1
53842: DEC
53843: ST_TO_ADDR
53844: LD_EXP 80
53848: PUSH
53849: FOR_TO
53850: IFFALSE 54037
// begin if not mc_build_list [ i ] then
53852: LD_EXP 85
53856: PUSH
53857: LD_VAR 0 4
53861: ARRAY
53862: NOT
53863: IFFALSE 53867
// continue ;
53865: GO 53849
// for j := 1 to mc_build_list [ i ] do
53867: LD_ADDR_VAR 0 5
53871: PUSH
53872: DOUBLE
53873: LD_INT 1
53875: DEC
53876: ST_TO_ADDR
53877: LD_EXP 85
53881: PUSH
53882: LD_VAR 0 4
53886: ARRAY
53887: PUSH
53888: FOR_TO
53889: IFFALSE 54033
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
53891: LD_VAR 0 6
53895: PUSH
53896: LD_VAR 0 7
53900: PUSH
53901: LD_VAR 0 8
53905: PUSH
53906: LD_VAR 0 9
53910: PUSH
53911: EMPTY
53912: LIST
53913: LIST
53914: LIST
53915: LIST
53916: PPUSH
53917: LD_EXP 85
53921: PUSH
53922: LD_VAR 0 4
53926: ARRAY
53927: PUSH
53928: LD_VAR 0 5
53932: ARRAY
53933: PPUSH
53934: CALL 66160 0 2
53938: IFFALSE 54031
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
53940: LD_ADDR_EXP 85
53944: PUSH
53945: LD_EXP 85
53949: PPUSH
53950: LD_VAR 0 4
53954: PPUSH
53955: LD_EXP 85
53959: PUSH
53960: LD_VAR 0 4
53964: ARRAY
53965: PPUSH
53966: LD_VAR 0 5
53970: PPUSH
53971: CALL_OW 3
53975: PPUSH
53976: CALL_OW 1
53980: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
53981: LD_ADDR_EXP 87
53985: PUSH
53986: LD_EXP 87
53990: PPUSH
53991: LD_VAR 0 4
53995: PUSH
53996: LD_EXP 87
54000: PUSH
54001: LD_VAR 0 4
54005: ARRAY
54006: PUSH
54007: LD_INT 1
54009: PLUS
54010: PUSH
54011: EMPTY
54012: LIST
54013: LIST
54014: PPUSH
54015: LD_VAR 0 1
54019: PPUSH
54020: CALL 59553 0 3
54024: ST_TO_ADDR
// exit ;
54025: POP
54026: POP
54027: POP
54028: POP
54029: GO 54039
// end ;
54031: GO 53888
54033: POP
54034: POP
// end ;
54035: GO 53849
54037: POP
54038: POP
// end ;
54039: LD_VAR 0 3
54043: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
54044: LD_INT 0
54046: PPUSH
54047: PPUSH
54048: PPUSH
// if not mc_bases or not skirmish then
54049: LD_EXP 80
54053: NOT
54054: IFTRUE 54063
54056: PUSH
54057: LD_EXP 78
54061: NOT
54062: OR
54063: IFFALSE 54067
// exit ;
54065: GO 54263
// for i = 1 to mc_bases do
54067: LD_ADDR_VAR 0 4
54071: PUSH
54072: DOUBLE
54073: LD_INT 1
54075: DEC
54076: ST_TO_ADDR
54077: LD_EXP 80
54081: PUSH
54082: FOR_TO
54083: IFFALSE 54172
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
54085: LD_VAR 0 1
54089: PUSH
54090: LD_EXP 88
54094: PUSH
54095: LD_VAR 0 4
54099: ARRAY
54100: IN
54101: IFFALSE 54122
54103: PUSH
54104: LD_VAR 0 1
54108: PUSH
54109: LD_EXP 89
54113: PUSH
54114: LD_VAR 0 4
54118: ARRAY
54119: IN
54120: NOT
54121: AND
54122: IFFALSE 54170
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
54124: LD_ADDR_EXP 89
54128: PUSH
54129: LD_EXP 89
54133: PPUSH
54134: LD_VAR 0 4
54138: PUSH
54139: LD_EXP 89
54143: PUSH
54144: LD_VAR 0 4
54148: ARRAY
54149: PUSH
54150: LD_INT 1
54152: PLUS
54153: PUSH
54154: EMPTY
54155: LIST
54156: LIST
54157: PPUSH
54158: LD_VAR 0 1
54162: PPUSH
54163: CALL 59553 0 3
54167: ST_TO_ADDR
// break ;
54168: GO 54172
// end ; end ;
54170: GO 54082
54172: POP
54173: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
54174: LD_VAR 0 1
54178: PPUSH
54179: CALL_OW 257
54183: PUSH
54184: LD_EXP 106
54188: IN
54189: IFFALSE 54206
54191: PUSH
54192: LD_VAR 0 1
54196: PPUSH
54197: CALL_OW 266
54201: PUSH
54202: LD_INT 5
54204: EQUAL
54205: AND
54206: IFFALSE 54223
54208: PUSH
54209: LD_VAR 0 2
54213: PPUSH
54214: CALL_OW 110
54218: PUSH
54219: LD_INT 18
54221: NONEQUAL
54222: AND
54223: IFFALSE 54263
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
54225: LD_VAR 0 2
54229: PPUSH
54230: CALL_OW 257
54234: PUSH
54235: LD_INT 5
54237: PUSH
54238: LD_INT 8
54240: PUSH
54241: LD_INT 9
54243: PUSH
54244: EMPTY
54245: LIST
54246: LIST
54247: LIST
54248: IN
54249: IFFALSE 54263
// SetClass ( unit , 1 ) ;
54251: LD_VAR 0 2
54255: PPUSH
54256: LD_INT 1
54258: PPUSH
54259: CALL_OW 336
// end ;
54263: LD_VAR 0 3
54267: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
54268: LD_INT 0
54270: PPUSH
54271: PPUSH
// if not mc_bases or not skirmish then
54272: LD_EXP 80
54276: NOT
54277: IFTRUE 54286
54279: PUSH
54280: LD_EXP 78
54284: NOT
54285: OR
54286: IFFALSE 54290
// exit ;
54288: GO 54406
// if GetLives ( abandoned_vehicle ) > 250 then
54290: LD_VAR 0 2
54294: PPUSH
54295: CALL_OW 256
54299: PUSH
54300: LD_INT 250
54302: GREATER
54303: IFFALSE 54307
// exit ;
54305: GO 54406
// for i = 1 to mc_bases do
54307: LD_ADDR_VAR 0 6
54311: PUSH
54312: DOUBLE
54313: LD_INT 1
54315: DEC
54316: ST_TO_ADDR
54317: LD_EXP 80
54321: PUSH
54322: FOR_TO
54323: IFFALSE 54404
// begin if driver in mc_bases [ i ] then
54325: LD_VAR 0 1
54329: PUSH
54330: LD_EXP 80
54334: PUSH
54335: LD_VAR 0 6
54339: ARRAY
54340: IN
54341: IFFALSE 54402
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
54343: LD_VAR 0 1
54347: PPUSH
54348: LD_EXP 80
54352: PUSH
54353: LD_VAR 0 6
54357: ARRAY
54358: PPUSH
54359: LD_INT 2
54361: PUSH
54362: LD_INT 30
54364: PUSH
54365: LD_INT 0
54367: PUSH
54368: EMPTY
54369: LIST
54370: LIST
54371: PUSH
54372: LD_INT 30
54374: PUSH
54375: LD_INT 1
54377: PUSH
54378: EMPTY
54379: LIST
54380: LIST
54381: PUSH
54382: EMPTY
54383: LIST
54384: LIST
54385: LIST
54386: PPUSH
54387: CALL_OW 72
54391: PUSH
54392: LD_INT 1
54394: ARRAY
54395: PPUSH
54396: CALL 93480 0 2
// break ;
54400: GO 54404
// end ; end ;
54402: GO 54322
54404: POP
54405: POP
// end ; end_of_file
54406: LD_VAR 0 5
54410: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
54411: LD_INT 0
54413: PPUSH
54414: PPUSH
// if exist_mode then
54415: LD_VAR 0 2
54419: IFFALSE 54465
// begin unit := CreateCharacter ( prefix & ident ) ;
54421: LD_ADDR_VAR 0 5
54425: PUSH
54426: LD_VAR 0 3
54430: PUSH
54431: LD_VAR 0 1
54435: STR
54436: PPUSH
54437: CALL_OW 34
54441: ST_TO_ADDR
// if unit then
54442: LD_VAR 0 5
54446: IFFALSE 54463
// DeleteCharacters ( prefix & ident ) ;
54448: LD_VAR 0 3
54452: PUSH
54453: LD_VAR 0 1
54457: STR
54458: PPUSH
54459: CALL_OW 40
// end else
54463: GO 54480
// unit := NewCharacter ( ident ) ;
54465: LD_ADDR_VAR 0 5
54469: PUSH
54470: LD_VAR 0 1
54474: PPUSH
54475: CALL_OW 25
54479: ST_TO_ADDR
// result := unit ;
54480: LD_ADDR_VAR 0 4
54484: PUSH
54485: LD_VAR 0 5
54489: ST_TO_ADDR
// end ;
54490: LD_VAR 0 4
54494: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
54495: LD_INT 0
54497: PPUSH
54498: PPUSH
// if exist_mode then
54499: LD_VAR 0 2
54503: IFFALSE 54528
// unit := CreateCharacter ( prefix & ident ) else
54505: LD_ADDR_VAR 0 5
54509: PUSH
54510: LD_VAR 0 3
54514: PUSH
54515: LD_VAR 0 1
54519: STR
54520: PPUSH
54521: CALL_OW 34
54525: ST_TO_ADDR
54526: GO 54543
// unit := NewCharacter ( ident ) ;
54528: LD_ADDR_VAR 0 5
54532: PUSH
54533: LD_VAR 0 1
54537: PPUSH
54538: CALL_OW 25
54542: ST_TO_ADDR
// result := unit ;
54543: LD_ADDR_VAR 0 4
54547: PUSH
54548: LD_VAR 0 5
54552: ST_TO_ADDR
// end ;
54553: LD_VAR 0 4
54557: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
54558: LD_INT 0
54560: PPUSH
54561: PPUSH
// if not side or not nation then
54562: LD_VAR 0 1
54566: NOT
54567: IFTRUE 54576
54569: PUSH
54570: LD_VAR 0 2
54574: NOT
54575: OR
54576: IFFALSE 54580
// exit ;
54578: GO 55374
// case nation of nation_american :
54580: LD_VAR 0 2
54584: PUSH
54585: LD_INT 1
54587: DOUBLE
54588: EQUAL
54589: IFTRUE 54593
54591: GO 54815
54593: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 , 90 , 93 ] ; nation_arabian :
54594: LD_ADDR_VAR 0 4
54598: PUSH
54599: LD_INT 35
54601: PUSH
54602: LD_INT 45
54604: PUSH
54605: LD_INT 46
54607: PUSH
54608: LD_INT 47
54610: PUSH
54611: LD_INT 82
54613: PUSH
54614: LD_INT 83
54616: PUSH
54617: LD_INT 84
54619: PUSH
54620: LD_INT 85
54622: PUSH
54623: LD_INT 86
54625: PUSH
54626: LD_INT 1
54628: PUSH
54629: LD_INT 2
54631: PUSH
54632: LD_INT 6
54634: PUSH
54635: LD_INT 15
54637: PUSH
54638: LD_INT 16
54640: PUSH
54641: LD_INT 7
54643: PUSH
54644: LD_INT 12
54646: PUSH
54647: LD_INT 13
54649: PUSH
54650: LD_INT 10
54652: PUSH
54653: LD_INT 14
54655: PUSH
54656: LD_INT 20
54658: PUSH
54659: LD_INT 21
54661: PUSH
54662: LD_INT 22
54664: PUSH
54665: LD_INT 25
54667: PUSH
54668: LD_INT 32
54670: PUSH
54671: LD_INT 27
54673: PUSH
54674: LD_INT 36
54676: PUSH
54677: LD_INT 69
54679: PUSH
54680: LD_INT 39
54682: PUSH
54683: LD_INT 34
54685: PUSH
54686: LD_INT 40
54688: PUSH
54689: LD_INT 48
54691: PUSH
54692: LD_INT 49
54694: PUSH
54695: LD_INT 50
54697: PUSH
54698: LD_INT 51
54700: PUSH
54701: LD_INT 52
54703: PUSH
54704: LD_INT 53
54706: PUSH
54707: LD_INT 54
54709: PUSH
54710: LD_INT 55
54712: PUSH
54713: LD_INT 56
54715: PUSH
54716: LD_INT 57
54718: PUSH
54719: LD_INT 58
54721: PUSH
54722: LD_INT 59
54724: PUSH
54725: LD_INT 60
54727: PUSH
54728: LD_INT 61
54730: PUSH
54731: LD_INT 62
54733: PUSH
54734: LD_INT 80
54736: PUSH
54737: LD_INT 82
54739: PUSH
54740: LD_INT 83
54742: PUSH
54743: LD_INT 84
54745: PUSH
54746: LD_INT 85
54748: PUSH
54749: LD_INT 86
54751: PUSH
54752: LD_INT 90
54754: PUSH
54755: LD_INT 93
54757: PUSH
54758: EMPTY
54759: LIST
54760: LIST
54761: LIST
54762: LIST
54763: LIST
54764: LIST
54765: LIST
54766: LIST
54767: LIST
54768: LIST
54769: LIST
54770: LIST
54771: LIST
54772: LIST
54773: LIST
54774: LIST
54775: LIST
54776: LIST
54777: LIST
54778: LIST
54779: LIST
54780: LIST
54781: LIST
54782: LIST
54783: LIST
54784: LIST
54785: LIST
54786: LIST
54787: LIST
54788: LIST
54789: LIST
54790: LIST
54791: LIST
54792: LIST
54793: LIST
54794: LIST
54795: LIST
54796: LIST
54797: LIST
54798: LIST
54799: LIST
54800: LIST
54801: LIST
54802: LIST
54803: LIST
54804: LIST
54805: LIST
54806: LIST
54807: LIST
54808: LIST
54809: LIST
54810: LIST
54811: LIST
54812: ST_TO_ADDR
54813: GO 55296
54815: LD_INT 2
54817: DOUBLE
54818: EQUAL
54819: IFTRUE 54823
54821: GO 55057
54823: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 , 92 , 94 ] ; nation_russian :
54824: LD_ADDR_VAR 0 4
54828: PUSH
54829: LD_INT 35
54831: PUSH
54832: LD_INT 45
54834: PUSH
54835: LD_INT 46
54837: PUSH
54838: LD_INT 47
54840: PUSH
54841: LD_INT 82
54843: PUSH
54844: LD_INT 83
54846: PUSH
54847: LD_INT 84
54849: PUSH
54850: LD_INT 85
54852: PUSH
54853: LD_INT 87
54855: PUSH
54856: LD_INT 70
54858: PUSH
54859: LD_INT 1
54861: PUSH
54862: LD_INT 11
54864: PUSH
54865: LD_INT 3
54867: PUSH
54868: LD_INT 4
54870: PUSH
54871: LD_INT 5
54873: PUSH
54874: LD_INT 6
54876: PUSH
54877: LD_INT 15
54879: PUSH
54880: LD_INT 18
54882: PUSH
54883: LD_INT 7
54885: PUSH
54886: LD_INT 17
54888: PUSH
54889: LD_INT 8
54891: PUSH
54892: LD_INT 20
54894: PUSH
54895: LD_INT 21
54897: PUSH
54898: LD_INT 22
54900: PUSH
54901: LD_INT 72
54903: PUSH
54904: LD_INT 26
54906: PUSH
54907: LD_INT 69
54909: PUSH
54910: LD_INT 39
54912: PUSH
54913: LD_INT 40
54915: PUSH
54916: LD_INT 41
54918: PUSH
54919: LD_INT 42
54921: PUSH
54922: LD_INT 43
54924: PUSH
54925: LD_INT 48
54927: PUSH
54928: LD_INT 49
54930: PUSH
54931: LD_INT 50
54933: PUSH
54934: LD_INT 51
54936: PUSH
54937: LD_INT 52
54939: PUSH
54940: LD_INT 53
54942: PUSH
54943: LD_INT 54
54945: PUSH
54946: LD_INT 55
54948: PUSH
54949: LD_INT 56
54951: PUSH
54952: LD_INT 60
54954: PUSH
54955: LD_INT 61
54957: PUSH
54958: LD_INT 62
54960: PUSH
54961: LD_INT 66
54963: PUSH
54964: LD_INT 67
54966: PUSH
54967: LD_INT 68
54969: PUSH
54970: LD_INT 81
54972: PUSH
54973: LD_INT 82
54975: PUSH
54976: LD_INT 83
54978: PUSH
54979: LD_INT 84
54981: PUSH
54982: LD_INT 85
54984: PUSH
54985: LD_INT 87
54987: PUSH
54988: LD_INT 88
54990: PUSH
54991: LD_INT 92
54993: PUSH
54994: LD_INT 94
54996: PUSH
54997: EMPTY
54998: LIST
54999: LIST
55000: LIST
55001: LIST
55002: LIST
55003: LIST
55004: LIST
55005: LIST
55006: LIST
55007: LIST
55008: LIST
55009: LIST
55010: LIST
55011: LIST
55012: LIST
55013: LIST
55014: LIST
55015: LIST
55016: LIST
55017: LIST
55018: LIST
55019: LIST
55020: LIST
55021: LIST
55022: LIST
55023: LIST
55024: LIST
55025: LIST
55026: LIST
55027: LIST
55028: LIST
55029: LIST
55030: LIST
55031: LIST
55032: LIST
55033: LIST
55034: LIST
55035: LIST
55036: LIST
55037: LIST
55038: LIST
55039: LIST
55040: LIST
55041: LIST
55042: LIST
55043: LIST
55044: LIST
55045: LIST
55046: LIST
55047: LIST
55048: LIST
55049: LIST
55050: LIST
55051: LIST
55052: LIST
55053: LIST
55054: ST_TO_ADDR
55055: GO 55296
55057: LD_INT 3
55059: DOUBLE
55060: EQUAL
55061: IFTRUE 55065
55063: GO 55295
55065: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 , 89 , 91 ] ; end ;
55066: LD_ADDR_VAR 0 4
55070: PUSH
55071: LD_INT 46
55073: PUSH
55074: LD_INT 47
55076: PUSH
55077: LD_INT 1
55079: PUSH
55080: LD_INT 2
55082: PUSH
55083: LD_INT 82
55085: PUSH
55086: LD_INT 83
55088: PUSH
55089: LD_INT 84
55091: PUSH
55092: LD_INT 85
55094: PUSH
55095: LD_INT 86
55097: PUSH
55098: LD_INT 11
55100: PUSH
55101: LD_INT 9
55103: PUSH
55104: LD_INT 20
55106: PUSH
55107: LD_INT 19
55109: PUSH
55110: LD_INT 21
55112: PUSH
55113: LD_INT 24
55115: PUSH
55116: LD_INT 22
55118: PUSH
55119: LD_INT 25
55121: PUSH
55122: LD_INT 28
55124: PUSH
55125: LD_INT 29
55127: PUSH
55128: LD_INT 30
55130: PUSH
55131: LD_INT 31
55133: PUSH
55134: LD_INT 37
55136: PUSH
55137: LD_INT 38
55139: PUSH
55140: LD_INT 32
55142: PUSH
55143: LD_INT 27
55145: PUSH
55146: LD_INT 33
55148: PUSH
55149: LD_INT 69
55151: PUSH
55152: LD_INT 39
55154: PUSH
55155: LD_INT 34
55157: PUSH
55158: LD_INT 40
55160: PUSH
55161: LD_INT 71
55163: PUSH
55164: LD_INT 23
55166: PUSH
55167: LD_INT 44
55169: PUSH
55170: LD_INT 48
55172: PUSH
55173: LD_INT 49
55175: PUSH
55176: LD_INT 50
55178: PUSH
55179: LD_INT 51
55181: PUSH
55182: LD_INT 52
55184: PUSH
55185: LD_INT 53
55187: PUSH
55188: LD_INT 54
55190: PUSH
55191: LD_INT 55
55193: PUSH
55194: LD_INT 56
55196: PUSH
55197: LD_INT 57
55199: PUSH
55200: LD_INT 58
55202: PUSH
55203: LD_INT 59
55205: PUSH
55206: LD_INT 63
55208: PUSH
55209: LD_INT 64
55211: PUSH
55212: LD_INT 65
55214: PUSH
55215: LD_INT 82
55217: PUSH
55218: LD_INT 83
55220: PUSH
55221: LD_INT 84
55223: PUSH
55224: LD_INT 85
55226: PUSH
55227: LD_INT 86
55229: PUSH
55230: LD_INT 89
55232: PUSH
55233: LD_INT 91
55235: PUSH
55236: EMPTY
55237: LIST
55238: LIST
55239: LIST
55240: LIST
55241: LIST
55242: LIST
55243: LIST
55244: LIST
55245: LIST
55246: LIST
55247: LIST
55248: LIST
55249: LIST
55250: LIST
55251: LIST
55252: LIST
55253: LIST
55254: LIST
55255: LIST
55256: LIST
55257: LIST
55258: LIST
55259: LIST
55260: LIST
55261: LIST
55262: LIST
55263: LIST
55264: LIST
55265: LIST
55266: LIST
55267: LIST
55268: LIST
55269: LIST
55270: LIST
55271: LIST
55272: LIST
55273: LIST
55274: LIST
55275: LIST
55276: LIST
55277: LIST
55278: LIST
55279: LIST
55280: LIST
55281: LIST
55282: LIST
55283: LIST
55284: LIST
55285: LIST
55286: LIST
55287: LIST
55288: LIST
55289: LIST
55290: LIST
55291: LIST
55292: ST_TO_ADDR
55293: GO 55296
55295: POP
// if state > - 1 and state < 3 then
55296: LD_VAR 0 3
55300: PUSH
55301: LD_INT 1
55303: NEG
55304: GREATER
55305: IFFALSE 55317
55307: PUSH
55308: LD_VAR 0 3
55312: PUSH
55313: LD_INT 3
55315: LESS
55316: AND
55317: IFFALSE 55374
// for i in result do
55319: LD_ADDR_VAR 0 5
55323: PUSH
55324: LD_VAR 0 4
55328: PUSH
55329: FOR_IN
55330: IFFALSE 55372
// if GetTech ( i , side ) <> state then
55332: LD_VAR 0 5
55336: PPUSH
55337: LD_VAR 0 1
55341: PPUSH
55342: CALL_OW 321
55346: PUSH
55347: LD_VAR 0 3
55351: NONEQUAL
55352: IFFALSE 55370
// result := result diff i ;
55354: LD_ADDR_VAR 0 4
55358: PUSH
55359: LD_VAR 0 4
55363: PUSH
55364: LD_VAR 0 5
55368: DIFF
55369: ST_TO_ADDR
55370: GO 55329
55372: POP
55373: POP
// end ;
55374: LD_VAR 0 4
55378: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
55379: LD_INT 0
55381: PPUSH
55382: PPUSH
55383: PPUSH
// result := true ;
55384: LD_ADDR_VAR 0 3
55388: PUSH
55389: LD_INT 1
55391: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
55392: LD_ADDR_VAR 0 5
55396: PUSH
55397: LD_VAR 0 2
55401: PPUSH
55402: CALL_OW 480
55406: ST_TO_ADDR
// if not tmp then
55407: LD_VAR 0 5
55411: NOT
55412: IFFALSE 55416
// exit ;
55414: GO 55465
// for i in tmp do
55416: LD_ADDR_VAR 0 4
55420: PUSH
55421: LD_VAR 0 5
55425: PUSH
55426: FOR_IN
55427: IFFALSE 55463
// if GetTech ( i , side ) <> state_researched then
55429: LD_VAR 0 4
55433: PPUSH
55434: LD_VAR 0 1
55438: PPUSH
55439: CALL_OW 321
55443: PUSH
55444: LD_INT 2
55446: NONEQUAL
55447: IFFALSE 55461
// begin result := false ;
55449: LD_ADDR_VAR 0 3
55453: PUSH
55454: LD_INT 0
55456: ST_TO_ADDR
// exit ;
55457: POP
55458: POP
55459: GO 55465
// end ;
55461: GO 55426
55463: POP
55464: POP
// end ;
55465: LD_VAR 0 3
55469: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
55470: LD_INT 0
55472: PPUSH
55473: PPUSH
55474: PPUSH
55475: PPUSH
55476: PPUSH
55477: PPUSH
55478: PPUSH
55479: PPUSH
55480: PPUSH
55481: PPUSH
55482: PPUSH
55483: PPUSH
55484: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
55485: LD_VAR 0 1
55489: NOT
55490: IFTRUE 55507
55492: PUSH
55493: LD_VAR 0 1
55497: PPUSH
55498: CALL_OW 257
55502: PUSH
55503: LD_INT 9
55505: NONEQUAL
55506: OR
55507: IFFALSE 55511
// exit ;
55509: GO 56090
// side := GetSide ( unit ) ;
55511: LD_ADDR_VAR 0 9
55515: PUSH
55516: LD_VAR 0 1
55520: PPUSH
55521: CALL_OW 255
55525: ST_TO_ADDR
// tech_space := tech_spacanom ;
55526: LD_ADDR_VAR 0 12
55530: PUSH
55531: LD_INT 29
55533: ST_TO_ADDR
// tech_time := tech_taurad ;
55534: LD_ADDR_VAR 0 13
55538: PUSH
55539: LD_INT 28
55541: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
55542: LD_ADDR_VAR 0 11
55546: PUSH
55547: LD_VAR 0 1
55551: PPUSH
55552: CALL_OW 310
55556: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
55557: LD_VAR 0 11
55561: PPUSH
55562: CALL_OW 247
55566: PUSH
55567: LD_INT 2
55569: EQUAL
55570: IFFALSE 55574
// exit ;
55572: GO 56090
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55574: LD_ADDR_VAR 0 8
55578: PUSH
55579: LD_INT 81
55581: PUSH
55582: LD_VAR 0 9
55586: PUSH
55587: EMPTY
55588: LIST
55589: LIST
55590: PUSH
55591: LD_INT 3
55593: PUSH
55594: LD_INT 21
55596: PUSH
55597: LD_INT 3
55599: PUSH
55600: EMPTY
55601: LIST
55602: LIST
55603: PUSH
55604: EMPTY
55605: LIST
55606: LIST
55607: PUSH
55608: EMPTY
55609: LIST
55610: LIST
55611: PPUSH
55612: CALL_OW 69
55616: ST_TO_ADDR
// if not tmp then
55617: LD_VAR 0 8
55621: NOT
55622: IFFALSE 55626
// exit ;
55624: GO 56090
// if in_unit then
55626: LD_VAR 0 11
55630: IFFALSE 55654
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
55632: LD_ADDR_VAR 0 10
55636: PUSH
55637: LD_VAR 0 8
55641: PPUSH
55642: LD_VAR 0 11
55646: PPUSH
55647: CALL_OW 74
55651: ST_TO_ADDR
55652: GO 55674
// enemy := NearestUnitToUnit ( tmp , unit ) ;
55654: LD_ADDR_VAR 0 10
55658: PUSH
55659: LD_VAR 0 8
55663: PPUSH
55664: LD_VAR 0 1
55668: PPUSH
55669: CALL_OW 74
55673: ST_TO_ADDR
// if not enemy then
55674: LD_VAR 0 10
55678: NOT
55679: IFFALSE 55683
// exit ;
55681: GO 56090
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
55683: LD_VAR 0 11
55687: IFFALSE 55709
55689: PUSH
55690: LD_VAR 0 11
55694: PPUSH
55695: LD_VAR 0 10
55699: PPUSH
55700: CALL_OW 296
55704: PUSH
55705: LD_INT 13
55707: GREATER
55708: AND
55709: IFTRUE 55731
55711: PUSH
55712: LD_VAR 0 1
55716: PPUSH
55717: LD_VAR 0 10
55721: PPUSH
55722: CALL_OW 296
55726: PUSH
55727: LD_INT 12
55729: GREATER
55730: OR
55731: IFFALSE 55735
// exit ;
55733: GO 56090
// missile := [ 1 ] ;
55735: LD_ADDR_VAR 0 14
55739: PUSH
55740: LD_INT 1
55742: PUSH
55743: EMPTY
55744: LIST
55745: ST_TO_ADDR
// if Researched ( side , tech_space ) then
55746: LD_VAR 0 9
55750: PPUSH
55751: LD_VAR 0 12
55755: PPUSH
55756: CALL_OW 325
55760: IFFALSE 55789
// missile := Replace ( missile , missile + 1 , 2 ) ;
55762: LD_ADDR_VAR 0 14
55766: PUSH
55767: LD_VAR 0 14
55771: PPUSH
55772: LD_VAR 0 14
55776: PUSH
55777: LD_INT 1
55779: PLUS
55780: PPUSH
55781: LD_INT 2
55783: PPUSH
55784: CALL_OW 1
55788: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
55789: LD_VAR 0 9
55793: PPUSH
55794: LD_VAR 0 13
55798: PPUSH
55799: CALL_OW 325
55803: IFFALSE 55827
55805: PUSH
55806: LD_VAR 0 10
55810: PPUSH
55811: CALL_OW 255
55815: PPUSH
55816: LD_VAR 0 13
55820: PPUSH
55821: CALL_OW 325
55825: NOT
55826: AND
55827: IFFALSE 55856
// missile := Replace ( missile , missile + 1 , 3 ) ;
55829: LD_ADDR_VAR 0 14
55833: PUSH
55834: LD_VAR 0 14
55838: PPUSH
55839: LD_VAR 0 14
55843: PUSH
55844: LD_INT 1
55846: PLUS
55847: PPUSH
55848: LD_INT 3
55850: PPUSH
55851: CALL_OW 1
55855: ST_TO_ADDR
// if missile < 2 then
55856: LD_VAR 0 14
55860: PUSH
55861: LD_INT 2
55863: LESS
55864: IFFALSE 55868
// exit ;
55866: GO 56090
// x := GetX ( enemy ) ;
55868: LD_ADDR_VAR 0 4
55872: PUSH
55873: LD_VAR 0 10
55877: PPUSH
55878: CALL_OW 250
55882: ST_TO_ADDR
// y := GetY ( enemy ) ;
55883: LD_ADDR_VAR 0 5
55887: PUSH
55888: LD_VAR 0 10
55892: PPUSH
55893: CALL_OW 251
55897: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
55898: LD_ADDR_VAR 0 6
55902: PUSH
55903: LD_VAR 0 4
55907: PUSH
55908: LD_INT 1
55910: NEG
55911: PPUSH
55912: LD_INT 1
55914: PPUSH
55915: CALL_OW 12
55919: PLUS
55920: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
55921: LD_ADDR_VAR 0 7
55925: PUSH
55926: LD_VAR 0 5
55930: PUSH
55931: LD_INT 1
55933: NEG
55934: PPUSH
55935: LD_INT 1
55937: PPUSH
55938: CALL_OW 12
55942: PLUS
55943: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55944: LD_VAR 0 6
55948: PPUSH
55949: LD_VAR 0 7
55953: PPUSH
55954: CALL_OW 488
55958: NOT
55959: IFFALSE 55981
// begin _x := x ;
55961: LD_ADDR_VAR 0 6
55965: PUSH
55966: LD_VAR 0 4
55970: ST_TO_ADDR
// _y := y ;
55971: LD_ADDR_VAR 0 7
55975: PUSH
55976: LD_VAR 0 5
55980: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
55981: LD_ADDR_VAR 0 3
55985: PUSH
55986: LD_INT 1
55988: PPUSH
55989: LD_VAR 0 14
55993: PPUSH
55994: CALL_OW 12
55998: ST_TO_ADDR
// case i of 1 :
55999: LD_VAR 0 3
56003: PUSH
56004: LD_INT 1
56006: DOUBLE
56007: EQUAL
56008: IFTRUE 56012
56010: GO 56029
56012: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
56013: LD_VAR 0 1
56017: PPUSH
56018: LD_VAR 0 10
56022: PPUSH
56023: CALL_OW 115
56027: GO 56090
56029: LD_INT 2
56031: DOUBLE
56032: EQUAL
56033: IFTRUE 56037
56035: GO 56059
56037: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
56038: LD_VAR 0 1
56042: PPUSH
56043: LD_VAR 0 6
56047: PPUSH
56048: LD_VAR 0 7
56052: PPUSH
56053: CALL_OW 153
56057: GO 56090
56059: LD_INT 3
56061: DOUBLE
56062: EQUAL
56063: IFTRUE 56067
56065: GO 56089
56067: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
56068: LD_VAR 0 1
56072: PPUSH
56073: LD_VAR 0 6
56077: PPUSH
56078: LD_VAR 0 7
56082: PPUSH
56083: CALL_OW 154
56087: GO 56090
56089: POP
// end ;
56090: LD_VAR 0 2
56094: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
56095: LD_INT 0
56097: PPUSH
56098: PPUSH
56099: PPUSH
56100: PPUSH
56101: PPUSH
56102: PPUSH
// if not unit or not building then
56103: LD_VAR 0 1
56107: NOT
56108: IFTRUE 56117
56110: PUSH
56111: LD_VAR 0 2
56115: NOT
56116: OR
56117: IFFALSE 56121
// exit ;
56119: GO 56279
// x := GetX ( building ) ;
56121: LD_ADDR_VAR 0 5
56125: PUSH
56126: LD_VAR 0 2
56130: PPUSH
56131: CALL_OW 250
56135: ST_TO_ADDR
// y := GetY ( building ) ;
56136: LD_ADDR_VAR 0 6
56140: PUSH
56141: LD_VAR 0 2
56145: PPUSH
56146: CALL_OW 251
56150: ST_TO_ADDR
// for i := 0 to 5 do
56151: LD_ADDR_VAR 0 4
56155: PUSH
56156: DOUBLE
56157: LD_INT 0
56159: DEC
56160: ST_TO_ADDR
56161: LD_INT 5
56163: PUSH
56164: FOR_TO
56165: IFFALSE 56277
// begin _x := ShiftX ( x , i , 3 ) ;
56167: LD_ADDR_VAR 0 7
56171: PUSH
56172: LD_VAR 0 5
56176: PPUSH
56177: LD_VAR 0 4
56181: PPUSH
56182: LD_INT 3
56184: PPUSH
56185: CALL_OW 272
56189: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
56190: LD_ADDR_VAR 0 8
56194: PUSH
56195: LD_VAR 0 6
56199: PPUSH
56200: LD_VAR 0 4
56204: PPUSH
56205: LD_INT 3
56207: PPUSH
56208: CALL_OW 273
56212: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
56213: LD_VAR 0 7
56217: PPUSH
56218: LD_VAR 0 8
56222: PPUSH
56223: CALL_OW 488
56227: NOT
56228: IFFALSE 56232
// continue ;
56230: GO 56164
// if HexInfo ( _x , _y ) = 0 then
56232: LD_VAR 0 7
56236: PPUSH
56237: LD_VAR 0 8
56241: PPUSH
56242: CALL_OW 428
56246: PUSH
56247: LD_INT 0
56249: EQUAL
56250: IFFALSE 56275
// begin ComMoveXY ( unit , _x , _y ) ;
56252: LD_VAR 0 1
56256: PPUSH
56257: LD_VAR 0 7
56261: PPUSH
56262: LD_VAR 0 8
56266: PPUSH
56267: CALL_OW 111
// exit ;
56271: POP
56272: POP
56273: GO 56279
// end ; end ;
56275: GO 56164
56277: POP
56278: POP
// end ;
56279: LD_VAR 0 3
56283: RET
// export function ScanBase ( side , base_area ) ; begin
56284: LD_INT 0
56286: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
56287: LD_ADDR_VAR 0 3
56291: PUSH
56292: LD_VAR 0 2
56296: PPUSH
56297: LD_INT 81
56299: PUSH
56300: LD_VAR 0 1
56304: PUSH
56305: EMPTY
56306: LIST
56307: LIST
56308: PPUSH
56309: CALL_OW 70
56313: ST_TO_ADDR
// end ;
56314: LD_VAR 0 3
56318: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
56319: LD_INT 0
56321: PPUSH
56322: PPUSH
56323: PPUSH
56324: PPUSH
// result := false ;
56325: LD_ADDR_VAR 0 2
56329: PUSH
56330: LD_INT 0
56332: ST_TO_ADDR
// side := GetSide ( unit ) ;
56333: LD_ADDR_VAR 0 3
56337: PUSH
56338: LD_VAR 0 1
56342: PPUSH
56343: CALL_OW 255
56347: ST_TO_ADDR
// nat := GetNation ( unit ) ;
56348: LD_ADDR_VAR 0 4
56352: PUSH
56353: LD_VAR 0 1
56357: PPUSH
56358: CALL_OW 248
56362: ST_TO_ADDR
// case nat of 1 :
56363: LD_VAR 0 4
56367: PUSH
56368: LD_INT 1
56370: DOUBLE
56371: EQUAL
56372: IFTRUE 56376
56374: GO 56387
56376: POP
// tech := tech_lassight ; 2 :
56377: LD_ADDR_VAR 0 5
56381: PUSH
56382: LD_INT 12
56384: ST_TO_ADDR
56385: GO 56426
56387: LD_INT 2
56389: DOUBLE
56390: EQUAL
56391: IFTRUE 56395
56393: GO 56406
56395: POP
// tech := tech_mortar ; 3 :
56396: LD_ADDR_VAR 0 5
56400: PUSH
56401: LD_INT 41
56403: ST_TO_ADDR
56404: GO 56426
56406: LD_INT 3
56408: DOUBLE
56409: EQUAL
56410: IFTRUE 56414
56412: GO 56425
56414: POP
// tech := tech_bazooka ; end ;
56415: LD_ADDR_VAR 0 5
56419: PUSH
56420: LD_INT 44
56422: ST_TO_ADDR
56423: GO 56426
56425: POP
// if Researched ( side , tech ) then
56426: LD_VAR 0 3
56430: PPUSH
56431: LD_VAR 0 5
56435: PPUSH
56436: CALL_OW 325
56440: IFFALSE 56467
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
56442: LD_ADDR_VAR 0 2
56446: PUSH
56447: LD_INT 5
56449: PUSH
56450: LD_INT 8
56452: PUSH
56453: LD_INT 9
56455: PUSH
56456: EMPTY
56457: LIST
56458: LIST
56459: LIST
56460: PUSH
56461: LD_VAR 0 4
56465: ARRAY
56466: ST_TO_ADDR
// end ;
56467: LD_VAR 0 2
56471: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
56472: LD_INT 0
56474: PPUSH
56475: PPUSH
56476: PPUSH
// if not mines then
56477: LD_VAR 0 2
56481: NOT
56482: IFFALSE 56486
// exit ;
56484: GO 56630
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56486: LD_ADDR_VAR 0 5
56490: PUSH
56491: LD_INT 81
56493: PUSH
56494: LD_VAR 0 1
56498: PUSH
56499: EMPTY
56500: LIST
56501: LIST
56502: PUSH
56503: LD_INT 3
56505: PUSH
56506: LD_INT 21
56508: PUSH
56509: LD_INT 3
56511: PUSH
56512: EMPTY
56513: LIST
56514: LIST
56515: PUSH
56516: EMPTY
56517: LIST
56518: LIST
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: PPUSH
56524: CALL_OW 69
56528: ST_TO_ADDR
// for i in mines do
56529: LD_ADDR_VAR 0 4
56533: PUSH
56534: LD_VAR 0 2
56538: PUSH
56539: FOR_IN
56540: IFFALSE 56628
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
56542: LD_VAR 0 4
56546: PUSH
56547: LD_INT 1
56549: ARRAY
56550: PPUSH
56551: LD_VAR 0 4
56555: PUSH
56556: LD_INT 2
56558: ARRAY
56559: PPUSH
56560: CALL_OW 458
56564: NOT
56565: IFFALSE 56569
// continue ;
56567: GO 56539
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
56569: LD_VAR 0 4
56573: PUSH
56574: LD_INT 1
56576: ARRAY
56577: PPUSH
56578: LD_VAR 0 4
56582: PUSH
56583: LD_INT 2
56585: ARRAY
56586: PPUSH
56587: CALL_OW 428
56591: PUSH
56592: LD_VAR 0 5
56596: IN
56597: IFFALSE 56626
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
56599: LD_VAR 0 4
56603: PUSH
56604: LD_INT 1
56606: ARRAY
56607: PPUSH
56608: LD_VAR 0 4
56612: PUSH
56613: LD_INT 2
56615: ARRAY
56616: PPUSH
56617: LD_VAR 0 1
56621: PPUSH
56622: CALL_OW 456
// end ;
56626: GO 56539
56628: POP
56629: POP
// end ;
56630: LD_VAR 0 3
56634: RET
// export function Count ( array ) ; begin
56635: LD_INT 0
56637: PPUSH
// result := array + 0 ;
56638: LD_ADDR_VAR 0 2
56642: PUSH
56643: LD_VAR 0 1
56647: PUSH
56648: LD_INT 0
56650: PLUS
56651: ST_TO_ADDR
// end ;
56652: LD_VAR 0 2
56656: RET
// export function IsEmpty ( building ) ; begin
56657: LD_INT 0
56659: PPUSH
// if not building then
56660: LD_VAR 0 1
56664: NOT
56665: IFFALSE 56669
// exit ;
56667: GO 56712
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
56669: LD_ADDR_VAR 0 2
56673: PUSH
56674: LD_VAR 0 1
56678: PUSH
56679: LD_INT 22
56681: PUSH
56682: LD_VAR 0 1
56686: PPUSH
56687: CALL_OW 255
56691: PUSH
56692: EMPTY
56693: LIST
56694: LIST
56695: PUSH
56696: LD_INT 58
56698: PUSH
56699: EMPTY
56700: LIST
56701: PUSH
56702: EMPTY
56703: LIST
56704: LIST
56705: PPUSH
56706: CALL_OW 69
56710: IN
56711: ST_TO_ADDR
// end ;
56712: LD_VAR 0 2
56716: RET
// export function IsNotFull ( building ) ; var places ; begin
56717: LD_INT 0
56719: PPUSH
56720: PPUSH
// if not building then
56721: LD_VAR 0 1
56725: NOT
56726: IFFALSE 56730
// exit ;
56728: GO 56758
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
56730: LD_ADDR_VAR 0 2
56734: PUSH
56735: LD_VAR 0 1
56739: PPUSH
56740: LD_INT 3
56742: PUSH
56743: LD_INT 62
56745: PUSH
56746: EMPTY
56747: LIST
56748: PUSH
56749: EMPTY
56750: LIST
56751: LIST
56752: PPUSH
56753: CALL_OW 72
56757: ST_TO_ADDR
// end ;
56758: LD_VAR 0 2
56762: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
56763: LD_INT 0
56765: PPUSH
56766: PPUSH
56767: PPUSH
56768: PPUSH
// tmp := [ ] ;
56769: LD_ADDR_VAR 0 3
56773: PUSH
56774: EMPTY
56775: ST_TO_ADDR
// list := [ ] ;
56776: LD_ADDR_VAR 0 5
56780: PUSH
56781: EMPTY
56782: ST_TO_ADDR
// for i = 16 to 25 do
56783: LD_ADDR_VAR 0 4
56787: PUSH
56788: DOUBLE
56789: LD_INT 16
56791: DEC
56792: ST_TO_ADDR
56793: LD_INT 25
56795: PUSH
56796: FOR_TO
56797: IFFALSE 56870
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
56799: LD_ADDR_VAR 0 3
56803: PUSH
56804: LD_VAR 0 3
56808: PUSH
56809: LD_INT 22
56811: PUSH
56812: LD_VAR 0 1
56816: PPUSH
56817: CALL_OW 255
56821: PUSH
56822: EMPTY
56823: LIST
56824: LIST
56825: PUSH
56826: LD_INT 91
56828: PUSH
56829: LD_VAR 0 1
56833: PUSH
56834: LD_INT 6
56836: PUSH
56837: EMPTY
56838: LIST
56839: LIST
56840: LIST
56841: PUSH
56842: LD_INT 30
56844: PUSH
56845: LD_VAR 0 4
56849: PUSH
56850: EMPTY
56851: LIST
56852: LIST
56853: PUSH
56854: EMPTY
56855: LIST
56856: LIST
56857: LIST
56858: PUSH
56859: EMPTY
56860: LIST
56861: PPUSH
56862: CALL_OW 69
56866: ADD
56867: ST_TO_ADDR
56868: GO 56796
56870: POP
56871: POP
// for i = 1 to tmp do
56872: LD_ADDR_VAR 0 4
56876: PUSH
56877: DOUBLE
56878: LD_INT 1
56880: DEC
56881: ST_TO_ADDR
56882: LD_VAR 0 3
56886: PUSH
56887: FOR_TO
56888: IFFALSE 56976
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
56890: LD_ADDR_VAR 0 5
56894: PUSH
56895: LD_VAR 0 5
56899: PUSH
56900: LD_VAR 0 3
56904: PUSH
56905: LD_VAR 0 4
56909: ARRAY
56910: PPUSH
56911: CALL_OW 266
56915: PUSH
56916: LD_VAR 0 3
56920: PUSH
56921: LD_VAR 0 4
56925: ARRAY
56926: PPUSH
56927: CALL_OW 250
56931: PUSH
56932: LD_VAR 0 3
56936: PUSH
56937: LD_VAR 0 4
56941: ARRAY
56942: PPUSH
56943: CALL_OW 251
56947: PUSH
56948: LD_VAR 0 3
56952: PUSH
56953: LD_VAR 0 4
56957: ARRAY
56958: PPUSH
56959: CALL_OW 254
56963: PUSH
56964: EMPTY
56965: LIST
56966: LIST
56967: LIST
56968: LIST
56969: PUSH
56970: EMPTY
56971: LIST
56972: ADD
56973: ST_TO_ADDR
56974: GO 56887
56976: POP
56977: POP
// result := list ;
56978: LD_ADDR_VAR 0 2
56982: PUSH
56983: LD_VAR 0 5
56987: ST_TO_ADDR
// end ;
56988: LD_VAR 0 2
56992: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
56993: LD_INT 0
56995: PPUSH
56996: PPUSH
56997: PPUSH
56998: PPUSH
56999: PPUSH
57000: PPUSH
57001: PPUSH
// if not factory then
57002: LD_VAR 0 1
57006: NOT
57007: IFFALSE 57011
// exit ;
57009: GO 57614
// if control = control_apeman then
57011: LD_VAR 0 4
57015: PUSH
57016: LD_INT 5
57018: EQUAL
57019: IFFALSE 57128
// begin tmp := UnitsInside ( factory ) ;
57021: LD_ADDR_VAR 0 8
57025: PUSH
57026: LD_VAR 0 1
57030: PPUSH
57031: CALL_OW 313
57035: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
57036: LD_VAR 0 8
57040: PPUSH
57041: LD_INT 25
57043: PUSH
57044: LD_INT 12
57046: PUSH
57047: EMPTY
57048: LIST
57049: LIST
57050: PPUSH
57051: CALL_OW 72
57055: NOT
57056: IFFALSE 57066
// control := control_manual ;
57058: LD_ADDR_VAR 0 4
57062: PUSH
57063: LD_INT 1
57065: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
57066: LD_ADDR_VAR 0 8
57070: PUSH
57071: LD_VAR 0 1
57075: PPUSH
57076: CALL 56763 0 1
57080: ST_TO_ADDR
// if tmp then
57081: LD_VAR 0 8
57085: IFFALSE 57128
// begin for i in tmp do
57087: LD_ADDR_VAR 0 7
57091: PUSH
57092: LD_VAR 0 8
57096: PUSH
57097: FOR_IN
57098: IFFALSE 57126
// if i [ 1 ] = b_ext_radio then
57100: LD_VAR 0 7
57104: PUSH
57105: LD_INT 1
57107: ARRAY
57108: PUSH
57109: LD_INT 22
57111: EQUAL
57112: IFFALSE 57124
// begin control := control_remote ;
57114: LD_ADDR_VAR 0 4
57118: PUSH
57119: LD_INT 2
57121: ST_TO_ADDR
// break ;
57122: GO 57126
// end ;
57124: GO 57097
57126: POP
57127: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
57128: LD_VAR 0 1
57132: PPUSH
57133: LD_VAR 0 2
57137: PPUSH
57138: LD_VAR 0 3
57142: PPUSH
57143: LD_VAR 0 4
57147: PPUSH
57148: LD_VAR 0 5
57152: PPUSH
57153: CALL_OW 448
57157: IFFALSE 57192
// begin result := [ chassis , engine , control , weapon ] ;
57159: LD_ADDR_VAR 0 6
57163: PUSH
57164: LD_VAR 0 2
57168: PUSH
57169: LD_VAR 0 3
57173: PUSH
57174: LD_VAR 0 4
57178: PUSH
57179: LD_VAR 0 5
57183: PUSH
57184: EMPTY
57185: LIST
57186: LIST
57187: LIST
57188: LIST
57189: ST_TO_ADDR
// exit ;
57190: GO 57614
// end ; _chassis := AvailableChassisList ( factory ) ;
57192: LD_ADDR_VAR 0 9
57196: PUSH
57197: LD_VAR 0 1
57201: PPUSH
57202: CALL_OW 475
57206: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
57207: LD_ADDR_VAR 0 11
57211: PUSH
57212: LD_VAR 0 1
57216: PPUSH
57217: CALL_OW 476
57221: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
57222: LD_ADDR_VAR 0 12
57226: PUSH
57227: LD_VAR 0 1
57231: PPUSH
57232: CALL_OW 477
57236: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
57237: LD_ADDR_VAR 0 10
57241: PUSH
57242: LD_VAR 0 1
57246: PPUSH
57247: CALL_OW 478
57251: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
57252: LD_VAR 0 9
57256: NOT
57257: IFTRUE 57266
57259: PUSH
57260: LD_VAR 0 11
57264: NOT
57265: OR
57266: IFTRUE 57275
57268: PUSH
57269: LD_VAR 0 12
57273: NOT
57274: OR
57275: IFTRUE 57284
57277: PUSH
57278: LD_VAR 0 10
57282: NOT
57283: OR
57284: IFFALSE 57319
// begin result := [ chassis , engine , control , weapon ] ;
57286: LD_ADDR_VAR 0 6
57290: PUSH
57291: LD_VAR 0 2
57295: PUSH
57296: LD_VAR 0 3
57300: PUSH
57301: LD_VAR 0 4
57305: PUSH
57306: LD_VAR 0 5
57310: PUSH
57311: EMPTY
57312: LIST
57313: LIST
57314: LIST
57315: LIST
57316: ST_TO_ADDR
// exit ;
57317: GO 57614
// end ; if not chassis in _chassis then
57319: LD_VAR 0 2
57323: PUSH
57324: LD_VAR 0 9
57328: IN
57329: NOT
57330: IFFALSE 57356
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
57332: LD_ADDR_VAR 0 2
57336: PUSH
57337: LD_VAR 0 9
57341: PUSH
57342: LD_INT 1
57344: PPUSH
57345: LD_VAR 0 9
57349: PPUSH
57350: CALL_OW 12
57354: ARRAY
57355: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
57356: LD_VAR 0 2
57360: PPUSH
57361: LD_VAR 0 3
57365: PPUSH
57366: CALL 57619 0 2
57370: NOT
57371: IFFALSE 57432
// repeat engine := _engine [ 1 ] ;
57373: LD_ADDR_VAR 0 3
57377: PUSH
57378: LD_VAR 0 11
57382: PUSH
57383: LD_INT 1
57385: ARRAY
57386: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
57387: LD_ADDR_VAR 0 11
57391: PUSH
57392: LD_VAR 0 11
57396: PPUSH
57397: LD_INT 1
57399: PPUSH
57400: CALL_OW 3
57404: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
57405: LD_VAR 0 2
57409: PPUSH
57410: LD_VAR 0 3
57414: PPUSH
57415: CALL 57619 0 2
57419: IFTRUE 57430
57421: PUSH
57422: LD_VAR 0 11
57426: PUSH
57427: EMPTY
57428: EQUAL
57429: OR
57430: IFFALSE 57373
// if not control in _control then
57432: LD_VAR 0 4
57436: PUSH
57437: LD_VAR 0 12
57441: IN
57442: NOT
57443: IFFALSE 57469
// control := _control [ rand ( 1 , _control ) ] ;
57445: LD_ADDR_VAR 0 4
57449: PUSH
57450: LD_VAR 0 12
57454: PUSH
57455: LD_INT 1
57457: PPUSH
57458: LD_VAR 0 12
57462: PPUSH
57463: CALL_OW 12
57467: ARRAY
57468: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
57469: LD_VAR 0 2
57473: PPUSH
57474: LD_VAR 0 5
57478: PPUSH
57479: CALL 57841 0 2
57483: NOT
57484: IFFALSE 57545
// repeat weapon := _weapon [ 1 ] ;
57486: LD_ADDR_VAR 0 5
57490: PUSH
57491: LD_VAR 0 10
57495: PUSH
57496: LD_INT 1
57498: ARRAY
57499: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
57500: LD_ADDR_VAR 0 10
57504: PUSH
57505: LD_VAR 0 10
57509: PPUSH
57510: LD_INT 1
57512: PPUSH
57513: CALL_OW 3
57517: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
57518: LD_VAR 0 2
57522: PPUSH
57523: LD_VAR 0 5
57527: PPUSH
57528: CALL 57841 0 2
57532: IFTRUE 57543
57534: PUSH
57535: LD_VAR 0 10
57539: PUSH
57540: EMPTY
57541: EQUAL
57542: OR
57543: IFFALSE 57486
// result := [ ] ;
57545: LD_ADDR_VAR 0 6
57549: PUSH
57550: EMPTY
57551: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
57552: LD_VAR 0 1
57556: PPUSH
57557: LD_VAR 0 2
57561: PPUSH
57562: LD_VAR 0 3
57566: PPUSH
57567: LD_VAR 0 4
57571: PPUSH
57572: LD_VAR 0 5
57576: PPUSH
57577: CALL_OW 448
57581: IFFALSE 57614
// result := [ chassis , engine , control , weapon ] ;
57583: LD_ADDR_VAR 0 6
57587: PUSH
57588: LD_VAR 0 2
57592: PUSH
57593: LD_VAR 0 3
57597: PUSH
57598: LD_VAR 0 4
57602: PUSH
57603: LD_VAR 0 5
57607: PUSH
57608: EMPTY
57609: LIST
57610: LIST
57611: LIST
57612: LIST
57613: ST_TO_ADDR
// end ;
57614: LD_VAR 0 6
57618: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
57619: LD_INT 0
57621: PPUSH
// if not chassis or not engine then
57622: LD_VAR 0 1
57626: NOT
57627: IFTRUE 57636
57629: PUSH
57630: LD_VAR 0 2
57634: NOT
57635: OR
57636: IFFALSE 57640
// exit ;
57638: GO 57836
// case engine of engine_solar :
57640: LD_VAR 0 2
57644: PUSH
57645: LD_INT 2
57647: DOUBLE
57648: EQUAL
57649: IFTRUE 57653
57651: GO 57691
57653: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
57654: LD_ADDR_VAR 0 3
57658: PUSH
57659: LD_INT 11
57661: PUSH
57662: LD_INT 12
57664: PUSH
57665: LD_INT 13
57667: PUSH
57668: LD_INT 14
57670: PUSH
57671: LD_INT 1
57673: PUSH
57674: LD_INT 2
57676: PUSH
57677: LD_INT 3
57679: PUSH
57680: EMPTY
57681: LIST
57682: LIST
57683: LIST
57684: LIST
57685: LIST
57686: LIST
57687: LIST
57688: ST_TO_ADDR
57689: GO 57820
57691: LD_INT 1
57693: DOUBLE
57694: EQUAL
57695: IFTRUE 57699
57697: GO 57761
57699: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
57700: LD_ADDR_VAR 0 3
57704: PUSH
57705: LD_INT 11
57707: PUSH
57708: LD_INT 12
57710: PUSH
57711: LD_INT 13
57713: PUSH
57714: LD_INT 14
57716: PUSH
57717: LD_INT 1
57719: PUSH
57720: LD_INT 2
57722: PUSH
57723: LD_INT 3
57725: PUSH
57726: LD_INT 4
57728: PUSH
57729: LD_INT 5
57731: PUSH
57732: LD_INT 21
57734: PUSH
57735: LD_INT 23
57737: PUSH
57738: LD_INT 22
57740: PUSH
57741: LD_INT 24
57743: PUSH
57744: EMPTY
57745: LIST
57746: LIST
57747: LIST
57748: LIST
57749: LIST
57750: LIST
57751: LIST
57752: LIST
57753: LIST
57754: LIST
57755: LIST
57756: LIST
57757: LIST
57758: ST_TO_ADDR
57759: GO 57820
57761: LD_INT 3
57763: DOUBLE
57764: EQUAL
57765: IFTRUE 57769
57767: GO 57819
57769: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57770: LD_ADDR_VAR 0 3
57774: PUSH
57775: LD_INT 13
57777: PUSH
57778: LD_INT 14
57780: PUSH
57781: LD_INT 2
57783: PUSH
57784: LD_INT 3
57786: PUSH
57787: LD_INT 4
57789: PUSH
57790: LD_INT 5
57792: PUSH
57793: LD_INT 21
57795: PUSH
57796: LD_INT 22
57798: PUSH
57799: LD_INT 23
57801: PUSH
57802: LD_INT 24
57804: PUSH
57805: EMPTY
57806: LIST
57807: LIST
57808: LIST
57809: LIST
57810: LIST
57811: LIST
57812: LIST
57813: LIST
57814: LIST
57815: LIST
57816: ST_TO_ADDR
57817: GO 57820
57819: POP
// result := ( chassis in result ) ;
57820: LD_ADDR_VAR 0 3
57824: PUSH
57825: LD_VAR 0 1
57829: PUSH
57830: LD_VAR 0 3
57834: IN
57835: ST_TO_ADDR
// end ;
57836: LD_VAR 0 3
57840: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
57841: LD_INT 0
57843: PPUSH
// if not chassis or not weapon then
57844: LD_VAR 0 1
57848: NOT
57849: IFTRUE 57858
57851: PUSH
57852: LD_VAR 0 2
57856: NOT
57857: OR
57858: IFFALSE 57862
// exit ;
57860: GO 58956
// case weapon of us_machine_gun :
57862: LD_VAR 0 2
57866: PUSH
57867: LD_INT 2
57869: DOUBLE
57870: EQUAL
57871: IFTRUE 57875
57873: GO 57905
57875: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
57876: LD_ADDR_VAR 0 3
57880: PUSH
57881: LD_INT 1
57883: PUSH
57884: LD_INT 2
57886: PUSH
57887: LD_INT 3
57889: PUSH
57890: LD_INT 4
57892: PUSH
57893: LD_INT 5
57895: PUSH
57896: EMPTY
57897: LIST
57898: LIST
57899: LIST
57900: LIST
57901: LIST
57902: ST_TO_ADDR
57903: GO 58940
57905: LD_INT 3
57907: DOUBLE
57908: EQUAL
57909: IFTRUE 57913
57911: GO 57943
57913: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
57914: LD_ADDR_VAR 0 3
57918: PUSH
57919: LD_INT 1
57921: PUSH
57922: LD_INT 2
57924: PUSH
57925: LD_INT 3
57927: PUSH
57928: LD_INT 4
57930: PUSH
57931: LD_INT 5
57933: PUSH
57934: EMPTY
57935: LIST
57936: LIST
57937: LIST
57938: LIST
57939: LIST
57940: ST_TO_ADDR
57941: GO 58940
57943: LD_INT 11
57945: DOUBLE
57946: EQUAL
57947: IFTRUE 57951
57949: GO 57981
57951: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
57952: LD_ADDR_VAR 0 3
57956: PUSH
57957: LD_INT 1
57959: PUSH
57960: LD_INT 2
57962: PUSH
57963: LD_INT 3
57965: PUSH
57966: LD_INT 4
57968: PUSH
57969: LD_INT 5
57971: PUSH
57972: EMPTY
57973: LIST
57974: LIST
57975: LIST
57976: LIST
57977: LIST
57978: ST_TO_ADDR
57979: GO 58940
57981: LD_INT 4
57983: DOUBLE
57984: EQUAL
57985: IFTRUE 57989
57987: GO 58015
57989: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
57990: LD_ADDR_VAR 0 3
57994: PUSH
57995: LD_INT 2
57997: PUSH
57998: LD_INT 3
58000: PUSH
58001: LD_INT 4
58003: PUSH
58004: LD_INT 5
58006: PUSH
58007: EMPTY
58008: LIST
58009: LIST
58010: LIST
58011: LIST
58012: ST_TO_ADDR
58013: GO 58940
58015: LD_INT 5
58017: DOUBLE
58018: EQUAL
58019: IFTRUE 58023
58021: GO 58049
58023: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
58024: LD_ADDR_VAR 0 3
58028: PUSH
58029: LD_INT 2
58031: PUSH
58032: LD_INT 3
58034: PUSH
58035: LD_INT 4
58037: PUSH
58038: LD_INT 5
58040: PUSH
58041: EMPTY
58042: LIST
58043: LIST
58044: LIST
58045: LIST
58046: ST_TO_ADDR
58047: GO 58940
58049: LD_INT 9
58051: DOUBLE
58052: EQUAL
58053: IFTRUE 58057
58055: GO 58083
58057: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
58058: LD_ADDR_VAR 0 3
58062: PUSH
58063: LD_INT 2
58065: PUSH
58066: LD_INT 3
58068: PUSH
58069: LD_INT 4
58071: PUSH
58072: LD_INT 5
58074: PUSH
58075: EMPTY
58076: LIST
58077: LIST
58078: LIST
58079: LIST
58080: ST_TO_ADDR
58081: GO 58940
58083: LD_INT 7
58085: DOUBLE
58086: EQUAL
58087: IFTRUE 58091
58089: GO 58117
58091: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
58092: LD_ADDR_VAR 0 3
58096: PUSH
58097: LD_INT 2
58099: PUSH
58100: LD_INT 3
58102: PUSH
58103: LD_INT 4
58105: PUSH
58106: LD_INT 5
58108: PUSH
58109: EMPTY
58110: LIST
58111: LIST
58112: LIST
58113: LIST
58114: ST_TO_ADDR
58115: GO 58940
58117: LD_INT 12
58119: DOUBLE
58120: EQUAL
58121: IFTRUE 58125
58123: GO 58151
58125: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
58126: LD_ADDR_VAR 0 3
58130: PUSH
58131: LD_INT 2
58133: PUSH
58134: LD_INT 3
58136: PUSH
58137: LD_INT 4
58139: PUSH
58140: LD_INT 5
58142: PUSH
58143: EMPTY
58144: LIST
58145: LIST
58146: LIST
58147: LIST
58148: ST_TO_ADDR
58149: GO 58940
58151: LD_INT 13
58153: DOUBLE
58154: EQUAL
58155: IFTRUE 58159
58157: GO 58185
58159: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
58160: LD_ADDR_VAR 0 3
58164: PUSH
58165: LD_INT 2
58167: PUSH
58168: LD_INT 3
58170: PUSH
58171: LD_INT 4
58173: PUSH
58174: LD_INT 5
58176: PUSH
58177: EMPTY
58178: LIST
58179: LIST
58180: LIST
58181: LIST
58182: ST_TO_ADDR
58183: GO 58940
58185: LD_INT 14
58187: DOUBLE
58188: EQUAL
58189: IFTRUE 58193
58191: GO 58211
58193: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
58194: LD_ADDR_VAR 0 3
58198: PUSH
58199: LD_INT 4
58201: PUSH
58202: LD_INT 5
58204: PUSH
58205: EMPTY
58206: LIST
58207: LIST
58208: ST_TO_ADDR
58209: GO 58940
58211: LD_INT 6
58213: DOUBLE
58214: EQUAL
58215: IFTRUE 58219
58217: GO 58237
58219: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
58220: LD_ADDR_VAR 0 3
58224: PUSH
58225: LD_INT 4
58227: PUSH
58228: LD_INT 5
58230: PUSH
58231: EMPTY
58232: LIST
58233: LIST
58234: ST_TO_ADDR
58235: GO 58940
58237: LD_INT 10
58239: DOUBLE
58240: EQUAL
58241: IFTRUE 58245
58243: GO 58263
58245: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
58246: LD_ADDR_VAR 0 3
58250: PUSH
58251: LD_INT 4
58253: PUSH
58254: LD_INT 5
58256: PUSH
58257: EMPTY
58258: LIST
58259: LIST
58260: ST_TO_ADDR
58261: GO 58940
58263: LD_INT 22
58265: DOUBLE
58266: EQUAL
58267: IFTRUE 58271
58269: GO 58297
58271: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
58272: LD_ADDR_VAR 0 3
58276: PUSH
58277: LD_INT 11
58279: PUSH
58280: LD_INT 12
58282: PUSH
58283: LD_INT 13
58285: PUSH
58286: LD_INT 14
58288: PUSH
58289: EMPTY
58290: LIST
58291: LIST
58292: LIST
58293: LIST
58294: ST_TO_ADDR
58295: GO 58940
58297: LD_INT 23
58299: DOUBLE
58300: EQUAL
58301: IFTRUE 58305
58303: GO 58331
58305: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
58306: LD_ADDR_VAR 0 3
58310: PUSH
58311: LD_INT 11
58313: PUSH
58314: LD_INT 12
58316: PUSH
58317: LD_INT 13
58319: PUSH
58320: LD_INT 14
58322: PUSH
58323: EMPTY
58324: LIST
58325: LIST
58326: LIST
58327: LIST
58328: ST_TO_ADDR
58329: GO 58940
58331: LD_INT 24
58333: DOUBLE
58334: EQUAL
58335: IFTRUE 58339
58337: GO 58365
58339: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
58340: LD_ADDR_VAR 0 3
58344: PUSH
58345: LD_INT 11
58347: PUSH
58348: LD_INT 12
58350: PUSH
58351: LD_INT 13
58353: PUSH
58354: LD_INT 14
58356: PUSH
58357: EMPTY
58358: LIST
58359: LIST
58360: LIST
58361: LIST
58362: ST_TO_ADDR
58363: GO 58940
58365: LD_INT 30
58367: DOUBLE
58368: EQUAL
58369: IFTRUE 58373
58371: GO 58399
58373: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
58374: LD_ADDR_VAR 0 3
58378: PUSH
58379: LD_INT 11
58381: PUSH
58382: LD_INT 12
58384: PUSH
58385: LD_INT 13
58387: PUSH
58388: LD_INT 14
58390: PUSH
58391: EMPTY
58392: LIST
58393: LIST
58394: LIST
58395: LIST
58396: ST_TO_ADDR
58397: GO 58940
58399: LD_INT 25
58401: DOUBLE
58402: EQUAL
58403: IFTRUE 58407
58405: GO 58425
58407: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
58408: LD_ADDR_VAR 0 3
58412: PUSH
58413: LD_INT 13
58415: PUSH
58416: LD_INT 14
58418: PUSH
58419: EMPTY
58420: LIST
58421: LIST
58422: ST_TO_ADDR
58423: GO 58940
58425: LD_INT 27
58427: DOUBLE
58428: EQUAL
58429: IFTRUE 58433
58431: GO 58451
58433: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
58434: LD_ADDR_VAR 0 3
58438: PUSH
58439: LD_INT 13
58441: PUSH
58442: LD_INT 14
58444: PUSH
58445: EMPTY
58446: LIST
58447: LIST
58448: ST_TO_ADDR
58449: GO 58940
58451: LD_INT 92
58453: DOUBLE
58454: EQUAL
58455: IFTRUE 58459
58457: GO 58485
58459: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
58460: LD_ADDR_VAR 0 3
58464: PUSH
58465: LD_INT 11
58467: PUSH
58468: LD_INT 12
58470: PUSH
58471: LD_INT 13
58473: PUSH
58474: LD_INT 14
58476: PUSH
58477: EMPTY
58478: LIST
58479: LIST
58480: LIST
58481: LIST
58482: ST_TO_ADDR
58483: GO 58940
58485: LD_INT 28
58487: DOUBLE
58488: EQUAL
58489: IFTRUE 58493
58491: GO 58511
58493: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
58494: LD_ADDR_VAR 0 3
58498: PUSH
58499: LD_INT 13
58501: PUSH
58502: LD_INT 14
58504: PUSH
58505: EMPTY
58506: LIST
58507: LIST
58508: ST_TO_ADDR
58509: GO 58940
58511: LD_INT 29
58513: DOUBLE
58514: EQUAL
58515: IFTRUE 58519
58517: GO 58537
58519: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
58520: LD_ADDR_VAR 0 3
58524: PUSH
58525: LD_INT 13
58527: PUSH
58528: LD_INT 14
58530: PUSH
58531: EMPTY
58532: LIST
58533: LIST
58534: ST_TO_ADDR
58535: GO 58940
58537: LD_INT 31
58539: DOUBLE
58540: EQUAL
58541: IFTRUE 58545
58543: GO 58563
58545: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
58546: LD_ADDR_VAR 0 3
58550: PUSH
58551: LD_INT 13
58553: PUSH
58554: LD_INT 14
58556: PUSH
58557: EMPTY
58558: LIST
58559: LIST
58560: ST_TO_ADDR
58561: GO 58940
58563: LD_INT 26
58565: DOUBLE
58566: EQUAL
58567: IFTRUE 58571
58569: GO 58589
58571: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
58572: LD_ADDR_VAR 0 3
58576: PUSH
58577: LD_INT 13
58579: PUSH
58580: LD_INT 14
58582: PUSH
58583: EMPTY
58584: LIST
58585: LIST
58586: ST_TO_ADDR
58587: GO 58940
58589: LD_INT 42
58591: DOUBLE
58592: EQUAL
58593: IFTRUE 58597
58595: GO 58623
58597: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
58598: LD_ADDR_VAR 0 3
58602: PUSH
58603: LD_INT 21
58605: PUSH
58606: LD_INT 22
58608: PUSH
58609: LD_INT 23
58611: PUSH
58612: LD_INT 24
58614: PUSH
58615: EMPTY
58616: LIST
58617: LIST
58618: LIST
58619: LIST
58620: ST_TO_ADDR
58621: GO 58940
58623: LD_INT 43
58625: DOUBLE
58626: EQUAL
58627: IFTRUE 58631
58629: GO 58657
58631: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
58632: LD_ADDR_VAR 0 3
58636: PUSH
58637: LD_INT 21
58639: PUSH
58640: LD_INT 22
58642: PUSH
58643: LD_INT 23
58645: PUSH
58646: LD_INT 24
58648: PUSH
58649: EMPTY
58650: LIST
58651: LIST
58652: LIST
58653: LIST
58654: ST_TO_ADDR
58655: GO 58940
58657: LD_INT 44
58659: DOUBLE
58660: EQUAL
58661: IFTRUE 58665
58663: GO 58691
58665: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
58666: LD_ADDR_VAR 0 3
58670: PUSH
58671: LD_INT 21
58673: PUSH
58674: LD_INT 22
58676: PUSH
58677: LD_INT 23
58679: PUSH
58680: LD_INT 24
58682: PUSH
58683: EMPTY
58684: LIST
58685: LIST
58686: LIST
58687: LIST
58688: ST_TO_ADDR
58689: GO 58940
58691: LD_INT 45
58693: DOUBLE
58694: EQUAL
58695: IFTRUE 58699
58697: GO 58725
58699: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
58700: LD_ADDR_VAR 0 3
58704: PUSH
58705: LD_INT 21
58707: PUSH
58708: LD_INT 22
58710: PUSH
58711: LD_INT 23
58713: PUSH
58714: LD_INT 24
58716: PUSH
58717: EMPTY
58718: LIST
58719: LIST
58720: LIST
58721: LIST
58722: ST_TO_ADDR
58723: GO 58940
58725: LD_INT 49
58727: DOUBLE
58728: EQUAL
58729: IFTRUE 58733
58731: GO 58759
58733: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
58734: LD_ADDR_VAR 0 3
58738: PUSH
58739: LD_INT 21
58741: PUSH
58742: LD_INT 22
58744: PUSH
58745: LD_INT 23
58747: PUSH
58748: LD_INT 24
58750: PUSH
58751: EMPTY
58752: LIST
58753: LIST
58754: LIST
58755: LIST
58756: ST_TO_ADDR
58757: GO 58940
58759: LD_INT 51
58761: DOUBLE
58762: EQUAL
58763: IFTRUE 58767
58765: GO 58793
58767: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
58768: LD_ADDR_VAR 0 3
58772: PUSH
58773: LD_INT 21
58775: PUSH
58776: LD_INT 22
58778: PUSH
58779: LD_INT 23
58781: PUSH
58782: LD_INT 24
58784: PUSH
58785: EMPTY
58786: LIST
58787: LIST
58788: LIST
58789: LIST
58790: ST_TO_ADDR
58791: GO 58940
58793: LD_INT 52
58795: DOUBLE
58796: EQUAL
58797: IFTRUE 58801
58799: GO 58827
58801: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
58802: LD_ADDR_VAR 0 3
58806: PUSH
58807: LD_INT 21
58809: PUSH
58810: LD_INT 22
58812: PUSH
58813: LD_INT 23
58815: PUSH
58816: LD_INT 24
58818: PUSH
58819: EMPTY
58820: LIST
58821: LIST
58822: LIST
58823: LIST
58824: ST_TO_ADDR
58825: GO 58940
58827: LD_INT 53
58829: DOUBLE
58830: EQUAL
58831: IFTRUE 58835
58833: GO 58853
58835: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
58836: LD_ADDR_VAR 0 3
58840: PUSH
58841: LD_INT 23
58843: PUSH
58844: LD_INT 24
58846: PUSH
58847: EMPTY
58848: LIST
58849: LIST
58850: ST_TO_ADDR
58851: GO 58940
58853: LD_INT 46
58855: DOUBLE
58856: EQUAL
58857: IFTRUE 58861
58859: GO 58879
58861: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
58862: LD_ADDR_VAR 0 3
58866: PUSH
58867: LD_INT 23
58869: PUSH
58870: LD_INT 24
58872: PUSH
58873: EMPTY
58874: LIST
58875: LIST
58876: ST_TO_ADDR
58877: GO 58940
58879: LD_INT 47
58881: DOUBLE
58882: EQUAL
58883: IFTRUE 58887
58885: GO 58905
58887: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_radar :
58888: LD_ADDR_VAR 0 3
58892: PUSH
58893: LD_INT 23
58895: PUSH
58896: LD_INT 24
58898: PUSH
58899: EMPTY
58900: LIST
58901: LIST
58902: ST_TO_ADDR
58903: GO 58940
58905: LD_INT 98
58907: DOUBLE
58908: EQUAL
58909: IFTRUE 58913
58911: GO 58939
58913: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
58914: LD_ADDR_VAR 0 3
58918: PUSH
58919: LD_INT 21
58921: PUSH
58922: LD_INT 22
58924: PUSH
58925: LD_INT 23
58927: PUSH
58928: LD_INT 24
58930: PUSH
58931: EMPTY
58932: LIST
58933: LIST
58934: LIST
58935: LIST
58936: ST_TO_ADDR
58937: GO 58940
58939: POP
// result := ( chassis in result ) ;
58940: LD_ADDR_VAR 0 3
58944: PUSH
58945: LD_VAR 0 1
58949: PUSH
58950: LD_VAR 0 3
58954: IN
58955: ST_TO_ADDR
// end ;
58956: LD_VAR 0 3
58960: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
58961: LD_INT 0
58963: PPUSH
58964: PPUSH
58965: PPUSH
58966: PPUSH
58967: PPUSH
58968: PPUSH
58969: PPUSH
// result := array ;
58970: LD_ADDR_VAR 0 5
58974: PUSH
58975: LD_VAR 0 1
58979: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
58980: LD_VAR 0 1
58984: NOT
58985: IFTRUE 58994
58987: PUSH
58988: LD_VAR 0 2
58992: NOT
58993: OR
58994: IFTRUE 59003
58996: PUSH
58997: LD_VAR 0 3
59001: NOT
59002: OR
59003: IFTRUE 59017
59005: PUSH
59006: LD_VAR 0 2
59010: PUSH
59011: LD_VAR 0 1
59015: GREATER
59016: OR
59017: IFTRUE 59031
59019: PUSH
59020: LD_VAR 0 3
59024: PUSH
59025: LD_VAR 0 1
59029: GREATER
59030: OR
59031: IFFALSE 59035
// exit ;
59033: GO 59331
// if direction then
59035: LD_VAR 0 4
59039: IFFALSE 59103
// begin d := 1 ;
59041: LD_ADDR_VAR 0 9
59045: PUSH
59046: LD_INT 1
59048: ST_TO_ADDR
// if i_from > i_to then
59049: LD_VAR 0 2
59053: PUSH
59054: LD_VAR 0 3
59058: GREATER
59059: IFFALSE 59085
// length := ( array - i_from ) + i_to else
59061: LD_ADDR_VAR 0 11
59065: PUSH
59066: LD_VAR 0 1
59070: PUSH
59071: LD_VAR 0 2
59075: MINUS
59076: PUSH
59077: LD_VAR 0 3
59081: PLUS
59082: ST_TO_ADDR
59083: GO 59101
// length := i_to - i_from ;
59085: LD_ADDR_VAR 0 11
59089: PUSH
59090: LD_VAR 0 3
59094: PUSH
59095: LD_VAR 0 2
59099: MINUS
59100: ST_TO_ADDR
// end else
59101: GO 59164
// begin d := - 1 ;
59103: LD_ADDR_VAR 0 9
59107: PUSH
59108: LD_INT 1
59110: NEG
59111: ST_TO_ADDR
// if i_from > i_to then
59112: LD_VAR 0 2
59116: PUSH
59117: LD_VAR 0 3
59121: GREATER
59122: IFFALSE 59142
// length := i_from - i_to else
59124: LD_ADDR_VAR 0 11
59128: PUSH
59129: LD_VAR 0 2
59133: PUSH
59134: LD_VAR 0 3
59138: MINUS
59139: ST_TO_ADDR
59140: GO 59164
// length := ( array - i_to ) + i_from ;
59142: LD_ADDR_VAR 0 11
59146: PUSH
59147: LD_VAR 0 1
59151: PUSH
59152: LD_VAR 0 3
59156: MINUS
59157: PUSH
59158: LD_VAR 0 2
59162: PLUS
59163: ST_TO_ADDR
// end ; if not length then
59164: LD_VAR 0 11
59168: NOT
59169: IFFALSE 59173
// exit ;
59171: GO 59331
// tmp := array ;
59173: LD_ADDR_VAR 0 10
59177: PUSH
59178: LD_VAR 0 1
59182: ST_TO_ADDR
// for i = 1 to length do
59183: LD_ADDR_VAR 0 6
59187: PUSH
59188: DOUBLE
59189: LD_INT 1
59191: DEC
59192: ST_TO_ADDR
59193: LD_VAR 0 11
59197: PUSH
59198: FOR_TO
59199: IFFALSE 59319
// begin for j = 1 to array do
59201: LD_ADDR_VAR 0 7
59205: PUSH
59206: DOUBLE
59207: LD_INT 1
59209: DEC
59210: ST_TO_ADDR
59211: LD_VAR 0 1
59215: PUSH
59216: FOR_TO
59217: IFFALSE 59305
// begin k := j + d ;
59219: LD_ADDR_VAR 0 8
59223: PUSH
59224: LD_VAR 0 7
59228: PUSH
59229: LD_VAR 0 9
59233: PLUS
59234: ST_TO_ADDR
// if k > array then
59235: LD_VAR 0 8
59239: PUSH
59240: LD_VAR 0 1
59244: GREATER
59245: IFFALSE 59255
// k := 1 ;
59247: LD_ADDR_VAR 0 8
59251: PUSH
59252: LD_INT 1
59254: ST_TO_ADDR
// if not k then
59255: LD_VAR 0 8
59259: NOT
59260: IFFALSE 59272
// k := array ;
59262: LD_ADDR_VAR 0 8
59266: PUSH
59267: LD_VAR 0 1
59271: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
59272: LD_ADDR_VAR 0 10
59276: PUSH
59277: LD_VAR 0 10
59281: PPUSH
59282: LD_VAR 0 8
59286: PPUSH
59287: LD_VAR 0 1
59291: PUSH
59292: LD_VAR 0 7
59296: ARRAY
59297: PPUSH
59298: CALL_OW 1
59302: ST_TO_ADDR
// end ;
59303: GO 59216
59305: POP
59306: POP
// array := tmp ;
59307: LD_ADDR_VAR 0 1
59311: PUSH
59312: LD_VAR 0 10
59316: ST_TO_ADDR
// end ;
59317: GO 59198
59319: POP
59320: POP
// result := array ;
59321: LD_ADDR_VAR 0 5
59325: PUSH
59326: LD_VAR 0 1
59330: ST_TO_ADDR
// end ;
59331: LD_VAR 0 5
59335: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
59336: LD_INT 0
59338: PPUSH
59339: PPUSH
// result := 0 ;
59340: LD_ADDR_VAR 0 3
59344: PUSH
59345: LD_INT 0
59347: ST_TO_ADDR
// if not array or not value in array then
59348: LD_VAR 0 1
59352: NOT
59353: IFTRUE 59368
59355: PUSH
59356: LD_VAR 0 2
59360: PUSH
59361: LD_VAR 0 1
59365: IN
59366: NOT
59367: OR
59368: IFFALSE 59372
// exit ;
59370: GO 59426
// for i = 1 to array do
59372: LD_ADDR_VAR 0 4
59376: PUSH
59377: DOUBLE
59378: LD_INT 1
59380: DEC
59381: ST_TO_ADDR
59382: LD_VAR 0 1
59386: PUSH
59387: FOR_TO
59388: IFFALSE 59424
// if value = array [ i ] then
59390: LD_VAR 0 2
59394: PUSH
59395: LD_VAR 0 1
59399: PUSH
59400: LD_VAR 0 4
59404: ARRAY
59405: EQUAL
59406: IFFALSE 59422
// begin result := i ;
59408: LD_ADDR_VAR 0 3
59412: PUSH
59413: LD_VAR 0 4
59417: ST_TO_ADDR
// exit ;
59418: POP
59419: POP
59420: GO 59426
// end ;
59422: GO 59387
59424: POP
59425: POP
// end ;
59426: LD_VAR 0 3
59430: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
59431: LD_INT 0
59433: PPUSH
// vc_chassis := chassis ;
59434: LD_ADDR_OWVAR 37
59438: PUSH
59439: LD_VAR 0 1
59443: ST_TO_ADDR
// vc_engine := engine ;
59444: LD_ADDR_OWVAR 39
59448: PUSH
59449: LD_VAR 0 2
59453: ST_TO_ADDR
// vc_control := control ;
59454: LD_ADDR_OWVAR 38
59458: PUSH
59459: LD_VAR 0 3
59463: ST_TO_ADDR
// vc_weapon := weapon ;
59464: LD_ADDR_OWVAR 40
59468: PUSH
59469: LD_VAR 0 4
59473: ST_TO_ADDR
// vc_fuel_battery := fuel ;
59474: LD_ADDR_OWVAR 41
59478: PUSH
59479: LD_VAR 0 5
59483: ST_TO_ADDR
// end ;
59484: LD_VAR 0 6
59488: RET
// export function WantPlant ( unit ) ; var task ; begin
59489: LD_INT 0
59491: PPUSH
59492: PPUSH
// result := false ;
59493: LD_ADDR_VAR 0 2
59497: PUSH
59498: LD_INT 0
59500: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
59501: LD_ADDR_VAR 0 3
59505: PUSH
59506: LD_VAR 0 1
59510: PPUSH
59511: CALL_OW 437
59515: ST_TO_ADDR
// if task then
59516: LD_VAR 0 3
59520: IFFALSE 59548
// if task [ 1 ] [ 1 ] = p then
59522: LD_VAR 0 3
59526: PUSH
59527: LD_INT 1
59529: ARRAY
59530: PUSH
59531: LD_INT 1
59533: ARRAY
59534: PUSH
59535: LD_STRING p
59537: EQUAL
59538: IFFALSE 59548
// result := true ;
59540: LD_ADDR_VAR 0 2
59544: PUSH
59545: LD_INT 1
59547: ST_TO_ADDR
// end ;
59548: LD_VAR 0 2
59552: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
59553: LD_INT 0
59555: PPUSH
59556: PPUSH
59557: PPUSH
59558: PPUSH
// if pos < 1 then
59559: LD_VAR 0 2
59563: PUSH
59564: LD_INT 1
59566: LESS
59567: IFFALSE 59571
// exit ;
59569: GO 59874
// if pos = 1 then
59571: LD_VAR 0 2
59575: PUSH
59576: LD_INT 1
59578: EQUAL
59579: IFFALSE 59612
// result := Replace ( arr , pos [ 1 ] , value ) else
59581: LD_ADDR_VAR 0 4
59585: PUSH
59586: LD_VAR 0 1
59590: PPUSH
59591: LD_VAR 0 2
59595: PUSH
59596: LD_INT 1
59598: ARRAY
59599: PPUSH
59600: LD_VAR 0 3
59604: PPUSH
59605: CALL_OW 1
59609: ST_TO_ADDR
59610: GO 59874
// begin tmp := arr ;
59612: LD_ADDR_VAR 0 6
59616: PUSH
59617: LD_VAR 0 1
59621: ST_TO_ADDR
// s_arr := [ tmp ] ;
59622: LD_ADDR_VAR 0 7
59626: PUSH
59627: LD_VAR 0 6
59631: PUSH
59632: EMPTY
59633: LIST
59634: ST_TO_ADDR
// for i = 1 to pos - 1 do
59635: LD_ADDR_VAR 0 5
59639: PUSH
59640: DOUBLE
59641: LD_INT 1
59643: DEC
59644: ST_TO_ADDR
59645: LD_VAR 0 2
59649: PUSH
59650: LD_INT 1
59652: MINUS
59653: PUSH
59654: FOR_TO
59655: IFFALSE 59700
// begin tmp := tmp [ pos [ i ] ] ;
59657: LD_ADDR_VAR 0 6
59661: PUSH
59662: LD_VAR 0 6
59666: PUSH
59667: LD_VAR 0 2
59671: PUSH
59672: LD_VAR 0 5
59676: ARRAY
59677: ARRAY
59678: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
59679: LD_ADDR_VAR 0 7
59683: PUSH
59684: LD_VAR 0 7
59688: PUSH
59689: LD_VAR 0 6
59693: PUSH
59694: EMPTY
59695: LIST
59696: ADD
59697: ST_TO_ADDR
// end ;
59698: GO 59654
59700: POP
59701: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
59702: LD_ADDR_VAR 0 6
59706: PUSH
59707: LD_VAR 0 6
59711: PPUSH
59712: LD_VAR 0 2
59716: PUSH
59717: LD_VAR 0 2
59721: ARRAY
59722: PPUSH
59723: LD_VAR 0 3
59727: PPUSH
59728: CALL_OW 1
59732: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
59733: LD_ADDR_VAR 0 7
59737: PUSH
59738: LD_VAR 0 7
59742: PPUSH
59743: LD_VAR 0 7
59747: PPUSH
59748: LD_VAR 0 6
59752: PPUSH
59753: CALL_OW 1
59757: ST_TO_ADDR
// for i = s_arr downto 2 do
59758: LD_ADDR_VAR 0 5
59762: PUSH
59763: DOUBLE
59764: LD_VAR 0 7
59768: INC
59769: ST_TO_ADDR
59770: LD_INT 2
59772: PUSH
59773: FOR_DOWNTO
59774: IFFALSE 59858
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
59776: LD_ADDR_VAR 0 6
59780: PUSH
59781: LD_VAR 0 7
59785: PUSH
59786: LD_VAR 0 5
59790: PUSH
59791: LD_INT 1
59793: MINUS
59794: ARRAY
59795: PPUSH
59796: LD_VAR 0 2
59800: PUSH
59801: LD_VAR 0 5
59805: PUSH
59806: LD_INT 1
59808: MINUS
59809: ARRAY
59810: PPUSH
59811: LD_VAR 0 7
59815: PUSH
59816: LD_VAR 0 5
59820: ARRAY
59821: PPUSH
59822: CALL_OW 1
59826: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
59827: LD_ADDR_VAR 0 7
59831: PUSH
59832: LD_VAR 0 7
59836: PPUSH
59837: LD_VAR 0 5
59841: PUSH
59842: LD_INT 1
59844: MINUS
59845: PPUSH
59846: LD_VAR 0 6
59850: PPUSH
59851: CALL_OW 1
59855: ST_TO_ADDR
// end ;
59856: GO 59773
59858: POP
59859: POP
// result := s_arr [ 1 ] ;
59860: LD_ADDR_VAR 0 4
59864: PUSH
59865: LD_VAR 0 7
59869: PUSH
59870: LD_INT 1
59872: ARRAY
59873: ST_TO_ADDR
// end ; end ;
59874: LD_VAR 0 4
59878: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
59879: LD_INT 0
59881: PPUSH
59882: PPUSH
// if not list then
59883: LD_VAR 0 1
59887: NOT
59888: IFFALSE 59892
// exit ;
59890: GO 59983
// i := list [ pos1 ] ;
59892: LD_ADDR_VAR 0 5
59896: PUSH
59897: LD_VAR 0 1
59901: PUSH
59902: LD_VAR 0 2
59906: ARRAY
59907: ST_TO_ADDR
// if not i then
59908: LD_VAR 0 5
59912: NOT
59913: IFFALSE 59917
// exit ;
59915: GO 59983
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
59917: LD_ADDR_VAR 0 1
59921: PUSH
59922: LD_VAR 0 1
59926: PPUSH
59927: LD_VAR 0 2
59931: PPUSH
59932: LD_VAR 0 1
59936: PUSH
59937: LD_VAR 0 3
59941: ARRAY
59942: PPUSH
59943: CALL_OW 1
59947: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
59948: LD_ADDR_VAR 0 1
59952: PUSH
59953: LD_VAR 0 1
59957: PPUSH
59958: LD_VAR 0 3
59962: PPUSH
59963: LD_VAR 0 5
59967: PPUSH
59968: CALL_OW 1
59972: ST_TO_ADDR
// result := list ;
59973: LD_ADDR_VAR 0 4
59977: PUSH
59978: LD_VAR 0 1
59982: ST_TO_ADDR
// end ;
59983: LD_VAR 0 4
59987: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
59988: LD_INT 0
59990: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
59991: LD_ADDR_VAR 0 5
59995: PUSH
59996: LD_VAR 0 1
60000: PPUSH
60001: CALL_OW 250
60005: PPUSH
60006: LD_VAR 0 1
60010: PPUSH
60011: CALL_OW 251
60015: PPUSH
60016: LD_VAR 0 2
60020: PPUSH
60021: LD_VAR 0 3
60025: PPUSH
60026: LD_VAR 0 4
60030: PPUSH
60031: CALL 60413 0 5
60035: ST_TO_ADDR
// end ;
60036: LD_VAR 0 5
60040: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
60041: LD_INT 0
60043: PPUSH
60044: PPUSH
60045: PPUSH
60046: PPUSH
// if not list or not unit then
60047: LD_VAR 0 2
60051: NOT
60052: IFTRUE 60061
60054: PUSH
60055: LD_VAR 0 1
60059: NOT
60060: OR
60061: IFFALSE 60065
// exit ;
60063: GO 60408
// result := [ ] ;
60065: LD_ADDR_VAR 0 5
60069: PUSH
60070: EMPTY
60071: ST_TO_ADDR
// for i in list do
60072: LD_ADDR_VAR 0 6
60076: PUSH
60077: LD_VAR 0 2
60081: PUSH
60082: FOR_IN
60083: IFFALSE 60301
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60085: LD_ADDR_VAR 0 8
60089: PUSH
60090: LD_VAR 0 1
60094: PPUSH
60095: LD_VAR 0 6
60099: PUSH
60100: LD_INT 1
60102: ARRAY
60103: PPUSH
60104: LD_VAR 0 6
60108: PUSH
60109: LD_INT 2
60111: ARRAY
60112: PPUSH
60113: CALL_OW 297
60117: ST_TO_ADDR
// if not Count ( result ) then
60118: LD_VAR 0 5
60122: PPUSH
60123: CALL 56635 0 1
60127: NOT
60128: IFFALSE 60161
// begin result := Join ( result , [ i , tmp ] ) ;
60130: LD_ADDR_VAR 0 5
60134: PUSH
60135: LD_VAR 0 5
60139: PPUSH
60140: LD_VAR 0 6
60144: PUSH
60145: LD_VAR 0 8
60149: PUSH
60150: EMPTY
60151: LIST
60152: LIST
60153: PPUSH
60154: CALL 92601 0 2
60158: ST_TO_ADDR
// continue ;
60159: GO 60082
// end ; if result [ result ] [ 2 ] <= tmp then
60161: LD_VAR 0 5
60165: PUSH
60166: LD_VAR 0 5
60170: ARRAY
60171: PUSH
60172: LD_INT 2
60174: ARRAY
60175: PUSH
60176: LD_VAR 0 8
60180: LESSEQUAL
60181: IFFALSE 60214
// result := Join ( result , [ i , tmp ] ) else
60183: LD_ADDR_VAR 0 5
60187: PUSH
60188: LD_VAR 0 5
60192: PPUSH
60193: LD_VAR 0 6
60197: PUSH
60198: LD_VAR 0 8
60202: PUSH
60203: EMPTY
60204: LIST
60205: LIST
60206: PPUSH
60207: CALL 92601 0 2
60211: ST_TO_ADDR
60212: GO 60299
// begin for j := 1 to Count ( result ) do
60214: LD_ADDR_VAR 0 7
60218: PUSH
60219: DOUBLE
60220: LD_INT 1
60222: DEC
60223: ST_TO_ADDR
60224: LD_VAR 0 5
60228: PPUSH
60229: CALL 56635 0 1
60233: PUSH
60234: FOR_TO
60235: IFFALSE 60297
// begin if tmp < result [ j ] [ 2 ] then
60237: LD_VAR 0 8
60241: PUSH
60242: LD_VAR 0 5
60246: PUSH
60247: LD_VAR 0 7
60251: ARRAY
60252: PUSH
60253: LD_INT 2
60255: ARRAY
60256: LESS
60257: IFFALSE 60295
// begin result := Insert ( result , j , [ i , tmp ] ) ;
60259: LD_ADDR_VAR 0 5
60263: PUSH
60264: LD_VAR 0 5
60268: PPUSH
60269: LD_VAR 0 7
60273: PPUSH
60274: LD_VAR 0 6
60278: PUSH
60279: LD_VAR 0 8
60283: PUSH
60284: EMPTY
60285: LIST
60286: LIST
60287: PPUSH
60288: CALL_OW 2
60292: ST_TO_ADDR
// break ;
60293: GO 60297
// end ; end ;
60295: GO 60234
60297: POP
60298: POP
// end ; end ;
60299: GO 60082
60301: POP
60302: POP
// if result and not asc then
60303: LD_VAR 0 5
60307: IFFALSE 60316
60309: PUSH
60310: LD_VAR 0 3
60314: NOT
60315: AND
60316: IFFALSE 60333
// result := ReverseArray ( result ) ;
60318: LD_ADDR_VAR 0 5
60322: PUSH
60323: LD_VAR 0 5
60327: PPUSH
60328: CALL 87691 0 1
60332: ST_TO_ADDR
// tmp := [ ] ;
60333: LD_ADDR_VAR 0 8
60337: PUSH
60338: EMPTY
60339: ST_TO_ADDR
// if mode then
60340: LD_VAR 0 4
60344: IFFALSE 60408
// begin for i := 1 to result do
60346: LD_ADDR_VAR 0 6
60350: PUSH
60351: DOUBLE
60352: LD_INT 1
60354: DEC
60355: ST_TO_ADDR
60356: LD_VAR 0 5
60360: PUSH
60361: FOR_TO
60362: IFFALSE 60396
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
60364: LD_ADDR_VAR 0 8
60368: PUSH
60369: LD_VAR 0 8
60373: PPUSH
60374: LD_VAR 0 5
60378: PUSH
60379: LD_VAR 0 6
60383: ARRAY
60384: PUSH
60385: LD_INT 1
60387: ARRAY
60388: PPUSH
60389: CALL 92601 0 2
60393: ST_TO_ADDR
60394: GO 60361
60396: POP
60397: POP
// result := tmp ;
60398: LD_ADDR_VAR 0 5
60402: PUSH
60403: LD_VAR 0 8
60407: ST_TO_ADDR
// end ; end ;
60408: LD_VAR 0 5
60412: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
60413: LD_INT 0
60415: PPUSH
60416: PPUSH
60417: PPUSH
60418: PPUSH
// if not list then
60419: LD_VAR 0 3
60423: NOT
60424: IFFALSE 60428
// exit ;
60426: GO 60818
// result := [ ] ;
60428: LD_ADDR_VAR 0 6
60432: PUSH
60433: EMPTY
60434: ST_TO_ADDR
// for i in list do
60435: LD_ADDR_VAR 0 7
60439: PUSH
60440: LD_VAR 0 3
60444: PUSH
60445: FOR_IN
60446: IFFALSE 60648
// begin tmp := GetDistUnitXY ( i , x , y ) ;
60448: LD_ADDR_VAR 0 9
60452: PUSH
60453: LD_VAR 0 7
60457: PPUSH
60458: LD_VAR 0 1
60462: PPUSH
60463: LD_VAR 0 2
60467: PPUSH
60468: CALL_OW 297
60472: ST_TO_ADDR
// if not result then
60473: LD_VAR 0 6
60477: NOT
60478: IFFALSE 60504
// result := [ [ i , tmp ] ] else
60480: LD_ADDR_VAR 0 6
60484: PUSH
60485: LD_VAR 0 7
60489: PUSH
60490: LD_VAR 0 9
60494: PUSH
60495: EMPTY
60496: LIST
60497: LIST
60498: PUSH
60499: EMPTY
60500: LIST
60501: ST_TO_ADDR
60502: GO 60646
// begin if result [ result ] [ 2 ] <= tmp then
60504: LD_VAR 0 6
60508: PUSH
60509: LD_VAR 0 6
60513: ARRAY
60514: PUSH
60515: LD_INT 2
60517: ARRAY
60518: PUSH
60519: LD_VAR 0 9
60523: LESSEQUAL
60524: IFFALSE 60566
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
60526: LD_ADDR_VAR 0 6
60530: PUSH
60531: LD_VAR 0 6
60535: PPUSH
60536: LD_VAR 0 6
60540: PUSH
60541: LD_INT 1
60543: PLUS
60544: PPUSH
60545: LD_VAR 0 7
60549: PUSH
60550: LD_VAR 0 9
60554: PUSH
60555: EMPTY
60556: LIST
60557: LIST
60558: PPUSH
60559: CALL_OW 2
60563: ST_TO_ADDR
60564: GO 60646
// for j := 1 to result do
60566: LD_ADDR_VAR 0 8
60570: PUSH
60571: DOUBLE
60572: LD_INT 1
60574: DEC
60575: ST_TO_ADDR
60576: LD_VAR 0 6
60580: PUSH
60581: FOR_TO
60582: IFFALSE 60644
// begin if tmp < result [ j ] [ 2 ] then
60584: LD_VAR 0 9
60588: PUSH
60589: LD_VAR 0 6
60593: PUSH
60594: LD_VAR 0 8
60598: ARRAY
60599: PUSH
60600: LD_INT 2
60602: ARRAY
60603: LESS
60604: IFFALSE 60642
// begin result := Insert ( result , j , [ i , tmp ] ) ;
60606: LD_ADDR_VAR 0 6
60610: PUSH
60611: LD_VAR 0 6
60615: PPUSH
60616: LD_VAR 0 8
60620: PPUSH
60621: LD_VAR 0 7
60625: PUSH
60626: LD_VAR 0 9
60630: PUSH
60631: EMPTY
60632: LIST
60633: LIST
60634: PPUSH
60635: CALL_OW 2
60639: ST_TO_ADDR
// break ;
60640: GO 60644
// end ; end ;
60642: GO 60581
60644: POP
60645: POP
// end ; end ;
60646: GO 60445
60648: POP
60649: POP
// if result and not asc then
60650: LD_VAR 0 6
60654: IFFALSE 60663
60656: PUSH
60657: LD_VAR 0 4
60661: NOT
60662: AND
60663: IFFALSE 60738
// begin tmp := result ;
60665: LD_ADDR_VAR 0 9
60669: PUSH
60670: LD_VAR 0 6
60674: ST_TO_ADDR
// for i = tmp downto 1 do
60675: LD_ADDR_VAR 0 7
60679: PUSH
60680: DOUBLE
60681: LD_VAR 0 9
60685: INC
60686: ST_TO_ADDR
60687: LD_INT 1
60689: PUSH
60690: FOR_DOWNTO
60691: IFFALSE 60736
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
60693: LD_ADDR_VAR 0 6
60697: PUSH
60698: LD_VAR 0 6
60702: PPUSH
60703: LD_VAR 0 9
60707: PUSH
60708: LD_VAR 0 7
60712: MINUS
60713: PUSH
60714: LD_INT 1
60716: PLUS
60717: PPUSH
60718: LD_VAR 0 9
60722: PUSH
60723: LD_VAR 0 7
60727: ARRAY
60728: PPUSH
60729: CALL_OW 1
60733: ST_TO_ADDR
60734: GO 60690
60736: POP
60737: POP
// end ; tmp := [ ] ;
60738: LD_ADDR_VAR 0 9
60742: PUSH
60743: EMPTY
60744: ST_TO_ADDR
// if mode then
60745: LD_VAR 0 5
60749: IFFALSE 60818
// begin for i = 1 to result do
60751: LD_ADDR_VAR 0 7
60755: PUSH
60756: DOUBLE
60757: LD_INT 1
60759: DEC
60760: ST_TO_ADDR
60761: LD_VAR 0 6
60765: PUSH
60766: FOR_TO
60767: IFFALSE 60806
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
60769: LD_ADDR_VAR 0 9
60773: PUSH
60774: LD_VAR 0 9
60778: PPUSH
60779: LD_VAR 0 7
60783: PPUSH
60784: LD_VAR 0 6
60788: PUSH
60789: LD_VAR 0 7
60793: ARRAY
60794: PUSH
60795: LD_INT 1
60797: ARRAY
60798: PPUSH
60799: CALL_OW 1
60803: ST_TO_ADDR
60804: GO 60766
60806: POP
60807: POP
// result := tmp ;
60808: LD_ADDR_VAR 0 6
60812: PUSH
60813: LD_VAR 0 9
60817: ST_TO_ADDR
// end ; end ;
60818: LD_VAR 0 6
60822: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
60823: LD_INT 0
60825: PPUSH
60826: PPUSH
60827: PPUSH
60828: PPUSH
60829: PPUSH
60830: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
60831: LD_ADDR_VAR 0 5
60835: PUSH
60836: LD_INT 0
60838: PUSH
60839: LD_INT 0
60841: PUSH
60842: LD_INT 0
60844: PUSH
60845: EMPTY
60846: PUSH
60847: EMPTY
60848: LIST
60849: LIST
60850: LIST
60851: LIST
60852: ST_TO_ADDR
// if not x or not y then
60853: LD_VAR 0 2
60857: NOT
60858: IFTRUE 60867
60860: PUSH
60861: LD_VAR 0 3
60865: NOT
60866: OR
60867: IFFALSE 60871
// exit ;
60869: GO 62527
// if not range then
60871: LD_VAR 0 4
60875: NOT
60876: IFFALSE 60886
// range := 10 ;
60878: LD_ADDR_VAR 0 4
60882: PUSH
60883: LD_INT 10
60885: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
60886: LD_ADDR_VAR 0 8
60890: PUSH
60891: LD_INT 81
60893: PUSH
60894: LD_VAR 0 1
60898: PUSH
60899: EMPTY
60900: LIST
60901: LIST
60902: PUSH
60903: LD_INT 92
60905: PUSH
60906: LD_VAR 0 2
60910: PUSH
60911: LD_VAR 0 3
60915: PUSH
60916: LD_VAR 0 4
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: LIST
60925: LIST
60926: PUSH
60927: LD_INT 3
60929: PUSH
60930: LD_INT 21
60932: PUSH
60933: LD_INT 3
60935: PUSH
60936: EMPTY
60937: LIST
60938: LIST
60939: PUSH
60940: EMPTY
60941: LIST
60942: LIST
60943: PUSH
60944: EMPTY
60945: LIST
60946: LIST
60947: LIST
60948: PPUSH
60949: CALL_OW 69
60953: ST_TO_ADDR
// if not tmp then
60954: LD_VAR 0 8
60958: NOT
60959: IFFALSE 60963
// exit ;
60961: GO 62527
// for i in tmp do
60963: LD_ADDR_VAR 0 6
60967: PUSH
60968: LD_VAR 0 8
60972: PUSH
60973: FOR_IN
60974: IFFALSE 62502
// begin points := [ 0 , 0 , 0 ] ;
60976: LD_ADDR_VAR 0 9
60980: PUSH
60981: LD_INT 0
60983: PUSH
60984: LD_INT 0
60986: PUSH
60987: LD_INT 0
60989: PUSH
60990: EMPTY
60991: LIST
60992: LIST
60993: LIST
60994: ST_TO_ADDR
// bpoints := 1 ;
60995: LD_ADDR_VAR 0 10
60999: PUSH
61000: LD_INT 1
61002: ST_TO_ADDR
// case GetType ( i ) of unit_human :
61003: LD_VAR 0 6
61007: PPUSH
61008: CALL_OW 247
61012: PUSH
61013: LD_INT 1
61015: DOUBLE
61016: EQUAL
61017: IFTRUE 61021
61019: GO 61603
61021: POP
// begin if GetClass ( i ) = 1 then
61022: LD_VAR 0 6
61026: PPUSH
61027: CALL_OW 257
61031: PUSH
61032: LD_INT 1
61034: EQUAL
61035: IFFALSE 61056
// points := [ 10 , 5 , 3 ] ;
61037: LD_ADDR_VAR 0 9
61041: PUSH
61042: LD_INT 10
61044: PUSH
61045: LD_INT 5
61047: PUSH
61048: LD_INT 3
61050: PUSH
61051: EMPTY
61052: LIST
61053: LIST
61054: LIST
61055: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
61056: LD_VAR 0 6
61060: PPUSH
61061: CALL_OW 257
61065: PUSH
61066: LD_INT 2
61068: PUSH
61069: LD_INT 3
61071: PUSH
61072: LD_INT 4
61074: PUSH
61075: EMPTY
61076: LIST
61077: LIST
61078: LIST
61079: IN
61080: IFFALSE 61101
// points := [ 3 , 2 , 1 ] ;
61082: LD_ADDR_VAR 0 9
61086: PUSH
61087: LD_INT 3
61089: PUSH
61090: LD_INT 2
61092: PUSH
61093: LD_INT 1
61095: PUSH
61096: EMPTY
61097: LIST
61098: LIST
61099: LIST
61100: ST_TO_ADDR
// if GetClass ( i ) = 5 then
61101: LD_VAR 0 6
61105: PPUSH
61106: CALL_OW 257
61110: PUSH
61111: LD_INT 5
61113: EQUAL
61114: IFFALSE 61135
// points := [ 130 , 5 , 2 ] ;
61116: LD_ADDR_VAR 0 9
61120: PUSH
61121: LD_INT 130
61123: PUSH
61124: LD_INT 5
61126: PUSH
61127: LD_INT 2
61129: PUSH
61130: EMPTY
61131: LIST
61132: LIST
61133: LIST
61134: ST_TO_ADDR
// if GetClass ( i ) = 8 then
61135: LD_VAR 0 6
61139: PPUSH
61140: CALL_OW 257
61144: PUSH
61145: LD_INT 8
61147: EQUAL
61148: IFFALSE 61169
// points := [ 35 , 35 , 30 ] ;
61150: LD_ADDR_VAR 0 9
61154: PUSH
61155: LD_INT 35
61157: PUSH
61158: LD_INT 35
61160: PUSH
61161: LD_INT 30
61163: PUSH
61164: EMPTY
61165: LIST
61166: LIST
61167: LIST
61168: ST_TO_ADDR
// if GetClass ( i ) = 9 then
61169: LD_VAR 0 6
61173: PPUSH
61174: CALL_OW 257
61178: PUSH
61179: LD_INT 9
61181: EQUAL
61182: IFFALSE 61203
// points := [ 20 , 55 , 40 ] ;
61184: LD_ADDR_VAR 0 9
61188: PUSH
61189: LD_INT 20
61191: PUSH
61192: LD_INT 55
61194: PUSH
61195: LD_INT 40
61197: PUSH
61198: EMPTY
61199: LIST
61200: LIST
61201: LIST
61202: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
61203: LD_VAR 0 6
61207: PPUSH
61208: CALL_OW 257
61212: PUSH
61213: LD_INT 12
61215: PUSH
61216: LD_INT 16
61218: PUSH
61219: EMPTY
61220: LIST
61221: LIST
61222: IN
61223: IFFALSE 61244
// points := [ 5 , 3 , 2 ] ;
61225: LD_ADDR_VAR 0 9
61229: PUSH
61230: LD_INT 5
61232: PUSH
61233: LD_INT 3
61235: PUSH
61236: LD_INT 2
61238: PUSH
61239: EMPTY
61240: LIST
61241: LIST
61242: LIST
61243: ST_TO_ADDR
// if GetClass ( i ) = 17 then
61244: LD_VAR 0 6
61248: PPUSH
61249: CALL_OW 257
61253: PUSH
61254: LD_INT 17
61256: EQUAL
61257: IFFALSE 61278
// points := [ 100 , 50 , 75 ] ;
61259: LD_ADDR_VAR 0 9
61263: PUSH
61264: LD_INT 100
61266: PUSH
61267: LD_INT 50
61269: PUSH
61270: LD_INT 75
61272: PUSH
61273: EMPTY
61274: LIST
61275: LIST
61276: LIST
61277: ST_TO_ADDR
// if GetClass ( i ) = 15 then
61278: LD_VAR 0 6
61282: PPUSH
61283: CALL_OW 257
61287: PUSH
61288: LD_INT 15
61290: EQUAL
61291: IFFALSE 61312
// points := [ 10 , 5 , 3 ] ;
61293: LD_ADDR_VAR 0 9
61297: PUSH
61298: LD_INT 10
61300: PUSH
61301: LD_INT 5
61303: PUSH
61304: LD_INT 3
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: LIST
61311: ST_TO_ADDR
// if GetClass ( i ) = 14 then
61312: LD_VAR 0 6
61316: PPUSH
61317: CALL_OW 257
61321: PUSH
61322: LD_INT 14
61324: EQUAL
61325: IFFALSE 61346
// points := [ 10 , 0 , 0 ] ;
61327: LD_ADDR_VAR 0 9
61331: PUSH
61332: LD_INT 10
61334: PUSH
61335: LD_INT 0
61337: PUSH
61338: LD_INT 0
61340: PUSH
61341: EMPTY
61342: LIST
61343: LIST
61344: LIST
61345: ST_TO_ADDR
// if GetClass ( i ) = 11 then
61346: LD_VAR 0 6
61350: PPUSH
61351: CALL_OW 257
61355: PUSH
61356: LD_INT 11
61358: EQUAL
61359: IFFALSE 61380
// points := [ 30 , 10 , 5 ] ;
61361: LD_ADDR_VAR 0 9
61365: PUSH
61366: LD_INT 30
61368: PUSH
61369: LD_INT 10
61371: PUSH
61372: LD_INT 5
61374: PUSH
61375: EMPTY
61376: LIST
61377: LIST
61378: LIST
61379: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
61380: LD_VAR 0 1
61384: PPUSH
61385: LD_INT 5
61387: PPUSH
61388: CALL_OW 321
61392: PUSH
61393: LD_INT 2
61395: EQUAL
61396: IFFALSE 61413
// bpoints := bpoints * 1.8 ;
61398: LD_ADDR_VAR 0 10
61402: PUSH
61403: LD_VAR 0 10
61407: PUSH
61408: LD_REAL  1.80000000000000E+0000
61411: MUL
61412: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
61413: LD_VAR 0 6
61417: PPUSH
61418: CALL_OW 257
61422: PUSH
61423: LD_INT 1
61425: PUSH
61426: LD_INT 2
61428: PUSH
61429: LD_INT 3
61431: PUSH
61432: LD_INT 4
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: LIST
61439: LIST
61440: IN
61441: IFFALSE 61461
61443: PUSH
61444: LD_VAR 0 1
61448: PPUSH
61449: LD_INT 51
61451: PPUSH
61452: CALL_OW 321
61456: PUSH
61457: LD_INT 2
61459: EQUAL
61460: AND
61461: IFFALSE 61478
// bpoints := bpoints * 1.2 ;
61463: LD_ADDR_VAR 0 10
61467: PUSH
61468: LD_VAR 0 10
61472: PUSH
61473: LD_REAL  1.20000000000000E+0000
61476: MUL
61477: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
61478: LD_VAR 0 6
61482: PPUSH
61483: CALL_OW 257
61487: PUSH
61488: LD_INT 5
61490: PUSH
61491: LD_INT 7
61493: PUSH
61494: LD_INT 9
61496: PUSH
61497: EMPTY
61498: LIST
61499: LIST
61500: LIST
61501: IN
61502: IFFALSE 61522
61504: PUSH
61505: LD_VAR 0 1
61509: PPUSH
61510: LD_INT 52
61512: PPUSH
61513: CALL_OW 321
61517: PUSH
61518: LD_INT 2
61520: EQUAL
61521: AND
61522: IFFALSE 61539
// bpoints := bpoints * 1.5 ;
61524: LD_ADDR_VAR 0 10
61528: PUSH
61529: LD_VAR 0 10
61533: PUSH
61534: LD_REAL  1.50000000000000E+0000
61537: MUL
61538: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
61539: LD_VAR 0 1
61543: PPUSH
61544: LD_INT 66
61546: PPUSH
61547: CALL_OW 321
61551: PUSH
61552: LD_INT 2
61554: EQUAL
61555: IFFALSE 61572
// bpoints := bpoints * 1.1 ;
61557: LD_ADDR_VAR 0 10
61561: PUSH
61562: LD_VAR 0 10
61566: PUSH
61567: LD_REAL  1.10000000000000E+0000
61570: MUL
61571: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
61572: LD_ADDR_VAR 0 10
61576: PUSH
61577: LD_VAR 0 10
61581: PUSH
61582: LD_VAR 0 6
61586: PPUSH
61587: LD_INT 1
61589: PPUSH
61590: CALL_OW 259
61594: PUSH
61595: LD_REAL  1.15000000000000E+0000
61598: MUL
61599: MUL
61600: ST_TO_ADDR
// end ; unit_vehicle :
61601: GO 62431
61603: LD_INT 2
61605: DOUBLE
61606: EQUAL
61607: IFTRUE 61611
61609: GO 62419
61611: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
61612: LD_VAR 0 6
61616: PPUSH
61617: CALL_OW 264
61621: PUSH
61622: LD_INT 2
61624: PUSH
61625: LD_INT 42
61627: PUSH
61628: LD_INT 24
61630: PUSH
61631: EMPTY
61632: LIST
61633: LIST
61634: LIST
61635: IN
61636: IFFALSE 61657
// points := [ 25 , 5 , 3 ] ;
61638: LD_ADDR_VAR 0 9
61642: PUSH
61643: LD_INT 25
61645: PUSH
61646: LD_INT 5
61648: PUSH
61649: LD_INT 3
61651: PUSH
61652: EMPTY
61653: LIST
61654: LIST
61655: LIST
61656: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
61657: LD_VAR 0 6
61661: PPUSH
61662: CALL_OW 264
61666: PUSH
61667: LD_INT 4
61669: PUSH
61670: LD_INT 43
61672: PUSH
61673: LD_INT 25
61675: PUSH
61676: EMPTY
61677: LIST
61678: LIST
61679: LIST
61680: IN
61681: IFFALSE 61702
// points := [ 40 , 15 , 5 ] ;
61683: LD_ADDR_VAR 0 9
61687: PUSH
61688: LD_INT 40
61690: PUSH
61691: LD_INT 15
61693: PUSH
61694: LD_INT 5
61696: PUSH
61697: EMPTY
61698: LIST
61699: LIST
61700: LIST
61701: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
61702: LD_VAR 0 6
61706: PPUSH
61707: CALL_OW 264
61711: PUSH
61712: LD_INT 3
61714: PUSH
61715: LD_INT 23
61717: PUSH
61718: EMPTY
61719: LIST
61720: LIST
61721: IN
61722: IFFALSE 61743
// points := [ 7 , 25 , 8 ] ;
61724: LD_ADDR_VAR 0 9
61728: PUSH
61729: LD_INT 7
61731: PUSH
61732: LD_INT 25
61734: PUSH
61735: LD_INT 8
61737: PUSH
61738: EMPTY
61739: LIST
61740: LIST
61741: LIST
61742: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
61743: LD_VAR 0 6
61747: PPUSH
61748: CALL_OW 264
61752: PUSH
61753: LD_INT 5
61755: PUSH
61756: LD_INT 27
61758: PUSH
61759: LD_INT 44
61761: PUSH
61762: EMPTY
61763: LIST
61764: LIST
61765: LIST
61766: IN
61767: IFFALSE 61788
// points := [ 14 , 50 , 16 ] ;
61769: LD_ADDR_VAR 0 9
61773: PUSH
61774: LD_INT 14
61776: PUSH
61777: LD_INT 50
61779: PUSH
61780: LD_INT 16
61782: PUSH
61783: EMPTY
61784: LIST
61785: LIST
61786: LIST
61787: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
61788: LD_VAR 0 6
61792: PPUSH
61793: CALL_OW 264
61797: PUSH
61798: LD_INT 6
61800: PUSH
61801: LD_INT 46
61803: PUSH
61804: EMPTY
61805: LIST
61806: LIST
61807: IN
61808: IFFALSE 61829
// points := [ 32 , 120 , 70 ] ;
61810: LD_ADDR_VAR 0 9
61814: PUSH
61815: LD_INT 32
61817: PUSH
61818: LD_INT 120
61820: PUSH
61821: LD_INT 70
61823: PUSH
61824: EMPTY
61825: LIST
61826: LIST
61827: LIST
61828: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
61829: LD_VAR 0 6
61833: PPUSH
61834: CALL_OW 264
61838: PUSH
61839: LD_INT 7
61841: PUSH
61842: LD_INT 28
61844: PUSH
61845: LD_INT 45
61847: PUSH
61848: LD_INT 92
61850: PUSH
61851: EMPTY
61852: LIST
61853: LIST
61854: LIST
61855: LIST
61856: IN
61857: IFFALSE 61878
// points := [ 35 , 20 , 45 ] ;
61859: LD_ADDR_VAR 0 9
61863: PUSH
61864: LD_INT 35
61866: PUSH
61867: LD_INT 20
61869: PUSH
61870: LD_INT 45
61872: PUSH
61873: EMPTY
61874: LIST
61875: LIST
61876: LIST
61877: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
61878: LD_VAR 0 6
61882: PPUSH
61883: CALL_OW 264
61887: PUSH
61888: LD_INT 47
61890: PUSH
61891: EMPTY
61892: LIST
61893: IN
61894: IFFALSE 61915
// points := [ 67 , 45 , 75 ] ;
61896: LD_ADDR_VAR 0 9
61900: PUSH
61901: LD_INT 67
61903: PUSH
61904: LD_INT 45
61906: PUSH
61907: LD_INT 75
61909: PUSH
61910: EMPTY
61911: LIST
61912: LIST
61913: LIST
61914: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
61915: LD_VAR 0 6
61919: PPUSH
61920: CALL_OW 264
61924: PUSH
61925: LD_INT 26
61927: PUSH
61928: EMPTY
61929: LIST
61930: IN
61931: IFFALSE 61952
// points := [ 120 , 30 , 80 ] ;
61933: LD_ADDR_VAR 0 9
61937: PUSH
61938: LD_INT 120
61940: PUSH
61941: LD_INT 30
61943: PUSH
61944: LD_INT 80
61946: PUSH
61947: EMPTY
61948: LIST
61949: LIST
61950: LIST
61951: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
61952: LD_VAR 0 6
61956: PPUSH
61957: CALL_OW 264
61961: PUSH
61962: LD_INT 22
61964: PUSH
61965: EMPTY
61966: LIST
61967: IN
61968: IFFALSE 61989
// points := [ 40 , 1 , 1 ] ;
61970: LD_ADDR_VAR 0 9
61974: PUSH
61975: LD_INT 40
61977: PUSH
61978: LD_INT 1
61980: PUSH
61981: LD_INT 1
61983: PUSH
61984: EMPTY
61985: LIST
61986: LIST
61987: LIST
61988: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
61989: LD_VAR 0 6
61993: PPUSH
61994: CALL_OW 264
61998: PUSH
61999: LD_INT 29
62001: PUSH
62002: EMPTY
62003: LIST
62004: IN
62005: IFFALSE 62026
// points := [ 70 , 200 , 400 ] ;
62007: LD_ADDR_VAR 0 9
62011: PUSH
62012: LD_INT 70
62014: PUSH
62015: LD_INT 200
62017: PUSH
62018: LD_INT 400
62020: PUSH
62021: EMPTY
62022: LIST
62023: LIST
62024: LIST
62025: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
62026: LD_VAR 0 6
62030: PPUSH
62031: CALL_OW 264
62035: PUSH
62036: LD_INT 14
62038: PUSH
62039: LD_INT 53
62041: PUSH
62042: EMPTY
62043: LIST
62044: LIST
62045: IN
62046: IFFALSE 62067
// points := [ 40 , 10 , 20 ] ;
62048: LD_ADDR_VAR 0 9
62052: PUSH
62053: LD_INT 40
62055: PUSH
62056: LD_INT 10
62058: PUSH
62059: LD_INT 20
62061: PUSH
62062: EMPTY
62063: LIST
62064: LIST
62065: LIST
62066: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
62067: LD_VAR 0 6
62071: PPUSH
62072: CALL_OW 264
62076: PUSH
62077: LD_INT 9
62079: PUSH
62080: EMPTY
62081: LIST
62082: IN
62083: IFFALSE 62104
// points := [ 5 , 70 , 20 ] ;
62085: LD_ADDR_VAR 0 9
62089: PUSH
62090: LD_INT 5
62092: PUSH
62093: LD_INT 70
62095: PUSH
62096: LD_INT 20
62098: PUSH
62099: EMPTY
62100: LIST
62101: LIST
62102: LIST
62103: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
62104: LD_VAR 0 6
62108: PPUSH
62109: CALL_OW 264
62113: PUSH
62114: LD_INT 10
62116: PUSH
62117: EMPTY
62118: LIST
62119: IN
62120: IFFALSE 62141
// points := [ 35 , 110 , 70 ] ;
62122: LD_ADDR_VAR 0 9
62126: PUSH
62127: LD_INT 35
62129: PUSH
62130: LD_INT 110
62132: PUSH
62133: LD_INT 70
62135: PUSH
62136: EMPTY
62137: LIST
62138: LIST
62139: LIST
62140: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
62141: LD_VAR 0 6
62145: PPUSH
62146: CALL_OW 265
62150: PUSH
62151: LD_INT 25
62153: EQUAL
62154: IFFALSE 62175
// points := [ 80 , 65 , 100 ] ;
62156: LD_ADDR_VAR 0 9
62160: PUSH
62161: LD_INT 80
62163: PUSH
62164: LD_INT 65
62166: PUSH
62167: LD_INT 100
62169: PUSH
62170: EMPTY
62171: LIST
62172: LIST
62173: LIST
62174: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
62175: LD_VAR 0 6
62179: PPUSH
62180: CALL_OW 263
62184: PUSH
62185: LD_INT 1
62187: EQUAL
62188: IFFALSE 62223
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
62190: LD_ADDR_VAR 0 10
62194: PUSH
62195: LD_VAR 0 10
62199: PUSH
62200: LD_VAR 0 6
62204: PPUSH
62205: CALL_OW 311
62209: PPUSH
62210: LD_INT 3
62212: PPUSH
62213: CALL_OW 259
62217: PUSH
62218: LD_INT 4
62220: MUL
62221: MUL
62222: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
62223: LD_VAR 0 6
62227: PPUSH
62228: CALL_OW 263
62232: PUSH
62233: LD_INT 2
62235: EQUAL
62236: IFFALSE 62287
// begin j := IsControledBy ( i ) ;
62238: LD_ADDR_VAR 0 7
62242: PUSH
62243: LD_VAR 0 6
62247: PPUSH
62248: CALL_OW 312
62252: ST_TO_ADDR
// if j then
62253: LD_VAR 0 7
62257: IFFALSE 62287
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
62259: LD_ADDR_VAR 0 10
62263: PUSH
62264: LD_VAR 0 10
62268: PUSH
62269: LD_VAR 0 7
62273: PPUSH
62274: LD_INT 3
62276: PPUSH
62277: CALL_OW 259
62281: PUSH
62282: LD_INT 3
62284: MUL
62285: MUL
62286: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
62287: LD_VAR 0 6
62291: PPUSH
62292: CALL_OW 264
62296: PUSH
62297: LD_INT 5
62299: PUSH
62300: LD_INT 6
62302: PUSH
62303: LD_INT 46
62305: PUSH
62306: LD_INT 44
62308: PUSH
62309: LD_INT 47
62311: PUSH
62312: LD_INT 45
62314: PUSH
62315: LD_INT 28
62317: PUSH
62318: LD_INT 7
62320: PUSH
62321: LD_INT 27
62323: PUSH
62324: LD_INT 29
62326: PUSH
62327: EMPTY
62328: LIST
62329: LIST
62330: LIST
62331: LIST
62332: LIST
62333: LIST
62334: LIST
62335: LIST
62336: LIST
62337: LIST
62338: IN
62339: IFFALSE 62359
62341: PUSH
62342: LD_VAR 0 1
62346: PPUSH
62347: LD_INT 52
62349: PPUSH
62350: CALL_OW 321
62354: PUSH
62355: LD_INT 2
62357: EQUAL
62358: AND
62359: IFFALSE 62376
// bpoints := bpoints * 1.2 ;
62361: LD_ADDR_VAR 0 10
62365: PUSH
62366: LD_VAR 0 10
62370: PUSH
62371: LD_REAL  1.20000000000000E+0000
62374: MUL
62375: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
62376: LD_VAR 0 6
62380: PPUSH
62381: CALL_OW 264
62385: PUSH
62386: LD_INT 6
62388: PUSH
62389: LD_INT 46
62391: PUSH
62392: LD_INT 47
62394: PUSH
62395: EMPTY
62396: LIST
62397: LIST
62398: LIST
62399: IN
62400: IFFALSE 62417
// bpoints := bpoints * 1.2 ;
62402: LD_ADDR_VAR 0 10
62406: PUSH
62407: LD_VAR 0 10
62411: PUSH
62412: LD_REAL  1.20000000000000E+0000
62415: MUL
62416: ST_TO_ADDR
// end ; unit_building :
62417: GO 62431
62419: LD_INT 3
62421: DOUBLE
62422: EQUAL
62423: IFTRUE 62427
62425: GO 62430
62427: POP
// ; end ;
62428: GO 62431
62430: POP
// for j = 1 to 3 do
62431: LD_ADDR_VAR 0 7
62435: PUSH
62436: DOUBLE
62437: LD_INT 1
62439: DEC
62440: ST_TO_ADDR
62441: LD_INT 3
62443: PUSH
62444: FOR_TO
62445: IFFALSE 62498
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
62447: LD_ADDR_VAR 0 5
62451: PUSH
62452: LD_VAR 0 5
62456: PPUSH
62457: LD_VAR 0 7
62461: PPUSH
62462: LD_VAR 0 5
62466: PUSH
62467: LD_VAR 0 7
62471: ARRAY
62472: PUSH
62473: LD_VAR 0 9
62477: PUSH
62478: LD_VAR 0 7
62482: ARRAY
62483: PUSH
62484: LD_VAR 0 10
62488: MUL
62489: PLUS
62490: PPUSH
62491: CALL_OW 1
62495: ST_TO_ADDR
62496: GO 62444
62498: POP
62499: POP
// end ;
62500: GO 60973
62502: POP
62503: POP
// result := Replace ( result , 4 , tmp ) ;
62504: LD_ADDR_VAR 0 5
62508: PUSH
62509: LD_VAR 0 5
62513: PPUSH
62514: LD_INT 4
62516: PPUSH
62517: LD_VAR 0 8
62521: PPUSH
62522: CALL_OW 1
62526: ST_TO_ADDR
// end ;
62527: LD_VAR 0 5
62531: RET
// export function DangerAtRange ( unit , range ) ; begin
62532: LD_INT 0
62534: PPUSH
// if not unit then
62535: LD_VAR 0 1
62539: NOT
62540: IFFALSE 62544
// exit ;
62542: GO 62589
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
62544: LD_ADDR_VAR 0 3
62548: PUSH
62549: LD_VAR 0 1
62553: PPUSH
62554: CALL_OW 255
62558: PPUSH
62559: LD_VAR 0 1
62563: PPUSH
62564: CALL_OW 250
62568: PPUSH
62569: LD_VAR 0 1
62573: PPUSH
62574: CALL_OW 251
62578: PPUSH
62579: LD_VAR 0 2
62583: PPUSH
62584: CALL 60823 0 4
62588: ST_TO_ADDR
// end ;
62589: LD_VAR 0 3
62593: RET
// export function DangerInArea ( side , area ) ; begin
62594: LD_INT 0
62596: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
62597: LD_ADDR_VAR 0 3
62601: PUSH
62602: LD_VAR 0 2
62606: PPUSH
62607: LD_INT 81
62609: PUSH
62610: LD_VAR 0 1
62614: PUSH
62615: EMPTY
62616: LIST
62617: LIST
62618: PPUSH
62619: CALL_OW 70
62623: ST_TO_ADDR
// end ;
62624: LD_VAR 0 3
62628: RET
// export function IsExtension ( b ) ; begin
62629: LD_INT 0
62631: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
62632: LD_ADDR_VAR 0 2
62636: PUSH
62637: LD_VAR 0 1
62641: PUSH
62642: LD_INT 23
62644: PUSH
62645: LD_INT 20
62647: PUSH
62648: LD_INT 22
62650: PUSH
62651: LD_INT 17
62653: PUSH
62654: LD_INT 24
62656: PUSH
62657: LD_INT 21
62659: PUSH
62660: LD_INT 19
62662: PUSH
62663: LD_INT 16
62665: PUSH
62666: LD_INT 25
62668: PUSH
62669: LD_INT 18
62671: PUSH
62672: EMPTY
62673: LIST
62674: LIST
62675: LIST
62676: LIST
62677: LIST
62678: LIST
62679: LIST
62680: LIST
62681: LIST
62682: LIST
62683: IN
62684: ST_TO_ADDR
// end ;
62685: LD_VAR 0 2
62689: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
62690: LD_INT 0
62692: PPUSH
62693: PPUSH
62694: PPUSH
// result := [ ] ;
62695: LD_ADDR_VAR 0 4
62699: PUSH
62700: EMPTY
62701: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
62702: LD_ADDR_VAR 0 5
62706: PUSH
62707: LD_VAR 0 2
62711: PPUSH
62712: LD_INT 21
62714: PUSH
62715: LD_INT 3
62717: PUSH
62718: EMPTY
62719: LIST
62720: LIST
62721: PPUSH
62722: CALL_OW 70
62726: ST_TO_ADDR
// if not tmp then
62727: LD_VAR 0 5
62731: NOT
62732: IFFALSE 62736
// exit ;
62734: GO 62800
// if checkLink then
62736: LD_VAR 0 3
62740: IFFALSE 62790
// begin for i in tmp do
62742: LD_ADDR_VAR 0 6
62746: PUSH
62747: LD_VAR 0 5
62751: PUSH
62752: FOR_IN
62753: IFFALSE 62788
// if GetBase ( i ) <> base then
62755: LD_VAR 0 6
62759: PPUSH
62760: CALL_OW 274
62764: PUSH
62765: LD_VAR 0 1
62769: NONEQUAL
62770: IFFALSE 62786
// ComLinkToBase ( base , i ) ;
62772: LD_VAR 0 1
62776: PPUSH
62777: LD_VAR 0 6
62781: PPUSH
62782: CALL_OW 169
62786: GO 62752
62788: POP
62789: POP
// end ; result := tmp ;
62790: LD_ADDR_VAR 0 4
62794: PUSH
62795: LD_VAR 0 5
62799: ST_TO_ADDR
// end ;
62800: LD_VAR 0 4
62804: RET
// export function ComComplete ( units , b ) ; var i ; begin
62805: LD_INT 0
62807: PPUSH
62808: PPUSH
// if not units then
62809: LD_VAR 0 1
62813: NOT
62814: IFFALSE 62818
// exit ;
62816: GO 62908
// for i in units do
62818: LD_ADDR_VAR 0 4
62822: PUSH
62823: LD_VAR 0 1
62827: PUSH
62828: FOR_IN
62829: IFFALSE 62906
// if BuildingStatus ( b ) = bs_build then
62831: LD_VAR 0 2
62835: PPUSH
62836: CALL_OW 461
62840: PUSH
62841: LD_INT 1
62843: EQUAL
62844: IFFALSE 62904
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
62846: LD_VAR 0 4
62850: PPUSH
62851: LD_STRING h
62853: PUSH
62854: LD_VAR 0 2
62858: PPUSH
62859: CALL_OW 250
62863: PUSH
62864: LD_VAR 0 2
62868: PPUSH
62869: CALL_OW 251
62873: PUSH
62874: LD_VAR 0 2
62878: PUSH
62879: LD_INT 0
62881: PUSH
62882: LD_INT 0
62884: PUSH
62885: LD_INT 0
62887: PUSH
62888: EMPTY
62889: LIST
62890: LIST
62891: LIST
62892: LIST
62893: LIST
62894: LIST
62895: LIST
62896: PUSH
62897: EMPTY
62898: LIST
62899: PPUSH
62900: CALL_OW 446
62904: GO 62828
62906: POP
62907: POP
// end ;
62908: LD_VAR 0 3
62912: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
62913: LD_INT 0
62915: PPUSH
62916: PPUSH
62917: PPUSH
62918: PPUSH
62919: PPUSH
62920: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
62921: LD_VAR 0 1
62925: NOT
62926: IFTRUE 62943
62928: PUSH
62929: LD_VAR 0 1
62933: PPUSH
62934: CALL_OW 263
62938: PUSH
62939: LD_INT 2
62941: NONEQUAL
62942: OR
62943: IFFALSE 62947
// exit ;
62945: GO 63263
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
62947: LD_ADDR_VAR 0 6
62951: PUSH
62952: LD_INT 22
62954: PUSH
62955: LD_VAR 0 1
62959: PPUSH
62960: CALL_OW 255
62964: PUSH
62965: EMPTY
62966: LIST
62967: LIST
62968: PUSH
62969: LD_INT 2
62971: PUSH
62972: LD_INT 30
62974: PUSH
62975: LD_INT 36
62977: PUSH
62978: EMPTY
62979: LIST
62980: LIST
62981: PUSH
62982: LD_INT 34
62984: PUSH
62985: LD_INT 31
62987: PUSH
62988: EMPTY
62989: LIST
62990: LIST
62991: PUSH
62992: EMPTY
62993: LIST
62994: LIST
62995: LIST
62996: PUSH
62997: EMPTY
62998: LIST
62999: LIST
63000: PPUSH
63001: CALL_OW 69
63005: ST_TO_ADDR
// if not tmp then
63006: LD_VAR 0 6
63010: NOT
63011: IFFALSE 63015
// exit ;
63013: GO 63263
// result := [ ] ;
63015: LD_ADDR_VAR 0 2
63019: PUSH
63020: EMPTY
63021: ST_TO_ADDR
// for i in tmp do
63022: LD_ADDR_VAR 0 3
63026: PUSH
63027: LD_VAR 0 6
63031: PUSH
63032: FOR_IN
63033: IFFALSE 63104
// begin t := UnitsInside ( i ) ;
63035: LD_ADDR_VAR 0 4
63039: PUSH
63040: LD_VAR 0 3
63044: PPUSH
63045: CALL_OW 313
63049: ST_TO_ADDR
// if t then
63050: LD_VAR 0 4
63054: IFFALSE 63102
// for j in t do
63056: LD_ADDR_VAR 0 7
63060: PUSH
63061: LD_VAR 0 4
63065: PUSH
63066: FOR_IN
63067: IFFALSE 63100
// result := Replace ( result , result + 1 , j ) ;
63069: LD_ADDR_VAR 0 2
63073: PUSH
63074: LD_VAR 0 2
63078: PPUSH
63079: LD_VAR 0 2
63083: PUSH
63084: LD_INT 1
63086: PLUS
63087: PPUSH
63088: LD_VAR 0 7
63092: PPUSH
63093: CALL_OW 1
63097: ST_TO_ADDR
63098: GO 63066
63100: POP
63101: POP
// end ;
63102: GO 63032
63104: POP
63105: POP
// if not result then
63106: LD_VAR 0 2
63110: NOT
63111: IFFALSE 63115
// exit ;
63113: GO 63263
// mech := result [ 1 ] ;
63115: LD_ADDR_VAR 0 5
63119: PUSH
63120: LD_VAR 0 2
63124: PUSH
63125: LD_INT 1
63127: ARRAY
63128: ST_TO_ADDR
// if result > 1 then
63129: LD_VAR 0 2
63133: PUSH
63134: LD_INT 1
63136: GREATER
63137: IFFALSE 63249
// begin for i = 2 to result do
63139: LD_ADDR_VAR 0 3
63143: PUSH
63144: DOUBLE
63145: LD_INT 2
63147: DEC
63148: ST_TO_ADDR
63149: LD_VAR 0 2
63153: PUSH
63154: FOR_TO
63155: IFFALSE 63247
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
63157: LD_ADDR_VAR 0 4
63161: PUSH
63162: LD_VAR 0 2
63166: PUSH
63167: LD_VAR 0 3
63171: ARRAY
63172: PPUSH
63173: LD_INT 3
63175: PPUSH
63176: CALL_OW 259
63180: PUSH
63181: LD_VAR 0 2
63185: PUSH
63186: LD_VAR 0 3
63190: ARRAY
63191: PPUSH
63192: CALL_OW 432
63196: MINUS
63197: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
63198: LD_VAR 0 4
63202: PUSH
63203: LD_VAR 0 5
63207: PPUSH
63208: LD_INT 3
63210: PPUSH
63211: CALL_OW 259
63215: PUSH
63216: LD_VAR 0 5
63220: PPUSH
63221: CALL_OW 432
63225: MINUS
63226: GREATEREQUAL
63227: IFFALSE 63245
// mech := result [ i ] ;
63229: LD_ADDR_VAR 0 5
63233: PUSH
63234: LD_VAR 0 2
63238: PUSH
63239: LD_VAR 0 3
63243: ARRAY
63244: ST_TO_ADDR
// end ;
63245: GO 63154
63247: POP
63248: POP
// end ; ComLinkTo ( vehicle , mech ) ;
63249: LD_VAR 0 1
63253: PPUSH
63254: LD_VAR 0 5
63258: PPUSH
63259: CALL_OW 135
// end ;
63263: LD_VAR 0 2
63267: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
63268: LD_INT 0
63270: PPUSH
63271: PPUSH
63272: PPUSH
63273: PPUSH
63274: PPUSH
63275: PPUSH
63276: PPUSH
63277: PPUSH
63278: PPUSH
63279: PPUSH
63280: PPUSH
63281: PPUSH
63282: PPUSH
// result := [ ] ;
63283: LD_ADDR_VAR 0 7
63287: PUSH
63288: EMPTY
63289: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
63290: LD_VAR 0 1
63294: PPUSH
63295: CALL_OW 266
63299: PUSH
63300: LD_INT 0
63302: PUSH
63303: LD_INT 1
63305: PUSH
63306: EMPTY
63307: LIST
63308: LIST
63309: IN
63310: NOT
63311: IFFALSE 63315
// exit ;
63313: GO 64955
// if name then
63315: LD_VAR 0 3
63319: IFFALSE 63335
// SetBName ( base_dep , name ) ;
63321: LD_VAR 0 1
63325: PPUSH
63326: LD_VAR 0 3
63330: PPUSH
63331: CALL_OW 500
// base := GetBase ( base_dep ) ;
63335: LD_ADDR_VAR 0 15
63339: PUSH
63340: LD_VAR 0 1
63344: PPUSH
63345: CALL_OW 274
63349: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
63350: LD_ADDR_VAR 0 16
63354: PUSH
63355: LD_VAR 0 1
63359: PPUSH
63360: CALL_OW 255
63364: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
63365: LD_ADDR_VAR 0 17
63369: PUSH
63370: LD_VAR 0 1
63374: PPUSH
63375: CALL_OW 248
63379: ST_TO_ADDR
// if sources then
63380: LD_VAR 0 5
63384: IFFALSE 63431
// for i = 1 to 3 do
63386: LD_ADDR_VAR 0 8
63390: PUSH
63391: DOUBLE
63392: LD_INT 1
63394: DEC
63395: ST_TO_ADDR
63396: LD_INT 3
63398: PUSH
63399: FOR_TO
63400: IFFALSE 63429
// AddResourceType ( base , i , sources [ i ] ) ;
63402: LD_VAR 0 15
63406: PPUSH
63407: LD_VAR 0 8
63411: PPUSH
63412: LD_VAR 0 5
63416: PUSH
63417: LD_VAR 0 8
63421: ARRAY
63422: PPUSH
63423: CALL_OW 276
63427: GO 63399
63429: POP
63430: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
63431: LD_ADDR_VAR 0 18
63435: PUSH
63436: LD_VAR 0 15
63440: PPUSH
63441: LD_VAR 0 2
63445: PPUSH
63446: LD_INT 1
63448: PPUSH
63449: CALL 62690 0 3
63453: ST_TO_ADDR
// InitHc ;
63454: CALL_OW 19
// InitUc ;
63458: CALL_OW 18
// uc_side := side ;
63462: LD_ADDR_OWVAR 20
63466: PUSH
63467: LD_VAR 0 16
63471: ST_TO_ADDR
// uc_nation := nation ;
63472: LD_ADDR_OWVAR 21
63476: PUSH
63477: LD_VAR 0 17
63481: ST_TO_ADDR
// if buildings then
63482: LD_VAR 0 18
63486: IFFALSE 64814
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
63488: LD_ADDR_VAR 0 19
63492: PUSH
63493: LD_VAR 0 18
63497: PPUSH
63498: LD_INT 2
63500: PUSH
63501: LD_INT 30
63503: PUSH
63504: LD_INT 29
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PUSH
63511: LD_INT 30
63513: PUSH
63514: LD_INT 30
63516: PUSH
63517: EMPTY
63518: LIST
63519: LIST
63520: PUSH
63521: EMPTY
63522: LIST
63523: LIST
63524: LIST
63525: PPUSH
63526: CALL_OW 72
63530: ST_TO_ADDR
// if tmp then
63531: LD_VAR 0 19
63535: IFFALSE 63583
// for i in tmp do
63537: LD_ADDR_VAR 0 8
63541: PUSH
63542: LD_VAR 0 19
63546: PUSH
63547: FOR_IN
63548: IFFALSE 63581
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
63550: LD_VAR 0 8
63554: PPUSH
63555: CALL_OW 250
63559: PPUSH
63560: LD_VAR 0 8
63564: PPUSH
63565: CALL_OW 251
63569: PPUSH
63570: LD_VAR 0 16
63574: PPUSH
63575: CALL_OW 441
63579: GO 63547
63581: POP
63582: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
63583: LD_VAR 0 18
63587: PPUSH
63588: LD_INT 2
63590: PUSH
63591: LD_INT 30
63593: PUSH
63594: LD_INT 32
63596: PUSH
63597: EMPTY
63598: LIST
63599: LIST
63600: PUSH
63601: LD_INT 30
63603: PUSH
63604: LD_INT 33
63606: PUSH
63607: EMPTY
63608: LIST
63609: LIST
63610: PUSH
63611: EMPTY
63612: LIST
63613: LIST
63614: LIST
63615: PPUSH
63616: CALL_OW 72
63620: IFFALSE 63708
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
63622: LD_ADDR_VAR 0 8
63626: PUSH
63627: LD_VAR 0 18
63631: PPUSH
63632: LD_INT 2
63634: PUSH
63635: LD_INT 30
63637: PUSH
63638: LD_INT 32
63640: PUSH
63641: EMPTY
63642: LIST
63643: LIST
63644: PUSH
63645: LD_INT 30
63647: PUSH
63648: LD_INT 33
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: PUSH
63655: EMPTY
63656: LIST
63657: LIST
63658: LIST
63659: PPUSH
63660: CALL_OW 72
63664: PUSH
63665: FOR_IN
63666: IFFALSE 63706
// begin if not GetBWeapon ( i ) then
63668: LD_VAR 0 8
63672: PPUSH
63673: CALL_OW 269
63677: NOT
63678: IFFALSE 63704
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
63680: LD_VAR 0 8
63684: PPUSH
63685: LD_VAR 0 8
63689: PPUSH
63690: LD_VAR 0 2
63694: PPUSH
63695: CALL 64960 0 2
63699: PPUSH
63700: CALL_OW 431
// end ;
63704: GO 63665
63706: POP
63707: POP
// end ; for i = 1 to personel do
63708: LD_ADDR_VAR 0 8
63712: PUSH
63713: DOUBLE
63714: LD_INT 1
63716: DEC
63717: ST_TO_ADDR
63718: LD_VAR 0 6
63722: PUSH
63723: FOR_TO
63724: IFFALSE 64794
// begin if i > 4 then
63726: LD_VAR 0 8
63730: PUSH
63731: LD_INT 4
63733: GREATER
63734: IFFALSE 63738
// break ;
63736: GO 64794
// case i of 1 :
63738: LD_VAR 0 8
63742: PUSH
63743: LD_INT 1
63745: DOUBLE
63746: EQUAL
63747: IFTRUE 63751
63749: GO 63831
63751: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
63752: LD_ADDR_VAR 0 12
63756: PUSH
63757: LD_VAR 0 18
63761: PPUSH
63762: LD_INT 22
63764: PUSH
63765: LD_VAR 0 16
63769: PUSH
63770: EMPTY
63771: LIST
63772: LIST
63773: PUSH
63774: LD_INT 58
63776: PUSH
63777: EMPTY
63778: LIST
63779: PUSH
63780: LD_INT 2
63782: PUSH
63783: LD_INT 30
63785: PUSH
63786: LD_INT 32
63788: PUSH
63789: EMPTY
63790: LIST
63791: LIST
63792: PUSH
63793: LD_INT 30
63795: PUSH
63796: LD_INT 4
63798: PUSH
63799: EMPTY
63800: LIST
63801: LIST
63802: PUSH
63803: LD_INT 30
63805: PUSH
63806: LD_INT 5
63808: PUSH
63809: EMPTY
63810: LIST
63811: LIST
63812: PUSH
63813: EMPTY
63814: LIST
63815: LIST
63816: LIST
63817: LIST
63818: PUSH
63819: EMPTY
63820: LIST
63821: LIST
63822: LIST
63823: PPUSH
63824: CALL_OW 72
63828: ST_TO_ADDR
63829: GO 64053
63831: LD_INT 2
63833: DOUBLE
63834: EQUAL
63835: IFTRUE 63839
63837: GO 63901
63839: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
63840: LD_ADDR_VAR 0 12
63844: PUSH
63845: LD_VAR 0 18
63849: PPUSH
63850: LD_INT 22
63852: PUSH
63853: LD_VAR 0 16
63857: PUSH
63858: EMPTY
63859: LIST
63860: LIST
63861: PUSH
63862: LD_INT 2
63864: PUSH
63865: LD_INT 30
63867: PUSH
63868: LD_INT 0
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: PUSH
63875: LD_INT 30
63877: PUSH
63878: LD_INT 1
63880: PUSH
63881: EMPTY
63882: LIST
63883: LIST
63884: PUSH
63885: EMPTY
63886: LIST
63887: LIST
63888: LIST
63889: PUSH
63890: EMPTY
63891: LIST
63892: LIST
63893: PPUSH
63894: CALL_OW 72
63898: ST_TO_ADDR
63899: GO 64053
63901: LD_INT 3
63903: DOUBLE
63904: EQUAL
63905: IFTRUE 63909
63907: GO 63971
63909: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
63910: LD_ADDR_VAR 0 12
63914: PUSH
63915: LD_VAR 0 18
63919: PPUSH
63920: LD_INT 22
63922: PUSH
63923: LD_VAR 0 16
63927: PUSH
63928: EMPTY
63929: LIST
63930: LIST
63931: PUSH
63932: LD_INT 2
63934: PUSH
63935: LD_INT 30
63937: PUSH
63938: LD_INT 2
63940: PUSH
63941: EMPTY
63942: LIST
63943: LIST
63944: PUSH
63945: LD_INT 30
63947: PUSH
63948: LD_INT 3
63950: PUSH
63951: EMPTY
63952: LIST
63953: LIST
63954: PUSH
63955: EMPTY
63956: LIST
63957: LIST
63958: LIST
63959: PUSH
63960: EMPTY
63961: LIST
63962: LIST
63963: PPUSH
63964: CALL_OW 72
63968: ST_TO_ADDR
63969: GO 64053
63971: LD_INT 4
63973: DOUBLE
63974: EQUAL
63975: IFTRUE 63979
63977: GO 64052
63979: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
63980: LD_ADDR_VAR 0 12
63984: PUSH
63985: LD_VAR 0 18
63989: PPUSH
63990: LD_INT 22
63992: PUSH
63993: LD_VAR 0 16
63997: PUSH
63998: EMPTY
63999: LIST
64000: LIST
64001: PUSH
64002: LD_INT 2
64004: PUSH
64005: LD_INT 30
64007: PUSH
64008: LD_INT 6
64010: PUSH
64011: EMPTY
64012: LIST
64013: LIST
64014: PUSH
64015: LD_INT 30
64017: PUSH
64018: LD_INT 7
64020: PUSH
64021: EMPTY
64022: LIST
64023: LIST
64024: PUSH
64025: LD_INT 30
64027: PUSH
64028: LD_INT 8
64030: PUSH
64031: EMPTY
64032: LIST
64033: LIST
64034: PUSH
64035: EMPTY
64036: LIST
64037: LIST
64038: LIST
64039: LIST
64040: PUSH
64041: EMPTY
64042: LIST
64043: LIST
64044: PPUSH
64045: CALL_OW 72
64049: ST_TO_ADDR
64050: GO 64053
64052: POP
// if i = 1 then
64053: LD_VAR 0 8
64057: PUSH
64058: LD_INT 1
64060: EQUAL
64061: IFFALSE 64172
// begin tmp := [ ] ;
64063: LD_ADDR_VAR 0 19
64067: PUSH
64068: EMPTY
64069: ST_TO_ADDR
// for j in f do
64070: LD_ADDR_VAR 0 9
64074: PUSH
64075: LD_VAR 0 12
64079: PUSH
64080: FOR_IN
64081: IFFALSE 64154
// if GetBType ( j ) = b_bunker then
64083: LD_VAR 0 9
64087: PPUSH
64088: CALL_OW 266
64092: PUSH
64093: LD_INT 32
64095: EQUAL
64096: IFFALSE 64123
// tmp := Insert ( tmp , 1 , j ) else
64098: LD_ADDR_VAR 0 19
64102: PUSH
64103: LD_VAR 0 19
64107: PPUSH
64108: LD_INT 1
64110: PPUSH
64111: LD_VAR 0 9
64115: PPUSH
64116: CALL_OW 2
64120: ST_TO_ADDR
64121: GO 64152
// tmp := Insert ( tmp , tmp + 1 , j ) ;
64123: LD_ADDR_VAR 0 19
64127: PUSH
64128: LD_VAR 0 19
64132: PPUSH
64133: LD_VAR 0 19
64137: PUSH
64138: LD_INT 1
64140: PLUS
64141: PPUSH
64142: LD_VAR 0 9
64146: PPUSH
64147: CALL_OW 2
64151: ST_TO_ADDR
64152: GO 64080
64154: POP
64155: POP
// if tmp then
64156: LD_VAR 0 19
64160: IFFALSE 64172
// f := tmp ;
64162: LD_ADDR_VAR 0 12
64166: PUSH
64167: LD_VAR 0 19
64171: ST_TO_ADDR
// end ; x := personel [ i ] ;
64172: LD_ADDR_VAR 0 13
64176: PUSH
64177: LD_VAR 0 6
64181: PUSH
64182: LD_VAR 0 8
64186: ARRAY
64187: ST_TO_ADDR
// if x = - 1 then
64188: LD_VAR 0 13
64192: PUSH
64193: LD_INT 1
64195: NEG
64196: EQUAL
64197: IFFALSE 64408
// begin for j in f do
64199: LD_ADDR_VAR 0 9
64203: PUSH
64204: LD_VAR 0 12
64208: PUSH
64209: FOR_IN
64210: IFFALSE 64404
// repeat InitHc ;
64212: CALL_OW 19
// if GetBType ( j ) = b_barracks then
64216: LD_VAR 0 9
64220: PPUSH
64221: CALL_OW 266
64225: PUSH
64226: LD_INT 5
64228: EQUAL
64229: IFFALSE 64299
// begin if UnitsInside ( j ) < 3 then
64231: LD_VAR 0 9
64235: PPUSH
64236: CALL_OW 313
64240: PUSH
64241: LD_INT 3
64243: LESS
64244: IFFALSE 64280
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
64246: LD_INT 0
64248: PPUSH
64249: LD_INT 5
64251: PUSH
64252: LD_INT 8
64254: PUSH
64255: LD_INT 9
64257: PUSH
64258: EMPTY
64259: LIST
64260: LIST
64261: LIST
64262: PUSH
64263: LD_VAR 0 17
64267: ARRAY
64268: PPUSH
64269: LD_VAR 0 4
64273: PPUSH
64274: CALL_OW 380
64278: GO 64297
// PrepareHuman ( false , i , skill ) ;
64280: LD_INT 0
64282: PPUSH
64283: LD_VAR 0 8
64287: PPUSH
64288: LD_VAR 0 4
64292: PPUSH
64293: CALL_OW 380
// end else
64297: GO 64316
// PrepareHuman ( false , i , skill ) ;
64299: LD_INT 0
64301: PPUSH
64302: LD_VAR 0 8
64306: PPUSH
64307: LD_VAR 0 4
64311: PPUSH
64312: CALL_OW 380
// un := CreateHuman ;
64316: LD_ADDR_VAR 0 14
64320: PUSH
64321: CALL_OW 44
64325: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
64326: LD_ADDR_VAR 0 7
64330: PUSH
64331: LD_VAR 0 7
64335: PPUSH
64336: LD_INT 1
64338: PPUSH
64339: LD_VAR 0 14
64343: PPUSH
64344: CALL_OW 2
64348: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
64349: LD_VAR 0 14
64353: PPUSH
64354: LD_VAR 0 9
64358: PPUSH
64359: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
64363: LD_VAR 0 9
64367: PPUSH
64368: CALL_OW 313
64372: PUSH
64373: LD_INT 6
64375: EQUAL
64376: IFTRUE 64400
64378: PUSH
64379: LD_VAR 0 9
64383: PPUSH
64384: CALL_OW 266
64388: PUSH
64389: LD_INT 32
64391: PUSH
64392: LD_INT 31
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: IN
64399: OR
64400: IFFALSE 64212
64402: GO 64209
64404: POP
64405: POP
// end else
64406: GO 64792
// for j = 1 to x do
64408: LD_ADDR_VAR 0 9
64412: PUSH
64413: DOUBLE
64414: LD_INT 1
64416: DEC
64417: ST_TO_ADDR
64418: LD_VAR 0 13
64422: PUSH
64423: FOR_TO
64424: IFFALSE 64790
// begin InitHc ;
64426: CALL_OW 19
// if not f then
64430: LD_VAR 0 12
64434: NOT
64435: IFFALSE 64524
// begin PrepareHuman ( false , i , skill ) ;
64437: LD_INT 0
64439: PPUSH
64440: LD_VAR 0 8
64444: PPUSH
64445: LD_VAR 0 4
64449: PPUSH
64450: CALL_OW 380
// un := CreateHuman ;
64454: LD_ADDR_VAR 0 14
64458: PUSH
64459: CALL_OW 44
64463: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
64464: LD_ADDR_VAR 0 7
64468: PUSH
64469: LD_VAR 0 7
64473: PPUSH
64474: LD_INT 1
64476: PPUSH
64477: LD_VAR 0 14
64481: PPUSH
64482: CALL_OW 2
64486: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
64487: LD_VAR 0 14
64491: PPUSH
64492: LD_VAR 0 1
64496: PPUSH
64497: CALL_OW 250
64501: PPUSH
64502: LD_VAR 0 1
64506: PPUSH
64507: CALL_OW 251
64511: PPUSH
64512: LD_INT 10
64514: PPUSH
64515: LD_INT 0
64517: PPUSH
64518: CALL_OW 50
// continue ;
64522: GO 64423
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
64524: LD_VAR 0 12
64528: PUSH
64529: LD_INT 1
64531: ARRAY
64532: PPUSH
64533: CALL_OW 313
64537: IFFALSE 64565
64539: PUSH
64540: LD_VAR 0 12
64544: PUSH
64545: LD_INT 1
64547: ARRAY
64548: PPUSH
64549: CALL_OW 266
64553: PUSH
64554: LD_INT 32
64556: PUSH
64557: LD_INT 31
64559: PUSH
64560: EMPTY
64561: LIST
64562: LIST
64563: IN
64564: AND
64565: IFTRUE 64586
64567: PUSH
64568: LD_VAR 0 12
64572: PUSH
64573: LD_INT 1
64575: ARRAY
64576: PPUSH
64577: CALL_OW 313
64581: PUSH
64582: LD_INT 6
64584: EQUAL
64585: OR
64586: IFFALSE 64606
// f := Delete ( f , 1 ) ;
64588: LD_ADDR_VAR 0 12
64592: PUSH
64593: LD_VAR 0 12
64597: PPUSH
64598: LD_INT 1
64600: PPUSH
64601: CALL_OW 3
64605: ST_TO_ADDR
// if not f then
64606: LD_VAR 0 12
64610: NOT
64611: IFFALSE 64629
// begin x := x + 2 ;
64613: LD_ADDR_VAR 0 13
64617: PUSH
64618: LD_VAR 0 13
64622: PUSH
64623: LD_INT 2
64625: PLUS
64626: ST_TO_ADDR
// continue ;
64627: GO 64423
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
64629: LD_VAR 0 12
64633: PUSH
64634: LD_INT 1
64636: ARRAY
64637: PPUSH
64638: CALL_OW 266
64642: PUSH
64643: LD_INT 5
64645: EQUAL
64646: IFFALSE 64720
// begin if UnitsInside ( f [ 1 ] ) < 3 then
64648: LD_VAR 0 12
64652: PUSH
64653: LD_INT 1
64655: ARRAY
64656: PPUSH
64657: CALL_OW 313
64661: PUSH
64662: LD_INT 3
64664: LESS
64665: IFFALSE 64701
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
64667: LD_INT 0
64669: PPUSH
64670: LD_INT 5
64672: PUSH
64673: LD_INT 8
64675: PUSH
64676: LD_INT 9
64678: PUSH
64679: EMPTY
64680: LIST
64681: LIST
64682: LIST
64683: PUSH
64684: LD_VAR 0 17
64688: ARRAY
64689: PPUSH
64690: LD_VAR 0 4
64694: PPUSH
64695: CALL_OW 380
64699: GO 64718
// PrepareHuman ( false , i , skill ) ;
64701: LD_INT 0
64703: PPUSH
64704: LD_VAR 0 8
64708: PPUSH
64709: LD_VAR 0 4
64713: PPUSH
64714: CALL_OW 380
// end else
64718: GO 64737
// PrepareHuman ( false , i , skill ) ;
64720: LD_INT 0
64722: PPUSH
64723: LD_VAR 0 8
64727: PPUSH
64728: LD_VAR 0 4
64732: PPUSH
64733: CALL_OW 380
// un := CreateHuman ;
64737: LD_ADDR_VAR 0 14
64741: PUSH
64742: CALL_OW 44
64746: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
64747: LD_ADDR_VAR 0 7
64751: PUSH
64752: LD_VAR 0 7
64756: PPUSH
64757: LD_INT 1
64759: PPUSH
64760: LD_VAR 0 14
64764: PPUSH
64765: CALL_OW 2
64769: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
64770: LD_VAR 0 14
64774: PPUSH
64775: LD_VAR 0 12
64779: PUSH
64780: LD_INT 1
64782: ARRAY
64783: PPUSH
64784: CALL_OW 52
// end ;
64788: GO 64423
64790: POP
64791: POP
// end ;
64792: GO 63723
64794: POP
64795: POP
// result := result ^ buildings ;
64796: LD_ADDR_VAR 0 7
64800: PUSH
64801: LD_VAR 0 7
64805: PUSH
64806: LD_VAR 0 18
64810: ADD
64811: ST_TO_ADDR
// end else
64812: GO 64955
// begin for i = 1 to personel do
64814: LD_ADDR_VAR 0 8
64818: PUSH
64819: DOUBLE
64820: LD_INT 1
64822: DEC
64823: ST_TO_ADDR
64824: LD_VAR 0 6
64828: PUSH
64829: FOR_TO
64830: IFFALSE 64953
// begin if i > 4 then
64832: LD_VAR 0 8
64836: PUSH
64837: LD_INT 4
64839: GREATER
64840: IFFALSE 64844
// break ;
64842: GO 64953
// x := personel [ i ] ;
64844: LD_ADDR_VAR 0 13
64848: PUSH
64849: LD_VAR 0 6
64853: PUSH
64854: LD_VAR 0 8
64858: ARRAY
64859: ST_TO_ADDR
// if x = - 1 then
64860: LD_VAR 0 13
64864: PUSH
64865: LD_INT 1
64867: NEG
64868: EQUAL
64869: IFFALSE 64873
// continue ;
64871: GO 64829
// PrepareHuman ( false , i , skill ) ;
64873: LD_INT 0
64875: PPUSH
64876: LD_VAR 0 8
64880: PPUSH
64881: LD_VAR 0 4
64885: PPUSH
64886: CALL_OW 380
// un := CreateHuman ;
64890: LD_ADDR_VAR 0 14
64894: PUSH
64895: CALL_OW 44
64899: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
64900: LD_VAR 0 14
64904: PPUSH
64905: LD_VAR 0 1
64909: PPUSH
64910: CALL_OW 250
64914: PPUSH
64915: LD_VAR 0 1
64919: PPUSH
64920: CALL_OW 251
64924: PPUSH
64925: LD_INT 10
64927: PPUSH
64928: LD_INT 0
64930: PPUSH
64931: CALL_OW 50
// result := result ^ un ;
64935: LD_ADDR_VAR 0 7
64939: PUSH
64940: LD_VAR 0 7
64944: PUSH
64945: LD_VAR 0 14
64949: ADD
64950: ST_TO_ADDR
// end ;
64951: GO 64829
64953: POP
64954: POP
// end ; end ;
64955: LD_VAR 0 7
64959: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
64960: LD_INT 0
64962: PPUSH
64963: PPUSH
64964: PPUSH
64965: PPUSH
64966: PPUSH
64967: PPUSH
64968: PPUSH
64969: PPUSH
64970: PPUSH
64971: PPUSH
64972: PPUSH
64973: PPUSH
64974: PPUSH
64975: PPUSH
64976: PPUSH
64977: PPUSH
// result := false ;
64978: LD_ADDR_VAR 0 3
64982: PUSH
64983: LD_INT 0
64985: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
64986: LD_VAR 0 1
64990: NOT
64991: IFTRUE 65016
64993: PUSH
64994: LD_VAR 0 1
64998: PPUSH
64999: CALL_OW 266
65003: PUSH
65004: LD_INT 32
65006: PUSH
65007: LD_INT 33
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: IN
65014: NOT
65015: OR
65016: IFFALSE 65020
// exit ;
65018: GO 66155
// nat := GetNation ( tower ) ;
65020: LD_ADDR_VAR 0 12
65024: PUSH
65025: LD_VAR 0 1
65029: PPUSH
65030: CALL_OW 248
65034: ST_TO_ADDR
// side := GetSide ( tower ) ;
65035: LD_ADDR_VAR 0 16
65039: PUSH
65040: LD_VAR 0 1
65044: PPUSH
65045: CALL_OW 255
65049: ST_TO_ADDR
// x := GetX ( tower ) ;
65050: LD_ADDR_VAR 0 10
65054: PUSH
65055: LD_VAR 0 1
65059: PPUSH
65060: CALL_OW 250
65064: ST_TO_ADDR
// y := GetY ( tower ) ;
65065: LD_ADDR_VAR 0 11
65069: PUSH
65070: LD_VAR 0 1
65074: PPUSH
65075: CALL_OW 251
65079: ST_TO_ADDR
// if not x or not y then
65080: LD_VAR 0 10
65084: NOT
65085: IFTRUE 65094
65087: PUSH
65088: LD_VAR 0 11
65092: NOT
65093: OR
65094: IFFALSE 65098
// exit ;
65096: GO 66155
// weapon := 0 ;
65098: LD_ADDR_VAR 0 18
65102: PUSH
65103: LD_INT 0
65105: ST_TO_ADDR
// fac_list := [ ] ;
65106: LD_ADDR_VAR 0 17
65110: PUSH
65111: EMPTY
65112: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
65113: LD_ADDR_VAR 0 6
65117: PUSH
65118: LD_VAR 0 1
65122: PPUSH
65123: CALL_OW 274
65127: PPUSH
65128: LD_VAR 0 2
65132: PPUSH
65133: LD_INT 0
65135: PPUSH
65136: CALL 62690 0 3
65140: PPUSH
65141: LD_INT 30
65143: PUSH
65144: LD_INT 3
65146: PUSH
65147: EMPTY
65148: LIST
65149: LIST
65150: PPUSH
65151: CALL_OW 72
65155: ST_TO_ADDR
// if not factories then
65156: LD_VAR 0 6
65160: NOT
65161: IFFALSE 65165
// exit ;
65163: GO 66155
// for i in factories do
65165: LD_ADDR_VAR 0 8
65169: PUSH
65170: LD_VAR 0 6
65174: PUSH
65175: FOR_IN
65176: IFFALSE 65201
// fac_list := fac_list union AvailableWeaponList ( i ) ;
65178: LD_ADDR_VAR 0 17
65182: PUSH
65183: LD_VAR 0 17
65187: PUSH
65188: LD_VAR 0 8
65192: PPUSH
65193: CALL_OW 478
65197: UNION
65198: ST_TO_ADDR
65199: GO 65175
65201: POP
65202: POP
// if not fac_list then
65203: LD_VAR 0 17
65207: NOT
65208: IFFALSE 65212
// exit ;
65210: GO 66155
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
65212: LD_ADDR_VAR 0 5
65216: PUSH
65217: LD_INT 4
65219: PUSH
65220: LD_INT 5
65222: PUSH
65223: LD_INT 9
65225: PUSH
65226: LD_INT 10
65228: PUSH
65229: LD_INT 6
65231: PUSH
65232: LD_INT 7
65234: PUSH
65235: LD_INT 11
65237: PUSH
65238: EMPTY
65239: LIST
65240: LIST
65241: LIST
65242: LIST
65243: LIST
65244: LIST
65245: LIST
65246: PUSH
65247: LD_INT 27
65249: PUSH
65250: LD_INT 28
65252: PUSH
65253: LD_INT 26
65255: PUSH
65256: LD_INT 30
65258: PUSH
65259: EMPTY
65260: LIST
65261: LIST
65262: LIST
65263: LIST
65264: PUSH
65265: LD_INT 43
65267: PUSH
65268: LD_INT 44
65270: PUSH
65271: LD_INT 46
65273: PUSH
65274: LD_INT 45
65276: PUSH
65277: LD_INT 47
65279: PUSH
65280: LD_INT 49
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: LIST
65287: LIST
65288: LIST
65289: LIST
65290: PUSH
65291: EMPTY
65292: LIST
65293: LIST
65294: LIST
65295: PUSH
65296: LD_VAR 0 12
65300: ARRAY
65301: ST_TO_ADDR
// list := list isect fac_list ;
65302: LD_ADDR_VAR 0 5
65306: PUSH
65307: LD_VAR 0 5
65311: PUSH
65312: LD_VAR 0 17
65316: ISECT
65317: ST_TO_ADDR
// if not list then
65318: LD_VAR 0 5
65322: NOT
65323: IFFALSE 65327
// exit ;
65325: GO 66155
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
65327: LD_VAR 0 12
65331: PUSH
65332: LD_INT 3
65334: EQUAL
65335: IFFALSE 65347
65337: PUSH
65338: LD_INT 49
65340: PUSH
65341: LD_VAR 0 5
65345: IN
65346: AND
65347: IFFALSE 65367
65349: PUSH
65350: LD_INT 31
65352: PPUSH
65353: LD_VAR 0 16
65357: PPUSH
65358: CALL_OW 321
65362: PUSH
65363: LD_INT 2
65365: EQUAL
65366: AND
65367: IFFALSE 65427
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
65369: LD_INT 22
65371: PUSH
65372: LD_VAR 0 16
65376: PUSH
65377: EMPTY
65378: LIST
65379: LIST
65380: PUSH
65381: LD_INT 35
65383: PUSH
65384: LD_INT 49
65386: PUSH
65387: EMPTY
65388: LIST
65389: LIST
65390: PUSH
65391: LD_INT 91
65393: PUSH
65394: LD_VAR 0 1
65398: PUSH
65399: LD_INT 10
65401: PUSH
65402: EMPTY
65403: LIST
65404: LIST
65405: LIST
65406: PUSH
65407: EMPTY
65408: LIST
65409: LIST
65410: LIST
65411: PPUSH
65412: CALL_OW 69
65416: NOT
65417: IFFALSE 65427
// weapon := ru_time_lapser ;
65419: LD_ADDR_VAR 0 18
65423: PUSH
65424: LD_INT 49
65426: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
65427: LD_VAR 0 12
65431: PUSH
65432: LD_INT 1
65434: PUSH
65435: LD_INT 2
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: IN
65442: IFFALSE 65466
65444: PUSH
65445: LD_INT 11
65447: PUSH
65448: LD_VAR 0 5
65452: IN
65453: IFTRUE 65465
65455: PUSH
65456: LD_INT 30
65458: PUSH
65459: LD_VAR 0 5
65463: IN
65464: OR
65465: AND
65466: IFFALSE 65486
65468: PUSH
65469: LD_INT 6
65471: PPUSH
65472: LD_VAR 0 16
65476: PPUSH
65477: CALL_OW 321
65481: PUSH
65482: LD_INT 2
65484: EQUAL
65485: AND
65486: IFFALSE 65653
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
65488: LD_INT 22
65490: PUSH
65491: LD_VAR 0 16
65495: PUSH
65496: EMPTY
65497: LIST
65498: LIST
65499: PUSH
65500: LD_INT 2
65502: PUSH
65503: LD_INT 35
65505: PUSH
65506: LD_INT 11
65508: PUSH
65509: EMPTY
65510: LIST
65511: LIST
65512: PUSH
65513: LD_INT 35
65515: PUSH
65516: LD_INT 30
65518: PUSH
65519: EMPTY
65520: LIST
65521: LIST
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: LIST
65527: PUSH
65528: LD_INT 91
65530: PUSH
65531: LD_VAR 0 1
65535: PUSH
65536: LD_INT 18
65538: PUSH
65539: EMPTY
65540: LIST
65541: LIST
65542: LIST
65543: PUSH
65544: EMPTY
65545: LIST
65546: LIST
65547: LIST
65548: PPUSH
65549: CALL_OW 69
65553: NOT
65554: IFFALSE 65630
65556: PUSH
65557: LD_INT 22
65559: PUSH
65560: LD_VAR 0 16
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: LD_INT 2
65571: PUSH
65572: LD_INT 30
65574: PUSH
65575: LD_INT 32
65577: PUSH
65578: EMPTY
65579: LIST
65580: LIST
65581: PUSH
65582: LD_INT 30
65584: PUSH
65585: LD_INT 33
65587: PUSH
65588: EMPTY
65589: LIST
65590: LIST
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: LIST
65596: PUSH
65597: LD_INT 91
65599: PUSH
65600: LD_VAR 0 1
65604: PUSH
65605: LD_INT 12
65607: PUSH
65608: EMPTY
65609: LIST
65610: LIST
65611: LIST
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: LIST
65617: PUSH
65618: EMPTY
65619: LIST
65620: PPUSH
65621: CALL_OW 69
65625: PUSH
65626: LD_INT 2
65628: GREATER
65629: AND
65630: IFFALSE 65653
// weapon := [ us_radar , ar_radar ] [ nat ] ;
65632: LD_ADDR_VAR 0 18
65636: PUSH
65637: LD_INT 11
65639: PUSH
65640: LD_INT 30
65642: PUSH
65643: EMPTY
65644: LIST
65645: LIST
65646: PUSH
65647: LD_VAR 0 12
65651: ARRAY
65652: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
65653: LD_VAR 0 18
65657: NOT
65658: IFFALSE 65678
65660: PUSH
65661: LD_INT 40
65663: PPUSH
65664: LD_VAR 0 16
65668: PPUSH
65669: CALL_OW 321
65673: PUSH
65674: LD_INT 2
65676: EQUAL
65677: AND
65678: IFFALSE 65714
65680: PUSH
65681: LD_INT 7
65683: PUSH
65684: LD_VAR 0 5
65688: IN
65689: IFTRUE 65701
65691: PUSH
65692: LD_INT 28
65694: PUSH
65695: LD_VAR 0 5
65699: IN
65700: OR
65701: IFTRUE 65713
65703: PUSH
65704: LD_INT 45
65706: PUSH
65707: LD_VAR 0 5
65711: IN
65712: OR
65713: AND
65714: IFFALSE 65968
// begin hex := GetHexInfo ( x , y ) ;
65716: LD_ADDR_VAR 0 4
65720: PUSH
65721: LD_VAR 0 10
65725: PPUSH
65726: LD_VAR 0 11
65730: PPUSH
65731: CALL_OW 546
65735: ST_TO_ADDR
// if hex [ 1 ] then
65736: LD_VAR 0 4
65740: PUSH
65741: LD_INT 1
65743: ARRAY
65744: IFFALSE 65748
// exit ;
65746: GO 66155
// height := hex [ 2 ] ;
65748: LD_ADDR_VAR 0 15
65752: PUSH
65753: LD_VAR 0 4
65757: PUSH
65758: LD_INT 2
65760: ARRAY
65761: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
65762: LD_ADDR_VAR 0 14
65766: PUSH
65767: LD_INT 0
65769: PUSH
65770: LD_INT 2
65772: PUSH
65773: LD_INT 3
65775: PUSH
65776: LD_INT 5
65778: PUSH
65779: EMPTY
65780: LIST
65781: LIST
65782: LIST
65783: LIST
65784: ST_TO_ADDR
// for i in tmp do
65785: LD_ADDR_VAR 0 8
65789: PUSH
65790: LD_VAR 0 14
65794: PUSH
65795: FOR_IN
65796: IFFALSE 65966
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
65798: LD_ADDR_VAR 0 9
65802: PUSH
65803: LD_VAR 0 10
65807: PPUSH
65808: LD_VAR 0 8
65812: PPUSH
65813: LD_INT 5
65815: PPUSH
65816: CALL_OW 272
65820: PUSH
65821: LD_VAR 0 11
65825: PPUSH
65826: LD_VAR 0 8
65830: PPUSH
65831: LD_INT 5
65833: PPUSH
65834: CALL_OW 273
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
65843: LD_VAR 0 9
65847: PUSH
65848: LD_INT 1
65850: ARRAY
65851: PPUSH
65852: LD_VAR 0 9
65856: PUSH
65857: LD_INT 2
65859: ARRAY
65860: PPUSH
65861: CALL_OW 488
65865: IFFALSE 65964
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
65867: LD_ADDR_VAR 0 4
65871: PUSH
65872: LD_VAR 0 9
65876: PUSH
65877: LD_INT 1
65879: ARRAY
65880: PPUSH
65881: LD_VAR 0 9
65885: PUSH
65886: LD_INT 2
65888: ARRAY
65889: PPUSH
65890: CALL_OW 546
65894: ST_TO_ADDR
// if hex [ 1 ] then
65895: LD_VAR 0 4
65899: PUSH
65900: LD_INT 1
65902: ARRAY
65903: IFFALSE 65907
// continue ;
65905: GO 65795
// h := hex [ 2 ] ;
65907: LD_ADDR_VAR 0 13
65911: PUSH
65912: LD_VAR 0 4
65916: PUSH
65917: LD_INT 2
65919: ARRAY
65920: ST_TO_ADDR
// if h + 7 < height then
65921: LD_VAR 0 13
65925: PUSH
65926: LD_INT 7
65928: PLUS
65929: PUSH
65930: LD_VAR 0 15
65934: LESS
65935: IFFALSE 65964
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
65937: LD_ADDR_VAR 0 18
65941: PUSH
65942: LD_INT 7
65944: PUSH
65945: LD_INT 28
65947: PUSH
65948: LD_INT 45
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: LIST
65955: PUSH
65956: LD_VAR 0 12
65960: ARRAY
65961: ST_TO_ADDR
// break ;
65962: GO 65966
// end ; end ; end ;
65964: GO 65795
65966: POP
65967: POP
// end ; if not weapon then
65968: LD_VAR 0 18
65972: NOT
65973: IFFALSE 66033
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
65975: LD_ADDR_VAR 0 5
65979: PUSH
65980: LD_VAR 0 5
65984: PUSH
65985: LD_INT 11
65987: PUSH
65988: LD_INT 30
65990: PUSH
65991: LD_INT 49
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: LIST
65998: DIFF
65999: ST_TO_ADDR
// if not list then
66000: LD_VAR 0 5
66004: NOT
66005: IFFALSE 66009
// exit ;
66007: GO 66155
// weapon := list [ rand ( 1 , list ) ] ;
66009: LD_ADDR_VAR 0 18
66013: PUSH
66014: LD_VAR 0 5
66018: PUSH
66019: LD_INT 1
66021: PPUSH
66022: LD_VAR 0 5
66026: PPUSH
66027: CALL_OW 12
66031: ARRAY
66032: ST_TO_ADDR
// end ; if weapon then
66033: LD_VAR 0 18
66037: IFFALSE 66155
// begin tmp := CostOfWeapon ( weapon ) ;
66039: LD_ADDR_VAR 0 14
66043: PUSH
66044: LD_VAR 0 18
66048: PPUSH
66049: CALL_OW 451
66053: ST_TO_ADDR
// j := GetBase ( tower ) ;
66054: LD_ADDR_VAR 0 9
66058: PUSH
66059: LD_VAR 0 1
66063: PPUSH
66064: CALL_OW 274
66068: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
66069: LD_VAR 0 9
66073: PPUSH
66074: LD_INT 1
66076: PPUSH
66077: CALL_OW 275
66081: PUSH
66082: LD_VAR 0 14
66086: PUSH
66087: LD_INT 1
66089: ARRAY
66090: GREATEREQUAL
66091: IFFALSE 66117
66093: PUSH
66094: LD_VAR 0 9
66098: PPUSH
66099: LD_INT 2
66101: PPUSH
66102: CALL_OW 275
66106: PUSH
66107: LD_VAR 0 14
66111: PUSH
66112: LD_INT 2
66114: ARRAY
66115: GREATEREQUAL
66116: AND
66117: IFFALSE 66143
66119: PUSH
66120: LD_VAR 0 9
66124: PPUSH
66125: LD_INT 3
66127: PPUSH
66128: CALL_OW 275
66132: PUSH
66133: LD_VAR 0 14
66137: PUSH
66138: LD_INT 3
66140: ARRAY
66141: GREATEREQUAL
66142: AND
66143: IFFALSE 66155
// result := weapon ;
66145: LD_ADDR_VAR 0 3
66149: PUSH
66150: LD_VAR 0 18
66154: ST_TO_ADDR
// end ; end ;
66155: LD_VAR 0 3
66159: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
66160: LD_INT 0
66162: PPUSH
66163: PPUSH
// result := true ;
66164: LD_ADDR_VAR 0 3
66168: PUSH
66169: LD_INT 1
66171: ST_TO_ADDR
// if array1 = array2 then
66172: LD_VAR 0 1
66176: PUSH
66177: LD_VAR 0 2
66181: EQUAL
66182: IFFALSE 66242
// begin for i = 1 to array1 do
66184: LD_ADDR_VAR 0 4
66188: PUSH
66189: DOUBLE
66190: LD_INT 1
66192: DEC
66193: ST_TO_ADDR
66194: LD_VAR 0 1
66198: PUSH
66199: FOR_TO
66200: IFFALSE 66238
// if array1 [ i ] <> array2 [ i ] then
66202: LD_VAR 0 1
66206: PUSH
66207: LD_VAR 0 4
66211: ARRAY
66212: PUSH
66213: LD_VAR 0 2
66217: PUSH
66218: LD_VAR 0 4
66222: ARRAY
66223: NONEQUAL
66224: IFFALSE 66236
// begin result := false ;
66226: LD_ADDR_VAR 0 3
66230: PUSH
66231: LD_INT 0
66233: ST_TO_ADDR
// break ;
66234: GO 66238
// end ;
66236: GO 66199
66238: POP
66239: POP
// end else
66240: GO 66250
// result := false ;
66242: LD_ADDR_VAR 0 3
66246: PUSH
66247: LD_INT 0
66249: ST_TO_ADDR
// end ;
66250: LD_VAR 0 3
66254: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
66255: LD_INT 0
66257: PPUSH
66258: PPUSH
// if not array1 or not array2 then
66259: LD_VAR 0 1
66263: NOT
66264: IFTRUE 66273
66266: PUSH
66267: LD_VAR 0 2
66271: NOT
66272: OR
66273: IFFALSE 66277
// exit ;
66275: GO 66341
// result := true ;
66277: LD_ADDR_VAR 0 3
66281: PUSH
66282: LD_INT 1
66284: ST_TO_ADDR
// for i = 1 to array1 do
66285: LD_ADDR_VAR 0 4
66289: PUSH
66290: DOUBLE
66291: LD_INT 1
66293: DEC
66294: ST_TO_ADDR
66295: LD_VAR 0 1
66299: PUSH
66300: FOR_TO
66301: IFFALSE 66339
// if array1 [ i ] <> array2 [ i ] then
66303: LD_VAR 0 1
66307: PUSH
66308: LD_VAR 0 4
66312: ARRAY
66313: PUSH
66314: LD_VAR 0 2
66318: PUSH
66319: LD_VAR 0 4
66323: ARRAY
66324: NONEQUAL
66325: IFFALSE 66337
// begin result := false ;
66327: LD_ADDR_VAR 0 3
66331: PUSH
66332: LD_INT 0
66334: ST_TO_ADDR
// break ;
66335: GO 66339
// end ;
66337: GO 66300
66339: POP
66340: POP
// end ;
66341: LD_VAR 0 3
66345: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
66346: LD_INT 0
66348: PPUSH
66349: PPUSH
66350: PPUSH
// pom := GetBase ( fac ) ;
66351: LD_ADDR_VAR 0 5
66355: PUSH
66356: LD_VAR 0 1
66360: PPUSH
66361: CALL_OW 274
66365: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
66366: LD_ADDR_VAR 0 4
66370: PUSH
66371: LD_VAR 0 2
66375: PUSH
66376: LD_INT 1
66378: ARRAY
66379: PPUSH
66380: LD_VAR 0 2
66384: PUSH
66385: LD_INT 2
66387: ARRAY
66388: PPUSH
66389: LD_VAR 0 2
66393: PUSH
66394: LD_INT 3
66396: ARRAY
66397: PPUSH
66398: LD_VAR 0 2
66402: PUSH
66403: LD_INT 4
66405: ARRAY
66406: PPUSH
66407: CALL_OW 449
66411: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
66412: LD_ADDR_VAR 0 3
66416: PUSH
66417: LD_VAR 0 5
66421: PPUSH
66422: LD_INT 1
66424: PPUSH
66425: CALL_OW 275
66429: PUSH
66430: LD_VAR 0 4
66434: PUSH
66435: LD_INT 1
66437: ARRAY
66438: GREATEREQUAL
66439: IFFALSE 66465
66441: PUSH
66442: LD_VAR 0 5
66446: PPUSH
66447: LD_INT 2
66449: PPUSH
66450: CALL_OW 275
66454: PUSH
66455: LD_VAR 0 4
66459: PUSH
66460: LD_INT 2
66462: ARRAY
66463: GREATEREQUAL
66464: AND
66465: IFFALSE 66491
66467: PUSH
66468: LD_VAR 0 5
66472: PPUSH
66473: LD_INT 3
66475: PPUSH
66476: CALL_OW 275
66480: PUSH
66481: LD_VAR 0 4
66485: PUSH
66486: LD_INT 3
66488: ARRAY
66489: GREATEREQUAL
66490: AND
66491: ST_TO_ADDR
// end ;
66492: LD_VAR 0 3
66496: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
66497: LD_INT 0
66499: PPUSH
66500: PPUSH
66501: PPUSH
66502: PPUSH
// pom := GetBase ( building ) ;
66503: LD_ADDR_VAR 0 3
66507: PUSH
66508: LD_VAR 0 1
66512: PPUSH
66513: CALL_OW 274
66517: ST_TO_ADDR
// if not pom then
66518: LD_VAR 0 3
66522: NOT
66523: IFFALSE 66527
// exit ;
66525: GO 66701
// btype := GetBType ( building ) ;
66527: LD_ADDR_VAR 0 5
66531: PUSH
66532: LD_VAR 0 1
66536: PPUSH
66537: CALL_OW 266
66541: ST_TO_ADDR
// if btype = b_armoury then
66542: LD_VAR 0 5
66546: PUSH
66547: LD_INT 4
66549: EQUAL
66550: IFFALSE 66560
// btype := b_barracks ;
66552: LD_ADDR_VAR 0 5
66556: PUSH
66557: LD_INT 5
66559: ST_TO_ADDR
// if btype = b_depot then
66560: LD_VAR 0 5
66564: PUSH
66565: LD_INT 0
66567: EQUAL
66568: IFFALSE 66578
// btype := b_warehouse ;
66570: LD_ADDR_VAR 0 5
66574: PUSH
66575: LD_INT 1
66577: ST_TO_ADDR
// if btype = b_workshop then
66578: LD_VAR 0 5
66582: PUSH
66583: LD_INT 2
66585: EQUAL
66586: IFFALSE 66596
// btype := b_factory ;
66588: LD_ADDR_VAR 0 5
66592: PUSH
66593: LD_INT 3
66595: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
66596: LD_ADDR_VAR 0 4
66600: PUSH
66601: LD_VAR 0 5
66605: PPUSH
66606: LD_VAR 0 1
66610: PPUSH
66611: CALL_OW 248
66615: PPUSH
66616: CALL_OW 450
66620: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
66621: LD_ADDR_VAR 0 2
66625: PUSH
66626: LD_VAR 0 3
66630: PPUSH
66631: LD_INT 1
66633: PPUSH
66634: CALL_OW 275
66638: PUSH
66639: LD_VAR 0 4
66643: PUSH
66644: LD_INT 1
66646: ARRAY
66647: GREATEREQUAL
66648: IFFALSE 66674
66650: PUSH
66651: LD_VAR 0 3
66655: PPUSH
66656: LD_INT 2
66658: PPUSH
66659: CALL_OW 275
66663: PUSH
66664: LD_VAR 0 4
66668: PUSH
66669: LD_INT 2
66671: ARRAY
66672: GREATEREQUAL
66673: AND
66674: IFFALSE 66700
66676: PUSH
66677: LD_VAR 0 3
66681: PPUSH
66682: LD_INT 3
66684: PPUSH
66685: CALL_OW 275
66689: PUSH
66690: LD_VAR 0 4
66694: PUSH
66695: LD_INT 3
66697: ARRAY
66698: GREATEREQUAL
66699: AND
66700: ST_TO_ADDR
// end ;
66701: LD_VAR 0 2
66705: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
66706: LD_INT 0
66708: PPUSH
66709: PPUSH
66710: PPUSH
// pom := GetBase ( building ) ;
66711: LD_ADDR_VAR 0 4
66715: PUSH
66716: LD_VAR 0 1
66720: PPUSH
66721: CALL_OW 274
66725: ST_TO_ADDR
// if not pom then
66726: LD_VAR 0 4
66730: NOT
66731: IFFALSE 66735
// exit ;
66733: GO 66840
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
66735: LD_ADDR_VAR 0 5
66739: PUSH
66740: LD_VAR 0 2
66744: PPUSH
66745: LD_VAR 0 1
66749: PPUSH
66750: CALL_OW 248
66754: PPUSH
66755: CALL_OW 450
66759: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
66760: LD_ADDR_VAR 0 3
66764: PUSH
66765: LD_VAR 0 4
66769: PPUSH
66770: LD_INT 1
66772: PPUSH
66773: CALL_OW 275
66777: PUSH
66778: LD_VAR 0 5
66782: PUSH
66783: LD_INT 1
66785: ARRAY
66786: GREATEREQUAL
66787: IFFALSE 66813
66789: PUSH
66790: LD_VAR 0 4
66794: PPUSH
66795: LD_INT 2
66797: PPUSH
66798: CALL_OW 275
66802: PUSH
66803: LD_VAR 0 5
66807: PUSH
66808: LD_INT 2
66810: ARRAY
66811: GREATEREQUAL
66812: AND
66813: IFFALSE 66839
66815: PUSH
66816: LD_VAR 0 4
66820: PPUSH
66821: LD_INT 3
66823: PPUSH
66824: CALL_OW 275
66828: PUSH
66829: LD_VAR 0 5
66833: PUSH
66834: LD_INT 3
66836: ARRAY
66837: GREATEREQUAL
66838: AND
66839: ST_TO_ADDR
// end ;
66840: LD_VAR 0 3
66844: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
66845: LD_INT 0
66847: PPUSH
66848: PPUSH
66849: PPUSH
66850: PPUSH
66851: PPUSH
66852: PPUSH
66853: PPUSH
66854: PPUSH
66855: PPUSH
66856: PPUSH
66857: PPUSH
// result := false ;
66858: LD_ADDR_VAR 0 8
66862: PUSH
66863: LD_INT 0
66865: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
66866: LD_VAR 0 5
66870: NOT
66871: IFTRUE 66880
66873: PUSH
66874: LD_VAR 0 1
66878: NOT
66879: OR
66880: IFTRUE 66889
66882: PUSH
66883: LD_VAR 0 2
66887: NOT
66888: OR
66889: IFTRUE 66898
66891: PUSH
66892: LD_VAR 0 3
66896: NOT
66897: OR
66898: IFFALSE 66902
// exit ;
66900: GO 67728
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
66902: LD_ADDR_VAR 0 14
66906: PUSH
66907: LD_VAR 0 1
66911: PPUSH
66912: LD_VAR 0 2
66916: PPUSH
66917: LD_VAR 0 3
66921: PPUSH
66922: LD_VAR 0 4
66926: PPUSH
66927: LD_VAR 0 5
66931: PUSH
66932: LD_INT 1
66934: ARRAY
66935: PPUSH
66936: CALL_OW 248
66940: PPUSH
66941: LD_INT 0
66943: PPUSH
66944: CALL 69009 0 6
66948: ST_TO_ADDR
// if not hexes then
66949: LD_VAR 0 14
66953: NOT
66954: IFFALSE 66958
// exit ;
66956: GO 67728
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
66958: LD_ADDR_VAR 0 17
66962: PUSH
66963: LD_VAR 0 5
66967: PPUSH
66968: LD_INT 22
66970: PUSH
66971: LD_VAR 0 13
66975: PPUSH
66976: CALL_OW 255
66980: PUSH
66981: EMPTY
66982: LIST
66983: LIST
66984: PUSH
66985: LD_INT 2
66987: PUSH
66988: LD_INT 30
66990: PUSH
66991: LD_INT 0
66993: PUSH
66994: EMPTY
66995: LIST
66996: LIST
66997: PUSH
66998: LD_INT 30
67000: PUSH
67001: LD_INT 1
67003: PUSH
67004: EMPTY
67005: LIST
67006: LIST
67007: PUSH
67008: EMPTY
67009: LIST
67010: LIST
67011: LIST
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: PPUSH
67017: CALL_OW 72
67021: ST_TO_ADDR
// for i = 1 to hexes do
67022: LD_ADDR_VAR 0 9
67026: PUSH
67027: DOUBLE
67028: LD_INT 1
67030: DEC
67031: ST_TO_ADDR
67032: LD_VAR 0 14
67036: PUSH
67037: FOR_TO
67038: IFFALSE 67726
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
67040: LD_ADDR_VAR 0 13
67044: PUSH
67045: LD_VAR 0 14
67049: PUSH
67050: LD_VAR 0 9
67054: ARRAY
67055: PUSH
67056: LD_INT 1
67058: ARRAY
67059: PPUSH
67060: LD_VAR 0 14
67064: PUSH
67065: LD_VAR 0 9
67069: ARRAY
67070: PUSH
67071: LD_INT 2
67073: ARRAY
67074: PPUSH
67075: CALL_OW 428
67079: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
67080: LD_VAR 0 14
67084: PUSH
67085: LD_VAR 0 9
67089: ARRAY
67090: PUSH
67091: LD_INT 1
67093: ARRAY
67094: PPUSH
67095: LD_VAR 0 14
67099: PUSH
67100: LD_VAR 0 9
67104: ARRAY
67105: PUSH
67106: LD_INT 2
67108: ARRAY
67109: PPUSH
67110: CALL_OW 351
67114: IFTRUE 67153
67116: PUSH
67117: LD_VAR 0 14
67121: PUSH
67122: LD_VAR 0 9
67126: ARRAY
67127: PUSH
67128: LD_INT 1
67130: ARRAY
67131: PPUSH
67132: LD_VAR 0 14
67136: PUSH
67137: LD_VAR 0 9
67141: ARRAY
67142: PUSH
67143: LD_INT 2
67145: ARRAY
67146: PPUSH
67147: CALL_OW 488
67151: NOT
67152: OR
67153: IFTRUE 67170
67155: PUSH
67156: LD_VAR 0 13
67160: PPUSH
67161: CALL_OW 247
67165: PUSH
67166: LD_INT 3
67168: EQUAL
67169: OR
67170: IFFALSE 67176
// exit ;
67172: POP
67173: POP
67174: GO 67728
// if not tmp then
67176: LD_VAR 0 13
67180: NOT
67181: IFFALSE 67185
// continue ;
67183: GO 67037
// result := true ;
67185: LD_ADDR_VAR 0 8
67189: PUSH
67190: LD_INT 1
67192: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
67193: LD_VAR 0 6
67197: IFFALSE 67214
67199: PUSH
67200: LD_VAR 0 13
67204: PPUSH
67205: CALL_OW 247
67209: PUSH
67210: LD_INT 2
67212: EQUAL
67213: AND
67214: IFFALSE 67231
67216: PUSH
67217: LD_VAR 0 13
67221: PPUSH
67222: CALL_OW 263
67226: PUSH
67227: LD_INT 1
67229: EQUAL
67230: AND
67231: IFFALSE 67395
// begin if IsDrivenBy ( tmp ) then
67233: LD_VAR 0 13
67237: PPUSH
67238: CALL_OW 311
67242: IFFALSE 67246
// continue ;
67244: GO 67037
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
67246: LD_VAR 0 6
67250: PPUSH
67251: LD_INT 3
67253: PUSH
67254: LD_INT 60
67256: PUSH
67257: EMPTY
67258: LIST
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: PUSH
67264: LD_INT 3
67266: PUSH
67267: LD_INT 55
67269: PUSH
67270: EMPTY
67271: LIST
67272: PUSH
67273: EMPTY
67274: LIST
67275: LIST
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: PPUSH
67281: CALL_OW 72
67285: IFFALSE 67393
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
67287: LD_ADDR_VAR 0 18
67291: PUSH
67292: LD_VAR 0 6
67296: PPUSH
67297: LD_INT 3
67299: PUSH
67300: LD_INT 60
67302: PUSH
67303: EMPTY
67304: LIST
67305: PUSH
67306: EMPTY
67307: LIST
67308: LIST
67309: PUSH
67310: LD_INT 3
67312: PUSH
67313: LD_INT 55
67315: PUSH
67316: EMPTY
67317: LIST
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: EMPTY
67324: LIST
67325: LIST
67326: PPUSH
67327: CALL_OW 72
67331: PUSH
67332: LD_INT 1
67334: ARRAY
67335: ST_TO_ADDR
// if IsInUnit ( driver ) then
67336: LD_VAR 0 18
67340: PPUSH
67341: CALL_OW 310
67345: IFFALSE 67356
// ComExit ( driver ) ;
67347: LD_VAR 0 18
67351: PPUSH
67352: CALL 92999 0 1
// AddComEnterUnit ( driver , tmp ) ;
67356: LD_VAR 0 18
67360: PPUSH
67361: LD_VAR 0 13
67365: PPUSH
67366: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
67370: LD_VAR 0 18
67374: PPUSH
67375: LD_VAR 0 7
67379: PPUSH
67380: CALL_OW 173
// AddComExitVehicle ( driver ) ;
67384: LD_VAR 0 18
67388: PPUSH
67389: CALL_OW 181
// end ; continue ;
67393: GO 67037
// end ; if not cleaners or not tmp in cleaners then
67395: LD_VAR 0 6
67399: NOT
67400: IFTRUE 67415
67402: PUSH
67403: LD_VAR 0 13
67407: PUSH
67408: LD_VAR 0 6
67412: IN
67413: NOT
67414: OR
67415: IFFALSE 67724
// begin if dep then
67417: LD_VAR 0 17
67421: IFFALSE 67557
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
67423: LD_ADDR_VAR 0 16
67427: PUSH
67428: LD_VAR 0 17
67432: PUSH
67433: LD_INT 1
67435: ARRAY
67436: PPUSH
67437: CALL_OW 250
67441: PPUSH
67442: LD_VAR 0 17
67446: PUSH
67447: LD_INT 1
67449: ARRAY
67450: PPUSH
67451: CALL_OW 254
67455: PPUSH
67456: LD_INT 5
67458: PPUSH
67459: CALL_OW 272
67463: PUSH
67464: LD_VAR 0 17
67468: PUSH
67469: LD_INT 1
67471: ARRAY
67472: PPUSH
67473: CALL_OW 251
67477: PPUSH
67478: LD_VAR 0 17
67482: PUSH
67483: LD_INT 1
67485: ARRAY
67486: PPUSH
67487: CALL_OW 254
67491: PPUSH
67492: LD_INT 5
67494: PPUSH
67495: CALL_OW 273
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
67504: LD_VAR 0 16
67508: PUSH
67509: LD_INT 1
67511: ARRAY
67512: PPUSH
67513: LD_VAR 0 16
67517: PUSH
67518: LD_INT 2
67520: ARRAY
67521: PPUSH
67522: CALL_OW 488
67526: IFFALSE 67557
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
67528: LD_VAR 0 13
67532: PPUSH
67533: LD_VAR 0 16
67537: PUSH
67538: LD_INT 1
67540: ARRAY
67541: PPUSH
67542: LD_VAR 0 16
67546: PUSH
67547: LD_INT 2
67549: ARRAY
67550: PPUSH
67551: CALL_OW 111
// continue ;
67555: GO 67037
// end ; end ; r := GetDir ( tmp ) ;
67557: LD_ADDR_VAR 0 15
67561: PUSH
67562: LD_VAR 0 13
67566: PPUSH
67567: CALL_OW 254
67571: ST_TO_ADDR
// if r = 5 then
67572: LD_VAR 0 15
67576: PUSH
67577: LD_INT 5
67579: EQUAL
67580: IFFALSE 67590
// r := 0 ;
67582: LD_ADDR_VAR 0 15
67586: PUSH
67587: LD_INT 0
67589: ST_TO_ADDR
// for j = r to 5 do
67590: LD_ADDR_VAR 0 10
67594: PUSH
67595: DOUBLE
67596: LD_VAR 0 15
67600: DEC
67601: ST_TO_ADDR
67602: LD_INT 5
67604: PUSH
67605: FOR_TO
67606: IFFALSE 67722
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
67608: LD_ADDR_VAR 0 11
67612: PUSH
67613: LD_VAR 0 13
67617: PPUSH
67618: CALL_OW 250
67622: PPUSH
67623: LD_VAR 0 10
67627: PPUSH
67628: LD_INT 2
67630: PPUSH
67631: CALL_OW 272
67635: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
67636: LD_ADDR_VAR 0 12
67640: PUSH
67641: LD_VAR 0 13
67645: PPUSH
67646: CALL_OW 251
67650: PPUSH
67651: LD_VAR 0 10
67655: PPUSH
67656: LD_INT 2
67658: PPUSH
67659: CALL_OW 273
67663: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
67664: LD_VAR 0 11
67668: PPUSH
67669: LD_VAR 0 12
67673: PPUSH
67674: CALL_OW 488
67678: IFFALSE 67697
67680: PUSH
67681: LD_VAR 0 11
67685: PPUSH
67686: LD_VAR 0 12
67690: PPUSH
67691: CALL_OW 428
67695: NOT
67696: AND
67697: IFFALSE 67720
// begin ComMoveXY ( tmp , _x , _y ) ;
67699: LD_VAR 0 13
67703: PPUSH
67704: LD_VAR 0 11
67708: PPUSH
67709: LD_VAR 0 12
67713: PPUSH
67714: CALL_OW 111
// break ;
67718: GO 67722
// end ; end ;
67720: GO 67605
67722: POP
67723: POP
// end ; end ;
67724: GO 67037
67726: POP
67727: POP
// end ;
67728: LD_VAR 0 8
67732: RET
// export function BuildingTechInvented ( side , btype ) ; begin
67733: LD_INT 0
67735: PPUSH
// result := true ;
67736: LD_ADDR_VAR 0 3
67740: PUSH
67741: LD_INT 1
67743: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
67744: LD_VAR 0 2
67748: PUSH
67749: LD_INT 24
67751: DOUBLE
67752: EQUAL
67753: IFTRUE 67763
67755: LD_INT 33
67757: DOUBLE
67758: EQUAL
67759: IFTRUE 67763
67761: GO 67788
67763: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
67764: LD_ADDR_VAR 0 3
67768: PUSH
67769: LD_INT 32
67771: PPUSH
67772: LD_VAR 0 1
67776: PPUSH
67777: CALL_OW 321
67781: PUSH
67782: LD_INT 2
67784: EQUAL
67785: ST_TO_ADDR
67786: GO 68104
67788: LD_INT 20
67790: DOUBLE
67791: EQUAL
67792: IFTRUE 67796
67794: GO 67821
67796: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
67797: LD_ADDR_VAR 0 3
67801: PUSH
67802: LD_INT 6
67804: PPUSH
67805: LD_VAR 0 1
67809: PPUSH
67810: CALL_OW 321
67814: PUSH
67815: LD_INT 2
67817: EQUAL
67818: ST_TO_ADDR
67819: GO 68104
67821: LD_INT 22
67823: DOUBLE
67824: EQUAL
67825: IFTRUE 67835
67827: LD_INT 36
67829: DOUBLE
67830: EQUAL
67831: IFTRUE 67835
67833: GO 67860
67835: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
67836: LD_ADDR_VAR 0 3
67840: PUSH
67841: LD_INT 15
67843: PPUSH
67844: LD_VAR 0 1
67848: PPUSH
67849: CALL_OW 321
67853: PUSH
67854: LD_INT 2
67856: EQUAL
67857: ST_TO_ADDR
67858: GO 68104
67860: LD_INT 30
67862: DOUBLE
67863: EQUAL
67864: IFTRUE 67868
67866: GO 67893
67868: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
67869: LD_ADDR_VAR 0 3
67873: PUSH
67874: LD_INT 20
67876: PPUSH
67877: LD_VAR 0 1
67881: PPUSH
67882: CALL_OW 321
67886: PUSH
67887: LD_INT 2
67889: EQUAL
67890: ST_TO_ADDR
67891: GO 68104
67893: LD_INT 28
67895: DOUBLE
67896: EQUAL
67897: IFTRUE 67907
67899: LD_INT 21
67901: DOUBLE
67902: EQUAL
67903: IFTRUE 67907
67905: GO 67932
67907: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
67908: LD_ADDR_VAR 0 3
67912: PUSH
67913: LD_INT 21
67915: PPUSH
67916: LD_VAR 0 1
67920: PPUSH
67921: CALL_OW 321
67925: PUSH
67926: LD_INT 2
67928: EQUAL
67929: ST_TO_ADDR
67930: GO 68104
67932: LD_INT 16
67934: DOUBLE
67935: EQUAL
67936: IFTRUE 67940
67938: GO 67965
67940: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
67941: LD_ADDR_VAR 0 3
67945: PUSH
67946: LD_INT 84
67948: PPUSH
67949: LD_VAR 0 1
67953: PPUSH
67954: CALL_OW 321
67958: PUSH
67959: LD_INT 2
67961: EQUAL
67962: ST_TO_ADDR
67963: GO 68104
67965: LD_INT 19
67967: DOUBLE
67968: EQUAL
67969: IFTRUE 67979
67971: LD_INT 23
67973: DOUBLE
67974: EQUAL
67975: IFTRUE 67979
67977: GO 68004
67979: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
67980: LD_ADDR_VAR 0 3
67984: PUSH
67985: LD_INT 83
67987: PPUSH
67988: LD_VAR 0 1
67992: PPUSH
67993: CALL_OW 321
67997: PUSH
67998: LD_INT 2
68000: EQUAL
68001: ST_TO_ADDR
68002: GO 68104
68004: LD_INT 17
68006: DOUBLE
68007: EQUAL
68008: IFTRUE 68012
68010: GO 68037
68012: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
68013: LD_ADDR_VAR 0 3
68017: PUSH
68018: LD_INT 39
68020: PPUSH
68021: LD_VAR 0 1
68025: PPUSH
68026: CALL_OW 321
68030: PUSH
68031: LD_INT 2
68033: EQUAL
68034: ST_TO_ADDR
68035: GO 68104
68037: LD_INT 18
68039: DOUBLE
68040: EQUAL
68041: IFTRUE 68045
68043: GO 68070
68045: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
68046: LD_ADDR_VAR 0 3
68050: PUSH
68051: LD_INT 40
68053: PPUSH
68054: LD_VAR 0 1
68058: PPUSH
68059: CALL_OW 321
68063: PUSH
68064: LD_INT 2
68066: EQUAL
68067: ST_TO_ADDR
68068: GO 68104
68070: LD_INT 27
68072: DOUBLE
68073: EQUAL
68074: IFTRUE 68078
68076: GO 68103
68078: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
68079: LD_ADDR_VAR 0 3
68083: PUSH
68084: LD_INT 35
68086: PPUSH
68087: LD_VAR 0 1
68091: PPUSH
68092: CALL_OW 321
68096: PUSH
68097: LD_INT 2
68099: EQUAL
68100: ST_TO_ADDR
68101: GO 68104
68103: POP
// end ;
68104: LD_VAR 0 3
68108: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
68109: LD_INT 0
68111: PPUSH
68112: PPUSH
68113: PPUSH
68114: PPUSH
68115: PPUSH
68116: PPUSH
68117: PPUSH
68118: PPUSH
68119: PPUSH
68120: PPUSH
68121: PPUSH
// result := false ;
68122: LD_ADDR_VAR 0 6
68126: PUSH
68127: LD_INT 0
68129: ST_TO_ADDR
// if btype = b_depot then
68130: LD_VAR 0 2
68134: PUSH
68135: LD_INT 0
68137: EQUAL
68138: IFFALSE 68150
// begin result := true ;
68140: LD_ADDR_VAR 0 6
68144: PUSH
68145: LD_INT 1
68147: ST_TO_ADDR
// exit ;
68148: GO 69004
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
68150: LD_VAR 0 1
68154: NOT
68155: IFTRUE 68180
68157: PUSH
68158: LD_VAR 0 1
68162: PPUSH
68163: CALL_OW 266
68167: PUSH
68168: LD_INT 0
68170: PUSH
68171: LD_INT 1
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: IN
68178: NOT
68179: OR
68180: IFTRUE 68189
68182: PUSH
68183: LD_VAR 0 2
68187: NOT
68188: OR
68189: IFTRUE 68225
68191: PUSH
68192: LD_VAR 0 5
68196: PUSH
68197: LD_INT 0
68199: PUSH
68200: LD_INT 1
68202: PUSH
68203: LD_INT 2
68205: PUSH
68206: LD_INT 3
68208: PUSH
68209: LD_INT 4
68211: PUSH
68212: LD_INT 5
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: LIST
68219: LIST
68220: LIST
68221: LIST
68222: IN
68223: NOT
68224: OR
68225: IFTRUE 68244
68227: PUSH
68228: LD_VAR 0 3
68232: PPUSH
68233: LD_VAR 0 4
68237: PPUSH
68238: CALL_OW 488
68242: NOT
68243: OR
68244: IFFALSE 68248
// exit ;
68246: GO 69004
// side := GetSide ( depot ) ;
68248: LD_ADDR_VAR 0 9
68252: PUSH
68253: LD_VAR 0 1
68257: PPUSH
68258: CALL_OW 255
68262: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
68263: LD_VAR 0 9
68267: PPUSH
68268: LD_VAR 0 2
68272: PPUSH
68273: CALL 67733 0 2
68277: NOT
68278: IFFALSE 68282
// exit ;
68280: GO 69004
// pom := GetBase ( depot ) ;
68282: LD_ADDR_VAR 0 10
68286: PUSH
68287: LD_VAR 0 1
68291: PPUSH
68292: CALL_OW 274
68296: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
68297: LD_ADDR_VAR 0 11
68301: PUSH
68302: LD_VAR 0 2
68306: PPUSH
68307: LD_VAR 0 1
68311: PPUSH
68312: CALL_OW 248
68316: PPUSH
68317: CALL_OW 450
68321: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
68322: LD_VAR 0 10
68326: PPUSH
68327: LD_INT 1
68329: PPUSH
68330: CALL_OW 275
68334: PUSH
68335: LD_VAR 0 11
68339: PUSH
68340: LD_INT 1
68342: ARRAY
68343: GREATEREQUAL
68344: IFFALSE 68370
68346: PUSH
68347: LD_VAR 0 10
68351: PPUSH
68352: LD_INT 2
68354: PPUSH
68355: CALL_OW 275
68359: PUSH
68360: LD_VAR 0 11
68364: PUSH
68365: LD_INT 2
68367: ARRAY
68368: GREATEREQUAL
68369: AND
68370: IFFALSE 68396
68372: PUSH
68373: LD_VAR 0 10
68377: PPUSH
68378: LD_INT 3
68380: PPUSH
68381: CALL_OW 275
68385: PUSH
68386: LD_VAR 0 11
68390: PUSH
68391: LD_INT 3
68393: ARRAY
68394: GREATEREQUAL
68395: AND
68396: NOT
68397: IFFALSE 68401
// exit ;
68399: GO 69004
// if GetBType ( depot ) = b_depot then
68401: LD_VAR 0 1
68405: PPUSH
68406: CALL_OW 266
68410: PUSH
68411: LD_INT 0
68413: EQUAL
68414: IFFALSE 68426
// dist := 28 else
68416: LD_ADDR_VAR 0 14
68420: PUSH
68421: LD_INT 28
68423: ST_TO_ADDR
68424: GO 68434
// dist := 36 ;
68426: LD_ADDR_VAR 0 14
68430: PUSH
68431: LD_INT 36
68433: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
68434: LD_VAR 0 1
68438: PPUSH
68439: LD_VAR 0 3
68443: PPUSH
68444: LD_VAR 0 4
68448: PPUSH
68449: CALL_OW 297
68453: PUSH
68454: LD_VAR 0 14
68458: GREATER
68459: IFFALSE 68463
// exit ;
68461: GO 69004
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
68463: LD_ADDR_VAR 0 12
68467: PUSH
68468: LD_VAR 0 2
68472: PPUSH
68473: LD_VAR 0 3
68477: PPUSH
68478: LD_VAR 0 4
68482: PPUSH
68483: LD_VAR 0 5
68487: PPUSH
68488: LD_VAR 0 1
68492: PPUSH
68493: CALL_OW 248
68497: PPUSH
68498: LD_INT 0
68500: PPUSH
68501: CALL 69009 0 6
68505: ST_TO_ADDR
// if not hexes then
68506: LD_VAR 0 12
68510: NOT
68511: IFFALSE 68515
// exit ;
68513: GO 69004
// hex := GetHexInfo ( x , y ) ;
68515: LD_ADDR_VAR 0 15
68519: PUSH
68520: LD_VAR 0 3
68524: PPUSH
68525: LD_VAR 0 4
68529: PPUSH
68530: CALL_OW 546
68534: ST_TO_ADDR
// if hex [ 1 ] then
68535: LD_VAR 0 15
68539: PUSH
68540: LD_INT 1
68542: ARRAY
68543: IFFALSE 68547
// exit ;
68545: GO 69004
// height := hex [ 2 ] ;
68547: LD_ADDR_VAR 0 13
68551: PUSH
68552: LD_VAR 0 15
68556: PUSH
68557: LD_INT 2
68559: ARRAY
68560: ST_TO_ADDR
// for i = 1 to hexes do
68561: LD_ADDR_VAR 0 7
68565: PUSH
68566: DOUBLE
68567: LD_INT 1
68569: DEC
68570: ST_TO_ADDR
68571: LD_VAR 0 12
68575: PUSH
68576: FOR_TO
68577: IFFALSE 68921
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
68579: LD_VAR 0 12
68583: PUSH
68584: LD_VAR 0 7
68588: ARRAY
68589: PUSH
68590: LD_INT 1
68592: ARRAY
68593: PPUSH
68594: LD_VAR 0 12
68598: PUSH
68599: LD_VAR 0 7
68603: ARRAY
68604: PUSH
68605: LD_INT 2
68607: ARRAY
68608: PPUSH
68609: CALL_OW 488
68613: NOT
68614: IFTRUE 68656
68616: PUSH
68617: LD_VAR 0 12
68621: PUSH
68622: LD_VAR 0 7
68626: ARRAY
68627: PUSH
68628: LD_INT 1
68630: ARRAY
68631: PPUSH
68632: LD_VAR 0 12
68636: PUSH
68637: LD_VAR 0 7
68641: ARRAY
68642: PUSH
68643: LD_INT 2
68645: ARRAY
68646: PPUSH
68647: CALL_OW 428
68651: PUSH
68652: LD_INT 0
68654: GREATER
68655: OR
68656: IFTRUE 68694
68658: PUSH
68659: LD_VAR 0 12
68663: PUSH
68664: LD_VAR 0 7
68668: ARRAY
68669: PUSH
68670: LD_INT 1
68672: ARRAY
68673: PPUSH
68674: LD_VAR 0 12
68678: PUSH
68679: LD_VAR 0 7
68683: ARRAY
68684: PUSH
68685: LD_INT 2
68687: ARRAY
68688: PPUSH
68689: CALL_OW 351
68693: OR
68694: IFFALSE 68700
// exit ;
68696: POP
68697: POP
68698: GO 69004
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
68700: LD_ADDR_VAR 0 8
68704: PUSH
68705: LD_VAR 0 12
68709: PUSH
68710: LD_VAR 0 7
68714: ARRAY
68715: PUSH
68716: LD_INT 1
68718: ARRAY
68719: PPUSH
68720: LD_VAR 0 12
68724: PUSH
68725: LD_VAR 0 7
68729: ARRAY
68730: PUSH
68731: LD_INT 2
68733: ARRAY
68734: PPUSH
68735: CALL_OW 546
68739: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
68740: LD_VAR 0 8
68744: PUSH
68745: LD_INT 1
68747: ARRAY
68748: IFTRUE 68770
68750: PUSH
68751: LD_VAR 0 8
68755: PUSH
68756: LD_INT 2
68758: ARRAY
68759: PUSH
68760: LD_VAR 0 13
68764: PUSH
68765: LD_INT 2
68767: PLUS
68768: GREATER
68769: OR
68770: IFTRUE 68792
68772: PUSH
68773: LD_VAR 0 8
68777: PUSH
68778: LD_INT 2
68780: ARRAY
68781: PUSH
68782: LD_VAR 0 13
68786: PUSH
68787: LD_INT 2
68789: MINUS
68790: LESS
68791: OR
68792: IFTRUE 68860
68794: PUSH
68795: LD_VAR 0 8
68799: PUSH
68800: LD_INT 3
68802: ARRAY
68803: PUSH
68804: LD_INT 0
68806: PUSH
68807: LD_INT 8
68809: PUSH
68810: LD_INT 9
68812: PUSH
68813: LD_INT 10
68815: PUSH
68816: LD_INT 11
68818: PUSH
68819: LD_INT 12
68821: PUSH
68822: LD_INT 13
68824: PUSH
68825: LD_INT 16
68827: PUSH
68828: LD_INT 17
68830: PUSH
68831: LD_INT 18
68833: PUSH
68834: LD_INT 19
68836: PUSH
68837: LD_INT 20
68839: PUSH
68840: LD_INT 21
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: IN
68858: NOT
68859: OR
68860: IFTRUE 68873
68862: PUSH
68863: LD_VAR 0 8
68867: PUSH
68868: LD_INT 5
68870: ARRAY
68871: NOT
68872: OR
68873: IFTRUE 68913
68875: PUSH
68876: LD_VAR 0 8
68880: PUSH
68881: LD_INT 6
68883: ARRAY
68884: PUSH
68885: LD_INT 1
68887: PUSH
68888: LD_INT 2
68890: PUSH
68891: LD_INT 7
68893: PUSH
68894: LD_INT 9
68896: PUSH
68897: LD_INT 10
68899: PUSH
68900: LD_INT 11
68902: PUSH
68903: EMPTY
68904: LIST
68905: LIST
68906: LIST
68907: LIST
68908: LIST
68909: LIST
68910: IN
68911: NOT
68912: OR
68913: IFFALSE 68919
// exit ;
68915: POP
68916: POP
68917: GO 69004
// end ;
68919: GO 68576
68921: POP
68922: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
68923: LD_VAR 0 9
68927: PPUSH
68928: LD_VAR 0 3
68932: PPUSH
68933: LD_VAR 0 4
68937: PPUSH
68938: LD_INT 20
68940: PPUSH
68941: CALL 60823 0 4
68945: PUSH
68946: LD_INT 4
68948: ARRAY
68949: IFFALSE 68953
// exit ;
68951: GO 69004
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
68953: LD_VAR 0 2
68957: PUSH
68958: LD_INT 29
68960: PUSH
68961: LD_INT 30
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: IN
68968: IFFALSE 68992
68970: PUSH
68971: LD_VAR 0 3
68975: PPUSH
68976: LD_VAR 0 4
68980: PPUSH
68981: LD_VAR 0 9
68985: PPUSH
68986: CALL_OW 440
68990: NOT
68991: AND
68992: IFFALSE 68996
// exit ;
68994: GO 69004
// result := true ;
68996: LD_ADDR_VAR 0 6
69000: PUSH
69001: LD_INT 1
69003: ST_TO_ADDR
// end ;
69004: LD_VAR 0 6
69008: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
69009: LD_INT 0
69011: PPUSH
69012: PPUSH
69013: PPUSH
69014: PPUSH
69015: PPUSH
69016: PPUSH
69017: PPUSH
69018: PPUSH
69019: PPUSH
69020: PPUSH
69021: PPUSH
69022: PPUSH
69023: PPUSH
69024: PPUSH
69025: PPUSH
69026: PPUSH
69027: PPUSH
69028: PPUSH
69029: PPUSH
69030: PPUSH
69031: PPUSH
69032: PPUSH
69033: PPUSH
69034: PPUSH
69035: PPUSH
69036: PPUSH
69037: PPUSH
69038: PPUSH
69039: PPUSH
69040: PPUSH
69041: PPUSH
69042: PPUSH
69043: PPUSH
69044: PPUSH
69045: PPUSH
69046: PPUSH
69047: PPUSH
69048: PPUSH
69049: PPUSH
69050: PPUSH
69051: PPUSH
69052: PPUSH
69053: PPUSH
69054: PPUSH
69055: PPUSH
69056: PPUSH
69057: PPUSH
69058: PPUSH
69059: PPUSH
69060: PPUSH
69061: PPUSH
69062: PPUSH
69063: PPUSH
69064: PPUSH
69065: PPUSH
69066: PPUSH
69067: PPUSH
69068: PPUSH
// result = [ ] ;
69069: LD_ADDR_VAR 0 7
69073: PUSH
69074: EMPTY
69075: ST_TO_ADDR
// temp_list = [ ] ;
69076: LD_ADDR_VAR 0 9
69080: PUSH
69081: EMPTY
69082: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
69083: LD_VAR 0 4
69087: PUSH
69088: LD_INT 0
69090: PUSH
69091: LD_INT 1
69093: PUSH
69094: LD_INT 2
69096: PUSH
69097: LD_INT 3
69099: PUSH
69100: LD_INT 4
69102: PUSH
69103: LD_INT 5
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: LIST
69110: LIST
69111: LIST
69112: LIST
69113: IN
69114: NOT
69115: IFTRUE 69158
69117: PUSH
69118: LD_VAR 0 1
69122: PUSH
69123: LD_INT 0
69125: PUSH
69126: LD_INT 1
69128: PUSH
69129: EMPTY
69130: LIST
69131: LIST
69132: IN
69133: IFFALSE 69157
69135: PUSH
69136: LD_VAR 0 5
69140: PUSH
69141: LD_INT 1
69143: PUSH
69144: LD_INT 2
69146: PUSH
69147: LD_INT 3
69149: PUSH
69150: EMPTY
69151: LIST
69152: LIST
69153: LIST
69154: IN
69155: NOT
69156: AND
69157: OR
69158: IFFALSE 69162
// exit ;
69160: GO 87561
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
69162: LD_VAR 0 1
69166: PUSH
69167: LD_INT 6
69169: PUSH
69170: LD_INT 7
69172: PUSH
69173: LD_INT 8
69175: PUSH
69176: LD_INT 13
69178: PUSH
69179: LD_INT 12
69181: PUSH
69182: LD_INT 15
69184: PUSH
69185: LD_INT 11
69187: PUSH
69188: LD_INT 14
69190: PUSH
69191: LD_INT 10
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: IN
69205: IFFALSE 69215
// btype = b_lab ;
69207: LD_ADDR_VAR 0 1
69211: PUSH
69212: LD_INT 6
69214: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
69215: LD_VAR 0 6
69219: PUSH
69220: LD_INT 0
69222: PUSH
69223: LD_INT 1
69225: PUSH
69226: LD_INT 2
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: LIST
69233: IN
69234: NOT
69235: IFTRUE 69303
69237: PUSH
69238: LD_VAR 0 1
69242: PUSH
69243: LD_INT 0
69245: PUSH
69246: LD_INT 1
69248: PUSH
69249: LD_INT 2
69251: PUSH
69252: LD_INT 3
69254: PUSH
69255: LD_INT 6
69257: PUSH
69258: LD_INT 36
69260: PUSH
69261: LD_INT 4
69263: PUSH
69264: LD_INT 5
69266: PUSH
69267: LD_INT 31
69269: PUSH
69270: LD_INT 32
69272: PUSH
69273: LD_INT 33
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: LIST
69280: LIST
69281: LIST
69282: LIST
69283: LIST
69284: LIST
69285: LIST
69286: LIST
69287: LIST
69288: IN
69289: NOT
69290: IFFALSE 69302
69292: PUSH
69293: LD_VAR 0 6
69297: PUSH
69298: LD_INT 1
69300: EQUAL
69301: AND
69302: OR
69303: IFTRUE 69335
69305: PUSH
69306: LD_VAR 0 1
69310: PUSH
69311: LD_INT 2
69313: PUSH
69314: LD_INT 3
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: IN
69321: NOT
69322: IFFALSE 69334
69324: PUSH
69325: LD_VAR 0 6
69329: PUSH
69330: LD_INT 2
69332: EQUAL
69333: AND
69334: OR
69335: IFFALSE 69345
// mode = 0 ;
69337: LD_ADDR_VAR 0 6
69341: PUSH
69342: LD_INT 0
69344: ST_TO_ADDR
// case mode of 0 :
69345: LD_VAR 0 6
69349: PUSH
69350: LD_INT 0
69352: DOUBLE
69353: EQUAL
69354: IFTRUE 69358
69356: GO 80811
69358: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
69359: LD_ADDR_VAR 0 11
69363: PUSH
69364: LD_INT 0
69366: PUSH
69367: LD_INT 0
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: LD_INT 0
69376: PUSH
69377: LD_INT 1
69379: NEG
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PUSH
69385: LD_INT 1
69387: PUSH
69388: LD_INT 0
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 1
69397: PUSH
69398: LD_INT 1
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: LD_INT 0
69407: PUSH
69408: LD_INT 1
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: PUSH
69415: LD_INT 1
69417: NEG
69418: PUSH
69419: LD_INT 0
69421: PUSH
69422: EMPTY
69423: LIST
69424: LIST
69425: PUSH
69426: LD_INT 1
69428: NEG
69429: PUSH
69430: LD_INT 1
69432: NEG
69433: PUSH
69434: EMPTY
69435: LIST
69436: LIST
69437: PUSH
69438: LD_INT 1
69440: NEG
69441: PUSH
69442: LD_INT 2
69444: NEG
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 0
69452: PUSH
69453: LD_INT 2
69455: NEG
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: PUSH
69461: LD_INT 1
69463: PUSH
69464: LD_INT 1
69466: NEG
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: LD_INT 1
69474: PUSH
69475: LD_INT 2
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: PUSH
69482: LD_INT 0
69484: PUSH
69485: LD_INT 2
69487: PUSH
69488: EMPTY
69489: LIST
69490: LIST
69491: PUSH
69492: LD_INT 1
69494: NEG
69495: PUSH
69496: LD_INT 1
69498: PUSH
69499: EMPTY
69500: LIST
69501: LIST
69502: PUSH
69503: LD_INT 1
69505: PUSH
69506: LD_INT 3
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 0
69515: PUSH
69516: LD_INT 3
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: LD_INT 1
69525: NEG
69526: PUSH
69527: LD_INT 2
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: LIST
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: LIST
69543: LIST
69544: LIST
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69552: LD_ADDR_VAR 0 12
69556: PUSH
69557: LD_INT 0
69559: PUSH
69560: LD_INT 0
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 0
69569: PUSH
69570: LD_INT 1
69572: NEG
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: LD_INT 1
69580: PUSH
69581: LD_INT 0
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: PUSH
69588: LD_INT 1
69590: PUSH
69591: LD_INT 1
69593: PUSH
69594: EMPTY
69595: LIST
69596: LIST
69597: PUSH
69598: LD_INT 0
69600: PUSH
69601: LD_INT 1
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: LD_INT 1
69610: NEG
69611: PUSH
69612: LD_INT 0
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PUSH
69619: LD_INT 1
69621: NEG
69622: PUSH
69623: LD_INT 1
69625: NEG
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: PUSH
69631: LD_INT 1
69633: PUSH
69634: LD_INT 1
69636: NEG
69637: PUSH
69638: EMPTY
69639: LIST
69640: LIST
69641: PUSH
69642: LD_INT 2
69644: PUSH
69645: LD_INT 0
69647: PUSH
69648: EMPTY
69649: LIST
69650: LIST
69651: PUSH
69652: LD_INT 2
69654: PUSH
69655: LD_INT 1
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: PUSH
69662: LD_INT 1
69664: NEG
69665: PUSH
69666: LD_INT 1
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 2
69675: NEG
69676: PUSH
69677: LD_INT 0
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 2
69686: NEG
69687: PUSH
69688: LD_INT 1
69690: NEG
69691: PUSH
69692: EMPTY
69693: LIST
69694: LIST
69695: PUSH
69696: LD_INT 2
69698: NEG
69699: PUSH
69700: LD_INT 1
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: PUSH
69707: LD_INT 3
69709: NEG
69710: PUSH
69711: LD_INT 0
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 3
69720: NEG
69721: PUSH
69722: LD_INT 1
69724: NEG
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69748: LD_ADDR_VAR 0 13
69752: PUSH
69753: LD_INT 0
69755: PUSH
69756: LD_INT 0
69758: PUSH
69759: EMPTY
69760: LIST
69761: LIST
69762: PUSH
69763: LD_INT 0
69765: PUSH
69766: LD_INT 1
69768: NEG
69769: PUSH
69770: EMPTY
69771: LIST
69772: LIST
69773: PUSH
69774: LD_INT 1
69776: PUSH
69777: LD_INT 0
69779: PUSH
69780: EMPTY
69781: LIST
69782: LIST
69783: PUSH
69784: LD_INT 1
69786: PUSH
69787: LD_INT 1
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 0
69796: PUSH
69797: LD_INT 1
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 1
69806: NEG
69807: PUSH
69808: LD_INT 0
69810: PUSH
69811: EMPTY
69812: LIST
69813: LIST
69814: PUSH
69815: LD_INT 1
69817: NEG
69818: PUSH
69819: LD_INT 1
69821: NEG
69822: PUSH
69823: EMPTY
69824: LIST
69825: LIST
69826: PUSH
69827: LD_INT 1
69829: NEG
69830: PUSH
69831: LD_INT 2
69833: NEG
69834: PUSH
69835: EMPTY
69836: LIST
69837: LIST
69838: PUSH
69839: LD_INT 2
69841: PUSH
69842: LD_INT 1
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: PUSH
69849: LD_INT 2
69851: PUSH
69852: LD_INT 2
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 1
69861: PUSH
69862: LD_INT 2
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 2
69871: NEG
69872: PUSH
69873: LD_INT 1
69875: NEG
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: LD_INT 2
69883: NEG
69884: PUSH
69885: LD_INT 2
69887: NEG
69888: PUSH
69889: EMPTY
69890: LIST
69891: LIST
69892: PUSH
69893: LD_INT 2
69895: NEG
69896: PUSH
69897: LD_INT 3
69899: NEG
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: PUSH
69905: LD_INT 3
69907: NEG
69908: PUSH
69909: LD_INT 2
69911: NEG
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 3
69919: NEG
69920: PUSH
69921: LD_INT 3
69923: NEG
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: LIST
69933: LIST
69934: LIST
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
69947: LD_ADDR_VAR 0 14
69951: PUSH
69952: LD_INT 0
69954: PUSH
69955: LD_INT 0
69957: PUSH
69958: EMPTY
69959: LIST
69960: LIST
69961: PUSH
69962: LD_INT 0
69964: PUSH
69965: LD_INT 1
69967: NEG
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: PUSH
69973: LD_INT 1
69975: PUSH
69976: LD_INT 0
69978: PUSH
69979: EMPTY
69980: LIST
69981: LIST
69982: PUSH
69983: LD_INT 1
69985: PUSH
69986: LD_INT 1
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: LD_INT 0
69995: PUSH
69996: LD_INT 1
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 1
70005: NEG
70006: PUSH
70007: LD_INT 0
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 1
70016: NEG
70017: PUSH
70018: LD_INT 1
70020: NEG
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: PUSH
70026: LD_INT 1
70028: NEG
70029: PUSH
70030: LD_INT 2
70032: NEG
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: PUSH
70038: LD_INT 0
70040: PUSH
70041: LD_INT 2
70043: NEG
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: PUSH
70049: LD_INT 1
70051: PUSH
70052: LD_INT 1
70054: NEG
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: PUSH
70060: LD_INT 1
70062: PUSH
70063: LD_INT 2
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 0
70072: PUSH
70073: LD_INT 2
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: LD_INT 1
70082: NEG
70083: PUSH
70084: LD_INT 1
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 1
70093: NEG
70094: PUSH
70095: LD_INT 3
70097: NEG
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: LD_INT 0
70105: PUSH
70106: LD_INT 3
70108: NEG
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 1
70116: PUSH
70117: LD_INT 2
70119: NEG
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: LIST
70129: LIST
70130: LIST
70131: LIST
70132: LIST
70133: LIST
70134: LIST
70135: LIST
70136: LIST
70137: LIST
70138: LIST
70139: LIST
70140: LIST
70141: LIST
70142: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
70143: LD_ADDR_VAR 0 15
70147: PUSH
70148: LD_INT 0
70150: PUSH
70151: LD_INT 0
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: LD_INT 0
70160: PUSH
70161: LD_INT 1
70163: NEG
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: LD_INT 1
70171: PUSH
70172: LD_INT 0
70174: PUSH
70175: EMPTY
70176: LIST
70177: LIST
70178: PUSH
70179: LD_INT 1
70181: PUSH
70182: LD_INT 1
70184: PUSH
70185: EMPTY
70186: LIST
70187: LIST
70188: PUSH
70189: LD_INT 0
70191: PUSH
70192: LD_INT 1
70194: PUSH
70195: EMPTY
70196: LIST
70197: LIST
70198: PUSH
70199: LD_INT 1
70201: NEG
70202: PUSH
70203: LD_INT 0
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PUSH
70210: LD_INT 1
70212: NEG
70213: PUSH
70214: LD_INT 1
70216: NEG
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 1
70224: PUSH
70225: LD_INT 1
70227: NEG
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 2
70235: PUSH
70236: LD_INT 0
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 2
70245: PUSH
70246: LD_INT 1
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: PUSH
70253: LD_INT 1
70255: NEG
70256: PUSH
70257: LD_INT 1
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 2
70266: NEG
70267: PUSH
70268: LD_INT 0
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 2
70277: NEG
70278: PUSH
70279: LD_INT 1
70281: NEG
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: LD_INT 2
70289: PUSH
70290: LD_INT 1
70292: NEG
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: PUSH
70298: LD_INT 3
70300: PUSH
70301: LD_INT 0
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: PUSH
70308: LD_INT 3
70310: PUSH
70311: LD_INT 1
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: PUSH
70318: EMPTY
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
70336: LD_ADDR_VAR 0 16
70340: PUSH
70341: LD_INT 0
70343: PUSH
70344: LD_INT 0
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: PUSH
70351: LD_INT 0
70353: PUSH
70354: LD_INT 1
70356: NEG
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: PUSH
70362: LD_INT 1
70364: PUSH
70365: LD_INT 0
70367: PUSH
70368: EMPTY
70369: LIST
70370: LIST
70371: PUSH
70372: LD_INT 1
70374: PUSH
70375: LD_INT 1
70377: PUSH
70378: EMPTY
70379: LIST
70380: LIST
70381: PUSH
70382: LD_INT 0
70384: PUSH
70385: LD_INT 1
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 1
70394: NEG
70395: PUSH
70396: LD_INT 0
70398: PUSH
70399: EMPTY
70400: LIST
70401: LIST
70402: PUSH
70403: LD_INT 1
70405: NEG
70406: PUSH
70407: LD_INT 1
70409: NEG
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 1
70417: NEG
70418: PUSH
70419: LD_INT 2
70421: NEG
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: PUSH
70427: LD_INT 2
70429: PUSH
70430: LD_INT 1
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 2
70439: PUSH
70440: LD_INT 2
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 1
70449: PUSH
70450: LD_INT 2
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: PUSH
70457: LD_INT 2
70459: NEG
70460: PUSH
70461: LD_INT 1
70463: NEG
70464: PUSH
70465: EMPTY
70466: LIST
70467: LIST
70468: PUSH
70469: LD_INT 2
70471: NEG
70472: PUSH
70473: LD_INT 2
70475: NEG
70476: PUSH
70477: EMPTY
70478: LIST
70479: LIST
70480: PUSH
70481: LD_INT 3
70483: PUSH
70484: LD_INT 2
70486: PUSH
70487: EMPTY
70488: LIST
70489: LIST
70490: PUSH
70491: LD_INT 3
70493: PUSH
70494: LD_INT 3
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: LD_INT 2
70503: PUSH
70504: LD_INT 3
70506: PUSH
70507: EMPTY
70508: LIST
70509: LIST
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: LIST
70515: LIST
70516: LIST
70517: LIST
70518: LIST
70519: LIST
70520: LIST
70521: LIST
70522: LIST
70523: LIST
70524: LIST
70525: LIST
70526: LIST
70527: LIST
70528: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70529: LD_ADDR_VAR 0 17
70533: PUSH
70534: LD_INT 0
70536: PUSH
70537: LD_INT 0
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 0
70546: PUSH
70547: LD_INT 1
70549: NEG
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 1
70557: PUSH
70558: LD_INT 0
70560: PUSH
70561: EMPTY
70562: LIST
70563: LIST
70564: PUSH
70565: LD_INT 1
70567: PUSH
70568: LD_INT 1
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PUSH
70575: LD_INT 0
70577: PUSH
70578: LD_INT 1
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: PUSH
70585: LD_INT 1
70587: NEG
70588: PUSH
70589: LD_INT 0
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 1
70598: NEG
70599: PUSH
70600: LD_INT 1
70602: NEG
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 1
70610: NEG
70611: PUSH
70612: LD_INT 2
70614: NEG
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: LD_INT 0
70622: PUSH
70623: LD_INT 2
70625: NEG
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PUSH
70631: LD_INT 1
70633: PUSH
70634: LD_INT 1
70636: NEG
70637: PUSH
70638: EMPTY
70639: LIST
70640: LIST
70641: PUSH
70642: LD_INT 2
70644: PUSH
70645: LD_INT 0
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: PUSH
70652: LD_INT 2
70654: PUSH
70655: LD_INT 1
70657: PUSH
70658: EMPTY
70659: LIST
70660: LIST
70661: PUSH
70662: LD_INT 2
70664: PUSH
70665: LD_INT 2
70667: PUSH
70668: EMPTY
70669: LIST
70670: LIST
70671: PUSH
70672: LD_INT 1
70674: PUSH
70675: LD_INT 2
70677: PUSH
70678: EMPTY
70679: LIST
70680: LIST
70681: PUSH
70682: LD_INT 0
70684: PUSH
70685: LD_INT 2
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: LD_INT 1
70694: NEG
70695: PUSH
70696: LD_INT 1
70698: PUSH
70699: EMPTY
70700: LIST
70701: LIST
70702: PUSH
70703: LD_INT 2
70705: NEG
70706: PUSH
70707: LD_INT 0
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 2
70716: NEG
70717: PUSH
70718: LD_INT 1
70720: NEG
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: LD_INT 2
70728: NEG
70729: PUSH
70730: LD_INT 2
70732: NEG
70733: PUSH
70734: EMPTY
70735: LIST
70736: LIST
70737: PUSH
70738: EMPTY
70739: LIST
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70759: LD_ADDR_VAR 0 18
70763: PUSH
70764: LD_INT 0
70766: PUSH
70767: LD_INT 0
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: PUSH
70774: LD_INT 0
70776: PUSH
70777: LD_INT 1
70779: NEG
70780: PUSH
70781: EMPTY
70782: LIST
70783: LIST
70784: PUSH
70785: LD_INT 1
70787: PUSH
70788: LD_INT 0
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PUSH
70795: LD_INT 1
70797: PUSH
70798: LD_INT 1
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: PUSH
70805: LD_INT 0
70807: PUSH
70808: LD_INT 1
70810: PUSH
70811: EMPTY
70812: LIST
70813: LIST
70814: PUSH
70815: LD_INT 1
70817: NEG
70818: PUSH
70819: LD_INT 0
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: PUSH
70826: LD_INT 1
70828: NEG
70829: PUSH
70830: LD_INT 1
70832: NEG
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: PUSH
70838: LD_INT 1
70840: NEG
70841: PUSH
70842: LD_INT 2
70844: NEG
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: PUSH
70850: LD_INT 0
70852: PUSH
70853: LD_INT 2
70855: NEG
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 1
70863: PUSH
70864: LD_INT 1
70866: NEG
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: PUSH
70872: LD_INT 2
70874: PUSH
70875: LD_INT 0
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 2
70884: PUSH
70885: LD_INT 1
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 2
70894: PUSH
70895: LD_INT 2
70897: PUSH
70898: EMPTY
70899: LIST
70900: LIST
70901: PUSH
70902: LD_INT 1
70904: PUSH
70905: LD_INT 2
70907: PUSH
70908: EMPTY
70909: LIST
70910: LIST
70911: PUSH
70912: LD_INT 0
70914: PUSH
70915: LD_INT 2
70917: PUSH
70918: EMPTY
70919: LIST
70920: LIST
70921: PUSH
70922: LD_INT 1
70924: NEG
70925: PUSH
70926: LD_INT 1
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: PUSH
70933: LD_INT 2
70935: NEG
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: LD_INT 2
70946: NEG
70947: PUSH
70948: LD_INT 1
70950: NEG
70951: PUSH
70952: EMPTY
70953: LIST
70954: LIST
70955: PUSH
70956: LD_INT 2
70958: NEG
70959: PUSH
70960: LD_INT 2
70962: NEG
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PUSH
70968: EMPTY
70969: LIST
70970: LIST
70971: LIST
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: LIST
70980: LIST
70981: LIST
70982: LIST
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70989: LD_ADDR_VAR 0 19
70993: PUSH
70994: LD_INT 0
70996: PUSH
70997: LD_INT 0
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: PUSH
71004: LD_INT 0
71006: PUSH
71007: LD_INT 1
71009: NEG
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: PUSH
71015: LD_INT 1
71017: PUSH
71018: LD_INT 0
71020: PUSH
71021: EMPTY
71022: LIST
71023: LIST
71024: PUSH
71025: LD_INT 1
71027: PUSH
71028: LD_INT 1
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: PUSH
71035: LD_INT 0
71037: PUSH
71038: LD_INT 1
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: LD_INT 1
71047: NEG
71048: PUSH
71049: LD_INT 0
71051: PUSH
71052: EMPTY
71053: LIST
71054: LIST
71055: PUSH
71056: LD_INT 1
71058: NEG
71059: PUSH
71060: LD_INT 1
71062: NEG
71063: PUSH
71064: EMPTY
71065: LIST
71066: LIST
71067: PUSH
71068: LD_INT 1
71070: NEG
71071: PUSH
71072: LD_INT 2
71074: NEG
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 0
71082: PUSH
71083: LD_INT 2
71085: NEG
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PUSH
71091: LD_INT 1
71093: PUSH
71094: LD_INT 1
71096: NEG
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: PUSH
71102: LD_INT 2
71104: PUSH
71105: LD_INT 0
71107: PUSH
71108: EMPTY
71109: LIST
71110: LIST
71111: PUSH
71112: LD_INT 2
71114: PUSH
71115: LD_INT 1
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PUSH
71122: LD_INT 2
71124: PUSH
71125: LD_INT 2
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: LD_INT 1
71134: PUSH
71135: LD_INT 2
71137: PUSH
71138: EMPTY
71139: LIST
71140: LIST
71141: PUSH
71142: LD_INT 0
71144: PUSH
71145: LD_INT 2
71147: PUSH
71148: EMPTY
71149: LIST
71150: LIST
71151: PUSH
71152: LD_INT 1
71154: NEG
71155: PUSH
71156: LD_INT 1
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: PUSH
71163: LD_INT 2
71165: NEG
71166: PUSH
71167: LD_INT 0
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PUSH
71174: LD_INT 2
71176: NEG
71177: PUSH
71178: LD_INT 1
71180: NEG
71181: PUSH
71182: EMPTY
71183: LIST
71184: LIST
71185: PUSH
71186: LD_INT 2
71188: NEG
71189: PUSH
71190: LD_INT 2
71192: NEG
71193: PUSH
71194: EMPTY
71195: LIST
71196: LIST
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: LIST
71202: LIST
71203: LIST
71204: LIST
71205: LIST
71206: LIST
71207: LIST
71208: LIST
71209: LIST
71210: LIST
71211: LIST
71212: LIST
71213: LIST
71214: LIST
71215: LIST
71216: LIST
71217: LIST
71218: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71219: LD_ADDR_VAR 0 20
71223: PUSH
71224: LD_INT 0
71226: PUSH
71227: LD_INT 0
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 0
71236: PUSH
71237: LD_INT 1
71239: NEG
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 1
71247: PUSH
71248: LD_INT 0
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 1
71257: PUSH
71258: LD_INT 1
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 0
71267: PUSH
71268: LD_INT 1
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 1
71277: NEG
71278: PUSH
71279: LD_INT 0
71281: PUSH
71282: EMPTY
71283: LIST
71284: LIST
71285: PUSH
71286: LD_INT 1
71288: NEG
71289: PUSH
71290: LD_INT 1
71292: NEG
71293: PUSH
71294: EMPTY
71295: LIST
71296: LIST
71297: PUSH
71298: LD_INT 1
71300: NEG
71301: PUSH
71302: LD_INT 2
71304: NEG
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 0
71312: PUSH
71313: LD_INT 2
71315: NEG
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 1
71323: PUSH
71324: LD_INT 1
71326: NEG
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: PUSH
71332: LD_INT 2
71334: PUSH
71335: LD_INT 0
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: PUSH
71342: LD_INT 2
71344: PUSH
71345: LD_INT 1
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: PUSH
71352: LD_INT 2
71354: PUSH
71355: LD_INT 2
71357: PUSH
71358: EMPTY
71359: LIST
71360: LIST
71361: PUSH
71362: LD_INT 1
71364: PUSH
71365: LD_INT 2
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: PUSH
71372: LD_INT 0
71374: PUSH
71375: LD_INT 2
71377: PUSH
71378: EMPTY
71379: LIST
71380: LIST
71381: PUSH
71382: LD_INT 1
71384: NEG
71385: PUSH
71386: LD_INT 1
71388: PUSH
71389: EMPTY
71390: LIST
71391: LIST
71392: PUSH
71393: LD_INT 2
71395: NEG
71396: PUSH
71397: LD_INT 0
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PUSH
71404: LD_INT 2
71406: NEG
71407: PUSH
71408: LD_INT 1
71410: NEG
71411: PUSH
71412: EMPTY
71413: LIST
71414: LIST
71415: PUSH
71416: LD_INT 2
71418: NEG
71419: PUSH
71420: LD_INT 2
71422: NEG
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: LIST
71444: LIST
71445: LIST
71446: LIST
71447: LIST
71448: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71449: LD_ADDR_VAR 0 21
71453: PUSH
71454: LD_INT 0
71456: PUSH
71457: LD_INT 0
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: LD_INT 0
71466: PUSH
71467: LD_INT 1
71469: NEG
71470: PUSH
71471: EMPTY
71472: LIST
71473: LIST
71474: PUSH
71475: LD_INT 1
71477: PUSH
71478: LD_INT 0
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: PUSH
71485: LD_INT 1
71487: PUSH
71488: LD_INT 1
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PUSH
71495: LD_INT 0
71497: PUSH
71498: LD_INT 1
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PUSH
71505: LD_INT 1
71507: NEG
71508: PUSH
71509: LD_INT 0
71511: PUSH
71512: EMPTY
71513: LIST
71514: LIST
71515: PUSH
71516: LD_INT 1
71518: NEG
71519: PUSH
71520: LD_INT 1
71522: NEG
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: PUSH
71528: LD_INT 1
71530: NEG
71531: PUSH
71532: LD_INT 2
71534: NEG
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PUSH
71540: LD_INT 0
71542: PUSH
71543: LD_INT 2
71545: NEG
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PUSH
71551: LD_INT 1
71553: PUSH
71554: LD_INT 1
71556: NEG
71557: PUSH
71558: EMPTY
71559: LIST
71560: LIST
71561: PUSH
71562: LD_INT 2
71564: PUSH
71565: LD_INT 0
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: PUSH
71572: LD_INT 2
71574: PUSH
71575: LD_INT 1
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: PUSH
71582: LD_INT 2
71584: PUSH
71585: LD_INT 2
71587: PUSH
71588: EMPTY
71589: LIST
71590: LIST
71591: PUSH
71592: LD_INT 1
71594: PUSH
71595: LD_INT 2
71597: PUSH
71598: EMPTY
71599: LIST
71600: LIST
71601: PUSH
71602: LD_INT 0
71604: PUSH
71605: LD_INT 2
71607: PUSH
71608: EMPTY
71609: LIST
71610: LIST
71611: PUSH
71612: LD_INT 1
71614: NEG
71615: PUSH
71616: LD_INT 1
71618: PUSH
71619: EMPTY
71620: LIST
71621: LIST
71622: PUSH
71623: LD_INT 2
71625: NEG
71626: PUSH
71627: LD_INT 0
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: PUSH
71634: LD_INT 2
71636: NEG
71637: PUSH
71638: LD_INT 1
71640: NEG
71641: PUSH
71642: EMPTY
71643: LIST
71644: LIST
71645: PUSH
71646: LD_INT 2
71648: NEG
71649: PUSH
71650: LD_INT 2
71652: NEG
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: LIST
71662: LIST
71663: LIST
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: LIST
71669: LIST
71670: LIST
71671: LIST
71672: LIST
71673: LIST
71674: LIST
71675: LIST
71676: LIST
71677: LIST
71678: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71679: LD_ADDR_VAR 0 22
71683: PUSH
71684: LD_INT 0
71686: PUSH
71687: LD_INT 0
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: LD_INT 0
71696: PUSH
71697: LD_INT 1
71699: NEG
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PUSH
71705: LD_INT 1
71707: PUSH
71708: LD_INT 0
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: LD_INT 1
71717: PUSH
71718: LD_INT 1
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: PUSH
71725: LD_INT 0
71727: PUSH
71728: LD_INT 1
71730: PUSH
71731: EMPTY
71732: LIST
71733: LIST
71734: PUSH
71735: LD_INT 1
71737: NEG
71738: PUSH
71739: LD_INT 0
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: PUSH
71746: LD_INT 1
71748: NEG
71749: PUSH
71750: LD_INT 1
71752: NEG
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: LD_INT 1
71760: NEG
71761: PUSH
71762: LD_INT 2
71764: NEG
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: PUSH
71770: LD_INT 0
71772: PUSH
71773: LD_INT 2
71775: NEG
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: LD_INT 1
71783: PUSH
71784: LD_INT 1
71786: NEG
71787: PUSH
71788: EMPTY
71789: LIST
71790: LIST
71791: PUSH
71792: LD_INT 2
71794: PUSH
71795: LD_INT 0
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: PUSH
71802: LD_INT 2
71804: PUSH
71805: LD_INT 1
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 2
71814: PUSH
71815: LD_INT 2
71817: PUSH
71818: EMPTY
71819: LIST
71820: LIST
71821: PUSH
71822: LD_INT 1
71824: PUSH
71825: LD_INT 2
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PUSH
71832: LD_INT 0
71834: PUSH
71835: LD_INT 2
71837: PUSH
71838: EMPTY
71839: LIST
71840: LIST
71841: PUSH
71842: LD_INT 1
71844: NEG
71845: PUSH
71846: LD_INT 1
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 2
71855: NEG
71856: PUSH
71857: LD_INT 0
71859: PUSH
71860: EMPTY
71861: LIST
71862: LIST
71863: PUSH
71864: LD_INT 2
71866: NEG
71867: PUSH
71868: LD_INT 1
71870: NEG
71871: PUSH
71872: EMPTY
71873: LIST
71874: LIST
71875: PUSH
71876: LD_INT 2
71878: NEG
71879: PUSH
71880: LD_INT 2
71882: NEG
71883: PUSH
71884: EMPTY
71885: LIST
71886: LIST
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: LIST
71892: LIST
71893: LIST
71894: LIST
71895: LIST
71896: LIST
71897: LIST
71898: LIST
71899: LIST
71900: LIST
71901: LIST
71902: LIST
71903: LIST
71904: LIST
71905: LIST
71906: LIST
71907: LIST
71908: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
71909: LD_ADDR_VAR 0 23
71913: PUSH
71914: LD_INT 0
71916: PUSH
71917: LD_INT 0
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: PUSH
71924: LD_INT 0
71926: PUSH
71927: LD_INT 1
71929: NEG
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: LD_INT 1
71937: PUSH
71938: LD_INT 0
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: PUSH
71945: LD_INT 1
71947: PUSH
71948: LD_INT 1
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 0
71957: PUSH
71958: LD_INT 1
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: PUSH
71965: LD_INT 1
71967: NEG
71968: PUSH
71969: LD_INT 0
71971: PUSH
71972: EMPTY
71973: LIST
71974: LIST
71975: PUSH
71976: LD_INT 1
71978: NEG
71979: PUSH
71980: LD_INT 1
71982: NEG
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 1
71990: NEG
71991: PUSH
71992: LD_INT 2
71994: NEG
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 0
72002: PUSH
72003: LD_INT 2
72005: NEG
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 1
72013: PUSH
72014: LD_INT 1
72016: NEG
72017: PUSH
72018: EMPTY
72019: LIST
72020: LIST
72021: PUSH
72022: LD_INT 2
72024: PUSH
72025: LD_INT 0
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PUSH
72032: LD_INT 2
72034: PUSH
72035: LD_INT 1
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: PUSH
72042: LD_INT 2
72044: PUSH
72045: LD_INT 2
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: PUSH
72052: LD_INT 1
72054: PUSH
72055: LD_INT 2
72057: PUSH
72058: EMPTY
72059: LIST
72060: LIST
72061: PUSH
72062: LD_INT 0
72064: PUSH
72065: LD_INT 2
72067: PUSH
72068: EMPTY
72069: LIST
72070: LIST
72071: PUSH
72072: LD_INT 1
72074: NEG
72075: PUSH
72076: LD_INT 1
72078: PUSH
72079: EMPTY
72080: LIST
72081: LIST
72082: PUSH
72083: LD_INT 2
72085: NEG
72086: PUSH
72087: LD_INT 0
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: PUSH
72094: LD_INT 2
72096: NEG
72097: PUSH
72098: LD_INT 1
72100: NEG
72101: PUSH
72102: EMPTY
72103: LIST
72104: LIST
72105: PUSH
72106: LD_INT 2
72108: NEG
72109: PUSH
72110: LD_INT 2
72112: NEG
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: PUSH
72118: LD_INT 2
72120: NEG
72121: PUSH
72122: LD_INT 3
72124: NEG
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PUSH
72130: LD_INT 1
72132: NEG
72133: PUSH
72134: LD_INT 3
72136: NEG
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: PUSH
72142: LD_INT 1
72144: PUSH
72145: LD_INT 2
72147: NEG
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: PUSH
72153: LD_INT 2
72155: PUSH
72156: LD_INT 1
72158: NEG
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: LIST
72168: LIST
72169: LIST
72170: LIST
72171: LIST
72172: LIST
72173: LIST
72174: LIST
72175: LIST
72176: LIST
72177: LIST
72178: LIST
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: LIST
72184: LIST
72185: LIST
72186: LIST
72187: LIST
72188: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
72189: LD_ADDR_VAR 0 24
72193: PUSH
72194: LD_INT 0
72196: PUSH
72197: LD_INT 0
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: LD_INT 0
72206: PUSH
72207: LD_INT 1
72209: NEG
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 1
72217: PUSH
72218: LD_INT 0
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 1
72227: PUSH
72228: LD_INT 1
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 0
72237: PUSH
72238: LD_INT 1
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 1
72247: NEG
72248: PUSH
72249: LD_INT 0
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: PUSH
72256: LD_INT 1
72258: NEG
72259: PUSH
72260: LD_INT 1
72262: NEG
72263: PUSH
72264: EMPTY
72265: LIST
72266: LIST
72267: PUSH
72268: LD_INT 1
72270: NEG
72271: PUSH
72272: LD_INT 2
72274: NEG
72275: PUSH
72276: EMPTY
72277: LIST
72278: LIST
72279: PUSH
72280: LD_INT 0
72282: PUSH
72283: LD_INT 2
72285: NEG
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: PUSH
72291: LD_INT 1
72293: PUSH
72294: LD_INT 1
72296: NEG
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 2
72304: PUSH
72305: LD_INT 0
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 2
72314: PUSH
72315: LD_INT 1
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 2
72324: PUSH
72325: LD_INT 2
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: PUSH
72332: LD_INT 1
72334: PUSH
72335: LD_INT 2
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: PUSH
72342: LD_INT 0
72344: PUSH
72345: LD_INT 2
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: PUSH
72352: LD_INT 1
72354: NEG
72355: PUSH
72356: LD_INT 1
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: PUSH
72363: LD_INT 2
72365: NEG
72366: PUSH
72367: LD_INT 0
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: PUSH
72374: LD_INT 2
72376: NEG
72377: PUSH
72378: LD_INT 1
72380: NEG
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PUSH
72386: LD_INT 2
72388: NEG
72389: PUSH
72390: LD_INT 2
72392: NEG
72393: PUSH
72394: EMPTY
72395: LIST
72396: LIST
72397: PUSH
72398: LD_INT 1
72400: PUSH
72401: LD_INT 2
72403: NEG
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 2
72411: PUSH
72412: LD_INT 1
72414: NEG
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PUSH
72420: LD_INT 3
72422: PUSH
72423: LD_INT 1
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 3
72432: PUSH
72433: LD_INT 2
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: LIST
72444: LIST
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: LIST
72450: LIST
72451: LIST
72452: LIST
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
72465: LD_ADDR_VAR 0 25
72469: PUSH
72470: LD_INT 0
72472: PUSH
72473: LD_INT 0
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PUSH
72480: LD_INT 0
72482: PUSH
72483: LD_INT 1
72485: NEG
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: PUSH
72491: LD_INT 1
72493: PUSH
72494: LD_INT 0
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 1
72503: PUSH
72504: LD_INT 1
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: LD_INT 0
72513: PUSH
72514: LD_INT 1
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: PUSH
72521: LD_INT 1
72523: NEG
72524: PUSH
72525: LD_INT 0
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: PUSH
72532: LD_INT 1
72534: NEG
72535: PUSH
72536: LD_INT 1
72538: NEG
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 1
72546: NEG
72547: PUSH
72548: LD_INT 2
72550: NEG
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: PUSH
72556: LD_INT 0
72558: PUSH
72559: LD_INT 2
72561: NEG
72562: PUSH
72563: EMPTY
72564: LIST
72565: LIST
72566: PUSH
72567: LD_INT 1
72569: PUSH
72570: LD_INT 1
72572: NEG
72573: PUSH
72574: EMPTY
72575: LIST
72576: LIST
72577: PUSH
72578: LD_INT 2
72580: PUSH
72581: LD_INT 0
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PUSH
72588: LD_INT 2
72590: PUSH
72591: LD_INT 1
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: PUSH
72598: LD_INT 2
72600: PUSH
72601: LD_INT 2
72603: PUSH
72604: EMPTY
72605: LIST
72606: LIST
72607: PUSH
72608: LD_INT 1
72610: PUSH
72611: LD_INT 2
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: PUSH
72618: LD_INT 0
72620: PUSH
72621: LD_INT 2
72623: PUSH
72624: EMPTY
72625: LIST
72626: LIST
72627: PUSH
72628: LD_INT 1
72630: NEG
72631: PUSH
72632: LD_INT 1
72634: PUSH
72635: EMPTY
72636: LIST
72637: LIST
72638: PUSH
72639: LD_INT 2
72641: NEG
72642: PUSH
72643: LD_INT 0
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 2
72652: NEG
72653: PUSH
72654: LD_INT 1
72656: NEG
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 2
72664: NEG
72665: PUSH
72666: LD_INT 2
72668: NEG
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PUSH
72674: LD_INT 3
72676: PUSH
72677: LD_INT 1
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: PUSH
72684: LD_INT 3
72686: PUSH
72687: LD_INT 2
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 2
72696: PUSH
72697: LD_INT 3
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PUSH
72704: LD_INT 1
72706: PUSH
72707: LD_INT 3
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PUSH
72714: EMPTY
72715: LIST
72716: LIST
72717: LIST
72718: LIST
72719: LIST
72720: LIST
72721: LIST
72722: LIST
72723: LIST
72724: LIST
72725: LIST
72726: LIST
72727: LIST
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: LIST
72733: LIST
72734: LIST
72735: LIST
72736: LIST
72737: LIST
72738: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
72739: LD_ADDR_VAR 0 26
72743: PUSH
72744: LD_INT 0
72746: PUSH
72747: LD_INT 0
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: PUSH
72754: LD_INT 0
72756: PUSH
72757: LD_INT 1
72759: NEG
72760: PUSH
72761: EMPTY
72762: LIST
72763: LIST
72764: PUSH
72765: LD_INT 1
72767: PUSH
72768: LD_INT 0
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: PUSH
72775: LD_INT 1
72777: PUSH
72778: LD_INT 1
72780: PUSH
72781: EMPTY
72782: LIST
72783: LIST
72784: PUSH
72785: LD_INT 0
72787: PUSH
72788: LD_INT 1
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: PUSH
72795: LD_INT 1
72797: NEG
72798: PUSH
72799: LD_INT 0
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 1
72808: NEG
72809: PUSH
72810: LD_INT 1
72812: NEG
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: PUSH
72818: LD_INT 1
72820: NEG
72821: PUSH
72822: LD_INT 2
72824: NEG
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PUSH
72830: LD_INT 0
72832: PUSH
72833: LD_INT 2
72835: NEG
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: PUSH
72841: LD_INT 1
72843: PUSH
72844: LD_INT 1
72846: NEG
72847: PUSH
72848: EMPTY
72849: LIST
72850: LIST
72851: PUSH
72852: LD_INT 2
72854: PUSH
72855: LD_INT 0
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 2
72864: PUSH
72865: LD_INT 1
72867: PUSH
72868: EMPTY
72869: LIST
72870: LIST
72871: PUSH
72872: LD_INT 2
72874: PUSH
72875: LD_INT 2
72877: PUSH
72878: EMPTY
72879: LIST
72880: LIST
72881: PUSH
72882: LD_INT 1
72884: PUSH
72885: LD_INT 2
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: LD_INT 0
72894: PUSH
72895: LD_INT 2
72897: PUSH
72898: EMPTY
72899: LIST
72900: LIST
72901: PUSH
72902: LD_INT 1
72904: NEG
72905: PUSH
72906: LD_INT 1
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: LD_INT 2
72915: NEG
72916: PUSH
72917: LD_INT 0
72919: PUSH
72920: EMPTY
72921: LIST
72922: LIST
72923: PUSH
72924: LD_INT 2
72926: NEG
72927: PUSH
72928: LD_INT 1
72930: NEG
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 2
72938: NEG
72939: PUSH
72940: LD_INT 2
72942: NEG
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: LD_INT 2
72950: PUSH
72951: LD_INT 3
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: LD_INT 1
72960: PUSH
72961: LD_INT 3
72963: PUSH
72964: EMPTY
72965: LIST
72966: LIST
72967: PUSH
72968: LD_INT 1
72970: NEG
72971: PUSH
72972: LD_INT 2
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 2
72981: NEG
72982: PUSH
72983: LD_INT 1
72985: PUSH
72986: EMPTY
72987: LIST
72988: LIST
72989: PUSH
72990: EMPTY
72991: LIST
72992: LIST
72993: LIST
72994: LIST
72995: LIST
72996: LIST
72997: LIST
72998: LIST
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: LIST
73013: LIST
73014: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
73015: LD_ADDR_VAR 0 27
73019: PUSH
73020: LD_INT 0
73022: PUSH
73023: LD_INT 0
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: LD_INT 0
73032: PUSH
73033: LD_INT 1
73035: NEG
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: LD_INT 1
73043: PUSH
73044: LD_INT 0
73046: PUSH
73047: EMPTY
73048: LIST
73049: LIST
73050: PUSH
73051: LD_INT 1
73053: PUSH
73054: LD_INT 1
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: PUSH
73061: LD_INT 0
73063: PUSH
73064: LD_INT 1
73066: PUSH
73067: EMPTY
73068: LIST
73069: LIST
73070: PUSH
73071: LD_INT 1
73073: NEG
73074: PUSH
73075: LD_INT 0
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: LD_INT 1
73084: NEG
73085: PUSH
73086: LD_INT 1
73088: NEG
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 1
73096: NEG
73097: PUSH
73098: LD_INT 2
73100: NEG
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: PUSH
73106: LD_INT 0
73108: PUSH
73109: LD_INT 2
73111: NEG
73112: PUSH
73113: EMPTY
73114: LIST
73115: LIST
73116: PUSH
73117: LD_INT 1
73119: PUSH
73120: LD_INT 1
73122: NEG
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: LD_INT 2
73130: PUSH
73131: LD_INT 0
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: PUSH
73138: LD_INT 2
73140: PUSH
73141: LD_INT 1
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 2
73150: PUSH
73151: LD_INT 2
73153: PUSH
73154: EMPTY
73155: LIST
73156: LIST
73157: PUSH
73158: LD_INT 1
73160: PUSH
73161: LD_INT 2
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 0
73170: PUSH
73171: LD_INT 2
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 1
73180: NEG
73181: PUSH
73182: LD_INT 1
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 2
73191: NEG
73192: PUSH
73193: LD_INT 0
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: PUSH
73200: LD_INT 2
73202: NEG
73203: PUSH
73204: LD_INT 1
73206: NEG
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 2
73214: NEG
73215: PUSH
73216: LD_INT 2
73218: NEG
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 1
73226: NEG
73227: PUSH
73228: LD_INT 2
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: PUSH
73235: LD_INT 2
73237: NEG
73238: PUSH
73239: LD_INT 1
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 3
73248: NEG
73249: PUSH
73250: LD_INT 1
73252: NEG
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: LD_INT 3
73260: NEG
73261: PUSH
73262: LD_INT 2
73264: NEG
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: PUSH
73270: EMPTY
73271: LIST
73272: LIST
73273: LIST
73274: LIST
73275: LIST
73276: LIST
73277: LIST
73278: LIST
73279: LIST
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
73295: LD_ADDR_VAR 0 28
73299: PUSH
73300: LD_INT 0
73302: PUSH
73303: LD_INT 0
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: LD_INT 0
73312: PUSH
73313: LD_INT 1
73315: NEG
73316: PUSH
73317: EMPTY
73318: LIST
73319: LIST
73320: PUSH
73321: LD_INT 1
73323: PUSH
73324: LD_INT 0
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: PUSH
73331: LD_INT 1
73333: PUSH
73334: LD_INT 1
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: PUSH
73341: LD_INT 0
73343: PUSH
73344: LD_INT 1
73346: PUSH
73347: EMPTY
73348: LIST
73349: LIST
73350: PUSH
73351: LD_INT 1
73353: NEG
73354: PUSH
73355: LD_INT 0
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: LD_INT 1
73364: NEG
73365: PUSH
73366: LD_INT 1
73368: NEG
73369: PUSH
73370: EMPTY
73371: LIST
73372: LIST
73373: PUSH
73374: LD_INT 1
73376: NEG
73377: PUSH
73378: LD_INT 2
73380: NEG
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: LD_INT 0
73388: PUSH
73389: LD_INT 2
73391: NEG
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: PUSH
73397: LD_INT 1
73399: PUSH
73400: LD_INT 1
73402: NEG
73403: PUSH
73404: EMPTY
73405: LIST
73406: LIST
73407: PUSH
73408: LD_INT 2
73410: PUSH
73411: LD_INT 0
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: LD_INT 2
73420: PUSH
73421: LD_INT 1
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 2
73430: PUSH
73431: LD_INT 2
73433: PUSH
73434: EMPTY
73435: LIST
73436: LIST
73437: PUSH
73438: LD_INT 1
73440: PUSH
73441: LD_INT 2
73443: PUSH
73444: EMPTY
73445: LIST
73446: LIST
73447: PUSH
73448: LD_INT 0
73450: PUSH
73451: LD_INT 2
73453: PUSH
73454: EMPTY
73455: LIST
73456: LIST
73457: PUSH
73458: LD_INT 1
73460: NEG
73461: PUSH
73462: LD_INT 1
73464: PUSH
73465: EMPTY
73466: LIST
73467: LIST
73468: PUSH
73469: LD_INT 2
73471: NEG
73472: PUSH
73473: LD_INT 0
73475: PUSH
73476: EMPTY
73477: LIST
73478: LIST
73479: PUSH
73480: LD_INT 2
73482: NEG
73483: PUSH
73484: LD_INT 1
73486: NEG
73487: PUSH
73488: EMPTY
73489: LIST
73490: LIST
73491: PUSH
73492: LD_INT 2
73494: NEG
73495: PUSH
73496: LD_INT 2
73498: NEG
73499: PUSH
73500: EMPTY
73501: LIST
73502: LIST
73503: PUSH
73504: LD_INT 2
73506: NEG
73507: PUSH
73508: LD_INT 3
73510: NEG
73511: PUSH
73512: EMPTY
73513: LIST
73514: LIST
73515: PUSH
73516: LD_INT 1
73518: NEG
73519: PUSH
73520: LD_INT 3
73522: NEG
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: LD_INT 3
73530: NEG
73531: PUSH
73532: LD_INT 1
73534: NEG
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: PUSH
73540: LD_INT 3
73542: NEG
73543: PUSH
73544: LD_INT 2
73546: NEG
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73577: LD_ADDR_VAR 0 29
73581: PUSH
73582: LD_INT 0
73584: PUSH
73585: LD_INT 0
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: PUSH
73592: LD_INT 0
73594: PUSH
73595: LD_INT 1
73597: NEG
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: PUSH
73603: LD_INT 1
73605: PUSH
73606: LD_INT 0
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: PUSH
73613: LD_INT 1
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: EMPTY
73620: LIST
73621: LIST
73622: PUSH
73623: LD_INT 0
73625: PUSH
73626: LD_INT 1
73628: PUSH
73629: EMPTY
73630: LIST
73631: LIST
73632: PUSH
73633: LD_INT 1
73635: NEG
73636: PUSH
73637: LD_INT 0
73639: PUSH
73640: EMPTY
73641: LIST
73642: LIST
73643: PUSH
73644: LD_INT 1
73646: NEG
73647: PUSH
73648: LD_INT 1
73650: NEG
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: PUSH
73656: LD_INT 1
73658: NEG
73659: PUSH
73660: LD_INT 2
73662: NEG
73663: PUSH
73664: EMPTY
73665: LIST
73666: LIST
73667: PUSH
73668: LD_INT 0
73670: PUSH
73671: LD_INT 2
73673: NEG
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: LD_INT 1
73681: PUSH
73682: LD_INT 1
73684: NEG
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 2
73692: PUSH
73693: LD_INT 0
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 2
73702: PUSH
73703: LD_INT 1
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 1
73712: PUSH
73713: LD_INT 2
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 0
73722: PUSH
73723: LD_INT 2
73725: PUSH
73726: EMPTY
73727: LIST
73728: LIST
73729: PUSH
73730: LD_INT 1
73732: NEG
73733: PUSH
73734: LD_INT 1
73736: PUSH
73737: EMPTY
73738: LIST
73739: LIST
73740: PUSH
73741: LD_INT 2
73743: NEG
73744: PUSH
73745: LD_INT 1
73747: NEG
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 2
73755: NEG
73756: PUSH
73757: LD_INT 2
73759: NEG
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: LD_INT 2
73767: NEG
73768: PUSH
73769: LD_INT 3
73771: NEG
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 2
73779: PUSH
73780: LD_INT 1
73782: NEG
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 3
73790: PUSH
73791: LD_INT 1
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PUSH
73798: LD_INT 1
73800: PUSH
73801: LD_INT 3
73803: PUSH
73804: EMPTY
73805: LIST
73806: LIST
73807: PUSH
73808: LD_INT 1
73810: NEG
73811: PUSH
73812: LD_INT 2
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: PUSH
73819: LD_INT 3
73821: NEG
73822: PUSH
73823: LD_INT 2
73825: NEG
73826: PUSH
73827: EMPTY
73828: LIST
73829: LIST
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: LIST
73835: LIST
73836: LIST
73837: LIST
73838: LIST
73839: LIST
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: LIST
73846: LIST
73847: LIST
73848: LIST
73849: LIST
73850: LIST
73851: LIST
73852: LIST
73853: LIST
73854: LIST
73855: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73856: LD_ADDR_VAR 0 30
73860: PUSH
73861: LD_INT 0
73863: PUSH
73864: LD_INT 0
73866: PUSH
73867: EMPTY
73868: LIST
73869: LIST
73870: PUSH
73871: LD_INT 0
73873: PUSH
73874: LD_INT 1
73876: NEG
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 1
73884: PUSH
73885: LD_INT 0
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 1
73894: PUSH
73895: LD_INT 1
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 0
73904: PUSH
73905: LD_INT 1
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: LD_INT 1
73914: NEG
73915: PUSH
73916: LD_INT 0
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 1
73925: NEG
73926: PUSH
73927: LD_INT 1
73929: NEG
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 1
73937: NEG
73938: PUSH
73939: LD_INT 2
73941: NEG
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 0
73949: PUSH
73950: LD_INT 2
73952: NEG
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: LD_INT 1
73960: PUSH
73961: LD_INT 1
73963: NEG
73964: PUSH
73965: EMPTY
73966: LIST
73967: LIST
73968: PUSH
73969: LD_INT 2
73971: PUSH
73972: LD_INT 0
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PUSH
73979: LD_INT 2
73981: PUSH
73982: LD_INT 1
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 2
73991: PUSH
73992: LD_INT 2
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: PUSH
73999: LD_INT 1
74001: PUSH
74002: LD_INT 2
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 1
74011: NEG
74012: PUSH
74013: LD_INT 1
74015: PUSH
74016: EMPTY
74017: LIST
74018: LIST
74019: PUSH
74020: LD_INT 2
74022: NEG
74023: PUSH
74024: LD_INT 0
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 2
74033: NEG
74034: PUSH
74035: LD_INT 1
74037: NEG
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PUSH
74043: LD_INT 1
74045: NEG
74046: PUSH
74047: LD_INT 3
74049: NEG
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: PUSH
74055: LD_INT 1
74057: PUSH
74058: LD_INT 2
74060: NEG
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: LD_INT 3
74068: PUSH
74069: LD_INT 2
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 2
74078: PUSH
74079: LD_INT 3
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: PUSH
74086: LD_INT 2
74088: NEG
74089: PUSH
74090: LD_INT 1
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: PUSH
74097: LD_INT 3
74099: NEG
74100: PUSH
74101: LD_INT 1
74103: NEG
74104: PUSH
74105: EMPTY
74106: LIST
74107: LIST
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: LIST
74113: LIST
74114: LIST
74115: LIST
74116: LIST
74117: LIST
74118: LIST
74119: LIST
74120: LIST
74121: LIST
74122: LIST
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: LIST
74128: LIST
74129: LIST
74130: LIST
74131: LIST
74132: LIST
74133: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
74134: LD_ADDR_VAR 0 31
74138: PUSH
74139: LD_INT 0
74141: PUSH
74142: LD_INT 0
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 0
74151: PUSH
74152: LD_INT 1
74154: NEG
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 1
74162: PUSH
74163: LD_INT 0
74165: PUSH
74166: EMPTY
74167: LIST
74168: LIST
74169: PUSH
74170: LD_INT 1
74172: PUSH
74173: LD_INT 1
74175: PUSH
74176: EMPTY
74177: LIST
74178: LIST
74179: PUSH
74180: LD_INT 0
74182: PUSH
74183: LD_INT 1
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PUSH
74190: LD_INT 1
74192: NEG
74193: PUSH
74194: LD_INT 0
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PUSH
74201: LD_INT 1
74203: NEG
74204: PUSH
74205: LD_INT 1
74207: NEG
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 1
74215: NEG
74216: PUSH
74217: LD_INT 2
74219: NEG
74220: PUSH
74221: EMPTY
74222: LIST
74223: LIST
74224: PUSH
74225: LD_INT 1
74227: PUSH
74228: LD_INT 1
74230: NEG
74231: PUSH
74232: EMPTY
74233: LIST
74234: LIST
74235: PUSH
74236: LD_INT 2
74238: PUSH
74239: LD_INT 0
74241: PUSH
74242: EMPTY
74243: LIST
74244: LIST
74245: PUSH
74246: LD_INT 2
74248: PUSH
74249: LD_INT 1
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PUSH
74256: LD_INT 2
74258: PUSH
74259: LD_INT 2
74261: PUSH
74262: EMPTY
74263: LIST
74264: LIST
74265: PUSH
74266: LD_INT 1
74268: PUSH
74269: LD_INT 2
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: PUSH
74276: LD_INT 0
74278: PUSH
74279: LD_INT 2
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 1
74288: NEG
74289: PUSH
74290: LD_INT 1
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PUSH
74297: LD_INT 2
74299: NEG
74300: PUSH
74301: LD_INT 1
74303: NEG
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: LD_INT 2
74311: NEG
74312: PUSH
74313: LD_INT 2
74315: NEG
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 2
74323: NEG
74324: PUSH
74325: LD_INT 3
74327: NEG
74328: PUSH
74329: EMPTY
74330: LIST
74331: LIST
74332: PUSH
74333: LD_INT 2
74335: PUSH
74336: LD_INT 1
74338: NEG
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: PUSH
74344: LD_INT 3
74346: PUSH
74347: LD_INT 1
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: PUSH
74354: LD_INT 1
74356: PUSH
74357: LD_INT 3
74359: PUSH
74360: EMPTY
74361: LIST
74362: LIST
74363: PUSH
74364: LD_INT 1
74366: NEG
74367: PUSH
74368: LD_INT 2
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: LD_INT 3
74377: NEG
74378: PUSH
74379: LD_INT 2
74381: NEG
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: LIST
74391: LIST
74392: LIST
74393: LIST
74394: LIST
74395: LIST
74396: LIST
74397: LIST
74398: LIST
74399: LIST
74400: LIST
74401: LIST
74402: LIST
74403: LIST
74404: LIST
74405: LIST
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74412: LD_ADDR_VAR 0 32
74416: PUSH
74417: LD_INT 0
74419: PUSH
74420: LD_INT 0
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: PUSH
74427: LD_INT 0
74429: PUSH
74430: LD_INT 1
74432: NEG
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 1
74440: PUSH
74441: LD_INT 0
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PUSH
74448: LD_INT 1
74450: PUSH
74451: LD_INT 1
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: PUSH
74458: LD_INT 0
74460: PUSH
74461: LD_INT 1
74463: PUSH
74464: EMPTY
74465: LIST
74466: LIST
74467: PUSH
74468: LD_INT 1
74470: NEG
74471: PUSH
74472: LD_INT 0
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: PUSH
74479: LD_INT 1
74481: NEG
74482: PUSH
74483: LD_INT 1
74485: NEG
74486: PUSH
74487: EMPTY
74488: LIST
74489: LIST
74490: PUSH
74491: LD_INT 1
74493: NEG
74494: PUSH
74495: LD_INT 2
74497: NEG
74498: PUSH
74499: EMPTY
74500: LIST
74501: LIST
74502: PUSH
74503: LD_INT 0
74505: PUSH
74506: LD_INT 2
74508: NEG
74509: PUSH
74510: EMPTY
74511: LIST
74512: LIST
74513: PUSH
74514: LD_INT 1
74516: PUSH
74517: LD_INT 1
74519: NEG
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: LD_INT 2
74527: PUSH
74528: LD_INT 1
74530: PUSH
74531: EMPTY
74532: LIST
74533: LIST
74534: PUSH
74535: LD_INT 2
74537: PUSH
74538: LD_INT 2
74540: PUSH
74541: EMPTY
74542: LIST
74543: LIST
74544: PUSH
74545: LD_INT 1
74547: PUSH
74548: LD_INT 2
74550: PUSH
74551: EMPTY
74552: LIST
74553: LIST
74554: PUSH
74555: LD_INT 0
74557: PUSH
74558: LD_INT 2
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: LD_INT 1
74567: NEG
74568: PUSH
74569: LD_INT 1
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: LD_INT 2
74578: NEG
74579: PUSH
74580: LD_INT 0
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: LD_INT 2
74589: NEG
74590: PUSH
74591: LD_INT 1
74593: NEG
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: PUSH
74599: LD_INT 1
74601: NEG
74602: PUSH
74603: LD_INT 3
74605: NEG
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: PUSH
74611: LD_INT 1
74613: PUSH
74614: LD_INT 2
74616: NEG
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 3
74624: PUSH
74625: LD_INT 2
74627: PUSH
74628: EMPTY
74629: LIST
74630: LIST
74631: PUSH
74632: LD_INT 2
74634: PUSH
74635: LD_INT 3
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: PUSH
74642: LD_INT 2
74644: NEG
74645: PUSH
74646: LD_INT 1
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 3
74655: NEG
74656: PUSH
74657: LD_INT 1
74659: NEG
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: LIST
74669: LIST
74670: LIST
74671: LIST
74672: LIST
74673: LIST
74674: LIST
74675: LIST
74676: LIST
74677: LIST
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: LIST
74683: LIST
74684: LIST
74685: LIST
74686: LIST
74687: LIST
74688: LIST
74689: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
74690: LD_ADDR_VAR 0 33
74694: PUSH
74695: LD_INT 0
74697: PUSH
74698: LD_INT 0
74700: PUSH
74701: EMPTY
74702: LIST
74703: LIST
74704: PUSH
74705: LD_INT 0
74707: PUSH
74708: LD_INT 1
74710: NEG
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: PUSH
74716: LD_INT 1
74718: PUSH
74719: LD_INT 0
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: PUSH
74726: LD_INT 1
74728: PUSH
74729: LD_INT 1
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: LD_INT 0
74738: PUSH
74739: LD_INT 1
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: PUSH
74746: LD_INT 1
74748: NEG
74749: PUSH
74750: LD_INT 0
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PUSH
74757: LD_INT 1
74759: NEG
74760: PUSH
74761: LD_INT 1
74763: NEG
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: LD_INT 1
74771: NEG
74772: PUSH
74773: LD_INT 2
74775: NEG
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: PUSH
74781: LD_INT 1
74783: PUSH
74784: LD_INT 1
74786: NEG
74787: PUSH
74788: EMPTY
74789: LIST
74790: LIST
74791: PUSH
74792: LD_INT 2
74794: PUSH
74795: LD_INT 0
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: LD_INT 2
74804: PUSH
74805: LD_INT 1
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: PUSH
74812: LD_INT 1
74814: PUSH
74815: LD_INT 2
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: PUSH
74822: LD_INT 0
74824: PUSH
74825: LD_INT 2
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 1
74834: NEG
74835: PUSH
74836: LD_INT 1
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: PUSH
74843: LD_INT 2
74845: NEG
74846: PUSH
74847: LD_INT 0
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: PUSH
74854: LD_INT 2
74856: NEG
74857: PUSH
74858: LD_INT 1
74860: NEG
74861: PUSH
74862: EMPTY
74863: LIST
74864: LIST
74865: PUSH
74866: LD_INT 2
74868: NEG
74869: PUSH
74870: LD_INT 2
74872: NEG
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PUSH
74878: LD_INT 2
74880: NEG
74881: PUSH
74882: LD_INT 3
74884: NEG
74885: PUSH
74886: EMPTY
74887: LIST
74888: LIST
74889: PUSH
74890: LD_INT 2
74892: PUSH
74893: LD_INT 1
74895: NEG
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: PUSH
74901: LD_INT 3
74903: PUSH
74904: LD_INT 1
74906: PUSH
74907: EMPTY
74908: LIST
74909: LIST
74910: PUSH
74911: LD_INT 1
74913: PUSH
74914: LD_INT 3
74916: PUSH
74917: EMPTY
74918: LIST
74919: LIST
74920: PUSH
74921: LD_INT 1
74923: NEG
74924: PUSH
74925: LD_INT 2
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: PUSH
74932: LD_INT 3
74934: NEG
74935: PUSH
74936: LD_INT 2
74938: NEG
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: EMPTY
74945: LIST
74946: LIST
74947: LIST
74948: LIST
74949: LIST
74950: LIST
74951: LIST
74952: LIST
74953: LIST
74954: LIST
74955: LIST
74956: LIST
74957: LIST
74958: LIST
74959: LIST
74960: LIST
74961: LIST
74962: LIST
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: LIST
74968: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74969: LD_ADDR_VAR 0 34
74973: PUSH
74974: LD_INT 0
74976: PUSH
74977: LD_INT 0
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: LD_INT 0
74986: PUSH
74987: LD_INT 1
74989: NEG
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_INT 1
74997: PUSH
74998: LD_INT 0
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: LD_INT 1
75007: PUSH
75008: LD_INT 1
75010: PUSH
75011: EMPTY
75012: LIST
75013: LIST
75014: PUSH
75015: LD_INT 0
75017: PUSH
75018: LD_INT 1
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PUSH
75025: LD_INT 1
75027: NEG
75028: PUSH
75029: LD_INT 0
75031: PUSH
75032: EMPTY
75033: LIST
75034: LIST
75035: PUSH
75036: LD_INT 1
75038: NEG
75039: PUSH
75040: LD_INT 1
75042: NEG
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: PUSH
75048: LD_INT 1
75050: NEG
75051: PUSH
75052: LD_INT 2
75054: NEG
75055: PUSH
75056: EMPTY
75057: LIST
75058: LIST
75059: PUSH
75060: LD_INT 0
75062: PUSH
75063: LD_INT 2
75065: NEG
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: LD_INT 1
75073: PUSH
75074: LD_INT 1
75076: NEG
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 2
75084: PUSH
75085: LD_INT 1
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PUSH
75092: LD_INT 2
75094: PUSH
75095: LD_INT 2
75097: PUSH
75098: EMPTY
75099: LIST
75100: LIST
75101: PUSH
75102: LD_INT 1
75104: PUSH
75105: LD_INT 2
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: PUSH
75112: LD_INT 1
75114: NEG
75115: PUSH
75116: LD_INT 1
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: PUSH
75123: LD_INT 2
75125: NEG
75126: PUSH
75127: LD_INT 0
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 2
75136: NEG
75137: PUSH
75138: LD_INT 1
75140: NEG
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 2
75148: NEG
75149: PUSH
75150: LD_INT 2
75152: NEG
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: LD_INT 1
75160: NEG
75161: PUSH
75162: LD_INT 3
75164: NEG
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 1
75172: PUSH
75173: LD_INT 2
75175: NEG
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PUSH
75181: LD_INT 3
75183: PUSH
75184: LD_INT 2
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: PUSH
75191: LD_INT 2
75193: PUSH
75194: LD_INT 3
75196: PUSH
75197: EMPTY
75198: LIST
75199: LIST
75200: PUSH
75201: LD_INT 2
75203: NEG
75204: PUSH
75205: LD_INT 1
75207: PUSH
75208: EMPTY
75209: LIST
75210: LIST
75211: PUSH
75212: LD_INT 3
75214: NEG
75215: PUSH
75216: LD_INT 1
75218: NEG
75219: PUSH
75220: EMPTY
75221: LIST
75222: LIST
75223: PUSH
75224: EMPTY
75225: LIST
75226: LIST
75227: LIST
75228: LIST
75229: LIST
75230: LIST
75231: LIST
75232: LIST
75233: LIST
75234: LIST
75235: LIST
75236: LIST
75237: LIST
75238: LIST
75239: LIST
75240: LIST
75241: LIST
75242: LIST
75243: LIST
75244: LIST
75245: LIST
75246: LIST
75247: LIST
75248: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
75249: LD_ADDR_VAR 0 35
75253: PUSH
75254: LD_INT 0
75256: PUSH
75257: LD_INT 0
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: PUSH
75264: LD_INT 0
75266: PUSH
75267: LD_INT 1
75269: NEG
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: PUSH
75275: LD_INT 1
75277: PUSH
75278: LD_INT 0
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: PUSH
75285: LD_INT 1
75287: PUSH
75288: LD_INT 1
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 0
75297: PUSH
75298: LD_INT 1
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 1
75307: NEG
75308: PUSH
75309: LD_INT 0
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: PUSH
75316: LD_INT 1
75318: NEG
75319: PUSH
75320: LD_INT 1
75322: NEG
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PUSH
75328: LD_INT 2
75330: PUSH
75331: LD_INT 1
75333: PUSH
75334: EMPTY
75335: LIST
75336: LIST
75337: PUSH
75338: LD_INT 2
75340: NEG
75341: PUSH
75342: LD_INT 1
75344: NEG
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PUSH
75350: EMPTY
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: LIST
75359: LIST
75360: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
75361: LD_ADDR_VAR 0 36
75365: PUSH
75366: LD_INT 0
75368: PUSH
75369: LD_INT 0
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 0
75378: PUSH
75379: LD_INT 1
75381: NEG
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: PUSH
75387: LD_INT 1
75389: PUSH
75390: LD_INT 0
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: LD_INT 1
75399: PUSH
75400: LD_INT 1
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: PUSH
75407: LD_INT 0
75409: PUSH
75410: LD_INT 1
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PUSH
75417: LD_INT 1
75419: NEG
75420: PUSH
75421: LD_INT 0
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 1
75430: NEG
75431: PUSH
75432: LD_INT 1
75434: NEG
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 1
75442: NEG
75443: PUSH
75444: LD_INT 2
75446: NEG
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: PUSH
75452: LD_INT 1
75454: PUSH
75455: LD_INT 2
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: LIST
75466: LIST
75467: LIST
75468: LIST
75469: LIST
75470: LIST
75471: LIST
75472: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
75473: LD_ADDR_VAR 0 37
75477: PUSH
75478: LD_INT 0
75480: PUSH
75481: LD_INT 0
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: LD_INT 1
75493: NEG
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 1
75501: PUSH
75502: LD_INT 0
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 1
75511: PUSH
75512: LD_INT 1
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: LD_INT 0
75521: PUSH
75522: LD_INT 1
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 1
75531: NEG
75532: PUSH
75533: LD_INT 0
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 1
75542: NEG
75543: PUSH
75544: LD_INT 1
75546: NEG
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 1
75554: PUSH
75555: LD_INT 1
75557: NEG
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: PUSH
75563: LD_INT 1
75565: NEG
75566: PUSH
75567: LD_INT 1
75569: PUSH
75570: EMPTY
75571: LIST
75572: LIST
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: LIST
75578: LIST
75579: LIST
75580: LIST
75581: LIST
75582: LIST
75583: LIST
75584: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
75585: LD_ADDR_VAR 0 38
75589: PUSH
75590: LD_INT 0
75592: PUSH
75593: LD_INT 0
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 0
75602: PUSH
75603: LD_INT 1
75605: NEG
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 1
75613: PUSH
75614: LD_INT 0
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 1
75623: PUSH
75624: LD_INT 1
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 0
75633: PUSH
75634: LD_INT 1
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 1
75643: NEG
75644: PUSH
75645: LD_INT 0
75647: PUSH
75648: EMPTY
75649: LIST
75650: LIST
75651: PUSH
75652: LD_INT 1
75654: NEG
75655: PUSH
75656: LD_INT 1
75658: NEG
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: PUSH
75664: LD_INT 2
75666: PUSH
75667: LD_INT 1
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PUSH
75674: LD_INT 2
75676: NEG
75677: PUSH
75678: LD_INT 1
75680: NEG
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: LIST
75690: LIST
75691: LIST
75692: LIST
75693: LIST
75694: LIST
75695: LIST
75696: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
75697: LD_ADDR_VAR 0 39
75701: PUSH
75702: LD_INT 0
75704: PUSH
75705: LD_INT 0
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: LD_INT 0
75714: PUSH
75715: LD_INT 1
75717: NEG
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: PUSH
75723: LD_INT 1
75725: PUSH
75726: LD_INT 0
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 1
75735: PUSH
75736: LD_INT 1
75738: PUSH
75739: EMPTY
75740: LIST
75741: LIST
75742: PUSH
75743: LD_INT 0
75745: PUSH
75746: LD_INT 1
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: LD_INT 1
75755: NEG
75756: PUSH
75757: LD_INT 0
75759: PUSH
75760: EMPTY
75761: LIST
75762: LIST
75763: PUSH
75764: LD_INT 1
75766: NEG
75767: PUSH
75768: LD_INT 1
75770: NEG
75771: PUSH
75772: EMPTY
75773: LIST
75774: LIST
75775: PUSH
75776: LD_INT 1
75778: NEG
75779: PUSH
75780: LD_INT 2
75782: NEG
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: PUSH
75788: LD_INT 1
75790: PUSH
75791: LD_INT 2
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PUSH
75798: EMPTY
75799: LIST
75800: LIST
75801: LIST
75802: LIST
75803: LIST
75804: LIST
75805: LIST
75806: LIST
75807: LIST
75808: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
75809: LD_ADDR_VAR 0 40
75813: PUSH
75814: LD_INT 0
75816: PUSH
75817: LD_INT 0
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 0
75826: PUSH
75827: LD_INT 1
75829: NEG
75830: PUSH
75831: EMPTY
75832: LIST
75833: LIST
75834: PUSH
75835: LD_INT 1
75837: PUSH
75838: LD_INT 0
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: PUSH
75845: LD_INT 1
75847: PUSH
75848: LD_INT 1
75850: PUSH
75851: EMPTY
75852: LIST
75853: LIST
75854: PUSH
75855: LD_INT 0
75857: PUSH
75858: LD_INT 1
75860: PUSH
75861: EMPTY
75862: LIST
75863: LIST
75864: PUSH
75865: LD_INT 1
75867: NEG
75868: PUSH
75869: LD_INT 0
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: PUSH
75876: LD_INT 1
75878: NEG
75879: PUSH
75880: LD_INT 1
75882: NEG
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 1
75890: PUSH
75891: LD_INT 1
75893: NEG
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: LD_INT 1
75901: NEG
75902: PUSH
75903: LD_INT 1
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: LIST
75914: LIST
75915: LIST
75916: LIST
75917: LIST
75918: LIST
75919: LIST
75920: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75921: LD_ADDR_VAR 0 41
75925: PUSH
75926: LD_INT 0
75928: PUSH
75929: LD_INT 0
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: PUSH
75936: LD_INT 0
75938: PUSH
75939: LD_INT 1
75941: NEG
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: LD_INT 1
75949: PUSH
75950: LD_INT 0
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: LD_INT 1
75959: PUSH
75960: LD_INT 1
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PUSH
75967: LD_INT 0
75969: PUSH
75970: LD_INT 1
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 1
75979: NEG
75980: PUSH
75981: LD_INT 0
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 1
75990: NEG
75991: PUSH
75992: LD_INT 1
75994: NEG
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 1
76002: NEG
76003: PUSH
76004: LD_INT 2
76006: NEG
76007: PUSH
76008: EMPTY
76009: LIST
76010: LIST
76011: PUSH
76012: LD_INT 1
76014: PUSH
76015: LD_INT 1
76017: NEG
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 2
76025: PUSH
76026: LD_INT 0
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 2
76035: PUSH
76036: LD_INT 1
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 2
76045: PUSH
76046: LD_INT 2
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 1
76055: PUSH
76056: LD_INT 2
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 1
76065: NEG
76066: PUSH
76067: LD_INT 1
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 2
76076: NEG
76077: PUSH
76078: LD_INT 0
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: LD_INT 2
76087: NEG
76088: PUSH
76089: LD_INT 1
76091: NEG
76092: PUSH
76093: EMPTY
76094: LIST
76095: LIST
76096: PUSH
76097: LD_INT 2
76099: NEG
76100: PUSH
76101: LD_INT 2
76103: NEG
76104: PUSH
76105: EMPTY
76106: LIST
76107: LIST
76108: PUSH
76109: LD_INT 2
76111: NEG
76112: PUSH
76113: LD_INT 3
76115: NEG
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: PUSH
76121: LD_INT 2
76123: PUSH
76124: LD_INT 1
76126: NEG
76127: PUSH
76128: EMPTY
76129: LIST
76130: LIST
76131: PUSH
76132: LD_INT 3
76134: PUSH
76135: LD_INT 0
76137: PUSH
76138: EMPTY
76139: LIST
76140: LIST
76141: PUSH
76142: LD_INT 3
76144: PUSH
76145: LD_INT 1
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: PUSH
76152: LD_INT 3
76154: PUSH
76155: LD_INT 2
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: LD_INT 3
76164: PUSH
76165: LD_INT 3
76167: PUSH
76168: EMPTY
76169: LIST
76170: LIST
76171: PUSH
76172: LD_INT 2
76174: PUSH
76175: LD_INT 3
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 2
76184: NEG
76185: PUSH
76186: LD_INT 1
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: PUSH
76193: LD_INT 3
76195: NEG
76196: PUSH
76197: LD_INT 0
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: PUSH
76204: LD_INT 3
76206: NEG
76207: PUSH
76208: LD_INT 1
76210: NEG
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: PUSH
76216: LD_INT 3
76218: NEG
76219: PUSH
76220: LD_INT 2
76222: NEG
76223: PUSH
76224: EMPTY
76225: LIST
76226: LIST
76227: PUSH
76228: LD_INT 3
76230: NEG
76231: PUSH
76232: LD_INT 3
76234: NEG
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: LIST
76244: LIST
76245: LIST
76246: LIST
76247: LIST
76248: LIST
76249: LIST
76250: LIST
76251: LIST
76252: LIST
76253: LIST
76254: LIST
76255: LIST
76256: LIST
76257: LIST
76258: LIST
76259: LIST
76260: LIST
76261: LIST
76262: LIST
76263: LIST
76264: LIST
76265: LIST
76266: LIST
76267: LIST
76268: LIST
76269: LIST
76270: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76271: LD_ADDR_VAR 0 42
76275: PUSH
76276: LD_INT 0
76278: PUSH
76279: LD_INT 0
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: LD_INT 0
76288: PUSH
76289: LD_INT 1
76291: NEG
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PUSH
76297: LD_INT 1
76299: PUSH
76300: LD_INT 0
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: PUSH
76307: LD_INT 1
76309: PUSH
76310: LD_INT 1
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PUSH
76317: LD_INT 0
76319: PUSH
76320: LD_INT 1
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: LD_INT 1
76329: NEG
76330: PUSH
76331: LD_INT 0
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 1
76340: NEG
76341: PUSH
76342: LD_INT 1
76344: NEG
76345: PUSH
76346: EMPTY
76347: LIST
76348: LIST
76349: PUSH
76350: LD_INT 1
76352: NEG
76353: PUSH
76354: LD_INT 2
76356: NEG
76357: PUSH
76358: EMPTY
76359: LIST
76360: LIST
76361: PUSH
76362: LD_INT 0
76364: PUSH
76365: LD_INT 2
76367: NEG
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 1
76375: PUSH
76376: LD_INT 1
76378: NEG
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: LD_INT 2
76386: PUSH
76387: LD_INT 1
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: PUSH
76394: LD_INT 2
76396: PUSH
76397: LD_INT 2
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 1
76406: PUSH
76407: LD_INT 2
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: LD_INT 0
76416: PUSH
76417: LD_INT 2
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: PUSH
76424: LD_INT 1
76426: NEG
76427: PUSH
76428: LD_INT 1
76430: PUSH
76431: EMPTY
76432: LIST
76433: LIST
76434: PUSH
76435: LD_INT 2
76437: NEG
76438: PUSH
76439: LD_INT 1
76441: NEG
76442: PUSH
76443: EMPTY
76444: LIST
76445: LIST
76446: PUSH
76447: LD_INT 2
76449: NEG
76450: PUSH
76451: LD_INT 2
76453: NEG
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: PUSH
76459: LD_INT 2
76461: NEG
76462: PUSH
76463: LD_INT 3
76465: NEG
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 1
76473: NEG
76474: PUSH
76475: LD_INT 3
76477: NEG
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: LD_INT 0
76485: PUSH
76486: LD_INT 3
76488: NEG
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PUSH
76494: LD_INT 1
76496: PUSH
76497: LD_INT 2
76499: NEG
76500: PUSH
76501: EMPTY
76502: LIST
76503: LIST
76504: PUSH
76505: LD_INT 3
76507: PUSH
76508: LD_INT 2
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: PUSH
76515: LD_INT 3
76517: PUSH
76518: LD_INT 3
76520: PUSH
76521: EMPTY
76522: LIST
76523: LIST
76524: PUSH
76525: LD_INT 2
76527: PUSH
76528: LD_INT 3
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: PUSH
76535: LD_INT 1
76537: PUSH
76538: LD_INT 3
76540: PUSH
76541: EMPTY
76542: LIST
76543: LIST
76544: PUSH
76545: LD_INT 0
76547: PUSH
76548: LD_INT 3
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: LD_INT 1
76557: NEG
76558: PUSH
76559: LD_INT 2
76561: PUSH
76562: EMPTY
76563: LIST
76564: LIST
76565: PUSH
76566: LD_INT 3
76568: NEG
76569: PUSH
76570: LD_INT 2
76572: NEG
76573: PUSH
76574: EMPTY
76575: LIST
76576: LIST
76577: PUSH
76578: LD_INT 3
76580: NEG
76581: PUSH
76582: LD_INT 3
76584: NEG
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: LIST
76594: LIST
76595: LIST
76596: LIST
76597: LIST
76598: LIST
76599: LIST
76600: LIST
76601: LIST
76602: LIST
76603: LIST
76604: LIST
76605: LIST
76606: LIST
76607: LIST
76608: LIST
76609: LIST
76610: LIST
76611: LIST
76612: LIST
76613: LIST
76614: LIST
76615: LIST
76616: LIST
76617: LIST
76618: LIST
76619: LIST
76620: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76621: LD_ADDR_VAR 0 43
76625: PUSH
76626: LD_INT 0
76628: PUSH
76629: LD_INT 0
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: PUSH
76636: LD_INT 0
76638: PUSH
76639: LD_INT 1
76641: NEG
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: PUSH
76647: LD_INT 1
76649: PUSH
76650: LD_INT 0
76652: PUSH
76653: EMPTY
76654: LIST
76655: LIST
76656: PUSH
76657: LD_INT 1
76659: PUSH
76660: LD_INT 1
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 0
76669: PUSH
76670: LD_INT 1
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: LD_INT 1
76679: NEG
76680: PUSH
76681: LD_INT 0
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: PUSH
76688: LD_INT 1
76690: NEG
76691: PUSH
76692: LD_INT 1
76694: NEG
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: LD_INT 1
76702: NEG
76703: PUSH
76704: LD_INT 2
76706: NEG
76707: PUSH
76708: EMPTY
76709: LIST
76710: LIST
76711: PUSH
76712: LD_INT 0
76714: PUSH
76715: LD_INT 2
76717: NEG
76718: PUSH
76719: EMPTY
76720: LIST
76721: LIST
76722: PUSH
76723: LD_INT 1
76725: PUSH
76726: LD_INT 1
76728: NEG
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PUSH
76734: LD_INT 2
76736: PUSH
76737: LD_INT 0
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 2
76746: PUSH
76747: LD_INT 1
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: LD_INT 1
76756: PUSH
76757: LD_INT 2
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 0
76766: PUSH
76767: LD_INT 2
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 1
76776: NEG
76777: PUSH
76778: LD_INT 1
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 2
76787: NEG
76788: PUSH
76789: LD_INT 0
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 2
76798: NEG
76799: PUSH
76800: LD_INT 1
76802: NEG
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 1
76810: NEG
76811: PUSH
76812: LD_INT 3
76814: NEG
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: LD_INT 0
76822: PUSH
76823: LD_INT 3
76825: NEG
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: PUSH
76831: LD_INT 1
76833: PUSH
76834: LD_INT 2
76836: NEG
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: PUSH
76842: LD_INT 2
76844: PUSH
76845: LD_INT 1
76847: NEG
76848: PUSH
76849: EMPTY
76850: LIST
76851: LIST
76852: PUSH
76853: LD_INT 3
76855: PUSH
76856: LD_INT 0
76858: PUSH
76859: EMPTY
76860: LIST
76861: LIST
76862: PUSH
76863: LD_INT 3
76865: PUSH
76866: LD_INT 1
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: PUSH
76873: LD_INT 1
76875: PUSH
76876: LD_INT 3
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: PUSH
76883: LD_INT 0
76885: PUSH
76886: LD_INT 3
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: PUSH
76893: LD_INT 1
76895: NEG
76896: PUSH
76897: LD_INT 2
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: LD_INT 2
76906: NEG
76907: PUSH
76908: LD_INT 1
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: LD_INT 3
76917: NEG
76918: PUSH
76919: LD_INT 0
76921: PUSH
76922: EMPTY
76923: LIST
76924: LIST
76925: PUSH
76926: LD_INT 3
76928: NEG
76929: PUSH
76930: LD_INT 1
76932: NEG
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: LIST
76942: LIST
76943: LIST
76944: LIST
76945: LIST
76946: LIST
76947: LIST
76948: LIST
76949: LIST
76950: LIST
76951: LIST
76952: LIST
76953: LIST
76954: LIST
76955: LIST
76956: LIST
76957: LIST
76958: LIST
76959: LIST
76960: LIST
76961: LIST
76962: LIST
76963: LIST
76964: LIST
76965: LIST
76966: LIST
76967: LIST
76968: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76969: LD_ADDR_VAR 0 44
76973: PUSH
76974: LD_INT 0
76976: PUSH
76977: LD_INT 0
76979: PUSH
76980: EMPTY
76981: LIST
76982: LIST
76983: PUSH
76984: LD_INT 0
76986: PUSH
76987: LD_INT 1
76989: NEG
76990: PUSH
76991: EMPTY
76992: LIST
76993: LIST
76994: PUSH
76995: LD_INT 1
76997: PUSH
76998: LD_INT 0
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: PUSH
77005: LD_INT 1
77007: PUSH
77008: LD_INT 1
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 0
77017: PUSH
77018: LD_INT 1
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: PUSH
77025: LD_INT 1
77027: NEG
77028: PUSH
77029: LD_INT 0
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 1
77038: NEG
77039: PUSH
77040: LD_INT 1
77042: NEG
77043: PUSH
77044: EMPTY
77045: LIST
77046: LIST
77047: PUSH
77048: LD_INT 1
77050: NEG
77051: PUSH
77052: LD_INT 2
77054: NEG
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 1
77062: PUSH
77063: LD_INT 1
77065: NEG
77066: PUSH
77067: EMPTY
77068: LIST
77069: LIST
77070: PUSH
77071: LD_INT 2
77073: PUSH
77074: LD_INT 0
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: PUSH
77081: LD_INT 2
77083: PUSH
77084: LD_INT 1
77086: PUSH
77087: EMPTY
77088: LIST
77089: LIST
77090: PUSH
77091: LD_INT 2
77093: PUSH
77094: LD_INT 2
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PUSH
77101: LD_INT 1
77103: PUSH
77104: LD_INT 2
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: PUSH
77111: LD_INT 1
77113: NEG
77114: PUSH
77115: LD_INT 1
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 2
77124: NEG
77125: PUSH
77126: LD_INT 0
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 2
77135: NEG
77136: PUSH
77137: LD_INT 1
77139: NEG
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 2
77147: NEG
77148: PUSH
77149: LD_INT 2
77151: NEG
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: LD_INT 2
77159: NEG
77160: PUSH
77161: LD_INT 3
77163: NEG
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 2
77171: PUSH
77172: LD_INT 1
77174: NEG
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 3
77182: PUSH
77183: LD_INT 0
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: LD_INT 3
77192: PUSH
77193: LD_INT 1
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: LD_INT 3
77202: PUSH
77203: LD_INT 2
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: PUSH
77210: LD_INT 3
77212: PUSH
77213: LD_INT 3
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: PUSH
77220: LD_INT 2
77222: PUSH
77223: LD_INT 3
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: PUSH
77230: LD_INT 2
77232: NEG
77233: PUSH
77234: LD_INT 1
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 3
77243: NEG
77244: PUSH
77245: LD_INT 0
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 3
77254: NEG
77255: PUSH
77256: LD_INT 1
77258: NEG
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: PUSH
77264: LD_INT 3
77266: NEG
77267: PUSH
77268: LD_INT 2
77270: NEG
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 3
77278: NEG
77279: PUSH
77280: LD_INT 3
77282: NEG
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: LIST
77292: LIST
77293: LIST
77294: LIST
77295: LIST
77296: LIST
77297: LIST
77298: LIST
77299: LIST
77300: LIST
77301: LIST
77302: LIST
77303: LIST
77304: LIST
77305: LIST
77306: LIST
77307: LIST
77308: LIST
77309: LIST
77310: LIST
77311: LIST
77312: LIST
77313: LIST
77314: LIST
77315: LIST
77316: LIST
77317: LIST
77318: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77319: LD_ADDR_VAR 0 45
77323: PUSH
77324: LD_INT 0
77326: PUSH
77327: LD_INT 0
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 0
77336: PUSH
77337: LD_INT 1
77339: NEG
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 1
77347: PUSH
77348: LD_INT 0
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: PUSH
77355: LD_INT 1
77357: PUSH
77358: LD_INT 1
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 0
77367: PUSH
77368: LD_INT 1
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: LD_INT 1
77377: NEG
77378: PUSH
77379: LD_INT 0
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PUSH
77386: LD_INT 1
77388: NEG
77389: PUSH
77390: LD_INT 1
77392: NEG
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: PUSH
77398: LD_INT 1
77400: NEG
77401: PUSH
77402: LD_INT 2
77404: NEG
77405: PUSH
77406: EMPTY
77407: LIST
77408: LIST
77409: PUSH
77410: LD_INT 0
77412: PUSH
77413: LD_INT 2
77415: NEG
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 1
77423: PUSH
77424: LD_INT 1
77426: NEG
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: LD_INT 2
77434: PUSH
77435: LD_INT 1
77437: PUSH
77438: EMPTY
77439: LIST
77440: LIST
77441: PUSH
77442: LD_INT 2
77444: PUSH
77445: LD_INT 2
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 1
77454: PUSH
77455: LD_INT 2
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: PUSH
77462: LD_INT 0
77464: PUSH
77465: LD_INT 2
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 1
77474: NEG
77475: PUSH
77476: LD_INT 1
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: PUSH
77483: LD_INT 2
77485: NEG
77486: PUSH
77487: LD_INT 1
77489: NEG
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 2
77497: NEG
77498: PUSH
77499: LD_INT 2
77501: NEG
77502: PUSH
77503: EMPTY
77504: LIST
77505: LIST
77506: PUSH
77507: LD_INT 2
77509: NEG
77510: PUSH
77511: LD_INT 3
77513: NEG
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 1
77521: NEG
77522: PUSH
77523: LD_INT 3
77525: NEG
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 0
77533: PUSH
77534: LD_INT 3
77536: NEG
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 1
77544: PUSH
77545: LD_INT 2
77547: NEG
77548: PUSH
77549: EMPTY
77550: LIST
77551: LIST
77552: PUSH
77553: LD_INT 3
77555: PUSH
77556: LD_INT 2
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 3
77565: PUSH
77566: LD_INT 3
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: PUSH
77573: LD_INT 2
77575: PUSH
77576: LD_INT 3
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: PUSH
77583: LD_INT 1
77585: PUSH
77586: LD_INT 3
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: LD_INT 0
77595: PUSH
77596: LD_INT 3
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PUSH
77603: LD_INT 1
77605: NEG
77606: PUSH
77607: LD_INT 2
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 3
77616: NEG
77617: PUSH
77618: LD_INT 2
77620: NEG
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: LD_INT 3
77628: NEG
77629: PUSH
77630: LD_INT 3
77632: NEG
77633: PUSH
77634: EMPTY
77635: LIST
77636: LIST
77637: PUSH
77638: EMPTY
77639: LIST
77640: LIST
77641: LIST
77642: LIST
77643: LIST
77644: LIST
77645: LIST
77646: LIST
77647: LIST
77648: LIST
77649: LIST
77650: LIST
77651: LIST
77652: LIST
77653: LIST
77654: LIST
77655: LIST
77656: LIST
77657: LIST
77658: LIST
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77669: LD_ADDR_VAR 0 46
77673: PUSH
77674: LD_INT 0
77676: PUSH
77677: LD_INT 0
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: PUSH
77684: LD_INT 0
77686: PUSH
77687: LD_INT 1
77689: NEG
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: LD_INT 1
77697: PUSH
77698: LD_INT 0
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PUSH
77705: LD_INT 1
77707: PUSH
77708: LD_INT 1
77710: PUSH
77711: EMPTY
77712: LIST
77713: LIST
77714: PUSH
77715: LD_INT 0
77717: PUSH
77718: LD_INT 1
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: PUSH
77725: LD_INT 1
77727: NEG
77728: PUSH
77729: LD_INT 0
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: PUSH
77736: LD_INT 1
77738: NEG
77739: PUSH
77740: LD_INT 1
77742: NEG
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: PUSH
77748: LD_INT 1
77750: NEG
77751: PUSH
77752: LD_INT 2
77754: NEG
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 0
77762: PUSH
77763: LD_INT 2
77765: NEG
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: PUSH
77771: LD_INT 1
77773: PUSH
77774: LD_INT 1
77776: NEG
77777: PUSH
77778: EMPTY
77779: LIST
77780: LIST
77781: PUSH
77782: LD_INT 2
77784: PUSH
77785: LD_INT 0
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: LD_INT 2
77794: PUSH
77795: LD_INT 1
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: LD_INT 1
77804: PUSH
77805: LD_INT 2
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PUSH
77812: LD_INT 0
77814: PUSH
77815: LD_INT 2
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: PUSH
77822: LD_INT 1
77824: NEG
77825: PUSH
77826: LD_INT 1
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 2
77835: NEG
77836: PUSH
77837: LD_INT 0
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 2
77846: NEG
77847: PUSH
77848: LD_INT 1
77850: NEG
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: PUSH
77856: LD_INT 1
77858: NEG
77859: PUSH
77860: LD_INT 3
77862: NEG
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: LD_INT 0
77870: PUSH
77871: LD_INT 3
77873: NEG
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 1
77881: PUSH
77882: LD_INT 2
77884: NEG
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 2
77892: PUSH
77893: LD_INT 1
77895: NEG
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PUSH
77901: LD_INT 3
77903: PUSH
77904: LD_INT 0
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: PUSH
77911: LD_INT 3
77913: PUSH
77914: LD_INT 1
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 1
77923: PUSH
77924: LD_INT 3
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: PUSH
77931: LD_INT 0
77933: PUSH
77934: LD_INT 3
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 1
77943: NEG
77944: PUSH
77945: LD_INT 2
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 2
77954: NEG
77955: PUSH
77956: LD_INT 1
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: LD_INT 3
77965: NEG
77966: PUSH
77967: LD_INT 0
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 3
77976: NEG
77977: PUSH
77978: LD_INT 1
77980: NEG
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: LIST
77990: LIST
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78017: LD_ADDR_VAR 0 47
78021: PUSH
78022: LD_INT 0
78024: PUSH
78025: LD_INT 0
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 0
78034: PUSH
78035: LD_INT 1
78037: NEG
78038: PUSH
78039: EMPTY
78040: LIST
78041: LIST
78042: PUSH
78043: LD_INT 1
78045: PUSH
78046: LD_INT 0
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: PUSH
78053: LD_INT 1
78055: PUSH
78056: LD_INT 1
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: PUSH
78063: LD_INT 0
78065: PUSH
78066: LD_INT 1
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: LD_INT 1
78075: NEG
78076: PUSH
78077: LD_INT 0
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: PUSH
78084: LD_INT 1
78086: NEG
78087: PUSH
78088: LD_INT 1
78090: NEG
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: LD_INT 1
78098: NEG
78099: PUSH
78100: LD_INT 2
78102: NEG
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 0
78110: PUSH
78111: LD_INT 2
78113: NEG
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: PUSH
78119: LD_INT 1
78121: PUSH
78122: LD_INT 1
78124: NEG
78125: PUSH
78126: EMPTY
78127: LIST
78128: LIST
78129: PUSH
78130: LD_INT 2
78132: NEG
78133: PUSH
78134: LD_INT 1
78136: NEG
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: LD_INT 2
78144: NEG
78145: PUSH
78146: LD_INT 2
78148: NEG
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: LIST
78158: LIST
78159: LIST
78160: LIST
78161: LIST
78162: LIST
78163: LIST
78164: LIST
78165: LIST
78166: LIST
78167: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78168: LD_ADDR_VAR 0 48
78172: PUSH
78173: LD_INT 0
78175: PUSH
78176: LD_INT 0
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 0
78185: PUSH
78186: LD_INT 1
78188: NEG
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 1
78196: PUSH
78197: LD_INT 0
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 1
78206: PUSH
78207: LD_INT 1
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: PUSH
78214: LD_INT 0
78216: PUSH
78217: LD_INT 1
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: LD_INT 1
78226: NEG
78227: PUSH
78228: LD_INT 0
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 1
78237: NEG
78238: PUSH
78239: LD_INT 1
78241: NEG
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 1
78249: NEG
78250: PUSH
78251: LD_INT 2
78253: NEG
78254: PUSH
78255: EMPTY
78256: LIST
78257: LIST
78258: PUSH
78259: LD_INT 0
78261: PUSH
78262: LD_INT 2
78264: NEG
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: LD_INT 1
78272: PUSH
78273: LD_INT 1
78275: NEG
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 2
78283: PUSH
78284: LD_INT 0
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: PUSH
78291: LD_INT 2
78293: PUSH
78294: LD_INT 1
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: EMPTY
78302: LIST
78303: LIST
78304: LIST
78305: LIST
78306: LIST
78307: LIST
78308: LIST
78309: LIST
78310: LIST
78311: LIST
78312: LIST
78313: LIST
78314: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78315: LD_ADDR_VAR 0 49
78319: PUSH
78320: LD_INT 0
78322: PUSH
78323: LD_INT 0
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: LD_INT 0
78332: PUSH
78333: LD_INT 1
78335: NEG
78336: PUSH
78337: EMPTY
78338: LIST
78339: LIST
78340: PUSH
78341: LD_INT 1
78343: PUSH
78344: LD_INT 0
78346: PUSH
78347: EMPTY
78348: LIST
78349: LIST
78350: PUSH
78351: LD_INT 1
78353: PUSH
78354: LD_INT 1
78356: PUSH
78357: EMPTY
78358: LIST
78359: LIST
78360: PUSH
78361: LD_INT 0
78363: PUSH
78364: LD_INT 1
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: PUSH
78371: LD_INT 1
78373: NEG
78374: PUSH
78375: LD_INT 0
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 1
78384: NEG
78385: PUSH
78386: LD_INT 1
78388: NEG
78389: PUSH
78390: EMPTY
78391: LIST
78392: LIST
78393: PUSH
78394: LD_INT 1
78396: PUSH
78397: LD_INT 1
78399: NEG
78400: PUSH
78401: EMPTY
78402: LIST
78403: LIST
78404: PUSH
78405: LD_INT 2
78407: PUSH
78408: LD_INT 0
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PUSH
78415: LD_INT 2
78417: PUSH
78418: LD_INT 1
78420: PUSH
78421: EMPTY
78422: LIST
78423: LIST
78424: PUSH
78425: LD_INT 2
78427: PUSH
78428: LD_INT 2
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: PUSH
78435: LD_INT 1
78437: PUSH
78438: LD_INT 2
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: LIST
78449: LIST
78450: LIST
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: LIST
78457: LIST
78458: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78459: LD_ADDR_VAR 0 50
78463: PUSH
78464: LD_INT 0
78466: PUSH
78467: LD_INT 0
78469: PUSH
78470: EMPTY
78471: LIST
78472: LIST
78473: PUSH
78474: LD_INT 0
78476: PUSH
78477: LD_INT 1
78479: NEG
78480: PUSH
78481: EMPTY
78482: LIST
78483: LIST
78484: PUSH
78485: LD_INT 1
78487: PUSH
78488: LD_INT 0
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: PUSH
78495: LD_INT 1
78497: PUSH
78498: LD_INT 1
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 0
78507: PUSH
78508: LD_INT 1
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: PUSH
78515: LD_INT 1
78517: NEG
78518: PUSH
78519: LD_INT 0
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 1
78528: NEG
78529: PUSH
78530: LD_INT 1
78532: NEG
78533: PUSH
78534: EMPTY
78535: LIST
78536: LIST
78537: PUSH
78538: LD_INT 2
78540: PUSH
78541: LD_INT 1
78543: PUSH
78544: EMPTY
78545: LIST
78546: LIST
78547: PUSH
78548: LD_INT 2
78550: PUSH
78551: LD_INT 2
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: PUSH
78558: LD_INT 1
78560: PUSH
78561: LD_INT 2
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 0
78570: PUSH
78571: LD_INT 2
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 1
78580: NEG
78581: PUSH
78582: LD_INT 1
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: LIST
78593: LIST
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78603: LD_ADDR_VAR 0 51
78607: PUSH
78608: LD_INT 0
78610: PUSH
78611: LD_INT 0
78613: PUSH
78614: EMPTY
78615: LIST
78616: LIST
78617: PUSH
78618: LD_INT 0
78620: PUSH
78621: LD_INT 1
78623: NEG
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 1
78631: PUSH
78632: LD_INT 0
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 1
78641: PUSH
78642: LD_INT 1
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 0
78651: PUSH
78652: LD_INT 1
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 1
78661: NEG
78662: PUSH
78663: LD_INT 0
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 1
78672: NEG
78673: PUSH
78674: LD_INT 1
78676: NEG
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: PUSH
78682: LD_INT 1
78684: PUSH
78685: LD_INT 2
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 0
78694: PUSH
78695: LD_INT 2
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: PUSH
78702: LD_INT 1
78704: NEG
78705: PUSH
78706: LD_INT 1
78708: PUSH
78709: EMPTY
78710: LIST
78711: LIST
78712: PUSH
78713: LD_INT 2
78715: NEG
78716: PUSH
78717: LD_INT 0
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: PUSH
78724: LD_INT 2
78726: NEG
78727: PUSH
78728: LD_INT 1
78730: NEG
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: LIST
78746: LIST
78747: LIST
78748: LIST
78749: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78750: LD_ADDR_VAR 0 52
78754: PUSH
78755: LD_INT 0
78757: PUSH
78758: LD_INT 0
78760: PUSH
78761: EMPTY
78762: LIST
78763: LIST
78764: PUSH
78765: LD_INT 0
78767: PUSH
78768: LD_INT 1
78770: NEG
78771: PUSH
78772: EMPTY
78773: LIST
78774: LIST
78775: PUSH
78776: LD_INT 1
78778: PUSH
78779: LD_INT 0
78781: PUSH
78782: EMPTY
78783: LIST
78784: LIST
78785: PUSH
78786: LD_INT 1
78788: PUSH
78789: LD_INT 1
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: PUSH
78796: LD_INT 0
78798: PUSH
78799: LD_INT 1
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: LD_INT 1
78808: NEG
78809: PUSH
78810: LD_INT 0
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: PUSH
78817: LD_INT 1
78819: NEG
78820: PUSH
78821: LD_INT 1
78823: NEG
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: PUSH
78829: LD_INT 1
78831: NEG
78832: PUSH
78833: LD_INT 2
78835: NEG
78836: PUSH
78837: EMPTY
78838: LIST
78839: LIST
78840: PUSH
78841: LD_INT 1
78843: NEG
78844: PUSH
78845: LD_INT 1
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 2
78854: NEG
78855: PUSH
78856: LD_INT 0
78858: PUSH
78859: EMPTY
78860: LIST
78861: LIST
78862: PUSH
78863: LD_INT 2
78865: NEG
78866: PUSH
78867: LD_INT 1
78869: NEG
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 2
78877: NEG
78878: PUSH
78879: LD_INT 2
78881: NEG
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: EMPTY
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78901: LD_ADDR_VAR 0 53
78905: PUSH
78906: LD_INT 0
78908: PUSH
78909: LD_INT 0
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: PUSH
78916: LD_INT 0
78918: PUSH
78919: LD_INT 1
78921: NEG
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: PUSH
78927: LD_INT 1
78929: PUSH
78930: LD_INT 0
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 1
78939: PUSH
78940: LD_INT 1
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 0
78949: PUSH
78950: LD_INT 1
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PUSH
78957: LD_INT 1
78959: NEG
78960: PUSH
78961: LD_INT 0
78963: PUSH
78964: EMPTY
78965: LIST
78966: LIST
78967: PUSH
78968: LD_INT 1
78970: NEG
78971: PUSH
78972: LD_INT 1
78974: NEG
78975: PUSH
78976: EMPTY
78977: LIST
78978: LIST
78979: PUSH
78980: LD_INT 1
78982: NEG
78983: PUSH
78984: LD_INT 2
78986: NEG
78987: PUSH
78988: EMPTY
78989: LIST
78990: LIST
78991: PUSH
78992: LD_INT 0
78994: PUSH
78995: LD_INT 2
78997: NEG
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: LD_INT 1
79005: PUSH
79006: LD_INT 1
79008: NEG
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PUSH
79014: LD_INT 2
79016: PUSH
79017: LD_INT 0
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 2
79026: PUSH
79027: LD_INT 1
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 2
79036: PUSH
79037: LD_INT 2
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 1
79046: PUSH
79047: LD_INT 2
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 0
79056: PUSH
79057: LD_INT 2
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 1
79066: NEG
79067: PUSH
79068: LD_INT 1
79070: PUSH
79071: EMPTY
79072: LIST
79073: LIST
79074: PUSH
79075: LD_INT 2
79077: NEG
79078: PUSH
79079: LD_INT 0
79081: PUSH
79082: EMPTY
79083: LIST
79084: LIST
79085: PUSH
79086: LD_INT 2
79088: NEG
79089: PUSH
79090: LD_INT 1
79092: NEG
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PUSH
79098: LD_INT 2
79100: NEG
79101: PUSH
79102: LD_INT 2
79104: NEG
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: LIST
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: LIST
79119: LIST
79120: LIST
79121: LIST
79122: LIST
79123: LIST
79124: LIST
79125: LIST
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79131: LD_ADDR_VAR 0 54
79135: PUSH
79136: LD_INT 0
79138: PUSH
79139: LD_INT 0
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: LD_INT 0
79148: PUSH
79149: LD_INT 1
79151: NEG
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 1
79159: PUSH
79160: LD_INT 0
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 1
79169: PUSH
79170: LD_INT 1
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 0
79179: PUSH
79180: LD_INT 1
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 1
79189: NEG
79190: PUSH
79191: LD_INT 0
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 1
79200: NEG
79201: PUSH
79202: LD_INT 1
79204: NEG
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 1
79212: NEG
79213: PUSH
79214: LD_INT 2
79216: NEG
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PUSH
79222: LD_INT 0
79224: PUSH
79225: LD_INT 2
79227: NEG
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PUSH
79233: LD_INT 1
79235: PUSH
79236: LD_INT 1
79238: NEG
79239: PUSH
79240: EMPTY
79241: LIST
79242: LIST
79243: PUSH
79244: LD_INT 2
79246: PUSH
79247: LD_INT 0
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 2
79256: PUSH
79257: LD_INT 1
79259: PUSH
79260: EMPTY
79261: LIST
79262: LIST
79263: PUSH
79264: LD_INT 2
79266: PUSH
79267: LD_INT 2
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 1
79276: PUSH
79277: LD_INT 2
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: LD_INT 0
79286: PUSH
79287: LD_INT 2
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: LD_INT 1
79296: NEG
79297: PUSH
79298: LD_INT 1
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: LD_INT 2
79307: NEG
79308: PUSH
79309: LD_INT 0
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: PUSH
79316: LD_INT 2
79318: NEG
79319: PUSH
79320: LD_INT 1
79322: NEG
79323: PUSH
79324: EMPTY
79325: LIST
79326: LIST
79327: PUSH
79328: LD_INT 2
79330: NEG
79331: PUSH
79332: LD_INT 2
79334: NEG
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: LIST
79348: LIST
79349: LIST
79350: LIST
79351: LIST
79352: LIST
79353: LIST
79354: LIST
79355: LIST
79356: LIST
79357: LIST
79358: LIST
79359: LIST
79360: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79361: LD_ADDR_VAR 0 55
79365: PUSH
79366: LD_INT 0
79368: PUSH
79369: LD_INT 0
79371: PUSH
79372: EMPTY
79373: LIST
79374: LIST
79375: PUSH
79376: LD_INT 0
79378: PUSH
79379: LD_INT 1
79381: NEG
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: PUSH
79387: LD_INT 1
79389: PUSH
79390: LD_INT 0
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: LD_INT 1
79399: PUSH
79400: LD_INT 1
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: PUSH
79407: LD_INT 0
79409: PUSH
79410: LD_INT 1
79412: PUSH
79413: EMPTY
79414: LIST
79415: LIST
79416: PUSH
79417: LD_INT 1
79419: NEG
79420: PUSH
79421: LD_INT 0
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: LD_INT 1
79430: NEG
79431: PUSH
79432: LD_INT 1
79434: NEG
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: PUSH
79440: LD_INT 1
79442: NEG
79443: PUSH
79444: LD_INT 2
79446: NEG
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PUSH
79452: LD_INT 0
79454: PUSH
79455: LD_INT 2
79457: NEG
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 1
79465: PUSH
79466: LD_INT 1
79468: NEG
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: PUSH
79474: LD_INT 2
79476: PUSH
79477: LD_INT 0
79479: PUSH
79480: EMPTY
79481: LIST
79482: LIST
79483: PUSH
79484: LD_INT 2
79486: PUSH
79487: LD_INT 1
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: LD_INT 2
79496: PUSH
79497: LD_INT 2
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PUSH
79504: LD_INT 1
79506: PUSH
79507: LD_INT 2
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 0
79516: PUSH
79517: LD_INT 2
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: PUSH
79524: LD_INT 1
79526: NEG
79527: PUSH
79528: LD_INT 1
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: LD_INT 2
79537: NEG
79538: PUSH
79539: LD_INT 0
79541: PUSH
79542: EMPTY
79543: LIST
79544: LIST
79545: PUSH
79546: LD_INT 2
79548: NEG
79549: PUSH
79550: LD_INT 1
79552: NEG
79553: PUSH
79554: EMPTY
79555: LIST
79556: LIST
79557: PUSH
79558: LD_INT 2
79560: NEG
79561: PUSH
79562: LD_INT 2
79564: NEG
79565: PUSH
79566: EMPTY
79567: LIST
79568: LIST
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: LIST
79574: LIST
79575: LIST
79576: LIST
79577: LIST
79578: LIST
79579: LIST
79580: LIST
79581: LIST
79582: LIST
79583: LIST
79584: LIST
79585: LIST
79586: LIST
79587: LIST
79588: LIST
79589: LIST
79590: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79591: LD_ADDR_VAR 0 56
79595: PUSH
79596: LD_INT 0
79598: PUSH
79599: LD_INT 0
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 0
79608: PUSH
79609: LD_INT 1
79611: NEG
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 1
79619: PUSH
79620: LD_INT 0
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: LD_INT 1
79629: PUSH
79630: LD_INT 1
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 0
79639: PUSH
79640: LD_INT 1
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PUSH
79647: LD_INT 1
79649: NEG
79650: PUSH
79651: LD_INT 0
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 1
79660: NEG
79661: PUSH
79662: LD_INT 1
79664: NEG
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 1
79672: NEG
79673: PUSH
79674: LD_INT 2
79676: NEG
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: PUSH
79682: LD_INT 0
79684: PUSH
79685: LD_INT 2
79687: NEG
79688: PUSH
79689: EMPTY
79690: LIST
79691: LIST
79692: PUSH
79693: LD_INT 1
79695: PUSH
79696: LD_INT 1
79698: NEG
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 2
79706: PUSH
79707: LD_INT 0
79709: PUSH
79710: EMPTY
79711: LIST
79712: LIST
79713: PUSH
79714: LD_INT 2
79716: PUSH
79717: LD_INT 1
79719: PUSH
79720: EMPTY
79721: LIST
79722: LIST
79723: PUSH
79724: LD_INT 2
79726: PUSH
79727: LD_INT 2
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 1
79736: PUSH
79737: LD_INT 2
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: LD_INT 0
79746: PUSH
79747: LD_INT 2
79749: PUSH
79750: EMPTY
79751: LIST
79752: LIST
79753: PUSH
79754: LD_INT 1
79756: NEG
79757: PUSH
79758: LD_INT 1
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 2
79767: NEG
79768: PUSH
79769: LD_INT 0
79771: PUSH
79772: EMPTY
79773: LIST
79774: LIST
79775: PUSH
79776: LD_INT 2
79778: NEG
79779: PUSH
79780: LD_INT 1
79782: NEG
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 2
79790: NEG
79791: PUSH
79792: LD_INT 2
79794: NEG
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: LIST
79804: LIST
79805: LIST
79806: LIST
79807: LIST
79808: LIST
79809: LIST
79810: LIST
79811: LIST
79812: LIST
79813: LIST
79814: LIST
79815: LIST
79816: LIST
79817: LIST
79818: LIST
79819: LIST
79820: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79821: LD_ADDR_VAR 0 57
79825: PUSH
79826: LD_INT 0
79828: PUSH
79829: LD_INT 0
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 0
79838: PUSH
79839: LD_INT 1
79841: NEG
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: PUSH
79847: LD_INT 1
79849: PUSH
79850: LD_INT 0
79852: PUSH
79853: EMPTY
79854: LIST
79855: LIST
79856: PUSH
79857: LD_INT 1
79859: PUSH
79860: LD_INT 1
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 0
79869: PUSH
79870: LD_INT 1
79872: PUSH
79873: EMPTY
79874: LIST
79875: LIST
79876: PUSH
79877: LD_INT 1
79879: NEG
79880: PUSH
79881: LD_INT 0
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: PUSH
79888: LD_INT 1
79890: NEG
79891: PUSH
79892: LD_INT 1
79894: NEG
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 1
79902: NEG
79903: PUSH
79904: LD_INT 2
79906: NEG
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: LD_INT 0
79914: PUSH
79915: LD_INT 2
79917: NEG
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: PUSH
79923: LD_INT 1
79925: PUSH
79926: LD_INT 1
79928: NEG
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: PUSH
79934: LD_INT 2
79936: PUSH
79937: LD_INT 0
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 2
79946: PUSH
79947: LD_INT 1
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: PUSH
79954: LD_INT 2
79956: PUSH
79957: LD_INT 2
79959: PUSH
79960: EMPTY
79961: LIST
79962: LIST
79963: PUSH
79964: LD_INT 1
79966: PUSH
79967: LD_INT 2
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 0
79976: PUSH
79977: LD_INT 2
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: LD_INT 1
79986: NEG
79987: PUSH
79988: LD_INT 1
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 2
79997: NEG
79998: PUSH
79999: LD_INT 0
80001: PUSH
80002: EMPTY
80003: LIST
80004: LIST
80005: PUSH
80006: LD_INT 2
80008: NEG
80009: PUSH
80010: LD_INT 1
80012: NEG
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 2
80020: NEG
80021: PUSH
80022: LD_INT 2
80024: NEG
80025: PUSH
80026: EMPTY
80027: LIST
80028: LIST
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: LIST
80034: LIST
80035: LIST
80036: LIST
80037: LIST
80038: LIST
80039: LIST
80040: LIST
80041: LIST
80042: LIST
80043: LIST
80044: LIST
80045: LIST
80046: LIST
80047: LIST
80048: LIST
80049: LIST
80050: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80051: LD_ADDR_VAR 0 58
80055: PUSH
80056: LD_INT 0
80058: PUSH
80059: LD_INT 0
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: LD_INT 0
80068: PUSH
80069: LD_INT 1
80071: NEG
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 1
80079: PUSH
80080: LD_INT 0
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 1
80089: PUSH
80090: LD_INT 1
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 0
80099: PUSH
80100: LD_INT 1
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: PUSH
80107: LD_INT 1
80109: NEG
80110: PUSH
80111: LD_INT 0
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 1
80120: NEG
80121: PUSH
80122: LD_INT 1
80124: NEG
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: LD_INT 1
80132: NEG
80133: PUSH
80134: LD_INT 2
80136: NEG
80137: PUSH
80138: EMPTY
80139: LIST
80140: LIST
80141: PUSH
80142: LD_INT 0
80144: PUSH
80145: LD_INT 2
80147: NEG
80148: PUSH
80149: EMPTY
80150: LIST
80151: LIST
80152: PUSH
80153: LD_INT 1
80155: PUSH
80156: LD_INT 1
80158: NEG
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 2
80166: PUSH
80167: LD_INT 0
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 2
80176: PUSH
80177: LD_INT 1
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 2
80186: PUSH
80187: LD_INT 2
80189: PUSH
80190: EMPTY
80191: LIST
80192: LIST
80193: PUSH
80194: LD_INT 1
80196: PUSH
80197: LD_INT 2
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 0
80206: PUSH
80207: LD_INT 2
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 1
80216: NEG
80217: PUSH
80218: LD_INT 1
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PUSH
80225: LD_INT 2
80227: NEG
80228: PUSH
80229: LD_INT 0
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: LD_INT 2
80238: NEG
80239: PUSH
80240: LD_INT 1
80242: NEG
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 2
80250: NEG
80251: PUSH
80252: LD_INT 2
80254: NEG
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: EMPTY
80261: LIST
80262: LIST
80263: LIST
80264: LIST
80265: LIST
80266: LIST
80267: LIST
80268: LIST
80269: LIST
80270: LIST
80271: LIST
80272: LIST
80273: LIST
80274: LIST
80275: LIST
80276: LIST
80277: LIST
80278: LIST
80279: LIST
80280: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80281: LD_ADDR_VAR 0 59
80285: PUSH
80286: LD_INT 0
80288: PUSH
80289: LD_INT 0
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PUSH
80296: LD_INT 0
80298: PUSH
80299: LD_INT 1
80301: NEG
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 1
80309: PUSH
80310: LD_INT 0
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 1
80319: PUSH
80320: LD_INT 1
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 0
80329: PUSH
80330: LD_INT 1
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: PUSH
80337: LD_INT 1
80339: NEG
80340: PUSH
80341: LD_INT 0
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: PUSH
80348: LD_INT 1
80350: NEG
80351: PUSH
80352: LD_INT 1
80354: NEG
80355: PUSH
80356: EMPTY
80357: LIST
80358: LIST
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80369: LD_ADDR_VAR 0 60
80373: PUSH
80374: LD_INT 0
80376: PUSH
80377: LD_INT 0
80379: PUSH
80380: EMPTY
80381: LIST
80382: LIST
80383: PUSH
80384: LD_INT 0
80386: PUSH
80387: LD_INT 1
80389: NEG
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 1
80397: PUSH
80398: LD_INT 0
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 1
80407: PUSH
80408: LD_INT 1
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: LD_INT 0
80417: PUSH
80418: LD_INT 1
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 1
80427: NEG
80428: PUSH
80429: LD_INT 0
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 1
80438: NEG
80439: PUSH
80440: LD_INT 1
80442: NEG
80443: PUSH
80444: EMPTY
80445: LIST
80446: LIST
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80457: LD_ADDR_VAR 0 61
80461: PUSH
80462: LD_INT 0
80464: PUSH
80465: LD_INT 0
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: LD_INT 0
80474: PUSH
80475: LD_INT 1
80477: NEG
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: PUSH
80483: LD_INT 1
80485: PUSH
80486: LD_INT 0
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 1
80495: PUSH
80496: LD_INT 1
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 0
80505: PUSH
80506: LD_INT 1
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 1
80515: NEG
80516: PUSH
80517: LD_INT 0
80519: PUSH
80520: EMPTY
80521: LIST
80522: LIST
80523: PUSH
80524: LD_INT 1
80526: NEG
80527: PUSH
80528: LD_INT 1
80530: NEG
80531: PUSH
80532: EMPTY
80533: LIST
80534: LIST
80535: PUSH
80536: EMPTY
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80545: LD_ADDR_VAR 0 62
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: LD_INT 0
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: PUSH
80560: LD_INT 0
80562: PUSH
80563: LD_INT 1
80565: NEG
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 1
80573: PUSH
80574: LD_INT 0
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 1
80583: PUSH
80584: LD_INT 1
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 0
80593: PUSH
80594: LD_INT 1
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 1
80603: NEG
80604: PUSH
80605: LD_INT 0
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 1
80614: NEG
80615: PUSH
80616: LD_INT 1
80618: NEG
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80633: LD_ADDR_VAR 0 63
80637: PUSH
80638: LD_INT 0
80640: PUSH
80641: LD_INT 0
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: LD_INT 1
80653: NEG
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 1
80661: PUSH
80662: LD_INT 0
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 1
80671: PUSH
80672: LD_INT 1
80674: PUSH
80675: EMPTY
80676: LIST
80677: LIST
80678: PUSH
80679: LD_INT 0
80681: PUSH
80682: LD_INT 1
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 1
80691: NEG
80692: PUSH
80693: LD_INT 0
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 1
80702: NEG
80703: PUSH
80704: LD_INT 1
80706: NEG
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80721: LD_ADDR_VAR 0 64
80725: PUSH
80726: LD_INT 0
80728: PUSH
80729: LD_INT 0
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 0
80738: PUSH
80739: LD_INT 1
80741: NEG
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: PUSH
80747: LD_INT 1
80749: PUSH
80750: LD_INT 0
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PUSH
80757: LD_INT 1
80759: PUSH
80760: LD_INT 1
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 0
80769: PUSH
80770: LD_INT 1
80772: PUSH
80773: EMPTY
80774: LIST
80775: LIST
80776: PUSH
80777: LD_INT 1
80779: NEG
80780: PUSH
80781: LD_INT 0
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: LD_INT 1
80790: NEG
80791: PUSH
80792: LD_INT 1
80794: NEG
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: LIST
80804: LIST
80805: LIST
80806: LIST
80807: LIST
80808: ST_TO_ADDR
// end ; 1 :
80809: GO 86706
80811: LD_INT 1
80813: DOUBLE
80814: EQUAL
80815: IFTRUE 80819
80817: GO 83442
80819: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80820: LD_ADDR_VAR 0 11
80824: PUSH
80825: LD_INT 1
80827: NEG
80828: PUSH
80829: LD_INT 3
80831: NEG
80832: PUSH
80833: EMPTY
80834: LIST
80835: LIST
80836: PUSH
80837: LD_INT 0
80839: PUSH
80840: LD_INT 3
80842: NEG
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: LD_INT 1
80850: PUSH
80851: LD_INT 2
80853: NEG
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: LIST
80863: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80864: LD_ADDR_VAR 0 12
80868: PUSH
80869: LD_INT 2
80871: PUSH
80872: LD_INT 1
80874: NEG
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: LD_INT 3
80882: PUSH
80883: LD_INT 0
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: PUSH
80890: LD_INT 3
80892: PUSH
80893: LD_INT 1
80895: PUSH
80896: EMPTY
80897: LIST
80898: LIST
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: LIST
80904: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80905: LD_ADDR_VAR 0 13
80909: PUSH
80910: LD_INT 3
80912: PUSH
80913: LD_INT 2
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: LD_INT 3
80922: PUSH
80923: LD_INT 3
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 2
80932: PUSH
80933: LD_INT 3
80935: PUSH
80936: EMPTY
80937: LIST
80938: LIST
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: LIST
80944: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80945: LD_ADDR_VAR 0 14
80949: PUSH
80950: LD_INT 1
80952: PUSH
80953: LD_INT 3
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: LD_INT 0
80962: PUSH
80963: LD_INT 3
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: PUSH
80970: LD_INT 1
80972: NEG
80973: PUSH
80974: LD_INT 2
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: LIST
80985: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80986: LD_ADDR_VAR 0 15
80990: PUSH
80991: LD_INT 2
80993: NEG
80994: PUSH
80995: LD_INT 1
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 3
81004: NEG
81005: PUSH
81006: LD_INT 0
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 3
81015: NEG
81016: PUSH
81017: LD_INT 1
81019: NEG
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: LIST
81029: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81030: LD_ADDR_VAR 0 16
81034: PUSH
81035: LD_INT 2
81037: NEG
81038: PUSH
81039: LD_INT 3
81041: NEG
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: LD_INT 3
81049: NEG
81050: PUSH
81051: LD_INT 2
81053: NEG
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 3
81061: NEG
81062: PUSH
81063: LD_INT 3
81065: NEG
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: LIST
81075: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81076: LD_ADDR_VAR 0 17
81080: PUSH
81081: LD_INT 1
81083: NEG
81084: PUSH
81085: LD_INT 3
81087: NEG
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: PUSH
81093: LD_INT 0
81095: PUSH
81096: LD_INT 3
81098: NEG
81099: PUSH
81100: EMPTY
81101: LIST
81102: LIST
81103: PUSH
81104: LD_INT 1
81106: PUSH
81107: LD_INT 2
81109: NEG
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: LIST
81119: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81120: LD_ADDR_VAR 0 18
81124: PUSH
81125: LD_INT 2
81127: PUSH
81128: LD_INT 1
81130: NEG
81131: PUSH
81132: EMPTY
81133: LIST
81134: LIST
81135: PUSH
81136: LD_INT 3
81138: PUSH
81139: LD_INT 0
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 3
81148: PUSH
81149: LD_INT 1
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: EMPTY
81157: LIST
81158: LIST
81159: LIST
81160: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81161: LD_ADDR_VAR 0 19
81165: PUSH
81166: LD_INT 3
81168: PUSH
81169: LD_INT 2
81171: PUSH
81172: EMPTY
81173: LIST
81174: LIST
81175: PUSH
81176: LD_INT 3
81178: PUSH
81179: LD_INT 3
81181: PUSH
81182: EMPTY
81183: LIST
81184: LIST
81185: PUSH
81186: LD_INT 2
81188: PUSH
81189: LD_INT 3
81191: PUSH
81192: EMPTY
81193: LIST
81194: LIST
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: LIST
81200: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81201: LD_ADDR_VAR 0 20
81205: PUSH
81206: LD_INT 1
81208: PUSH
81209: LD_INT 3
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 0
81218: PUSH
81219: LD_INT 3
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 1
81228: NEG
81229: PUSH
81230: LD_INT 2
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: LIST
81241: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81242: LD_ADDR_VAR 0 21
81246: PUSH
81247: LD_INT 2
81249: NEG
81250: PUSH
81251: LD_INT 1
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 3
81260: NEG
81261: PUSH
81262: LD_INT 0
81264: PUSH
81265: EMPTY
81266: LIST
81267: LIST
81268: PUSH
81269: LD_INT 3
81271: NEG
81272: PUSH
81273: LD_INT 1
81275: NEG
81276: PUSH
81277: EMPTY
81278: LIST
81279: LIST
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: LIST
81285: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81286: LD_ADDR_VAR 0 22
81290: PUSH
81291: LD_INT 2
81293: NEG
81294: PUSH
81295: LD_INT 3
81297: NEG
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: PUSH
81303: LD_INT 3
81305: NEG
81306: PUSH
81307: LD_INT 2
81309: NEG
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 3
81317: NEG
81318: PUSH
81319: LD_INT 3
81321: NEG
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: LIST
81331: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
81332: LD_ADDR_VAR 0 23
81336: PUSH
81337: LD_INT 0
81339: PUSH
81340: LD_INT 3
81342: NEG
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 1
81350: NEG
81351: PUSH
81352: LD_INT 4
81354: NEG
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 1
81362: PUSH
81363: LD_INT 3
81365: NEG
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: LIST
81375: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
81376: LD_ADDR_VAR 0 24
81380: PUSH
81381: LD_INT 3
81383: PUSH
81384: LD_INT 0
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 3
81393: PUSH
81394: LD_INT 1
81396: NEG
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: LD_INT 4
81404: PUSH
81405: LD_INT 1
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: EMPTY
81413: LIST
81414: LIST
81415: LIST
81416: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
81417: LD_ADDR_VAR 0 25
81421: PUSH
81422: LD_INT 3
81424: PUSH
81425: LD_INT 3
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 4
81434: PUSH
81435: LD_INT 3
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 3
81444: PUSH
81445: LD_INT 4
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: LIST
81456: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
81457: LD_ADDR_VAR 0 26
81461: PUSH
81462: LD_INT 0
81464: PUSH
81465: LD_INT 3
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: LD_INT 1
81474: PUSH
81475: LD_INT 4
81477: PUSH
81478: EMPTY
81479: LIST
81480: LIST
81481: PUSH
81482: LD_INT 1
81484: NEG
81485: PUSH
81486: LD_INT 3
81488: PUSH
81489: EMPTY
81490: LIST
81491: LIST
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: LIST
81497: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
81498: LD_ADDR_VAR 0 27
81502: PUSH
81503: LD_INT 3
81505: NEG
81506: PUSH
81507: LD_INT 0
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: PUSH
81514: LD_INT 3
81516: NEG
81517: PUSH
81518: LD_INT 1
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 4
81527: NEG
81528: PUSH
81529: LD_INT 1
81531: NEG
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: EMPTY
81538: LIST
81539: LIST
81540: LIST
81541: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
81542: LD_ADDR_VAR 0 28
81546: PUSH
81547: LD_INT 3
81549: NEG
81550: PUSH
81551: LD_INT 3
81553: NEG
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_INT 3
81561: NEG
81562: PUSH
81563: LD_INT 4
81565: NEG
81566: PUSH
81567: EMPTY
81568: LIST
81569: LIST
81570: PUSH
81571: LD_INT 4
81573: NEG
81574: PUSH
81575: LD_INT 3
81577: NEG
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: LIST
81587: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
81588: LD_ADDR_VAR 0 29
81592: PUSH
81593: LD_INT 1
81595: NEG
81596: PUSH
81597: LD_INT 3
81599: NEG
81600: PUSH
81601: EMPTY
81602: LIST
81603: LIST
81604: PUSH
81605: LD_INT 0
81607: PUSH
81608: LD_INT 3
81610: NEG
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: LD_INT 1
81618: PUSH
81619: LD_INT 2
81621: NEG
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 1
81629: NEG
81630: PUSH
81631: LD_INT 4
81633: NEG
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 0
81641: PUSH
81642: LD_INT 4
81644: NEG
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: LD_INT 1
81652: PUSH
81653: LD_INT 3
81655: NEG
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 1
81663: NEG
81664: PUSH
81665: LD_INT 5
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 0
81675: PUSH
81676: LD_INT 5
81678: NEG
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 1
81686: PUSH
81687: LD_INT 4
81689: NEG
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: LD_INT 1
81697: NEG
81698: PUSH
81699: LD_INT 6
81701: NEG
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 0
81709: PUSH
81710: LD_INT 6
81712: NEG
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 1
81720: PUSH
81721: LD_INT 5
81723: NEG
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: LIST
81741: LIST
81742: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
81743: LD_ADDR_VAR 0 30
81747: PUSH
81748: LD_INT 2
81750: PUSH
81751: LD_INT 1
81753: NEG
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 3
81761: PUSH
81762: LD_INT 0
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 3
81771: PUSH
81772: LD_INT 1
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 3
81781: PUSH
81782: LD_INT 1
81784: NEG
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: PUSH
81790: LD_INT 4
81792: PUSH
81793: LD_INT 0
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: PUSH
81800: LD_INT 4
81802: PUSH
81803: LD_INT 1
81805: PUSH
81806: EMPTY
81807: LIST
81808: LIST
81809: PUSH
81810: LD_INT 4
81812: PUSH
81813: LD_INT 1
81815: NEG
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: PUSH
81821: LD_INT 5
81823: PUSH
81824: LD_INT 0
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: PUSH
81831: LD_INT 5
81833: PUSH
81834: LD_INT 1
81836: PUSH
81837: EMPTY
81838: LIST
81839: LIST
81840: PUSH
81841: LD_INT 5
81843: PUSH
81844: LD_INT 1
81846: NEG
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 6
81854: PUSH
81855: LD_INT 0
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 6
81864: PUSH
81865: LD_INT 1
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: LIST
81876: LIST
81877: LIST
81878: LIST
81879: LIST
81880: LIST
81881: LIST
81882: LIST
81883: LIST
81884: LIST
81885: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
81886: LD_ADDR_VAR 0 31
81890: PUSH
81891: LD_INT 3
81893: PUSH
81894: LD_INT 2
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: LD_INT 3
81903: PUSH
81904: LD_INT 3
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 2
81913: PUSH
81914: LD_INT 3
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 4
81923: PUSH
81924: LD_INT 3
81926: PUSH
81927: EMPTY
81928: LIST
81929: LIST
81930: PUSH
81931: LD_INT 4
81933: PUSH
81934: LD_INT 4
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: PUSH
81941: LD_INT 3
81943: PUSH
81944: LD_INT 4
81946: PUSH
81947: EMPTY
81948: LIST
81949: LIST
81950: PUSH
81951: LD_INT 5
81953: PUSH
81954: LD_INT 4
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: PUSH
81961: LD_INT 5
81963: PUSH
81964: LD_INT 5
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: PUSH
81971: LD_INT 4
81973: PUSH
81974: LD_INT 5
81976: PUSH
81977: EMPTY
81978: LIST
81979: LIST
81980: PUSH
81981: LD_INT 6
81983: PUSH
81984: LD_INT 5
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 6
81993: PUSH
81994: LD_INT 6
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 5
82003: PUSH
82004: LD_INT 6
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
82025: LD_ADDR_VAR 0 32
82029: PUSH
82030: LD_INT 1
82032: PUSH
82033: LD_INT 3
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: LD_INT 0
82042: PUSH
82043: LD_INT 3
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: LD_INT 1
82052: NEG
82053: PUSH
82054: LD_INT 2
82056: PUSH
82057: EMPTY
82058: LIST
82059: LIST
82060: PUSH
82061: LD_INT 1
82063: PUSH
82064: LD_INT 4
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 0
82073: PUSH
82074: LD_INT 4
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 1
82083: NEG
82084: PUSH
82085: LD_INT 3
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 1
82094: PUSH
82095: LD_INT 5
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: PUSH
82102: LD_INT 0
82104: PUSH
82105: LD_INT 5
82107: PUSH
82108: EMPTY
82109: LIST
82110: LIST
82111: PUSH
82112: LD_INT 1
82114: NEG
82115: PUSH
82116: LD_INT 4
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: PUSH
82123: LD_INT 1
82125: PUSH
82126: LD_INT 6
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 0
82135: PUSH
82136: LD_INT 6
82138: PUSH
82139: EMPTY
82140: LIST
82141: LIST
82142: PUSH
82143: LD_INT 1
82145: NEG
82146: PUSH
82147: LD_INT 5
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: LIST
82167: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
82168: LD_ADDR_VAR 0 33
82172: PUSH
82173: LD_INT 2
82175: NEG
82176: PUSH
82177: LD_INT 1
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: PUSH
82184: LD_INT 3
82186: NEG
82187: PUSH
82188: LD_INT 0
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 3
82197: NEG
82198: PUSH
82199: LD_INT 1
82201: NEG
82202: PUSH
82203: EMPTY
82204: LIST
82205: LIST
82206: PUSH
82207: LD_INT 3
82209: NEG
82210: PUSH
82211: LD_INT 1
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: PUSH
82218: LD_INT 4
82220: NEG
82221: PUSH
82222: LD_INT 0
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 4
82231: NEG
82232: PUSH
82233: LD_INT 1
82235: NEG
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: LD_INT 4
82243: NEG
82244: PUSH
82245: LD_INT 1
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 5
82254: NEG
82255: PUSH
82256: LD_INT 0
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 5
82265: NEG
82266: PUSH
82267: LD_INT 1
82269: NEG
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: PUSH
82275: LD_INT 5
82277: NEG
82278: PUSH
82279: LD_INT 1
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 6
82288: NEG
82289: PUSH
82290: LD_INT 0
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: PUSH
82297: LD_INT 6
82299: NEG
82300: PUSH
82301: LD_INT 1
82303: NEG
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: LIST
82322: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
82323: LD_ADDR_VAR 0 34
82327: PUSH
82328: LD_INT 2
82330: NEG
82331: PUSH
82332: LD_INT 3
82334: NEG
82335: PUSH
82336: EMPTY
82337: LIST
82338: LIST
82339: PUSH
82340: LD_INT 3
82342: NEG
82343: PUSH
82344: LD_INT 2
82346: NEG
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: LD_INT 3
82354: NEG
82355: PUSH
82356: LD_INT 3
82358: NEG
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 3
82366: NEG
82367: PUSH
82368: LD_INT 4
82370: NEG
82371: PUSH
82372: EMPTY
82373: LIST
82374: LIST
82375: PUSH
82376: LD_INT 4
82378: NEG
82379: PUSH
82380: LD_INT 3
82382: NEG
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: PUSH
82388: LD_INT 4
82390: NEG
82391: PUSH
82392: LD_INT 4
82394: NEG
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: LD_INT 4
82402: NEG
82403: PUSH
82404: LD_INT 5
82406: NEG
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: PUSH
82412: LD_INT 5
82414: NEG
82415: PUSH
82416: LD_INT 4
82418: NEG
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 5
82426: NEG
82427: PUSH
82428: LD_INT 5
82430: NEG
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: PUSH
82436: LD_INT 5
82438: NEG
82439: PUSH
82440: LD_INT 6
82442: NEG
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 6
82450: NEG
82451: PUSH
82452: LD_INT 5
82454: NEG
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 6
82462: NEG
82463: PUSH
82464: LD_INT 6
82466: NEG
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: LIST
82476: LIST
82477: LIST
82478: LIST
82479: LIST
82480: LIST
82481: LIST
82482: LIST
82483: LIST
82484: LIST
82485: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
82486: LD_ADDR_VAR 0 41
82490: PUSH
82491: LD_INT 0
82493: PUSH
82494: LD_INT 2
82496: NEG
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 1
82504: NEG
82505: PUSH
82506: LD_INT 3
82508: NEG
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 1
82516: PUSH
82517: LD_INT 2
82519: NEG
82520: PUSH
82521: EMPTY
82522: LIST
82523: LIST
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: LIST
82529: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
82530: LD_ADDR_VAR 0 42
82534: PUSH
82535: LD_INT 2
82537: PUSH
82538: LD_INT 0
82540: PUSH
82541: EMPTY
82542: LIST
82543: LIST
82544: PUSH
82545: LD_INT 2
82547: PUSH
82548: LD_INT 1
82550: NEG
82551: PUSH
82552: EMPTY
82553: LIST
82554: LIST
82555: PUSH
82556: LD_INT 3
82558: PUSH
82559: LD_INT 1
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: EMPTY
82567: LIST
82568: LIST
82569: LIST
82570: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
82571: LD_ADDR_VAR 0 43
82575: PUSH
82576: LD_INT 2
82578: PUSH
82579: LD_INT 2
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: LD_INT 3
82588: PUSH
82589: LD_INT 2
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 2
82598: PUSH
82599: LD_INT 3
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: LIST
82610: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
82611: LD_ADDR_VAR 0 44
82615: PUSH
82616: LD_INT 0
82618: PUSH
82619: LD_INT 2
82621: PUSH
82622: EMPTY
82623: LIST
82624: LIST
82625: PUSH
82626: LD_INT 1
82628: PUSH
82629: LD_INT 3
82631: PUSH
82632: EMPTY
82633: LIST
82634: LIST
82635: PUSH
82636: LD_INT 1
82638: NEG
82639: PUSH
82640: LD_INT 2
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: EMPTY
82648: LIST
82649: LIST
82650: LIST
82651: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82652: LD_ADDR_VAR 0 45
82656: PUSH
82657: LD_INT 2
82659: NEG
82660: PUSH
82661: LD_INT 0
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 2
82670: NEG
82671: PUSH
82672: LD_INT 1
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: PUSH
82679: LD_INT 3
82681: NEG
82682: PUSH
82683: LD_INT 1
82685: NEG
82686: PUSH
82687: EMPTY
82688: LIST
82689: LIST
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: LIST
82695: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
82696: LD_ADDR_VAR 0 46
82700: PUSH
82701: LD_INT 2
82703: NEG
82704: PUSH
82705: LD_INT 2
82707: NEG
82708: PUSH
82709: EMPTY
82710: LIST
82711: LIST
82712: PUSH
82713: LD_INT 2
82715: NEG
82716: PUSH
82717: LD_INT 3
82719: NEG
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 3
82727: NEG
82728: PUSH
82729: LD_INT 2
82731: NEG
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: LIST
82741: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
82742: LD_ADDR_VAR 0 47
82746: PUSH
82747: LD_INT 2
82749: NEG
82750: PUSH
82751: LD_INT 3
82753: NEG
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 1
82761: NEG
82762: PUSH
82763: LD_INT 3
82765: NEG
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: EMPTY
82772: LIST
82773: LIST
82774: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82775: LD_ADDR_VAR 0 48
82779: PUSH
82780: LD_INT 1
82782: PUSH
82783: LD_INT 2
82785: NEG
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 2
82793: PUSH
82794: LD_INT 1
82796: NEG
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: PUSH
82802: EMPTY
82803: LIST
82804: LIST
82805: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
82806: LD_ADDR_VAR 0 49
82810: PUSH
82811: LD_INT 3
82813: PUSH
82814: LD_INT 1
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 3
82823: PUSH
82824: LD_INT 2
82826: PUSH
82827: EMPTY
82828: LIST
82829: LIST
82830: PUSH
82831: EMPTY
82832: LIST
82833: LIST
82834: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
82835: LD_ADDR_VAR 0 50
82839: PUSH
82840: LD_INT 2
82842: PUSH
82843: LD_INT 3
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 1
82852: PUSH
82853: LD_INT 3
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: EMPTY
82861: LIST
82862: LIST
82863: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82864: LD_ADDR_VAR 0 51
82868: PUSH
82869: LD_INT 1
82871: NEG
82872: PUSH
82873: LD_INT 2
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 2
82882: NEG
82883: PUSH
82884: LD_INT 1
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82895: LD_ADDR_VAR 0 52
82899: PUSH
82900: LD_INT 3
82902: NEG
82903: PUSH
82904: LD_INT 1
82906: NEG
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: PUSH
82912: LD_INT 3
82914: NEG
82915: PUSH
82916: LD_INT 2
82918: NEG
82919: PUSH
82920: EMPTY
82921: LIST
82922: LIST
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82928: LD_ADDR_VAR 0 53
82932: PUSH
82933: LD_INT 1
82935: NEG
82936: PUSH
82937: LD_INT 3
82939: NEG
82940: PUSH
82941: EMPTY
82942: LIST
82943: LIST
82944: PUSH
82945: LD_INT 0
82947: PUSH
82948: LD_INT 3
82950: NEG
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: LD_INT 1
82958: PUSH
82959: LD_INT 2
82961: NEG
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: EMPTY
82968: LIST
82969: LIST
82970: LIST
82971: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82972: LD_ADDR_VAR 0 54
82976: PUSH
82977: LD_INT 2
82979: PUSH
82980: LD_INT 1
82982: NEG
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: PUSH
82988: LD_INT 3
82990: PUSH
82991: LD_INT 0
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: LD_INT 3
83000: PUSH
83001: LD_INT 1
83003: PUSH
83004: EMPTY
83005: LIST
83006: LIST
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: LIST
83012: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
83013: LD_ADDR_VAR 0 55
83017: PUSH
83018: LD_INT 3
83020: PUSH
83021: LD_INT 2
83023: PUSH
83024: EMPTY
83025: LIST
83026: LIST
83027: PUSH
83028: LD_INT 3
83030: PUSH
83031: LD_INT 3
83033: PUSH
83034: EMPTY
83035: LIST
83036: LIST
83037: PUSH
83038: LD_INT 2
83040: PUSH
83041: LD_INT 3
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: LIST
83052: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
83053: LD_ADDR_VAR 0 56
83057: PUSH
83058: LD_INT 1
83060: PUSH
83061: LD_INT 3
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: PUSH
83068: LD_INT 0
83070: PUSH
83071: LD_INT 3
83073: PUSH
83074: EMPTY
83075: LIST
83076: LIST
83077: PUSH
83078: LD_INT 1
83080: NEG
83081: PUSH
83082: LD_INT 2
83084: PUSH
83085: EMPTY
83086: LIST
83087: LIST
83088: PUSH
83089: EMPTY
83090: LIST
83091: LIST
83092: LIST
83093: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83094: LD_ADDR_VAR 0 57
83098: PUSH
83099: LD_INT 2
83101: NEG
83102: PUSH
83103: LD_INT 1
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 3
83112: NEG
83113: PUSH
83114: LD_INT 0
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PUSH
83121: LD_INT 3
83123: NEG
83124: PUSH
83125: LD_INT 1
83127: NEG
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: LIST
83137: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83138: LD_ADDR_VAR 0 58
83142: PUSH
83143: LD_INT 2
83145: NEG
83146: PUSH
83147: LD_INT 3
83149: NEG
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PUSH
83155: LD_INT 3
83157: NEG
83158: PUSH
83159: LD_INT 2
83161: NEG
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: PUSH
83167: LD_INT 3
83169: NEG
83170: PUSH
83171: LD_INT 3
83173: NEG
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: LIST
83183: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
83184: LD_ADDR_VAR 0 59
83188: PUSH
83189: LD_INT 1
83191: NEG
83192: PUSH
83193: LD_INT 2
83195: NEG
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 0
83203: PUSH
83204: LD_INT 2
83206: NEG
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 1
83214: PUSH
83215: LD_INT 1
83217: NEG
83218: PUSH
83219: EMPTY
83220: LIST
83221: LIST
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: LIST
83227: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
83228: LD_ADDR_VAR 0 60
83232: PUSH
83233: LD_INT 1
83235: PUSH
83236: LD_INT 1
83238: NEG
83239: PUSH
83240: EMPTY
83241: LIST
83242: LIST
83243: PUSH
83244: LD_INT 2
83246: PUSH
83247: LD_INT 0
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: PUSH
83254: LD_INT 2
83256: PUSH
83257: LD_INT 1
83259: PUSH
83260: EMPTY
83261: LIST
83262: LIST
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: LIST
83268: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
83269: LD_ADDR_VAR 0 61
83273: PUSH
83274: LD_INT 2
83276: PUSH
83277: LD_INT 1
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: PUSH
83284: LD_INT 2
83286: PUSH
83287: LD_INT 2
83289: PUSH
83290: EMPTY
83291: LIST
83292: LIST
83293: PUSH
83294: LD_INT 1
83296: PUSH
83297: LD_INT 2
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: LIST
83308: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
83309: LD_ADDR_VAR 0 62
83313: PUSH
83314: LD_INT 1
83316: PUSH
83317: LD_INT 2
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: PUSH
83324: LD_INT 0
83326: PUSH
83327: LD_INT 2
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 1
83336: NEG
83337: PUSH
83338: LD_INT 1
83340: PUSH
83341: EMPTY
83342: LIST
83343: LIST
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: LIST
83349: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
83350: LD_ADDR_VAR 0 63
83354: PUSH
83355: LD_INT 1
83357: NEG
83358: PUSH
83359: LD_INT 1
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 2
83368: NEG
83369: PUSH
83370: LD_INT 0
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 2
83379: NEG
83380: PUSH
83381: LD_INT 1
83383: NEG
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: LIST
83393: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83394: LD_ADDR_VAR 0 64
83398: PUSH
83399: LD_INT 1
83401: NEG
83402: PUSH
83403: LD_INT 2
83405: NEG
83406: PUSH
83407: EMPTY
83408: LIST
83409: LIST
83410: PUSH
83411: LD_INT 2
83413: NEG
83414: PUSH
83415: LD_INT 1
83417: NEG
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: PUSH
83423: LD_INT 2
83425: NEG
83426: PUSH
83427: LD_INT 2
83429: NEG
83430: PUSH
83431: EMPTY
83432: LIST
83433: LIST
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: LIST
83439: ST_TO_ADDR
// end ; 2 :
83440: GO 86706
83442: LD_INT 2
83444: DOUBLE
83445: EQUAL
83446: IFTRUE 83450
83448: GO 86705
83450: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
83451: LD_ADDR_VAR 0 29
83455: PUSH
83456: LD_INT 4
83458: PUSH
83459: LD_INT 0
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 4
83468: PUSH
83469: LD_INT 1
83471: NEG
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 5
83479: PUSH
83480: LD_INT 0
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: PUSH
83487: LD_INT 5
83489: PUSH
83490: LD_INT 1
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: LD_INT 4
83499: PUSH
83500: LD_INT 1
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PUSH
83507: LD_INT 3
83509: PUSH
83510: LD_INT 0
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: PUSH
83517: LD_INT 3
83519: PUSH
83520: LD_INT 1
83522: NEG
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: LD_INT 3
83530: PUSH
83531: LD_INT 2
83533: NEG
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PUSH
83539: LD_INT 5
83541: PUSH
83542: LD_INT 2
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 3
83551: PUSH
83552: LD_INT 3
83554: PUSH
83555: EMPTY
83556: LIST
83557: LIST
83558: PUSH
83559: LD_INT 3
83561: PUSH
83562: LD_INT 2
83564: PUSH
83565: EMPTY
83566: LIST
83567: LIST
83568: PUSH
83569: LD_INT 4
83571: PUSH
83572: LD_INT 3
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 4
83581: PUSH
83582: LD_INT 4
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: PUSH
83589: LD_INT 3
83591: PUSH
83592: LD_INT 4
83594: PUSH
83595: EMPTY
83596: LIST
83597: LIST
83598: PUSH
83599: LD_INT 2
83601: PUSH
83602: LD_INT 3
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: LD_INT 2
83611: PUSH
83612: LD_INT 2
83614: PUSH
83615: EMPTY
83616: LIST
83617: LIST
83618: PUSH
83619: LD_INT 4
83621: PUSH
83622: LD_INT 2
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: PUSH
83629: LD_INT 2
83631: PUSH
83632: LD_INT 4
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PUSH
83639: LD_INT 0
83641: PUSH
83642: LD_INT 4
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 0
83651: PUSH
83652: LD_INT 3
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 1
83661: PUSH
83662: LD_INT 4
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 1
83671: PUSH
83672: LD_INT 5
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: PUSH
83679: LD_INT 0
83681: PUSH
83682: LD_INT 5
83684: PUSH
83685: EMPTY
83686: LIST
83687: LIST
83688: PUSH
83689: LD_INT 1
83691: NEG
83692: PUSH
83693: LD_INT 4
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: PUSH
83700: LD_INT 1
83702: NEG
83703: PUSH
83704: LD_INT 3
83706: PUSH
83707: EMPTY
83708: LIST
83709: LIST
83710: PUSH
83711: LD_INT 2
83713: PUSH
83714: LD_INT 5
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: PUSH
83721: LD_INT 2
83723: NEG
83724: PUSH
83725: LD_INT 3
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PUSH
83732: LD_INT 3
83734: NEG
83735: PUSH
83736: LD_INT 0
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: PUSH
83743: LD_INT 3
83745: NEG
83746: PUSH
83747: LD_INT 1
83749: NEG
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 2
83757: NEG
83758: PUSH
83759: LD_INT 0
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 2
83768: NEG
83769: PUSH
83770: LD_INT 1
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: PUSH
83777: LD_INT 3
83779: NEG
83780: PUSH
83781: LD_INT 1
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 4
83790: NEG
83791: PUSH
83792: LD_INT 0
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: LD_INT 4
83801: NEG
83802: PUSH
83803: LD_INT 1
83805: NEG
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: PUSH
83811: LD_INT 4
83813: NEG
83814: PUSH
83815: LD_INT 2
83817: NEG
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: PUSH
83823: LD_INT 2
83825: NEG
83826: PUSH
83827: LD_INT 2
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 4
83836: NEG
83837: PUSH
83838: LD_INT 4
83840: NEG
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PUSH
83846: LD_INT 4
83848: NEG
83849: PUSH
83850: LD_INT 5
83852: NEG
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 3
83860: NEG
83861: PUSH
83862: LD_INT 4
83864: NEG
83865: PUSH
83866: EMPTY
83867: LIST
83868: LIST
83869: PUSH
83870: LD_INT 3
83872: NEG
83873: PUSH
83874: LD_INT 3
83876: NEG
83877: PUSH
83878: EMPTY
83879: LIST
83880: LIST
83881: PUSH
83882: LD_INT 4
83884: NEG
83885: PUSH
83886: LD_INT 3
83888: NEG
83889: PUSH
83890: EMPTY
83891: LIST
83892: LIST
83893: PUSH
83894: LD_INT 5
83896: NEG
83897: PUSH
83898: LD_INT 4
83900: NEG
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: LD_INT 5
83908: NEG
83909: PUSH
83910: LD_INT 5
83912: NEG
83913: PUSH
83914: EMPTY
83915: LIST
83916: LIST
83917: PUSH
83918: LD_INT 3
83920: NEG
83921: PUSH
83922: LD_INT 5
83924: NEG
83925: PUSH
83926: EMPTY
83927: LIST
83928: LIST
83929: PUSH
83930: LD_INT 5
83932: NEG
83933: PUSH
83934: LD_INT 3
83936: NEG
83937: PUSH
83938: EMPTY
83939: LIST
83940: LIST
83941: PUSH
83942: EMPTY
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: LIST
83974: LIST
83975: LIST
83976: LIST
83977: LIST
83978: LIST
83979: LIST
83980: LIST
83981: LIST
83982: LIST
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
83989: LD_ADDR_VAR 0 30
83993: PUSH
83994: LD_INT 4
83996: PUSH
83997: LD_INT 4
83999: PUSH
84000: EMPTY
84001: LIST
84002: LIST
84003: PUSH
84004: LD_INT 4
84006: PUSH
84007: LD_INT 3
84009: PUSH
84010: EMPTY
84011: LIST
84012: LIST
84013: PUSH
84014: LD_INT 5
84016: PUSH
84017: LD_INT 4
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: PUSH
84024: LD_INT 5
84026: PUSH
84027: LD_INT 5
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 4
84036: PUSH
84037: LD_INT 5
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: PUSH
84044: LD_INT 3
84046: PUSH
84047: LD_INT 4
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 3
84056: PUSH
84057: LD_INT 3
84059: PUSH
84060: EMPTY
84061: LIST
84062: LIST
84063: PUSH
84064: LD_INT 5
84066: PUSH
84067: LD_INT 3
84069: PUSH
84070: EMPTY
84071: LIST
84072: LIST
84073: PUSH
84074: LD_INT 3
84076: PUSH
84077: LD_INT 5
84079: PUSH
84080: EMPTY
84081: LIST
84082: LIST
84083: PUSH
84084: LD_INT 0
84086: PUSH
84087: LD_INT 3
84089: PUSH
84090: EMPTY
84091: LIST
84092: LIST
84093: PUSH
84094: LD_INT 0
84096: PUSH
84097: LD_INT 2
84099: PUSH
84100: EMPTY
84101: LIST
84102: LIST
84103: PUSH
84104: LD_INT 1
84106: PUSH
84107: LD_INT 3
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: PUSH
84114: LD_INT 1
84116: PUSH
84117: LD_INT 4
84119: PUSH
84120: EMPTY
84121: LIST
84122: LIST
84123: PUSH
84124: LD_INT 0
84126: PUSH
84127: LD_INT 4
84129: PUSH
84130: EMPTY
84131: LIST
84132: LIST
84133: PUSH
84134: LD_INT 1
84136: NEG
84137: PUSH
84138: LD_INT 3
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 1
84147: NEG
84148: PUSH
84149: LD_INT 2
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: PUSH
84156: LD_INT 2
84158: PUSH
84159: LD_INT 4
84161: PUSH
84162: EMPTY
84163: LIST
84164: LIST
84165: PUSH
84166: LD_INT 2
84168: NEG
84169: PUSH
84170: LD_INT 2
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 4
84179: NEG
84180: PUSH
84181: LD_INT 0
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PUSH
84188: LD_INT 4
84190: NEG
84191: PUSH
84192: LD_INT 1
84194: NEG
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: PUSH
84200: LD_INT 3
84202: NEG
84203: PUSH
84204: LD_INT 0
84206: PUSH
84207: EMPTY
84208: LIST
84209: LIST
84210: PUSH
84211: LD_INT 3
84213: NEG
84214: PUSH
84215: LD_INT 1
84217: PUSH
84218: EMPTY
84219: LIST
84220: LIST
84221: PUSH
84222: LD_INT 4
84224: NEG
84225: PUSH
84226: LD_INT 1
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: PUSH
84233: LD_INT 5
84235: NEG
84236: PUSH
84237: LD_INT 0
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 5
84246: NEG
84247: PUSH
84248: LD_INT 1
84250: NEG
84251: PUSH
84252: EMPTY
84253: LIST
84254: LIST
84255: PUSH
84256: LD_INT 5
84258: NEG
84259: PUSH
84260: LD_INT 2
84262: NEG
84263: PUSH
84264: EMPTY
84265: LIST
84266: LIST
84267: PUSH
84268: LD_INT 3
84270: NEG
84271: PUSH
84272: LD_INT 2
84274: PUSH
84275: EMPTY
84276: LIST
84277: LIST
84278: PUSH
84279: LD_INT 3
84281: NEG
84282: PUSH
84283: LD_INT 3
84285: NEG
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 3
84293: NEG
84294: PUSH
84295: LD_INT 4
84297: NEG
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 2
84305: NEG
84306: PUSH
84307: LD_INT 3
84309: NEG
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: PUSH
84315: LD_INT 2
84317: NEG
84318: PUSH
84319: LD_INT 2
84321: NEG
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 3
84329: NEG
84330: PUSH
84331: LD_INT 2
84333: NEG
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 4
84341: NEG
84342: PUSH
84343: LD_INT 3
84345: NEG
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 4
84353: NEG
84354: PUSH
84355: LD_INT 4
84357: NEG
84358: PUSH
84359: EMPTY
84360: LIST
84361: LIST
84362: PUSH
84363: LD_INT 2
84365: NEG
84366: PUSH
84367: LD_INT 4
84369: NEG
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: PUSH
84375: LD_INT 4
84377: NEG
84378: PUSH
84379: LD_INT 2
84381: NEG
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: LD_INT 0
84389: PUSH
84390: LD_INT 4
84392: NEG
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PUSH
84398: LD_INT 0
84400: PUSH
84401: LD_INT 5
84403: NEG
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 1
84411: PUSH
84412: LD_INT 4
84414: NEG
84415: PUSH
84416: EMPTY
84417: LIST
84418: LIST
84419: PUSH
84420: LD_INT 1
84422: PUSH
84423: LD_INT 3
84425: NEG
84426: PUSH
84427: EMPTY
84428: LIST
84429: LIST
84430: PUSH
84431: LD_INT 0
84433: PUSH
84434: LD_INT 3
84436: NEG
84437: PUSH
84438: EMPTY
84439: LIST
84440: LIST
84441: PUSH
84442: LD_INT 1
84444: NEG
84445: PUSH
84446: LD_INT 4
84448: NEG
84449: PUSH
84450: EMPTY
84451: LIST
84452: LIST
84453: PUSH
84454: LD_INT 1
84456: NEG
84457: PUSH
84458: LD_INT 5
84460: NEG
84461: PUSH
84462: EMPTY
84463: LIST
84464: LIST
84465: PUSH
84466: LD_INT 2
84468: PUSH
84469: LD_INT 3
84471: NEG
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 2
84479: NEG
84480: PUSH
84481: LD_INT 5
84483: NEG
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: EMPTY
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: LIST
84523: LIST
84524: LIST
84525: LIST
84526: LIST
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
84536: LD_ADDR_VAR 0 31
84540: PUSH
84541: LD_INT 0
84543: PUSH
84544: LD_INT 4
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PUSH
84551: LD_INT 0
84553: PUSH
84554: LD_INT 3
84556: PUSH
84557: EMPTY
84558: LIST
84559: LIST
84560: PUSH
84561: LD_INT 1
84563: PUSH
84564: LD_INT 4
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: LD_INT 1
84573: PUSH
84574: LD_INT 5
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: PUSH
84581: LD_INT 0
84583: PUSH
84584: LD_INT 5
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: PUSH
84591: LD_INT 1
84593: NEG
84594: PUSH
84595: LD_INT 4
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: PUSH
84602: LD_INT 1
84604: NEG
84605: PUSH
84606: LD_INT 3
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: LD_INT 2
84615: PUSH
84616: LD_INT 5
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 2
84625: NEG
84626: PUSH
84627: LD_INT 3
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: LD_INT 3
84636: NEG
84637: PUSH
84638: LD_INT 0
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: LD_INT 3
84647: NEG
84648: PUSH
84649: LD_INT 1
84651: NEG
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: PUSH
84657: LD_INT 2
84659: NEG
84660: PUSH
84661: LD_INT 0
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: PUSH
84668: LD_INT 2
84670: NEG
84671: PUSH
84672: LD_INT 1
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 3
84681: NEG
84682: PUSH
84683: LD_INT 1
84685: PUSH
84686: EMPTY
84687: LIST
84688: LIST
84689: PUSH
84690: LD_INT 4
84692: NEG
84693: PUSH
84694: LD_INT 0
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: PUSH
84701: LD_INT 4
84703: NEG
84704: PUSH
84705: LD_INT 1
84707: NEG
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: PUSH
84713: LD_INT 4
84715: NEG
84716: PUSH
84717: LD_INT 2
84719: NEG
84720: PUSH
84721: EMPTY
84722: LIST
84723: LIST
84724: PUSH
84725: LD_INT 2
84727: NEG
84728: PUSH
84729: LD_INT 2
84731: PUSH
84732: EMPTY
84733: LIST
84734: LIST
84735: PUSH
84736: LD_INT 4
84738: NEG
84739: PUSH
84740: LD_INT 4
84742: NEG
84743: PUSH
84744: EMPTY
84745: LIST
84746: LIST
84747: PUSH
84748: LD_INT 4
84750: NEG
84751: PUSH
84752: LD_INT 5
84754: NEG
84755: PUSH
84756: EMPTY
84757: LIST
84758: LIST
84759: PUSH
84760: LD_INT 3
84762: NEG
84763: PUSH
84764: LD_INT 4
84766: NEG
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: PUSH
84772: LD_INT 3
84774: NEG
84775: PUSH
84776: LD_INT 3
84778: NEG
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 4
84786: NEG
84787: PUSH
84788: LD_INT 3
84790: NEG
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 5
84798: NEG
84799: PUSH
84800: LD_INT 4
84802: NEG
84803: PUSH
84804: EMPTY
84805: LIST
84806: LIST
84807: PUSH
84808: LD_INT 5
84810: NEG
84811: PUSH
84812: LD_INT 5
84814: NEG
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PUSH
84820: LD_INT 3
84822: NEG
84823: PUSH
84824: LD_INT 5
84826: NEG
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: PUSH
84832: LD_INT 5
84834: NEG
84835: PUSH
84836: LD_INT 3
84838: NEG
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: PUSH
84844: LD_INT 0
84846: PUSH
84847: LD_INT 3
84849: NEG
84850: PUSH
84851: EMPTY
84852: LIST
84853: LIST
84854: PUSH
84855: LD_INT 0
84857: PUSH
84858: LD_INT 4
84860: NEG
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: PUSH
84866: LD_INT 1
84868: PUSH
84869: LD_INT 3
84871: NEG
84872: PUSH
84873: EMPTY
84874: LIST
84875: LIST
84876: PUSH
84877: LD_INT 1
84879: PUSH
84880: LD_INT 2
84882: NEG
84883: PUSH
84884: EMPTY
84885: LIST
84886: LIST
84887: PUSH
84888: LD_INT 0
84890: PUSH
84891: LD_INT 2
84893: NEG
84894: PUSH
84895: EMPTY
84896: LIST
84897: LIST
84898: PUSH
84899: LD_INT 1
84901: NEG
84902: PUSH
84903: LD_INT 3
84905: NEG
84906: PUSH
84907: EMPTY
84908: LIST
84909: LIST
84910: PUSH
84911: LD_INT 1
84913: NEG
84914: PUSH
84915: LD_INT 4
84917: NEG
84918: PUSH
84919: EMPTY
84920: LIST
84921: LIST
84922: PUSH
84923: LD_INT 2
84925: PUSH
84926: LD_INT 2
84928: NEG
84929: PUSH
84930: EMPTY
84931: LIST
84932: LIST
84933: PUSH
84934: LD_INT 2
84936: NEG
84937: PUSH
84938: LD_INT 4
84940: NEG
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: PUSH
84946: LD_INT 4
84948: PUSH
84949: LD_INT 0
84951: PUSH
84952: EMPTY
84953: LIST
84954: LIST
84955: PUSH
84956: LD_INT 4
84958: PUSH
84959: LD_INT 1
84961: NEG
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 5
84969: PUSH
84970: LD_INT 0
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: PUSH
84977: LD_INT 5
84979: PUSH
84980: LD_INT 1
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 4
84989: PUSH
84990: LD_INT 1
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 3
84999: PUSH
85000: LD_INT 0
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 3
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 3
85020: PUSH
85021: LD_INT 2
85023: NEG
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: LD_INT 5
85031: PUSH
85032: LD_INT 2
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: PUSH
85039: EMPTY
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: LIST
85065: LIST
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: LIST
85073: LIST
85074: LIST
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
85086: LD_ADDR_VAR 0 32
85090: PUSH
85091: LD_INT 4
85093: NEG
85094: PUSH
85095: LD_INT 0
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_INT 4
85104: NEG
85105: PUSH
85106: LD_INT 1
85108: NEG
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: LD_INT 3
85116: NEG
85117: PUSH
85118: LD_INT 0
85120: PUSH
85121: EMPTY
85122: LIST
85123: LIST
85124: PUSH
85125: LD_INT 3
85127: NEG
85128: PUSH
85129: LD_INT 1
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: LD_INT 4
85138: NEG
85139: PUSH
85140: LD_INT 1
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 5
85149: NEG
85150: PUSH
85151: LD_INT 0
85153: PUSH
85154: EMPTY
85155: LIST
85156: LIST
85157: PUSH
85158: LD_INT 5
85160: NEG
85161: PUSH
85162: LD_INT 1
85164: NEG
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: PUSH
85170: LD_INT 5
85172: NEG
85173: PUSH
85174: LD_INT 2
85176: NEG
85177: PUSH
85178: EMPTY
85179: LIST
85180: LIST
85181: PUSH
85182: LD_INT 3
85184: NEG
85185: PUSH
85186: LD_INT 2
85188: PUSH
85189: EMPTY
85190: LIST
85191: LIST
85192: PUSH
85193: LD_INT 3
85195: NEG
85196: PUSH
85197: LD_INT 3
85199: NEG
85200: PUSH
85201: EMPTY
85202: LIST
85203: LIST
85204: PUSH
85205: LD_INT 3
85207: NEG
85208: PUSH
85209: LD_INT 4
85211: NEG
85212: PUSH
85213: EMPTY
85214: LIST
85215: LIST
85216: PUSH
85217: LD_INT 2
85219: NEG
85220: PUSH
85221: LD_INT 3
85223: NEG
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: PUSH
85229: LD_INT 2
85231: NEG
85232: PUSH
85233: LD_INT 2
85235: NEG
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: PUSH
85241: LD_INT 3
85243: NEG
85244: PUSH
85245: LD_INT 2
85247: NEG
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 4
85255: NEG
85256: PUSH
85257: LD_INT 3
85259: NEG
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 4
85267: NEG
85268: PUSH
85269: LD_INT 4
85271: NEG
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PUSH
85277: LD_INT 2
85279: NEG
85280: PUSH
85281: LD_INT 4
85283: NEG
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 4
85291: NEG
85292: PUSH
85293: LD_INT 2
85295: NEG
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 0
85303: PUSH
85304: LD_INT 4
85306: NEG
85307: PUSH
85308: EMPTY
85309: LIST
85310: LIST
85311: PUSH
85312: LD_INT 0
85314: PUSH
85315: LD_INT 5
85317: NEG
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: LD_INT 1
85325: PUSH
85326: LD_INT 4
85328: NEG
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 1
85336: PUSH
85337: LD_INT 3
85339: NEG
85340: PUSH
85341: EMPTY
85342: LIST
85343: LIST
85344: PUSH
85345: LD_INT 0
85347: PUSH
85348: LD_INT 3
85350: NEG
85351: PUSH
85352: EMPTY
85353: LIST
85354: LIST
85355: PUSH
85356: LD_INT 1
85358: NEG
85359: PUSH
85360: LD_INT 4
85362: NEG
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: PUSH
85368: LD_INT 1
85370: NEG
85371: PUSH
85372: LD_INT 5
85374: NEG
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: PUSH
85380: LD_INT 2
85382: PUSH
85383: LD_INT 3
85385: NEG
85386: PUSH
85387: EMPTY
85388: LIST
85389: LIST
85390: PUSH
85391: LD_INT 2
85393: NEG
85394: PUSH
85395: LD_INT 5
85397: NEG
85398: PUSH
85399: EMPTY
85400: LIST
85401: LIST
85402: PUSH
85403: LD_INT 3
85405: PUSH
85406: LD_INT 0
85408: PUSH
85409: EMPTY
85410: LIST
85411: LIST
85412: PUSH
85413: LD_INT 3
85415: PUSH
85416: LD_INT 1
85418: NEG
85419: PUSH
85420: EMPTY
85421: LIST
85422: LIST
85423: PUSH
85424: LD_INT 4
85426: PUSH
85427: LD_INT 0
85429: PUSH
85430: EMPTY
85431: LIST
85432: LIST
85433: PUSH
85434: LD_INT 4
85436: PUSH
85437: LD_INT 1
85439: PUSH
85440: EMPTY
85441: LIST
85442: LIST
85443: PUSH
85444: LD_INT 3
85446: PUSH
85447: LD_INT 1
85449: PUSH
85450: EMPTY
85451: LIST
85452: LIST
85453: PUSH
85454: LD_INT 2
85456: PUSH
85457: LD_INT 0
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: PUSH
85464: LD_INT 2
85466: PUSH
85467: LD_INT 1
85469: NEG
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: PUSH
85475: LD_INT 2
85477: PUSH
85478: LD_INT 2
85480: NEG
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: LD_INT 4
85488: PUSH
85489: LD_INT 2
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: PUSH
85496: LD_INT 4
85498: PUSH
85499: LD_INT 4
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 4
85508: PUSH
85509: LD_INT 3
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 5
85518: PUSH
85519: LD_INT 4
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 5
85528: PUSH
85529: LD_INT 5
85531: PUSH
85532: EMPTY
85533: LIST
85534: LIST
85535: PUSH
85536: LD_INT 4
85538: PUSH
85539: LD_INT 5
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: PUSH
85546: LD_INT 3
85548: PUSH
85549: LD_INT 4
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: PUSH
85556: LD_INT 3
85558: PUSH
85559: LD_INT 3
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 5
85568: PUSH
85569: LD_INT 3
85571: PUSH
85572: EMPTY
85573: LIST
85574: LIST
85575: PUSH
85576: LD_INT 3
85578: PUSH
85579: LD_INT 5
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: LIST
85593: LIST
85594: LIST
85595: LIST
85596: LIST
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: LIST
85613: LIST
85614: LIST
85615: LIST
85616: LIST
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: LIST
85631: LIST
85632: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
85633: LD_ADDR_VAR 0 33
85637: PUSH
85638: LD_INT 4
85640: NEG
85641: PUSH
85642: LD_INT 4
85644: NEG
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 4
85652: NEG
85653: PUSH
85654: LD_INT 5
85656: NEG
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: LD_INT 3
85664: NEG
85665: PUSH
85666: LD_INT 4
85668: NEG
85669: PUSH
85670: EMPTY
85671: LIST
85672: LIST
85673: PUSH
85674: LD_INT 3
85676: NEG
85677: PUSH
85678: LD_INT 3
85680: NEG
85681: PUSH
85682: EMPTY
85683: LIST
85684: LIST
85685: PUSH
85686: LD_INT 4
85688: NEG
85689: PUSH
85690: LD_INT 3
85692: NEG
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: LD_INT 5
85700: NEG
85701: PUSH
85702: LD_INT 4
85704: NEG
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: LD_INT 5
85712: NEG
85713: PUSH
85714: LD_INT 5
85716: NEG
85717: PUSH
85718: EMPTY
85719: LIST
85720: LIST
85721: PUSH
85722: LD_INT 3
85724: NEG
85725: PUSH
85726: LD_INT 5
85728: NEG
85729: PUSH
85730: EMPTY
85731: LIST
85732: LIST
85733: PUSH
85734: LD_INT 5
85736: NEG
85737: PUSH
85738: LD_INT 3
85740: NEG
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: PUSH
85746: LD_INT 0
85748: PUSH
85749: LD_INT 3
85751: NEG
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: PUSH
85757: LD_INT 0
85759: PUSH
85760: LD_INT 4
85762: NEG
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: LD_INT 1
85770: PUSH
85771: LD_INT 3
85773: NEG
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 1
85781: PUSH
85782: LD_INT 2
85784: NEG
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 0
85792: PUSH
85793: LD_INT 2
85795: NEG
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: PUSH
85801: LD_INT 1
85803: NEG
85804: PUSH
85805: LD_INT 3
85807: NEG
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: PUSH
85813: LD_INT 1
85815: NEG
85816: PUSH
85817: LD_INT 4
85819: NEG
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 2
85827: PUSH
85828: LD_INT 2
85830: NEG
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 2
85838: NEG
85839: PUSH
85840: LD_INT 4
85842: NEG
85843: PUSH
85844: EMPTY
85845: LIST
85846: LIST
85847: PUSH
85848: LD_INT 4
85850: PUSH
85851: LD_INT 0
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: PUSH
85858: LD_INT 4
85860: PUSH
85861: LD_INT 1
85863: NEG
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: LD_INT 5
85871: PUSH
85872: LD_INT 0
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: PUSH
85879: LD_INT 5
85881: PUSH
85882: LD_INT 1
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 4
85891: PUSH
85892: LD_INT 1
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: PUSH
85899: LD_INT 3
85901: PUSH
85902: LD_INT 0
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 3
85911: PUSH
85912: LD_INT 1
85914: NEG
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 3
85922: PUSH
85923: LD_INT 2
85925: NEG
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 5
85933: PUSH
85934: LD_INT 2
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PUSH
85941: LD_INT 3
85943: PUSH
85944: LD_INT 3
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 3
85953: PUSH
85954: LD_INT 2
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 4
85963: PUSH
85964: LD_INT 3
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: PUSH
85971: LD_INT 4
85973: PUSH
85974: LD_INT 4
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PUSH
85981: LD_INT 3
85983: PUSH
85984: LD_INT 4
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: LD_INT 2
85993: PUSH
85994: LD_INT 3
85996: PUSH
85997: EMPTY
85998: LIST
85999: LIST
86000: PUSH
86001: LD_INT 2
86003: PUSH
86004: LD_INT 2
86006: PUSH
86007: EMPTY
86008: LIST
86009: LIST
86010: PUSH
86011: LD_INT 4
86013: PUSH
86014: LD_INT 2
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: LD_INT 2
86023: PUSH
86024: LD_INT 4
86026: PUSH
86027: EMPTY
86028: LIST
86029: LIST
86030: PUSH
86031: LD_INT 0
86033: PUSH
86034: LD_INT 4
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: PUSH
86041: LD_INT 0
86043: PUSH
86044: LD_INT 3
86046: PUSH
86047: EMPTY
86048: LIST
86049: LIST
86050: PUSH
86051: LD_INT 1
86053: PUSH
86054: LD_INT 4
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 1
86063: PUSH
86064: LD_INT 5
86066: PUSH
86067: EMPTY
86068: LIST
86069: LIST
86070: PUSH
86071: LD_INT 0
86073: PUSH
86074: LD_INT 5
86076: PUSH
86077: EMPTY
86078: LIST
86079: LIST
86080: PUSH
86081: LD_INT 1
86083: NEG
86084: PUSH
86085: LD_INT 4
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: PUSH
86092: LD_INT 1
86094: NEG
86095: PUSH
86096: LD_INT 3
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 2
86105: PUSH
86106: LD_INT 5
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 2
86115: NEG
86116: PUSH
86117: LD_INT 3
86119: PUSH
86120: EMPTY
86121: LIST
86122: LIST
86123: PUSH
86124: EMPTY
86125: LIST
86126: LIST
86127: LIST
86128: LIST
86129: LIST
86130: LIST
86131: LIST
86132: LIST
86133: LIST
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: LIST
86142: LIST
86143: LIST
86144: LIST
86145: LIST
86146: LIST
86147: LIST
86148: LIST
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
86171: LD_ADDR_VAR 0 34
86175: PUSH
86176: LD_INT 0
86178: PUSH
86179: LD_INT 4
86181: NEG
86182: PUSH
86183: EMPTY
86184: LIST
86185: LIST
86186: PUSH
86187: LD_INT 0
86189: PUSH
86190: LD_INT 5
86192: NEG
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 1
86200: PUSH
86201: LD_INT 4
86203: NEG
86204: PUSH
86205: EMPTY
86206: LIST
86207: LIST
86208: PUSH
86209: LD_INT 1
86211: PUSH
86212: LD_INT 3
86214: NEG
86215: PUSH
86216: EMPTY
86217: LIST
86218: LIST
86219: PUSH
86220: LD_INT 0
86222: PUSH
86223: LD_INT 3
86225: NEG
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PUSH
86231: LD_INT 1
86233: NEG
86234: PUSH
86235: LD_INT 4
86237: NEG
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 1
86245: NEG
86246: PUSH
86247: LD_INT 5
86249: NEG
86250: PUSH
86251: EMPTY
86252: LIST
86253: LIST
86254: PUSH
86255: LD_INT 2
86257: PUSH
86258: LD_INT 3
86260: NEG
86261: PUSH
86262: EMPTY
86263: LIST
86264: LIST
86265: PUSH
86266: LD_INT 2
86268: NEG
86269: PUSH
86270: LD_INT 5
86272: NEG
86273: PUSH
86274: EMPTY
86275: LIST
86276: LIST
86277: PUSH
86278: LD_INT 3
86280: PUSH
86281: LD_INT 0
86283: PUSH
86284: EMPTY
86285: LIST
86286: LIST
86287: PUSH
86288: LD_INT 3
86290: PUSH
86291: LD_INT 1
86293: NEG
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 4
86301: PUSH
86302: LD_INT 0
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 4
86311: PUSH
86312: LD_INT 1
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 3
86321: PUSH
86322: LD_INT 1
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 2
86331: PUSH
86332: LD_INT 0
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: PUSH
86339: LD_INT 2
86341: PUSH
86342: LD_INT 1
86344: NEG
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: PUSH
86350: LD_INT 2
86352: PUSH
86353: LD_INT 2
86355: NEG
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: PUSH
86361: LD_INT 4
86363: PUSH
86364: LD_INT 2
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: LD_INT 4
86373: PUSH
86374: LD_INT 4
86376: PUSH
86377: EMPTY
86378: LIST
86379: LIST
86380: PUSH
86381: LD_INT 4
86383: PUSH
86384: LD_INT 3
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: PUSH
86391: LD_INT 5
86393: PUSH
86394: LD_INT 4
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: PUSH
86401: LD_INT 5
86403: PUSH
86404: LD_INT 5
86406: PUSH
86407: EMPTY
86408: LIST
86409: LIST
86410: PUSH
86411: LD_INT 4
86413: PUSH
86414: LD_INT 5
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 3
86423: PUSH
86424: LD_INT 4
86426: PUSH
86427: EMPTY
86428: LIST
86429: LIST
86430: PUSH
86431: LD_INT 3
86433: PUSH
86434: LD_INT 3
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: LD_INT 5
86443: PUSH
86444: LD_INT 3
86446: PUSH
86447: EMPTY
86448: LIST
86449: LIST
86450: PUSH
86451: LD_INT 3
86453: PUSH
86454: LD_INT 5
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PUSH
86461: LD_INT 0
86463: PUSH
86464: LD_INT 3
86466: PUSH
86467: EMPTY
86468: LIST
86469: LIST
86470: PUSH
86471: LD_INT 0
86473: PUSH
86474: LD_INT 2
86476: PUSH
86477: EMPTY
86478: LIST
86479: LIST
86480: PUSH
86481: LD_INT 1
86483: PUSH
86484: LD_INT 3
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: LD_INT 1
86493: PUSH
86494: LD_INT 4
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: LD_INT 0
86503: PUSH
86504: LD_INT 4
86506: PUSH
86507: EMPTY
86508: LIST
86509: LIST
86510: PUSH
86511: LD_INT 1
86513: NEG
86514: PUSH
86515: LD_INT 3
86517: PUSH
86518: EMPTY
86519: LIST
86520: LIST
86521: PUSH
86522: LD_INT 1
86524: NEG
86525: PUSH
86526: LD_INT 2
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 2
86535: PUSH
86536: LD_INT 4
86538: PUSH
86539: EMPTY
86540: LIST
86541: LIST
86542: PUSH
86543: LD_INT 2
86545: NEG
86546: PUSH
86547: LD_INT 2
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: LD_INT 4
86556: NEG
86557: PUSH
86558: LD_INT 0
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PUSH
86565: LD_INT 4
86567: NEG
86568: PUSH
86569: LD_INT 1
86571: NEG
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PUSH
86577: LD_INT 3
86579: NEG
86580: PUSH
86581: LD_INT 0
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: PUSH
86588: LD_INT 3
86590: NEG
86591: PUSH
86592: LD_INT 1
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: PUSH
86599: LD_INT 4
86601: NEG
86602: PUSH
86603: LD_INT 1
86605: PUSH
86606: EMPTY
86607: LIST
86608: LIST
86609: PUSH
86610: LD_INT 5
86612: NEG
86613: PUSH
86614: LD_INT 0
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 5
86623: NEG
86624: PUSH
86625: LD_INT 1
86627: NEG
86628: PUSH
86629: EMPTY
86630: LIST
86631: LIST
86632: PUSH
86633: LD_INT 5
86635: NEG
86636: PUSH
86637: LD_INT 2
86639: NEG
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: PUSH
86645: LD_INT 3
86647: NEG
86648: PUSH
86649: LD_INT 2
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: LIST
86702: ST_TO_ADDR
// end ; end ;
86703: GO 86706
86705: POP
// case btype of b_depot , b_warehouse :
86706: LD_VAR 0 1
86710: PUSH
86711: LD_INT 0
86713: DOUBLE
86714: EQUAL
86715: IFTRUE 86725
86717: LD_INT 1
86719: DOUBLE
86720: EQUAL
86721: IFTRUE 86725
86723: GO 86926
86725: POP
// case nation of nation_american :
86726: LD_VAR 0 5
86730: PUSH
86731: LD_INT 1
86733: DOUBLE
86734: EQUAL
86735: IFTRUE 86739
86737: GO 86795
86739: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
86740: LD_ADDR_VAR 0 9
86744: PUSH
86745: LD_VAR 0 11
86749: PUSH
86750: LD_VAR 0 12
86754: PUSH
86755: LD_VAR 0 13
86759: PUSH
86760: LD_VAR 0 14
86764: PUSH
86765: LD_VAR 0 15
86769: PUSH
86770: LD_VAR 0 16
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: PUSH
86783: LD_VAR 0 4
86787: PUSH
86788: LD_INT 1
86790: PLUS
86791: ARRAY
86792: ST_TO_ADDR
86793: GO 86924
86795: LD_INT 2
86797: DOUBLE
86798: EQUAL
86799: IFTRUE 86803
86801: GO 86859
86803: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
86804: LD_ADDR_VAR 0 9
86808: PUSH
86809: LD_VAR 0 17
86813: PUSH
86814: LD_VAR 0 18
86818: PUSH
86819: LD_VAR 0 19
86823: PUSH
86824: LD_VAR 0 20
86828: PUSH
86829: LD_VAR 0 21
86833: PUSH
86834: LD_VAR 0 22
86838: PUSH
86839: EMPTY
86840: LIST
86841: LIST
86842: LIST
86843: LIST
86844: LIST
86845: LIST
86846: PUSH
86847: LD_VAR 0 4
86851: PUSH
86852: LD_INT 1
86854: PLUS
86855: ARRAY
86856: ST_TO_ADDR
86857: GO 86924
86859: LD_INT 3
86861: DOUBLE
86862: EQUAL
86863: IFTRUE 86867
86865: GO 86923
86867: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
86868: LD_ADDR_VAR 0 9
86872: PUSH
86873: LD_VAR 0 23
86877: PUSH
86878: LD_VAR 0 24
86882: PUSH
86883: LD_VAR 0 25
86887: PUSH
86888: LD_VAR 0 26
86892: PUSH
86893: LD_VAR 0 27
86897: PUSH
86898: LD_VAR 0 28
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: PUSH
86911: LD_VAR 0 4
86915: PUSH
86916: LD_INT 1
86918: PLUS
86919: ARRAY
86920: ST_TO_ADDR
86921: GO 86924
86923: POP
86924: GO 87479
86926: LD_INT 2
86928: DOUBLE
86929: EQUAL
86930: IFTRUE 86940
86932: LD_INT 3
86934: DOUBLE
86935: EQUAL
86936: IFTRUE 86940
86938: GO 86996
86940: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
86941: LD_ADDR_VAR 0 9
86945: PUSH
86946: LD_VAR 0 29
86950: PUSH
86951: LD_VAR 0 30
86955: PUSH
86956: LD_VAR 0 31
86960: PUSH
86961: LD_VAR 0 32
86965: PUSH
86966: LD_VAR 0 33
86970: PUSH
86971: LD_VAR 0 34
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: PUSH
86984: LD_VAR 0 4
86988: PUSH
86989: LD_INT 1
86991: PLUS
86992: ARRAY
86993: ST_TO_ADDR
86994: GO 87479
86996: LD_INT 16
86998: DOUBLE
86999: EQUAL
87000: IFTRUE 87058
87002: LD_INT 17
87004: DOUBLE
87005: EQUAL
87006: IFTRUE 87058
87008: LD_INT 18
87010: DOUBLE
87011: EQUAL
87012: IFTRUE 87058
87014: LD_INT 19
87016: DOUBLE
87017: EQUAL
87018: IFTRUE 87058
87020: LD_INT 22
87022: DOUBLE
87023: EQUAL
87024: IFTRUE 87058
87026: LD_INT 20
87028: DOUBLE
87029: EQUAL
87030: IFTRUE 87058
87032: LD_INT 21
87034: DOUBLE
87035: EQUAL
87036: IFTRUE 87058
87038: LD_INT 23
87040: DOUBLE
87041: EQUAL
87042: IFTRUE 87058
87044: LD_INT 24
87046: DOUBLE
87047: EQUAL
87048: IFTRUE 87058
87050: LD_INT 25
87052: DOUBLE
87053: EQUAL
87054: IFTRUE 87058
87056: GO 87114
87058: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
87059: LD_ADDR_VAR 0 9
87063: PUSH
87064: LD_VAR 0 35
87068: PUSH
87069: LD_VAR 0 36
87073: PUSH
87074: LD_VAR 0 37
87078: PUSH
87079: LD_VAR 0 38
87083: PUSH
87084: LD_VAR 0 39
87088: PUSH
87089: LD_VAR 0 40
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: LIST
87098: LIST
87099: LIST
87100: LIST
87101: PUSH
87102: LD_VAR 0 4
87106: PUSH
87107: LD_INT 1
87109: PLUS
87110: ARRAY
87111: ST_TO_ADDR
87112: GO 87479
87114: LD_INT 6
87116: DOUBLE
87117: EQUAL
87118: IFTRUE 87170
87120: LD_INT 7
87122: DOUBLE
87123: EQUAL
87124: IFTRUE 87170
87126: LD_INT 8
87128: DOUBLE
87129: EQUAL
87130: IFTRUE 87170
87132: LD_INT 13
87134: DOUBLE
87135: EQUAL
87136: IFTRUE 87170
87138: LD_INT 12
87140: DOUBLE
87141: EQUAL
87142: IFTRUE 87170
87144: LD_INT 15
87146: DOUBLE
87147: EQUAL
87148: IFTRUE 87170
87150: LD_INT 11
87152: DOUBLE
87153: EQUAL
87154: IFTRUE 87170
87156: LD_INT 14
87158: DOUBLE
87159: EQUAL
87160: IFTRUE 87170
87162: LD_INT 10
87164: DOUBLE
87165: EQUAL
87166: IFTRUE 87170
87168: GO 87226
87170: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
87171: LD_ADDR_VAR 0 9
87175: PUSH
87176: LD_VAR 0 41
87180: PUSH
87181: LD_VAR 0 42
87185: PUSH
87186: LD_VAR 0 43
87190: PUSH
87191: LD_VAR 0 44
87195: PUSH
87196: LD_VAR 0 45
87200: PUSH
87201: LD_VAR 0 46
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: LIST
87210: LIST
87211: LIST
87212: LIST
87213: PUSH
87214: LD_VAR 0 4
87218: PUSH
87219: LD_INT 1
87221: PLUS
87222: ARRAY
87223: ST_TO_ADDR
87224: GO 87479
87226: LD_INT 36
87228: DOUBLE
87229: EQUAL
87230: IFTRUE 87234
87232: GO 87290
87234: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
87235: LD_ADDR_VAR 0 9
87239: PUSH
87240: LD_VAR 0 47
87244: PUSH
87245: LD_VAR 0 48
87249: PUSH
87250: LD_VAR 0 49
87254: PUSH
87255: LD_VAR 0 50
87259: PUSH
87260: LD_VAR 0 51
87264: PUSH
87265: LD_VAR 0 52
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: PUSH
87278: LD_VAR 0 4
87282: PUSH
87283: LD_INT 1
87285: PLUS
87286: ARRAY
87287: ST_TO_ADDR
87288: GO 87479
87290: LD_INT 4
87292: DOUBLE
87293: EQUAL
87294: IFTRUE 87316
87296: LD_INT 5
87298: DOUBLE
87299: EQUAL
87300: IFTRUE 87316
87302: LD_INT 34
87304: DOUBLE
87305: EQUAL
87306: IFTRUE 87316
87308: LD_INT 37
87310: DOUBLE
87311: EQUAL
87312: IFTRUE 87316
87314: GO 87372
87316: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
87317: LD_ADDR_VAR 0 9
87321: PUSH
87322: LD_VAR 0 53
87326: PUSH
87327: LD_VAR 0 54
87331: PUSH
87332: LD_VAR 0 55
87336: PUSH
87337: LD_VAR 0 56
87341: PUSH
87342: LD_VAR 0 57
87346: PUSH
87347: LD_VAR 0 58
87351: PUSH
87352: EMPTY
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: PUSH
87360: LD_VAR 0 4
87364: PUSH
87365: LD_INT 1
87367: PLUS
87368: ARRAY
87369: ST_TO_ADDR
87370: GO 87479
87372: LD_INT 31
87374: DOUBLE
87375: EQUAL
87376: IFTRUE 87422
87378: LD_INT 32
87380: DOUBLE
87381: EQUAL
87382: IFTRUE 87422
87384: LD_INT 33
87386: DOUBLE
87387: EQUAL
87388: IFTRUE 87422
87390: LD_INT 27
87392: DOUBLE
87393: EQUAL
87394: IFTRUE 87422
87396: LD_INT 26
87398: DOUBLE
87399: EQUAL
87400: IFTRUE 87422
87402: LD_INT 28
87404: DOUBLE
87405: EQUAL
87406: IFTRUE 87422
87408: LD_INT 29
87410: DOUBLE
87411: EQUAL
87412: IFTRUE 87422
87414: LD_INT 30
87416: DOUBLE
87417: EQUAL
87418: IFTRUE 87422
87420: GO 87478
87422: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
87423: LD_ADDR_VAR 0 9
87427: PUSH
87428: LD_VAR 0 59
87432: PUSH
87433: LD_VAR 0 60
87437: PUSH
87438: LD_VAR 0 61
87442: PUSH
87443: LD_VAR 0 62
87447: PUSH
87448: LD_VAR 0 63
87452: PUSH
87453: LD_VAR 0 64
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: PUSH
87466: LD_VAR 0 4
87470: PUSH
87471: LD_INT 1
87473: PLUS
87474: ARRAY
87475: ST_TO_ADDR
87476: GO 87479
87478: POP
// temp_list2 = [ ] ;
87479: LD_ADDR_VAR 0 10
87483: PUSH
87484: EMPTY
87485: ST_TO_ADDR
// for i in temp_list do
87486: LD_ADDR_VAR 0 8
87490: PUSH
87491: LD_VAR 0 9
87495: PUSH
87496: FOR_IN
87497: IFFALSE 87549
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
87499: LD_ADDR_VAR 0 10
87503: PUSH
87504: LD_VAR 0 10
87508: PUSH
87509: LD_VAR 0 8
87513: PUSH
87514: LD_INT 1
87516: ARRAY
87517: PUSH
87518: LD_VAR 0 2
87522: PLUS
87523: PUSH
87524: LD_VAR 0 8
87528: PUSH
87529: LD_INT 2
87531: ARRAY
87532: PUSH
87533: LD_VAR 0 3
87537: PLUS
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: PUSH
87543: EMPTY
87544: LIST
87545: ADD
87546: ST_TO_ADDR
87547: GO 87496
87549: POP
87550: POP
// result = temp_list2 ;
87551: LD_ADDR_VAR 0 7
87555: PUSH
87556: LD_VAR 0 10
87560: ST_TO_ADDR
// end ;
87561: LD_VAR 0 7
87565: RET
// export function EnemyInRange ( unit , dist ) ; begin
87566: LD_INT 0
87568: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
87569: LD_ADDR_VAR 0 3
87573: PUSH
87574: LD_VAR 0 1
87578: PPUSH
87579: CALL_OW 255
87583: PPUSH
87584: LD_VAR 0 1
87588: PPUSH
87589: CALL_OW 250
87593: PPUSH
87594: LD_VAR 0 1
87598: PPUSH
87599: CALL_OW 251
87603: PPUSH
87604: LD_VAR 0 2
87608: PPUSH
87609: CALL 60823 0 4
87613: PUSH
87614: LD_INT 4
87616: ARRAY
87617: ST_TO_ADDR
// end ;
87618: LD_VAR 0 3
87622: RET
// export function PlayerSeeMe ( unit ) ; begin
87623: LD_INT 0
87625: PPUSH
// result := See ( your_side , unit ) ;
87626: LD_ADDR_VAR 0 2
87630: PUSH
87631: LD_OWVAR 2
87635: PPUSH
87636: LD_VAR 0 1
87640: PPUSH
87641: CALL_OW 292
87645: ST_TO_ADDR
// end ;
87646: LD_VAR 0 2
87650: RET
// export function ReverseDir ( unit ) ; begin
87651: LD_INT 0
87653: PPUSH
// if not unit then
87654: LD_VAR 0 1
87658: NOT
87659: IFFALSE 87663
// exit ;
87661: GO 87686
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
87663: LD_ADDR_VAR 0 2
87667: PUSH
87668: LD_VAR 0 1
87672: PPUSH
87673: CALL_OW 254
87677: PUSH
87678: LD_INT 3
87680: PLUS
87681: PUSH
87682: LD_INT 6
87684: MOD
87685: ST_TO_ADDR
// end ;
87686: LD_VAR 0 2
87690: RET
// export function ReverseArray ( array ) ; var i ; begin
87691: LD_INT 0
87693: PPUSH
87694: PPUSH
// if not array then
87695: LD_VAR 0 1
87699: NOT
87700: IFFALSE 87704
// exit ;
87702: GO 87759
// result := [ ] ;
87704: LD_ADDR_VAR 0 2
87708: PUSH
87709: EMPTY
87710: ST_TO_ADDR
// for i := array downto 1 do
87711: LD_ADDR_VAR 0 3
87715: PUSH
87716: DOUBLE
87717: LD_VAR 0 1
87721: INC
87722: ST_TO_ADDR
87723: LD_INT 1
87725: PUSH
87726: FOR_DOWNTO
87727: IFFALSE 87757
// result := Join ( result , array [ i ] ) ;
87729: LD_ADDR_VAR 0 2
87733: PUSH
87734: LD_VAR 0 2
87738: PPUSH
87739: LD_VAR 0 1
87743: PUSH
87744: LD_VAR 0 3
87748: ARRAY
87749: PPUSH
87750: CALL 92601 0 2
87754: ST_TO_ADDR
87755: GO 87726
87757: POP
87758: POP
// end ;
87759: LD_VAR 0 2
87763: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
87764: LD_INT 0
87766: PPUSH
87767: PPUSH
87768: PPUSH
87769: PPUSH
87770: PPUSH
87771: PPUSH
// if not unit or not hexes then
87772: LD_VAR 0 1
87776: NOT
87777: IFTRUE 87786
87779: PUSH
87780: LD_VAR 0 2
87784: NOT
87785: OR
87786: IFFALSE 87790
// exit ;
87788: GO 87913
// dist := 9999 ;
87790: LD_ADDR_VAR 0 5
87794: PUSH
87795: LD_INT 9999
87797: ST_TO_ADDR
// for i = 1 to hexes do
87798: LD_ADDR_VAR 0 4
87802: PUSH
87803: DOUBLE
87804: LD_INT 1
87806: DEC
87807: ST_TO_ADDR
87808: LD_VAR 0 2
87812: PUSH
87813: FOR_TO
87814: IFFALSE 87901
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
87816: LD_ADDR_VAR 0 6
87820: PUSH
87821: LD_VAR 0 1
87825: PPUSH
87826: LD_VAR 0 2
87830: PUSH
87831: LD_VAR 0 4
87835: ARRAY
87836: PUSH
87837: LD_INT 1
87839: ARRAY
87840: PPUSH
87841: LD_VAR 0 2
87845: PUSH
87846: LD_VAR 0 4
87850: ARRAY
87851: PUSH
87852: LD_INT 2
87854: ARRAY
87855: PPUSH
87856: CALL_OW 297
87860: ST_TO_ADDR
// if tdist < dist then
87861: LD_VAR 0 6
87865: PUSH
87866: LD_VAR 0 5
87870: LESS
87871: IFFALSE 87899
// begin hex := hexes [ i ] ;
87873: LD_ADDR_VAR 0 8
87877: PUSH
87878: LD_VAR 0 2
87882: PUSH
87883: LD_VAR 0 4
87887: ARRAY
87888: ST_TO_ADDR
// dist := tdist ;
87889: LD_ADDR_VAR 0 5
87893: PUSH
87894: LD_VAR 0 6
87898: ST_TO_ADDR
// end ; end ;
87899: GO 87813
87901: POP
87902: POP
// result := hex ;
87903: LD_ADDR_VAR 0 3
87907: PUSH
87908: LD_VAR 0 8
87912: ST_TO_ADDR
// end ;
87913: LD_VAR 0 3
87917: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
87918: LD_INT 0
87920: PPUSH
87921: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87922: LD_VAR 0 1
87926: NOT
87927: IFTRUE 87966
87929: PUSH
87930: LD_VAR 0 1
87934: PUSH
87935: LD_INT 21
87937: PUSH
87938: LD_INT 2
87940: PUSH
87941: EMPTY
87942: LIST
87943: LIST
87944: PUSH
87945: LD_INT 23
87947: PUSH
87948: LD_INT 2
87950: PUSH
87951: EMPTY
87952: LIST
87953: LIST
87954: PUSH
87955: EMPTY
87956: LIST
87957: LIST
87958: PPUSH
87959: CALL_OW 69
87963: IN
87964: NOT
87965: OR
87966: IFFALSE 87970
// exit ;
87968: GO 88017
// for i = 1 to 3 do
87970: LD_ADDR_VAR 0 3
87974: PUSH
87975: DOUBLE
87976: LD_INT 1
87978: DEC
87979: ST_TO_ADDR
87980: LD_INT 3
87982: PUSH
87983: FOR_TO
87984: IFFALSE 88015
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
87986: LD_VAR 0 1
87990: PPUSH
87991: CALL_OW 250
87995: PPUSH
87996: LD_VAR 0 1
88000: PPUSH
88001: CALL_OW 251
88005: PPUSH
88006: LD_INT 1
88008: PPUSH
88009: CALL_OW 453
88013: GO 87983
88015: POP
88016: POP
// end ;
88017: LD_VAR 0 2
88021: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
88022: LD_INT 0
88024: PPUSH
88025: PPUSH
88026: PPUSH
88027: PPUSH
88028: PPUSH
88029: PPUSH
// if not unit or not enemy_unit then
88030: LD_VAR 0 1
88034: NOT
88035: IFTRUE 88044
88037: PUSH
88038: LD_VAR 0 2
88042: NOT
88043: OR
88044: IFFALSE 88048
// exit ;
88046: GO 88519
// if GetLives ( i ) < 250 then
88048: LD_VAR 0 4
88052: PPUSH
88053: CALL_OW 256
88057: PUSH
88058: LD_INT 250
88060: LESS
88061: IFFALSE 88074
// begin ComAutodestruct ( i ) ;
88063: LD_VAR 0 4
88067: PPUSH
88068: CALL 87918 0 1
// exit ;
88072: GO 88519
// end ; x := GetX ( enemy_unit ) ;
88074: LD_ADDR_VAR 0 7
88078: PUSH
88079: LD_VAR 0 2
88083: PPUSH
88084: CALL_OW 250
88088: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
88089: LD_ADDR_VAR 0 8
88093: PUSH
88094: LD_VAR 0 2
88098: PPUSH
88099: CALL_OW 251
88103: ST_TO_ADDR
// if not x or not y then
88104: LD_VAR 0 7
88108: NOT
88109: IFTRUE 88118
88111: PUSH
88112: LD_VAR 0 8
88116: NOT
88117: OR
88118: IFFALSE 88122
// exit ;
88120: GO 88519
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
88122: LD_ADDR_VAR 0 6
88126: PUSH
88127: LD_VAR 0 7
88131: PPUSH
88132: LD_INT 0
88134: PPUSH
88135: LD_INT 4
88137: PPUSH
88138: CALL_OW 272
88142: PUSH
88143: LD_VAR 0 8
88147: PPUSH
88148: LD_INT 0
88150: PPUSH
88151: LD_INT 4
88153: PPUSH
88154: CALL_OW 273
88158: PUSH
88159: EMPTY
88160: LIST
88161: LIST
88162: PUSH
88163: LD_VAR 0 7
88167: PPUSH
88168: LD_INT 1
88170: PPUSH
88171: LD_INT 4
88173: PPUSH
88174: CALL_OW 272
88178: PUSH
88179: LD_VAR 0 8
88183: PPUSH
88184: LD_INT 1
88186: PPUSH
88187: LD_INT 4
88189: PPUSH
88190: CALL_OW 273
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_VAR 0 7
88203: PPUSH
88204: LD_INT 2
88206: PPUSH
88207: LD_INT 4
88209: PPUSH
88210: CALL_OW 272
88214: PUSH
88215: LD_VAR 0 8
88219: PPUSH
88220: LD_INT 2
88222: PPUSH
88223: LD_INT 4
88225: PPUSH
88226: CALL_OW 273
88230: PUSH
88231: EMPTY
88232: LIST
88233: LIST
88234: PUSH
88235: LD_VAR 0 7
88239: PPUSH
88240: LD_INT 3
88242: PPUSH
88243: LD_INT 4
88245: PPUSH
88246: CALL_OW 272
88250: PUSH
88251: LD_VAR 0 8
88255: PPUSH
88256: LD_INT 3
88258: PPUSH
88259: LD_INT 4
88261: PPUSH
88262: CALL_OW 273
88266: PUSH
88267: EMPTY
88268: LIST
88269: LIST
88270: PUSH
88271: LD_VAR 0 7
88275: PPUSH
88276: LD_INT 4
88278: PPUSH
88279: LD_INT 4
88281: PPUSH
88282: CALL_OW 272
88286: PUSH
88287: LD_VAR 0 8
88291: PPUSH
88292: LD_INT 4
88294: PPUSH
88295: LD_INT 4
88297: PPUSH
88298: CALL_OW 273
88302: PUSH
88303: EMPTY
88304: LIST
88305: LIST
88306: PUSH
88307: LD_VAR 0 7
88311: PPUSH
88312: LD_INT 5
88314: PPUSH
88315: LD_INT 4
88317: PPUSH
88318: CALL_OW 272
88322: PUSH
88323: LD_VAR 0 8
88327: PPUSH
88328: LD_INT 5
88330: PPUSH
88331: LD_INT 4
88333: PPUSH
88334: CALL_OW 273
88338: PUSH
88339: EMPTY
88340: LIST
88341: LIST
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: LIST
88347: LIST
88348: LIST
88349: LIST
88350: ST_TO_ADDR
// for i = tmp downto 1 do
88351: LD_ADDR_VAR 0 4
88355: PUSH
88356: DOUBLE
88357: LD_VAR 0 6
88361: INC
88362: ST_TO_ADDR
88363: LD_INT 1
88365: PUSH
88366: FOR_DOWNTO
88367: IFFALSE 88470
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
88369: LD_VAR 0 6
88373: PUSH
88374: LD_VAR 0 4
88378: ARRAY
88379: PUSH
88380: LD_INT 1
88382: ARRAY
88383: PPUSH
88384: LD_VAR 0 6
88388: PUSH
88389: LD_VAR 0 4
88393: ARRAY
88394: PUSH
88395: LD_INT 2
88397: ARRAY
88398: PPUSH
88399: CALL_OW 488
88403: NOT
88404: IFTRUE 88446
88406: PUSH
88407: LD_VAR 0 6
88411: PUSH
88412: LD_VAR 0 4
88416: ARRAY
88417: PUSH
88418: LD_INT 1
88420: ARRAY
88421: PPUSH
88422: LD_VAR 0 6
88426: PUSH
88427: LD_VAR 0 4
88431: ARRAY
88432: PUSH
88433: LD_INT 2
88435: ARRAY
88436: PPUSH
88437: CALL_OW 428
88441: PUSH
88442: LD_INT 0
88444: NONEQUAL
88445: OR
88446: IFFALSE 88468
// tmp := Delete ( tmp , i ) ;
88448: LD_ADDR_VAR 0 6
88452: PUSH
88453: LD_VAR 0 6
88457: PPUSH
88458: LD_VAR 0 4
88462: PPUSH
88463: CALL_OW 3
88467: ST_TO_ADDR
88468: GO 88366
88470: POP
88471: POP
// j := GetClosestHex ( unit , tmp ) ;
88472: LD_ADDR_VAR 0 5
88476: PUSH
88477: LD_VAR 0 1
88481: PPUSH
88482: LD_VAR 0 6
88486: PPUSH
88487: CALL 87764 0 2
88491: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
88492: LD_VAR 0 1
88496: PPUSH
88497: LD_VAR 0 5
88501: PUSH
88502: LD_INT 1
88504: ARRAY
88505: PPUSH
88506: LD_VAR 0 5
88510: PUSH
88511: LD_INT 2
88513: ARRAY
88514: PPUSH
88515: CALL_OW 111
// end ;
88519: LD_VAR 0 3
88523: RET
// export function PrepareApemanSoldier ( ) ; begin
88524: LD_INT 0
88526: PPUSH
// uc_nation := 0 ;
88527: LD_ADDR_OWVAR 21
88531: PUSH
88532: LD_INT 0
88534: ST_TO_ADDR
// hc_sex := sex_male ;
88535: LD_ADDR_OWVAR 27
88539: PUSH
88540: LD_INT 1
88542: ST_TO_ADDR
// hc_name :=  ;
88543: LD_ADDR_OWVAR 26
88547: PUSH
88548: LD_STRING 
88550: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
88551: LD_ADDR_OWVAR 28
88555: PUSH
88556: LD_INT 15
88558: ST_TO_ADDR
// hc_gallery :=  ;
88559: LD_ADDR_OWVAR 33
88563: PUSH
88564: LD_STRING 
88566: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
88567: LD_ADDR_OWVAR 31
88571: PUSH
88572: LD_INT 0
88574: PPUSH
88575: LD_INT 3
88577: PPUSH
88578: CALL_OW 12
88582: PUSH
88583: LD_INT 0
88585: PPUSH
88586: LD_INT 3
88588: PPUSH
88589: CALL_OW 12
88593: PUSH
88594: LD_INT 0
88596: PUSH
88597: LD_INT 0
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: LIST
88604: LIST
88605: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88606: LD_ADDR_OWVAR 29
88610: PUSH
88611: LD_INT 12
88613: PUSH
88614: LD_INT 12
88616: PUSH
88617: EMPTY
88618: LIST
88619: LIST
88620: ST_TO_ADDR
// end ;
88621: LD_VAR 0 1
88625: RET
// export function PrepareApemanEngineer ( ) ; begin
88626: LD_INT 0
88628: PPUSH
// uc_nation := 0 ;
88629: LD_ADDR_OWVAR 21
88633: PUSH
88634: LD_INT 0
88636: ST_TO_ADDR
// hc_sex := sex_male ;
88637: LD_ADDR_OWVAR 27
88641: PUSH
88642: LD_INT 1
88644: ST_TO_ADDR
// hc_name :=  ;
88645: LD_ADDR_OWVAR 26
88649: PUSH
88650: LD_STRING 
88652: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
88653: LD_ADDR_OWVAR 28
88657: PUSH
88658: LD_INT 16
88660: ST_TO_ADDR
// hc_gallery :=  ;
88661: LD_ADDR_OWVAR 33
88665: PUSH
88666: LD_STRING 
88668: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
88669: LD_ADDR_OWVAR 31
88673: PUSH
88674: LD_INT 0
88676: PPUSH
88677: LD_INT 3
88679: PPUSH
88680: CALL_OW 12
88684: PUSH
88685: LD_INT 0
88687: PPUSH
88688: LD_INT 3
88690: PPUSH
88691: CALL_OW 12
88695: PUSH
88696: LD_INT 0
88698: PUSH
88699: LD_INT 0
88701: PUSH
88702: EMPTY
88703: LIST
88704: LIST
88705: LIST
88706: LIST
88707: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88708: LD_ADDR_OWVAR 29
88712: PUSH
88713: LD_INT 12
88715: PUSH
88716: LD_INT 12
88718: PUSH
88719: EMPTY
88720: LIST
88721: LIST
88722: ST_TO_ADDR
// end ;
88723: LD_VAR 0 1
88727: RET
// export function PrepareApeman ( agressivity ) ; begin
88728: LD_INT 0
88730: PPUSH
// uc_side := 0 ;
88731: LD_ADDR_OWVAR 20
88735: PUSH
88736: LD_INT 0
88738: ST_TO_ADDR
// uc_nation := 0 ;
88739: LD_ADDR_OWVAR 21
88743: PUSH
88744: LD_INT 0
88746: ST_TO_ADDR
// hc_sex := sex_male ;
88747: LD_ADDR_OWVAR 27
88751: PUSH
88752: LD_INT 1
88754: ST_TO_ADDR
// hc_class := class_apeman ;
88755: LD_ADDR_OWVAR 28
88759: PUSH
88760: LD_INT 12
88762: ST_TO_ADDR
// hc_gallery :=  ;
88763: LD_ADDR_OWVAR 33
88767: PUSH
88768: LD_STRING 
88770: ST_TO_ADDR
// hc_name :=  ;
88771: LD_ADDR_OWVAR 26
88775: PUSH
88776: LD_STRING 
88778: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88779: LD_ADDR_OWVAR 29
88783: PUSH
88784: LD_INT 12
88786: PUSH
88787: LD_INT 12
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: ST_TO_ADDR
// if agressivity = 0 then
88794: LD_VAR 0 1
88798: PUSH
88799: LD_INT 0
88801: EQUAL
88802: IFFALSE 88814
// hc_agressivity := 0 else
88804: LD_ADDR_OWVAR 35
88808: PUSH
88809: LD_INT 0
88811: ST_TO_ADDR
88812: GO 88835
// hc_agressivity := rand ( - agressivity , agressivity ) ;
88814: LD_ADDR_OWVAR 35
88818: PUSH
88819: LD_VAR 0 1
88823: NEG
88824: PPUSH
88825: LD_VAR 0 1
88829: PPUSH
88830: CALL_OW 12
88834: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
88835: LD_ADDR_OWVAR 31
88839: PUSH
88840: LD_INT 0
88842: PPUSH
88843: LD_INT 3
88845: PPUSH
88846: CALL_OW 12
88850: PUSH
88851: LD_INT 0
88853: PPUSH
88854: LD_INT 3
88856: PPUSH
88857: CALL_OW 12
88861: PUSH
88862: LD_INT 0
88864: PUSH
88865: LD_INT 0
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: LIST
88872: LIST
88873: ST_TO_ADDR
// end ;
88874: LD_VAR 0 2
88878: RET
// export function PrepareTiger ( agressivity ) ; begin
88879: LD_INT 0
88881: PPUSH
// uc_side := 0 ;
88882: LD_ADDR_OWVAR 20
88886: PUSH
88887: LD_INT 0
88889: ST_TO_ADDR
// uc_nation := 0 ;
88890: LD_ADDR_OWVAR 21
88894: PUSH
88895: LD_INT 0
88897: ST_TO_ADDR
// InitHc ;
88898: CALL_OW 19
// hc_class := class_tiger ;
88902: LD_ADDR_OWVAR 28
88906: PUSH
88907: LD_INT 14
88909: ST_TO_ADDR
// hc_gallery :=  ;
88910: LD_ADDR_OWVAR 33
88914: PUSH
88915: LD_STRING 
88917: ST_TO_ADDR
// hc_name :=  ;
88918: LD_ADDR_OWVAR 26
88922: PUSH
88923: LD_STRING 
88925: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
88926: LD_ADDR_OWVAR 35
88930: PUSH
88931: LD_VAR 0 1
88935: NEG
88936: PPUSH
88937: LD_VAR 0 1
88941: PPUSH
88942: CALL_OW 12
88946: ST_TO_ADDR
// end ;
88947: LD_VAR 0 2
88951: RET
// export function PrepareEnchidna ( ) ; begin
88952: LD_INT 0
88954: PPUSH
// uc_side := 0 ;
88955: LD_ADDR_OWVAR 20
88959: PUSH
88960: LD_INT 0
88962: ST_TO_ADDR
// uc_nation := 0 ;
88963: LD_ADDR_OWVAR 21
88967: PUSH
88968: LD_INT 0
88970: ST_TO_ADDR
// InitHc ;
88971: CALL_OW 19
// hc_class := class_baggie ;
88975: LD_ADDR_OWVAR 28
88979: PUSH
88980: LD_INT 13
88982: ST_TO_ADDR
// hc_gallery :=  ;
88983: LD_ADDR_OWVAR 33
88987: PUSH
88988: LD_STRING 
88990: ST_TO_ADDR
// hc_name :=  ;
88991: LD_ADDR_OWVAR 26
88995: PUSH
88996: LD_STRING 
88998: ST_TO_ADDR
// end ;
88999: LD_VAR 0 1
89003: RET
// export function PrepareFrog ( ) ; begin
89004: LD_INT 0
89006: PPUSH
// uc_side := 0 ;
89007: LD_ADDR_OWVAR 20
89011: PUSH
89012: LD_INT 0
89014: ST_TO_ADDR
// uc_nation := 0 ;
89015: LD_ADDR_OWVAR 21
89019: PUSH
89020: LD_INT 0
89022: ST_TO_ADDR
// InitHc ;
89023: CALL_OW 19
// hc_class := class_frog ;
89027: LD_ADDR_OWVAR 28
89031: PUSH
89032: LD_INT 19
89034: ST_TO_ADDR
// hc_gallery :=  ;
89035: LD_ADDR_OWVAR 33
89039: PUSH
89040: LD_STRING 
89042: ST_TO_ADDR
// hc_name :=  ;
89043: LD_ADDR_OWVAR 26
89047: PUSH
89048: LD_STRING 
89050: ST_TO_ADDR
// end ;
89051: LD_VAR 0 1
89055: RET
// export function PrepareFish ( ) ; begin
89056: LD_INT 0
89058: PPUSH
// uc_side := 0 ;
89059: LD_ADDR_OWVAR 20
89063: PUSH
89064: LD_INT 0
89066: ST_TO_ADDR
// uc_nation := 0 ;
89067: LD_ADDR_OWVAR 21
89071: PUSH
89072: LD_INT 0
89074: ST_TO_ADDR
// InitHc ;
89075: CALL_OW 19
// hc_class := class_fish ;
89079: LD_ADDR_OWVAR 28
89083: PUSH
89084: LD_INT 20
89086: ST_TO_ADDR
// hc_gallery :=  ;
89087: LD_ADDR_OWVAR 33
89091: PUSH
89092: LD_STRING 
89094: ST_TO_ADDR
// hc_name :=  ;
89095: LD_ADDR_OWVAR 26
89099: PUSH
89100: LD_STRING 
89102: ST_TO_ADDR
// end ;
89103: LD_VAR 0 1
89107: RET
// export function PrepareBird ( ) ; begin
89108: LD_INT 0
89110: PPUSH
// uc_side := 0 ;
89111: LD_ADDR_OWVAR 20
89115: PUSH
89116: LD_INT 0
89118: ST_TO_ADDR
// uc_nation := 0 ;
89119: LD_ADDR_OWVAR 21
89123: PUSH
89124: LD_INT 0
89126: ST_TO_ADDR
// InitHc ;
89127: CALL_OW 19
// hc_class := class_phororhacos ;
89131: LD_ADDR_OWVAR 28
89135: PUSH
89136: LD_INT 18
89138: ST_TO_ADDR
// hc_gallery :=  ;
89139: LD_ADDR_OWVAR 33
89143: PUSH
89144: LD_STRING 
89146: ST_TO_ADDR
// hc_name :=  ;
89147: LD_ADDR_OWVAR 26
89151: PUSH
89152: LD_STRING 
89154: ST_TO_ADDR
// end ;
89155: LD_VAR 0 1
89159: RET
// export function PrepareHorse ( ) ; begin
89160: LD_INT 0
89162: PPUSH
// uc_side := 0 ;
89163: LD_ADDR_OWVAR 20
89167: PUSH
89168: LD_INT 0
89170: ST_TO_ADDR
// uc_nation := 0 ;
89171: LD_ADDR_OWVAR 21
89175: PUSH
89176: LD_INT 0
89178: ST_TO_ADDR
// InitHc ;
89179: CALL_OW 19
// hc_class := class_horse ;
89183: LD_ADDR_OWVAR 28
89187: PUSH
89188: LD_INT 21
89190: ST_TO_ADDR
// hc_gallery :=  ;
89191: LD_ADDR_OWVAR 33
89195: PUSH
89196: LD_STRING 
89198: ST_TO_ADDR
// hc_name :=  ;
89199: LD_ADDR_OWVAR 26
89203: PUSH
89204: LD_STRING 
89206: ST_TO_ADDR
// end ;
89207: LD_VAR 0 1
89211: RET
// export function PrepareMastodont ( ) ; begin
89212: LD_INT 0
89214: PPUSH
// uc_side := 0 ;
89215: LD_ADDR_OWVAR 20
89219: PUSH
89220: LD_INT 0
89222: ST_TO_ADDR
// uc_nation := 0 ;
89223: LD_ADDR_OWVAR 21
89227: PUSH
89228: LD_INT 0
89230: ST_TO_ADDR
// vc_chassis := class_mastodont ;
89231: LD_ADDR_OWVAR 37
89235: PUSH
89236: LD_INT 31
89238: ST_TO_ADDR
// vc_control := control_rider ;
89239: LD_ADDR_OWVAR 38
89243: PUSH
89244: LD_INT 4
89246: ST_TO_ADDR
// end ;
89247: LD_VAR 0 1
89251: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
89252: LD_INT 0
89254: PPUSH
89255: PPUSH
89256: PPUSH
// uc_side = 0 ;
89257: LD_ADDR_OWVAR 20
89261: PUSH
89262: LD_INT 0
89264: ST_TO_ADDR
// uc_nation = 0 ;
89265: LD_ADDR_OWVAR 21
89269: PUSH
89270: LD_INT 0
89272: ST_TO_ADDR
// InitHc_All ( ) ;
89273: CALL_OW 584
// InitVc ;
89277: CALL_OW 20
// if mastodonts then
89281: LD_VAR 0 6
89285: IFFALSE 89352
// for i = 1 to mastodonts do
89287: LD_ADDR_VAR 0 11
89291: PUSH
89292: DOUBLE
89293: LD_INT 1
89295: DEC
89296: ST_TO_ADDR
89297: LD_VAR 0 6
89301: PUSH
89302: FOR_TO
89303: IFFALSE 89350
// begin vc_chassis := 31 ;
89305: LD_ADDR_OWVAR 37
89309: PUSH
89310: LD_INT 31
89312: ST_TO_ADDR
// vc_control := control_rider ;
89313: LD_ADDR_OWVAR 38
89317: PUSH
89318: LD_INT 4
89320: ST_TO_ADDR
// animal := CreateVehicle ;
89321: LD_ADDR_VAR 0 12
89325: PUSH
89326: CALL_OW 45
89330: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89331: LD_VAR 0 12
89335: PPUSH
89336: LD_VAR 0 8
89340: PPUSH
89341: LD_INT 0
89343: PPUSH
89344: CALL 91494 0 3
// end ;
89348: GO 89302
89350: POP
89351: POP
// if horses then
89352: LD_VAR 0 5
89356: IFFALSE 89423
// for i = 1 to horses do
89358: LD_ADDR_VAR 0 11
89362: PUSH
89363: DOUBLE
89364: LD_INT 1
89366: DEC
89367: ST_TO_ADDR
89368: LD_VAR 0 5
89372: PUSH
89373: FOR_TO
89374: IFFALSE 89421
// begin hc_class := 21 ;
89376: LD_ADDR_OWVAR 28
89380: PUSH
89381: LD_INT 21
89383: ST_TO_ADDR
// hc_gallery :=  ;
89384: LD_ADDR_OWVAR 33
89388: PUSH
89389: LD_STRING 
89391: ST_TO_ADDR
// animal := CreateHuman ;
89392: LD_ADDR_VAR 0 12
89396: PUSH
89397: CALL_OW 44
89401: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89402: LD_VAR 0 12
89406: PPUSH
89407: LD_VAR 0 8
89411: PPUSH
89412: LD_INT 0
89414: PPUSH
89415: CALL 91494 0 3
// end ;
89419: GO 89373
89421: POP
89422: POP
// if birds then
89423: LD_VAR 0 1
89427: IFFALSE 89494
// for i = 1 to birds do
89429: LD_ADDR_VAR 0 11
89433: PUSH
89434: DOUBLE
89435: LD_INT 1
89437: DEC
89438: ST_TO_ADDR
89439: LD_VAR 0 1
89443: PUSH
89444: FOR_TO
89445: IFFALSE 89492
// begin hc_class := 18 ;
89447: LD_ADDR_OWVAR 28
89451: PUSH
89452: LD_INT 18
89454: ST_TO_ADDR
// hc_gallery =  ;
89455: LD_ADDR_OWVAR 33
89459: PUSH
89460: LD_STRING 
89462: ST_TO_ADDR
// animal := CreateHuman ;
89463: LD_ADDR_VAR 0 12
89467: PUSH
89468: CALL_OW 44
89472: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89473: LD_VAR 0 12
89477: PPUSH
89478: LD_VAR 0 8
89482: PPUSH
89483: LD_INT 0
89485: PPUSH
89486: CALL 91494 0 3
// end ;
89490: GO 89444
89492: POP
89493: POP
// if tigers then
89494: LD_VAR 0 2
89498: IFFALSE 89582
// for i = 1 to tigers do
89500: LD_ADDR_VAR 0 11
89504: PUSH
89505: DOUBLE
89506: LD_INT 1
89508: DEC
89509: ST_TO_ADDR
89510: LD_VAR 0 2
89514: PUSH
89515: FOR_TO
89516: IFFALSE 89580
// begin hc_class = class_tiger ;
89518: LD_ADDR_OWVAR 28
89522: PUSH
89523: LD_INT 14
89525: ST_TO_ADDR
// hc_gallery =  ;
89526: LD_ADDR_OWVAR 33
89530: PUSH
89531: LD_STRING 
89533: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
89534: LD_ADDR_OWVAR 35
89538: PUSH
89539: LD_INT 7
89541: NEG
89542: PPUSH
89543: LD_INT 7
89545: PPUSH
89546: CALL_OW 12
89550: ST_TO_ADDR
// animal := CreateHuman ;
89551: LD_ADDR_VAR 0 12
89555: PUSH
89556: CALL_OW 44
89560: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89561: LD_VAR 0 12
89565: PPUSH
89566: LD_VAR 0 8
89570: PPUSH
89571: LD_INT 0
89573: PPUSH
89574: CALL 91494 0 3
// end ;
89578: GO 89515
89580: POP
89581: POP
// if apemans then
89582: LD_VAR 0 3
89586: IFFALSE 89709
// for i = 1 to apemans do
89588: LD_ADDR_VAR 0 11
89592: PUSH
89593: DOUBLE
89594: LD_INT 1
89596: DEC
89597: ST_TO_ADDR
89598: LD_VAR 0 3
89602: PUSH
89603: FOR_TO
89604: IFFALSE 89707
// begin hc_class = class_apeman ;
89606: LD_ADDR_OWVAR 28
89610: PUSH
89611: LD_INT 12
89613: ST_TO_ADDR
// hc_gallery =  ;
89614: LD_ADDR_OWVAR 33
89618: PUSH
89619: LD_STRING 
89621: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
89622: LD_ADDR_OWVAR 35
89626: PUSH
89627: LD_INT 2
89629: NEG
89630: PPUSH
89631: LD_INT 2
89633: PPUSH
89634: CALL_OW 12
89638: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
89639: LD_ADDR_OWVAR 31
89643: PUSH
89644: LD_INT 1
89646: PPUSH
89647: LD_INT 3
89649: PPUSH
89650: CALL_OW 12
89654: PUSH
89655: LD_INT 1
89657: PPUSH
89658: LD_INT 3
89660: PPUSH
89661: CALL_OW 12
89665: PUSH
89666: LD_INT 0
89668: PUSH
89669: LD_INT 0
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: LIST
89676: LIST
89677: ST_TO_ADDR
// animal := CreateHuman ;
89678: LD_ADDR_VAR 0 12
89682: PUSH
89683: CALL_OW 44
89687: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89688: LD_VAR 0 12
89692: PPUSH
89693: LD_VAR 0 8
89697: PPUSH
89698: LD_INT 0
89700: PPUSH
89701: CALL 91494 0 3
// end ;
89705: GO 89603
89707: POP
89708: POP
// if enchidnas then
89709: LD_VAR 0 4
89713: IFFALSE 89780
// for i = 1 to enchidnas do
89715: LD_ADDR_VAR 0 11
89719: PUSH
89720: DOUBLE
89721: LD_INT 1
89723: DEC
89724: ST_TO_ADDR
89725: LD_VAR 0 4
89729: PUSH
89730: FOR_TO
89731: IFFALSE 89778
// begin hc_class = 13 ;
89733: LD_ADDR_OWVAR 28
89737: PUSH
89738: LD_INT 13
89740: ST_TO_ADDR
// hc_gallery =  ;
89741: LD_ADDR_OWVAR 33
89745: PUSH
89746: LD_STRING 
89748: ST_TO_ADDR
// animal := CreateHuman ;
89749: LD_ADDR_VAR 0 12
89753: PUSH
89754: CALL_OW 44
89758: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89759: LD_VAR 0 12
89763: PPUSH
89764: LD_VAR 0 8
89768: PPUSH
89769: LD_INT 0
89771: PPUSH
89772: CALL 91494 0 3
// end ;
89776: GO 89730
89778: POP
89779: POP
// if fishes then
89780: LD_VAR 0 7
89784: IFFALSE 89851
// for i = 1 to fishes do
89786: LD_ADDR_VAR 0 11
89790: PUSH
89791: DOUBLE
89792: LD_INT 1
89794: DEC
89795: ST_TO_ADDR
89796: LD_VAR 0 7
89800: PUSH
89801: FOR_TO
89802: IFFALSE 89849
// begin hc_class = 20 ;
89804: LD_ADDR_OWVAR 28
89808: PUSH
89809: LD_INT 20
89811: ST_TO_ADDR
// hc_gallery =  ;
89812: LD_ADDR_OWVAR 33
89816: PUSH
89817: LD_STRING 
89819: ST_TO_ADDR
// animal := CreateHuman ;
89820: LD_ADDR_VAR 0 12
89824: PUSH
89825: CALL_OW 44
89829: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
89830: LD_VAR 0 12
89834: PPUSH
89835: LD_VAR 0 9
89839: PPUSH
89840: LD_INT 0
89842: PPUSH
89843: CALL 91494 0 3
// end ;
89847: GO 89801
89849: POP
89850: POP
// end ;
89851: LD_VAR 0 10
89855: RET
// export function WantHeal ( sci , unit ) ; begin
89856: LD_INT 0
89858: PPUSH
// if GetTaskList ( sci ) > 0 then
89859: LD_VAR 0 1
89863: PPUSH
89864: CALL_OW 437
89868: PUSH
89869: LD_INT 0
89871: GREATER
89872: IFFALSE 89944
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
89874: LD_VAR 0 1
89878: PPUSH
89879: CALL_OW 437
89883: PUSH
89884: LD_INT 1
89886: ARRAY
89887: PUSH
89888: LD_INT 1
89890: ARRAY
89891: PUSH
89892: LD_STRING l
89894: EQUAL
89895: IFFALSE 89922
89897: PUSH
89898: LD_VAR 0 1
89902: PPUSH
89903: CALL_OW 437
89907: PUSH
89908: LD_INT 1
89910: ARRAY
89911: PUSH
89912: LD_INT 4
89914: ARRAY
89915: PUSH
89916: LD_VAR 0 2
89920: EQUAL
89921: AND
89922: IFFALSE 89934
// result := true else
89924: LD_ADDR_VAR 0 3
89928: PUSH
89929: LD_INT 1
89931: ST_TO_ADDR
89932: GO 89942
// result := false ;
89934: LD_ADDR_VAR 0 3
89938: PUSH
89939: LD_INT 0
89941: ST_TO_ADDR
// end else
89942: GO 89952
// result := false ;
89944: LD_ADDR_VAR 0 3
89948: PUSH
89949: LD_INT 0
89951: ST_TO_ADDR
// end ;
89952: LD_VAR 0 3
89956: RET
// export function HealTarget ( sci ) ; begin
89957: LD_INT 0
89959: PPUSH
// if not sci then
89960: LD_VAR 0 1
89964: NOT
89965: IFFALSE 89969
// exit ;
89967: GO 90034
// result := 0 ;
89969: LD_ADDR_VAR 0 2
89973: PUSH
89974: LD_INT 0
89976: ST_TO_ADDR
// if GetTaskList ( sci ) then
89977: LD_VAR 0 1
89981: PPUSH
89982: CALL_OW 437
89986: IFFALSE 90034
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
89988: LD_VAR 0 1
89992: PPUSH
89993: CALL_OW 437
89997: PUSH
89998: LD_INT 1
90000: ARRAY
90001: PUSH
90002: LD_INT 1
90004: ARRAY
90005: PUSH
90006: LD_STRING l
90008: EQUAL
90009: IFFALSE 90034
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
90011: LD_ADDR_VAR 0 2
90015: PUSH
90016: LD_VAR 0 1
90020: PPUSH
90021: CALL_OW 437
90025: PUSH
90026: LD_INT 1
90028: ARRAY
90029: PUSH
90030: LD_INT 4
90032: ARRAY
90033: ST_TO_ADDR
// end ;
90034: LD_VAR 0 2
90038: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90039: LD_INT 0
90041: PPUSH
90042: PPUSH
90043: PPUSH
90044: PPUSH
// if not base_units then
90045: LD_VAR 0 1
90049: NOT
90050: IFFALSE 90054
// exit ;
90052: GO 90141
// result := false ;
90054: LD_ADDR_VAR 0 2
90058: PUSH
90059: LD_INT 0
90061: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90062: LD_ADDR_VAR 0 5
90066: PUSH
90067: LD_VAR 0 1
90071: PPUSH
90072: LD_INT 21
90074: PUSH
90075: LD_INT 3
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: PPUSH
90082: CALL_OW 72
90086: ST_TO_ADDR
// if not tmp then
90087: LD_VAR 0 5
90091: NOT
90092: IFFALSE 90096
// exit ;
90094: GO 90141
// for i in tmp do
90096: LD_ADDR_VAR 0 3
90100: PUSH
90101: LD_VAR 0 5
90105: PUSH
90106: FOR_IN
90107: IFFALSE 90139
// begin result := EnemyInRange ( i , 22 ) ;
90109: LD_ADDR_VAR 0 2
90113: PUSH
90114: LD_VAR 0 3
90118: PPUSH
90119: LD_INT 22
90121: PPUSH
90122: CALL 87566 0 2
90126: ST_TO_ADDR
// if result then
90127: LD_VAR 0 2
90131: IFFALSE 90137
// exit ;
90133: POP
90134: POP
90135: GO 90141
// end ;
90137: GO 90106
90139: POP
90140: POP
// end ;
90141: LD_VAR 0 2
90145: RET
// export function FilterByTag ( units , tag ) ; begin
90146: LD_INT 0
90148: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
90149: LD_ADDR_VAR 0 3
90153: PUSH
90154: LD_VAR 0 1
90158: PPUSH
90159: LD_INT 120
90161: PUSH
90162: LD_VAR 0 2
90166: PUSH
90167: EMPTY
90168: LIST
90169: LIST
90170: PPUSH
90171: CALL_OW 72
90175: ST_TO_ADDR
// end ;
90176: LD_VAR 0 3
90180: RET
// export function IsDriver ( un ) ; begin
90181: LD_INT 0
90183: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
90184: LD_ADDR_VAR 0 2
90188: PUSH
90189: LD_VAR 0 1
90193: PUSH
90194: LD_INT 55
90196: PUSH
90197: EMPTY
90198: LIST
90199: PPUSH
90200: CALL_OW 69
90204: IN
90205: ST_TO_ADDR
// end ;
90206: LD_VAR 0 2
90210: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
90211: LD_INT 0
90213: PPUSH
90214: PPUSH
// list := [ ] ;
90215: LD_ADDR_VAR 0 5
90219: PUSH
90220: EMPTY
90221: ST_TO_ADDR
// case d of 0 :
90222: LD_VAR 0 3
90226: PUSH
90227: LD_INT 0
90229: DOUBLE
90230: EQUAL
90231: IFTRUE 90235
90233: GO 90368
90235: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
90236: LD_ADDR_VAR 0 5
90240: PUSH
90241: LD_VAR 0 1
90245: PUSH
90246: LD_INT 4
90248: MINUS
90249: PUSH
90250: LD_VAR 0 2
90254: PUSH
90255: LD_INT 4
90257: MINUS
90258: PUSH
90259: LD_INT 2
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: LIST
90266: PUSH
90267: LD_VAR 0 1
90271: PUSH
90272: LD_INT 3
90274: MINUS
90275: PUSH
90276: LD_VAR 0 2
90280: PUSH
90281: LD_INT 1
90283: PUSH
90284: EMPTY
90285: LIST
90286: LIST
90287: LIST
90288: PUSH
90289: LD_VAR 0 1
90293: PUSH
90294: LD_INT 4
90296: PLUS
90297: PUSH
90298: LD_VAR 0 2
90302: PUSH
90303: LD_INT 4
90305: PUSH
90306: EMPTY
90307: LIST
90308: LIST
90309: LIST
90310: PUSH
90311: LD_VAR 0 1
90315: PUSH
90316: LD_INT 3
90318: PLUS
90319: PUSH
90320: LD_VAR 0 2
90324: PUSH
90325: LD_INT 3
90327: PLUS
90328: PUSH
90329: LD_INT 5
90331: PUSH
90332: EMPTY
90333: LIST
90334: LIST
90335: LIST
90336: PUSH
90337: LD_VAR 0 1
90341: PUSH
90342: LD_VAR 0 2
90346: PUSH
90347: LD_INT 4
90349: PLUS
90350: PUSH
90351: LD_INT 0
90353: PUSH
90354: EMPTY
90355: LIST
90356: LIST
90357: LIST
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: ST_TO_ADDR
// end ; 1 :
90366: GO 91066
90368: LD_INT 1
90370: DOUBLE
90371: EQUAL
90372: IFTRUE 90376
90374: GO 90509
90376: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
90377: LD_ADDR_VAR 0 5
90381: PUSH
90382: LD_VAR 0 1
90386: PUSH
90387: LD_VAR 0 2
90391: PUSH
90392: LD_INT 4
90394: MINUS
90395: PUSH
90396: LD_INT 3
90398: PUSH
90399: EMPTY
90400: LIST
90401: LIST
90402: LIST
90403: PUSH
90404: LD_VAR 0 1
90408: PUSH
90409: LD_INT 3
90411: MINUS
90412: PUSH
90413: LD_VAR 0 2
90417: PUSH
90418: LD_INT 3
90420: MINUS
90421: PUSH
90422: LD_INT 2
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: LIST
90429: PUSH
90430: LD_VAR 0 1
90434: PUSH
90435: LD_INT 4
90437: MINUS
90438: PUSH
90439: LD_VAR 0 2
90443: PUSH
90444: LD_INT 1
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: LIST
90451: PUSH
90452: LD_VAR 0 1
90456: PUSH
90457: LD_VAR 0 2
90461: PUSH
90462: LD_INT 3
90464: PLUS
90465: PUSH
90466: LD_INT 0
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: LIST
90473: PUSH
90474: LD_VAR 0 1
90478: PUSH
90479: LD_INT 4
90481: PLUS
90482: PUSH
90483: LD_VAR 0 2
90487: PUSH
90488: LD_INT 4
90490: PLUS
90491: PUSH
90492: LD_INT 5
90494: PUSH
90495: EMPTY
90496: LIST
90497: LIST
90498: LIST
90499: PUSH
90500: EMPTY
90501: LIST
90502: LIST
90503: LIST
90504: LIST
90505: LIST
90506: ST_TO_ADDR
// end ; 2 :
90507: GO 91066
90509: LD_INT 2
90511: DOUBLE
90512: EQUAL
90513: IFTRUE 90517
90515: GO 90646
90517: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
90518: LD_ADDR_VAR 0 5
90522: PUSH
90523: LD_VAR 0 1
90527: PUSH
90528: LD_VAR 0 2
90532: PUSH
90533: LD_INT 3
90535: MINUS
90536: PUSH
90537: LD_INT 3
90539: PUSH
90540: EMPTY
90541: LIST
90542: LIST
90543: LIST
90544: PUSH
90545: LD_VAR 0 1
90549: PUSH
90550: LD_INT 4
90552: PLUS
90553: PUSH
90554: LD_VAR 0 2
90558: PUSH
90559: LD_INT 4
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: LIST
90566: PUSH
90567: LD_VAR 0 1
90571: PUSH
90572: LD_VAR 0 2
90576: PUSH
90577: LD_INT 4
90579: PLUS
90580: PUSH
90581: LD_INT 0
90583: PUSH
90584: EMPTY
90585: LIST
90586: LIST
90587: LIST
90588: PUSH
90589: LD_VAR 0 1
90593: PUSH
90594: LD_INT 3
90596: MINUS
90597: PUSH
90598: LD_VAR 0 2
90602: PUSH
90603: LD_INT 1
90605: PUSH
90606: EMPTY
90607: LIST
90608: LIST
90609: LIST
90610: PUSH
90611: LD_VAR 0 1
90615: PUSH
90616: LD_INT 4
90618: MINUS
90619: PUSH
90620: LD_VAR 0 2
90624: PUSH
90625: LD_INT 4
90627: MINUS
90628: PUSH
90629: LD_INT 2
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: LIST
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: ST_TO_ADDR
// end ; 3 :
90644: GO 91066
90646: LD_INT 3
90648: DOUBLE
90649: EQUAL
90650: IFTRUE 90654
90652: GO 90787
90654: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
90655: LD_ADDR_VAR 0 5
90659: PUSH
90660: LD_VAR 0 1
90664: PUSH
90665: LD_INT 3
90667: PLUS
90668: PUSH
90669: LD_VAR 0 2
90673: PUSH
90674: LD_INT 4
90676: PUSH
90677: EMPTY
90678: LIST
90679: LIST
90680: LIST
90681: PUSH
90682: LD_VAR 0 1
90686: PUSH
90687: LD_INT 4
90689: PLUS
90690: PUSH
90691: LD_VAR 0 2
90695: PUSH
90696: LD_INT 4
90698: PLUS
90699: PUSH
90700: LD_INT 5
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: LIST
90707: PUSH
90708: LD_VAR 0 1
90712: PUSH
90713: LD_INT 4
90715: MINUS
90716: PUSH
90717: LD_VAR 0 2
90721: PUSH
90722: LD_INT 1
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: LIST
90729: PUSH
90730: LD_VAR 0 1
90734: PUSH
90735: LD_VAR 0 2
90739: PUSH
90740: LD_INT 4
90742: MINUS
90743: PUSH
90744: LD_INT 3
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: LIST
90751: PUSH
90752: LD_VAR 0 1
90756: PUSH
90757: LD_INT 3
90759: MINUS
90760: PUSH
90761: LD_VAR 0 2
90765: PUSH
90766: LD_INT 3
90768: MINUS
90769: PUSH
90770: LD_INT 2
90772: PUSH
90773: EMPTY
90774: LIST
90775: LIST
90776: LIST
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: ST_TO_ADDR
// end ; 4 :
90785: GO 91066
90787: LD_INT 4
90789: DOUBLE
90790: EQUAL
90791: IFTRUE 90795
90793: GO 90928
90795: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
90796: LD_ADDR_VAR 0 5
90800: PUSH
90801: LD_VAR 0 1
90805: PUSH
90806: LD_VAR 0 2
90810: PUSH
90811: LD_INT 4
90813: PLUS
90814: PUSH
90815: LD_INT 0
90817: PUSH
90818: EMPTY
90819: LIST
90820: LIST
90821: LIST
90822: PUSH
90823: LD_VAR 0 1
90827: PUSH
90828: LD_INT 3
90830: PLUS
90831: PUSH
90832: LD_VAR 0 2
90836: PUSH
90837: LD_INT 3
90839: PLUS
90840: PUSH
90841: LD_INT 5
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: LIST
90848: PUSH
90849: LD_VAR 0 1
90853: PUSH
90854: LD_INT 4
90856: PLUS
90857: PUSH
90858: LD_VAR 0 2
90862: PUSH
90863: LD_INT 4
90865: PUSH
90866: EMPTY
90867: LIST
90868: LIST
90869: LIST
90870: PUSH
90871: LD_VAR 0 1
90875: PUSH
90876: LD_VAR 0 2
90880: PUSH
90881: LD_INT 3
90883: MINUS
90884: PUSH
90885: LD_INT 3
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: LIST
90892: PUSH
90893: LD_VAR 0 1
90897: PUSH
90898: LD_INT 4
90900: MINUS
90901: PUSH
90902: LD_VAR 0 2
90906: PUSH
90907: LD_INT 4
90909: MINUS
90910: PUSH
90911: LD_INT 2
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: LIST
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: LIST
90923: LIST
90924: LIST
90925: ST_TO_ADDR
// end ; 5 :
90926: GO 91066
90928: LD_INT 5
90930: DOUBLE
90931: EQUAL
90932: IFTRUE 90936
90934: GO 91065
90936: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
90937: LD_ADDR_VAR 0 5
90941: PUSH
90942: LD_VAR 0 1
90946: PUSH
90947: LD_INT 4
90949: MINUS
90950: PUSH
90951: LD_VAR 0 2
90955: PUSH
90956: LD_INT 1
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: LIST
90963: PUSH
90964: LD_VAR 0 1
90968: PUSH
90969: LD_VAR 0 2
90973: PUSH
90974: LD_INT 4
90976: MINUS
90977: PUSH
90978: LD_INT 3
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: LIST
90985: PUSH
90986: LD_VAR 0 1
90990: PUSH
90991: LD_INT 4
90993: PLUS
90994: PUSH
90995: LD_VAR 0 2
90999: PUSH
91000: LD_INT 4
91002: PLUS
91003: PUSH
91004: LD_INT 5
91006: PUSH
91007: EMPTY
91008: LIST
91009: LIST
91010: LIST
91011: PUSH
91012: LD_VAR 0 1
91016: PUSH
91017: LD_INT 3
91019: PLUS
91020: PUSH
91021: LD_VAR 0 2
91025: PUSH
91026: LD_INT 4
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: LIST
91033: PUSH
91034: LD_VAR 0 1
91038: PUSH
91039: LD_VAR 0 2
91043: PUSH
91044: LD_INT 3
91046: PLUS
91047: PUSH
91048: LD_INT 0
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: LIST
91055: PUSH
91056: EMPTY
91057: LIST
91058: LIST
91059: LIST
91060: LIST
91061: LIST
91062: ST_TO_ADDR
// end ; end ;
91063: GO 91066
91065: POP
// result := list ;
91066: LD_ADDR_VAR 0 4
91070: PUSH
91071: LD_VAR 0 5
91075: ST_TO_ADDR
// end ;
91076: LD_VAR 0 4
91080: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
91081: LD_INT 0
91083: PPUSH
91084: PPUSH
91085: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
91086: LD_VAR 0 1
91090: NOT
91091: IFTRUE 91119
91093: PUSH
91094: LD_VAR 0 2
91098: PUSH
91099: LD_INT 1
91101: PUSH
91102: LD_INT 2
91104: PUSH
91105: LD_INT 3
91107: PUSH
91108: LD_INT 4
91110: PUSH
91111: EMPTY
91112: LIST
91113: LIST
91114: LIST
91115: LIST
91116: IN
91117: NOT
91118: OR
91119: IFFALSE 91123
// exit ;
91121: GO 91206
// tmp := [ ] ;
91123: LD_ADDR_VAR 0 5
91127: PUSH
91128: EMPTY
91129: ST_TO_ADDR
// for i in units do
91130: LD_ADDR_VAR 0 4
91134: PUSH
91135: LD_VAR 0 1
91139: PUSH
91140: FOR_IN
91141: IFFALSE 91175
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
91143: LD_ADDR_VAR 0 5
91147: PUSH
91148: LD_VAR 0 5
91152: PPUSH
91153: LD_VAR 0 4
91157: PPUSH
91158: LD_VAR 0 2
91162: PPUSH
91163: CALL_OW 259
91167: PPUSH
91168: CALL 92601 0 2
91172: ST_TO_ADDR
91173: GO 91140
91175: POP
91176: POP
// if not tmp then
91177: LD_VAR 0 5
91181: NOT
91182: IFFALSE 91186
// exit ;
91184: GO 91206
// result := SortListByListDesc ( units , tmp ) ;
91186: LD_ADDR_VAR 0 3
91190: PUSH
91191: LD_VAR 0 1
91195: PPUSH
91196: LD_VAR 0 5
91200: PPUSH
91201: CALL_OW 77
91205: ST_TO_ADDR
// end ;
91206: LD_VAR 0 3
91210: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
91211: LD_INT 0
91213: PPUSH
91214: PPUSH
91215: PPUSH
// result := false ;
91216: LD_ADDR_VAR 0 3
91220: PUSH
91221: LD_INT 0
91223: ST_TO_ADDR
// if not building then
91224: LD_VAR 0 2
91228: NOT
91229: IFFALSE 91233
// exit ;
91231: GO 91377
// x := GetX ( building ) ;
91233: LD_ADDR_VAR 0 4
91237: PUSH
91238: LD_VAR 0 2
91242: PPUSH
91243: CALL_OW 250
91247: ST_TO_ADDR
// y := GetY ( building ) ;
91248: LD_ADDR_VAR 0 5
91252: PUSH
91253: LD_VAR 0 2
91257: PPUSH
91258: CALL_OW 251
91262: ST_TO_ADDR
// if not x or not y then
91263: LD_VAR 0 4
91267: NOT
91268: IFTRUE 91277
91270: PUSH
91271: LD_VAR 0 5
91275: NOT
91276: OR
91277: IFFALSE 91281
// exit ;
91279: GO 91377
// if GetTaskList ( unit ) then
91281: LD_VAR 0 1
91285: PPUSH
91286: CALL_OW 437
91290: IFFALSE 91377
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
91292: LD_STRING e
91294: PUSH
91295: LD_VAR 0 1
91299: PPUSH
91300: CALL_OW 437
91304: PUSH
91305: LD_INT 1
91307: ARRAY
91308: PUSH
91309: LD_INT 1
91311: ARRAY
91312: EQUAL
91313: IFFALSE 91340
91315: PUSH
91316: LD_VAR 0 4
91320: PUSH
91321: LD_VAR 0 1
91325: PPUSH
91326: CALL_OW 437
91330: PUSH
91331: LD_INT 1
91333: ARRAY
91334: PUSH
91335: LD_INT 2
91337: ARRAY
91338: EQUAL
91339: AND
91340: IFFALSE 91367
91342: PUSH
91343: LD_VAR 0 5
91347: PUSH
91348: LD_VAR 0 1
91352: PPUSH
91353: CALL_OW 437
91357: PUSH
91358: LD_INT 1
91360: ARRAY
91361: PUSH
91362: LD_INT 3
91364: ARRAY
91365: EQUAL
91366: AND
91367: IFFALSE 91377
// result := true end ;
91369: LD_ADDR_VAR 0 3
91373: PUSH
91374: LD_INT 1
91376: ST_TO_ADDR
// end ;
91377: LD_VAR 0 3
91381: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
91382: LD_INT 0
91384: PPUSH
// result := false ;
91385: LD_ADDR_VAR 0 4
91389: PUSH
91390: LD_INT 0
91392: ST_TO_ADDR
// if GetTaskList ( unit ) then
91393: LD_VAR 0 1
91397: PPUSH
91398: CALL_OW 437
91402: IFFALSE 91489
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
91404: LD_STRING M
91406: PUSH
91407: LD_VAR 0 1
91411: PPUSH
91412: CALL_OW 437
91416: PUSH
91417: LD_INT 1
91419: ARRAY
91420: PUSH
91421: LD_INT 1
91423: ARRAY
91424: EQUAL
91425: IFFALSE 91452
91427: PUSH
91428: LD_VAR 0 2
91432: PUSH
91433: LD_VAR 0 1
91437: PPUSH
91438: CALL_OW 437
91442: PUSH
91443: LD_INT 1
91445: ARRAY
91446: PUSH
91447: LD_INT 2
91449: ARRAY
91450: EQUAL
91451: AND
91452: IFFALSE 91479
91454: PUSH
91455: LD_VAR 0 3
91459: PUSH
91460: LD_VAR 0 1
91464: PPUSH
91465: CALL_OW 437
91469: PUSH
91470: LD_INT 1
91472: ARRAY
91473: PUSH
91474: LD_INT 3
91476: ARRAY
91477: EQUAL
91478: AND
91479: IFFALSE 91489
// result := true ;
91481: LD_ADDR_VAR 0 4
91485: PUSH
91486: LD_INT 1
91488: ST_TO_ADDR
// end ; end ;
91489: LD_VAR 0 4
91493: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
91494: LD_INT 0
91496: PPUSH
91497: PPUSH
91498: PPUSH
91499: PPUSH
// if not unit or not area then
91500: LD_VAR 0 1
91504: NOT
91505: IFTRUE 91514
91507: PUSH
91508: LD_VAR 0 2
91512: NOT
91513: OR
91514: IFFALSE 91518
// exit ;
91516: GO 91694
// tmp := AreaToList ( area , i ) ;
91518: LD_ADDR_VAR 0 6
91522: PUSH
91523: LD_VAR 0 2
91527: PPUSH
91528: LD_VAR 0 5
91532: PPUSH
91533: CALL_OW 517
91537: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
91538: LD_ADDR_VAR 0 5
91542: PUSH
91543: DOUBLE
91544: LD_INT 1
91546: DEC
91547: ST_TO_ADDR
91548: LD_VAR 0 6
91552: PUSH
91553: LD_INT 1
91555: ARRAY
91556: PUSH
91557: FOR_TO
91558: IFFALSE 91692
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
91560: LD_ADDR_VAR 0 7
91564: PUSH
91565: LD_VAR 0 6
91569: PUSH
91570: LD_INT 1
91572: ARRAY
91573: PUSH
91574: LD_VAR 0 5
91578: ARRAY
91579: PUSH
91580: LD_VAR 0 6
91584: PUSH
91585: LD_INT 2
91587: ARRAY
91588: PUSH
91589: LD_VAR 0 5
91593: ARRAY
91594: PUSH
91595: EMPTY
91596: LIST
91597: LIST
91598: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
91599: LD_INT 92
91601: PUSH
91602: LD_VAR 0 7
91606: PUSH
91607: LD_INT 1
91609: ARRAY
91610: PUSH
91611: LD_VAR 0 7
91615: PUSH
91616: LD_INT 2
91618: ARRAY
91619: PUSH
91620: LD_INT 2
91622: PUSH
91623: EMPTY
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: PPUSH
91629: CALL_OW 69
91633: PUSH
91634: LD_INT 0
91636: EQUAL
91637: IFFALSE 91690
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
91639: LD_VAR 0 1
91643: PPUSH
91644: LD_VAR 0 7
91648: PUSH
91649: LD_INT 1
91651: ARRAY
91652: PPUSH
91653: LD_VAR 0 7
91657: PUSH
91658: LD_INT 2
91660: ARRAY
91661: PPUSH
91662: LD_VAR 0 3
91666: PPUSH
91667: CALL_OW 48
// result := IsPlaced ( unit ) ;
91671: LD_ADDR_VAR 0 4
91675: PUSH
91676: LD_VAR 0 1
91680: PPUSH
91681: CALL_OW 305
91685: ST_TO_ADDR
// exit ;
91686: POP
91687: POP
91688: GO 91694
// end ; end ;
91690: GO 91557
91692: POP
91693: POP
// end ;
91694: LD_VAR 0 4
91698: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
91699: LD_INT 0
91701: PPUSH
91702: PPUSH
91703: PPUSH
// if not side or side > 8 then
91704: LD_VAR 0 1
91708: NOT
91709: IFTRUE 91721
91711: PUSH
91712: LD_VAR 0 1
91716: PUSH
91717: LD_INT 8
91719: GREATER
91720: OR
91721: IFFALSE 91725
// exit ;
91723: GO 91912
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
91725: LD_ADDR_VAR 0 4
91729: PUSH
91730: LD_INT 22
91732: PUSH
91733: LD_VAR 0 1
91737: PUSH
91738: EMPTY
91739: LIST
91740: LIST
91741: PUSH
91742: LD_INT 21
91744: PUSH
91745: LD_INT 3
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: PPUSH
91756: CALL_OW 69
91760: ST_TO_ADDR
// if not tmp then
91761: LD_VAR 0 4
91765: NOT
91766: IFFALSE 91770
// exit ;
91768: GO 91912
// enable_addtolog := true ;
91770: LD_ADDR_OWVAR 81
91774: PUSH
91775: LD_INT 1
91777: ST_TO_ADDR
// AddToLog ( [ ) ;
91778: LD_STRING [
91780: PPUSH
91781: CALL_OW 561
// for i in tmp do
91785: LD_ADDR_VAR 0 3
91789: PUSH
91790: LD_VAR 0 4
91794: PUSH
91795: FOR_IN
91796: IFFALSE 91903
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
91798: LD_STRING [
91800: PUSH
91801: LD_VAR 0 3
91805: PPUSH
91806: CALL_OW 266
91810: STR
91811: PUSH
91812: LD_STRING , 
91814: STR
91815: PUSH
91816: LD_VAR 0 3
91820: PPUSH
91821: CALL_OW 250
91825: STR
91826: PUSH
91827: LD_STRING , 
91829: STR
91830: PUSH
91831: LD_VAR 0 3
91835: PPUSH
91836: CALL_OW 251
91840: STR
91841: PUSH
91842: LD_STRING , 
91844: STR
91845: PUSH
91846: LD_VAR 0 3
91850: PPUSH
91851: CALL_OW 254
91855: STR
91856: PUSH
91857: LD_STRING , 
91859: STR
91860: PUSH
91861: LD_VAR 0 3
91865: PPUSH
91866: LD_INT 1
91868: PPUSH
91869: CALL_OW 268
91873: STR
91874: PUSH
91875: LD_STRING , 
91877: STR
91878: PUSH
91879: LD_VAR 0 3
91883: PPUSH
91884: LD_INT 2
91886: PPUSH
91887: CALL_OW 268
91891: STR
91892: PUSH
91893: LD_STRING ],
91895: STR
91896: PPUSH
91897: CALL_OW 561
// end ;
91901: GO 91795
91903: POP
91904: POP
// AddToLog ( ]; ) ;
91905: LD_STRING ];
91907: PPUSH
91908: CALL_OW 561
// end ;
91912: LD_VAR 0 2
91916: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
91917: LD_INT 0
91919: PPUSH
91920: PPUSH
91921: PPUSH
91922: PPUSH
91923: PPUSH
// if not area or not rate or not max then
91924: LD_VAR 0 1
91928: NOT
91929: IFTRUE 91938
91931: PUSH
91932: LD_VAR 0 2
91936: NOT
91937: OR
91938: IFTRUE 91947
91940: PUSH
91941: LD_VAR 0 4
91945: NOT
91946: OR
91947: IFFALSE 91951
// exit ;
91949: GO 92140
// while 1 do
91951: LD_INT 1
91953: IFFALSE 92140
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
91955: LD_ADDR_VAR 0 9
91959: PUSH
91960: LD_VAR 0 1
91964: PPUSH
91965: LD_INT 1
91967: PPUSH
91968: CALL_OW 287
91972: PUSH
91973: LD_INT 10
91975: MUL
91976: ST_TO_ADDR
// r := rate / 10 ;
91977: LD_ADDR_VAR 0 7
91981: PUSH
91982: LD_VAR 0 2
91986: PUSH
91987: LD_INT 10
91989: DIVREAL
91990: ST_TO_ADDR
// time := 1 1$00 ;
91991: LD_ADDR_VAR 0 8
91995: PUSH
91996: LD_INT 2100
91998: ST_TO_ADDR
// if amount < min then
91999: LD_VAR 0 9
92003: PUSH
92004: LD_VAR 0 3
92008: LESS
92009: IFFALSE 92027
// r := r * 2 else
92011: LD_ADDR_VAR 0 7
92015: PUSH
92016: LD_VAR 0 7
92020: PUSH
92021: LD_INT 2
92023: MUL
92024: ST_TO_ADDR
92025: GO 92053
// if amount > max then
92027: LD_VAR 0 9
92031: PUSH
92032: LD_VAR 0 4
92036: GREATER
92037: IFFALSE 92053
// r := r / 2 ;
92039: LD_ADDR_VAR 0 7
92043: PUSH
92044: LD_VAR 0 7
92048: PUSH
92049: LD_INT 2
92051: DIVREAL
92052: ST_TO_ADDR
// time := time / r ;
92053: LD_ADDR_VAR 0 8
92057: PUSH
92058: LD_VAR 0 8
92062: PUSH
92063: LD_VAR 0 7
92067: DIVREAL
92068: ST_TO_ADDR
// if time < 0 then
92069: LD_VAR 0 8
92073: PUSH
92074: LD_INT 0
92076: LESS
92077: IFFALSE 92094
// time := time * - 1 ;
92079: LD_ADDR_VAR 0 8
92083: PUSH
92084: LD_VAR 0 8
92088: PUSH
92089: LD_INT 1
92091: NEG
92092: MUL
92093: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
92094: LD_VAR 0 8
92098: PUSH
92099: LD_INT 35
92101: PPUSH
92102: LD_INT 875
92104: PPUSH
92105: CALL_OW 12
92109: PLUS
92110: PPUSH
92111: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92115: LD_INT 1
92117: PPUSH
92118: LD_INT 5
92120: PPUSH
92121: CALL_OW 12
92125: PPUSH
92126: LD_VAR 0 1
92130: PPUSH
92131: LD_INT 1
92133: PPUSH
92134: CALL_OW 55
// end ;
92138: GO 91951
// end ;
92140: LD_VAR 0 5
92144: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92145: LD_INT 0
92147: PPUSH
92148: PPUSH
92149: PPUSH
92150: PPUSH
92151: PPUSH
92152: PPUSH
92153: PPUSH
92154: PPUSH
// if not turrets or not factories then
92155: LD_VAR 0 1
92159: NOT
92160: IFTRUE 92169
92162: PUSH
92163: LD_VAR 0 2
92167: NOT
92168: OR
92169: IFFALSE 92173
// exit ;
92171: GO 92480
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92173: LD_ADDR_VAR 0 10
92177: PUSH
92178: LD_INT 5
92180: PUSH
92181: LD_INT 6
92183: PUSH
92184: EMPTY
92185: LIST
92186: LIST
92187: PUSH
92188: LD_INT 2
92190: PUSH
92191: LD_INT 4
92193: PUSH
92194: EMPTY
92195: LIST
92196: LIST
92197: PUSH
92198: LD_INT 3
92200: PUSH
92201: LD_INT 5
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: LIST
92212: PUSH
92213: LD_INT 24
92215: PUSH
92216: LD_INT 25
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: LD_INT 23
92225: PUSH
92226: LD_INT 27
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 42
92239: PUSH
92240: LD_INT 43
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 44
92249: PUSH
92250: LD_INT 46
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: LD_INT 45
92259: PUSH
92260: LD_INT 47
92262: PUSH
92263: EMPTY
92264: LIST
92265: LIST
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: LIST
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: LIST
92276: ST_TO_ADDR
// result := [ ] ;
92277: LD_ADDR_VAR 0 3
92281: PUSH
92282: EMPTY
92283: ST_TO_ADDR
// for i in turrets do
92284: LD_ADDR_VAR 0 4
92288: PUSH
92289: LD_VAR 0 1
92293: PUSH
92294: FOR_IN
92295: IFFALSE 92478
// begin nat := GetNation ( i ) ;
92297: LD_ADDR_VAR 0 7
92301: PUSH
92302: LD_VAR 0 4
92306: PPUSH
92307: CALL_OW 248
92311: ST_TO_ADDR
// weapon := 0 ;
92312: LD_ADDR_VAR 0 8
92316: PUSH
92317: LD_INT 0
92319: ST_TO_ADDR
// if not nat then
92320: LD_VAR 0 7
92324: NOT
92325: IFFALSE 92329
// continue ;
92327: GO 92294
// for j in list [ nat ] do
92329: LD_ADDR_VAR 0 5
92333: PUSH
92334: LD_VAR 0 10
92338: PUSH
92339: LD_VAR 0 7
92343: ARRAY
92344: PUSH
92345: FOR_IN
92346: IFFALSE 92387
// if GetBWeapon ( i ) = j [ 1 ] then
92348: LD_VAR 0 4
92352: PPUSH
92353: CALL_OW 269
92357: PUSH
92358: LD_VAR 0 5
92362: PUSH
92363: LD_INT 1
92365: ARRAY
92366: EQUAL
92367: IFFALSE 92385
// begin weapon := j [ 2 ] ;
92369: LD_ADDR_VAR 0 8
92373: PUSH
92374: LD_VAR 0 5
92378: PUSH
92379: LD_INT 2
92381: ARRAY
92382: ST_TO_ADDR
// break ;
92383: GO 92387
// end ;
92385: GO 92345
92387: POP
92388: POP
// if not weapon then
92389: LD_VAR 0 8
92393: NOT
92394: IFFALSE 92398
// continue ;
92396: GO 92294
// for k in factories do
92398: LD_ADDR_VAR 0 6
92402: PUSH
92403: LD_VAR 0 2
92407: PUSH
92408: FOR_IN
92409: IFFALSE 92474
// begin weapons := AvailableWeaponList ( k ) ;
92411: LD_ADDR_VAR 0 9
92415: PUSH
92416: LD_VAR 0 6
92420: PPUSH
92421: CALL_OW 478
92425: ST_TO_ADDR
// if not weapons then
92426: LD_VAR 0 9
92430: NOT
92431: IFFALSE 92435
// continue ;
92433: GO 92408
// if weapon in weapons then
92435: LD_VAR 0 8
92439: PUSH
92440: LD_VAR 0 9
92444: IN
92445: IFFALSE 92472
// begin result := [ i , weapon ] ;
92447: LD_ADDR_VAR 0 3
92451: PUSH
92452: LD_VAR 0 4
92456: PUSH
92457: LD_VAR 0 8
92461: PUSH
92462: EMPTY
92463: LIST
92464: LIST
92465: ST_TO_ADDR
// exit ;
92466: POP
92467: POP
92468: POP
92469: POP
92470: GO 92480
// end ; end ;
92472: GO 92408
92474: POP
92475: POP
// end ;
92476: GO 92294
92478: POP
92479: POP
// end ;
92480: LD_VAR 0 3
92484: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
92485: LD_INT 0
92487: PPUSH
// if not side or side > 8 then
92488: LD_VAR 0 3
92492: NOT
92493: IFTRUE 92505
92495: PUSH
92496: LD_VAR 0 3
92500: PUSH
92501: LD_INT 8
92503: GREATER
92504: OR
92505: IFFALSE 92509
// exit ;
92507: GO 92568
// if not range then
92509: LD_VAR 0 4
92513: NOT
92514: IFFALSE 92525
// range := - 12 ;
92516: LD_ADDR_VAR 0 4
92520: PUSH
92521: LD_INT 12
92523: NEG
92524: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
92525: LD_VAR 0 1
92529: PPUSH
92530: LD_VAR 0 2
92534: PPUSH
92535: LD_VAR 0 3
92539: PPUSH
92540: LD_VAR 0 4
92544: PPUSH
92545: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
92549: LD_VAR 0 1
92553: PPUSH
92554: LD_VAR 0 2
92558: PPUSH
92559: LD_VAR 0 3
92563: PPUSH
92564: CALL_OW 331
// end ;
92568: LD_VAR 0 5
92572: RET
// export function Video ( mode ) ; begin
92573: LD_INT 0
92575: PPUSH
// ingame_video = mode ;
92576: LD_ADDR_OWVAR 52
92580: PUSH
92581: LD_VAR 0 1
92585: ST_TO_ADDR
// interface_hidden = mode ;
92586: LD_ADDR_OWVAR 54
92590: PUSH
92591: LD_VAR 0 1
92595: ST_TO_ADDR
// end ;
92596: LD_VAR 0 2
92600: RET
// export function Join ( array , element ) ; begin
92601: LD_INT 0
92603: PPUSH
// result := Replace ( array , array + 1 , element ) ;
92604: LD_ADDR_VAR 0 3
92608: PUSH
92609: LD_VAR 0 1
92613: PPUSH
92614: LD_VAR 0 1
92618: PUSH
92619: LD_INT 1
92621: PLUS
92622: PPUSH
92623: LD_VAR 0 2
92627: PPUSH
92628: CALL_OW 1
92632: ST_TO_ADDR
// end ;
92633: LD_VAR 0 3
92637: RET
// export function JoinUnion ( array , element ) ; begin
92638: LD_INT 0
92640: PPUSH
// result := array union element ;
92641: LD_ADDR_VAR 0 3
92645: PUSH
92646: LD_VAR 0 1
92650: PUSH
92651: LD_VAR 0 2
92655: UNION
92656: ST_TO_ADDR
// end ;
92657: LD_VAR 0 3
92661: RET
// export function GetBehemoths ( side ) ; begin
92662: LD_INT 0
92664: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
92665: LD_ADDR_VAR 0 2
92669: PUSH
92670: LD_INT 22
92672: PUSH
92673: LD_VAR 0 1
92677: PUSH
92678: EMPTY
92679: LIST
92680: LIST
92681: PUSH
92682: LD_INT 31
92684: PUSH
92685: LD_INT 25
92687: PUSH
92688: EMPTY
92689: LIST
92690: LIST
92691: PUSH
92692: EMPTY
92693: LIST
92694: LIST
92695: PPUSH
92696: CALL_OW 69
92700: ST_TO_ADDR
// end ;
92701: LD_VAR 0 2
92705: RET
// export function Shuffle ( array ) ; var i , index ; begin
92706: LD_INT 0
92708: PPUSH
92709: PPUSH
92710: PPUSH
// result := [ ] ;
92711: LD_ADDR_VAR 0 2
92715: PUSH
92716: EMPTY
92717: ST_TO_ADDR
// if not array then
92718: LD_VAR 0 1
92722: NOT
92723: IFFALSE 92727
// exit ;
92725: GO 92826
// Randomize ;
92727: CALL_OW 10
// for i = array downto 1 do
92731: LD_ADDR_VAR 0 3
92735: PUSH
92736: DOUBLE
92737: LD_VAR 0 1
92741: INC
92742: ST_TO_ADDR
92743: LD_INT 1
92745: PUSH
92746: FOR_DOWNTO
92747: IFFALSE 92824
// begin index := rand ( 1 , array ) ;
92749: LD_ADDR_VAR 0 4
92753: PUSH
92754: LD_INT 1
92756: PPUSH
92757: LD_VAR 0 1
92761: PPUSH
92762: CALL_OW 12
92766: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
92767: LD_ADDR_VAR 0 2
92771: PUSH
92772: LD_VAR 0 2
92776: PPUSH
92777: LD_VAR 0 2
92781: PUSH
92782: LD_INT 1
92784: PLUS
92785: PPUSH
92786: LD_VAR 0 1
92790: PUSH
92791: LD_VAR 0 4
92795: ARRAY
92796: PPUSH
92797: CALL_OW 2
92801: ST_TO_ADDR
// array := Delete ( array , index ) ;
92802: LD_ADDR_VAR 0 1
92806: PUSH
92807: LD_VAR 0 1
92811: PPUSH
92812: LD_VAR 0 4
92816: PPUSH
92817: CALL_OW 3
92821: ST_TO_ADDR
// end ;
92822: GO 92746
92824: POP
92825: POP
// end ;
92826: LD_VAR 0 2
92830: RET
// export function GetBaseMaterials ( base ) ; begin
92831: LD_INT 0
92833: PPUSH
// result := [ 0 , 0 , 0 ] ;
92834: LD_ADDR_VAR 0 2
92838: PUSH
92839: LD_INT 0
92841: PUSH
92842: LD_INT 0
92844: PUSH
92845: LD_INT 0
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: LIST
92852: ST_TO_ADDR
// if not base then
92853: LD_VAR 0 1
92857: NOT
92858: IFFALSE 92862
// exit ;
92860: GO 92911
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
92862: LD_ADDR_VAR 0 2
92866: PUSH
92867: LD_VAR 0 1
92871: PPUSH
92872: LD_INT 1
92874: PPUSH
92875: CALL_OW 275
92879: PUSH
92880: LD_VAR 0 1
92884: PPUSH
92885: LD_INT 2
92887: PPUSH
92888: CALL_OW 275
92892: PUSH
92893: LD_VAR 0 1
92897: PPUSH
92898: LD_INT 3
92900: PPUSH
92901: CALL_OW 275
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: LIST
92910: ST_TO_ADDR
// end ;
92911: LD_VAR 0 2
92915: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
92916: LD_INT 0
92918: PPUSH
92919: PPUSH
// result := array ;
92920: LD_ADDR_VAR 0 3
92924: PUSH
92925: LD_VAR 0 1
92929: ST_TO_ADDR
// if size >= result then
92930: LD_VAR 0 2
92934: PUSH
92935: LD_VAR 0 3
92939: GREATEREQUAL
92940: IFFALSE 92944
// exit ;
92942: GO 92994
// if size then
92944: LD_VAR 0 2
92948: IFFALSE 92994
// for i := array downto size do
92950: LD_ADDR_VAR 0 4
92954: PUSH
92955: DOUBLE
92956: LD_VAR 0 1
92960: INC
92961: ST_TO_ADDR
92962: LD_VAR 0 2
92966: PUSH
92967: FOR_DOWNTO
92968: IFFALSE 92992
// result := Delete ( result , result ) ;
92970: LD_ADDR_VAR 0 3
92974: PUSH
92975: LD_VAR 0 3
92979: PPUSH
92980: LD_VAR 0 3
92984: PPUSH
92985: CALL_OW 3
92989: ST_TO_ADDR
92990: GO 92967
92992: POP
92993: POP
// end ;
92994: LD_VAR 0 3
92998: RET
// export function ComExit ( unit ) ; var tmp ; begin
92999: LD_INT 0
93001: PPUSH
93002: PPUSH
// if not IsInUnit ( unit ) then
93003: LD_VAR 0 1
93007: PPUSH
93008: CALL_OW 310
93012: NOT
93013: IFFALSE 93017
// exit ;
93015: GO 93077
// tmp := IsInUnit ( unit ) ;
93017: LD_ADDR_VAR 0 3
93021: PUSH
93022: LD_VAR 0 1
93026: PPUSH
93027: CALL_OW 310
93031: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
93032: LD_VAR 0 3
93036: PPUSH
93037: CALL_OW 247
93041: PUSH
93042: LD_INT 2
93044: EQUAL
93045: IFFALSE 93058
// ComExitVehicle ( unit ) else
93047: LD_VAR 0 1
93051: PPUSH
93052: CALL_OW 121
93056: GO 93067
// ComExitBuilding ( unit ) ;
93058: LD_VAR 0 1
93062: PPUSH
93063: CALL_OW 122
// result := tmp ;
93067: LD_ADDR_VAR 0 2
93071: PUSH
93072: LD_VAR 0 3
93076: ST_TO_ADDR
// end ;
93077: LD_VAR 0 2
93081: RET
// export function ComExitAll ( units ) ; var i ; begin
93082: LD_INT 0
93084: PPUSH
93085: PPUSH
// if not units then
93086: LD_VAR 0 1
93090: NOT
93091: IFFALSE 93095
// exit ;
93093: GO 93121
// for i in units do
93095: LD_ADDR_VAR 0 3
93099: PUSH
93100: LD_VAR 0 1
93104: PUSH
93105: FOR_IN
93106: IFFALSE 93119
// ComExit ( i ) ;
93108: LD_VAR 0 3
93112: PPUSH
93113: CALL 92999 0 1
93117: GO 93105
93119: POP
93120: POP
// end ;
93121: LD_VAR 0 2
93125: RET
// export function ResetHc ; begin
93126: LD_INT 0
93128: PPUSH
// InitHc ;
93129: CALL_OW 19
// hc_importance := 0 ;
93133: LD_ADDR_OWVAR 32
93137: PUSH
93138: LD_INT 0
93140: ST_TO_ADDR
// end ;
93141: LD_VAR 0 1
93145: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
93146: LD_INT 0
93148: PPUSH
93149: PPUSH
93150: PPUSH
// _x := ( x1 + x2 ) div 2 ;
93151: LD_ADDR_VAR 0 6
93155: PUSH
93156: LD_VAR 0 1
93160: PUSH
93161: LD_VAR 0 3
93165: PLUS
93166: PUSH
93167: LD_INT 2
93169: DIV
93170: ST_TO_ADDR
// if _x < 0 then
93171: LD_VAR 0 6
93175: PUSH
93176: LD_INT 0
93178: LESS
93179: IFFALSE 93196
// _x := _x * - 1 ;
93181: LD_ADDR_VAR 0 6
93185: PUSH
93186: LD_VAR 0 6
93190: PUSH
93191: LD_INT 1
93193: NEG
93194: MUL
93195: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
93196: LD_ADDR_VAR 0 7
93200: PUSH
93201: LD_VAR 0 2
93205: PUSH
93206: LD_VAR 0 4
93210: PLUS
93211: PUSH
93212: LD_INT 2
93214: DIV
93215: ST_TO_ADDR
// if _y < 0 then
93216: LD_VAR 0 7
93220: PUSH
93221: LD_INT 0
93223: LESS
93224: IFFALSE 93241
// _y := _y * - 1 ;
93226: LD_ADDR_VAR 0 7
93230: PUSH
93231: LD_VAR 0 7
93235: PUSH
93236: LD_INT 1
93238: NEG
93239: MUL
93240: ST_TO_ADDR
// result := [ _x , _y ] ;
93241: LD_ADDR_VAR 0 5
93245: PUSH
93246: LD_VAR 0 6
93250: PUSH
93251: LD_VAR 0 7
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: ST_TO_ADDR
// end ;
93260: LD_VAR 0 5
93264: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
93265: LD_INT 0
93267: PPUSH
93268: PPUSH
93269: PPUSH
93270: PPUSH
// task := GetTaskList ( unit ) ;
93271: LD_ADDR_VAR 0 7
93275: PUSH
93276: LD_VAR 0 1
93280: PPUSH
93281: CALL_OW 437
93285: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
93286: LD_VAR 0 7
93290: NOT
93291: IFFALSE 93310
93293: PUSH
93294: LD_VAR 0 1
93298: PPUSH
93299: LD_VAR 0 2
93303: PPUSH
93304: CALL_OW 308
93308: NOT
93309: AND
93310: IFFALSE 93314
// exit ;
93312: GO 93432
// if IsInArea ( unit , area ) then
93314: LD_VAR 0 1
93318: PPUSH
93319: LD_VAR 0 2
93323: PPUSH
93324: CALL_OW 308
93328: IFFALSE 93346
// begin ComMoveToArea ( unit , goAway ) ;
93330: LD_VAR 0 1
93334: PPUSH
93335: LD_VAR 0 3
93339: PPUSH
93340: CALL_OW 113
// exit ;
93344: GO 93432
// end ; if task [ 1 ] [ 1 ] <> M then
93346: LD_VAR 0 7
93350: PUSH
93351: LD_INT 1
93353: ARRAY
93354: PUSH
93355: LD_INT 1
93357: ARRAY
93358: PUSH
93359: LD_STRING M
93361: NONEQUAL
93362: IFFALSE 93366
// exit ;
93364: GO 93432
// x := task [ 1 ] [ 2 ] ;
93366: LD_ADDR_VAR 0 5
93370: PUSH
93371: LD_VAR 0 7
93375: PUSH
93376: LD_INT 1
93378: ARRAY
93379: PUSH
93380: LD_INT 2
93382: ARRAY
93383: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
93384: LD_ADDR_VAR 0 6
93388: PUSH
93389: LD_VAR 0 7
93393: PUSH
93394: LD_INT 1
93396: ARRAY
93397: PUSH
93398: LD_INT 3
93400: ARRAY
93401: ST_TO_ADDR
// if InArea ( x , y , area ) then
93402: LD_VAR 0 5
93406: PPUSH
93407: LD_VAR 0 6
93411: PPUSH
93412: LD_VAR 0 2
93416: PPUSH
93417: CALL_OW 309
93421: IFFALSE 93432
// ComStop ( unit ) ;
93423: LD_VAR 0 1
93427: PPUSH
93428: CALL_OW 141
// end ;
93432: LD_VAR 0 4
93436: RET
// export function Abs ( value ) ; begin
93437: LD_INT 0
93439: PPUSH
// result := value ;
93440: LD_ADDR_VAR 0 2
93444: PUSH
93445: LD_VAR 0 1
93449: ST_TO_ADDR
// if value < 0 then
93450: LD_VAR 0 1
93454: PUSH
93455: LD_INT 0
93457: LESS
93458: IFFALSE 93475
// result := value * - 1 ;
93460: LD_ADDR_VAR 0 2
93464: PUSH
93465: LD_VAR 0 1
93469: PUSH
93470: LD_INT 1
93472: NEG
93473: MUL
93474: ST_TO_ADDR
// end ;
93475: LD_VAR 0 2
93479: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
93480: LD_INT 0
93482: PPUSH
93483: PPUSH
93484: PPUSH
93485: PPUSH
93486: PPUSH
93487: PPUSH
93488: PPUSH
93489: PPUSH
// if not unit or not building then
93490: LD_VAR 0 1
93494: NOT
93495: IFTRUE 93504
93497: PUSH
93498: LD_VAR 0 2
93502: NOT
93503: OR
93504: IFFALSE 93508
// exit ;
93506: GO 93736
// x := GetX ( building ) ;
93508: LD_ADDR_VAR 0 4
93512: PUSH
93513: LD_VAR 0 2
93517: PPUSH
93518: CALL_OW 250
93522: ST_TO_ADDR
// y := GetY ( building ) ;
93523: LD_ADDR_VAR 0 6
93527: PUSH
93528: LD_VAR 0 2
93532: PPUSH
93533: CALL_OW 251
93537: ST_TO_ADDR
// d := GetDir ( building ) ;
93538: LD_ADDR_VAR 0 8
93542: PUSH
93543: LD_VAR 0 2
93547: PPUSH
93548: CALL_OW 254
93552: ST_TO_ADDR
// r := 4 ;
93553: LD_ADDR_VAR 0 9
93557: PUSH
93558: LD_INT 4
93560: ST_TO_ADDR
// for i := 1 to 5 do
93561: LD_ADDR_VAR 0 10
93565: PUSH
93566: DOUBLE
93567: LD_INT 1
93569: DEC
93570: ST_TO_ADDR
93571: LD_INT 5
93573: PUSH
93574: FOR_TO
93575: IFFALSE 93734
// begin _x := ShiftX ( x , d , r + i ) ;
93577: LD_ADDR_VAR 0 5
93581: PUSH
93582: LD_VAR 0 4
93586: PPUSH
93587: LD_VAR 0 8
93591: PPUSH
93592: LD_VAR 0 9
93596: PUSH
93597: LD_VAR 0 10
93601: PLUS
93602: PPUSH
93603: CALL_OW 272
93607: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
93608: LD_ADDR_VAR 0 7
93612: PUSH
93613: LD_VAR 0 6
93617: PPUSH
93618: LD_VAR 0 8
93622: PPUSH
93623: LD_VAR 0 9
93627: PUSH
93628: LD_VAR 0 10
93632: PLUS
93633: PPUSH
93634: CALL_OW 273
93638: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
93639: LD_VAR 0 5
93643: PPUSH
93644: LD_VAR 0 7
93648: PPUSH
93649: CALL_OW 488
93653: IFFALSE 93688
93655: PUSH
93656: LD_VAR 0 5
93660: PPUSH
93661: LD_VAR 0 7
93665: PPUSH
93666: CALL_OW 428
93670: PPUSH
93671: CALL_OW 247
93675: PUSH
93676: LD_INT 3
93678: PUSH
93679: LD_INT 2
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: IN
93686: NOT
93687: AND
93688: IFFALSE 93732
// begin ComMoveXY ( unit , _x , _y ) ;
93690: LD_VAR 0 1
93694: PPUSH
93695: LD_VAR 0 5
93699: PPUSH
93700: LD_VAR 0 7
93704: PPUSH
93705: CALL_OW 111
// result := [ _x , _y ] ;
93709: LD_ADDR_VAR 0 3
93713: PUSH
93714: LD_VAR 0 5
93718: PUSH
93719: LD_VAR 0 7
93723: PUSH
93724: EMPTY
93725: LIST
93726: LIST
93727: ST_TO_ADDR
// exit ;
93728: POP
93729: POP
93730: GO 93736
// end ; end ;
93732: GO 93574
93734: POP
93735: POP
// end ;
93736: LD_VAR 0 3
93740: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
93741: LD_INT 0
93743: PPUSH
93744: PPUSH
93745: PPUSH
// result := 0 ;
93746: LD_ADDR_VAR 0 3
93750: PUSH
93751: LD_INT 0
93753: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
93754: LD_VAR 0 1
93758: PUSH
93759: LD_INT 0
93761: LESS
93762: IFTRUE 93774
93764: PUSH
93765: LD_VAR 0 1
93769: PUSH
93770: LD_INT 8
93772: GREATER
93773: OR
93774: IFTRUE 93786
93776: PUSH
93777: LD_VAR 0 2
93781: PUSH
93782: LD_INT 0
93784: LESS
93785: OR
93786: IFTRUE 93798
93788: PUSH
93789: LD_VAR 0 2
93793: PUSH
93794: LD_INT 8
93796: GREATER
93797: OR
93798: IFFALSE 93802
// exit ;
93800: GO 93877
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
93802: LD_ADDR_VAR 0 4
93806: PUSH
93807: LD_INT 22
93809: PUSH
93810: LD_VAR 0 2
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: PPUSH
93819: CALL_OW 69
93823: PUSH
93824: FOR_IN
93825: IFFALSE 93875
// begin un := UnitShoot ( i ) ;
93827: LD_ADDR_VAR 0 5
93831: PUSH
93832: LD_VAR 0 4
93836: PPUSH
93837: CALL_OW 504
93841: ST_TO_ADDR
// if GetSide ( un ) = side1 then
93842: LD_VAR 0 5
93846: PPUSH
93847: CALL_OW 255
93851: PUSH
93852: LD_VAR 0 1
93856: EQUAL
93857: IFFALSE 93873
// begin result := un ;
93859: LD_ADDR_VAR 0 3
93863: PUSH
93864: LD_VAR 0 5
93868: ST_TO_ADDR
// exit ;
93869: POP
93870: POP
93871: GO 93877
// end ; end ;
93873: GO 93824
93875: POP
93876: POP
// end ;
93877: LD_VAR 0 3
93881: RET
// export function GetCargoBay ( units ) ; begin
93882: LD_INT 0
93884: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
93885: LD_ADDR_VAR 0 2
93889: PUSH
93890: LD_VAR 0 1
93894: PPUSH
93895: LD_INT 2
93897: PUSH
93898: LD_INT 34
93900: PUSH
93901: LD_INT 12
93903: PUSH
93904: EMPTY
93905: LIST
93906: LIST
93907: PUSH
93908: LD_INT 34
93910: PUSH
93911: LD_INT 51
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 34
93920: PUSH
93921: LD_INT 32
93923: PUSH
93924: EMPTY
93925: LIST
93926: LIST
93927: PUSH
93928: LD_INT 34
93930: PUSH
93931: LD_INT 89
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: PPUSH
93945: CALL_OW 72
93949: ST_TO_ADDR
// end ;
93950: LD_VAR 0 2
93954: RET
// export function Negate ( value ) ; begin
93955: LD_INT 0
93957: PPUSH
// result := not value ;
93958: LD_ADDR_VAR 0 2
93962: PUSH
93963: LD_VAR 0 1
93967: NOT
93968: ST_TO_ADDR
// end ;
93969: LD_VAR 0 2
93973: RET
// export function Inc ( value ) ; begin
93974: LD_INT 0
93976: PPUSH
// result := value + 1 ;
93977: LD_ADDR_VAR 0 2
93981: PUSH
93982: LD_VAR 0 1
93986: PUSH
93987: LD_INT 1
93989: PLUS
93990: ST_TO_ADDR
// end ;
93991: LD_VAR 0 2
93995: RET
// export function Dec ( value ) ; begin
93996: LD_INT 0
93998: PPUSH
// result := value - 1 ;
93999: LD_ADDR_VAR 0 2
94003: PUSH
94004: LD_VAR 0 1
94008: PUSH
94009: LD_INT 1
94011: MINUS
94012: ST_TO_ADDR
// end ;
94013: LD_VAR 0 2
94017: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
94018: LD_INT 0
94020: PPUSH
94021: PPUSH
94022: PPUSH
94023: PPUSH
94024: PPUSH
94025: PPUSH
94026: PPUSH
94027: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
94028: LD_VAR 0 1
94032: PPUSH
94033: LD_VAR 0 2
94037: PPUSH
94038: CALL_OW 488
94042: NOT
94043: IFTRUE 94062
94045: PUSH
94046: LD_VAR 0 3
94050: PPUSH
94051: LD_VAR 0 4
94055: PPUSH
94056: CALL_OW 488
94060: NOT
94061: OR
94062: IFFALSE 94075
// begin result := - 1 ;
94064: LD_ADDR_VAR 0 5
94068: PUSH
94069: LD_INT 1
94071: NEG
94072: ST_TO_ADDR
// exit ;
94073: GO 94310
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
94075: LD_ADDR_VAR 0 12
94079: PUSH
94080: LD_VAR 0 1
94084: PPUSH
94085: LD_VAR 0 2
94089: PPUSH
94090: LD_VAR 0 3
94094: PPUSH
94095: LD_VAR 0 4
94099: PPUSH
94100: CALL 93146 0 4
94104: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
94105: LD_ADDR_VAR 0 11
94109: PUSH
94110: LD_VAR 0 1
94114: PPUSH
94115: LD_VAR 0 2
94119: PPUSH
94120: LD_VAR 0 12
94124: PUSH
94125: LD_INT 1
94127: ARRAY
94128: PPUSH
94129: LD_VAR 0 12
94133: PUSH
94134: LD_INT 2
94136: ARRAY
94137: PPUSH
94138: CALL_OW 298
94142: ST_TO_ADDR
// distance := 9999 ;
94143: LD_ADDR_VAR 0 10
94147: PUSH
94148: LD_INT 9999
94150: ST_TO_ADDR
// for i := 0 to 5 do
94151: LD_ADDR_VAR 0 6
94155: PUSH
94156: DOUBLE
94157: LD_INT 0
94159: DEC
94160: ST_TO_ADDR
94161: LD_INT 5
94163: PUSH
94164: FOR_TO
94165: IFFALSE 94308
// begin _x := ShiftX ( x1 , i , centerDist ) ;
94167: LD_ADDR_VAR 0 7
94171: PUSH
94172: LD_VAR 0 1
94176: PPUSH
94177: LD_VAR 0 6
94181: PPUSH
94182: LD_VAR 0 11
94186: PPUSH
94187: CALL_OW 272
94191: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
94192: LD_ADDR_VAR 0 8
94196: PUSH
94197: LD_VAR 0 2
94201: PPUSH
94202: LD_VAR 0 6
94206: PPUSH
94207: LD_VAR 0 11
94211: PPUSH
94212: CALL_OW 273
94216: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
94217: LD_VAR 0 7
94221: PPUSH
94222: LD_VAR 0 8
94226: PPUSH
94227: CALL_OW 488
94231: NOT
94232: IFFALSE 94236
// continue ;
94234: GO 94164
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
94236: LD_ADDR_VAR 0 9
94240: PUSH
94241: LD_VAR 0 12
94245: PUSH
94246: LD_INT 1
94248: ARRAY
94249: PPUSH
94250: LD_VAR 0 12
94254: PUSH
94255: LD_INT 2
94257: ARRAY
94258: PPUSH
94259: LD_VAR 0 7
94263: PPUSH
94264: LD_VAR 0 8
94268: PPUSH
94269: CALL_OW 298
94273: ST_TO_ADDR
// if tmp < distance then
94274: LD_VAR 0 9
94278: PUSH
94279: LD_VAR 0 10
94283: LESS
94284: IFFALSE 94306
// begin result := i ;
94286: LD_ADDR_VAR 0 5
94290: PUSH
94291: LD_VAR 0 6
94295: ST_TO_ADDR
// distance := tmp ;
94296: LD_ADDR_VAR 0 10
94300: PUSH
94301: LD_VAR 0 9
94305: ST_TO_ADDR
// end ; end ;
94306: GO 94164
94308: POP
94309: POP
// end ;
94310: LD_VAR 0 5
94314: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
94315: LD_INT 0
94317: PPUSH
94318: PPUSH
// if not driver or not IsInUnit ( driver ) then
94319: LD_VAR 0 1
94323: NOT
94324: IFTRUE 94338
94326: PUSH
94327: LD_VAR 0 1
94331: PPUSH
94332: CALL_OW 310
94336: NOT
94337: OR
94338: IFFALSE 94342
// exit ;
94340: GO 94432
// vehicle := IsInUnit ( driver ) ;
94342: LD_ADDR_VAR 0 3
94346: PUSH
94347: LD_VAR 0 1
94351: PPUSH
94352: CALL_OW 310
94356: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
94357: LD_VAR 0 1
94361: PPUSH
94362: LD_STRING \
94364: PUSH
94365: LD_INT 0
94367: PUSH
94368: LD_INT 0
94370: PUSH
94371: LD_INT 0
94373: PUSH
94374: LD_INT 0
94376: PUSH
94377: LD_INT 0
94379: PUSH
94380: LD_INT 0
94382: PUSH
94383: EMPTY
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: PUSH
94392: LD_STRING E
94394: PUSH
94395: LD_INT 0
94397: PUSH
94398: LD_INT 0
94400: PUSH
94401: LD_VAR 0 3
94405: PUSH
94406: LD_INT 0
94408: PUSH
94409: LD_INT 0
94411: PUSH
94412: LD_INT 0
94414: PUSH
94415: EMPTY
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: PUSH
94424: EMPTY
94425: LIST
94426: LIST
94427: PPUSH
94428: CALL_OW 446
// end ;
94432: LD_VAR 0 2
94436: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
94437: LD_INT 0
94439: PPUSH
94440: PPUSH
// if not driver or not IsInUnit ( driver ) then
94441: LD_VAR 0 1
94445: NOT
94446: IFTRUE 94460
94448: PUSH
94449: LD_VAR 0 1
94453: PPUSH
94454: CALL_OW 310
94458: NOT
94459: OR
94460: IFFALSE 94464
// exit ;
94462: GO 94554
// vehicle := IsInUnit ( driver ) ;
94464: LD_ADDR_VAR 0 3
94468: PUSH
94469: LD_VAR 0 1
94473: PPUSH
94474: CALL_OW 310
94478: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
94479: LD_VAR 0 1
94483: PPUSH
94484: LD_STRING \
94486: PUSH
94487: LD_INT 0
94489: PUSH
94490: LD_INT 0
94492: PUSH
94493: LD_INT 0
94495: PUSH
94496: LD_INT 0
94498: PUSH
94499: LD_INT 0
94501: PUSH
94502: LD_INT 0
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: PUSH
94514: LD_STRING E
94516: PUSH
94517: LD_INT 0
94519: PUSH
94520: LD_INT 0
94522: PUSH
94523: LD_VAR 0 3
94527: PUSH
94528: LD_INT 0
94530: PUSH
94531: LD_INT 0
94533: PUSH
94534: LD_INT 0
94536: PUSH
94537: EMPTY
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: PUSH
94546: EMPTY
94547: LIST
94548: LIST
94549: PPUSH
94550: CALL_OW 447
// end ;
94554: LD_VAR 0 2
94558: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
94559: LD_INT 0
94561: PPUSH
94562: PPUSH
94563: PPUSH
// tmp := [ ] ;
94564: LD_ADDR_VAR 0 5
94568: PUSH
94569: EMPTY
94570: ST_TO_ADDR
// for i in units do
94571: LD_ADDR_VAR 0 4
94575: PUSH
94576: LD_VAR 0 1
94580: PUSH
94581: FOR_IN
94582: IFFALSE 94620
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
94584: LD_ADDR_VAR 0 5
94588: PUSH
94589: LD_VAR 0 5
94593: PPUSH
94594: LD_VAR 0 5
94598: PUSH
94599: LD_INT 1
94601: PLUS
94602: PPUSH
94603: LD_VAR 0 4
94607: PPUSH
94608: CALL_OW 256
94612: PPUSH
94613: CALL_OW 2
94617: ST_TO_ADDR
94618: GO 94581
94620: POP
94621: POP
// if not tmp then
94622: LD_VAR 0 5
94626: NOT
94627: IFFALSE 94631
// exit ;
94629: GO 94679
// if asc then
94631: LD_VAR 0 2
94635: IFFALSE 94659
// result := SortListByListAsc ( units , tmp ) else
94637: LD_ADDR_VAR 0 3
94641: PUSH
94642: LD_VAR 0 1
94646: PPUSH
94647: LD_VAR 0 5
94651: PPUSH
94652: CALL_OW 76
94656: ST_TO_ADDR
94657: GO 94679
// result := SortListByListDesc ( units , tmp ) ;
94659: LD_ADDR_VAR 0 3
94663: PUSH
94664: LD_VAR 0 1
94668: PPUSH
94669: LD_VAR 0 5
94673: PPUSH
94674: CALL_OW 77
94678: ST_TO_ADDR
// end ;
94679: LD_VAR 0 3
94683: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
94684: LD_INT 0
94686: PPUSH
94687: PPUSH
// task := GetTaskList ( mech ) ;
94688: LD_ADDR_VAR 0 4
94692: PUSH
94693: LD_VAR 0 1
94697: PPUSH
94698: CALL_OW 437
94702: ST_TO_ADDR
// if not task then
94703: LD_VAR 0 4
94707: NOT
94708: IFFALSE 94712
// exit ;
94710: GO 94756
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
94712: LD_ADDR_VAR 0 3
94716: PUSH
94717: LD_VAR 0 4
94721: PUSH
94722: LD_INT 1
94724: ARRAY
94725: PUSH
94726: LD_INT 1
94728: ARRAY
94729: PUSH
94730: LD_STRING r
94732: EQUAL
94733: IFFALSE 94755
94735: PUSH
94736: LD_VAR 0 4
94740: PUSH
94741: LD_INT 1
94743: ARRAY
94744: PUSH
94745: LD_INT 4
94747: ARRAY
94748: PUSH
94749: LD_VAR 0 2
94753: EQUAL
94754: AND
94755: ST_TO_ADDR
// end ;
94756: LD_VAR 0 3
94760: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
94761: LD_INT 0
94763: PPUSH
// SetDir ( unit , d ) ;
94764: LD_VAR 0 1
94768: PPUSH
94769: LD_VAR 0 4
94773: PPUSH
94774: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
94778: LD_ADDR_VAR 0 6
94782: PUSH
94783: LD_VAR 0 1
94787: PPUSH
94788: LD_VAR 0 2
94792: PPUSH
94793: LD_VAR 0 3
94797: PPUSH
94798: LD_VAR 0 5
94802: PPUSH
94803: CALL_OW 48
94807: ST_TO_ADDR
// end ;
94808: LD_VAR 0 6
94812: RET
// export function ToNaturalNumber ( number ) ; begin
94813: LD_INT 0
94815: PPUSH
// result := number div 1 ;
94816: LD_ADDR_VAR 0 2
94820: PUSH
94821: LD_VAR 0 1
94825: PUSH
94826: LD_INT 1
94828: DIV
94829: ST_TO_ADDR
// if number < 0 then
94830: LD_VAR 0 1
94834: PUSH
94835: LD_INT 0
94837: LESS
94838: IFFALSE 94848
// result := 0 ;
94840: LD_ADDR_VAR 0 2
94844: PUSH
94845: LD_INT 0
94847: ST_TO_ADDR
// end ;
94848: LD_VAR 0 2
94852: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
94853: LD_INT 0
94855: PPUSH
94856: PPUSH
94857: PPUSH
// if not buildings then
94858: LD_VAR 0 1
94862: NOT
94863: IFFALSE 94867
// exit ;
94865: GO 94982
// tmp := [ ] ;
94867: LD_ADDR_VAR 0 5
94871: PUSH
94872: EMPTY
94873: ST_TO_ADDR
// for b in buildings do
94874: LD_ADDR_VAR 0 4
94878: PUSH
94879: LD_VAR 0 1
94883: PUSH
94884: FOR_IN
94885: IFFALSE 94923
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
94887: LD_ADDR_VAR 0 5
94891: PUSH
94892: LD_VAR 0 5
94896: PPUSH
94897: LD_VAR 0 5
94901: PUSH
94902: LD_INT 1
94904: PLUS
94905: PPUSH
94906: LD_VAR 0 4
94910: PPUSH
94911: CALL_OW 266
94915: PPUSH
94916: CALL_OW 1
94920: ST_TO_ADDR
94921: GO 94884
94923: POP
94924: POP
// if not tmp then
94925: LD_VAR 0 5
94929: NOT
94930: IFFALSE 94934
// exit ;
94932: GO 94982
// if asc then
94934: LD_VAR 0 2
94938: IFFALSE 94962
// result := SortListByListAsc ( buildings , tmp ) else
94940: LD_ADDR_VAR 0 3
94944: PUSH
94945: LD_VAR 0 1
94949: PPUSH
94950: LD_VAR 0 5
94954: PPUSH
94955: CALL_OW 76
94959: ST_TO_ADDR
94960: GO 94982
// result := SortListByListDesc ( buildings , tmp ) ;
94962: LD_ADDR_VAR 0 3
94966: PUSH
94967: LD_VAR 0 1
94971: PPUSH
94972: LD_VAR 0 5
94976: PPUSH
94977: CALL_OW 77
94981: ST_TO_ADDR
// end ;
94982: LD_VAR 0 3
94986: RET
// export function SortByClass ( units , class ) ; var un ; begin
94987: LD_INT 0
94989: PPUSH
94990: PPUSH
// if not units or not class then
94991: LD_VAR 0 1
94995: NOT
94996: IFTRUE 95005
94998: PUSH
94999: LD_VAR 0 2
95003: NOT
95004: OR
95005: IFFALSE 95009
// exit ;
95007: GO 95104
// result := [ ] ;
95009: LD_ADDR_VAR 0 3
95013: PUSH
95014: EMPTY
95015: ST_TO_ADDR
// for un in units do
95016: LD_ADDR_VAR 0 4
95020: PUSH
95021: LD_VAR 0 1
95025: PUSH
95026: FOR_IN
95027: IFFALSE 95102
// if GetClass ( un ) = class then
95029: LD_VAR 0 4
95033: PPUSH
95034: CALL_OW 257
95038: PUSH
95039: LD_VAR 0 2
95043: EQUAL
95044: IFFALSE 95071
// result := Insert ( result , 1 , un ) else
95046: LD_ADDR_VAR 0 3
95050: PUSH
95051: LD_VAR 0 3
95055: PPUSH
95056: LD_INT 1
95058: PPUSH
95059: LD_VAR 0 4
95063: PPUSH
95064: CALL_OW 2
95068: ST_TO_ADDR
95069: GO 95100
// result := Replace ( result , result + 1 , un ) ;
95071: LD_ADDR_VAR 0 3
95075: PUSH
95076: LD_VAR 0 3
95080: PPUSH
95081: LD_VAR 0 3
95085: PUSH
95086: LD_INT 1
95088: PLUS
95089: PPUSH
95090: LD_VAR 0 4
95094: PPUSH
95095: CALL_OW 1
95099: ST_TO_ADDR
95100: GO 95026
95102: POP
95103: POP
// end ;
95104: LD_VAR 0 3
95108: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
95109: LD_INT 0
95111: PPUSH
95112: PPUSH
95113: PPUSH
95114: PPUSH
95115: PPUSH
95116: PPUSH
95117: PPUSH
// result := [ ] ;
95118: LD_ADDR_VAR 0 4
95122: PUSH
95123: EMPTY
95124: ST_TO_ADDR
// if x - r < 0 then
95125: LD_VAR 0 1
95129: PUSH
95130: LD_VAR 0 3
95134: MINUS
95135: PUSH
95136: LD_INT 0
95138: LESS
95139: IFFALSE 95151
// min_x := 0 else
95141: LD_ADDR_VAR 0 8
95145: PUSH
95146: LD_INT 0
95148: ST_TO_ADDR
95149: GO 95167
// min_x := x - r ;
95151: LD_ADDR_VAR 0 8
95155: PUSH
95156: LD_VAR 0 1
95160: PUSH
95161: LD_VAR 0 3
95165: MINUS
95166: ST_TO_ADDR
// if y - r < 0 then
95167: LD_VAR 0 2
95171: PUSH
95172: LD_VAR 0 3
95176: MINUS
95177: PUSH
95178: LD_INT 0
95180: LESS
95181: IFFALSE 95193
// min_y := 0 else
95183: LD_ADDR_VAR 0 7
95187: PUSH
95188: LD_INT 0
95190: ST_TO_ADDR
95191: GO 95209
// min_y := y - r ;
95193: LD_ADDR_VAR 0 7
95197: PUSH
95198: LD_VAR 0 2
95202: PUSH
95203: LD_VAR 0 3
95207: MINUS
95208: ST_TO_ADDR
// max_x := x + r ;
95209: LD_ADDR_VAR 0 9
95213: PUSH
95214: LD_VAR 0 1
95218: PUSH
95219: LD_VAR 0 3
95223: PLUS
95224: ST_TO_ADDR
// max_y := y + r ;
95225: LD_ADDR_VAR 0 10
95229: PUSH
95230: LD_VAR 0 2
95234: PUSH
95235: LD_VAR 0 3
95239: PLUS
95240: ST_TO_ADDR
// for _x = min_x to max_x do
95241: LD_ADDR_VAR 0 5
95245: PUSH
95246: DOUBLE
95247: LD_VAR 0 8
95251: DEC
95252: ST_TO_ADDR
95253: LD_VAR 0 9
95257: PUSH
95258: FOR_TO
95259: IFFALSE 95360
// for _y = min_y to max_y do
95261: LD_ADDR_VAR 0 6
95265: PUSH
95266: DOUBLE
95267: LD_VAR 0 7
95271: DEC
95272: ST_TO_ADDR
95273: LD_VAR 0 10
95277: PUSH
95278: FOR_TO
95279: IFFALSE 95356
// begin if not ValidHex ( _x , _y ) then
95281: LD_VAR 0 5
95285: PPUSH
95286: LD_VAR 0 6
95290: PPUSH
95291: CALL_OW 488
95295: NOT
95296: IFFALSE 95300
// continue ;
95298: GO 95278
// if GetResourceTypeXY ( _x , _y ) then
95300: LD_VAR 0 5
95304: PPUSH
95305: LD_VAR 0 6
95309: PPUSH
95310: CALL_OW 283
95314: IFFALSE 95354
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
95316: LD_ADDR_VAR 0 4
95320: PUSH
95321: LD_VAR 0 4
95325: PPUSH
95326: LD_VAR 0 4
95330: PUSH
95331: LD_INT 1
95333: PLUS
95334: PPUSH
95335: LD_VAR 0 5
95339: PUSH
95340: LD_VAR 0 6
95344: PUSH
95345: EMPTY
95346: LIST
95347: LIST
95348: PPUSH
95349: CALL_OW 1
95353: ST_TO_ADDR
// end ;
95354: GO 95278
95356: POP
95357: POP
95358: GO 95258
95360: POP
95361: POP
// end ;
95362: LD_VAR 0 4
95366: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
95367: LD_INT 0
95369: PPUSH
95370: PPUSH
95371: PPUSH
95372: PPUSH
95373: PPUSH
95374: PPUSH
95375: PPUSH
95376: PPUSH
// if not units then
95377: LD_VAR 0 1
95381: NOT
95382: IFFALSE 95386
// exit ;
95384: GO 95918
// result := UnitFilter ( units , [ f_ok ] ) ;
95386: LD_ADDR_VAR 0 3
95390: PUSH
95391: LD_VAR 0 1
95395: PPUSH
95396: LD_INT 50
95398: PUSH
95399: EMPTY
95400: LIST
95401: PPUSH
95402: CALL_OW 72
95406: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
95407: LD_ADDR_VAR 0 8
95411: PUSH
95412: LD_VAR 0 1
95416: PUSH
95417: LD_INT 1
95419: ARRAY
95420: PPUSH
95421: CALL_OW 255
95425: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
95426: LD_ADDR_VAR 0 10
95430: PUSH
95431: LD_INT 29
95433: PUSH
95434: LD_INT 91
95436: PUSH
95437: LD_INT 49
95439: PUSH
95440: EMPTY
95441: LIST
95442: LIST
95443: LIST
95444: ST_TO_ADDR
// if not result then
95445: LD_VAR 0 3
95449: NOT
95450: IFFALSE 95454
// exit ;
95452: GO 95918
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
95454: LD_ADDR_VAR 0 5
95458: PUSH
95459: LD_INT 81
95461: PUSH
95462: LD_VAR 0 8
95466: PUSH
95467: EMPTY
95468: LIST
95469: LIST
95470: PPUSH
95471: CALL_OW 69
95475: ST_TO_ADDR
// for i in result do
95476: LD_ADDR_VAR 0 4
95480: PUSH
95481: LD_VAR 0 3
95485: PUSH
95486: FOR_IN
95487: IFFALSE 95916
// begin tag := GetTag ( i ) + 1 ;
95489: LD_ADDR_VAR 0 9
95493: PUSH
95494: LD_VAR 0 4
95498: PPUSH
95499: CALL_OW 110
95503: PUSH
95504: LD_INT 1
95506: PLUS
95507: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
95508: LD_ADDR_VAR 0 7
95512: PUSH
95513: LD_VAR 0 4
95517: PPUSH
95518: CALL_OW 250
95522: PPUSH
95523: LD_VAR 0 4
95527: PPUSH
95528: CALL_OW 251
95532: PPUSH
95533: LD_INT 4
95535: PPUSH
95536: CALL 95109 0 3
95540: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
95541: LD_VAR 0 4
95545: PPUSH
95546: CALL_OW 247
95550: PUSH
95551: LD_INT 2
95553: EQUAL
95554: IFFALSE 95566
95556: PUSH
95557: LD_VAR 0 7
95561: PUSH
95562: LD_INT 2
95564: GREATER
95565: AND
95566: IFFALSE 95586
95568: PUSH
95569: LD_VAR 0 4
95573: PPUSH
95574: CALL_OW 264
95578: PUSH
95579: LD_VAR 0 10
95583: IN
95584: NOT
95585: AND
95586: IFFALSE 95625
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
95588: LD_VAR 0 4
95592: PPUSH
95593: LD_VAR 0 7
95597: PUSH
95598: LD_INT 1
95600: ARRAY
95601: PUSH
95602: LD_INT 1
95604: ARRAY
95605: PPUSH
95606: LD_VAR 0 7
95610: PUSH
95611: LD_INT 1
95613: ARRAY
95614: PUSH
95615: LD_INT 2
95617: ARRAY
95618: PPUSH
95619: CALL_OW 116
95623: GO 95914
// if path > tag then
95625: LD_VAR 0 2
95629: PUSH
95630: LD_VAR 0 9
95634: GREATER
95635: IFFALSE 95843
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
95637: LD_ADDR_VAR 0 6
95641: PUSH
95642: LD_VAR 0 5
95646: PPUSH
95647: LD_INT 91
95649: PUSH
95650: LD_VAR 0 4
95654: PUSH
95655: LD_INT 8
95657: PUSH
95658: EMPTY
95659: LIST
95660: LIST
95661: LIST
95662: PPUSH
95663: CALL_OW 72
95667: ST_TO_ADDR
// if nearEnemy then
95668: LD_VAR 0 6
95672: IFFALSE 95741
// begin if GetWeapon ( i ) = ru_time_lapser then
95674: LD_VAR 0 4
95678: PPUSH
95679: CALL_OW 264
95683: PUSH
95684: LD_INT 49
95686: EQUAL
95687: IFFALSE 95715
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
95689: LD_VAR 0 4
95693: PPUSH
95694: LD_VAR 0 6
95698: PPUSH
95699: LD_VAR 0 4
95703: PPUSH
95704: CALL_OW 74
95708: PPUSH
95709: CALL_OW 112
95713: GO 95739
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
95715: LD_VAR 0 4
95719: PPUSH
95720: LD_VAR 0 6
95724: PPUSH
95725: LD_VAR 0 4
95729: PPUSH
95730: CALL_OW 74
95734: PPUSH
95735: CALL 96999 0 2
// end else
95739: GO 95841
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
95741: LD_VAR 0 4
95745: PPUSH
95746: LD_VAR 0 2
95750: PUSH
95751: LD_VAR 0 9
95755: ARRAY
95756: PUSH
95757: LD_INT 1
95759: ARRAY
95760: PPUSH
95761: LD_VAR 0 2
95765: PUSH
95766: LD_VAR 0 9
95770: ARRAY
95771: PUSH
95772: LD_INT 2
95774: ARRAY
95775: PPUSH
95776: CALL_OW 297
95780: PUSH
95781: LD_INT 6
95783: GREATER
95784: IFFALSE 95827
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
95786: LD_VAR 0 4
95790: PPUSH
95791: LD_VAR 0 2
95795: PUSH
95796: LD_VAR 0 9
95800: ARRAY
95801: PUSH
95802: LD_INT 1
95804: ARRAY
95805: PPUSH
95806: LD_VAR 0 2
95810: PUSH
95811: LD_VAR 0 9
95815: ARRAY
95816: PUSH
95817: LD_INT 2
95819: ARRAY
95820: PPUSH
95821: CALL_OW 114
95825: GO 95841
// SetTag ( i , tag ) ;
95827: LD_VAR 0 4
95831: PPUSH
95832: LD_VAR 0 9
95836: PPUSH
95837: CALL_OW 109
// end else
95841: GO 95914
// if enemy then
95843: LD_VAR 0 5
95847: IFFALSE 95914
// begin if GetWeapon ( i ) = ru_time_lapser then
95849: LD_VAR 0 4
95853: PPUSH
95854: CALL_OW 264
95858: PUSH
95859: LD_INT 49
95861: EQUAL
95862: IFFALSE 95890
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
95864: LD_VAR 0 4
95868: PPUSH
95869: LD_VAR 0 5
95873: PPUSH
95874: LD_VAR 0 4
95878: PPUSH
95879: CALL_OW 74
95883: PPUSH
95884: CALL_OW 112
95888: GO 95914
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
95890: LD_VAR 0 4
95894: PPUSH
95895: LD_VAR 0 5
95899: PPUSH
95900: LD_VAR 0 4
95904: PPUSH
95905: CALL_OW 74
95909: PPUSH
95910: CALL 96999 0 2
// end ; end ;
95914: GO 95486
95916: POP
95917: POP
// end ;
95918: LD_VAR 0 3
95922: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
95923: LD_INT 0
95925: PPUSH
95926: PPUSH
95927: PPUSH
// if not unit or IsInUnit ( unit ) then
95928: LD_VAR 0 1
95932: NOT
95933: IFTRUE 95946
95935: PUSH
95936: LD_VAR 0 1
95940: PPUSH
95941: CALL_OW 310
95945: OR
95946: IFFALSE 95950
// exit ;
95948: GO 96041
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
95950: LD_ADDR_VAR 0 4
95954: PUSH
95955: LD_VAR 0 1
95959: PPUSH
95960: CALL_OW 250
95964: PPUSH
95965: LD_VAR 0 2
95969: PPUSH
95970: LD_INT 1
95972: PPUSH
95973: CALL_OW 272
95977: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
95978: LD_ADDR_VAR 0 5
95982: PUSH
95983: LD_VAR 0 1
95987: PPUSH
95988: CALL_OW 251
95992: PPUSH
95993: LD_VAR 0 2
95997: PPUSH
95998: LD_INT 1
96000: PPUSH
96001: CALL_OW 273
96005: ST_TO_ADDR
// if ValidHex ( x , y ) then
96006: LD_VAR 0 4
96010: PPUSH
96011: LD_VAR 0 5
96015: PPUSH
96016: CALL_OW 488
96020: IFFALSE 96041
// ComTurnXY ( unit , x , y ) ;
96022: LD_VAR 0 1
96026: PPUSH
96027: LD_VAR 0 4
96031: PPUSH
96032: LD_VAR 0 5
96036: PPUSH
96037: CALL_OW 118
// end ;
96041: LD_VAR 0 3
96045: RET
// export function SeeUnits ( side , units ) ; var i ; begin
96046: LD_INT 0
96048: PPUSH
96049: PPUSH
// result := false ;
96050: LD_ADDR_VAR 0 3
96054: PUSH
96055: LD_INT 0
96057: ST_TO_ADDR
// if not units then
96058: LD_VAR 0 2
96062: NOT
96063: IFFALSE 96067
// exit ;
96065: GO 96112
// for i in units do
96067: LD_ADDR_VAR 0 4
96071: PUSH
96072: LD_VAR 0 2
96076: PUSH
96077: FOR_IN
96078: IFFALSE 96110
// if See ( side , i ) then
96080: LD_VAR 0 1
96084: PPUSH
96085: LD_VAR 0 4
96089: PPUSH
96090: CALL_OW 292
96094: IFFALSE 96108
// begin result := true ;
96096: LD_ADDR_VAR 0 3
96100: PUSH
96101: LD_INT 1
96103: ST_TO_ADDR
// exit ;
96104: POP
96105: POP
96106: GO 96112
// end ;
96108: GO 96077
96110: POP
96111: POP
// end ;
96112: LD_VAR 0 3
96116: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
96117: LD_INT 0
96119: PPUSH
96120: PPUSH
96121: PPUSH
96122: PPUSH
// if not unit or not points then
96123: LD_VAR 0 1
96127: NOT
96128: IFTRUE 96137
96130: PUSH
96131: LD_VAR 0 2
96135: NOT
96136: OR
96137: IFFALSE 96141
// exit ;
96139: GO 96231
// dist := 99999 ;
96141: LD_ADDR_VAR 0 5
96145: PUSH
96146: LD_INT 99999
96148: ST_TO_ADDR
// for i in points do
96149: LD_ADDR_VAR 0 4
96153: PUSH
96154: LD_VAR 0 2
96158: PUSH
96159: FOR_IN
96160: IFFALSE 96229
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
96162: LD_ADDR_VAR 0 6
96166: PUSH
96167: LD_VAR 0 1
96171: PPUSH
96172: LD_VAR 0 4
96176: PUSH
96177: LD_INT 1
96179: ARRAY
96180: PPUSH
96181: LD_VAR 0 4
96185: PUSH
96186: LD_INT 2
96188: ARRAY
96189: PPUSH
96190: CALL_OW 297
96194: ST_TO_ADDR
// if tmpDist < dist then
96195: LD_VAR 0 6
96199: PUSH
96200: LD_VAR 0 5
96204: LESS
96205: IFFALSE 96227
// begin result := i ;
96207: LD_ADDR_VAR 0 3
96211: PUSH
96212: LD_VAR 0 4
96216: ST_TO_ADDR
// dist := tmpDist ;
96217: LD_ADDR_VAR 0 5
96221: PUSH
96222: LD_VAR 0 6
96226: ST_TO_ADDR
// end ; end ;
96227: GO 96159
96229: POP
96230: POP
// end ;
96231: LD_VAR 0 3
96235: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
96236: LD_INT 0
96238: PPUSH
// uc_side := side ;
96239: LD_ADDR_OWVAR 20
96243: PUSH
96244: LD_VAR 0 1
96248: ST_TO_ADDR
// uc_nation := 3 ;
96249: LD_ADDR_OWVAR 21
96253: PUSH
96254: LD_INT 3
96256: ST_TO_ADDR
// vc_chassis := 25 ;
96257: LD_ADDR_OWVAR 37
96261: PUSH
96262: LD_INT 25
96264: ST_TO_ADDR
// vc_engine := engine_siberite ;
96265: LD_ADDR_OWVAR 39
96269: PUSH
96270: LD_INT 3
96272: ST_TO_ADDR
// vc_control := control_computer ;
96273: LD_ADDR_OWVAR 38
96277: PUSH
96278: LD_INT 3
96280: ST_TO_ADDR
// vc_weapon := 59 ;
96281: LD_ADDR_OWVAR 40
96285: PUSH
96286: LD_INT 59
96288: ST_TO_ADDR
// result := CreateVehicle ;
96289: LD_ADDR_VAR 0 5
96293: PUSH
96294: CALL_OW 45
96298: ST_TO_ADDR
// SetDir ( result , d ) ;
96299: LD_VAR 0 5
96303: PPUSH
96304: LD_VAR 0 4
96308: PPUSH
96309: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
96313: LD_VAR 0 5
96317: PPUSH
96318: LD_VAR 0 2
96322: PPUSH
96323: LD_VAR 0 3
96327: PPUSH
96328: LD_INT 0
96330: PPUSH
96331: CALL_OW 48
// end ;
96335: LD_VAR 0 5
96339: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
96340: LD_INT 0
96342: PPUSH
96343: PPUSH
96344: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
96345: LD_ADDR_VAR 0 2
96349: PUSH
96350: LD_INT 0
96352: PUSH
96353: LD_INT 0
96355: PUSH
96356: LD_INT 0
96358: PUSH
96359: LD_INT 0
96361: PUSH
96362: EMPTY
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
96368: LD_VAR 0 1
96372: NOT
96373: IFTRUE 96406
96375: PUSH
96376: LD_VAR 0 1
96380: PPUSH
96381: CALL_OW 264
96385: PUSH
96386: LD_INT 12
96388: PUSH
96389: LD_INT 51
96391: PUSH
96392: LD_INT 32
96394: PUSH
96395: LD_INT 89
96397: PUSH
96398: EMPTY
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: IN
96404: NOT
96405: OR
96406: IFFALSE 96410
// exit ;
96408: GO 96508
// for i := 1 to 3 do
96410: LD_ADDR_VAR 0 3
96414: PUSH
96415: DOUBLE
96416: LD_INT 1
96418: DEC
96419: ST_TO_ADDR
96420: LD_INT 3
96422: PUSH
96423: FOR_TO
96424: IFFALSE 96506
// begin tmp := GetCargo ( cargo , i ) ;
96426: LD_ADDR_VAR 0 4
96430: PUSH
96431: LD_VAR 0 1
96435: PPUSH
96436: LD_VAR 0 3
96440: PPUSH
96441: CALL_OW 289
96445: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
96446: LD_ADDR_VAR 0 2
96450: PUSH
96451: LD_VAR 0 2
96455: PPUSH
96456: LD_VAR 0 3
96460: PPUSH
96461: LD_VAR 0 4
96465: PPUSH
96466: CALL_OW 1
96470: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
96471: LD_ADDR_VAR 0 2
96475: PUSH
96476: LD_VAR 0 2
96480: PPUSH
96481: LD_INT 4
96483: PPUSH
96484: LD_VAR 0 2
96488: PUSH
96489: LD_INT 4
96491: ARRAY
96492: PUSH
96493: LD_VAR 0 4
96497: PLUS
96498: PPUSH
96499: CALL_OW 1
96503: ST_TO_ADDR
// end ;
96504: GO 96423
96506: POP
96507: POP
// end ;
96508: LD_VAR 0 2
96512: RET
// export function Length ( array ) ; begin
96513: LD_INT 0
96515: PPUSH
// result := array + 0 ;
96516: LD_ADDR_VAR 0 2
96520: PUSH
96521: LD_VAR 0 1
96525: PUSH
96526: LD_INT 0
96528: PLUS
96529: ST_TO_ADDR
// end ;
96530: LD_VAR 0 2
96534: RET
// export function PrepareArray ( array ) ; begin
96535: LD_INT 0
96537: PPUSH
// result := array diff 0 ;
96538: LD_ADDR_VAR 0 2
96542: PUSH
96543: LD_VAR 0 1
96547: PUSH
96548: LD_INT 0
96550: DIFF
96551: ST_TO_ADDR
// if not result [ 1 ] then
96552: LD_VAR 0 2
96556: PUSH
96557: LD_INT 1
96559: ARRAY
96560: NOT
96561: IFFALSE 96581
// result := Delete ( result , 1 ) ;
96563: LD_ADDR_VAR 0 2
96567: PUSH
96568: LD_VAR 0 2
96572: PPUSH
96573: LD_INT 1
96575: PPUSH
96576: CALL_OW 3
96580: ST_TO_ADDR
// end ;
96581: LD_VAR 0 2
96585: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
96586: LD_INT 0
96588: PPUSH
96589: PPUSH
96590: PPUSH
96591: PPUSH
// sibRocketRange := 25 ;
96592: LD_ADDR_VAR 0 6
96596: PUSH
96597: LD_INT 25
96599: ST_TO_ADDR
// result := false ;
96600: LD_ADDR_VAR 0 4
96604: PUSH
96605: LD_INT 0
96607: ST_TO_ADDR
// for i := 0 to 5 do
96608: LD_ADDR_VAR 0 5
96612: PUSH
96613: DOUBLE
96614: LD_INT 0
96616: DEC
96617: ST_TO_ADDR
96618: LD_INT 5
96620: PUSH
96621: FOR_TO
96622: IFFALSE 96689
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
96624: LD_VAR 0 1
96628: PPUSH
96629: LD_VAR 0 5
96633: PPUSH
96634: LD_VAR 0 6
96638: PPUSH
96639: CALL_OW 272
96643: PPUSH
96644: LD_VAR 0 2
96648: PPUSH
96649: LD_VAR 0 5
96653: PPUSH
96654: LD_VAR 0 6
96658: PPUSH
96659: CALL_OW 273
96663: PPUSH
96664: LD_VAR 0 3
96668: PPUSH
96669: CALL_OW 309
96673: IFFALSE 96687
// begin result := true ;
96675: LD_ADDR_VAR 0 4
96679: PUSH
96680: LD_INT 1
96682: ST_TO_ADDR
// exit ;
96683: POP
96684: POP
96685: GO 96691
// end ;
96687: GO 96621
96689: POP
96690: POP
// end ;
96691: LD_VAR 0 4
96695: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
96696: LD_INT 0
96698: PPUSH
96699: PPUSH
96700: PPUSH
// if btype = b_depot then
96701: LD_VAR 0 2
96705: PUSH
96706: LD_INT 0
96708: EQUAL
96709: IFFALSE 96721
// begin result := true ;
96711: LD_ADDR_VAR 0 3
96715: PUSH
96716: LD_INT 1
96718: ST_TO_ADDR
// exit ;
96719: GO 96841
// end ; pom := GetBase ( depot ) ;
96721: LD_ADDR_VAR 0 4
96725: PUSH
96726: LD_VAR 0 1
96730: PPUSH
96731: CALL_OW 274
96735: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
96736: LD_ADDR_VAR 0 5
96740: PUSH
96741: LD_VAR 0 2
96745: PPUSH
96746: LD_VAR 0 1
96750: PPUSH
96751: CALL_OW 248
96755: PPUSH
96756: CALL_OW 450
96760: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
96761: LD_ADDR_VAR 0 3
96765: PUSH
96766: LD_VAR 0 4
96770: PPUSH
96771: LD_INT 1
96773: PPUSH
96774: CALL_OW 275
96778: PUSH
96779: LD_VAR 0 5
96783: PUSH
96784: LD_INT 1
96786: ARRAY
96787: GREATEREQUAL
96788: IFFALSE 96814
96790: PUSH
96791: LD_VAR 0 4
96795: PPUSH
96796: LD_INT 2
96798: PPUSH
96799: CALL_OW 275
96803: PUSH
96804: LD_VAR 0 5
96808: PUSH
96809: LD_INT 2
96811: ARRAY
96812: GREATEREQUAL
96813: AND
96814: IFFALSE 96840
96816: PUSH
96817: LD_VAR 0 4
96821: PPUSH
96822: LD_INT 3
96824: PPUSH
96825: CALL_OW 275
96829: PUSH
96830: LD_VAR 0 5
96834: PUSH
96835: LD_INT 3
96837: ARRAY
96838: GREATEREQUAL
96839: AND
96840: ST_TO_ADDR
// end ;
96841: LD_VAR 0 3
96845: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
96846: LD_INT 0
96848: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
96849: LD_VAR 0 1
96853: PPUSH
96854: LD_VAR 0 2
96858: PPUSH
96859: LD_INT 0
96861: PPUSH
96862: LD_INT 0
96864: PPUSH
96865: LD_INT 1
96867: PPUSH
96868: LD_INT 0
96870: PPUSH
96871: CALL_OW 587
// end ;
96875: LD_VAR 0 3
96879: RET
// export function CenterOnNow ( unit ) ; begin
96880: LD_INT 0
96882: PPUSH
// result := IsInUnit ( unit ) ;
96883: LD_ADDR_VAR 0 2
96887: PUSH
96888: LD_VAR 0 1
96892: PPUSH
96893: CALL_OW 310
96897: ST_TO_ADDR
// if not result then
96898: LD_VAR 0 2
96902: NOT
96903: IFFALSE 96915
// result := unit ;
96905: LD_ADDR_VAR 0 2
96909: PUSH
96910: LD_VAR 0 1
96914: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
96915: LD_VAR 0 1
96919: PPUSH
96920: CALL_OW 87
// end ;
96924: LD_VAR 0 2
96928: RET
// export function ComMoveHex ( unit , hex ) ; begin
96929: LD_INT 0
96931: PPUSH
// if not hex then
96932: LD_VAR 0 2
96936: NOT
96937: IFFALSE 96941
// exit ;
96939: GO 96994
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
96941: LD_VAR 0 2
96945: PUSH
96946: LD_INT 1
96948: ARRAY
96949: PPUSH
96950: LD_VAR 0 2
96954: PUSH
96955: LD_INT 2
96957: ARRAY
96958: PPUSH
96959: CALL_OW 428
96963: IFFALSE 96967
// exit ;
96965: GO 96994
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
96967: LD_VAR 0 1
96971: PPUSH
96972: LD_VAR 0 2
96976: PUSH
96977: LD_INT 1
96979: ARRAY
96980: PPUSH
96981: LD_VAR 0 2
96985: PUSH
96986: LD_INT 2
96988: ARRAY
96989: PPUSH
96990: CALL_OW 111
// end ;
96994: LD_VAR 0 3
96998: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
96999: LD_INT 0
97001: PPUSH
97002: PPUSH
97003: PPUSH
// if not unit or not enemy then
97004: LD_VAR 0 1
97008: NOT
97009: IFTRUE 97018
97011: PUSH
97012: LD_VAR 0 2
97016: NOT
97017: OR
97018: IFFALSE 97022
// exit ;
97020: GO 97148
// x := GetX ( enemy ) ;
97022: LD_ADDR_VAR 0 4
97026: PUSH
97027: LD_VAR 0 2
97031: PPUSH
97032: CALL_OW 250
97036: ST_TO_ADDR
// y := GetY ( enemy ) ;
97037: LD_ADDR_VAR 0 5
97041: PUSH
97042: LD_VAR 0 2
97046: PPUSH
97047: CALL_OW 251
97051: ST_TO_ADDR
// if ValidHex ( x , y ) then
97052: LD_VAR 0 4
97056: PPUSH
97057: LD_VAR 0 5
97061: PPUSH
97062: CALL_OW 488
97066: IFFALSE 97148
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
97068: LD_VAR 0 2
97072: PPUSH
97073: CALL_OW 247
97077: PUSH
97078: LD_INT 3
97080: PUSH
97081: LD_INT 2
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: IN
97088: IFTRUE 97111
97090: PUSH
97091: LD_VAR 0 1
97095: PPUSH
97096: CALL_OW 255
97100: PPUSH
97101: LD_VAR 0 2
97105: PPUSH
97106: CALL_OW 292
97110: OR
97111: IFFALSE 97129
// ComAttackUnit ( unit , enemy ) else
97113: LD_VAR 0 1
97117: PPUSH
97118: LD_VAR 0 2
97122: PPUSH
97123: CALL_OW 115
97127: GO 97148
// ComAgressiveMove ( unit , x , y ) ;
97129: LD_VAR 0 1
97133: PPUSH
97134: LD_VAR 0 4
97138: PPUSH
97139: LD_VAR 0 5
97143: PPUSH
97144: CALL_OW 114
// end ;
97148: LD_VAR 0 3
97152: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
97153: LD_INT 0
97155: PPUSH
97156: PPUSH
97157: PPUSH
// list := AreaToList ( area , 0 ) ;
97158: LD_ADDR_VAR 0 5
97162: PUSH
97163: LD_VAR 0 1
97167: PPUSH
97168: LD_INT 0
97170: PPUSH
97171: CALL_OW 517
97175: ST_TO_ADDR
// if not list then
97176: LD_VAR 0 5
97180: NOT
97181: IFFALSE 97185
// exit ;
97183: GO 97315
// if all then
97185: LD_VAR 0 2
97189: IFFALSE 97277
// begin for i := 1 to list [ 1 ] do
97191: LD_ADDR_VAR 0 4
97195: PUSH
97196: DOUBLE
97197: LD_INT 1
97199: DEC
97200: ST_TO_ADDR
97201: LD_VAR 0 5
97205: PUSH
97206: LD_INT 1
97208: ARRAY
97209: PUSH
97210: FOR_TO
97211: IFFALSE 97273
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
97213: LD_ADDR_VAR 0 3
97217: PUSH
97218: LD_VAR 0 3
97222: PPUSH
97223: LD_VAR 0 3
97227: PUSH
97228: LD_INT 1
97230: PLUS
97231: PPUSH
97232: LD_VAR 0 5
97236: PUSH
97237: LD_INT 1
97239: ARRAY
97240: PUSH
97241: LD_VAR 0 4
97245: ARRAY
97246: PUSH
97247: LD_VAR 0 5
97251: PUSH
97252: LD_INT 2
97254: ARRAY
97255: PUSH
97256: LD_VAR 0 4
97260: ARRAY
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PPUSH
97266: CALL_OW 1
97270: ST_TO_ADDR
97271: GO 97210
97273: POP
97274: POP
// exit ;
97275: GO 97315
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
97277: LD_ADDR_VAR 0 3
97281: PUSH
97282: LD_VAR 0 5
97286: PUSH
97287: LD_INT 1
97289: ARRAY
97290: PUSH
97291: LD_INT 1
97293: ARRAY
97294: PUSH
97295: LD_VAR 0 5
97299: PUSH
97300: LD_INT 2
97302: ARRAY
97303: PUSH
97304: LD_INT 1
97306: ARRAY
97307: PUSH
97308: EMPTY
97309: LIST
97310: LIST
97311: PUSH
97312: EMPTY
97313: LIST
97314: ST_TO_ADDR
// end ;
97315: LD_VAR 0 3
97319: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
97320: LD_INT 0
97322: PPUSH
97323: PPUSH
// list := AreaToList ( area , 0 ) ;
97324: LD_ADDR_VAR 0 4
97328: PUSH
97329: LD_VAR 0 1
97333: PPUSH
97334: LD_INT 0
97336: PPUSH
97337: CALL_OW 517
97341: ST_TO_ADDR
// if not list then
97342: LD_VAR 0 4
97346: NOT
97347: IFFALSE 97351
// exit ;
97349: GO 97392
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
97351: LD_ADDR_VAR 0 3
97355: PUSH
97356: LD_VAR 0 4
97360: PUSH
97361: LD_INT 1
97363: ARRAY
97364: PUSH
97365: LD_INT 1
97367: ARRAY
97368: PUSH
97369: LD_VAR 0 4
97373: PUSH
97374: LD_INT 2
97376: ARRAY
97377: PUSH
97378: LD_INT 1
97380: ARRAY
97381: PUSH
97382: LD_VAR 0 2
97386: PUSH
97387: EMPTY
97388: LIST
97389: LIST
97390: LIST
97391: ST_TO_ADDR
// end ;
97392: LD_VAR 0 3
97396: RET
// export function First ( array ) ; begin
97397: LD_INT 0
97399: PPUSH
// if not array then
97400: LD_VAR 0 1
97404: NOT
97405: IFFALSE 97409
// exit ;
97407: GO 97423
// result := array [ 1 ] ;
97409: LD_ADDR_VAR 0 2
97413: PUSH
97414: LD_VAR 0 1
97418: PUSH
97419: LD_INT 1
97421: ARRAY
97422: ST_TO_ADDR
// end ;
97423: LD_VAR 0 2
97427: RET
// export function Last ( array ) ; begin
97428: LD_INT 0
97430: PPUSH
// if not array then
97431: LD_VAR 0 1
97435: NOT
97436: IFFALSE 97440
// exit ;
97438: GO 97456
// result := array [ array ] ;
97440: LD_ADDR_VAR 0 2
97444: PUSH
97445: LD_VAR 0 1
97449: PUSH
97450: LD_VAR 0 1
97454: ARRAY
97455: ST_TO_ADDR
// end ;
97456: LD_VAR 0 2
97460: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
97461: LD_INT 0
97463: PPUSH
97464: PPUSH
// result := [ ] ;
97465: LD_ADDR_VAR 0 5
97469: PUSH
97470: EMPTY
97471: ST_TO_ADDR
// if not array then
97472: LD_VAR 0 1
97476: NOT
97477: IFFALSE 97481
// exit ;
97479: GO 97593
// for i := 1 to array do
97481: LD_ADDR_VAR 0 6
97485: PUSH
97486: DOUBLE
97487: LD_INT 1
97489: DEC
97490: ST_TO_ADDR
97491: LD_VAR 0 1
97495: PUSH
97496: FOR_TO
97497: IFFALSE 97591
// if array [ i ] [ index ] = value then
97499: LD_VAR 0 1
97503: PUSH
97504: LD_VAR 0 6
97508: ARRAY
97509: PUSH
97510: LD_VAR 0 2
97514: ARRAY
97515: PUSH
97516: LD_VAR 0 3
97520: EQUAL
97521: IFFALSE 97589
// begin if indexColumn then
97523: LD_VAR 0 4
97527: IFFALSE 97563
// result := Join ( result , array [ i ] [ indexColumn ] ) else
97529: LD_ADDR_VAR 0 5
97533: PUSH
97534: LD_VAR 0 5
97538: PPUSH
97539: LD_VAR 0 1
97543: PUSH
97544: LD_VAR 0 6
97548: ARRAY
97549: PUSH
97550: LD_VAR 0 4
97554: ARRAY
97555: PPUSH
97556: CALL 92601 0 2
97560: ST_TO_ADDR
97561: GO 97589
// result := Join ( result , array [ i ] ) ;
97563: LD_ADDR_VAR 0 5
97567: PUSH
97568: LD_VAR 0 5
97572: PPUSH
97573: LD_VAR 0 1
97577: PUSH
97578: LD_VAR 0 6
97582: ARRAY
97583: PPUSH
97584: CALL 92601 0 2
97588: ST_TO_ADDR
// end ;
97589: GO 97496
97591: POP
97592: POP
// end ;
97593: LD_VAR 0 5
97597: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
97598: LD_INT 0
97600: PPUSH
// if not vehicles or not parkingPoint then
97601: LD_VAR 0 1
97605: NOT
97606: IFTRUE 97615
97608: PUSH
97609: LD_VAR 0 2
97613: NOT
97614: OR
97615: IFFALSE 97619
// exit ;
97617: GO 97717
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
97619: LD_ADDR_VAR 0 1
97623: PUSH
97624: LD_VAR 0 1
97628: PPUSH
97629: LD_INT 50
97631: PUSH
97632: EMPTY
97633: LIST
97634: PUSH
97635: LD_INT 3
97637: PUSH
97638: LD_INT 92
97640: PUSH
97641: LD_VAR 0 2
97645: PUSH
97646: LD_INT 1
97648: ARRAY
97649: PUSH
97650: LD_VAR 0 2
97654: PUSH
97655: LD_INT 2
97657: ARRAY
97658: PUSH
97659: LD_INT 8
97661: PUSH
97662: EMPTY
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: PUSH
97668: EMPTY
97669: LIST
97670: LIST
97671: PUSH
97672: EMPTY
97673: LIST
97674: LIST
97675: PPUSH
97676: CALL_OW 72
97680: ST_TO_ADDR
// if not vehicles then
97681: LD_VAR 0 1
97685: NOT
97686: IFFALSE 97690
// exit ;
97688: GO 97717
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
97690: LD_VAR 0 1
97694: PPUSH
97695: LD_VAR 0 2
97699: PUSH
97700: LD_INT 1
97702: ARRAY
97703: PPUSH
97704: LD_VAR 0 2
97708: PUSH
97709: LD_INT 2
97711: ARRAY
97712: PPUSH
97713: CALL_OW 111
// end ;
97717: LD_VAR 0 3
97721: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
97722: LD_INT 0
97724: PPUSH
97725: PPUSH
97726: PPUSH
// if not side or not area then
97727: LD_VAR 0 1
97731: NOT
97732: IFTRUE 97741
97734: PUSH
97735: LD_VAR 0 2
97739: NOT
97740: OR
97741: IFFALSE 97745
// exit ;
97743: GO 97864
// tmp := AreaToList ( area , 0 ) ;
97745: LD_ADDR_VAR 0 5
97749: PUSH
97750: LD_VAR 0 2
97754: PPUSH
97755: LD_INT 0
97757: PPUSH
97758: CALL_OW 517
97762: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
97763: LD_ADDR_VAR 0 4
97767: PUSH
97768: DOUBLE
97769: LD_INT 1
97771: DEC
97772: ST_TO_ADDR
97773: LD_VAR 0 5
97777: PUSH
97778: LD_INT 1
97780: ARRAY
97781: PUSH
97782: FOR_TO
97783: IFFALSE 97862
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
97785: LD_VAR 0 5
97789: PUSH
97790: LD_INT 1
97792: ARRAY
97793: PUSH
97794: LD_VAR 0 4
97798: ARRAY
97799: PPUSH
97800: LD_VAR 0 5
97804: PUSH
97805: LD_INT 2
97807: ARRAY
97808: PUSH
97809: LD_VAR 0 4
97813: ARRAY
97814: PPUSH
97815: CALL_OW 351
97819: IFFALSE 97860
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
97821: LD_VAR 0 5
97825: PUSH
97826: LD_INT 1
97828: ARRAY
97829: PUSH
97830: LD_VAR 0 4
97834: ARRAY
97835: PPUSH
97836: LD_VAR 0 5
97840: PUSH
97841: LD_INT 2
97843: ARRAY
97844: PUSH
97845: LD_VAR 0 4
97849: ARRAY
97850: PPUSH
97851: LD_VAR 0 1
97855: PPUSH
97856: CALL_OW 244
// end ;
97860: GO 97782
97862: POP
97863: POP
// end ;
97864: LD_VAR 0 3
97868: RET
// export function UniqueArray ( array ) ; var i ; begin
97869: LD_INT 0
97871: PPUSH
97872: PPUSH
// result := [ ] ;
97873: LD_ADDR_VAR 0 2
97877: PUSH
97878: EMPTY
97879: ST_TO_ADDR
// if not array then
97880: LD_VAR 0 1
97884: NOT
97885: IFFALSE 97889
// exit ;
97887: GO 97950
// for i := 1 to array do
97889: LD_ADDR_VAR 0 3
97893: PUSH
97894: DOUBLE
97895: LD_INT 1
97897: DEC
97898: ST_TO_ADDR
97899: LD_VAR 0 1
97903: PUSH
97904: FOR_TO
97905: IFFALSE 97948
// if not array [ i ] in result then
97907: LD_VAR 0 1
97911: PUSH
97912: LD_VAR 0 3
97916: ARRAY
97917: PUSH
97918: LD_VAR 0 2
97922: IN
97923: NOT
97924: IFFALSE 97946
// result := Join ( result , i ) ;
97926: LD_ADDR_VAR 0 2
97930: PUSH
97931: LD_VAR 0 2
97935: PPUSH
97936: LD_VAR 0 3
97940: PPUSH
97941: CALL 92601 0 2
97945: ST_TO_ADDR
97946: GO 97904
97948: POP
97949: POP
// end ; end_of_file end_of_file
97950: LD_VAR 0 2
97954: RET
// export globalGameSaveCounter ; every 0 0$1 do
97955: GO 97957
97957: DISABLE
// begin enable ;
97958: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
97959: LD_STRING updateTimer(
97961: PUSH
97962: LD_OWVAR 1
97966: STR
97967: PUSH
97968: LD_STRING );
97970: STR
97971: PPUSH
97972: CALL_OW 559
// end ;
97976: END
// every 0 0$1 do
97977: GO 97979
97979: DISABLE
// begin globalGameSaveCounter := 0 ;
97980: LD_ADDR_EXP 125
97984: PUSH
97985: LD_INT 0
97987: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
97988: LD_STRING setGameSaveCounter(0)
97990: PPUSH
97991: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
97995: LD_STRING initStreamRollete();
97997: PPUSH
97998: CALL_OW 559
// InitStreamMode ;
98002: CALL 99347 0 0
// DefineStreamItems ( false ) ;
98006: LD_INT 0
98008: PPUSH
98009: CALL 99811 0 1
// end ;
98013: END
// export function SOS_MapStart ( ) ; begin
98014: LD_INT 0
98016: PPUSH
// if streamModeActive then
98017: LD_EXP 126
98021: IFFALSE 98030
// DefineStreamItems ( true ) ;
98023: LD_INT 1
98025: PPUSH
98026: CALL 99811 0 1
// UpdateLuaVariables ( ) ;
98030: CALL 98047 0 0
// UpdateFactoryWaypoints ( ) ;
98034: CALL 112933 0 0
// UpdateWarehouseGatheringPoints ( ) ;
98038: CALL 113185 0 0
// end ;
98042: LD_VAR 0 1
98046: RET
// function UpdateLuaVariables ( ) ; begin
98047: LD_INT 0
98049: PPUSH
// if globalGameSaveCounter then
98050: LD_EXP 125
98054: IFFALSE 98088
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
98056: LD_ADDR_EXP 125
98060: PUSH
98061: LD_EXP 125
98065: PPUSH
98066: CALL 93974 0 1
98070: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
98071: LD_STRING setGameSaveCounter(
98073: PUSH
98074: LD_EXP 125
98078: STR
98079: PUSH
98080: LD_STRING )
98082: STR
98083: PPUSH
98084: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
98088: LD_STRING setGameDifficulty(
98090: PUSH
98091: LD_OWVAR 67
98095: STR
98096: PUSH
98097: LD_STRING )
98099: STR
98100: PPUSH
98101: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
98105: LD_STRING displayDifficulty(
98107: PUSH
98108: LD_OWVAR 67
98112: STR
98113: PUSH
98114: LD_STRING )
98116: STR
98117: PPUSH
98118: CALL_OW 559
// end ;
98122: LD_VAR 0 1
98126: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
98127: LD_INT 0
98129: PPUSH
// if p2 = stream_mode then
98130: LD_VAR 0 2
98134: PUSH
98135: LD_INT 100
98137: EQUAL
98138: IFFALSE 99141
// begin if not StreamModeActive then
98140: LD_EXP 126
98144: NOT
98145: IFFALSE 98155
// StreamModeActive := true ;
98147: LD_ADDR_EXP 126
98151: PUSH
98152: LD_INT 1
98154: ST_TO_ADDR
// if p3 = 0 then
98155: LD_VAR 0 3
98159: PUSH
98160: LD_INT 0
98162: EQUAL
98163: IFFALSE 98169
// InitStreamMode ;
98165: CALL 99347 0 0
// if p3 = 1 then
98169: LD_VAR 0 3
98173: PUSH
98174: LD_INT 1
98176: EQUAL
98177: IFFALSE 98187
// sRocket := true ;
98179: LD_ADDR_EXP 131
98183: PUSH
98184: LD_INT 1
98186: ST_TO_ADDR
// if p3 = 2 then
98187: LD_VAR 0 3
98191: PUSH
98192: LD_INT 2
98194: EQUAL
98195: IFFALSE 98205
// sSpeed := true ;
98197: LD_ADDR_EXP 130
98201: PUSH
98202: LD_INT 1
98204: ST_TO_ADDR
// if p3 = 3 then
98205: LD_VAR 0 3
98209: PUSH
98210: LD_INT 3
98212: EQUAL
98213: IFFALSE 98223
// sEngine := true ;
98215: LD_ADDR_EXP 132
98219: PUSH
98220: LD_INT 1
98222: ST_TO_ADDR
// if p3 = 4 then
98223: LD_VAR 0 3
98227: PUSH
98228: LD_INT 4
98230: EQUAL
98231: IFFALSE 98241
// sSpec := true ;
98233: LD_ADDR_EXP 129
98237: PUSH
98238: LD_INT 1
98240: ST_TO_ADDR
// if p3 = 5 then
98241: LD_VAR 0 3
98245: PUSH
98246: LD_INT 5
98248: EQUAL
98249: IFFALSE 98259
// sLevel := true ;
98251: LD_ADDR_EXP 133
98255: PUSH
98256: LD_INT 1
98258: ST_TO_ADDR
// if p3 = 6 then
98259: LD_VAR 0 3
98263: PUSH
98264: LD_INT 6
98266: EQUAL
98267: IFFALSE 98277
// sArmoury := true ;
98269: LD_ADDR_EXP 134
98273: PUSH
98274: LD_INT 1
98276: ST_TO_ADDR
// if p3 = 7 then
98277: LD_VAR 0 3
98281: PUSH
98282: LD_INT 7
98284: EQUAL
98285: IFFALSE 98295
// sRadar := true ;
98287: LD_ADDR_EXP 135
98291: PUSH
98292: LD_INT 1
98294: ST_TO_ADDR
// if p3 = 8 then
98295: LD_VAR 0 3
98299: PUSH
98300: LD_INT 8
98302: EQUAL
98303: IFFALSE 98313
// sBunker := true ;
98305: LD_ADDR_EXP 136
98309: PUSH
98310: LD_INT 1
98312: ST_TO_ADDR
// if p3 = 9 then
98313: LD_VAR 0 3
98317: PUSH
98318: LD_INT 9
98320: EQUAL
98321: IFFALSE 98331
// sHack := true ;
98323: LD_ADDR_EXP 137
98327: PUSH
98328: LD_INT 1
98330: ST_TO_ADDR
// if p3 = 10 then
98331: LD_VAR 0 3
98335: PUSH
98336: LD_INT 10
98338: EQUAL
98339: IFFALSE 98349
// sFire := true ;
98341: LD_ADDR_EXP 138
98345: PUSH
98346: LD_INT 1
98348: ST_TO_ADDR
// if p3 = 11 then
98349: LD_VAR 0 3
98353: PUSH
98354: LD_INT 11
98356: EQUAL
98357: IFFALSE 98367
// sRefresh := true ;
98359: LD_ADDR_EXP 139
98363: PUSH
98364: LD_INT 1
98366: ST_TO_ADDR
// if p3 = 12 then
98367: LD_VAR 0 3
98371: PUSH
98372: LD_INT 12
98374: EQUAL
98375: IFFALSE 98385
// sExp := true ;
98377: LD_ADDR_EXP 140
98381: PUSH
98382: LD_INT 1
98384: ST_TO_ADDR
// if p3 = 13 then
98385: LD_VAR 0 3
98389: PUSH
98390: LD_INT 13
98392: EQUAL
98393: IFFALSE 98403
// sDepot := true ;
98395: LD_ADDR_EXP 141
98399: PUSH
98400: LD_INT 1
98402: ST_TO_ADDR
// if p3 = 14 then
98403: LD_VAR 0 3
98407: PUSH
98408: LD_INT 14
98410: EQUAL
98411: IFFALSE 98421
// sFlag := true ;
98413: LD_ADDR_EXP 142
98417: PUSH
98418: LD_INT 1
98420: ST_TO_ADDR
// if p3 = 15 then
98421: LD_VAR 0 3
98425: PUSH
98426: LD_INT 15
98428: EQUAL
98429: IFFALSE 98439
// sKamikadze := true ;
98431: LD_ADDR_EXP 150
98435: PUSH
98436: LD_INT 1
98438: ST_TO_ADDR
// if p3 = 16 then
98439: LD_VAR 0 3
98443: PUSH
98444: LD_INT 16
98446: EQUAL
98447: IFFALSE 98457
// sTroll := true ;
98449: LD_ADDR_EXP 151
98453: PUSH
98454: LD_INT 1
98456: ST_TO_ADDR
// if p3 = 17 then
98457: LD_VAR 0 3
98461: PUSH
98462: LD_INT 17
98464: EQUAL
98465: IFFALSE 98475
// sSlow := true ;
98467: LD_ADDR_EXP 152
98471: PUSH
98472: LD_INT 1
98474: ST_TO_ADDR
// if p3 = 18 then
98475: LD_VAR 0 3
98479: PUSH
98480: LD_INT 18
98482: EQUAL
98483: IFFALSE 98493
// sLack := true ;
98485: LD_ADDR_EXP 153
98489: PUSH
98490: LD_INT 1
98492: ST_TO_ADDR
// if p3 = 19 then
98493: LD_VAR 0 3
98497: PUSH
98498: LD_INT 19
98500: EQUAL
98501: IFFALSE 98511
// sTank := true ;
98503: LD_ADDR_EXP 155
98507: PUSH
98508: LD_INT 1
98510: ST_TO_ADDR
// if p3 = 20 then
98511: LD_VAR 0 3
98515: PUSH
98516: LD_INT 20
98518: EQUAL
98519: IFFALSE 98529
// sRemote := true ;
98521: LD_ADDR_EXP 156
98525: PUSH
98526: LD_INT 1
98528: ST_TO_ADDR
// if p3 = 21 then
98529: LD_VAR 0 3
98533: PUSH
98534: LD_INT 21
98536: EQUAL
98537: IFFALSE 98547
// sPowell := true ;
98539: LD_ADDR_EXP 157
98543: PUSH
98544: LD_INT 1
98546: ST_TO_ADDR
// if p3 = 22 then
98547: LD_VAR 0 3
98551: PUSH
98552: LD_INT 22
98554: EQUAL
98555: IFFALSE 98565
// sTeleport := true ;
98557: LD_ADDR_EXP 160
98561: PUSH
98562: LD_INT 1
98564: ST_TO_ADDR
// if p3 = 23 then
98565: LD_VAR 0 3
98569: PUSH
98570: LD_INT 23
98572: EQUAL
98573: IFFALSE 98583
// sOilTower := true ;
98575: LD_ADDR_EXP 162
98579: PUSH
98580: LD_INT 1
98582: ST_TO_ADDR
// if p3 = 24 then
98583: LD_VAR 0 3
98587: PUSH
98588: LD_INT 24
98590: EQUAL
98591: IFFALSE 98601
// sShovel := true ;
98593: LD_ADDR_EXP 163
98597: PUSH
98598: LD_INT 1
98600: ST_TO_ADDR
// if p3 = 25 then
98601: LD_VAR 0 3
98605: PUSH
98606: LD_INT 25
98608: EQUAL
98609: IFFALSE 98619
// sSheik := true ;
98611: LD_ADDR_EXP 164
98615: PUSH
98616: LD_INT 1
98618: ST_TO_ADDR
// if p3 = 26 then
98619: LD_VAR 0 3
98623: PUSH
98624: LD_INT 26
98626: EQUAL
98627: IFFALSE 98637
// sEarthquake := true ;
98629: LD_ADDR_EXP 166
98633: PUSH
98634: LD_INT 1
98636: ST_TO_ADDR
// if p3 = 27 then
98637: LD_VAR 0 3
98641: PUSH
98642: LD_INT 27
98644: EQUAL
98645: IFFALSE 98655
// sAI := true ;
98647: LD_ADDR_EXP 167
98651: PUSH
98652: LD_INT 1
98654: ST_TO_ADDR
// if p3 = 28 then
98655: LD_VAR 0 3
98659: PUSH
98660: LD_INT 28
98662: EQUAL
98663: IFFALSE 98673
// sCargo := true ;
98665: LD_ADDR_EXP 170
98669: PUSH
98670: LD_INT 1
98672: ST_TO_ADDR
// if p3 = 29 then
98673: LD_VAR 0 3
98677: PUSH
98678: LD_INT 29
98680: EQUAL
98681: IFFALSE 98691
// sDLaser := true ;
98683: LD_ADDR_EXP 171
98687: PUSH
98688: LD_INT 1
98690: ST_TO_ADDR
// if p3 = 30 then
98691: LD_VAR 0 3
98695: PUSH
98696: LD_INT 30
98698: EQUAL
98699: IFFALSE 98709
// sExchange := true ;
98701: LD_ADDR_EXP 172
98705: PUSH
98706: LD_INT 1
98708: ST_TO_ADDR
// if p3 = 31 then
98709: LD_VAR 0 3
98713: PUSH
98714: LD_INT 31
98716: EQUAL
98717: IFFALSE 98727
// sFac := true ;
98719: LD_ADDR_EXP 173
98723: PUSH
98724: LD_INT 1
98726: ST_TO_ADDR
// if p3 = 32 then
98727: LD_VAR 0 3
98731: PUSH
98732: LD_INT 32
98734: EQUAL
98735: IFFALSE 98745
// sPower := true ;
98737: LD_ADDR_EXP 174
98741: PUSH
98742: LD_INT 1
98744: ST_TO_ADDR
// if p3 = 33 then
98745: LD_VAR 0 3
98749: PUSH
98750: LD_INT 33
98752: EQUAL
98753: IFFALSE 98763
// sRandom := true ;
98755: LD_ADDR_EXP 175
98759: PUSH
98760: LD_INT 1
98762: ST_TO_ADDR
// if p3 = 34 then
98763: LD_VAR 0 3
98767: PUSH
98768: LD_INT 34
98770: EQUAL
98771: IFFALSE 98781
// sShield := true ;
98773: LD_ADDR_EXP 176
98777: PUSH
98778: LD_INT 1
98780: ST_TO_ADDR
// if p3 = 35 then
98781: LD_VAR 0 3
98785: PUSH
98786: LD_INT 35
98788: EQUAL
98789: IFFALSE 98799
// sTime := true ;
98791: LD_ADDR_EXP 177
98795: PUSH
98796: LD_INT 1
98798: ST_TO_ADDR
// if p3 = 36 then
98799: LD_VAR 0 3
98803: PUSH
98804: LD_INT 36
98806: EQUAL
98807: IFFALSE 98817
// sTools := true ;
98809: LD_ADDR_EXP 178
98813: PUSH
98814: LD_INT 1
98816: ST_TO_ADDR
// if p3 = 101 then
98817: LD_VAR 0 3
98821: PUSH
98822: LD_INT 101
98824: EQUAL
98825: IFFALSE 98835
// sSold := true ;
98827: LD_ADDR_EXP 143
98831: PUSH
98832: LD_INT 1
98834: ST_TO_ADDR
// if p3 = 102 then
98835: LD_VAR 0 3
98839: PUSH
98840: LD_INT 102
98842: EQUAL
98843: IFFALSE 98853
// sDiff := true ;
98845: LD_ADDR_EXP 144
98849: PUSH
98850: LD_INT 1
98852: ST_TO_ADDR
// if p3 = 103 then
98853: LD_VAR 0 3
98857: PUSH
98858: LD_INT 103
98860: EQUAL
98861: IFFALSE 98871
// sFog := true ;
98863: LD_ADDR_EXP 147
98867: PUSH
98868: LD_INT 1
98870: ST_TO_ADDR
// if p3 = 104 then
98871: LD_VAR 0 3
98875: PUSH
98876: LD_INT 104
98878: EQUAL
98879: IFFALSE 98889
// sReset := true ;
98881: LD_ADDR_EXP 148
98885: PUSH
98886: LD_INT 1
98888: ST_TO_ADDR
// if p3 = 105 then
98889: LD_VAR 0 3
98893: PUSH
98894: LD_INT 105
98896: EQUAL
98897: IFFALSE 98907
// sSun := true ;
98899: LD_ADDR_EXP 149
98903: PUSH
98904: LD_INT 1
98906: ST_TO_ADDR
// if p3 = 106 then
98907: LD_VAR 0 3
98911: PUSH
98912: LD_INT 106
98914: EQUAL
98915: IFFALSE 98925
// sTiger := true ;
98917: LD_ADDR_EXP 145
98921: PUSH
98922: LD_INT 1
98924: ST_TO_ADDR
// if p3 = 107 then
98925: LD_VAR 0 3
98929: PUSH
98930: LD_INT 107
98932: EQUAL
98933: IFFALSE 98943
// sBomb := true ;
98935: LD_ADDR_EXP 146
98939: PUSH
98940: LD_INT 1
98942: ST_TO_ADDR
// if p3 = 108 then
98943: LD_VAR 0 3
98947: PUSH
98948: LD_INT 108
98950: EQUAL
98951: IFFALSE 98961
// sWound := true ;
98953: LD_ADDR_EXP 154
98957: PUSH
98958: LD_INT 1
98960: ST_TO_ADDR
// if p3 = 109 then
98961: LD_VAR 0 3
98965: PUSH
98966: LD_INT 109
98968: EQUAL
98969: IFFALSE 98979
// sBetray := true ;
98971: LD_ADDR_EXP 158
98975: PUSH
98976: LD_INT 1
98978: ST_TO_ADDR
// if p3 = 110 then
98979: LD_VAR 0 3
98983: PUSH
98984: LD_INT 110
98986: EQUAL
98987: IFFALSE 98997
// sContamin := true ;
98989: LD_ADDR_EXP 159
98993: PUSH
98994: LD_INT 1
98996: ST_TO_ADDR
// if p3 = 111 then
98997: LD_VAR 0 3
99001: PUSH
99002: LD_INT 111
99004: EQUAL
99005: IFFALSE 99015
// sOil := true ;
99007: LD_ADDR_EXP 161
99011: PUSH
99012: LD_INT 1
99014: ST_TO_ADDR
// if p3 = 112 then
99015: LD_VAR 0 3
99019: PUSH
99020: LD_INT 112
99022: EQUAL
99023: IFFALSE 99033
// sStu := true ;
99025: LD_ADDR_EXP 165
99029: PUSH
99030: LD_INT 1
99032: ST_TO_ADDR
// if p3 = 113 then
99033: LD_VAR 0 3
99037: PUSH
99038: LD_INT 113
99040: EQUAL
99041: IFFALSE 99051
// sBazooka := true ;
99043: LD_ADDR_EXP 168
99047: PUSH
99048: LD_INT 1
99050: ST_TO_ADDR
// if p3 = 114 then
99051: LD_VAR 0 3
99055: PUSH
99056: LD_INT 114
99058: EQUAL
99059: IFFALSE 99069
// sMortar := true ;
99061: LD_ADDR_EXP 169
99065: PUSH
99066: LD_INT 1
99068: ST_TO_ADDR
// if p3 = 115 then
99069: LD_VAR 0 3
99073: PUSH
99074: LD_INT 115
99076: EQUAL
99077: IFFALSE 99087
// sRanger := true ;
99079: LD_ADDR_EXP 179
99083: PUSH
99084: LD_INT 1
99086: ST_TO_ADDR
// if p3 = 116 then
99087: LD_VAR 0 3
99091: PUSH
99092: LD_INT 116
99094: EQUAL
99095: IFFALSE 99105
// sComputer := true ;
99097: LD_ADDR_EXP 180
99101: PUSH
99102: LD_INT 1
99104: ST_TO_ADDR
// if p3 = 117 then
99105: LD_VAR 0 3
99109: PUSH
99110: LD_INT 117
99112: EQUAL
99113: IFFALSE 99123
// s30 := true ;
99115: LD_ADDR_EXP 181
99119: PUSH
99120: LD_INT 1
99122: ST_TO_ADDR
// if p3 = 118 then
99123: LD_VAR 0 3
99127: PUSH
99128: LD_INT 118
99130: EQUAL
99131: IFFALSE 99141
// s60 := true ;
99133: LD_ADDR_EXP 182
99137: PUSH
99138: LD_INT 1
99140: ST_TO_ADDR
// end ; if p2 = hack_mode then
99141: LD_VAR 0 2
99145: PUSH
99146: LD_INT 101
99148: EQUAL
99149: IFFALSE 99277
// begin case p3 of 1 :
99151: LD_VAR 0 3
99155: PUSH
99156: LD_INT 1
99158: DOUBLE
99159: EQUAL
99160: IFTRUE 99164
99162: GO 99171
99164: POP
// hHackUnlimitedResources ; 2 :
99165: CALL 111540 0 0
99169: GO 99277
99171: LD_INT 2
99173: DOUBLE
99174: EQUAL
99175: IFTRUE 99179
99177: GO 99186
99179: POP
// hHackSetLevel10 ; 3 :
99180: CALL 111673 0 0
99184: GO 99277
99186: LD_INT 3
99188: DOUBLE
99189: EQUAL
99190: IFTRUE 99194
99192: GO 99201
99194: POP
// hHackSetLevel10YourUnits ; 4 :
99195: CALL 111758 0 0
99199: GO 99277
99201: LD_INT 4
99203: DOUBLE
99204: EQUAL
99205: IFTRUE 99209
99207: GO 99216
99209: POP
// hHackInvincible ; 5 :
99210: CALL 112206 0 0
99214: GO 99277
99216: LD_INT 5
99218: DOUBLE
99219: EQUAL
99220: IFTRUE 99224
99222: GO 99231
99224: POP
// hHackInvisible ; 6 :
99225: CALL 112317 0 0
99229: GO 99277
99231: LD_INT 6
99233: DOUBLE
99234: EQUAL
99235: IFTRUE 99239
99237: GO 99246
99239: POP
// hHackChangeYourSide ; 7 :
99240: CALL 112374 0 0
99244: GO 99277
99246: LD_INT 7
99248: DOUBLE
99249: EQUAL
99250: IFTRUE 99254
99252: GO 99261
99254: POP
// hHackChangeUnitSide ; 8 :
99255: CALL 112416 0 0
99259: GO 99277
99261: LD_INT 8
99263: DOUBLE
99264: EQUAL
99265: IFTRUE 99269
99267: GO 99276
99269: POP
// hHackFog ; end ;
99270: CALL 112517 0 0
99274: GO 99277
99276: POP
// end ; if p2 = game_save_mode then
99277: LD_VAR 0 2
99281: PUSH
99282: LD_INT 102
99284: EQUAL
99285: IFFALSE 99342
// begin if p3 = 1 then
99287: LD_VAR 0 3
99291: PUSH
99292: LD_INT 1
99294: EQUAL
99295: IFFALSE 99307
// globalGameSaveCounter := p4 ;
99297: LD_ADDR_EXP 125
99301: PUSH
99302: LD_VAR 0 4
99306: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
99307: LD_VAR 0 3
99311: PUSH
99312: LD_INT 2
99314: EQUAL
99315: IFFALSE 99323
99317: PUSH
99318: LD_EXP 125
99322: AND
99323: IFFALSE 99342
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
99325: LD_STRING setGameSaveCounter(
99327: PUSH
99328: LD_EXP 125
99332: STR
99333: PUSH
99334: LD_STRING )
99336: STR
99337: PPUSH
99338: CALL_OW 559
// end ; end ;
99342: LD_VAR 0 7
99346: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
99347: LD_INT 0
99349: PPUSH
// streamModeActive := false ;
99350: LD_ADDR_EXP 126
99354: PUSH
99355: LD_INT 0
99357: ST_TO_ADDR
// normalCounter := 36 ;
99358: LD_ADDR_EXP 127
99362: PUSH
99363: LD_INT 36
99365: ST_TO_ADDR
// hardcoreCounter := 18 ;
99366: LD_ADDR_EXP 128
99370: PUSH
99371: LD_INT 18
99373: ST_TO_ADDR
// sRocket := false ;
99374: LD_ADDR_EXP 131
99378: PUSH
99379: LD_INT 0
99381: ST_TO_ADDR
// sSpeed := false ;
99382: LD_ADDR_EXP 130
99386: PUSH
99387: LD_INT 0
99389: ST_TO_ADDR
// sEngine := false ;
99390: LD_ADDR_EXP 132
99394: PUSH
99395: LD_INT 0
99397: ST_TO_ADDR
// sSpec := false ;
99398: LD_ADDR_EXP 129
99402: PUSH
99403: LD_INT 0
99405: ST_TO_ADDR
// sLevel := false ;
99406: LD_ADDR_EXP 133
99410: PUSH
99411: LD_INT 0
99413: ST_TO_ADDR
// sArmoury := false ;
99414: LD_ADDR_EXP 134
99418: PUSH
99419: LD_INT 0
99421: ST_TO_ADDR
// sRadar := false ;
99422: LD_ADDR_EXP 135
99426: PUSH
99427: LD_INT 0
99429: ST_TO_ADDR
// sBunker := false ;
99430: LD_ADDR_EXP 136
99434: PUSH
99435: LD_INT 0
99437: ST_TO_ADDR
// sHack := false ;
99438: LD_ADDR_EXP 137
99442: PUSH
99443: LD_INT 0
99445: ST_TO_ADDR
// sFire := false ;
99446: LD_ADDR_EXP 138
99450: PUSH
99451: LD_INT 0
99453: ST_TO_ADDR
// sRefresh := false ;
99454: LD_ADDR_EXP 139
99458: PUSH
99459: LD_INT 0
99461: ST_TO_ADDR
// sExp := false ;
99462: LD_ADDR_EXP 140
99466: PUSH
99467: LD_INT 0
99469: ST_TO_ADDR
// sDepot := false ;
99470: LD_ADDR_EXP 141
99474: PUSH
99475: LD_INT 0
99477: ST_TO_ADDR
// sFlag := false ;
99478: LD_ADDR_EXP 142
99482: PUSH
99483: LD_INT 0
99485: ST_TO_ADDR
// sKamikadze := false ;
99486: LD_ADDR_EXP 150
99490: PUSH
99491: LD_INT 0
99493: ST_TO_ADDR
// sTroll := false ;
99494: LD_ADDR_EXP 151
99498: PUSH
99499: LD_INT 0
99501: ST_TO_ADDR
// sSlow := false ;
99502: LD_ADDR_EXP 152
99506: PUSH
99507: LD_INT 0
99509: ST_TO_ADDR
// sLack := false ;
99510: LD_ADDR_EXP 153
99514: PUSH
99515: LD_INT 0
99517: ST_TO_ADDR
// sTank := false ;
99518: LD_ADDR_EXP 155
99522: PUSH
99523: LD_INT 0
99525: ST_TO_ADDR
// sRemote := false ;
99526: LD_ADDR_EXP 156
99530: PUSH
99531: LD_INT 0
99533: ST_TO_ADDR
// sPowell := false ;
99534: LD_ADDR_EXP 157
99538: PUSH
99539: LD_INT 0
99541: ST_TO_ADDR
// sTeleport := false ;
99542: LD_ADDR_EXP 160
99546: PUSH
99547: LD_INT 0
99549: ST_TO_ADDR
// sOilTower := false ;
99550: LD_ADDR_EXP 162
99554: PUSH
99555: LD_INT 0
99557: ST_TO_ADDR
// sShovel := false ;
99558: LD_ADDR_EXP 163
99562: PUSH
99563: LD_INT 0
99565: ST_TO_ADDR
// sSheik := false ;
99566: LD_ADDR_EXP 164
99570: PUSH
99571: LD_INT 0
99573: ST_TO_ADDR
// sEarthquake := false ;
99574: LD_ADDR_EXP 166
99578: PUSH
99579: LD_INT 0
99581: ST_TO_ADDR
// sAI := false ;
99582: LD_ADDR_EXP 167
99586: PUSH
99587: LD_INT 0
99589: ST_TO_ADDR
// sCargo := false ;
99590: LD_ADDR_EXP 170
99594: PUSH
99595: LD_INT 0
99597: ST_TO_ADDR
// sDLaser := false ;
99598: LD_ADDR_EXP 171
99602: PUSH
99603: LD_INT 0
99605: ST_TO_ADDR
// sExchange := false ;
99606: LD_ADDR_EXP 172
99610: PUSH
99611: LD_INT 0
99613: ST_TO_ADDR
// sFac := false ;
99614: LD_ADDR_EXP 173
99618: PUSH
99619: LD_INT 0
99621: ST_TO_ADDR
// sPower := false ;
99622: LD_ADDR_EXP 174
99626: PUSH
99627: LD_INT 0
99629: ST_TO_ADDR
// sRandom := false ;
99630: LD_ADDR_EXP 175
99634: PUSH
99635: LD_INT 0
99637: ST_TO_ADDR
// sShield := false ;
99638: LD_ADDR_EXP 176
99642: PUSH
99643: LD_INT 0
99645: ST_TO_ADDR
// sTime := false ;
99646: LD_ADDR_EXP 177
99650: PUSH
99651: LD_INT 0
99653: ST_TO_ADDR
// sTools := false ;
99654: LD_ADDR_EXP 178
99658: PUSH
99659: LD_INT 0
99661: ST_TO_ADDR
// sSold := false ;
99662: LD_ADDR_EXP 143
99666: PUSH
99667: LD_INT 0
99669: ST_TO_ADDR
// sDiff := false ;
99670: LD_ADDR_EXP 144
99674: PUSH
99675: LD_INT 0
99677: ST_TO_ADDR
// sFog := false ;
99678: LD_ADDR_EXP 147
99682: PUSH
99683: LD_INT 0
99685: ST_TO_ADDR
// sReset := false ;
99686: LD_ADDR_EXP 148
99690: PUSH
99691: LD_INT 0
99693: ST_TO_ADDR
// sSun := false ;
99694: LD_ADDR_EXP 149
99698: PUSH
99699: LD_INT 0
99701: ST_TO_ADDR
// sTiger := false ;
99702: LD_ADDR_EXP 145
99706: PUSH
99707: LD_INT 0
99709: ST_TO_ADDR
// sBomb := false ;
99710: LD_ADDR_EXP 146
99714: PUSH
99715: LD_INT 0
99717: ST_TO_ADDR
// sWound := false ;
99718: LD_ADDR_EXP 154
99722: PUSH
99723: LD_INT 0
99725: ST_TO_ADDR
// sBetray := false ;
99726: LD_ADDR_EXP 158
99730: PUSH
99731: LD_INT 0
99733: ST_TO_ADDR
// sContamin := false ;
99734: LD_ADDR_EXP 159
99738: PUSH
99739: LD_INT 0
99741: ST_TO_ADDR
// sOil := false ;
99742: LD_ADDR_EXP 161
99746: PUSH
99747: LD_INT 0
99749: ST_TO_ADDR
// sStu := false ;
99750: LD_ADDR_EXP 165
99754: PUSH
99755: LD_INT 0
99757: ST_TO_ADDR
// sBazooka := false ;
99758: LD_ADDR_EXP 168
99762: PUSH
99763: LD_INT 0
99765: ST_TO_ADDR
// sMortar := false ;
99766: LD_ADDR_EXP 169
99770: PUSH
99771: LD_INT 0
99773: ST_TO_ADDR
// sRanger := false ;
99774: LD_ADDR_EXP 179
99778: PUSH
99779: LD_INT 0
99781: ST_TO_ADDR
// sComputer := false ;
99782: LD_ADDR_EXP 180
99786: PUSH
99787: LD_INT 0
99789: ST_TO_ADDR
// s30 := false ;
99790: LD_ADDR_EXP 181
99794: PUSH
99795: LD_INT 0
99797: ST_TO_ADDR
// s60 := false ;
99798: LD_ADDR_EXP 182
99802: PUSH
99803: LD_INT 0
99805: ST_TO_ADDR
// end ;
99806: LD_VAR 0 1
99810: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
99811: LD_INT 0
99813: PPUSH
99814: PPUSH
99815: PPUSH
99816: PPUSH
99817: PPUSH
99818: PPUSH
99819: PPUSH
// result := [ ] ;
99820: LD_ADDR_VAR 0 2
99824: PUSH
99825: EMPTY
99826: ST_TO_ADDR
// if campaign_id = 1 then
99827: LD_OWVAR 69
99831: PUSH
99832: LD_INT 1
99834: EQUAL
99835: IFFALSE 103001
// begin case mission_number of 1 :
99837: LD_OWVAR 70
99841: PUSH
99842: LD_INT 1
99844: DOUBLE
99845: EQUAL
99846: IFTRUE 99850
99848: GO 99926
99850: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
99851: LD_ADDR_VAR 0 2
99855: PUSH
99856: LD_INT 2
99858: PUSH
99859: LD_INT 4
99861: PUSH
99862: LD_INT 11
99864: PUSH
99865: LD_INT 12
99867: PUSH
99868: LD_INT 15
99870: PUSH
99871: LD_INT 16
99873: PUSH
99874: LD_INT 22
99876: PUSH
99877: LD_INT 23
99879: PUSH
99880: LD_INT 26
99882: PUSH
99883: EMPTY
99884: LIST
99885: LIST
99886: LIST
99887: LIST
99888: LIST
99889: LIST
99890: LIST
99891: LIST
99892: LIST
99893: PUSH
99894: LD_INT 101
99896: PUSH
99897: LD_INT 102
99899: PUSH
99900: LD_INT 106
99902: PUSH
99903: LD_INT 116
99905: PUSH
99906: LD_INT 117
99908: PUSH
99909: LD_INT 118
99911: PUSH
99912: EMPTY
99913: LIST
99914: LIST
99915: LIST
99916: LIST
99917: LIST
99918: LIST
99919: PUSH
99920: EMPTY
99921: LIST
99922: LIST
99923: ST_TO_ADDR
99924: GO 102999
99926: LD_INT 2
99928: DOUBLE
99929: EQUAL
99930: IFTRUE 99934
99932: GO 100018
99934: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
99935: LD_ADDR_VAR 0 2
99939: PUSH
99940: LD_INT 2
99942: PUSH
99943: LD_INT 4
99945: PUSH
99946: LD_INT 11
99948: PUSH
99949: LD_INT 12
99951: PUSH
99952: LD_INT 15
99954: PUSH
99955: LD_INT 16
99957: PUSH
99958: LD_INT 22
99960: PUSH
99961: LD_INT 23
99963: PUSH
99964: LD_INT 26
99966: PUSH
99967: EMPTY
99968: LIST
99969: LIST
99970: LIST
99971: LIST
99972: LIST
99973: LIST
99974: LIST
99975: LIST
99976: LIST
99977: PUSH
99978: LD_INT 101
99980: PUSH
99981: LD_INT 102
99983: PUSH
99984: LD_INT 105
99986: PUSH
99987: LD_INT 106
99989: PUSH
99990: LD_INT 108
99992: PUSH
99993: LD_INT 116
99995: PUSH
99996: LD_INT 117
99998: PUSH
99999: LD_INT 118
100001: PUSH
100002: EMPTY
100003: LIST
100004: LIST
100005: LIST
100006: LIST
100007: LIST
100008: LIST
100009: LIST
100010: LIST
100011: PUSH
100012: EMPTY
100013: LIST
100014: LIST
100015: ST_TO_ADDR
100016: GO 102999
100018: LD_INT 3
100020: DOUBLE
100021: EQUAL
100022: IFTRUE 100026
100024: GO 100114
100026: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
100027: LD_ADDR_VAR 0 2
100031: PUSH
100032: LD_INT 2
100034: PUSH
100035: LD_INT 4
100037: PUSH
100038: LD_INT 5
100040: PUSH
100041: LD_INT 11
100043: PUSH
100044: LD_INT 12
100046: PUSH
100047: LD_INT 15
100049: PUSH
100050: LD_INT 16
100052: PUSH
100053: LD_INT 22
100055: PUSH
100056: LD_INT 26
100058: PUSH
100059: LD_INT 36
100061: PUSH
100062: EMPTY
100063: LIST
100064: LIST
100065: LIST
100066: LIST
100067: LIST
100068: LIST
100069: LIST
100070: LIST
100071: LIST
100072: LIST
100073: PUSH
100074: LD_INT 101
100076: PUSH
100077: LD_INT 102
100079: PUSH
100080: LD_INT 105
100082: PUSH
100083: LD_INT 106
100085: PUSH
100086: LD_INT 108
100088: PUSH
100089: LD_INT 116
100091: PUSH
100092: LD_INT 117
100094: PUSH
100095: LD_INT 118
100097: PUSH
100098: EMPTY
100099: LIST
100100: LIST
100101: LIST
100102: LIST
100103: LIST
100104: LIST
100105: LIST
100106: LIST
100107: PUSH
100108: EMPTY
100109: LIST
100110: LIST
100111: ST_TO_ADDR
100112: GO 102999
100114: LD_INT 4
100116: DOUBLE
100117: EQUAL
100118: IFTRUE 100122
100120: GO 100218
100122: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
100123: LD_ADDR_VAR 0 2
100127: PUSH
100128: LD_INT 2
100130: PUSH
100131: LD_INT 4
100133: PUSH
100134: LD_INT 5
100136: PUSH
100137: LD_INT 8
100139: PUSH
100140: LD_INT 11
100142: PUSH
100143: LD_INT 12
100145: PUSH
100146: LD_INT 15
100148: PUSH
100149: LD_INT 16
100151: PUSH
100152: LD_INT 22
100154: PUSH
100155: LD_INT 23
100157: PUSH
100158: LD_INT 26
100160: PUSH
100161: LD_INT 36
100163: PUSH
100164: EMPTY
100165: LIST
100166: LIST
100167: LIST
100168: LIST
100169: LIST
100170: LIST
100171: LIST
100172: LIST
100173: LIST
100174: LIST
100175: LIST
100176: LIST
100177: PUSH
100178: LD_INT 101
100180: PUSH
100181: LD_INT 102
100183: PUSH
100184: LD_INT 105
100186: PUSH
100187: LD_INT 106
100189: PUSH
100190: LD_INT 108
100192: PUSH
100193: LD_INT 116
100195: PUSH
100196: LD_INT 117
100198: PUSH
100199: LD_INT 118
100201: PUSH
100202: EMPTY
100203: LIST
100204: LIST
100205: LIST
100206: LIST
100207: LIST
100208: LIST
100209: LIST
100210: LIST
100211: PUSH
100212: EMPTY
100213: LIST
100214: LIST
100215: ST_TO_ADDR
100216: GO 102999
100218: LD_INT 5
100220: DOUBLE
100221: EQUAL
100222: IFTRUE 100226
100224: GO 100338
100226: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
100227: LD_ADDR_VAR 0 2
100231: PUSH
100232: LD_INT 2
100234: PUSH
100235: LD_INT 4
100237: PUSH
100238: LD_INT 5
100240: PUSH
100241: LD_INT 6
100243: PUSH
100244: LD_INT 8
100246: PUSH
100247: LD_INT 11
100249: PUSH
100250: LD_INT 12
100252: PUSH
100253: LD_INT 15
100255: PUSH
100256: LD_INT 16
100258: PUSH
100259: LD_INT 22
100261: PUSH
100262: LD_INT 23
100264: PUSH
100265: LD_INT 25
100267: PUSH
100268: LD_INT 26
100270: PUSH
100271: LD_INT 36
100273: PUSH
100274: EMPTY
100275: LIST
100276: LIST
100277: LIST
100278: LIST
100279: LIST
100280: LIST
100281: LIST
100282: LIST
100283: LIST
100284: LIST
100285: LIST
100286: LIST
100287: LIST
100288: LIST
100289: PUSH
100290: LD_INT 101
100292: PUSH
100293: LD_INT 102
100295: PUSH
100296: LD_INT 105
100298: PUSH
100299: LD_INT 106
100301: PUSH
100302: LD_INT 108
100304: PUSH
100305: LD_INT 109
100307: PUSH
100308: LD_INT 112
100310: PUSH
100311: LD_INT 116
100313: PUSH
100314: LD_INT 117
100316: PUSH
100317: LD_INT 118
100319: PUSH
100320: EMPTY
100321: LIST
100322: LIST
100323: LIST
100324: LIST
100325: LIST
100326: LIST
100327: LIST
100328: LIST
100329: LIST
100330: LIST
100331: PUSH
100332: EMPTY
100333: LIST
100334: LIST
100335: ST_TO_ADDR
100336: GO 102999
100338: LD_INT 6
100340: DOUBLE
100341: EQUAL
100342: IFTRUE 100346
100344: GO 100478
100346: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
100347: LD_ADDR_VAR 0 2
100351: PUSH
100352: LD_INT 2
100354: PUSH
100355: LD_INT 4
100357: PUSH
100358: LD_INT 5
100360: PUSH
100361: LD_INT 6
100363: PUSH
100364: LD_INT 8
100366: PUSH
100367: LD_INT 11
100369: PUSH
100370: LD_INT 12
100372: PUSH
100373: LD_INT 15
100375: PUSH
100376: LD_INT 16
100378: PUSH
100379: LD_INT 20
100381: PUSH
100382: LD_INT 21
100384: PUSH
100385: LD_INT 22
100387: PUSH
100388: LD_INT 23
100390: PUSH
100391: LD_INT 25
100393: PUSH
100394: LD_INT 26
100396: PUSH
100397: LD_INT 30
100399: PUSH
100400: LD_INT 31
100402: PUSH
100403: LD_INT 32
100405: PUSH
100406: LD_INT 36
100408: PUSH
100409: EMPTY
100410: LIST
100411: LIST
100412: LIST
100413: LIST
100414: LIST
100415: LIST
100416: LIST
100417: LIST
100418: LIST
100419: LIST
100420: LIST
100421: LIST
100422: LIST
100423: LIST
100424: LIST
100425: LIST
100426: LIST
100427: LIST
100428: LIST
100429: PUSH
100430: LD_INT 101
100432: PUSH
100433: LD_INT 102
100435: PUSH
100436: LD_INT 105
100438: PUSH
100439: LD_INT 106
100441: PUSH
100442: LD_INT 108
100444: PUSH
100445: LD_INT 109
100447: PUSH
100448: LD_INT 112
100450: PUSH
100451: LD_INT 116
100453: PUSH
100454: LD_INT 117
100456: PUSH
100457: LD_INT 118
100459: PUSH
100460: EMPTY
100461: LIST
100462: LIST
100463: LIST
100464: LIST
100465: LIST
100466: LIST
100467: LIST
100468: LIST
100469: LIST
100470: LIST
100471: PUSH
100472: EMPTY
100473: LIST
100474: LIST
100475: ST_TO_ADDR
100476: GO 102999
100478: LD_INT 7
100480: DOUBLE
100481: EQUAL
100482: IFTRUE 100486
100484: GO 100598
100486: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
100487: LD_ADDR_VAR 0 2
100491: PUSH
100492: LD_INT 2
100494: PUSH
100495: LD_INT 4
100497: PUSH
100498: LD_INT 5
100500: PUSH
100501: LD_INT 7
100503: PUSH
100504: LD_INT 11
100506: PUSH
100507: LD_INT 12
100509: PUSH
100510: LD_INT 15
100512: PUSH
100513: LD_INT 16
100515: PUSH
100516: LD_INT 20
100518: PUSH
100519: LD_INT 21
100521: PUSH
100522: LD_INT 22
100524: PUSH
100525: LD_INT 23
100527: PUSH
100528: LD_INT 25
100530: PUSH
100531: LD_INT 26
100533: PUSH
100534: EMPTY
100535: LIST
100536: LIST
100537: LIST
100538: LIST
100539: LIST
100540: LIST
100541: LIST
100542: LIST
100543: LIST
100544: LIST
100545: LIST
100546: LIST
100547: LIST
100548: LIST
100549: PUSH
100550: LD_INT 101
100552: PUSH
100553: LD_INT 102
100555: PUSH
100556: LD_INT 103
100558: PUSH
100559: LD_INT 105
100561: PUSH
100562: LD_INT 106
100564: PUSH
100565: LD_INT 108
100567: PUSH
100568: LD_INT 112
100570: PUSH
100571: LD_INT 116
100573: PUSH
100574: LD_INT 117
100576: PUSH
100577: LD_INT 118
100579: PUSH
100580: EMPTY
100581: LIST
100582: LIST
100583: LIST
100584: LIST
100585: LIST
100586: LIST
100587: LIST
100588: LIST
100589: LIST
100590: LIST
100591: PUSH
100592: EMPTY
100593: LIST
100594: LIST
100595: ST_TO_ADDR
100596: GO 102999
100598: LD_INT 8
100600: DOUBLE
100601: EQUAL
100602: IFTRUE 100606
100604: GO 100746
100606: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
100607: LD_ADDR_VAR 0 2
100611: PUSH
100612: LD_INT 2
100614: PUSH
100615: LD_INT 4
100617: PUSH
100618: LD_INT 5
100620: PUSH
100621: LD_INT 6
100623: PUSH
100624: LD_INT 7
100626: PUSH
100627: LD_INT 8
100629: PUSH
100630: LD_INT 11
100632: PUSH
100633: LD_INT 12
100635: PUSH
100636: LD_INT 15
100638: PUSH
100639: LD_INT 16
100641: PUSH
100642: LD_INT 20
100644: PUSH
100645: LD_INT 21
100647: PUSH
100648: LD_INT 22
100650: PUSH
100651: LD_INT 23
100653: PUSH
100654: LD_INT 25
100656: PUSH
100657: LD_INT 26
100659: PUSH
100660: LD_INT 30
100662: PUSH
100663: LD_INT 31
100665: PUSH
100666: LD_INT 32
100668: PUSH
100669: LD_INT 36
100671: PUSH
100672: EMPTY
100673: LIST
100674: LIST
100675: LIST
100676: LIST
100677: LIST
100678: LIST
100679: LIST
100680: LIST
100681: LIST
100682: LIST
100683: LIST
100684: LIST
100685: LIST
100686: LIST
100687: LIST
100688: LIST
100689: LIST
100690: LIST
100691: LIST
100692: LIST
100693: PUSH
100694: LD_INT 101
100696: PUSH
100697: LD_INT 102
100699: PUSH
100700: LD_INT 103
100702: PUSH
100703: LD_INT 105
100705: PUSH
100706: LD_INT 106
100708: PUSH
100709: LD_INT 108
100711: PUSH
100712: LD_INT 109
100714: PUSH
100715: LD_INT 112
100717: PUSH
100718: LD_INT 116
100720: PUSH
100721: LD_INT 117
100723: PUSH
100724: LD_INT 118
100726: PUSH
100727: EMPTY
100728: LIST
100729: LIST
100730: LIST
100731: LIST
100732: LIST
100733: LIST
100734: LIST
100735: LIST
100736: LIST
100737: LIST
100738: LIST
100739: PUSH
100740: EMPTY
100741: LIST
100742: LIST
100743: ST_TO_ADDR
100744: GO 102999
100746: LD_INT 9
100748: DOUBLE
100749: EQUAL
100750: IFTRUE 100754
100752: GO 100902
100754: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
100755: LD_ADDR_VAR 0 2
100759: PUSH
100760: LD_INT 2
100762: PUSH
100763: LD_INT 4
100765: PUSH
100766: LD_INT 5
100768: PUSH
100769: LD_INT 6
100771: PUSH
100772: LD_INT 7
100774: PUSH
100775: LD_INT 8
100777: PUSH
100778: LD_INT 11
100780: PUSH
100781: LD_INT 12
100783: PUSH
100784: LD_INT 15
100786: PUSH
100787: LD_INT 16
100789: PUSH
100790: LD_INT 20
100792: PUSH
100793: LD_INT 21
100795: PUSH
100796: LD_INT 22
100798: PUSH
100799: LD_INT 23
100801: PUSH
100802: LD_INT 25
100804: PUSH
100805: LD_INT 26
100807: PUSH
100808: LD_INT 28
100810: PUSH
100811: LD_INT 30
100813: PUSH
100814: LD_INT 31
100816: PUSH
100817: LD_INT 32
100819: PUSH
100820: LD_INT 36
100822: PUSH
100823: EMPTY
100824: LIST
100825: LIST
100826: LIST
100827: LIST
100828: LIST
100829: LIST
100830: LIST
100831: LIST
100832: LIST
100833: LIST
100834: LIST
100835: LIST
100836: LIST
100837: LIST
100838: LIST
100839: LIST
100840: LIST
100841: LIST
100842: LIST
100843: LIST
100844: LIST
100845: PUSH
100846: LD_INT 101
100848: PUSH
100849: LD_INT 102
100851: PUSH
100852: LD_INT 103
100854: PUSH
100855: LD_INT 105
100857: PUSH
100858: LD_INT 106
100860: PUSH
100861: LD_INT 108
100863: PUSH
100864: LD_INT 109
100866: PUSH
100867: LD_INT 112
100869: PUSH
100870: LD_INT 114
100872: PUSH
100873: LD_INT 116
100875: PUSH
100876: LD_INT 117
100878: PUSH
100879: LD_INT 118
100881: PUSH
100882: EMPTY
100883: LIST
100884: LIST
100885: LIST
100886: LIST
100887: LIST
100888: LIST
100889: LIST
100890: LIST
100891: LIST
100892: LIST
100893: LIST
100894: LIST
100895: PUSH
100896: EMPTY
100897: LIST
100898: LIST
100899: ST_TO_ADDR
100900: GO 102999
100902: LD_INT 10
100904: DOUBLE
100905: EQUAL
100906: IFTRUE 100910
100908: GO 101106
100910: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
100911: LD_ADDR_VAR 0 2
100915: PUSH
100916: LD_INT 2
100918: PUSH
100919: LD_INT 4
100921: PUSH
100922: LD_INT 5
100924: PUSH
100925: LD_INT 6
100927: PUSH
100928: LD_INT 7
100930: PUSH
100931: LD_INT 8
100933: PUSH
100934: LD_INT 9
100936: PUSH
100937: LD_INT 10
100939: PUSH
100940: LD_INT 11
100942: PUSH
100943: LD_INT 12
100945: PUSH
100946: LD_INT 13
100948: PUSH
100949: LD_INT 14
100951: PUSH
100952: LD_INT 15
100954: PUSH
100955: LD_INT 16
100957: PUSH
100958: LD_INT 17
100960: PUSH
100961: LD_INT 18
100963: PUSH
100964: LD_INT 19
100966: PUSH
100967: LD_INT 20
100969: PUSH
100970: LD_INT 21
100972: PUSH
100973: LD_INT 22
100975: PUSH
100976: LD_INT 23
100978: PUSH
100979: LD_INT 24
100981: PUSH
100982: LD_INT 25
100984: PUSH
100985: LD_INT 26
100987: PUSH
100988: LD_INT 28
100990: PUSH
100991: LD_INT 30
100993: PUSH
100994: LD_INT 31
100996: PUSH
100997: LD_INT 32
100999: PUSH
101000: LD_INT 36
101002: PUSH
101003: EMPTY
101004: LIST
101005: LIST
101006: LIST
101007: LIST
101008: LIST
101009: LIST
101010: LIST
101011: LIST
101012: LIST
101013: LIST
101014: LIST
101015: LIST
101016: LIST
101017: LIST
101018: LIST
101019: LIST
101020: LIST
101021: LIST
101022: LIST
101023: LIST
101024: LIST
101025: LIST
101026: LIST
101027: LIST
101028: LIST
101029: LIST
101030: LIST
101031: LIST
101032: LIST
101033: PUSH
101034: LD_INT 101
101036: PUSH
101037: LD_INT 102
101039: PUSH
101040: LD_INT 103
101042: PUSH
101043: LD_INT 104
101045: PUSH
101046: LD_INT 105
101048: PUSH
101049: LD_INT 106
101051: PUSH
101052: LD_INT 107
101054: PUSH
101055: LD_INT 108
101057: PUSH
101058: LD_INT 109
101060: PUSH
101061: LD_INT 110
101063: PUSH
101064: LD_INT 111
101066: PUSH
101067: LD_INT 112
101069: PUSH
101070: LD_INT 114
101072: PUSH
101073: LD_INT 116
101075: PUSH
101076: LD_INT 117
101078: PUSH
101079: LD_INT 118
101081: PUSH
101082: EMPTY
101083: LIST
101084: LIST
101085: LIST
101086: LIST
101087: LIST
101088: LIST
101089: LIST
101090: LIST
101091: LIST
101092: LIST
101093: LIST
101094: LIST
101095: LIST
101096: LIST
101097: LIST
101098: LIST
101099: PUSH
101100: EMPTY
101101: LIST
101102: LIST
101103: ST_TO_ADDR
101104: GO 102999
101106: LD_INT 11
101108: DOUBLE
101109: EQUAL
101110: IFTRUE 101114
101112: GO 101318
101114: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
101115: LD_ADDR_VAR 0 2
101119: PUSH
101120: LD_INT 2
101122: PUSH
101123: LD_INT 3
101125: PUSH
101126: LD_INT 4
101128: PUSH
101129: LD_INT 5
101131: PUSH
101132: LD_INT 6
101134: PUSH
101135: LD_INT 7
101137: PUSH
101138: LD_INT 8
101140: PUSH
101141: LD_INT 9
101143: PUSH
101144: LD_INT 10
101146: PUSH
101147: LD_INT 11
101149: PUSH
101150: LD_INT 12
101152: PUSH
101153: LD_INT 13
101155: PUSH
101156: LD_INT 14
101158: PUSH
101159: LD_INT 15
101161: PUSH
101162: LD_INT 16
101164: PUSH
101165: LD_INT 17
101167: PUSH
101168: LD_INT 18
101170: PUSH
101171: LD_INT 19
101173: PUSH
101174: LD_INT 20
101176: PUSH
101177: LD_INT 21
101179: PUSH
101180: LD_INT 22
101182: PUSH
101183: LD_INT 23
101185: PUSH
101186: LD_INT 24
101188: PUSH
101189: LD_INT 25
101191: PUSH
101192: LD_INT 26
101194: PUSH
101195: LD_INT 28
101197: PUSH
101198: LD_INT 30
101200: PUSH
101201: LD_INT 31
101203: PUSH
101204: LD_INT 32
101206: PUSH
101207: LD_INT 34
101209: PUSH
101210: LD_INT 36
101212: PUSH
101213: EMPTY
101214: LIST
101215: LIST
101216: LIST
101217: LIST
101218: LIST
101219: LIST
101220: LIST
101221: LIST
101222: LIST
101223: LIST
101224: LIST
101225: LIST
101226: LIST
101227: LIST
101228: LIST
101229: LIST
101230: LIST
101231: LIST
101232: LIST
101233: LIST
101234: LIST
101235: LIST
101236: LIST
101237: LIST
101238: LIST
101239: LIST
101240: LIST
101241: LIST
101242: LIST
101243: LIST
101244: LIST
101245: PUSH
101246: LD_INT 101
101248: PUSH
101249: LD_INT 102
101251: PUSH
101252: LD_INT 103
101254: PUSH
101255: LD_INT 104
101257: PUSH
101258: LD_INT 105
101260: PUSH
101261: LD_INT 106
101263: PUSH
101264: LD_INT 107
101266: PUSH
101267: LD_INT 108
101269: PUSH
101270: LD_INT 109
101272: PUSH
101273: LD_INT 110
101275: PUSH
101276: LD_INT 111
101278: PUSH
101279: LD_INT 112
101281: PUSH
101282: LD_INT 114
101284: PUSH
101285: LD_INT 116
101287: PUSH
101288: LD_INT 117
101290: PUSH
101291: LD_INT 118
101293: PUSH
101294: EMPTY
101295: LIST
101296: LIST
101297: LIST
101298: LIST
101299: LIST
101300: LIST
101301: LIST
101302: LIST
101303: LIST
101304: LIST
101305: LIST
101306: LIST
101307: LIST
101308: LIST
101309: LIST
101310: LIST
101311: PUSH
101312: EMPTY
101313: LIST
101314: LIST
101315: ST_TO_ADDR
101316: GO 102999
101318: LD_INT 12
101320: DOUBLE
101321: EQUAL
101322: IFTRUE 101326
101324: GO 101546
101326: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
101327: LD_ADDR_VAR 0 2
101331: PUSH
101332: LD_INT 1
101334: PUSH
101335: LD_INT 2
101337: PUSH
101338: LD_INT 3
101340: PUSH
101341: LD_INT 4
101343: PUSH
101344: LD_INT 5
101346: PUSH
101347: LD_INT 6
101349: PUSH
101350: LD_INT 7
101352: PUSH
101353: LD_INT 8
101355: PUSH
101356: LD_INT 9
101358: PUSH
101359: LD_INT 10
101361: PUSH
101362: LD_INT 11
101364: PUSH
101365: LD_INT 12
101367: PUSH
101368: LD_INT 13
101370: PUSH
101371: LD_INT 14
101373: PUSH
101374: LD_INT 15
101376: PUSH
101377: LD_INT 16
101379: PUSH
101380: LD_INT 17
101382: PUSH
101383: LD_INT 18
101385: PUSH
101386: LD_INT 19
101388: PUSH
101389: LD_INT 20
101391: PUSH
101392: LD_INT 21
101394: PUSH
101395: LD_INT 22
101397: PUSH
101398: LD_INT 23
101400: PUSH
101401: LD_INT 24
101403: PUSH
101404: LD_INT 25
101406: PUSH
101407: LD_INT 26
101409: PUSH
101410: LD_INT 27
101412: PUSH
101413: LD_INT 28
101415: PUSH
101416: LD_INT 30
101418: PUSH
101419: LD_INT 31
101421: PUSH
101422: LD_INT 32
101424: PUSH
101425: LD_INT 33
101427: PUSH
101428: LD_INT 34
101430: PUSH
101431: LD_INT 36
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: LIST
101438: LIST
101439: LIST
101440: LIST
101441: LIST
101442: LIST
101443: LIST
101444: LIST
101445: LIST
101446: LIST
101447: LIST
101448: LIST
101449: LIST
101450: LIST
101451: LIST
101452: LIST
101453: LIST
101454: LIST
101455: LIST
101456: LIST
101457: LIST
101458: LIST
101459: LIST
101460: LIST
101461: LIST
101462: LIST
101463: LIST
101464: LIST
101465: LIST
101466: LIST
101467: LIST
101468: LIST
101469: PUSH
101470: LD_INT 101
101472: PUSH
101473: LD_INT 102
101475: PUSH
101476: LD_INT 103
101478: PUSH
101479: LD_INT 104
101481: PUSH
101482: LD_INT 105
101484: PUSH
101485: LD_INT 106
101487: PUSH
101488: LD_INT 107
101490: PUSH
101491: LD_INT 108
101493: PUSH
101494: LD_INT 109
101496: PUSH
101497: LD_INT 110
101499: PUSH
101500: LD_INT 111
101502: PUSH
101503: LD_INT 112
101505: PUSH
101506: LD_INT 113
101508: PUSH
101509: LD_INT 114
101511: PUSH
101512: LD_INT 116
101514: PUSH
101515: LD_INT 117
101517: PUSH
101518: LD_INT 118
101520: PUSH
101521: EMPTY
101522: LIST
101523: LIST
101524: LIST
101525: LIST
101526: LIST
101527: LIST
101528: LIST
101529: LIST
101530: LIST
101531: LIST
101532: LIST
101533: LIST
101534: LIST
101535: LIST
101536: LIST
101537: LIST
101538: LIST
101539: PUSH
101540: EMPTY
101541: LIST
101542: LIST
101543: ST_TO_ADDR
101544: GO 102999
101546: LD_INT 13
101548: DOUBLE
101549: EQUAL
101550: IFTRUE 101554
101552: GO 101762
101554: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
101555: LD_ADDR_VAR 0 2
101559: PUSH
101560: LD_INT 1
101562: PUSH
101563: LD_INT 2
101565: PUSH
101566: LD_INT 3
101568: PUSH
101569: LD_INT 4
101571: PUSH
101572: LD_INT 5
101574: PUSH
101575: LD_INT 8
101577: PUSH
101578: LD_INT 9
101580: PUSH
101581: LD_INT 10
101583: PUSH
101584: LD_INT 11
101586: PUSH
101587: LD_INT 12
101589: PUSH
101590: LD_INT 14
101592: PUSH
101593: LD_INT 15
101595: PUSH
101596: LD_INT 16
101598: PUSH
101599: LD_INT 17
101601: PUSH
101602: LD_INT 18
101604: PUSH
101605: LD_INT 19
101607: PUSH
101608: LD_INT 20
101610: PUSH
101611: LD_INT 21
101613: PUSH
101614: LD_INT 22
101616: PUSH
101617: LD_INT 23
101619: PUSH
101620: LD_INT 24
101622: PUSH
101623: LD_INT 25
101625: PUSH
101626: LD_INT 26
101628: PUSH
101629: LD_INT 27
101631: PUSH
101632: LD_INT 28
101634: PUSH
101635: LD_INT 30
101637: PUSH
101638: LD_INT 31
101640: PUSH
101641: LD_INT 32
101643: PUSH
101644: LD_INT 33
101646: PUSH
101647: LD_INT 34
101649: PUSH
101650: LD_INT 36
101652: PUSH
101653: EMPTY
101654: LIST
101655: LIST
101656: LIST
101657: LIST
101658: LIST
101659: LIST
101660: LIST
101661: LIST
101662: LIST
101663: LIST
101664: LIST
101665: LIST
101666: LIST
101667: LIST
101668: LIST
101669: LIST
101670: LIST
101671: LIST
101672: LIST
101673: LIST
101674: LIST
101675: LIST
101676: LIST
101677: LIST
101678: LIST
101679: LIST
101680: LIST
101681: LIST
101682: LIST
101683: LIST
101684: LIST
101685: PUSH
101686: LD_INT 101
101688: PUSH
101689: LD_INT 102
101691: PUSH
101692: LD_INT 103
101694: PUSH
101695: LD_INT 104
101697: PUSH
101698: LD_INT 105
101700: PUSH
101701: LD_INT 106
101703: PUSH
101704: LD_INT 107
101706: PUSH
101707: LD_INT 108
101709: PUSH
101710: LD_INT 109
101712: PUSH
101713: LD_INT 110
101715: PUSH
101716: LD_INT 111
101718: PUSH
101719: LD_INT 112
101721: PUSH
101722: LD_INT 113
101724: PUSH
101725: LD_INT 114
101727: PUSH
101728: LD_INT 116
101730: PUSH
101731: LD_INT 117
101733: PUSH
101734: LD_INT 118
101736: PUSH
101737: EMPTY
101738: LIST
101739: LIST
101740: LIST
101741: LIST
101742: LIST
101743: LIST
101744: LIST
101745: LIST
101746: LIST
101747: LIST
101748: LIST
101749: LIST
101750: LIST
101751: LIST
101752: LIST
101753: LIST
101754: LIST
101755: PUSH
101756: EMPTY
101757: LIST
101758: LIST
101759: ST_TO_ADDR
101760: GO 102999
101762: LD_INT 14
101764: DOUBLE
101765: EQUAL
101766: IFTRUE 101770
101768: GO 101994
101770: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
101771: LD_ADDR_VAR 0 2
101775: PUSH
101776: LD_INT 1
101778: PUSH
101779: LD_INT 2
101781: PUSH
101782: LD_INT 3
101784: PUSH
101785: LD_INT 4
101787: PUSH
101788: LD_INT 5
101790: PUSH
101791: LD_INT 6
101793: PUSH
101794: LD_INT 7
101796: PUSH
101797: LD_INT 8
101799: PUSH
101800: LD_INT 9
101802: PUSH
101803: LD_INT 10
101805: PUSH
101806: LD_INT 11
101808: PUSH
101809: LD_INT 12
101811: PUSH
101812: LD_INT 13
101814: PUSH
101815: LD_INT 14
101817: PUSH
101818: LD_INT 15
101820: PUSH
101821: LD_INT 16
101823: PUSH
101824: LD_INT 17
101826: PUSH
101827: LD_INT 18
101829: PUSH
101830: LD_INT 19
101832: PUSH
101833: LD_INT 20
101835: PUSH
101836: LD_INT 21
101838: PUSH
101839: LD_INT 22
101841: PUSH
101842: LD_INT 23
101844: PUSH
101845: LD_INT 24
101847: PUSH
101848: LD_INT 25
101850: PUSH
101851: LD_INT 26
101853: PUSH
101854: LD_INT 27
101856: PUSH
101857: LD_INT 28
101859: PUSH
101860: LD_INT 29
101862: PUSH
101863: LD_INT 30
101865: PUSH
101866: LD_INT 31
101868: PUSH
101869: LD_INT 32
101871: PUSH
101872: LD_INT 33
101874: PUSH
101875: LD_INT 34
101877: PUSH
101878: LD_INT 36
101880: PUSH
101881: EMPTY
101882: LIST
101883: LIST
101884: LIST
101885: LIST
101886: LIST
101887: LIST
101888: LIST
101889: LIST
101890: LIST
101891: LIST
101892: LIST
101893: LIST
101894: LIST
101895: LIST
101896: LIST
101897: LIST
101898: LIST
101899: LIST
101900: LIST
101901: LIST
101902: LIST
101903: LIST
101904: LIST
101905: LIST
101906: LIST
101907: LIST
101908: LIST
101909: LIST
101910: LIST
101911: LIST
101912: LIST
101913: LIST
101914: LIST
101915: LIST
101916: LIST
101917: PUSH
101918: LD_INT 101
101920: PUSH
101921: LD_INT 102
101923: PUSH
101924: LD_INT 103
101926: PUSH
101927: LD_INT 104
101929: PUSH
101930: LD_INT 105
101932: PUSH
101933: LD_INT 106
101935: PUSH
101936: LD_INT 107
101938: PUSH
101939: LD_INT 108
101941: PUSH
101942: LD_INT 109
101944: PUSH
101945: LD_INT 110
101947: PUSH
101948: LD_INT 111
101950: PUSH
101951: LD_INT 112
101953: PUSH
101954: LD_INT 113
101956: PUSH
101957: LD_INT 114
101959: PUSH
101960: LD_INT 116
101962: PUSH
101963: LD_INT 117
101965: PUSH
101966: LD_INT 118
101968: PUSH
101969: EMPTY
101970: LIST
101971: LIST
101972: LIST
101973: LIST
101974: LIST
101975: LIST
101976: LIST
101977: LIST
101978: LIST
101979: LIST
101980: LIST
101981: LIST
101982: LIST
101983: LIST
101984: LIST
101985: LIST
101986: LIST
101987: PUSH
101988: EMPTY
101989: LIST
101990: LIST
101991: ST_TO_ADDR
101992: GO 102999
101994: LD_INT 15
101996: DOUBLE
101997: EQUAL
101998: IFTRUE 102002
102000: GO 102226
102002: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
102003: LD_ADDR_VAR 0 2
102007: PUSH
102008: LD_INT 1
102010: PUSH
102011: LD_INT 2
102013: PUSH
102014: LD_INT 3
102016: PUSH
102017: LD_INT 4
102019: PUSH
102020: LD_INT 5
102022: PUSH
102023: LD_INT 6
102025: PUSH
102026: LD_INT 7
102028: PUSH
102029: LD_INT 8
102031: PUSH
102032: LD_INT 9
102034: PUSH
102035: LD_INT 10
102037: PUSH
102038: LD_INT 11
102040: PUSH
102041: LD_INT 12
102043: PUSH
102044: LD_INT 13
102046: PUSH
102047: LD_INT 14
102049: PUSH
102050: LD_INT 15
102052: PUSH
102053: LD_INT 16
102055: PUSH
102056: LD_INT 17
102058: PUSH
102059: LD_INT 18
102061: PUSH
102062: LD_INT 19
102064: PUSH
102065: LD_INT 20
102067: PUSH
102068: LD_INT 21
102070: PUSH
102071: LD_INT 22
102073: PUSH
102074: LD_INT 23
102076: PUSH
102077: LD_INT 24
102079: PUSH
102080: LD_INT 25
102082: PUSH
102083: LD_INT 26
102085: PUSH
102086: LD_INT 27
102088: PUSH
102089: LD_INT 28
102091: PUSH
102092: LD_INT 29
102094: PUSH
102095: LD_INT 30
102097: PUSH
102098: LD_INT 31
102100: PUSH
102101: LD_INT 32
102103: PUSH
102104: LD_INT 33
102106: PUSH
102107: LD_INT 34
102109: PUSH
102110: LD_INT 36
102112: PUSH
102113: EMPTY
102114: LIST
102115: LIST
102116: LIST
102117: LIST
102118: LIST
102119: LIST
102120: LIST
102121: LIST
102122: LIST
102123: LIST
102124: LIST
102125: LIST
102126: LIST
102127: LIST
102128: LIST
102129: LIST
102130: LIST
102131: LIST
102132: LIST
102133: LIST
102134: LIST
102135: LIST
102136: LIST
102137: LIST
102138: LIST
102139: LIST
102140: LIST
102141: LIST
102142: LIST
102143: LIST
102144: LIST
102145: LIST
102146: LIST
102147: LIST
102148: LIST
102149: PUSH
102150: LD_INT 101
102152: PUSH
102153: LD_INT 102
102155: PUSH
102156: LD_INT 103
102158: PUSH
102159: LD_INT 104
102161: PUSH
102162: LD_INT 105
102164: PUSH
102165: LD_INT 106
102167: PUSH
102168: LD_INT 107
102170: PUSH
102171: LD_INT 108
102173: PUSH
102174: LD_INT 109
102176: PUSH
102177: LD_INT 110
102179: PUSH
102180: LD_INT 111
102182: PUSH
102183: LD_INT 112
102185: PUSH
102186: LD_INT 113
102188: PUSH
102189: LD_INT 114
102191: PUSH
102192: LD_INT 116
102194: PUSH
102195: LD_INT 117
102197: PUSH
102198: LD_INT 118
102200: PUSH
102201: EMPTY
102202: LIST
102203: LIST
102204: LIST
102205: LIST
102206: LIST
102207: LIST
102208: LIST
102209: LIST
102210: LIST
102211: LIST
102212: LIST
102213: LIST
102214: LIST
102215: LIST
102216: LIST
102217: LIST
102218: LIST
102219: PUSH
102220: EMPTY
102221: LIST
102222: LIST
102223: ST_TO_ADDR
102224: GO 102999
102226: LD_INT 16
102228: DOUBLE
102229: EQUAL
102230: IFTRUE 102234
102232: GO 102370
102234: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
102235: LD_ADDR_VAR 0 2
102239: PUSH
102240: LD_INT 2
102242: PUSH
102243: LD_INT 4
102245: PUSH
102246: LD_INT 5
102248: PUSH
102249: LD_INT 7
102251: PUSH
102252: LD_INT 11
102254: PUSH
102255: LD_INT 12
102257: PUSH
102258: LD_INT 15
102260: PUSH
102261: LD_INT 16
102263: PUSH
102264: LD_INT 20
102266: PUSH
102267: LD_INT 21
102269: PUSH
102270: LD_INT 22
102272: PUSH
102273: LD_INT 23
102275: PUSH
102276: LD_INT 25
102278: PUSH
102279: LD_INT 26
102281: PUSH
102282: LD_INT 30
102284: PUSH
102285: LD_INT 31
102287: PUSH
102288: LD_INT 32
102290: PUSH
102291: LD_INT 33
102293: PUSH
102294: LD_INT 34
102296: PUSH
102297: EMPTY
102298: LIST
102299: LIST
102300: LIST
102301: LIST
102302: LIST
102303: LIST
102304: LIST
102305: LIST
102306: LIST
102307: LIST
102308: LIST
102309: LIST
102310: LIST
102311: LIST
102312: LIST
102313: LIST
102314: LIST
102315: LIST
102316: LIST
102317: PUSH
102318: LD_INT 101
102320: PUSH
102321: LD_INT 102
102323: PUSH
102324: LD_INT 103
102326: PUSH
102327: LD_INT 106
102329: PUSH
102330: LD_INT 108
102332: PUSH
102333: LD_INT 112
102335: PUSH
102336: LD_INT 113
102338: PUSH
102339: LD_INT 114
102341: PUSH
102342: LD_INT 116
102344: PUSH
102345: LD_INT 117
102347: PUSH
102348: LD_INT 118
102350: PUSH
102351: EMPTY
102352: LIST
102353: LIST
102354: LIST
102355: LIST
102356: LIST
102357: LIST
102358: LIST
102359: LIST
102360: LIST
102361: LIST
102362: LIST
102363: PUSH
102364: EMPTY
102365: LIST
102366: LIST
102367: ST_TO_ADDR
102368: GO 102999
102370: LD_INT 17
102372: DOUBLE
102373: EQUAL
102374: IFTRUE 102378
102376: GO 102602
102378: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
102379: LD_ADDR_VAR 0 2
102383: PUSH
102384: LD_INT 1
102386: PUSH
102387: LD_INT 2
102389: PUSH
102390: LD_INT 3
102392: PUSH
102393: LD_INT 4
102395: PUSH
102396: LD_INT 5
102398: PUSH
102399: LD_INT 6
102401: PUSH
102402: LD_INT 7
102404: PUSH
102405: LD_INT 8
102407: PUSH
102408: LD_INT 9
102410: PUSH
102411: LD_INT 10
102413: PUSH
102414: LD_INT 11
102416: PUSH
102417: LD_INT 12
102419: PUSH
102420: LD_INT 13
102422: PUSH
102423: LD_INT 14
102425: PUSH
102426: LD_INT 15
102428: PUSH
102429: LD_INT 16
102431: PUSH
102432: LD_INT 17
102434: PUSH
102435: LD_INT 18
102437: PUSH
102438: LD_INT 19
102440: PUSH
102441: LD_INT 20
102443: PUSH
102444: LD_INT 21
102446: PUSH
102447: LD_INT 22
102449: PUSH
102450: LD_INT 23
102452: PUSH
102453: LD_INT 24
102455: PUSH
102456: LD_INT 25
102458: PUSH
102459: LD_INT 26
102461: PUSH
102462: LD_INT 27
102464: PUSH
102465: LD_INT 28
102467: PUSH
102468: LD_INT 29
102470: PUSH
102471: LD_INT 30
102473: PUSH
102474: LD_INT 31
102476: PUSH
102477: LD_INT 32
102479: PUSH
102480: LD_INT 33
102482: PUSH
102483: LD_INT 34
102485: PUSH
102486: LD_INT 36
102488: PUSH
102489: EMPTY
102490: LIST
102491: LIST
102492: LIST
102493: LIST
102494: LIST
102495: LIST
102496: LIST
102497: LIST
102498: LIST
102499: LIST
102500: LIST
102501: LIST
102502: LIST
102503: LIST
102504: LIST
102505: LIST
102506: LIST
102507: LIST
102508: LIST
102509: LIST
102510: LIST
102511: LIST
102512: LIST
102513: LIST
102514: LIST
102515: LIST
102516: LIST
102517: LIST
102518: LIST
102519: LIST
102520: LIST
102521: LIST
102522: LIST
102523: LIST
102524: LIST
102525: PUSH
102526: LD_INT 101
102528: PUSH
102529: LD_INT 102
102531: PUSH
102532: LD_INT 103
102534: PUSH
102535: LD_INT 104
102537: PUSH
102538: LD_INT 105
102540: PUSH
102541: LD_INT 106
102543: PUSH
102544: LD_INT 107
102546: PUSH
102547: LD_INT 108
102549: PUSH
102550: LD_INT 109
102552: PUSH
102553: LD_INT 110
102555: PUSH
102556: LD_INT 111
102558: PUSH
102559: LD_INT 112
102561: PUSH
102562: LD_INT 113
102564: PUSH
102565: LD_INT 114
102567: PUSH
102568: LD_INT 116
102570: PUSH
102571: LD_INT 117
102573: PUSH
102574: LD_INT 118
102576: PUSH
102577: EMPTY
102578: LIST
102579: LIST
102580: LIST
102581: LIST
102582: LIST
102583: LIST
102584: LIST
102585: LIST
102586: LIST
102587: LIST
102588: LIST
102589: LIST
102590: LIST
102591: LIST
102592: LIST
102593: LIST
102594: LIST
102595: PUSH
102596: EMPTY
102597: LIST
102598: LIST
102599: ST_TO_ADDR
102600: GO 102999
102602: LD_INT 18
102604: DOUBLE
102605: EQUAL
102606: IFTRUE 102610
102608: GO 102758
102610: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
102611: LD_ADDR_VAR 0 2
102615: PUSH
102616: LD_INT 2
102618: PUSH
102619: LD_INT 4
102621: PUSH
102622: LD_INT 5
102624: PUSH
102625: LD_INT 7
102627: PUSH
102628: LD_INT 11
102630: PUSH
102631: LD_INT 12
102633: PUSH
102634: LD_INT 15
102636: PUSH
102637: LD_INT 16
102639: PUSH
102640: LD_INT 20
102642: PUSH
102643: LD_INT 21
102645: PUSH
102646: LD_INT 22
102648: PUSH
102649: LD_INT 23
102651: PUSH
102652: LD_INT 25
102654: PUSH
102655: LD_INT 26
102657: PUSH
102658: LD_INT 30
102660: PUSH
102661: LD_INT 31
102663: PUSH
102664: LD_INT 32
102666: PUSH
102667: LD_INT 33
102669: PUSH
102670: LD_INT 34
102672: PUSH
102673: LD_INT 35
102675: PUSH
102676: LD_INT 36
102678: PUSH
102679: EMPTY
102680: LIST
102681: LIST
102682: LIST
102683: LIST
102684: LIST
102685: LIST
102686: LIST
102687: LIST
102688: LIST
102689: LIST
102690: LIST
102691: LIST
102692: LIST
102693: LIST
102694: LIST
102695: LIST
102696: LIST
102697: LIST
102698: LIST
102699: LIST
102700: LIST
102701: PUSH
102702: LD_INT 101
102704: PUSH
102705: LD_INT 102
102707: PUSH
102708: LD_INT 103
102710: PUSH
102711: LD_INT 106
102713: PUSH
102714: LD_INT 108
102716: PUSH
102717: LD_INT 112
102719: PUSH
102720: LD_INT 113
102722: PUSH
102723: LD_INT 114
102725: PUSH
102726: LD_INT 115
102728: PUSH
102729: LD_INT 116
102731: PUSH
102732: LD_INT 117
102734: PUSH
102735: LD_INT 118
102737: PUSH
102738: EMPTY
102739: LIST
102740: LIST
102741: LIST
102742: LIST
102743: LIST
102744: LIST
102745: LIST
102746: LIST
102747: LIST
102748: LIST
102749: LIST
102750: LIST
102751: PUSH
102752: EMPTY
102753: LIST
102754: LIST
102755: ST_TO_ADDR
102756: GO 102999
102758: LD_INT 19
102760: DOUBLE
102761: EQUAL
102762: IFTRUE 102766
102764: GO 102998
102766: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
102767: LD_ADDR_VAR 0 2
102771: PUSH
102772: LD_INT 1
102774: PUSH
102775: LD_INT 2
102777: PUSH
102778: LD_INT 3
102780: PUSH
102781: LD_INT 4
102783: PUSH
102784: LD_INT 5
102786: PUSH
102787: LD_INT 6
102789: PUSH
102790: LD_INT 7
102792: PUSH
102793: LD_INT 8
102795: PUSH
102796: LD_INT 9
102798: PUSH
102799: LD_INT 10
102801: PUSH
102802: LD_INT 11
102804: PUSH
102805: LD_INT 12
102807: PUSH
102808: LD_INT 13
102810: PUSH
102811: LD_INT 14
102813: PUSH
102814: LD_INT 15
102816: PUSH
102817: LD_INT 16
102819: PUSH
102820: LD_INT 17
102822: PUSH
102823: LD_INT 18
102825: PUSH
102826: LD_INT 19
102828: PUSH
102829: LD_INT 20
102831: PUSH
102832: LD_INT 21
102834: PUSH
102835: LD_INT 22
102837: PUSH
102838: LD_INT 23
102840: PUSH
102841: LD_INT 24
102843: PUSH
102844: LD_INT 25
102846: PUSH
102847: LD_INT 26
102849: PUSH
102850: LD_INT 27
102852: PUSH
102853: LD_INT 28
102855: PUSH
102856: LD_INT 29
102858: PUSH
102859: LD_INT 30
102861: PUSH
102862: LD_INT 31
102864: PUSH
102865: LD_INT 32
102867: PUSH
102868: LD_INT 33
102870: PUSH
102871: LD_INT 34
102873: PUSH
102874: LD_INT 35
102876: PUSH
102877: LD_INT 36
102879: PUSH
102880: EMPTY
102881: LIST
102882: LIST
102883: LIST
102884: LIST
102885: LIST
102886: LIST
102887: LIST
102888: LIST
102889: LIST
102890: LIST
102891: LIST
102892: LIST
102893: LIST
102894: LIST
102895: LIST
102896: LIST
102897: LIST
102898: LIST
102899: LIST
102900: LIST
102901: LIST
102902: LIST
102903: LIST
102904: LIST
102905: LIST
102906: LIST
102907: LIST
102908: LIST
102909: LIST
102910: LIST
102911: LIST
102912: LIST
102913: LIST
102914: LIST
102915: LIST
102916: LIST
102917: PUSH
102918: LD_INT 101
102920: PUSH
102921: LD_INT 102
102923: PUSH
102924: LD_INT 103
102926: PUSH
102927: LD_INT 104
102929: PUSH
102930: LD_INT 105
102932: PUSH
102933: LD_INT 106
102935: PUSH
102936: LD_INT 107
102938: PUSH
102939: LD_INT 108
102941: PUSH
102942: LD_INT 109
102944: PUSH
102945: LD_INT 110
102947: PUSH
102948: LD_INT 111
102950: PUSH
102951: LD_INT 112
102953: PUSH
102954: LD_INT 113
102956: PUSH
102957: LD_INT 114
102959: PUSH
102960: LD_INT 115
102962: PUSH
102963: LD_INT 116
102965: PUSH
102966: LD_INT 117
102968: PUSH
102969: LD_INT 118
102971: PUSH
102972: EMPTY
102973: LIST
102974: LIST
102975: LIST
102976: LIST
102977: LIST
102978: LIST
102979: LIST
102980: LIST
102981: LIST
102982: LIST
102983: LIST
102984: LIST
102985: LIST
102986: LIST
102987: LIST
102988: LIST
102989: LIST
102990: LIST
102991: PUSH
102992: EMPTY
102993: LIST
102994: LIST
102995: ST_TO_ADDR
102996: GO 102999
102998: POP
// end else
102999: GO 103230
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
103001: LD_ADDR_VAR 0 2
103005: PUSH
103006: LD_INT 1
103008: PUSH
103009: LD_INT 2
103011: PUSH
103012: LD_INT 3
103014: PUSH
103015: LD_INT 4
103017: PUSH
103018: LD_INT 5
103020: PUSH
103021: LD_INT 6
103023: PUSH
103024: LD_INT 7
103026: PUSH
103027: LD_INT 8
103029: PUSH
103030: LD_INT 9
103032: PUSH
103033: LD_INT 10
103035: PUSH
103036: LD_INT 11
103038: PUSH
103039: LD_INT 12
103041: PUSH
103042: LD_INT 13
103044: PUSH
103045: LD_INT 14
103047: PUSH
103048: LD_INT 15
103050: PUSH
103051: LD_INT 16
103053: PUSH
103054: LD_INT 17
103056: PUSH
103057: LD_INT 18
103059: PUSH
103060: LD_INT 19
103062: PUSH
103063: LD_INT 20
103065: PUSH
103066: LD_INT 21
103068: PUSH
103069: LD_INT 22
103071: PUSH
103072: LD_INT 23
103074: PUSH
103075: LD_INT 24
103077: PUSH
103078: LD_INT 25
103080: PUSH
103081: LD_INT 26
103083: PUSH
103084: LD_INT 27
103086: PUSH
103087: LD_INT 28
103089: PUSH
103090: LD_INT 29
103092: PUSH
103093: LD_INT 30
103095: PUSH
103096: LD_INT 31
103098: PUSH
103099: LD_INT 32
103101: PUSH
103102: LD_INT 33
103104: PUSH
103105: LD_INT 34
103107: PUSH
103108: LD_INT 35
103110: PUSH
103111: LD_INT 36
103113: PUSH
103114: EMPTY
103115: LIST
103116: LIST
103117: LIST
103118: LIST
103119: LIST
103120: LIST
103121: LIST
103122: LIST
103123: LIST
103124: LIST
103125: LIST
103126: LIST
103127: LIST
103128: LIST
103129: LIST
103130: LIST
103131: LIST
103132: LIST
103133: LIST
103134: LIST
103135: LIST
103136: LIST
103137: LIST
103138: LIST
103139: LIST
103140: LIST
103141: LIST
103142: LIST
103143: LIST
103144: LIST
103145: LIST
103146: LIST
103147: LIST
103148: LIST
103149: LIST
103150: LIST
103151: PUSH
103152: LD_INT 101
103154: PUSH
103155: LD_INT 102
103157: PUSH
103158: LD_INT 103
103160: PUSH
103161: LD_INT 104
103163: PUSH
103164: LD_INT 105
103166: PUSH
103167: LD_INT 106
103169: PUSH
103170: LD_INT 107
103172: PUSH
103173: LD_INT 108
103175: PUSH
103176: LD_INT 109
103178: PUSH
103179: LD_INT 110
103181: PUSH
103182: LD_INT 111
103184: PUSH
103185: LD_INT 112
103187: PUSH
103188: LD_INT 113
103190: PUSH
103191: LD_INT 114
103193: PUSH
103194: LD_INT 115
103196: PUSH
103197: LD_INT 116
103199: PUSH
103200: LD_INT 117
103202: PUSH
103203: LD_INT 118
103205: PUSH
103206: EMPTY
103207: LIST
103208: LIST
103209: LIST
103210: LIST
103211: LIST
103212: LIST
103213: LIST
103214: LIST
103215: LIST
103216: LIST
103217: LIST
103218: LIST
103219: LIST
103220: LIST
103221: LIST
103222: LIST
103223: LIST
103224: LIST
103225: PUSH
103226: EMPTY
103227: LIST
103228: LIST
103229: ST_TO_ADDR
// if result then
103230: LD_VAR 0 2
103234: IFFALSE 104020
// begin normal :=  ;
103236: LD_ADDR_VAR 0 5
103240: PUSH
103241: LD_STRING 
103243: ST_TO_ADDR
// hardcore :=  ;
103244: LD_ADDR_VAR 0 6
103248: PUSH
103249: LD_STRING 
103251: ST_TO_ADDR
// active :=  ;
103252: LD_ADDR_VAR 0 7
103256: PUSH
103257: LD_STRING 
103259: ST_TO_ADDR
// for i = 1 to normalCounter do
103260: LD_ADDR_VAR 0 8
103264: PUSH
103265: DOUBLE
103266: LD_INT 1
103268: DEC
103269: ST_TO_ADDR
103270: LD_EXP 127
103274: PUSH
103275: FOR_TO
103276: IFFALSE 103377
// begin tmp := 0 ;
103278: LD_ADDR_VAR 0 3
103282: PUSH
103283: LD_STRING 0
103285: ST_TO_ADDR
// if result [ 1 ] then
103286: LD_VAR 0 2
103290: PUSH
103291: LD_INT 1
103293: ARRAY
103294: IFFALSE 103359
// if result [ 1 ] [ 1 ] = i then
103296: LD_VAR 0 2
103300: PUSH
103301: LD_INT 1
103303: ARRAY
103304: PUSH
103305: LD_INT 1
103307: ARRAY
103308: PUSH
103309: LD_VAR 0 8
103313: EQUAL
103314: IFFALSE 103359
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
103316: LD_ADDR_VAR 0 2
103320: PUSH
103321: LD_VAR 0 2
103325: PPUSH
103326: LD_INT 1
103328: PPUSH
103329: LD_VAR 0 2
103333: PUSH
103334: LD_INT 1
103336: ARRAY
103337: PPUSH
103338: LD_INT 1
103340: PPUSH
103341: CALL_OW 3
103345: PPUSH
103346: CALL_OW 1
103350: ST_TO_ADDR
// tmp := 1 ;
103351: LD_ADDR_VAR 0 3
103355: PUSH
103356: LD_STRING 1
103358: ST_TO_ADDR
// end ; normal := normal & tmp ;
103359: LD_ADDR_VAR 0 5
103363: PUSH
103364: LD_VAR 0 5
103368: PUSH
103369: LD_VAR 0 3
103373: STR
103374: ST_TO_ADDR
// end ;
103375: GO 103275
103377: POP
103378: POP
// for i = 1 to hardcoreCounter do
103379: LD_ADDR_VAR 0 8
103383: PUSH
103384: DOUBLE
103385: LD_INT 1
103387: DEC
103388: ST_TO_ADDR
103389: LD_EXP 128
103393: PUSH
103394: FOR_TO
103395: IFFALSE 103500
// begin tmp := 0 ;
103397: LD_ADDR_VAR 0 3
103401: PUSH
103402: LD_STRING 0
103404: ST_TO_ADDR
// if result [ 2 ] then
103405: LD_VAR 0 2
103409: PUSH
103410: LD_INT 2
103412: ARRAY
103413: IFFALSE 103482
// if result [ 2 ] [ 1 ] = 100 + i then
103415: LD_VAR 0 2
103419: PUSH
103420: LD_INT 2
103422: ARRAY
103423: PUSH
103424: LD_INT 1
103426: ARRAY
103427: PUSH
103428: LD_INT 100
103430: PUSH
103431: LD_VAR 0 8
103435: PLUS
103436: EQUAL
103437: IFFALSE 103482
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
103439: LD_ADDR_VAR 0 2
103443: PUSH
103444: LD_VAR 0 2
103448: PPUSH
103449: LD_INT 2
103451: PPUSH
103452: LD_VAR 0 2
103456: PUSH
103457: LD_INT 2
103459: ARRAY
103460: PPUSH
103461: LD_INT 1
103463: PPUSH
103464: CALL_OW 3
103468: PPUSH
103469: CALL_OW 1
103473: ST_TO_ADDR
// tmp := 1 ;
103474: LD_ADDR_VAR 0 3
103478: PUSH
103479: LD_STRING 1
103481: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
103482: LD_ADDR_VAR 0 6
103486: PUSH
103487: LD_VAR 0 6
103491: PUSH
103492: LD_VAR 0 3
103496: STR
103497: ST_TO_ADDR
// end ;
103498: GO 103394
103500: POP
103501: POP
// if isGameLoad then
103502: LD_VAR 0 1
103506: IFFALSE 103981
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
103508: LD_ADDR_VAR 0 4
103512: PUSH
103513: LD_EXP 131
103517: PUSH
103518: LD_EXP 130
103522: PUSH
103523: LD_EXP 132
103527: PUSH
103528: LD_EXP 129
103532: PUSH
103533: LD_EXP 133
103537: PUSH
103538: LD_EXP 134
103542: PUSH
103543: LD_EXP 135
103547: PUSH
103548: LD_EXP 136
103552: PUSH
103553: LD_EXP 137
103557: PUSH
103558: LD_EXP 138
103562: PUSH
103563: LD_EXP 139
103567: PUSH
103568: LD_EXP 140
103572: PUSH
103573: LD_EXP 141
103577: PUSH
103578: LD_EXP 142
103582: PUSH
103583: LD_EXP 150
103587: PUSH
103588: LD_EXP 151
103592: PUSH
103593: LD_EXP 152
103597: PUSH
103598: LD_EXP 153
103602: PUSH
103603: LD_EXP 155
103607: PUSH
103608: LD_EXP 156
103612: PUSH
103613: LD_EXP 157
103617: PUSH
103618: LD_EXP 160
103622: PUSH
103623: LD_EXP 162
103627: PUSH
103628: LD_EXP 163
103632: PUSH
103633: LD_EXP 164
103637: PUSH
103638: LD_EXP 166
103642: PUSH
103643: LD_EXP 167
103647: PUSH
103648: LD_EXP 170
103652: PUSH
103653: LD_EXP 171
103657: PUSH
103658: LD_EXP 172
103662: PUSH
103663: LD_EXP 173
103667: PUSH
103668: LD_EXP 174
103672: PUSH
103673: LD_EXP 175
103677: PUSH
103678: LD_EXP 176
103682: PUSH
103683: LD_EXP 177
103687: PUSH
103688: LD_EXP 178
103692: PUSH
103693: LD_EXP 143
103697: PUSH
103698: LD_EXP 144
103702: PUSH
103703: LD_EXP 147
103707: PUSH
103708: LD_EXP 148
103712: PUSH
103713: LD_EXP 149
103717: PUSH
103718: LD_EXP 145
103722: PUSH
103723: LD_EXP 146
103727: PUSH
103728: LD_EXP 154
103732: PUSH
103733: LD_EXP 158
103737: PUSH
103738: LD_EXP 159
103742: PUSH
103743: LD_EXP 161
103747: PUSH
103748: LD_EXP 165
103752: PUSH
103753: LD_EXP 168
103757: PUSH
103758: LD_EXP 169
103762: PUSH
103763: LD_EXP 179
103767: PUSH
103768: LD_EXP 180
103772: PUSH
103773: LD_EXP 181
103777: PUSH
103778: LD_EXP 182
103782: PUSH
103783: EMPTY
103784: LIST
103785: LIST
103786: LIST
103787: LIST
103788: LIST
103789: LIST
103790: LIST
103791: LIST
103792: LIST
103793: LIST
103794: LIST
103795: LIST
103796: LIST
103797: LIST
103798: LIST
103799: LIST
103800: LIST
103801: LIST
103802: LIST
103803: LIST
103804: LIST
103805: LIST
103806: LIST
103807: LIST
103808: LIST
103809: LIST
103810: LIST
103811: LIST
103812: LIST
103813: LIST
103814: LIST
103815: LIST
103816: LIST
103817: LIST
103818: LIST
103819: LIST
103820: LIST
103821: LIST
103822: LIST
103823: LIST
103824: LIST
103825: LIST
103826: LIST
103827: LIST
103828: LIST
103829: LIST
103830: LIST
103831: LIST
103832: LIST
103833: LIST
103834: LIST
103835: LIST
103836: LIST
103837: LIST
103838: ST_TO_ADDR
// tmp :=  ;
103839: LD_ADDR_VAR 0 3
103843: PUSH
103844: LD_STRING 
103846: ST_TO_ADDR
// for i = 1 to normalCounter do
103847: LD_ADDR_VAR 0 8
103851: PUSH
103852: DOUBLE
103853: LD_INT 1
103855: DEC
103856: ST_TO_ADDR
103857: LD_EXP 127
103861: PUSH
103862: FOR_TO
103863: IFFALSE 103899
// begin if flags [ i ] then
103865: LD_VAR 0 4
103869: PUSH
103870: LD_VAR 0 8
103874: ARRAY
103875: IFFALSE 103897
// tmp := tmp & i & ; ;
103877: LD_ADDR_VAR 0 3
103881: PUSH
103882: LD_VAR 0 3
103886: PUSH
103887: LD_VAR 0 8
103891: STR
103892: PUSH
103893: LD_STRING ;
103895: STR
103896: ST_TO_ADDR
// end ;
103897: GO 103862
103899: POP
103900: POP
// for i = 1 to hardcoreCounter do
103901: LD_ADDR_VAR 0 8
103905: PUSH
103906: DOUBLE
103907: LD_INT 1
103909: DEC
103910: ST_TO_ADDR
103911: LD_EXP 128
103915: PUSH
103916: FOR_TO
103917: IFFALSE 103963
// begin if flags [ normalCounter + i ] then
103919: LD_VAR 0 4
103923: PUSH
103924: LD_EXP 127
103928: PUSH
103929: LD_VAR 0 8
103933: PLUS
103934: ARRAY
103935: IFFALSE 103961
// tmp := tmp & ( 100 + i ) & ; ;
103937: LD_ADDR_VAR 0 3
103941: PUSH
103942: LD_VAR 0 3
103946: PUSH
103947: LD_INT 100
103949: PUSH
103950: LD_VAR 0 8
103954: PLUS
103955: STR
103956: PUSH
103957: LD_STRING ;
103959: STR
103960: ST_TO_ADDR
// end ;
103961: GO 103916
103963: POP
103964: POP
// if tmp then
103965: LD_VAR 0 3
103969: IFFALSE 103981
// active := tmp ;
103971: LD_ADDR_VAR 0 7
103975: PUSH
103976: LD_VAR 0 3
103980: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
103981: LD_STRING getStreamItemsFromMission("
103983: PUSH
103984: LD_VAR 0 5
103988: STR
103989: PUSH
103990: LD_STRING ","
103992: STR
103993: PUSH
103994: LD_VAR 0 6
103998: STR
103999: PUSH
104000: LD_STRING ","
104002: STR
104003: PUSH
104004: LD_VAR 0 7
104008: STR
104009: PUSH
104010: LD_STRING ")
104012: STR
104013: PPUSH
104014: CALL_OW 559
// end else
104018: GO 104027
// ToLua ( getStreamItemsFromMission("","","") ) ;
104020: LD_STRING getStreamItemsFromMission("","","")
104022: PPUSH
104023: CALL_OW 559
// end ;
104027: LD_VAR 0 2
104031: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
104032: LD_EXP 126
104036: IFFALSE 104044
104038: PUSH
104039: LD_EXP 131
104043: AND
104044: IFFALSE 104168
104046: GO 104048
104048: DISABLE
104049: LD_INT 0
104051: PPUSH
104052: PPUSH
// begin enable ;
104053: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
104054: LD_ADDR_VAR 0 2
104058: PUSH
104059: LD_INT 22
104061: PUSH
104062: LD_OWVAR 2
104066: PUSH
104067: EMPTY
104068: LIST
104069: LIST
104070: PUSH
104071: LD_INT 2
104073: PUSH
104074: LD_INT 34
104076: PUSH
104077: LD_INT 7
104079: PUSH
104080: EMPTY
104081: LIST
104082: LIST
104083: PUSH
104084: LD_INT 34
104086: PUSH
104087: LD_INT 45
104089: PUSH
104090: EMPTY
104091: LIST
104092: LIST
104093: PUSH
104094: LD_INT 34
104096: PUSH
104097: LD_INT 28
104099: PUSH
104100: EMPTY
104101: LIST
104102: LIST
104103: PUSH
104104: LD_INT 34
104106: PUSH
104107: LD_INT 47
104109: PUSH
104110: EMPTY
104111: LIST
104112: LIST
104113: PUSH
104114: EMPTY
104115: LIST
104116: LIST
104117: LIST
104118: LIST
104119: LIST
104120: PUSH
104121: EMPTY
104122: LIST
104123: LIST
104124: PPUSH
104125: CALL_OW 69
104129: ST_TO_ADDR
// if not tmp then
104130: LD_VAR 0 2
104134: NOT
104135: IFFALSE 104139
// exit ;
104137: GO 104168
// for i in tmp do
104139: LD_ADDR_VAR 0 1
104143: PUSH
104144: LD_VAR 0 2
104148: PUSH
104149: FOR_IN
104150: IFFALSE 104166
// begin SetLives ( i , 0 ) ;
104152: LD_VAR 0 1
104156: PPUSH
104157: LD_INT 0
104159: PPUSH
104160: CALL_OW 234
// end ;
104164: GO 104149
104166: POP
104167: POP
// end ;
104168: PPOPN 2
104170: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
104171: LD_EXP 126
104175: IFFALSE 104183
104177: PUSH
104178: LD_EXP 132
104182: AND
104183: IFFALSE 104267
104185: GO 104187
104187: DISABLE
104188: LD_INT 0
104190: PPUSH
104191: PPUSH
// begin enable ;
104192: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
104193: LD_ADDR_VAR 0 2
104197: PUSH
104198: LD_INT 22
104200: PUSH
104201: LD_OWVAR 2
104205: PUSH
104206: EMPTY
104207: LIST
104208: LIST
104209: PUSH
104210: LD_INT 32
104212: PUSH
104213: LD_INT 3
104215: PUSH
104216: EMPTY
104217: LIST
104218: LIST
104219: PUSH
104220: EMPTY
104221: LIST
104222: LIST
104223: PPUSH
104224: CALL_OW 69
104228: ST_TO_ADDR
// if not tmp then
104229: LD_VAR 0 2
104233: NOT
104234: IFFALSE 104238
// exit ;
104236: GO 104267
// for i in tmp do
104238: LD_ADDR_VAR 0 1
104242: PUSH
104243: LD_VAR 0 2
104247: PUSH
104248: FOR_IN
104249: IFFALSE 104265
// begin SetLives ( i , 0 ) ;
104251: LD_VAR 0 1
104255: PPUSH
104256: LD_INT 0
104258: PPUSH
104259: CALL_OW 234
// end ;
104263: GO 104248
104265: POP
104266: POP
// end ;
104267: PPOPN 2
104269: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
104270: LD_EXP 126
104274: IFFALSE 104282
104276: PUSH
104277: LD_EXP 129
104281: AND
104282: IFFALSE 104375
104284: GO 104286
104286: DISABLE
104287: LD_INT 0
104289: PPUSH
// begin enable ;
104290: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
104291: LD_ADDR_VAR 0 1
104295: PUSH
104296: LD_INT 22
104298: PUSH
104299: LD_OWVAR 2
104303: PUSH
104304: EMPTY
104305: LIST
104306: LIST
104307: PUSH
104308: LD_INT 2
104310: PUSH
104311: LD_INT 25
104313: PUSH
104314: LD_INT 5
104316: PUSH
104317: EMPTY
104318: LIST
104319: LIST
104320: PUSH
104321: LD_INT 25
104323: PUSH
104324: LD_INT 9
104326: PUSH
104327: EMPTY
104328: LIST
104329: LIST
104330: PUSH
104331: LD_INT 25
104333: PUSH
104334: LD_INT 8
104336: PUSH
104337: EMPTY
104338: LIST
104339: LIST
104340: PUSH
104341: EMPTY
104342: LIST
104343: LIST
104344: LIST
104345: LIST
104346: PUSH
104347: EMPTY
104348: LIST
104349: LIST
104350: PPUSH
104351: CALL_OW 69
104355: PUSH
104356: FOR_IN
104357: IFFALSE 104373
// begin SetClass ( i , 1 ) ;
104359: LD_VAR 0 1
104363: PPUSH
104364: LD_INT 1
104366: PPUSH
104367: CALL_OW 336
// end ;
104371: GO 104356
104373: POP
104374: POP
// end ;
104375: PPOPN 1
104377: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
104378: LD_EXP 126
104382: IFFALSE 104390
104384: PUSH
104385: LD_EXP 130
104389: AND
104390: IFFALSE 104402
104392: PUSH
104393: LD_OWVAR 65
104397: PUSH
104398: LD_INT 7
104400: LESS
104401: AND
104402: IFFALSE 104416
104404: GO 104406
104406: DISABLE
// begin enable ;
104407: ENABLE
// game_speed := 7 ;
104408: LD_ADDR_OWVAR 65
104412: PUSH
104413: LD_INT 7
104415: ST_TO_ADDR
// end ;
104416: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
104417: LD_EXP 126
104421: IFFALSE 104429
104423: PUSH
104424: LD_EXP 133
104428: AND
104429: IFFALSE 104631
104431: GO 104433
104433: DISABLE
104434: LD_INT 0
104436: PPUSH
104437: PPUSH
104438: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104439: LD_ADDR_VAR 0 3
104443: PUSH
104444: LD_INT 81
104446: PUSH
104447: LD_OWVAR 2
104451: PUSH
104452: EMPTY
104453: LIST
104454: LIST
104455: PUSH
104456: LD_INT 21
104458: PUSH
104459: LD_INT 1
104461: PUSH
104462: EMPTY
104463: LIST
104464: LIST
104465: PUSH
104466: EMPTY
104467: LIST
104468: LIST
104469: PPUSH
104470: CALL_OW 69
104474: ST_TO_ADDR
// if not tmp then
104475: LD_VAR 0 3
104479: NOT
104480: IFFALSE 104484
// exit ;
104482: GO 104631
// if tmp > 5 then
104484: LD_VAR 0 3
104488: PUSH
104489: LD_INT 5
104491: GREATER
104492: IFFALSE 104504
// k := 5 else
104494: LD_ADDR_VAR 0 2
104498: PUSH
104499: LD_INT 5
104501: ST_TO_ADDR
104502: GO 104514
// k := tmp ;
104504: LD_ADDR_VAR 0 2
104508: PUSH
104509: LD_VAR 0 3
104513: ST_TO_ADDR
// for i := 1 to k do
104514: LD_ADDR_VAR 0 1
104518: PUSH
104519: DOUBLE
104520: LD_INT 1
104522: DEC
104523: ST_TO_ADDR
104524: LD_VAR 0 2
104528: PUSH
104529: FOR_TO
104530: IFFALSE 104629
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
104532: LD_VAR 0 3
104536: PUSH
104537: LD_VAR 0 1
104541: ARRAY
104542: PPUSH
104543: LD_VAR 0 1
104547: PUSH
104548: LD_INT 4
104550: MOD
104551: PUSH
104552: LD_INT 1
104554: PLUS
104555: PPUSH
104556: CALL_OW 259
104560: PUSH
104561: LD_INT 10
104563: LESS
104564: IFFALSE 104627
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
104566: LD_VAR 0 3
104570: PUSH
104571: LD_VAR 0 1
104575: ARRAY
104576: PPUSH
104577: LD_VAR 0 1
104581: PUSH
104582: LD_INT 4
104584: MOD
104585: PUSH
104586: LD_INT 1
104588: PLUS
104589: PPUSH
104590: LD_VAR 0 3
104594: PUSH
104595: LD_VAR 0 1
104599: ARRAY
104600: PPUSH
104601: LD_VAR 0 1
104605: PUSH
104606: LD_INT 4
104608: MOD
104609: PUSH
104610: LD_INT 1
104612: PLUS
104613: PPUSH
104614: CALL_OW 259
104618: PUSH
104619: LD_INT 1
104621: PLUS
104622: PPUSH
104623: CALL_OW 237
104627: GO 104529
104629: POP
104630: POP
// end ;
104631: PPOPN 3
104633: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
104634: LD_EXP 126
104638: IFFALSE 104646
104640: PUSH
104641: LD_EXP 134
104645: AND
104646: IFFALSE 104666
104648: GO 104650
104650: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
104651: LD_INT 4
104653: PPUSH
104654: LD_OWVAR 2
104658: PPUSH
104659: LD_INT 0
104661: PPUSH
104662: CALL_OW 324
104666: END
// every 0 0$1 trigger StreamModeActive and sShovel do
104667: LD_EXP 126
104671: IFFALSE 104679
104673: PUSH
104674: LD_EXP 163
104678: AND
104679: IFFALSE 104699
104681: GO 104683
104683: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
104684: LD_INT 19
104686: PPUSH
104687: LD_OWVAR 2
104691: PPUSH
104692: LD_INT 0
104694: PPUSH
104695: CALL_OW 324
104699: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
104700: LD_EXP 126
104704: IFFALSE 104712
104706: PUSH
104707: LD_EXP 135
104711: AND
104712: IFFALSE 104814
104714: GO 104716
104716: DISABLE
104717: LD_INT 0
104719: PPUSH
104720: PPUSH
// begin enable ;
104721: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
104722: LD_ADDR_VAR 0 2
104726: PUSH
104727: LD_INT 22
104729: PUSH
104730: LD_OWVAR 2
104734: PUSH
104735: EMPTY
104736: LIST
104737: LIST
104738: PUSH
104739: LD_INT 2
104741: PUSH
104742: LD_INT 34
104744: PUSH
104745: LD_INT 11
104747: PUSH
104748: EMPTY
104749: LIST
104750: LIST
104751: PUSH
104752: LD_INT 34
104754: PUSH
104755: LD_INT 30
104757: PUSH
104758: EMPTY
104759: LIST
104760: LIST
104761: PUSH
104762: EMPTY
104763: LIST
104764: LIST
104765: LIST
104766: PUSH
104767: EMPTY
104768: LIST
104769: LIST
104770: PPUSH
104771: CALL_OW 69
104775: ST_TO_ADDR
// if not tmp then
104776: LD_VAR 0 2
104780: NOT
104781: IFFALSE 104785
// exit ;
104783: GO 104814
// for i in tmp do
104785: LD_ADDR_VAR 0 1
104789: PUSH
104790: LD_VAR 0 2
104794: PUSH
104795: FOR_IN
104796: IFFALSE 104812
// begin SetLives ( i , 0 ) ;
104798: LD_VAR 0 1
104802: PPUSH
104803: LD_INT 0
104805: PPUSH
104806: CALL_OW 234
// end ;
104810: GO 104795
104812: POP
104813: POP
// end ;
104814: PPOPN 2
104816: END
// every 0 0$1 trigger StreamModeActive and sBunker do
104817: LD_EXP 126
104821: IFFALSE 104829
104823: PUSH
104824: LD_EXP 136
104828: AND
104829: IFFALSE 104849
104831: GO 104833
104833: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
104834: LD_INT 32
104836: PPUSH
104837: LD_OWVAR 2
104841: PPUSH
104842: LD_INT 0
104844: PPUSH
104845: CALL_OW 324
104849: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
104850: LD_EXP 126
104854: IFFALSE 104862
104856: PUSH
104857: LD_EXP 137
104861: AND
104862: IFFALSE 105045
104864: GO 104866
104866: DISABLE
104867: LD_INT 0
104869: PPUSH
104870: PPUSH
104871: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
104872: LD_ADDR_VAR 0 2
104876: PUSH
104877: LD_INT 22
104879: PUSH
104880: LD_OWVAR 2
104884: PUSH
104885: EMPTY
104886: LIST
104887: LIST
104888: PUSH
104889: LD_INT 33
104891: PUSH
104892: LD_INT 3
104894: PUSH
104895: EMPTY
104896: LIST
104897: LIST
104898: PUSH
104899: EMPTY
104900: LIST
104901: LIST
104902: PPUSH
104903: CALL_OW 69
104907: ST_TO_ADDR
// if not tmp then
104908: LD_VAR 0 2
104912: NOT
104913: IFFALSE 104917
// exit ;
104915: GO 105045
// side := 0 ;
104917: LD_ADDR_VAR 0 3
104921: PUSH
104922: LD_INT 0
104924: ST_TO_ADDR
// for i := 1 to 8 do
104925: LD_ADDR_VAR 0 1
104929: PUSH
104930: DOUBLE
104931: LD_INT 1
104933: DEC
104934: ST_TO_ADDR
104935: LD_INT 8
104937: PUSH
104938: FOR_TO
104939: IFFALSE 104989
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
104941: LD_OWVAR 2
104945: PUSH
104946: LD_VAR 0 1
104950: NONEQUAL
104951: IFFALSE 104973
104953: PUSH
104954: LD_OWVAR 2
104958: PPUSH
104959: LD_VAR 0 1
104963: PPUSH
104964: CALL_OW 81
104968: PUSH
104969: LD_INT 2
104971: EQUAL
104972: AND
104973: IFFALSE 104987
// begin side := i ;
104975: LD_ADDR_VAR 0 3
104979: PUSH
104980: LD_VAR 0 1
104984: ST_TO_ADDR
// break ;
104985: GO 104989
// end ;
104987: GO 104938
104989: POP
104990: POP
// if not side then
104991: LD_VAR 0 3
104995: NOT
104996: IFFALSE 105000
// exit ;
104998: GO 105045
// for i := 1 to tmp do
105000: LD_ADDR_VAR 0 1
105004: PUSH
105005: DOUBLE
105006: LD_INT 1
105008: DEC
105009: ST_TO_ADDR
105010: LD_VAR 0 2
105014: PUSH
105015: FOR_TO
105016: IFFALSE 105043
// if Prob ( 60 ) then
105018: LD_INT 60
105020: PPUSH
105021: CALL_OW 13
105025: IFFALSE 105041
// SetSide ( i , side ) ;
105027: LD_VAR 0 1
105031: PPUSH
105032: LD_VAR 0 3
105036: PPUSH
105037: CALL_OW 235
105041: GO 105015
105043: POP
105044: POP
// end ;
105045: PPOPN 3
105047: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
105048: LD_EXP 126
105052: IFFALSE 105060
105054: PUSH
105055: LD_EXP 139
105059: AND
105060: IFFALSE 105179
105062: GO 105064
105064: DISABLE
105065: LD_INT 0
105067: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
105068: LD_ADDR_VAR 0 1
105072: PUSH
105073: LD_INT 22
105075: PUSH
105076: LD_OWVAR 2
105080: PUSH
105081: EMPTY
105082: LIST
105083: LIST
105084: PUSH
105085: LD_INT 21
105087: PUSH
105088: LD_INT 1
105090: PUSH
105091: EMPTY
105092: LIST
105093: LIST
105094: PUSH
105095: LD_INT 3
105097: PUSH
105098: LD_INT 23
105100: PUSH
105101: LD_INT 0
105103: PUSH
105104: EMPTY
105105: LIST
105106: LIST
105107: PUSH
105108: EMPTY
105109: LIST
105110: LIST
105111: PUSH
105112: EMPTY
105113: LIST
105114: LIST
105115: LIST
105116: PPUSH
105117: CALL_OW 69
105121: PUSH
105122: FOR_IN
105123: IFFALSE 105177
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
105125: LD_VAR 0 1
105129: PPUSH
105130: CALL_OW 257
105134: PUSH
105135: LD_INT 1
105137: PUSH
105138: LD_INT 2
105140: PUSH
105141: LD_INT 3
105143: PUSH
105144: LD_INT 4
105146: PUSH
105147: EMPTY
105148: LIST
105149: LIST
105150: LIST
105151: LIST
105152: IN
105153: IFFALSE 105175
// SetClass ( un , rand ( 1 , 4 ) ) ;
105155: LD_VAR 0 1
105159: PPUSH
105160: LD_INT 1
105162: PPUSH
105163: LD_INT 4
105165: PPUSH
105166: CALL_OW 12
105170: PPUSH
105171: CALL_OW 336
105175: GO 105122
105177: POP
105178: POP
// end ;
105179: PPOPN 1
105181: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
105182: LD_EXP 126
105186: IFFALSE 105194
105188: PUSH
105189: LD_EXP 138
105193: AND
105194: IFFALSE 105273
105196: GO 105198
105198: DISABLE
105199: LD_INT 0
105201: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
105202: LD_ADDR_VAR 0 1
105206: PUSH
105207: LD_INT 22
105209: PUSH
105210: LD_OWVAR 2
105214: PUSH
105215: EMPTY
105216: LIST
105217: LIST
105218: PUSH
105219: LD_INT 21
105221: PUSH
105222: LD_INT 3
105224: PUSH
105225: EMPTY
105226: LIST
105227: LIST
105228: PUSH
105229: EMPTY
105230: LIST
105231: LIST
105232: PPUSH
105233: CALL_OW 69
105237: ST_TO_ADDR
// if not tmp then
105238: LD_VAR 0 1
105242: NOT
105243: IFFALSE 105247
// exit ;
105245: GO 105273
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
105247: LD_VAR 0 1
105251: PUSH
105252: LD_INT 1
105254: PPUSH
105255: LD_VAR 0 1
105259: PPUSH
105260: CALL_OW 12
105264: ARRAY
105265: PPUSH
105266: LD_INT 100
105268: PPUSH
105269: CALL_OW 234
// end ;
105273: PPOPN 1
105275: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
105276: LD_EXP 126
105280: IFFALSE 105288
105282: PUSH
105283: LD_EXP 140
105287: AND
105288: IFFALSE 105386
105290: GO 105292
105292: DISABLE
105293: LD_INT 0
105295: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105296: LD_ADDR_VAR 0 1
105300: PUSH
105301: LD_INT 22
105303: PUSH
105304: LD_OWVAR 2
105308: PUSH
105309: EMPTY
105310: LIST
105311: LIST
105312: PUSH
105313: LD_INT 21
105315: PUSH
105316: LD_INT 1
105318: PUSH
105319: EMPTY
105320: LIST
105321: LIST
105322: PUSH
105323: EMPTY
105324: LIST
105325: LIST
105326: PPUSH
105327: CALL_OW 69
105331: ST_TO_ADDR
// if not tmp then
105332: LD_VAR 0 1
105336: NOT
105337: IFFALSE 105341
// exit ;
105339: GO 105386
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
105341: LD_VAR 0 1
105345: PUSH
105346: LD_INT 1
105348: PPUSH
105349: LD_VAR 0 1
105353: PPUSH
105354: CALL_OW 12
105358: ARRAY
105359: PPUSH
105360: LD_INT 1
105362: PPUSH
105363: LD_INT 4
105365: PPUSH
105366: CALL_OW 12
105370: PPUSH
105371: LD_INT 3000
105373: PPUSH
105374: LD_INT 9000
105376: PPUSH
105377: CALL_OW 12
105381: PPUSH
105382: CALL_OW 492
// end ;
105386: PPOPN 1
105388: END
// every 0 0$1 trigger StreamModeActive and sDepot do
105389: LD_EXP 126
105393: IFFALSE 105401
105395: PUSH
105396: LD_EXP 141
105400: AND
105401: IFFALSE 105421
105403: GO 105405
105405: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
105406: LD_INT 1
105408: PPUSH
105409: LD_OWVAR 2
105413: PPUSH
105414: LD_INT 0
105416: PPUSH
105417: CALL_OW 324
105421: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
105422: LD_EXP 126
105426: IFFALSE 105434
105428: PUSH
105429: LD_EXP 142
105433: AND
105434: IFFALSE 105517
105436: GO 105438
105438: DISABLE
105439: LD_INT 0
105441: PPUSH
105442: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
105443: LD_ADDR_VAR 0 2
105447: PUSH
105448: LD_INT 22
105450: PUSH
105451: LD_OWVAR 2
105455: PUSH
105456: EMPTY
105457: LIST
105458: LIST
105459: PUSH
105460: LD_INT 21
105462: PUSH
105463: LD_INT 3
105465: PUSH
105466: EMPTY
105467: LIST
105468: LIST
105469: PUSH
105470: EMPTY
105471: LIST
105472: LIST
105473: PPUSH
105474: CALL_OW 69
105478: ST_TO_ADDR
// if not tmp then
105479: LD_VAR 0 2
105483: NOT
105484: IFFALSE 105488
// exit ;
105486: GO 105517
// for i in tmp do
105488: LD_ADDR_VAR 0 1
105492: PUSH
105493: LD_VAR 0 2
105497: PUSH
105498: FOR_IN
105499: IFFALSE 105515
// SetBLevel ( i , 10 ) ;
105501: LD_VAR 0 1
105505: PPUSH
105506: LD_INT 10
105508: PPUSH
105509: CALL_OW 241
105513: GO 105498
105515: POP
105516: POP
// end ;
105517: PPOPN 2
105519: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
105520: LD_EXP 126
105524: IFFALSE 105532
105526: PUSH
105527: LD_EXP 143
105531: AND
105532: IFFALSE 105643
105534: GO 105536
105536: DISABLE
105537: LD_INT 0
105539: PPUSH
105540: PPUSH
105541: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105542: LD_ADDR_VAR 0 3
105546: PUSH
105547: LD_INT 22
105549: PUSH
105550: LD_OWVAR 2
105554: PUSH
105555: EMPTY
105556: LIST
105557: LIST
105558: PUSH
105559: LD_INT 25
105561: PUSH
105562: LD_INT 1
105564: PUSH
105565: EMPTY
105566: LIST
105567: LIST
105568: PUSH
105569: EMPTY
105570: LIST
105571: LIST
105572: PPUSH
105573: CALL_OW 69
105577: ST_TO_ADDR
// if not tmp then
105578: LD_VAR 0 3
105582: NOT
105583: IFFALSE 105587
// exit ;
105585: GO 105643
// un := tmp [ rand ( 1 , tmp ) ] ;
105587: LD_ADDR_VAR 0 2
105591: PUSH
105592: LD_VAR 0 3
105596: PUSH
105597: LD_INT 1
105599: PPUSH
105600: LD_VAR 0 3
105604: PPUSH
105605: CALL_OW 12
105609: ARRAY
105610: ST_TO_ADDR
// if Crawls ( un ) then
105611: LD_VAR 0 2
105615: PPUSH
105616: CALL_OW 318
105620: IFFALSE 105631
// ComWalk ( un ) ;
105622: LD_VAR 0 2
105626: PPUSH
105627: CALL_OW 138
// SetClass ( un , class_sniper ) ;
105631: LD_VAR 0 2
105635: PPUSH
105636: LD_INT 5
105638: PPUSH
105639: CALL_OW 336
// end ;
105643: PPOPN 3
105645: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
105646: LD_EXP 126
105650: IFFALSE 105658
105652: PUSH
105653: LD_EXP 144
105657: AND
105658: IFFALSE 105670
105660: PUSH
105661: LD_OWVAR 67
105665: PUSH
105666: LD_INT 4
105668: LESS
105669: AND
105670: IFFALSE 105689
105672: GO 105674
105674: DISABLE
// begin Difficulty := Difficulty + 1 ;
105675: LD_ADDR_OWVAR 67
105679: PUSH
105680: LD_OWVAR 67
105684: PUSH
105685: LD_INT 1
105687: PLUS
105688: ST_TO_ADDR
// end ;
105689: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
105690: LD_EXP 126
105694: IFFALSE 105702
105696: PUSH
105697: LD_EXP 145
105701: AND
105702: IFFALSE 105805
105704: GO 105706
105706: DISABLE
105707: LD_INT 0
105709: PPUSH
// begin for i := 1 to 5 do
105710: LD_ADDR_VAR 0 1
105714: PUSH
105715: DOUBLE
105716: LD_INT 1
105718: DEC
105719: ST_TO_ADDR
105720: LD_INT 5
105722: PUSH
105723: FOR_TO
105724: IFFALSE 105803
// begin uc_nation := nation_nature ;
105726: LD_ADDR_OWVAR 21
105730: PUSH
105731: LD_INT 0
105733: ST_TO_ADDR
// uc_side := 0 ;
105734: LD_ADDR_OWVAR 20
105738: PUSH
105739: LD_INT 0
105741: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
105742: LD_ADDR_OWVAR 29
105746: PUSH
105747: LD_INT 12
105749: PUSH
105750: LD_INT 12
105752: PUSH
105753: EMPTY
105754: LIST
105755: LIST
105756: ST_TO_ADDR
// hc_agressivity := 20 ;
105757: LD_ADDR_OWVAR 35
105761: PUSH
105762: LD_INT 20
105764: ST_TO_ADDR
// hc_class := class_tiger ;
105765: LD_ADDR_OWVAR 28
105769: PUSH
105770: LD_INT 14
105772: ST_TO_ADDR
// hc_gallery :=  ;
105773: LD_ADDR_OWVAR 33
105777: PUSH
105778: LD_STRING 
105780: ST_TO_ADDR
// hc_name :=  ;
105781: LD_ADDR_OWVAR 26
105785: PUSH
105786: LD_STRING 
105788: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
105789: CALL_OW 44
105793: PPUSH
105794: LD_INT 0
105796: PPUSH
105797: CALL_OW 51
// end ;
105801: GO 105723
105803: POP
105804: POP
// end ;
105805: PPOPN 1
105807: END
// every 0 0$1 trigger StreamModeActive and sBomb do
105808: LD_EXP 126
105812: IFFALSE 105820
105814: PUSH
105815: LD_EXP 146
105819: AND
105820: IFFALSE 105829
105822: GO 105824
105824: DISABLE
// StreamSibBomb ;
105825: CALL 105830 0 0
105829: END
// export function StreamSibBomb ; var i , x , y ; begin
105830: LD_INT 0
105832: PPUSH
105833: PPUSH
105834: PPUSH
105835: PPUSH
// result := false ;
105836: LD_ADDR_VAR 0 1
105840: PUSH
105841: LD_INT 0
105843: ST_TO_ADDR
// for i := 1 to 16 do
105844: LD_ADDR_VAR 0 2
105848: PUSH
105849: DOUBLE
105850: LD_INT 1
105852: DEC
105853: ST_TO_ADDR
105854: LD_INT 16
105856: PUSH
105857: FOR_TO
105858: IFFALSE 106057
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
105860: LD_ADDR_VAR 0 3
105864: PUSH
105865: LD_INT 10
105867: PUSH
105868: LD_INT 20
105870: PUSH
105871: LD_INT 30
105873: PUSH
105874: LD_INT 40
105876: PUSH
105877: LD_INT 50
105879: PUSH
105880: LD_INT 60
105882: PUSH
105883: LD_INT 70
105885: PUSH
105886: LD_INT 80
105888: PUSH
105889: LD_INT 90
105891: PUSH
105892: LD_INT 100
105894: PUSH
105895: LD_INT 110
105897: PUSH
105898: LD_INT 120
105900: PUSH
105901: LD_INT 130
105903: PUSH
105904: LD_INT 140
105906: PUSH
105907: LD_INT 150
105909: PUSH
105910: EMPTY
105911: LIST
105912: LIST
105913: LIST
105914: LIST
105915: LIST
105916: LIST
105917: LIST
105918: LIST
105919: LIST
105920: LIST
105921: LIST
105922: LIST
105923: LIST
105924: LIST
105925: LIST
105926: PUSH
105927: LD_INT 1
105929: PPUSH
105930: LD_INT 15
105932: PPUSH
105933: CALL_OW 12
105937: ARRAY
105938: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
105939: LD_ADDR_VAR 0 4
105943: PUSH
105944: LD_INT 10
105946: PUSH
105947: LD_INT 20
105949: PUSH
105950: LD_INT 30
105952: PUSH
105953: LD_INT 40
105955: PUSH
105956: LD_INT 50
105958: PUSH
105959: LD_INT 60
105961: PUSH
105962: LD_INT 70
105964: PUSH
105965: LD_INT 80
105967: PUSH
105968: LD_INT 90
105970: PUSH
105971: LD_INT 100
105973: PUSH
105974: LD_INT 110
105976: PUSH
105977: LD_INT 120
105979: PUSH
105980: LD_INT 130
105982: PUSH
105983: LD_INT 140
105985: PUSH
105986: LD_INT 150
105988: PUSH
105989: EMPTY
105990: LIST
105991: LIST
105992: LIST
105993: LIST
105994: LIST
105995: LIST
105996: LIST
105997: LIST
105998: LIST
105999: LIST
106000: LIST
106001: LIST
106002: LIST
106003: LIST
106004: LIST
106005: PUSH
106006: LD_INT 1
106008: PPUSH
106009: LD_INT 15
106011: PPUSH
106012: CALL_OW 12
106016: ARRAY
106017: ST_TO_ADDR
// if ValidHex ( x , y ) then
106018: LD_VAR 0 3
106022: PPUSH
106023: LD_VAR 0 4
106027: PPUSH
106028: CALL_OW 488
106032: IFFALSE 106055
// begin result := [ x , y ] ;
106034: LD_ADDR_VAR 0 1
106038: PUSH
106039: LD_VAR 0 3
106043: PUSH
106044: LD_VAR 0 4
106048: PUSH
106049: EMPTY
106050: LIST
106051: LIST
106052: ST_TO_ADDR
// break ;
106053: GO 106057
// end ; end ;
106055: GO 105857
106057: POP
106058: POP
// if result then
106059: LD_VAR 0 1
106063: IFFALSE 106123
// begin ToLua ( playSibBomb() ) ;
106065: LD_STRING playSibBomb()
106067: PPUSH
106068: CALL_OW 559
// wait ( 0 0$14 ) ;
106072: LD_INT 490
106074: PPUSH
106075: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
106079: LD_VAR 0 1
106083: PUSH
106084: LD_INT 1
106086: ARRAY
106087: PPUSH
106088: LD_VAR 0 1
106092: PUSH
106093: LD_INT 2
106095: ARRAY
106096: PPUSH
106097: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
106101: LD_VAR 0 1
106105: PUSH
106106: LD_INT 1
106108: ARRAY
106109: PPUSH
106110: LD_VAR 0 1
106114: PUSH
106115: LD_INT 2
106117: ARRAY
106118: PPUSH
106119: CALL_OW 429
// end ; end ;
106123: LD_VAR 0 1
106127: RET
// every 0 0$1 trigger StreamModeActive and sReset do
106128: LD_EXP 126
106132: IFFALSE 106140
106134: PUSH
106135: LD_EXP 148
106139: AND
106140: IFFALSE 106152
106142: GO 106144
106144: DISABLE
// YouLost (  ) ;
106145: LD_STRING 
106147: PPUSH
106148: CALL_OW 104
106152: END
// every 0 0$1 trigger StreamModeActive and sFog do
106153: LD_EXP 126
106157: IFFALSE 106165
106159: PUSH
106160: LD_EXP 147
106164: AND
106165: IFFALSE 106179
106167: GO 106169
106169: DISABLE
// FogOff ( your_side ) ;
106170: LD_OWVAR 2
106174: PPUSH
106175: CALL_OW 344
106179: END
// every 0 0$1 trigger StreamModeActive and sSun do
106180: LD_EXP 126
106184: IFFALSE 106192
106186: PUSH
106187: LD_EXP 149
106191: AND
106192: IFFALSE 106220
106194: GO 106196
106196: DISABLE
// begin solar_recharge_percent := 0 ;
106197: LD_ADDR_OWVAR 79
106201: PUSH
106202: LD_INT 0
106204: ST_TO_ADDR
// wait ( 5 5$00 ) ;
106205: LD_INT 10500
106207: PPUSH
106208: CALL_OW 67
// solar_recharge_percent := 100 ;
106212: LD_ADDR_OWVAR 79
106216: PUSH
106217: LD_INT 100
106219: ST_TO_ADDR
// end ;
106220: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
106221: LD_EXP 126
106225: IFFALSE 106233
106227: PUSH
106228: LD_EXP 150
106232: AND
106233: IFFALSE 106472
106235: GO 106237
106237: DISABLE
106238: LD_INT 0
106240: PPUSH
106241: PPUSH
106242: PPUSH
// begin tmp := [ ] ;
106243: LD_ADDR_VAR 0 3
106247: PUSH
106248: EMPTY
106249: ST_TO_ADDR
// for i := 1 to 6 do
106250: LD_ADDR_VAR 0 1
106254: PUSH
106255: DOUBLE
106256: LD_INT 1
106258: DEC
106259: ST_TO_ADDR
106260: LD_INT 6
106262: PUSH
106263: FOR_TO
106264: IFFALSE 106369
// begin uc_nation := nation_nature ;
106266: LD_ADDR_OWVAR 21
106270: PUSH
106271: LD_INT 0
106273: ST_TO_ADDR
// uc_side := 0 ;
106274: LD_ADDR_OWVAR 20
106278: PUSH
106279: LD_INT 0
106281: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
106282: LD_ADDR_OWVAR 29
106286: PUSH
106287: LD_INT 12
106289: PUSH
106290: LD_INT 12
106292: PUSH
106293: EMPTY
106294: LIST
106295: LIST
106296: ST_TO_ADDR
// hc_agressivity := 20 ;
106297: LD_ADDR_OWVAR 35
106301: PUSH
106302: LD_INT 20
106304: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
106305: LD_ADDR_OWVAR 28
106309: PUSH
106310: LD_INT 17
106312: ST_TO_ADDR
// hc_gallery :=  ;
106313: LD_ADDR_OWVAR 33
106317: PUSH
106318: LD_STRING 
106320: ST_TO_ADDR
// hc_name :=  ;
106321: LD_ADDR_OWVAR 26
106325: PUSH
106326: LD_STRING 
106328: ST_TO_ADDR
// un := CreateHuman ;
106329: LD_ADDR_VAR 0 2
106333: PUSH
106334: CALL_OW 44
106338: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
106339: LD_VAR 0 2
106343: PPUSH
106344: LD_INT 1
106346: PPUSH
106347: CALL_OW 51
// tmp := tmp ^ un ;
106351: LD_ADDR_VAR 0 3
106355: PUSH
106356: LD_VAR 0 3
106360: PUSH
106361: LD_VAR 0 2
106365: ADD
106366: ST_TO_ADDR
// end ;
106367: GO 106263
106369: POP
106370: POP
// repeat wait ( 0 0$1 ) ;
106371: LD_INT 35
106373: PPUSH
106374: CALL_OW 67
// for un in tmp do
106378: LD_ADDR_VAR 0 2
106382: PUSH
106383: LD_VAR 0 3
106387: PUSH
106388: FOR_IN
106389: IFFALSE 106463
// begin if IsDead ( un ) then
106391: LD_VAR 0 2
106395: PPUSH
106396: CALL_OW 301
106400: IFFALSE 106420
// begin tmp := tmp diff un ;
106402: LD_ADDR_VAR 0 3
106406: PUSH
106407: LD_VAR 0 3
106411: PUSH
106412: LD_VAR 0 2
106416: DIFF
106417: ST_TO_ADDR
// continue ;
106418: GO 106388
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
106420: LD_VAR 0 2
106424: PPUSH
106425: LD_INT 3
106427: PUSH
106428: LD_INT 22
106430: PUSH
106431: LD_INT 0
106433: PUSH
106434: EMPTY
106435: LIST
106436: LIST
106437: PUSH
106438: EMPTY
106439: LIST
106440: LIST
106441: PPUSH
106442: CALL_OW 69
106446: PPUSH
106447: LD_VAR 0 2
106451: PPUSH
106452: CALL_OW 74
106456: PPUSH
106457: CALL_OW 115
// end ;
106461: GO 106388
106463: POP
106464: POP
// until not tmp ;
106465: LD_VAR 0 3
106469: NOT
106470: IFFALSE 106371
// end ;
106472: PPOPN 3
106474: END
// every 0 0$1 trigger StreamModeActive and sTroll do
106475: LD_EXP 126
106479: IFFALSE 106487
106481: PUSH
106482: LD_EXP 151
106486: AND
106487: IFFALSE 106541
106489: GO 106491
106491: DISABLE
// begin ToLua ( displayTroll(); ) ;
106492: LD_STRING displayTroll();
106494: PPUSH
106495: CALL_OW 559
// wait ( 3 3$00 ) ;
106499: LD_INT 6300
106501: PPUSH
106502: CALL_OW 67
// ToLua ( hideTroll(); ) ;
106506: LD_STRING hideTroll();
106508: PPUSH
106509: CALL_OW 559
// wait ( 1 1$00 ) ;
106513: LD_INT 2100
106515: PPUSH
106516: CALL_OW 67
// ToLua ( displayTroll(); ) ;
106520: LD_STRING displayTroll();
106522: PPUSH
106523: CALL_OW 559
// wait ( 1 1$00 ) ;
106527: LD_INT 2100
106529: PPUSH
106530: CALL_OW 67
// ToLua ( hideTroll(); ) ;
106534: LD_STRING hideTroll();
106536: PPUSH
106537: CALL_OW 559
// end ;
106541: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
106542: LD_EXP 126
106546: IFFALSE 106554
106548: PUSH
106549: LD_EXP 152
106553: AND
106554: IFFALSE 106617
106556: GO 106558
106558: DISABLE
106559: LD_INT 0
106561: PPUSH
// begin p := 0 ;
106562: LD_ADDR_VAR 0 1
106566: PUSH
106567: LD_INT 0
106569: ST_TO_ADDR
// repeat game_speed := 1 ;
106570: LD_ADDR_OWVAR 65
106574: PUSH
106575: LD_INT 1
106577: ST_TO_ADDR
// wait ( 0 0$1 ) ;
106578: LD_INT 35
106580: PPUSH
106581: CALL_OW 67
// p := p + 1 ;
106585: LD_ADDR_VAR 0 1
106589: PUSH
106590: LD_VAR 0 1
106594: PUSH
106595: LD_INT 1
106597: PLUS
106598: ST_TO_ADDR
// until p >= 60 ;
106599: LD_VAR 0 1
106603: PUSH
106604: LD_INT 60
106606: GREATEREQUAL
106607: IFFALSE 106570
// game_speed := 4 ;
106609: LD_ADDR_OWVAR 65
106613: PUSH
106614: LD_INT 4
106616: ST_TO_ADDR
// end ;
106617: PPOPN 1
106619: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
106620: LD_EXP 126
106624: IFFALSE 106632
106626: PUSH
106627: LD_EXP 153
106631: AND
106632: IFFALSE 106778
106634: GO 106636
106636: DISABLE
106637: LD_INT 0
106639: PPUSH
106640: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106641: LD_ADDR_VAR 0 1
106645: PUSH
106646: LD_INT 22
106648: PUSH
106649: LD_OWVAR 2
106653: PUSH
106654: EMPTY
106655: LIST
106656: LIST
106657: PUSH
106658: LD_INT 2
106660: PUSH
106661: LD_INT 30
106663: PUSH
106664: LD_INT 0
106666: PUSH
106667: EMPTY
106668: LIST
106669: LIST
106670: PUSH
106671: LD_INT 30
106673: PUSH
106674: LD_INT 1
106676: PUSH
106677: EMPTY
106678: LIST
106679: LIST
106680: PUSH
106681: EMPTY
106682: LIST
106683: LIST
106684: LIST
106685: PUSH
106686: EMPTY
106687: LIST
106688: LIST
106689: PPUSH
106690: CALL_OW 69
106694: ST_TO_ADDR
// if not depot then
106695: LD_VAR 0 1
106699: NOT
106700: IFFALSE 106704
// exit ;
106702: GO 106778
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
106704: LD_ADDR_VAR 0 2
106708: PUSH
106709: LD_VAR 0 1
106713: PUSH
106714: LD_INT 1
106716: PPUSH
106717: LD_VAR 0 1
106721: PPUSH
106722: CALL_OW 12
106726: ARRAY
106727: PPUSH
106728: CALL_OW 274
106732: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
106733: LD_VAR 0 2
106737: PPUSH
106738: LD_INT 1
106740: PPUSH
106741: LD_INT 0
106743: PPUSH
106744: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
106748: LD_VAR 0 2
106752: PPUSH
106753: LD_INT 2
106755: PPUSH
106756: LD_INT 0
106758: PPUSH
106759: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
106763: LD_VAR 0 2
106767: PPUSH
106768: LD_INT 3
106770: PPUSH
106771: LD_INT 0
106773: PPUSH
106774: CALL_OW 277
// end ;
106778: PPOPN 2
106780: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
106781: LD_EXP 126
106785: IFFALSE 106793
106787: PUSH
106788: LD_EXP 154
106792: AND
106793: IFFALSE 106890
106795: GO 106797
106797: DISABLE
106798: LD_INT 0
106800: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106801: LD_ADDR_VAR 0 1
106805: PUSH
106806: LD_INT 22
106808: PUSH
106809: LD_OWVAR 2
106813: PUSH
106814: EMPTY
106815: LIST
106816: LIST
106817: PUSH
106818: LD_INT 21
106820: PUSH
106821: LD_INT 1
106823: PUSH
106824: EMPTY
106825: LIST
106826: LIST
106827: PUSH
106828: LD_INT 3
106830: PUSH
106831: LD_INT 23
106833: PUSH
106834: LD_INT 0
106836: PUSH
106837: EMPTY
106838: LIST
106839: LIST
106840: PUSH
106841: EMPTY
106842: LIST
106843: LIST
106844: PUSH
106845: EMPTY
106846: LIST
106847: LIST
106848: LIST
106849: PPUSH
106850: CALL_OW 69
106854: ST_TO_ADDR
// if not tmp then
106855: LD_VAR 0 1
106859: NOT
106860: IFFALSE 106864
// exit ;
106862: GO 106890
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
106864: LD_VAR 0 1
106868: PUSH
106869: LD_INT 1
106871: PPUSH
106872: LD_VAR 0 1
106876: PPUSH
106877: CALL_OW 12
106881: ARRAY
106882: PPUSH
106883: LD_INT 200
106885: PPUSH
106886: CALL_OW 234
// end ;
106890: PPOPN 1
106892: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
106893: LD_EXP 126
106897: IFFALSE 106905
106899: PUSH
106900: LD_EXP 155
106904: AND
106905: IFFALSE 106984
106907: GO 106909
106909: DISABLE
106910: LD_INT 0
106912: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
106913: LD_ADDR_VAR 0 1
106917: PUSH
106918: LD_INT 22
106920: PUSH
106921: LD_OWVAR 2
106925: PUSH
106926: EMPTY
106927: LIST
106928: LIST
106929: PUSH
106930: LD_INT 21
106932: PUSH
106933: LD_INT 2
106935: PUSH
106936: EMPTY
106937: LIST
106938: LIST
106939: PUSH
106940: EMPTY
106941: LIST
106942: LIST
106943: PPUSH
106944: CALL_OW 69
106948: ST_TO_ADDR
// if not tmp then
106949: LD_VAR 0 1
106953: NOT
106954: IFFALSE 106958
// exit ;
106956: GO 106984
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
106958: LD_VAR 0 1
106962: PUSH
106963: LD_INT 1
106965: PPUSH
106966: LD_VAR 0 1
106970: PPUSH
106971: CALL_OW 12
106975: ARRAY
106976: PPUSH
106977: LD_INT 60
106979: PPUSH
106980: CALL_OW 234
// end ;
106984: PPOPN 1
106986: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
106987: LD_EXP 126
106991: IFFALSE 106999
106993: PUSH
106994: LD_EXP 156
106998: AND
106999: IFFALSE 107098
107001: GO 107003
107003: DISABLE
107004: LD_INT 0
107006: PPUSH
107007: PPUSH
// begin enable ;
107008: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
107009: LD_ADDR_VAR 0 1
107013: PUSH
107014: LD_INT 22
107016: PUSH
107017: LD_OWVAR 2
107021: PUSH
107022: EMPTY
107023: LIST
107024: LIST
107025: PUSH
107026: LD_INT 61
107028: PUSH
107029: EMPTY
107030: LIST
107031: PUSH
107032: LD_INT 33
107034: PUSH
107035: LD_INT 2
107037: PUSH
107038: EMPTY
107039: LIST
107040: LIST
107041: PUSH
107042: EMPTY
107043: LIST
107044: LIST
107045: LIST
107046: PPUSH
107047: CALL_OW 69
107051: ST_TO_ADDR
// if not tmp then
107052: LD_VAR 0 1
107056: NOT
107057: IFFALSE 107061
// exit ;
107059: GO 107098
// for i in tmp do
107061: LD_ADDR_VAR 0 2
107065: PUSH
107066: LD_VAR 0 1
107070: PUSH
107071: FOR_IN
107072: IFFALSE 107096
// if IsControledBy ( i ) then
107074: LD_VAR 0 2
107078: PPUSH
107079: CALL_OW 312
107083: IFFALSE 107094
// ComUnlink ( i ) ;
107085: LD_VAR 0 2
107089: PPUSH
107090: CALL_OW 136
107094: GO 107071
107096: POP
107097: POP
// end ;
107098: PPOPN 2
107100: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
107101: LD_EXP 126
107105: IFFALSE 107113
107107: PUSH
107108: LD_EXP 157
107112: AND
107113: IFFALSE 107253
107115: GO 107117
107117: DISABLE
107118: LD_INT 0
107120: PPUSH
107121: PPUSH
// begin ToLua ( displayPowell(); ) ;
107122: LD_STRING displayPowell();
107124: PPUSH
107125: CALL_OW 559
// uc_side := 0 ;
107129: LD_ADDR_OWVAR 20
107133: PUSH
107134: LD_INT 0
107136: ST_TO_ADDR
// uc_nation := 2 ;
107137: LD_ADDR_OWVAR 21
107141: PUSH
107142: LD_INT 2
107144: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
107145: LD_ADDR_OWVAR 37
107149: PUSH
107150: LD_INT 14
107152: ST_TO_ADDR
// vc_engine := engine_siberite ;
107153: LD_ADDR_OWVAR 39
107157: PUSH
107158: LD_INT 3
107160: ST_TO_ADDR
// vc_control := control_apeman ;
107161: LD_ADDR_OWVAR 38
107165: PUSH
107166: LD_INT 5
107168: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
107169: LD_ADDR_OWVAR 40
107173: PUSH
107174: LD_INT 29
107176: ST_TO_ADDR
// un := CreateVehicle ;
107177: LD_ADDR_VAR 0 2
107181: PUSH
107182: CALL_OW 45
107186: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
107187: LD_VAR 0 2
107191: PPUSH
107192: LD_INT 1
107194: PPUSH
107195: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
107199: LD_INT 35
107201: PPUSH
107202: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
107206: LD_VAR 0 2
107210: PPUSH
107211: LD_INT 22
107213: PUSH
107214: LD_OWVAR 2
107218: PUSH
107219: EMPTY
107220: LIST
107221: LIST
107222: PPUSH
107223: CALL_OW 69
107227: PPUSH
107228: LD_VAR 0 2
107232: PPUSH
107233: CALL_OW 74
107237: PPUSH
107238: CALL_OW 115
// until IsDead ( un ) ;
107242: LD_VAR 0 2
107246: PPUSH
107247: CALL_OW 301
107251: IFFALSE 107199
// end ;
107253: PPOPN 2
107255: END
// every 0 0$1 trigger StreamModeActive and sStu do
107256: LD_EXP 126
107260: IFFALSE 107268
107262: PUSH
107263: LD_EXP 165
107267: AND
107268: IFFALSE 107284
107270: GO 107272
107272: DISABLE
// begin ToLua ( displayStucuk(); ) ;
107273: LD_STRING displayStucuk();
107275: PPUSH
107276: CALL_OW 559
// ResetFog ;
107280: CALL_OW 335
// end ;
107284: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
107285: LD_EXP 126
107289: IFFALSE 107297
107291: PUSH
107292: LD_EXP 158
107296: AND
107297: IFFALSE 107438
107299: GO 107301
107301: DISABLE
107302: LD_INT 0
107304: PPUSH
107305: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
107306: LD_ADDR_VAR 0 2
107310: PUSH
107311: LD_INT 22
107313: PUSH
107314: LD_OWVAR 2
107318: PUSH
107319: EMPTY
107320: LIST
107321: LIST
107322: PUSH
107323: LD_INT 21
107325: PUSH
107326: LD_INT 1
107328: PUSH
107329: EMPTY
107330: LIST
107331: LIST
107332: PUSH
107333: EMPTY
107334: LIST
107335: LIST
107336: PPUSH
107337: CALL_OW 69
107341: ST_TO_ADDR
// if not tmp then
107342: LD_VAR 0 2
107346: NOT
107347: IFFALSE 107351
// exit ;
107349: GO 107438
// un := tmp [ rand ( 1 , tmp ) ] ;
107351: LD_ADDR_VAR 0 1
107355: PUSH
107356: LD_VAR 0 2
107360: PUSH
107361: LD_INT 1
107363: PPUSH
107364: LD_VAR 0 2
107368: PPUSH
107369: CALL_OW 12
107373: ARRAY
107374: ST_TO_ADDR
// SetSide ( un , 0 ) ;
107375: LD_VAR 0 1
107379: PPUSH
107380: LD_INT 0
107382: PPUSH
107383: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
107387: LD_VAR 0 1
107391: PPUSH
107392: LD_OWVAR 3
107396: PUSH
107397: LD_VAR 0 1
107401: DIFF
107402: PPUSH
107403: LD_VAR 0 1
107407: PPUSH
107408: CALL_OW 74
107412: PPUSH
107413: CALL_OW 115
// wait ( 0 0$20 ) ;
107417: LD_INT 700
107419: PPUSH
107420: CALL_OW 67
// SetSide ( un , your_side ) ;
107424: LD_VAR 0 1
107428: PPUSH
107429: LD_OWVAR 2
107433: PPUSH
107434: CALL_OW 235
// end ;
107438: PPOPN 2
107440: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
107441: LD_EXP 126
107445: IFFALSE 107453
107447: PUSH
107448: LD_EXP 159
107452: AND
107453: IFFALSE 107559
107455: GO 107457
107457: DISABLE
107458: LD_INT 0
107460: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107461: LD_ADDR_VAR 0 1
107465: PUSH
107466: LD_INT 22
107468: PUSH
107469: LD_OWVAR 2
107473: PUSH
107474: EMPTY
107475: LIST
107476: LIST
107477: PUSH
107478: LD_INT 2
107480: PUSH
107481: LD_INT 30
107483: PUSH
107484: LD_INT 0
107486: PUSH
107487: EMPTY
107488: LIST
107489: LIST
107490: PUSH
107491: LD_INT 30
107493: PUSH
107494: LD_INT 1
107496: PUSH
107497: EMPTY
107498: LIST
107499: LIST
107500: PUSH
107501: EMPTY
107502: LIST
107503: LIST
107504: LIST
107505: PUSH
107506: EMPTY
107507: LIST
107508: LIST
107509: PPUSH
107510: CALL_OW 69
107514: ST_TO_ADDR
// if not depot then
107515: LD_VAR 0 1
107519: NOT
107520: IFFALSE 107524
// exit ;
107522: GO 107559
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
107524: LD_VAR 0 1
107528: PUSH
107529: LD_INT 1
107531: ARRAY
107532: PPUSH
107533: CALL_OW 250
107537: PPUSH
107538: LD_VAR 0 1
107542: PUSH
107543: LD_INT 1
107545: ARRAY
107546: PPUSH
107547: CALL_OW 251
107551: PPUSH
107552: LD_INT 70
107554: PPUSH
107555: CALL_OW 495
// end ;
107559: PPOPN 1
107561: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
107562: LD_EXP 126
107566: IFFALSE 107574
107568: PUSH
107569: LD_EXP 160
107573: AND
107574: IFFALSE 107785
107576: GO 107578
107578: DISABLE
107579: LD_INT 0
107581: PPUSH
107582: PPUSH
107583: PPUSH
107584: PPUSH
107585: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
107586: LD_ADDR_VAR 0 5
107590: PUSH
107591: LD_INT 22
107593: PUSH
107594: LD_OWVAR 2
107598: PUSH
107599: EMPTY
107600: LIST
107601: LIST
107602: PUSH
107603: LD_INT 21
107605: PUSH
107606: LD_INT 1
107608: PUSH
107609: EMPTY
107610: LIST
107611: LIST
107612: PUSH
107613: EMPTY
107614: LIST
107615: LIST
107616: PPUSH
107617: CALL_OW 69
107621: ST_TO_ADDR
// if not tmp then
107622: LD_VAR 0 5
107626: NOT
107627: IFFALSE 107631
// exit ;
107629: GO 107785
// for i in tmp do
107631: LD_ADDR_VAR 0 1
107635: PUSH
107636: LD_VAR 0 5
107640: PUSH
107641: FOR_IN
107642: IFFALSE 107783
// begin d := rand ( 0 , 5 ) ;
107644: LD_ADDR_VAR 0 4
107648: PUSH
107649: LD_INT 0
107651: PPUSH
107652: LD_INT 5
107654: PPUSH
107655: CALL_OW 12
107659: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
107660: LD_ADDR_VAR 0 2
107664: PUSH
107665: LD_VAR 0 1
107669: PPUSH
107670: CALL_OW 250
107674: PPUSH
107675: LD_VAR 0 4
107679: PPUSH
107680: LD_INT 3
107682: PPUSH
107683: LD_INT 12
107685: PPUSH
107686: CALL_OW 12
107690: PPUSH
107691: CALL_OW 272
107695: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
107696: LD_ADDR_VAR 0 3
107700: PUSH
107701: LD_VAR 0 1
107705: PPUSH
107706: CALL_OW 251
107710: PPUSH
107711: LD_VAR 0 4
107715: PPUSH
107716: LD_INT 3
107718: PPUSH
107719: LD_INT 12
107721: PPUSH
107722: CALL_OW 12
107726: PPUSH
107727: CALL_OW 273
107731: ST_TO_ADDR
// if ValidHex ( x , y ) then
107732: LD_VAR 0 2
107736: PPUSH
107737: LD_VAR 0 3
107741: PPUSH
107742: CALL_OW 488
107746: IFFALSE 107781
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
107748: LD_VAR 0 1
107752: PPUSH
107753: LD_VAR 0 2
107757: PPUSH
107758: LD_VAR 0 3
107762: PPUSH
107763: LD_INT 3
107765: PPUSH
107766: LD_INT 6
107768: PPUSH
107769: CALL_OW 12
107773: PPUSH
107774: LD_INT 1
107776: PPUSH
107777: CALL_OW 483
// end ;
107781: GO 107641
107783: POP
107784: POP
// end ;
107785: PPOPN 5
107787: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
107788: LD_EXP 126
107792: IFFALSE 107800
107794: PUSH
107795: LD_EXP 161
107799: AND
107800: IFFALSE 107894
107802: GO 107804
107804: DISABLE
107805: LD_INT 0
107807: PPUSH
107808: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
107809: LD_ADDR_VAR 0 2
107813: PUSH
107814: LD_INT 22
107816: PUSH
107817: LD_OWVAR 2
107821: PUSH
107822: EMPTY
107823: LIST
107824: LIST
107825: PUSH
107826: LD_INT 32
107828: PUSH
107829: LD_INT 1
107831: PUSH
107832: EMPTY
107833: LIST
107834: LIST
107835: PUSH
107836: LD_INT 21
107838: PUSH
107839: LD_INT 2
107841: PUSH
107842: EMPTY
107843: LIST
107844: LIST
107845: PUSH
107846: EMPTY
107847: LIST
107848: LIST
107849: LIST
107850: PPUSH
107851: CALL_OW 69
107855: ST_TO_ADDR
// if not tmp then
107856: LD_VAR 0 2
107860: NOT
107861: IFFALSE 107865
// exit ;
107863: GO 107894
// for i in tmp do
107865: LD_ADDR_VAR 0 1
107869: PUSH
107870: LD_VAR 0 2
107874: PUSH
107875: FOR_IN
107876: IFFALSE 107892
// SetFuel ( i , 0 ) ;
107878: LD_VAR 0 1
107882: PPUSH
107883: LD_INT 0
107885: PPUSH
107886: CALL_OW 240
107890: GO 107875
107892: POP
107893: POP
// end ;
107894: PPOPN 2
107896: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
107897: LD_EXP 126
107901: IFFALSE 107909
107903: PUSH
107904: LD_EXP 162
107908: AND
107909: IFFALSE 107975
107911: GO 107913
107913: DISABLE
107914: LD_INT 0
107916: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
107917: LD_ADDR_VAR 0 1
107921: PUSH
107922: LD_INT 22
107924: PUSH
107925: LD_OWVAR 2
107929: PUSH
107930: EMPTY
107931: LIST
107932: LIST
107933: PUSH
107934: LD_INT 30
107936: PUSH
107937: LD_INT 29
107939: PUSH
107940: EMPTY
107941: LIST
107942: LIST
107943: PUSH
107944: EMPTY
107945: LIST
107946: LIST
107947: PPUSH
107948: CALL_OW 69
107952: ST_TO_ADDR
// if not tmp then
107953: LD_VAR 0 1
107957: NOT
107958: IFFALSE 107962
// exit ;
107960: GO 107975
// DestroyUnit ( tmp [ 1 ] ) ;
107962: LD_VAR 0 1
107966: PUSH
107967: LD_INT 1
107969: ARRAY
107970: PPUSH
107971: CALL_OW 65
// end ;
107975: PPOPN 1
107977: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
107978: LD_EXP 126
107982: IFFALSE 107990
107984: PUSH
107985: LD_EXP 164
107989: AND
107990: IFFALSE 108119
107992: GO 107994
107994: DISABLE
107995: LD_INT 0
107997: PPUSH
// begin uc_side := 0 ;
107998: LD_ADDR_OWVAR 20
108002: PUSH
108003: LD_INT 0
108005: ST_TO_ADDR
// uc_nation := nation_arabian ;
108006: LD_ADDR_OWVAR 21
108010: PUSH
108011: LD_INT 2
108013: ST_TO_ADDR
// hc_gallery :=  ;
108014: LD_ADDR_OWVAR 33
108018: PUSH
108019: LD_STRING 
108021: ST_TO_ADDR
// hc_name :=  ;
108022: LD_ADDR_OWVAR 26
108026: PUSH
108027: LD_STRING 
108029: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
108030: LD_INT 1
108032: PPUSH
108033: LD_INT 11
108035: PPUSH
108036: LD_INT 10
108038: PPUSH
108039: CALL_OW 380
// un := CreateHuman ;
108043: LD_ADDR_VAR 0 1
108047: PUSH
108048: CALL_OW 44
108052: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
108053: LD_VAR 0 1
108057: PPUSH
108058: LD_INT 1
108060: PPUSH
108061: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
108065: LD_INT 35
108067: PPUSH
108068: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
108072: LD_VAR 0 1
108076: PPUSH
108077: LD_INT 22
108079: PUSH
108080: LD_OWVAR 2
108084: PUSH
108085: EMPTY
108086: LIST
108087: LIST
108088: PPUSH
108089: CALL_OW 69
108093: PPUSH
108094: LD_VAR 0 1
108098: PPUSH
108099: CALL_OW 74
108103: PPUSH
108104: CALL_OW 115
// until IsDead ( un ) ;
108108: LD_VAR 0 1
108112: PPUSH
108113: CALL_OW 301
108117: IFFALSE 108065
// end ;
108119: PPOPN 1
108121: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
108122: LD_EXP 126
108126: IFFALSE 108134
108128: PUSH
108129: LD_EXP 166
108133: AND
108134: IFFALSE 108146
108136: GO 108138
108138: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
108139: LD_STRING earthquake(getX(game), 0, 32)
108141: PPUSH
108142: CALL_OW 559
108146: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
108147: LD_EXP 126
108151: IFFALSE 108159
108153: PUSH
108154: LD_EXP 167
108158: AND
108159: IFFALSE 108250
108161: GO 108163
108163: DISABLE
108164: LD_INT 0
108166: PPUSH
// begin enable ;
108167: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
108168: LD_ADDR_VAR 0 1
108172: PUSH
108173: LD_INT 22
108175: PUSH
108176: LD_OWVAR 2
108180: PUSH
108181: EMPTY
108182: LIST
108183: LIST
108184: PUSH
108185: LD_INT 21
108187: PUSH
108188: LD_INT 2
108190: PUSH
108191: EMPTY
108192: LIST
108193: LIST
108194: PUSH
108195: LD_INT 33
108197: PUSH
108198: LD_INT 3
108200: PUSH
108201: EMPTY
108202: LIST
108203: LIST
108204: PUSH
108205: EMPTY
108206: LIST
108207: LIST
108208: LIST
108209: PPUSH
108210: CALL_OW 69
108214: ST_TO_ADDR
// if not tmp then
108215: LD_VAR 0 1
108219: NOT
108220: IFFALSE 108224
// exit ;
108222: GO 108250
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
108224: LD_VAR 0 1
108228: PUSH
108229: LD_INT 1
108231: PPUSH
108232: LD_VAR 0 1
108236: PPUSH
108237: CALL_OW 12
108241: ARRAY
108242: PPUSH
108243: LD_INT 1
108245: PPUSH
108246: CALL_OW 234
// end ;
108250: PPOPN 1
108252: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
108253: LD_EXP 126
108257: IFFALSE 108265
108259: PUSH
108260: LD_EXP 168
108264: AND
108265: IFFALSE 108406
108267: GO 108269
108269: DISABLE
108270: LD_INT 0
108272: PPUSH
108273: PPUSH
108274: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
108275: LD_ADDR_VAR 0 3
108279: PUSH
108280: LD_INT 22
108282: PUSH
108283: LD_OWVAR 2
108287: PUSH
108288: EMPTY
108289: LIST
108290: LIST
108291: PUSH
108292: LD_INT 25
108294: PUSH
108295: LD_INT 1
108297: PUSH
108298: EMPTY
108299: LIST
108300: LIST
108301: PUSH
108302: EMPTY
108303: LIST
108304: LIST
108305: PPUSH
108306: CALL_OW 69
108310: ST_TO_ADDR
// if not tmp then
108311: LD_VAR 0 3
108315: NOT
108316: IFFALSE 108320
// exit ;
108318: GO 108406
// un := tmp [ rand ( 1 , tmp ) ] ;
108320: LD_ADDR_VAR 0 2
108324: PUSH
108325: LD_VAR 0 3
108329: PUSH
108330: LD_INT 1
108332: PPUSH
108333: LD_VAR 0 3
108337: PPUSH
108338: CALL_OW 12
108342: ARRAY
108343: ST_TO_ADDR
// if Crawls ( un ) then
108344: LD_VAR 0 2
108348: PPUSH
108349: CALL_OW 318
108353: IFFALSE 108364
// ComWalk ( un ) ;
108355: LD_VAR 0 2
108359: PPUSH
108360: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
108364: LD_VAR 0 2
108368: PPUSH
108369: LD_INT 9
108371: PPUSH
108372: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
108376: LD_INT 28
108378: PPUSH
108379: LD_OWVAR 2
108383: PPUSH
108384: LD_INT 2
108386: PPUSH
108387: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
108391: LD_INT 29
108393: PPUSH
108394: LD_OWVAR 2
108398: PPUSH
108399: LD_INT 2
108401: PPUSH
108402: CALL_OW 322
// end ;
108406: PPOPN 3
108408: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
108409: LD_EXP 126
108413: IFFALSE 108421
108415: PUSH
108416: LD_EXP 169
108420: AND
108421: IFFALSE 108532
108423: GO 108425
108425: DISABLE
108426: LD_INT 0
108428: PPUSH
108429: PPUSH
108430: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
108431: LD_ADDR_VAR 0 3
108435: PUSH
108436: LD_INT 22
108438: PUSH
108439: LD_OWVAR 2
108443: PUSH
108444: EMPTY
108445: LIST
108446: LIST
108447: PUSH
108448: LD_INT 25
108450: PUSH
108451: LD_INT 1
108453: PUSH
108454: EMPTY
108455: LIST
108456: LIST
108457: PUSH
108458: EMPTY
108459: LIST
108460: LIST
108461: PPUSH
108462: CALL_OW 69
108466: ST_TO_ADDR
// if not tmp then
108467: LD_VAR 0 3
108471: NOT
108472: IFFALSE 108476
// exit ;
108474: GO 108532
// un := tmp [ rand ( 1 , tmp ) ] ;
108476: LD_ADDR_VAR 0 2
108480: PUSH
108481: LD_VAR 0 3
108485: PUSH
108486: LD_INT 1
108488: PPUSH
108489: LD_VAR 0 3
108493: PPUSH
108494: CALL_OW 12
108498: ARRAY
108499: ST_TO_ADDR
// if Crawls ( un ) then
108500: LD_VAR 0 2
108504: PPUSH
108505: CALL_OW 318
108509: IFFALSE 108520
// ComWalk ( un ) ;
108511: LD_VAR 0 2
108515: PPUSH
108516: CALL_OW 138
// SetClass ( un , class_mortar ) ;
108520: LD_VAR 0 2
108524: PPUSH
108525: LD_INT 8
108527: PPUSH
108528: CALL_OW 336
// end ;
108532: PPOPN 3
108534: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
108535: LD_EXP 126
108539: IFFALSE 108547
108541: PUSH
108542: LD_EXP 170
108546: AND
108547: IFFALSE 108691
108549: GO 108551
108551: DISABLE
108552: LD_INT 0
108554: PPUSH
108555: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
108556: LD_ADDR_VAR 0 2
108560: PUSH
108561: LD_INT 22
108563: PUSH
108564: LD_OWVAR 2
108568: PUSH
108569: EMPTY
108570: LIST
108571: LIST
108572: PUSH
108573: LD_INT 21
108575: PUSH
108576: LD_INT 2
108578: PUSH
108579: EMPTY
108580: LIST
108581: LIST
108582: PUSH
108583: LD_INT 2
108585: PUSH
108586: LD_INT 34
108588: PUSH
108589: LD_INT 12
108591: PUSH
108592: EMPTY
108593: LIST
108594: LIST
108595: PUSH
108596: LD_INT 34
108598: PUSH
108599: LD_INT 51
108601: PUSH
108602: EMPTY
108603: LIST
108604: LIST
108605: PUSH
108606: LD_INT 34
108608: PUSH
108609: LD_INT 32
108611: PUSH
108612: EMPTY
108613: LIST
108614: LIST
108615: PUSH
108616: EMPTY
108617: LIST
108618: LIST
108619: LIST
108620: LIST
108621: PUSH
108622: EMPTY
108623: LIST
108624: LIST
108625: LIST
108626: PPUSH
108627: CALL_OW 69
108631: ST_TO_ADDR
// if not tmp then
108632: LD_VAR 0 2
108636: NOT
108637: IFFALSE 108641
// exit ;
108639: GO 108691
// for i in tmp do
108641: LD_ADDR_VAR 0 1
108645: PUSH
108646: LD_VAR 0 2
108650: PUSH
108651: FOR_IN
108652: IFFALSE 108689
// if GetCargo ( i , mat_artifact ) = 0 then
108654: LD_VAR 0 1
108658: PPUSH
108659: LD_INT 4
108661: PPUSH
108662: CALL_OW 289
108666: PUSH
108667: LD_INT 0
108669: EQUAL
108670: IFFALSE 108687
// SetCargo ( i , mat_siberit , 100 ) ;
108672: LD_VAR 0 1
108676: PPUSH
108677: LD_INT 3
108679: PPUSH
108680: LD_INT 100
108682: PPUSH
108683: CALL_OW 290
108687: GO 108651
108689: POP
108690: POP
// end ;
108691: PPOPN 2
108693: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
108694: LD_EXP 126
108698: IFFALSE 108706
108700: PUSH
108701: LD_EXP 171
108705: AND
108706: IFFALSE 108889
108708: GO 108710
108710: DISABLE
108711: LD_INT 0
108713: PPUSH
108714: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108715: LD_ADDR_VAR 0 2
108719: PUSH
108720: LD_INT 22
108722: PUSH
108723: LD_OWVAR 2
108727: PUSH
108728: EMPTY
108729: LIST
108730: LIST
108731: PPUSH
108732: CALL_OW 69
108736: ST_TO_ADDR
// if not tmp then
108737: LD_VAR 0 2
108741: NOT
108742: IFFALSE 108746
// exit ;
108744: GO 108889
// for i := 1 to 2 do
108746: LD_ADDR_VAR 0 1
108750: PUSH
108751: DOUBLE
108752: LD_INT 1
108754: DEC
108755: ST_TO_ADDR
108756: LD_INT 2
108758: PUSH
108759: FOR_TO
108760: IFFALSE 108887
// begin uc_side := your_side ;
108762: LD_ADDR_OWVAR 20
108766: PUSH
108767: LD_OWVAR 2
108771: ST_TO_ADDR
// uc_nation := nation_american ;
108772: LD_ADDR_OWVAR 21
108776: PUSH
108777: LD_INT 1
108779: ST_TO_ADDR
// vc_chassis := us_morphling ;
108780: LD_ADDR_OWVAR 37
108784: PUSH
108785: LD_INT 5
108787: ST_TO_ADDR
// vc_engine := engine_siberite ;
108788: LD_ADDR_OWVAR 39
108792: PUSH
108793: LD_INT 3
108795: ST_TO_ADDR
// vc_control := control_computer ;
108796: LD_ADDR_OWVAR 38
108800: PUSH
108801: LD_INT 3
108803: ST_TO_ADDR
// vc_weapon := us_double_laser ;
108804: LD_ADDR_OWVAR 40
108808: PUSH
108809: LD_INT 10
108811: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
108812: LD_VAR 0 2
108816: PUSH
108817: LD_INT 1
108819: ARRAY
108820: PPUSH
108821: CALL_OW 310
108825: NOT
108826: IFFALSE 108873
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
108828: CALL_OW 45
108832: PPUSH
108833: LD_VAR 0 2
108837: PUSH
108838: LD_INT 1
108840: ARRAY
108841: PPUSH
108842: CALL_OW 250
108846: PPUSH
108847: LD_VAR 0 2
108851: PUSH
108852: LD_INT 1
108854: ARRAY
108855: PPUSH
108856: CALL_OW 251
108860: PPUSH
108861: LD_INT 12
108863: PPUSH
108864: LD_INT 1
108866: PPUSH
108867: CALL_OW 50
108871: GO 108885
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
108873: CALL_OW 45
108877: PPUSH
108878: LD_INT 1
108880: PPUSH
108881: CALL_OW 51
// end ;
108885: GO 108759
108887: POP
108888: POP
// end ;
108889: PPOPN 2
108891: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
108892: LD_EXP 126
108896: IFFALSE 108904
108898: PUSH
108899: LD_EXP 172
108903: AND
108904: IFFALSE 109126
108906: GO 108908
108908: DISABLE
108909: LD_INT 0
108911: PPUSH
108912: PPUSH
108913: PPUSH
108914: PPUSH
108915: PPUSH
108916: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
108917: LD_ADDR_VAR 0 6
108921: PUSH
108922: LD_INT 22
108924: PUSH
108925: LD_OWVAR 2
108929: PUSH
108930: EMPTY
108931: LIST
108932: LIST
108933: PUSH
108934: LD_INT 21
108936: PUSH
108937: LD_INT 1
108939: PUSH
108940: EMPTY
108941: LIST
108942: LIST
108943: PUSH
108944: LD_INT 3
108946: PUSH
108947: LD_INT 23
108949: PUSH
108950: LD_INT 0
108952: PUSH
108953: EMPTY
108954: LIST
108955: LIST
108956: PUSH
108957: EMPTY
108958: LIST
108959: LIST
108960: PUSH
108961: EMPTY
108962: LIST
108963: LIST
108964: LIST
108965: PPUSH
108966: CALL_OW 69
108970: ST_TO_ADDR
// if not tmp then
108971: LD_VAR 0 6
108975: NOT
108976: IFFALSE 108980
// exit ;
108978: GO 109126
// s1 := rand ( 1 , 4 ) ;
108980: LD_ADDR_VAR 0 2
108984: PUSH
108985: LD_INT 1
108987: PPUSH
108988: LD_INT 4
108990: PPUSH
108991: CALL_OW 12
108995: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
108996: LD_ADDR_VAR 0 4
109000: PUSH
109001: LD_VAR 0 6
109005: PUSH
109006: LD_INT 1
109008: ARRAY
109009: PPUSH
109010: LD_VAR 0 2
109014: PPUSH
109015: CALL_OW 259
109019: ST_TO_ADDR
// if s1 = 1 then
109020: LD_VAR 0 2
109024: PUSH
109025: LD_INT 1
109027: EQUAL
109028: IFFALSE 109048
// s2 := rand ( 2 , 4 ) else
109030: LD_ADDR_VAR 0 3
109034: PUSH
109035: LD_INT 2
109037: PPUSH
109038: LD_INT 4
109040: PPUSH
109041: CALL_OW 12
109045: ST_TO_ADDR
109046: GO 109056
// s2 := 1 ;
109048: LD_ADDR_VAR 0 3
109052: PUSH
109053: LD_INT 1
109055: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
109056: LD_ADDR_VAR 0 5
109060: PUSH
109061: LD_VAR 0 6
109065: PUSH
109066: LD_INT 1
109068: ARRAY
109069: PPUSH
109070: LD_VAR 0 3
109074: PPUSH
109075: CALL_OW 259
109079: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
109080: LD_VAR 0 6
109084: PUSH
109085: LD_INT 1
109087: ARRAY
109088: PPUSH
109089: LD_VAR 0 2
109093: PPUSH
109094: LD_VAR 0 5
109098: PPUSH
109099: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
109103: LD_VAR 0 6
109107: PUSH
109108: LD_INT 1
109110: ARRAY
109111: PPUSH
109112: LD_VAR 0 3
109116: PPUSH
109117: LD_VAR 0 4
109121: PPUSH
109122: CALL_OW 237
// end ;
109126: PPOPN 6
109128: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
109129: LD_EXP 126
109133: IFFALSE 109141
109135: PUSH
109136: LD_EXP 173
109140: AND
109141: IFFALSE 109220
109143: GO 109145
109145: DISABLE
109146: LD_INT 0
109148: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
109149: LD_ADDR_VAR 0 1
109153: PUSH
109154: LD_INT 22
109156: PUSH
109157: LD_OWVAR 2
109161: PUSH
109162: EMPTY
109163: LIST
109164: LIST
109165: PUSH
109166: LD_INT 30
109168: PUSH
109169: LD_INT 3
109171: PUSH
109172: EMPTY
109173: LIST
109174: LIST
109175: PUSH
109176: EMPTY
109177: LIST
109178: LIST
109179: PPUSH
109180: CALL_OW 69
109184: ST_TO_ADDR
// if not tmp then
109185: LD_VAR 0 1
109189: NOT
109190: IFFALSE 109194
// exit ;
109192: GO 109220
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
109194: LD_VAR 0 1
109198: PUSH
109199: LD_INT 1
109201: PPUSH
109202: LD_VAR 0 1
109206: PPUSH
109207: CALL_OW 12
109211: ARRAY
109212: PPUSH
109213: LD_INT 1
109215: PPUSH
109216: CALL_OW 234
// end ;
109220: PPOPN 1
109222: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
109223: LD_EXP 126
109227: IFFALSE 109235
109229: PUSH
109230: LD_EXP 174
109234: AND
109235: IFFALSE 109347
109237: GO 109239
109239: DISABLE
109240: LD_INT 0
109242: PPUSH
109243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
109244: LD_ADDR_VAR 0 2
109248: PUSH
109249: LD_INT 22
109251: PUSH
109252: LD_OWVAR 2
109256: PUSH
109257: EMPTY
109258: LIST
109259: LIST
109260: PUSH
109261: LD_INT 2
109263: PUSH
109264: LD_INT 30
109266: PUSH
109267: LD_INT 27
109269: PUSH
109270: EMPTY
109271: LIST
109272: LIST
109273: PUSH
109274: LD_INT 30
109276: PUSH
109277: LD_INT 26
109279: PUSH
109280: EMPTY
109281: LIST
109282: LIST
109283: PUSH
109284: LD_INT 30
109286: PUSH
109287: LD_INT 28
109289: PUSH
109290: EMPTY
109291: LIST
109292: LIST
109293: PUSH
109294: EMPTY
109295: LIST
109296: LIST
109297: LIST
109298: LIST
109299: PUSH
109300: EMPTY
109301: LIST
109302: LIST
109303: PPUSH
109304: CALL_OW 69
109308: ST_TO_ADDR
// if not tmp then
109309: LD_VAR 0 2
109313: NOT
109314: IFFALSE 109318
// exit ;
109316: GO 109347
// for i in tmp do
109318: LD_ADDR_VAR 0 1
109322: PUSH
109323: LD_VAR 0 2
109327: PUSH
109328: FOR_IN
109329: IFFALSE 109345
// SetLives ( i , 1 ) ;
109331: LD_VAR 0 1
109335: PPUSH
109336: LD_INT 1
109338: PPUSH
109339: CALL_OW 234
109343: GO 109328
109345: POP
109346: POP
// end ;
109347: PPOPN 2
109349: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
109350: LD_EXP 126
109354: IFFALSE 109362
109356: PUSH
109357: LD_EXP 175
109361: AND
109362: IFFALSE 109649
109364: GO 109366
109366: DISABLE
109367: LD_INT 0
109369: PPUSH
109370: PPUSH
109371: PPUSH
// begin i := rand ( 1 , 7 ) ;
109372: LD_ADDR_VAR 0 1
109376: PUSH
109377: LD_INT 1
109379: PPUSH
109380: LD_INT 7
109382: PPUSH
109383: CALL_OW 12
109387: ST_TO_ADDR
// case i of 1 :
109388: LD_VAR 0 1
109392: PUSH
109393: LD_INT 1
109395: DOUBLE
109396: EQUAL
109397: IFTRUE 109401
109399: GO 109411
109401: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
109402: LD_STRING earthquake(getX(game), 0, 32)
109404: PPUSH
109405: CALL_OW 559
109409: GO 109649
109411: LD_INT 2
109413: DOUBLE
109414: EQUAL
109415: IFTRUE 109419
109417: GO 109433
109419: POP
// begin ToLua ( displayStucuk(); ) ;
109420: LD_STRING displayStucuk();
109422: PPUSH
109423: CALL_OW 559
// ResetFog ;
109427: CALL_OW 335
// end ; 3 :
109431: GO 109649
109433: LD_INT 3
109435: DOUBLE
109436: EQUAL
109437: IFTRUE 109441
109439: GO 109545
109441: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
109442: LD_ADDR_VAR 0 2
109446: PUSH
109447: LD_INT 22
109449: PUSH
109450: LD_OWVAR 2
109454: PUSH
109455: EMPTY
109456: LIST
109457: LIST
109458: PUSH
109459: LD_INT 25
109461: PUSH
109462: LD_INT 1
109464: PUSH
109465: EMPTY
109466: LIST
109467: LIST
109468: PUSH
109469: EMPTY
109470: LIST
109471: LIST
109472: PPUSH
109473: CALL_OW 69
109477: ST_TO_ADDR
// if not tmp then
109478: LD_VAR 0 2
109482: NOT
109483: IFFALSE 109487
// exit ;
109485: GO 109649
// un := tmp [ rand ( 1 , tmp ) ] ;
109487: LD_ADDR_VAR 0 3
109491: PUSH
109492: LD_VAR 0 2
109496: PUSH
109497: LD_INT 1
109499: PPUSH
109500: LD_VAR 0 2
109504: PPUSH
109505: CALL_OW 12
109509: ARRAY
109510: ST_TO_ADDR
// if Crawls ( un ) then
109511: LD_VAR 0 3
109515: PPUSH
109516: CALL_OW 318
109520: IFFALSE 109531
// ComWalk ( un ) ;
109522: LD_VAR 0 3
109526: PPUSH
109527: CALL_OW 138
// SetClass ( un , class_mortar ) ;
109531: LD_VAR 0 3
109535: PPUSH
109536: LD_INT 8
109538: PPUSH
109539: CALL_OW 336
// end ; 4 :
109543: GO 109649
109545: LD_INT 4
109547: DOUBLE
109548: EQUAL
109549: IFTRUE 109553
109551: GO 109627
109553: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
109554: LD_ADDR_VAR 0 2
109558: PUSH
109559: LD_INT 22
109561: PUSH
109562: LD_OWVAR 2
109566: PUSH
109567: EMPTY
109568: LIST
109569: LIST
109570: PUSH
109571: LD_INT 30
109573: PUSH
109574: LD_INT 29
109576: PUSH
109577: EMPTY
109578: LIST
109579: LIST
109580: PUSH
109581: EMPTY
109582: LIST
109583: LIST
109584: PPUSH
109585: CALL_OW 69
109589: ST_TO_ADDR
// if not tmp then
109590: LD_VAR 0 2
109594: NOT
109595: IFFALSE 109599
// exit ;
109597: GO 109649
// CenterNowOnUnits ( tmp [ 1 ] ) ;
109599: LD_VAR 0 2
109603: PUSH
109604: LD_INT 1
109606: ARRAY
109607: PPUSH
109608: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
109612: LD_VAR 0 2
109616: PUSH
109617: LD_INT 1
109619: ARRAY
109620: PPUSH
109621: CALL_OW 65
// end ; 5 .. 7 :
109625: GO 109649
109627: LD_INT 5
109629: DOUBLE
109630: GREATEREQUAL
109631: IFFALSE 109639
109633: LD_INT 7
109635: DOUBLE
109636: LESSEQUAL
109637: IFTRUE 109641
109639: GO 109648
109641: POP
// StreamSibBomb ; end ;
109642: CALL 105830 0 0
109646: GO 109649
109648: POP
// end ;
109649: PPOPN 3
109651: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
109652: LD_EXP 126
109656: IFFALSE 109664
109658: PUSH
109659: LD_EXP 176
109663: AND
109664: IFFALSE 109820
109666: GO 109668
109668: DISABLE
109669: LD_INT 0
109671: PPUSH
109672: PPUSH
109673: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
109674: LD_ADDR_VAR 0 2
109678: PUSH
109679: LD_INT 81
109681: PUSH
109682: LD_OWVAR 2
109686: PUSH
109687: EMPTY
109688: LIST
109689: LIST
109690: PUSH
109691: LD_INT 2
109693: PUSH
109694: LD_INT 21
109696: PUSH
109697: LD_INT 1
109699: PUSH
109700: EMPTY
109701: LIST
109702: LIST
109703: PUSH
109704: LD_INT 21
109706: PUSH
109707: LD_INT 2
109709: PUSH
109710: EMPTY
109711: LIST
109712: LIST
109713: PUSH
109714: EMPTY
109715: LIST
109716: LIST
109717: LIST
109718: PUSH
109719: EMPTY
109720: LIST
109721: LIST
109722: PPUSH
109723: CALL_OW 69
109727: ST_TO_ADDR
// if not tmp then
109728: LD_VAR 0 2
109732: NOT
109733: IFFALSE 109737
// exit ;
109735: GO 109820
// p := 0 ;
109737: LD_ADDR_VAR 0 3
109741: PUSH
109742: LD_INT 0
109744: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
109745: LD_INT 35
109747: PPUSH
109748: CALL_OW 67
// p := p + 1 ;
109752: LD_ADDR_VAR 0 3
109756: PUSH
109757: LD_VAR 0 3
109761: PUSH
109762: LD_INT 1
109764: PLUS
109765: ST_TO_ADDR
// for i in tmp do
109766: LD_ADDR_VAR 0 1
109770: PUSH
109771: LD_VAR 0 2
109775: PUSH
109776: FOR_IN
109777: IFFALSE 109808
// if GetLives ( i ) < 1000 then
109779: LD_VAR 0 1
109783: PPUSH
109784: CALL_OW 256
109788: PUSH
109789: LD_INT 1000
109791: LESS
109792: IFFALSE 109806
// SetLives ( i , 1000 ) ;
109794: LD_VAR 0 1
109798: PPUSH
109799: LD_INT 1000
109801: PPUSH
109802: CALL_OW 234
109806: GO 109776
109808: POP
109809: POP
// until p > 20 ;
109810: LD_VAR 0 3
109814: PUSH
109815: LD_INT 20
109817: GREATER
109818: IFFALSE 109745
// end ;
109820: PPOPN 3
109822: END
// every 0 0$1 trigger StreamModeActive and sTime do
109823: LD_EXP 126
109827: IFFALSE 109835
109829: PUSH
109830: LD_EXP 177
109834: AND
109835: IFFALSE 109870
109837: GO 109839
109839: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
109840: LD_INT 28
109842: PPUSH
109843: LD_OWVAR 2
109847: PPUSH
109848: LD_INT 2
109850: PPUSH
109851: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
109855: LD_INT 30
109857: PPUSH
109858: LD_OWVAR 2
109862: PPUSH
109863: LD_INT 2
109865: PPUSH
109866: CALL_OW 322
// end ;
109870: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
109871: LD_EXP 126
109875: IFFALSE 109883
109877: PUSH
109878: LD_EXP 178
109882: AND
109883: IFFALSE 110004
109885: GO 109887
109887: DISABLE
109888: LD_INT 0
109890: PPUSH
109891: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
109892: LD_ADDR_VAR 0 2
109896: PUSH
109897: LD_INT 22
109899: PUSH
109900: LD_OWVAR 2
109904: PUSH
109905: EMPTY
109906: LIST
109907: LIST
109908: PUSH
109909: LD_INT 21
109911: PUSH
109912: LD_INT 1
109914: PUSH
109915: EMPTY
109916: LIST
109917: LIST
109918: PUSH
109919: LD_INT 3
109921: PUSH
109922: LD_INT 23
109924: PUSH
109925: LD_INT 0
109927: PUSH
109928: EMPTY
109929: LIST
109930: LIST
109931: PUSH
109932: EMPTY
109933: LIST
109934: LIST
109935: PUSH
109936: EMPTY
109937: LIST
109938: LIST
109939: LIST
109940: PPUSH
109941: CALL_OW 69
109945: ST_TO_ADDR
// if not tmp then
109946: LD_VAR 0 2
109950: NOT
109951: IFFALSE 109955
// exit ;
109953: GO 110004
// for i in tmp do
109955: LD_ADDR_VAR 0 1
109959: PUSH
109960: LD_VAR 0 2
109964: PUSH
109965: FOR_IN
109966: IFFALSE 110002
// begin if Crawls ( i ) then
109968: LD_VAR 0 1
109972: PPUSH
109973: CALL_OW 318
109977: IFFALSE 109988
// ComWalk ( i ) ;
109979: LD_VAR 0 1
109983: PPUSH
109984: CALL_OW 138
// SetClass ( i , 2 ) ;
109988: LD_VAR 0 1
109992: PPUSH
109993: LD_INT 2
109995: PPUSH
109996: CALL_OW 336
// end ;
110000: GO 109965
110002: POP
110003: POP
// end ;
110004: PPOPN 2
110006: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
110007: LD_EXP 126
110011: IFFALSE 110019
110013: PUSH
110014: LD_EXP 179
110018: AND
110019: IFFALSE 110309
110021: GO 110023
110023: DISABLE
110024: LD_INT 0
110026: PPUSH
110027: PPUSH
110028: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
110029: LD_OWVAR 2
110033: PPUSH
110034: LD_INT 9
110036: PPUSH
110037: LD_INT 1
110039: PPUSH
110040: LD_INT 1
110042: PPUSH
110043: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
110047: LD_INT 9
110049: PPUSH
110050: LD_OWVAR 2
110054: PPUSH
110055: CALL_OW 343
// uc_side := 9 ;
110059: LD_ADDR_OWVAR 20
110063: PUSH
110064: LD_INT 9
110066: ST_TO_ADDR
// uc_nation := 2 ;
110067: LD_ADDR_OWVAR 21
110071: PUSH
110072: LD_INT 2
110074: ST_TO_ADDR
// hc_name := Dark Warrior ;
110075: LD_ADDR_OWVAR 26
110079: PUSH
110080: LD_STRING Dark Warrior
110082: ST_TO_ADDR
// hc_gallery :=  ;
110083: LD_ADDR_OWVAR 33
110087: PUSH
110088: LD_STRING 
110090: ST_TO_ADDR
// hc_noskilllimit := true ;
110091: LD_ADDR_OWVAR 76
110095: PUSH
110096: LD_INT 1
110098: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
110099: LD_ADDR_OWVAR 31
110103: PUSH
110104: LD_INT 30
110106: PUSH
110107: LD_INT 30
110109: PUSH
110110: LD_INT 30
110112: PUSH
110113: LD_INT 30
110115: PUSH
110116: EMPTY
110117: LIST
110118: LIST
110119: LIST
110120: LIST
110121: ST_TO_ADDR
// un := CreateHuman ;
110122: LD_ADDR_VAR 0 3
110126: PUSH
110127: CALL_OW 44
110131: ST_TO_ADDR
// hc_noskilllimit := false ;
110132: LD_ADDR_OWVAR 76
110136: PUSH
110137: LD_INT 0
110139: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110140: LD_VAR 0 3
110144: PPUSH
110145: LD_INT 1
110147: PPUSH
110148: CALL_OW 51
// ToLua ( playRanger() ) ;
110152: LD_STRING playRanger()
110154: PPUSH
110155: CALL_OW 559
// p := 0 ;
110159: LD_ADDR_VAR 0 2
110163: PUSH
110164: LD_INT 0
110166: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
110167: LD_INT 35
110169: PPUSH
110170: CALL_OW 67
// p := p + 1 ;
110174: LD_ADDR_VAR 0 2
110178: PUSH
110179: LD_VAR 0 2
110183: PUSH
110184: LD_INT 1
110186: PLUS
110187: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
110188: LD_VAR 0 3
110192: PPUSH
110193: CALL_OW 256
110197: PUSH
110198: LD_INT 1000
110200: LESS
110201: IFFALSE 110215
// SetLives ( un , 1000 ) ;
110203: LD_VAR 0 3
110207: PPUSH
110208: LD_INT 1000
110210: PPUSH
110211: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
110215: LD_VAR 0 3
110219: PPUSH
110220: LD_INT 81
110222: PUSH
110223: LD_OWVAR 2
110227: PUSH
110228: EMPTY
110229: LIST
110230: LIST
110231: PUSH
110232: LD_INT 91
110234: PUSH
110235: LD_VAR 0 3
110239: PUSH
110240: LD_INT 30
110242: PUSH
110243: EMPTY
110244: LIST
110245: LIST
110246: LIST
110247: PUSH
110248: EMPTY
110249: LIST
110250: LIST
110251: PPUSH
110252: CALL_OW 69
110256: PPUSH
110257: LD_VAR 0 3
110261: PPUSH
110262: CALL_OW 74
110266: PPUSH
110267: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
110271: LD_VAR 0 2
110275: PUSH
110276: LD_INT 80
110278: GREATER
110279: IFTRUE 110292
110281: PUSH
110282: LD_VAR 0 3
110286: PPUSH
110287: CALL_OW 301
110291: OR
110292: IFFALSE 110167
// if un then
110294: LD_VAR 0 3
110298: IFFALSE 110309
// RemoveUnit ( un ) ;
110300: LD_VAR 0 3
110304: PPUSH
110305: CALL_OW 64
// end ;
110309: PPOPN 3
110311: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
110312: LD_EXP 180
110316: IFFALSE 110432
110318: GO 110320
110320: DISABLE
110321: LD_INT 0
110323: PPUSH
110324: PPUSH
110325: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
110326: LD_ADDR_VAR 0 2
110330: PUSH
110331: LD_INT 81
110333: PUSH
110334: LD_OWVAR 2
110338: PUSH
110339: EMPTY
110340: LIST
110341: LIST
110342: PUSH
110343: LD_INT 21
110345: PUSH
110346: LD_INT 1
110348: PUSH
110349: EMPTY
110350: LIST
110351: LIST
110352: PUSH
110353: EMPTY
110354: LIST
110355: LIST
110356: PPUSH
110357: CALL_OW 69
110361: ST_TO_ADDR
// ToLua ( playComputer() ) ;
110362: LD_STRING playComputer()
110364: PPUSH
110365: CALL_OW 559
// if not tmp then
110369: LD_VAR 0 2
110373: NOT
110374: IFFALSE 110378
// exit ;
110376: GO 110432
// for i in tmp do
110378: LD_ADDR_VAR 0 1
110382: PUSH
110383: LD_VAR 0 2
110387: PUSH
110388: FOR_IN
110389: IFFALSE 110430
// for j := 1 to 4 do
110391: LD_ADDR_VAR 0 3
110395: PUSH
110396: DOUBLE
110397: LD_INT 1
110399: DEC
110400: ST_TO_ADDR
110401: LD_INT 4
110403: PUSH
110404: FOR_TO
110405: IFFALSE 110426
// SetSkill ( i , j , 10 ) ;
110407: LD_VAR 0 1
110411: PPUSH
110412: LD_VAR 0 3
110416: PPUSH
110417: LD_INT 10
110419: PPUSH
110420: CALL_OW 237
110424: GO 110404
110426: POP
110427: POP
110428: GO 110388
110430: POP
110431: POP
// end ;
110432: PPOPN 3
110434: END
// every 0 0$1 trigger s30 do var i , tmp ;
110435: LD_EXP 181
110439: IFFALSE 110508
110441: GO 110443
110443: DISABLE
110444: LD_INT 0
110446: PPUSH
110447: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
110448: LD_ADDR_VAR 0 2
110452: PUSH
110453: LD_INT 22
110455: PUSH
110456: LD_OWVAR 2
110460: PUSH
110461: EMPTY
110462: LIST
110463: LIST
110464: PPUSH
110465: CALL_OW 69
110469: ST_TO_ADDR
// if not tmp then
110470: LD_VAR 0 2
110474: NOT
110475: IFFALSE 110479
// exit ;
110477: GO 110508
// for i in tmp do
110479: LD_ADDR_VAR 0 1
110483: PUSH
110484: LD_VAR 0 2
110488: PUSH
110489: FOR_IN
110490: IFFALSE 110506
// SetLives ( i , 300 ) ;
110492: LD_VAR 0 1
110496: PPUSH
110497: LD_INT 300
110499: PPUSH
110500: CALL_OW 234
110504: GO 110489
110506: POP
110507: POP
// end ;
110508: PPOPN 2
110510: END
// every 0 0$1 trigger s60 do var i , tmp ;
110511: LD_EXP 182
110515: IFFALSE 110584
110517: GO 110519
110519: DISABLE
110520: LD_INT 0
110522: PPUSH
110523: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
110524: LD_ADDR_VAR 0 2
110528: PUSH
110529: LD_INT 22
110531: PUSH
110532: LD_OWVAR 2
110536: PUSH
110537: EMPTY
110538: LIST
110539: LIST
110540: PPUSH
110541: CALL_OW 69
110545: ST_TO_ADDR
// if not tmp then
110546: LD_VAR 0 2
110550: NOT
110551: IFFALSE 110555
// exit ;
110553: GO 110584
// for i in tmp do
110555: LD_ADDR_VAR 0 1
110559: PUSH
110560: LD_VAR 0 2
110564: PUSH
110565: FOR_IN
110566: IFFALSE 110582
// SetLives ( i , 600 ) ;
110568: LD_VAR 0 1
110572: PPUSH
110573: LD_INT 600
110575: PPUSH
110576: CALL_OW 234
110580: GO 110565
110582: POP
110583: POP
// end ;
110584: PPOPN 2
110586: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
110587: LD_INT 0
110589: PPUSH
// case cmd of 301 :
110590: LD_VAR 0 1
110594: PUSH
110595: LD_INT 301
110597: DOUBLE
110598: EQUAL
110599: IFTRUE 110603
110601: GO 110635
110603: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
110604: LD_VAR 0 6
110608: PPUSH
110609: LD_VAR 0 7
110613: PPUSH
110614: LD_VAR 0 8
110618: PPUSH
110619: LD_VAR 0 4
110623: PPUSH
110624: LD_VAR 0 5
110628: PPUSH
110629: CALL 111848 0 5
110633: GO 110756
110635: LD_INT 302
110637: DOUBLE
110638: EQUAL
110639: IFTRUE 110643
110641: GO 110680
110643: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
110644: LD_VAR 0 6
110648: PPUSH
110649: LD_VAR 0 7
110653: PPUSH
110654: LD_VAR 0 8
110658: PPUSH
110659: LD_VAR 0 9
110663: PPUSH
110664: LD_VAR 0 4
110668: PPUSH
110669: LD_VAR 0 5
110673: PPUSH
110674: CALL 111939 0 6
110678: GO 110756
110680: LD_INT 303
110682: DOUBLE
110683: EQUAL
110684: IFTRUE 110688
110686: GO 110725
110688: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
110689: LD_VAR 0 6
110693: PPUSH
110694: LD_VAR 0 7
110698: PPUSH
110699: LD_VAR 0 8
110703: PPUSH
110704: LD_VAR 0 9
110708: PPUSH
110709: LD_VAR 0 4
110713: PPUSH
110714: LD_VAR 0 5
110718: PPUSH
110719: CALL 110761 0 6
110723: GO 110756
110725: LD_INT 304
110727: DOUBLE
110728: EQUAL
110729: IFTRUE 110733
110731: GO 110755
110733: POP
// hHackTeleport ( unit , x , y ) ; end ;
110734: LD_VAR 0 2
110738: PPUSH
110739: LD_VAR 0 4
110743: PPUSH
110744: LD_VAR 0 5
110748: PPUSH
110749: CALL 112532 0 3
110753: GO 110756
110755: POP
// end ;
110756: LD_VAR 0 12
110760: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
110761: LD_INT 0
110763: PPUSH
110764: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
110765: LD_VAR 0 1
110769: PUSH
110770: LD_INT 1
110772: LESS
110773: IFTRUE 110785
110775: PUSH
110776: LD_VAR 0 1
110780: PUSH
110781: LD_INT 3
110783: GREATER
110784: OR
110785: IFTRUE 110803
110787: PUSH
110788: LD_VAR 0 5
110792: PPUSH
110793: LD_VAR 0 6
110797: PPUSH
110798: CALL_OW 428
110802: OR
110803: IFFALSE 110807
// exit ;
110805: GO 111535
// uc_side := your_side ;
110807: LD_ADDR_OWVAR 20
110811: PUSH
110812: LD_OWVAR 2
110816: ST_TO_ADDR
// uc_nation := nation ;
110817: LD_ADDR_OWVAR 21
110821: PUSH
110822: LD_VAR 0 1
110826: ST_TO_ADDR
// bc_level = 1 ;
110827: LD_ADDR_OWVAR 43
110831: PUSH
110832: LD_INT 1
110834: ST_TO_ADDR
// case btype of 1 :
110835: LD_VAR 0 2
110839: PUSH
110840: LD_INT 1
110842: DOUBLE
110843: EQUAL
110844: IFTRUE 110848
110846: GO 110859
110848: POP
// bc_type := b_depot ; 2 :
110849: LD_ADDR_OWVAR 42
110853: PUSH
110854: LD_INT 0
110856: ST_TO_ADDR
110857: GO 111479
110859: LD_INT 2
110861: DOUBLE
110862: EQUAL
110863: IFTRUE 110867
110865: GO 110878
110867: POP
// bc_type := b_warehouse ; 3 :
110868: LD_ADDR_OWVAR 42
110872: PUSH
110873: LD_INT 1
110875: ST_TO_ADDR
110876: GO 111479
110878: LD_INT 3
110880: DOUBLE
110881: EQUAL
110882: IFTRUE 110886
110884: GO 110897
110886: POP
// bc_type := b_lab ; 4 .. 9 :
110887: LD_ADDR_OWVAR 42
110891: PUSH
110892: LD_INT 6
110894: ST_TO_ADDR
110895: GO 111479
110897: LD_INT 4
110899: DOUBLE
110900: GREATEREQUAL
110901: IFFALSE 110909
110903: LD_INT 9
110905: DOUBLE
110906: LESSEQUAL
110907: IFTRUE 110911
110909: GO 110971
110911: POP
// begin bc_type := b_lab_half ;
110912: LD_ADDR_OWVAR 42
110916: PUSH
110917: LD_INT 7
110919: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
110920: LD_ADDR_OWVAR 44
110924: PUSH
110925: LD_INT 10
110927: PUSH
110928: LD_INT 11
110930: PUSH
110931: LD_INT 12
110933: PUSH
110934: LD_INT 15
110936: PUSH
110937: LD_INT 14
110939: PUSH
110940: LD_INT 13
110942: PUSH
110943: EMPTY
110944: LIST
110945: LIST
110946: LIST
110947: LIST
110948: LIST
110949: LIST
110950: PUSH
110951: LD_VAR 0 2
110955: PUSH
110956: LD_INT 3
110958: MINUS
110959: ARRAY
110960: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
110961: LD_ADDR_OWVAR 45
110965: PUSH
110966: LD_INT 9
110968: ST_TO_ADDR
// end ; 10 .. 13 :
110969: GO 111479
110971: LD_INT 10
110973: DOUBLE
110974: GREATEREQUAL
110975: IFFALSE 110983
110977: LD_INT 13
110979: DOUBLE
110980: LESSEQUAL
110981: IFTRUE 110985
110983: GO 111062
110985: POP
// begin bc_type := b_lab_full ;
110986: LD_ADDR_OWVAR 42
110990: PUSH
110991: LD_INT 8
110993: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
110994: LD_ADDR_OWVAR 44
110998: PUSH
110999: LD_INT 10
111001: PUSH
111002: LD_INT 12
111004: PUSH
111005: LD_INT 14
111007: PUSH
111008: LD_INT 13
111010: PUSH
111011: EMPTY
111012: LIST
111013: LIST
111014: LIST
111015: LIST
111016: PUSH
111017: LD_VAR 0 2
111021: PUSH
111022: LD_INT 9
111024: MINUS
111025: ARRAY
111026: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
111027: LD_ADDR_OWVAR 45
111031: PUSH
111032: LD_INT 11
111034: PUSH
111035: LD_INT 15
111037: PUSH
111038: LD_INT 12
111040: PUSH
111041: LD_INT 15
111043: PUSH
111044: EMPTY
111045: LIST
111046: LIST
111047: LIST
111048: LIST
111049: PUSH
111050: LD_VAR 0 2
111054: PUSH
111055: LD_INT 9
111057: MINUS
111058: ARRAY
111059: ST_TO_ADDR
// end ; 14 :
111060: GO 111479
111062: LD_INT 14
111064: DOUBLE
111065: EQUAL
111066: IFTRUE 111070
111068: GO 111081
111070: POP
// bc_type := b_workshop ; 15 :
111071: LD_ADDR_OWVAR 42
111075: PUSH
111076: LD_INT 2
111078: ST_TO_ADDR
111079: GO 111479
111081: LD_INT 15
111083: DOUBLE
111084: EQUAL
111085: IFTRUE 111089
111087: GO 111100
111089: POP
// bc_type := b_factory ; 16 :
111090: LD_ADDR_OWVAR 42
111094: PUSH
111095: LD_INT 3
111097: ST_TO_ADDR
111098: GO 111479
111100: LD_INT 16
111102: DOUBLE
111103: EQUAL
111104: IFTRUE 111108
111106: GO 111119
111108: POP
// bc_type := b_ext_gun ; 17 :
111109: LD_ADDR_OWVAR 42
111113: PUSH
111114: LD_INT 17
111116: ST_TO_ADDR
111117: GO 111479
111119: LD_INT 17
111121: DOUBLE
111122: EQUAL
111123: IFTRUE 111127
111125: GO 111155
111127: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
111128: LD_ADDR_OWVAR 42
111132: PUSH
111133: LD_INT 19
111135: PUSH
111136: LD_INT 23
111138: PUSH
111139: LD_INT 19
111141: PUSH
111142: EMPTY
111143: LIST
111144: LIST
111145: LIST
111146: PUSH
111147: LD_VAR 0 1
111151: ARRAY
111152: ST_TO_ADDR
111153: GO 111479
111155: LD_INT 18
111157: DOUBLE
111158: EQUAL
111159: IFTRUE 111163
111161: GO 111174
111163: POP
// bc_type := b_ext_radar ; 19 :
111164: LD_ADDR_OWVAR 42
111168: PUSH
111169: LD_INT 20
111171: ST_TO_ADDR
111172: GO 111479
111174: LD_INT 19
111176: DOUBLE
111177: EQUAL
111178: IFTRUE 111182
111180: GO 111193
111182: POP
// bc_type := b_ext_radio ; 20 :
111183: LD_ADDR_OWVAR 42
111187: PUSH
111188: LD_INT 22
111190: ST_TO_ADDR
111191: GO 111479
111193: LD_INT 20
111195: DOUBLE
111196: EQUAL
111197: IFTRUE 111201
111199: GO 111212
111201: POP
// bc_type := b_ext_siberium ; 21 :
111202: LD_ADDR_OWVAR 42
111206: PUSH
111207: LD_INT 21
111209: ST_TO_ADDR
111210: GO 111479
111212: LD_INT 21
111214: DOUBLE
111215: EQUAL
111216: IFTRUE 111220
111218: GO 111231
111220: POP
// bc_type := b_ext_computer ; 22 :
111221: LD_ADDR_OWVAR 42
111225: PUSH
111226: LD_INT 24
111228: ST_TO_ADDR
111229: GO 111479
111231: LD_INT 22
111233: DOUBLE
111234: EQUAL
111235: IFTRUE 111239
111237: GO 111250
111239: POP
// bc_type := b_ext_track ; 23 :
111240: LD_ADDR_OWVAR 42
111244: PUSH
111245: LD_INT 16
111247: ST_TO_ADDR
111248: GO 111479
111250: LD_INT 23
111252: DOUBLE
111253: EQUAL
111254: IFTRUE 111258
111256: GO 111269
111258: POP
// bc_type := b_ext_laser ; 24 :
111259: LD_ADDR_OWVAR 42
111263: PUSH
111264: LD_INT 25
111266: ST_TO_ADDR
111267: GO 111479
111269: LD_INT 24
111271: DOUBLE
111272: EQUAL
111273: IFTRUE 111277
111275: GO 111288
111277: POP
// bc_type := b_control_tower ; 25 :
111278: LD_ADDR_OWVAR 42
111282: PUSH
111283: LD_INT 36
111285: ST_TO_ADDR
111286: GO 111479
111288: LD_INT 25
111290: DOUBLE
111291: EQUAL
111292: IFTRUE 111296
111294: GO 111307
111296: POP
// bc_type := b_breastwork ; 26 :
111297: LD_ADDR_OWVAR 42
111301: PUSH
111302: LD_INT 31
111304: ST_TO_ADDR
111305: GO 111479
111307: LD_INT 26
111309: DOUBLE
111310: EQUAL
111311: IFTRUE 111315
111313: GO 111326
111315: POP
// bc_type := b_bunker ; 27 :
111316: LD_ADDR_OWVAR 42
111320: PUSH
111321: LD_INT 32
111323: ST_TO_ADDR
111324: GO 111479
111326: LD_INT 27
111328: DOUBLE
111329: EQUAL
111330: IFTRUE 111334
111332: GO 111345
111334: POP
// bc_type := b_turret ; 28 :
111335: LD_ADDR_OWVAR 42
111339: PUSH
111340: LD_INT 33
111342: ST_TO_ADDR
111343: GO 111479
111345: LD_INT 28
111347: DOUBLE
111348: EQUAL
111349: IFTRUE 111353
111351: GO 111364
111353: POP
// bc_type := b_armoury ; 29 :
111354: LD_ADDR_OWVAR 42
111358: PUSH
111359: LD_INT 4
111361: ST_TO_ADDR
111362: GO 111479
111364: LD_INT 29
111366: DOUBLE
111367: EQUAL
111368: IFTRUE 111372
111370: GO 111383
111372: POP
// bc_type := b_barracks ; 30 :
111373: LD_ADDR_OWVAR 42
111377: PUSH
111378: LD_INT 5
111380: ST_TO_ADDR
111381: GO 111479
111383: LD_INT 30
111385: DOUBLE
111386: EQUAL
111387: IFTRUE 111391
111389: GO 111402
111391: POP
// bc_type := b_solar_power ; 31 :
111392: LD_ADDR_OWVAR 42
111396: PUSH
111397: LD_INT 27
111399: ST_TO_ADDR
111400: GO 111479
111402: LD_INT 31
111404: DOUBLE
111405: EQUAL
111406: IFTRUE 111410
111408: GO 111421
111410: POP
// bc_type := b_oil_power ; 32 :
111411: LD_ADDR_OWVAR 42
111415: PUSH
111416: LD_INT 26
111418: ST_TO_ADDR
111419: GO 111479
111421: LD_INT 32
111423: DOUBLE
111424: EQUAL
111425: IFTRUE 111429
111427: GO 111440
111429: POP
// bc_type := b_siberite_power ; 33 :
111430: LD_ADDR_OWVAR 42
111434: PUSH
111435: LD_INT 28
111437: ST_TO_ADDR
111438: GO 111479
111440: LD_INT 33
111442: DOUBLE
111443: EQUAL
111444: IFTRUE 111448
111446: GO 111459
111448: POP
// bc_type := b_oil_mine ; 34 :
111449: LD_ADDR_OWVAR 42
111453: PUSH
111454: LD_INT 29
111456: ST_TO_ADDR
111457: GO 111479
111459: LD_INT 34
111461: DOUBLE
111462: EQUAL
111463: IFTRUE 111467
111465: GO 111478
111467: POP
// bc_type := b_siberite_mine ; end ;
111468: LD_ADDR_OWVAR 42
111472: PUSH
111473: LD_INT 30
111475: ST_TO_ADDR
111476: GO 111479
111478: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
111479: LD_ADDR_VAR 0 8
111483: PUSH
111484: LD_VAR 0 5
111488: PPUSH
111489: LD_VAR 0 6
111493: PPUSH
111494: LD_VAR 0 3
111498: PPUSH
111499: CALL_OW 47
111503: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
111504: LD_OWVAR 42
111508: PUSH
111509: LD_INT 32
111511: PUSH
111512: LD_INT 33
111514: PUSH
111515: EMPTY
111516: LIST
111517: LIST
111518: IN
111519: IFFALSE 111535
// PlaceWeaponTurret ( b , weapon ) ;
111521: LD_VAR 0 8
111525: PPUSH
111526: LD_VAR 0 4
111530: PPUSH
111531: CALL_OW 431
// end ;
111535: LD_VAR 0 7
111539: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
111540: LD_INT 0
111542: PPUSH
111543: PPUSH
111544: PPUSH
111545: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
111546: LD_ADDR_VAR 0 4
111550: PUSH
111551: LD_INT 22
111553: PUSH
111554: LD_OWVAR 2
111558: PUSH
111559: EMPTY
111560: LIST
111561: LIST
111562: PUSH
111563: LD_INT 2
111565: PUSH
111566: LD_INT 30
111568: PUSH
111569: LD_INT 0
111571: PUSH
111572: EMPTY
111573: LIST
111574: LIST
111575: PUSH
111576: LD_INT 30
111578: PUSH
111579: LD_INT 1
111581: PUSH
111582: EMPTY
111583: LIST
111584: LIST
111585: PUSH
111586: EMPTY
111587: LIST
111588: LIST
111589: LIST
111590: PUSH
111591: EMPTY
111592: LIST
111593: LIST
111594: PPUSH
111595: CALL_OW 69
111599: ST_TO_ADDR
// if not tmp then
111600: LD_VAR 0 4
111604: NOT
111605: IFFALSE 111609
// exit ;
111607: GO 111668
// for i in tmp do
111609: LD_ADDR_VAR 0 2
111613: PUSH
111614: LD_VAR 0 4
111618: PUSH
111619: FOR_IN
111620: IFFALSE 111666
// for j = 1 to 3 do
111622: LD_ADDR_VAR 0 3
111626: PUSH
111627: DOUBLE
111628: LD_INT 1
111630: DEC
111631: ST_TO_ADDR
111632: LD_INT 3
111634: PUSH
111635: FOR_TO
111636: IFFALSE 111662
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
111638: LD_VAR 0 2
111642: PPUSH
111643: CALL_OW 274
111647: PPUSH
111648: LD_VAR 0 3
111652: PPUSH
111653: LD_INT 99999
111655: PPUSH
111656: CALL_OW 277
111660: GO 111635
111662: POP
111663: POP
111664: GO 111619
111666: POP
111667: POP
// end ;
111668: LD_VAR 0 1
111672: RET
// export function hHackSetLevel10 ; var i , j ; begin
111673: LD_INT 0
111675: PPUSH
111676: PPUSH
111677: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
111678: LD_ADDR_VAR 0 2
111682: PUSH
111683: LD_INT 21
111685: PUSH
111686: LD_INT 1
111688: PUSH
111689: EMPTY
111690: LIST
111691: LIST
111692: PPUSH
111693: CALL_OW 69
111697: PUSH
111698: FOR_IN
111699: IFFALSE 111751
// if IsSelected ( i ) then
111701: LD_VAR 0 2
111705: PPUSH
111706: CALL_OW 306
111710: IFFALSE 111749
// begin for j := 1 to 4 do
111712: LD_ADDR_VAR 0 3
111716: PUSH
111717: DOUBLE
111718: LD_INT 1
111720: DEC
111721: ST_TO_ADDR
111722: LD_INT 4
111724: PUSH
111725: FOR_TO
111726: IFFALSE 111747
// SetSkill ( i , j , 10 ) ;
111728: LD_VAR 0 2
111732: PPUSH
111733: LD_VAR 0 3
111737: PPUSH
111738: LD_INT 10
111740: PPUSH
111741: CALL_OW 237
111745: GO 111725
111747: POP
111748: POP
// end ;
111749: GO 111698
111751: POP
111752: POP
// end ;
111753: LD_VAR 0 1
111757: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
111758: LD_INT 0
111760: PPUSH
111761: PPUSH
111762: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
111763: LD_ADDR_VAR 0 2
111767: PUSH
111768: LD_INT 22
111770: PUSH
111771: LD_OWVAR 2
111775: PUSH
111776: EMPTY
111777: LIST
111778: LIST
111779: PUSH
111780: LD_INT 21
111782: PUSH
111783: LD_INT 1
111785: PUSH
111786: EMPTY
111787: LIST
111788: LIST
111789: PUSH
111790: EMPTY
111791: LIST
111792: LIST
111793: PPUSH
111794: CALL_OW 69
111798: PUSH
111799: FOR_IN
111800: IFFALSE 111841
// begin for j := 1 to 4 do
111802: LD_ADDR_VAR 0 3
111806: PUSH
111807: DOUBLE
111808: LD_INT 1
111810: DEC
111811: ST_TO_ADDR
111812: LD_INT 4
111814: PUSH
111815: FOR_TO
111816: IFFALSE 111837
// SetSkill ( i , j , 10 ) ;
111818: LD_VAR 0 2
111822: PPUSH
111823: LD_VAR 0 3
111827: PPUSH
111828: LD_INT 10
111830: PPUSH
111831: CALL_OW 237
111835: GO 111815
111837: POP
111838: POP
// end ;
111839: GO 111799
111841: POP
111842: POP
// end ;
111843: LD_VAR 0 1
111847: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
111848: LD_INT 0
111850: PPUSH
// uc_side := your_side ;
111851: LD_ADDR_OWVAR 20
111855: PUSH
111856: LD_OWVAR 2
111860: ST_TO_ADDR
// uc_nation := nation ;
111861: LD_ADDR_OWVAR 21
111865: PUSH
111866: LD_VAR 0 1
111870: ST_TO_ADDR
// InitHc ;
111871: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
111875: LD_INT 0
111877: PPUSH
111878: LD_VAR 0 2
111882: PPUSH
111883: LD_VAR 0 3
111887: PPUSH
111888: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
111892: LD_VAR 0 4
111896: PPUSH
111897: LD_VAR 0 5
111901: PPUSH
111902: CALL_OW 428
111906: PUSH
111907: LD_INT 0
111909: EQUAL
111910: IFFALSE 111934
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
111912: CALL_OW 44
111916: PPUSH
111917: LD_VAR 0 4
111921: PPUSH
111922: LD_VAR 0 5
111926: PPUSH
111927: LD_INT 1
111929: PPUSH
111930: CALL_OW 48
// end ;
111934: LD_VAR 0 6
111938: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
111939: LD_INT 0
111941: PPUSH
111942: PPUSH
// uc_side := your_side ;
111943: LD_ADDR_OWVAR 20
111947: PUSH
111948: LD_OWVAR 2
111952: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
111953: LD_VAR 0 1
111957: PUSH
111958: LD_INT 1
111960: PUSH
111961: LD_INT 2
111963: PUSH
111964: LD_INT 3
111966: PUSH
111967: LD_INT 4
111969: PUSH
111970: LD_INT 5
111972: PUSH
111973: EMPTY
111974: LIST
111975: LIST
111976: LIST
111977: LIST
111978: LIST
111979: IN
111980: IFFALSE 111992
// uc_nation := nation_american else
111982: LD_ADDR_OWVAR 21
111986: PUSH
111987: LD_INT 1
111989: ST_TO_ADDR
111990: GO 112035
// if chassis in [ 11 , 12 , 13 , 14 ] then
111992: LD_VAR 0 1
111996: PUSH
111997: LD_INT 11
111999: PUSH
112000: LD_INT 12
112002: PUSH
112003: LD_INT 13
112005: PUSH
112006: LD_INT 14
112008: PUSH
112009: EMPTY
112010: LIST
112011: LIST
112012: LIST
112013: LIST
112014: IN
112015: IFFALSE 112027
// uc_nation := nation_arabian else
112017: LD_ADDR_OWVAR 21
112021: PUSH
112022: LD_INT 2
112024: ST_TO_ADDR
112025: GO 112035
// uc_nation := nation_russian ;
112027: LD_ADDR_OWVAR 21
112031: PUSH
112032: LD_INT 3
112034: ST_TO_ADDR
// vc_chassis := chassis ;
112035: LD_ADDR_OWVAR 37
112039: PUSH
112040: LD_VAR 0 1
112044: ST_TO_ADDR
// vc_engine := engine ;
112045: LD_ADDR_OWVAR 39
112049: PUSH
112050: LD_VAR 0 2
112054: ST_TO_ADDR
// vc_control := control ;
112055: LD_ADDR_OWVAR 38
112059: PUSH
112060: LD_VAR 0 3
112064: ST_TO_ADDR
// vc_weapon := weapon ;
112065: LD_ADDR_OWVAR 40
112069: PUSH
112070: LD_VAR 0 4
112074: ST_TO_ADDR
// un := CreateVehicle ;
112075: LD_ADDR_VAR 0 8
112079: PUSH
112080: CALL_OW 45
112084: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
112085: LD_VAR 0 8
112089: PPUSH
112090: LD_INT 0
112092: PPUSH
112093: LD_INT 5
112095: PPUSH
112096: CALL_OW 12
112100: PPUSH
112101: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
112105: LD_VAR 0 8
112109: PPUSH
112110: LD_VAR 0 5
112114: PPUSH
112115: LD_VAR 0 6
112119: PPUSH
112120: LD_INT 1
112122: PPUSH
112123: CALL_OW 48
// end ;
112127: LD_VAR 0 7
112131: RET
// export hInvincible ; every 1 do
112132: GO 112134
112134: DISABLE
// hInvincible := [ ] ;
112135: LD_ADDR_EXP 183
112139: PUSH
112140: EMPTY
112141: ST_TO_ADDR
112142: END
// every 10 do var i ;
112143: GO 112145
112145: DISABLE
112146: LD_INT 0
112148: PPUSH
// begin enable ;
112149: ENABLE
// if not hInvincible then
112150: LD_EXP 183
112154: NOT
112155: IFFALSE 112159
// exit ;
112157: GO 112203
// for i in hInvincible do
112159: LD_ADDR_VAR 0 1
112163: PUSH
112164: LD_EXP 183
112168: PUSH
112169: FOR_IN
112170: IFFALSE 112201
// if GetLives ( i ) < 1000 then
112172: LD_VAR 0 1
112176: PPUSH
112177: CALL_OW 256
112181: PUSH
112182: LD_INT 1000
112184: LESS
112185: IFFALSE 112199
// SetLives ( i , 1000 ) ;
112187: LD_VAR 0 1
112191: PPUSH
112192: LD_INT 1000
112194: PPUSH
112195: CALL_OW 234
112199: GO 112169
112201: POP
112202: POP
// end ;
112203: PPOPN 1
112205: END
// export function hHackInvincible ; var i ; begin
112206: LD_INT 0
112208: PPUSH
112209: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
112210: LD_ADDR_VAR 0 2
112214: PUSH
112215: LD_INT 2
112217: PUSH
112218: LD_INT 21
112220: PUSH
112221: LD_INT 1
112223: PUSH
112224: EMPTY
112225: LIST
112226: LIST
112227: PUSH
112228: LD_INT 21
112230: PUSH
112231: LD_INT 2
112233: PUSH
112234: EMPTY
112235: LIST
112236: LIST
112237: PUSH
112238: EMPTY
112239: LIST
112240: LIST
112241: LIST
112242: PPUSH
112243: CALL_OW 69
112247: PUSH
112248: FOR_IN
112249: IFFALSE 112310
// if IsSelected ( i ) then
112251: LD_VAR 0 2
112255: PPUSH
112256: CALL_OW 306
112260: IFFALSE 112308
// begin if i in hInvincible then
112262: LD_VAR 0 2
112266: PUSH
112267: LD_EXP 183
112271: IN
112272: IFFALSE 112292
// hInvincible := hInvincible diff i else
112274: LD_ADDR_EXP 183
112278: PUSH
112279: LD_EXP 183
112283: PUSH
112284: LD_VAR 0 2
112288: DIFF
112289: ST_TO_ADDR
112290: GO 112308
// hInvincible := hInvincible union i ;
112292: LD_ADDR_EXP 183
112296: PUSH
112297: LD_EXP 183
112301: PUSH
112302: LD_VAR 0 2
112306: UNION
112307: ST_TO_ADDR
// end ;
112308: GO 112248
112310: POP
112311: POP
// end ;
112312: LD_VAR 0 1
112316: RET
// export function hHackInvisible ; var i , j ; begin
112317: LD_INT 0
112319: PPUSH
112320: PPUSH
112321: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
112322: LD_ADDR_VAR 0 2
112326: PUSH
112327: LD_INT 21
112329: PUSH
112330: LD_INT 1
112332: PUSH
112333: EMPTY
112334: LIST
112335: LIST
112336: PPUSH
112337: CALL_OW 69
112341: PUSH
112342: FOR_IN
112343: IFFALSE 112367
// if IsSelected ( i ) then
112345: LD_VAR 0 2
112349: PPUSH
112350: CALL_OW 306
112354: IFFALSE 112365
// ComForceInvisible ( i ) ;
112356: LD_VAR 0 2
112360: PPUSH
112361: CALL_OW 496
112365: GO 112342
112367: POP
112368: POP
// end ;
112369: LD_VAR 0 1
112373: RET
// export function hHackChangeYourSide ; begin
112374: LD_INT 0
112376: PPUSH
// if your_side = 8 then
112377: LD_OWVAR 2
112381: PUSH
112382: LD_INT 8
112384: EQUAL
112385: IFFALSE 112397
// your_side := 0 else
112387: LD_ADDR_OWVAR 2
112391: PUSH
112392: LD_INT 0
112394: ST_TO_ADDR
112395: GO 112411
// your_side := your_side + 1 ;
112397: LD_ADDR_OWVAR 2
112401: PUSH
112402: LD_OWVAR 2
112406: PUSH
112407: LD_INT 1
112409: PLUS
112410: ST_TO_ADDR
// end ;
112411: LD_VAR 0 1
112415: RET
// export function hHackChangeUnitSide ; var i , j ; begin
112416: LD_INT 0
112418: PPUSH
112419: PPUSH
112420: PPUSH
// for i in all_units do
112421: LD_ADDR_VAR 0 2
112425: PUSH
112426: LD_OWVAR 3
112430: PUSH
112431: FOR_IN
112432: IFFALSE 112510
// if IsSelected ( i ) then
112434: LD_VAR 0 2
112438: PPUSH
112439: CALL_OW 306
112443: IFFALSE 112508
// begin j := GetSide ( i ) ;
112445: LD_ADDR_VAR 0 3
112449: PUSH
112450: LD_VAR 0 2
112454: PPUSH
112455: CALL_OW 255
112459: ST_TO_ADDR
// if j = 8 then
112460: LD_VAR 0 3
112464: PUSH
112465: LD_INT 8
112467: EQUAL
112468: IFFALSE 112480
// j := 0 else
112470: LD_ADDR_VAR 0 3
112474: PUSH
112475: LD_INT 0
112477: ST_TO_ADDR
112478: GO 112494
// j := j + 1 ;
112480: LD_ADDR_VAR 0 3
112484: PUSH
112485: LD_VAR 0 3
112489: PUSH
112490: LD_INT 1
112492: PLUS
112493: ST_TO_ADDR
// SetSide ( i , j ) ;
112494: LD_VAR 0 2
112498: PPUSH
112499: LD_VAR 0 3
112503: PPUSH
112504: CALL_OW 235
// end ;
112508: GO 112431
112510: POP
112511: POP
// end ;
112512: LD_VAR 0 1
112516: RET
// export function hHackFog ; begin
112517: LD_INT 0
112519: PPUSH
// FogOff ( true ) ;
112520: LD_INT 1
112522: PPUSH
112523: CALL_OW 344
// end ;
112527: LD_VAR 0 1
112531: RET
// export function hHackTeleport ( unit , x , y ) ; begin
112532: LD_INT 0
112534: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
112535: LD_VAR 0 1
112539: PPUSH
112540: LD_VAR 0 2
112544: PPUSH
112545: LD_VAR 0 3
112549: PPUSH
112550: LD_INT 1
112552: PPUSH
112553: LD_INT 1
112555: PPUSH
112556: CALL_OW 483
// CenterOnXY ( x , y ) ;
112560: LD_VAR 0 2
112564: PPUSH
112565: LD_VAR 0 3
112569: PPUSH
112570: CALL_OW 84
// end ;
112574: LD_VAR 0 4
112578: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
112579: LD_INT 0
112581: PPUSH
112582: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
112583: LD_VAR 0 1
112587: NOT
112588: IFTRUE 112607
112590: PUSH
112591: LD_VAR 0 2
112595: PPUSH
112596: LD_VAR 0 3
112600: PPUSH
112601: CALL_OW 488
112605: NOT
112606: OR
112607: IFTRUE 112642
112609: PUSH
112610: LD_VAR 0 1
112614: PPUSH
112615: CALL_OW 266
112619: PUSH
112620: LD_INT 3
112622: NONEQUAL
112623: IFFALSE 112641
112625: PUSH
112626: LD_VAR 0 1
112630: PPUSH
112631: CALL_OW 247
112635: PUSH
112636: LD_INT 1
112638: EQUAL
112639: NOT
112640: AND
112641: OR
112642: IFFALSE 112646
// exit ;
112644: GO 112928
// if GetType ( factory ) = unit_human then
112646: LD_VAR 0 1
112650: PPUSH
112651: CALL_OW 247
112655: PUSH
112656: LD_INT 1
112658: EQUAL
112659: IFFALSE 112676
// factory := IsInUnit ( factory ) ;
112661: LD_ADDR_VAR 0 1
112665: PUSH
112666: LD_VAR 0 1
112670: PPUSH
112671: CALL_OW 310
112675: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
112676: LD_VAR 0 1
112680: PPUSH
112681: CALL_OW 266
112685: PUSH
112686: LD_INT 3
112688: NONEQUAL
112689: IFFALSE 112693
// exit ;
112691: GO 112928
// for i := 1 to Count ( factoryWaypoints ) do
112693: LD_ADDR_VAR 0 5
112697: PUSH
112698: DOUBLE
112699: LD_INT 1
112701: DEC
112702: ST_TO_ADDR
112703: LD_EXP 184
112707: PPUSH
112708: CALL 56635 0 1
112712: PUSH
112713: FOR_TO
112714: IFFALSE 112876
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
112716: LD_VAR 0 2
112720: PPUSH
112721: LD_VAR 0 3
112725: PPUSH
112726: CALL_OW 428
112730: PUSH
112731: LD_EXP 184
112735: PUSH
112736: LD_VAR 0 5
112740: ARRAY
112741: PUSH
112742: LD_INT 2
112744: ARRAY
112745: EQUAL
112746: IFFALSE 112778
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
112748: LD_ADDR_EXP 184
112752: PUSH
112753: LD_EXP 184
112757: PPUSH
112758: LD_VAR 0 5
112762: PPUSH
112763: CALL_OW 3
112767: ST_TO_ADDR
// UpdateFactoryWaypoints ;
112768: CALL 112933 0 0
// exit ;
112772: POP
112773: POP
112774: GO 112928
// end else
112776: GO 112874
// if factory = factoryWaypoints [ i ] [ 2 ] then
112778: LD_VAR 0 1
112782: PUSH
112783: LD_EXP 184
112787: PUSH
112788: LD_VAR 0 5
112792: ARRAY
112793: PUSH
112794: LD_INT 2
112796: ARRAY
112797: EQUAL
112798: IFFALSE 112874
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
112800: LD_ADDR_EXP 184
112804: PUSH
112805: LD_EXP 184
112809: PPUSH
112810: LD_VAR 0 5
112814: PPUSH
112815: CALL_OW 3
112819: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
112820: LD_ADDR_EXP 184
112824: PUSH
112825: LD_EXP 184
112829: PPUSH
112830: LD_VAR 0 1
112834: PPUSH
112835: CALL_OW 255
112839: PUSH
112840: LD_VAR 0 1
112844: PUSH
112845: LD_VAR 0 2
112849: PUSH
112850: LD_VAR 0 3
112854: PUSH
112855: EMPTY
112856: LIST
112857: LIST
112858: LIST
112859: LIST
112860: PPUSH
112861: CALL 92601 0 2
112865: ST_TO_ADDR
// UpdateFactoryWaypoints ;
112866: CALL 112933 0 0
// exit ;
112870: POP
112871: POP
112872: GO 112928
// end ; end ;
112874: GO 112713
112876: POP
112877: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
112878: LD_ADDR_EXP 184
112882: PUSH
112883: LD_EXP 184
112887: PPUSH
112888: LD_VAR 0 1
112892: PPUSH
112893: CALL_OW 255
112897: PUSH
112898: LD_VAR 0 1
112902: PUSH
112903: LD_VAR 0 2
112907: PUSH
112908: LD_VAR 0 3
112912: PUSH
112913: EMPTY
112914: LIST
112915: LIST
112916: LIST
112917: LIST
112918: PPUSH
112919: CALL 92601 0 2
112923: ST_TO_ADDR
// UpdateFactoryWaypoints ;
112924: CALL 112933 0 0
// end ;
112928: LD_VAR 0 4
112932: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
112933: LD_INT 0
112935: PPUSH
112936: PPUSH
112937: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
112938: LD_STRING resetFactoryWaypoint();
112940: PPUSH
112941: CALL_OW 559
// if factoryWaypoints then
112945: LD_EXP 184
112949: IFFALSE 113070
// begin list := factoryWaypoints ;
112951: LD_ADDR_VAR 0 3
112955: PUSH
112956: LD_EXP 184
112960: ST_TO_ADDR
// for i := 1 to list do
112961: LD_ADDR_VAR 0 2
112965: PUSH
112966: DOUBLE
112967: LD_INT 1
112969: DEC
112970: ST_TO_ADDR
112971: LD_VAR 0 3
112975: PUSH
112976: FOR_TO
112977: IFFALSE 113068
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
112979: LD_STRING setFactoryWaypointXY(
112981: PUSH
112982: LD_VAR 0 3
112986: PUSH
112987: LD_VAR 0 2
112991: ARRAY
112992: PUSH
112993: LD_INT 1
112995: ARRAY
112996: STR
112997: PUSH
112998: LD_STRING ,
113000: STR
113001: PUSH
113002: LD_VAR 0 3
113006: PUSH
113007: LD_VAR 0 2
113011: ARRAY
113012: PUSH
113013: LD_INT 2
113015: ARRAY
113016: STR
113017: PUSH
113018: LD_STRING ,
113020: STR
113021: PUSH
113022: LD_VAR 0 3
113026: PUSH
113027: LD_VAR 0 2
113031: ARRAY
113032: PUSH
113033: LD_INT 3
113035: ARRAY
113036: STR
113037: PUSH
113038: LD_STRING ,
113040: STR
113041: PUSH
113042: LD_VAR 0 3
113046: PUSH
113047: LD_VAR 0 2
113051: ARRAY
113052: PUSH
113053: LD_INT 4
113055: ARRAY
113056: STR
113057: PUSH
113058: LD_STRING )
113060: STR
113061: PPUSH
113062: CALL_OW 559
113066: GO 112976
113068: POP
113069: POP
// end ; end ;
113070: LD_VAR 0 1
113074: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
113075: LD_INT 0
113077: PPUSH
// if HexInfo ( x , y ) = warehouse then
113078: LD_VAR 0 2
113082: PPUSH
113083: LD_VAR 0 3
113087: PPUSH
113088: CALL_OW 428
113092: PUSH
113093: LD_VAR 0 1
113097: EQUAL
113098: IFFALSE 113125
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
113100: LD_ADDR_EXP 186
113104: PUSH
113105: LD_EXP 186
113109: PPUSH
113110: LD_VAR 0 1
113114: PPUSH
113115: LD_INT 0
113117: PPUSH
113118: CALL_OW 1
113122: ST_TO_ADDR
113123: GO 113176
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
113125: LD_ADDR_EXP 186
113129: PUSH
113130: LD_EXP 186
113134: PPUSH
113135: LD_VAR 0 1
113139: PPUSH
113140: LD_VAR 0 1
113144: PPUSH
113145: CALL_OW 255
113149: PUSH
113150: LD_VAR 0 1
113154: PUSH
113155: LD_VAR 0 2
113159: PUSH
113160: LD_VAR 0 3
113164: PUSH
113165: EMPTY
113166: LIST
113167: LIST
113168: LIST
113169: LIST
113170: PPUSH
113171: CALL_OW 1
113175: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
113176: CALL 113185 0 0
// end ;
113180: LD_VAR 0 4
113184: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
113185: LD_INT 0
113187: PPUSH
113188: PPUSH
113189: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
113190: LD_STRING resetWarehouseGatheringPoints();
113192: PPUSH
113193: CALL_OW 559
// if warehouseGatheringPoints then
113197: LD_EXP 186
113201: IFFALSE 113327
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
113203: LD_ADDR_VAR 0 3
113207: PUSH
113208: LD_EXP 186
113212: PPUSH
113213: CALL 96535 0 1
113217: ST_TO_ADDR
// for i := 1 to list do
113218: LD_ADDR_VAR 0 2
113222: PUSH
113223: DOUBLE
113224: LD_INT 1
113226: DEC
113227: ST_TO_ADDR
113228: LD_VAR 0 3
113232: PUSH
113233: FOR_TO
113234: IFFALSE 113325
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
113236: LD_STRING setWarehouseGatheringPointXY(
113238: PUSH
113239: LD_VAR 0 3
113243: PUSH
113244: LD_VAR 0 2
113248: ARRAY
113249: PUSH
113250: LD_INT 1
113252: ARRAY
113253: STR
113254: PUSH
113255: LD_STRING ,
113257: STR
113258: PUSH
113259: LD_VAR 0 3
113263: PUSH
113264: LD_VAR 0 2
113268: ARRAY
113269: PUSH
113270: LD_INT 2
113272: ARRAY
113273: STR
113274: PUSH
113275: LD_STRING ,
113277: STR
113278: PUSH
113279: LD_VAR 0 3
113283: PUSH
113284: LD_VAR 0 2
113288: ARRAY
113289: PUSH
113290: LD_INT 3
113292: ARRAY
113293: STR
113294: PUSH
113295: LD_STRING ,
113297: STR
113298: PUSH
113299: LD_VAR 0 3
113303: PUSH
113304: LD_VAR 0 2
113308: ARRAY
113309: PUSH
113310: LD_INT 4
113312: ARRAY
113313: STR
113314: PUSH
113315: LD_STRING )
113317: STR
113318: PPUSH
113319: CALL_OW 559
113323: GO 113233
113325: POP
113326: POP
// end ; end ;
113327: LD_VAR 0 1
113331: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
113332: LD_EXP 186
113336: IFFALSE 114031
113338: GO 113340
113340: DISABLE
113341: LD_INT 0
113343: PPUSH
113344: PPUSH
113345: PPUSH
113346: PPUSH
113347: PPUSH
113348: PPUSH
113349: PPUSH
113350: PPUSH
113351: PPUSH
// begin enable ;
113352: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
113353: LD_ADDR_VAR 0 3
113357: PUSH
113358: LD_EXP 186
113362: PPUSH
113363: CALL 96535 0 1
113367: ST_TO_ADDR
// if not list then
113368: LD_VAR 0 3
113372: NOT
113373: IFFALSE 113377
// exit ;
113375: GO 114031
// for i := 1 to list do
113377: LD_ADDR_VAR 0 1
113381: PUSH
113382: DOUBLE
113383: LD_INT 1
113385: DEC
113386: ST_TO_ADDR
113387: LD_VAR 0 3
113391: PUSH
113392: FOR_TO
113393: IFFALSE 114029
// begin depot := list [ i ] [ 2 ] ;
113395: LD_ADDR_VAR 0 8
113399: PUSH
113400: LD_VAR 0 3
113404: PUSH
113405: LD_VAR 0 1
113409: ARRAY
113410: PUSH
113411: LD_INT 2
113413: ARRAY
113414: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
113415: LD_ADDR_VAR 0 5
113419: PUSH
113420: LD_VAR 0 3
113424: PUSH
113425: LD_VAR 0 1
113429: ARRAY
113430: PUSH
113431: LD_INT 1
113433: ARRAY
113434: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
113435: LD_VAR 0 8
113439: PPUSH
113440: CALL_OW 301
113444: IFTRUE 113463
113446: PUSH
113447: LD_VAR 0 5
113451: PUSH
113452: LD_VAR 0 8
113456: PPUSH
113457: CALL_OW 255
113461: NONEQUAL
113462: OR
113463: IFFALSE 113492
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
113465: LD_ADDR_EXP 186
113469: PUSH
113470: LD_EXP 186
113474: PPUSH
113475: LD_VAR 0 8
113479: PPUSH
113480: LD_INT 0
113482: PPUSH
113483: CALL_OW 1
113487: ST_TO_ADDR
// exit ;
113488: POP
113489: POP
113490: GO 114031
// end ; x := list [ i ] [ 3 ] ;
113492: LD_ADDR_VAR 0 6
113496: PUSH
113497: LD_VAR 0 3
113501: PUSH
113502: LD_VAR 0 1
113506: ARRAY
113507: PUSH
113508: LD_INT 3
113510: ARRAY
113511: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
113512: LD_ADDR_VAR 0 7
113516: PUSH
113517: LD_VAR 0 3
113521: PUSH
113522: LD_VAR 0 1
113526: ARRAY
113527: PUSH
113528: LD_INT 4
113530: ARRAY
113531: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
113532: LD_ADDR_VAR 0 9
113536: PUSH
113537: LD_VAR 0 6
113541: PPUSH
113542: LD_VAR 0 7
113546: PPUSH
113547: LD_INT 16
113549: PPUSH
113550: CALL 95109 0 3
113554: ST_TO_ADDR
// if not cratesNearbyPoint then
113555: LD_VAR 0 9
113559: NOT
113560: IFFALSE 113566
// exit ;
113562: POP
113563: POP
113564: GO 114031
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
113566: LD_ADDR_VAR 0 4
113570: PUSH
113571: LD_INT 22
113573: PUSH
113574: LD_VAR 0 5
113578: PUSH
113579: EMPTY
113580: LIST
113581: LIST
113582: PUSH
113583: LD_INT 3
113585: PUSH
113586: LD_INT 60
113588: PUSH
113589: EMPTY
113590: LIST
113591: PUSH
113592: EMPTY
113593: LIST
113594: LIST
113595: PUSH
113596: LD_INT 91
113598: PUSH
113599: LD_VAR 0 8
113603: PUSH
113604: LD_INT 6
113606: PUSH
113607: EMPTY
113608: LIST
113609: LIST
113610: LIST
113611: PUSH
113612: LD_INT 2
113614: PUSH
113615: LD_INT 25
113617: PUSH
113618: LD_INT 2
113620: PUSH
113621: EMPTY
113622: LIST
113623: LIST
113624: PUSH
113625: LD_INT 25
113627: PUSH
113628: LD_INT 16
113630: PUSH
113631: EMPTY
113632: LIST
113633: LIST
113634: PUSH
113635: EMPTY
113636: LIST
113637: LIST
113638: LIST
113639: PUSH
113640: EMPTY
113641: LIST
113642: LIST
113643: LIST
113644: LIST
113645: PPUSH
113646: CALL_OW 69
113650: PUSH
113651: LD_VAR 0 8
113655: PPUSH
113656: CALL_OW 313
113660: PPUSH
113661: LD_INT 3
113663: PUSH
113664: LD_INT 60
113666: PUSH
113667: EMPTY
113668: LIST
113669: PUSH
113670: EMPTY
113671: LIST
113672: LIST
113673: PUSH
113674: LD_INT 2
113676: PUSH
113677: LD_INT 25
113679: PUSH
113680: LD_INT 2
113682: PUSH
113683: EMPTY
113684: LIST
113685: LIST
113686: PUSH
113687: LD_INT 25
113689: PUSH
113690: LD_INT 16
113692: PUSH
113693: EMPTY
113694: LIST
113695: LIST
113696: PUSH
113697: EMPTY
113698: LIST
113699: LIST
113700: LIST
113701: PUSH
113702: EMPTY
113703: LIST
113704: LIST
113705: PPUSH
113706: CALL_OW 72
113710: UNION
113711: ST_TO_ADDR
// if tmp then
113712: LD_VAR 0 4
113716: IFFALSE 113796
// begin tmp := ShrinkArray ( tmp , 3 ) ;
113718: LD_ADDR_VAR 0 4
113722: PUSH
113723: LD_VAR 0 4
113727: PPUSH
113728: LD_INT 3
113730: PPUSH
113731: CALL 92916 0 2
113735: ST_TO_ADDR
// for j in tmp do
113736: LD_ADDR_VAR 0 2
113740: PUSH
113741: LD_VAR 0 4
113745: PUSH
113746: FOR_IN
113747: IFFALSE 113790
// begin if IsInUnit ( j ) then
113749: LD_VAR 0 2
113753: PPUSH
113754: CALL_OW 310
113758: IFFALSE 113769
// ComExit ( j ) ;
113760: LD_VAR 0 2
113764: PPUSH
113765: CALL 92999 0 1
// AddComCollect ( j , x , y ) ;
113769: LD_VAR 0 2
113773: PPUSH
113774: LD_VAR 0 6
113778: PPUSH
113779: LD_VAR 0 7
113783: PPUSH
113784: CALL_OW 177
// end ;
113788: GO 113746
113790: POP
113791: POP
// exit ;
113792: POP
113793: POP
113794: GO 114031
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
113796: LD_ADDR_VAR 0 4
113800: PUSH
113801: LD_INT 22
113803: PUSH
113804: LD_VAR 0 5
113808: PUSH
113809: EMPTY
113810: LIST
113811: LIST
113812: PUSH
113813: LD_INT 91
113815: PUSH
113816: LD_VAR 0 8
113820: PUSH
113821: LD_INT 8
113823: PUSH
113824: EMPTY
113825: LIST
113826: LIST
113827: LIST
113828: PUSH
113829: LD_INT 2
113831: PUSH
113832: LD_INT 34
113834: PUSH
113835: LD_INT 12
113837: PUSH
113838: EMPTY
113839: LIST
113840: LIST
113841: PUSH
113842: LD_INT 34
113844: PUSH
113845: LD_INT 51
113847: PUSH
113848: EMPTY
113849: LIST
113850: LIST
113851: PUSH
113852: LD_INT 34
113854: PUSH
113855: LD_INT 32
113857: PUSH
113858: EMPTY
113859: LIST
113860: LIST
113861: PUSH
113862: LD_INT 34
113864: PUSH
113865: LD_INT 89
113867: PUSH
113868: EMPTY
113869: LIST
113870: LIST
113871: PUSH
113872: EMPTY
113873: LIST
113874: LIST
113875: LIST
113876: LIST
113877: LIST
113878: PUSH
113879: EMPTY
113880: LIST
113881: LIST
113882: LIST
113883: PPUSH
113884: CALL_OW 69
113888: ST_TO_ADDR
// if tmp then
113889: LD_VAR 0 4
113893: IFFALSE 114027
// begin for j in tmp do
113895: LD_ADDR_VAR 0 2
113899: PUSH
113900: LD_VAR 0 4
113904: PUSH
113905: FOR_IN
113906: IFFALSE 114025
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
113908: LD_VAR 0 2
113912: PPUSH
113913: CALL_OW 262
113917: PUSH
113918: LD_INT 3
113920: EQUAL
113921: IFTRUE 113938
113923: PUSH
113924: LD_VAR 0 2
113928: PPUSH
113929: CALL_OW 261
113933: PUSH
113934: LD_INT 20
113936: GREATER
113937: OR
113938: IFFALSE 113952
113940: PUSH
113941: LD_VAR 0 2
113945: PPUSH
113946: CALL_OW 314
113950: NOT
113951: AND
113952: IFFALSE 113982
113954: PUSH
113955: LD_VAR 0 2
113959: PPUSH
113960: CALL_OW 263
113964: PUSH
113965: LD_INT 1
113967: NONEQUAL
113968: IFTRUE 113981
113970: PUSH
113971: LD_VAR 0 2
113975: PPUSH
113976: CALL_OW 311
113980: OR
113981: AND
113982: IFFALSE 114023
// begin ComCollect ( j , x , y ) ;
113984: LD_VAR 0 2
113988: PPUSH
113989: LD_VAR 0 6
113993: PPUSH
113994: LD_VAR 0 7
113998: PPUSH
113999: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
114003: LD_VAR 0 2
114007: PPUSH
114008: LD_VAR 0 8
114012: PPUSH
114013: CALL_OW 172
// exit ;
114017: POP
114018: POP
114019: POP
114020: POP
114021: GO 114031
// end ;
114023: GO 113905
114025: POP
114026: POP
// end ; end ;
114027: GO 113392
114029: POP
114030: POP
// end ; end_of_file
114031: PPOPN 9
114033: END
// export function SOS_UnitDestroyed ( un ) ; begin
114034: LD_INT 0
114036: PPUSH
// ComRadiation ( un ) ;
114037: LD_VAR 0 1
114041: PPUSH
114042: CALL 115204 0 1
// end ;
114046: LD_VAR 0 2
114050: RET
// export function SOS_UnitKamikazed ( un ) ; begin
114051: LD_INT 0
114053: PPUSH
// ComRadiation ( un ) ;
114054: LD_VAR 0 1
114058: PPUSH
114059: CALL 115204 0 1
// end ;
114063: LD_VAR 0 2
114067: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
114068: LD_INT 0
114070: PPUSH
// end ;
114071: LD_VAR 0 4
114075: RET
// export function SOS_Command ( cmd ) ; begin
114076: LD_INT 0
114078: PPUSH
// end ;
114079: LD_VAR 0 2
114083: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
114084: LD_INT 0
114086: PPUSH
// end ;
114087: LD_VAR 0 6
114091: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex , weapon ; begin
114092: LD_INT 0
114094: PPUSH
114095: PPUSH
114096: PPUSH
114097: PPUSH
114098: PPUSH
// if not vehicle or not factory then
114099: LD_VAR 0 1
114103: NOT
114104: IFTRUE 114113
114106: PUSH
114107: LD_VAR 0 2
114111: NOT
114112: OR
114113: IFFALSE 114117
// exit ;
114115: GO 114779
// weapon := GetWeapon ( vehicle ) ;
114117: LD_ADDR_VAR 0 7
114121: PUSH
114122: LD_VAR 0 1
114126: PPUSH
114127: CALL_OW 264
114131: ST_TO_ADDR
// if weapon = ar_miner then
114132: LD_VAR 0 7
114136: PUSH
114137: LD_INT 81
114139: EQUAL
114140: IFFALSE 114197
// begin minersList := Replace ( minersList , minersList + 1 , vehicle ) ;
114142: LD_ADDR_EXP 195
114146: PUSH
114147: LD_EXP 195
114151: PPUSH
114152: LD_EXP 195
114156: PUSH
114157: LD_INT 1
114159: PLUS
114160: PPUSH
114161: LD_VAR 0 1
114165: PPUSH
114166: CALL_OW 1
114170: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
114171: LD_ADDR_EXP 196
114175: PUSH
114176: LD_EXP 196
114180: PPUSH
114181: LD_EXP 196
114185: PUSH
114186: LD_INT 1
114188: PLUS
114189: PPUSH
114190: EMPTY
114191: PPUSH
114192: CALL_OW 1
114196: ST_TO_ADDR
// end ; if not factoryWaypoints then
114197: LD_EXP 184
114201: NOT
114202: IFFALSE 114206
// exit ;
114204: GO 114779
// for i := 1 to Count ( factoryWaypoints ) do
114206: LD_ADDR_VAR 0 4
114210: PUSH
114211: DOUBLE
114212: LD_INT 1
114214: DEC
114215: ST_TO_ADDR
114216: LD_EXP 184
114220: PPUSH
114221: CALL 56635 0 1
114225: PUSH
114226: FOR_TO
114227: IFFALSE 114777
// if factoryWaypoints [ i ] [ 2 ] = factory then
114229: LD_EXP 184
114233: PUSH
114234: LD_VAR 0 4
114238: ARRAY
114239: PUSH
114240: LD_INT 2
114242: ARRAY
114243: PUSH
114244: LD_VAR 0 2
114248: EQUAL
114249: IFFALSE 114775
// begin if GetControl ( vehicle ) = control_manual then
114251: LD_VAR 0 1
114255: PPUSH
114256: CALL_OW 263
114260: PUSH
114261: LD_INT 1
114263: EQUAL
114264: IFFALSE 114628
// begin driver := IsDrivenBy ( vehicle ) ;
114266: LD_ADDR_VAR 0 5
114270: PUSH
114271: LD_VAR 0 1
114275: PPUSH
114276: CALL_OW 311
114280: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
114281: LD_VAR 0 5
114285: PUSH
114286: LD_EXP 185
114290: IN
114291: IFTRUE 114305
114293: PUSH
114294: LD_VAR 0 1
114298: PUSH
114299: LD_EXP 185
114303: IN
114304: OR
114305: IFFALSE 114311
// exit ;
114307: POP
114308: POP
114309: GO 114779
// if not HasTask ( driver ) then
114311: LD_VAR 0 5
114315: PPUSH
114316: CALL_OW 314
114320: NOT
114321: IFFALSE 114626
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
114323: LD_ADDR_EXP 185
114327: PUSH
114328: LD_EXP 185
114332: PPUSH
114333: LD_VAR 0 5
114337: PPUSH
114338: CALL 92601 0 2
114342: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
114343: LD_ADDR_EXP 185
114347: PUSH
114348: LD_EXP 185
114352: PPUSH
114353: LD_VAR 0 1
114357: PPUSH
114358: CALL 92601 0 2
114362: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
114363: LD_ADDR_VAR 0 6
114367: PUSH
114368: LD_EXP 184
114372: PUSH
114373: LD_VAR 0 4
114377: ARRAY
114378: PUSH
114379: LD_INT 3
114381: ARRAY
114382: PPUSH
114383: LD_EXP 184
114387: PUSH
114388: LD_VAR 0 4
114392: ARRAY
114393: PUSH
114394: LD_INT 4
114396: ARRAY
114397: PPUSH
114398: CALL_OW 428
114402: ST_TO_ADDR
// if hex then
114403: LD_VAR 0 6
114407: IFFALSE 114425
// ComMoveUnit ( driver , hex ) else
114409: LD_VAR 0 5
114413: PPUSH
114414: LD_VAR 0 6
114418: PPUSH
114419: CALL_OW 112
114423: GO 114509
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
114425: LD_VAR 0 1
114429: PPUSH
114430: LD_EXP 184
114434: PUSH
114435: LD_VAR 0 4
114439: ARRAY
114440: PUSH
114441: LD_INT 3
114443: ARRAY
114444: PPUSH
114445: LD_EXP 184
114449: PUSH
114450: LD_VAR 0 4
114454: ARRAY
114455: PUSH
114456: LD_INT 4
114458: ARRAY
114459: PPUSH
114460: CALL_OW 297
114464: PUSH
114465: LD_INT 0
114467: GREATER
114468: IFFALSE 114509
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
114470: LD_VAR 0 5
114474: PPUSH
114475: LD_EXP 184
114479: PUSH
114480: LD_VAR 0 4
114484: ARRAY
114485: PUSH
114486: LD_INT 3
114488: ARRAY
114489: PPUSH
114490: LD_EXP 184
114494: PUSH
114495: LD_VAR 0 4
114499: ARRAY
114500: PUSH
114501: LD_INT 4
114503: ARRAY
114504: PPUSH
114505: CALL_OW 111
// AddComExitVehicle ( driver ) ;
114509: LD_VAR 0 5
114513: PPUSH
114514: CALL_OW 181
// if Multiplayer then
114518: LD_OWVAR 4
114522: IFFALSE 114571
// begin repeat wait ( 10 ) ;
114524: LD_INT 10
114526: PPUSH
114527: CALL_OW 67
// until not IsInUnit ( driver ) ;
114531: LD_VAR 0 5
114535: PPUSH
114536: CALL_OW 310
114540: NOT
114541: IFFALSE 114524
// if not HasTask ( driver ) then
114543: LD_VAR 0 5
114547: PPUSH
114548: CALL_OW 314
114552: NOT
114553: IFFALSE 114569
// ComEnterUnit ( driver , factory ) ;
114555: LD_VAR 0 5
114559: PPUSH
114560: LD_VAR 0 2
114564: PPUSH
114565: CALL_OW 120
// end else
114569: GO 114585
// AddComEnterUnit ( driver , factory ) ;
114571: LD_VAR 0 5
114575: PPUSH
114576: LD_VAR 0 2
114580: PPUSH
114581: CALL_OW 180
// wait ( 0 0$1 ) ;
114585: LD_INT 35
114587: PPUSH
114588: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
114592: LD_ADDR_EXP 185
114596: PUSH
114597: LD_EXP 185
114601: PUSH
114602: LD_VAR 0 5
114606: DIFF
114607: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
114608: LD_ADDR_EXP 185
114612: PUSH
114613: LD_EXP 185
114617: PUSH
114618: LD_VAR 0 1
114622: DIFF
114623: ST_TO_ADDR
// break ;
114624: GO 114777
// end ; end else
114626: GO 114775
// if GetControl ( vehicle ) = control_remote then
114628: LD_VAR 0 1
114632: PPUSH
114633: CALL_OW 263
114637: PUSH
114638: LD_INT 2
114640: EQUAL
114641: IFFALSE 114727
// begin wait ( 0 0$2 ) ;
114643: LD_INT 70
114645: PPUSH
114646: CALL_OW 67
// repeat wait ( 10 ) ;
114650: LD_INT 10
114652: PPUSH
114653: CALL_OW 67
// Connect ( vehicle ) ;
114657: LD_VAR 0 1
114661: PPUSH
114662: CALL 62913 0 1
// until IsControledBy ( vehicle ) ;
114666: LD_VAR 0 1
114670: PPUSH
114671: CALL_OW 312
114675: IFFALSE 114650
// wait ( 10 ) ;
114677: LD_INT 10
114679: PPUSH
114680: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
114684: LD_VAR 0 1
114688: PPUSH
114689: LD_EXP 184
114693: PUSH
114694: LD_VAR 0 4
114698: ARRAY
114699: PUSH
114700: LD_INT 3
114702: ARRAY
114703: PPUSH
114704: LD_EXP 184
114708: PUSH
114709: LD_VAR 0 4
114713: ARRAY
114714: PUSH
114715: LD_INT 4
114717: ARRAY
114718: PPUSH
114719: CALL_OW 111
// break ;
114723: GO 114777
// end else
114725: GO 114775
// begin wait ( 0 0$3 ) ;
114727: LD_INT 105
114729: PPUSH
114730: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
114734: LD_VAR 0 1
114738: PPUSH
114739: LD_EXP 184
114743: PUSH
114744: LD_VAR 0 4
114748: ARRAY
114749: PUSH
114750: LD_INT 3
114752: ARRAY
114753: PPUSH
114754: LD_EXP 184
114758: PUSH
114759: LD_VAR 0 4
114763: ARRAY
114764: PUSH
114765: LD_INT 4
114767: ARRAY
114768: PPUSH
114769: CALL_OW 111
// break ;
114773: GO 114777
// end ; end ;
114775: GO 114226
114777: POP
114778: POP
// end ;
114779: LD_VAR 0 3
114783: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
114784: LD_INT 0
114786: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
114787: LD_VAR 0 1
114791: PUSH
114792: LD_INT 250
114794: EQUAL
114795: IFFALSE 114812
114797: PUSH
114798: LD_VAR 0 2
114802: PPUSH
114803: CALL_OW 264
114807: PUSH
114808: LD_INT 81
114810: EQUAL
114811: AND
114812: IFFALSE 114833
// MinerPlaceMine ( unit , x , y ) ;
114814: LD_VAR 0 2
114818: PPUSH
114819: LD_VAR 0 4
114823: PPUSH
114824: LD_VAR 0 5
114828: PPUSH
114829: CALL 118114 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
114833: LD_VAR 0 1
114837: PUSH
114838: LD_INT 251
114840: EQUAL
114841: IFFALSE 114858
114843: PUSH
114844: LD_VAR 0 2
114848: PPUSH
114849: CALL_OW 264
114853: PUSH
114854: LD_INT 81
114856: EQUAL
114857: AND
114858: IFFALSE 114879
// MinerDetonateMine ( unit , x , y ) ;
114860: LD_VAR 0 2
114864: PPUSH
114865: LD_VAR 0 4
114869: PPUSH
114870: LD_VAR 0 5
114874: PPUSH
114875: CALL 118521 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
114879: LD_VAR 0 1
114883: PUSH
114884: LD_INT 252
114886: EQUAL
114887: IFFALSE 114904
114889: PUSH
114890: LD_VAR 0 2
114894: PPUSH
114895: CALL_OW 264
114899: PUSH
114900: LD_INT 81
114902: EQUAL
114903: AND
114904: IFFALSE 114925
// MinerCreateMinefield ( unit , x , y ) ;
114906: LD_VAR 0 2
114910: PPUSH
114911: LD_VAR 0 4
114915: PPUSH
114916: LD_VAR 0 5
114920: PPUSH
114921: CALL 118753 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
114925: LD_VAR 0 1
114929: PUSH
114930: LD_INT 253
114932: EQUAL
114933: IFFALSE 114950
114935: PUSH
114936: LD_VAR 0 2
114940: PPUSH
114941: CALL_OW 257
114945: PUSH
114946: LD_INT 5
114948: EQUAL
114949: AND
114950: IFFALSE 114971
// ComBinocular ( unit , x , y ) ;
114952: LD_VAR 0 2
114956: PPUSH
114957: LD_VAR 0 4
114961: PPUSH
114962: LD_VAR 0 5
114966: PPUSH
114967: CALL 119128 0 3
// if selectedUnit then
114971: LD_VAR 0 3
114975: IFFALSE 115035
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
114977: LD_VAR 0 1
114981: PUSH
114982: LD_INT 254
114984: EQUAL
114985: IFFALSE 115002
114987: PUSH
114988: LD_VAR 0 2
114992: PPUSH
114993: CALL_OW 264
114997: PUSH
114998: LD_INT 99
115000: EQUAL
115001: AND
115002: IFFALSE 115019
115004: PUSH
115005: LD_VAR 0 3
115009: PPUSH
115010: CALL_OW 263
115014: PUSH
115015: LD_INT 3
115017: EQUAL
115018: AND
115019: IFFALSE 115035
// HackDestroyVehicle ( unit , selectedUnit ) ;
115021: LD_VAR 0 2
115025: PPUSH
115026: LD_VAR 0 3
115030: PPUSH
115031: CALL 117325 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
115035: LD_VAR 0 1
115039: PUSH
115040: LD_INT 255
115042: EQUAL
115043: IFFALSE 115067
115045: PUSH
115046: LD_VAR 0 2
115050: PPUSH
115051: CALL_OW 264
115055: PUSH
115056: LD_INT 14
115058: PUSH
115059: LD_INT 53
115061: PUSH
115062: EMPTY
115063: LIST
115064: LIST
115065: IN
115066: AND
115067: IFFALSE 115085
115069: PUSH
115070: LD_VAR 0 4
115074: PPUSH
115075: LD_VAR 0 5
115079: PPUSH
115080: CALL_OW 488
115084: AND
115085: IFFALSE 115109
// CutTreeXYR ( unit , x , y , 12 ) ;
115087: LD_VAR 0 2
115091: PPUSH
115092: LD_VAR 0 4
115096: PPUSH
115097: LD_VAR 0 5
115101: PPUSH
115102: LD_INT 12
115104: PPUSH
115105: CALL 115300 0 4
// if cmd = 256 then
115109: LD_VAR 0 1
115113: PUSH
115114: LD_INT 256
115116: EQUAL
115117: IFFALSE 115138
// SetFactoryWaypoint ( unit , x , y ) ;
115119: LD_VAR 0 2
115123: PPUSH
115124: LD_VAR 0 4
115128: PPUSH
115129: LD_VAR 0 5
115133: PPUSH
115134: CALL 112579 0 3
// if cmd = 257 then
115138: LD_VAR 0 1
115142: PUSH
115143: LD_INT 257
115145: EQUAL
115146: IFFALSE 115167
// SetWarehouseGatheringPoint ( unit , x , y ) ;
115148: LD_VAR 0 2
115152: PPUSH
115153: LD_VAR 0 4
115157: PPUSH
115158: LD_VAR 0 5
115162: PPUSH
115163: CALL 113075 0 3
// if cmd = 258 then
115167: LD_VAR 0 1
115171: PUSH
115172: LD_INT 258
115174: EQUAL
115175: IFFALSE 115199
// BurnTreeXYR ( unit , x , y , 8 ) ;
115177: LD_VAR 0 2
115181: PPUSH
115182: LD_VAR 0 4
115186: PPUSH
115187: LD_VAR 0 5
115191: PPUSH
115192: LD_INT 8
115194: PPUSH
115195: CALL 115700 0 4
// end ;
115199: LD_VAR 0 6
115203: RET
// export function ComRadiation ( un ) ; var eff ; begin
115204: LD_INT 0
115206: PPUSH
115207: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
115208: LD_VAR 0 1
115212: PPUSH
115213: CALL_OW 264
115217: PUSH
115218: LD_INT 91
115220: NONEQUAL
115221: IFFALSE 115225
// exit ;
115223: GO 115295
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
115225: LD_INT 68
115227: PPUSH
115228: LD_VAR 0 1
115232: PPUSH
115233: CALL_OW 255
115237: PPUSH
115238: CALL_OW 321
115242: PUSH
115243: LD_INT 2
115245: EQUAL
115246: IFFALSE 115258
// eff := 50 else
115248: LD_ADDR_VAR 0 3
115252: PUSH
115253: LD_INT 50
115255: ST_TO_ADDR
115256: GO 115266
// eff := 25 ;
115258: LD_ADDR_VAR 0 3
115262: PUSH
115263: LD_INT 25
115265: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
115266: LD_VAR 0 1
115270: PPUSH
115271: CALL_OW 250
115275: PPUSH
115276: LD_VAR 0 1
115280: PPUSH
115281: CALL_OW 251
115285: PPUSH
115286: LD_VAR 0 3
115290: PPUSH
115291: CALL_OW 495
// end ;
115295: LD_VAR 0 2
115299: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
115300: LD_INT 0
115302: PPUSH
115303: PPUSH
115304: PPUSH
115305: PPUSH
115306: PPUSH
115307: PPUSH
115308: PPUSH
115309: PPUSH
115310: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
115311: LD_VAR 0 1
115315: PPUSH
115316: CALL_OW 302
115320: NOT
115321: IFTRUE 115340
115323: PUSH
115324: LD_VAR 0 2
115328: PPUSH
115329: LD_VAR 0 3
115333: PPUSH
115334: CALL_OW 488
115338: NOT
115339: OR
115340: IFTRUE 115349
115342: PUSH
115343: LD_VAR 0 4
115347: NOT
115348: OR
115349: IFFALSE 115353
// exit ;
115351: GO 115695
// list := [ ] ;
115353: LD_ADDR_VAR 0 13
115357: PUSH
115358: EMPTY
115359: ST_TO_ADDR
// if x - r < 0 then
115360: LD_VAR 0 2
115364: PUSH
115365: LD_VAR 0 4
115369: MINUS
115370: PUSH
115371: LD_INT 0
115373: LESS
115374: IFFALSE 115386
// min_x := 0 else
115376: LD_ADDR_VAR 0 7
115380: PUSH
115381: LD_INT 0
115383: ST_TO_ADDR
115384: GO 115402
// min_x := x - r ;
115386: LD_ADDR_VAR 0 7
115390: PUSH
115391: LD_VAR 0 2
115395: PUSH
115396: LD_VAR 0 4
115400: MINUS
115401: ST_TO_ADDR
// if y - r < 0 then
115402: LD_VAR 0 3
115406: PUSH
115407: LD_VAR 0 4
115411: MINUS
115412: PUSH
115413: LD_INT 0
115415: LESS
115416: IFFALSE 115428
// min_y := 0 else
115418: LD_ADDR_VAR 0 8
115422: PUSH
115423: LD_INT 0
115425: ST_TO_ADDR
115426: GO 115444
// min_y := y - r ;
115428: LD_ADDR_VAR 0 8
115432: PUSH
115433: LD_VAR 0 3
115437: PUSH
115438: LD_VAR 0 4
115442: MINUS
115443: ST_TO_ADDR
// max_x := x + r ;
115444: LD_ADDR_VAR 0 9
115448: PUSH
115449: LD_VAR 0 2
115453: PUSH
115454: LD_VAR 0 4
115458: PLUS
115459: ST_TO_ADDR
// max_y := y + r ;
115460: LD_ADDR_VAR 0 10
115464: PUSH
115465: LD_VAR 0 3
115469: PUSH
115470: LD_VAR 0 4
115474: PLUS
115475: ST_TO_ADDR
// for _x = min_x to max_x do
115476: LD_ADDR_VAR 0 11
115480: PUSH
115481: DOUBLE
115482: LD_VAR 0 7
115486: DEC
115487: ST_TO_ADDR
115488: LD_VAR 0 9
115492: PUSH
115493: FOR_TO
115494: IFFALSE 115613
// for _y = min_y to max_y do
115496: LD_ADDR_VAR 0 12
115500: PUSH
115501: DOUBLE
115502: LD_VAR 0 8
115506: DEC
115507: ST_TO_ADDR
115508: LD_VAR 0 10
115512: PUSH
115513: FOR_TO
115514: IFFALSE 115609
// begin if not ValidHex ( _x , _y ) then
115516: LD_VAR 0 11
115520: PPUSH
115521: LD_VAR 0 12
115525: PPUSH
115526: CALL_OW 488
115530: NOT
115531: IFFALSE 115535
// continue ;
115533: GO 115513
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
115535: LD_VAR 0 11
115539: PPUSH
115540: LD_VAR 0 12
115544: PPUSH
115545: CALL_OW 351
115549: IFFALSE 115567
115551: PUSH
115552: LD_VAR 0 11
115556: PPUSH
115557: LD_VAR 0 12
115561: PPUSH
115562: CALL_OW 554
115566: AND
115567: IFFALSE 115607
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
115569: LD_ADDR_VAR 0 13
115573: PUSH
115574: LD_VAR 0 13
115578: PPUSH
115579: LD_VAR 0 13
115583: PUSH
115584: LD_INT 1
115586: PLUS
115587: PPUSH
115588: LD_VAR 0 11
115592: PUSH
115593: LD_VAR 0 12
115597: PUSH
115598: EMPTY
115599: LIST
115600: LIST
115601: PPUSH
115602: CALL_OW 2
115606: ST_TO_ADDR
// end ;
115607: GO 115513
115609: POP
115610: POP
115611: GO 115493
115613: POP
115614: POP
// if not list then
115615: LD_VAR 0 13
115619: NOT
115620: IFFALSE 115624
// exit ;
115622: GO 115695
// for i in list do
115624: LD_ADDR_VAR 0 6
115628: PUSH
115629: LD_VAR 0 13
115633: PUSH
115634: FOR_IN
115635: IFFALSE 115693
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
115637: LD_VAR 0 1
115641: PPUSH
115642: LD_STRING M
115644: PUSH
115645: LD_VAR 0 6
115649: PUSH
115650: LD_INT 1
115652: ARRAY
115653: PUSH
115654: LD_VAR 0 6
115658: PUSH
115659: LD_INT 2
115661: ARRAY
115662: PUSH
115663: LD_INT 0
115665: PUSH
115666: LD_INT 0
115668: PUSH
115669: LD_INT 0
115671: PUSH
115672: LD_INT 0
115674: PUSH
115675: EMPTY
115676: LIST
115677: LIST
115678: LIST
115679: LIST
115680: LIST
115681: LIST
115682: LIST
115683: PUSH
115684: EMPTY
115685: LIST
115686: PPUSH
115687: CALL_OW 447
115691: GO 115634
115693: POP
115694: POP
// end ;
115695: LD_VAR 0 5
115699: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
115700: LD_INT 0
115702: PPUSH
115703: PPUSH
115704: PPUSH
115705: PPUSH
115706: PPUSH
115707: PPUSH
115708: PPUSH
115709: PPUSH
115710: PPUSH
115711: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
115712: LD_VAR 0 1
115716: PPUSH
115717: CALL_OW 302
115721: NOT
115722: IFTRUE 115741
115724: PUSH
115725: LD_VAR 0 2
115729: PPUSH
115730: LD_VAR 0 3
115734: PPUSH
115735: CALL_OW 488
115739: NOT
115740: OR
115741: IFTRUE 115750
115743: PUSH
115744: LD_VAR 0 4
115748: NOT
115749: OR
115750: IFFALSE 115754
// exit ;
115752: GO 116271
// list := [ ] ;
115754: LD_ADDR_VAR 0 13
115758: PUSH
115759: EMPTY
115760: ST_TO_ADDR
// if x - r < 0 then
115761: LD_VAR 0 2
115765: PUSH
115766: LD_VAR 0 4
115770: MINUS
115771: PUSH
115772: LD_INT 0
115774: LESS
115775: IFFALSE 115787
// min_x := 0 else
115777: LD_ADDR_VAR 0 7
115781: PUSH
115782: LD_INT 0
115784: ST_TO_ADDR
115785: GO 115803
// min_x := x - r ;
115787: LD_ADDR_VAR 0 7
115791: PUSH
115792: LD_VAR 0 2
115796: PUSH
115797: LD_VAR 0 4
115801: MINUS
115802: ST_TO_ADDR
// if y - r < 0 then
115803: LD_VAR 0 3
115807: PUSH
115808: LD_VAR 0 4
115812: MINUS
115813: PUSH
115814: LD_INT 0
115816: LESS
115817: IFFALSE 115829
// min_y := 0 else
115819: LD_ADDR_VAR 0 8
115823: PUSH
115824: LD_INT 0
115826: ST_TO_ADDR
115827: GO 115845
// min_y := y - r ;
115829: LD_ADDR_VAR 0 8
115833: PUSH
115834: LD_VAR 0 3
115838: PUSH
115839: LD_VAR 0 4
115843: MINUS
115844: ST_TO_ADDR
// max_x := x + r ;
115845: LD_ADDR_VAR 0 9
115849: PUSH
115850: LD_VAR 0 2
115854: PUSH
115855: LD_VAR 0 4
115859: PLUS
115860: ST_TO_ADDR
// max_y := y + r ;
115861: LD_ADDR_VAR 0 10
115865: PUSH
115866: LD_VAR 0 3
115870: PUSH
115871: LD_VAR 0 4
115875: PLUS
115876: ST_TO_ADDR
// for _x = min_x to max_x do
115877: LD_ADDR_VAR 0 11
115881: PUSH
115882: DOUBLE
115883: LD_VAR 0 7
115887: DEC
115888: ST_TO_ADDR
115889: LD_VAR 0 9
115893: PUSH
115894: FOR_TO
115895: IFFALSE 116014
// for _y = min_y to max_y do
115897: LD_ADDR_VAR 0 12
115901: PUSH
115902: DOUBLE
115903: LD_VAR 0 8
115907: DEC
115908: ST_TO_ADDR
115909: LD_VAR 0 10
115913: PUSH
115914: FOR_TO
115915: IFFALSE 116010
// begin if not ValidHex ( _x , _y ) then
115917: LD_VAR 0 11
115921: PPUSH
115922: LD_VAR 0 12
115926: PPUSH
115927: CALL_OW 488
115931: NOT
115932: IFFALSE 115936
// continue ;
115934: GO 115914
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
115936: LD_VAR 0 11
115940: PPUSH
115941: LD_VAR 0 12
115945: PPUSH
115946: CALL_OW 351
115950: IFFALSE 115968
115952: PUSH
115953: LD_VAR 0 11
115957: PPUSH
115958: LD_VAR 0 12
115962: PPUSH
115963: CALL_OW 554
115967: AND
115968: IFFALSE 116008
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
115970: LD_ADDR_VAR 0 13
115974: PUSH
115975: LD_VAR 0 13
115979: PPUSH
115980: LD_VAR 0 13
115984: PUSH
115985: LD_INT 1
115987: PLUS
115988: PPUSH
115989: LD_VAR 0 11
115993: PUSH
115994: LD_VAR 0 12
115998: PUSH
115999: EMPTY
116000: LIST
116001: LIST
116002: PPUSH
116003: CALL_OW 2
116007: ST_TO_ADDR
// end ;
116008: GO 115914
116010: POP
116011: POP
116012: GO 115894
116014: POP
116015: POP
// if not list then
116016: LD_VAR 0 13
116020: NOT
116021: IFFALSE 116025
// exit ;
116023: GO 116271
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
116025: LD_ADDR_VAR 0 13
116029: PUSH
116030: LD_VAR 0 1
116034: PPUSH
116035: LD_VAR 0 13
116039: PPUSH
116040: LD_INT 1
116042: PPUSH
116043: LD_INT 1
116045: PPUSH
116046: CALL 60041 0 4
116050: ST_TO_ADDR
// ComStop ( flame ) ;
116051: LD_VAR 0 1
116055: PPUSH
116056: CALL_OW 141
// for i in list do
116060: LD_ADDR_VAR 0 6
116064: PUSH
116065: LD_VAR 0 13
116069: PUSH
116070: FOR_IN
116071: IFFALSE 116102
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
116073: LD_VAR 0 1
116077: PPUSH
116078: LD_VAR 0 6
116082: PUSH
116083: LD_INT 1
116085: ARRAY
116086: PPUSH
116087: LD_VAR 0 6
116091: PUSH
116092: LD_INT 2
116094: ARRAY
116095: PPUSH
116096: CALL_OW 176
116100: GO 116070
116102: POP
116103: POP
// repeat wait ( 0 0$1 ) ;
116104: LD_INT 35
116106: PPUSH
116107: CALL_OW 67
// task := GetTaskList ( flame ) ;
116111: LD_ADDR_VAR 0 14
116115: PUSH
116116: LD_VAR 0 1
116120: PPUSH
116121: CALL_OW 437
116125: ST_TO_ADDR
// if not task then
116126: LD_VAR 0 14
116130: NOT
116131: IFFALSE 116135
// exit ;
116133: GO 116271
// if task [ 1 ] [ 1 ] <> | then
116135: LD_VAR 0 14
116139: PUSH
116140: LD_INT 1
116142: ARRAY
116143: PUSH
116144: LD_INT 1
116146: ARRAY
116147: PUSH
116148: LD_STRING |
116150: NONEQUAL
116151: IFFALSE 116155
// exit ;
116153: GO 116271
// _x := task [ 1 ] [ 2 ] ;
116155: LD_ADDR_VAR 0 11
116159: PUSH
116160: LD_VAR 0 14
116164: PUSH
116165: LD_INT 1
116167: ARRAY
116168: PUSH
116169: LD_INT 2
116171: ARRAY
116172: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
116173: LD_ADDR_VAR 0 12
116177: PUSH
116178: LD_VAR 0 14
116182: PUSH
116183: LD_INT 1
116185: ARRAY
116186: PUSH
116187: LD_INT 3
116189: ARRAY
116190: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
116191: LD_VAR 0 11
116195: PPUSH
116196: LD_VAR 0 12
116200: PPUSH
116201: CALL_OW 351
116205: NOT
116206: IFTRUE 116225
116208: PUSH
116209: LD_VAR 0 11
116213: PPUSH
116214: LD_VAR 0 12
116218: PPUSH
116219: CALL_OW 554
116223: NOT
116224: OR
116225: IFFALSE 116259
// begin task := Delete ( task , 1 ) ;
116227: LD_ADDR_VAR 0 14
116231: PUSH
116232: LD_VAR 0 14
116236: PPUSH
116237: LD_INT 1
116239: PPUSH
116240: CALL_OW 3
116244: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
116245: LD_VAR 0 1
116249: PPUSH
116250: LD_VAR 0 14
116254: PPUSH
116255: CALL_OW 446
// end ; until not HasTask ( flame ) ;
116259: LD_VAR 0 1
116263: PPUSH
116264: CALL_OW 314
116268: NOT
116269: IFFALSE 116104
// end ;
116271: LD_VAR 0 5
116275: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
116276: LD_EXP 188
116280: NOT
116281: IFFALSE 116331
116283: GO 116285
116285: DISABLE
// begin initHack := true ;
116286: LD_ADDR_EXP 188
116290: PUSH
116291: LD_INT 1
116293: ST_TO_ADDR
// hackTanks := [ ] ;
116294: LD_ADDR_EXP 189
116298: PUSH
116299: EMPTY
116300: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
116301: LD_ADDR_EXP 190
116305: PUSH
116306: EMPTY
116307: ST_TO_ADDR
// hackLimit := 3 ;
116308: LD_ADDR_EXP 191
116312: PUSH
116313: LD_INT 3
116315: ST_TO_ADDR
// hackDist := 12 ;
116316: LD_ADDR_EXP 192
116320: PUSH
116321: LD_INT 12
116323: ST_TO_ADDR
// hackCounter := [ ] ;
116324: LD_ADDR_EXP 193
116328: PUSH
116329: EMPTY
116330: ST_TO_ADDR
// end ;
116331: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
116332: LD_EXP 188
116336: IFFALSE 116354
116338: PUSH
116339: LD_INT 34
116341: PUSH
116342: LD_INT 99
116344: PUSH
116345: EMPTY
116346: LIST
116347: LIST
116348: PPUSH
116349: CALL_OW 69
116353: AND
116354: IFFALSE 116607
116356: GO 116358
116358: DISABLE
116359: LD_INT 0
116361: PPUSH
116362: PPUSH
// begin enable ;
116363: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
116364: LD_ADDR_VAR 0 1
116368: PUSH
116369: LD_INT 34
116371: PUSH
116372: LD_INT 99
116374: PUSH
116375: EMPTY
116376: LIST
116377: LIST
116378: PPUSH
116379: CALL_OW 69
116383: PUSH
116384: FOR_IN
116385: IFFALSE 116605
// begin if not i in hackTanks then
116387: LD_VAR 0 1
116391: PUSH
116392: LD_EXP 189
116396: IN
116397: NOT
116398: IFFALSE 116481
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
116400: LD_ADDR_EXP 189
116404: PUSH
116405: LD_EXP 189
116409: PPUSH
116410: LD_EXP 189
116414: PUSH
116415: LD_INT 1
116417: PLUS
116418: PPUSH
116419: LD_VAR 0 1
116423: PPUSH
116424: CALL_OW 1
116428: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
116429: LD_ADDR_EXP 190
116433: PUSH
116434: LD_EXP 190
116438: PPUSH
116439: LD_EXP 190
116443: PUSH
116444: LD_INT 1
116446: PLUS
116447: PPUSH
116448: EMPTY
116449: PPUSH
116450: CALL_OW 1
116454: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
116455: LD_ADDR_EXP 193
116459: PUSH
116460: LD_EXP 193
116464: PPUSH
116465: LD_EXP 193
116469: PUSH
116470: LD_INT 1
116472: PLUS
116473: PPUSH
116474: EMPTY
116475: PPUSH
116476: CALL_OW 1
116480: ST_TO_ADDR
// end ; if not IsOk ( i ) then
116481: LD_VAR 0 1
116485: PPUSH
116486: CALL_OW 302
116490: NOT
116491: IFFALSE 116504
// begin HackUnlinkAll ( i ) ;
116493: LD_VAR 0 1
116497: PPUSH
116498: CALL 116610 0 1
// continue ;
116502: GO 116384
// end ; HackCheckCapturedStatus ( i ) ;
116504: LD_VAR 0 1
116508: PPUSH
116509: CALL 117055 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
116513: LD_ADDR_VAR 0 2
116517: PUSH
116518: LD_INT 81
116520: PUSH
116521: LD_VAR 0 1
116525: PPUSH
116526: CALL_OW 255
116530: PUSH
116531: EMPTY
116532: LIST
116533: LIST
116534: PUSH
116535: LD_INT 33
116537: PUSH
116538: LD_INT 3
116540: PUSH
116541: EMPTY
116542: LIST
116543: LIST
116544: PUSH
116545: LD_INT 91
116547: PUSH
116548: LD_VAR 0 1
116552: PUSH
116553: LD_EXP 192
116557: PUSH
116558: EMPTY
116559: LIST
116560: LIST
116561: LIST
116562: PUSH
116563: LD_INT 50
116565: PUSH
116566: EMPTY
116567: LIST
116568: PUSH
116569: EMPTY
116570: LIST
116571: LIST
116572: LIST
116573: LIST
116574: PPUSH
116575: CALL_OW 69
116579: ST_TO_ADDR
// if not tmp then
116580: LD_VAR 0 2
116584: NOT
116585: IFFALSE 116589
// continue ;
116587: GO 116384
// HackLink ( i , tmp ) ;
116589: LD_VAR 0 1
116593: PPUSH
116594: LD_VAR 0 2
116598: PPUSH
116599: CALL 116746 0 2
// end ;
116603: GO 116384
116605: POP
116606: POP
// end ;
116607: PPOPN 2
116609: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
116610: LD_INT 0
116612: PPUSH
116613: PPUSH
116614: PPUSH
// if not hack in hackTanks then
116615: LD_VAR 0 1
116619: PUSH
116620: LD_EXP 189
116624: IN
116625: NOT
116626: IFFALSE 116630
// exit ;
116628: GO 116741
// index := GetElementIndex ( hackTanks , hack ) ;
116630: LD_ADDR_VAR 0 4
116634: PUSH
116635: LD_EXP 189
116639: PPUSH
116640: LD_VAR 0 1
116644: PPUSH
116645: CALL 59336 0 2
116649: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
116650: LD_EXP 190
116654: PUSH
116655: LD_VAR 0 4
116659: ARRAY
116660: IFFALSE 116741
// begin for i in hackTanksCaptured [ index ] do
116662: LD_ADDR_VAR 0 3
116666: PUSH
116667: LD_EXP 190
116671: PUSH
116672: LD_VAR 0 4
116676: ARRAY
116677: PUSH
116678: FOR_IN
116679: IFFALSE 116705
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
116681: LD_VAR 0 3
116685: PUSH
116686: LD_INT 1
116688: ARRAY
116689: PPUSH
116690: LD_VAR 0 3
116694: PUSH
116695: LD_INT 2
116697: ARRAY
116698: PPUSH
116699: CALL_OW 235
116703: GO 116678
116705: POP
116706: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
116707: LD_ADDR_EXP 190
116711: PUSH
116712: LD_EXP 190
116716: PPUSH
116717: LD_VAR 0 4
116721: PPUSH
116722: EMPTY
116723: PPUSH
116724: CALL_OW 1
116728: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
116729: LD_VAR 0 1
116733: PPUSH
116734: LD_INT 0
116736: PPUSH
116737: CALL_OW 505
// end ; end ;
116741: LD_VAR 0 2
116745: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
116746: LD_INT 0
116748: PPUSH
116749: PPUSH
116750: PPUSH
// if not hack in hackTanks or not vehicles then
116751: LD_VAR 0 1
116755: PUSH
116756: LD_EXP 189
116760: IN
116761: NOT
116762: IFTRUE 116771
116764: PUSH
116765: LD_VAR 0 2
116769: NOT
116770: OR
116771: IFFALSE 116775
// exit ;
116773: GO 117050
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
116775: LD_ADDR_VAR 0 2
116779: PUSH
116780: LD_VAR 0 1
116784: PPUSH
116785: LD_VAR 0 2
116789: PPUSH
116790: LD_INT 1
116792: PPUSH
116793: LD_INT 1
116795: PPUSH
116796: CALL 59988 0 4
116800: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
116801: LD_ADDR_VAR 0 5
116805: PUSH
116806: LD_EXP 189
116810: PPUSH
116811: LD_VAR 0 1
116815: PPUSH
116816: CALL 59336 0 2
116820: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
116821: LD_EXP 190
116825: PUSH
116826: LD_VAR 0 5
116830: ARRAY
116831: PUSH
116832: LD_EXP 191
116836: LESS
116837: IFFALSE 117026
// begin for i := 1 to vehicles do
116839: LD_ADDR_VAR 0 4
116843: PUSH
116844: DOUBLE
116845: LD_INT 1
116847: DEC
116848: ST_TO_ADDR
116849: LD_VAR 0 2
116853: PUSH
116854: FOR_TO
116855: IFFALSE 117024
// begin if hackTanksCaptured [ index ] = hackLimit then
116857: LD_EXP 190
116861: PUSH
116862: LD_VAR 0 5
116866: ARRAY
116867: PUSH
116868: LD_EXP 191
116872: EQUAL
116873: IFFALSE 116877
// break ;
116875: GO 117024
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
116877: LD_ADDR_EXP 193
116881: PUSH
116882: LD_EXP 193
116886: PPUSH
116887: LD_VAR 0 5
116891: PPUSH
116892: LD_EXP 193
116896: PUSH
116897: LD_VAR 0 5
116901: ARRAY
116902: PUSH
116903: LD_INT 1
116905: PLUS
116906: PPUSH
116907: CALL_OW 1
116911: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
116912: LD_ADDR_EXP 190
116916: PUSH
116917: LD_EXP 190
116921: PPUSH
116922: LD_VAR 0 5
116926: PUSH
116927: LD_EXP 190
116931: PUSH
116932: LD_VAR 0 5
116936: ARRAY
116937: PUSH
116938: LD_INT 1
116940: PLUS
116941: PUSH
116942: EMPTY
116943: LIST
116944: LIST
116945: PPUSH
116946: LD_VAR 0 2
116950: PUSH
116951: LD_VAR 0 4
116955: ARRAY
116956: PUSH
116957: LD_VAR 0 2
116961: PUSH
116962: LD_VAR 0 4
116966: ARRAY
116967: PPUSH
116968: CALL_OW 255
116972: PUSH
116973: EMPTY
116974: LIST
116975: LIST
116976: PPUSH
116977: CALL 59553 0 3
116981: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
116982: LD_VAR 0 2
116986: PUSH
116987: LD_VAR 0 4
116991: ARRAY
116992: PPUSH
116993: LD_VAR 0 1
116997: PPUSH
116998: CALL_OW 255
117002: PPUSH
117003: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
117007: LD_VAR 0 2
117011: PUSH
117012: LD_VAR 0 4
117016: ARRAY
117017: PPUSH
117018: CALL_OW 141
// end ;
117022: GO 116854
117024: POP
117025: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117026: LD_VAR 0 1
117030: PPUSH
117031: LD_EXP 190
117035: PUSH
117036: LD_VAR 0 5
117040: ARRAY
117041: PUSH
117042: LD_INT 0
117044: PLUS
117045: PPUSH
117046: CALL_OW 505
// end ;
117050: LD_VAR 0 3
117054: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
117055: LD_INT 0
117057: PPUSH
117058: PPUSH
117059: PPUSH
117060: PPUSH
// if not hack in hackTanks then
117061: LD_VAR 0 1
117065: PUSH
117066: LD_EXP 189
117070: IN
117071: NOT
117072: IFFALSE 117076
// exit ;
117074: GO 117320
// index := GetElementIndex ( hackTanks , hack ) ;
117076: LD_ADDR_VAR 0 4
117080: PUSH
117081: LD_EXP 189
117085: PPUSH
117086: LD_VAR 0 1
117090: PPUSH
117091: CALL 59336 0 2
117095: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
117096: LD_ADDR_VAR 0 3
117100: PUSH
117101: DOUBLE
117102: LD_EXP 190
117106: PUSH
117107: LD_VAR 0 4
117111: ARRAY
117112: INC
117113: ST_TO_ADDR
117114: LD_INT 1
117116: PUSH
117117: FOR_DOWNTO
117118: IFFALSE 117294
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
117120: LD_ADDR_VAR 0 5
117124: PUSH
117125: LD_EXP 190
117129: PUSH
117130: LD_VAR 0 4
117134: ARRAY
117135: PUSH
117136: LD_VAR 0 3
117140: ARRAY
117141: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
117142: LD_VAR 0 5
117146: PUSH
117147: LD_INT 1
117149: ARRAY
117150: PPUSH
117151: CALL_OW 302
117155: NOT
117156: IFTRUE 117184
117158: PUSH
117159: LD_VAR 0 5
117163: PUSH
117164: LD_INT 1
117166: ARRAY
117167: PPUSH
117168: CALL_OW 255
117172: PUSH
117173: LD_VAR 0 1
117177: PPUSH
117178: CALL_OW 255
117182: NONEQUAL
117183: OR
117184: IFFALSE 117292
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
117186: LD_VAR 0 5
117190: PUSH
117191: LD_INT 1
117193: ARRAY
117194: PPUSH
117195: CALL_OW 305
117199: IFFALSE 117227
117201: PUSH
117202: LD_VAR 0 5
117206: PUSH
117207: LD_INT 1
117209: ARRAY
117210: PPUSH
117211: CALL_OW 255
117215: PUSH
117216: LD_VAR 0 1
117220: PPUSH
117221: CALL_OW 255
117225: EQUAL
117226: AND
117227: IFFALSE 117251
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
117229: LD_VAR 0 5
117233: PUSH
117234: LD_INT 1
117236: ARRAY
117237: PPUSH
117238: LD_VAR 0 5
117242: PUSH
117243: LD_INT 2
117245: ARRAY
117246: PPUSH
117247: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
117251: LD_ADDR_EXP 190
117255: PUSH
117256: LD_EXP 190
117260: PPUSH
117261: LD_VAR 0 4
117265: PPUSH
117266: LD_EXP 190
117270: PUSH
117271: LD_VAR 0 4
117275: ARRAY
117276: PPUSH
117277: LD_VAR 0 3
117281: PPUSH
117282: CALL_OW 3
117286: PPUSH
117287: CALL_OW 1
117291: ST_TO_ADDR
// end ; end ;
117292: GO 117117
117294: POP
117295: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117296: LD_VAR 0 1
117300: PPUSH
117301: LD_EXP 190
117305: PUSH
117306: LD_VAR 0 4
117310: ARRAY
117311: PUSH
117312: LD_INT 0
117314: PLUS
117315: PPUSH
117316: CALL_OW 505
// end ;
117320: LD_VAR 0 2
117324: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
117325: LD_INT 0
117327: PPUSH
117328: PPUSH
117329: PPUSH
117330: PPUSH
// if not hack in hackTanks then
117331: LD_VAR 0 1
117335: PUSH
117336: LD_EXP 189
117340: IN
117341: NOT
117342: IFFALSE 117346
// exit ;
117344: GO 117431
// index := GetElementIndex ( hackTanks , hack ) ;
117346: LD_ADDR_VAR 0 5
117350: PUSH
117351: LD_EXP 189
117355: PPUSH
117356: LD_VAR 0 1
117360: PPUSH
117361: CALL 59336 0 2
117365: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
117366: LD_ADDR_VAR 0 4
117370: PUSH
117371: DOUBLE
117372: LD_INT 1
117374: DEC
117375: ST_TO_ADDR
117376: LD_EXP 190
117380: PUSH
117381: LD_VAR 0 5
117385: ARRAY
117386: PUSH
117387: FOR_TO
117388: IFFALSE 117429
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
117390: LD_EXP 190
117394: PUSH
117395: LD_VAR 0 5
117399: ARRAY
117400: PUSH
117401: LD_VAR 0 4
117405: ARRAY
117406: PUSH
117407: LD_INT 1
117409: ARRAY
117410: PUSH
117411: LD_VAR 0 2
117415: EQUAL
117416: IFFALSE 117427
// KillUnit ( vehicle ) ;
117418: LD_VAR 0 2
117422: PPUSH
117423: CALL_OW 66
117427: GO 117387
117429: POP
117430: POP
// end ;
117431: LD_VAR 0 3
117435: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do var i ;
117436: LD_EXP 194
117440: NOT
117441: IFFALSE 117574
117443: GO 117445
117445: DISABLE
117446: LD_INT 0
117448: PPUSH
// begin initMiner := true ;
117449: LD_ADDR_EXP 194
117453: PUSH
117454: LD_INT 1
117456: ST_TO_ADDR
// minersList := [ ] ;
117457: LD_ADDR_EXP 195
117461: PUSH
117462: EMPTY
117463: ST_TO_ADDR
// minerMinesList := [ ] ;
117464: LD_ADDR_EXP 196
117468: PUSH
117469: EMPTY
117470: ST_TO_ADDR
// minesLimitPerVehicle := 6 ;
117471: LD_ADDR_EXP 197
117475: PUSH
117476: LD_INT 6
117478: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
117479: LD_ADDR_VAR 0 1
117483: PUSH
117484: LD_INT 34
117486: PUSH
117487: LD_INT 81
117489: PUSH
117490: EMPTY
117491: LIST
117492: LIST
117493: PPUSH
117494: CALL_OW 69
117498: PUSH
117499: FOR_IN
117500: IFFALSE 117572
// begin if not i in minersList then
117502: LD_VAR 0 1
117506: PUSH
117507: LD_EXP 195
117511: IN
117512: NOT
117513: IFFALSE 117570
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
117515: LD_ADDR_EXP 195
117519: PUSH
117520: LD_EXP 195
117524: PPUSH
117525: LD_EXP 195
117529: PUSH
117530: LD_INT 1
117532: PLUS
117533: PPUSH
117534: LD_VAR 0 1
117538: PPUSH
117539: CALL_OW 1
117543: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
117544: LD_ADDR_EXP 196
117548: PUSH
117549: LD_EXP 196
117553: PPUSH
117554: LD_EXP 196
117558: PUSH
117559: LD_INT 1
117561: PLUS
117562: PPUSH
117563: EMPTY
117564: PPUSH
117565: CALL_OW 1
117569: ST_TO_ADDR
// end end ;
117570: GO 117499
117572: POP
117573: POP
// end ;
117574: PPOPN 1
117576: END
// every 0 0$1 trigger initMiner and ( Count ( minerMinesList ) or FilterAllUnits ( [ f_weapon , ar_miner ] ) ) do var i , j , side , tmp ;
117577: LD_EXP 194
117581: IFFALSE 117612
117583: PUSH
117584: LD_EXP 196
117588: PPUSH
117589: CALL 56635 0 1
117593: IFTRUE 117611
117595: PUSH
117596: LD_INT 34
117598: PUSH
117599: LD_INT 81
117601: PUSH
117602: EMPTY
117603: LIST
117604: LIST
117605: PPUSH
117606: CALL_OW 69
117610: OR
117611: AND
117612: IFFALSE 118111
117614: GO 117616
117616: DISABLE
117617: LD_INT 0
117619: PPUSH
117620: PPUSH
117621: PPUSH
117622: PPUSH
// begin enable ;
117623: ENABLE
// for i := minerMinesList downto 1 do
117624: LD_ADDR_VAR 0 1
117628: PUSH
117629: DOUBLE
117630: LD_EXP 196
117634: INC
117635: ST_TO_ADDR
117636: LD_INT 1
117638: PUSH
117639: FOR_DOWNTO
117640: IFFALSE 118109
// begin if IsLive ( minersList [ i ] ) then
117642: LD_EXP 195
117646: PUSH
117647: LD_VAR 0 1
117651: ARRAY
117652: PPUSH
117653: CALL_OW 300
117657: IFFALSE 117690
// SetUnitDisplayNumber ( minersList [ i ] , Count ( minerMinesList [ i ] ) ) ;
117659: LD_EXP 195
117663: PUSH
117664: LD_VAR 0 1
117668: ARRAY
117669: PPUSH
117670: LD_EXP 196
117674: PUSH
117675: LD_VAR 0 1
117679: ARRAY
117680: PPUSH
117681: CALL 56635 0 1
117685: PPUSH
117686: CALL_OW 505
// if not minerMinesList [ i ] then
117690: LD_EXP 196
117694: PUSH
117695: LD_VAR 0 1
117699: ARRAY
117700: NOT
117701: IFFALSE 117705
// continue ;
117703: GO 117639
// for j := minerMinesList [ i ] downto 1 do
117705: LD_ADDR_VAR 0 2
117709: PUSH
117710: DOUBLE
117711: LD_EXP 196
117715: PUSH
117716: LD_VAR 0 1
117720: ARRAY
117721: INC
117722: ST_TO_ADDR
117723: LD_INT 1
117725: PUSH
117726: FOR_DOWNTO
117727: IFFALSE 118105
// begin side := GetSide ( minersList [ i ] ) ;
117729: LD_ADDR_VAR 0 3
117733: PUSH
117734: LD_EXP 195
117738: PUSH
117739: LD_VAR 0 1
117743: ARRAY
117744: PPUSH
117745: CALL_OW 255
117749: ST_TO_ADDR
// if IsDead ( minersList [ i ] ) or not IsPlaced ( minersList [ i ] ) then
117750: LD_EXP 195
117754: PUSH
117755: LD_VAR 0 1
117759: ARRAY
117760: PPUSH
117761: CALL_OW 301
117765: IFTRUE 117785
117767: PUSH
117768: LD_EXP 195
117772: PUSH
117773: LD_VAR 0 1
117777: ARRAY
117778: PPUSH
117779: CALL_OW 305
117783: NOT
117784: OR
117785: IFFALSE 117876
// begin RemoveMineXY ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
117787: LD_EXP 196
117791: PUSH
117792: LD_VAR 0 1
117796: ARRAY
117797: PUSH
117798: LD_VAR 0 2
117802: ARRAY
117803: PUSH
117804: LD_INT 1
117806: ARRAY
117807: PPUSH
117808: LD_EXP 196
117812: PUSH
117813: LD_VAR 0 1
117817: ARRAY
117818: PUSH
117819: LD_VAR 0 2
117823: ARRAY
117824: PUSH
117825: LD_INT 2
117827: ARRAY
117828: PPUSH
117829: CALL_OW 612
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
117833: LD_ADDR_EXP 196
117837: PUSH
117838: LD_EXP 196
117842: PPUSH
117843: LD_VAR 0 1
117847: PPUSH
117848: LD_EXP 196
117852: PUSH
117853: LD_VAR 0 1
117857: ARRAY
117858: PPUSH
117859: LD_VAR 0 2
117863: PPUSH
117864: CALL_OW 3
117868: PPUSH
117869: CALL_OW 1
117873: ST_TO_ADDR
// continue ;
117874: GO 117726
// end ; tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
117876: LD_ADDR_VAR 0 4
117880: PUSH
117881: LD_EXP 196
117885: PUSH
117886: LD_VAR 0 1
117890: ARRAY
117891: PUSH
117892: LD_VAR 0 2
117896: ARRAY
117897: PUSH
117898: LD_INT 1
117900: ARRAY
117901: PPUSH
117902: LD_EXP 196
117906: PUSH
117907: LD_VAR 0 1
117911: ARRAY
117912: PUSH
117913: LD_VAR 0 2
117917: ARRAY
117918: PUSH
117919: LD_INT 2
117921: ARRAY
117922: PPUSH
117923: CALL_OW 428
117927: ST_TO_ADDR
// if not tmp then
117928: LD_VAR 0 4
117932: NOT
117933: IFFALSE 117937
// continue ;
117935: GO 117726
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
117937: LD_VAR 0 4
117941: PUSH
117942: LD_INT 81
117944: PUSH
117945: LD_VAR 0 3
117949: PUSH
117950: EMPTY
117951: LIST
117952: LIST
117953: PPUSH
117954: CALL_OW 69
117958: IN
117959: IFFALSE 118009
117961: PUSH
117962: LD_EXP 196
117966: PUSH
117967: LD_VAR 0 1
117971: ARRAY
117972: PUSH
117973: LD_VAR 0 2
117977: ARRAY
117978: PUSH
117979: LD_INT 1
117981: ARRAY
117982: PPUSH
117983: LD_EXP 196
117987: PUSH
117988: LD_VAR 0 1
117992: ARRAY
117993: PUSH
117994: LD_VAR 0 2
117998: ARRAY
117999: PUSH
118000: LD_INT 2
118002: ARRAY
118003: PPUSH
118004: CALL_OW 458
118008: AND
118009: IFFALSE 118103
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
118011: LD_EXP 196
118015: PUSH
118016: LD_VAR 0 1
118020: ARRAY
118021: PUSH
118022: LD_VAR 0 2
118026: ARRAY
118027: PUSH
118028: LD_INT 1
118030: ARRAY
118031: PPUSH
118032: LD_EXP 196
118036: PUSH
118037: LD_VAR 0 1
118041: ARRAY
118042: PUSH
118043: LD_VAR 0 2
118047: ARRAY
118048: PUSH
118049: LD_INT 2
118051: ARRAY
118052: PPUSH
118053: LD_VAR 0 3
118057: PPUSH
118058: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
118062: LD_ADDR_EXP 196
118066: PUSH
118067: LD_EXP 196
118071: PPUSH
118072: LD_VAR 0 1
118076: PPUSH
118077: LD_EXP 196
118081: PUSH
118082: LD_VAR 0 1
118086: ARRAY
118087: PPUSH
118088: LD_VAR 0 2
118092: PPUSH
118093: CALL_OW 3
118097: PPUSH
118098: CALL_OW 1
118102: ST_TO_ADDR
// end ; end ;
118103: GO 117726
118105: POP
118106: POP
// end ;
118107: GO 117639
118109: POP
118110: POP
// end ;
118111: PPOPN 4
118113: END
// export function MinerPlaceMine ( unit , x , y ) ; var index , side , i ; begin
118114: LD_INT 0
118116: PPUSH
118117: PPUSH
118118: PPUSH
118119: PPUSH
// result := false ;
118120: LD_ADDR_VAR 0 4
118124: PUSH
118125: LD_INT 0
118127: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
118128: LD_VAR 0 1
118132: PPUSH
118133: CALL_OW 264
118137: PUSH
118138: LD_INT 81
118140: EQUAL
118141: NOT
118142: IFFALSE 118146
// exit ;
118144: GO 118516
// side := GetSide ( unit ) ;
118146: LD_ADDR_VAR 0 6
118150: PUSH
118151: LD_VAR 0 1
118155: PPUSH
118156: CALL_OW 255
118160: ST_TO_ADDR
// index := GetElementIndex ( minersList , unit ) ;
118161: LD_ADDR_VAR 0 5
118165: PUSH
118166: LD_EXP 195
118170: PPUSH
118171: LD_VAR 0 1
118175: PPUSH
118176: CALL 59336 0 2
118180: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
118181: LD_EXP 196
118185: PUSH
118186: LD_VAR 0 5
118190: ARRAY
118191: PUSH
118192: LD_EXP 197
118196: GREATEREQUAL
118197: IFFALSE 118201
// exit ;
118199: GO 118516
// ComMoveXY ( unit , x , y ) ;
118201: LD_VAR 0 1
118205: PPUSH
118206: LD_VAR 0 2
118210: PPUSH
118211: LD_VAR 0 3
118215: PPUSH
118216: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
118220: LD_INT 35
118222: PPUSH
118223: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
118227: LD_VAR 0 1
118231: PPUSH
118232: LD_VAR 0 2
118236: PPUSH
118237: LD_VAR 0 3
118241: PPUSH
118242: CALL 91382 0 3
118246: NOT
118247: IFFALSE 118260
118249: PUSH
118250: LD_VAR 0 1
118254: PPUSH
118255: CALL_OW 314
118259: AND
118260: IFFALSE 118264
// exit ;
118262: GO 118516
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
118264: LD_VAR 0 2
118268: PPUSH
118269: LD_VAR 0 3
118273: PPUSH
118274: CALL_OW 428
118278: PUSH
118279: LD_VAR 0 1
118283: EQUAL
118284: IFFALSE 118298
118286: PUSH
118287: LD_VAR 0 1
118291: PPUSH
118292: CALL_OW 314
118296: NOT
118297: AND
118298: IFFALSE 118220
// if MineAtPos ( x , y ) then
118300: LD_VAR 0 2
118304: PPUSH
118305: LD_VAR 0 3
118309: PPUSH
118310: CALL_OW 458
118314: IFFALSE 118318
// exit ;
118316: GO 118516
// if your_side = side then
118318: LD_OWVAR 2
118322: PUSH
118323: LD_VAR 0 6
118327: EQUAL
118328: IFFALSE 118347
// PlaySoundXY ( x , y , PlantMine ) ;
118330: LD_VAR 0 2
118334: PPUSH
118335: LD_VAR 0 3
118339: PPUSH
118340: LD_STRING PlantMine
118342: PPUSH
118343: CALL_OW 366
// repeat wait ( 1 ) ;
118347: LD_INT 1
118349: PPUSH
118350: CALL_OW 67
// until PlaceMine ( x , y , side , 0 ) ;
118354: LD_VAR 0 2
118358: PPUSH
118359: LD_VAR 0 3
118363: PPUSH
118364: LD_VAR 0 6
118368: PPUSH
118369: LD_INT 0
118371: PPUSH
118372: CALL_OW 454
118376: IFFALSE 118347
// if MineAtPos ( x , y ) then
118378: LD_VAR 0 2
118382: PPUSH
118383: LD_VAR 0 3
118387: PPUSH
118388: CALL_OW 458
118392: IFFALSE 118508
// begin for i in minerMinesList [ index ] do
118394: LD_ADDR_VAR 0 7
118398: PUSH
118399: LD_EXP 196
118403: PUSH
118404: LD_VAR 0 5
118408: ARRAY
118409: PUSH
118410: FOR_IN
118411: IFFALSE 118453
// if i [ 1 ] = x and i [ 2 ] = y then
118413: LD_VAR 0 7
118417: PUSH
118418: LD_INT 1
118420: ARRAY
118421: PUSH
118422: LD_VAR 0 2
118426: EQUAL
118427: IFFALSE 118445
118429: PUSH
118430: LD_VAR 0 7
118434: PUSH
118435: LD_INT 2
118437: ARRAY
118438: PUSH
118439: LD_VAR 0 3
118443: EQUAL
118444: AND
118445: IFFALSE 118451
// exit ;
118447: POP
118448: POP
118449: GO 118516
118451: GO 118410
118453: POP
118454: POP
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
118455: LD_ADDR_EXP 196
118459: PUSH
118460: LD_EXP 196
118464: PPUSH
118465: LD_VAR 0 5
118469: PUSH
118470: LD_EXP 196
118474: PUSH
118475: LD_VAR 0 5
118479: ARRAY
118480: PUSH
118481: LD_INT 1
118483: PLUS
118484: PUSH
118485: EMPTY
118486: LIST
118487: LIST
118488: PPUSH
118489: LD_VAR 0 2
118493: PUSH
118494: LD_VAR 0 3
118498: PUSH
118499: EMPTY
118500: LIST
118501: LIST
118502: PPUSH
118503: CALL 59553 0 3
118507: ST_TO_ADDR
// end ; result := true ;
118508: LD_ADDR_VAR 0 4
118512: PUSH
118513: LD_INT 1
118515: ST_TO_ADDR
// end ;
118516: LD_VAR 0 4
118520: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
118521: LD_INT 0
118523: PPUSH
118524: PPUSH
118525: PPUSH
// if not unit in minersList then
118526: LD_VAR 0 1
118530: PUSH
118531: LD_EXP 195
118535: IN
118536: NOT
118537: IFFALSE 118541
// exit ;
118539: GO 118748
// index := GetElementIndex ( minersList , unit ) ;
118541: LD_ADDR_VAR 0 6
118545: PUSH
118546: LD_EXP 195
118550: PPUSH
118551: LD_VAR 0 1
118555: PPUSH
118556: CALL 59336 0 2
118560: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
118561: LD_ADDR_VAR 0 5
118565: PUSH
118566: DOUBLE
118567: LD_EXP 196
118571: PUSH
118572: LD_VAR 0 6
118576: ARRAY
118577: INC
118578: ST_TO_ADDR
118579: LD_INT 1
118581: PUSH
118582: FOR_DOWNTO
118583: IFFALSE 118746
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
118585: LD_EXP 196
118589: PUSH
118590: LD_VAR 0 6
118594: ARRAY
118595: PUSH
118596: LD_VAR 0 5
118600: ARRAY
118601: PUSH
118602: LD_INT 1
118604: ARRAY
118605: PPUSH
118606: LD_EXP 196
118610: PUSH
118611: LD_VAR 0 6
118615: ARRAY
118616: PUSH
118617: LD_VAR 0 5
118621: ARRAY
118622: PUSH
118623: LD_INT 2
118625: ARRAY
118626: PPUSH
118627: LD_VAR 0 2
118631: PPUSH
118632: LD_VAR 0 3
118636: PPUSH
118637: CALL_OW 298
118641: PUSH
118642: LD_INT 6
118644: LESS
118645: IFFALSE 118744
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
118647: LD_EXP 196
118651: PUSH
118652: LD_VAR 0 6
118656: ARRAY
118657: PUSH
118658: LD_VAR 0 5
118662: ARRAY
118663: PUSH
118664: LD_INT 1
118666: ARRAY
118667: PPUSH
118668: LD_EXP 196
118672: PUSH
118673: LD_VAR 0 6
118677: ARRAY
118678: PUSH
118679: LD_VAR 0 5
118683: ARRAY
118684: PUSH
118685: LD_INT 2
118687: ARRAY
118688: PPUSH
118689: LD_VAR 0 1
118693: PPUSH
118694: CALL_OW 255
118698: PPUSH
118699: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118703: LD_ADDR_EXP 196
118707: PUSH
118708: LD_EXP 196
118712: PPUSH
118713: LD_VAR 0 6
118717: PPUSH
118718: LD_EXP 196
118722: PUSH
118723: LD_VAR 0 6
118727: ARRAY
118728: PPUSH
118729: LD_VAR 0 5
118733: PPUSH
118734: CALL_OW 3
118738: PPUSH
118739: CALL_OW 1
118743: ST_TO_ADDR
// end ; end ;
118744: GO 118582
118746: POP
118747: POP
// end ;
118748: LD_VAR 0 4
118752: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
118753: LD_INT 0
118755: PPUSH
118756: PPUSH
118757: PPUSH
118758: PPUSH
118759: PPUSH
118760: PPUSH
118761: PPUSH
118762: PPUSH
118763: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
118764: LD_VAR 0 1
118768: PPUSH
118769: CALL_OW 264
118773: PUSH
118774: LD_INT 81
118776: EQUAL
118777: NOT
118778: IFTRUE 118793
118780: PUSH
118781: LD_VAR 0 1
118785: PUSH
118786: LD_EXP 195
118790: IN
118791: NOT
118792: OR
118793: IFFALSE 118797
// exit ;
118795: GO 119123
// index := GetElementIndex ( minersList , unit ) ;
118797: LD_ADDR_VAR 0 6
118801: PUSH
118802: LD_EXP 195
118806: PPUSH
118807: LD_VAR 0 1
118811: PPUSH
118812: CALL 59336 0 2
118816: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
118817: LD_ADDR_VAR 0 8
118821: PUSH
118822: LD_EXP 197
118826: PUSH
118827: LD_EXP 196
118831: PUSH
118832: LD_VAR 0 6
118836: ARRAY
118837: MINUS
118838: ST_TO_ADDR
// if not minesFreeAmount then
118839: LD_VAR 0 8
118843: NOT
118844: IFFALSE 118848
// exit ;
118846: GO 119123
// tmp := [ ] ;
118848: LD_ADDR_VAR 0 7
118852: PUSH
118853: EMPTY
118854: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
118855: LD_ADDR_VAR 0 5
118859: PUSH
118860: DOUBLE
118861: LD_INT 1
118863: DEC
118864: ST_TO_ADDR
118865: LD_VAR 0 8
118869: PUSH
118870: FOR_TO
118871: IFFALSE 119070
// begin _d := rand ( 0 , 5 ) ;
118873: LD_ADDR_VAR 0 11
118877: PUSH
118878: LD_INT 0
118880: PPUSH
118881: LD_INT 5
118883: PPUSH
118884: CALL_OW 12
118888: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
118889: LD_ADDR_VAR 0 12
118893: PUSH
118894: LD_INT 2
118896: PPUSH
118897: LD_INT 6
118899: PPUSH
118900: CALL_OW 12
118904: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
118905: LD_ADDR_VAR 0 9
118909: PUSH
118910: LD_VAR 0 2
118914: PPUSH
118915: LD_VAR 0 11
118919: PPUSH
118920: LD_VAR 0 12
118924: PPUSH
118925: CALL_OW 272
118929: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
118930: LD_ADDR_VAR 0 10
118934: PUSH
118935: LD_VAR 0 3
118939: PPUSH
118940: LD_VAR 0 11
118944: PPUSH
118945: LD_VAR 0 12
118949: PPUSH
118950: CALL_OW 273
118954: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
118955: LD_VAR 0 9
118959: PPUSH
118960: LD_VAR 0 10
118964: PPUSH
118965: CALL_OW 488
118969: IFFALSE 118993
118971: PUSH
118972: LD_VAR 0 9
118976: PUSH
118977: LD_VAR 0 10
118981: PUSH
118982: EMPTY
118983: LIST
118984: LIST
118985: PUSH
118986: LD_VAR 0 7
118990: IN
118991: NOT
118992: AND
118993: IFFALSE 119012
118995: PUSH
118996: LD_VAR 0 9
119000: PPUSH
119001: LD_VAR 0 10
119005: PPUSH
119006: CALL_OW 458
119010: NOT
119011: AND
119012: IFFALSE 119054
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
119014: LD_ADDR_VAR 0 7
119018: PUSH
119019: LD_VAR 0 7
119023: PPUSH
119024: LD_VAR 0 7
119028: PUSH
119029: LD_INT 1
119031: PLUS
119032: PPUSH
119033: LD_VAR 0 9
119037: PUSH
119038: LD_VAR 0 10
119042: PUSH
119043: EMPTY
119044: LIST
119045: LIST
119046: PPUSH
119047: CALL_OW 1
119051: ST_TO_ADDR
119052: GO 119068
// i := i - 1 ;
119054: LD_ADDR_VAR 0 5
119058: PUSH
119059: LD_VAR 0 5
119063: PUSH
119064: LD_INT 1
119066: MINUS
119067: ST_TO_ADDR
// end ;
119068: GO 118870
119070: POP
119071: POP
// for i in tmp do
119072: LD_ADDR_VAR 0 5
119076: PUSH
119077: LD_VAR 0 7
119081: PUSH
119082: FOR_IN
119083: IFFALSE 119121
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
119085: LD_VAR 0 1
119089: PPUSH
119090: LD_VAR 0 5
119094: PUSH
119095: LD_INT 1
119097: ARRAY
119098: PPUSH
119099: LD_VAR 0 5
119103: PUSH
119104: LD_INT 2
119106: ARRAY
119107: PPUSH
119108: CALL 118114 0 3
119112: NOT
119113: IFFALSE 119119
// exit ;
119115: POP
119116: POP
119117: GO 119123
119119: GO 119082
119121: POP
119122: POP
// end ;
119123: LD_VAR 0 4
119127: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
119128: LD_INT 0
119130: PPUSH
119131: PPUSH
119132: PPUSH
119133: PPUSH
119134: PPUSH
119135: PPUSH
119136: PPUSH
119137: PPUSH
119138: PPUSH
// if GetClass ( unit ) <> class_sniper then
119139: LD_VAR 0 1
119143: PPUSH
119144: CALL_OW 257
119148: PUSH
119149: LD_INT 5
119151: NONEQUAL
119152: IFFALSE 119156
// exit ;
119154: GO 119626
// dist := 8 ;
119156: LD_ADDR_VAR 0 5
119160: PUSH
119161: LD_INT 8
119163: ST_TO_ADDR
// viewRange := 12 ;
119164: LD_ADDR_VAR 0 8
119168: PUSH
119169: LD_INT 12
119171: ST_TO_ADDR
// side := GetSide ( unit ) ;
119172: LD_ADDR_VAR 0 6
119176: PUSH
119177: LD_VAR 0 1
119181: PPUSH
119182: CALL_OW 255
119186: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
119187: LD_INT 61
119189: PPUSH
119190: LD_VAR 0 6
119194: PPUSH
119195: CALL_OW 321
119199: PUSH
119200: LD_INT 2
119202: EQUAL
119203: IFFALSE 119213
// viewRange := 16 ;
119205: LD_ADDR_VAR 0 8
119209: PUSH
119210: LD_INT 16
119212: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
119213: LD_VAR 0 1
119217: PPUSH
119218: LD_VAR 0 2
119222: PPUSH
119223: LD_VAR 0 3
119227: PPUSH
119228: CALL_OW 297
119232: PUSH
119233: LD_VAR 0 5
119237: GREATER
119238: IFFALSE 119317
// begin ComMoveXY ( unit , x , y ) ;
119240: LD_VAR 0 1
119244: PPUSH
119245: LD_VAR 0 2
119249: PPUSH
119250: LD_VAR 0 3
119254: PPUSH
119255: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
119259: LD_INT 35
119261: PPUSH
119262: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
119266: LD_VAR 0 1
119270: PPUSH
119271: LD_VAR 0 2
119275: PPUSH
119276: LD_VAR 0 3
119280: PPUSH
119281: CALL 91382 0 3
119285: NOT
119286: IFFALSE 119290
// exit ;
119288: GO 119626
// until GetDistUnitXY ( unit , x , y ) < dist ;
119290: LD_VAR 0 1
119294: PPUSH
119295: LD_VAR 0 2
119299: PPUSH
119300: LD_VAR 0 3
119304: PPUSH
119305: CALL_OW 297
119309: PUSH
119310: LD_VAR 0 5
119314: LESS
119315: IFFALSE 119259
// end ; ComTurnXY ( unit , x , y ) ;
119317: LD_VAR 0 1
119321: PPUSH
119322: LD_VAR 0 2
119326: PPUSH
119327: LD_VAR 0 3
119331: PPUSH
119332: CALL_OW 118
// repeat if Multiplayer then
119336: LD_OWVAR 4
119340: IFFALSE 119351
// wait ( 35 ) else
119342: LD_INT 35
119344: PPUSH
119345: CALL_OW 67
119349: GO 119358
// wait ( 5 ) ;
119351: LD_INT 5
119353: PPUSH
119354: CALL_OW 67
// _d := GetDir ( unit ) ;
119358: LD_ADDR_VAR 0 11
119362: PUSH
119363: LD_VAR 0 1
119367: PPUSH
119368: CALL_OW 254
119372: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
119373: LD_ADDR_VAR 0 7
119377: PUSH
119378: LD_VAR 0 1
119382: PPUSH
119383: CALL_OW 250
119387: PPUSH
119388: LD_VAR 0 1
119392: PPUSH
119393: CALL_OW 251
119397: PPUSH
119398: LD_VAR 0 2
119402: PPUSH
119403: LD_VAR 0 3
119407: PPUSH
119408: CALL 94018 0 4
119412: ST_TO_ADDR
// until dir = _d ;
119413: LD_VAR 0 7
119417: PUSH
119418: LD_VAR 0 11
119422: EQUAL
119423: IFFALSE 119336
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
119425: LD_ADDR_VAR 0 9
119429: PUSH
119430: LD_VAR 0 1
119434: PPUSH
119435: CALL_OW 250
119439: PPUSH
119440: LD_VAR 0 7
119444: PPUSH
119445: LD_VAR 0 5
119449: PPUSH
119450: CALL_OW 272
119454: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
119455: LD_ADDR_VAR 0 10
119459: PUSH
119460: LD_VAR 0 1
119464: PPUSH
119465: CALL_OW 251
119469: PPUSH
119470: LD_VAR 0 7
119474: PPUSH
119475: LD_VAR 0 5
119479: PPUSH
119480: CALL_OW 273
119484: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
119485: LD_VAR 0 9
119489: PPUSH
119490: LD_VAR 0 10
119494: PPUSH
119495: CALL_OW 488
119499: NOT
119500: IFFALSE 119504
// exit ;
119502: GO 119626
// ComAnimCustom ( unit , 1 ) ;
119504: LD_VAR 0 1
119508: PPUSH
119509: LD_INT 1
119511: PPUSH
119512: CALL_OW 592
// p := 0 ;
119516: LD_ADDR_VAR 0 12
119520: PUSH
119521: LD_INT 0
119523: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
119524: LD_VAR 0 9
119528: PPUSH
119529: LD_VAR 0 10
119533: PPUSH
119534: LD_VAR 0 6
119538: PPUSH
119539: LD_VAR 0 8
119543: PPUSH
119544: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
119548: LD_INT 35
119550: PPUSH
119551: CALL_OW 67
// p := Inc ( p ) ;
119555: LD_ADDR_VAR 0 12
119559: PUSH
119560: LD_VAR 0 12
119564: PPUSH
119565: CALL 93974 0 1
119569: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
119570: LD_VAR 0 12
119574: PUSH
119575: LD_INT 3
119577: EQUAL
119578: IFTRUE 119592
119580: PUSH
119581: LD_VAR 0 1
119585: PPUSH
119586: CALL_OW 302
119590: NOT
119591: OR
119592: IFTRUE 119605
119594: PUSH
119595: LD_VAR 0 1
119599: PPUSH
119600: CALL_OW 301
119604: OR
119605: IFFALSE 119548
// RemoveSeeing ( _x , _y , side ) ;
119607: LD_VAR 0 9
119611: PPUSH
119612: LD_VAR 0 10
119616: PPUSH
119617: LD_VAR 0 6
119621: PPUSH
119622: CALL_OW 331
// end ;
119626: LD_VAR 0 4
119630: RET
// function RevealDetectorMine ( unit ) ; var side , r , x , y , min_x , min_y , max_x , max_y , _x , _y ; begin
119631: LD_INT 0
119633: PPUSH
119634: PPUSH
119635: PPUSH
119636: PPUSH
119637: PPUSH
119638: PPUSH
119639: PPUSH
119640: PPUSH
119641: PPUSH
119642: PPUSH
119643: PPUSH
// if not unit then
119644: LD_VAR 0 1
119648: NOT
119649: IFFALSE 119653
// exit ;
119651: GO 119924
// side := GetSide ( unit ) ;
119653: LD_ADDR_VAR 0 3
119657: PUSH
119658: LD_VAR 0 1
119662: PPUSH
119663: CALL_OW 255
119667: ST_TO_ADDR
// x := GetX ( unit ) ;
119668: LD_ADDR_VAR 0 5
119672: PUSH
119673: LD_VAR 0 1
119677: PPUSH
119678: CALL_OW 250
119682: ST_TO_ADDR
// y := GetY ( unit ) ;
119683: LD_ADDR_VAR 0 6
119687: PUSH
119688: LD_VAR 0 1
119692: PPUSH
119693: CALL_OW 251
119697: ST_TO_ADDR
// r := 8 ;
119698: LD_ADDR_VAR 0 4
119702: PUSH
119703: LD_INT 8
119705: ST_TO_ADDR
// if x - r < 0 then
119706: LD_VAR 0 5
119710: PUSH
119711: LD_VAR 0 4
119715: MINUS
119716: PUSH
119717: LD_INT 0
119719: LESS
119720: IFFALSE 119732
// min_x := 0 else
119722: LD_ADDR_VAR 0 7
119726: PUSH
119727: LD_INT 0
119729: ST_TO_ADDR
119730: GO 119748
// min_x := x - r ;
119732: LD_ADDR_VAR 0 7
119736: PUSH
119737: LD_VAR 0 5
119741: PUSH
119742: LD_VAR 0 4
119746: MINUS
119747: ST_TO_ADDR
// if y - r < 0 then
119748: LD_VAR 0 6
119752: PUSH
119753: LD_VAR 0 4
119757: MINUS
119758: PUSH
119759: LD_INT 0
119761: LESS
119762: IFFALSE 119774
// min_y := 0 else
119764: LD_ADDR_VAR 0 8
119768: PUSH
119769: LD_INT 0
119771: ST_TO_ADDR
119772: GO 119790
// min_y := y - r ;
119774: LD_ADDR_VAR 0 8
119778: PUSH
119779: LD_VAR 0 6
119783: PUSH
119784: LD_VAR 0 4
119788: MINUS
119789: ST_TO_ADDR
// max_x := x + r ;
119790: LD_ADDR_VAR 0 9
119794: PUSH
119795: LD_VAR 0 5
119799: PUSH
119800: LD_VAR 0 4
119804: PLUS
119805: ST_TO_ADDR
// max_y := y + r ;
119806: LD_ADDR_VAR 0 10
119810: PUSH
119811: LD_VAR 0 6
119815: PUSH
119816: LD_VAR 0 4
119820: PLUS
119821: ST_TO_ADDR
// for _x = min_x to max_x do
119822: LD_ADDR_VAR 0 11
119826: PUSH
119827: DOUBLE
119828: LD_VAR 0 7
119832: DEC
119833: ST_TO_ADDR
119834: LD_VAR 0 9
119838: PUSH
119839: FOR_TO
119840: IFFALSE 119922
// for _y = min_y to max_y do
119842: LD_ADDR_VAR 0 12
119846: PUSH
119847: DOUBLE
119848: LD_VAR 0 8
119852: DEC
119853: ST_TO_ADDR
119854: LD_VAR 0 10
119858: PUSH
119859: FOR_TO
119860: IFFALSE 119918
// begin if not ValidHex ( _x , _y ) then
119862: LD_VAR 0 11
119866: PPUSH
119867: LD_VAR 0 12
119871: PPUSH
119872: CALL_OW 488
119876: NOT
119877: IFFALSE 119881
// continue ;
119879: GO 119859
// if MineAtPos ( _x , _y ) then
119881: LD_VAR 0 11
119885: PPUSH
119886: LD_VAR 0 12
119890: PPUSH
119891: CALL_OW 458
119895: IFFALSE 119916
// ViewMineAtPos ( _x , _y , side ) ;
119897: LD_VAR 0 11
119901: PPUSH
119902: LD_VAR 0 12
119906: PPUSH
119907: LD_VAR 0 3
119911: PPUSH
119912: CALL_OW 457
// end ;
119916: GO 119859
119918: POP
119919: POP
119920: GO 119839
119922: POP
119923: POP
// end ;
119924: LD_VAR 0 2
119928: RET
// function DetectMine ( units ) ; var i , x , y , scaners , timer ; begin
119929: LD_INT 0
119931: PPUSH
119932: PPUSH
119933: PPUSH
119934: PPUSH
119935: PPUSH
119936: PPUSH
// if not units then
119937: LD_VAR 0 1
119941: NOT
119942: IFFALSE 119946
// exit ;
119944: GO 120376
// scaners := [ ] ;
119946: LD_ADDR_VAR 0 6
119950: PUSH
119951: EMPTY
119952: ST_TO_ADDR
// for i in units do
119953: LD_ADDR_VAR 0 3
119957: PUSH
119958: LD_VAR 0 1
119962: PUSH
119963: FOR_IN
119964: IFFALSE 120121
// begin if GetWeapon ( i ) <> us_radar or not IsOk ( i ) or GetTag ( i ) = tMineDetector then
119966: LD_VAR 0 3
119970: PPUSH
119971: CALL_OW 264
119975: PUSH
119976: LD_INT 11
119978: NONEQUAL
119979: IFTRUE 119993
119981: PUSH
119982: LD_VAR 0 3
119986: PPUSH
119987: CALL_OW 302
119991: NOT
119992: OR
119993: IFTRUE 120010
119995: PUSH
119996: LD_VAR 0 3
120000: PPUSH
120001: CALL_OW 110
120005: PUSH
120006: LD_INT 502
120008: EQUAL
120009: OR
120010: IFFALSE 120014
// continue ;
120012: GO 119963
// ComStop ( i ) ;
120014: LD_VAR 0 3
120018: PPUSH
120019: CALL_OW 141
// x := GetX ( i ) ;
120023: LD_ADDR_VAR 0 4
120027: PUSH
120028: LD_VAR 0 3
120032: PPUSH
120033: CALL_OW 250
120037: ST_TO_ADDR
// y := GetY ( i ) ;
120038: LD_ADDR_VAR 0 5
120042: PUSH
120043: LD_VAR 0 3
120047: PPUSH
120048: CALL_OW 251
120052: ST_TO_ADDR
// if GetSide ( i ) = your_side then
120053: LD_VAR 0 3
120057: PPUSH
120058: CALL_OW 255
120062: PUSH
120063: LD_OWVAR 2
120067: EQUAL
120068: IFFALSE 120087
// PlaySoundXY ( x , y , mineDetector ) ;
120070: LD_VAR 0 4
120074: PPUSH
120075: LD_VAR 0 5
120079: PPUSH
120080: LD_STRING mineDetector
120082: PPUSH
120083: CALL_OW 366
// scaners := Join ( scaners , i ) ;
120087: LD_ADDR_VAR 0 6
120091: PUSH
120092: LD_VAR 0 6
120096: PPUSH
120097: LD_VAR 0 3
120101: PPUSH
120102: CALL 92601 0 2
120106: ST_TO_ADDR
// SetTag ( i , tMineDetector ) ;
120107: LD_VAR 0 3
120111: PPUSH
120112: LD_INT 502
120114: PPUSH
120115: CALL_OW 109
// end ;
120119: GO 119963
120121: POP
120122: POP
// if not scaners then
120123: LD_VAR 0 6
120127: NOT
120128: IFFALSE 120132
// exit ;
120130: GO 120376
// wait ( 3 ) ;
120132: LD_INT 3
120134: PPUSH
120135: CALL_OW 67
// timer := 6 ;
120139: LD_ADDR_VAR 0 7
120143: PUSH
120144: LD_INT 6
120146: ST_TO_ADDR
// repeat for i in scaners do
120147: LD_ADDR_VAR 0 3
120151: PUSH
120152: LD_VAR 0 6
120156: PUSH
120157: FOR_IN
120158: IFFALSE 120274
// begin if not IsOk ( i ) or HasTask ( i ) or ( GetControl ( i ) = control_manual and not IsDrivenBy ( i ) ) then
120160: LD_VAR 0 3
120164: PPUSH
120165: CALL_OW 302
120169: NOT
120170: IFTRUE 120183
120172: PUSH
120173: LD_VAR 0 3
120177: PPUSH
120178: CALL_OW 314
120182: OR
120183: IFTRUE 120214
120185: PUSH
120186: LD_VAR 0 3
120190: PPUSH
120191: CALL_OW 263
120195: PUSH
120196: LD_INT 1
120198: EQUAL
120199: IFFALSE 120213
120201: PUSH
120202: LD_VAR 0 3
120206: PPUSH
120207: CALL_OW 311
120211: NOT
120212: AND
120213: OR
120214: IFFALSE 120258
// begin SetUnitDisplayNumber ( i , 0 ) ;
120216: LD_VAR 0 3
120220: PPUSH
120221: LD_INT 0
120223: PPUSH
120224: CALL_OW 505
// SetTag ( i , 0 ) ;
120228: LD_VAR 0 3
120232: PPUSH
120233: LD_INT 0
120235: PPUSH
120236: CALL_OW 109
// scaners := scaners diff i ;
120240: LD_ADDR_VAR 0 6
120244: PUSH
120245: LD_VAR 0 6
120249: PUSH
120250: LD_VAR 0 3
120254: DIFF
120255: ST_TO_ADDR
// continue ;
120256: GO 120157
// end ; SetUnitDisplayNumber ( i , timer ) ;
120258: LD_VAR 0 3
120262: PPUSH
120263: LD_VAR 0 7
120267: PPUSH
120268: CALL_OW 505
// end ;
120272: GO 120157
120274: POP
120275: POP
// if not scaners then
120276: LD_VAR 0 6
120280: NOT
120281: IFFALSE 120285
// exit ;
120283: GO 120376
// timer := Dec ( timer ) ;
120285: LD_ADDR_VAR 0 7
120289: PUSH
120290: LD_VAR 0 7
120294: PPUSH
120295: CALL 93996 0 1
120299: ST_TO_ADDR
// wait ( 0 0$1 ) ;
120300: LD_INT 35
120302: PPUSH
120303: CALL_OW 67
// until timer = 0 ;
120307: LD_VAR 0 7
120311: PUSH
120312: LD_INT 0
120314: EQUAL
120315: IFFALSE 120147
// if not scaners then
120317: LD_VAR 0 6
120321: NOT
120322: IFFALSE 120326
// exit ;
120324: GO 120376
// for i in scaners do
120326: LD_ADDR_VAR 0 3
120330: PUSH
120331: LD_VAR 0 6
120335: PUSH
120336: FOR_IN
120337: IFFALSE 120374
// begin SetUnitDisplayNumber ( i , 0 ) ;
120339: LD_VAR 0 3
120343: PPUSH
120344: LD_INT 0
120346: PPUSH
120347: CALL_OW 505
// SetTag ( i , 0 ) ;
120351: LD_VAR 0 3
120355: PPUSH
120356: LD_INT 0
120358: PPUSH
120359: CALL_OW 109
// RevealDetectorMine ( i ) ;
120363: LD_VAR 0 3
120367: PPUSH
120368: CALL 119631 0 1
// end ;
120372: GO 120336
120374: POP
120375: POP
// end ;
120376: LD_VAR 0 2
120380: RET
// export function SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ; begin
120381: LD_INT 0
120383: PPUSH
// if p1 = mine_detector_mode then
120384: LD_VAR 0 2
120388: PUSH
120389: LD_INT 103
120391: EQUAL
120392: IFFALSE 120403
// DetectMine ( units ) ;
120394: LD_VAR 0 1
120398: PPUSH
120399: CALL 119929 0 1
// end ; end_of_file
120403: LD_VAR 0 7
120407: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
120408: LD_INT 0
120410: PPUSH
120411: PPUSH
120412: PPUSH
120413: PPUSH
120414: PPUSH
120415: PPUSH
120416: PPUSH
120417: PPUSH
120418: PPUSH
120419: PPUSH
120420: PPUSH
120421: PPUSH
120422: PPUSH
120423: PPUSH
120424: PPUSH
120425: PPUSH
120426: PPUSH
120427: PPUSH
120428: PPUSH
120429: PPUSH
120430: PPUSH
120431: PPUSH
120432: PPUSH
120433: PPUSH
120434: PPUSH
120435: PPUSH
120436: PPUSH
120437: PPUSH
120438: PPUSH
120439: PPUSH
120440: PPUSH
120441: PPUSH
120442: PPUSH
120443: PPUSH
// if not list then
120444: LD_VAR 0 1
120448: NOT
120449: IFFALSE 120453
// exit ;
120451: GO 125172
// base := list [ 1 ] ;
120453: LD_ADDR_VAR 0 3
120457: PUSH
120458: LD_VAR 0 1
120462: PUSH
120463: LD_INT 1
120465: ARRAY
120466: ST_TO_ADDR
// group := list [ 2 ] ;
120467: LD_ADDR_VAR 0 4
120471: PUSH
120472: LD_VAR 0 1
120476: PUSH
120477: LD_INT 2
120479: ARRAY
120480: ST_TO_ADDR
// path := list [ 3 ] ;
120481: LD_ADDR_VAR 0 5
120485: PUSH
120486: LD_VAR 0 1
120490: PUSH
120491: LD_INT 3
120493: ARRAY
120494: ST_TO_ADDR
// flags := list [ 4 ] ;
120495: LD_ADDR_VAR 0 6
120499: PUSH
120500: LD_VAR 0 1
120504: PUSH
120505: LD_INT 4
120507: ARRAY
120508: ST_TO_ADDR
// mined := [ ] ;
120509: LD_ADDR_VAR 0 27
120513: PUSH
120514: EMPTY
120515: ST_TO_ADDR
// bombed := [ ] ;
120516: LD_ADDR_VAR 0 28
120520: PUSH
120521: EMPTY
120522: ST_TO_ADDR
// healers := [ ] ;
120523: LD_ADDR_VAR 0 31
120527: PUSH
120528: EMPTY
120529: ST_TO_ADDR
// to_heal := [ ] ;
120530: LD_ADDR_VAR 0 30
120534: PUSH
120535: EMPTY
120536: ST_TO_ADDR
// repairs := [ ] ;
120537: LD_ADDR_VAR 0 33
120541: PUSH
120542: EMPTY
120543: ST_TO_ADDR
// to_repair := [ ] ;
120544: LD_ADDR_VAR 0 32
120548: PUSH
120549: EMPTY
120550: ST_TO_ADDR
// if not group or not path then
120551: LD_VAR 0 4
120555: NOT
120556: IFTRUE 120565
120558: PUSH
120559: LD_VAR 0 5
120563: NOT
120564: OR
120565: IFFALSE 120569
// exit ;
120567: GO 125172
// side := GetSide ( group [ 1 ] ) ;
120569: LD_ADDR_VAR 0 35
120573: PUSH
120574: LD_VAR 0 4
120578: PUSH
120579: LD_INT 1
120581: ARRAY
120582: PPUSH
120583: CALL_OW 255
120587: ST_TO_ADDR
// if flags then
120588: LD_VAR 0 6
120592: IFFALSE 120736
// begin f_ignore_area := flags [ 1 ] ;
120594: LD_ADDR_VAR 0 17
120598: PUSH
120599: LD_VAR 0 6
120603: PUSH
120604: LD_INT 1
120606: ARRAY
120607: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
120608: LD_ADDR_VAR 0 18
120612: PUSH
120613: LD_VAR 0 6
120617: PUSH
120618: LD_INT 2
120620: ARRAY
120621: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
120622: LD_ADDR_VAR 0 19
120626: PUSH
120627: LD_VAR 0 6
120631: PUSH
120632: LD_INT 3
120634: ARRAY
120635: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
120636: LD_ADDR_VAR 0 20
120640: PUSH
120641: LD_VAR 0 6
120645: PUSH
120646: LD_INT 4
120648: ARRAY
120649: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
120650: LD_ADDR_VAR 0 21
120654: PUSH
120655: LD_VAR 0 6
120659: PUSH
120660: LD_INT 5
120662: ARRAY
120663: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
120664: LD_ADDR_VAR 0 22
120668: PUSH
120669: LD_VAR 0 6
120673: PUSH
120674: LD_INT 6
120676: ARRAY
120677: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
120678: LD_ADDR_VAR 0 23
120682: PUSH
120683: LD_VAR 0 6
120687: PUSH
120688: LD_INT 7
120690: ARRAY
120691: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
120692: LD_ADDR_VAR 0 24
120696: PUSH
120697: LD_VAR 0 6
120701: PUSH
120702: LD_INT 8
120704: ARRAY
120705: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
120706: LD_ADDR_VAR 0 25
120710: PUSH
120711: LD_VAR 0 6
120715: PUSH
120716: LD_INT 9
120718: ARRAY
120719: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
120720: LD_ADDR_VAR 0 26
120724: PUSH
120725: LD_VAR 0 6
120729: PUSH
120730: LD_INT 10
120732: ARRAY
120733: ST_TO_ADDR
// end else
120734: GO 120816
// begin f_ignore_area := false ;
120736: LD_ADDR_VAR 0 17
120740: PUSH
120741: LD_INT 0
120743: ST_TO_ADDR
// f_capture := false ;
120744: LD_ADDR_VAR 0 18
120748: PUSH
120749: LD_INT 0
120751: ST_TO_ADDR
// f_ignore_civ := false ;
120752: LD_ADDR_VAR 0 19
120756: PUSH
120757: LD_INT 0
120759: ST_TO_ADDR
// f_murder := false ;
120760: LD_ADDR_VAR 0 20
120764: PUSH
120765: LD_INT 0
120767: ST_TO_ADDR
// f_mines := false ;
120768: LD_ADDR_VAR 0 21
120772: PUSH
120773: LD_INT 0
120775: ST_TO_ADDR
// f_repair := false ;
120776: LD_ADDR_VAR 0 22
120780: PUSH
120781: LD_INT 0
120783: ST_TO_ADDR
// f_heal := false ;
120784: LD_ADDR_VAR 0 23
120788: PUSH
120789: LD_INT 0
120791: ST_TO_ADDR
// f_spacetime := false ;
120792: LD_ADDR_VAR 0 24
120796: PUSH
120797: LD_INT 0
120799: ST_TO_ADDR
// f_attack_depot := false ;
120800: LD_ADDR_VAR 0 25
120804: PUSH
120805: LD_INT 0
120807: ST_TO_ADDR
// f_crawl := false ;
120808: LD_ADDR_VAR 0 26
120812: PUSH
120813: LD_INT 0
120815: ST_TO_ADDR
// end ; if f_heal then
120816: LD_VAR 0 23
120820: IFFALSE 120847
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
120822: LD_ADDR_VAR 0 31
120826: PUSH
120827: LD_VAR 0 4
120831: PPUSH
120832: LD_INT 25
120834: PUSH
120835: LD_INT 4
120837: PUSH
120838: EMPTY
120839: LIST
120840: LIST
120841: PPUSH
120842: CALL_OW 72
120846: ST_TO_ADDR
// if f_repair then
120847: LD_VAR 0 22
120851: IFFALSE 120878
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
120853: LD_ADDR_VAR 0 33
120857: PUSH
120858: LD_VAR 0 4
120862: PPUSH
120863: LD_INT 25
120865: PUSH
120866: LD_INT 3
120868: PUSH
120869: EMPTY
120870: LIST
120871: LIST
120872: PPUSH
120873: CALL_OW 72
120877: ST_TO_ADDR
// units_path := [ ] ;
120878: LD_ADDR_VAR 0 16
120882: PUSH
120883: EMPTY
120884: ST_TO_ADDR
// for i = 1 to group do
120885: LD_ADDR_VAR 0 7
120889: PUSH
120890: DOUBLE
120891: LD_INT 1
120893: DEC
120894: ST_TO_ADDR
120895: LD_VAR 0 4
120899: PUSH
120900: FOR_TO
120901: IFFALSE 120930
// units_path := Replace ( units_path , i , path ) ;
120903: LD_ADDR_VAR 0 16
120907: PUSH
120908: LD_VAR 0 16
120912: PPUSH
120913: LD_VAR 0 7
120917: PPUSH
120918: LD_VAR 0 5
120922: PPUSH
120923: CALL_OW 1
120927: ST_TO_ADDR
120928: GO 120900
120930: POP
120931: POP
// repeat for i = group downto 1 do
120932: LD_ADDR_VAR 0 7
120936: PUSH
120937: DOUBLE
120938: LD_VAR 0 4
120942: INC
120943: ST_TO_ADDR
120944: LD_INT 1
120946: PUSH
120947: FOR_DOWNTO
120948: IFFALSE 125124
// begin wait ( 5 ) ;
120950: LD_INT 5
120952: PPUSH
120953: CALL_OW 67
// tmp := [ ] ;
120957: LD_ADDR_VAR 0 14
120961: PUSH
120962: EMPTY
120963: ST_TO_ADDR
// attacking := false ;
120964: LD_ADDR_VAR 0 29
120968: PUSH
120969: LD_INT 0
120971: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
120972: LD_VAR 0 4
120976: PUSH
120977: LD_VAR 0 7
120981: ARRAY
120982: PPUSH
120983: CALL_OW 301
120987: IFTRUE 121002
120989: PUSH
120990: LD_VAR 0 4
120994: PUSH
120995: LD_VAR 0 7
120999: ARRAY
121000: NOT
121001: OR
121002: IFFALSE 121111
// begin if GetType ( group [ i ] ) = unit_human then
121004: LD_VAR 0 4
121008: PUSH
121009: LD_VAR 0 7
121013: ARRAY
121014: PPUSH
121015: CALL_OW 247
121019: PUSH
121020: LD_INT 1
121022: EQUAL
121023: IFFALSE 121069
// begin to_heal := to_heal diff group [ i ] ;
121025: LD_ADDR_VAR 0 30
121029: PUSH
121030: LD_VAR 0 30
121034: PUSH
121035: LD_VAR 0 4
121039: PUSH
121040: LD_VAR 0 7
121044: ARRAY
121045: DIFF
121046: ST_TO_ADDR
// healers := healers diff group [ i ] ;
121047: LD_ADDR_VAR 0 31
121051: PUSH
121052: LD_VAR 0 31
121056: PUSH
121057: LD_VAR 0 4
121061: PUSH
121062: LD_VAR 0 7
121066: ARRAY
121067: DIFF
121068: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
121069: LD_ADDR_VAR 0 4
121073: PUSH
121074: LD_VAR 0 4
121078: PPUSH
121079: LD_VAR 0 7
121083: PPUSH
121084: CALL_OW 3
121088: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
121089: LD_ADDR_VAR 0 16
121093: PUSH
121094: LD_VAR 0 16
121098: PPUSH
121099: LD_VAR 0 7
121103: PPUSH
121104: CALL_OW 3
121108: ST_TO_ADDR
// continue ;
121109: GO 120947
// end ; if f_repair then
121111: LD_VAR 0 22
121115: IFFALSE 121612
// begin if GetType ( group [ i ] ) = unit_vehicle then
121117: LD_VAR 0 4
121121: PUSH
121122: LD_VAR 0 7
121126: ARRAY
121127: PPUSH
121128: CALL_OW 247
121132: PUSH
121133: LD_INT 2
121135: EQUAL
121136: IFFALSE 121330
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
121138: LD_VAR 0 4
121142: PUSH
121143: LD_VAR 0 7
121147: ARRAY
121148: PPUSH
121149: CALL_OW 256
121153: PUSH
121154: LD_INT 700
121156: LESS
121157: IFFALSE 121178
121159: PUSH
121160: LD_VAR 0 4
121164: PUSH
121165: LD_VAR 0 7
121169: ARRAY
121170: PUSH
121171: LD_VAR 0 32
121175: IN
121176: NOT
121177: AND
121178: IFFALSE 121202
// to_repair := to_repair union group [ i ] ;
121180: LD_ADDR_VAR 0 32
121184: PUSH
121185: LD_VAR 0 32
121189: PUSH
121190: LD_VAR 0 4
121194: PUSH
121195: LD_VAR 0 7
121199: ARRAY
121200: UNION
121201: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
121202: LD_VAR 0 4
121206: PUSH
121207: LD_VAR 0 7
121211: ARRAY
121212: PPUSH
121213: CALL_OW 256
121217: PUSH
121218: LD_INT 1000
121220: EQUAL
121221: IFFALSE 121241
121223: PUSH
121224: LD_VAR 0 4
121228: PUSH
121229: LD_VAR 0 7
121233: ARRAY
121234: PUSH
121235: LD_VAR 0 32
121239: IN
121240: AND
121241: IFFALSE 121265
// to_repair := to_repair diff group [ i ] ;
121243: LD_ADDR_VAR 0 32
121247: PUSH
121248: LD_VAR 0 32
121252: PUSH
121253: LD_VAR 0 4
121257: PUSH
121258: LD_VAR 0 7
121262: ARRAY
121263: DIFF
121264: ST_TO_ADDR
// if group [ i ] in to_repair then
121265: LD_VAR 0 4
121269: PUSH
121270: LD_VAR 0 7
121274: ARRAY
121275: PUSH
121276: LD_VAR 0 32
121280: IN
121281: IFFALSE 121328
// begin if not IsInArea ( group [ i ] , f_repair ) then
121283: LD_VAR 0 4
121287: PUSH
121288: LD_VAR 0 7
121292: ARRAY
121293: PPUSH
121294: LD_VAR 0 22
121298: PPUSH
121299: CALL_OW 308
121303: NOT
121304: IFFALSE 121326
// ComMoveToArea ( group [ i ] , f_repair ) ;
121306: LD_VAR 0 4
121310: PUSH
121311: LD_VAR 0 7
121315: ARRAY
121316: PPUSH
121317: LD_VAR 0 22
121321: PPUSH
121322: CALL_OW 113
// continue ;
121326: GO 120947
// end ; end else
121328: GO 121612
// if group [ i ] in repairs then
121330: LD_VAR 0 4
121334: PUSH
121335: LD_VAR 0 7
121339: ARRAY
121340: PUSH
121341: LD_VAR 0 33
121345: IN
121346: IFFALSE 121612
// begin if IsInUnit ( group [ i ] ) then
121348: LD_VAR 0 4
121352: PUSH
121353: LD_VAR 0 7
121357: ARRAY
121358: PPUSH
121359: CALL_OW 310
121363: IFFALSE 121433
// begin z := IsInUnit ( group [ i ] ) ;
121365: LD_ADDR_VAR 0 13
121369: PUSH
121370: LD_VAR 0 4
121374: PUSH
121375: LD_VAR 0 7
121379: ARRAY
121380: PPUSH
121381: CALL_OW 310
121385: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
121386: LD_VAR 0 13
121390: PUSH
121391: LD_VAR 0 32
121395: IN
121396: IFFALSE 121414
121398: PUSH
121399: LD_VAR 0 13
121403: PPUSH
121404: LD_VAR 0 22
121408: PPUSH
121409: CALL_OW 308
121413: AND
121414: IFFALSE 121431
// ComExitVehicle ( group [ i ] ) ;
121416: LD_VAR 0 4
121420: PUSH
121421: LD_VAR 0 7
121425: ARRAY
121426: PPUSH
121427: CALL_OW 121
// end else
121431: GO 121612
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
121433: LD_ADDR_VAR 0 13
121437: PUSH
121438: LD_VAR 0 4
121442: PPUSH
121443: LD_INT 95
121445: PUSH
121446: LD_VAR 0 22
121450: PUSH
121451: EMPTY
121452: LIST
121453: LIST
121454: PUSH
121455: LD_INT 58
121457: PUSH
121458: EMPTY
121459: LIST
121460: PUSH
121461: EMPTY
121462: LIST
121463: LIST
121464: PPUSH
121465: CALL_OW 72
121469: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
121470: LD_VAR 0 4
121474: PUSH
121475: LD_VAR 0 7
121479: ARRAY
121480: PPUSH
121481: CALL_OW 314
121485: NOT
121486: IFFALSE 121610
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
121488: LD_ADDR_VAR 0 10
121492: PUSH
121493: LD_VAR 0 13
121497: PPUSH
121498: LD_VAR 0 4
121502: PUSH
121503: LD_VAR 0 7
121507: ARRAY
121508: PPUSH
121509: CALL_OW 74
121513: ST_TO_ADDR
// if not x then
121514: LD_VAR 0 10
121518: NOT
121519: IFFALSE 121523
// continue ;
121521: GO 120947
// if GetLives ( x ) < 1000 then
121523: LD_VAR 0 10
121527: PPUSH
121528: CALL_OW 256
121532: PUSH
121533: LD_INT 1000
121535: LESS
121536: IFFALSE 121560
// ComRepairVehicle ( group [ i ] , x ) else
121538: LD_VAR 0 4
121542: PUSH
121543: LD_VAR 0 7
121547: ARRAY
121548: PPUSH
121549: LD_VAR 0 10
121553: PPUSH
121554: CALL_OW 129
121558: GO 121610
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
121560: LD_VAR 0 23
121564: IFFALSE 121587
121566: PUSH
121567: LD_VAR 0 4
121571: PUSH
121572: LD_VAR 0 7
121576: ARRAY
121577: PPUSH
121578: CALL_OW 256
121582: PUSH
121583: LD_INT 1000
121585: LESS
121586: AND
121587: NOT
121588: IFFALSE 121610
// ComEnterUnit ( group [ i ] , x ) ;
121590: LD_VAR 0 4
121594: PUSH
121595: LD_VAR 0 7
121599: ARRAY
121600: PPUSH
121601: LD_VAR 0 10
121605: PPUSH
121606: CALL_OW 120
// end ; continue ;
121610: GO 120947
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
121612: LD_VAR 0 23
121616: IFFALSE 121639
121618: PUSH
121619: LD_VAR 0 4
121623: PUSH
121624: LD_VAR 0 7
121628: ARRAY
121629: PPUSH
121630: CALL_OW 247
121634: PUSH
121635: LD_INT 1
121637: EQUAL
121638: AND
121639: IFFALSE 122123
// begin if group [ i ] in healers then
121641: LD_VAR 0 4
121645: PUSH
121646: LD_VAR 0 7
121650: ARRAY
121651: PUSH
121652: LD_VAR 0 31
121656: IN
121657: IFFALSE 121934
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
121659: LD_VAR 0 4
121663: PUSH
121664: LD_VAR 0 7
121668: ARRAY
121669: PPUSH
121670: LD_VAR 0 23
121674: PPUSH
121675: CALL_OW 308
121679: NOT
121680: IFFALSE 121700
121682: PUSH
121683: LD_VAR 0 4
121687: PUSH
121688: LD_VAR 0 7
121692: ARRAY
121693: PPUSH
121694: CALL_OW 314
121698: NOT
121699: AND
121700: IFFALSE 121724
// ComMoveToArea ( group [ i ] , f_heal ) else
121702: LD_VAR 0 4
121706: PUSH
121707: LD_VAR 0 7
121711: ARRAY
121712: PPUSH
121713: LD_VAR 0 23
121717: PPUSH
121718: CALL_OW 113
121722: GO 121932
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
121724: LD_VAR 0 4
121728: PUSH
121729: LD_VAR 0 7
121733: ARRAY
121734: PPUSH
121735: CALL 89957 0 1
121739: PPUSH
121740: CALL_OW 256
121744: PUSH
121745: LD_INT 1000
121747: EQUAL
121748: IFFALSE 121767
// ComStop ( group [ i ] ) else
121750: LD_VAR 0 4
121754: PUSH
121755: LD_VAR 0 7
121759: ARRAY
121760: PPUSH
121761: CALL_OW 141
121765: GO 121932
// if not HasTask ( group [ i ] ) and to_heal then
121767: LD_VAR 0 4
121771: PUSH
121772: LD_VAR 0 7
121776: ARRAY
121777: PPUSH
121778: CALL_OW 314
121782: NOT
121783: IFFALSE 121791
121785: PUSH
121786: LD_VAR 0 30
121790: AND
121791: IFFALSE 121932
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
121793: LD_ADDR_VAR 0 13
121797: PUSH
121798: LD_VAR 0 30
121802: PPUSH
121803: LD_INT 3
121805: PUSH
121806: LD_INT 54
121808: PUSH
121809: EMPTY
121810: LIST
121811: PUSH
121812: EMPTY
121813: LIST
121814: LIST
121815: PPUSH
121816: CALL_OW 72
121820: PPUSH
121821: LD_VAR 0 4
121825: PUSH
121826: LD_VAR 0 7
121830: ARRAY
121831: PPUSH
121832: CALL_OW 74
121836: ST_TO_ADDR
// if z then
121837: LD_VAR 0 13
121841: IFFALSE 121932
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
121843: LD_INT 91
121845: PUSH
121846: LD_VAR 0 13
121850: PUSH
121851: LD_INT 10
121853: PUSH
121854: EMPTY
121855: LIST
121856: LIST
121857: LIST
121858: PUSH
121859: LD_INT 81
121861: PUSH
121862: LD_VAR 0 13
121866: PPUSH
121867: CALL_OW 255
121871: PUSH
121872: EMPTY
121873: LIST
121874: LIST
121875: PUSH
121876: EMPTY
121877: LIST
121878: LIST
121879: PPUSH
121880: CALL_OW 69
121884: PUSH
121885: LD_INT 0
121887: EQUAL
121888: IFFALSE 121912
// ComHeal ( group [ i ] , z ) else
121890: LD_VAR 0 4
121894: PUSH
121895: LD_VAR 0 7
121899: ARRAY
121900: PPUSH
121901: LD_VAR 0 13
121905: PPUSH
121906: CALL_OW 128
121910: GO 121932
// ComMoveToArea ( group [ i ] , f_heal ) ;
121912: LD_VAR 0 4
121916: PUSH
121917: LD_VAR 0 7
121921: ARRAY
121922: PPUSH
121923: LD_VAR 0 23
121927: PPUSH
121928: CALL_OW 113
// end ; continue ;
121932: GO 120947
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
121934: LD_VAR 0 4
121938: PUSH
121939: LD_VAR 0 7
121943: ARRAY
121944: PPUSH
121945: CALL_OW 256
121949: PUSH
121950: LD_INT 700
121952: LESS
121953: IFFALSE 121974
121955: PUSH
121956: LD_VAR 0 4
121960: PUSH
121961: LD_VAR 0 7
121965: ARRAY
121966: PUSH
121967: LD_VAR 0 30
121971: IN
121972: NOT
121973: AND
121974: IFFALSE 121998
// to_heal := to_heal union group [ i ] ;
121976: LD_ADDR_VAR 0 30
121980: PUSH
121981: LD_VAR 0 30
121985: PUSH
121986: LD_VAR 0 4
121990: PUSH
121991: LD_VAR 0 7
121995: ARRAY
121996: UNION
121997: ST_TO_ADDR
// if group [ i ] in to_heal then
121998: LD_VAR 0 4
122002: PUSH
122003: LD_VAR 0 7
122007: ARRAY
122008: PUSH
122009: LD_VAR 0 30
122013: IN
122014: IFFALSE 122123
// begin if GetLives ( group [ i ] ) = 1000 then
122016: LD_VAR 0 4
122020: PUSH
122021: LD_VAR 0 7
122025: ARRAY
122026: PPUSH
122027: CALL_OW 256
122031: PUSH
122032: LD_INT 1000
122034: EQUAL
122035: IFFALSE 122061
// to_heal := to_heal diff group [ i ] else
122037: LD_ADDR_VAR 0 30
122041: PUSH
122042: LD_VAR 0 30
122046: PUSH
122047: LD_VAR 0 4
122051: PUSH
122052: LD_VAR 0 7
122056: ARRAY
122057: DIFF
122058: ST_TO_ADDR
122059: GO 122123
// begin if not IsInArea ( group [ i ] , to_heal ) then
122061: LD_VAR 0 4
122065: PUSH
122066: LD_VAR 0 7
122070: ARRAY
122071: PPUSH
122072: LD_VAR 0 30
122076: PPUSH
122077: CALL_OW 308
122081: NOT
122082: IFFALSE 122106
// ComMoveToArea ( group [ i ] , f_heal ) else
122084: LD_VAR 0 4
122088: PUSH
122089: LD_VAR 0 7
122093: ARRAY
122094: PPUSH
122095: LD_VAR 0 23
122099: PPUSH
122100: CALL_OW 113
122104: GO 122121
// ComHold ( group [ i ] ) ;
122106: LD_VAR 0 4
122110: PUSH
122111: LD_VAR 0 7
122115: ARRAY
122116: PPUSH
122117: CALL_OW 140
// continue ;
122121: GO 120947
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
122123: LD_VAR 0 4
122127: PUSH
122128: LD_VAR 0 7
122132: ARRAY
122133: PPUSH
122134: LD_INT 10
122136: PPUSH
122137: CALL 87566 0 2
122141: NOT
122142: IFFALSE 122160
122144: PUSH
122145: LD_VAR 0 16
122149: PUSH
122150: LD_VAR 0 7
122154: ARRAY
122155: PUSH
122156: EMPTY
122157: EQUAL
122158: NOT
122159: AND
122160: IFFALSE 122426
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
122162: LD_VAR 0 4
122166: PUSH
122167: LD_VAR 0 7
122171: ARRAY
122172: PPUSH
122173: CALL_OW 262
122177: PUSH
122178: LD_INT 1
122180: PUSH
122181: LD_INT 2
122183: PUSH
122184: EMPTY
122185: LIST
122186: LIST
122187: IN
122188: IFFALSE 122229
// if GetFuel ( group [ i ] ) < 10 then
122190: LD_VAR 0 4
122194: PUSH
122195: LD_VAR 0 7
122199: ARRAY
122200: PPUSH
122201: CALL_OW 261
122205: PUSH
122206: LD_INT 10
122208: LESS
122209: IFFALSE 122229
// SetFuel ( group [ i ] , 12 ) ;
122211: LD_VAR 0 4
122215: PUSH
122216: LD_VAR 0 7
122220: ARRAY
122221: PPUSH
122222: LD_INT 12
122224: PPUSH
122225: CALL_OW 240
// if units_path [ i ] then
122229: LD_VAR 0 16
122233: PUSH
122234: LD_VAR 0 7
122238: ARRAY
122239: IFFALSE 122424
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
122241: LD_VAR 0 4
122245: PUSH
122246: LD_VAR 0 7
122250: ARRAY
122251: PPUSH
122252: LD_VAR 0 16
122256: PUSH
122257: LD_VAR 0 7
122261: ARRAY
122262: PUSH
122263: LD_INT 1
122265: ARRAY
122266: PUSH
122267: LD_INT 1
122269: ARRAY
122270: PPUSH
122271: LD_VAR 0 16
122275: PUSH
122276: LD_VAR 0 7
122280: ARRAY
122281: PUSH
122282: LD_INT 1
122284: ARRAY
122285: PUSH
122286: LD_INT 2
122288: ARRAY
122289: PPUSH
122290: CALL_OW 297
122294: PUSH
122295: LD_INT 6
122297: GREATER
122298: IFFALSE 122373
// begin if not HasTask ( group [ i ] ) then
122300: LD_VAR 0 4
122304: PUSH
122305: LD_VAR 0 7
122309: ARRAY
122310: PPUSH
122311: CALL_OW 314
122315: NOT
122316: IFFALSE 122371
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
122318: LD_VAR 0 4
122322: PUSH
122323: LD_VAR 0 7
122327: ARRAY
122328: PPUSH
122329: LD_VAR 0 16
122333: PUSH
122334: LD_VAR 0 7
122338: ARRAY
122339: PUSH
122340: LD_INT 1
122342: ARRAY
122343: PUSH
122344: LD_INT 1
122346: ARRAY
122347: PPUSH
122348: LD_VAR 0 16
122352: PUSH
122353: LD_VAR 0 7
122357: ARRAY
122358: PUSH
122359: LD_INT 1
122361: ARRAY
122362: PUSH
122363: LD_INT 2
122365: ARRAY
122366: PPUSH
122367: CALL_OW 114
// end else
122371: GO 122424
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
122373: LD_ADDR_VAR 0 15
122377: PUSH
122378: LD_VAR 0 16
122382: PUSH
122383: LD_VAR 0 7
122387: ARRAY
122388: PPUSH
122389: LD_INT 1
122391: PPUSH
122392: CALL_OW 3
122396: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
122397: LD_ADDR_VAR 0 16
122401: PUSH
122402: LD_VAR 0 16
122406: PPUSH
122407: LD_VAR 0 7
122411: PPUSH
122412: LD_VAR 0 15
122416: PPUSH
122417: CALL_OW 1
122421: ST_TO_ADDR
// continue ;
122422: GO 120947
// end ; end ; end else
122424: GO 125122
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
122426: LD_ADDR_VAR 0 14
122430: PUSH
122431: LD_INT 81
122433: PUSH
122434: LD_VAR 0 4
122438: PUSH
122439: LD_VAR 0 7
122443: ARRAY
122444: PPUSH
122445: CALL_OW 255
122449: PUSH
122450: EMPTY
122451: LIST
122452: LIST
122453: PPUSH
122454: CALL_OW 69
122458: ST_TO_ADDR
// if not tmp then
122459: LD_VAR 0 14
122463: NOT
122464: IFFALSE 122468
// continue ;
122466: GO 120947
// if f_ignore_area then
122468: LD_VAR 0 17
122472: IFFALSE 122560
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
122474: LD_ADDR_VAR 0 15
122478: PUSH
122479: LD_VAR 0 14
122483: PPUSH
122484: LD_INT 3
122486: PUSH
122487: LD_INT 92
122489: PUSH
122490: LD_VAR 0 17
122494: PUSH
122495: LD_INT 1
122497: ARRAY
122498: PUSH
122499: LD_VAR 0 17
122503: PUSH
122504: LD_INT 2
122506: ARRAY
122507: PUSH
122508: LD_VAR 0 17
122512: PUSH
122513: LD_INT 3
122515: ARRAY
122516: PUSH
122517: EMPTY
122518: LIST
122519: LIST
122520: LIST
122521: LIST
122522: PUSH
122523: EMPTY
122524: LIST
122525: LIST
122526: PPUSH
122527: CALL_OW 72
122531: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
122532: LD_VAR 0 14
122536: PUSH
122537: LD_VAR 0 15
122541: DIFF
122542: IFFALSE 122560
// tmp := tmp diff tmp2 ;
122544: LD_ADDR_VAR 0 14
122548: PUSH
122549: LD_VAR 0 14
122553: PUSH
122554: LD_VAR 0 15
122558: DIFF
122559: ST_TO_ADDR
// end ; if not f_murder then
122560: LD_VAR 0 20
122564: NOT
122565: IFFALSE 122623
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
122567: LD_ADDR_VAR 0 15
122571: PUSH
122572: LD_VAR 0 14
122576: PPUSH
122577: LD_INT 3
122579: PUSH
122580: LD_INT 50
122582: PUSH
122583: EMPTY
122584: LIST
122585: PUSH
122586: EMPTY
122587: LIST
122588: LIST
122589: PPUSH
122590: CALL_OW 72
122594: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
122595: LD_VAR 0 14
122599: PUSH
122600: LD_VAR 0 15
122604: DIFF
122605: IFFALSE 122623
// tmp := tmp diff tmp2 ;
122607: LD_ADDR_VAR 0 14
122611: PUSH
122612: LD_VAR 0 14
122616: PUSH
122617: LD_VAR 0 15
122621: DIFF
122622: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
122623: LD_ADDR_VAR 0 14
122627: PUSH
122628: LD_VAR 0 4
122632: PUSH
122633: LD_VAR 0 7
122637: ARRAY
122638: PPUSH
122639: LD_VAR 0 14
122643: PPUSH
122644: LD_INT 1
122646: PPUSH
122647: LD_INT 1
122649: PPUSH
122650: CALL 59988 0 4
122654: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
122655: LD_VAR 0 4
122659: PUSH
122660: LD_VAR 0 7
122664: ARRAY
122665: PPUSH
122666: CALL_OW 257
122670: PUSH
122671: LD_INT 1
122673: EQUAL
122674: IFFALSE 123134
// begin if WantPlant ( group [ i ] ) then
122676: LD_VAR 0 4
122680: PUSH
122681: LD_VAR 0 7
122685: ARRAY
122686: PPUSH
122687: CALL 59489 0 1
122691: IFFALSE 122695
// continue ;
122693: GO 120947
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
122695: LD_VAR 0 18
122699: IFFALSE 122719
122701: PUSH
122702: LD_VAR 0 4
122706: PUSH
122707: LD_VAR 0 7
122711: ARRAY
122712: PPUSH
122713: CALL_OW 310
122717: NOT
122718: AND
122719: IFFALSE 122762
122721: PUSH
122722: LD_VAR 0 14
122726: PUSH
122727: LD_INT 1
122729: ARRAY
122730: PUSH
122731: LD_VAR 0 14
122735: PPUSH
122736: LD_INT 21
122738: PUSH
122739: LD_INT 2
122741: PUSH
122742: EMPTY
122743: LIST
122744: LIST
122745: PUSH
122746: LD_INT 58
122748: PUSH
122749: EMPTY
122750: LIST
122751: PUSH
122752: EMPTY
122753: LIST
122754: LIST
122755: PPUSH
122756: CALL_OW 72
122760: IN
122761: AND
122762: IFFALSE 122798
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
122764: LD_VAR 0 4
122768: PUSH
122769: LD_VAR 0 7
122773: ARRAY
122774: PPUSH
122775: LD_VAR 0 14
122779: PUSH
122780: LD_INT 1
122782: ARRAY
122783: PPUSH
122784: CALL_OW 120
// attacking := true ;
122788: LD_ADDR_VAR 0 29
122792: PUSH
122793: LD_INT 1
122795: ST_TO_ADDR
// continue ;
122796: GO 120947
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
122798: LD_VAR 0 26
122802: IFFALSE 122825
122804: PUSH
122805: LD_VAR 0 4
122809: PUSH
122810: LD_VAR 0 7
122814: ARRAY
122815: PPUSH
122816: CALL_OW 257
122820: PUSH
122821: LD_INT 1
122823: EQUAL
122824: AND
122825: IFFALSE 122848
122827: PUSH
122828: LD_VAR 0 4
122832: PUSH
122833: LD_VAR 0 7
122837: ARRAY
122838: PPUSH
122839: CALL_OW 256
122843: PUSH
122844: LD_INT 800
122846: LESS
122847: AND
122848: IFFALSE 122868
122850: PUSH
122851: LD_VAR 0 4
122855: PUSH
122856: LD_VAR 0 7
122860: ARRAY
122861: PPUSH
122862: CALL_OW 318
122866: NOT
122867: AND
122868: IFFALSE 122885
// ComCrawl ( group [ i ] ) ;
122870: LD_VAR 0 4
122874: PUSH
122875: LD_VAR 0 7
122879: ARRAY
122880: PPUSH
122881: CALL_OW 137
// if f_mines then
122885: LD_VAR 0 21
122889: IFFALSE 123134
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
122891: LD_VAR 0 14
122895: PUSH
122896: LD_INT 1
122898: ARRAY
122899: PPUSH
122900: CALL_OW 247
122904: PUSH
122905: LD_INT 3
122907: EQUAL
122908: IFFALSE 122927
122910: PUSH
122911: LD_VAR 0 14
122915: PUSH
122916: LD_INT 1
122918: ARRAY
122919: PUSH
122920: LD_VAR 0 27
122924: IN
122925: NOT
122926: AND
122927: IFFALSE 123134
// begin x := GetX ( tmp [ 1 ] ) ;
122929: LD_ADDR_VAR 0 10
122933: PUSH
122934: LD_VAR 0 14
122938: PUSH
122939: LD_INT 1
122941: ARRAY
122942: PPUSH
122943: CALL_OW 250
122947: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
122948: LD_ADDR_VAR 0 11
122952: PUSH
122953: LD_VAR 0 14
122957: PUSH
122958: LD_INT 1
122960: ARRAY
122961: PPUSH
122962: CALL_OW 251
122966: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
122967: LD_ADDR_VAR 0 12
122971: PUSH
122972: LD_VAR 0 4
122976: PUSH
122977: LD_VAR 0 7
122981: ARRAY
122982: PPUSH
122983: CALL 87651 0 1
122987: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
122988: LD_VAR 0 4
122992: PUSH
122993: LD_VAR 0 7
122997: ARRAY
122998: PPUSH
122999: LD_VAR 0 10
123003: PPUSH
123004: LD_VAR 0 11
123008: PPUSH
123009: LD_VAR 0 14
123013: PUSH
123014: LD_INT 1
123016: ARRAY
123017: PPUSH
123018: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
123022: LD_VAR 0 4
123026: PUSH
123027: LD_VAR 0 7
123031: ARRAY
123032: PPUSH
123033: LD_VAR 0 10
123037: PPUSH
123038: LD_VAR 0 12
123042: PPUSH
123043: LD_INT 7
123045: PPUSH
123046: CALL_OW 272
123050: PPUSH
123051: LD_VAR 0 11
123055: PPUSH
123056: LD_VAR 0 12
123060: PPUSH
123061: LD_INT 7
123063: PPUSH
123064: CALL_OW 273
123068: PPUSH
123069: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
123073: LD_VAR 0 4
123077: PUSH
123078: LD_VAR 0 7
123082: ARRAY
123083: PPUSH
123084: LD_INT 71
123086: PPUSH
123087: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
123091: LD_ADDR_VAR 0 27
123095: PUSH
123096: LD_VAR 0 27
123100: PPUSH
123101: LD_VAR 0 27
123105: PUSH
123106: LD_INT 1
123108: PLUS
123109: PPUSH
123110: LD_VAR 0 14
123114: PUSH
123115: LD_INT 1
123117: ARRAY
123118: PPUSH
123119: CALL_OW 1
123123: ST_TO_ADDR
// attacking := true ;
123124: LD_ADDR_VAR 0 29
123128: PUSH
123129: LD_INT 1
123131: ST_TO_ADDR
// continue ;
123132: GO 120947
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
123134: LD_VAR 0 4
123138: PUSH
123139: LD_VAR 0 7
123143: ARRAY
123144: PPUSH
123145: CALL_OW 257
123149: PUSH
123150: LD_INT 17
123152: EQUAL
123153: IFFALSE 123177
123155: PUSH
123156: LD_VAR 0 4
123160: PUSH
123161: LD_VAR 0 7
123165: ARRAY
123166: PPUSH
123167: CALL_OW 110
123171: PUSH
123172: LD_INT 71
123174: EQUAL
123175: NOT
123176: AND
123177: IFFALSE 123323
// begin attacking := false ;
123179: LD_ADDR_VAR 0 29
123183: PUSH
123184: LD_INT 0
123186: ST_TO_ADDR
// k := 5 ;
123187: LD_ADDR_VAR 0 9
123191: PUSH
123192: LD_INT 5
123194: ST_TO_ADDR
// if tmp < k then
123195: LD_VAR 0 14
123199: PUSH
123200: LD_VAR 0 9
123204: LESS
123205: IFFALSE 123217
// k := tmp ;
123207: LD_ADDR_VAR 0 9
123211: PUSH
123212: LD_VAR 0 14
123216: ST_TO_ADDR
// for j = 1 to k do
123217: LD_ADDR_VAR 0 8
123221: PUSH
123222: DOUBLE
123223: LD_INT 1
123225: DEC
123226: ST_TO_ADDR
123227: LD_VAR 0 9
123231: PUSH
123232: FOR_TO
123233: IFFALSE 123321
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
123235: LD_VAR 0 14
123239: PUSH
123240: LD_VAR 0 8
123244: ARRAY
123245: PUSH
123246: LD_VAR 0 14
123250: PPUSH
123251: LD_INT 58
123253: PUSH
123254: EMPTY
123255: LIST
123256: PPUSH
123257: CALL_OW 72
123261: IN
123262: NOT
123263: IFFALSE 123319
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123265: LD_VAR 0 4
123269: PUSH
123270: LD_VAR 0 7
123274: ARRAY
123275: PPUSH
123276: LD_VAR 0 14
123280: PUSH
123281: LD_VAR 0 8
123285: ARRAY
123286: PPUSH
123287: CALL_OW 115
// attacking := true ;
123291: LD_ADDR_VAR 0 29
123295: PUSH
123296: LD_INT 1
123298: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
123299: LD_VAR 0 4
123303: PUSH
123304: LD_VAR 0 7
123308: ARRAY
123309: PPUSH
123310: LD_INT 71
123312: PPUSH
123313: CALL_OW 109
// continue ;
123317: GO 123232
// end ; end ;
123319: GO 123232
123321: POP
123322: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
123323: LD_VAR 0 4
123327: PUSH
123328: LD_VAR 0 7
123332: ARRAY
123333: PPUSH
123334: CALL_OW 257
123338: PUSH
123339: LD_INT 8
123341: EQUAL
123342: IFTRUE 123380
123344: PUSH
123345: LD_VAR 0 4
123349: PUSH
123350: LD_VAR 0 7
123354: ARRAY
123355: PPUSH
123356: CALL_OW 264
123360: PUSH
123361: LD_INT 28
123363: PUSH
123364: LD_INT 45
123366: PUSH
123367: LD_INT 7
123369: PUSH
123370: LD_INT 47
123372: PUSH
123373: EMPTY
123374: LIST
123375: LIST
123376: LIST
123377: LIST
123378: IN
123379: OR
123380: IFFALSE 123636
// begin attacking := false ;
123382: LD_ADDR_VAR 0 29
123386: PUSH
123387: LD_INT 0
123389: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
123390: LD_VAR 0 14
123394: PUSH
123395: LD_INT 1
123397: ARRAY
123398: PPUSH
123399: CALL_OW 266
123403: PUSH
123404: LD_INT 32
123406: PUSH
123407: LD_INT 31
123409: PUSH
123410: LD_INT 33
123412: PUSH
123413: LD_INT 4
123415: PUSH
123416: LD_INT 5
123418: PUSH
123419: EMPTY
123420: LIST
123421: LIST
123422: LIST
123423: LIST
123424: LIST
123425: IN
123426: IFFALSE 123612
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
123428: LD_ADDR_VAR 0 9
123432: PUSH
123433: LD_VAR 0 14
123437: PUSH
123438: LD_INT 1
123440: ARRAY
123441: PPUSH
123442: CALL_OW 266
123446: PPUSH
123447: LD_VAR 0 14
123451: PUSH
123452: LD_INT 1
123454: ARRAY
123455: PPUSH
123456: CALL_OW 250
123460: PPUSH
123461: LD_VAR 0 14
123465: PUSH
123466: LD_INT 1
123468: ARRAY
123469: PPUSH
123470: CALL_OW 251
123474: PPUSH
123475: LD_VAR 0 14
123479: PUSH
123480: LD_INT 1
123482: ARRAY
123483: PPUSH
123484: CALL_OW 254
123488: PPUSH
123489: LD_VAR 0 14
123493: PUSH
123494: LD_INT 1
123496: ARRAY
123497: PPUSH
123498: CALL_OW 248
123502: PPUSH
123503: LD_INT 0
123505: PPUSH
123506: CALL 69009 0 6
123510: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
123511: LD_ADDR_VAR 0 8
123515: PUSH
123516: LD_VAR 0 4
123520: PUSH
123521: LD_VAR 0 7
123525: ARRAY
123526: PPUSH
123527: LD_VAR 0 9
123531: PPUSH
123532: CALL 87764 0 2
123536: ST_TO_ADDR
// if j then
123537: LD_VAR 0 8
123541: IFFALSE 123610
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
123543: LD_VAR 0 8
123547: PUSH
123548: LD_INT 1
123550: ARRAY
123551: PPUSH
123552: LD_VAR 0 8
123556: PUSH
123557: LD_INT 2
123559: ARRAY
123560: PPUSH
123561: CALL_OW 488
123565: IFFALSE 123610
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
123567: LD_VAR 0 4
123571: PUSH
123572: LD_VAR 0 7
123576: ARRAY
123577: PPUSH
123578: LD_VAR 0 8
123582: PUSH
123583: LD_INT 1
123585: ARRAY
123586: PPUSH
123587: LD_VAR 0 8
123591: PUSH
123592: LD_INT 2
123594: ARRAY
123595: PPUSH
123596: CALL_OW 116
// attacking := true ;
123600: LD_ADDR_VAR 0 29
123604: PUSH
123605: LD_INT 1
123607: ST_TO_ADDR
// continue ;
123608: GO 120947
// end ; end else
123610: GO 123636
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123612: LD_VAR 0 4
123616: PUSH
123617: LD_VAR 0 7
123621: ARRAY
123622: PPUSH
123623: LD_VAR 0 14
123627: PUSH
123628: LD_INT 1
123630: ARRAY
123631: PPUSH
123632: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
123636: LD_VAR 0 4
123640: PUSH
123641: LD_VAR 0 7
123645: ARRAY
123646: PPUSH
123647: CALL_OW 265
123651: PUSH
123652: LD_INT 11
123654: EQUAL
123655: IFFALSE 123933
// begin k := 10 ;
123657: LD_ADDR_VAR 0 9
123661: PUSH
123662: LD_INT 10
123664: ST_TO_ADDR
// x := 0 ;
123665: LD_ADDR_VAR 0 10
123669: PUSH
123670: LD_INT 0
123672: ST_TO_ADDR
// if tmp < k then
123673: LD_VAR 0 14
123677: PUSH
123678: LD_VAR 0 9
123682: LESS
123683: IFFALSE 123695
// k := tmp ;
123685: LD_ADDR_VAR 0 9
123689: PUSH
123690: LD_VAR 0 14
123694: ST_TO_ADDR
// for j = k downto 1 do
123695: LD_ADDR_VAR 0 8
123699: PUSH
123700: DOUBLE
123701: LD_VAR 0 9
123705: INC
123706: ST_TO_ADDR
123707: LD_INT 1
123709: PUSH
123710: FOR_DOWNTO
123711: IFFALSE 123786
// begin if GetType ( tmp [ j ] ) = unit_human then
123713: LD_VAR 0 14
123717: PUSH
123718: LD_VAR 0 8
123722: ARRAY
123723: PPUSH
123724: CALL_OW 247
123728: PUSH
123729: LD_INT 1
123731: EQUAL
123732: IFFALSE 123784
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
123734: LD_VAR 0 4
123738: PUSH
123739: LD_VAR 0 7
123743: ARRAY
123744: PPUSH
123745: LD_VAR 0 14
123749: PUSH
123750: LD_VAR 0 8
123754: ARRAY
123755: PPUSH
123756: CALL 88022 0 2
// x := tmp [ j ] ;
123760: LD_ADDR_VAR 0 10
123764: PUSH
123765: LD_VAR 0 14
123769: PUSH
123770: LD_VAR 0 8
123774: ARRAY
123775: ST_TO_ADDR
// attacking := true ;
123776: LD_ADDR_VAR 0 29
123780: PUSH
123781: LD_INT 1
123783: ST_TO_ADDR
// end ; end ;
123784: GO 123710
123786: POP
123787: POP
// if not x then
123788: LD_VAR 0 10
123792: NOT
123793: IFFALSE 123933
// begin attacking := true ;
123795: LD_ADDR_VAR 0 29
123799: PUSH
123800: LD_INT 1
123802: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
123803: LD_VAR 0 4
123807: PUSH
123808: LD_VAR 0 7
123812: ARRAY
123813: PPUSH
123814: CALL_OW 250
123818: PPUSH
123819: LD_VAR 0 4
123823: PUSH
123824: LD_VAR 0 7
123828: ARRAY
123829: PPUSH
123830: CALL_OW 251
123834: PPUSH
123835: CALL_OW 546
123839: PUSH
123840: LD_INT 2
123842: ARRAY
123843: PUSH
123844: LD_VAR 0 14
123848: PUSH
123849: LD_INT 1
123851: ARRAY
123852: PPUSH
123853: CALL_OW 250
123857: PPUSH
123858: LD_VAR 0 14
123862: PUSH
123863: LD_INT 1
123865: ARRAY
123866: PPUSH
123867: CALL_OW 251
123871: PPUSH
123872: CALL_OW 546
123876: PUSH
123877: LD_INT 2
123879: ARRAY
123880: EQUAL
123881: IFFALSE 123909
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
123883: LD_VAR 0 4
123887: PUSH
123888: LD_VAR 0 7
123892: ARRAY
123893: PPUSH
123894: LD_VAR 0 14
123898: PUSH
123899: LD_INT 1
123901: ARRAY
123902: PPUSH
123903: CALL 88022 0 2
123907: GO 123933
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123909: LD_VAR 0 4
123913: PUSH
123914: LD_VAR 0 7
123918: ARRAY
123919: PPUSH
123920: LD_VAR 0 14
123924: PUSH
123925: LD_INT 1
123927: ARRAY
123928: PPUSH
123929: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
123933: LD_VAR 0 4
123937: PUSH
123938: LD_VAR 0 7
123942: ARRAY
123943: PPUSH
123944: CALL_OW 264
123948: PUSH
123949: LD_INT 29
123951: EQUAL
123952: IFFALSE 124322
// begin if WantsToAttack ( group [ i ] ) in bombed then
123954: LD_VAR 0 4
123958: PUSH
123959: LD_VAR 0 7
123963: ARRAY
123964: PPUSH
123965: CALL_OW 319
123969: PUSH
123970: LD_VAR 0 28
123974: IN
123975: IFFALSE 123979
// continue ;
123977: GO 120947
// k := 8 ;
123979: LD_ADDR_VAR 0 9
123983: PUSH
123984: LD_INT 8
123986: ST_TO_ADDR
// x := 0 ;
123987: LD_ADDR_VAR 0 10
123991: PUSH
123992: LD_INT 0
123994: ST_TO_ADDR
// if tmp < k then
123995: LD_VAR 0 14
123999: PUSH
124000: LD_VAR 0 9
124004: LESS
124005: IFFALSE 124017
// k := tmp ;
124007: LD_ADDR_VAR 0 9
124011: PUSH
124012: LD_VAR 0 14
124016: ST_TO_ADDR
// for j = 1 to k do
124017: LD_ADDR_VAR 0 8
124021: PUSH
124022: DOUBLE
124023: LD_INT 1
124025: DEC
124026: ST_TO_ADDR
124027: LD_VAR 0 9
124031: PUSH
124032: FOR_TO
124033: IFFALSE 124167
// begin if GetType ( tmp [ j ] ) = unit_building then
124035: LD_VAR 0 14
124039: PUSH
124040: LD_VAR 0 8
124044: ARRAY
124045: PPUSH
124046: CALL_OW 247
124050: PUSH
124051: LD_INT 3
124053: EQUAL
124054: IFFALSE 124165
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
124056: LD_VAR 0 14
124060: PUSH
124061: LD_VAR 0 8
124065: ARRAY
124066: PUSH
124067: LD_VAR 0 28
124071: IN
124072: NOT
124073: IFFALSE 124092
124075: PUSH
124076: LD_VAR 0 14
124080: PUSH
124081: LD_VAR 0 8
124085: ARRAY
124086: PPUSH
124087: CALL_OW 313
124091: AND
124092: IFFALSE 124165
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
124094: LD_VAR 0 4
124098: PUSH
124099: LD_VAR 0 7
124103: ARRAY
124104: PPUSH
124105: LD_VAR 0 14
124109: PUSH
124110: LD_VAR 0 8
124114: ARRAY
124115: PPUSH
124116: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
124120: LD_ADDR_VAR 0 28
124124: PUSH
124125: LD_VAR 0 28
124129: PPUSH
124130: LD_VAR 0 28
124134: PUSH
124135: LD_INT 1
124137: PLUS
124138: PPUSH
124139: LD_VAR 0 14
124143: PUSH
124144: LD_VAR 0 8
124148: ARRAY
124149: PPUSH
124150: CALL_OW 1
124154: ST_TO_ADDR
// attacking := true ;
124155: LD_ADDR_VAR 0 29
124159: PUSH
124160: LD_INT 1
124162: ST_TO_ADDR
// break ;
124163: GO 124167
// end ; end ;
124165: GO 124032
124167: POP
124168: POP
// if not attacking and f_attack_depot then
124169: LD_VAR 0 29
124173: NOT
124174: IFFALSE 124182
124176: PUSH
124177: LD_VAR 0 25
124181: AND
124182: IFFALSE 124277
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
124184: LD_ADDR_VAR 0 13
124188: PUSH
124189: LD_VAR 0 14
124193: PPUSH
124194: LD_INT 2
124196: PUSH
124197: LD_INT 30
124199: PUSH
124200: LD_INT 0
124202: PUSH
124203: EMPTY
124204: LIST
124205: LIST
124206: PUSH
124207: LD_INT 30
124209: PUSH
124210: LD_INT 1
124212: PUSH
124213: EMPTY
124214: LIST
124215: LIST
124216: PUSH
124217: EMPTY
124218: LIST
124219: LIST
124220: LIST
124221: PPUSH
124222: CALL_OW 72
124226: ST_TO_ADDR
// if z then
124227: LD_VAR 0 13
124231: IFFALSE 124277
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
124233: LD_VAR 0 4
124237: PUSH
124238: LD_VAR 0 7
124242: ARRAY
124243: PPUSH
124244: LD_VAR 0 13
124248: PPUSH
124249: LD_VAR 0 4
124253: PUSH
124254: LD_VAR 0 7
124258: ARRAY
124259: PPUSH
124260: CALL_OW 74
124264: PPUSH
124265: CALL_OW 115
// attacking := true ;
124269: LD_ADDR_VAR 0 29
124273: PUSH
124274: LD_INT 1
124276: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
124277: LD_VAR 0 4
124281: PUSH
124282: LD_VAR 0 7
124286: ARRAY
124287: PPUSH
124288: CALL_OW 256
124292: PUSH
124293: LD_INT 500
124295: LESS
124296: IFFALSE 124322
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124298: LD_VAR 0 4
124302: PUSH
124303: LD_VAR 0 7
124307: ARRAY
124308: PPUSH
124309: LD_VAR 0 14
124313: PUSH
124314: LD_INT 1
124316: ARRAY
124317: PPUSH
124318: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
124322: LD_VAR 0 4
124326: PUSH
124327: LD_VAR 0 7
124331: ARRAY
124332: PPUSH
124333: CALL_OW 264
124337: PUSH
124338: LD_INT 49
124340: EQUAL
124341: IFFALSE 124462
// begin if not HasTask ( group [ i ] ) then
124343: LD_VAR 0 4
124347: PUSH
124348: LD_VAR 0 7
124352: ARRAY
124353: PPUSH
124354: CALL_OW 314
124358: NOT
124359: IFFALSE 124462
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
124361: LD_ADDR_VAR 0 9
124365: PUSH
124366: LD_INT 81
124368: PUSH
124369: LD_VAR 0 4
124373: PUSH
124374: LD_VAR 0 7
124378: ARRAY
124379: PPUSH
124380: CALL_OW 255
124384: PUSH
124385: EMPTY
124386: LIST
124387: LIST
124388: PPUSH
124389: CALL_OW 69
124393: PPUSH
124394: LD_VAR 0 4
124398: PUSH
124399: LD_VAR 0 7
124403: ARRAY
124404: PPUSH
124405: CALL_OW 74
124409: ST_TO_ADDR
// if k then
124410: LD_VAR 0 9
124414: IFFALSE 124462
// if GetDistUnits ( group [ i ] , k ) > 10 then
124416: LD_VAR 0 4
124420: PUSH
124421: LD_VAR 0 7
124425: ARRAY
124426: PPUSH
124427: LD_VAR 0 9
124431: PPUSH
124432: CALL_OW 296
124436: PUSH
124437: LD_INT 10
124439: GREATER
124440: IFFALSE 124462
// ComMoveUnit ( group [ i ] , k ) ;
124442: LD_VAR 0 4
124446: PUSH
124447: LD_VAR 0 7
124451: ARRAY
124452: PPUSH
124453: LD_VAR 0 9
124457: PPUSH
124458: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
124462: LD_VAR 0 4
124466: PUSH
124467: LD_VAR 0 7
124471: ARRAY
124472: PPUSH
124473: CALL_OW 256
124477: PUSH
124478: LD_INT 250
124480: LESS
124481: IFFALSE 124525
124483: PUSH
124484: LD_VAR 0 4
124488: PUSH
124489: LD_VAR 0 7
124493: ARRAY
124494: PUSH
124495: LD_INT 21
124497: PUSH
124498: LD_INT 2
124500: PUSH
124501: EMPTY
124502: LIST
124503: LIST
124504: PUSH
124505: LD_INT 23
124507: PUSH
124508: LD_INT 2
124510: PUSH
124511: EMPTY
124512: LIST
124513: LIST
124514: PUSH
124515: EMPTY
124516: LIST
124517: LIST
124518: PPUSH
124519: CALL_OW 69
124523: IN
124524: AND
124525: IFFALSE 124652
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
124527: LD_ADDR_VAR 0 9
124531: PUSH
124532: LD_OWVAR 3
124536: PUSH
124537: LD_VAR 0 4
124541: PUSH
124542: LD_VAR 0 7
124546: ARRAY
124547: DIFF
124548: PPUSH
124549: LD_VAR 0 4
124553: PUSH
124554: LD_VAR 0 7
124558: ARRAY
124559: PPUSH
124560: CALL_OW 74
124564: ST_TO_ADDR
// if not k then
124565: LD_VAR 0 9
124569: NOT
124570: IFFALSE 124574
// continue ;
124572: GO 120947
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
124574: LD_VAR 0 9
124578: PUSH
124579: LD_INT 81
124581: PUSH
124582: LD_VAR 0 4
124586: PUSH
124587: LD_VAR 0 7
124591: ARRAY
124592: PPUSH
124593: CALL_OW 255
124597: PUSH
124598: EMPTY
124599: LIST
124600: LIST
124601: PPUSH
124602: CALL_OW 69
124606: IN
124607: IFFALSE 124635
124609: PUSH
124610: LD_VAR 0 9
124614: PPUSH
124615: LD_VAR 0 4
124619: PUSH
124620: LD_VAR 0 7
124624: ARRAY
124625: PPUSH
124626: CALL_OW 296
124630: PUSH
124631: LD_INT 5
124633: LESS
124634: AND
124635: IFFALSE 124652
// ComAutodestruct ( group [ i ] ) ;
124637: LD_VAR 0 4
124641: PUSH
124642: LD_VAR 0 7
124646: ARRAY
124647: PPUSH
124648: CALL 87918 0 1
// end ; if f_attack_depot then
124652: LD_VAR 0 25
124656: IFFALSE 124768
// begin k := 6 ;
124658: LD_ADDR_VAR 0 9
124662: PUSH
124663: LD_INT 6
124665: ST_TO_ADDR
// if tmp < k then
124666: LD_VAR 0 14
124670: PUSH
124671: LD_VAR 0 9
124675: LESS
124676: IFFALSE 124688
// k := tmp ;
124678: LD_ADDR_VAR 0 9
124682: PUSH
124683: LD_VAR 0 14
124687: ST_TO_ADDR
// for j = 1 to k do
124688: LD_ADDR_VAR 0 8
124692: PUSH
124693: DOUBLE
124694: LD_INT 1
124696: DEC
124697: ST_TO_ADDR
124698: LD_VAR 0 9
124702: PUSH
124703: FOR_TO
124704: IFFALSE 124766
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
124706: LD_VAR 0 8
124710: PPUSH
124711: CALL_OW 266
124715: PUSH
124716: LD_INT 0
124718: PUSH
124719: LD_INT 1
124721: PUSH
124722: EMPTY
124723: LIST
124724: LIST
124725: IN
124726: IFFALSE 124764
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
124728: LD_VAR 0 4
124732: PUSH
124733: LD_VAR 0 7
124737: ARRAY
124738: PPUSH
124739: LD_VAR 0 14
124743: PUSH
124744: LD_VAR 0 8
124748: ARRAY
124749: PPUSH
124750: CALL_OW 115
// attacking := true ;
124754: LD_ADDR_VAR 0 29
124758: PUSH
124759: LD_INT 1
124761: ST_TO_ADDR
// break ;
124762: GO 124766
// end ;
124764: GO 124703
124766: POP
124767: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
124768: LD_VAR 0 4
124772: PUSH
124773: LD_VAR 0 7
124777: ARRAY
124778: PPUSH
124779: CALL_OW 302
124783: IFFALSE 124792
124785: PUSH
124786: LD_VAR 0 29
124790: NOT
124791: AND
124792: IFFALSE 125122
// begin if GetTag ( group [ i ] ) = 71 then
124794: LD_VAR 0 4
124798: PUSH
124799: LD_VAR 0 7
124803: ARRAY
124804: PPUSH
124805: CALL_OW 110
124809: PUSH
124810: LD_INT 71
124812: EQUAL
124813: IFFALSE 124854
// begin if HasTask ( group [ i ] ) then
124815: LD_VAR 0 4
124819: PUSH
124820: LD_VAR 0 7
124824: ARRAY
124825: PPUSH
124826: CALL_OW 314
124830: IFFALSE 124836
// continue else
124832: GO 120947
124834: GO 124854
// SetTag ( group [ i ] , 0 ) ;
124836: LD_VAR 0 4
124840: PUSH
124841: LD_VAR 0 7
124845: ARRAY
124846: PPUSH
124847: LD_INT 0
124849: PPUSH
124850: CALL_OW 109
// end ; k := 8 ;
124854: LD_ADDR_VAR 0 9
124858: PUSH
124859: LD_INT 8
124861: ST_TO_ADDR
// x := 0 ;
124862: LD_ADDR_VAR 0 10
124866: PUSH
124867: LD_INT 0
124869: ST_TO_ADDR
// if tmp < k then
124870: LD_VAR 0 14
124874: PUSH
124875: LD_VAR 0 9
124879: LESS
124880: IFFALSE 124892
// k := tmp ;
124882: LD_ADDR_VAR 0 9
124886: PUSH
124887: LD_VAR 0 14
124891: ST_TO_ADDR
// for j = 1 to k do
124892: LD_ADDR_VAR 0 8
124896: PUSH
124897: DOUBLE
124898: LD_INT 1
124900: DEC
124901: ST_TO_ADDR
124902: LD_VAR 0 9
124906: PUSH
124907: FOR_TO
124908: IFFALSE 125014
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
124910: LD_VAR 0 14
124914: PUSH
124915: LD_VAR 0 8
124919: ARRAY
124920: PPUSH
124921: CALL_OW 247
124925: PUSH
124926: LD_INT 1
124928: EQUAL
124929: IFFALSE 124992
124931: PUSH
124932: LD_VAR 0 14
124936: PUSH
124937: LD_VAR 0 8
124941: ARRAY
124942: PPUSH
124943: CALL_OW 256
124947: PUSH
124948: LD_INT 250
124950: LESS
124951: IFFALSE 124959
124953: PUSH
124954: LD_VAR 0 20
124958: AND
124959: IFTRUE 124991
124961: PUSH
124962: LD_VAR 0 20
124966: NOT
124967: IFFALSE 124990
124969: PUSH
124970: LD_VAR 0 14
124974: PUSH
124975: LD_VAR 0 8
124979: ARRAY
124980: PPUSH
124981: CALL_OW 256
124985: PUSH
124986: LD_INT 250
124988: GREATEREQUAL
124989: AND
124990: OR
124991: AND
124992: IFFALSE 125012
// begin x := tmp [ j ] ;
124994: LD_ADDR_VAR 0 10
124998: PUSH
124999: LD_VAR 0 14
125003: PUSH
125004: LD_VAR 0 8
125008: ARRAY
125009: ST_TO_ADDR
// break ;
125010: GO 125014
// end ;
125012: GO 124907
125014: POP
125015: POP
// if x then
125016: LD_VAR 0 10
125020: IFFALSE 125044
// ComAttackUnit ( group [ i ] , x ) else
125022: LD_VAR 0 4
125026: PUSH
125027: LD_VAR 0 7
125031: ARRAY
125032: PPUSH
125033: LD_VAR 0 10
125037: PPUSH
125038: CALL_OW 115
125042: GO 125068
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
125044: LD_VAR 0 4
125048: PUSH
125049: LD_VAR 0 7
125053: ARRAY
125054: PPUSH
125055: LD_VAR 0 14
125059: PUSH
125060: LD_INT 1
125062: ARRAY
125063: PPUSH
125064: CALL_OW 115
// if not HasTask ( group [ i ] ) then
125068: LD_VAR 0 4
125072: PUSH
125073: LD_VAR 0 7
125077: ARRAY
125078: PPUSH
125079: CALL_OW 314
125083: NOT
125084: IFFALSE 125122
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
125086: LD_VAR 0 4
125090: PUSH
125091: LD_VAR 0 7
125095: ARRAY
125096: PPUSH
125097: LD_VAR 0 14
125101: PPUSH
125102: LD_VAR 0 4
125106: PUSH
125107: LD_VAR 0 7
125111: ARRAY
125112: PPUSH
125113: CALL_OW 74
125117: PPUSH
125118: CALL_OW 115
// end ; end ; end ;
125122: GO 120947
125124: POP
125125: POP
// wait ( 0 0$2 ) ;
125126: LD_INT 70
125128: PPUSH
125129: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
125133: LD_VAR 0 4
125137: NOT
125138: IFTRUE 125149
125140: PUSH
125141: LD_VAR 0 4
125145: PUSH
125146: EMPTY
125147: EQUAL
125148: OR
125149: IFTRUE 125170
125151: PUSH
125152: LD_INT 81
125154: PUSH
125155: LD_VAR 0 35
125159: PUSH
125160: EMPTY
125161: LIST
125162: LIST
125163: PPUSH
125164: CALL_OW 69
125168: NOT
125169: OR
125170: IFFALSE 120932
// end ;
125172: LD_VAR 0 2
125176: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
125177: LD_INT 0
125179: PPUSH
125180: PPUSH
125181: PPUSH
125182: PPUSH
125183: PPUSH
125184: PPUSH
// if not base or not mc_bases [ base ] or not solds then
125185: LD_VAR 0 1
125189: NOT
125190: IFTRUE 125205
125192: PUSH
125193: LD_EXP 80
125197: PUSH
125198: LD_VAR 0 1
125202: ARRAY
125203: NOT
125204: OR
125205: IFTRUE 125214
125207: PUSH
125208: LD_VAR 0 2
125212: NOT
125213: OR
125214: IFFALSE 125218
// exit ;
125216: GO 125776
// side := mc_sides [ base ] ;
125218: LD_ADDR_VAR 0 6
125222: PUSH
125223: LD_EXP 106
125227: PUSH
125228: LD_VAR 0 1
125232: ARRAY
125233: ST_TO_ADDR
// if not side then
125234: LD_VAR 0 6
125238: NOT
125239: IFFALSE 125243
// exit ;
125241: GO 125776
// for i in solds do
125243: LD_ADDR_VAR 0 7
125247: PUSH
125248: LD_VAR 0 2
125252: PUSH
125253: FOR_IN
125254: IFFALSE 125315
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
125256: LD_VAR 0 7
125260: PPUSH
125261: CALL_OW 310
125265: PPUSH
125266: CALL_OW 266
125270: PUSH
125271: LD_INT 32
125273: PUSH
125274: LD_INT 31
125276: PUSH
125277: EMPTY
125278: LIST
125279: LIST
125280: IN
125281: IFFALSE 125301
// solds := solds diff i else
125283: LD_ADDR_VAR 0 2
125287: PUSH
125288: LD_VAR 0 2
125292: PUSH
125293: LD_VAR 0 7
125297: DIFF
125298: ST_TO_ADDR
125299: GO 125313
// SetTag ( i , 18 ) ;
125301: LD_VAR 0 7
125305: PPUSH
125306: LD_INT 18
125308: PPUSH
125309: CALL_OW 109
125313: GO 125253
125315: POP
125316: POP
// if not solds then
125317: LD_VAR 0 2
125321: NOT
125322: IFFALSE 125326
// exit ;
125324: GO 125776
// repeat wait ( 0 0$2 ) ;
125326: LD_INT 70
125328: PPUSH
125329: CALL_OW 67
// enemy := mc_scan [ base ] ;
125333: LD_ADDR_VAR 0 4
125337: PUSH
125338: LD_EXP 103
125342: PUSH
125343: LD_VAR 0 1
125347: ARRAY
125348: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
125349: LD_EXP 80
125353: PUSH
125354: LD_VAR 0 1
125358: ARRAY
125359: NOT
125360: IFTRUE 125377
125362: PUSH
125363: LD_EXP 80
125367: PUSH
125368: LD_VAR 0 1
125372: ARRAY
125373: PUSH
125374: EMPTY
125375: EQUAL
125376: OR
125377: IFFALSE 125414
// begin for i in solds do
125379: LD_ADDR_VAR 0 7
125383: PUSH
125384: LD_VAR 0 2
125388: PUSH
125389: FOR_IN
125390: IFFALSE 125403
// ComStop ( i ) ;
125392: LD_VAR 0 7
125396: PPUSH
125397: CALL_OW 141
125401: GO 125389
125403: POP
125404: POP
// solds := [ ] ;
125405: LD_ADDR_VAR 0 2
125409: PUSH
125410: EMPTY
125411: ST_TO_ADDR
// exit ;
125412: GO 125776
// end ; for i in solds do
125414: LD_ADDR_VAR 0 7
125418: PUSH
125419: LD_VAR 0 2
125423: PUSH
125424: FOR_IN
125425: IFFALSE 125746
// begin if IsInUnit ( i ) then
125427: LD_VAR 0 7
125431: PPUSH
125432: CALL_OW 310
125436: IFFALSE 125447
// ComExitBuilding ( i ) ;
125438: LD_VAR 0 7
125442: PPUSH
125443: CALL_OW 122
// if GetLives ( i ) > 500 then
125447: LD_VAR 0 7
125451: PPUSH
125452: CALL_OW 256
125456: PUSH
125457: LD_INT 500
125459: GREATER
125460: IFFALSE 125513
// begin e := NearestUnitToUnit ( enemy , i ) ;
125462: LD_ADDR_VAR 0 5
125466: PUSH
125467: LD_VAR 0 4
125471: PPUSH
125472: LD_VAR 0 7
125476: PPUSH
125477: CALL_OW 74
125481: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
125482: LD_VAR 0 7
125486: PPUSH
125487: LD_VAR 0 5
125491: PPUSH
125492: CALL_OW 250
125496: PPUSH
125497: LD_VAR 0 5
125501: PPUSH
125502: CALL_OW 251
125506: PPUSH
125507: CALL_OW 114
// end else
125511: GO 125744
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
125513: LD_VAR 0 7
125517: PPUSH
125518: LD_EXP 80
125522: PUSH
125523: LD_VAR 0 1
125527: ARRAY
125528: PPUSH
125529: LD_INT 2
125531: PUSH
125532: LD_INT 30
125534: PUSH
125535: LD_INT 0
125537: PUSH
125538: EMPTY
125539: LIST
125540: LIST
125541: PUSH
125542: LD_INT 30
125544: PUSH
125545: LD_INT 1
125547: PUSH
125548: EMPTY
125549: LIST
125550: LIST
125551: PUSH
125552: LD_INT 30
125554: PUSH
125555: LD_INT 6
125557: PUSH
125558: EMPTY
125559: LIST
125560: LIST
125561: PUSH
125562: EMPTY
125563: LIST
125564: LIST
125565: LIST
125566: LIST
125567: PPUSH
125568: CALL_OW 72
125572: PPUSH
125573: LD_VAR 0 7
125577: PPUSH
125578: CALL_OW 74
125582: PPUSH
125583: CALL_OW 296
125587: PUSH
125588: LD_INT 10
125590: GREATER
125591: IFFALSE 125744
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
125593: LD_ADDR_VAR 0 8
125597: PUSH
125598: LD_EXP 80
125602: PUSH
125603: LD_VAR 0 1
125607: ARRAY
125608: PPUSH
125609: LD_INT 2
125611: PUSH
125612: LD_INT 30
125614: PUSH
125615: LD_INT 0
125617: PUSH
125618: EMPTY
125619: LIST
125620: LIST
125621: PUSH
125622: LD_INT 30
125624: PUSH
125625: LD_INT 1
125627: PUSH
125628: EMPTY
125629: LIST
125630: LIST
125631: PUSH
125632: LD_INT 30
125634: PUSH
125635: LD_INT 6
125637: PUSH
125638: EMPTY
125639: LIST
125640: LIST
125641: PUSH
125642: EMPTY
125643: LIST
125644: LIST
125645: LIST
125646: LIST
125647: PPUSH
125648: CALL_OW 72
125652: PPUSH
125653: LD_VAR 0 7
125657: PPUSH
125658: CALL_OW 74
125662: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
125663: LD_VAR 0 7
125667: PPUSH
125668: LD_VAR 0 8
125672: PPUSH
125673: CALL_OW 250
125677: PPUSH
125678: LD_INT 3
125680: PPUSH
125681: LD_INT 5
125683: PPUSH
125684: CALL_OW 272
125688: PPUSH
125689: LD_VAR 0 8
125693: PPUSH
125694: CALL_OW 251
125698: PPUSH
125699: LD_INT 3
125701: PPUSH
125702: LD_INT 5
125704: PPUSH
125705: CALL_OW 273
125709: PPUSH
125710: CALL_OW 111
// SetTag ( i , 0 ) ;
125714: LD_VAR 0 7
125718: PPUSH
125719: LD_INT 0
125721: PPUSH
125722: CALL_OW 109
// solds := solds diff i ;
125726: LD_ADDR_VAR 0 2
125730: PUSH
125731: LD_VAR 0 2
125735: PUSH
125736: LD_VAR 0 7
125740: DIFF
125741: ST_TO_ADDR
// continue ;
125742: GO 125424
// end ; end ;
125744: GO 125424
125746: POP
125747: POP
// until not solds or not enemy ;
125748: LD_VAR 0 2
125752: NOT
125753: IFTRUE 125762
125755: PUSH
125756: LD_VAR 0 4
125760: NOT
125761: OR
125762: IFFALSE 125326
// MC_Reset ( base , 18 ) ;
125764: LD_VAR 0 1
125768: PPUSH
125769: LD_INT 18
125771: PPUSH
125772: CALL 27518 0 2
// end ;
125776: LD_VAR 0 3
125780: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
125781: LD_INT 0
125783: PPUSH
125784: PPUSH
125785: PPUSH
125786: PPUSH
125787: PPUSH
125788: PPUSH
125789: PPUSH
125790: PPUSH
125791: PPUSH
125792: PPUSH
125793: PPUSH
125794: PPUSH
125795: PPUSH
125796: PPUSH
125797: PPUSH
125798: PPUSH
125799: PPUSH
125800: PPUSH
125801: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
125802: LD_ADDR_VAR 0 12
125806: PUSH
125807: LD_EXP 80
125811: PUSH
125812: LD_VAR 0 1
125816: ARRAY
125817: PPUSH
125818: LD_INT 25
125820: PUSH
125821: LD_INT 3
125823: PUSH
125824: EMPTY
125825: LIST
125826: LIST
125827: PPUSH
125828: CALL_OW 72
125832: ST_TO_ADDR
// if mc_remote_driver [ base ] then
125833: LD_EXP 120
125837: PUSH
125838: LD_VAR 0 1
125842: ARRAY
125843: IFFALSE 125867
// mechs := mechs diff mc_remote_driver [ base ] ;
125845: LD_ADDR_VAR 0 12
125849: PUSH
125850: LD_VAR 0 12
125854: PUSH
125855: LD_EXP 120
125859: PUSH
125860: LD_VAR 0 1
125864: ARRAY
125865: DIFF
125866: ST_TO_ADDR
// for i in mechs do
125867: LD_ADDR_VAR 0 4
125871: PUSH
125872: LD_VAR 0 12
125876: PUSH
125877: FOR_IN
125878: IFFALSE 125913
// if GetTag ( i ) > 0 then
125880: LD_VAR 0 4
125884: PPUSH
125885: CALL_OW 110
125889: PUSH
125890: LD_INT 0
125892: GREATER
125893: IFFALSE 125911
// mechs := mechs diff i ;
125895: LD_ADDR_VAR 0 12
125899: PUSH
125900: LD_VAR 0 12
125904: PUSH
125905: LD_VAR 0 4
125909: DIFF
125910: ST_TO_ADDR
125911: GO 125877
125913: POP
125914: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
125915: LD_ADDR_VAR 0 8
125919: PUSH
125920: LD_EXP 80
125924: PUSH
125925: LD_VAR 0 1
125929: ARRAY
125930: PPUSH
125931: LD_INT 2
125933: PUSH
125934: LD_INT 25
125936: PUSH
125937: LD_INT 1
125939: PUSH
125940: EMPTY
125941: LIST
125942: LIST
125943: PUSH
125944: LD_INT 25
125946: PUSH
125947: LD_INT 5
125949: PUSH
125950: EMPTY
125951: LIST
125952: LIST
125953: PUSH
125954: LD_INT 25
125956: PUSH
125957: LD_INT 8
125959: PUSH
125960: EMPTY
125961: LIST
125962: LIST
125963: PUSH
125964: LD_INT 25
125966: PUSH
125967: LD_INT 9
125969: PUSH
125970: EMPTY
125971: LIST
125972: LIST
125973: PUSH
125974: EMPTY
125975: LIST
125976: LIST
125977: LIST
125978: LIST
125979: LIST
125980: PPUSH
125981: CALL_OW 72
125985: ST_TO_ADDR
// if not defenders and not solds then
125986: LD_VAR 0 2
125990: NOT
125991: IFFALSE 126000
125993: PUSH
125994: LD_VAR 0 8
125998: NOT
125999: AND
126000: IFFALSE 126004
// exit ;
126002: GO 127826
// depot_under_attack := false ;
126004: LD_ADDR_VAR 0 16
126008: PUSH
126009: LD_INT 0
126011: ST_TO_ADDR
// sold_defenders := [ ] ;
126012: LD_ADDR_VAR 0 17
126016: PUSH
126017: EMPTY
126018: ST_TO_ADDR
// if mechs then
126019: LD_VAR 0 12
126023: IFFALSE 126178
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
126025: LD_ADDR_VAR 0 4
126029: PUSH
126030: LD_VAR 0 2
126034: PPUSH
126035: LD_INT 21
126037: PUSH
126038: LD_INT 2
126040: PUSH
126041: EMPTY
126042: LIST
126043: LIST
126044: PPUSH
126045: CALL_OW 72
126049: PUSH
126050: FOR_IN
126051: IFFALSE 126176
// begin if GetTag ( i ) <> 20 then
126053: LD_VAR 0 4
126057: PPUSH
126058: CALL_OW 110
126062: PUSH
126063: LD_INT 20
126065: NONEQUAL
126066: IFFALSE 126080
// SetTag ( i , 20 ) ;
126068: LD_VAR 0 4
126072: PPUSH
126073: LD_INT 20
126075: PPUSH
126076: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
126080: LD_VAR 0 4
126084: PPUSH
126085: CALL_OW 263
126089: PUSH
126090: LD_INT 1
126092: EQUAL
126093: IFFALSE 126107
126095: PUSH
126096: LD_VAR 0 4
126100: PPUSH
126101: CALL_OW 311
126105: NOT
126106: AND
126107: IFFALSE 126174
// begin un := mechs [ 1 ] ;
126109: LD_ADDR_VAR 0 10
126113: PUSH
126114: LD_VAR 0 12
126118: PUSH
126119: LD_INT 1
126121: ARRAY
126122: ST_TO_ADDR
// ComExit ( un ) ;
126123: LD_VAR 0 10
126127: PPUSH
126128: CALL 92999 0 1
// AddComEnterUnit ( un , i ) ;
126132: LD_VAR 0 10
126136: PPUSH
126137: LD_VAR 0 4
126141: PPUSH
126142: CALL_OW 180
// SetTag ( un , 19 ) ;
126146: LD_VAR 0 10
126150: PPUSH
126151: LD_INT 19
126153: PPUSH
126154: CALL_OW 109
// mechs := mechs diff un ;
126158: LD_ADDR_VAR 0 12
126162: PUSH
126163: LD_VAR 0 12
126167: PUSH
126168: LD_VAR 0 10
126172: DIFF
126173: ST_TO_ADDR
// end ; end ;
126174: GO 126050
126176: POP
126177: POP
// if solds then
126178: LD_VAR 0 8
126182: IFFALSE 126241
// for i in solds do
126184: LD_ADDR_VAR 0 4
126188: PUSH
126189: LD_VAR 0 8
126193: PUSH
126194: FOR_IN
126195: IFFALSE 126239
// if not GetTag ( i ) then
126197: LD_VAR 0 4
126201: PPUSH
126202: CALL_OW 110
126206: NOT
126207: IFFALSE 126237
// begin defenders := defenders union i ;
126209: LD_ADDR_VAR 0 2
126213: PUSH
126214: LD_VAR 0 2
126218: PUSH
126219: LD_VAR 0 4
126223: UNION
126224: ST_TO_ADDR
// SetTag ( i , 18 ) ;
126225: LD_VAR 0 4
126229: PPUSH
126230: LD_INT 18
126232: PPUSH
126233: CALL_OW 109
// end ;
126237: GO 126194
126239: POP
126240: POP
// repeat wait ( 0 0$2 ) ;
126241: LD_INT 70
126243: PPUSH
126244: CALL_OW 67
// enemy := mc_scan [ base ] ;
126248: LD_ADDR_VAR 0 21
126252: PUSH
126253: LD_EXP 103
126257: PUSH
126258: LD_VAR 0 1
126262: ARRAY
126263: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
126264: LD_EXP 80
126268: PUSH
126269: LD_VAR 0 1
126273: ARRAY
126274: NOT
126275: IFTRUE 126292
126277: PUSH
126278: LD_EXP 80
126282: PUSH
126283: LD_VAR 0 1
126287: ARRAY
126288: PUSH
126289: EMPTY
126290: EQUAL
126291: OR
126292: IFFALSE 126329
// begin for i in defenders do
126294: LD_ADDR_VAR 0 4
126298: PUSH
126299: LD_VAR 0 2
126303: PUSH
126304: FOR_IN
126305: IFFALSE 126318
// ComStop ( i ) ;
126307: LD_VAR 0 4
126311: PPUSH
126312: CALL_OW 141
126316: GO 126304
126318: POP
126319: POP
// defenders := [ ] ;
126320: LD_ADDR_VAR 0 2
126324: PUSH
126325: EMPTY
126326: ST_TO_ADDR
// exit ;
126327: GO 127826
// end ; for i in defenders do
126329: LD_ADDR_VAR 0 4
126333: PUSH
126334: LD_VAR 0 2
126338: PUSH
126339: FOR_IN
126340: IFFALSE 127274
// begin e := NearestUnitToUnit ( enemy , i ) ;
126342: LD_ADDR_VAR 0 13
126346: PUSH
126347: LD_VAR 0 21
126351: PPUSH
126352: LD_VAR 0 4
126356: PPUSH
126357: CALL_OW 74
126361: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
126362: LD_ADDR_VAR 0 7
126366: PUSH
126367: LD_EXP 80
126371: PUSH
126372: LD_VAR 0 1
126376: ARRAY
126377: PPUSH
126378: LD_INT 2
126380: PUSH
126381: LD_INT 30
126383: PUSH
126384: LD_INT 0
126386: PUSH
126387: EMPTY
126388: LIST
126389: LIST
126390: PUSH
126391: LD_INT 30
126393: PUSH
126394: LD_INT 1
126396: PUSH
126397: EMPTY
126398: LIST
126399: LIST
126400: PUSH
126401: EMPTY
126402: LIST
126403: LIST
126404: LIST
126405: PPUSH
126406: CALL_OW 72
126410: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
126411: LD_ADDR_VAR 0 16
126415: PUSH
126416: LD_VAR 0 7
126420: NOT
126421: IFTRUE 126451
126423: PUSH
126424: LD_VAR 0 7
126428: PPUSH
126429: LD_INT 3
126431: PUSH
126432: LD_INT 24
126434: PUSH
126435: LD_INT 600
126437: PUSH
126438: EMPTY
126439: LIST
126440: LIST
126441: PUSH
126442: EMPTY
126443: LIST
126444: LIST
126445: PPUSH
126446: CALL_OW 72
126450: OR
126451: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
126452: LD_VAR 0 4
126456: PPUSH
126457: CALL_OW 247
126461: PUSH
126462: LD_INT 2
126464: DOUBLE
126465: EQUAL
126466: IFTRUE 126470
126468: GO 126886
126470: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
126471: LD_VAR 0 4
126475: PPUSH
126476: CALL_OW 256
126480: PUSH
126481: LD_INT 1000
126483: EQUAL
126484: IFFALSE 126530
126486: PUSH
126487: LD_VAR 0 4
126491: PPUSH
126492: LD_VAR 0 13
126496: PPUSH
126497: CALL_OW 296
126501: PUSH
126502: LD_INT 40
126504: LESS
126505: IFTRUE 126529
126507: PUSH
126508: LD_VAR 0 13
126512: PPUSH
126513: LD_EXP 105
126517: PUSH
126518: LD_VAR 0 1
126522: ARRAY
126523: PPUSH
126524: CALL_OW 308
126528: OR
126529: AND
126530: IFFALSE 126656
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
126532: LD_VAR 0 4
126536: PPUSH
126537: CALL_OW 262
126541: PUSH
126542: LD_INT 1
126544: EQUAL
126545: IFFALSE 126562
126547: PUSH
126548: LD_VAR 0 4
126552: PPUSH
126553: CALL_OW 261
126557: PUSH
126558: LD_INT 30
126560: LESS
126561: AND
126562: IFFALSE 126570
126564: PUSH
126565: LD_VAR 0 7
126569: AND
126570: IFFALSE 126640
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
126572: LD_VAR 0 4
126576: PPUSH
126577: LD_VAR 0 7
126581: PPUSH
126582: LD_VAR 0 4
126586: PPUSH
126587: CALL_OW 74
126591: PPUSH
126592: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
126596: LD_VAR 0 4
126600: PPUSH
126601: LD_VAR 0 7
126605: PPUSH
126606: LD_VAR 0 4
126610: PPUSH
126611: CALL_OW 74
126615: PPUSH
126616: CALL_OW 296
126620: PUSH
126621: LD_INT 6
126623: LESS
126624: IFFALSE 126638
// SetFuel ( i , 100 ) ;
126626: LD_VAR 0 4
126630: PPUSH
126631: LD_INT 100
126633: PPUSH
126634: CALL_OW 240
// end else
126638: GO 126654
// ComAttackUnit ( i , e ) ;
126640: LD_VAR 0 4
126644: PPUSH
126645: LD_VAR 0 13
126649: PPUSH
126650: CALL_OW 115
// end else
126654: GO 126763
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
126656: LD_VAR 0 13
126660: PPUSH
126661: LD_EXP 105
126665: PUSH
126666: LD_VAR 0 1
126670: ARRAY
126671: PPUSH
126672: CALL_OW 308
126676: NOT
126677: IFFALSE 126699
126679: PUSH
126680: LD_VAR 0 4
126684: PPUSH
126685: LD_VAR 0 13
126689: PPUSH
126690: CALL_OW 296
126694: PUSH
126695: LD_INT 40
126697: GREATEREQUAL
126698: AND
126699: IFTRUE 126716
126701: PUSH
126702: LD_VAR 0 4
126706: PPUSH
126707: CALL_OW 256
126711: PUSH
126712: LD_INT 650
126714: LESSEQUAL
126715: OR
126716: IFFALSE 126741
126718: PUSH
126719: LD_VAR 0 4
126723: PPUSH
126724: LD_EXP 104
126728: PUSH
126729: LD_VAR 0 1
126733: ARRAY
126734: PPUSH
126735: CALL_OW 308
126739: NOT
126740: AND
126741: IFFALSE 126763
// ComMoveToArea ( i , mc_parking [ base ] ) ;
126743: LD_VAR 0 4
126747: PPUSH
126748: LD_EXP 104
126752: PUSH
126753: LD_VAR 0 1
126757: ARRAY
126758: PPUSH
126759: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
126763: LD_VAR 0 4
126767: PPUSH
126768: CALL_OW 256
126772: PUSH
126773: LD_INT 1000
126775: LESS
126776: IFFALSE 126793
126778: PUSH
126779: LD_VAR 0 4
126783: PPUSH
126784: CALL_OW 263
126788: PUSH
126789: LD_INT 1
126791: EQUAL
126792: AND
126793: IFFALSE 126806
126795: PUSH
126796: LD_VAR 0 4
126800: PPUSH
126801: CALL_OW 311
126805: AND
126806: IFFALSE 126830
126808: PUSH
126809: LD_VAR 0 4
126813: PPUSH
126814: LD_EXP 104
126818: PUSH
126819: LD_VAR 0 1
126823: ARRAY
126824: PPUSH
126825: CALL_OW 308
126829: AND
126830: IFFALSE 126884
// begin mech := IsDrivenBy ( i ) ;
126832: LD_ADDR_VAR 0 9
126836: PUSH
126837: LD_VAR 0 4
126841: PPUSH
126842: CALL_OW 311
126846: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
126847: LD_VAR 0 9
126851: PPUSH
126852: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
126856: LD_VAR 0 9
126860: PPUSH
126861: LD_VAR 0 4
126865: PPUSH
126866: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
126870: LD_VAR 0 9
126874: PPUSH
126875: LD_VAR 0 4
126879: PPUSH
126880: CALL_OW 180
// end ; end ; unit_human :
126884: GO 127245
126886: LD_INT 1
126888: DOUBLE
126889: EQUAL
126890: IFTRUE 126894
126892: GO 127244
126894: POP
// begin b := IsInUnit ( i ) ;
126895: LD_ADDR_VAR 0 18
126899: PUSH
126900: LD_VAR 0 4
126904: PPUSH
126905: CALL_OW 310
126909: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
126910: LD_ADDR_VAR 0 19
126914: PUSH
126915: LD_VAR 0 18
126919: NOT
126920: IFTRUE 126944
126922: PUSH
126923: LD_VAR 0 18
126927: PPUSH
126928: CALL_OW 266
126932: PUSH
126933: LD_INT 32
126935: PUSH
126936: LD_INT 31
126938: PUSH
126939: EMPTY
126940: LIST
126941: LIST
126942: IN
126943: OR
126944: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
126945: LD_VAR 0 18
126949: PPUSH
126950: CALL_OW 266
126954: PUSH
126955: LD_INT 5
126957: EQUAL
126958: IFFALSE 126990
126960: PUSH
126961: LD_VAR 0 4
126965: PPUSH
126966: CALL_OW 257
126970: PUSH
126971: LD_INT 1
126973: PUSH
126974: LD_INT 2
126976: PUSH
126977: LD_INT 3
126979: PUSH
126980: LD_INT 4
126982: PUSH
126983: EMPTY
126984: LIST
126985: LIST
126986: LIST
126987: LIST
126988: IN
126989: AND
126990: IFFALSE 127027
// begin class := AllowSpecClass ( i ) ;
126992: LD_ADDR_VAR 0 20
126996: PUSH
126997: LD_VAR 0 4
127001: PPUSH
127002: CALL 56319 0 1
127006: ST_TO_ADDR
// if class then
127007: LD_VAR 0 20
127011: IFFALSE 127027
// ComChangeProfession ( i , class ) ;
127013: LD_VAR 0 4
127017: PPUSH
127018: LD_VAR 0 20
127022: PPUSH
127023: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
127027: LD_VAR 0 16
127031: IFTRUE 127058
127033: PUSH
127034: LD_VAR 0 2
127038: PPUSH
127039: LD_INT 21
127041: PUSH
127042: LD_INT 2
127044: PUSH
127045: EMPTY
127046: LIST
127047: LIST
127048: PPUSH
127049: CALL_OW 72
127053: PUSH
127054: LD_INT 1
127056: LESSEQUAL
127057: OR
127058: IFFALSE 127066
127060: PUSH
127061: LD_VAR 0 19
127065: AND
127066: IFFALSE 127081
127068: PUSH
127069: LD_VAR 0 4
127073: PUSH
127074: LD_VAR 0 17
127078: IN
127079: NOT
127080: AND
127081: IFFALSE 127176
// begin if b then
127083: LD_VAR 0 18
127087: IFFALSE 127138
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
127089: LD_VAR 0 18
127093: PPUSH
127094: LD_VAR 0 21
127098: PPUSH
127099: LD_VAR 0 18
127103: PPUSH
127104: CALL_OW 74
127108: PPUSH
127109: CALL_OW 296
127113: PUSH
127114: LD_INT 10
127116: LESS
127117: IFFALSE 127134
127119: PUSH
127120: LD_VAR 0 18
127124: PPUSH
127125: CALL_OW 461
127129: PUSH
127130: LD_INT 7
127132: NONEQUAL
127133: AND
127134: IFFALSE 127138
// continue ;
127136: GO 126339
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
127138: LD_ADDR_VAR 0 17
127142: PUSH
127143: LD_VAR 0 17
127147: PPUSH
127148: LD_VAR 0 17
127152: PUSH
127153: LD_INT 1
127155: PLUS
127156: PPUSH
127157: LD_VAR 0 4
127161: PPUSH
127162: CALL_OW 1
127166: ST_TO_ADDR
// ComExitBuilding ( i ) ;
127167: LD_VAR 0 4
127171: PPUSH
127172: CALL_OW 122
// end ; if sold_defenders then
127176: LD_VAR 0 17
127180: IFFALSE 127242
// if i in sold_defenders then
127182: LD_VAR 0 4
127186: PUSH
127187: LD_VAR 0 17
127191: IN
127192: IFFALSE 127242
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
127194: LD_VAR 0 4
127198: PPUSH
127199: CALL_OW 314
127203: NOT
127204: IFFALSE 127226
127206: PUSH
127207: LD_VAR 0 4
127211: PPUSH
127212: LD_VAR 0 13
127216: PPUSH
127217: CALL_OW 296
127221: PUSH
127222: LD_INT 30
127224: LESS
127225: AND
127226: IFFALSE 127242
// ComAttackUnit ( i , e ) ;
127228: LD_VAR 0 4
127232: PPUSH
127233: LD_VAR 0 13
127237: PPUSH
127238: CALL_OW 115
// end ; end ; end ;
127242: GO 127245
127244: POP
// if IsDead ( i ) then
127245: LD_VAR 0 4
127249: PPUSH
127250: CALL_OW 301
127254: IFFALSE 127272
// defenders := defenders diff i ;
127256: LD_ADDR_VAR 0 2
127260: PUSH
127261: LD_VAR 0 2
127265: PUSH
127266: LD_VAR 0 4
127270: DIFF
127271: ST_TO_ADDR
// end ;
127272: GO 126339
127274: POP
127275: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
127276: LD_VAR 0 21
127280: NOT
127281: IFTRUE 127290
127283: PUSH
127284: LD_VAR 0 2
127288: NOT
127289: OR
127290: IFTRUE 127305
127292: PUSH
127293: LD_EXP 80
127297: PUSH
127298: LD_VAR 0 1
127302: ARRAY
127303: NOT
127304: OR
127305: IFFALSE 126241
// MC_Reset ( base , 18 ) ;
127307: LD_VAR 0 1
127311: PPUSH
127312: LD_INT 18
127314: PPUSH
127315: CALL 27518 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
127319: LD_ADDR_VAR 0 2
127323: PUSH
127324: LD_VAR 0 2
127328: PUSH
127329: LD_VAR 0 2
127333: PPUSH
127334: LD_INT 2
127336: PUSH
127337: LD_INT 25
127339: PUSH
127340: LD_INT 1
127342: PUSH
127343: EMPTY
127344: LIST
127345: LIST
127346: PUSH
127347: LD_INT 25
127349: PUSH
127350: LD_INT 5
127352: PUSH
127353: EMPTY
127354: LIST
127355: LIST
127356: PUSH
127357: LD_INT 25
127359: PUSH
127360: LD_INT 8
127362: PUSH
127363: EMPTY
127364: LIST
127365: LIST
127366: PUSH
127367: LD_INT 25
127369: PUSH
127370: LD_INT 9
127372: PUSH
127373: EMPTY
127374: LIST
127375: LIST
127376: PUSH
127377: EMPTY
127378: LIST
127379: LIST
127380: LIST
127381: LIST
127382: LIST
127383: PPUSH
127384: CALL_OW 72
127388: DIFF
127389: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
127390: LD_VAR 0 21
127394: NOT
127395: IFFALSE 127418
127397: PUSH
127398: LD_VAR 0 2
127402: PPUSH
127403: LD_INT 21
127405: PUSH
127406: LD_INT 2
127408: PUSH
127409: EMPTY
127410: LIST
127411: LIST
127412: PPUSH
127413: CALL_OW 72
127417: AND
127418: IFFALSE 127762
// begin tmp := FilterByTag ( defenders , 19 ) ;
127420: LD_ADDR_VAR 0 11
127424: PUSH
127425: LD_VAR 0 2
127429: PPUSH
127430: LD_INT 19
127432: PPUSH
127433: CALL 90146 0 2
127437: ST_TO_ADDR
// if tmp then
127438: LD_VAR 0 11
127442: IFFALSE 127512
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
127444: LD_ADDR_VAR 0 11
127448: PUSH
127449: LD_VAR 0 11
127453: PPUSH
127454: LD_INT 25
127456: PUSH
127457: LD_INT 3
127459: PUSH
127460: EMPTY
127461: LIST
127462: LIST
127463: PPUSH
127464: CALL_OW 72
127468: ST_TO_ADDR
// if tmp then
127469: LD_VAR 0 11
127473: IFFALSE 127512
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
127475: LD_ADDR_EXP 92
127479: PUSH
127480: LD_EXP 92
127484: PPUSH
127485: LD_VAR 0 1
127489: PPUSH
127490: LD_EXP 92
127494: PUSH
127495: LD_VAR 0 1
127499: ARRAY
127500: PUSH
127501: LD_VAR 0 11
127505: UNION
127506: PPUSH
127507: CALL_OW 1
127511: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
127512: LD_VAR 0 1
127516: PPUSH
127517: LD_INT 19
127519: PPUSH
127520: CALL 27518 0 2
// repeat wait ( 0 0$1 ) ;
127524: LD_INT 35
127526: PPUSH
127527: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
127531: LD_EXP 80
127535: PUSH
127536: LD_VAR 0 1
127540: ARRAY
127541: NOT
127542: IFTRUE 127559
127544: PUSH
127545: LD_EXP 80
127549: PUSH
127550: LD_VAR 0 1
127554: ARRAY
127555: PUSH
127556: EMPTY
127557: EQUAL
127558: OR
127559: IFFALSE 127596
// begin for i in defenders do
127561: LD_ADDR_VAR 0 4
127565: PUSH
127566: LD_VAR 0 2
127570: PUSH
127571: FOR_IN
127572: IFFALSE 127585
// ComStop ( i ) ;
127574: LD_VAR 0 4
127578: PPUSH
127579: CALL_OW 141
127583: GO 127571
127585: POP
127586: POP
// defenders := [ ] ;
127587: LD_ADDR_VAR 0 2
127591: PUSH
127592: EMPTY
127593: ST_TO_ADDR
// exit ;
127594: GO 127826
// end ; for i in defenders do
127596: LD_ADDR_VAR 0 4
127600: PUSH
127601: LD_VAR 0 2
127605: PUSH
127606: FOR_IN
127607: IFFALSE 127696
// begin if not IsInArea ( i , mc_parking [ base ] ) then
127609: LD_VAR 0 4
127613: PPUSH
127614: LD_EXP 104
127618: PUSH
127619: LD_VAR 0 1
127623: ARRAY
127624: PPUSH
127625: CALL_OW 308
127629: NOT
127630: IFFALSE 127654
// ComMoveToArea ( i , mc_parking [ base ] ) else
127632: LD_VAR 0 4
127636: PPUSH
127637: LD_EXP 104
127641: PUSH
127642: LD_VAR 0 1
127646: ARRAY
127647: PPUSH
127648: CALL_OW 113
127652: GO 127694
// if GetControl ( i ) = control_manual then
127654: LD_VAR 0 4
127658: PPUSH
127659: CALL_OW 263
127663: PUSH
127664: LD_INT 1
127666: EQUAL
127667: IFFALSE 127694
// if IsDrivenBy ( i ) then
127669: LD_VAR 0 4
127673: PPUSH
127674: CALL_OW 311
127678: IFFALSE 127694
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
127680: LD_VAR 0 4
127684: PPUSH
127685: CALL_OW 311
127689: PPUSH
127690: CALL_OW 121
// end ;
127694: GO 127606
127696: POP
127697: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
127698: LD_VAR 0 2
127702: PPUSH
127703: LD_INT 95
127705: PUSH
127706: LD_EXP 104
127710: PUSH
127711: LD_VAR 0 1
127715: ARRAY
127716: PUSH
127717: EMPTY
127718: LIST
127719: LIST
127720: PPUSH
127721: CALL_OW 72
127725: PUSH
127726: LD_VAR 0 2
127730: EQUAL
127731: IFTRUE 127745
127733: PUSH
127734: LD_EXP 103
127738: PUSH
127739: LD_VAR 0 1
127743: ARRAY
127744: OR
127745: IFTRUE 127760
127747: PUSH
127748: LD_EXP 80
127752: PUSH
127753: LD_VAR 0 1
127757: ARRAY
127758: NOT
127759: OR
127760: IFFALSE 127524
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
127762: LD_ADDR_EXP 102
127766: PUSH
127767: LD_EXP 102
127771: PPUSH
127772: LD_VAR 0 1
127776: PPUSH
127777: LD_VAR 0 2
127781: PPUSH
127782: LD_INT 21
127784: PUSH
127785: LD_INT 2
127787: PUSH
127788: EMPTY
127789: LIST
127790: LIST
127791: PPUSH
127792: CALL_OW 72
127796: PPUSH
127797: CALL_OW 1
127801: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
127802: LD_VAR 0 1
127806: PPUSH
127807: LD_INT 19
127809: PPUSH
127810: CALL 27518 0 2
// MC_Reset ( base , 20 ) ;
127814: LD_VAR 0 1
127818: PPUSH
127819: LD_INT 20
127821: PPUSH
127822: CALL 27518 0 2
// end ; end_of_file
127826: LD_VAR 0 3
127830: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
127831: LD_VAR 0 1
127835: PUSH
127836: LD_INT 200
127838: DOUBLE
127839: GREATEREQUAL
127840: IFFALSE 127848
127842: LD_INT 299
127844: DOUBLE
127845: LESSEQUAL
127846: IFTRUE 127850
127848: GO 127882
127850: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
127851: LD_VAR 0 1
127855: PPUSH
127856: LD_VAR 0 2
127860: PPUSH
127861: LD_VAR 0 3
127865: PPUSH
127866: LD_VAR 0 4
127870: PPUSH
127871: LD_VAR 0 5
127875: PPUSH
127876: CALL 114784 0 5
127880: GO 127959
127882: LD_INT 300
127884: DOUBLE
127885: GREATEREQUAL
127886: IFFALSE 127894
127888: LD_INT 399
127890: DOUBLE
127891: LESSEQUAL
127892: IFTRUE 127896
127894: GO 127958
127896: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
127897: LD_VAR 0 1
127901: PPUSH
127902: LD_VAR 0 2
127906: PPUSH
127907: LD_VAR 0 3
127911: PPUSH
127912: LD_VAR 0 4
127916: PPUSH
127917: LD_VAR 0 5
127921: PPUSH
127922: LD_VAR 0 6
127926: PPUSH
127927: LD_VAR 0 7
127931: PPUSH
127932: LD_VAR 0 8
127936: PPUSH
127937: LD_VAR 0 9
127941: PPUSH
127942: LD_VAR 0 10
127946: PPUSH
127947: LD_VAR 0 11
127951: PPUSH
127952: CALL 110587 0 11
127956: GO 127959
127958: POP
// end ;
127959: PPOPN 11
127961: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
127962: LD_VAR 0 1
127966: PPUSH
127967: LD_VAR 0 2
127971: PPUSH
127972: LD_VAR 0 3
127976: PPUSH
127977: LD_VAR 0 4
127981: PPUSH
127982: LD_VAR 0 5
127986: PPUSH
127987: CALL 114084 0 5
// end ; end_of_file
127991: PPOPN 5
127993: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
127994: LD_VAR 0 1
127998: PPUSH
127999: LD_VAR 0 2
128003: PPUSH
128004: LD_VAR 0 3
128008: PPUSH
128009: LD_VAR 0 4
128013: PPUSH
128014: LD_VAR 0 5
128018: PPUSH
128019: LD_VAR 0 6
128023: PPUSH
128024: CALL 98127 0 6
// end ;
128028: PPOPN 6
128030: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
128031: LD_INT 0
128033: PPUSH
// begin if not units then
128034: LD_VAR 0 1
128038: NOT
128039: IFFALSE 128043
// exit ;
128041: GO 128077
// SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ;
128043: LD_VAR 0 1
128047: PPUSH
128048: LD_VAR 0 2
128052: PPUSH
128053: LD_VAR 0 3
128057: PPUSH
128058: LD_VAR 0 4
128062: PPUSH
128063: LD_VAR 0 5
128067: PPUSH
128068: LD_VAR 0 6
128072: PPUSH
128073: CALL 120381 0 6
// end ;
128077: PPOPN 7
128079: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
128080: CALL 98014 0 0
// end ;
128084: PPOPN 1
128086: END
