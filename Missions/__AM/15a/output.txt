// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 21287 0 0
// InitNature ;
  19: CALL 17953 0 0
// InitArtifact ;
  23: CALL 18570 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5102 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 6874 0 0
// PrepareRussian ;
  52: CALL 8883 0 0
// PrepareLegion ;
  56: CALL 7306 0 0
// Action ;
  60: CALL 11516 0 0
// MC_Start ( ) ;
  64: CALL 23459 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 101
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 102
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 45197 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 46257 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 46350 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 106
 353: PUSH
 354: LD_EXP 106
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 45515 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 45700 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 46257 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 46350 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 45515 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 45700 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 46130 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 45197 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 46257 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 46350 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 106
 843: PUSH
 844: LD_EXP 106
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 45515 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 45700 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 46257 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 46350 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 46668 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 46462 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 45515 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 45700 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 46081 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// uc_side := 7 ;
1443: LD_ADDR_OWVAR 20
1447: PUSH
1448: LD_INT 7
1450: ST_TO_ADDR
// tmp := [ ] ;
1451: LD_ADDR_VAR 0 5
1455: PUSH
1456: EMPTY
1457: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1458: LD_ADDR_EXP 19
1462: PUSH
1463: LD_STRING JMM
1465: PPUSH
1466: LD_EXP 1
1470: NOT
1471: PPUSH
1472: LD_STRING 14a_
1474: PPUSH
1475: CALL 51951 0 3
1479: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1480: LD_ADDR_EXP 52
1484: PUSH
1485: LD_STRING Burlak
1487: PPUSH
1488: LD_EXP 1
1492: NOT
1493: PPUSH
1494: LD_STRING 14a_
1496: PPUSH
1497: CALL 51951 0 3
1501: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1502: LD_ADDR_EXP 34
1506: PUSH
1507: LD_STRING Joan
1509: PPUSH
1510: LD_EXP 1
1514: NOT
1515: PPUSH
1516: LD_STRING 13a_
1518: PPUSH
1519: CALL 51951 0 3
1523: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1524: LD_ADDR_EXP 20
1528: PUSH
1529: LD_STRING Roth
1531: PPUSH
1532: LD_EXP 1
1536: NOT
1537: PPUSH
1538: LD_STRING 13a_
1540: PPUSH
1541: CALL 51951 0 3
1545: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1546: LD_ADDR_EXP 38
1550: PUSH
1551: LD_STRING Gossudarov
1553: PPUSH
1554: LD_EXP 1
1558: NOT
1559: PPUSH
1560: LD_STRING 13a_
1562: PPUSH
1563: CALL 51951 0 3
1567: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1568: LD_ADDR_EXP 25
1572: PUSH
1573: LD_STRING Denis
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 13a_
1584: PPUSH
1585: CALL 51951 0 3
1589: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1590: LD_ADDR_EXP 35
1594: PUSH
1595: LD_STRING DeltaDoctor
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 13a_
1606: PPUSH
1607: CALL 51951 0 3
1611: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1612: LD_ADDR_EXP 37
1616: PUSH
1617: LD_STRING Mike
1619: PPUSH
1620: LD_EXP 1
1624: NOT
1625: PPUSH
1626: LD_STRING 13a_
1628: PPUSH
1629: CALL 51951 0 3
1633: ST_TO_ADDR
// if DeltaDoctor then
1634: LD_EXP 35
1638: IFFALSE 1656
// tmp := tmp ^ DeltaDoctor ;
1640: LD_ADDR_VAR 0 5
1644: PUSH
1645: LD_VAR 0 5
1649: PUSH
1650: LD_EXP 35
1654: ADD
1655: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1656: LD_ADDR_EXP 33
1660: PUSH
1661: LD_STRING Simms
1663: PPUSH
1664: LD_EXP 1
1668: NOT
1669: PPUSH
1670: LD_STRING 13a_
1672: PPUSH
1673: CALL 51951 0 3
1677: ST_TO_ADDR
// if Simms then
1678: LD_EXP 33
1682: IFFALSE 1700
// tmp := tmp ^ Simms ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_VAR 0 5
1693: PUSH
1694: LD_EXP 33
1698: ADD
1699: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1700: LD_ADDR_EXP 31
1704: PUSH
1705: LD_STRING Frank
1707: PPUSH
1708: LD_EXP 1
1712: NOT
1713: PPUSH
1714: LD_STRING 13a_
1716: PPUSH
1717: CALL 51951 0 3
1721: ST_TO_ADDR
// if Frank then
1722: LD_EXP 31
1726: IFFALSE 1744
// tmp := tmp ^ Frank ;
1728: LD_ADDR_VAR 0 5
1732: PUSH
1733: LD_VAR 0 5
1737: PUSH
1738: LD_EXP 31
1742: ADD
1743: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1744: LD_ADDR_EXP 39
1748: PUSH
1749: LD_STRING Kirilenkova
1751: PPUSH
1752: LD_EXP 1
1756: NOT
1757: PPUSH
1758: LD_STRING 13a_
1760: PPUSH
1761: CALL 51951 0 3
1765: ST_TO_ADDR
// if Kirilenkova then
1766: LD_EXP 39
1770: IFFALSE 1788
// tmp := tmp ^ Kirilenkova ;
1772: LD_ADDR_VAR 0 5
1776: PUSH
1777: LD_VAR 0 5
1781: PUSH
1782: LD_EXP 39
1786: ADD
1787: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1788: LD_ADDR_EXP 40
1792: PUSH
1793: LD_STRING Titov
1795: PPUSH
1796: LD_EXP 1
1800: NOT
1801: PPUSH
1802: LD_STRING 13a_
1804: PPUSH
1805: CALL 51951 0 3
1809: ST_TO_ADDR
// if Titov then
1810: LD_EXP 40
1814: IFFALSE 1832
// tmp := tmp ^ Titov ;
1816: LD_ADDR_VAR 0 5
1820: PUSH
1821: LD_VAR 0 5
1825: PUSH
1826: LD_EXP 40
1830: ADD
1831: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1832: LD_ADDR_EXP 41
1836: PUSH
1837: LD_STRING Fadeev
1839: PPUSH
1840: LD_EXP 1
1844: NOT
1845: PPUSH
1846: LD_STRING 13a_
1848: PPUSH
1849: CALL 51951 0 3
1853: ST_TO_ADDR
// if Fadeev then
1854: LD_EXP 41
1858: IFFALSE 1876
// tmp := tmp ^ Fadeev ;
1860: LD_ADDR_VAR 0 5
1864: PUSH
1865: LD_VAR 0 5
1869: PUSH
1870: LD_EXP 41
1874: ADD
1875: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1876: LD_ADDR_EXP 42
1880: PUSH
1881: LD_STRING Dolgov
1883: PPUSH
1884: LD_EXP 1
1888: NOT
1889: PPUSH
1890: LD_STRING 13a_
1892: PPUSH
1893: CALL 51951 0 3
1897: ST_TO_ADDR
// if Dolgov then
1898: LD_EXP 42
1902: IFFALSE 1920
// tmp := tmp ^ Dolgov ;
1904: LD_ADDR_VAR 0 5
1908: PUSH
1909: LD_VAR 0 5
1913: PUSH
1914: LD_EXP 42
1918: ADD
1919: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1920: LD_ADDR_EXP 43
1924: PUSH
1925: LD_STRING Petrosyan
1927: PPUSH
1928: LD_EXP 1
1932: NOT
1933: PPUSH
1934: LD_STRING 13a_
1936: PPUSH
1937: CALL 51951 0 3
1941: ST_TO_ADDR
// if Petrosyan then
1942: LD_EXP 43
1946: IFFALSE 1964
// tmp := tmp ^ Petrosyan ;
1948: LD_ADDR_VAR 0 5
1952: PUSH
1953: LD_VAR 0 5
1957: PUSH
1958: LD_EXP 43
1962: ADD
1963: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1964: LD_ADDR_EXP 44
1968: PUSH
1969: LD_STRING Scholtze
1971: PPUSH
1972: LD_EXP 1
1976: NOT
1977: PPUSH
1978: LD_STRING 13a_
1980: PPUSH
1981: CALL 51951 0 3
1985: ST_TO_ADDR
// if Scholtze then
1986: LD_EXP 44
1990: IFFALSE 2008
// tmp := tmp ^ Scholtze ;
1992: LD_ADDR_VAR 0 5
1996: PUSH
1997: LD_VAR 0 5
2001: PUSH
2002: LD_EXP 44
2006: ADD
2007: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2008: LD_ADDR_EXP 45
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: LD_EXP 1
2020: NOT
2021: PPUSH
2022: LD_STRING 13a_
2024: PPUSH
2025: CALL 51951 0 3
2029: ST_TO_ADDR
// if Oblukov then
2030: LD_EXP 45
2034: IFFALSE 2052
// tmp := tmp ^ Oblukov ;
2036: LD_ADDR_VAR 0 5
2040: PUSH
2041: LD_VAR 0 5
2045: PUSH
2046: LD_EXP 45
2050: ADD
2051: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2052: LD_ADDR_EXP 46
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: LD_EXP 1
2064: NOT
2065: PPUSH
2066: LD_STRING 13a_
2068: PPUSH
2069: CALL 51951 0 3
2073: ST_TO_ADDR
// if Kapitsova then
2074: LD_EXP 46
2078: IFFALSE 2096
// tmp := tmp ^ Kapitsova ;
2080: LD_ADDR_VAR 0 5
2084: PUSH
2085: LD_VAR 0 5
2089: PUSH
2090: LD_EXP 46
2094: ADD
2095: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2096: LD_ADDR_EXP 47
2100: PUSH
2101: LD_STRING Lipshchin
2103: PPUSH
2104: LD_EXP 1
2108: NOT
2109: PPUSH
2110: LD_STRING 13a_
2112: PPUSH
2113: CALL 51951 0 3
2117: ST_TO_ADDR
// if Lipshchin then
2118: LD_EXP 47
2122: IFFALSE 2140
// tmp := tmp ^ Lipshchin ;
2124: LD_ADDR_VAR 0 5
2128: PUSH
2129: LD_VAR 0 5
2133: PUSH
2134: LD_EXP 47
2138: ADD
2139: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2140: LD_ADDR_EXP 48
2144: PUSH
2145: LD_STRING Petrovova
2147: PPUSH
2148: LD_EXP 1
2152: NOT
2153: PPUSH
2154: LD_STRING 13a_
2156: PPUSH
2157: CALL 51951 0 3
2161: ST_TO_ADDR
// if Petrovova then
2162: LD_EXP 48
2166: IFFALSE 2184
// tmp := tmp ^ Petrovova ;
2168: LD_ADDR_VAR 0 5
2172: PUSH
2173: LD_VAR 0 5
2177: PUSH
2178: LD_EXP 48
2182: ADD
2183: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2184: LD_ADDR_EXP 49
2188: PUSH
2189: LD_STRING Kovalyuk
2191: PPUSH
2192: LD_EXP 1
2196: NOT
2197: PPUSH
2198: LD_STRING 13a_
2200: PPUSH
2201: CALL 51951 0 3
2205: ST_TO_ADDR
// if Kovalyuk then
2206: LD_EXP 49
2210: IFFALSE 2228
// tmp := tmp ^ Kovalyuk ;
2212: LD_ADDR_VAR 0 5
2216: PUSH
2217: LD_VAR 0 5
2221: PUSH
2222: LD_EXP 49
2226: ADD
2227: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2228: LD_ADDR_EXP 50
2232: PUSH
2233: LD_STRING Kuzmov
2235: PPUSH
2236: LD_EXP 1
2240: NOT
2241: PPUSH
2242: LD_STRING 13a_
2244: PPUSH
2245: CALL 51951 0 3
2249: ST_TO_ADDR
// if Kuzmov then
2250: LD_EXP 50
2254: IFFALSE 2272
// tmp := tmp ^ Kuzmov ;
2256: LD_ADDR_VAR 0 5
2260: PUSH
2261: LD_VAR 0 5
2265: PUSH
2266: LD_EXP 50
2270: ADD
2271: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2272: LD_ADDR_EXP 51
2276: PUSH
2277: LD_STRING Karamazov
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: LD_STRING 13a_
2288: PPUSH
2289: CALL 51951 0 3
2293: ST_TO_ADDR
// if Karamazov then
2294: LD_EXP 51
2298: IFFALSE 2316
// tmp := tmp ^ Karamazov ;
2300: LD_ADDR_VAR 0 5
2304: PUSH
2305: LD_VAR 0 5
2309: PUSH
2310: LD_EXP 51
2314: ADD
2315: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2316: LD_ADDR_EXP 53
2320: PUSH
2321: LD_STRING Belkov
2323: PPUSH
2324: LD_EXP 1
2328: NOT
2329: PPUSH
2330: LD_STRING 13a_
2332: PPUSH
2333: CALL 51951 0 3
2337: ST_TO_ADDR
// if Belkov then
2338: LD_EXP 53
2342: IFFALSE 2360
// tmp := tmp ^ Belkov ;
2344: LD_ADDR_VAR 0 5
2348: PUSH
2349: LD_VAR 0 5
2353: PUSH
2354: LD_EXP 53
2358: ADD
2359: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 54
2364: PUSH
2365: LD_STRING Gnyevko
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 51951 0 3
2381: ST_TO_ADDR
// if Gnyevko then
2382: LD_EXP 54
2386: IFFALSE 2404
// tmp := tmp ^ Gnyevko ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 54
2402: ADD
2403: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2404: LD_ADDR_EXP 36
2408: PUSH
2409: LD_STRING Coonie
2411: PPUSH
2412: CALL_OW 25
2416: ST_TO_ADDR
// if not Lisa then
2417: LD_EXP 21
2421: NOT
2422: IFFALSE 2468
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2424: LD_ADDR_EXP 21
2428: PUSH
2429: LD_STRING Lisa
2431: PPUSH
2432: LD_EXP 1
2436: NOT
2437: PPUSH
2438: LD_STRING 13a_
2440: PPUSH
2441: CALL 51951 0 3
2445: ST_TO_ADDR
// if Lisa then
2446: LD_EXP 21
2450: IFFALSE 2468
// tmp := tmp ^ Lisa ;
2452: LD_ADDR_VAR 0 5
2456: PUSH
2457: LD_VAR 0 5
2461: PUSH
2462: LD_EXP 21
2466: ADD
2467: ST_TO_ADDR
// end ; if not Donaldson then
2468: LD_EXP 22
2472: NOT
2473: IFFALSE 2519
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2475: LD_ADDR_EXP 22
2479: PUSH
2480: LD_STRING Donaldson
2482: PPUSH
2483: LD_EXP 1
2487: NOT
2488: PPUSH
2489: LD_STRING 13a_
2491: PPUSH
2492: CALL 51951 0 3
2496: ST_TO_ADDR
// if Donaldson then
2497: LD_EXP 22
2501: IFFALSE 2519
// tmp := tmp ^ Donaldson ;
2503: LD_ADDR_VAR 0 5
2507: PUSH
2508: LD_VAR 0 5
2512: PUSH
2513: LD_EXP 22
2517: ADD
2518: ST_TO_ADDR
// end ; if not Bobby then
2519: LD_EXP 23
2523: NOT
2524: IFFALSE 2570
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2526: LD_ADDR_EXP 23
2530: PUSH
2531: LD_STRING Bobby
2533: PPUSH
2534: LD_EXP 1
2538: NOT
2539: PPUSH
2540: LD_STRING 13a_
2542: PPUSH
2543: CALL 51951 0 3
2547: ST_TO_ADDR
// if Bobby then
2548: LD_EXP 23
2552: IFFALSE 2570
// tmp := tmp ^ Bobby ;
2554: LD_ADDR_VAR 0 5
2558: PUSH
2559: LD_VAR 0 5
2563: PUSH
2564: LD_EXP 23
2568: ADD
2569: ST_TO_ADDR
// end ; if not Cyrus then
2570: LD_EXP 24
2574: NOT
2575: IFFALSE 2621
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2577: LD_ADDR_EXP 24
2581: PUSH
2582: LD_STRING Cyrus
2584: PPUSH
2585: LD_EXP 1
2589: NOT
2590: PPUSH
2591: LD_STRING 13a_
2593: PPUSH
2594: CALL 51951 0 3
2598: ST_TO_ADDR
// if Cyrus then
2599: LD_EXP 24
2603: IFFALSE 2621
// tmp := tmp ^ Cyrus ;
2605: LD_ADDR_VAR 0 5
2609: PUSH
2610: LD_VAR 0 5
2614: PUSH
2615: LD_EXP 24
2619: ADD
2620: ST_TO_ADDR
// end ; if not Brown then
2621: LD_EXP 26
2625: NOT
2626: IFFALSE 2672
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2628: LD_ADDR_EXP 26
2632: PUSH
2633: LD_STRING Brown
2635: PPUSH
2636: LD_EXP 1
2640: NOT
2641: PPUSH
2642: LD_STRING 13a_
2644: PPUSH
2645: CALL 51951 0 3
2649: ST_TO_ADDR
// if Brown then
2650: LD_EXP 26
2654: IFFALSE 2672
// tmp := tmp ^ Brown ;
2656: LD_ADDR_VAR 0 5
2660: PUSH
2661: LD_VAR 0 5
2665: PUSH
2666: LD_EXP 26
2670: ADD
2671: ST_TO_ADDR
// end ; if not Gladstone then
2672: LD_EXP 27
2676: NOT
2677: IFFALSE 2723
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2679: LD_ADDR_EXP 27
2683: PUSH
2684: LD_STRING Gladstone
2686: PPUSH
2687: LD_EXP 1
2691: NOT
2692: PPUSH
2693: LD_STRING 13a_
2695: PPUSH
2696: CALL 51951 0 3
2700: ST_TO_ADDR
// if Gladstone then
2701: LD_EXP 27
2705: IFFALSE 2723
// tmp := tmp ^ Gladstone ;
2707: LD_ADDR_VAR 0 5
2711: PUSH
2712: LD_VAR 0 5
2716: PUSH
2717: LD_EXP 27
2721: ADD
2722: ST_TO_ADDR
// end ; if not Cornel then
2723: LD_EXP 29
2727: NOT
2728: IFFALSE 2774
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2730: LD_ADDR_EXP 29
2734: PUSH
2735: LD_STRING Cornel
2737: PPUSH
2738: LD_EXP 1
2742: NOT
2743: PPUSH
2744: LD_STRING 13a_
2746: PPUSH
2747: CALL 51951 0 3
2751: ST_TO_ADDR
// if Cornel then
2752: LD_EXP 29
2756: IFFALSE 2774
// tmp := tmp ^ Cornel ;
2758: LD_ADDR_VAR 0 5
2762: PUSH
2763: LD_VAR 0 5
2767: PUSH
2768: LD_EXP 29
2772: ADD
2773: ST_TO_ADDR
// end ; if not Houten then
2774: LD_EXP 28
2778: NOT
2779: IFFALSE 2825
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2781: LD_ADDR_EXP 28
2785: PUSH
2786: LD_STRING Houten
2788: PPUSH
2789: LD_EXP 1
2793: NOT
2794: PPUSH
2795: LD_STRING 13a_
2797: PPUSH
2798: CALL 51951 0 3
2802: ST_TO_ADDR
// if Houten then
2803: LD_EXP 28
2807: IFFALSE 2825
// tmp := tmp ^ Houten ;
2809: LD_ADDR_VAR 0 5
2813: PUSH
2814: LD_VAR 0 5
2818: PUSH
2819: LD_EXP 28
2823: ADD
2824: ST_TO_ADDR
// end ; if not Gary then
2825: LD_EXP 30
2829: NOT
2830: IFFALSE 2876
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2832: LD_ADDR_EXP 30
2836: PUSH
2837: LD_STRING Gary
2839: PPUSH
2840: LD_EXP 1
2844: NOT
2845: PPUSH
2846: LD_STRING 13a_
2848: PPUSH
2849: CALL 51951 0 3
2853: ST_TO_ADDR
// if Gary then
2854: LD_EXP 30
2858: IFFALSE 2876
// tmp := tmp ^ Gary ;
2860: LD_ADDR_VAR 0 5
2864: PUSH
2865: LD_VAR 0 5
2869: PUSH
2870: LD_EXP 30
2874: ADD
2875: ST_TO_ADDR
// end ; if not Kikuchi then
2876: LD_EXP 32
2880: NOT
2881: IFFALSE 2927
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2883: LD_ADDR_EXP 32
2887: PUSH
2888: LD_STRING Kikuchi
2890: PPUSH
2891: LD_EXP 1
2895: NOT
2896: PPUSH
2897: LD_STRING 13a_
2899: PPUSH
2900: CALL 51951 0 3
2904: ST_TO_ADDR
// if Kikuchi then
2905: LD_EXP 32
2909: IFFALSE 2927
// tmp := tmp ^ Kikuchi ;
2911: LD_ADDR_VAR 0 5
2915: PUSH
2916: LD_VAR 0 5
2920: PUSH
2921: LD_EXP 32
2925: ADD
2926: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2927: LD_ADDR_VAR 0 5
2931: PUSH
2932: LD_VAR 0 5
2936: PUSH
2937: LD_STRING 13a_others
2939: PPUSH
2940: CALL_OW 31
2944: UNION
2945: ST_TO_ADDR
// tmp := tmp diff 0 ;
2946: LD_ADDR_VAR 0 5
2950: PUSH
2951: LD_VAR 0 5
2955: PUSH
2956: LD_INT 0
2958: DIFF
2959: ST_TO_ADDR
// if tmp < 15 then
2960: LD_VAR 0 5
2964: PUSH
2965: LD_INT 15
2967: LESS
2968: IFFALSE 3056
// for i = 15 downto tmp do
2970: LD_ADDR_VAR 0 2
2974: PUSH
2975: DOUBLE
2976: LD_INT 15
2978: INC
2979: ST_TO_ADDR
2980: LD_VAR 0 5
2984: PUSH
2985: FOR_DOWNTO
2986: IFFALSE 3054
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2988: LD_ADDR_OWVAR 21
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 3
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: PUSH
3003: LD_INT 1
3005: PPUSH
3006: LD_INT 2
3008: PPUSH
3009: CALL_OW 12
3013: ARRAY
3014: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3015: LD_INT 0
3017: PPUSH
3018: LD_INT 1
3020: PPUSH
3021: LD_INT 4
3023: PPUSH
3024: CALL_OW 12
3028: PPUSH
3029: LD_INT 8
3031: PPUSH
3032: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3036: LD_ADDR_VAR 0 5
3040: PUSH
3041: LD_VAR 0 5
3045: PUSH
3046: CALL_OW 44
3050: ADD
3051: ST_TO_ADDR
// end ;
3052: GO 2985
3054: POP
3055: POP
// if not debug then
3056: LD_EXP 1
3060: NOT
3061: IFFALSE 3241
// selected = CharacterSelection (  , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3063: LD_ADDR_VAR 0 4
3067: PUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_INT 14
3073: PUSH
3074: LD_INT 14
3076: PUSH
3077: LD_INT 13
3079: PUSH
3080: LD_INT 12
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: LD_OWVAR 67
3093: ARRAY
3094: PPUSH
3095: LD_INT 14
3097: PUSH
3098: LD_INT 14
3100: PUSH
3101: LD_INT 13
3103: PUSH
3104: LD_INT 12
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: LD_INT -5
3121: PUSH
3122: LD_EXP 19
3126: PUSH
3127: LD_EXP 52
3131: PUSH
3132: LD_EXP 20
3136: PUSH
3137: LD_EXP 34
3141: PUSH
3142: LD_EXP 25
3146: PUSH
3147: LD_EXP 38
3151: PUSH
3152: LD_INT -2
3154: PUSH
3155: LD_INT -3
3157: PUSH
3158: LD_INT -5
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: PUSH
3173: LD_VAR 0 5
3177: ADD
3178: PPUSH
3179: LD_INT 1
3181: PUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 1
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 3
3197: PUSH
3198: LD_INT 5
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: LD_INT 9
3214: PUSH
3215: LD_INT 0
3217: PUSH
3218: LD_INT 3
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: PPUSH
3234: CALL_OW 42
3238: ST_TO_ADDR
3239: GO 3290
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3241: LD_ADDR_VAR 0 4
3245: PUSH
3246: LD_EXP 40
3250: PUSH
3251: LD_EXP 41
3255: PUSH
3256: LD_EXP 42
3260: PUSH
3261: LD_EXP 43
3265: PUSH
3266: LD_EXP 44
3270: PUSH
3271: LD_EXP 45
3275: PUSH
3276: LD_EXP 46
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3290: LD_ADDR_EXP 17
3294: PUSH
3295: LD_VAR 0 5
3299: PUSH
3300: LD_VAR 0 4
3304: DIFF
3305: ST_TO_ADDR
// uc_nation := 1 ;
3306: LD_ADDR_OWVAR 21
3310: PUSH
3311: LD_INT 1
3313: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3314: LD_INT 5
3316: PPUSH
3317: LD_INT 3
3319: PPUSH
3320: LD_INT 1
3322: PPUSH
3323: LD_INT 6
3325: PPUSH
3326: LD_INT 100
3328: PPUSH
3329: CALL 56966 0 5
// veh := CreateVehicle ;
3333: LD_ADDR_VAR 0 3
3337: PUSH
3338: CALL_OW 45
3342: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3343: LD_VAR 0 3
3347: PPUSH
3348: LD_INT 7
3350: NEG
3351: PPUSH
3352: CALL_OW 242
// SetDir ( veh , 3 ) ;
3356: LD_VAR 0 3
3360: PPUSH
3361: LD_INT 3
3363: PPUSH
3364: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3368: LD_VAR 0 3
3372: PPUSH
3373: LD_INT 31
3375: PPUSH
3376: LD_INT 0
3378: PPUSH
3379: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3383: LD_EXP 19
3387: PPUSH
3388: LD_VAR 0 3
3392: PPUSH
3393: CALL_OW 52
// if Joan then
3397: LD_EXP 34
3401: IFFALSE 3473
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3403: LD_INT 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: LD_INT 1
3411: PPUSH
3412: LD_INT 11
3414: PPUSH
3415: LD_INT 100
3417: PPUSH
3418: CALL 56966 0 5
// veh := CreateVehicle ;
3422: LD_ADDR_VAR 0 3
3426: PUSH
3427: CALL_OW 45
3431: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3432: LD_VAR 0 3
3436: PPUSH
3437: LD_INT 3
3439: PPUSH
3440: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3444: LD_VAR 0 3
3448: PPUSH
3449: LD_INT 30
3451: PPUSH
3452: LD_INT 0
3454: PPUSH
3455: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3459: LD_EXP 34
3463: PPUSH
3464: LD_VAR 0 3
3468: PPUSH
3469: CALL_OW 52
// end ; if Roth then
3473: LD_EXP 20
3477: IFFALSE 3549
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3479: LD_INT 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: LD_INT 11
3490: PPUSH
3491: LD_INT 100
3493: PPUSH
3494: CALL 56966 0 5
// veh := CreateVehicle ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: CALL_OW 45
3507: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3508: LD_VAR 0 3
3512: PPUSH
3513: LD_INT 3
3515: PPUSH
3516: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3520: LD_VAR 0 3
3524: PPUSH
3525: LD_INT 30
3527: PPUSH
3528: LD_INT 0
3530: PPUSH
3531: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3535: LD_EXP 20
3539: PPUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: CALL_OW 52
// end ; if Denis then
3549: LD_EXP 25
3553: IFFALSE 3625
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3555: LD_INT 5
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: LD_INT 1
3563: PPUSH
3564: LD_INT 9
3566: PPUSH
3567: LD_INT 100
3569: PPUSH
3570: CALL 56966 0 5
// veh := CreateVehicle ;
3574: LD_ADDR_VAR 0 3
3578: PUSH
3579: CALL_OW 45
3583: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3584: LD_VAR 0 3
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3596: LD_VAR 0 3
3600: PPUSH
3601: LD_INT 30
3603: PPUSH
3604: LD_INT 0
3606: PPUSH
3607: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3611: LD_EXP 25
3615: PPUSH
3616: LD_VAR 0 3
3620: PPUSH
3621: CALL_OW 52
// end ; uc_nation := 3 ;
3625: LD_ADDR_OWVAR 21
3629: PUSH
3630: LD_INT 3
3632: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3633: LD_INT 22
3635: PPUSH
3636: LD_INT 3
3638: PPUSH
3639: LD_INT 1
3641: PPUSH
3642: LD_INT 45
3644: PPUSH
3645: LD_INT 100
3647: PPUSH
3648: CALL 56966 0 5
// veh := CreateVehicle ;
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: CALL_OW 45
3661: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3662: LD_VAR 0 3
3666: PPUSH
3667: LD_INT 7
3669: NEG
3670: PPUSH
3671: CALL_OW 242
// SetDir ( veh , 3 ) ;
3675: LD_VAR 0 3
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3687: LD_VAR 0 3
3691: PPUSH
3692: LD_INT 31
3694: PPUSH
3695: LD_INT 0
3697: PPUSH
3698: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3702: LD_EXP 52
3706: PPUSH
3707: LD_VAR 0 3
3711: PPUSH
3712: CALL_OW 52
// if Gossudarov then
3716: LD_EXP 38
3720: IFFALSE 3807
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3722: LD_INT 22
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: LD_INT 51
3733: PPUSH
3734: LD_INT 100
3736: PPUSH
3737: CALL 56966 0 5
// veh := CreateVehicle ;
3741: LD_ADDR_VAR 0 3
3745: PUSH
3746: CALL_OW 45
3750: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3751: LD_VAR 0 3
3755: PPUSH
3756: LD_INT 3
3758: PPUSH
3759: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3763: LD_VAR 0 3
3767: PPUSH
3768: LD_INT 30
3770: PPUSH
3771: LD_INT 0
3773: PPUSH
3774: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3778: LD_EXP 38
3782: PPUSH
3783: LD_VAR 0 3
3787: PPUSH
3788: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3792: LD_VAR 0 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 100
3802: PPUSH
3803: CALL_OW 290
// end ; if Mike then
3807: LD_EXP 37
3811: IFFALSE 3828
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3813: LD_EXP 37
3817: PPUSH
3818: LD_INT 30
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 49
// for i in selected do
3828: LD_ADDR_VAR 0 2
3832: PUSH
3833: LD_VAR 0 4
3837: PUSH
3838: FOR_IN
3839: IFFALSE 4397
// begin uc_nation := GetNation ( i ) ;
3841: LD_ADDR_OWVAR 21
3845: PUSH
3846: LD_VAR 0 2
3850: PPUSH
3851: CALL_OW 248
3855: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3856: LD_VAR 0 2
3860: PUSH
3861: LD_EXP 21
3865: PUSH
3866: LD_EXP 22
3870: PUSH
3871: LD_EXP 24
3875: PUSH
3876: LD_EXP 23
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: LIST
3885: LIST
3886: IN
3887: IFFALSE 3910
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3889: LD_INT 5
3891: PPUSH
3892: LD_INT 3
3894: PPUSH
3895: LD_INT 1
3897: PPUSH
3898: LD_INT 6
3900: PPUSH
3901: LD_INT 100
3903: PPUSH
3904: CALL 56966 0 5
3908: GO 4344
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3910: LD_VAR 0 2
3914: PUSH
3915: LD_EXP 45
3919: PUSH
3920: LD_EXP 50
3924: PUSH
3925: LD_EXP 48
3929: PUSH
3930: LD_EXP 40
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: IN
3941: IFFALSE 3972
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3943: LD_INT 24
3945: PPUSH
3946: LD_INT 1
3948: PPUSH
3949: LD_INT 1
3951: PPUSH
3952: LD_INT 46
3954: PPUSH
3955: LD_INT 65
3957: PPUSH
3958: LD_INT 75
3960: PPUSH
3961: CALL_OW 12
3965: PPUSH
3966: CALL 56966 0 5
3970: GO 4344
// if i = Karamazov then
3972: LD_VAR 0 2
3976: PUSH
3977: LD_EXP 51
3981: EQUAL
3982: IFFALSE 4005
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3984: LD_INT 22
3986: PPUSH
3987: LD_INT 3
3989: PPUSH
3990: LD_INT 1
3992: PPUSH
3993: LD_INT 52
3995: PPUSH
3996: LD_INT 100
3998: PPUSH
3999: CALL 56966 0 5
4003: GO 4344
// if i = Brown then
4005: LD_VAR 0 2
4009: PUSH
4010: LD_EXP 26
4014: EQUAL
4015: IFFALSE 4038
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4017: LD_INT 3
4019: PPUSH
4020: LD_INT 3
4022: PPUSH
4023: LD_INT 1
4025: PPUSH
4026: LD_INT 13
4028: PPUSH
4029: LD_INT 100
4031: PPUSH
4032: CALL 56966 0 5
4036: GO 4344
// if uc_nation = nation_american then
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 1
4045: EQUAL
4046: IFFALSE 4197
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4048: LD_INT 3
4050: PUSH
4051: LD_INT 5
4053: PUSH
4054: LD_INT 5
4056: PUSH
4057: EMPTY
4058: LIST
4059: LIST
4060: LIST
4061: PUSH
4062: LD_OWVAR 21
4066: PUSH
4067: LD_INT 3
4069: MOD
4070: PUSH
4071: LD_INT 1
4073: PLUS
4074: ARRAY
4075: PPUSH
4076: LD_INT 1
4078: PUSH
4079: LD_INT 3
4081: PUSH
4082: LD_INT 1
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: LIST
4089: PUSH
4090: LD_OWVAR 21
4094: PUSH
4095: LD_INT 3
4097: MOD
4098: PUSH
4099: LD_INT 1
4101: PLUS
4102: ARRAY
4103: PPUSH
4104: LD_INT 1
4106: PPUSH
4107: LD_INT 11
4109: PUSH
4110: LD_INT 4
4112: PUSH
4113: LD_INT 5
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PUSH
4121: LD_INT 6
4123: PUSH
4124: LD_INT 7
4126: PUSH
4127: LD_INT 9
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: PUSH
4135: LD_INT 6
4137: PUSH
4138: LD_INT 9
4140: PUSH
4141: LD_INT 12
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: LIST
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: LD_OWVAR 21
4158: PUSH
4159: LD_INT 3
4161: MOD
4162: PUSH
4163: LD_INT 1
4165: PLUS
4166: ARRAY
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 3
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 65
4182: PPUSH
4183: LD_INT 75
4185: PPUSH
4186: CALL_OW 12
4190: PPUSH
4191: CALL 56966 0 5
// end else
4195: GO 4344
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4197: LD_INT 22
4199: PUSH
4200: LD_INT 23
4202: PUSH
4203: LD_INT 23
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: LIST
4210: PUSH
4211: LD_OWVAR 21
4215: PUSH
4216: LD_INT 3
4218: MOD
4219: PUSH
4220: LD_INT 1
4222: PLUS
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PUSH
4228: LD_INT 3
4230: PUSH
4231: LD_INT 1
4233: PUSH
4234: EMPTY
4235: LIST
4236: LIST
4237: LIST
4238: PUSH
4239: LD_OWVAR 21
4243: PUSH
4244: LD_INT 3
4246: MOD
4247: PUSH
4248: LD_INT 1
4250: PLUS
4251: ARRAY
4252: PPUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 45
4258: PUSH
4259: LD_INT 43
4261: PUSH
4262: LD_INT 44
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: LIST
4269: PUSH
4270: LD_INT 46
4272: PUSH
4273: LD_INT 45
4275: PUSH
4276: LD_INT 44
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 46
4286: PUSH
4287: LD_INT 43
4289: PUSH
4290: LD_INT 45
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: LIST
4302: PUSH
4303: LD_OWVAR 21
4307: PUSH
4308: LD_INT 3
4310: MOD
4311: PUSH
4312: LD_INT 1
4314: PLUS
4315: ARRAY
4316: PUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 3
4322: PPUSH
4323: CALL_OW 12
4327: ARRAY
4328: PPUSH
4329: LD_INT 65
4331: PPUSH
4332: LD_INT 75
4334: PPUSH
4335: CALL_OW 12
4339: PPUSH
4340: CALL 56966 0 5
// end ; veh := CreateVehicle ;
4344: LD_ADDR_VAR 0 3
4348: PUSH
4349: CALL_OW 45
4353: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4354: LD_VAR 0 3
4358: PPUSH
4359: LD_INT 3
4361: PPUSH
4362: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4366: LD_VAR 0 3
4370: PPUSH
4371: LD_INT 30
4373: PPUSH
4374: LD_INT 0
4376: PPUSH
4377: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4381: LD_VAR 0 2
4385: PPUSH
4386: LD_VAR 0 3
4390: PPUSH
4391: CALL_OW 52
// end ;
4395: GO 3838
4397: POP
4398: POP
// if artifactArCaptured then
4399: LD_EXP 9
4403: IFFALSE 4489
// begin uc_nation := nation_american ;
4405: LD_ADDR_OWVAR 21
4409: PUSH
4410: LD_INT 1
4412: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4413: LD_INT 3
4415: PPUSH
4416: LD_INT 3
4418: PPUSH
4419: LD_INT 3
4421: PPUSH
4422: LD_INT 12
4424: PPUSH
4425: LD_INT 100
4427: PPUSH
4428: CALL 56966 0 5
// veh := CreateVehicle ;
4432: LD_ADDR_VAR 0 3
4436: PUSH
4437: CALL_OW 45
4441: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4442: LD_VAR 0 3
4446: PPUSH
4447: LD_INT 3
4449: PPUSH
4450: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4454: LD_VAR 0 3
4458: PPUSH
4459: LD_INT 198
4461: PPUSH
4462: LD_INT 22
4464: PPUSH
4465: LD_INT 0
4467: PPUSH
4468: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 4
4479: PPUSH
4480: LD_INT 50
4482: PPUSH
4483: CALL_OW 290
// end else
4487: GO 4508
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4489: LD_INT 4
4491: PPUSH
4492: LD_INT 5
4494: PPUSH
4495: LD_INT 267
4497: PPUSH
4498: LD_INT 226
4500: PPUSH
4501: LD_INT 0
4503: PPUSH
4504: CALL_OW 58
// end ; uc_nation := nation_american ;
4508: LD_ADDR_OWVAR 21
4512: PUSH
4513: LD_INT 1
4515: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4516: LD_INT 3
4518: PPUSH
4519: LD_INT 3
4521: PPUSH
4522: LD_INT 3
4524: PPUSH
4525: LD_INT 12
4527: PPUSH
4528: LD_INT 100
4530: PPUSH
4531: CALL 56966 0 5
// veh := CreateVehicle ;
4535: LD_ADDR_VAR 0 3
4539: PUSH
4540: CALL_OW 45
4544: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4545: LD_VAR 0 3
4549: PPUSH
4550: LD_INT 3
4552: PPUSH
4553: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4557: LD_VAR 0 3
4561: PPUSH
4562: LD_INT 218
4564: PPUSH
4565: LD_INT 23
4567: PPUSH
4568: LD_INT 0
4570: PPUSH
4571: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 4
4582: PPUSH
4583: LD_INT 30
4585: PPUSH
4586: CALL_OW 290
// uc_nation := nation_russian ;
4590: LD_ADDR_OWVAR 21
4594: PUSH
4595: LD_INT 3
4597: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4598: LD_INT 22
4600: PPUSH
4601: LD_INT 3
4603: PPUSH
4604: LD_INT 3
4606: PPUSH
4607: LD_INT 51
4609: PPUSH
4610: LD_INT 100
4612: PPUSH
4613: CALL 56966 0 5
// veh := CreateVehicle ;
4617: LD_ADDR_VAR 0 3
4621: PUSH
4622: CALL_OW 45
4626: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4627: LD_VAR 0 3
4631: PPUSH
4632: LD_INT 3
4634: PPUSH
4635: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4639: LD_VAR 0 3
4643: PPUSH
4644: LD_INT 214
4646: PPUSH
4647: LD_INT 20
4649: PPUSH
4650: LD_INT 0
4652: PPUSH
4653: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4657: LD_VAR 0 3
4661: PPUSH
4662: LD_INT 4
4664: PPUSH
4665: LD_INT 40
4667: PPUSH
4668: CALL_OW 290
// end ;
4672: LD_VAR 0 1
4676: RET
// export function AllianceSupport ; var i , veh ; begin
4677: LD_INT 0
4679: PPUSH
4680: PPUSH
4681: PPUSH
// if not allianceTeam then
4682: LD_EXP 17
4686: NOT
4687: IFFALSE 4691
// exit ;
4689: GO 5097
// for i := 1 to 6 do
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: DOUBLE
4697: LD_INT 1
4699: DEC
4700: ST_TO_ADDR
4701: LD_INT 6
4703: PUSH
4704: FOR_TO
4705: IFFALSE 5001
// begin uc_side := 7 ;
4707: LD_ADDR_OWVAR 20
4711: PUSH
4712: LD_INT 7
4714: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4715: LD_ADDR_OWVAR 21
4719: PUSH
4720: LD_INT 1
4722: PUSH
4723: LD_INT 3
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_VAR 0 2
4734: PUSH
4735: LD_INT 2
4737: MOD
4738: PUSH
4739: LD_INT 1
4741: PLUS
4742: ARRAY
4743: ST_TO_ADDR
// if uc_nation = 1 then
4744: LD_OWVAR 21
4748: PUSH
4749: LD_INT 1
4751: EQUAL
4752: IFFALSE 4794
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4754: LD_INT 5
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 1
4762: PPUSH
4763: LD_INT 6
4765: PUSH
4766: LD_INT 7
4768: PUSH
4769: EMPTY
4770: LIST
4771: LIST
4772: PUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 2
4778: PPUSH
4779: CALL_OW 12
4783: ARRAY
4784: PPUSH
4785: LD_INT 100
4787: PPUSH
4788: CALL 56966 0 5
4792: GO 4832
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4794: LD_INT 23
4796: PPUSH
4797: LD_INT 3
4799: PPUSH
4800: LD_INT 1
4802: PPUSH
4803: LD_INT 46
4805: PUSH
4806: LD_INT 47
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: PUSH
4813: LD_INT 1
4815: PPUSH
4816: LD_INT 2
4818: PPUSH
4819: CALL_OW 12
4823: ARRAY
4824: PPUSH
4825: LD_INT 100
4827: PPUSH
4828: CALL 56966 0 5
// if not allianceTeam then
4832: LD_EXP 17
4836: NOT
4837: IFFALSE 4841
// break ;
4839: GO 5001
// veh := CreateVehicle ;
4841: LD_ADDR_VAR 0 3
4845: PUSH
4846: CALL_OW 45
4850: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4851: LD_VAR 0 3
4855: PPUSH
4856: LD_INT 4
4858: PPUSH
4859: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4863: LD_VAR 0 3
4867: PPUSH
4868: LD_INT 38
4870: PPUSH
4871: LD_INT 0
4873: PPUSH
4874: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4878: LD_EXP 17
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: LD_INT 3
4889: PPUSH
4890: CALL_OW 259
4894: PUSH
4895: LD_INT 4
4897: GREATER
4898: IFFALSE 4916
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4900: LD_EXP 17
4904: PUSH
4905: LD_INT 1
4907: ARRAY
4908: PPUSH
4909: LD_INT 3
4911: PPUSH
4912: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4916: LD_EXP 17
4920: PUSH
4921: LD_INT 1
4923: ARRAY
4924: PPUSH
4925: LD_INT 4
4927: PPUSH
4928: CALL_OW 259
4932: PUSH
4933: LD_INT 8
4935: GREATER
4936: IFFALSE 4954
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4938: LD_EXP 17
4942: PUSH
4943: LD_INT 1
4945: ARRAY
4946: PPUSH
4947: LD_INT 4
4949: PPUSH
4950: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4954: LD_EXP 17
4958: PUSH
4959: LD_INT 1
4961: ARRAY
4962: PPUSH
4963: LD_VAR 0 3
4967: PPUSH
4968: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4972: LD_ADDR_EXP 17
4976: PUSH
4977: LD_EXP 17
4981: PPUSH
4982: LD_INT 1
4984: PPUSH
4985: CALL_OW 3
4989: ST_TO_ADDR
// ComHold ( veh ) ;
4990: LD_VAR 0 3
4994: PPUSH
4995: CALL_OW 140
// end ;
4999: GO 4704
5001: POP
5002: POP
// uc_side := 7 ;
5003: LD_ADDR_OWVAR 20
5007: PUSH
5008: LD_INT 7
5010: ST_TO_ADDR
// uc_nation := 1 ;
5011: LD_ADDR_OWVAR 21
5015: PUSH
5016: LD_INT 1
5018: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5019: LD_INT 5
5021: PPUSH
5022: LD_INT 3
5024: PPUSH
5025: LD_INT 3
5027: PPUSH
5028: LD_INT 11
5030: PPUSH
5031: LD_INT 100
5033: PPUSH
5034: CALL 56966 0 5
// veh := CreateVehicle ;
5038: LD_ADDR_VAR 0 3
5042: PUSH
5043: CALL_OW 45
5047: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5048: LD_VAR 0 3
5052: PPUSH
5053: LD_INT 4
5055: PPUSH
5056: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5060: LD_VAR 0 3
5064: PPUSH
5065: LD_INT 305
5067: PPUSH
5068: LD_INT 218
5070: PPUSH
5071: LD_INT 0
5073: PPUSH
5074: CALL_OW 48
// ComHold ( veh ) ;
5078: LD_VAR 0 3
5082: PPUSH
5083: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5087: LD_INT 313
5089: PPUSH
5090: LD_INT 220
5092: PPUSH
5093: CALL_OW 86
// end ; end_of_file
5097: LD_VAR 0 1
5101: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5102: LD_INT 0
5104: PPUSH
5105: PPUSH
5106: PPUSH
5107: PPUSH
5108: PPUSH
5109: PPUSH
5110: PPUSH
5111: PPUSH
5112: PPUSH
5113: PPUSH
// InitHc ;
5114: CALL_OW 19
// uc_side := 1 ;
5118: LD_ADDR_OWVAR 20
5122: PUSH
5123: LD_INT 1
5125: ST_TO_ADDR
// uc_nation := 1 ;
5126: LD_ADDR_OWVAR 21
5130: PUSH
5131: LD_INT 1
5133: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5134: LD_ADDR_VAR 0 2
5138: PUSH
5139: LD_INT 22
5141: PUSH
5142: LD_INT 1
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PUSH
5149: LD_INT 21
5151: PUSH
5152: LD_INT 3
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: EMPTY
5160: LIST
5161: LIST
5162: PPUSH
5163: CALL_OW 69
5167: PUSH
5168: FOR_IN
5169: IFFALSE 5185
// SetBLevel ( i , 10 ) ;
5171: LD_VAR 0 2
5175: PPUSH
5176: LD_INT 10
5178: PPUSH
5179: CALL_OW 241
5183: GO 5168
5185: POP
5186: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5187: LD_INT 387
5189: PPUSH
5190: CALL_OW 274
5194: PPUSH
5195: LD_INT 1
5197: PPUSH
5198: LD_INT 7500
5200: PPUSH
5201: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5205: LD_INT 387
5207: PPUSH
5208: CALL_OW 274
5212: PPUSH
5213: LD_INT 2
5215: PPUSH
5216: LD_INT 4000
5218: PPUSH
5219: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5223: LD_INT 387
5225: PPUSH
5226: CALL_OW 274
5230: PPUSH
5231: LD_INT 3
5233: PPUSH
5234: LD_INT 50
5236: PPUSH
5237: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5241: LD_INT 476
5243: PPUSH
5244: CALL_OW 274
5248: PPUSH
5249: LD_INT 1
5251: PPUSH
5252: LD_INT 5500
5254: PPUSH
5255: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5259: LD_INT 476
5261: PPUSH
5262: CALL_OW 274
5266: PPUSH
5267: LD_INT 2
5269: PPUSH
5270: LD_INT 4000
5272: PPUSH
5273: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5277: LD_INT 476
5279: PPUSH
5280: CALL_OW 274
5284: PPUSH
5285: LD_INT 3
5287: PPUSH
5288: LD_INT 10
5290: PPUSH
5291: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5295: LD_ADDR_EXP 55
5299: PUSH
5300: LD_STRING Powell
5302: PPUSH
5303: CALL_OW 25
5307: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5308: LD_EXP 55
5312: PPUSH
5313: LD_INT 387
5315: PPUSH
5316: CALL_OW 52
// tmp := [ ] ;
5320: LD_ADDR_VAR 0 6
5324: PUSH
5325: EMPTY
5326: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5327: LD_ADDR_EXP 21
5331: PUSH
5332: LD_STRING Lisa
5334: PPUSH
5335: LD_EXP 1
5339: NOT
5340: PPUSH
5341: LD_STRING 12p_
5343: PPUSH
5344: CALL 51951 0 3
5348: ST_TO_ADDR
// if Lisa then
5349: LD_EXP 21
5353: IFFALSE 5371
// tmp := tmp ^ Lisa ;
5355: LD_ADDR_VAR 0 6
5359: PUSH
5360: LD_VAR 0 6
5364: PUSH
5365: LD_EXP 21
5369: ADD
5370: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5371: LD_ADDR_EXP 22
5375: PUSH
5376: LD_STRING Donaldson
5378: PPUSH
5379: LD_EXP 1
5383: NOT
5384: PPUSH
5385: LD_STRING 12p_
5387: PPUSH
5388: CALL 51951 0 3
5392: ST_TO_ADDR
// if Donaldson then
5393: LD_EXP 22
5397: IFFALSE 5415
// tmp := tmp ^ Donaldson ;
5399: LD_ADDR_VAR 0 6
5403: PUSH
5404: LD_VAR 0 6
5408: PUSH
5409: LD_EXP 22
5413: ADD
5414: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5415: LD_ADDR_EXP 23
5419: PUSH
5420: LD_STRING Bobby
5422: PPUSH
5423: LD_EXP 1
5427: NOT
5428: PPUSH
5429: LD_STRING 12p_
5431: PPUSH
5432: CALL 51951 0 3
5436: ST_TO_ADDR
// if Bobby then
5437: LD_EXP 23
5441: IFFALSE 5459
// tmp := tmp ^ Bobby ;
5443: LD_ADDR_VAR 0 6
5447: PUSH
5448: LD_VAR 0 6
5452: PUSH
5453: LD_EXP 23
5457: ADD
5458: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5459: LD_ADDR_EXP 24
5463: PUSH
5464: LD_STRING Cyrus
5466: PPUSH
5467: LD_EXP 1
5471: NOT
5472: PPUSH
5473: LD_STRING 12p_
5475: PPUSH
5476: CALL 51951 0 3
5480: ST_TO_ADDR
// if Cyrus then
5481: LD_EXP 24
5485: IFFALSE 5503
// tmp := tmp ^ Cyrus ;
5487: LD_ADDR_VAR 0 6
5491: PUSH
5492: LD_VAR 0 6
5496: PUSH
5497: LD_EXP 24
5501: ADD
5502: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5503: LD_ADDR_EXP 26
5507: PUSH
5508: LD_STRING Brown
5510: PPUSH
5511: LD_EXP 1
5515: NOT
5516: PPUSH
5517: LD_STRING 12p_
5519: PPUSH
5520: CALL 51951 0 3
5524: ST_TO_ADDR
// if Brown then
5525: LD_EXP 26
5529: IFFALSE 5547
// tmp := tmp ^ Brown ;
5531: LD_ADDR_VAR 0 6
5535: PUSH
5536: LD_VAR 0 6
5540: PUSH
5541: LD_EXP 26
5545: ADD
5546: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5547: LD_ADDR_EXP 27
5551: PUSH
5552: LD_STRING Gladstone
5554: PPUSH
5555: LD_EXP 1
5559: NOT
5560: PPUSH
5561: LD_STRING 12p_
5563: PPUSH
5564: CALL 51951 0 3
5568: ST_TO_ADDR
// if Gladstone then
5569: LD_EXP 27
5573: IFFALSE 5591
// tmp := tmp ^ Gladstone ;
5575: LD_ADDR_VAR 0 6
5579: PUSH
5580: LD_VAR 0 6
5584: PUSH
5585: LD_EXP 27
5589: ADD
5590: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5591: LD_ADDR_EXP 28
5595: PUSH
5596: LD_STRING Houten
5598: PPUSH
5599: LD_EXP 1
5603: NOT
5604: PPUSH
5605: LD_STRING 12p_
5607: PPUSH
5608: CALL 51951 0 3
5612: ST_TO_ADDR
// if Houten then
5613: LD_EXP 28
5617: IFFALSE 5635
// tmp := tmp ^ Houten ;
5619: LD_ADDR_VAR 0 6
5623: PUSH
5624: LD_VAR 0 6
5628: PUSH
5629: LD_EXP 28
5633: ADD
5634: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5635: LD_ADDR_EXP 29
5639: PUSH
5640: LD_STRING Cornel
5642: PPUSH
5643: LD_EXP 1
5647: NOT
5648: PPUSH
5649: LD_STRING 12p_
5651: PPUSH
5652: CALL 51951 0 3
5656: ST_TO_ADDR
// if Cornel then
5657: LD_EXP 29
5661: IFFALSE 5679
// tmp := tmp ^ Cornel ;
5663: LD_ADDR_VAR 0 6
5667: PUSH
5668: LD_VAR 0 6
5672: PUSH
5673: LD_EXP 29
5677: ADD
5678: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5679: LD_ADDR_EXP 30
5683: PUSH
5684: LD_STRING Gary
5686: PPUSH
5687: LD_EXP 1
5691: NOT
5692: PPUSH
5693: LD_STRING 12p_
5695: PPUSH
5696: CALL 51951 0 3
5700: ST_TO_ADDR
// if Gary then
5701: LD_EXP 30
5705: IFFALSE 5723
// tmp := tmp ^ Gary ;
5707: LD_ADDR_VAR 0 6
5711: PUSH
5712: LD_VAR 0 6
5716: PUSH
5717: LD_EXP 30
5721: ADD
5722: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5723: LD_ADDR_EXP 32
5727: PUSH
5728: LD_STRING Kikuchi
5730: PPUSH
5731: LD_EXP 1
5735: NOT
5736: PPUSH
5737: LD_STRING 12p_
5739: PPUSH
5740: CALL 51951 0 3
5744: ST_TO_ADDR
// if Kikuchi then
5745: LD_EXP 32
5749: IFFALSE 5767
// tmp := tmp ^ Kikuchi ;
5751: LD_ADDR_VAR 0 6
5755: PUSH
5756: LD_VAR 0 6
5760: PUSH
5761: LD_EXP 32
5765: ADD
5766: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5767: LD_ADDR_VAR 0 6
5771: PUSH
5772: LD_VAR 0 6
5776: PUSH
5777: LD_STRING 12p_others
5779: PPUSH
5780: CALL_OW 31
5784: UNION
5785: ST_TO_ADDR
// if tmp < 36 then
5786: LD_VAR 0 6
5790: PUSH
5791: LD_INT 36
5793: LESS
5794: IFFALSE 5861
// for i = 1 to 36 - tmp do
5796: LD_ADDR_VAR 0 2
5800: PUSH
5801: DOUBLE
5802: LD_INT 1
5804: DEC
5805: ST_TO_ADDR
5806: LD_INT 36
5808: PUSH
5809: LD_VAR 0 6
5813: MINUS
5814: PUSH
5815: FOR_TO
5816: IFFALSE 5859
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5818: LD_INT 1
5820: PPUSH
5821: LD_VAR 0 2
5825: PUSH
5826: LD_INT 4
5828: MOD
5829: PUSH
5830: LD_INT 1
5832: PLUS
5833: PPUSH
5834: LD_INT 10
5836: PPUSH
5837: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5841: LD_ADDR_VAR 0 6
5845: PUSH
5846: LD_VAR 0 6
5850: PUSH
5851: CALL_OW 44
5855: ADD
5856: ST_TO_ADDR
// end ;
5857: GO 5815
5859: POP
5860: POP
// for i in tmp do
5861: LD_ADDR_VAR 0 2
5865: PUSH
5866: LD_VAR 0 6
5870: PUSH
5871: FOR_IN
5872: IFFALSE 5897
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5874: LD_VAR 0 2
5878: PPUSH
5879: LD_INT 62
5881: PPUSH
5882: LD_INT 93
5884: PPUSH
5885: LD_INT 9
5887: PPUSH
5888: LD_INT 0
5890: PPUSH
5891: CALL_OW 50
5895: GO 5871
5897: POP
5898: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5899: LD_ADDR_EXP 77
5903: PUSH
5904: LD_EXP 77
5908: PPUSH
5909: LD_INT 4
5911: PPUSH
5912: LD_INT 22
5914: PUSH
5915: LD_INT 1
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: PPUSH
5922: CALL_OW 69
5926: PUSH
5927: LD_EXP 55
5931: DIFF
5932: PPUSH
5933: CALL_OW 1
5937: ST_TO_ADDR
// uc_side := 0 ;
5938: LD_ADDR_OWVAR 20
5942: PUSH
5943: LD_INT 0
5945: ST_TO_ADDR
// uc_nation := 0 ;
5946: LD_ADDR_OWVAR 21
5950: PUSH
5951: LD_INT 0
5953: ST_TO_ADDR
// for i = 1 to 4 do
5954: LD_ADDR_VAR 0 2
5958: PUSH
5959: DOUBLE
5960: LD_INT 1
5962: DEC
5963: ST_TO_ADDR
5964: LD_INT 4
5966: PUSH
5967: FOR_TO
5968: IFFALSE 5999
// begin InitHc ;
5970: CALL_OW 19
// hc_class := class_apeman ;
5974: LD_ADDR_OWVAR 28
5978: PUSH
5979: LD_INT 12
5981: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5982: CALL_OW 44
5986: PPUSH
5987: LD_INT 11
5989: PPUSH
5990: LD_INT 0
5992: PPUSH
5993: CALL_OW 49
// end ;
5997: GO 5967
5999: POP
6000: POP
// end ;
6001: LD_VAR 0 1
6005: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
6006: LD_EXP 4
6010: NOT
6011: PUSH
6012: LD_INT 4
6014: PPUSH
6015: LD_INT 1
6017: PPUSH
6018: CALL 46981 0 2
6022: NOT
6023: AND
6024: IFFALSE 6796
6026: GO 6028
6028: DISABLE
6029: LD_INT 0
6031: PPUSH
6032: PPUSH
6033: PPUSH
// begin enable ;
6034: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6035: LD_INT 22
6037: PUSH
6038: LD_INT 1
6040: PUSH
6041: EMPTY
6042: LIST
6043: LIST
6044: PUSH
6045: LD_INT 23
6047: PUSH
6048: LD_INT 1
6050: PUSH
6051: EMPTY
6052: LIST
6053: LIST
6054: PUSH
6055: LD_INT 30
6057: PUSH
6058: LD_INT 3
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: LIST
6069: PPUSH
6070: CALL_OW 69
6074: NOT
6075: IFFALSE 6079
// exit ;
6077: GO 6796
// if Prob ( 40 ) then
6079: LD_INT 40
6081: PPUSH
6082: CALL_OW 13
6086: IFFALSE 6213
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6088: LD_INT 4
6090: PPUSH
6091: LD_INT 5
6093: PUSH
6094: LD_INT 1
6096: PUSH
6097: LD_INT 2
6099: PUSH
6100: LD_INT 7
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: LIST
6107: LIST
6108: PUSH
6109: LD_INT 5
6111: PUSH
6112: LD_INT 1
6114: PUSH
6115: LD_INT 2
6117: PUSH
6118: LD_INT 7
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: LIST
6125: LIST
6126: PUSH
6127: LD_INT 5
6129: PUSH
6130: LD_INT 1
6132: PUSH
6133: LD_INT 2
6135: PUSH
6136: LD_INT 7
6138: PUSH
6139: EMPTY
6140: LIST
6141: LIST
6142: LIST
6143: LIST
6144: PUSH
6145: LD_INT 5
6147: PUSH
6148: LD_INT 1
6150: PUSH
6151: LD_INT 2
6153: PUSH
6154: LD_INT 6
6156: PUSH
6157: EMPTY
6158: LIST
6159: LIST
6160: LIST
6161: LIST
6162: PUSH
6163: LD_INT 5
6165: PUSH
6166: LD_INT 1
6168: PUSH
6169: LD_INT 2
6171: PUSH
6172: LD_INT 6
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: PUSH
6181: LD_INT 5
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 6
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: LIST
6198: PUSH
6199: EMPTY
6200: LIST
6201: LIST
6202: LIST
6203: LIST
6204: LIST
6205: LIST
6206: PPUSH
6207: CALL 45563 0 2
// end else
6211: GO 6336
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6213: LD_INT 4
6215: PPUSH
6216: LD_INT 5
6218: PUSH
6219: LD_INT 1
6221: PUSH
6222: LD_INT 2
6224: PUSH
6225: LD_INT 7
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: LD_INT 5
6236: PUSH
6237: LD_INT 1
6239: PUSH
6240: LD_INT 2
6242: PUSH
6243: LD_INT 9
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: LIST
6250: LIST
6251: PUSH
6252: LD_INT 5
6254: PUSH
6255: LD_INT 1
6257: PUSH
6258: LD_INT 2
6260: PUSH
6261: LD_INT 9
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: PUSH
6270: LD_INT 5
6272: PUSH
6273: LD_INT 1
6275: PUSH
6276: LD_INT 2
6278: PUSH
6279: LD_INT 6
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: PUSH
6288: LD_INT 5
6290: PUSH
6291: LD_INT 1
6293: PUSH
6294: LD_INT 2
6296: PUSH
6297: LD_INT 6
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: LIST
6304: LIST
6305: PUSH
6306: LD_INT 5
6308: PUSH
6309: LD_INT 1
6311: PUSH
6312: LD_INT 2
6314: PUSH
6315: LD_INT 6
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: LIST
6323: PUSH
6324: EMPTY
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: LIST
6331: PPUSH
6332: CALL 45563 0 2
// end ; repeat wait ( 0 0$1 ) ;
6336: LD_INT 35
6338: PPUSH
6339: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
6343: LD_INT 4
6345: PPUSH
6346: LD_INT 1
6348: PPUSH
6349: CALL 46981 0 2
6353: PUSH
6354: LD_INT 6
6356: GREATEREQUAL
6357: IFFALSE 6336
// wait ( 0 0$30 ) ;
6359: LD_INT 1050
6361: PPUSH
6362: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6366: LD_ADDR_VAR 0 2
6370: PUSH
6371: LD_INT 4
6373: PPUSH
6374: LD_INT 1
6376: PPUSH
6377: CALL 46981 0 2
6381: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6382: LD_ADDR_EXP 96
6386: PUSH
6387: LD_EXP 96
6391: PPUSH
6392: LD_INT 4
6394: PPUSH
6395: LD_EXP 96
6399: PUSH
6400: LD_INT 4
6402: ARRAY
6403: PUSH
6404: LD_VAR 0 2
6408: DIFF
6409: PPUSH
6410: CALL_OW 1
6414: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: LD_INT 0
6422: PPUSH
6423: LD_INT 2
6425: PPUSH
6426: CALL_OW 12
6430: ST_TO_ADDR
// if target then
6431: LD_VAR 0 3
6435: IFFALSE 6563
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6437: LD_ADDR_VAR 0 2
6441: PUSH
6442: LD_VAR 0 2
6446: PPUSH
6447: LD_INT 24
6449: PUSH
6450: LD_INT 250
6452: PUSH
6453: EMPTY
6454: LIST
6455: LIST
6456: PPUSH
6457: CALL_OW 72
6461: ST_TO_ADDR
// for i in tmp do
6462: LD_ADDR_VAR 0 1
6466: PUSH
6467: LD_VAR 0 2
6471: PUSH
6472: FOR_IN
6473: IFFALSE 6513
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6475: LD_VAR 0 1
6479: PPUSH
6480: LD_INT 114
6482: PPUSH
6483: LD_INT 108
6485: PPUSH
6486: CALL_OW 297
6490: PUSH
6491: LD_INT 9
6493: GREATER
6494: IFFALSE 6511
// ComMoveXY ( i , 114 , 108 ) ;
6496: LD_VAR 0 1
6500: PPUSH
6501: LD_INT 114
6503: PPUSH
6504: LD_INT 108
6506: PPUSH
6507: CALL_OW 111
6511: GO 6472
6513: POP
6514: POP
// wait ( 0 0$1 ) ;
6515: LD_INT 35
6517: PPUSH
6518: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6522: LD_VAR 0 2
6526: PPUSH
6527: LD_INT 92
6529: PUSH
6530: LD_INT 114
6532: PUSH
6533: LD_INT 108
6535: PUSH
6536: LD_INT 9
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: LIST
6543: LIST
6544: PPUSH
6545: CALL_OW 72
6549: PUSH
6550: LD_VAR 0 2
6554: PUSH
6555: LD_INT 1
6557: MINUS
6558: GREATEREQUAL
6559: IFFALSE 6437
// end else
6561: GO 6687
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6563: LD_ADDR_VAR 0 2
6567: PUSH
6568: LD_VAR 0 2
6572: PPUSH
6573: LD_INT 24
6575: PUSH
6576: LD_INT 250
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: PPUSH
6583: CALL_OW 72
6587: ST_TO_ADDR
// for i in tmp do
6588: LD_ADDR_VAR 0 1
6592: PUSH
6593: LD_VAR 0 2
6597: PUSH
6598: FOR_IN
6599: IFFALSE 6639
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6601: LD_VAR 0 1
6605: PPUSH
6606: LD_INT 129
6608: PPUSH
6609: LD_INT 139
6611: PPUSH
6612: CALL_OW 297
6616: PUSH
6617: LD_INT 9
6619: GREATER
6620: IFFALSE 6637
// ComMoveXY ( i , 129 , 139 ) ;
6622: LD_VAR 0 1
6626: PPUSH
6627: LD_INT 129
6629: PPUSH
6630: LD_INT 139
6632: PPUSH
6633: CALL_OW 111
6637: GO 6598
6639: POP
6640: POP
// wait ( 0 0$1 ) ;
6641: LD_INT 35
6643: PPUSH
6644: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6648: LD_VAR 0 2
6652: PPUSH
6653: LD_INT 92
6655: PUSH
6656: LD_INT 129
6658: PUSH
6659: LD_INT 139
6661: PUSH
6662: LD_INT 9
6664: PUSH
6665: EMPTY
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: PPUSH
6671: CALL_OW 72
6675: PUSH
6676: LD_VAR 0 2
6680: PUSH
6681: LD_INT 1
6683: MINUS
6684: GREATEREQUAL
6685: IFFALSE 6563
// end ; repeat wait ( 0 0$1 ) ;
6687: LD_INT 35
6689: PPUSH
6690: CALL_OW 67
// for i in tmp do
6694: LD_ADDR_VAR 0 1
6698: PUSH
6699: LD_VAR 0 2
6703: PUSH
6704: FOR_IN
6705: IFFALSE 6787
// begin if GetLives ( i ) > 251 then
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 256
6716: PUSH
6717: LD_INT 251
6719: GREATER
6720: IFFALSE 6758
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6722: LD_VAR 0 1
6726: PPUSH
6727: LD_INT 81
6729: PUSH
6730: LD_INT 1
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PPUSH
6737: CALL_OW 69
6741: PPUSH
6742: LD_VAR 0 1
6746: PPUSH
6747: CALL_OW 74
6751: PPUSH
6752: CALL_OW 115
6756: GO 6785
// if IsDead ( i ) then
6758: LD_VAR 0 1
6762: PPUSH
6763: CALL_OW 301
6767: IFFALSE 6785
// tmp := tmp diff i ;
6769: LD_ADDR_VAR 0 2
6773: PUSH
6774: LD_VAR 0 2
6778: PUSH
6779: LD_VAR 0 1
6783: DIFF
6784: ST_TO_ADDR
// end ;
6785: GO 6704
6787: POP
6788: POP
// until not tmp ;
6789: LD_VAR 0 2
6793: NOT
6794: IFFALSE 6687
// end ;
6796: PPOPN 3
6798: END
// every 30 30$00 trigger not americanDestroyed do
6799: LD_EXP 4
6803: NOT
6804: IFFALSE 6873
6806: GO 6808
6808: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6809: LD_INT 63000
6811: PUSH
6812: LD_INT 42000
6814: PUSH
6815: LD_INT 31500
6817: PUSH
6818: LD_INT 21000
6820: PUSH
6821: EMPTY
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PUSH
6827: LD_OWVAR 67
6831: ARRAY
6832: PPUSH
6833: CALL_OW 67
// if americanDestroyed then
6837: LD_EXP 4
6841: IFFALSE 6845
// exit ;
6843: GO 6873
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6845: LD_INT 4
6847: PPUSH
6848: LD_INT 5
6850: PUSH
6851: LD_INT 3
6853: PUSH
6854: LD_INT 1
6856: PUSH
6857: LD_INT 8
6859: PUSH
6860: EMPTY
6861: LIST
6862: LIST
6863: LIST
6864: LIST
6865: PUSH
6866: EMPTY
6867: LIST
6868: PPUSH
6869: CALL 45563 0 2
// end ; end_of_file
6873: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6874: LD_INT 0
6876: PPUSH
6877: PPUSH
6878: PPUSH
6879: PPUSH
6880: PPUSH
// side := 2 ;
6881: LD_ADDR_VAR 0 5
6885: PUSH
6886: LD_INT 2
6888: ST_TO_ADDR
// InitHc ;
6889: CALL_OW 19
// uc_side := side ;
6893: LD_ADDR_OWVAR 20
6897: PUSH
6898: LD_VAR 0 5
6902: ST_TO_ADDR
// uc_nation := 2 ;
6903: LD_ADDR_OWVAR 21
6907: PUSH
6908: LD_INT 2
6910: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6911: LD_ADDR_VAR 0 2
6915: PUSH
6916: LD_INT 22
6918: PUSH
6919: LD_INT 2
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: PUSH
6926: LD_INT 21
6928: PUSH
6929: LD_INT 3
6931: PUSH
6932: EMPTY
6933: LIST
6934: LIST
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: PPUSH
6940: CALL_OW 69
6944: PUSH
6945: FOR_IN
6946: IFFALSE 6962
// SetBLevel ( i , 10 ) ;
6948: LD_VAR 0 2
6952: PPUSH
6953: LD_INT 10
6955: PPUSH
6956: CALL_OW 241
6960: GO 6945
6962: POP
6963: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6964: LD_ADDR_VAR 0 4
6968: PUSH
6969: LD_INT 22
6971: PUSH
6972: LD_VAR 0 5
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PUSH
6981: LD_INT 30
6983: PUSH
6984: LD_INT 32
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PUSH
6991: LD_INT 58
6993: PUSH
6994: EMPTY
6995: LIST
6996: PUSH
6997: EMPTY
6998: LIST
6999: LIST
7000: LIST
7001: PPUSH
7002: CALL_OW 69
7006: ST_TO_ADDR
// for i = 1 to 10 do
7007: LD_ADDR_VAR 0 2
7011: PUSH
7012: DOUBLE
7013: LD_INT 1
7015: DEC
7016: ST_TO_ADDR
7017: LD_INT 10
7019: PUSH
7020: FOR_TO
7021: IFFALSE 7093
// begin uc_nation := nation_nature ;
7023: LD_ADDR_OWVAR 21
7027: PUSH
7028: LD_INT 0
7030: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7031: LD_ADDR_OWVAR 28
7035: PUSH
7036: LD_INT 15
7038: ST_TO_ADDR
// hc_gallery :=  ;
7039: LD_ADDR_OWVAR 33
7043: PUSH
7044: LD_STRING 
7046: ST_TO_ADDR
// hc_name :=  ;
7047: LD_ADDR_OWVAR 26
7051: PUSH
7052: LD_STRING 
7054: ST_TO_ADDR
// un := CreateHuman ;
7055: LD_ADDR_VAR 0 3
7059: PUSH
7060: CALL_OW 44
7064: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7065: LD_VAR 0 3
7069: PPUSH
7070: LD_VAR 0 4
7074: PUSH
7075: LD_VAR 0 4
7079: PUSH
7080: LD_VAR 0 2
7084: MINUS
7085: ARRAY
7086: PPUSH
7087: CALL_OW 52
// end ;
7091: GO 7020
7093: POP
7094: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7095: LD_INT 503
7097: PPUSH
7098: LD_INT 27
7100: PPUSH
7101: LD_STRING 
7103: PPUSH
7104: LD_INT 8
7106: PUSH
7107: LD_INT 9
7109: PUSH
7110: LD_INT 10
7112: PUSH
7113: LD_INT 10
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: PUSH
7122: LD_OWVAR 67
7126: ARRAY
7127: PPUSH
7128: LD_INT 3000
7130: PUSH
7131: LD_INT 500
7133: PUSH
7134: LD_INT 150
7136: PUSH
7137: EMPTY
7138: LIST
7139: LIST
7140: LIST
7141: PPUSH
7142: LD_INT 16
7144: PUSH
7145: LD_INT 6
7147: PUSH
7148: LD_INT 6
7150: PUSH
7151: LD_INT 6
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: LIST
7158: LIST
7159: PPUSH
7160: CALL 60410 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7164: LD_ADDR_EXP 77
7168: PUSH
7169: LD_EXP 77
7173: PPUSH
7174: LD_INT 1
7176: PPUSH
7177: LD_INT 22
7179: PUSH
7180: LD_VAR 0 5
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: PUSH
7189: LD_INT 23
7191: PUSH
7192: LD_INT 2
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: PUSH
7199: LD_INT 3
7201: PUSH
7202: LD_INT 21
7204: PUSH
7205: LD_INT 2
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: PUSH
7216: EMPTY
7217: LIST
7218: LIST
7219: LIST
7220: PPUSH
7221: CALL_OW 69
7225: PPUSH
7226: CALL_OW 1
7230: ST_TO_ADDR
// end ;
7231: LD_VAR 0 1
7235: RET
// export Omar ; export function PrepareOmarAli ; begin
7236: LD_INT 0
7238: PPUSH
// uc_side := 5 ;
7239: LD_ADDR_OWVAR 20
7243: PUSH
7244: LD_INT 5
7246: ST_TO_ADDR
// uc_nation := 2 ;
7247: LD_ADDR_OWVAR 21
7251: PUSH
7252: LD_INT 2
7254: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7255: LD_ADDR_EXP 56
7259: PUSH
7260: LD_STRING Omar
7262: PPUSH
7263: CALL_OW 25
7267: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7268: LD_EXP 56
7272: PPUSH
7273: LD_INT 330
7275: PPUSH
7276: LD_INT 244
7278: PPUSH
7279: LD_INT 0
7281: PPUSH
7282: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7286: LD_EXP 56
7290: PPUSH
7291: LD_INT 252
7293: PPUSH
7294: LD_INT 220
7296: PPUSH
7297: CALL_OW 111
// end ; end_of_file
7301: LD_VAR 0 1
7305: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
7306: LD_INT 0
7308: PPUSH
7309: PPUSH
7310: PPUSH
7311: PPUSH
7312: PPUSH
// side := 8 ;
7313: LD_ADDR_VAR 0 3
7317: PUSH
7318: LD_INT 8
7320: ST_TO_ADDR
// InitHc ;
7321: CALL_OW 19
// uc_side := side ;
7325: LD_ADDR_OWVAR 20
7329: PUSH
7330: LD_VAR 0 3
7334: ST_TO_ADDR
// uc_nation := 2 ;
7335: LD_ADDR_OWVAR 21
7339: PUSH
7340: LD_INT 2
7342: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7343: LD_ADDR_VAR 0 2
7347: PUSH
7348: LD_INT 22
7350: PUSH
7351: LD_VAR 0 3
7355: PUSH
7356: EMPTY
7357: LIST
7358: LIST
7359: PUSH
7360: LD_INT 21
7362: PUSH
7363: LD_INT 3
7365: PUSH
7366: EMPTY
7367: LIST
7368: LIST
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: PPUSH
7374: CALL_OW 69
7378: PUSH
7379: FOR_IN
7380: IFFALSE 7396
// SetBLevel ( i , 10 ) ;
7382: LD_VAR 0 2
7386: PPUSH
7387: LD_INT 10
7389: PPUSH
7390: CALL_OW 241
7394: GO 7379
7396: POP
7397: POP
// Schulz := NewCharacter ( Schulz ) ;
7398: LD_ADDR_EXP 57
7402: PUSH
7403: LD_STRING Schulz
7405: PPUSH
7406: CALL_OW 25
7410: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7411: LD_ADDR_EXP 58
7415: PUSH
7416: LD_STRING Kozlov
7418: PPUSH
7419: LD_INT 0
7421: PPUSH
7422: LD_STRING 
7424: PPUSH
7425: CALL 51951 0 3
7429: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7430: LD_EXP 58
7434: PPUSH
7435: LD_INT 22
7437: PUSH
7438: LD_INT 8
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: PUSH
7445: LD_INT 23
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: EMPTY
7452: LIST
7453: LIST
7454: PUSH
7455: LD_INT 30
7457: PUSH
7458: LD_INT 8
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: PPUSH
7470: CALL_OW 69
7474: PUSH
7475: LD_INT 1
7477: ARRAY
7478: PPUSH
7479: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7483: LD_EXP 58
7487: PPUSH
7488: LD_INT 3
7490: PPUSH
7491: LD_INT 10
7493: PPUSH
7494: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7498: LD_ADDR_VAR 0 5
7502: PUSH
7503: LD_INT 22
7505: PUSH
7506: LD_VAR 0 3
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: PUSH
7515: LD_INT 30
7517: PUSH
7518: LD_INT 32
7520: PUSH
7521: EMPTY
7522: LIST
7523: LIST
7524: PUSH
7525: LD_INT 58
7527: PUSH
7528: EMPTY
7529: LIST
7530: PUSH
7531: EMPTY
7532: LIST
7533: LIST
7534: LIST
7535: PPUSH
7536: CALL_OW 69
7540: ST_TO_ADDR
// for i = 1 to 10 do
7541: LD_ADDR_VAR 0 2
7545: PUSH
7546: DOUBLE
7547: LD_INT 1
7549: DEC
7550: ST_TO_ADDR
7551: LD_INT 10
7553: PUSH
7554: FOR_TO
7555: IFFALSE 7627
// begin uc_nation := nation_nature ;
7557: LD_ADDR_OWVAR 21
7561: PUSH
7562: LD_INT 0
7564: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7565: LD_ADDR_OWVAR 28
7569: PUSH
7570: LD_INT 15
7572: ST_TO_ADDR
// hc_gallery :=  ;
7573: LD_ADDR_OWVAR 33
7577: PUSH
7578: LD_STRING 
7580: ST_TO_ADDR
// hc_name :=  ;
7581: LD_ADDR_OWVAR 26
7585: PUSH
7586: LD_STRING 
7588: ST_TO_ADDR
// un := CreateHuman ;
7589: LD_ADDR_VAR 0 4
7593: PUSH
7594: CALL_OW 44
7598: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7599: LD_VAR 0 4
7603: PPUSH
7604: LD_VAR 0 5
7608: PUSH
7609: LD_VAR 0 5
7613: PUSH
7614: LD_VAR 0 2
7618: MINUS
7619: ARRAY
7620: PPUSH
7621: CALL_OW 52
// end ;
7625: GO 7554
7627: POP
7628: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7629: LD_INT 324
7631: PPUSH
7632: LD_INT 3
7634: PPUSH
7635: LD_STRING 
7637: PPUSH
7638: LD_INT 8
7640: PUSH
7641: LD_INT 9
7643: PUSH
7644: LD_INT 10
7646: PUSH
7647: LD_INT 10
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: LIST
7654: LIST
7655: PUSH
7656: LD_OWVAR 67
7660: ARRAY
7661: PPUSH
7662: LD_INT 3000
7664: PUSH
7665: LD_INT 500
7667: PUSH
7668: LD_INT 150
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: LIST
7675: PPUSH
7676: LD_INT 16
7678: PUSH
7679: LD_INT 6
7681: PUSH
7682: LD_INT 6
7684: PUSH
7685: LD_INT 8
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: PPUSH
7694: CALL 60410 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7698: LD_ADDR_EXP 77
7702: PUSH
7703: LD_EXP 77
7707: PPUSH
7708: LD_INT 3
7710: PPUSH
7711: LD_INT 22
7713: PUSH
7714: LD_VAR 0 3
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: LD_INT 23
7725: PUSH
7726: LD_INT 2
7728: PUSH
7729: EMPTY
7730: LIST
7731: LIST
7732: PUSH
7733: LD_INT 3
7735: PUSH
7736: LD_INT 21
7738: PUSH
7739: LD_INT 2
7741: PUSH
7742: EMPTY
7743: LIST
7744: LIST
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: LIST
7754: PPUSH
7755: CALL_OW 69
7759: PUSH
7760: LD_EXP 57
7764: DIFF
7765: PPUSH
7766: CALL_OW 1
7770: ST_TO_ADDR
// end ;
7771: LD_VAR 0 1
7775: RET
// export function BuildKozlovBomb ; begin
7776: LD_INT 0
7778: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7779: LD_INT 332
7781: PPUSH
7782: CALL_OW 302
7786: NOT
7787: PUSH
7788: LD_INT 336
7790: PPUSH
7791: CALL_OW 302
7795: NOT
7796: OR
7797: IFFALSE 7801
// exit ;
7799: GO 7898
// ComChangeProfession ( Kozlov , 4 ) ;
7801: LD_EXP 58
7805: PPUSH
7806: LD_INT 4
7808: PPUSH
7809: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7813: LD_INT 336
7815: PPUSH
7816: LD_INT 25
7818: PPUSH
7819: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7823: LD_INT 35
7825: PPUSH
7826: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7830: LD_INT 25
7832: PPUSH
7833: LD_INT 8
7835: PPUSH
7836: CALL_OW 321
7840: PUSH
7841: LD_INT 2
7843: EQUAL
7844: IFFALSE 7823
// ComExitBuilding ( Kozlov ) ;
7846: LD_EXP 58
7850: PPUSH
7851: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7855: LD_EXP 58
7859: PPUSH
7860: LD_INT 332
7862: PPUSH
7863: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7867: LD_EXP 58
7871: PPUSH
7872: LD_INT 3
7874: PPUSH
7875: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7879: LD_INT 332
7881: PPUSH
7882: LD_INT 23
7884: PPUSH
7885: LD_INT 3
7887: PPUSH
7888: LD_INT 1
7890: PPUSH
7891: LD_INT 48
7893: PPUSH
7894: CALL_OW 125
// end ;
7898: LD_VAR 0 1
7902: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7903: LD_EXP 3
7907: NOT
7908: PUSH
7909: LD_INT 3
7911: PPUSH
7912: LD_INT 1
7914: PPUSH
7915: CALL 46981 0 2
7919: NOT
7920: AND
7921: IFFALSE 8777
7923: GO 7925
7925: DISABLE
7926: LD_INT 0
7928: PPUSH
7929: PPUSH
7930: PPUSH
// begin enable ;
7931: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7932: LD_INT 22
7934: PUSH
7935: LD_INT 8
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PUSH
7942: LD_INT 23
7944: PUSH
7945: LD_INT 2
7947: PUSH
7948: EMPTY
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 30
7954: PUSH
7955: LD_INT 3
7957: PUSH
7958: EMPTY
7959: LIST
7960: LIST
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: LIST
7966: PPUSH
7967: CALL_OW 69
7971: NOT
7972: IFFALSE 7976
// exit ;
7974: GO 8777
// if Prob ( 40 ) then
7976: LD_INT 40
7978: PPUSH
7979: CALL_OW 13
7983: IFFALSE 8110
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7985: LD_INT 3
7987: PPUSH
7988: LD_INT 14
7990: PUSH
7991: LD_INT 1
7993: PUSH
7994: LD_INT 2
7996: PUSH
7997: LD_INT 28
7999: PUSH
8000: EMPTY
8001: LIST
8002: LIST
8003: LIST
8004: LIST
8005: PUSH
8006: LD_INT 14
8008: PUSH
8009: LD_INT 1
8011: PUSH
8012: LD_INT 2
8014: PUSH
8015: LD_INT 28
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: LIST
8022: LIST
8023: PUSH
8024: LD_INT 14
8026: PUSH
8027: LD_INT 1
8029: PUSH
8030: LD_INT 2
8032: PUSH
8033: LD_INT 28
8035: PUSH
8036: EMPTY
8037: LIST
8038: LIST
8039: LIST
8040: LIST
8041: PUSH
8042: LD_INT 14
8044: PUSH
8045: LD_INT 1
8047: PUSH
8048: LD_INT 2
8050: PUSH
8051: LD_INT 28
8053: PUSH
8054: EMPTY
8055: LIST
8056: LIST
8057: LIST
8058: LIST
8059: PUSH
8060: LD_INT 14
8062: PUSH
8063: LD_INT 1
8065: PUSH
8066: LD_INT 2
8068: PUSH
8069: LD_INT 28
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: LIST
8076: LIST
8077: PUSH
8078: LD_INT 14
8080: PUSH
8081: LD_INT 1
8083: PUSH
8084: LD_INT 2
8086: PUSH
8087: LD_INT 26
8089: PUSH
8090: EMPTY
8091: LIST
8092: LIST
8093: LIST
8094: LIST
8095: PUSH
8096: EMPTY
8097: LIST
8098: LIST
8099: LIST
8100: LIST
8101: LIST
8102: LIST
8103: PPUSH
8104: CALL 45563 0 2
// end else
8108: GO 8317
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8110: LD_INT 3
8112: PPUSH
8113: LD_INT 14
8115: PUSH
8116: LD_INT 1
8118: PUSH
8119: LD_INT 2
8121: PUSH
8122: LD_INT 27
8124: PUSH
8125: LD_INT 26
8127: PUSH
8128: LD_INT 26
8130: PUSH
8131: LD_INT 28
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: LIST
8138: LIST
8139: PUSH
8140: LD_OWVAR 67
8144: ARRAY
8145: PUSH
8146: EMPTY
8147: LIST
8148: LIST
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 14
8154: PUSH
8155: LD_INT 1
8157: PUSH
8158: LD_INT 2
8160: PUSH
8161: LD_INT 27
8163: PUSH
8164: LD_INT 26
8166: PUSH
8167: LD_INT 26
8169: PUSH
8170: LD_INT 26
8172: PUSH
8173: EMPTY
8174: LIST
8175: LIST
8176: LIST
8177: LIST
8178: PUSH
8179: LD_OWVAR 67
8183: ARRAY
8184: PUSH
8185: EMPTY
8186: LIST
8187: LIST
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 14
8193: PUSH
8194: LD_INT 1
8196: PUSH
8197: LD_INT 2
8199: PUSH
8200: LD_INT 26
8202: PUSH
8203: LD_INT 26
8205: PUSH
8206: LD_INT 29
8208: PUSH
8209: LD_INT 29
8211: PUSH
8212: EMPTY
8213: LIST
8214: LIST
8215: LIST
8216: LIST
8217: PUSH
8218: LD_OWVAR 67
8222: ARRAY
8223: PUSH
8224: EMPTY
8225: LIST
8226: LIST
8227: LIST
8228: LIST
8229: PUSH
8230: LD_INT 13
8232: PUSH
8233: LD_INT 1
8235: PUSH
8236: LD_INT 2
8238: PUSH
8239: LD_INT 26
8241: PUSH
8242: LD_INT 29
8244: PUSH
8245: LD_INT 29
8247: PUSH
8248: LD_INT 29
8250: PUSH
8251: EMPTY
8252: LIST
8253: LIST
8254: LIST
8255: LIST
8256: PUSH
8257: LD_OWVAR 67
8261: ARRAY
8262: PUSH
8263: EMPTY
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: PUSH
8269: LD_INT 13
8271: PUSH
8272: LD_INT 1
8274: PUSH
8275: LD_INT 2
8277: PUSH
8278: LD_INT 29
8280: PUSH
8281: EMPTY
8282: LIST
8283: LIST
8284: LIST
8285: LIST
8286: PUSH
8287: LD_INT 14
8289: PUSH
8290: LD_INT 1
8292: PUSH
8293: LD_INT 2
8295: PUSH
8296: LD_INT 26
8298: PUSH
8299: EMPTY
8300: LIST
8301: LIST
8302: LIST
8303: LIST
8304: PUSH
8305: EMPTY
8306: LIST
8307: LIST
8308: LIST
8309: LIST
8310: LIST
8311: LIST
8312: PPUSH
8313: CALL 45563 0 2
// end ; repeat wait ( 0 0$1 ) ;
8317: LD_INT 35
8319: PPUSH
8320: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
8324: LD_INT 3
8326: PPUSH
8327: LD_INT 1
8329: PPUSH
8330: CALL 46981 0 2
8334: PUSH
8335: LD_INT 6
8337: GREATEREQUAL
8338: IFFALSE 8317
// wait ( 0 0$30 ) ;
8340: LD_INT 1050
8342: PPUSH
8343: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8347: LD_ADDR_VAR 0 2
8351: PUSH
8352: LD_INT 3
8354: PPUSH
8355: LD_INT 1
8357: PPUSH
8358: CALL 46981 0 2
8362: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8363: LD_ADDR_EXP 96
8367: PUSH
8368: LD_EXP 96
8372: PPUSH
8373: LD_INT 3
8375: PPUSH
8376: LD_EXP 96
8380: PUSH
8381: LD_INT 3
8383: ARRAY
8384: PUSH
8385: LD_VAR 0 2
8389: DIFF
8390: PPUSH
8391: CALL_OW 1
8395: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8396: LD_ADDR_VAR 0 3
8400: PUSH
8401: LD_INT 0
8403: PPUSH
8404: LD_INT 2
8406: PPUSH
8407: CALL_OW 12
8411: ST_TO_ADDR
// if target then
8412: LD_VAR 0 3
8416: IFFALSE 8544
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8418: LD_ADDR_VAR 0 2
8422: PUSH
8423: LD_VAR 0 2
8427: PPUSH
8428: LD_INT 24
8430: PUSH
8431: LD_INT 250
8433: PUSH
8434: EMPTY
8435: LIST
8436: LIST
8437: PPUSH
8438: CALL_OW 72
8442: ST_TO_ADDR
// for i in tmp do
8443: LD_ADDR_VAR 0 1
8447: PUSH
8448: LD_VAR 0 2
8452: PUSH
8453: FOR_IN
8454: IFFALSE 8494
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8456: LD_VAR 0 1
8460: PPUSH
8461: LD_INT 89
8463: PPUSH
8464: LD_INT 71
8466: PPUSH
8467: CALL_OW 297
8471: PUSH
8472: LD_INT 9
8474: GREATER
8475: IFFALSE 8492
// ComMoveXY ( i , 89 , 71 ) ;
8477: LD_VAR 0 1
8481: PPUSH
8482: LD_INT 89
8484: PPUSH
8485: LD_INT 71
8487: PPUSH
8488: CALL_OW 111
8492: GO 8453
8494: POP
8495: POP
// wait ( 0 0$1 ) ;
8496: LD_INT 35
8498: PPUSH
8499: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8503: LD_VAR 0 2
8507: PPUSH
8508: LD_INT 92
8510: PUSH
8511: LD_INT 89
8513: PUSH
8514: LD_INT 71
8516: PUSH
8517: LD_INT 9
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: LIST
8524: LIST
8525: PPUSH
8526: CALL_OW 72
8530: PUSH
8531: LD_VAR 0 2
8535: PUSH
8536: LD_INT 1
8538: MINUS
8539: GREATEREQUAL
8540: IFFALSE 8418
// end else
8542: GO 8668
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8544: LD_ADDR_VAR 0 2
8548: PUSH
8549: LD_VAR 0 2
8553: PPUSH
8554: LD_INT 24
8556: PUSH
8557: LD_INT 250
8559: PUSH
8560: EMPTY
8561: LIST
8562: LIST
8563: PPUSH
8564: CALL_OW 72
8568: ST_TO_ADDR
// for i in tmp do
8569: LD_ADDR_VAR 0 1
8573: PUSH
8574: LD_VAR 0 2
8578: PUSH
8579: FOR_IN
8580: IFFALSE 8620
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8582: LD_VAR 0 1
8586: PPUSH
8587: LD_INT 147
8589: PPUSH
8590: LD_INT 4
8592: PPUSH
8593: CALL_OW 297
8597: PUSH
8598: LD_INT 9
8600: GREATER
8601: IFFALSE 8618
// ComMoveXY ( i , 147 , 4 ) ;
8603: LD_VAR 0 1
8607: PPUSH
8608: LD_INT 147
8610: PPUSH
8611: LD_INT 4
8613: PPUSH
8614: CALL_OW 111
8618: GO 8579
8620: POP
8621: POP
// wait ( 0 0$1 ) ;
8622: LD_INT 35
8624: PPUSH
8625: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8629: LD_VAR 0 2
8633: PPUSH
8634: LD_INT 92
8636: PUSH
8637: LD_INT 147
8639: PUSH
8640: LD_INT 4
8642: PUSH
8643: LD_INT 9
8645: PUSH
8646: EMPTY
8647: LIST
8648: LIST
8649: LIST
8650: LIST
8651: PPUSH
8652: CALL_OW 72
8656: PUSH
8657: LD_VAR 0 2
8661: PUSH
8662: LD_INT 1
8664: MINUS
8665: GREATEREQUAL
8666: IFFALSE 8544
// end ; repeat wait ( 0 0$1 ) ;
8668: LD_INT 35
8670: PPUSH
8671: CALL_OW 67
// for i in tmp do
8675: LD_ADDR_VAR 0 1
8679: PUSH
8680: LD_VAR 0 2
8684: PUSH
8685: FOR_IN
8686: IFFALSE 8768
// begin if GetLives ( i ) > 251 then
8688: LD_VAR 0 1
8692: PPUSH
8693: CALL_OW 256
8697: PUSH
8698: LD_INT 251
8700: GREATER
8701: IFFALSE 8739
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8703: LD_VAR 0 1
8707: PPUSH
8708: LD_INT 81
8710: PUSH
8711: LD_INT 8
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: PPUSH
8718: CALL_OW 69
8722: PPUSH
8723: LD_VAR 0 1
8727: PPUSH
8728: CALL_OW 74
8732: PPUSH
8733: CALL_OW 115
8737: GO 8766
// if IsDead ( i ) then
8739: LD_VAR 0 1
8743: PPUSH
8744: CALL_OW 301
8748: IFFALSE 8766
// tmp := tmp diff i ;
8750: LD_ADDR_VAR 0 2
8754: PUSH
8755: LD_VAR 0 2
8759: PUSH
8760: LD_VAR 0 1
8764: DIFF
8765: ST_TO_ADDR
// end ;
8766: GO 8685
8768: POP
8769: POP
// until not tmp ;
8770: LD_VAR 0 2
8774: NOT
8775: IFFALSE 8668
// end ;
8777: PPOPN 3
8779: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8780: LD_EXP 58
8784: PPUSH
8785: CALL_OW 302
8789: PUSH
8790: LD_EXP 3
8794: NOT
8795: AND
8796: IFFALSE 8805
8798: GO 8800
8800: DISABLE
// BuildKozlovBomb ;
8801: CALL 7776 0 0
8805: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8806: LD_INT 22
8808: PUSH
8809: LD_INT 8
8811: PUSH
8812: EMPTY
8813: LIST
8814: LIST
8815: PUSH
8816: LD_INT 34
8818: PUSH
8819: LD_INT 48
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PPUSH
8830: CALL_OW 69
8834: IFFALSE 8882
8836: GO 8838
8838: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8839: LD_INT 22
8841: PUSH
8842: LD_INT 8
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PUSH
8849: LD_INT 34
8851: PUSH
8852: LD_INT 48
8854: PUSH
8855: EMPTY
8856: LIST
8857: LIST
8858: PUSH
8859: EMPTY
8860: LIST
8861: LIST
8862: PPUSH
8863: CALL_OW 69
8867: PUSH
8868: LD_INT 1
8870: ARRAY
8871: PPUSH
8872: LD_INT 173
8874: PPUSH
8875: LD_INT 96
8877: PPUSH
8878: CALL_OW 116
// end ; end_of_file
8882: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
8887: PPUSH
8888: PPUSH
8889: PPUSH
8890: PPUSH
8891: PPUSH
8892: PPUSH
8893: PPUSH
// side := 3 ;
8894: LD_ADDR_VAR 0 6
8898: PUSH
8899: LD_INT 3
8901: ST_TO_ADDR
// InitHc ;
8902: CALL_OW 19
// uc_side := side ;
8906: LD_ADDR_OWVAR 20
8910: PUSH
8911: LD_VAR 0 6
8915: ST_TO_ADDR
// uc_nation := 3 ;
8916: LD_ADDR_OWVAR 21
8920: PUSH
8921: LD_INT 3
8923: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8924: LD_ADDR_VAR 0 2
8928: PUSH
8929: LD_INT 22
8931: PUSH
8932: LD_VAR 0 6
8936: PUSH
8937: EMPTY
8938: LIST
8939: LIST
8940: PUSH
8941: LD_INT 21
8943: PUSH
8944: LD_INT 3
8946: PUSH
8947: EMPTY
8948: LIST
8949: LIST
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: PPUSH
8955: CALL_OW 69
8959: PUSH
8960: FOR_IN
8961: IFFALSE 8977
// SetBLevel ( i , 10 ) ;
8963: LD_VAR 0 2
8967: PPUSH
8968: LD_INT 10
8970: PPUSH
8971: CALL_OW 241
8975: GO 8960
8977: POP
8978: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8979: LD_ADDR_VAR 0 9
8983: PUSH
8984: LD_INT 22
8986: PUSH
8987: LD_VAR 0 6
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: PUSH
8996: LD_INT 30
8998: PUSH
8999: LD_INT 34
9001: PUSH
9002: EMPTY
9003: LIST
9004: LIST
9005: PUSH
9006: EMPTY
9007: LIST
9008: LIST
9009: PPUSH
9010: CALL_OW 69
9014: ST_TO_ADDR
// if teleport then
9015: LD_VAR 0 9
9019: IFFALSE 9040
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9021: LD_VAR 0 9
9025: PUSH
9026: LD_INT 1
9028: ARRAY
9029: PPUSH
9030: LD_INT 123
9032: PPUSH
9033: LD_INT 122
9035: PPUSH
9036: CALL_OW 243
// hc_importance := 0 ;
9040: LD_ADDR_OWVAR 32
9044: PUSH
9045: LD_INT 0
9047: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9048: LD_ADDR_EXP 59
9052: PUSH
9053: LD_STRING Platonov
9055: PPUSH
9056: CALL_OW 25
9060: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9061: LD_ADDR_EXP 60
9065: PUSH
9066: LD_STRING Yakotich
9068: PPUSH
9069: LD_EXP 1
9073: NOT
9074: PPUSH
9075: LD_STRING 09_
9077: PPUSH
9078: CALL 51951 0 3
9082: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9083: LD_ADDR_EXP 61
9087: PUSH
9088: LD_STRING Gleb
9090: PPUSH
9091: CALL_OW 25
9095: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9096: LD_STRING 03_Cornel
9098: PPUSH
9099: CALL_OW 28
9103: IFFALSE 9151
// begin Bierezov := NewCharacter ( Mikhail ) ;
9105: LD_ADDR_EXP 62
9109: PUSH
9110: LD_STRING Mikhail
9112: PPUSH
9113: CALL_OW 25
9117: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9118: LD_EXP 62
9122: PPUSH
9123: LD_INT 197
9125: PPUSH
9126: LD_INT 111
9128: PPUSH
9129: LD_INT 9
9131: PPUSH
9132: LD_INT 0
9134: PPUSH
9135: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9139: LD_EXP 62
9143: PPUSH
9144: LD_INT 3
9146: PPUSH
9147: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9151: LD_EXP 59
9155: PPUSH
9156: LD_INT 126
9158: PPUSH
9159: CALL_OW 52
// if Yakotich then
9163: LD_EXP 60
9167: IFFALSE 9190
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9169: LD_EXP 60
9173: PPUSH
9174: LD_INT 197
9176: PPUSH
9177: LD_INT 111
9179: PPUSH
9180: LD_INT 9
9182: PPUSH
9183: LD_INT 0
9185: PPUSH
9186: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9190: LD_EXP 61
9194: PPUSH
9195: LD_INT 197
9197: PPUSH
9198: LD_INT 111
9200: PPUSH
9201: LD_INT 9
9203: PPUSH
9204: LD_INT 0
9206: PPUSH
9207: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9211: LD_ADDR_VAR 0 5
9215: PUSH
9216: LD_INT 126
9218: PPUSH
9219: LD_INT 2
9221: PPUSH
9222: LD_STRING zhukov
9224: PPUSH
9225: LD_INT 9
9227: PUSH
9228: LD_INT 10
9230: PUSH
9231: LD_INT 10
9233: PUSH
9234: LD_INT 10
9236: PUSH
9237: EMPTY
9238: LIST
9239: LIST
9240: LIST
9241: LIST
9242: PUSH
9243: LD_OWVAR 67
9247: ARRAY
9248: PPUSH
9249: LD_INT 9000
9251: PUSH
9252: LD_INT 1000
9254: PUSH
9255: LD_INT 300
9257: PUSH
9258: EMPTY
9259: LIST
9260: LIST
9261: LIST
9262: PPUSH
9263: LD_INT 21
9265: PUSH
9266: LD_INT 8
9268: PUSH
9269: LD_INT 13
9271: PUSH
9272: LD_INT 8
9274: PUSH
9275: EMPTY
9276: LIST
9277: LIST
9278: LIST
9279: LIST
9280: PPUSH
9281: CALL 60410 0 6
9285: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9286: LD_ADDR_VAR 0 4
9290: PUSH
9291: LD_INT 267
9293: PPUSH
9294: CALL_OW 274
9298: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9299: LD_VAR 0 4
9303: PPUSH
9304: LD_INT 1
9306: PPUSH
9307: LD_INT 5000
9309: PPUSH
9310: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9314: LD_VAR 0 4
9318: PPUSH
9319: LD_INT 2
9321: PPUSH
9322: LD_INT 200
9324: PPUSH
9325: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9329: LD_VAR 0 4
9333: PPUSH
9334: LD_INT 3
9336: PPUSH
9337: LD_INT 200
9339: PPUSH
9340: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
9344: LD_ADDR_EXP 77
9348: PUSH
9349: LD_EXP 77
9353: PPUSH
9354: LD_INT 2
9356: PPUSH
9357: LD_VAR 0 5
9361: PUSH
9362: LD_INT 22
9364: PUSH
9365: LD_VAR 0 6
9369: PUSH
9370: EMPTY
9371: LIST
9372: LIST
9373: PUSH
9374: LD_INT 3
9376: PUSH
9377: LD_INT 21
9379: PUSH
9380: LD_INT 2
9382: PUSH
9383: EMPTY
9384: LIST
9385: LIST
9386: PUSH
9387: EMPTY
9388: LIST
9389: LIST
9390: PUSH
9391: EMPTY
9392: LIST
9393: LIST
9394: PPUSH
9395: CALL_OW 69
9399: UNION
9400: PUSH
9401: LD_EXP 59
9405: DIFF
9406: PPUSH
9407: CALL_OW 1
9411: ST_TO_ADDR
// behemoths := [ ] ;
9412: LD_ADDR_EXP 63
9416: PUSH
9417: EMPTY
9418: ST_TO_ADDR
// behemothBuilders := [ ] ;
9419: LD_ADDR_EXP 64
9423: PUSH
9424: EMPTY
9425: ST_TO_ADDR
// j := 3 ;
9426: LD_ADDR_VAR 0 3
9430: PUSH
9431: LD_INT 3
9433: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9434: LD_ADDR_VAR 0 2
9438: PUSH
9439: LD_INT 22
9441: PUSH
9442: LD_INT 3
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: PUSH
9449: LD_INT 25
9451: PUSH
9452: LD_INT 3
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: PUSH
9459: EMPTY
9460: LIST
9461: LIST
9462: PPUSH
9463: CALL_OW 69
9467: PUSH
9468: FOR_IN
9469: IFFALSE 9519
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9471: LD_ADDR_EXP 64
9475: PUSH
9476: LD_EXP 64
9480: PPUSH
9481: LD_VAR 0 2
9485: PPUSH
9486: CALL 89400 0 2
9490: ST_TO_ADDR
// j := j - 1 ;
9491: LD_ADDR_VAR 0 3
9495: PUSH
9496: LD_VAR 0 3
9500: PUSH
9501: LD_INT 1
9503: MINUS
9504: ST_TO_ADDR
// if j = 0 then
9505: LD_VAR 0 3
9509: PUSH
9510: LD_INT 0
9512: EQUAL
9513: IFFALSE 9517
// break ;
9515: GO 9519
// end ;
9517: GO 9468
9519: POP
9520: POP
// end ;
9521: LD_VAR 0 1
9525: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9526: LD_INT 0
9528: PPUSH
9529: PPUSH
9530: PPUSH
9531: PPUSH
9532: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9533: LD_ADDR_VAR 0 4
9537: PUSH
9538: LD_INT 209
9540: PUSH
9541: LD_INT 149
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: PUSH
9548: LD_INT 219
9550: PUSH
9551: LD_INT 154
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 223
9560: PUSH
9561: LD_INT 149
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: PUSH
9568: LD_INT 232
9570: PUSH
9571: LD_INT 155
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: ST_TO_ADDR
// if not behemothBuilders then
9584: LD_EXP 64
9588: NOT
9589: IFFALSE 9593
// exit ;
9591: GO 9697
// j := 1 ;
9593: LD_ADDR_VAR 0 3
9597: PUSH
9598: LD_INT 1
9600: ST_TO_ADDR
// for i in behemothBuilders do
9601: LD_ADDR_VAR 0 2
9605: PUSH
9606: LD_EXP 64
9610: PUSH
9611: FOR_IN
9612: IFFALSE 9695
// begin if IsInUnit ( i ) then
9614: LD_VAR 0 2
9618: PPUSH
9619: CALL_OW 310
9623: IFFALSE 9634
// ComExitBuilding ( i ) ;
9625: LD_VAR 0 2
9629: PPUSH
9630: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9634: LD_VAR 0 2
9638: PPUSH
9639: LD_INT 37
9641: PPUSH
9642: LD_VAR 0 4
9646: PUSH
9647: LD_VAR 0 3
9651: ARRAY
9652: PUSH
9653: LD_INT 1
9655: ARRAY
9656: PPUSH
9657: LD_VAR 0 4
9661: PUSH
9662: LD_VAR 0 3
9666: ARRAY
9667: PUSH
9668: LD_INT 2
9670: ARRAY
9671: PPUSH
9672: LD_INT 0
9674: PPUSH
9675: CALL_OW 230
// j := j + 1 ;
9679: LD_ADDR_VAR 0 3
9683: PUSH
9684: LD_VAR 0 3
9688: PUSH
9689: LD_INT 1
9691: PLUS
9692: ST_TO_ADDR
// end ;
9693: GO 9611
9695: POP
9696: POP
// end ;
9697: LD_VAR 0 1
9701: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9702: LD_INT 3
9704: PPUSH
9705: CALL 89461 0 1
9709: PUSH
9710: LD_INT 22
9712: PUSH
9713: LD_INT 3
9715: PUSH
9716: EMPTY
9717: LIST
9718: LIST
9719: PUSH
9720: LD_INT 30
9722: PUSH
9723: LD_INT 37
9725: PUSH
9726: EMPTY
9727: LIST
9728: LIST
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PPUSH
9734: CALL_OW 69
9738: NOT
9739: AND
9740: IFFALSE 9926
9742: GO 9744
9744: DISABLE
9745: LD_INT 0
9747: PPUSH
9748: PPUSH
// begin enable ;
9749: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9750: LD_ADDR_VAR 0 2
9754: PUSH
9755: LD_INT 3
9757: PPUSH
9758: CALL 89461 0 1
9762: ST_TO_ADDR
// for i in tmp do
9763: LD_ADDR_VAR 0 1
9767: PUSH
9768: LD_VAR 0 2
9772: PUSH
9773: FOR_IN
9774: IFFALSE 9924
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9776: LD_VAR 0 1
9780: PPUSH
9781: LD_INT 7
9783: PPUSH
9784: CALL_OW 308
9788: PUSH
9789: LD_VAR 0 1
9793: PPUSH
9794: CALL_OW 110
9798: PUSH
9799: LD_INT 2
9801: EQUAL
9802: NOT
9803: AND
9804: IFFALSE 9818
// SetTag ( i , 2 ) ;
9806: LD_VAR 0 1
9810: PPUSH
9811: LD_INT 2
9813: PPUSH
9814: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9818: LD_INT 81
9820: PUSH
9821: LD_INT 3
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: PUSH
9828: LD_INT 91
9830: PUSH
9831: LD_VAR 0 1
9835: PUSH
9836: LD_INT 12
9838: PUSH
9839: EMPTY
9840: LIST
9841: LIST
9842: LIST
9843: PUSH
9844: EMPTY
9845: LIST
9846: LIST
9847: PPUSH
9848: CALL_OW 69
9852: NOT
9853: PUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: CALL_OW 110
9863: PUSH
9864: LD_INT 2
9866: EQUAL
9867: NOT
9868: AND
9869: IFFALSE 9888
// ComAgressiveMove ( i , 64 , 93 ) else
9871: LD_VAR 0 1
9875: PPUSH
9876: LD_INT 64
9878: PPUSH
9879: LD_INT 93
9881: PPUSH
9882: CALL_OW 114
9886: GO 9922
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9888: LD_VAR 0 1
9892: PPUSH
9893: LD_INT 81
9895: PUSH
9896: LD_INT 3
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PPUSH
9903: CALL_OW 69
9907: PPUSH
9908: LD_VAR 0 1
9912: PPUSH
9913: CALL_OW 74
9917: PPUSH
9918: CALL_OW 115
// end ;
9922: GO 9773
9924: POP
9925: POP
// end ;
9926: PPOPN 2
9928: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9929: LD_EXP 2
9933: NOT
9934: PUSH
9935: LD_INT 2
9937: PPUSH
9938: LD_INT 1
9940: PPUSH
9941: CALL 46981 0 2
9945: NOT
9946: AND
9947: IFFALSE 10871
9949: GO 9951
9951: DISABLE
9952: LD_INT 0
9954: PPUSH
9955: PPUSH
9956: PPUSH
9957: PPUSH
// begin enable ;
9958: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9959: LD_INT 22
9961: PUSH
9962: LD_INT 3
9964: PUSH
9965: EMPTY
9966: LIST
9967: LIST
9968: PUSH
9969: LD_INT 30
9971: PUSH
9972: LD_INT 3
9974: PUSH
9975: EMPTY
9976: LIST
9977: LIST
9978: PUSH
9979: EMPTY
9980: LIST
9981: LIST
9982: PPUSH
9983: CALL_OW 69
9987: NOT
9988: IFFALSE 9992
// exit ;
9990: GO 10871
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9992: LD_ADDR_VAR 0 4
9996: PUSH
9997: LD_INT 22
9999: PUSH
10000: LD_INT 3
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PUSH
10007: LD_INT 30
10009: PUSH
10010: LD_INT 34
10012: PUSH
10013: EMPTY
10014: LIST
10015: LIST
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PPUSH
10021: CALL_OW 69
10025: ST_TO_ADDR
// if Prob ( 40 ) then
10026: LD_INT 40
10028: PPUSH
10029: CALL_OW 13
10033: IFFALSE 10160
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10035: LD_INT 2
10037: PPUSH
10038: LD_INT 22
10040: PUSH
10041: LD_INT 3
10043: PUSH
10044: LD_INT 3
10046: PUSH
10047: LD_INT 49
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: LIST
10054: LIST
10055: PUSH
10056: LD_INT 22
10058: PUSH
10059: LD_INT 3
10061: PUSH
10062: LD_INT 3
10064: PUSH
10065: LD_INT 49
10067: PUSH
10068: EMPTY
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: PUSH
10074: LD_INT 22
10076: PUSH
10077: LD_INT 3
10079: PUSH
10080: LD_INT 3
10082: PUSH
10083: LD_INT 49
10085: PUSH
10086: EMPTY
10087: LIST
10088: LIST
10089: LIST
10090: LIST
10091: PUSH
10092: LD_INT 24
10094: PUSH
10095: LD_INT 3
10097: PUSH
10098: LD_INT 3
10100: PUSH
10101: LD_INT 46
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: PUSH
10110: LD_INT 24
10112: PUSH
10113: LD_INT 3
10115: PUSH
10116: LD_INT 3
10118: PUSH
10119: LD_INT 46
10121: PUSH
10122: EMPTY
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: PUSH
10128: LD_INT 24
10130: PUSH
10131: LD_INT 3
10133: PUSH
10134: LD_INT 3
10136: PUSH
10137: LD_INT 46
10139: PUSH
10140: EMPTY
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: PPUSH
10154: CALL 45563 0 2
// end else
10158: GO 10283
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10160: LD_INT 2
10162: PPUSH
10163: LD_INT 24
10165: PUSH
10166: LD_INT 3
10168: PUSH
10169: LD_INT 3
10171: PUSH
10172: LD_INT 47
10174: PUSH
10175: EMPTY
10176: LIST
10177: LIST
10178: LIST
10179: LIST
10180: PUSH
10181: LD_INT 24
10183: PUSH
10184: LD_INT 3
10186: PUSH
10187: LD_INT 3
10189: PUSH
10190: LD_INT 47
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: LIST
10197: LIST
10198: PUSH
10199: LD_INT 24
10201: PUSH
10202: LD_INT 3
10204: PUSH
10205: LD_INT 3
10207: PUSH
10208: LD_INT 47
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 24
10219: PUSH
10220: LD_INT 3
10222: PUSH
10223: LD_INT 3
10225: PUSH
10226: LD_INT 46
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: LIST
10233: LIST
10234: PUSH
10235: LD_INT 24
10237: PUSH
10238: LD_INT 3
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: LD_INT 46
10246: PUSH
10247: EMPTY
10248: LIST
10249: LIST
10250: LIST
10251: LIST
10252: PUSH
10253: LD_INT 24
10255: PUSH
10256: LD_INT 3
10258: PUSH
10259: LD_INT 3
10261: PUSH
10262: LD_INT 46
10264: PUSH
10265: EMPTY
10266: LIST
10267: LIST
10268: LIST
10269: LIST
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: PPUSH
10279: CALL 45563 0 2
// end ; if Difficulty > 1 then
10283: LD_OWVAR 67
10287: PUSH
10288: LD_INT 1
10290: GREATER
10291: IFFALSE 10321
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10293: LD_INT 2
10295: PPUSH
10296: LD_INT 24
10298: PUSH
10299: LD_INT 3
10301: PUSH
10302: LD_INT 3
10304: PUSH
10305: LD_INT 47
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: LIST
10312: LIST
10313: PUSH
10314: EMPTY
10315: LIST
10316: PPUSH
10317: CALL 45563 0 2
// repeat wait ( 0 0$1 ) ;
10321: LD_INT 35
10323: PPUSH
10324: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10328: LD_INT 2
10330: PPUSH
10331: LD_INT 1
10333: PPUSH
10334: CALL 46981 0 2
10338: PUSH
10339: LD_INT 6
10341: PUSH
10342: LD_INT 7
10344: PUSH
10345: LD_INT 7
10347: PUSH
10348: LD_INT 7
10350: PUSH
10351: EMPTY
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: PUSH
10357: LD_OWVAR 67
10361: ARRAY
10362: GREATEREQUAL
10363: IFFALSE 10321
// wait ( 0 0$30 ) ;
10365: LD_INT 1050
10367: PPUSH
10368: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10372: LD_ADDR_VAR 0 2
10376: PUSH
10377: LD_INT 2
10379: PPUSH
10380: LD_INT 1
10382: PPUSH
10383: CALL 46981 0 2
10387: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10388: LD_ADDR_EXP 96
10392: PUSH
10393: LD_EXP 96
10397: PPUSH
10398: LD_INT 2
10400: PPUSH
10401: LD_EXP 96
10405: PUSH
10406: LD_INT 2
10408: ARRAY
10409: PUSH
10410: LD_VAR 0 2
10414: DIFF
10415: PPUSH
10416: CALL_OW 1
10420: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10421: LD_ADDR_VAR 0 3
10425: PUSH
10426: LD_INT 0
10428: PPUSH
10429: LD_INT 1
10431: PPUSH
10432: CALL_OW 12
10436: ST_TO_ADDR
// if target then
10437: LD_VAR 0 3
10441: IFFALSE 10569
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10443: LD_ADDR_VAR 0 2
10447: PUSH
10448: LD_VAR 0 2
10452: PPUSH
10453: LD_INT 24
10455: PUSH
10456: LD_INT 250
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: PPUSH
10463: CALL_OW 72
10467: ST_TO_ADDR
// for i in tmp do
10468: LD_ADDR_VAR 0 1
10472: PUSH
10473: LD_VAR 0 2
10477: PUSH
10478: FOR_IN
10479: IFFALSE 10519
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10481: LD_VAR 0 1
10485: PPUSH
10486: LD_INT 139
10488: PPUSH
10489: LD_INT 89
10491: PPUSH
10492: CALL_OW 297
10496: PUSH
10497: LD_INT 9
10499: GREATER
10500: IFFALSE 10517
// ComMoveXY ( i , 139 , 89 ) ;
10502: LD_VAR 0 1
10506: PPUSH
10507: LD_INT 139
10509: PPUSH
10510: LD_INT 89
10512: PPUSH
10513: CALL_OW 111
10517: GO 10478
10519: POP
10520: POP
// wait ( 0 0$1 ) ;
10521: LD_INT 35
10523: PPUSH
10524: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10528: LD_VAR 0 2
10532: PPUSH
10533: LD_INT 92
10535: PUSH
10536: LD_INT 139
10538: PUSH
10539: LD_INT 89
10541: PUSH
10542: LD_INT 9
10544: PUSH
10545: EMPTY
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: PPUSH
10551: CALL_OW 72
10555: PUSH
10556: LD_VAR 0 2
10560: PUSH
10561: LD_INT 1
10563: MINUS
10564: GREATEREQUAL
10565: IFFALSE 10443
// end else
10567: GO 10711
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10569: LD_VAR 0 2
10573: PPUSH
10574: LD_VAR 0 4
10578: PUSH
10579: LD_INT 1
10581: ARRAY
10582: PPUSH
10583: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10587: LD_ADDR_VAR 0 2
10591: PUSH
10592: LD_VAR 0 2
10596: PPUSH
10597: LD_INT 24
10599: PUSH
10600: LD_INT 250
10602: PUSH
10603: EMPTY
10604: LIST
10605: LIST
10606: PPUSH
10607: CALL_OW 72
10611: ST_TO_ADDR
// for i in tmp do
10612: LD_ADDR_VAR 0 1
10616: PUSH
10617: LD_VAR 0 2
10621: PUSH
10622: FOR_IN
10623: IFFALSE 10663
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10625: LD_VAR 0 1
10629: PPUSH
10630: LD_INT 124
10632: PPUSH
10633: LD_INT 139
10635: PPUSH
10636: CALL_OW 297
10640: PUSH
10641: LD_INT 9
10643: GREATER
10644: IFFALSE 10661
// ComMoveXY ( i , 124 , 139 ) ;
10646: LD_VAR 0 1
10650: PPUSH
10651: LD_INT 124
10653: PPUSH
10654: LD_INT 139
10656: PPUSH
10657: CALL_OW 111
10661: GO 10622
10663: POP
10664: POP
// wait ( 0 0$1 ) ;
10665: LD_INT 35
10667: PPUSH
10668: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10672: LD_VAR 0 2
10676: PPUSH
10677: LD_INT 92
10679: PUSH
10680: LD_INT 124
10682: PUSH
10683: LD_INT 139
10685: PUSH
10686: LD_INT 9
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: LIST
10693: LIST
10694: PPUSH
10695: CALL_OW 72
10699: PUSH
10700: LD_VAR 0 2
10704: PUSH
10705: LD_INT 1
10707: MINUS
10708: GREATEREQUAL
10709: IFFALSE 10587
// end ; repeat wait ( 0 0$1 ) ;
10711: LD_INT 35
10713: PPUSH
10714: CALL_OW 67
// for i in tmp do
10718: LD_ADDR_VAR 0 1
10722: PUSH
10723: LD_VAR 0 2
10727: PUSH
10728: FOR_IN
10729: IFFALSE 10862
// begin if GetLives ( i ) > 251 then
10731: LD_VAR 0 1
10735: PPUSH
10736: CALL_OW 256
10740: PUSH
10741: LD_INT 251
10743: GREATER
10744: IFFALSE 10833
// begin if GetWeapon ( i ) = ru_time_lapser then
10746: LD_VAR 0 1
10750: PPUSH
10751: CALL_OW 264
10755: PUSH
10756: LD_INT 49
10758: EQUAL
10759: IFFALSE 10797
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10761: LD_VAR 0 1
10765: PPUSH
10766: LD_INT 81
10768: PUSH
10769: LD_INT 3
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PPUSH
10776: CALL_OW 69
10780: PPUSH
10781: LD_VAR 0 1
10785: PPUSH
10786: CALL_OW 74
10790: PPUSH
10791: CALL_OW 112
10795: GO 10831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10797: LD_VAR 0 1
10801: PPUSH
10802: LD_INT 81
10804: PUSH
10805: LD_INT 3
10807: PUSH
10808: EMPTY
10809: LIST
10810: LIST
10811: PPUSH
10812: CALL_OW 69
10816: PPUSH
10817: LD_VAR 0 1
10821: PPUSH
10822: CALL_OW 74
10826: PPUSH
10827: CALL_OW 115
// end else
10831: GO 10860
// if IsDead ( i ) then
10833: LD_VAR 0 1
10837: PPUSH
10838: CALL_OW 301
10842: IFFALSE 10860
// tmp := tmp diff i ;
10844: LD_ADDR_VAR 0 2
10848: PUSH
10849: LD_VAR 0 2
10853: PUSH
10854: LD_VAR 0 1
10858: DIFF
10859: ST_TO_ADDR
// end ;
10860: GO 10728
10862: POP
10863: POP
// until not tmp ;
10864: LD_VAR 0 2
10868: NOT
10869: IFFALSE 10711
// end ;
10871: PPOPN 4
10873: END
// every 30 30$00 trigger not russianDestroyed do
10874: LD_EXP 2
10878: NOT
10879: IFFALSE 10948
10881: GO 10883
10883: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10884: LD_INT 105000
10886: PUSH
10887: LD_INT 84000
10889: PUSH
10890: LD_INT 63000
10892: PUSH
10893: LD_INT 52500
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: PUSH
10902: LD_OWVAR 67
10906: ARRAY
10907: PPUSH
10908: CALL_OW 67
// if russianDestroyed then
10912: LD_EXP 2
10916: IFFALSE 10920
// exit ;
10918: GO 10948
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10920: LD_INT 2
10922: PPUSH
10923: LD_INT 23
10925: PUSH
10926: LD_INT 3
10928: PUSH
10929: LD_INT 1
10931: PUSH
10932: LD_INT 48
10934: PUSH
10935: EMPTY
10936: LIST
10937: LIST
10938: LIST
10939: LIST
10940: PUSH
10941: EMPTY
10942: LIST
10943: PPUSH
10944: CALL 45563 0 2
// end ; end_of_file
10948: END
// export function CustomEvent ( event ) ; begin
10949: LD_INT 0
10951: PPUSH
// end ;
10952: LD_VAR 0 2
10956: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10957: LD_VAR 0 2
10961: PPUSH
10962: LD_VAR 0 3
10966: PPUSH
10967: LD_INT 15
10969: PPUSH
10970: CALL_OW 309
10974: IFFALSE 10983
// YouLost ( MothContaminate ) ;
10976: LD_STRING MothContaminate
10978: PPUSH
10979: CALL_OW 104
// end ;
10983: PPOPN 3
10985: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10986: LD_VAR 0 2
10990: PPUSH
10991: LD_VAR 0 3
10995: PPUSH
10996: LD_INT 15
10998: PPUSH
10999: CALL_OW 309
11003: IFFALSE 11019
// begin wait ( 0 0$6 ) ;
11005: LD_INT 210
11007: PPUSH
11008: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11012: LD_STRING MothContaminateBomb
11014: PPUSH
11015: CALL_OW 104
// end ; end ;
11019: PPOPN 3
11021: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11022: LD_VAR 0 1
11026: PPUSH
11027: CALL 109002 0 1
// if un = JMM then
11031: LD_VAR 0 1
11035: PUSH
11036: LD_EXP 19
11040: EQUAL
11041: IFFALSE 11052
// begin YouLost ( JMM ) ;
11043: LD_STRING JMM
11045: PPUSH
11046: CALL_OW 104
// exit ;
11050: GO 11181
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11052: LD_VAR 0 1
11056: PPUSH
11057: CALL_OW 255
11061: PUSH
11062: LD_INT 2
11064: EQUAL
11065: PUSH
11066: LD_EXP 18
11070: NOT
11071: AND
11072: IFFALSE 11082
// arabianAttacked := true ;
11074: LD_ADDR_EXP 18
11078: PUSH
11079: LD_INT 1
11081: ST_TO_ADDR
// if un = Powell then
11082: LD_VAR 0 1
11086: PUSH
11087: LD_EXP 55
11091: EQUAL
11092: IFFALSE 11102
// americanDestroyed := true ;
11094: LD_ADDR_EXP 4
11098: PUSH
11099: LD_INT 1
11101: ST_TO_ADDR
// if un = Platonov then
11102: LD_VAR 0 1
11106: PUSH
11107: LD_EXP 59
11111: EQUAL
11112: IFFALSE 11122
// russianDestroyed := true ;
11114: LD_ADDR_EXP 2
11118: PUSH
11119: LD_INT 1
11121: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11122: LD_VAR 0 1
11126: PUSH
11127: LD_INT 22
11129: PUSH
11130: LD_INT 7
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PUSH
11137: LD_INT 21
11139: PUSH
11140: LD_INT 2
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: PPUSH
11151: CALL_OW 69
11155: IN
11156: IFFALSE 11172
// vehicleLostCounter := vehicleLostCounter + 1 ;
11158: LD_ADDR_EXP 15
11162: PUSH
11163: LD_EXP 15
11167: PUSH
11168: LD_INT 1
11170: PLUS
11171: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11172: LD_VAR 0 1
11176: PPUSH
11177: CALL 48967 0 1
// end ;
11181: PPOPN 1
11183: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11184: LD_VAR 0 1
11188: PPUSH
11189: LD_VAR 0 2
11193: PPUSH
11194: CALL 51299 0 2
// end ;
11198: PPOPN 2
11200: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11201: LD_VAR 0 1
11205: PPUSH
11206: CALL 50367 0 1
// end ;
11210: PPOPN 1
11212: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11213: LD_VAR 0 1
11217: PUSH
11218: LD_INT 22
11220: PUSH
11221: LD_INT 8
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: PUSH
11228: LD_INT 30
11230: PUSH
11231: LD_INT 2
11233: PUSH
11234: EMPTY
11235: LIST
11236: LIST
11237: PUSH
11238: LD_INT 23
11240: PUSH
11241: LD_INT 3
11243: PUSH
11244: EMPTY
11245: LIST
11246: LIST
11247: PUSH
11248: EMPTY
11249: LIST
11250: LIST
11251: LIST
11252: PPUSH
11253: CALL_OW 69
11257: IN
11258: IFFALSE 11285
// begin ComUpgrade ( building ) ;
11260: LD_VAR 0 1
11264: PPUSH
11265: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11269: LD_EXP 58
11273: PPUSH
11274: LD_VAR 0 1
11278: PPUSH
11279: CALL 59949 0 2
// exit ;
11283: GO 11294
// end ; MCE_BuildingComplete ( building ) ;
11285: LD_VAR 0 1
11289: PPUSH
11290: CALL 50608 0 1
// end ;
11294: PPOPN 1
11296: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11297: LD_VAR 0 1
11301: PPUSH
11302: LD_VAR 0 2
11306: PPUSH
11307: CALL 48663 0 2
// end ;
11311: PPOPN 2
11313: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11314: LD_VAR 0 1
11318: PPUSH
11319: LD_VAR 0 2
11323: PPUSH
11324: LD_VAR 0 3
11328: PPUSH
11329: LD_VAR 0 4
11333: PPUSH
11334: LD_VAR 0 5
11338: PPUSH
11339: CALL 48283 0 5
// end ;
11343: PPOPN 5
11345: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11346: LD_VAR 0 1
11350: PPUSH
11351: LD_VAR 0 2
11355: PPUSH
11356: CALL 109122 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11360: LD_VAR 0 1
11364: PPUSH
11365: LD_VAR 0 2
11369: PPUSH
11370: CALL 47874 0 2
// end ;
11374: PPOPN 2
11376: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11377: LD_VAR 0 1
11381: PPUSH
11382: LD_VAR 0 2
11386: PPUSH
11387: LD_VAR 0 3
11391: PPUSH
11392: LD_VAR 0 4
11396: PPUSH
11397: CALL 47712 0 4
// end ;
11401: PPOPN 4
11403: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11404: LD_VAR 0 1
11408: PPUSH
11409: LD_VAR 0 2
11413: PPUSH
11414: LD_VAR 0 3
11418: PPUSH
11419: CALL 47487 0 3
// end ;
11423: PPOPN 3
11425: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11426: LD_VAR 0 1
11430: PPUSH
11431: LD_VAR 0 2
11435: PPUSH
11436: CALL 47372 0 2
// end ;
11440: PPOPN 2
11442: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11443: LD_VAR 0 1
11447: PPUSH
11448: LD_VAR 0 2
11452: PPUSH
11453: CALL 51594 0 2
// end ;
11457: PPOPN 2
11459: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11460: LD_VAR 0 1
11464: PPUSH
11465: LD_VAR 0 2
11469: PPUSH
11470: LD_VAR 0 3
11474: PPUSH
11475: LD_VAR 0 4
11479: PPUSH
11480: CALL 51810 0 4
// end ;
11484: PPOPN 4
11486: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11487: LD_VAR 0 1
11491: PPUSH
11492: LD_VAR 0 2
11496: PPUSH
11497: CALL 47181 0 2
// end ;
11501: PPOPN 2
11503: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11504: LD_VAR 0 1
11508: PPUSH
11509: CALL 109106 0 1
// end ; end_of_file
11513: PPOPN 1
11515: END
// export function Action ; begin
11516: LD_INT 0
11518: PPUSH
// InGameOn ;
11519: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11523: LD_INT 206
11525: PPUSH
11526: LD_INT 11
11528: PPUSH
11529: CALL_OW 86
// wait ( 0 0$1 ) ;
11533: LD_INT 35
11535: PPUSH
11536: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11540: LD_EXP 19
11544: PPUSH
11545: LD_STRING DStart-JMM-JMM-1
11547: PPUSH
11548: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11552: LD_EXP 52
11556: PPUSH
11557: LD_STRING DStart-JMM-Bur-1
11559: PPUSH
11560: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11564: LD_EXP 19
11568: PPUSH
11569: LD_STRING DStart-JMM-JMM-2
11571: PPUSH
11572: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11576: LD_EXP 52
11580: PPUSH
11581: LD_STRING DStart-JMM-Bur-2
11583: PPUSH
11584: CALL_OW 88
// InGameOff ;
11588: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11592: LD_STRING MStart
11594: PPUSH
11595: CALL_OW 337
// SaveForQuickRestart ;
11599: CALL_OW 22
// end ;
11603: LD_VAR 0 1
11607: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11608: LD_INT 7
11610: PPUSH
11611: LD_INT 255
11613: PPUSH
11614: LD_INT 219
11616: PPUSH
11617: CALL_OW 293
11621: IFFALSE 12230
11623: GO 11625
11625: DISABLE
11626: LD_INT 0
11628: PPUSH
// begin wait ( 0 0$3 ) ;
11629: LD_INT 105
11631: PPUSH
11632: CALL_OW 67
// alienSpotted := true ;
11636: LD_ADDR_EXP 10
11640: PUSH
11641: LD_INT 1
11643: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11644: LD_ADDR_VAR 0 1
11648: PUSH
11649: LD_INT 22
11651: PUSH
11652: LD_INT 7
11654: PUSH
11655: EMPTY
11656: LIST
11657: LIST
11658: PUSH
11659: LD_INT 23
11661: PUSH
11662: LD_INT 3
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: PUSH
11669: LD_INT 21
11671: PUSH
11672: LD_INT 1
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: PUSH
11679: LD_INT 26
11681: PUSH
11682: LD_INT 1
11684: PUSH
11685: EMPTY
11686: LIST
11687: LIST
11688: PUSH
11689: EMPTY
11690: LIST
11691: LIST
11692: LIST
11693: LIST
11694: PPUSH
11695: CALL_OW 69
11699: PUSH
11700: LD_EXP 52
11704: PUSH
11705: LD_EXP 40
11709: PUSH
11710: LD_EXP 42
11714: PUSH
11715: LD_EXP 43
11719: PUSH
11720: LD_EXP 50
11724: PUSH
11725: LD_EXP 49
11729: PUSH
11730: LD_EXP 44
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: DIFF
11744: ST_TO_ADDR
// DialogueOn ;
11745: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11749: LD_INT 255
11751: PPUSH
11752: LD_INT 219
11754: PPUSH
11755: LD_INT 7
11757: PPUSH
11758: LD_INT 20
11760: NEG
11761: PPUSH
11762: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11766: LD_INT 255
11768: PPUSH
11769: LD_INT 219
11771: PPUSH
11772: CALL_OW 86
// if speaker then
11776: LD_VAR 0 1
11780: IFFALSE 11798
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11782: LD_VAR 0 1
11786: PUSH
11787: LD_INT 1
11789: ARRAY
11790: PPUSH
11791: LD_STRING DAlienBase-RSol1-1
11793: PPUSH
11794: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11798: LD_EXP 19
11802: PPUSH
11803: LD_STRING DAlienBase-JMM-1
11805: PPUSH
11806: CALL_OW 88
// if IsOk ( Burlak ) then
11810: LD_EXP 52
11814: PPUSH
11815: CALL_OW 302
11819: IFFALSE 11840
// begin dwait ( 0 0$1 ) ;
11821: LD_INT 35
11823: PPUSH
11824: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11828: LD_EXP 52
11832: PPUSH
11833: LD_STRING DAlienBase-Bur-1
11835: PPUSH
11836: CALL_OW 88
// end ; if IsOk ( Roth ) then
11840: LD_EXP 20
11844: PPUSH
11845: CALL_OW 302
11849: IFFALSE 11863
// Say ( Roth , DAlienBase-Roth-1 ) ;
11851: LD_EXP 20
11855: PPUSH
11856: LD_STRING DAlienBase-Roth-1
11858: PPUSH
11859: CALL_OW 88
// if IsOk ( Gossudarov ) then
11863: LD_EXP 38
11867: PPUSH
11868: CALL_OW 302
11872: IFFALSE 11888
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11874: LD_EXP 38
11878: PPUSH
11879: LD_STRING DAlienBase-Gos-1
11881: PPUSH
11882: CALL_OW 88
11886: GO 12005
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11888: LD_ADDR_VAR 0 1
11892: PUSH
11893: LD_INT 22
11895: PUSH
11896: LD_INT 7
11898: PUSH
11899: EMPTY
11900: LIST
11901: LIST
11902: PUSH
11903: LD_INT 25
11905: PUSH
11906: LD_INT 4
11908: PUSH
11909: EMPTY
11910: LIST
11911: LIST
11912: PUSH
11913: LD_INT 21
11915: PUSH
11916: LD_INT 1
11918: PUSH
11919: EMPTY
11920: LIST
11921: LIST
11922: PUSH
11923: LD_INT 26
11925: PUSH
11926: LD_INT 1
11928: PUSH
11929: EMPTY
11930: LIST
11931: LIST
11932: PUSH
11933: EMPTY
11934: LIST
11935: LIST
11936: LIST
11937: LIST
11938: PPUSH
11939: CALL_OW 69
11943: PUSH
11944: LD_EXP 20
11948: PUSH
11949: LD_EXP 19
11953: PUSH
11954: LD_EXP 52
11958: PUSH
11959: LD_EXP 40
11963: PUSH
11964: LD_EXP 50
11968: PUSH
11969: LD_EXP 49
11973: PUSH
11974: EMPTY
11975: LIST
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: DIFF
11982: ST_TO_ADDR
// if speaker then
11983: LD_VAR 0 1
11987: IFFALSE 12005
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11989: LD_VAR 0 1
11993: PUSH
11994: LD_INT 1
11996: ARRAY
11997: PPUSH
11998: LD_STRING DAlienBase-Sci1-1
12000: PPUSH
12001: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12005: LD_INT 255
12007: PPUSH
12008: LD_INT 219
12010: PPUSH
12011: LD_INT 7
12013: PPUSH
12014: CALL_OW 331
// DialogueOff ;
12018: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12022: LD_INT 35
12024: PPUSH
12025: CALL_OW 67
// until IsSelected ( alien ) ;
12029: LD_INT 1
12031: PPUSH
12032: CALL_OW 306
12036: IFFALSE 12022
// if not artifactIResearched or not artifactIIResearched then
12038: LD_EXP 12
12042: NOT
12043: PUSH
12044: LD_EXP 13
12048: NOT
12049: OR
12050: IFFALSE 12230
// begin if IsOk ( Roth ) then
12052: LD_EXP 20
12056: PPUSH
12057: CALL_OW 302
12061: IFFALSE 12077
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12063: LD_EXP 20
12067: PPUSH
12068: LD_STRING DAlieBaseNotReady-Roth-1
12070: PPUSH
12071: CALL_OW 88
12075: GO 12230
// if IsOk ( Gossudarov ) then
12077: LD_EXP 38
12081: PPUSH
12082: CALL_OW 302
12086: IFFALSE 12102
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12088: LD_EXP 38
12092: PPUSH
12093: LD_STRING DAlieBaseNotReady-Gos-1
12095: PPUSH
12096: CALL_OW 88
12100: GO 12230
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12102: LD_ADDR_VAR 0 1
12106: PUSH
12107: LD_INT 22
12109: PUSH
12110: LD_INT 7
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PUSH
12117: LD_INT 23
12119: PUSH
12120: LD_INT 3
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: LD_INT 25
12129: PUSH
12130: LD_INT 4
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: PUSH
12137: LD_INT 21
12139: PUSH
12140: LD_INT 1
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_INT 26
12149: PUSH
12150: LD_INT 1
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PUSH
12157: EMPTY
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: LIST
12163: PPUSH
12164: CALL_OW 69
12168: PUSH
12169: LD_EXP 20
12173: PUSH
12174: LD_EXP 19
12178: PUSH
12179: LD_EXP 52
12183: PUSH
12184: LD_EXP 40
12188: PUSH
12189: LD_EXP 50
12193: PUSH
12194: LD_EXP 49
12198: PUSH
12199: EMPTY
12200: LIST
12201: LIST
12202: LIST
12203: LIST
12204: LIST
12205: LIST
12206: DIFF
12207: ST_TO_ADDR
// if speaker then
12208: LD_VAR 0 1
12212: IFFALSE 12230
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12214: LD_VAR 0 1
12218: PUSH
12219: LD_INT 1
12221: ARRAY
12222: PPUSH
12223: LD_STRING DAlieBaseNotReady-RSci1-1
12225: PPUSH
12226: CALL_OW 88
// end ; end ; end ;
12230: PPOPN 1
12232: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12233: LD_INT 24
12235: PPUSH
12236: LD_INT 7
12238: PPUSH
12239: CALL_OW 321
12243: PUSH
12244: LD_INT 2
12246: EQUAL
12247: IFFALSE 12938
12249: GO 12251
12251: DISABLE
12252: LD_INT 0
12254: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12255: LD_ADDR_VAR 0 1
12259: PUSH
12260: LD_INT 22
12262: PUSH
12263: LD_INT 7
12265: PUSH
12266: EMPTY
12267: LIST
12268: LIST
12269: PUSH
12270: LD_INT 23
12272: PUSH
12273: LD_INT 3
12275: PUSH
12276: EMPTY
12277: LIST
12278: LIST
12279: PUSH
12280: LD_INT 25
12282: PUSH
12283: LD_INT 4
12285: PUSH
12286: EMPTY
12287: LIST
12288: LIST
12289: PUSH
12290: LD_INT 21
12292: PUSH
12293: LD_INT 1
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: PUSH
12300: LD_INT 26
12302: PUSH
12303: LD_INT 1
12305: PUSH
12306: EMPTY
12307: LIST
12308: LIST
12309: PUSH
12310: EMPTY
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: PPUSH
12317: CALL_OW 69
12321: PUSH
12322: LD_EXP 20
12326: PUSH
12327: LD_EXP 19
12331: PUSH
12332: LD_EXP 52
12336: PUSH
12337: LD_EXP 40
12341: PUSH
12342: LD_EXP 50
12346: PUSH
12347: LD_EXP 49
12351: PUSH
12352: EMPTY
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: DIFF
12360: ST_TO_ADDR
// if not speaker then
12361: LD_VAR 0 1
12365: NOT
12366: IFFALSE 12370
// exit ;
12368: GO 12938
// DialogueOn ;
12370: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12374: LD_VAR 0 1
12378: PUSH
12379: LD_INT 1
12381: ARRAY
12382: PPUSH
12383: LD_STRING DArtefTechnology-RSci1-1
12385: PPUSH
12386: CALL_OW 88
// if IsOk ( Burlak ) then
12390: LD_EXP 52
12394: PPUSH
12395: CALL_OW 302
12399: IFFALSE 12413
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12401: LD_EXP 52
12405: PPUSH
12406: LD_STRING DArtefTechnology-Bur-1
12408: PPUSH
12409: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12413: LD_VAR 0 1
12417: PUSH
12418: LD_INT 1
12420: ARRAY
12421: PPUSH
12422: LD_STRING DArtefTechnology-RSci1-2
12424: PPUSH
12425: CALL_OW 88
// if Denis then
12429: LD_EXP 25
12433: IFFALSE 12450
// speaker := [ Denis ] else
12435: LD_ADDR_VAR 0 1
12439: PUSH
12440: LD_EXP 25
12444: PUSH
12445: EMPTY
12446: LIST
12447: ST_TO_ADDR
12448: GO 12556
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12450: LD_ADDR_VAR 0 1
12454: PUSH
12455: LD_INT 22
12457: PUSH
12458: LD_INT 7
12460: PUSH
12461: EMPTY
12462: LIST
12463: LIST
12464: PUSH
12465: LD_INT 23
12467: PUSH
12468: LD_INT 1
12470: PUSH
12471: EMPTY
12472: LIST
12473: LIST
12474: PUSH
12475: LD_INT 25
12477: PUSH
12478: LD_INT 4
12480: PUSH
12481: EMPTY
12482: LIST
12483: LIST
12484: PUSH
12485: LD_INT 21
12487: PUSH
12488: LD_INT 1
12490: PUSH
12491: EMPTY
12492: LIST
12493: LIST
12494: PUSH
12495: LD_INT 26
12497: PUSH
12498: LD_INT 1
12500: PUSH
12501: EMPTY
12502: LIST
12503: LIST
12504: PUSH
12505: EMPTY
12506: LIST
12507: LIST
12508: LIST
12509: LIST
12510: LIST
12511: PPUSH
12512: CALL_OW 69
12516: PUSH
12517: LD_EXP 20
12521: PUSH
12522: LD_EXP 19
12526: PUSH
12527: LD_EXP 52
12531: PUSH
12532: LD_EXP 40
12536: PUSH
12537: LD_EXP 50
12541: PUSH
12542: LD_EXP 49
12546: PUSH
12547: EMPTY
12548: LIST
12549: LIST
12550: LIST
12551: LIST
12552: LIST
12553: LIST
12554: DIFF
12555: ST_TO_ADDR
// if speaker then
12556: LD_VAR 0 1
12560: IFFALSE 12578
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12562: LD_VAR 0 1
12566: PUSH
12567: LD_INT 1
12569: ARRAY
12570: PPUSH
12571: LD_STRING DArtefTechnology-Sci1-2
12573: PPUSH
12574: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12578: LD_ADDR_VAR 0 1
12582: PUSH
12583: LD_INT 22
12585: PUSH
12586: LD_INT 7
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: PUSH
12593: LD_INT 23
12595: PUSH
12596: LD_INT 3
12598: PUSH
12599: EMPTY
12600: LIST
12601: LIST
12602: PUSH
12603: LD_INT 25
12605: PUSH
12606: LD_INT 4
12608: PUSH
12609: EMPTY
12610: LIST
12611: LIST
12612: PUSH
12613: LD_INT 21
12615: PUSH
12616: LD_INT 1
12618: PUSH
12619: EMPTY
12620: LIST
12621: LIST
12622: PUSH
12623: LD_INT 26
12625: PUSH
12626: LD_INT 1
12628: PUSH
12629: EMPTY
12630: LIST
12631: LIST
12632: PUSH
12633: EMPTY
12634: LIST
12635: LIST
12636: LIST
12637: LIST
12638: LIST
12639: PPUSH
12640: CALL_OW 69
12644: PUSH
12645: LD_EXP 20
12649: PUSH
12650: LD_EXP 19
12654: PUSH
12655: LD_EXP 52
12659: PUSH
12660: LD_EXP 40
12664: PUSH
12665: LD_EXP 50
12669: PUSH
12670: LD_EXP 49
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: DIFF
12683: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12684: LD_VAR 0 1
12688: PUSH
12689: LD_EXP 9
12693: PUSH
12694: LD_EXP 5
12698: OR
12699: AND
12700: IFFALSE 12934
// begin if arabianDestroyed and IsOk ( Burlak ) then
12702: LD_EXP 5
12706: PUSH
12707: LD_EXP 52
12711: PPUSH
12712: CALL_OW 302
12716: AND
12717: IFFALSE 12733
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12719: LD_EXP 52
12723: PPUSH
12724: LD_STRING DArtefTechnology-Bur-2
12726: PPUSH
12727: CALL_OW 88
12731: GO 12745
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12733: LD_EXP 19
12737: PPUSH
12738: LD_STRING DArtefTechnology-JMM-2
12740: PPUSH
12741: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12745: LD_VAR 0 1
12749: PUSH
12750: LD_INT 1
12752: ARRAY
12753: PPUSH
12754: LD_STRING DArtefTechnology-RSci1-3
12756: PPUSH
12757: CALL_OW 88
// if Denis then
12761: LD_EXP 25
12765: IFFALSE 12782
// speaker := [ Denis ] else
12767: LD_ADDR_VAR 0 1
12771: PUSH
12772: LD_EXP 25
12776: PUSH
12777: EMPTY
12778: LIST
12779: ST_TO_ADDR
12780: GO 12888
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12782: LD_ADDR_VAR 0 1
12786: PUSH
12787: LD_INT 22
12789: PUSH
12790: LD_INT 7
12792: PUSH
12793: EMPTY
12794: LIST
12795: LIST
12796: PUSH
12797: LD_INT 23
12799: PUSH
12800: LD_INT 1
12802: PUSH
12803: EMPTY
12804: LIST
12805: LIST
12806: PUSH
12807: LD_INT 25
12809: PUSH
12810: LD_INT 4
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: LD_INT 21
12819: PUSH
12820: LD_INT 1
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: PUSH
12827: LD_INT 26
12829: PUSH
12830: LD_INT 1
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: PPUSH
12844: CALL_OW 69
12848: PUSH
12849: LD_EXP 20
12853: PUSH
12854: LD_EXP 19
12858: PUSH
12859: LD_EXP 52
12863: PUSH
12864: LD_EXP 40
12868: PUSH
12869: LD_EXP 50
12873: PUSH
12874: LD_EXP 49
12878: PUSH
12879: EMPTY
12880: LIST
12881: LIST
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: DIFF
12887: ST_TO_ADDR
// if speaker then
12888: LD_VAR 0 1
12892: IFFALSE 12934
// if alienSpotted then
12894: LD_EXP 10
12898: IFFALSE 12918
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12900: LD_VAR 0 1
12904: PUSH
12905: LD_INT 1
12907: ARRAY
12908: PPUSH
12909: LD_STRING DArtefTechnology-Sci1-3
12911: PPUSH
12912: CALL_OW 88
12916: GO 12934
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12918: LD_VAR 0 1
12922: PUSH
12923: LD_INT 1
12925: ARRAY
12926: PPUSH
12927: LD_STRING DArtefTechnology-Sci1-3a
12929: PPUSH
12930: CALL_OW 88
// end ; DialogueOff ;
12934: CALL_OW 7
// end ;
12938: PPOPN 1
12940: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12941: LD_EXP 12
12945: IFFALSE 13148
12947: GO 12949
12949: DISABLE
12950: LD_INT 0
12952: PPUSH
// begin if Denis then
12953: LD_EXP 25
12957: IFFALSE 12974
// speaker := [ Denis ] else
12959: LD_ADDR_VAR 0 1
12963: PUSH
12964: LD_EXP 25
12968: PUSH
12969: EMPTY
12970: LIST
12971: ST_TO_ADDR
12972: GO 13080
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12974: LD_ADDR_VAR 0 1
12978: PUSH
12979: LD_INT 22
12981: PUSH
12982: LD_INT 7
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: PUSH
12989: LD_INT 23
12991: PUSH
12992: LD_INT 1
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: PUSH
12999: LD_INT 25
13001: PUSH
13002: LD_INT 4
13004: PUSH
13005: EMPTY
13006: LIST
13007: LIST
13008: PUSH
13009: LD_INT 21
13011: PUSH
13012: LD_INT 1
13014: PUSH
13015: EMPTY
13016: LIST
13017: LIST
13018: PUSH
13019: LD_INT 26
13021: PUSH
13022: LD_INT 1
13024: PUSH
13025: EMPTY
13026: LIST
13027: LIST
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: PPUSH
13036: CALL_OW 69
13040: PUSH
13041: LD_EXP 20
13045: PUSH
13046: LD_EXP 19
13050: PUSH
13051: LD_EXP 52
13055: PUSH
13056: LD_EXP 40
13060: PUSH
13061: LD_EXP 50
13065: PUSH
13066: LD_EXP 49
13070: PUSH
13071: EMPTY
13072: LIST
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: DIFF
13079: ST_TO_ADDR
// if not speaker then
13080: LD_VAR 0 1
13084: NOT
13085: IFFALSE 13089
// exit ;
13087: GO 13148
// DialogueOn ;
13089: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13093: LD_VAR 0 1
13097: PUSH
13098: LD_INT 1
13100: ARRAY
13101: PPUSH
13102: LD_STRING DArtefTechnologyAm-Sci1-1
13104: PPUSH
13105: CALL_OW 88
// if IsOk ( Burlak ) then
13109: LD_EXP 52
13113: PPUSH
13114: CALL_OW 302
13118: IFFALSE 13132
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13120: LD_EXP 52
13124: PPUSH
13125: LD_STRING DArtefTechnologyAm-Bur-1
13127: PPUSH
13128: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13132: LD_EXP 19
13136: PPUSH
13137: LD_STRING DArtefTechnologyAm-JMM-1
13139: PPUSH
13140: CALL_OW 88
// DialogueOff ;
13144: CALL_OW 7
// end ;
13148: PPOPN 1
13150: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13151: LD_EXP 13
13155: IFFALSE 13357
13157: GO 13159
13159: DISABLE
13160: LD_INT 0
13162: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13163: LD_ADDR_VAR 0 1
13167: PUSH
13168: LD_INT 22
13170: PUSH
13171: LD_INT 7
13173: PUSH
13174: EMPTY
13175: LIST
13176: LIST
13177: PUSH
13178: LD_INT 23
13180: PUSH
13181: LD_INT 3
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: PUSH
13188: LD_INT 25
13190: PUSH
13191: LD_INT 4
13193: PUSH
13194: EMPTY
13195: LIST
13196: LIST
13197: PUSH
13198: LD_INT 21
13200: PUSH
13201: LD_INT 1
13203: PUSH
13204: EMPTY
13205: LIST
13206: LIST
13207: PUSH
13208: LD_INT 26
13210: PUSH
13211: LD_INT 1
13213: PUSH
13214: EMPTY
13215: LIST
13216: LIST
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL_OW 69
13229: PUSH
13230: LD_EXP 20
13234: PUSH
13235: LD_EXP 19
13239: PUSH
13240: LD_EXP 52
13244: PUSH
13245: LD_EXP 40
13249: PUSH
13250: LD_EXP 50
13254: PUSH
13255: LD_EXP 49
13259: PUSH
13260: EMPTY
13261: LIST
13262: LIST
13263: LIST
13264: LIST
13265: LIST
13266: LIST
13267: DIFF
13268: ST_TO_ADDR
// if not speaker then
13269: LD_VAR 0 1
13273: NOT
13274: IFFALSE 13278
// exit ;
13276: GO 13357
// DialogueOn ;
13278: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13282: LD_VAR 0 1
13286: PUSH
13287: LD_VAR 0 1
13291: ARRAY
13292: PPUSH
13293: LD_STRING DArtefTechnologyRu-RSci1-1
13295: PPUSH
13296: CALL_OW 88
// if IsOk ( Burlak ) then
13300: LD_EXP 52
13304: PPUSH
13305: CALL_OW 302
13309: IFFALSE 13323
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13311: LD_EXP 52
13315: PPUSH
13316: LD_STRING DArtefTechnologyRu-Bur-1
13318: PPUSH
13319: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13323: LD_VAR 0 1
13327: PUSH
13328: LD_VAR 0 1
13332: ARRAY
13333: PPUSH
13334: LD_STRING DArtefTechnologyRu-RSci1-2
13336: PPUSH
13337: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13341: LD_EXP 19
13345: PPUSH
13346: LD_STRING DArtefTechnologyRu-JMM-1
13348: PPUSH
13349: CALL_OW 88
// DialogueOff ;
13353: CALL_OW 7
// end ;
13357: PPOPN 1
13359: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13360: LD_INT 24
13362: PPUSH
13363: LD_INT 7
13365: PPUSH
13366: CALL_OW 321
13370: PUSH
13371: LD_INT 2
13373: EQUAL
13374: PUSH
13375: LD_INT 1
13377: PPUSH
13378: CALL_OW 255
13382: PUSH
13383: LD_INT 7
13385: EQUAL
13386: AND
13387: IFFALSE 13555
13389: GO 13391
13391: DISABLE
13392: LD_INT 0
13394: PPUSH
// begin if Denis then
13395: LD_EXP 25
13399: IFFALSE 13416
// speaker := [ Denis ] else
13401: LD_ADDR_VAR 0 1
13405: PUSH
13406: LD_EXP 25
13410: PUSH
13411: EMPTY
13412: LIST
13413: ST_TO_ADDR
13414: GO 13522
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13416: LD_ADDR_VAR 0 1
13420: PUSH
13421: LD_INT 22
13423: PUSH
13424: LD_INT 7
13426: PUSH
13427: EMPTY
13428: LIST
13429: LIST
13430: PUSH
13431: LD_INT 23
13433: PUSH
13434: LD_INT 1
13436: PUSH
13437: EMPTY
13438: LIST
13439: LIST
13440: PUSH
13441: LD_INT 25
13443: PUSH
13444: LD_INT 4
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: PUSH
13451: LD_INT 21
13453: PUSH
13454: LD_INT 1
13456: PUSH
13457: EMPTY
13458: LIST
13459: LIST
13460: PUSH
13461: LD_INT 26
13463: PUSH
13464: LD_INT 1
13466: PUSH
13467: EMPTY
13468: LIST
13469: LIST
13470: PUSH
13471: EMPTY
13472: LIST
13473: LIST
13474: LIST
13475: LIST
13476: LIST
13477: PPUSH
13478: CALL_OW 69
13482: PUSH
13483: LD_EXP 20
13487: PUSH
13488: LD_EXP 19
13492: PUSH
13493: LD_EXP 52
13497: PUSH
13498: LD_EXP 40
13502: PUSH
13503: LD_EXP 50
13507: PUSH
13508: LD_EXP 49
13512: PUSH
13513: EMPTY
13514: LIST
13515: LIST
13516: LIST
13517: LIST
13518: LIST
13519: LIST
13520: DIFF
13521: ST_TO_ADDR
// if not speaker then
13522: LD_VAR 0 1
13526: NOT
13527: IFFALSE 13531
// exit ;
13529: GO 13555
// DialogueOn ;
13531: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13535: LD_VAR 0 1
13539: PUSH
13540: LD_INT 1
13542: ARRAY
13543: PPUSH
13544: LD_STRING DArtefTechnologyArStart-Sci1-1
13546: PPUSH
13547: CALL_OW 88
// DialogueOff ;
13551: CALL_OW 7
// end ;
13555: PPOPN 1
13557: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13558: LD_EXP 14
13562: IFFALSE 13843
13564: GO 13566
13566: DISABLE
13567: LD_INT 0
13569: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13570: LD_ADDR_VAR 0 1
13574: PUSH
13575: LD_INT 22
13577: PUSH
13578: LD_INT 7
13580: PUSH
13581: EMPTY
13582: LIST
13583: LIST
13584: PUSH
13585: LD_INT 23
13587: PUSH
13588: LD_INT 3
13590: PUSH
13591: EMPTY
13592: LIST
13593: LIST
13594: PUSH
13595: LD_INT 25
13597: PUSH
13598: LD_INT 4
13600: PUSH
13601: EMPTY
13602: LIST
13603: LIST
13604: PUSH
13605: LD_INT 21
13607: PUSH
13608: LD_INT 1
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PUSH
13615: LD_INT 26
13617: PUSH
13618: LD_INT 1
13620: PUSH
13621: EMPTY
13622: LIST
13623: LIST
13624: PUSH
13625: EMPTY
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: LIST
13631: PPUSH
13632: CALL_OW 69
13636: PUSH
13637: LD_EXP 20
13641: PUSH
13642: LD_EXP 19
13646: PUSH
13647: LD_EXP 52
13651: PUSH
13652: LD_EXP 40
13656: PUSH
13657: LD_EXP 50
13661: PUSH
13662: LD_EXP 49
13666: PUSH
13667: EMPTY
13668: LIST
13669: LIST
13670: LIST
13671: LIST
13672: LIST
13673: LIST
13674: DIFF
13675: ST_TO_ADDR
// if not speaker then
13676: LD_VAR 0 1
13680: NOT
13681: IFFALSE 13685
// exit ;
13683: GO 13843
// DialogueOn ;
13685: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13689: LD_VAR 0 1
13693: PUSH
13694: LD_INT 1
13696: ARRAY
13697: PPUSH
13698: LD_STRING DArtefTechnologyAr-RSci1-1
13700: PPUSH
13701: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13705: LD_EXP 19
13709: PPUSH
13710: LD_STRING DArtefTechnologyAr-JMM-1
13712: PPUSH
13713: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13717: LD_VAR 0 1
13721: PUSH
13722: LD_INT 1
13724: ARRAY
13725: PPUSH
13726: LD_STRING DArtefTechnologyAr-RSci1-2
13728: PPUSH
13729: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13733: LD_EXP 19
13737: PPUSH
13738: LD_STRING DArtefTechnologyAr-JMM-2
13740: PPUSH
13741: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13745: LD_VAR 0 1
13749: PUSH
13750: LD_INT 1
13752: ARRAY
13753: PPUSH
13754: LD_STRING DArtefTechnologyAr-RSci1-3
13756: PPUSH
13757: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13761: LD_EXP 19
13765: PPUSH
13766: LD_STRING DArtefTechnologyAr-JMM-3
13768: PPUSH
13769: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13773: LD_VAR 0 1
13777: PUSH
13778: LD_INT 1
13780: ARRAY
13781: PPUSH
13782: LD_STRING DArtefTechnologyAr-RSci1-4
13784: PPUSH
13785: CALL_OW 88
// if IsOk ( Burlak ) then
13789: LD_EXP 52
13793: PPUSH
13794: CALL_OW 302
13798: IFFALSE 13812
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13800: LD_EXP 52
13804: PPUSH
13805: LD_STRING DArtefTechnologyAr-Bur-4
13807: PPUSH
13808: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13812: LD_EXP 19
13816: PPUSH
13817: LD_STRING DArtefTechnologyAr-JMM-4
13819: PPUSH
13820: CALL_OW 88
// DialogueOff ;
13824: CALL_OW 7
// wait ( 0 0$45 ) ;
13828: LD_INT 1575
13830: PPUSH
13831: CALL_OW 67
// spawnOmar := true ;
13835: LD_ADDR_EXP 11
13839: PUSH
13840: LD_INT 1
13842: ST_TO_ADDR
// end ;
13843: PPOPN 1
13845: END
// every 0 0$1 trigger spawnOmar do
13846: LD_EXP 11
13850: IFFALSE 14230
13852: GO 13854
13854: DISABLE
// begin PrepareOmarAli ;
13855: CALL 7236 0 0
// if not HasTask ( Omar ) then
13859: LD_EXP 56
13863: PPUSH
13864: CALL_OW 314
13868: NOT
13869: IFFALSE 13886
// ComMoveXY ( Omar , 252 , 220 ) ;
13871: LD_EXP 56
13875: PPUSH
13876: LD_INT 252
13878: PPUSH
13879: LD_INT 220
13881: PPUSH
13882: CALL_OW 111
// if not Omar then
13886: LD_EXP 56
13890: NOT
13891: IFFALSE 13895
// exit ;
13893: GO 14230
// repeat wait ( 0 0$1 ) ;
13895: LD_INT 35
13897: PPUSH
13898: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13902: LD_EXP 56
13906: PPUSH
13907: CALL_OW 314
13911: NOT
13912: PUSH
13913: LD_EXP 56
13917: PPUSH
13918: LD_INT 252
13920: PPUSH
13921: LD_INT 220
13923: PPUSH
13924: CALL_OW 297
13928: PUSH
13929: LD_INT 6
13931: GREATER
13932: AND
13933: IFFALSE 13950
// ComMoveXY ( Omar , 252 , 220 ) ;
13935: LD_EXP 56
13939: PPUSH
13940: LD_INT 252
13942: PPUSH
13943: LD_INT 220
13945: PPUSH
13946: CALL_OW 111
// until See ( 7 , Omar ) ;
13950: LD_INT 7
13952: PPUSH
13953: LD_EXP 56
13957: PPUSH
13958: CALL_OW 292
13962: IFFALSE 13895
// CenterNowOnUnits ( Omar ) ;
13964: LD_EXP 56
13968: PPUSH
13969: CALL_OW 87
// DialogueOn ;
13973: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13977: LD_EXP 56
13981: PPUSH
13982: LD_STRING DOmar-Omar-1
13984: PPUSH
13985: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13989: LD_EXP 19
13993: PPUSH
13994: LD_STRING DOmar-JMM-1
13996: PPUSH
13997: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14001: LD_EXP 56
14005: PPUSH
14006: LD_STRING DOmar-Omar-2
14008: PPUSH
14009: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14013: LD_EXP 19
14017: PPUSH
14018: LD_STRING DOmar-JMM-2
14020: PPUSH
14021: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14025: LD_EXP 56
14029: PPUSH
14030: LD_STRING DOmar-Omar-3
14032: PPUSH
14033: CALL_OW 88
// if IsOk ( Burlak ) then
14037: LD_EXP 52
14041: PPUSH
14042: CALL_OW 302
14046: IFFALSE 14062
// Say ( Burlak , DOmar-Bur-3 ) else
14048: LD_EXP 52
14052: PPUSH
14053: LD_STRING DOmar-Bur-3
14055: PPUSH
14056: CALL_OW 88
14060: GO 14074
// Say ( JMM , DOmar-JMM-3 ) ;
14062: LD_EXP 19
14066: PPUSH
14067: LD_STRING DOmar-JMM-3
14069: PPUSH
14070: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14074: LD_EXP 56
14078: PPUSH
14079: LD_STRING DOmar-Omar-4
14081: PPUSH
14082: CALL_OW 88
// case Query ( QAccept ) of 1 :
14086: LD_STRING QAccept
14088: PPUSH
14089: CALL_OW 97
14093: PUSH
14094: LD_INT 1
14096: DOUBLE
14097: EQUAL
14098: IFTRUE 14102
14100: GO 14138
14102: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14103: LD_EXP 19
14107: PPUSH
14108: LD_STRING DQrAccept#1-JMM-1
14110: PPUSH
14111: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14115: LD_EXP 56
14119: PPUSH
14120: LD_INT 7
14122: PPUSH
14123: CALL_OW 235
// ComStop ( Omar ) ;
14127: LD_EXP 56
14131: PPUSH
14132: CALL_OW 141
// end ; 2 :
14136: GO 14187
14138: LD_INT 2
14140: DOUBLE
14141: EQUAL
14142: IFTRUE 14146
14144: GO 14186
14146: POP
// begin if IsOk ( Burlak ) then
14147: LD_EXP 52
14151: PPUSH
14152: CALL_OW 302
14156: IFFALSE 14172
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14158: LD_EXP 52
14162: PPUSH
14163: LD_STRING DQrAccept#2-Bur-1
14165: PPUSH
14166: CALL_OW 88
14170: GO 14184
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14172: LD_EXP 19
14176: PPUSH
14177: LD_STRING DQrAccept#2-JMM-1
14179: PPUSH
14180: CALL_OW 88
// end ; end ;
14184: GO 14187
14186: POP
// DialogueOff ;
14187: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14191: LD_EXP 56
14195: PPUSH
14196: CALL_OW 255
14200: PUSH
14201: LD_INT 7
14203: EQUAL
14204: IFFALSE 14215
// begin SetAchievement ( ACH_OMAR ) ;
14206: LD_STRING ACH_OMAR
14208: PPUSH
14209: CALL_OW 543
// exit ;
14213: GO 14230
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14215: LD_EXP 56
14219: PPUSH
14220: LD_INT 202
14222: PPUSH
14223: LD_INT 115
14225: PPUSH
14226: CALL_OW 111
// end ;
14230: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
14231: LD_EXP 56
14235: PPUSH
14236: LD_INT 200
14238: PPUSH
14239: LD_INT 98
14241: PPUSH
14242: CALL_OW 297
14246: PUSH
14247: LD_INT 40
14249: LESS
14250: PUSH
14251: LD_EXP 2
14255: AND
14256: IFFALSE 14474
14258: GO 14260
14260: DISABLE
// begin SetSide ( Omar , 5 ) ;
14261: LD_EXP 56
14265: PPUSH
14266: LD_INT 5
14268: PPUSH
14269: CALL_OW 235
// if IsInUnit ( Omar ) then
14273: LD_EXP 56
14277: PPUSH
14278: CALL_OW 310
14282: IFFALSE 14293
// ComExitVehicle ( Omar ) ;
14284: LD_EXP 56
14288: PPUSH
14289: CALL_OW 121
// if IsInUnit ( Omar ) then
14293: LD_EXP 56
14297: PPUSH
14298: CALL_OW 310
14302: IFFALSE 14313
// ComExitBuilding ( Omar ) ;
14304: LD_EXP 56
14308: PPUSH
14309: CALL_OW 122
// wait ( 0 0$1 ) ;
14313: LD_INT 35
14315: PPUSH
14316: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14320: LD_EXP 56
14324: PPUSH
14325: LD_INT 203
14327: PPUSH
14328: LD_INT 120
14330: PPUSH
14331: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14335: LD_INT 35
14337: PPUSH
14338: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
14342: LD_EXP 56
14346: PPUSH
14347: CALL_OW 306
14351: PUSH
14352: LD_EXP 56
14356: PPUSH
14357: LD_INT 203
14359: PPUSH
14360: LD_INT 120
14362: PPUSH
14363: CALL_OW 297
14367: PUSH
14368: LD_INT 6
14370: LESS
14371: OR
14372: IFFALSE 14335
// CenterNowOnUnits ( Omar ) ;
14374: LD_EXP 56
14378: PPUSH
14379: CALL_OW 87
// DialogueOn ;
14383: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
14387: LD_EXP 19
14391: PPUSH
14392: LD_STRING DOmarContam-JMM-1
14394: PPUSH
14395: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14399: LD_EXP 56
14403: PPUSH
14404: LD_STRING DOmarContam-Omar-1
14406: PPUSH
14407: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14411: LD_EXP 19
14415: PPUSH
14416: LD_STRING DOmarContam-JMM-2
14418: PPUSH
14419: CALL_OW 88
// DialogueOff ;
14423: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14427: LD_INT 5
14429: PPUSH
14430: LD_INT 7
14432: PPUSH
14433: LD_INT 2
14435: PPUSH
14436: LD_INT 1
14438: PPUSH
14439: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14443: LD_INT 105
14445: PPUSH
14446: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
14450: LD_EXP 56
14454: PPUSH
14455: LD_INT 203
14457: PPUSH
14458: LD_INT 120
14460: PPUSH
14461: CALL_OW 307
14465: IFFALSE 14443
// YouLost ( MothContaminate ) ;
14467: LD_STRING MothContaminate
14469: PPUSH
14470: CALL_OW 104
// end ;
14474: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
14475: LD_EXP 4
14479: NOT
14480: PUSH
14481: LD_INT 22
14483: PUSH
14484: LD_INT 1
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: LD_INT 34
14493: PUSH
14494: LD_INT 8
14496: PUSH
14497: EMPTY
14498: LIST
14499: LIST
14500: PUSH
14501: EMPTY
14502: LIST
14503: LIST
14504: PPUSH
14505: CALL_OW 69
14509: AND
14510: IFFALSE 14629
14512: GO 14514
14514: DISABLE
// begin wait ( 0 0$5 ) ;
14515: LD_INT 175
14517: PPUSH
14518: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
14522: LD_EXP 55
14526: PPUSH
14527: CALL_OW 302
14531: NOT
14532: PUSH
14533: LD_INT 22
14535: PUSH
14536: LD_INT 1
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: PUSH
14543: LD_INT 34
14545: PUSH
14546: LD_INT 8
14548: PUSH
14549: EMPTY
14550: LIST
14551: LIST
14552: PUSH
14553: EMPTY
14554: LIST
14555: LIST
14556: PPUSH
14557: CALL_OW 69
14561: NOT
14562: OR
14563: IFFALSE 14567
// exit ;
14565: GO 14629
// DialogueOn ;
14567: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14571: LD_EXP 55
14575: PPUSH
14576: LD_STRING DWinAmericans-Pow-1
14578: PPUSH
14579: CALL_OW 94
// if IsOk ( Burlak ) then
14583: LD_EXP 52
14587: PPUSH
14588: CALL_OW 302
14592: IFFALSE 14606
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14594: LD_EXP 52
14598: PPUSH
14599: LD_STRING DWinAmericans-Bur-1
14601: PPUSH
14602: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14606: LD_EXP 19
14610: PPUSH
14611: LD_STRING DWinAmericans-JMM-1
14613: PPUSH
14614: CALL_OW 88
// DialogueOff ;
14618: CALL_OW 7
// YouLost ( AmBomb ) ;
14622: LD_STRING AmBomb
14624: PPUSH
14625: CALL_OW 104
// end ;
14629: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14630: LD_EXP 2
14634: NOT
14635: PUSH
14636: LD_INT 22
14638: PUSH
14639: LD_INT 3
14641: PUSH
14642: EMPTY
14643: LIST
14644: LIST
14645: PUSH
14646: LD_INT 34
14648: PUSH
14649: LD_INT 48
14651: PUSH
14652: EMPTY
14653: LIST
14654: LIST
14655: PUSH
14656: EMPTY
14657: LIST
14658: LIST
14659: PPUSH
14660: CALL_OW 69
14664: AND
14665: IFFALSE 14784
14667: GO 14669
14669: DISABLE
// begin wait ( 0 0$5 ) ;
14670: LD_INT 175
14672: PPUSH
14673: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14677: LD_EXP 59
14681: PPUSH
14682: CALL_OW 302
14686: NOT
14687: PUSH
14688: LD_INT 22
14690: PUSH
14691: LD_INT 3
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PUSH
14698: LD_INT 34
14700: PUSH
14701: LD_INT 48
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: PUSH
14708: EMPTY
14709: LIST
14710: LIST
14711: PPUSH
14712: CALL_OW 69
14716: NOT
14717: OR
14718: IFFALSE 14722
// exit ;
14720: GO 14784
// DialogueOn ;
14722: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14726: LD_EXP 59
14730: PPUSH
14731: LD_STRING DWinRussians-Pla-1
14733: PPUSH
14734: CALL_OW 94
// if IsOk ( Burlak ) then
14738: LD_EXP 52
14742: PPUSH
14743: CALL_OW 302
14747: IFFALSE 14761
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14749: LD_EXP 52
14753: PPUSH
14754: LD_STRING DWinRussians-Bur-1
14756: PPUSH
14757: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14761: LD_EXP 19
14765: PPUSH
14766: LD_STRING DWinRussians-JMM-1
14768: PPUSH
14769: CALL_OW 88
// DialogueOff ;
14773: CALL_OW 7
// YouLost ( RuBomb ) ;
14777: LD_STRING RuBomb
14779: PPUSH
14780: CALL_OW 104
// end ;
14784: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14785: LD_INT 7
14787: PPUSH
14788: LD_INT 22
14790: PUSH
14791: LD_INT 7
14793: PUSH
14794: EMPTY
14795: LIST
14796: LIST
14797: PPUSH
14798: CALL_OW 70
14802: PUSH
14803: LD_EXP 4
14807: NOT
14808: AND
14809: IFFALSE 14838
14811: GO 14813
14813: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14814: LD_EXP 55
14818: PPUSH
14819: LD_STRING DSurrenderAmericans-Pow-1
14821: PPUSH
14822: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14826: LD_EXP 19
14830: PPUSH
14831: LD_STRING DSurrenderAmericans-JMM-1
14833: PPUSH
14834: CALL_OW 88
// end ;
14838: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14839: LD_INT 2
14841: PPUSH
14842: LD_INT 22
14844: PUSH
14845: LD_INT 7
14847: PUSH
14848: EMPTY
14849: LIST
14850: LIST
14851: PPUSH
14852: CALL_OW 70
14856: PUSH
14857: LD_EXP 2
14861: NOT
14862: AND
14863: PUSH
14864: LD_EXP 52
14868: AND
14869: IFFALSE 14898
14871: GO 14873
14873: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14874: LD_EXP 59
14878: PPUSH
14879: LD_STRING DSurrenderRussians-Pla-1
14881: PPUSH
14882: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14886: LD_EXP 52
14890: PPUSH
14891: LD_STRING DSurrenderRussians-Bur-1
14893: PPUSH
14894: CALL_OW 88
// end ;
14898: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14899: LD_EXP 4
14903: IFFALSE 15286
14905: GO 14907
14907: DISABLE
14908: LD_INT 0
14910: PPUSH
14911: PPUSH
14912: PPUSH
// begin MC_Kill ( 4 ) ;
14913: LD_INT 4
14915: PPUSH
14916: CALL 21536 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14920: LD_INT 1
14922: PPUSH
14923: LD_INT 7
14925: PPUSH
14926: LD_INT 1
14928: PPUSH
14929: LD_INT 1
14931: PPUSH
14932: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14936: LD_ADDR_VAR 0 3
14940: PUSH
14941: LD_INT 22
14943: PUSH
14944: LD_INT 1
14946: PUSH
14947: EMPTY
14948: LIST
14949: LIST
14950: PUSH
14951: LD_INT 26
14953: PUSH
14954: LD_INT 1
14956: PUSH
14957: EMPTY
14958: LIST
14959: LIST
14960: PUSH
14961: LD_INT 23
14963: PUSH
14964: LD_INT 1
14966: PUSH
14967: EMPTY
14968: LIST
14969: LIST
14970: PUSH
14971: EMPTY
14972: LIST
14973: LIST
14974: LIST
14975: PPUSH
14976: CALL_OW 69
14980: PUSH
14981: LD_EXP 55
14985: PUSH
14986: LD_EXP 27
14990: PUSH
14991: LD_EXP 24
14995: PUSH
14996: LD_EXP 23
15000: PUSH
15001: LD_EXP 30
15005: PUSH
15006: LD_EXP 28
15010: PUSH
15011: EMPTY
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: DIFF
15019: ST_TO_ADDR
// if speaker then
15020: LD_VAR 0 3
15024: IFFALSE 15050
// begin DialogueOn ;
15026: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
15030: LD_VAR 0 3
15034: PUSH
15035: LD_INT 1
15037: ARRAY
15038: PPUSH
15039: LD_STRING DSurrenderAmericans-Sol1-1a
15041: PPUSH
15042: CALL_OW 94
// DialogueOff ;
15046: CALL_OW 7
// end ; americanCapitulated := true ;
15050: LD_ADDR_EXP 6
15054: PUSH
15055: LD_INT 1
15057: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15058: LD_ADDR_VAR 0 2
15062: PUSH
15063: LD_INT 22
15065: PUSH
15066: LD_INT 1
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: PUSH
15073: LD_INT 21
15075: PUSH
15076: LD_INT 1
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: PPUSH
15087: CALL_OW 69
15091: PUSH
15092: LD_INT 22
15094: PUSH
15095: LD_INT 1
15097: PUSH
15098: EMPTY
15099: LIST
15100: LIST
15101: PUSH
15102: LD_INT 21
15104: PUSH
15105: LD_INT 2
15107: PUSH
15108: EMPTY
15109: LIST
15110: LIST
15111: PUSH
15112: LD_INT 1
15114: PUSH
15115: EMPTY
15116: LIST
15117: PUSH
15118: EMPTY
15119: LIST
15120: LIST
15121: LIST
15122: PPUSH
15123: CALL_OW 69
15127: ADD
15128: ST_TO_ADDR
// if tmp then
15129: LD_VAR 0 2
15133: IFFALSE 15286
// repeat wait ( 0 0$1 ) ;
15135: LD_INT 35
15137: PPUSH
15138: CALL_OW 67
// for i in tmp do
15142: LD_ADDR_VAR 0 1
15146: PUSH
15147: LD_VAR 0 2
15151: PUSH
15152: FOR_IN
15153: IFFALSE 15235
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15155: LD_VAR 0 1
15159: PPUSH
15160: CALL_OW 310
15164: PUSH
15165: LD_VAR 0 1
15169: PPUSH
15170: CALL_OW 310
15174: PPUSH
15175: CALL_OW 247
15179: PUSH
15180: LD_INT 3
15182: EQUAL
15183: AND
15184: IFFALSE 15195
// ComExitBuilding ( i ) ;
15186: LD_VAR 0 1
15190: PPUSH
15191: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15195: LD_VAR 0 1
15199: PPUSH
15200: LD_INT 122
15202: PPUSH
15203: LD_INT 242
15205: PPUSH
15206: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15210: LD_VAR 0 1
15214: PPUSH
15215: LD_INT 35
15217: PPUSH
15218: CALL_OW 308
15222: IFFALSE 15233
// RemoveUnit ( i ) ;
15224: LD_VAR 0 1
15228: PPUSH
15229: CALL_OW 64
// end ;
15233: GO 15152
15235: POP
15236: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15237: LD_INT 22
15239: PUSH
15240: LD_INT 1
15242: PUSH
15243: EMPTY
15244: LIST
15245: LIST
15246: PUSH
15247: LD_INT 2
15249: PUSH
15250: LD_INT 21
15252: PUSH
15253: LD_INT 1
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: PUSH
15260: LD_INT 33
15262: PUSH
15263: LD_INT 1
15265: PUSH
15266: EMPTY
15267: LIST
15268: LIST
15269: PUSH
15270: EMPTY
15271: LIST
15272: LIST
15273: LIST
15274: PUSH
15275: EMPTY
15276: LIST
15277: LIST
15278: PPUSH
15279: CALL_OW 69
15283: NOT
15284: IFFALSE 15135
// end ;
15286: PPOPN 3
15288: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15289: LD_EXP 2
15293: IFFALSE 15694
15295: GO 15297
15297: DISABLE
15298: LD_INT 0
15300: PPUSH
15301: PPUSH
15302: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15303: LD_INT 35
15305: PPUSH
15306: CALL_OW 67
// until IsDead ( Yakotich ) ;
15310: LD_EXP 60
15314: PPUSH
15315: CALL_OW 301
15319: IFFALSE 15303
// MC_Kill ( 2 ) ;
15321: LD_INT 2
15323: PPUSH
15324: CALL 21536 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15328: LD_INT 3
15330: PPUSH
15331: LD_INT 7
15333: PPUSH
15334: LD_INT 1
15336: PPUSH
15337: LD_INT 1
15339: PPUSH
15340: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
15344: LD_ADDR_VAR 0 3
15348: PUSH
15349: LD_INT 22
15351: PUSH
15352: LD_INT 3
15354: PUSH
15355: EMPTY
15356: LIST
15357: LIST
15358: PUSH
15359: LD_INT 26
15361: PUSH
15362: LD_INT 1
15364: PUSH
15365: EMPTY
15366: LIST
15367: LIST
15368: PUSH
15369: LD_INT 23
15371: PUSH
15372: LD_INT 3
15374: PUSH
15375: EMPTY
15376: LIST
15377: LIST
15378: PUSH
15379: EMPTY
15380: LIST
15381: LIST
15382: LIST
15383: PPUSH
15384: CALL_OW 69
15388: PUSH
15389: LD_EXP 59
15393: PUSH
15394: LD_EXP 60
15398: PUSH
15399: EMPTY
15400: LIST
15401: LIST
15402: DIFF
15403: ST_TO_ADDR
// if speaker then
15404: LD_VAR 0 3
15408: IFFALSE 15458
// begin DialogueOn ;
15410: CALL_OW 6
// if Burlak then
15414: LD_EXP 52
15418: IFFALSE 15438
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
15420: LD_VAR 0 3
15424: PUSH
15425: LD_INT 1
15427: ARRAY
15428: PPUSH
15429: LD_STRING DSurrenderRussians-RSol1-1
15431: PPUSH
15432: CALL_OW 94
15436: GO 15454
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
15438: LD_VAR 0 3
15442: PUSH
15443: LD_INT 1
15445: ARRAY
15446: PPUSH
15447: LD_STRING DSurrenderRussians-RSol1-1a
15449: PPUSH
15450: CALL_OW 94
// DialogueOff ;
15454: CALL_OW 7
// end ; russianCapitulated := true ;
15458: LD_ADDR_EXP 7
15462: PUSH
15463: LD_INT 1
15465: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15466: LD_ADDR_VAR 0 2
15470: PUSH
15471: LD_INT 22
15473: PUSH
15474: LD_INT 3
15476: PUSH
15477: EMPTY
15478: LIST
15479: LIST
15480: PUSH
15481: LD_INT 21
15483: PUSH
15484: LD_INT 1
15486: PUSH
15487: EMPTY
15488: LIST
15489: LIST
15490: PUSH
15491: EMPTY
15492: LIST
15493: LIST
15494: PPUSH
15495: CALL_OW 69
15499: PUSH
15500: LD_INT 22
15502: PUSH
15503: LD_INT 3
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 21
15512: PUSH
15513: LD_INT 2
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 1
15522: PUSH
15523: EMPTY
15524: LIST
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: LIST
15530: PPUSH
15531: CALL_OW 69
15535: ADD
15536: ST_TO_ADDR
// if tmp then
15537: LD_VAR 0 2
15541: IFFALSE 15694
// repeat wait ( 0 0$1 ) ;
15543: LD_INT 35
15545: PPUSH
15546: CALL_OW 67
// for i in tmp do
15550: LD_ADDR_VAR 0 1
15554: PUSH
15555: LD_VAR 0 2
15559: PUSH
15560: FOR_IN
15561: IFFALSE 15643
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15563: LD_VAR 0 1
15567: PPUSH
15568: CALL_OW 310
15572: PUSH
15573: LD_VAR 0 1
15577: PPUSH
15578: CALL_OW 310
15582: PPUSH
15583: CALL_OW 247
15587: PUSH
15588: LD_INT 3
15590: EQUAL
15591: AND
15592: IFFALSE 15603
// ComExitBuilding ( i ) ;
15594: LD_VAR 0 1
15598: PPUSH
15599: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15603: LD_VAR 0 1
15607: PPUSH
15608: LD_INT 154
15610: PPUSH
15611: LD_INT 1
15613: PPUSH
15614: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15618: LD_VAR 0 1
15622: PPUSH
15623: LD_INT 36
15625: PPUSH
15626: CALL_OW 308
15630: IFFALSE 15641
// RemoveUnit ( i ) ;
15632: LD_VAR 0 1
15636: PPUSH
15637: CALL_OW 64
// end ;
15641: GO 15560
15643: POP
15644: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15645: LD_INT 22
15647: PUSH
15648: LD_INT 3
15650: PUSH
15651: EMPTY
15652: LIST
15653: LIST
15654: PUSH
15655: LD_INT 2
15657: PUSH
15658: LD_INT 21
15660: PUSH
15661: LD_INT 1
15663: PUSH
15664: EMPTY
15665: LIST
15666: LIST
15667: PUSH
15668: LD_INT 33
15670: PUSH
15671: LD_INT 1
15673: PUSH
15674: EMPTY
15675: LIST
15676: LIST
15677: PUSH
15678: EMPTY
15679: LIST
15680: LIST
15681: LIST
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: PPUSH
15687: CALL_OW 69
15691: NOT
15692: IFFALSE 15543
// end ;
15694: PPOPN 3
15696: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15697: LD_INT 22
15699: PUSH
15700: LD_INT 8
15702: PUSH
15703: EMPTY
15704: LIST
15705: LIST
15706: PUSH
15707: LD_INT 21
15709: PUSH
15710: LD_INT 1
15712: PUSH
15713: EMPTY
15714: LIST
15715: LIST
15716: PUSH
15717: LD_INT 23
15719: PUSH
15720: LD_INT 2
15722: PUSH
15723: EMPTY
15724: LIST
15725: LIST
15726: PUSH
15727: EMPTY
15728: LIST
15729: LIST
15730: LIST
15731: PPUSH
15732: CALL_OW 69
15736: PUSH
15737: LD_INT 18
15739: LESS
15740: PUSH
15741: LD_EXP 58
15745: PPUSH
15746: CALL_OW 301
15750: OR
15751: PUSH
15752: LD_INT 324
15754: PPUSH
15755: CALL_OW 255
15759: PUSH
15760: LD_INT 7
15762: EQUAL
15763: OR
15764: IFFALSE 15777
15766: GO 15768
15768: DISABLE
// legionDestroyed := true ;
15769: LD_ADDR_EXP 3
15773: PUSH
15774: LD_INT 1
15776: ST_TO_ADDR
15777: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15778: LD_INT 22
15780: PUSH
15781: LD_INT 2
15783: PUSH
15784: EMPTY
15785: LIST
15786: LIST
15787: PUSH
15788: LD_INT 21
15790: PUSH
15791: LD_INT 1
15793: PUSH
15794: EMPTY
15795: LIST
15796: LIST
15797: PUSH
15798: LD_INT 23
15800: PUSH
15801: LD_INT 2
15803: PUSH
15804: EMPTY
15805: LIST
15806: LIST
15807: PUSH
15808: EMPTY
15809: LIST
15810: LIST
15811: LIST
15812: PPUSH
15813: CALL_OW 69
15817: PUSH
15818: LD_INT 9
15820: LESS
15821: IFFALSE 15834
15823: GO 15825
15825: DISABLE
// arabianDestroyed := true ;
15826: LD_ADDR_EXP 5
15830: PUSH
15831: LD_INT 1
15833: ST_TO_ADDR
15834: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15835: LD_EXP 5
15839: IFFALSE 16083
15841: GO 15843
15843: DISABLE
15844: LD_INT 0
15846: PPUSH
15847: PPUSH
// begin MC_Kill ( 1 ) ;
15848: LD_INT 1
15850: PPUSH
15851: CALL 21536 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15855: LD_ADDR_VAR 0 2
15859: PUSH
15860: LD_INT 22
15862: PUSH
15863: LD_INT 2
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PUSH
15870: LD_INT 21
15872: PUSH
15873: LD_INT 1
15875: PUSH
15876: EMPTY
15877: LIST
15878: LIST
15879: PUSH
15880: EMPTY
15881: LIST
15882: LIST
15883: PPUSH
15884: CALL_OW 69
15888: PUSH
15889: LD_INT 22
15891: PUSH
15892: LD_INT 8
15894: PUSH
15895: EMPTY
15896: LIST
15897: LIST
15898: PUSH
15899: LD_INT 21
15901: PUSH
15902: LD_INT 2
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: PUSH
15909: LD_INT 1
15911: PUSH
15912: EMPTY
15913: LIST
15914: PUSH
15915: EMPTY
15916: LIST
15917: LIST
15918: LIST
15919: PPUSH
15920: CALL_OW 69
15924: ADD
15925: ST_TO_ADDR
// if tmp then
15926: LD_VAR 0 2
15930: IFFALSE 16083
// repeat wait ( 0 0$1 ) ;
15932: LD_INT 35
15934: PPUSH
15935: CALL_OW 67
// for i in tmp do
15939: LD_ADDR_VAR 0 1
15943: PUSH
15944: LD_VAR 0 2
15948: PUSH
15949: FOR_IN
15950: IFFALSE 16032
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15952: LD_VAR 0 1
15956: PPUSH
15957: CALL_OW 310
15961: PUSH
15962: LD_VAR 0 1
15966: PPUSH
15967: CALL_OW 310
15971: PPUSH
15972: CALL_OW 247
15976: PUSH
15977: LD_INT 3
15979: EQUAL
15980: AND
15981: IFFALSE 15992
// ComExitBuilding ( i ) ;
15983: LD_VAR 0 1
15987: PPUSH
15988: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15992: LD_VAR 0 1
15996: PPUSH
15997: LD_INT 254
15999: PPUSH
16000: LD_INT 268
16002: PPUSH
16003: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
16007: LD_VAR 0 1
16011: PPUSH
16012: LD_INT 34
16014: PPUSH
16015: CALL_OW 308
16019: IFFALSE 16030
// RemoveUnit ( i ) ;
16021: LD_VAR 0 1
16025: PPUSH
16026: CALL_OW 64
// end ;
16030: GO 15949
16032: POP
16033: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16034: LD_INT 22
16036: PUSH
16037: LD_INT 2
16039: PUSH
16040: EMPTY
16041: LIST
16042: LIST
16043: PUSH
16044: LD_INT 2
16046: PUSH
16047: LD_INT 21
16049: PUSH
16050: LD_INT 1
16052: PUSH
16053: EMPTY
16054: LIST
16055: LIST
16056: PUSH
16057: LD_INT 33
16059: PUSH
16060: LD_INT 1
16062: PUSH
16063: EMPTY
16064: LIST
16065: LIST
16066: PUSH
16067: EMPTY
16068: LIST
16069: LIST
16070: LIST
16071: PUSH
16072: EMPTY
16073: LIST
16074: LIST
16075: PPUSH
16076: CALL_OW 69
16080: NOT
16081: IFFALSE 15932
// end ;
16083: PPOPN 2
16085: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16086: LD_EXP 3
16090: IFFALSE 16442
16092: GO 16094
16094: DISABLE
16095: LD_INT 0
16097: PPUSH
16098: PPUSH
// begin MC_Kill ( 3 ) ;
16099: LD_INT 3
16101: PPUSH
16102: CALL 21536 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16106: LD_INT 8
16108: PPUSH
16109: LD_INT 7
16111: PPUSH
16112: LD_INT 1
16114: PPUSH
16115: LD_INT 1
16117: PPUSH
16118: CALL_OW 80
// DialogueOn ;
16122: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16126: LD_EXP 57
16130: PPUSH
16131: LD_STRING D15-Szulc-1
16133: PPUSH
16134: CALL_OW 94
// DialogueOff ;
16138: CALL_OW 7
// legionCapitulated := true ;
16142: LD_ADDR_EXP 8
16146: PUSH
16147: LD_INT 1
16149: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16150: LD_ADDR_VAR 0 1
16154: PUSH
16155: LD_INT 22
16157: PUSH
16158: LD_INT 8
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PUSH
16165: LD_INT 21
16167: PUSH
16168: LD_INT 3
16170: PUSH
16171: EMPTY
16172: LIST
16173: LIST
16174: PUSH
16175: LD_INT 23
16177: PUSH
16178: LD_INT 3
16180: PUSH
16181: EMPTY
16182: LIST
16183: LIST
16184: PUSH
16185: EMPTY
16186: LIST
16187: LIST
16188: LIST
16189: PPUSH
16190: CALL_OW 69
16194: PUSH
16195: FOR_IN
16196: IFFALSE 16212
// SetLives ( i , 3 ) ;
16198: LD_VAR 0 1
16202: PPUSH
16203: LD_INT 3
16205: PPUSH
16206: CALL_OW 234
16210: GO 16195
16212: POP
16213: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16214: LD_ADDR_VAR 0 2
16218: PUSH
16219: LD_INT 22
16221: PUSH
16222: LD_INT 8
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PUSH
16229: LD_INT 21
16231: PUSH
16232: LD_INT 1
16234: PUSH
16235: EMPTY
16236: LIST
16237: LIST
16238: PUSH
16239: EMPTY
16240: LIST
16241: LIST
16242: PPUSH
16243: CALL_OW 69
16247: PUSH
16248: LD_INT 22
16250: PUSH
16251: LD_INT 8
16253: PUSH
16254: EMPTY
16255: LIST
16256: LIST
16257: PUSH
16258: LD_INT 21
16260: PUSH
16261: LD_INT 2
16263: PUSH
16264: EMPTY
16265: LIST
16266: LIST
16267: PUSH
16268: LD_INT 1
16270: PUSH
16271: EMPTY
16272: LIST
16273: PUSH
16274: EMPTY
16275: LIST
16276: LIST
16277: LIST
16278: PPUSH
16279: CALL_OW 69
16283: ADD
16284: ST_TO_ADDR
// if tmp then
16285: LD_VAR 0 2
16289: IFFALSE 16442
// repeat wait ( 0 0$1 ) ;
16291: LD_INT 35
16293: PPUSH
16294: CALL_OW 67
// for i in tmp do
16298: LD_ADDR_VAR 0 1
16302: PUSH
16303: LD_VAR 0 2
16307: PUSH
16308: FOR_IN
16309: IFFALSE 16391
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16311: LD_VAR 0 1
16315: PPUSH
16316: CALL_OW 310
16320: PUSH
16321: LD_VAR 0 1
16325: PPUSH
16326: CALL_OW 310
16330: PPUSH
16331: CALL_OW 247
16335: PUSH
16336: LD_INT 3
16338: EQUAL
16339: AND
16340: IFFALSE 16351
// ComExitBuilding ( i ) ;
16342: LD_VAR 0 1
16346: PPUSH
16347: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
16351: LD_VAR 0 1
16355: PPUSH
16356: LD_INT 10
16358: PPUSH
16359: LD_INT 1
16361: PPUSH
16362: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
16366: LD_VAR 0 1
16370: PPUSH
16371: LD_INT 32
16373: PPUSH
16374: CALL_OW 308
16378: IFFALSE 16389
// RemoveUnit ( i ) ;
16380: LD_VAR 0 1
16384: PPUSH
16385: CALL_OW 64
// end ;
16389: GO 16308
16391: POP
16392: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16393: LD_INT 22
16395: PUSH
16396: LD_INT 8
16398: PUSH
16399: EMPTY
16400: LIST
16401: LIST
16402: PUSH
16403: LD_INT 2
16405: PUSH
16406: LD_INT 21
16408: PUSH
16409: LD_INT 1
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: PUSH
16416: LD_INT 33
16418: PUSH
16419: LD_INT 1
16421: PUSH
16422: EMPTY
16423: LIST
16424: LIST
16425: PUSH
16426: EMPTY
16427: LIST
16428: LIST
16429: LIST
16430: PUSH
16431: EMPTY
16432: LIST
16433: LIST
16434: PPUSH
16435: CALL_OW 69
16439: NOT
16440: IFFALSE 16291
// end ;
16442: PPOPN 2
16444: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 do
16445: LD_EXP 5
16449: NOT
16450: PUSH
16451: LD_OWVAR 1
16455: PUSH
16456: LD_INT 63000
16458: GREATEREQUAL
16459: AND
16460: IFFALSE 16469
16462: GO 16464
16464: DISABLE
// AllianceSupport ;
16465: CALL 4677 0 0
16469: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
16470: LD_EXP 4
16474: PUSH
16475: LD_EXP 2
16479: AND
16480: PUSH
16481: LD_EXP 3
16485: AND
16486: PUSH
16487: LD_EXP 5
16491: AND
16492: PUSH
16493: LD_EXP 6
16497: AND
16498: PUSH
16499: LD_EXP 7
16503: AND
16504: PUSH
16505: LD_EXP 8
16509: AND
16510: PUSH
16511: LD_EXP 56
16515: PPUSH
16516: CALL_OW 255
16520: PUSH
16521: LD_INT 5
16523: NONEQUAL
16524: PUSH
16525: LD_EXP 56
16529: PPUSH
16530: CALL_OW 301
16534: OR
16535: PUSH
16536: LD_EXP 56
16540: PPUSH
16541: CALL_OW 305
16545: NOT
16546: OR
16547: AND
16548: IFFALSE 17950
16550: GO 16552
16552: DISABLE
16553: LD_INT 0
16555: PPUSH
16556: PPUSH
// begin wait ( 0 0$5 ) ;
16557: LD_INT 175
16559: PPUSH
16560: CALL_OW 67
// music_class := 5 ;
16564: LD_ADDR_OWVAR 72
16568: PUSH
16569: LD_INT 5
16571: ST_TO_ADDR
// music_nat := 5 ;
16572: LD_ADDR_OWVAR 71
16576: PUSH
16577: LD_INT 5
16579: ST_TO_ADDR
// if vehicleLostCounter < 3 then
16580: LD_EXP 15
16584: PUSH
16585: LD_INT 3
16587: LESS
16588: IFFALSE 16597
// SetAchievement ( ACH_ECONOMY ) ;
16590: LD_STRING ACH_ECONOMY
16592: PPUSH
16593: CALL_OW 543
// if tick < 60 60$00 then
16597: LD_OWVAR 1
16601: PUSH
16602: LD_INT 126000
16604: LESS
16605: IFFALSE 16621
// begin wait ( 3 ) ;
16607: LD_INT 3
16609: PPUSH
16610: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16614: LD_STRING ACH_ASPEED_19
16616: PPUSH
16617: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16621: LD_EXP 19
16625: PPUSH
16626: CALL_OW 87
// InGameOn ;
16630: CALL_OW 8
// DialogueOn ;
16634: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16638: LD_EXP 19
16642: PPUSH
16643: LD_STRING DEnd-JMM-JMM-1
16645: PPUSH
16646: CALL_OW 88
// if Joan then
16650: LD_EXP 34
16654: IFFALSE 16670
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16656: LD_EXP 34
16660: PPUSH
16661: LD_STRING DEnd-JMM-Joan-1
16663: PPUSH
16664: CALL_OW 88
16668: GO 16714
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16670: LD_EXP 21
16674: PUSH
16675: LD_EXP 21
16679: PPUSH
16680: CALL_OW 255
16684: PUSH
16685: LD_INT 7
16687: EQUAL
16688: AND
16689: PUSH
16690: LD_EXP 21
16694: PPUSH
16695: CALL_OW 305
16699: AND
16700: IFFALSE 16714
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16702: LD_EXP 21
16706: PPUSH
16707: LD_STRING DEnd-JMM-Lisa-1
16709: PPUSH
16710: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16714: LD_EXP 31
16718: PUSH
16719: LD_EXP 31
16723: PPUSH
16724: CALL_OW 305
16728: AND
16729: IFFALSE 16743
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16731: LD_EXP 31
16735: PPUSH
16736: LD_STRING DEnd-JMM-Frank-1
16738: PPUSH
16739: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16743: LD_EXP 24
16747: PUSH
16748: LD_EXP 24
16752: PPUSH
16753: CALL_OW 255
16757: PUSH
16758: LD_INT 7
16760: EQUAL
16761: AND
16762: PUSH
16763: LD_EXP 24
16767: PPUSH
16768: CALL_OW 305
16772: AND
16773: IFFALSE 16787
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16775: LD_EXP 24
16779: PPUSH
16780: LD_STRING DEnd-JMM-Cyrus-1
16782: PPUSH
16783: CALL_OW 88
// if Burlak then
16787: LD_EXP 52
16791: IFFALSE 16805
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16793: LD_EXP 52
16797: PPUSH
16798: LD_STRING DEnd-JMM-Bur-1
16800: PPUSH
16801: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
16805: LD_EXP 34
16809: PUSH
16810: LD_EXP 21
16814: AND
16815: PUSH
16816: LD_EXP 21
16820: PPUSH
16821: CALL_OW 255
16825: PUSH
16826: LD_INT 7
16828: EQUAL
16829: AND
16830: PUSH
16831: LD_EXP 21
16835: PPUSH
16836: CALL_OW 305
16840: AND
16841: PUSH
16842: LD_EXP 52
16846: PPUSH
16847: CALL_OW 302
16851: AND
16852: IFFALSE 16866
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16854: LD_EXP 21
16858: PPUSH
16859: LD_STRING DEnd-Burlak-Lisa-1
16861: PPUSH
16862: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16866: LD_EXP 53
16870: PUSH
16871: LD_EXP 53
16875: PPUSH
16876: CALL_OW 305
16880: AND
16881: IFFALSE 16895
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16883: LD_EXP 53
16887: PPUSH
16888: LD_STRING DEnd-JMM-Bel-1
16890: PPUSH
16891: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16895: LD_EXP 54
16899: PUSH
16900: LD_EXP 54
16904: PPUSH
16905: CALL_OW 305
16909: AND
16910: IFFALSE 16924
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16912: LD_EXP 54
16916: PPUSH
16917: LD_STRING DEnd-JMM-Gny-1
16919: PPUSH
16920: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16924: LD_EXP 29
16928: PUSH
16929: LD_EXP 29
16933: PPUSH
16934: CALL_OW 255
16938: PUSH
16939: LD_INT 7
16941: EQUAL
16942: AND
16943: PUSH
16944: LD_EXP 29
16948: PPUSH
16949: CALL_OW 305
16953: AND
16954: IFFALSE 16968
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16956: LD_EXP 29
16960: PPUSH
16961: LD_STRING DEnd-JMM-Corn-1
16963: PPUSH
16964: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16968: LD_EXP 22
16972: PUSH
16973: LD_EXP 22
16977: PPUSH
16978: CALL_OW 255
16982: PUSH
16983: LD_INT 7
16985: EQUAL
16986: AND
16987: PUSH
16988: LD_EXP 22
16992: PPUSH
16993: CALL_OW 305
16997: AND
16998: IFFALSE 17012
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
17000: LD_EXP 22
17004: PPUSH
17005: LD_STRING DEnd-JMM-Don-1
17007: PPUSH
17008: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
17012: LD_EXP 23
17016: PUSH
17017: LD_EXP 23
17021: PPUSH
17022: CALL_OW 255
17026: PUSH
17027: LD_INT 7
17029: EQUAL
17030: AND
17031: PUSH
17032: LD_EXP 23
17036: PPUSH
17037: CALL_OW 305
17041: AND
17042: IFFALSE 17056
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17044: LD_EXP 23
17048: PPUSH
17049: LD_STRING DEnd-JMM-Bobby-1
17051: PPUSH
17052: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17056: LD_EXP 25
17060: PUSH
17061: LD_EXP 25
17065: PPUSH
17066: CALL_OW 255
17070: PUSH
17071: LD_INT 7
17073: EQUAL
17074: AND
17075: PUSH
17076: LD_EXP 25
17080: PPUSH
17081: CALL_OW 305
17085: AND
17086: IFFALSE 17100
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17088: LD_EXP 25
17092: PPUSH
17093: LD_STRING DEnd-JMM-Den-1
17095: PPUSH
17096: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17100: LD_EXP 27
17104: PUSH
17105: LD_EXP 27
17109: PPUSH
17110: CALL_OW 255
17114: PUSH
17115: LD_INT 7
17117: EQUAL
17118: AND
17119: PUSH
17120: LD_EXP 27
17124: PPUSH
17125: CALL_OW 305
17129: AND
17130: IFFALSE 17144
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17132: LD_EXP 27
17136: PPUSH
17137: LD_STRING DEnd-JMM-Glad-1
17139: PPUSH
17140: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17144: LD_EXP 32
17148: PUSH
17149: LD_EXP 32
17153: PPUSH
17154: CALL_OW 255
17158: PUSH
17159: LD_INT 7
17161: EQUAL
17162: AND
17163: PUSH
17164: LD_EXP 32
17168: PPUSH
17169: CALL_OW 305
17173: AND
17174: IFFALSE 17188
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17176: LD_EXP 32
17180: PPUSH
17181: LD_STRING DEnd-JMM-Yam-1
17183: PPUSH
17184: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17188: LD_EXP 26
17192: PUSH
17193: LD_EXP 26
17197: PPUSH
17198: CALL_OW 255
17202: PUSH
17203: LD_INT 7
17205: EQUAL
17206: AND
17207: PUSH
17208: LD_EXP 26
17212: PPUSH
17213: CALL_OW 305
17217: AND
17218: IFFALSE 17232
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17220: LD_EXP 26
17224: PPUSH
17225: LD_STRING DEnd-JMM-Brown-1
17227: PPUSH
17228: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17232: LD_EXP 36
17236: PUSH
17237: LD_EXP 36
17241: PPUSH
17242: CALL_OW 255
17246: PUSH
17247: LD_INT 7
17249: EQUAL
17250: AND
17251: PUSH
17252: LD_EXP 36
17256: PPUSH
17257: CALL_OW 305
17261: AND
17262: IFFALSE 17276
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17264: LD_EXP 36
17268: PPUSH
17269: LD_STRING DEnd-JMM-Con-1
17271: PPUSH
17272: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17276: LD_EXP 30
17280: PUSH
17281: LD_EXP 30
17285: PPUSH
17286: CALL_OW 255
17290: PUSH
17291: LD_INT 7
17293: EQUAL
17294: AND
17295: PUSH
17296: LD_EXP 30
17300: PPUSH
17301: CALL_OW 305
17305: AND
17306: IFFALSE 17320
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17308: LD_EXP 30
17312: PPUSH
17313: LD_STRING DEnd-JMM-Gary-1
17315: PPUSH
17316: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
17320: LD_EXP 33
17324: PUSH
17325: LD_EXP 20
17329: AND
17330: PUSH
17331: LD_EXP 33
17335: PPUSH
17336: CALL_OW 305
17340: AND
17341: IFFALSE 17355
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17343: LD_EXP 33
17347: PPUSH
17348: LD_STRING DEnd-JMM-Sim-1
17350: PPUSH
17351: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
17355: LD_EXP 28
17359: PUSH
17360: LD_EXP 28
17364: PPUSH
17365: CALL_OW 255
17369: PUSH
17370: LD_INT 7
17372: EQUAL
17373: AND
17374: PUSH
17375: LD_EXP 28
17379: PPUSH
17380: CALL_OW 305
17384: AND
17385: IFFALSE 17399
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
17387: LD_EXP 28
17391: PPUSH
17392: LD_STRING DEnd-JMM-VanH-1
17394: PPUSH
17395: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
17399: LD_EXP 42
17403: PUSH
17404: LD_EXP 42
17408: PPUSH
17409: CALL_OW 305
17413: AND
17414: IFFALSE 17428
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17416: LD_EXP 42
17420: PPUSH
17421: LD_STRING DEnd-JMM-Dol-1
17423: PPUSH
17424: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
17428: LD_EXP 46
17432: PUSH
17433: LD_EXP 46
17437: PPUSH
17438: CALL_OW 305
17442: AND
17443: IFFALSE 17457
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17445: LD_EXP 46
17449: PPUSH
17450: LD_STRING DEnd-JMM-Kap-1
17452: PPUSH
17453: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
17457: LD_EXP 49
17461: PUSH
17462: LD_EXP 49
17466: PPUSH
17467: CALL_OW 305
17471: AND
17472: IFFALSE 17486
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17474: LD_EXP 49
17478: PPUSH
17479: LD_STRING DEnd-JMM-Kov-1
17481: PPUSH
17482: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
17486: LD_EXP 44
17490: PUSH
17491: LD_EXP 44
17495: PPUSH
17496: CALL_OW 305
17500: AND
17501: IFFALSE 17515
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17503: LD_EXP 44
17507: PPUSH
17508: LD_STRING DEnd-JMM-Sch-1
17510: PPUSH
17511: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
17515: LD_EXP 40
17519: PUSH
17520: LD_EXP 40
17524: PPUSH
17525: CALL_OW 305
17529: AND
17530: IFFALSE 17544
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
17532: LD_EXP 40
17536: PPUSH
17537: LD_STRING DEnd-JMM-Tit-1
17539: PPUSH
17540: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
17544: LD_EXP 45
17548: PUSH
17549: LD_EXP 45
17553: PPUSH
17554: CALL_OW 305
17558: AND
17559: IFFALSE 17573
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
17561: LD_EXP 45
17565: PPUSH
17566: LD_STRING DEnd-JMM-Obl-1
17568: PPUSH
17569: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
17573: LD_EXP 47
17577: PUSH
17578: LD_EXP 47
17582: PPUSH
17583: CALL_OW 305
17587: AND
17588: IFFALSE 17602
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
17590: LD_EXP 47
17594: PPUSH
17595: LD_STRING DEnd-JMM-Lip-1
17597: PPUSH
17598: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17602: LD_EXP 41
17606: PUSH
17607: LD_EXP 41
17611: PPUSH
17612: CALL_OW 305
17616: AND
17617: PUSH
17618: LD_EXP 52
17622: AND
17623: IFFALSE 17637
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17625: LD_EXP 41
17629: PPUSH
17630: LD_STRING DEnd-Burlak-Fad-1
17632: PPUSH
17633: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17637: LD_EXP 48
17641: PUSH
17642: LD_EXP 48
17646: PPUSH
17647: CALL_OW 305
17651: AND
17652: IFFALSE 17666
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17654: LD_EXP 48
17658: PPUSH
17659: LD_STRING DEnd-Burlak-Ptr-1
17661: PPUSH
17662: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17666: LD_EXP 50
17670: PUSH
17671: LD_EXP 50
17675: PPUSH
17676: CALL_OW 305
17680: AND
17681: IFFALSE 17695
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17683: LD_EXP 50
17687: PPUSH
17688: LD_STRING DEnd-Burlak-Kuz-1
17690: PPUSH
17691: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17695: LD_EXP 39
17699: PUSH
17700: LD_EXP 39
17704: PPUSH
17705: CALL_OW 305
17709: AND
17710: PUSH
17711: LD_EXP 52
17715: AND
17716: IFFALSE 17730
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17718: LD_EXP 39
17722: PPUSH
17723: LD_STRING DEnd-Burlak-Kir-1
17725: PPUSH
17726: CALL_OW 88
// if Burlak then
17730: LD_EXP 52
17734: IFFALSE 17748
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17736: LD_EXP 19
17740: PPUSH
17741: LD_STRING DEnd-Burlak-JMM-1
17743: PPUSH
17744: CALL_OW 88
// dwait ( 0 0$2 ) ;
17748: LD_INT 70
17750: PPUSH
17751: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17755: LD_EXP 57
17759: PPUSH
17760: LD_STRING DEnd-Szulc
17762: PPUSH
17763: CALL_OW 94
// dwait ( 0 0$1 ) ;
17767: LD_INT 35
17769: PPUSH
17770: CALL_OW 68
// if IsLive ( Burlak ) then
17774: LD_EXP 52
17778: PPUSH
17779: CALL_OW 300
17783: IFFALSE 17795
// med1 := 1 else
17785: LD_ADDR_VAR 0 1
17789: PUSH
17790: LD_INT 1
17792: ST_TO_ADDR
17793: GO 17804
// med1 := - 1 ;
17795: LD_ADDR_VAR 0 1
17799: PUSH
17800: LD_INT 1
17802: NEG
17803: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17804: LD_EXP 12
17808: PUSH
17809: LD_EXP 13
17813: AND
17814: PUSH
17815: LD_EXP 14
17819: AND
17820: IFFALSE 17832
// med2 := 1 else
17822: LD_ADDR_VAR 0 2
17826: PUSH
17827: LD_INT 1
17829: ST_TO_ADDR
17830: GO 17841
// med2 := - 1 ;
17832: LD_ADDR_VAR 0 2
17836: PUSH
17837: LD_INT 1
17839: NEG
17840: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17841: LD_STRING Hero
17843: PPUSH
17844: LD_INT 1
17846: PPUSH
17847: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17851: LD_STRING Artefact
17853: PPUSH
17854: LD_VAR 0 2
17858: PPUSH
17859: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17863: LD_STRING ReconcileBurlak
17865: PPUSH
17866: LD_VAR 0 1
17870: PPUSH
17871: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17875: LD_OWVAR 67
17879: PUSH
17880: LD_INT 3
17882: GREATEREQUAL
17883: PUSH
17884: LD_VAR 0 1
17888: PUSH
17889: LD_INT 1
17891: EQUAL
17892: AND
17893: PUSH
17894: LD_VAR 0 2
17898: PUSH
17899: LD_INT 1
17901: EQUAL
17902: AND
17903: IFFALSE 17915
// SetAchievementEX ( ACH_AMER , 19 ) ;
17905: LD_STRING ACH_AMER
17907: PPUSH
17908: LD_INT 19
17910: PPUSH
17911: CALL_OW 564
// GiveMedals ( MAIN ) ;
17915: LD_STRING MAIN
17917: PPUSH
17918: CALL_OW 102
// InGameOff ;
17922: CALL_OW 9
// DialogueOff ;
17926: CALL_OW 7
// music_nat := 1 ;
17930: LD_ADDR_OWVAR 71
17934: PUSH
17935: LD_INT 1
17937: ST_TO_ADDR
// music_class := 4 ;
17938: LD_ADDR_OWVAR 72
17942: PUSH
17943: LD_INT 4
17945: ST_TO_ADDR
// YouWin ;
17946: CALL_OW 103
// end ; end_of_file
17950: PPOPN 2
17952: END
// export function InitNature ; begin
17953: LD_INT 0
17955: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17956: LD_INT 3
17958: PPUSH
17959: LD_INT 3
17961: PPUSH
17962: LD_INT 2
17964: PPUSH
17965: LD_INT 1
17967: PPUSH
17968: LD_INT 1
17970: PPUSH
17971: LD_INT 0
17973: PPUSH
17974: LD_INT 0
17976: PPUSH
17977: LD_INT 17
17979: PPUSH
17980: LD_INT 0
17982: PPUSH
17983: CALL 86082 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17987: LD_INT 2
17989: PPUSH
17990: LD_INT 1
17992: PPUSH
17993: LD_INT 1
17995: PPUSH
17996: LD_INT 1
17998: PPUSH
17999: LD_INT 1
18001: PPUSH
18002: LD_INT 0
18004: PPUSH
18005: LD_INT 0
18007: PPUSH
18008: LD_INT 18
18010: PPUSH
18011: LD_INT 0
18013: PPUSH
18014: CALL 86082 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
18018: LD_INT 4
18020: PPUSH
18021: LD_INT 1
18023: PPUSH
18024: LD_INT 2
18026: PPUSH
18027: LD_INT 4
18029: PPUSH
18030: LD_INT 2
18032: PPUSH
18033: LD_INT 1
18035: PPUSH
18036: LD_INT 0
18038: PPUSH
18039: LD_INT 19
18041: PPUSH
18042: LD_INT 0
18044: PPUSH
18045: CALL 86082 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18049: LD_INT 0
18051: PPUSH
18052: LD_INT 0
18054: PPUSH
18055: LD_INT 0
18057: PPUSH
18058: LD_INT 0
18060: PPUSH
18061: LD_INT 0
18063: PPUSH
18064: LD_INT 0
18066: PPUSH
18067: LD_INT 9
18069: PPUSH
18070: LD_INT 0
18072: PPUSH
18073: LD_INT 20
18075: PPUSH
18076: CALL 86082 0 9
// end ; end_of_file
18080: LD_VAR 0 1
18084: RET
// every 0 0$30 do var time ;
18085: GO 18087
18087: DISABLE
18088: LD_INT 0
18090: PPUSH
// begin time := 0 0$30 ;
18091: LD_ADDR_VAR 0 1
18095: PUSH
18096: LD_INT 1050
18098: ST_TO_ADDR
// repeat wait ( time ) ;
18099: LD_VAR 0 1
18103: PPUSH
18104: CALL_OW 67
// if Prob ( 50 ) then
18108: LD_INT 50
18110: PPUSH
18111: CALL_OW 13
18115: IFFALSE 18144
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18117: LD_INT 1
18119: PPUSH
18120: LD_INT 5
18122: PPUSH
18123: CALL_OW 12
18127: PPUSH
18128: LD_INT 106
18130: PPUSH
18131: LD_INT 89
18133: PPUSH
18134: LD_INT 45
18136: PPUSH
18137: LD_INT 1
18139: PPUSH
18140: CALL_OW 56
// time := time + 0 0$3 ;
18144: LD_ADDR_VAR 0 1
18148: PUSH
18149: LD_VAR 0 1
18153: PUSH
18154: LD_INT 105
18156: PLUS
18157: ST_TO_ADDR
// if Prob ( 30 ) then
18158: LD_INT 30
18160: PPUSH
18161: CALL_OW 13
18165: IFFALSE 18211
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18167: LD_INT 525
18169: PPUSH
18170: LD_INT 735
18172: PPUSH
18173: CALL_OW 12
18177: PPUSH
18178: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
18182: LD_INT 1
18184: PPUSH
18185: LD_INT 5
18187: PPUSH
18188: CALL_OW 12
18192: PPUSH
18193: LD_INT 21
18195: PPUSH
18196: LD_INT 26
18198: PPUSH
18199: LD_INT 12
18201: PPUSH
18202: LD_INT 1
18204: PPUSH
18205: CALL_OW 56
// end else
18209: GO 18247
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
18211: LD_INT 700
18213: PPUSH
18214: LD_INT 1225
18216: PPUSH
18217: CALL_OW 12
18221: PPUSH
18222: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
18226: LD_INT 1
18228: PPUSH
18229: LD_INT 5
18231: PPUSH
18232: CALL_OW 12
18236: PPUSH
18237: LD_INT 14
18239: PPUSH
18240: LD_INT 1
18242: PPUSH
18243: CALL_OW 55
// end ; if Prob ( 50 ) then
18247: LD_INT 50
18249: PPUSH
18250: CALL_OW 13
18254: IFFALSE 18300
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
18256: LD_INT 700
18258: PPUSH
18259: LD_INT 1050
18261: PPUSH
18262: CALL_OW 12
18266: PPUSH
18267: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
18271: LD_INT 1
18273: PPUSH
18274: LD_INT 5
18276: PPUSH
18277: CALL_OW 12
18281: PPUSH
18282: LD_INT 181
18284: PPUSH
18285: LD_INT 218
18287: PPUSH
18288: LD_INT 16
18290: PPUSH
18291: LD_INT 1
18293: PPUSH
18294: CALL_OW 56
// end else
18298: GO 18372
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
18300: LD_INT 350
18302: PPUSH
18303: LD_INT 525
18305: PPUSH
18306: CALL_OW 12
18310: PPUSH
18311: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
18315: LD_INT 1
18317: PPUSH
18318: LD_INT 5
18320: PPUSH
18321: CALL_OW 12
18325: PPUSH
18326: LD_INT 13
18328: PPUSH
18329: LD_INT 1
18331: PPUSH
18332: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18336: LD_INT 350
18338: PPUSH
18339: LD_INT 700
18341: PPUSH
18342: CALL_OW 12
18346: PPUSH
18347: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
18351: LD_INT 1
18353: PPUSH
18354: LD_INT 5
18356: PPUSH
18357: CALL_OW 12
18361: PPUSH
18362: LD_INT 33
18364: PPUSH
18365: LD_INT 1
18367: PPUSH
18368: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
18372: LD_INT 65
18374: PUSH
18375: LD_INT 62
18377: PUSH
18378: LD_INT 55
18380: PUSH
18381: LD_INT 50
18383: PUSH
18384: EMPTY
18385: LIST
18386: LIST
18387: LIST
18388: LIST
18389: PUSH
18390: LD_OWVAR 67
18394: ARRAY
18395: PPUSH
18396: CALL_OW 13
18400: IFFALSE 18446
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
18402: LD_INT 525
18404: PPUSH
18405: LD_INT 875
18407: PPUSH
18408: CALL_OW 12
18412: PPUSH
18413: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18417: LD_INT 1
18419: PPUSH
18420: LD_INT 5
18422: PPUSH
18423: CALL_OW 12
18427: PPUSH
18428: LD_INT 294
18430: PPUSH
18431: LD_INT 211
18433: PPUSH
18434: LD_INT 30
18436: PPUSH
18437: LD_INT 1
18439: PPUSH
18440: CALL_OW 56
// end else
18444: GO 18488
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
18446: LD_INT 420
18448: PPUSH
18449: LD_INT 770
18451: PPUSH
18452: CALL_OW 12
18456: PPUSH
18457: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18461: LD_INT 1
18463: PPUSH
18464: LD_INT 5
18466: PPUSH
18467: CALL_OW 12
18471: PPUSH
18472: LD_INT 294
18474: PPUSH
18475: LD_INT 211
18477: PPUSH
18478: LD_INT 30
18480: PPUSH
18481: LD_INT 1
18483: PPUSH
18484: CALL_OW 56
// end ; if time > 2 2$20 then
18488: LD_VAR 0 1
18492: PUSH
18493: LD_INT 4900
18495: GREATER
18496: IFFALSE 18506
// time := 0 0$50 ;
18498: LD_ADDR_VAR 0 1
18502: PUSH
18503: LD_INT 1750
18505: ST_TO_ADDR
// until false ;
18506: LD_INT 0
18508: IFFALSE 18099
// end ;
18510: PPOPN 1
18512: END
// every 0 0$45 trigger tick < 10 10$00 do
18513: LD_OWVAR 1
18517: PUSH
18518: LD_INT 21000
18520: LESS
18521: IFFALSE 18569
18523: GO 18525
18525: DISABLE
// begin enable ;
18526: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18527: LD_INT 350
18529: PPUSH
18530: LD_INT 700
18532: PPUSH
18533: CALL_OW 12
18537: PPUSH
18538: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
18542: LD_INT 3
18544: PPUSH
18545: LD_INT 5
18547: PPUSH
18548: CALL_OW 12
18552: PPUSH
18553: LD_INT 181
18555: PPUSH
18556: LD_INT 13
18558: PPUSH
18559: LD_INT 20
18561: PPUSH
18562: LD_INT 1
18564: PPUSH
18565: CALL_OW 56
// end ; end_of_file
18569: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
18570: LD_INT 0
18572: PPUSH
// SetArtifactRes ( 7 , true ) ;
18573: LD_INT 7
18575: PPUSH
18576: LD_INT 1
18578: PPUSH
18579: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
18583: LD_ADDR_EXP 65
18587: PUSH
18588: EMPTY
18589: PUSH
18590: EMPTY
18591: PUSH
18592: EMPTY
18593: PUSH
18594: EMPTY
18595: LIST
18596: LIST
18597: LIST
18598: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18599: LD_ADDR_EXP 66
18603: PUSH
18604: LD_INT 1050
18606: PUSH
18607: LD_OWVAR 67
18611: MUL
18612: PUSH
18613: LD_INT 2800
18615: PUSH
18616: LD_OWVAR 67
18620: MUL
18621: PUSH
18622: LD_INT 1
18624: NEG
18625: PUSH
18626: EMPTY
18627: LIST
18628: LIST
18629: LIST
18630: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18631: LD_ADDR_EXP 67
18635: PUSH
18636: LD_INT 10
18638: PUSH
18639: LD_INT 35
18641: PUSH
18642: LD_INT 100
18644: PUSH
18645: EMPTY
18646: LIST
18647: LIST
18648: LIST
18649: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18650: LD_ADDR_EXP 68
18654: PUSH
18655: LD_INT 0
18657: PUSH
18658: LD_INT 0
18660: PUSH
18661: LD_INT 0
18663: PUSH
18664: EMPTY
18665: LIST
18666: LIST
18667: LIST
18668: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18669: LD_ADDR_EXP 70
18673: PUSH
18674: LD_INT 300
18676: PUSH
18677: LD_INT 500
18679: PUSH
18680: LD_INT 800
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: LIST
18687: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18688: LD_ADDR_EXP 71
18692: PUSH
18693: LD_INT 0
18695: PUSH
18696: LD_INT 0
18698: PUSH
18699: LD_INT 0
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: LIST
18706: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18707: LD_ADDR_EXP 72
18711: PUSH
18712: LD_INT 0
18714: PUSH
18715: LD_INT 0
18717: PUSH
18718: LD_INT 0
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18726: LD_ADDR_EXP 69
18730: PUSH
18731: LD_INT 0
18733: PUSH
18734: LD_INT 0
18736: PUSH
18737: LD_INT 0
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: LIST
18744: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18745: LD_ADDR_EXP 73
18749: PUSH
18750: LD_INT 4
18752: PUSH
18753: LD_INT 3
18755: PUSH
18756: LD_INT 1
18758: PUSH
18759: EMPTY
18760: LIST
18761: LIST
18762: LIST
18763: PUSH
18764: LD_INT 5
18766: PUSH
18767: LD_INT 4
18769: PUSH
18770: LD_INT 2
18772: PUSH
18773: EMPTY
18774: LIST
18775: LIST
18776: LIST
18777: PUSH
18778: LD_INT 6
18780: PUSH
18781: LD_INT 3
18783: PUSH
18784: LD_INT 3
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: LIST
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: LIST
18796: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18797: LD_ADDR_EXP 74
18801: PUSH
18802: LD_INT 0
18804: PUSH
18805: LD_INT 0
18807: PUSH
18808: LD_INT 0
18810: PUSH
18811: EMPTY
18812: LIST
18813: LIST
18814: LIST
18815: ST_TO_ADDR
// end ;
18816: LD_VAR 0 1
18820: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18821: LD_INT 24
18823: PPUSH
18824: LD_INT 7
18826: PPUSH
18827: CALL_OW 321
18831: PUSH
18832: LD_INT 2
18834: EQUAL
18835: IFFALSE 19761
18837: GO 18839
18839: DISABLE
18840: LD_INT 0
18842: PPUSH
18843: PPUSH
18844: PPUSH
18845: PPUSH
18846: PPUSH
// begin enable ;
18847: ENABLE
// for i = 1 to 3 do
18848: LD_ADDR_VAR 0 1
18852: PUSH
18853: DOUBLE
18854: LD_INT 1
18856: DEC
18857: ST_TO_ADDR
18858: LD_INT 3
18860: PUSH
18861: FOR_TO
18862: IFFALSE 19759
// begin pos := FindArtifact ( i + 2 ) ;
18864: LD_ADDR_VAR 0 2
18868: PUSH
18869: LD_VAR 0 1
18873: PUSH
18874: LD_INT 2
18876: PLUS
18877: PPUSH
18878: CALL_OW 469
18882: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18883: LD_ADDR_EXP 65
18887: PUSH
18888: LD_EXP 65
18892: PPUSH
18893: LD_VAR 0 1
18897: PPUSH
18898: LD_VAR 0 2
18902: PPUSH
18903: CALL_OW 1
18907: ST_TO_ADDR
// if pos then
18908: LD_VAR 0 2
18912: IFFALSE 19620
// begin case i of 1 :
18914: LD_VAR 0 1
18918: PUSH
18919: LD_INT 1
18921: DOUBLE
18922: EQUAL
18923: IFTRUE 18927
18925: GO 19004
18927: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18928: LD_ADDR_VAR 0 4
18932: PUSH
18933: LD_INT 22
18935: PUSH
18936: LD_INT 7
18938: PUSH
18939: EMPTY
18940: LIST
18941: LIST
18942: PUSH
18943: LD_INT 23
18945: PUSH
18946: LD_INT 1
18948: PUSH
18949: EMPTY
18950: LIST
18951: LIST
18952: PUSH
18953: LD_INT 2
18955: PUSH
18956: LD_INT 30
18958: PUSH
18959: LD_INT 8
18961: PUSH
18962: EMPTY
18963: LIST
18964: LIST
18965: PUSH
18966: LD_INT 30
18968: PUSH
18969: LD_INT 7
18971: PUSH
18972: EMPTY
18973: LIST
18974: LIST
18975: PUSH
18976: LD_INT 30
18978: PUSH
18979: LD_INT 11
18981: PUSH
18982: EMPTY
18983: LIST
18984: LIST
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: LIST
18990: LIST
18991: PUSH
18992: EMPTY
18993: LIST
18994: LIST
18995: LIST
18996: PPUSH
18997: CALL_OW 69
19001: ST_TO_ADDR
19002: GO 19112
19004: LD_INT 2
19006: DOUBLE
19007: EQUAL
19008: IFTRUE 19012
19010: GO 19089
19012: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
19013: LD_ADDR_VAR 0 4
19017: PUSH
19018: LD_INT 22
19020: PUSH
19021: LD_INT 7
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: PUSH
19028: LD_INT 23
19030: PUSH
19031: LD_INT 3
19033: PUSH
19034: EMPTY
19035: LIST
19036: LIST
19037: PUSH
19038: LD_INT 2
19040: PUSH
19041: LD_INT 30
19043: PUSH
19044: LD_INT 8
19046: PUSH
19047: EMPTY
19048: LIST
19049: LIST
19050: PUSH
19051: LD_INT 30
19053: PUSH
19054: LD_INT 7
19056: PUSH
19057: EMPTY
19058: LIST
19059: LIST
19060: PUSH
19061: LD_INT 30
19063: PUSH
19064: LD_INT 11
19066: PUSH
19067: EMPTY
19068: LIST
19069: LIST
19070: PUSH
19071: EMPTY
19072: LIST
19073: LIST
19074: LIST
19075: LIST
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: LIST
19081: PPUSH
19082: CALL_OW 69
19086: ST_TO_ADDR
19087: GO 19112
19089: LD_INT 3
19091: DOUBLE
19092: EQUAL
19093: IFTRUE 19097
19095: GO 19111
19097: POP
// labs := [ alien ] ; end ;
19098: LD_ADDR_VAR 0 4
19102: PUSH
19103: LD_INT 1
19105: PUSH
19106: EMPTY
19107: LIST
19108: ST_TO_ADDR
19109: GO 19112
19111: POP
// if not labs then
19112: LD_VAR 0 4
19116: NOT
19117: IFFALSE 19121
// continue ;
19119: GO 18861
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19121: LD_ADDR_VAR 0 5
19125: PUSH
19126: LD_VAR 0 4
19130: PPUSH
19131: LD_EXP 65
19135: PUSH
19136: LD_VAR 0 1
19140: ARRAY
19141: PUSH
19142: LD_INT 1
19144: ARRAY
19145: PPUSH
19146: LD_EXP 65
19150: PUSH
19151: LD_VAR 0 1
19155: ARRAY
19156: PUSH
19157: LD_INT 2
19159: ARRAY
19160: PPUSH
19161: CALL_OW 73
19165: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19166: LD_VAR 0 5
19170: NOT
19171: PUSH
19172: LD_VAR 0 5
19176: PUSH
19177: LD_EXP 72
19181: PUSH
19182: LD_VAR 0 1
19186: ARRAY
19187: NONEQUAL
19188: OR
19189: IFFALSE 19294
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19191: LD_INT 7
19193: PPUSH
19194: LD_EXP 73
19198: PUSH
19199: LD_VAR 0 1
19203: ARRAY
19204: PUSH
19205: LD_INT 3
19207: ARRAY
19208: PPUSH
19209: LD_INT 0
19211: PPUSH
19212: LD_EXP 72
19216: PUSH
19217: LD_VAR 0 1
19221: ARRAY
19222: PPUSH
19223: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19227: LD_INT 7
19229: PPUSH
19230: LD_EXP 73
19234: PUSH
19235: LD_VAR 0 1
19239: ARRAY
19240: PUSH
19241: LD_INT 1
19243: ARRAY
19244: PPUSH
19245: LD_INT 0
19247: PPUSH
19248: LD_EXP 72
19252: PUSH
19253: LD_VAR 0 1
19257: ARRAY
19258: PPUSH
19259: CALL_OW 468
// if nearestLab then
19263: LD_VAR 0 5
19267: IFFALSE 19294
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
19269: LD_ADDR_EXP 72
19273: PUSH
19274: LD_EXP 72
19278: PPUSH
19279: LD_VAR 0 1
19283: PPUSH
19284: LD_VAR 0 5
19288: PPUSH
19289: CALL_OW 1
19293: ST_TO_ADDR
// end ; if not nearestLab then
19294: LD_VAR 0 5
19298: NOT
19299: IFFALSE 19303
// continue ;
19301: GO 18861
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
19303: LD_VAR 0 5
19307: PPUSH
19308: LD_EXP 65
19312: PUSH
19313: LD_VAR 0 1
19317: ARRAY
19318: PUSH
19319: LD_INT 1
19321: ARRAY
19322: PPUSH
19323: LD_EXP 65
19327: PUSH
19328: LD_VAR 0 1
19332: ARRAY
19333: PUSH
19334: LD_INT 2
19336: ARRAY
19337: PPUSH
19338: CALL_OW 297
19342: PUSH
19343: LD_INT 8
19345: LESS
19346: IFFALSE 19543
// begin if not artifactsResearched [ i ] then
19348: LD_EXP 68
19352: PUSH
19353: LD_VAR 0 1
19357: ARRAY
19358: NOT
19359: IFFALSE 19440
// begin if BuildingStatus ( nearestLab ) = bs_idle then
19361: LD_VAR 0 5
19365: PPUSH
19366: CALL_OW 461
19370: PUSH
19371: LD_INT 2
19373: EQUAL
19374: IFFALSE 19408
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
19376: LD_INT 7
19378: PPUSH
19379: LD_EXP 73
19383: PUSH
19384: LD_VAR 0 1
19388: ARRAY
19389: PUSH
19390: LD_INT 3
19392: ARRAY
19393: PPUSH
19394: LD_INT 2
19396: PPUSH
19397: LD_VAR 0 5
19401: PPUSH
19402: CALL_OW 468
19406: GO 19438
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
19408: LD_INT 7
19410: PPUSH
19411: LD_EXP 73
19415: PUSH
19416: LD_VAR 0 1
19420: ARRAY
19421: PUSH
19422: LD_INT 3
19424: ARRAY
19425: PPUSH
19426: LD_INT 1
19428: PPUSH
19429: LD_VAR 0 5
19433: PPUSH
19434: CALL_OW 468
// end else
19438: GO 19541
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
19440: LD_VAR 0 5
19444: PPUSH
19445: CALL_OW 461
19449: PUSH
19450: LD_INT 2
19452: EQUAL
19453: PUSH
19454: LD_EXP 74
19458: PUSH
19459: LD_VAR 0 1
19463: ARRAY
19464: AND
19465: IFFALSE 19511
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
19467: LD_INT 7
19469: PPUSH
19470: LD_EXP 73
19474: PUSH
19475: LD_VAR 0 1
19479: ARRAY
19480: PUSH
19481: LD_INT 1
19483: ARRAY
19484: PPUSH
19485: LD_EXP 73
19489: PUSH
19490: LD_VAR 0 1
19494: ARRAY
19495: PUSH
19496: LD_INT 2
19498: ARRAY
19499: PPUSH
19500: LD_VAR 0 5
19504: PPUSH
19505: CALL_OW 468
19509: GO 19541
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
19511: LD_INT 7
19513: PPUSH
19514: LD_EXP 73
19518: PUSH
19519: LD_VAR 0 1
19523: ARRAY
19524: PUSH
19525: LD_INT 1
19527: ARRAY
19528: PPUSH
19529: LD_INT 1
19531: PPUSH
19532: LD_VAR 0 5
19536: PPUSH
19537: CALL_OW 468
// end else
19541: GO 19618
// begin if not artifactsResearched [ i ] then
19543: LD_EXP 68
19547: PUSH
19548: LD_VAR 0 1
19552: ARRAY
19553: NOT
19554: IFFALSE 19588
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
19556: LD_INT 7
19558: PPUSH
19559: LD_EXP 73
19563: PUSH
19564: LD_VAR 0 1
19568: ARRAY
19569: PUSH
19570: LD_INT 3
19572: ARRAY
19573: PPUSH
19574: LD_INT 0
19576: PPUSH
19577: LD_VAR 0 5
19581: PPUSH
19582: CALL_OW 468
19586: GO 19618
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
19588: LD_INT 7
19590: PPUSH
19591: LD_EXP 73
19595: PUSH
19596: LD_VAR 0 1
19600: ARRAY
19601: PUSH
19602: LD_INT 1
19604: ARRAY
19605: PPUSH
19606: LD_INT 0
19608: PPUSH
19609: LD_VAR 0 5
19613: PPUSH
19614: CALL_OW 468
// end ; end else
19618: GO 19757
// begin if not artifactsLabs [ i ] then
19620: LD_EXP 72
19624: PUSH
19625: LD_VAR 0 1
19629: ARRAY
19630: NOT
19631: IFFALSE 19635
// continue ;
19633: GO 18861
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19635: LD_INT 7
19637: PPUSH
19638: LD_EXP 73
19642: PUSH
19643: LD_VAR 0 1
19647: ARRAY
19648: PUSH
19649: LD_INT 3
19651: ARRAY
19652: PPUSH
19653: LD_INT 0
19655: PPUSH
19656: LD_EXP 72
19660: PUSH
19661: LD_VAR 0 1
19665: ARRAY
19666: PPUSH
19667: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19671: LD_INT 7
19673: PPUSH
19674: LD_EXP 73
19678: PUSH
19679: LD_VAR 0 1
19683: ARRAY
19684: PUSH
19685: LD_INT 1
19687: ARRAY
19688: PPUSH
19689: LD_INT 0
19691: PPUSH
19692: LD_EXP 72
19696: PUSH
19697: LD_VAR 0 1
19701: ARRAY
19702: PPUSH
19703: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19707: LD_EXP 69
19711: PUSH
19712: LD_VAR 0 1
19716: ARRAY
19717: IFFALSE 19757
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19719: LD_ADDR_EXP 69
19723: PUSH
19724: LD_EXP 69
19728: PPUSH
19729: LD_VAR 0 1
19733: PPUSH
19734: LD_INT 0
19736: PPUSH
19737: CALL_OW 1
19741: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19742: LD_EXP 72
19746: PUSH
19747: LD_VAR 0 1
19751: ARRAY
19752: PPUSH
19753: CALL_OW 127
// end ; end ; end ;
19757: GO 18861
19759: POP
19760: POP
// end ;
19761: PPOPN 5
19763: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19764: LD_INT 0
19766: PPUSH
19767: PPUSH
19768: PPUSH
19769: PPUSH
19770: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19771: LD_VAR 0 2
19775: PUSH
19776: LD_EXP 73
19780: PUSH
19781: LD_INT 1
19783: ARRAY
19784: PUSH
19785: LD_INT 3
19787: ARRAY
19788: EQUAL
19789: IFFALSE 19912
// begin lab := artifactsLabs [ 1 ] ;
19791: LD_ADDR_VAR 0 6
19795: PUSH
19796: LD_EXP 72
19800: PUSH
19801: LD_INT 1
19803: ARRAY
19804: ST_TO_ADDR
// if not lab then
19805: LD_VAR 0 6
19809: NOT
19810: IFFALSE 19814
// exit ;
19812: GO 20892
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19814: LD_VAR 0 6
19818: PPUSH
19819: LD_EXP 70
19823: PUSH
19824: LD_INT 1
19826: ARRAY
19827: PPUSH
19828: LD_INT 1
19830: PPUSH
19831: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19835: LD_EXP 71
19839: PUSH
19840: LD_INT 1
19842: ARRAY
19843: IFFALSE 19863
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19845: LD_VAR 0 6
19849: PPUSH
19850: LD_EXP 71
19854: PUSH
19855: LD_INT 1
19857: ARRAY
19858: PPUSH
19859: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19863: LD_ADDR_EXP 69
19867: PUSH
19868: LD_EXP 69
19872: PPUSH
19873: LD_INT 1
19875: PPUSH
19876: LD_INT 1
19878: PPUSH
19879: CALL_OW 1
19883: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19884: LD_INT 7
19886: PPUSH
19887: LD_EXP 73
19891: PUSH
19892: LD_INT 1
19894: ARRAY
19895: PUSH
19896: LD_INT 3
19898: ARRAY
19899: PPUSH
19900: LD_INT 0
19902: PPUSH
19903: LD_VAR 0 6
19907: PPUSH
19908: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19912: LD_VAR 0 2
19916: PUSH
19917: LD_EXP 73
19921: PUSH
19922: LD_INT 2
19924: ARRAY
19925: PUSH
19926: LD_INT 3
19928: ARRAY
19929: EQUAL
19930: IFFALSE 20053
// begin lab := artifactsLabs [ 2 ] ;
19932: LD_ADDR_VAR 0 6
19936: PUSH
19937: LD_EXP 72
19941: PUSH
19942: LD_INT 2
19944: ARRAY
19945: ST_TO_ADDR
// if not lab then
19946: LD_VAR 0 6
19950: NOT
19951: IFFALSE 19955
// exit ;
19953: GO 20892
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19955: LD_VAR 0 6
19959: PPUSH
19960: LD_EXP 70
19964: PUSH
19965: LD_INT 2
19967: ARRAY
19968: PPUSH
19969: LD_INT 1
19971: PPUSH
19972: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19976: LD_EXP 71
19980: PUSH
19981: LD_INT 2
19983: ARRAY
19984: IFFALSE 20004
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19986: LD_VAR 0 6
19990: PPUSH
19991: LD_EXP 71
19995: PUSH
19996: LD_INT 2
19998: ARRAY
19999: PPUSH
20000: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
20004: LD_ADDR_EXP 69
20008: PUSH
20009: LD_EXP 69
20013: PPUSH
20014: LD_INT 2
20016: PPUSH
20017: LD_INT 1
20019: PPUSH
20020: CALL_OW 1
20024: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
20025: LD_INT 7
20027: PPUSH
20028: LD_EXP 73
20032: PUSH
20033: LD_INT 2
20035: ARRAY
20036: PUSH
20037: LD_INT 3
20039: ARRAY
20040: PPUSH
20041: LD_INT 0
20043: PPUSH
20044: LD_VAR 0 6
20048: PPUSH
20049: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20053: LD_VAR 0 2
20057: PUSH
20058: LD_EXP 73
20062: PUSH
20063: LD_INT 3
20065: ARRAY
20066: PUSH
20067: LD_INT 3
20069: ARRAY
20070: EQUAL
20071: IFFALSE 20194
// begin lab := artifactsLabs [ 3 ] ;
20073: LD_ADDR_VAR 0 6
20077: PUSH
20078: LD_EXP 72
20082: PUSH
20083: LD_INT 3
20085: ARRAY
20086: ST_TO_ADDR
// if not lab then
20087: LD_VAR 0 6
20091: NOT
20092: IFFALSE 20096
// exit ;
20094: GO 20892
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20096: LD_VAR 0 6
20100: PPUSH
20101: LD_EXP 70
20105: PUSH
20106: LD_INT 3
20108: ARRAY
20109: PPUSH
20110: LD_INT 1
20112: PPUSH
20113: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20117: LD_EXP 71
20121: PUSH
20122: LD_INT 3
20124: ARRAY
20125: IFFALSE 20145
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20127: LD_VAR 0 6
20131: PPUSH
20132: LD_EXP 71
20136: PUSH
20137: LD_INT 3
20139: ARRAY
20140: PPUSH
20141: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20145: LD_ADDR_EXP 69
20149: PUSH
20150: LD_EXP 69
20154: PPUSH
20155: LD_INT 3
20157: PPUSH
20158: LD_INT 1
20160: PPUSH
20161: CALL_OW 1
20165: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20166: LD_INT 7
20168: PPUSH
20169: LD_EXP 73
20173: PUSH
20174: LD_INT 3
20176: ARRAY
20177: PUSH
20178: LD_INT 3
20180: ARRAY
20181: PPUSH
20182: LD_INT 0
20184: PPUSH
20185: LD_VAR 0 6
20189: PPUSH
20190: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
20194: LD_VAR 0 2
20198: PUSH
20199: LD_EXP 73
20203: PUSH
20204: LD_INT 1
20206: ARRAY
20207: PUSH
20208: LD_INT 1
20210: ARRAY
20211: EQUAL
20212: IFFALSE 20370
// begin lab := artifactsLabs [ 1 ] ;
20214: LD_ADDR_VAR 0 6
20218: PUSH
20219: LD_EXP 72
20223: PUSH
20224: LD_INT 1
20226: ARRAY
20227: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
20228: LD_VAR 0 6
20232: PPUSH
20233: CALL_OW 274
20237: PPUSH
20238: CALL 89630 0 1
20242: PUSH
20243: LD_INT 3
20245: ARRAY
20246: PUSH
20247: LD_EXP 67
20251: PUSH
20252: LD_INT 1
20254: ARRAY
20255: LESS
20256: IFFALSE 20270
// begin HintSpec ( ArtifactCost , 2 ) ;
20258: LD_STRING ArtifactCost
20260: PPUSH
20261: LD_INT 2
20263: PPUSH
20264: CALL_OW 338
// exit ;
20268: GO 20892
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
20270: LD_ADDR_EXP 74
20274: PUSH
20275: LD_EXP 74
20279: PPUSH
20280: LD_INT 1
20282: PPUSH
20283: LD_INT 0
20285: PPUSH
20286: CALL_OW 1
20290: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
20291: LD_VAR 0 3
20295: PPUSH
20296: LD_VAR 0 4
20300: PPUSH
20301: LD_INT 7
20303: PPUSH
20304: LD_INT 12
20306: NEG
20307: PPUSH
20308: CALL_OW 330
// wait ( 0 0$30 ) ;
20312: LD_INT 1050
20314: PPUSH
20315: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
20319: LD_VAR 0 3
20323: PPUSH
20324: LD_VAR 0 4
20328: PPUSH
20329: LD_INT 7
20331: PPUSH
20332: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
20336: LD_EXP 66
20340: PUSH
20341: LD_INT 1
20343: ARRAY
20344: PPUSH
20345: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
20349: LD_ADDR_EXP 74
20353: PUSH
20354: LD_EXP 74
20358: PPUSH
20359: LD_INT 1
20361: PPUSH
20362: LD_INT 1
20364: PPUSH
20365: CALL_OW 1
20369: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
20370: LD_VAR 0 2
20374: PUSH
20375: LD_EXP 73
20379: PUSH
20380: LD_INT 2
20382: ARRAY
20383: PUSH
20384: LD_INT 1
20386: ARRAY
20387: EQUAL
20388: IFFALSE 20625
// begin lab := artifactsLabs [ 2 ] ;
20390: LD_ADDR_VAR 0 6
20394: PUSH
20395: LD_EXP 72
20399: PUSH
20400: LD_INT 2
20402: ARRAY
20403: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
20404: LD_VAR 0 3
20408: PUSH
20409: LD_INT 81
20411: PUSH
20412: LD_INT 7
20414: PUSH
20415: EMPTY
20416: LIST
20417: LIST
20418: PUSH
20419: LD_INT 2
20421: PUSH
20422: LD_INT 32
20424: PUSH
20425: LD_INT 3
20427: PUSH
20428: EMPTY
20429: LIST
20430: LIST
20431: PUSH
20432: LD_INT 30
20434: PUSH
20435: LD_INT 28
20437: PUSH
20438: EMPTY
20439: LIST
20440: LIST
20441: PUSH
20442: LD_INT 30
20444: PUSH
20445: LD_INT 30
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: PUSH
20452: LD_INT 35
20454: PUSH
20455: LD_INT 49
20457: PUSH
20458: EMPTY
20459: LIST
20460: LIST
20461: PUSH
20462: LD_INT 34
20464: PUSH
20465: LD_INT 49
20467: PUSH
20468: EMPTY
20469: LIST
20470: LIST
20471: PUSH
20472: LD_INT 30
20474: PUSH
20475: LD_INT 21
20477: PUSH
20478: EMPTY
20479: LIST
20480: LIST
20481: PUSH
20482: EMPTY
20483: LIST
20484: LIST
20485: LIST
20486: LIST
20487: LIST
20488: LIST
20489: LIST
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PPUSH
20495: CALL_OW 69
20499: IN
20500: NOT
20501: IFFALSE 20505
// exit ;
20503: GO 20892
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
20505: LD_VAR 0 6
20509: PPUSH
20510: CALL_OW 274
20514: PPUSH
20515: CALL 89630 0 1
20519: PUSH
20520: LD_INT 3
20522: ARRAY
20523: PUSH
20524: LD_EXP 67
20528: PUSH
20529: LD_INT 2
20531: ARRAY
20532: LESS
20533: IFFALSE 20547
// begin HintSpec ( ArtifactCost , 2 ) ;
20535: LD_STRING ArtifactCost
20537: PPUSH
20538: LD_INT 2
20540: PPUSH
20541: CALL_OW 338
// exit ;
20545: GO 20892
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
20547: LD_ADDR_EXP 74
20551: PUSH
20552: LD_EXP 74
20556: PPUSH
20557: LD_INT 2
20559: PPUSH
20560: LD_INT 0
20562: PPUSH
20563: CALL_OW 1
20567: ST_TO_ADDR
// KillUnit ( x ) ;
20568: LD_VAR 0 3
20572: PPUSH
20573: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
20577: LD_ADDR_EXP 16
20581: PUSH
20582: LD_EXP 16
20586: PUSH
20587: LD_INT 1
20589: PLUS
20590: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
20591: LD_EXP 66
20595: PUSH
20596: LD_INT 2
20598: ARRAY
20599: PPUSH
20600: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20604: LD_ADDR_EXP 74
20608: PUSH
20609: LD_EXP 74
20613: PPUSH
20614: LD_INT 2
20616: PPUSH
20617: LD_INT 1
20619: PPUSH
20620: CALL_OW 1
20624: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20625: LD_VAR 0 2
20629: PUSH
20630: LD_EXP 73
20634: PUSH
20635: LD_INT 3
20637: ARRAY
20638: PUSH
20639: LD_INT 1
20641: ARRAY
20642: EQUAL
20643: IFFALSE 20892
// begin lab := artifactsLabs [ 3 ] ;
20645: LD_ADDR_VAR 0 6
20649: PUSH
20650: LD_EXP 72
20654: PUSH
20655: LD_INT 3
20657: ARRAY
20658: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20659: LD_VAR 0 6
20663: PPUSH
20664: CALL_OW 274
20668: PPUSH
20669: CALL 89630 0 1
20673: PUSH
20674: LD_INT 3
20676: ARRAY
20677: PUSH
20678: LD_EXP 67
20682: PUSH
20683: LD_INT 3
20685: ARRAY
20686: LESS
20687: IFFALSE 20701
// begin HintSpec ( ArtifactCost , 2 ) ;
20689: LD_STRING ArtifactCost
20691: PPUSH
20692: LD_INT 2
20694: PPUSH
20695: CALL_OW 338
// exit ;
20699: GO 20892
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20701: LD_INT 37
20703: PPUSH
20704: LD_INT 1
20706: PPUSH
20707: CALL_OW 424
// time := 0 0$30 ;
20711: LD_ADDR_VAR 0 7
20715: PUSH
20716: LD_INT 1050
20718: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20719: LD_ADDR_EXP 74
20723: PUSH
20724: LD_EXP 74
20728: PPUSH
20729: LD_INT 3
20731: PPUSH
20732: LD_INT 0
20734: PPUSH
20735: CALL_OW 1
20739: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20740: LD_ADDR_OWVAR 47
20744: PUSH
20745: LD_STRING #Am15a-1
20747: PUSH
20748: LD_VAR 0 7
20752: PUSH
20753: EMPTY
20754: LIST
20755: LIST
20756: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20757: LD_INT 35
20759: PPUSH
20760: CALL_OW 67
// time := time - 0 0$1 ;
20764: LD_ADDR_VAR 0 7
20768: PUSH
20769: LD_VAR 0 7
20773: PUSH
20774: LD_INT 35
20776: MINUS
20777: ST_TO_ADDR
// until time = 0 0$00 ;
20778: LD_VAR 0 7
20782: PUSH
20783: LD_INT 0
20785: EQUAL
20786: IFFALSE 20740
// display_strings :=  ;
20788: LD_ADDR_OWVAR 47
20792: PUSH
20793: LD_STRING 
20795: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20796: LD_INT 37
20798: PPUSH
20799: LD_INT 0
20801: PPUSH
20802: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20806: LD_ADDR_VAR 0 8
20810: PUSH
20811: LD_INT 37
20813: PPUSH
20814: LD_INT 3
20816: PUSH
20817: LD_INT 21
20819: PUSH
20820: LD_INT 3
20822: PUSH
20823: EMPTY
20824: LIST
20825: LIST
20826: PUSH
20827: EMPTY
20828: LIST
20829: LIST
20830: PPUSH
20831: CALL_OW 70
20835: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20836: LD_VAR 0 3
20840: PPUSH
20841: LD_VAR 0 4
20845: PPUSH
20846: CALL_OW 84
// for un in list do
20850: LD_ADDR_VAR 0 9
20854: PUSH
20855: LD_VAR 0 8
20859: PUSH
20860: FOR_IN
20861: IFFALSE 20890
// TeleportUnit ( un , x , y , 12 , true ) ;
20863: LD_VAR 0 9
20867: PPUSH
20868: LD_VAR 0 3
20872: PPUSH
20873: LD_VAR 0 4
20877: PPUSH
20878: LD_INT 12
20880: PPUSH
20881: LD_INT 1
20883: PPUSH
20884: CALL_OW 483
20888: GO 20860
20890: POP
20891: POP
// end ; end ;
20892: PPOPN 9
20894: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20895: LD_INT 0
20897: PPUSH
20898: PPUSH
// begin labNum := 0 ;
20899: LD_ADDR_VAR 0 4
20903: PUSH
20904: LD_INT 0
20906: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20907: LD_ADDR_VAR 0 3
20911: PUSH
20912: DOUBLE
20913: LD_INT 1
20915: DEC
20916: ST_TO_ADDR
20917: LD_EXP 72
20921: PUSH
20922: FOR_TO
20923: IFFALSE 20957
// if artifactsLabs [ i ] = lab then
20925: LD_EXP 72
20929: PUSH
20930: LD_VAR 0 3
20934: ARRAY
20935: PUSH
20936: LD_VAR 0 1
20940: EQUAL
20941: IFFALSE 20955
// begin labNum := i ;
20943: LD_ADDR_VAR 0 4
20947: PUSH
20948: LD_VAR 0 3
20952: ST_TO_ADDR
// break ;
20953: GO 20957
// end ;
20955: GO 20922
20957: POP
20958: POP
// if not labNum then
20959: LD_VAR 0 4
20963: NOT
20964: IFFALSE 20968
// exit ;
20966: GO 21046
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20968: LD_INT 7
20970: PPUSH
20971: LD_EXP 73
20975: PUSH
20976: LD_VAR 0 4
20980: ARRAY
20981: PUSH
20982: LD_INT 3
20984: ARRAY
20985: PPUSH
20986: LD_INT 2
20988: PPUSH
20989: LD_VAR 0 1
20993: PPUSH
20994: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20998: LD_ADDR_EXP 71
21002: PUSH
21003: LD_EXP 71
21007: PPUSH
21008: LD_VAR 0 4
21012: PPUSH
21013: LD_VAR 0 2
21017: PPUSH
21018: CALL_OW 1
21022: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
21023: LD_ADDR_EXP 69
21027: PUSH
21028: LD_EXP 69
21032: PPUSH
21033: LD_VAR 0 4
21037: PPUSH
21038: LD_INT 0
21040: PPUSH
21041: CALL_OW 1
21045: ST_TO_ADDR
// end ;
21046: PPOPN 4
21048: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21049: LD_INT 0
21051: PPUSH
21052: PPUSH
// begin labNum := 0 ;
21053: LD_ADDR_VAR 0 3
21057: PUSH
21058: LD_INT 0
21060: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21061: LD_ADDR_VAR 0 2
21065: PUSH
21066: DOUBLE
21067: LD_INT 1
21069: DEC
21070: ST_TO_ADDR
21071: LD_EXP 72
21075: PUSH
21076: FOR_TO
21077: IFFALSE 21111
// if artifactsLabs [ i ] = lab then
21079: LD_EXP 72
21083: PUSH
21084: LD_VAR 0 2
21088: ARRAY
21089: PUSH
21090: LD_VAR 0 1
21094: EQUAL
21095: IFFALSE 21109
// begin labNum := i ;
21097: LD_ADDR_VAR 0 3
21101: PUSH
21102: LD_VAR 0 2
21106: ST_TO_ADDR
// break ;
21107: GO 21111
// end ;
21109: GO 21076
21111: POP
21112: POP
// if not labNum then
21113: LD_VAR 0 3
21117: NOT
21118: IFFALSE 21122
// exit ;
21120: GO 21284
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21122: LD_INT 7
21124: PPUSH
21125: LD_EXP 73
21129: PUSH
21130: LD_VAR 0 3
21134: ARRAY
21135: PUSH
21136: LD_INT 3
21138: ARRAY
21139: PPUSH
21140: LD_INT 0
21142: PPUSH
21143: LD_VAR 0 1
21147: PPUSH
21148: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21152: LD_ADDR_EXP 68
21156: PUSH
21157: LD_EXP 68
21161: PPUSH
21162: LD_VAR 0 3
21166: PPUSH
21167: LD_INT 1
21169: PPUSH
21170: CALL_OW 1
21174: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
21175: LD_ADDR_EXP 74
21179: PUSH
21180: LD_EXP 74
21184: PPUSH
21185: LD_VAR 0 3
21189: PPUSH
21190: LD_INT 1
21192: PPUSH
21193: CALL_OW 1
21197: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
21198: LD_ADDR_EXP 69
21202: PUSH
21203: LD_EXP 69
21207: PPUSH
21208: LD_VAR 0 3
21212: PPUSH
21213: LD_INT 0
21215: PPUSH
21216: CALL_OW 1
21220: ST_TO_ADDR
// case labNum of 1 :
21221: LD_VAR 0 3
21225: PUSH
21226: LD_INT 1
21228: DOUBLE
21229: EQUAL
21230: IFTRUE 21234
21232: GO 21245
21234: POP
// artifactIResearched := true ; 2 :
21235: LD_ADDR_EXP 12
21239: PUSH
21240: LD_INT 1
21242: ST_TO_ADDR
21243: GO 21284
21245: LD_INT 2
21247: DOUBLE
21248: EQUAL
21249: IFTRUE 21253
21251: GO 21264
21253: POP
// artifactIIResearched := true ; 3 :
21254: LD_ADDR_EXP 13
21258: PUSH
21259: LD_INT 1
21261: ST_TO_ADDR
21262: GO 21284
21264: LD_INT 3
21266: DOUBLE
21267: EQUAL
21268: IFTRUE 21272
21270: GO 21283
21272: POP
// artifactIIIResearched := true ; end ;
21273: LD_ADDR_EXP 14
21277: PUSH
21278: LD_INT 1
21280: ST_TO_ADDR
21281: GO 21284
21283: POP
// end ; end_of_file
21284: PPOPN 3
21286: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
21287: LD_INT 0
21289: PPUSH
21290: PPUSH
// skirmish := false ;
21291: LD_ADDR_EXP 75
21295: PUSH
21296: LD_INT 0
21298: ST_TO_ADDR
// debug_mc := false ;
21299: LD_ADDR_EXP 76
21303: PUSH
21304: LD_INT 0
21306: ST_TO_ADDR
// mc_bases := [ ] ;
21307: LD_ADDR_EXP 77
21311: PUSH
21312: EMPTY
21313: ST_TO_ADDR
// mc_sides := [ ] ;
21314: LD_ADDR_EXP 103
21318: PUSH
21319: EMPTY
21320: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
21321: LD_ADDR_EXP 78
21325: PUSH
21326: EMPTY
21327: ST_TO_ADDR
// mc_building_repairs := [ ] ;
21328: LD_ADDR_EXP 79
21332: PUSH
21333: EMPTY
21334: ST_TO_ADDR
// mc_need_heal := [ ] ;
21335: LD_ADDR_EXP 80
21339: PUSH
21340: EMPTY
21341: ST_TO_ADDR
// mc_healers := [ ] ;
21342: LD_ADDR_EXP 81
21346: PUSH
21347: EMPTY
21348: ST_TO_ADDR
// mc_build_list := [ ] ;
21349: LD_ADDR_EXP 82
21353: PUSH
21354: EMPTY
21355: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
21356: LD_ADDR_EXP 109
21360: PUSH
21361: EMPTY
21362: ST_TO_ADDR
// mc_builders := [ ] ;
21363: LD_ADDR_EXP 83
21367: PUSH
21368: EMPTY
21369: ST_TO_ADDR
// mc_construct_list := [ ] ;
21370: LD_ADDR_EXP 84
21374: PUSH
21375: EMPTY
21376: ST_TO_ADDR
// mc_turret_list := [ ] ;
21377: LD_ADDR_EXP 85
21381: PUSH
21382: EMPTY
21383: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
21384: LD_ADDR_EXP 86
21388: PUSH
21389: EMPTY
21390: ST_TO_ADDR
// mc_miners := [ ] ;
21391: LD_ADDR_EXP 91
21395: PUSH
21396: EMPTY
21397: ST_TO_ADDR
// mc_mines := [ ] ;
21398: LD_ADDR_EXP 90
21402: PUSH
21403: EMPTY
21404: ST_TO_ADDR
// mc_minefields := [ ] ;
21405: LD_ADDR_EXP 92
21409: PUSH
21410: EMPTY
21411: ST_TO_ADDR
// mc_crates := [ ] ;
21412: LD_ADDR_EXP 93
21416: PUSH
21417: EMPTY
21418: ST_TO_ADDR
// mc_crates_collector := [ ] ;
21419: LD_ADDR_EXP 94
21423: PUSH
21424: EMPTY
21425: ST_TO_ADDR
// mc_crates_area := [ ] ;
21426: LD_ADDR_EXP 95
21430: PUSH
21431: EMPTY
21432: ST_TO_ADDR
// mc_vehicles := [ ] ;
21433: LD_ADDR_EXP 96
21437: PUSH
21438: EMPTY
21439: ST_TO_ADDR
// mc_attack := [ ] ;
21440: LD_ADDR_EXP 97
21444: PUSH
21445: EMPTY
21446: ST_TO_ADDR
// mc_produce := [ ] ;
21447: LD_ADDR_EXP 98
21451: PUSH
21452: EMPTY
21453: ST_TO_ADDR
// mc_defender := [ ] ;
21454: LD_ADDR_EXP 99
21458: PUSH
21459: EMPTY
21460: ST_TO_ADDR
// mc_parking := [ ] ;
21461: LD_ADDR_EXP 101
21465: PUSH
21466: EMPTY
21467: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21468: LD_ADDR_EXP 87
21472: PUSH
21473: EMPTY
21474: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21475: LD_ADDR_EXP 89
21479: PUSH
21480: EMPTY
21481: ST_TO_ADDR
// mc_scan := [ ] ;
21482: LD_ADDR_EXP 100
21486: PUSH
21487: EMPTY
21488: ST_TO_ADDR
// mc_scan_area := [ ] ;
21489: LD_ADDR_EXP 102
21493: PUSH
21494: EMPTY
21495: ST_TO_ADDR
// mc_tech := [ ] ;
21496: LD_ADDR_EXP 104
21500: PUSH
21501: EMPTY
21502: ST_TO_ADDR
// mc_class := [ ] ;
21503: LD_ADDR_EXP 118
21507: PUSH
21508: EMPTY
21509: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21510: LD_ADDR_EXP 119
21514: PUSH
21515: EMPTY
21516: ST_TO_ADDR
// mc_is_defending := [ ] ;
21517: LD_ADDR_EXP 120
21521: PUSH
21522: EMPTY
21523: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
21524: LD_ADDR_EXP 111
21528: PUSH
21529: EMPTY
21530: ST_TO_ADDR
// end ;
21531: LD_VAR 0 1
21535: RET
// export function MC_Kill ( base ) ; begin
21536: LD_INT 0
21538: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21539: LD_ADDR_EXP 77
21543: PUSH
21544: LD_EXP 77
21548: PPUSH
21549: LD_VAR 0 1
21553: PPUSH
21554: EMPTY
21555: PPUSH
21556: CALL_OW 1
21560: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21561: LD_ADDR_EXP 78
21565: PUSH
21566: LD_EXP 78
21570: PPUSH
21571: LD_VAR 0 1
21575: PPUSH
21576: EMPTY
21577: PPUSH
21578: CALL_OW 1
21582: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21583: LD_ADDR_EXP 79
21587: PUSH
21588: LD_EXP 79
21592: PPUSH
21593: LD_VAR 0 1
21597: PPUSH
21598: EMPTY
21599: PPUSH
21600: CALL_OW 1
21604: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21605: LD_ADDR_EXP 80
21609: PUSH
21610: LD_EXP 80
21614: PPUSH
21615: LD_VAR 0 1
21619: PPUSH
21620: EMPTY
21621: PPUSH
21622: CALL_OW 1
21626: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21627: LD_ADDR_EXP 81
21631: PUSH
21632: LD_EXP 81
21636: PPUSH
21637: LD_VAR 0 1
21641: PPUSH
21642: EMPTY
21643: PPUSH
21644: CALL_OW 1
21648: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21649: LD_ADDR_EXP 82
21653: PUSH
21654: LD_EXP 82
21658: PPUSH
21659: LD_VAR 0 1
21663: PPUSH
21664: EMPTY
21665: PPUSH
21666: CALL_OW 1
21670: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21671: LD_ADDR_EXP 83
21675: PUSH
21676: LD_EXP 83
21680: PPUSH
21681: LD_VAR 0 1
21685: PPUSH
21686: EMPTY
21687: PPUSH
21688: CALL_OW 1
21692: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21693: LD_ADDR_EXP 84
21697: PUSH
21698: LD_EXP 84
21702: PPUSH
21703: LD_VAR 0 1
21707: PPUSH
21708: EMPTY
21709: PPUSH
21710: CALL_OW 1
21714: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21715: LD_ADDR_EXP 85
21719: PUSH
21720: LD_EXP 85
21724: PPUSH
21725: LD_VAR 0 1
21729: PPUSH
21730: EMPTY
21731: PPUSH
21732: CALL_OW 1
21736: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21737: LD_ADDR_EXP 86
21741: PUSH
21742: LD_EXP 86
21746: PPUSH
21747: LD_VAR 0 1
21751: PPUSH
21752: EMPTY
21753: PPUSH
21754: CALL_OW 1
21758: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21759: LD_ADDR_EXP 87
21763: PUSH
21764: LD_EXP 87
21768: PPUSH
21769: LD_VAR 0 1
21773: PPUSH
21774: EMPTY
21775: PPUSH
21776: CALL_OW 1
21780: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21781: LD_ADDR_EXP 88
21785: PUSH
21786: LD_EXP 88
21790: PPUSH
21791: LD_VAR 0 1
21795: PPUSH
21796: LD_INT 0
21798: PPUSH
21799: CALL_OW 1
21803: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21804: LD_ADDR_EXP 89
21808: PUSH
21809: LD_EXP 89
21813: PPUSH
21814: LD_VAR 0 1
21818: PPUSH
21819: EMPTY
21820: PPUSH
21821: CALL_OW 1
21825: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21826: LD_ADDR_EXP 90
21830: PUSH
21831: LD_EXP 90
21835: PPUSH
21836: LD_VAR 0 1
21840: PPUSH
21841: EMPTY
21842: PPUSH
21843: CALL_OW 1
21847: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21848: LD_ADDR_EXP 91
21852: PUSH
21853: LD_EXP 91
21857: PPUSH
21858: LD_VAR 0 1
21862: PPUSH
21863: EMPTY
21864: PPUSH
21865: CALL_OW 1
21869: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21870: LD_ADDR_EXP 92
21874: PUSH
21875: LD_EXP 92
21879: PPUSH
21880: LD_VAR 0 1
21884: PPUSH
21885: EMPTY
21886: PPUSH
21887: CALL_OW 1
21891: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21892: LD_ADDR_EXP 93
21896: PUSH
21897: LD_EXP 93
21901: PPUSH
21902: LD_VAR 0 1
21906: PPUSH
21907: EMPTY
21908: PPUSH
21909: CALL_OW 1
21913: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21914: LD_ADDR_EXP 94
21918: PUSH
21919: LD_EXP 94
21923: PPUSH
21924: LD_VAR 0 1
21928: PPUSH
21929: EMPTY
21930: PPUSH
21931: CALL_OW 1
21935: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21936: LD_ADDR_EXP 95
21940: PUSH
21941: LD_EXP 95
21945: PPUSH
21946: LD_VAR 0 1
21950: PPUSH
21951: EMPTY
21952: PPUSH
21953: CALL_OW 1
21957: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21958: LD_ADDR_EXP 96
21962: PUSH
21963: LD_EXP 96
21967: PPUSH
21968: LD_VAR 0 1
21972: PPUSH
21973: EMPTY
21974: PPUSH
21975: CALL_OW 1
21979: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21980: LD_ADDR_EXP 97
21984: PUSH
21985: LD_EXP 97
21989: PPUSH
21990: LD_VAR 0 1
21994: PPUSH
21995: EMPTY
21996: PPUSH
21997: CALL_OW 1
22001: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22002: LD_ADDR_EXP 98
22006: PUSH
22007: LD_EXP 98
22011: PPUSH
22012: LD_VAR 0 1
22016: PPUSH
22017: EMPTY
22018: PPUSH
22019: CALL_OW 1
22023: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22024: LD_ADDR_EXP 99
22028: PUSH
22029: LD_EXP 99
22033: PPUSH
22034: LD_VAR 0 1
22038: PPUSH
22039: EMPTY
22040: PPUSH
22041: CALL_OW 1
22045: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22046: LD_ADDR_EXP 100
22050: PUSH
22051: LD_EXP 100
22055: PPUSH
22056: LD_VAR 0 1
22060: PPUSH
22061: EMPTY
22062: PPUSH
22063: CALL_OW 1
22067: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22068: LD_ADDR_EXP 101
22072: PUSH
22073: LD_EXP 101
22077: PPUSH
22078: LD_VAR 0 1
22082: PPUSH
22083: EMPTY
22084: PPUSH
22085: CALL_OW 1
22089: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22090: LD_ADDR_EXP 102
22094: PUSH
22095: LD_EXP 102
22099: PPUSH
22100: LD_VAR 0 1
22104: PPUSH
22105: EMPTY
22106: PPUSH
22107: CALL_OW 1
22111: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22112: LD_ADDR_EXP 104
22116: PUSH
22117: LD_EXP 104
22121: PPUSH
22122: LD_VAR 0 1
22126: PPUSH
22127: EMPTY
22128: PPUSH
22129: CALL_OW 1
22133: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22134: LD_ADDR_EXP 106
22138: PUSH
22139: LD_EXP 106
22143: PPUSH
22144: LD_VAR 0 1
22148: PPUSH
22149: EMPTY
22150: PPUSH
22151: CALL_OW 1
22155: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22156: LD_ADDR_EXP 107
22160: PUSH
22161: LD_EXP 107
22165: PPUSH
22166: LD_VAR 0 1
22170: PPUSH
22171: EMPTY
22172: PPUSH
22173: CALL_OW 1
22177: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22178: LD_ADDR_EXP 108
22182: PUSH
22183: LD_EXP 108
22187: PPUSH
22188: LD_VAR 0 1
22192: PPUSH
22193: EMPTY
22194: PPUSH
22195: CALL_OW 1
22199: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22200: LD_ADDR_EXP 109
22204: PUSH
22205: LD_EXP 109
22209: PPUSH
22210: LD_VAR 0 1
22214: PPUSH
22215: EMPTY
22216: PPUSH
22217: CALL_OW 1
22221: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22222: LD_ADDR_EXP 110
22226: PUSH
22227: LD_EXP 110
22231: PPUSH
22232: LD_VAR 0 1
22236: PPUSH
22237: EMPTY
22238: PPUSH
22239: CALL_OW 1
22243: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22244: LD_ADDR_EXP 111
22248: PUSH
22249: LD_EXP 111
22253: PPUSH
22254: LD_VAR 0 1
22258: PPUSH
22259: EMPTY
22260: PPUSH
22261: CALL_OW 1
22265: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22266: LD_ADDR_EXP 112
22270: PUSH
22271: LD_EXP 112
22275: PPUSH
22276: LD_VAR 0 1
22280: PPUSH
22281: EMPTY
22282: PPUSH
22283: CALL_OW 1
22287: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22288: LD_ADDR_EXP 113
22292: PUSH
22293: LD_EXP 113
22297: PPUSH
22298: LD_VAR 0 1
22302: PPUSH
22303: EMPTY
22304: PPUSH
22305: CALL_OW 1
22309: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22310: LD_ADDR_EXP 114
22314: PUSH
22315: LD_EXP 114
22319: PPUSH
22320: LD_VAR 0 1
22324: PPUSH
22325: EMPTY
22326: PPUSH
22327: CALL_OW 1
22331: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22332: LD_ADDR_EXP 115
22336: PUSH
22337: LD_EXP 115
22341: PPUSH
22342: LD_VAR 0 1
22346: PPUSH
22347: EMPTY
22348: PPUSH
22349: CALL_OW 1
22353: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22354: LD_ADDR_EXP 116
22358: PUSH
22359: LD_EXP 116
22363: PPUSH
22364: LD_VAR 0 1
22368: PPUSH
22369: EMPTY
22370: PPUSH
22371: CALL_OW 1
22375: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22376: LD_ADDR_EXP 117
22380: PUSH
22381: LD_EXP 117
22385: PPUSH
22386: LD_VAR 0 1
22390: PPUSH
22391: EMPTY
22392: PPUSH
22393: CALL_OW 1
22397: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22398: LD_ADDR_EXP 118
22402: PUSH
22403: LD_EXP 118
22407: PPUSH
22408: LD_VAR 0 1
22412: PPUSH
22413: EMPTY
22414: PPUSH
22415: CALL_OW 1
22419: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22420: LD_ADDR_EXP 119
22424: PUSH
22425: LD_EXP 119
22429: PPUSH
22430: LD_VAR 0 1
22434: PPUSH
22435: LD_INT 0
22437: PPUSH
22438: CALL_OW 1
22442: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22443: LD_ADDR_EXP 120
22447: PUSH
22448: LD_EXP 120
22452: PPUSH
22453: LD_VAR 0 1
22457: PPUSH
22458: LD_INT 0
22460: PPUSH
22461: CALL_OW 1
22465: ST_TO_ADDR
// end ;
22466: LD_VAR 0 2
22470: RET
// export function MC_Add ( side , units ) ; var base ; begin
22471: LD_INT 0
22473: PPUSH
22474: PPUSH
// base := mc_bases + 1 ;
22475: LD_ADDR_VAR 0 4
22479: PUSH
22480: LD_EXP 77
22484: PUSH
22485: LD_INT 1
22487: PLUS
22488: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22489: LD_ADDR_EXP 103
22493: PUSH
22494: LD_EXP 103
22498: PPUSH
22499: LD_VAR 0 4
22503: PPUSH
22504: LD_VAR 0 1
22508: PPUSH
22509: CALL_OW 1
22513: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22514: LD_ADDR_EXP 77
22518: PUSH
22519: LD_EXP 77
22523: PPUSH
22524: LD_VAR 0 4
22528: PPUSH
22529: LD_VAR 0 2
22533: PPUSH
22534: CALL_OW 1
22538: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22539: LD_ADDR_EXP 78
22543: PUSH
22544: LD_EXP 78
22548: PPUSH
22549: LD_VAR 0 4
22553: PPUSH
22554: EMPTY
22555: PPUSH
22556: CALL_OW 1
22560: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22561: LD_ADDR_EXP 79
22565: PUSH
22566: LD_EXP 79
22570: PPUSH
22571: LD_VAR 0 4
22575: PPUSH
22576: EMPTY
22577: PPUSH
22578: CALL_OW 1
22582: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22583: LD_ADDR_EXP 80
22587: PUSH
22588: LD_EXP 80
22592: PPUSH
22593: LD_VAR 0 4
22597: PPUSH
22598: EMPTY
22599: PPUSH
22600: CALL_OW 1
22604: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22605: LD_ADDR_EXP 81
22609: PUSH
22610: LD_EXP 81
22614: PPUSH
22615: LD_VAR 0 4
22619: PPUSH
22620: EMPTY
22621: PPUSH
22622: CALL_OW 1
22626: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22627: LD_ADDR_EXP 82
22631: PUSH
22632: LD_EXP 82
22636: PPUSH
22637: LD_VAR 0 4
22641: PPUSH
22642: EMPTY
22643: PPUSH
22644: CALL_OW 1
22648: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22649: LD_ADDR_EXP 83
22653: PUSH
22654: LD_EXP 83
22658: PPUSH
22659: LD_VAR 0 4
22663: PPUSH
22664: EMPTY
22665: PPUSH
22666: CALL_OW 1
22670: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22671: LD_ADDR_EXP 84
22675: PUSH
22676: LD_EXP 84
22680: PPUSH
22681: LD_VAR 0 4
22685: PPUSH
22686: EMPTY
22687: PPUSH
22688: CALL_OW 1
22692: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22693: LD_ADDR_EXP 85
22697: PUSH
22698: LD_EXP 85
22702: PPUSH
22703: LD_VAR 0 4
22707: PPUSH
22708: EMPTY
22709: PPUSH
22710: CALL_OW 1
22714: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22715: LD_ADDR_EXP 86
22719: PUSH
22720: LD_EXP 86
22724: PPUSH
22725: LD_VAR 0 4
22729: PPUSH
22730: EMPTY
22731: PPUSH
22732: CALL_OW 1
22736: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22737: LD_ADDR_EXP 87
22741: PUSH
22742: LD_EXP 87
22746: PPUSH
22747: LD_VAR 0 4
22751: PPUSH
22752: EMPTY
22753: PPUSH
22754: CALL_OW 1
22758: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22759: LD_ADDR_EXP 88
22763: PUSH
22764: LD_EXP 88
22768: PPUSH
22769: LD_VAR 0 4
22773: PPUSH
22774: LD_INT 0
22776: PPUSH
22777: CALL_OW 1
22781: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22782: LD_ADDR_EXP 89
22786: PUSH
22787: LD_EXP 89
22791: PPUSH
22792: LD_VAR 0 4
22796: PPUSH
22797: EMPTY
22798: PPUSH
22799: CALL_OW 1
22803: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22804: LD_ADDR_EXP 90
22808: PUSH
22809: LD_EXP 90
22813: PPUSH
22814: LD_VAR 0 4
22818: PPUSH
22819: EMPTY
22820: PPUSH
22821: CALL_OW 1
22825: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22826: LD_ADDR_EXP 91
22830: PUSH
22831: LD_EXP 91
22835: PPUSH
22836: LD_VAR 0 4
22840: PPUSH
22841: EMPTY
22842: PPUSH
22843: CALL_OW 1
22847: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22848: LD_ADDR_EXP 92
22852: PUSH
22853: LD_EXP 92
22857: PPUSH
22858: LD_VAR 0 4
22862: PPUSH
22863: EMPTY
22864: PPUSH
22865: CALL_OW 1
22869: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22870: LD_ADDR_EXP 93
22874: PUSH
22875: LD_EXP 93
22879: PPUSH
22880: LD_VAR 0 4
22884: PPUSH
22885: EMPTY
22886: PPUSH
22887: CALL_OW 1
22891: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22892: LD_ADDR_EXP 94
22896: PUSH
22897: LD_EXP 94
22901: PPUSH
22902: LD_VAR 0 4
22906: PPUSH
22907: EMPTY
22908: PPUSH
22909: CALL_OW 1
22913: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22914: LD_ADDR_EXP 95
22918: PUSH
22919: LD_EXP 95
22923: PPUSH
22924: LD_VAR 0 4
22928: PPUSH
22929: EMPTY
22930: PPUSH
22931: CALL_OW 1
22935: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22936: LD_ADDR_EXP 96
22940: PUSH
22941: LD_EXP 96
22945: PPUSH
22946: LD_VAR 0 4
22950: PPUSH
22951: EMPTY
22952: PPUSH
22953: CALL_OW 1
22957: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22958: LD_ADDR_EXP 97
22962: PUSH
22963: LD_EXP 97
22967: PPUSH
22968: LD_VAR 0 4
22972: PPUSH
22973: EMPTY
22974: PPUSH
22975: CALL_OW 1
22979: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22980: LD_ADDR_EXP 98
22984: PUSH
22985: LD_EXP 98
22989: PPUSH
22990: LD_VAR 0 4
22994: PPUSH
22995: EMPTY
22996: PPUSH
22997: CALL_OW 1
23001: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23002: LD_ADDR_EXP 99
23006: PUSH
23007: LD_EXP 99
23011: PPUSH
23012: LD_VAR 0 4
23016: PPUSH
23017: EMPTY
23018: PPUSH
23019: CALL_OW 1
23023: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23024: LD_ADDR_EXP 100
23028: PUSH
23029: LD_EXP 100
23033: PPUSH
23034: LD_VAR 0 4
23038: PPUSH
23039: EMPTY
23040: PPUSH
23041: CALL_OW 1
23045: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23046: LD_ADDR_EXP 101
23050: PUSH
23051: LD_EXP 101
23055: PPUSH
23056: LD_VAR 0 4
23060: PPUSH
23061: EMPTY
23062: PPUSH
23063: CALL_OW 1
23067: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23068: LD_ADDR_EXP 102
23072: PUSH
23073: LD_EXP 102
23077: PPUSH
23078: LD_VAR 0 4
23082: PPUSH
23083: EMPTY
23084: PPUSH
23085: CALL_OW 1
23089: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23090: LD_ADDR_EXP 104
23094: PUSH
23095: LD_EXP 104
23099: PPUSH
23100: LD_VAR 0 4
23104: PPUSH
23105: EMPTY
23106: PPUSH
23107: CALL_OW 1
23111: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23112: LD_ADDR_EXP 106
23116: PUSH
23117: LD_EXP 106
23121: PPUSH
23122: LD_VAR 0 4
23126: PPUSH
23127: EMPTY
23128: PPUSH
23129: CALL_OW 1
23133: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23134: LD_ADDR_EXP 107
23138: PUSH
23139: LD_EXP 107
23143: PPUSH
23144: LD_VAR 0 4
23148: PPUSH
23149: EMPTY
23150: PPUSH
23151: CALL_OW 1
23155: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23156: LD_ADDR_EXP 108
23160: PUSH
23161: LD_EXP 108
23165: PPUSH
23166: LD_VAR 0 4
23170: PPUSH
23171: EMPTY
23172: PPUSH
23173: CALL_OW 1
23177: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23178: LD_ADDR_EXP 109
23182: PUSH
23183: LD_EXP 109
23187: PPUSH
23188: LD_VAR 0 4
23192: PPUSH
23193: EMPTY
23194: PPUSH
23195: CALL_OW 1
23199: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23200: LD_ADDR_EXP 110
23204: PUSH
23205: LD_EXP 110
23209: PPUSH
23210: LD_VAR 0 4
23214: PPUSH
23215: EMPTY
23216: PPUSH
23217: CALL_OW 1
23221: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23222: LD_ADDR_EXP 111
23226: PUSH
23227: LD_EXP 111
23231: PPUSH
23232: LD_VAR 0 4
23236: PPUSH
23237: EMPTY
23238: PPUSH
23239: CALL_OW 1
23243: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23244: LD_ADDR_EXP 112
23248: PUSH
23249: LD_EXP 112
23253: PPUSH
23254: LD_VAR 0 4
23258: PPUSH
23259: EMPTY
23260: PPUSH
23261: CALL_OW 1
23265: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23266: LD_ADDR_EXP 113
23270: PUSH
23271: LD_EXP 113
23275: PPUSH
23276: LD_VAR 0 4
23280: PPUSH
23281: EMPTY
23282: PPUSH
23283: CALL_OW 1
23287: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23288: LD_ADDR_EXP 114
23292: PUSH
23293: LD_EXP 114
23297: PPUSH
23298: LD_VAR 0 4
23302: PPUSH
23303: EMPTY
23304: PPUSH
23305: CALL_OW 1
23309: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23310: LD_ADDR_EXP 115
23314: PUSH
23315: LD_EXP 115
23319: PPUSH
23320: LD_VAR 0 4
23324: PPUSH
23325: EMPTY
23326: PPUSH
23327: CALL_OW 1
23331: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23332: LD_ADDR_EXP 116
23336: PUSH
23337: LD_EXP 116
23341: PPUSH
23342: LD_VAR 0 4
23346: PPUSH
23347: EMPTY
23348: PPUSH
23349: CALL_OW 1
23353: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23354: LD_ADDR_EXP 117
23358: PUSH
23359: LD_EXP 117
23363: PPUSH
23364: LD_VAR 0 4
23368: PPUSH
23369: EMPTY
23370: PPUSH
23371: CALL_OW 1
23375: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23376: LD_ADDR_EXP 118
23380: PUSH
23381: LD_EXP 118
23385: PPUSH
23386: LD_VAR 0 4
23390: PPUSH
23391: EMPTY
23392: PPUSH
23393: CALL_OW 1
23397: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23398: LD_ADDR_EXP 119
23402: PUSH
23403: LD_EXP 119
23407: PPUSH
23408: LD_VAR 0 4
23412: PPUSH
23413: LD_INT 0
23415: PPUSH
23416: CALL_OW 1
23420: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23421: LD_ADDR_EXP 120
23425: PUSH
23426: LD_EXP 120
23430: PPUSH
23431: LD_VAR 0 4
23435: PPUSH
23436: LD_INT 0
23438: PPUSH
23439: CALL_OW 1
23443: ST_TO_ADDR
// result := base ;
23444: LD_ADDR_VAR 0 3
23448: PUSH
23449: LD_VAR 0 4
23453: ST_TO_ADDR
// end ;
23454: LD_VAR 0 3
23458: RET
// export function MC_Start ( ) ; var i ; begin
23459: LD_INT 0
23461: PPUSH
23462: PPUSH
// for i = 1 to mc_bases do
23463: LD_ADDR_VAR 0 2
23467: PUSH
23468: DOUBLE
23469: LD_INT 1
23471: DEC
23472: ST_TO_ADDR
23473: LD_EXP 77
23477: PUSH
23478: FOR_TO
23479: IFFALSE 24579
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23481: LD_ADDR_EXP 77
23485: PUSH
23486: LD_EXP 77
23490: PPUSH
23491: LD_VAR 0 2
23495: PPUSH
23496: LD_EXP 77
23500: PUSH
23501: LD_VAR 0 2
23505: ARRAY
23506: PUSH
23507: LD_INT 0
23509: DIFF
23510: PPUSH
23511: CALL_OW 1
23515: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23516: LD_ADDR_EXP 78
23520: PUSH
23521: LD_EXP 78
23525: PPUSH
23526: LD_VAR 0 2
23530: PPUSH
23531: EMPTY
23532: PPUSH
23533: CALL_OW 1
23537: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23538: LD_ADDR_EXP 79
23542: PUSH
23543: LD_EXP 79
23547: PPUSH
23548: LD_VAR 0 2
23552: PPUSH
23553: EMPTY
23554: PPUSH
23555: CALL_OW 1
23559: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23560: LD_ADDR_EXP 80
23564: PUSH
23565: LD_EXP 80
23569: PPUSH
23570: LD_VAR 0 2
23574: PPUSH
23575: EMPTY
23576: PPUSH
23577: CALL_OW 1
23581: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23582: LD_ADDR_EXP 81
23586: PUSH
23587: LD_EXP 81
23591: PPUSH
23592: LD_VAR 0 2
23596: PPUSH
23597: EMPTY
23598: PUSH
23599: EMPTY
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: PPUSH
23605: CALL_OW 1
23609: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23610: LD_ADDR_EXP 82
23614: PUSH
23615: LD_EXP 82
23619: PPUSH
23620: LD_VAR 0 2
23624: PPUSH
23625: EMPTY
23626: PPUSH
23627: CALL_OW 1
23631: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23632: LD_ADDR_EXP 109
23636: PUSH
23637: LD_EXP 109
23641: PPUSH
23642: LD_VAR 0 2
23646: PPUSH
23647: EMPTY
23648: PPUSH
23649: CALL_OW 1
23653: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23654: LD_ADDR_EXP 83
23658: PUSH
23659: LD_EXP 83
23663: PPUSH
23664: LD_VAR 0 2
23668: PPUSH
23669: EMPTY
23670: PPUSH
23671: CALL_OW 1
23675: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23676: LD_ADDR_EXP 84
23680: PUSH
23681: LD_EXP 84
23685: PPUSH
23686: LD_VAR 0 2
23690: PPUSH
23691: EMPTY
23692: PPUSH
23693: CALL_OW 1
23697: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23698: LD_ADDR_EXP 85
23702: PUSH
23703: LD_EXP 85
23707: PPUSH
23708: LD_VAR 0 2
23712: PPUSH
23713: LD_EXP 77
23717: PUSH
23718: LD_VAR 0 2
23722: ARRAY
23723: PPUSH
23724: LD_INT 2
23726: PUSH
23727: LD_INT 30
23729: PUSH
23730: LD_INT 32
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: PUSH
23737: LD_INT 30
23739: PUSH
23740: LD_INT 33
23742: PUSH
23743: EMPTY
23744: LIST
23745: LIST
23746: PUSH
23747: EMPTY
23748: LIST
23749: LIST
23750: LIST
23751: PPUSH
23752: CALL_OW 72
23756: PPUSH
23757: CALL_OW 1
23761: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23762: LD_ADDR_EXP 86
23766: PUSH
23767: LD_EXP 86
23771: PPUSH
23772: LD_VAR 0 2
23776: PPUSH
23777: LD_EXP 77
23781: PUSH
23782: LD_VAR 0 2
23786: ARRAY
23787: PPUSH
23788: LD_INT 2
23790: PUSH
23791: LD_INT 30
23793: PUSH
23794: LD_INT 32
23796: PUSH
23797: EMPTY
23798: LIST
23799: LIST
23800: PUSH
23801: LD_INT 30
23803: PUSH
23804: LD_INT 31
23806: PUSH
23807: EMPTY
23808: LIST
23809: LIST
23810: PUSH
23811: EMPTY
23812: LIST
23813: LIST
23814: LIST
23815: PUSH
23816: LD_INT 58
23818: PUSH
23819: EMPTY
23820: LIST
23821: PUSH
23822: EMPTY
23823: LIST
23824: LIST
23825: PPUSH
23826: CALL_OW 72
23830: PPUSH
23831: CALL_OW 1
23835: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23836: LD_ADDR_EXP 87
23840: PUSH
23841: LD_EXP 87
23845: PPUSH
23846: LD_VAR 0 2
23850: PPUSH
23851: EMPTY
23852: PPUSH
23853: CALL_OW 1
23857: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23858: LD_ADDR_EXP 91
23862: PUSH
23863: LD_EXP 91
23867: PPUSH
23868: LD_VAR 0 2
23872: PPUSH
23873: EMPTY
23874: PPUSH
23875: CALL_OW 1
23879: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23880: LD_ADDR_EXP 90
23884: PUSH
23885: LD_EXP 90
23889: PPUSH
23890: LD_VAR 0 2
23894: PPUSH
23895: EMPTY
23896: PPUSH
23897: CALL_OW 1
23901: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23902: LD_ADDR_EXP 92
23906: PUSH
23907: LD_EXP 92
23911: PPUSH
23912: LD_VAR 0 2
23916: PPUSH
23917: EMPTY
23918: PPUSH
23919: CALL_OW 1
23923: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23924: LD_ADDR_EXP 93
23928: PUSH
23929: LD_EXP 93
23933: PPUSH
23934: LD_VAR 0 2
23938: PPUSH
23939: EMPTY
23940: PPUSH
23941: CALL_OW 1
23945: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23946: LD_ADDR_EXP 94
23950: PUSH
23951: LD_EXP 94
23955: PPUSH
23956: LD_VAR 0 2
23960: PPUSH
23961: EMPTY
23962: PPUSH
23963: CALL_OW 1
23967: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23968: LD_ADDR_EXP 95
23972: PUSH
23973: LD_EXP 95
23977: PPUSH
23978: LD_VAR 0 2
23982: PPUSH
23983: EMPTY
23984: PPUSH
23985: CALL_OW 1
23989: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23990: LD_ADDR_EXP 96
23994: PUSH
23995: LD_EXP 96
23999: PPUSH
24000: LD_VAR 0 2
24004: PPUSH
24005: EMPTY
24006: PPUSH
24007: CALL_OW 1
24011: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24012: LD_ADDR_EXP 97
24016: PUSH
24017: LD_EXP 97
24021: PPUSH
24022: LD_VAR 0 2
24026: PPUSH
24027: EMPTY
24028: PPUSH
24029: CALL_OW 1
24033: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24034: LD_ADDR_EXP 98
24038: PUSH
24039: LD_EXP 98
24043: PPUSH
24044: LD_VAR 0 2
24048: PPUSH
24049: EMPTY
24050: PPUSH
24051: CALL_OW 1
24055: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24056: LD_ADDR_EXP 99
24060: PUSH
24061: LD_EXP 99
24065: PPUSH
24066: LD_VAR 0 2
24070: PPUSH
24071: EMPTY
24072: PPUSH
24073: CALL_OW 1
24077: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24078: LD_ADDR_EXP 88
24082: PUSH
24083: LD_EXP 88
24087: PPUSH
24088: LD_VAR 0 2
24092: PPUSH
24093: LD_INT 0
24095: PPUSH
24096: CALL_OW 1
24100: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24101: LD_ADDR_EXP 101
24105: PUSH
24106: LD_EXP 101
24110: PPUSH
24111: LD_VAR 0 2
24115: PPUSH
24116: LD_INT 0
24118: PPUSH
24119: CALL_OW 1
24123: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24124: LD_ADDR_EXP 89
24128: PUSH
24129: LD_EXP 89
24133: PPUSH
24134: LD_VAR 0 2
24138: PPUSH
24139: EMPTY
24140: PPUSH
24141: CALL_OW 1
24145: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24146: LD_ADDR_EXP 100
24150: PUSH
24151: LD_EXP 100
24155: PPUSH
24156: LD_VAR 0 2
24160: PPUSH
24161: LD_INT 0
24163: PPUSH
24164: CALL_OW 1
24168: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
24169: LD_ADDR_EXP 102
24173: PUSH
24174: LD_EXP 102
24178: PPUSH
24179: LD_VAR 0 2
24183: PPUSH
24184: EMPTY
24185: PPUSH
24186: CALL_OW 1
24190: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
24191: LD_ADDR_EXP 105
24195: PUSH
24196: LD_EXP 105
24200: PPUSH
24201: LD_VAR 0 2
24205: PPUSH
24206: LD_INT 0
24208: PPUSH
24209: CALL_OW 1
24213: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
24214: LD_ADDR_EXP 106
24218: PUSH
24219: LD_EXP 106
24223: PPUSH
24224: LD_VAR 0 2
24228: PPUSH
24229: EMPTY
24230: PPUSH
24231: CALL_OW 1
24235: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
24236: LD_ADDR_EXP 107
24240: PUSH
24241: LD_EXP 107
24245: PPUSH
24246: LD_VAR 0 2
24250: PPUSH
24251: EMPTY
24252: PPUSH
24253: CALL_OW 1
24257: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24258: LD_ADDR_EXP 108
24262: PUSH
24263: LD_EXP 108
24267: PPUSH
24268: LD_VAR 0 2
24272: PPUSH
24273: EMPTY
24274: PPUSH
24275: CALL_OW 1
24279: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
24280: LD_ADDR_EXP 110
24284: PUSH
24285: LD_EXP 110
24289: PPUSH
24290: LD_VAR 0 2
24294: PPUSH
24295: LD_EXP 77
24299: PUSH
24300: LD_VAR 0 2
24304: ARRAY
24305: PPUSH
24306: LD_INT 2
24308: PUSH
24309: LD_INT 30
24311: PUSH
24312: LD_INT 6
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: PUSH
24319: LD_INT 30
24321: PUSH
24322: LD_INT 7
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: PUSH
24329: LD_INT 30
24331: PUSH
24332: LD_INT 8
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: EMPTY
24340: LIST
24341: LIST
24342: LIST
24343: LIST
24344: PPUSH
24345: CALL_OW 72
24349: PPUSH
24350: CALL_OW 1
24354: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
24355: LD_ADDR_EXP 111
24359: PUSH
24360: LD_EXP 111
24364: PPUSH
24365: LD_VAR 0 2
24369: PPUSH
24370: EMPTY
24371: PPUSH
24372: CALL_OW 1
24376: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
24377: LD_ADDR_EXP 112
24381: PUSH
24382: LD_EXP 112
24386: PPUSH
24387: LD_VAR 0 2
24391: PPUSH
24392: EMPTY
24393: PPUSH
24394: CALL_OW 1
24398: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
24399: LD_ADDR_EXP 113
24403: PUSH
24404: LD_EXP 113
24408: PPUSH
24409: LD_VAR 0 2
24413: PPUSH
24414: EMPTY
24415: PPUSH
24416: CALL_OW 1
24420: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
24421: LD_ADDR_EXP 114
24425: PUSH
24426: LD_EXP 114
24430: PPUSH
24431: LD_VAR 0 2
24435: PPUSH
24436: EMPTY
24437: PPUSH
24438: CALL_OW 1
24442: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24443: LD_ADDR_EXP 115
24447: PUSH
24448: LD_EXP 115
24452: PPUSH
24453: LD_VAR 0 2
24457: PPUSH
24458: EMPTY
24459: PPUSH
24460: CALL_OW 1
24464: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24465: LD_ADDR_EXP 116
24469: PUSH
24470: LD_EXP 116
24474: PPUSH
24475: LD_VAR 0 2
24479: PPUSH
24480: EMPTY
24481: PPUSH
24482: CALL_OW 1
24486: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24487: LD_ADDR_EXP 117
24491: PUSH
24492: LD_EXP 117
24496: PPUSH
24497: LD_VAR 0 2
24501: PPUSH
24502: EMPTY
24503: PPUSH
24504: CALL_OW 1
24508: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24509: LD_ADDR_EXP 118
24513: PUSH
24514: LD_EXP 118
24518: PPUSH
24519: LD_VAR 0 2
24523: PPUSH
24524: EMPTY
24525: PPUSH
24526: CALL_OW 1
24530: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24531: LD_ADDR_EXP 119
24535: PUSH
24536: LD_EXP 119
24540: PPUSH
24541: LD_VAR 0 2
24545: PPUSH
24546: LD_INT 0
24548: PPUSH
24549: CALL_OW 1
24553: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24554: LD_ADDR_EXP 120
24558: PUSH
24559: LD_EXP 120
24563: PPUSH
24564: LD_VAR 0 2
24568: PPUSH
24569: LD_INT 0
24571: PPUSH
24572: CALL_OW 1
24576: ST_TO_ADDR
// end ;
24577: GO 23478
24579: POP
24580: POP
// MC_InitSides ( ) ;
24581: CALL 24867 0 0
// MC_InitResearch ( ) ;
24585: CALL 24606 0 0
// CustomInitMacro ( ) ;
24589: CALL 228 0 0
// skirmish := true ;
24593: LD_ADDR_EXP 75
24597: PUSH
24598: LD_INT 1
24600: ST_TO_ADDR
// end ;
24601: LD_VAR 0 1
24605: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24606: LD_INT 0
24608: PPUSH
24609: PPUSH
24610: PPUSH
24611: PPUSH
24612: PPUSH
24613: PPUSH
// if not mc_bases then
24614: LD_EXP 77
24618: NOT
24619: IFFALSE 24623
// exit ;
24621: GO 24862
// for i = 1 to 8 do
24623: LD_ADDR_VAR 0 2
24627: PUSH
24628: DOUBLE
24629: LD_INT 1
24631: DEC
24632: ST_TO_ADDR
24633: LD_INT 8
24635: PUSH
24636: FOR_TO
24637: IFFALSE 24663
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24639: LD_ADDR_EXP 104
24643: PUSH
24644: LD_EXP 104
24648: PPUSH
24649: LD_VAR 0 2
24653: PPUSH
24654: EMPTY
24655: PPUSH
24656: CALL_OW 1
24660: ST_TO_ADDR
24661: GO 24636
24663: POP
24664: POP
// tmp := [ ] ;
24665: LD_ADDR_VAR 0 5
24669: PUSH
24670: EMPTY
24671: ST_TO_ADDR
// for i = 1 to mc_sides do
24672: LD_ADDR_VAR 0 2
24676: PUSH
24677: DOUBLE
24678: LD_INT 1
24680: DEC
24681: ST_TO_ADDR
24682: LD_EXP 103
24686: PUSH
24687: FOR_TO
24688: IFFALSE 24746
// if not mc_sides [ i ] in tmp then
24690: LD_EXP 103
24694: PUSH
24695: LD_VAR 0 2
24699: ARRAY
24700: PUSH
24701: LD_VAR 0 5
24705: IN
24706: NOT
24707: IFFALSE 24744
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24709: LD_ADDR_VAR 0 5
24713: PUSH
24714: LD_VAR 0 5
24718: PPUSH
24719: LD_VAR 0 5
24723: PUSH
24724: LD_INT 1
24726: PLUS
24727: PPUSH
24728: LD_EXP 103
24732: PUSH
24733: LD_VAR 0 2
24737: ARRAY
24738: PPUSH
24739: CALL_OW 2
24743: ST_TO_ADDR
24744: GO 24687
24746: POP
24747: POP
// if not tmp then
24748: LD_VAR 0 5
24752: NOT
24753: IFFALSE 24757
// exit ;
24755: GO 24862
// for j in tmp do
24757: LD_ADDR_VAR 0 3
24761: PUSH
24762: LD_VAR 0 5
24766: PUSH
24767: FOR_IN
24768: IFFALSE 24860
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24770: LD_ADDR_VAR 0 6
24774: PUSH
24775: LD_INT 22
24777: PUSH
24778: LD_VAR 0 3
24782: PUSH
24783: EMPTY
24784: LIST
24785: LIST
24786: PPUSH
24787: CALL_OW 69
24791: ST_TO_ADDR
// if not un then
24792: LD_VAR 0 6
24796: NOT
24797: IFFALSE 24801
// continue ;
24799: GO 24767
// nation := GetNation ( un [ 1 ] ) ;
24801: LD_ADDR_VAR 0 4
24805: PUSH
24806: LD_VAR 0 6
24810: PUSH
24811: LD_INT 1
24813: ARRAY
24814: PPUSH
24815: CALL_OW 248
24819: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24820: LD_ADDR_EXP 104
24824: PUSH
24825: LD_EXP 104
24829: PPUSH
24830: LD_VAR 0 3
24834: PPUSH
24835: LD_VAR 0 3
24839: PPUSH
24840: LD_VAR 0 4
24844: PPUSH
24845: LD_INT 1
24847: PPUSH
24848: CALL 52014 0 3
24852: PPUSH
24853: CALL_OW 1
24857: ST_TO_ADDR
// end ;
24858: GO 24767
24860: POP
24861: POP
// end ;
24862: LD_VAR 0 1
24866: RET
// export function MC_InitSides ( ) ; var i ; begin
24867: LD_INT 0
24869: PPUSH
24870: PPUSH
// if not mc_bases then
24871: LD_EXP 77
24875: NOT
24876: IFFALSE 24880
// exit ;
24878: GO 24954
// for i = 1 to mc_bases do
24880: LD_ADDR_VAR 0 2
24884: PUSH
24885: DOUBLE
24886: LD_INT 1
24888: DEC
24889: ST_TO_ADDR
24890: LD_EXP 77
24894: PUSH
24895: FOR_TO
24896: IFFALSE 24952
// if mc_bases [ i ] then
24898: LD_EXP 77
24902: PUSH
24903: LD_VAR 0 2
24907: ARRAY
24908: IFFALSE 24950
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24910: LD_ADDR_EXP 103
24914: PUSH
24915: LD_EXP 103
24919: PPUSH
24920: LD_VAR 0 2
24924: PPUSH
24925: LD_EXP 77
24929: PUSH
24930: LD_VAR 0 2
24934: ARRAY
24935: PUSH
24936: LD_INT 1
24938: ARRAY
24939: PPUSH
24940: CALL_OW 255
24944: PPUSH
24945: CALL_OW 1
24949: ST_TO_ADDR
24950: GO 24895
24952: POP
24953: POP
// end ;
24954: LD_VAR 0 1
24958: RET
// every 0 0$03 trigger skirmish do
24959: LD_EXP 75
24963: IFFALSE 25117
24965: GO 24967
24967: DISABLE
// begin enable ;
24968: ENABLE
// MC_CheckBuildings ( ) ;
24969: CALL 29615 0 0
// MC_CheckPeopleLife ( ) ;
24973: CALL 29776 0 0
// RaiseSailEvent ( 100 ) ;
24977: LD_INT 100
24979: PPUSH
24980: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24984: LD_INT 103
24986: PPUSH
24987: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24991: LD_INT 104
24993: PPUSH
24994: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24998: LD_INT 105
25000: PPUSH
25001: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25005: LD_INT 106
25007: PPUSH
25008: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25012: LD_INT 107
25014: PPUSH
25015: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25019: LD_INT 108
25021: PPUSH
25022: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25026: LD_INT 109
25028: PPUSH
25029: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25033: LD_INT 110
25035: PPUSH
25036: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25040: LD_INT 111
25042: PPUSH
25043: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25047: LD_INT 112
25049: PPUSH
25050: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25054: LD_INT 113
25056: PPUSH
25057: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25061: LD_INT 120
25063: PPUSH
25064: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25068: LD_INT 121
25070: PPUSH
25071: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25075: LD_INT 122
25077: PPUSH
25078: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25082: LD_INT 123
25084: PPUSH
25085: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25089: LD_INT 124
25091: PPUSH
25092: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25096: LD_INT 125
25098: PPUSH
25099: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25103: LD_INT 126
25105: PPUSH
25106: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25110: LD_INT 200
25112: PPUSH
25113: CALL_OW 427
// end ;
25117: END
// on SailEvent ( event ) do begin if event < 100 then
25118: LD_VAR 0 1
25122: PUSH
25123: LD_INT 100
25125: LESS
25126: IFFALSE 25137
// CustomEvent ( event ) ;
25128: LD_VAR 0 1
25132: PPUSH
25133: CALL 10949 0 1
// if event = 100 then
25137: LD_VAR 0 1
25141: PUSH
25142: LD_INT 100
25144: EQUAL
25145: IFFALSE 25151
// MC_ClassManager ( ) ;
25147: CALL 25543 0 0
// if event = 101 then
25151: LD_VAR 0 1
25155: PUSH
25156: LD_INT 101
25158: EQUAL
25159: IFFALSE 25165
// MC_RepairBuildings ( ) ;
25161: CALL 30361 0 0
// if event = 102 then
25165: LD_VAR 0 1
25169: PUSH
25170: LD_INT 102
25172: EQUAL
25173: IFFALSE 25179
// MC_Heal ( ) ;
25175: CALL 31296 0 0
// if event = 103 then
25179: LD_VAR 0 1
25183: PUSH
25184: LD_INT 103
25186: EQUAL
25187: IFFALSE 25193
// MC_Build ( ) ;
25189: CALL 31718 0 0
// if event = 104 then
25193: LD_VAR 0 1
25197: PUSH
25198: LD_INT 104
25200: EQUAL
25201: IFFALSE 25207
// MC_TurretWeapon ( ) ;
25203: CALL 33352 0 0
// if event = 105 then
25207: LD_VAR 0 1
25211: PUSH
25212: LD_INT 105
25214: EQUAL
25215: IFFALSE 25221
// MC_BuildUpgrade ( ) ;
25217: CALL 32903 0 0
// if event = 106 then
25221: LD_VAR 0 1
25225: PUSH
25226: LD_INT 106
25228: EQUAL
25229: IFFALSE 25235
// MC_PlantMines ( ) ;
25231: CALL 33782 0 0
// if event = 107 then
25235: LD_VAR 0 1
25239: PUSH
25240: LD_INT 107
25242: EQUAL
25243: IFFALSE 25249
// MC_CollectCrates ( ) ;
25245: CALL 34573 0 0
// if event = 108 then
25249: LD_VAR 0 1
25253: PUSH
25254: LD_INT 108
25256: EQUAL
25257: IFFALSE 25263
// MC_LinkRemoteControl ( ) ;
25259: CALL 36423 0 0
// if event = 109 then
25263: LD_VAR 0 1
25267: PUSH
25268: LD_INT 109
25270: EQUAL
25271: IFFALSE 25277
// MC_ProduceVehicle ( ) ;
25273: CALL 36604 0 0
// if event = 110 then
25277: LD_VAR 0 1
25281: PUSH
25282: LD_INT 110
25284: EQUAL
25285: IFFALSE 25291
// MC_SendAttack ( ) ;
25287: CALL 37070 0 0
// if event = 111 then
25291: LD_VAR 0 1
25295: PUSH
25296: LD_INT 111
25298: EQUAL
25299: IFFALSE 25305
// MC_Defend ( ) ;
25301: CALL 37178 0 0
// if event = 112 then
25305: LD_VAR 0 1
25309: PUSH
25310: LD_INT 112
25312: EQUAL
25313: IFFALSE 25319
// MC_Research ( ) ;
25315: CALL 38058 0 0
// if event = 113 then
25319: LD_VAR 0 1
25323: PUSH
25324: LD_INT 113
25326: EQUAL
25327: IFFALSE 25333
// MC_MinesTrigger ( ) ;
25329: CALL 39172 0 0
// if event = 120 then
25333: LD_VAR 0 1
25337: PUSH
25338: LD_INT 120
25340: EQUAL
25341: IFFALSE 25347
// MC_RepairVehicle ( ) ;
25343: CALL 39271 0 0
// if event = 121 then
25347: LD_VAR 0 1
25351: PUSH
25352: LD_INT 121
25354: EQUAL
25355: IFFALSE 25361
// MC_TameApe ( ) ;
25357: CALL 40040 0 0
// if event = 122 then
25361: LD_VAR 0 1
25365: PUSH
25366: LD_INT 122
25368: EQUAL
25369: IFFALSE 25375
// MC_ChangeApeClass ( ) ;
25371: CALL 40869 0 0
// if event = 123 then
25375: LD_VAR 0 1
25379: PUSH
25380: LD_INT 123
25382: EQUAL
25383: IFFALSE 25389
// MC_Bazooka ( ) ;
25385: CALL 41519 0 0
// if event = 124 then
25389: LD_VAR 0 1
25393: PUSH
25394: LD_INT 124
25396: EQUAL
25397: IFFALSE 25403
// MC_TeleportExit ( ) ;
25399: CALL 41717 0 0
// if event = 125 then
25403: LD_VAR 0 1
25407: PUSH
25408: LD_INT 125
25410: EQUAL
25411: IFFALSE 25417
// MC_Deposits ( ) ;
25413: CALL 42364 0 0
// if event = 126 then
25417: LD_VAR 0 1
25421: PUSH
25422: LD_INT 126
25424: EQUAL
25425: IFFALSE 25431
// MC_RemoteDriver ( ) ;
25427: CALL 42989 0 0
// if event = 200 then
25431: LD_VAR 0 1
25435: PUSH
25436: LD_INT 200
25438: EQUAL
25439: IFFALSE 25445
// MC_Idle ( ) ;
25441: CALL 44938 0 0
// end ;
25445: PPOPN 1
25447: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25448: LD_INT 0
25450: PPUSH
25451: PPUSH
// if not mc_bases [ base ] or not tag then
25452: LD_EXP 77
25456: PUSH
25457: LD_VAR 0 1
25461: ARRAY
25462: NOT
25463: PUSH
25464: LD_VAR 0 2
25468: NOT
25469: OR
25470: IFFALSE 25474
// exit ;
25472: GO 25538
// for i in mc_bases [ base ] union mc_ape [ base ] do
25474: LD_ADDR_VAR 0 4
25478: PUSH
25479: LD_EXP 77
25483: PUSH
25484: LD_VAR 0 1
25488: ARRAY
25489: PUSH
25490: LD_EXP 106
25494: PUSH
25495: LD_VAR 0 1
25499: ARRAY
25500: UNION
25501: PUSH
25502: FOR_IN
25503: IFFALSE 25536
// if GetTag ( i ) = tag then
25505: LD_VAR 0 4
25509: PPUSH
25510: CALL_OW 110
25514: PUSH
25515: LD_VAR 0 2
25519: EQUAL
25520: IFFALSE 25534
// SetTag ( i , 0 ) ;
25522: LD_VAR 0 4
25526: PPUSH
25527: LD_INT 0
25529: PPUSH
25530: CALL_OW 109
25534: GO 25502
25536: POP
25537: POP
// end ;
25538: LD_VAR 0 3
25542: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25543: LD_INT 0
25545: PPUSH
25546: PPUSH
25547: PPUSH
25548: PPUSH
25549: PPUSH
25550: PPUSH
25551: PPUSH
25552: PPUSH
// if not mc_bases then
25553: LD_EXP 77
25557: NOT
25558: IFFALSE 25562
// exit ;
25560: GO 26020
// for i = 1 to mc_bases do
25562: LD_ADDR_VAR 0 2
25566: PUSH
25567: DOUBLE
25568: LD_INT 1
25570: DEC
25571: ST_TO_ADDR
25572: LD_EXP 77
25576: PUSH
25577: FOR_TO
25578: IFFALSE 26018
// begin tmp := MC_ClassCheckReq ( i ) ;
25580: LD_ADDR_VAR 0 4
25584: PUSH
25585: LD_VAR 0 2
25589: PPUSH
25590: CALL 26025 0 1
25594: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25595: LD_ADDR_EXP 118
25599: PUSH
25600: LD_EXP 118
25604: PPUSH
25605: LD_VAR 0 2
25609: PPUSH
25610: LD_VAR 0 4
25614: PPUSH
25615: CALL_OW 1
25619: ST_TO_ADDR
// if not tmp then
25620: LD_VAR 0 4
25624: NOT
25625: IFFALSE 25629
// continue ;
25627: GO 25577
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25629: LD_ADDR_VAR 0 6
25633: PUSH
25634: LD_EXP 77
25638: PUSH
25639: LD_VAR 0 2
25643: ARRAY
25644: PPUSH
25645: LD_INT 2
25647: PUSH
25648: LD_INT 30
25650: PUSH
25651: LD_INT 4
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: LD_INT 30
25660: PUSH
25661: LD_INT 5
25663: PUSH
25664: EMPTY
25665: LIST
25666: LIST
25667: PUSH
25668: EMPTY
25669: LIST
25670: LIST
25671: LIST
25672: PPUSH
25673: CALL_OW 72
25677: PUSH
25678: LD_EXP 77
25682: PUSH
25683: LD_VAR 0 2
25687: ARRAY
25688: PPUSH
25689: LD_INT 2
25691: PUSH
25692: LD_INT 30
25694: PUSH
25695: LD_INT 0
25697: PUSH
25698: EMPTY
25699: LIST
25700: LIST
25701: PUSH
25702: LD_INT 30
25704: PUSH
25705: LD_INT 1
25707: PUSH
25708: EMPTY
25709: LIST
25710: LIST
25711: PUSH
25712: EMPTY
25713: LIST
25714: LIST
25715: LIST
25716: PPUSH
25717: CALL_OW 72
25721: PUSH
25722: LD_EXP 77
25726: PUSH
25727: LD_VAR 0 2
25731: ARRAY
25732: PPUSH
25733: LD_INT 30
25735: PUSH
25736: LD_INT 3
25738: PUSH
25739: EMPTY
25740: LIST
25741: LIST
25742: PPUSH
25743: CALL_OW 72
25747: PUSH
25748: LD_EXP 77
25752: PUSH
25753: LD_VAR 0 2
25757: ARRAY
25758: PPUSH
25759: LD_INT 2
25761: PUSH
25762: LD_INT 30
25764: PUSH
25765: LD_INT 6
25767: PUSH
25768: EMPTY
25769: LIST
25770: LIST
25771: PUSH
25772: LD_INT 30
25774: PUSH
25775: LD_INT 7
25777: PUSH
25778: EMPTY
25779: LIST
25780: LIST
25781: PUSH
25782: LD_INT 30
25784: PUSH
25785: LD_INT 8
25787: PUSH
25788: EMPTY
25789: LIST
25790: LIST
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: LIST
25796: LIST
25797: PPUSH
25798: CALL_OW 72
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: LIST
25807: LIST
25808: ST_TO_ADDR
// for j = 1 to 4 do
25809: LD_ADDR_VAR 0 3
25813: PUSH
25814: DOUBLE
25815: LD_INT 1
25817: DEC
25818: ST_TO_ADDR
25819: LD_INT 4
25821: PUSH
25822: FOR_TO
25823: IFFALSE 26014
// begin if not tmp [ j ] then
25825: LD_VAR 0 4
25829: PUSH
25830: LD_VAR 0 3
25834: ARRAY
25835: NOT
25836: IFFALSE 25840
// continue ;
25838: GO 25822
// for p in tmp [ j ] do
25840: LD_ADDR_VAR 0 5
25844: PUSH
25845: LD_VAR 0 4
25849: PUSH
25850: LD_VAR 0 3
25854: ARRAY
25855: PUSH
25856: FOR_IN
25857: IFFALSE 26010
// begin if not b [ j ] then
25859: LD_VAR 0 6
25863: PUSH
25864: LD_VAR 0 3
25868: ARRAY
25869: NOT
25870: IFFALSE 25874
// break ;
25872: GO 26010
// e := 0 ;
25874: LD_ADDR_VAR 0 7
25878: PUSH
25879: LD_INT 0
25881: ST_TO_ADDR
// for k in b [ j ] do
25882: LD_ADDR_VAR 0 8
25886: PUSH
25887: LD_VAR 0 6
25891: PUSH
25892: LD_VAR 0 3
25896: ARRAY
25897: PUSH
25898: FOR_IN
25899: IFFALSE 25926
// if IsNotFull ( k ) then
25901: LD_VAR 0 8
25905: PPUSH
25906: CALL 54167 0 1
25910: IFFALSE 25924
// begin e := k ;
25912: LD_ADDR_VAR 0 7
25916: PUSH
25917: LD_VAR 0 8
25921: ST_TO_ADDR
// break ;
25922: GO 25926
// end ;
25924: GO 25898
25926: POP
25927: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25928: LD_VAR 0 7
25932: PUSH
25933: LD_VAR 0 5
25937: PPUSH
25938: LD_VAR 0 7
25942: PPUSH
25943: CALL 88046 0 2
25947: NOT
25948: AND
25949: IFFALSE 26008
// begin if IsInUnit ( p ) then
25951: LD_VAR 0 5
25955: PPUSH
25956: CALL_OW 310
25960: IFFALSE 25971
// ComExitBuilding ( p ) ;
25962: LD_VAR 0 5
25966: PPUSH
25967: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25971: LD_VAR 0 5
25975: PPUSH
25976: LD_VAR 0 7
25980: PPUSH
25981: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25985: LD_VAR 0 5
25989: PPUSH
25990: LD_VAR 0 3
25994: PPUSH
25995: CALL_OW 183
// AddComExitBuilding ( p ) ;
25999: LD_VAR 0 5
26003: PPUSH
26004: CALL_OW 182
// end ; end ;
26008: GO 25856
26010: POP
26011: POP
// end ;
26012: GO 25822
26014: POP
26015: POP
// end ;
26016: GO 25577
26018: POP
26019: POP
// end ;
26020: LD_VAR 0 1
26024: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26025: LD_INT 0
26027: PPUSH
26028: PPUSH
26029: PPUSH
26030: PPUSH
26031: PPUSH
26032: PPUSH
26033: PPUSH
26034: PPUSH
26035: PPUSH
26036: PPUSH
26037: PPUSH
26038: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26039: LD_VAR 0 1
26043: NOT
26044: PUSH
26045: LD_EXP 77
26049: PUSH
26050: LD_VAR 0 1
26054: ARRAY
26055: NOT
26056: OR
26057: PUSH
26058: LD_EXP 77
26062: PUSH
26063: LD_VAR 0 1
26067: ARRAY
26068: PPUSH
26069: LD_INT 2
26071: PUSH
26072: LD_INT 30
26074: PUSH
26075: LD_INT 0
26077: PUSH
26078: EMPTY
26079: LIST
26080: LIST
26081: PUSH
26082: LD_INT 30
26084: PUSH
26085: LD_INT 1
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: EMPTY
26093: LIST
26094: LIST
26095: LIST
26096: PPUSH
26097: CALL_OW 72
26101: NOT
26102: OR
26103: IFFALSE 26107
// exit ;
26105: GO 29610
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26107: LD_ADDR_VAR 0 4
26111: PUSH
26112: LD_EXP 77
26116: PUSH
26117: LD_VAR 0 1
26121: ARRAY
26122: PPUSH
26123: LD_INT 2
26125: PUSH
26126: LD_INT 25
26128: PUSH
26129: LD_INT 1
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PUSH
26136: LD_INT 25
26138: PUSH
26139: LD_INT 2
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PUSH
26146: LD_INT 25
26148: PUSH
26149: LD_INT 3
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: PUSH
26156: LD_INT 25
26158: PUSH
26159: LD_INT 4
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: LD_INT 25
26168: PUSH
26169: LD_INT 5
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 25
26178: PUSH
26179: LD_INT 8
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: PUSH
26186: LD_INT 25
26188: PUSH
26189: LD_INT 9
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: PUSH
26196: EMPTY
26197: LIST
26198: LIST
26199: LIST
26200: LIST
26201: LIST
26202: LIST
26203: LIST
26204: LIST
26205: PPUSH
26206: CALL_OW 72
26210: ST_TO_ADDR
// if not tmp then
26211: LD_VAR 0 4
26215: NOT
26216: IFFALSE 26220
// exit ;
26218: GO 29610
// for i in tmp do
26220: LD_ADDR_VAR 0 3
26224: PUSH
26225: LD_VAR 0 4
26229: PUSH
26230: FOR_IN
26231: IFFALSE 26262
// if GetTag ( i ) then
26233: LD_VAR 0 3
26237: PPUSH
26238: CALL_OW 110
26242: IFFALSE 26260
// tmp := tmp diff i ;
26244: LD_ADDR_VAR 0 4
26248: PUSH
26249: LD_VAR 0 4
26253: PUSH
26254: LD_VAR 0 3
26258: DIFF
26259: ST_TO_ADDR
26260: GO 26230
26262: POP
26263: POP
// if not tmp then
26264: LD_VAR 0 4
26268: NOT
26269: IFFALSE 26273
// exit ;
26271: GO 29610
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26273: LD_ADDR_VAR 0 5
26277: PUSH
26278: LD_EXP 77
26282: PUSH
26283: LD_VAR 0 1
26287: ARRAY
26288: PPUSH
26289: LD_INT 2
26291: PUSH
26292: LD_INT 25
26294: PUSH
26295: LD_INT 1
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: PUSH
26302: LD_INT 25
26304: PUSH
26305: LD_INT 5
26307: PUSH
26308: EMPTY
26309: LIST
26310: LIST
26311: PUSH
26312: LD_INT 25
26314: PUSH
26315: LD_INT 8
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: PUSH
26322: LD_INT 25
26324: PUSH
26325: LD_INT 9
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: LIST
26336: LIST
26337: LIST
26338: PPUSH
26339: CALL_OW 72
26343: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
26344: LD_ADDR_VAR 0 6
26348: PUSH
26349: LD_EXP 77
26353: PUSH
26354: LD_VAR 0 1
26358: ARRAY
26359: PPUSH
26360: LD_INT 25
26362: PUSH
26363: LD_INT 2
26365: PUSH
26366: EMPTY
26367: LIST
26368: LIST
26369: PPUSH
26370: CALL_OW 72
26374: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
26375: LD_ADDR_VAR 0 7
26379: PUSH
26380: LD_EXP 77
26384: PUSH
26385: LD_VAR 0 1
26389: ARRAY
26390: PPUSH
26391: LD_INT 25
26393: PUSH
26394: LD_INT 3
26396: PUSH
26397: EMPTY
26398: LIST
26399: LIST
26400: PPUSH
26401: CALL_OW 72
26405: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
26406: LD_ADDR_VAR 0 8
26410: PUSH
26411: LD_EXP 77
26415: PUSH
26416: LD_VAR 0 1
26420: ARRAY
26421: PPUSH
26422: LD_INT 25
26424: PUSH
26425: LD_INT 4
26427: PUSH
26428: EMPTY
26429: LIST
26430: LIST
26431: PUSH
26432: LD_INT 24
26434: PUSH
26435: LD_INT 251
26437: PUSH
26438: EMPTY
26439: LIST
26440: LIST
26441: PUSH
26442: EMPTY
26443: LIST
26444: LIST
26445: PPUSH
26446: CALL_OW 72
26450: ST_TO_ADDR
// if mc_is_defending [ base ] then
26451: LD_EXP 120
26455: PUSH
26456: LD_VAR 0 1
26460: ARRAY
26461: IFFALSE 26922
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26463: LD_ADDR_EXP 119
26467: PUSH
26468: LD_EXP 119
26472: PPUSH
26473: LD_VAR 0 1
26477: PPUSH
26478: LD_INT 4
26480: PPUSH
26481: CALL_OW 1
26485: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26486: LD_ADDR_VAR 0 12
26490: PUSH
26491: LD_EXP 77
26495: PUSH
26496: LD_VAR 0 1
26500: ARRAY
26501: PPUSH
26502: LD_INT 2
26504: PUSH
26505: LD_INT 30
26507: PUSH
26508: LD_INT 4
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 30
26517: PUSH
26518: LD_INT 5
26520: PUSH
26521: EMPTY
26522: LIST
26523: LIST
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: LIST
26529: PPUSH
26530: CALL_OW 72
26534: ST_TO_ADDR
// if not b then
26535: LD_VAR 0 12
26539: NOT
26540: IFFALSE 26544
// exit ;
26542: GO 29610
// p := [ ] ;
26544: LD_ADDR_VAR 0 11
26548: PUSH
26549: EMPTY
26550: ST_TO_ADDR
// if sci >= 2 then
26551: LD_VAR 0 8
26555: PUSH
26556: LD_INT 2
26558: GREATEREQUAL
26559: IFFALSE 26590
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26561: LD_ADDR_VAR 0 8
26565: PUSH
26566: LD_VAR 0 8
26570: PUSH
26571: LD_INT 1
26573: ARRAY
26574: PUSH
26575: LD_VAR 0 8
26579: PUSH
26580: LD_INT 2
26582: ARRAY
26583: PUSH
26584: EMPTY
26585: LIST
26586: LIST
26587: ST_TO_ADDR
26588: GO 26651
// if sci = 1 then
26590: LD_VAR 0 8
26594: PUSH
26595: LD_INT 1
26597: EQUAL
26598: IFFALSE 26619
// sci := [ sci [ 1 ] ] else
26600: LD_ADDR_VAR 0 8
26604: PUSH
26605: LD_VAR 0 8
26609: PUSH
26610: LD_INT 1
26612: ARRAY
26613: PUSH
26614: EMPTY
26615: LIST
26616: ST_TO_ADDR
26617: GO 26651
// if sci = 0 then
26619: LD_VAR 0 8
26623: PUSH
26624: LD_INT 0
26626: EQUAL
26627: IFFALSE 26651
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26629: LD_ADDR_VAR 0 11
26633: PUSH
26634: LD_VAR 0 4
26638: PPUSH
26639: LD_INT 4
26641: PPUSH
26642: CALL 87909 0 2
26646: PUSH
26647: LD_INT 1
26649: ARRAY
26650: ST_TO_ADDR
// if eng > 4 then
26651: LD_VAR 0 6
26655: PUSH
26656: LD_INT 4
26658: GREATER
26659: IFFALSE 26705
// for i = eng downto 4 do
26661: LD_ADDR_VAR 0 3
26665: PUSH
26666: DOUBLE
26667: LD_VAR 0 6
26671: INC
26672: ST_TO_ADDR
26673: LD_INT 4
26675: PUSH
26676: FOR_DOWNTO
26677: IFFALSE 26703
// eng := eng diff eng [ i ] ;
26679: LD_ADDR_VAR 0 6
26683: PUSH
26684: LD_VAR 0 6
26688: PUSH
26689: LD_VAR 0 6
26693: PUSH
26694: LD_VAR 0 3
26698: ARRAY
26699: DIFF
26700: ST_TO_ADDR
26701: GO 26676
26703: POP
26704: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26705: LD_ADDR_VAR 0 4
26709: PUSH
26710: LD_VAR 0 4
26714: PUSH
26715: LD_VAR 0 5
26719: PUSH
26720: LD_VAR 0 6
26724: UNION
26725: PUSH
26726: LD_VAR 0 7
26730: UNION
26731: PUSH
26732: LD_VAR 0 8
26736: UNION
26737: DIFF
26738: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26739: LD_ADDR_VAR 0 13
26743: PUSH
26744: LD_EXP 77
26748: PUSH
26749: LD_VAR 0 1
26753: ARRAY
26754: PPUSH
26755: LD_INT 2
26757: PUSH
26758: LD_INT 30
26760: PUSH
26761: LD_INT 32
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: PUSH
26768: LD_INT 30
26770: PUSH
26771: LD_INT 31
26773: PUSH
26774: EMPTY
26775: LIST
26776: LIST
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: PPUSH
26783: CALL_OW 72
26787: PUSH
26788: LD_EXP 77
26792: PUSH
26793: LD_VAR 0 1
26797: ARRAY
26798: PPUSH
26799: LD_INT 2
26801: PUSH
26802: LD_INT 30
26804: PUSH
26805: LD_INT 4
26807: PUSH
26808: EMPTY
26809: LIST
26810: LIST
26811: PUSH
26812: LD_INT 30
26814: PUSH
26815: LD_INT 5
26817: PUSH
26818: EMPTY
26819: LIST
26820: LIST
26821: PUSH
26822: EMPTY
26823: LIST
26824: LIST
26825: LIST
26826: PPUSH
26827: CALL_OW 72
26831: PUSH
26832: LD_INT 6
26834: MUL
26835: PLUS
26836: ST_TO_ADDR
// if bcount < tmp then
26837: LD_VAR 0 13
26841: PUSH
26842: LD_VAR 0 4
26846: LESS
26847: IFFALSE 26893
// for i = tmp downto bcount do
26849: LD_ADDR_VAR 0 3
26853: PUSH
26854: DOUBLE
26855: LD_VAR 0 4
26859: INC
26860: ST_TO_ADDR
26861: LD_VAR 0 13
26865: PUSH
26866: FOR_DOWNTO
26867: IFFALSE 26891
// tmp := Delete ( tmp , tmp ) ;
26869: LD_ADDR_VAR 0 4
26873: PUSH
26874: LD_VAR 0 4
26878: PPUSH
26879: LD_VAR 0 4
26883: PPUSH
26884: CALL_OW 3
26888: ST_TO_ADDR
26889: GO 26866
26891: POP
26892: POP
// result := [ tmp , 0 , 0 , p ] ;
26893: LD_ADDR_VAR 0 2
26897: PUSH
26898: LD_VAR 0 4
26902: PUSH
26903: LD_INT 0
26905: PUSH
26906: LD_INT 0
26908: PUSH
26909: LD_VAR 0 11
26913: PUSH
26914: EMPTY
26915: LIST
26916: LIST
26917: LIST
26918: LIST
26919: ST_TO_ADDR
// exit ;
26920: GO 29610
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26922: LD_EXP 77
26926: PUSH
26927: LD_VAR 0 1
26931: ARRAY
26932: PPUSH
26933: LD_INT 2
26935: PUSH
26936: LD_INT 30
26938: PUSH
26939: LD_INT 6
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 30
26948: PUSH
26949: LD_INT 7
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: LD_INT 30
26958: PUSH
26959: LD_INT 8
26961: PUSH
26962: EMPTY
26963: LIST
26964: LIST
26965: PUSH
26966: EMPTY
26967: LIST
26968: LIST
26969: LIST
26970: LIST
26971: PPUSH
26972: CALL_OW 72
26976: NOT
26977: PUSH
26978: LD_EXP 77
26982: PUSH
26983: LD_VAR 0 1
26987: ARRAY
26988: PPUSH
26989: LD_INT 30
26991: PUSH
26992: LD_INT 3
26994: PUSH
26995: EMPTY
26996: LIST
26997: LIST
26998: PPUSH
26999: CALL_OW 72
27003: NOT
27004: AND
27005: IFFALSE 27077
// begin if eng = tmp then
27007: LD_VAR 0 6
27011: PUSH
27012: LD_VAR 0 4
27016: EQUAL
27017: IFFALSE 27021
// exit ;
27019: GO 29610
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27021: LD_ADDR_EXP 119
27025: PUSH
27026: LD_EXP 119
27030: PPUSH
27031: LD_VAR 0 1
27035: PPUSH
27036: LD_INT 1
27038: PPUSH
27039: CALL_OW 1
27043: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27044: LD_ADDR_VAR 0 2
27048: PUSH
27049: LD_INT 0
27051: PUSH
27052: LD_VAR 0 4
27056: PUSH
27057: LD_VAR 0 6
27061: DIFF
27062: PUSH
27063: LD_INT 0
27065: PUSH
27066: LD_INT 0
27068: PUSH
27069: EMPTY
27070: LIST
27071: LIST
27072: LIST
27073: LIST
27074: ST_TO_ADDR
// exit ;
27075: GO 29610
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27077: LD_EXP 104
27081: PUSH
27082: LD_EXP 103
27086: PUSH
27087: LD_VAR 0 1
27091: ARRAY
27092: ARRAY
27093: PUSH
27094: LD_EXP 77
27098: PUSH
27099: LD_VAR 0 1
27103: ARRAY
27104: PPUSH
27105: LD_INT 2
27107: PUSH
27108: LD_INT 30
27110: PUSH
27111: LD_INT 6
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: LD_INT 30
27120: PUSH
27121: LD_INT 7
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PUSH
27128: LD_INT 30
27130: PUSH
27131: LD_INT 8
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: PUSH
27138: EMPTY
27139: LIST
27140: LIST
27141: LIST
27142: LIST
27143: PPUSH
27144: CALL_OW 72
27148: AND
27149: PUSH
27150: LD_EXP 77
27154: PUSH
27155: LD_VAR 0 1
27159: ARRAY
27160: PPUSH
27161: LD_INT 30
27163: PUSH
27164: LD_INT 3
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PPUSH
27171: CALL_OW 72
27175: NOT
27176: AND
27177: IFFALSE 27391
// begin if sci >= 6 then
27179: LD_VAR 0 8
27183: PUSH
27184: LD_INT 6
27186: GREATEREQUAL
27187: IFFALSE 27191
// exit ;
27189: GO 29610
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
27191: LD_ADDR_EXP 119
27195: PUSH
27196: LD_EXP 119
27200: PPUSH
27201: LD_VAR 0 1
27205: PPUSH
27206: LD_INT 2
27208: PPUSH
27209: CALL_OW 1
27213: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
27214: LD_ADDR_VAR 0 9
27218: PUSH
27219: LD_VAR 0 4
27223: PUSH
27224: LD_VAR 0 8
27228: DIFF
27229: PPUSH
27230: LD_INT 4
27232: PPUSH
27233: CALL 87909 0 2
27237: ST_TO_ADDR
// p := [ ] ;
27238: LD_ADDR_VAR 0 11
27242: PUSH
27243: EMPTY
27244: ST_TO_ADDR
// if sci < 6 and sort > 6 then
27245: LD_VAR 0 8
27249: PUSH
27250: LD_INT 6
27252: LESS
27253: PUSH
27254: LD_VAR 0 9
27258: PUSH
27259: LD_INT 6
27261: GREATER
27262: AND
27263: IFFALSE 27344
// begin for i = 1 to 6 - sci do
27265: LD_ADDR_VAR 0 3
27269: PUSH
27270: DOUBLE
27271: LD_INT 1
27273: DEC
27274: ST_TO_ADDR
27275: LD_INT 6
27277: PUSH
27278: LD_VAR 0 8
27282: MINUS
27283: PUSH
27284: FOR_TO
27285: IFFALSE 27340
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
27287: LD_ADDR_VAR 0 11
27291: PUSH
27292: LD_VAR 0 11
27296: PPUSH
27297: LD_VAR 0 11
27301: PUSH
27302: LD_INT 1
27304: PLUS
27305: PPUSH
27306: LD_VAR 0 9
27310: PUSH
27311: LD_INT 1
27313: ARRAY
27314: PPUSH
27315: CALL_OW 2
27319: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
27320: LD_ADDR_VAR 0 9
27324: PUSH
27325: LD_VAR 0 9
27329: PPUSH
27330: LD_INT 1
27332: PPUSH
27333: CALL_OW 3
27337: ST_TO_ADDR
// end ;
27338: GO 27284
27340: POP
27341: POP
// end else
27342: GO 27364
// if sort then
27344: LD_VAR 0 9
27348: IFFALSE 27364
// p := sort [ 1 ] ;
27350: LD_ADDR_VAR 0 11
27354: PUSH
27355: LD_VAR 0 9
27359: PUSH
27360: LD_INT 1
27362: ARRAY
27363: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
27364: LD_ADDR_VAR 0 2
27368: PUSH
27369: LD_INT 0
27371: PUSH
27372: LD_INT 0
27374: PUSH
27375: LD_INT 0
27377: PUSH
27378: LD_VAR 0 11
27382: PUSH
27383: EMPTY
27384: LIST
27385: LIST
27386: LIST
27387: LIST
27388: ST_TO_ADDR
// exit ;
27389: GO 29610
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27391: LD_EXP 104
27395: PUSH
27396: LD_EXP 103
27400: PUSH
27401: LD_VAR 0 1
27405: ARRAY
27406: ARRAY
27407: PUSH
27408: LD_EXP 77
27412: PUSH
27413: LD_VAR 0 1
27417: ARRAY
27418: PPUSH
27419: LD_INT 2
27421: PUSH
27422: LD_INT 30
27424: PUSH
27425: LD_INT 6
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 30
27434: PUSH
27435: LD_INT 7
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: PUSH
27442: LD_INT 30
27444: PUSH
27445: LD_INT 8
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: PUSH
27452: EMPTY
27453: LIST
27454: LIST
27455: LIST
27456: LIST
27457: PPUSH
27458: CALL_OW 72
27462: AND
27463: PUSH
27464: LD_EXP 77
27468: PUSH
27469: LD_VAR 0 1
27473: ARRAY
27474: PPUSH
27475: LD_INT 30
27477: PUSH
27478: LD_INT 3
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: PPUSH
27485: CALL_OW 72
27489: AND
27490: IFFALSE 28224
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27492: LD_ADDR_EXP 119
27496: PUSH
27497: LD_EXP 119
27501: PPUSH
27502: LD_VAR 0 1
27506: PPUSH
27507: LD_INT 3
27509: PPUSH
27510: CALL_OW 1
27514: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27515: LD_ADDR_VAR 0 2
27519: PUSH
27520: LD_INT 0
27522: PUSH
27523: LD_INT 0
27525: PUSH
27526: LD_INT 0
27528: PUSH
27529: LD_INT 0
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: LIST
27536: LIST
27537: ST_TO_ADDR
// if not eng then
27538: LD_VAR 0 6
27542: NOT
27543: IFFALSE 27606
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27545: LD_ADDR_VAR 0 11
27549: PUSH
27550: LD_VAR 0 4
27554: PPUSH
27555: LD_INT 2
27557: PPUSH
27558: CALL 87909 0 2
27562: PUSH
27563: LD_INT 1
27565: ARRAY
27566: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27567: LD_ADDR_VAR 0 2
27571: PUSH
27572: LD_VAR 0 2
27576: PPUSH
27577: LD_INT 2
27579: PPUSH
27580: LD_VAR 0 11
27584: PPUSH
27585: CALL_OW 1
27589: ST_TO_ADDR
// tmp := tmp diff p ;
27590: LD_ADDR_VAR 0 4
27594: PUSH
27595: LD_VAR 0 4
27599: PUSH
27600: LD_VAR 0 11
27604: DIFF
27605: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27606: LD_VAR 0 4
27610: PUSH
27611: LD_VAR 0 8
27615: PUSH
27616: LD_INT 6
27618: LESS
27619: AND
27620: IFFALSE 27808
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27622: LD_ADDR_VAR 0 9
27626: PUSH
27627: LD_VAR 0 4
27631: PUSH
27632: LD_VAR 0 8
27636: PUSH
27637: LD_VAR 0 7
27641: UNION
27642: DIFF
27643: PPUSH
27644: LD_INT 4
27646: PPUSH
27647: CALL 87909 0 2
27651: ST_TO_ADDR
// p := [ ] ;
27652: LD_ADDR_VAR 0 11
27656: PUSH
27657: EMPTY
27658: ST_TO_ADDR
// if sort then
27659: LD_VAR 0 9
27663: IFFALSE 27779
// for i = 1 to 6 - sci do
27665: LD_ADDR_VAR 0 3
27669: PUSH
27670: DOUBLE
27671: LD_INT 1
27673: DEC
27674: ST_TO_ADDR
27675: LD_INT 6
27677: PUSH
27678: LD_VAR 0 8
27682: MINUS
27683: PUSH
27684: FOR_TO
27685: IFFALSE 27777
// begin if i = sort then
27687: LD_VAR 0 3
27691: PUSH
27692: LD_VAR 0 9
27696: EQUAL
27697: IFFALSE 27701
// break ;
27699: GO 27777
// if GetClass ( i ) = 4 then
27701: LD_VAR 0 3
27705: PPUSH
27706: CALL_OW 257
27710: PUSH
27711: LD_INT 4
27713: EQUAL
27714: IFFALSE 27718
// continue ;
27716: GO 27684
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27718: LD_ADDR_VAR 0 11
27722: PUSH
27723: LD_VAR 0 11
27727: PPUSH
27728: LD_VAR 0 11
27732: PUSH
27733: LD_INT 1
27735: PLUS
27736: PPUSH
27737: LD_VAR 0 9
27741: PUSH
27742: LD_VAR 0 3
27746: ARRAY
27747: PPUSH
27748: CALL_OW 2
27752: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27753: LD_ADDR_VAR 0 4
27757: PUSH
27758: LD_VAR 0 4
27762: PUSH
27763: LD_VAR 0 9
27767: PUSH
27768: LD_VAR 0 3
27772: ARRAY
27773: DIFF
27774: ST_TO_ADDR
// end ;
27775: GO 27684
27777: POP
27778: POP
// if p then
27779: LD_VAR 0 11
27783: IFFALSE 27808
// result := Replace ( result , 4 , p ) ;
27785: LD_ADDR_VAR 0 2
27789: PUSH
27790: LD_VAR 0 2
27794: PPUSH
27795: LD_INT 4
27797: PPUSH
27798: LD_VAR 0 11
27802: PPUSH
27803: CALL_OW 1
27807: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27808: LD_VAR 0 4
27812: PUSH
27813: LD_VAR 0 7
27817: PUSH
27818: LD_INT 6
27820: LESS
27821: AND
27822: IFFALSE 28010
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27824: LD_ADDR_VAR 0 9
27828: PUSH
27829: LD_VAR 0 4
27833: PUSH
27834: LD_VAR 0 8
27838: PUSH
27839: LD_VAR 0 7
27843: UNION
27844: DIFF
27845: PPUSH
27846: LD_INT 3
27848: PPUSH
27849: CALL 87909 0 2
27853: ST_TO_ADDR
// p := [ ] ;
27854: LD_ADDR_VAR 0 11
27858: PUSH
27859: EMPTY
27860: ST_TO_ADDR
// if sort then
27861: LD_VAR 0 9
27865: IFFALSE 27981
// for i = 1 to 6 - mech do
27867: LD_ADDR_VAR 0 3
27871: PUSH
27872: DOUBLE
27873: LD_INT 1
27875: DEC
27876: ST_TO_ADDR
27877: LD_INT 6
27879: PUSH
27880: LD_VAR 0 7
27884: MINUS
27885: PUSH
27886: FOR_TO
27887: IFFALSE 27979
// begin if i = sort then
27889: LD_VAR 0 3
27893: PUSH
27894: LD_VAR 0 9
27898: EQUAL
27899: IFFALSE 27903
// break ;
27901: GO 27979
// if GetClass ( i ) = 3 then
27903: LD_VAR 0 3
27907: PPUSH
27908: CALL_OW 257
27912: PUSH
27913: LD_INT 3
27915: EQUAL
27916: IFFALSE 27920
// continue ;
27918: GO 27886
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27920: LD_ADDR_VAR 0 11
27924: PUSH
27925: LD_VAR 0 11
27929: PPUSH
27930: LD_VAR 0 11
27934: PUSH
27935: LD_INT 1
27937: PLUS
27938: PPUSH
27939: LD_VAR 0 9
27943: PUSH
27944: LD_VAR 0 3
27948: ARRAY
27949: PPUSH
27950: CALL_OW 2
27954: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27955: LD_ADDR_VAR 0 4
27959: PUSH
27960: LD_VAR 0 4
27964: PUSH
27965: LD_VAR 0 9
27969: PUSH
27970: LD_VAR 0 3
27974: ARRAY
27975: DIFF
27976: ST_TO_ADDR
// end ;
27977: GO 27886
27979: POP
27980: POP
// if p then
27981: LD_VAR 0 11
27985: IFFALSE 28010
// result := Replace ( result , 3 , p ) ;
27987: LD_ADDR_VAR 0 2
27991: PUSH
27992: LD_VAR 0 2
27996: PPUSH
27997: LD_INT 3
27999: PPUSH
28000: LD_VAR 0 11
28004: PPUSH
28005: CALL_OW 1
28009: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28010: LD_VAR 0 4
28014: PUSH
28015: LD_INT 6
28017: GREATER
28018: PUSH
28019: LD_VAR 0 6
28023: PUSH
28024: LD_INT 6
28026: LESS
28027: AND
28028: IFFALSE 28222
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28030: LD_ADDR_VAR 0 9
28034: PUSH
28035: LD_VAR 0 4
28039: PUSH
28040: LD_VAR 0 8
28044: PUSH
28045: LD_VAR 0 7
28049: UNION
28050: PUSH
28051: LD_VAR 0 6
28055: UNION
28056: DIFF
28057: PPUSH
28058: LD_INT 2
28060: PPUSH
28061: CALL 87909 0 2
28065: ST_TO_ADDR
// p := [ ] ;
28066: LD_ADDR_VAR 0 11
28070: PUSH
28071: EMPTY
28072: ST_TO_ADDR
// if sort then
28073: LD_VAR 0 9
28077: IFFALSE 28193
// for i = 1 to 6 - eng do
28079: LD_ADDR_VAR 0 3
28083: PUSH
28084: DOUBLE
28085: LD_INT 1
28087: DEC
28088: ST_TO_ADDR
28089: LD_INT 6
28091: PUSH
28092: LD_VAR 0 6
28096: MINUS
28097: PUSH
28098: FOR_TO
28099: IFFALSE 28191
// begin if i = sort then
28101: LD_VAR 0 3
28105: PUSH
28106: LD_VAR 0 9
28110: EQUAL
28111: IFFALSE 28115
// break ;
28113: GO 28191
// if GetClass ( i ) = 2 then
28115: LD_VAR 0 3
28119: PPUSH
28120: CALL_OW 257
28124: PUSH
28125: LD_INT 2
28127: EQUAL
28128: IFFALSE 28132
// continue ;
28130: GO 28098
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28132: LD_ADDR_VAR 0 11
28136: PUSH
28137: LD_VAR 0 11
28141: PPUSH
28142: LD_VAR 0 11
28146: PUSH
28147: LD_INT 1
28149: PLUS
28150: PPUSH
28151: LD_VAR 0 9
28155: PUSH
28156: LD_VAR 0 3
28160: ARRAY
28161: PPUSH
28162: CALL_OW 2
28166: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28167: LD_ADDR_VAR 0 4
28171: PUSH
28172: LD_VAR 0 4
28176: PUSH
28177: LD_VAR 0 9
28181: PUSH
28182: LD_VAR 0 3
28186: ARRAY
28187: DIFF
28188: ST_TO_ADDR
// end ;
28189: GO 28098
28191: POP
28192: POP
// if p then
28193: LD_VAR 0 11
28197: IFFALSE 28222
// result := Replace ( result , 2 , p ) ;
28199: LD_ADDR_VAR 0 2
28203: PUSH
28204: LD_VAR 0 2
28208: PPUSH
28209: LD_INT 2
28211: PPUSH
28212: LD_VAR 0 11
28216: PPUSH
28217: CALL_OW 1
28221: ST_TO_ADDR
// end ; exit ;
28222: GO 29610
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
28224: LD_EXP 104
28228: PUSH
28229: LD_EXP 103
28233: PUSH
28234: LD_VAR 0 1
28238: ARRAY
28239: ARRAY
28240: NOT
28241: PUSH
28242: LD_EXP 77
28246: PUSH
28247: LD_VAR 0 1
28251: ARRAY
28252: PPUSH
28253: LD_INT 30
28255: PUSH
28256: LD_INT 3
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PPUSH
28263: CALL_OW 72
28267: AND
28268: PUSH
28269: LD_EXP 82
28273: PUSH
28274: LD_VAR 0 1
28278: ARRAY
28279: AND
28280: IFFALSE 28888
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
28282: LD_ADDR_EXP 119
28286: PUSH
28287: LD_EXP 119
28291: PPUSH
28292: LD_VAR 0 1
28296: PPUSH
28297: LD_INT 5
28299: PPUSH
28300: CALL_OW 1
28304: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28305: LD_ADDR_VAR 0 2
28309: PUSH
28310: LD_INT 0
28312: PUSH
28313: LD_INT 0
28315: PUSH
28316: LD_INT 0
28318: PUSH
28319: LD_INT 0
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: LIST
28326: LIST
28327: ST_TO_ADDR
// if sci > 1 then
28328: LD_VAR 0 8
28332: PUSH
28333: LD_INT 1
28335: GREATER
28336: IFFALSE 28364
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
28338: LD_ADDR_VAR 0 4
28342: PUSH
28343: LD_VAR 0 4
28347: PUSH
28348: LD_VAR 0 8
28352: PUSH
28353: LD_VAR 0 8
28357: PUSH
28358: LD_INT 1
28360: ARRAY
28361: DIFF
28362: DIFF
28363: ST_TO_ADDR
// if tmp and not sci then
28364: LD_VAR 0 4
28368: PUSH
28369: LD_VAR 0 8
28373: NOT
28374: AND
28375: IFFALSE 28444
// begin sort := SortBySkill ( tmp , 4 ) ;
28377: LD_ADDR_VAR 0 9
28381: PUSH
28382: LD_VAR 0 4
28386: PPUSH
28387: LD_INT 4
28389: PPUSH
28390: CALL 87909 0 2
28394: ST_TO_ADDR
// if sort then
28395: LD_VAR 0 9
28399: IFFALSE 28415
// p := sort [ 1 ] ;
28401: LD_ADDR_VAR 0 11
28405: PUSH
28406: LD_VAR 0 9
28410: PUSH
28411: LD_INT 1
28413: ARRAY
28414: ST_TO_ADDR
// if p then
28415: LD_VAR 0 11
28419: IFFALSE 28444
// result := Replace ( result , 4 , p ) ;
28421: LD_ADDR_VAR 0 2
28425: PUSH
28426: LD_VAR 0 2
28430: PPUSH
28431: LD_INT 4
28433: PPUSH
28434: LD_VAR 0 11
28438: PPUSH
28439: CALL_OW 1
28443: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28444: LD_ADDR_VAR 0 4
28448: PUSH
28449: LD_VAR 0 4
28453: PUSH
28454: LD_VAR 0 7
28458: DIFF
28459: ST_TO_ADDR
// if tmp and mech < 6 then
28460: LD_VAR 0 4
28464: PUSH
28465: LD_VAR 0 7
28469: PUSH
28470: LD_INT 6
28472: LESS
28473: AND
28474: IFFALSE 28662
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28476: LD_ADDR_VAR 0 9
28480: PUSH
28481: LD_VAR 0 4
28485: PUSH
28486: LD_VAR 0 8
28490: PUSH
28491: LD_VAR 0 7
28495: UNION
28496: DIFF
28497: PPUSH
28498: LD_INT 3
28500: PPUSH
28501: CALL 87909 0 2
28505: ST_TO_ADDR
// p := [ ] ;
28506: LD_ADDR_VAR 0 11
28510: PUSH
28511: EMPTY
28512: ST_TO_ADDR
// if sort then
28513: LD_VAR 0 9
28517: IFFALSE 28633
// for i = 1 to 6 - mech do
28519: LD_ADDR_VAR 0 3
28523: PUSH
28524: DOUBLE
28525: LD_INT 1
28527: DEC
28528: ST_TO_ADDR
28529: LD_INT 6
28531: PUSH
28532: LD_VAR 0 7
28536: MINUS
28537: PUSH
28538: FOR_TO
28539: IFFALSE 28631
// begin if i = sort then
28541: LD_VAR 0 3
28545: PUSH
28546: LD_VAR 0 9
28550: EQUAL
28551: IFFALSE 28555
// break ;
28553: GO 28631
// if GetClass ( i ) = 3 then
28555: LD_VAR 0 3
28559: PPUSH
28560: CALL_OW 257
28564: PUSH
28565: LD_INT 3
28567: EQUAL
28568: IFFALSE 28572
// continue ;
28570: GO 28538
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28572: LD_ADDR_VAR 0 11
28576: PUSH
28577: LD_VAR 0 11
28581: PPUSH
28582: LD_VAR 0 11
28586: PUSH
28587: LD_INT 1
28589: PLUS
28590: PPUSH
28591: LD_VAR 0 9
28595: PUSH
28596: LD_VAR 0 3
28600: ARRAY
28601: PPUSH
28602: CALL_OW 2
28606: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28607: LD_ADDR_VAR 0 4
28611: PUSH
28612: LD_VAR 0 4
28616: PUSH
28617: LD_VAR 0 9
28621: PUSH
28622: LD_VAR 0 3
28626: ARRAY
28627: DIFF
28628: ST_TO_ADDR
// end ;
28629: GO 28538
28631: POP
28632: POP
// if p then
28633: LD_VAR 0 11
28637: IFFALSE 28662
// result := Replace ( result , 3 , p ) ;
28639: LD_ADDR_VAR 0 2
28643: PUSH
28644: LD_VAR 0 2
28648: PPUSH
28649: LD_INT 3
28651: PPUSH
28652: LD_VAR 0 11
28656: PPUSH
28657: CALL_OW 1
28661: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28662: LD_ADDR_VAR 0 4
28666: PUSH
28667: LD_VAR 0 4
28671: PUSH
28672: LD_VAR 0 6
28676: DIFF
28677: ST_TO_ADDR
// if tmp and eng < 6 then
28678: LD_VAR 0 4
28682: PUSH
28683: LD_VAR 0 6
28687: PUSH
28688: LD_INT 6
28690: LESS
28691: AND
28692: IFFALSE 28886
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28694: LD_ADDR_VAR 0 9
28698: PUSH
28699: LD_VAR 0 4
28703: PUSH
28704: LD_VAR 0 8
28708: PUSH
28709: LD_VAR 0 7
28713: UNION
28714: PUSH
28715: LD_VAR 0 6
28719: UNION
28720: DIFF
28721: PPUSH
28722: LD_INT 2
28724: PPUSH
28725: CALL 87909 0 2
28729: ST_TO_ADDR
// p := [ ] ;
28730: LD_ADDR_VAR 0 11
28734: PUSH
28735: EMPTY
28736: ST_TO_ADDR
// if sort then
28737: LD_VAR 0 9
28741: IFFALSE 28857
// for i = 1 to 6 - eng do
28743: LD_ADDR_VAR 0 3
28747: PUSH
28748: DOUBLE
28749: LD_INT 1
28751: DEC
28752: ST_TO_ADDR
28753: LD_INT 6
28755: PUSH
28756: LD_VAR 0 6
28760: MINUS
28761: PUSH
28762: FOR_TO
28763: IFFALSE 28855
// begin if i = sort then
28765: LD_VAR 0 3
28769: PUSH
28770: LD_VAR 0 9
28774: EQUAL
28775: IFFALSE 28779
// break ;
28777: GO 28855
// if GetClass ( i ) = 2 then
28779: LD_VAR 0 3
28783: PPUSH
28784: CALL_OW 257
28788: PUSH
28789: LD_INT 2
28791: EQUAL
28792: IFFALSE 28796
// continue ;
28794: GO 28762
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28796: LD_ADDR_VAR 0 11
28800: PUSH
28801: LD_VAR 0 11
28805: PPUSH
28806: LD_VAR 0 11
28810: PUSH
28811: LD_INT 1
28813: PLUS
28814: PPUSH
28815: LD_VAR 0 9
28819: PUSH
28820: LD_VAR 0 3
28824: ARRAY
28825: PPUSH
28826: CALL_OW 2
28830: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28831: LD_ADDR_VAR 0 4
28835: PUSH
28836: LD_VAR 0 4
28840: PUSH
28841: LD_VAR 0 9
28845: PUSH
28846: LD_VAR 0 3
28850: ARRAY
28851: DIFF
28852: ST_TO_ADDR
// end ;
28853: GO 28762
28855: POP
28856: POP
// if p then
28857: LD_VAR 0 11
28861: IFFALSE 28886
// result := Replace ( result , 2 , p ) ;
28863: LD_ADDR_VAR 0 2
28867: PUSH
28868: LD_VAR 0 2
28872: PPUSH
28873: LD_INT 2
28875: PPUSH
28876: LD_VAR 0 11
28880: PPUSH
28881: CALL_OW 1
28885: ST_TO_ADDR
// end ; exit ;
28886: GO 29610
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28888: LD_EXP 104
28892: PUSH
28893: LD_EXP 103
28897: PUSH
28898: LD_VAR 0 1
28902: ARRAY
28903: ARRAY
28904: NOT
28905: PUSH
28906: LD_EXP 77
28910: PUSH
28911: LD_VAR 0 1
28915: ARRAY
28916: PPUSH
28917: LD_INT 30
28919: PUSH
28920: LD_INT 3
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PPUSH
28927: CALL_OW 72
28931: AND
28932: PUSH
28933: LD_EXP 82
28937: PUSH
28938: LD_VAR 0 1
28942: ARRAY
28943: NOT
28944: AND
28945: IFFALSE 29610
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28947: LD_ADDR_EXP 119
28951: PUSH
28952: LD_EXP 119
28956: PPUSH
28957: LD_VAR 0 1
28961: PPUSH
28962: LD_INT 6
28964: PPUSH
28965: CALL_OW 1
28969: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28970: LD_ADDR_VAR 0 2
28974: PUSH
28975: LD_INT 0
28977: PUSH
28978: LD_INT 0
28980: PUSH
28981: LD_INT 0
28983: PUSH
28984: LD_INT 0
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: ST_TO_ADDR
// if sci >= 1 then
28993: LD_VAR 0 8
28997: PUSH
28998: LD_INT 1
29000: GREATEREQUAL
29001: IFFALSE 29023
// tmp := tmp diff sci [ 1 ] ;
29003: LD_ADDR_VAR 0 4
29007: PUSH
29008: LD_VAR 0 4
29012: PUSH
29013: LD_VAR 0 8
29017: PUSH
29018: LD_INT 1
29020: ARRAY
29021: DIFF
29022: ST_TO_ADDR
// if tmp and not sci then
29023: LD_VAR 0 4
29027: PUSH
29028: LD_VAR 0 8
29032: NOT
29033: AND
29034: IFFALSE 29103
// begin sort := SortBySkill ( tmp , 4 ) ;
29036: LD_ADDR_VAR 0 9
29040: PUSH
29041: LD_VAR 0 4
29045: PPUSH
29046: LD_INT 4
29048: PPUSH
29049: CALL 87909 0 2
29053: ST_TO_ADDR
// if sort then
29054: LD_VAR 0 9
29058: IFFALSE 29074
// p := sort [ 1 ] ;
29060: LD_ADDR_VAR 0 11
29064: PUSH
29065: LD_VAR 0 9
29069: PUSH
29070: LD_INT 1
29072: ARRAY
29073: ST_TO_ADDR
// if p then
29074: LD_VAR 0 11
29078: IFFALSE 29103
// result := Replace ( result , 4 , p ) ;
29080: LD_ADDR_VAR 0 2
29084: PUSH
29085: LD_VAR 0 2
29089: PPUSH
29090: LD_INT 4
29092: PPUSH
29093: LD_VAR 0 11
29097: PPUSH
29098: CALL_OW 1
29102: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29103: LD_ADDR_VAR 0 4
29107: PUSH
29108: LD_VAR 0 4
29112: PUSH
29113: LD_VAR 0 7
29117: DIFF
29118: ST_TO_ADDR
// if tmp and mech < 6 then
29119: LD_VAR 0 4
29123: PUSH
29124: LD_VAR 0 7
29128: PUSH
29129: LD_INT 6
29131: LESS
29132: AND
29133: IFFALSE 29315
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29135: LD_ADDR_VAR 0 9
29139: PUSH
29140: LD_VAR 0 4
29144: PUSH
29145: LD_VAR 0 7
29149: DIFF
29150: PPUSH
29151: LD_INT 3
29153: PPUSH
29154: CALL 87909 0 2
29158: ST_TO_ADDR
// p := [ ] ;
29159: LD_ADDR_VAR 0 11
29163: PUSH
29164: EMPTY
29165: ST_TO_ADDR
// if sort then
29166: LD_VAR 0 9
29170: IFFALSE 29286
// for i = 1 to 6 - mech do
29172: LD_ADDR_VAR 0 3
29176: PUSH
29177: DOUBLE
29178: LD_INT 1
29180: DEC
29181: ST_TO_ADDR
29182: LD_INT 6
29184: PUSH
29185: LD_VAR 0 7
29189: MINUS
29190: PUSH
29191: FOR_TO
29192: IFFALSE 29284
// begin if i = sort then
29194: LD_VAR 0 3
29198: PUSH
29199: LD_VAR 0 9
29203: EQUAL
29204: IFFALSE 29208
// break ;
29206: GO 29284
// if GetClass ( i ) = 3 then
29208: LD_VAR 0 3
29212: PPUSH
29213: CALL_OW 257
29217: PUSH
29218: LD_INT 3
29220: EQUAL
29221: IFFALSE 29225
// continue ;
29223: GO 29191
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29225: LD_ADDR_VAR 0 11
29229: PUSH
29230: LD_VAR 0 11
29234: PPUSH
29235: LD_VAR 0 11
29239: PUSH
29240: LD_INT 1
29242: PLUS
29243: PPUSH
29244: LD_VAR 0 9
29248: PUSH
29249: LD_VAR 0 3
29253: ARRAY
29254: PPUSH
29255: CALL_OW 2
29259: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29260: LD_ADDR_VAR 0 4
29264: PUSH
29265: LD_VAR 0 4
29269: PUSH
29270: LD_VAR 0 9
29274: PUSH
29275: LD_VAR 0 3
29279: ARRAY
29280: DIFF
29281: ST_TO_ADDR
// end ;
29282: GO 29191
29284: POP
29285: POP
// if p then
29286: LD_VAR 0 11
29290: IFFALSE 29315
// result := Replace ( result , 3 , p ) ;
29292: LD_ADDR_VAR 0 2
29296: PUSH
29297: LD_VAR 0 2
29301: PPUSH
29302: LD_INT 3
29304: PPUSH
29305: LD_VAR 0 11
29309: PPUSH
29310: CALL_OW 1
29314: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29315: LD_ADDR_VAR 0 4
29319: PUSH
29320: LD_VAR 0 4
29324: PUSH
29325: LD_VAR 0 6
29329: DIFF
29330: ST_TO_ADDR
// if tmp and eng < 4 then
29331: LD_VAR 0 4
29335: PUSH
29336: LD_VAR 0 6
29340: PUSH
29341: LD_INT 4
29343: LESS
29344: AND
29345: IFFALSE 29535
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
29347: LD_ADDR_VAR 0 9
29351: PUSH
29352: LD_VAR 0 4
29356: PUSH
29357: LD_VAR 0 7
29361: PUSH
29362: LD_VAR 0 6
29366: UNION
29367: DIFF
29368: PPUSH
29369: LD_INT 2
29371: PPUSH
29372: CALL 87909 0 2
29376: ST_TO_ADDR
// p := [ ] ;
29377: LD_ADDR_VAR 0 11
29381: PUSH
29382: EMPTY
29383: ST_TO_ADDR
// if sort then
29384: LD_VAR 0 9
29388: IFFALSE 29504
// for i = 1 to 4 - eng do
29390: LD_ADDR_VAR 0 3
29394: PUSH
29395: DOUBLE
29396: LD_INT 1
29398: DEC
29399: ST_TO_ADDR
29400: LD_INT 4
29402: PUSH
29403: LD_VAR 0 6
29407: MINUS
29408: PUSH
29409: FOR_TO
29410: IFFALSE 29502
// begin if i = sort then
29412: LD_VAR 0 3
29416: PUSH
29417: LD_VAR 0 9
29421: EQUAL
29422: IFFALSE 29426
// break ;
29424: GO 29502
// if GetClass ( i ) = 2 then
29426: LD_VAR 0 3
29430: PPUSH
29431: CALL_OW 257
29435: PUSH
29436: LD_INT 2
29438: EQUAL
29439: IFFALSE 29443
// continue ;
29441: GO 29409
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29443: LD_ADDR_VAR 0 11
29447: PUSH
29448: LD_VAR 0 11
29452: PPUSH
29453: LD_VAR 0 11
29457: PUSH
29458: LD_INT 1
29460: PLUS
29461: PPUSH
29462: LD_VAR 0 9
29466: PUSH
29467: LD_VAR 0 3
29471: ARRAY
29472: PPUSH
29473: CALL_OW 2
29477: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29478: LD_ADDR_VAR 0 4
29482: PUSH
29483: LD_VAR 0 4
29487: PUSH
29488: LD_VAR 0 9
29492: PUSH
29493: LD_VAR 0 3
29497: ARRAY
29498: DIFF
29499: ST_TO_ADDR
// end ;
29500: GO 29409
29502: POP
29503: POP
// if p then
29504: LD_VAR 0 11
29508: IFFALSE 29533
// result := Replace ( result , 2 , p ) ;
29510: LD_ADDR_VAR 0 2
29514: PUSH
29515: LD_VAR 0 2
29519: PPUSH
29520: LD_INT 2
29522: PPUSH
29523: LD_VAR 0 11
29527: PPUSH
29528: CALL_OW 1
29532: ST_TO_ADDR
// end else
29533: GO 29579
// for i = eng downto 5 do
29535: LD_ADDR_VAR 0 3
29539: PUSH
29540: DOUBLE
29541: LD_VAR 0 6
29545: INC
29546: ST_TO_ADDR
29547: LD_INT 5
29549: PUSH
29550: FOR_DOWNTO
29551: IFFALSE 29577
// tmp := tmp union eng [ i ] ;
29553: LD_ADDR_VAR 0 4
29557: PUSH
29558: LD_VAR 0 4
29562: PUSH
29563: LD_VAR 0 6
29567: PUSH
29568: LD_VAR 0 3
29572: ARRAY
29573: UNION
29574: ST_TO_ADDR
29575: GO 29550
29577: POP
29578: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29579: LD_ADDR_VAR 0 2
29583: PUSH
29584: LD_VAR 0 2
29588: PPUSH
29589: LD_INT 1
29591: PPUSH
29592: LD_VAR 0 4
29596: PUSH
29597: LD_VAR 0 5
29601: DIFF
29602: PPUSH
29603: CALL_OW 1
29607: ST_TO_ADDR
// exit ;
29608: GO 29610
// end ; end ;
29610: LD_VAR 0 2
29614: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29615: LD_INT 0
29617: PPUSH
29618: PPUSH
29619: PPUSH
// if not mc_bases then
29620: LD_EXP 77
29624: NOT
29625: IFFALSE 29629
// exit ;
29627: GO 29771
// for i = 1 to mc_bases do
29629: LD_ADDR_VAR 0 2
29633: PUSH
29634: DOUBLE
29635: LD_INT 1
29637: DEC
29638: ST_TO_ADDR
29639: LD_EXP 77
29643: PUSH
29644: FOR_TO
29645: IFFALSE 29762
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29647: LD_ADDR_VAR 0 3
29651: PUSH
29652: LD_EXP 77
29656: PUSH
29657: LD_VAR 0 2
29661: ARRAY
29662: PPUSH
29663: LD_INT 21
29665: PUSH
29666: LD_INT 3
29668: PUSH
29669: EMPTY
29670: LIST
29671: LIST
29672: PUSH
29673: LD_INT 3
29675: PUSH
29676: LD_INT 2
29678: PUSH
29679: LD_INT 30
29681: PUSH
29682: LD_INT 29
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 30
29691: PUSH
29692: LD_INT 30
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: LIST
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: PUSH
29708: LD_INT 3
29710: PUSH
29711: LD_INT 24
29713: PUSH
29714: LD_INT 1000
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PUSH
29721: EMPTY
29722: LIST
29723: LIST
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: LIST
29729: PPUSH
29730: CALL_OW 72
29734: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29735: LD_ADDR_EXP 78
29739: PUSH
29740: LD_EXP 78
29744: PPUSH
29745: LD_VAR 0 2
29749: PPUSH
29750: LD_VAR 0 3
29754: PPUSH
29755: CALL_OW 1
29759: ST_TO_ADDR
// end ;
29760: GO 29644
29762: POP
29763: POP
// RaiseSailEvent ( 101 ) ;
29764: LD_INT 101
29766: PPUSH
29767: CALL_OW 427
// end ;
29771: LD_VAR 0 1
29775: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29776: LD_INT 0
29778: PPUSH
29779: PPUSH
29780: PPUSH
29781: PPUSH
29782: PPUSH
29783: PPUSH
29784: PPUSH
// if not mc_bases then
29785: LD_EXP 77
29789: NOT
29790: IFFALSE 29794
// exit ;
29792: GO 30356
// for i = 1 to mc_bases do
29794: LD_ADDR_VAR 0 2
29798: PUSH
29799: DOUBLE
29800: LD_INT 1
29802: DEC
29803: ST_TO_ADDR
29804: LD_EXP 77
29808: PUSH
29809: FOR_TO
29810: IFFALSE 30347
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29812: LD_ADDR_VAR 0 5
29816: PUSH
29817: LD_EXP 77
29821: PUSH
29822: LD_VAR 0 2
29826: ARRAY
29827: PUSH
29828: LD_EXP 106
29832: PUSH
29833: LD_VAR 0 2
29837: ARRAY
29838: UNION
29839: PPUSH
29840: LD_INT 21
29842: PUSH
29843: LD_INT 1
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: LD_INT 3
29855: PUSH
29856: LD_INT 54
29858: PUSH
29859: EMPTY
29860: LIST
29861: PUSH
29862: EMPTY
29863: LIST
29864: LIST
29865: PUSH
29866: LD_INT 3
29868: PUSH
29869: LD_INT 24
29871: PUSH
29872: LD_INT 1000
29874: PUSH
29875: EMPTY
29876: LIST
29877: LIST
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: LIST
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PPUSH
29892: CALL_OW 72
29896: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29897: LD_ADDR_VAR 0 6
29901: PUSH
29902: LD_EXP 77
29906: PUSH
29907: LD_VAR 0 2
29911: ARRAY
29912: PPUSH
29913: LD_INT 21
29915: PUSH
29916: LD_INT 1
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: LD_INT 3
29928: PUSH
29929: LD_INT 54
29931: PUSH
29932: EMPTY
29933: LIST
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 3
29941: PUSH
29942: LD_INT 24
29944: PUSH
29945: LD_INT 250
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: LIST
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PPUSH
29965: CALL_OW 72
29969: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29970: LD_ADDR_VAR 0 7
29974: PUSH
29975: LD_VAR 0 5
29979: PUSH
29980: LD_VAR 0 6
29984: DIFF
29985: ST_TO_ADDR
// if not need_heal_1 then
29986: LD_VAR 0 6
29990: NOT
29991: IFFALSE 30024
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29993: LD_ADDR_EXP 80
29997: PUSH
29998: LD_EXP 80
30002: PPUSH
30003: LD_VAR 0 2
30007: PUSH
30008: LD_INT 1
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PPUSH
30015: EMPTY
30016: PPUSH
30017: CALL 57088 0 3
30021: ST_TO_ADDR
30022: GO 30094
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30024: LD_ADDR_EXP 80
30028: PUSH
30029: LD_EXP 80
30033: PPUSH
30034: LD_VAR 0 2
30038: PUSH
30039: LD_INT 1
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PPUSH
30046: LD_EXP 80
30050: PUSH
30051: LD_VAR 0 2
30055: ARRAY
30056: PUSH
30057: LD_INT 1
30059: ARRAY
30060: PPUSH
30061: LD_INT 3
30063: PUSH
30064: LD_INT 24
30066: PUSH
30067: LD_INT 1000
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: PPUSH
30078: CALL_OW 72
30082: PUSH
30083: LD_VAR 0 6
30087: UNION
30088: PPUSH
30089: CALL 57088 0 3
30093: ST_TO_ADDR
// if not need_heal_2 then
30094: LD_VAR 0 7
30098: NOT
30099: IFFALSE 30132
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30101: LD_ADDR_EXP 80
30105: PUSH
30106: LD_EXP 80
30110: PPUSH
30111: LD_VAR 0 2
30115: PUSH
30116: LD_INT 2
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PPUSH
30123: EMPTY
30124: PPUSH
30125: CALL 57088 0 3
30129: ST_TO_ADDR
30130: GO 30164
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30132: LD_ADDR_EXP 80
30136: PUSH
30137: LD_EXP 80
30141: PPUSH
30142: LD_VAR 0 2
30146: PUSH
30147: LD_INT 2
30149: PUSH
30150: EMPTY
30151: LIST
30152: LIST
30153: PPUSH
30154: LD_VAR 0 7
30158: PPUSH
30159: CALL 57088 0 3
30163: ST_TO_ADDR
// if need_heal_2 then
30164: LD_VAR 0 7
30168: IFFALSE 30329
// for j in need_heal_2 do
30170: LD_ADDR_VAR 0 3
30174: PUSH
30175: LD_VAR 0 7
30179: PUSH
30180: FOR_IN
30181: IFFALSE 30327
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30183: LD_ADDR_VAR 0 5
30187: PUSH
30188: LD_EXP 77
30192: PUSH
30193: LD_VAR 0 2
30197: ARRAY
30198: PPUSH
30199: LD_INT 2
30201: PUSH
30202: LD_INT 30
30204: PUSH
30205: LD_INT 6
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 30
30214: PUSH
30215: LD_INT 7
30217: PUSH
30218: EMPTY
30219: LIST
30220: LIST
30221: PUSH
30222: LD_INT 30
30224: PUSH
30225: LD_INT 8
30227: PUSH
30228: EMPTY
30229: LIST
30230: LIST
30231: PUSH
30232: LD_INT 30
30234: PUSH
30235: LD_INT 0
30237: PUSH
30238: EMPTY
30239: LIST
30240: LIST
30241: PUSH
30242: LD_INT 30
30244: PUSH
30245: LD_INT 1
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: LIST
30256: LIST
30257: LIST
30258: LIST
30259: PPUSH
30260: CALL_OW 72
30264: ST_TO_ADDR
// if tmp then
30265: LD_VAR 0 5
30269: IFFALSE 30325
// begin k := NearestUnitToUnit ( tmp , j ) ;
30271: LD_ADDR_VAR 0 4
30275: PUSH
30276: LD_VAR 0 5
30280: PPUSH
30281: LD_VAR 0 3
30285: PPUSH
30286: CALL_OW 74
30290: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
30291: LD_VAR 0 3
30295: PPUSH
30296: LD_VAR 0 4
30300: PPUSH
30301: CALL_OW 296
30305: PUSH
30306: LD_INT 5
30308: GREATER
30309: IFFALSE 30325
// ComMoveToNearbyEntrance ( j , k ) ;
30311: LD_VAR 0 3
30315: PPUSH
30316: LD_VAR 0 4
30320: PPUSH
30321: CALL 90277 0 2
// end ; end ;
30325: GO 30180
30327: POP
30328: POP
// if not need_heal_1 and not need_heal_2 then
30329: LD_VAR 0 6
30333: NOT
30334: PUSH
30335: LD_VAR 0 7
30339: NOT
30340: AND
30341: IFFALSE 30345
// continue ;
30343: GO 29809
// end ;
30345: GO 29809
30347: POP
30348: POP
// RaiseSailEvent ( 102 ) ;
30349: LD_INT 102
30351: PPUSH
30352: CALL_OW 427
// end ;
30356: LD_VAR 0 1
30360: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
30361: LD_INT 0
30363: PPUSH
30364: PPUSH
30365: PPUSH
30366: PPUSH
30367: PPUSH
30368: PPUSH
30369: PPUSH
30370: PPUSH
// if not mc_bases then
30371: LD_EXP 77
30375: NOT
30376: IFFALSE 30380
// exit ;
30378: GO 31291
// for i = 1 to mc_bases do
30380: LD_ADDR_VAR 0 2
30384: PUSH
30385: DOUBLE
30386: LD_INT 1
30388: DEC
30389: ST_TO_ADDR
30390: LD_EXP 77
30394: PUSH
30395: FOR_TO
30396: IFFALSE 31289
// begin if not mc_building_need_repair [ i ] then
30398: LD_EXP 78
30402: PUSH
30403: LD_VAR 0 2
30407: ARRAY
30408: NOT
30409: IFFALSE 30594
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
30411: LD_ADDR_VAR 0 6
30415: PUSH
30416: LD_EXP 96
30420: PUSH
30421: LD_VAR 0 2
30425: ARRAY
30426: PPUSH
30427: LD_INT 3
30429: PUSH
30430: LD_INT 24
30432: PUSH
30433: LD_INT 1000
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PUSH
30444: LD_INT 2
30446: PUSH
30447: LD_INT 34
30449: PUSH
30450: LD_INT 13
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: LD_INT 34
30459: PUSH
30460: LD_INT 52
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: PUSH
30467: LD_INT 34
30469: PUSH
30470: LD_INT 88
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: LIST
30481: LIST
30482: PUSH
30483: EMPTY
30484: LIST
30485: LIST
30486: PPUSH
30487: CALL_OW 72
30491: ST_TO_ADDR
// if cranes then
30492: LD_VAR 0 6
30496: IFFALSE 30558
// for j in cranes do
30498: LD_ADDR_VAR 0 3
30502: PUSH
30503: LD_VAR 0 6
30507: PUSH
30508: FOR_IN
30509: IFFALSE 30556
// if not IsInArea ( j , mc_parking [ i ] ) then
30511: LD_VAR 0 3
30515: PPUSH
30516: LD_EXP 101
30520: PUSH
30521: LD_VAR 0 2
30525: ARRAY
30526: PPUSH
30527: CALL_OW 308
30531: NOT
30532: IFFALSE 30554
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30534: LD_VAR 0 3
30538: PPUSH
30539: LD_EXP 101
30543: PUSH
30544: LD_VAR 0 2
30548: ARRAY
30549: PPUSH
30550: CALL_OW 113
30554: GO 30508
30556: POP
30557: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30558: LD_ADDR_EXP 79
30562: PUSH
30563: LD_EXP 79
30567: PPUSH
30568: LD_VAR 0 2
30572: PPUSH
30573: EMPTY
30574: PPUSH
30575: CALL_OW 1
30579: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30580: LD_VAR 0 2
30584: PPUSH
30585: LD_INT 101
30587: PPUSH
30588: CALL 25448 0 2
// continue ;
30592: GO 30395
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30594: LD_ADDR_EXP 83
30598: PUSH
30599: LD_EXP 83
30603: PPUSH
30604: LD_VAR 0 2
30608: PPUSH
30609: EMPTY
30610: PPUSH
30611: CALL_OW 1
30615: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30616: LD_VAR 0 2
30620: PPUSH
30621: LD_INT 103
30623: PPUSH
30624: CALL 25448 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30628: LD_ADDR_VAR 0 5
30632: PUSH
30633: LD_EXP 77
30637: PUSH
30638: LD_VAR 0 2
30642: ARRAY
30643: PUSH
30644: LD_EXP 106
30648: PUSH
30649: LD_VAR 0 2
30653: ARRAY
30654: UNION
30655: PPUSH
30656: LD_INT 2
30658: PUSH
30659: LD_INT 25
30661: PUSH
30662: LD_INT 2
30664: PUSH
30665: EMPTY
30666: LIST
30667: LIST
30668: PUSH
30669: LD_INT 25
30671: PUSH
30672: LD_INT 16
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: LIST
30683: PUSH
30684: EMPTY
30685: LIST
30686: PPUSH
30687: CALL_OW 72
30691: ST_TO_ADDR
// if mc_need_heal [ i ] then
30692: LD_EXP 80
30696: PUSH
30697: LD_VAR 0 2
30701: ARRAY
30702: IFFALSE 30746
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30704: LD_ADDR_VAR 0 5
30708: PUSH
30709: LD_VAR 0 5
30713: PUSH
30714: LD_EXP 80
30718: PUSH
30719: LD_VAR 0 2
30723: ARRAY
30724: PUSH
30725: LD_INT 1
30727: ARRAY
30728: PUSH
30729: LD_EXP 80
30733: PUSH
30734: LD_VAR 0 2
30738: ARRAY
30739: PUSH
30740: LD_INT 2
30742: ARRAY
30743: UNION
30744: DIFF
30745: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30746: LD_ADDR_VAR 0 6
30750: PUSH
30751: LD_EXP 96
30755: PUSH
30756: LD_VAR 0 2
30760: ARRAY
30761: PPUSH
30762: LD_INT 2
30764: PUSH
30765: LD_INT 34
30767: PUSH
30768: LD_INT 13
30770: PUSH
30771: EMPTY
30772: LIST
30773: LIST
30774: PUSH
30775: LD_INT 34
30777: PUSH
30778: LD_INT 52
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 34
30787: PUSH
30788: LD_INT 88
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: LIST
30799: LIST
30800: PPUSH
30801: CALL_OW 72
30805: ST_TO_ADDR
// if cranes then
30806: LD_VAR 0 6
30810: IFFALSE 30978
// begin for j in cranes do
30812: LD_ADDR_VAR 0 3
30816: PUSH
30817: LD_VAR 0 6
30821: PUSH
30822: FOR_IN
30823: IFFALSE 30976
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30825: LD_VAR 0 3
30829: PPUSH
30830: CALL_OW 256
30834: PUSH
30835: LD_INT 1000
30837: EQUAL
30838: PUSH
30839: LD_VAR 0 3
30843: PPUSH
30844: CALL_OW 314
30848: NOT
30849: AND
30850: IFFALSE 30916
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
30852: LD_ADDR_VAR 0 8
30856: PUSH
30857: LD_EXP 78
30861: PUSH
30862: LD_VAR 0 2
30866: ARRAY
30867: PPUSH
30868: LD_VAR 0 3
30872: PPUSH
30873: CALL_OW 74
30877: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30878: LD_VAR 0 8
30882: PPUSH
30883: LD_INT 16
30885: PPUSH
30886: CALL 59685 0 2
30890: PUSH
30891: LD_INT 4
30893: ARRAY
30894: PUSH
30895: LD_INT 10
30897: LESS
30898: IFFALSE 30914
// ComRepairBuilding ( j , to_repair ) ;
30900: LD_VAR 0 3
30904: PPUSH
30905: LD_VAR 0 8
30909: PPUSH
30910: CALL_OW 130
// end else
30914: GO 30974
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30916: LD_VAR 0 3
30920: PPUSH
30921: CALL_OW 256
30925: PUSH
30926: LD_INT 500
30928: LESS
30929: PUSH
30930: LD_VAR 0 3
30934: PPUSH
30935: LD_EXP 101
30939: PUSH
30940: LD_VAR 0 2
30944: ARRAY
30945: PPUSH
30946: CALL_OW 308
30950: NOT
30951: AND
30952: IFFALSE 30974
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30954: LD_VAR 0 3
30958: PPUSH
30959: LD_EXP 101
30963: PUSH
30964: LD_VAR 0 2
30968: ARRAY
30969: PPUSH
30970: CALL_OW 113
// end ;
30974: GO 30822
30976: POP
30977: POP
// end ; if tmp > 3 then
30978: LD_VAR 0 5
30982: PUSH
30983: LD_INT 3
30985: GREATER
30986: IFFALSE 31006
// tmp := ShrinkArray ( tmp , 4 ) ;
30988: LD_ADDR_VAR 0 5
30992: PUSH
30993: LD_VAR 0 5
30997: PPUSH
30998: LD_INT 4
31000: PPUSH
31001: CALL 89715 0 2
31005: ST_TO_ADDR
// if not tmp then
31006: LD_VAR 0 5
31010: NOT
31011: IFFALSE 31015
// continue ;
31013: GO 30395
// for j in tmp do
31015: LD_ADDR_VAR 0 3
31019: PUSH
31020: LD_VAR 0 5
31024: PUSH
31025: FOR_IN
31026: IFFALSE 31285
// begin if IsInUnit ( j ) then
31028: LD_VAR 0 3
31032: PPUSH
31033: CALL_OW 310
31037: IFFALSE 31048
// ComExitBuilding ( j ) ;
31039: LD_VAR 0 3
31043: PPUSH
31044: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31048: LD_VAR 0 3
31052: PUSH
31053: LD_EXP 79
31057: PUSH
31058: LD_VAR 0 2
31062: ARRAY
31063: IN
31064: NOT
31065: IFFALSE 31123
// begin SetTag ( j , 101 ) ;
31067: LD_VAR 0 3
31071: PPUSH
31072: LD_INT 101
31074: PPUSH
31075: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31079: LD_ADDR_EXP 79
31083: PUSH
31084: LD_EXP 79
31088: PPUSH
31089: LD_VAR 0 2
31093: PUSH
31094: LD_EXP 79
31098: PUSH
31099: LD_VAR 0 2
31103: ARRAY
31104: PUSH
31105: LD_INT 1
31107: PLUS
31108: PUSH
31109: EMPTY
31110: LIST
31111: LIST
31112: PPUSH
31113: LD_VAR 0 3
31117: PPUSH
31118: CALL 57088 0 3
31122: ST_TO_ADDR
// end ; wait ( 1 ) ;
31123: LD_INT 1
31125: PPUSH
31126: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31130: LD_ADDR_VAR 0 7
31134: PUSH
31135: LD_EXP 78
31139: PUSH
31140: LD_VAR 0 2
31144: ARRAY
31145: ST_TO_ADDR
// if mc_scan [ i ] then
31146: LD_EXP 100
31150: PUSH
31151: LD_VAR 0 2
31155: ARRAY
31156: IFFALSE 31218
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31158: LD_ADDR_VAR 0 7
31162: PUSH
31163: LD_EXP 78
31167: PUSH
31168: LD_VAR 0 2
31172: ARRAY
31173: PPUSH
31174: LD_INT 3
31176: PUSH
31177: LD_INT 30
31179: PUSH
31180: LD_INT 32
31182: PUSH
31183: EMPTY
31184: LIST
31185: LIST
31186: PUSH
31187: LD_INT 30
31189: PUSH
31190: LD_INT 33
31192: PUSH
31193: EMPTY
31194: LIST
31195: LIST
31196: PUSH
31197: LD_INT 30
31199: PUSH
31200: LD_INT 31
31202: PUSH
31203: EMPTY
31204: LIST
31205: LIST
31206: PUSH
31207: EMPTY
31208: LIST
31209: LIST
31210: LIST
31211: LIST
31212: PPUSH
31213: CALL_OW 72
31217: ST_TO_ADDR
// if not to_repair_tmp then
31218: LD_VAR 0 7
31222: NOT
31223: IFFALSE 31227
// continue ;
31225: GO 31025
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
31227: LD_ADDR_VAR 0 8
31231: PUSH
31232: LD_VAR 0 7
31236: PPUSH
31237: LD_VAR 0 3
31241: PPUSH
31242: CALL_OW 74
31246: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
31247: LD_VAR 0 8
31251: PPUSH
31252: LD_INT 16
31254: PPUSH
31255: CALL 59685 0 2
31259: PUSH
31260: LD_INT 4
31262: ARRAY
31263: PUSH
31264: LD_INT 14
31266: LESS
31267: IFFALSE 31283
// ComRepairBuilding ( j , to_repair ) ;
31269: LD_VAR 0 3
31273: PPUSH
31274: LD_VAR 0 8
31278: PPUSH
31279: CALL_OW 130
// end ;
31283: GO 31025
31285: POP
31286: POP
// end ;
31287: GO 30395
31289: POP
31290: POP
// end ;
31291: LD_VAR 0 1
31295: RET
// export function MC_Heal ; var i , j , tmp ; begin
31296: LD_INT 0
31298: PPUSH
31299: PPUSH
31300: PPUSH
31301: PPUSH
// if not mc_bases then
31302: LD_EXP 77
31306: NOT
31307: IFFALSE 31311
// exit ;
31309: GO 31713
// for i = 1 to mc_bases do
31311: LD_ADDR_VAR 0 2
31315: PUSH
31316: DOUBLE
31317: LD_INT 1
31319: DEC
31320: ST_TO_ADDR
31321: LD_EXP 77
31325: PUSH
31326: FOR_TO
31327: IFFALSE 31711
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
31329: LD_EXP 80
31333: PUSH
31334: LD_VAR 0 2
31338: ARRAY
31339: PUSH
31340: LD_INT 1
31342: ARRAY
31343: NOT
31344: PUSH
31345: LD_EXP 80
31349: PUSH
31350: LD_VAR 0 2
31354: ARRAY
31355: PUSH
31356: LD_INT 2
31358: ARRAY
31359: NOT
31360: AND
31361: IFFALSE 31399
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
31363: LD_ADDR_EXP 81
31367: PUSH
31368: LD_EXP 81
31372: PPUSH
31373: LD_VAR 0 2
31377: PPUSH
31378: EMPTY
31379: PPUSH
31380: CALL_OW 1
31384: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
31385: LD_VAR 0 2
31389: PPUSH
31390: LD_INT 102
31392: PPUSH
31393: CALL 25448 0 2
// continue ;
31397: GO 31326
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31399: LD_ADDR_VAR 0 4
31403: PUSH
31404: LD_EXP 77
31408: PUSH
31409: LD_VAR 0 2
31413: ARRAY
31414: PPUSH
31415: LD_INT 25
31417: PUSH
31418: LD_INT 4
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PPUSH
31425: CALL_OW 72
31429: ST_TO_ADDR
// if not tmp then
31430: LD_VAR 0 4
31434: NOT
31435: IFFALSE 31439
// continue ;
31437: GO 31326
// if mc_taming [ i ] then
31439: LD_EXP 108
31443: PUSH
31444: LD_VAR 0 2
31448: ARRAY
31449: IFFALSE 31473
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31451: LD_ADDR_EXP 108
31455: PUSH
31456: LD_EXP 108
31460: PPUSH
31461: LD_VAR 0 2
31465: PPUSH
31466: EMPTY
31467: PPUSH
31468: CALL_OW 1
31472: ST_TO_ADDR
// for j in tmp do
31473: LD_ADDR_VAR 0 3
31477: PUSH
31478: LD_VAR 0 4
31482: PUSH
31483: FOR_IN
31484: IFFALSE 31707
// begin if IsInUnit ( j ) then
31486: LD_VAR 0 3
31490: PPUSH
31491: CALL_OW 310
31495: IFFALSE 31506
// ComExitBuilding ( j ) ;
31497: LD_VAR 0 3
31501: PPUSH
31502: CALL_OW 122
// if not j in mc_healers [ i ] then
31506: LD_VAR 0 3
31510: PUSH
31511: LD_EXP 81
31515: PUSH
31516: LD_VAR 0 2
31520: ARRAY
31521: IN
31522: NOT
31523: IFFALSE 31569
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31525: LD_ADDR_EXP 81
31529: PUSH
31530: LD_EXP 81
31534: PPUSH
31535: LD_VAR 0 2
31539: PUSH
31540: LD_EXP 81
31544: PUSH
31545: LD_VAR 0 2
31549: ARRAY
31550: PUSH
31551: LD_INT 1
31553: PLUS
31554: PUSH
31555: EMPTY
31556: LIST
31557: LIST
31558: PPUSH
31559: LD_VAR 0 3
31563: PPUSH
31564: CALL 57088 0 3
31568: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31569: LD_VAR 0 3
31573: PPUSH
31574: CALL_OW 110
31578: PUSH
31579: LD_INT 102
31581: NONEQUAL
31582: IFFALSE 31596
// SetTag ( j , 102 ) ;
31584: LD_VAR 0 3
31588: PPUSH
31589: LD_INT 102
31591: PPUSH
31592: CALL_OW 109
// Wait ( 3 ) ;
31596: LD_INT 3
31598: PPUSH
31599: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31603: LD_EXP 80
31607: PUSH
31608: LD_VAR 0 2
31612: ARRAY
31613: PUSH
31614: LD_INT 1
31616: ARRAY
31617: IFFALSE 31649
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31619: LD_VAR 0 3
31623: PPUSH
31624: LD_EXP 80
31628: PUSH
31629: LD_VAR 0 2
31633: ARRAY
31634: PUSH
31635: LD_INT 1
31637: ARRAY
31638: PUSH
31639: LD_INT 1
31641: ARRAY
31642: PPUSH
31643: CALL_OW 128
31647: GO 31705
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31649: LD_VAR 0 3
31653: PPUSH
31654: CALL_OW 314
31658: NOT
31659: PUSH
31660: LD_EXP 80
31664: PUSH
31665: LD_VAR 0 2
31669: ARRAY
31670: PUSH
31671: LD_INT 2
31673: ARRAY
31674: AND
31675: IFFALSE 31705
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31677: LD_VAR 0 3
31681: PPUSH
31682: LD_EXP 80
31686: PUSH
31687: LD_VAR 0 2
31691: ARRAY
31692: PUSH
31693: LD_INT 2
31695: ARRAY
31696: PUSH
31697: LD_INT 1
31699: ARRAY
31700: PPUSH
31701: CALL_OW 128
// end ;
31705: GO 31483
31707: POP
31708: POP
// end ;
31709: GO 31326
31711: POP
31712: POP
// end ;
31713: LD_VAR 0 1
31717: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
31718: LD_INT 0
31720: PPUSH
31721: PPUSH
31722: PPUSH
31723: PPUSH
31724: PPUSH
31725: PPUSH
// if not mc_bases then
31726: LD_EXP 77
31730: NOT
31731: IFFALSE 31735
// exit ;
31733: GO 32898
// for i = 1 to mc_bases do
31735: LD_ADDR_VAR 0 2
31739: PUSH
31740: DOUBLE
31741: LD_INT 1
31743: DEC
31744: ST_TO_ADDR
31745: LD_EXP 77
31749: PUSH
31750: FOR_TO
31751: IFFALSE 32896
// begin if mc_scan [ i ] then
31753: LD_EXP 100
31757: PUSH
31758: LD_VAR 0 2
31762: ARRAY
31763: IFFALSE 31767
// continue ;
31765: GO 31750
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31767: LD_EXP 82
31771: PUSH
31772: LD_VAR 0 2
31776: ARRAY
31777: NOT
31778: PUSH
31779: LD_EXP 84
31783: PUSH
31784: LD_VAR 0 2
31788: ARRAY
31789: NOT
31790: AND
31791: PUSH
31792: LD_EXP 83
31796: PUSH
31797: LD_VAR 0 2
31801: ARRAY
31802: AND
31803: IFFALSE 31841
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31805: LD_ADDR_EXP 83
31809: PUSH
31810: LD_EXP 83
31814: PPUSH
31815: LD_VAR 0 2
31819: PPUSH
31820: EMPTY
31821: PPUSH
31822: CALL_OW 1
31826: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31827: LD_VAR 0 2
31831: PPUSH
31832: LD_INT 103
31834: PPUSH
31835: CALL 25448 0 2
// continue ;
31839: GO 31750
// end ; if mc_construct_list [ i ] then
31841: LD_EXP 84
31845: PUSH
31846: LD_VAR 0 2
31850: ARRAY
31851: IFFALSE 32071
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31853: LD_ADDR_VAR 0 5
31857: PUSH
31858: LD_EXP 77
31862: PUSH
31863: LD_VAR 0 2
31867: ARRAY
31868: PPUSH
31869: LD_INT 25
31871: PUSH
31872: LD_INT 2
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PPUSH
31879: CALL_OW 72
31883: PUSH
31884: LD_EXP 79
31888: PUSH
31889: LD_VAR 0 2
31893: ARRAY
31894: DIFF
31895: ST_TO_ADDR
// if not tmp then
31896: LD_VAR 0 5
31900: NOT
31901: IFFALSE 31905
// continue ;
31903: GO 31750
// for j in tmp do
31905: LD_ADDR_VAR 0 3
31909: PUSH
31910: LD_VAR 0 5
31914: PUSH
31915: FOR_IN
31916: IFFALSE 32067
// begin if not mc_builders [ i ] then
31918: LD_EXP 83
31922: PUSH
31923: LD_VAR 0 2
31927: ARRAY
31928: NOT
31929: IFFALSE 31987
// begin SetTag ( j , 103 ) ;
31931: LD_VAR 0 3
31935: PPUSH
31936: LD_INT 103
31938: PPUSH
31939: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31943: LD_ADDR_EXP 83
31947: PUSH
31948: LD_EXP 83
31952: PPUSH
31953: LD_VAR 0 2
31957: PUSH
31958: LD_EXP 83
31962: PUSH
31963: LD_VAR 0 2
31967: ARRAY
31968: PUSH
31969: LD_INT 1
31971: PLUS
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: PPUSH
31977: LD_VAR 0 3
31981: PPUSH
31982: CALL 57088 0 3
31986: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31987: LD_VAR 0 3
31991: PPUSH
31992: CALL_OW 310
31996: IFFALSE 32007
// ComExitBuilding ( j ) ;
31998: LD_VAR 0 3
32002: PPUSH
32003: CALL_OW 122
// wait ( 3 ) ;
32007: LD_INT 3
32009: PPUSH
32010: CALL_OW 67
// if not mc_construct_list [ i ] then
32014: LD_EXP 84
32018: PUSH
32019: LD_VAR 0 2
32023: ARRAY
32024: NOT
32025: IFFALSE 32029
// break ;
32027: GO 32067
// if not HasTask ( j ) then
32029: LD_VAR 0 3
32033: PPUSH
32034: CALL_OW 314
32038: NOT
32039: IFFALSE 32065
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32041: LD_VAR 0 3
32045: PPUSH
32046: LD_EXP 84
32050: PUSH
32051: LD_VAR 0 2
32055: ARRAY
32056: PUSH
32057: LD_INT 1
32059: ARRAY
32060: PPUSH
32061: CALL 59949 0 2
// end ;
32065: GO 31915
32067: POP
32068: POP
// end else
32069: GO 32894
// if mc_build_list [ i ] then
32071: LD_EXP 82
32075: PUSH
32076: LD_VAR 0 2
32080: ARRAY
32081: IFFALSE 32894
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32083: LD_EXP 82
32087: PUSH
32088: LD_VAR 0 2
32092: ARRAY
32093: PUSH
32094: LD_INT 1
32096: ARRAY
32097: PUSH
32098: LD_INT 1
32100: ARRAY
32101: PPUSH
32102: CALL 59773 0 1
32106: PUSH
32107: LD_EXP 77
32111: PUSH
32112: LD_VAR 0 2
32116: ARRAY
32117: PPUSH
32118: LD_INT 2
32120: PUSH
32121: LD_INT 30
32123: PUSH
32124: LD_INT 2
32126: PUSH
32127: EMPTY
32128: LIST
32129: LIST
32130: PUSH
32131: LD_INT 30
32133: PUSH
32134: LD_INT 3
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: LIST
32145: PPUSH
32146: CALL_OW 72
32150: NOT
32151: AND
32152: IFFALSE 32257
// begin for j = 1 to mc_build_list [ i ] do
32154: LD_ADDR_VAR 0 3
32158: PUSH
32159: DOUBLE
32160: LD_INT 1
32162: DEC
32163: ST_TO_ADDR
32164: LD_EXP 82
32168: PUSH
32169: LD_VAR 0 2
32173: ARRAY
32174: PUSH
32175: FOR_TO
32176: IFFALSE 32255
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
32178: LD_EXP 82
32182: PUSH
32183: LD_VAR 0 2
32187: ARRAY
32188: PUSH
32189: LD_VAR 0 3
32193: ARRAY
32194: PUSH
32195: LD_INT 1
32197: ARRAY
32198: PUSH
32199: LD_INT 2
32201: EQUAL
32202: IFFALSE 32253
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
32204: LD_ADDR_EXP 82
32208: PUSH
32209: LD_EXP 82
32213: PPUSH
32214: LD_VAR 0 2
32218: PPUSH
32219: LD_EXP 82
32223: PUSH
32224: LD_VAR 0 2
32228: ARRAY
32229: PPUSH
32230: LD_VAR 0 3
32234: PPUSH
32235: LD_INT 1
32237: PPUSH
32238: LD_INT 0
32240: PPUSH
32241: CALL 56506 0 4
32245: PPUSH
32246: CALL_OW 1
32250: ST_TO_ADDR
// break ;
32251: GO 32255
// end ;
32253: GO 32175
32255: POP
32256: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32257: LD_ADDR_VAR 0 6
32261: PUSH
32262: LD_EXP 77
32266: PUSH
32267: LD_VAR 0 2
32271: ARRAY
32272: PPUSH
32273: LD_INT 2
32275: PUSH
32276: LD_INT 30
32278: PUSH
32279: LD_INT 0
32281: PUSH
32282: EMPTY
32283: LIST
32284: LIST
32285: PUSH
32286: LD_INT 30
32288: PUSH
32289: LD_INT 1
32291: PUSH
32292: EMPTY
32293: LIST
32294: LIST
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: LIST
32300: PPUSH
32301: CALL_OW 72
32305: ST_TO_ADDR
// for k := 1 to depot do
32306: LD_ADDR_VAR 0 4
32310: PUSH
32311: DOUBLE
32312: LD_INT 1
32314: DEC
32315: ST_TO_ADDR
32316: LD_VAR 0 6
32320: PUSH
32321: FOR_TO
32322: IFFALSE 32892
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
32324: LD_EXP 82
32328: PUSH
32329: LD_VAR 0 2
32333: ARRAY
32334: PUSH
32335: LD_INT 1
32337: ARRAY
32338: PUSH
32339: LD_INT 1
32341: ARRAY
32342: PUSH
32343: LD_INT 0
32345: EQUAL
32346: PUSH
32347: LD_VAR 0 6
32351: PUSH
32352: LD_VAR 0 4
32356: ARRAY
32357: PPUSH
32358: LD_EXP 82
32362: PUSH
32363: LD_VAR 0 2
32367: ARRAY
32368: PUSH
32369: LD_INT 1
32371: ARRAY
32372: PUSH
32373: LD_INT 1
32375: ARRAY
32376: PPUSH
32377: LD_EXP 82
32381: PUSH
32382: LD_VAR 0 2
32386: ARRAY
32387: PUSH
32388: LD_INT 1
32390: ARRAY
32391: PUSH
32392: LD_INT 2
32394: ARRAY
32395: PPUSH
32396: LD_EXP 82
32400: PUSH
32401: LD_VAR 0 2
32405: ARRAY
32406: PUSH
32407: LD_INT 1
32409: ARRAY
32410: PUSH
32411: LD_INT 3
32413: ARRAY
32414: PPUSH
32415: LD_EXP 82
32419: PUSH
32420: LD_VAR 0 2
32424: ARRAY
32425: PUSH
32426: LD_INT 1
32428: ARRAY
32429: PUSH
32430: LD_INT 4
32432: ARRAY
32433: PPUSH
32434: CALL 65185 0 5
32438: OR
32439: IFFALSE 32720
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32441: LD_ADDR_VAR 0 5
32445: PUSH
32446: LD_EXP 77
32450: PUSH
32451: LD_VAR 0 2
32455: ARRAY
32456: PPUSH
32457: LD_INT 25
32459: PUSH
32460: LD_INT 2
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: PPUSH
32467: CALL_OW 72
32471: PUSH
32472: LD_EXP 79
32476: PUSH
32477: LD_VAR 0 2
32481: ARRAY
32482: DIFF
32483: ST_TO_ADDR
// if not tmp then
32484: LD_VAR 0 5
32488: NOT
32489: IFFALSE 32493
// continue ;
32491: GO 32321
// for j in tmp do
32493: LD_ADDR_VAR 0 3
32497: PUSH
32498: LD_VAR 0 5
32502: PUSH
32503: FOR_IN
32504: IFFALSE 32716
// begin if not mc_builders [ i ] then
32506: LD_EXP 83
32510: PUSH
32511: LD_VAR 0 2
32515: ARRAY
32516: NOT
32517: IFFALSE 32575
// begin SetTag ( j , 103 ) ;
32519: LD_VAR 0 3
32523: PPUSH
32524: LD_INT 103
32526: PPUSH
32527: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32531: LD_ADDR_EXP 83
32535: PUSH
32536: LD_EXP 83
32540: PPUSH
32541: LD_VAR 0 2
32545: PUSH
32546: LD_EXP 83
32550: PUSH
32551: LD_VAR 0 2
32555: ARRAY
32556: PUSH
32557: LD_INT 1
32559: PLUS
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PPUSH
32565: LD_VAR 0 3
32569: PPUSH
32570: CALL 57088 0 3
32574: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32575: LD_VAR 0 3
32579: PPUSH
32580: CALL_OW 310
32584: IFFALSE 32595
// ComExitBuilding ( j ) ;
32586: LD_VAR 0 3
32590: PPUSH
32591: CALL_OW 122
// wait ( 3 ) ;
32595: LD_INT 3
32597: PPUSH
32598: CALL_OW 67
// if not mc_build_list [ i ] then
32602: LD_EXP 82
32606: PUSH
32607: LD_VAR 0 2
32611: ARRAY
32612: NOT
32613: IFFALSE 32617
// break ;
32615: GO 32716
// if not HasTask ( j ) then
32617: LD_VAR 0 3
32621: PPUSH
32622: CALL_OW 314
32626: NOT
32627: IFFALSE 32714
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32629: LD_VAR 0 3
32633: PPUSH
32634: LD_EXP 82
32638: PUSH
32639: LD_VAR 0 2
32643: ARRAY
32644: PUSH
32645: LD_INT 1
32647: ARRAY
32648: PUSH
32649: LD_INT 1
32651: ARRAY
32652: PPUSH
32653: LD_EXP 82
32657: PUSH
32658: LD_VAR 0 2
32662: ARRAY
32663: PUSH
32664: LD_INT 1
32666: ARRAY
32667: PUSH
32668: LD_INT 2
32670: ARRAY
32671: PPUSH
32672: LD_EXP 82
32676: PUSH
32677: LD_VAR 0 2
32681: ARRAY
32682: PUSH
32683: LD_INT 1
32685: ARRAY
32686: PUSH
32687: LD_INT 3
32689: ARRAY
32690: PPUSH
32691: LD_EXP 82
32695: PUSH
32696: LD_VAR 0 2
32700: ARRAY
32701: PUSH
32702: LD_INT 1
32704: ARRAY
32705: PUSH
32706: LD_INT 4
32708: ARRAY
32709: PPUSH
32710: CALL_OW 145
// end ;
32714: GO 32503
32716: POP
32717: POP
// end else
32718: GO 32890
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32720: LD_EXP 77
32724: PUSH
32725: LD_VAR 0 2
32729: ARRAY
32730: PPUSH
32731: LD_EXP 82
32735: PUSH
32736: LD_VAR 0 2
32740: ARRAY
32741: PUSH
32742: LD_INT 1
32744: ARRAY
32745: PUSH
32746: LD_INT 1
32748: ARRAY
32749: PPUSH
32750: LD_EXP 82
32754: PUSH
32755: LD_VAR 0 2
32759: ARRAY
32760: PUSH
32761: LD_INT 1
32763: ARRAY
32764: PUSH
32765: LD_INT 2
32767: ARRAY
32768: PPUSH
32769: LD_EXP 82
32773: PUSH
32774: LD_VAR 0 2
32778: ARRAY
32779: PUSH
32780: LD_INT 1
32782: ARRAY
32783: PUSH
32784: LD_INT 3
32786: ARRAY
32787: PPUSH
32788: LD_EXP 82
32792: PUSH
32793: LD_VAR 0 2
32797: ARRAY
32798: PUSH
32799: LD_INT 1
32801: ARRAY
32802: PUSH
32803: LD_INT 4
32805: ARRAY
32806: PPUSH
32807: LD_EXP 77
32811: PUSH
32812: LD_VAR 0 2
32816: ARRAY
32817: PPUSH
32818: LD_INT 21
32820: PUSH
32821: LD_INT 3
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PPUSH
32828: CALL_OW 72
32832: PPUSH
32833: EMPTY
32834: PPUSH
32835: CALL 63939 0 7
32839: NOT
32840: IFFALSE 32890
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32842: LD_ADDR_EXP 82
32846: PUSH
32847: LD_EXP 82
32851: PPUSH
32852: LD_VAR 0 2
32856: PPUSH
32857: LD_EXP 82
32861: PUSH
32862: LD_VAR 0 2
32866: ARRAY
32867: PPUSH
32868: LD_INT 1
32870: PPUSH
32871: LD_INT 1
32873: NEG
32874: PPUSH
32875: LD_INT 0
32877: PPUSH
32878: CALL 56506 0 4
32882: PPUSH
32883: CALL_OW 1
32887: ST_TO_ADDR
// continue ;
32888: GO 32321
// end ; end ;
32890: GO 32321
32892: POP
32893: POP
// end ; end ;
32894: GO 31750
32896: POP
32897: POP
// end ;
32898: LD_VAR 0 1
32902: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32903: LD_INT 0
32905: PPUSH
32906: PPUSH
32907: PPUSH
32908: PPUSH
32909: PPUSH
32910: PPUSH
// if not mc_bases then
32911: LD_EXP 77
32915: NOT
32916: IFFALSE 32920
// exit ;
32918: GO 33347
// for i = 1 to mc_bases do
32920: LD_ADDR_VAR 0 2
32924: PUSH
32925: DOUBLE
32926: LD_INT 1
32928: DEC
32929: ST_TO_ADDR
32930: LD_EXP 77
32934: PUSH
32935: FOR_TO
32936: IFFALSE 33345
// begin tmp := mc_build_upgrade [ i ] ;
32938: LD_ADDR_VAR 0 4
32942: PUSH
32943: LD_EXP 109
32947: PUSH
32948: LD_VAR 0 2
32952: ARRAY
32953: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32954: LD_ADDR_VAR 0 6
32958: PUSH
32959: LD_EXP 110
32963: PUSH
32964: LD_VAR 0 2
32968: ARRAY
32969: PPUSH
32970: LD_INT 2
32972: PUSH
32973: LD_INT 30
32975: PUSH
32976: LD_INT 6
32978: PUSH
32979: EMPTY
32980: LIST
32981: LIST
32982: PUSH
32983: LD_INT 30
32985: PUSH
32986: LD_INT 7
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: LIST
32997: PPUSH
32998: CALL_OW 72
33002: ST_TO_ADDR
// if not tmp and not lab then
33003: LD_VAR 0 4
33007: NOT
33008: PUSH
33009: LD_VAR 0 6
33013: NOT
33014: AND
33015: IFFALSE 33019
// continue ;
33017: GO 32935
// if tmp then
33019: LD_VAR 0 4
33023: IFFALSE 33143
// for j in tmp do
33025: LD_ADDR_VAR 0 3
33029: PUSH
33030: LD_VAR 0 4
33034: PUSH
33035: FOR_IN
33036: IFFALSE 33141
// begin if UpgradeCost ( j ) then
33038: LD_VAR 0 3
33042: PPUSH
33043: CALL 63599 0 1
33047: IFFALSE 33139
// begin ComUpgrade ( j ) ;
33049: LD_VAR 0 3
33053: PPUSH
33054: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33058: LD_ADDR_EXP 109
33062: PUSH
33063: LD_EXP 109
33067: PPUSH
33068: LD_VAR 0 2
33072: PPUSH
33073: LD_EXP 109
33077: PUSH
33078: LD_VAR 0 2
33082: ARRAY
33083: PUSH
33084: LD_VAR 0 3
33088: DIFF
33089: PPUSH
33090: CALL_OW 1
33094: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33095: LD_ADDR_EXP 84
33099: PUSH
33100: LD_EXP 84
33104: PPUSH
33105: LD_VAR 0 2
33109: PUSH
33110: LD_EXP 84
33114: PUSH
33115: LD_VAR 0 2
33119: ARRAY
33120: PUSH
33121: LD_INT 1
33123: PLUS
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PPUSH
33129: LD_VAR 0 3
33133: PPUSH
33134: CALL 57088 0 3
33138: ST_TO_ADDR
// end ; end ;
33139: GO 33035
33141: POP
33142: POP
// if not lab or not mc_lab_upgrade [ i ] then
33143: LD_VAR 0 6
33147: NOT
33148: PUSH
33149: LD_EXP 111
33153: PUSH
33154: LD_VAR 0 2
33158: ARRAY
33159: NOT
33160: OR
33161: IFFALSE 33165
// continue ;
33163: GO 32935
// for j in lab do
33165: LD_ADDR_VAR 0 3
33169: PUSH
33170: LD_VAR 0 6
33174: PUSH
33175: FOR_IN
33176: IFFALSE 33341
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
33178: LD_VAR 0 3
33182: PPUSH
33183: CALL_OW 266
33187: PUSH
33188: LD_INT 6
33190: PUSH
33191: LD_INT 7
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: IN
33198: PUSH
33199: LD_VAR 0 3
33203: PPUSH
33204: CALL_OW 461
33208: PUSH
33209: LD_INT 1
33211: NONEQUAL
33212: AND
33213: IFFALSE 33339
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
33215: LD_VAR 0 3
33219: PPUSH
33220: LD_EXP 111
33224: PUSH
33225: LD_VAR 0 2
33229: ARRAY
33230: PUSH
33231: LD_INT 1
33233: ARRAY
33234: PPUSH
33235: CALL 63804 0 2
33239: IFFALSE 33339
// begin ComCancel ( j ) ;
33241: LD_VAR 0 3
33245: PPUSH
33246: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
33250: LD_VAR 0 3
33254: PPUSH
33255: LD_EXP 111
33259: PUSH
33260: LD_VAR 0 2
33264: ARRAY
33265: PUSH
33266: LD_INT 1
33268: ARRAY
33269: PPUSH
33270: CALL_OW 207
// if not j in mc_construct_list [ i ] then
33274: LD_VAR 0 3
33278: PUSH
33279: LD_EXP 84
33283: PUSH
33284: LD_VAR 0 2
33288: ARRAY
33289: IN
33290: NOT
33291: IFFALSE 33337
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33293: LD_ADDR_EXP 84
33297: PUSH
33298: LD_EXP 84
33302: PPUSH
33303: LD_VAR 0 2
33307: PUSH
33308: LD_EXP 84
33312: PUSH
33313: LD_VAR 0 2
33317: ARRAY
33318: PUSH
33319: LD_INT 1
33321: PLUS
33322: PUSH
33323: EMPTY
33324: LIST
33325: LIST
33326: PPUSH
33327: LD_VAR 0 3
33331: PPUSH
33332: CALL 57088 0 3
33336: ST_TO_ADDR
// break ;
33337: GO 33341
// end ; end ; end ;
33339: GO 33175
33341: POP
33342: POP
// end ;
33343: GO 32935
33345: POP
33346: POP
// end ;
33347: LD_VAR 0 1
33351: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
33352: LD_INT 0
33354: PPUSH
33355: PPUSH
33356: PPUSH
33357: PPUSH
33358: PPUSH
33359: PPUSH
33360: PPUSH
33361: PPUSH
33362: PPUSH
// if not mc_bases then
33363: LD_EXP 77
33367: NOT
33368: IFFALSE 33372
// exit ;
33370: GO 33777
// for i = 1 to mc_bases do
33372: LD_ADDR_VAR 0 2
33376: PUSH
33377: DOUBLE
33378: LD_INT 1
33380: DEC
33381: ST_TO_ADDR
33382: LD_EXP 77
33386: PUSH
33387: FOR_TO
33388: IFFALSE 33775
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
33390: LD_EXP 85
33394: PUSH
33395: LD_VAR 0 2
33399: ARRAY
33400: NOT
33401: PUSH
33402: LD_EXP 77
33406: PUSH
33407: LD_VAR 0 2
33411: ARRAY
33412: PPUSH
33413: LD_INT 30
33415: PUSH
33416: LD_INT 3
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PPUSH
33423: CALL_OW 72
33427: NOT
33428: OR
33429: IFFALSE 33433
// continue ;
33431: GO 33387
// busy := false ;
33433: LD_ADDR_VAR 0 8
33437: PUSH
33438: LD_INT 0
33440: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33441: LD_ADDR_VAR 0 4
33445: PUSH
33446: LD_EXP 77
33450: PUSH
33451: LD_VAR 0 2
33455: ARRAY
33456: PPUSH
33457: LD_INT 30
33459: PUSH
33460: LD_INT 3
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: PPUSH
33467: CALL_OW 72
33471: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33472: LD_ADDR_VAR 0 6
33476: PUSH
33477: LD_EXP 85
33481: PUSH
33482: LD_VAR 0 2
33486: ARRAY
33487: PPUSH
33488: LD_INT 2
33490: PUSH
33491: LD_INT 30
33493: PUSH
33494: LD_INT 32
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PUSH
33501: LD_INT 30
33503: PUSH
33504: LD_INT 33
33506: PUSH
33507: EMPTY
33508: LIST
33509: LIST
33510: PUSH
33511: EMPTY
33512: LIST
33513: LIST
33514: LIST
33515: PPUSH
33516: CALL_OW 72
33520: ST_TO_ADDR
// if not t then
33521: LD_VAR 0 6
33525: NOT
33526: IFFALSE 33530
// continue ;
33528: GO 33387
// for j in tmp do
33530: LD_ADDR_VAR 0 3
33534: PUSH
33535: LD_VAR 0 4
33539: PUSH
33540: FOR_IN
33541: IFFALSE 33571
// if not BuildingStatus ( j ) = bs_idle then
33543: LD_VAR 0 3
33547: PPUSH
33548: CALL_OW 461
33552: PUSH
33553: LD_INT 2
33555: EQUAL
33556: NOT
33557: IFFALSE 33569
// begin busy := true ;
33559: LD_ADDR_VAR 0 8
33563: PUSH
33564: LD_INT 1
33566: ST_TO_ADDR
// break ;
33567: GO 33571
// end ;
33569: GO 33540
33571: POP
33572: POP
// if busy then
33573: LD_VAR 0 8
33577: IFFALSE 33581
// continue ;
33579: GO 33387
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33581: LD_ADDR_VAR 0 7
33585: PUSH
33586: LD_VAR 0 6
33590: PPUSH
33591: LD_INT 35
33593: PUSH
33594: LD_INT 0
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PPUSH
33601: CALL_OW 72
33605: ST_TO_ADDR
// if tw then
33606: LD_VAR 0 7
33610: IFFALSE 33687
// begin tw := tw [ 1 ] ;
33612: LD_ADDR_VAR 0 7
33616: PUSH
33617: LD_VAR 0 7
33621: PUSH
33622: LD_INT 1
33624: ARRAY
33625: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33626: LD_ADDR_VAR 0 9
33630: PUSH
33631: LD_VAR 0 7
33635: PPUSH
33636: LD_EXP 102
33640: PUSH
33641: LD_VAR 0 2
33645: ARRAY
33646: PPUSH
33647: CALL 62096 0 2
33651: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33652: LD_EXP 116
33656: PUSH
33657: LD_VAR 0 2
33661: ARRAY
33662: IFFALSE 33685
// if not weapon in mc_allowed_tower_weapons [ i ] then
33664: LD_VAR 0 9
33668: PUSH
33669: LD_EXP 116
33673: PUSH
33674: LD_VAR 0 2
33678: ARRAY
33679: IN
33680: NOT
33681: IFFALSE 33685
// continue ;
33683: GO 33387
// end else
33685: GO 33750
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33687: LD_ADDR_VAR 0 5
33691: PUSH
33692: LD_EXP 85
33696: PUSH
33697: LD_VAR 0 2
33701: ARRAY
33702: PPUSH
33703: LD_VAR 0 4
33707: PPUSH
33708: CALL 88948 0 2
33712: ST_TO_ADDR
// if not tmp2 then
33713: LD_VAR 0 5
33717: NOT
33718: IFFALSE 33722
// continue ;
33720: GO 33387
// tw := tmp2 [ 1 ] ;
33722: LD_ADDR_VAR 0 7
33726: PUSH
33727: LD_VAR 0 5
33731: PUSH
33732: LD_INT 1
33734: ARRAY
33735: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33736: LD_ADDR_VAR 0 9
33740: PUSH
33741: LD_VAR 0 5
33745: PUSH
33746: LD_INT 2
33748: ARRAY
33749: ST_TO_ADDR
// end ; if not weapon then
33750: LD_VAR 0 9
33754: NOT
33755: IFFALSE 33759
// continue ;
33757: GO 33387
// ComPlaceWeapon ( tw , weapon ) ;
33759: LD_VAR 0 7
33763: PPUSH
33764: LD_VAR 0 9
33768: PPUSH
33769: CALL_OW 148
// end ;
33773: GO 33387
33775: POP
33776: POP
// end ;
33777: LD_VAR 0 1
33781: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33782: LD_INT 0
33784: PPUSH
33785: PPUSH
33786: PPUSH
33787: PPUSH
33788: PPUSH
33789: PPUSH
33790: PPUSH
// if not mc_bases then
33791: LD_EXP 77
33795: NOT
33796: IFFALSE 33800
// exit ;
33798: GO 34568
// for i = 1 to mc_bases do
33800: LD_ADDR_VAR 0 2
33804: PUSH
33805: DOUBLE
33806: LD_INT 1
33808: DEC
33809: ST_TO_ADDR
33810: LD_EXP 77
33814: PUSH
33815: FOR_TO
33816: IFFALSE 34566
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33818: LD_EXP 90
33822: PUSH
33823: LD_VAR 0 2
33827: ARRAY
33828: NOT
33829: PUSH
33830: LD_EXP 90
33834: PUSH
33835: LD_VAR 0 2
33839: ARRAY
33840: PUSH
33841: LD_EXP 91
33845: PUSH
33846: LD_VAR 0 2
33850: ARRAY
33851: EQUAL
33852: OR
33853: PUSH
33854: LD_EXP 100
33858: PUSH
33859: LD_VAR 0 2
33863: ARRAY
33864: OR
33865: IFFALSE 33869
// continue ;
33867: GO 33815
// if mc_miners [ i ] then
33869: LD_EXP 91
33873: PUSH
33874: LD_VAR 0 2
33878: ARRAY
33879: IFFALSE 34253
// begin for j = mc_miners [ i ] downto 1 do
33881: LD_ADDR_VAR 0 3
33885: PUSH
33886: DOUBLE
33887: LD_EXP 91
33891: PUSH
33892: LD_VAR 0 2
33896: ARRAY
33897: INC
33898: ST_TO_ADDR
33899: LD_INT 1
33901: PUSH
33902: FOR_DOWNTO
33903: IFFALSE 34251
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33905: LD_EXP 91
33909: PUSH
33910: LD_VAR 0 2
33914: ARRAY
33915: PUSH
33916: LD_VAR 0 3
33920: ARRAY
33921: PPUSH
33922: CALL_OW 301
33926: PUSH
33927: LD_EXP 91
33931: PUSH
33932: LD_VAR 0 2
33936: ARRAY
33937: PUSH
33938: LD_VAR 0 3
33942: ARRAY
33943: PPUSH
33944: CALL_OW 257
33948: PUSH
33949: LD_INT 1
33951: NONEQUAL
33952: OR
33953: IFFALSE 34016
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33955: LD_ADDR_VAR 0 5
33959: PUSH
33960: LD_EXP 91
33964: PUSH
33965: LD_VAR 0 2
33969: ARRAY
33970: PUSH
33971: LD_EXP 91
33975: PUSH
33976: LD_VAR 0 2
33980: ARRAY
33981: PUSH
33982: LD_VAR 0 3
33986: ARRAY
33987: DIFF
33988: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33989: LD_ADDR_EXP 91
33993: PUSH
33994: LD_EXP 91
33998: PPUSH
33999: LD_VAR 0 2
34003: PPUSH
34004: LD_VAR 0 5
34008: PPUSH
34009: CALL_OW 1
34013: ST_TO_ADDR
// continue ;
34014: GO 33902
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34016: LD_EXP 91
34020: PUSH
34021: LD_VAR 0 2
34025: ARRAY
34026: PUSH
34027: LD_VAR 0 3
34031: ARRAY
34032: PPUSH
34033: CALL_OW 257
34037: PUSH
34038: LD_INT 1
34040: EQUAL
34041: PUSH
34042: LD_EXP 91
34046: PUSH
34047: LD_VAR 0 2
34051: ARRAY
34052: PUSH
34053: LD_VAR 0 3
34057: ARRAY
34058: PPUSH
34059: CALL_OW 459
34063: NOT
34064: AND
34065: PUSH
34066: LD_EXP 91
34070: PUSH
34071: LD_VAR 0 2
34075: ARRAY
34076: PUSH
34077: LD_VAR 0 3
34081: ARRAY
34082: PPUSH
34083: CALL_OW 314
34087: NOT
34088: AND
34089: IFFALSE 34249
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34091: LD_EXP 91
34095: PUSH
34096: LD_VAR 0 2
34100: ARRAY
34101: PUSH
34102: LD_VAR 0 3
34106: ARRAY
34107: PPUSH
34108: CALL_OW 310
34112: IFFALSE 34135
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34114: LD_EXP 91
34118: PUSH
34119: LD_VAR 0 2
34123: ARRAY
34124: PUSH
34125: LD_VAR 0 3
34129: ARRAY
34130: PPUSH
34131: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34135: LD_EXP 91
34139: PUSH
34140: LD_VAR 0 2
34144: ARRAY
34145: PUSH
34146: LD_VAR 0 3
34150: ARRAY
34151: PPUSH
34152: CALL_OW 314
34156: NOT
34157: IFFALSE 34249
// begin r := rand ( 1 , mc_mines [ i ] ) ;
34159: LD_ADDR_VAR 0 7
34163: PUSH
34164: LD_INT 1
34166: PPUSH
34167: LD_EXP 90
34171: PUSH
34172: LD_VAR 0 2
34176: ARRAY
34177: PPUSH
34178: CALL_OW 12
34182: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
34183: LD_EXP 91
34187: PUSH
34188: LD_VAR 0 2
34192: ARRAY
34193: PUSH
34194: LD_VAR 0 3
34198: ARRAY
34199: PPUSH
34200: LD_EXP 90
34204: PUSH
34205: LD_VAR 0 2
34209: ARRAY
34210: PUSH
34211: LD_VAR 0 7
34215: ARRAY
34216: PUSH
34217: LD_INT 1
34219: ARRAY
34220: PPUSH
34221: LD_EXP 90
34225: PUSH
34226: LD_VAR 0 2
34230: ARRAY
34231: PUSH
34232: LD_VAR 0 7
34236: ARRAY
34237: PUSH
34238: LD_INT 2
34240: ARRAY
34241: PPUSH
34242: LD_INT 0
34244: PPUSH
34245: CALL_OW 193
// end ; end ; end ;
34249: GO 33902
34251: POP
34252: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
34253: LD_ADDR_VAR 0 5
34257: PUSH
34258: LD_EXP 77
34262: PUSH
34263: LD_VAR 0 2
34267: ARRAY
34268: PPUSH
34269: LD_INT 2
34271: PUSH
34272: LD_INT 30
34274: PUSH
34275: LD_INT 4
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: PUSH
34282: LD_INT 30
34284: PUSH
34285: LD_INT 5
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 30
34294: PUSH
34295: LD_INT 32
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: LIST
34306: LIST
34307: PPUSH
34308: CALL_OW 72
34312: ST_TO_ADDR
// if not tmp then
34313: LD_VAR 0 5
34317: NOT
34318: IFFALSE 34322
// continue ;
34320: GO 33815
// list := [ ] ;
34322: LD_ADDR_VAR 0 6
34326: PUSH
34327: EMPTY
34328: ST_TO_ADDR
// for j in tmp do
34329: LD_ADDR_VAR 0 3
34333: PUSH
34334: LD_VAR 0 5
34338: PUSH
34339: FOR_IN
34340: IFFALSE 34409
// begin for k in UnitsInside ( j ) do
34342: LD_ADDR_VAR 0 4
34346: PUSH
34347: LD_VAR 0 3
34351: PPUSH
34352: CALL_OW 313
34356: PUSH
34357: FOR_IN
34358: IFFALSE 34405
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
34360: LD_VAR 0 4
34364: PPUSH
34365: CALL_OW 257
34369: PUSH
34370: LD_INT 1
34372: EQUAL
34373: PUSH
34374: LD_VAR 0 4
34378: PPUSH
34379: CALL_OW 459
34383: NOT
34384: AND
34385: IFFALSE 34403
// list := list ^ k ;
34387: LD_ADDR_VAR 0 6
34391: PUSH
34392: LD_VAR 0 6
34396: PUSH
34397: LD_VAR 0 4
34401: ADD
34402: ST_TO_ADDR
34403: GO 34357
34405: POP
34406: POP
// end ;
34407: GO 34339
34409: POP
34410: POP
// list := list diff mc_miners [ i ] ;
34411: LD_ADDR_VAR 0 6
34415: PUSH
34416: LD_VAR 0 6
34420: PUSH
34421: LD_EXP 91
34425: PUSH
34426: LD_VAR 0 2
34430: ARRAY
34431: DIFF
34432: ST_TO_ADDR
// if not list then
34433: LD_VAR 0 6
34437: NOT
34438: IFFALSE 34442
// continue ;
34440: GO 33815
// k := mc_mines [ i ] - mc_miners [ i ] ;
34442: LD_ADDR_VAR 0 4
34446: PUSH
34447: LD_EXP 90
34451: PUSH
34452: LD_VAR 0 2
34456: ARRAY
34457: PUSH
34458: LD_EXP 91
34462: PUSH
34463: LD_VAR 0 2
34467: ARRAY
34468: MINUS
34469: ST_TO_ADDR
// if k > list then
34470: LD_VAR 0 4
34474: PUSH
34475: LD_VAR 0 6
34479: GREATER
34480: IFFALSE 34492
// k := list ;
34482: LD_ADDR_VAR 0 4
34486: PUSH
34487: LD_VAR 0 6
34491: ST_TO_ADDR
// for j = 1 to k do
34492: LD_ADDR_VAR 0 3
34496: PUSH
34497: DOUBLE
34498: LD_INT 1
34500: DEC
34501: ST_TO_ADDR
34502: LD_VAR 0 4
34506: PUSH
34507: FOR_TO
34508: IFFALSE 34562
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34510: LD_ADDR_EXP 91
34514: PUSH
34515: LD_EXP 91
34519: PPUSH
34520: LD_VAR 0 2
34524: PUSH
34525: LD_EXP 91
34529: PUSH
34530: LD_VAR 0 2
34534: ARRAY
34535: PUSH
34536: LD_INT 1
34538: PLUS
34539: PUSH
34540: EMPTY
34541: LIST
34542: LIST
34543: PPUSH
34544: LD_VAR 0 6
34548: PUSH
34549: LD_VAR 0 3
34553: ARRAY
34554: PPUSH
34555: CALL 57088 0 3
34559: ST_TO_ADDR
34560: GO 34507
34562: POP
34563: POP
// end ;
34564: GO 33815
34566: POP
34567: POP
// end ;
34568: LD_VAR 0 1
34572: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34573: LD_INT 0
34575: PPUSH
34576: PPUSH
34577: PPUSH
34578: PPUSH
34579: PPUSH
34580: PPUSH
34581: PPUSH
34582: PPUSH
34583: PPUSH
34584: PPUSH
34585: PPUSH
// if not mc_bases then
34586: LD_EXP 77
34590: NOT
34591: IFFALSE 34595
// exit ;
34593: GO 36418
// for i = 1 to mc_bases do
34595: LD_ADDR_VAR 0 2
34599: PUSH
34600: DOUBLE
34601: LD_INT 1
34603: DEC
34604: ST_TO_ADDR
34605: LD_EXP 77
34609: PUSH
34610: FOR_TO
34611: IFFALSE 36416
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34613: LD_EXP 77
34617: PUSH
34618: LD_VAR 0 2
34622: ARRAY
34623: NOT
34624: PUSH
34625: LD_EXP 84
34629: PUSH
34630: LD_VAR 0 2
34634: ARRAY
34635: OR
34636: IFFALSE 34640
// continue ;
34638: GO 34610
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34640: LD_EXP 93
34644: PUSH
34645: LD_VAR 0 2
34649: ARRAY
34650: NOT
34651: PUSH
34652: LD_EXP 94
34656: PUSH
34657: LD_VAR 0 2
34661: ARRAY
34662: AND
34663: IFFALSE 34701
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34665: LD_ADDR_EXP 94
34669: PUSH
34670: LD_EXP 94
34674: PPUSH
34675: LD_VAR 0 2
34679: PPUSH
34680: EMPTY
34681: PPUSH
34682: CALL_OW 1
34686: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34687: LD_VAR 0 2
34691: PPUSH
34692: LD_INT 107
34694: PPUSH
34695: CALL 25448 0 2
// continue ;
34699: GO 34610
// end ; target := [ ] ;
34701: LD_ADDR_VAR 0 7
34705: PUSH
34706: EMPTY
34707: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34708: LD_ADDR_VAR 0 6
34712: PUSH
34713: LD_EXP 77
34717: PUSH
34718: LD_VAR 0 2
34722: ARRAY
34723: PUSH
34724: LD_INT 1
34726: ARRAY
34727: PPUSH
34728: CALL_OW 255
34732: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34733: LD_ADDR_VAR 0 9
34737: PUSH
34738: LD_EXP 77
34742: PUSH
34743: LD_VAR 0 2
34747: ARRAY
34748: PPUSH
34749: LD_INT 2
34751: PUSH
34752: LD_INT 30
34754: PUSH
34755: LD_INT 0
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 30
34764: PUSH
34765: LD_INT 1
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: LIST
34776: PPUSH
34777: CALL_OW 72
34781: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34782: LD_ADDR_VAR 0 3
34786: PUSH
34787: DOUBLE
34788: LD_EXP 93
34792: PUSH
34793: LD_VAR 0 2
34797: ARRAY
34798: INC
34799: ST_TO_ADDR
34800: LD_INT 1
34802: PUSH
34803: FOR_DOWNTO
34804: IFFALSE 35049
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34806: LD_EXP 93
34810: PUSH
34811: LD_VAR 0 2
34815: ARRAY
34816: PUSH
34817: LD_VAR 0 3
34821: ARRAY
34822: PUSH
34823: LD_INT 2
34825: ARRAY
34826: PPUSH
34827: LD_EXP 93
34831: PUSH
34832: LD_VAR 0 2
34836: ARRAY
34837: PUSH
34838: LD_VAR 0 3
34842: ARRAY
34843: PUSH
34844: LD_INT 3
34846: ARRAY
34847: PPUSH
34848: CALL_OW 488
34852: PUSH
34853: LD_EXP 93
34857: PUSH
34858: LD_VAR 0 2
34862: ARRAY
34863: PUSH
34864: LD_VAR 0 3
34868: ARRAY
34869: PUSH
34870: LD_INT 2
34872: ARRAY
34873: PPUSH
34874: LD_EXP 93
34878: PUSH
34879: LD_VAR 0 2
34883: ARRAY
34884: PUSH
34885: LD_VAR 0 3
34889: ARRAY
34890: PUSH
34891: LD_INT 3
34893: ARRAY
34894: PPUSH
34895: CALL_OW 284
34899: PUSH
34900: LD_INT 0
34902: EQUAL
34903: AND
34904: IFFALSE 34959
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34906: LD_ADDR_VAR 0 5
34910: PUSH
34911: LD_EXP 93
34915: PUSH
34916: LD_VAR 0 2
34920: ARRAY
34921: PPUSH
34922: LD_VAR 0 3
34926: PPUSH
34927: CALL_OW 3
34931: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34932: LD_ADDR_EXP 93
34936: PUSH
34937: LD_EXP 93
34941: PPUSH
34942: LD_VAR 0 2
34946: PPUSH
34947: LD_VAR 0 5
34951: PPUSH
34952: CALL_OW 1
34956: ST_TO_ADDR
// continue ;
34957: GO 34803
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34959: LD_VAR 0 6
34963: PPUSH
34964: LD_EXP 93
34968: PUSH
34969: LD_VAR 0 2
34973: ARRAY
34974: PUSH
34975: LD_VAR 0 3
34979: ARRAY
34980: PUSH
34981: LD_INT 2
34983: ARRAY
34984: PPUSH
34985: LD_EXP 93
34989: PUSH
34990: LD_VAR 0 2
34994: ARRAY
34995: PUSH
34996: LD_VAR 0 3
35000: ARRAY
35001: PUSH
35002: LD_INT 3
35004: ARRAY
35005: PPUSH
35006: LD_INT 30
35008: PPUSH
35009: CALL 57984 0 4
35013: PUSH
35014: LD_INT 4
35016: ARRAY
35017: PUSH
35018: LD_INT 0
35020: EQUAL
35021: IFFALSE 35047
// begin target := mc_crates [ i ] [ j ] ;
35023: LD_ADDR_VAR 0 7
35027: PUSH
35028: LD_EXP 93
35032: PUSH
35033: LD_VAR 0 2
35037: ARRAY
35038: PUSH
35039: LD_VAR 0 3
35043: ARRAY
35044: ST_TO_ADDR
// break ;
35045: GO 35049
// end ; end ;
35047: GO 34803
35049: POP
35050: POP
// if not target then
35051: LD_VAR 0 7
35055: NOT
35056: IFFALSE 35060
// continue ;
35058: GO 34610
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35060: LD_ADDR_VAR 0 8
35064: PUSH
35065: LD_EXP 96
35069: PUSH
35070: LD_VAR 0 2
35074: ARRAY
35075: PPUSH
35076: LD_INT 2
35078: PUSH
35079: LD_INT 3
35081: PUSH
35082: LD_INT 58
35084: PUSH
35085: EMPTY
35086: LIST
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 61
35094: PUSH
35095: EMPTY
35096: LIST
35097: PUSH
35098: LD_INT 33
35100: PUSH
35101: LD_INT 5
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 33
35110: PUSH
35111: LD_INT 3
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: PUSH
35125: LD_INT 2
35127: PUSH
35128: LD_INT 34
35130: PUSH
35131: LD_INT 32
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 34
35140: PUSH
35141: LD_INT 51
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 34
35150: PUSH
35151: LD_INT 12
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: EMPTY
35159: LIST
35160: LIST
35161: LIST
35162: LIST
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PPUSH
35168: CALL_OW 72
35172: ST_TO_ADDR
// if not cargo then
35173: LD_VAR 0 8
35177: NOT
35178: IFFALSE 35884
// begin if mc_crates_collector [ i ] < 5 then
35180: LD_EXP 94
35184: PUSH
35185: LD_VAR 0 2
35189: ARRAY
35190: PUSH
35191: LD_INT 5
35193: LESS
35194: IFFALSE 35560
// begin if mc_ape [ i ] then
35196: LD_EXP 106
35200: PUSH
35201: LD_VAR 0 2
35205: ARRAY
35206: IFFALSE 35253
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
35208: LD_ADDR_VAR 0 5
35212: PUSH
35213: LD_EXP 106
35217: PUSH
35218: LD_VAR 0 2
35222: ARRAY
35223: PPUSH
35224: LD_INT 25
35226: PUSH
35227: LD_INT 16
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 24
35236: PUSH
35237: LD_INT 750
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PUSH
35244: EMPTY
35245: LIST
35246: LIST
35247: PPUSH
35248: CALL_OW 72
35252: ST_TO_ADDR
// if not tmp then
35253: LD_VAR 0 5
35257: NOT
35258: IFFALSE 35305
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
35260: LD_ADDR_VAR 0 5
35264: PUSH
35265: LD_EXP 77
35269: PUSH
35270: LD_VAR 0 2
35274: ARRAY
35275: PPUSH
35276: LD_INT 25
35278: PUSH
35279: LD_INT 2
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 24
35288: PUSH
35289: LD_INT 750
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PPUSH
35300: CALL_OW 72
35304: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
35305: LD_EXP 106
35309: PUSH
35310: LD_VAR 0 2
35314: ARRAY
35315: PUSH
35316: LD_EXP 77
35320: PUSH
35321: LD_VAR 0 2
35325: ARRAY
35326: PPUSH
35327: LD_INT 25
35329: PUSH
35330: LD_INT 2
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 24
35339: PUSH
35340: LD_INT 750
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PPUSH
35351: CALL_OW 72
35355: AND
35356: PUSH
35357: LD_VAR 0 5
35361: PUSH
35362: LD_INT 5
35364: LESS
35365: AND
35366: IFFALSE 35448
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
35368: LD_ADDR_VAR 0 3
35372: PUSH
35373: LD_EXP 77
35377: PUSH
35378: LD_VAR 0 2
35382: ARRAY
35383: PPUSH
35384: LD_INT 25
35386: PUSH
35387: LD_INT 2
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 24
35396: PUSH
35397: LD_INT 750
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PPUSH
35408: CALL_OW 72
35412: PUSH
35413: FOR_IN
35414: IFFALSE 35446
// begin tmp := tmp union j ;
35416: LD_ADDR_VAR 0 5
35420: PUSH
35421: LD_VAR 0 5
35425: PUSH
35426: LD_VAR 0 3
35430: UNION
35431: ST_TO_ADDR
// if tmp >= 5 then
35432: LD_VAR 0 5
35436: PUSH
35437: LD_INT 5
35439: GREATEREQUAL
35440: IFFALSE 35444
// break ;
35442: GO 35446
// end ;
35444: GO 35413
35446: POP
35447: POP
// end ; if not tmp then
35448: LD_VAR 0 5
35452: NOT
35453: IFFALSE 35457
// continue ;
35455: GO 34610
// for j in tmp do
35457: LD_ADDR_VAR 0 3
35461: PUSH
35462: LD_VAR 0 5
35466: PUSH
35467: FOR_IN
35468: IFFALSE 35558
// if not GetTag ( j ) then
35470: LD_VAR 0 3
35474: PPUSH
35475: CALL_OW 110
35479: NOT
35480: IFFALSE 35556
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35482: LD_ADDR_EXP 94
35486: PUSH
35487: LD_EXP 94
35491: PPUSH
35492: LD_VAR 0 2
35496: PUSH
35497: LD_EXP 94
35501: PUSH
35502: LD_VAR 0 2
35506: ARRAY
35507: PUSH
35508: LD_INT 1
35510: PLUS
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PPUSH
35516: LD_VAR 0 3
35520: PPUSH
35521: CALL 57088 0 3
35525: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35526: LD_VAR 0 3
35530: PPUSH
35531: LD_INT 107
35533: PPUSH
35534: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35538: LD_EXP 94
35542: PUSH
35543: LD_VAR 0 2
35547: ARRAY
35548: PUSH
35549: LD_INT 5
35551: GREATEREQUAL
35552: IFFALSE 35556
// break ;
35554: GO 35558
// end ;
35556: GO 35467
35558: POP
35559: POP
// end ; if mc_crates_collector [ i ] and target then
35560: LD_EXP 94
35564: PUSH
35565: LD_VAR 0 2
35569: ARRAY
35570: PUSH
35571: LD_VAR 0 7
35575: AND
35576: IFFALSE 35882
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35578: LD_EXP 94
35582: PUSH
35583: LD_VAR 0 2
35587: ARRAY
35588: PUSH
35589: LD_VAR 0 7
35593: PUSH
35594: LD_INT 1
35596: ARRAY
35597: LESS
35598: IFFALSE 35618
// tmp := mc_crates_collector [ i ] else
35600: LD_ADDR_VAR 0 5
35604: PUSH
35605: LD_EXP 94
35609: PUSH
35610: LD_VAR 0 2
35614: ARRAY
35615: ST_TO_ADDR
35616: GO 35632
// tmp := target [ 1 ] ;
35618: LD_ADDR_VAR 0 5
35622: PUSH
35623: LD_VAR 0 7
35627: PUSH
35628: LD_INT 1
35630: ARRAY
35631: ST_TO_ADDR
// k := 0 ;
35632: LD_ADDR_VAR 0 4
35636: PUSH
35637: LD_INT 0
35639: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35640: LD_ADDR_VAR 0 3
35644: PUSH
35645: LD_EXP 94
35649: PUSH
35650: LD_VAR 0 2
35654: ARRAY
35655: PUSH
35656: FOR_IN
35657: IFFALSE 35880
// begin k := k + 1 ;
35659: LD_ADDR_VAR 0 4
35663: PUSH
35664: LD_VAR 0 4
35668: PUSH
35669: LD_INT 1
35671: PLUS
35672: ST_TO_ADDR
// if k > tmp then
35673: LD_VAR 0 4
35677: PUSH
35678: LD_VAR 0 5
35682: GREATER
35683: IFFALSE 35687
// break ;
35685: GO 35880
// if not GetClass ( j ) in [ 2 , 16 ] then
35687: LD_VAR 0 3
35691: PPUSH
35692: CALL_OW 257
35696: PUSH
35697: LD_INT 2
35699: PUSH
35700: LD_INT 16
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: IN
35707: NOT
35708: IFFALSE 35761
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35710: LD_ADDR_EXP 94
35714: PUSH
35715: LD_EXP 94
35719: PPUSH
35720: LD_VAR 0 2
35724: PPUSH
35725: LD_EXP 94
35729: PUSH
35730: LD_VAR 0 2
35734: ARRAY
35735: PUSH
35736: LD_VAR 0 3
35740: DIFF
35741: PPUSH
35742: CALL_OW 1
35746: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35747: LD_VAR 0 3
35751: PPUSH
35752: LD_INT 0
35754: PPUSH
35755: CALL_OW 109
// continue ;
35759: GO 35656
// end ; if IsInUnit ( j ) then
35761: LD_VAR 0 3
35765: PPUSH
35766: CALL_OW 310
35770: IFFALSE 35781
// ComExitBuilding ( j ) ;
35772: LD_VAR 0 3
35776: PPUSH
35777: CALL_OW 122
// wait ( 3 ) ;
35781: LD_INT 3
35783: PPUSH
35784: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35788: LD_VAR 0 3
35792: PPUSH
35793: CALL_OW 314
35797: PUSH
35798: LD_VAR 0 6
35802: PPUSH
35803: LD_VAR 0 7
35807: PUSH
35808: LD_INT 2
35810: ARRAY
35811: PPUSH
35812: LD_VAR 0 7
35816: PUSH
35817: LD_INT 3
35819: ARRAY
35820: PPUSH
35821: LD_INT 30
35823: PPUSH
35824: CALL 57984 0 4
35828: PUSH
35829: LD_INT 4
35831: ARRAY
35832: AND
35833: IFFALSE 35851
// ComStandNearbyBuilding ( j , depot ) else
35835: LD_VAR 0 3
35839: PPUSH
35840: LD_VAR 0 9
35844: PPUSH
35845: CALL 53515 0 2
35849: GO 35878
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35851: LD_VAR 0 3
35855: PPUSH
35856: LD_VAR 0 7
35860: PUSH
35861: LD_INT 2
35863: ARRAY
35864: PPUSH
35865: LD_VAR 0 7
35869: PUSH
35870: LD_INT 3
35872: ARRAY
35873: PPUSH
35874: CALL_OW 117
// end ;
35878: GO 35656
35880: POP
35881: POP
// end ; end else
35882: GO 36414
// begin for j in cargo do
35884: LD_ADDR_VAR 0 3
35888: PUSH
35889: LD_VAR 0 8
35893: PUSH
35894: FOR_IN
35895: IFFALSE 36412
// begin if GetTag ( j ) <> 0 then
35897: LD_VAR 0 3
35901: PPUSH
35902: CALL_OW 110
35906: PUSH
35907: LD_INT 0
35909: NONEQUAL
35910: IFFALSE 35914
// continue ;
35912: GO 35894
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35914: LD_VAR 0 3
35918: PPUSH
35919: CALL_OW 256
35923: PUSH
35924: LD_INT 1000
35926: LESS
35927: PUSH
35928: LD_VAR 0 3
35932: PPUSH
35933: LD_EXP 101
35937: PUSH
35938: LD_VAR 0 2
35942: ARRAY
35943: PPUSH
35944: CALL_OW 308
35948: NOT
35949: AND
35950: IFFALSE 35972
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35952: LD_VAR 0 3
35956: PPUSH
35957: LD_EXP 101
35961: PUSH
35962: LD_VAR 0 2
35966: ARRAY
35967: PPUSH
35968: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35972: LD_VAR 0 3
35976: PPUSH
35977: CALL_OW 256
35981: PUSH
35982: LD_INT 1000
35984: LESS
35985: PUSH
35986: LD_VAR 0 3
35990: PPUSH
35991: LD_EXP 101
35995: PUSH
35996: LD_VAR 0 2
36000: ARRAY
36001: PPUSH
36002: CALL_OW 308
36006: AND
36007: IFFALSE 36011
// continue ;
36009: GO 35894
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36011: LD_VAR 0 3
36015: PPUSH
36016: CALL_OW 262
36020: PUSH
36021: LD_INT 2
36023: EQUAL
36024: PUSH
36025: LD_VAR 0 3
36029: PPUSH
36030: CALL_OW 261
36034: PUSH
36035: LD_INT 15
36037: LESS
36038: AND
36039: IFFALSE 36043
// continue ;
36041: GO 35894
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36043: LD_VAR 0 3
36047: PPUSH
36048: CALL_OW 262
36052: PUSH
36053: LD_INT 1
36055: EQUAL
36056: PUSH
36057: LD_VAR 0 3
36061: PPUSH
36062: CALL_OW 261
36066: PUSH
36067: LD_INT 10
36069: LESS
36070: AND
36071: IFFALSE 36351
// begin if not depot then
36073: LD_VAR 0 9
36077: NOT
36078: IFFALSE 36082
// continue ;
36080: GO 35894
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36082: LD_VAR 0 3
36086: PPUSH
36087: LD_VAR 0 9
36091: PPUSH
36092: LD_VAR 0 3
36096: PPUSH
36097: CALL_OW 74
36101: PPUSH
36102: CALL_OW 296
36106: PUSH
36107: LD_INT 6
36109: LESS
36110: IFFALSE 36126
// SetFuel ( j , 100 ) else
36112: LD_VAR 0 3
36116: PPUSH
36117: LD_INT 100
36119: PPUSH
36120: CALL_OW 240
36124: GO 36351
// if GetFuel ( j ) = 0 then
36126: LD_VAR 0 3
36130: PPUSH
36131: CALL_OW 261
36135: PUSH
36136: LD_INT 0
36138: EQUAL
36139: IFFALSE 36351
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36141: LD_ADDR_EXP 96
36145: PUSH
36146: LD_EXP 96
36150: PPUSH
36151: LD_VAR 0 2
36155: PPUSH
36156: LD_EXP 96
36160: PUSH
36161: LD_VAR 0 2
36165: ARRAY
36166: PUSH
36167: LD_VAR 0 3
36171: DIFF
36172: PPUSH
36173: CALL_OW 1
36177: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
36178: LD_VAR 0 3
36182: PPUSH
36183: CALL_OW 263
36187: PUSH
36188: LD_INT 1
36190: EQUAL
36191: IFFALSE 36207
// ComExitVehicle ( IsInUnit ( j ) ) ;
36193: LD_VAR 0 3
36197: PPUSH
36198: CALL_OW 310
36202: PPUSH
36203: CALL_OW 121
// if GetControl ( j ) = control_remote then
36207: LD_VAR 0 3
36211: PPUSH
36212: CALL_OW 263
36216: PUSH
36217: LD_INT 2
36219: EQUAL
36220: IFFALSE 36231
// ComUnlink ( j ) ;
36222: LD_VAR 0 3
36226: PPUSH
36227: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
36231: LD_ADDR_VAR 0 10
36235: PUSH
36236: LD_VAR 0 2
36240: PPUSH
36241: LD_INT 3
36243: PPUSH
36244: CALL 46018 0 2
36248: ST_TO_ADDR
// if fac then
36249: LD_VAR 0 10
36253: IFFALSE 36349
// begin for k in fac do
36255: LD_ADDR_VAR 0 4
36259: PUSH
36260: LD_VAR 0 10
36264: PUSH
36265: FOR_IN
36266: IFFALSE 36347
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
36268: LD_ADDR_VAR 0 11
36272: PUSH
36273: LD_VAR 0 10
36277: PPUSH
36278: LD_VAR 0 3
36282: PPUSH
36283: CALL_OW 265
36287: PPUSH
36288: LD_VAR 0 3
36292: PPUSH
36293: CALL_OW 262
36297: PPUSH
36298: LD_VAR 0 3
36302: PPUSH
36303: CALL_OW 263
36307: PPUSH
36308: LD_VAR 0 3
36312: PPUSH
36313: CALL_OW 264
36317: PPUSH
36318: CALL 54586 0 5
36322: ST_TO_ADDR
// if components then
36323: LD_VAR 0 11
36327: IFFALSE 36345
// begin MC_InsertProduceList ( i , components ) ;
36329: LD_VAR 0 2
36333: PPUSH
36334: LD_VAR 0 11
36338: PPUSH
36339: CALL 45563 0 2
// break ;
36343: GO 36347
// end ; end ;
36345: GO 36265
36347: POP
36348: POP
// end ; continue ;
36349: GO 35894
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
36351: LD_VAR 0 3
36355: PPUSH
36356: LD_INT 1
36358: PPUSH
36359: CALL_OW 289
36363: PUSH
36364: LD_INT 100
36366: LESS
36367: PUSH
36368: LD_VAR 0 3
36372: PPUSH
36373: CALL_OW 314
36377: NOT
36378: AND
36379: IFFALSE 36408
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36381: LD_VAR 0 3
36385: PPUSH
36386: LD_VAR 0 7
36390: PUSH
36391: LD_INT 2
36393: ARRAY
36394: PPUSH
36395: LD_VAR 0 7
36399: PUSH
36400: LD_INT 3
36402: ARRAY
36403: PPUSH
36404: CALL_OW 117
// break ;
36408: GO 36412
// end ;
36410: GO 35894
36412: POP
36413: POP
// end ; end ;
36414: GO 34610
36416: POP
36417: POP
// end ;
36418: LD_VAR 0 1
36422: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
36423: LD_INT 0
36425: PPUSH
36426: PPUSH
36427: PPUSH
36428: PPUSH
// if not mc_bases then
36429: LD_EXP 77
36433: NOT
36434: IFFALSE 36438
// exit ;
36436: GO 36599
// for i = 1 to mc_bases do
36438: LD_ADDR_VAR 0 2
36442: PUSH
36443: DOUBLE
36444: LD_INT 1
36446: DEC
36447: ST_TO_ADDR
36448: LD_EXP 77
36452: PUSH
36453: FOR_TO
36454: IFFALSE 36597
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36456: LD_ADDR_VAR 0 4
36460: PUSH
36461: LD_EXP 96
36465: PUSH
36466: LD_VAR 0 2
36470: ARRAY
36471: PUSH
36472: LD_EXP 99
36476: PUSH
36477: LD_VAR 0 2
36481: ARRAY
36482: UNION
36483: PPUSH
36484: LD_INT 33
36486: PUSH
36487: LD_INT 2
36489: PUSH
36490: EMPTY
36491: LIST
36492: LIST
36493: PPUSH
36494: CALL_OW 72
36498: ST_TO_ADDR
// if tmp then
36499: LD_VAR 0 4
36503: IFFALSE 36595
// for j in tmp do
36505: LD_ADDR_VAR 0 3
36509: PUSH
36510: LD_VAR 0 4
36514: PUSH
36515: FOR_IN
36516: IFFALSE 36593
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36518: LD_VAR 0 3
36522: PPUSH
36523: CALL_OW 312
36527: NOT
36528: PUSH
36529: LD_VAR 0 3
36533: PPUSH
36534: CALL_OW 256
36538: PUSH
36539: LD_INT 250
36541: GREATEREQUAL
36542: AND
36543: IFFALSE 36556
// Connect ( j ) else
36545: LD_VAR 0 3
36549: PPUSH
36550: CALL 60057 0 1
36554: GO 36591
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36556: LD_VAR 0 3
36560: PPUSH
36561: CALL_OW 256
36565: PUSH
36566: LD_INT 250
36568: LESS
36569: PUSH
36570: LD_VAR 0 3
36574: PPUSH
36575: CALL_OW 312
36579: AND
36580: IFFALSE 36591
// ComUnlink ( j ) ;
36582: LD_VAR 0 3
36586: PPUSH
36587: CALL_OW 136
36591: GO 36515
36593: POP
36594: POP
// end ;
36595: GO 36453
36597: POP
36598: POP
// end ;
36599: LD_VAR 0 1
36603: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36604: LD_INT 0
36606: PPUSH
36607: PPUSH
36608: PPUSH
36609: PPUSH
36610: PPUSH
// if not mc_bases then
36611: LD_EXP 77
36615: NOT
36616: IFFALSE 36620
// exit ;
36618: GO 37065
// for i = 1 to mc_bases do
36620: LD_ADDR_VAR 0 2
36624: PUSH
36625: DOUBLE
36626: LD_INT 1
36628: DEC
36629: ST_TO_ADDR
36630: LD_EXP 77
36634: PUSH
36635: FOR_TO
36636: IFFALSE 37063
// begin if not mc_produce [ i ] then
36638: LD_EXP 98
36642: PUSH
36643: LD_VAR 0 2
36647: ARRAY
36648: NOT
36649: IFFALSE 36653
// continue ;
36651: GO 36635
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36653: LD_ADDR_VAR 0 5
36657: PUSH
36658: LD_EXP 77
36662: PUSH
36663: LD_VAR 0 2
36667: ARRAY
36668: PPUSH
36669: LD_INT 30
36671: PUSH
36672: LD_INT 3
36674: PUSH
36675: EMPTY
36676: LIST
36677: LIST
36678: PPUSH
36679: CALL_OW 72
36683: ST_TO_ADDR
// if not fac then
36684: LD_VAR 0 5
36688: NOT
36689: IFFALSE 36693
// continue ;
36691: GO 36635
// for j in fac do
36693: LD_ADDR_VAR 0 3
36697: PUSH
36698: LD_VAR 0 5
36702: PUSH
36703: FOR_IN
36704: IFFALSE 37059
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36706: LD_VAR 0 3
36710: PPUSH
36711: CALL_OW 461
36715: PUSH
36716: LD_INT 2
36718: NONEQUAL
36719: PUSH
36720: LD_VAR 0 3
36724: PPUSH
36725: LD_INT 15
36727: PPUSH
36728: CALL 59685 0 2
36732: PUSH
36733: LD_INT 4
36735: ARRAY
36736: OR
36737: IFFALSE 36741
// continue ;
36739: GO 36703
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36741: LD_VAR 0 3
36745: PPUSH
36746: LD_EXP 98
36750: PUSH
36751: LD_VAR 0 2
36755: ARRAY
36756: PUSH
36757: LD_INT 1
36759: ARRAY
36760: PUSH
36761: LD_INT 1
36763: ARRAY
36764: PPUSH
36765: LD_EXP 98
36769: PUSH
36770: LD_VAR 0 2
36774: ARRAY
36775: PUSH
36776: LD_INT 1
36778: ARRAY
36779: PUSH
36780: LD_INT 2
36782: ARRAY
36783: PPUSH
36784: LD_EXP 98
36788: PUSH
36789: LD_VAR 0 2
36793: ARRAY
36794: PUSH
36795: LD_INT 1
36797: ARRAY
36798: PUSH
36799: LD_INT 3
36801: ARRAY
36802: PPUSH
36803: LD_EXP 98
36807: PUSH
36808: LD_VAR 0 2
36812: ARRAY
36813: PUSH
36814: LD_INT 1
36816: ARRAY
36817: PUSH
36818: LD_INT 4
36820: ARRAY
36821: PPUSH
36822: CALL_OW 448
36826: PUSH
36827: LD_VAR 0 3
36831: PPUSH
36832: LD_EXP 98
36836: PUSH
36837: LD_VAR 0 2
36841: ARRAY
36842: PUSH
36843: LD_INT 1
36845: ARRAY
36846: PUSH
36847: LD_INT 1
36849: ARRAY
36850: PUSH
36851: LD_EXP 98
36855: PUSH
36856: LD_VAR 0 2
36860: ARRAY
36861: PUSH
36862: LD_INT 1
36864: ARRAY
36865: PUSH
36866: LD_INT 2
36868: ARRAY
36869: PUSH
36870: LD_EXP 98
36874: PUSH
36875: LD_VAR 0 2
36879: ARRAY
36880: PUSH
36881: LD_INT 1
36883: ARRAY
36884: PUSH
36885: LD_INT 3
36887: ARRAY
36888: PUSH
36889: LD_EXP 98
36893: PUSH
36894: LD_VAR 0 2
36898: ARRAY
36899: PUSH
36900: LD_INT 1
36902: ARRAY
36903: PUSH
36904: LD_INT 4
36906: ARRAY
36907: PUSH
36908: EMPTY
36909: LIST
36910: LIST
36911: LIST
36912: LIST
36913: PPUSH
36914: CALL 63452 0 2
36918: AND
36919: IFFALSE 37057
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36921: LD_VAR 0 3
36925: PPUSH
36926: LD_EXP 98
36930: PUSH
36931: LD_VAR 0 2
36935: ARRAY
36936: PUSH
36937: LD_INT 1
36939: ARRAY
36940: PUSH
36941: LD_INT 1
36943: ARRAY
36944: PPUSH
36945: LD_EXP 98
36949: PUSH
36950: LD_VAR 0 2
36954: ARRAY
36955: PUSH
36956: LD_INT 1
36958: ARRAY
36959: PUSH
36960: LD_INT 2
36962: ARRAY
36963: PPUSH
36964: LD_EXP 98
36968: PUSH
36969: LD_VAR 0 2
36973: ARRAY
36974: PUSH
36975: LD_INT 1
36977: ARRAY
36978: PUSH
36979: LD_INT 3
36981: ARRAY
36982: PPUSH
36983: LD_EXP 98
36987: PUSH
36988: LD_VAR 0 2
36992: ARRAY
36993: PUSH
36994: LD_INT 1
36996: ARRAY
36997: PUSH
36998: LD_INT 4
37000: ARRAY
37001: PPUSH
37002: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37006: LD_ADDR_VAR 0 4
37010: PUSH
37011: LD_EXP 98
37015: PUSH
37016: LD_VAR 0 2
37020: ARRAY
37021: PPUSH
37022: LD_INT 1
37024: PPUSH
37025: CALL_OW 3
37029: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37030: LD_ADDR_EXP 98
37034: PUSH
37035: LD_EXP 98
37039: PPUSH
37040: LD_VAR 0 2
37044: PPUSH
37045: LD_VAR 0 4
37049: PPUSH
37050: CALL_OW 1
37054: ST_TO_ADDR
// break ;
37055: GO 37059
// end ; end ;
37057: GO 36703
37059: POP
37060: POP
// end ;
37061: GO 36635
37063: POP
37064: POP
// end ;
37065: LD_VAR 0 1
37069: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37070: LD_INT 0
37072: PPUSH
37073: PPUSH
37074: PPUSH
// if not mc_bases then
37075: LD_EXP 77
37079: NOT
37080: IFFALSE 37084
// exit ;
37082: GO 37173
// for i = 1 to mc_bases do
37084: LD_ADDR_VAR 0 2
37088: PUSH
37089: DOUBLE
37090: LD_INT 1
37092: DEC
37093: ST_TO_ADDR
37094: LD_EXP 77
37098: PUSH
37099: FOR_TO
37100: IFFALSE 37171
// begin if mc_attack [ i ] then
37102: LD_EXP 97
37106: PUSH
37107: LD_VAR 0 2
37111: ARRAY
37112: IFFALSE 37169
// begin tmp := mc_attack [ i ] [ 1 ] ;
37114: LD_ADDR_VAR 0 3
37118: PUSH
37119: LD_EXP 97
37123: PUSH
37124: LD_VAR 0 2
37128: ARRAY
37129: PUSH
37130: LD_INT 1
37132: ARRAY
37133: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37134: LD_ADDR_EXP 97
37138: PUSH
37139: LD_EXP 97
37143: PPUSH
37144: LD_VAR 0 2
37148: PPUSH
37149: EMPTY
37150: PPUSH
37151: CALL_OW 1
37155: ST_TO_ADDR
// Attack ( tmp ) ;
37156: LD_VAR 0 3
37160: PPUSH
37161: CALL 113291 0 1
// exit ;
37165: POP
37166: POP
37167: GO 37173
// end ; end ;
37169: GO 37099
37171: POP
37172: POP
// end ;
37173: LD_VAR 0 1
37177: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
37178: LD_INT 0
37180: PPUSH
37181: PPUSH
37182: PPUSH
37183: PPUSH
37184: PPUSH
37185: PPUSH
37186: PPUSH
// if not mc_bases then
37187: LD_EXP 77
37191: NOT
37192: IFFALSE 37196
// exit ;
37194: GO 38053
// for i = 1 to mc_bases do
37196: LD_ADDR_VAR 0 2
37200: PUSH
37201: DOUBLE
37202: LD_INT 1
37204: DEC
37205: ST_TO_ADDR
37206: LD_EXP 77
37210: PUSH
37211: FOR_TO
37212: IFFALSE 38051
// begin if not mc_bases [ i ] then
37214: LD_EXP 77
37218: PUSH
37219: LD_VAR 0 2
37223: ARRAY
37224: NOT
37225: IFFALSE 37229
// continue ;
37227: GO 37211
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
37229: LD_ADDR_VAR 0 7
37233: PUSH
37234: LD_EXP 77
37238: PUSH
37239: LD_VAR 0 2
37243: ARRAY
37244: PUSH
37245: LD_INT 1
37247: ARRAY
37248: PPUSH
37249: CALL 53737 0 1
37253: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
37254: LD_ADDR_EXP 100
37258: PUSH
37259: LD_EXP 100
37263: PPUSH
37264: LD_VAR 0 2
37268: PPUSH
37269: LD_EXP 77
37273: PUSH
37274: LD_VAR 0 2
37278: ARRAY
37279: PUSH
37280: LD_INT 1
37282: ARRAY
37283: PPUSH
37284: CALL_OW 255
37288: PPUSH
37289: LD_EXP 102
37293: PUSH
37294: LD_VAR 0 2
37298: ARRAY
37299: PPUSH
37300: CALL 53702 0 2
37304: PPUSH
37305: CALL_OW 1
37309: ST_TO_ADDR
// if not mc_scan [ i ] then
37310: LD_EXP 100
37314: PUSH
37315: LD_VAR 0 2
37319: ARRAY
37320: NOT
37321: IFFALSE 37499
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
37323: LD_ADDR_EXP 120
37327: PUSH
37328: LD_EXP 120
37332: PPUSH
37333: LD_VAR 0 2
37337: PPUSH
37338: LD_INT 0
37340: PPUSH
37341: CALL_OW 1
37345: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37346: LD_ADDR_VAR 0 4
37350: PUSH
37351: LD_EXP 77
37355: PUSH
37356: LD_VAR 0 2
37360: ARRAY
37361: PPUSH
37362: LD_INT 2
37364: PUSH
37365: LD_INT 25
37367: PUSH
37368: LD_INT 5
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: LD_INT 25
37377: PUSH
37378: LD_INT 8
37380: PUSH
37381: EMPTY
37382: LIST
37383: LIST
37384: PUSH
37385: LD_INT 25
37387: PUSH
37388: LD_INT 9
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: PPUSH
37401: CALL_OW 72
37405: ST_TO_ADDR
// if not tmp then
37406: LD_VAR 0 4
37410: NOT
37411: IFFALSE 37415
// continue ;
37413: GO 37211
// for j in tmp do
37415: LD_ADDR_VAR 0 3
37419: PUSH
37420: LD_VAR 0 4
37424: PUSH
37425: FOR_IN
37426: IFFALSE 37497
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
37428: LD_VAR 0 3
37432: PPUSH
37433: CALL_OW 310
37437: PPUSH
37438: CALL_OW 266
37442: PUSH
37443: LD_INT 5
37445: EQUAL
37446: PUSH
37447: LD_VAR 0 3
37451: PPUSH
37452: CALL_OW 257
37456: PUSH
37457: LD_INT 1
37459: EQUAL
37460: AND
37461: PUSH
37462: LD_VAR 0 3
37466: PPUSH
37467: CALL_OW 459
37471: NOT
37472: AND
37473: PUSH
37474: LD_VAR 0 7
37478: AND
37479: IFFALSE 37495
// ComChangeProfession ( j , class ) ;
37481: LD_VAR 0 3
37485: PPUSH
37486: LD_VAR 0 7
37490: PPUSH
37491: CALL_OW 123
37495: GO 37425
37497: POP
37498: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37499: LD_EXP 100
37503: PUSH
37504: LD_VAR 0 2
37508: ARRAY
37509: PUSH
37510: LD_EXP 120
37514: PUSH
37515: LD_VAR 0 2
37519: ARRAY
37520: NOT
37521: AND
37522: PUSH
37523: LD_EXP 99
37527: PUSH
37528: LD_VAR 0 2
37532: ARRAY
37533: NOT
37534: AND
37535: PUSH
37536: LD_EXP 77
37540: PUSH
37541: LD_VAR 0 2
37545: ARRAY
37546: PPUSH
37547: LD_INT 50
37549: PUSH
37550: EMPTY
37551: LIST
37552: PUSH
37553: LD_INT 2
37555: PUSH
37556: LD_INT 30
37558: PUSH
37559: LD_INT 32
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 30
37568: PUSH
37569: LD_INT 33
37571: PUSH
37572: EMPTY
37573: LIST
37574: LIST
37575: PUSH
37576: LD_INT 30
37578: PUSH
37579: LD_INT 4
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 30
37588: PUSH
37589: LD_INT 5
37591: PUSH
37592: EMPTY
37593: LIST
37594: LIST
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: LIST
37600: LIST
37601: LIST
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PPUSH
37607: CALL_OW 72
37611: PUSH
37612: LD_INT 4
37614: LESS
37615: PUSH
37616: LD_EXP 77
37620: PUSH
37621: LD_VAR 0 2
37625: ARRAY
37626: PPUSH
37627: LD_INT 3
37629: PUSH
37630: LD_INT 24
37632: PUSH
37633: LD_INT 1000
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 2
37646: PUSH
37647: LD_INT 30
37649: PUSH
37650: LD_INT 0
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: PUSH
37657: LD_INT 30
37659: PUSH
37660: LD_INT 1
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: LIST
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PPUSH
37676: CALL_OW 72
37680: OR
37681: AND
37682: IFFALSE 37933
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37684: LD_ADDR_EXP 120
37688: PUSH
37689: LD_EXP 120
37693: PPUSH
37694: LD_VAR 0 2
37698: PPUSH
37699: LD_INT 1
37701: PPUSH
37702: CALL_OW 1
37706: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37707: LD_ADDR_VAR 0 4
37711: PUSH
37712: LD_EXP 77
37716: PUSH
37717: LD_VAR 0 2
37721: ARRAY
37722: PPUSH
37723: LD_INT 2
37725: PUSH
37726: LD_INT 25
37728: PUSH
37729: LD_INT 1
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 25
37738: PUSH
37739: LD_INT 5
37741: PUSH
37742: EMPTY
37743: LIST
37744: LIST
37745: PUSH
37746: LD_INT 25
37748: PUSH
37749: LD_INT 8
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: PUSH
37756: LD_INT 25
37758: PUSH
37759: LD_INT 9
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: LIST
37770: LIST
37771: LIST
37772: PPUSH
37773: CALL_OW 72
37777: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37778: LD_ADDR_VAR 0 4
37782: PUSH
37783: LD_VAR 0 4
37787: PUSH
37788: LD_VAR 0 4
37792: PPUSH
37793: LD_INT 18
37795: PPUSH
37796: CALL 86974 0 2
37800: DIFF
37801: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37802: LD_VAR 0 4
37806: NOT
37807: PUSH
37808: LD_EXP 77
37812: PUSH
37813: LD_VAR 0 2
37817: ARRAY
37818: PPUSH
37819: LD_INT 2
37821: PUSH
37822: LD_INT 30
37824: PUSH
37825: LD_INT 4
37827: PUSH
37828: EMPTY
37829: LIST
37830: LIST
37831: PUSH
37832: LD_INT 30
37834: PUSH
37835: LD_INT 5
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: LIST
37846: PPUSH
37847: CALL_OW 72
37851: NOT
37852: AND
37853: IFFALSE 37915
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37855: LD_ADDR_VAR 0 4
37859: PUSH
37860: LD_EXP 77
37864: PUSH
37865: LD_VAR 0 2
37869: ARRAY
37870: PPUSH
37871: LD_INT 2
37873: PUSH
37874: LD_INT 25
37876: PUSH
37877: LD_INT 2
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 25
37886: PUSH
37887: LD_INT 3
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 25
37896: PUSH
37897: LD_INT 4
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: EMPTY
37905: LIST
37906: LIST
37907: LIST
37908: LIST
37909: PPUSH
37910: CALL_OW 72
37914: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
37915: LD_VAR 0 2
37919: PPUSH
37920: LD_VAR 0 4
37924: PPUSH
37925: CALL 118000 0 2
// exit ;
37929: POP
37930: POP
37931: GO 38053
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
37933: LD_EXP 100
37937: PUSH
37938: LD_VAR 0 2
37942: ARRAY
37943: PUSH
37944: LD_EXP 120
37948: PUSH
37949: LD_VAR 0 2
37953: ARRAY
37954: NOT
37955: AND
37956: PUSH
37957: LD_EXP 99
37961: PUSH
37962: LD_VAR 0 2
37966: ARRAY
37967: AND
37968: IFFALSE 38049
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37970: LD_ADDR_EXP 120
37974: PUSH
37975: LD_EXP 120
37979: PPUSH
37980: LD_VAR 0 2
37984: PPUSH
37985: LD_INT 1
37987: PPUSH
37988: CALL_OW 1
37992: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
37993: LD_ADDR_VAR 0 4
37997: PUSH
37998: LD_EXP 99
38002: PUSH
38003: LD_VAR 0 2
38007: ARRAY
38008: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38009: LD_ADDR_EXP 99
38013: PUSH
38014: LD_EXP 99
38018: PPUSH
38019: LD_VAR 0 2
38023: PPUSH
38024: EMPTY
38025: PPUSH
38026: CALL_OW 1
38030: ST_TO_ADDR
// Defend ( i , tmp ) ;
38031: LD_VAR 0 2
38035: PPUSH
38036: LD_VAR 0 4
38040: PPUSH
38041: CALL 118596 0 2
// exit ;
38045: POP
38046: POP
38047: GO 38053
// end ; end ;
38049: GO 37211
38051: POP
38052: POP
// end ;
38053: LD_VAR 0 1
38057: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38058: LD_INT 0
38060: PPUSH
38061: PPUSH
38062: PPUSH
38063: PPUSH
38064: PPUSH
38065: PPUSH
38066: PPUSH
38067: PPUSH
38068: PPUSH
38069: PPUSH
38070: PPUSH
// if not mc_bases then
38071: LD_EXP 77
38075: NOT
38076: IFFALSE 38080
// exit ;
38078: GO 39167
// for i = 1 to mc_bases do
38080: LD_ADDR_VAR 0 2
38084: PUSH
38085: DOUBLE
38086: LD_INT 1
38088: DEC
38089: ST_TO_ADDR
38090: LD_EXP 77
38094: PUSH
38095: FOR_TO
38096: IFFALSE 39165
// begin tmp := mc_lab [ i ] ;
38098: LD_ADDR_VAR 0 6
38102: PUSH
38103: LD_EXP 110
38107: PUSH
38108: LD_VAR 0 2
38112: ARRAY
38113: ST_TO_ADDR
// if not tmp then
38114: LD_VAR 0 6
38118: NOT
38119: IFFALSE 38123
// continue ;
38121: GO 38095
// idle_lab := 0 ;
38123: LD_ADDR_VAR 0 11
38127: PUSH
38128: LD_INT 0
38130: ST_TO_ADDR
// for j in tmp do
38131: LD_ADDR_VAR 0 3
38135: PUSH
38136: LD_VAR 0 6
38140: PUSH
38141: FOR_IN
38142: IFFALSE 39161
// begin researching := false ;
38144: LD_ADDR_VAR 0 10
38148: PUSH
38149: LD_INT 0
38151: ST_TO_ADDR
// side := GetSide ( j ) ;
38152: LD_ADDR_VAR 0 4
38156: PUSH
38157: LD_VAR 0 3
38161: PPUSH
38162: CALL_OW 255
38166: ST_TO_ADDR
// if not mc_tech [ side ] then
38167: LD_EXP 104
38171: PUSH
38172: LD_VAR 0 4
38176: ARRAY
38177: NOT
38178: IFFALSE 38182
// continue ;
38180: GO 38141
// if BuildingStatus ( j ) = bs_idle then
38182: LD_VAR 0 3
38186: PPUSH
38187: CALL_OW 461
38191: PUSH
38192: LD_INT 2
38194: EQUAL
38195: IFFALSE 38383
// begin if idle_lab and UnitsInside ( j ) < 6 then
38197: LD_VAR 0 11
38201: PUSH
38202: LD_VAR 0 3
38206: PPUSH
38207: CALL_OW 313
38211: PUSH
38212: LD_INT 6
38214: LESS
38215: AND
38216: IFFALSE 38287
// begin tmp2 := UnitsInside ( idle_lab ) ;
38218: LD_ADDR_VAR 0 9
38222: PUSH
38223: LD_VAR 0 11
38227: PPUSH
38228: CALL_OW 313
38232: ST_TO_ADDR
// if tmp2 then
38233: LD_VAR 0 9
38237: IFFALSE 38279
// for x in tmp2 do
38239: LD_ADDR_VAR 0 7
38243: PUSH
38244: LD_VAR 0 9
38248: PUSH
38249: FOR_IN
38250: IFFALSE 38277
// begin ComExitBuilding ( x ) ;
38252: LD_VAR 0 7
38256: PPUSH
38257: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38261: LD_VAR 0 7
38265: PPUSH
38266: LD_VAR 0 3
38270: PPUSH
38271: CALL_OW 180
// end ;
38275: GO 38249
38277: POP
38278: POP
// idle_lab := 0 ;
38279: LD_ADDR_VAR 0 11
38283: PUSH
38284: LD_INT 0
38286: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
38287: LD_ADDR_VAR 0 5
38291: PUSH
38292: LD_EXP 104
38296: PUSH
38297: LD_VAR 0 4
38301: ARRAY
38302: PUSH
38303: FOR_IN
38304: IFFALSE 38364
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
38306: LD_VAR 0 3
38310: PPUSH
38311: LD_VAR 0 5
38315: PPUSH
38316: CALL_OW 430
38320: PUSH
38321: LD_VAR 0 4
38325: PPUSH
38326: LD_VAR 0 5
38330: PPUSH
38331: CALL 52807 0 2
38335: AND
38336: IFFALSE 38362
// begin researching := true ;
38338: LD_ADDR_VAR 0 10
38342: PUSH
38343: LD_INT 1
38345: ST_TO_ADDR
// ComResearch ( j , t ) ;
38346: LD_VAR 0 3
38350: PPUSH
38351: LD_VAR 0 5
38355: PPUSH
38356: CALL_OW 124
// break ;
38360: GO 38364
// end ;
38362: GO 38303
38364: POP
38365: POP
// if not researching then
38366: LD_VAR 0 10
38370: NOT
38371: IFFALSE 38383
// idle_lab := j ;
38373: LD_ADDR_VAR 0 11
38377: PUSH
38378: LD_VAR 0 3
38382: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
38383: LD_VAR 0 3
38387: PPUSH
38388: CALL_OW 461
38392: PUSH
38393: LD_INT 10
38395: EQUAL
38396: IFFALSE 38984
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
38398: LD_EXP 106
38402: PUSH
38403: LD_VAR 0 2
38407: ARRAY
38408: NOT
38409: PUSH
38410: LD_EXP 107
38414: PUSH
38415: LD_VAR 0 2
38419: ARRAY
38420: NOT
38421: AND
38422: PUSH
38423: LD_EXP 104
38427: PUSH
38428: LD_VAR 0 4
38432: ARRAY
38433: PUSH
38434: LD_INT 1
38436: GREATER
38437: AND
38438: IFFALSE 38569
// begin ComCancel ( j ) ;
38440: LD_VAR 0 3
38444: PPUSH
38445: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
38449: LD_ADDR_EXP 104
38453: PUSH
38454: LD_EXP 104
38458: PPUSH
38459: LD_VAR 0 4
38463: PPUSH
38464: LD_EXP 104
38468: PUSH
38469: LD_VAR 0 4
38473: ARRAY
38474: PPUSH
38475: LD_EXP 104
38479: PUSH
38480: LD_VAR 0 4
38484: ARRAY
38485: PUSH
38486: LD_INT 1
38488: MINUS
38489: PPUSH
38490: LD_EXP 104
38494: PUSH
38495: LD_VAR 0 4
38499: ARRAY
38500: PPUSH
38501: LD_INT 0
38503: PPUSH
38504: CALL 56506 0 4
38508: PPUSH
38509: CALL_OW 1
38513: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38514: LD_ADDR_EXP 104
38518: PUSH
38519: LD_EXP 104
38523: PPUSH
38524: LD_VAR 0 4
38528: PPUSH
38529: LD_EXP 104
38533: PUSH
38534: LD_VAR 0 4
38538: ARRAY
38539: PPUSH
38540: LD_EXP 104
38544: PUSH
38545: LD_VAR 0 4
38549: ARRAY
38550: PPUSH
38551: LD_INT 1
38553: PPUSH
38554: LD_INT 0
38556: PPUSH
38557: CALL 56506 0 4
38561: PPUSH
38562: CALL_OW 1
38566: ST_TO_ADDR
// continue ;
38567: GO 38141
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38569: LD_EXP 106
38573: PUSH
38574: LD_VAR 0 2
38578: ARRAY
38579: PUSH
38580: LD_EXP 107
38584: PUSH
38585: LD_VAR 0 2
38589: ARRAY
38590: NOT
38591: AND
38592: IFFALSE 38719
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38594: LD_ADDR_EXP 107
38598: PUSH
38599: LD_EXP 107
38603: PPUSH
38604: LD_VAR 0 2
38608: PUSH
38609: LD_EXP 107
38613: PUSH
38614: LD_VAR 0 2
38618: ARRAY
38619: PUSH
38620: LD_INT 1
38622: PLUS
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PPUSH
38628: LD_EXP 106
38632: PUSH
38633: LD_VAR 0 2
38637: ARRAY
38638: PUSH
38639: LD_INT 1
38641: ARRAY
38642: PPUSH
38643: CALL 57088 0 3
38647: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38648: LD_EXP 106
38652: PUSH
38653: LD_VAR 0 2
38657: ARRAY
38658: PUSH
38659: LD_INT 1
38661: ARRAY
38662: PPUSH
38663: LD_INT 112
38665: PPUSH
38666: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38670: LD_ADDR_VAR 0 9
38674: PUSH
38675: LD_EXP 106
38679: PUSH
38680: LD_VAR 0 2
38684: ARRAY
38685: PPUSH
38686: LD_INT 1
38688: PPUSH
38689: CALL_OW 3
38693: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38694: LD_ADDR_EXP 106
38698: PUSH
38699: LD_EXP 106
38703: PPUSH
38704: LD_VAR 0 2
38708: PPUSH
38709: LD_VAR 0 9
38713: PPUSH
38714: CALL_OW 1
38718: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38719: LD_EXP 106
38723: PUSH
38724: LD_VAR 0 2
38728: ARRAY
38729: PUSH
38730: LD_EXP 107
38734: PUSH
38735: LD_VAR 0 2
38739: ARRAY
38740: AND
38741: PUSH
38742: LD_EXP 107
38746: PUSH
38747: LD_VAR 0 2
38751: ARRAY
38752: PUSH
38753: LD_INT 1
38755: ARRAY
38756: PPUSH
38757: CALL_OW 310
38761: NOT
38762: AND
38763: PUSH
38764: LD_VAR 0 3
38768: PPUSH
38769: CALL_OW 313
38773: PUSH
38774: LD_INT 6
38776: EQUAL
38777: AND
38778: IFFALSE 38834
// begin tmp2 := UnitsInside ( j ) ;
38780: LD_ADDR_VAR 0 9
38784: PUSH
38785: LD_VAR 0 3
38789: PPUSH
38790: CALL_OW 313
38794: ST_TO_ADDR
// if tmp2 = 6 then
38795: LD_VAR 0 9
38799: PUSH
38800: LD_INT 6
38802: EQUAL
38803: IFFALSE 38834
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38805: LD_VAR 0 9
38809: PUSH
38810: LD_INT 1
38812: ARRAY
38813: PPUSH
38814: LD_INT 112
38816: PPUSH
38817: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38821: LD_VAR 0 9
38825: PUSH
38826: LD_INT 1
38828: ARRAY
38829: PPUSH
38830: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38834: LD_EXP 107
38838: PUSH
38839: LD_VAR 0 2
38843: ARRAY
38844: PUSH
38845: LD_EXP 107
38849: PUSH
38850: LD_VAR 0 2
38854: ARRAY
38855: PUSH
38856: LD_INT 1
38858: ARRAY
38859: PPUSH
38860: CALL_OW 314
38864: NOT
38865: AND
38866: PUSH
38867: LD_EXP 107
38871: PUSH
38872: LD_VAR 0 2
38876: ARRAY
38877: PUSH
38878: LD_INT 1
38880: ARRAY
38881: PPUSH
38882: CALL_OW 310
38886: NOT
38887: AND
38888: IFFALSE 38914
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38890: LD_EXP 107
38894: PUSH
38895: LD_VAR 0 2
38899: ARRAY
38900: PUSH
38901: LD_INT 1
38903: ARRAY
38904: PPUSH
38905: LD_VAR 0 3
38909: PPUSH
38910: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38914: LD_EXP 107
38918: PUSH
38919: LD_VAR 0 2
38923: ARRAY
38924: PUSH
38925: LD_INT 1
38927: ARRAY
38928: PPUSH
38929: CALL_OW 310
38933: PUSH
38934: LD_EXP 107
38938: PUSH
38939: LD_VAR 0 2
38943: ARRAY
38944: PUSH
38945: LD_INT 1
38947: ARRAY
38948: PPUSH
38949: CALL_OW 310
38953: PPUSH
38954: CALL_OW 461
38958: PUSH
38959: LD_INT 3
38961: NONEQUAL
38962: AND
38963: IFFALSE 38984
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
38965: LD_EXP 107
38969: PUSH
38970: LD_VAR 0 2
38974: ARRAY
38975: PUSH
38976: LD_INT 1
38978: ARRAY
38979: PPUSH
38980: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
38984: LD_VAR 0 3
38988: PPUSH
38989: CALL_OW 461
38993: PUSH
38994: LD_INT 6
38996: EQUAL
38997: PUSH
38998: LD_VAR 0 6
39002: PUSH
39003: LD_INT 1
39005: GREATER
39006: AND
39007: IFFALSE 39159
// begin sci := [ ] ;
39009: LD_ADDR_VAR 0 8
39013: PUSH
39014: EMPTY
39015: ST_TO_ADDR
// for x in ( tmp diff j ) do
39016: LD_ADDR_VAR 0 7
39020: PUSH
39021: LD_VAR 0 6
39025: PUSH
39026: LD_VAR 0 3
39030: DIFF
39031: PUSH
39032: FOR_IN
39033: IFFALSE 39085
// begin if sci = 6 then
39035: LD_VAR 0 8
39039: PUSH
39040: LD_INT 6
39042: EQUAL
39043: IFFALSE 39047
// break ;
39045: GO 39085
// if BuildingStatus ( x ) = bs_idle then
39047: LD_VAR 0 7
39051: PPUSH
39052: CALL_OW 461
39056: PUSH
39057: LD_INT 2
39059: EQUAL
39060: IFFALSE 39083
// sci := sci ^ UnitsInside ( x ) ;
39062: LD_ADDR_VAR 0 8
39066: PUSH
39067: LD_VAR 0 8
39071: PUSH
39072: LD_VAR 0 7
39076: PPUSH
39077: CALL_OW 313
39081: ADD
39082: ST_TO_ADDR
// end ;
39083: GO 39032
39085: POP
39086: POP
// if not sci then
39087: LD_VAR 0 8
39091: NOT
39092: IFFALSE 39096
// continue ;
39094: GO 38141
// for x in sci do
39096: LD_ADDR_VAR 0 7
39100: PUSH
39101: LD_VAR 0 8
39105: PUSH
39106: FOR_IN
39107: IFFALSE 39157
// if IsInUnit ( x ) and not HasTask ( x ) then
39109: LD_VAR 0 7
39113: PPUSH
39114: CALL_OW 310
39118: PUSH
39119: LD_VAR 0 7
39123: PPUSH
39124: CALL_OW 314
39128: NOT
39129: AND
39130: IFFALSE 39155
// begin ComExitBuilding ( x ) ;
39132: LD_VAR 0 7
39136: PPUSH
39137: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39141: LD_VAR 0 7
39145: PPUSH
39146: LD_VAR 0 3
39150: PPUSH
39151: CALL_OW 180
// end ;
39155: GO 39106
39157: POP
39158: POP
// end ; end ;
39159: GO 38141
39161: POP
39162: POP
// end ;
39163: GO 38095
39165: POP
39166: POP
// end ;
39167: LD_VAR 0 1
39171: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
39172: LD_INT 0
39174: PPUSH
39175: PPUSH
// if not mc_bases then
39176: LD_EXP 77
39180: NOT
39181: IFFALSE 39185
// exit ;
39183: GO 39266
// for i = 1 to mc_bases do
39185: LD_ADDR_VAR 0 2
39189: PUSH
39190: DOUBLE
39191: LD_INT 1
39193: DEC
39194: ST_TO_ADDR
39195: LD_EXP 77
39199: PUSH
39200: FOR_TO
39201: IFFALSE 39264
// if mc_mines [ i ] and mc_miners [ i ] then
39203: LD_EXP 90
39207: PUSH
39208: LD_VAR 0 2
39212: ARRAY
39213: PUSH
39214: LD_EXP 91
39218: PUSH
39219: LD_VAR 0 2
39223: ARRAY
39224: AND
39225: IFFALSE 39262
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
39227: LD_EXP 91
39231: PUSH
39232: LD_VAR 0 2
39236: ARRAY
39237: PUSH
39238: LD_INT 1
39240: ARRAY
39241: PPUSH
39242: CALL_OW 255
39246: PPUSH
39247: LD_EXP 90
39251: PUSH
39252: LD_VAR 0 2
39256: ARRAY
39257: PPUSH
39258: CALL 53890 0 2
39262: GO 39200
39264: POP
39265: POP
// end ;
39266: LD_VAR 0 1
39270: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
39271: LD_INT 0
39273: PPUSH
39274: PPUSH
39275: PPUSH
39276: PPUSH
39277: PPUSH
39278: PPUSH
39279: PPUSH
39280: PPUSH
// if not mc_bases or not mc_parking then
39281: LD_EXP 77
39285: NOT
39286: PUSH
39287: LD_EXP 101
39291: NOT
39292: OR
39293: IFFALSE 39297
// exit ;
39295: GO 40035
// for i = 1 to mc_bases do
39297: LD_ADDR_VAR 0 2
39301: PUSH
39302: DOUBLE
39303: LD_INT 1
39305: DEC
39306: ST_TO_ADDR
39307: LD_EXP 77
39311: PUSH
39312: FOR_TO
39313: IFFALSE 40033
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
39315: LD_EXP 77
39319: PUSH
39320: LD_VAR 0 2
39324: ARRAY
39325: NOT
39326: PUSH
39327: LD_EXP 101
39331: PUSH
39332: LD_VAR 0 2
39336: ARRAY
39337: NOT
39338: OR
39339: IFFALSE 39343
// continue ;
39341: GO 39312
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
39343: LD_ADDR_VAR 0 5
39347: PUSH
39348: LD_EXP 77
39352: PUSH
39353: LD_VAR 0 2
39357: ARRAY
39358: PUSH
39359: LD_INT 1
39361: ARRAY
39362: PPUSH
39363: CALL_OW 255
39367: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39368: LD_ADDR_VAR 0 6
39372: PUSH
39373: LD_EXP 77
39377: PUSH
39378: LD_VAR 0 2
39382: ARRAY
39383: PPUSH
39384: LD_INT 30
39386: PUSH
39387: LD_INT 3
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PPUSH
39394: CALL_OW 72
39398: ST_TO_ADDR
// if not fac then
39399: LD_VAR 0 6
39403: NOT
39404: IFFALSE 39455
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39406: LD_ADDR_VAR 0 6
39410: PUSH
39411: LD_EXP 77
39415: PUSH
39416: LD_VAR 0 2
39420: ARRAY
39421: PPUSH
39422: LD_INT 2
39424: PUSH
39425: LD_INT 30
39427: PUSH
39428: LD_INT 0
39430: PUSH
39431: EMPTY
39432: LIST
39433: LIST
39434: PUSH
39435: LD_INT 30
39437: PUSH
39438: LD_INT 1
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: LIST
39449: PPUSH
39450: CALL_OW 72
39454: ST_TO_ADDR
// if not fac then
39455: LD_VAR 0 6
39459: NOT
39460: IFFALSE 39464
// continue ;
39462: GO 39312
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39464: LD_ADDR_VAR 0 7
39468: PUSH
39469: LD_EXP 101
39473: PUSH
39474: LD_VAR 0 2
39478: ARRAY
39479: PPUSH
39480: LD_INT 22
39482: PUSH
39483: LD_VAR 0 5
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 21
39494: PUSH
39495: LD_INT 2
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 3
39504: PUSH
39505: LD_INT 60
39507: PUSH
39508: EMPTY
39509: LIST
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 3
39517: PUSH
39518: LD_INT 24
39520: PUSH
39521: LD_INT 1000
39523: PUSH
39524: EMPTY
39525: LIST
39526: LIST
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: PPUSH
39538: CALL_OW 70
39542: ST_TO_ADDR
// for j in fac do
39543: LD_ADDR_VAR 0 3
39547: PUSH
39548: LD_VAR 0 6
39552: PUSH
39553: FOR_IN
39554: IFFALSE 39649
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39556: LD_ADDR_VAR 0 7
39560: PUSH
39561: LD_VAR 0 7
39565: PUSH
39566: LD_INT 22
39568: PUSH
39569: LD_VAR 0 5
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PUSH
39578: LD_INT 91
39580: PUSH
39581: LD_VAR 0 3
39585: PUSH
39586: LD_INT 15
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 21
39596: PUSH
39597: LD_INT 2
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 3
39606: PUSH
39607: LD_INT 60
39609: PUSH
39610: EMPTY
39611: LIST
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 3
39619: PUSH
39620: LD_INT 24
39622: PUSH
39623: LD_INT 1000
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: LIST
39638: LIST
39639: LIST
39640: PPUSH
39641: CALL_OW 69
39645: UNION
39646: ST_TO_ADDR
39647: GO 39553
39649: POP
39650: POP
// if not vehs then
39651: LD_VAR 0 7
39655: NOT
39656: IFFALSE 39682
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39658: LD_ADDR_EXP 89
39662: PUSH
39663: LD_EXP 89
39667: PPUSH
39668: LD_VAR 0 2
39672: PPUSH
39673: EMPTY
39674: PPUSH
39675: CALL_OW 1
39679: ST_TO_ADDR
// continue ;
39680: GO 39312
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39682: LD_ADDR_VAR 0 8
39686: PUSH
39687: LD_EXP 77
39691: PUSH
39692: LD_VAR 0 2
39696: ARRAY
39697: PPUSH
39698: LD_INT 30
39700: PUSH
39701: LD_INT 3
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PPUSH
39708: CALL_OW 72
39712: ST_TO_ADDR
// if tmp then
39713: LD_VAR 0 8
39717: IFFALSE 39820
// begin for j in tmp do
39719: LD_ADDR_VAR 0 3
39723: PUSH
39724: LD_VAR 0 8
39728: PUSH
39729: FOR_IN
39730: IFFALSE 39818
// for k in UnitsInside ( j ) do
39732: LD_ADDR_VAR 0 4
39736: PUSH
39737: LD_VAR 0 3
39741: PPUSH
39742: CALL_OW 313
39746: PUSH
39747: FOR_IN
39748: IFFALSE 39814
// if k then
39750: LD_VAR 0 4
39754: IFFALSE 39812
// if not k in mc_repair_vehicle [ i ] then
39756: LD_VAR 0 4
39760: PUSH
39761: LD_EXP 89
39765: PUSH
39766: LD_VAR 0 2
39770: ARRAY
39771: IN
39772: NOT
39773: IFFALSE 39812
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39775: LD_ADDR_EXP 89
39779: PUSH
39780: LD_EXP 89
39784: PPUSH
39785: LD_VAR 0 2
39789: PPUSH
39790: LD_EXP 89
39794: PUSH
39795: LD_VAR 0 2
39799: ARRAY
39800: PUSH
39801: LD_VAR 0 4
39805: UNION
39806: PPUSH
39807: CALL_OW 1
39811: ST_TO_ADDR
39812: GO 39747
39814: POP
39815: POP
39816: GO 39729
39818: POP
39819: POP
// end ; if not mc_repair_vehicle [ i ] then
39820: LD_EXP 89
39824: PUSH
39825: LD_VAR 0 2
39829: ARRAY
39830: NOT
39831: IFFALSE 39835
// continue ;
39833: GO 39312
// for j in mc_repair_vehicle [ i ] do
39835: LD_ADDR_VAR 0 3
39839: PUSH
39840: LD_EXP 89
39844: PUSH
39845: LD_VAR 0 2
39849: ARRAY
39850: PUSH
39851: FOR_IN
39852: IFFALSE 40029
// begin if GetClass ( j ) <> 3 then
39854: LD_VAR 0 3
39858: PPUSH
39859: CALL_OW 257
39863: PUSH
39864: LD_INT 3
39866: NONEQUAL
39867: IFFALSE 39908
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39869: LD_ADDR_EXP 89
39873: PUSH
39874: LD_EXP 89
39878: PPUSH
39879: LD_VAR 0 2
39883: PPUSH
39884: LD_EXP 89
39888: PUSH
39889: LD_VAR 0 2
39893: ARRAY
39894: PUSH
39895: LD_VAR 0 3
39899: DIFF
39900: PPUSH
39901: CALL_OW 1
39905: ST_TO_ADDR
// continue ;
39906: GO 39851
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39908: LD_VAR 0 3
39912: PPUSH
39913: CALL_OW 311
39917: NOT
39918: PUSH
39919: LD_VAR 0 3
39923: PUSH
39924: LD_EXP 80
39928: PUSH
39929: LD_VAR 0 2
39933: ARRAY
39934: PUSH
39935: LD_INT 1
39937: ARRAY
39938: IN
39939: NOT
39940: AND
39941: PUSH
39942: LD_VAR 0 3
39946: PUSH
39947: LD_EXP 80
39951: PUSH
39952: LD_VAR 0 2
39956: ARRAY
39957: PUSH
39958: LD_INT 2
39960: ARRAY
39961: IN
39962: NOT
39963: AND
39964: IFFALSE 40027
// begin if IsInUnit ( j ) then
39966: LD_VAR 0 3
39970: PPUSH
39971: CALL_OW 310
39975: IFFALSE 39988
// ComExitBuilding ( j ) else
39977: LD_VAR 0 3
39981: PPUSH
39982: CALL_OW 122
39986: GO 40027
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
39988: LD_VAR 0 3
39992: PPUSH
39993: LD_VAR 0 7
39997: PUSH
39998: LD_INT 1
40000: ARRAY
40001: PPUSH
40002: CALL 91465 0 2
40006: NOT
40007: IFFALSE 40027
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40009: LD_VAR 0 3
40013: PPUSH
40014: LD_VAR 0 7
40018: PUSH
40019: LD_INT 1
40021: ARRAY
40022: PPUSH
40023: CALL_OW 129
// end ; end ;
40027: GO 39851
40029: POP
40030: POP
// end ;
40031: GO 39312
40033: POP
40034: POP
// end ;
40035: LD_VAR 0 1
40039: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40040: LD_INT 0
40042: PPUSH
40043: PPUSH
40044: PPUSH
40045: PPUSH
40046: PPUSH
40047: PPUSH
40048: PPUSH
40049: PPUSH
40050: PPUSH
40051: PPUSH
40052: PPUSH
// if not mc_bases then
40053: LD_EXP 77
40057: NOT
40058: IFFALSE 40062
// exit ;
40060: GO 40864
// for i = 1 to mc_bases do
40062: LD_ADDR_VAR 0 2
40066: PUSH
40067: DOUBLE
40068: LD_INT 1
40070: DEC
40071: ST_TO_ADDR
40072: LD_EXP 77
40076: PUSH
40077: FOR_TO
40078: IFFALSE 40862
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40080: LD_EXP 105
40084: PUSH
40085: LD_VAR 0 2
40089: ARRAY
40090: NOT
40091: PUSH
40092: LD_EXP 80
40096: PUSH
40097: LD_VAR 0 2
40101: ARRAY
40102: PUSH
40103: LD_INT 1
40105: ARRAY
40106: OR
40107: PUSH
40108: LD_EXP 80
40112: PUSH
40113: LD_VAR 0 2
40117: ARRAY
40118: PUSH
40119: LD_INT 2
40121: ARRAY
40122: OR
40123: PUSH
40124: LD_EXP 103
40128: PUSH
40129: LD_VAR 0 2
40133: ARRAY
40134: PPUSH
40135: LD_INT 1
40137: PPUSH
40138: CALL_OW 325
40142: NOT
40143: OR
40144: PUSH
40145: LD_EXP 100
40149: PUSH
40150: LD_VAR 0 2
40154: ARRAY
40155: OR
40156: IFFALSE 40160
// continue ;
40158: GO 40077
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
40160: LD_ADDR_VAR 0 8
40164: PUSH
40165: LD_EXP 77
40169: PUSH
40170: LD_VAR 0 2
40174: ARRAY
40175: PPUSH
40176: LD_INT 25
40178: PUSH
40179: LD_INT 4
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: LD_INT 50
40188: PUSH
40189: EMPTY
40190: LIST
40191: PUSH
40192: LD_INT 3
40194: PUSH
40195: LD_INT 60
40197: PUSH
40198: EMPTY
40199: LIST
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: LIST
40209: PPUSH
40210: CALL_OW 72
40214: PUSH
40215: LD_EXP 81
40219: PUSH
40220: LD_VAR 0 2
40224: ARRAY
40225: DIFF
40226: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40227: LD_ADDR_VAR 0 9
40231: PUSH
40232: LD_EXP 77
40236: PUSH
40237: LD_VAR 0 2
40241: ARRAY
40242: PPUSH
40243: LD_INT 2
40245: PUSH
40246: LD_INT 30
40248: PUSH
40249: LD_INT 0
40251: PUSH
40252: EMPTY
40253: LIST
40254: LIST
40255: PUSH
40256: LD_INT 30
40258: PUSH
40259: LD_INT 1
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: EMPTY
40267: LIST
40268: LIST
40269: LIST
40270: PPUSH
40271: CALL_OW 72
40275: ST_TO_ADDR
// if not tmp or not dep then
40276: LD_VAR 0 8
40280: NOT
40281: PUSH
40282: LD_VAR 0 9
40286: NOT
40287: OR
40288: IFFALSE 40292
// continue ;
40290: GO 40077
// side := GetSide ( tmp [ 1 ] ) ;
40292: LD_ADDR_VAR 0 11
40296: PUSH
40297: LD_VAR 0 8
40301: PUSH
40302: LD_INT 1
40304: ARRAY
40305: PPUSH
40306: CALL_OW 255
40310: ST_TO_ADDR
// dep := dep [ 1 ] ;
40311: LD_ADDR_VAR 0 9
40315: PUSH
40316: LD_VAR 0 9
40320: PUSH
40321: LD_INT 1
40323: ARRAY
40324: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
40325: LD_ADDR_VAR 0 7
40329: PUSH
40330: LD_EXP 105
40334: PUSH
40335: LD_VAR 0 2
40339: ARRAY
40340: PPUSH
40341: LD_INT 22
40343: PUSH
40344: LD_INT 0
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 25
40353: PUSH
40354: LD_INT 12
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: PPUSH
40365: CALL_OW 70
40369: PUSH
40370: LD_INT 22
40372: PUSH
40373: LD_INT 0
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: LD_INT 25
40382: PUSH
40383: LD_INT 12
40385: PUSH
40386: EMPTY
40387: LIST
40388: LIST
40389: PUSH
40390: LD_INT 91
40392: PUSH
40393: LD_VAR 0 9
40397: PUSH
40398: LD_INT 20
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: LIST
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: LIST
40410: PPUSH
40411: CALL_OW 69
40415: UNION
40416: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
40417: LD_ADDR_VAR 0 10
40421: PUSH
40422: LD_EXP 105
40426: PUSH
40427: LD_VAR 0 2
40431: ARRAY
40432: PPUSH
40433: LD_INT 81
40435: PUSH
40436: LD_VAR 0 11
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PPUSH
40445: CALL_OW 70
40449: ST_TO_ADDR
// if not apes or danger_at_area then
40450: LD_VAR 0 7
40454: NOT
40455: PUSH
40456: LD_VAR 0 10
40460: OR
40461: IFFALSE 40511
// begin if mc_taming [ i ] then
40463: LD_EXP 108
40467: PUSH
40468: LD_VAR 0 2
40472: ARRAY
40473: IFFALSE 40509
// begin MC_Reset ( i , 121 ) ;
40475: LD_VAR 0 2
40479: PPUSH
40480: LD_INT 121
40482: PPUSH
40483: CALL 25448 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40487: LD_ADDR_EXP 108
40491: PUSH
40492: LD_EXP 108
40496: PPUSH
40497: LD_VAR 0 2
40501: PPUSH
40502: EMPTY
40503: PPUSH
40504: CALL_OW 1
40508: ST_TO_ADDR
// end ; continue ;
40509: GO 40077
// end ; for j in tmp do
40511: LD_ADDR_VAR 0 3
40515: PUSH
40516: LD_VAR 0 8
40520: PUSH
40521: FOR_IN
40522: IFFALSE 40858
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40524: LD_VAR 0 3
40528: PUSH
40529: LD_EXP 108
40533: PUSH
40534: LD_VAR 0 2
40538: ARRAY
40539: IN
40540: NOT
40541: PUSH
40542: LD_EXP 108
40546: PUSH
40547: LD_VAR 0 2
40551: ARRAY
40552: PUSH
40553: LD_INT 3
40555: LESS
40556: AND
40557: IFFALSE 40615
// begin SetTag ( j , 121 ) ;
40559: LD_VAR 0 3
40563: PPUSH
40564: LD_INT 121
40566: PPUSH
40567: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40571: LD_ADDR_EXP 108
40575: PUSH
40576: LD_EXP 108
40580: PPUSH
40581: LD_VAR 0 2
40585: PUSH
40586: LD_EXP 108
40590: PUSH
40591: LD_VAR 0 2
40595: ARRAY
40596: PUSH
40597: LD_INT 1
40599: PLUS
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: PPUSH
40605: LD_VAR 0 3
40609: PPUSH
40610: CALL 57088 0 3
40614: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40615: LD_VAR 0 3
40619: PUSH
40620: LD_EXP 108
40624: PUSH
40625: LD_VAR 0 2
40629: ARRAY
40630: IN
40631: IFFALSE 40856
// begin if GetClass ( j ) <> 4 then
40633: LD_VAR 0 3
40637: PPUSH
40638: CALL_OW 257
40642: PUSH
40643: LD_INT 4
40645: NONEQUAL
40646: IFFALSE 40699
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40648: LD_ADDR_EXP 108
40652: PUSH
40653: LD_EXP 108
40657: PPUSH
40658: LD_VAR 0 2
40662: PPUSH
40663: LD_EXP 108
40667: PUSH
40668: LD_VAR 0 2
40672: ARRAY
40673: PUSH
40674: LD_VAR 0 3
40678: DIFF
40679: PPUSH
40680: CALL_OW 1
40684: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40685: LD_VAR 0 3
40689: PPUSH
40690: LD_INT 0
40692: PPUSH
40693: CALL_OW 109
// continue ;
40697: GO 40521
// end ; if IsInUnit ( j ) then
40699: LD_VAR 0 3
40703: PPUSH
40704: CALL_OW 310
40708: IFFALSE 40719
// ComExitBuilding ( j ) ;
40710: LD_VAR 0 3
40714: PPUSH
40715: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40719: LD_ADDR_VAR 0 6
40723: PUSH
40724: LD_VAR 0 7
40728: PPUSH
40729: LD_VAR 0 3
40733: PPUSH
40734: CALL_OW 74
40738: ST_TO_ADDR
// if not ape then
40739: LD_VAR 0 6
40743: NOT
40744: IFFALSE 40748
// break ;
40746: GO 40858
// x := GetX ( ape ) ;
40748: LD_ADDR_VAR 0 4
40752: PUSH
40753: LD_VAR 0 6
40757: PPUSH
40758: CALL_OW 250
40762: ST_TO_ADDR
// y := GetY ( ape ) ;
40763: LD_ADDR_VAR 0 5
40767: PUSH
40768: LD_VAR 0 6
40772: PPUSH
40773: CALL_OW 251
40777: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40778: LD_VAR 0 4
40782: PPUSH
40783: LD_VAR 0 5
40787: PPUSH
40788: CALL_OW 488
40792: NOT
40793: PUSH
40794: LD_VAR 0 11
40798: PPUSH
40799: LD_VAR 0 4
40803: PPUSH
40804: LD_VAR 0 5
40808: PPUSH
40809: LD_INT 20
40811: PPUSH
40812: CALL 57984 0 4
40816: PUSH
40817: LD_INT 4
40819: ARRAY
40820: OR
40821: IFFALSE 40825
// break ;
40823: GO 40858
// if not HasTask ( j ) then
40825: LD_VAR 0 3
40829: PPUSH
40830: CALL_OW 314
40834: NOT
40835: IFFALSE 40856
// ComTameXY ( j , x , y ) ;
40837: LD_VAR 0 3
40841: PPUSH
40842: LD_VAR 0 4
40846: PPUSH
40847: LD_VAR 0 5
40851: PPUSH
40852: CALL_OW 131
// end ; end ;
40856: GO 40521
40858: POP
40859: POP
// end ;
40860: GO 40077
40862: POP
40863: POP
// end ;
40864: LD_VAR 0 1
40868: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40869: LD_INT 0
40871: PPUSH
40872: PPUSH
40873: PPUSH
40874: PPUSH
40875: PPUSH
40876: PPUSH
40877: PPUSH
40878: PPUSH
// if not mc_bases then
40879: LD_EXP 77
40883: NOT
40884: IFFALSE 40888
// exit ;
40886: GO 41514
// for i = 1 to mc_bases do
40888: LD_ADDR_VAR 0 2
40892: PUSH
40893: DOUBLE
40894: LD_INT 1
40896: DEC
40897: ST_TO_ADDR
40898: LD_EXP 77
40902: PUSH
40903: FOR_TO
40904: IFFALSE 41512
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40906: LD_EXP 106
40910: PUSH
40911: LD_VAR 0 2
40915: ARRAY
40916: NOT
40917: PUSH
40918: LD_EXP 106
40922: PUSH
40923: LD_VAR 0 2
40927: ARRAY
40928: PPUSH
40929: LD_INT 25
40931: PUSH
40932: LD_INT 12
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PPUSH
40939: CALL_OW 72
40943: NOT
40944: OR
40945: IFFALSE 40949
// continue ;
40947: GO 40903
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
40949: LD_ADDR_VAR 0 5
40953: PUSH
40954: LD_EXP 106
40958: PUSH
40959: LD_VAR 0 2
40963: ARRAY
40964: PUSH
40965: LD_INT 1
40967: ARRAY
40968: PPUSH
40969: CALL_OW 255
40973: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
40974: LD_VAR 0 5
40978: PPUSH
40979: LD_INT 2
40981: PPUSH
40982: CALL_OW 325
40986: IFFALSE 41239
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40988: LD_ADDR_VAR 0 4
40992: PUSH
40993: LD_EXP 106
40997: PUSH
40998: LD_VAR 0 2
41002: ARRAY
41003: PPUSH
41004: LD_INT 25
41006: PUSH
41007: LD_INT 16
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PPUSH
41014: CALL_OW 72
41018: ST_TO_ADDR
// if tmp < 6 then
41019: LD_VAR 0 4
41023: PUSH
41024: LD_INT 6
41026: LESS
41027: IFFALSE 41239
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41029: LD_ADDR_VAR 0 6
41033: PUSH
41034: LD_EXP 77
41038: PUSH
41039: LD_VAR 0 2
41043: ARRAY
41044: PPUSH
41045: LD_INT 2
41047: PUSH
41048: LD_INT 30
41050: PUSH
41051: LD_INT 0
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 30
41060: PUSH
41061: LD_INT 1
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: LIST
41072: PPUSH
41073: CALL_OW 72
41077: ST_TO_ADDR
// if depot then
41078: LD_VAR 0 6
41082: IFFALSE 41239
// begin selected := 0 ;
41084: LD_ADDR_VAR 0 7
41088: PUSH
41089: LD_INT 0
41091: ST_TO_ADDR
// for j in depot do
41092: LD_ADDR_VAR 0 3
41096: PUSH
41097: LD_VAR 0 6
41101: PUSH
41102: FOR_IN
41103: IFFALSE 41134
// begin if UnitsInside ( j ) < 6 then
41105: LD_VAR 0 3
41109: PPUSH
41110: CALL_OW 313
41114: PUSH
41115: LD_INT 6
41117: LESS
41118: IFFALSE 41132
// begin selected := j ;
41120: LD_ADDR_VAR 0 7
41124: PUSH
41125: LD_VAR 0 3
41129: ST_TO_ADDR
// break ;
41130: GO 41134
// end ; end ;
41132: GO 41102
41134: POP
41135: POP
// if selected then
41136: LD_VAR 0 7
41140: IFFALSE 41239
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41142: LD_ADDR_VAR 0 3
41146: PUSH
41147: LD_EXP 106
41151: PUSH
41152: LD_VAR 0 2
41156: ARRAY
41157: PPUSH
41158: LD_INT 25
41160: PUSH
41161: LD_INT 12
41163: PUSH
41164: EMPTY
41165: LIST
41166: LIST
41167: PPUSH
41168: CALL_OW 72
41172: PUSH
41173: FOR_IN
41174: IFFALSE 41237
// if not HasTask ( j ) then
41176: LD_VAR 0 3
41180: PPUSH
41181: CALL_OW 314
41185: NOT
41186: IFFALSE 41235
// begin if not IsInUnit ( j ) then
41188: LD_VAR 0 3
41192: PPUSH
41193: CALL_OW 310
41197: NOT
41198: IFFALSE 41214
// ComEnterUnit ( j , selected ) ;
41200: LD_VAR 0 3
41204: PPUSH
41205: LD_VAR 0 7
41209: PPUSH
41210: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
41214: LD_VAR 0 3
41218: PPUSH
41219: LD_INT 16
41221: PPUSH
41222: CALL_OW 183
// AddComExitBuilding ( j ) ;
41226: LD_VAR 0 3
41230: PPUSH
41231: CALL_OW 182
// end ;
41235: GO 41173
41237: POP
41238: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
41239: LD_VAR 0 5
41243: PPUSH
41244: LD_INT 11
41246: PPUSH
41247: CALL_OW 325
41251: IFFALSE 41510
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41253: LD_ADDR_VAR 0 4
41257: PUSH
41258: LD_EXP 106
41262: PUSH
41263: LD_VAR 0 2
41267: ARRAY
41268: PPUSH
41269: LD_INT 25
41271: PUSH
41272: LD_INT 16
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PPUSH
41279: CALL_OW 72
41283: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
41284: LD_VAR 0 4
41288: PUSH
41289: LD_INT 6
41291: GREATEREQUAL
41292: PUSH
41293: LD_VAR 0 5
41297: PPUSH
41298: LD_INT 2
41300: PPUSH
41301: CALL_OW 325
41305: NOT
41306: OR
41307: IFFALSE 41510
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41309: LD_ADDR_VAR 0 8
41313: PUSH
41314: LD_EXP 77
41318: PUSH
41319: LD_VAR 0 2
41323: ARRAY
41324: PPUSH
41325: LD_INT 2
41327: PUSH
41328: LD_INT 30
41330: PUSH
41331: LD_INT 4
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: LD_INT 30
41340: PUSH
41341: LD_INT 5
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: LIST
41352: PPUSH
41353: CALL_OW 72
41357: ST_TO_ADDR
// if barracks then
41358: LD_VAR 0 8
41362: IFFALSE 41510
// begin selected := 0 ;
41364: LD_ADDR_VAR 0 7
41368: PUSH
41369: LD_INT 0
41371: ST_TO_ADDR
// for j in barracks do
41372: LD_ADDR_VAR 0 3
41376: PUSH
41377: LD_VAR 0 8
41381: PUSH
41382: FOR_IN
41383: IFFALSE 41414
// begin if UnitsInside ( j ) < 6 then
41385: LD_VAR 0 3
41389: PPUSH
41390: CALL_OW 313
41394: PUSH
41395: LD_INT 6
41397: LESS
41398: IFFALSE 41412
// begin selected := j ;
41400: LD_ADDR_VAR 0 7
41404: PUSH
41405: LD_VAR 0 3
41409: ST_TO_ADDR
// break ;
41410: GO 41414
// end ; end ;
41412: GO 41382
41414: POP
41415: POP
// if selected then
41416: LD_VAR 0 7
41420: IFFALSE 41510
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41422: LD_ADDR_VAR 0 3
41426: PUSH
41427: LD_EXP 106
41431: PUSH
41432: LD_VAR 0 2
41436: ARRAY
41437: PPUSH
41438: LD_INT 25
41440: PUSH
41441: LD_INT 12
41443: PUSH
41444: EMPTY
41445: LIST
41446: LIST
41447: PPUSH
41448: CALL_OW 72
41452: PUSH
41453: FOR_IN
41454: IFFALSE 41508
// if not IsInUnit ( j ) and not HasTask ( j ) then
41456: LD_VAR 0 3
41460: PPUSH
41461: CALL_OW 310
41465: NOT
41466: PUSH
41467: LD_VAR 0 3
41471: PPUSH
41472: CALL_OW 314
41476: NOT
41477: AND
41478: IFFALSE 41506
// begin ComEnterUnit ( j , selected ) ;
41480: LD_VAR 0 3
41484: PPUSH
41485: LD_VAR 0 7
41489: PPUSH
41490: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41494: LD_VAR 0 3
41498: PPUSH
41499: LD_INT 15
41501: PPUSH
41502: CALL_OW 183
// end ;
41506: GO 41453
41508: POP
41509: POP
// end ; end ; end ; end ; end ;
41510: GO 40903
41512: POP
41513: POP
// end ;
41514: LD_VAR 0 1
41518: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41519: LD_INT 0
41521: PPUSH
41522: PPUSH
41523: PPUSH
41524: PPUSH
// if not mc_bases then
41525: LD_EXP 77
41529: NOT
41530: IFFALSE 41534
// exit ;
41532: GO 41712
// for i = 1 to mc_bases do
41534: LD_ADDR_VAR 0 2
41538: PUSH
41539: DOUBLE
41540: LD_INT 1
41542: DEC
41543: ST_TO_ADDR
41544: LD_EXP 77
41548: PUSH
41549: FOR_TO
41550: IFFALSE 41710
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41552: LD_ADDR_VAR 0 4
41556: PUSH
41557: LD_EXP 77
41561: PUSH
41562: LD_VAR 0 2
41566: ARRAY
41567: PPUSH
41568: LD_INT 25
41570: PUSH
41571: LD_INT 9
41573: PUSH
41574: EMPTY
41575: LIST
41576: LIST
41577: PPUSH
41578: CALL_OW 72
41582: ST_TO_ADDR
// if not tmp then
41583: LD_VAR 0 4
41587: NOT
41588: IFFALSE 41592
// continue ;
41590: GO 41549
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41592: LD_EXP 103
41596: PUSH
41597: LD_VAR 0 2
41601: ARRAY
41602: PPUSH
41603: LD_INT 29
41605: PPUSH
41606: CALL_OW 325
41610: NOT
41611: PUSH
41612: LD_EXP 103
41616: PUSH
41617: LD_VAR 0 2
41621: ARRAY
41622: PPUSH
41623: LD_INT 28
41625: PPUSH
41626: CALL_OW 325
41630: NOT
41631: AND
41632: IFFALSE 41636
// continue ;
41634: GO 41549
// for j in tmp do
41636: LD_ADDR_VAR 0 3
41640: PUSH
41641: LD_VAR 0 4
41645: PUSH
41646: FOR_IN
41647: IFFALSE 41706
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41649: LD_VAR 0 3
41653: PUSH
41654: LD_EXP 80
41658: PUSH
41659: LD_VAR 0 2
41663: ARRAY
41664: PUSH
41665: LD_INT 1
41667: ARRAY
41668: IN
41669: NOT
41670: PUSH
41671: LD_VAR 0 3
41675: PUSH
41676: LD_EXP 80
41680: PUSH
41681: LD_VAR 0 2
41685: ARRAY
41686: PUSH
41687: LD_INT 2
41689: ARRAY
41690: IN
41691: NOT
41692: AND
41693: IFFALSE 41704
// ComSpaceTimeShoot ( j ) ;
41695: LD_VAR 0 3
41699: PPUSH
41700: CALL 52898 0 1
41704: GO 41646
41706: POP
41707: POP
// end ;
41708: GO 41549
41710: POP
41711: POP
// end ;
41712: LD_VAR 0 1
41716: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41717: LD_INT 0
41719: PPUSH
41720: PPUSH
41721: PPUSH
41722: PPUSH
41723: PPUSH
41724: PPUSH
41725: PPUSH
41726: PPUSH
41727: PPUSH
// if not mc_bases then
41728: LD_EXP 77
41732: NOT
41733: IFFALSE 41737
// exit ;
41735: GO 42359
// for i = 1 to mc_bases do
41737: LD_ADDR_VAR 0 2
41741: PUSH
41742: DOUBLE
41743: LD_INT 1
41745: DEC
41746: ST_TO_ADDR
41747: LD_EXP 77
41751: PUSH
41752: FOR_TO
41753: IFFALSE 42357
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41755: LD_EXP 112
41759: PUSH
41760: LD_VAR 0 2
41764: ARRAY
41765: NOT
41766: PUSH
41767: LD_INT 38
41769: PPUSH
41770: LD_EXP 103
41774: PUSH
41775: LD_VAR 0 2
41779: ARRAY
41780: PPUSH
41781: CALL_OW 321
41785: PUSH
41786: LD_INT 2
41788: NONEQUAL
41789: OR
41790: IFFALSE 41794
// continue ;
41792: GO 41752
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41794: LD_ADDR_VAR 0 8
41798: PUSH
41799: LD_EXP 77
41803: PUSH
41804: LD_VAR 0 2
41808: ARRAY
41809: PPUSH
41810: LD_INT 30
41812: PUSH
41813: LD_INT 34
41815: PUSH
41816: EMPTY
41817: LIST
41818: LIST
41819: PPUSH
41820: CALL_OW 72
41824: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41825: LD_ADDR_VAR 0 9
41829: PUSH
41830: LD_EXP 77
41834: PUSH
41835: LD_VAR 0 2
41839: ARRAY
41840: PPUSH
41841: LD_INT 25
41843: PUSH
41844: LD_INT 4
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PPUSH
41851: CALL_OW 72
41855: PPUSH
41856: LD_INT 0
41858: PPUSH
41859: CALL 86974 0 2
41863: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41864: LD_VAR 0 9
41868: NOT
41869: PUSH
41870: LD_VAR 0 8
41874: NOT
41875: OR
41876: PUSH
41877: LD_EXP 77
41881: PUSH
41882: LD_VAR 0 2
41886: ARRAY
41887: PPUSH
41888: LD_INT 124
41890: PPUSH
41891: CALL 86974 0 2
41895: OR
41896: IFFALSE 41900
// continue ;
41898: GO 41752
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41900: LD_EXP 113
41904: PUSH
41905: LD_VAR 0 2
41909: ARRAY
41910: PUSH
41911: LD_EXP 112
41915: PUSH
41916: LD_VAR 0 2
41920: ARRAY
41921: LESS
41922: PUSH
41923: LD_EXP 113
41927: PUSH
41928: LD_VAR 0 2
41932: ARRAY
41933: PUSH
41934: LD_VAR 0 8
41938: LESS
41939: AND
41940: IFFALSE 42355
// begin tmp := sci [ 1 ] ;
41942: LD_ADDR_VAR 0 7
41946: PUSH
41947: LD_VAR 0 9
41951: PUSH
41952: LD_INT 1
41954: ARRAY
41955: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
41956: LD_VAR 0 7
41960: PPUSH
41961: LD_INT 124
41963: PPUSH
41964: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
41968: LD_ADDR_VAR 0 3
41972: PUSH
41973: DOUBLE
41974: LD_EXP 112
41978: PUSH
41979: LD_VAR 0 2
41983: ARRAY
41984: INC
41985: ST_TO_ADDR
41986: LD_EXP 112
41990: PUSH
41991: LD_VAR 0 2
41995: ARRAY
41996: PUSH
41997: FOR_DOWNTO
41998: IFFALSE 42341
// begin if IsInUnit ( tmp ) then
42000: LD_VAR 0 7
42004: PPUSH
42005: CALL_OW 310
42009: IFFALSE 42020
// ComExitBuilding ( tmp ) ;
42011: LD_VAR 0 7
42015: PPUSH
42016: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42020: LD_INT 35
42022: PPUSH
42023: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42027: LD_VAR 0 7
42031: PPUSH
42032: CALL_OW 310
42036: NOT
42037: PUSH
42038: LD_VAR 0 7
42042: PPUSH
42043: CALL_OW 314
42047: NOT
42048: AND
42049: IFFALSE 42020
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42051: LD_ADDR_VAR 0 6
42055: PUSH
42056: LD_VAR 0 7
42060: PPUSH
42061: CALL_OW 250
42065: PUSH
42066: LD_VAR 0 7
42070: PPUSH
42071: CALL_OW 251
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42080: LD_INT 35
42082: PPUSH
42083: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42087: LD_ADDR_VAR 0 4
42091: PUSH
42092: LD_EXP 112
42096: PUSH
42097: LD_VAR 0 2
42101: ARRAY
42102: PUSH
42103: LD_VAR 0 3
42107: ARRAY
42108: PUSH
42109: LD_INT 1
42111: ARRAY
42112: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42113: LD_ADDR_VAR 0 5
42117: PUSH
42118: LD_EXP 112
42122: PUSH
42123: LD_VAR 0 2
42127: ARRAY
42128: PUSH
42129: LD_VAR 0 3
42133: ARRAY
42134: PUSH
42135: LD_INT 2
42137: ARRAY
42138: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42139: LD_VAR 0 7
42143: PPUSH
42144: LD_INT 10
42146: PPUSH
42147: CALL 59685 0 2
42151: PUSH
42152: LD_INT 4
42154: ARRAY
42155: IFFALSE 42193
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
42157: LD_VAR 0 7
42161: PPUSH
42162: LD_VAR 0 6
42166: PUSH
42167: LD_INT 1
42169: ARRAY
42170: PPUSH
42171: LD_VAR 0 6
42175: PUSH
42176: LD_INT 2
42178: ARRAY
42179: PPUSH
42180: CALL_OW 111
// wait ( 0 0$10 ) ;
42184: LD_INT 350
42186: PPUSH
42187: CALL_OW 67
// end else
42191: GO 42219
// begin ComMoveXY ( tmp , x , y ) ;
42193: LD_VAR 0 7
42197: PPUSH
42198: LD_VAR 0 4
42202: PPUSH
42203: LD_VAR 0 5
42207: PPUSH
42208: CALL_OW 111
// wait ( 0 0$3 ) ;
42212: LD_INT 105
42214: PPUSH
42215: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
42219: LD_VAR 0 7
42223: PPUSH
42224: LD_VAR 0 4
42228: PPUSH
42229: LD_VAR 0 5
42233: PPUSH
42234: CALL_OW 307
42238: IFFALSE 42080
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
42240: LD_VAR 0 7
42244: PPUSH
42245: LD_VAR 0 4
42249: PPUSH
42250: LD_VAR 0 5
42254: PPUSH
42255: LD_VAR 0 8
42259: PUSH
42260: LD_VAR 0 3
42264: ARRAY
42265: PPUSH
42266: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
42270: LD_INT 35
42272: PPUSH
42273: CALL_OW 67
// until not HasTask ( tmp ) ;
42277: LD_VAR 0 7
42281: PPUSH
42282: CALL_OW 314
42286: NOT
42287: IFFALSE 42270
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
42289: LD_ADDR_EXP 113
42293: PUSH
42294: LD_EXP 113
42298: PPUSH
42299: LD_VAR 0 2
42303: PUSH
42304: LD_EXP 113
42308: PUSH
42309: LD_VAR 0 2
42313: ARRAY
42314: PUSH
42315: LD_INT 1
42317: PLUS
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PPUSH
42323: LD_VAR 0 8
42327: PUSH
42328: LD_VAR 0 3
42332: ARRAY
42333: PPUSH
42334: CALL 57088 0 3
42338: ST_TO_ADDR
// end ;
42339: GO 41997
42341: POP
42342: POP
// MC_Reset ( i , 124 ) ;
42343: LD_VAR 0 2
42347: PPUSH
42348: LD_INT 124
42350: PPUSH
42351: CALL 25448 0 2
// end ; end ;
42355: GO 41752
42357: POP
42358: POP
// end ;
42359: LD_VAR 0 1
42363: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
42364: LD_INT 0
42366: PPUSH
42367: PPUSH
42368: PPUSH
// if not mc_bases then
42369: LD_EXP 77
42373: NOT
42374: IFFALSE 42378
// exit ;
42376: GO 42984
// for i = 1 to mc_bases do
42378: LD_ADDR_VAR 0 2
42382: PUSH
42383: DOUBLE
42384: LD_INT 1
42386: DEC
42387: ST_TO_ADDR
42388: LD_EXP 77
42392: PUSH
42393: FOR_TO
42394: IFFALSE 42982
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42396: LD_ADDR_VAR 0 3
42400: PUSH
42401: LD_EXP 77
42405: PUSH
42406: LD_VAR 0 2
42410: ARRAY
42411: PPUSH
42412: LD_INT 25
42414: PUSH
42415: LD_INT 4
42417: PUSH
42418: EMPTY
42419: LIST
42420: LIST
42421: PPUSH
42422: CALL_OW 72
42426: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42427: LD_VAR 0 3
42431: NOT
42432: PUSH
42433: LD_EXP 114
42437: PUSH
42438: LD_VAR 0 2
42442: ARRAY
42443: NOT
42444: OR
42445: PUSH
42446: LD_EXP 77
42450: PUSH
42451: LD_VAR 0 2
42455: ARRAY
42456: PPUSH
42457: LD_INT 2
42459: PUSH
42460: LD_INT 30
42462: PUSH
42463: LD_INT 0
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: LD_INT 30
42472: PUSH
42473: LD_INT 1
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: LIST
42484: PPUSH
42485: CALL_OW 72
42489: NOT
42490: OR
42491: IFFALSE 42541
// begin if mc_deposits_finder [ i ] then
42493: LD_EXP 115
42497: PUSH
42498: LD_VAR 0 2
42502: ARRAY
42503: IFFALSE 42539
// begin MC_Reset ( i , 125 ) ;
42505: LD_VAR 0 2
42509: PPUSH
42510: LD_INT 125
42512: PPUSH
42513: CALL 25448 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42517: LD_ADDR_EXP 115
42521: PUSH
42522: LD_EXP 115
42526: PPUSH
42527: LD_VAR 0 2
42531: PPUSH
42532: EMPTY
42533: PPUSH
42534: CALL_OW 1
42538: ST_TO_ADDR
// end ; continue ;
42539: GO 42393
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42541: LD_EXP 114
42545: PUSH
42546: LD_VAR 0 2
42550: ARRAY
42551: PUSH
42552: LD_INT 1
42554: ARRAY
42555: PUSH
42556: LD_INT 3
42558: ARRAY
42559: PUSH
42560: LD_INT 1
42562: EQUAL
42563: PUSH
42564: LD_INT 20
42566: PPUSH
42567: LD_EXP 103
42571: PUSH
42572: LD_VAR 0 2
42576: ARRAY
42577: PPUSH
42578: CALL_OW 321
42582: PUSH
42583: LD_INT 2
42585: NONEQUAL
42586: AND
42587: IFFALSE 42637
// begin if mc_deposits_finder [ i ] then
42589: LD_EXP 115
42593: PUSH
42594: LD_VAR 0 2
42598: ARRAY
42599: IFFALSE 42635
// begin MC_Reset ( i , 125 ) ;
42601: LD_VAR 0 2
42605: PPUSH
42606: LD_INT 125
42608: PPUSH
42609: CALL 25448 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42613: LD_ADDR_EXP 115
42617: PUSH
42618: LD_EXP 115
42622: PPUSH
42623: LD_VAR 0 2
42627: PPUSH
42628: EMPTY
42629: PPUSH
42630: CALL_OW 1
42634: ST_TO_ADDR
// end ; continue ;
42635: GO 42393
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42637: LD_EXP 114
42641: PUSH
42642: LD_VAR 0 2
42646: ARRAY
42647: PUSH
42648: LD_INT 1
42650: ARRAY
42651: PUSH
42652: LD_INT 1
42654: ARRAY
42655: PPUSH
42656: LD_EXP 114
42660: PUSH
42661: LD_VAR 0 2
42665: ARRAY
42666: PUSH
42667: LD_INT 1
42669: ARRAY
42670: PUSH
42671: LD_INT 2
42673: ARRAY
42674: PPUSH
42675: LD_EXP 103
42679: PUSH
42680: LD_VAR 0 2
42684: ARRAY
42685: PPUSH
42686: CALL_OW 440
42690: IFFALSE 42733
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42692: LD_ADDR_EXP 114
42696: PUSH
42697: LD_EXP 114
42701: PPUSH
42702: LD_VAR 0 2
42706: PPUSH
42707: LD_EXP 114
42711: PUSH
42712: LD_VAR 0 2
42716: ARRAY
42717: PPUSH
42718: LD_INT 1
42720: PPUSH
42721: CALL_OW 3
42725: PPUSH
42726: CALL_OW 1
42730: ST_TO_ADDR
42731: GO 42980
// begin if not mc_deposits_finder [ i ] then
42733: LD_EXP 115
42737: PUSH
42738: LD_VAR 0 2
42742: ARRAY
42743: NOT
42744: IFFALSE 42796
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42746: LD_ADDR_EXP 115
42750: PUSH
42751: LD_EXP 115
42755: PPUSH
42756: LD_VAR 0 2
42760: PPUSH
42761: LD_VAR 0 3
42765: PUSH
42766: LD_INT 1
42768: ARRAY
42769: PUSH
42770: EMPTY
42771: LIST
42772: PPUSH
42773: CALL_OW 1
42777: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42778: LD_VAR 0 3
42782: PUSH
42783: LD_INT 1
42785: ARRAY
42786: PPUSH
42787: LD_INT 125
42789: PPUSH
42790: CALL_OW 109
// end else
42794: GO 42980
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42796: LD_EXP 115
42800: PUSH
42801: LD_VAR 0 2
42805: ARRAY
42806: PUSH
42807: LD_INT 1
42809: ARRAY
42810: PPUSH
42811: CALL_OW 310
42815: IFFALSE 42838
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42817: LD_EXP 115
42821: PUSH
42822: LD_VAR 0 2
42826: ARRAY
42827: PUSH
42828: LD_INT 1
42830: ARRAY
42831: PPUSH
42832: CALL_OW 122
42836: GO 42980
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42838: LD_EXP 115
42842: PUSH
42843: LD_VAR 0 2
42847: ARRAY
42848: PUSH
42849: LD_INT 1
42851: ARRAY
42852: PPUSH
42853: CALL_OW 314
42857: NOT
42858: PUSH
42859: LD_EXP 115
42863: PUSH
42864: LD_VAR 0 2
42868: ARRAY
42869: PUSH
42870: LD_INT 1
42872: ARRAY
42873: PPUSH
42874: LD_EXP 114
42878: PUSH
42879: LD_VAR 0 2
42883: ARRAY
42884: PUSH
42885: LD_INT 1
42887: ARRAY
42888: PUSH
42889: LD_INT 1
42891: ARRAY
42892: PPUSH
42893: LD_EXP 114
42897: PUSH
42898: LD_VAR 0 2
42902: ARRAY
42903: PUSH
42904: LD_INT 1
42906: ARRAY
42907: PUSH
42908: LD_INT 2
42910: ARRAY
42911: PPUSH
42912: CALL_OW 297
42916: PUSH
42917: LD_INT 6
42919: GREATER
42920: AND
42921: IFFALSE 42980
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42923: LD_EXP 115
42927: PUSH
42928: LD_VAR 0 2
42932: ARRAY
42933: PUSH
42934: LD_INT 1
42936: ARRAY
42937: PPUSH
42938: LD_EXP 114
42942: PUSH
42943: LD_VAR 0 2
42947: ARRAY
42948: PUSH
42949: LD_INT 1
42951: ARRAY
42952: PUSH
42953: LD_INT 1
42955: ARRAY
42956: PPUSH
42957: LD_EXP 114
42961: PUSH
42962: LD_VAR 0 2
42966: ARRAY
42967: PUSH
42968: LD_INT 1
42970: ARRAY
42971: PUSH
42972: LD_INT 2
42974: ARRAY
42975: PPUSH
42976: CALL_OW 111
// end ; end ; end ;
42980: GO 42393
42982: POP
42983: POP
// end ;
42984: LD_VAR 0 1
42988: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
42989: LD_INT 0
42991: PPUSH
42992: PPUSH
42993: PPUSH
42994: PPUSH
42995: PPUSH
42996: PPUSH
42997: PPUSH
42998: PPUSH
42999: PPUSH
43000: PPUSH
43001: PPUSH
// if not mc_bases then
43002: LD_EXP 77
43006: NOT
43007: IFFALSE 43011
// exit ;
43009: GO 43951
// for i = 1 to mc_bases do
43011: LD_ADDR_VAR 0 2
43015: PUSH
43016: DOUBLE
43017: LD_INT 1
43019: DEC
43020: ST_TO_ADDR
43021: LD_EXP 77
43025: PUSH
43026: FOR_TO
43027: IFFALSE 43949
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43029: LD_EXP 77
43033: PUSH
43034: LD_VAR 0 2
43038: ARRAY
43039: NOT
43040: PUSH
43041: LD_EXP 100
43045: PUSH
43046: LD_VAR 0 2
43050: ARRAY
43051: OR
43052: IFFALSE 43056
// continue ;
43054: GO 43026
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43056: LD_ADDR_VAR 0 7
43060: PUSH
43061: LD_EXP 77
43065: PUSH
43066: LD_VAR 0 2
43070: ARRAY
43071: PUSH
43072: LD_INT 1
43074: ARRAY
43075: PPUSH
43076: CALL_OW 248
43080: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43081: LD_VAR 0 7
43085: PUSH
43086: LD_INT 3
43088: EQUAL
43089: PUSH
43090: LD_EXP 96
43094: PUSH
43095: LD_VAR 0 2
43099: ARRAY
43100: PUSH
43101: LD_EXP 99
43105: PUSH
43106: LD_VAR 0 2
43110: ARRAY
43111: UNION
43112: PPUSH
43113: LD_INT 33
43115: PUSH
43116: LD_INT 2
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PPUSH
43123: CALL_OW 72
43127: NOT
43128: OR
43129: IFFALSE 43133
// continue ;
43131: GO 43026
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43133: LD_ADDR_VAR 0 9
43137: PUSH
43138: LD_EXP 77
43142: PUSH
43143: LD_VAR 0 2
43147: ARRAY
43148: PPUSH
43149: LD_INT 30
43151: PUSH
43152: LD_INT 36
43154: PUSH
43155: EMPTY
43156: LIST
43157: LIST
43158: PPUSH
43159: CALL_OW 72
43163: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
43164: LD_ADDR_VAR 0 10
43168: PUSH
43169: LD_EXP 96
43173: PUSH
43174: LD_VAR 0 2
43178: ARRAY
43179: PPUSH
43180: LD_INT 34
43182: PUSH
43183: LD_INT 31
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PPUSH
43190: CALL_OW 72
43194: ST_TO_ADDR
// if not cts and not mcts then
43195: LD_VAR 0 9
43199: NOT
43200: PUSH
43201: LD_VAR 0 10
43205: NOT
43206: AND
43207: IFFALSE 43211
// continue ;
43209: GO 43026
// x := cts ;
43211: LD_ADDR_VAR 0 11
43215: PUSH
43216: LD_VAR 0 9
43220: ST_TO_ADDR
// if not x then
43221: LD_VAR 0 11
43225: NOT
43226: IFFALSE 43238
// x := mcts ;
43228: LD_ADDR_VAR 0 11
43232: PUSH
43233: LD_VAR 0 10
43237: ST_TO_ADDR
// if not x then
43238: LD_VAR 0 11
43242: NOT
43243: IFFALSE 43247
// continue ;
43245: GO 43026
// if mc_remote_driver [ i ] then
43247: LD_EXP 117
43251: PUSH
43252: LD_VAR 0 2
43256: ARRAY
43257: IFFALSE 43644
// for j in mc_remote_driver [ i ] do
43259: LD_ADDR_VAR 0 3
43263: PUSH
43264: LD_EXP 117
43268: PUSH
43269: LD_VAR 0 2
43273: ARRAY
43274: PUSH
43275: FOR_IN
43276: IFFALSE 43642
// begin if GetClass ( j ) <> 3 then
43278: LD_VAR 0 3
43282: PPUSH
43283: CALL_OW 257
43287: PUSH
43288: LD_INT 3
43290: NONEQUAL
43291: IFFALSE 43344
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
43293: LD_ADDR_EXP 117
43297: PUSH
43298: LD_EXP 117
43302: PPUSH
43303: LD_VAR 0 2
43307: PPUSH
43308: LD_EXP 117
43312: PUSH
43313: LD_VAR 0 2
43317: ARRAY
43318: PUSH
43319: LD_VAR 0 3
43323: DIFF
43324: PPUSH
43325: CALL_OW 1
43329: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43330: LD_VAR 0 3
43334: PPUSH
43335: LD_INT 0
43337: PPUSH
43338: CALL_OW 109
// continue ;
43342: GO 43275
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
43344: LD_EXP 96
43348: PUSH
43349: LD_VAR 0 2
43353: ARRAY
43354: PPUSH
43355: LD_INT 34
43357: PUSH
43358: LD_INT 31
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: PUSH
43365: LD_INT 58
43367: PUSH
43368: EMPTY
43369: LIST
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PPUSH
43375: CALL_OW 72
43379: PUSH
43380: LD_VAR 0 3
43384: PPUSH
43385: CALL 87009 0 1
43389: NOT
43390: AND
43391: IFFALSE 43462
// begin if IsInUnit ( j ) then
43393: LD_VAR 0 3
43397: PPUSH
43398: CALL_OW 310
43402: IFFALSE 43413
// ComExitBuilding ( j ) ;
43404: LD_VAR 0 3
43408: PPUSH
43409: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
43413: LD_VAR 0 3
43417: PPUSH
43418: LD_EXP 96
43422: PUSH
43423: LD_VAR 0 2
43427: ARRAY
43428: PPUSH
43429: LD_INT 34
43431: PUSH
43432: LD_INT 31
43434: PUSH
43435: EMPTY
43436: LIST
43437: LIST
43438: PUSH
43439: LD_INT 58
43441: PUSH
43442: EMPTY
43443: LIST
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PPUSH
43449: CALL_OW 72
43453: PUSH
43454: LD_INT 1
43456: ARRAY
43457: PPUSH
43458: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
43462: LD_VAR 0 3
43466: PPUSH
43467: CALL_OW 310
43471: NOT
43472: PUSH
43473: LD_VAR 0 3
43477: PPUSH
43478: CALL_OW 310
43482: PPUSH
43483: CALL_OW 266
43487: PUSH
43488: LD_INT 36
43490: NONEQUAL
43491: PUSH
43492: LD_VAR 0 3
43496: PPUSH
43497: CALL 87009 0 1
43501: NOT
43502: AND
43503: OR
43504: IFFALSE 43640
// begin if IsInUnit ( j ) then
43506: LD_VAR 0 3
43510: PPUSH
43511: CALL_OW 310
43515: IFFALSE 43526
// ComExitBuilding ( j ) ;
43517: LD_VAR 0 3
43521: PPUSH
43522: CALL_OW 122
// ct := 0 ;
43526: LD_ADDR_VAR 0 8
43530: PUSH
43531: LD_INT 0
43533: ST_TO_ADDR
// for k in x do
43534: LD_ADDR_VAR 0 4
43538: PUSH
43539: LD_VAR 0 11
43543: PUSH
43544: FOR_IN
43545: IFFALSE 43618
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43547: LD_VAR 0 4
43551: PPUSH
43552: CALL_OW 264
43556: PUSH
43557: LD_INT 31
43559: EQUAL
43560: PUSH
43561: LD_VAR 0 4
43565: PPUSH
43566: CALL_OW 311
43570: NOT
43571: AND
43572: PUSH
43573: LD_VAR 0 4
43577: PPUSH
43578: CALL_OW 266
43582: PUSH
43583: LD_INT 36
43585: EQUAL
43586: PUSH
43587: LD_VAR 0 4
43591: PPUSH
43592: CALL_OW 313
43596: PUSH
43597: LD_INT 3
43599: LESS
43600: AND
43601: OR
43602: IFFALSE 43616
// begin ct := k ;
43604: LD_ADDR_VAR 0 8
43608: PUSH
43609: LD_VAR 0 4
43613: ST_TO_ADDR
// break ;
43614: GO 43618
// end ;
43616: GO 43544
43618: POP
43619: POP
// if ct then
43620: LD_VAR 0 8
43624: IFFALSE 43640
// ComEnterUnit ( j , ct ) ;
43626: LD_VAR 0 3
43630: PPUSH
43631: LD_VAR 0 8
43635: PPUSH
43636: CALL_OW 120
// end ; end ;
43640: GO 43275
43642: POP
43643: POP
// places := 0 ;
43644: LD_ADDR_VAR 0 5
43648: PUSH
43649: LD_INT 0
43651: ST_TO_ADDR
// for j = 1 to x do
43652: LD_ADDR_VAR 0 3
43656: PUSH
43657: DOUBLE
43658: LD_INT 1
43660: DEC
43661: ST_TO_ADDR
43662: LD_VAR 0 11
43666: PUSH
43667: FOR_TO
43668: IFFALSE 43744
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43670: LD_VAR 0 11
43674: PUSH
43675: LD_VAR 0 3
43679: ARRAY
43680: PPUSH
43681: CALL_OW 264
43685: PUSH
43686: LD_INT 31
43688: EQUAL
43689: IFFALSE 43707
// places := places + 1 else
43691: LD_ADDR_VAR 0 5
43695: PUSH
43696: LD_VAR 0 5
43700: PUSH
43701: LD_INT 1
43703: PLUS
43704: ST_TO_ADDR
43705: GO 43742
// if GetBType ( x [ j ] ) = b_control_tower then
43707: LD_VAR 0 11
43711: PUSH
43712: LD_VAR 0 3
43716: ARRAY
43717: PPUSH
43718: CALL_OW 266
43722: PUSH
43723: LD_INT 36
43725: EQUAL
43726: IFFALSE 43742
// places := places + 3 ;
43728: LD_ADDR_VAR 0 5
43732: PUSH
43733: LD_VAR 0 5
43737: PUSH
43738: LD_INT 3
43740: PLUS
43741: ST_TO_ADDR
43742: GO 43667
43744: POP
43745: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43746: LD_VAR 0 5
43750: PUSH
43751: LD_INT 0
43753: EQUAL
43754: PUSH
43755: LD_VAR 0 5
43759: PUSH
43760: LD_EXP 117
43764: PUSH
43765: LD_VAR 0 2
43769: ARRAY
43770: LESSEQUAL
43771: OR
43772: IFFALSE 43776
// continue ;
43774: GO 43026
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43776: LD_ADDR_VAR 0 6
43780: PUSH
43781: LD_EXP 77
43785: PUSH
43786: LD_VAR 0 2
43790: ARRAY
43791: PPUSH
43792: LD_INT 25
43794: PUSH
43795: LD_INT 3
43797: PUSH
43798: EMPTY
43799: LIST
43800: LIST
43801: PPUSH
43802: CALL_OW 72
43806: PUSH
43807: LD_EXP 117
43811: PUSH
43812: LD_VAR 0 2
43816: ARRAY
43817: DIFF
43818: PPUSH
43819: LD_INT 3
43821: PPUSH
43822: CALL 87909 0 2
43826: ST_TO_ADDR
// for j in tmp do
43827: LD_ADDR_VAR 0 3
43831: PUSH
43832: LD_VAR 0 6
43836: PUSH
43837: FOR_IN
43838: IFFALSE 43873
// if GetTag ( j ) > 0 then
43840: LD_VAR 0 3
43844: PPUSH
43845: CALL_OW 110
43849: PUSH
43850: LD_INT 0
43852: GREATER
43853: IFFALSE 43871
// tmp := tmp diff j ;
43855: LD_ADDR_VAR 0 6
43859: PUSH
43860: LD_VAR 0 6
43864: PUSH
43865: LD_VAR 0 3
43869: DIFF
43870: ST_TO_ADDR
43871: GO 43837
43873: POP
43874: POP
// if not tmp then
43875: LD_VAR 0 6
43879: NOT
43880: IFFALSE 43884
// continue ;
43882: GO 43026
// if places then
43884: LD_VAR 0 5
43888: IFFALSE 43947
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43890: LD_ADDR_EXP 117
43894: PUSH
43895: LD_EXP 117
43899: PPUSH
43900: LD_VAR 0 2
43904: PPUSH
43905: LD_EXP 117
43909: PUSH
43910: LD_VAR 0 2
43914: ARRAY
43915: PUSH
43916: LD_VAR 0 6
43920: PUSH
43921: LD_INT 1
43923: ARRAY
43924: UNION
43925: PPUSH
43926: CALL_OW 1
43930: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43931: LD_VAR 0 6
43935: PUSH
43936: LD_INT 1
43938: ARRAY
43939: PPUSH
43940: LD_INT 126
43942: PPUSH
43943: CALL_OW 109
// end ; end ;
43947: GO 43026
43949: POP
43950: POP
// end ;
43951: LD_VAR 0 1
43955: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
43956: LD_INT 0
43958: PPUSH
43959: PPUSH
43960: PPUSH
43961: PPUSH
43962: PPUSH
43963: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
43964: LD_VAR 0 1
43968: NOT
43969: PUSH
43970: LD_VAR 0 2
43974: NOT
43975: OR
43976: PUSH
43977: LD_VAR 0 3
43981: NOT
43982: OR
43983: PUSH
43984: LD_VAR 0 4
43988: PUSH
43989: LD_INT 1
43991: PUSH
43992: LD_INT 2
43994: PUSH
43995: LD_INT 3
43997: PUSH
43998: LD_INT 4
44000: PUSH
44001: LD_INT 5
44003: PUSH
44004: LD_INT 8
44006: PUSH
44007: LD_INT 9
44009: PUSH
44010: LD_INT 15
44012: PUSH
44013: LD_INT 16
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: LIST
44020: LIST
44021: LIST
44022: LIST
44023: LIST
44024: LIST
44025: LIST
44026: IN
44027: NOT
44028: OR
44029: IFFALSE 44033
// exit ;
44031: GO 44933
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44033: LD_ADDR_VAR 0 2
44037: PUSH
44038: LD_VAR 0 2
44042: PPUSH
44043: LD_INT 21
44045: PUSH
44046: LD_INT 3
44048: PUSH
44049: EMPTY
44050: LIST
44051: LIST
44052: PUSH
44053: LD_INT 24
44055: PUSH
44056: LD_INT 250
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PPUSH
44067: CALL_OW 72
44071: ST_TO_ADDR
// case class of 1 , 15 :
44072: LD_VAR 0 4
44076: PUSH
44077: LD_INT 1
44079: DOUBLE
44080: EQUAL
44081: IFTRUE 44091
44083: LD_INT 15
44085: DOUBLE
44086: EQUAL
44087: IFTRUE 44091
44089: GO 44176
44091: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44092: LD_ADDR_VAR 0 8
44096: PUSH
44097: LD_VAR 0 2
44101: PPUSH
44102: LD_INT 2
44104: PUSH
44105: LD_INT 30
44107: PUSH
44108: LD_INT 32
44110: PUSH
44111: EMPTY
44112: LIST
44113: LIST
44114: PUSH
44115: LD_INT 30
44117: PUSH
44118: LD_INT 31
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: LIST
44129: PPUSH
44130: CALL_OW 72
44134: PUSH
44135: LD_VAR 0 2
44139: PPUSH
44140: LD_INT 2
44142: PUSH
44143: LD_INT 30
44145: PUSH
44146: LD_INT 4
44148: PUSH
44149: EMPTY
44150: LIST
44151: LIST
44152: PUSH
44153: LD_INT 30
44155: PUSH
44156: LD_INT 5
44158: PUSH
44159: EMPTY
44160: LIST
44161: LIST
44162: PUSH
44163: EMPTY
44164: LIST
44165: LIST
44166: LIST
44167: PPUSH
44168: CALL_OW 72
44172: ADD
44173: ST_TO_ADDR
44174: GO 44422
44176: LD_INT 2
44178: DOUBLE
44179: EQUAL
44180: IFTRUE 44190
44182: LD_INT 16
44184: DOUBLE
44185: EQUAL
44186: IFTRUE 44190
44188: GO 44236
44190: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
44191: LD_ADDR_VAR 0 8
44195: PUSH
44196: LD_VAR 0 2
44200: PPUSH
44201: LD_INT 2
44203: PUSH
44204: LD_INT 30
44206: PUSH
44207: LD_INT 0
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: LD_INT 30
44216: PUSH
44217: LD_INT 1
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: LIST
44228: PPUSH
44229: CALL_OW 72
44233: ST_TO_ADDR
44234: GO 44422
44236: LD_INT 3
44238: DOUBLE
44239: EQUAL
44240: IFTRUE 44244
44242: GO 44290
44244: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
44245: LD_ADDR_VAR 0 8
44249: PUSH
44250: LD_VAR 0 2
44254: PPUSH
44255: LD_INT 2
44257: PUSH
44258: LD_INT 30
44260: PUSH
44261: LD_INT 2
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 30
44270: PUSH
44271: LD_INT 3
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: PUSH
44278: EMPTY
44279: LIST
44280: LIST
44281: LIST
44282: PPUSH
44283: CALL_OW 72
44287: ST_TO_ADDR
44288: GO 44422
44290: LD_INT 4
44292: DOUBLE
44293: EQUAL
44294: IFTRUE 44298
44296: GO 44355
44298: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
44299: LD_ADDR_VAR 0 8
44303: PUSH
44304: LD_VAR 0 2
44308: PPUSH
44309: LD_INT 2
44311: PUSH
44312: LD_INT 30
44314: PUSH
44315: LD_INT 6
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 30
44324: PUSH
44325: LD_INT 7
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: PUSH
44332: LD_INT 30
44334: PUSH
44335: LD_INT 8
44337: PUSH
44338: EMPTY
44339: LIST
44340: LIST
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: PPUSH
44348: CALL_OW 72
44352: ST_TO_ADDR
44353: GO 44422
44355: LD_INT 5
44357: DOUBLE
44358: EQUAL
44359: IFTRUE 44375
44361: LD_INT 8
44363: DOUBLE
44364: EQUAL
44365: IFTRUE 44375
44367: LD_INT 9
44369: DOUBLE
44370: EQUAL
44371: IFTRUE 44375
44373: GO 44421
44375: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
44376: LD_ADDR_VAR 0 8
44380: PUSH
44381: LD_VAR 0 2
44385: PPUSH
44386: LD_INT 2
44388: PUSH
44389: LD_INT 30
44391: PUSH
44392: LD_INT 4
44394: PUSH
44395: EMPTY
44396: LIST
44397: LIST
44398: PUSH
44399: LD_INT 30
44401: PUSH
44402: LD_INT 5
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: PUSH
44409: EMPTY
44410: LIST
44411: LIST
44412: LIST
44413: PPUSH
44414: CALL_OW 72
44418: ST_TO_ADDR
44419: GO 44422
44421: POP
// if not tmp then
44422: LD_VAR 0 8
44426: NOT
44427: IFFALSE 44431
// exit ;
44429: GO 44933
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
44431: LD_VAR 0 4
44435: PUSH
44436: LD_INT 1
44438: PUSH
44439: LD_INT 15
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: IN
44446: PUSH
44447: LD_EXP 86
44451: PUSH
44452: LD_VAR 0 1
44456: ARRAY
44457: AND
44458: IFFALSE 44614
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
44460: LD_ADDR_VAR 0 9
44464: PUSH
44465: LD_EXP 86
44469: PUSH
44470: LD_VAR 0 1
44474: ARRAY
44475: PUSH
44476: LD_INT 1
44478: ARRAY
44479: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
44480: LD_VAR 0 9
44484: PUSH
44485: LD_EXP 87
44489: PUSH
44490: LD_VAR 0 1
44494: ARRAY
44495: IN
44496: NOT
44497: IFFALSE 44612
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44499: LD_ADDR_EXP 87
44503: PUSH
44504: LD_EXP 87
44508: PPUSH
44509: LD_VAR 0 1
44513: PUSH
44514: LD_EXP 87
44518: PUSH
44519: LD_VAR 0 1
44523: ARRAY
44524: PUSH
44525: LD_INT 1
44527: PLUS
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: PPUSH
44533: LD_VAR 0 9
44537: PPUSH
44538: CALL 57088 0 3
44542: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44543: LD_ADDR_EXP 86
44547: PUSH
44548: LD_EXP 86
44552: PPUSH
44553: LD_VAR 0 1
44557: PPUSH
44558: LD_EXP 86
44562: PUSH
44563: LD_VAR 0 1
44567: ARRAY
44568: PUSH
44569: LD_VAR 0 9
44573: DIFF
44574: PPUSH
44575: CALL_OW 1
44579: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44580: LD_VAR 0 3
44584: PPUSH
44585: LD_EXP 87
44589: PUSH
44590: LD_VAR 0 1
44594: ARRAY
44595: PUSH
44596: LD_EXP 87
44600: PUSH
44601: LD_VAR 0 1
44605: ARRAY
44606: ARRAY
44607: PPUSH
44608: CALL_OW 120
// end ; exit ;
44612: GO 44933
// end ; if tmp > 1 then
44614: LD_VAR 0 8
44618: PUSH
44619: LD_INT 1
44621: GREATER
44622: IFFALSE 44726
// for i = 2 to tmp do
44624: LD_ADDR_VAR 0 6
44628: PUSH
44629: DOUBLE
44630: LD_INT 2
44632: DEC
44633: ST_TO_ADDR
44634: LD_VAR 0 8
44638: PUSH
44639: FOR_TO
44640: IFFALSE 44724
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44642: LD_VAR 0 8
44646: PUSH
44647: LD_VAR 0 6
44651: ARRAY
44652: PPUSH
44653: CALL_OW 461
44657: PUSH
44658: LD_INT 6
44660: EQUAL
44661: IFFALSE 44722
// begin x := tmp [ i ] ;
44663: LD_ADDR_VAR 0 9
44667: PUSH
44668: LD_VAR 0 8
44672: PUSH
44673: LD_VAR 0 6
44677: ARRAY
44678: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44679: LD_ADDR_VAR 0 8
44683: PUSH
44684: LD_VAR 0 8
44688: PPUSH
44689: LD_VAR 0 6
44693: PPUSH
44694: CALL_OW 3
44698: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44699: LD_ADDR_VAR 0 8
44703: PUSH
44704: LD_VAR 0 8
44708: PPUSH
44709: LD_INT 1
44711: PPUSH
44712: LD_VAR 0 9
44716: PPUSH
44717: CALL_OW 2
44721: ST_TO_ADDR
// end ;
44722: GO 44639
44724: POP
44725: POP
// for i in tmp do
44726: LD_ADDR_VAR 0 6
44730: PUSH
44731: LD_VAR 0 8
44735: PUSH
44736: FOR_IN
44737: IFFALSE 44806
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44739: LD_VAR 0 6
44743: PPUSH
44744: CALL_OW 313
44748: PUSH
44749: LD_INT 6
44751: LESS
44752: PUSH
44753: LD_VAR 0 6
44757: PPUSH
44758: CALL_OW 266
44762: PUSH
44763: LD_INT 31
44765: PUSH
44766: LD_INT 32
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: IN
44773: NOT
44774: AND
44775: PUSH
44776: LD_VAR 0 6
44780: PPUSH
44781: CALL_OW 313
44785: PUSH
44786: LD_INT 0
44788: EQUAL
44789: OR
44790: IFFALSE 44804
// begin j := i ;
44792: LD_ADDR_VAR 0 7
44796: PUSH
44797: LD_VAR 0 6
44801: ST_TO_ADDR
// break ;
44802: GO 44806
// end ; end ;
44804: GO 44736
44806: POP
44807: POP
// if j then
44808: LD_VAR 0 7
44812: IFFALSE 44830
// ComEnterUnit ( unit , j ) else
44814: LD_VAR 0 3
44818: PPUSH
44819: LD_VAR 0 7
44823: PPUSH
44824: CALL_OW 120
44828: GO 44933
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44830: LD_ADDR_VAR 0 10
44834: PUSH
44835: LD_VAR 0 2
44839: PPUSH
44840: LD_INT 2
44842: PUSH
44843: LD_INT 30
44845: PUSH
44846: LD_INT 0
44848: PUSH
44849: EMPTY
44850: LIST
44851: LIST
44852: PUSH
44853: LD_INT 30
44855: PUSH
44856: LD_INT 1
44858: PUSH
44859: EMPTY
44860: LIST
44861: LIST
44862: PUSH
44863: EMPTY
44864: LIST
44865: LIST
44866: LIST
44867: PPUSH
44868: CALL_OW 72
44872: ST_TO_ADDR
// if depot then
44873: LD_VAR 0 10
44877: IFFALSE 44933
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44879: LD_ADDR_VAR 0 10
44883: PUSH
44884: LD_VAR 0 10
44888: PPUSH
44889: LD_VAR 0 3
44893: PPUSH
44894: CALL_OW 74
44898: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44899: LD_VAR 0 3
44903: PPUSH
44904: LD_VAR 0 10
44908: PPUSH
44909: CALL_OW 296
44913: PUSH
44914: LD_INT 10
44916: GREATER
44917: IFFALSE 44933
// ComStandNearbyBuilding ( unit , depot ) ;
44919: LD_VAR 0 3
44923: PPUSH
44924: LD_VAR 0 10
44928: PPUSH
44929: CALL 53515 0 2
// end ; end ; end ;
44933: LD_VAR 0 5
44937: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44938: LD_INT 0
44940: PPUSH
44941: PPUSH
44942: PPUSH
44943: PPUSH
// if not mc_bases then
44944: LD_EXP 77
44948: NOT
44949: IFFALSE 44953
// exit ;
44951: GO 45192
// for i = 1 to mc_bases do
44953: LD_ADDR_VAR 0 2
44957: PUSH
44958: DOUBLE
44959: LD_INT 1
44961: DEC
44962: ST_TO_ADDR
44963: LD_EXP 77
44967: PUSH
44968: FOR_TO
44969: IFFALSE 45190
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
44971: LD_ADDR_VAR 0 4
44975: PUSH
44976: LD_EXP 77
44980: PUSH
44981: LD_VAR 0 2
44985: ARRAY
44986: PPUSH
44987: LD_INT 21
44989: PUSH
44990: LD_INT 1
44992: PUSH
44993: EMPTY
44994: LIST
44995: LIST
44996: PPUSH
44997: CALL_OW 72
45001: PUSH
45002: LD_EXP 106
45006: PUSH
45007: LD_VAR 0 2
45011: ARRAY
45012: UNION
45013: ST_TO_ADDR
// if not tmp then
45014: LD_VAR 0 4
45018: NOT
45019: IFFALSE 45023
// continue ;
45021: GO 44968
// for j in tmp do
45023: LD_ADDR_VAR 0 3
45027: PUSH
45028: LD_VAR 0 4
45032: PUSH
45033: FOR_IN
45034: IFFALSE 45186
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45036: LD_VAR 0 3
45040: PPUSH
45041: CALL_OW 110
45045: NOT
45046: PUSH
45047: LD_VAR 0 3
45051: PPUSH
45052: CALL_OW 314
45056: NOT
45057: AND
45058: PUSH
45059: LD_VAR 0 3
45063: PPUSH
45064: CALL_OW 311
45068: NOT
45069: AND
45070: PUSH
45071: LD_VAR 0 3
45075: PPUSH
45076: CALL_OW 310
45080: NOT
45081: AND
45082: PUSH
45083: LD_VAR 0 3
45087: PUSH
45088: LD_EXP 80
45092: PUSH
45093: LD_VAR 0 2
45097: ARRAY
45098: PUSH
45099: LD_INT 1
45101: ARRAY
45102: IN
45103: NOT
45104: AND
45105: PUSH
45106: LD_VAR 0 3
45110: PUSH
45111: LD_EXP 80
45115: PUSH
45116: LD_VAR 0 2
45120: ARRAY
45121: PUSH
45122: LD_INT 2
45124: ARRAY
45125: IN
45126: NOT
45127: AND
45128: PUSH
45129: LD_VAR 0 3
45133: PUSH
45134: LD_EXP 89
45138: PUSH
45139: LD_VAR 0 2
45143: ARRAY
45144: IN
45145: NOT
45146: AND
45147: IFFALSE 45184
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45149: LD_VAR 0 2
45153: PPUSH
45154: LD_EXP 77
45158: PUSH
45159: LD_VAR 0 2
45163: ARRAY
45164: PPUSH
45165: LD_VAR 0 3
45169: PPUSH
45170: LD_VAR 0 3
45174: PPUSH
45175: CALL_OW 257
45179: PPUSH
45180: CALL 43956 0 4
// end ;
45184: GO 45033
45186: POP
45187: POP
// end ;
45188: GO 44968
45190: POP
45191: POP
// end ;
45192: LD_VAR 0 1
45196: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
45197: LD_INT 0
45199: PPUSH
45200: PPUSH
45201: PPUSH
45202: PPUSH
45203: PPUSH
45204: PPUSH
// if not mc_bases [ base ] then
45205: LD_EXP 77
45209: PUSH
45210: LD_VAR 0 1
45214: ARRAY
45215: NOT
45216: IFFALSE 45220
// exit ;
45218: GO 45402
// tmp := [ ] ;
45220: LD_ADDR_VAR 0 6
45224: PUSH
45225: EMPTY
45226: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
45227: LD_ADDR_VAR 0 7
45231: PUSH
45232: LD_VAR 0 3
45236: PPUSH
45237: LD_INT 0
45239: PPUSH
45240: CALL_OW 517
45244: ST_TO_ADDR
// if not list then
45245: LD_VAR 0 7
45249: NOT
45250: IFFALSE 45254
// exit ;
45252: GO 45402
// for i = 1 to amount do
45254: LD_ADDR_VAR 0 5
45258: PUSH
45259: DOUBLE
45260: LD_INT 1
45262: DEC
45263: ST_TO_ADDR
45264: LD_VAR 0 2
45268: PUSH
45269: FOR_TO
45270: IFFALSE 45350
// begin x := rand ( 1 , list [ 1 ] ) ;
45272: LD_ADDR_VAR 0 8
45276: PUSH
45277: LD_INT 1
45279: PPUSH
45280: LD_VAR 0 7
45284: PUSH
45285: LD_INT 1
45287: ARRAY
45288: PPUSH
45289: CALL_OW 12
45293: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
45294: LD_ADDR_VAR 0 6
45298: PUSH
45299: LD_VAR 0 6
45303: PPUSH
45304: LD_VAR 0 5
45308: PPUSH
45309: LD_VAR 0 7
45313: PUSH
45314: LD_INT 1
45316: ARRAY
45317: PUSH
45318: LD_VAR 0 8
45322: ARRAY
45323: PUSH
45324: LD_VAR 0 7
45328: PUSH
45329: LD_INT 2
45331: ARRAY
45332: PUSH
45333: LD_VAR 0 8
45337: ARRAY
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: PPUSH
45343: CALL_OW 1
45347: ST_TO_ADDR
// end ;
45348: GO 45269
45350: POP
45351: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
45352: LD_ADDR_EXP 90
45356: PUSH
45357: LD_EXP 90
45361: PPUSH
45362: LD_VAR 0 1
45366: PPUSH
45367: LD_VAR 0 6
45371: PPUSH
45372: CALL_OW 1
45376: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
45377: LD_ADDR_EXP 92
45381: PUSH
45382: LD_EXP 92
45386: PPUSH
45387: LD_VAR 0 1
45391: PPUSH
45392: LD_VAR 0 3
45396: PPUSH
45397: CALL_OW 1
45401: ST_TO_ADDR
// end ;
45402: LD_VAR 0 4
45406: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
45407: LD_INT 0
45409: PPUSH
// if not mc_bases [ base ] then
45410: LD_EXP 77
45414: PUSH
45415: LD_VAR 0 1
45419: ARRAY
45420: NOT
45421: IFFALSE 45425
// exit ;
45423: GO 45450
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
45425: LD_ADDR_EXP 82
45429: PUSH
45430: LD_EXP 82
45434: PPUSH
45435: LD_VAR 0 1
45439: PPUSH
45440: LD_VAR 0 2
45444: PPUSH
45445: CALL_OW 1
45449: ST_TO_ADDR
// end ;
45450: LD_VAR 0 3
45454: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
45455: LD_INT 0
45457: PPUSH
// if not mc_bases [ base ] then
45458: LD_EXP 77
45462: PUSH
45463: LD_VAR 0 1
45467: ARRAY
45468: NOT
45469: IFFALSE 45473
// exit ;
45471: GO 45510
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
45473: LD_ADDR_EXP 82
45477: PUSH
45478: LD_EXP 82
45482: PPUSH
45483: LD_VAR 0 1
45487: PPUSH
45488: LD_EXP 82
45492: PUSH
45493: LD_VAR 0 1
45497: ARRAY
45498: PUSH
45499: LD_VAR 0 2
45503: UNION
45504: PPUSH
45505: CALL_OW 1
45509: ST_TO_ADDR
// end ;
45510: LD_VAR 0 3
45514: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45515: LD_INT 0
45517: PPUSH
// if not mc_bases [ base ] then
45518: LD_EXP 77
45522: PUSH
45523: LD_VAR 0 1
45527: ARRAY
45528: NOT
45529: IFFALSE 45533
// exit ;
45531: GO 45558
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45533: LD_ADDR_EXP 98
45537: PUSH
45538: LD_EXP 98
45542: PPUSH
45543: LD_VAR 0 1
45547: PPUSH
45548: LD_VAR 0 2
45552: PPUSH
45553: CALL_OW 1
45557: ST_TO_ADDR
// end ;
45558: LD_VAR 0 3
45562: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45563: LD_INT 0
45565: PPUSH
// if not mc_bases [ base ] then
45566: LD_EXP 77
45570: PUSH
45571: LD_VAR 0 1
45575: ARRAY
45576: NOT
45577: IFFALSE 45581
// exit ;
45579: GO 45618
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45581: LD_ADDR_EXP 98
45585: PUSH
45586: LD_EXP 98
45590: PPUSH
45591: LD_VAR 0 1
45595: PPUSH
45596: LD_EXP 98
45600: PUSH
45601: LD_VAR 0 1
45605: ARRAY
45606: PUSH
45607: LD_VAR 0 2
45611: ADD
45612: PPUSH
45613: CALL_OW 1
45617: ST_TO_ADDR
// end ;
45618: LD_VAR 0 3
45622: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45623: LD_INT 0
45625: PPUSH
// if not mc_bases [ base ] then
45626: LD_EXP 77
45630: PUSH
45631: LD_VAR 0 1
45635: ARRAY
45636: NOT
45637: IFFALSE 45641
// exit ;
45639: GO 45695
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45641: LD_ADDR_EXP 99
45645: PUSH
45646: LD_EXP 99
45650: PPUSH
45651: LD_VAR 0 1
45655: PPUSH
45656: LD_VAR 0 2
45660: PPUSH
45661: CALL_OW 1
45665: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45666: LD_ADDR_EXP 88
45670: PUSH
45671: LD_EXP 88
45675: PPUSH
45676: LD_VAR 0 1
45680: PPUSH
45681: LD_VAR 0 2
45685: PUSH
45686: LD_INT 0
45688: PLUS
45689: PPUSH
45690: CALL_OW 1
45694: ST_TO_ADDR
// end ;
45695: LD_VAR 0 3
45699: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45700: LD_INT 0
45702: PPUSH
// if not mc_bases [ base ] then
45703: LD_EXP 77
45707: PUSH
45708: LD_VAR 0 1
45712: ARRAY
45713: NOT
45714: IFFALSE 45718
// exit ;
45716: GO 45743
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45718: LD_ADDR_EXP 88
45722: PUSH
45723: LD_EXP 88
45727: PPUSH
45728: LD_VAR 0 1
45732: PPUSH
45733: LD_VAR 0 2
45737: PPUSH
45738: CALL_OW 1
45742: ST_TO_ADDR
// end ;
45743: LD_VAR 0 3
45747: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45748: LD_INT 0
45750: PPUSH
45751: PPUSH
45752: PPUSH
45753: PPUSH
// if not mc_bases [ base ] then
45754: LD_EXP 77
45758: PUSH
45759: LD_VAR 0 1
45763: ARRAY
45764: NOT
45765: IFFALSE 45769
// exit ;
45767: GO 45834
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45769: LD_ADDR_EXP 97
45773: PUSH
45774: LD_EXP 97
45778: PPUSH
45779: LD_VAR 0 1
45783: PUSH
45784: LD_EXP 97
45788: PUSH
45789: LD_VAR 0 1
45793: ARRAY
45794: PUSH
45795: LD_INT 1
45797: PLUS
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: PPUSH
45803: LD_VAR 0 1
45807: PUSH
45808: LD_VAR 0 2
45812: PUSH
45813: LD_VAR 0 3
45817: PUSH
45818: LD_VAR 0 4
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: PPUSH
45829: CALL 57088 0 3
45833: ST_TO_ADDR
// end ;
45834: LD_VAR 0 5
45838: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45839: LD_INT 0
45841: PPUSH
// if not mc_bases [ base ] then
45842: LD_EXP 77
45846: PUSH
45847: LD_VAR 0 1
45851: ARRAY
45852: NOT
45853: IFFALSE 45857
// exit ;
45855: GO 45882
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45857: LD_ADDR_EXP 114
45861: PUSH
45862: LD_EXP 114
45866: PPUSH
45867: LD_VAR 0 1
45871: PPUSH
45872: LD_VAR 0 2
45876: PPUSH
45877: CALL_OW 1
45881: ST_TO_ADDR
// end ;
45882: LD_VAR 0 3
45886: RET
// export function MC_GetMinesField ( base ) ; begin
45887: LD_INT 0
45889: PPUSH
// result := mc_mines [ base ] ;
45890: LD_ADDR_VAR 0 2
45894: PUSH
45895: LD_EXP 90
45899: PUSH
45900: LD_VAR 0 1
45904: ARRAY
45905: ST_TO_ADDR
// end ;
45906: LD_VAR 0 2
45910: RET
// export function MC_GetProduceList ( base ) ; begin
45911: LD_INT 0
45913: PPUSH
// result := mc_produce [ base ] ;
45914: LD_ADDR_VAR 0 2
45918: PUSH
45919: LD_EXP 98
45923: PUSH
45924: LD_VAR 0 1
45928: ARRAY
45929: ST_TO_ADDR
// end ;
45930: LD_VAR 0 2
45934: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45935: LD_INT 0
45937: PPUSH
45938: PPUSH
// if not mc_bases then
45939: LD_EXP 77
45943: NOT
45944: IFFALSE 45948
// exit ;
45946: GO 46013
// if mc_bases [ base ] then
45948: LD_EXP 77
45952: PUSH
45953: LD_VAR 0 1
45957: ARRAY
45958: IFFALSE 46013
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45960: LD_ADDR_VAR 0 3
45964: PUSH
45965: LD_EXP 77
45969: PUSH
45970: LD_VAR 0 1
45974: ARRAY
45975: PPUSH
45976: LD_INT 30
45978: PUSH
45979: LD_VAR 0 2
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: PPUSH
45988: CALL_OW 72
45992: ST_TO_ADDR
// if result then
45993: LD_VAR 0 3
45997: IFFALSE 46013
// result := result [ 1 ] ;
45999: LD_ADDR_VAR 0 3
46003: PUSH
46004: LD_VAR 0 3
46008: PUSH
46009: LD_INT 1
46011: ARRAY
46012: ST_TO_ADDR
// end ; end ;
46013: LD_VAR 0 3
46017: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46018: LD_INT 0
46020: PPUSH
46021: PPUSH
// if not mc_bases then
46022: LD_EXP 77
46026: NOT
46027: IFFALSE 46031
// exit ;
46029: GO 46076
// if mc_bases [ base ] then
46031: LD_EXP 77
46035: PUSH
46036: LD_VAR 0 1
46040: ARRAY
46041: IFFALSE 46076
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46043: LD_ADDR_VAR 0 3
46047: PUSH
46048: LD_EXP 77
46052: PUSH
46053: LD_VAR 0 1
46057: ARRAY
46058: PPUSH
46059: LD_INT 30
46061: PUSH
46062: LD_VAR 0 2
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: PPUSH
46071: CALL_OW 72
46075: ST_TO_ADDR
// end ;
46076: LD_VAR 0 3
46080: RET
// export function MC_SetTame ( base , area ) ; begin
46081: LD_INT 0
46083: PPUSH
// if not mc_bases or not base then
46084: LD_EXP 77
46088: NOT
46089: PUSH
46090: LD_VAR 0 1
46094: NOT
46095: OR
46096: IFFALSE 46100
// exit ;
46098: GO 46125
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46100: LD_ADDR_EXP 105
46104: PUSH
46105: LD_EXP 105
46109: PPUSH
46110: LD_VAR 0 1
46114: PPUSH
46115: LD_VAR 0 2
46119: PPUSH
46120: CALL_OW 1
46124: ST_TO_ADDR
// end ;
46125: LD_VAR 0 3
46129: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46130: LD_INT 0
46132: PPUSH
46133: PPUSH
// if not mc_bases or not base then
46134: LD_EXP 77
46138: NOT
46139: PUSH
46140: LD_VAR 0 1
46144: NOT
46145: OR
46146: IFFALSE 46150
// exit ;
46148: GO 46252
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46150: LD_ADDR_VAR 0 4
46154: PUSH
46155: LD_EXP 77
46159: PUSH
46160: LD_VAR 0 1
46164: ARRAY
46165: PPUSH
46166: LD_INT 30
46168: PUSH
46169: LD_VAR 0 2
46173: PUSH
46174: EMPTY
46175: LIST
46176: LIST
46177: PPUSH
46178: CALL_OW 72
46182: ST_TO_ADDR
// if not tmp then
46183: LD_VAR 0 4
46187: NOT
46188: IFFALSE 46192
// exit ;
46190: GO 46252
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
46192: LD_ADDR_EXP 109
46196: PUSH
46197: LD_EXP 109
46201: PPUSH
46202: LD_VAR 0 1
46206: PPUSH
46207: LD_EXP 109
46211: PUSH
46212: LD_VAR 0 1
46216: ARRAY
46217: PPUSH
46218: LD_EXP 109
46222: PUSH
46223: LD_VAR 0 1
46227: ARRAY
46228: PUSH
46229: LD_INT 1
46231: PLUS
46232: PPUSH
46233: LD_VAR 0 4
46237: PUSH
46238: LD_INT 1
46240: ARRAY
46241: PPUSH
46242: CALL_OW 2
46246: PPUSH
46247: CALL_OW 1
46251: ST_TO_ADDR
// end ;
46252: LD_VAR 0 3
46256: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
46257: LD_INT 0
46259: PPUSH
46260: PPUSH
// if not mc_bases or not base or not kinds then
46261: LD_EXP 77
46265: NOT
46266: PUSH
46267: LD_VAR 0 1
46271: NOT
46272: OR
46273: PUSH
46274: LD_VAR 0 2
46278: NOT
46279: OR
46280: IFFALSE 46284
// exit ;
46282: GO 46345
// for i in kinds do
46284: LD_ADDR_VAR 0 4
46288: PUSH
46289: LD_VAR 0 2
46293: PUSH
46294: FOR_IN
46295: IFFALSE 46343
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
46297: LD_ADDR_EXP 111
46301: PUSH
46302: LD_EXP 111
46306: PPUSH
46307: LD_VAR 0 1
46311: PUSH
46312: LD_EXP 111
46316: PUSH
46317: LD_VAR 0 1
46321: ARRAY
46322: PUSH
46323: LD_INT 1
46325: PLUS
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: PPUSH
46331: LD_VAR 0 4
46335: PPUSH
46336: CALL 57088 0 3
46340: ST_TO_ADDR
46341: GO 46294
46343: POP
46344: POP
// end ;
46345: LD_VAR 0 3
46349: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
46350: LD_INT 0
46352: PPUSH
// if not mc_bases or not base or not areas then
46353: LD_EXP 77
46357: NOT
46358: PUSH
46359: LD_VAR 0 1
46363: NOT
46364: OR
46365: PUSH
46366: LD_VAR 0 2
46370: NOT
46371: OR
46372: IFFALSE 46376
// exit ;
46374: GO 46401
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
46376: LD_ADDR_EXP 95
46380: PUSH
46381: LD_EXP 95
46385: PPUSH
46386: LD_VAR 0 1
46390: PPUSH
46391: LD_VAR 0 2
46395: PPUSH
46396: CALL_OW 1
46400: ST_TO_ADDR
// end ;
46401: LD_VAR 0 3
46405: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
46406: LD_INT 0
46408: PPUSH
// if not mc_bases or not base or not teleports_exit then
46409: LD_EXP 77
46413: NOT
46414: PUSH
46415: LD_VAR 0 1
46419: NOT
46420: OR
46421: PUSH
46422: LD_VAR 0 2
46426: NOT
46427: OR
46428: IFFALSE 46432
// exit ;
46430: GO 46457
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
46432: LD_ADDR_EXP 112
46436: PUSH
46437: LD_EXP 112
46441: PPUSH
46442: LD_VAR 0 1
46446: PPUSH
46447: LD_VAR 0 2
46451: PPUSH
46452: CALL_OW 1
46456: ST_TO_ADDR
// end ;
46457: LD_VAR 0 3
46461: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
46462: LD_INT 0
46464: PPUSH
46465: PPUSH
46466: PPUSH
// if not mc_bases or not base or not ext_list then
46467: LD_EXP 77
46471: NOT
46472: PUSH
46473: LD_VAR 0 1
46477: NOT
46478: OR
46479: PUSH
46480: LD_VAR 0 5
46484: NOT
46485: OR
46486: IFFALSE 46490
// exit ;
46488: GO 46663
// tmp := GetFacExtXYD ( x , y , d ) ;
46490: LD_ADDR_VAR 0 8
46494: PUSH
46495: LD_VAR 0 2
46499: PPUSH
46500: LD_VAR 0 3
46504: PPUSH
46505: LD_VAR 0 4
46509: PPUSH
46510: CALL 87039 0 3
46514: ST_TO_ADDR
// if not tmp then
46515: LD_VAR 0 8
46519: NOT
46520: IFFALSE 46524
// exit ;
46522: GO 46663
// for i in tmp do
46524: LD_ADDR_VAR 0 7
46528: PUSH
46529: LD_VAR 0 8
46533: PUSH
46534: FOR_IN
46535: IFFALSE 46661
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46537: LD_ADDR_EXP 82
46541: PUSH
46542: LD_EXP 82
46546: PPUSH
46547: LD_VAR 0 1
46551: PPUSH
46552: LD_EXP 82
46556: PUSH
46557: LD_VAR 0 1
46561: ARRAY
46562: PPUSH
46563: LD_EXP 82
46567: PUSH
46568: LD_VAR 0 1
46572: ARRAY
46573: PUSH
46574: LD_INT 1
46576: PLUS
46577: PPUSH
46578: LD_VAR 0 5
46582: PUSH
46583: LD_INT 1
46585: ARRAY
46586: PUSH
46587: LD_VAR 0 7
46591: PUSH
46592: LD_INT 1
46594: ARRAY
46595: PUSH
46596: LD_VAR 0 7
46600: PUSH
46601: LD_INT 2
46603: ARRAY
46604: PUSH
46605: LD_VAR 0 7
46609: PUSH
46610: LD_INT 3
46612: ARRAY
46613: PUSH
46614: EMPTY
46615: LIST
46616: LIST
46617: LIST
46618: LIST
46619: PPUSH
46620: CALL_OW 2
46624: PPUSH
46625: CALL_OW 1
46629: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46630: LD_ADDR_VAR 0 5
46634: PUSH
46635: LD_VAR 0 5
46639: PPUSH
46640: LD_INT 1
46642: PPUSH
46643: CALL_OW 3
46647: ST_TO_ADDR
// if not ext_list then
46648: LD_VAR 0 5
46652: NOT
46653: IFFALSE 46659
// exit ;
46655: POP
46656: POP
46657: GO 46663
// end ;
46659: GO 46534
46661: POP
46662: POP
// end ;
46663: LD_VAR 0 6
46667: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46668: LD_INT 0
46670: PPUSH
// if not mc_bases or not base or not weapon_list then
46671: LD_EXP 77
46675: NOT
46676: PUSH
46677: LD_VAR 0 1
46681: NOT
46682: OR
46683: PUSH
46684: LD_VAR 0 2
46688: NOT
46689: OR
46690: IFFALSE 46694
// exit ;
46692: GO 46719
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46694: LD_ADDR_EXP 116
46698: PUSH
46699: LD_EXP 116
46703: PPUSH
46704: LD_VAR 0 1
46708: PPUSH
46709: LD_VAR 0 2
46713: PPUSH
46714: CALL_OW 1
46718: ST_TO_ADDR
// end ;
46719: LD_VAR 0 3
46723: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46724: LD_INT 0
46726: PPUSH
// if not mc_bases or not base or not tech_list then
46727: LD_EXP 77
46731: NOT
46732: PUSH
46733: LD_VAR 0 1
46737: NOT
46738: OR
46739: PUSH
46740: LD_VAR 0 2
46744: NOT
46745: OR
46746: IFFALSE 46750
// exit ;
46748: GO 46775
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46750: LD_ADDR_EXP 104
46754: PUSH
46755: LD_EXP 104
46759: PPUSH
46760: LD_VAR 0 1
46764: PPUSH
46765: LD_VAR 0 2
46769: PPUSH
46770: CALL_OW 1
46774: ST_TO_ADDR
// end ;
46775: LD_VAR 0 3
46779: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46780: LD_INT 0
46782: PPUSH
// if not mc_bases or not parking_area or not base then
46783: LD_EXP 77
46787: NOT
46788: PUSH
46789: LD_VAR 0 2
46793: NOT
46794: OR
46795: PUSH
46796: LD_VAR 0 1
46800: NOT
46801: OR
46802: IFFALSE 46806
// exit ;
46804: GO 46831
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46806: LD_ADDR_EXP 101
46810: PUSH
46811: LD_EXP 101
46815: PPUSH
46816: LD_VAR 0 1
46820: PPUSH
46821: LD_VAR 0 2
46825: PPUSH
46826: CALL_OW 1
46830: ST_TO_ADDR
// end ;
46831: LD_VAR 0 3
46835: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46836: LD_INT 0
46838: PPUSH
// if not mc_bases or not base or not scan_area then
46839: LD_EXP 77
46843: NOT
46844: PUSH
46845: LD_VAR 0 1
46849: NOT
46850: OR
46851: PUSH
46852: LD_VAR 0 2
46856: NOT
46857: OR
46858: IFFALSE 46862
// exit ;
46860: GO 46887
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46862: LD_ADDR_EXP 102
46866: PUSH
46867: LD_EXP 102
46871: PPUSH
46872: LD_VAR 0 1
46876: PPUSH
46877: LD_VAR 0 2
46881: PPUSH
46882: CALL_OW 1
46886: ST_TO_ADDR
// end ;
46887: LD_VAR 0 3
46891: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46892: LD_INT 0
46894: PPUSH
46895: PPUSH
// if not mc_bases or not base then
46896: LD_EXP 77
46900: NOT
46901: PUSH
46902: LD_VAR 0 1
46906: NOT
46907: OR
46908: IFFALSE 46912
// exit ;
46910: GO 46976
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46912: LD_ADDR_VAR 0 3
46916: PUSH
46917: LD_INT 1
46919: PUSH
46920: LD_INT 2
46922: PUSH
46923: LD_INT 3
46925: PUSH
46926: LD_INT 4
46928: PUSH
46929: LD_INT 11
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: LIST
46938: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46939: LD_ADDR_EXP 104
46943: PUSH
46944: LD_EXP 104
46948: PPUSH
46949: LD_VAR 0 1
46953: PPUSH
46954: LD_EXP 104
46958: PUSH
46959: LD_VAR 0 1
46963: ARRAY
46964: PUSH
46965: LD_VAR 0 3
46969: DIFF
46970: PPUSH
46971: CALL_OW 1
46975: ST_TO_ADDR
// end ;
46976: LD_VAR 0 2
46980: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
46981: LD_INT 0
46983: PPUSH
// result := mc_vehicles [ base ] ;
46984: LD_ADDR_VAR 0 3
46988: PUSH
46989: LD_EXP 96
46993: PUSH
46994: LD_VAR 0 1
46998: ARRAY
46999: ST_TO_ADDR
// if onlyCombat then
47000: LD_VAR 0 2
47004: IFFALSE 47176
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47006: LD_ADDR_VAR 0 3
47010: PUSH
47011: LD_VAR 0 3
47015: PUSH
47016: LD_VAR 0 3
47020: PPUSH
47021: LD_INT 2
47023: PUSH
47024: LD_INT 34
47026: PUSH
47027: LD_INT 12
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: LD_INT 34
47036: PUSH
47037: LD_INT 51
47039: PUSH
47040: EMPTY
47041: LIST
47042: LIST
47043: PUSH
47044: LD_INT 34
47046: PUSH
47047: LD_INT 89
47049: PUSH
47050: EMPTY
47051: LIST
47052: LIST
47053: PUSH
47054: LD_INT 34
47056: PUSH
47057: LD_INT 32
47059: PUSH
47060: EMPTY
47061: LIST
47062: LIST
47063: PUSH
47064: LD_INT 34
47066: PUSH
47067: LD_INT 13
47069: PUSH
47070: EMPTY
47071: LIST
47072: LIST
47073: PUSH
47074: LD_INT 34
47076: PUSH
47077: LD_INT 52
47079: PUSH
47080: EMPTY
47081: LIST
47082: LIST
47083: PUSH
47084: LD_INT 34
47086: PUSH
47087: LD_INT 88
47089: PUSH
47090: EMPTY
47091: LIST
47092: LIST
47093: PUSH
47094: LD_INT 34
47096: PUSH
47097: LD_INT 14
47099: PUSH
47100: EMPTY
47101: LIST
47102: LIST
47103: PUSH
47104: LD_INT 34
47106: PUSH
47107: LD_INT 53
47109: PUSH
47110: EMPTY
47111: LIST
47112: LIST
47113: PUSH
47114: LD_INT 34
47116: PUSH
47117: LD_INT 98
47119: PUSH
47120: EMPTY
47121: LIST
47122: LIST
47123: PUSH
47124: LD_INT 34
47126: PUSH
47127: LD_INT 31
47129: PUSH
47130: EMPTY
47131: LIST
47132: LIST
47133: PUSH
47134: LD_INT 34
47136: PUSH
47137: LD_INT 48
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: PUSH
47144: LD_INT 34
47146: PUSH
47147: LD_INT 8
47149: PUSH
47150: EMPTY
47151: LIST
47152: LIST
47153: PUSH
47154: EMPTY
47155: LIST
47156: LIST
47157: LIST
47158: LIST
47159: LIST
47160: LIST
47161: LIST
47162: LIST
47163: LIST
47164: LIST
47165: LIST
47166: LIST
47167: LIST
47168: LIST
47169: PPUSH
47170: CALL_OW 72
47174: DIFF
47175: ST_TO_ADDR
// end ; end_of_file
47176: LD_VAR 0 3
47180: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
47181: LD_INT 0
47183: PPUSH
47184: PPUSH
47185: PPUSH
// if not mc_bases or not skirmish then
47186: LD_EXP 77
47190: NOT
47191: PUSH
47192: LD_EXP 75
47196: NOT
47197: OR
47198: IFFALSE 47202
// exit ;
47200: GO 47367
// for i = 1 to mc_bases do
47202: LD_ADDR_VAR 0 4
47206: PUSH
47207: DOUBLE
47208: LD_INT 1
47210: DEC
47211: ST_TO_ADDR
47212: LD_EXP 77
47216: PUSH
47217: FOR_TO
47218: IFFALSE 47365
// begin if sci in mc_bases [ i ] then
47220: LD_VAR 0 2
47224: PUSH
47225: LD_EXP 77
47229: PUSH
47230: LD_VAR 0 4
47234: ARRAY
47235: IN
47236: IFFALSE 47363
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
47238: LD_ADDR_EXP 106
47242: PUSH
47243: LD_EXP 106
47247: PPUSH
47248: LD_VAR 0 4
47252: PUSH
47253: LD_EXP 106
47257: PUSH
47258: LD_VAR 0 4
47262: ARRAY
47263: PUSH
47264: LD_INT 1
47266: PLUS
47267: PUSH
47268: EMPTY
47269: LIST
47270: LIST
47271: PPUSH
47272: LD_VAR 0 1
47276: PPUSH
47277: CALL 57088 0 3
47281: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
47282: LD_ADDR_VAR 0 5
47286: PUSH
47287: LD_EXP 77
47291: PUSH
47292: LD_VAR 0 4
47296: ARRAY
47297: PPUSH
47298: LD_INT 2
47300: PUSH
47301: LD_INT 30
47303: PUSH
47304: LD_INT 0
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: PUSH
47311: LD_INT 30
47313: PUSH
47314: LD_INT 1
47316: PUSH
47317: EMPTY
47318: LIST
47319: LIST
47320: PUSH
47321: EMPTY
47322: LIST
47323: LIST
47324: LIST
47325: PPUSH
47326: CALL_OW 72
47330: PPUSH
47331: LD_VAR 0 1
47335: PPUSH
47336: CALL_OW 74
47340: ST_TO_ADDR
// if tmp then
47341: LD_VAR 0 5
47345: IFFALSE 47361
// ComStandNearbyBuilding ( ape , tmp ) ;
47347: LD_VAR 0 1
47351: PPUSH
47352: LD_VAR 0 5
47356: PPUSH
47357: CALL 53515 0 2
// break ;
47361: GO 47365
// end ; end ;
47363: GO 47217
47365: POP
47366: POP
// end ;
47367: LD_VAR 0 3
47371: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
47372: LD_INT 0
47374: PPUSH
47375: PPUSH
47376: PPUSH
// if not mc_bases or not skirmish then
47377: LD_EXP 77
47381: NOT
47382: PUSH
47383: LD_EXP 75
47387: NOT
47388: OR
47389: IFFALSE 47393
// exit ;
47391: GO 47482
// for i = 1 to mc_bases do
47393: LD_ADDR_VAR 0 4
47397: PUSH
47398: DOUBLE
47399: LD_INT 1
47401: DEC
47402: ST_TO_ADDR
47403: LD_EXP 77
47407: PUSH
47408: FOR_TO
47409: IFFALSE 47480
// begin if building in mc_busy_turret_list [ i ] then
47411: LD_VAR 0 1
47415: PUSH
47416: LD_EXP 87
47420: PUSH
47421: LD_VAR 0 4
47425: ARRAY
47426: IN
47427: IFFALSE 47478
// begin tmp := mc_busy_turret_list [ i ] diff building ;
47429: LD_ADDR_VAR 0 5
47433: PUSH
47434: LD_EXP 87
47438: PUSH
47439: LD_VAR 0 4
47443: ARRAY
47444: PUSH
47445: LD_VAR 0 1
47449: DIFF
47450: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
47451: LD_ADDR_EXP 87
47455: PUSH
47456: LD_EXP 87
47460: PPUSH
47461: LD_VAR 0 4
47465: PPUSH
47466: LD_VAR 0 5
47470: PPUSH
47471: CALL_OW 1
47475: ST_TO_ADDR
// break ;
47476: GO 47480
// end ; end ;
47478: GO 47408
47480: POP
47481: POP
// end ;
47482: LD_VAR 0 3
47486: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47487: LD_INT 0
47489: PPUSH
47490: PPUSH
47491: PPUSH
// if not mc_bases or not skirmish then
47492: LD_EXP 77
47496: NOT
47497: PUSH
47498: LD_EXP 75
47502: NOT
47503: OR
47504: IFFALSE 47508
// exit ;
47506: GO 47707
// for i = 1 to mc_bases do
47508: LD_ADDR_VAR 0 5
47512: PUSH
47513: DOUBLE
47514: LD_INT 1
47516: DEC
47517: ST_TO_ADDR
47518: LD_EXP 77
47522: PUSH
47523: FOR_TO
47524: IFFALSE 47705
// if building in mc_bases [ i ] then
47526: LD_VAR 0 1
47530: PUSH
47531: LD_EXP 77
47535: PUSH
47536: LD_VAR 0 5
47540: ARRAY
47541: IN
47542: IFFALSE 47703
// begin tmp := mc_bases [ i ] diff building ;
47544: LD_ADDR_VAR 0 6
47548: PUSH
47549: LD_EXP 77
47553: PUSH
47554: LD_VAR 0 5
47558: ARRAY
47559: PUSH
47560: LD_VAR 0 1
47564: DIFF
47565: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47566: LD_ADDR_EXP 77
47570: PUSH
47571: LD_EXP 77
47575: PPUSH
47576: LD_VAR 0 5
47580: PPUSH
47581: LD_VAR 0 6
47585: PPUSH
47586: CALL_OW 1
47590: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47591: LD_VAR 0 1
47595: PUSH
47596: LD_EXP 85
47600: PUSH
47601: LD_VAR 0 5
47605: ARRAY
47606: IN
47607: IFFALSE 47646
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47609: LD_ADDR_EXP 85
47613: PUSH
47614: LD_EXP 85
47618: PPUSH
47619: LD_VAR 0 5
47623: PPUSH
47624: LD_EXP 85
47628: PUSH
47629: LD_VAR 0 5
47633: ARRAY
47634: PUSH
47635: LD_VAR 0 1
47639: DIFF
47640: PPUSH
47641: CALL_OW 1
47645: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47646: LD_VAR 0 1
47650: PUSH
47651: LD_EXP 86
47655: PUSH
47656: LD_VAR 0 5
47660: ARRAY
47661: IN
47662: IFFALSE 47701
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47664: LD_ADDR_EXP 86
47668: PUSH
47669: LD_EXP 86
47673: PPUSH
47674: LD_VAR 0 5
47678: PPUSH
47679: LD_EXP 86
47683: PUSH
47684: LD_VAR 0 5
47688: ARRAY
47689: PUSH
47690: LD_VAR 0 1
47694: DIFF
47695: PPUSH
47696: CALL_OW 1
47700: ST_TO_ADDR
// break ;
47701: GO 47705
// end ;
47703: GO 47523
47705: POP
47706: POP
// end ;
47707: LD_VAR 0 4
47711: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47712: LD_INT 0
47714: PPUSH
47715: PPUSH
47716: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47717: LD_EXP 77
47721: NOT
47722: PUSH
47723: LD_EXP 75
47727: NOT
47728: OR
47729: PUSH
47730: LD_VAR 0 3
47734: PUSH
47735: LD_EXP 103
47739: IN
47740: NOT
47741: OR
47742: IFFALSE 47746
// exit ;
47744: GO 47869
// for i = 1 to mc_vehicles do
47746: LD_ADDR_VAR 0 6
47750: PUSH
47751: DOUBLE
47752: LD_INT 1
47754: DEC
47755: ST_TO_ADDR
47756: LD_EXP 96
47760: PUSH
47761: FOR_TO
47762: IFFALSE 47867
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47764: LD_VAR 0 2
47768: PUSH
47769: LD_EXP 96
47773: PUSH
47774: LD_VAR 0 6
47778: ARRAY
47779: IN
47780: PUSH
47781: LD_VAR 0 1
47785: PUSH
47786: LD_EXP 96
47790: PUSH
47791: LD_VAR 0 6
47795: ARRAY
47796: IN
47797: OR
47798: IFFALSE 47865
// begin tmp := mc_vehicles [ i ] diff old ;
47800: LD_ADDR_VAR 0 7
47804: PUSH
47805: LD_EXP 96
47809: PUSH
47810: LD_VAR 0 6
47814: ARRAY
47815: PUSH
47816: LD_VAR 0 2
47820: DIFF
47821: ST_TO_ADDR
// tmp := tmp diff new ;
47822: LD_ADDR_VAR 0 7
47826: PUSH
47827: LD_VAR 0 7
47831: PUSH
47832: LD_VAR 0 1
47836: DIFF
47837: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47838: LD_ADDR_EXP 96
47842: PUSH
47843: LD_EXP 96
47847: PPUSH
47848: LD_VAR 0 6
47852: PPUSH
47853: LD_VAR 0 7
47857: PPUSH
47858: CALL_OW 1
47862: ST_TO_ADDR
// break ;
47863: GO 47867
// end ;
47865: GO 47761
47867: POP
47868: POP
// end ;
47869: LD_VAR 0 5
47873: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47874: LD_INT 0
47876: PPUSH
47877: PPUSH
47878: PPUSH
47879: PPUSH
// if not mc_bases or not skirmish then
47880: LD_EXP 77
47884: NOT
47885: PUSH
47886: LD_EXP 75
47890: NOT
47891: OR
47892: IFFALSE 47896
// exit ;
47894: GO 48278
// side := GetSide ( vehicle ) ;
47896: LD_ADDR_VAR 0 5
47900: PUSH
47901: LD_VAR 0 1
47905: PPUSH
47906: CALL_OW 255
47910: ST_TO_ADDR
// for i = 1 to mc_bases do
47911: LD_ADDR_VAR 0 4
47915: PUSH
47916: DOUBLE
47917: LD_INT 1
47919: DEC
47920: ST_TO_ADDR
47921: LD_EXP 77
47925: PUSH
47926: FOR_TO
47927: IFFALSE 48276
// begin if factory in mc_bases [ i ] then
47929: LD_VAR 0 2
47933: PUSH
47934: LD_EXP 77
47938: PUSH
47939: LD_VAR 0 4
47943: ARRAY
47944: IN
47945: IFFALSE 48274
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
47947: LD_EXP 99
47951: PUSH
47952: LD_VAR 0 4
47956: ARRAY
47957: PUSH
47958: LD_EXP 88
47962: PUSH
47963: LD_VAR 0 4
47967: ARRAY
47968: LESS
47969: PUSH
47970: LD_VAR 0 1
47974: PPUSH
47975: CALL_OW 264
47979: PUSH
47980: LD_INT 31
47982: PUSH
47983: LD_INT 32
47985: PUSH
47986: LD_INT 51
47988: PUSH
47989: LD_INT 89
47991: PUSH
47992: LD_INT 12
47994: PUSH
47995: LD_INT 30
47997: PUSH
47998: LD_INT 98
48000: PUSH
48001: LD_INT 11
48003: PUSH
48004: LD_INT 53
48006: PUSH
48007: LD_INT 14
48009: PUSH
48010: LD_INT 91
48012: PUSH
48013: LD_INT 29
48015: PUSH
48016: LD_INT 99
48018: PUSH
48019: LD_INT 13
48021: PUSH
48022: LD_INT 52
48024: PUSH
48025: LD_INT 88
48027: PUSH
48028: LD_INT 48
48030: PUSH
48031: LD_INT 8
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: LIST
48038: LIST
48039: LIST
48040: LIST
48041: LIST
48042: LIST
48043: LIST
48044: LIST
48045: LIST
48046: LIST
48047: LIST
48048: LIST
48049: LIST
48050: LIST
48051: LIST
48052: LIST
48053: IN
48054: NOT
48055: AND
48056: IFFALSE 48104
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48058: LD_ADDR_EXP 99
48062: PUSH
48063: LD_EXP 99
48067: PPUSH
48068: LD_VAR 0 4
48072: PUSH
48073: LD_EXP 99
48077: PUSH
48078: LD_VAR 0 4
48082: ARRAY
48083: PUSH
48084: LD_INT 1
48086: PLUS
48087: PUSH
48088: EMPTY
48089: LIST
48090: LIST
48091: PPUSH
48092: LD_VAR 0 1
48096: PPUSH
48097: CALL 57088 0 3
48101: ST_TO_ADDR
48102: GO 48148
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48104: LD_ADDR_EXP 96
48108: PUSH
48109: LD_EXP 96
48113: PPUSH
48114: LD_VAR 0 4
48118: PUSH
48119: LD_EXP 96
48123: PUSH
48124: LD_VAR 0 4
48128: ARRAY
48129: PUSH
48130: LD_INT 1
48132: PLUS
48133: PUSH
48134: EMPTY
48135: LIST
48136: LIST
48137: PPUSH
48138: LD_VAR 0 1
48142: PPUSH
48143: CALL 57088 0 3
48147: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
48148: LD_VAR 0 1
48152: PPUSH
48153: CALL_OW 263
48157: PUSH
48158: LD_INT 2
48160: EQUAL
48161: IFFALSE 48190
// begin repeat wait ( 0 0$3 ) ;
48163: LD_INT 105
48165: PPUSH
48166: CALL_OW 67
// Connect ( vehicle ) ;
48170: LD_VAR 0 1
48174: PPUSH
48175: CALL 60057 0 1
// until IsControledBy ( vehicle ) ;
48179: LD_VAR 0 1
48183: PPUSH
48184: CALL_OW 312
48188: IFFALSE 48163
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
48190: LD_VAR 0 1
48194: PPUSH
48195: LD_EXP 101
48199: PUSH
48200: LD_VAR 0 4
48204: ARRAY
48205: PPUSH
48206: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
48210: LD_VAR 0 1
48214: PPUSH
48215: CALL_OW 263
48219: PUSH
48220: LD_INT 1
48222: NONEQUAL
48223: IFFALSE 48227
// break ;
48225: GO 48276
// repeat wait ( 0 0$1 ) ;
48227: LD_INT 35
48229: PPUSH
48230: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
48234: LD_VAR 0 1
48238: PPUSH
48239: LD_EXP 101
48243: PUSH
48244: LD_VAR 0 4
48248: ARRAY
48249: PPUSH
48250: CALL_OW 308
48254: IFFALSE 48227
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
48256: LD_VAR 0 1
48260: PPUSH
48261: CALL_OW 311
48265: PPUSH
48266: CALL_OW 121
// exit ;
48270: POP
48271: POP
48272: GO 48278
// end ; end ;
48274: GO 47926
48276: POP
48277: POP
// end ;
48278: LD_VAR 0 3
48282: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
48283: LD_INT 0
48285: PPUSH
48286: PPUSH
48287: PPUSH
48288: PPUSH
// if not mc_bases or not skirmish then
48289: LD_EXP 77
48293: NOT
48294: PUSH
48295: LD_EXP 75
48299: NOT
48300: OR
48301: IFFALSE 48305
// exit ;
48303: GO 48658
// repeat wait ( 0 0$1 ) ;
48305: LD_INT 35
48307: PPUSH
48308: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
48312: LD_VAR 0 2
48316: PPUSH
48317: LD_VAR 0 3
48321: PPUSH
48322: CALL_OW 284
48326: IFFALSE 48305
// if GetResourceTypeXY ( x , y ) = mat_artefact then
48328: LD_VAR 0 2
48332: PPUSH
48333: LD_VAR 0 3
48337: PPUSH
48338: CALL_OW 283
48342: PUSH
48343: LD_INT 4
48345: EQUAL
48346: IFFALSE 48350
// exit ;
48348: GO 48658
// for i = 1 to mc_bases do
48350: LD_ADDR_VAR 0 7
48354: PUSH
48355: DOUBLE
48356: LD_INT 1
48358: DEC
48359: ST_TO_ADDR
48360: LD_EXP 77
48364: PUSH
48365: FOR_TO
48366: IFFALSE 48656
// begin if mc_crates_area [ i ] then
48368: LD_EXP 95
48372: PUSH
48373: LD_VAR 0 7
48377: ARRAY
48378: IFFALSE 48489
// for j in mc_crates_area [ i ] do
48380: LD_ADDR_VAR 0 8
48384: PUSH
48385: LD_EXP 95
48389: PUSH
48390: LD_VAR 0 7
48394: ARRAY
48395: PUSH
48396: FOR_IN
48397: IFFALSE 48487
// if InArea ( x , y , j ) then
48399: LD_VAR 0 2
48403: PPUSH
48404: LD_VAR 0 3
48408: PPUSH
48409: LD_VAR 0 8
48413: PPUSH
48414: CALL_OW 309
48418: IFFALSE 48485
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48420: LD_ADDR_EXP 93
48424: PUSH
48425: LD_EXP 93
48429: PPUSH
48430: LD_VAR 0 7
48434: PUSH
48435: LD_EXP 93
48439: PUSH
48440: LD_VAR 0 7
48444: ARRAY
48445: PUSH
48446: LD_INT 1
48448: PLUS
48449: PUSH
48450: EMPTY
48451: LIST
48452: LIST
48453: PPUSH
48454: LD_VAR 0 4
48458: PUSH
48459: LD_VAR 0 2
48463: PUSH
48464: LD_VAR 0 3
48468: PUSH
48469: EMPTY
48470: LIST
48471: LIST
48472: LIST
48473: PPUSH
48474: CALL 57088 0 3
48478: ST_TO_ADDR
// exit ;
48479: POP
48480: POP
48481: POP
48482: POP
48483: GO 48658
// end ;
48485: GO 48396
48487: POP
48488: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48489: LD_ADDR_VAR 0 9
48493: PUSH
48494: LD_EXP 77
48498: PUSH
48499: LD_VAR 0 7
48503: ARRAY
48504: PPUSH
48505: LD_INT 2
48507: PUSH
48508: LD_INT 30
48510: PUSH
48511: LD_INT 0
48513: PUSH
48514: EMPTY
48515: LIST
48516: LIST
48517: PUSH
48518: LD_INT 30
48520: PUSH
48521: LD_INT 1
48523: PUSH
48524: EMPTY
48525: LIST
48526: LIST
48527: PUSH
48528: EMPTY
48529: LIST
48530: LIST
48531: LIST
48532: PPUSH
48533: CALL_OW 72
48537: ST_TO_ADDR
// if not depot then
48538: LD_VAR 0 9
48542: NOT
48543: IFFALSE 48547
// continue ;
48545: GO 48365
// for j in depot do
48547: LD_ADDR_VAR 0 8
48551: PUSH
48552: LD_VAR 0 9
48556: PUSH
48557: FOR_IN
48558: IFFALSE 48652
// if GetDistUnitXY ( j , x , y ) < 30 then
48560: LD_VAR 0 8
48564: PPUSH
48565: LD_VAR 0 2
48569: PPUSH
48570: LD_VAR 0 3
48574: PPUSH
48575: CALL_OW 297
48579: PUSH
48580: LD_INT 30
48582: LESS
48583: IFFALSE 48650
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48585: LD_ADDR_EXP 93
48589: PUSH
48590: LD_EXP 93
48594: PPUSH
48595: LD_VAR 0 7
48599: PUSH
48600: LD_EXP 93
48604: PUSH
48605: LD_VAR 0 7
48609: ARRAY
48610: PUSH
48611: LD_INT 1
48613: PLUS
48614: PUSH
48615: EMPTY
48616: LIST
48617: LIST
48618: PPUSH
48619: LD_VAR 0 4
48623: PUSH
48624: LD_VAR 0 2
48628: PUSH
48629: LD_VAR 0 3
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: LIST
48638: PPUSH
48639: CALL 57088 0 3
48643: ST_TO_ADDR
// exit ;
48644: POP
48645: POP
48646: POP
48647: POP
48648: GO 48658
// end ;
48650: GO 48557
48652: POP
48653: POP
// end ;
48654: GO 48365
48656: POP
48657: POP
// end ;
48658: LD_VAR 0 6
48662: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48663: LD_INT 0
48665: PPUSH
48666: PPUSH
48667: PPUSH
48668: PPUSH
// if not mc_bases or not skirmish then
48669: LD_EXP 77
48673: NOT
48674: PUSH
48675: LD_EXP 75
48679: NOT
48680: OR
48681: IFFALSE 48685
// exit ;
48683: GO 48962
// side := GetSide ( lab ) ;
48685: LD_ADDR_VAR 0 4
48689: PUSH
48690: LD_VAR 0 2
48694: PPUSH
48695: CALL_OW 255
48699: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48700: LD_VAR 0 4
48704: PUSH
48705: LD_EXP 103
48709: IN
48710: NOT
48711: PUSH
48712: LD_EXP 104
48716: NOT
48717: OR
48718: PUSH
48719: LD_EXP 77
48723: NOT
48724: OR
48725: IFFALSE 48729
// exit ;
48727: GO 48962
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48729: LD_ADDR_EXP 104
48733: PUSH
48734: LD_EXP 104
48738: PPUSH
48739: LD_VAR 0 4
48743: PPUSH
48744: LD_EXP 104
48748: PUSH
48749: LD_VAR 0 4
48753: ARRAY
48754: PUSH
48755: LD_VAR 0 1
48759: DIFF
48760: PPUSH
48761: CALL_OW 1
48765: ST_TO_ADDR
// for i = 1 to mc_bases do
48766: LD_ADDR_VAR 0 5
48770: PUSH
48771: DOUBLE
48772: LD_INT 1
48774: DEC
48775: ST_TO_ADDR
48776: LD_EXP 77
48780: PUSH
48781: FOR_TO
48782: IFFALSE 48960
// begin if lab in mc_bases [ i ] then
48784: LD_VAR 0 2
48788: PUSH
48789: LD_EXP 77
48793: PUSH
48794: LD_VAR 0 5
48798: ARRAY
48799: IN
48800: IFFALSE 48958
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48802: LD_VAR 0 1
48806: PUSH
48807: LD_INT 11
48809: PUSH
48810: LD_INT 4
48812: PUSH
48813: LD_INT 3
48815: PUSH
48816: LD_INT 2
48818: PUSH
48819: EMPTY
48820: LIST
48821: LIST
48822: LIST
48823: LIST
48824: IN
48825: PUSH
48826: LD_EXP 107
48830: PUSH
48831: LD_VAR 0 5
48835: ARRAY
48836: AND
48837: IFFALSE 48958
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48839: LD_ADDR_VAR 0 6
48843: PUSH
48844: LD_EXP 107
48848: PUSH
48849: LD_VAR 0 5
48853: ARRAY
48854: PUSH
48855: LD_INT 1
48857: ARRAY
48858: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48859: LD_ADDR_EXP 107
48863: PUSH
48864: LD_EXP 107
48868: PPUSH
48869: LD_VAR 0 5
48873: PPUSH
48874: EMPTY
48875: PPUSH
48876: CALL_OW 1
48880: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48881: LD_VAR 0 6
48885: PPUSH
48886: LD_INT 0
48888: PPUSH
48889: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48893: LD_VAR 0 6
48897: PPUSH
48898: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48902: LD_ADDR_EXP 106
48906: PUSH
48907: LD_EXP 106
48911: PPUSH
48912: LD_VAR 0 5
48916: PPUSH
48917: LD_EXP 106
48921: PUSH
48922: LD_VAR 0 5
48926: ARRAY
48927: PPUSH
48928: LD_INT 1
48930: PPUSH
48931: LD_VAR 0 6
48935: PPUSH
48936: CALL_OW 2
48940: PPUSH
48941: CALL_OW 1
48945: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
48946: LD_VAR 0 5
48950: PPUSH
48951: LD_INT 112
48953: PPUSH
48954: CALL 25448 0 2
// end ; end ; end ;
48958: GO 48781
48960: POP
48961: POP
// end ;
48962: LD_VAR 0 3
48966: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
48967: LD_INT 0
48969: PPUSH
48970: PPUSH
48971: PPUSH
48972: PPUSH
48973: PPUSH
48974: PPUSH
48975: PPUSH
48976: PPUSH
// if not mc_bases or not skirmish then
48977: LD_EXP 77
48981: NOT
48982: PUSH
48983: LD_EXP 75
48987: NOT
48988: OR
48989: IFFALSE 48993
// exit ;
48991: GO 50362
// for i = 1 to mc_bases do
48993: LD_ADDR_VAR 0 3
48997: PUSH
48998: DOUBLE
48999: LD_INT 1
49001: DEC
49002: ST_TO_ADDR
49003: LD_EXP 77
49007: PUSH
49008: FOR_TO
49009: IFFALSE 50360
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49011: LD_VAR 0 1
49015: PUSH
49016: LD_EXP 77
49020: PUSH
49021: LD_VAR 0 3
49025: ARRAY
49026: IN
49027: PUSH
49028: LD_VAR 0 1
49032: PUSH
49033: LD_EXP 84
49037: PUSH
49038: LD_VAR 0 3
49042: ARRAY
49043: IN
49044: OR
49045: PUSH
49046: LD_VAR 0 1
49050: PUSH
49051: LD_EXP 99
49055: PUSH
49056: LD_VAR 0 3
49060: ARRAY
49061: IN
49062: OR
49063: PUSH
49064: LD_VAR 0 1
49068: PUSH
49069: LD_EXP 96
49073: PUSH
49074: LD_VAR 0 3
49078: ARRAY
49079: IN
49080: OR
49081: PUSH
49082: LD_VAR 0 1
49086: PUSH
49087: LD_EXP 106
49091: PUSH
49092: LD_VAR 0 3
49096: ARRAY
49097: IN
49098: OR
49099: PUSH
49100: LD_VAR 0 1
49104: PUSH
49105: LD_EXP 107
49109: PUSH
49110: LD_VAR 0 3
49114: ARRAY
49115: IN
49116: OR
49117: IFFALSE 50358
// begin if un in mc_ape [ i ] then
49119: LD_VAR 0 1
49123: PUSH
49124: LD_EXP 106
49128: PUSH
49129: LD_VAR 0 3
49133: ARRAY
49134: IN
49135: IFFALSE 49174
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49137: LD_ADDR_EXP 106
49141: PUSH
49142: LD_EXP 106
49146: PPUSH
49147: LD_VAR 0 3
49151: PPUSH
49152: LD_EXP 106
49156: PUSH
49157: LD_VAR 0 3
49161: ARRAY
49162: PUSH
49163: LD_VAR 0 1
49167: DIFF
49168: PPUSH
49169: CALL_OW 1
49173: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
49174: LD_VAR 0 1
49178: PUSH
49179: LD_EXP 107
49183: PUSH
49184: LD_VAR 0 3
49188: ARRAY
49189: IN
49190: IFFALSE 49214
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49192: LD_ADDR_EXP 107
49196: PUSH
49197: LD_EXP 107
49201: PPUSH
49202: LD_VAR 0 3
49206: PPUSH
49207: EMPTY
49208: PPUSH
49209: CALL_OW 1
49213: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
49214: LD_VAR 0 1
49218: PPUSH
49219: CALL_OW 247
49223: PUSH
49224: LD_INT 2
49226: EQUAL
49227: PUSH
49228: LD_VAR 0 1
49232: PPUSH
49233: CALL_OW 110
49237: PUSH
49238: LD_INT 20
49240: EQUAL
49241: PUSH
49242: LD_VAR 0 1
49246: PUSH
49247: LD_EXP 99
49251: PUSH
49252: LD_VAR 0 3
49256: ARRAY
49257: IN
49258: OR
49259: PUSH
49260: LD_VAR 0 1
49264: PPUSH
49265: CALL_OW 264
49269: PUSH
49270: LD_INT 12
49272: PUSH
49273: LD_INT 51
49275: PUSH
49276: LD_INT 89
49278: PUSH
49279: LD_INT 32
49281: PUSH
49282: LD_INT 13
49284: PUSH
49285: LD_INT 52
49287: PUSH
49288: LD_INT 31
49290: PUSH
49291: EMPTY
49292: LIST
49293: LIST
49294: LIST
49295: LIST
49296: LIST
49297: LIST
49298: LIST
49299: IN
49300: OR
49301: AND
49302: IFFALSE 49610
// begin if un in mc_defender [ i ] then
49304: LD_VAR 0 1
49308: PUSH
49309: LD_EXP 99
49313: PUSH
49314: LD_VAR 0 3
49318: ARRAY
49319: IN
49320: IFFALSE 49359
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49322: LD_ADDR_EXP 99
49326: PUSH
49327: LD_EXP 99
49331: PPUSH
49332: LD_VAR 0 3
49336: PPUSH
49337: LD_EXP 99
49341: PUSH
49342: LD_VAR 0 3
49346: ARRAY
49347: PUSH
49348: LD_VAR 0 1
49352: DIFF
49353: PPUSH
49354: CALL_OW 1
49358: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
49359: LD_ADDR_VAR 0 8
49363: PUSH
49364: LD_VAR 0 3
49368: PPUSH
49369: LD_INT 3
49371: PPUSH
49372: CALL 46018 0 2
49376: ST_TO_ADDR
// if fac then
49377: LD_VAR 0 8
49381: IFFALSE 49610
// begin for j in fac do
49383: LD_ADDR_VAR 0 4
49387: PUSH
49388: LD_VAR 0 8
49392: PUSH
49393: FOR_IN
49394: IFFALSE 49608
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
49396: LD_ADDR_VAR 0 9
49400: PUSH
49401: LD_VAR 0 8
49405: PPUSH
49406: LD_VAR 0 1
49410: PPUSH
49411: CALL_OW 265
49415: PPUSH
49416: LD_VAR 0 1
49420: PPUSH
49421: CALL_OW 262
49425: PPUSH
49426: LD_VAR 0 1
49430: PPUSH
49431: CALL_OW 263
49435: PPUSH
49436: LD_VAR 0 1
49440: PPUSH
49441: CALL_OW 264
49445: PPUSH
49446: CALL 54586 0 5
49450: ST_TO_ADDR
// if components then
49451: LD_VAR 0 9
49455: IFFALSE 49606
// begin if GetWeapon ( un ) = ar_control_tower then
49457: LD_VAR 0 1
49461: PPUSH
49462: CALL_OW 264
49466: PUSH
49467: LD_INT 31
49469: EQUAL
49470: IFFALSE 49587
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49472: LD_VAR 0 1
49476: PPUSH
49477: CALL_OW 311
49481: PPUSH
49482: LD_INT 0
49484: PPUSH
49485: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49489: LD_ADDR_EXP 117
49493: PUSH
49494: LD_EXP 117
49498: PPUSH
49499: LD_VAR 0 3
49503: PPUSH
49504: LD_EXP 117
49508: PUSH
49509: LD_VAR 0 3
49513: ARRAY
49514: PUSH
49515: LD_VAR 0 1
49519: PPUSH
49520: CALL_OW 311
49524: DIFF
49525: PPUSH
49526: CALL_OW 1
49530: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49531: LD_ADDR_VAR 0 7
49535: PUSH
49536: LD_EXP 98
49540: PUSH
49541: LD_VAR 0 3
49545: ARRAY
49546: PPUSH
49547: LD_INT 1
49549: PPUSH
49550: LD_VAR 0 9
49554: PPUSH
49555: CALL_OW 2
49559: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49560: LD_ADDR_EXP 98
49564: PUSH
49565: LD_EXP 98
49569: PPUSH
49570: LD_VAR 0 3
49574: PPUSH
49575: LD_VAR 0 7
49579: PPUSH
49580: CALL_OW 1
49584: ST_TO_ADDR
// end else
49585: GO 49604
// MC_InsertProduceList ( i , [ components ] ) ;
49587: LD_VAR 0 3
49591: PPUSH
49592: LD_VAR 0 9
49596: PUSH
49597: EMPTY
49598: LIST
49599: PPUSH
49600: CALL 45563 0 2
// break ;
49604: GO 49608
// end ; end ;
49606: GO 49393
49608: POP
49609: POP
// end ; end ; if GetType ( un ) = unit_building then
49610: LD_VAR 0 1
49614: PPUSH
49615: CALL_OW 247
49619: PUSH
49620: LD_INT 3
49622: EQUAL
49623: IFFALSE 50026
// begin btype := GetBType ( un ) ;
49625: LD_ADDR_VAR 0 5
49629: PUSH
49630: LD_VAR 0 1
49634: PPUSH
49635: CALL_OW 266
49639: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49640: LD_VAR 0 5
49644: PUSH
49645: LD_INT 29
49647: PUSH
49648: LD_INT 30
49650: PUSH
49651: EMPTY
49652: LIST
49653: LIST
49654: IN
49655: IFFALSE 49728
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49657: LD_VAR 0 1
49661: PPUSH
49662: CALL_OW 250
49666: PPUSH
49667: LD_VAR 0 1
49671: PPUSH
49672: CALL_OW 251
49676: PPUSH
49677: LD_VAR 0 1
49681: PPUSH
49682: CALL_OW 255
49686: PPUSH
49687: CALL_OW 440
49691: NOT
49692: IFFALSE 49728
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49694: LD_VAR 0 1
49698: PPUSH
49699: CALL_OW 250
49703: PPUSH
49704: LD_VAR 0 1
49708: PPUSH
49709: CALL_OW 251
49713: PPUSH
49714: LD_VAR 0 1
49718: PPUSH
49719: CALL_OW 255
49723: PPUSH
49724: CALL_OW 441
// end ; if btype = b_warehouse then
49728: LD_VAR 0 5
49732: PUSH
49733: LD_INT 1
49735: EQUAL
49736: IFFALSE 49754
// begin btype := b_depot ;
49738: LD_ADDR_VAR 0 5
49742: PUSH
49743: LD_INT 0
49745: ST_TO_ADDR
// pos := 1 ;
49746: LD_ADDR_VAR 0 6
49750: PUSH
49751: LD_INT 1
49753: ST_TO_ADDR
// end ; if btype = b_factory then
49754: LD_VAR 0 5
49758: PUSH
49759: LD_INT 3
49761: EQUAL
49762: IFFALSE 49780
// begin btype := b_workshop ;
49764: LD_ADDR_VAR 0 5
49768: PUSH
49769: LD_INT 2
49771: ST_TO_ADDR
// pos := 1 ;
49772: LD_ADDR_VAR 0 6
49776: PUSH
49777: LD_INT 1
49779: ST_TO_ADDR
// end ; if btype = b_barracks then
49780: LD_VAR 0 5
49784: PUSH
49785: LD_INT 5
49787: EQUAL
49788: IFFALSE 49798
// btype := b_armoury ;
49790: LD_ADDR_VAR 0 5
49794: PUSH
49795: LD_INT 4
49797: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49798: LD_VAR 0 5
49802: PUSH
49803: LD_INT 7
49805: PUSH
49806: LD_INT 8
49808: PUSH
49809: EMPTY
49810: LIST
49811: LIST
49812: IN
49813: IFFALSE 49823
// btype := b_lab ;
49815: LD_ADDR_VAR 0 5
49819: PUSH
49820: LD_INT 6
49822: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49823: LD_ADDR_EXP 82
49827: PUSH
49828: LD_EXP 82
49832: PPUSH
49833: LD_VAR 0 3
49837: PUSH
49838: LD_EXP 82
49842: PUSH
49843: LD_VAR 0 3
49847: ARRAY
49848: PUSH
49849: LD_INT 1
49851: PLUS
49852: PUSH
49853: EMPTY
49854: LIST
49855: LIST
49856: PPUSH
49857: LD_VAR 0 5
49861: PUSH
49862: LD_VAR 0 1
49866: PPUSH
49867: CALL_OW 250
49871: PUSH
49872: LD_VAR 0 1
49876: PPUSH
49877: CALL_OW 251
49881: PUSH
49882: LD_VAR 0 1
49886: PPUSH
49887: CALL_OW 254
49891: PUSH
49892: EMPTY
49893: LIST
49894: LIST
49895: LIST
49896: LIST
49897: PPUSH
49898: CALL 57088 0 3
49902: ST_TO_ADDR
// if pos = 1 then
49903: LD_VAR 0 6
49907: PUSH
49908: LD_INT 1
49910: EQUAL
49911: IFFALSE 50026
// begin tmp := mc_build_list [ i ] ;
49913: LD_ADDR_VAR 0 7
49917: PUSH
49918: LD_EXP 82
49922: PUSH
49923: LD_VAR 0 3
49927: ARRAY
49928: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
49929: LD_VAR 0 7
49933: PPUSH
49934: LD_INT 2
49936: PUSH
49937: LD_INT 30
49939: PUSH
49940: LD_INT 0
49942: PUSH
49943: EMPTY
49944: LIST
49945: LIST
49946: PUSH
49947: LD_INT 30
49949: PUSH
49950: LD_INT 1
49952: PUSH
49953: EMPTY
49954: LIST
49955: LIST
49956: PUSH
49957: EMPTY
49958: LIST
49959: LIST
49960: LIST
49961: PPUSH
49962: CALL_OW 72
49966: IFFALSE 49976
// pos := 2 ;
49968: LD_ADDR_VAR 0 6
49972: PUSH
49973: LD_INT 2
49975: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
49976: LD_ADDR_VAR 0 7
49980: PUSH
49981: LD_VAR 0 7
49985: PPUSH
49986: LD_VAR 0 6
49990: PPUSH
49991: LD_VAR 0 7
49995: PPUSH
49996: CALL 57414 0 3
50000: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50001: LD_ADDR_EXP 82
50005: PUSH
50006: LD_EXP 82
50010: PPUSH
50011: LD_VAR 0 3
50015: PPUSH
50016: LD_VAR 0 7
50020: PPUSH
50021: CALL_OW 1
50025: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50026: LD_VAR 0 1
50030: PUSH
50031: LD_EXP 77
50035: PUSH
50036: LD_VAR 0 3
50040: ARRAY
50041: IN
50042: IFFALSE 50081
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50044: LD_ADDR_EXP 77
50048: PUSH
50049: LD_EXP 77
50053: PPUSH
50054: LD_VAR 0 3
50058: PPUSH
50059: LD_EXP 77
50063: PUSH
50064: LD_VAR 0 3
50068: ARRAY
50069: PUSH
50070: LD_VAR 0 1
50074: DIFF
50075: PPUSH
50076: CALL_OW 1
50080: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50081: LD_VAR 0 1
50085: PUSH
50086: LD_EXP 84
50090: PUSH
50091: LD_VAR 0 3
50095: ARRAY
50096: IN
50097: IFFALSE 50136
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50099: LD_ADDR_EXP 84
50103: PUSH
50104: LD_EXP 84
50108: PPUSH
50109: LD_VAR 0 3
50113: PPUSH
50114: LD_EXP 84
50118: PUSH
50119: LD_VAR 0 3
50123: ARRAY
50124: PUSH
50125: LD_VAR 0 1
50129: DIFF
50130: PPUSH
50131: CALL_OW 1
50135: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50136: LD_VAR 0 1
50140: PUSH
50141: LD_EXP 96
50145: PUSH
50146: LD_VAR 0 3
50150: ARRAY
50151: IN
50152: IFFALSE 50191
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
50154: LD_ADDR_EXP 96
50158: PUSH
50159: LD_EXP 96
50163: PPUSH
50164: LD_VAR 0 3
50168: PPUSH
50169: LD_EXP 96
50173: PUSH
50174: LD_VAR 0 3
50178: ARRAY
50179: PUSH
50180: LD_VAR 0 1
50184: DIFF
50185: PPUSH
50186: CALL_OW 1
50190: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
50191: LD_VAR 0 1
50195: PUSH
50196: LD_EXP 99
50200: PUSH
50201: LD_VAR 0 3
50205: ARRAY
50206: IN
50207: IFFALSE 50246
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50209: LD_ADDR_EXP 99
50213: PUSH
50214: LD_EXP 99
50218: PPUSH
50219: LD_VAR 0 3
50223: PPUSH
50224: LD_EXP 99
50228: PUSH
50229: LD_VAR 0 3
50233: ARRAY
50234: PUSH
50235: LD_VAR 0 1
50239: DIFF
50240: PPUSH
50241: CALL_OW 1
50245: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
50246: LD_VAR 0 1
50250: PUSH
50251: LD_EXP 86
50255: PUSH
50256: LD_VAR 0 3
50260: ARRAY
50261: IN
50262: IFFALSE 50301
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
50264: LD_ADDR_EXP 86
50268: PUSH
50269: LD_EXP 86
50273: PPUSH
50274: LD_VAR 0 3
50278: PPUSH
50279: LD_EXP 86
50283: PUSH
50284: LD_VAR 0 3
50288: ARRAY
50289: PUSH
50290: LD_VAR 0 1
50294: DIFF
50295: PPUSH
50296: CALL_OW 1
50300: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
50301: LD_VAR 0 1
50305: PUSH
50306: LD_EXP 85
50310: PUSH
50311: LD_VAR 0 3
50315: ARRAY
50316: IN
50317: IFFALSE 50356
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
50319: LD_ADDR_EXP 85
50323: PUSH
50324: LD_EXP 85
50328: PPUSH
50329: LD_VAR 0 3
50333: PPUSH
50334: LD_EXP 85
50338: PUSH
50339: LD_VAR 0 3
50343: ARRAY
50344: PUSH
50345: LD_VAR 0 1
50349: DIFF
50350: PPUSH
50351: CALL_OW 1
50355: ST_TO_ADDR
// end ; break ;
50356: GO 50360
// end ;
50358: GO 49008
50360: POP
50361: POP
// end ;
50362: LD_VAR 0 2
50366: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
50367: LD_INT 0
50369: PPUSH
50370: PPUSH
50371: PPUSH
// if not mc_bases or not skirmish then
50372: LD_EXP 77
50376: NOT
50377: PUSH
50378: LD_EXP 75
50382: NOT
50383: OR
50384: IFFALSE 50388
// exit ;
50386: GO 50603
// for i = 1 to mc_bases do
50388: LD_ADDR_VAR 0 3
50392: PUSH
50393: DOUBLE
50394: LD_INT 1
50396: DEC
50397: ST_TO_ADDR
50398: LD_EXP 77
50402: PUSH
50403: FOR_TO
50404: IFFALSE 50601
// begin if building in mc_construct_list [ i ] then
50406: LD_VAR 0 1
50410: PUSH
50411: LD_EXP 84
50415: PUSH
50416: LD_VAR 0 3
50420: ARRAY
50421: IN
50422: IFFALSE 50599
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50424: LD_ADDR_EXP 84
50428: PUSH
50429: LD_EXP 84
50433: PPUSH
50434: LD_VAR 0 3
50438: PPUSH
50439: LD_EXP 84
50443: PUSH
50444: LD_VAR 0 3
50448: ARRAY
50449: PUSH
50450: LD_VAR 0 1
50454: DIFF
50455: PPUSH
50456: CALL_OW 1
50460: ST_TO_ADDR
// if building in mc_lab [ i ] then
50461: LD_VAR 0 1
50465: PUSH
50466: LD_EXP 110
50470: PUSH
50471: LD_VAR 0 3
50475: ARRAY
50476: IN
50477: IFFALSE 50532
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50479: LD_ADDR_EXP 111
50483: PUSH
50484: LD_EXP 111
50488: PPUSH
50489: LD_VAR 0 3
50493: PPUSH
50494: LD_EXP 111
50498: PUSH
50499: LD_VAR 0 3
50503: ARRAY
50504: PPUSH
50505: LD_INT 1
50507: PPUSH
50508: LD_EXP 111
50512: PUSH
50513: LD_VAR 0 3
50517: ARRAY
50518: PPUSH
50519: LD_INT 0
50521: PPUSH
50522: CALL 56506 0 4
50526: PPUSH
50527: CALL_OW 1
50531: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50532: LD_VAR 0 1
50536: PUSH
50537: LD_EXP 77
50541: PUSH
50542: LD_VAR 0 3
50546: ARRAY
50547: IN
50548: NOT
50549: IFFALSE 50595
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50551: LD_ADDR_EXP 77
50555: PUSH
50556: LD_EXP 77
50560: PPUSH
50561: LD_VAR 0 3
50565: PUSH
50566: LD_EXP 77
50570: PUSH
50571: LD_VAR 0 3
50575: ARRAY
50576: PUSH
50577: LD_INT 1
50579: PLUS
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PPUSH
50585: LD_VAR 0 1
50589: PPUSH
50590: CALL 57088 0 3
50594: ST_TO_ADDR
// exit ;
50595: POP
50596: POP
50597: GO 50603
// end ; end ;
50599: GO 50403
50601: POP
50602: POP
// end ;
50603: LD_VAR 0 2
50607: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50608: LD_INT 0
50610: PPUSH
50611: PPUSH
50612: PPUSH
50613: PPUSH
50614: PPUSH
50615: PPUSH
50616: PPUSH
// if not mc_bases or not skirmish then
50617: LD_EXP 77
50621: NOT
50622: PUSH
50623: LD_EXP 75
50627: NOT
50628: OR
50629: IFFALSE 50633
// exit ;
50631: GO 51294
// for i = 1 to mc_bases do
50633: LD_ADDR_VAR 0 3
50637: PUSH
50638: DOUBLE
50639: LD_INT 1
50641: DEC
50642: ST_TO_ADDR
50643: LD_EXP 77
50647: PUSH
50648: FOR_TO
50649: IFFALSE 51292
// begin if building in mc_construct_list [ i ] then
50651: LD_VAR 0 1
50655: PUSH
50656: LD_EXP 84
50660: PUSH
50661: LD_VAR 0 3
50665: ARRAY
50666: IN
50667: IFFALSE 51290
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50669: LD_ADDR_EXP 84
50673: PUSH
50674: LD_EXP 84
50678: PPUSH
50679: LD_VAR 0 3
50683: PPUSH
50684: LD_EXP 84
50688: PUSH
50689: LD_VAR 0 3
50693: ARRAY
50694: PUSH
50695: LD_VAR 0 1
50699: DIFF
50700: PPUSH
50701: CALL_OW 1
50705: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50706: LD_ADDR_EXP 77
50710: PUSH
50711: LD_EXP 77
50715: PPUSH
50716: LD_VAR 0 3
50720: PUSH
50721: LD_EXP 77
50725: PUSH
50726: LD_VAR 0 3
50730: ARRAY
50731: PUSH
50732: LD_INT 1
50734: PLUS
50735: PUSH
50736: EMPTY
50737: LIST
50738: LIST
50739: PPUSH
50740: LD_VAR 0 1
50744: PPUSH
50745: CALL 57088 0 3
50749: ST_TO_ADDR
// btype := GetBType ( building ) ;
50750: LD_ADDR_VAR 0 5
50754: PUSH
50755: LD_VAR 0 1
50759: PPUSH
50760: CALL_OW 266
50764: ST_TO_ADDR
// side := GetSide ( building ) ;
50765: LD_ADDR_VAR 0 8
50769: PUSH
50770: LD_VAR 0 1
50774: PPUSH
50775: CALL_OW 255
50779: ST_TO_ADDR
// if btype = b_lab then
50780: LD_VAR 0 5
50784: PUSH
50785: LD_INT 6
50787: EQUAL
50788: IFFALSE 50838
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50790: LD_ADDR_EXP 110
50794: PUSH
50795: LD_EXP 110
50799: PPUSH
50800: LD_VAR 0 3
50804: PUSH
50805: LD_EXP 110
50809: PUSH
50810: LD_VAR 0 3
50814: ARRAY
50815: PUSH
50816: LD_INT 1
50818: PLUS
50819: PUSH
50820: EMPTY
50821: LIST
50822: LIST
50823: PPUSH
50824: LD_VAR 0 1
50828: PPUSH
50829: CALL 57088 0 3
50833: ST_TO_ADDR
// exit ;
50834: POP
50835: POP
50836: GO 51294
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50838: LD_VAR 0 5
50842: PUSH
50843: LD_INT 0
50845: PUSH
50846: LD_INT 2
50848: PUSH
50849: LD_INT 4
50851: PUSH
50852: EMPTY
50853: LIST
50854: LIST
50855: LIST
50856: IN
50857: IFFALSE 50981
// begin if btype = b_armoury then
50859: LD_VAR 0 5
50863: PUSH
50864: LD_INT 4
50866: EQUAL
50867: IFFALSE 50877
// btype := b_barracks ;
50869: LD_ADDR_VAR 0 5
50873: PUSH
50874: LD_INT 5
50876: ST_TO_ADDR
// if btype = b_depot then
50877: LD_VAR 0 5
50881: PUSH
50882: LD_INT 0
50884: EQUAL
50885: IFFALSE 50895
// btype := b_warehouse ;
50887: LD_ADDR_VAR 0 5
50891: PUSH
50892: LD_INT 1
50894: ST_TO_ADDR
// if btype = b_workshop then
50895: LD_VAR 0 5
50899: PUSH
50900: LD_INT 2
50902: EQUAL
50903: IFFALSE 50913
// btype := b_factory ;
50905: LD_ADDR_VAR 0 5
50909: PUSH
50910: LD_INT 3
50912: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50913: LD_VAR 0 5
50917: PPUSH
50918: LD_VAR 0 8
50922: PPUSH
50923: CALL_OW 323
50927: PUSH
50928: LD_INT 1
50930: EQUAL
50931: IFFALSE 50977
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
50933: LD_ADDR_EXP 109
50937: PUSH
50938: LD_EXP 109
50942: PPUSH
50943: LD_VAR 0 3
50947: PUSH
50948: LD_EXP 109
50952: PUSH
50953: LD_VAR 0 3
50957: ARRAY
50958: PUSH
50959: LD_INT 1
50961: PLUS
50962: PUSH
50963: EMPTY
50964: LIST
50965: LIST
50966: PPUSH
50967: LD_VAR 0 1
50971: PPUSH
50972: CALL 57088 0 3
50976: ST_TO_ADDR
// exit ;
50977: POP
50978: POP
50979: GO 51294
// end ; if btype in [ b_bunker , b_turret ] then
50981: LD_VAR 0 5
50985: PUSH
50986: LD_INT 32
50988: PUSH
50989: LD_INT 33
50991: PUSH
50992: EMPTY
50993: LIST
50994: LIST
50995: IN
50996: IFFALSE 51286
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
50998: LD_ADDR_EXP 85
51002: PUSH
51003: LD_EXP 85
51007: PPUSH
51008: LD_VAR 0 3
51012: PUSH
51013: LD_EXP 85
51017: PUSH
51018: LD_VAR 0 3
51022: ARRAY
51023: PUSH
51024: LD_INT 1
51026: PLUS
51027: PUSH
51028: EMPTY
51029: LIST
51030: LIST
51031: PPUSH
51032: LD_VAR 0 1
51036: PPUSH
51037: CALL 57088 0 3
51041: ST_TO_ADDR
// if btype = b_bunker then
51042: LD_VAR 0 5
51046: PUSH
51047: LD_INT 32
51049: EQUAL
51050: IFFALSE 51286
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51052: LD_ADDR_EXP 86
51056: PUSH
51057: LD_EXP 86
51061: PPUSH
51062: LD_VAR 0 3
51066: PUSH
51067: LD_EXP 86
51071: PUSH
51072: LD_VAR 0 3
51076: ARRAY
51077: PUSH
51078: LD_INT 1
51080: PLUS
51081: PUSH
51082: EMPTY
51083: LIST
51084: LIST
51085: PPUSH
51086: LD_VAR 0 1
51090: PPUSH
51091: CALL 57088 0 3
51095: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51096: LD_ADDR_VAR 0 6
51100: PUSH
51101: LD_EXP 77
51105: PUSH
51106: LD_VAR 0 3
51110: ARRAY
51111: PPUSH
51112: LD_INT 25
51114: PUSH
51115: LD_INT 1
51117: PUSH
51118: EMPTY
51119: LIST
51120: LIST
51121: PUSH
51122: LD_INT 3
51124: PUSH
51125: LD_INT 54
51127: PUSH
51128: EMPTY
51129: LIST
51130: PUSH
51131: EMPTY
51132: LIST
51133: LIST
51134: PUSH
51135: EMPTY
51136: LIST
51137: LIST
51138: PPUSH
51139: CALL_OW 72
51143: ST_TO_ADDR
// if tmp then
51144: LD_VAR 0 6
51148: IFFALSE 51154
// exit ;
51150: POP
51151: POP
51152: GO 51294
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51154: LD_ADDR_VAR 0 6
51158: PUSH
51159: LD_EXP 77
51163: PUSH
51164: LD_VAR 0 3
51168: ARRAY
51169: PPUSH
51170: LD_INT 2
51172: PUSH
51173: LD_INT 30
51175: PUSH
51176: LD_INT 4
51178: PUSH
51179: EMPTY
51180: LIST
51181: LIST
51182: PUSH
51183: LD_INT 30
51185: PUSH
51186: LD_INT 5
51188: PUSH
51189: EMPTY
51190: LIST
51191: LIST
51192: PUSH
51193: EMPTY
51194: LIST
51195: LIST
51196: LIST
51197: PPUSH
51198: CALL_OW 72
51202: ST_TO_ADDR
// if not tmp then
51203: LD_VAR 0 6
51207: NOT
51208: IFFALSE 51214
// exit ;
51210: POP
51211: POP
51212: GO 51294
// for j in tmp do
51214: LD_ADDR_VAR 0 4
51218: PUSH
51219: LD_VAR 0 6
51223: PUSH
51224: FOR_IN
51225: IFFALSE 51284
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
51227: LD_ADDR_VAR 0 7
51231: PUSH
51232: LD_VAR 0 4
51236: PPUSH
51237: CALL_OW 313
51241: PPUSH
51242: LD_INT 25
51244: PUSH
51245: LD_INT 1
51247: PUSH
51248: EMPTY
51249: LIST
51250: LIST
51251: PPUSH
51252: CALL_OW 72
51256: ST_TO_ADDR
// if units then
51257: LD_VAR 0 7
51261: IFFALSE 51282
// begin ComExitBuilding ( units [ 1 ] ) ;
51263: LD_VAR 0 7
51267: PUSH
51268: LD_INT 1
51270: ARRAY
51271: PPUSH
51272: CALL_OW 122
// exit ;
51276: POP
51277: POP
51278: POP
51279: POP
51280: GO 51294
// end ; end ;
51282: GO 51224
51284: POP
51285: POP
// end ; end ; exit ;
51286: POP
51287: POP
51288: GO 51294
// end ; end ;
51290: GO 50648
51292: POP
51293: POP
// end ;
51294: LD_VAR 0 2
51298: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
51299: LD_INT 0
51301: PPUSH
51302: PPUSH
51303: PPUSH
51304: PPUSH
51305: PPUSH
51306: PPUSH
51307: PPUSH
// if not mc_bases or not skirmish then
51308: LD_EXP 77
51312: NOT
51313: PUSH
51314: LD_EXP 75
51318: NOT
51319: OR
51320: IFFALSE 51324
// exit ;
51322: GO 51589
// btype := GetBType ( building ) ;
51324: LD_ADDR_VAR 0 6
51328: PUSH
51329: LD_VAR 0 1
51333: PPUSH
51334: CALL_OW 266
51338: ST_TO_ADDR
// x := GetX ( building ) ;
51339: LD_ADDR_VAR 0 7
51343: PUSH
51344: LD_VAR 0 1
51348: PPUSH
51349: CALL_OW 250
51353: ST_TO_ADDR
// y := GetY ( building ) ;
51354: LD_ADDR_VAR 0 8
51358: PUSH
51359: LD_VAR 0 1
51363: PPUSH
51364: CALL_OW 251
51368: ST_TO_ADDR
// d := GetDir ( building ) ;
51369: LD_ADDR_VAR 0 9
51373: PUSH
51374: LD_VAR 0 1
51378: PPUSH
51379: CALL_OW 254
51383: ST_TO_ADDR
// for i = 1 to mc_bases do
51384: LD_ADDR_VAR 0 4
51388: PUSH
51389: DOUBLE
51390: LD_INT 1
51392: DEC
51393: ST_TO_ADDR
51394: LD_EXP 77
51398: PUSH
51399: FOR_TO
51400: IFFALSE 51587
// begin if not mc_build_list [ i ] then
51402: LD_EXP 82
51406: PUSH
51407: LD_VAR 0 4
51411: ARRAY
51412: NOT
51413: IFFALSE 51417
// continue ;
51415: GO 51399
// for j := 1 to mc_build_list [ i ] do
51417: LD_ADDR_VAR 0 5
51421: PUSH
51422: DOUBLE
51423: LD_INT 1
51425: DEC
51426: ST_TO_ADDR
51427: LD_EXP 82
51431: PUSH
51432: LD_VAR 0 4
51436: ARRAY
51437: PUSH
51438: FOR_TO
51439: IFFALSE 51583
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
51441: LD_VAR 0 6
51445: PUSH
51446: LD_VAR 0 7
51450: PUSH
51451: LD_VAR 0 8
51455: PUSH
51456: LD_VAR 0 9
51460: PUSH
51461: EMPTY
51462: LIST
51463: LIST
51464: LIST
51465: LIST
51466: PPUSH
51467: LD_EXP 82
51471: PUSH
51472: LD_VAR 0 4
51476: ARRAY
51477: PUSH
51478: LD_VAR 0 5
51482: ARRAY
51483: PPUSH
51484: CALL 63268 0 2
51488: IFFALSE 51581
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51490: LD_ADDR_EXP 82
51494: PUSH
51495: LD_EXP 82
51499: PPUSH
51500: LD_VAR 0 4
51504: PPUSH
51505: LD_EXP 82
51509: PUSH
51510: LD_VAR 0 4
51514: ARRAY
51515: PPUSH
51516: LD_VAR 0 5
51520: PPUSH
51521: CALL_OW 3
51525: PPUSH
51526: CALL_OW 1
51530: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51531: LD_ADDR_EXP 84
51535: PUSH
51536: LD_EXP 84
51540: PPUSH
51541: LD_VAR 0 4
51545: PUSH
51546: LD_EXP 84
51550: PUSH
51551: LD_VAR 0 4
51555: ARRAY
51556: PUSH
51557: LD_INT 1
51559: PLUS
51560: PUSH
51561: EMPTY
51562: LIST
51563: LIST
51564: PPUSH
51565: LD_VAR 0 1
51569: PPUSH
51570: CALL 57088 0 3
51574: ST_TO_ADDR
// exit ;
51575: POP
51576: POP
51577: POP
51578: POP
51579: GO 51589
// end ;
51581: GO 51438
51583: POP
51584: POP
// end ;
51585: GO 51399
51587: POP
51588: POP
// end ;
51589: LD_VAR 0 3
51593: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51594: LD_INT 0
51596: PPUSH
51597: PPUSH
51598: PPUSH
// if not mc_bases or not skirmish then
51599: LD_EXP 77
51603: NOT
51604: PUSH
51605: LD_EXP 75
51609: NOT
51610: OR
51611: IFFALSE 51615
// exit ;
51613: GO 51805
// for i = 1 to mc_bases do
51615: LD_ADDR_VAR 0 4
51619: PUSH
51620: DOUBLE
51621: LD_INT 1
51623: DEC
51624: ST_TO_ADDR
51625: LD_EXP 77
51629: PUSH
51630: FOR_TO
51631: IFFALSE 51718
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51633: LD_VAR 0 1
51637: PUSH
51638: LD_EXP 85
51642: PUSH
51643: LD_VAR 0 4
51647: ARRAY
51648: IN
51649: PUSH
51650: LD_VAR 0 1
51654: PUSH
51655: LD_EXP 86
51659: PUSH
51660: LD_VAR 0 4
51664: ARRAY
51665: IN
51666: NOT
51667: AND
51668: IFFALSE 51716
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51670: LD_ADDR_EXP 86
51674: PUSH
51675: LD_EXP 86
51679: PPUSH
51680: LD_VAR 0 4
51684: PUSH
51685: LD_EXP 86
51689: PUSH
51690: LD_VAR 0 4
51694: ARRAY
51695: PUSH
51696: LD_INT 1
51698: PLUS
51699: PUSH
51700: EMPTY
51701: LIST
51702: LIST
51703: PPUSH
51704: LD_VAR 0 1
51708: PPUSH
51709: CALL 57088 0 3
51713: ST_TO_ADDR
// break ;
51714: GO 51718
// end ; end ;
51716: GO 51630
51718: POP
51719: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51720: LD_VAR 0 1
51724: PPUSH
51725: CALL_OW 257
51729: PUSH
51730: LD_EXP 103
51734: IN
51735: PUSH
51736: LD_VAR 0 1
51740: PPUSH
51741: CALL_OW 266
51745: PUSH
51746: LD_INT 5
51748: EQUAL
51749: AND
51750: PUSH
51751: LD_VAR 0 2
51755: PPUSH
51756: CALL_OW 110
51760: PUSH
51761: LD_INT 18
51763: NONEQUAL
51764: AND
51765: IFFALSE 51805
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51767: LD_VAR 0 2
51771: PPUSH
51772: CALL_OW 257
51776: PUSH
51777: LD_INT 5
51779: PUSH
51780: LD_INT 8
51782: PUSH
51783: LD_INT 9
51785: PUSH
51786: EMPTY
51787: LIST
51788: LIST
51789: LIST
51790: IN
51791: IFFALSE 51805
// SetClass ( unit , 1 ) ;
51793: LD_VAR 0 2
51797: PPUSH
51798: LD_INT 1
51800: PPUSH
51801: CALL_OW 336
// end ;
51805: LD_VAR 0 3
51809: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51810: LD_INT 0
51812: PPUSH
51813: PPUSH
// if not mc_bases or not skirmish then
51814: LD_EXP 77
51818: NOT
51819: PUSH
51820: LD_EXP 75
51824: NOT
51825: OR
51826: IFFALSE 51830
// exit ;
51828: GO 51946
// if GetLives ( abandoned_vehicle ) > 250 then
51830: LD_VAR 0 2
51834: PPUSH
51835: CALL_OW 256
51839: PUSH
51840: LD_INT 250
51842: GREATER
51843: IFFALSE 51847
// exit ;
51845: GO 51946
// for i = 1 to mc_bases do
51847: LD_ADDR_VAR 0 6
51851: PUSH
51852: DOUBLE
51853: LD_INT 1
51855: DEC
51856: ST_TO_ADDR
51857: LD_EXP 77
51861: PUSH
51862: FOR_TO
51863: IFFALSE 51944
// begin if driver in mc_bases [ i ] then
51865: LD_VAR 0 1
51869: PUSH
51870: LD_EXP 77
51874: PUSH
51875: LD_VAR 0 6
51879: ARRAY
51880: IN
51881: IFFALSE 51942
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51883: LD_VAR 0 1
51887: PPUSH
51888: LD_EXP 77
51892: PUSH
51893: LD_VAR 0 6
51897: ARRAY
51898: PPUSH
51899: LD_INT 2
51901: PUSH
51902: LD_INT 30
51904: PUSH
51905: LD_INT 0
51907: PUSH
51908: EMPTY
51909: LIST
51910: LIST
51911: PUSH
51912: LD_INT 30
51914: PUSH
51915: LD_INT 1
51917: PUSH
51918: EMPTY
51919: LIST
51920: LIST
51921: PUSH
51922: EMPTY
51923: LIST
51924: LIST
51925: LIST
51926: PPUSH
51927: CALL_OW 72
51931: PUSH
51932: LD_INT 1
51934: ARRAY
51935: PPUSH
51936: CALL 90277 0 2
// break ;
51940: GO 51944
// end ; end ;
51942: GO 51862
51944: POP
51945: POP
// end ; end_of_file
51946: LD_VAR 0 5
51950: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
51951: LD_INT 0
51953: PPUSH
51954: PPUSH
// if exist_mode then
51955: LD_VAR 0 2
51959: IFFALSE 51984
// unit := CreateCharacter ( prefix & ident ) else
51961: LD_ADDR_VAR 0 5
51965: PUSH
51966: LD_VAR 0 3
51970: PUSH
51971: LD_VAR 0 1
51975: STR
51976: PPUSH
51977: CALL_OW 34
51981: ST_TO_ADDR
51982: GO 51999
// unit := NewCharacter ( ident ) ;
51984: LD_ADDR_VAR 0 5
51988: PUSH
51989: LD_VAR 0 1
51993: PPUSH
51994: CALL_OW 25
51998: ST_TO_ADDR
// result := unit ;
51999: LD_ADDR_VAR 0 4
52003: PUSH
52004: LD_VAR 0 5
52008: ST_TO_ADDR
// end ;
52009: LD_VAR 0 4
52013: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52014: LD_INT 0
52016: PPUSH
52017: PPUSH
// if not side or not nation then
52018: LD_VAR 0 1
52022: NOT
52023: PUSH
52024: LD_VAR 0 2
52028: NOT
52029: OR
52030: IFFALSE 52034
// exit ;
52032: GO 52802
// case nation of nation_american :
52034: LD_VAR 0 2
52038: PUSH
52039: LD_INT 1
52041: DOUBLE
52042: EQUAL
52043: IFTRUE 52047
52045: GO 52261
52047: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52048: LD_ADDR_VAR 0 4
52052: PUSH
52053: LD_INT 35
52055: PUSH
52056: LD_INT 45
52058: PUSH
52059: LD_INT 46
52061: PUSH
52062: LD_INT 47
52064: PUSH
52065: LD_INT 82
52067: PUSH
52068: LD_INT 83
52070: PUSH
52071: LD_INT 84
52073: PUSH
52074: LD_INT 85
52076: PUSH
52077: LD_INT 86
52079: PUSH
52080: LD_INT 1
52082: PUSH
52083: LD_INT 2
52085: PUSH
52086: LD_INT 6
52088: PUSH
52089: LD_INT 15
52091: PUSH
52092: LD_INT 16
52094: PUSH
52095: LD_INT 7
52097: PUSH
52098: LD_INT 12
52100: PUSH
52101: LD_INT 13
52103: PUSH
52104: LD_INT 10
52106: PUSH
52107: LD_INT 14
52109: PUSH
52110: LD_INT 20
52112: PUSH
52113: LD_INT 21
52115: PUSH
52116: LD_INT 22
52118: PUSH
52119: LD_INT 25
52121: PUSH
52122: LD_INT 32
52124: PUSH
52125: LD_INT 27
52127: PUSH
52128: LD_INT 36
52130: PUSH
52131: LD_INT 69
52133: PUSH
52134: LD_INT 39
52136: PUSH
52137: LD_INT 34
52139: PUSH
52140: LD_INT 40
52142: PUSH
52143: LD_INT 48
52145: PUSH
52146: LD_INT 49
52148: PUSH
52149: LD_INT 50
52151: PUSH
52152: LD_INT 51
52154: PUSH
52155: LD_INT 52
52157: PUSH
52158: LD_INT 53
52160: PUSH
52161: LD_INT 54
52163: PUSH
52164: LD_INT 55
52166: PUSH
52167: LD_INT 56
52169: PUSH
52170: LD_INT 57
52172: PUSH
52173: LD_INT 58
52175: PUSH
52176: LD_INT 59
52178: PUSH
52179: LD_INT 60
52181: PUSH
52182: LD_INT 61
52184: PUSH
52185: LD_INT 62
52187: PUSH
52188: LD_INT 80
52190: PUSH
52191: LD_INT 82
52193: PUSH
52194: LD_INT 83
52196: PUSH
52197: LD_INT 84
52199: PUSH
52200: LD_INT 85
52202: PUSH
52203: LD_INT 86
52205: PUSH
52206: EMPTY
52207: LIST
52208: LIST
52209: LIST
52210: LIST
52211: LIST
52212: LIST
52213: LIST
52214: LIST
52215: LIST
52216: LIST
52217: LIST
52218: LIST
52219: LIST
52220: LIST
52221: LIST
52222: LIST
52223: LIST
52224: LIST
52225: LIST
52226: LIST
52227: LIST
52228: LIST
52229: LIST
52230: LIST
52231: LIST
52232: LIST
52233: LIST
52234: LIST
52235: LIST
52236: LIST
52237: LIST
52238: LIST
52239: LIST
52240: LIST
52241: LIST
52242: LIST
52243: LIST
52244: LIST
52245: LIST
52246: LIST
52247: LIST
52248: LIST
52249: LIST
52250: LIST
52251: LIST
52252: LIST
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: LIST
52258: ST_TO_ADDR
52259: GO 52726
52261: LD_INT 2
52263: DOUBLE
52264: EQUAL
52265: IFTRUE 52269
52267: GO 52495
52269: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
52270: LD_ADDR_VAR 0 4
52274: PUSH
52275: LD_INT 35
52277: PUSH
52278: LD_INT 45
52280: PUSH
52281: LD_INT 46
52283: PUSH
52284: LD_INT 47
52286: PUSH
52287: LD_INT 82
52289: PUSH
52290: LD_INT 83
52292: PUSH
52293: LD_INT 84
52295: PUSH
52296: LD_INT 85
52298: PUSH
52299: LD_INT 87
52301: PUSH
52302: LD_INT 70
52304: PUSH
52305: LD_INT 1
52307: PUSH
52308: LD_INT 11
52310: PUSH
52311: LD_INT 3
52313: PUSH
52314: LD_INT 4
52316: PUSH
52317: LD_INT 5
52319: PUSH
52320: LD_INT 6
52322: PUSH
52323: LD_INT 15
52325: PUSH
52326: LD_INT 18
52328: PUSH
52329: LD_INT 7
52331: PUSH
52332: LD_INT 17
52334: PUSH
52335: LD_INT 8
52337: PUSH
52338: LD_INT 20
52340: PUSH
52341: LD_INT 21
52343: PUSH
52344: LD_INT 22
52346: PUSH
52347: LD_INT 72
52349: PUSH
52350: LD_INT 26
52352: PUSH
52353: LD_INT 69
52355: PUSH
52356: LD_INT 39
52358: PUSH
52359: LD_INT 40
52361: PUSH
52362: LD_INT 41
52364: PUSH
52365: LD_INT 42
52367: PUSH
52368: LD_INT 43
52370: PUSH
52371: LD_INT 48
52373: PUSH
52374: LD_INT 49
52376: PUSH
52377: LD_INT 50
52379: PUSH
52380: LD_INT 51
52382: PUSH
52383: LD_INT 52
52385: PUSH
52386: LD_INT 53
52388: PUSH
52389: LD_INT 54
52391: PUSH
52392: LD_INT 55
52394: PUSH
52395: LD_INT 56
52397: PUSH
52398: LD_INT 60
52400: PUSH
52401: LD_INT 61
52403: PUSH
52404: LD_INT 62
52406: PUSH
52407: LD_INT 66
52409: PUSH
52410: LD_INT 67
52412: PUSH
52413: LD_INT 68
52415: PUSH
52416: LD_INT 81
52418: PUSH
52419: LD_INT 82
52421: PUSH
52422: LD_INT 83
52424: PUSH
52425: LD_INT 84
52427: PUSH
52428: LD_INT 85
52430: PUSH
52431: LD_INT 87
52433: PUSH
52434: LD_INT 88
52436: PUSH
52437: EMPTY
52438: LIST
52439: LIST
52440: LIST
52441: LIST
52442: LIST
52443: LIST
52444: LIST
52445: LIST
52446: LIST
52447: LIST
52448: LIST
52449: LIST
52450: LIST
52451: LIST
52452: LIST
52453: LIST
52454: LIST
52455: LIST
52456: LIST
52457: LIST
52458: LIST
52459: LIST
52460: LIST
52461: LIST
52462: LIST
52463: LIST
52464: LIST
52465: LIST
52466: LIST
52467: LIST
52468: LIST
52469: LIST
52470: LIST
52471: LIST
52472: LIST
52473: LIST
52474: LIST
52475: LIST
52476: LIST
52477: LIST
52478: LIST
52479: LIST
52480: LIST
52481: LIST
52482: LIST
52483: LIST
52484: LIST
52485: LIST
52486: LIST
52487: LIST
52488: LIST
52489: LIST
52490: LIST
52491: LIST
52492: ST_TO_ADDR
52493: GO 52726
52495: LD_INT 3
52497: DOUBLE
52498: EQUAL
52499: IFTRUE 52503
52501: GO 52725
52503: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52504: LD_ADDR_VAR 0 4
52508: PUSH
52509: LD_INT 46
52511: PUSH
52512: LD_INT 47
52514: PUSH
52515: LD_INT 1
52517: PUSH
52518: LD_INT 2
52520: PUSH
52521: LD_INT 82
52523: PUSH
52524: LD_INT 83
52526: PUSH
52527: LD_INT 84
52529: PUSH
52530: LD_INT 85
52532: PUSH
52533: LD_INT 86
52535: PUSH
52536: LD_INT 11
52538: PUSH
52539: LD_INT 9
52541: PUSH
52542: LD_INT 20
52544: PUSH
52545: LD_INT 19
52547: PUSH
52548: LD_INT 21
52550: PUSH
52551: LD_INT 24
52553: PUSH
52554: LD_INT 22
52556: PUSH
52557: LD_INT 25
52559: PUSH
52560: LD_INT 28
52562: PUSH
52563: LD_INT 29
52565: PUSH
52566: LD_INT 30
52568: PUSH
52569: LD_INT 31
52571: PUSH
52572: LD_INT 37
52574: PUSH
52575: LD_INT 38
52577: PUSH
52578: LD_INT 32
52580: PUSH
52581: LD_INT 27
52583: PUSH
52584: LD_INT 33
52586: PUSH
52587: LD_INT 69
52589: PUSH
52590: LD_INT 39
52592: PUSH
52593: LD_INT 34
52595: PUSH
52596: LD_INT 40
52598: PUSH
52599: LD_INT 71
52601: PUSH
52602: LD_INT 23
52604: PUSH
52605: LD_INT 44
52607: PUSH
52608: LD_INT 48
52610: PUSH
52611: LD_INT 49
52613: PUSH
52614: LD_INT 50
52616: PUSH
52617: LD_INT 51
52619: PUSH
52620: LD_INT 52
52622: PUSH
52623: LD_INT 53
52625: PUSH
52626: LD_INT 54
52628: PUSH
52629: LD_INT 55
52631: PUSH
52632: LD_INT 56
52634: PUSH
52635: LD_INT 57
52637: PUSH
52638: LD_INT 58
52640: PUSH
52641: LD_INT 59
52643: PUSH
52644: LD_INT 63
52646: PUSH
52647: LD_INT 64
52649: PUSH
52650: LD_INT 65
52652: PUSH
52653: LD_INT 82
52655: PUSH
52656: LD_INT 83
52658: PUSH
52659: LD_INT 84
52661: PUSH
52662: LD_INT 85
52664: PUSH
52665: LD_INT 86
52667: PUSH
52668: EMPTY
52669: LIST
52670: LIST
52671: LIST
52672: LIST
52673: LIST
52674: LIST
52675: LIST
52676: LIST
52677: LIST
52678: LIST
52679: LIST
52680: LIST
52681: LIST
52682: LIST
52683: LIST
52684: LIST
52685: LIST
52686: LIST
52687: LIST
52688: LIST
52689: LIST
52690: LIST
52691: LIST
52692: LIST
52693: LIST
52694: LIST
52695: LIST
52696: LIST
52697: LIST
52698: LIST
52699: LIST
52700: LIST
52701: LIST
52702: LIST
52703: LIST
52704: LIST
52705: LIST
52706: LIST
52707: LIST
52708: LIST
52709: LIST
52710: LIST
52711: LIST
52712: LIST
52713: LIST
52714: LIST
52715: LIST
52716: LIST
52717: LIST
52718: LIST
52719: LIST
52720: LIST
52721: LIST
52722: ST_TO_ADDR
52723: GO 52726
52725: POP
// if state > - 1 and state < 3 then
52726: LD_VAR 0 3
52730: PUSH
52731: LD_INT 1
52733: NEG
52734: GREATER
52735: PUSH
52736: LD_VAR 0 3
52740: PUSH
52741: LD_INT 3
52743: LESS
52744: AND
52745: IFFALSE 52802
// for i in result do
52747: LD_ADDR_VAR 0 5
52751: PUSH
52752: LD_VAR 0 4
52756: PUSH
52757: FOR_IN
52758: IFFALSE 52800
// if GetTech ( i , side ) <> state then
52760: LD_VAR 0 5
52764: PPUSH
52765: LD_VAR 0 1
52769: PPUSH
52770: CALL_OW 321
52774: PUSH
52775: LD_VAR 0 3
52779: NONEQUAL
52780: IFFALSE 52798
// result := result diff i ;
52782: LD_ADDR_VAR 0 4
52786: PUSH
52787: LD_VAR 0 4
52791: PUSH
52792: LD_VAR 0 5
52796: DIFF
52797: ST_TO_ADDR
52798: GO 52757
52800: POP
52801: POP
// end ;
52802: LD_VAR 0 4
52806: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52807: LD_INT 0
52809: PPUSH
52810: PPUSH
52811: PPUSH
// result := true ;
52812: LD_ADDR_VAR 0 3
52816: PUSH
52817: LD_INT 1
52819: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52820: LD_ADDR_VAR 0 5
52824: PUSH
52825: LD_VAR 0 2
52829: PPUSH
52830: CALL_OW 480
52834: ST_TO_ADDR
// if not tmp then
52835: LD_VAR 0 5
52839: NOT
52840: IFFALSE 52844
// exit ;
52842: GO 52893
// for i in tmp do
52844: LD_ADDR_VAR 0 4
52848: PUSH
52849: LD_VAR 0 5
52853: PUSH
52854: FOR_IN
52855: IFFALSE 52891
// if GetTech ( i , side ) <> state_researched then
52857: LD_VAR 0 4
52861: PPUSH
52862: LD_VAR 0 1
52866: PPUSH
52867: CALL_OW 321
52871: PUSH
52872: LD_INT 2
52874: NONEQUAL
52875: IFFALSE 52889
// begin result := false ;
52877: LD_ADDR_VAR 0 3
52881: PUSH
52882: LD_INT 0
52884: ST_TO_ADDR
// exit ;
52885: POP
52886: POP
52887: GO 52893
// end ;
52889: GO 52854
52891: POP
52892: POP
// end ;
52893: LD_VAR 0 3
52897: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52898: LD_INT 0
52900: PPUSH
52901: PPUSH
52902: PPUSH
52903: PPUSH
52904: PPUSH
52905: PPUSH
52906: PPUSH
52907: PPUSH
52908: PPUSH
52909: PPUSH
52910: PPUSH
52911: PPUSH
52912: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52913: LD_VAR 0 1
52917: NOT
52918: PUSH
52919: LD_VAR 0 1
52923: PPUSH
52924: CALL_OW 257
52928: PUSH
52929: LD_INT 9
52931: NONEQUAL
52932: OR
52933: IFFALSE 52937
// exit ;
52935: GO 53510
// side := GetSide ( unit ) ;
52937: LD_ADDR_VAR 0 9
52941: PUSH
52942: LD_VAR 0 1
52946: PPUSH
52947: CALL_OW 255
52951: ST_TO_ADDR
// tech_space := tech_spacanom ;
52952: LD_ADDR_VAR 0 12
52956: PUSH
52957: LD_INT 29
52959: ST_TO_ADDR
// tech_time := tech_taurad ;
52960: LD_ADDR_VAR 0 13
52964: PUSH
52965: LD_INT 28
52967: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
52968: LD_ADDR_VAR 0 11
52972: PUSH
52973: LD_VAR 0 1
52977: PPUSH
52978: CALL_OW 310
52982: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
52983: LD_VAR 0 11
52987: PPUSH
52988: CALL_OW 247
52992: PUSH
52993: LD_INT 2
52995: EQUAL
52996: IFFALSE 53000
// exit ;
52998: GO 53510
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53000: LD_ADDR_VAR 0 8
53004: PUSH
53005: LD_INT 81
53007: PUSH
53008: LD_VAR 0 9
53012: PUSH
53013: EMPTY
53014: LIST
53015: LIST
53016: PUSH
53017: LD_INT 3
53019: PUSH
53020: LD_INT 21
53022: PUSH
53023: LD_INT 3
53025: PUSH
53026: EMPTY
53027: LIST
53028: LIST
53029: PUSH
53030: EMPTY
53031: LIST
53032: LIST
53033: PUSH
53034: EMPTY
53035: LIST
53036: LIST
53037: PPUSH
53038: CALL_OW 69
53042: ST_TO_ADDR
// if not tmp then
53043: LD_VAR 0 8
53047: NOT
53048: IFFALSE 53052
// exit ;
53050: GO 53510
// if in_unit then
53052: LD_VAR 0 11
53056: IFFALSE 53080
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53058: LD_ADDR_VAR 0 10
53062: PUSH
53063: LD_VAR 0 8
53067: PPUSH
53068: LD_VAR 0 11
53072: PPUSH
53073: CALL_OW 74
53077: ST_TO_ADDR
53078: GO 53100
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53080: LD_ADDR_VAR 0 10
53084: PUSH
53085: LD_VAR 0 8
53089: PPUSH
53090: LD_VAR 0 1
53094: PPUSH
53095: CALL_OW 74
53099: ST_TO_ADDR
// if not enemy then
53100: LD_VAR 0 10
53104: NOT
53105: IFFALSE 53109
// exit ;
53107: GO 53510
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53109: LD_VAR 0 11
53113: PUSH
53114: LD_VAR 0 11
53118: PPUSH
53119: LD_VAR 0 10
53123: PPUSH
53124: CALL_OW 296
53128: PUSH
53129: LD_INT 13
53131: GREATER
53132: AND
53133: PUSH
53134: LD_VAR 0 1
53138: PPUSH
53139: LD_VAR 0 10
53143: PPUSH
53144: CALL_OW 296
53148: PUSH
53149: LD_INT 12
53151: GREATER
53152: OR
53153: IFFALSE 53157
// exit ;
53155: GO 53510
// missile := [ 1 ] ;
53157: LD_ADDR_VAR 0 14
53161: PUSH
53162: LD_INT 1
53164: PUSH
53165: EMPTY
53166: LIST
53167: ST_TO_ADDR
// if Researched ( side , tech_space ) then
53168: LD_VAR 0 9
53172: PPUSH
53173: LD_VAR 0 12
53177: PPUSH
53178: CALL_OW 325
53182: IFFALSE 53211
// missile := Replace ( missile , missile + 1 , 2 ) ;
53184: LD_ADDR_VAR 0 14
53188: PUSH
53189: LD_VAR 0 14
53193: PPUSH
53194: LD_VAR 0 14
53198: PUSH
53199: LD_INT 1
53201: PLUS
53202: PPUSH
53203: LD_INT 2
53205: PPUSH
53206: CALL_OW 1
53210: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
53211: LD_VAR 0 9
53215: PPUSH
53216: LD_VAR 0 13
53220: PPUSH
53221: CALL_OW 325
53225: PUSH
53226: LD_VAR 0 10
53230: PPUSH
53231: CALL_OW 255
53235: PPUSH
53236: LD_VAR 0 13
53240: PPUSH
53241: CALL_OW 325
53245: NOT
53246: AND
53247: IFFALSE 53276
// missile := Replace ( missile , missile + 1 , 3 ) ;
53249: LD_ADDR_VAR 0 14
53253: PUSH
53254: LD_VAR 0 14
53258: PPUSH
53259: LD_VAR 0 14
53263: PUSH
53264: LD_INT 1
53266: PLUS
53267: PPUSH
53268: LD_INT 3
53270: PPUSH
53271: CALL_OW 1
53275: ST_TO_ADDR
// if missile < 2 then
53276: LD_VAR 0 14
53280: PUSH
53281: LD_INT 2
53283: LESS
53284: IFFALSE 53288
// exit ;
53286: GO 53510
// x := GetX ( enemy ) ;
53288: LD_ADDR_VAR 0 4
53292: PUSH
53293: LD_VAR 0 10
53297: PPUSH
53298: CALL_OW 250
53302: ST_TO_ADDR
// y := GetY ( enemy ) ;
53303: LD_ADDR_VAR 0 5
53307: PUSH
53308: LD_VAR 0 10
53312: PPUSH
53313: CALL_OW 251
53317: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
53318: LD_ADDR_VAR 0 6
53322: PUSH
53323: LD_VAR 0 4
53327: PUSH
53328: LD_INT 1
53330: NEG
53331: PPUSH
53332: LD_INT 1
53334: PPUSH
53335: CALL_OW 12
53339: PLUS
53340: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
53341: LD_ADDR_VAR 0 7
53345: PUSH
53346: LD_VAR 0 5
53350: PUSH
53351: LD_INT 1
53353: NEG
53354: PPUSH
53355: LD_INT 1
53357: PPUSH
53358: CALL_OW 12
53362: PLUS
53363: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53364: LD_VAR 0 6
53368: PPUSH
53369: LD_VAR 0 7
53373: PPUSH
53374: CALL_OW 488
53378: NOT
53379: IFFALSE 53401
// begin _x := x ;
53381: LD_ADDR_VAR 0 6
53385: PUSH
53386: LD_VAR 0 4
53390: ST_TO_ADDR
// _y := y ;
53391: LD_ADDR_VAR 0 7
53395: PUSH
53396: LD_VAR 0 5
53400: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
53401: LD_ADDR_VAR 0 3
53405: PUSH
53406: LD_INT 1
53408: PPUSH
53409: LD_VAR 0 14
53413: PPUSH
53414: CALL_OW 12
53418: ST_TO_ADDR
// case i of 1 :
53419: LD_VAR 0 3
53423: PUSH
53424: LD_INT 1
53426: DOUBLE
53427: EQUAL
53428: IFTRUE 53432
53430: GO 53449
53432: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
53433: LD_VAR 0 1
53437: PPUSH
53438: LD_VAR 0 10
53442: PPUSH
53443: CALL_OW 115
53447: GO 53510
53449: LD_INT 2
53451: DOUBLE
53452: EQUAL
53453: IFTRUE 53457
53455: GO 53479
53457: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
53458: LD_VAR 0 1
53462: PPUSH
53463: LD_VAR 0 6
53467: PPUSH
53468: LD_VAR 0 7
53472: PPUSH
53473: CALL_OW 153
53477: GO 53510
53479: LD_INT 3
53481: DOUBLE
53482: EQUAL
53483: IFTRUE 53487
53485: GO 53509
53487: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53488: LD_VAR 0 1
53492: PPUSH
53493: LD_VAR 0 6
53497: PPUSH
53498: LD_VAR 0 7
53502: PPUSH
53503: CALL_OW 154
53507: GO 53510
53509: POP
// end ;
53510: LD_VAR 0 2
53514: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53515: LD_INT 0
53517: PPUSH
53518: PPUSH
53519: PPUSH
53520: PPUSH
53521: PPUSH
53522: PPUSH
// if not unit or not building then
53523: LD_VAR 0 1
53527: NOT
53528: PUSH
53529: LD_VAR 0 2
53533: NOT
53534: OR
53535: IFFALSE 53539
// exit ;
53537: GO 53697
// x := GetX ( building ) ;
53539: LD_ADDR_VAR 0 5
53543: PUSH
53544: LD_VAR 0 2
53548: PPUSH
53549: CALL_OW 250
53553: ST_TO_ADDR
// y := GetY ( building ) ;
53554: LD_ADDR_VAR 0 6
53558: PUSH
53559: LD_VAR 0 2
53563: PPUSH
53564: CALL_OW 251
53568: ST_TO_ADDR
// for i = 0 to 5 do
53569: LD_ADDR_VAR 0 4
53573: PUSH
53574: DOUBLE
53575: LD_INT 0
53577: DEC
53578: ST_TO_ADDR
53579: LD_INT 5
53581: PUSH
53582: FOR_TO
53583: IFFALSE 53695
// begin _x := ShiftX ( x , i , 3 ) ;
53585: LD_ADDR_VAR 0 7
53589: PUSH
53590: LD_VAR 0 5
53594: PPUSH
53595: LD_VAR 0 4
53599: PPUSH
53600: LD_INT 3
53602: PPUSH
53603: CALL_OW 272
53607: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53608: LD_ADDR_VAR 0 8
53612: PUSH
53613: LD_VAR 0 6
53617: PPUSH
53618: LD_VAR 0 4
53622: PPUSH
53623: LD_INT 3
53625: PPUSH
53626: CALL_OW 273
53630: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53631: LD_VAR 0 7
53635: PPUSH
53636: LD_VAR 0 8
53640: PPUSH
53641: CALL_OW 488
53645: NOT
53646: IFFALSE 53650
// continue ;
53648: GO 53582
// if HexInfo ( _x , _y ) = 0 then
53650: LD_VAR 0 7
53654: PPUSH
53655: LD_VAR 0 8
53659: PPUSH
53660: CALL_OW 428
53664: PUSH
53665: LD_INT 0
53667: EQUAL
53668: IFFALSE 53693
// begin ComMoveXY ( unit , _x , _y ) ;
53670: LD_VAR 0 1
53674: PPUSH
53675: LD_VAR 0 7
53679: PPUSH
53680: LD_VAR 0 8
53684: PPUSH
53685: CALL_OW 111
// exit ;
53689: POP
53690: POP
53691: GO 53697
// end ; end ;
53693: GO 53582
53695: POP
53696: POP
// end ;
53697: LD_VAR 0 3
53701: RET
// export function ScanBase ( side , base_area ) ; begin
53702: LD_INT 0
53704: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53705: LD_ADDR_VAR 0 3
53709: PUSH
53710: LD_VAR 0 2
53714: PPUSH
53715: LD_INT 81
53717: PUSH
53718: LD_VAR 0 1
53722: PUSH
53723: EMPTY
53724: LIST
53725: LIST
53726: PPUSH
53727: CALL_OW 70
53731: ST_TO_ADDR
// end ;
53732: LD_VAR 0 3
53736: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53737: LD_INT 0
53739: PPUSH
53740: PPUSH
53741: PPUSH
53742: PPUSH
// result := false ;
53743: LD_ADDR_VAR 0 2
53747: PUSH
53748: LD_INT 0
53750: ST_TO_ADDR
// side := GetSide ( unit ) ;
53751: LD_ADDR_VAR 0 3
53755: PUSH
53756: LD_VAR 0 1
53760: PPUSH
53761: CALL_OW 255
53765: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53766: LD_ADDR_VAR 0 4
53770: PUSH
53771: LD_VAR 0 1
53775: PPUSH
53776: CALL_OW 248
53780: ST_TO_ADDR
// case nat of 1 :
53781: LD_VAR 0 4
53785: PUSH
53786: LD_INT 1
53788: DOUBLE
53789: EQUAL
53790: IFTRUE 53794
53792: GO 53805
53794: POP
// tech := tech_lassight ; 2 :
53795: LD_ADDR_VAR 0 5
53799: PUSH
53800: LD_INT 12
53802: ST_TO_ADDR
53803: GO 53844
53805: LD_INT 2
53807: DOUBLE
53808: EQUAL
53809: IFTRUE 53813
53811: GO 53824
53813: POP
// tech := tech_mortar ; 3 :
53814: LD_ADDR_VAR 0 5
53818: PUSH
53819: LD_INT 41
53821: ST_TO_ADDR
53822: GO 53844
53824: LD_INT 3
53826: DOUBLE
53827: EQUAL
53828: IFTRUE 53832
53830: GO 53843
53832: POP
// tech := tech_bazooka ; end ;
53833: LD_ADDR_VAR 0 5
53837: PUSH
53838: LD_INT 44
53840: ST_TO_ADDR
53841: GO 53844
53843: POP
// if Researched ( side , tech ) then
53844: LD_VAR 0 3
53848: PPUSH
53849: LD_VAR 0 5
53853: PPUSH
53854: CALL_OW 325
53858: IFFALSE 53885
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53860: LD_ADDR_VAR 0 2
53864: PUSH
53865: LD_INT 5
53867: PUSH
53868: LD_INT 8
53870: PUSH
53871: LD_INT 9
53873: PUSH
53874: EMPTY
53875: LIST
53876: LIST
53877: LIST
53878: PUSH
53879: LD_VAR 0 4
53883: ARRAY
53884: ST_TO_ADDR
// end ;
53885: LD_VAR 0 2
53889: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53890: LD_INT 0
53892: PPUSH
53893: PPUSH
53894: PPUSH
// if not mines then
53895: LD_VAR 0 2
53899: NOT
53900: IFFALSE 53904
// exit ;
53902: GO 54048
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53904: LD_ADDR_VAR 0 5
53908: PUSH
53909: LD_INT 81
53911: PUSH
53912: LD_VAR 0 1
53916: PUSH
53917: EMPTY
53918: LIST
53919: LIST
53920: PUSH
53921: LD_INT 3
53923: PUSH
53924: LD_INT 21
53926: PUSH
53927: LD_INT 3
53929: PUSH
53930: EMPTY
53931: LIST
53932: LIST
53933: PUSH
53934: EMPTY
53935: LIST
53936: LIST
53937: PUSH
53938: EMPTY
53939: LIST
53940: LIST
53941: PPUSH
53942: CALL_OW 69
53946: ST_TO_ADDR
// for i in mines do
53947: LD_ADDR_VAR 0 4
53951: PUSH
53952: LD_VAR 0 2
53956: PUSH
53957: FOR_IN
53958: IFFALSE 54046
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53960: LD_VAR 0 4
53964: PUSH
53965: LD_INT 1
53967: ARRAY
53968: PPUSH
53969: LD_VAR 0 4
53973: PUSH
53974: LD_INT 2
53976: ARRAY
53977: PPUSH
53978: CALL_OW 458
53982: NOT
53983: IFFALSE 53987
// continue ;
53985: GO 53957
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53987: LD_VAR 0 4
53991: PUSH
53992: LD_INT 1
53994: ARRAY
53995: PPUSH
53996: LD_VAR 0 4
54000: PUSH
54001: LD_INT 2
54003: ARRAY
54004: PPUSH
54005: CALL_OW 428
54009: PUSH
54010: LD_VAR 0 5
54014: IN
54015: IFFALSE 54044
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54017: LD_VAR 0 4
54021: PUSH
54022: LD_INT 1
54024: ARRAY
54025: PPUSH
54026: LD_VAR 0 4
54030: PUSH
54031: LD_INT 2
54033: ARRAY
54034: PPUSH
54035: LD_VAR 0 1
54039: PPUSH
54040: CALL_OW 456
// end ;
54044: GO 53957
54046: POP
54047: POP
// end ;
54048: LD_VAR 0 3
54052: RET
// export function Count ( array ) ; var i ; begin
54053: LD_INT 0
54055: PPUSH
54056: PPUSH
// result := 0 ;
54057: LD_ADDR_VAR 0 2
54061: PUSH
54062: LD_INT 0
54064: ST_TO_ADDR
// for i in array do
54065: LD_ADDR_VAR 0 3
54069: PUSH
54070: LD_VAR 0 1
54074: PUSH
54075: FOR_IN
54076: IFFALSE 54100
// if i then
54078: LD_VAR 0 3
54082: IFFALSE 54098
// result := result + 1 ;
54084: LD_ADDR_VAR 0 2
54088: PUSH
54089: LD_VAR 0 2
54093: PUSH
54094: LD_INT 1
54096: PLUS
54097: ST_TO_ADDR
54098: GO 54075
54100: POP
54101: POP
// end ;
54102: LD_VAR 0 2
54106: RET
// export function IsEmpty ( building ) ; begin
54107: LD_INT 0
54109: PPUSH
// if not building then
54110: LD_VAR 0 1
54114: NOT
54115: IFFALSE 54119
// exit ;
54117: GO 54162
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54119: LD_ADDR_VAR 0 2
54123: PUSH
54124: LD_VAR 0 1
54128: PUSH
54129: LD_INT 22
54131: PUSH
54132: LD_VAR 0 1
54136: PPUSH
54137: CALL_OW 255
54141: PUSH
54142: EMPTY
54143: LIST
54144: LIST
54145: PUSH
54146: LD_INT 58
54148: PUSH
54149: EMPTY
54150: LIST
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: PPUSH
54156: CALL_OW 69
54160: IN
54161: ST_TO_ADDR
// end ;
54162: LD_VAR 0 2
54166: RET
// export function IsNotFull ( building ) ; var places ; begin
54167: LD_INT 0
54169: PPUSH
54170: PPUSH
// if not building then
54171: LD_VAR 0 1
54175: NOT
54176: IFFALSE 54180
// exit ;
54178: GO 54351
// result := false ;
54180: LD_ADDR_VAR 0 2
54184: PUSH
54185: LD_INT 0
54187: ST_TO_ADDR
// places := 0 ;
54188: LD_ADDR_VAR 0 3
54192: PUSH
54193: LD_INT 0
54195: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
54196: LD_VAR 0 1
54200: PPUSH
54201: CALL_OW 266
54205: PUSH
54206: LD_INT 0
54208: DOUBLE
54209: EQUAL
54210: IFTRUE 54268
54212: LD_INT 1
54214: DOUBLE
54215: EQUAL
54216: IFTRUE 54268
54218: LD_INT 6
54220: DOUBLE
54221: EQUAL
54222: IFTRUE 54268
54224: LD_INT 7
54226: DOUBLE
54227: EQUAL
54228: IFTRUE 54268
54230: LD_INT 8
54232: DOUBLE
54233: EQUAL
54234: IFTRUE 54268
54236: LD_INT 4
54238: DOUBLE
54239: EQUAL
54240: IFTRUE 54268
54242: LD_INT 5
54244: DOUBLE
54245: EQUAL
54246: IFTRUE 54268
54248: LD_INT 2
54250: DOUBLE
54251: EQUAL
54252: IFTRUE 54268
54254: LD_INT 3
54256: DOUBLE
54257: EQUAL
54258: IFTRUE 54268
54260: LD_INT 35
54262: DOUBLE
54263: EQUAL
54264: IFTRUE 54268
54266: GO 54279
54268: POP
// places := 6 ; b_bunker , b_breastwork :
54269: LD_ADDR_VAR 0 3
54273: PUSH
54274: LD_INT 6
54276: ST_TO_ADDR
54277: GO 54324
54279: LD_INT 32
54281: DOUBLE
54282: EQUAL
54283: IFTRUE 54293
54285: LD_INT 31
54287: DOUBLE
54288: EQUAL
54289: IFTRUE 54293
54291: GO 54304
54293: POP
// places := 1 ; b_control_tower :
54294: LD_ADDR_VAR 0 3
54298: PUSH
54299: LD_INT 1
54301: ST_TO_ADDR
54302: GO 54324
54304: LD_INT 36
54306: DOUBLE
54307: EQUAL
54308: IFTRUE 54312
54310: GO 54323
54312: POP
// places := 3 ; end ;
54313: LD_ADDR_VAR 0 3
54317: PUSH
54318: LD_INT 3
54320: ST_TO_ADDR
54321: GO 54324
54323: POP
// if places then
54324: LD_VAR 0 3
54328: IFFALSE 54351
// result := UnitsInside ( building ) < places ;
54330: LD_ADDR_VAR 0 2
54334: PUSH
54335: LD_VAR 0 1
54339: PPUSH
54340: CALL_OW 313
54344: PUSH
54345: LD_VAR 0 3
54349: LESS
54350: ST_TO_ADDR
// end ;
54351: LD_VAR 0 2
54355: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54356: LD_INT 0
54358: PPUSH
54359: PPUSH
54360: PPUSH
54361: PPUSH
// tmp := [ ] ;
54362: LD_ADDR_VAR 0 3
54366: PUSH
54367: EMPTY
54368: ST_TO_ADDR
// list := [ ] ;
54369: LD_ADDR_VAR 0 5
54373: PUSH
54374: EMPTY
54375: ST_TO_ADDR
// for i = 16 to 25 do
54376: LD_ADDR_VAR 0 4
54380: PUSH
54381: DOUBLE
54382: LD_INT 16
54384: DEC
54385: ST_TO_ADDR
54386: LD_INT 25
54388: PUSH
54389: FOR_TO
54390: IFFALSE 54463
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54392: LD_ADDR_VAR 0 3
54396: PUSH
54397: LD_VAR 0 3
54401: PUSH
54402: LD_INT 22
54404: PUSH
54405: LD_VAR 0 1
54409: PPUSH
54410: CALL_OW 255
54414: PUSH
54415: EMPTY
54416: LIST
54417: LIST
54418: PUSH
54419: LD_INT 91
54421: PUSH
54422: LD_VAR 0 1
54426: PUSH
54427: LD_INT 6
54429: PUSH
54430: EMPTY
54431: LIST
54432: LIST
54433: LIST
54434: PUSH
54435: LD_INT 30
54437: PUSH
54438: LD_VAR 0 4
54442: PUSH
54443: EMPTY
54444: LIST
54445: LIST
54446: PUSH
54447: EMPTY
54448: LIST
54449: LIST
54450: LIST
54451: PUSH
54452: EMPTY
54453: LIST
54454: PPUSH
54455: CALL_OW 69
54459: ADD
54460: ST_TO_ADDR
54461: GO 54389
54463: POP
54464: POP
// for i = 1 to tmp do
54465: LD_ADDR_VAR 0 4
54469: PUSH
54470: DOUBLE
54471: LD_INT 1
54473: DEC
54474: ST_TO_ADDR
54475: LD_VAR 0 3
54479: PUSH
54480: FOR_TO
54481: IFFALSE 54569
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54483: LD_ADDR_VAR 0 5
54487: PUSH
54488: LD_VAR 0 5
54492: PUSH
54493: LD_VAR 0 3
54497: PUSH
54498: LD_VAR 0 4
54502: ARRAY
54503: PPUSH
54504: CALL_OW 266
54508: PUSH
54509: LD_VAR 0 3
54513: PUSH
54514: LD_VAR 0 4
54518: ARRAY
54519: PPUSH
54520: CALL_OW 250
54524: PUSH
54525: LD_VAR 0 3
54529: PUSH
54530: LD_VAR 0 4
54534: ARRAY
54535: PPUSH
54536: CALL_OW 251
54540: PUSH
54541: LD_VAR 0 3
54545: PUSH
54546: LD_VAR 0 4
54550: ARRAY
54551: PPUSH
54552: CALL_OW 254
54556: PUSH
54557: EMPTY
54558: LIST
54559: LIST
54560: LIST
54561: LIST
54562: PUSH
54563: EMPTY
54564: LIST
54565: ADD
54566: ST_TO_ADDR
54567: GO 54480
54569: POP
54570: POP
// result := list ;
54571: LD_ADDR_VAR 0 2
54575: PUSH
54576: LD_VAR 0 5
54580: ST_TO_ADDR
// end ;
54581: LD_VAR 0 2
54585: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54586: LD_INT 0
54588: PPUSH
54589: PPUSH
54590: PPUSH
54591: PPUSH
54592: PPUSH
54593: PPUSH
54594: PPUSH
// if not factory then
54595: LD_VAR 0 1
54599: NOT
54600: IFFALSE 54604
// exit ;
54602: GO 55197
// if control = control_apeman then
54604: LD_VAR 0 4
54608: PUSH
54609: LD_INT 5
54611: EQUAL
54612: IFFALSE 54721
// begin tmp := UnitsInside ( factory ) ;
54614: LD_ADDR_VAR 0 8
54618: PUSH
54619: LD_VAR 0 1
54623: PPUSH
54624: CALL_OW 313
54628: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54629: LD_VAR 0 8
54633: PPUSH
54634: LD_INT 25
54636: PUSH
54637: LD_INT 12
54639: PUSH
54640: EMPTY
54641: LIST
54642: LIST
54643: PPUSH
54644: CALL_OW 72
54648: NOT
54649: IFFALSE 54659
// control := control_manual ;
54651: LD_ADDR_VAR 0 4
54655: PUSH
54656: LD_INT 1
54658: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54659: LD_ADDR_VAR 0 8
54663: PUSH
54664: LD_VAR 0 1
54668: PPUSH
54669: CALL 54356 0 1
54673: ST_TO_ADDR
// if tmp then
54674: LD_VAR 0 8
54678: IFFALSE 54721
// begin for i in tmp do
54680: LD_ADDR_VAR 0 7
54684: PUSH
54685: LD_VAR 0 8
54689: PUSH
54690: FOR_IN
54691: IFFALSE 54719
// if i [ 1 ] = b_ext_radio then
54693: LD_VAR 0 7
54697: PUSH
54698: LD_INT 1
54700: ARRAY
54701: PUSH
54702: LD_INT 22
54704: EQUAL
54705: IFFALSE 54717
// begin control := control_remote ;
54707: LD_ADDR_VAR 0 4
54711: PUSH
54712: LD_INT 2
54714: ST_TO_ADDR
// break ;
54715: GO 54719
// end ;
54717: GO 54690
54719: POP
54720: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54721: LD_VAR 0 1
54725: PPUSH
54726: LD_VAR 0 2
54730: PPUSH
54731: LD_VAR 0 3
54735: PPUSH
54736: LD_VAR 0 4
54740: PPUSH
54741: LD_VAR 0 5
54745: PPUSH
54746: CALL_OW 448
54750: IFFALSE 54785
// begin result := [ chassis , engine , control , weapon ] ;
54752: LD_ADDR_VAR 0 6
54756: PUSH
54757: LD_VAR 0 2
54761: PUSH
54762: LD_VAR 0 3
54766: PUSH
54767: LD_VAR 0 4
54771: PUSH
54772: LD_VAR 0 5
54776: PUSH
54777: EMPTY
54778: LIST
54779: LIST
54780: LIST
54781: LIST
54782: ST_TO_ADDR
// exit ;
54783: GO 55197
// end ; _chassis := AvailableChassisList ( factory ) ;
54785: LD_ADDR_VAR 0 9
54789: PUSH
54790: LD_VAR 0 1
54794: PPUSH
54795: CALL_OW 475
54799: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54800: LD_ADDR_VAR 0 11
54804: PUSH
54805: LD_VAR 0 1
54809: PPUSH
54810: CALL_OW 476
54814: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54815: LD_ADDR_VAR 0 12
54819: PUSH
54820: LD_VAR 0 1
54824: PPUSH
54825: CALL_OW 477
54829: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54830: LD_ADDR_VAR 0 10
54834: PUSH
54835: LD_VAR 0 1
54839: PPUSH
54840: CALL_OW 478
54844: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54845: LD_VAR 0 9
54849: NOT
54850: PUSH
54851: LD_VAR 0 11
54855: NOT
54856: OR
54857: PUSH
54858: LD_VAR 0 12
54862: NOT
54863: OR
54864: PUSH
54865: LD_VAR 0 10
54869: NOT
54870: OR
54871: IFFALSE 54906
// begin result := [ chassis , engine , control , weapon ] ;
54873: LD_ADDR_VAR 0 6
54877: PUSH
54878: LD_VAR 0 2
54882: PUSH
54883: LD_VAR 0 3
54887: PUSH
54888: LD_VAR 0 4
54892: PUSH
54893: LD_VAR 0 5
54897: PUSH
54898: EMPTY
54899: LIST
54900: LIST
54901: LIST
54902: LIST
54903: ST_TO_ADDR
// exit ;
54904: GO 55197
// end ; if not chassis in _chassis then
54906: LD_VAR 0 2
54910: PUSH
54911: LD_VAR 0 9
54915: IN
54916: NOT
54917: IFFALSE 54943
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54919: LD_ADDR_VAR 0 2
54923: PUSH
54924: LD_VAR 0 9
54928: PUSH
54929: LD_INT 1
54931: PPUSH
54932: LD_VAR 0 9
54936: PPUSH
54937: CALL_OW 12
54941: ARRAY
54942: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54943: LD_VAR 0 2
54947: PPUSH
54948: LD_VAR 0 3
54952: PPUSH
54953: CALL 55202 0 2
54957: NOT
54958: IFFALSE 55017
// repeat engine := _engine [ 1 ] ;
54960: LD_ADDR_VAR 0 3
54964: PUSH
54965: LD_VAR 0 11
54969: PUSH
54970: LD_INT 1
54972: ARRAY
54973: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54974: LD_ADDR_VAR 0 11
54978: PUSH
54979: LD_VAR 0 11
54983: PPUSH
54984: LD_INT 1
54986: PPUSH
54987: CALL_OW 3
54991: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54992: LD_VAR 0 2
54996: PPUSH
54997: LD_VAR 0 3
55001: PPUSH
55002: CALL 55202 0 2
55006: PUSH
55007: LD_VAR 0 11
55011: PUSH
55012: EMPTY
55013: EQUAL
55014: OR
55015: IFFALSE 54960
// if not control in _control then
55017: LD_VAR 0 4
55021: PUSH
55022: LD_VAR 0 12
55026: IN
55027: NOT
55028: IFFALSE 55054
// control := _control [ rand ( 1 , _control ) ] ;
55030: LD_ADDR_VAR 0 4
55034: PUSH
55035: LD_VAR 0 12
55039: PUSH
55040: LD_INT 1
55042: PPUSH
55043: LD_VAR 0 12
55047: PPUSH
55048: CALL_OW 12
55052: ARRAY
55053: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55054: LD_VAR 0 2
55058: PPUSH
55059: LD_VAR 0 5
55063: PPUSH
55064: CALL 55422 0 2
55068: NOT
55069: IFFALSE 55128
// repeat weapon := _weapon [ 1 ] ;
55071: LD_ADDR_VAR 0 5
55075: PUSH
55076: LD_VAR 0 10
55080: PUSH
55081: LD_INT 1
55083: ARRAY
55084: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55085: LD_ADDR_VAR 0 10
55089: PUSH
55090: LD_VAR 0 10
55094: PPUSH
55095: LD_INT 1
55097: PPUSH
55098: CALL_OW 3
55102: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55103: LD_VAR 0 2
55107: PPUSH
55108: LD_VAR 0 5
55112: PPUSH
55113: CALL 55422 0 2
55117: PUSH
55118: LD_VAR 0 10
55122: PUSH
55123: EMPTY
55124: EQUAL
55125: OR
55126: IFFALSE 55071
// result := [ ] ;
55128: LD_ADDR_VAR 0 6
55132: PUSH
55133: EMPTY
55134: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55135: LD_VAR 0 1
55139: PPUSH
55140: LD_VAR 0 2
55144: PPUSH
55145: LD_VAR 0 3
55149: PPUSH
55150: LD_VAR 0 4
55154: PPUSH
55155: LD_VAR 0 5
55159: PPUSH
55160: CALL_OW 448
55164: IFFALSE 55197
// result := [ chassis , engine , control , weapon ] ;
55166: LD_ADDR_VAR 0 6
55170: PUSH
55171: LD_VAR 0 2
55175: PUSH
55176: LD_VAR 0 3
55180: PUSH
55181: LD_VAR 0 4
55185: PUSH
55186: LD_VAR 0 5
55190: PUSH
55191: EMPTY
55192: LIST
55193: LIST
55194: LIST
55195: LIST
55196: ST_TO_ADDR
// end ;
55197: LD_VAR 0 6
55201: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55202: LD_INT 0
55204: PPUSH
// if not chassis or not engine then
55205: LD_VAR 0 1
55209: NOT
55210: PUSH
55211: LD_VAR 0 2
55215: NOT
55216: OR
55217: IFFALSE 55221
// exit ;
55219: GO 55417
// case engine of engine_solar :
55221: LD_VAR 0 2
55225: PUSH
55226: LD_INT 2
55228: DOUBLE
55229: EQUAL
55230: IFTRUE 55234
55232: GO 55272
55234: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55235: LD_ADDR_VAR 0 3
55239: PUSH
55240: LD_INT 11
55242: PUSH
55243: LD_INT 12
55245: PUSH
55246: LD_INT 13
55248: PUSH
55249: LD_INT 14
55251: PUSH
55252: LD_INT 1
55254: PUSH
55255: LD_INT 2
55257: PUSH
55258: LD_INT 3
55260: PUSH
55261: EMPTY
55262: LIST
55263: LIST
55264: LIST
55265: LIST
55266: LIST
55267: LIST
55268: LIST
55269: ST_TO_ADDR
55270: GO 55401
55272: LD_INT 1
55274: DOUBLE
55275: EQUAL
55276: IFTRUE 55280
55278: GO 55342
55280: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55281: LD_ADDR_VAR 0 3
55285: PUSH
55286: LD_INT 11
55288: PUSH
55289: LD_INT 12
55291: PUSH
55292: LD_INT 13
55294: PUSH
55295: LD_INT 14
55297: PUSH
55298: LD_INT 1
55300: PUSH
55301: LD_INT 2
55303: PUSH
55304: LD_INT 3
55306: PUSH
55307: LD_INT 4
55309: PUSH
55310: LD_INT 5
55312: PUSH
55313: LD_INT 21
55315: PUSH
55316: LD_INT 23
55318: PUSH
55319: LD_INT 22
55321: PUSH
55322: LD_INT 24
55324: PUSH
55325: EMPTY
55326: LIST
55327: LIST
55328: LIST
55329: LIST
55330: LIST
55331: LIST
55332: LIST
55333: LIST
55334: LIST
55335: LIST
55336: LIST
55337: LIST
55338: LIST
55339: ST_TO_ADDR
55340: GO 55401
55342: LD_INT 3
55344: DOUBLE
55345: EQUAL
55346: IFTRUE 55350
55348: GO 55400
55350: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55351: LD_ADDR_VAR 0 3
55355: PUSH
55356: LD_INT 13
55358: PUSH
55359: LD_INT 14
55361: PUSH
55362: LD_INT 2
55364: PUSH
55365: LD_INT 3
55367: PUSH
55368: LD_INT 4
55370: PUSH
55371: LD_INT 5
55373: PUSH
55374: LD_INT 21
55376: PUSH
55377: LD_INT 22
55379: PUSH
55380: LD_INT 23
55382: PUSH
55383: LD_INT 24
55385: PUSH
55386: EMPTY
55387: LIST
55388: LIST
55389: LIST
55390: LIST
55391: LIST
55392: LIST
55393: LIST
55394: LIST
55395: LIST
55396: LIST
55397: ST_TO_ADDR
55398: GO 55401
55400: POP
// result := ( chassis in result ) ;
55401: LD_ADDR_VAR 0 3
55405: PUSH
55406: LD_VAR 0 1
55410: PUSH
55411: LD_VAR 0 3
55415: IN
55416: ST_TO_ADDR
// end ;
55417: LD_VAR 0 3
55421: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55422: LD_INT 0
55424: PPUSH
// if not chassis or not weapon then
55425: LD_VAR 0 1
55429: NOT
55430: PUSH
55431: LD_VAR 0 2
55435: NOT
55436: OR
55437: IFFALSE 55441
// exit ;
55439: GO 56501
// case weapon of us_machine_gun :
55441: LD_VAR 0 2
55445: PUSH
55446: LD_INT 2
55448: DOUBLE
55449: EQUAL
55450: IFTRUE 55454
55452: GO 55484
55454: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55455: LD_ADDR_VAR 0 3
55459: PUSH
55460: LD_INT 1
55462: PUSH
55463: LD_INT 2
55465: PUSH
55466: LD_INT 3
55468: PUSH
55469: LD_INT 4
55471: PUSH
55472: LD_INT 5
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: LIST
55479: LIST
55480: LIST
55481: ST_TO_ADDR
55482: GO 56485
55484: LD_INT 3
55486: DOUBLE
55487: EQUAL
55488: IFTRUE 55492
55490: GO 55522
55492: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55493: LD_ADDR_VAR 0 3
55497: PUSH
55498: LD_INT 1
55500: PUSH
55501: LD_INT 2
55503: PUSH
55504: LD_INT 3
55506: PUSH
55507: LD_INT 4
55509: PUSH
55510: LD_INT 5
55512: PUSH
55513: EMPTY
55514: LIST
55515: LIST
55516: LIST
55517: LIST
55518: LIST
55519: ST_TO_ADDR
55520: GO 56485
55522: LD_INT 11
55524: DOUBLE
55525: EQUAL
55526: IFTRUE 55530
55528: GO 55560
55530: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55531: LD_ADDR_VAR 0 3
55535: PUSH
55536: LD_INT 1
55538: PUSH
55539: LD_INT 2
55541: PUSH
55542: LD_INT 3
55544: PUSH
55545: LD_INT 4
55547: PUSH
55548: LD_INT 5
55550: PUSH
55551: EMPTY
55552: LIST
55553: LIST
55554: LIST
55555: LIST
55556: LIST
55557: ST_TO_ADDR
55558: GO 56485
55560: LD_INT 4
55562: DOUBLE
55563: EQUAL
55564: IFTRUE 55568
55566: GO 55594
55568: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55569: LD_ADDR_VAR 0 3
55573: PUSH
55574: LD_INT 2
55576: PUSH
55577: LD_INT 3
55579: PUSH
55580: LD_INT 4
55582: PUSH
55583: LD_INT 5
55585: PUSH
55586: EMPTY
55587: LIST
55588: LIST
55589: LIST
55590: LIST
55591: ST_TO_ADDR
55592: GO 56485
55594: LD_INT 5
55596: DOUBLE
55597: EQUAL
55598: IFTRUE 55602
55600: GO 55628
55602: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55603: LD_ADDR_VAR 0 3
55607: PUSH
55608: LD_INT 2
55610: PUSH
55611: LD_INT 3
55613: PUSH
55614: LD_INT 4
55616: PUSH
55617: LD_INT 5
55619: PUSH
55620: EMPTY
55621: LIST
55622: LIST
55623: LIST
55624: LIST
55625: ST_TO_ADDR
55626: GO 56485
55628: LD_INT 9
55630: DOUBLE
55631: EQUAL
55632: IFTRUE 55636
55634: GO 55662
55636: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55637: LD_ADDR_VAR 0 3
55641: PUSH
55642: LD_INT 2
55644: PUSH
55645: LD_INT 3
55647: PUSH
55648: LD_INT 4
55650: PUSH
55651: LD_INT 5
55653: PUSH
55654: EMPTY
55655: LIST
55656: LIST
55657: LIST
55658: LIST
55659: ST_TO_ADDR
55660: GO 56485
55662: LD_INT 7
55664: DOUBLE
55665: EQUAL
55666: IFTRUE 55670
55668: GO 55696
55670: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55671: LD_ADDR_VAR 0 3
55675: PUSH
55676: LD_INT 2
55678: PUSH
55679: LD_INT 3
55681: PUSH
55682: LD_INT 4
55684: PUSH
55685: LD_INT 5
55687: PUSH
55688: EMPTY
55689: LIST
55690: LIST
55691: LIST
55692: LIST
55693: ST_TO_ADDR
55694: GO 56485
55696: LD_INT 12
55698: DOUBLE
55699: EQUAL
55700: IFTRUE 55704
55702: GO 55730
55704: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55705: LD_ADDR_VAR 0 3
55709: PUSH
55710: LD_INT 2
55712: PUSH
55713: LD_INT 3
55715: PUSH
55716: LD_INT 4
55718: PUSH
55719: LD_INT 5
55721: PUSH
55722: EMPTY
55723: LIST
55724: LIST
55725: LIST
55726: LIST
55727: ST_TO_ADDR
55728: GO 56485
55730: LD_INT 13
55732: DOUBLE
55733: EQUAL
55734: IFTRUE 55738
55736: GO 55764
55738: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55739: LD_ADDR_VAR 0 3
55743: PUSH
55744: LD_INT 2
55746: PUSH
55747: LD_INT 3
55749: PUSH
55750: LD_INT 4
55752: PUSH
55753: LD_INT 5
55755: PUSH
55756: EMPTY
55757: LIST
55758: LIST
55759: LIST
55760: LIST
55761: ST_TO_ADDR
55762: GO 56485
55764: LD_INT 14
55766: DOUBLE
55767: EQUAL
55768: IFTRUE 55772
55770: GO 55790
55772: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55773: LD_ADDR_VAR 0 3
55777: PUSH
55778: LD_INT 4
55780: PUSH
55781: LD_INT 5
55783: PUSH
55784: EMPTY
55785: LIST
55786: LIST
55787: ST_TO_ADDR
55788: GO 56485
55790: LD_INT 6
55792: DOUBLE
55793: EQUAL
55794: IFTRUE 55798
55796: GO 55816
55798: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55799: LD_ADDR_VAR 0 3
55803: PUSH
55804: LD_INT 4
55806: PUSH
55807: LD_INT 5
55809: PUSH
55810: EMPTY
55811: LIST
55812: LIST
55813: ST_TO_ADDR
55814: GO 56485
55816: LD_INT 10
55818: DOUBLE
55819: EQUAL
55820: IFTRUE 55824
55822: GO 55842
55824: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55825: LD_ADDR_VAR 0 3
55829: PUSH
55830: LD_INT 4
55832: PUSH
55833: LD_INT 5
55835: PUSH
55836: EMPTY
55837: LIST
55838: LIST
55839: ST_TO_ADDR
55840: GO 56485
55842: LD_INT 22
55844: DOUBLE
55845: EQUAL
55846: IFTRUE 55850
55848: GO 55876
55850: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55851: LD_ADDR_VAR 0 3
55855: PUSH
55856: LD_INT 11
55858: PUSH
55859: LD_INT 12
55861: PUSH
55862: LD_INT 13
55864: PUSH
55865: LD_INT 14
55867: PUSH
55868: EMPTY
55869: LIST
55870: LIST
55871: LIST
55872: LIST
55873: ST_TO_ADDR
55874: GO 56485
55876: LD_INT 23
55878: DOUBLE
55879: EQUAL
55880: IFTRUE 55884
55882: GO 55910
55884: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55885: LD_ADDR_VAR 0 3
55889: PUSH
55890: LD_INT 11
55892: PUSH
55893: LD_INT 12
55895: PUSH
55896: LD_INT 13
55898: PUSH
55899: LD_INT 14
55901: PUSH
55902: EMPTY
55903: LIST
55904: LIST
55905: LIST
55906: LIST
55907: ST_TO_ADDR
55908: GO 56485
55910: LD_INT 24
55912: DOUBLE
55913: EQUAL
55914: IFTRUE 55918
55916: GO 55944
55918: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55919: LD_ADDR_VAR 0 3
55923: PUSH
55924: LD_INT 11
55926: PUSH
55927: LD_INT 12
55929: PUSH
55930: LD_INT 13
55932: PUSH
55933: LD_INT 14
55935: PUSH
55936: EMPTY
55937: LIST
55938: LIST
55939: LIST
55940: LIST
55941: ST_TO_ADDR
55942: GO 56485
55944: LD_INT 30
55946: DOUBLE
55947: EQUAL
55948: IFTRUE 55952
55950: GO 55978
55952: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55953: LD_ADDR_VAR 0 3
55957: PUSH
55958: LD_INT 11
55960: PUSH
55961: LD_INT 12
55963: PUSH
55964: LD_INT 13
55966: PUSH
55967: LD_INT 14
55969: PUSH
55970: EMPTY
55971: LIST
55972: LIST
55973: LIST
55974: LIST
55975: ST_TO_ADDR
55976: GO 56485
55978: LD_INT 25
55980: DOUBLE
55981: EQUAL
55982: IFTRUE 55986
55984: GO 56004
55986: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55987: LD_ADDR_VAR 0 3
55991: PUSH
55992: LD_INT 13
55994: PUSH
55995: LD_INT 14
55997: PUSH
55998: EMPTY
55999: LIST
56000: LIST
56001: ST_TO_ADDR
56002: GO 56485
56004: LD_INT 27
56006: DOUBLE
56007: EQUAL
56008: IFTRUE 56012
56010: GO 56030
56012: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
56013: LD_ADDR_VAR 0 3
56017: PUSH
56018: LD_INT 13
56020: PUSH
56021: LD_INT 14
56023: PUSH
56024: EMPTY
56025: LIST
56026: LIST
56027: ST_TO_ADDR
56028: GO 56485
56030: LD_INT 92
56032: DOUBLE
56033: EQUAL
56034: IFTRUE 56038
56036: GO 56064
56038: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56039: LD_ADDR_VAR 0 3
56043: PUSH
56044: LD_INT 11
56046: PUSH
56047: LD_INT 12
56049: PUSH
56050: LD_INT 13
56052: PUSH
56053: LD_INT 14
56055: PUSH
56056: EMPTY
56057: LIST
56058: LIST
56059: LIST
56060: LIST
56061: ST_TO_ADDR
56062: GO 56485
56064: LD_INT 28
56066: DOUBLE
56067: EQUAL
56068: IFTRUE 56072
56070: GO 56090
56072: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56073: LD_ADDR_VAR 0 3
56077: PUSH
56078: LD_INT 13
56080: PUSH
56081: LD_INT 14
56083: PUSH
56084: EMPTY
56085: LIST
56086: LIST
56087: ST_TO_ADDR
56088: GO 56485
56090: LD_INT 29
56092: DOUBLE
56093: EQUAL
56094: IFTRUE 56098
56096: GO 56116
56098: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56099: LD_ADDR_VAR 0 3
56103: PUSH
56104: LD_INT 13
56106: PUSH
56107: LD_INT 14
56109: PUSH
56110: EMPTY
56111: LIST
56112: LIST
56113: ST_TO_ADDR
56114: GO 56485
56116: LD_INT 31
56118: DOUBLE
56119: EQUAL
56120: IFTRUE 56124
56122: GO 56142
56124: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56125: LD_ADDR_VAR 0 3
56129: PUSH
56130: LD_INT 13
56132: PUSH
56133: LD_INT 14
56135: PUSH
56136: EMPTY
56137: LIST
56138: LIST
56139: ST_TO_ADDR
56140: GO 56485
56142: LD_INT 26
56144: DOUBLE
56145: EQUAL
56146: IFTRUE 56150
56148: GO 56168
56150: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56151: LD_ADDR_VAR 0 3
56155: PUSH
56156: LD_INT 13
56158: PUSH
56159: LD_INT 14
56161: PUSH
56162: EMPTY
56163: LIST
56164: LIST
56165: ST_TO_ADDR
56166: GO 56485
56168: LD_INT 42
56170: DOUBLE
56171: EQUAL
56172: IFTRUE 56176
56174: GO 56202
56176: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56177: LD_ADDR_VAR 0 3
56181: PUSH
56182: LD_INT 21
56184: PUSH
56185: LD_INT 22
56187: PUSH
56188: LD_INT 23
56190: PUSH
56191: LD_INT 24
56193: PUSH
56194: EMPTY
56195: LIST
56196: LIST
56197: LIST
56198: LIST
56199: ST_TO_ADDR
56200: GO 56485
56202: LD_INT 43
56204: DOUBLE
56205: EQUAL
56206: IFTRUE 56210
56208: GO 56236
56210: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56211: LD_ADDR_VAR 0 3
56215: PUSH
56216: LD_INT 21
56218: PUSH
56219: LD_INT 22
56221: PUSH
56222: LD_INT 23
56224: PUSH
56225: LD_INT 24
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: LIST
56232: LIST
56233: ST_TO_ADDR
56234: GO 56485
56236: LD_INT 44
56238: DOUBLE
56239: EQUAL
56240: IFTRUE 56244
56242: GO 56270
56244: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56245: LD_ADDR_VAR 0 3
56249: PUSH
56250: LD_INT 21
56252: PUSH
56253: LD_INT 22
56255: PUSH
56256: LD_INT 23
56258: PUSH
56259: LD_INT 24
56261: PUSH
56262: EMPTY
56263: LIST
56264: LIST
56265: LIST
56266: LIST
56267: ST_TO_ADDR
56268: GO 56485
56270: LD_INT 45
56272: DOUBLE
56273: EQUAL
56274: IFTRUE 56278
56276: GO 56304
56278: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56279: LD_ADDR_VAR 0 3
56283: PUSH
56284: LD_INT 21
56286: PUSH
56287: LD_INT 22
56289: PUSH
56290: LD_INT 23
56292: PUSH
56293: LD_INT 24
56295: PUSH
56296: EMPTY
56297: LIST
56298: LIST
56299: LIST
56300: LIST
56301: ST_TO_ADDR
56302: GO 56485
56304: LD_INT 49
56306: DOUBLE
56307: EQUAL
56308: IFTRUE 56312
56310: GO 56338
56312: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56313: LD_ADDR_VAR 0 3
56317: PUSH
56318: LD_INT 21
56320: PUSH
56321: LD_INT 22
56323: PUSH
56324: LD_INT 23
56326: PUSH
56327: LD_INT 24
56329: PUSH
56330: EMPTY
56331: LIST
56332: LIST
56333: LIST
56334: LIST
56335: ST_TO_ADDR
56336: GO 56485
56338: LD_INT 51
56340: DOUBLE
56341: EQUAL
56342: IFTRUE 56346
56344: GO 56372
56346: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56347: LD_ADDR_VAR 0 3
56351: PUSH
56352: LD_INT 21
56354: PUSH
56355: LD_INT 22
56357: PUSH
56358: LD_INT 23
56360: PUSH
56361: LD_INT 24
56363: PUSH
56364: EMPTY
56365: LIST
56366: LIST
56367: LIST
56368: LIST
56369: ST_TO_ADDR
56370: GO 56485
56372: LD_INT 52
56374: DOUBLE
56375: EQUAL
56376: IFTRUE 56380
56378: GO 56406
56380: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56381: LD_ADDR_VAR 0 3
56385: PUSH
56386: LD_INT 21
56388: PUSH
56389: LD_INT 22
56391: PUSH
56392: LD_INT 23
56394: PUSH
56395: LD_INT 24
56397: PUSH
56398: EMPTY
56399: LIST
56400: LIST
56401: LIST
56402: LIST
56403: ST_TO_ADDR
56404: GO 56485
56406: LD_INT 53
56408: DOUBLE
56409: EQUAL
56410: IFTRUE 56414
56412: GO 56432
56414: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56415: LD_ADDR_VAR 0 3
56419: PUSH
56420: LD_INT 23
56422: PUSH
56423: LD_INT 24
56425: PUSH
56426: EMPTY
56427: LIST
56428: LIST
56429: ST_TO_ADDR
56430: GO 56485
56432: LD_INT 46
56434: DOUBLE
56435: EQUAL
56436: IFTRUE 56440
56438: GO 56458
56440: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56441: LD_ADDR_VAR 0 3
56445: PUSH
56446: LD_INT 23
56448: PUSH
56449: LD_INT 24
56451: PUSH
56452: EMPTY
56453: LIST
56454: LIST
56455: ST_TO_ADDR
56456: GO 56485
56458: LD_INT 47
56460: DOUBLE
56461: EQUAL
56462: IFTRUE 56466
56464: GO 56484
56466: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56467: LD_ADDR_VAR 0 3
56471: PUSH
56472: LD_INT 23
56474: PUSH
56475: LD_INT 24
56477: PUSH
56478: EMPTY
56479: LIST
56480: LIST
56481: ST_TO_ADDR
56482: GO 56485
56484: POP
// result := ( chassis in result ) ;
56485: LD_ADDR_VAR 0 3
56489: PUSH
56490: LD_VAR 0 1
56494: PUSH
56495: LD_VAR 0 3
56499: IN
56500: ST_TO_ADDR
// end ;
56501: LD_VAR 0 3
56505: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56506: LD_INT 0
56508: PPUSH
56509: PPUSH
56510: PPUSH
56511: PPUSH
56512: PPUSH
56513: PPUSH
56514: PPUSH
// result := array ;
56515: LD_ADDR_VAR 0 5
56519: PUSH
56520: LD_VAR 0 1
56524: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56525: LD_VAR 0 1
56529: NOT
56530: PUSH
56531: LD_VAR 0 2
56535: NOT
56536: OR
56537: PUSH
56538: LD_VAR 0 3
56542: NOT
56543: OR
56544: PUSH
56545: LD_VAR 0 2
56549: PUSH
56550: LD_VAR 0 1
56554: GREATER
56555: OR
56556: PUSH
56557: LD_VAR 0 3
56561: PUSH
56562: LD_VAR 0 1
56566: GREATER
56567: OR
56568: IFFALSE 56572
// exit ;
56570: GO 56868
// if direction then
56572: LD_VAR 0 4
56576: IFFALSE 56640
// begin d := 1 ;
56578: LD_ADDR_VAR 0 9
56582: PUSH
56583: LD_INT 1
56585: ST_TO_ADDR
// if i_from > i_to then
56586: LD_VAR 0 2
56590: PUSH
56591: LD_VAR 0 3
56595: GREATER
56596: IFFALSE 56622
// length := ( array - i_from ) + i_to else
56598: LD_ADDR_VAR 0 11
56602: PUSH
56603: LD_VAR 0 1
56607: PUSH
56608: LD_VAR 0 2
56612: MINUS
56613: PUSH
56614: LD_VAR 0 3
56618: PLUS
56619: ST_TO_ADDR
56620: GO 56638
// length := i_to - i_from ;
56622: LD_ADDR_VAR 0 11
56626: PUSH
56627: LD_VAR 0 3
56631: PUSH
56632: LD_VAR 0 2
56636: MINUS
56637: ST_TO_ADDR
// end else
56638: GO 56701
// begin d := - 1 ;
56640: LD_ADDR_VAR 0 9
56644: PUSH
56645: LD_INT 1
56647: NEG
56648: ST_TO_ADDR
// if i_from > i_to then
56649: LD_VAR 0 2
56653: PUSH
56654: LD_VAR 0 3
56658: GREATER
56659: IFFALSE 56679
// length := i_from - i_to else
56661: LD_ADDR_VAR 0 11
56665: PUSH
56666: LD_VAR 0 2
56670: PUSH
56671: LD_VAR 0 3
56675: MINUS
56676: ST_TO_ADDR
56677: GO 56701
// length := ( array - i_to ) + i_from ;
56679: LD_ADDR_VAR 0 11
56683: PUSH
56684: LD_VAR 0 1
56688: PUSH
56689: LD_VAR 0 3
56693: MINUS
56694: PUSH
56695: LD_VAR 0 2
56699: PLUS
56700: ST_TO_ADDR
// end ; if not length then
56701: LD_VAR 0 11
56705: NOT
56706: IFFALSE 56710
// exit ;
56708: GO 56868
// tmp := array ;
56710: LD_ADDR_VAR 0 10
56714: PUSH
56715: LD_VAR 0 1
56719: ST_TO_ADDR
// for i = 1 to length do
56720: LD_ADDR_VAR 0 6
56724: PUSH
56725: DOUBLE
56726: LD_INT 1
56728: DEC
56729: ST_TO_ADDR
56730: LD_VAR 0 11
56734: PUSH
56735: FOR_TO
56736: IFFALSE 56856
// begin for j = 1 to array do
56738: LD_ADDR_VAR 0 7
56742: PUSH
56743: DOUBLE
56744: LD_INT 1
56746: DEC
56747: ST_TO_ADDR
56748: LD_VAR 0 1
56752: PUSH
56753: FOR_TO
56754: IFFALSE 56842
// begin k := j + d ;
56756: LD_ADDR_VAR 0 8
56760: PUSH
56761: LD_VAR 0 7
56765: PUSH
56766: LD_VAR 0 9
56770: PLUS
56771: ST_TO_ADDR
// if k > array then
56772: LD_VAR 0 8
56776: PUSH
56777: LD_VAR 0 1
56781: GREATER
56782: IFFALSE 56792
// k := 1 ;
56784: LD_ADDR_VAR 0 8
56788: PUSH
56789: LD_INT 1
56791: ST_TO_ADDR
// if not k then
56792: LD_VAR 0 8
56796: NOT
56797: IFFALSE 56809
// k := array ;
56799: LD_ADDR_VAR 0 8
56803: PUSH
56804: LD_VAR 0 1
56808: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56809: LD_ADDR_VAR 0 10
56813: PUSH
56814: LD_VAR 0 10
56818: PPUSH
56819: LD_VAR 0 8
56823: PPUSH
56824: LD_VAR 0 1
56828: PUSH
56829: LD_VAR 0 7
56833: ARRAY
56834: PPUSH
56835: CALL_OW 1
56839: ST_TO_ADDR
// end ;
56840: GO 56753
56842: POP
56843: POP
// array := tmp ;
56844: LD_ADDR_VAR 0 1
56848: PUSH
56849: LD_VAR 0 10
56853: ST_TO_ADDR
// end ;
56854: GO 56735
56856: POP
56857: POP
// result := array ;
56858: LD_ADDR_VAR 0 5
56862: PUSH
56863: LD_VAR 0 1
56867: ST_TO_ADDR
// end ;
56868: LD_VAR 0 5
56872: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56873: LD_INT 0
56875: PPUSH
56876: PPUSH
// result := 0 ;
56877: LD_ADDR_VAR 0 3
56881: PUSH
56882: LD_INT 0
56884: ST_TO_ADDR
// if not array or not value in array then
56885: LD_VAR 0 1
56889: NOT
56890: PUSH
56891: LD_VAR 0 2
56895: PUSH
56896: LD_VAR 0 1
56900: IN
56901: NOT
56902: OR
56903: IFFALSE 56907
// exit ;
56905: GO 56961
// for i = 1 to array do
56907: LD_ADDR_VAR 0 4
56911: PUSH
56912: DOUBLE
56913: LD_INT 1
56915: DEC
56916: ST_TO_ADDR
56917: LD_VAR 0 1
56921: PUSH
56922: FOR_TO
56923: IFFALSE 56959
// if value = array [ i ] then
56925: LD_VAR 0 2
56929: PUSH
56930: LD_VAR 0 1
56934: PUSH
56935: LD_VAR 0 4
56939: ARRAY
56940: EQUAL
56941: IFFALSE 56957
// begin result := i ;
56943: LD_ADDR_VAR 0 3
56947: PUSH
56948: LD_VAR 0 4
56952: ST_TO_ADDR
// exit ;
56953: POP
56954: POP
56955: GO 56961
// end ;
56957: GO 56922
56959: POP
56960: POP
// end ;
56961: LD_VAR 0 3
56965: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56966: LD_INT 0
56968: PPUSH
// vc_chassis := chassis ;
56969: LD_ADDR_OWVAR 37
56973: PUSH
56974: LD_VAR 0 1
56978: ST_TO_ADDR
// vc_engine := engine ;
56979: LD_ADDR_OWVAR 39
56983: PUSH
56984: LD_VAR 0 2
56988: ST_TO_ADDR
// vc_control := control ;
56989: LD_ADDR_OWVAR 38
56993: PUSH
56994: LD_VAR 0 3
56998: ST_TO_ADDR
// vc_weapon := weapon ;
56999: LD_ADDR_OWVAR 40
57003: PUSH
57004: LD_VAR 0 4
57008: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57009: LD_ADDR_OWVAR 41
57013: PUSH
57014: LD_VAR 0 5
57018: ST_TO_ADDR
// end ;
57019: LD_VAR 0 6
57023: RET
// export function WantPlant ( unit ) ; var task ; begin
57024: LD_INT 0
57026: PPUSH
57027: PPUSH
// result := false ;
57028: LD_ADDR_VAR 0 2
57032: PUSH
57033: LD_INT 0
57035: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57036: LD_ADDR_VAR 0 3
57040: PUSH
57041: LD_VAR 0 1
57045: PPUSH
57046: CALL_OW 437
57050: ST_TO_ADDR
// if task then
57051: LD_VAR 0 3
57055: IFFALSE 57083
// if task [ 1 ] [ 1 ] = p then
57057: LD_VAR 0 3
57061: PUSH
57062: LD_INT 1
57064: ARRAY
57065: PUSH
57066: LD_INT 1
57068: ARRAY
57069: PUSH
57070: LD_STRING p
57072: EQUAL
57073: IFFALSE 57083
// result := true ;
57075: LD_ADDR_VAR 0 2
57079: PUSH
57080: LD_INT 1
57082: ST_TO_ADDR
// end ;
57083: LD_VAR 0 2
57087: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57088: LD_INT 0
57090: PPUSH
57091: PPUSH
57092: PPUSH
57093: PPUSH
// if pos < 1 then
57094: LD_VAR 0 2
57098: PUSH
57099: LD_INT 1
57101: LESS
57102: IFFALSE 57106
// exit ;
57104: GO 57409
// if pos = 1 then
57106: LD_VAR 0 2
57110: PUSH
57111: LD_INT 1
57113: EQUAL
57114: IFFALSE 57147
// result := Replace ( arr , pos [ 1 ] , value ) else
57116: LD_ADDR_VAR 0 4
57120: PUSH
57121: LD_VAR 0 1
57125: PPUSH
57126: LD_VAR 0 2
57130: PUSH
57131: LD_INT 1
57133: ARRAY
57134: PPUSH
57135: LD_VAR 0 3
57139: PPUSH
57140: CALL_OW 1
57144: ST_TO_ADDR
57145: GO 57409
// begin tmp := arr ;
57147: LD_ADDR_VAR 0 6
57151: PUSH
57152: LD_VAR 0 1
57156: ST_TO_ADDR
// s_arr := [ tmp ] ;
57157: LD_ADDR_VAR 0 7
57161: PUSH
57162: LD_VAR 0 6
57166: PUSH
57167: EMPTY
57168: LIST
57169: ST_TO_ADDR
// for i = 1 to pos - 1 do
57170: LD_ADDR_VAR 0 5
57174: PUSH
57175: DOUBLE
57176: LD_INT 1
57178: DEC
57179: ST_TO_ADDR
57180: LD_VAR 0 2
57184: PUSH
57185: LD_INT 1
57187: MINUS
57188: PUSH
57189: FOR_TO
57190: IFFALSE 57235
// begin tmp := tmp [ pos [ i ] ] ;
57192: LD_ADDR_VAR 0 6
57196: PUSH
57197: LD_VAR 0 6
57201: PUSH
57202: LD_VAR 0 2
57206: PUSH
57207: LD_VAR 0 5
57211: ARRAY
57212: ARRAY
57213: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57214: LD_ADDR_VAR 0 7
57218: PUSH
57219: LD_VAR 0 7
57223: PUSH
57224: LD_VAR 0 6
57228: PUSH
57229: EMPTY
57230: LIST
57231: ADD
57232: ST_TO_ADDR
// end ;
57233: GO 57189
57235: POP
57236: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57237: LD_ADDR_VAR 0 6
57241: PUSH
57242: LD_VAR 0 6
57246: PPUSH
57247: LD_VAR 0 2
57251: PUSH
57252: LD_VAR 0 2
57256: ARRAY
57257: PPUSH
57258: LD_VAR 0 3
57262: PPUSH
57263: CALL_OW 1
57267: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57268: LD_ADDR_VAR 0 7
57272: PUSH
57273: LD_VAR 0 7
57277: PPUSH
57278: LD_VAR 0 7
57282: PPUSH
57283: LD_VAR 0 6
57287: PPUSH
57288: CALL_OW 1
57292: ST_TO_ADDR
// for i = s_arr downto 2 do
57293: LD_ADDR_VAR 0 5
57297: PUSH
57298: DOUBLE
57299: LD_VAR 0 7
57303: INC
57304: ST_TO_ADDR
57305: LD_INT 2
57307: PUSH
57308: FOR_DOWNTO
57309: IFFALSE 57393
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57311: LD_ADDR_VAR 0 6
57315: PUSH
57316: LD_VAR 0 7
57320: PUSH
57321: LD_VAR 0 5
57325: PUSH
57326: LD_INT 1
57328: MINUS
57329: ARRAY
57330: PPUSH
57331: LD_VAR 0 2
57335: PUSH
57336: LD_VAR 0 5
57340: PUSH
57341: LD_INT 1
57343: MINUS
57344: ARRAY
57345: PPUSH
57346: LD_VAR 0 7
57350: PUSH
57351: LD_VAR 0 5
57355: ARRAY
57356: PPUSH
57357: CALL_OW 1
57361: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57362: LD_ADDR_VAR 0 7
57366: PUSH
57367: LD_VAR 0 7
57371: PPUSH
57372: LD_VAR 0 5
57376: PUSH
57377: LD_INT 1
57379: MINUS
57380: PPUSH
57381: LD_VAR 0 6
57385: PPUSH
57386: CALL_OW 1
57390: ST_TO_ADDR
// end ;
57391: GO 57308
57393: POP
57394: POP
// result := s_arr [ 1 ] ;
57395: LD_ADDR_VAR 0 4
57399: PUSH
57400: LD_VAR 0 7
57404: PUSH
57405: LD_INT 1
57407: ARRAY
57408: ST_TO_ADDR
// end ; end ;
57409: LD_VAR 0 4
57413: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57414: LD_INT 0
57416: PPUSH
57417: PPUSH
// if not list then
57418: LD_VAR 0 1
57422: NOT
57423: IFFALSE 57427
// exit ;
57425: GO 57518
// i := list [ pos1 ] ;
57427: LD_ADDR_VAR 0 5
57431: PUSH
57432: LD_VAR 0 1
57436: PUSH
57437: LD_VAR 0 2
57441: ARRAY
57442: ST_TO_ADDR
// if not i then
57443: LD_VAR 0 5
57447: NOT
57448: IFFALSE 57452
// exit ;
57450: GO 57518
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57452: LD_ADDR_VAR 0 1
57456: PUSH
57457: LD_VAR 0 1
57461: PPUSH
57462: LD_VAR 0 2
57466: PPUSH
57467: LD_VAR 0 1
57471: PUSH
57472: LD_VAR 0 3
57476: ARRAY
57477: PPUSH
57478: CALL_OW 1
57482: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57483: LD_ADDR_VAR 0 1
57487: PUSH
57488: LD_VAR 0 1
57492: PPUSH
57493: LD_VAR 0 3
57497: PPUSH
57498: LD_VAR 0 5
57502: PPUSH
57503: CALL_OW 1
57507: ST_TO_ADDR
// result := list ;
57508: LD_ADDR_VAR 0 4
57512: PUSH
57513: LD_VAR 0 1
57517: ST_TO_ADDR
// end ;
57518: LD_VAR 0 4
57522: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57523: LD_INT 0
57525: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57526: LD_ADDR_VAR 0 5
57530: PUSH
57531: LD_VAR 0 1
57535: PPUSH
57536: CALL_OW 250
57540: PPUSH
57541: LD_VAR 0 1
57545: PPUSH
57546: CALL_OW 251
57550: PPUSH
57551: LD_VAR 0 2
57555: PPUSH
57556: LD_VAR 0 3
57560: PPUSH
57561: LD_VAR 0 4
57565: PPUSH
57566: CALL 57576 0 5
57570: ST_TO_ADDR
// end ;
57571: LD_VAR 0 5
57575: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57576: LD_INT 0
57578: PPUSH
57579: PPUSH
57580: PPUSH
57581: PPUSH
// if not list then
57582: LD_VAR 0 3
57586: NOT
57587: IFFALSE 57591
// exit ;
57589: GO 57979
// result := [ ] ;
57591: LD_ADDR_VAR 0 6
57595: PUSH
57596: EMPTY
57597: ST_TO_ADDR
// for i in list do
57598: LD_ADDR_VAR 0 7
57602: PUSH
57603: LD_VAR 0 3
57607: PUSH
57608: FOR_IN
57609: IFFALSE 57811
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57611: LD_ADDR_VAR 0 9
57615: PUSH
57616: LD_VAR 0 7
57620: PPUSH
57621: LD_VAR 0 1
57625: PPUSH
57626: LD_VAR 0 2
57630: PPUSH
57631: CALL_OW 297
57635: ST_TO_ADDR
// if not result then
57636: LD_VAR 0 6
57640: NOT
57641: IFFALSE 57667
// result := [ [ i , tmp ] ] else
57643: LD_ADDR_VAR 0 6
57647: PUSH
57648: LD_VAR 0 7
57652: PUSH
57653: LD_VAR 0 9
57657: PUSH
57658: EMPTY
57659: LIST
57660: LIST
57661: PUSH
57662: EMPTY
57663: LIST
57664: ST_TO_ADDR
57665: GO 57809
// begin if result [ result ] [ 2 ] < tmp then
57667: LD_VAR 0 6
57671: PUSH
57672: LD_VAR 0 6
57676: ARRAY
57677: PUSH
57678: LD_INT 2
57680: ARRAY
57681: PUSH
57682: LD_VAR 0 9
57686: LESS
57687: IFFALSE 57729
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57689: LD_ADDR_VAR 0 6
57693: PUSH
57694: LD_VAR 0 6
57698: PPUSH
57699: LD_VAR 0 6
57703: PUSH
57704: LD_INT 1
57706: PLUS
57707: PPUSH
57708: LD_VAR 0 7
57712: PUSH
57713: LD_VAR 0 9
57717: PUSH
57718: EMPTY
57719: LIST
57720: LIST
57721: PPUSH
57722: CALL_OW 2
57726: ST_TO_ADDR
57727: GO 57809
// for j = 1 to result do
57729: LD_ADDR_VAR 0 8
57733: PUSH
57734: DOUBLE
57735: LD_INT 1
57737: DEC
57738: ST_TO_ADDR
57739: LD_VAR 0 6
57743: PUSH
57744: FOR_TO
57745: IFFALSE 57807
// begin if tmp < result [ j ] [ 2 ] then
57747: LD_VAR 0 9
57751: PUSH
57752: LD_VAR 0 6
57756: PUSH
57757: LD_VAR 0 8
57761: ARRAY
57762: PUSH
57763: LD_INT 2
57765: ARRAY
57766: LESS
57767: IFFALSE 57805
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57769: LD_ADDR_VAR 0 6
57773: PUSH
57774: LD_VAR 0 6
57778: PPUSH
57779: LD_VAR 0 8
57783: PPUSH
57784: LD_VAR 0 7
57788: PUSH
57789: LD_VAR 0 9
57793: PUSH
57794: EMPTY
57795: LIST
57796: LIST
57797: PPUSH
57798: CALL_OW 2
57802: ST_TO_ADDR
// break ;
57803: GO 57807
// end ; end ;
57805: GO 57744
57807: POP
57808: POP
// end ; end ;
57809: GO 57608
57811: POP
57812: POP
// if result and not asc then
57813: LD_VAR 0 6
57817: PUSH
57818: LD_VAR 0 4
57822: NOT
57823: AND
57824: IFFALSE 57899
// begin tmp := result ;
57826: LD_ADDR_VAR 0 9
57830: PUSH
57831: LD_VAR 0 6
57835: ST_TO_ADDR
// for i = tmp downto 1 do
57836: LD_ADDR_VAR 0 7
57840: PUSH
57841: DOUBLE
57842: LD_VAR 0 9
57846: INC
57847: ST_TO_ADDR
57848: LD_INT 1
57850: PUSH
57851: FOR_DOWNTO
57852: IFFALSE 57897
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57854: LD_ADDR_VAR 0 6
57858: PUSH
57859: LD_VAR 0 6
57863: PPUSH
57864: LD_VAR 0 9
57868: PUSH
57869: LD_VAR 0 7
57873: MINUS
57874: PUSH
57875: LD_INT 1
57877: PLUS
57878: PPUSH
57879: LD_VAR 0 9
57883: PUSH
57884: LD_VAR 0 7
57888: ARRAY
57889: PPUSH
57890: CALL_OW 1
57894: ST_TO_ADDR
57895: GO 57851
57897: POP
57898: POP
// end ; tmp := [ ] ;
57899: LD_ADDR_VAR 0 9
57903: PUSH
57904: EMPTY
57905: ST_TO_ADDR
// if mode then
57906: LD_VAR 0 5
57910: IFFALSE 57979
// begin for i = 1 to result do
57912: LD_ADDR_VAR 0 7
57916: PUSH
57917: DOUBLE
57918: LD_INT 1
57920: DEC
57921: ST_TO_ADDR
57922: LD_VAR 0 6
57926: PUSH
57927: FOR_TO
57928: IFFALSE 57967
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57930: LD_ADDR_VAR 0 9
57934: PUSH
57935: LD_VAR 0 9
57939: PPUSH
57940: LD_VAR 0 7
57944: PPUSH
57945: LD_VAR 0 6
57949: PUSH
57950: LD_VAR 0 7
57954: ARRAY
57955: PUSH
57956: LD_INT 1
57958: ARRAY
57959: PPUSH
57960: CALL_OW 1
57964: ST_TO_ADDR
57965: GO 57927
57967: POP
57968: POP
// result := tmp ;
57969: LD_ADDR_VAR 0 6
57973: PUSH
57974: LD_VAR 0 9
57978: ST_TO_ADDR
// end ; end ;
57979: LD_VAR 0 6
57983: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57984: LD_INT 0
57986: PPUSH
57987: PPUSH
57988: PPUSH
57989: PPUSH
57990: PPUSH
57991: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57992: LD_ADDR_VAR 0 5
57996: PUSH
57997: LD_INT 0
57999: PUSH
58000: LD_INT 0
58002: PUSH
58003: LD_INT 0
58005: PUSH
58006: EMPTY
58007: PUSH
58008: EMPTY
58009: LIST
58010: LIST
58011: LIST
58012: LIST
58013: ST_TO_ADDR
// if not x or not y then
58014: LD_VAR 0 2
58018: NOT
58019: PUSH
58020: LD_VAR 0 3
58024: NOT
58025: OR
58026: IFFALSE 58030
// exit ;
58028: GO 59680
// if not range then
58030: LD_VAR 0 4
58034: NOT
58035: IFFALSE 58045
// range := 10 ;
58037: LD_ADDR_VAR 0 4
58041: PUSH
58042: LD_INT 10
58044: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58045: LD_ADDR_VAR 0 8
58049: PUSH
58050: LD_INT 81
58052: PUSH
58053: LD_VAR 0 1
58057: PUSH
58058: EMPTY
58059: LIST
58060: LIST
58061: PUSH
58062: LD_INT 92
58064: PUSH
58065: LD_VAR 0 2
58069: PUSH
58070: LD_VAR 0 3
58074: PUSH
58075: LD_VAR 0 4
58079: PUSH
58080: EMPTY
58081: LIST
58082: LIST
58083: LIST
58084: LIST
58085: PUSH
58086: LD_INT 3
58088: PUSH
58089: LD_INT 21
58091: PUSH
58092: LD_INT 3
58094: PUSH
58095: EMPTY
58096: LIST
58097: LIST
58098: PUSH
58099: EMPTY
58100: LIST
58101: LIST
58102: PUSH
58103: EMPTY
58104: LIST
58105: LIST
58106: LIST
58107: PPUSH
58108: CALL_OW 69
58112: ST_TO_ADDR
// if not tmp then
58113: LD_VAR 0 8
58117: NOT
58118: IFFALSE 58122
// exit ;
58120: GO 59680
// for i in tmp do
58122: LD_ADDR_VAR 0 6
58126: PUSH
58127: LD_VAR 0 8
58131: PUSH
58132: FOR_IN
58133: IFFALSE 59655
// begin points := [ 0 , 0 , 0 ] ;
58135: LD_ADDR_VAR 0 9
58139: PUSH
58140: LD_INT 0
58142: PUSH
58143: LD_INT 0
58145: PUSH
58146: LD_INT 0
58148: PUSH
58149: EMPTY
58150: LIST
58151: LIST
58152: LIST
58153: ST_TO_ADDR
// bpoints := 1 ;
58154: LD_ADDR_VAR 0 10
58158: PUSH
58159: LD_INT 1
58161: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58162: LD_VAR 0 6
58166: PPUSH
58167: CALL_OW 247
58171: PUSH
58172: LD_INT 1
58174: DOUBLE
58175: EQUAL
58176: IFTRUE 58180
58178: GO 58758
58180: POP
// begin if GetClass ( i ) = 1 then
58181: LD_VAR 0 6
58185: PPUSH
58186: CALL_OW 257
58190: PUSH
58191: LD_INT 1
58193: EQUAL
58194: IFFALSE 58215
// points := [ 10 , 5 , 3 ] ;
58196: LD_ADDR_VAR 0 9
58200: PUSH
58201: LD_INT 10
58203: PUSH
58204: LD_INT 5
58206: PUSH
58207: LD_INT 3
58209: PUSH
58210: EMPTY
58211: LIST
58212: LIST
58213: LIST
58214: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58215: LD_VAR 0 6
58219: PPUSH
58220: CALL_OW 257
58224: PUSH
58225: LD_INT 2
58227: PUSH
58228: LD_INT 3
58230: PUSH
58231: LD_INT 4
58233: PUSH
58234: EMPTY
58235: LIST
58236: LIST
58237: LIST
58238: IN
58239: IFFALSE 58260
// points := [ 3 , 2 , 1 ] ;
58241: LD_ADDR_VAR 0 9
58245: PUSH
58246: LD_INT 3
58248: PUSH
58249: LD_INT 2
58251: PUSH
58252: LD_INT 1
58254: PUSH
58255: EMPTY
58256: LIST
58257: LIST
58258: LIST
58259: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58260: LD_VAR 0 6
58264: PPUSH
58265: CALL_OW 257
58269: PUSH
58270: LD_INT 5
58272: EQUAL
58273: IFFALSE 58294
// points := [ 130 , 5 , 2 ] ;
58275: LD_ADDR_VAR 0 9
58279: PUSH
58280: LD_INT 130
58282: PUSH
58283: LD_INT 5
58285: PUSH
58286: LD_INT 2
58288: PUSH
58289: EMPTY
58290: LIST
58291: LIST
58292: LIST
58293: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58294: LD_VAR 0 6
58298: PPUSH
58299: CALL_OW 257
58303: PUSH
58304: LD_INT 8
58306: EQUAL
58307: IFFALSE 58328
// points := [ 35 , 35 , 30 ] ;
58309: LD_ADDR_VAR 0 9
58313: PUSH
58314: LD_INT 35
58316: PUSH
58317: LD_INT 35
58319: PUSH
58320: LD_INT 30
58322: PUSH
58323: EMPTY
58324: LIST
58325: LIST
58326: LIST
58327: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58328: LD_VAR 0 6
58332: PPUSH
58333: CALL_OW 257
58337: PUSH
58338: LD_INT 9
58340: EQUAL
58341: IFFALSE 58362
// points := [ 20 , 55 , 40 ] ;
58343: LD_ADDR_VAR 0 9
58347: PUSH
58348: LD_INT 20
58350: PUSH
58351: LD_INT 55
58353: PUSH
58354: LD_INT 40
58356: PUSH
58357: EMPTY
58358: LIST
58359: LIST
58360: LIST
58361: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58362: LD_VAR 0 6
58366: PPUSH
58367: CALL_OW 257
58371: PUSH
58372: LD_INT 12
58374: PUSH
58375: LD_INT 16
58377: PUSH
58378: EMPTY
58379: LIST
58380: LIST
58381: IN
58382: IFFALSE 58403
// points := [ 5 , 3 , 2 ] ;
58384: LD_ADDR_VAR 0 9
58388: PUSH
58389: LD_INT 5
58391: PUSH
58392: LD_INT 3
58394: PUSH
58395: LD_INT 2
58397: PUSH
58398: EMPTY
58399: LIST
58400: LIST
58401: LIST
58402: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58403: LD_VAR 0 6
58407: PPUSH
58408: CALL_OW 257
58412: PUSH
58413: LD_INT 17
58415: EQUAL
58416: IFFALSE 58437
// points := [ 100 , 50 , 75 ] ;
58418: LD_ADDR_VAR 0 9
58422: PUSH
58423: LD_INT 100
58425: PUSH
58426: LD_INT 50
58428: PUSH
58429: LD_INT 75
58431: PUSH
58432: EMPTY
58433: LIST
58434: LIST
58435: LIST
58436: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58437: LD_VAR 0 6
58441: PPUSH
58442: CALL_OW 257
58446: PUSH
58447: LD_INT 15
58449: EQUAL
58450: IFFALSE 58471
// points := [ 10 , 5 , 3 ] ;
58452: LD_ADDR_VAR 0 9
58456: PUSH
58457: LD_INT 10
58459: PUSH
58460: LD_INT 5
58462: PUSH
58463: LD_INT 3
58465: PUSH
58466: EMPTY
58467: LIST
58468: LIST
58469: LIST
58470: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58471: LD_VAR 0 6
58475: PPUSH
58476: CALL_OW 257
58480: PUSH
58481: LD_INT 14
58483: EQUAL
58484: IFFALSE 58505
// points := [ 10 , 0 , 0 ] ;
58486: LD_ADDR_VAR 0 9
58490: PUSH
58491: LD_INT 10
58493: PUSH
58494: LD_INT 0
58496: PUSH
58497: LD_INT 0
58499: PUSH
58500: EMPTY
58501: LIST
58502: LIST
58503: LIST
58504: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58505: LD_VAR 0 6
58509: PPUSH
58510: CALL_OW 257
58514: PUSH
58515: LD_INT 11
58517: EQUAL
58518: IFFALSE 58539
// points := [ 30 , 10 , 5 ] ;
58520: LD_ADDR_VAR 0 9
58524: PUSH
58525: LD_INT 30
58527: PUSH
58528: LD_INT 10
58530: PUSH
58531: LD_INT 5
58533: PUSH
58534: EMPTY
58535: LIST
58536: LIST
58537: LIST
58538: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58539: LD_VAR 0 1
58543: PPUSH
58544: LD_INT 5
58546: PPUSH
58547: CALL_OW 321
58551: PUSH
58552: LD_INT 2
58554: EQUAL
58555: IFFALSE 58572
// bpoints := bpoints * 1.8 ;
58557: LD_ADDR_VAR 0 10
58561: PUSH
58562: LD_VAR 0 10
58566: PUSH
58567: LD_REAL  1.80000000000000E+0000
58570: MUL
58571: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58572: LD_VAR 0 6
58576: PPUSH
58577: CALL_OW 257
58581: PUSH
58582: LD_INT 1
58584: PUSH
58585: LD_INT 2
58587: PUSH
58588: LD_INT 3
58590: PUSH
58591: LD_INT 4
58593: PUSH
58594: EMPTY
58595: LIST
58596: LIST
58597: LIST
58598: LIST
58599: IN
58600: PUSH
58601: LD_VAR 0 1
58605: PPUSH
58606: LD_INT 51
58608: PPUSH
58609: CALL_OW 321
58613: PUSH
58614: LD_INT 2
58616: EQUAL
58617: AND
58618: IFFALSE 58635
// bpoints := bpoints * 1.2 ;
58620: LD_ADDR_VAR 0 10
58624: PUSH
58625: LD_VAR 0 10
58629: PUSH
58630: LD_REAL  1.20000000000000E+0000
58633: MUL
58634: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58635: LD_VAR 0 6
58639: PPUSH
58640: CALL_OW 257
58644: PUSH
58645: LD_INT 5
58647: PUSH
58648: LD_INT 7
58650: PUSH
58651: LD_INT 9
58653: PUSH
58654: EMPTY
58655: LIST
58656: LIST
58657: LIST
58658: IN
58659: PUSH
58660: LD_VAR 0 1
58664: PPUSH
58665: LD_INT 52
58667: PPUSH
58668: CALL_OW 321
58672: PUSH
58673: LD_INT 2
58675: EQUAL
58676: AND
58677: IFFALSE 58694
// bpoints := bpoints * 1.5 ;
58679: LD_ADDR_VAR 0 10
58683: PUSH
58684: LD_VAR 0 10
58688: PUSH
58689: LD_REAL  1.50000000000000E+0000
58692: MUL
58693: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58694: LD_VAR 0 1
58698: PPUSH
58699: LD_INT 66
58701: PPUSH
58702: CALL_OW 321
58706: PUSH
58707: LD_INT 2
58709: EQUAL
58710: IFFALSE 58727
// bpoints := bpoints * 1.1 ;
58712: LD_ADDR_VAR 0 10
58716: PUSH
58717: LD_VAR 0 10
58721: PUSH
58722: LD_REAL  1.10000000000000E+0000
58725: MUL
58726: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58727: LD_ADDR_VAR 0 10
58731: PUSH
58732: LD_VAR 0 10
58736: PUSH
58737: LD_VAR 0 6
58741: PPUSH
58742: LD_INT 1
58744: PPUSH
58745: CALL_OW 259
58749: PUSH
58750: LD_REAL  1.15000000000000E+0000
58753: MUL
58754: MUL
58755: ST_TO_ADDR
// end ; unit_vehicle :
58756: GO 59584
58758: LD_INT 2
58760: DOUBLE
58761: EQUAL
58762: IFTRUE 58766
58764: GO 59572
58766: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58767: LD_VAR 0 6
58771: PPUSH
58772: CALL_OW 264
58776: PUSH
58777: LD_INT 2
58779: PUSH
58780: LD_INT 42
58782: PUSH
58783: LD_INT 24
58785: PUSH
58786: EMPTY
58787: LIST
58788: LIST
58789: LIST
58790: IN
58791: IFFALSE 58812
// points := [ 25 , 5 , 3 ] ;
58793: LD_ADDR_VAR 0 9
58797: PUSH
58798: LD_INT 25
58800: PUSH
58801: LD_INT 5
58803: PUSH
58804: LD_INT 3
58806: PUSH
58807: EMPTY
58808: LIST
58809: LIST
58810: LIST
58811: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58812: LD_VAR 0 6
58816: PPUSH
58817: CALL_OW 264
58821: PUSH
58822: LD_INT 4
58824: PUSH
58825: LD_INT 43
58827: PUSH
58828: LD_INT 25
58830: PUSH
58831: EMPTY
58832: LIST
58833: LIST
58834: LIST
58835: IN
58836: IFFALSE 58857
// points := [ 40 , 15 , 5 ] ;
58838: LD_ADDR_VAR 0 9
58842: PUSH
58843: LD_INT 40
58845: PUSH
58846: LD_INT 15
58848: PUSH
58849: LD_INT 5
58851: PUSH
58852: EMPTY
58853: LIST
58854: LIST
58855: LIST
58856: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58857: LD_VAR 0 6
58861: PPUSH
58862: CALL_OW 264
58866: PUSH
58867: LD_INT 3
58869: PUSH
58870: LD_INT 23
58872: PUSH
58873: EMPTY
58874: LIST
58875: LIST
58876: IN
58877: IFFALSE 58898
// points := [ 7 , 25 , 8 ] ;
58879: LD_ADDR_VAR 0 9
58883: PUSH
58884: LD_INT 7
58886: PUSH
58887: LD_INT 25
58889: PUSH
58890: LD_INT 8
58892: PUSH
58893: EMPTY
58894: LIST
58895: LIST
58896: LIST
58897: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58898: LD_VAR 0 6
58902: PPUSH
58903: CALL_OW 264
58907: PUSH
58908: LD_INT 5
58910: PUSH
58911: LD_INT 27
58913: PUSH
58914: LD_INT 44
58916: PUSH
58917: EMPTY
58918: LIST
58919: LIST
58920: LIST
58921: IN
58922: IFFALSE 58943
// points := [ 14 , 50 , 16 ] ;
58924: LD_ADDR_VAR 0 9
58928: PUSH
58929: LD_INT 14
58931: PUSH
58932: LD_INT 50
58934: PUSH
58935: LD_INT 16
58937: PUSH
58938: EMPTY
58939: LIST
58940: LIST
58941: LIST
58942: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58943: LD_VAR 0 6
58947: PPUSH
58948: CALL_OW 264
58952: PUSH
58953: LD_INT 6
58955: PUSH
58956: LD_INT 46
58958: PUSH
58959: EMPTY
58960: LIST
58961: LIST
58962: IN
58963: IFFALSE 58984
// points := [ 32 , 120 , 70 ] ;
58965: LD_ADDR_VAR 0 9
58969: PUSH
58970: LD_INT 32
58972: PUSH
58973: LD_INT 120
58975: PUSH
58976: LD_INT 70
58978: PUSH
58979: EMPTY
58980: LIST
58981: LIST
58982: LIST
58983: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58984: LD_VAR 0 6
58988: PPUSH
58989: CALL_OW 264
58993: PUSH
58994: LD_INT 7
58996: PUSH
58997: LD_INT 28
58999: PUSH
59000: LD_INT 45
59002: PUSH
59003: LD_INT 92
59005: PUSH
59006: EMPTY
59007: LIST
59008: LIST
59009: LIST
59010: LIST
59011: IN
59012: IFFALSE 59033
// points := [ 35 , 20 , 45 ] ;
59014: LD_ADDR_VAR 0 9
59018: PUSH
59019: LD_INT 35
59021: PUSH
59022: LD_INT 20
59024: PUSH
59025: LD_INT 45
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: LIST
59032: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59033: LD_VAR 0 6
59037: PPUSH
59038: CALL_OW 264
59042: PUSH
59043: LD_INT 47
59045: PUSH
59046: EMPTY
59047: LIST
59048: IN
59049: IFFALSE 59070
// points := [ 67 , 45 , 75 ] ;
59051: LD_ADDR_VAR 0 9
59055: PUSH
59056: LD_INT 67
59058: PUSH
59059: LD_INT 45
59061: PUSH
59062: LD_INT 75
59064: PUSH
59065: EMPTY
59066: LIST
59067: LIST
59068: LIST
59069: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59070: LD_VAR 0 6
59074: PPUSH
59075: CALL_OW 264
59079: PUSH
59080: LD_INT 26
59082: PUSH
59083: EMPTY
59084: LIST
59085: IN
59086: IFFALSE 59107
// points := [ 120 , 30 , 80 ] ;
59088: LD_ADDR_VAR 0 9
59092: PUSH
59093: LD_INT 120
59095: PUSH
59096: LD_INT 30
59098: PUSH
59099: LD_INT 80
59101: PUSH
59102: EMPTY
59103: LIST
59104: LIST
59105: LIST
59106: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59107: LD_VAR 0 6
59111: PPUSH
59112: CALL_OW 264
59116: PUSH
59117: LD_INT 22
59119: PUSH
59120: EMPTY
59121: LIST
59122: IN
59123: IFFALSE 59144
// points := [ 40 , 1 , 1 ] ;
59125: LD_ADDR_VAR 0 9
59129: PUSH
59130: LD_INT 40
59132: PUSH
59133: LD_INT 1
59135: PUSH
59136: LD_INT 1
59138: PUSH
59139: EMPTY
59140: LIST
59141: LIST
59142: LIST
59143: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59144: LD_VAR 0 6
59148: PPUSH
59149: CALL_OW 264
59153: PUSH
59154: LD_INT 29
59156: PUSH
59157: EMPTY
59158: LIST
59159: IN
59160: IFFALSE 59181
// points := [ 70 , 200 , 400 ] ;
59162: LD_ADDR_VAR 0 9
59166: PUSH
59167: LD_INT 70
59169: PUSH
59170: LD_INT 200
59172: PUSH
59173: LD_INT 400
59175: PUSH
59176: EMPTY
59177: LIST
59178: LIST
59179: LIST
59180: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59181: LD_VAR 0 6
59185: PPUSH
59186: CALL_OW 264
59190: PUSH
59191: LD_INT 14
59193: PUSH
59194: LD_INT 53
59196: PUSH
59197: EMPTY
59198: LIST
59199: LIST
59200: IN
59201: IFFALSE 59222
// points := [ 40 , 10 , 20 ] ;
59203: LD_ADDR_VAR 0 9
59207: PUSH
59208: LD_INT 40
59210: PUSH
59211: LD_INT 10
59213: PUSH
59214: LD_INT 20
59216: PUSH
59217: EMPTY
59218: LIST
59219: LIST
59220: LIST
59221: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59222: LD_VAR 0 6
59226: PPUSH
59227: CALL_OW 264
59231: PUSH
59232: LD_INT 9
59234: PUSH
59235: EMPTY
59236: LIST
59237: IN
59238: IFFALSE 59259
// points := [ 5 , 70 , 20 ] ;
59240: LD_ADDR_VAR 0 9
59244: PUSH
59245: LD_INT 5
59247: PUSH
59248: LD_INT 70
59250: PUSH
59251: LD_INT 20
59253: PUSH
59254: EMPTY
59255: LIST
59256: LIST
59257: LIST
59258: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59259: LD_VAR 0 6
59263: PPUSH
59264: CALL_OW 264
59268: PUSH
59269: LD_INT 10
59271: PUSH
59272: EMPTY
59273: LIST
59274: IN
59275: IFFALSE 59296
// points := [ 35 , 110 , 70 ] ;
59277: LD_ADDR_VAR 0 9
59281: PUSH
59282: LD_INT 35
59284: PUSH
59285: LD_INT 110
59287: PUSH
59288: LD_INT 70
59290: PUSH
59291: EMPTY
59292: LIST
59293: LIST
59294: LIST
59295: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59296: LD_VAR 0 6
59300: PPUSH
59301: CALL_OW 265
59305: PUSH
59306: LD_INT 25
59308: EQUAL
59309: IFFALSE 59330
// points := [ 80 , 65 , 100 ] ;
59311: LD_ADDR_VAR 0 9
59315: PUSH
59316: LD_INT 80
59318: PUSH
59319: LD_INT 65
59321: PUSH
59322: LD_INT 100
59324: PUSH
59325: EMPTY
59326: LIST
59327: LIST
59328: LIST
59329: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59330: LD_VAR 0 6
59334: PPUSH
59335: CALL_OW 263
59339: PUSH
59340: LD_INT 1
59342: EQUAL
59343: IFFALSE 59378
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59345: LD_ADDR_VAR 0 10
59349: PUSH
59350: LD_VAR 0 10
59354: PUSH
59355: LD_VAR 0 6
59359: PPUSH
59360: CALL_OW 311
59364: PPUSH
59365: LD_INT 3
59367: PPUSH
59368: CALL_OW 259
59372: PUSH
59373: LD_INT 4
59375: MUL
59376: MUL
59377: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59378: LD_VAR 0 6
59382: PPUSH
59383: CALL_OW 263
59387: PUSH
59388: LD_INT 2
59390: EQUAL
59391: IFFALSE 59442
// begin j := IsControledBy ( i ) ;
59393: LD_ADDR_VAR 0 7
59397: PUSH
59398: LD_VAR 0 6
59402: PPUSH
59403: CALL_OW 312
59407: ST_TO_ADDR
// if j then
59408: LD_VAR 0 7
59412: IFFALSE 59442
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59414: LD_ADDR_VAR 0 10
59418: PUSH
59419: LD_VAR 0 10
59423: PUSH
59424: LD_VAR 0 7
59428: PPUSH
59429: LD_INT 3
59431: PPUSH
59432: CALL_OW 259
59436: PUSH
59437: LD_INT 3
59439: MUL
59440: MUL
59441: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59442: LD_VAR 0 6
59446: PPUSH
59447: CALL_OW 264
59451: PUSH
59452: LD_INT 5
59454: PUSH
59455: LD_INT 6
59457: PUSH
59458: LD_INT 46
59460: PUSH
59461: LD_INT 44
59463: PUSH
59464: LD_INT 47
59466: PUSH
59467: LD_INT 45
59469: PUSH
59470: LD_INT 28
59472: PUSH
59473: LD_INT 7
59475: PUSH
59476: LD_INT 27
59478: PUSH
59479: LD_INT 29
59481: PUSH
59482: EMPTY
59483: LIST
59484: LIST
59485: LIST
59486: LIST
59487: LIST
59488: LIST
59489: LIST
59490: LIST
59491: LIST
59492: LIST
59493: IN
59494: PUSH
59495: LD_VAR 0 1
59499: PPUSH
59500: LD_INT 52
59502: PPUSH
59503: CALL_OW 321
59507: PUSH
59508: LD_INT 2
59510: EQUAL
59511: AND
59512: IFFALSE 59529
// bpoints := bpoints * 1.2 ;
59514: LD_ADDR_VAR 0 10
59518: PUSH
59519: LD_VAR 0 10
59523: PUSH
59524: LD_REAL  1.20000000000000E+0000
59527: MUL
59528: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59529: LD_VAR 0 6
59533: PPUSH
59534: CALL_OW 264
59538: PUSH
59539: LD_INT 6
59541: PUSH
59542: LD_INT 46
59544: PUSH
59545: LD_INT 47
59547: PUSH
59548: EMPTY
59549: LIST
59550: LIST
59551: LIST
59552: IN
59553: IFFALSE 59570
// bpoints := bpoints * 1.2 ;
59555: LD_ADDR_VAR 0 10
59559: PUSH
59560: LD_VAR 0 10
59564: PUSH
59565: LD_REAL  1.20000000000000E+0000
59568: MUL
59569: ST_TO_ADDR
// end ; unit_building :
59570: GO 59584
59572: LD_INT 3
59574: DOUBLE
59575: EQUAL
59576: IFTRUE 59580
59578: GO 59583
59580: POP
// ; end ;
59581: GO 59584
59583: POP
// for j = 1 to 3 do
59584: LD_ADDR_VAR 0 7
59588: PUSH
59589: DOUBLE
59590: LD_INT 1
59592: DEC
59593: ST_TO_ADDR
59594: LD_INT 3
59596: PUSH
59597: FOR_TO
59598: IFFALSE 59651
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59600: LD_ADDR_VAR 0 5
59604: PUSH
59605: LD_VAR 0 5
59609: PPUSH
59610: LD_VAR 0 7
59614: PPUSH
59615: LD_VAR 0 5
59619: PUSH
59620: LD_VAR 0 7
59624: ARRAY
59625: PUSH
59626: LD_VAR 0 9
59630: PUSH
59631: LD_VAR 0 7
59635: ARRAY
59636: PUSH
59637: LD_VAR 0 10
59641: MUL
59642: PLUS
59643: PPUSH
59644: CALL_OW 1
59648: ST_TO_ADDR
59649: GO 59597
59651: POP
59652: POP
// end ;
59653: GO 58132
59655: POP
59656: POP
// result := Replace ( result , 4 , tmp ) ;
59657: LD_ADDR_VAR 0 5
59661: PUSH
59662: LD_VAR 0 5
59666: PPUSH
59667: LD_INT 4
59669: PPUSH
59670: LD_VAR 0 8
59674: PPUSH
59675: CALL_OW 1
59679: ST_TO_ADDR
// end ;
59680: LD_VAR 0 5
59684: RET
// export function DangerAtRange ( unit , range ) ; begin
59685: LD_INT 0
59687: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59688: LD_ADDR_VAR 0 3
59692: PUSH
59693: LD_VAR 0 1
59697: PPUSH
59698: CALL_OW 255
59702: PPUSH
59703: LD_VAR 0 1
59707: PPUSH
59708: CALL_OW 250
59712: PPUSH
59713: LD_VAR 0 1
59717: PPUSH
59718: CALL_OW 251
59722: PPUSH
59723: LD_VAR 0 2
59727: PPUSH
59728: CALL 57984 0 4
59732: ST_TO_ADDR
// end ;
59733: LD_VAR 0 3
59737: RET
// export function DangerInArea ( side , area ) ; begin
59738: LD_INT 0
59740: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59741: LD_ADDR_VAR 0 3
59745: PUSH
59746: LD_VAR 0 2
59750: PPUSH
59751: LD_INT 81
59753: PUSH
59754: LD_VAR 0 1
59758: PUSH
59759: EMPTY
59760: LIST
59761: LIST
59762: PPUSH
59763: CALL_OW 70
59767: ST_TO_ADDR
// end ;
59768: LD_VAR 0 3
59772: RET
// export function IsExtension ( b ) ; begin
59773: LD_INT 0
59775: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59776: LD_ADDR_VAR 0 2
59780: PUSH
59781: LD_VAR 0 1
59785: PUSH
59786: LD_INT 23
59788: PUSH
59789: LD_INT 20
59791: PUSH
59792: LD_INT 22
59794: PUSH
59795: LD_INT 17
59797: PUSH
59798: LD_INT 24
59800: PUSH
59801: LD_INT 21
59803: PUSH
59804: LD_INT 19
59806: PUSH
59807: LD_INT 16
59809: PUSH
59810: LD_INT 25
59812: PUSH
59813: LD_INT 18
59815: PUSH
59816: EMPTY
59817: LIST
59818: LIST
59819: LIST
59820: LIST
59821: LIST
59822: LIST
59823: LIST
59824: LIST
59825: LIST
59826: LIST
59827: IN
59828: ST_TO_ADDR
// end ;
59829: LD_VAR 0 2
59833: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59834: LD_INT 0
59836: PPUSH
59837: PPUSH
59838: PPUSH
// result := [ ] ;
59839: LD_ADDR_VAR 0 4
59843: PUSH
59844: EMPTY
59845: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59846: LD_ADDR_VAR 0 5
59850: PUSH
59851: LD_VAR 0 2
59855: PPUSH
59856: LD_INT 21
59858: PUSH
59859: LD_INT 3
59861: PUSH
59862: EMPTY
59863: LIST
59864: LIST
59865: PPUSH
59866: CALL_OW 70
59870: ST_TO_ADDR
// if not tmp then
59871: LD_VAR 0 5
59875: NOT
59876: IFFALSE 59880
// exit ;
59878: GO 59944
// if checkLink then
59880: LD_VAR 0 3
59884: IFFALSE 59934
// begin for i in tmp do
59886: LD_ADDR_VAR 0 6
59890: PUSH
59891: LD_VAR 0 5
59895: PUSH
59896: FOR_IN
59897: IFFALSE 59932
// if GetBase ( i ) <> base then
59899: LD_VAR 0 6
59903: PPUSH
59904: CALL_OW 274
59908: PUSH
59909: LD_VAR 0 1
59913: NONEQUAL
59914: IFFALSE 59930
// ComLinkToBase ( base , i ) ;
59916: LD_VAR 0 1
59920: PPUSH
59921: LD_VAR 0 6
59925: PPUSH
59926: CALL_OW 169
59930: GO 59896
59932: POP
59933: POP
// end ; result := tmp ;
59934: LD_ADDR_VAR 0 4
59938: PUSH
59939: LD_VAR 0 5
59943: ST_TO_ADDR
// end ;
59944: LD_VAR 0 4
59948: RET
// export function ComComplete ( units , b ) ; var i ; begin
59949: LD_INT 0
59951: PPUSH
59952: PPUSH
// if not units then
59953: LD_VAR 0 1
59957: NOT
59958: IFFALSE 59962
// exit ;
59960: GO 60052
// for i in units do
59962: LD_ADDR_VAR 0 4
59966: PUSH
59967: LD_VAR 0 1
59971: PUSH
59972: FOR_IN
59973: IFFALSE 60050
// if BuildingStatus ( b ) = bs_build then
59975: LD_VAR 0 2
59979: PPUSH
59980: CALL_OW 461
59984: PUSH
59985: LD_INT 1
59987: EQUAL
59988: IFFALSE 60048
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59990: LD_VAR 0 4
59994: PPUSH
59995: LD_STRING h
59997: PUSH
59998: LD_VAR 0 2
60002: PPUSH
60003: CALL_OW 250
60007: PUSH
60008: LD_VAR 0 2
60012: PPUSH
60013: CALL_OW 251
60017: PUSH
60018: LD_VAR 0 2
60022: PUSH
60023: LD_INT 0
60025: PUSH
60026: LD_INT 0
60028: PUSH
60029: LD_INT 0
60031: PUSH
60032: EMPTY
60033: LIST
60034: LIST
60035: LIST
60036: LIST
60037: LIST
60038: LIST
60039: LIST
60040: PUSH
60041: EMPTY
60042: LIST
60043: PPUSH
60044: CALL_OW 446
60048: GO 59972
60050: POP
60051: POP
// end ;
60052: LD_VAR 0 3
60056: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60057: LD_INT 0
60059: PPUSH
60060: PPUSH
60061: PPUSH
60062: PPUSH
60063: PPUSH
60064: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
60065: LD_VAR 0 1
60069: NOT
60070: PUSH
60071: LD_VAR 0 1
60075: PPUSH
60076: CALL_OW 263
60080: PUSH
60081: LD_INT 2
60083: NONEQUAL
60084: OR
60085: IFFALSE 60089
// exit ;
60087: GO 60405
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60089: LD_ADDR_VAR 0 6
60093: PUSH
60094: LD_INT 22
60096: PUSH
60097: LD_VAR 0 1
60101: PPUSH
60102: CALL_OW 255
60106: PUSH
60107: EMPTY
60108: LIST
60109: LIST
60110: PUSH
60111: LD_INT 2
60113: PUSH
60114: LD_INT 30
60116: PUSH
60117: LD_INT 36
60119: PUSH
60120: EMPTY
60121: LIST
60122: LIST
60123: PUSH
60124: LD_INT 34
60126: PUSH
60127: LD_INT 31
60129: PUSH
60130: EMPTY
60131: LIST
60132: LIST
60133: PUSH
60134: EMPTY
60135: LIST
60136: LIST
60137: LIST
60138: PUSH
60139: EMPTY
60140: LIST
60141: LIST
60142: PPUSH
60143: CALL_OW 69
60147: ST_TO_ADDR
// if not tmp then
60148: LD_VAR 0 6
60152: NOT
60153: IFFALSE 60157
// exit ;
60155: GO 60405
// result := [ ] ;
60157: LD_ADDR_VAR 0 2
60161: PUSH
60162: EMPTY
60163: ST_TO_ADDR
// for i in tmp do
60164: LD_ADDR_VAR 0 3
60168: PUSH
60169: LD_VAR 0 6
60173: PUSH
60174: FOR_IN
60175: IFFALSE 60246
// begin t := UnitsInside ( i ) ;
60177: LD_ADDR_VAR 0 4
60181: PUSH
60182: LD_VAR 0 3
60186: PPUSH
60187: CALL_OW 313
60191: ST_TO_ADDR
// if t then
60192: LD_VAR 0 4
60196: IFFALSE 60244
// for j in t do
60198: LD_ADDR_VAR 0 7
60202: PUSH
60203: LD_VAR 0 4
60207: PUSH
60208: FOR_IN
60209: IFFALSE 60242
// result := Replace ( result , result + 1 , j ) ;
60211: LD_ADDR_VAR 0 2
60215: PUSH
60216: LD_VAR 0 2
60220: PPUSH
60221: LD_VAR 0 2
60225: PUSH
60226: LD_INT 1
60228: PLUS
60229: PPUSH
60230: LD_VAR 0 7
60234: PPUSH
60235: CALL_OW 1
60239: ST_TO_ADDR
60240: GO 60208
60242: POP
60243: POP
// end ;
60244: GO 60174
60246: POP
60247: POP
// if not result then
60248: LD_VAR 0 2
60252: NOT
60253: IFFALSE 60257
// exit ;
60255: GO 60405
// mech := result [ 1 ] ;
60257: LD_ADDR_VAR 0 5
60261: PUSH
60262: LD_VAR 0 2
60266: PUSH
60267: LD_INT 1
60269: ARRAY
60270: ST_TO_ADDR
// if result > 1 then
60271: LD_VAR 0 2
60275: PUSH
60276: LD_INT 1
60278: GREATER
60279: IFFALSE 60391
// begin for i = 2 to result do
60281: LD_ADDR_VAR 0 3
60285: PUSH
60286: DOUBLE
60287: LD_INT 2
60289: DEC
60290: ST_TO_ADDR
60291: LD_VAR 0 2
60295: PUSH
60296: FOR_TO
60297: IFFALSE 60389
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60299: LD_ADDR_VAR 0 4
60303: PUSH
60304: LD_VAR 0 2
60308: PUSH
60309: LD_VAR 0 3
60313: ARRAY
60314: PPUSH
60315: LD_INT 3
60317: PPUSH
60318: CALL_OW 259
60322: PUSH
60323: LD_VAR 0 2
60327: PUSH
60328: LD_VAR 0 3
60332: ARRAY
60333: PPUSH
60334: CALL_OW 432
60338: MINUS
60339: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60340: LD_VAR 0 4
60344: PUSH
60345: LD_VAR 0 5
60349: PPUSH
60350: LD_INT 3
60352: PPUSH
60353: CALL_OW 259
60357: PUSH
60358: LD_VAR 0 5
60362: PPUSH
60363: CALL_OW 432
60367: MINUS
60368: GREATEREQUAL
60369: IFFALSE 60387
// mech := result [ i ] ;
60371: LD_ADDR_VAR 0 5
60375: PUSH
60376: LD_VAR 0 2
60380: PUSH
60381: LD_VAR 0 3
60385: ARRAY
60386: ST_TO_ADDR
// end ;
60387: GO 60296
60389: POP
60390: POP
// end ; ComLinkTo ( vehicle , mech ) ;
60391: LD_VAR 0 1
60395: PPUSH
60396: LD_VAR 0 5
60400: PPUSH
60401: CALL_OW 135
// end ;
60405: LD_VAR 0 2
60409: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60410: LD_INT 0
60412: PPUSH
60413: PPUSH
60414: PPUSH
60415: PPUSH
60416: PPUSH
60417: PPUSH
60418: PPUSH
60419: PPUSH
60420: PPUSH
60421: PPUSH
60422: PPUSH
60423: PPUSH
60424: PPUSH
// result := [ ] ;
60425: LD_ADDR_VAR 0 7
60429: PUSH
60430: EMPTY
60431: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60432: LD_VAR 0 1
60436: PPUSH
60437: CALL_OW 266
60441: PUSH
60442: LD_INT 0
60444: PUSH
60445: LD_INT 1
60447: PUSH
60448: EMPTY
60449: LIST
60450: LIST
60451: IN
60452: NOT
60453: IFFALSE 60457
// exit ;
60455: GO 62091
// if name then
60457: LD_VAR 0 3
60461: IFFALSE 60477
// SetBName ( base_dep , name ) ;
60463: LD_VAR 0 1
60467: PPUSH
60468: LD_VAR 0 3
60472: PPUSH
60473: CALL_OW 500
// base := GetBase ( base_dep ) ;
60477: LD_ADDR_VAR 0 15
60481: PUSH
60482: LD_VAR 0 1
60486: PPUSH
60487: CALL_OW 274
60491: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60492: LD_ADDR_VAR 0 16
60496: PUSH
60497: LD_VAR 0 1
60501: PPUSH
60502: CALL_OW 255
60506: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60507: LD_ADDR_VAR 0 17
60511: PUSH
60512: LD_VAR 0 1
60516: PPUSH
60517: CALL_OW 248
60521: ST_TO_ADDR
// if sources then
60522: LD_VAR 0 5
60526: IFFALSE 60573
// for i = 1 to 3 do
60528: LD_ADDR_VAR 0 8
60532: PUSH
60533: DOUBLE
60534: LD_INT 1
60536: DEC
60537: ST_TO_ADDR
60538: LD_INT 3
60540: PUSH
60541: FOR_TO
60542: IFFALSE 60571
// AddResourceType ( base , i , sources [ i ] ) ;
60544: LD_VAR 0 15
60548: PPUSH
60549: LD_VAR 0 8
60553: PPUSH
60554: LD_VAR 0 5
60558: PUSH
60559: LD_VAR 0 8
60563: ARRAY
60564: PPUSH
60565: CALL_OW 276
60569: GO 60541
60571: POP
60572: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
60573: LD_ADDR_VAR 0 18
60577: PUSH
60578: LD_VAR 0 15
60582: PPUSH
60583: LD_VAR 0 2
60587: PPUSH
60588: LD_INT 1
60590: PPUSH
60591: CALL 59834 0 3
60595: ST_TO_ADDR
// InitHc ;
60596: CALL_OW 19
// InitUc ;
60600: CALL_OW 18
// uc_side := side ;
60604: LD_ADDR_OWVAR 20
60608: PUSH
60609: LD_VAR 0 16
60613: ST_TO_ADDR
// uc_nation := nation ;
60614: LD_ADDR_OWVAR 21
60618: PUSH
60619: LD_VAR 0 17
60623: ST_TO_ADDR
// if buildings then
60624: LD_VAR 0 18
60628: IFFALSE 61950
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60630: LD_ADDR_VAR 0 19
60634: PUSH
60635: LD_VAR 0 18
60639: PPUSH
60640: LD_INT 2
60642: PUSH
60643: LD_INT 30
60645: PUSH
60646: LD_INT 29
60648: PUSH
60649: EMPTY
60650: LIST
60651: LIST
60652: PUSH
60653: LD_INT 30
60655: PUSH
60656: LD_INT 30
60658: PUSH
60659: EMPTY
60660: LIST
60661: LIST
60662: PUSH
60663: EMPTY
60664: LIST
60665: LIST
60666: LIST
60667: PPUSH
60668: CALL_OW 72
60672: ST_TO_ADDR
// if tmp then
60673: LD_VAR 0 19
60677: IFFALSE 60725
// for i in tmp do
60679: LD_ADDR_VAR 0 8
60683: PUSH
60684: LD_VAR 0 19
60688: PUSH
60689: FOR_IN
60690: IFFALSE 60723
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60692: LD_VAR 0 8
60696: PPUSH
60697: CALL_OW 250
60701: PPUSH
60702: LD_VAR 0 8
60706: PPUSH
60707: CALL_OW 251
60711: PPUSH
60712: LD_VAR 0 16
60716: PPUSH
60717: CALL_OW 441
60721: GO 60689
60723: POP
60724: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60725: LD_VAR 0 18
60729: PPUSH
60730: LD_INT 2
60732: PUSH
60733: LD_INT 30
60735: PUSH
60736: LD_INT 32
60738: PUSH
60739: EMPTY
60740: LIST
60741: LIST
60742: PUSH
60743: LD_INT 30
60745: PUSH
60746: LD_INT 33
60748: PUSH
60749: EMPTY
60750: LIST
60751: LIST
60752: PUSH
60753: EMPTY
60754: LIST
60755: LIST
60756: LIST
60757: PPUSH
60758: CALL_OW 72
60762: IFFALSE 60850
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60764: LD_ADDR_VAR 0 8
60768: PUSH
60769: LD_VAR 0 18
60773: PPUSH
60774: LD_INT 2
60776: PUSH
60777: LD_INT 30
60779: PUSH
60780: LD_INT 32
60782: PUSH
60783: EMPTY
60784: LIST
60785: LIST
60786: PUSH
60787: LD_INT 30
60789: PUSH
60790: LD_INT 33
60792: PUSH
60793: EMPTY
60794: LIST
60795: LIST
60796: PUSH
60797: EMPTY
60798: LIST
60799: LIST
60800: LIST
60801: PPUSH
60802: CALL_OW 72
60806: PUSH
60807: FOR_IN
60808: IFFALSE 60848
// begin if not GetBWeapon ( i ) then
60810: LD_VAR 0 8
60814: PPUSH
60815: CALL_OW 269
60819: NOT
60820: IFFALSE 60846
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60822: LD_VAR 0 8
60826: PPUSH
60827: LD_VAR 0 8
60831: PPUSH
60832: LD_VAR 0 2
60836: PPUSH
60837: CALL 62096 0 2
60841: PPUSH
60842: CALL_OW 431
// end ;
60846: GO 60807
60848: POP
60849: POP
// end ; for i = 1 to personel do
60850: LD_ADDR_VAR 0 8
60854: PUSH
60855: DOUBLE
60856: LD_INT 1
60858: DEC
60859: ST_TO_ADDR
60860: LD_VAR 0 6
60864: PUSH
60865: FOR_TO
60866: IFFALSE 61930
// begin if i > 4 then
60868: LD_VAR 0 8
60872: PUSH
60873: LD_INT 4
60875: GREATER
60876: IFFALSE 60880
// break ;
60878: GO 61930
// case i of 1 :
60880: LD_VAR 0 8
60884: PUSH
60885: LD_INT 1
60887: DOUBLE
60888: EQUAL
60889: IFTRUE 60893
60891: GO 60973
60893: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60894: LD_ADDR_VAR 0 12
60898: PUSH
60899: LD_VAR 0 18
60903: PPUSH
60904: LD_INT 22
60906: PUSH
60907: LD_VAR 0 16
60911: PUSH
60912: EMPTY
60913: LIST
60914: LIST
60915: PUSH
60916: LD_INT 58
60918: PUSH
60919: EMPTY
60920: LIST
60921: PUSH
60922: LD_INT 2
60924: PUSH
60925: LD_INT 30
60927: PUSH
60928: LD_INT 32
60930: PUSH
60931: EMPTY
60932: LIST
60933: LIST
60934: PUSH
60935: LD_INT 30
60937: PUSH
60938: LD_INT 4
60940: PUSH
60941: EMPTY
60942: LIST
60943: LIST
60944: PUSH
60945: LD_INT 30
60947: PUSH
60948: LD_INT 5
60950: PUSH
60951: EMPTY
60952: LIST
60953: LIST
60954: PUSH
60955: EMPTY
60956: LIST
60957: LIST
60958: LIST
60959: LIST
60960: PUSH
60961: EMPTY
60962: LIST
60963: LIST
60964: LIST
60965: PPUSH
60966: CALL_OW 72
60970: ST_TO_ADDR
60971: GO 61195
60973: LD_INT 2
60975: DOUBLE
60976: EQUAL
60977: IFTRUE 60981
60979: GO 61043
60981: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60982: LD_ADDR_VAR 0 12
60986: PUSH
60987: LD_VAR 0 18
60991: PPUSH
60992: LD_INT 22
60994: PUSH
60995: LD_VAR 0 16
60999: PUSH
61000: EMPTY
61001: LIST
61002: LIST
61003: PUSH
61004: LD_INT 2
61006: PUSH
61007: LD_INT 30
61009: PUSH
61010: LD_INT 0
61012: PUSH
61013: EMPTY
61014: LIST
61015: LIST
61016: PUSH
61017: LD_INT 30
61019: PUSH
61020: LD_INT 1
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: LIST
61031: PUSH
61032: EMPTY
61033: LIST
61034: LIST
61035: PPUSH
61036: CALL_OW 72
61040: ST_TO_ADDR
61041: GO 61195
61043: LD_INT 3
61045: DOUBLE
61046: EQUAL
61047: IFTRUE 61051
61049: GO 61113
61051: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61052: LD_ADDR_VAR 0 12
61056: PUSH
61057: LD_VAR 0 18
61061: PPUSH
61062: LD_INT 22
61064: PUSH
61065: LD_VAR 0 16
61069: PUSH
61070: EMPTY
61071: LIST
61072: LIST
61073: PUSH
61074: LD_INT 2
61076: PUSH
61077: LD_INT 30
61079: PUSH
61080: LD_INT 2
61082: PUSH
61083: EMPTY
61084: LIST
61085: LIST
61086: PUSH
61087: LD_INT 30
61089: PUSH
61090: LD_INT 3
61092: PUSH
61093: EMPTY
61094: LIST
61095: LIST
61096: PUSH
61097: EMPTY
61098: LIST
61099: LIST
61100: LIST
61101: PUSH
61102: EMPTY
61103: LIST
61104: LIST
61105: PPUSH
61106: CALL_OW 72
61110: ST_TO_ADDR
61111: GO 61195
61113: LD_INT 4
61115: DOUBLE
61116: EQUAL
61117: IFTRUE 61121
61119: GO 61194
61121: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61122: LD_ADDR_VAR 0 12
61126: PUSH
61127: LD_VAR 0 18
61131: PPUSH
61132: LD_INT 22
61134: PUSH
61135: LD_VAR 0 16
61139: PUSH
61140: EMPTY
61141: LIST
61142: LIST
61143: PUSH
61144: LD_INT 2
61146: PUSH
61147: LD_INT 30
61149: PUSH
61150: LD_INT 6
61152: PUSH
61153: EMPTY
61154: LIST
61155: LIST
61156: PUSH
61157: LD_INT 30
61159: PUSH
61160: LD_INT 7
61162: PUSH
61163: EMPTY
61164: LIST
61165: LIST
61166: PUSH
61167: LD_INT 30
61169: PUSH
61170: LD_INT 8
61172: PUSH
61173: EMPTY
61174: LIST
61175: LIST
61176: PUSH
61177: EMPTY
61178: LIST
61179: LIST
61180: LIST
61181: LIST
61182: PUSH
61183: EMPTY
61184: LIST
61185: LIST
61186: PPUSH
61187: CALL_OW 72
61191: ST_TO_ADDR
61192: GO 61195
61194: POP
// if i = 1 then
61195: LD_VAR 0 8
61199: PUSH
61200: LD_INT 1
61202: EQUAL
61203: IFFALSE 61314
// begin tmp := [ ] ;
61205: LD_ADDR_VAR 0 19
61209: PUSH
61210: EMPTY
61211: ST_TO_ADDR
// for j in f do
61212: LD_ADDR_VAR 0 9
61216: PUSH
61217: LD_VAR 0 12
61221: PUSH
61222: FOR_IN
61223: IFFALSE 61296
// if GetBType ( j ) = b_bunker then
61225: LD_VAR 0 9
61229: PPUSH
61230: CALL_OW 266
61234: PUSH
61235: LD_INT 32
61237: EQUAL
61238: IFFALSE 61265
// tmp := Insert ( tmp , 1 , j ) else
61240: LD_ADDR_VAR 0 19
61244: PUSH
61245: LD_VAR 0 19
61249: PPUSH
61250: LD_INT 1
61252: PPUSH
61253: LD_VAR 0 9
61257: PPUSH
61258: CALL_OW 2
61262: ST_TO_ADDR
61263: GO 61294
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61265: LD_ADDR_VAR 0 19
61269: PUSH
61270: LD_VAR 0 19
61274: PPUSH
61275: LD_VAR 0 19
61279: PUSH
61280: LD_INT 1
61282: PLUS
61283: PPUSH
61284: LD_VAR 0 9
61288: PPUSH
61289: CALL_OW 2
61293: ST_TO_ADDR
61294: GO 61222
61296: POP
61297: POP
// if tmp then
61298: LD_VAR 0 19
61302: IFFALSE 61314
// f := tmp ;
61304: LD_ADDR_VAR 0 12
61308: PUSH
61309: LD_VAR 0 19
61313: ST_TO_ADDR
// end ; x := personel [ i ] ;
61314: LD_ADDR_VAR 0 13
61318: PUSH
61319: LD_VAR 0 6
61323: PUSH
61324: LD_VAR 0 8
61328: ARRAY
61329: ST_TO_ADDR
// if x = - 1 then
61330: LD_VAR 0 13
61334: PUSH
61335: LD_INT 1
61337: NEG
61338: EQUAL
61339: IFFALSE 61548
// begin for j in f do
61341: LD_ADDR_VAR 0 9
61345: PUSH
61346: LD_VAR 0 12
61350: PUSH
61351: FOR_IN
61352: IFFALSE 61544
// repeat InitHc ;
61354: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61358: LD_VAR 0 9
61362: PPUSH
61363: CALL_OW 266
61367: PUSH
61368: LD_INT 5
61370: EQUAL
61371: IFFALSE 61441
// begin if UnitsInside ( j ) < 3 then
61373: LD_VAR 0 9
61377: PPUSH
61378: CALL_OW 313
61382: PUSH
61383: LD_INT 3
61385: LESS
61386: IFFALSE 61422
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61388: LD_INT 0
61390: PPUSH
61391: LD_INT 5
61393: PUSH
61394: LD_INT 8
61396: PUSH
61397: LD_INT 9
61399: PUSH
61400: EMPTY
61401: LIST
61402: LIST
61403: LIST
61404: PUSH
61405: LD_VAR 0 17
61409: ARRAY
61410: PPUSH
61411: LD_VAR 0 4
61415: PPUSH
61416: CALL_OW 380
61420: GO 61439
// PrepareHuman ( false , i , skill ) ;
61422: LD_INT 0
61424: PPUSH
61425: LD_VAR 0 8
61429: PPUSH
61430: LD_VAR 0 4
61434: PPUSH
61435: CALL_OW 380
// end else
61439: GO 61458
// PrepareHuman ( false , i , skill ) ;
61441: LD_INT 0
61443: PPUSH
61444: LD_VAR 0 8
61448: PPUSH
61449: LD_VAR 0 4
61453: PPUSH
61454: CALL_OW 380
// un := CreateHuman ;
61458: LD_ADDR_VAR 0 14
61462: PUSH
61463: CALL_OW 44
61467: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61468: LD_ADDR_VAR 0 7
61472: PUSH
61473: LD_VAR 0 7
61477: PPUSH
61478: LD_INT 1
61480: PPUSH
61481: LD_VAR 0 14
61485: PPUSH
61486: CALL_OW 2
61490: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61491: LD_VAR 0 14
61495: PPUSH
61496: LD_VAR 0 9
61500: PPUSH
61501: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61505: LD_VAR 0 9
61509: PPUSH
61510: CALL_OW 313
61514: PUSH
61515: LD_INT 6
61517: EQUAL
61518: PUSH
61519: LD_VAR 0 9
61523: PPUSH
61524: CALL_OW 266
61528: PUSH
61529: LD_INT 32
61531: PUSH
61532: LD_INT 31
61534: PUSH
61535: EMPTY
61536: LIST
61537: LIST
61538: IN
61539: OR
61540: IFFALSE 61354
61542: GO 61351
61544: POP
61545: POP
// end else
61546: GO 61928
// for j = 1 to x do
61548: LD_ADDR_VAR 0 9
61552: PUSH
61553: DOUBLE
61554: LD_INT 1
61556: DEC
61557: ST_TO_ADDR
61558: LD_VAR 0 13
61562: PUSH
61563: FOR_TO
61564: IFFALSE 61926
// begin InitHc ;
61566: CALL_OW 19
// if not f then
61570: LD_VAR 0 12
61574: NOT
61575: IFFALSE 61664
// begin PrepareHuman ( false , i , skill ) ;
61577: LD_INT 0
61579: PPUSH
61580: LD_VAR 0 8
61584: PPUSH
61585: LD_VAR 0 4
61589: PPUSH
61590: CALL_OW 380
// un := CreateHuman ;
61594: LD_ADDR_VAR 0 14
61598: PUSH
61599: CALL_OW 44
61603: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61604: LD_ADDR_VAR 0 7
61608: PUSH
61609: LD_VAR 0 7
61613: PPUSH
61614: LD_INT 1
61616: PPUSH
61617: LD_VAR 0 14
61621: PPUSH
61622: CALL_OW 2
61626: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61627: LD_VAR 0 14
61631: PPUSH
61632: LD_VAR 0 1
61636: PPUSH
61637: CALL_OW 250
61641: PPUSH
61642: LD_VAR 0 1
61646: PPUSH
61647: CALL_OW 251
61651: PPUSH
61652: LD_INT 10
61654: PPUSH
61655: LD_INT 0
61657: PPUSH
61658: CALL_OW 50
// continue ;
61662: GO 61563
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61664: LD_VAR 0 12
61668: PUSH
61669: LD_INT 1
61671: ARRAY
61672: PPUSH
61673: CALL_OW 313
61677: PUSH
61678: LD_VAR 0 12
61682: PUSH
61683: LD_INT 1
61685: ARRAY
61686: PPUSH
61687: CALL_OW 266
61691: PUSH
61692: LD_INT 32
61694: PUSH
61695: LD_INT 31
61697: PUSH
61698: EMPTY
61699: LIST
61700: LIST
61701: IN
61702: AND
61703: PUSH
61704: LD_VAR 0 12
61708: PUSH
61709: LD_INT 1
61711: ARRAY
61712: PPUSH
61713: CALL_OW 313
61717: PUSH
61718: LD_INT 6
61720: EQUAL
61721: OR
61722: IFFALSE 61742
// f := Delete ( f , 1 ) ;
61724: LD_ADDR_VAR 0 12
61728: PUSH
61729: LD_VAR 0 12
61733: PPUSH
61734: LD_INT 1
61736: PPUSH
61737: CALL_OW 3
61741: ST_TO_ADDR
// if not f then
61742: LD_VAR 0 12
61746: NOT
61747: IFFALSE 61765
// begin x := x + 2 ;
61749: LD_ADDR_VAR 0 13
61753: PUSH
61754: LD_VAR 0 13
61758: PUSH
61759: LD_INT 2
61761: PLUS
61762: ST_TO_ADDR
// continue ;
61763: GO 61563
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61765: LD_VAR 0 12
61769: PUSH
61770: LD_INT 1
61772: ARRAY
61773: PPUSH
61774: CALL_OW 266
61778: PUSH
61779: LD_INT 5
61781: EQUAL
61782: IFFALSE 61856
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61784: LD_VAR 0 12
61788: PUSH
61789: LD_INT 1
61791: ARRAY
61792: PPUSH
61793: CALL_OW 313
61797: PUSH
61798: LD_INT 3
61800: LESS
61801: IFFALSE 61837
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61803: LD_INT 0
61805: PPUSH
61806: LD_INT 5
61808: PUSH
61809: LD_INT 8
61811: PUSH
61812: LD_INT 9
61814: PUSH
61815: EMPTY
61816: LIST
61817: LIST
61818: LIST
61819: PUSH
61820: LD_VAR 0 17
61824: ARRAY
61825: PPUSH
61826: LD_VAR 0 4
61830: PPUSH
61831: CALL_OW 380
61835: GO 61854
// PrepareHuman ( false , i , skill ) ;
61837: LD_INT 0
61839: PPUSH
61840: LD_VAR 0 8
61844: PPUSH
61845: LD_VAR 0 4
61849: PPUSH
61850: CALL_OW 380
// end else
61854: GO 61873
// PrepareHuman ( false , i , skill ) ;
61856: LD_INT 0
61858: PPUSH
61859: LD_VAR 0 8
61863: PPUSH
61864: LD_VAR 0 4
61868: PPUSH
61869: CALL_OW 380
// un := CreateHuman ;
61873: LD_ADDR_VAR 0 14
61877: PUSH
61878: CALL_OW 44
61882: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61883: LD_ADDR_VAR 0 7
61887: PUSH
61888: LD_VAR 0 7
61892: PPUSH
61893: LD_INT 1
61895: PPUSH
61896: LD_VAR 0 14
61900: PPUSH
61901: CALL_OW 2
61905: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61906: LD_VAR 0 14
61910: PPUSH
61911: LD_VAR 0 12
61915: PUSH
61916: LD_INT 1
61918: ARRAY
61919: PPUSH
61920: CALL_OW 52
// end ;
61924: GO 61563
61926: POP
61927: POP
// end ;
61928: GO 60865
61930: POP
61931: POP
// result := result ^ buildings ;
61932: LD_ADDR_VAR 0 7
61936: PUSH
61937: LD_VAR 0 7
61941: PUSH
61942: LD_VAR 0 18
61946: ADD
61947: ST_TO_ADDR
// end else
61948: GO 62091
// begin for i = 1 to personel do
61950: LD_ADDR_VAR 0 8
61954: PUSH
61955: DOUBLE
61956: LD_INT 1
61958: DEC
61959: ST_TO_ADDR
61960: LD_VAR 0 6
61964: PUSH
61965: FOR_TO
61966: IFFALSE 62089
// begin if i > 4 then
61968: LD_VAR 0 8
61972: PUSH
61973: LD_INT 4
61975: GREATER
61976: IFFALSE 61980
// break ;
61978: GO 62089
// x := personel [ i ] ;
61980: LD_ADDR_VAR 0 13
61984: PUSH
61985: LD_VAR 0 6
61989: PUSH
61990: LD_VAR 0 8
61994: ARRAY
61995: ST_TO_ADDR
// if x = - 1 then
61996: LD_VAR 0 13
62000: PUSH
62001: LD_INT 1
62003: NEG
62004: EQUAL
62005: IFFALSE 62009
// continue ;
62007: GO 61965
// PrepareHuman ( false , i , skill ) ;
62009: LD_INT 0
62011: PPUSH
62012: LD_VAR 0 8
62016: PPUSH
62017: LD_VAR 0 4
62021: PPUSH
62022: CALL_OW 380
// un := CreateHuman ;
62026: LD_ADDR_VAR 0 14
62030: PUSH
62031: CALL_OW 44
62035: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62036: LD_VAR 0 14
62040: PPUSH
62041: LD_VAR 0 1
62045: PPUSH
62046: CALL_OW 250
62050: PPUSH
62051: LD_VAR 0 1
62055: PPUSH
62056: CALL_OW 251
62060: PPUSH
62061: LD_INT 10
62063: PPUSH
62064: LD_INT 0
62066: PPUSH
62067: CALL_OW 50
// result := result ^ un ;
62071: LD_ADDR_VAR 0 7
62075: PUSH
62076: LD_VAR 0 7
62080: PUSH
62081: LD_VAR 0 14
62085: ADD
62086: ST_TO_ADDR
// end ;
62087: GO 61965
62089: POP
62090: POP
// end ; end ;
62091: LD_VAR 0 7
62095: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62096: LD_INT 0
62098: PPUSH
62099: PPUSH
62100: PPUSH
62101: PPUSH
62102: PPUSH
62103: PPUSH
62104: PPUSH
62105: PPUSH
62106: PPUSH
62107: PPUSH
62108: PPUSH
62109: PPUSH
62110: PPUSH
62111: PPUSH
62112: PPUSH
62113: PPUSH
// result := false ;
62114: LD_ADDR_VAR 0 3
62118: PUSH
62119: LD_INT 0
62121: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62122: LD_VAR 0 1
62126: NOT
62127: PUSH
62128: LD_VAR 0 1
62132: PPUSH
62133: CALL_OW 266
62137: PUSH
62138: LD_INT 32
62140: PUSH
62141: LD_INT 33
62143: PUSH
62144: EMPTY
62145: LIST
62146: LIST
62147: IN
62148: NOT
62149: OR
62150: IFFALSE 62154
// exit ;
62152: GO 63263
// nat := GetNation ( tower ) ;
62154: LD_ADDR_VAR 0 12
62158: PUSH
62159: LD_VAR 0 1
62163: PPUSH
62164: CALL_OW 248
62168: ST_TO_ADDR
// side := GetSide ( tower ) ;
62169: LD_ADDR_VAR 0 16
62173: PUSH
62174: LD_VAR 0 1
62178: PPUSH
62179: CALL_OW 255
62183: ST_TO_ADDR
// x := GetX ( tower ) ;
62184: LD_ADDR_VAR 0 10
62188: PUSH
62189: LD_VAR 0 1
62193: PPUSH
62194: CALL_OW 250
62198: ST_TO_ADDR
// y := GetY ( tower ) ;
62199: LD_ADDR_VAR 0 11
62203: PUSH
62204: LD_VAR 0 1
62208: PPUSH
62209: CALL_OW 251
62213: ST_TO_ADDR
// if not x or not y then
62214: LD_VAR 0 10
62218: NOT
62219: PUSH
62220: LD_VAR 0 11
62224: NOT
62225: OR
62226: IFFALSE 62230
// exit ;
62228: GO 63263
// weapon := 0 ;
62230: LD_ADDR_VAR 0 18
62234: PUSH
62235: LD_INT 0
62237: ST_TO_ADDR
// fac_list := [ ] ;
62238: LD_ADDR_VAR 0 17
62242: PUSH
62243: EMPTY
62244: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62245: LD_ADDR_VAR 0 6
62249: PUSH
62250: LD_VAR 0 1
62254: PPUSH
62255: CALL_OW 274
62259: PPUSH
62260: LD_VAR 0 2
62264: PPUSH
62265: LD_INT 0
62267: PPUSH
62268: CALL 59834 0 3
62272: PPUSH
62273: LD_INT 30
62275: PUSH
62276: LD_INT 3
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: PPUSH
62283: CALL_OW 72
62287: ST_TO_ADDR
// if not factories then
62288: LD_VAR 0 6
62292: NOT
62293: IFFALSE 62297
// exit ;
62295: GO 63263
// for i in factories do
62297: LD_ADDR_VAR 0 8
62301: PUSH
62302: LD_VAR 0 6
62306: PUSH
62307: FOR_IN
62308: IFFALSE 62333
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62310: LD_ADDR_VAR 0 17
62314: PUSH
62315: LD_VAR 0 17
62319: PUSH
62320: LD_VAR 0 8
62324: PPUSH
62325: CALL_OW 478
62329: UNION
62330: ST_TO_ADDR
62331: GO 62307
62333: POP
62334: POP
// if not fac_list then
62335: LD_VAR 0 17
62339: NOT
62340: IFFALSE 62344
// exit ;
62342: GO 63263
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62344: LD_ADDR_VAR 0 5
62348: PUSH
62349: LD_INT 4
62351: PUSH
62352: LD_INT 5
62354: PUSH
62355: LD_INT 9
62357: PUSH
62358: LD_INT 10
62360: PUSH
62361: LD_INT 6
62363: PUSH
62364: LD_INT 7
62366: PUSH
62367: LD_INT 11
62369: PUSH
62370: EMPTY
62371: LIST
62372: LIST
62373: LIST
62374: LIST
62375: LIST
62376: LIST
62377: LIST
62378: PUSH
62379: LD_INT 27
62381: PUSH
62382: LD_INT 28
62384: PUSH
62385: LD_INT 26
62387: PUSH
62388: LD_INT 30
62390: PUSH
62391: EMPTY
62392: LIST
62393: LIST
62394: LIST
62395: LIST
62396: PUSH
62397: LD_INT 43
62399: PUSH
62400: LD_INT 44
62402: PUSH
62403: LD_INT 46
62405: PUSH
62406: LD_INT 45
62408: PUSH
62409: LD_INT 47
62411: PUSH
62412: LD_INT 49
62414: PUSH
62415: EMPTY
62416: LIST
62417: LIST
62418: LIST
62419: LIST
62420: LIST
62421: LIST
62422: PUSH
62423: EMPTY
62424: LIST
62425: LIST
62426: LIST
62427: PUSH
62428: LD_VAR 0 12
62432: ARRAY
62433: ST_TO_ADDR
// list := list isect fac_list ;
62434: LD_ADDR_VAR 0 5
62438: PUSH
62439: LD_VAR 0 5
62443: PUSH
62444: LD_VAR 0 17
62448: ISECT
62449: ST_TO_ADDR
// if not list then
62450: LD_VAR 0 5
62454: NOT
62455: IFFALSE 62459
// exit ;
62457: GO 63263
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62459: LD_VAR 0 12
62463: PUSH
62464: LD_INT 3
62466: EQUAL
62467: PUSH
62468: LD_INT 49
62470: PUSH
62471: LD_VAR 0 5
62475: IN
62476: AND
62477: PUSH
62478: LD_INT 31
62480: PPUSH
62481: LD_VAR 0 16
62485: PPUSH
62486: CALL_OW 321
62490: PUSH
62491: LD_INT 2
62493: EQUAL
62494: AND
62495: IFFALSE 62555
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62497: LD_INT 22
62499: PUSH
62500: LD_VAR 0 16
62504: PUSH
62505: EMPTY
62506: LIST
62507: LIST
62508: PUSH
62509: LD_INT 35
62511: PUSH
62512: LD_INT 49
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: PUSH
62519: LD_INT 91
62521: PUSH
62522: LD_VAR 0 1
62526: PUSH
62527: LD_INT 10
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: LIST
62534: PUSH
62535: EMPTY
62536: LIST
62537: LIST
62538: LIST
62539: PPUSH
62540: CALL_OW 69
62544: NOT
62545: IFFALSE 62555
// weapon := ru_time_lapser ;
62547: LD_ADDR_VAR 0 18
62551: PUSH
62552: LD_INT 49
62554: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62555: LD_VAR 0 12
62559: PUSH
62560: LD_INT 1
62562: PUSH
62563: LD_INT 2
62565: PUSH
62566: EMPTY
62567: LIST
62568: LIST
62569: IN
62570: PUSH
62571: LD_INT 11
62573: PUSH
62574: LD_VAR 0 5
62578: IN
62579: PUSH
62580: LD_INT 30
62582: PUSH
62583: LD_VAR 0 5
62587: IN
62588: OR
62589: AND
62590: PUSH
62591: LD_INT 6
62593: PPUSH
62594: LD_VAR 0 16
62598: PPUSH
62599: CALL_OW 321
62603: PUSH
62604: LD_INT 2
62606: EQUAL
62607: AND
62608: IFFALSE 62773
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62610: LD_INT 22
62612: PUSH
62613: LD_VAR 0 16
62617: PUSH
62618: EMPTY
62619: LIST
62620: LIST
62621: PUSH
62622: LD_INT 2
62624: PUSH
62625: LD_INT 35
62627: PUSH
62628: LD_INT 11
62630: PUSH
62631: EMPTY
62632: LIST
62633: LIST
62634: PUSH
62635: LD_INT 35
62637: PUSH
62638: LD_INT 30
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: PUSH
62645: EMPTY
62646: LIST
62647: LIST
62648: LIST
62649: PUSH
62650: LD_INT 91
62652: PUSH
62653: LD_VAR 0 1
62657: PUSH
62658: LD_INT 18
62660: PUSH
62661: EMPTY
62662: LIST
62663: LIST
62664: LIST
62665: PUSH
62666: EMPTY
62667: LIST
62668: LIST
62669: LIST
62670: PPUSH
62671: CALL_OW 69
62675: NOT
62676: PUSH
62677: LD_INT 22
62679: PUSH
62680: LD_VAR 0 16
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: PUSH
62689: LD_INT 2
62691: PUSH
62692: LD_INT 30
62694: PUSH
62695: LD_INT 32
62697: PUSH
62698: EMPTY
62699: LIST
62700: LIST
62701: PUSH
62702: LD_INT 30
62704: PUSH
62705: LD_INT 33
62707: PUSH
62708: EMPTY
62709: LIST
62710: LIST
62711: PUSH
62712: EMPTY
62713: LIST
62714: LIST
62715: LIST
62716: PUSH
62717: LD_INT 91
62719: PUSH
62720: LD_VAR 0 1
62724: PUSH
62725: LD_INT 12
62727: PUSH
62728: EMPTY
62729: LIST
62730: LIST
62731: LIST
62732: PUSH
62733: EMPTY
62734: LIST
62735: LIST
62736: LIST
62737: PUSH
62738: EMPTY
62739: LIST
62740: PPUSH
62741: CALL_OW 69
62745: PUSH
62746: LD_INT 2
62748: GREATER
62749: AND
62750: IFFALSE 62773
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62752: LD_ADDR_VAR 0 18
62756: PUSH
62757: LD_INT 11
62759: PUSH
62760: LD_INT 30
62762: PUSH
62763: EMPTY
62764: LIST
62765: LIST
62766: PUSH
62767: LD_VAR 0 12
62771: ARRAY
62772: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62773: LD_VAR 0 18
62777: NOT
62778: PUSH
62779: LD_INT 40
62781: PPUSH
62782: LD_VAR 0 16
62786: PPUSH
62787: CALL_OW 321
62791: PUSH
62792: LD_INT 2
62794: EQUAL
62795: AND
62796: PUSH
62797: LD_INT 7
62799: PUSH
62800: LD_VAR 0 5
62804: IN
62805: PUSH
62806: LD_INT 28
62808: PUSH
62809: LD_VAR 0 5
62813: IN
62814: OR
62815: PUSH
62816: LD_INT 45
62818: PUSH
62819: LD_VAR 0 5
62823: IN
62824: OR
62825: AND
62826: IFFALSE 63080
// begin hex := GetHexInfo ( x , y ) ;
62828: LD_ADDR_VAR 0 4
62832: PUSH
62833: LD_VAR 0 10
62837: PPUSH
62838: LD_VAR 0 11
62842: PPUSH
62843: CALL_OW 546
62847: ST_TO_ADDR
// if hex [ 1 ] then
62848: LD_VAR 0 4
62852: PUSH
62853: LD_INT 1
62855: ARRAY
62856: IFFALSE 62860
// exit ;
62858: GO 63263
// height := hex [ 2 ] ;
62860: LD_ADDR_VAR 0 15
62864: PUSH
62865: LD_VAR 0 4
62869: PUSH
62870: LD_INT 2
62872: ARRAY
62873: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62874: LD_ADDR_VAR 0 14
62878: PUSH
62879: LD_INT 0
62881: PUSH
62882: LD_INT 2
62884: PUSH
62885: LD_INT 3
62887: PUSH
62888: LD_INT 5
62890: PUSH
62891: EMPTY
62892: LIST
62893: LIST
62894: LIST
62895: LIST
62896: ST_TO_ADDR
// for i in tmp do
62897: LD_ADDR_VAR 0 8
62901: PUSH
62902: LD_VAR 0 14
62906: PUSH
62907: FOR_IN
62908: IFFALSE 63078
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62910: LD_ADDR_VAR 0 9
62914: PUSH
62915: LD_VAR 0 10
62919: PPUSH
62920: LD_VAR 0 8
62924: PPUSH
62925: LD_INT 5
62927: PPUSH
62928: CALL_OW 272
62932: PUSH
62933: LD_VAR 0 11
62937: PPUSH
62938: LD_VAR 0 8
62942: PPUSH
62943: LD_INT 5
62945: PPUSH
62946: CALL_OW 273
62950: PUSH
62951: EMPTY
62952: LIST
62953: LIST
62954: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62955: LD_VAR 0 9
62959: PUSH
62960: LD_INT 1
62962: ARRAY
62963: PPUSH
62964: LD_VAR 0 9
62968: PUSH
62969: LD_INT 2
62971: ARRAY
62972: PPUSH
62973: CALL_OW 488
62977: IFFALSE 63076
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62979: LD_ADDR_VAR 0 4
62983: PUSH
62984: LD_VAR 0 9
62988: PUSH
62989: LD_INT 1
62991: ARRAY
62992: PPUSH
62993: LD_VAR 0 9
62997: PUSH
62998: LD_INT 2
63000: ARRAY
63001: PPUSH
63002: CALL_OW 546
63006: ST_TO_ADDR
// if hex [ 1 ] then
63007: LD_VAR 0 4
63011: PUSH
63012: LD_INT 1
63014: ARRAY
63015: IFFALSE 63019
// continue ;
63017: GO 62907
// h := hex [ 2 ] ;
63019: LD_ADDR_VAR 0 13
63023: PUSH
63024: LD_VAR 0 4
63028: PUSH
63029: LD_INT 2
63031: ARRAY
63032: ST_TO_ADDR
// if h + 7 < height then
63033: LD_VAR 0 13
63037: PUSH
63038: LD_INT 7
63040: PLUS
63041: PUSH
63042: LD_VAR 0 15
63046: LESS
63047: IFFALSE 63076
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63049: LD_ADDR_VAR 0 18
63053: PUSH
63054: LD_INT 7
63056: PUSH
63057: LD_INT 28
63059: PUSH
63060: LD_INT 45
63062: PUSH
63063: EMPTY
63064: LIST
63065: LIST
63066: LIST
63067: PUSH
63068: LD_VAR 0 12
63072: ARRAY
63073: ST_TO_ADDR
// break ;
63074: GO 63078
// end ; end ; end ;
63076: GO 62907
63078: POP
63079: POP
// end ; if not weapon then
63080: LD_VAR 0 18
63084: NOT
63085: IFFALSE 63145
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63087: LD_ADDR_VAR 0 5
63091: PUSH
63092: LD_VAR 0 5
63096: PUSH
63097: LD_INT 11
63099: PUSH
63100: LD_INT 30
63102: PUSH
63103: LD_INT 49
63105: PUSH
63106: EMPTY
63107: LIST
63108: LIST
63109: LIST
63110: DIFF
63111: ST_TO_ADDR
// if not list then
63112: LD_VAR 0 5
63116: NOT
63117: IFFALSE 63121
// exit ;
63119: GO 63263
// weapon := list [ rand ( 1 , list ) ] ;
63121: LD_ADDR_VAR 0 18
63125: PUSH
63126: LD_VAR 0 5
63130: PUSH
63131: LD_INT 1
63133: PPUSH
63134: LD_VAR 0 5
63138: PPUSH
63139: CALL_OW 12
63143: ARRAY
63144: ST_TO_ADDR
// end ; if weapon then
63145: LD_VAR 0 18
63149: IFFALSE 63263
// begin tmp := CostOfWeapon ( weapon ) ;
63151: LD_ADDR_VAR 0 14
63155: PUSH
63156: LD_VAR 0 18
63160: PPUSH
63161: CALL_OW 451
63165: ST_TO_ADDR
// j := GetBase ( tower ) ;
63166: LD_ADDR_VAR 0 9
63170: PUSH
63171: LD_VAR 0 1
63175: PPUSH
63176: CALL_OW 274
63180: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63181: LD_VAR 0 9
63185: PPUSH
63186: LD_INT 1
63188: PPUSH
63189: CALL_OW 275
63193: PUSH
63194: LD_VAR 0 14
63198: PUSH
63199: LD_INT 1
63201: ARRAY
63202: GREATEREQUAL
63203: PUSH
63204: LD_VAR 0 9
63208: PPUSH
63209: LD_INT 2
63211: PPUSH
63212: CALL_OW 275
63216: PUSH
63217: LD_VAR 0 14
63221: PUSH
63222: LD_INT 2
63224: ARRAY
63225: GREATEREQUAL
63226: AND
63227: PUSH
63228: LD_VAR 0 9
63232: PPUSH
63233: LD_INT 3
63235: PPUSH
63236: CALL_OW 275
63240: PUSH
63241: LD_VAR 0 14
63245: PUSH
63246: LD_INT 3
63248: ARRAY
63249: GREATEREQUAL
63250: AND
63251: IFFALSE 63263
// result := weapon ;
63253: LD_ADDR_VAR 0 3
63257: PUSH
63258: LD_VAR 0 18
63262: ST_TO_ADDR
// end ; end ;
63263: LD_VAR 0 3
63267: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63268: LD_INT 0
63270: PPUSH
63271: PPUSH
// result := true ;
63272: LD_ADDR_VAR 0 3
63276: PUSH
63277: LD_INT 1
63279: ST_TO_ADDR
// if array1 = array2 then
63280: LD_VAR 0 1
63284: PUSH
63285: LD_VAR 0 2
63289: EQUAL
63290: IFFALSE 63350
// begin for i = 1 to array1 do
63292: LD_ADDR_VAR 0 4
63296: PUSH
63297: DOUBLE
63298: LD_INT 1
63300: DEC
63301: ST_TO_ADDR
63302: LD_VAR 0 1
63306: PUSH
63307: FOR_TO
63308: IFFALSE 63346
// if array1 [ i ] <> array2 [ i ] then
63310: LD_VAR 0 1
63314: PUSH
63315: LD_VAR 0 4
63319: ARRAY
63320: PUSH
63321: LD_VAR 0 2
63325: PUSH
63326: LD_VAR 0 4
63330: ARRAY
63331: NONEQUAL
63332: IFFALSE 63344
// begin result := false ;
63334: LD_ADDR_VAR 0 3
63338: PUSH
63339: LD_INT 0
63341: ST_TO_ADDR
// break ;
63342: GO 63346
// end ;
63344: GO 63307
63346: POP
63347: POP
// end else
63348: GO 63358
// result := false ;
63350: LD_ADDR_VAR 0 3
63354: PUSH
63355: LD_INT 0
63357: ST_TO_ADDR
// end ;
63358: LD_VAR 0 3
63362: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
63363: LD_INT 0
63365: PPUSH
63366: PPUSH
// if not array1 or not array2 then
63367: LD_VAR 0 1
63371: NOT
63372: PUSH
63373: LD_VAR 0 2
63377: NOT
63378: OR
63379: IFFALSE 63383
// exit ;
63381: GO 63447
// result := true ;
63383: LD_ADDR_VAR 0 3
63387: PUSH
63388: LD_INT 1
63390: ST_TO_ADDR
// for i = 1 to array1 do
63391: LD_ADDR_VAR 0 4
63395: PUSH
63396: DOUBLE
63397: LD_INT 1
63399: DEC
63400: ST_TO_ADDR
63401: LD_VAR 0 1
63405: PUSH
63406: FOR_TO
63407: IFFALSE 63445
// if array1 [ i ] <> array2 [ i ] then
63409: LD_VAR 0 1
63413: PUSH
63414: LD_VAR 0 4
63418: ARRAY
63419: PUSH
63420: LD_VAR 0 2
63424: PUSH
63425: LD_VAR 0 4
63429: ARRAY
63430: NONEQUAL
63431: IFFALSE 63443
// begin result := false ;
63433: LD_ADDR_VAR 0 3
63437: PUSH
63438: LD_INT 0
63440: ST_TO_ADDR
// break ;
63441: GO 63445
// end ;
63443: GO 63406
63445: POP
63446: POP
// end ;
63447: LD_VAR 0 3
63451: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63452: LD_INT 0
63454: PPUSH
63455: PPUSH
63456: PPUSH
// pom := GetBase ( fac ) ;
63457: LD_ADDR_VAR 0 5
63461: PUSH
63462: LD_VAR 0 1
63466: PPUSH
63467: CALL_OW 274
63471: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63472: LD_ADDR_VAR 0 4
63476: PUSH
63477: LD_VAR 0 2
63481: PUSH
63482: LD_INT 1
63484: ARRAY
63485: PPUSH
63486: LD_VAR 0 2
63490: PUSH
63491: LD_INT 2
63493: ARRAY
63494: PPUSH
63495: LD_VAR 0 2
63499: PUSH
63500: LD_INT 3
63502: ARRAY
63503: PPUSH
63504: LD_VAR 0 2
63508: PUSH
63509: LD_INT 4
63511: ARRAY
63512: PPUSH
63513: CALL_OW 449
63517: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63518: LD_ADDR_VAR 0 3
63522: PUSH
63523: LD_VAR 0 5
63527: PPUSH
63528: LD_INT 1
63530: PPUSH
63531: CALL_OW 275
63535: PUSH
63536: LD_VAR 0 4
63540: PUSH
63541: LD_INT 1
63543: ARRAY
63544: GREATEREQUAL
63545: PUSH
63546: LD_VAR 0 5
63550: PPUSH
63551: LD_INT 2
63553: PPUSH
63554: CALL_OW 275
63558: PUSH
63559: LD_VAR 0 4
63563: PUSH
63564: LD_INT 2
63566: ARRAY
63567: GREATEREQUAL
63568: AND
63569: PUSH
63570: LD_VAR 0 5
63574: PPUSH
63575: LD_INT 3
63577: PPUSH
63578: CALL_OW 275
63582: PUSH
63583: LD_VAR 0 4
63587: PUSH
63588: LD_INT 3
63590: ARRAY
63591: GREATEREQUAL
63592: AND
63593: ST_TO_ADDR
// end ;
63594: LD_VAR 0 3
63598: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63599: LD_INT 0
63601: PPUSH
63602: PPUSH
63603: PPUSH
63604: PPUSH
// pom := GetBase ( building ) ;
63605: LD_ADDR_VAR 0 3
63609: PUSH
63610: LD_VAR 0 1
63614: PPUSH
63615: CALL_OW 274
63619: ST_TO_ADDR
// if not pom then
63620: LD_VAR 0 3
63624: NOT
63625: IFFALSE 63629
// exit ;
63627: GO 63799
// btype := GetBType ( building ) ;
63629: LD_ADDR_VAR 0 5
63633: PUSH
63634: LD_VAR 0 1
63638: PPUSH
63639: CALL_OW 266
63643: ST_TO_ADDR
// if btype = b_armoury then
63644: LD_VAR 0 5
63648: PUSH
63649: LD_INT 4
63651: EQUAL
63652: IFFALSE 63662
// btype := b_barracks ;
63654: LD_ADDR_VAR 0 5
63658: PUSH
63659: LD_INT 5
63661: ST_TO_ADDR
// if btype = b_depot then
63662: LD_VAR 0 5
63666: PUSH
63667: LD_INT 0
63669: EQUAL
63670: IFFALSE 63680
// btype := b_warehouse ;
63672: LD_ADDR_VAR 0 5
63676: PUSH
63677: LD_INT 1
63679: ST_TO_ADDR
// if btype = b_workshop then
63680: LD_VAR 0 5
63684: PUSH
63685: LD_INT 2
63687: EQUAL
63688: IFFALSE 63698
// btype := b_factory ;
63690: LD_ADDR_VAR 0 5
63694: PUSH
63695: LD_INT 3
63697: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63698: LD_ADDR_VAR 0 4
63702: PUSH
63703: LD_VAR 0 5
63707: PPUSH
63708: LD_VAR 0 1
63712: PPUSH
63713: CALL_OW 248
63717: PPUSH
63718: CALL_OW 450
63722: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63723: LD_ADDR_VAR 0 2
63727: PUSH
63728: LD_VAR 0 3
63732: PPUSH
63733: LD_INT 1
63735: PPUSH
63736: CALL_OW 275
63740: PUSH
63741: LD_VAR 0 4
63745: PUSH
63746: LD_INT 1
63748: ARRAY
63749: GREATEREQUAL
63750: PUSH
63751: LD_VAR 0 3
63755: PPUSH
63756: LD_INT 2
63758: PPUSH
63759: CALL_OW 275
63763: PUSH
63764: LD_VAR 0 4
63768: PUSH
63769: LD_INT 2
63771: ARRAY
63772: GREATEREQUAL
63773: AND
63774: PUSH
63775: LD_VAR 0 3
63779: PPUSH
63780: LD_INT 3
63782: PPUSH
63783: CALL_OW 275
63787: PUSH
63788: LD_VAR 0 4
63792: PUSH
63793: LD_INT 3
63795: ARRAY
63796: GREATEREQUAL
63797: AND
63798: ST_TO_ADDR
// end ;
63799: LD_VAR 0 2
63803: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63804: LD_INT 0
63806: PPUSH
63807: PPUSH
63808: PPUSH
// pom := GetBase ( building ) ;
63809: LD_ADDR_VAR 0 4
63813: PUSH
63814: LD_VAR 0 1
63818: PPUSH
63819: CALL_OW 274
63823: ST_TO_ADDR
// if not pom then
63824: LD_VAR 0 4
63828: NOT
63829: IFFALSE 63833
// exit ;
63831: GO 63934
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63833: LD_ADDR_VAR 0 5
63837: PUSH
63838: LD_VAR 0 2
63842: PPUSH
63843: LD_VAR 0 1
63847: PPUSH
63848: CALL_OW 248
63852: PPUSH
63853: CALL_OW 450
63857: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63858: LD_ADDR_VAR 0 3
63862: PUSH
63863: LD_VAR 0 4
63867: PPUSH
63868: LD_INT 1
63870: PPUSH
63871: CALL_OW 275
63875: PUSH
63876: LD_VAR 0 5
63880: PUSH
63881: LD_INT 1
63883: ARRAY
63884: GREATEREQUAL
63885: PUSH
63886: LD_VAR 0 4
63890: PPUSH
63891: LD_INT 2
63893: PPUSH
63894: CALL_OW 275
63898: PUSH
63899: LD_VAR 0 5
63903: PUSH
63904: LD_INT 2
63906: ARRAY
63907: GREATEREQUAL
63908: AND
63909: PUSH
63910: LD_VAR 0 4
63914: PPUSH
63915: LD_INT 3
63917: PPUSH
63918: CALL_OW 275
63922: PUSH
63923: LD_VAR 0 5
63927: PUSH
63928: LD_INT 3
63930: ARRAY
63931: GREATEREQUAL
63932: AND
63933: ST_TO_ADDR
// end ;
63934: LD_VAR 0 3
63938: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63939: LD_INT 0
63941: PPUSH
63942: PPUSH
63943: PPUSH
63944: PPUSH
63945: PPUSH
63946: PPUSH
63947: PPUSH
63948: PPUSH
63949: PPUSH
63950: PPUSH
63951: PPUSH
// result := false ;
63952: LD_ADDR_VAR 0 8
63956: PUSH
63957: LD_INT 0
63959: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63960: LD_VAR 0 5
63964: NOT
63965: PUSH
63966: LD_VAR 0 1
63970: NOT
63971: OR
63972: PUSH
63973: LD_VAR 0 2
63977: NOT
63978: OR
63979: PUSH
63980: LD_VAR 0 3
63984: NOT
63985: OR
63986: IFFALSE 63990
// exit ;
63988: GO 64804
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63990: LD_ADDR_VAR 0 14
63994: PUSH
63995: LD_VAR 0 1
63999: PPUSH
64000: LD_VAR 0 2
64004: PPUSH
64005: LD_VAR 0 3
64009: PPUSH
64010: LD_VAR 0 4
64014: PPUSH
64015: LD_VAR 0 5
64019: PUSH
64020: LD_INT 1
64022: ARRAY
64023: PPUSH
64024: CALL_OW 248
64028: PPUSH
64029: LD_INT 0
64031: PPUSH
64032: CALL 66037 0 6
64036: ST_TO_ADDR
// if not hexes then
64037: LD_VAR 0 14
64041: NOT
64042: IFFALSE 64046
// exit ;
64044: GO 64804
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64046: LD_ADDR_VAR 0 17
64050: PUSH
64051: LD_VAR 0 5
64055: PPUSH
64056: LD_INT 22
64058: PUSH
64059: LD_VAR 0 13
64063: PPUSH
64064: CALL_OW 255
64068: PUSH
64069: EMPTY
64070: LIST
64071: LIST
64072: PUSH
64073: LD_INT 2
64075: PUSH
64076: LD_INT 30
64078: PUSH
64079: LD_INT 0
64081: PUSH
64082: EMPTY
64083: LIST
64084: LIST
64085: PUSH
64086: LD_INT 30
64088: PUSH
64089: LD_INT 1
64091: PUSH
64092: EMPTY
64093: LIST
64094: LIST
64095: PUSH
64096: EMPTY
64097: LIST
64098: LIST
64099: LIST
64100: PUSH
64101: EMPTY
64102: LIST
64103: LIST
64104: PPUSH
64105: CALL_OW 72
64109: ST_TO_ADDR
// for i = 1 to hexes do
64110: LD_ADDR_VAR 0 9
64114: PUSH
64115: DOUBLE
64116: LD_INT 1
64118: DEC
64119: ST_TO_ADDR
64120: LD_VAR 0 14
64124: PUSH
64125: FOR_TO
64126: IFFALSE 64802
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64128: LD_ADDR_VAR 0 13
64132: PUSH
64133: LD_VAR 0 14
64137: PUSH
64138: LD_VAR 0 9
64142: ARRAY
64143: PUSH
64144: LD_INT 1
64146: ARRAY
64147: PPUSH
64148: LD_VAR 0 14
64152: PUSH
64153: LD_VAR 0 9
64157: ARRAY
64158: PUSH
64159: LD_INT 2
64161: ARRAY
64162: PPUSH
64163: CALL_OW 428
64167: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64168: LD_VAR 0 14
64172: PUSH
64173: LD_VAR 0 9
64177: ARRAY
64178: PUSH
64179: LD_INT 1
64181: ARRAY
64182: PPUSH
64183: LD_VAR 0 14
64187: PUSH
64188: LD_VAR 0 9
64192: ARRAY
64193: PUSH
64194: LD_INT 2
64196: ARRAY
64197: PPUSH
64198: CALL_OW 351
64202: PUSH
64203: LD_VAR 0 14
64207: PUSH
64208: LD_VAR 0 9
64212: ARRAY
64213: PUSH
64214: LD_INT 1
64216: ARRAY
64217: PPUSH
64218: LD_VAR 0 14
64222: PUSH
64223: LD_VAR 0 9
64227: ARRAY
64228: PUSH
64229: LD_INT 2
64231: ARRAY
64232: PPUSH
64233: CALL_OW 488
64237: NOT
64238: OR
64239: PUSH
64240: LD_VAR 0 13
64244: PPUSH
64245: CALL_OW 247
64249: PUSH
64250: LD_INT 3
64252: EQUAL
64253: OR
64254: IFFALSE 64260
// exit ;
64256: POP
64257: POP
64258: GO 64804
// if not tmp then
64260: LD_VAR 0 13
64264: NOT
64265: IFFALSE 64269
// continue ;
64267: GO 64125
// result := true ;
64269: LD_ADDR_VAR 0 8
64273: PUSH
64274: LD_INT 1
64276: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64277: LD_VAR 0 6
64281: PUSH
64282: LD_VAR 0 13
64286: PPUSH
64287: CALL_OW 247
64291: PUSH
64292: LD_INT 2
64294: EQUAL
64295: AND
64296: PUSH
64297: LD_VAR 0 13
64301: PPUSH
64302: CALL_OW 263
64306: PUSH
64307: LD_INT 1
64309: EQUAL
64310: AND
64311: IFFALSE 64475
// begin if IsDrivenBy ( tmp ) then
64313: LD_VAR 0 13
64317: PPUSH
64318: CALL_OW 311
64322: IFFALSE 64326
// continue ;
64324: GO 64125
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
64326: LD_VAR 0 6
64330: PPUSH
64331: LD_INT 3
64333: PUSH
64334: LD_INT 60
64336: PUSH
64337: EMPTY
64338: LIST
64339: PUSH
64340: EMPTY
64341: LIST
64342: LIST
64343: PUSH
64344: LD_INT 3
64346: PUSH
64347: LD_INT 55
64349: PUSH
64350: EMPTY
64351: LIST
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: PUSH
64357: EMPTY
64358: LIST
64359: LIST
64360: PPUSH
64361: CALL_OW 72
64365: IFFALSE 64473
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
64367: LD_ADDR_VAR 0 18
64371: PUSH
64372: LD_VAR 0 6
64376: PPUSH
64377: LD_INT 3
64379: PUSH
64380: LD_INT 60
64382: PUSH
64383: EMPTY
64384: LIST
64385: PUSH
64386: EMPTY
64387: LIST
64388: LIST
64389: PUSH
64390: LD_INT 3
64392: PUSH
64393: LD_INT 55
64395: PUSH
64396: EMPTY
64397: LIST
64398: PUSH
64399: EMPTY
64400: LIST
64401: LIST
64402: PUSH
64403: EMPTY
64404: LIST
64405: LIST
64406: PPUSH
64407: CALL_OW 72
64411: PUSH
64412: LD_INT 1
64414: ARRAY
64415: ST_TO_ADDR
// if IsInUnit ( driver ) then
64416: LD_VAR 0 18
64420: PPUSH
64421: CALL_OW 310
64425: IFFALSE 64436
// ComExit ( driver ) ;
64427: LD_VAR 0 18
64431: PPUSH
64432: CALL 89798 0 1
// AddComEnterUnit ( driver , tmp ) ;
64436: LD_VAR 0 18
64440: PPUSH
64441: LD_VAR 0 13
64445: PPUSH
64446: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
64450: LD_VAR 0 18
64454: PPUSH
64455: LD_VAR 0 7
64459: PPUSH
64460: CALL_OW 173
// AddComExitVehicle ( driver ) ;
64464: LD_VAR 0 18
64468: PPUSH
64469: CALL_OW 181
// end ; continue ;
64473: GO 64125
// end ; if not cleaners or not tmp in cleaners then
64475: LD_VAR 0 6
64479: NOT
64480: PUSH
64481: LD_VAR 0 13
64485: PUSH
64486: LD_VAR 0 6
64490: IN
64491: NOT
64492: OR
64493: IFFALSE 64800
// begin if dep then
64495: LD_VAR 0 17
64499: IFFALSE 64635
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64501: LD_ADDR_VAR 0 16
64505: PUSH
64506: LD_VAR 0 17
64510: PUSH
64511: LD_INT 1
64513: ARRAY
64514: PPUSH
64515: CALL_OW 250
64519: PPUSH
64520: LD_VAR 0 17
64524: PUSH
64525: LD_INT 1
64527: ARRAY
64528: PPUSH
64529: CALL_OW 254
64533: PPUSH
64534: LD_INT 5
64536: PPUSH
64537: CALL_OW 272
64541: PUSH
64542: LD_VAR 0 17
64546: PUSH
64547: LD_INT 1
64549: ARRAY
64550: PPUSH
64551: CALL_OW 251
64555: PPUSH
64556: LD_VAR 0 17
64560: PUSH
64561: LD_INT 1
64563: ARRAY
64564: PPUSH
64565: CALL_OW 254
64569: PPUSH
64570: LD_INT 5
64572: PPUSH
64573: CALL_OW 273
64577: PUSH
64578: EMPTY
64579: LIST
64580: LIST
64581: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64582: LD_VAR 0 16
64586: PUSH
64587: LD_INT 1
64589: ARRAY
64590: PPUSH
64591: LD_VAR 0 16
64595: PUSH
64596: LD_INT 2
64598: ARRAY
64599: PPUSH
64600: CALL_OW 488
64604: IFFALSE 64635
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64606: LD_VAR 0 13
64610: PPUSH
64611: LD_VAR 0 16
64615: PUSH
64616: LD_INT 1
64618: ARRAY
64619: PPUSH
64620: LD_VAR 0 16
64624: PUSH
64625: LD_INT 2
64627: ARRAY
64628: PPUSH
64629: CALL_OW 111
// continue ;
64633: GO 64125
// end ; end ; r := GetDir ( tmp ) ;
64635: LD_ADDR_VAR 0 15
64639: PUSH
64640: LD_VAR 0 13
64644: PPUSH
64645: CALL_OW 254
64649: ST_TO_ADDR
// if r = 5 then
64650: LD_VAR 0 15
64654: PUSH
64655: LD_INT 5
64657: EQUAL
64658: IFFALSE 64668
// r := 0 ;
64660: LD_ADDR_VAR 0 15
64664: PUSH
64665: LD_INT 0
64667: ST_TO_ADDR
// for j = r to 5 do
64668: LD_ADDR_VAR 0 10
64672: PUSH
64673: DOUBLE
64674: LD_VAR 0 15
64678: DEC
64679: ST_TO_ADDR
64680: LD_INT 5
64682: PUSH
64683: FOR_TO
64684: IFFALSE 64798
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64686: LD_ADDR_VAR 0 11
64690: PUSH
64691: LD_VAR 0 13
64695: PPUSH
64696: CALL_OW 250
64700: PPUSH
64701: LD_VAR 0 10
64705: PPUSH
64706: LD_INT 2
64708: PPUSH
64709: CALL_OW 272
64713: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64714: LD_ADDR_VAR 0 12
64718: PUSH
64719: LD_VAR 0 13
64723: PPUSH
64724: CALL_OW 251
64728: PPUSH
64729: LD_VAR 0 10
64733: PPUSH
64734: LD_INT 2
64736: PPUSH
64737: CALL_OW 273
64741: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64742: LD_VAR 0 11
64746: PPUSH
64747: LD_VAR 0 12
64751: PPUSH
64752: CALL_OW 488
64756: PUSH
64757: LD_VAR 0 11
64761: PPUSH
64762: LD_VAR 0 12
64766: PPUSH
64767: CALL_OW 428
64771: NOT
64772: AND
64773: IFFALSE 64796
// begin ComMoveXY ( tmp , _x , _y ) ;
64775: LD_VAR 0 13
64779: PPUSH
64780: LD_VAR 0 11
64784: PPUSH
64785: LD_VAR 0 12
64789: PPUSH
64790: CALL_OW 111
// break ;
64794: GO 64798
// end ; end ;
64796: GO 64683
64798: POP
64799: POP
// end ; end ;
64800: GO 64125
64802: POP
64803: POP
// end ;
64804: LD_VAR 0 8
64808: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64809: LD_INT 0
64811: PPUSH
// result := true ;
64812: LD_ADDR_VAR 0 3
64816: PUSH
64817: LD_INT 1
64819: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64820: LD_VAR 0 2
64824: PUSH
64825: LD_INT 24
64827: DOUBLE
64828: EQUAL
64829: IFTRUE 64839
64831: LD_INT 33
64833: DOUBLE
64834: EQUAL
64835: IFTRUE 64839
64837: GO 64864
64839: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64840: LD_ADDR_VAR 0 3
64844: PUSH
64845: LD_INT 32
64847: PPUSH
64848: LD_VAR 0 1
64852: PPUSH
64853: CALL_OW 321
64857: PUSH
64858: LD_INT 2
64860: EQUAL
64861: ST_TO_ADDR
64862: GO 65180
64864: LD_INT 20
64866: DOUBLE
64867: EQUAL
64868: IFTRUE 64872
64870: GO 64897
64872: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64873: LD_ADDR_VAR 0 3
64877: PUSH
64878: LD_INT 6
64880: PPUSH
64881: LD_VAR 0 1
64885: PPUSH
64886: CALL_OW 321
64890: PUSH
64891: LD_INT 2
64893: EQUAL
64894: ST_TO_ADDR
64895: GO 65180
64897: LD_INT 22
64899: DOUBLE
64900: EQUAL
64901: IFTRUE 64911
64903: LD_INT 36
64905: DOUBLE
64906: EQUAL
64907: IFTRUE 64911
64909: GO 64936
64911: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64912: LD_ADDR_VAR 0 3
64916: PUSH
64917: LD_INT 15
64919: PPUSH
64920: LD_VAR 0 1
64924: PPUSH
64925: CALL_OW 321
64929: PUSH
64930: LD_INT 2
64932: EQUAL
64933: ST_TO_ADDR
64934: GO 65180
64936: LD_INT 30
64938: DOUBLE
64939: EQUAL
64940: IFTRUE 64944
64942: GO 64969
64944: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64945: LD_ADDR_VAR 0 3
64949: PUSH
64950: LD_INT 20
64952: PPUSH
64953: LD_VAR 0 1
64957: PPUSH
64958: CALL_OW 321
64962: PUSH
64963: LD_INT 2
64965: EQUAL
64966: ST_TO_ADDR
64967: GO 65180
64969: LD_INT 28
64971: DOUBLE
64972: EQUAL
64973: IFTRUE 64983
64975: LD_INT 21
64977: DOUBLE
64978: EQUAL
64979: IFTRUE 64983
64981: GO 65008
64983: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64984: LD_ADDR_VAR 0 3
64988: PUSH
64989: LD_INT 21
64991: PPUSH
64992: LD_VAR 0 1
64996: PPUSH
64997: CALL_OW 321
65001: PUSH
65002: LD_INT 2
65004: EQUAL
65005: ST_TO_ADDR
65006: GO 65180
65008: LD_INT 16
65010: DOUBLE
65011: EQUAL
65012: IFTRUE 65016
65014: GO 65041
65016: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
65017: LD_ADDR_VAR 0 3
65021: PUSH
65022: LD_INT 84
65024: PPUSH
65025: LD_VAR 0 1
65029: PPUSH
65030: CALL_OW 321
65034: PUSH
65035: LD_INT 2
65037: EQUAL
65038: ST_TO_ADDR
65039: GO 65180
65041: LD_INT 19
65043: DOUBLE
65044: EQUAL
65045: IFTRUE 65055
65047: LD_INT 23
65049: DOUBLE
65050: EQUAL
65051: IFTRUE 65055
65053: GO 65080
65055: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
65056: LD_ADDR_VAR 0 3
65060: PUSH
65061: LD_INT 83
65063: PPUSH
65064: LD_VAR 0 1
65068: PPUSH
65069: CALL_OW 321
65073: PUSH
65074: LD_INT 2
65076: EQUAL
65077: ST_TO_ADDR
65078: GO 65180
65080: LD_INT 17
65082: DOUBLE
65083: EQUAL
65084: IFTRUE 65088
65086: GO 65113
65088: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65089: LD_ADDR_VAR 0 3
65093: PUSH
65094: LD_INT 39
65096: PPUSH
65097: LD_VAR 0 1
65101: PPUSH
65102: CALL_OW 321
65106: PUSH
65107: LD_INT 2
65109: EQUAL
65110: ST_TO_ADDR
65111: GO 65180
65113: LD_INT 18
65115: DOUBLE
65116: EQUAL
65117: IFTRUE 65121
65119: GO 65146
65121: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65122: LD_ADDR_VAR 0 3
65126: PUSH
65127: LD_INT 40
65129: PPUSH
65130: LD_VAR 0 1
65134: PPUSH
65135: CALL_OW 321
65139: PUSH
65140: LD_INT 2
65142: EQUAL
65143: ST_TO_ADDR
65144: GO 65180
65146: LD_INT 27
65148: DOUBLE
65149: EQUAL
65150: IFTRUE 65154
65152: GO 65179
65154: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65155: LD_ADDR_VAR 0 3
65159: PUSH
65160: LD_INT 35
65162: PPUSH
65163: LD_VAR 0 1
65167: PPUSH
65168: CALL_OW 321
65172: PUSH
65173: LD_INT 2
65175: EQUAL
65176: ST_TO_ADDR
65177: GO 65180
65179: POP
// end ;
65180: LD_VAR 0 3
65184: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65185: LD_INT 0
65187: PPUSH
65188: PPUSH
65189: PPUSH
65190: PPUSH
65191: PPUSH
65192: PPUSH
65193: PPUSH
65194: PPUSH
65195: PPUSH
65196: PPUSH
65197: PPUSH
// result := false ;
65198: LD_ADDR_VAR 0 6
65202: PUSH
65203: LD_INT 0
65205: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65206: LD_VAR 0 1
65210: NOT
65211: PUSH
65212: LD_VAR 0 1
65216: PPUSH
65217: CALL_OW 266
65221: PUSH
65222: LD_INT 0
65224: PUSH
65225: LD_INT 1
65227: PUSH
65228: EMPTY
65229: LIST
65230: LIST
65231: IN
65232: NOT
65233: OR
65234: PUSH
65235: LD_VAR 0 2
65239: NOT
65240: OR
65241: PUSH
65242: LD_VAR 0 5
65246: PUSH
65247: LD_INT 0
65249: PUSH
65250: LD_INT 1
65252: PUSH
65253: LD_INT 2
65255: PUSH
65256: LD_INT 3
65258: PUSH
65259: LD_INT 4
65261: PUSH
65262: LD_INT 5
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: LIST
65269: LIST
65270: LIST
65271: LIST
65272: IN
65273: NOT
65274: OR
65275: PUSH
65276: LD_VAR 0 3
65280: PPUSH
65281: LD_VAR 0 4
65285: PPUSH
65286: CALL_OW 488
65290: NOT
65291: OR
65292: IFFALSE 65296
// exit ;
65294: GO 66032
// side := GetSide ( depot ) ;
65296: LD_ADDR_VAR 0 9
65300: PUSH
65301: LD_VAR 0 1
65305: PPUSH
65306: CALL_OW 255
65310: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65311: LD_VAR 0 9
65315: PPUSH
65316: LD_VAR 0 2
65320: PPUSH
65321: CALL 64809 0 2
65325: NOT
65326: IFFALSE 65330
// exit ;
65328: GO 66032
// pom := GetBase ( depot ) ;
65330: LD_ADDR_VAR 0 10
65334: PUSH
65335: LD_VAR 0 1
65339: PPUSH
65340: CALL_OW 274
65344: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65345: LD_ADDR_VAR 0 11
65349: PUSH
65350: LD_VAR 0 2
65354: PPUSH
65355: LD_VAR 0 1
65359: PPUSH
65360: CALL_OW 248
65364: PPUSH
65365: CALL_OW 450
65369: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65370: LD_VAR 0 10
65374: PPUSH
65375: LD_INT 1
65377: PPUSH
65378: CALL_OW 275
65382: PUSH
65383: LD_VAR 0 11
65387: PUSH
65388: LD_INT 1
65390: ARRAY
65391: GREATEREQUAL
65392: PUSH
65393: LD_VAR 0 10
65397: PPUSH
65398: LD_INT 2
65400: PPUSH
65401: CALL_OW 275
65405: PUSH
65406: LD_VAR 0 11
65410: PUSH
65411: LD_INT 2
65413: ARRAY
65414: GREATEREQUAL
65415: AND
65416: PUSH
65417: LD_VAR 0 10
65421: PPUSH
65422: LD_INT 3
65424: PPUSH
65425: CALL_OW 275
65429: PUSH
65430: LD_VAR 0 11
65434: PUSH
65435: LD_INT 3
65437: ARRAY
65438: GREATEREQUAL
65439: AND
65440: NOT
65441: IFFALSE 65445
// exit ;
65443: GO 66032
// if GetBType ( depot ) = b_depot then
65445: LD_VAR 0 1
65449: PPUSH
65450: CALL_OW 266
65454: PUSH
65455: LD_INT 0
65457: EQUAL
65458: IFFALSE 65470
// dist := 28 else
65460: LD_ADDR_VAR 0 14
65464: PUSH
65465: LD_INT 28
65467: ST_TO_ADDR
65468: GO 65478
// dist := 36 ;
65470: LD_ADDR_VAR 0 14
65474: PUSH
65475: LD_INT 36
65477: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65478: LD_VAR 0 1
65482: PPUSH
65483: LD_VAR 0 3
65487: PPUSH
65488: LD_VAR 0 4
65492: PPUSH
65493: CALL_OW 297
65497: PUSH
65498: LD_VAR 0 14
65502: GREATER
65503: IFFALSE 65507
// exit ;
65505: GO 66032
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65507: LD_ADDR_VAR 0 12
65511: PUSH
65512: LD_VAR 0 2
65516: PPUSH
65517: LD_VAR 0 3
65521: PPUSH
65522: LD_VAR 0 4
65526: PPUSH
65527: LD_VAR 0 5
65531: PPUSH
65532: LD_VAR 0 1
65536: PPUSH
65537: CALL_OW 248
65541: PPUSH
65542: LD_INT 0
65544: PPUSH
65545: CALL 66037 0 6
65549: ST_TO_ADDR
// if not hexes then
65550: LD_VAR 0 12
65554: NOT
65555: IFFALSE 65559
// exit ;
65557: GO 66032
// hex := GetHexInfo ( x , y ) ;
65559: LD_ADDR_VAR 0 15
65563: PUSH
65564: LD_VAR 0 3
65568: PPUSH
65569: LD_VAR 0 4
65573: PPUSH
65574: CALL_OW 546
65578: ST_TO_ADDR
// if hex [ 1 ] then
65579: LD_VAR 0 15
65583: PUSH
65584: LD_INT 1
65586: ARRAY
65587: IFFALSE 65591
// exit ;
65589: GO 66032
// height := hex [ 2 ] ;
65591: LD_ADDR_VAR 0 13
65595: PUSH
65596: LD_VAR 0 15
65600: PUSH
65601: LD_INT 2
65603: ARRAY
65604: ST_TO_ADDR
// for i = 1 to hexes do
65605: LD_ADDR_VAR 0 7
65609: PUSH
65610: DOUBLE
65611: LD_INT 1
65613: DEC
65614: ST_TO_ADDR
65615: LD_VAR 0 12
65619: PUSH
65620: FOR_TO
65621: IFFALSE 65951
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65623: LD_VAR 0 12
65627: PUSH
65628: LD_VAR 0 7
65632: ARRAY
65633: PUSH
65634: LD_INT 1
65636: ARRAY
65637: PPUSH
65638: LD_VAR 0 12
65642: PUSH
65643: LD_VAR 0 7
65647: ARRAY
65648: PUSH
65649: LD_INT 2
65651: ARRAY
65652: PPUSH
65653: CALL_OW 488
65657: NOT
65658: PUSH
65659: LD_VAR 0 12
65663: PUSH
65664: LD_VAR 0 7
65668: ARRAY
65669: PUSH
65670: LD_INT 1
65672: ARRAY
65673: PPUSH
65674: LD_VAR 0 12
65678: PUSH
65679: LD_VAR 0 7
65683: ARRAY
65684: PUSH
65685: LD_INT 2
65687: ARRAY
65688: PPUSH
65689: CALL_OW 428
65693: PUSH
65694: LD_INT 0
65696: GREATER
65697: OR
65698: PUSH
65699: LD_VAR 0 12
65703: PUSH
65704: LD_VAR 0 7
65708: ARRAY
65709: PUSH
65710: LD_INT 1
65712: ARRAY
65713: PPUSH
65714: LD_VAR 0 12
65718: PUSH
65719: LD_VAR 0 7
65723: ARRAY
65724: PUSH
65725: LD_INT 2
65727: ARRAY
65728: PPUSH
65729: CALL_OW 351
65733: OR
65734: IFFALSE 65740
// exit ;
65736: POP
65737: POP
65738: GO 66032
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65740: LD_ADDR_VAR 0 8
65744: PUSH
65745: LD_VAR 0 12
65749: PUSH
65750: LD_VAR 0 7
65754: ARRAY
65755: PUSH
65756: LD_INT 1
65758: ARRAY
65759: PPUSH
65760: LD_VAR 0 12
65764: PUSH
65765: LD_VAR 0 7
65769: ARRAY
65770: PUSH
65771: LD_INT 2
65773: ARRAY
65774: PPUSH
65775: CALL_OW 546
65779: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65780: LD_VAR 0 8
65784: PUSH
65785: LD_INT 1
65787: ARRAY
65788: PUSH
65789: LD_VAR 0 8
65793: PUSH
65794: LD_INT 2
65796: ARRAY
65797: PUSH
65798: LD_VAR 0 13
65802: PUSH
65803: LD_INT 2
65805: PLUS
65806: GREATER
65807: OR
65808: PUSH
65809: LD_VAR 0 8
65813: PUSH
65814: LD_INT 2
65816: ARRAY
65817: PUSH
65818: LD_VAR 0 13
65822: PUSH
65823: LD_INT 2
65825: MINUS
65826: LESS
65827: OR
65828: PUSH
65829: LD_VAR 0 8
65833: PUSH
65834: LD_INT 3
65836: ARRAY
65837: PUSH
65838: LD_INT 0
65840: PUSH
65841: LD_INT 8
65843: PUSH
65844: LD_INT 9
65846: PUSH
65847: LD_INT 10
65849: PUSH
65850: LD_INT 11
65852: PUSH
65853: LD_INT 12
65855: PUSH
65856: LD_INT 13
65858: PUSH
65859: LD_INT 16
65861: PUSH
65862: LD_INT 17
65864: PUSH
65865: LD_INT 18
65867: PUSH
65868: LD_INT 19
65870: PUSH
65871: LD_INT 20
65873: PUSH
65874: LD_INT 21
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: LIST
65881: LIST
65882: LIST
65883: LIST
65884: LIST
65885: LIST
65886: LIST
65887: LIST
65888: LIST
65889: LIST
65890: LIST
65891: IN
65892: NOT
65893: OR
65894: PUSH
65895: LD_VAR 0 8
65899: PUSH
65900: LD_INT 5
65902: ARRAY
65903: NOT
65904: OR
65905: PUSH
65906: LD_VAR 0 8
65910: PUSH
65911: LD_INT 6
65913: ARRAY
65914: PUSH
65915: LD_INT 1
65917: PUSH
65918: LD_INT 2
65920: PUSH
65921: LD_INT 7
65923: PUSH
65924: LD_INT 9
65926: PUSH
65927: LD_INT 10
65929: PUSH
65930: LD_INT 11
65932: PUSH
65933: EMPTY
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: LIST
65940: IN
65941: NOT
65942: OR
65943: IFFALSE 65949
// exit ;
65945: POP
65946: POP
65947: GO 66032
// end ;
65949: GO 65620
65951: POP
65952: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65953: LD_VAR 0 9
65957: PPUSH
65958: LD_VAR 0 3
65962: PPUSH
65963: LD_VAR 0 4
65967: PPUSH
65968: LD_INT 20
65970: PPUSH
65971: CALL 57984 0 4
65975: PUSH
65976: LD_INT 4
65978: ARRAY
65979: IFFALSE 65983
// exit ;
65981: GO 66032
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65983: LD_VAR 0 2
65987: PUSH
65988: LD_INT 29
65990: PUSH
65991: LD_INT 30
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: IN
65998: PUSH
65999: LD_VAR 0 3
66003: PPUSH
66004: LD_VAR 0 4
66008: PPUSH
66009: LD_VAR 0 9
66013: PPUSH
66014: CALL_OW 440
66018: NOT
66019: AND
66020: IFFALSE 66024
// exit ;
66022: GO 66032
// result := true ;
66024: LD_ADDR_VAR 0 6
66028: PUSH
66029: LD_INT 1
66031: ST_TO_ADDR
// end ;
66032: LD_VAR 0 6
66036: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
66037: LD_INT 0
66039: PPUSH
66040: PPUSH
66041: PPUSH
66042: PPUSH
66043: PPUSH
66044: PPUSH
66045: PPUSH
66046: PPUSH
66047: PPUSH
66048: PPUSH
66049: PPUSH
66050: PPUSH
66051: PPUSH
66052: PPUSH
66053: PPUSH
66054: PPUSH
66055: PPUSH
66056: PPUSH
66057: PPUSH
66058: PPUSH
66059: PPUSH
66060: PPUSH
66061: PPUSH
66062: PPUSH
66063: PPUSH
66064: PPUSH
66065: PPUSH
66066: PPUSH
66067: PPUSH
66068: PPUSH
66069: PPUSH
66070: PPUSH
66071: PPUSH
66072: PPUSH
66073: PPUSH
66074: PPUSH
66075: PPUSH
66076: PPUSH
66077: PPUSH
66078: PPUSH
66079: PPUSH
66080: PPUSH
66081: PPUSH
66082: PPUSH
66083: PPUSH
66084: PPUSH
66085: PPUSH
66086: PPUSH
66087: PPUSH
66088: PPUSH
66089: PPUSH
66090: PPUSH
66091: PPUSH
66092: PPUSH
66093: PPUSH
66094: PPUSH
66095: PPUSH
66096: PPUSH
// result = [ ] ;
66097: LD_ADDR_VAR 0 7
66101: PUSH
66102: EMPTY
66103: ST_TO_ADDR
// temp_list = [ ] ;
66104: LD_ADDR_VAR 0 9
66108: PUSH
66109: EMPTY
66110: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66111: LD_VAR 0 4
66115: PUSH
66116: LD_INT 0
66118: PUSH
66119: LD_INT 1
66121: PUSH
66122: LD_INT 2
66124: PUSH
66125: LD_INT 3
66127: PUSH
66128: LD_INT 4
66130: PUSH
66131: LD_INT 5
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: IN
66142: NOT
66143: PUSH
66144: LD_VAR 0 1
66148: PUSH
66149: LD_INT 0
66151: PUSH
66152: LD_INT 1
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: IN
66159: PUSH
66160: LD_VAR 0 5
66164: PUSH
66165: LD_INT 1
66167: PUSH
66168: LD_INT 2
66170: PUSH
66171: LD_INT 3
66173: PUSH
66174: EMPTY
66175: LIST
66176: LIST
66177: LIST
66178: IN
66179: NOT
66180: AND
66181: OR
66182: IFFALSE 66186
// exit ;
66184: GO 84577
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66186: LD_VAR 0 1
66190: PUSH
66191: LD_INT 6
66193: PUSH
66194: LD_INT 7
66196: PUSH
66197: LD_INT 8
66199: PUSH
66200: LD_INT 13
66202: PUSH
66203: LD_INT 12
66205: PUSH
66206: LD_INT 15
66208: PUSH
66209: LD_INT 11
66211: PUSH
66212: LD_INT 14
66214: PUSH
66215: LD_INT 10
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: LIST
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: IN
66229: IFFALSE 66239
// btype = b_lab ;
66231: LD_ADDR_VAR 0 1
66235: PUSH
66236: LD_INT 6
66238: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66239: LD_VAR 0 6
66243: PUSH
66244: LD_INT 0
66246: PUSH
66247: LD_INT 1
66249: PUSH
66250: LD_INT 2
66252: PUSH
66253: EMPTY
66254: LIST
66255: LIST
66256: LIST
66257: IN
66258: NOT
66259: PUSH
66260: LD_VAR 0 1
66264: PUSH
66265: LD_INT 0
66267: PUSH
66268: LD_INT 1
66270: PUSH
66271: LD_INT 2
66273: PUSH
66274: LD_INT 3
66276: PUSH
66277: LD_INT 6
66279: PUSH
66280: LD_INT 36
66282: PUSH
66283: LD_INT 4
66285: PUSH
66286: LD_INT 5
66288: PUSH
66289: LD_INT 31
66291: PUSH
66292: LD_INT 32
66294: PUSH
66295: LD_INT 33
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: LIST
66302: LIST
66303: LIST
66304: LIST
66305: LIST
66306: LIST
66307: LIST
66308: LIST
66309: LIST
66310: IN
66311: NOT
66312: PUSH
66313: LD_VAR 0 6
66317: PUSH
66318: LD_INT 1
66320: EQUAL
66321: AND
66322: OR
66323: PUSH
66324: LD_VAR 0 1
66328: PUSH
66329: LD_INT 2
66331: PUSH
66332: LD_INT 3
66334: PUSH
66335: EMPTY
66336: LIST
66337: LIST
66338: IN
66339: NOT
66340: PUSH
66341: LD_VAR 0 6
66345: PUSH
66346: LD_INT 2
66348: EQUAL
66349: AND
66350: OR
66351: IFFALSE 66361
// mode = 0 ;
66353: LD_ADDR_VAR 0 6
66357: PUSH
66358: LD_INT 0
66360: ST_TO_ADDR
// case mode of 0 :
66361: LD_VAR 0 6
66365: PUSH
66366: LD_INT 0
66368: DOUBLE
66369: EQUAL
66370: IFTRUE 66374
66372: GO 77827
66374: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66375: LD_ADDR_VAR 0 11
66379: PUSH
66380: LD_INT 0
66382: PUSH
66383: LD_INT 0
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: PUSH
66390: LD_INT 0
66392: PUSH
66393: LD_INT 1
66395: NEG
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 1
66403: PUSH
66404: LD_INT 0
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 1
66413: PUSH
66414: LD_INT 1
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PUSH
66421: LD_INT 0
66423: PUSH
66424: LD_INT 1
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: LD_INT 1
66433: NEG
66434: PUSH
66435: LD_INT 0
66437: PUSH
66438: EMPTY
66439: LIST
66440: LIST
66441: PUSH
66442: LD_INT 1
66444: NEG
66445: PUSH
66446: LD_INT 1
66448: NEG
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 1
66456: NEG
66457: PUSH
66458: LD_INT 2
66460: NEG
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: LD_INT 0
66468: PUSH
66469: LD_INT 2
66471: NEG
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: PUSH
66477: LD_INT 1
66479: PUSH
66480: LD_INT 1
66482: NEG
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 1
66490: PUSH
66491: LD_INT 2
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: PUSH
66498: LD_INT 0
66500: PUSH
66501: LD_INT 2
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: LD_INT 1
66510: NEG
66511: PUSH
66512: LD_INT 1
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: PUSH
66519: LD_INT 1
66521: PUSH
66522: LD_INT 3
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PUSH
66529: LD_INT 0
66531: PUSH
66532: LD_INT 3
66534: PUSH
66535: EMPTY
66536: LIST
66537: LIST
66538: PUSH
66539: LD_INT 1
66541: NEG
66542: PUSH
66543: LD_INT 2
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: LIST
66554: LIST
66555: LIST
66556: LIST
66557: LIST
66558: LIST
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: LIST
66564: LIST
66565: LIST
66566: LIST
66567: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66568: LD_ADDR_VAR 0 12
66572: PUSH
66573: LD_INT 0
66575: PUSH
66576: LD_INT 0
66578: PUSH
66579: EMPTY
66580: LIST
66581: LIST
66582: PUSH
66583: LD_INT 0
66585: PUSH
66586: LD_INT 1
66588: NEG
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: PUSH
66594: LD_INT 1
66596: PUSH
66597: LD_INT 0
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: LD_INT 1
66606: PUSH
66607: LD_INT 1
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: PUSH
66614: LD_INT 0
66616: PUSH
66617: LD_INT 1
66619: PUSH
66620: EMPTY
66621: LIST
66622: LIST
66623: PUSH
66624: LD_INT 1
66626: NEG
66627: PUSH
66628: LD_INT 0
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: PUSH
66635: LD_INT 1
66637: NEG
66638: PUSH
66639: LD_INT 1
66641: NEG
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: PUSH
66647: LD_INT 1
66649: PUSH
66650: LD_INT 1
66652: NEG
66653: PUSH
66654: EMPTY
66655: LIST
66656: LIST
66657: PUSH
66658: LD_INT 2
66660: PUSH
66661: LD_INT 0
66663: PUSH
66664: EMPTY
66665: LIST
66666: LIST
66667: PUSH
66668: LD_INT 2
66670: PUSH
66671: LD_INT 1
66673: PUSH
66674: EMPTY
66675: LIST
66676: LIST
66677: PUSH
66678: LD_INT 1
66680: NEG
66681: PUSH
66682: LD_INT 1
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 2
66691: NEG
66692: PUSH
66693: LD_INT 0
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PUSH
66700: LD_INT 2
66702: NEG
66703: PUSH
66704: LD_INT 1
66706: NEG
66707: PUSH
66708: EMPTY
66709: LIST
66710: LIST
66711: PUSH
66712: LD_INT 2
66714: NEG
66715: PUSH
66716: LD_INT 1
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PUSH
66723: LD_INT 3
66725: NEG
66726: PUSH
66727: LD_INT 0
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 3
66736: NEG
66737: PUSH
66738: LD_INT 1
66740: NEG
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66764: LD_ADDR_VAR 0 13
66768: PUSH
66769: LD_INT 0
66771: PUSH
66772: LD_INT 0
66774: PUSH
66775: EMPTY
66776: LIST
66777: LIST
66778: PUSH
66779: LD_INT 0
66781: PUSH
66782: LD_INT 1
66784: NEG
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: LD_INT 1
66792: PUSH
66793: LD_INT 0
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 1
66802: PUSH
66803: LD_INT 1
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 0
66812: PUSH
66813: LD_INT 1
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 1
66822: NEG
66823: PUSH
66824: LD_INT 0
66826: PUSH
66827: EMPTY
66828: LIST
66829: LIST
66830: PUSH
66831: LD_INT 1
66833: NEG
66834: PUSH
66835: LD_INT 1
66837: NEG
66838: PUSH
66839: EMPTY
66840: LIST
66841: LIST
66842: PUSH
66843: LD_INT 1
66845: NEG
66846: PUSH
66847: LD_INT 2
66849: NEG
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: PUSH
66855: LD_INT 2
66857: PUSH
66858: LD_INT 1
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 2
66867: PUSH
66868: LD_INT 2
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 1
66877: PUSH
66878: LD_INT 2
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PUSH
66885: LD_INT 2
66887: NEG
66888: PUSH
66889: LD_INT 1
66891: NEG
66892: PUSH
66893: EMPTY
66894: LIST
66895: LIST
66896: PUSH
66897: LD_INT 2
66899: NEG
66900: PUSH
66901: LD_INT 2
66903: NEG
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: PUSH
66909: LD_INT 2
66911: NEG
66912: PUSH
66913: LD_INT 3
66915: NEG
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: PUSH
66921: LD_INT 3
66923: NEG
66924: PUSH
66925: LD_INT 2
66927: NEG
66928: PUSH
66929: EMPTY
66930: LIST
66931: LIST
66932: PUSH
66933: LD_INT 3
66935: NEG
66936: PUSH
66937: LD_INT 3
66939: NEG
66940: PUSH
66941: EMPTY
66942: LIST
66943: LIST
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: LIST
66949: LIST
66950: LIST
66951: LIST
66952: LIST
66953: LIST
66954: LIST
66955: LIST
66956: LIST
66957: LIST
66958: LIST
66959: LIST
66960: LIST
66961: LIST
66962: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66963: LD_ADDR_VAR 0 14
66967: PUSH
66968: LD_INT 0
66970: PUSH
66971: LD_INT 0
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PUSH
66978: LD_INT 0
66980: PUSH
66981: LD_INT 1
66983: NEG
66984: PUSH
66985: EMPTY
66986: LIST
66987: LIST
66988: PUSH
66989: LD_INT 1
66991: PUSH
66992: LD_INT 0
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: PUSH
66999: LD_INT 1
67001: PUSH
67002: LD_INT 1
67004: PUSH
67005: EMPTY
67006: LIST
67007: LIST
67008: PUSH
67009: LD_INT 0
67011: PUSH
67012: LD_INT 1
67014: PUSH
67015: EMPTY
67016: LIST
67017: LIST
67018: PUSH
67019: LD_INT 1
67021: NEG
67022: PUSH
67023: LD_INT 0
67025: PUSH
67026: EMPTY
67027: LIST
67028: LIST
67029: PUSH
67030: LD_INT 1
67032: NEG
67033: PUSH
67034: LD_INT 1
67036: NEG
67037: PUSH
67038: EMPTY
67039: LIST
67040: LIST
67041: PUSH
67042: LD_INT 1
67044: NEG
67045: PUSH
67046: LD_INT 2
67048: NEG
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: LD_INT 2
67059: NEG
67060: PUSH
67061: EMPTY
67062: LIST
67063: LIST
67064: PUSH
67065: LD_INT 1
67067: PUSH
67068: LD_INT 1
67070: NEG
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 1
67078: PUSH
67079: LD_INT 2
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 0
67088: PUSH
67089: LD_INT 2
67091: PUSH
67092: EMPTY
67093: LIST
67094: LIST
67095: PUSH
67096: LD_INT 1
67098: NEG
67099: PUSH
67100: LD_INT 1
67102: PUSH
67103: EMPTY
67104: LIST
67105: LIST
67106: PUSH
67107: LD_INT 1
67109: NEG
67110: PUSH
67111: LD_INT 3
67113: NEG
67114: PUSH
67115: EMPTY
67116: LIST
67117: LIST
67118: PUSH
67119: LD_INT 0
67121: PUSH
67122: LD_INT 3
67124: NEG
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 1
67132: PUSH
67133: LD_INT 2
67135: NEG
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: LIST
67145: LIST
67146: LIST
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: LIST
67158: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67159: LD_ADDR_VAR 0 15
67163: PUSH
67164: LD_INT 0
67166: PUSH
67167: LD_INT 0
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: PUSH
67174: LD_INT 0
67176: PUSH
67177: LD_INT 1
67179: NEG
67180: PUSH
67181: EMPTY
67182: LIST
67183: LIST
67184: PUSH
67185: LD_INT 1
67187: PUSH
67188: LD_INT 0
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: LD_INT 1
67197: PUSH
67198: LD_INT 1
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 0
67207: PUSH
67208: LD_INT 1
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: PUSH
67215: LD_INT 1
67217: NEG
67218: PUSH
67219: LD_INT 0
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: LD_INT 1
67228: NEG
67229: PUSH
67230: LD_INT 1
67232: NEG
67233: PUSH
67234: EMPTY
67235: LIST
67236: LIST
67237: PUSH
67238: LD_INT 1
67240: PUSH
67241: LD_INT 1
67243: NEG
67244: PUSH
67245: EMPTY
67246: LIST
67247: LIST
67248: PUSH
67249: LD_INT 2
67251: PUSH
67252: LD_INT 0
67254: PUSH
67255: EMPTY
67256: LIST
67257: LIST
67258: PUSH
67259: LD_INT 2
67261: PUSH
67262: LD_INT 1
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 1
67271: NEG
67272: PUSH
67273: LD_INT 1
67275: PUSH
67276: EMPTY
67277: LIST
67278: LIST
67279: PUSH
67280: LD_INT 2
67282: NEG
67283: PUSH
67284: LD_INT 0
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: PUSH
67291: LD_INT 2
67293: NEG
67294: PUSH
67295: LD_INT 1
67297: NEG
67298: PUSH
67299: EMPTY
67300: LIST
67301: LIST
67302: PUSH
67303: LD_INT 2
67305: PUSH
67306: LD_INT 1
67308: NEG
67309: PUSH
67310: EMPTY
67311: LIST
67312: LIST
67313: PUSH
67314: LD_INT 3
67316: PUSH
67317: LD_INT 0
67319: PUSH
67320: EMPTY
67321: LIST
67322: LIST
67323: PUSH
67324: LD_INT 3
67326: PUSH
67327: LD_INT 1
67329: PUSH
67330: EMPTY
67331: LIST
67332: LIST
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: LIST
67338: LIST
67339: LIST
67340: LIST
67341: LIST
67342: LIST
67343: LIST
67344: LIST
67345: LIST
67346: LIST
67347: LIST
67348: LIST
67349: LIST
67350: LIST
67351: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67352: LD_ADDR_VAR 0 16
67356: PUSH
67357: LD_INT 0
67359: PUSH
67360: LD_INT 0
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: PUSH
67367: LD_INT 0
67369: PUSH
67370: LD_INT 1
67372: NEG
67373: PUSH
67374: EMPTY
67375: LIST
67376: LIST
67377: PUSH
67378: LD_INT 1
67380: PUSH
67381: LD_INT 0
67383: PUSH
67384: EMPTY
67385: LIST
67386: LIST
67387: PUSH
67388: LD_INT 1
67390: PUSH
67391: LD_INT 1
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 0
67400: PUSH
67401: LD_INT 1
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: PUSH
67408: LD_INT 1
67410: NEG
67411: PUSH
67412: LD_INT 0
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: PUSH
67419: LD_INT 1
67421: NEG
67422: PUSH
67423: LD_INT 1
67425: NEG
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: PUSH
67431: LD_INT 1
67433: NEG
67434: PUSH
67435: LD_INT 2
67437: NEG
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: LD_INT 2
67445: PUSH
67446: LD_INT 1
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PUSH
67453: LD_INT 2
67455: PUSH
67456: LD_INT 2
67458: PUSH
67459: EMPTY
67460: LIST
67461: LIST
67462: PUSH
67463: LD_INT 1
67465: PUSH
67466: LD_INT 2
67468: PUSH
67469: EMPTY
67470: LIST
67471: LIST
67472: PUSH
67473: LD_INT 2
67475: NEG
67476: PUSH
67477: LD_INT 1
67479: NEG
67480: PUSH
67481: EMPTY
67482: LIST
67483: LIST
67484: PUSH
67485: LD_INT 2
67487: NEG
67488: PUSH
67489: LD_INT 2
67491: NEG
67492: PUSH
67493: EMPTY
67494: LIST
67495: LIST
67496: PUSH
67497: LD_INT 3
67499: PUSH
67500: LD_INT 2
67502: PUSH
67503: EMPTY
67504: LIST
67505: LIST
67506: PUSH
67507: LD_INT 3
67509: PUSH
67510: LD_INT 3
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 2
67519: PUSH
67520: LD_INT 3
67522: PUSH
67523: EMPTY
67524: LIST
67525: LIST
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: LIST
67531: LIST
67532: LIST
67533: LIST
67534: LIST
67535: LIST
67536: LIST
67537: LIST
67538: LIST
67539: LIST
67540: LIST
67541: LIST
67542: LIST
67543: LIST
67544: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67545: LD_ADDR_VAR 0 17
67549: PUSH
67550: LD_INT 0
67552: PUSH
67553: LD_INT 0
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 0
67562: PUSH
67563: LD_INT 1
67565: NEG
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PUSH
67571: LD_INT 1
67573: PUSH
67574: LD_INT 0
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: PUSH
67581: LD_INT 1
67583: PUSH
67584: LD_INT 1
67586: PUSH
67587: EMPTY
67588: LIST
67589: LIST
67590: PUSH
67591: LD_INT 0
67593: PUSH
67594: LD_INT 1
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: PUSH
67601: LD_INT 1
67603: NEG
67604: PUSH
67605: LD_INT 0
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PUSH
67612: LD_INT 1
67614: NEG
67615: PUSH
67616: LD_INT 1
67618: NEG
67619: PUSH
67620: EMPTY
67621: LIST
67622: LIST
67623: PUSH
67624: LD_INT 1
67626: NEG
67627: PUSH
67628: LD_INT 2
67630: NEG
67631: PUSH
67632: EMPTY
67633: LIST
67634: LIST
67635: PUSH
67636: LD_INT 0
67638: PUSH
67639: LD_INT 2
67641: NEG
67642: PUSH
67643: EMPTY
67644: LIST
67645: LIST
67646: PUSH
67647: LD_INT 1
67649: PUSH
67650: LD_INT 1
67652: NEG
67653: PUSH
67654: EMPTY
67655: LIST
67656: LIST
67657: PUSH
67658: LD_INT 2
67660: PUSH
67661: LD_INT 0
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: PUSH
67668: LD_INT 2
67670: PUSH
67671: LD_INT 1
67673: PUSH
67674: EMPTY
67675: LIST
67676: LIST
67677: PUSH
67678: LD_INT 2
67680: PUSH
67681: LD_INT 2
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: PUSH
67688: LD_INT 1
67690: PUSH
67691: LD_INT 2
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: PUSH
67698: LD_INT 0
67700: PUSH
67701: LD_INT 2
67703: PUSH
67704: EMPTY
67705: LIST
67706: LIST
67707: PUSH
67708: LD_INT 1
67710: NEG
67711: PUSH
67712: LD_INT 1
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PUSH
67719: LD_INT 2
67721: NEG
67722: PUSH
67723: LD_INT 0
67725: PUSH
67726: EMPTY
67727: LIST
67728: LIST
67729: PUSH
67730: LD_INT 2
67732: NEG
67733: PUSH
67734: LD_INT 1
67736: NEG
67737: PUSH
67738: EMPTY
67739: LIST
67740: LIST
67741: PUSH
67742: LD_INT 2
67744: NEG
67745: PUSH
67746: LD_INT 2
67748: NEG
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67775: LD_ADDR_VAR 0 18
67779: PUSH
67780: LD_INT 0
67782: PUSH
67783: LD_INT 0
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: LD_INT 0
67792: PUSH
67793: LD_INT 1
67795: NEG
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 1
67803: PUSH
67804: LD_INT 0
67806: PUSH
67807: EMPTY
67808: LIST
67809: LIST
67810: PUSH
67811: LD_INT 1
67813: PUSH
67814: LD_INT 1
67816: PUSH
67817: EMPTY
67818: LIST
67819: LIST
67820: PUSH
67821: LD_INT 0
67823: PUSH
67824: LD_INT 1
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: PUSH
67831: LD_INT 1
67833: NEG
67834: PUSH
67835: LD_INT 0
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: LD_INT 1
67844: NEG
67845: PUSH
67846: LD_INT 1
67848: NEG
67849: PUSH
67850: EMPTY
67851: LIST
67852: LIST
67853: PUSH
67854: LD_INT 1
67856: NEG
67857: PUSH
67858: LD_INT 2
67860: NEG
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: PUSH
67866: LD_INT 0
67868: PUSH
67869: LD_INT 2
67871: NEG
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: PUSH
67877: LD_INT 1
67879: PUSH
67880: LD_INT 1
67882: NEG
67883: PUSH
67884: EMPTY
67885: LIST
67886: LIST
67887: PUSH
67888: LD_INT 2
67890: PUSH
67891: LD_INT 0
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: PUSH
67898: LD_INT 2
67900: PUSH
67901: LD_INT 1
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 2
67910: PUSH
67911: LD_INT 2
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 1
67920: PUSH
67921: LD_INT 2
67923: PUSH
67924: EMPTY
67925: LIST
67926: LIST
67927: PUSH
67928: LD_INT 0
67930: PUSH
67931: LD_INT 2
67933: PUSH
67934: EMPTY
67935: LIST
67936: LIST
67937: PUSH
67938: LD_INT 1
67940: NEG
67941: PUSH
67942: LD_INT 1
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: PUSH
67949: LD_INT 2
67951: NEG
67952: PUSH
67953: LD_INT 0
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: PUSH
67960: LD_INT 2
67962: NEG
67963: PUSH
67964: LD_INT 1
67966: NEG
67967: PUSH
67968: EMPTY
67969: LIST
67970: LIST
67971: PUSH
67972: LD_INT 2
67974: NEG
67975: PUSH
67976: LD_INT 2
67978: NEG
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: LIST
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: LIST
67993: LIST
67994: LIST
67995: LIST
67996: LIST
67997: LIST
67998: LIST
67999: LIST
68000: LIST
68001: LIST
68002: LIST
68003: LIST
68004: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68005: LD_ADDR_VAR 0 19
68009: PUSH
68010: LD_INT 0
68012: PUSH
68013: LD_INT 0
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: PUSH
68020: LD_INT 0
68022: PUSH
68023: LD_INT 1
68025: NEG
68026: PUSH
68027: EMPTY
68028: LIST
68029: LIST
68030: PUSH
68031: LD_INT 1
68033: PUSH
68034: LD_INT 0
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: PUSH
68041: LD_INT 1
68043: PUSH
68044: LD_INT 1
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: PUSH
68051: LD_INT 0
68053: PUSH
68054: LD_INT 1
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: PUSH
68061: LD_INT 1
68063: NEG
68064: PUSH
68065: LD_INT 0
68067: PUSH
68068: EMPTY
68069: LIST
68070: LIST
68071: PUSH
68072: LD_INT 1
68074: NEG
68075: PUSH
68076: LD_INT 1
68078: NEG
68079: PUSH
68080: EMPTY
68081: LIST
68082: LIST
68083: PUSH
68084: LD_INT 1
68086: NEG
68087: PUSH
68088: LD_INT 2
68090: NEG
68091: PUSH
68092: EMPTY
68093: LIST
68094: LIST
68095: PUSH
68096: LD_INT 0
68098: PUSH
68099: LD_INT 2
68101: NEG
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: PUSH
68107: LD_INT 1
68109: PUSH
68110: LD_INT 1
68112: NEG
68113: PUSH
68114: EMPTY
68115: LIST
68116: LIST
68117: PUSH
68118: LD_INT 2
68120: PUSH
68121: LD_INT 0
68123: PUSH
68124: EMPTY
68125: LIST
68126: LIST
68127: PUSH
68128: LD_INT 2
68130: PUSH
68131: LD_INT 1
68133: PUSH
68134: EMPTY
68135: LIST
68136: LIST
68137: PUSH
68138: LD_INT 2
68140: PUSH
68141: LD_INT 2
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: PUSH
68148: LD_INT 1
68150: PUSH
68151: LD_INT 2
68153: PUSH
68154: EMPTY
68155: LIST
68156: LIST
68157: PUSH
68158: LD_INT 0
68160: PUSH
68161: LD_INT 2
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: PUSH
68168: LD_INT 1
68170: NEG
68171: PUSH
68172: LD_INT 1
68174: PUSH
68175: EMPTY
68176: LIST
68177: LIST
68178: PUSH
68179: LD_INT 2
68181: NEG
68182: PUSH
68183: LD_INT 0
68185: PUSH
68186: EMPTY
68187: LIST
68188: LIST
68189: PUSH
68190: LD_INT 2
68192: NEG
68193: PUSH
68194: LD_INT 1
68196: NEG
68197: PUSH
68198: EMPTY
68199: LIST
68200: LIST
68201: PUSH
68202: LD_INT 2
68204: NEG
68205: PUSH
68206: LD_INT 2
68208: NEG
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: LIST
68218: LIST
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: LIST
68224: LIST
68225: LIST
68226: LIST
68227: LIST
68228: LIST
68229: LIST
68230: LIST
68231: LIST
68232: LIST
68233: LIST
68234: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68235: LD_ADDR_VAR 0 20
68239: PUSH
68240: LD_INT 0
68242: PUSH
68243: LD_INT 0
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 0
68252: PUSH
68253: LD_INT 1
68255: NEG
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PUSH
68261: LD_INT 1
68263: PUSH
68264: LD_INT 0
68266: PUSH
68267: EMPTY
68268: LIST
68269: LIST
68270: PUSH
68271: LD_INT 1
68273: PUSH
68274: LD_INT 1
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: PUSH
68281: LD_INT 0
68283: PUSH
68284: LD_INT 1
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: LD_INT 1
68293: NEG
68294: PUSH
68295: LD_INT 0
68297: PUSH
68298: EMPTY
68299: LIST
68300: LIST
68301: PUSH
68302: LD_INT 1
68304: NEG
68305: PUSH
68306: LD_INT 1
68308: NEG
68309: PUSH
68310: EMPTY
68311: LIST
68312: LIST
68313: PUSH
68314: LD_INT 1
68316: NEG
68317: PUSH
68318: LD_INT 2
68320: NEG
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: PUSH
68326: LD_INT 0
68328: PUSH
68329: LD_INT 2
68331: NEG
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 1
68339: PUSH
68340: LD_INT 1
68342: NEG
68343: PUSH
68344: EMPTY
68345: LIST
68346: LIST
68347: PUSH
68348: LD_INT 2
68350: PUSH
68351: LD_INT 0
68353: PUSH
68354: EMPTY
68355: LIST
68356: LIST
68357: PUSH
68358: LD_INT 2
68360: PUSH
68361: LD_INT 1
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: PUSH
68368: LD_INT 2
68370: PUSH
68371: LD_INT 2
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 1
68380: PUSH
68381: LD_INT 2
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 0
68390: PUSH
68391: LD_INT 2
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: LD_INT 1
68400: NEG
68401: PUSH
68402: LD_INT 1
68404: PUSH
68405: EMPTY
68406: LIST
68407: LIST
68408: PUSH
68409: LD_INT 2
68411: NEG
68412: PUSH
68413: LD_INT 0
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: PUSH
68420: LD_INT 2
68422: NEG
68423: PUSH
68424: LD_INT 1
68426: NEG
68427: PUSH
68428: EMPTY
68429: LIST
68430: LIST
68431: PUSH
68432: LD_INT 2
68434: NEG
68435: PUSH
68436: LD_INT 2
68438: NEG
68439: PUSH
68440: EMPTY
68441: LIST
68442: LIST
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: LIST
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: LIST
68458: LIST
68459: LIST
68460: LIST
68461: LIST
68462: LIST
68463: LIST
68464: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68465: LD_ADDR_VAR 0 21
68469: PUSH
68470: LD_INT 0
68472: PUSH
68473: LD_INT 0
68475: PUSH
68476: EMPTY
68477: LIST
68478: LIST
68479: PUSH
68480: LD_INT 0
68482: PUSH
68483: LD_INT 1
68485: NEG
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: PUSH
68491: LD_INT 1
68493: PUSH
68494: LD_INT 0
68496: PUSH
68497: EMPTY
68498: LIST
68499: LIST
68500: PUSH
68501: LD_INT 1
68503: PUSH
68504: LD_INT 1
68506: PUSH
68507: EMPTY
68508: LIST
68509: LIST
68510: PUSH
68511: LD_INT 0
68513: PUSH
68514: LD_INT 1
68516: PUSH
68517: EMPTY
68518: LIST
68519: LIST
68520: PUSH
68521: LD_INT 1
68523: NEG
68524: PUSH
68525: LD_INT 0
68527: PUSH
68528: EMPTY
68529: LIST
68530: LIST
68531: PUSH
68532: LD_INT 1
68534: NEG
68535: PUSH
68536: LD_INT 1
68538: NEG
68539: PUSH
68540: EMPTY
68541: LIST
68542: LIST
68543: PUSH
68544: LD_INT 1
68546: NEG
68547: PUSH
68548: LD_INT 2
68550: NEG
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PUSH
68556: LD_INT 0
68558: PUSH
68559: LD_INT 2
68561: NEG
68562: PUSH
68563: EMPTY
68564: LIST
68565: LIST
68566: PUSH
68567: LD_INT 1
68569: PUSH
68570: LD_INT 1
68572: NEG
68573: PUSH
68574: EMPTY
68575: LIST
68576: LIST
68577: PUSH
68578: LD_INT 2
68580: PUSH
68581: LD_INT 0
68583: PUSH
68584: EMPTY
68585: LIST
68586: LIST
68587: PUSH
68588: LD_INT 2
68590: PUSH
68591: LD_INT 1
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PUSH
68598: LD_INT 2
68600: PUSH
68601: LD_INT 2
68603: PUSH
68604: EMPTY
68605: LIST
68606: LIST
68607: PUSH
68608: LD_INT 1
68610: PUSH
68611: LD_INT 2
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: PUSH
68618: LD_INT 0
68620: PUSH
68621: LD_INT 2
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: PUSH
68628: LD_INT 1
68630: NEG
68631: PUSH
68632: LD_INT 1
68634: PUSH
68635: EMPTY
68636: LIST
68637: LIST
68638: PUSH
68639: LD_INT 2
68641: NEG
68642: PUSH
68643: LD_INT 0
68645: PUSH
68646: EMPTY
68647: LIST
68648: LIST
68649: PUSH
68650: LD_INT 2
68652: NEG
68653: PUSH
68654: LD_INT 1
68656: NEG
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: PUSH
68662: LD_INT 2
68664: NEG
68665: PUSH
68666: LD_INT 2
68668: NEG
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: LIST
68689: LIST
68690: LIST
68691: LIST
68692: LIST
68693: LIST
68694: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68695: LD_ADDR_VAR 0 22
68699: PUSH
68700: LD_INT 0
68702: PUSH
68703: LD_INT 0
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: LD_INT 0
68712: PUSH
68713: LD_INT 1
68715: NEG
68716: PUSH
68717: EMPTY
68718: LIST
68719: LIST
68720: PUSH
68721: LD_INT 1
68723: PUSH
68724: LD_INT 0
68726: PUSH
68727: EMPTY
68728: LIST
68729: LIST
68730: PUSH
68731: LD_INT 1
68733: PUSH
68734: LD_INT 1
68736: PUSH
68737: EMPTY
68738: LIST
68739: LIST
68740: PUSH
68741: LD_INT 0
68743: PUSH
68744: LD_INT 1
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PUSH
68751: LD_INT 1
68753: NEG
68754: PUSH
68755: LD_INT 0
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 1
68764: NEG
68765: PUSH
68766: LD_INT 1
68768: NEG
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: PUSH
68774: LD_INT 1
68776: NEG
68777: PUSH
68778: LD_INT 2
68780: NEG
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: PUSH
68786: LD_INT 0
68788: PUSH
68789: LD_INT 2
68791: NEG
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: PUSH
68797: LD_INT 1
68799: PUSH
68800: LD_INT 1
68802: NEG
68803: PUSH
68804: EMPTY
68805: LIST
68806: LIST
68807: PUSH
68808: LD_INT 2
68810: PUSH
68811: LD_INT 0
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: PUSH
68818: LD_INT 2
68820: PUSH
68821: LD_INT 1
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: LD_INT 2
68830: PUSH
68831: LD_INT 2
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: PUSH
68838: LD_INT 1
68840: PUSH
68841: LD_INT 2
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: LD_INT 0
68850: PUSH
68851: LD_INT 2
68853: PUSH
68854: EMPTY
68855: LIST
68856: LIST
68857: PUSH
68858: LD_INT 1
68860: NEG
68861: PUSH
68862: LD_INT 1
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: PUSH
68869: LD_INT 2
68871: NEG
68872: PUSH
68873: LD_INT 0
68875: PUSH
68876: EMPTY
68877: LIST
68878: LIST
68879: PUSH
68880: LD_INT 2
68882: NEG
68883: PUSH
68884: LD_INT 1
68886: NEG
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PUSH
68892: LD_INT 2
68894: NEG
68895: PUSH
68896: LD_INT 2
68898: NEG
68899: PUSH
68900: EMPTY
68901: LIST
68902: LIST
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: LIST
68908: LIST
68909: LIST
68910: LIST
68911: LIST
68912: LIST
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: LIST
68918: LIST
68919: LIST
68920: LIST
68921: LIST
68922: LIST
68923: LIST
68924: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68925: LD_ADDR_VAR 0 23
68929: PUSH
68930: LD_INT 0
68932: PUSH
68933: LD_INT 0
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PUSH
68940: LD_INT 0
68942: PUSH
68943: LD_INT 1
68945: NEG
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 1
68953: PUSH
68954: LD_INT 0
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PUSH
68961: LD_INT 1
68963: PUSH
68964: LD_INT 1
68966: PUSH
68967: EMPTY
68968: LIST
68969: LIST
68970: PUSH
68971: LD_INT 0
68973: PUSH
68974: LD_INT 1
68976: PUSH
68977: EMPTY
68978: LIST
68979: LIST
68980: PUSH
68981: LD_INT 1
68983: NEG
68984: PUSH
68985: LD_INT 0
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 1
68994: NEG
68995: PUSH
68996: LD_INT 1
68998: NEG
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 1
69006: NEG
69007: PUSH
69008: LD_INT 2
69010: NEG
69011: PUSH
69012: EMPTY
69013: LIST
69014: LIST
69015: PUSH
69016: LD_INT 0
69018: PUSH
69019: LD_INT 2
69021: NEG
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 1
69029: PUSH
69030: LD_INT 1
69032: NEG
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 2
69040: PUSH
69041: LD_INT 0
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: PUSH
69048: LD_INT 2
69050: PUSH
69051: LD_INT 1
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PUSH
69058: LD_INT 2
69060: PUSH
69061: LD_INT 2
69063: PUSH
69064: EMPTY
69065: LIST
69066: LIST
69067: PUSH
69068: LD_INT 1
69070: PUSH
69071: LD_INT 2
69073: PUSH
69074: EMPTY
69075: LIST
69076: LIST
69077: PUSH
69078: LD_INT 0
69080: PUSH
69081: LD_INT 2
69083: PUSH
69084: EMPTY
69085: LIST
69086: LIST
69087: PUSH
69088: LD_INT 1
69090: NEG
69091: PUSH
69092: LD_INT 1
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 2
69101: NEG
69102: PUSH
69103: LD_INT 0
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 2
69112: NEG
69113: PUSH
69114: LD_INT 1
69116: NEG
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: LD_INT 2
69124: NEG
69125: PUSH
69126: LD_INT 2
69128: NEG
69129: PUSH
69130: EMPTY
69131: LIST
69132: LIST
69133: PUSH
69134: LD_INT 2
69136: NEG
69137: PUSH
69138: LD_INT 3
69140: NEG
69141: PUSH
69142: EMPTY
69143: LIST
69144: LIST
69145: PUSH
69146: LD_INT 1
69148: NEG
69149: PUSH
69150: LD_INT 3
69152: NEG
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 1
69160: PUSH
69161: LD_INT 2
69163: NEG
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 2
69171: PUSH
69172: LD_INT 1
69174: NEG
69175: PUSH
69176: EMPTY
69177: LIST
69178: LIST
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69205: LD_ADDR_VAR 0 24
69209: PUSH
69210: LD_INT 0
69212: PUSH
69213: LD_INT 0
69215: PUSH
69216: EMPTY
69217: LIST
69218: LIST
69219: PUSH
69220: LD_INT 0
69222: PUSH
69223: LD_INT 1
69225: NEG
69226: PUSH
69227: EMPTY
69228: LIST
69229: LIST
69230: PUSH
69231: LD_INT 1
69233: PUSH
69234: LD_INT 0
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 1
69243: PUSH
69244: LD_INT 1
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PUSH
69251: LD_INT 0
69253: PUSH
69254: LD_INT 1
69256: PUSH
69257: EMPTY
69258: LIST
69259: LIST
69260: PUSH
69261: LD_INT 1
69263: NEG
69264: PUSH
69265: LD_INT 0
69267: PUSH
69268: EMPTY
69269: LIST
69270: LIST
69271: PUSH
69272: LD_INT 1
69274: NEG
69275: PUSH
69276: LD_INT 1
69278: NEG
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: PUSH
69284: LD_INT 1
69286: NEG
69287: PUSH
69288: LD_INT 2
69290: NEG
69291: PUSH
69292: EMPTY
69293: LIST
69294: LIST
69295: PUSH
69296: LD_INT 0
69298: PUSH
69299: LD_INT 2
69301: NEG
69302: PUSH
69303: EMPTY
69304: LIST
69305: LIST
69306: PUSH
69307: LD_INT 1
69309: PUSH
69310: LD_INT 1
69312: NEG
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: LD_INT 2
69320: PUSH
69321: LD_INT 0
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: LD_INT 2
69330: PUSH
69331: LD_INT 1
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 2
69340: PUSH
69341: LD_INT 2
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: LD_INT 1
69350: PUSH
69351: LD_INT 2
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: PUSH
69358: LD_INT 0
69360: PUSH
69361: LD_INT 2
69363: PUSH
69364: EMPTY
69365: LIST
69366: LIST
69367: PUSH
69368: LD_INT 1
69370: NEG
69371: PUSH
69372: LD_INT 1
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PUSH
69379: LD_INT 2
69381: NEG
69382: PUSH
69383: LD_INT 0
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 2
69392: NEG
69393: PUSH
69394: LD_INT 1
69396: NEG
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PUSH
69402: LD_INT 2
69404: NEG
69405: PUSH
69406: LD_INT 2
69408: NEG
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 1
69416: PUSH
69417: LD_INT 2
69419: NEG
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 2
69427: PUSH
69428: LD_INT 1
69430: NEG
69431: PUSH
69432: EMPTY
69433: LIST
69434: LIST
69435: PUSH
69436: LD_INT 3
69438: PUSH
69439: LD_INT 1
69441: PUSH
69442: EMPTY
69443: LIST
69444: LIST
69445: PUSH
69446: LD_INT 3
69448: PUSH
69449: LD_INT 2
69451: PUSH
69452: EMPTY
69453: LIST
69454: LIST
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: LIST
69460: LIST
69461: LIST
69462: LIST
69463: LIST
69464: LIST
69465: LIST
69466: LIST
69467: LIST
69468: LIST
69469: LIST
69470: LIST
69471: LIST
69472: LIST
69473: LIST
69474: LIST
69475: LIST
69476: LIST
69477: LIST
69478: LIST
69479: LIST
69480: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69481: LD_ADDR_VAR 0 25
69485: PUSH
69486: LD_INT 0
69488: PUSH
69489: LD_INT 0
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 0
69498: PUSH
69499: LD_INT 1
69501: NEG
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: PUSH
69507: LD_INT 1
69509: PUSH
69510: LD_INT 0
69512: PUSH
69513: EMPTY
69514: LIST
69515: LIST
69516: PUSH
69517: LD_INT 1
69519: PUSH
69520: LD_INT 1
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PUSH
69527: LD_INT 0
69529: PUSH
69530: LD_INT 1
69532: PUSH
69533: EMPTY
69534: LIST
69535: LIST
69536: PUSH
69537: LD_INT 1
69539: NEG
69540: PUSH
69541: LD_INT 0
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: LD_INT 1
69550: NEG
69551: PUSH
69552: LD_INT 1
69554: NEG
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 1
69562: NEG
69563: PUSH
69564: LD_INT 2
69566: NEG
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 0
69574: PUSH
69575: LD_INT 2
69577: NEG
69578: PUSH
69579: EMPTY
69580: LIST
69581: LIST
69582: PUSH
69583: LD_INT 1
69585: PUSH
69586: LD_INT 1
69588: NEG
69589: PUSH
69590: EMPTY
69591: LIST
69592: LIST
69593: PUSH
69594: LD_INT 2
69596: PUSH
69597: LD_INT 0
69599: PUSH
69600: EMPTY
69601: LIST
69602: LIST
69603: PUSH
69604: LD_INT 2
69606: PUSH
69607: LD_INT 1
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: PUSH
69614: LD_INT 2
69616: PUSH
69617: LD_INT 2
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 1
69626: PUSH
69627: LD_INT 2
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: PUSH
69634: LD_INT 0
69636: PUSH
69637: LD_INT 2
69639: PUSH
69640: EMPTY
69641: LIST
69642: LIST
69643: PUSH
69644: LD_INT 1
69646: NEG
69647: PUSH
69648: LD_INT 1
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 2
69657: NEG
69658: PUSH
69659: LD_INT 0
69661: PUSH
69662: EMPTY
69663: LIST
69664: LIST
69665: PUSH
69666: LD_INT 2
69668: NEG
69669: PUSH
69670: LD_INT 1
69672: NEG
69673: PUSH
69674: EMPTY
69675: LIST
69676: LIST
69677: PUSH
69678: LD_INT 2
69680: NEG
69681: PUSH
69682: LD_INT 2
69684: NEG
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: LD_INT 3
69692: PUSH
69693: LD_INT 1
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: PUSH
69700: LD_INT 3
69702: PUSH
69703: LD_INT 2
69705: PUSH
69706: EMPTY
69707: LIST
69708: LIST
69709: PUSH
69710: LD_INT 2
69712: PUSH
69713: LD_INT 3
69715: PUSH
69716: EMPTY
69717: LIST
69718: LIST
69719: PUSH
69720: LD_INT 1
69722: PUSH
69723: LD_INT 3
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69755: LD_ADDR_VAR 0 26
69759: PUSH
69760: LD_INT 0
69762: PUSH
69763: LD_INT 0
69765: PUSH
69766: EMPTY
69767: LIST
69768: LIST
69769: PUSH
69770: LD_INT 0
69772: PUSH
69773: LD_INT 1
69775: NEG
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 1
69783: PUSH
69784: LD_INT 0
69786: PUSH
69787: EMPTY
69788: LIST
69789: LIST
69790: PUSH
69791: LD_INT 1
69793: PUSH
69794: LD_INT 1
69796: PUSH
69797: EMPTY
69798: LIST
69799: LIST
69800: PUSH
69801: LD_INT 0
69803: PUSH
69804: LD_INT 1
69806: PUSH
69807: EMPTY
69808: LIST
69809: LIST
69810: PUSH
69811: LD_INT 1
69813: NEG
69814: PUSH
69815: LD_INT 0
69817: PUSH
69818: EMPTY
69819: LIST
69820: LIST
69821: PUSH
69822: LD_INT 1
69824: NEG
69825: PUSH
69826: LD_INT 1
69828: NEG
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 1
69836: NEG
69837: PUSH
69838: LD_INT 2
69840: NEG
69841: PUSH
69842: EMPTY
69843: LIST
69844: LIST
69845: PUSH
69846: LD_INT 0
69848: PUSH
69849: LD_INT 2
69851: NEG
69852: PUSH
69853: EMPTY
69854: LIST
69855: LIST
69856: PUSH
69857: LD_INT 1
69859: PUSH
69860: LD_INT 1
69862: NEG
69863: PUSH
69864: EMPTY
69865: LIST
69866: LIST
69867: PUSH
69868: LD_INT 2
69870: PUSH
69871: LD_INT 0
69873: PUSH
69874: EMPTY
69875: LIST
69876: LIST
69877: PUSH
69878: LD_INT 2
69880: PUSH
69881: LD_INT 1
69883: PUSH
69884: EMPTY
69885: LIST
69886: LIST
69887: PUSH
69888: LD_INT 2
69890: PUSH
69891: LD_INT 2
69893: PUSH
69894: EMPTY
69895: LIST
69896: LIST
69897: PUSH
69898: LD_INT 1
69900: PUSH
69901: LD_INT 2
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: LD_INT 0
69910: PUSH
69911: LD_INT 2
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PUSH
69918: LD_INT 1
69920: NEG
69921: PUSH
69922: LD_INT 1
69924: PUSH
69925: EMPTY
69926: LIST
69927: LIST
69928: PUSH
69929: LD_INT 2
69931: NEG
69932: PUSH
69933: LD_INT 0
69935: PUSH
69936: EMPTY
69937: LIST
69938: LIST
69939: PUSH
69940: LD_INT 2
69942: NEG
69943: PUSH
69944: LD_INT 1
69946: NEG
69947: PUSH
69948: EMPTY
69949: LIST
69950: LIST
69951: PUSH
69952: LD_INT 2
69954: NEG
69955: PUSH
69956: LD_INT 2
69958: NEG
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: PUSH
69964: LD_INT 2
69966: PUSH
69967: LD_INT 3
69969: PUSH
69970: EMPTY
69971: LIST
69972: LIST
69973: PUSH
69974: LD_INT 1
69976: PUSH
69977: LD_INT 3
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PUSH
69984: LD_INT 1
69986: NEG
69987: PUSH
69988: LD_INT 2
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: PUSH
69995: LD_INT 2
69997: NEG
69998: PUSH
69999: LD_INT 1
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: LIST
70010: LIST
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: LIST
70016: LIST
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: LIST
70022: LIST
70023: LIST
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: LIST
70030: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70031: LD_ADDR_VAR 0 27
70035: PUSH
70036: LD_INT 0
70038: PUSH
70039: LD_INT 0
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PUSH
70046: LD_INT 0
70048: PUSH
70049: LD_INT 1
70051: NEG
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 1
70059: PUSH
70060: LD_INT 0
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 1
70069: PUSH
70070: LD_INT 1
70072: PUSH
70073: EMPTY
70074: LIST
70075: LIST
70076: PUSH
70077: LD_INT 0
70079: PUSH
70080: LD_INT 1
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 1
70089: NEG
70090: PUSH
70091: LD_INT 0
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 1
70100: NEG
70101: PUSH
70102: LD_INT 1
70104: NEG
70105: PUSH
70106: EMPTY
70107: LIST
70108: LIST
70109: PUSH
70110: LD_INT 1
70112: NEG
70113: PUSH
70114: LD_INT 2
70116: NEG
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 0
70124: PUSH
70125: LD_INT 2
70127: NEG
70128: PUSH
70129: EMPTY
70130: LIST
70131: LIST
70132: PUSH
70133: LD_INT 1
70135: PUSH
70136: LD_INT 1
70138: NEG
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: PUSH
70144: LD_INT 2
70146: PUSH
70147: LD_INT 0
70149: PUSH
70150: EMPTY
70151: LIST
70152: LIST
70153: PUSH
70154: LD_INT 2
70156: PUSH
70157: LD_INT 1
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: PUSH
70164: LD_INT 2
70166: PUSH
70167: LD_INT 2
70169: PUSH
70170: EMPTY
70171: LIST
70172: LIST
70173: PUSH
70174: LD_INT 1
70176: PUSH
70177: LD_INT 2
70179: PUSH
70180: EMPTY
70181: LIST
70182: LIST
70183: PUSH
70184: LD_INT 0
70186: PUSH
70187: LD_INT 2
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: PUSH
70194: LD_INT 1
70196: NEG
70197: PUSH
70198: LD_INT 1
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PUSH
70205: LD_INT 2
70207: NEG
70208: PUSH
70209: LD_INT 0
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 2
70218: NEG
70219: PUSH
70220: LD_INT 1
70222: NEG
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PUSH
70228: LD_INT 2
70230: NEG
70231: PUSH
70232: LD_INT 2
70234: NEG
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 1
70242: NEG
70243: PUSH
70244: LD_INT 2
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: PUSH
70251: LD_INT 2
70253: NEG
70254: PUSH
70255: LD_INT 1
70257: PUSH
70258: EMPTY
70259: LIST
70260: LIST
70261: PUSH
70262: LD_INT 3
70264: NEG
70265: PUSH
70266: LD_INT 1
70268: NEG
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: PUSH
70274: LD_INT 3
70276: NEG
70277: PUSH
70278: LD_INT 2
70280: NEG
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70311: LD_ADDR_VAR 0 28
70315: PUSH
70316: LD_INT 0
70318: PUSH
70319: LD_INT 0
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 0
70328: PUSH
70329: LD_INT 1
70331: NEG
70332: PUSH
70333: EMPTY
70334: LIST
70335: LIST
70336: PUSH
70337: LD_INT 1
70339: PUSH
70340: LD_INT 0
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PUSH
70347: LD_INT 1
70349: PUSH
70350: LD_INT 1
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: PUSH
70357: LD_INT 0
70359: PUSH
70360: LD_INT 1
70362: PUSH
70363: EMPTY
70364: LIST
70365: LIST
70366: PUSH
70367: LD_INT 1
70369: NEG
70370: PUSH
70371: LD_INT 0
70373: PUSH
70374: EMPTY
70375: LIST
70376: LIST
70377: PUSH
70378: LD_INT 1
70380: NEG
70381: PUSH
70382: LD_INT 1
70384: NEG
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PUSH
70390: LD_INT 1
70392: NEG
70393: PUSH
70394: LD_INT 2
70396: NEG
70397: PUSH
70398: EMPTY
70399: LIST
70400: LIST
70401: PUSH
70402: LD_INT 0
70404: PUSH
70405: LD_INT 2
70407: NEG
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: LD_INT 1
70415: PUSH
70416: LD_INT 1
70418: NEG
70419: PUSH
70420: EMPTY
70421: LIST
70422: LIST
70423: PUSH
70424: LD_INT 2
70426: PUSH
70427: LD_INT 0
70429: PUSH
70430: EMPTY
70431: LIST
70432: LIST
70433: PUSH
70434: LD_INT 2
70436: PUSH
70437: LD_INT 1
70439: PUSH
70440: EMPTY
70441: LIST
70442: LIST
70443: PUSH
70444: LD_INT 2
70446: PUSH
70447: LD_INT 2
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: PUSH
70454: LD_INT 1
70456: PUSH
70457: LD_INT 2
70459: PUSH
70460: EMPTY
70461: LIST
70462: LIST
70463: PUSH
70464: LD_INT 0
70466: PUSH
70467: LD_INT 2
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: PUSH
70474: LD_INT 1
70476: NEG
70477: PUSH
70478: LD_INT 1
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PUSH
70485: LD_INT 2
70487: NEG
70488: PUSH
70489: LD_INT 0
70491: PUSH
70492: EMPTY
70493: LIST
70494: LIST
70495: PUSH
70496: LD_INT 2
70498: NEG
70499: PUSH
70500: LD_INT 1
70502: NEG
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: PUSH
70508: LD_INT 2
70510: NEG
70511: PUSH
70512: LD_INT 2
70514: NEG
70515: PUSH
70516: EMPTY
70517: LIST
70518: LIST
70519: PUSH
70520: LD_INT 2
70522: NEG
70523: PUSH
70524: LD_INT 3
70526: NEG
70527: PUSH
70528: EMPTY
70529: LIST
70530: LIST
70531: PUSH
70532: LD_INT 1
70534: NEG
70535: PUSH
70536: LD_INT 3
70538: NEG
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 3
70546: NEG
70547: PUSH
70548: LD_INT 1
70550: NEG
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: PUSH
70556: LD_INT 3
70558: NEG
70559: PUSH
70560: LD_INT 2
70562: NEG
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: PUSH
70568: EMPTY
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: LIST
70586: LIST
70587: LIST
70588: LIST
70589: LIST
70590: LIST
70591: LIST
70592: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70593: LD_ADDR_VAR 0 29
70597: PUSH
70598: LD_INT 0
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 0
70610: PUSH
70611: LD_INT 1
70613: NEG
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 1
70621: PUSH
70622: LD_INT 0
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 1
70631: PUSH
70632: LD_INT 1
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 0
70641: PUSH
70642: LD_INT 1
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: LD_INT 1
70651: NEG
70652: PUSH
70653: LD_INT 0
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 1
70662: NEG
70663: PUSH
70664: LD_INT 1
70666: NEG
70667: PUSH
70668: EMPTY
70669: LIST
70670: LIST
70671: PUSH
70672: LD_INT 1
70674: NEG
70675: PUSH
70676: LD_INT 2
70678: NEG
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: PUSH
70684: LD_INT 0
70686: PUSH
70687: LD_INT 2
70689: NEG
70690: PUSH
70691: EMPTY
70692: LIST
70693: LIST
70694: PUSH
70695: LD_INT 1
70697: PUSH
70698: LD_INT 1
70700: NEG
70701: PUSH
70702: EMPTY
70703: LIST
70704: LIST
70705: PUSH
70706: LD_INT 2
70708: PUSH
70709: LD_INT 0
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PUSH
70716: LD_INT 2
70718: PUSH
70719: LD_INT 1
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: LD_INT 1
70728: PUSH
70729: LD_INT 2
70731: PUSH
70732: EMPTY
70733: LIST
70734: LIST
70735: PUSH
70736: LD_INT 0
70738: PUSH
70739: LD_INT 2
70741: PUSH
70742: EMPTY
70743: LIST
70744: LIST
70745: PUSH
70746: LD_INT 1
70748: NEG
70749: PUSH
70750: LD_INT 1
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: PUSH
70757: LD_INT 2
70759: NEG
70760: PUSH
70761: LD_INT 1
70763: NEG
70764: PUSH
70765: EMPTY
70766: LIST
70767: LIST
70768: PUSH
70769: LD_INT 2
70771: NEG
70772: PUSH
70773: LD_INT 2
70775: NEG
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: PUSH
70781: LD_INT 2
70783: NEG
70784: PUSH
70785: LD_INT 3
70787: NEG
70788: PUSH
70789: EMPTY
70790: LIST
70791: LIST
70792: PUSH
70793: LD_INT 2
70795: PUSH
70796: LD_INT 1
70798: NEG
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: PUSH
70804: LD_INT 3
70806: PUSH
70807: LD_INT 1
70809: PUSH
70810: EMPTY
70811: LIST
70812: LIST
70813: PUSH
70814: LD_INT 1
70816: PUSH
70817: LD_INT 3
70819: PUSH
70820: EMPTY
70821: LIST
70822: LIST
70823: PUSH
70824: LD_INT 1
70826: NEG
70827: PUSH
70828: LD_INT 2
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 3
70837: NEG
70838: PUSH
70839: LD_INT 2
70841: NEG
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: LIST
70851: LIST
70852: LIST
70853: LIST
70854: LIST
70855: LIST
70856: LIST
70857: LIST
70858: LIST
70859: LIST
70860: LIST
70861: LIST
70862: LIST
70863: LIST
70864: LIST
70865: LIST
70866: LIST
70867: LIST
70868: LIST
70869: LIST
70870: LIST
70871: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70872: LD_ADDR_VAR 0 30
70876: PUSH
70877: LD_INT 0
70879: PUSH
70880: LD_INT 0
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 0
70889: PUSH
70890: LD_INT 1
70892: NEG
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: PUSH
70898: LD_INT 1
70900: PUSH
70901: LD_INT 0
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: PUSH
70908: LD_INT 1
70910: PUSH
70911: LD_INT 1
70913: PUSH
70914: EMPTY
70915: LIST
70916: LIST
70917: PUSH
70918: LD_INT 0
70920: PUSH
70921: LD_INT 1
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 1
70930: NEG
70931: PUSH
70932: LD_INT 0
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 1
70941: NEG
70942: PUSH
70943: LD_INT 1
70945: NEG
70946: PUSH
70947: EMPTY
70948: LIST
70949: LIST
70950: PUSH
70951: LD_INT 1
70953: NEG
70954: PUSH
70955: LD_INT 2
70957: NEG
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: PUSH
70963: LD_INT 0
70965: PUSH
70966: LD_INT 2
70968: NEG
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: PUSH
70974: LD_INT 1
70976: PUSH
70977: LD_INT 1
70979: NEG
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: LD_INT 2
70987: PUSH
70988: LD_INT 0
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: PUSH
70995: LD_INT 2
70997: PUSH
70998: LD_INT 1
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 2
71007: PUSH
71008: LD_INT 2
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: PUSH
71015: LD_INT 1
71017: PUSH
71018: LD_INT 2
71020: PUSH
71021: EMPTY
71022: LIST
71023: LIST
71024: PUSH
71025: LD_INT 1
71027: NEG
71028: PUSH
71029: LD_INT 1
71031: PUSH
71032: EMPTY
71033: LIST
71034: LIST
71035: PUSH
71036: LD_INT 2
71038: NEG
71039: PUSH
71040: LD_INT 0
71042: PUSH
71043: EMPTY
71044: LIST
71045: LIST
71046: PUSH
71047: LD_INT 2
71049: NEG
71050: PUSH
71051: LD_INT 1
71053: NEG
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 1
71061: NEG
71062: PUSH
71063: LD_INT 3
71065: NEG
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 1
71073: PUSH
71074: LD_INT 2
71076: NEG
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: LD_INT 3
71084: PUSH
71085: LD_INT 2
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 2
71094: PUSH
71095: LD_INT 3
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: PUSH
71102: LD_INT 2
71104: NEG
71105: PUSH
71106: LD_INT 1
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: LD_INT 3
71115: NEG
71116: PUSH
71117: LD_INT 1
71119: NEG
71120: PUSH
71121: EMPTY
71122: LIST
71123: LIST
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: LIST
71129: LIST
71130: LIST
71131: LIST
71132: LIST
71133: LIST
71134: LIST
71135: LIST
71136: LIST
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71150: LD_ADDR_VAR 0 31
71154: PUSH
71155: LD_INT 0
71157: PUSH
71158: LD_INT 0
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PUSH
71165: LD_INT 0
71167: PUSH
71168: LD_INT 1
71170: NEG
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: PUSH
71176: LD_INT 1
71178: PUSH
71179: LD_INT 0
71181: PUSH
71182: EMPTY
71183: LIST
71184: LIST
71185: PUSH
71186: LD_INT 1
71188: PUSH
71189: LD_INT 1
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: PUSH
71196: LD_INT 0
71198: PUSH
71199: LD_INT 1
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: PUSH
71206: LD_INT 1
71208: NEG
71209: PUSH
71210: LD_INT 0
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: PUSH
71217: LD_INT 1
71219: NEG
71220: PUSH
71221: LD_INT 1
71223: NEG
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: PUSH
71229: LD_INT 1
71231: NEG
71232: PUSH
71233: LD_INT 2
71235: NEG
71236: PUSH
71237: EMPTY
71238: LIST
71239: LIST
71240: PUSH
71241: LD_INT 1
71243: PUSH
71244: LD_INT 1
71246: NEG
71247: PUSH
71248: EMPTY
71249: LIST
71250: LIST
71251: PUSH
71252: LD_INT 2
71254: PUSH
71255: LD_INT 0
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 2
71264: PUSH
71265: LD_INT 1
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: PUSH
71272: LD_INT 2
71274: PUSH
71275: LD_INT 2
71277: PUSH
71278: EMPTY
71279: LIST
71280: LIST
71281: PUSH
71282: LD_INT 1
71284: PUSH
71285: LD_INT 2
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PUSH
71292: LD_INT 0
71294: PUSH
71295: LD_INT 2
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PUSH
71302: LD_INT 1
71304: NEG
71305: PUSH
71306: LD_INT 1
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 2
71315: NEG
71316: PUSH
71317: LD_INT 1
71319: NEG
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: PUSH
71325: LD_INT 2
71327: NEG
71328: PUSH
71329: LD_INT 2
71331: NEG
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PUSH
71337: LD_INT 2
71339: NEG
71340: PUSH
71341: LD_INT 3
71343: NEG
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: LD_INT 2
71351: PUSH
71352: LD_INT 1
71354: NEG
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: PUSH
71360: LD_INT 3
71362: PUSH
71363: LD_INT 1
71365: PUSH
71366: EMPTY
71367: LIST
71368: LIST
71369: PUSH
71370: LD_INT 1
71372: PUSH
71373: LD_INT 3
71375: PUSH
71376: EMPTY
71377: LIST
71378: LIST
71379: PUSH
71380: LD_INT 1
71382: NEG
71383: PUSH
71384: LD_INT 2
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: PUSH
71391: LD_INT 3
71393: NEG
71394: PUSH
71395: LD_INT 2
71397: NEG
71398: PUSH
71399: EMPTY
71400: LIST
71401: LIST
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: LIST
71407: LIST
71408: LIST
71409: LIST
71410: LIST
71411: LIST
71412: LIST
71413: LIST
71414: LIST
71415: LIST
71416: LIST
71417: LIST
71418: LIST
71419: LIST
71420: LIST
71421: LIST
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71428: LD_ADDR_VAR 0 32
71432: PUSH
71433: LD_INT 0
71435: PUSH
71436: LD_INT 0
71438: PUSH
71439: EMPTY
71440: LIST
71441: LIST
71442: PUSH
71443: LD_INT 0
71445: PUSH
71446: LD_INT 1
71448: NEG
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 1
71456: PUSH
71457: LD_INT 0
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: LD_INT 1
71466: PUSH
71467: LD_INT 1
71469: PUSH
71470: EMPTY
71471: LIST
71472: LIST
71473: PUSH
71474: LD_INT 0
71476: PUSH
71477: LD_INT 1
71479: PUSH
71480: EMPTY
71481: LIST
71482: LIST
71483: PUSH
71484: LD_INT 1
71486: NEG
71487: PUSH
71488: LD_INT 0
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PUSH
71495: LD_INT 1
71497: NEG
71498: PUSH
71499: LD_INT 1
71501: NEG
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 1
71509: NEG
71510: PUSH
71511: LD_INT 2
71513: NEG
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 0
71521: PUSH
71522: LD_INT 2
71524: NEG
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: PUSH
71530: LD_INT 1
71532: PUSH
71533: LD_INT 1
71535: NEG
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 2
71543: PUSH
71544: LD_INT 1
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PUSH
71551: LD_INT 2
71553: PUSH
71554: LD_INT 2
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 1
71563: PUSH
71564: LD_INT 2
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PUSH
71571: LD_INT 0
71573: PUSH
71574: LD_INT 2
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 1
71583: NEG
71584: PUSH
71585: LD_INT 1
71587: PUSH
71588: EMPTY
71589: LIST
71590: LIST
71591: PUSH
71592: LD_INT 2
71594: NEG
71595: PUSH
71596: LD_INT 0
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: PUSH
71603: LD_INT 2
71605: NEG
71606: PUSH
71607: LD_INT 1
71609: NEG
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PUSH
71615: LD_INT 1
71617: NEG
71618: PUSH
71619: LD_INT 3
71621: NEG
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 1
71629: PUSH
71630: LD_INT 2
71632: NEG
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: LD_INT 3
71640: PUSH
71641: LD_INT 2
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: LD_INT 2
71650: PUSH
71651: LD_INT 3
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: LD_INT 2
71660: NEG
71661: PUSH
71662: LD_INT 1
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: PUSH
71669: LD_INT 3
71671: NEG
71672: PUSH
71673: LD_INT 1
71675: NEG
71676: PUSH
71677: EMPTY
71678: LIST
71679: LIST
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: LIST
71685: LIST
71686: LIST
71687: LIST
71688: LIST
71689: LIST
71690: LIST
71691: LIST
71692: LIST
71693: LIST
71694: LIST
71695: LIST
71696: LIST
71697: LIST
71698: LIST
71699: LIST
71700: LIST
71701: LIST
71702: LIST
71703: LIST
71704: LIST
71705: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71706: LD_ADDR_VAR 0 33
71710: PUSH
71711: LD_INT 0
71713: PUSH
71714: LD_INT 0
71716: PUSH
71717: EMPTY
71718: LIST
71719: LIST
71720: PUSH
71721: LD_INT 0
71723: PUSH
71724: LD_INT 1
71726: NEG
71727: PUSH
71728: EMPTY
71729: LIST
71730: LIST
71731: PUSH
71732: LD_INT 1
71734: PUSH
71735: LD_INT 0
71737: PUSH
71738: EMPTY
71739: LIST
71740: LIST
71741: PUSH
71742: LD_INT 1
71744: PUSH
71745: LD_INT 1
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: PUSH
71752: LD_INT 0
71754: PUSH
71755: LD_INT 1
71757: PUSH
71758: EMPTY
71759: LIST
71760: LIST
71761: PUSH
71762: LD_INT 1
71764: NEG
71765: PUSH
71766: LD_INT 0
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: LD_INT 1
71775: NEG
71776: PUSH
71777: LD_INT 1
71779: NEG
71780: PUSH
71781: EMPTY
71782: LIST
71783: LIST
71784: PUSH
71785: LD_INT 1
71787: NEG
71788: PUSH
71789: LD_INT 2
71791: NEG
71792: PUSH
71793: EMPTY
71794: LIST
71795: LIST
71796: PUSH
71797: LD_INT 1
71799: PUSH
71800: LD_INT 1
71802: NEG
71803: PUSH
71804: EMPTY
71805: LIST
71806: LIST
71807: PUSH
71808: LD_INT 2
71810: PUSH
71811: LD_INT 0
71813: PUSH
71814: EMPTY
71815: LIST
71816: LIST
71817: PUSH
71818: LD_INT 2
71820: PUSH
71821: LD_INT 1
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PUSH
71828: LD_INT 1
71830: PUSH
71831: LD_INT 2
71833: PUSH
71834: EMPTY
71835: LIST
71836: LIST
71837: PUSH
71838: LD_INT 0
71840: PUSH
71841: LD_INT 2
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 1
71850: NEG
71851: PUSH
71852: LD_INT 1
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 2
71861: NEG
71862: PUSH
71863: LD_INT 0
71865: PUSH
71866: EMPTY
71867: LIST
71868: LIST
71869: PUSH
71870: LD_INT 2
71872: NEG
71873: PUSH
71874: LD_INT 1
71876: NEG
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: LD_INT 2
71884: NEG
71885: PUSH
71886: LD_INT 2
71888: NEG
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 2
71896: NEG
71897: PUSH
71898: LD_INT 3
71900: NEG
71901: PUSH
71902: EMPTY
71903: LIST
71904: LIST
71905: PUSH
71906: LD_INT 2
71908: PUSH
71909: LD_INT 1
71911: NEG
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: LD_INT 3
71919: PUSH
71920: LD_INT 1
71922: PUSH
71923: EMPTY
71924: LIST
71925: LIST
71926: PUSH
71927: LD_INT 1
71929: PUSH
71930: LD_INT 3
71932: PUSH
71933: EMPTY
71934: LIST
71935: LIST
71936: PUSH
71937: LD_INT 1
71939: NEG
71940: PUSH
71941: LD_INT 2
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PUSH
71948: LD_INT 3
71950: NEG
71951: PUSH
71952: LD_INT 2
71954: NEG
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: LIST
71964: LIST
71965: LIST
71966: LIST
71967: LIST
71968: LIST
71969: LIST
71970: LIST
71971: LIST
71972: LIST
71973: LIST
71974: LIST
71975: LIST
71976: LIST
71977: LIST
71978: LIST
71979: LIST
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71985: LD_ADDR_VAR 0 34
71989: PUSH
71990: LD_INT 0
71992: PUSH
71993: LD_INT 0
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 0
72002: PUSH
72003: LD_INT 1
72005: NEG
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 1
72013: PUSH
72014: LD_INT 0
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 1
72023: PUSH
72024: LD_INT 1
72026: PUSH
72027: EMPTY
72028: LIST
72029: LIST
72030: PUSH
72031: LD_INT 0
72033: PUSH
72034: LD_INT 1
72036: PUSH
72037: EMPTY
72038: LIST
72039: LIST
72040: PUSH
72041: LD_INT 1
72043: NEG
72044: PUSH
72045: LD_INT 0
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: PUSH
72052: LD_INT 1
72054: NEG
72055: PUSH
72056: LD_INT 1
72058: NEG
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: LD_INT 1
72066: NEG
72067: PUSH
72068: LD_INT 2
72070: NEG
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 0
72078: PUSH
72079: LD_INT 2
72081: NEG
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: PUSH
72087: LD_INT 1
72089: PUSH
72090: LD_INT 1
72092: NEG
72093: PUSH
72094: EMPTY
72095: LIST
72096: LIST
72097: PUSH
72098: LD_INT 2
72100: PUSH
72101: LD_INT 1
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: PUSH
72108: LD_INT 2
72110: PUSH
72111: LD_INT 2
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: PUSH
72118: LD_INT 1
72120: PUSH
72121: LD_INT 2
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 1
72130: NEG
72131: PUSH
72132: LD_INT 1
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: PUSH
72139: LD_INT 2
72141: NEG
72142: PUSH
72143: LD_INT 0
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: PUSH
72150: LD_INT 2
72152: NEG
72153: PUSH
72154: LD_INT 1
72156: NEG
72157: PUSH
72158: EMPTY
72159: LIST
72160: LIST
72161: PUSH
72162: LD_INT 2
72164: NEG
72165: PUSH
72166: LD_INT 2
72168: NEG
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: LD_INT 1
72176: NEG
72177: PUSH
72178: LD_INT 3
72180: NEG
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 1
72188: PUSH
72189: LD_INT 2
72191: NEG
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: PUSH
72197: LD_INT 3
72199: PUSH
72200: LD_INT 2
72202: PUSH
72203: EMPTY
72204: LIST
72205: LIST
72206: PUSH
72207: LD_INT 2
72209: PUSH
72210: LD_INT 3
72212: PUSH
72213: EMPTY
72214: LIST
72215: LIST
72216: PUSH
72217: LD_INT 2
72219: NEG
72220: PUSH
72221: LD_INT 1
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: PUSH
72228: LD_INT 3
72230: NEG
72231: PUSH
72232: LD_INT 1
72234: NEG
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: EMPTY
72241: LIST
72242: LIST
72243: LIST
72244: LIST
72245: LIST
72246: LIST
72247: LIST
72248: LIST
72249: LIST
72250: LIST
72251: LIST
72252: LIST
72253: LIST
72254: LIST
72255: LIST
72256: LIST
72257: LIST
72258: LIST
72259: LIST
72260: LIST
72261: LIST
72262: LIST
72263: LIST
72264: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72265: LD_ADDR_VAR 0 35
72269: PUSH
72270: LD_INT 0
72272: PUSH
72273: LD_INT 0
72275: PUSH
72276: EMPTY
72277: LIST
72278: LIST
72279: PUSH
72280: LD_INT 0
72282: PUSH
72283: LD_INT 1
72285: NEG
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: PUSH
72291: LD_INT 1
72293: PUSH
72294: LD_INT 0
72296: PUSH
72297: EMPTY
72298: LIST
72299: LIST
72300: PUSH
72301: LD_INT 1
72303: PUSH
72304: LD_INT 1
72306: PUSH
72307: EMPTY
72308: LIST
72309: LIST
72310: PUSH
72311: LD_INT 0
72313: PUSH
72314: LD_INT 1
72316: PUSH
72317: EMPTY
72318: LIST
72319: LIST
72320: PUSH
72321: LD_INT 1
72323: NEG
72324: PUSH
72325: LD_INT 0
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: PUSH
72332: LD_INT 1
72334: NEG
72335: PUSH
72336: LD_INT 1
72338: NEG
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 2
72346: PUSH
72347: LD_INT 1
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 2
72356: NEG
72357: PUSH
72358: LD_INT 1
72360: NEG
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: LIST
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: LIST
72376: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72377: LD_ADDR_VAR 0 36
72381: PUSH
72382: LD_INT 0
72384: PUSH
72385: LD_INT 0
72387: PUSH
72388: EMPTY
72389: LIST
72390: LIST
72391: PUSH
72392: LD_INT 0
72394: PUSH
72395: LD_INT 1
72397: NEG
72398: PUSH
72399: EMPTY
72400: LIST
72401: LIST
72402: PUSH
72403: LD_INT 1
72405: PUSH
72406: LD_INT 0
72408: PUSH
72409: EMPTY
72410: LIST
72411: LIST
72412: PUSH
72413: LD_INT 1
72415: PUSH
72416: LD_INT 1
72418: PUSH
72419: EMPTY
72420: LIST
72421: LIST
72422: PUSH
72423: LD_INT 0
72425: PUSH
72426: LD_INT 1
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: PUSH
72433: LD_INT 1
72435: NEG
72436: PUSH
72437: LD_INT 0
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: LD_INT 1
72446: NEG
72447: PUSH
72448: LD_INT 1
72450: NEG
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: LD_INT 1
72458: NEG
72459: PUSH
72460: LD_INT 2
72462: NEG
72463: PUSH
72464: EMPTY
72465: LIST
72466: LIST
72467: PUSH
72468: LD_INT 1
72470: PUSH
72471: LD_INT 2
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: LIST
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: LIST
72488: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72489: LD_ADDR_VAR 0 37
72493: PUSH
72494: LD_INT 0
72496: PUSH
72497: LD_INT 0
72499: PUSH
72500: EMPTY
72501: LIST
72502: LIST
72503: PUSH
72504: LD_INT 0
72506: PUSH
72507: LD_INT 1
72509: NEG
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: PUSH
72515: LD_INT 1
72517: PUSH
72518: LD_INT 0
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: LD_INT 1
72527: PUSH
72528: LD_INT 1
72530: PUSH
72531: EMPTY
72532: LIST
72533: LIST
72534: PUSH
72535: LD_INT 0
72537: PUSH
72538: LD_INT 1
72540: PUSH
72541: EMPTY
72542: LIST
72543: LIST
72544: PUSH
72545: LD_INT 1
72547: NEG
72548: PUSH
72549: LD_INT 0
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: PUSH
72556: LD_INT 1
72558: NEG
72559: PUSH
72560: LD_INT 1
72562: NEG
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 1
72570: PUSH
72571: LD_INT 1
72573: NEG
72574: PUSH
72575: EMPTY
72576: LIST
72577: LIST
72578: PUSH
72579: LD_INT 1
72581: NEG
72582: PUSH
72583: LD_INT 1
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: LIST
72594: LIST
72595: LIST
72596: LIST
72597: LIST
72598: LIST
72599: LIST
72600: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72601: LD_ADDR_VAR 0 38
72605: PUSH
72606: LD_INT 0
72608: PUSH
72609: LD_INT 0
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: PUSH
72616: LD_INT 0
72618: PUSH
72619: LD_INT 1
72621: NEG
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: PUSH
72627: LD_INT 1
72629: PUSH
72630: LD_INT 0
72632: PUSH
72633: EMPTY
72634: LIST
72635: LIST
72636: PUSH
72637: LD_INT 1
72639: PUSH
72640: LD_INT 1
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: PUSH
72647: LD_INT 0
72649: PUSH
72650: LD_INT 1
72652: PUSH
72653: EMPTY
72654: LIST
72655: LIST
72656: PUSH
72657: LD_INT 1
72659: NEG
72660: PUSH
72661: LD_INT 0
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: LD_INT 1
72670: NEG
72671: PUSH
72672: LD_INT 1
72674: NEG
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: PUSH
72680: LD_INT 2
72682: PUSH
72683: LD_INT 1
72685: PUSH
72686: EMPTY
72687: LIST
72688: LIST
72689: PUSH
72690: LD_INT 2
72692: NEG
72693: PUSH
72694: LD_INT 1
72696: NEG
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: LIST
72706: LIST
72707: LIST
72708: LIST
72709: LIST
72710: LIST
72711: LIST
72712: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72713: LD_ADDR_VAR 0 39
72717: PUSH
72718: LD_INT 0
72720: PUSH
72721: LD_INT 0
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: PUSH
72728: LD_INT 0
72730: PUSH
72731: LD_INT 1
72733: NEG
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 1
72741: PUSH
72742: LD_INT 0
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 1
72751: PUSH
72752: LD_INT 1
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: LD_INT 0
72761: PUSH
72762: LD_INT 1
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: PUSH
72769: LD_INT 1
72771: NEG
72772: PUSH
72773: LD_INT 0
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: PUSH
72780: LD_INT 1
72782: NEG
72783: PUSH
72784: LD_INT 1
72786: NEG
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: PUSH
72792: LD_INT 1
72794: NEG
72795: PUSH
72796: LD_INT 2
72798: NEG
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: LD_INT 1
72806: PUSH
72807: LD_INT 2
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: LIST
72824: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72825: LD_ADDR_VAR 0 40
72829: PUSH
72830: LD_INT 0
72832: PUSH
72833: LD_INT 0
72835: PUSH
72836: EMPTY
72837: LIST
72838: LIST
72839: PUSH
72840: LD_INT 0
72842: PUSH
72843: LD_INT 1
72845: NEG
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: LD_INT 1
72853: PUSH
72854: LD_INT 0
72856: PUSH
72857: EMPTY
72858: LIST
72859: LIST
72860: PUSH
72861: LD_INT 1
72863: PUSH
72864: LD_INT 1
72866: PUSH
72867: EMPTY
72868: LIST
72869: LIST
72870: PUSH
72871: LD_INT 0
72873: PUSH
72874: LD_INT 1
72876: PUSH
72877: EMPTY
72878: LIST
72879: LIST
72880: PUSH
72881: LD_INT 1
72883: NEG
72884: PUSH
72885: LD_INT 0
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: LD_INT 1
72894: NEG
72895: PUSH
72896: LD_INT 1
72898: NEG
72899: PUSH
72900: EMPTY
72901: LIST
72902: LIST
72903: PUSH
72904: LD_INT 1
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 1
72917: NEG
72918: PUSH
72919: LD_INT 1
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: LIST
72930: LIST
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72937: LD_ADDR_VAR 0 41
72941: PUSH
72942: LD_INT 0
72944: PUSH
72945: LD_INT 0
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: PUSH
72952: LD_INT 0
72954: PUSH
72955: LD_INT 1
72957: NEG
72958: PUSH
72959: EMPTY
72960: LIST
72961: LIST
72962: PUSH
72963: LD_INT 1
72965: PUSH
72966: LD_INT 0
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: LD_INT 1
72975: PUSH
72976: LD_INT 1
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: PUSH
72983: LD_INT 0
72985: PUSH
72986: LD_INT 1
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 1
72995: NEG
72996: PUSH
72997: LD_INT 0
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: PUSH
73004: LD_INT 1
73006: NEG
73007: PUSH
73008: LD_INT 1
73010: NEG
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: PUSH
73016: LD_INT 1
73018: NEG
73019: PUSH
73020: LD_INT 2
73022: NEG
73023: PUSH
73024: EMPTY
73025: LIST
73026: LIST
73027: PUSH
73028: LD_INT 1
73030: PUSH
73031: LD_INT 1
73033: NEG
73034: PUSH
73035: EMPTY
73036: LIST
73037: LIST
73038: PUSH
73039: LD_INT 2
73041: PUSH
73042: LD_INT 0
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 2
73051: PUSH
73052: LD_INT 1
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 2
73061: PUSH
73062: LD_INT 2
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 1
73071: PUSH
73072: LD_INT 2
73074: PUSH
73075: EMPTY
73076: LIST
73077: LIST
73078: PUSH
73079: LD_INT 1
73081: NEG
73082: PUSH
73083: LD_INT 1
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 2
73092: NEG
73093: PUSH
73094: LD_INT 0
73096: PUSH
73097: EMPTY
73098: LIST
73099: LIST
73100: PUSH
73101: LD_INT 2
73103: NEG
73104: PUSH
73105: LD_INT 1
73107: NEG
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: PUSH
73113: LD_INT 2
73115: NEG
73116: PUSH
73117: LD_INT 2
73119: NEG
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: PUSH
73125: LD_INT 2
73127: NEG
73128: PUSH
73129: LD_INT 3
73131: NEG
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PUSH
73137: LD_INT 2
73139: PUSH
73140: LD_INT 1
73142: NEG
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 3
73150: PUSH
73151: LD_INT 0
73153: PUSH
73154: EMPTY
73155: LIST
73156: LIST
73157: PUSH
73158: LD_INT 3
73160: PUSH
73161: LD_INT 1
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 3
73170: PUSH
73171: LD_INT 2
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 3
73180: PUSH
73181: LD_INT 3
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: LD_INT 2
73190: PUSH
73191: LD_INT 3
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: LD_INT 2
73200: NEG
73201: PUSH
73202: LD_INT 1
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: LD_INT 3
73211: NEG
73212: PUSH
73213: LD_INT 0
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: LD_INT 3
73222: NEG
73223: PUSH
73224: LD_INT 1
73226: NEG
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 3
73234: NEG
73235: PUSH
73236: LD_INT 2
73238: NEG
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 3
73246: NEG
73247: PUSH
73248: LD_INT 3
73250: NEG
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: LIST
73260: LIST
73261: LIST
73262: LIST
73263: LIST
73264: LIST
73265: LIST
73266: LIST
73267: LIST
73268: LIST
73269: LIST
73270: LIST
73271: LIST
73272: LIST
73273: LIST
73274: LIST
73275: LIST
73276: LIST
73277: LIST
73278: LIST
73279: LIST
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73287: LD_ADDR_VAR 0 42
73291: PUSH
73292: LD_INT 0
73294: PUSH
73295: LD_INT 0
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 0
73304: PUSH
73305: LD_INT 1
73307: NEG
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: LD_INT 1
73315: PUSH
73316: LD_INT 0
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 1
73325: PUSH
73326: LD_INT 1
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: PUSH
73333: LD_INT 0
73335: PUSH
73336: LD_INT 1
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: LD_INT 1
73345: NEG
73346: PUSH
73347: LD_INT 0
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 1
73356: NEG
73357: PUSH
73358: LD_INT 1
73360: NEG
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: LD_INT 1
73368: NEG
73369: PUSH
73370: LD_INT 2
73372: NEG
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: LD_INT 0
73380: PUSH
73381: LD_INT 2
73383: NEG
73384: PUSH
73385: EMPTY
73386: LIST
73387: LIST
73388: PUSH
73389: LD_INT 1
73391: PUSH
73392: LD_INT 1
73394: NEG
73395: PUSH
73396: EMPTY
73397: LIST
73398: LIST
73399: PUSH
73400: LD_INT 2
73402: PUSH
73403: LD_INT 1
73405: PUSH
73406: EMPTY
73407: LIST
73408: LIST
73409: PUSH
73410: LD_INT 2
73412: PUSH
73413: LD_INT 2
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: PUSH
73420: LD_INT 1
73422: PUSH
73423: LD_INT 2
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PUSH
73430: LD_INT 0
73432: PUSH
73433: LD_INT 2
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 1
73442: NEG
73443: PUSH
73444: LD_INT 1
73446: PUSH
73447: EMPTY
73448: LIST
73449: LIST
73450: PUSH
73451: LD_INT 2
73453: NEG
73454: PUSH
73455: LD_INT 1
73457: NEG
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 2
73465: NEG
73466: PUSH
73467: LD_INT 2
73469: NEG
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: PUSH
73475: LD_INT 2
73477: NEG
73478: PUSH
73479: LD_INT 3
73481: NEG
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: PUSH
73487: LD_INT 1
73489: NEG
73490: PUSH
73491: LD_INT 3
73493: NEG
73494: PUSH
73495: EMPTY
73496: LIST
73497: LIST
73498: PUSH
73499: LD_INT 0
73501: PUSH
73502: LD_INT 3
73504: NEG
73505: PUSH
73506: EMPTY
73507: LIST
73508: LIST
73509: PUSH
73510: LD_INT 1
73512: PUSH
73513: LD_INT 2
73515: NEG
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: PUSH
73521: LD_INT 3
73523: PUSH
73524: LD_INT 2
73526: PUSH
73527: EMPTY
73528: LIST
73529: LIST
73530: PUSH
73531: LD_INT 3
73533: PUSH
73534: LD_INT 3
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: PUSH
73541: LD_INT 2
73543: PUSH
73544: LD_INT 3
73546: PUSH
73547: EMPTY
73548: LIST
73549: LIST
73550: PUSH
73551: LD_INT 1
73553: PUSH
73554: LD_INT 3
73556: PUSH
73557: EMPTY
73558: LIST
73559: LIST
73560: PUSH
73561: LD_INT 0
73563: PUSH
73564: LD_INT 3
73566: PUSH
73567: EMPTY
73568: LIST
73569: LIST
73570: PUSH
73571: LD_INT 1
73573: NEG
73574: PUSH
73575: LD_INT 2
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 3
73584: NEG
73585: PUSH
73586: LD_INT 2
73588: NEG
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 3
73596: NEG
73597: PUSH
73598: LD_INT 3
73600: NEG
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: LIST
73620: LIST
73621: LIST
73622: LIST
73623: LIST
73624: LIST
73625: LIST
73626: LIST
73627: LIST
73628: LIST
73629: LIST
73630: LIST
73631: LIST
73632: LIST
73633: LIST
73634: LIST
73635: LIST
73636: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73637: LD_ADDR_VAR 0 43
73641: PUSH
73642: LD_INT 0
73644: PUSH
73645: LD_INT 0
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 0
73654: PUSH
73655: LD_INT 1
73657: NEG
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: PUSH
73663: LD_INT 1
73665: PUSH
73666: LD_INT 0
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PUSH
73673: LD_INT 1
73675: PUSH
73676: LD_INT 1
73678: PUSH
73679: EMPTY
73680: LIST
73681: LIST
73682: PUSH
73683: LD_INT 0
73685: PUSH
73686: LD_INT 1
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 1
73695: NEG
73696: PUSH
73697: LD_INT 0
73699: PUSH
73700: EMPTY
73701: LIST
73702: LIST
73703: PUSH
73704: LD_INT 1
73706: NEG
73707: PUSH
73708: LD_INT 1
73710: NEG
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: PUSH
73716: LD_INT 1
73718: NEG
73719: PUSH
73720: LD_INT 2
73722: NEG
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: PUSH
73728: LD_INT 0
73730: PUSH
73731: LD_INT 2
73733: NEG
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: PUSH
73739: LD_INT 1
73741: PUSH
73742: LD_INT 1
73744: NEG
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: LD_INT 2
73752: PUSH
73753: LD_INT 0
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: PUSH
73760: LD_INT 2
73762: PUSH
73763: LD_INT 1
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: PUSH
73770: LD_INT 1
73772: PUSH
73773: LD_INT 2
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: PUSH
73780: LD_INT 0
73782: PUSH
73783: LD_INT 2
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 1
73792: NEG
73793: PUSH
73794: LD_INT 1
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: PUSH
73801: LD_INT 2
73803: NEG
73804: PUSH
73805: LD_INT 0
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 2
73814: NEG
73815: PUSH
73816: LD_INT 1
73818: NEG
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 1
73826: NEG
73827: PUSH
73828: LD_INT 3
73830: NEG
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: LD_INT 0
73838: PUSH
73839: LD_INT 3
73841: NEG
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 1
73849: PUSH
73850: LD_INT 2
73852: NEG
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PUSH
73858: LD_INT 2
73860: PUSH
73861: LD_INT 1
73863: NEG
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 3
73871: PUSH
73872: LD_INT 0
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: PUSH
73879: LD_INT 3
73881: PUSH
73882: LD_INT 1
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: LD_INT 1
73891: PUSH
73892: LD_INT 3
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 0
73901: PUSH
73902: LD_INT 3
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: LD_INT 1
73911: NEG
73912: PUSH
73913: LD_INT 2
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: PUSH
73920: LD_INT 2
73922: NEG
73923: PUSH
73924: LD_INT 1
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: LD_INT 3
73933: NEG
73934: PUSH
73935: LD_INT 0
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: LD_INT 3
73944: NEG
73945: PUSH
73946: LD_INT 1
73948: NEG
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: LIST
73958: LIST
73959: LIST
73960: LIST
73961: LIST
73962: LIST
73963: LIST
73964: LIST
73965: LIST
73966: LIST
73967: LIST
73968: LIST
73969: LIST
73970: LIST
73971: LIST
73972: LIST
73973: LIST
73974: LIST
73975: LIST
73976: LIST
73977: LIST
73978: LIST
73979: LIST
73980: LIST
73981: LIST
73982: LIST
73983: LIST
73984: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73985: LD_ADDR_VAR 0 44
73989: PUSH
73990: LD_INT 0
73992: PUSH
73993: LD_INT 0
73995: PUSH
73996: EMPTY
73997: LIST
73998: LIST
73999: PUSH
74000: LD_INT 0
74002: PUSH
74003: LD_INT 1
74005: NEG
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: LD_INT 1
74013: PUSH
74014: LD_INT 0
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: LD_INT 1
74023: PUSH
74024: LD_INT 1
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 0
74033: PUSH
74034: LD_INT 1
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 1
74043: NEG
74044: PUSH
74045: LD_INT 0
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PUSH
74052: LD_INT 1
74054: NEG
74055: PUSH
74056: LD_INT 1
74058: NEG
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 1
74066: NEG
74067: PUSH
74068: LD_INT 2
74070: NEG
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 1
74078: PUSH
74079: LD_INT 1
74081: NEG
74082: PUSH
74083: EMPTY
74084: LIST
74085: LIST
74086: PUSH
74087: LD_INT 2
74089: PUSH
74090: LD_INT 0
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: PUSH
74097: LD_INT 2
74099: PUSH
74100: LD_INT 1
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 2
74109: PUSH
74110: LD_INT 2
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: PUSH
74117: LD_INT 1
74119: PUSH
74120: LD_INT 2
74122: PUSH
74123: EMPTY
74124: LIST
74125: LIST
74126: PUSH
74127: LD_INT 1
74129: NEG
74130: PUSH
74131: LD_INT 1
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 2
74140: NEG
74141: PUSH
74142: LD_INT 0
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 2
74151: NEG
74152: PUSH
74153: LD_INT 1
74155: NEG
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: LD_INT 2
74163: NEG
74164: PUSH
74165: LD_INT 2
74167: NEG
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PUSH
74173: LD_INT 2
74175: NEG
74176: PUSH
74177: LD_INT 3
74179: NEG
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: PUSH
74185: LD_INT 2
74187: PUSH
74188: LD_INT 1
74190: NEG
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 3
74198: PUSH
74199: LD_INT 0
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: PUSH
74206: LD_INT 3
74208: PUSH
74209: LD_INT 1
74211: PUSH
74212: EMPTY
74213: LIST
74214: LIST
74215: PUSH
74216: LD_INT 3
74218: PUSH
74219: LD_INT 2
74221: PUSH
74222: EMPTY
74223: LIST
74224: LIST
74225: PUSH
74226: LD_INT 3
74228: PUSH
74229: LD_INT 3
74231: PUSH
74232: EMPTY
74233: LIST
74234: LIST
74235: PUSH
74236: LD_INT 2
74238: PUSH
74239: LD_INT 3
74241: PUSH
74242: EMPTY
74243: LIST
74244: LIST
74245: PUSH
74246: LD_INT 2
74248: NEG
74249: PUSH
74250: LD_INT 1
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: PUSH
74257: LD_INT 3
74259: NEG
74260: PUSH
74261: LD_INT 0
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: PUSH
74268: LD_INT 3
74270: NEG
74271: PUSH
74272: LD_INT 1
74274: NEG
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 3
74282: NEG
74283: PUSH
74284: LD_INT 2
74286: NEG
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 3
74294: NEG
74295: PUSH
74296: LD_INT 3
74298: NEG
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: EMPTY
74305: LIST
74306: LIST
74307: LIST
74308: LIST
74309: LIST
74310: LIST
74311: LIST
74312: LIST
74313: LIST
74314: LIST
74315: LIST
74316: LIST
74317: LIST
74318: LIST
74319: LIST
74320: LIST
74321: LIST
74322: LIST
74323: LIST
74324: LIST
74325: LIST
74326: LIST
74327: LIST
74328: LIST
74329: LIST
74330: LIST
74331: LIST
74332: LIST
74333: LIST
74334: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74335: LD_ADDR_VAR 0 45
74339: PUSH
74340: LD_INT 0
74342: PUSH
74343: LD_INT 0
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: PUSH
74350: LD_INT 0
74352: PUSH
74353: LD_INT 1
74355: NEG
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: PUSH
74361: LD_INT 1
74363: PUSH
74364: LD_INT 0
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 1
74373: PUSH
74374: LD_INT 1
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: PUSH
74381: LD_INT 0
74383: PUSH
74384: LD_INT 1
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: PUSH
74391: LD_INT 1
74393: NEG
74394: PUSH
74395: LD_INT 0
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PUSH
74402: LD_INT 1
74404: NEG
74405: PUSH
74406: LD_INT 1
74408: NEG
74409: PUSH
74410: EMPTY
74411: LIST
74412: LIST
74413: PUSH
74414: LD_INT 1
74416: NEG
74417: PUSH
74418: LD_INT 2
74420: NEG
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: PUSH
74426: LD_INT 0
74428: PUSH
74429: LD_INT 2
74431: NEG
74432: PUSH
74433: EMPTY
74434: LIST
74435: LIST
74436: PUSH
74437: LD_INT 1
74439: PUSH
74440: LD_INT 1
74442: NEG
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PUSH
74448: LD_INT 2
74450: PUSH
74451: LD_INT 1
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: PUSH
74458: LD_INT 2
74460: PUSH
74461: LD_INT 2
74463: PUSH
74464: EMPTY
74465: LIST
74466: LIST
74467: PUSH
74468: LD_INT 1
74470: PUSH
74471: LD_INT 2
74473: PUSH
74474: EMPTY
74475: LIST
74476: LIST
74477: PUSH
74478: LD_INT 0
74480: PUSH
74481: LD_INT 2
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 1
74490: NEG
74491: PUSH
74492: LD_INT 1
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 2
74501: NEG
74502: PUSH
74503: LD_INT 1
74505: NEG
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: LD_INT 2
74513: NEG
74514: PUSH
74515: LD_INT 2
74517: NEG
74518: PUSH
74519: EMPTY
74520: LIST
74521: LIST
74522: PUSH
74523: LD_INT 2
74525: NEG
74526: PUSH
74527: LD_INT 3
74529: NEG
74530: PUSH
74531: EMPTY
74532: LIST
74533: LIST
74534: PUSH
74535: LD_INT 1
74537: NEG
74538: PUSH
74539: LD_INT 3
74541: NEG
74542: PUSH
74543: EMPTY
74544: LIST
74545: LIST
74546: PUSH
74547: LD_INT 0
74549: PUSH
74550: LD_INT 3
74552: NEG
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: LD_INT 1
74560: PUSH
74561: LD_INT 2
74563: NEG
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: LD_INT 3
74571: PUSH
74572: LD_INT 2
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: PUSH
74579: LD_INT 3
74581: PUSH
74582: LD_INT 3
74584: PUSH
74585: EMPTY
74586: LIST
74587: LIST
74588: PUSH
74589: LD_INT 2
74591: PUSH
74592: LD_INT 3
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: PUSH
74599: LD_INT 1
74601: PUSH
74602: LD_INT 3
74604: PUSH
74605: EMPTY
74606: LIST
74607: LIST
74608: PUSH
74609: LD_INT 0
74611: PUSH
74612: LD_INT 3
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: PUSH
74619: LD_INT 1
74621: NEG
74622: PUSH
74623: LD_INT 2
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: PUSH
74630: LD_INT 3
74632: NEG
74633: PUSH
74634: LD_INT 2
74636: NEG
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: PUSH
74642: LD_INT 3
74644: NEG
74645: PUSH
74646: LD_INT 3
74648: NEG
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: EMPTY
74655: LIST
74656: LIST
74657: LIST
74658: LIST
74659: LIST
74660: LIST
74661: LIST
74662: LIST
74663: LIST
74664: LIST
74665: LIST
74666: LIST
74667: LIST
74668: LIST
74669: LIST
74670: LIST
74671: LIST
74672: LIST
74673: LIST
74674: LIST
74675: LIST
74676: LIST
74677: LIST
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: LIST
74683: LIST
74684: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74685: LD_ADDR_VAR 0 46
74689: PUSH
74690: LD_INT 0
74692: PUSH
74693: LD_INT 0
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: PUSH
74700: LD_INT 0
74702: PUSH
74703: LD_INT 1
74705: NEG
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: LD_INT 1
74713: PUSH
74714: LD_INT 0
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PUSH
74721: LD_INT 1
74723: PUSH
74724: LD_INT 1
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: PUSH
74731: LD_INT 0
74733: PUSH
74734: LD_INT 1
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 1
74743: NEG
74744: PUSH
74745: LD_INT 0
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PUSH
74752: LD_INT 1
74754: NEG
74755: PUSH
74756: LD_INT 1
74758: NEG
74759: PUSH
74760: EMPTY
74761: LIST
74762: LIST
74763: PUSH
74764: LD_INT 1
74766: NEG
74767: PUSH
74768: LD_INT 2
74770: NEG
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 0
74778: PUSH
74779: LD_INT 2
74781: NEG
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: PUSH
74787: LD_INT 1
74789: PUSH
74790: LD_INT 1
74792: NEG
74793: PUSH
74794: EMPTY
74795: LIST
74796: LIST
74797: PUSH
74798: LD_INT 2
74800: PUSH
74801: LD_INT 0
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: PUSH
74808: LD_INT 2
74810: PUSH
74811: LD_INT 1
74813: PUSH
74814: EMPTY
74815: LIST
74816: LIST
74817: PUSH
74818: LD_INT 1
74820: PUSH
74821: LD_INT 2
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 0
74830: PUSH
74831: LD_INT 2
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PUSH
74838: LD_INT 1
74840: NEG
74841: PUSH
74842: LD_INT 1
74844: PUSH
74845: EMPTY
74846: LIST
74847: LIST
74848: PUSH
74849: LD_INT 2
74851: NEG
74852: PUSH
74853: LD_INT 0
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: PUSH
74860: LD_INT 2
74862: NEG
74863: PUSH
74864: LD_INT 1
74866: NEG
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 1
74874: NEG
74875: PUSH
74876: LD_INT 3
74878: NEG
74879: PUSH
74880: EMPTY
74881: LIST
74882: LIST
74883: PUSH
74884: LD_INT 0
74886: PUSH
74887: LD_INT 3
74889: NEG
74890: PUSH
74891: EMPTY
74892: LIST
74893: LIST
74894: PUSH
74895: LD_INT 1
74897: PUSH
74898: LD_INT 2
74900: NEG
74901: PUSH
74902: EMPTY
74903: LIST
74904: LIST
74905: PUSH
74906: LD_INT 2
74908: PUSH
74909: LD_INT 1
74911: NEG
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 3
74919: PUSH
74920: LD_INT 0
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 3
74929: PUSH
74930: LD_INT 1
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: LD_INT 1
74939: PUSH
74940: LD_INT 3
74942: PUSH
74943: EMPTY
74944: LIST
74945: LIST
74946: PUSH
74947: LD_INT 0
74949: PUSH
74950: LD_INT 3
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: PUSH
74957: LD_INT 1
74959: NEG
74960: PUSH
74961: LD_INT 2
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: PUSH
74968: LD_INT 2
74970: NEG
74971: PUSH
74972: LD_INT 1
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: PUSH
74979: LD_INT 3
74981: NEG
74982: PUSH
74983: LD_INT 0
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: LD_INT 3
74992: NEG
74993: PUSH
74994: LD_INT 1
74996: NEG
74997: PUSH
74998: EMPTY
74999: LIST
75000: LIST
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: LIST
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: LIST
75011: LIST
75012: LIST
75013: LIST
75014: LIST
75015: LIST
75016: LIST
75017: LIST
75018: LIST
75019: LIST
75020: LIST
75021: LIST
75022: LIST
75023: LIST
75024: LIST
75025: LIST
75026: LIST
75027: LIST
75028: LIST
75029: LIST
75030: LIST
75031: LIST
75032: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75033: LD_ADDR_VAR 0 47
75037: PUSH
75038: LD_INT 0
75040: PUSH
75041: LD_INT 0
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: PUSH
75048: LD_INT 0
75050: PUSH
75051: LD_INT 1
75053: NEG
75054: PUSH
75055: EMPTY
75056: LIST
75057: LIST
75058: PUSH
75059: LD_INT 1
75061: PUSH
75062: LD_INT 0
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PUSH
75069: LD_INT 1
75071: PUSH
75072: LD_INT 1
75074: PUSH
75075: EMPTY
75076: LIST
75077: LIST
75078: PUSH
75079: LD_INT 0
75081: PUSH
75082: LD_INT 1
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: PUSH
75089: LD_INT 1
75091: NEG
75092: PUSH
75093: LD_INT 0
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: LD_INT 1
75102: NEG
75103: PUSH
75104: LD_INT 1
75106: NEG
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: PUSH
75112: LD_INT 1
75114: NEG
75115: PUSH
75116: LD_INT 2
75118: NEG
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: LD_INT 0
75126: PUSH
75127: LD_INT 2
75129: NEG
75130: PUSH
75131: EMPTY
75132: LIST
75133: LIST
75134: PUSH
75135: LD_INT 1
75137: PUSH
75138: LD_INT 1
75140: NEG
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 2
75148: NEG
75149: PUSH
75150: LD_INT 1
75152: NEG
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: LD_INT 2
75160: NEG
75161: PUSH
75162: LD_INT 2
75164: NEG
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: LIST
75174: LIST
75175: LIST
75176: LIST
75177: LIST
75178: LIST
75179: LIST
75180: LIST
75181: LIST
75182: LIST
75183: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75184: LD_ADDR_VAR 0 48
75188: PUSH
75189: LD_INT 0
75191: PUSH
75192: LD_INT 0
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 0
75201: PUSH
75202: LD_INT 1
75204: NEG
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: LD_INT 1
75212: PUSH
75213: LD_INT 0
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: LD_INT 1
75222: PUSH
75223: LD_INT 1
75225: PUSH
75226: EMPTY
75227: LIST
75228: LIST
75229: PUSH
75230: LD_INT 0
75232: PUSH
75233: LD_INT 1
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 1
75242: NEG
75243: PUSH
75244: LD_INT 0
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: PUSH
75251: LD_INT 1
75253: NEG
75254: PUSH
75255: LD_INT 1
75257: NEG
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: PUSH
75263: LD_INT 1
75265: NEG
75266: PUSH
75267: LD_INT 2
75269: NEG
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: PUSH
75275: LD_INT 0
75277: PUSH
75278: LD_INT 2
75280: NEG
75281: PUSH
75282: EMPTY
75283: LIST
75284: LIST
75285: PUSH
75286: LD_INT 1
75288: PUSH
75289: LD_INT 1
75291: NEG
75292: PUSH
75293: EMPTY
75294: LIST
75295: LIST
75296: PUSH
75297: LD_INT 2
75299: PUSH
75300: LD_INT 0
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: PUSH
75307: LD_INT 2
75309: PUSH
75310: LD_INT 1
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: PUSH
75317: EMPTY
75318: LIST
75319: LIST
75320: LIST
75321: LIST
75322: LIST
75323: LIST
75324: LIST
75325: LIST
75326: LIST
75327: LIST
75328: LIST
75329: LIST
75330: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75331: LD_ADDR_VAR 0 49
75335: PUSH
75336: LD_INT 0
75338: PUSH
75339: LD_INT 0
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: LD_INT 0
75348: PUSH
75349: LD_INT 1
75351: NEG
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: PUSH
75357: LD_INT 1
75359: PUSH
75360: LD_INT 0
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: LD_INT 1
75369: PUSH
75370: LD_INT 1
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: PUSH
75377: LD_INT 0
75379: PUSH
75380: LD_INT 1
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: PUSH
75387: LD_INT 1
75389: NEG
75390: PUSH
75391: LD_INT 0
75393: PUSH
75394: EMPTY
75395: LIST
75396: LIST
75397: PUSH
75398: LD_INT 1
75400: NEG
75401: PUSH
75402: LD_INT 1
75404: NEG
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 1
75412: PUSH
75413: LD_INT 1
75415: NEG
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: PUSH
75421: LD_INT 2
75423: PUSH
75424: LD_INT 0
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 2
75433: PUSH
75434: LD_INT 1
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: PUSH
75441: LD_INT 2
75443: PUSH
75444: LD_INT 2
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 1
75453: PUSH
75454: LD_INT 2
75456: PUSH
75457: EMPTY
75458: LIST
75459: LIST
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: LIST
75465: LIST
75466: LIST
75467: LIST
75468: LIST
75469: LIST
75470: LIST
75471: LIST
75472: LIST
75473: LIST
75474: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75475: LD_ADDR_VAR 0 50
75479: PUSH
75480: LD_INT 0
75482: PUSH
75483: LD_INT 0
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: PUSH
75490: LD_INT 0
75492: PUSH
75493: LD_INT 1
75495: NEG
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: PUSH
75501: LD_INT 1
75503: PUSH
75504: LD_INT 0
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: PUSH
75511: LD_INT 1
75513: PUSH
75514: LD_INT 1
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: LD_INT 0
75523: PUSH
75524: LD_INT 1
75526: PUSH
75527: EMPTY
75528: LIST
75529: LIST
75530: PUSH
75531: LD_INT 1
75533: NEG
75534: PUSH
75535: LD_INT 0
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 1
75544: NEG
75545: PUSH
75546: LD_INT 1
75548: NEG
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: LD_INT 2
75556: PUSH
75557: LD_INT 1
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 2
75566: PUSH
75567: LD_INT 2
75569: PUSH
75570: EMPTY
75571: LIST
75572: LIST
75573: PUSH
75574: LD_INT 1
75576: PUSH
75577: LD_INT 2
75579: PUSH
75580: EMPTY
75581: LIST
75582: LIST
75583: PUSH
75584: LD_INT 0
75586: PUSH
75587: LD_INT 2
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 1
75596: NEG
75597: PUSH
75598: LD_INT 1
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PUSH
75605: EMPTY
75606: LIST
75607: LIST
75608: LIST
75609: LIST
75610: LIST
75611: LIST
75612: LIST
75613: LIST
75614: LIST
75615: LIST
75616: LIST
75617: LIST
75618: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75619: LD_ADDR_VAR 0 51
75623: PUSH
75624: LD_INT 0
75626: PUSH
75627: LD_INT 0
75629: PUSH
75630: EMPTY
75631: LIST
75632: LIST
75633: PUSH
75634: LD_INT 0
75636: PUSH
75637: LD_INT 1
75639: NEG
75640: PUSH
75641: EMPTY
75642: LIST
75643: LIST
75644: PUSH
75645: LD_INT 1
75647: PUSH
75648: LD_INT 0
75650: PUSH
75651: EMPTY
75652: LIST
75653: LIST
75654: PUSH
75655: LD_INT 1
75657: PUSH
75658: LD_INT 1
75660: PUSH
75661: EMPTY
75662: LIST
75663: LIST
75664: PUSH
75665: LD_INT 0
75667: PUSH
75668: LD_INT 1
75670: PUSH
75671: EMPTY
75672: LIST
75673: LIST
75674: PUSH
75675: LD_INT 1
75677: NEG
75678: PUSH
75679: LD_INT 0
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: LD_INT 1
75688: NEG
75689: PUSH
75690: LD_INT 1
75692: NEG
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: PUSH
75698: LD_INT 1
75700: PUSH
75701: LD_INT 2
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 0
75710: PUSH
75711: LD_INT 2
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: PUSH
75718: LD_INT 1
75720: NEG
75721: PUSH
75722: LD_INT 1
75724: PUSH
75725: EMPTY
75726: LIST
75727: LIST
75728: PUSH
75729: LD_INT 2
75731: NEG
75732: PUSH
75733: LD_INT 0
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 2
75742: NEG
75743: PUSH
75744: LD_INT 1
75746: NEG
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: EMPTY
75753: LIST
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: LIST
75759: LIST
75760: LIST
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75766: LD_ADDR_VAR 0 52
75770: PUSH
75771: LD_INT 0
75773: PUSH
75774: LD_INT 0
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: PUSH
75781: LD_INT 0
75783: PUSH
75784: LD_INT 1
75786: NEG
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: LD_INT 1
75794: PUSH
75795: LD_INT 0
75797: PUSH
75798: EMPTY
75799: LIST
75800: LIST
75801: PUSH
75802: LD_INT 1
75804: PUSH
75805: LD_INT 1
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: PUSH
75812: LD_INT 0
75814: PUSH
75815: LD_INT 1
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: PUSH
75822: LD_INT 1
75824: NEG
75825: PUSH
75826: LD_INT 0
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: PUSH
75833: LD_INT 1
75835: NEG
75836: PUSH
75837: LD_INT 1
75839: NEG
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: PUSH
75845: LD_INT 1
75847: NEG
75848: PUSH
75849: LD_INT 2
75851: NEG
75852: PUSH
75853: EMPTY
75854: LIST
75855: LIST
75856: PUSH
75857: LD_INT 1
75859: NEG
75860: PUSH
75861: LD_INT 1
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: PUSH
75868: LD_INT 2
75870: NEG
75871: PUSH
75872: LD_INT 0
75874: PUSH
75875: EMPTY
75876: LIST
75877: LIST
75878: PUSH
75879: LD_INT 2
75881: NEG
75882: PUSH
75883: LD_INT 1
75885: NEG
75886: PUSH
75887: EMPTY
75888: LIST
75889: LIST
75890: PUSH
75891: LD_INT 2
75893: NEG
75894: PUSH
75895: LD_INT 2
75897: NEG
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: LIST
75907: LIST
75908: LIST
75909: LIST
75910: LIST
75911: LIST
75912: LIST
75913: LIST
75914: LIST
75915: LIST
75916: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75917: LD_ADDR_VAR 0 53
75921: PUSH
75922: LD_INT 0
75924: PUSH
75925: LD_INT 0
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 0
75934: PUSH
75935: LD_INT 1
75937: NEG
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: LD_INT 1
75945: PUSH
75946: LD_INT 0
75948: PUSH
75949: EMPTY
75950: LIST
75951: LIST
75952: PUSH
75953: LD_INT 1
75955: PUSH
75956: LD_INT 1
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: PUSH
75963: LD_INT 0
75965: PUSH
75966: LD_INT 1
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: PUSH
75973: LD_INT 1
75975: NEG
75976: PUSH
75977: LD_INT 0
75979: PUSH
75980: EMPTY
75981: LIST
75982: LIST
75983: PUSH
75984: LD_INT 1
75986: NEG
75987: PUSH
75988: LD_INT 1
75990: NEG
75991: PUSH
75992: EMPTY
75993: LIST
75994: LIST
75995: PUSH
75996: LD_INT 1
75998: NEG
75999: PUSH
76000: LD_INT 2
76002: NEG
76003: PUSH
76004: EMPTY
76005: LIST
76006: LIST
76007: PUSH
76008: LD_INT 0
76010: PUSH
76011: LD_INT 2
76013: NEG
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: LD_INT 1
76021: PUSH
76022: LD_INT 1
76024: NEG
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: PUSH
76030: LD_INT 2
76032: PUSH
76033: LD_INT 0
76035: PUSH
76036: EMPTY
76037: LIST
76038: LIST
76039: PUSH
76040: LD_INT 2
76042: PUSH
76043: LD_INT 1
76045: PUSH
76046: EMPTY
76047: LIST
76048: LIST
76049: PUSH
76050: LD_INT 2
76052: PUSH
76053: LD_INT 2
76055: PUSH
76056: EMPTY
76057: LIST
76058: LIST
76059: PUSH
76060: LD_INT 1
76062: PUSH
76063: LD_INT 2
76065: PUSH
76066: EMPTY
76067: LIST
76068: LIST
76069: PUSH
76070: LD_INT 0
76072: PUSH
76073: LD_INT 2
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: PUSH
76080: LD_INT 1
76082: NEG
76083: PUSH
76084: LD_INT 1
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: PUSH
76091: LD_INT 2
76093: NEG
76094: PUSH
76095: LD_INT 0
76097: PUSH
76098: EMPTY
76099: LIST
76100: LIST
76101: PUSH
76102: LD_INT 2
76104: NEG
76105: PUSH
76106: LD_INT 1
76108: NEG
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: PUSH
76114: LD_INT 2
76116: NEG
76117: PUSH
76118: LD_INT 2
76120: NEG
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: LIST
76130: LIST
76131: LIST
76132: LIST
76133: LIST
76134: LIST
76135: LIST
76136: LIST
76137: LIST
76138: LIST
76139: LIST
76140: LIST
76141: LIST
76142: LIST
76143: LIST
76144: LIST
76145: LIST
76146: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76147: LD_ADDR_VAR 0 54
76151: PUSH
76152: LD_INT 0
76154: PUSH
76155: LD_INT 0
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: LD_INT 0
76164: PUSH
76165: LD_INT 1
76167: NEG
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: LD_INT 1
76175: PUSH
76176: LD_INT 0
76178: PUSH
76179: EMPTY
76180: LIST
76181: LIST
76182: PUSH
76183: LD_INT 1
76185: PUSH
76186: LD_INT 1
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: PUSH
76193: LD_INT 0
76195: PUSH
76196: LD_INT 1
76198: PUSH
76199: EMPTY
76200: LIST
76201: LIST
76202: PUSH
76203: LD_INT 1
76205: NEG
76206: PUSH
76207: LD_INT 0
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: LD_INT 1
76216: NEG
76217: PUSH
76218: LD_INT 1
76220: NEG
76221: PUSH
76222: EMPTY
76223: LIST
76224: LIST
76225: PUSH
76226: LD_INT 1
76228: NEG
76229: PUSH
76230: LD_INT 2
76232: NEG
76233: PUSH
76234: EMPTY
76235: LIST
76236: LIST
76237: PUSH
76238: LD_INT 0
76240: PUSH
76241: LD_INT 2
76243: NEG
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: PUSH
76249: LD_INT 1
76251: PUSH
76252: LD_INT 1
76254: NEG
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PUSH
76260: LD_INT 2
76262: PUSH
76263: LD_INT 0
76265: PUSH
76266: EMPTY
76267: LIST
76268: LIST
76269: PUSH
76270: LD_INT 2
76272: PUSH
76273: LD_INT 1
76275: PUSH
76276: EMPTY
76277: LIST
76278: LIST
76279: PUSH
76280: LD_INT 2
76282: PUSH
76283: LD_INT 2
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: PUSH
76290: LD_INT 1
76292: PUSH
76293: LD_INT 2
76295: PUSH
76296: EMPTY
76297: LIST
76298: LIST
76299: PUSH
76300: LD_INT 0
76302: PUSH
76303: LD_INT 2
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: PUSH
76310: LD_INT 1
76312: NEG
76313: PUSH
76314: LD_INT 1
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PUSH
76321: LD_INT 2
76323: NEG
76324: PUSH
76325: LD_INT 0
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: PUSH
76332: LD_INT 2
76334: NEG
76335: PUSH
76336: LD_INT 1
76338: NEG
76339: PUSH
76340: EMPTY
76341: LIST
76342: LIST
76343: PUSH
76344: LD_INT 2
76346: NEG
76347: PUSH
76348: LD_INT 2
76350: NEG
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: LIST
76360: LIST
76361: LIST
76362: LIST
76363: LIST
76364: LIST
76365: LIST
76366: LIST
76367: LIST
76368: LIST
76369: LIST
76370: LIST
76371: LIST
76372: LIST
76373: LIST
76374: LIST
76375: LIST
76376: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76377: LD_ADDR_VAR 0 55
76381: PUSH
76382: LD_INT 0
76384: PUSH
76385: LD_INT 0
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 0
76394: PUSH
76395: LD_INT 1
76397: NEG
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 1
76405: PUSH
76406: LD_INT 0
76408: PUSH
76409: EMPTY
76410: LIST
76411: LIST
76412: PUSH
76413: LD_INT 1
76415: PUSH
76416: LD_INT 1
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: LD_INT 0
76425: PUSH
76426: LD_INT 1
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: LD_INT 1
76435: NEG
76436: PUSH
76437: LD_INT 0
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: PUSH
76444: LD_INT 1
76446: NEG
76447: PUSH
76448: LD_INT 1
76450: NEG
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: PUSH
76456: LD_INT 1
76458: NEG
76459: PUSH
76460: LD_INT 2
76462: NEG
76463: PUSH
76464: EMPTY
76465: LIST
76466: LIST
76467: PUSH
76468: LD_INT 0
76470: PUSH
76471: LD_INT 2
76473: NEG
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: PUSH
76479: LD_INT 1
76481: PUSH
76482: LD_INT 1
76484: NEG
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: LD_INT 2
76492: PUSH
76493: LD_INT 0
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: PUSH
76500: LD_INT 2
76502: PUSH
76503: LD_INT 1
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: PUSH
76510: LD_INT 2
76512: PUSH
76513: LD_INT 2
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 1
76522: PUSH
76523: LD_INT 2
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: LD_INT 0
76532: PUSH
76533: LD_INT 2
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: LD_INT 1
76542: NEG
76543: PUSH
76544: LD_INT 1
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: PUSH
76551: LD_INT 2
76553: NEG
76554: PUSH
76555: LD_INT 0
76557: PUSH
76558: EMPTY
76559: LIST
76560: LIST
76561: PUSH
76562: LD_INT 2
76564: NEG
76565: PUSH
76566: LD_INT 1
76568: NEG
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: PUSH
76574: LD_INT 2
76576: NEG
76577: PUSH
76578: LD_INT 2
76580: NEG
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: LIST
76590: LIST
76591: LIST
76592: LIST
76593: LIST
76594: LIST
76595: LIST
76596: LIST
76597: LIST
76598: LIST
76599: LIST
76600: LIST
76601: LIST
76602: LIST
76603: LIST
76604: LIST
76605: LIST
76606: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76607: LD_ADDR_VAR 0 56
76611: PUSH
76612: LD_INT 0
76614: PUSH
76615: LD_INT 0
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 0
76624: PUSH
76625: LD_INT 1
76627: NEG
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 1
76635: PUSH
76636: LD_INT 0
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: PUSH
76643: LD_INT 1
76645: PUSH
76646: LD_INT 1
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: PUSH
76653: LD_INT 0
76655: PUSH
76656: LD_INT 1
76658: PUSH
76659: EMPTY
76660: LIST
76661: LIST
76662: PUSH
76663: LD_INT 1
76665: NEG
76666: PUSH
76667: LD_INT 0
76669: PUSH
76670: EMPTY
76671: LIST
76672: LIST
76673: PUSH
76674: LD_INT 1
76676: NEG
76677: PUSH
76678: LD_INT 1
76680: NEG
76681: PUSH
76682: EMPTY
76683: LIST
76684: LIST
76685: PUSH
76686: LD_INT 1
76688: NEG
76689: PUSH
76690: LD_INT 2
76692: NEG
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PUSH
76698: LD_INT 0
76700: PUSH
76701: LD_INT 2
76703: NEG
76704: PUSH
76705: EMPTY
76706: LIST
76707: LIST
76708: PUSH
76709: LD_INT 1
76711: PUSH
76712: LD_INT 1
76714: NEG
76715: PUSH
76716: EMPTY
76717: LIST
76718: LIST
76719: PUSH
76720: LD_INT 2
76722: PUSH
76723: LD_INT 0
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: PUSH
76730: LD_INT 2
76732: PUSH
76733: LD_INT 1
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: PUSH
76740: LD_INT 2
76742: PUSH
76743: LD_INT 2
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: PUSH
76750: LD_INT 1
76752: PUSH
76753: LD_INT 2
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: PUSH
76760: LD_INT 0
76762: PUSH
76763: LD_INT 2
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: PUSH
76770: LD_INT 1
76772: NEG
76773: PUSH
76774: LD_INT 1
76776: PUSH
76777: EMPTY
76778: LIST
76779: LIST
76780: PUSH
76781: LD_INT 2
76783: NEG
76784: PUSH
76785: LD_INT 0
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 2
76794: NEG
76795: PUSH
76796: LD_INT 1
76798: NEG
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: PUSH
76804: LD_INT 2
76806: NEG
76807: PUSH
76808: LD_INT 2
76810: NEG
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: LIST
76820: LIST
76821: LIST
76822: LIST
76823: LIST
76824: LIST
76825: LIST
76826: LIST
76827: LIST
76828: LIST
76829: LIST
76830: LIST
76831: LIST
76832: LIST
76833: LIST
76834: LIST
76835: LIST
76836: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76837: LD_ADDR_VAR 0 57
76841: PUSH
76842: LD_INT 0
76844: PUSH
76845: LD_INT 0
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 0
76854: PUSH
76855: LD_INT 1
76857: NEG
76858: PUSH
76859: EMPTY
76860: LIST
76861: LIST
76862: PUSH
76863: LD_INT 1
76865: PUSH
76866: LD_INT 0
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: PUSH
76873: LD_INT 1
76875: PUSH
76876: LD_INT 1
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: PUSH
76883: LD_INT 0
76885: PUSH
76886: LD_INT 1
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: PUSH
76893: LD_INT 1
76895: NEG
76896: PUSH
76897: LD_INT 0
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: LD_INT 1
76906: NEG
76907: PUSH
76908: LD_INT 1
76910: NEG
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: PUSH
76916: LD_INT 1
76918: NEG
76919: PUSH
76920: LD_INT 2
76922: NEG
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PUSH
76928: LD_INT 0
76930: PUSH
76931: LD_INT 2
76933: NEG
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: PUSH
76939: LD_INT 1
76941: PUSH
76942: LD_INT 1
76944: NEG
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: PUSH
76950: LD_INT 2
76952: PUSH
76953: LD_INT 0
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 2
76962: PUSH
76963: LD_INT 1
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PUSH
76970: LD_INT 2
76972: PUSH
76973: LD_INT 2
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 1
76982: PUSH
76983: LD_INT 2
76985: PUSH
76986: EMPTY
76987: LIST
76988: LIST
76989: PUSH
76990: LD_INT 0
76992: PUSH
76993: LD_INT 2
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: PUSH
77000: LD_INT 1
77002: NEG
77003: PUSH
77004: LD_INT 1
77006: PUSH
77007: EMPTY
77008: LIST
77009: LIST
77010: PUSH
77011: LD_INT 2
77013: NEG
77014: PUSH
77015: LD_INT 0
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: PUSH
77022: LD_INT 2
77024: NEG
77025: PUSH
77026: LD_INT 1
77028: NEG
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: LD_INT 2
77036: NEG
77037: PUSH
77038: LD_INT 2
77040: NEG
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: LIST
77050: LIST
77051: LIST
77052: LIST
77053: LIST
77054: LIST
77055: LIST
77056: LIST
77057: LIST
77058: LIST
77059: LIST
77060: LIST
77061: LIST
77062: LIST
77063: LIST
77064: LIST
77065: LIST
77066: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77067: LD_ADDR_VAR 0 58
77071: PUSH
77072: LD_INT 0
77074: PUSH
77075: LD_INT 0
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: PUSH
77082: LD_INT 0
77084: PUSH
77085: LD_INT 1
77087: NEG
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PUSH
77093: LD_INT 1
77095: PUSH
77096: LD_INT 0
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: PUSH
77103: LD_INT 1
77105: PUSH
77106: LD_INT 1
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 0
77115: PUSH
77116: LD_INT 1
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: LD_INT 1
77125: NEG
77126: PUSH
77127: LD_INT 0
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: LD_INT 1
77136: NEG
77137: PUSH
77138: LD_INT 1
77140: NEG
77141: PUSH
77142: EMPTY
77143: LIST
77144: LIST
77145: PUSH
77146: LD_INT 1
77148: NEG
77149: PUSH
77150: LD_INT 2
77152: NEG
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: PUSH
77158: LD_INT 0
77160: PUSH
77161: LD_INT 2
77163: NEG
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 1
77171: PUSH
77172: LD_INT 1
77174: NEG
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 2
77182: PUSH
77183: LD_INT 0
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: LD_INT 2
77192: PUSH
77193: LD_INT 1
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: LD_INT 2
77202: PUSH
77203: LD_INT 2
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: PUSH
77210: LD_INT 1
77212: PUSH
77213: LD_INT 2
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: PUSH
77220: LD_INT 0
77222: PUSH
77223: LD_INT 2
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: PUSH
77230: LD_INT 1
77232: NEG
77233: PUSH
77234: LD_INT 1
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 2
77243: NEG
77244: PUSH
77245: LD_INT 0
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 2
77254: NEG
77255: PUSH
77256: LD_INT 1
77258: NEG
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: PUSH
77264: LD_INT 2
77266: NEG
77267: PUSH
77268: LD_INT 2
77270: NEG
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: EMPTY
77277: LIST
77278: LIST
77279: LIST
77280: LIST
77281: LIST
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: LIST
77289: LIST
77290: LIST
77291: LIST
77292: LIST
77293: LIST
77294: LIST
77295: LIST
77296: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77297: LD_ADDR_VAR 0 59
77301: PUSH
77302: LD_INT 0
77304: PUSH
77305: LD_INT 0
77307: PUSH
77308: EMPTY
77309: LIST
77310: LIST
77311: PUSH
77312: LD_INT 0
77314: PUSH
77315: LD_INT 1
77317: NEG
77318: PUSH
77319: EMPTY
77320: LIST
77321: LIST
77322: PUSH
77323: LD_INT 1
77325: PUSH
77326: LD_INT 0
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: PUSH
77333: LD_INT 1
77335: PUSH
77336: LD_INT 1
77338: PUSH
77339: EMPTY
77340: LIST
77341: LIST
77342: PUSH
77343: LD_INT 0
77345: PUSH
77346: LD_INT 1
77348: PUSH
77349: EMPTY
77350: LIST
77351: LIST
77352: PUSH
77353: LD_INT 1
77355: NEG
77356: PUSH
77357: LD_INT 0
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: PUSH
77364: LD_INT 1
77366: NEG
77367: PUSH
77368: LD_INT 1
77370: NEG
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: LIST
77380: LIST
77381: LIST
77382: LIST
77383: LIST
77384: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77385: LD_ADDR_VAR 0 60
77389: PUSH
77390: LD_INT 0
77392: PUSH
77393: LD_INT 0
77395: PUSH
77396: EMPTY
77397: LIST
77398: LIST
77399: PUSH
77400: LD_INT 0
77402: PUSH
77403: LD_INT 1
77405: NEG
77406: PUSH
77407: EMPTY
77408: LIST
77409: LIST
77410: PUSH
77411: LD_INT 1
77413: PUSH
77414: LD_INT 0
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 1
77423: PUSH
77424: LD_INT 1
77426: PUSH
77427: EMPTY
77428: LIST
77429: LIST
77430: PUSH
77431: LD_INT 0
77433: PUSH
77434: LD_INT 1
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: LD_INT 1
77443: NEG
77444: PUSH
77445: LD_INT 0
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 1
77454: NEG
77455: PUSH
77456: LD_INT 1
77458: NEG
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: EMPTY
77465: LIST
77466: LIST
77467: LIST
77468: LIST
77469: LIST
77470: LIST
77471: LIST
77472: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77473: LD_ADDR_VAR 0 61
77477: PUSH
77478: LD_INT 0
77480: PUSH
77481: LD_INT 0
77483: PUSH
77484: EMPTY
77485: LIST
77486: LIST
77487: PUSH
77488: LD_INT 0
77490: PUSH
77491: LD_INT 1
77493: NEG
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: LD_INT 1
77501: PUSH
77502: LD_INT 0
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: LD_INT 1
77511: PUSH
77512: LD_INT 1
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 0
77521: PUSH
77522: LD_INT 1
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: PUSH
77529: LD_INT 1
77531: NEG
77532: PUSH
77533: LD_INT 0
77535: PUSH
77536: EMPTY
77537: LIST
77538: LIST
77539: PUSH
77540: LD_INT 1
77542: NEG
77543: PUSH
77544: LD_INT 1
77546: NEG
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: LIST
77556: LIST
77557: LIST
77558: LIST
77559: LIST
77560: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77561: LD_ADDR_VAR 0 62
77565: PUSH
77566: LD_INT 0
77568: PUSH
77569: LD_INT 0
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: PUSH
77576: LD_INT 0
77578: PUSH
77579: LD_INT 1
77581: NEG
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 1
77589: PUSH
77590: LD_INT 0
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: PUSH
77597: LD_INT 1
77599: PUSH
77600: LD_INT 1
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: PUSH
77607: LD_INT 0
77609: PUSH
77610: LD_INT 1
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: PUSH
77617: LD_INT 1
77619: NEG
77620: PUSH
77621: LD_INT 0
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: PUSH
77628: LD_INT 1
77630: NEG
77631: PUSH
77632: LD_INT 1
77634: NEG
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: PUSH
77640: EMPTY
77641: LIST
77642: LIST
77643: LIST
77644: LIST
77645: LIST
77646: LIST
77647: LIST
77648: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77649: LD_ADDR_VAR 0 63
77653: PUSH
77654: LD_INT 0
77656: PUSH
77657: LD_INT 0
77659: PUSH
77660: EMPTY
77661: LIST
77662: LIST
77663: PUSH
77664: LD_INT 0
77666: PUSH
77667: LD_INT 1
77669: NEG
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: LD_INT 1
77677: PUSH
77678: LD_INT 0
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 1
77687: PUSH
77688: LD_INT 1
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: LD_INT 0
77697: PUSH
77698: LD_INT 1
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PUSH
77705: LD_INT 1
77707: NEG
77708: PUSH
77709: LD_INT 0
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 1
77718: NEG
77719: PUSH
77720: LD_INT 1
77722: NEG
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77737: LD_ADDR_VAR 0 64
77741: PUSH
77742: LD_INT 0
77744: PUSH
77745: LD_INT 0
77747: PUSH
77748: EMPTY
77749: LIST
77750: LIST
77751: PUSH
77752: LD_INT 0
77754: PUSH
77755: LD_INT 1
77757: NEG
77758: PUSH
77759: EMPTY
77760: LIST
77761: LIST
77762: PUSH
77763: LD_INT 1
77765: PUSH
77766: LD_INT 0
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: PUSH
77773: LD_INT 1
77775: PUSH
77776: LD_INT 1
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: PUSH
77783: LD_INT 0
77785: PUSH
77786: LD_INT 1
77788: PUSH
77789: EMPTY
77790: LIST
77791: LIST
77792: PUSH
77793: LD_INT 1
77795: NEG
77796: PUSH
77797: LD_INT 0
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: LD_INT 1
77806: NEG
77807: PUSH
77808: LD_INT 1
77810: NEG
77811: PUSH
77812: EMPTY
77813: LIST
77814: LIST
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: LIST
77823: LIST
77824: ST_TO_ADDR
// end ; 1 :
77825: GO 83722
77827: LD_INT 1
77829: DOUBLE
77830: EQUAL
77831: IFTRUE 77835
77833: GO 80458
77835: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77836: LD_ADDR_VAR 0 11
77840: PUSH
77841: LD_INT 1
77843: NEG
77844: PUSH
77845: LD_INT 3
77847: NEG
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: LD_INT 0
77855: PUSH
77856: LD_INT 3
77858: NEG
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: PUSH
77864: LD_INT 1
77866: PUSH
77867: LD_INT 2
77869: NEG
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: LIST
77879: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77880: LD_ADDR_VAR 0 12
77884: PUSH
77885: LD_INT 2
77887: PUSH
77888: LD_INT 1
77890: NEG
77891: PUSH
77892: EMPTY
77893: LIST
77894: LIST
77895: PUSH
77896: LD_INT 3
77898: PUSH
77899: LD_INT 0
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 3
77908: PUSH
77909: LD_INT 1
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: LIST
77920: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77921: LD_ADDR_VAR 0 13
77925: PUSH
77926: LD_INT 3
77928: PUSH
77929: LD_INT 2
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 3
77938: PUSH
77939: LD_INT 3
77941: PUSH
77942: EMPTY
77943: LIST
77944: LIST
77945: PUSH
77946: LD_INT 2
77948: PUSH
77949: LD_INT 3
77951: PUSH
77952: EMPTY
77953: LIST
77954: LIST
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: LIST
77960: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77961: LD_ADDR_VAR 0 14
77965: PUSH
77966: LD_INT 1
77968: PUSH
77969: LD_INT 3
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: PUSH
77976: LD_INT 0
77978: PUSH
77979: LD_INT 3
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: LD_INT 1
77988: NEG
77989: PUSH
77990: LD_INT 2
77992: PUSH
77993: EMPTY
77994: LIST
77995: LIST
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: LIST
78001: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78002: LD_ADDR_VAR 0 15
78006: PUSH
78007: LD_INT 2
78009: NEG
78010: PUSH
78011: LD_INT 1
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PUSH
78018: LD_INT 3
78020: NEG
78021: PUSH
78022: LD_INT 0
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: PUSH
78029: LD_INT 3
78031: NEG
78032: PUSH
78033: LD_INT 1
78035: NEG
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: EMPTY
78042: LIST
78043: LIST
78044: LIST
78045: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78046: LD_ADDR_VAR 0 16
78050: PUSH
78051: LD_INT 2
78053: NEG
78054: PUSH
78055: LD_INT 3
78057: NEG
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: PUSH
78063: LD_INT 3
78065: NEG
78066: PUSH
78067: LD_INT 2
78069: NEG
78070: PUSH
78071: EMPTY
78072: LIST
78073: LIST
78074: PUSH
78075: LD_INT 3
78077: NEG
78078: PUSH
78079: LD_INT 3
78081: NEG
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: PUSH
78087: EMPTY
78088: LIST
78089: LIST
78090: LIST
78091: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78092: LD_ADDR_VAR 0 17
78096: PUSH
78097: LD_INT 1
78099: NEG
78100: PUSH
78101: LD_INT 3
78103: NEG
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: LD_INT 0
78111: PUSH
78112: LD_INT 3
78114: NEG
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 1
78122: PUSH
78123: LD_INT 2
78125: NEG
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: LIST
78135: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78136: LD_ADDR_VAR 0 18
78140: PUSH
78141: LD_INT 2
78143: PUSH
78144: LD_INT 1
78146: NEG
78147: PUSH
78148: EMPTY
78149: LIST
78150: LIST
78151: PUSH
78152: LD_INT 3
78154: PUSH
78155: LD_INT 0
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 3
78164: PUSH
78165: LD_INT 1
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: LIST
78176: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78177: LD_ADDR_VAR 0 19
78181: PUSH
78182: LD_INT 3
78184: PUSH
78185: LD_INT 2
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PUSH
78192: LD_INT 3
78194: PUSH
78195: LD_INT 3
78197: PUSH
78198: EMPTY
78199: LIST
78200: LIST
78201: PUSH
78202: LD_INT 2
78204: PUSH
78205: LD_INT 3
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: LIST
78216: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78217: LD_ADDR_VAR 0 20
78221: PUSH
78222: LD_INT 1
78224: PUSH
78225: LD_INT 3
78227: PUSH
78228: EMPTY
78229: LIST
78230: LIST
78231: PUSH
78232: LD_INT 0
78234: PUSH
78235: LD_INT 3
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: PUSH
78242: LD_INT 1
78244: NEG
78245: PUSH
78246: LD_INT 2
78248: PUSH
78249: EMPTY
78250: LIST
78251: LIST
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: LIST
78257: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78258: LD_ADDR_VAR 0 21
78262: PUSH
78263: LD_INT 2
78265: NEG
78266: PUSH
78267: LD_INT 1
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 3
78276: NEG
78277: PUSH
78278: LD_INT 0
78280: PUSH
78281: EMPTY
78282: LIST
78283: LIST
78284: PUSH
78285: LD_INT 3
78287: NEG
78288: PUSH
78289: LD_INT 1
78291: NEG
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: LIST
78301: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78302: LD_ADDR_VAR 0 22
78306: PUSH
78307: LD_INT 2
78309: NEG
78310: PUSH
78311: LD_INT 3
78313: NEG
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 3
78321: NEG
78322: PUSH
78323: LD_INT 2
78325: NEG
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 3
78333: NEG
78334: PUSH
78335: LD_INT 3
78337: NEG
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: EMPTY
78344: LIST
78345: LIST
78346: LIST
78347: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78348: LD_ADDR_VAR 0 23
78352: PUSH
78353: LD_INT 0
78355: PUSH
78356: LD_INT 3
78358: NEG
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: LD_INT 1
78366: NEG
78367: PUSH
78368: LD_INT 4
78370: NEG
78371: PUSH
78372: EMPTY
78373: LIST
78374: LIST
78375: PUSH
78376: LD_INT 1
78378: PUSH
78379: LD_INT 3
78381: NEG
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: PUSH
78387: EMPTY
78388: LIST
78389: LIST
78390: LIST
78391: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78392: LD_ADDR_VAR 0 24
78396: PUSH
78397: LD_INT 3
78399: PUSH
78400: LD_INT 0
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: PUSH
78407: LD_INT 3
78409: PUSH
78410: LD_INT 1
78412: NEG
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: PUSH
78418: LD_INT 4
78420: PUSH
78421: LD_INT 1
78423: PUSH
78424: EMPTY
78425: LIST
78426: LIST
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: LIST
78432: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78433: LD_ADDR_VAR 0 25
78437: PUSH
78438: LD_INT 3
78440: PUSH
78441: LD_INT 3
78443: PUSH
78444: EMPTY
78445: LIST
78446: LIST
78447: PUSH
78448: LD_INT 4
78450: PUSH
78451: LD_INT 3
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: PUSH
78458: LD_INT 3
78460: PUSH
78461: LD_INT 4
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: LIST
78472: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78473: LD_ADDR_VAR 0 26
78477: PUSH
78478: LD_INT 0
78480: PUSH
78481: LD_INT 3
78483: PUSH
78484: EMPTY
78485: LIST
78486: LIST
78487: PUSH
78488: LD_INT 1
78490: PUSH
78491: LD_INT 4
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: PUSH
78498: LD_INT 1
78500: NEG
78501: PUSH
78502: LD_INT 3
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: LIST
78513: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78514: LD_ADDR_VAR 0 27
78518: PUSH
78519: LD_INT 3
78521: NEG
78522: PUSH
78523: LD_INT 0
78525: PUSH
78526: EMPTY
78527: LIST
78528: LIST
78529: PUSH
78530: LD_INT 3
78532: NEG
78533: PUSH
78534: LD_INT 1
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: PUSH
78541: LD_INT 4
78543: NEG
78544: PUSH
78545: LD_INT 1
78547: NEG
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: LIST
78557: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78558: LD_ADDR_VAR 0 28
78562: PUSH
78563: LD_INT 3
78565: NEG
78566: PUSH
78567: LD_INT 3
78569: NEG
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 3
78577: NEG
78578: PUSH
78579: LD_INT 4
78581: NEG
78582: PUSH
78583: EMPTY
78584: LIST
78585: LIST
78586: PUSH
78587: LD_INT 4
78589: NEG
78590: PUSH
78591: LD_INT 3
78593: NEG
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: LIST
78603: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78604: LD_ADDR_VAR 0 29
78608: PUSH
78609: LD_INT 1
78611: NEG
78612: PUSH
78613: LD_INT 3
78615: NEG
78616: PUSH
78617: EMPTY
78618: LIST
78619: LIST
78620: PUSH
78621: LD_INT 0
78623: PUSH
78624: LD_INT 3
78626: NEG
78627: PUSH
78628: EMPTY
78629: LIST
78630: LIST
78631: PUSH
78632: LD_INT 1
78634: PUSH
78635: LD_INT 2
78637: NEG
78638: PUSH
78639: EMPTY
78640: LIST
78641: LIST
78642: PUSH
78643: LD_INT 1
78645: NEG
78646: PUSH
78647: LD_INT 4
78649: NEG
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: PUSH
78655: LD_INT 0
78657: PUSH
78658: LD_INT 4
78660: NEG
78661: PUSH
78662: EMPTY
78663: LIST
78664: LIST
78665: PUSH
78666: LD_INT 1
78668: PUSH
78669: LD_INT 3
78671: NEG
78672: PUSH
78673: EMPTY
78674: LIST
78675: LIST
78676: PUSH
78677: LD_INT 1
78679: NEG
78680: PUSH
78681: LD_INT 5
78683: NEG
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: PUSH
78689: LD_INT 0
78691: PUSH
78692: LD_INT 5
78694: NEG
78695: PUSH
78696: EMPTY
78697: LIST
78698: LIST
78699: PUSH
78700: LD_INT 1
78702: PUSH
78703: LD_INT 4
78705: NEG
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: PUSH
78711: LD_INT 1
78713: NEG
78714: PUSH
78715: LD_INT 6
78717: NEG
78718: PUSH
78719: EMPTY
78720: LIST
78721: LIST
78722: PUSH
78723: LD_INT 0
78725: PUSH
78726: LD_INT 6
78728: NEG
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: PUSH
78734: LD_INT 1
78736: PUSH
78737: LD_INT 5
78739: NEG
78740: PUSH
78741: EMPTY
78742: LIST
78743: LIST
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: LIST
78749: LIST
78750: LIST
78751: LIST
78752: LIST
78753: LIST
78754: LIST
78755: LIST
78756: LIST
78757: LIST
78758: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78759: LD_ADDR_VAR 0 30
78763: PUSH
78764: LD_INT 2
78766: PUSH
78767: LD_INT 1
78769: NEG
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: PUSH
78775: LD_INT 3
78777: PUSH
78778: LD_INT 0
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: PUSH
78785: LD_INT 3
78787: PUSH
78788: LD_INT 1
78790: PUSH
78791: EMPTY
78792: LIST
78793: LIST
78794: PUSH
78795: LD_INT 3
78797: PUSH
78798: LD_INT 1
78800: NEG
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: LD_INT 4
78808: PUSH
78809: LD_INT 0
78811: PUSH
78812: EMPTY
78813: LIST
78814: LIST
78815: PUSH
78816: LD_INT 4
78818: PUSH
78819: LD_INT 1
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: LD_INT 4
78828: PUSH
78829: LD_INT 1
78831: NEG
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 5
78839: PUSH
78840: LD_INT 0
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 5
78849: PUSH
78850: LD_INT 1
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 5
78859: PUSH
78860: LD_INT 1
78862: NEG
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 6
78870: PUSH
78871: LD_INT 0
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PUSH
78878: LD_INT 6
78880: PUSH
78881: LD_INT 1
78883: PUSH
78884: EMPTY
78885: LIST
78886: LIST
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: LIST
78895: LIST
78896: LIST
78897: LIST
78898: LIST
78899: LIST
78900: LIST
78901: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78902: LD_ADDR_VAR 0 31
78906: PUSH
78907: LD_INT 3
78909: PUSH
78910: LD_INT 2
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 3
78919: PUSH
78920: LD_INT 3
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: PUSH
78927: LD_INT 2
78929: PUSH
78930: LD_INT 3
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 4
78939: PUSH
78940: LD_INT 3
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 4
78949: PUSH
78950: LD_INT 4
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PUSH
78957: LD_INT 3
78959: PUSH
78960: LD_INT 4
78962: PUSH
78963: EMPTY
78964: LIST
78965: LIST
78966: PUSH
78967: LD_INT 5
78969: PUSH
78970: LD_INT 4
78972: PUSH
78973: EMPTY
78974: LIST
78975: LIST
78976: PUSH
78977: LD_INT 5
78979: PUSH
78980: LD_INT 5
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: PUSH
78987: LD_INT 4
78989: PUSH
78990: LD_INT 5
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PUSH
78997: LD_INT 6
78999: PUSH
79000: LD_INT 5
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: PUSH
79007: LD_INT 6
79009: PUSH
79010: LD_INT 6
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 5
79019: PUSH
79020: LD_INT 6
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: LIST
79031: LIST
79032: LIST
79033: LIST
79034: LIST
79035: LIST
79036: LIST
79037: LIST
79038: LIST
79039: LIST
79040: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
79041: LD_ADDR_VAR 0 32
79045: PUSH
79046: LD_INT 1
79048: PUSH
79049: LD_INT 3
79051: PUSH
79052: EMPTY
79053: LIST
79054: LIST
79055: PUSH
79056: LD_INT 0
79058: PUSH
79059: LD_INT 3
79061: PUSH
79062: EMPTY
79063: LIST
79064: LIST
79065: PUSH
79066: LD_INT 1
79068: NEG
79069: PUSH
79070: LD_INT 2
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: PUSH
79077: LD_INT 1
79079: PUSH
79080: LD_INT 4
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: LD_INT 0
79089: PUSH
79090: LD_INT 4
79092: PUSH
79093: EMPTY
79094: LIST
79095: LIST
79096: PUSH
79097: LD_INT 1
79099: NEG
79100: PUSH
79101: LD_INT 3
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: LD_INT 1
79110: PUSH
79111: LD_INT 5
79113: PUSH
79114: EMPTY
79115: LIST
79116: LIST
79117: PUSH
79118: LD_INT 0
79120: PUSH
79121: LD_INT 5
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: LD_INT 1
79130: NEG
79131: PUSH
79132: LD_INT 4
79134: PUSH
79135: EMPTY
79136: LIST
79137: LIST
79138: PUSH
79139: LD_INT 1
79141: PUSH
79142: LD_INT 6
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 0
79151: PUSH
79152: LD_INT 6
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: PUSH
79159: LD_INT 1
79161: NEG
79162: PUSH
79163: LD_INT 5
79165: PUSH
79166: EMPTY
79167: LIST
79168: LIST
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: LIST
79174: LIST
79175: LIST
79176: LIST
79177: LIST
79178: LIST
79179: LIST
79180: LIST
79181: LIST
79182: LIST
79183: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79184: LD_ADDR_VAR 0 33
79188: PUSH
79189: LD_INT 2
79191: NEG
79192: PUSH
79193: LD_INT 1
79195: PUSH
79196: EMPTY
79197: LIST
79198: LIST
79199: PUSH
79200: LD_INT 3
79202: NEG
79203: PUSH
79204: LD_INT 0
79206: PUSH
79207: EMPTY
79208: LIST
79209: LIST
79210: PUSH
79211: LD_INT 3
79213: NEG
79214: PUSH
79215: LD_INT 1
79217: NEG
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 3
79225: NEG
79226: PUSH
79227: LD_INT 1
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PUSH
79234: LD_INT 4
79236: NEG
79237: PUSH
79238: LD_INT 0
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 4
79247: NEG
79248: PUSH
79249: LD_INT 1
79251: NEG
79252: PUSH
79253: EMPTY
79254: LIST
79255: LIST
79256: PUSH
79257: LD_INT 4
79259: NEG
79260: PUSH
79261: LD_INT 1
79263: PUSH
79264: EMPTY
79265: LIST
79266: LIST
79267: PUSH
79268: LD_INT 5
79270: NEG
79271: PUSH
79272: LD_INT 0
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: PUSH
79279: LD_INT 5
79281: NEG
79282: PUSH
79283: LD_INT 1
79285: NEG
79286: PUSH
79287: EMPTY
79288: LIST
79289: LIST
79290: PUSH
79291: LD_INT 5
79293: NEG
79294: PUSH
79295: LD_INT 1
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: LD_INT 6
79304: NEG
79305: PUSH
79306: LD_INT 0
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 6
79315: NEG
79316: PUSH
79317: LD_INT 1
79319: NEG
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79339: LD_ADDR_VAR 0 34
79343: PUSH
79344: LD_INT 2
79346: NEG
79347: PUSH
79348: LD_INT 3
79350: NEG
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 3
79358: NEG
79359: PUSH
79360: LD_INT 2
79362: NEG
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 3
79370: NEG
79371: PUSH
79372: LD_INT 3
79374: NEG
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: PUSH
79380: LD_INT 3
79382: NEG
79383: PUSH
79384: LD_INT 4
79386: NEG
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: LD_INT 4
79394: NEG
79395: PUSH
79396: LD_INT 3
79398: NEG
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 4
79406: NEG
79407: PUSH
79408: LD_INT 4
79410: NEG
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 4
79418: NEG
79419: PUSH
79420: LD_INT 5
79422: NEG
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: LD_INT 5
79430: NEG
79431: PUSH
79432: LD_INT 4
79434: NEG
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: PUSH
79440: LD_INT 5
79442: NEG
79443: PUSH
79444: LD_INT 5
79446: NEG
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PUSH
79452: LD_INT 5
79454: NEG
79455: PUSH
79456: LD_INT 6
79458: NEG
79459: PUSH
79460: EMPTY
79461: LIST
79462: LIST
79463: PUSH
79464: LD_INT 6
79466: NEG
79467: PUSH
79468: LD_INT 5
79470: NEG
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 6
79478: NEG
79479: PUSH
79480: LD_INT 6
79482: NEG
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: LIST
79492: LIST
79493: LIST
79494: LIST
79495: LIST
79496: LIST
79497: LIST
79498: LIST
79499: LIST
79500: LIST
79501: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79502: LD_ADDR_VAR 0 41
79506: PUSH
79507: LD_INT 0
79509: PUSH
79510: LD_INT 2
79512: NEG
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 1
79520: NEG
79521: PUSH
79522: LD_INT 3
79524: NEG
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: LD_INT 1
79532: PUSH
79533: LD_INT 2
79535: NEG
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: LIST
79545: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79546: LD_ADDR_VAR 0 42
79550: PUSH
79551: LD_INT 2
79553: PUSH
79554: LD_INT 0
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: PUSH
79561: LD_INT 2
79563: PUSH
79564: LD_INT 1
79566: NEG
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 3
79574: PUSH
79575: LD_INT 1
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: LIST
79586: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79587: LD_ADDR_VAR 0 43
79591: PUSH
79592: LD_INT 2
79594: PUSH
79595: LD_INT 2
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: LD_INT 3
79604: PUSH
79605: LD_INT 2
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 2
79614: PUSH
79615: LD_INT 3
79617: PUSH
79618: EMPTY
79619: LIST
79620: LIST
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: LIST
79626: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79627: LD_ADDR_VAR 0 44
79631: PUSH
79632: LD_INT 0
79634: PUSH
79635: LD_INT 2
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: LD_INT 1
79644: PUSH
79645: LD_INT 3
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 1
79654: NEG
79655: PUSH
79656: LD_INT 2
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: LIST
79667: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79668: LD_ADDR_VAR 0 45
79672: PUSH
79673: LD_INT 2
79675: NEG
79676: PUSH
79677: LD_INT 0
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 2
79686: NEG
79687: PUSH
79688: LD_INT 1
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: LD_INT 3
79697: NEG
79698: PUSH
79699: LD_INT 1
79701: NEG
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: LIST
79711: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79712: LD_ADDR_VAR 0 46
79716: PUSH
79717: LD_INT 2
79719: NEG
79720: PUSH
79721: LD_INT 2
79723: NEG
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 2
79731: NEG
79732: PUSH
79733: LD_INT 3
79735: NEG
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: LD_INT 3
79743: NEG
79744: PUSH
79745: LD_INT 2
79747: NEG
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: LIST
79757: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79758: LD_ADDR_VAR 0 47
79762: PUSH
79763: LD_INT 2
79765: NEG
79766: PUSH
79767: LD_INT 3
79769: NEG
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 1
79777: NEG
79778: PUSH
79779: LD_INT 3
79781: NEG
79782: PUSH
79783: EMPTY
79784: LIST
79785: LIST
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79791: LD_ADDR_VAR 0 48
79795: PUSH
79796: LD_INT 1
79798: PUSH
79799: LD_INT 2
79801: NEG
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: LD_INT 2
79809: PUSH
79810: LD_INT 1
79812: NEG
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79822: LD_ADDR_VAR 0 49
79826: PUSH
79827: LD_INT 3
79829: PUSH
79830: LD_INT 1
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: LD_INT 3
79839: PUSH
79840: LD_INT 2
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79851: LD_ADDR_VAR 0 50
79855: PUSH
79856: LD_INT 2
79858: PUSH
79859: LD_INT 3
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: PUSH
79866: LD_INT 1
79868: PUSH
79869: LD_INT 3
79871: PUSH
79872: EMPTY
79873: LIST
79874: LIST
79875: PUSH
79876: EMPTY
79877: LIST
79878: LIST
79879: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79880: LD_ADDR_VAR 0 51
79884: PUSH
79885: LD_INT 1
79887: NEG
79888: PUSH
79889: LD_INT 2
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 2
79898: NEG
79899: PUSH
79900: LD_INT 1
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79911: LD_ADDR_VAR 0 52
79915: PUSH
79916: LD_INT 3
79918: NEG
79919: PUSH
79920: LD_INT 1
79922: NEG
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 3
79930: NEG
79931: PUSH
79932: LD_INT 2
79934: NEG
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79944: LD_ADDR_VAR 0 53
79948: PUSH
79949: LD_INT 1
79951: NEG
79952: PUSH
79953: LD_INT 3
79955: NEG
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 0
79963: PUSH
79964: LD_INT 3
79966: NEG
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 1
79974: PUSH
79975: LD_INT 2
79977: NEG
79978: PUSH
79979: EMPTY
79980: LIST
79981: LIST
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: LIST
79987: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79988: LD_ADDR_VAR 0 54
79992: PUSH
79993: LD_INT 2
79995: PUSH
79996: LD_INT 1
79998: NEG
79999: PUSH
80000: EMPTY
80001: LIST
80002: LIST
80003: PUSH
80004: LD_INT 3
80006: PUSH
80007: LD_INT 0
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 3
80016: PUSH
80017: LD_INT 1
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: LIST
80028: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80029: LD_ADDR_VAR 0 55
80033: PUSH
80034: LD_INT 3
80036: PUSH
80037: LD_INT 2
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 3
80046: PUSH
80047: LD_INT 3
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 2
80056: PUSH
80057: LD_INT 3
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: LIST
80068: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80069: LD_ADDR_VAR 0 56
80073: PUSH
80074: LD_INT 1
80076: PUSH
80077: LD_INT 3
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PUSH
80084: LD_INT 0
80086: PUSH
80087: LD_INT 3
80089: PUSH
80090: EMPTY
80091: LIST
80092: LIST
80093: PUSH
80094: LD_INT 1
80096: NEG
80097: PUSH
80098: LD_INT 2
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: LIST
80109: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80110: LD_ADDR_VAR 0 57
80114: PUSH
80115: LD_INT 2
80117: NEG
80118: PUSH
80119: LD_INT 1
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 3
80128: NEG
80129: PUSH
80130: LD_INT 0
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 3
80139: NEG
80140: PUSH
80141: LD_INT 1
80143: NEG
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: EMPTY
80150: LIST
80151: LIST
80152: LIST
80153: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80154: LD_ADDR_VAR 0 58
80158: PUSH
80159: LD_INT 2
80161: NEG
80162: PUSH
80163: LD_INT 3
80165: NEG
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 3
80173: NEG
80174: PUSH
80175: LD_INT 2
80177: NEG
80178: PUSH
80179: EMPTY
80180: LIST
80181: LIST
80182: PUSH
80183: LD_INT 3
80185: NEG
80186: PUSH
80187: LD_INT 3
80189: NEG
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: LIST
80199: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80200: LD_ADDR_VAR 0 59
80204: PUSH
80205: LD_INT 1
80207: NEG
80208: PUSH
80209: LD_INT 2
80211: NEG
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 0
80219: PUSH
80220: LD_INT 2
80222: NEG
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 1
80230: PUSH
80231: LD_INT 1
80233: NEG
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: LIST
80243: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80244: LD_ADDR_VAR 0 60
80248: PUSH
80249: LD_INT 1
80251: PUSH
80252: LD_INT 1
80254: NEG
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: LD_INT 2
80262: PUSH
80263: LD_INT 0
80265: PUSH
80266: EMPTY
80267: LIST
80268: LIST
80269: PUSH
80270: LD_INT 2
80272: PUSH
80273: LD_INT 1
80275: PUSH
80276: EMPTY
80277: LIST
80278: LIST
80279: PUSH
80280: EMPTY
80281: LIST
80282: LIST
80283: LIST
80284: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80285: LD_ADDR_VAR 0 61
80289: PUSH
80290: LD_INT 2
80292: PUSH
80293: LD_INT 1
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: PUSH
80300: LD_INT 2
80302: PUSH
80303: LD_INT 2
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 1
80312: PUSH
80313: LD_INT 2
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: LIST
80324: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80325: LD_ADDR_VAR 0 62
80329: PUSH
80330: LD_INT 1
80332: PUSH
80333: LD_INT 2
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: PUSH
80340: LD_INT 0
80342: PUSH
80343: LD_INT 2
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 1
80352: NEG
80353: PUSH
80354: LD_INT 1
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: PUSH
80361: EMPTY
80362: LIST
80363: LIST
80364: LIST
80365: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80366: LD_ADDR_VAR 0 63
80370: PUSH
80371: LD_INT 1
80373: NEG
80374: PUSH
80375: LD_INT 1
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: PUSH
80382: LD_INT 2
80384: NEG
80385: PUSH
80386: LD_INT 0
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 2
80395: NEG
80396: PUSH
80397: LD_INT 1
80399: NEG
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: EMPTY
80406: LIST
80407: LIST
80408: LIST
80409: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80410: LD_ADDR_VAR 0 64
80414: PUSH
80415: LD_INT 1
80417: NEG
80418: PUSH
80419: LD_INT 2
80421: NEG
80422: PUSH
80423: EMPTY
80424: LIST
80425: LIST
80426: PUSH
80427: LD_INT 2
80429: NEG
80430: PUSH
80431: LD_INT 1
80433: NEG
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 2
80441: NEG
80442: PUSH
80443: LD_INT 2
80445: NEG
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: LIST
80455: ST_TO_ADDR
// end ; 2 :
80456: GO 83722
80458: LD_INT 2
80460: DOUBLE
80461: EQUAL
80462: IFTRUE 80466
80464: GO 83721
80466: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80467: LD_ADDR_VAR 0 29
80471: PUSH
80472: LD_INT 4
80474: PUSH
80475: LD_INT 0
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 4
80484: PUSH
80485: LD_INT 1
80487: NEG
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 5
80495: PUSH
80496: LD_INT 0
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 5
80505: PUSH
80506: LD_INT 1
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 4
80515: PUSH
80516: LD_INT 1
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 3
80525: PUSH
80526: LD_INT 0
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: PUSH
80533: LD_INT 3
80535: PUSH
80536: LD_INT 1
80538: NEG
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: PUSH
80544: LD_INT 3
80546: PUSH
80547: LD_INT 2
80549: NEG
80550: PUSH
80551: EMPTY
80552: LIST
80553: LIST
80554: PUSH
80555: LD_INT 5
80557: PUSH
80558: LD_INT 2
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 3
80567: PUSH
80568: LD_INT 3
80570: PUSH
80571: EMPTY
80572: LIST
80573: LIST
80574: PUSH
80575: LD_INT 3
80577: PUSH
80578: LD_INT 2
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 4
80587: PUSH
80588: LD_INT 3
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: PUSH
80595: LD_INT 4
80597: PUSH
80598: LD_INT 4
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 3
80607: PUSH
80608: LD_INT 4
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: PUSH
80615: LD_INT 2
80617: PUSH
80618: LD_INT 3
80620: PUSH
80621: EMPTY
80622: LIST
80623: LIST
80624: PUSH
80625: LD_INT 2
80627: PUSH
80628: LD_INT 2
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 4
80637: PUSH
80638: LD_INT 2
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 2
80647: PUSH
80648: LD_INT 4
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 0
80657: PUSH
80658: LD_INT 4
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: LD_INT 0
80667: PUSH
80668: LD_INT 3
80670: PUSH
80671: EMPTY
80672: LIST
80673: LIST
80674: PUSH
80675: LD_INT 1
80677: PUSH
80678: LD_INT 4
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 1
80687: PUSH
80688: LD_INT 5
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: PUSH
80695: LD_INT 0
80697: PUSH
80698: LD_INT 5
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: LD_INT 1
80707: NEG
80708: PUSH
80709: LD_INT 4
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 1
80718: NEG
80719: PUSH
80720: LD_INT 3
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 2
80729: PUSH
80730: LD_INT 5
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PUSH
80737: LD_INT 2
80739: NEG
80740: PUSH
80741: LD_INT 3
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 3
80750: NEG
80751: PUSH
80752: LD_INT 0
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 3
80761: NEG
80762: PUSH
80763: LD_INT 1
80765: NEG
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 2
80773: NEG
80774: PUSH
80775: LD_INT 0
80777: PUSH
80778: EMPTY
80779: LIST
80780: LIST
80781: PUSH
80782: LD_INT 2
80784: NEG
80785: PUSH
80786: LD_INT 1
80788: PUSH
80789: EMPTY
80790: LIST
80791: LIST
80792: PUSH
80793: LD_INT 3
80795: NEG
80796: PUSH
80797: LD_INT 1
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 4
80806: NEG
80807: PUSH
80808: LD_INT 0
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 4
80817: NEG
80818: PUSH
80819: LD_INT 1
80821: NEG
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 4
80829: NEG
80830: PUSH
80831: LD_INT 2
80833: NEG
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 2
80841: NEG
80842: PUSH
80843: LD_INT 2
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 4
80852: NEG
80853: PUSH
80854: LD_INT 4
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 4
80864: NEG
80865: PUSH
80866: LD_INT 5
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 3
80876: NEG
80877: PUSH
80878: LD_INT 4
80880: NEG
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: LD_INT 3
80888: NEG
80889: PUSH
80890: LD_INT 3
80892: NEG
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 4
80900: NEG
80901: PUSH
80902: LD_INT 3
80904: NEG
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 5
80912: NEG
80913: PUSH
80914: LD_INT 4
80916: NEG
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: LD_INT 5
80924: NEG
80925: PUSH
80926: LD_INT 5
80928: NEG
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: LD_INT 3
80936: NEG
80937: PUSH
80938: LD_INT 5
80940: NEG
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 5
80948: NEG
80949: PUSH
80950: LD_INT 3
80952: NEG
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: LIST
80971: LIST
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: LIST
80977: LIST
80978: LIST
80979: LIST
80980: LIST
80981: LIST
80982: LIST
80983: LIST
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
81005: LD_ADDR_VAR 0 30
81009: PUSH
81010: LD_INT 4
81012: PUSH
81013: LD_INT 4
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: LD_INT 4
81022: PUSH
81023: LD_INT 3
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 5
81032: PUSH
81033: LD_INT 4
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 5
81042: PUSH
81043: LD_INT 5
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 4
81052: PUSH
81053: LD_INT 5
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 3
81062: PUSH
81063: LD_INT 4
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 3
81072: PUSH
81073: LD_INT 3
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 5
81082: PUSH
81083: LD_INT 3
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 3
81092: PUSH
81093: LD_INT 5
81095: PUSH
81096: EMPTY
81097: LIST
81098: LIST
81099: PUSH
81100: LD_INT 0
81102: PUSH
81103: LD_INT 3
81105: PUSH
81106: EMPTY
81107: LIST
81108: LIST
81109: PUSH
81110: LD_INT 0
81112: PUSH
81113: LD_INT 2
81115: PUSH
81116: EMPTY
81117: LIST
81118: LIST
81119: PUSH
81120: LD_INT 1
81122: PUSH
81123: LD_INT 3
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: PUSH
81130: LD_INT 1
81132: PUSH
81133: LD_INT 4
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PUSH
81140: LD_INT 0
81142: PUSH
81143: LD_INT 4
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 1
81152: NEG
81153: PUSH
81154: LD_INT 3
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 1
81163: NEG
81164: PUSH
81165: LD_INT 2
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: LD_INT 2
81174: PUSH
81175: LD_INT 4
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: PUSH
81182: LD_INT 2
81184: NEG
81185: PUSH
81186: LD_INT 2
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: PUSH
81193: LD_INT 4
81195: NEG
81196: PUSH
81197: LD_INT 0
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 4
81206: NEG
81207: PUSH
81208: LD_INT 1
81210: NEG
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 3
81218: NEG
81219: PUSH
81220: LD_INT 0
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 3
81229: NEG
81230: PUSH
81231: LD_INT 1
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 4
81240: NEG
81241: PUSH
81242: LD_INT 1
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 5
81251: NEG
81252: PUSH
81253: LD_INT 0
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: LD_INT 5
81262: NEG
81263: PUSH
81264: LD_INT 1
81266: NEG
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PUSH
81272: LD_INT 5
81274: NEG
81275: PUSH
81276: LD_INT 2
81278: NEG
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 3
81286: NEG
81287: PUSH
81288: LD_INT 2
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 3
81297: NEG
81298: PUSH
81299: LD_INT 3
81301: NEG
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: PUSH
81307: LD_INT 3
81309: NEG
81310: PUSH
81311: LD_INT 4
81313: NEG
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: PUSH
81319: LD_INT 2
81321: NEG
81322: PUSH
81323: LD_INT 3
81325: NEG
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 2
81333: NEG
81334: PUSH
81335: LD_INT 2
81337: NEG
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PUSH
81343: LD_INT 3
81345: NEG
81346: PUSH
81347: LD_INT 2
81349: NEG
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 4
81357: NEG
81358: PUSH
81359: LD_INT 3
81361: NEG
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 4
81369: NEG
81370: PUSH
81371: LD_INT 4
81373: NEG
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 2
81381: NEG
81382: PUSH
81383: LD_INT 4
81385: NEG
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 4
81393: NEG
81394: PUSH
81395: LD_INT 2
81397: NEG
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: LD_INT 0
81405: PUSH
81406: LD_INT 4
81408: NEG
81409: PUSH
81410: EMPTY
81411: LIST
81412: LIST
81413: PUSH
81414: LD_INT 0
81416: PUSH
81417: LD_INT 5
81419: NEG
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 1
81427: PUSH
81428: LD_INT 4
81430: NEG
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PUSH
81436: LD_INT 1
81438: PUSH
81439: LD_INT 3
81441: NEG
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: PUSH
81447: LD_INT 0
81449: PUSH
81450: LD_INT 3
81452: NEG
81453: PUSH
81454: EMPTY
81455: LIST
81456: LIST
81457: PUSH
81458: LD_INT 1
81460: NEG
81461: PUSH
81462: LD_INT 4
81464: NEG
81465: PUSH
81466: EMPTY
81467: LIST
81468: LIST
81469: PUSH
81470: LD_INT 1
81472: NEG
81473: PUSH
81474: LD_INT 5
81476: NEG
81477: PUSH
81478: EMPTY
81479: LIST
81480: LIST
81481: PUSH
81482: LD_INT 2
81484: PUSH
81485: LD_INT 3
81487: NEG
81488: PUSH
81489: EMPTY
81490: LIST
81491: LIST
81492: PUSH
81493: LD_INT 2
81495: NEG
81496: PUSH
81497: LD_INT 5
81499: NEG
81500: PUSH
81501: EMPTY
81502: LIST
81503: LIST
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: LIST
81509: LIST
81510: LIST
81511: LIST
81512: LIST
81513: LIST
81514: LIST
81515: LIST
81516: LIST
81517: LIST
81518: LIST
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: LIST
81528: LIST
81529: LIST
81530: LIST
81531: LIST
81532: LIST
81533: LIST
81534: LIST
81535: LIST
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81552: LD_ADDR_VAR 0 31
81556: PUSH
81557: LD_INT 0
81559: PUSH
81560: LD_INT 4
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 0
81569: PUSH
81570: LD_INT 3
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 1
81579: PUSH
81580: LD_INT 4
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 1
81589: PUSH
81590: LD_INT 5
81592: PUSH
81593: EMPTY
81594: LIST
81595: LIST
81596: PUSH
81597: LD_INT 0
81599: PUSH
81600: LD_INT 5
81602: PUSH
81603: EMPTY
81604: LIST
81605: LIST
81606: PUSH
81607: LD_INT 1
81609: NEG
81610: PUSH
81611: LD_INT 4
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_INT 1
81620: NEG
81621: PUSH
81622: LD_INT 3
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: PUSH
81629: LD_INT 2
81631: PUSH
81632: LD_INT 5
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 2
81641: NEG
81642: PUSH
81643: LD_INT 3
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: LD_INT 3
81652: NEG
81653: PUSH
81654: LD_INT 0
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 3
81663: NEG
81664: PUSH
81665: LD_INT 1
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 2
81675: NEG
81676: PUSH
81677: LD_INT 0
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 2
81686: NEG
81687: PUSH
81688: LD_INT 1
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: LD_INT 3
81697: NEG
81698: PUSH
81699: LD_INT 1
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: PUSH
81706: LD_INT 4
81708: NEG
81709: PUSH
81710: LD_INT 0
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 4
81719: NEG
81720: PUSH
81721: LD_INT 1
81723: NEG
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 4
81731: NEG
81732: PUSH
81733: LD_INT 2
81735: NEG
81736: PUSH
81737: EMPTY
81738: LIST
81739: LIST
81740: PUSH
81741: LD_INT 2
81743: NEG
81744: PUSH
81745: LD_INT 2
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: LD_INT 4
81754: NEG
81755: PUSH
81756: LD_INT 4
81758: NEG
81759: PUSH
81760: EMPTY
81761: LIST
81762: LIST
81763: PUSH
81764: LD_INT 4
81766: NEG
81767: PUSH
81768: LD_INT 5
81770: NEG
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 3
81778: NEG
81779: PUSH
81780: LD_INT 4
81782: NEG
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 3
81790: NEG
81791: PUSH
81792: LD_INT 3
81794: NEG
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: PUSH
81800: LD_INT 4
81802: NEG
81803: PUSH
81804: LD_INT 3
81806: NEG
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 5
81814: NEG
81815: PUSH
81816: LD_INT 4
81818: NEG
81819: PUSH
81820: EMPTY
81821: LIST
81822: LIST
81823: PUSH
81824: LD_INT 5
81826: NEG
81827: PUSH
81828: LD_INT 5
81830: NEG
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: PUSH
81836: LD_INT 3
81838: NEG
81839: PUSH
81840: LD_INT 5
81842: NEG
81843: PUSH
81844: EMPTY
81845: LIST
81846: LIST
81847: PUSH
81848: LD_INT 5
81850: NEG
81851: PUSH
81852: LD_INT 3
81854: NEG
81855: PUSH
81856: EMPTY
81857: LIST
81858: LIST
81859: PUSH
81860: LD_INT 0
81862: PUSH
81863: LD_INT 3
81865: NEG
81866: PUSH
81867: EMPTY
81868: LIST
81869: LIST
81870: PUSH
81871: LD_INT 0
81873: PUSH
81874: LD_INT 4
81876: NEG
81877: PUSH
81878: EMPTY
81879: LIST
81880: LIST
81881: PUSH
81882: LD_INT 1
81884: PUSH
81885: LD_INT 3
81887: NEG
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: LD_INT 1
81895: PUSH
81896: LD_INT 2
81898: NEG
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 0
81906: PUSH
81907: LD_INT 2
81909: NEG
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 1
81917: NEG
81918: PUSH
81919: LD_INT 3
81921: NEG
81922: PUSH
81923: EMPTY
81924: LIST
81925: LIST
81926: PUSH
81927: LD_INT 1
81929: NEG
81930: PUSH
81931: LD_INT 4
81933: NEG
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: PUSH
81939: LD_INT 2
81941: PUSH
81942: LD_INT 2
81944: NEG
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: PUSH
81950: LD_INT 2
81952: NEG
81953: PUSH
81954: LD_INT 4
81956: NEG
81957: PUSH
81958: EMPTY
81959: LIST
81960: LIST
81961: PUSH
81962: LD_INT 4
81964: PUSH
81965: LD_INT 0
81967: PUSH
81968: EMPTY
81969: LIST
81970: LIST
81971: PUSH
81972: LD_INT 4
81974: PUSH
81975: LD_INT 1
81977: NEG
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 5
81985: PUSH
81986: LD_INT 0
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: PUSH
81993: LD_INT 5
81995: PUSH
81996: LD_INT 1
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: LD_INT 4
82005: PUSH
82006: LD_INT 1
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 3
82015: PUSH
82016: LD_INT 0
82018: PUSH
82019: EMPTY
82020: LIST
82021: LIST
82022: PUSH
82023: LD_INT 3
82025: PUSH
82026: LD_INT 1
82028: NEG
82029: PUSH
82030: EMPTY
82031: LIST
82032: LIST
82033: PUSH
82034: LD_INT 3
82036: PUSH
82037: LD_INT 2
82039: NEG
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: PUSH
82045: LD_INT 5
82047: PUSH
82048: LD_INT 2
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: LIST
82059: LIST
82060: LIST
82061: LIST
82062: LIST
82063: LIST
82064: LIST
82065: LIST
82066: LIST
82067: LIST
82068: LIST
82069: LIST
82070: LIST
82071: LIST
82072: LIST
82073: LIST
82074: LIST
82075: LIST
82076: LIST
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: LIST
82082: LIST
82083: LIST
82084: LIST
82085: LIST
82086: LIST
82087: LIST
82088: LIST
82089: LIST
82090: LIST
82091: LIST
82092: LIST
82093: LIST
82094: LIST
82095: LIST
82096: LIST
82097: LIST
82098: LIST
82099: LIST
82100: LIST
82101: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82102: LD_ADDR_VAR 0 32
82106: PUSH
82107: LD_INT 4
82109: NEG
82110: PUSH
82111: LD_INT 0
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 4
82120: NEG
82121: PUSH
82122: LD_INT 1
82124: NEG
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 3
82132: NEG
82133: PUSH
82134: LD_INT 0
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: PUSH
82141: LD_INT 3
82143: NEG
82144: PUSH
82145: LD_INT 1
82147: PUSH
82148: EMPTY
82149: LIST
82150: LIST
82151: PUSH
82152: LD_INT 4
82154: NEG
82155: PUSH
82156: LD_INT 1
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 5
82165: NEG
82166: PUSH
82167: LD_INT 0
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 5
82176: NEG
82177: PUSH
82178: LD_INT 1
82180: NEG
82181: PUSH
82182: EMPTY
82183: LIST
82184: LIST
82185: PUSH
82186: LD_INT 5
82188: NEG
82189: PUSH
82190: LD_INT 2
82192: NEG
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 3
82200: NEG
82201: PUSH
82202: LD_INT 2
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 3
82211: NEG
82212: PUSH
82213: LD_INT 3
82215: NEG
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: LD_INT 3
82223: NEG
82224: PUSH
82225: LD_INT 4
82227: NEG
82228: PUSH
82229: EMPTY
82230: LIST
82231: LIST
82232: PUSH
82233: LD_INT 2
82235: NEG
82236: PUSH
82237: LD_INT 3
82239: NEG
82240: PUSH
82241: EMPTY
82242: LIST
82243: LIST
82244: PUSH
82245: LD_INT 2
82247: NEG
82248: PUSH
82249: LD_INT 2
82251: NEG
82252: PUSH
82253: EMPTY
82254: LIST
82255: LIST
82256: PUSH
82257: LD_INT 3
82259: NEG
82260: PUSH
82261: LD_INT 2
82263: NEG
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 4
82271: NEG
82272: PUSH
82273: LD_INT 3
82275: NEG
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 4
82283: NEG
82284: PUSH
82285: LD_INT 4
82287: NEG
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: LD_INT 2
82295: NEG
82296: PUSH
82297: LD_INT 4
82299: NEG
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: PUSH
82305: LD_INT 4
82307: NEG
82308: PUSH
82309: LD_INT 2
82311: NEG
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: PUSH
82317: LD_INT 0
82319: PUSH
82320: LD_INT 4
82322: NEG
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: PUSH
82328: LD_INT 0
82330: PUSH
82331: LD_INT 5
82333: NEG
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: PUSH
82339: LD_INT 1
82341: PUSH
82342: LD_INT 4
82344: NEG
82345: PUSH
82346: EMPTY
82347: LIST
82348: LIST
82349: PUSH
82350: LD_INT 1
82352: PUSH
82353: LD_INT 3
82355: NEG
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PUSH
82361: LD_INT 0
82363: PUSH
82364: LD_INT 3
82366: NEG
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 1
82374: NEG
82375: PUSH
82376: LD_INT 4
82378: NEG
82379: PUSH
82380: EMPTY
82381: LIST
82382: LIST
82383: PUSH
82384: LD_INT 1
82386: NEG
82387: PUSH
82388: LD_INT 5
82390: NEG
82391: PUSH
82392: EMPTY
82393: LIST
82394: LIST
82395: PUSH
82396: LD_INT 2
82398: PUSH
82399: LD_INT 3
82401: NEG
82402: PUSH
82403: EMPTY
82404: LIST
82405: LIST
82406: PUSH
82407: LD_INT 2
82409: NEG
82410: PUSH
82411: LD_INT 5
82413: NEG
82414: PUSH
82415: EMPTY
82416: LIST
82417: LIST
82418: PUSH
82419: LD_INT 3
82421: PUSH
82422: LD_INT 0
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: PUSH
82429: LD_INT 3
82431: PUSH
82432: LD_INT 1
82434: NEG
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PUSH
82440: LD_INT 4
82442: PUSH
82443: LD_INT 0
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 4
82452: PUSH
82453: LD_INT 1
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 3
82462: PUSH
82463: LD_INT 1
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 2
82472: PUSH
82473: LD_INT 0
82475: PUSH
82476: EMPTY
82477: LIST
82478: LIST
82479: PUSH
82480: LD_INT 2
82482: PUSH
82483: LD_INT 1
82485: NEG
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: PUSH
82491: LD_INT 2
82493: PUSH
82494: LD_INT 2
82496: NEG
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 4
82504: PUSH
82505: LD_INT 2
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 4
82514: PUSH
82515: LD_INT 4
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 4
82524: PUSH
82525: LD_INT 3
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: LD_INT 5
82534: PUSH
82535: LD_INT 4
82537: PUSH
82538: EMPTY
82539: LIST
82540: LIST
82541: PUSH
82542: LD_INT 5
82544: PUSH
82545: LD_INT 5
82547: PUSH
82548: EMPTY
82549: LIST
82550: LIST
82551: PUSH
82552: LD_INT 4
82554: PUSH
82555: LD_INT 5
82557: PUSH
82558: EMPTY
82559: LIST
82560: LIST
82561: PUSH
82562: LD_INT 3
82564: PUSH
82565: LD_INT 4
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: PUSH
82572: LD_INT 3
82574: PUSH
82575: LD_INT 3
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 5
82584: PUSH
82585: LD_INT 3
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: PUSH
82592: LD_INT 3
82594: PUSH
82595: LD_INT 5
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: LIST
82606: LIST
82607: LIST
82608: LIST
82609: LIST
82610: LIST
82611: LIST
82612: LIST
82613: LIST
82614: LIST
82615: LIST
82616: LIST
82617: LIST
82618: LIST
82619: LIST
82620: LIST
82621: LIST
82622: LIST
82623: LIST
82624: LIST
82625: LIST
82626: LIST
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: LIST
82633: LIST
82634: LIST
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82649: LD_ADDR_VAR 0 33
82653: PUSH
82654: LD_INT 4
82656: NEG
82657: PUSH
82658: LD_INT 4
82660: NEG
82661: PUSH
82662: EMPTY
82663: LIST
82664: LIST
82665: PUSH
82666: LD_INT 4
82668: NEG
82669: PUSH
82670: LD_INT 5
82672: NEG
82673: PUSH
82674: EMPTY
82675: LIST
82676: LIST
82677: PUSH
82678: LD_INT 3
82680: NEG
82681: PUSH
82682: LD_INT 4
82684: NEG
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PUSH
82690: LD_INT 3
82692: NEG
82693: PUSH
82694: LD_INT 3
82696: NEG
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: LD_INT 4
82704: NEG
82705: PUSH
82706: LD_INT 3
82708: NEG
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 5
82716: NEG
82717: PUSH
82718: LD_INT 4
82720: NEG
82721: PUSH
82722: EMPTY
82723: LIST
82724: LIST
82725: PUSH
82726: LD_INT 5
82728: NEG
82729: PUSH
82730: LD_INT 5
82732: NEG
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: LD_INT 3
82740: NEG
82741: PUSH
82742: LD_INT 5
82744: NEG
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 5
82752: NEG
82753: PUSH
82754: LD_INT 3
82756: NEG
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 0
82764: PUSH
82765: LD_INT 3
82767: NEG
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: PUSH
82773: LD_INT 0
82775: PUSH
82776: LD_INT 4
82778: NEG
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 1
82786: PUSH
82787: LD_INT 3
82789: NEG
82790: PUSH
82791: EMPTY
82792: LIST
82793: LIST
82794: PUSH
82795: LD_INT 1
82797: PUSH
82798: LD_INT 2
82800: NEG
82801: PUSH
82802: EMPTY
82803: LIST
82804: LIST
82805: PUSH
82806: LD_INT 0
82808: PUSH
82809: LD_INT 2
82811: NEG
82812: PUSH
82813: EMPTY
82814: LIST
82815: LIST
82816: PUSH
82817: LD_INT 1
82819: NEG
82820: PUSH
82821: LD_INT 3
82823: NEG
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 1
82831: NEG
82832: PUSH
82833: LD_INT 4
82835: NEG
82836: PUSH
82837: EMPTY
82838: LIST
82839: LIST
82840: PUSH
82841: LD_INT 2
82843: PUSH
82844: LD_INT 2
82846: NEG
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 2
82854: NEG
82855: PUSH
82856: LD_INT 4
82858: NEG
82859: PUSH
82860: EMPTY
82861: LIST
82862: LIST
82863: PUSH
82864: LD_INT 4
82866: PUSH
82867: LD_INT 0
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: PUSH
82874: LD_INT 4
82876: PUSH
82877: LD_INT 1
82879: NEG
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PUSH
82885: LD_INT 5
82887: PUSH
82888: LD_INT 0
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: LD_INT 5
82897: PUSH
82898: LD_INT 1
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: PUSH
82905: LD_INT 4
82907: PUSH
82908: LD_INT 1
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PUSH
82915: LD_INT 3
82917: PUSH
82918: LD_INT 0
82920: PUSH
82921: EMPTY
82922: LIST
82923: LIST
82924: PUSH
82925: LD_INT 3
82927: PUSH
82928: LD_INT 1
82930: NEG
82931: PUSH
82932: EMPTY
82933: LIST
82934: LIST
82935: PUSH
82936: LD_INT 3
82938: PUSH
82939: LD_INT 2
82941: NEG
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 5
82949: PUSH
82950: LD_INT 2
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 3
82959: PUSH
82960: LD_INT 3
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 3
82969: PUSH
82970: LD_INT 2
82972: PUSH
82973: EMPTY
82974: LIST
82975: LIST
82976: PUSH
82977: LD_INT 4
82979: PUSH
82980: LD_INT 3
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: PUSH
82987: LD_INT 4
82989: PUSH
82990: LD_INT 4
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: PUSH
82997: LD_INT 3
82999: PUSH
83000: LD_INT 4
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: PUSH
83007: LD_INT 2
83009: PUSH
83010: LD_INT 3
83012: PUSH
83013: EMPTY
83014: LIST
83015: LIST
83016: PUSH
83017: LD_INT 2
83019: PUSH
83020: LD_INT 2
83022: PUSH
83023: EMPTY
83024: LIST
83025: LIST
83026: PUSH
83027: LD_INT 4
83029: PUSH
83030: LD_INT 2
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: PUSH
83037: LD_INT 2
83039: PUSH
83040: LD_INT 4
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PUSH
83047: LD_INT 0
83049: PUSH
83050: LD_INT 4
83052: PUSH
83053: EMPTY
83054: LIST
83055: LIST
83056: PUSH
83057: LD_INT 0
83059: PUSH
83060: LD_INT 3
83062: PUSH
83063: EMPTY
83064: LIST
83065: LIST
83066: PUSH
83067: LD_INT 1
83069: PUSH
83070: LD_INT 4
83072: PUSH
83073: EMPTY
83074: LIST
83075: LIST
83076: PUSH
83077: LD_INT 1
83079: PUSH
83080: LD_INT 5
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: LD_INT 0
83089: PUSH
83090: LD_INT 5
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 1
83099: NEG
83100: PUSH
83101: LD_INT 4
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: PUSH
83108: LD_INT 1
83110: NEG
83111: PUSH
83112: LD_INT 3
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 2
83121: PUSH
83122: LD_INT 5
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 2
83131: NEG
83132: PUSH
83133: LD_INT 3
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: LIST
83158: LIST
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: LIST
83164: LIST
83165: LIST
83166: LIST
83167: LIST
83168: LIST
83169: LIST
83170: LIST
83171: LIST
83172: LIST
83173: LIST
83174: LIST
83175: LIST
83176: LIST
83177: LIST
83178: LIST
83179: LIST
83180: LIST
83181: LIST
83182: LIST
83183: LIST
83184: LIST
83185: LIST
83186: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83187: LD_ADDR_VAR 0 34
83191: PUSH
83192: LD_INT 0
83194: PUSH
83195: LD_INT 4
83197: NEG
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 0
83205: PUSH
83206: LD_INT 5
83208: NEG
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 1
83216: PUSH
83217: LD_INT 4
83219: NEG
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: PUSH
83225: LD_INT 1
83227: PUSH
83228: LD_INT 3
83230: NEG
83231: PUSH
83232: EMPTY
83233: LIST
83234: LIST
83235: PUSH
83236: LD_INT 0
83238: PUSH
83239: LD_INT 3
83241: NEG
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PUSH
83247: LD_INT 1
83249: NEG
83250: PUSH
83251: LD_INT 4
83253: NEG
83254: PUSH
83255: EMPTY
83256: LIST
83257: LIST
83258: PUSH
83259: LD_INT 1
83261: NEG
83262: PUSH
83263: LD_INT 5
83265: NEG
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: PUSH
83271: LD_INT 2
83273: PUSH
83274: LD_INT 3
83276: NEG
83277: PUSH
83278: EMPTY
83279: LIST
83280: LIST
83281: PUSH
83282: LD_INT 2
83284: NEG
83285: PUSH
83286: LD_INT 5
83288: NEG
83289: PUSH
83290: EMPTY
83291: LIST
83292: LIST
83293: PUSH
83294: LD_INT 3
83296: PUSH
83297: LD_INT 0
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: PUSH
83304: LD_INT 3
83306: PUSH
83307: LD_INT 1
83309: NEG
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 4
83317: PUSH
83318: LD_INT 0
83320: PUSH
83321: EMPTY
83322: LIST
83323: LIST
83324: PUSH
83325: LD_INT 4
83327: PUSH
83328: LD_INT 1
83330: PUSH
83331: EMPTY
83332: LIST
83333: LIST
83334: PUSH
83335: LD_INT 3
83337: PUSH
83338: LD_INT 1
83340: PUSH
83341: EMPTY
83342: LIST
83343: LIST
83344: PUSH
83345: LD_INT 2
83347: PUSH
83348: LD_INT 0
83350: PUSH
83351: EMPTY
83352: LIST
83353: LIST
83354: PUSH
83355: LD_INT 2
83357: PUSH
83358: LD_INT 1
83360: NEG
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 2
83368: PUSH
83369: LD_INT 2
83371: NEG
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 4
83379: PUSH
83380: LD_INT 2
83382: PUSH
83383: EMPTY
83384: LIST
83385: LIST
83386: PUSH
83387: LD_INT 4
83389: PUSH
83390: LD_INT 4
83392: PUSH
83393: EMPTY
83394: LIST
83395: LIST
83396: PUSH
83397: LD_INT 4
83399: PUSH
83400: LD_INT 3
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 5
83409: PUSH
83410: LD_INT 4
83412: PUSH
83413: EMPTY
83414: LIST
83415: LIST
83416: PUSH
83417: LD_INT 5
83419: PUSH
83420: LD_INT 5
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 4
83429: PUSH
83430: LD_INT 5
83432: PUSH
83433: EMPTY
83434: LIST
83435: LIST
83436: PUSH
83437: LD_INT 3
83439: PUSH
83440: LD_INT 4
83442: PUSH
83443: EMPTY
83444: LIST
83445: LIST
83446: PUSH
83447: LD_INT 3
83449: PUSH
83450: LD_INT 3
83452: PUSH
83453: EMPTY
83454: LIST
83455: LIST
83456: PUSH
83457: LD_INT 5
83459: PUSH
83460: LD_INT 3
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PUSH
83467: LD_INT 3
83469: PUSH
83470: LD_INT 5
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 0
83479: PUSH
83480: LD_INT 3
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: PUSH
83487: LD_INT 0
83489: PUSH
83490: LD_INT 2
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: LD_INT 1
83499: PUSH
83500: LD_INT 3
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PUSH
83507: LD_INT 1
83509: PUSH
83510: LD_INT 4
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: PUSH
83517: LD_INT 0
83519: PUSH
83520: LD_INT 4
83522: PUSH
83523: EMPTY
83524: LIST
83525: LIST
83526: PUSH
83527: LD_INT 1
83529: NEG
83530: PUSH
83531: LD_INT 3
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: LD_INT 1
83540: NEG
83541: PUSH
83542: LD_INT 2
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 2
83551: PUSH
83552: LD_INT 4
83554: PUSH
83555: EMPTY
83556: LIST
83557: LIST
83558: PUSH
83559: LD_INT 2
83561: NEG
83562: PUSH
83563: LD_INT 2
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 4
83572: NEG
83573: PUSH
83574: LD_INT 0
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: LD_INT 4
83583: NEG
83584: PUSH
83585: LD_INT 1
83587: NEG
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 3
83595: NEG
83596: PUSH
83597: LD_INT 0
83599: PUSH
83600: EMPTY
83601: LIST
83602: LIST
83603: PUSH
83604: LD_INT 3
83606: NEG
83607: PUSH
83608: LD_INT 1
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 4
83617: NEG
83618: PUSH
83619: LD_INT 1
83621: PUSH
83622: EMPTY
83623: LIST
83624: LIST
83625: PUSH
83626: LD_INT 5
83628: NEG
83629: PUSH
83630: LD_INT 0
83632: PUSH
83633: EMPTY
83634: LIST
83635: LIST
83636: PUSH
83637: LD_INT 5
83639: NEG
83640: PUSH
83641: LD_INT 1
83643: NEG
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 5
83651: NEG
83652: PUSH
83653: LD_INT 2
83655: NEG
83656: PUSH
83657: EMPTY
83658: LIST
83659: LIST
83660: PUSH
83661: LD_INT 3
83663: NEG
83664: PUSH
83665: LD_INT 2
83667: PUSH
83668: EMPTY
83669: LIST
83670: LIST
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: LIST
83676: LIST
83677: LIST
83678: LIST
83679: LIST
83680: LIST
83681: LIST
83682: LIST
83683: LIST
83684: LIST
83685: LIST
83686: LIST
83687: LIST
83688: LIST
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: LIST
83710: LIST
83711: LIST
83712: LIST
83713: LIST
83714: LIST
83715: LIST
83716: LIST
83717: LIST
83718: ST_TO_ADDR
// end ; end ;
83719: GO 83722
83721: POP
// case btype of b_depot , b_warehouse :
83722: LD_VAR 0 1
83726: PUSH
83727: LD_INT 0
83729: DOUBLE
83730: EQUAL
83731: IFTRUE 83741
83733: LD_INT 1
83735: DOUBLE
83736: EQUAL
83737: IFTRUE 83741
83739: GO 83942
83741: POP
// case nation of nation_american :
83742: LD_VAR 0 5
83746: PUSH
83747: LD_INT 1
83749: DOUBLE
83750: EQUAL
83751: IFTRUE 83755
83753: GO 83811
83755: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83756: LD_ADDR_VAR 0 9
83760: PUSH
83761: LD_VAR 0 11
83765: PUSH
83766: LD_VAR 0 12
83770: PUSH
83771: LD_VAR 0 13
83775: PUSH
83776: LD_VAR 0 14
83780: PUSH
83781: LD_VAR 0 15
83785: PUSH
83786: LD_VAR 0 16
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: PUSH
83799: LD_VAR 0 4
83803: PUSH
83804: LD_INT 1
83806: PLUS
83807: ARRAY
83808: ST_TO_ADDR
83809: GO 83940
83811: LD_INT 2
83813: DOUBLE
83814: EQUAL
83815: IFTRUE 83819
83817: GO 83875
83819: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83820: LD_ADDR_VAR 0 9
83824: PUSH
83825: LD_VAR 0 17
83829: PUSH
83830: LD_VAR 0 18
83834: PUSH
83835: LD_VAR 0 19
83839: PUSH
83840: LD_VAR 0 20
83844: PUSH
83845: LD_VAR 0 21
83849: PUSH
83850: LD_VAR 0 22
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: LIST
83859: LIST
83860: LIST
83861: LIST
83862: PUSH
83863: LD_VAR 0 4
83867: PUSH
83868: LD_INT 1
83870: PLUS
83871: ARRAY
83872: ST_TO_ADDR
83873: GO 83940
83875: LD_INT 3
83877: DOUBLE
83878: EQUAL
83879: IFTRUE 83883
83881: GO 83939
83883: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83884: LD_ADDR_VAR 0 9
83888: PUSH
83889: LD_VAR 0 23
83893: PUSH
83894: LD_VAR 0 24
83898: PUSH
83899: LD_VAR 0 25
83903: PUSH
83904: LD_VAR 0 26
83908: PUSH
83909: LD_VAR 0 27
83913: PUSH
83914: LD_VAR 0 28
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: PUSH
83927: LD_VAR 0 4
83931: PUSH
83932: LD_INT 1
83934: PLUS
83935: ARRAY
83936: ST_TO_ADDR
83937: GO 83940
83939: POP
83940: GO 84495
83942: LD_INT 2
83944: DOUBLE
83945: EQUAL
83946: IFTRUE 83956
83948: LD_INT 3
83950: DOUBLE
83951: EQUAL
83952: IFTRUE 83956
83954: GO 84012
83956: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83957: LD_ADDR_VAR 0 9
83961: PUSH
83962: LD_VAR 0 29
83966: PUSH
83967: LD_VAR 0 30
83971: PUSH
83972: LD_VAR 0 31
83976: PUSH
83977: LD_VAR 0 32
83981: PUSH
83982: LD_VAR 0 33
83986: PUSH
83987: LD_VAR 0 34
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: PUSH
84000: LD_VAR 0 4
84004: PUSH
84005: LD_INT 1
84007: PLUS
84008: ARRAY
84009: ST_TO_ADDR
84010: GO 84495
84012: LD_INT 16
84014: DOUBLE
84015: EQUAL
84016: IFTRUE 84074
84018: LD_INT 17
84020: DOUBLE
84021: EQUAL
84022: IFTRUE 84074
84024: LD_INT 18
84026: DOUBLE
84027: EQUAL
84028: IFTRUE 84074
84030: LD_INT 19
84032: DOUBLE
84033: EQUAL
84034: IFTRUE 84074
84036: LD_INT 22
84038: DOUBLE
84039: EQUAL
84040: IFTRUE 84074
84042: LD_INT 20
84044: DOUBLE
84045: EQUAL
84046: IFTRUE 84074
84048: LD_INT 21
84050: DOUBLE
84051: EQUAL
84052: IFTRUE 84074
84054: LD_INT 23
84056: DOUBLE
84057: EQUAL
84058: IFTRUE 84074
84060: LD_INT 24
84062: DOUBLE
84063: EQUAL
84064: IFTRUE 84074
84066: LD_INT 25
84068: DOUBLE
84069: EQUAL
84070: IFTRUE 84074
84072: GO 84130
84074: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84075: LD_ADDR_VAR 0 9
84079: PUSH
84080: LD_VAR 0 35
84084: PUSH
84085: LD_VAR 0 36
84089: PUSH
84090: LD_VAR 0 37
84094: PUSH
84095: LD_VAR 0 38
84099: PUSH
84100: LD_VAR 0 39
84104: PUSH
84105: LD_VAR 0 40
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: LIST
84114: LIST
84115: LIST
84116: LIST
84117: PUSH
84118: LD_VAR 0 4
84122: PUSH
84123: LD_INT 1
84125: PLUS
84126: ARRAY
84127: ST_TO_ADDR
84128: GO 84495
84130: LD_INT 6
84132: DOUBLE
84133: EQUAL
84134: IFTRUE 84186
84136: LD_INT 7
84138: DOUBLE
84139: EQUAL
84140: IFTRUE 84186
84142: LD_INT 8
84144: DOUBLE
84145: EQUAL
84146: IFTRUE 84186
84148: LD_INT 13
84150: DOUBLE
84151: EQUAL
84152: IFTRUE 84186
84154: LD_INT 12
84156: DOUBLE
84157: EQUAL
84158: IFTRUE 84186
84160: LD_INT 15
84162: DOUBLE
84163: EQUAL
84164: IFTRUE 84186
84166: LD_INT 11
84168: DOUBLE
84169: EQUAL
84170: IFTRUE 84186
84172: LD_INT 14
84174: DOUBLE
84175: EQUAL
84176: IFTRUE 84186
84178: LD_INT 10
84180: DOUBLE
84181: EQUAL
84182: IFTRUE 84186
84184: GO 84242
84186: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84187: LD_ADDR_VAR 0 9
84191: PUSH
84192: LD_VAR 0 41
84196: PUSH
84197: LD_VAR 0 42
84201: PUSH
84202: LD_VAR 0 43
84206: PUSH
84207: LD_VAR 0 44
84211: PUSH
84212: LD_VAR 0 45
84216: PUSH
84217: LD_VAR 0 46
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: PUSH
84230: LD_VAR 0 4
84234: PUSH
84235: LD_INT 1
84237: PLUS
84238: ARRAY
84239: ST_TO_ADDR
84240: GO 84495
84242: LD_INT 36
84244: DOUBLE
84245: EQUAL
84246: IFTRUE 84250
84248: GO 84306
84250: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84251: LD_ADDR_VAR 0 9
84255: PUSH
84256: LD_VAR 0 47
84260: PUSH
84261: LD_VAR 0 48
84265: PUSH
84266: LD_VAR 0 49
84270: PUSH
84271: LD_VAR 0 50
84275: PUSH
84276: LD_VAR 0 51
84280: PUSH
84281: LD_VAR 0 52
84285: PUSH
84286: EMPTY
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: PUSH
84294: LD_VAR 0 4
84298: PUSH
84299: LD_INT 1
84301: PLUS
84302: ARRAY
84303: ST_TO_ADDR
84304: GO 84495
84306: LD_INT 4
84308: DOUBLE
84309: EQUAL
84310: IFTRUE 84332
84312: LD_INT 5
84314: DOUBLE
84315: EQUAL
84316: IFTRUE 84332
84318: LD_INT 34
84320: DOUBLE
84321: EQUAL
84322: IFTRUE 84332
84324: LD_INT 37
84326: DOUBLE
84327: EQUAL
84328: IFTRUE 84332
84330: GO 84388
84332: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84333: LD_ADDR_VAR 0 9
84337: PUSH
84338: LD_VAR 0 53
84342: PUSH
84343: LD_VAR 0 54
84347: PUSH
84348: LD_VAR 0 55
84352: PUSH
84353: LD_VAR 0 56
84357: PUSH
84358: LD_VAR 0 57
84362: PUSH
84363: LD_VAR 0 58
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: LIST
84374: LIST
84375: PUSH
84376: LD_VAR 0 4
84380: PUSH
84381: LD_INT 1
84383: PLUS
84384: ARRAY
84385: ST_TO_ADDR
84386: GO 84495
84388: LD_INT 31
84390: DOUBLE
84391: EQUAL
84392: IFTRUE 84438
84394: LD_INT 32
84396: DOUBLE
84397: EQUAL
84398: IFTRUE 84438
84400: LD_INT 33
84402: DOUBLE
84403: EQUAL
84404: IFTRUE 84438
84406: LD_INT 27
84408: DOUBLE
84409: EQUAL
84410: IFTRUE 84438
84412: LD_INT 26
84414: DOUBLE
84415: EQUAL
84416: IFTRUE 84438
84418: LD_INT 28
84420: DOUBLE
84421: EQUAL
84422: IFTRUE 84438
84424: LD_INT 29
84426: DOUBLE
84427: EQUAL
84428: IFTRUE 84438
84430: LD_INT 30
84432: DOUBLE
84433: EQUAL
84434: IFTRUE 84438
84436: GO 84494
84438: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
84439: LD_ADDR_VAR 0 9
84443: PUSH
84444: LD_VAR 0 59
84448: PUSH
84449: LD_VAR 0 60
84453: PUSH
84454: LD_VAR 0 61
84458: PUSH
84459: LD_VAR 0 62
84463: PUSH
84464: LD_VAR 0 63
84468: PUSH
84469: LD_VAR 0 64
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: PUSH
84482: LD_VAR 0 4
84486: PUSH
84487: LD_INT 1
84489: PLUS
84490: ARRAY
84491: ST_TO_ADDR
84492: GO 84495
84494: POP
// temp_list2 = [ ] ;
84495: LD_ADDR_VAR 0 10
84499: PUSH
84500: EMPTY
84501: ST_TO_ADDR
// for i in temp_list do
84502: LD_ADDR_VAR 0 8
84506: PUSH
84507: LD_VAR 0 9
84511: PUSH
84512: FOR_IN
84513: IFFALSE 84565
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84515: LD_ADDR_VAR 0 10
84519: PUSH
84520: LD_VAR 0 10
84524: PUSH
84525: LD_VAR 0 8
84529: PUSH
84530: LD_INT 1
84532: ARRAY
84533: PUSH
84534: LD_VAR 0 2
84538: PLUS
84539: PUSH
84540: LD_VAR 0 8
84544: PUSH
84545: LD_INT 2
84547: ARRAY
84548: PUSH
84549: LD_VAR 0 3
84553: PLUS
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: PUSH
84559: EMPTY
84560: LIST
84561: ADD
84562: ST_TO_ADDR
84563: GO 84512
84565: POP
84566: POP
// result = temp_list2 ;
84567: LD_ADDR_VAR 0 7
84571: PUSH
84572: LD_VAR 0 10
84576: ST_TO_ADDR
// end ;
84577: LD_VAR 0 7
84581: RET
// export function EnemyInRange ( unit , dist ) ; begin
84582: LD_INT 0
84584: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84585: LD_ADDR_VAR 0 3
84589: PUSH
84590: LD_VAR 0 1
84594: PPUSH
84595: CALL_OW 255
84599: PPUSH
84600: LD_VAR 0 1
84604: PPUSH
84605: CALL_OW 250
84609: PPUSH
84610: LD_VAR 0 1
84614: PPUSH
84615: CALL_OW 251
84619: PPUSH
84620: LD_VAR 0 2
84624: PPUSH
84625: CALL 57984 0 4
84629: PUSH
84630: LD_INT 4
84632: ARRAY
84633: ST_TO_ADDR
// end ;
84634: LD_VAR 0 3
84638: RET
// export function PlayerSeeMe ( unit ) ; begin
84639: LD_INT 0
84641: PPUSH
// result := See ( your_side , unit ) ;
84642: LD_ADDR_VAR 0 2
84646: PUSH
84647: LD_OWVAR 2
84651: PPUSH
84652: LD_VAR 0 1
84656: PPUSH
84657: CALL_OW 292
84661: ST_TO_ADDR
// end ;
84662: LD_VAR 0 2
84666: RET
// export function ReverseDir ( unit ) ; begin
84667: LD_INT 0
84669: PPUSH
// if not unit then
84670: LD_VAR 0 1
84674: NOT
84675: IFFALSE 84679
// exit ;
84677: GO 84702
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84679: LD_ADDR_VAR 0 2
84683: PUSH
84684: LD_VAR 0 1
84688: PPUSH
84689: CALL_OW 254
84693: PUSH
84694: LD_INT 3
84696: PLUS
84697: PUSH
84698: LD_INT 6
84700: MOD
84701: ST_TO_ADDR
// end ;
84702: LD_VAR 0 2
84706: RET
// export function ReverseArray ( array ) ; var i ; begin
84707: LD_INT 0
84709: PPUSH
84710: PPUSH
// if not array then
84711: LD_VAR 0 1
84715: NOT
84716: IFFALSE 84720
// exit ;
84718: GO 84775
// result := [ ] ;
84720: LD_ADDR_VAR 0 2
84724: PUSH
84725: EMPTY
84726: ST_TO_ADDR
// for i := array downto 1 do
84727: LD_ADDR_VAR 0 3
84731: PUSH
84732: DOUBLE
84733: LD_VAR 0 1
84737: INC
84738: ST_TO_ADDR
84739: LD_INT 1
84741: PUSH
84742: FOR_DOWNTO
84743: IFFALSE 84773
// result := Join ( result , array [ i ] ) ;
84745: LD_ADDR_VAR 0 2
84749: PUSH
84750: LD_VAR 0 2
84754: PPUSH
84755: LD_VAR 0 1
84759: PUSH
84760: LD_VAR 0 3
84764: ARRAY
84765: PPUSH
84766: CALL 89400 0 2
84770: ST_TO_ADDR
84771: GO 84742
84773: POP
84774: POP
// end ;
84775: LD_VAR 0 2
84779: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
84780: LD_INT 0
84782: PPUSH
84783: PPUSH
84784: PPUSH
84785: PPUSH
84786: PPUSH
84787: PPUSH
// if not unit or not hexes then
84788: LD_VAR 0 1
84792: NOT
84793: PUSH
84794: LD_VAR 0 2
84798: NOT
84799: OR
84800: IFFALSE 84804
// exit ;
84802: GO 84927
// dist := 9999 ;
84804: LD_ADDR_VAR 0 5
84808: PUSH
84809: LD_INT 9999
84811: ST_TO_ADDR
// for i = 1 to hexes do
84812: LD_ADDR_VAR 0 4
84816: PUSH
84817: DOUBLE
84818: LD_INT 1
84820: DEC
84821: ST_TO_ADDR
84822: LD_VAR 0 2
84826: PUSH
84827: FOR_TO
84828: IFFALSE 84915
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84830: LD_ADDR_VAR 0 6
84834: PUSH
84835: LD_VAR 0 1
84839: PPUSH
84840: LD_VAR 0 2
84844: PUSH
84845: LD_VAR 0 4
84849: ARRAY
84850: PUSH
84851: LD_INT 1
84853: ARRAY
84854: PPUSH
84855: LD_VAR 0 2
84859: PUSH
84860: LD_VAR 0 4
84864: ARRAY
84865: PUSH
84866: LD_INT 2
84868: ARRAY
84869: PPUSH
84870: CALL_OW 297
84874: ST_TO_ADDR
// if tdist < dist then
84875: LD_VAR 0 6
84879: PUSH
84880: LD_VAR 0 5
84884: LESS
84885: IFFALSE 84913
// begin hex := hexes [ i ] ;
84887: LD_ADDR_VAR 0 8
84891: PUSH
84892: LD_VAR 0 2
84896: PUSH
84897: LD_VAR 0 4
84901: ARRAY
84902: ST_TO_ADDR
// dist := tdist ;
84903: LD_ADDR_VAR 0 5
84907: PUSH
84908: LD_VAR 0 6
84912: ST_TO_ADDR
// end ; end ;
84913: GO 84827
84915: POP
84916: POP
// result := hex ;
84917: LD_ADDR_VAR 0 3
84921: PUSH
84922: LD_VAR 0 8
84926: ST_TO_ADDR
// end ;
84927: LD_VAR 0 3
84931: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84932: LD_INT 0
84934: PPUSH
84935: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84936: LD_VAR 0 1
84940: NOT
84941: PUSH
84942: LD_VAR 0 1
84946: PUSH
84947: LD_INT 21
84949: PUSH
84950: LD_INT 2
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 23
84959: PUSH
84960: LD_INT 2
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: EMPTY
84968: LIST
84969: LIST
84970: PPUSH
84971: CALL_OW 69
84975: IN
84976: NOT
84977: OR
84978: IFFALSE 84982
// exit ;
84980: GO 85029
// for i = 1 to 3 do
84982: LD_ADDR_VAR 0 3
84986: PUSH
84987: DOUBLE
84988: LD_INT 1
84990: DEC
84991: ST_TO_ADDR
84992: LD_INT 3
84994: PUSH
84995: FOR_TO
84996: IFFALSE 85027
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84998: LD_VAR 0 1
85002: PPUSH
85003: CALL_OW 250
85007: PPUSH
85008: LD_VAR 0 1
85012: PPUSH
85013: CALL_OW 251
85017: PPUSH
85018: LD_INT 1
85020: PPUSH
85021: CALL_OW 453
85025: GO 84995
85027: POP
85028: POP
// end ;
85029: LD_VAR 0 2
85033: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
85034: LD_INT 0
85036: PPUSH
85037: PPUSH
85038: PPUSH
85039: PPUSH
85040: PPUSH
85041: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
85042: LD_VAR 0 1
85046: NOT
85047: PUSH
85048: LD_VAR 0 2
85052: NOT
85053: OR
85054: PUSH
85055: LD_VAR 0 1
85059: PPUSH
85060: CALL_OW 314
85064: OR
85065: IFFALSE 85069
// exit ;
85067: GO 85510
// x := GetX ( enemy_unit ) ;
85069: LD_ADDR_VAR 0 7
85073: PUSH
85074: LD_VAR 0 2
85078: PPUSH
85079: CALL_OW 250
85083: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85084: LD_ADDR_VAR 0 8
85088: PUSH
85089: LD_VAR 0 2
85093: PPUSH
85094: CALL_OW 251
85098: ST_TO_ADDR
// if not x or not y then
85099: LD_VAR 0 7
85103: NOT
85104: PUSH
85105: LD_VAR 0 8
85109: NOT
85110: OR
85111: IFFALSE 85115
// exit ;
85113: GO 85510
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85115: LD_ADDR_VAR 0 6
85119: PUSH
85120: LD_VAR 0 7
85124: PPUSH
85125: LD_INT 0
85127: PPUSH
85128: LD_INT 4
85130: PPUSH
85131: CALL_OW 272
85135: PUSH
85136: LD_VAR 0 8
85140: PPUSH
85141: LD_INT 0
85143: PPUSH
85144: LD_INT 4
85146: PPUSH
85147: CALL_OW 273
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: LD_VAR 0 7
85160: PPUSH
85161: LD_INT 1
85163: PPUSH
85164: LD_INT 4
85166: PPUSH
85167: CALL_OW 272
85171: PUSH
85172: LD_VAR 0 8
85176: PPUSH
85177: LD_INT 1
85179: PPUSH
85180: LD_INT 4
85182: PPUSH
85183: CALL_OW 273
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PUSH
85192: LD_VAR 0 7
85196: PPUSH
85197: LD_INT 2
85199: PPUSH
85200: LD_INT 4
85202: PPUSH
85203: CALL_OW 272
85207: PUSH
85208: LD_VAR 0 8
85212: PPUSH
85213: LD_INT 2
85215: PPUSH
85216: LD_INT 4
85218: PPUSH
85219: CALL_OW 273
85223: PUSH
85224: EMPTY
85225: LIST
85226: LIST
85227: PUSH
85228: LD_VAR 0 7
85232: PPUSH
85233: LD_INT 3
85235: PPUSH
85236: LD_INT 4
85238: PPUSH
85239: CALL_OW 272
85243: PUSH
85244: LD_VAR 0 8
85248: PPUSH
85249: LD_INT 3
85251: PPUSH
85252: LD_INT 4
85254: PPUSH
85255: CALL_OW 273
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PUSH
85264: LD_VAR 0 7
85268: PPUSH
85269: LD_INT 4
85271: PPUSH
85272: LD_INT 4
85274: PPUSH
85275: CALL_OW 272
85279: PUSH
85280: LD_VAR 0 8
85284: PPUSH
85285: LD_INT 4
85287: PPUSH
85288: LD_INT 4
85290: PPUSH
85291: CALL_OW 273
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PUSH
85300: LD_VAR 0 7
85304: PPUSH
85305: LD_INT 5
85307: PPUSH
85308: LD_INT 4
85310: PPUSH
85311: CALL_OW 272
85315: PUSH
85316: LD_VAR 0 8
85320: PPUSH
85321: LD_INT 5
85323: PPUSH
85324: LD_INT 4
85326: PPUSH
85327: CALL_OW 273
85331: PUSH
85332: EMPTY
85333: LIST
85334: LIST
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: ST_TO_ADDR
// for i = tmp downto 1 do
85344: LD_ADDR_VAR 0 4
85348: PUSH
85349: DOUBLE
85350: LD_VAR 0 6
85354: INC
85355: ST_TO_ADDR
85356: LD_INT 1
85358: PUSH
85359: FOR_DOWNTO
85360: IFFALSE 85461
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85362: LD_VAR 0 6
85366: PUSH
85367: LD_VAR 0 4
85371: ARRAY
85372: PUSH
85373: LD_INT 1
85375: ARRAY
85376: PPUSH
85377: LD_VAR 0 6
85381: PUSH
85382: LD_VAR 0 4
85386: ARRAY
85387: PUSH
85388: LD_INT 2
85390: ARRAY
85391: PPUSH
85392: CALL_OW 488
85396: NOT
85397: PUSH
85398: LD_VAR 0 6
85402: PUSH
85403: LD_VAR 0 4
85407: ARRAY
85408: PUSH
85409: LD_INT 1
85411: ARRAY
85412: PPUSH
85413: LD_VAR 0 6
85417: PUSH
85418: LD_VAR 0 4
85422: ARRAY
85423: PUSH
85424: LD_INT 2
85426: ARRAY
85427: PPUSH
85428: CALL_OW 428
85432: PUSH
85433: LD_INT 0
85435: NONEQUAL
85436: OR
85437: IFFALSE 85459
// tmp := Delete ( tmp , i ) ;
85439: LD_ADDR_VAR 0 6
85443: PUSH
85444: LD_VAR 0 6
85448: PPUSH
85449: LD_VAR 0 4
85453: PPUSH
85454: CALL_OW 3
85458: ST_TO_ADDR
85459: GO 85359
85461: POP
85462: POP
// j := GetClosestHex ( unit , tmp ) ;
85463: LD_ADDR_VAR 0 5
85467: PUSH
85468: LD_VAR 0 1
85472: PPUSH
85473: LD_VAR 0 6
85477: PPUSH
85478: CALL 84780 0 2
85482: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85483: LD_VAR 0 1
85487: PPUSH
85488: LD_VAR 0 5
85492: PUSH
85493: LD_INT 1
85495: ARRAY
85496: PPUSH
85497: LD_VAR 0 5
85501: PUSH
85502: LD_INT 2
85504: ARRAY
85505: PPUSH
85506: CALL_OW 111
// end ;
85510: LD_VAR 0 3
85514: RET
// export function PrepareApemanSoldier ( ) ; begin
85515: LD_INT 0
85517: PPUSH
// uc_nation := 0 ;
85518: LD_ADDR_OWVAR 21
85522: PUSH
85523: LD_INT 0
85525: ST_TO_ADDR
// hc_sex := sex_male ;
85526: LD_ADDR_OWVAR 27
85530: PUSH
85531: LD_INT 1
85533: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
85534: LD_ADDR_OWVAR 28
85538: PUSH
85539: LD_INT 15
85541: ST_TO_ADDR
// hc_gallery :=  ;
85542: LD_ADDR_OWVAR 33
85546: PUSH
85547: LD_STRING 
85549: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85550: LD_ADDR_OWVAR 31
85554: PUSH
85555: LD_INT 0
85557: PPUSH
85558: LD_INT 3
85560: PPUSH
85561: CALL_OW 12
85565: PUSH
85566: LD_INT 0
85568: PPUSH
85569: LD_INT 3
85571: PPUSH
85572: CALL_OW 12
85576: PUSH
85577: LD_INT 0
85579: PUSH
85580: LD_INT 0
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: ST_TO_ADDR
// end ;
85589: LD_VAR 0 1
85593: RET
// export function PrepareApemanEngineer ( ) ; begin
85594: LD_INT 0
85596: PPUSH
// uc_nation := 0 ;
85597: LD_ADDR_OWVAR 21
85601: PUSH
85602: LD_INT 0
85604: ST_TO_ADDR
// hc_sex := sex_male ;
85605: LD_ADDR_OWVAR 27
85609: PUSH
85610: LD_INT 1
85612: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
85613: LD_ADDR_OWVAR 28
85617: PUSH
85618: LD_INT 16
85620: ST_TO_ADDR
// hc_gallery :=  ;
85621: LD_ADDR_OWVAR 33
85625: PUSH
85626: LD_STRING 
85628: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85629: LD_ADDR_OWVAR 31
85633: PUSH
85634: LD_INT 0
85636: PPUSH
85637: LD_INT 3
85639: PPUSH
85640: CALL_OW 12
85644: PUSH
85645: LD_INT 0
85647: PPUSH
85648: LD_INT 3
85650: PPUSH
85651: CALL_OW 12
85655: PUSH
85656: LD_INT 0
85658: PUSH
85659: LD_INT 0
85661: PUSH
85662: EMPTY
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: ST_TO_ADDR
// end ;
85668: LD_VAR 0 1
85672: RET
// export function PrepareApeman ( agressivity ) ; begin
85673: LD_INT 0
85675: PPUSH
// uc_side := 0 ;
85676: LD_ADDR_OWVAR 20
85680: PUSH
85681: LD_INT 0
85683: ST_TO_ADDR
// uc_nation := 0 ;
85684: LD_ADDR_OWVAR 21
85688: PUSH
85689: LD_INT 0
85691: ST_TO_ADDR
// hc_sex := sex_male ;
85692: LD_ADDR_OWVAR 27
85696: PUSH
85697: LD_INT 1
85699: ST_TO_ADDR
// hc_class := class_apeman ;
85700: LD_ADDR_OWVAR 28
85704: PUSH
85705: LD_INT 12
85707: ST_TO_ADDR
// hc_gallery :=  ;
85708: LD_ADDR_OWVAR 33
85712: PUSH
85713: LD_STRING 
85715: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85716: LD_ADDR_OWVAR 35
85720: PUSH
85721: LD_VAR 0 1
85725: NEG
85726: PPUSH
85727: LD_VAR 0 1
85731: PPUSH
85732: CALL_OW 12
85736: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85737: LD_ADDR_OWVAR 31
85741: PUSH
85742: LD_INT 0
85744: PPUSH
85745: LD_INT 3
85747: PPUSH
85748: CALL_OW 12
85752: PUSH
85753: LD_INT 0
85755: PPUSH
85756: LD_INT 3
85758: PPUSH
85759: CALL_OW 12
85763: PUSH
85764: LD_INT 0
85766: PUSH
85767: LD_INT 0
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: ST_TO_ADDR
// end ;
85776: LD_VAR 0 2
85780: RET
// export function PrepareTiger ( agressivity ) ; begin
85781: LD_INT 0
85783: PPUSH
// uc_side := 0 ;
85784: LD_ADDR_OWVAR 20
85788: PUSH
85789: LD_INT 0
85791: ST_TO_ADDR
// uc_nation := 0 ;
85792: LD_ADDR_OWVAR 21
85796: PUSH
85797: LD_INT 0
85799: ST_TO_ADDR
// hc_class := class_tiger ;
85800: LD_ADDR_OWVAR 28
85804: PUSH
85805: LD_INT 14
85807: ST_TO_ADDR
// hc_gallery :=  ;
85808: LD_ADDR_OWVAR 33
85812: PUSH
85813: LD_STRING 
85815: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85816: LD_ADDR_OWVAR 35
85820: PUSH
85821: LD_VAR 0 1
85825: NEG
85826: PPUSH
85827: LD_VAR 0 1
85831: PPUSH
85832: CALL_OW 12
85836: ST_TO_ADDR
// end ;
85837: LD_VAR 0 2
85841: RET
// export function PrepareEnchidna ( ) ; begin
85842: LD_INT 0
85844: PPUSH
// uc_side := 0 ;
85845: LD_ADDR_OWVAR 20
85849: PUSH
85850: LD_INT 0
85852: ST_TO_ADDR
// uc_nation := 0 ;
85853: LD_ADDR_OWVAR 21
85857: PUSH
85858: LD_INT 0
85860: ST_TO_ADDR
// hc_class := class_baggie ;
85861: LD_ADDR_OWVAR 28
85865: PUSH
85866: LD_INT 13
85868: ST_TO_ADDR
// hc_gallery :=  ;
85869: LD_ADDR_OWVAR 33
85873: PUSH
85874: LD_STRING 
85876: ST_TO_ADDR
// end ;
85877: LD_VAR 0 1
85881: RET
// export function PrepareFrog ( ) ; begin
85882: LD_INT 0
85884: PPUSH
// uc_side := 0 ;
85885: LD_ADDR_OWVAR 20
85889: PUSH
85890: LD_INT 0
85892: ST_TO_ADDR
// uc_nation := 0 ;
85893: LD_ADDR_OWVAR 21
85897: PUSH
85898: LD_INT 0
85900: ST_TO_ADDR
// hc_class := class_frog ;
85901: LD_ADDR_OWVAR 28
85905: PUSH
85906: LD_INT 19
85908: ST_TO_ADDR
// hc_gallery :=  ;
85909: LD_ADDR_OWVAR 33
85913: PUSH
85914: LD_STRING 
85916: ST_TO_ADDR
// end ;
85917: LD_VAR 0 1
85921: RET
// export function PrepareFish ( ) ; begin
85922: LD_INT 0
85924: PPUSH
// uc_side := 0 ;
85925: LD_ADDR_OWVAR 20
85929: PUSH
85930: LD_INT 0
85932: ST_TO_ADDR
// uc_nation := 0 ;
85933: LD_ADDR_OWVAR 21
85937: PUSH
85938: LD_INT 0
85940: ST_TO_ADDR
// hc_class := class_fish ;
85941: LD_ADDR_OWVAR 28
85945: PUSH
85946: LD_INT 20
85948: ST_TO_ADDR
// hc_gallery :=  ;
85949: LD_ADDR_OWVAR 33
85953: PUSH
85954: LD_STRING 
85956: ST_TO_ADDR
// end ;
85957: LD_VAR 0 1
85961: RET
// export function PrepareBird ( ) ; begin
85962: LD_INT 0
85964: PPUSH
// uc_side := 0 ;
85965: LD_ADDR_OWVAR 20
85969: PUSH
85970: LD_INT 0
85972: ST_TO_ADDR
// uc_nation := 0 ;
85973: LD_ADDR_OWVAR 21
85977: PUSH
85978: LD_INT 0
85980: ST_TO_ADDR
// hc_class := class_phororhacos ;
85981: LD_ADDR_OWVAR 28
85985: PUSH
85986: LD_INT 18
85988: ST_TO_ADDR
// hc_gallery :=  ;
85989: LD_ADDR_OWVAR 33
85993: PUSH
85994: LD_STRING 
85996: ST_TO_ADDR
// end ;
85997: LD_VAR 0 1
86001: RET
// export function PrepareHorse ( ) ; begin
86002: LD_INT 0
86004: PPUSH
// uc_side := 0 ;
86005: LD_ADDR_OWVAR 20
86009: PUSH
86010: LD_INT 0
86012: ST_TO_ADDR
// uc_nation := 0 ;
86013: LD_ADDR_OWVAR 21
86017: PUSH
86018: LD_INT 0
86020: ST_TO_ADDR
// hc_class := class_horse ;
86021: LD_ADDR_OWVAR 28
86025: PUSH
86026: LD_INT 21
86028: ST_TO_ADDR
// hc_gallery :=  ;
86029: LD_ADDR_OWVAR 33
86033: PUSH
86034: LD_STRING 
86036: ST_TO_ADDR
// end ;
86037: LD_VAR 0 1
86041: RET
// export function PrepareMastodont ( ) ; begin
86042: LD_INT 0
86044: PPUSH
// uc_side := 0 ;
86045: LD_ADDR_OWVAR 20
86049: PUSH
86050: LD_INT 0
86052: ST_TO_ADDR
// uc_nation := 0 ;
86053: LD_ADDR_OWVAR 21
86057: PUSH
86058: LD_INT 0
86060: ST_TO_ADDR
// vc_chassis := class_mastodont ;
86061: LD_ADDR_OWVAR 37
86065: PUSH
86066: LD_INT 31
86068: ST_TO_ADDR
// vc_control := control_rider ;
86069: LD_ADDR_OWVAR 38
86073: PUSH
86074: LD_INT 4
86076: ST_TO_ADDR
// end ;
86077: LD_VAR 0 1
86081: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
86082: LD_INT 0
86084: PPUSH
86085: PPUSH
86086: PPUSH
// uc_side = 0 ;
86087: LD_ADDR_OWVAR 20
86091: PUSH
86092: LD_INT 0
86094: ST_TO_ADDR
// uc_nation = 0 ;
86095: LD_ADDR_OWVAR 21
86099: PUSH
86100: LD_INT 0
86102: ST_TO_ADDR
// InitHc_All ( ) ;
86103: CALL_OW 584
// InitVc ;
86107: CALL_OW 20
// if mastodonts then
86111: LD_VAR 0 6
86115: IFFALSE 86182
// for i = 1 to mastodonts do
86117: LD_ADDR_VAR 0 11
86121: PUSH
86122: DOUBLE
86123: LD_INT 1
86125: DEC
86126: ST_TO_ADDR
86127: LD_VAR 0 6
86131: PUSH
86132: FOR_TO
86133: IFFALSE 86180
// begin vc_chassis := 31 ;
86135: LD_ADDR_OWVAR 37
86139: PUSH
86140: LD_INT 31
86142: ST_TO_ADDR
// vc_control := control_rider ;
86143: LD_ADDR_OWVAR 38
86147: PUSH
86148: LD_INT 4
86150: ST_TO_ADDR
// animal := CreateVehicle ;
86151: LD_ADDR_VAR 0 12
86155: PUSH
86156: CALL_OW 45
86160: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86161: LD_VAR 0 12
86165: PPUSH
86166: LD_VAR 0 8
86170: PPUSH
86171: LD_INT 0
86173: PPUSH
86174: CALL 88317 0 3
// end ;
86178: GO 86132
86180: POP
86181: POP
// if horses then
86182: LD_VAR 0 5
86186: IFFALSE 86253
// for i = 1 to horses do
86188: LD_ADDR_VAR 0 11
86192: PUSH
86193: DOUBLE
86194: LD_INT 1
86196: DEC
86197: ST_TO_ADDR
86198: LD_VAR 0 5
86202: PUSH
86203: FOR_TO
86204: IFFALSE 86251
// begin hc_class := 21 ;
86206: LD_ADDR_OWVAR 28
86210: PUSH
86211: LD_INT 21
86213: ST_TO_ADDR
// hc_gallery :=  ;
86214: LD_ADDR_OWVAR 33
86218: PUSH
86219: LD_STRING 
86221: ST_TO_ADDR
// animal := CreateHuman ;
86222: LD_ADDR_VAR 0 12
86226: PUSH
86227: CALL_OW 44
86231: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86232: LD_VAR 0 12
86236: PPUSH
86237: LD_VAR 0 8
86241: PPUSH
86242: LD_INT 0
86244: PPUSH
86245: CALL 88317 0 3
// end ;
86249: GO 86203
86251: POP
86252: POP
// if birds then
86253: LD_VAR 0 1
86257: IFFALSE 86324
// for i = 1 to birds do
86259: LD_ADDR_VAR 0 11
86263: PUSH
86264: DOUBLE
86265: LD_INT 1
86267: DEC
86268: ST_TO_ADDR
86269: LD_VAR 0 1
86273: PUSH
86274: FOR_TO
86275: IFFALSE 86322
// begin hc_class = 18 ;
86277: LD_ADDR_OWVAR 28
86281: PUSH
86282: LD_INT 18
86284: ST_TO_ADDR
// hc_gallery =  ;
86285: LD_ADDR_OWVAR 33
86289: PUSH
86290: LD_STRING 
86292: ST_TO_ADDR
// animal := CreateHuman ;
86293: LD_ADDR_VAR 0 12
86297: PUSH
86298: CALL_OW 44
86302: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86303: LD_VAR 0 12
86307: PPUSH
86308: LD_VAR 0 8
86312: PPUSH
86313: LD_INT 0
86315: PPUSH
86316: CALL 88317 0 3
// end ;
86320: GO 86274
86322: POP
86323: POP
// if tigers then
86324: LD_VAR 0 2
86328: IFFALSE 86412
// for i = 1 to tigers do
86330: LD_ADDR_VAR 0 11
86334: PUSH
86335: DOUBLE
86336: LD_INT 1
86338: DEC
86339: ST_TO_ADDR
86340: LD_VAR 0 2
86344: PUSH
86345: FOR_TO
86346: IFFALSE 86410
// begin hc_class = class_tiger ;
86348: LD_ADDR_OWVAR 28
86352: PUSH
86353: LD_INT 14
86355: ST_TO_ADDR
// hc_gallery =  ;
86356: LD_ADDR_OWVAR 33
86360: PUSH
86361: LD_STRING 
86363: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
86364: LD_ADDR_OWVAR 35
86368: PUSH
86369: LD_INT 7
86371: NEG
86372: PPUSH
86373: LD_INT 7
86375: PPUSH
86376: CALL_OW 12
86380: ST_TO_ADDR
// animal := CreateHuman ;
86381: LD_ADDR_VAR 0 12
86385: PUSH
86386: CALL_OW 44
86390: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86391: LD_VAR 0 12
86395: PPUSH
86396: LD_VAR 0 8
86400: PPUSH
86401: LD_INT 0
86403: PPUSH
86404: CALL 88317 0 3
// end ;
86408: GO 86345
86410: POP
86411: POP
// if apemans then
86412: LD_VAR 0 3
86416: IFFALSE 86539
// for i = 1 to apemans do
86418: LD_ADDR_VAR 0 11
86422: PUSH
86423: DOUBLE
86424: LD_INT 1
86426: DEC
86427: ST_TO_ADDR
86428: LD_VAR 0 3
86432: PUSH
86433: FOR_TO
86434: IFFALSE 86537
// begin hc_class = class_apeman ;
86436: LD_ADDR_OWVAR 28
86440: PUSH
86441: LD_INT 12
86443: ST_TO_ADDR
// hc_gallery =  ;
86444: LD_ADDR_OWVAR 33
86448: PUSH
86449: LD_STRING 
86451: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
86452: LD_ADDR_OWVAR 35
86456: PUSH
86457: LD_INT 2
86459: NEG
86460: PPUSH
86461: LD_INT 2
86463: PPUSH
86464: CALL_OW 12
86468: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
86469: LD_ADDR_OWVAR 31
86473: PUSH
86474: LD_INT 1
86476: PPUSH
86477: LD_INT 3
86479: PPUSH
86480: CALL_OW 12
86484: PUSH
86485: LD_INT 1
86487: PPUSH
86488: LD_INT 3
86490: PPUSH
86491: CALL_OW 12
86495: PUSH
86496: LD_INT 0
86498: PUSH
86499: LD_INT 0
86501: PUSH
86502: EMPTY
86503: LIST
86504: LIST
86505: LIST
86506: LIST
86507: ST_TO_ADDR
// animal := CreateHuman ;
86508: LD_ADDR_VAR 0 12
86512: PUSH
86513: CALL_OW 44
86517: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86518: LD_VAR 0 12
86522: PPUSH
86523: LD_VAR 0 8
86527: PPUSH
86528: LD_INT 0
86530: PPUSH
86531: CALL 88317 0 3
// end ;
86535: GO 86433
86537: POP
86538: POP
// if enchidnas then
86539: LD_VAR 0 4
86543: IFFALSE 86610
// for i = 1 to enchidnas do
86545: LD_ADDR_VAR 0 11
86549: PUSH
86550: DOUBLE
86551: LD_INT 1
86553: DEC
86554: ST_TO_ADDR
86555: LD_VAR 0 4
86559: PUSH
86560: FOR_TO
86561: IFFALSE 86608
// begin hc_class = 13 ;
86563: LD_ADDR_OWVAR 28
86567: PUSH
86568: LD_INT 13
86570: ST_TO_ADDR
// hc_gallery =  ;
86571: LD_ADDR_OWVAR 33
86575: PUSH
86576: LD_STRING 
86578: ST_TO_ADDR
// animal := CreateHuman ;
86579: LD_ADDR_VAR 0 12
86583: PUSH
86584: CALL_OW 44
86588: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86589: LD_VAR 0 12
86593: PPUSH
86594: LD_VAR 0 8
86598: PPUSH
86599: LD_INT 0
86601: PPUSH
86602: CALL 88317 0 3
// end ;
86606: GO 86560
86608: POP
86609: POP
// if fishes then
86610: LD_VAR 0 7
86614: IFFALSE 86681
// for i = 1 to fishes do
86616: LD_ADDR_VAR 0 11
86620: PUSH
86621: DOUBLE
86622: LD_INT 1
86624: DEC
86625: ST_TO_ADDR
86626: LD_VAR 0 7
86630: PUSH
86631: FOR_TO
86632: IFFALSE 86679
// begin hc_class = 20 ;
86634: LD_ADDR_OWVAR 28
86638: PUSH
86639: LD_INT 20
86641: ST_TO_ADDR
// hc_gallery =  ;
86642: LD_ADDR_OWVAR 33
86646: PUSH
86647: LD_STRING 
86649: ST_TO_ADDR
// animal := CreateHuman ;
86650: LD_ADDR_VAR 0 12
86654: PUSH
86655: CALL_OW 44
86659: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
86660: LD_VAR 0 12
86664: PPUSH
86665: LD_VAR 0 9
86669: PPUSH
86670: LD_INT 0
86672: PPUSH
86673: CALL 88317 0 3
// end ;
86677: GO 86631
86679: POP
86680: POP
// end ;
86681: LD_VAR 0 10
86685: RET
// export function WantHeal ( sci , unit ) ; begin
86686: LD_INT 0
86688: PPUSH
// if GetTaskList ( sci ) > 0 then
86689: LD_VAR 0 1
86693: PPUSH
86694: CALL_OW 437
86698: PUSH
86699: LD_INT 0
86701: GREATER
86702: IFFALSE 86772
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86704: LD_VAR 0 1
86708: PPUSH
86709: CALL_OW 437
86713: PUSH
86714: LD_INT 1
86716: ARRAY
86717: PUSH
86718: LD_INT 1
86720: ARRAY
86721: PUSH
86722: LD_STRING l
86724: EQUAL
86725: PUSH
86726: LD_VAR 0 1
86730: PPUSH
86731: CALL_OW 437
86735: PUSH
86736: LD_INT 1
86738: ARRAY
86739: PUSH
86740: LD_INT 4
86742: ARRAY
86743: PUSH
86744: LD_VAR 0 2
86748: EQUAL
86749: AND
86750: IFFALSE 86762
// result := true else
86752: LD_ADDR_VAR 0 3
86756: PUSH
86757: LD_INT 1
86759: ST_TO_ADDR
86760: GO 86770
// result := false ;
86762: LD_ADDR_VAR 0 3
86766: PUSH
86767: LD_INT 0
86769: ST_TO_ADDR
// end else
86770: GO 86780
// result := false ;
86772: LD_ADDR_VAR 0 3
86776: PUSH
86777: LD_INT 0
86779: ST_TO_ADDR
// end ;
86780: LD_VAR 0 3
86784: RET
// export function HealTarget ( sci ) ; begin
86785: LD_INT 0
86787: PPUSH
// if not sci then
86788: LD_VAR 0 1
86792: NOT
86793: IFFALSE 86797
// exit ;
86795: GO 86862
// result := 0 ;
86797: LD_ADDR_VAR 0 2
86801: PUSH
86802: LD_INT 0
86804: ST_TO_ADDR
// if GetTaskList ( sci ) then
86805: LD_VAR 0 1
86809: PPUSH
86810: CALL_OW 437
86814: IFFALSE 86862
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86816: LD_VAR 0 1
86820: PPUSH
86821: CALL_OW 437
86825: PUSH
86826: LD_INT 1
86828: ARRAY
86829: PUSH
86830: LD_INT 1
86832: ARRAY
86833: PUSH
86834: LD_STRING l
86836: EQUAL
86837: IFFALSE 86862
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86839: LD_ADDR_VAR 0 2
86843: PUSH
86844: LD_VAR 0 1
86848: PPUSH
86849: CALL_OW 437
86853: PUSH
86854: LD_INT 1
86856: ARRAY
86857: PUSH
86858: LD_INT 4
86860: ARRAY
86861: ST_TO_ADDR
// end ;
86862: LD_VAR 0 2
86866: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
86867: LD_INT 0
86869: PPUSH
86870: PPUSH
86871: PPUSH
86872: PPUSH
// if not base_units then
86873: LD_VAR 0 1
86877: NOT
86878: IFFALSE 86882
// exit ;
86880: GO 86969
// result := false ;
86882: LD_ADDR_VAR 0 2
86886: PUSH
86887: LD_INT 0
86889: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
86890: LD_ADDR_VAR 0 5
86894: PUSH
86895: LD_VAR 0 1
86899: PPUSH
86900: LD_INT 21
86902: PUSH
86903: LD_INT 3
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PPUSH
86910: CALL_OW 72
86914: ST_TO_ADDR
// if not tmp then
86915: LD_VAR 0 5
86919: NOT
86920: IFFALSE 86924
// exit ;
86922: GO 86969
// for i in tmp do
86924: LD_ADDR_VAR 0 3
86928: PUSH
86929: LD_VAR 0 5
86933: PUSH
86934: FOR_IN
86935: IFFALSE 86967
// begin result := EnemyInRange ( i , 22 ) ;
86937: LD_ADDR_VAR 0 2
86941: PUSH
86942: LD_VAR 0 3
86946: PPUSH
86947: LD_INT 22
86949: PPUSH
86950: CALL 84582 0 2
86954: ST_TO_ADDR
// if result then
86955: LD_VAR 0 2
86959: IFFALSE 86965
// exit ;
86961: POP
86962: POP
86963: GO 86969
// end ;
86965: GO 86934
86967: POP
86968: POP
// end ;
86969: LD_VAR 0 2
86973: RET
// export function FilterByTag ( units , tag ) ; begin
86974: LD_INT 0
86976: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
86977: LD_ADDR_VAR 0 3
86981: PUSH
86982: LD_VAR 0 1
86986: PPUSH
86987: LD_INT 120
86989: PUSH
86990: LD_VAR 0 2
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PPUSH
86999: CALL_OW 72
87003: ST_TO_ADDR
// end ;
87004: LD_VAR 0 3
87008: RET
// export function IsDriver ( un ) ; begin
87009: LD_INT 0
87011: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
87012: LD_ADDR_VAR 0 2
87016: PUSH
87017: LD_VAR 0 1
87021: PUSH
87022: LD_INT 55
87024: PUSH
87025: EMPTY
87026: LIST
87027: PPUSH
87028: CALL_OW 69
87032: IN
87033: ST_TO_ADDR
// end ;
87034: LD_VAR 0 2
87038: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
87039: LD_INT 0
87041: PPUSH
87042: PPUSH
// list := [ ] ;
87043: LD_ADDR_VAR 0 5
87047: PUSH
87048: EMPTY
87049: ST_TO_ADDR
// case d of 0 :
87050: LD_VAR 0 3
87054: PUSH
87055: LD_INT 0
87057: DOUBLE
87058: EQUAL
87059: IFTRUE 87063
87061: GO 87196
87063: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87064: LD_ADDR_VAR 0 5
87068: PUSH
87069: LD_VAR 0 1
87073: PUSH
87074: LD_INT 4
87076: MINUS
87077: PUSH
87078: LD_VAR 0 2
87082: PUSH
87083: LD_INT 4
87085: MINUS
87086: PUSH
87087: LD_INT 2
87089: PUSH
87090: EMPTY
87091: LIST
87092: LIST
87093: LIST
87094: PUSH
87095: LD_VAR 0 1
87099: PUSH
87100: LD_INT 3
87102: MINUS
87103: PUSH
87104: LD_VAR 0 2
87108: PUSH
87109: LD_INT 1
87111: PUSH
87112: EMPTY
87113: LIST
87114: LIST
87115: LIST
87116: PUSH
87117: LD_VAR 0 1
87121: PUSH
87122: LD_INT 4
87124: PLUS
87125: PUSH
87126: LD_VAR 0 2
87130: PUSH
87131: LD_INT 4
87133: PUSH
87134: EMPTY
87135: LIST
87136: LIST
87137: LIST
87138: PUSH
87139: LD_VAR 0 1
87143: PUSH
87144: LD_INT 3
87146: PLUS
87147: PUSH
87148: LD_VAR 0 2
87152: PUSH
87153: LD_INT 3
87155: PLUS
87156: PUSH
87157: LD_INT 5
87159: PUSH
87160: EMPTY
87161: LIST
87162: LIST
87163: LIST
87164: PUSH
87165: LD_VAR 0 1
87169: PUSH
87170: LD_VAR 0 2
87174: PUSH
87175: LD_INT 4
87177: PLUS
87178: PUSH
87179: LD_INT 0
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: LIST
87186: PUSH
87187: EMPTY
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: ST_TO_ADDR
// end ; 1 :
87194: GO 87894
87196: LD_INT 1
87198: DOUBLE
87199: EQUAL
87200: IFTRUE 87204
87202: GO 87337
87204: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87205: LD_ADDR_VAR 0 5
87209: PUSH
87210: LD_VAR 0 1
87214: PUSH
87215: LD_VAR 0 2
87219: PUSH
87220: LD_INT 4
87222: MINUS
87223: PUSH
87224: LD_INT 3
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: LIST
87231: PUSH
87232: LD_VAR 0 1
87236: PUSH
87237: LD_INT 3
87239: MINUS
87240: PUSH
87241: LD_VAR 0 2
87245: PUSH
87246: LD_INT 3
87248: MINUS
87249: PUSH
87250: LD_INT 2
87252: PUSH
87253: EMPTY
87254: LIST
87255: LIST
87256: LIST
87257: PUSH
87258: LD_VAR 0 1
87262: PUSH
87263: LD_INT 4
87265: MINUS
87266: PUSH
87267: LD_VAR 0 2
87271: PUSH
87272: LD_INT 1
87274: PUSH
87275: EMPTY
87276: LIST
87277: LIST
87278: LIST
87279: PUSH
87280: LD_VAR 0 1
87284: PUSH
87285: LD_VAR 0 2
87289: PUSH
87290: LD_INT 3
87292: PLUS
87293: PUSH
87294: LD_INT 0
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: LIST
87301: PUSH
87302: LD_VAR 0 1
87306: PUSH
87307: LD_INT 4
87309: PLUS
87310: PUSH
87311: LD_VAR 0 2
87315: PUSH
87316: LD_INT 4
87318: PLUS
87319: PUSH
87320: LD_INT 5
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: LIST
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: ST_TO_ADDR
// end ; 2 :
87335: GO 87894
87337: LD_INT 2
87339: DOUBLE
87340: EQUAL
87341: IFTRUE 87345
87343: GO 87474
87345: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
87346: LD_ADDR_VAR 0 5
87350: PUSH
87351: LD_VAR 0 1
87355: PUSH
87356: LD_VAR 0 2
87360: PUSH
87361: LD_INT 3
87363: MINUS
87364: PUSH
87365: LD_INT 3
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: LIST
87372: PUSH
87373: LD_VAR 0 1
87377: PUSH
87378: LD_INT 4
87380: PLUS
87381: PUSH
87382: LD_VAR 0 2
87386: PUSH
87387: LD_INT 4
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: LIST
87394: PUSH
87395: LD_VAR 0 1
87399: PUSH
87400: LD_VAR 0 2
87404: PUSH
87405: LD_INT 4
87407: PLUS
87408: PUSH
87409: LD_INT 0
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: LIST
87416: PUSH
87417: LD_VAR 0 1
87421: PUSH
87422: LD_INT 3
87424: MINUS
87425: PUSH
87426: LD_VAR 0 2
87430: PUSH
87431: LD_INT 1
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: LIST
87438: PUSH
87439: LD_VAR 0 1
87443: PUSH
87444: LD_INT 4
87446: MINUS
87447: PUSH
87448: LD_VAR 0 2
87452: PUSH
87453: LD_INT 4
87455: MINUS
87456: PUSH
87457: LD_INT 2
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: LIST
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: ST_TO_ADDR
// end ; 3 :
87472: GO 87894
87474: LD_INT 3
87476: DOUBLE
87477: EQUAL
87478: IFTRUE 87482
87480: GO 87615
87482: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
87483: LD_ADDR_VAR 0 5
87487: PUSH
87488: LD_VAR 0 1
87492: PUSH
87493: LD_INT 3
87495: PLUS
87496: PUSH
87497: LD_VAR 0 2
87501: PUSH
87502: LD_INT 4
87504: PUSH
87505: EMPTY
87506: LIST
87507: LIST
87508: LIST
87509: PUSH
87510: LD_VAR 0 1
87514: PUSH
87515: LD_INT 4
87517: PLUS
87518: PUSH
87519: LD_VAR 0 2
87523: PUSH
87524: LD_INT 4
87526: PLUS
87527: PUSH
87528: LD_INT 5
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: LIST
87535: PUSH
87536: LD_VAR 0 1
87540: PUSH
87541: LD_INT 4
87543: MINUS
87544: PUSH
87545: LD_VAR 0 2
87549: PUSH
87550: LD_INT 1
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: LIST
87557: PUSH
87558: LD_VAR 0 1
87562: PUSH
87563: LD_VAR 0 2
87567: PUSH
87568: LD_INT 4
87570: MINUS
87571: PUSH
87572: LD_INT 3
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: LIST
87579: PUSH
87580: LD_VAR 0 1
87584: PUSH
87585: LD_INT 3
87587: MINUS
87588: PUSH
87589: LD_VAR 0 2
87593: PUSH
87594: LD_INT 3
87596: MINUS
87597: PUSH
87598: LD_INT 2
87600: PUSH
87601: EMPTY
87602: LIST
87603: LIST
87604: LIST
87605: PUSH
87606: EMPTY
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: ST_TO_ADDR
// end ; 4 :
87613: GO 87894
87615: LD_INT 4
87617: DOUBLE
87618: EQUAL
87619: IFTRUE 87623
87621: GO 87756
87623: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
87624: LD_ADDR_VAR 0 5
87628: PUSH
87629: LD_VAR 0 1
87633: PUSH
87634: LD_VAR 0 2
87638: PUSH
87639: LD_INT 4
87641: PLUS
87642: PUSH
87643: LD_INT 0
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: LIST
87650: PUSH
87651: LD_VAR 0 1
87655: PUSH
87656: LD_INT 3
87658: PLUS
87659: PUSH
87660: LD_VAR 0 2
87664: PUSH
87665: LD_INT 3
87667: PLUS
87668: PUSH
87669: LD_INT 5
87671: PUSH
87672: EMPTY
87673: LIST
87674: LIST
87675: LIST
87676: PUSH
87677: LD_VAR 0 1
87681: PUSH
87682: LD_INT 4
87684: PLUS
87685: PUSH
87686: LD_VAR 0 2
87690: PUSH
87691: LD_INT 4
87693: PUSH
87694: EMPTY
87695: LIST
87696: LIST
87697: LIST
87698: PUSH
87699: LD_VAR 0 1
87703: PUSH
87704: LD_VAR 0 2
87708: PUSH
87709: LD_INT 3
87711: MINUS
87712: PUSH
87713: LD_INT 3
87715: PUSH
87716: EMPTY
87717: LIST
87718: LIST
87719: LIST
87720: PUSH
87721: LD_VAR 0 1
87725: PUSH
87726: LD_INT 4
87728: MINUS
87729: PUSH
87730: LD_VAR 0 2
87734: PUSH
87735: LD_INT 4
87737: MINUS
87738: PUSH
87739: LD_INT 2
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: LIST
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: ST_TO_ADDR
// end ; 5 :
87754: GO 87894
87756: LD_INT 5
87758: DOUBLE
87759: EQUAL
87760: IFTRUE 87764
87762: GO 87893
87764: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87765: LD_ADDR_VAR 0 5
87769: PUSH
87770: LD_VAR 0 1
87774: PUSH
87775: LD_INT 4
87777: MINUS
87778: PUSH
87779: LD_VAR 0 2
87783: PUSH
87784: LD_INT 1
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: LIST
87791: PUSH
87792: LD_VAR 0 1
87796: PUSH
87797: LD_VAR 0 2
87801: PUSH
87802: LD_INT 4
87804: MINUS
87805: PUSH
87806: LD_INT 3
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: LIST
87813: PUSH
87814: LD_VAR 0 1
87818: PUSH
87819: LD_INT 4
87821: PLUS
87822: PUSH
87823: LD_VAR 0 2
87827: PUSH
87828: LD_INT 4
87830: PLUS
87831: PUSH
87832: LD_INT 5
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: LIST
87839: PUSH
87840: LD_VAR 0 1
87844: PUSH
87845: LD_INT 3
87847: PLUS
87848: PUSH
87849: LD_VAR 0 2
87853: PUSH
87854: LD_INT 4
87856: PUSH
87857: EMPTY
87858: LIST
87859: LIST
87860: LIST
87861: PUSH
87862: LD_VAR 0 1
87866: PUSH
87867: LD_VAR 0 2
87871: PUSH
87872: LD_INT 3
87874: PLUS
87875: PUSH
87876: LD_INT 0
87878: PUSH
87879: EMPTY
87880: LIST
87881: LIST
87882: LIST
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: LIST
87888: LIST
87889: LIST
87890: ST_TO_ADDR
// end ; end ;
87891: GO 87894
87893: POP
// result := list ;
87894: LD_ADDR_VAR 0 4
87898: PUSH
87899: LD_VAR 0 5
87903: ST_TO_ADDR
// end ;
87904: LD_VAR 0 4
87908: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
87909: LD_INT 0
87911: PPUSH
87912: PPUSH
87913: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
87914: LD_VAR 0 1
87918: NOT
87919: PUSH
87920: LD_VAR 0 2
87924: PUSH
87925: LD_INT 1
87927: PUSH
87928: LD_INT 2
87930: PUSH
87931: LD_INT 3
87933: PUSH
87934: LD_INT 4
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: LIST
87941: LIST
87942: IN
87943: NOT
87944: OR
87945: IFFALSE 87949
// exit ;
87947: GO 88041
// tmp := [ ] ;
87949: LD_ADDR_VAR 0 5
87953: PUSH
87954: EMPTY
87955: ST_TO_ADDR
// for i in units do
87956: LD_ADDR_VAR 0 4
87960: PUSH
87961: LD_VAR 0 1
87965: PUSH
87966: FOR_IN
87967: IFFALSE 88010
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
87969: LD_ADDR_VAR 0 5
87973: PUSH
87974: LD_VAR 0 5
87978: PPUSH
87979: LD_VAR 0 5
87983: PUSH
87984: LD_INT 1
87986: PLUS
87987: PPUSH
87988: LD_VAR 0 4
87992: PPUSH
87993: LD_VAR 0 2
87997: PPUSH
87998: CALL_OW 259
88002: PPUSH
88003: CALL_OW 2
88007: ST_TO_ADDR
88008: GO 87966
88010: POP
88011: POP
// if not tmp then
88012: LD_VAR 0 5
88016: NOT
88017: IFFALSE 88021
// exit ;
88019: GO 88041
// result := SortListByListDesc ( units , tmp ) ;
88021: LD_ADDR_VAR 0 3
88025: PUSH
88026: LD_VAR 0 1
88030: PPUSH
88031: LD_VAR 0 5
88035: PPUSH
88036: CALL_OW 77
88040: ST_TO_ADDR
// end ;
88041: LD_VAR 0 3
88045: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88046: LD_INT 0
88048: PPUSH
88049: PPUSH
88050: PPUSH
// result := false ;
88051: LD_ADDR_VAR 0 3
88055: PUSH
88056: LD_INT 0
88058: ST_TO_ADDR
// x := GetX ( building ) ;
88059: LD_ADDR_VAR 0 4
88063: PUSH
88064: LD_VAR 0 2
88068: PPUSH
88069: CALL_OW 250
88073: ST_TO_ADDR
// y := GetY ( building ) ;
88074: LD_ADDR_VAR 0 5
88078: PUSH
88079: LD_VAR 0 2
88083: PPUSH
88084: CALL_OW 251
88088: ST_TO_ADDR
// if not building or not x or not y then
88089: LD_VAR 0 2
88093: NOT
88094: PUSH
88095: LD_VAR 0 4
88099: NOT
88100: OR
88101: PUSH
88102: LD_VAR 0 5
88106: NOT
88107: OR
88108: IFFALSE 88112
// exit ;
88110: GO 88204
// if GetTaskList ( unit ) then
88112: LD_VAR 0 1
88116: PPUSH
88117: CALL_OW 437
88121: IFFALSE 88204
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88123: LD_STRING e
88125: PUSH
88126: LD_VAR 0 1
88130: PPUSH
88131: CALL_OW 437
88135: PUSH
88136: LD_INT 1
88138: ARRAY
88139: PUSH
88140: LD_INT 1
88142: ARRAY
88143: EQUAL
88144: PUSH
88145: LD_VAR 0 4
88149: PUSH
88150: LD_VAR 0 1
88154: PPUSH
88155: CALL_OW 437
88159: PUSH
88160: LD_INT 1
88162: ARRAY
88163: PUSH
88164: LD_INT 2
88166: ARRAY
88167: EQUAL
88168: AND
88169: PUSH
88170: LD_VAR 0 5
88174: PUSH
88175: LD_VAR 0 1
88179: PPUSH
88180: CALL_OW 437
88184: PUSH
88185: LD_INT 1
88187: ARRAY
88188: PUSH
88189: LD_INT 3
88191: ARRAY
88192: EQUAL
88193: AND
88194: IFFALSE 88204
// result := true end ;
88196: LD_ADDR_VAR 0 3
88200: PUSH
88201: LD_INT 1
88203: ST_TO_ADDR
// end ;
88204: LD_VAR 0 3
88208: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
88209: LD_INT 0
88211: PPUSH
// result := false ;
88212: LD_ADDR_VAR 0 4
88216: PUSH
88217: LD_INT 0
88219: ST_TO_ADDR
// if GetTaskList ( unit ) then
88220: LD_VAR 0 1
88224: PPUSH
88225: CALL_OW 437
88229: IFFALSE 88312
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88231: LD_STRING M
88233: PUSH
88234: LD_VAR 0 1
88238: PPUSH
88239: CALL_OW 437
88243: PUSH
88244: LD_INT 1
88246: ARRAY
88247: PUSH
88248: LD_INT 1
88250: ARRAY
88251: EQUAL
88252: PUSH
88253: LD_VAR 0 2
88257: PUSH
88258: LD_VAR 0 1
88262: PPUSH
88263: CALL_OW 437
88267: PUSH
88268: LD_INT 1
88270: ARRAY
88271: PUSH
88272: LD_INT 2
88274: ARRAY
88275: EQUAL
88276: AND
88277: PUSH
88278: LD_VAR 0 3
88282: PUSH
88283: LD_VAR 0 1
88287: PPUSH
88288: CALL_OW 437
88292: PUSH
88293: LD_INT 1
88295: ARRAY
88296: PUSH
88297: LD_INT 3
88299: ARRAY
88300: EQUAL
88301: AND
88302: IFFALSE 88312
// result := true ;
88304: LD_ADDR_VAR 0 4
88308: PUSH
88309: LD_INT 1
88311: ST_TO_ADDR
// end ; end ;
88312: LD_VAR 0 4
88316: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
88317: LD_INT 0
88319: PPUSH
88320: PPUSH
88321: PPUSH
88322: PPUSH
// if not unit or not area then
88323: LD_VAR 0 1
88327: NOT
88328: PUSH
88329: LD_VAR 0 2
88333: NOT
88334: OR
88335: IFFALSE 88339
// exit ;
88337: GO 88503
// tmp := AreaToList ( area , i ) ;
88339: LD_ADDR_VAR 0 6
88343: PUSH
88344: LD_VAR 0 2
88348: PPUSH
88349: LD_VAR 0 5
88353: PPUSH
88354: CALL_OW 517
88358: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
88359: LD_ADDR_VAR 0 5
88363: PUSH
88364: DOUBLE
88365: LD_INT 1
88367: DEC
88368: ST_TO_ADDR
88369: LD_VAR 0 6
88373: PUSH
88374: LD_INT 1
88376: ARRAY
88377: PUSH
88378: FOR_TO
88379: IFFALSE 88501
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
88381: LD_ADDR_VAR 0 7
88385: PUSH
88386: LD_VAR 0 6
88390: PUSH
88391: LD_INT 1
88393: ARRAY
88394: PUSH
88395: LD_VAR 0 5
88399: ARRAY
88400: PUSH
88401: LD_VAR 0 6
88405: PUSH
88406: LD_INT 2
88408: ARRAY
88409: PUSH
88410: LD_VAR 0 5
88414: ARRAY
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
88420: LD_VAR 0 7
88424: PUSH
88425: LD_INT 1
88427: ARRAY
88428: PPUSH
88429: LD_VAR 0 7
88433: PUSH
88434: LD_INT 2
88436: ARRAY
88437: PPUSH
88438: CALL_OW 428
88442: PUSH
88443: LD_INT 0
88445: EQUAL
88446: IFFALSE 88499
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
88448: LD_VAR 0 1
88452: PPUSH
88453: LD_VAR 0 7
88457: PUSH
88458: LD_INT 1
88460: ARRAY
88461: PPUSH
88462: LD_VAR 0 7
88466: PUSH
88467: LD_INT 2
88469: ARRAY
88470: PPUSH
88471: LD_VAR 0 3
88475: PPUSH
88476: CALL_OW 48
// result := IsPlaced ( unit ) ;
88480: LD_ADDR_VAR 0 4
88484: PUSH
88485: LD_VAR 0 1
88489: PPUSH
88490: CALL_OW 305
88494: ST_TO_ADDR
// exit ;
88495: POP
88496: POP
88497: GO 88503
// end ; end ;
88499: GO 88378
88501: POP
88502: POP
// end ;
88503: LD_VAR 0 4
88507: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
88508: LD_INT 0
88510: PPUSH
88511: PPUSH
88512: PPUSH
// if not side or side > 8 then
88513: LD_VAR 0 1
88517: NOT
88518: PUSH
88519: LD_VAR 0 1
88523: PUSH
88524: LD_INT 8
88526: GREATER
88527: OR
88528: IFFALSE 88532
// exit ;
88530: GO 88719
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
88532: LD_ADDR_VAR 0 4
88536: PUSH
88537: LD_INT 22
88539: PUSH
88540: LD_VAR 0 1
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: PUSH
88549: LD_INT 21
88551: PUSH
88552: LD_INT 3
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: PPUSH
88563: CALL_OW 69
88567: ST_TO_ADDR
// if not tmp then
88568: LD_VAR 0 4
88572: NOT
88573: IFFALSE 88577
// exit ;
88575: GO 88719
// enable_addtolog := true ;
88577: LD_ADDR_OWVAR 81
88581: PUSH
88582: LD_INT 1
88584: ST_TO_ADDR
// AddToLog ( [ ) ;
88585: LD_STRING [
88587: PPUSH
88588: CALL_OW 561
// for i in tmp do
88592: LD_ADDR_VAR 0 3
88596: PUSH
88597: LD_VAR 0 4
88601: PUSH
88602: FOR_IN
88603: IFFALSE 88710
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
88605: LD_STRING [
88607: PUSH
88608: LD_VAR 0 3
88612: PPUSH
88613: CALL_OW 266
88617: STR
88618: PUSH
88619: LD_STRING , 
88621: STR
88622: PUSH
88623: LD_VAR 0 3
88627: PPUSH
88628: CALL_OW 250
88632: STR
88633: PUSH
88634: LD_STRING , 
88636: STR
88637: PUSH
88638: LD_VAR 0 3
88642: PPUSH
88643: CALL_OW 251
88647: STR
88648: PUSH
88649: LD_STRING , 
88651: STR
88652: PUSH
88653: LD_VAR 0 3
88657: PPUSH
88658: CALL_OW 254
88662: STR
88663: PUSH
88664: LD_STRING , 
88666: STR
88667: PUSH
88668: LD_VAR 0 3
88672: PPUSH
88673: LD_INT 1
88675: PPUSH
88676: CALL_OW 268
88680: STR
88681: PUSH
88682: LD_STRING , 
88684: STR
88685: PUSH
88686: LD_VAR 0 3
88690: PPUSH
88691: LD_INT 2
88693: PPUSH
88694: CALL_OW 268
88698: STR
88699: PUSH
88700: LD_STRING ],
88702: STR
88703: PPUSH
88704: CALL_OW 561
// end ;
88708: GO 88602
88710: POP
88711: POP
// AddToLog ( ]; ) ;
88712: LD_STRING ];
88714: PPUSH
88715: CALL_OW 561
// end ;
88719: LD_VAR 0 2
88723: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88724: LD_INT 0
88726: PPUSH
88727: PPUSH
88728: PPUSH
88729: PPUSH
88730: PPUSH
// if not area or not rate or not max then
88731: LD_VAR 0 1
88735: NOT
88736: PUSH
88737: LD_VAR 0 2
88741: NOT
88742: OR
88743: PUSH
88744: LD_VAR 0 4
88748: NOT
88749: OR
88750: IFFALSE 88754
// exit ;
88752: GO 88943
// while 1 do
88754: LD_INT 1
88756: IFFALSE 88943
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88758: LD_ADDR_VAR 0 9
88762: PUSH
88763: LD_VAR 0 1
88767: PPUSH
88768: LD_INT 1
88770: PPUSH
88771: CALL_OW 287
88775: PUSH
88776: LD_INT 10
88778: MUL
88779: ST_TO_ADDR
// r := rate / 10 ;
88780: LD_ADDR_VAR 0 7
88784: PUSH
88785: LD_VAR 0 2
88789: PUSH
88790: LD_INT 10
88792: DIVREAL
88793: ST_TO_ADDR
// time := 1 1$00 ;
88794: LD_ADDR_VAR 0 8
88798: PUSH
88799: LD_INT 2100
88801: ST_TO_ADDR
// if amount < min then
88802: LD_VAR 0 9
88806: PUSH
88807: LD_VAR 0 3
88811: LESS
88812: IFFALSE 88830
// r := r * 2 else
88814: LD_ADDR_VAR 0 7
88818: PUSH
88819: LD_VAR 0 7
88823: PUSH
88824: LD_INT 2
88826: MUL
88827: ST_TO_ADDR
88828: GO 88856
// if amount > max then
88830: LD_VAR 0 9
88834: PUSH
88835: LD_VAR 0 4
88839: GREATER
88840: IFFALSE 88856
// r := r / 2 ;
88842: LD_ADDR_VAR 0 7
88846: PUSH
88847: LD_VAR 0 7
88851: PUSH
88852: LD_INT 2
88854: DIVREAL
88855: ST_TO_ADDR
// time := time / r ;
88856: LD_ADDR_VAR 0 8
88860: PUSH
88861: LD_VAR 0 8
88865: PUSH
88866: LD_VAR 0 7
88870: DIVREAL
88871: ST_TO_ADDR
// if time < 0 then
88872: LD_VAR 0 8
88876: PUSH
88877: LD_INT 0
88879: LESS
88880: IFFALSE 88897
// time := time * - 1 ;
88882: LD_ADDR_VAR 0 8
88886: PUSH
88887: LD_VAR 0 8
88891: PUSH
88892: LD_INT 1
88894: NEG
88895: MUL
88896: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
88897: LD_VAR 0 8
88901: PUSH
88902: LD_INT 35
88904: PPUSH
88905: LD_INT 875
88907: PPUSH
88908: CALL_OW 12
88912: PLUS
88913: PPUSH
88914: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
88918: LD_INT 1
88920: PPUSH
88921: LD_INT 5
88923: PPUSH
88924: CALL_OW 12
88928: PPUSH
88929: LD_VAR 0 1
88933: PPUSH
88934: LD_INT 1
88936: PPUSH
88937: CALL_OW 55
// end ;
88941: GO 88754
// end ;
88943: LD_VAR 0 5
88947: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
88948: LD_INT 0
88950: PPUSH
88951: PPUSH
88952: PPUSH
88953: PPUSH
88954: PPUSH
88955: PPUSH
88956: PPUSH
88957: PPUSH
// if not turrets or not factories then
88958: LD_VAR 0 1
88962: NOT
88963: PUSH
88964: LD_VAR 0 2
88968: NOT
88969: OR
88970: IFFALSE 88974
// exit ;
88972: GO 89281
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
88974: LD_ADDR_VAR 0 10
88978: PUSH
88979: LD_INT 5
88981: PUSH
88982: LD_INT 6
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PUSH
88989: LD_INT 2
88991: PUSH
88992: LD_INT 4
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: LD_INT 3
89001: PUSH
89002: LD_INT 5
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: PUSH
89009: EMPTY
89010: LIST
89011: LIST
89012: LIST
89013: PUSH
89014: LD_INT 24
89016: PUSH
89017: LD_INT 25
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PUSH
89024: LD_INT 23
89026: PUSH
89027: LD_INT 27
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: PUSH
89038: LD_INT 42
89040: PUSH
89041: LD_INT 43
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: PUSH
89048: LD_INT 44
89050: PUSH
89051: LD_INT 46
89053: PUSH
89054: EMPTY
89055: LIST
89056: LIST
89057: PUSH
89058: LD_INT 45
89060: PUSH
89061: LD_INT 47
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: LIST
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: LIST
89077: ST_TO_ADDR
// result := [ ] ;
89078: LD_ADDR_VAR 0 3
89082: PUSH
89083: EMPTY
89084: ST_TO_ADDR
// for i in turrets do
89085: LD_ADDR_VAR 0 4
89089: PUSH
89090: LD_VAR 0 1
89094: PUSH
89095: FOR_IN
89096: IFFALSE 89279
// begin nat := GetNation ( i ) ;
89098: LD_ADDR_VAR 0 7
89102: PUSH
89103: LD_VAR 0 4
89107: PPUSH
89108: CALL_OW 248
89112: ST_TO_ADDR
// weapon := 0 ;
89113: LD_ADDR_VAR 0 8
89117: PUSH
89118: LD_INT 0
89120: ST_TO_ADDR
// if not nat then
89121: LD_VAR 0 7
89125: NOT
89126: IFFALSE 89130
// continue ;
89128: GO 89095
// for j in list [ nat ] do
89130: LD_ADDR_VAR 0 5
89134: PUSH
89135: LD_VAR 0 10
89139: PUSH
89140: LD_VAR 0 7
89144: ARRAY
89145: PUSH
89146: FOR_IN
89147: IFFALSE 89188
// if GetBWeapon ( i ) = j [ 1 ] then
89149: LD_VAR 0 4
89153: PPUSH
89154: CALL_OW 269
89158: PUSH
89159: LD_VAR 0 5
89163: PUSH
89164: LD_INT 1
89166: ARRAY
89167: EQUAL
89168: IFFALSE 89186
// begin weapon := j [ 2 ] ;
89170: LD_ADDR_VAR 0 8
89174: PUSH
89175: LD_VAR 0 5
89179: PUSH
89180: LD_INT 2
89182: ARRAY
89183: ST_TO_ADDR
// break ;
89184: GO 89188
// end ;
89186: GO 89146
89188: POP
89189: POP
// if not weapon then
89190: LD_VAR 0 8
89194: NOT
89195: IFFALSE 89199
// continue ;
89197: GO 89095
// for k in factories do
89199: LD_ADDR_VAR 0 6
89203: PUSH
89204: LD_VAR 0 2
89208: PUSH
89209: FOR_IN
89210: IFFALSE 89275
// begin weapons := AvailableWeaponList ( k ) ;
89212: LD_ADDR_VAR 0 9
89216: PUSH
89217: LD_VAR 0 6
89221: PPUSH
89222: CALL_OW 478
89226: ST_TO_ADDR
// if not weapons then
89227: LD_VAR 0 9
89231: NOT
89232: IFFALSE 89236
// continue ;
89234: GO 89209
// if weapon in weapons then
89236: LD_VAR 0 8
89240: PUSH
89241: LD_VAR 0 9
89245: IN
89246: IFFALSE 89273
// begin result := [ i , weapon ] ;
89248: LD_ADDR_VAR 0 3
89252: PUSH
89253: LD_VAR 0 4
89257: PUSH
89258: LD_VAR 0 8
89262: PUSH
89263: EMPTY
89264: LIST
89265: LIST
89266: ST_TO_ADDR
// exit ;
89267: POP
89268: POP
89269: POP
89270: POP
89271: GO 89281
// end ; end ;
89273: GO 89209
89275: POP
89276: POP
// end ;
89277: GO 89095
89279: POP
89280: POP
// end ;
89281: LD_VAR 0 3
89285: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
89286: LD_INT 0
89288: PPUSH
// if not side or side > 8 then
89289: LD_VAR 0 3
89293: NOT
89294: PUSH
89295: LD_VAR 0 3
89299: PUSH
89300: LD_INT 8
89302: GREATER
89303: OR
89304: IFFALSE 89308
// exit ;
89306: GO 89367
// if not range then
89308: LD_VAR 0 4
89312: NOT
89313: IFFALSE 89324
// range := - 12 ;
89315: LD_ADDR_VAR 0 4
89319: PUSH
89320: LD_INT 12
89322: NEG
89323: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
89324: LD_VAR 0 1
89328: PPUSH
89329: LD_VAR 0 2
89333: PPUSH
89334: LD_VAR 0 3
89338: PPUSH
89339: LD_VAR 0 4
89343: PPUSH
89344: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
89348: LD_VAR 0 1
89352: PPUSH
89353: LD_VAR 0 2
89357: PPUSH
89358: LD_VAR 0 3
89362: PPUSH
89363: CALL_OW 331
// end ;
89367: LD_VAR 0 5
89371: RET
// export function Video ( mode ) ; begin
89372: LD_INT 0
89374: PPUSH
// ingame_video = mode ;
89375: LD_ADDR_OWVAR 52
89379: PUSH
89380: LD_VAR 0 1
89384: ST_TO_ADDR
// interface_hidden = mode ;
89385: LD_ADDR_OWVAR 54
89389: PUSH
89390: LD_VAR 0 1
89394: ST_TO_ADDR
// end ;
89395: LD_VAR 0 2
89399: RET
// export function Join ( array , element ) ; begin
89400: LD_INT 0
89402: PPUSH
// result := Replace ( array , array + 1 , element ) ;
89403: LD_ADDR_VAR 0 3
89407: PUSH
89408: LD_VAR 0 1
89412: PPUSH
89413: LD_VAR 0 1
89417: PUSH
89418: LD_INT 1
89420: PLUS
89421: PPUSH
89422: LD_VAR 0 2
89426: PPUSH
89427: CALL_OW 1
89431: ST_TO_ADDR
// end ;
89432: LD_VAR 0 3
89436: RET
// export function JoinUnion ( array , element ) ; begin
89437: LD_INT 0
89439: PPUSH
// result := array union element ;
89440: LD_ADDR_VAR 0 3
89444: PUSH
89445: LD_VAR 0 1
89449: PUSH
89450: LD_VAR 0 2
89454: UNION
89455: ST_TO_ADDR
// end ;
89456: LD_VAR 0 3
89460: RET
// export function GetBehemoths ( side ) ; begin
89461: LD_INT 0
89463: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
89464: LD_ADDR_VAR 0 2
89468: PUSH
89469: LD_INT 22
89471: PUSH
89472: LD_VAR 0 1
89476: PUSH
89477: EMPTY
89478: LIST
89479: LIST
89480: PUSH
89481: LD_INT 31
89483: PUSH
89484: LD_INT 25
89486: PUSH
89487: EMPTY
89488: LIST
89489: LIST
89490: PUSH
89491: EMPTY
89492: LIST
89493: LIST
89494: PPUSH
89495: CALL_OW 69
89499: ST_TO_ADDR
// end ;
89500: LD_VAR 0 2
89504: RET
// export function Shuffle ( array ) ; var i , index ; begin
89505: LD_INT 0
89507: PPUSH
89508: PPUSH
89509: PPUSH
// result := [ ] ;
89510: LD_ADDR_VAR 0 2
89514: PUSH
89515: EMPTY
89516: ST_TO_ADDR
// if not array then
89517: LD_VAR 0 1
89521: NOT
89522: IFFALSE 89526
// exit ;
89524: GO 89625
// Randomize ;
89526: CALL_OW 10
// for i = array downto 1 do
89530: LD_ADDR_VAR 0 3
89534: PUSH
89535: DOUBLE
89536: LD_VAR 0 1
89540: INC
89541: ST_TO_ADDR
89542: LD_INT 1
89544: PUSH
89545: FOR_DOWNTO
89546: IFFALSE 89623
// begin index := rand ( 1 , array ) ;
89548: LD_ADDR_VAR 0 4
89552: PUSH
89553: LD_INT 1
89555: PPUSH
89556: LD_VAR 0 1
89560: PPUSH
89561: CALL_OW 12
89565: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
89566: LD_ADDR_VAR 0 2
89570: PUSH
89571: LD_VAR 0 2
89575: PPUSH
89576: LD_VAR 0 2
89580: PUSH
89581: LD_INT 1
89583: PLUS
89584: PPUSH
89585: LD_VAR 0 1
89589: PUSH
89590: LD_VAR 0 4
89594: ARRAY
89595: PPUSH
89596: CALL_OW 2
89600: ST_TO_ADDR
// array := Delete ( array , index ) ;
89601: LD_ADDR_VAR 0 1
89605: PUSH
89606: LD_VAR 0 1
89610: PPUSH
89611: LD_VAR 0 4
89615: PPUSH
89616: CALL_OW 3
89620: ST_TO_ADDR
// end ;
89621: GO 89545
89623: POP
89624: POP
// end ;
89625: LD_VAR 0 2
89629: RET
// export function GetBaseMaterials ( base ) ; begin
89630: LD_INT 0
89632: PPUSH
// result := [ 0 , 0 , 0 ] ;
89633: LD_ADDR_VAR 0 2
89637: PUSH
89638: LD_INT 0
89640: PUSH
89641: LD_INT 0
89643: PUSH
89644: LD_INT 0
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: LIST
89651: ST_TO_ADDR
// if not base then
89652: LD_VAR 0 1
89656: NOT
89657: IFFALSE 89661
// exit ;
89659: GO 89710
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
89661: LD_ADDR_VAR 0 2
89665: PUSH
89666: LD_VAR 0 1
89670: PPUSH
89671: LD_INT 1
89673: PPUSH
89674: CALL_OW 275
89678: PUSH
89679: LD_VAR 0 1
89683: PPUSH
89684: LD_INT 2
89686: PPUSH
89687: CALL_OW 275
89691: PUSH
89692: LD_VAR 0 1
89696: PPUSH
89697: LD_INT 3
89699: PPUSH
89700: CALL_OW 275
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: LIST
89709: ST_TO_ADDR
// end ;
89710: LD_VAR 0 2
89714: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
89715: LD_INT 0
89717: PPUSH
89718: PPUSH
// result := array ;
89719: LD_ADDR_VAR 0 3
89723: PUSH
89724: LD_VAR 0 1
89728: ST_TO_ADDR
// if size >= result then
89729: LD_VAR 0 2
89733: PUSH
89734: LD_VAR 0 3
89738: GREATEREQUAL
89739: IFFALSE 89743
// exit ;
89741: GO 89793
// if size then
89743: LD_VAR 0 2
89747: IFFALSE 89793
// for i := array downto size do
89749: LD_ADDR_VAR 0 4
89753: PUSH
89754: DOUBLE
89755: LD_VAR 0 1
89759: INC
89760: ST_TO_ADDR
89761: LD_VAR 0 2
89765: PUSH
89766: FOR_DOWNTO
89767: IFFALSE 89791
// result := Delete ( result , result ) ;
89769: LD_ADDR_VAR 0 3
89773: PUSH
89774: LD_VAR 0 3
89778: PPUSH
89779: LD_VAR 0 3
89783: PPUSH
89784: CALL_OW 3
89788: ST_TO_ADDR
89789: GO 89766
89791: POP
89792: POP
// end ;
89793: LD_VAR 0 3
89797: RET
// export function ComExit ( unit ) ; var tmp ; begin
89798: LD_INT 0
89800: PPUSH
89801: PPUSH
// if not IsInUnit ( unit ) then
89802: LD_VAR 0 1
89806: PPUSH
89807: CALL_OW 310
89811: NOT
89812: IFFALSE 89816
// exit ;
89814: GO 89876
// tmp := IsInUnit ( unit ) ;
89816: LD_ADDR_VAR 0 3
89820: PUSH
89821: LD_VAR 0 1
89825: PPUSH
89826: CALL_OW 310
89830: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
89831: LD_VAR 0 3
89835: PPUSH
89836: CALL_OW 247
89840: PUSH
89841: LD_INT 2
89843: EQUAL
89844: IFFALSE 89857
// ComExitVehicle ( unit ) else
89846: LD_VAR 0 1
89850: PPUSH
89851: CALL_OW 121
89855: GO 89866
// ComExitBuilding ( unit ) ;
89857: LD_VAR 0 1
89861: PPUSH
89862: CALL_OW 122
// result := tmp ;
89866: LD_ADDR_VAR 0 2
89870: PUSH
89871: LD_VAR 0 3
89875: ST_TO_ADDR
// end ;
89876: LD_VAR 0 2
89880: RET
// export function ComExitAll ( units ) ; var i ; begin
89881: LD_INT 0
89883: PPUSH
89884: PPUSH
// if not units then
89885: LD_VAR 0 1
89889: NOT
89890: IFFALSE 89894
// exit ;
89892: GO 89920
// for i in units do
89894: LD_ADDR_VAR 0 3
89898: PUSH
89899: LD_VAR 0 1
89903: PUSH
89904: FOR_IN
89905: IFFALSE 89918
// ComExit ( i ) ;
89907: LD_VAR 0 3
89911: PPUSH
89912: CALL 89798 0 1
89916: GO 89904
89918: POP
89919: POP
// end ;
89920: LD_VAR 0 2
89924: RET
// export function ResetHc ; begin
89925: LD_INT 0
89927: PPUSH
// InitHc ;
89928: CALL_OW 19
// hc_importance := 0 ;
89932: LD_ADDR_OWVAR 32
89936: PUSH
89937: LD_INT 0
89939: ST_TO_ADDR
// end ;
89940: LD_VAR 0 1
89944: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
89945: LD_INT 0
89947: PPUSH
89948: PPUSH
89949: PPUSH
// _x := ( x1 + x2 ) div 2 ;
89950: LD_ADDR_VAR 0 6
89954: PUSH
89955: LD_VAR 0 1
89959: PUSH
89960: LD_VAR 0 3
89964: PLUS
89965: PUSH
89966: LD_INT 2
89968: DIV
89969: ST_TO_ADDR
// if _x < 0 then
89970: LD_VAR 0 6
89974: PUSH
89975: LD_INT 0
89977: LESS
89978: IFFALSE 89995
// _x := _x * - 1 ;
89980: LD_ADDR_VAR 0 6
89984: PUSH
89985: LD_VAR 0 6
89989: PUSH
89990: LD_INT 1
89992: NEG
89993: MUL
89994: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
89995: LD_ADDR_VAR 0 7
89999: PUSH
90000: LD_VAR 0 2
90004: PUSH
90005: LD_VAR 0 4
90009: PLUS
90010: PUSH
90011: LD_INT 2
90013: DIV
90014: ST_TO_ADDR
// if _y < 0 then
90015: LD_VAR 0 7
90019: PUSH
90020: LD_INT 0
90022: LESS
90023: IFFALSE 90040
// _y := _y * - 1 ;
90025: LD_ADDR_VAR 0 7
90029: PUSH
90030: LD_VAR 0 7
90034: PUSH
90035: LD_INT 1
90037: NEG
90038: MUL
90039: ST_TO_ADDR
// result := [ _x , _y ] ;
90040: LD_ADDR_VAR 0 5
90044: PUSH
90045: LD_VAR 0 6
90049: PUSH
90050: LD_VAR 0 7
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: ST_TO_ADDR
// end ;
90059: LD_VAR 0 5
90063: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
90064: LD_INT 0
90066: PPUSH
90067: PPUSH
90068: PPUSH
90069: PPUSH
// task := GetTaskList ( unit ) ;
90070: LD_ADDR_VAR 0 7
90074: PUSH
90075: LD_VAR 0 1
90079: PPUSH
90080: CALL_OW 437
90084: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
90085: LD_VAR 0 7
90089: NOT
90090: PUSH
90091: LD_VAR 0 1
90095: PPUSH
90096: LD_VAR 0 2
90100: PPUSH
90101: CALL_OW 308
90105: NOT
90106: AND
90107: IFFALSE 90111
// exit ;
90109: GO 90229
// if IsInArea ( unit , area ) then
90111: LD_VAR 0 1
90115: PPUSH
90116: LD_VAR 0 2
90120: PPUSH
90121: CALL_OW 308
90125: IFFALSE 90143
// begin ComMoveToArea ( unit , goAway ) ;
90127: LD_VAR 0 1
90131: PPUSH
90132: LD_VAR 0 3
90136: PPUSH
90137: CALL_OW 113
// exit ;
90141: GO 90229
// end ; if task [ 1 ] [ 1 ] <> M then
90143: LD_VAR 0 7
90147: PUSH
90148: LD_INT 1
90150: ARRAY
90151: PUSH
90152: LD_INT 1
90154: ARRAY
90155: PUSH
90156: LD_STRING M
90158: NONEQUAL
90159: IFFALSE 90163
// exit ;
90161: GO 90229
// x := task [ 1 ] [ 2 ] ;
90163: LD_ADDR_VAR 0 5
90167: PUSH
90168: LD_VAR 0 7
90172: PUSH
90173: LD_INT 1
90175: ARRAY
90176: PUSH
90177: LD_INT 2
90179: ARRAY
90180: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
90181: LD_ADDR_VAR 0 6
90185: PUSH
90186: LD_VAR 0 7
90190: PUSH
90191: LD_INT 1
90193: ARRAY
90194: PUSH
90195: LD_INT 3
90197: ARRAY
90198: ST_TO_ADDR
// if InArea ( x , y , area ) then
90199: LD_VAR 0 5
90203: PPUSH
90204: LD_VAR 0 6
90208: PPUSH
90209: LD_VAR 0 2
90213: PPUSH
90214: CALL_OW 309
90218: IFFALSE 90229
// ComStop ( unit ) ;
90220: LD_VAR 0 1
90224: PPUSH
90225: CALL_OW 141
// end ;
90229: LD_VAR 0 4
90233: RET
// export function Abs ( value ) ; begin
90234: LD_INT 0
90236: PPUSH
// result := value ;
90237: LD_ADDR_VAR 0 2
90241: PUSH
90242: LD_VAR 0 1
90246: ST_TO_ADDR
// if value < 0 then
90247: LD_VAR 0 1
90251: PUSH
90252: LD_INT 0
90254: LESS
90255: IFFALSE 90272
// result := value * - 1 ;
90257: LD_ADDR_VAR 0 2
90261: PUSH
90262: LD_VAR 0 1
90266: PUSH
90267: LD_INT 1
90269: NEG
90270: MUL
90271: ST_TO_ADDR
// end ;
90272: LD_VAR 0 2
90276: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
90277: LD_INT 0
90279: PPUSH
90280: PPUSH
90281: PPUSH
90282: PPUSH
90283: PPUSH
90284: PPUSH
90285: PPUSH
90286: PPUSH
// if not unit or not building then
90287: LD_VAR 0 1
90291: NOT
90292: PUSH
90293: LD_VAR 0 2
90297: NOT
90298: OR
90299: IFFALSE 90303
// exit ;
90301: GO 90529
// x := GetX ( building ) ;
90303: LD_ADDR_VAR 0 4
90307: PUSH
90308: LD_VAR 0 2
90312: PPUSH
90313: CALL_OW 250
90317: ST_TO_ADDR
// y := GetY ( building ) ;
90318: LD_ADDR_VAR 0 6
90322: PUSH
90323: LD_VAR 0 2
90327: PPUSH
90328: CALL_OW 251
90332: ST_TO_ADDR
// d := GetDir ( building ) ;
90333: LD_ADDR_VAR 0 8
90337: PUSH
90338: LD_VAR 0 2
90342: PPUSH
90343: CALL_OW 254
90347: ST_TO_ADDR
// r := 4 ;
90348: LD_ADDR_VAR 0 9
90352: PUSH
90353: LD_INT 4
90355: ST_TO_ADDR
// for i := 1 to 5 do
90356: LD_ADDR_VAR 0 10
90360: PUSH
90361: DOUBLE
90362: LD_INT 1
90364: DEC
90365: ST_TO_ADDR
90366: LD_INT 5
90368: PUSH
90369: FOR_TO
90370: IFFALSE 90527
// begin _x := ShiftX ( x , d , r + i ) ;
90372: LD_ADDR_VAR 0 5
90376: PUSH
90377: LD_VAR 0 4
90381: PPUSH
90382: LD_VAR 0 8
90386: PPUSH
90387: LD_VAR 0 9
90391: PUSH
90392: LD_VAR 0 10
90396: PLUS
90397: PPUSH
90398: CALL_OW 272
90402: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
90403: LD_ADDR_VAR 0 7
90407: PUSH
90408: LD_VAR 0 6
90412: PPUSH
90413: LD_VAR 0 8
90417: PPUSH
90418: LD_VAR 0 9
90422: PUSH
90423: LD_VAR 0 10
90427: PLUS
90428: PPUSH
90429: CALL_OW 273
90433: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
90434: LD_VAR 0 5
90438: PPUSH
90439: LD_VAR 0 7
90443: PPUSH
90444: CALL_OW 488
90448: PUSH
90449: LD_VAR 0 5
90453: PPUSH
90454: LD_VAR 0 7
90458: PPUSH
90459: CALL_OW 428
90463: PPUSH
90464: CALL_OW 247
90468: PUSH
90469: LD_INT 3
90471: PUSH
90472: LD_INT 2
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: IN
90479: NOT
90480: AND
90481: IFFALSE 90525
// begin ComMoveXY ( unit , _x , _y ) ;
90483: LD_VAR 0 1
90487: PPUSH
90488: LD_VAR 0 5
90492: PPUSH
90493: LD_VAR 0 7
90497: PPUSH
90498: CALL_OW 111
// result := [ _x , _y ] ;
90502: LD_ADDR_VAR 0 3
90506: PUSH
90507: LD_VAR 0 5
90511: PUSH
90512: LD_VAR 0 7
90516: PUSH
90517: EMPTY
90518: LIST
90519: LIST
90520: ST_TO_ADDR
// exit ;
90521: POP
90522: POP
90523: GO 90529
// end ; end ;
90525: GO 90369
90527: POP
90528: POP
// end ;
90529: LD_VAR 0 3
90533: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
90534: LD_INT 0
90536: PPUSH
90537: PPUSH
90538: PPUSH
// result := 0 ;
90539: LD_ADDR_VAR 0 3
90543: PUSH
90544: LD_INT 0
90546: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
90547: LD_VAR 0 1
90551: PUSH
90552: LD_INT 0
90554: LESS
90555: PUSH
90556: LD_VAR 0 1
90560: PUSH
90561: LD_INT 8
90563: GREATER
90564: OR
90565: PUSH
90566: LD_VAR 0 2
90570: PUSH
90571: LD_INT 0
90573: LESS
90574: OR
90575: PUSH
90576: LD_VAR 0 2
90580: PUSH
90581: LD_INT 8
90583: GREATER
90584: OR
90585: IFFALSE 90589
// exit ;
90587: GO 90664
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
90589: LD_ADDR_VAR 0 4
90593: PUSH
90594: LD_INT 22
90596: PUSH
90597: LD_VAR 0 2
90601: PUSH
90602: EMPTY
90603: LIST
90604: LIST
90605: PPUSH
90606: CALL_OW 69
90610: PUSH
90611: FOR_IN
90612: IFFALSE 90662
// begin un := UnitShoot ( i ) ;
90614: LD_ADDR_VAR 0 5
90618: PUSH
90619: LD_VAR 0 4
90623: PPUSH
90624: CALL_OW 504
90628: ST_TO_ADDR
// if GetSide ( un ) = side1 then
90629: LD_VAR 0 5
90633: PPUSH
90634: CALL_OW 255
90638: PUSH
90639: LD_VAR 0 1
90643: EQUAL
90644: IFFALSE 90660
// begin result := un ;
90646: LD_ADDR_VAR 0 3
90650: PUSH
90651: LD_VAR 0 5
90655: ST_TO_ADDR
// exit ;
90656: POP
90657: POP
90658: GO 90664
// end ; end ;
90660: GO 90611
90662: POP
90663: POP
// end ;
90664: LD_VAR 0 3
90668: RET
// export function GetCargoBay ( units ) ; begin
90669: LD_INT 0
90671: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
90672: LD_ADDR_VAR 0 2
90676: PUSH
90677: LD_VAR 0 1
90681: PPUSH
90682: LD_INT 2
90684: PUSH
90685: LD_INT 34
90687: PUSH
90688: LD_INT 12
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: LD_INT 34
90697: PUSH
90698: LD_INT 51
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: LD_INT 34
90707: PUSH
90708: LD_INT 32
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: LD_INT 34
90717: PUSH
90718: LD_INT 89
90720: PUSH
90721: EMPTY
90722: LIST
90723: LIST
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: LIST
90729: LIST
90730: LIST
90731: PPUSH
90732: CALL_OW 72
90736: ST_TO_ADDR
// end ;
90737: LD_VAR 0 2
90741: RET
// export function Negate ( value ) ; begin
90742: LD_INT 0
90744: PPUSH
// result := not value ;
90745: LD_ADDR_VAR 0 2
90749: PUSH
90750: LD_VAR 0 1
90754: NOT
90755: ST_TO_ADDR
// end ;
90756: LD_VAR 0 2
90760: RET
// export function Inc ( value ) ; begin
90761: LD_INT 0
90763: PPUSH
// result := value + 1 ;
90764: LD_ADDR_VAR 0 2
90768: PUSH
90769: LD_VAR 0 1
90773: PUSH
90774: LD_INT 1
90776: PLUS
90777: ST_TO_ADDR
// end ;
90778: LD_VAR 0 2
90782: RET
// export function Dec ( value ) ; begin
90783: LD_INT 0
90785: PPUSH
// result := value - 1 ;
90786: LD_ADDR_VAR 0 2
90790: PUSH
90791: LD_VAR 0 1
90795: PUSH
90796: LD_INT 1
90798: MINUS
90799: ST_TO_ADDR
// end ;
90800: LD_VAR 0 2
90804: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
90805: LD_INT 0
90807: PPUSH
90808: PPUSH
90809: PPUSH
90810: PPUSH
90811: PPUSH
90812: PPUSH
90813: PPUSH
90814: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
90815: LD_VAR 0 1
90819: PPUSH
90820: LD_VAR 0 2
90824: PPUSH
90825: CALL_OW 488
90829: NOT
90830: PUSH
90831: LD_VAR 0 3
90835: PPUSH
90836: LD_VAR 0 4
90840: PPUSH
90841: CALL_OW 488
90845: NOT
90846: OR
90847: IFFALSE 90860
// begin result := - 1 ;
90849: LD_ADDR_VAR 0 5
90853: PUSH
90854: LD_INT 1
90856: NEG
90857: ST_TO_ADDR
// exit ;
90858: GO 91095
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
90860: LD_ADDR_VAR 0 12
90864: PUSH
90865: LD_VAR 0 1
90869: PPUSH
90870: LD_VAR 0 2
90874: PPUSH
90875: LD_VAR 0 3
90879: PPUSH
90880: LD_VAR 0 4
90884: PPUSH
90885: CALL 89945 0 4
90889: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
90890: LD_ADDR_VAR 0 11
90894: PUSH
90895: LD_VAR 0 1
90899: PPUSH
90900: LD_VAR 0 2
90904: PPUSH
90905: LD_VAR 0 12
90909: PUSH
90910: LD_INT 1
90912: ARRAY
90913: PPUSH
90914: LD_VAR 0 12
90918: PUSH
90919: LD_INT 2
90921: ARRAY
90922: PPUSH
90923: CALL_OW 298
90927: ST_TO_ADDR
// distance := 9999 ;
90928: LD_ADDR_VAR 0 10
90932: PUSH
90933: LD_INT 9999
90935: ST_TO_ADDR
// for i := 0 to 5 do
90936: LD_ADDR_VAR 0 6
90940: PUSH
90941: DOUBLE
90942: LD_INT 0
90944: DEC
90945: ST_TO_ADDR
90946: LD_INT 5
90948: PUSH
90949: FOR_TO
90950: IFFALSE 91093
// begin _x := ShiftX ( x1 , i , centerDist ) ;
90952: LD_ADDR_VAR 0 7
90956: PUSH
90957: LD_VAR 0 1
90961: PPUSH
90962: LD_VAR 0 6
90966: PPUSH
90967: LD_VAR 0 11
90971: PPUSH
90972: CALL_OW 272
90976: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
90977: LD_ADDR_VAR 0 8
90981: PUSH
90982: LD_VAR 0 2
90986: PPUSH
90987: LD_VAR 0 6
90991: PPUSH
90992: LD_VAR 0 11
90996: PPUSH
90997: CALL_OW 273
91001: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
91002: LD_VAR 0 7
91006: PPUSH
91007: LD_VAR 0 8
91011: PPUSH
91012: CALL_OW 488
91016: NOT
91017: IFFALSE 91021
// continue ;
91019: GO 90949
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
91021: LD_ADDR_VAR 0 9
91025: PUSH
91026: LD_VAR 0 12
91030: PUSH
91031: LD_INT 1
91033: ARRAY
91034: PPUSH
91035: LD_VAR 0 12
91039: PUSH
91040: LD_INT 2
91042: ARRAY
91043: PPUSH
91044: LD_VAR 0 7
91048: PPUSH
91049: LD_VAR 0 8
91053: PPUSH
91054: CALL_OW 298
91058: ST_TO_ADDR
// if tmp < distance then
91059: LD_VAR 0 9
91063: PUSH
91064: LD_VAR 0 10
91068: LESS
91069: IFFALSE 91091
// begin result := i ;
91071: LD_ADDR_VAR 0 5
91075: PUSH
91076: LD_VAR 0 6
91080: ST_TO_ADDR
// distance := tmp ;
91081: LD_ADDR_VAR 0 10
91085: PUSH
91086: LD_VAR 0 9
91090: ST_TO_ADDR
// end ; end ;
91091: GO 90949
91093: POP
91094: POP
// end ;
91095: LD_VAR 0 5
91099: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91100: LD_INT 0
91102: PPUSH
91103: PPUSH
// if not driver or not IsInUnit ( driver ) then
91104: LD_VAR 0 1
91108: NOT
91109: PUSH
91110: LD_VAR 0 1
91114: PPUSH
91115: CALL_OW 310
91119: NOT
91120: OR
91121: IFFALSE 91125
// exit ;
91123: GO 91215
// vehicle := IsInUnit ( driver ) ;
91125: LD_ADDR_VAR 0 3
91129: PUSH
91130: LD_VAR 0 1
91134: PPUSH
91135: CALL_OW 310
91139: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91140: LD_VAR 0 1
91144: PPUSH
91145: LD_STRING \
91147: PUSH
91148: LD_INT 0
91150: PUSH
91151: LD_INT 0
91153: PUSH
91154: LD_INT 0
91156: PUSH
91157: LD_INT 0
91159: PUSH
91160: LD_INT 0
91162: PUSH
91163: LD_INT 0
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: PUSH
91175: LD_STRING E
91177: PUSH
91178: LD_INT 0
91180: PUSH
91181: LD_INT 0
91183: PUSH
91184: LD_VAR 0 3
91188: PUSH
91189: LD_INT 0
91191: PUSH
91192: LD_INT 0
91194: PUSH
91195: LD_INT 0
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: PPUSH
91211: CALL_OW 446
// end ;
91215: LD_VAR 0 2
91219: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91220: LD_INT 0
91222: PPUSH
91223: PPUSH
// if not driver or not IsInUnit ( driver ) then
91224: LD_VAR 0 1
91228: NOT
91229: PUSH
91230: LD_VAR 0 1
91234: PPUSH
91235: CALL_OW 310
91239: NOT
91240: OR
91241: IFFALSE 91245
// exit ;
91243: GO 91335
// vehicle := IsInUnit ( driver ) ;
91245: LD_ADDR_VAR 0 3
91249: PUSH
91250: LD_VAR 0 1
91254: PPUSH
91255: CALL_OW 310
91259: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91260: LD_VAR 0 1
91264: PPUSH
91265: LD_STRING \
91267: PUSH
91268: LD_INT 0
91270: PUSH
91271: LD_INT 0
91273: PUSH
91274: LD_INT 0
91276: PUSH
91277: LD_INT 0
91279: PUSH
91280: LD_INT 0
91282: PUSH
91283: LD_INT 0
91285: PUSH
91286: EMPTY
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: PUSH
91295: LD_STRING E
91297: PUSH
91298: LD_INT 0
91300: PUSH
91301: LD_INT 0
91303: PUSH
91304: LD_VAR 0 3
91308: PUSH
91309: LD_INT 0
91311: PUSH
91312: LD_INT 0
91314: PUSH
91315: LD_INT 0
91317: PUSH
91318: EMPTY
91319: LIST
91320: LIST
91321: LIST
91322: LIST
91323: LIST
91324: LIST
91325: LIST
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: PPUSH
91331: CALL_OW 447
// end ;
91335: LD_VAR 0 2
91339: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
91340: LD_INT 0
91342: PPUSH
91343: PPUSH
91344: PPUSH
// tmp := [ ] ;
91345: LD_ADDR_VAR 0 5
91349: PUSH
91350: EMPTY
91351: ST_TO_ADDR
// for i in units do
91352: LD_ADDR_VAR 0 4
91356: PUSH
91357: LD_VAR 0 1
91361: PUSH
91362: FOR_IN
91363: IFFALSE 91401
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
91365: LD_ADDR_VAR 0 5
91369: PUSH
91370: LD_VAR 0 5
91374: PPUSH
91375: LD_VAR 0 5
91379: PUSH
91380: LD_INT 1
91382: PLUS
91383: PPUSH
91384: LD_VAR 0 4
91388: PPUSH
91389: CALL_OW 256
91393: PPUSH
91394: CALL_OW 2
91398: ST_TO_ADDR
91399: GO 91362
91401: POP
91402: POP
// if not tmp then
91403: LD_VAR 0 5
91407: NOT
91408: IFFALSE 91412
// exit ;
91410: GO 91460
// if asc then
91412: LD_VAR 0 2
91416: IFFALSE 91440
// result := SortListByListAsc ( units , tmp ) else
91418: LD_ADDR_VAR 0 3
91422: PUSH
91423: LD_VAR 0 1
91427: PPUSH
91428: LD_VAR 0 5
91432: PPUSH
91433: CALL_OW 76
91437: ST_TO_ADDR
91438: GO 91460
// result := SortListByListDesc ( units , tmp ) ;
91440: LD_ADDR_VAR 0 3
91444: PUSH
91445: LD_VAR 0 1
91449: PPUSH
91450: LD_VAR 0 5
91454: PPUSH
91455: CALL_OW 77
91459: ST_TO_ADDR
// end ;
91460: LD_VAR 0 3
91464: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
91465: LD_INT 0
91467: PPUSH
91468: PPUSH
// task := GetTaskList ( mech ) ;
91469: LD_ADDR_VAR 0 4
91473: PUSH
91474: LD_VAR 0 1
91478: PPUSH
91479: CALL_OW 437
91483: ST_TO_ADDR
// if not task then
91484: LD_VAR 0 4
91488: NOT
91489: IFFALSE 91493
// exit ;
91491: GO 91535
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
91493: LD_ADDR_VAR 0 3
91497: PUSH
91498: LD_VAR 0 4
91502: PUSH
91503: LD_INT 1
91505: ARRAY
91506: PUSH
91507: LD_INT 1
91509: ARRAY
91510: PUSH
91511: LD_STRING r
91513: EQUAL
91514: PUSH
91515: LD_VAR 0 4
91519: PUSH
91520: LD_INT 1
91522: ARRAY
91523: PUSH
91524: LD_INT 4
91526: ARRAY
91527: PUSH
91528: LD_VAR 0 2
91532: EQUAL
91533: AND
91534: ST_TO_ADDR
// end ;
91535: LD_VAR 0 3
91539: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
91540: LD_INT 0
91542: PPUSH
// SetDir ( unit , d ) ;
91543: LD_VAR 0 1
91547: PPUSH
91548: LD_VAR 0 4
91552: PPUSH
91553: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
91557: LD_VAR 0 1
91561: PPUSH
91562: LD_VAR 0 2
91566: PPUSH
91567: LD_VAR 0 3
91571: PPUSH
91572: LD_VAR 0 5
91576: PPUSH
91577: CALL_OW 48
// end ;
91581: LD_VAR 0 6
91585: RET
// export function ToNaturalNumber ( number ) ; begin
91586: LD_INT 0
91588: PPUSH
// result := number div 1 ;
91589: LD_ADDR_VAR 0 2
91593: PUSH
91594: LD_VAR 0 1
91598: PUSH
91599: LD_INT 1
91601: DIV
91602: ST_TO_ADDR
// if number < 0 then
91603: LD_VAR 0 1
91607: PUSH
91608: LD_INT 0
91610: LESS
91611: IFFALSE 91621
// result := 0 ;
91613: LD_ADDR_VAR 0 2
91617: PUSH
91618: LD_INT 0
91620: ST_TO_ADDR
// end ;
91621: LD_VAR 0 2
91625: RET
// export function SortByClass ( units , class ) ; var un ; begin
91626: LD_INT 0
91628: PPUSH
91629: PPUSH
// if not units or not class then
91630: LD_VAR 0 1
91634: NOT
91635: PUSH
91636: LD_VAR 0 2
91640: NOT
91641: OR
91642: IFFALSE 91646
// exit ;
91644: GO 91741
// result := [ ] ;
91646: LD_ADDR_VAR 0 3
91650: PUSH
91651: EMPTY
91652: ST_TO_ADDR
// for un in units do
91653: LD_ADDR_VAR 0 4
91657: PUSH
91658: LD_VAR 0 1
91662: PUSH
91663: FOR_IN
91664: IFFALSE 91739
// if GetClass ( un ) = class then
91666: LD_VAR 0 4
91670: PPUSH
91671: CALL_OW 257
91675: PUSH
91676: LD_VAR 0 2
91680: EQUAL
91681: IFFALSE 91708
// result := Insert ( result , 1 , un ) else
91683: LD_ADDR_VAR 0 3
91687: PUSH
91688: LD_VAR 0 3
91692: PPUSH
91693: LD_INT 1
91695: PPUSH
91696: LD_VAR 0 4
91700: PPUSH
91701: CALL_OW 2
91705: ST_TO_ADDR
91706: GO 91737
// result := Replace ( result , result + 1 , un ) ;
91708: LD_ADDR_VAR 0 3
91712: PUSH
91713: LD_VAR 0 3
91717: PPUSH
91718: LD_VAR 0 3
91722: PUSH
91723: LD_INT 1
91725: PLUS
91726: PPUSH
91727: LD_VAR 0 4
91731: PPUSH
91732: CALL_OW 1
91736: ST_TO_ADDR
91737: GO 91663
91739: POP
91740: POP
// end ;
91741: LD_VAR 0 3
91745: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
91746: LD_INT 0
91748: PPUSH
91749: PPUSH
91750: PPUSH
91751: PPUSH
91752: PPUSH
91753: PPUSH
91754: PPUSH
// result := [ ] ;
91755: LD_ADDR_VAR 0 4
91759: PUSH
91760: EMPTY
91761: ST_TO_ADDR
// if x - r < 0 then
91762: LD_VAR 0 1
91766: PUSH
91767: LD_VAR 0 3
91771: MINUS
91772: PUSH
91773: LD_INT 0
91775: LESS
91776: IFFALSE 91788
// min_x := 0 else
91778: LD_ADDR_VAR 0 8
91782: PUSH
91783: LD_INT 0
91785: ST_TO_ADDR
91786: GO 91804
// min_x := x - r ;
91788: LD_ADDR_VAR 0 8
91792: PUSH
91793: LD_VAR 0 1
91797: PUSH
91798: LD_VAR 0 3
91802: MINUS
91803: ST_TO_ADDR
// if y - r < 0 then
91804: LD_VAR 0 2
91808: PUSH
91809: LD_VAR 0 3
91813: MINUS
91814: PUSH
91815: LD_INT 0
91817: LESS
91818: IFFALSE 91830
// min_y := 0 else
91820: LD_ADDR_VAR 0 7
91824: PUSH
91825: LD_INT 0
91827: ST_TO_ADDR
91828: GO 91846
// min_y := y - r ;
91830: LD_ADDR_VAR 0 7
91834: PUSH
91835: LD_VAR 0 2
91839: PUSH
91840: LD_VAR 0 3
91844: MINUS
91845: ST_TO_ADDR
// max_x := x + r ;
91846: LD_ADDR_VAR 0 9
91850: PUSH
91851: LD_VAR 0 1
91855: PUSH
91856: LD_VAR 0 3
91860: PLUS
91861: ST_TO_ADDR
// max_y := y + r ;
91862: LD_ADDR_VAR 0 10
91866: PUSH
91867: LD_VAR 0 2
91871: PUSH
91872: LD_VAR 0 3
91876: PLUS
91877: ST_TO_ADDR
// for _x = min_x to max_x do
91878: LD_ADDR_VAR 0 5
91882: PUSH
91883: DOUBLE
91884: LD_VAR 0 8
91888: DEC
91889: ST_TO_ADDR
91890: LD_VAR 0 9
91894: PUSH
91895: FOR_TO
91896: IFFALSE 91997
// for _y = min_y to max_y do
91898: LD_ADDR_VAR 0 6
91902: PUSH
91903: DOUBLE
91904: LD_VAR 0 7
91908: DEC
91909: ST_TO_ADDR
91910: LD_VAR 0 10
91914: PUSH
91915: FOR_TO
91916: IFFALSE 91993
// begin if not ValidHex ( _x , _y ) then
91918: LD_VAR 0 5
91922: PPUSH
91923: LD_VAR 0 6
91927: PPUSH
91928: CALL_OW 488
91932: NOT
91933: IFFALSE 91937
// continue ;
91935: GO 91915
// if GetResourceTypeXY ( _x , _y ) then
91937: LD_VAR 0 5
91941: PPUSH
91942: LD_VAR 0 6
91946: PPUSH
91947: CALL_OW 283
91951: IFFALSE 91991
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
91953: LD_ADDR_VAR 0 4
91957: PUSH
91958: LD_VAR 0 4
91962: PPUSH
91963: LD_VAR 0 4
91967: PUSH
91968: LD_INT 1
91970: PLUS
91971: PPUSH
91972: LD_VAR 0 5
91976: PUSH
91977: LD_VAR 0 6
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: PPUSH
91986: CALL_OW 1
91990: ST_TO_ADDR
// end ;
91991: GO 91915
91993: POP
91994: POP
91995: GO 91895
91997: POP
91998: POP
// end ;
91999: LD_VAR 0 4
92003: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
92004: LD_INT 0
92006: PPUSH
92007: PPUSH
92008: PPUSH
92009: PPUSH
92010: PPUSH
92011: PPUSH
92012: PPUSH
92013: PPUSH
// if not units then
92014: LD_VAR 0 1
92018: NOT
92019: IFFALSE 92023
// exit ;
92021: GO 92547
// result := UnitFilter ( units , [ f_ok ] ) ;
92023: LD_ADDR_VAR 0 3
92027: PUSH
92028: LD_VAR 0 1
92032: PPUSH
92033: LD_INT 50
92035: PUSH
92036: EMPTY
92037: LIST
92038: PPUSH
92039: CALL_OW 72
92043: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
92044: LD_ADDR_VAR 0 8
92048: PUSH
92049: LD_VAR 0 1
92053: PUSH
92054: LD_INT 1
92056: ARRAY
92057: PPUSH
92058: CALL_OW 255
92062: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
92063: LD_ADDR_VAR 0 10
92067: PUSH
92068: LD_INT 29
92070: PUSH
92071: LD_INT 91
92073: PUSH
92074: LD_INT 49
92076: PUSH
92077: EMPTY
92078: LIST
92079: LIST
92080: LIST
92081: ST_TO_ADDR
// if not result then
92082: LD_VAR 0 3
92086: NOT
92087: IFFALSE 92091
// exit ;
92089: GO 92547
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
92091: LD_ADDR_VAR 0 5
92095: PUSH
92096: LD_INT 81
92098: PUSH
92099: LD_VAR 0 8
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PPUSH
92108: CALL_OW 69
92112: ST_TO_ADDR
// for i in result do
92113: LD_ADDR_VAR 0 4
92117: PUSH
92118: LD_VAR 0 3
92122: PUSH
92123: FOR_IN
92124: IFFALSE 92545
// begin tag := GetTag ( i ) + 1 ;
92126: LD_ADDR_VAR 0 9
92130: PUSH
92131: LD_VAR 0 4
92135: PPUSH
92136: CALL_OW 110
92140: PUSH
92141: LD_INT 1
92143: PLUS
92144: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
92145: LD_ADDR_VAR 0 7
92149: PUSH
92150: LD_VAR 0 4
92154: PPUSH
92155: CALL_OW 250
92159: PPUSH
92160: LD_VAR 0 4
92164: PPUSH
92165: CALL_OW 251
92169: PPUSH
92170: LD_INT 6
92172: PPUSH
92173: CALL 91746 0 3
92177: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
92178: LD_VAR 0 4
92182: PPUSH
92183: CALL_OW 247
92187: PUSH
92188: LD_INT 2
92190: EQUAL
92191: PUSH
92192: LD_VAR 0 7
92196: AND
92197: PUSH
92198: LD_VAR 0 4
92202: PPUSH
92203: CALL_OW 264
92207: PUSH
92208: LD_VAR 0 10
92212: IN
92213: NOT
92214: AND
92215: IFFALSE 92254
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
92217: LD_VAR 0 4
92221: PPUSH
92222: LD_VAR 0 7
92226: PUSH
92227: LD_INT 1
92229: ARRAY
92230: PUSH
92231: LD_INT 1
92233: ARRAY
92234: PPUSH
92235: LD_VAR 0 7
92239: PUSH
92240: LD_INT 1
92242: ARRAY
92243: PUSH
92244: LD_INT 2
92246: ARRAY
92247: PPUSH
92248: CALL_OW 116
92252: GO 92543
// if path > tag then
92254: LD_VAR 0 2
92258: PUSH
92259: LD_VAR 0 9
92263: GREATER
92264: IFFALSE 92472
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
92266: LD_ADDR_VAR 0 6
92270: PUSH
92271: LD_VAR 0 5
92275: PPUSH
92276: LD_INT 91
92278: PUSH
92279: LD_VAR 0 4
92283: PUSH
92284: LD_INT 8
92286: PUSH
92287: EMPTY
92288: LIST
92289: LIST
92290: LIST
92291: PPUSH
92292: CALL_OW 72
92296: ST_TO_ADDR
// if nearEnemy then
92297: LD_VAR 0 6
92301: IFFALSE 92370
// begin if GetWeapon ( i ) = ru_time_lapser then
92303: LD_VAR 0 4
92307: PPUSH
92308: CALL_OW 264
92312: PUSH
92313: LD_INT 49
92315: EQUAL
92316: IFFALSE 92344
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
92318: LD_VAR 0 4
92322: PPUSH
92323: LD_VAR 0 6
92327: PPUSH
92328: LD_VAR 0 4
92332: PPUSH
92333: CALL_OW 74
92337: PPUSH
92338: CALL_OW 112
92342: GO 92368
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
92344: LD_VAR 0 4
92348: PPUSH
92349: LD_VAR 0 6
92353: PPUSH
92354: LD_VAR 0 4
92358: PPUSH
92359: CALL_OW 74
92363: PPUSH
92364: CALL_OW 115
// end else
92368: GO 92470
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
92370: LD_VAR 0 4
92374: PPUSH
92375: LD_VAR 0 2
92379: PUSH
92380: LD_VAR 0 9
92384: ARRAY
92385: PUSH
92386: LD_INT 1
92388: ARRAY
92389: PPUSH
92390: LD_VAR 0 2
92394: PUSH
92395: LD_VAR 0 9
92399: ARRAY
92400: PUSH
92401: LD_INT 2
92403: ARRAY
92404: PPUSH
92405: CALL_OW 297
92409: PUSH
92410: LD_INT 6
92412: GREATER
92413: IFFALSE 92456
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
92415: LD_VAR 0 4
92419: PPUSH
92420: LD_VAR 0 2
92424: PUSH
92425: LD_VAR 0 9
92429: ARRAY
92430: PUSH
92431: LD_INT 1
92433: ARRAY
92434: PPUSH
92435: LD_VAR 0 2
92439: PUSH
92440: LD_VAR 0 9
92444: ARRAY
92445: PUSH
92446: LD_INT 2
92448: ARRAY
92449: PPUSH
92450: CALL_OW 114
92454: GO 92470
// SetTag ( i , tag ) ;
92456: LD_VAR 0 4
92460: PPUSH
92461: LD_VAR 0 9
92465: PPUSH
92466: CALL_OW 109
// end else
92470: GO 92543
// if enemy then
92472: LD_VAR 0 5
92476: IFFALSE 92543
// begin if GetWeapon ( i ) = ru_time_lapser then
92478: LD_VAR 0 4
92482: PPUSH
92483: CALL_OW 264
92487: PUSH
92488: LD_INT 49
92490: EQUAL
92491: IFFALSE 92519
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
92493: LD_VAR 0 4
92497: PPUSH
92498: LD_VAR 0 5
92502: PPUSH
92503: LD_VAR 0 4
92507: PPUSH
92508: CALL_OW 74
92512: PPUSH
92513: CALL_OW 112
92517: GO 92543
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
92519: LD_VAR 0 4
92523: PPUSH
92524: LD_VAR 0 5
92528: PPUSH
92529: LD_VAR 0 4
92533: PPUSH
92534: CALL_OW 74
92538: PPUSH
92539: CALL_OW 115
// end ; end ;
92543: GO 92123
92545: POP
92546: POP
// end ;
92547: LD_VAR 0 3
92551: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
92552: LD_INT 0
92554: PPUSH
92555: PPUSH
92556: PPUSH
// if not unit or IsInUnit ( unit ) then
92557: LD_VAR 0 1
92561: NOT
92562: PUSH
92563: LD_VAR 0 1
92567: PPUSH
92568: CALL_OW 310
92572: OR
92573: IFFALSE 92577
// exit ;
92575: GO 92668
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
92577: LD_ADDR_VAR 0 4
92581: PUSH
92582: LD_VAR 0 1
92586: PPUSH
92587: CALL_OW 250
92591: PPUSH
92592: LD_VAR 0 2
92596: PPUSH
92597: LD_INT 1
92599: PPUSH
92600: CALL_OW 272
92604: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
92605: LD_ADDR_VAR 0 5
92609: PUSH
92610: LD_VAR 0 1
92614: PPUSH
92615: CALL_OW 251
92619: PPUSH
92620: LD_VAR 0 2
92624: PPUSH
92625: LD_INT 1
92627: PPUSH
92628: CALL_OW 273
92632: ST_TO_ADDR
// if ValidHex ( x , y ) then
92633: LD_VAR 0 4
92637: PPUSH
92638: LD_VAR 0 5
92642: PPUSH
92643: CALL_OW 488
92647: IFFALSE 92668
// ComTurnXY ( unit , x , y ) ;
92649: LD_VAR 0 1
92653: PPUSH
92654: LD_VAR 0 4
92658: PPUSH
92659: LD_VAR 0 5
92663: PPUSH
92664: CALL_OW 118
// end ;
92668: LD_VAR 0 3
92672: RET
// export function SeeUnits ( side , units ) ; var i ; begin
92673: LD_INT 0
92675: PPUSH
92676: PPUSH
// result := false ;
92677: LD_ADDR_VAR 0 3
92681: PUSH
92682: LD_INT 0
92684: ST_TO_ADDR
// if not units then
92685: LD_VAR 0 2
92689: NOT
92690: IFFALSE 92694
// exit ;
92692: GO 92739
// for i in units do
92694: LD_ADDR_VAR 0 4
92698: PUSH
92699: LD_VAR 0 2
92703: PUSH
92704: FOR_IN
92705: IFFALSE 92737
// if See ( side , i ) then
92707: LD_VAR 0 1
92711: PPUSH
92712: LD_VAR 0 4
92716: PPUSH
92717: CALL_OW 292
92721: IFFALSE 92735
// begin result := true ;
92723: LD_ADDR_VAR 0 3
92727: PUSH
92728: LD_INT 1
92730: ST_TO_ADDR
// exit ;
92731: POP
92732: POP
92733: GO 92739
// end ;
92735: GO 92704
92737: POP
92738: POP
// end ;
92739: LD_VAR 0 3
92743: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
92744: LD_INT 0
92746: PPUSH
92747: PPUSH
92748: PPUSH
92749: PPUSH
// if not unit or not points then
92750: LD_VAR 0 1
92754: NOT
92755: PUSH
92756: LD_VAR 0 2
92760: NOT
92761: OR
92762: IFFALSE 92766
// exit ;
92764: GO 92856
// dist := 99999 ;
92766: LD_ADDR_VAR 0 5
92770: PUSH
92771: LD_INT 99999
92773: ST_TO_ADDR
// for i in points do
92774: LD_ADDR_VAR 0 4
92778: PUSH
92779: LD_VAR 0 2
92783: PUSH
92784: FOR_IN
92785: IFFALSE 92854
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
92787: LD_ADDR_VAR 0 6
92791: PUSH
92792: LD_VAR 0 1
92796: PPUSH
92797: LD_VAR 0 4
92801: PUSH
92802: LD_INT 1
92804: ARRAY
92805: PPUSH
92806: LD_VAR 0 4
92810: PUSH
92811: LD_INT 2
92813: ARRAY
92814: PPUSH
92815: CALL_OW 297
92819: ST_TO_ADDR
// if tmpDist < dist then
92820: LD_VAR 0 6
92824: PUSH
92825: LD_VAR 0 5
92829: LESS
92830: IFFALSE 92852
// begin result := i ;
92832: LD_ADDR_VAR 0 3
92836: PUSH
92837: LD_VAR 0 4
92841: ST_TO_ADDR
// dist := tmpDist ;
92842: LD_ADDR_VAR 0 5
92846: PUSH
92847: LD_VAR 0 6
92851: ST_TO_ADDR
// end ; end ;
92852: GO 92784
92854: POP
92855: POP
// end ;
92856: LD_VAR 0 3
92860: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
92861: LD_INT 0
92863: PPUSH
// uc_side := side ;
92864: LD_ADDR_OWVAR 20
92868: PUSH
92869: LD_VAR 0 1
92873: ST_TO_ADDR
// uc_nation := 3 ;
92874: LD_ADDR_OWVAR 21
92878: PUSH
92879: LD_INT 3
92881: ST_TO_ADDR
// vc_chassis := 25 ;
92882: LD_ADDR_OWVAR 37
92886: PUSH
92887: LD_INT 25
92889: ST_TO_ADDR
// vc_engine := engine_siberite ;
92890: LD_ADDR_OWVAR 39
92894: PUSH
92895: LD_INT 3
92897: ST_TO_ADDR
// vc_control := control_computer ;
92898: LD_ADDR_OWVAR 38
92902: PUSH
92903: LD_INT 3
92905: ST_TO_ADDR
// vc_weapon := 59 ;
92906: LD_ADDR_OWVAR 40
92910: PUSH
92911: LD_INT 59
92913: ST_TO_ADDR
// result := CreateVehicle ;
92914: LD_ADDR_VAR 0 5
92918: PUSH
92919: CALL_OW 45
92923: ST_TO_ADDR
// SetDir ( result , d ) ;
92924: LD_VAR 0 5
92928: PPUSH
92929: LD_VAR 0 4
92933: PPUSH
92934: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
92938: LD_VAR 0 5
92942: PPUSH
92943: LD_VAR 0 2
92947: PPUSH
92948: LD_VAR 0 3
92952: PPUSH
92953: LD_INT 0
92955: PPUSH
92956: CALL_OW 48
// end ;
92960: LD_VAR 0 5
92964: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
92965: LD_INT 0
92967: PPUSH
92968: PPUSH
92969: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
92970: LD_ADDR_VAR 0 2
92974: PUSH
92975: LD_INT 0
92977: PUSH
92978: LD_INT 0
92980: PUSH
92981: LD_INT 0
92983: PUSH
92984: LD_INT 0
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
92993: LD_VAR 0 1
92997: NOT
92998: PUSH
92999: LD_VAR 0 1
93003: PPUSH
93004: CALL_OW 264
93008: PUSH
93009: LD_INT 12
93011: PUSH
93012: LD_INT 51
93014: PUSH
93015: LD_INT 32
93017: PUSH
93018: LD_INT 89
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: LIST
93025: LIST
93026: IN
93027: NOT
93028: OR
93029: IFFALSE 93033
// exit ;
93031: GO 93131
// for i := 1 to 3 do
93033: LD_ADDR_VAR 0 3
93037: PUSH
93038: DOUBLE
93039: LD_INT 1
93041: DEC
93042: ST_TO_ADDR
93043: LD_INT 3
93045: PUSH
93046: FOR_TO
93047: IFFALSE 93129
// begin tmp := GetCargo ( cargo , i ) ;
93049: LD_ADDR_VAR 0 4
93053: PUSH
93054: LD_VAR 0 1
93058: PPUSH
93059: LD_VAR 0 3
93063: PPUSH
93064: CALL_OW 289
93068: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
93069: LD_ADDR_VAR 0 2
93073: PUSH
93074: LD_VAR 0 2
93078: PPUSH
93079: LD_VAR 0 3
93083: PPUSH
93084: LD_VAR 0 4
93088: PPUSH
93089: CALL_OW 1
93093: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
93094: LD_ADDR_VAR 0 2
93098: PUSH
93099: LD_VAR 0 2
93103: PPUSH
93104: LD_INT 4
93106: PPUSH
93107: LD_VAR 0 2
93111: PUSH
93112: LD_INT 4
93114: ARRAY
93115: PUSH
93116: LD_VAR 0 4
93120: PLUS
93121: PPUSH
93122: CALL_OW 1
93126: ST_TO_ADDR
// end ;
93127: GO 93046
93129: POP
93130: POP
// end ;
93131: LD_VAR 0 2
93135: RET
// export function Length ( array ) ; begin
93136: LD_INT 0
93138: PPUSH
// result := array + 0 ;
93139: LD_ADDR_VAR 0 2
93143: PUSH
93144: LD_VAR 0 1
93148: PUSH
93149: LD_INT 0
93151: PLUS
93152: ST_TO_ADDR
// end ;
93153: LD_VAR 0 2
93157: RET
// export function PrepareArray ( array ) ; begin
93158: LD_INT 0
93160: PPUSH
// result := array diff 0 ;
93161: LD_ADDR_VAR 0 2
93165: PUSH
93166: LD_VAR 0 1
93170: PUSH
93171: LD_INT 0
93173: DIFF
93174: ST_TO_ADDR
// if not result [ 1 ] then
93175: LD_VAR 0 2
93179: PUSH
93180: LD_INT 1
93182: ARRAY
93183: NOT
93184: IFFALSE 93204
// result := Delete ( result , 1 ) ;
93186: LD_ADDR_VAR 0 2
93190: PUSH
93191: LD_VAR 0 2
93195: PPUSH
93196: LD_INT 1
93198: PPUSH
93199: CALL_OW 3
93203: ST_TO_ADDR
// end ;
93204: LD_VAR 0 2
93208: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
93209: LD_INT 0
93211: PPUSH
93212: PPUSH
93213: PPUSH
93214: PPUSH
// sibRocketRange := 25 ;
93215: LD_ADDR_VAR 0 6
93219: PUSH
93220: LD_INT 25
93222: ST_TO_ADDR
// result := false ;
93223: LD_ADDR_VAR 0 4
93227: PUSH
93228: LD_INT 0
93230: ST_TO_ADDR
// for i := 0 to 5 do
93231: LD_ADDR_VAR 0 5
93235: PUSH
93236: DOUBLE
93237: LD_INT 0
93239: DEC
93240: ST_TO_ADDR
93241: LD_INT 5
93243: PUSH
93244: FOR_TO
93245: IFFALSE 93312
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
93247: LD_VAR 0 1
93251: PPUSH
93252: LD_VAR 0 5
93256: PPUSH
93257: LD_VAR 0 6
93261: PPUSH
93262: CALL_OW 272
93266: PPUSH
93267: LD_VAR 0 2
93271: PPUSH
93272: LD_VAR 0 5
93276: PPUSH
93277: LD_VAR 0 6
93281: PPUSH
93282: CALL_OW 273
93286: PPUSH
93287: LD_VAR 0 3
93291: PPUSH
93292: CALL_OW 309
93296: IFFALSE 93310
// begin result := true ;
93298: LD_ADDR_VAR 0 4
93302: PUSH
93303: LD_INT 1
93305: ST_TO_ADDR
// exit ;
93306: POP
93307: POP
93308: GO 93314
// end ;
93310: GO 93244
93312: POP
93313: POP
// end ;
93314: LD_VAR 0 4
93318: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
93319: LD_INT 0
93321: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
93322: LD_VAR 0 1
93326: PPUSH
93327: LD_VAR 0 2
93331: PPUSH
93332: LD_INT 0
93334: PPUSH
93335: LD_INT 0
93337: PPUSH
93338: LD_INT 1
93340: PPUSH
93341: LD_INT 0
93343: PPUSH
93344: CALL_OW 587
// end ; end_of_file end_of_file
93348: LD_VAR 0 3
93352: RET
// every 0 0$1 do
93353: GO 93355
93355: DISABLE
// begin enable ;
93356: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93357: LD_STRING updateTimer(
93359: PUSH
93360: LD_OWVAR 1
93364: STR
93365: PUSH
93366: LD_STRING );
93368: STR
93369: PPUSH
93370: CALL_OW 559
// end ;
93374: END
// export function SOS_MapStart ( ) ; begin
93375: LD_INT 0
93377: PPUSH
// if streamModeActive then
93378: LD_EXP 121
93382: IFFALSE 93391
// DefineStreamItems ( true ) ;
93384: LD_INT 1
93386: PPUSH
93387: CALL 95045 0 1
// UpdateFactoryWaypoints ( ) ;
93391: CALL 107906 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93395: CALL 108163 0 0
// end ;
93399: LD_VAR 0 1
93403: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93404: LD_INT 0
93406: PPUSH
// if p2 = hack_mode then
93407: LD_VAR 0 2
93411: PUSH
93412: LD_INT 100
93414: EQUAL
93415: IFFALSE 94418
// begin if not StreamModeActive then
93417: LD_EXP 121
93421: NOT
93422: IFFALSE 93432
// StreamModeActive := true ;
93424: LD_ADDR_EXP 121
93428: PUSH
93429: LD_INT 1
93431: ST_TO_ADDR
// if p3 = 0 then
93432: LD_VAR 0 3
93436: PUSH
93437: LD_INT 0
93439: EQUAL
93440: IFFALSE 93446
// InitStreamMode ;
93442: CALL 94581 0 0
// if p3 = 1 then
93446: LD_VAR 0 3
93450: PUSH
93451: LD_INT 1
93453: EQUAL
93454: IFFALSE 93464
// sRocket := true ;
93456: LD_ADDR_EXP 126
93460: PUSH
93461: LD_INT 1
93463: ST_TO_ADDR
// if p3 = 2 then
93464: LD_VAR 0 3
93468: PUSH
93469: LD_INT 2
93471: EQUAL
93472: IFFALSE 93482
// sSpeed := true ;
93474: LD_ADDR_EXP 125
93478: PUSH
93479: LD_INT 1
93481: ST_TO_ADDR
// if p3 = 3 then
93482: LD_VAR 0 3
93486: PUSH
93487: LD_INT 3
93489: EQUAL
93490: IFFALSE 93500
// sEngine := true ;
93492: LD_ADDR_EXP 127
93496: PUSH
93497: LD_INT 1
93499: ST_TO_ADDR
// if p3 = 4 then
93500: LD_VAR 0 3
93504: PUSH
93505: LD_INT 4
93507: EQUAL
93508: IFFALSE 93518
// sSpec := true ;
93510: LD_ADDR_EXP 124
93514: PUSH
93515: LD_INT 1
93517: ST_TO_ADDR
// if p3 = 5 then
93518: LD_VAR 0 3
93522: PUSH
93523: LD_INT 5
93525: EQUAL
93526: IFFALSE 93536
// sLevel := true ;
93528: LD_ADDR_EXP 128
93532: PUSH
93533: LD_INT 1
93535: ST_TO_ADDR
// if p3 = 6 then
93536: LD_VAR 0 3
93540: PUSH
93541: LD_INT 6
93543: EQUAL
93544: IFFALSE 93554
// sArmoury := true ;
93546: LD_ADDR_EXP 129
93550: PUSH
93551: LD_INT 1
93553: ST_TO_ADDR
// if p3 = 7 then
93554: LD_VAR 0 3
93558: PUSH
93559: LD_INT 7
93561: EQUAL
93562: IFFALSE 93572
// sRadar := true ;
93564: LD_ADDR_EXP 130
93568: PUSH
93569: LD_INT 1
93571: ST_TO_ADDR
// if p3 = 8 then
93572: LD_VAR 0 3
93576: PUSH
93577: LD_INT 8
93579: EQUAL
93580: IFFALSE 93590
// sBunker := true ;
93582: LD_ADDR_EXP 131
93586: PUSH
93587: LD_INT 1
93589: ST_TO_ADDR
// if p3 = 9 then
93590: LD_VAR 0 3
93594: PUSH
93595: LD_INT 9
93597: EQUAL
93598: IFFALSE 93608
// sHack := true ;
93600: LD_ADDR_EXP 132
93604: PUSH
93605: LD_INT 1
93607: ST_TO_ADDR
// if p3 = 10 then
93608: LD_VAR 0 3
93612: PUSH
93613: LD_INT 10
93615: EQUAL
93616: IFFALSE 93626
// sFire := true ;
93618: LD_ADDR_EXP 133
93622: PUSH
93623: LD_INT 1
93625: ST_TO_ADDR
// if p3 = 11 then
93626: LD_VAR 0 3
93630: PUSH
93631: LD_INT 11
93633: EQUAL
93634: IFFALSE 93644
// sRefresh := true ;
93636: LD_ADDR_EXP 134
93640: PUSH
93641: LD_INT 1
93643: ST_TO_ADDR
// if p3 = 12 then
93644: LD_VAR 0 3
93648: PUSH
93649: LD_INT 12
93651: EQUAL
93652: IFFALSE 93662
// sExp := true ;
93654: LD_ADDR_EXP 135
93658: PUSH
93659: LD_INT 1
93661: ST_TO_ADDR
// if p3 = 13 then
93662: LD_VAR 0 3
93666: PUSH
93667: LD_INT 13
93669: EQUAL
93670: IFFALSE 93680
// sDepot := true ;
93672: LD_ADDR_EXP 136
93676: PUSH
93677: LD_INT 1
93679: ST_TO_ADDR
// if p3 = 14 then
93680: LD_VAR 0 3
93684: PUSH
93685: LD_INT 14
93687: EQUAL
93688: IFFALSE 93698
// sFlag := true ;
93690: LD_ADDR_EXP 137
93694: PUSH
93695: LD_INT 1
93697: ST_TO_ADDR
// if p3 = 15 then
93698: LD_VAR 0 3
93702: PUSH
93703: LD_INT 15
93705: EQUAL
93706: IFFALSE 93716
// sKamikadze := true ;
93708: LD_ADDR_EXP 145
93712: PUSH
93713: LD_INT 1
93715: ST_TO_ADDR
// if p3 = 16 then
93716: LD_VAR 0 3
93720: PUSH
93721: LD_INT 16
93723: EQUAL
93724: IFFALSE 93734
// sTroll := true ;
93726: LD_ADDR_EXP 146
93730: PUSH
93731: LD_INT 1
93733: ST_TO_ADDR
// if p3 = 17 then
93734: LD_VAR 0 3
93738: PUSH
93739: LD_INT 17
93741: EQUAL
93742: IFFALSE 93752
// sSlow := true ;
93744: LD_ADDR_EXP 147
93748: PUSH
93749: LD_INT 1
93751: ST_TO_ADDR
// if p3 = 18 then
93752: LD_VAR 0 3
93756: PUSH
93757: LD_INT 18
93759: EQUAL
93760: IFFALSE 93770
// sLack := true ;
93762: LD_ADDR_EXP 148
93766: PUSH
93767: LD_INT 1
93769: ST_TO_ADDR
// if p3 = 19 then
93770: LD_VAR 0 3
93774: PUSH
93775: LD_INT 19
93777: EQUAL
93778: IFFALSE 93788
// sTank := true ;
93780: LD_ADDR_EXP 150
93784: PUSH
93785: LD_INT 1
93787: ST_TO_ADDR
// if p3 = 20 then
93788: LD_VAR 0 3
93792: PUSH
93793: LD_INT 20
93795: EQUAL
93796: IFFALSE 93806
// sRemote := true ;
93798: LD_ADDR_EXP 151
93802: PUSH
93803: LD_INT 1
93805: ST_TO_ADDR
// if p3 = 21 then
93806: LD_VAR 0 3
93810: PUSH
93811: LD_INT 21
93813: EQUAL
93814: IFFALSE 93824
// sPowell := true ;
93816: LD_ADDR_EXP 152
93820: PUSH
93821: LD_INT 1
93823: ST_TO_ADDR
// if p3 = 22 then
93824: LD_VAR 0 3
93828: PUSH
93829: LD_INT 22
93831: EQUAL
93832: IFFALSE 93842
// sTeleport := true ;
93834: LD_ADDR_EXP 155
93838: PUSH
93839: LD_INT 1
93841: ST_TO_ADDR
// if p3 = 23 then
93842: LD_VAR 0 3
93846: PUSH
93847: LD_INT 23
93849: EQUAL
93850: IFFALSE 93860
// sOilTower := true ;
93852: LD_ADDR_EXP 157
93856: PUSH
93857: LD_INT 1
93859: ST_TO_ADDR
// if p3 = 24 then
93860: LD_VAR 0 3
93864: PUSH
93865: LD_INT 24
93867: EQUAL
93868: IFFALSE 93878
// sShovel := true ;
93870: LD_ADDR_EXP 158
93874: PUSH
93875: LD_INT 1
93877: ST_TO_ADDR
// if p3 = 25 then
93878: LD_VAR 0 3
93882: PUSH
93883: LD_INT 25
93885: EQUAL
93886: IFFALSE 93896
// sSheik := true ;
93888: LD_ADDR_EXP 159
93892: PUSH
93893: LD_INT 1
93895: ST_TO_ADDR
// if p3 = 26 then
93896: LD_VAR 0 3
93900: PUSH
93901: LD_INT 26
93903: EQUAL
93904: IFFALSE 93914
// sEarthquake := true ;
93906: LD_ADDR_EXP 161
93910: PUSH
93911: LD_INT 1
93913: ST_TO_ADDR
// if p3 = 27 then
93914: LD_VAR 0 3
93918: PUSH
93919: LD_INT 27
93921: EQUAL
93922: IFFALSE 93932
// sAI := true ;
93924: LD_ADDR_EXP 162
93928: PUSH
93929: LD_INT 1
93931: ST_TO_ADDR
// if p3 = 28 then
93932: LD_VAR 0 3
93936: PUSH
93937: LD_INT 28
93939: EQUAL
93940: IFFALSE 93950
// sCargo := true ;
93942: LD_ADDR_EXP 165
93946: PUSH
93947: LD_INT 1
93949: ST_TO_ADDR
// if p3 = 29 then
93950: LD_VAR 0 3
93954: PUSH
93955: LD_INT 29
93957: EQUAL
93958: IFFALSE 93968
// sDLaser := true ;
93960: LD_ADDR_EXP 166
93964: PUSH
93965: LD_INT 1
93967: ST_TO_ADDR
// if p3 = 30 then
93968: LD_VAR 0 3
93972: PUSH
93973: LD_INT 30
93975: EQUAL
93976: IFFALSE 93986
// sExchange := true ;
93978: LD_ADDR_EXP 167
93982: PUSH
93983: LD_INT 1
93985: ST_TO_ADDR
// if p3 = 31 then
93986: LD_VAR 0 3
93990: PUSH
93991: LD_INT 31
93993: EQUAL
93994: IFFALSE 94004
// sFac := true ;
93996: LD_ADDR_EXP 168
94000: PUSH
94001: LD_INT 1
94003: ST_TO_ADDR
// if p3 = 32 then
94004: LD_VAR 0 3
94008: PUSH
94009: LD_INT 32
94011: EQUAL
94012: IFFALSE 94022
// sPower := true ;
94014: LD_ADDR_EXP 169
94018: PUSH
94019: LD_INT 1
94021: ST_TO_ADDR
// if p3 = 33 then
94022: LD_VAR 0 3
94026: PUSH
94027: LD_INT 33
94029: EQUAL
94030: IFFALSE 94040
// sRandom := true ;
94032: LD_ADDR_EXP 170
94036: PUSH
94037: LD_INT 1
94039: ST_TO_ADDR
// if p3 = 34 then
94040: LD_VAR 0 3
94044: PUSH
94045: LD_INT 34
94047: EQUAL
94048: IFFALSE 94058
// sShield := true ;
94050: LD_ADDR_EXP 171
94054: PUSH
94055: LD_INT 1
94057: ST_TO_ADDR
// if p3 = 35 then
94058: LD_VAR 0 3
94062: PUSH
94063: LD_INT 35
94065: EQUAL
94066: IFFALSE 94076
// sTime := true ;
94068: LD_ADDR_EXP 172
94072: PUSH
94073: LD_INT 1
94075: ST_TO_ADDR
// if p3 = 36 then
94076: LD_VAR 0 3
94080: PUSH
94081: LD_INT 36
94083: EQUAL
94084: IFFALSE 94094
// sTools := true ;
94086: LD_ADDR_EXP 173
94090: PUSH
94091: LD_INT 1
94093: ST_TO_ADDR
// if p3 = 101 then
94094: LD_VAR 0 3
94098: PUSH
94099: LD_INT 101
94101: EQUAL
94102: IFFALSE 94112
// sSold := true ;
94104: LD_ADDR_EXP 138
94108: PUSH
94109: LD_INT 1
94111: ST_TO_ADDR
// if p3 = 102 then
94112: LD_VAR 0 3
94116: PUSH
94117: LD_INT 102
94119: EQUAL
94120: IFFALSE 94130
// sDiff := true ;
94122: LD_ADDR_EXP 139
94126: PUSH
94127: LD_INT 1
94129: ST_TO_ADDR
// if p3 = 103 then
94130: LD_VAR 0 3
94134: PUSH
94135: LD_INT 103
94137: EQUAL
94138: IFFALSE 94148
// sFog := true ;
94140: LD_ADDR_EXP 142
94144: PUSH
94145: LD_INT 1
94147: ST_TO_ADDR
// if p3 = 104 then
94148: LD_VAR 0 3
94152: PUSH
94153: LD_INT 104
94155: EQUAL
94156: IFFALSE 94166
// sReset := true ;
94158: LD_ADDR_EXP 143
94162: PUSH
94163: LD_INT 1
94165: ST_TO_ADDR
// if p3 = 105 then
94166: LD_VAR 0 3
94170: PUSH
94171: LD_INT 105
94173: EQUAL
94174: IFFALSE 94184
// sSun := true ;
94176: LD_ADDR_EXP 144
94180: PUSH
94181: LD_INT 1
94183: ST_TO_ADDR
// if p3 = 106 then
94184: LD_VAR 0 3
94188: PUSH
94189: LD_INT 106
94191: EQUAL
94192: IFFALSE 94202
// sTiger := true ;
94194: LD_ADDR_EXP 140
94198: PUSH
94199: LD_INT 1
94201: ST_TO_ADDR
// if p3 = 107 then
94202: LD_VAR 0 3
94206: PUSH
94207: LD_INT 107
94209: EQUAL
94210: IFFALSE 94220
// sBomb := true ;
94212: LD_ADDR_EXP 141
94216: PUSH
94217: LD_INT 1
94219: ST_TO_ADDR
// if p3 = 108 then
94220: LD_VAR 0 3
94224: PUSH
94225: LD_INT 108
94227: EQUAL
94228: IFFALSE 94238
// sWound := true ;
94230: LD_ADDR_EXP 149
94234: PUSH
94235: LD_INT 1
94237: ST_TO_ADDR
// if p3 = 109 then
94238: LD_VAR 0 3
94242: PUSH
94243: LD_INT 109
94245: EQUAL
94246: IFFALSE 94256
// sBetray := true ;
94248: LD_ADDR_EXP 153
94252: PUSH
94253: LD_INT 1
94255: ST_TO_ADDR
// if p3 = 110 then
94256: LD_VAR 0 3
94260: PUSH
94261: LD_INT 110
94263: EQUAL
94264: IFFALSE 94274
// sContamin := true ;
94266: LD_ADDR_EXP 154
94270: PUSH
94271: LD_INT 1
94273: ST_TO_ADDR
// if p3 = 111 then
94274: LD_VAR 0 3
94278: PUSH
94279: LD_INT 111
94281: EQUAL
94282: IFFALSE 94292
// sOil := true ;
94284: LD_ADDR_EXP 156
94288: PUSH
94289: LD_INT 1
94291: ST_TO_ADDR
// if p3 = 112 then
94292: LD_VAR 0 3
94296: PUSH
94297: LD_INT 112
94299: EQUAL
94300: IFFALSE 94310
// sStu := true ;
94302: LD_ADDR_EXP 160
94306: PUSH
94307: LD_INT 1
94309: ST_TO_ADDR
// if p3 = 113 then
94310: LD_VAR 0 3
94314: PUSH
94315: LD_INT 113
94317: EQUAL
94318: IFFALSE 94328
// sBazooka := true ;
94320: LD_ADDR_EXP 163
94324: PUSH
94325: LD_INT 1
94327: ST_TO_ADDR
// if p3 = 114 then
94328: LD_VAR 0 3
94332: PUSH
94333: LD_INT 114
94335: EQUAL
94336: IFFALSE 94346
// sMortar := true ;
94338: LD_ADDR_EXP 164
94342: PUSH
94343: LD_INT 1
94345: ST_TO_ADDR
// if p3 = 115 then
94346: LD_VAR 0 3
94350: PUSH
94351: LD_INT 115
94353: EQUAL
94354: IFFALSE 94364
// sRanger := true ;
94356: LD_ADDR_EXP 174
94360: PUSH
94361: LD_INT 1
94363: ST_TO_ADDR
// if p3 = 116 then
94364: LD_VAR 0 3
94368: PUSH
94369: LD_INT 116
94371: EQUAL
94372: IFFALSE 94382
// sComputer := true ;
94374: LD_ADDR_EXP 175
94378: PUSH
94379: LD_INT 1
94381: ST_TO_ADDR
// if p3 = 117 then
94382: LD_VAR 0 3
94386: PUSH
94387: LD_INT 117
94389: EQUAL
94390: IFFALSE 94400
// s30 := true ;
94392: LD_ADDR_EXP 176
94396: PUSH
94397: LD_INT 1
94399: ST_TO_ADDR
// if p3 = 118 then
94400: LD_VAR 0 3
94404: PUSH
94405: LD_INT 118
94407: EQUAL
94408: IFFALSE 94418
// s60 := true ;
94410: LD_ADDR_EXP 177
94414: PUSH
94415: LD_INT 1
94417: ST_TO_ADDR
// end ; if p2 = stream_mode then
94418: LD_VAR 0 2
94422: PUSH
94423: LD_INT 101
94425: EQUAL
94426: IFFALSE 94554
// begin case p3 of 1 :
94428: LD_VAR 0 3
94432: PUSH
94433: LD_INT 1
94435: DOUBLE
94436: EQUAL
94437: IFTRUE 94441
94439: GO 94448
94441: POP
// hHackUnlimitedResources ; 2 :
94442: CALL 106652 0 0
94446: GO 94554
94448: LD_INT 2
94450: DOUBLE
94451: EQUAL
94452: IFTRUE 94456
94454: GO 94463
94456: POP
// hHackSetLevel10 ; 3 :
94457: CALL 106785 0 0
94461: GO 94554
94463: LD_INT 3
94465: DOUBLE
94466: EQUAL
94467: IFTRUE 94471
94469: GO 94478
94471: POP
// hHackSetLevel10YourUnits ; 4 :
94472: CALL 106870 0 0
94476: GO 94554
94478: LD_INT 4
94480: DOUBLE
94481: EQUAL
94482: IFTRUE 94486
94484: GO 94493
94486: POP
// hHackInvincible ; 5 :
94487: CALL 107318 0 0
94491: GO 94554
94493: LD_INT 5
94495: DOUBLE
94496: EQUAL
94497: IFTRUE 94501
94499: GO 94508
94501: POP
// hHackInvisible ; 6 :
94502: CALL 107429 0 0
94506: GO 94554
94508: LD_INT 6
94510: DOUBLE
94511: EQUAL
94512: IFTRUE 94516
94514: GO 94523
94516: POP
// hHackChangeYourSide ; 7 :
94517: CALL 107486 0 0
94521: GO 94554
94523: LD_INT 7
94525: DOUBLE
94526: EQUAL
94527: IFTRUE 94531
94529: GO 94538
94531: POP
// hHackChangeUnitSide ; 8 :
94532: CALL 107528 0 0
94536: GO 94554
94538: LD_INT 8
94540: DOUBLE
94541: EQUAL
94542: IFTRUE 94546
94544: GO 94553
94546: POP
// hHackFog ; end ;
94547: CALL 107629 0 0
94551: GO 94554
94553: POP
// end ; end ;
94554: LD_VAR 0 7
94558: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
94559: GO 94561
94561: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
94562: LD_STRING initStreamRollete();
94564: PPUSH
94565: CALL_OW 559
// InitStreamMode ;
94569: CALL 94581 0 0
// DefineStreamItems ( false ) ;
94573: LD_INT 0
94575: PPUSH
94576: CALL 95045 0 1
// end ;
94580: END
// function InitStreamMode ; begin
94581: LD_INT 0
94583: PPUSH
// streamModeActive := false ;
94584: LD_ADDR_EXP 121
94588: PUSH
94589: LD_INT 0
94591: ST_TO_ADDR
// normalCounter := 36 ;
94592: LD_ADDR_EXP 122
94596: PUSH
94597: LD_INT 36
94599: ST_TO_ADDR
// hardcoreCounter := 18 ;
94600: LD_ADDR_EXP 123
94604: PUSH
94605: LD_INT 18
94607: ST_TO_ADDR
// sRocket := false ;
94608: LD_ADDR_EXP 126
94612: PUSH
94613: LD_INT 0
94615: ST_TO_ADDR
// sSpeed := false ;
94616: LD_ADDR_EXP 125
94620: PUSH
94621: LD_INT 0
94623: ST_TO_ADDR
// sEngine := false ;
94624: LD_ADDR_EXP 127
94628: PUSH
94629: LD_INT 0
94631: ST_TO_ADDR
// sSpec := false ;
94632: LD_ADDR_EXP 124
94636: PUSH
94637: LD_INT 0
94639: ST_TO_ADDR
// sLevel := false ;
94640: LD_ADDR_EXP 128
94644: PUSH
94645: LD_INT 0
94647: ST_TO_ADDR
// sArmoury := false ;
94648: LD_ADDR_EXP 129
94652: PUSH
94653: LD_INT 0
94655: ST_TO_ADDR
// sRadar := false ;
94656: LD_ADDR_EXP 130
94660: PUSH
94661: LD_INT 0
94663: ST_TO_ADDR
// sBunker := false ;
94664: LD_ADDR_EXP 131
94668: PUSH
94669: LD_INT 0
94671: ST_TO_ADDR
// sHack := false ;
94672: LD_ADDR_EXP 132
94676: PUSH
94677: LD_INT 0
94679: ST_TO_ADDR
// sFire := false ;
94680: LD_ADDR_EXP 133
94684: PUSH
94685: LD_INT 0
94687: ST_TO_ADDR
// sRefresh := false ;
94688: LD_ADDR_EXP 134
94692: PUSH
94693: LD_INT 0
94695: ST_TO_ADDR
// sExp := false ;
94696: LD_ADDR_EXP 135
94700: PUSH
94701: LD_INT 0
94703: ST_TO_ADDR
// sDepot := false ;
94704: LD_ADDR_EXP 136
94708: PUSH
94709: LD_INT 0
94711: ST_TO_ADDR
// sFlag := false ;
94712: LD_ADDR_EXP 137
94716: PUSH
94717: LD_INT 0
94719: ST_TO_ADDR
// sKamikadze := false ;
94720: LD_ADDR_EXP 145
94724: PUSH
94725: LD_INT 0
94727: ST_TO_ADDR
// sTroll := false ;
94728: LD_ADDR_EXP 146
94732: PUSH
94733: LD_INT 0
94735: ST_TO_ADDR
// sSlow := false ;
94736: LD_ADDR_EXP 147
94740: PUSH
94741: LD_INT 0
94743: ST_TO_ADDR
// sLack := false ;
94744: LD_ADDR_EXP 148
94748: PUSH
94749: LD_INT 0
94751: ST_TO_ADDR
// sTank := false ;
94752: LD_ADDR_EXP 150
94756: PUSH
94757: LD_INT 0
94759: ST_TO_ADDR
// sRemote := false ;
94760: LD_ADDR_EXP 151
94764: PUSH
94765: LD_INT 0
94767: ST_TO_ADDR
// sPowell := false ;
94768: LD_ADDR_EXP 152
94772: PUSH
94773: LD_INT 0
94775: ST_TO_ADDR
// sTeleport := false ;
94776: LD_ADDR_EXP 155
94780: PUSH
94781: LD_INT 0
94783: ST_TO_ADDR
// sOilTower := false ;
94784: LD_ADDR_EXP 157
94788: PUSH
94789: LD_INT 0
94791: ST_TO_ADDR
// sShovel := false ;
94792: LD_ADDR_EXP 158
94796: PUSH
94797: LD_INT 0
94799: ST_TO_ADDR
// sSheik := false ;
94800: LD_ADDR_EXP 159
94804: PUSH
94805: LD_INT 0
94807: ST_TO_ADDR
// sEarthquake := false ;
94808: LD_ADDR_EXP 161
94812: PUSH
94813: LD_INT 0
94815: ST_TO_ADDR
// sAI := false ;
94816: LD_ADDR_EXP 162
94820: PUSH
94821: LD_INT 0
94823: ST_TO_ADDR
// sCargo := false ;
94824: LD_ADDR_EXP 165
94828: PUSH
94829: LD_INT 0
94831: ST_TO_ADDR
// sDLaser := false ;
94832: LD_ADDR_EXP 166
94836: PUSH
94837: LD_INT 0
94839: ST_TO_ADDR
// sExchange := false ;
94840: LD_ADDR_EXP 167
94844: PUSH
94845: LD_INT 0
94847: ST_TO_ADDR
// sFac := false ;
94848: LD_ADDR_EXP 168
94852: PUSH
94853: LD_INT 0
94855: ST_TO_ADDR
// sPower := false ;
94856: LD_ADDR_EXP 169
94860: PUSH
94861: LD_INT 0
94863: ST_TO_ADDR
// sRandom := false ;
94864: LD_ADDR_EXP 170
94868: PUSH
94869: LD_INT 0
94871: ST_TO_ADDR
// sShield := false ;
94872: LD_ADDR_EXP 171
94876: PUSH
94877: LD_INT 0
94879: ST_TO_ADDR
// sTime := false ;
94880: LD_ADDR_EXP 172
94884: PUSH
94885: LD_INT 0
94887: ST_TO_ADDR
// sTools := false ;
94888: LD_ADDR_EXP 173
94892: PUSH
94893: LD_INT 0
94895: ST_TO_ADDR
// sSold := false ;
94896: LD_ADDR_EXP 138
94900: PUSH
94901: LD_INT 0
94903: ST_TO_ADDR
// sDiff := false ;
94904: LD_ADDR_EXP 139
94908: PUSH
94909: LD_INT 0
94911: ST_TO_ADDR
// sFog := false ;
94912: LD_ADDR_EXP 142
94916: PUSH
94917: LD_INT 0
94919: ST_TO_ADDR
// sReset := false ;
94920: LD_ADDR_EXP 143
94924: PUSH
94925: LD_INT 0
94927: ST_TO_ADDR
// sSun := false ;
94928: LD_ADDR_EXP 144
94932: PUSH
94933: LD_INT 0
94935: ST_TO_ADDR
// sTiger := false ;
94936: LD_ADDR_EXP 140
94940: PUSH
94941: LD_INT 0
94943: ST_TO_ADDR
// sBomb := false ;
94944: LD_ADDR_EXP 141
94948: PUSH
94949: LD_INT 0
94951: ST_TO_ADDR
// sWound := false ;
94952: LD_ADDR_EXP 149
94956: PUSH
94957: LD_INT 0
94959: ST_TO_ADDR
// sBetray := false ;
94960: LD_ADDR_EXP 153
94964: PUSH
94965: LD_INT 0
94967: ST_TO_ADDR
// sContamin := false ;
94968: LD_ADDR_EXP 154
94972: PUSH
94973: LD_INT 0
94975: ST_TO_ADDR
// sOil := false ;
94976: LD_ADDR_EXP 156
94980: PUSH
94981: LD_INT 0
94983: ST_TO_ADDR
// sStu := false ;
94984: LD_ADDR_EXP 160
94988: PUSH
94989: LD_INT 0
94991: ST_TO_ADDR
// sBazooka := false ;
94992: LD_ADDR_EXP 163
94996: PUSH
94997: LD_INT 0
94999: ST_TO_ADDR
// sMortar := false ;
95000: LD_ADDR_EXP 164
95004: PUSH
95005: LD_INT 0
95007: ST_TO_ADDR
// sRanger := false ;
95008: LD_ADDR_EXP 174
95012: PUSH
95013: LD_INT 0
95015: ST_TO_ADDR
// sComputer := false ;
95016: LD_ADDR_EXP 175
95020: PUSH
95021: LD_INT 0
95023: ST_TO_ADDR
// s30 := false ;
95024: LD_ADDR_EXP 176
95028: PUSH
95029: LD_INT 0
95031: ST_TO_ADDR
// s60 := false ;
95032: LD_ADDR_EXP 177
95036: PUSH
95037: LD_INT 0
95039: ST_TO_ADDR
// end ;
95040: LD_VAR 0 1
95044: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
95045: LD_INT 0
95047: PPUSH
95048: PPUSH
95049: PPUSH
95050: PPUSH
95051: PPUSH
95052: PPUSH
95053: PPUSH
// result := [ ] ;
95054: LD_ADDR_VAR 0 2
95058: PUSH
95059: EMPTY
95060: ST_TO_ADDR
// if campaign_id = 1 then
95061: LD_OWVAR 69
95065: PUSH
95066: LD_INT 1
95068: EQUAL
95069: IFFALSE 98235
// begin case mission_number of 1 :
95071: LD_OWVAR 70
95075: PUSH
95076: LD_INT 1
95078: DOUBLE
95079: EQUAL
95080: IFTRUE 95084
95082: GO 95160
95084: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
95085: LD_ADDR_VAR 0 2
95089: PUSH
95090: LD_INT 2
95092: PUSH
95093: LD_INT 4
95095: PUSH
95096: LD_INT 11
95098: PUSH
95099: LD_INT 12
95101: PUSH
95102: LD_INT 15
95104: PUSH
95105: LD_INT 16
95107: PUSH
95108: LD_INT 22
95110: PUSH
95111: LD_INT 23
95113: PUSH
95114: LD_INT 26
95116: PUSH
95117: EMPTY
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: PUSH
95128: LD_INT 101
95130: PUSH
95131: LD_INT 102
95133: PUSH
95134: LD_INT 106
95136: PUSH
95137: LD_INT 116
95139: PUSH
95140: LD_INT 117
95142: PUSH
95143: LD_INT 118
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: PUSH
95154: EMPTY
95155: LIST
95156: LIST
95157: ST_TO_ADDR
95158: GO 98233
95160: LD_INT 2
95162: DOUBLE
95163: EQUAL
95164: IFTRUE 95168
95166: GO 95252
95168: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95169: LD_ADDR_VAR 0 2
95173: PUSH
95174: LD_INT 2
95176: PUSH
95177: LD_INT 4
95179: PUSH
95180: LD_INT 11
95182: PUSH
95183: LD_INT 12
95185: PUSH
95186: LD_INT 15
95188: PUSH
95189: LD_INT 16
95191: PUSH
95192: LD_INT 22
95194: PUSH
95195: LD_INT 23
95197: PUSH
95198: LD_INT 26
95200: PUSH
95201: EMPTY
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: PUSH
95212: LD_INT 101
95214: PUSH
95215: LD_INT 102
95217: PUSH
95218: LD_INT 105
95220: PUSH
95221: LD_INT 106
95223: PUSH
95224: LD_INT 108
95226: PUSH
95227: LD_INT 116
95229: PUSH
95230: LD_INT 117
95232: PUSH
95233: LD_INT 118
95235: PUSH
95236: EMPTY
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: PUSH
95246: EMPTY
95247: LIST
95248: LIST
95249: ST_TO_ADDR
95250: GO 98233
95252: LD_INT 3
95254: DOUBLE
95255: EQUAL
95256: IFTRUE 95260
95258: GO 95348
95260: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95261: LD_ADDR_VAR 0 2
95265: PUSH
95266: LD_INT 2
95268: PUSH
95269: LD_INT 4
95271: PUSH
95272: LD_INT 5
95274: PUSH
95275: LD_INT 11
95277: PUSH
95278: LD_INT 12
95280: PUSH
95281: LD_INT 15
95283: PUSH
95284: LD_INT 16
95286: PUSH
95287: LD_INT 22
95289: PUSH
95290: LD_INT 26
95292: PUSH
95293: LD_INT 36
95295: PUSH
95296: EMPTY
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: PUSH
95308: LD_INT 101
95310: PUSH
95311: LD_INT 102
95313: PUSH
95314: LD_INT 105
95316: PUSH
95317: LD_INT 106
95319: PUSH
95320: LD_INT 108
95322: PUSH
95323: LD_INT 116
95325: PUSH
95326: LD_INT 117
95328: PUSH
95329: LD_INT 118
95331: PUSH
95332: EMPTY
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: ST_TO_ADDR
95346: GO 98233
95348: LD_INT 4
95350: DOUBLE
95351: EQUAL
95352: IFTRUE 95356
95354: GO 95452
95356: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95357: LD_ADDR_VAR 0 2
95361: PUSH
95362: LD_INT 2
95364: PUSH
95365: LD_INT 4
95367: PUSH
95368: LD_INT 5
95370: PUSH
95371: LD_INT 8
95373: PUSH
95374: LD_INT 11
95376: PUSH
95377: LD_INT 12
95379: PUSH
95380: LD_INT 15
95382: PUSH
95383: LD_INT 16
95385: PUSH
95386: LD_INT 22
95388: PUSH
95389: LD_INT 23
95391: PUSH
95392: LD_INT 26
95394: PUSH
95395: LD_INT 36
95397: PUSH
95398: EMPTY
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: PUSH
95412: LD_INT 101
95414: PUSH
95415: LD_INT 102
95417: PUSH
95418: LD_INT 105
95420: PUSH
95421: LD_INT 106
95423: PUSH
95424: LD_INT 108
95426: PUSH
95427: LD_INT 116
95429: PUSH
95430: LD_INT 117
95432: PUSH
95433: LD_INT 118
95435: PUSH
95436: EMPTY
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: ST_TO_ADDR
95450: GO 98233
95452: LD_INT 5
95454: DOUBLE
95455: EQUAL
95456: IFTRUE 95460
95458: GO 95572
95460: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95461: LD_ADDR_VAR 0 2
95465: PUSH
95466: LD_INT 2
95468: PUSH
95469: LD_INT 4
95471: PUSH
95472: LD_INT 5
95474: PUSH
95475: LD_INT 6
95477: PUSH
95478: LD_INT 8
95480: PUSH
95481: LD_INT 11
95483: PUSH
95484: LD_INT 12
95486: PUSH
95487: LD_INT 15
95489: PUSH
95490: LD_INT 16
95492: PUSH
95493: LD_INT 22
95495: PUSH
95496: LD_INT 23
95498: PUSH
95499: LD_INT 25
95501: PUSH
95502: LD_INT 26
95504: PUSH
95505: LD_INT 36
95507: PUSH
95508: EMPTY
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: PUSH
95524: LD_INT 101
95526: PUSH
95527: LD_INT 102
95529: PUSH
95530: LD_INT 105
95532: PUSH
95533: LD_INT 106
95535: PUSH
95536: LD_INT 108
95538: PUSH
95539: LD_INT 109
95541: PUSH
95542: LD_INT 112
95544: PUSH
95545: LD_INT 116
95547: PUSH
95548: LD_INT 117
95550: PUSH
95551: LD_INT 118
95553: PUSH
95554: EMPTY
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: PUSH
95566: EMPTY
95567: LIST
95568: LIST
95569: ST_TO_ADDR
95570: GO 98233
95572: LD_INT 6
95574: DOUBLE
95575: EQUAL
95576: IFTRUE 95580
95578: GO 95712
95580: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
95581: LD_ADDR_VAR 0 2
95585: PUSH
95586: LD_INT 2
95588: PUSH
95589: LD_INT 4
95591: PUSH
95592: LD_INT 5
95594: PUSH
95595: LD_INT 6
95597: PUSH
95598: LD_INT 8
95600: PUSH
95601: LD_INT 11
95603: PUSH
95604: LD_INT 12
95606: PUSH
95607: LD_INT 15
95609: PUSH
95610: LD_INT 16
95612: PUSH
95613: LD_INT 20
95615: PUSH
95616: LD_INT 21
95618: PUSH
95619: LD_INT 22
95621: PUSH
95622: LD_INT 23
95624: PUSH
95625: LD_INT 25
95627: PUSH
95628: LD_INT 26
95630: PUSH
95631: LD_INT 30
95633: PUSH
95634: LD_INT 31
95636: PUSH
95637: LD_INT 32
95639: PUSH
95640: LD_INT 36
95642: PUSH
95643: EMPTY
95644: LIST
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: PUSH
95664: LD_INT 101
95666: PUSH
95667: LD_INT 102
95669: PUSH
95670: LD_INT 105
95672: PUSH
95673: LD_INT 106
95675: PUSH
95676: LD_INT 108
95678: PUSH
95679: LD_INT 109
95681: PUSH
95682: LD_INT 112
95684: PUSH
95685: LD_INT 116
95687: PUSH
95688: LD_INT 117
95690: PUSH
95691: LD_INT 118
95693: PUSH
95694: EMPTY
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: PUSH
95706: EMPTY
95707: LIST
95708: LIST
95709: ST_TO_ADDR
95710: GO 98233
95712: LD_INT 7
95714: DOUBLE
95715: EQUAL
95716: IFTRUE 95720
95718: GO 95832
95720: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95721: LD_ADDR_VAR 0 2
95725: PUSH
95726: LD_INT 2
95728: PUSH
95729: LD_INT 4
95731: PUSH
95732: LD_INT 5
95734: PUSH
95735: LD_INT 7
95737: PUSH
95738: LD_INT 11
95740: PUSH
95741: LD_INT 12
95743: PUSH
95744: LD_INT 15
95746: PUSH
95747: LD_INT 16
95749: PUSH
95750: LD_INT 20
95752: PUSH
95753: LD_INT 21
95755: PUSH
95756: LD_INT 22
95758: PUSH
95759: LD_INT 23
95761: PUSH
95762: LD_INT 25
95764: PUSH
95765: LD_INT 26
95767: PUSH
95768: EMPTY
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: PUSH
95784: LD_INT 101
95786: PUSH
95787: LD_INT 102
95789: PUSH
95790: LD_INT 103
95792: PUSH
95793: LD_INT 105
95795: PUSH
95796: LD_INT 106
95798: PUSH
95799: LD_INT 108
95801: PUSH
95802: LD_INT 112
95804: PUSH
95805: LD_INT 116
95807: PUSH
95808: LD_INT 117
95810: PUSH
95811: LD_INT 118
95813: PUSH
95814: EMPTY
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: PUSH
95826: EMPTY
95827: LIST
95828: LIST
95829: ST_TO_ADDR
95830: GO 98233
95832: LD_INT 8
95834: DOUBLE
95835: EQUAL
95836: IFTRUE 95840
95838: GO 95980
95840: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
95841: LD_ADDR_VAR 0 2
95845: PUSH
95846: LD_INT 2
95848: PUSH
95849: LD_INT 4
95851: PUSH
95852: LD_INT 5
95854: PUSH
95855: LD_INT 6
95857: PUSH
95858: LD_INT 7
95860: PUSH
95861: LD_INT 8
95863: PUSH
95864: LD_INT 11
95866: PUSH
95867: LD_INT 12
95869: PUSH
95870: LD_INT 15
95872: PUSH
95873: LD_INT 16
95875: PUSH
95876: LD_INT 20
95878: PUSH
95879: LD_INT 21
95881: PUSH
95882: LD_INT 22
95884: PUSH
95885: LD_INT 23
95887: PUSH
95888: LD_INT 25
95890: PUSH
95891: LD_INT 26
95893: PUSH
95894: LD_INT 30
95896: PUSH
95897: LD_INT 31
95899: PUSH
95900: LD_INT 32
95902: PUSH
95903: LD_INT 36
95905: PUSH
95906: EMPTY
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: PUSH
95928: LD_INT 101
95930: PUSH
95931: LD_INT 102
95933: PUSH
95934: LD_INT 103
95936: PUSH
95937: LD_INT 105
95939: PUSH
95940: LD_INT 106
95942: PUSH
95943: LD_INT 108
95945: PUSH
95946: LD_INT 109
95948: PUSH
95949: LD_INT 112
95951: PUSH
95952: LD_INT 116
95954: PUSH
95955: LD_INT 117
95957: PUSH
95958: LD_INT 118
95960: PUSH
95961: EMPTY
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: ST_TO_ADDR
95978: GO 98233
95980: LD_INT 9
95982: DOUBLE
95983: EQUAL
95984: IFTRUE 95988
95986: GO 96136
95988: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
95989: LD_ADDR_VAR 0 2
95993: PUSH
95994: LD_INT 2
95996: PUSH
95997: LD_INT 4
95999: PUSH
96000: LD_INT 5
96002: PUSH
96003: LD_INT 6
96005: PUSH
96006: LD_INT 7
96008: PUSH
96009: LD_INT 8
96011: PUSH
96012: LD_INT 11
96014: PUSH
96015: LD_INT 12
96017: PUSH
96018: LD_INT 15
96020: PUSH
96021: LD_INT 16
96023: PUSH
96024: LD_INT 20
96026: PUSH
96027: LD_INT 21
96029: PUSH
96030: LD_INT 22
96032: PUSH
96033: LD_INT 23
96035: PUSH
96036: LD_INT 25
96038: PUSH
96039: LD_INT 26
96041: PUSH
96042: LD_INT 28
96044: PUSH
96045: LD_INT 30
96047: PUSH
96048: LD_INT 31
96050: PUSH
96051: LD_INT 32
96053: PUSH
96054: LD_INT 36
96056: PUSH
96057: EMPTY
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: PUSH
96080: LD_INT 101
96082: PUSH
96083: LD_INT 102
96085: PUSH
96086: LD_INT 103
96088: PUSH
96089: LD_INT 105
96091: PUSH
96092: LD_INT 106
96094: PUSH
96095: LD_INT 108
96097: PUSH
96098: LD_INT 109
96100: PUSH
96101: LD_INT 112
96103: PUSH
96104: LD_INT 114
96106: PUSH
96107: LD_INT 116
96109: PUSH
96110: LD_INT 117
96112: PUSH
96113: LD_INT 118
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: PUSH
96130: EMPTY
96131: LIST
96132: LIST
96133: ST_TO_ADDR
96134: GO 98233
96136: LD_INT 10
96138: DOUBLE
96139: EQUAL
96140: IFTRUE 96144
96142: GO 96340
96144: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96145: LD_ADDR_VAR 0 2
96149: PUSH
96150: LD_INT 2
96152: PUSH
96153: LD_INT 4
96155: PUSH
96156: LD_INT 5
96158: PUSH
96159: LD_INT 6
96161: PUSH
96162: LD_INT 7
96164: PUSH
96165: LD_INT 8
96167: PUSH
96168: LD_INT 9
96170: PUSH
96171: LD_INT 10
96173: PUSH
96174: LD_INT 11
96176: PUSH
96177: LD_INT 12
96179: PUSH
96180: LD_INT 13
96182: PUSH
96183: LD_INT 14
96185: PUSH
96186: LD_INT 15
96188: PUSH
96189: LD_INT 16
96191: PUSH
96192: LD_INT 17
96194: PUSH
96195: LD_INT 18
96197: PUSH
96198: LD_INT 19
96200: PUSH
96201: LD_INT 20
96203: PUSH
96204: LD_INT 21
96206: PUSH
96207: LD_INT 22
96209: PUSH
96210: LD_INT 23
96212: PUSH
96213: LD_INT 24
96215: PUSH
96216: LD_INT 25
96218: PUSH
96219: LD_INT 26
96221: PUSH
96222: LD_INT 28
96224: PUSH
96225: LD_INT 30
96227: PUSH
96228: LD_INT 31
96230: PUSH
96231: LD_INT 32
96233: PUSH
96234: LD_INT 36
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: LIST
96241: LIST
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: PUSH
96268: LD_INT 101
96270: PUSH
96271: LD_INT 102
96273: PUSH
96274: LD_INT 103
96276: PUSH
96277: LD_INT 104
96279: PUSH
96280: LD_INT 105
96282: PUSH
96283: LD_INT 106
96285: PUSH
96286: LD_INT 107
96288: PUSH
96289: LD_INT 108
96291: PUSH
96292: LD_INT 109
96294: PUSH
96295: LD_INT 110
96297: PUSH
96298: LD_INT 111
96300: PUSH
96301: LD_INT 112
96303: PUSH
96304: LD_INT 114
96306: PUSH
96307: LD_INT 116
96309: PUSH
96310: LD_INT 117
96312: PUSH
96313: LD_INT 118
96315: PUSH
96316: EMPTY
96317: LIST
96318: LIST
96319: LIST
96320: LIST
96321: LIST
96322: LIST
96323: LIST
96324: LIST
96325: LIST
96326: LIST
96327: LIST
96328: LIST
96329: LIST
96330: LIST
96331: LIST
96332: LIST
96333: PUSH
96334: EMPTY
96335: LIST
96336: LIST
96337: ST_TO_ADDR
96338: GO 98233
96340: LD_INT 11
96342: DOUBLE
96343: EQUAL
96344: IFTRUE 96348
96346: GO 96552
96348: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96349: LD_ADDR_VAR 0 2
96353: PUSH
96354: LD_INT 2
96356: PUSH
96357: LD_INT 3
96359: PUSH
96360: LD_INT 4
96362: PUSH
96363: LD_INT 5
96365: PUSH
96366: LD_INT 6
96368: PUSH
96369: LD_INT 7
96371: PUSH
96372: LD_INT 8
96374: PUSH
96375: LD_INT 9
96377: PUSH
96378: LD_INT 10
96380: PUSH
96381: LD_INT 11
96383: PUSH
96384: LD_INT 12
96386: PUSH
96387: LD_INT 13
96389: PUSH
96390: LD_INT 14
96392: PUSH
96393: LD_INT 15
96395: PUSH
96396: LD_INT 16
96398: PUSH
96399: LD_INT 17
96401: PUSH
96402: LD_INT 18
96404: PUSH
96405: LD_INT 19
96407: PUSH
96408: LD_INT 20
96410: PUSH
96411: LD_INT 21
96413: PUSH
96414: LD_INT 22
96416: PUSH
96417: LD_INT 23
96419: PUSH
96420: LD_INT 24
96422: PUSH
96423: LD_INT 25
96425: PUSH
96426: LD_INT 26
96428: PUSH
96429: LD_INT 28
96431: PUSH
96432: LD_INT 30
96434: PUSH
96435: LD_INT 31
96437: PUSH
96438: LD_INT 32
96440: PUSH
96441: LD_INT 34
96443: PUSH
96444: LD_INT 36
96446: PUSH
96447: EMPTY
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: LIST
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: LIST
96478: LIST
96479: PUSH
96480: LD_INT 101
96482: PUSH
96483: LD_INT 102
96485: PUSH
96486: LD_INT 103
96488: PUSH
96489: LD_INT 104
96491: PUSH
96492: LD_INT 105
96494: PUSH
96495: LD_INT 106
96497: PUSH
96498: LD_INT 107
96500: PUSH
96501: LD_INT 108
96503: PUSH
96504: LD_INT 109
96506: PUSH
96507: LD_INT 110
96509: PUSH
96510: LD_INT 111
96512: PUSH
96513: LD_INT 112
96515: PUSH
96516: LD_INT 114
96518: PUSH
96519: LD_INT 116
96521: PUSH
96522: LD_INT 117
96524: PUSH
96525: LD_INT 118
96527: PUSH
96528: EMPTY
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: ST_TO_ADDR
96550: GO 98233
96552: LD_INT 12
96554: DOUBLE
96555: EQUAL
96556: IFTRUE 96560
96558: GO 96780
96560: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
96561: LD_ADDR_VAR 0 2
96565: PUSH
96566: LD_INT 1
96568: PUSH
96569: LD_INT 2
96571: PUSH
96572: LD_INT 3
96574: PUSH
96575: LD_INT 4
96577: PUSH
96578: LD_INT 5
96580: PUSH
96581: LD_INT 6
96583: PUSH
96584: LD_INT 7
96586: PUSH
96587: LD_INT 8
96589: PUSH
96590: LD_INT 9
96592: PUSH
96593: LD_INT 10
96595: PUSH
96596: LD_INT 11
96598: PUSH
96599: LD_INT 12
96601: PUSH
96602: LD_INT 13
96604: PUSH
96605: LD_INT 14
96607: PUSH
96608: LD_INT 15
96610: PUSH
96611: LD_INT 16
96613: PUSH
96614: LD_INT 17
96616: PUSH
96617: LD_INT 18
96619: PUSH
96620: LD_INT 19
96622: PUSH
96623: LD_INT 20
96625: PUSH
96626: LD_INT 21
96628: PUSH
96629: LD_INT 22
96631: PUSH
96632: LD_INT 23
96634: PUSH
96635: LD_INT 24
96637: PUSH
96638: LD_INT 25
96640: PUSH
96641: LD_INT 26
96643: PUSH
96644: LD_INT 27
96646: PUSH
96647: LD_INT 28
96649: PUSH
96650: LD_INT 30
96652: PUSH
96653: LD_INT 31
96655: PUSH
96656: LD_INT 32
96658: PUSH
96659: LD_INT 33
96661: PUSH
96662: LD_INT 34
96664: PUSH
96665: LD_INT 36
96667: PUSH
96668: EMPTY
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: PUSH
96704: LD_INT 101
96706: PUSH
96707: LD_INT 102
96709: PUSH
96710: LD_INT 103
96712: PUSH
96713: LD_INT 104
96715: PUSH
96716: LD_INT 105
96718: PUSH
96719: LD_INT 106
96721: PUSH
96722: LD_INT 107
96724: PUSH
96725: LD_INT 108
96727: PUSH
96728: LD_INT 109
96730: PUSH
96731: LD_INT 110
96733: PUSH
96734: LD_INT 111
96736: PUSH
96737: LD_INT 112
96739: PUSH
96740: LD_INT 113
96742: PUSH
96743: LD_INT 114
96745: PUSH
96746: LD_INT 116
96748: PUSH
96749: LD_INT 117
96751: PUSH
96752: LD_INT 118
96754: PUSH
96755: EMPTY
96756: LIST
96757: LIST
96758: LIST
96759: LIST
96760: LIST
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: LIST
96772: LIST
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: ST_TO_ADDR
96778: GO 98233
96780: LD_INT 13
96782: DOUBLE
96783: EQUAL
96784: IFTRUE 96788
96786: GO 96996
96788: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
96789: LD_ADDR_VAR 0 2
96793: PUSH
96794: LD_INT 1
96796: PUSH
96797: LD_INT 2
96799: PUSH
96800: LD_INT 3
96802: PUSH
96803: LD_INT 4
96805: PUSH
96806: LD_INT 5
96808: PUSH
96809: LD_INT 8
96811: PUSH
96812: LD_INT 9
96814: PUSH
96815: LD_INT 10
96817: PUSH
96818: LD_INT 11
96820: PUSH
96821: LD_INT 12
96823: PUSH
96824: LD_INT 14
96826: PUSH
96827: LD_INT 15
96829: PUSH
96830: LD_INT 16
96832: PUSH
96833: LD_INT 17
96835: PUSH
96836: LD_INT 18
96838: PUSH
96839: LD_INT 19
96841: PUSH
96842: LD_INT 20
96844: PUSH
96845: LD_INT 21
96847: PUSH
96848: LD_INT 22
96850: PUSH
96851: LD_INT 23
96853: PUSH
96854: LD_INT 24
96856: PUSH
96857: LD_INT 25
96859: PUSH
96860: LD_INT 26
96862: PUSH
96863: LD_INT 27
96865: PUSH
96866: LD_INT 28
96868: PUSH
96869: LD_INT 30
96871: PUSH
96872: LD_INT 31
96874: PUSH
96875: LD_INT 32
96877: PUSH
96878: LD_INT 33
96880: PUSH
96881: LD_INT 34
96883: PUSH
96884: LD_INT 36
96886: PUSH
96887: EMPTY
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: LIST
96917: LIST
96918: LIST
96919: PUSH
96920: LD_INT 101
96922: PUSH
96923: LD_INT 102
96925: PUSH
96926: LD_INT 103
96928: PUSH
96929: LD_INT 104
96931: PUSH
96932: LD_INT 105
96934: PUSH
96935: LD_INT 106
96937: PUSH
96938: LD_INT 107
96940: PUSH
96941: LD_INT 108
96943: PUSH
96944: LD_INT 109
96946: PUSH
96947: LD_INT 110
96949: PUSH
96950: LD_INT 111
96952: PUSH
96953: LD_INT 112
96955: PUSH
96956: LD_INT 113
96958: PUSH
96959: LD_INT 114
96961: PUSH
96962: LD_INT 116
96964: PUSH
96965: LD_INT 117
96967: PUSH
96968: LD_INT 118
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: ST_TO_ADDR
96994: GO 98233
96996: LD_INT 14
96998: DOUBLE
96999: EQUAL
97000: IFTRUE 97004
97002: GO 97228
97004: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
97005: LD_ADDR_VAR 0 2
97009: PUSH
97010: LD_INT 1
97012: PUSH
97013: LD_INT 2
97015: PUSH
97016: LD_INT 3
97018: PUSH
97019: LD_INT 4
97021: PUSH
97022: LD_INT 5
97024: PUSH
97025: LD_INT 6
97027: PUSH
97028: LD_INT 7
97030: PUSH
97031: LD_INT 8
97033: PUSH
97034: LD_INT 9
97036: PUSH
97037: LD_INT 10
97039: PUSH
97040: LD_INT 11
97042: PUSH
97043: LD_INT 12
97045: PUSH
97046: LD_INT 13
97048: PUSH
97049: LD_INT 14
97051: PUSH
97052: LD_INT 15
97054: PUSH
97055: LD_INT 16
97057: PUSH
97058: LD_INT 17
97060: PUSH
97061: LD_INT 18
97063: PUSH
97064: LD_INT 19
97066: PUSH
97067: LD_INT 20
97069: PUSH
97070: LD_INT 21
97072: PUSH
97073: LD_INT 22
97075: PUSH
97076: LD_INT 23
97078: PUSH
97079: LD_INT 24
97081: PUSH
97082: LD_INT 25
97084: PUSH
97085: LD_INT 26
97087: PUSH
97088: LD_INT 27
97090: PUSH
97091: LD_INT 28
97093: PUSH
97094: LD_INT 29
97096: PUSH
97097: LD_INT 30
97099: PUSH
97100: LD_INT 31
97102: PUSH
97103: LD_INT 32
97105: PUSH
97106: LD_INT 33
97108: PUSH
97109: LD_INT 34
97111: PUSH
97112: LD_INT 36
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: PUSH
97152: LD_INT 101
97154: PUSH
97155: LD_INT 102
97157: PUSH
97158: LD_INT 103
97160: PUSH
97161: LD_INT 104
97163: PUSH
97164: LD_INT 105
97166: PUSH
97167: LD_INT 106
97169: PUSH
97170: LD_INT 107
97172: PUSH
97173: LD_INT 108
97175: PUSH
97176: LD_INT 109
97178: PUSH
97179: LD_INT 110
97181: PUSH
97182: LD_INT 111
97184: PUSH
97185: LD_INT 112
97187: PUSH
97188: LD_INT 113
97190: PUSH
97191: LD_INT 114
97193: PUSH
97194: LD_INT 116
97196: PUSH
97197: LD_INT 117
97199: PUSH
97200: LD_INT 118
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: ST_TO_ADDR
97226: GO 98233
97228: LD_INT 15
97230: DOUBLE
97231: EQUAL
97232: IFTRUE 97236
97234: GO 97460
97236: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97237: LD_ADDR_VAR 0 2
97241: PUSH
97242: LD_INT 1
97244: PUSH
97245: LD_INT 2
97247: PUSH
97248: LD_INT 3
97250: PUSH
97251: LD_INT 4
97253: PUSH
97254: LD_INT 5
97256: PUSH
97257: LD_INT 6
97259: PUSH
97260: LD_INT 7
97262: PUSH
97263: LD_INT 8
97265: PUSH
97266: LD_INT 9
97268: PUSH
97269: LD_INT 10
97271: PUSH
97272: LD_INT 11
97274: PUSH
97275: LD_INT 12
97277: PUSH
97278: LD_INT 13
97280: PUSH
97281: LD_INT 14
97283: PUSH
97284: LD_INT 15
97286: PUSH
97287: LD_INT 16
97289: PUSH
97290: LD_INT 17
97292: PUSH
97293: LD_INT 18
97295: PUSH
97296: LD_INT 19
97298: PUSH
97299: LD_INT 20
97301: PUSH
97302: LD_INT 21
97304: PUSH
97305: LD_INT 22
97307: PUSH
97308: LD_INT 23
97310: PUSH
97311: LD_INT 24
97313: PUSH
97314: LD_INT 25
97316: PUSH
97317: LD_INT 26
97319: PUSH
97320: LD_INT 27
97322: PUSH
97323: LD_INT 28
97325: PUSH
97326: LD_INT 29
97328: PUSH
97329: LD_INT 30
97331: PUSH
97332: LD_INT 31
97334: PUSH
97335: LD_INT 32
97337: PUSH
97338: LD_INT 33
97340: PUSH
97341: LD_INT 34
97343: PUSH
97344: LD_INT 36
97346: PUSH
97347: EMPTY
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: PUSH
97384: LD_INT 101
97386: PUSH
97387: LD_INT 102
97389: PUSH
97390: LD_INT 103
97392: PUSH
97393: LD_INT 104
97395: PUSH
97396: LD_INT 105
97398: PUSH
97399: LD_INT 106
97401: PUSH
97402: LD_INT 107
97404: PUSH
97405: LD_INT 108
97407: PUSH
97408: LD_INT 109
97410: PUSH
97411: LD_INT 110
97413: PUSH
97414: LD_INT 111
97416: PUSH
97417: LD_INT 112
97419: PUSH
97420: LD_INT 113
97422: PUSH
97423: LD_INT 114
97425: PUSH
97426: LD_INT 116
97428: PUSH
97429: LD_INT 117
97431: PUSH
97432: LD_INT 118
97434: PUSH
97435: EMPTY
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: LIST
97441: LIST
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: LIST
97453: PUSH
97454: EMPTY
97455: LIST
97456: LIST
97457: ST_TO_ADDR
97458: GO 98233
97460: LD_INT 16
97462: DOUBLE
97463: EQUAL
97464: IFTRUE 97468
97466: GO 97604
97468: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97469: LD_ADDR_VAR 0 2
97473: PUSH
97474: LD_INT 2
97476: PUSH
97477: LD_INT 4
97479: PUSH
97480: LD_INT 5
97482: PUSH
97483: LD_INT 7
97485: PUSH
97486: LD_INT 11
97488: PUSH
97489: LD_INT 12
97491: PUSH
97492: LD_INT 15
97494: PUSH
97495: LD_INT 16
97497: PUSH
97498: LD_INT 20
97500: PUSH
97501: LD_INT 21
97503: PUSH
97504: LD_INT 22
97506: PUSH
97507: LD_INT 23
97509: PUSH
97510: LD_INT 25
97512: PUSH
97513: LD_INT 26
97515: PUSH
97516: LD_INT 30
97518: PUSH
97519: LD_INT 31
97521: PUSH
97522: LD_INT 32
97524: PUSH
97525: LD_INT 33
97527: PUSH
97528: LD_INT 34
97530: PUSH
97531: EMPTY
97532: LIST
97533: LIST
97534: LIST
97535: LIST
97536: LIST
97537: LIST
97538: LIST
97539: LIST
97540: LIST
97541: LIST
97542: LIST
97543: LIST
97544: LIST
97545: LIST
97546: LIST
97547: LIST
97548: LIST
97549: LIST
97550: LIST
97551: PUSH
97552: LD_INT 101
97554: PUSH
97555: LD_INT 102
97557: PUSH
97558: LD_INT 103
97560: PUSH
97561: LD_INT 106
97563: PUSH
97564: LD_INT 108
97566: PUSH
97567: LD_INT 112
97569: PUSH
97570: LD_INT 113
97572: PUSH
97573: LD_INT 114
97575: PUSH
97576: LD_INT 116
97578: PUSH
97579: LD_INT 117
97581: PUSH
97582: LD_INT 118
97584: PUSH
97585: EMPTY
97586: LIST
97587: LIST
97588: LIST
97589: LIST
97590: LIST
97591: LIST
97592: LIST
97593: LIST
97594: LIST
97595: LIST
97596: LIST
97597: PUSH
97598: EMPTY
97599: LIST
97600: LIST
97601: ST_TO_ADDR
97602: GO 98233
97604: LD_INT 17
97606: DOUBLE
97607: EQUAL
97608: IFTRUE 97612
97610: GO 97836
97612: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
97613: LD_ADDR_VAR 0 2
97617: PUSH
97618: LD_INT 1
97620: PUSH
97621: LD_INT 2
97623: PUSH
97624: LD_INT 3
97626: PUSH
97627: LD_INT 4
97629: PUSH
97630: LD_INT 5
97632: PUSH
97633: LD_INT 6
97635: PUSH
97636: LD_INT 7
97638: PUSH
97639: LD_INT 8
97641: PUSH
97642: LD_INT 9
97644: PUSH
97645: LD_INT 10
97647: PUSH
97648: LD_INT 11
97650: PUSH
97651: LD_INT 12
97653: PUSH
97654: LD_INT 13
97656: PUSH
97657: LD_INT 14
97659: PUSH
97660: LD_INT 15
97662: PUSH
97663: LD_INT 16
97665: PUSH
97666: LD_INT 17
97668: PUSH
97669: LD_INT 18
97671: PUSH
97672: LD_INT 19
97674: PUSH
97675: LD_INT 20
97677: PUSH
97678: LD_INT 21
97680: PUSH
97681: LD_INT 22
97683: PUSH
97684: LD_INT 23
97686: PUSH
97687: LD_INT 24
97689: PUSH
97690: LD_INT 25
97692: PUSH
97693: LD_INT 26
97695: PUSH
97696: LD_INT 27
97698: PUSH
97699: LD_INT 28
97701: PUSH
97702: LD_INT 29
97704: PUSH
97705: LD_INT 30
97707: PUSH
97708: LD_INT 31
97710: PUSH
97711: LD_INT 32
97713: PUSH
97714: LD_INT 33
97716: PUSH
97717: LD_INT 34
97719: PUSH
97720: LD_INT 36
97722: PUSH
97723: EMPTY
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: LIST
97759: PUSH
97760: LD_INT 101
97762: PUSH
97763: LD_INT 102
97765: PUSH
97766: LD_INT 103
97768: PUSH
97769: LD_INT 104
97771: PUSH
97772: LD_INT 105
97774: PUSH
97775: LD_INT 106
97777: PUSH
97778: LD_INT 107
97780: PUSH
97781: LD_INT 108
97783: PUSH
97784: LD_INT 109
97786: PUSH
97787: LD_INT 110
97789: PUSH
97790: LD_INT 111
97792: PUSH
97793: LD_INT 112
97795: PUSH
97796: LD_INT 113
97798: PUSH
97799: LD_INT 114
97801: PUSH
97802: LD_INT 116
97804: PUSH
97805: LD_INT 117
97807: PUSH
97808: LD_INT 118
97810: PUSH
97811: EMPTY
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: PUSH
97830: EMPTY
97831: LIST
97832: LIST
97833: ST_TO_ADDR
97834: GO 98233
97836: LD_INT 18
97838: DOUBLE
97839: EQUAL
97840: IFTRUE 97844
97842: GO 97992
97844: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
97845: LD_ADDR_VAR 0 2
97849: PUSH
97850: LD_INT 2
97852: PUSH
97853: LD_INT 4
97855: PUSH
97856: LD_INT 5
97858: PUSH
97859: LD_INT 7
97861: PUSH
97862: LD_INT 11
97864: PUSH
97865: LD_INT 12
97867: PUSH
97868: LD_INT 15
97870: PUSH
97871: LD_INT 16
97873: PUSH
97874: LD_INT 20
97876: PUSH
97877: LD_INT 21
97879: PUSH
97880: LD_INT 22
97882: PUSH
97883: LD_INT 23
97885: PUSH
97886: LD_INT 25
97888: PUSH
97889: LD_INT 26
97891: PUSH
97892: LD_INT 30
97894: PUSH
97895: LD_INT 31
97897: PUSH
97898: LD_INT 32
97900: PUSH
97901: LD_INT 33
97903: PUSH
97904: LD_INT 34
97906: PUSH
97907: LD_INT 35
97909: PUSH
97910: LD_INT 36
97912: PUSH
97913: EMPTY
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: PUSH
97936: LD_INT 101
97938: PUSH
97939: LD_INT 102
97941: PUSH
97942: LD_INT 103
97944: PUSH
97945: LD_INT 106
97947: PUSH
97948: LD_INT 108
97950: PUSH
97951: LD_INT 112
97953: PUSH
97954: LD_INT 113
97956: PUSH
97957: LD_INT 114
97959: PUSH
97960: LD_INT 115
97962: PUSH
97963: LD_INT 116
97965: PUSH
97966: LD_INT 117
97968: PUSH
97969: LD_INT 118
97971: PUSH
97972: EMPTY
97973: LIST
97974: LIST
97975: LIST
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: PUSH
97986: EMPTY
97987: LIST
97988: LIST
97989: ST_TO_ADDR
97990: GO 98233
97992: LD_INT 19
97994: DOUBLE
97995: EQUAL
97996: IFTRUE 98000
97998: GO 98232
98000: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
98001: LD_ADDR_VAR 0 2
98005: PUSH
98006: LD_INT 1
98008: PUSH
98009: LD_INT 2
98011: PUSH
98012: LD_INT 3
98014: PUSH
98015: LD_INT 4
98017: PUSH
98018: LD_INT 5
98020: PUSH
98021: LD_INT 6
98023: PUSH
98024: LD_INT 7
98026: PUSH
98027: LD_INT 8
98029: PUSH
98030: LD_INT 9
98032: PUSH
98033: LD_INT 10
98035: PUSH
98036: LD_INT 11
98038: PUSH
98039: LD_INT 12
98041: PUSH
98042: LD_INT 13
98044: PUSH
98045: LD_INT 14
98047: PUSH
98048: LD_INT 15
98050: PUSH
98051: LD_INT 16
98053: PUSH
98054: LD_INT 17
98056: PUSH
98057: LD_INT 18
98059: PUSH
98060: LD_INT 19
98062: PUSH
98063: LD_INT 20
98065: PUSH
98066: LD_INT 21
98068: PUSH
98069: LD_INT 22
98071: PUSH
98072: LD_INT 23
98074: PUSH
98075: LD_INT 24
98077: PUSH
98078: LD_INT 25
98080: PUSH
98081: LD_INT 26
98083: PUSH
98084: LD_INT 27
98086: PUSH
98087: LD_INT 28
98089: PUSH
98090: LD_INT 29
98092: PUSH
98093: LD_INT 30
98095: PUSH
98096: LD_INT 31
98098: PUSH
98099: LD_INT 32
98101: PUSH
98102: LD_INT 33
98104: PUSH
98105: LD_INT 34
98107: PUSH
98108: LD_INT 35
98110: PUSH
98111: LD_INT 36
98113: PUSH
98114: EMPTY
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: LIST
98128: LIST
98129: LIST
98130: LIST
98131: LIST
98132: LIST
98133: LIST
98134: LIST
98135: LIST
98136: LIST
98137: LIST
98138: LIST
98139: LIST
98140: LIST
98141: LIST
98142: LIST
98143: LIST
98144: LIST
98145: LIST
98146: LIST
98147: LIST
98148: LIST
98149: LIST
98150: LIST
98151: PUSH
98152: LD_INT 101
98154: PUSH
98155: LD_INT 102
98157: PUSH
98158: LD_INT 103
98160: PUSH
98161: LD_INT 104
98163: PUSH
98164: LD_INT 105
98166: PUSH
98167: LD_INT 106
98169: PUSH
98170: LD_INT 107
98172: PUSH
98173: LD_INT 108
98175: PUSH
98176: LD_INT 109
98178: PUSH
98179: LD_INT 110
98181: PUSH
98182: LD_INT 111
98184: PUSH
98185: LD_INT 112
98187: PUSH
98188: LD_INT 113
98190: PUSH
98191: LD_INT 114
98193: PUSH
98194: LD_INT 115
98196: PUSH
98197: LD_INT 116
98199: PUSH
98200: LD_INT 117
98202: PUSH
98203: LD_INT 118
98205: PUSH
98206: EMPTY
98207: LIST
98208: LIST
98209: LIST
98210: LIST
98211: LIST
98212: LIST
98213: LIST
98214: LIST
98215: LIST
98216: LIST
98217: LIST
98218: LIST
98219: LIST
98220: LIST
98221: LIST
98222: LIST
98223: LIST
98224: LIST
98225: PUSH
98226: EMPTY
98227: LIST
98228: LIST
98229: ST_TO_ADDR
98230: GO 98233
98232: POP
// end else
98233: GO 98464
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98235: LD_ADDR_VAR 0 2
98239: PUSH
98240: LD_INT 1
98242: PUSH
98243: LD_INT 2
98245: PUSH
98246: LD_INT 3
98248: PUSH
98249: LD_INT 4
98251: PUSH
98252: LD_INT 5
98254: PUSH
98255: LD_INT 6
98257: PUSH
98258: LD_INT 7
98260: PUSH
98261: LD_INT 8
98263: PUSH
98264: LD_INT 9
98266: PUSH
98267: LD_INT 10
98269: PUSH
98270: LD_INT 11
98272: PUSH
98273: LD_INT 12
98275: PUSH
98276: LD_INT 13
98278: PUSH
98279: LD_INT 14
98281: PUSH
98282: LD_INT 15
98284: PUSH
98285: LD_INT 16
98287: PUSH
98288: LD_INT 17
98290: PUSH
98291: LD_INT 18
98293: PUSH
98294: LD_INT 19
98296: PUSH
98297: LD_INT 20
98299: PUSH
98300: LD_INT 21
98302: PUSH
98303: LD_INT 22
98305: PUSH
98306: LD_INT 23
98308: PUSH
98309: LD_INT 24
98311: PUSH
98312: LD_INT 25
98314: PUSH
98315: LD_INT 26
98317: PUSH
98318: LD_INT 27
98320: PUSH
98321: LD_INT 28
98323: PUSH
98324: LD_INT 29
98326: PUSH
98327: LD_INT 30
98329: PUSH
98330: LD_INT 31
98332: PUSH
98333: LD_INT 32
98335: PUSH
98336: LD_INT 33
98338: PUSH
98339: LD_INT 34
98341: PUSH
98342: LD_INT 35
98344: PUSH
98345: LD_INT 36
98347: PUSH
98348: EMPTY
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: LIST
98360: LIST
98361: LIST
98362: LIST
98363: LIST
98364: LIST
98365: LIST
98366: LIST
98367: LIST
98368: LIST
98369: LIST
98370: LIST
98371: LIST
98372: LIST
98373: LIST
98374: LIST
98375: LIST
98376: LIST
98377: LIST
98378: LIST
98379: LIST
98380: LIST
98381: LIST
98382: LIST
98383: LIST
98384: LIST
98385: PUSH
98386: LD_INT 101
98388: PUSH
98389: LD_INT 102
98391: PUSH
98392: LD_INT 103
98394: PUSH
98395: LD_INT 104
98397: PUSH
98398: LD_INT 105
98400: PUSH
98401: LD_INT 106
98403: PUSH
98404: LD_INT 107
98406: PUSH
98407: LD_INT 108
98409: PUSH
98410: LD_INT 109
98412: PUSH
98413: LD_INT 110
98415: PUSH
98416: LD_INT 111
98418: PUSH
98419: LD_INT 112
98421: PUSH
98422: LD_INT 113
98424: PUSH
98425: LD_INT 114
98427: PUSH
98428: LD_INT 115
98430: PUSH
98431: LD_INT 116
98433: PUSH
98434: LD_INT 117
98436: PUSH
98437: LD_INT 118
98439: PUSH
98440: EMPTY
98441: LIST
98442: LIST
98443: LIST
98444: LIST
98445: LIST
98446: LIST
98447: LIST
98448: LIST
98449: LIST
98450: LIST
98451: LIST
98452: LIST
98453: LIST
98454: LIST
98455: LIST
98456: LIST
98457: LIST
98458: LIST
98459: PUSH
98460: EMPTY
98461: LIST
98462: LIST
98463: ST_TO_ADDR
// if result then
98464: LD_VAR 0 2
98468: IFFALSE 99254
// begin normal :=  ;
98470: LD_ADDR_VAR 0 5
98474: PUSH
98475: LD_STRING 
98477: ST_TO_ADDR
// hardcore :=  ;
98478: LD_ADDR_VAR 0 6
98482: PUSH
98483: LD_STRING 
98485: ST_TO_ADDR
// active :=  ;
98486: LD_ADDR_VAR 0 7
98490: PUSH
98491: LD_STRING 
98493: ST_TO_ADDR
// for i = 1 to normalCounter do
98494: LD_ADDR_VAR 0 8
98498: PUSH
98499: DOUBLE
98500: LD_INT 1
98502: DEC
98503: ST_TO_ADDR
98504: LD_EXP 122
98508: PUSH
98509: FOR_TO
98510: IFFALSE 98611
// begin tmp := 0 ;
98512: LD_ADDR_VAR 0 3
98516: PUSH
98517: LD_STRING 0
98519: ST_TO_ADDR
// if result [ 1 ] then
98520: LD_VAR 0 2
98524: PUSH
98525: LD_INT 1
98527: ARRAY
98528: IFFALSE 98593
// if result [ 1 ] [ 1 ] = i then
98530: LD_VAR 0 2
98534: PUSH
98535: LD_INT 1
98537: ARRAY
98538: PUSH
98539: LD_INT 1
98541: ARRAY
98542: PUSH
98543: LD_VAR 0 8
98547: EQUAL
98548: IFFALSE 98593
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
98550: LD_ADDR_VAR 0 2
98554: PUSH
98555: LD_VAR 0 2
98559: PPUSH
98560: LD_INT 1
98562: PPUSH
98563: LD_VAR 0 2
98567: PUSH
98568: LD_INT 1
98570: ARRAY
98571: PPUSH
98572: LD_INT 1
98574: PPUSH
98575: CALL_OW 3
98579: PPUSH
98580: CALL_OW 1
98584: ST_TO_ADDR
// tmp := 1 ;
98585: LD_ADDR_VAR 0 3
98589: PUSH
98590: LD_STRING 1
98592: ST_TO_ADDR
// end ; normal := normal & tmp ;
98593: LD_ADDR_VAR 0 5
98597: PUSH
98598: LD_VAR 0 5
98602: PUSH
98603: LD_VAR 0 3
98607: STR
98608: ST_TO_ADDR
// end ;
98609: GO 98509
98611: POP
98612: POP
// for i = 1 to hardcoreCounter do
98613: LD_ADDR_VAR 0 8
98617: PUSH
98618: DOUBLE
98619: LD_INT 1
98621: DEC
98622: ST_TO_ADDR
98623: LD_EXP 123
98627: PUSH
98628: FOR_TO
98629: IFFALSE 98734
// begin tmp := 0 ;
98631: LD_ADDR_VAR 0 3
98635: PUSH
98636: LD_STRING 0
98638: ST_TO_ADDR
// if result [ 2 ] then
98639: LD_VAR 0 2
98643: PUSH
98644: LD_INT 2
98646: ARRAY
98647: IFFALSE 98716
// if result [ 2 ] [ 1 ] = 100 + i then
98649: LD_VAR 0 2
98653: PUSH
98654: LD_INT 2
98656: ARRAY
98657: PUSH
98658: LD_INT 1
98660: ARRAY
98661: PUSH
98662: LD_INT 100
98664: PUSH
98665: LD_VAR 0 8
98669: PLUS
98670: EQUAL
98671: IFFALSE 98716
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
98673: LD_ADDR_VAR 0 2
98677: PUSH
98678: LD_VAR 0 2
98682: PPUSH
98683: LD_INT 2
98685: PPUSH
98686: LD_VAR 0 2
98690: PUSH
98691: LD_INT 2
98693: ARRAY
98694: PPUSH
98695: LD_INT 1
98697: PPUSH
98698: CALL_OW 3
98702: PPUSH
98703: CALL_OW 1
98707: ST_TO_ADDR
// tmp := 1 ;
98708: LD_ADDR_VAR 0 3
98712: PUSH
98713: LD_STRING 1
98715: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98716: LD_ADDR_VAR 0 6
98720: PUSH
98721: LD_VAR 0 6
98725: PUSH
98726: LD_VAR 0 3
98730: STR
98731: ST_TO_ADDR
// end ;
98732: GO 98628
98734: POP
98735: POP
// if isGameLoad then
98736: LD_VAR 0 1
98740: IFFALSE 99215
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
98742: LD_ADDR_VAR 0 4
98746: PUSH
98747: LD_EXP 126
98751: PUSH
98752: LD_EXP 125
98756: PUSH
98757: LD_EXP 127
98761: PUSH
98762: LD_EXP 124
98766: PUSH
98767: LD_EXP 128
98771: PUSH
98772: LD_EXP 129
98776: PUSH
98777: LD_EXP 130
98781: PUSH
98782: LD_EXP 131
98786: PUSH
98787: LD_EXP 132
98791: PUSH
98792: LD_EXP 133
98796: PUSH
98797: LD_EXP 134
98801: PUSH
98802: LD_EXP 135
98806: PUSH
98807: LD_EXP 136
98811: PUSH
98812: LD_EXP 137
98816: PUSH
98817: LD_EXP 145
98821: PUSH
98822: LD_EXP 146
98826: PUSH
98827: LD_EXP 147
98831: PUSH
98832: LD_EXP 148
98836: PUSH
98837: LD_EXP 150
98841: PUSH
98842: LD_EXP 151
98846: PUSH
98847: LD_EXP 152
98851: PUSH
98852: LD_EXP 155
98856: PUSH
98857: LD_EXP 157
98861: PUSH
98862: LD_EXP 158
98866: PUSH
98867: LD_EXP 159
98871: PUSH
98872: LD_EXP 161
98876: PUSH
98877: LD_EXP 162
98881: PUSH
98882: LD_EXP 165
98886: PUSH
98887: LD_EXP 166
98891: PUSH
98892: LD_EXP 167
98896: PUSH
98897: LD_EXP 168
98901: PUSH
98902: LD_EXP 169
98906: PUSH
98907: LD_EXP 170
98911: PUSH
98912: LD_EXP 171
98916: PUSH
98917: LD_EXP 172
98921: PUSH
98922: LD_EXP 173
98926: PUSH
98927: LD_EXP 138
98931: PUSH
98932: LD_EXP 139
98936: PUSH
98937: LD_EXP 142
98941: PUSH
98942: LD_EXP 143
98946: PUSH
98947: LD_EXP 144
98951: PUSH
98952: LD_EXP 140
98956: PUSH
98957: LD_EXP 141
98961: PUSH
98962: LD_EXP 149
98966: PUSH
98967: LD_EXP 153
98971: PUSH
98972: LD_EXP 154
98976: PUSH
98977: LD_EXP 156
98981: PUSH
98982: LD_EXP 160
98986: PUSH
98987: LD_EXP 163
98991: PUSH
98992: LD_EXP 164
98996: PUSH
98997: LD_EXP 174
99001: PUSH
99002: LD_EXP 175
99006: PUSH
99007: LD_EXP 176
99011: PUSH
99012: LD_EXP 177
99016: PUSH
99017: EMPTY
99018: LIST
99019: LIST
99020: LIST
99021: LIST
99022: LIST
99023: LIST
99024: LIST
99025: LIST
99026: LIST
99027: LIST
99028: LIST
99029: LIST
99030: LIST
99031: LIST
99032: LIST
99033: LIST
99034: LIST
99035: LIST
99036: LIST
99037: LIST
99038: LIST
99039: LIST
99040: LIST
99041: LIST
99042: LIST
99043: LIST
99044: LIST
99045: LIST
99046: LIST
99047: LIST
99048: LIST
99049: LIST
99050: LIST
99051: LIST
99052: LIST
99053: LIST
99054: LIST
99055: LIST
99056: LIST
99057: LIST
99058: LIST
99059: LIST
99060: LIST
99061: LIST
99062: LIST
99063: LIST
99064: LIST
99065: LIST
99066: LIST
99067: LIST
99068: LIST
99069: LIST
99070: LIST
99071: LIST
99072: ST_TO_ADDR
// tmp :=  ;
99073: LD_ADDR_VAR 0 3
99077: PUSH
99078: LD_STRING 
99080: ST_TO_ADDR
// for i = 1 to normalCounter do
99081: LD_ADDR_VAR 0 8
99085: PUSH
99086: DOUBLE
99087: LD_INT 1
99089: DEC
99090: ST_TO_ADDR
99091: LD_EXP 122
99095: PUSH
99096: FOR_TO
99097: IFFALSE 99133
// begin if flags [ i ] then
99099: LD_VAR 0 4
99103: PUSH
99104: LD_VAR 0 8
99108: ARRAY
99109: IFFALSE 99131
// tmp := tmp & i & ; ;
99111: LD_ADDR_VAR 0 3
99115: PUSH
99116: LD_VAR 0 3
99120: PUSH
99121: LD_VAR 0 8
99125: STR
99126: PUSH
99127: LD_STRING ;
99129: STR
99130: ST_TO_ADDR
// end ;
99131: GO 99096
99133: POP
99134: POP
// for i = 1 to hardcoreCounter do
99135: LD_ADDR_VAR 0 8
99139: PUSH
99140: DOUBLE
99141: LD_INT 1
99143: DEC
99144: ST_TO_ADDR
99145: LD_EXP 123
99149: PUSH
99150: FOR_TO
99151: IFFALSE 99197
// begin if flags [ normalCounter + i ] then
99153: LD_VAR 0 4
99157: PUSH
99158: LD_EXP 122
99162: PUSH
99163: LD_VAR 0 8
99167: PLUS
99168: ARRAY
99169: IFFALSE 99195
// tmp := tmp & ( 100 + i ) & ; ;
99171: LD_ADDR_VAR 0 3
99175: PUSH
99176: LD_VAR 0 3
99180: PUSH
99181: LD_INT 100
99183: PUSH
99184: LD_VAR 0 8
99188: PLUS
99189: STR
99190: PUSH
99191: LD_STRING ;
99193: STR
99194: ST_TO_ADDR
// end ;
99195: GO 99150
99197: POP
99198: POP
// if tmp then
99199: LD_VAR 0 3
99203: IFFALSE 99215
// active := tmp ;
99205: LD_ADDR_VAR 0 7
99209: PUSH
99210: LD_VAR 0 3
99214: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99215: LD_STRING getStreamItemsFromMission("
99217: PUSH
99218: LD_VAR 0 5
99222: STR
99223: PUSH
99224: LD_STRING ","
99226: STR
99227: PUSH
99228: LD_VAR 0 6
99232: STR
99233: PUSH
99234: LD_STRING ","
99236: STR
99237: PUSH
99238: LD_VAR 0 7
99242: STR
99243: PUSH
99244: LD_STRING ")
99246: STR
99247: PPUSH
99248: CALL_OW 559
// end else
99252: GO 99261
// ToLua ( getStreamItemsFromMission("","","") ) ;
99254: LD_STRING getStreamItemsFromMission("","","")
99256: PPUSH
99257: CALL_OW 559
// end ;
99261: LD_VAR 0 2
99265: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99266: LD_EXP 121
99270: PUSH
99271: LD_EXP 126
99275: AND
99276: IFFALSE 99400
99278: GO 99280
99280: DISABLE
99281: LD_INT 0
99283: PPUSH
99284: PPUSH
// begin enable ;
99285: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99286: LD_ADDR_VAR 0 2
99290: PUSH
99291: LD_INT 22
99293: PUSH
99294: LD_OWVAR 2
99298: PUSH
99299: EMPTY
99300: LIST
99301: LIST
99302: PUSH
99303: LD_INT 2
99305: PUSH
99306: LD_INT 34
99308: PUSH
99309: LD_INT 7
99311: PUSH
99312: EMPTY
99313: LIST
99314: LIST
99315: PUSH
99316: LD_INT 34
99318: PUSH
99319: LD_INT 45
99321: PUSH
99322: EMPTY
99323: LIST
99324: LIST
99325: PUSH
99326: LD_INT 34
99328: PUSH
99329: LD_INT 28
99331: PUSH
99332: EMPTY
99333: LIST
99334: LIST
99335: PUSH
99336: LD_INT 34
99338: PUSH
99339: LD_INT 47
99341: PUSH
99342: EMPTY
99343: LIST
99344: LIST
99345: PUSH
99346: EMPTY
99347: LIST
99348: LIST
99349: LIST
99350: LIST
99351: LIST
99352: PUSH
99353: EMPTY
99354: LIST
99355: LIST
99356: PPUSH
99357: CALL_OW 69
99361: ST_TO_ADDR
// if not tmp then
99362: LD_VAR 0 2
99366: NOT
99367: IFFALSE 99371
// exit ;
99369: GO 99400
// for i in tmp do
99371: LD_ADDR_VAR 0 1
99375: PUSH
99376: LD_VAR 0 2
99380: PUSH
99381: FOR_IN
99382: IFFALSE 99398
// begin SetLives ( i , 0 ) ;
99384: LD_VAR 0 1
99388: PPUSH
99389: LD_INT 0
99391: PPUSH
99392: CALL_OW 234
// end ;
99396: GO 99381
99398: POP
99399: POP
// end ;
99400: PPOPN 2
99402: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
99403: LD_EXP 121
99407: PUSH
99408: LD_EXP 127
99412: AND
99413: IFFALSE 99497
99415: GO 99417
99417: DISABLE
99418: LD_INT 0
99420: PPUSH
99421: PPUSH
// begin enable ;
99422: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
99423: LD_ADDR_VAR 0 2
99427: PUSH
99428: LD_INT 22
99430: PUSH
99431: LD_OWVAR 2
99435: PUSH
99436: EMPTY
99437: LIST
99438: LIST
99439: PUSH
99440: LD_INT 32
99442: PUSH
99443: LD_INT 3
99445: PUSH
99446: EMPTY
99447: LIST
99448: LIST
99449: PUSH
99450: EMPTY
99451: LIST
99452: LIST
99453: PPUSH
99454: CALL_OW 69
99458: ST_TO_ADDR
// if not tmp then
99459: LD_VAR 0 2
99463: NOT
99464: IFFALSE 99468
// exit ;
99466: GO 99497
// for i in tmp do
99468: LD_ADDR_VAR 0 1
99472: PUSH
99473: LD_VAR 0 2
99477: PUSH
99478: FOR_IN
99479: IFFALSE 99495
// begin SetLives ( i , 0 ) ;
99481: LD_VAR 0 1
99485: PPUSH
99486: LD_INT 0
99488: PPUSH
99489: CALL_OW 234
// end ;
99493: GO 99478
99495: POP
99496: POP
// end ;
99497: PPOPN 2
99499: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
99500: LD_EXP 121
99504: PUSH
99505: LD_EXP 124
99509: AND
99510: IFFALSE 99603
99512: GO 99514
99514: DISABLE
99515: LD_INT 0
99517: PPUSH
// begin enable ;
99518: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
99519: LD_ADDR_VAR 0 1
99523: PUSH
99524: LD_INT 22
99526: PUSH
99527: LD_OWVAR 2
99531: PUSH
99532: EMPTY
99533: LIST
99534: LIST
99535: PUSH
99536: LD_INT 2
99538: PUSH
99539: LD_INT 25
99541: PUSH
99542: LD_INT 5
99544: PUSH
99545: EMPTY
99546: LIST
99547: LIST
99548: PUSH
99549: LD_INT 25
99551: PUSH
99552: LD_INT 9
99554: PUSH
99555: EMPTY
99556: LIST
99557: LIST
99558: PUSH
99559: LD_INT 25
99561: PUSH
99562: LD_INT 8
99564: PUSH
99565: EMPTY
99566: LIST
99567: LIST
99568: PUSH
99569: EMPTY
99570: LIST
99571: LIST
99572: LIST
99573: LIST
99574: PUSH
99575: EMPTY
99576: LIST
99577: LIST
99578: PPUSH
99579: CALL_OW 69
99583: PUSH
99584: FOR_IN
99585: IFFALSE 99601
// begin SetClass ( i , 1 ) ;
99587: LD_VAR 0 1
99591: PPUSH
99592: LD_INT 1
99594: PPUSH
99595: CALL_OW 336
// end ;
99599: GO 99584
99601: POP
99602: POP
// end ;
99603: PPOPN 1
99605: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
99606: LD_EXP 121
99610: PUSH
99611: LD_EXP 125
99615: AND
99616: PUSH
99617: LD_OWVAR 65
99621: PUSH
99622: LD_INT 7
99624: LESS
99625: AND
99626: IFFALSE 99640
99628: GO 99630
99630: DISABLE
// begin enable ;
99631: ENABLE
// game_speed := 7 ;
99632: LD_ADDR_OWVAR 65
99636: PUSH
99637: LD_INT 7
99639: ST_TO_ADDR
// end ;
99640: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
99641: LD_EXP 121
99645: PUSH
99646: LD_EXP 128
99650: AND
99651: IFFALSE 99853
99653: GO 99655
99655: DISABLE
99656: LD_INT 0
99658: PPUSH
99659: PPUSH
99660: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99661: LD_ADDR_VAR 0 3
99665: PUSH
99666: LD_INT 81
99668: PUSH
99669: LD_OWVAR 2
99673: PUSH
99674: EMPTY
99675: LIST
99676: LIST
99677: PUSH
99678: LD_INT 21
99680: PUSH
99681: LD_INT 1
99683: PUSH
99684: EMPTY
99685: LIST
99686: LIST
99687: PUSH
99688: EMPTY
99689: LIST
99690: LIST
99691: PPUSH
99692: CALL_OW 69
99696: ST_TO_ADDR
// if not tmp then
99697: LD_VAR 0 3
99701: NOT
99702: IFFALSE 99706
// exit ;
99704: GO 99853
// if tmp > 5 then
99706: LD_VAR 0 3
99710: PUSH
99711: LD_INT 5
99713: GREATER
99714: IFFALSE 99726
// k := 5 else
99716: LD_ADDR_VAR 0 2
99720: PUSH
99721: LD_INT 5
99723: ST_TO_ADDR
99724: GO 99736
// k := tmp ;
99726: LD_ADDR_VAR 0 2
99730: PUSH
99731: LD_VAR 0 3
99735: ST_TO_ADDR
// for i := 1 to k do
99736: LD_ADDR_VAR 0 1
99740: PUSH
99741: DOUBLE
99742: LD_INT 1
99744: DEC
99745: ST_TO_ADDR
99746: LD_VAR 0 2
99750: PUSH
99751: FOR_TO
99752: IFFALSE 99851
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
99754: LD_VAR 0 3
99758: PUSH
99759: LD_VAR 0 1
99763: ARRAY
99764: PPUSH
99765: LD_VAR 0 1
99769: PUSH
99770: LD_INT 4
99772: MOD
99773: PUSH
99774: LD_INT 1
99776: PLUS
99777: PPUSH
99778: CALL_OW 259
99782: PUSH
99783: LD_INT 10
99785: LESS
99786: IFFALSE 99849
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
99788: LD_VAR 0 3
99792: PUSH
99793: LD_VAR 0 1
99797: ARRAY
99798: PPUSH
99799: LD_VAR 0 1
99803: PUSH
99804: LD_INT 4
99806: MOD
99807: PUSH
99808: LD_INT 1
99810: PLUS
99811: PPUSH
99812: LD_VAR 0 3
99816: PUSH
99817: LD_VAR 0 1
99821: ARRAY
99822: PPUSH
99823: LD_VAR 0 1
99827: PUSH
99828: LD_INT 4
99830: MOD
99831: PUSH
99832: LD_INT 1
99834: PLUS
99835: PPUSH
99836: CALL_OW 259
99840: PUSH
99841: LD_INT 1
99843: PLUS
99844: PPUSH
99845: CALL_OW 237
99849: GO 99751
99851: POP
99852: POP
// end ;
99853: PPOPN 3
99855: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99856: LD_EXP 121
99860: PUSH
99861: LD_EXP 129
99865: AND
99866: IFFALSE 99886
99868: GO 99870
99870: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
99871: LD_INT 4
99873: PPUSH
99874: LD_OWVAR 2
99878: PPUSH
99879: LD_INT 0
99881: PPUSH
99882: CALL_OW 324
99886: END
// every 0 0$1 trigger StreamModeActive and sShovel do
99887: LD_EXP 121
99891: PUSH
99892: LD_EXP 158
99896: AND
99897: IFFALSE 99917
99899: GO 99901
99901: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
99902: LD_INT 19
99904: PPUSH
99905: LD_OWVAR 2
99909: PPUSH
99910: LD_INT 0
99912: PPUSH
99913: CALL_OW 324
99917: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
99918: LD_EXP 121
99922: PUSH
99923: LD_EXP 130
99927: AND
99928: IFFALSE 100030
99930: GO 99932
99932: DISABLE
99933: LD_INT 0
99935: PPUSH
99936: PPUSH
// begin enable ;
99937: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
99938: LD_ADDR_VAR 0 2
99942: PUSH
99943: LD_INT 22
99945: PUSH
99946: LD_OWVAR 2
99950: PUSH
99951: EMPTY
99952: LIST
99953: LIST
99954: PUSH
99955: LD_INT 2
99957: PUSH
99958: LD_INT 34
99960: PUSH
99961: LD_INT 11
99963: PUSH
99964: EMPTY
99965: LIST
99966: LIST
99967: PUSH
99968: LD_INT 34
99970: PUSH
99971: LD_INT 30
99973: PUSH
99974: EMPTY
99975: LIST
99976: LIST
99977: PUSH
99978: EMPTY
99979: LIST
99980: LIST
99981: LIST
99982: PUSH
99983: EMPTY
99984: LIST
99985: LIST
99986: PPUSH
99987: CALL_OW 69
99991: ST_TO_ADDR
// if not tmp then
99992: LD_VAR 0 2
99996: NOT
99997: IFFALSE 100001
// exit ;
99999: GO 100030
// for i in tmp do
100001: LD_ADDR_VAR 0 1
100005: PUSH
100006: LD_VAR 0 2
100010: PUSH
100011: FOR_IN
100012: IFFALSE 100028
// begin SetLives ( i , 0 ) ;
100014: LD_VAR 0 1
100018: PPUSH
100019: LD_INT 0
100021: PPUSH
100022: CALL_OW 234
// end ;
100026: GO 100011
100028: POP
100029: POP
// end ;
100030: PPOPN 2
100032: END
// every 0 0$1 trigger StreamModeActive and sBunker do
100033: LD_EXP 121
100037: PUSH
100038: LD_EXP 131
100042: AND
100043: IFFALSE 100063
100045: GO 100047
100047: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
100048: LD_INT 32
100050: PPUSH
100051: LD_OWVAR 2
100055: PPUSH
100056: LD_INT 0
100058: PPUSH
100059: CALL_OW 324
100063: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
100064: LD_EXP 121
100068: PUSH
100069: LD_EXP 132
100073: AND
100074: IFFALSE 100255
100076: GO 100078
100078: DISABLE
100079: LD_INT 0
100081: PPUSH
100082: PPUSH
100083: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
100084: LD_ADDR_VAR 0 2
100088: PUSH
100089: LD_INT 22
100091: PUSH
100092: LD_OWVAR 2
100096: PUSH
100097: EMPTY
100098: LIST
100099: LIST
100100: PUSH
100101: LD_INT 33
100103: PUSH
100104: LD_INT 3
100106: PUSH
100107: EMPTY
100108: LIST
100109: LIST
100110: PUSH
100111: EMPTY
100112: LIST
100113: LIST
100114: PPUSH
100115: CALL_OW 69
100119: ST_TO_ADDR
// if not tmp then
100120: LD_VAR 0 2
100124: NOT
100125: IFFALSE 100129
// exit ;
100127: GO 100255
// side := 0 ;
100129: LD_ADDR_VAR 0 3
100133: PUSH
100134: LD_INT 0
100136: ST_TO_ADDR
// for i := 1 to 8 do
100137: LD_ADDR_VAR 0 1
100141: PUSH
100142: DOUBLE
100143: LD_INT 1
100145: DEC
100146: ST_TO_ADDR
100147: LD_INT 8
100149: PUSH
100150: FOR_TO
100151: IFFALSE 100199
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
100153: LD_OWVAR 2
100157: PUSH
100158: LD_VAR 0 1
100162: NONEQUAL
100163: PUSH
100164: LD_OWVAR 2
100168: PPUSH
100169: LD_VAR 0 1
100173: PPUSH
100174: CALL_OW 81
100178: PUSH
100179: LD_INT 2
100181: EQUAL
100182: AND
100183: IFFALSE 100197
// begin side := i ;
100185: LD_ADDR_VAR 0 3
100189: PUSH
100190: LD_VAR 0 1
100194: ST_TO_ADDR
// break ;
100195: GO 100199
// end ;
100197: GO 100150
100199: POP
100200: POP
// if not side then
100201: LD_VAR 0 3
100205: NOT
100206: IFFALSE 100210
// exit ;
100208: GO 100255
// for i := 1 to tmp do
100210: LD_ADDR_VAR 0 1
100214: PUSH
100215: DOUBLE
100216: LD_INT 1
100218: DEC
100219: ST_TO_ADDR
100220: LD_VAR 0 2
100224: PUSH
100225: FOR_TO
100226: IFFALSE 100253
// if Prob ( 60 ) then
100228: LD_INT 60
100230: PPUSH
100231: CALL_OW 13
100235: IFFALSE 100251
// SetSide ( i , side ) ;
100237: LD_VAR 0 1
100241: PPUSH
100242: LD_VAR 0 3
100246: PPUSH
100247: CALL_OW 235
100251: GO 100225
100253: POP
100254: POP
// end ;
100255: PPOPN 3
100257: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100258: LD_EXP 121
100262: PUSH
100263: LD_EXP 134
100267: AND
100268: IFFALSE 100387
100270: GO 100272
100272: DISABLE
100273: LD_INT 0
100275: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100276: LD_ADDR_VAR 0 1
100280: PUSH
100281: LD_INT 22
100283: PUSH
100284: LD_OWVAR 2
100288: PUSH
100289: EMPTY
100290: LIST
100291: LIST
100292: PUSH
100293: LD_INT 21
100295: PUSH
100296: LD_INT 1
100298: PUSH
100299: EMPTY
100300: LIST
100301: LIST
100302: PUSH
100303: LD_INT 3
100305: PUSH
100306: LD_INT 23
100308: PUSH
100309: LD_INT 0
100311: PUSH
100312: EMPTY
100313: LIST
100314: LIST
100315: PUSH
100316: EMPTY
100317: LIST
100318: LIST
100319: PUSH
100320: EMPTY
100321: LIST
100322: LIST
100323: LIST
100324: PPUSH
100325: CALL_OW 69
100329: PUSH
100330: FOR_IN
100331: IFFALSE 100385
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100333: LD_VAR 0 1
100337: PPUSH
100338: CALL_OW 257
100342: PUSH
100343: LD_INT 1
100345: PUSH
100346: LD_INT 2
100348: PUSH
100349: LD_INT 3
100351: PUSH
100352: LD_INT 4
100354: PUSH
100355: EMPTY
100356: LIST
100357: LIST
100358: LIST
100359: LIST
100360: IN
100361: IFFALSE 100383
// SetClass ( un , rand ( 1 , 4 ) ) ;
100363: LD_VAR 0 1
100367: PPUSH
100368: LD_INT 1
100370: PPUSH
100371: LD_INT 4
100373: PPUSH
100374: CALL_OW 12
100378: PPUSH
100379: CALL_OW 336
100383: GO 100330
100385: POP
100386: POP
// end ;
100387: PPOPN 1
100389: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100390: LD_EXP 121
100394: PUSH
100395: LD_EXP 133
100399: AND
100400: IFFALSE 100479
100402: GO 100404
100404: DISABLE
100405: LD_INT 0
100407: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100408: LD_ADDR_VAR 0 1
100412: PUSH
100413: LD_INT 22
100415: PUSH
100416: LD_OWVAR 2
100420: PUSH
100421: EMPTY
100422: LIST
100423: LIST
100424: PUSH
100425: LD_INT 21
100427: PUSH
100428: LD_INT 3
100430: PUSH
100431: EMPTY
100432: LIST
100433: LIST
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: PPUSH
100439: CALL_OW 69
100443: ST_TO_ADDR
// if not tmp then
100444: LD_VAR 0 1
100448: NOT
100449: IFFALSE 100453
// exit ;
100451: GO 100479
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
100453: LD_VAR 0 1
100457: PUSH
100458: LD_INT 1
100460: PPUSH
100461: LD_VAR 0 1
100465: PPUSH
100466: CALL_OW 12
100470: ARRAY
100471: PPUSH
100472: LD_INT 100
100474: PPUSH
100475: CALL_OW 234
// end ;
100479: PPOPN 1
100481: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
100482: LD_EXP 121
100486: PUSH
100487: LD_EXP 135
100491: AND
100492: IFFALSE 100590
100494: GO 100496
100496: DISABLE
100497: LD_INT 0
100499: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100500: LD_ADDR_VAR 0 1
100504: PUSH
100505: LD_INT 22
100507: PUSH
100508: LD_OWVAR 2
100512: PUSH
100513: EMPTY
100514: LIST
100515: LIST
100516: PUSH
100517: LD_INT 21
100519: PUSH
100520: LD_INT 1
100522: PUSH
100523: EMPTY
100524: LIST
100525: LIST
100526: PUSH
100527: EMPTY
100528: LIST
100529: LIST
100530: PPUSH
100531: CALL_OW 69
100535: ST_TO_ADDR
// if not tmp then
100536: LD_VAR 0 1
100540: NOT
100541: IFFALSE 100545
// exit ;
100543: GO 100590
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
100545: LD_VAR 0 1
100549: PUSH
100550: LD_INT 1
100552: PPUSH
100553: LD_VAR 0 1
100557: PPUSH
100558: CALL_OW 12
100562: ARRAY
100563: PPUSH
100564: LD_INT 1
100566: PPUSH
100567: LD_INT 4
100569: PPUSH
100570: CALL_OW 12
100574: PPUSH
100575: LD_INT 3000
100577: PPUSH
100578: LD_INT 9000
100580: PPUSH
100581: CALL_OW 12
100585: PPUSH
100586: CALL_OW 492
// end ;
100590: PPOPN 1
100592: END
// every 0 0$1 trigger StreamModeActive and sDepot do
100593: LD_EXP 121
100597: PUSH
100598: LD_EXP 136
100602: AND
100603: IFFALSE 100623
100605: GO 100607
100607: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
100608: LD_INT 1
100610: PPUSH
100611: LD_OWVAR 2
100615: PPUSH
100616: LD_INT 0
100618: PPUSH
100619: CALL_OW 324
100623: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
100624: LD_EXP 121
100628: PUSH
100629: LD_EXP 137
100633: AND
100634: IFFALSE 100717
100636: GO 100638
100638: DISABLE
100639: LD_INT 0
100641: PPUSH
100642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100643: LD_ADDR_VAR 0 2
100647: PUSH
100648: LD_INT 22
100650: PUSH
100651: LD_OWVAR 2
100655: PUSH
100656: EMPTY
100657: LIST
100658: LIST
100659: PUSH
100660: LD_INT 21
100662: PUSH
100663: LD_INT 3
100665: PUSH
100666: EMPTY
100667: LIST
100668: LIST
100669: PUSH
100670: EMPTY
100671: LIST
100672: LIST
100673: PPUSH
100674: CALL_OW 69
100678: ST_TO_ADDR
// if not tmp then
100679: LD_VAR 0 2
100683: NOT
100684: IFFALSE 100688
// exit ;
100686: GO 100717
// for i in tmp do
100688: LD_ADDR_VAR 0 1
100692: PUSH
100693: LD_VAR 0 2
100697: PUSH
100698: FOR_IN
100699: IFFALSE 100715
// SetBLevel ( i , 10 ) ;
100701: LD_VAR 0 1
100705: PPUSH
100706: LD_INT 10
100708: PPUSH
100709: CALL_OW 241
100713: GO 100698
100715: POP
100716: POP
// end ;
100717: PPOPN 2
100719: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
100720: LD_EXP 121
100724: PUSH
100725: LD_EXP 138
100729: AND
100730: IFFALSE 100841
100732: GO 100734
100734: DISABLE
100735: LD_INT 0
100737: PPUSH
100738: PPUSH
100739: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100740: LD_ADDR_VAR 0 3
100744: PUSH
100745: LD_INT 22
100747: PUSH
100748: LD_OWVAR 2
100752: PUSH
100753: EMPTY
100754: LIST
100755: LIST
100756: PUSH
100757: LD_INT 25
100759: PUSH
100760: LD_INT 1
100762: PUSH
100763: EMPTY
100764: LIST
100765: LIST
100766: PUSH
100767: EMPTY
100768: LIST
100769: LIST
100770: PPUSH
100771: CALL_OW 69
100775: ST_TO_ADDR
// if not tmp then
100776: LD_VAR 0 3
100780: NOT
100781: IFFALSE 100785
// exit ;
100783: GO 100841
// un := tmp [ rand ( 1 , tmp ) ] ;
100785: LD_ADDR_VAR 0 2
100789: PUSH
100790: LD_VAR 0 3
100794: PUSH
100795: LD_INT 1
100797: PPUSH
100798: LD_VAR 0 3
100802: PPUSH
100803: CALL_OW 12
100807: ARRAY
100808: ST_TO_ADDR
// if Crawls ( un ) then
100809: LD_VAR 0 2
100813: PPUSH
100814: CALL_OW 318
100818: IFFALSE 100829
// ComWalk ( un ) ;
100820: LD_VAR 0 2
100824: PPUSH
100825: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100829: LD_VAR 0 2
100833: PPUSH
100834: LD_INT 5
100836: PPUSH
100837: CALL_OW 336
// end ;
100841: PPOPN 3
100843: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
100844: LD_EXP 121
100848: PUSH
100849: LD_EXP 139
100853: AND
100854: PUSH
100855: LD_OWVAR 67
100859: PUSH
100860: LD_INT 4
100862: LESS
100863: AND
100864: IFFALSE 100883
100866: GO 100868
100868: DISABLE
// begin Difficulty := Difficulty + 1 ;
100869: LD_ADDR_OWVAR 67
100873: PUSH
100874: LD_OWVAR 67
100878: PUSH
100879: LD_INT 1
100881: PLUS
100882: ST_TO_ADDR
// end ;
100883: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
100884: LD_EXP 121
100888: PUSH
100889: LD_EXP 140
100893: AND
100894: IFFALSE 100997
100896: GO 100898
100898: DISABLE
100899: LD_INT 0
100901: PPUSH
// begin for i := 1 to 5 do
100902: LD_ADDR_VAR 0 1
100906: PUSH
100907: DOUBLE
100908: LD_INT 1
100910: DEC
100911: ST_TO_ADDR
100912: LD_INT 5
100914: PUSH
100915: FOR_TO
100916: IFFALSE 100995
// begin uc_nation := nation_nature ;
100918: LD_ADDR_OWVAR 21
100922: PUSH
100923: LD_INT 0
100925: ST_TO_ADDR
// uc_side := 0 ;
100926: LD_ADDR_OWVAR 20
100930: PUSH
100931: LD_INT 0
100933: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100934: LD_ADDR_OWVAR 29
100938: PUSH
100939: LD_INT 12
100941: PUSH
100942: LD_INT 12
100944: PUSH
100945: EMPTY
100946: LIST
100947: LIST
100948: ST_TO_ADDR
// hc_agressivity := 20 ;
100949: LD_ADDR_OWVAR 35
100953: PUSH
100954: LD_INT 20
100956: ST_TO_ADDR
// hc_class := class_tiger ;
100957: LD_ADDR_OWVAR 28
100961: PUSH
100962: LD_INT 14
100964: ST_TO_ADDR
// hc_gallery :=  ;
100965: LD_ADDR_OWVAR 33
100969: PUSH
100970: LD_STRING 
100972: ST_TO_ADDR
// hc_name :=  ;
100973: LD_ADDR_OWVAR 26
100977: PUSH
100978: LD_STRING 
100980: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
100981: CALL_OW 44
100985: PPUSH
100986: LD_INT 0
100988: PPUSH
100989: CALL_OW 51
// end ;
100993: GO 100915
100995: POP
100996: POP
// end ;
100997: PPOPN 1
100999: END
// every 0 0$1 trigger StreamModeActive and sBomb do
101000: LD_EXP 121
101004: PUSH
101005: LD_EXP 141
101009: AND
101010: IFFALSE 101019
101012: GO 101014
101014: DISABLE
// StreamSibBomb ;
101015: CALL 101020 0 0
101019: END
// export function StreamSibBomb ; var i , x , y ; begin
101020: LD_INT 0
101022: PPUSH
101023: PPUSH
101024: PPUSH
101025: PPUSH
// result := false ;
101026: LD_ADDR_VAR 0 1
101030: PUSH
101031: LD_INT 0
101033: ST_TO_ADDR
// for i := 1 to 16 do
101034: LD_ADDR_VAR 0 2
101038: PUSH
101039: DOUBLE
101040: LD_INT 1
101042: DEC
101043: ST_TO_ADDR
101044: LD_INT 16
101046: PUSH
101047: FOR_TO
101048: IFFALSE 101247
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101050: LD_ADDR_VAR 0 3
101054: PUSH
101055: LD_INT 10
101057: PUSH
101058: LD_INT 20
101060: PUSH
101061: LD_INT 30
101063: PUSH
101064: LD_INT 40
101066: PUSH
101067: LD_INT 50
101069: PUSH
101070: LD_INT 60
101072: PUSH
101073: LD_INT 70
101075: PUSH
101076: LD_INT 80
101078: PUSH
101079: LD_INT 90
101081: PUSH
101082: LD_INT 100
101084: PUSH
101085: LD_INT 110
101087: PUSH
101088: LD_INT 120
101090: PUSH
101091: LD_INT 130
101093: PUSH
101094: LD_INT 140
101096: PUSH
101097: LD_INT 150
101099: PUSH
101100: EMPTY
101101: LIST
101102: LIST
101103: LIST
101104: LIST
101105: LIST
101106: LIST
101107: LIST
101108: LIST
101109: LIST
101110: LIST
101111: LIST
101112: LIST
101113: LIST
101114: LIST
101115: LIST
101116: PUSH
101117: LD_INT 1
101119: PPUSH
101120: LD_INT 15
101122: PPUSH
101123: CALL_OW 12
101127: ARRAY
101128: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101129: LD_ADDR_VAR 0 4
101133: PUSH
101134: LD_INT 10
101136: PUSH
101137: LD_INT 20
101139: PUSH
101140: LD_INT 30
101142: PUSH
101143: LD_INT 40
101145: PUSH
101146: LD_INT 50
101148: PUSH
101149: LD_INT 60
101151: PUSH
101152: LD_INT 70
101154: PUSH
101155: LD_INT 80
101157: PUSH
101158: LD_INT 90
101160: PUSH
101161: LD_INT 100
101163: PUSH
101164: LD_INT 110
101166: PUSH
101167: LD_INT 120
101169: PUSH
101170: LD_INT 130
101172: PUSH
101173: LD_INT 140
101175: PUSH
101176: LD_INT 150
101178: PUSH
101179: EMPTY
101180: LIST
101181: LIST
101182: LIST
101183: LIST
101184: LIST
101185: LIST
101186: LIST
101187: LIST
101188: LIST
101189: LIST
101190: LIST
101191: LIST
101192: LIST
101193: LIST
101194: LIST
101195: PUSH
101196: LD_INT 1
101198: PPUSH
101199: LD_INT 15
101201: PPUSH
101202: CALL_OW 12
101206: ARRAY
101207: ST_TO_ADDR
// if ValidHex ( x , y ) then
101208: LD_VAR 0 3
101212: PPUSH
101213: LD_VAR 0 4
101217: PPUSH
101218: CALL_OW 488
101222: IFFALSE 101245
// begin result := [ x , y ] ;
101224: LD_ADDR_VAR 0 1
101228: PUSH
101229: LD_VAR 0 3
101233: PUSH
101234: LD_VAR 0 4
101238: PUSH
101239: EMPTY
101240: LIST
101241: LIST
101242: ST_TO_ADDR
// break ;
101243: GO 101247
// end ; end ;
101245: GO 101047
101247: POP
101248: POP
// if result then
101249: LD_VAR 0 1
101253: IFFALSE 101313
// begin ToLua ( playSibBomb() ) ;
101255: LD_STRING playSibBomb()
101257: PPUSH
101258: CALL_OW 559
// wait ( 0 0$14 ) ;
101262: LD_INT 490
101264: PPUSH
101265: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101269: LD_VAR 0 1
101273: PUSH
101274: LD_INT 1
101276: ARRAY
101277: PPUSH
101278: LD_VAR 0 1
101282: PUSH
101283: LD_INT 2
101285: ARRAY
101286: PPUSH
101287: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101291: LD_VAR 0 1
101295: PUSH
101296: LD_INT 1
101298: ARRAY
101299: PPUSH
101300: LD_VAR 0 1
101304: PUSH
101305: LD_INT 2
101307: ARRAY
101308: PPUSH
101309: CALL_OW 429
// end ; end ;
101313: LD_VAR 0 1
101317: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101318: LD_EXP 121
101322: PUSH
101323: LD_EXP 143
101327: AND
101328: IFFALSE 101340
101330: GO 101332
101332: DISABLE
// YouLost (  ) ;
101333: LD_STRING 
101335: PPUSH
101336: CALL_OW 104
101340: END
// every 0 0$1 trigger StreamModeActive and sFog do
101341: LD_EXP 121
101345: PUSH
101346: LD_EXP 142
101350: AND
101351: IFFALSE 101365
101353: GO 101355
101355: DISABLE
// FogOff ( your_side ) ;
101356: LD_OWVAR 2
101360: PPUSH
101361: CALL_OW 344
101365: END
// every 0 0$1 trigger StreamModeActive and sSun do
101366: LD_EXP 121
101370: PUSH
101371: LD_EXP 144
101375: AND
101376: IFFALSE 101404
101378: GO 101380
101380: DISABLE
// begin solar_recharge_percent := 0 ;
101381: LD_ADDR_OWVAR 79
101385: PUSH
101386: LD_INT 0
101388: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101389: LD_INT 10500
101391: PPUSH
101392: CALL_OW 67
// solar_recharge_percent := 100 ;
101396: LD_ADDR_OWVAR 79
101400: PUSH
101401: LD_INT 100
101403: ST_TO_ADDR
// end ;
101404: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
101405: LD_EXP 121
101409: PUSH
101410: LD_EXP 145
101414: AND
101415: IFFALSE 101654
101417: GO 101419
101419: DISABLE
101420: LD_INT 0
101422: PPUSH
101423: PPUSH
101424: PPUSH
// begin tmp := [ ] ;
101425: LD_ADDR_VAR 0 3
101429: PUSH
101430: EMPTY
101431: ST_TO_ADDR
// for i := 1 to 6 do
101432: LD_ADDR_VAR 0 1
101436: PUSH
101437: DOUBLE
101438: LD_INT 1
101440: DEC
101441: ST_TO_ADDR
101442: LD_INT 6
101444: PUSH
101445: FOR_TO
101446: IFFALSE 101551
// begin uc_nation := nation_nature ;
101448: LD_ADDR_OWVAR 21
101452: PUSH
101453: LD_INT 0
101455: ST_TO_ADDR
// uc_side := 0 ;
101456: LD_ADDR_OWVAR 20
101460: PUSH
101461: LD_INT 0
101463: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101464: LD_ADDR_OWVAR 29
101468: PUSH
101469: LD_INT 12
101471: PUSH
101472: LD_INT 12
101474: PUSH
101475: EMPTY
101476: LIST
101477: LIST
101478: ST_TO_ADDR
// hc_agressivity := 20 ;
101479: LD_ADDR_OWVAR 35
101483: PUSH
101484: LD_INT 20
101486: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
101487: LD_ADDR_OWVAR 28
101491: PUSH
101492: LD_INT 17
101494: ST_TO_ADDR
// hc_gallery :=  ;
101495: LD_ADDR_OWVAR 33
101499: PUSH
101500: LD_STRING 
101502: ST_TO_ADDR
// hc_name :=  ;
101503: LD_ADDR_OWVAR 26
101507: PUSH
101508: LD_STRING 
101510: ST_TO_ADDR
// un := CreateHuman ;
101511: LD_ADDR_VAR 0 2
101515: PUSH
101516: CALL_OW 44
101520: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
101521: LD_VAR 0 2
101525: PPUSH
101526: LD_INT 1
101528: PPUSH
101529: CALL_OW 51
// tmp := tmp ^ un ;
101533: LD_ADDR_VAR 0 3
101537: PUSH
101538: LD_VAR 0 3
101542: PUSH
101543: LD_VAR 0 2
101547: ADD
101548: ST_TO_ADDR
// end ;
101549: GO 101445
101551: POP
101552: POP
// repeat wait ( 0 0$1 ) ;
101553: LD_INT 35
101555: PPUSH
101556: CALL_OW 67
// for un in tmp do
101560: LD_ADDR_VAR 0 2
101564: PUSH
101565: LD_VAR 0 3
101569: PUSH
101570: FOR_IN
101571: IFFALSE 101645
// begin if IsDead ( un ) then
101573: LD_VAR 0 2
101577: PPUSH
101578: CALL_OW 301
101582: IFFALSE 101602
// begin tmp := tmp diff un ;
101584: LD_ADDR_VAR 0 3
101588: PUSH
101589: LD_VAR 0 3
101593: PUSH
101594: LD_VAR 0 2
101598: DIFF
101599: ST_TO_ADDR
// continue ;
101600: GO 101570
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
101602: LD_VAR 0 2
101606: PPUSH
101607: LD_INT 3
101609: PUSH
101610: LD_INT 22
101612: PUSH
101613: LD_INT 0
101615: PUSH
101616: EMPTY
101617: LIST
101618: LIST
101619: PUSH
101620: EMPTY
101621: LIST
101622: LIST
101623: PPUSH
101624: CALL_OW 69
101628: PPUSH
101629: LD_VAR 0 2
101633: PPUSH
101634: CALL_OW 74
101638: PPUSH
101639: CALL_OW 115
// end ;
101643: GO 101570
101645: POP
101646: POP
// until not tmp ;
101647: LD_VAR 0 3
101651: NOT
101652: IFFALSE 101553
// end ;
101654: PPOPN 3
101656: END
// every 0 0$1 trigger StreamModeActive and sTroll do
101657: LD_EXP 121
101661: PUSH
101662: LD_EXP 146
101666: AND
101667: IFFALSE 101721
101669: GO 101671
101671: DISABLE
// begin ToLua ( displayTroll(); ) ;
101672: LD_STRING displayTroll();
101674: PPUSH
101675: CALL_OW 559
// wait ( 3 3$00 ) ;
101679: LD_INT 6300
101681: PPUSH
101682: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101686: LD_STRING hideTroll();
101688: PPUSH
101689: CALL_OW 559
// wait ( 1 1$00 ) ;
101693: LD_INT 2100
101695: PPUSH
101696: CALL_OW 67
// ToLua ( displayTroll(); ) ;
101700: LD_STRING displayTroll();
101702: PPUSH
101703: CALL_OW 559
// wait ( 1 1$00 ) ;
101707: LD_INT 2100
101709: PPUSH
101710: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101714: LD_STRING hideTroll();
101716: PPUSH
101717: CALL_OW 559
// end ;
101721: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
101722: LD_EXP 121
101726: PUSH
101727: LD_EXP 147
101731: AND
101732: IFFALSE 101795
101734: GO 101736
101736: DISABLE
101737: LD_INT 0
101739: PPUSH
// begin p := 0 ;
101740: LD_ADDR_VAR 0 1
101744: PUSH
101745: LD_INT 0
101747: ST_TO_ADDR
// repeat game_speed := 1 ;
101748: LD_ADDR_OWVAR 65
101752: PUSH
101753: LD_INT 1
101755: ST_TO_ADDR
// wait ( 0 0$1 ) ;
101756: LD_INT 35
101758: PPUSH
101759: CALL_OW 67
// p := p + 1 ;
101763: LD_ADDR_VAR 0 1
101767: PUSH
101768: LD_VAR 0 1
101772: PUSH
101773: LD_INT 1
101775: PLUS
101776: ST_TO_ADDR
// until p >= 60 ;
101777: LD_VAR 0 1
101781: PUSH
101782: LD_INT 60
101784: GREATEREQUAL
101785: IFFALSE 101748
// game_speed := 4 ;
101787: LD_ADDR_OWVAR 65
101791: PUSH
101792: LD_INT 4
101794: ST_TO_ADDR
// end ;
101795: PPOPN 1
101797: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
101798: LD_EXP 121
101802: PUSH
101803: LD_EXP 148
101807: AND
101808: IFFALSE 101954
101810: GO 101812
101812: DISABLE
101813: LD_INT 0
101815: PPUSH
101816: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101817: LD_ADDR_VAR 0 1
101821: PUSH
101822: LD_INT 22
101824: PUSH
101825: LD_OWVAR 2
101829: PUSH
101830: EMPTY
101831: LIST
101832: LIST
101833: PUSH
101834: LD_INT 2
101836: PUSH
101837: LD_INT 30
101839: PUSH
101840: LD_INT 0
101842: PUSH
101843: EMPTY
101844: LIST
101845: LIST
101846: PUSH
101847: LD_INT 30
101849: PUSH
101850: LD_INT 1
101852: PUSH
101853: EMPTY
101854: LIST
101855: LIST
101856: PUSH
101857: EMPTY
101858: LIST
101859: LIST
101860: LIST
101861: PUSH
101862: EMPTY
101863: LIST
101864: LIST
101865: PPUSH
101866: CALL_OW 69
101870: ST_TO_ADDR
// if not depot then
101871: LD_VAR 0 1
101875: NOT
101876: IFFALSE 101880
// exit ;
101878: GO 101954
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
101880: LD_ADDR_VAR 0 2
101884: PUSH
101885: LD_VAR 0 1
101889: PUSH
101890: LD_INT 1
101892: PPUSH
101893: LD_VAR 0 1
101897: PPUSH
101898: CALL_OW 12
101902: ARRAY
101903: PPUSH
101904: CALL_OW 274
101908: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
101909: LD_VAR 0 2
101913: PPUSH
101914: LD_INT 1
101916: PPUSH
101917: LD_INT 0
101919: PPUSH
101920: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
101924: LD_VAR 0 2
101928: PPUSH
101929: LD_INT 2
101931: PPUSH
101932: LD_INT 0
101934: PPUSH
101935: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
101939: LD_VAR 0 2
101943: PPUSH
101944: LD_INT 3
101946: PPUSH
101947: LD_INT 0
101949: PPUSH
101950: CALL_OW 277
// end ;
101954: PPOPN 2
101956: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
101957: LD_EXP 121
101961: PUSH
101962: LD_EXP 149
101966: AND
101967: IFFALSE 102064
101969: GO 101971
101971: DISABLE
101972: LD_INT 0
101974: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101975: LD_ADDR_VAR 0 1
101979: PUSH
101980: LD_INT 22
101982: PUSH
101983: LD_OWVAR 2
101987: PUSH
101988: EMPTY
101989: LIST
101990: LIST
101991: PUSH
101992: LD_INT 21
101994: PUSH
101995: LD_INT 1
101997: PUSH
101998: EMPTY
101999: LIST
102000: LIST
102001: PUSH
102002: LD_INT 3
102004: PUSH
102005: LD_INT 23
102007: PUSH
102008: LD_INT 0
102010: PUSH
102011: EMPTY
102012: LIST
102013: LIST
102014: PUSH
102015: EMPTY
102016: LIST
102017: LIST
102018: PUSH
102019: EMPTY
102020: LIST
102021: LIST
102022: LIST
102023: PPUSH
102024: CALL_OW 69
102028: ST_TO_ADDR
// if not tmp then
102029: LD_VAR 0 1
102033: NOT
102034: IFFALSE 102038
// exit ;
102036: GO 102064
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
102038: LD_VAR 0 1
102042: PUSH
102043: LD_INT 1
102045: PPUSH
102046: LD_VAR 0 1
102050: PPUSH
102051: CALL_OW 12
102055: ARRAY
102056: PPUSH
102057: LD_INT 200
102059: PPUSH
102060: CALL_OW 234
// end ;
102064: PPOPN 1
102066: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
102067: LD_EXP 121
102071: PUSH
102072: LD_EXP 150
102076: AND
102077: IFFALSE 102156
102079: GO 102081
102081: DISABLE
102082: LD_INT 0
102084: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
102085: LD_ADDR_VAR 0 1
102089: PUSH
102090: LD_INT 22
102092: PUSH
102093: LD_OWVAR 2
102097: PUSH
102098: EMPTY
102099: LIST
102100: LIST
102101: PUSH
102102: LD_INT 21
102104: PUSH
102105: LD_INT 2
102107: PUSH
102108: EMPTY
102109: LIST
102110: LIST
102111: PUSH
102112: EMPTY
102113: LIST
102114: LIST
102115: PPUSH
102116: CALL_OW 69
102120: ST_TO_ADDR
// if not tmp then
102121: LD_VAR 0 1
102125: NOT
102126: IFFALSE 102130
// exit ;
102128: GO 102156
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
102130: LD_VAR 0 1
102134: PUSH
102135: LD_INT 1
102137: PPUSH
102138: LD_VAR 0 1
102142: PPUSH
102143: CALL_OW 12
102147: ARRAY
102148: PPUSH
102149: LD_INT 60
102151: PPUSH
102152: CALL_OW 234
// end ;
102156: PPOPN 1
102158: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
102159: LD_EXP 121
102163: PUSH
102164: LD_EXP 151
102168: AND
102169: IFFALSE 102268
102171: GO 102173
102173: DISABLE
102174: LD_INT 0
102176: PPUSH
102177: PPUSH
// begin enable ;
102178: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
102179: LD_ADDR_VAR 0 1
102183: PUSH
102184: LD_INT 22
102186: PUSH
102187: LD_OWVAR 2
102191: PUSH
102192: EMPTY
102193: LIST
102194: LIST
102195: PUSH
102196: LD_INT 61
102198: PUSH
102199: EMPTY
102200: LIST
102201: PUSH
102202: LD_INT 33
102204: PUSH
102205: LD_INT 2
102207: PUSH
102208: EMPTY
102209: LIST
102210: LIST
102211: PUSH
102212: EMPTY
102213: LIST
102214: LIST
102215: LIST
102216: PPUSH
102217: CALL_OW 69
102221: ST_TO_ADDR
// if not tmp then
102222: LD_VAR 0 1
102226: NOT
102227: IFFALSE 102231
// exit ;
102229: GO 102268
// for i in tmp do
102231: LD_ADDR_VAR 0 2
102235: PUSH
102236: LD_VAR 0 1
102240: PUSH
102241: FOR_IN
102242: IFFALSE 102266
// if IsControledBy ( i ) then
102244: LD_VAR 0 2
102248: PPUSH
102249: CALL_OW 312
102253: IFFALSE 102264
// ComUnlink ( i ) ;
102255: LD_VAR 0 2
102259: PPUSH
102260: CALL_OW 136
102264: GO 102241
102266: POP
102267: POP
// end ;
102268: PPOPN 2
102270: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102271: LD_EXP 121
102275: PUSH
102276: LD_EXP 152
102280: AND
102281: IFFALSE 102421
102283: GO 102285
102285: DISABLE
102286: LD_INT 0
102288: PPUSH
102289: PPUSH
// begin ToLua ( displayPowell(); ) ;
102290: LD_STRING displayPowell();
102292: PPUSH
102293: CALL_OW 559
// uc_side := 0 ;
102297: LD_ADDR_OWVAR 20
102301: PUSH
102302: LD_INT 0
102304: ST_TO_ADDR
// uc_nation := 2 ;
102305: LD_ADDR_OWVAR 21
102309: PUSH
102310: LD_INT 2
102312: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102313: LD_ADDR_OWVAR 37
102317: PUSH
102318: LD_INT 14
102320: ST_TO_ADDR
// vc_engine := engine_siberite ;
102321: LD_ADDR_OWVAR 39
102325: PUSH
102326: LD_INT 3
102328: ST_TO_ADDR
// vc_control := control_apeman ;
102329: LD_ADDR_OWVAR 38
102333: PUSH
102334: LD_INT 5
102336: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102337: LD_ADDR_OWVAR 40
102341: PUSH
102342: LD_INT 29
102344: ST_TO_ADDR
// un := CreateVehicle ;
102345: LD_ADDR_VAR 0 2
102349: PUSH
102350: CALL_OW 45
102354: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102355: LD_VAR 0 2
102359: PPUSH
102360: LD_INT 1
102362: PPUSH
102363: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102367: LD_INT 35
102369: PPUSH
102370: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102374: LD_VAR 0 2
102378: PPUSH
102379: LD_INT 22
102381: PUSH
102382: LD_OWVAR 2
102386: PUSH
102387: EMPTY
102388: LIST
102389: LIST
102390: PPUSH
102391: CALL_OW 69
102395: PPUSH
102396: LD_VAR 0 2
102400: PPUSH
102401: CALL_OW 74
102405: PPUSH
102406: CALL_OW 115
// until IsDead ( un ) ;
102410: LD_VAR 0 2
102414: PPUSH
102415: CALL_OW 301
102419: IFFALSE 102367
// end ;
102421: PPOPN 2
102423: END
// every 0 0$1 trigger StreamModeActive and sStu do
102424: LD_EXP 121
102428: PUSH
102429: LD_EXP 160
102433: AND
102434: IFFALSE 102450
102436: GO 102438
102438: DISABLE
// begin ToLua ( displayStucuk(); ) ;
102439: LD_STRING displayStucuk();
102441: PPUSH
102442: CALL_OW 559
// ResetFog ;
102446: CALL_OW 335
// end ;
102450: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
102451: LD_EXP 121
102455: PUSH
102456: LD_EXP 153
102460: AND
102461: IFFALSE 102602
102463: GO 102465
102465: DISABLE
102466: LD_INT 0
102468: PPUSH
102469: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102470: LD_ADDR_VAR 0 2
102474: PUSH
102475: LD_INT 22
102477: PUSH
102478: LD_OWVAR 2
102482: PUSH
102483: EMPTY
102484: LIST
102485: LIST
102486: PUSH
102487: LD_INT 21
102489: PUSH
102490: LD_INT 1
102492: PUSH
102493: EMPTY
102494: LIST
102495: LIST
102496: PUSH
102497: EMPTY
102498: LIST
102499: LIST
102500: PPUSH
102501: CALL_OW 69
102505: ST_TO_ADDR
// if not tmp then
102506: LD_VAR 0 2
102510: NOT
102511: IFFALSE 102515
// exit ;
102513: GO 102602
// un := tmp [ rand ( 1 , tmp ) ] ;
102515: LD_ADDR_VAR 0 1
102519: PUSH
102520: LD_VAR 0 2
102524: PUSH
102525: LD_INT 1
102527: PPUSH
102528: LD_VAR 0 2
102532: PPUSH
102533: CALL_OW 12
102537: ARRAY
102538: ST_TO_ADDR
// SetSide ( un , 0 ) ;
102539: LD_VAR 0 1
102543: PPUSH
102544: LD_INT 0
102546: PPUSH
102547: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
102551: LD_VAR 0 1
102555: PPUSH
102556: LD_OWVAR 3
102560: PUSH
102561: LD_VAR 0 1
102565: DIFF
102566: PPUSH
102567: LD_VAR 0 1
102571: PPUSH
102572: CALL_OW 74
102576: PPUSH
102577: CALL_OW 115
// wait ( 0 0$20 ) ;
102581: LD_INT 700
102583: PPUSH
102584: CALL_OW 67
// SetSide ( un , your_side ) ;
102588: LD_VAR 0 1
102592: PPUSH
102593: LD_OWVAR 2
102597: PPUSH
102598: CALL_OW 235
// end ;
102602: PPOPN 2
102604: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
102605: LD_EXP 121
102609: PUSH
102610: LD_EXP 154
102614: AND
102615: IFFALSE 102721
102617: GO 102619
102619: DISABLE
102620: LD_INT 0
102622: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102623: LD_ADDR_VAR 0 1
102627: PUSH
102628: LD_INT 22
102630: PUSH
102631: LD_OWVAR 2
102635: PUSH
102636: EMPTY
102637: LIST
102638: LIST
102639: PUSH
102640: LD_INT 2
102642: PUSH
102643: LD_INT 30
102645: PUSH
102646: LD_INT 0
102648: PUSH
102649: EMPTY
102650: LIST
102651: LIST
102652: PUSH
102653: LD_INT 30
102655: PUSH
102656: LD_INT 1
102658: PUSH
102659: EMPTY
102660: LIST
102661: LIST
102662: PUSH
102663: EMPTY
102664: LIST
102665: LIST
102666: LIST
102667: PUSH
102668: EMPTY
102669: LIST
102670: LIST
102671: PPUSH
102672: CALL_OW 69
102676: ST_TO_ADDR
// if not depot then
102677: LD_VAR 0 1
102681: NOT
102682: IFFALSE 102686
// exit ;
102684: GO 102721
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
102686: LD_VAR 0 1
102690: PUSH
102691: LD_INT 1
102693: ARRAY
102694: PPUSH
102695: CALL_OW 250
102699: PPUSH
102700: LD_VAR 0 1
102704: PUSH
102705: LD_INT 1
102707: ARRAY
102708: PPUSH
102709: CALL_OW 251
102713: PPUSH
102714: LD_INT 70
102716: PPUSH
102717: CALL_OW 495
// end ;
102721: PPOPN 1
102723: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
102724: LD_EXP 121
102728: PUSH
102729: LD_EXP 155
102733: AND
102734: IFFALSE 102945
102736: GO 102738
102738: DISABLE
102739: LD_INT 0
102741: PPUSH
102742: PPUSH
102743: PPUSH
102744: PPUSH
102745: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102746: LD_ADDR_VAR 0 5
102750: PUSH
102751: LD_INT 22
102753: PUSH
102754: LD_OWVAR 2
102758: PUSH
102759: EMPTY
102760: LIST
102761: LIST
102762: PUSH
102763: LD_INT 21
102765: PUSH
102766: LD_INT 1
102768: PUSH
102769: EMPTY
102770: LIST
102771: LIST
102772: PUSH
102773: EMPTY
102774: LIST
102775: LIST
102776: PPUSH
102777: CALL_OW 69
102781: ST_TO_ADDR
// if not tmp then
102782: LD_VAR 0 5
102786: NOT
102787: IFFALSE 102791
// exit ;
102789: GO 102945
// for i in tmp do
102791: LD_ADDR_VAR 0 1
102795: PUSH
102796: LD_VAR 0 5
102800: PUSH
102801: FOR_IN
102802: IFFALSE 102943
// begin d := rand ( 0 , 5 ) ;
102804: LD_ADDR_VAR 0 4
102808: PUSH
102809: LD_INT 0
102811: PPUSH
102812: LD_INT 5
102814: PPUSH
102815: CALL_OW 12
102819: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
102820: LD_ADDR_VAR 0 2
102824: PUSH
102825: LD_VAR 0 1
102829: PPUSH
102830: CALL_OW 250
102834: PPUSH
102835: LD_VAR 0 4
102839: PPUSH
102840: LD_INT 3
102842: PPUSH
102843: LD_INT 12
102845: PPUSH
102846: CALL_OW 12
102850: PPUSH
102851: CALL_OW 272
102855: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
102856: LD_ADDR_VAR 0 3
102860: PUSH
102861: LD_VAR 0 1
102865: PPUSH
102866: CALL_OW 251
102870: PPUSH
102871: LD_VAR 0 4
102875: PPUSH
102876: LD_INT 3
102878: PPUSH
102879: LD_INT 12
102881: PPUSH
102882: CALL_OW 12
102886: PPUSH
102887: CALL_OW 273
102891: ST_TO_ADDR
// if ValidHex ( x , y ) then
102892: LD_VAR 0 2
102896: PPUSH
102897: LD_VAR 0 3
102901: PPUSH
102902: CALL_OW 488
102906: IFFALSE 102941
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
102908: LD_VAR 0 1
102912: PPUSH
102913: LD_VAR 0 2
102917: PPUSH
102918: LD_VAR 0 3
102922: PPUSH
102923: LD_INT 3
102925: PPUSH
102926: LD_INT 6
102928: PPUSH
102929: CALL_OW 12
102933: PPUSH
102934: LD_INT 1
102936: PPUSH
102937: CALL_OW 483
// end ;
102941: GO 102801
102943: POP
102944: POP
// end ;
102945: PPOPN 5
102947: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
102948: LD_EXP 121
102952: PUSH
102953: LD_EXP 156
102957: AND
102958: IFFALSE 103052
102960: GO 102962
102962: DISABLE
102963: LD_INT 0
102965: PPUSH
102966: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
102967: LD_ADDR_VAR 0 2
102971: PUSH
102972: LD_INT 22
102974: PUSH
102975: LD_OWVAR 2
102979: PUSH
102980: EMPTY
102981: LIST
102982: LIST
102983: PUSH
102984: LD_INT 32
102986: PUSH
102987: LD_INT 1
102989: PUSH
102990: EMPTY
102991: LIST
102992: LIST
102993: PUSH
102994: LD_INT 21
102996: PUSH
102997: LD_INT 2
102999: PUSH
103000: EMPTY
103001: LIST
103002: LIST
103003: PUSH
103004: EMPTY
103005: LIST
103006: LIST
103007: LIST
103008: PPUSH
103009: CALL_OW 69
103013: ST_TO_ADDR
// if not tmp then
103014: LD_VAR 0 2
103018: NOT
103019: IFFALSE 103023
// exit ;
103021: GO 103052
// for i in tmp do
103023: LD_ADDR_VAR 0 1
103027: PUSH
103028: LD_VAR 0 2
103032: PUSH
103033: FOR_IN
103034: IFFALSE 103050
// SetFuel ( i , 0 ) ;
103036: LD_VAR 0 1
103040: PPUSH
103041: LD_INT 0
103043: PPUSH
103044: CALL_OW 240
103048: GO 103033
103050: POP
103051: POP
// end ;
103052: PPOPN 2
103054: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
103055: LD_EXP 121
103059: PUSH
103060: LD_EXP 157
103064: AND
103065: IFFALSE 103131
103067: GO 103069
103069: DISABLE
103070: LD_INT 0
103072: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103073: LD_ADDR_VAR 0 1
103077: PUSH
103078: LD_INT 22
103080: PUSH
103081: LD_OWVAR 2
103085: PUSH
103086: EMPTY
103087: LIST
103088: LIST
103089: PUSH
103090: LD_INT 30
103092: PUSH
103093: LD_INT 29
103095: PUSH
103096: EMPTY
103097: LIST
103098: LIST
103099: PUSH
103100: EMPTY
103101: LIST
103102: LIST
103103: PPUSH
103104: CALL_OW 69
103108: ST_TO_ADDR
// if not tmp then
103109: LD_VAR 0 1
103113: NOT
103114: IFFALSE 103118
// exit ;
103116: GO 103131
// DestroyUnit ( tmp [ 1 ] ) ;
103118: LD_VAR 0 1
103122: PUSH
103123: LD_INT 1
103125: ARRAY
103126: PPUSH
103127: CALL_OW 65
// end ;
103131: PPOPN 1
103133: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
103134: LD_EXP 121
103138: PUSH
103139: LD_EXP 159
103143: AND
103144: IFFALSE 103273
103146: GO 103148
103148: DISABLE
103149: LD_INT 0
103151: PPUSH
// begin uc_side := 0 ;
103152: LD_ADDR_OWVAR 20
103156: PUSH
103157: LD_INT 0
103159: ST_TO_ADDR
// uc_nation := nation_arabian ;
103160: LD_ADDR_OWVAR 21
103164: PUSH
103165: LD_INT 2
103167: ST_TO_ADDR
// hc_gallery :=  ;
103168: LD_ADDR_OWVAR 33
103172: PUSH
103173: LD_STRING 
103175: ST_TO_ADDR
// hc_name :=  ;
103176: LD_ADDR_OWVAR 26
103180: PUSH
103181: LD_STRING 
103183: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
103184: LD_INT 1
103186: PPUSH
103187: LD_INT 11
103189: PPUSH
103190: LD_INT 10
103192: PPUSH
103193: CALL_OW 380
// un := CreateHuman ;
103197: LD_ADDR_VAR 0 1
103201: PUSH
103202: CALL_OW 44
103206: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103207: LD_VAR 0 1
103211: PPUSH
103212: LD_INT 1
103214: PPUSH
103215: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103219: LD_INT 35
103221: PPUSH
103222: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103226: LD_VAR 0 1
103230: PPUSH
103231: LD_INT 22
103233: PUSH
103234: LD_OWVAR 2
103238: PUSH
103239: EMPTY
103240: LIST
103241: LIST
103242: PPUSH
103243: CALL_OW 69
103247: PPUSH
103248: LD_VAR 0 1
103252: PPUSH
103253: CALL_OW 74
103257: PPUSH
103258: CALL_OW 115
// until IsDead ( un ) ;
103262: LD_VAR 0 1
103266: PPUSH
103267: CALL_OW 301
103271: IFFALSE 103219
// end ;
103273: PPOPN 1
103275: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103276: LD_EXP 121
103280: PUSH
103281: LD_EXP 161
103285: AND
103286: IFFALSE 103298
103288: GO 103290
103290: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103291: LD_STRING earthquake(getX(game), 0, 32)
103293: PPUSH
103294: CALL_OW 559
103298: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103299: LD_EXP 121
103303: PUSH
103304: LD_EXP 162
103308: AND
103309: IFFALSE 103400
103311: GO 103313
103313: DISABLE
103314: LD_INT 0
103316: PPUSH
// begin enable ;
103317: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103318: LD_ADDR_VAR 0 1
103322: PUSH
103323: LD_INT 22
103325: PUSH
103326: LD_OWVAR 2
103330: PUSH
103331: EMPTY
103332: LIST
103333: LIST
103334: PUSH
103335: LD_INT 21
103337: PUSH
103338: LD_INT 2
103340: PUSH
103341: EMPTY
103342: LIST
103343: LIST
103344: PUSH
103345: LD_INT 33
103347: PUSH
103348: LD_INT 3
103350: PUSH
103351: EMPTY
103352: LIST
103353: LIST
103354: PUSH
103355: EMPTY
103356: LIST
103357: LIST
103358: LIST
103359: PPUSH
103360: CALL_OW 69
103364: ST_TO_ADDR
// if not tmp then
103365: LD_VAR 0 1
103369: NOT
103370: IFFALSE 103374
// exit ;
103372: GO 103400
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103374: LD_VAR 0 1
103378: PUSH
103379: LD_INT 1
103381: PPUSH
103382: LD_VAR 0 1
103386: PPUSH
103387: CALL_OW 12
103391: ARRAY
103392: PPUSH
103393: LD_INT 1
103395: PPUSH
103396: CALL_OW 234
// end ;
103400: PPOPN 1
103402: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
103403: LD_EXP 121
103407: PUSH
103408: LD_EXP 163
103412: AND
103413: IFFALSE 103554
103415: GO 103417
103417: DISABLE
103418: LD_INT 0
103420: PPUSH
103421: PPUSH
103422: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103423: LD_ADDR_VAR 0 3
103427: PUSH
103428: LD_INT 22
103430: PUSH
103431: LD_OWVAR 2
103435: PUSH
103436: EMPTY
103437: LIST
103438: LIST
103439: PUSH
103440: LD_INT 25
103442: PUSH
103443: LD_INT 1
103445: PUSH
103446: EMPTY
103447: LIST
103448: LIST
103449: PUSH
103450: EMPTY
103451: LIST
103452: LIST
103453: PPUSH
103454: CALL_OW 69
103458: ST_TO_ADDR
// if not tmp then
103459: LD_VAR 0 3
103463: NOT
103464: IFFALSE 103468
// exit ;
103466: GO 103554
// un := tmp [ rand ( 1 , tmp ) ] ;
103468: LD_ADDR_VAR 0 2
103472: PUSH
103473: LD_VAR 0 3
103477: PUSH
103478: LD_INT 1
103480: PPUSH
103481: LD_VAR 0 3
103485: PPUSH
103486: CALL_OW 12
103490: ARRAY
103491: ST_TO_ADDR
// if Crawls ( un ) then
103492: LD_VAR 0 2
103496: PPUSH
103497: CALL_OW 318
103501: IFFALSE 103512
// ComWalk ( un ) ;
103503: LD_VAR 0 2
103507: PPUSH
103508: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
103512: LD_VAR 0 2
103516: PPUSH
103517: LD_INT 9
103519: PPUSH
103520: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
103524: LD_INT 28
103526: PPUSH
103527: LD_OWVAR 2
103531: PPUSH
103532: LD_INT 2
103534: PPUSH
103535: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
103539: LD_INT 29
103541: PPUSH
103542: LD_OWVAR 2
103546: PPUSH
103547: LD_INT 2
103549: PPUSH
103550: CALL_OW 322
// end ;
103554: PPOPN 3
103556: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
103557: LD_EXP 121
103561: PUSH
103562: LD_EXP 164
103566: AND
103567: IFFALSE 103678
103569: GO 103571
103571: DISABLE
103572: LD_INT 0
103574: PPUSH
103575: PPUSH
103576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103577: LD_ADDR_VAR 0 3
103581: PUSH
103582: LD_INT 22
103584: PUSH
103585: LD_OWVAR 2
103589: PUSH
103590: EMPTY
103591: LIST
103592: LIST
103593: PUSH
103594: LD_INT 25
103596: PUSH
103597: LD_INT 1
103599: PUSH
103600: EMPTY
103601: LIST
103602: LIST
103603: PUSH
103604: EMPTY
103605: LIST
103606: LIST
103607: PPUSH
103608: CALL_OW 69
103612: ST_TO_ADDR
// if not tmp then
103613: LD_VAR 0 3
103617: NOT
103618: IFFALSE 103622
// exit ;
103620: GO 103678
// un := tmp [ rand ( 1 , tmp ) ] ;
103622: LD_ADDR_VAR 0 2
103626: PUSH
103627: LD_VAR 0 3
103631: PUSH
103632: LD_INT 1
103634: PPUSH
103635: LD_VAR 0 3
103639: PPUSH
103640: CALL_OW 12
103644: ARRAY
103645: ST_TO_ADDR
// if Crawls ( un ) then
103646: LD_VAR 0 2
103650: PPUSH
103651: CALL_OW 318
103655: IFFALSE 103666
// ComWalk ( un ) ;
103657: LD_VAR 0 2
103661: PPUSH
103662: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103666: LD_VAR 0 2
103670: PPUSH
103671: LD_INT 8
103673: PPUSH
103674: CALL_OW 336
// end ;
103678: PPOPN 3
103680: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
103681: LD_EXP 121
103685: PUSH
103686: LD_EXP 165
103690: AND
103691: IFFALSE 103835
103693: GO 103695
103695: DISABLE
103696: LD_INT 0
103698: PPUSH
103699: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
103700: LD_ADDR_VAR 0 2
103704: PUSH
103705: LD_INT 22
103707: PUSH
103708: LD_OWVAR 2
103712: PUSH
103713: EMPTY
103714: LIST
103715: LIST
103716: PUSH
103717: LD_INT 21
103719: PUSH
103720: LD_INT 2
103722: PUSH
103723: EMPTY
103724: LIST
103725: LIST
103726: PUSH
103727: LD_INT 2
103729: PUSH
103730: LD_INT 34
103732: PUSH
103733: LD_INT 12
103735: PUSH
103736: EMPTY
103737: LIST
103738: LIST
103739: PUSH
103740: LD_INT 34
103742: PUSH
103743: LD_INT 51
103745: PUSH
103746: EMPTY
103747: LIST
103748: LIST
103749: PUSH
103750: LD_INT 34
103752: PUSH
103753: LD_INT 32
103755: PUSH
103756: EMPTY
103757: LIST
103758: LIST
103759: PUSH
103760: EMPTY
103761: LIST
103762: LIST
103763: LIST
103764: LIST
103765: PUSH
103766: EMPTY
103767: LIST
103768: LIST
103769: LIST
103770: PPUSH
103771: CALL_OW 69
103775: ST_TO_ADDR
// if not tmp then
103776: LD_VAR 0 2
103780: NOT
103781: IFFALSE 103785
// exit ;
103783: GO 103835
// for i in tmp do
103785: LD_ADDR_VAR 0 1
103789: PUSH
103790: LD_VAR 0 2
103794: PUSH
103795: FOR_IN
103796: IFFALSE 103833
// if GetCargo ( i , mat_artifact ) = 0 then
103798: LD_VAR 0 1
103802: PPUSH
103803: LD_INT 4
103805: PPUSH
103806: CALL_OW 289
103810: PUSH
103811: LD_INT 0
103813: EQUAL
103814: IFFALSE 103831
// SetCargo ( i , mat_siberit , 100 ) ;
103816: LD_VAR 0 1
103820: PPUSH
103821: LD_INT 3
103823: PPUSH
103824: LD_INT 100
103826: PPUSH
103827: CALL_OW 290
103831: GO 103795
103833: POP
103834: POP
// end ;
103835: PPOPN 2
103837: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
103838: LD_EXP 121
103842: PUSH
103843: LD_EXP 166
103847: AND
103848: IFFALSE 104031
103850: GO 103852
103852: DISABLE
103853: LD_INT 0
103855: PPUSH
103856: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103857: LD_ADDR_VAR 0 2
103861: PUSH
103862: LD_INT 22
103864: PUSH
103865: LD_OWVAR 2
103869: PUSH
103870: EMPTY
103871: LIST
103872: LIST
103873: PPUSH
103874: CALL_OW 69
103878: ST_TO_ADDR
// if not tmp then
103879: LD_VAR 0 2
103883: NOT
103884: IFFALSE 103888
// exit ;
103886: GO 104031
// for i := 1 to 2 do
103888: LD_ADDR_VAR 0 1
103892: PUSH
103893: DOUBLE
103894: LD_INT 1
103896: DEC
103897: ST_TO_ADDR
103898: LD_INT 2
103900: PUSH
103901: FOR_TO
103902: IFFALSE 104029
// begin uc_side := your_side ;
103904: LD_ADDR_OWVAR 20
103908: PUSH
103909: LD_OWVAR 2
103913: ST_TO_ADDR
// uc_nation := nation_american ;
103914: LD_ADDR_OWVAR 21
103918: PUSH
103919: LD_INT 1
103921: ST_TO_ADDR
// vc_chassis := us_morphling ;
103922: LD_ADDR_OWVAR 37
103926: PUSH
103927: LD_INT 5
103929: ST_TO_ADDR
// vc_engine := engine_siberite ;
103930: LD_ADDR_OWVAR 39
103934: PUSH
103935: LD_INT 3
103937: ST_TO_ADDR
// vc_control := control_computer ;
103938: LD_ADDR_OWVAR 38
103942: PUSH
103943: LD_INT 3
103945: ST_TO_ADDR
// vc_weapon := us_double_laser ;
103946: LD_ADDR_OWVAR 40
103950: PUSH
103951: LD_INT 10
103953: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
103954: LD_VAR 0 2
103958: PUSH
103959: LD_INT 1
103961: ARRAY
103962: PPUSH
103963: CALL_OW 310
103967: NOT
103968: IFFALSE 104015
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
103970: CALL_OW 45
103974: PPUSH
103975: LD_VAR 0 2
103979: PUSH
103980: LD_INT 1
103982: ARRAY
103983: PPUSH
103984: CALL_OW 250
103988: PPUSH
103989: LD_VAR 0 2
103993: PUSH
103994: LD_INT 1
103996: ARRAY
103997: PPUSH
103998: CALL_OW 251
104002: PPUSH
104003: LD_INT 12
104005: PPUSH
104006: LD_INT 1
104008: PPUSH
104009: CALL_OW 50
104013: GO 104027
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
104015: CALL_OW 45
104019: PPUSH
104020: LD_INT 1
104022: PPUSH
104023: CALL_OW 51
// end ;
104027: GO 103901
104029: POP
104030: POP
// end ;
104031: PPOPN 2
104033: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
104034: LD_EXP 121
104038: PUSH
104039: LD_EXP 167
104043: AND
104044: IFFALSE 104266
104046: GO 104048
104048: DISABLE
104049: LD_INT 0
104051: PPUSH
104052: PPUSH
104053: PPUSH
104054: PPUSH
104055: PPUSH
104056: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104057: LD_ADDR_VAR 0 6
104061: PUSH
104062: LD_INT 22
104064: PUSH
104065: LD_OWVAR 2
104069: PUSH
104070: EMPTY
104071: LIST
104072: LIST
104073: PUSH
104074: LD_INT 21
104076: PUSH
104077: LD_INT 1
104079: PUSH
104080: EMPTY
104081: LIST
104082: LIST
104083: PUSH
104084: LD_INT 3
104086: PUSH
104087: LD_INT 23
104089: PUSH
104090: LD_INT 0
104092: PUSH
104093: EMPTY
104094: LIST
104095: LIST
104096: PUSH
104097: EMPTY
104098: LIST
104099: LIST
104100: PUSH
104101: EMPTY
104102: LIST
104103: LIST
104104: LIST
104105: PPUSH
104106: CALL_OW 69
104110: ST_TO_ADDR
// if not tmp then
104111: LD_VAR 0 6
104115: NOT
104116: IFFALSE 104120
// exit ;
104118: GO 104266
// s1 := rand ( 1 , 4 ) ;
104120: LD_ADDR_VAR 0 2
104124: PUSH
104125: LD_INT 1
104127: PPUSH
104128: LD_INT 4
104130: PPUSH
104131: CALL_OW 12
104135: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
104136: LD_ADDR_VAR 0 4
104140: PUSH
104141: LD_VAR 0 6
104145: PUSH
104146: LD_INT 1
104148: ARRAY
104149: PPUSH
104150: LD_VAR 0 2
104154: PPUSH
104155: CALL_OW 259
104159: ST_TO_ADDR
// if s1 = 1 then
104160: LD_VAR 0 2
104164: PUSH
104165: LD_INT 1
104167: EQUAL
104168: IFFALSE 104188
// s2 := rand ( 2 , 4 ) else
104170: LD_ADDR_VAR 0 3
104174: PUSH
104175: LD_INT 2
104177: PPUSH
104178: LD_INT 4
104180: PPUSH
104181: CALL_OW 12
104185: ST_TO_ADDR
104186: GO 104196
// s2 := 1 ;
104188: LD_ADDR_VAR 0 3
104192: PUSH
104193: LD_INT 1
104195: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104196: LD_ADDR_VAR 0 5
104200: PUSH
104201: LD_VAR 0 6
104205: PUSH
104206: LD_INT 1
104208: ARRAY
104209: PPUSH
104210: LD_VAR 0 3
104214: PPUSH
104215: CALL_OW 259
104219: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104220: LD_VAR 0 6
104224: PUSH
104225: LD_INT 1
104227: ARRAY
104228: PPUSH
104229: LD_VAR 0 2
104233: PPUSH
104234: LD_VAR 0 5
104238: PPUSH
104239: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104243: LD_VAR 0 6
104247: PUSH
104248: LD_INT 1
104250: ARRAY
104251: PPUSH
104252: LD_VAR 0 3
104256: PPUSH
104257: LD_VAR 0 4
104261: PPUSH
104262: CALL_OW 237
// end ;
104266: PPOPN 6
104268: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104269: LD_EXP 121
104273: PUSH
104274: LD_EXP 168
104278: AND
104279: IFFALSE 104358
104281: GO 104283
104283: DISABLE
104284: LD_INT 0
104286: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104287: LD_ADDR_VAR 0 1
104291: PUSH
104292: LD_INT 22
104294: PUSH
104295: LD_OWVAR 2
104299: PUSH
104300: EMPTY
104301: LIST
104302: LIST
104303: PUSH
104304: LD_INT 30
104306: PUSH
104307: LD_INT 3
104309: PUSH
104310: EMPTY
104311: LIST
104312: LIST
104313: PUSH
104314: EMPTY
104315: LIST
104316: LIST
104317: PPUSH
104318: CALL_OW 69
104322: ST_TO_ADDR
// if not tmp then
104323: LD_VAR 0 1
104327: NOT
104328: IFFALSE 104332
// exit ;
104330: GO 104358
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104332: LD_VAR 0 1
104336: PUSH
104337: LD_INT 1
104339: PPUSH
104340: LD_VAR 0 1
104344: PPUSH
104345: CALL_OW 12
104349: ARRAY
104350: PPUSH
104351: LD_INT 1
104353: PPUSH
104354: CALL_OW 234
// end ;
104358: PPOPN 1
104360: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104361: LD_EXP 121
104365: PUSH
104366: LD_EXP 169
104370: AND
104371: IFFALSE 104483
104373: GO 104375
104375: DISABLE
104376: LD_INT 0
104378: PPUSH
104379: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104380: LD_ADDR_VAR 0 2
104384: PUSH
104385: LD_INT 22
104387: PUSH
104388: LD_OWVAR 2
104392: PUSH
104393: EMPTY
104394: LIST
104395: LIST
104396: PUSH
104397: LD_INT 2
104399: PUSH
104400: LD_INT 30
104402: PUSH
104403: LD_INT 27
104405: PUSH
104406: EMPTY
104407: LIST
104408: LIST
104409: PUSH
104410: LD_INT 30
104412: PUSH
104413: LD_INT 26
104415: PUSH
104416: EMPTY
104417: LIST
104418: LIST
104419: PUSH
104420: LD_INT 30
104422: PUSH
104423: LD_INT 28
104425: PUSH
104426: EMPTY
104427: LIST
104428: LIST
104429: PUSH
104430: EMPTY
104431: LIST
104432: LIST
104433: LIST
104434: LIST
104435: PUSH
104436: EMPTY
104437: LIST
104438: LIST
104439: PPUSH
104440: CALL_OW 69
104444: ST_TO_ADDR
// if not tmp then
104445: LD_VAR 0 2
104449: NOT
104450: IFFALSE 104454
// exit ;
104452: GO 104483
// for i in tmp do
104454: LD_ADDR_VAR 0 1
104458: PUSH
104459: LD_VAR 0 2
104463: PUSH
104464: FOR_IN
104465: IFFALSE 104481
// SetLives ( i , 1 ) ;
104467: LD_VAR 0 1
104471: PPUSH
104472: LD_INT 1
104474: PPUSH
104475: CALL_OW 234
104479: GO 104464
104481: POP
104482: POP
// end ;
104483: PPOPN 2
104485: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
104486: LD_EXP 121
104490: PUSH
104491: LD_EXP 170
104495: AND
104496: IFFALSE 104783
104498: GO 104500
104500: DISABLE
104501: LD_INT 0
104503: PPUSH
104504: PPUSH
104505: PPUSH
// begin i := rand ( 1 , 7 ) ;
104506: LD_ADDR_VAR 0 1
104510: PUSH
104511: LD_INT 1
104513: PPUSH
104514: LD_INT 7
104516: PPUSH
104517: CALL_OW 12
104521: ST_TO_ADDR
// case i of 1 :
104522: LD_VAR 0 1
104526: PUSH
104527: LD_INT 1
104529: DOUBLE
104530: EQUAL
104531: IFTRUE 104535
104533: GO 104545
104535: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
104536: LD_STRING earthquake(getX(game), 0, 32)
104538: PPUSH
104539: CALL_OW 559
104543: GO 104783
104545: LD_INT 2
104547: DOUBLE
104548: EQUAL
104549: IFTRUE 104553
104551: GO 104567
104553: POP
// begin ToLua ( displayStucuk(); ) ;
104554: LD_STRING displayStucuk();
104556: PPUSH
104557: CALL_OW 559
// ResetFog ;
104561: CALL_OW 335
// end ; 3 :
104565: GO 104783
104567: LD_INT 3
104569: DOUBLE
104570: EQUAL
104571: IFTRUE 104575
104573: GO 104679
104575: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104576: LD_ADDR_VAR 0 2
104580: PUSH
104581: LD_INT 22
104583: PUSH
104584: LD_OWVAR 2
104588: PUSH
104589: EMPTY
104590: LIST
104591: LIST
104592: PUSH
104593: LD_INT 25
104595: PUSH
104596: LD_INT 1
104598: PUSH
104599: EMPTY
104600: LIST
104601: LIST
104602: PUSH
104603: EMPTY
104604: LIST
104605: LIST
104606: PPUSH
104607: CALL_OW 69
104611: ST_TO_ADDR
// if not tmp then
104612: LD_VAR 0 2
104616: NOT
104617: IFFALSE 104621
// exit ;
104619: GO 104783
// un := tmp [ rand ( 1 , tmp ) ] ;
104621: LD_ADDR_VAR 0 3
104625: PUSH
104626: LD_VAR 0 2
104630: PUSH
104631: LD_INT 1
104633: PPUSH
104634: LD_VAR 0 2
104638: PPUSH
104639: CALL_OW 12
104643: ARRAY
104644: ST_TO_ADDR
// if Crawls ( un ) then
104645: LD_VAR 0 3
104649: PPUSH
104650: CALL_OW 318
104654: IFFALSE 104665
// ComWalk ( un ) ;
104656: LD_VAR 0 3
104660: PPUSH
104661: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104665: LD_VAR 0 3
104669: PPUSH
104670: LD_INT 8
104672: PPUSH
104673: CALL_OW 336
// end ; 4 :
104677: GO 104783
104679: LD_INT 4
104681: DOUBLE
104682: EQUAL
104683: IFTRUE 104687
104685: GO 104761
104687: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104688: LD_ADDR_VAR 0 2
104692: PUSH
104693: LD_INT 22
104695: PUSH
104696: LD_OWVAR 2
104700: PUSH
104701: EMPTY
104702: LIST
104703: LIST
104704: PUSH
104705: LD_INT 30
104707: PUSH
104708: LD_INT 29
104710: PUSH
104711: EMPTY
104712: LIST
104713: LIST
104714: PUSH
104715: EMPTY
104716: LIST
104717: LIST
104718: PPUSH
104719: CALL_OW 69
104723: ST_TO_ADDR
// if not tmp then
104724: LD_VAR 0 2
104728: NOT
104729: IFFALSE 104733
// exit ;
104731: GO 104783
// CenterNowOnUnits ( tmp [ 1 ] ) ;
104733: LD_VAR 0 2
104737: PUSH
104738: LD_INT 1
104740: ARRAY
104741: PPUSH
104742: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
104746: LD_VAR 0 2
104750: PUSH
104751: LD_INT 1
104753: ARRAY
104754: PPUSH
104755: CALL_OW 65
// end ; 5 .. 7 :
104759: GO 104783
104761: LD_INT 5
104763: DOUBLE
104764: GREATEREQUAL
104765: IFFALSE 104773
104767: LD_INT 7
104769: DOUBLE
104770: LESSEQUAL
104771: IFTRUE 104775
104773: GO 104782
104775: POP
// StreamSibBomb ; end ;
104776: CALL 101020 0 0
104780: GO 104783
104782: POP
// end ;
104783: PPOPN 3
104785: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
104786: LD_EXP 121
104790: PUSH
104791: LD_EXP 171
104795: AND
104796: IFFALSE 104952
104798: GO 104800
104800: DISABLE
104801: LD_INT 0
104803: PPUSH
104804: PPUSH
104805: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
104806: LD_ADDR_VAR 0 2
104810: PUSH
104811: LD_INT 81
104813: PUSH
104814: LD_OWVAR 2
104818: PUSH
104819: EMPTY
104820: LIST
104821: LIST
104822: PUSH
104823: LD_INT 2
104825: PUSH
104826: LD_INT 21
104828: PUSH
104829: LD_INT 1
104831: PUSH
104832: EMPTY
104833: LIST
104834: LIST
104835: PUSH
104836: LD_INT 21
104838: PUSH
104839: LD_INT 2
104841: PUSH
104842: EMPTY
104843: LIST
104844: LIST
104845: PUSH
104846: EMPTY
104847: LIST
104848: LIST
104849: LIST
104850: PUSH
104851: EMPTY
104852: LIST
104853: LIST
104854: PPUSH
104855: CALL_OW 69
104859: ST_TO_ADDR
// if not tmp then
104860: LD_VAR 0 2
104864: NOT
104865: IFFALSE 104869
// exit ;
104867: GO 104952
// p := 0 ;
104869: LD_ADDR_VAR 0 3
104873: PUSH
104874: LD_INT 0
104876: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104877: LD_INT 35
104879: PPUSH
104880: CALL_OW 67
// p := p + 1 ;
104884: LD_ADDR_VAR 0 3
104888: PUSH
104889: LD_VAR 0 3
104893: PUSH
104894: LD_INT 1
104896: PLUS
104897: ST_TO_ADDR
// for i in tmp do
104898: LD_ADDR_VAR 0 1
104902: PUSH
104903: LD_VAR 0 2
104907: PUSH
104908: FOR_IN
104909: IFFALSE 104940
// if GetLives ( i ) < 1000 then
104911: LD_VAR 0 1
104915: PPUSH
104916: CALL_OW 256
104920: PUSH
104921: LD_INT 1000
104923: LESS
104924: IFFALSE 104938
// SetLives ( i , 1000 ) ;
104926: LD_VAR 0 1
104930: PPUSH
104931: LD_INT 1000
104933: PPUSH
104934: CALL_OW 234
104938: GO 104908
104940: POP
104941: POP
// until p > 20 ;
104942: LD_VAR 0 3
104946: PUSH
104947: LD_INT 20
104949: GREATER
104950: IFFALSE 104877
// end ;
104952: PPOPN 3
104954: END
// every 0 0$1 trigger StreamModeActive and sTime do
104955: LD_EXP 121
104959: PUSH
104960: LD_EXP 172
104964: AND
104965: IFFALSE 105000
104967: GO 104969
104969: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
104970: LD_INT 28
104972: PPUSH
104973: LD_OWVAR 2
104977: PPUSH
104978: LD_INT 2
104980: PPUSH
104981: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
104985: LD_INT 30
104987: PPUSH
104988: LD_OWVAR 2
104992: PPUSH
104993: LD_INT 2
104995: PPUSH
104996: CALL_OW 322
// end ;
105000: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
105001: LD_EXP 121
105005: PUSH
105006: LD_EXP 173
105010: AND
105011: IFFALSE 105132
105013: GO 105015
105015: DISABLE
105016: LD_INT 0
105018: PPUSH
105019: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105020: LD_ADDR_VAR 0 2
105024: PUSH
105025: LD_INT 22
105027: PUSH
105028: LD_OWVAR 2
105032: PUSH
105033: EMPTY
105034: LIST
105035: LIST
105036: PUSH
105037: LD_INT 21
105039: PUSH
105040: LD_INT 1
105042: PUSH
105043: EMPTY
105044: LIST
105045: LIST
105046: PUSH
105047: LD_INT 3
105049: PUSH
105050: LD_INT 23
105052: PUSH
105053: LD_INT 0
105055: PUSH
105056: EMPTY
105057: LIST
105058: LIST
105059: PUSH
105060: EMPTY
105061: LIST
105062: LIST
105063: PUSH
105064: EMPTY
105065: LIST
105066: LIST
105067: LIST
105068: PPUSH
105069: CALL_OW 69
105073: ST_TO_ADDR
// if not tmp then
105074: LD_VAR 0 2
105078: NOT
105079: IFFALSE 105083
// exit ;
105081: GO 105132
// for i in tmp do
105083: LD_ADDR_VAR 0 1
105087: PUSH
105088: LD_VAR 0 2
105092: PUSH
105093: FOR_IN
105094: IFFALSE 105130
// begin if Crawls ( i ) then
105096: LD_VAR 0 1
105100: PPUSH
105101: CALL_OW 318
105105: IFFALSE 105116
// ComWalk ( i ) ;
105107: LD_VAR 0 1
105111: PPUSH
105112: CALL_OW 138
// SetClass ( i , 2 ) ;
105116: LD_VAR 0 1
105120: PPUSH
105121: LD_INT 2
105123: PPUSH
105124: CALL_OW 336
// end ;
105128: GO 105093
105130: POP
105131: POP
// end ;
105132: PPOPN 2
105134: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
105135: LD_EXP 121
105139: PUSH
105140: LD_EXP 174
105144: AND
105145: IFFALSE 105433
105147: GO 105149
105149: DISABLE
105150: LD_INT 0
105152: PPUSH
105153: PPUSH
105154: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
105155: LD_OWVAR 2
105159: PPUSH
105160: LD_INT 9
105162: PPUSH
105163: LD_INT 1
105165: PPUSH
105166: LD_INT 1
105168: PPUSH
105169: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
105173: LD_INT 9
105175: PPUSH
105176: LD_OWVAR 2
105180: PPUSH
105181: CALL_OW 343
// uc_side := 9 ;
105185: LD_ADDR_OWVAR 20
105189: PUSH
105190: LD_INT 9
105192: ST_TO_ADDR
// uc_nation := 2 ;
105193: LD_ADDR_OWVAR 21
105197: PUSH
105198: LD_INT 2
105200: ST_TO_ADDR
// hc_name := Dark Warrior ;
105201: LD_ADDR_OWVAR 26
105205: PUSH
105206: LD_STRING Dark Warrior
105208: ST_TO_ADDR
// hc_gallery :=  ;
105209: LD_ADDR_OWVAR 33
105213: PUSH
105214: LD_STRING 
105216: ST_TO_ADDR
// hc_noskilllimit := true ;
105217: LD_ADDR_OWVAR 76
105221: PUSH
105222: LD_INT 1
105224: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105225: LD_ADDR_OWVAR 31
105229: PUSH
105230: LD_INT 30
105232: PUSH
105233: LD_INT 30
105235: PUSH
105236: LD_INT 30
105238: PUSH
105239: LD_INT 30
105241: PUSH
105242: EMPTY
105243: LIST
105244: LIST
105245: LIST
105246: LIST
105247: ST_TO_ADDR
// un := CreateHuman ;
105248: LD_ADDR_VAR 0 3
105252: PUSH
105253: CALL_OW 44
105257: ST_TO_ADDR
// hc_noskilllimit := false ;
105258: LD_ADDR_OWVAR 76
105262: PUSH
105263: LD_INT 0
105265: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105266: LD_VAR 0 3
105270: PPUSH
105271: LD_INT 1
105273: PPUSH
105274: CALL_OW 51
// ToLua ( playRanger() ) ;
105278: LD_STRING playRanger()
105280: PPUSH
105281: CALL_OW 559
// p := 0 ;
105285: LD_ADDR_VAR 0 2
105289: PUSH
105290: LD_INT 0
105292: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105293: LD_INT 35
105295: PPUSH
105296: CALL_OW 67
// p := p + 1 ;
105300: LD_ADDR_VAR 0 2
105304: PUSH
105305: LD_VAR 0 2
105309: PUSH
105310: LD_INT 1
105312: PLUS
105313: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105314: LD_VAR 0 3
105318: PPUSH
105319: CALL_OW 256
105323: PUSH
105324: LD_INT 1000
105326: LESS
105327: IFFALSE 105341
// SetLives ( un , 1000 ) ;
105329: LD_VAR 0 3
105333: PPUSH
105334: LD_INT 1000
105336: PPUSH
105337: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105341: LD_VAR 0 3
105345: PPUSH
105346: LD_INT 81
105348: PUSH
105349: LD_OWVAR 2
105353: PUSH
105354: EMPTY
105355: LIST
105356: LIST
105357: PUSH
105358: LD_INT 91
105360: PUSH
105361: LD_VAR 0 3
105365: PUSH
105366: LD_INT 30
105368: PUSH
105369: EMPTY
105370: LIST
105371: LIST
105372: LIST
105373: PUSH
105374: EMPTY
105375: LIST
105376: LIST
105377: PPUSH
105378: CALL_OW 69
105382: PPUSH
105383: LD_VAR 0 3
105387: PPUSH
105388: CALL_OW 74
105392: PPUSH
105393: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
105397: LD_VAR 0 2
105401: PUSH
105402: LD_INT 80
105404: GREATER
105405: PUSH
105406: LD_VAR 0 3
105410: PPUSH
105411: CALL_OW 301
105415: OR
105416: IFFALSE 105293
// if un then
105418: LD_VAR 0 3
105422: IFFALSE 105433
// RemoveUnit ( un ) ;
105424: LD_VAR 0 3
105428: PPUSH
105429: CALL_OW 64
// end ;
105433: PPOPN 3
105435: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
105436: LD_EXP 175
105440: IFFALSE 105556
105442: GO 105444
105444: DISABLE
105445: LD_INT 0
105447: PPUSH
105448: PPUSH
105449: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105450: LD_ADDR_VAR 0 2
105454: PUSH
105455: LD_INT 81
105457: PUSH
105458: LD_OWVAR 2
105462: PUSH
105463: EMPTY
105464: LIST
105465: LIST
105466: PUSH
105467: LD_INT 21
105469: PUSH
105470: LD_INT 1
105472: PUSH
105473: EMPTY
105474: LIST
105475: LIST
105476: PUSH
105477: EMPTY
105478: LIST
105479: LIST
105480: PPUSH
105481: CALL_OW 69
105485: ST_TO_ADDR
// ToLua ( playComputer() ) ;
105486: LD_STRING playComputer()
105488: PPUSH
105489: CALL_OW 559
// if not tmp then
105493: LD_VAR 0 2
105497: NOT
105498: IFFALSE 105502
// exit ;
105500: GO 105556
// for i in tmp do
105502: LD_ADDR_VAR 0 1
105506: PUSH
105507: LD_VAR 0 2
105511: PUSH
105512: FOR_IN
105513: IFFALSE 105554
// for j := 1 to 4 do
105515: LD_ADDR_VAR 0 3
105519: PUSH
105520: DOUBLE
105521: LD_INT 1
105523: DEC
105524: ST_TO_ADDR
105525: LD_INT 4
105527: PUSH
105528: FOR_TO
105529: IFFALSE 105550
// SetSkill ( i , j , 10 ) ;
105531: LD_VAR 0 1
105535: PPUSH
105536: LD_VAR 0 3
105540: PPUSH
105541: LD_INT 10
105543: PPUSH
105544: CALL_OW 237
105548: GO 105528
105550: POP
105551: POP
105552: GO 105512
105554: POP
105555: POP
// end ;
105556: PPOPN 3
105558: END
// every 0 0$1 trigger s30 do var i , tmp ;
105559: LD_EXP 176
105563: IFFALSE 105632
105565: GO 105567
105567: DISABLE
105568: LD_INT 0
105570: PPUSH
105571: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105572: LD_ADDR_VAR 0 2
105576: PUSH
105577: LD_INT 22
105579: PUSH
105580: LD_OWVAR 2
105584: PUSH
105585: EMPTY
105586: LIST
105587: LIST
105588: PPUSH
105589: CALL_OW 69
105593: ST_TO_ADDR
// if not tmp then
105594: LD_VAR 0 2
105598: NOT
105599: IFFALSE 105603
// exit ;
105601: GO 105632
// for i in tmp do
105603: LD_ADDR_VAR 0 1
105607: PUSH
105608: LD_VAR 0 2
105612: PUSH
105613: FOR_IN
105614: IFFALSE 105630
// SetLives ( i , 300 ) ;
105616: LD_VAR 0 1
105620: PPUSH
105621: LD_INT 300
105623: PPUSH
105624: CALL_OW 234
105628: GO 105613
105630: POP
105631: POP
// end ;
105632: PPOPN 2
105634: END
// every 0 0$1 trigger s60 do var i , tmp ;
105635: LD_EXP 177
105639: IFFALSE 105708
105641: GO 105643
105643: DISABLE
105644: LD_INT 0
105646: PPUSH
105647: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105648: LD_ADDR_VAR 0 2
105652: PUSH
105653: LD_INT 22
105655: PUSH
105656: LD_OWVAR 2
105660: PUSH
105661: EMPTY
105662: LIST
105663: LIST
105664: PPUSH
105665: CALL_OW 69
105669: ST_TO_ADDR
// if not tmp then
105670: LD_VAR 0 2
105674: NOT
105675: IFFALSE 105679
// exit ;
105677: GO 105708
// for i in tmp do
105679: LD_ADDR_VAR 0 1
105683: PUSH
105684: LD_VAR 0 2
105688: PUSH
105689: FOR_IN
105690: IFFALSE 105706
// SetLives ( i , 600 ) ;
105692: LD_VAR 0 1
105696: PPUSH
105697: LD_INT 600
105699: PPUSH
105700: CALL_OW 234
105704: GO 105689
105706: POP
105707: POP
// end ;
105708: PPOPN 2
105710: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105711: LD_INT 0
105713: PPUSH
// case cmd of 301 :
105714: LD_VAR 0 1
105718: PUSH
105719: LD_INT 301
105721: DOUBLE
105722: EQUAL
105723: IFTRUE 105727
105725: GO 105759
105727: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
105728: LD_VAR 0 6
105732: PPUSH
105733: LD_VAR 0 7
105737: PPUSH
105738: LD_VAR 0 8
105742: PPUSH
105743: LD_VAR 0 4
105747: PPUSH
105748: LD_VAR 0 5
105752: PPUSH
105753: CALL 106960 0 5
105757: GO 105880
105759: LD_INT 302
105761: DOUBLE
105762: EQUAL
105763: IFTRUE 105767
105765: GO 105804
105767: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
105768: LD_VAR 0 6
105772: PPUSH
105773: LD_VAR 0 7
105777: PPUSH
105778: LD_VAR 0 8
105782: PPUSH
105783: LD_VAR 0 9
105787: PPUSH
105788: LD_VAR 0 4
105792: PPUSH
105793: LD_VAR 0 5
105797: PPUSH
105798: CALL 107051 0 6
105802: GO 105880
105804: LD_INT 303
105806: DOUBLE
105807: EQUAL
105808: IFTRUE 105812
105810: GO 105849
105812: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
105813: LD_VAR 0 6
105817: PPUSH
105818: LD_VAR 0 7
105822: PPUSH
105823: LD_VAR 0 8
105827: PPUSH
105828: LD_VAR 0 9
105832: PPUSH
105833: LD_VAR 0 4
105837: PPUSH
105838: LD_VAR 0 5
105842: PPUSH
105843: CALL 105885 0 6
105847: GO 105880
105849: LD_INT 304
105851: DOUBLE
105852: EQUAL
105853: IFTRUE 105857
105855: GO 105879
105857: POP
// hHackTeleport ( unit , x , y ) ; end ;
105858: LD_VAR 0 2
105862: PPUSH
105863: LD_VAR 0 4
105867: PPUSH
105868: LD_VAR 0 5
105872: PPUSH
105873: CALL 107644 0 3
105877: GO 105880
105879: POP
// end ;
105880: LD_VAR 0 12
105884: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
105885: LD_INT 0
105887: PPUSH
105888: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
105889: LD_VAR 0 1
105893: PUSH
105894: LD_INT 1
105896: LESS
105897: PUSH
105898: LD_VAR 0 1
105902: PUSH
105903: LD_INT 3
105905: GREATER
105906: OR
105907: PUSH
105908: LD_VAR 0 5
105912: PPUSH
105913: LD_VAR 0 6
105917: PPUSH
105918: CALL_OW 428
105922: OR
105923: IFFALSE 105927
// exit ;
105925: GO 106647
// uc_side := your_side ;
105927: LD_ADDR_OWVAR 20
105931: PUSH
105932: LD_OWVAR 2
105936: ST_TO_ADDR
// uc_nation := nation ;
105937: LD_ADDR_OWVAR 21
105941: PUSH
105942: LD_VAR 0 1
105946: ST_TO_ADDR
// bc_level = 1 ;
105947: LD_ADDR_OWVAR 43
105951: PUSH
105952: LD_INT 1
105954: ST_TO_ADDR
// case btype of 1 :
105955: LD_VAR 0 2
105959: PUSH
105960: LD_INT 1
105962: DOUBLE
105963: EQUAL
105964: IFTRUE 105968
105966: GO 105979
105968: POP
// bc_type := b_depot ; 2 :
105969: LD_ADDR_OWVAR 42
105973: PUSH
105974: LD_INT 0
105976: ST_TO_ADDR
105977: GO 106591
105979: LD_INT 2
105981: DOUBLE
105982: EQUAL
105983: IFTRUE 105987
105985: GO 105998
105987: POP
// bc_type := b_warehouse ; 3 :
105988: LD_ADDR_OWVAR 42
105992: PUSH
105993: LD_INT 1
105995: ST_TO_ADDR
105996: GO 106591
105998: LD_INT 3
106000: DOUBLE
106001: EQUAL
106002: IFTRUE 106006
106004: GO 106017
106006: POP
// bc_type := b_lab ; 4 .. 9 :
106007: LD_ADDR_OWVAR 42
106011: PUSH
106012: LD_INT 6
106014: ST_TO_ADDR
106015: GO 106591
106017: LD_INT 4
106019: DOUBLE
106020: GREATEREQUAL
106021: IFFALSE 106029
106023: LD_INT 9
106025: DOUBLE
106026: LESSEQUAL
106027: IFTRUE 106031
106029: GO 106083
106031: POP
// begin bc_type := b_lab_half ;
106032: LD_ADDR_OWVAR 42
106036: PUSH
106037: LD_INT 7
106039: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
106040: LD_ADDR_OWVAR 44
106044: PUSH
106045: LD_INT 10
106047: PUSH
106048: LD_INT 11
106050: PUSH
106051: LD_INT 12
106053: PUSH
106054: LD_INT 15
106056: PUSH
106057: LD_INT 14
106059: PUSH
106060: LD_INT 13
106062: PUSH
106063: EMPTY
106064: LIST
106065: LIST
106066: LIST
106067: LIST
106068: LIST
106069: LIST
106070: PUSH
106071: LD_VAR 0 2
106075: PUSH
106076: LD_INT 3
106078: MINUS
106079: ARRAY
106080: ST_TO_ADDR
// end ; 10 .. 13 :
106081: GO 106591
106083: LD_INT 10
106085: DOUBLE
106086: GREATEREQUAL
106087: IFFALSE 106095
106089: LD_INT 13
106091: DOUBLE
106092: LESSEQUAL
106093: IFTRUE 106097
106095: GO 106174
106097: POP
// begin bc_type := b_lab_full ;
106098: LD_ADDR_OWVAR 42
106102: PUSH
106103: LD_INT 8
106105: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
106106: LD_ADDR_OWVAR 44
106110: PUSH
106111: LD_INT 10
106113: PUSH
106114: LD_INT 12
106116: PUSH
106117: LD_INT 14
106119: PUSH
106120: LD_INT 13
106122: PUSH
106123: EMPTY
106124: LIST
106125: LIST
106126: LIST
106127: LIST
106128: PUSH
106129: LD_VAR 0 2
106133: PUSH
106134: LD_INT 9
106136: MINUS
106137: ARRAY
106138: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
106139: LD_ADDR_OWVAR 45
106143: PUSH
106144: LD_INT 11
106146: PUSH
106147: LD_INT 15
106149: PUSH
106150: LD_INT 12
106152: PUSH
106153: LD_INT 15
106155: PUSH
106156: EMPTY
106157: LIST
106158: LIST
106159: LIST
106160: LIST
106161: PUSH
106162: LD_VAR 0 2
106166: PUSH
106167: LD_INT 9
106169: MINUS
106170: ARRAY
106171: ST_TO_ADDR
// end ; 14 :
106172: GO 106591
106174: LD_INT 14
106176: DOUBLE
106177: EQUAL
106178: IFTRUE 106182
106180: GO 106193
106182: POP
// bc_type := b_workshop ; 15 :
106183: LD_ADDR_OWVAR 42
106187: PUSH
106188: LD_INT 2
106190: ST_TO_ADDR
106191: GO 106591
106193: LD_INT 15
106195: DOUBLE
106196: EQUAL
106197: IFTRUE 106201
106199: GO 106212
106201: POP
// bc_type := b_factory ; 16 :
106202: LD_ADDR_OWVAR 42
106206: PUSH
106207: LD_INT 3
106209: ST_TO_ADDR
106210: GO 106591
106212: LD_INT 16
106214: DOUBLE
106215: EQUAL
106216: IFTRUE 106220
106218: GO 106231
106220: POP
// bc_type := b_ext_gun ; 17 :
106221: LD_ADDR_OWVAR 42
106225: PUSH
106226: LD_INT 17
106228: ST_TO_ADDR
106229: GO 106591
106231: LD_INT 17
106233: DOUBLE
106234: EQUAL
106235: IFTRUE 106239
106237: GO 106267
106239: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106240: LD_ADDR_OWVAR 42
106244: PUSH
106245: LD_INT 19
106247: PUSH
106248: LD_INT 23
106250: PUSH
106251: LD_INT 19
106253: PUSH
106254: EMPTY
106255: LIST
106256: LIST
106257: LIST
106258: PUSH
106259: LD_VAR 0 1
106263: ARRAY
106264: ST_TO_ADDR
106265: GO 106591
106267: LD_INT 18
106269: DOUBLE
106270: EQUAL
106271: IFTRUE 106275
106273: GO 106286
106275: POP
// bc_type := b_ext_radar ; 19 :
106276: LD_ADDR_OWVAR 42
106280: PUSH
106281: LD_INT 20
106283: ST_TO_ADDR
106284: GO 106591
106286: LD_INT 19
106288: DOUBLE
106289: EQUAL
106290: IFTRUE 106294
106292: GO 106305
106294: POP
// bc_type := b_ext_radio ; 20 :
106295: LD_ADDR_OWVAR 42
106299: PUSH
106300: LD_INT 22
106302: ST_TO_ADDR
106303: GO 106591
106305: LD_INT 20
106307: DOUBLE
106308: EQUAL
106309: IFTRUE 106313
106311: GO 106324
106313: POP
// bc_type := b_ext_siberium ; 21 :
106314: LD_ADDR_OWVAR 42
106318: PUSH
106319: LD_INT 21
106321: ST_TO_ADDR
106322: GO 106591
106324: LD_INT 21
106326: DOUBLE
106327: EQUAL
106328: IFTRUE 106332
106330: GO 106343
106332: POP
// bc_type := b_ext_computer ; 22 :
106333: LD_ADDR_OWVAR 42
106337: PUSH
106338: LD_INT 24
106340: ST_TO_ADDR
106341: GO 106591
106343: LD_INT 22
106345: DOUBLE
106346: EQUAL
106347: IFTRUE 106351
106349: GO 106362
106351: POP
// bc_type := b_ext_track ; 23 :
106352: LD_ADDR_OWVAR 42
106356: PUSH
106357: LD_INT 16
106359: ST_TO_ADDR
106360: GO 106591
106362: LD_INT 23
106364: DOUBLE
106365: EQUAL
106366: IFTRUE 106370
106368: GO 106381
106370: POP
// bc_type := b_ext_laser ; 24 :
106371: LD_ADDR_OWVAR 42
106375: PUSH
106376: LD_INT 25
106378: ST_TO_ADDR
106379: GO 106591
106381: LD_INT 24
106383: DOUBLE
106384: EQUAL
106385: IFTRUE 106389
106387: GO 106400
106389: POP
// bc_type := b_control_tower ; 25 :
106390: LD_ADDR_OWVAR 42
106394: PUSH
106395: LD_INT 36
106397: ST_TO_ADDR
106398: GO 106591
106400: LD_INT 25
106402: DOUBLE
106403: EQUAL
106404: IFTRUE 106408
106406: GO 106419
106408: POP
// bc_type := b_breastwork ; 26 :
106409: LD_ADDR_OWVAR 42
106413: PUSH
106414: LD_INT 31
106416: ST_TO_ADDR
106417: GO 106591
106419: LD_INT 26
106421: DOUBLE
106422: EQUAL
106423: IFTRUE 106427
106425: GO 106438
106427: POP
// bc_type := b_bunker ; 27 :
106428: LD_ADDR_OWVAR 42
106432: PUSH
106433: LD_INT 32
106435: ST_TO_ADDR
106436: GO 106591
106438: LD_INT 27
106440: DOUBLE
106441: EQUAL
106442: IFTRUE 106446
106444: GO 106457
106446: POP
// bc_type := b_turret ; 28 :
106447: LD_ADDR_OWVAR 42
106451: PUSH
106452: LD_INT 33
106454: ST_TO_ADDR
106455: GO 106591
106457: LD_INT 28
106459: DOUBLE
106460: EQUAL
106461: IFTRUE 106465
106463: GO 106476
106465: POP
// bc_type := b_armoury ; 29 :
106466: LD_ADDR_OWVAR 42
106470: PUSH
106471: LD_INT 4
106473: ST_TO_ADDR
106474: GO 106591
106476: LD_INT 29
106478: DOUBLE
106479: EQUAL
106480: IFTRUE 106484
106482: GO 106495
106484: POP
// bc_type := b_barracks ; 30 :
106485: LD_ADDR_OWVAR 42
106489: PUSH
106490: LD_INT 5
106492: ST_TO_ADDR
106493: GO 106591
106495: LD_INT 30
106497: DOUBLE
106498: EQUAL
106499: IFTRUE 106503
106501: GO 106514
106503: POP
// bc_type := b_solar_power ; 31 :
106504: LD_ADDR_OWVAR 42
106508: PUSH
106509: LD_INT 27
106511: ST_TO_ADDR
106512: GO 106591
106514: LD_INT 31
106516: DOUBLE
106517: EQUAL
106518: IFTRUE 106522
106520: GO 106533
106522: POP
// bc_type := b_oil_power ; 32 :
106523: LD_ADDR_OWVAR 42
106527: PUSH
106528: LD_INT 26
106530: ST_TO_ADDR
106531: GO 106591
106533: LD_INT 32
106535: DOUBLE
106536: EQUAL
106537: IFTRUE 106541
106539: GO 106552
106541: POP
// bc_type := b_siberite_power ; 33 :
106542: LD_ADDR_OWVAR 42
106546: PUSH
106547: LD_INT 28
106549: ST_TO_ADDR
106550: GO 106591
106552: LD_INT 33
106554: DOUBLE
106555: EQUAL
106556: IFTRUE 106560
106558: GO 106571
106560: POP
// bc_type := b_oil_mine ; 34 :
106561: LD_ADDR_OWVAR 42
106565: PUSH
106566: LD_INT 29
106568: ST_TO_ADDR
106569: GO 106591
106571: LD_INT 34
106573: DOUBLE
106574: EQUAL
106575: IFTRUE 106579
106577: GO 106590
106579: POP
// bc_type := b_siberite_mine ; end ;
106580: LD_ADDR_OWVAR 42
106584: PUSH
106585: LD_INT 30
106587: ST_TO_ADDR
106588: GO 106591
106590: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
106591: LD_ADDR_VAR 0 8
106595: PUSH
106596: LD_VAR 0 5
106600: PPUSH
106601: LD_VAR 0 6
106605: PPUSH
106606: LD_VAR 0 3
106610: PPUSH
106611: CALL_OW 47
106615: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
106616: LD_OWVAR 42
106620: PUSH
106621: LD_INT 32
106623: PUSH
106624: LD_INT 33
106626: PUSH
106627: EMPTY
106628: LIST
106629: LIST
106630: IN
106631: IFFALSE 106647
// PlaceWeaponTurret ( b , weapon ) ;
106633: LD_VAR 0 8
106637: PPUSH
106638: LD_VAR 0 4
106642: PPUSH
106643: CALL_OW 431
// end ;
106647: LD_VAR 0 7
106651: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
106652: LD_INT 0
106654: PPUSH
106655: PPUSH
106656: PPUSH
106657: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106658: LD_ADDR_VAR 0 4
106662: PUSH
106663: LD_INT 22
106665: PUSH
106666: LD_OWVAR 2
106670: PUSH
106671: EMPTY
106672: LIST
106673: LIST
106674: PUSH
106675: LD_INT 2
106677: PUSH
106678: LD_INT 30
106680: PUSH
106681: LD_INT 0
106683: PUSH
106684: EMPTY
106685: LIST
106686: LIST
106687: PUSH
106688: LD_INT 30
106690: PUSH
106691: LD_INT 1
106693: PUSH
106694: EMPTY
106695: LIST
106696: LIST
106697: PUSH
106698: EMPTY
106699: LIST
106700: LIST
106701: LIST
106702: PUSH
106703: EMPTY
106704: LIST
106705: LIST
106706: PPUSH
106707: CALL_OW 69
106711: ST_TO_ADDR
// if not tmp then
106712: LD_VAR 0 4
106716: NOT
106717: IFFALSE 106721
// exit ;
106719: GO 106780
// for i in tmp do
106721: LD_ADDR_VAR 0 2
106725: PUSH
106726: LD_VAR 0 4
106730: PUSH
106731: FOR_IN
106732: IFFALSE 106778
// for j = 1 to 3 do
106734: LD_ADDR_VAR 0 3
106738: PUSH
106739: DOUBLE
106740: LD_INT 1
106742: DEC
106743: ST_TO_ADDR
106744: LD_INT 3
106746: PUSH
106747: FOR_TO
106748: IFFALSE 106774
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
106750: LD_VAR 0 2
106754: PPUSH
106755: CALL_OW 274
106759: PPUSH
106760: LD_VAR 0 3
106764: PPUSH
106765: LD_INT 99999
106767: PPUSH
106768: CALL_OW 277
106772: GO 106747
106774: POP
106775: POP
106776: GO 106731
106778: POP
106779: POP
// end ;
106780: LD_VAR 0 1
106784: RET
// export function hHackSetLevel10 ; var i , j ; begin
106785: LD_INT 0
106787: PPUSH
106788: PPUSH
106789: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106790: LD_ADDR_VAR 0 2
106794: PUSH
106795: LD_INT 21
106797: PUSH
106798: LD_INT 1
106800: PUSH
106801: EMPTY
106802: LIST
106803: LIST
106804: PPUSH
106805: CALL_OW 69
106809: PUSH
106810: FOR_IN
106811: IFFALSE 106863
// if IsSelected ( i ) then
106813: LD_VAR 0 2
106817: PPUSH
106818: CALL_OW 306
106822: IFFALSE 106861
// begin for j := 1 to 4 do
106824: LD_ADDR_VAR 0 3
106828: PUSH
106829: DOUBLE
106830: LD_INT 1
106832: DEC
106833: ST_TO_ADDR
106834: LD_INT 4
106836: PUSH
106837: FOR_TO
106838: IFFALSE 106859
// SetSkill ( i , j , 10 ) ;
106840: LD_VAR 0 2
106844: PPUSH
106845: LD_VAR 0 3
106849: PPUSH
106850: LD_INT 10
106852: PPUSH
106853: CALL_OW 237
106857: GO 106837
106859: POP
106860: POP
// end ;
106861: GO 106810
106863: POP
106864: POP
// end ;
106865: LD_VAR 0 1
106869: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
106870: LD_INT 0
106872: PPUSH
106873: PPUSH
106874: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
106875: LD_ADDR_VAR 0 2
106879: PUSH
106880: LD_INT 22
106882: PUSH
106883: LD_OWVAR 2
106887: PUSH
106888: EMPTY
106889: LIST
106890: LIST
106891: PUSH
106892: LD_INT 21
106894: PUSH
106895: LD_INT 1
106897: PUSH
106898: EMPTY
106899: LIST
106900: LIST
106901: PUSH
106902: EMPTY
106903: LIST
106904: LIST
106905: PPUSH
106906: CALL_OW 69
106910: PUSH
106911: FOR_IN
106912: IFFALSE 106953
// begin for j := 1 to 4 do
106914: LD_ADDR_VAR 0 3
106918: PUSH
106919: DOUBLE
106920: LD_INT 1
106922: DEC
106923: ST_TO_ADDR
106924: LD_INT 4
106926: PUSH
106927: FOR_TO
106928: IFFALSE 106949
// SetSkill ( i , j , 10 ) ;
106930: LD_VAR 0 2
106934: PPUSH
106935: LD_VAR 0 3
106939: PPUSH
106940: LD_INT 10
106942: PPUSH
106943: CALL_OW 237
106947: GO 106927
106949: POP
106950: POP
// end ;
106951: GO 106911
106953: POP
106954: POP
// end ;
106955: LD_VAR 0 1
106959: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
106960: LD_INT 0
106962: PPUSH
// uc_side := your_side ;
106963: LD_ADDR_OWVAR 20
106967: PUSH
106968: LD_OWVAR 2
106972: ST_TO_ADDR
// uc_nation := nation ;
106973: LD_ADDR_OWVAR 21
106977: PUSH
106978: LD_VAR 0 1
106982: ST_TO_ADDR
// InitHc ;
106983: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
106987: LD_INT 0
106989: PPUSH
106990: LD_VAR 0 2
106994: PPUSH
106995: LD_VAR 0 3
106999: PPUSH
107000: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
107004: LD_VAR 0 4
107008: PPUSH
107009: LD_VAR 0 5
107013: PPUSH
107014: CALL_OW 428
107018: PUSH
107019: LD_INT 0
107021: EQUAL
107022: IFFALSE 107046
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
107024: CALL_OW 44
107028: PPUSH
107029: LD_VAR 0 4
107033: PPUSH
107034: LD_VAR 0 5
107038: PPUSH
107039: LD_INT 1
107041: PPUSH
107042: CALL_OW 48
// end ;
107046: LD_VAR 0 6
107050: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
107051: LD_INT 0
107053: PPUSH
107054: PPUSH
// uc_side := your_side ;
107055: LD_ADDR_OWVAR 20
107059: PUSH
107060: LD_OWVAR 2
107064: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
107065: LD_VAR 0 1
107069: PUSH
107070: LD_INT 1
107072: PUSH
107073: LD_INT 2
107075: PUSH
107076: LD_INT 3
107078: PUSH
107079: LD_INT 4
107081: PUSH
107082: LD_INT 5
107084: PUSH
107085: EMPTY
107086: LIST
107087: LIST
107088: LIST
107089: LIST
107090: LIST
107091: IN
107092: IFFALSE 107104
// uc_nation := nation_american else
107094: LD_ADDR_OWVAR 21
107098: PUSH
107099: LD_INT 1
107101: ST_TO_ADDR
107102: GO 107147
// if chassis in [ 11 , 12 , 13 , 14 ] then
107104: LD_VAR 0 1
107108: PUSH
107109: LD_INT 11
107111: PUSH
107112: LD_INT 12
107114: PUSH
107115: LD_INT 13
107117: PUSH
107118: LD_INT 14
107120: PUSH
107121: EMPTY
107122: LIST
107123: LIST
107124: LIST
107125: LIST
107126: IN
107127: IFFALSE 107139
// uc_nation := nation_arabian else
107129: LD_ADDR_OWVAR 21
107133: PUSH
107134: LD_INT 2
107136: ST_TO_ADDR
107137: GO 107147
// uc_nation := nation_russian ;
107139: LD_ADDR_OWVAR 21
107143: PUSH
107144: LD_INT 3
107146: ST_TO_ADDR
// vc_chassis := chassis ;
107147: LD_ADDR_OWVAR 37
107151: PUSH
107152: LD_VAR 0 1
107156: ST_TO_ADDR
// vc_engine := engine ;
107157: LD_ADDR_OWVAR 39
107161: PUSH
107162: LD_VAR 0 2
107166: ST_TO_ADDR
// vc_control := control ;
107167: LD_ADDR_OWVAR 38
107171: PUSH
107172: LD_VAR 0 3
107176: ST_TO_ADDR
// vc_weapon := weapon ;
107177: LD_ADDR_OWVAR 40
107181: PUSH
107182: LD_VAR 0 4
107186: ST_TO_ADDR
// un := CreateVehicle ;
107187: LD_ADDR_VAR 0 8
107191: PUSH
107192: CALL_OW 45
107196: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107197: LD_VAR 0 8
107201: PPUSH
107202: LD_INT 0
107204: PPUSH
107205: LD_INT 5
107207: PPUSH
107208: CALL_OW 12
107212: PPUSH
107213: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107217: LD_VAR 0 8
107221: PPUSH
107222: LD_VAR 0 5
107226: PPUSH
107227: LD_VAR 0 6
107231: PPUSH
107232: LD_INT 1
107234: PPUSH
107235: CALL_OW 48
// end ;
107239: LD_VAR 0 7
107243: RET
// export hInvincible ; every 1 do
107244: GO 107246
107246: DISABLE
// hInvincible := [ ] ;
107247: LD_ADDR_EXP 178
107251: PUSH
107252: EMPTY
107253: ST_TO_ADDR
107254: END
// every 10 do var i ;
107255: GO 107257
107257: DISABLE
107258: LD_INT 0
107260: PPUSH
// begin enable ;
107261: ENABLE
// if not hInvincible then
107262: LD_EXP 178
107266: NOT
107267: IFFALSE 107271
// exit ;
107269: GO 107315
// for i in hInvincible do
107271: LD_ADDR_VAR 0 1
107275: PUSH
107276: LD_EXP 178
107280: PUSH
107281: FOR_IN
107282: IFFALSE 107313
// if GetLives ( i ) < 1000 then
107284: LD_VAR 0 1
107288: PPUSH
107289: CALL_OW 256
107293: PUSH
107294: LD_INT 1000
107296: LESS
107297: IFFALSE 107311
// SetLives ( i , 1000 ) ;
107299: LD_VAR 0 1
107303: PPUSH
107304: LD_INT 1000
107306: PPUSH
107307: CALL_OW 234
107311: GO 107281
107313: POP
107314: POP
// end ;
107315: PPOPN 1
107317: END
// export function hHackInvincible ; var i ; begin
107318: LD_INT 0
107320: PPUSH
107321: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107322: LD_ADDR_VAR 0 2
107326: PUSH
107327: LD_INT 2
107329: PUSH
107330: LD_INT 21
107332: PUSH
107333: LD_INT 1
107335: PUSH
107336: EMPTY
107337: LIST
107338: LIST
107339: PUSH
107340: LD_INT 21
107342: PUSH
107343: LD_INT 2
107345: PUSH
107346: EMPTY
107347: LIST
107348: LIST
107349: PUSH
107350: EMPTY
107351: LIST
107352: LIST
107353: LIST
107354: PPUSH
107355: CALL_OW 69
107359: PUSH
107360: FOR_IN
107361: IFFALSE 107422
// if IsSelected ( i ) then
107363: LD_VAR 0 2
107367: PPUSH
107368: CALL_OW 306
107372: IFFALSE 107420
// begin if i in hInvincible then
107374: LD_VAR 0 2
107378: PUSH
107379: LD_EXP 178
107383: IN
107384: IFFALSE 107404
// hInvincible := hInvincible diff i else
107386: LD_ADDR_EXP 178
107390: PUSH
107391: LD_EXP 178
107395: PUSH
107396: LD_VAR 0 2
107400: DIFF
107401: ST_TO_ADDR
107402: GO 107420
// hInvincible := hInvincible union i ;
107404: LD_ADDR_EXP 178
107408: PUSH
107409: LD_EXP 178
107413: PUSH
107414: LD_VAR 0 2
107418: UNION
107419: ST_TO_ADDR
// end ;
107420: GO 107360
107422: POP
107423: POP
// end ;
107424: LD_VAR 0 1
107428: RET
// export function hHackInvisible ; var i , j ; begin
107429: LD_INT 0
107431: PPUSH
107432: PPUSH
107433: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107434: LD_ADDR_VAR 0 2
107438: PUSH
107439: LD_INT 21
107441: PUSH
107442: LD_INT 1
107444: PUSH
107445: EMPTY
107446: LIST
107447: LIST
107448: PPUSH
107449: CALL_OW 69
107453: PUSH
107454: FOR_IN
107455: IFFALSE 107479
// if IsSelected ( i ) then
107457: LD_VAR 0 2
107461: PPUSH
107462: CALL_OW 306
107466: IFFALSE 107477
// ComForceInvisible ( i ) ;
107468: LD_VAR 0 2
107472: PPUSH
107473: CALL_OW 496
107477: GO 107454
107479: POP
107480: POP
// end ;
107481: LD_VAR 0 1
107485: RET
// export function hHackChangeYourSide ; begin
107486: LD_INT 0
107488: PPUSH
// if your_side = 8 then
107489: LD_OWVAR 2
107493: PUSH
107494: LD_INT 8
107496: EQUAL
107497: IFFALSE 107509
// your_side := 0 else
107499: LD_ADDR_OWVAR 2
107503: PUSH
107504: LD_INT 0
107506: ST_TO_ADDR
107507: GO 107523
// your_side := your_side + 1 ;
107509: LD_ADDR_OWVAR 2
107513: PUSH
107514: LD_OWVAR 2
107518: PUSH
107519: LD_INT 1
107521: PLUS
107522: ST_TO_ADDR
// end ;
107523: LD_VAR 0 1
107527: RET
// export function hHackChangeUnitSide ; var i , j ; begin
107528: LD_INT 0
107530: PPUSH
107531: PPUSH
107532: PPUSH
// for i in all_units do
107533: LD_ADDR_VAR 0 2
107537: PUSH
107538: LD_OWVAR 3
107542: PUSH
107543: FOR_IN
107544: IFFALSE 107622
// if IsSelected ( i ) then
107546: LD_VAR 0 2
107550: PPUSH
107551: CALL_OW 306
107555: IFFALSE 107620
// begin j := GetSide ( i ) ;
107557: LD_ADDR_VAR 0 3
107561: PUSH
107562: LD_VAR 0 2
107566: PPUSH
107567: CALL_OW 255
107571: ST_TO_ADDR
// if j = 8 then
107572: LD_VAR 0 3
107576: PUSH
107577: LD_INT 8
107579: EQUAL
107580: IFFALSE 107592
// j := 0 else
107582: LD_ADDR_VAR 0 3
107586: PUSH
107587: LD_INT 0
107589: ST_TO_ADDR
107590: GO 107606
// j := j + 1 ;
107592: LD_ADDR_VAR 0 3
107596: PUSH
107597: LD_VAR 0 3
107601: PUSH
107602: LD_INT 1
107604: PLUS
107605: ST_TO_ADDR
// SetSide ( i , j ) ;
107606: LD_VAR 0 2
107610: PPUSH
107611: LD_VAR 0 3
107615: PPUSH
107616: CALL_OW 235
// end ;
107620: GO 107543
107622: POP
107623: POP
// end ;
107624: LD_VAR 0 1
107628: RET
// export function hHackFog ; begin
107629: LD_INT 0
107631: PPUSH
// FogOff ( true ) ;
107632: LD_INT 1
107634: PPUSH
107635: CALL_OW 344
// end ;
107639: LD_VAR 0 1
107643: RET
// export function hHackTeleport ( unit , x , y ) ; begin
107644: LD_INT 0
107646: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
107647: LD_VAR 0 1
107651: PPUSH
107652: LD_VAR 0 2
107656: PPUSH
107657: LD_VAR 0 3
107661: PPUSH
107662: LD_INT 1
107664: PPUSH
107665: LD_INT 1
107667: PPUSH
107668: CALL_OW 483
// CenterOnXY ( x , y ) ;
107672: LD_VAR 0 2
107676: PPUSH
107677: LD_VAR 0 3
107681: PPUSH
107682: CALL_OW 84
// end ;
107686: LD_VAR 0 4
107690: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
107691: LD_INT 0
107693: PPUSH
107694: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
107695: LD_VAR 0 1
107699: NOT
107700: PUSH
107701: LD_VAR 0 2
107705: PPUSH
107706: LD_VAR 0 3
107710: PPUSH
107711: CALL_OW 488
107715: NOT
107716: OR
107717: PUSH
107718: LD_VAR 0 1
107722: PPUSH
107723: CALL_OW 266
107727: PUSH
107728: LD_INT 3
107730: NONEQUAL
107731: PUSH
107732: LD_VAR 0 1
107736: PPUSH
107737: CALL_OW 247
107741: PUSH
107742: LD_INT 1
107744: EQUAL
107745: NOT
107746: AND
107747: OR
107748: IFFALSE 107752
// exit ;
107750: GO 107901
// if GetType ( factory ) = unit_human then
107752: LD_VAR 0 1
107756: PPUSH
107757: CALL_OW 247
107761: PUSH
107762: LD_INT 1
107764: EQUAL
107765: IFFALSE 107782
// factory := IsInUnit ( factory ) ;
107767: LD_ADDR_VAR 0 1
107771: PUSH
107772: LD_VAR 0 1
107776: PPUSH
107777: CALL_OW 310
107781: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
107782: LD_VAR 0 1
107786: PPUSH
107787: CALL_OW 266
107791: PUSH
107792: LD_INT 3
107794: NONEQUAL
107795: IFFALSE 107799
// exit ;
107797: GO 107901
// if HexInfo ( x , y ) = factory then
107799: LD_VAR 0 2
107803: PPUSH
107804: LD_VAR 0 3
107808: PPUSH
107809: CALL_OW 428
107813: PUSH
107814: LD_VAR 0 1
107818: EQUAL
107819: IFFALSE 107846
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
107821: LD_ADDR_EXP 179
107825: PUSH
107826: LD_EXP 179
107830: PPUSH
107831: LD_VAR 0 1
107835: PPUSH
107836: LD_INT 0
107838: PPUSH
107839: CALL_OW 1
107843: ST_TO_ADDR
107844: GO 107897
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
107846: LD_ADDR_EXP 179
107850: PUSH
107851: LD_EXP 179
107855: PPUSH
107856: LD_VAR 0 1
107860: PPUSH
107861: LD_VAR 0 1
107865: PPUSH
107866: CALL_OW 255
107870: PUSH
107871: LD_VAR 0 1
107875: PUSH
107876: LD_VAR 0 2
107880: PUSH
107881: LD_VAR 0 3
107885: PUSH
107886: EMPTY
107887: LIST
107888: LIST
107889: LIST
107890: LIST
107891: PPUSH
107892: CALL_OW 1
107896: ST_TO_ADDR
// UpdateFactoryWaypoints ;
107897: CALL 107906 0 0
// end ;
107901: LD_VAR 0 4
107905: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
107906: LD_INT 0
107908: PPUSH
107909: PPUSH
107910: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
107911: LD_STRING resetFactoryWaypoint();
107913: PPUSH
107914: CALL_OW 559
// if factoryWaypoints then
107918: LD_EXP 179
107922: IFFALSE 108048
// begin list := PrepareArray ( factoryWaypoints ) ;
107924: LD_ADDR_VAR 0 3
107928: PUSH
107929: LD_EXP 179
107933: PPUSH
107934: CALL 93158 0 1
107938: ST_TO_ADDR
// for i := 1 to list do
107939: LD_ADDR_VAR 0 2
107943: PUSH
107944: DOUBLE
107945: LD_INT 1
107947: DEC
107948: ST_TO_ADDR
107949: LD_VAR 0 3
107953: PUSH
107954: FOR_TO
107955: IFFALSE 108046
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107957: LD_STRING setFactoryWaypointXY(
107959: PUSH
107960: LD_VAR 0 3
107964: PUSH
107965: LD_VAR 0 2
107969: ARRAY
107970: PUSH
107971: LD_INT 1
107973: ARRAY
107974: STR
107975: PUSH
107976: LD_STRING ,
107978: STR
107979: PUSH
107980: LD_VAR 0 3
107984: PUSH
107985: LD_VAR 0 2
107989: ARRAY
107990: PUSH
107991: LD_INT 2
107993: ARRAY
107994: STR
107995: PUSH
107996: LD_STRING ,
107998: STR
107999: PUSH
108000: LD_VAR 0 3
108004: PUSH
108005: LD_VAR 0 2
108009: ARRAY
108010: PUSH
108011: LD_INT 3
108013: ARRAY
108014: STR
108015: PUSH
108016: LD_STRING ,
108018: STR
108019: PUSH
108020: LD_VAR 0 3
108024: PUSH
108025: LD_VAR 0 2
108029: ARRAY
108030: PUSH
108031: LD_INT 4
108033: ARRAY
108034: STR
108035: PUSH
108036: LD_STRING )
108038: STR
108039: PPUSH
108040: CALL_OW 559
108044: GO 107954
108046: POP
108047: POP
// end ; end ;
108048: LD_VAR 0 1
108052: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
108053: LD_INT 0
108055: PPUSH
// if HexInfo ( x , y ) = warehouse then
108056: LD_VAR 0 2
108060: PPUSH
108061: LD_VAR 0 3
108065: PPUSH
108066: CALL_OW 428
108070: PUSH
108071: LD_VAR 0 1
108075: EQUAL
108076: IFFALSE 108103
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
108078: LD_ADDR_EXP 180
108082: PUSH
108083: LD_EXP 180
108087: PPUSH
108088: LD_VAR 0 1
108092: PPUSH
108093: LD_INT 0
108095: PPUSH
108096: CALL_OW 1
108100: ST_TO_ADDR
108101: GO 108154
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
108103: LD_ADDR_EXP 180
108107: PUSH
108108: LD_EXP 180
108112: PPUSH
108113: LD_VAR 0 1
108117: PPUSH
108118: LD_VAR 0 1
108122: PPUSH
108123: CALL_OW 255
108127: PUSH
108128: LD_VAR 0 1
108132: PUSH
108133: LD_VAR 0 2
108137: PUSH
108138: LD_VAR 0 3
108142: PUSH
108143: EMPTY
108144: LIST
108145: LIST
108146: LIST
108147: LIST
108148: PPUSH
108149: CALL_OW 1
108153: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
108154: CALL 108163 0 0
// end ;
108158: LD_VAR 0 4
108162: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
108163: LD_INT 0
108165: PPUSH
108166: PPUSH
108167: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
108168: LD_STRING resetWarehouseGatheringPoints();
108170: PPUSH
108171: CALL_OW 559
// if warehouseGatheringPoints then
108175: LD_EXP 180
108179: IFFALSE 108305
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
108181: LD_ADDR_VAR 0 3
108185: PUSH
108186: LD_EXP 180
108190: PPUSH
108191: CALL 93158 0 1
108195: ST_TO_ADDR
// for i := 1 to list do
108196: LD_ADDR_VAR 0 2
108200: PUSH
108201: DOUBLE
108202: LD_INT 1
108204: DEC
108205: ST_TO_ADDR
108206: LD_VAR 0 3
108210: PUSH
108211: FOR_TO
108212: IFFALSE 108303
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108214: LD_STRING setWarehouseGatheringPointXY(
108216: PUSH
108217: LD_VAR 0 3
108221: PUSH
108222: LD_VAR 0 2
108226: ARRAY
108227: PUSH
108228: LD_INT 1
108230: ARRAY
108231: STR
108232: PUSH
108233: LD_STRING ,
108235: STR
108236: PUSH
108237: LD_VAR 0 3
108241: PUSH
108242: LD_VAR 0 2
108246: ARRAY
108247: PUSH
108248: LD_INT 2
108250: ARRAY
108251: STR
108252: PUSH
108253: LD_STRING ,
108255: STR
108256: PUSH
108257: LD_VAR 0 3
108261: PUSH
108262: LD_VAR 0 2
108266: ARRAY
108267: PUSH
108268: LD_INT 3
108270: ARRAY
108271: STR
108272: PUSH
108273: LD_STRING ,
108275: STR
108276: PUSH
108277: LD_VAR 0 3
108281: PUSH
108282: LD_VAR 0 2
108286: ARRAY
108287: PUSH
108288: LD_INT 4
108290: ARRAY
108291: STR
108292: PUSH
108293: LD_STRING )
108295: STR
108296: PPUSH
108297: CALL_OW 559
108301: GO 108211
108303: POP
108304: POP
// end ; end ;
108305: LD_VAR 0 1
108309: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
108310: LD_EXP 180
108314: IFFALSE 108999
108316: GO 108318
108318: DISABLE
108319: LD_INT 0
108321: PPUSH
108322: PPUSH
108323: PPUSH
108324: PPUSH
108325: PPUSH
108326: PPUSH
108327: PPUSH
108328: PPUSH
108329: PPUSH
// begin enable ;
108330: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108331: LD_ADDR_VAR 0 3
108335: PUSH
108336: LD_EXP 180
108340: PPUSH
108341: CALL 93158 0 1
108345: ST_TO_ADDR
// if not list then
108346: LD_VAR 0 3
108350: NOT
108351: IFFALSE 108355
// exit ;
108353: GO 108999
// for i := 1 to list do
108355: LD_ADDR_VAR 0 1
108359: PUSH
108360: DOUBLE
108361: LD_INT 1
108363: DEC
108364: ST_TO_ADDR
108365: LD_VAR 0 3
108369: PUSH
108370: FOR_TO
108371: IFFALSE 108997
// begin depot := list [ i ] [ 2 ] ;
108373: LD_ADDR_VAR 0 8
108377: PUSH
108378: LD_VAR 0 3
108382: PUSH
108383: LD_VAR 0 1
108387: ARRAY
108388: PUSH
108389: LD_INT 2
108391: ARRAY
108392: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
108393: LD_ADDR_VAR 0 5
108397: PUSH
108398: LD_VAR 0 3
108402: PUSH
108403: LD_VAR 0 1
108407: ARRAY
108408: PUSH
108409: LD_INT 1
108411: ARRAY
108412: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
108413: LD_VAR 0 8
108417: PPUSH
108418: CALL_OW 301
108422: PUSH
108423: LD_VAR 0 5
108427: PUSH
108428: LD_VAR 0 8
108432: PPUSH
108433: CALL_OW 255
108437: NONEQUAL
108438: OR
108439: IFFALSE 108468
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
108441: LD_ADDR_EXP 180
108445: PUSH
108446: LD_EXP 180
108450: PPUSH
108451: LD_VAR 0 8
108455: PPUSH
108456: LD_INT 0
108458: PPUSH
108459: CALL_OW 1
108463: ST_TO_ADDR
// exit ;
108464: POP
108465: POP
108466: GO 108999
// end ; x := list [ i ] [ 3 ] ;
108468: LD_ADDR_VAR 0 6
108472: PUSH
108473: LD_VAR 0 3
108477: PUSH
108478: LD_VAR 0 1
108482: ARRAY
108483: PUSH
108484: LD_INT 3
108486: ARRAY
108487: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
108488: LD_ADDR_VAR 0 7
108492: PUSH
108493: LD_VAR 0 3
108497: PUSH
108498: LD_VAR 0 1
108502: ARRAY
108503: PUSH
108504: LD_INT 4
108506: ARRAY
108507: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
108508: LD_ADDR_VAR 0 9
108512: PUSH
108513: LD_VAR 0 6
108517: PPUSH
108518: LD_VAR 0 7
108522: PPUSH
108523: LD_INT 16
108525: PPUSH
108526: CALL 91746 0 3
108530: ST_TO_ADDR
// if not cratesNearbyPoint then
108531: LD_VAR 0 9
108535: NOT
108536: IFFALSE 108542
// exit ;
108538: POP
108539: POP
108540: GO 108999
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
108542: LD_ADDR_VAR 0 4
108546: PUSH
108547: LD_INT 22
108549: PUSH
108550: LD_VAR 0 5
108554: PUSH
108555: EMPTY
108556: LIST
108557: LIST
108558: PUSH
108559: LD_INT 3
108561: PUSH
108562: LD_INT 60
108564: PUSH
108565: EMPTY
108566: LIST
108567: PUSH
108568: EMPTY
108569: LIST
108570: LIST
108571: PUSH
108572: LD_INT 91
108574: PUSH
108575: LD_VAR 0 8
108579: PUSH
108580: LD_INT 6
108582: PUSH
108583: EMPTY
108584: LIST
108585: LIST
108586: LIST
108587: PUSH
108588: LD_INT 2
108590: PUSH
108591: LD_INT 25
108593: PUSH
108594: LD_INT 2
108596: PUSH
108597: EMPTY
108598: LIST
108599: LIST
108600: PUSH
108601: LD_INT 25
108603: PUSH
108604: LD_INT 16
108606: PUSH
108607: EMPTY
108608: LIST
108609: LIST
108610: PUSH
108611: EMPTY
108612: LIST
108613: LIST
108614: LIST
108615: PUSH
108616: EMPTY
108617: LIST
108618: LIST
108619: LIST
108620: LIST
108621: PPUSH
108622: CALL_OW 69
108626: PUSH
108627: LD_VAR 0 8
108631: PPUSH
108632: CALL_OW 313
108636: PPUSH
108637: LD_INT 3
108639: PUSH
108640: LD_INT 60
108642: PUSH
108643: EMPTY
108644: LIST
108645: PUSH
108646: EMPTY
108647: LIST
108648: LIST
108649: PUSH
108650: LD_INT 2
108652: PUSH
108653: LD_INT 25
108655: PUSH
108656: LD_INT 2
108658: PUSH
108659: EMPTY
108660: LIST
108661: LIST
108662: PUSH
108663: LD_INT 25
108665: PUSH
108666: LD_INT 16
108668: PUSH
108669: EMPTY
108670: LIST
108671: LIST
108672: PUSH
108673: EMPTY
108674: LIST
108675: LIST
108676: LIST
108677: PUSH
108678: EMPTY
108679: LIST
108680: LIST
108681: PPUSH
108682: CALL_OW 72
108686: UNION
108687: ST_TO_ADDR
// if tmp then
108688: LD_VAR 0 4
108692: IFFALSE 108772
// begin tmp := ShrinkArray ( tmp , 3 ) ;
108694: LD_ADDR_VAR 0 4
108698: PUSH
108699: LD_VAR 0 4
108703: PPUSH
108704: LD_INT 3
108706: PPUSH
108707: CALL 89715 0 2
108711: ST_TO_ADDR
// for j in tmp do
108712: LD_ADDR_VAR 0 2
108716: PUSH
108717: LD_VAR 0 4
108721: PUSH
108722: FOR_IN
108723: IFFALSE 108766
// begin if IsInUnit ( j ) then
108725: LD_VAR 0 2
108729: PPUSH
108730: CALL_OW 310
108734: IFFALSE 108745
// ComExit ( j ) ;
108736: LD_VAR 0 2
108740: PPUSH
108741: CALL 89798 0 1
// AddComCollect ( j , x , y ) ;
108745: LD_VAR 0 2
108749: PPUSH
108750: LD_VAR 0 6
108754: PPUSH
108755: LD_VAR 0 7
108759: PPUSH
108760: CALL_OW 177
// end ;
108764: GO 108722
108766: POP
108767: POP
// exit ;
108768: POP
108769: POP
108770: GO 108999
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
108772: LD_ADDR_VAR 0 4
108776: PUSH
108777: LD_INT 22
108779: PUSH
108780: LD_VAR 0 5
108784: PUSH
108785: EMPTY
108786: LIST
108787: LIST
108788: PUSH
108789: LD_INT 91
108791: PUSH
108792: LD_VAR 0 8
108796: PUSH
108797: LD_INT 8
108799: PUSH
108800: EMPTY
108801: LIST
108802: LIST
108803: LIST
108804: PUSH
108805: LD_INT 2
108807: PUSH
108808: LD_INT 34
108810: PUSH
108811: LD_INT 12
108813: PUSH
108814: EMPTY
108815: LIST
108816: LIST
108817: PUSH
108818: LD_INT 34
108820: PUSH
108821: LD_INT 51
108823: PUSH
108824: EMPTY
108825: LIST
108826: LIST
108827: PUSH
108828: LD_INT 34
108830: PUSH
108831: LD_INT 32
108833: PUSH
108834: EMPTY
108835: LIST
108836: LIST
108837: PUSH
108838: LD_INT 34
108840: PUSH
108841: LD_INT 89
108843: PUSH
108844: EMPTY
108845: LIST
108846: LIST
108847: PUSH
108848: EMPTY
108849: LIST
108850: LIST
108851: LIST
108852: LIST
108853: LIST
108854: PUSH
108855: EMPTY
108856: LIST
108857: LIST
108858: LIST
108859: PPUSH
108860: CALL_OW 69
108864: ST_TO_ADDR
// if tmp then
108865: LD_VAR 0 4
108869: IFFALSE 108995
// begin for j in tmp do
108871: LD_ADDR_VAR 0 2
108875: PUSH
108876: LD_VAR 0 4
108880: PUSH
108881: FOR_IN
108882: IFFALSE 108993
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
108884: LD_VAR 0 2
108888: PPUSH
108889: CALL_OW 262
108893: PUSH
108894: LD_INT 3
108896: EQUAL
108897: PUSH
108898: LD_VAR 0 2
108902: PPUSH
108903: CALL_OW 261
108907: PUSH
108908: LD_INT 20
108910: GREATER
108911: OR
108912: PUSH
108913: LD_VAR 0 2
108917: PPUSH
108918: CALL_OW 314
108922: NOT
108923: AND
108924: PUSH
108925: LD_VAR 0 2
108929: PPUSH
108930: CALL_OW 263
108934: PUSH
108935: LD_INT 1
108937: NONEQUAL
108938: PUSH
108939: LD_VAR 0 2
108943: PPUSH
108944: CALL_OW 311
108948: OR
108949: AND
108950: IFFALSE 108991
// begin ComCollect ( j , x , y ) ;
108952: LD_VAR 0 2
108956: PPUSH
108957: LD_VAR 0 6
108961: PPUSH
108962: LD_VAR 0 7
108966: PPUSH
108967: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
108971: LD_VAR 0 2
108975: PPUSH
108976: LD_VAR 0 8
108980: PPUSH
108981: CALL_OW 172
// exit ;
108985: POP
108986: POP
108987: POP
108988: POP
108989: GO 108999
// end ;
108991: GO 108881
108993: POP
108994: POP
// end ; end ;
108995: GO 108370
108997: POP
108998: POP
// end ; end_of_file
108999: PPOPN 9
109001: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
109002: LD_INT 0
109004: PPUSH
109005: PPUSH
109006: PPUSH
109007: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
109008: LD_VAR 0 1
109012: PPUSH
109013: CALL_OW 264
109017: PUSH
109018: LD_INT 91
109020: EQUAL
109021: IFFALSE 109093
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
109023: LD_INT 68
109025: PPUSH
109026: LD_VAR 0 1
109030: PPUSH
109031: CALL_OW 255
109035: PPUSH
109036: CALL_OW 321
109040: PUSH
109041: LD_INT 2
109043: EQUAL
109044: IFFALSE 109056
// eff := 70 else
109046: LD_ADDR_VAR 0 4
109050: PUSH
109051: LD_INT 70
109053: ST_TO_ADDR
109054: GO 109064
// eff := 30 ;
109056: LD_ADDR_VAR 0 4
109060: PUSH
109061: LD_INT 30
109063: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
109064: LD_VAR 0 1
109068: PPUSH
109069: CALL_OW 250
109073: PPUSH
109074: LD_VAR 0 1
109078: PPUSH
109079: CALL_OW 251
109083: PPUSH
109084: LD_VAR 0 4
109088: PPUSH
109089: CALL_OW 495
// end ; end ;
109093: LD_VAR 0 2
109097: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
109098: LD_INT 0
109100: PPUSH
// end ;
109101: LD_VAR 0 4
109105: RET
// export function SOS_Command ( cmd ) ; begin
109106: LD_INT 0
109108: PPUSH
// end ;
109109: LD_VAR 0 2
109113: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
109114: LD_INT 0
109116: PPUSH
// end ;
109117: LD_VAR 0 6
109121: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
109122: LD_INT 0
109124: PPUSH
109125: PPUSH
// if not vehicle or not factory then
109126: LD_VAR 0 1
109130: NOT
109131: PUSH
109132: LD_VAR 0 2
109136: NOT
109137: OR
109138: IFFALSE 109142
// exit ;
109140: GO 109373
// if factoryWaypoints >= factory then
109142: LD_EXP 179
109146: PUSH
109147: LD_VAR 0 2
109151: GREATEREQUAL
109152: IFFALSE 109373
// if factoryWaypoints [ factory ] then
109154: LD_EXP 179
109158: PUSH
109159: LD_VAR 0 2
109163: ARRAY
109164: IFFALSE 109373
// begin if GetControl ( vehicle ) = control_manual then
109166: LD_VAR 0 1
109170: PPUSH
109171: CALL_OW 263
109175: PUSH
109176: LD_INT 1
109178: EQUAL
109179: IFFALSE 109260
// begin driver := IsDrivenBy ( vehicle ) ;
109181: LD_ADDR_VAR 0 4
109185: PUSH
109186: LD_VAR 0 1
109190: PPUSH
109191: CALL_OW 311
109195: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109196: LD_VAR 0 4
109200: PPUSH
109201: LD_EXP 179
109205: PUSH
109206: LD_VAR 0 2
109210: ARRAY
109211: PUSH
109212: LD_INT 3
109214: ARRAY
109215: PPUSH
109216: LD_EXP 179
109220: PUSH
109221: LD_VAR 0 2
109225: ARRAY
109226: PUSH
109227: LD_INT 4
109229: ARRAY
109230: PPUSH
109231: CALL_OW 171
// AddComExitVehicle ( driver ) ;
109235: LD_VAR 0 4
109239: PPUSH
109240: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
109244: LD_VAR 0 4
109248: PPUSH
109249: LD_VAR 0 2
109253: PPUSH
109254: CALL_OW 180
// end else
109258: GO 109373
// if GetControl ( vehicle ) = control_remote then
109260: LD_VAR 0 1
109264: PPUSH
109265: CALL_OW 263
109269: PUSH
109270: LD_INT 2
109272: EQUAL
109273: IFFALSE 109334
// begin wait ( 0 0$2 ) ;
109275: LD_INT 70
109277: PPUSH
109278: CALL_OW 67
// if Connect ( vehicle ) then
109282: LD_VAR 0 1
109286: PPUSH
109287: CALL 60057 0 1
109291: IFFALSE 109332
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109293: LD_VAR 0 1
109297: PPUSH
109298: LD_EXP 179
109302: PUSH
109303: LD_VAR 0 2
109307: ARRAY
109308: PUSH
109309: LD_INT 3
109311: ARRAY
109312: PPUSH
109313: LD_EXP 179
109317: PUSH
109318: LD_VAR 0 2
109322: ARRAY
109323: PUSH
109324: LD_INT 4
109326: ARRAY
109327: PPUSH
109328: CALL_OW 171
// end else
109332: GO 109373
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109334: LD_VAR 0 1
109338: PPUSH
109339: LD_EXP 179
109343: PUSH
109344: LD_VAR 0 2
109348: ARRAY
109349: PUSH
109350: LD_INT 3
109352: ARRAY
109353: PPUSH
109354: LD_EXP 179
109358: PUSH
109359: LD_VAR 0 2
109363: ARRAY
109364: PUSH
109365: LD_INT 4
109367: ARRAY
109368: PPUSH
109369: CALL_OW 171
// end ; end ;
109373: LD_VAR 0 3
109377: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
109378: LD_INT 0
109380: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
109381: LD_VAR 0 1
109385: PUSH
109386: LD_INT 250
109388: EQUAL
109389: PUSH
109390: LD_VAR 0 2
109394: PPUSH
109395: CALL_OW 264
109399: PUSH
109400: LD_INT 81
109402: EQUAL
109403: AND
109404: IFFALSE 109425
// MinerPlaceMine ( unit , x , y ) ;
109406: LD_VAR 0 2
109410: PPUSH
109411: LD_VAR 0 4
109415: PPUSH
109416: LD_VAR 0 5
109420: PPUSH
109421: CALL 111810 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
109425: LD_VAR 0 1
109429: PUSH
109430: LD_INT 251
109432: EQUAL
109433: PUSH
109434: LD_VAR 0 2
109438: PPUSH
109439: CALL_OW 264
109443: PUSH
109444: LD_INT 81
109446: EQUAL
109447: AND
109448: IFFALSE 109469
// MinerDetonateMine ( unit , x , y ) ;
109450: LD_VAR 0 2
109454: PPUSH
109455: LD_VAR 0 4
109459: PPUSH
109460: LD_VAR 0 5
109464: PPUSH
109465: CALL 112085 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
109469: LD_VAR 0 1
109473: PUSH
109474: LD_INT 252
109476: EQUAL
109477: PUSH
109478: LD_VAR 0 2
109482: PPUSH
109483: CALL_OW 264
109487: PUSH
109488: LD_INT 81
109490: EQUAL
109491: AND
109492: IFFALSE 109513
// MinerCreateMinefield ( unit , x , y ) ;
109494: LD_VAR 0 2
109498: PPUSH
109499: LD_VAR 0 4
109503: PPUSH
109504: LD_VAR 0 5
109508: PPUSH
109509: CALL 112502 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
109513: LD_VAR 0 1
109517: PUSH
109518: LD_INT 253
109520: EQUAL
109521: PUSH
109522: LD_VAR 0 2
109526: PPUSH
109527: CALL_OW 257
109531: PUSH
109532: LD_INT 5
109534: EQUAL
109535: AND
109536: IFFALSE 109557
// ComBinocular ( unit , x , y ) ;
109538: LD_VAR 0 2
109542: PPUSH
109543: LD_VAR 0 4
109547: PPUSH
109548: LD_VAR 0 5
109552: PPUSH
109553: CALL 112871 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
109557: LD_VAR 0 1
109561: PUSH
109562: LD_INT 254
109564: EQUAL
109565: PUSH
109566: LD_VAR 0 2
109570: PPUSH
109571: CALL_OW 264
109575: PUSH
109576: LD_INT 99
109578: EQUAL
109579: AND
109580: PUSH
109581: LD_VAR 0 3
109585: PPUSH
109586: CALL_OW 263
109590: PUSH
109591: LD_INT 3
109593: EQUAL
109594: AND
109595: IFFALSE 109611
// HackDestroyVehicle ( unit , selectedUnit ) ;
109597: LD_VAR 0 2
109601: PPUSH
109602: LD_VAR 0 3
109606: PPUSH
109607: CALL 111174 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
109611: LD_VAR 0 1
109615: PUSH
109616: LD_INT 255
109618: EQUAL
109619: PUSH
109620: LD_VAR 0 2
109624: PPUSH
109625: CALL_OW 264
109629: PUSH
109630: LD_INT 14
109632: PUSH
109633: LD_INT 53
109635: PUSH
109636: EMPTY
109637: LIST
109638: LIST
109639: IN
109640: AND
109641: PUSH
109642: LD_VAR 0 4
109646: PPUSH
109647: LD_VAR 0 5
109651: PPUSH
109652: CALL_OW 488
109656: AND
109657: IFFALSE 109681
// CutTreeXYR ( unit , x , y , 12 ) ;
109659: LD_VAR 0 2
109663: PPUSH
109664: LD_VAR 0 4
109668: PPUSH
109669: LD_VAR 0 5
109673: PPUSH
109674: LD_INT 12
109676: PPUSH
109677: CALL 109744 0 4
// if cmd = 256 then
109681: LD_VAR 0 1
109685: PUSH
109686: LD_INT 256
109688: EQUAL
109689: IFFALSE 109710
// SetFactoryWaypoint ( unit , x , y ) ;
109691: LD_VAR 0 2
109695: PPUSH
109696: LD_VAR 0 4
109700: PPUSH
109701: LD_VAR 0 5
109705: PPUSH
109706: CALL 107691 0 3
// if cmd = 257 then
109710: LD_VAR 0 1
109714: PUSH
109715: LD_INT 257
109717: EQUAL
109718: IFFALSE 109739
// SetWarehouseGatheringPoint ( unit , x , y ) ;
109720: LD_VAR 0 2
109724: PPUSH
109725: LD_VAR 0 4
109729: PPUSH
109730: LD_VAR 0 5
109734: PPUSH
109735: CALL 108053 0 3
// end ;
109739: LD_VAR 0 6
109743: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
109744: LD_INT 0
109746: PPUSH
109747: PPUSH
109748: PPUSH
109749: PPUSH
109750: PPUSH
109751: PPUSH
109752: PPUSH
109753: PPUSH
109754: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
109755: LD_VAR 0 1
109759: NOT
109760: PUSH
109761: LD_VAR 0 2
109765: PPUSH
109766: LD_VAR 0 3
109770: PPUSH
109771: CALL_OW 488
109775: NOT
109776: OR
109777: PUSH
109778: LD_VAR 0 4
109782: NOT
109783: OR
109784: IFFALSE 109788
// exit ;
109786: GO 110128
// list := [ ] ;
109788: LD_ADDR_VAR 0 13
109792: PUSH
109793: EMPTY
109794: ST_TO_ADDR
// if x - r < 0 then
109795: LD_VAR 0 2
109799: PUSH
109800: LD_VAR 0 4
109804: MINUS
109805: PUSH
109806: LD_INT 0
109808: LESS
109809: IFFALSE 109821
// min_x := 0 else
109811: LD_ADDR_VAR 0 7
109815: PUSH
109816: LD_INT 0
109818: ST_TO_ADDR
109819: GO 109837
// min_x := x - r ;
109821: LD_ADDR_VAR 0 7
109825: PUSH
109826: LD_VAR 0 2
109830: PUSH
109831: LD_VAR 0 4
109835: MINUS
109836: ST_TO_ADDR
// if y - r < 0 then
109837: LD_VAR 0 3
109841: PUSH
109842: LD_VAR 0 4
109846: MINUS
109847: PUSH
109848: LD_INT 0
109850: LESS
109851: IFFALSE 109863
// min_y := 0 else
109853: LD_ADDR_VAR 0 8
109857: PUSH
109858: LD_INT 0
109860: ST_TO_ADDR
109861: GO 109879
// min_y := y - r ;
109863: LD_ADDR_VAR 0 8
109867: PUSH
109868: LD_VAR 0 3
109872: PUSH
109873: LD_VAR 0 4
109877: MINUS
109878: ST_TO_ADDR
// max_x := x + r ;
109879: LD_ADDR_VAR 0 9
109883: PUSH
109884: LD_VAR 0 2
109888: PUSH
109889: LD_VAR 0 4
109893: PLUS
109894: ST_TO_ADDR
// max_y := y + r ;
109895: LD_ADDR_VAR 0 10
109899: PUSH
109900: LD_VAR 0 3
109904: PUSH
109905: LD_VAR 0 4
109909: PLUS
109910: ST_TO_ADDR
// for _x = min_x to max_x do
109911: LD_ADDR_VAR 0 11
109915: PUSH
109916: DOUBLE
109917: LD_VAR 0 7
109921: DEC
109922: ST_TO_ADDR
109923: LD_VAR 0 9
109927: PUSH
109928: FOR_TO
109929: IFFALSE 110046
// for _y = min_y to max_y do
109931: LD_ADDR_VAR 0 12
109935: PUSH
109936: DOUBLE
109937: LD_VAR 0 8
109941: DEC
109942: ST_TO_ADDR
109943: LD_VAR 0 10
109947: PUSH
109948: FOR_TO
109949: IFFALSE 110042
// begin if not ValidHex ( _x , _y ) then
109951: LD_VAR 0 11
109955: PPUSH
109956: LD_VAR 0 12
109960: PPUSH
109961: CALL_OW 488
109965: NOT
109966: IFFALSE 109970
// continue ;
109968: GO 109948
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109970: LD_VAR 0 11
109974: PPUSH
109975: LD_VAR 0 12
109979: PPUSH
109980: CALL_OW 351
109984: PUSH
109985: LD_VAR 0 11
109989: PPUSH
109990: LD_VAR 0 12
109994: PPUSH
109995: CALL_OW 554
109999: AND
110000: IFFALSE 110040
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
110002: LD_ADDR_VAR 0 13
110006: PUSH
110007: LD_VAR 0 13
110011: PPUSH
110012: LD_VAR 0 13
110016: PUSH
110017: LD_INT 1
110019: PLUS
110020: PPUSH
110021: LD_VAR 0 11
110025: PUSH
110026: LD_VAR 0 12
110030: PUSH
110031: EMPTY
110032: LIST
110033: LIST
110034: PPUSH
110035: CALL_OW 2
110039: ST_TO_ADDR
// end ;
110040: GO 109948
110042: POP
110043: POP
110044: GO 109928
110046: POP
110047: POP
// if not list then
110048: LD_VAR 0 13
110052: NOT
110053: IFFALSE 110057
// exit ;
110055: GO 110128
// for i in list do
110057: LD_ADDR_VAR 0 6
110061: PUSH
110062: LD_VAR 0 13
110066: PUSH
110067: FOR_IN
110068: IFFALSE 110126
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
110070: LD_VAR 0 1
110074: PPUSH
110075: LD_STRING M
110077: PUSH
110078: LD_VAR 0 6
110082: PUSH
110083: LD_INT 1
110085: ARRAY
110086: PUSH
110087: LD_VAR 0 6
110091: PUSH
110092: LD_INT 2
110094: ARRAY
110095: PUSH
110096: LD_INT 0
110098: PUSH
110099: LD_INT 0
110101: PUSH
110102: LD_INT 0
110104: PUSH
110105: LD_INT 0
110107: PUSH
110108: EMPTY
110109: LIST
110110: LIST
110111: LIST
110112: LIST
110113: LIST
110114: LIST
110115: LIST
110116: PUSH
110117: EMPTY
110118: LIST
110119: PPUSH
110120: CALL_OW 447
110124: GO 110067
110126: POP
110127: POP
// end ;
110128: LD_VAR 0 5
110132: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
110133: LD_EXP 182
110137: NOT
110138: IFFALSE 110188
110140: GO 110142
110142: DISABLE
// begin initHack := true ;
110143: LD_ADDR_EXP 182
110147: PUSH
110148: LD_INT 1
110150: ST_TO_ADDR
// hackTanks := [ ] ;
110151: LD_ADDR_EXP 183
110155: PUSH
110156: EMPTY
110157: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
110158: LD_ADDR_EXP 184
110162: PUSH
110163: EMPTY
110164: ST_TO_ADDR
// hackLimit := 3 ;
110165: LD_ADDR_EXP 185
110169: PUSH
110170: LD_INT 3
110172: ST_TO_ADDR
// hackDist := 12 ;
110173: LD_ADDR_EXP 186
110177: PUSH
110178: LD_INT 12
110180: ST_TO_ADDR
// hackCounter := [ ] ;
110181: LD_ADDR_EXP 187
110185: PUSH
110186: EMPTY
110187: ST_TO_ADDR
// end ;
110188: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
110189: LD_EXP 182
110193: PUSH
110194: LD_INT 34
110196: PUSH
110197: LD_INT 99
110199: PUSH
110200: EMPTY
110201: LIST
110202: LIST
110203: PPUSH
110204: CALL_OW 69
110208: AND
110209: IFFALSE 110462
110211: GO 110213
110213: DISABLE
110214: LD_INT 0
110216: PPUSH
110217: PPUSH
// begin enable ;
110218: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
110219: LD_ADDR_VAR 0 1
110223: PUSH
110224: LD_INT 34
110226: PUSH
110227: LD_INT 99
110229: PUSH
110230: EMPTY
110231: LIST
110232: LIST
110233: PPUSH
110234: CALL_OW 69
110238: PUSH
110239: FOR_IN
110240: IFFALSE 110460
// begin if not i in hackTanks then
110242: LD_VAR 0 1
110246: PUSH
110247: LD_EXP 183
110251: IN
110252: NOT
110253: IFFALSE 110336
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
110255: LD_ADDR_EXP 183
110259: PUSH
110260: LD_EXP 183
110264: PPUSH
110265: LD_EXP 183
110269: PUSH
110270: LD_INT 1
110272: PLUS
110273: PPUSH
110274: LD_VAR 0 1
110278: PPUSH
110279: CALL_OW 1
110283: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
110284: LD_ADDR_EXP 184
110288: PUSH
110289: LD_EXP 184
110293: PPUSH
110294: LD_EXP 184
110298: PUSH
110299: LD_INT 1
110301: PLUS
110302: PPUSH
110303: EMPTY
110304: PPUSH
110305: CALL_OW 1
110309: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
110310: LD_ADDR_EXP 187
110314: PUSH
110315: LD_EXP 187
110319: PPUSH
110320: LD_EXP 187
110324: PUSH
110325: LD_INT 1
110327: PLUS
110328: PPUSH
110329: EMPTY
110330: PPUSH
110331: CALL_OW 1
110335: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110336: LD_VAR 0 1
110340: PPUSH
110341: CALL_OW 302
110345: NOT
110346: IFFALSE 110359
// begin HackUnlinkAll ( i ) ;
110348: LD_VAR 0 1
110352: PPUSH
110353: CALL 110465 0 1
// continue ;
110357: GO 110239
// end ; HackCheckCapturedStatus ( i ) ;
110359: LD_VAR 0 1
110363: PPUSH
110364: CALL 110908 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110368: LD_ADDR_VAR 0 2
110372: PUSH
110373: LD_INT 81
110375: PUSH
110376: LD_VAR 0 1
110380: PPUSH
110381: CALL_OW 255
110385: PUSH
110386: EMPTY
110387: LIST
110388: LIST
110389: PUSH
110390: LD_INT 33
110392: PUSH
110393: LD_INT 3
110395: PUSH
110396: EMPTY
110397: LIST
110398: LIST
110399: PUSH
110400: LD_INT 91
110402: PUSH
110403: LD_VAR 0 1
110407: PUSH
110408: LD_EXP 186
110412: PUSH
110413: EMPTY
110414: LIST
110415: LIST
110416: LIST
110417: PUSH
110418: LD_INT 50
110420: PUSH
110421: EMPTY
110422: LIST
110423: PUSH
110424: EMPTY
110425: LIST
110426: LIST
110427: LIST
110428: LIST
110429: PPUSH
110430: CALL_OW 69
110434: ST_TO_ADDR
// if not tmp then
110435: LD_VAR 0 2
110439: NOT
110440: IFFALSE 110444
// continue ;
110442: GO 110239
// HackLink ( i , tmp ) ;
110444: LD_VAR 0 1
110448: PPUSH
110449: LD_VAR 0 2
110453: PPUSH
110454: CALL 110601 0 2
// end ;
110458: GO 110239
110460: POP
110461: POP
// end ;
110462: PPOPN 2
110464: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110465: LD_INT 0
110467: PPUSH
110468: PPUSH
110469: PPUSH
// if not hack in hackTanks then
110470: LD_VAR 0 1
110474: PUSH
110475: LD_EXP 183
110479: IN
110480: NOT
110481: IFFALSE 110485
// exit ;
110483: GO 110596
// index := GetElementIndex ( hackTanks , hack ) ;
110485: LD_ADDR_VAR 0 4
110489: PUSH
110490: LD_EXP 183
110494: PPUSH
110495: LD_VAR 0 1
110499: PPUSH
110500: CALL 56873 0 2
110504: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110505: LD_EXP 184
110509: PUSH
110510: LD_VAR 0 4
110514: ARRAY
110515: IFFALSE 110596
// begin for i in hackTanksCaptured [ index ] do
110517: LD_ADDR_VAR 0 3
110521: PUSH
110522: LD_EXP 184
110526: PUSH
110527: LD_VAR 0 4
110531: ARRAY
110532: PUSH
110533: FOR_IN
110534: IFFALSE 110560
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110536: LD_VAR 0 3
110540: PUSH
110541: LD_INT 1
110543: ARRAY
110544: PPUSH
110545: LD_VAR 0 3
110549: PUSH
110550: LD_INT 2
110552: ARRAY
110553: PPUSH
110554: CALL_OW 235
110558: GO 110533
110560: POP
110561: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110562: LD_ADDR_EXP 184
110566: PUSH
110567: LD_EXP 184
110571: PPUSH
110572: LD_VAR 0 4
110576: PPUSH
110577: EMPTY
110578: PPUSH
110579: CALL_OW 1
110583: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110584: LD_VAR 0 1
110588: PPUSH
110589: LD_INT 0
110591: PPUSH
110592: CALL_OW 505
// end ; end ;
110596: LD_VAR 0 2
110600: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110601: LD_INT 0
110603: PPUSH
110604: PPUSH
110605: PPUSH
// if not hack in hackTanks or not vehicles then
110606: LD_VAR 0 1
110610: PUSH
110611: LD_EXP 183
110615: IN
110616: NOT
110617: PUSH
110618: LD_VAR 0 2
110622: NOT
110623: OR
110624: IFFALSE 110628
// exit ;
110626: GO 110903
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110628: LD_ADDR_VAR 0 2
110632: PUSH
110633: LD_VAR 0 1
110637: PPUSH
110638: LD_VAR 0 2
110642: PPUSH
110643: LD_INT 1
110645: PPUSH
110646: LD_INT 1
110648: PPUSH
110649: CALL 57523 0 4
110653: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110654: LD_ADDR_VAR 0 5
110658: PUSH
110659: LD_EXP 183
110663: PPUSH
110664: LD_VAR 0 1
110668: PPUSH
110669: CALL 56873 0 2
110673: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110674: LD_EXP 184
110678: PUSH
110679: LD_VAR 0 5
110683: ARRAY
110684: PUSH
110685: LD_EXP 185
110689: LESS
110690: IFFALSE 110879
// begin for i := 1 to vehicles do
110692: LD_ADDR_VAR 0 4
110696: PUSH
110697: DOUBLE
110698: LD_INT 1
110700: DEC
110701: ST_TO_ADDR
110702: LD_VAR 0 2
110706: PUSH
110707: FOR_TO
110708: IFFALSE 110877
// begin if hackTanksCaptured [ index ] = hackLimit then
110710: LD_EXP 184
110714: PUSH
110715: LD_VAR 0 5
110719: ARRAY
110720: PUSH
110721: LD_EXP 185
110725: EQUAL
110726: IFFALSE 110730
// break ;
110728: GO 110877
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
110730: LD_ADDR_EXP 187
110734: PUSH
110735: LD_EXP 187
110739: PPUSH
110740: LD_VAR 0 5
110744: PPUSH
110745: LD_EXP 187
110749: PUSH
110750: LD_VAR 0 5
110754: ARRAY
110755: PUSH
110756: LD_INT 1
110758: PLUS
110759: PPUSH
110760: CALL_OW 1
110764: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
110765: LD_ADDR_EXP 184
110769: PUSH
110770: LD_EXP 184
110774: PPUSH
110775: LD_VAR 0 5
110779: PUSH
110780: LD_EXP 184
110784: PUSH
110785: LD_VAR 0 5
110789: ARRAY
110790: PUSH
110791: LD_INT 1
110793: PLUS
110794: PUSH
110795: EMPTY
110796: LIST
110797: LIST
110798: PPUSH
110799: LD_VAR 0 2
110803: PUSH
110804: LD_VAR 0 4
110808: ARRAY
110809: PUSH
110810: LD_VAR 0 2
110814: PUSH
110815: LD_VAR 0 4
110819: ARRAY
110820: PPUSH
110821: CALL_OW 255
110825: PUSH
110826: EMPTY
110827: LIST
110828: LIST
110829: PPUSH
110830: CALL 57088 0 3
110834: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
110835: LD_VAR 0 2
110839: PUSH
110840: LD_VAR 0 4
110844: ARRAY
110845: PPUSH
110846: LD_VAR 0 1
110850: PPUSH
110851: CALL_OW 255
110855: PPUSH
110856: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
110860: LD_VAR 0 2
110864: PUSH
110865: LD_VAR 0 4
110869: ARRAY
110870: PPUSH
110871: CALL_OW 141
// end ;
110875: GO 110707
110877: POP
110878: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110879: LD_VAR 0 1
110883: PPUSH
110884: LD_EXP 184
110888: PUSH
110889: LD_VAR 0 5
110893: ARRAY
110894: PUSH
110895: LD_INT 0
110897: PLUS
110898: PPUSH
110899: CALL_OW 505
// end ;
110903: LD_VAR 0 3
110907: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
110908: LD_INT 0
110910: PPUSH
110911: PPUSH
110912: PPUSH
110913: PPUSH
// if not hack in hackTanks then
110914: LD_VAR 0 1
110918: PUSH
110919: LD_EXP 183
110923: IN
110924: NOT
110925: IFFALSE 110929
// exit ;
110927: GO 111169
// index := GetElementIndex ( hackTanks , hack ) ;
110929: LD_ADDR_VAR 0 4
110933: PUSH
110934: LD_EXP 183
110938: PPUSH
110939: LD_VAR 0 1
110943: PPUSH
110944: CALL 56873 0 2
110948: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
110949: LD_ADDR_VAR 0 3
110953: PUSH
110954: DOUBLE
110955: LD_EXP 184
110959: PUSH
110960: LD_VAR 0 4
110964: ARRAY
110965: INC
110966: ST_TO_ADDR
110967: LD_INT 1
110969: PUSH
110970: FOR_DOWNTO
110971: IFFALSE 111143
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
110973: LD_ADDR_VAR 0 5
110977: PUSH
110978: LD_EXP 184
110982: PUSH
110983: LD_VAR 0 4
110987: ARRAY
110988: PUSH
110989: LD_VAR 0 3
110993: ARRAY
110994: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
110995: LD_VAR 0 5
110999: PUSH
111000: LD_INT 1
111002: ARRAY
111003: PPUSH
111004: CALL_OW 302
111008: NOT
111009: PUSH
111010: LD_VAR 0 5
111014: PUSH
111015: LD_INT 1
111017: ARRAY
111018: PPUSH
111019: CALL_OW 255
111023: PUSH
111024: LD_VAR 0 1
111028: PPUSH
111029: CALL_OW 255
111033: NONEQUAL
111034: OR
111035: IFFALSE 111141
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
111037: LD_VAR 0 5
111041: PUSH
111042: LD_INT 1
111044: ARRAY
111045: PPUSH
111046: CALL_OW 305
111050: PUSH
111051: LD_VAR 0 5
111055: PUSH
111056: LD_INT 1
111058: ARRAY
111059: PPUSH
111060: CALL_OW 255
111064: PUSH
111065: LD_VAR 0 1
111069: PPUSH
111070: CALL_OW 255
111074: EQUAL
111075: AND
111076: IFFALSE 111100
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
111078: LD_VAR 0 5
111082: PUSH
111083: LD_INT 1
111085: ARRAY
111086: PPUSH
111087: LD_VAR 0 5
111091: PUSH
111092: LD_INT 2
111094: ARRAY
111095: PPUSH
111096: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
111100: LD_ADDR_EXP 184
111104: PUSH
111105: LD_EXP 184
111109: PPUSH
111110: LD_VAR 0 4
111114: PPUSH
111115: LD_EXP 184
111119: PUSH
111120: LD_VAR 0 4
111124: ARRAY
111125: PPUSH
111126: LD_VAR 0 3
111130: PPUSH
111131: CALL_OW 3
111135: PPUSH
111136: CALL_OW 1
111140: ST_TO_ADDR
// end ; end ;
111141: GO 110970
111143: POP
111144: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111145: LD_VAR 0 1
111149: PPUSH
111150: LD_EXP 184
111154: PUSH
111155: LD_VAR 0 4
111159: ARRAY
111160: PUSH
111161: LD_INT 0
111163: PLUS
111164: PPUSH
111165: CALL_OW 505
// end ;
111169: LD_VAR 0 2
111173: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
111174: LD_INT 0
111176: PPUSH
111177: PPUSH
111178: PPUSH
111179: PPUSH
// if not hack in hackTanks then
111180: LD_VAR 0 1
111184: PUSH
111185: LD_EXP 183
111189: IN
111190: NOT
111191: IFFALSE 111195
// exit ;
111193: GO 111280
// index := GetElementIndex ( hackTanks , hack ) ;
111195: LD_ADDR_VAR 0 5
111199: PUSH
111200: LD_EXP 183
111204: PPUSH
111205: LD_VAR 0 1
111209: PPUSH
111210: CALL 56873 0 2
111214: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
111215: LD_ADDR_VAR 0 4
111219: PUSH
111220: DOUBLE
111221: LD_INT 1
111223: DEC
111224: ST_TO_ADDR
111225: LD_EXP 184
111229: PUSH
111230: LD_VAR 0 5
111234: ARRAY
111235: PUSH
111236: FOR_TO
111237: IFFALSE 111278
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
111239: LD_EXP 184
111243: PUSH
111244: LD_VAR 0 5
111248: ARRAY
111249: PUSH
111250: LD_VAR 0 4
111254: ARRAY
111255: PUSH
111256: LD_INT 1
111258: ARRAY
111259: PUSH
111260: LD_VAR 0 2
111264: EQUAL
111265: IFFALSE 111276
// KillUnit ( vehicle ) ;
111267: LD_VAR 0 2
111271: PPUSH
111272: CALL_OW 66
111276: GO 111236
111278: POP
111279: POP
// end ;
111280: LD_VAR 0 3
111284: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
111285: LD_EXP 188
111289: NOT
111290: IFFALSE 111325
111292: GO 111294
111294: DISABLE
// begin initMiner := true ;
111295: LD_ADDR_EXP 188
111299: PUSH
111300: LD_INT 1
111302: ST_TO_ADDR
// minersList := [ ] ;
111303: LD_ADDR_EXP 189
111307: PUSH
111308: EMPTY
111309: ST_TO_ADDR
// minerMinesList := [ ] ;
111310: LD_ADDR_EXP 190
111314: PUSH
111315: EMPTY
111316: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
111317: LD_ADDR_EXP 191
111321: PUSH
111322: LD_INT 5
111324: ST_TO_ADDR
// end ;
111325: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
111326: LD_EXP 188
111330: PUSH
111331: LD_INT 34
111333: PUSH
111334: LD_INT 81
111336: PUSH
111337: EMPTY
111338: LIST
111339: LIST
111340: PPUSH
111341: CALL_OW 69
111345: AND
111346: IFFALSE 111807
111348: GO 111350
111350: DISABLE
111351: LD_INT 0
111353: PPUSH
111354: PPUSH
111355: PPUSH
111356: PPUSH
// begin enable ;
111357: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111358: LD_ADDR_VAR 0 1
111362: PUSH
111363: LD_INT 34
111365: PUSH
111366: LD_INT 81
111368: PUSH
111369: EMPTY
111370: LIST
111371: LIST
111372: PPUSH
111373: CALL_OW 69
111377: PUSH
111378: FOR_IN
111379: IFFALSE 111451
// begin if not i in minersList then
111381: LD_VAR 0 1
111385: PUSH
111386: LD_EXP 189
111390: IN
111391: NOT
111392: IFFALSE 111449
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111394: LD_ADDR_EXP 189
111398: PUSH
111399: LD_EXP 189
111403: PPUSH
111404: LD_EXP 189
111408: PUSH
111409: LD_INT 1
111411: PLUS
111412: PPUSH
111413: LD_VAR 0 1
111417: PPUSH
111418: CALL_OW 1
111422: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111423: LD_ADDR_EXP 190
111427: PUSH
111428: LD_EXP 190
111432: PPUSH
111433: LD_EXP 190
111437: PUSH
111438: LD_INT 1
111440: PLUS
111441: PPUSH
111442: EMPTY
111443: PPUSH
111444: CALL_OW 1
111448: ST_TO_ADDR
// end end ;
111449: GO 111378
111451: POP
111452: POP
// for i := minerMinesList downto 1 do
111453: LD_ADDR_VAR 0 1
111457: PUSH
111458: DOUBLE
111459: LD_EXP 190
111463: INC
111464: ST_TO_ADDR
111465: LD_INT 1
111467: PUSH
111468: FOR_DOWNTO
111469: IFFALSE 111805
// begin if IsLive ( minersList [ i ] ) then
111471: LD_EXP 189
111475: PUSH
111476: LD_VAR 0 1
111480: ARRAY
111481: PPUSH
111482: CALL_OW 300
111486: IFFALSE 111514
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
111488: LD_EXP 189
111492: PUSH
111493: LD_VAR 0 1
111497: ARRAY
111498: PPUSH
111499: LD_EXP 190
111503: PUSH
111504: LD_VAR 0 1
111508: ARRAY
111509: PPUSH
111510: CALL_OW 505
// if not minerMinesList [ i ] then
111514: LD_EXP 190
111518: PUSH
111519: LD_VAR 0 1
111523: ARRAY
111524: NOT
111525: IFFALSE 111529
// continue ;
111527: GO 111468
// for j := minerMinesList [ i ] downto 1 do
111529: LD_ADDR_VAR 0 2
111533: PUSH
111534: DOUBLE
111535: LD_EXP 190
111539: PUSH
111540: LD_VAR 0 1
111544: ARRAY
111545: INC
111546: ST_TO_ADDR
111547: LD_INT 1
111549: PUSH
111550: FOR_DOWNTO
111551: IFFALSE 111801
// begin side := GetSide ( minersList [ i ] ) ;
111553: LD_ADDR_VAR 0 3
111557: PUSH
111558: LD_EXP 189
111562: PUSH
111563: LD_VAR 0 1
111567: ARRAY
111568: PPUSH
111569: CALL_OW 255
111573: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111574: LD_ADDR_VAR 0 4
111578: PUSH
111579: LD_EXP 190
111583: PUSH
111584: LD_VAR 0 1
111588: ARRAY
111589: PUSH
111590: LD_VAR 0 2
111594: ARRAY
111595: PUSH
111596: LD_INT 1
111598: ARRAY
111599: PPUSH
111600: LD_EXP 190
111604: PUSH
111605: LD_VAR 0 1
111609: ARRAY
111610: PUSH
111611: LD_VAR 0 2
111615: ARRAY
111616: PUSH
111617: LD_INT 2
111619: ARRAY
111620: PPUSH
111621: CALL_OW 428
111625: ST_TO_ADDR
// if not tmp then
111626: LD_VAR 0 4
111630: NOT
111631: IFFALSE 111635
// continue ;
111633: GO 111550
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111635: LD_VAR 0 4
111639: PUSH
111640: LD_INT 81
111642: PUSH
111643: LD_VAR 0 3
111647: PUSH
111648: EMPTY
111649: LIST
111650: LIST
111651: PPUSH
111652: CALL_OW 69
111656: IN
111657: PUSH
111658: LD_EXP 190
111662: PUSH
111663: LD_VAR 0 1
111667: ARRAY
111668: PUSH
111669: LD_VAR 0 2
111673: ARRAY
111674: PUSH
111675: LD_INT 1
111677: ARRAY
111678: PPUSH
111679: LD_EXP 190
111683: PUSH
111684: LD_VAR 0 1
111688: ARRAY
111689: PUSH
111690: LD_VAR 0 2
111694: ARRAY
111695: PUSH
111696: LD_INT 2
111698: ARRAY
111699: PPUSH
111700: CALL_OW 458
111704: AND
111705: IFFALSE 111799
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111707: LD_EXP 190
111711: PUSH
111712: LD_VAR 0 1
111716: ARRAY
111717: PUSH
111718: LD_VAR 0 2
111722: ARRAY
111723: PUSH
111724: LD_INT 1
111726: ARRAY
111727: PPUSH
111728: LD_EXP 190
111732: PUSH
111733: LD_VAR 0 1
111737: ARRAY
111738: PUSH
111739: LD_VAR 0 2
111743: ARRAY
111744: PUSH
111745: LD_INT 2
111747: ARRAY
111748: PPUSH
111749: LD_VAR 0 3
111753: PPUSH
111754: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111758: LD_ADDR_EXP 190
111762: PUSH
111763: LD_EXP 190
111767: PPUSH
111768: LD_VAR 0 1
111772: PPUSH
111773: LD_EXP 190
111777: PUSH
111778: LD_VAR 0 1
111782: ARRAY
111783: PPUSH
111784: LD_VAR 0 2
111788: PPUSH
111789: CALL_OW 3
111793: PPUSH
111794: CALL_OW 1
111798: ST_TO_ADDR
// end ; end ;
111799: GO 111550
111801: POP
111802: POP
// end ;
111803: GO 111468
111805: POP
111806: POP
// end ;
111807: PPOPN 4
111809: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
111810: LD_INT 0
111812: PPUSH
111813: PPUSH
// result := false ;
111814: LD_ADDR_VAR 0 4
111818: PUSH
111819: LD_INT 0
111821: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
111822: LD_VAR 0 1
111826: PPUSH
111827: CALL_OW 264
111831: PUSH
111832: LD_INT 81
111834: EQUAL
111835: NOT
111836: IFFALSE 111840
// exit ;
111838: GO 112080
// index := GetElementIndex ( minersList , unit ) ;
111840: LD_ADDR_VAR 0 5
111844: PUSH
111845: LD_EXP 189
111849: PPUSH
111850: LD_VAR 0 1
111854: PPUSH
111855: CALL 56873 0 2
111859: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
111860: LD_EXP 190
111864: PUSH
111865: LD_VAR 0 5
111869: ARRAY
111870: PUSH
111871: LD_EXP 191
111875: GREATEREQUAL
111876: IFFALSE 111880
// exit ;
111878: GO 112080
// ComMoveXY ( unit , x , y ) ;
111880: LD_VAR 0 1
111884: PPUSH
111885: LD_VAR 0 2
111889: PPUSH
111890: LD_VAR 0 3
111894: PPUSH
111895: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111899: LD_INT 35
111901: PPUSH
111902: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
111906: LD_VAR 0 1
111910: PPUSH
111911: LD_VAR 0 2
111915: PPUSH
111916: LD_VAR 0 3
111920: PPUSH
111921: CALL 88209 0 3
111925: NOT
111926: PUSH
111927: LD_VAR 0 1
111931: PPUSH
111932: CALL_OW 314
111936: AND
111937: IFFALSE 111941
// exit ;
111939: GO 112080
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
111941: LD_VAR 0 2
111945: PPUSH
111946: LD_VAR 0 3
111950: PPUSH
111951: CALL_OW 428
111955: PUSH
111956: LD_VAR 0 1
111960: EQUAL
111961: PUSH
111962: LD_VAR 0 1
111966: PPUSH
111967: CALL_OW 314
111971: NOT
111972: AND
111973: IFFALSE 111899
// PlaySoundXY ( x , y , PlantMine ) ;
111975: LD_VAR 0 2
111979: PPUSH
111980: LD_VAR 0 3
111984: PPUSH
111985: LD_STRING PlantMine
111987: PPUSH
111988: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
111992: LD_VAR 0 2
111996: PPUSH
111997: LD_VAR 0 3
112001: PPUSH
112002: LD_VAR 0 1
112006: PPUSH
112007: CALL_OW 255
112011: PPUSH
112012: LD_INT 0
112014: PPUSH
112015: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
112019: LD_ADDR_EXP 190
112023: PUSH
112024: LD_EXP 190
112028: PPUSH
112029: LD_VAR 0 5
112033: PUSH
112034: LD_EXP 190
112038: PUSH
112039: LD_VAR 0 5
112043: ARRAY
112044: PUSH
112045: LD_INT 1
112047: PLUS
112048: PUSH
112049: EMPTY
112050: LIST
112051: LIST
112052: PPUSH
112053: LD_VAR 0 2
112057: PUSH
112058: LD_VAR 0 3
112062: PUSH
112063: EMPTY
112064: LIST
112065: LIST
112066: PPUSH
112067: CALL 57088 0 3
112071: ST_TO_ADDR
// result := true ;
112072: LD_ADDR_VAR 0 4
112076: PUSH
112077: LD_INT 1
112079: ST_TO_ADDR
// end ;
112080: LD_VAR 0 4
112084: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
112085: LD_INT 0
112087: PPUSH
112088: PPUSH
112089: PPUSH
// if not unit in minersList then
112090: LD_VAR 0 1
112094: PUSH
112095: LD_EXP 189
112099: IN
112100: NOT
112101: IFFALSE 112105
// exit ;
112103: GO 112497
// index := GetElementIndex ( minersList , unit ) ;
112105: LD_ADDR_VAR 0 6
112109: PUSH
112110: LD_EXP 189
112114: PPUSH
112115: LD_VAR 0 1
112119: PPUSH
112120: CALL 56873 0 2
112124: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
112125: LD_ADDR_VAR 0 5
112129: PUSH
112130: DOUBLE
112131: LD_EXP 190
112135: PUSH
112136: LD_VAR 0 6
112140: ARRAY
112141: INC
112142: ST_TO_ADDR
112143: LD_INT 1
112145: PUSH
112146: FOR_DOWNTO
112147: IFFALSE 112308
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
112149: LD_EXP 190
112153: PUSH
112154: LD_VAR 0 6
112158: ARRAY
112159: PUSH
112160: LD_VAR 0 5
112164: ARRAY
112165: PUSH
112166: LD_INT 1
112168: ARRAY
112169: PUSH
112170: LD_VAR 0 2
112174: EQUAL
112175: PUSH
112176: LD_EXP 190
112180: PUSH
112181: LD_VAR 0 6
112185: ARRAY
112186: PUSH
112187: LD_VAR 0 5
112191: ARRAY
112192: PUSH
112193: LD_INT 2
112195: ARRAY
112196: PUSH
112197: LD_VAR 0 3
112201: EQUAL
112202: AND
112203: IFFALSE 112306
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112205: LD_EXP 190
112209: PUSH
112210: LD_VAR 0 6
112214: ARRAY
112215: PUSH
112216: LD_VAR 0 5
112220: ARRAY
112221: PUSH
112222: LD_INT 1
112224: ARRAY
112225: PPUSH
112226: LD_EXP 190
112230: PUSH
112231: LD_VAR 0 6
112235: ARRAY
112236: PUSH
112237: LD_VAR 0 5
112241: ARRAY
112242: PUSH
112243: LD_INT 2
112245: ARRAY
112246: PPUSH
112247: LD_VAR 0 1
112251: PPUSH
112252: CALL_OW 255
112256: PPUSH
112257: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112261: LD_ADDR_EXP 190
112265: PUSH
112266: LD_EXP 190
112270: PPUSH
112271: LD_VAR 0 6
112275: PPUSH
112276: LD_EXP 190
112280: PUSH
112281: LD_VAR 0 6
112285: ARRAY
112286: PPUSH
112287: LD_VAR 0 5
112291: PPUSH
112292: CALL_OW 3
112296: PPUSH
112297: CALL_OW 1
112301: ST_TO_ADDR
// exit ;
112302: POP
112303: POP
112304: GO 112497
// end ; end ;
112306: GO 112146
112308: POP
112309: POP
// for i := minerMinesList [ index ] downto 1 do
112310: LD_ADDR_VAR 0 5
112314: PUSH
112315: DOUBLE
112316: LD_EXP 190
112320: PUSH
112321: LD_VAR 0 6
112325: ARRAY
112326: INC
112327: ST_TO_ADDR
112328: LD_INT 1
112330: PUSH
112331: FOR_DOWNTO
112332: IFFALSE 112495
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112334: LD_EXP 190
112338: PUSH
112339: LD_VAR 0 6
112343: ARRAY
112344: PUSH
112345: LD_VAR 0 5
112349: ARRAY
112350: PUSH
112351: LD_INT 1
112353: ARRAY
112354: PPUSH
112355: LD_EXP 190
112359: PUSH
112360: LD_VAR 0 6
112364: ARRAY
112365: PUSH
112366: LD_VAR 0 5
112370: ARRAY
112371: PUSH
112372: LD_INT 2
112374: ARRAY
112375: PPUSH
112376: LD_VAR 0 2
112380: PPUSH
112381: LD_VAR 0 3
112385: PPUSH
112386: CALL_OW 298
112390: PUSH
112391: LD_INT 6
112393: LESS
112394: IFFALSE 112493
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112396: LD_EXP 190
112400: PUSH
112401: LD_VAR 0 6
112405: ARRAY
112406: PUSH
112407: LD_VAR 0 5
112411: ARRAY
112412: PUSH
112413: LD_INT 1
112415: ARRAY
112416: PPUSH
112417: LD_EXP 190
112421: PUSH
112422: LD_VAR 0 6
112426: ARRAY
112427: PUSH
112428: LD_VAR 0 5
112432: ARRAY
112433: PUSH
112434: LD_INT 2
112436: ARRAY
112437: PPUSH
112438: LD_VAR 0 1
112442: PPUSH
112443: CALL_OW 255
112447: PPUSH
112448: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112452: LD_ADDR_EXP 190
112456: PUSH
112457: LD_EXP 190
112461: PPUSH
112462: LD_VAR 0 6
112466: PPUSH
112467: LD_EXP 190
112471: PUSH
112472: LD_VAR 0 6
112476: ARRAY
112477: PPUSH
112478: LD_VAR 0 5
112482: PPUSH
112483: CALL_OW 3
112487: PPUSH
112488: CALL_OW 1
112492: ST_TO_ADDR
// end ; end ;
112493: GO 112331
112495: POP
112496: POP
// end ;
112497: LD_VAR 0 4
112501: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112502: LD_INT 0
112504: PPUSH
112505: PPUSH
112506: PPUSH
112507: PPUSH
112508: PPUSH
112509: PPUSH
112510: PPUSH
112511: PPUSH
112512: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112513: LD_VAR 0 1
112517: PPUSH
112518: CALL_OW 264
112522: PUSH
112523: LD_INT 81
112525: EQUAL
112526: NOT
112527: PUSH
112528: LD_VAR 0 1
112532: PUSH
112533: LD_EXP 189
112537: IN
112538: NOT
112539: OR
112540: IFFALSE 112544
// exit ;
112542: GO 112866
// index := GetElementIndex ( minersList , unit ) ;
112544: LD_ADDR_VAR 0 6
112548: PUSH
112549: LD_EXP 189
112553: PPUSH
112554: LD_VAR 0 1
112558: PPUSH
112559: CALL 56873 0 2
112563: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112564: LD_ADDR_VAR 0 8
112568: PUSH
112569: LD_EXP 191
112573: PUSH
112574: LD_EXP 190
112578: PUSH
112579: LD_VAR 0 6
112583: ARRAY
112584: MINUS
112585: ST_TO_ADDR
// if not minesFreeAmount then
112586: LD_VAR 0 8
112590: NOT
112591: IFFALSE 112595
// exit ;
112593: GO 112866
// tmp := [ ] ;
112595: LD_ADDR_VAR 0 7
112599: PUSH
112600: EMPTY
112601: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
112602: LD_ADDR_VAR 0 5
112606: PUSH
112607: DOUBLE
112608: LD_INT 1
112610: DEC
112611: ST_TO_ADDR
112612: LD_VAR 0 8
112616: PUSH
112617: FOR_TO
112618: IFFALSE 112813
// begin _d := rand ( 0 , 5 ) ;
112620: LD_ADDR_VAR 0 11
112624: PUSH
112625: LD_INT 0
112627: PPUSH
112628: LD_INT 5
112630: PPUSH
112631: CALL_OW 12
112635: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112636: LD_ADDR_VAR 0 12
112640: PUSH
112641: LD_INT 2
112643: PPUSH
112644: LD_INT 6
112646: PPUSH
112647: CALL_OW 12
112651: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112652: LD_ADDR_VAR 0 9
112656: PUSH
112657: LD_VAR 0 2
112661: PPUSH
112662: LD_VAR 0 11
112666: PPUSH
112667: LD_VAR 0 12
112671: PPUSH
112672: CALL_OW 272
112676: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112677: LD_ADDR_VAR 0 10
112681: PUSH
112682: LD_VAR 0 3
112686: PPUSH
112687: LD_VAR 0 11
112691: PPUSH
112692: LD_VAR 0 12
112696: PPUSH
112697: CALL_OW 273
112701: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112702: LD_VAR 0 9
112706: PPUSH
112707: LD_VAR 0 10
112711: PPUSH
112712: CALL_OW 488
112716: PUSH
112717: LD_VAR 0 9
112721: PUSH
112722: LD_VAR 0 10
112726: PUSH
112727: EMPTY
112728: LIST
112729: LIST
112730: PUSH
112731: LD_VAR 0 7
112735: IN
112736: NOT
112737: AND
112738: PUSH
112739: LD_VAR 0 9
112743: PPUSH
112744: LD_VAR 0 10
112748: PPUSH
112749: CALL_OW 458
112753: NOT
112754: AND
112755: IFFALSE 112797
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
112757: LD_ADDR_VAR 0 7
112761: PUSH
112762: LD_VAR 0 7
112766: PPUSH
112767: LD_VAR 0 7
112771: PUSH
112772: LD_INT 1
112774: PLUS
112775: PPUSH
112776: LD_VAR 0 9
112780: PUSH
112781: LD_VAR 0 10
112785: PUSH
112786: EMPTY
112787: LIST
112788: LIST
112789: PPUSH
112790: CALL_OW 1
112794: ST_TO_ADDR
112795: GO 112811
// i := i - 1 ;
112797: LD_ADDR_VAR 0 5
112801: PUSH
112802: LD_VAR 0 5
112806: PUSH
112807: LD_INT 1
112809: MINUS
112810: ST_TO_ADDR
// end ;
112811: GO 112617
112813: POP
112814: POP
// for i in tmp do
112815: LD_ADDR_VAR 0 5
112819: PUSH
112820: LD_VAR 0 7
112824: PUSH
112825: FOR_IN
112826: IFFALSE 112864
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
112828: LD_VAR 0 1
112832: PPUSH
112833: LD_VAR 0 5
112837: PUSH
112838: LD_INT 1
112840: ARRAY
112841: PPUSH
112842: LD_VAR 0 5
112846: PUSH
112847: LD_INT 2
112849: ARRAY
112850: PPUSH
112851: CALL 111810 0 3
112855: NOT
112856: IFFALSE 112862
// exit ;
112858: POP
112859: POP
112860: GO 112866
112862: GO 112825
112864: POP
112865: POP
// end ;
112866: LD_VAR 0 4
112870: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
112871: LD_INT 0
112873: PPUSH
112874: PPUSH
112875: PPUSH
112876: PPUSH
112877: PPUSH
112878: PPUSH
112879: PPUSH
// if not GetClass ( unit ) = class_sniper then
112880: LD_VAR 0 1
112884: PPUSH
112885: CALL_OW 257
112889: PUSH
112890: LD_INT 5
112892: EQUAL
112893: NOT
112894: IFFALSE 112898
// exit ;
112896: GO 113286
// dist := 8 ;
112898: LD_ADDR_VAR 0 5
112902: PUSH
112903: LD_INT 8
112905: ST_TO_ADDR
// viewRange := 12 ;
112906: LD_ADDR_VAR 0 7
112910: PUSH
112911: LD_INT 12
112913: ST_TO_ADDR
// side := GetSide ( unit ) ;
112914: LD_ADDR_VAR 0 6
112918: PUSH
112919: LD_VAR 0 1
112923: PPUSH
112924: CALL_OW 255
112928: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
112929: LD_INT 61
112931: PPUSH
112932: LD_VAR 0 6
112936: PPUSH
112937: CALL_OW 321
112941: PUSH
112942: LD_INT 2
112944: EQUAL
112945: IFFALSE 112955
// viewRange := 16 ;
112947: LD_ADDR_VAR 0 7
112951: PUSH
112952: LD_INT 16
112954: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
112955: LD_VAR 0 1
112959: PPUSH
112960: LD_VAR 0 2
112964: PPUSH
112965: LD_VAR 0 3
112969: PPUSH
112970: CALL_OW 297
112974: PUSH
112975: LD_VAR 0 5
112979: GREATER
112980: IFFALSE 113059
// begin ComMoveXY ( unit , x , y ) ;
112982: LD_VAR 0 1
112986: PPUSH
112987: LD_VAR 0 2
112991: PPUSH
112992: LD_VAR 0 3
112996: PPUSH
112997: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
113001: LD_INT 35
113003: PPUSH
113004: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
113008: LD_VAR 0 1
113012: PPUSH
113013: LD_VAR 0 2
113017: PPUSH
113018: LD_VAR 0 3
113022: PPUSH
113023: CALL 88209 0 3
113027: NOT
113028: IFFALSE 113032
// exit ;
113030: GO 113286
// until GetDistUnitXY ( unit , x , y ) < dist ;
113032: LD_VAR 0 1
113036: PPUSH
113037: LD_VAR 0 2
113041: PPUSH
113042: LD_VAR 0 3
113046: PPUSH
113047: CALL_OW 297
113051: PUSH
113052: LD_VAR 0 5
113056: LESS
113057: IFFALSE 113001
// end ; ComTurnXY ( unit , x , y ) ;
113059: LD_VAR 0 1
113063: PPUSH
113064: LD_VAR 0 2
113068: PPUSH
113069: LD_VAR 0 3
113073: PPUSH
113074: CALL_OW 118
// wait ( 5 ) ;
113078: LD_INT 5
113080: PPUSH
113081: CALL_OW 67
// _d := GetDir ( unit ) ;
113085: LD_ADDR_VAR 0 10
113089: PUSH
113090: LD_VAR 0 1
113094: PPUSH
113095: CALL_OW 254
113099: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
113100: LD_ADDR_VAR 0 8
113104: PUSH
113105: LD_VAR 0 1
113109: PPUSH
113110: CALL_OW 250
113114: PPUSH
113115: LD_VAR 0 10
113119: PPUSH
113120: LD_VAR 0 5
113124: PPUSH
113125: CALL_OW 272
113129: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
113130: LD_ADDR_VAR 0 9
113134: PUSH
113135: LD_VAR 0 1
113139: PPUSH
113140: CALL_OW 251
113144: PPUSH
113145: LD_VAR 0 10
113149: PPUSH
113150: LD_VAR 0 5
113154: PPUSH
113155: CALL_OW 273
113159: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
113160: LD_VAR 0 8
113164: PPUSH
113165: LD_VAR 0 9
113169: PPUSH
113170: CALL_OW 488
113174: NOT
113175: IFFALSE 113179
// exit ;
113177: GO 113286
// ComAnimCustom ( unit , 1 ) ;
113179: LD_VAR 0 1
113183: PPUSH
113184: LD_INT 1
113186: PPUSH
113187: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
113191: LD_VAR 0 8
113195: PPUSH
113196: LD_VAR 0 9
113200: PPUSH
113201: LD_VAR 0 6
113205: PPUSH
113206: LD_VAR 0 7
113210: PPUSH
113211: CALL_OW 330
// repeat wait ( 1 ) ;
113215: LD_INT 1
113217: PPUSH
113218: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
113222: LD_VAR 0 1
113226: PPUSH
113227: CALL_OW 316
113231: PUSH
113232: LD_VAR 0 1
113236: PPUSH
113237: CALL_OW 314
113241: OR
113242: PUSH
113243: LD_VAR 0 1
113247: PPUSH
113248: CALL_OW 302
113252: NOT
113253: OR
113254: PUSH
113255: LD_VAR 0 1
113259: PPUSH
113260: CALL_OW 301
113264: OR
113265: IFFALSE 113215
// RemoveSeeing ( _x , _y , side ) ;
113267: LD_VAR 0 8
113271: PPUSH
113272: LD_VAR 0 9
113276: PPUSH
113277: LD_VAR 0 6
113281: PPUSH
113282: CALL_OW 331
// end ; end_of_file
113286: LD_VAR 0 4
113290: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
113291: LD_INT 0
113293: PPUSH
113294: PPUSH
113295: PPUSH
113296: PPUSH
113297: PPUSH
113298: PPUSH
113299: PPUSH
113300: PPUSH
113301: PPUSH
113302: PPUSH
113303: PPUSH
113304: PPUSH
113305: PPUSH
113306: PPUSH
113307: PPUSH
113308: PPUSH
113309: PPUSH
113310: PPUSH
113311: PPUSH
113312: PPUSH
113313: PPUSH
113314: PPUSH
113315: PPUSH
113316: PPUSH
113317: PPUSH
113318: PPUSH
113319: PPUSH
113320: PPUSH
113321: PPUSH
113322: PPUSH
113323: PPUSH
113324: PPUSH
113325: PPUSH
113326: PPUSH
// if not list then
113327: LD_VAR 0 1
113331: NOT
113332: IFFALSE 113336
// exit ;
113334: GO 117995
// base := list [ 1 ] ;
113336: LD_ADDR_VAR 0 3
113340: PUSH
113341: LD_VAR 0 1
113345: PUSH
113346: LD_INT 1
113348: ARRAY
113349: ST_TO_ADDR
// group := list [ 2 ] ;
113350: LD_ADDR_VAR 0 4
113354: PUSH
113355: LD_VAR 0 1
113359: PUSH
113360: LD_INT 2
113362: ARRAY
113363: ST_TO_ADDR
// path := list [ 3 ] ;
113364: LD_ADDR_VAR 0 5
113368: PUSH
113369: LD_VAR 0 1
113373: PUSH
113374: LD_INT 3
113376: ARRAY
113377: ST_TO_ADDR
// flags := list [ 4 ] ;
113378: LD_ADDR_VAR 0 6
113382: PUSH
113383: LD_VAR 0 1
113387: PUSH
113388: LD_INT 4
113390: ARRAY
113391: ST_TO_ADDR
// mined := [ ] ;
113392: LD_ADDR_VAR 0 27
113396: PUSH
113397: EMPTY
113398: ST_TO_ADDR
// bombed := [ ] ;
113399: LD_ADDR_VAR 0 28
113403: PUSH
113404: EMPTY
113405: ST_TO_ADDR
// healers := [ ] ;
113406: LD_ADDR_VAR 0 31
113410: PUSH
113411: EMPTY
113412: ST_TO_ADDR
// to_heal := [ ] ;
113413: LD_ADDR_VAR 0 30
113417: PUSH
113418: EMPTY
113419: ST_TO_ADDR
// repairs := [ ] ;
113420: LD_ADDR_VAR 0 33
113424: PUSH
113425: EMPTY
113426: ST_TO_ADDR
// to_repair := [ ] ;
113427: LD_ADDR_VAR 0 32
113431: PUSH
113432: EMPTY
113433: ST_TO_ADDR
// if not group or not path then
113434: LD_VAR 0 4
113438: NOT
113439: PUSH
113440: LD_VAR 0 5
113444: NOT
113445: OR
113446: IFFALSE 113450
// exit ;
113448: GO 117995
// side := GetSide ( group [ 1 ] ) ;
113450: LD_ADDR_VAR 0 35
113454: PUSH
113455: LD_VAR 0 4
113459: PUSH
113460: LD_INT 1
113462: ARRAY
113463: PPUSH
113464: CALL_OW 255
113468: ST_TO_ADDR
// if flags then
113469: LD_VAR 0 6
113473: IFFALSE 113617
// begin f_ignore_area := flags [ 1 ] ;
113475: LD_ADDR_VAR 0 17
113479: PUSH
113480: LD_VAR 0 6
113484: PUSH
113485: LD_INT 1
113487: ARRAY
113488: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113489: LD_ADDR_VAR 0 18
113493: PUSH
113494: LD_VAR 0 6
113498: PUSH
113499: LD_INT 2
113501: ARRAY
113502: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113503: LD_ADDR_VAR 0 19
113507: PUSH
113508: LD_VAR 0 6
113512: PUSH
113513: LD_INT 3
113515: ARRAY
113516: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113517: LD_ADDR_VAR 0 20
113521: PUSH
113522: LD_VAR 0 6
113526: PUSH
113527: LD_INT 4
113529: ARRAY
113530: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113531: LD_ADDR_VAR 0 21
113535: PUSH
113536: LD_VAR 0 6
113540: PUSH
113541: LD_INT 5
113543: ARRAY
113544: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113545: LD_ADDR_VAR 0 22
113549: PUSH
113550: LD_VAR 0 6
113554: PUSH
113555: LD_INT 6
113557: ARRAY
113558: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113559: LD_ADDR_VAR 0 23
113563: PUSH
113564: LD_VAR 0 6
113568: PUSH
113569: LD_INT 7
113571: ARRAY
113572: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113573: LD_ADDR_VAR 0 24
113577: PUSH
113578: LD_VAR 0 6
113582: PUSH
113583: LD_INT 8
113585: ARRAY
113586: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113587: LD_ADDR_VAR 0 25
113591: PUSH
113592: LD_VAR 0 6
113596: PUSH
113597: LD_INT 9
113599: ARRAY
113600: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113601: LD_ADDR_VAR 0 26
113605: PUSH
113606: LD_VAR 0 6
113610: PUSH
113611: LD_INT 10
113613: ARRAY
113614: ST_TO_ADDR
// end else
113615: GO 113697
// begin f_ignore_area := false ;
113617: LD_ADDR_VAR 0 17
113621: PUSH
113622: LD_INT 0
113624: ST_TO_ADDR
// f_capture := false ;
113625: LD_ADDR_VAR 0 18
113629: PUSH
113630: LD_INT 0
113632: ST_TO_ADDR
// f_ignore_civ := false ;
113633: LD_ADDR_VAR 0 19
113637: PUSH
113638: LD_INT 0
113640: ST_TO_ADDR
// f_murder := false ;
113641: LD_ADDR_VAR 0 20
113645: PUSH
113646: LD_INT 0
113648: ST_TO_ADDR
// f_mines := false ;
113649: LD_ADDR_VAR 0 21
113653: PUSH
113654: LD_INT 0
113656: ST_TO_ADDR
// f_repair := false ;
113657: LD_ADDR_VAR 0 22
113661: PUSH
113662: LD_INT 0
113664: ST_TO_ADDR
// f_heal := false ;
113665: LD_ADDR_VAR 0 23
113669: PUSH
113670: LD_INT 0
113672: ST_TO_ADDR
// f_spacetime := false ;
113673: LD_ADDR_VAR 0 24
113677: PUSH
113678: LD_INT 0
113680: ST_TO_ADDR
// f_attack_depot := false ;
113681: LD_ADDR_VAR 0 25
113685: PUSH
113686: LD_INT 0
113688: ST_TO_ADDR
// f_crawl := false ;
113689: LD_ADDR_VAR 0 26
113693: PUSH
113694: LD_INT 0
113696: ST_TO_ADDR
// end ; if f_heal then
113697: LD_VAR 0 23
113701: IFFALSE 113728
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113703: LD_ADDR_VAR 0 31
113707: PUSH
113708: LD_VAR 0 4
113712: PPUSH
113713: LD_INT 25
113715: PUSH
113716: LD_INT 4
113718: PUSH
113719: EMPTY
113720: LIST
113721: LIST
113722: PPUSH
113723: CALL_OW 72
113727: ST_TO_ADDR
// if f_repair then
113728: LD_VAR 0 22
113732: IFFALSE 113759
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113734: LD_ADDR_VAR 0 33
113738: PUSH
113739: LD_VAR 0 4
113743: PPUSH
113744: LD_INT 25
113746: PUSH
113747: LD_INT 3
113749: PUSH
113750: EMPTY
113751: LIST
113752: LIST
113753: PPUSH
113754: CALL_OW 72
113758: ST_TO_ADDR
// units_path := [ ] ;
113759: LD_ADDR_VAR 0 16
113763: PUSH
113764: EMPTY
113765: ST_TO_ADDR
// for i = 1 to group do
113766: LD_ADDR_VAR 0 7
113770: PUSH
113771: DOUBLE
113772: LD_INT 1
113774: DEC
113775: ST_TO_ADDR
113776: LD_VAR 0 4
113780: PUSH
113781: FOR_TO
113782: IFFALSE 113811
// units_path := Replace ( units_path , i , path ) ;
113784: LD_ADDR_VAR 0 16
113788: PUSH
113789: LD_VAR 0 16
113793: PPUSH
113794: LD_VAR 0 7
113798: PPUSH
113799: LD_VAR 0 5
113803: PPUSH
113804: CALL_OW 1
113808: ST_TO_ADDR
113809: GO 113781
113811: POP
113812: POP
// repeat for i = group downto 1 do
113813: LD_ADDR_VAR 0 7
113817: PUSH
113818: DOUBLE
113819: LD_VAR 0 4
113823: INC
113824: ST_TO_ADDR
113825: LD_INT 1
113827: PUSH
113828: FOR_DOWNTO
113829: IFFALSE 117951
// begin wait ( 5 ) ;
113831: LD_INT 5
113833: PPUSH
113834: CALL_OW 67
// tmp := [ ] ;
113838: LD_ADDR_VAR 0 14
113842: PUSH
113843: EMPTY
113844: ST_TO_ADDR
// attacking := false ;
113845: LD_ADDR_VAR 0 29
113849: PUSH
113850: LD_INT 0
113852: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113853: LD_VAR 0 4
113857: PUSH
113858: LD_VAR 0 7
113862: ARRAY
113863: PPUSH
113864: CALL_OW 301
113868: PUSH
113869: LD_VAR 0 4
113873: PUSH
113874: LD_VAR 0 7
113878: ARRAY
113879: NOT
113880: OR
113881: IFFALSE 113990
// begin if GetType ( group [ i ] ) = unit_human then
113883: LD_VAR 0 4
113887: PUSH
113888: LD_VAR 0 7
113892: ARRAY
113893: PPUSH
113894: CALL_OW 247
113898: PUSH
113899: LD_INT 1
113901: EQUAL
113902: IFFALSE 113948
// begin to_heal := to_heal diff group [ i ] ;
113904: LD_ADDR_VAR 0 30
113908: PUSH
113909: LD_VAR 0 30
113913: PUSH
113914: LD_VAR 0 4
113918: PUSH
113919: LD_VAR 0 7
113923: ARRAY
113924: DIFF
113925: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113926: LD_ADDR_VAR 0 31
113930: PUSH
113931: LD_VAR 0 31
113935: PUSH
113936: LD_VAR 0 4
113940: PUSH
113941: LD_VAR 0 7
113945: ARRAY
113946: DIFF
113947: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113948: LD_ADDR_VAR 0 4
113952: PUSH
113953: LD_VAR 0 4
113957: PPUSH
113958: LD_VAR 0 7
113962: PPUSH
113963: CALL_OW 3
113967: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113968: LD_ADDR_VAR 0 16
113972: PUSH
113973: LD_VAR 0 16
113977: PPUSH
113978: LD_VAR 0 7
113982: PPUSH
113983: CALL_OW 3
113987: ST_TO_ADDR
// continue ;
113988: GO 113828
// end ; if f_repair then
113990: LD_VAR 0 22
113994: IFFALSE 114483
// begin if GetType ( group [ i ] ) = unit_vehicle then
113996: LD_VAR 0 4
114000: PUSH
114001: LD_VAR 0 7
114005: ARRAY
114006: PPUSH
114007: CALL_OW 247
114011: PUSH
114012: LD_INT 2
114014: EQUAL
114015: IFFALSE 114205
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
114017: LD_VAR 0 4
114021: PUSH
114022: LD_VAR 0 7
114026: ARRAY
114027: PPUSH
114028: CALL_OW 256
114032: PUSH
114033: LD_INT 700
114035: LESS
114036: PUSH
114037: LD_VAR 0 4
114041: PUSH
114042: LD_VAR 0 7
114046: ARRAY
114047: PUSH
114048: LD_VAR 0 32
114052: IN
114053: NOT
114054: AND
114055: IFFALSE 114079
// to_repair := to_repair union group [ i ] ;
114057: LD_ADDR_VAR 0 32
114061: PUSH
114062: LD_VAR 0 32
114066: PUSH
114067: LD_VAR 0 4
114071: PUSH
114072: LD_VAR 0 7
114076: ARRAY
114077: UNION
114078: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
114079: LD_VAR 0 4
114083: PUSH
114084: LD_VAR 0 7
114088: ARRAY
114089: PPUSH
114090: CALL_OW 256
114094: PUSH
114095: LD_INT 1000
114097: EQUAL
114098: PUSH
114099: LD_VAR 0 4
114103: PUSH
114104: LD_VAR 0 7
114108: ARRAY
114109: PUSH
114110: LD_VAR 0 32
114114: IN
114115: AND
114116: IFFALSE 114140
// to_repair := to_repair diff group [ i ] ;
114118: LD_ADDR_VAR 0 32
114122: PUSH
114123: LD_VAR 0 32
114127: PUSH
114128: LD_VAR 0 4
114132: PUSH
114133: LD_VAR 0 7
114137: ARRAY
114138: DIFF
114139: ST_TO_ADDR
// if group [ i ] in to_repair then
114140: LD_VAR 0 4
114144: PUSH
114145: LD_VAR 0 7
114149: ARRAY
114150: PUSH
114151: LD_VAR 0 32
114155: IN
114156: IFFALSE 114203
// begin if not IsInArea ( group [ i ] , f_repair ) then
114158: LD_VAR 0 4
114162: PUSH
114163: LD_VAR 0 7
114167: ARRAY
114168: PPUSH
114169: LD_VAR 0 22
114173: PPUSH
114174: CALL_OW 308
114178: NOT
114179: IFFALSE 114201
// ComMoveToArea ( group [ i ] , f_repair ) ;
114181: LD_VAR 0 4
114185: PUSH
114186: LD_VAR 0 7
114190: ARRAY
114191: PPUSH
114192: LD_VAR 0 22
114196: PPUSH
114197: CALL_OW 113
// continue ;
114201: GO 113828
// end ; end else
114203: GO 114483
// if group [ i ] in repairs then
114205: LD_VAR 0 4
114209: PUSH
114210: LD_VAR 0 7
114214: ARRAY
114215: PUSH
114216: LD_VAR 0 33
114220: IN
114221: IFFALSE 114483
// begin if IsInUnit ( group [ i ] ) then
114223: LD_VAR 0 4
114227: PUSH
114228: LD_VAR 0 7
114232: ARRAY
114233: PPUSH
114234: CALL_OW 310
114238: IFFALSE 114306
// begin z := IsInUnit ( group [ i ] ) ;
114240: LD_ADDR_VAR 0 13
114244: PUSH
114245: LD_VAR 0 4
114249: PUSH
114250: LD_VAR 0 7
114254: ARRAY
114255: PPUSH
114256: CALL_OW 310
114260: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
114261: LD_VAR 0 13
114265: PUSH
114266: LD_VAR 0 32
114270: IN
114271: PUSH
114272: LD_VAR 0 13
114276: PPUSH
114277: LD_VAR 0 22
114281: PPUSH
114282: CALL_OW 308
114286: AND
114287: IFFALSE 114304
// ComExitVehicle ( group [ i ] ) ;
114289: LD_VAR 0 4
114293: PUSH
114294: LD_VAR 0 7
114298: ARRAY
114299: PPUSH
114300: CALL_OW 121
// end else
114304: GO 114483
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
114306: LD_ADDR_VAR 0 13
114310: PUSH
114311: LD_VAR 0 4
114315: PPUSH
114316: LD_INT 95
114318: PUSH
114319: LD_VAR 0 22
114323: PUSH
114324: EMPTY
114325: LIST
114326: LIST
114327: PUSH
114328: LD_INT 58
114330: PUSH
114331: EMPTY
114332: LIST
114333: PUSH
114334: EMPTY
114335: LIST
114336: LIST
114337: PPUSH
114338: CALL_OW 72
114342: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114343: LD_VAR 0 4
114347: PUSH
114348: LD_VAR 0 7
114352: ARRAY
114353: PPUSH
114354: CALL_OW 314
114358: NOT
114359: IFFALSE 114481
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114361: LD_ADDR_VAR 0 10
114365: PUSH
114366: LD_VAR 0 13
114370: PPUSH
114371: LD_VAR 0 4
114375: PUSH
114376: LD_VAR 0 7
114380: ARRAY
114381: PPUSH
114382: CALL_OW 74
114386: ST_TO_ADDR
// if not x then
114387: LD_VAR 0 10
114391: NOT
114392: IFFALSE 114396
// continue ;
114394: GO 113828
// if GetLives ( x ) < 1000 then
114396: LD_VAR 0 10
114400: PPUSH
114401: CALL_OW 256
114405: PUSH
114406: LD_INT 1000
114408: LESS
114409: IFFALSE 114433
// ComRepairVehicle ( group [ i ] , x ) else
114411: LD_VAR 0 4
114415: PUSH
114416: LD_VAR 0 7
114420: ARRAY
114421: PPUSH
114422: LD_VAR 0 10
114426: PPUSH
114427: CALL_OW 129
114431: GO 114481
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114433: LD_VAR 0 23
114437: PUSH
114438: LD_VAR 0 4
114442: PUSH
114443: LD_VAR 0 7
114447: ARRAY
114448: PPUSH
114449: CALL_OW 256
114453: PUSH
114454: LD_INT 1000
114456: LESS
114457: AND
114458: NOT
114459: IFFALSE 114481
// ComEnterUnit ( group [ i ] , x ) ;
114461: LD_VAR 0 4
114465: PUSH
114466: LD_VAR 0 7
114470: ARRAY
114471: PPUSH
114472: LD_VAR 0 10
114476: PPUSH
114477: CALL_OW 120
// end ; continue ;
114481: GO 113828
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114483: LD_VAR 0 23
114487: PUSH
114488: LD_VAR 0 4
114492: PUSH
114493: LD_VAR 0 7
114497: ARRAY
114498: PPUSH
114499: CALL_OW 247
114503: PUSH
114504: LD_INT 1
114506: EQUAL
114507: AND
114508: IFFALSE 114986
// begin if group [ i ] in healers then
114510: LD_VAR 0 4
114514: PUSH
114515: LD_VAR 0 7
114519: ARRAY
114520: PUSH
114521: LD_VAR 0 31
114525: IN
114526: IFFALSE 114799
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114528: LD_VAR 0 4
114532: PUSH
114533: LD_VAR 0 7
114537: ARRAY
114538: PPUSH
114539: LD_VAR 0 23
114543: PPUSH
114544: CALL_OW 308
114548: NOT
114549: PUSH
114550: LD_VAR 0 4
114554: PUSH
114555: LD_VAR 0 7
114559: ARRAY
114560: PPUSH
114561: CALL_OW 314
114565: NOT
114566: AND
114567: IFFALSE 114591
// ComMoveToArea ( group [ i ] , f_heal ) else
114569: LD_VAR 0 4
114573: PUSH
114574: LD_VAR 0 7
114578: ARRAY
114579: PPUSH
114580: LD_VAR 0 23
114584: PPUSH
114585: CALL_OW 113
114589: GO 114797
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114591: LD_VAR 0 4
114595: PUSH
114596: LD_VAR 0 7
114600: ARRAY
114601: PPUSH
114602: CALL 86785 0 1
114606: PPUSH
114607: CALL_OW 256
114611: PUSH
114612: LD_INT 1000
114614: EQUAL
114615: IFFALSE 114634
// ComStop ( group [ i ] ) else
114617: LD_VAR 0 4
114621: PUSH
114622: LD_VAR 0 7
114626: ARRAY
114627: PPUSH
114628: CALL_OW 141
114632: GO 114797
// if not HasTask ( group [ i ] ) and to_heal then
114634: LD_VAR 0 4
114638: PUSH
114639: LD_VAR 0 7
114643: ARRAY
114644: PPUSH
114645: CALL_OW 314
114649: NOT
114650: PUSH
114651: LD_VAR 0 30
114655: AND
114656: IFFALSE 114797
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114658: LD_ADDR_VAR 0 13
114662: PUSH
114663: LD_VAR 0 30
114667: PPUSH
114668: LD_INT 3
114670: PUSH
114671: LD_INT 54
114673: PUSH
114674: EMPTY
114675: LIST
114676: PUSH
114677: EMPTY
114678: LIST
114679: LIST
114680: PPUSH
114681: CALL_OW 72
114685: PPUSH
114686: LD_VAR 0 4
114690: PUSH
114691: LD_VAR 0 7
114695: ARRAY
114696: PPUSH
114697: CALL_OW 74
114701: ST_TO_ADDR
// if z then
114702: LD_VAR 0 13
114706: IFFALSE 114797
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114708: LD_INT 91
114710: PUSH
114711: LD_VAR 0 13
114715: PUSH
114716: LD_INT 10
114718: PUSH
114719: EMPTY
114720: LIST
114721: LIST
114722: LIST
114723: PUSH
114724: LD_INT 81
114726: PUSH
114727: LD_VAR 0 13
114731: PPUSH
114732: CALL_OW 255
114736: PUSH
114737: EMPTY
114738: LIST
114739: LIST
114740: PUSH
114741: EMPTY
114742: LIST
114743: LIST
114744: PPUSH
114745: CALL_OW 69
114749: PUSH
114750: LD_INT 0
114752: EQUAL
114753: IFFALSE 114777
// ComHeal ( group [ i ] , z ) else
114755: LD_VAR 0 4
114759: PUSH
114760: LD_VAR 0 7
114764: ARRAY
114765: PPUSH
114766: LD_VAR 0 13
114770: PPUSH
114771: CALL_OW 128
114775: GO 114797
// ComMoveToArea ( group [ i ] , f_heal ) ;
114777: LD_VAR 0 4
114781: PUSH
114782: LD_VAR 0 7
114786: ARRAY
114787: PPUSH
114788: LD_VAR 0 23
114792: PPUSH
114793: CALL_OW 113
// end ; continue ;
114797: GO 113828
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114799: LD_VAR 0 4
114803: PUSH
114804: LD_VAR 0 7
114808: ARRAY
114809: PPUSH
114810: CALL_OW 256
114814: PUSH
114815: LD_INT 700
114817: LESS
114818: PUSH
114819: LD_VAR 0 4
114823: PUSH
114824: LD_VAR 0 7
114828: ARRAY
114829: PUSH
114830: LD_VAR 0 30
114834: IN
114835: NOT
114836: AND
114837: IFFALSE 114861
// to_heal := to_heal union group [ i ] ;
114839: LD_ADDR_VAR 0 30
114843: PUSH
114844: LD_VAR 0 30
114848: PUSH
114849: LD_VAR 0 4
114853: PUSH
114854: LD_VAR 0 7
114858: ARRAY
114859: UNION
114860: ST_TO_ADDR
// if group [ i ] in to_heal then
114861: LD_VAR 0 4
114865: PUSH
114866: LD_VAR 0 7
114870: ARRAY
114871: PUSH
114872: LD_VAR 0 30
114876: IN
114877: IFFALSE 114986
// begin if GetLives ( group [ i ] ) = 1000 then
114879: LD_VAR 0 4
114883: PUSH
114884: LD_VAR 0 7
114888: ARRAY
114889: PPUSH
114890: CALL_OW 256
114894: PUSH
114895: LD_INT 1000
114897: EQUAL
114898: IFFALSE 114924
// to_heal := to_heal diff group [ i ] else
114900: LD_ADDR_VAR 0 30
114904: PUSH
114905: LD_VAR 0 30
114909: PUSH
114910: LD_VAR 0 4
114914: PUSH
114915: LD_VAR 0 7
114919: ARRAY
114920: DIFF
114921: ST_TO_ADDR
114922: GO 114986
// begin if not IsInArea ( group [ i ] , to_heal ) then
114924: LD_VAR 0 4
114928: PUSH
114929: LD_VAR 0 7
114933: ARRAY
114934: PPUSH
114935: LD_VAR 0 30
114939: PPUSH
114940: CALL_OW 308
114944: NOT
114945: IFFALSE 114969
// ComMoveToArea ( group [ i ] , f_heal ) else
114947: LD_VAR 0 4
114951: PUSH
114952: LD_VAR 0 7
114956: ARRAY
114957: PPUSH
114958: LD_VAR 0 23
114962: PPUSH
114963: CALL_OW 113
114967: GO 114984
// ComHold ( group [ i ] ) ;
114969: LD_VAR 0 4
114973: PUSH
114974: LD_VAR 0 7
114978: ARRAY
114979: PPUSH
114980: CALL_OW 140
// continue ;
114984: GO 113828
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114986: LD_VAR 0 4
114990: PUSH
114991: LD_VAR 0 7
114995: ARRAY
114996: PPUSH
114997: LD_INT 10
114999: PPUSH
115000: CALL 84582 0 2
115004: NOT
115005: PUSH
115006: LD_VAR 0 16
115010: PUSH
115011: LD_VAR 0 7
115015: ARRAY
115016: PUSH
115017: EMPTY
115018: EQUAL
115019: NOT
115020: AND
115021: IFFALSE 115287
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
115023: LD_VAR 0 4
115027: PUSH
115028: LD_VAR 0 7
115032: ARRAY
115033: PPUSH
115034: CALL_OW 262
115038: PUSH
115039: LD_INT 1
115041: PUSH
115042: LD_INT 2
115044: PUSH
115045: EMPTY
115046: LIST
115047: LIST
115048: IN
115049: IFFALSE 115090
// if GetFuel ( group [ i ] ) < 10 then
115051: LD_VAR 0 4
115055: PUSH
115056: LD_VAR 0 7
115060: ARRAY
115061: PPUSH
115062: CALL_OW 261
115066: PUSH
115067: LD_INT 10
115069: LESS
115070: IFFALSE 115090
// SetFuel ( group [ i ] , 12 ) ;
115072: LD_VAR 0 4
115076: PUSH
115077: LD_VAR 0 7
115081: ARRAY
115082: PPUSH
115083: LD_INT 12
115085: PPUSH
115086: CALL_OW 240
// if units_path [ i ] then
115090: LD_VAR 0 16
115094: PUSH
115095: LD_VAR 0 7
115099: ARRAY
115100: IFFALSE 115285
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
115102: LD_VAR 0 4
115106: PUSH
115107: LD_VAR 0 7
115111: ARRAY
115112: PPUSH
115113: LD_VAR 0 16
115117: PUSH
115118: LD_VAR 0 7
115122: ARRAY
115123: PUSH
115124: LD_INT 1
115126: ARRAY
115127: PUSH
115128: LD_INT 1
115130: ARRAY
115131: PPUSH
115132: LD_VAR 0 16
115136: PUSH
115137: LD_VAR 0 7
115141: ARRAY
115142: PUSH
115143: LD_INT 1
115145: ARRAY
115146: PUSH
115147: LD_INT 2
115149: ARRAY
115150: PPUSH
115151: CALL_OW 297
115155: PUSH
115156: LD_INT 6
115158: GREATER
115159: IFFALSE 115234
// begin if not HasTask ( group [ i ] ) then
115161: LD_VAR 0 4
115165: PUSH
115166: LD_VAR 0 7
115170: ARRAY
115171: PPUSH
115172: CALL_OW 314
115176: NOT
115177: IFFALSE 115232
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
115179: LD_VAR 0 4
115183: PUSH
115184: LD_VAR 0 7
115188: ARRAY
115189: PPUSH
115190: LD_VAR 0 16
115194: PUSH
115195: LD_VAR 0 7
115199: ARRAY
115200: PUSH
115201: LD_INT 1
115203: ARRAY
115204: PUSH
115205: LD_INT 1
115207: ARRAY
115208: PPUSH
115209: LD_VAR 0 16
115213: PUSH
115214: LD_VAR 0 7
115218: ARRAY
115219: PUSH
115220: LD_INT 1
115222: ARRAY
115223: PUSH
115224: LD_INT 2
115226: ARRAY
115227: PPUSH
115228: CALL_OW 114
// end else
115232: GO 115285
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
115234: LD_ADDR_VAR 0 15
115238: PUSH
115239: LD_VAR 0 16
115243: PUSH
115244: LD_VAR 0 7
115248: ARRAY
115249: PPUSH
115250: LD_INT 1
115252: PPUSH
115253: CALL_OW 3
115257: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115258: LD_ADDR_VAR 0 16
115262: PUSH
115263: LD_VAR 0 16
115267: PPUSH
115268: LD_VAR 0 7
115272: PPUSH
115273: LD_VAR 0 15
115277: PPUSH
115278: CALL_OW 1
115282: ST_TO_ADDR
// continue ;
115283: GO 113828
// end ; end ; end else
115285: GO 117949
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
115287: LD_ADDR_VAR 0 14
115291: PUSH
115292: LD_INT 81
115294: PUSH
115295: LD_VAR 0 4
115299: PUSH
115300: LD_VAR 0 7
115304: ARRAY
115305: PPUSH
115306: CALL_OW 255
115310: PUSH
115311: EMPTY
115312: LIST
115313: LIST
115314: PPUSH
115315: CALL_OW 69
115319: ST_TO_ADDR
// if not tmp then
115320: LD_VAR 0 14
115324: NOT
115325: IFFALSE 115329
// continue ;
115327: GO 113828
// if f_ignore_area then
115329: LD_VAR 0 17
115333: IFFALSE 115421
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115335: LD_ADDR_VAR 0 15
115339: PUSH
115340: LD_VAR 0 14
115344: PPUSH
115345: LD_INT 3
115347: PUSH
115348: LD_INT 92
115350: PUSH
115351: LD_VAR 0 17
115355: PUSH
115356: LD_INT 1
115358: ARRAY
115359: PUSH
115360: LD_VAR 0 17
115364: PUSH
115365: LD_INT 2
115367: ARRAY
115368: PUSH
115369: LD_VAR 0 17
115373: PUSH
115374: LD_INT 3
115376: ARRAY
115377: PUSH
115378: EMPTY
115379: LIST
115380: LIST
115381: LIST
115382: LIST
115383: PUSH
115384: EMPTY
115385: LIST
115386: LIST
115387: PPUSH
115388: CALL_OW 72
115392: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115393: LD_VAR 0 14
115397: PUSH
115398: LD_VAR 0 15
115402: DIFF
115403: IFFALSE 115421
// tmp := tmp diff tmp2 ;
115405: LD_ADDR_VAR 0 14
115409: PUSH
115410: LD_VAR 0 14
115414: PUSH
115415: LD_VAR 0 15
115419: DIFF
115420: ST_TO_ADDR
// end ; if not f_murder then
115421: LD_VAR 0 20
115425: NOT
115426: IFFALSE 115484
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115428: LD_ADDR_VAR 0 15
115432: PUSH
115433: LD_VAR 0 14
115437: PPUSH
115438: LD_INT 3
115440: PUSH
115441: LD_INT 50
115443: PUSH
115444: EMPTY
115445: LIST
115446: PUSH
115447: EMPTY
115448: LIST
115449: LIST
115450: PPUSH
115451: CALL_OW 72
115455: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115456: LD_VAR 0 14
115460: PUSH
115461: LD_VAR 0 15
115465: DIFF
115466: IFFALSE 115484
// tmp := tmp diff tmp2 ;
115468: LD_ADDR_VAR 0 14
115472: PUSH
115473: LD_VAR 0 14
115477: PUSH
115478: LD_VAR 0 15
115482: DIFF
115483: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115484: LD_ADDR_VAR 0 14
115488: PUSH
115489: LD_VAR 0 4
115493: PUSH
115494: LD_VAR 0 7
115498: ARRAY
115499: PPUSH
115500: LD_VAR 0 14
115504: PPUSH
115505: LD_INT 1
115507: PPUSH
115508: LD_INT 1
115510: PPUSH
115511: CALL 57523 0 4
115515: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115516: LD_VAR 0 4
115520: PUSH
115521: LD_VAR 0 7
115525: ARRAY
115526: PPUSH
115527: CALL_OW 257
115531: PUSH
115532: LD_INT 1
115534: EQUAL
115535: IFFALSE 115983
// begin if WantPlant ( group [ i ] ) then
115537: LD_VAR 0 4
115541: PUSH
115542: LD_VAR 0 7
115546: ARRAY
115547: PPUSH
115548: CALL 57024 0 1
115552: IFFALSE 115556
// continue ;
115554: GO 113828
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115556: LD_VAR 0 18
115560: PUSH
115561: LD_VAR 0 4
115565: PUSH
115566: LD_VAR 0 7
115570: ARRAY
115571: PPUSH
115572: CALL_OW 310
115576: NOT
115577: AND
115578: PUSH
115579: LD_VAR 0 14
115583: PUSH
115584: LD_INT 1
115586: ARRAY
115587: PUSH
115588: LD_VAR 0 14
115592: PPUSH
115593: LD_INT 21
115595: PUSH
115596: LD_INT 2
115598: PUSH
115599: EMPTY
115600: LIST
115601: LIST
115602: PUSH
115603: LD_INT 58
115605: PUSH
115606: EMPTY
115607: LIST
115608: PUSH
115609: EMPTY
115610: LIST
115611: LIST
115612: PPUSH
115613: CALL_OW 72
115617: IN
115618: AND
115619: IFFALSE 115655
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115621: LD_VAR 0 4
115625: PUSH
115626: LD_VAR 0 7
115630: ARRAY
115631: PPUSH
115632: LD_VAR 0 14
115636: PUSH
115637: LD_INT 1
115639: ARRAY
115640: PPUSH
115641: CALL_OW 120
// attacking := true ;
115645: LD_ADDR_VAR 0 29
115649: PUSH
115650: LD_INT 1
115652: ST_TO_ADDR
// continue ;
115653: GO 113828
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115655: LD_VAR 0 26
115659: PUSH
115660: LD_VAR 0 4
115664: PUSH
115665: LD_VAR 0 7
115669: ARRAY
115670: PPUSH
115671: CALL_OW 257
115675: PUSH
115676: LD_INT 1
115678: EQUAL
115679: AND
115680: PUSH
115681: LD_VAR 0 4
115685: PUSH
115686: LD_VAR 0 7
115690: ARRAY
115691: PPUSH
115692: CALL_OW 256
115696: PUSH
115697: LD_INT 800
115699: LESS
115700: AND
115701: PUSH
115702: LD_VAR 0 4
115706: PUSH
115707: LD_VAR 0 7
115711: ARRAY
115712: PPUSH
115713: CALL_OW 318
115717: NOT
115718: AND
115719: IFFALSE 115736
// ComCrawl ( group [ i ] ) ;
115721: LD_VAR 0 4
115725: PUSH
115726: LD_VAR 0 7
115730: ARRAY
115731: PPUSH
115732: CALL_OW 137
// if f_mines then
115736: LD_VAR 0 21
115740: IFFALSE 115983
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115742: LD_VAR 0 14
115746: PUSH
115747: LD_INT 1
115749: ARRAY
115750: PPUSH
115751: CALL_OW 247
115755: PUSH
115756: LD_INT 3
115758: EQUAL
115759: PUSH
115760: LD_VAR 0 14
115764: PUSH
115765: LD_INT 1
115767: ARRAY
115768: PUSH
115769: LD_VAR 0 27
115773: IN
115774: NOT
115775: AND
115776: IFFALSE 115983
// begin x := GetX ( tmp [ 1 ] ) ;
115778: LD_ADDR_VAR 0 10
115782: PUSH
115783: LD_VAR 0 14
115787: PUSH
115788: LD_INT 1
115790: ARRAY
115791: PPUSH
115792: CALL_OW 250
115796: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115797: LD_ADDR_VAR 0 11
115801: PUSH
115802: LD_VAR 0 14
115806: PUSH
115807: LD_INT 1
115809: ARRAY
115810: PPUSH
115811: CALL_OW 251
115815: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115816: LD_ADDR_VAR 0 12
115820: PUSH
115821: LD_VAR 0 4
115825: PUSH
115826: LD_VAR 0 7
115830: ARRAY
115831: PPUSH
115832: CALL 84667 0 1
115836: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115837: LD_VAR 0 4
115841: PUSH
115842: LD_VAR 0 7
115846: ARRAY
115847: PPUSH
115848: LD_VAR 0 10
115852: PPUSH
115853: LD_VAR 0 11
115857: PPUSH
115858: LD_VAR 0 14
115862: PUSH
115863: LD_INT 1
115865: ARRAY
115866: PPUSH
115867: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115871: LD_VAR 0 4
115875: PUSH
115876: LD_VAR 0 7
115880: ARRAY
115881: PPUSH
115882: LD_VAR 0 10
115886: PPUSH
115887: LD_VAR 0 12
115891: PPUSH
115892: LD_INT 7
115894: PPUSH
115895: CALL_OW 272
115899: PPUSH
115900: LD_VAR 0 11
115904: PPUSH
115905: LD_VAR 0 12
115909: PPUSH
115910: LD_INT 7
115912: PPUSH
115913: CALL_OW 273
115917: PPUSH
115918: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115922: LD_VAR 0 4
115926: PUSH
115927: LD_VAR 0 7
115931: ARRAY
115932: PPUSH
115933: LD_INT 71
115935: PPUSH
115936: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115940: LD_ADDR_VAR 0 27
115944: PUSH
115945: LD_VAR 0 27
115949: PPUSH
115950: LD_VAR 0 27
115954: PUSH
115955: LD_INT 1
115957: PLUS
115958: PPUSH
115959: LD_VAR 0 14
115963: PUSH
115964: LD_INT 1
115966: ARRAY
115967: PPUSH
115968: CALL_OW 1
115972: ST_TO_ADDR
// attacking := true ;
115973: LD_ADDR_VAR 0 29
115977: PUSH
115978: LD_INT 1
115980: ST_TO_ADDR
// continue ;
115981: GO 113828
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115983: LD_VAR 0 4
115987: PUSH
115988: LD_VAR 0 7
115992: ARRAY
115993: PPUSH
115994: CALL_OW 257
115998: PUSH
115999: LD_INT 17
116001: EQUAL
116002: PUSH
116003: LD_VAR 0 4
116007: PUSH
116008: LD_VAR 0 7
116012: ARRAY
116013: PPUSH
116014: CALL_OW 110
116018: PUSH
116019: LD_INT 71
116021: EQUAL
116022: NOT
116023: AND
116024: IFFALSE 116170
// begin attacking := false ;
116026: LD_ADDR_VAR 0 29
116030: PUSH
116031: LD_INT 0
116033: ST_TO_ADDR
// k := 5 ;
116034: LD_ADDR_VAR 0 9
116038: PUSH
116039: LD_INT 5
116041: ST_TO_ADDR
// if tmp < k then
116042: LD_VAR 0 14
116046: PUSH
116047: LD_VAR 0 9
116051: LESS
116052: IFFALSE 116064
// k := tmp ;
116054: LD_ADDR_VAR 0 9
116058: PUSH
116059: LD_VAR 0 14
116063: ST_TO_ADDR
// for j = 1 to k do
116064: LD_ADDR_VAR 0 8
116068: PUSH
116069: DOUBLE
116070: LD_INT 1
116072: DEC
116073: ST_TO_ADDR
116074: LD_VAR 0 9
116078: PUSH
116079: FOR_TO
116080: IFFALSE 116168
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
116082: LD_VAR 0 14
116086: PUSH
116087: LD_VAR 0 8
116091: ARRAY
116092: PUSH
116093: LD_VAR 0 14
116097: PPUSH
116098: LD_INT 58
116100: PUSH
116101: EMPTY
116102: LIST
116103: PPUSH
116104: CALL_OW 72
116108: IN
116109: NOT
116110: IFFALSE 116166
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116112: LD_VAR 0 4
116116: PUSH
116117: LD_VAR 0 7
116121: ARRAY
116122: PPUSH
116123: LD_VAR 0 14
116127: PUSH
116128: LD_VAR 0 8
116132: ARRAY
116133: PPUSH
116134: CALL_OW 115
// attacking := true ;
116138: LD_ADDR_VAR 0 29
116142: PUSH
116143: LD_INT 1
116145: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
116146: LD_VAR 0 4
116150: PUSH
116151: LD_VAR 0 7
116155: ARRAY
116156: PPUSH
116157: LD_INT 71
116159: PPUSH
116160: CALL_OW 109
// continue ;
116164: GO 116079
// end ; end ;
116166: GO 116079
116168: POP
116169: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
116170: LD_VAR 0 4
116174: PUSH
116175: LD_VAR 0 7
116179: ARRAY
116180: PPUSH
116181: CALL_OW 257
116185: PUSH
116186: LD_INT 8
116188: EQUAL
116189: PUSH
116190: LD_VAR 0 4
116194: PUSH
116195: LD_VAR 0 7
116199: ARRAY
116200: PPUSH
116201: CALL_OW 264
116205: PUSH
116206: LD_INT 28
116208: PUSH
116209: LD_INT 45
116211: PUSH
116212: LD_INT 7
116214: PUSH
116215: LD_INT 47
116217: PUSH
116218: EMPTY
116219: LIST
116220: LIST
116221: LIST
116222: LIST
116223: IN
116224: OR
116225: IFFALSE 116481
// begin attacking := false ;
116227: LD_ADDR_VAR 0 29
116231: PUSH
116232: LD_INT 0
116234: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
116235: LD_VAR 0 14
116239: PUSH
116240: LD_INT 1
116242: ARRAY
116243: PPUSH
116244: CALL_OW 266
116248: PUSH
116249: LD_INT 32
116251: PUSH
116252: LD_INT 31
116254: PUSH
116255: LD_INT 33
116257: PUSH
116258: LD_INT 4
116260: PUSH
116261: LD_INT 5
116263: PUSH
116264: EMPTY
116265: LIST
116266: LIST
116267: LIST
116268: LIST
116269: LIST
116270: IN
116271: IFFALSE 116457
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
116273: LD_ADDR_VAR 0 9
116277: PUSH
116278: LD_VAR 0 14
116282: PUSH
116283: LD_INT 1
116285: ARRAY
116286: PPUSH
116287: CALL_OW 266
116291: PPUSH
116292: LD_VAR 0 14
116296: PUSH
116297: LD_INT 1
116299: ARRAY
116300: PPUSH
116301: CALL_OW 250
116305: PPUSH
116306: LD_VAR 0 14
116310: PUSH
116311: LD_INT 1
116313: ARRAY
116314: PPUSH
116315: CALL_OW 251
116319: PPUSH
116320: LD_VAR 0 14
116324: PUSH
116325: LD_INT 1
116327: ARRAY
116328: PPUSH
116329: CALL_OW 254
116333: PPUSH
116334: LD_VAR 0 14
116338: PUSH
116339: LD_INT 1
116341: ARRAY
116342: PPUSH
116343: CALL_OW 248
116347: PPUSH
116348: LD_INT 0
116350: PPUSH
116351: CALL 66037 0 6
116355: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116356: LD_ADDR_VAR 0 8
116360: PUSH
116361: LD_VAR 0 4
116365: PUSH
116366: LD_VAR 0 7
116370: ARRAY
116371: PPUSH
116372: LD_VAR 0 9
116376: PPUSH
116377: CALL 84780 0 2
116381: ST_TO_ADDR
// if j then
116382: LD_VAR 0 8
116386: IFFALSE 116455
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116388: LD_VAR 0 8
116392: PUSH
116393: LD_INT 1
116395: ARRAY
116396: PPUSH
116397: LD_VAR 0 8
116401: PUSH
116402: LD_INT 2
116404: ARRAY
116405: PPUSH
116406: CALL_OW 488
116410: IFFALSE 116455
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116412: LD_VAR 0 4
116416: PUSH
116417: LD_VAR 0 7
116421: ARRAY
116422: PPUSH
116423: LD_VAR 0 8
116427: PUSH
116428: LD_INT 1
116430: ARRAY
116431: PPUSH
116432: LD_VAR 0 8
116436: PUSH
116437: LD_INT 2
116439: ARRAY
116440: PPUSH
116441: CALL_OW 116
// attacking := true ;
116445: LD_ADDR_VAR 0 29
116449: PUSH
116450: LD_INT 1
116452: ST_TO_ADDR
// continue ;
116453: GO 113828
// end ; end else
116455: GO 116481
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116457: LD_VAR 0 4
116461: PUSH
116462: LD_VAR 0 7
116466: ARRAY
116467: PPUSH
116468: LD_VAR 0 14
116472: PUSH
116473: LD_INT 1
116475: ARRAY
116476: PPUSH
116477: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116481: LD_VAR 0 4
116485: PUSH
116486: LD_VAR 0 7
116490: ARRAY
116491: PPUSH
116492: CALL_OW 265
116496: PUSH
116497: LD_INT 11
116499: EQUAL
116500: IFFALSE 116778
// begin k := 10 ;
116502: LD_ADDR_VAR 0 9
116506: PUSH
116507: LD_INT 10
116509: ST_TO_ADDR
// x := 0 ;
116510: LD_ADDR_VAR 0 10
116514: PUSH
116515: LD_INT 0
116517: ST_TO_ADDR
// if tmp < k then
116518: LD_VAR 0 14
116522: PUSH
116523: LD_VAR 0 9
116527: LESS
116528: IFFALSE 116540
// k := tmp ;
116530: LD_ADDR_VAR 0 9
116534: PUSH
116535: LD_VAR 0 14
116539: ST_TO_ADDR
// for j = k downto 1 do
116540: LD_ADDR_VAR 0 8
116544: PUSH
116545: DOUBLE
116546: LD_VAR 0 9
116550: INC
116551: ST_TO_ADDR
116552: LD_INT 1
116554: PUSH
116555: FOR_DOWNTO
116556: IFFALSE 116631
// begin if GetType ( tmp [ j ] ) = unit_human then
116558: LD_VAR 0 14
116562: PUSH
116563: LD_VAR 0 8
116567: ARRAY
116568: PPUSH
116569: CALL_OW 247
116573: PUSH
116574: LD_INT 1
116576: EQUAL
116577: IFFALSE 116629
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116579: LD_VAR 0 4
116583: PUSH
116584: LD_VAR 0 7
116588: ARRAY
116589: PPUSH
116590: LD_VAR 0 14
116594: PUSH
116595: LD_VAR 0 8
116599: ARRAY
116600: PPUSH
116601: CALL 85034 0 2
// x := tmp [ j ] ;
116605: LD_ADDR_VAR 0 10
116609: PUSH
116610: LD_VAR 0 14
116614: PUSH
116615: LD_VAR 0 8
116619: ARRAY
116620: ST_TO_ADDR
// attacking := true ;
116621: LD_ADDR_VAR 0 29
116625: PUSH
116626: LD_INT 1
116628: ST_TO_ADDR
// end ; end ;
116629: GO 116555
116631: POP
116632: POP
// if not x then
116633: LD_VAR 0 10
116637: NOT
116638: IFFALSE 116778
// begin attacking := true ;
116640: LD_ADDR_VAR 0 29
116644: PUSH
116645: LD_INT 1
116647: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116648: LD_VAR 0 4
116652: PUSH
116653: LD_VAR 0 7
116657: ARRAY
116658: PPUSH
116659: CALL_OW 250
116663: PPUSH
116664: LD_VAR 0 4
116668: PUSH
116669: LD_VAR 0 7
116673: ARRAY
116674: PPUSH
116675: CALL_OW 251
116679: PPUSH
116680: CALL_OW 546
116684: PUSH
116685: LD_INT 2
116687: ARRAY
116688: PUSH
116689: LD_VAR 0 14
116693: PUSH
116694: LD_INT 1
116696: ARRAY
116697: PPUSH
116698: CALL_OW 250
116702: PPUSH
116703: LD_VAR 0 14
116707: PUSH
116708: LD_INT 1
116710: ARRAY
116711: PPUSH
116712: CALL_OW 251
116716: PPUSH
116717: CALL_OW 546
116721: PUSH
116722: LD_INT 2
116724: ARRAY
116725: EQUAL
116726: IFFALSE 116754
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116728: LD_VAR 0 4
116732: PUSH
116733: LD_VAR 0 7
116737: ARRAY
116738: PPUSH
116739: LD_VAR 0 14
116743: PUSH
116744: LD_INT 1
116746: ARRAY
116747: PPUSH
116748: CALL 85034 0 2
116752: GO 116778
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116754: LD_VAR 0 4
116758: PUSH
116759: LD_VAR 0 7
116763: ARRAY
116764: PPUSH
116765: LD_VAR 0 14
116769: PUSH
116770: LD_INT 1
116772: ARRAY
116773: PPUSH
116774: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116778: LD_VAR 0 4
116782: PUSH
116783: LD_VAR 0 7
116787: ARRAY
116788: PPUSH
116789: CALL_OW 264
116793: PUSH
116794: LD_INT 29
116796: EQUAL
116797: IFFALSE 117163
// begin if WantsToAttack ( group [ i ] ) in bombed then
116799: LD_VAR 0 4
116803: PUSH
116804: LD_VAR 0 7
116808: ARRAY
116809: PPUSH
116810: CALL_OW 319
116814: PUSH
116815: LD_VAR 0 28
116819: IN
116820: IFFALSE 116824
// continue ;
116822: GO 113828
// k := 8 ;
116824: LD_ADDR_VAR 0 9
116828: PUSH
116829: LD_INT 8
116831: ST_TO_ADDR
// x := 0 ;
116832: LD_ADDR_VAR 0 10
116836: PUSH
116837: LD_INT 0
116839: ST_TO_ADDR
// if tmp < k then
116840: LD_VAR 0 14
116844: PUSH
116845: LD_VAR 0 9
116849: LESS
116850: IFFALSE 116862
// k := tmp ;
116852: LD_ADDR_VAR 0 9
116856: PUSH
116857: LD_VAR 0 14
116861: ST_TO_ADDR
// for j = 1 to k do
116862: LD_ADDR_VAR 0 8
116866: PUSH
116867: DOUBLE
116868: LD_INT 1
116870: DEC
116871: ST_TO_ADDR
116872: LD_VAR 0 9
116876: PUSH
116877: FOR_TO
116878: IFFALSE 117010
// begin if GetType ( tmp [ j ] ) = unit_building then
116880: LD_VAR 0 14
116884: PUSH
116885: LD_VAR 0 8
116889: ARRAY
116890: PPUSH
116891: CALL_OW 247
116895: PUSH
116896: LD_INT 3
116898: EQUAL
116899: IFFALSE 117008
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116901: LD_VAR 0 14
116905: PUSH
116906: LD_VAR 0 8
116910: ARRAY
116911: PUSH
116912: LD_VAR 0 28
116916: IN
116917: NOT
116918: PUSH
116919: LD_VAR 0 14
116923: PUSH
116924: LD_VAR 0 8
116928: ARRAY
116929: PPUSH
116930: CALL_OW 313
116934: AND
116935: IFFALSE 117008
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116937: LD_VAR 0 4
116941: PUSH
116942: LD_VAR 0 7
116946: ARRAY
116947: PPUSH
116948: LD_VAR 0 14
116952: PUSH
116953: LD_VAR 0 8
116957: ARRAY
116958: PPUSH
116959: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116963: LD_ADDR_VAR 0 28
116967: PUSH
116968: LD_VAR 0 28
116972: PPUSH
116973: LD_VAR 0 28
116977: PUSH
116978: LD_INT 1
116980: PLUS
116981: PPUSH
116982: LD_VAR 0 14
116986: PUSH
116987: LD_VAR 0 8
116991: ARRAY
116992: PPUSH
116993: CALL_OW 1
116997: ST_TO_ADDR
// attacking := true ;
116998: LD_ADDR_VAR 0 29
117002: PUSH
117003: LD_INT 1
117005: ST_TO_ADDR
// break ;
117006: GO 117010
// end ; end ;
117008: GO 116877
117010: POP
117011: POP
// if not attacking and f_attack_depot then
117012: LD_VAR 0 29
117016: NOT
117017: PUSH
117018: LD_VAR 0 25
117022: AND
117023: IFFALSE 117118
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
117025: LD_ADDR_VAR 0 13
117029: PUSH
117030: LD_VAR 0 14
117034: PPUSH
117035: LD_INT 2
117037: PUSH
117038: LD_INT 30
117040: PUSH
117041: LD_INT 0
117043: PUSH
117044: EMPTY
117045: LIST
117046: LIST
117047: PUSH
117048: LD_INT 30
117050: PUSH
117051: LD_INT 1
117053: PUSH
117054: EMPTY
117055: LIST
117056: LIST
117057: PUSH
117058: EMPTY
117059: LIST
117060: LIST
117061: LIST
117062: PPUSH
117063: CALL_OW 72
117067: ST_TO_ADDR
// if z then
117068: LD_VAR 0 13
117072: IFFALSE 117118
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
117074: LD_VAR 0 4
117078: PUSH
117079: LD_VAR 0 7
117083: ARRAY
117084: PPUSH
117085: LD_VAR 0 13
117089: PPUSH
117090: LD_VAR 0 4
117094: PUSH
117095: LD_VAR 0 7
117099: ARRAY
117100: PPUSH
117101: CALL_OW 74
117105: PPUSH
117106: CALL_OW 115
// attacking := true ;
117110: LD_ADDR_VAR 0 29
117114: PUSH
117115: LD_INT 1
117117: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
117118: LD_VAR 0 4
117122: PUSH
117123: LD_VAR 0 7
117127: ARRAY
117128: PPUSH
117129: CALL_OW 256
117133: PUSH
117134: LD_INT 500
117136: LESS
117137: IFFALSE 117163
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117139: LD_VAR 0 4
117143: PUSH
117144: LD_VAR 0 7
117148: ARRAY
117149: PPUSH
117150: LD_VAR 0 14
117154: PUSH
117155: LD_INT 1
117157: ARRAY
117158: PPUSH
117159: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
117163: LD_VAR 0 4
117167: PUSH
117168: LD_VAR 0 7
117172: ARRAY
117173: PPUSH
117174: CALL_OW 264
117178: PUSH
117179: LD_INT 49
117181: EQUAL
117182: IFFALSE 117303
// begin if not HasTask ( group [ i ] ) then
117184: LD_VAR 0 4
117188: PUSH
117189: LD_VAR 0 7
117193: ARRAY
117194: PPUSH
117195: CALL_OW 314
117199: NOT
117200: IFFALSE 117303
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
117202: LD_ADDR_VAR 0 9
117206: PUSH
117207: LD_INT 81
117209: PUSH
117210: LD_VAR 0 4
117214: PUSH
117215: LD_VAR 0 7
117219: ARRAY
117220: PPUSH
117221: CALL_OW 255
117225: PUSH
117226: EMPTY
117227: LIST
117228: LIST
117229: PPUSH
117230: CALL_OW 69
117234: PPUSH
117235: LD_VAR 0 4
117239: PUSH
117240: LD_VAR 0 7
117244: ARRAY
117245: PPUSH
117246: CALL_OW 74
117250: ST_TO_ADDR
// if k then
117251: LD_VAR 0 9
117255: IFFALSE 117303
// if GetDistUnits ( group [ i ] , k ) > 10 then
117257: LD_VAR 0 4
117261: PUSH
117262: LD_VAR 0 7
117266: ARRAY
117267: PPUSH
117268: LD_VAR 0 9
117272: PPUSH
117273: CALL_OW 296
117277: PUSH
117278: LD_INT 10
117280: GREATER
117281: IFFALSE 117303
// ComMoveUnit ( group [ i ] , k ) ;
117283: LD_VAR 0 4
117287: PUSH
117288: LD_VAR 0 7
117292: ARRAY
117293: PPUSH
117294: LD_VAR 0 9
117298: PPUSH
117299: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
117303: LD_VAR 0 4
117307: PUSH
117308: LD_VAR 0 7
117312: ARRAY
117313: PPUSH
117314: CALL_OW 256
117318: PUSH
117319: LD_INT 250
117321: LESS
117322: PUSH
117323: LD_VAR 0 4
117327: PUSH
117328: LD_VAR 0 7
117332: ARRAY
117333: PUSH
117334: LD_INT 21
117336: PUSH
117337: LD_INT 2
117339: PUSH
117340: EMPTY
117341: LIST
117342: LIST
117343: PUSH
117344: LD_INT 23
117346: PUSH
117347: LD_INT 2
117349: PUSH
117350: EMPTY
117351: LIST
117352: LIST
117353: PUSH
117354: EMPTY
117355: LIST
117356: LIST
117357: PPUSH
117358: CALL_OW 69
117362: IN
117363: AND
117364: IFFALSE 117489
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117366: LD_ADDR_VAR 0 9
117370: PUSH
117371: LD_OWVAR 3
117375: PUSH
117376: LD_VAR 0 4
117380: PUSH
117381: LD_VAR 0 7
117385: ARRAY
117386: DIFF
117387: PPUSH
117388: LD_VAR 0 4
117392: PUSH
117393: LD_VAR 0 7
117397: ARRAY
117398: PPUSH
117399: CALL_OW 74
117403: ST_TO_ADDR
// if not k then
117404: LD_VAR 0 9
117408: NOT
117409: IFFALSE 117413
// continue ;
117411: GO 113828
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117413: LD_VAR 0 9
117417: PUSH
117418: LD_INT 81
117420: PUSH
117421: LD_VAR 0 4
117425: PUSH
117426: LD_VAR 0 7
117430: ARRAY
117431: PPUSH
117432: CALL_OW 255
117436: PUSH
117437: EMPTY
117438: LIST
117439: LIST
117440: PPUSH
117441: CALL_OW 69
117445: IN
117446: PUSH
117447: LD_VAR 0 9
117451: PPUSH
117452: LD_VAR 0 4
117456: PUSH
117457: LD_VAR 0 7
117461: ARRAY
117462: PPUSH
117463: CALL_OW 296
117467: PUSH
117468: LD_INT 5
117470: LESS
117471: AND
117472: IFFALSE 117489
// ComAutodestruct ( group [ i ] ) ;
117474: LD_VAR 0 4
117478: PUSH
117479: LD_VAR 0 7
117483: ARRAY
117484: PPUSH
117485: CALL 84932 0 1
// end ; if f_attack_depot then
117489: LD_VAR 0 25
117493: IFFALSE 117605
// begin k := 6 ;
117495: LD_ADDR_VAR 0 9
117499: PUSH
117500: LD_INT 6
117502: ST_TO_ADDR
// if tmp < k then
117503: LD_VAR 0 14
117507: PUSH
117508: LD_VAR 0 9
117512: LESS
117513: IFFALSE 117525
// k := tmp ;
117515: LD_ADDR_VAR 0 9
117519: PUSH
117520: LD_VAR 0 14
117524: ST_TO_ADDR
// for j = 1 to k do
117525: LD_ADDR_VAR 0 8
117529: PUSH
117530: DOUBLE
117531: LD_INT 1
117533: DEC
117534: ST_TO_ADDR
117535: LD_VAR 0 9
117539: PUSH
117540: FOR_TO
117541: IFFALSE 117603
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117543: LD_VAR 0 8
117547: PPUSH
117548: CALL_OW 266
117552: PUSH
117553: LD_INT 0
117555: PUSH
117556: LD_INT 1
117558: PUSH
117559: EMPTY
117560: LIST
117561: LIST
117562: IN
117563: IFFALSE 117601
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117565: LD_VAR 0 4
117569: PUSH
117570: LD_VAR 0 7
117574: ARRAY
117575: PPUSH
117576: LD_VAR 0 14
117580: PUSH
117581: LD_VAR 0 8
117585: ARRAY
117586: PPUSH
117587: CALL_OW 115
// attacking := true ;
117591: LD_ADDR_VAR 0 29
117595: PUSH
117596: LD_INT 1
117598: ST_TO_ADDR
// break ;
117599: GO 117603
// end ;
117601: GO 117540
117603: POP
117604: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117605: LD_VAR 0 4
117609: PUSH
117610: LD_VAR 0 7
117614: ARRAY
117615: PPUSH
117616: CALL_OW 302
117620: PUSH
117621: LD_VAR 0 29
117625: NOT
117626: AND
117627: IFFALSE 117949
// begin if GetTag ( group [ i ] ) = 71 then
117629: LD_VAR 0 4
117633: PUSH
117634: LD_VAR 0 7
117638: ARRAY
117639: PPUSH
117640: CALL_OW 110
117644: PUSH
117645: LD_INT 71
117647: EQUAL
117648: IFFALSE 117689
// begin if HasTask ( group [ i ] ) then
117650: LD_VAR 0 4
117654: PUSH
117655: LD_VAR 0 7
117659: ARRAY
117660: PPUSH
117661: CALL_OW 314
117665: IFFALSE 117671
// continue else
117667: GO 113828
117669: GO 117689
// SetTag ( group [ i ] , 0 ) ;
117671: LD_VAR 0 4
117675: PUSH
117676: LD_VAR 0 7
117680: ARRAY
117681: PPUSH
117682: LD_INT 0
117684: PPUSH
117685: CALL_OW 109
// end ; k := 8 ;
117689: LD_ADDR_VAR 0 9
117693: PUSH
117694: LD_INT 8
117696: ST_TO_ADDR
// x := 0 ;
117697: LD_ADDR_VAR 0 10
117701: PUSH
117702: LD_INT 0
117704: ST_TO_ADDR
// if tmp < k then
117705: LD_VAR 0 14
117709: PUSH
117710: LD_VAR 0 9
117714: LESS
117715: IFFALSE 117727
// k := tmp ;
117717: LD_ADDR_VAR 0 9
117721: PUSH
117722: LD_VAR 0 14
117726: ST_TO_ADDR
// for j = 1 to k do
117727: LD_ADDR_VAR 0 8
117731: PUSH
117732: DOUBLE
117733: LD_INT 1
117735: DEC
117736: ST_TO_ADDR
117737: LD_VAR 0 9
117741: PUSH
117742: FOR_TO
117743: IFFALSE 117841
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117745: LD_VAR 0 14
117749: PUSH
117750: LD_VAR 0 8
117754: ARRAY
117755: PPUSH
117756: CALL_OW 247
117760: PUSH
117761: LD_INT 1
117763: EQUAL
117764: PUSH
117765: LD_VAR 0 14
117769: PUSH
117770: LD_VAR 0 8
117774: ARRAY
117775: PPUSH
117776: CALL_OW 256
117780: PUSH
117781: LD_INT 250
117783: LESS
117784: PUSH
117785: LD_VAR 0 20
117789: AND
117790: PUSH
117791: LD_VAR 0 20
117795: NOT
117796: PUSH
117797: LD_VAR 0 14
117801: PUSH
117802: LD_VAR 0 8
117806: ARRAY
117807: PPUSH
117808: CALL_OW 256
117812: PUSH
117813: LD_INT 250
117815: GREATEREQUAL
117816: AND
117817: OR
117818: AND
117819: IFFALSE 117839
// begin x := tmp [ j ] ;
117821: LD_ADDR_VAR 0 10
117825: PUSH
117826: LD_VAR 0 14
117830: PUSH
117831: LD_VAR 0 8
117835: ARRAY
117836: ST_TO_ADDR
// break ;
117837: GO 117841
// end ;
117839: GO 117742
117841: POP
117842: POP
// if x then
117843: LD_VAR 0 10
117847: IFFALSE 117871
// ComAttackUnit ( group [ i ] , x ) else
117849: LD_VAR 0 4
117853: PUSH
117854: LD_VAR 0 7
117858: ARRAY
117859: PPUSH
117860: LD_VAR 0 10
117864: PPUSH
117865: CALL_OW 115
117869: GO 117895
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117871: LD_VAR 0 4
117875: PUSH
117876: LD_VAR 0 7
117880: ARRAY
117881: PPUSH
117882: LD_VAR 0 14
117886: PUSH
117887: LD_INT 1
117889: ARRAY
117890: PPUSH
117891: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117895: LD_VAR 0 4
117899: PUSH
117900: LD_VAR 0 7
117904: ARRAY
117905: PPUSH
117906: CALL_OW 314
117910: NOT
117911: IFFALSE 117949
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117913: LD_VAR 0 4
117917: PUSH
117918: LD_VAR 0 7
117922: ARRAY
117923: PPUSH
117924: LD_VAR 0 14
117928: PPUSH
117929: LD_VAR 0 4
117933: PUSH
117934: LD_VAR 0 7
117938: ARRAY
117939: PPUSH
117940: CALL_OW 74
117944: PPUSH
117945: CALL_OW 115
// end ; end ; end ;
117949: GO 113828
117951: POP
117952: POP
// wait ( 0 0$2 ) ;
117953: LD_INT 70
117955: PPUSH
117956: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117960: LD_VAR 0 4
117964: NOT
117965: PUSH
117966: LD_VAR 0 4
117970: PUSH
117971: EMPTY
117972: EQUAL
117973: OR
117974: PUSH
117975: LD_INT 81
117977: PUSH
117978: LD_VAR 0 35
117982: PUSH
117983: EMPTY
117984: LIST
117985: LIST
117986: PPUSH
117987: CALL_OW 69
117991: NOT
117992: OR
117993: IFFALSE 113813
// end ;
117995: LD_VAR 0 2
117999: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
118000: LD_INT 0
118002: PPUSH
118003: PPUSH
118004: PPUSH
118005: PPUSH
118006: PPUSH
118007: PPUSH
// if not base or not mc_bases [ base ] or not solds then
118008: LD_VAR 0 1
118012: NOT
118013: PUSH
118014: LD_EXP 77
118018: PUSH
118019: LD_VAR 0 1
118023: ARRAY
118024: NOT
118025: OR
118026: PUSH
118027: LD_VAR 0 2
118031: NOT
118032: OR
118033: IFFALSE 118037
// exit ;
118035: GO 118591
// side := mc_sides [ base ] ;
118037: LD_ADDR_VAR 0 6
118041: PUSH
118042: LD_EXP 103
118046: PUSH
118047: LD_VAR 0 1
118051: ARRAY
118052: ST_TO_ADDR
// if not side then
118053: LD_VAR 0 6
118057: NOT
118058: IFFALSE 118062
// exit ;
118060: GO 118591
// for i in solds do
118062: LD_ADDR_VAR 0 7
118066: PUSH
118067: LD_VAR 0 2
118071: PUSH
118072: FOR_IN
118073: IFFALSE 118134
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
118075: LD_VAR 0 7
118079: PPUSH
118080: CALL_OW 310
118084: PPUSH
118085: CALL_OW 266
118089: PUSH
118090: LD_INT 32
118092: PUSH
118093: LD_INT 31
118095: PUSH
118096: EMPTY
118097: LIST
118098: LIST
118099: IN
118100: IFFALSE 118120
// solds := solds diff i else
118102: LD_ADDR_VAR 0 2
118106: PUSH
118107: LD_VAR 0 2
118111: PUSH
118112: LD_VAR 0 7
118116: DIFF
118117: ST_TO_ADDR
118118: GO 118132
// SetTag ( i , 18 ) ;
118120: LD_VAR 0 7
118124: PPUSH
118125: LD_INT 18
118127: PPUSH
118128: CALL_OW 109
118132: GO 118072
118134: POP
118135: POP
// if not solds then
118136: LD_VAR 0 2
118140: NOT
118141: IFFALSE 118145
// exit ;
118143: GO 118591
// repeat wait ( 0 0$2 ) ;
118145: LD_INT 70
118147: PPUSH
118148: CALL_OW 67
// enemy := mc_scan [ base ] ;
118152: LD_ADDR_VAR 0 4
118156: PUSH
118157: LD_EXP 100
118161: PUSH
118162: LD_VAR 0 1
118166: ARRAY
118167: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118168: LD_EXP 77
118172: PUSH
118173: LD_VAR 0 1
118177: ARRAY
118178: NOT
118179: PUSH
118180: LD_EXP 77
118184: PUSH
118185: LD_VAR 0 1
118189: ARRAY
118190: PUSH
118191: EMPTY
118192: EQUAL
118193: OR
118194: IFFALSE 118231
// begin for i in solds do
118196: LD_ADDR_VAR 0 7
118200: PUSH
118201: LD_VAR 0 2
118205: PUSH
118206: FOR_IN
118207: IFFALSE 118220
// ComStop ( i ) ;
118209: LD_VAR 0 7
118213: PPUSH
118214: CALL_OW 141
118218: GO 118206
118220: POP
118221: POP
// solds := [ ] ;
118222: LD_ADDR_VAR 0 2
118226: PUSH
118227: EMPTY
118228: ST_TO_ADDR
// exit ;
118229: GO 118591
// end ; for i in solds do
118231: LD_ADDR_VAR 0 7
118235: PUSH
118236: LD_VAR 0 2
118240: PUSH
118241: FOR_IN
118242: IFFALSE 118563
// begin if IsInUnit ( i ) then
118244: LD_VAR 0 7
118248: PPUSH
118249: CALL_OW 310
118253: IFFALSE 118264
// ComExitBuilding ( i ) ;
118255: LD_VAR 0 7
118259: PPUSH
118260: CALL_OW 122
// if GetLives ( i ) > 500 then
118264: LD_VAR 0 7
118268: PPUSH
118269: CALL_OW 256
118273: PUSH
118274: LD_INT 500
118276: GREATER
118277: IFFALSE 118330
// begin e := NearestUnitToUnit ( enemy , i ) ;
118279: LD_ADDR_VAR 0 5
118283: PUSH
118284: LD_VAR 0 4
118288: PPUSH
118289: LD_VAR 0 7
118293: PPUSH
118294: CALL_OW 74
118298: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
118299: LD_VAR 0 7
118303: PPUSH
118304: LD_VAR 0 5
118308: PPUSH
118309: CALL_OW 250
118313: PPUSH
118314: LD_VAR 0 5
118318: PPUSH
118319: CALL_OW 251
118323: PPUSH
118324: CALL_OW 114
// end else
118328: GO 118561
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
118330: LD_VAR 0 7
118334: PPUSH
118335: LD_EXP 77
118339: PUSH
118340: LD_VAR 0 1
118344: ARRAY
118345: PPUSH
118346: LD_INT 2
118348: PUSH
118349: LD_INT 30
118351: PUSH
118352: LD_INT 0
118354: PUSH
118355: EMPTY
118356: LIST
118357: LIST
118358: PUSH
118359: LD_INT 30
118361: PUSH
118362: LD_INT 1
118364: PUSH
118365: EMPTY
118366: LIST
118367: LIST
118368: PUSH
118369: LD_INT 30
118371: PUSH
118372: LD_INT 6
118374: PUSH
118375: EMPTY
118376: LIST
118377: LIST
118378: PUSH
118379: EMPTY
118380: LIST
118381: LIST
118382: LIST
118383: LIST
118384: PPUSH
118385: CALL_OW 72
118389: PPUSH
118390: LD_VAR 0 7
118394: PPUSH
118395: CALL_OW 74
118399: PPUSH
118400: CALL_OW 296
118404: PUSH
118405: LD_INT 10
118407: GREATER
118408: IFFALSE 118561
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118410: LD_ADDR_VAR 0 8
118414: PUSH
118415: LD_EXP 77
118419: PUSH
118420: LD_VAR 0 1
118424: ARRAY
118425: PPUSH
118426: LD_INT 2
118428: PUSH
118429: LD_INT 30
118431: PUSH
118432: LD_INT 0
118434: PUSH
118435: EMPTY
118436: LIST
118437: LIST
118438: PUSH
118439: LD_INT 30
118441: PUSH
118442: LD_INT 1
118444: PUSH
118445: EMPTY
118446: LIST
118447: LIST
118448: PUSH
118449: LD_INT 30
118451: PUSH
118452: LD_INT 6
118454: PUSH
118455: EMPTY
118456: LIST
118457: LIST
118458: PUSH
118459: EMPTY
118460: LIST
118461: LIST
118462: LIST
118463: LIST
118464: PPUSH
118465: CALL_OW 72
118469: PPUSH
118470: LD_VAR 0 7
118474: PPUSH
118475: CALL_OW 74
118479: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118480: LD_VAR 0 7
118484: PPUSH
118485: LD_VAR 0 8
118489: PPUSH
118490: CALL_OW 250
118494: PPUSH
118495: LD_INT 3
118497: PPUSH
118498: LD_INT 5
118500: PPUSH
118501: CALL_OW 272
118505: PPUSH
118506: LD_VAR 0 8
118510: PPUSH
118511: CALL_OW 251
118515: PPUSH
118516: LD_INT 3
118518: PPUSH
118519: LD_INT 5
118521: PPUSH
118522: CALL_OW 273
118526: PPUSH
118527: CALL_OW 111
// SetTag ( i , 0 ) ;
118531: LD_VAR 0 7
118535: PPUSH
118536: LD_INT 0
118538: PPUSH
118539: CALL_OW 109
// solds := solds diff i ;
118543: LD_ADDR_VAR 0 2
118547: PUSH
118548: LD_VAR 0 2
118552: PUSH
118553: LD_VAR 0 7
118557: DIFF
118558: ST_TO_ADDR
// continue ;
118559: GO 118241
// end ; end ;
118561: GO 118241
118563: POP
118564: POP
// until not solds or not enemy ;
118565: LD_VAR 0 2
118569: NOT
118570: PUSH
118571: LD_VAR 0 4
118575: NOT
118576: OR
118577: IFFALSE 118145
// MC_Reset ( base , 18 ) ;
118579: LD_VAR 0 1
118583: PPUSH
118584: LD_INT 18
118586: PPUSH
118587: CALL 25448 0 2
// end ;
118591: LD_VAR 0 3
118595: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
118596: LD_INT 0
118598: PPUSH
118599: PPUSH
118600: PPUSH
118601: PPUSH
118602: PPUSH
118603: PPUSH
118604: PPUSH
118605: PPUSH
118606: PPUSH
118607: PPUSH
118608: PPUSH
118609: PPUSH
118610: PPUSH
118611: PPUSH
118612: PPUSH
118613: PPUSH
118614: PPUSH
118615: PPUSH
118616: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118617: LD_ADDR_VAR 0 12
118621: PUSH
118622: LD_EXP 77
118626: PUSH
118627: LD_VAR 0 1
118631: ARRAY
118632: PPUSH
118633: LD_INT 25
118635: PUSH
118636: LD_INT 3
118638: PUSH
118639: EMPTY
118640: LIST
118641: LIST
118642: PPUSH
118643: CALL_OW 72
118647: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118648: LD_EXP 117
118652: PUSH
118653: LD_VAR 0 1
118657: ARRAY
118658: IFFALSE 118682
// mechs := mechs diff mc_remote_driver [ base ] ;
118660: LD_ADDR_VAR 0 12
118664: PUSH
118665: LD_VAR 0 12
118669: PUSH
118670: LD_EXP 117
118674: PUSH
118675: LD_VAR 0 1
118679: ARRAY
118680: DIFF
118681: ST_TO_ADDR
// for i in mechs do
118682: LD_ADDR_VAR 0 4
118686: PUSH
118687: LD_VAR 0 12
118691: PUSH
118692: FOR_IN
118693: IFFALSE 118728
// if GetTag ( i ) > 0 then
118695: LD_VAR 0 4
118699: PPUSH
118700: CALL_OW 110
118704: PUSH
118705: LD_INT 0
118707: GREATER
118708: IFFALSE 118726
// mechs := mechs diff i ;
118710: LD_ADDR_VAR 0 12
118714: PUSH
118715: LD_VAR 0 12
118719: PUSH
118720: LD_VAR 0 4
118724: DIFF
118725: ST_TO_ADDR
118726: GO 118692
118728: POP
118729: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118730: LD_ADDR_VAR 0 8
118734: PUSH
118735: LD_EXP 77
118739: PUSH
118740: LD_VAR 0 1
118744: ARRAY
118745: PPUSH
118746: LD_INT 2
118748: PUSH
118749: LD_INT 25
118751: PUSH
118752: LD_INT 1
118754: PUSH
118755: EMPTY
118756: LIST
118757: LIST
118758: PUSH
118759: LD_INT 25
118761: PUSH
118762: LD_INT 5
118764: PUSH
118765: EMPTY
118766: LIST
118767: LIST
118768: PUSH
118769: LD_INT 25
118771: PUSH
118772: LD_INT 8
118774: PUSH
118775: EMPTY
118776: LIST
118777: LIST
118778: PUSH
118779: LD_INT 25
118781: PUSH
118782: LD_INT 9
118784: PUSH
118785: EMPTY
118786: LIST
118787: LIST
118788: PUSH
118789: EMPTY
118790: LIST
118791: LIST
118792: LIST
118793: LIST
118794: LIST
118795: PPUSH
118796: CALL_OW 72
118800: ST_TO_ADDR
// if not defenders and not solds then
118801: LD_VAR 0 2
118805: NOT
118806: PUSH
118807: LD_VAR 0 8
118811: NOT
118812: AND
118813: IFFALSE 118817
// exit ;
118815: GO 120587
// depot_under_attack := false ;
118817: LD_ADDR_VAR 0 16
118821: PUSH
118822: LD_INT 0
118824: ST_TO_ADDR
// sold_defenders := [ ] ;
118825: LD_ADDR_VAR 0 17
118829: PUSH
118830: EMPTY
118831: ST_TO_ADDR
// if mechs then
118832: LD_VAR 0 12
118836: IFFALSE 118989
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
118838: LD_ADDR_VAR 0 4
118842: PUSH
118843: LD_VAR 0 2
118847: PPUSH
118848: LD_INT 21
118850: PUSH
118851: LD_INT 2
118853: PUSH
118854: EMPTY
118855: LIST
118856: LIST
118857: PPUSH
118858: CALL_OW 72
118862: PUSH
118863: FOR_IN
118864: IFFALSE 118987
// begin if GetTag ( i ) <> 20 then
118866: LD_VAR 0 4
118870: PPUSH
118871: CALL_OW 110
118875: PUSH
118876: LD_INT 20
118878: NONEQUAL
118879: IFFALSE 118893
// SetTag ( i , 20 ) ;
118881: LD_VAR 0 4
118885: PPUSH
118886: LD_INT 20
118888: PPUSH
118889: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
118893: LD_VAR 0 4
118897: PPUSH
118898: CALL_OW 263
118902: PUSH
118903: LD_INT 1
118905: EQUAL
118906: PUSH
118907: LD_VAR 0 4
118911: PPUSH
118912: CALL_OW 311
118916: NOT
118917: AND
118918: IFFALSE 118985
// begin un := mechs [ 1 ] ;
118920: LD_ADDR_VAR 0 10
118924: PUSH
118925: LD_VAR 0 12
118929: PUSH
118930: LD_INT 1
118932: ARRAY
118933: ST_TO_ADDR
// ComExit ( un ) ;
118934: LD_VAR 0 10
118938: PPUSH
118939: CALL 89798 0 1
// AddComEnterUnit ( un , i ) ;
118943: LD_VAR 0 10
118947: PPUSH
118948: LD_VAR 0 4
118952: PPUSH
118953: CALL_OW 180
// SetTag ( un , 19 ) ;
118957: LD_VAR 0 10
118961: PPUSH
118962: LD_INT 19
118964: PPUSH
118965: CALL_OW 109
// mechs := mechs diff un ;
118969: LD_ADDR_VAR 0 12
118973: PUSH
118974: LD_VAR 0 12
118978: PUSH
118979: LD_VAR 0 10
118983: DIFF
118984: ST_TO_ADDR
// end ; end ;
118985: GO 118863
118987: POP
118988: POP
// if solds then
118989: LD_VAR 0 8
118993: IFFALSE 119052
// for i in solds do
118995: LD_ADDR_VAR 0 4
118999: PUSH
119000: LD_VAR 0 8
119004: PUSH
119005: FOR_IN
119006: IFFALSE 119050
// if not GetTag ( i ) then
119008: LD_VAR 0 4
119012: PPUSH
119013: CALL_OW 110
119017: NOT
119018: IFFALSE 119048
// begin defenders := defenders union i ;
119020: LD_ADDR_VAR 0 2
119024: PUSH
119025: LD_VAR 0 2
119029: PUSH
119030: LD_VAR 0 4
119034: UNION
119035: ST_TO_ADDR
// SetTag ( i , 18 ) ;
119036: LD_VAR 0 4
119040: PPUSH
119041: LD_INT 18
119043: PPUSH
119044: CALL_OW 109
// end ;
119048: GO 119005
119050: POP
119051: POP
// repeat wait ( 0 0$2 ) ;
119052: LD_INT 70
119054: PPUSH
119055: CALL_OW 67
// enemy := mc_scan [ base ] ;
119059: LD_ADDR_VAR 0 21
119063: PUSH
119064: LD_EXP 100
119068: PUSH
119069: LD_VAR 0 1
119073: ARRAY
119074: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119075: LD_EXP 77
119079: PUSH
119080: LD_VAR 0 1
119084: ARRAY
119085: NOT
119086: PUSH
119087: LD_EXP 77
119091: PUSH
119092: LD_VAR 0 1
119096: ARRAY
119097: PUSH
119098: EMPTY
119099: EQUAL
119100: OR
119101: IFFALSE 119138
// begin for i in defenders do
119103: LD_ADDR_VAR 0 4
119107: PUSH
119108: LD_VAR 0 2
119112: PUSH
119113: FOR_IN
119114: IFFALSE 119127
// ComStop ( i ) ;
119116: LD_VAR 0 4
119120: PPUSH
119121: CALL_OW 141
119125: GO 119113
119127: POP
119128: POP
// defenders := [ ] ;
119129: LD_ADDR_VAR 0 2
119133: PUSH
119134: EMPTY
119135: ST_TO_ADDR
// exit ;
119136: GO 120587
// end ; for i in defenders do
119138: LD_ADDR_VAR 0 4
119142: PUSH
119143: LD_VAR 0 2
119147: PUSH
119148: FOR_IN
119149: IFFALSE 120047
// begin e := NearestUnitToUnit ( enemy , i ) ;
119151: LD_ADDR_VAR 0 13
119155: PUSH
119156: LD_VAR 0 21
119160: PPUSH
119161: LD_VAR 0 4
119165: PPUSH
119166: CALL_OW 74
119170: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
119171: LD_ADDR_VAR 0 7
119175: PUSH
119176: LD_EXP 77
119180: PUSH
119181: LD_VAR 0 1
119185: ARRAY
119186: PPUSH
119187: LD_INT 2
119189: PUSH
119190: LD_INT 30
119192: PUSH
119193: LD_INT 0
119195: PUSH
119196: EMPTY
119197: LIST
119198: LIST
119199: PUSH
119200: LD_INT 30
119202: PUSH
119203: LD_INT 1
119205: PUSH
119206: EMPTY
119207: LIST
119208: LIST
119209: PUSH
119210: EMPTY
119211: LIST
119212: LIST
119213: LIST
119214: PPUSH
119215: CALL_OW 72
119219: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
119220: LD_ADDR_VAR 0 16
119224: PUSH
119225: LD_VAR 0 7
119229: NOT
119230: PUSH
119231: LD_VAR 0 7
119235: PPUSH
119236: LD_INT 3
119238: PUSH
119239: LD_INT 24
119241: PUSH
119242: LD_INT 600
119244: PUSH
119245: EMPTY
119246: LIST
119247: LIST
119248: PUSH
119249: EMPTY
119250: LIST
119251: LIST
119252: PPUSH
119253: CALL_OW 72
119257: OR
119258: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
119259: LD_VAR 0 4
119263: PPUSH
119264: CALL_OW 247
119268: PUSH
119269: LD_INT 2
119271: DOUBLE
119272: EQUAL
119273: IFTRUE 119277
119275: GO 119673
119277: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
119278: LD_VAR 0 4
119282: PPUSH
119283: CALL_OW 256
119287: PUSH
119288: LD_INT 1000
119290: EQUAL
119291: PUSH
119292: LD_VAR 0 4
119296: PPUSH
119297: LD_VAR 0 13
119301: PPUSH
119302: CALL_OW 296
119306: PUSH
119307: LD_INT 40
119309: LESS
119310: PUSH
119311: LD_VAR 0 13
119315: PPUSH
119316: LD_EXP 102
119320: PUSH
119321: LD_VAR 0 1
119325: ARRAY
119326: PPUSH
119327: CALL_OW 308
119331: OR
119332: AND
119333: IFFALSE 119455
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119335: LD_VAR 0 4
119339: PPUSH
119340: CALL_OW 262
119344: PUSH
119345: LD_INT 1
119347: EQUAL
119348: PUSH
119349: LD_VAR 0 4
119353: PPUSH
119354: CALL_OW 261
119358: PUSH
119359: LD_INT 30
119361: LESS
119362: AND
119363: PUSH
119364: LD_VAR 0 7
119368: AND
119369: IFFALSE 119439
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119371: LD_VAR 0 4
119375: PPUSH
119376: LD_VAR 0 7
119380: PPUSH
119381: LD_VAR 0 4
119385: PPUSH
119386: CALL_OW 74
119390: PPUSH
119391: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119395: LD_VAR 0 4
119399: PPUSH
119400: LD_VAR 0 7
119404: PPUSH
119405: LD_VAR 0 4
119409: PPUSH
119410: CALL_OW 74
119414: PPUSH
119415: CALL_OW 296
119419: PUSH
119420: LD_INT 6
119422: LESS
119423: IFFALSE 119437
// SetFuel ( i , 100 ) ;
119425: LD_VAR 0 4
119429: PPUSH
119430: LD_INT 100
119432: PPUSH
119433: CALL_OW 240
// end else
119437: GO 119453
// ComAttackUnit ( i , e ) ;
119439: LD_VAR 0 4
119443: PPUSH
119444: LD_VAR 0 13
119448: PPUSH
119449: CALL_OW 115
// end else
119453: GO 119556
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119455: LD_VAR 0 13
119459: PPUSH
119460: LD_EXP 102
119464: PUSH
119465: LD_VAR 0 1
119469: ARRAY
119470: PPUSH
119471: CALL_OW 308
119475: NOT
119476: PUSH
119477: LD_VAR 0 4
119481: PPUSH
119482: LD_VAR 0 13
119486: PPUSH
119487: CALL_OW 296
119491: PUSH
119492: LD_INT 40
119494: GREATEREQUAL
119495: AND
119496: PUSH
119497: LD_VAR 0 4
119501: PPUSH
119502: CALL_OW 256
119506: PUSH
119507: LD_INT 650
119509: LESSEQUAL
119510: OR
119511: PUSH
119512: LD_VAR 0 4
119516: PPUSH
119517: LD_EXP 101
119521: PUSH
119522: LD_VAR 0 1
119526: ARRAY
119527: PPUSH
119528: CALL_OW 308
119532: NOT
119533: AND
119534: IFFALSE 119556
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119536: LD_VAR 0 4
119540: PPUSH
119541: LD_EXP 101
119545: PUSH
119546: LD_VAR 0 1
119550: ARRAY
119551: PPUSH
119552: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119556: LD_VAR 0 4
119560: PPUSH
119561: CALL_OW 256
119565: PUSH
119566: LD_INT 1000
119568: LESS
119569: PUSH
119570: LD_VAR 0 4
119574: PPUSH
119575: CALL_OW 263
119579: PUSH
119580: LD_INT 1
119582: EQUAL
119583: AND
119584: PUSH
119585: LD_VAR 0 4
119589: PPUSH
119590: CALL_OW 311
119594: AND
119595: PUSH
119596: LD_VAR 0 4
119600: PPUSH
119601: LD_EXP 101
119605: PUSH
119606: LD_VAR 0 1
119610: ARRAY
119611: PPUSH
119612: CALL_OW 308
119616: AND
119617: IFFALSE 119671
// begin mech := IsDrivenBy ( i ) ;
119619: LD_ADDR_VAR 0 9
119623: PUSH
119624: LD_VAR 0 4
119628: PPUSH
119629: CALL_OW 311
119633: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119634: LD_VAR 0 9
119638: PPUSH
119639: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119643: LD_VAR 0 9
119647: PPUSH
119648: LD_VAR 0 4
119652: PPUSH
119653: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119657: LD_VAR 0 9
119661: PPUSH
119662: LD_VAR 0 4
119666: PPUSH
119667: CALL_OW 180
// end ; end ; unit_human :
119671: GO 120018
119673: LD_INT 1
119675: DOUBLE
119676: EQUAL
119677: IFTRUE 119681
119679: GO 120017
119681: POP
// begin b := IsInUnit ( i ) ;
119682: LD_ADDR_VAR 0 18
119686: PUSH
119687: LD_VAR 0 4
119691: PPUSH
119692: CALL_OW 310
119696: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119697: LD_ADDR_VAR 0 19
119701: PUSH
119702: LD_VAR 0 18
119706: NOT
119707: PUSH
119708: LD_VAR 0 18
119712: PPUSH
119713: CALL_OW 266
119717: PUSH
119718: LD_INT 32
119720: PUSH
119721: LD_INT 31
119723: PUSH
119724: EMPTY
119725: LIST
119726: LIST
119727: IN
119728: OR
119729: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
119730: LD_VAR 0 18
119734: PPUSH
119735: CALL_OW 266
119739: PUSH
119740: LD_INT 5
119742: EQUAL
119743: PUSH
119744: LD_VAR 0 4
119748: PPUSH
119749: CALL_OW 257
119753: PUSH
119754: LD_INT 1
119756: PUSH
119757: LD_INT 2
119759: PUSH
119760: LD_INT 3
119762: PUSH
119763: LD_INT 4
119765: PUSH
119766: EMPTY
119767: LIST
119768: LIST
119769: LIST
119770: LIST
119771: IN
119772: AND
119773: IFFALSE 119810
// begin class := AllowSpecClass ( i ) ;
119775: LD_ADDR_VAR 0 20
119779: PUSH
119780: LD_VAR 0 4
119784: PPUSH
119785: CALL 53737 0 1
119789: ST_TO_ADDR
// if class then
119790: LD_VAR 0 20
119794: IFFALSE 119810
// ComChangeProfession ( i , class ) ;
119796: LD_VAR 0 4
119800: PPUSH
119801: LD_VAR 0 20
119805: PPUSH
119806: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119810: LD_VAR 0 16
119814: PUSH
119815: LD_VAR 0 2
119819: PPUSH
119820: LD_INT 21
119822: PUSH
119823: LD_INT 2
119825: PUSH
119826: EMPTY
119827: LIST
119828: LIST
119829: PPUSH
119830: CALL_OW 72
119834: PUSH
119835: LD_INT 1
119837: LESSEQUAL
119838: OR
119839: PUSH
119840: LD_VAR 0 19
119844: AND
119845: PUSH
119846: LD_VAR 0 4
119850: PUSH
119851: LD_VAR 0 17
119855: IN
119856: NOT
119857: AND
119858: IFFALSE 119951
// begin if b then
119860: LD_VAR 0 18
119864: IFFALSE 119913
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119866: LD_VAR 0 18
119870: PPUSH
119871: LD_VAR 0 21
119875: PPUSH
119876: LD_VAR 0 18
119880: PPUSH
119881: CALL_OW 74
119885: PPUSH
119886: CALL_OW 296
119890: PUSH
119891: LD_INT 10
119893: LESS
119894: PUSH
119895: LD_VAR 0 18
119899: PPUSH
119900: CALL_OW 461
119904: PUSH
119905: LD_INT 7
119907: NONEQUAL
119908: AND
119909: IFFALSE 119913
// continue ;
119911: GO 119148
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119913: LD_ADDR_VAR 0 17
119917: PUSH
119918: LD_VAR 0 17
119922: PPUSH
119923: LD_VAR 0 17
119927: PUSH
119928: LD_INT 1
119930: PLUS
119931: PPUSH
119932: LD_VAR 0 4
119936: PPUSH
119937: CALL_OW 1
119941: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119942: LD_VAR 0 4
119946: PPUSH
119947: CALL_OW 122
// end ; if sold_defenders then
119951: LD_VAR 0 17
119955: IFFALSE 120015
// if i in sold_defenders then
119957: LD_VAR 0 4
119961: PUSH
119962: LD_VAR 0 17
119966: IN
119967: IFFALSE 120015
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119969: LD_VAR 0 4
119973: PPUSH
119974: CALL_OW 314
119978: NOT
119979: PUSH
119980: LD_VAR 0 4
119984: PPUSH
119985: LD_VAR 0 13
119989: PPUSH
119990: CALL_OW 296
119994: PUSH
119995: LD_INT 30
119997: LESS
119998: AND
119999: IFFALSE 120015
// ComAttackUnit ( i , e ) ;
120001: LD_VAR 0 4
120005: PPUSH
120006: LD_VAR 0 13
120010: PPUSH
120011: CALL_OW 115
// end ; end ; end ;
120015: GO 120018
120017: POP
// if IsDead ( i ) then
120018: LD_VAR 0 4
120022: PPUSH
120023: CALL_OW 301
120027: IFFALSE 120045
// defenders := defenders diff i ;
120029: LD_ADDR_VAR 0 2
120033: PUSH
120034: LD_VAR 0 2
120038: PUSH
120039: LD_VAR 0 4
120043: DIFF
120044: ST_TO_ADDR
// end ;
120045: GO 119148
120047: POP
120048: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
120049: LD_VAR 0 21
120053: NOT
120054: PUSH
120055: LD_VAR 0 2
120059: NOT
120060: OR
120061: PUSH
120062: LD_EXP 77
120066: PUSH
120067: LD_VAR 0 1
120071: ARRAY
120072: NOT
120073: OR
120074: IFFALSE 119052
// MC_Reset ( base , 18 ) ;
120076: LD_VAR 0 1
120080: PPUSH
120081: LD_INT 18
120083: PPUSH
120084: CALL 25448 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
120088: LD_ADDR_VAR 0 2
120092: PUSH
120093: LD_VAR 0 2
120097: PUSH
120098: LD_VAR 0 2
120102: PPUSH
120103: LD_INT 2
120105: PUSH
120106: LD_INT 25
120108: PUSH
120109: LD_INT 1
120111: PUSH
120112: EMPTY
120113: LIST
120114: LIST
120115: PUSH
120116: LD_INT 25
120118: PUSH
120119: LD_INT 5
120121: PUSH
120122: EMPTY
120123: LIST
120124: LIST
120125: PUSH
120126: LD_INT 25
120128: PUSH
120129: LD_INT 8
120131: PUSH
120132: EMPTY
120133: LIST
120134: LIST
120135: PUSH
120136: LD_INT 25
120138: PUSH
120139: LD_INT 9
120141: PUSH
120142: EMPTY
120143: LIST
120144: LIST
120145: PUSH
120146: EMPTY
120147: LIST
120148: LIST
120149: LIST
120150: LIST
120151: LIST
120152: PPUSH
120153: CALL_OW 72
120157: DIFF
120158: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
120159: LD_VAR 0 21
120163: NOT
120164: PUSH
120165: LD_VAR 0 2
120169: PPUSH
120170: LD_INT 21
120172: PUSH
120173: LD_INT 2
120175: PUSH
120176: EMPTY
120177: LIST
120178: LIST
120179: PPUSH
120180: CALL_OW 72
120184: AND
120185: IFFALSE 120523
// begin tmp := FilterByTag ( defenders , 19 ) ;
120187: LD_ADDR_VAR 0 11
120191: PUSH
120192: LD_VAR 0 2
120196: PPUSH
120197: LD_INT 19
120199: PPUSH
120200: CALL 86974 0 2
120204: ST_TO_ADDR
// if tmp then
120205: LD_VAR 0 11
120209: IFFALSE 120279
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
120211: LD_ADDR_VAR 0 11
120215: PUSH
120216: LD_VAR 0 11
120220: PPUSH
120221: LD_INT 25
120223: PUSH
120224: LD_INT 3
120226: PUSH
120227: EMPTY
120228: LIST
120229: LIST
120230: PPUSH
120231: CALL_OW 72
120235: ST_TO_ADDR
// if tmp then
120236: LD_VAR 0 11
120240: IFFALSE 120279
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
120242: LD_ADDR_EXP 89
120246: PUSH
120247: LD_EXP 89
120251: PPUSH
120252: LD_VAR 0 1
120256: PPUSH
120257: LD_EXP 89
120261: PUSH
120262: LD_VAR 0 1
120266: ARRAY
120267: PUSH
120268: LD_VAR 0 11
120272: UNION
120273: PPUSH
120274: CALL_OW 1
120278: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
120279: LD_VAR 0 1
120283: PPUSH
120284: LD_INT 19
120286: PPUSH
120287: CALL 25448 0 2
// repeat wait ( 0 0$1 ) ;
120291: LD_INT 35
120293: PPUSH
120294: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120298: LD_EXP 77
120302: PUSH
120303: LD_VAR 0 1
120307: ARRAY
120308: NOT
120309: PUSH
120310: LD_EXP 77
120314: PUSH
120315: LD_VAR 0 1
120319: ARRAY
120320: PUSH
120321: EMPTY
120322: EQUAL
120323: OR
120324: IFFALSE 120361
// begin for i in defenders do
120326: LD_ADDR_VAR 0 4
120330: PUSH
120331: LD_VAR 0 2
120335: PUSH
120336: FOR_IN
120337: IFFALSE 120350
// ComStop ( i ) ;
120339: LD_VAR 0 4
120343: PPUSH
120344: CALL_OW 141
120348: GO 120336
120350: POP
120351: POP
// defenders := [ ] ;
120352: LD_ADDR_VAR 0 2
120356: PUSH
120357: EMPTY
120358: ST_TO_ADDR
// exit ;
120359: GO 120587
// end ; for i in defenders do
120361: LD_ADDR_VAR 0 4
120365: PUSH
120366: LD_VAR 0 2
120370: PUSH
120371: FOR_IN
120372: IFFALSE 120461
// begin if not IsInArea ( i , mc_parking [ base ] ) then
120374: LD_VAR 0 4
120378: PPUSH
120379: LD_EXP 101
120383: PUSH
120384: LD_VAR 0 1
120388: ARRAY
120389: PPUSH
120390: CALL_OW 308
120394: NOT
120395: IFFALSE 120419
// ComMoveToArea ( i , mc_parking [ base ] ) else
120397: LD_VAR 0 4
120401: PPUSH
120402: LD_EXP 101
120406: PUSH
120407: LD_VAR 0 1
120411: ARRAY
120412: PPUSH
120413: CALL_OW 113
120417: GO 120459
// if GetControl ( i ) = control_manual then
120419: LD_VAR 0 4
120423: PPUSH
120424: CALL_OW 263
120428: PUSH
120429: LD_INT 1
120431: EQUAL
120432: IFFALSE 120459
// if IsDrivenBy ( i ) then
120434: LD_VAR 0 4
120438: PPUSH
120439: CALL_OW 311
120443: IFFALSE 120459
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120445: LD_VAR 0 4
120449: PPUSH
120450: CALL_OW 311
120454: PPUSH
120455: CALL_OW 121
// end ;
120459: GO 120371
120461: POP
120462: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120463: LD_VAR 0 2
120467: PPUSH
120468: LD_INT 95
120470: PUSH
120471: LD_EXP 101
120475: PUSH
120476: LD_VAR 0 1
120480: ARRAY
120481: PUSH
120482: EMPTY
120483: LIST
120484: LIST
120485: PPUSH
120486: CALL_OW 72
120490: PUSH
120491: LD_VAR 0 2
120495: EQUAL
120496: PUSH
120497: LD_EXP 100
120501: PUSH
120502: LD_VAR 0 1
120506: ARRAY
120507: OR
120508: PUSH
120509: LD_EXP 77
120513: PUSH
120514: LD_VAR 0 1
120518: ARRAY
120519: NOT
120520: OR
120521: IFFALSE 120291
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
120523: LD_ADDR_EXP 99
120527: PUSH
120528: LD_EXP 99
120532: PPUSH
120533: LD_VAR 0 1
120537: PPUSH
120538: LD_VAR 0 2
120542: PPUSH
120543: LD_INT 21
120545: PUSH
120546: LD_INT 2
120548: PUSH
120549: EMPTY
120550: LIST
120551: LIST
120552: PPUSH
120553: CALL_OW 72
120557: PPUSH
120558: CALL_OW 1
120562: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
120563: LD_VAR 0 1
120567: PPUSH
120568: LD_INT 19
120570: PPUSH
120571: CALL 25448 0 2
// MC_Reset ( base , 20 ) ;
120575: LD_VAR 0 1
120579: PPUSH
120580: LD_INT 20
120582: PPUSH
120583: CALL 25448 0 2
// end ; end_of_file
120587: LD_VAR 0 3
120591: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
120592: LD_VAR 0 1
120596: PUSH
120597: LD_INT 200
120599: DOUBLE
120600: GREATEREQUAL
120601: IFFALSE 120609
120603: LD_INT 299
120605: DOUBLE
120606: LESSEQUAL
120607: IFTRUE 120611
120609: GO 120643
120611: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
120612: LD_VAR 0 1
120616: PPUSH
120617: LD_VAR 0 2
120621: PPUSH
120622: LD_VAR 0 3
120626: PPUSH
120627: LD_VAR 0 4
120631: PPUSH
120632: LD_VAR 0 5
120636: PPUSH
120637: CALL 109378 0 5
120641: GO 120720
120643: LD_INT 300
120645: DOUBLE
120646: GREATEREQUAL
120647: IFFALSE 120655
120649: LD_INT 399
120651: DOUBLE
120652: LESSEQUAL
120653: IFTRUE 120657
120655: GO 120719
120657: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
120658: LD_VAR 0 1
120662: PPUSH
120663: LD_VAR 0 2
120667: PPUSH
120668: LD_VAR 0 3
120672: PPUSH
120673: LD_VAR 0 4
120677: PPUSH
120678: LD_VAR 0 5
120682: PPUSH
120683: LD_VAR 0 6
120687: PPUSH
120688: LD_VAR 0 7
120692: PPUSH
120693: LD_VAR 0 8
120697: PPUSH
120698: LD_VAR 0 9
120702: PPUSH
120703: LD_VAR 0 10
120707: PPUSH
120708: LD_VAR 0 11
120712: PPUSH
120713: CALL 105711 0 11
120717: GO 120720
120719: POP
// end ;
120720: PPOPN 11
120722: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
120723: LD_VAR 0 1
120727: PPUSH
120728: LD_VAR 0 2
120732: PPUSH
120733: LD_VAR 0 3
120737: PPUSH
120738: LD_VAR 0 4
120742: PPUSH
120743: LD_VAR 0 5
120747: PPUSH
120748: CALL 109114 0 5
// end ; end_of_file
120752: PPOPN 5
120754: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
120755: LD_VAR 0 1
120759: PPUSH
120760: LD_VAR 0 2
120764: PPUSH
120765: LD_VAR 0 3
120769: PPUSH
120770: LD_VAR 0 4
120774: PPUSH
120775: LD_VAR 0 5
120779: PPUSH
120780: LD_VAR 0 6
120784: PPUSH
120785: CALL 93404 0 6
// end ;
120789: PPOPN 6
120791: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
120792: LD_INT 0
120794: PPUSH
// begin if not units then
120795: LD_VAR 0 1
120799: NOT
120800: IFFALSE 120804
// exit ;
120802: GO 120804
// end ;
120804: PPOPN 7
120806: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
120807: CALL 93375 0 0
// end ;
120811: PPOPN 1
120813: END
