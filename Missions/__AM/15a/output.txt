// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20640 0 0
// InitNature ;
  19: CALL 17182 0 0
// InitArtifact ;
  23: CALL 17795 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4579 0 0
// PrepareAlliance ;
  44: CALL 1375 0 0
// PrepareArabian ;
  48: CALL 6347 0 0
// PrepareRussian ;
  52: CALL 8332 0 0
// PrepareLegion ;
  56: CALL 6775 0 0
// Action ;
  60: CALL 10885 0 0
// MC_Start ( ) ;
  64: CALL 22752 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// end ;
 208: LD_VAR 0 1
 212: RET
// export function CustomInitMacro ( ) ; begin
 213: LD_INT 0
 215: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 216: LD_ADDR_EXP 112
 220: PUSH
 221: LD_INT 26
 223: PUSH
 224: LD_INT 1
 226: PUSH
 227: LD_INT 4
 229: PUSH
 230: LD_INT 8
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 239: LD_ADDR_EXP 113
 243: PUSH
 244: LD_INT 27
 246: PUSH
 247: LD_INT 2
 249: PUSH
 250: LD_INT 3
 252: PUSH
 253: LD_INT 7
 255: PUSH
 256: EMPTY
 257: LIST
 258: LIST
 259: LIST
 260: LIST
 261: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 262: LD_INT 1
 264: PPUSH
 265: LD_INT 6
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: LD_INT 9
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: PPUSH
 285: LD_INT 28
 287: PPUSH
 288: CALL 43953 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 292: LD_INT 1
 294: PPUSH
 295: LD_INT 10
 297: PUSH
 298: LD_INT 11
 300: PUSH
 301: LD_INT 13
 303: PUSH
 304: LD_INT 15
 306: PUSH
 307: EMPTY
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: PPUSH
 313: CALL 45013 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 317: LD_INT 1
 319: PPUSH
 320: LD_INT 29
 322: PUSH
 323: EMPTY
 324: LIST
 325: PPUSH
 326: CALL 45106 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 330: LD_ADDR_EXP 117
 334: PUSH
 335: LD_EXP 117
 339: PPUSH
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 22
 345: PUSH
 346: LD_INT 2
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: PUSH
 353: LD_INT 25
 355: PUSH
 356: LD_INT 15
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PPUSH
 367: CALL_OW 69
 371: PPUSH
 372: CALL_OW 1
 376: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 377: LD_INT 1
 379: PPUSH
 380: LD_INT 13
 382: PUSH
 383: LD_INT 2
 385: PUSH
 386: LD_INT 1
 388: PUSH
 389: LD_INT 31
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: PUSH
 398: LD_INT 13
 400: PUSH
 401: LD_INT 2
 403: PUSH
 404: LD_INT 1
 406: PUSH
 407: LD_INT 31
 409: PUSH
 410: EMPTY
 411: LIST
 412: LIST
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 13
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 1
 424: PUSH
 425: LD_INT 28
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PUSH
 434: LD_INT 13
 436: PUSH
 437: LD_INT 1
 439: PUSH
 440: LD_INT 1
 442: PUSH
 443: LD_INT 28
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: PUSH
 452: LD_INT 13
 454: PUSH
 455: LD_INT 1
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: LD_INT 28
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: PUSH
 470: LD_INT 13
 472: PUSH
 473: LD_INT 1
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: LD_INT 28
 481: PUSH
 482: EMPTY
 483: LIST
 484: LIST
 485: LIST
 486: LIST
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: PPUSH
 496: CALL 44271 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 500: LD_INT 1
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL 44456 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 510: LD_INT 2
 512: PPUSH
 513: LD_INT 10
 515: PUSH
 516: LD_INT 11
 518: PUSH
 519: LD_INT 12
 521: PUSH
 522: LD_INT 14
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PPUSH
 531: CALL 45013 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 14
 540: PUSH
 541: EMPTY
 542: LIST
 543: PPUSH
 544: CALL 45106 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 21
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 3
 559: PUSH
 560: LD_INT 51
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_INT 22
 571: PUSH
 572: LD_INT 3
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: LD_INT 52
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 22
 589: PUSH
 590: LD_INT 3
 592: PUSH
 593: LD_INT 3
 595: PUSH
 596: LD_INT 52
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_INT 24
 607: PUSH
 608: LD_INT 3
 610: PUSH
 611: LD_INT 3
 613: PUSH
 614: LD_INT 47
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: LD_INT 24
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 3
 631: PUSH
 632: LD_INT 47
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: PUSH
 641: LD_INT 24
 643: PUSH
 644: LD_INT 3
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 47
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 24
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 47
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 24
 679: PUSH
 680: LD_INT 3
 682: PUSH
 683: LD_INT 3
 685: PUSH
 686: LD_INT 47
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: LIST
 693: LIST
 694: PUSH
 695: EMPTY
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: LIST
 703: LIST
 704: PPUSH
 705: CALL 44271 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 709: LD_INT 2
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL 44456 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 719: LD_INT 2
 721: PPUSH
 722: LD_INT 0
 724: PPUSH
 725: CALL 44886 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 729: LD_INT 3
 731: PPUSH
 732: LD_INT 10
 734: PUSH
 735: LD_INT 12
 737: PUSH
 738: LD_INT 15
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: PUSH
 746: LD_OWVAR 67
 750: ARRAY
 751: PPUSH
 752: LD_INT 24
 754: PPUSH
 755: CALL 43953 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 759: LD_INT 3
 761: PPUSH
 762: LD_INT 10
 764: PUSH
 765: LD_INT 11
 767: PUSH
 768: LD_INT 13
 770: PUSH
 771: LD_INT 15
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: LIST
 778: LIST
 779: PPUSH
 780: CALL 45013 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 13
 789: PUSH
 790: EMPTY
 791: LIST
 792: PPUSH
 793: CALL 45106 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 797: LD_ADDR_EXP 117
 801: PUSH
 802: LD_EXP 117
 806: PPUSH
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 22
 812: PUSH
 813: LD_INT 8
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: PUSH
 820: LD_INT 25
 822: PUSH
 823: LD_INT 15
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PPUSH
 834: CALL_OW 69
 838: PPUSH
 839: CALL_OW 1
 843: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 844: LD_INT 3
 846: PPUSH
 847: LD_INT 13
 849: PUSH
 850: LD_INT 2
 852: PUSH
 853: LD_INT 1
 855: PUSH
 856: LD_INT 31
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: PUSH
 865: LD_INT 13
 867: PUSH
 868: LD_INT 2
 870: PUSH
 871: LD_INT 1
 873: PUSH
 874: LD_INT 31
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 13
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 2
 891: PUSH
 892: LD_INT 32
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PUSH
 901: LD_INT 14
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 1
 909: PUSH
 910: LD_INT 28
 912: PUSH
 913: EMPTY
 914: LIST
 915: LIST
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 14
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: LD_INT 1
 927: PUSH
 928: LD_INT 28
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 14
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 1
 945: PUSH
 946: LD_INT 28
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 14
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 28
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PPUSH
 982: CALL 44271 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 986: LD_INT 3
 988: PPUSH
 989: LD_INT 4
 991: PPUSH
 992: CALL 44456 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 996: LD_INT 4
 998: PPUSH
 999: LD_INT 10
1001: PUSH
1002: LD_INT 12
1004: PUSH
1005: LD_INT 11
1007: PUSH
1008: LD_INT 15
1010: PUSH
1011: EMPTY
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL 45013 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1021: LD_INT 4
1023: PPUSH
1024: LD_INT 33
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL 45106 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1034: LD_INT 4
1036: PPUSH
1037: LD_INT 5
1039: PUSH
1040: LD_INT 6
1042: PUSH
1043: LD_INT 7
1045: PUSH
1046: LD_INT 9
1048: PUSH
1049: LD_INT 10
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PPUSH
1059: CALL 45424 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1063: LD_INT 4
1065: PPUSH
1066: LD_INT 54
1068: PPUSH
1069: LD_INT 85
1071: PPUSH
1072: LD_INT 2
1074: PPUSH
1075: LD_INT 25
1077: PUSH
1078: LD_INT 16
1080: PUSH
1081: LD_INT 17
1083: PUSH
1084: LD_INT 18
1086: PUSH
1087: LD_INT 22
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: LIST
1095: LIST
1096: PPUSH
1097: CALL 45218 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1101: LD_INT 4
1103: PPUSH
1104: LD_INT 5
1106: PUSH
1107: LD_INT 1
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: LD_INT 7
1115: PUSH
1116: EMPTY
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 1
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: LD_INT 6
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 5
1142: PUSH
1143: LD_INT 1
1145: PUSH
1146: LD_INT 1
1148: PUSH
1149: LD_INT 7
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 5
1160: PUSH
1161: LD_INT 1
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 6
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 5
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 3
1184: PUSH
1185: LD_INT 12
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 3
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 3
1202: PUSH
1203: LD_INT 13
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: PPUSH
1220: CALL 44271 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1224: LD_INT 4
1226: PPUSH
1227: LD_INT 4
1229: PPUSH
1230: CALL 44456 0 2
// MC_SetTame ( 4 , powellApe ) ;
1234: LD_INT 4
1236: PPUSH
1237: LD_INT 11
1239: PPUSH
1240: CALL 44837 0 2
// end ;
1244: LD_VAR 0 1
1248: RET
// every 0 0$1 trigger debug do var i ;
1249: LD_EXP 1
1253: IFFALSE 1351
1255: GO 1257
1257: DISABLE
1258: LD_INT 0
1260: PPUSH
// begin enable ;
1261: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1262: LD_ADDR_VAR 0 1
1266: PUSH
1267: LD_INT 22
1269: PUSH
1270: LD_INT 7
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 2
1279: PUSH
1280: LD_INT 21
1282: PUSH
1283: LD_INT 1
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: PUSH
1290: LD_INT 21
1292: PUSH
1293: LD_INT 2
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 3
1307: PUSH
1308: LD_INT 24
1310: PUSH
1311: LD_INT 1000
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL_OW 69
1331: PUSH
1332: FOR_IN
1333: IFFALSE 1349
// SetLives ( i , 1000 ) ;
1335: LD_VAR 0 1
1339: PPUSH
1340: LD_INT 1000
1342: PPUSH
1343: CALL_OW 234
1347: GO 1332
1349: POP
1350: POP
// end ;
1351: PPOPN 1
1353: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1354: LD_EXP 16
1358: PUSH
1359: LD_INT 5
1361: GREATEREQUAL
1362: IFFALSE 1374
1364: GO 1366
1366: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1367: LD_STRING ACH_ARTIFACT
1369: PPUSH
1370: CALL_OW 543
1374: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1375: LD_INT 0
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
// uc_side := 7 ;
1382: LD_ADDR_OWVAR 20
1386: PUSH
1387: LD_INT 7
1389: ST_TO_ADDR
// tmp := [ ] ;
1390: LD_ADDR_VAR 0 5
1394: PUSH
1395: EMPTY
1396: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1397: LD_ADDR_EXP 17
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: LD_STRING 14a_
1413: PPUSH
1414: CALL 50663 0 3
1418: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1419: LD_ADDR_EXP 49
1423: PUSH
1424: LD_STRING Burlak
1426: PPUSH
1427: LD_EXP 1
1431: NOT
1432: PPUSH
1433: LD_STRING 14a_
1435: PPUSH
1436: CALL 50663 0 3
1440: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1441: LD_ADDR_EXP 32
1445: PUSH
1446: LD_STRING Joan
1448: PPUSH
1449: LD_EXP 1
1453: NOT
1454: PPUSH
1455: LD_STRING 13a_
1457: PPUSH
1458: CALL 50663 0 3
1462: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1463: LD_ADDR_EXP 18
1467: PUSH
1468: LD_STRING Roth
1470: PPUSH
1471: LD_EXP 1
1475: NOT
1476: PPUSH
1477: LD_STRING 13a_
1479: PPUSH
1480: CALL 50663 0 3
1484: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1485: LD_ADDR_EXP 35
1489: PUSH
1490: LD_STRING Gossudarov
1492: PPUSH
1493: LD_EXP 1
1497: NOT
1498: PPUSH
1499: LD_STRING 13a_
1501: PPUSH
1502: CALL 50663 0 3
1506: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1507: LD_ADDR_EXP 23
1511: PUSH
1512: LD_STRING Denis
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: LD_STRING 13a_
1523: PPUSH
1524: CALL 50663 0 3
1528: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1529: LD_ADDR_EXP 33
1533: PUSH
1534: LD_STRING DeltaDoctor
1536: PPUSH
1537: LD_EXP 1
1541: NOT
1542: PPUSH
1543: LD_STRING 13a_
1545: PPUSH
1546: CALL 50663 0 3
1550: ST_TO_ADDR
// if DeltaDoctor then
1551: LD_EXP 33
1555: IFFALSE 1573
// tmp := tmp ^ DeltaDoctor ;
1557: LD_ADDR_VAR 0 5
1561: PUSH
1562: LD_VAR 0 5
1566: PUSH
1567: LD_EXP 33
1571: ADD
1572: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1573: LD_ADDR_EXP 31
1577: PUSH
1578: LD_STRING Simms
1580: PPUSH
1581: LD_EXP 1
1585: NOT
1586: PPUSH
1587: LD_STRING 13a_
1589: PPUSH
1590: CALL 50663 0 3
1594: ST_TO_ADDR
// if Simms then
1595: LD_EXP 31
1599: IFFALSE 1617
// tmp := tmp ^ Simms ;
1601: LD_ADDR_VAR 0 5
1605: PUSH
1606: LD_VAR 0 5
1610: PUSH
1611: LD_EXP 31
1615: ADD
1616: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1617: LD_ADDR_EXP 29
1621: PUSH
1622: LD_STRING Frank
1624: PPUSH
1625: LD_EXP 1
1629: NOT
1630: PPUSH
1631: LD_STRING 13a_
1633: PPUSH
1634: CALL 50663 0 3
1638: ST_TO_ADDR
// if Frank then
1639: LD_EXP 29
1643: IFFALSE 1661
// tmp := tmp ^ Frank ;
1645: LD_ADDR_VAR 0 5
1649: PUSH
1650: LD_VAR 0 5
1654: PUSH
1655: LD_EXP 29
1659: ADD
1660: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1661: LD_ADDR_EXP 36
1665: PUSH
1666: LD_STRING Kirilenkova
1668: PPUSH
1669: LD_EXP 1
1673: NOT
1674: PPUSH
1675: LD_STRING 13a_
1677: PPUSH
1678: CALL 50663 0 3
1682: ST_TO_ADDR
// if Kirilenkova then
1683: LD_EXP 36
1687: IFFALSE 1705
// tmp := tmp ^ Kirilenkova ;
1689: LD_ADDR_VAR 0 5
1693: PUSH
1694: LD_VAR 0 5
1698: PUSH
1699: LD_EXP 36
1703: ADD
1704: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1705: LD_ADDR_EXP 37
1709: PUSH
1710: LD_STRING Titov
1712: PPUSH
1713: LD_EXP 1
1717: NOT
1718: PPUSH
1719: LD_STRING 13a_
1721: PPUSH
1722: CALL 50663 0 3
1726: ST_TO_ADDR
// if Titov then
1727: LD_EXP 37
1731: IFFALSE 1749
// tmp := tmp ^ Titov ;
1733: LD_ADDR_VAR 0 5
1737: PUSH
1738: LD_VAR 0 5
1742: PUSH
1743: LD_EXP 37
1747: ADD
1748: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1749: LD_ADDR_EXP 38
1753: PUSH
1754: LD_STRING Fadeev
1756: PPUSH
1757: LD_EXP 1
1761: NOT
1762: PPUSH
1763: LD_STRING 13a_
1765: PPUSH
1766: CALL 50663 0 3
1770: ST_TO_ADDR
// if Fadeev then
1771: LD_EXP 38
1775: IFFALSE 1793
// tmp := tmp ^ Fadeev ;
1777: LD_ADDR_VAR 0 5
1781: PUSH
1782: LD_VAR 0 5
1786: PUSH
1787: LD_EXP 38
1791: ADD
1792: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1793: LD_ADDR_EXP 39
1797: PUSH
1798: LD_STRING Dolgov
1800: PPUSH
1801: LD_EXP 1
1805: NOT
1806: PPUSH
1807: LD_STRING 13a_
1809: PPUSH
1810: CALL 50663 0 3
1814: ST_TO_ADDR
// if Dolgov then
1815: LD_EXP 39
1819: IFFALSE 1837
// tmp := tmp ^ Dolgov ;
1821: LD_ADDR_VAR 0 5
1825: PUSH
1826: LD_VAR 0 5
1830: PUSH
1831: LD_EXP 39
1835: ADD
1836: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1837: LD_ADDR_EXP 40
1841: PUSH
1842: LD_STRING Petrosyan
1844: PPUSH
1845: LD_EXP 1
1849: NOT
1850: PPUSH
1851: LD_STRING 13a_
1853: PPUSH
1854: CALL 50663 0 3
1858: ST_TO_ADDR
// if Petrosyan then
1859: LD_EXP 40
1863: IFFALSE 1881
// tmp := tmp ^ Petrosyan ;
1865: LD_ADDR_VAR 0 5
1869: PUSH
1870: LD_VAR 0 5
1874: PUSH
1875: LD_EXP 40
1879: ADD
1880: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1881: LD_ADDR_EXP 41
1885: PUSH
1886: LD_STRING Scholtze
1888: PPUSH
1889: LD_EXP 1
1893: NOT
1894: PPUSH
1895: LD_STRING 13a_
1897: PPUSH
1898: CALL 50663 0 3
1902: ST_TO_ADDR
// if Scholtze then
1903: LD_EXP 41
1907: IFFALSE 1925
// tmp := tmp ^ Scholtze ;
1909: LD_ADDR_VAR 0 5
1913: PUSH
1914: LD_VAR 0 5
1918: PUSH
1919: LD_EXP 41
1923: ADD
1924: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1925: LD_ADDR_EXP 42
1929: PUSH
1930: LD_STRING Oblukov
1932: PPUSH
1933: LD_EXP 1
1937: NOT
1938: PPUSH
1939: LD_STRING 13a_
1941: PPUSH
1942: CALL 50663 0 3
1946: ST_TO_ADDR
// if Oblukov then
1947: LD_EXP 42
1951: IFFALSE 1969
// tmp := tmp ^ Oblukov ;
1953: LD_ADDR_VAR 0 5
1957: PUSH
1958: LD_VAR 0 5
1962: PUSH
1963: LD_EXP 42
1967: ADD
1968: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1969: LD_ADDR_EXP 43
1973: PUSH
1974: LD_STRING Kapitsova
1976: PPUSH
1977: LD_EXP 1
1981: NOT
1982: PPUSH
1983: LD_STRING 13a_
1985: PPUSH
1986: CALL 50663 0 3
1990: ST_TO_ADDR
// if Kapitsova then
1991: LD_EXP 43
1995: IFFALSE 2013
// tmp := tmp ^ Kapitsova ;
1997: LD_ADDR_VAR 0 5
2001: PUSH
2002: LD_VAR 0 5
2006: PUSH
2007: LD_EXP 43
2011: ADD
2012: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2013: LD_ADDR_EXP 44
2017: PUSH
2018: LD_STRING Lipshchin
2020: PPUSH
2021: LD_EXP 1
2025: NOT
2026: PPUSH
2027: LD_STRING 13a_
2029: PPUSH
2030: CALL 50663 0 3
2034: ST_TO_ADDR
// if Lipshchin then
2035: LD_EXP 44
2039: IFFALSE 2057
// tmp := tmp ^ Lipshchin ;
2041: LD_ADDR_VAR 0 5
2045: PUSH
2046: LD_VAR 0 5
2050: PUSH
2051: LD_EXP 44
2055: ADD
2056: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2057: LD_ADDR_EXP 45
2061: PUSH
2062: LD_STRING Petrovova
2064: PPUSH
2065: LD_EXP 1
2069: NOT
2070: PPUSH
2071: LD_STRING 13a_
2073: PPUSH
2074: CALL 50663 0 3
2078: ST_TO_ADDR
// if Petrovova then
2079: LD_EXP 45
2083: IFFALSE 2101
// tmp := tmp ^ Petrovova ;
2085: LD_ADDR_VAR 0 5
2089: PUSH
2090: LD_VAR 0 5
2094: PUSH
2095: LD_EXP 45
2099: ADD
2100: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2101: LD_ADDR_EXP 46
2105: PUSH
2106: LD_STRING Kovalyuk
2108: PPUSH
2109: LD_EXP 1
2113: NOT
2114: PPUSH
2115: LD_STRING 13a_
2117: PPUSH
2118: CALL 50663 0 3
2122: ST_TO_ADDR
// if Kovalyuk then
2123: LD_EXP 46
2127: IFFALSE 2145
// tmp := tmp ^ Kovalyuk ;
2129: LD_ADDR_VAR 0 5
2133: PUSH
2134: LD_VAR 0 5
2138: PUSH
2139: LD_EXP 46
2143: ADD
2144: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2145: LD_ADDR_EXP 47
2149: PUSH
2150: LD_STRING Kuzmov
2152: PPUSH
2153: LD_EXP 1
2157: NOT
2158: PPUSH
2159: LD_STRING 13a_
2161: PPUSH
2162: CALL 50663 0 3
2166: ST_TO_ADDR
// if Kuzmov then
2167: LD_EXP 47
2171: IFFALSE 2189
// tmp := tmp ^ Kuzmov ;
2173: LD_ADDR_VAR 0 5
2177: PUSH
2178: LD_VAR 0 5
2182: PUSH
2183: LD_EXP 47
2187: ADD
2188: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2189: LD_ADDR_EXP 48
2193: PUSH
2194: LD_STRING Karamazov
2196: PPUSH
2197: LD_EXP 1
2201: NOT
2202: PPUSH
2203: LD_STRING 13a_
2205: PPUSH
2206: CALL 50663 0 3
2210: ST_TO_ADDR
// if Karamazov then
2211: LD_EXP 48
2215: IFFALSE 2233
// tmp := tmp ^ Karamazov ;
2217: LD_ADDR_VAR 0 5
2221: PUSH
2222: LD_VAR 0 5
2226: PUSH
2227: LD_EXP 48
2231: ADD
2232: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2233: LD_ADDR_EXP 50
2237: PUSH
2238: LD_STRING Belkov
2240: PPUSH
2241: LD_EXP 1
2245: NOT
2246: PPUSH
2247: LD_STRING 13a_
2249: PPUSH
2250: CALL 50663 0 3
2254: ST_TO_ADDR
// if Belkov then
2255: LD_EXP 50
2259: IFFALSE 2277
// tmp := tmp ^ Belkov ;
2261: LD_ADDR_VAR 0 5
2265: PUSH
2266: LD_VAR 0 5
2270: PUSH
2271: LD_EXP 50
2275: ADD
2276: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2277: LD_ADDR_EXP 51
2281: PUSH
2282: LD_STRING Gnyevko
2284: PPUSH
2285: LD_EXP 1
2289: NOT
2290: PPUSH
2291: LD_STRING 13a_
2293: PPUSH
2294: CALL 50663 0 3
2298: ST_TO_ADDR
// if Gnyevko then
2299: LD_EXP 51
2303: IFFALSE 2321
// tmp := tmp ^ Gnyevko ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PUSH
2315: LD_EXP 51
2319: ADD
2320: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2321: LD_ADDR_EXP 34
2325: PUSH
2326: LD_STRING Coonie
2328: PPUSH
2329: CALL_OW 25
2333: ST_TO_ADDR
// if not Lisa then
2334: LD_EXP 19
2338: NOT
2339: IFFALSE 2385
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2341: LD_ADDR_EXP 19
2345: PUSH
2346: LD_STRING Lisa
2348: PPUSH
2349: LD_EXP 1
2353: NOT
2354: PPUSH
2355: LD_STRING 13a_
2357: PPUSH
2358: CALL 50663 0 3
2362: ST_TO_ADDR
// if Lisa then
2363: LD_EXP 19
2367: IFFALSE 2385
// tmp := tmp ^ Lisa ;
2369: LD_ADDR_VAR 0 5
2373: PUSH
2374: LD_VAR 0 5
2378: PUSH
2379: LD_EXP 19
2383: ADD
2384: ST_TO_ADDR
// end ; if not Donaldson then
2385: LD_EXP 20
2389: NOT
2390: IFFALSE 2436
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2392: LD_ADDR_EXP 20
2396: PUSH
2397: LD_STRING Donaldson
2399: PPUSH
2400: LD_EXP 1
2404: NOT
2405: PPUSH
2406: LD_STRING 13a_
2408: PPUSH
2409: CALL 50663 0 3
2413: ST_TO_ADDR
// if Donaldson then
2414: LD_EXP 20
2418: IFFALSE 2436
// tmp := tmp ^ Donaldson ;
2420: LD_ADDR_VAR 0 5
2424: PUSH
2425: LD_VAR 0 5
2429: PUSH
2430: LD_EXP 20
2434: ADD
2435: ST_TO_ADDR
// end ; if not Bobby then
2436: LD_EXP 21
2440: NOT
2441: IFFALSE 2487
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2443: LD_ADDR_EXP 21
2447: PUSH
2448: LD_STRING Bobby
2450: PPUSH
2451: LD_EXP 1
2455: NOT
2456: PPUSH
2457: LD_STRING 13a_
2459: PPUSH
2460: CALL 50663 0 3
2464: ST_TO_ADDR
// if Bobby then
2465: LD_EXP 21
2469: IFFALSE 2487
// tmp := tmp ^ Bobby ;
2471: LD_ADDR_VAR 0 5
2475: PUSH
2476: LD_VAR 0 5
2480: PUSH
2481: LD_EXP 21
2485: ADD
2486: ST_TO_ADDR
// end ; if not Cyrus then
2487: LD_EXP 22
2491: NOT
2492: IFFALSE 2538
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2494: LD_ADDR_EXP 22
2498: PUSH
2499: LD_STRING Cyrus
2501: PPUSH
2502: LD_EXP 1
2506: NOT
2507: PPUSH
2508: LD_STRING 13a_
2510: PPUSH
2511: CALL 50663 0 3
2515: ST_TO_ADDR
// if Cyrus then
2516: LD_EXP 22
2520: IFFALSE 2538
// tmp := tmp ^ Cyrus ;
2522: LD_ADDR_VAR 0 5
2526: PUSH
2527: LD_VAR 0 5
2531: PUSH
2532: LD_EXP 22
2536: ADD
2537: ST_TO_ADDR
// end ; if not Brown then
2538: LD_EXP 24
2542: NOT
2543: IFFALSE 2589
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2545: LD_ADDR_EXP 24
2549: PUSH
2550: LD_STRING Brown
2552: PPUSH
2553: LD_EXP 1
2557: NOT
2558: PPUSH
2559: LD_STRING 13a_
2561: PPUSH
2562: CALL 50663 0 3
2566: ST_TO_ADDR
// if Brown then
2567: LD_EXP 24
2571: IFFALSE 2589
// tmp := tmp ^ Brown ;
2573: LD_ADDR_VAR 0 5
2577: PUSH
2578: LD_VAR 0 5
2582: PUSH
2583: LD_EXP 24
2587: ADD
2588: ST_TO_ADDR
// end ; if not Gladstone then
2589: LD_EXP 25
2593: NOT
2594: IFFALSE 2640
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2596: LD_ADDR_EXP 25
2600: PUSH
2601: LD_STRING Gladstone
2603: PPUSH
2604: LD_EXP 1
2608: NOT
2609: PPUSH
2610: LD_STRING 13a_
2612: PPUSH
2613: CALL 50663 0 3
2617: ST_TO_ADDR
// if Gladstone then
2618: LD_EXP 25
2622: IFFALSE 2640
// tmp := tmp ^ Gladstone ;
2624: LD_ADDR_VAR 0 5
2628: PUSH
2629: LD_VAR 0 5
2633: PUSH
2634: LD_EXP 25
2638: ADD
2639: ST_TO_ADDR
// end ; if not Cornel then
2640: LD_EXP 27
2644: NOT
2645: IFFALSE 2691
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2647: LD_ADDR_EXP 27
2651: PUSH
2652: LD_STRING Cornel
2654: PPUSH
2655: LD_EXP 1
2659: NOT
2660: PPUSH
2661: LD_STRING 13a_
2663: PPUSH
2664: CALL 50663 0 3
2668: ST_TO_ADDR
// if Cornel then
2669: LD_EXP 27
2673: IFFALSE 2691
// tmp := tmp ^ Cornel ;
2675: LD_ADDR_VAR 0 5
2679: PUSH
2680: LD_VAR 0 5
2684: PUSH
2685: LD_EXP 27
2689: ADD
2690: ST_TO_ADDR
// end ; if not Houten then
2691: LD_EXP 26
2695: NOT
2696: IFFALSE 2742
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2698: LD_ADDR_EXP 26
2702: PUSH
2703: LD_STRING Houten
2705: PPUSH
2706: LD_EXP 1
2710: NOT
2711: PPUSH
2712: LD_STRING 13a_
2714: PPUSH
2715: CALL 50663 0 3
2719: ST_TO_ADDR
// if Houten then
2720: LD_EXP 26
2724: IFFALSE 2742
// tmp := tmp ^ Houten ;
2726: LD_ADDR_VAR 0 5
2730: PUSH
2731: LD_VAR 0 5
2735: PUSH
2736: LD_EXP 26
2740: ADD
2741: ST_TO_ADDR
// end ; if not Gary then
2742: LD_EXP 28
2746: NOT
2747: IFFALSE 2793
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2749: LD_ADDR_EXP 28
2753: PUSH
2754: LD_STRING Gary
2756: PPUSH
2757: LD_EXP 1
2761: NOT
2762: PPUSH
2763: LD_STRING 13a_
2765: PPUSH
2766: CALL 50663 0 3
2770: ST_TO_ADDR
// if Gary then
2771: LD_EXP 28
2775: IFFALSE 2793
// tmp := tmp ^ Gary ;
2777: LD_ADDR_VAR 0 5
2781: PUSH
2782: LD_VAR 0 5
2786: PUSH
2787: LD_EXP 28
2791: ADD
2792: ST_TO_ADDR
// end ; if not Kikuchi then
2793: LD_EXP 30
2797: NOT
2798: IFFALSE 2844
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2800: LD_ADDR_EXP 30
2804: PUSH
2805: LD_STRING Kikuchi
2807: PPUSH
2808: LD_EXP 1
2812: NOT
2813: PPUSH
2814: LD_STRING 13a_
2816: PPUSH
2817: CALL 50663 0 3
2821: ST_TO_ADDR
// if Kikuchi then
2822: LD_EXP 30
2826: IFFALSE 2844
// tmp := tmp ^ Kikuchi ;
2828: LD_ADDR_VAR 0 5
2832: PUSH
2833: LD_VAR 0 5
2837: PUSH
2838: LD_EXP 30
2842: ADD
2843: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_VAR 0 5
2853: PUSH
2854: LD_STRING 13a_others
2856: PPUSH
2857: CALL_OW 31
2861: UNION
2862: ST_TO_ADDR
// tmp := tmp diff 0 ;
2863: LD_ADDR_VAR 0 5
2867: PUSH
2868: LD_VAR 0 5
2872: PUSH
2873: LD_INT 0
2875: DIFF
2876: ST_TO_ADDR
// if tmp < 15 then
2877: LD_VAR 0 5
2881: PUSH
2882: LD_INT 15
2884: LESS
2885: IFFALSE 2973
// for i = 15 downto tmp do
2887: LD_ADDR_VAR 0 2
2891: PUSH
2892: DOUBLE
2893: LD_INT 15
2895: INC
2896: ST_TO_ADDR
2897: LD_VAR 0 5
2901: PUSH
2902: FOR_DOWNTO
2903: IFFALSE 2971
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2905: LD_ADDR_OWVAR 21
2909: PUSH
2910: LD_INT 1
2912: PUSH
2913: LD_INT 3
2915: PUSH
2916: EMPTY
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 1
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: CALL_OW 12
2930: ARRAY
2931: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2932: LD_INT 0
2934: PPUSH
2935: LD_INT 1
2937: PPUSH
2938: LD_INT 4
2940: PPUSH
2941: CALL_OW 12
2945: PPUSH
2946: LD_INT 8
2948: PPUSH
2949: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2953: LD_ADDR_VAR 0 5
2957: PUSH
2958: LD_VAR 0 5
2962: PUSH
2963: CALL_OW 44
2967: ADD
2968: ST_TO_ADDR
// end ;
2969: GO 2902
2971: POP
2972: POP
// if not debug then
2973: LD_EXP 1
2977: NOT
2978: IFFALSE 3150
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2980: LD_ADDR_VAR 0 4
2984: PUSH
2985: LD_STRING 
2987: PPUSH
2988: LD_INT 15
2990: PUSH
2991: LD_INT 14
2993: PUSH
2994: LD_INT 13
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: LIST
3001: PUSH
3002: LD_OWVAR 67
3006: ARRAY
3007: PPUSH
3008: LD_INT 15
3010: PUSH
3011: LD_INT 14
3013: PUSH
3014: LD_INT 13
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: LIST
3021: PUSH
3022: LD_OWVAR 67
3026: ARRAY
3027: PPUSH
3028: LD_INT -6
3030: PUSH
3031: LD_EXP 17
3035: PUSH
3036: LD_EXP 49
3040: PUSH
3041: LD_EXP 18
3045: PUSH
3046: LD_EXP 32
3050: PUSH
3051: LD_EXP 23
3055: PUSH
3056: LD_EXP 35
3060: PUSH
3061: LD_INT -2
3063: PUSH
3064: LD_INT -3
3066: PUSH
3067: LD_INT -5
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PUSH
3082: LD_VAR 0 5
3086: ADD
3087: PPUSH
3088: LD_INT 1
3090: PUSH
3091: LD_INT 4
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: LD_INT 1
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 3
3106: PUSH
3107: LD_INT 5
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 9
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 3
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PPUSH
3143: CALL_OW 42
3147: ST_TO_ADDR
3148: GO 3229
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3150: LD_ADDR_VAR 0 4
3154: PUSH
3155: LD_EXP 37
3159: PUSH
3160: LD_EXP 38
3164: PUSH
3165: LD_EXP 39
3169: PUSH
3170: LD_EXP 40
3174: PUSH
3175: LD_EXP 41
3179: PUSH
3180: LD_EXP 42
3184: PUSH
3185: LD_EXP 43
3189: PUSH
3190: LD_EXP 44
3194: PUSH
3195: LD_EXP 45
3199: PUSH
3200: LD_EXP 46
3204: PUSH
3205: LD_EXP 47
3209: PUSH
3210: LD_EXP 48
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: ST_TO_ADDR
// uc_nation := 1 ;
3229: LD_ADDR_OWVAR 21
3233: PUSH
3234: LD_INT 1
3236: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3237: LD_INT 5
3239: PPUSH
3240: LD_INT 3
3242: PPUSH
3243: LD_INT 1
3245: PPUSH
3246: LD_INT 6
3248: PPUSH
3249: LD_INT 100
3251: PPUSH
3252: CALL 55487 0 5
// veh := CreateVehicle ;
3256: LD_ADDR_VAR 0 3
3260: PUSH
3261: CALL_OW 45
3265: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3266: LD_VAR 0 3
3270: PPUSH
3271: LD_INT 7
3273: NEG
3274: PPUSH
3275: CALL_OW 242
// SetDir ( veh , 3 ) ;
3279: LD_VAR 0 3
3283: PPUSH
3284: LD_INT 3
3286: PPUSH
3287: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3291: LD_VAR 0 3
3295: PPUSH
3296: LD_INT 31
3298: PPUSH
3299: LD_INT 0
3301: PPUSH
3302: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3306: LD_EXP 17
3310: PPUSH
3311: LD_VAR 0 3
3315: PPUSH
3316: CALL_OW 52
// if Joan then
3320: LD_EXP 32
3324: IFFALSE 3396
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3326: LD_INT 3
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: LD_INT 1
3334: PPUSH
3335: LD_INT 11
3337: PPUSH
3338: LD_INT 100
3340: PPUSH
3341: CALL 55487 0 5
// veh := CreateVehicle ;
3345: LD_ADDR_VAR 0 3
3349: PUSH
3350: CALL_OW 45
3354: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3355: LD_VAR 0 3
3359: PPUSH
3360: LD_INT 3
3362: PPUSH
3363: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3367: LD_VAR 0 3
3371: PPUSH
3372: LD_INT 30
3374: PPUSH
3375: LD_INT 0
3377: PPUSH
3378: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3382: LD_EXP 32
3386: PPUSH
3387: LD_VAR 0 3
3391: PPUSH
3392: CALL_OW 52
// end ; if Roth then
3396: LD_EXP 18
3400: IFFALSE 3472
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3402: LD_INT 3
3404: PPUSH
3405: LD_INT 3
3407: PPUSH
3408: LD_INT 1
3410: PPUSH
3411: LD_INT 11
3413: PPUSH
3414: LD_INT 100
3416: PPUSH
3417: CALL 55487 0 5
// veh := CreateVehicle ;
3421: LD_ADDR_VAR 0 3
3425: PUSH
3426: CALL_OW 45
3430: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3431: LD_VAR 0 3
3435: PPUSH
3436: LD_INT 3
3438: PPUSH
3439: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3443: LD_VAR 0 3
3447: PPUSH
3448: LD_INT 30
3450: PPUSH
3451: LD_INT 0
3453: PPUSH
3454: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3458: LD_EXP 18
3462: PPUSH
3463: LD_VAR 0 3
3467: PPUSH
3468: CALL_OW 52
// end ; if Denis then
3472: LD_EXP 23
3476: IFFALSE 3548
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3478: LD_INT 5
3480: PPUSH
3481: LD_INT 3
3483: PPUSH
3484: LD_INT 1
3486: PPUSH
3487: LD_INT 9
3489: PPUSH
3490: LD_INT 100
3492: PPUSH
3493: CALL 55487 0 5
// veh := CreateVehicle ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: CALL_OW 45
3506: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3507: LD_VAR 0 3
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3519: LD_VAR 0 3
3523: PPUSH
3524: LD_INT 30
3526: PPUSH
3527: LD_INT 0
3529: PPUSH
3530: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3534: LD_EXP 23
3538: PPUSH
3539: LD_VAR 0 3
3543: PPUSH
3544: CALL_OW 52
// end ; uc_nation := 3 ;
3548: LD_ADDR_OWVAR 21
3552: PUSH
3553: LD_INT 3
3555: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3556: LD_INT 22
3558: PPUSH
3559: LD_INT 3
3561: PPUSH
3562: LD_INT 1
3564: PPUSH
3565: LD_INT 45
3567: PPUSH
3568: LD_INT 100
3570: PPUSH
3571: CALL 55487 0 5
// veh := CreateVehicle ;
3575: LD_ADDR_VAR 0 3
3579: PUSH
3580: CALL_OW 45
3584: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3585: LD_VAR 0 3
3589: PPUSH
3590: LD_INT 7
3592: NEG
3593: PPUSH
3594: CALL_OW 242
// SetDir ( veh , 3 ) ;
3598: LD_VAR 0 3
3602: PPUSH
3603: LD_INT 3
3605: PPUSH
3606: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3610: LD_VAR 0 3
3614: PPUSH
3615: LD_INT 31
3617: PPUSH
3618: LD_INT 0
3620: PPUSH
3621: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3625: LD_EXP 49
3629: PPUSH
3630: LD_VAR 0 3
3634: PPUSH
3635: CALL_OW 52
// if Gossudarov then
3639: LD_EXP 35
3643: IFFALSE 3730
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3645: LD_INT 22
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: LD_INT 1
3653: PPUSH
3654: LD_INT 51
3656: PPUSH
3657: LD_INT 100
3659: PPUSH
3660: CALL 55487 0 5
// veh := CreateVehicle ;
3664: LD_ADDR_VAR 0 3
3668: PUSH
3669: CALL_OW 45
3673: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3674: LD_VAR 0 3
3678: PPUSH
3679: LD_INT 3
3681: PPUSH
3682: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3686: LD_VAR 0 3
3690: PPUSH
3691: LD_INT 30
3693: PPUSH
3694: LD_INT 0
3696: PPUSH
3697: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3701: LD_EXP 35
3705: PPUSH
3706: LD_VAR 0 3
3710: PPUSH
3711: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3715: LD_VAR 0 3
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_INT 100
3725: PPUSH
3726: CALL_OW 290
// end ; for i in selected do
3730: LD_ADDR_VAR 0 2
3734: PUSH
3735: LD_VAR 0 4
3739: PUSH
3740: FOR_IN
3741: IFFALSE 4299
// begin uc_nation := GetNation ( i ) ;
3743: LD_ADDR_OWVAR 21
3747: PUSH
3748: LD_VAR 0 2
3752: PPUSH
3753: CALL_OW 248
3757: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3758: LD_VAR 0 2
3762: PUSH
3763: LD_EXP 19
3767: PUSH
3768: LD_EXP 20
3772: PUSH
3773: LD_EXP 22
3777: PUSH
3778: LD_EXP 21
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: LIST
3787: LIST
3788: IN
3789: IFFALSE 3812
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3791: LD_INT 5
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 6
3802: PPUSH
3803: LD_INT 100
3805: PPUSH
3806: CALL 55487 0 5
3810: GO 4246
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3812: LD_VAR 0 2
3816: PUSH
3817: LD_EXP 42
3821: PUSH
3822: LD_EXP 47
3826: PUSH
3827: LD_EXP 45
3831: PUSH
3832: LD_EXP 37
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: IN
3843: IFFALSE 3874
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3845: LD_INT 24
3847: PPUSH
3848: LD_INT 1
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 46
3856: PPUSH
3857: LD_INT 65
3859: PPUSH
3860: LD_INT 75
3862: PPUSH
3863: CALL_OW 12
3867: PPUSH
3868: CALL 55487 0 5
3872: GO 4246
// if i = Karamazov then
3874: LD_VAR 0 2
3878: PUSH
3879: LD_EXP 48
3883: EQUAL
3884: IFFALSE 3907
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3886: LD_INT 22
3888: PPUSH
3889: LD_INT 3
3891: PPUSH
3892: LD_INT 1
3894: PPUSH
3895: LD_INT 52
3897: PPUSH
3898: LD_INT 100
3900: PPUSH
3901: CALL 55487 0 5
3905: GO 4246
// if i = Brown then
3907: LD_VAR 0 2
3911: PUSH
3912: LD_EXP 24
3916: EQUAL
3917: IFFALSE 3940
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3919: LD_INT 3
3921: PPUSH
3922: LD_INT 3
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 13
3930: PPUSH
3931: LD_INT 100
3933: PPUSH
3934: CALL 55487 0 5
3938: GO 4246
// if uc_nation = nation_american then
3940: LD_OWVAR 21
3944: PUSH
3945: LD_INT 1
3947: EQUAL
3948: IFFALSE 4099
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3950: LD_INT 3
3952: PUSH
3953: LD_INT 5
3955: PUSH
3956: LD_INT 5
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 21
3968: PUSH
3969: LD_INT 3
3971: MOD
3972: PUSH
3973: LD_INT 1
3975: PLUS
3976: ARRAY
3977: PPUSH
3978: LD_INT 1
3980: PUSH
3981: LD_INT 3
3983: PUSH
3984: LD_INT 1
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: LIST
3991: PUSH
3992: LD_OWVAR 21
3996: PUSH
3997: LD_INT 3
3999: MOD
4000: PUSH
4001: LD_INT 1
4003: PLUS
4004: ARRAY
4005: PPUSH
4006: LD_INT 1
4008: PPUSH
4009: LD_INT 11
4011: PUSH
4012: LD_INT 4
4014: PUSH
4015: LD_INT 5
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: LIST
4022: PUSH
4023: LD_INT 6
4025: PUSH
4026: LD_INT 7
4028: PUSH
4029: LD_INT 9
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_INT 6
4039: PUSH
4040: LD_INT 9
4042: PUSH
4043: LD_INT 12
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_OWVAR 21
4060: PUSH
4061: LD_INT 3
4063: MOD
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: ARRAY
4069: PUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 3
4075: PPUSH
4076: CALL_OW 12
4080: ARRAY
4081: PPUSH
4082: LD_INT 65
4084: PPUSH
4085: LD_INT 75
4087: PPUSH
4088: CALL_OW 12
4092: PPUSH
4093: CALL 55487 0 5
// end else
4097: GO 4246
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4099: LD_INT 22
4101: PUSH
4102: LD_INT 23
4104: PUSH
4105: LD_INT 23
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: LD_OWVAR 21
4117: PUSH
4118: LD_INT 3
4120: MOD
4121: PUSH
4122: LD_INT 1
4124: PLUS
4125: ARRAY
4126: PPUSH
4127: LD_INT 1
4129: PUSH
4130: LD_INT 3
4132: PUSH
4133: LD_INT 1
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: LIST
4140: PUSH
4141: LD_OWVAR 21
4145: PUSH
4146: LD_INT 3
4148: MOD
4149: PUSH
4150: LD_INT 1
4152: PLUS
4153: ARRAY
4154: PPUSH
4155: LD_INT 1
4157: PPUSH
4158: LD_INT 45
4160: PUSH
4161: LD_INT 43
4163: PUSH
4164: LD_INT 44
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 46
4174: PUSH
4175: LD_INT 45
4177: PUSH
4178: LD_INT 44
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 46
4188: PUSH
4189: LD_INT 43
4191: PUSH
4192: LD_INT 45
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: LIST
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: LIST
4204: PUSH
4205: LD_OWVAR 21
4209: PUSH
4210: LD_INT 3
4212: MOD
4213: PUSH
4214: LD_INT 1
4216: PLUS
4217: ARRAY
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 65
4233: PPUSH
4234: LD_INT 75
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 55487 0 5
// end ; veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 3
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4256: LD_VAR 0 3
4260: PPUSH
4261: LD_INT 3
4263: PPUSH
4264: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4268: LD_VAR 0 3
4272: PPUSH
4273: LD_INT 30
4275: PPUSH
4276: LD_INT 0
4278: PPUSH
4279: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_VAR 0 3
4292: PPUSH
4293: CALL_OW 52
// end ;
4297: GO 3740
4299: POP
4300: POP
// if artifactArCaptured then
4301: LD_EXP 9
4305: IFFALSE 4391
// begin uc_nation := nation_american ;
4307: LD_ADDR_OWVAR 21
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4315: LD_INT 3
4317: PPUSH
4318: LD_INT 3
4320: PPUSH
4321: LD_INT 3
4323: PPUSH
4324: LD_INT 12
4326: PPUSH
4327: LD_INT 100
4329: PPUSH
4330: CALL 55487 0 5
// veh := CreateVehicle ;
4334: LD_ADDR_VAR 0 3
4338: PUSH
4339: CALL_OW 45
4343: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4344: LD_VAR 0 3
4348: PPUSH
4349: LD_INT 3
4351: PPUSH
4352: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4356: LD_VAR 0 3
4360: PPUSH
4361: LD_INT 198
4363: PPUSH
4364: LD_INT 22
4366: PPUSH
4367: LD_INT 0
4369: PPUSH
4370: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4374: LD_VAR 0 3
4378: PPUSH
4379: LD_INT 4
4381: PPUSH
4382: LD_INT 50
4384: PPUSH
4385: CALL_OW 290
// end else
4389: GO 4410
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4391: LD_INT 4
4393: PPUSH
4394: LD_INT 267
4396: PPUSH
4397: LD_INT 226
4399: PPUSH
4400: LD_INT 5
4402: PPUSH
4403: LD_INT 0
4405: PPUSH
4406: CALL_OW 58
// end ; uc_nation := nation_american ;
4410: LD_ADDR_OWVAR 21
4414: PUSH
4415: LD_INT 1
4417: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4418: LD_INT 3
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: LD_INT 3
4426: PPUSH
4427: LD_INT 12
4429: PPUSH
4430: LD_INT 100
4432: PPUSH
4433: CALL 55487 0 5
// veh := CreateVehicle ;
4437: LD_ADDR_VAR 0 3
4441: PUSH
4442: CALL_OW 45
4446: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4447: LD_VAR 0 3
4451: PPUSH
4452: LD_INT 3
4454: PPUSH
4455: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4459: LD_VAR 0 3
4463: PPUSH
4464: LD_INT 218
4466: PPUSH
4467: LD_INT 23
4469: PPUSH
4470: LD_INT 0
4472: PPUSH
4473: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4477: LD_VAR 0 3
4481: PPUSH
4482: LD_INT 4
4484: PPUSH
4485: LD_INT 30
4487: PPUSH
4488: CALL_OW 290
// uc_nation := nation_russian ;
4492: LD_ADDR_OWVAR 21
4496: PUSH
4497: LD_INT 3
4499: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4500: LD_INT 22
4502: PPUSH
4503: LD_INT 3
4505: PPUSH
4506: LD_INT 3
4508: PPUSH
4509: LD_INT 51
4511: PPUSH
4512: LD_INT 100
4514: PPUSH
4515: CALL 55487 0 5
// veh := CreateVehicle ;
4519: LD_ADDR_VAR 0 3
4523: PUSH
4524: CALL_OW 45
4528: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4529: LD_VAR 0 3
4533: PPUSH
4534: LD_INT 3
4536: PPUSH
4537: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4541: LD_VAR 0 3
4545: PPUSH
4546: LD_INT 214
4548: PPUSH
4549: LD_INT 20
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4559: LD_VAR 0 3
4563: PPUSH
4564: LD_INT 4
4566: PPUSH
4567: LD_INT 40
4569: PPUSH
4570: CALL_OW 290
// end ; end_of_file
4574: LD_VAR 0 1
4578: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4579: LD_INT 0
4581: PPUSH
4582: PPUSH
4583: PPUSH
4584: PPUSH
4585: PPUSH
4586: PPUSH
4587: PPUSH
4588: PPUSH
4589: PPUSH
4590: PPUSH
// InitHc ;
4591: CALL_OW 19
// uc_side := 1 ;
4595: LD_ADDR_OWVAR 20
4599: PUSH
4600: LD_INT 1
4602: ST_TO_ADDR
// uc_nation := 1 ;
4603: LD_ADDR_OWVAR 21
4607: PUSH
4608: LD_INT 1
4610: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4611: LD_ADDR_VAR 0 2
4615: PUSH
4616: LD_INT 22
4618: PUSH
4619: LD_INT 1
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: PUSH
4626: LD_INT 21
4628: PUSH
4629: LD_INT 3
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PPUSH
4640: CALL_OW 69
4644: PUSH
4645: FOR_IN
4646: IFFALSE 4662
// SetBLevel ( i , 10 ) ;
4648: LD_VAR 0 2
4652: PPUSH
4653: LD_INT 10
4655: PPUSH
4656: CALL_OW 241
4660: GO 4645
4662: POP
4663: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4664: LD_INT 387
4666: PPUSH
4667: CALL_OW 274
4671: PPUSH
4672: LD_INT 1
4674: PPUSH
4675: LD_INT 7500
4677: PPUSH
4678: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4682: LD_INT 387
4684: PPUSH
4685: CALL_OW 274
4689: PPUSH
4690: LD_INT 2
4692: PPUSH
4693: LD_INT 4000
4695: PPUSH
4696: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4700: LD_INT 387
4702: PPUSH
4703: CALL_OW 274
4707: PPUSH
4708: LD_INT 3
4710: PPUSH
4711: LD_INT 50
4713: PPUSH
4714: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4718: LD_INT 476
4720: PPUSH
4721: CALL_OW 274
4725: PPUSH
4726: LD_INT 1
4728: PPUSH
4729: LD_INT 5500
4731: PPUSH
4732: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4736: LD_INT 476
4738: PPUSH
4739: CALL_OW 274
4743: PPUSH
4744: LD_INT 2
4746: PPUSH
4747: LD_INT 4000
4749: PPUSH
4750: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4754: LD_INT 476
4756: PPUSH
4757: CALL_OW 274
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 10
4767: PPUSH
4768: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4772: LD_ADDR_EXP 52
4776: PUSH
4777: LD_STRING Powell
4779: PPUSH
4780: CALL_OW 25
4784: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4785: LD_EXP 52
4789: PPUSH
4790: LD_INT 387
4792: PPUSH
4793: CALL_OW 52
// tmp := [ ] ;
4797: LD_ADDR_VAR 0 6
4801: PUSH
4802: EMPTY
4803: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4804: LD_ADDR_EXP 19
4808: PUSH
4809: LD_STRING Lisa
4811: PPUSH
4812: LD_EXP 1
4816: NOT
4817: PPUSH
4818: LD_STRING 12p_
4820: PPUSH
4821: CALL 50663 0 3
4825: ST_TO_ADDR
// if Lisa then
4826: LD_EXP 19
4830: IFFALSE 4848
// tmp := tmp ^ Lisa ;
4832: LD_ADDR_VAR 0 6
4836: PUSH
4837: LD_VAR 0 6
4841: PUSH
4842: LD_EXP 19
4846: ADD
4847: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4848: LD_ADDR_EXP 20
4852: PUSH
4853: LD_STRING Donaldson
4855: PPUSH
4856: LD_EXP 1
4860: NOT
4861: PPUSH
4862: LD_STRING 12p_
4864: PPUSH
4865: CALL 50663 0 3
4869: ST_TO_ADDR
// if Donaldson then
4870: LD_EXP 20
4874: IFFALSE 4892
// tmp := tmp ^ Donaldson ;
4876: LD_ADDR_VAR 0 6
4880: PUSH
4881: LD_VAR 0 6
4885: PUSH
4886: LD_EXP 20
4890: ADD
4891: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4892: LD_ADDR_EXP 21
4896: PUSH
4897: LD_STRING Bobby
4899: PPUSH
4900: LD_EXP 1
4904: NOT
4905: PPUSH
4906: LD_STRING 12p_
4908: PPUSH
4909: CALL 50663 0 3
4913: ST_TO_ADDR
// if Bobby then
4914: LD_EXP 21
4918: IFFALSE 4936
// tmp := tmp ^ Bobby ;
4920: LD_ADDR_VAR 0 6
4924: PUSH
4925: LD_VAR 0 6
4929: PUSH
4930: LD_EXP 21
4934: ADD
4935: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4936: LD_ADDR_EXP 22
4940: PUSH
4941: LD_STRING Cyrus
4943: PPUSH
4944: LD_EXP 1
4948: NOT
4949: PPUSH
4950: LD_STRING 12p_
4952: PPUSH
4953: CALL 50663 0 3
4957: ST_TO_ADDR
// if Cyrus then
4958: LD_EXP 22
4962: IFFALSE 4980
// tmp := tmp ^ Cyrus ;
4964: LD_ADDR_VAR 0 6
4968: PUSH
4969: LD_VAR 0 6
4973: PUSH
4974: LD_EXP 22
4978: ADD
4979: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4980: LD_ADDR_EXP 24
4984: PUSH
4985: LD_STRING Brown
4987: PPUSH
4988: LD_EXP 1
4992: NOT
4993: PPUSH
4994: LD_STRING 12p_
4996: PPUSH
4997: CALL 50663 0 3
5001: ST_TO_ADDR
// if Brown then
5002: LD_EXP 24
5006: IFFALSE 5024
// tmp := tmp ^ Brown ;
5008: LD_ADDR_VAR 0 6
5012: PUSH
5013: LD_VAR 0 6
5017: PUSH
5018: LD_EXP 24
5022: ADD
5023: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5024: LD_ADDR_EXP 25
5028: PUSH
5029: LD_STRING Gladstone
5031: PPUSH
5032: LD_EXP 1
5036: NOT
5037: PPUSH
5038: LD_STRING 12p_
5040: PPUSH
5041: CALL 50663 0 3
5045: ST_TO_ADDR
// if Gladstone then
5046: LD_EXP 25
5050: IFFALSE 5068
// tmp := tmp ^ Gladstone ;
5052: LD_ADDR_VAR 0 6
5056: PUSH
5057: LD_VAR 0 6
5061: PUSH
5062: LD_EXP 25
5066: ADD
5067: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5068: LD_ADDR_EXP 26
5072: PUSH
5073: LD_STRING Houten
5075: PPUSH
5076: LD_EXP 1
5080: NOT
5081: PPUSH
5082: LD_STRING 12p_
5084: PPUSH
5085: CALL 50663 0 3
5089: ST_TO_ADDR
// if Houten then
5090: LD_EXP 26
5094: IFFALSE 5112
// tmp := tmp ^ Houten ;
5096: LD_ADDR_VAR 0 6
5100: PUSH
5101: LD_VAR 0 6
5105: PUSH
5106: LD_EXP 26
5110: ADD
5111: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5112: LD_ADDR_EXP 27
5116: PUSH
5117: LD_STRING Cornel
5119: PPUSH
5120: LD_EXP 1
5124: NOT
5125: PPUSH
5126: LD_STRING 12p_
5128: PPUSH
5129: CALL 50663 0 3
5133: ST_TO_ADDR
// if Cornel then
5134: LD_EXP 27
5138: IFFALSE 5156
// tmp := tmp ^ Cornel ;
5140: LD_ADDR_VAR 0 6
5144: PUSH
5145: LD_VAR 0 6
5149: PUSH
5150: LD_EXP 27
5154: ADD
5155: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5156: LD_ADDR_EXP 28
5160: PUSH
5161: LD_STRING Gary
5163: PPUSH
5164: LD_EXP 1
5168: NOT
5169: PPUSH
5170: LD_STRING 12p_
5172: PPUSH
5173: CALL 50663 0 3
5177: ST_TO_ADDR
// if Gary then
5178: LD_EXP 28
5182: IFFALSE 5200
// tmp := tmp ^ Gary ;
5184: LD_ADDR_VAR 0 6
5188: PUSH
5189: LD_VAR 0 6
5193: PUSH
5194: LD_EXP 28
5198: ADD
5199: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5200: LD_ADDR_EXP 30
5204: PUSH
5205: LD_STRING Kikuchi
5207: PPUSH
5208: LD_EXP 1
5212: NOT
5213: PPUSH
5214: LD_STRING 12p_
5216: PPUSH
5217: CALL 50663 0 3
5221: ST_TO_ADDR
// if Kikuchi then
5222: LD_EXP 30
5226: IFFALSE 5244
// tmp := tmp ^ Kikuchi ;
5228: LD_ADDR_VAR 0 6
5232: PUSH
5233: LD_VAR 0 6
5237: PUSH
5238: LD_EXP 30
5242: ADD
5243: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5244: LD_ADDR_VAR 0 6
5248: PUSH
5249: LD_VAR 0 6
5253: PUSH
5254: LD_STRING 12p_others
5256: PPUSH
5257: CALL_OW 31
5261: UNION
5262: ST_TO_ADDR
// if tmp < 36 then
5263: LD_VAR 0 6
5267: PUSH
5268: LD_INT 36
5270: LESS
5271: IFFALSE 5338
// for i = 1 to 36 - tmp do
5273: LD_ADDR_VAR 0 2
5277: PUSH
5278: DOUBLE
5279: LD_INT 1
5281: DEC
5282: ST_TO_ADDR
5283: LD_INT 36
5285: PUSH
5286: LD_VAR 0 6
5290: MINUS
5291: PUSH
5292: FOR_TO
5293: IFFALSE 5336
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5295: LD_INT 1
5297: PPUSH
5298: LD_VAR 0 2
5302: PUSH
5303: LD_INT 4
5305: MOD
5306: PUSH
5307: LD_INT 1
5309: PLUS
5310: PPUSH
5311: LD_INT 10
5313: PPUSH
5314: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5318: LD_ADDR_VAR 0 6
5322: PUSH
5323: LD_VAR 0 6
5327: PUSH
5328: CALL_OW 44
5332: ADD
5333: ST_TO_ADDR
// end ;
5334: GO 5292
5336: POP
5337: POP
// for i in tmp do
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: LD_VAR 0 6
5347: PUSH
5348: FOR_IN
5349: IFFALSE 5374
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5351: LD_VAR 0 2
5355: PPUSH
5356: LD_INT 62
5358: PPUSH
5359: LD_INT 93
5361: PPUSH
5362: LD_INT 9
5364: PPUSH
5365: LD_INT 0
5367: PPUSH
5368: CALL_OW 50
5372: GO 5348
5374: POP
5375: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5376: LD_ADDR_EXP 88
5380: PUSH
5381: LD_EXP 88
5385: PPUSH
5386: LD_INT 4
5388: PPUSH
5389: LD_INT 22
5391: PUSH
5392: LD_INT 1
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PPUSH
5399: CALL_OW 69
5403: PUSH
5404: LD_EXP 52
5408: DIFF
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// uc_side := 0 ;
5415: LD_ADDR_OWVAR 20
5419: PUSH
5420: LD_INT 0
5422: ST_TO_ADDR
// uc_nation := 0 ;
5423: LD_ADDR_OWVAR 21
5427: PUSH
5428: LD_INT 0
5430: ST_TO_ADDR
// for i = 1 to 4 do
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: DOUBLE
5437: LD_INT 1
5439: DEC
5440: ST_TO_ADDR
5441: LD_INT 4
5443: PUSH
5444: FOR_TO
5445: IFFALSE 5476
// begin InitHc ;
5447: CALL_OW 19
// hc_class := class_apeman ;
5451: LD_ADDR_OWVAR 28
5455: PUSH
5456: LD_INT 12
5458: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5459: CALL_OW 44
5463: PPUSH
5464: LD_INT 11
5466: PPUSH
5467: LD_INT 0
5469: PPUSH
5470: CALL_OW 49
// end ;
5474: GO 5444
5476: POP
5477: POP
// end ;
5478: LD_VAR 0 1
5482: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5483: LD_EXP 4
5487: NOT
5488: PUSH
5489: LD_INT 4
5491: PPUSH
5492: LD_INT 1
5494: PPUSH
5495: CALL 45737 0 2
5499: NOT
5500: AND
5501: IFFALSE 6273
5503: GO 5505
5505: DISABLE
5506: LD_INT 0
5508: PPUSH
5509: PPUSH
5510: PPUSH
// begin enable ;
5511: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5512: LD_INT 22
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: PUSH
5522: LD_INT 23
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: PUSH
5532: LD_INT 30
5534: PUSH
5535: LD_INT 3
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: LIST
5546: PPUSH
5547: CALL_OW 69
5551: NOT
5552: IFFALSE 5556
// exit ;
5554: GO 6273
// if Prob ( 40 ) then
5556: LD_INT 40
5558: PPUSH
5559: CALL_OW 13
5563: IFFALSE 5690
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5565: LD_INT 4
5567: PPUSH
5568: LD_INT 5
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: LD_INT 2
5576: PUSH
5577: LD_INT 7
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 5
5588: PUSH
5589: LD_INT 1
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: LD_INT 7
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 7
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 5
5624: PUSH
5625: LD_INT 1
5627: PUSH
5628: LD_INT 2
5630: PUSH
5631: LD_INT 6
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: PUSH
5640: LD_INT 5
5642: PUSH
5643: LD_INT 1
5645: PUSH
5646: LD_INT 2
5648: PUSH
5649: LD_INT 6
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: PUSH
5658: LD_INT 5
5660: PUSH
5661: LD_INT 1
5663: PUSH
5664: LD_INT 2
5666: PUSH
5667: LD_INT 6
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PPUSH
5684: CALL 44319 0 2
// end else
5688: GO 5813
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5690: LD_INT 4
5692: PPUSH
5693: LD_INT 5
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: LD_INT 7
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 5
5713: PUSH
5714: LD_INT 1
5716: PUSH
5717: LD_INT 2
5719: PUSH
5720: LD_INT 9
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 5
5731: PUSH
5732: LD_INT 1
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: LD_INT 9
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 5
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 6
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 5
5767: PUSH
5768: LD_INT 1
5770: PUSH
5771: LD_INT 2
5773: PUSH
5774: LD_INT 6
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 5
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 6
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: LIST
5799: LIST
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PPUSH
5809: CALL 44319 0 2
// end ; repeat wait ( 0 0$1 ) ;
5813: LD_INT 35
5815: PPUSH
5816: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5820: LD_INT 4
5822: PPUSH
5823: LD_INT 1
5825: PPUSH
5826: CALL 45737 0 2
5830: PUSH
5831: LD_INT 6
5833: GREATEREQUAL
5834: IFFALSE 5813
// wait ( 0 0$30 ) ;
5836: LD_INT 1050
5838: PPUSH
5839: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 4
5850: PPUSH
5851: LD_INT 1
5853: PPUSH
5854: CALL 45737 0 2
5858: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5859: LD_ADDR_EXP 107
5863: PUSH
5864: LD_EXP 107
5868: PPUSH
5869: LD_INT 4
5871: PPUSH
5872: LD_EXP 107
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: LD_VAR 0 2
5885: DIFF
5886: PPUSH
5887: CALL_OW 1
5891: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5892: LD_ADDR_VAR 0 3
5896: PUSH
5897: LD_INT 0
5899: PPUSH
5900: LD_INT 2
5902: PPUSH
5903: CALL_OW 12
5907: ST_TO_ADDR
// if target then
5908: LD_VAR 0 3
5912: IFFALSE 6040
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5914: LD_ADDR_VAR 0 2
5918: PUSH
5919: LD_VAR 0 2
5923: PPUSH
5924: LD_INT 24
5926: PUSH
5927: LD_INT 250
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PPUSH
5934: CALL_OW 72
5938: ST_TO_ADDR
// for i in tmp do
5939: LD_ADDR_VAR 0 1
5943: PUSH
5944: LD_VAR 0 2
5948: PUSH
5949: FOR_IN
5950: IFFALSE 5990
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5952: LD_VAR 0 1
5956: PPUSH
5957: LD_INT 114
5959: PPUSH
5960: LD_INT 108
5962: PPUSH
5963: CALL_OW 297
5967: PUSH
5968: LD_INT 9
5970: GREATER
5971: IFFALSE 5988
// ComMoveXY ( i , 114 , 108 ) ;
5973: LD_VAR 0 1
5977: PPUSH
5978: LD_INT 114
5980: PPUSH
5981: LD_INT 108
5983: PPUSH
5984: CALL_OW 111
5988: GO 5949
5990: POP
5991: POP
// wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5999: LD_VAR 0 2
6003: PPUSH
6004: LD_INT 92
6006: PUSH
6007: LD_INT 114
6009: PUSH
6010: LD_INT 108
6012: PUSH
6013: LD_INT 9
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: PPUSH
6022: CALL_OW 72
6026: PUSH
6027: LD_VAR 0 2
6031: PUSH
6032: LD_INT 1
6034: MINUS
6035: GREATEREQUAL
6036: IFFALSE 5914
// end else
6038: GO 6164
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6040: LD_ADDR_VAR 0 2
6044: PUSH
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 24
6052: PUSH
6053: LD_INT 250
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL_OW 72
6064: ST_TO_ADDR
// for i in tmp do
6065: LD_ADDR_VAR 0 1
6069: PUSH
6070: LD_VAR 0 2
6074: PUSH
6075: FOR_IN
6076: IFFALSE 6116
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6078: LD_VAR 0 1
6082: PPUSH
6083: LD_INT 129
6085: PPUSH
6086: LD_INT 139
6088: PPUSH
6089: CALL_OW 297
6093: PUSH
6094: LD_INT 9
6096: GREATER
6097: IFFALSE 6114
// ComMoveXY ( i , 129 , 139 ) ;
6099: LD_VAR 0 1
6103: PPUSH
6104: LD_INT 129
6106: PPUSH
6107: LD_INT 139
6109: PPUSH
6110: CALL_OW 111
6114: GO 6075
6116: POP
6117: POP
// wait ( 0 0$1 ) ;
6118: LD_INT 35
6120: PPUSH
6121: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6125: LD_VAR 0 2
6129: PPUSH
6130: LD_INT 92
6132: PUSH
6133: LD_INT 129
6135: PUSH
6136: LD_INT 139
6138: PUSH
6139: LD_INT 9
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PPUSH
6148: CALL_OW 72
6152: PUSH
6153: LD_VAR 0 2
6157: PUSH
6158: LD_INT 1
6160: MINUS
6161: GREATEREQUAL
6162: IFFALSE 6040
// end ; repeat wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// for i in tmp do
6171: LD_ADDR_VAR 0 1
6175: PUSH
6176: LD_VAR 0 2
6180: PUSH
6181: FOR_IN
6182: IFFALSE 6264
// begin if GetLives ( i ) > 251 then
6184: LD_VAR 0 1
6188: PPUSH
6189: CALL_OW 256
6193: PUSH
6194: LD_INT 251
6196: GREATER
6197: IFFALSE 6235
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6199: LD_VAR 0 1
6203: PPUSH
6204: LD_INT 81
6206: PUSH
6207: LD_INT 1
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: PPUSH
6214: CALL_OW 69
6218: PPUSH
6219: LD_VAR 0 1
6223: PPUSH
6224: CALL_OW 74
6228: PPUSH
6229: CALL_OW 115
6233: GO 6262
// if IsDead ( i ) then
6235: LD_VAR 0 1
6239: PPUSH
6240: CALL_OW 301
6244: IFFALSE 6262
// tmp := tmp diff i ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PUSH
6256: LD_VAR 0 1
6260: DIFF
6261: ST_TO_ADDR
// end ;
6262: GO 6181
6264: POP
6265: POP
// until not tmp ;
6266: LD_VAR 0 2
6270: NOT
6271: IFFALSE 6164
// end ;
6273: PPOPN 3
6275: END
// every 30 30$00 trigger not americanDestroyed do
6276: LD_EXP 4
6280: NOT
6281: IFFALSE 6346
6283: GO 6285
6285: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6286: LD_INT 63000
6288: PUSH
6289: LD_INT 42000
6291: PUSH
6292: LD_INT 21000
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_OWVAR 67
6304: ARRAY
6305: PPUSH
6306: CALL_OW 67
// if americanDestroyed then
6310: LD_EXP 4
6314: IFFALSE 6318
// exit ;
6316: GO 6346
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6318: LD_INT 4
6320: PPUSH
6321: LD_INT 5
6323: PUSH
6324: LD_INT 3
6326: PUSH
6327: LD_INT 1
6329: PUSH
6330: LD_INT 8
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PUSH
6339: EMPTY
6340: LIST
6341: PPUSH
6342: CALL 44319 0 2
// end ; end_of_file
6346: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6347: LD_INT 0
6349: PPUSH
6350: PPUSH
6351: PPUSH
6352: PPUSH
6353: PPUSH
// side := 2 ;
6354: LD_ADDR_VAR 0 5
6358: PUSH
6359: LD_INT 2
6361: ST_TO_ADDR
// InitHc ;
6362: CALL_OW 19
// uc_side := side ;
6366: LD_ADDR_OWVAR 20
6370: PUSH
6371: LD_VAR 0 5
6375: ST_TO_ADDR
// uc_nation := 2 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 2
6383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6384: LD_ADDR_VAR 0 2
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_INT 2
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 21
6401: PUSH
6402: LD_INT 3
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6435
// SetBLevel ( i , 10 ) ;
6421: LD_VAR 0 2
6425: PPUSH
6426: LD_INT 10
6428: PPUSH
6429: CALL_OW 241
6433: GO 6418
6435: POP
6436: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6437: LD_ADDR_VAR 0 4
6441: PUSH
6442: LD_INT 22
6444: PUSH
6445: LD_VAR 0 5
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 30
6456: PUSH
6457: LD_INT 32
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 58
6466: PUSH
6467: EMPTY
6468: LIST
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: LIST
6474: PPUSH
6475: CALL_OW 69
6479: ST_TO_ADDR
// for i = 1 to 10 do
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: DOUBLE
6486: LD_INT 1
6488: DEC
6489: ST_TO_ADDR
6490: LD_INT 10
6492: PUSH
6493: FOR_TO
6494: IFFALSE 6566
// begin uc_nation := nation_nature ;
6496: LD_ADDR_OWVAR 21
6500: PUSH
6501: LD_INT 0
6503: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6504: LD_ADDR_OWVAR 28
6508: PUSH
6509: LD_INT 15
6511: ST_TO_ADDR
// hc_gallery :=  ;
6512: LD_ADDR_OWVAR 33
6516: PUSH
6517: LD_STRING 
6519: ST_TO_ADDR
// hc_name :=  ;
6520: LD_ADDR_OWVAR 26
6524: PUSH
6525: LD_STRING 
6527: ST_TO_ADDR
// un := CreateHuman ;
6528: LD_ADDR_VAR 0 3
6532: PUSH
6533: CALL_OW 44
6537: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6538: LD_VAR 0 3
6542: PPUSH
6543: LD_VAR 0 4
6547: PUSH
6548: LD_VAR 0 4
6552: PUSH
6553: LD_VAR 0 2
6557: MINUS
6558: ARRAY
6559: PPUSH
6560: CALL_OW 52
// end ;
6564: GO 6493
6566: POP
6567: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6568: LD_INT 503
6570: PPUSH
6571: LD_INT 27
6573: PPUSH
6574: LD_STRING 
6576: PPUSH
6577: LD_INT 8
6579: PUSH
6580: LD_INT 9
6582: PUSH
6583: LD_INT 10
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: PUSH
6591: LD_OWVAR 67
6595: ARRAY
6596: PPUSH
6597: LD_INT 3000
6599: PUSH
6600: LD_INT 500
6602: PUSH
6603: LD_INT 150
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: PPUSH
6611: LD_INT 16
6613: PUSH
6614: LD_INT 6
6616: PUSH
6617: LD_INT 6
6619: PUSH
6620: LD_INT 6
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PPUSH
6629: CALL 58896 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6633: LD_ADDR_EXP 88
6637: PUSH
6638: LD_EXP 88
6642: PPUSH
6643: LD_INT 1
6645: PPUSH
6646: LD_INT 22
6648: PUSH
6649: LD_VAR 0 5
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PUSH
6658: LD_INT 23
6660: PUSH
6661: LD_INT 2
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: PUSH
6668: LD_INT 3
6670: PUSH
6671: LD_INT 21
6673: PUSH
6674: LD_INT 2
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: LIST
6689: PPUSH
6690: CALL_OW 69
6694: PPUSH
6695: CALL_OW 1
6699: ST_TO_ADDR
// end ;
6700: LD_VAR 0 1
6704: RET
// export Omar ; export function PrepareOmarAli ; begin
6705: LD_INT 0
6707: PPUSH
// uc_side := 5 ;
6708: LD_ADDR_OWVAR 20
6712: PUSH
6713: LD_INT 5
6715: ST_TO_ADDR
// uc_nation := 2 ;
6716: LD_ADDR_OWVAR 21
6720: PUSH
6721: LD_INT 2
6723: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6724: LD_ADDR_EXP 53
6728: PUSH
6729: LD_STRING Omar
6731: PPUSH
6732: CALL_OW 25
6736: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6737: LD_EXP 53
6741: PPUSH
6742: LD_INT 330
6744: PPUSH
6745: LD_INT 244
6747: PPUSH
6748: LD_INT 0
6750: PPUSH
6751: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6755: LD_EXP 53
6759: PPUSH
6760: LD_INT 252
6762: PPUSH
6763: LD_INT 220
6765: PPUSH
6766: CALL_OW 111
// end ; end_of_file
6770: LD_VAR 0 1
6774: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6775: LD_INT 0
6777: PPUSH
6778: PPUSH
6779: PPUSH
6780: PPUSH
6781: PPUSH
// side := 8 ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_INT 8
6789: ST_TO_ADDR
// InitHc ;
6790: CALL_OW 19
// uc_side := side ;
6794: LD_ADDR_OWVAR 20
6798: PUSH
6799: LD_VAR 0 3
6803: ST_TO_ADDR
// uc_nation := 2 ;
6804: LD_ADDR_OWVAR 21
6808: PUSH
6809: LD_INT 2
6811: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6812: LD_ADDR_VAR 0 2
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 21
6831: PUSH
6832: LD_INT 3
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PPUSH
6843: CALL_OW 69
6847: PUSH
6848: FOR_IN
6849: IFFALSE 6865
// SetBLevel ( i , 10 ) ;
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_INT 10
6858: PPUSH
6859: CALL_OW 241
6863: GO 6848
6865: POP
6866: POP
// Schulz := NewCharacter ( Schulz ) ;
6867: LD_ADDR_EXP 54
6871: PUSH
6872: LD_STRING Schulz
6874: PPUSH
6875: CALL_OW 25
6879: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6880: LD_ADDR_EXP 55
6884: PUSH
6885: LD_STRING Kozlov
6887: PPUSH
6888: LD_INT 0
6890: PPUSH
6891: LD_STRING 
6893: PPUSH
6894: CALL 50663 0 3
6898: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6899: LD_EXP 55
6903: PPUSH
6904: LD_INT 22
6906: PUSH
6907: LD_INT 8
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PUSH
6914: LD_INT 23
6916: PUSH
6917: LD_INT 3
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PUSH
6924: LD_INT 30
6926: PUSH
6927: LD_INT 8
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: LIST
6938: PPUSH
6939: CALL_OW 69
6943: PUSH
6944: LD_INT 1
6946: ARRAY
6947: PPUSH
6948: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6952: LD_EXP 55
6956: PPUSH
6957: LD_INT 3
6959: PPUSH
6960: LD_INT 10
6962: PPUSH
6963: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6967: LD_ADDR_VAR 0 5
6971: PUSH
6972: LD_INT 22
6974: PUSH
6975: LD_VAR 0 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 30
6986: PUSH
6987: LD_INT 32
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 58
6996: PUSH
6997: EMPTY
6998: LIST
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: LIST
7004: PPUSH
7005: CALL_OW 69
7009: ST_TO_ADDR
// for i = 1 to 10 do
7010: LD_ADDR_VAR 0 2
7014: PUSH
7015: DOUBLE
7016: LD_INT 1
7018: DEC
7019: ST_TO_ADDR
7020: LD_INT 10
7022: PUSH
7023: FOR_TO
7024: IFFALSE 7096
// begin uc_nation := nation_nature ;
7026: LD_ADDR_OWVAR 21
7030: PUSH
7031: LD_INT 0
7033: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7034: LD_ADDR_OWVAR 28
7038: PUSH
7039: LD_INT 15
7041: ST_TO_ADDR
// hc_gallery :=  ;
7042: LD_ADDR_OWVAR 33
7046: PUSH
7047: LD_STRING 
7049: ST_TO_ADDR
// hc_name :=  ;
7050: LD_ADDR_OWVAR 26
7054: PUSH
7055: LD_STRING 
7057: ST_TO_ADDR
// un := CreateHuman ;
7058: LD_ADDR_VAR 0 4
7062: PUSH
7063: CALL_OW 44
7067: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7068: LD_VAR 0 4
7072: PPUSH
7073: LD_VAR 0 5
7077: PUSH
7078: LD_VAR 0 5
7082: PUSH
7083: LD_VAR 0 2
7087: MINUS
7088: ARRAY
7089: PPUSH
7090: CALL_OW 52
// end ;
7094: GO 7023
7096: POP
7097: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7098: LD_INT 324
7100: PPUSH
7101: LD_INT 3
7103: PPUSH
7104: LD_STRING 
7106: PPUSH
7107: LD_INT 8
7109: PUSH
7110: LD_INT 9
7112: PUSH
7113: LD_INT 10
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: PUSH
7121: LD_OWVAR 67
7125: ARRAY
7126: PPUSH
7127: LD_INT 3000
7129: PUSH
7130: LD_INT 500
7132: PUSH
7133: LD_INT 150
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PPUSH
7141: LD_INT 16
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 6
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: LIST
7157: LIST
7158: PPUSH
7159: CALL 58896 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7163: LD_ADDR_EXP 88
7167: PUSH
7168: LD_EXP 88
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: LD_INT 22
7178: PUSH
7179: LD_VAR 0 3
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: PUSH
7188: LD_INT 23
7190: PUSH
7191: LD_INT 2
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: LD_INT 3
7200: PUSH
7201: LD_INT 21
7203: PUSH
7204: LD_INT 2
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: CALL_OW 69
7224: PUSH
7225: LD_EXP 54
7229: DIFF
7230: PPUSH
7231: CALL_OW 1
7235: ST_TO_ADDR
// end ;
7236: LD_VAR 0 1
7240: RET
// export function BuildKozlovBomb ; begin
7241: LD_INT 0
7243: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7244: LD_INT 332
7246: PPUSH
7247: CALL_OW 302
7251: NOT
7252: PUSH
7253: LD_INT 336
7255: PPUSH
7256: CALL_OW 302
7260: NOT
7261: OR
7262: IFFALSE 7266
// exit ;
7264: GO 7363
// ComChangeProfession ( Kozlov , 4 ) ;
7266: LD_EXP 55
7270: PPUSH
7271: LD_INT 4
7273: PPUSH
7274: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7278: LD_INT 336
7280: PPUSH
7281: LD_INT 25
7283: PPUSH
7284: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7288: LD_INT 35
7290: PPUSH
7291: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7295: LD_INT 25
7297: PPUSH
7298: LD_INT 8
7300: PPUSH
7301: CALL_OW 321
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7288
// ComExitBuilding ( Kozlov ) ;
7311: LD_EXP 55
7315: PPUSH
7316: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7320: LD_EXP 55
7324: PPUSH
7325: LD_INT 332
7327: PPUSH
7328: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7332: LD_EXP 55
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7344: LD_INT 332
7346: PPUSH
7347: LD_INT 23
7349: PPUSH
7350: LD_INT 3
7352: PPUSH
7353: LD_INT 1
7355: PPUSH
7356: LD_INT 48
7358: PPUSH
7359: CALL_OW 125
// end ;
7363: LD_VAR 0 1
7367: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7368: LD_EXP 3
7372: NOT
7373: PUSH
7374: LD_INT 3
7376: PPUSH
7377: LD_INT 1
7379: PPUSH
7380: CALL 45737 0 2
7384: NOT
7385: AND
7386: IFFALSE 8226
7388: GO 7390
7390: DISABLE
7391: LD_INT 0
7393: PPUSH
7394: PPUSH
7395: PPUSH
// begin enable ;
7396: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7397: LD_INT 22
7399: PUSH
7400: LD_INT 8
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PUSH
7407: LD_INT 23
7409: PUSH
7410: LD_INT 2
7412: PUSH
7413: EMPTY
7414: LIST
7415: LIST
7416: PUSH
7417: LD_INT 30
7419: PUSH
7420: LD_INT 3
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: PPUSH
7432: CALL_OW 69
7436: NOT
7437: IFFALSE 7441
// exit ;
7439: GO 8226
// if Prob ( 40 ) then
7441: LD_INT 40
7443: PPUSH
7444: CALL_OW 13
7448: IFFALSE 7575
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7450: LD_INT 3
7452: PPUSH
7453: LD_INT 14
7455: PUSH
7456: LD_INT 1
7458: PUSH
7459: LD_INT 2
7461: PUSH
7462: LD_INT 28
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: PUSH
7471: LD_INT 14
7473: PUSH
7474: LD_INT 1
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 28
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 14
7491: PUSH
7492: LD_INT 1
7494: PUSH
7495: LD_INT 2
7497: PUSH
7498: LD_INT 28
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 14
7509: PUSH
7510: LD_INT 1
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 28
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: LD_INT 14
7527: PUSH
7528: LD_INT 1
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: LD_INT 28
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: LD_INT 14
7545: PUSH
7546: LD_INT 1
7548: PUSH
7549: LD_INT 2
7551: PUSH
7552: LD_INT 26
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: LIST
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: LIST
7565: LIST
7566: LIST
7567: LIST
7568: PPUSH
7569: CALL 44319 0 2
// end else
7573: GO 7766
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7575: LD_INT 3
7577: PPUSH
7578: LD_INT 14
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 2
7586: PUSH
7587: LD_INT 27
7589: PUSH
7590: LD_INT 26
7592: PUSH
7593: LD_INT 26
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: LIST
7600: PUSH
7601: LD_OWVAR 67
7605: ARRAY
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 14
7615: PUSH
7616: LD_INT 1
7618: PUSH
7619: LD_INT 2
7621: PUSH
7622: LD_INT 27
7624: PUSH
7625: LD_INT 26
7627: PUSH
7628: LD_INT 26
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: LD_OWVAR 67
7640: ARRAY
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: LIST
7647: PUSH
7648: LD_INT 14
7650: PUSH
7651: LD_INT 1
7653: PUSH
7654: LD_INT 2
7656: PUSH
7657: LD_INT 26
7659: PUSH
7660: LD_INT 26
7662: PUSH
7663: LD_INT 29
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_OWVAR 67
7675: ARRAY
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 13
7685: PUSH
7686: LD_INT 1
7688: PUSH
7689: LD_INT 2
7691: PUSH
7692: LD_INT 26
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: LD_INT 29
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: PUSH
7706: LD_OWVAR 67
7710: ARRAY
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 13
7720: PUSH
7721: LD_INT 1
7723: PUSH
7724: LD_INT 2
7726: PUSH
7727: LD_INT 29
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 14
7738: PUSH
7739: LD_INT 1
7741: PUSH
7742: LD_INT 2
7744: PUSH
7745: LD_INT 26
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PPUSH
7762: CALL 44319 0 2
// end ; repeat wait ( 0 0$1 ) ;
7766: LD_INT 35
7768: PPUSH
7769: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7773: LD_INT 3
7775: PPUSH
7776: LD_INT 1
7778: PPUSH
7779: CALL 45737 0 2
7783: PUSH
7784: LD_INT 6
7786: GREATEREQUAL
7787: IFFALSE 7766
// wait ( 0 0$30 ) ;
7789: LD_INT 1050
7791: PPUSH
7792: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7796: LD_ADDR_VAR 0 2
7800: PUSH
7801: LD_INT 3
7803: PPUSH
7804: LD_INT 1
7806: PPUSH
7807: CALL 45737 0 2
7811: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7812: LD_ADDR_EXP 107
7816: PUSH
7817: LD_EXP 107
7821: PPUSH
7822: LD_INT 3
7824: PPUSH
7825: LD_EXP 107
7829: PUSH
7830: LD_INT 3
7832: ARRAY
7833: PUSH
7834: LD_VAR 0 2
7838: DIFF
7839: PPUSH
7840: CALL_OW 1
7844: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7845: LD_ADDR_VAR 0 3
7849: PUSH
7850: LD_INT 0
7852: PPUSH
7853: LD_INT 2
7855: PPUSH
7856: CALL_OW 12
7860: ST_TO_ADDR
// if target then
7861: LD_VAR 0 3
7865: IFFALSE 7993
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7867: LD_ADDR_VAR 0 2
7871: PUSH
7872: LD_VAR 0 2
7876: PPUSH
7877: LD_INT 24
7879: PUSH
7880: LD_INT 250
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 72
7891: ST_TO_ADDR
// for i in tmp do
7892: LD_ADDR_VAR 0 1
7896: PUSH
7897: LD_VAR 0 2
7901: PUSH
7902: FOR_IN
7903: IFFALSE 7943
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7905: LD_VAR 0 1
7909: PPUSH
7910: LD_INT 89
7912: PPUSH
7913: LD_INT 71
7915: PPUSH
7916: CALL_OW 297
7920: PUSH
7921: LD_INT 9
7923: GREATER
7924: IFFALSE 7941
// ComMoveXY ( i , 89 , 71 ) ;
7926: LD_VAR 0 1
7930: PPUSH
7931: LD_INT 89
7933: PPUSH
7934: LD_INT 71
7936: PPUSH
7937: CALL_OW 111
7941: GO 7902
7943: POP
7944: POP
// wait ( 0 0$1 ) ;
7945: LD_INT 35
7947: PPUSH
7948: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7952: LD_VAR 0 2
7956: PPUSH
7957: LD_INT 92
7959: PUSH
7960: LD_INT 89
7962: PUSH
7963: LD_INT 71
7965: PUSH
7966: LD_INT 9
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PPUSH
7975: CALL_OW 72
7979: PUSH
7980: LD_VAR 0 2
7984: PUSH
7985: LD_INT 1
7987: MINUS
7988: GREATEREQUAL
7989: IFFALSE 7867
// end else
7991: GO 8117
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7993: LD_ADDR_VAR 0 2
7997: PUSH
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 24
8005: PUSH
8006: LD_INT 250
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: ST_TO_ADDR
// for i in tmp do
8018: LD_ADDR_VAR 0 1
8022: PUSH
8023: LD_VAR 0 2
8027: PUSH
8028: FOR_IN
8029: IFFALSE 8069
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8031: LD_VAR 0 1
8035: PPUSH
8036: LD_INT 147
8038: PPUSH
8039: LD_INT 4
8041: PPUSH
8042: CALL_OW 297
8046: PUSH
8047: LD_INT 9
8049: GREATER
8050: IFFALSE 8067
// ComMoveXY ( i , 147 , 4 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 147
8059: PPUSH
8060: LD_INT 4
8062: PPUSH
8063: CALL_OW 111
8067: GO 8028
8069: POP
8070: POP
// wait ( 0 0$1 ) ;
8071: LD_INT 35
8073: PPUSH
8074: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8078: LD_VAR 0 2
8082: PPUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 147
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 9
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 72
8105: PUSH
8106: LD_VAR 0 2
8110: PUSH
8111: LD_INT 1
8113: MINUS
8114: GREATEREQUAL
8115: IFFALSE 7993
// end ; repeat wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// for i in tmp do
8124: LD_ADDR_VAR 0 1
8128: PUSH
8129: LD_VAR 0 2
8133: PUSH
8134: FOR_IN
8135: IFFALSE 8217
// begin if GetLives ( i ) > 251 then
8137: LD_VAR 0 1
8141: PPUSH
8142: CALL_OW 256
8146: PUSH
8147: LD_INT 251
8149: GREATER
8150: IFFALSE 8188
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8152: LD_VAR 0 1
8156: PPUSH
8157: LD_INT 81
8159: PUSH
8160: LD_INT 8
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: PPUSH
8172: LD_VAR 0 1
8176: PPUSH
8177: CALL_OW 74
8181: PPUSH
8182: CALL_OW 115
8186: GO 8215
// if IsDead ( i ) then
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 301
8197: IFFALSE 8215
// tmp := tmp diff i ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_VAR 0 2
8208: PUSH
8209: LD_VAR 0 1
8213: DIFF
8214: ST_TO_ADDR
// end ;
8215: GO 8134
8217: POP
8218: POP
// until not tmp ;
8219: LD_VAR 0 2
8223: NOT
8224: IFFALSE 8117
// end ;
8226: PPOPN 3
8228: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8229: LD_EXP 55
8233: PPUSH
8234: CALL_OW 302
8238: PUSH
8239: LD_EXP 3
8243: NOT
8244: AND
8245: IFFALSE 8254
8247: GO 8249
8249: DISABLE
// BuildKozlovBomb ;
8250: CALL 7241 0 0
8254: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8255: LD_INT 22
8257: PUSH
8258: LD_INT 8
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 34
8267: PUSH
8268: LD_INT 48
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PPUSH
8279: CALL_OW 69
8283: IFFALSE 8331
8285: GO 8287
8287: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8288: LD_INT 22
8290: PUSH
8291: LD_INT 8
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: LD_INT 34
8300: PUSH
8301: LD_INT 48
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PPUSH
8312: CALL_OW 69
8316: PUSH
8317: LD_INT 1
8319: ARRAY
8320: PPUSH
8321: LD_INT 173
8323: PPUSH
8324: LD_INT 96
8326: PPUSH
8327: CALL_OW 116
// end ; end_of_file
8331: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8332: LD_INT 0
8334: PPUSH
8335: PPUSH
8336: PPUSH
8337: PPUSH
8338: PPUSH
8339: PPUSH
8340: PPUSH
8341: PPUSH
8342: PPUSH
// side := 3 ;
8343: LD_ADDR_VAR 0 6
8347: PUSH
8348: LD_INT 3
8350: ST_TO_ADDR
// InitHc ;
8351: CALL_OW 19
// uc_side := side ;
8355: LD_ADDR_OWVAR 20
8359: PUSH
8360: LD_VAR 0 6
8364: ST_TO_ADDR
// uc_nation := 3 ;
8365: LD_ADDR_OWVAR 21
8369: PUSH
8370: LD_INT 3
8372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 22
8380: PUSH
8381: LD_VAR 0 6
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 21
8392: PUSH
8393: LD_INT 3
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PPUSH
8404: CALL_OW 69
8408: PUSH
8409: FOR_IN
8410: IFFALSE 8426
// SetBLevel ( i , 10 ) ;
8412: LD_VAR 0 2
8416: PPUSH
8417: LD_INT 10
8419: PPUSH
8420: CALL_OW 241
8424: GO 8409
8426: POP
8427: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8428: LD_ADDR_VAR 0 9
8432: PUSH
8433: LD_INT 22
8435: PUSH
8436: LD_VAR 0 6
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: PUSH
8445: LD_INT 30
8447: PUSH
8448: LD_INT 34
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PUSH
8455: EMPTY
8456: LIST
8457: LIST
8458: PPUSH
8459: CALL_OW 69
8463: ST_TO_ADDR
// if teleport then
8464: LD_VAR 0 9
8468: IFFALSE 8489
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8470: LD_VAR 0 9
8474: PUSH
8475: LD_INT 1
8477: ARRAY
8478: PPUSH
8479: LD_INT 123
8481: PPUSH
8482: LD_INT 122
8484: PPUSH
8485: CALL_OW 243
// hc_importance := 0 ;
8489: LD_ADDR_OWVAR 32
8493: PUSH
8494: LD_INT 0
8496: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8497: LD_ADDR_EXP 56
8501: PUSH
8502: LD_STRING Platonov
8504: PPUSH
8505: CALL_OW 25
8509: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8510: LD_ADDR_EXP 57
8514: PUSH
8515: LD_STRING Yakotich
8517: PPUSH
8518: CALL_OW 25
8522: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8523: LD_ADDR_EXP 58
8527: PUSH
8528: LD_STRING Gleb
8530: PPUSH
8531: CALL_OW 25
8535: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8536: LD_STRING 03_Cornel
8538: PPUSH
8539: CALL_OW 28
8543: IFFALSE 8591
// begin Bierezov := NewCharacter ( Mikhail ) ;
8545: LD_ADDR_EXP 59
8549: PUSH
8550: LD_STRING Mikhail
8552: PPUSH
8553: CALL_OW 25
8557: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8558: LD_EXP 59
8562: PPUSH
8563: LD_INT 197
8565: PPUSH
8566: LD_INT 111
8568: PPUSH
8569: LD_INT 9
8571: PPUSH
8572: LD_INT 0
8574: PPUSH
8575: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8579: LD_EXP 59
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8591: LD_EXP 56
8595: PPUSH
8596: LD_INT 126
8598: PPUSH
8599: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8603: LD_EXP 57
8607: PPUSH
8608: LD_INT 197
8610: PPUSH
8611: LD_INT 111
8613: PPUSH
8614: LD_INT 9
8616: PPUSH
8617: LD_INT 0
8619: PPUSH
8620: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8624: LD_EXP 58
8628: PPUSH
8629: LD_INT 197
8631: PPUSH
8632: LD_INT 111
8634: PPUSH
8635: LD_INT 9
8637: PPUSH
8638: LD_INT 0
8640: PPUSH
8641: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8645: LD_ADDR_VAR 0 5
8649: PUSH
8650: LD_INT 126
8652: PPUSH
8653: LD_INT 2
8655: PPUSH
8656: LD_STRING zhukov
8658: PPUSH
8659: LD_INT 9
8661: PUSH
8662: LD_INT 10
8664: PUSH
8665: LD_INT 10
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_OWVAR 67
8677: ARRAY
8678: PPUSH
8679: LD_INT 9000
8681: PUSH
8682: LD_INT 1000
8684: PUSH
8685: LD_INT 300
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: LD_INT 21
8695: PUSH
8696: LD_INT 8
8698: PUSH
8699: LD_INT 13
8701: PUSH
8702: LD_INT 8
8704: PUSH
8705: EMPTY
8706: LIST
8707: LIST
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL 58896 0 6
8715: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8716: LD_ADDR_VAR 0 4
8720: PUSH
8721: LD_INT 267
8723: PPUSH
8724: CALL_OW 274
8728: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8729: LD_VAR 0 4
8733: PPUSH
8734: LD_INT 1
8736: PPUSH
8737: LD_INT 5000
8739: PPUSH
8740: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8744: LD_VAR 0 4
8748: PPUSH
8749: LD_INT 2
8751: PPUSH
8752: LD_INT 200
8754: PPUSH
8755: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8759: LD_VAR 0 4
8763: PPUSH
8764: LD_INT 3
8766: PPUSH
8767: LD_INT 200
8769: PPUSH
8770: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8774: LD_ADDR_EXP 88
8778: PUSH
8779: LD_EXP 88
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: LD_VAR 0 5
8791: PUSH
8792: LD_INT 22
8794: PUSH
8795: LD_VAR 0 6
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: LD_INT 3
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 2
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: PPUSH
8825: CALL_OW 69
8829: UNION
8830: PUSH
8831: LD_EXP 56
8835: DIFF
8836: PPUSH
8837: CALL_OW 1
8841: ST_TO_ADDR
// behemoths := [ ] ;
8842: LD_ADDR_EXP 60
8846: PUSH
8847: EMPTY
8848: ST_TO_ADDR
// behemothBuilders := [ ] ;
8849: LD_ADDR_EXP 61
8853: PUSH
8854: EMPTY
8855: ST_TO_ADDR
// j := 3 ;
8856: LD_ADDR_VAR 0 3
8860: PUSH
8861: LD_INT 3
8863: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8864: LD_ADDR_VAR 0 2
8868: PUSH
8869: LD_INT 22
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 25
8881: PUSH
8882: LD_INT 3
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PPUSH
8893: CALL_OW 69
8897: PUSH
8898: FOR_IN
8899: IFFALSE 8949
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8901: LD_ADDR_EXP 61
8905: PUSH
8906: LD_EXP 61
8910: PPUSH
8911: LD_VAR 0 2
8915: PPUSH
8916: CALL 86533 0 2
8920: ST_TO_ADDR
// j := j - 1 ;
8921: LD_ADDR_VAR 0 3
8925: PUSH
8926: LD_VAR 0 3
8930: PUSH
8931: LD_INT 1
8933: MINUS
8934: ST_TO_ADDR
// if j = 0 then
8935: LD_VAR 0 3
8939: PUSH
8940: LD_INT 0
8942: EQUAL
8943: IFFALSE 8947
// break ;
8945: GO 8949
// end ;
8947: GO 8898
8949: POP
8950: POP
// end ;
8951: LD_VAR 0 1
8955: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8956: LD_INT 0
8958: PPUSH
8959: PPUSH
8960: PPUSH
8961: PPUSH
8962: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8963: LD_ADDR_VAR 0 4
8967: PUSH
8968: LD_INT 209
8970: PUSH
8971: LD_INT 149
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: PUSH
8978: LD_INT 219
8980: PUSH
8981: LD_INT 154
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: PUSH
8988: LD_INT 223
8990: PUSH
8991: LD_INT 149
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: PUSH
8998: LD_INT 232
9000: PUSH
9001: LD_INT 155
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: ST_TO_ADDR
// if not behemothBuilders then
9014: LD_EXP 61
9018: NOT
9019: IFFALSE 9023
// exit ;
9021: GO 9127
// j := 1 ;
9023: LD_ADDR_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ST_TO_ADDR
// for i in behemothBuilders do
9031: LD_ADDR_VAR 0 2
9035: PUSH
9036: LD_EXP 61
9040: PUSH
9041: FOR_IN
9042: IFFALSE 9125
// begin if IsInUnit ( i ) then
9044: LD_VAR 0 2
9048: PPUSH
9049: CALL_OW 310
9053: IFFALSE 9064
// ComExitBuilding ( i ) ;
9055: LD_VAR 0 2
9059: PPUSH
9060: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9064: LD_VAR 0 2
9068: PPUSH
9069: LD_INT 37
9071: PPUSH
9072: LD_VAR 0 4
9076: PUSH
9077: LD_VAR 0 3
9081: ARRAY
9082: PUSH
9083: LD_INT 1
9085: ARRAY
9086: PPUSH
9087: LD_VAR 0 4
9091: PUSH
9092: LD_VAR 0 3
9096: ARRAY
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_INT 0
9104: PPUSH
9105: CALL_OW 230
// j := j + 1 ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_VAR 0 3
9118: PUSH
9119: LD_INT 1
9121: PLUS
9122: ST_TO_ADDR
// end ;
9123: GO 9041
9125: POP
9126: POP
// end ;
9127: LD_VAR 0 1
9131: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9132: LD_INT 3
9134: PPUSH
9135: CALL 86594 0 1
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 30
9152: PUSH
9153: LD_INT 37
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: NOT
9169: AND
9170: IFFALSE 9356
9172: GO 9174
9174: DISABLE
9175: LD_INT 0
9177: PPUSH
9178: PPUSH
// begin enable ;
9179: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9180: LD_ADDR_VAR 0 2
9184: PUSH
9185: LD_INT 3
9187: PPUSH
9188: CALL 86594 0 1
9192: ST_TO_ADDR
// for i in tmp do
9193: LD_ADDR_VAR 0 1
9197: PUSH
9198: LD_VAR 0 2
9202: PUSH
9203: FOR_IN
9204: IFFALSE 9354
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_INT 7
9213: PPUSH
9214: CALL_OW 308
9218: PUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: CALL_OW 110
9228: PUSH
9229: LD_INT 2
9231: EQUAL
9232: NOT
9233: AND
9234: IFFALSE 9248
// SetTag ( i , 2 ) ;
9236: LD_VAR 0 1
9240: PPUSH
9241: LD_INT 2
9243: PPUSH
9244: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9248: LD_INT 81
9250: PUSH
9251: LD_INT 3
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: LD_INT 91
9260: PUSH
9261: LD_VAR 0 1
9265: PUSH
9266: LD_INT 12
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PPUSH
9278: CALL_OW 69
9282: NOT
9283: PUSH
9284: LD_VAR 0 1
9288: PPUSH
9289: CALL_OW 110
9293: PUSH
9294: LD_INT 2
9296: EQUAL
9297: NOT
9298: AND
9299: IFFALSE 9318
// ComAgressiveMove ( i , 64 , 93 ) else
9301: LD_VAR 0 1
9305: PPUSH
9306: LD_INT 64
9308: PPUSH
9309: LD_INT 93
9311: PPUSH
9312: CALL_OW 114
9316: GO 9352
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9318: LD_VAR 0 1
9322: PPUSH
9323: LD_INT 81
9325: PUSH
9326: LD_INT 3
9328: PUSH
9329: EMPTY
9330: LIST
9331: LIST
9332: PPUSH
9333: CALL_OW 69
9337: PPUSH
9338: LD_VAR 0 1
9342: PPUSH
9343: CALL_OW 74
9347: PPUSH
9348: CALL_OW 115
// end ;
9352: GO 9203
9354: POP
9355: POP
// end ;
9356: PPOPN 2
9358: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9359: LD_EXP 2
9363: NOT
9364: PUSH
9365: LD_INT 2
9367: PPUSH
9368: LD_INT 1
9370: PPUSH
9371: CALL 45737 0 2
9375: NOT
9376: AND
9377: IFFALSE 10297
9379: GO 9381
9381: DISABLE
9382: LD_INT 0
9384: PPUSH
9385: PPUSH
9386: PPUSH
9387: PPUSH
// begin enable ;
9388: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 30
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: NOT
9418: IFFALSE 9422
// exit ;
9420: GO 10297
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9422: LD_ADDR_VAR 0 4
9426: PUSH
9427: LD_INT 22
9429: PUSH
9430: LD_INT 3
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PUSH
9437: LD_INT 30
9439: PUSH
9440: LD_INT 34
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: ST_TO_ADDR
// if Prob ( 40 ) then
9456: LD_INT 40
9458: PPUSH
9459: CALL_OW 13
9463: IFFALSE 9590
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9465: LD_INT 2
9467: PPUSH
9468: LD_INT 22
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: LD_INT 49
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 22
9488: PUSH
9489: LD_INT 3
9491: PUSH
9492: LD_INT 3
9494: PUSH
9495: LD_INT 49
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: PUSH
9504: LD_INT 22
9506: PUSH
9507: LD_INT 3
9509: PUSH
9510: LD_INT 3
9512: PUSH
9513: LD_INT 49
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: PUSH
9522: LD_INT 24
9524: PUSH
9525: LD_INT 3
9527: PUSH
9528: LD_INT 3
9530: PUSH
9531: LD_INT 46
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 24
9542: PUSH
9543: LD_INT 3
9545: PUSH
9546: LD_INT 3
9548: PUSH
9549: LD_INT 46
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 24
9560: PUSH
9561: LD_INT 3
9563: PUSH
9564: LD_INT 3
9566: PUSH
9567: LD_INT 46
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: PPUSH
9584: CALL 44319 0 2
// end else
9588: GO 9713
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9590: LD_INT 2
9592: PPUSH
9593: LD_INT 24
9595: PUSH
9596: LD_INT 3
9598: PUSH
9599: LD_INT 3
9601: PUSH
9602: LD_INT 47
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: PUSH
9611: LD_INT 24
9613: PUSH
9614: LD_INT 3
9616: PUSH
9617: LD_INT 3
9619: PUSH
9620: LD_INT 47
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_INT 24
9631: PUSH
9632: LD_INT 3
9634: PUSH
9635: LD_INT 3
9637: PUSH
9638: LD_INT 47
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 24
9649: PUSH
9650: LD_INT 3
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: LD_INT 46
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: PUSH
9665: LD_INT 24
9667: PUSH
9668: LD_INT 3
9670: PUSH
9671: LD_INT 3
9673: PUSH
9674: LD_INT 46
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: PUSH
9683: LD_INT 24
9685: PUSH
9686: LD_INT 3
9688: PUSH
9689: LD_INT 3
9691: PUSH
9692: LD_INT 46
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: PPUSH
9709: CALL 44319 0 2
// end ; if Difficulty > 1 then
9713: LD_OWVAR 67
9717: PUSH
9718: LD_INT 1
9720: GREATER
9721: IFFALSE 9751
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9723: LD_INT 2
9725: PPUSH
9726: LD_INT 24
9728: PUSH
9729: LD_INT 3
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 47
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: PPUSH
9747: CALL 44319 0 2
// repeat wait ( 0 0$1 ) ;
9751: LD_INT 35
9753: PPUSH
9754: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9758: LD_INT 2
9760: PPUSH
9761: LD_INT 1
9763: PPUSH
9764: CALL 45737 0 2
9768: PUSH
9769: LD_INT 6
9771: PUSH
9772: LD_INT 7
9774: PUSH
9775: LD_INT 7
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_OWVAR 67
9787: ARRAY
9788: GREATEREQUAL
9789: IFFALSE 9751
// wait ( 0 0$30 ) ;
9791: LD_INT 1050
9793: PPUSH
9794: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 2
9805: PPUSH
9806: LD_INT 1
9808: PPUSH
9809: CALL 45737 0 2
9813: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9814: LD_ADDR_EXP 107
9818: PUSH
9819: LD_EXP 107
9823: PPUSH
9824: LD_INT 2
9826: PPUSH
9827: LD_EXP 107
9831: PUSH
9832: LD_INT 2
9834: ARRAY
9835: PUSH
9836: LD_VAR 0 2
9840: DIFF
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9847: LD_ADDR_VAR 0 3
9851: PUSH
9852: LD_INT 0
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL_OW 12
9862: ST_TO_ADDR
// if target then
9863: LD_VAR 0 3
9867: IFFALSE 9995
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9869: LD_ADDR_VAR 0 2
9873: PUSH
9874: LD_VAR 0 2
9878: PPUSH
9879: LD_INT 24
9881: PUSH
9882: LD_INT 250
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PPUSH
9889: CALL_OW 72
9893: ST_TO_ADDR
// for i in tmp do
9894: LD_ADDR_VAR 0 1
9898: PUSH
9899: LD_VAR 0 2
9903: PUSH
9904: FOR_IN
9905: IFFALSE 9945
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 139
9914: PPUSH
9915: LD_INT 89
9917: PPUSH
9918: CALL_OW 297
9922: PUSH
9923: LD_INT 9
9925: GREATER
9926: IFFALSE 9943
// ComMoveXY ( i , 139 , 89 ) ;
9928: LD_VAR 0 1
9932: PPUSH
9933: LD_INT 139
9935: PPUSH
9936: LD_INT 89
9938: PPUSH
9939: CALL_OW 111
9943: GO 9904
9945: POP
9946: POP
// wait ( 0 0$1 ) ;
9947: LD_INT 35
9949: PPUSH
9950: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9954: LD_VAR 0 2
9958: PPUSH
9959: LD_INT 92
9961: PUSH
9962: LD_INT 139
9964: PUSH
9965: LD_INT 89
9967: PUSH
9968: LD_INT 9
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: LIST
9975: LIST
9976: PPUSH
9977: CALL_OW 72
9981: PUSH
9982: LD_VAR 0 2
9986: PUSH
9987: LD_INT 1
9989: MINUS
9990: GREATEREQUAL
9991: IFFALSE 9869
// end else
9993: GO 10137
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9995: LD_VAR 0 2
9999: PPUSH
10000: LD_VAR 0 4
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PPUSH
10009: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10013: LD_ADDR_VAR 0 2
10017: PUSH
10018: LD_VAR 0 2
10022: PPUSH
10023: LD_INT 24
10025: PUSH
10026: LD_INT 250
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PPUSH
10033: CALL_OW 72
10037: ST_TO_ADDR
// for i in tmp do
10038: LD_ADDR_VAR 0 1
10042: PUSH
10043: LD_VAR 0 2
10047: PUSH
10048: FOR_IN
10049: IFFALSE 10089
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10051: LD_VAR 0 1
10055: PPUSH
10056: LD_INT 124
10058: PPUSH
10059: LD_INT 139
10061: PPUSH
10062: CALL_OW 297
10066: PUSH
10067: LD_INT 9
10069: GREATER
10070: IFFALSE 10087
// ComMoveXY ( i , 124 , 139 ) ;
10072: LD_VAR 0 1
10076: PPUSH
10077: LD_INT 124
10079: PPUSH
10080: LD_INT 139
10082: PPUSH
10083: CALL_OW 111
10087: GO 10048
10089: POP
10090: POP
// wait ( 0 0$1 ) ;
10091: LD_INT 35
10093: PPUSH
10094: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10098: LD_VAR 0 2
10102: PPUSH
10103: LD_INT 92
10105: PUSH
10106: LD_INT 124
10108: PUSH
10109: LD_INT 139
10111: PUSH
10112: LD_INT 9
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 72
10125: PUSH
10126: LD_VAR 0 2
10130: PUSH
10131: LD_INT 1
10133: MINUS
10134: GREATEREQUAL
10135: IFFALSE 10013
// end ; repeat wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// for i in tmp do
10144: LD_ADDR_VAR 0 1
10148: PUSH
10149: LD_VAR 0 2
10153: PUSH
10154: FOR_IN
10155: IFFALSE 10288
// begin if GetLives ( i ) > 251 then
10157: LD_VAR 0 1
10161: PPUSH
10162: CALL_OW 256
10166: PUSH
10167: LD_INT 251
10169: GREATER
10170: IFFALSE 10259
// begin if GetWeapon ( i ) = ru_time_lapser then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 264
10181: PUSH
10182: LD_INT 49
10184: EQUAL
10185: IFFALSE 10223
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10187: LD_VAR 0 1
10191: PPUSH
10192: LD_INT 81
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: PPUSH
10202: CALL_OW 69
10206: PPUSH
10207: LD_VAR 0 1
10211: PPUSH
10212: CALL_OW 74
10216: PPUSH
10217: CALL_OW 112
10221: GO 10257
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10223: LD_VAR 0 1
10227: PPUSH
10228: LD_INT 81
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PPUSH
10238: CALL_OW 69
10242: PPUSH
10243: LD_VAR 0 1
10247: PPUSH
10248: CALL_OW 74
10252: PPUSH
10253: CALL_OW 115
// end else
10257: GO 10286
// if IsDead ( i ) then
10259: LD_VAR 0 1
10263: PPUSH
10264: CALL_OW 301
10268: IFFALSE 10286
// tmp := tmp diff i ;
10270: LD_ADDR_VAR 0 2
10274: PUSH
10275: LD_VAR 0 2
10279: PUSH
10280: LD_VAR 0 1
10284: DIFF
10285: ST_TO_ADDR
// end ;
10286: GO 10154
10288: POP
10289: POP
// until not tmp ;
10290: LD_VAR 0 2
10294: NOT
10295: IFFALSE 10137
// end ;
10297: PPOPN 4
10299: END
// every 30 30$00 trigger not russianDestroyed do
10300: LD_EXP 2
10304: NOT
10305: IFFALSE 10370
10307: GO 10309
10309: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10310: LD_INT 105000
10312: PUSH
10313: LD_INT 84000
10315: PUSH
10316: LD_INT 63000
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: LIST
10323: PUSH
10324: LD_OWVAR 67
10328: ARRAY
10329: PPUSH
10330: CALL_OW 67
// if russianDestroyed then
10334: LD_EXP 2
10338: IFFALSE 10342
// exit ;
10340: GO 10370
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 23
10347: PUSH
10348: LD_INT 3
10350: PUSH
10351: LD_INT 1
10353: PUSH
10354: LD_INT 48
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PUSH
10363: EMPTY
10364: LIST
10365: PPUSH
10366: CALL 44319 0 2
// end ; end_of_file
10370: END
// export function CustomEvent ( event ) ; begin
10371: LD_INT 0
10373: PPUSH
// end ;
10374: LD_VAR 0 2
10378: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10379: LD_VAR 0 2
10383: PPUSH
10384: LD_VAR 0 3
10388: PPUSH
10389: LD_INT 15
10391: PPUSH
10392: CALL_OW 309
10396: IFFALSE 10405
// YouLost ( MothContaminate ) ;
10398: LD_STRING MothContaminate
10400: PPUSH
10401: CALL_OW 104
// end ;
10405: PPOPN 3
10407: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10408: LD_VAR 0 2
10412: PPUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 15
10420: PPUSH
10421: CALL_OW 309
10425: IFFALSE 10441
// begin wait ( 0 0$6 ) ;
10427: LD_INT 210
10429: PPUSH
10430: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10434: LD_STRING MothContaminateBomb
10436: PPUSH
10437: CALL_OW 104
// end ; end ;
10441: PPOPN 3
10443: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10444: LD_VAR 0 1
10448: PUSH
10449: LD_EXP 17
10453: EQUAL
10454: IFFALSE 10465
// begin YouLost ( JMM ) ;
10456: LD_STRING JMM
10458: PPUSH
10459: CALL_OW 104
// exit ;
10463: GO 10564
// end ; if un = Powell then
10465: LD_VAR 0 1
10469: PUSH
10470: LD_EXP 52
10474: EQUAL
10475: IFFALSE 10485
// americanDestroyed := true ;
10477: LD_ADDR_EXP 4
10481: PUSH
10482: LD_INT 1
10484: ST_TO_ADDR
// if un = Platonov then
10485: LD_VAR 0 1
10489: PUSH
10490: LD_EXP 56
10494: EQUAL
10495: IFFALSE 10505
// russianDestroyed := true ;
10497: LD_ADDR_EXP 2
10501: PUSH
10502: LD_INT 1
10504: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10505: LD_VAR 0 1
10509: PUSH
10510: LD_INT 22
10512: PUSH
10513: LD_INT 7
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 21
10522: PUSH
10523: LD_INT 2
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IN
10539: IFFALSE 10555
// vehicleLostCounter := vehicleLostCounter + 1 ;
10541: LD_ADDR_EXP 15
10545: PUSH
10546: LD_EXP 15
10550: PUSH
10551: LD_INT 1
10553: PLUS
10554: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL 47711 0 1
// end ;
10564: PPOPN 1
10566: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10567: LD_VAR 0 1
10571: PPUSH
10572: LD_VAR 0 2
10576: PPUSH
10577: CALL 50045 0 2
// end ;
10581: PPOPN 2
10583: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10584: LD_VAR 0 1
10588: PPUSH
10589: CALL 49113 0 1
// end ;
10593: PPOPN 1
10595: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10596: LD_VAR 0 1
10600: PUSH
10601: LD_INT 22
10603: PUSH
10604: LD_INT 8
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 30
10613: PUSH
10614: LD_INT 2
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 23
10623: PUSH
10624: LD_INT 3
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: IN
10641: IFFALSE 10668
// begin ComUpgrade ( building ) ;
10643: LD_VAR 0 1
10647: PPUSH
10648: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10652: LD_EXP 55
10656: PPUSH
10657: LD_VAR 0 1
10661: PPUSH
10662: CALL 58460 0 2
// exit ;
10666: GO 10677
// end ; MCE_BuildingComplete ( building ) ;
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL 49354 0 1
// end ;
10677: PPOPN 1
10679: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10680: LD_VAR 0 1
10684: PPUSH
10685: LD_VAR 0 2
10689: PPUSH
10690: CALL 47407 0 2
// end ;
10694: PPOPN 2
10696: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_VAR 0 2
10706: PPUSH
10707: LD_VAR 0 3
10711: PPUSH
10712: LD_VAR 0 4
10716: PPUSH
10717: LD_VAR 0 5
10721: PPUSH
10722: CALL 47027 0 5
// end ;
10726: PPOPN 5
10728: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10729: LD_VAR 0 1
10733: PPUSH
10734: LD_VAR 0 2
10738: PPUSH
10739: CALL 46623 0 2
// end ;
10743: PPOPN 2
10745: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10746: LD_VAR 0 1
10750: PPUSH
10751: LD_VAR 0 2
10755: PPUSH
10756: LD_VAR 0 3
10760: PPUSH
10761: LD_VAR 0 4
10765: PPUSH
10766: CALL 46461 0 4
// end ;
10770: PPOPN 4
10772: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10773: LD_VAR 0 1
10777: PPUSH
10778: LD_VAR 0 2
10782: PPUSH
10783: LD_VAR 0 3
10787: PPUSH
10788: CALL 46236 0 3
// end ;
10792: PPOPN 3
10794: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10795: LD_VAR 0 1
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: CALL 46121 0 2
// end ;
10809: PPOPN 2
10811: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_VAR 0 2
10821: PPUSH
10822: CALL 50306 0 2
// end ;
10826: PPOPN 2
10828: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10829: LD_VAR 0 1
10833: PPUSH
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_VAR 0 3
10843: PPUSH
10844: LD_VAR 0 4
10848: PPUSH
10849: CALL 50522 0 4
// end ;
10853: PPOPN 4
10855: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10856: LD_VAR 0 1
10860: PPUSH
10861: LD_VAR 0 2
10865: PPUSH
10866: CALL 45930 0 2
// end ;
10870: PPOPN 2
10872: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10873: LD_VAR 0 1
10877: PPUSH
10878: CALL 98181 0 1
// end ; end_of_file
10882: PPOPN 1
10884: END
// export function Action ; begin
10885: LD_INT 0
10887: PPUSH
// InGameOn ;
10888: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10892: LD_INT 206
10894: PPUSH
10895: LD_INT 11
10897: PPUSH
10898: CALL_OW 86
// wait ( 0 0$1 ) ;
10902: LD_INT 35
10904: PPUSH
10905: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10909: LD_EXP 17
10913: PPUSH
10914: LD_STRING DStart-JMM-JMM-1
10916: PPUSH
10917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10921: LD_EXP 49
10925: PPUSH
10926: LD_STRING DStart-JMM-Bur-1
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10933: LD_EXP 17
10937: PPUSH
10938: LD_STRING DStart-JMM-JMM-2
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10945: LD_EXP 49
10949: PPUSH
10950: LD_STRING DStart-JMM-Bur-2
10952: PPUSH
10953: CALL_OW 88
// InGameOff ;
10957: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10961: LD_STRING MStart
10963: PPUSH
10964: CALL_OW 337
// SaveForQuickRestart ;
10968: CALL_OW 22
// end ;
10972: LD_VAR 0 1
10976: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10977: LD_INT 7
10979: PPUSH
10980: LD_INT 255
10982: PPUSH
10983: LD_INT 219
10985: PPUSH
10986: CALL_OW 293
10990: IFFALSE 11599
10992: GO 10994
10994: DISABLE
10995: LD_INT 0
10997: PPUSH
// begin wait ( 0 0$3 ) ;
10998: LD_INT 105
11000: PPUSH
11001: CALL_OW 67
// alienSpotted := true ;
11005: LD_ADDR_EXP 10
11009: PUSH
11010: LD_INT 1
11012: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11013: LD_ADDR_VAR 0 1
11017: PUSH
11018: LD_INT 22
11020: PUSH
11021: LD_INT 7
11023: PUSH
11024: EMPTY
11025: LIST
11026: LIST
11027: PUSH
11028: LD_INT 23
11030: PUSH
11031: LD_INT 3
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PUSH
11038: LD_INT 21
11040: PUSH
11041: LD_INT 1
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: PUSH
11048: LD_INT 26
11050: PUSH
11051: LD_INT 1
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: LIST
11062: LIST
11063: PPUSH
11064: CALL_OW 69
11068: PUSH
11069: LD_EXP 49
11073: PUSH
11074: LD_EXP 37
11078: PUSH
11079: LD_EXP 39
11083: PUSH
11084: LD_EXP 40
11088: PUSH
11089: LD_EXP 47
11093: PUSH
11094: LD_EXP 46
11098: PUSH
11099: LD_EXP 41
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: LIST
11111: LIST
11112: DIFF
11113: ST_TO_ADDR
// DialogueOn ;
11114: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11118: LD_INT 255
11120: PPUSH
11121: LD_INT 219
11123: PPUSH
11124: LD_INT 7
11126: PPUSH
11127: LD_INT 20
11129: NEG
11130: PPUSH
11131: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11135: LD_INT 255
11137: PPUSH
11138: LD_INT 219
11140: PPUSH
11141: CALL_OW 86
// if speaker then
11145: LD_VAR 0 1
11149: IFFALSE 11167
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11151: LD_VAR 0 1
11155: PUSH
11156: LD_INT 1
11158: ARRAY
11159: PPUSH
11160: LD_STRING DAlienBase-RSol1-1
11162: PPUSH
11163: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11167: LD_EXP 17
11171: PPUSH
11172: LD_STRING DAlienBase-JMM-1
11174: PPUSH
11175: CALL_OW 88
// if IsOk ( Burlak ) then
11179: LD_EXP 49
11183: PPUSH
11184: CALL_OW 302
11188: IFFALSE 11209
// begin dwait ( 0 0$1 ) ;
11190: LD_INT 35
11192: PPUSH
11193: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11197: LD_EXP 49
11201: PPUSH
11202: LD_STRING DAlienBase-Bur-1
11204: PPUSH
11205: CALL_OW 88
// end ; if IsOk ( Roth ) then
11209: LD_EXP 18
11213: PPUSH
11214: CALL_OW 302
11218: IFFALSE 11232
// Say ( Roth , DAlienBase-Roth-1 ) ;
11220: LD_EXP 18
11224: PPUSH
11225: LD_STRING DAlienBase-Roth-1
11227: PPUSH
11228: CALL_OW 88
// if IsOk ( Gossudarov ) then
11232: LD_EXP 35
11236: PPUSH
11237: CALL_OW 302
11241: IFFALSE 11257
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11243: LD_EXP 35
11247: PPUSH
11248: LD_STRING DAlienBase-Gos-1
11250: PPUSH
11251: CALL_OW 88
11255: GO 11374
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11257: LD_ADDR_VAR 0 1
11261: PUSH
11262: LD_INT 22
11264: PUSH
11265: LD_INT 7
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: PUSH
11272: LD_INT 25
11274: PUSH
11275: LD_INT 4
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: PUSH
11282: LD_INT 21
11284: PUSH
11285: LD_INT 1
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PUSH
11292: LD_INT 26
11294: PUSH
11295: LD_INT 1
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: PUSH
11302: EMPTY
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: PPUSH
11308: CALL_OW 69
11312: PUSH
11313: LD_EXP 18
11317: PUSH
11318: LD_EXP 17
11322: PUSH
11323: LD_EXP 49
11327: PUSH
11328: LD_EXP 37
11332: PUSH
11333: LD_EXP 47
11337: PUSH
11338: LD_EXP 46
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: LIST
11347: LIST
11348: LIST
11349: LIST
11350: DIFF
11351: ST_TO_ADDR
// if speaker then
11352: LD_VAR 0 1
11356: IFFALSE 11374
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11358: LD_VAR 0 1
11362: PUSH
11363: LD_INT 1
11365: ARRAY
11366: PPUSH
11367: LD_STRING DAlienBase-Sci1-1
11369: PPUSH
11370: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11374: LD_INT 255
11376: PPUSH
11377: LD_INT 219
11379: PPUSH
11380: LD_INT 7
11382: PPUSH
11383: CALL_OW 331
// DialogueOff ;
11387: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// until IsSelected ( alien ) ;
11398: LD_INT 1
11400: PPUSH
11401: CALL_OW 306
11405: IFFALSE 11391
// if not artifactIResearched or not artifactIIResearched then
11407: LD_EXP 12
11411: NOT
11412: PUSH
11413: LD_EXP 13
11417: NOT
11418: OR
11419: IFFALSE 11599
// begin if IsOk ( Roth ) then
11421: LD_EXP 18
11425: PPUSH
11426: CALL_OW 302
11430: IFFALSE 11446
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11432: LD_EXP 18
11436: PPUSH
11437: LD_STRING DAlieBaseNotReady-Roth-1
11439: PPUSH
11440: CALL_OW 88
11444: GO 11599
// if IsOk ( Gossudarov ) then
11446: LD_EXP 35
11450: PPUSH
11451: CALL_OW 302
11455: IFFALSE 11471
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11457: LD_EXP 35
11461: PPUSH
11462: LD_STRING DAlieBaseNotReady-Gos-1
11464: PPUSH
11465: CALL_OW 88
11469: GO 11599
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11471: LD_ADDR_VAR 0 1
11475: PUSH
11476: LD_INT 22
11478: PUSH
11479: LD_INT 7
11481: PUSH
11482: EMPTY
11483: LIST
11484: LIST
11485: PUSH
11486: LD_INT 23
11488: PUSH
11489: LD_INT 3
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: PUSH
11496: LD_INT 25
11498: PUSH
11499: LD_INT 4
11501: PUSH
11502: EMPTY
11503: LIST
11504: LIST
11505: PUSH
11506: LD_INT 21
11508: PUSH
11509: LD_INT 1
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: PUSH
11516: LD_INT 26
11518: PUSH
11519: LD_INT 1
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: PUSH
11526: EMPTY
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: PPUSH
11533: CALL_OW 69
11537: PUSH
11538: LD_EXP 18
11542: PUSH
11543: LD_EXP 17
11547: PUSH
11548: LD_EXP 49
11552: PUSH
11553: LD_EXP 37
11557: PUSH
11558: LD_EXP 47
11562: PUSH
11563: LD_EXP 46
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: LIST
11572: LIST
11573: LIST
11574: LIST
11575: DIFF
11576: ST_TO_ADDR
// if speaker then
11577: LD_VAR 0 1
11581: IFFALSE 11599
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11583: LD_VAR 0 1
11587: PUSH
11588: LD_INT 1
11590: ARRAY
11591: PPUSH
11592: LD_STRING DAlieBaseNotReady-RSci1-1
11594: PPUSH
11595: CALL_OW 88
// end ; end ; end ;
11599: PPOPN 1
11601: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11602: LD_INT 24
11604: PPUSH
11605: LD_INT 7
11607: PPUSH
11608: CALL_OW 321
11612: PUSH
11613: LD_INT 2
11615: EQUAL
11616: IFFALSE 12307
11618: GO 11620
11620: DISABLE
11621: LD_INT 0
11623: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11624: LD_ADDR_VAR 0 1
11628: PUSH
11629: LD_INT 22
11631: PUSH
11632: LD_INT 7
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: PUSH
11639: LD_INT 23
11641: PUSH
11642: LD_INT 3
11644: PUSH
11645: EMPTY
11646: LIST
11647: LIST
11648: PUSH
11649: LD_INT 25
11651: PUSH
11652: LD_INT 4
11654: PUSH
11655: EMPTY
11656: LIST
11657: LIST
11658: PUSH
11659: LD_INT 21
11661: PUSH
11662: LD_INT 1
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: PUSH
11669: LD_INT 26
11671: PUSH
11672: LD_INT 1
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: PPUSH
11686: CALL_OW 69
11690: PUSH
11691: LD_EXP 18
11695: PUSH
11696: LD_EXP 17
11700: PUSH
11701: LD_EXP 49
11705: PUSH
11706: LD_EXP 37
11710: PUSH
11711: LD_EXP 47
11715: PUSH
11716: LD_EXP 46
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: DIFF
11729: ST_TO_ADDR
// if not speaker then
11730: LD_VAR 0 1
11734: NOT
11735: IFFALSE 11739
// exit ;
11737: GO 12307
// DialogueOn ;
11739: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11743: LD_VAR 0 1
11747: PUSH
11748: LD_INT 1
11750: ARRAY
11751: PPUSH
11752: LD_STRING DArtefTechnology-RSci1-1
11754: PPUSH
11755: CALL_OW 88
// if IsOk ( Burlak ) then
11759: LD_EXP 49
11763: PPUSH
11764: CALL_OW 302
11768: IFFALSE 11782
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11770: LD_EXP 49
11774: PPUSH
11775: LD_STRING DArtefTechnology-Bur-1
11777: PPUSH
11778: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11782: LD_VAR 0 1
11786: PUSH
11787: LD_INT 1
11789: ARRAY
11790: PPUSH
11791: LD_STRING DArtefTechnology-RSci1-2
11793: PPUSH
11794: CALL_OW 88
// if Denis then
11798: LD_EXP 23
11802: IFFALSE 11819
// speaker := [ Denis ] else
11804: LD_ADDR_VAR 0 1
11808: PUSH
11809: LD_EXP 23
11813: PUSH
11814: EMPTY
11815: LIST
11816: ST_TO_ADDR
11817: GO 11925
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11819: LD_ADDR_VAR 0 1
11823: PUSH
11824: LD_INT 22
11826: PUSH
11827: LD_INT 7
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: LD_INT 23
11836: PUSH
11837: LD_INT 1
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: PUSH
11844: LD_INT 25
11846: PUSH
11847: LD_INT 4
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PUSH
11854: LD_INT 21
11856: PUSH
11857: LD_INT 1
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PUSH
11864: LD_INT 26
11866: PUSH
11867: LD_INT 1
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: PPUSH
11881: CALL_OW 69
11885: PUSH
11886: LD_EXP 18
11890: PUSH
11891: LD_EXP 17
11895: PUSH
11896: LD_EXP 49
11900: PUSH
11901: LD_EXP 37
11905: PUSH
11906: LD_EXP 47
11910: PUSH
11911: LD_EXP 46
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: LIST
11920: LIST
11921: LIST
11922: LIST
11923: DIFF
11924: ST_TO_ADDR
// if speaker then
11925: LD_VAR 0 1
11929: IFFALSE 11947
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11931: LD_VAR 0 1
11935: PUSH
11936: LD_INT 1
11938: ARRAY
11939: PPUSH
11940: LD_STRING DArtefTechnology-Sci1-2
11942: PPUSH
11943: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11947: LD_ADDR_VAR 0 1
11951: PUSH
11952: LD_INT 22
11954: PUSH
11955: LD_INT 7
11957: PUSH
11958: EMPTY
11959: LIST
11960: LIST
11961: PUSH
11962: LD_INT 23
11964: PUSH
11965: LD_INT 3
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 25
11974: PUSH
11975: LD_INT 4
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: LD_INT 21
11984: PUSH
11985: LD_INT 1
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PUSH
11992: LD_INT 26
11994: PUSH
11995: LD_INT 1
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PUSH
12002: EMPTY
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: PPUSH
12009: CALL_OW 69
12013: PUSH
12014: LD_EXP 18
12018: PUSH
12019: LD_EXP 17
12023: PUSH
12024: LD_EXP 49
12028: PUSH
12029: LD_EXP 37
12033: PUSH
12034: LD_EXP 47
12038: PUSH
12039: LD_EXP 46
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: LIST
12048: LIST
12049: LIST
12050: LIST
12051: DIFF
12052: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12053: LD_VAR 0 1
12057: PUSH
12058: LD_EXP 9
12062: PUSH
12063: LD_EXP 5
12067: OR
12068: AND
12069: IFFALSE 12303
// begin if arabianDestroyed and IsOk ( Burlak ) then
12071: LD_EXP 5
12075: PUSH
12076: LD_EXP 49
12080: PPUSH
12081: CALL_OW 302
12085: AND
12086: IFFALSE 12102
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12088: LD_EXP 49
12092: PPUSH
12093: LD_STRING DArtefTechnology-Bur-2
12095: PPUSH
12096: CALL_OW 88
12100: GO 12114
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12102: LD_EXP 17
12106: PPUSH
12107: LD_STRING DArtefTechnology-JMM-2
12109: PPUSH
12110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12114: LD_VAR 0 1
12118: PUSH
12119: LD_INT 1
12121: ARRAY
12122: PPUSH
12123: LD_STRING DArtefTechnology-RSci1-3
12125: PPUSH
12126: CALL_OW 88
// if Denis then
12130: LD_EXP 23
12134: IFFALSE 12151
// speaker := [ Denis ] else
12136: LD_ADDR_VAR 0 1
12140: PUSH
12141: LD_EXP 23
12145: PUSH
12146: EMPTY
12147: LIST
12148: ST_TO_ADDR
12149: GO 12257
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12151: LD_ADDR_VAR 0 1
12155: PUSH
12156: LD_INT 22
12158: PUSH
12159: LD_INT 7
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PUSH
12166: LD_INT 23
12168: PUSH
12169: LD_INT 1
12171: PUSH
12172: EMPTY
12173: LIST
12174: LIST
12175: PUSH
12176: LD_INT 25
12178: PUSH
12179: LD_INT 4
12181: PUSH
12182: EMPTY
12183: LIST
12184: LIST
12185: PUSH
12186: LD_INT 21
12188: PUSH
12189: LD_INT 1
12191: PUSH
12192: EMPTY
12193: LIST
12194: LIST
12195: PUSH
12196: LD_INT 26
12198: PUSH
12199: LD_INT 1
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: EMPTY
12207: LIST
12208: LIST
12209: LIST
12210: LIST
12211: LIST
12212: PPUSH
12213: CALL_OW 69
12217: PUSH
12218: LD_EXP 18
12222: PUSH
12223: LD_EXP 17
12227: PUSH
12228: LD_EXP 49
12232: PUSH
12233: LD_EXP 37
12237: PUSH
12238: LD_EXP 47
12242: PUSH
12243: LD_EXP 46
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: DIFF
12256: ST_TO_ADDR
// if speaker then
12257: LD_VAR 0 1
12261: IFFALSE 12303
// if alienSpotted then
12263: LD_EXP 10
12267: IFFALSE 12287
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12269: LD_VAR 0 1
12273: PUSH
12274: LD_INT 1
12276: ARRAY
12277: PPUSH
12278: LD_STRING DArtefTechnology-Sci1-3
12280: PPUSH
12281: CALL_OW 88
12285: GO 12303
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12287: LD_VAR 0 1
12291: PUSH
12292: LD_INT 1
12294: ARRAY
12295: PPUSH
12296: LD_STRING DArtefTechnology-Sci1-3a
12298: PPUSH
12299: CALL_OW 88
// end ; DialogueOff ;
12303: CALL_OW 7
// end ;
12307: PPOPN 1
12309: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12310: LD_EXP 12
12314: IFFALSE 12509
12316: GO 12318
12318: DISABLE
12319: LD_INT 0
12321: PPUSH
// begin if Denis then
12322: LD_EXP 23
12326: IFFALSE 12343
// speaker := [ Denis ] else
12328: LD_ADDR_VAR 0 1
12332: PUSH
12333: LD_EXP 23
12337: PUSH
12338: EMPTY
12339: LIST
12340: ST_TO_ADDR
12341: GO 12449
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12343: LD_ADDR_VAR 0 1
12347: PUSH
12348: LD_INT 22
12350: PUSH
12351: LD_INT 7
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: LD_INT 23
12360: PUSH
12361: LD_INT 1
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PUSH
12368: LD_INT 25
12370: PUSH
12371: LD_INT 4
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: PUSH
12378: LD_INT 21
12380: PUSH
12381: LD_INT 1
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: PUSH
12388: LD_INT 26
12390: PUSH
12391: LD_INT 1
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: LIST
12404: PPUSH
12405: CALL_OW 69
12409: PUSH
12410: LD_EXP 18
12414: PUSH
12415: LD_EXP 17
12419: PUSH
12420: LD_EXP 49
12424: PUSH
12425: LD_EXP 37
12429: PUSH
12430: LD_EXP 47
12434: PUSH
12435: LD_EXP 46
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: LIST
12444: LIST
12445: LIST
12446: LIST
12447: DIFF
12448: ST_TO_ADDR
// if not speaker then
12449: LD_VAR 0 1
12453: NOT
12454: IFFALSE 12458
// exit ;
12456: GO 12509
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12458: LD_VAR 0 1
12462: PUSH
12463: LD_INT 1
12465: ARRAY
12466: PPUSH
12467: LD_STRING DArtefTechnologyAm-Sci1-1
12469: PPUSH
12470: CALL_OW 88
// if IsOk ( Burlak ) then
12474: LD_EXP 49
12478: PPUSH
12479: CALL_OW 302
12483: IFFALSE 12497
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12485: LD_EXP 49
12489: PPUSH
12490: LD_STRING DArtefTechnologyAm-Bur-1
12492: PPUSH
12493: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12497: LD_EXP 17
12501: PPUSH
12502: LD_STRING DArtefTechnologyAm-JMM-1
12504: PPUSH
12505: CALL_OW 88
// end ;
12509: PPOPN 1
12511: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12512: LD_EXP 13
12516: IFFALSE 12706
12518: GO 12520
12520: DISABLE
12521: LD_INT 0
12523: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12524: LD_ADDR_VAR 0 1
12528: PUSH
12529: LD_INT 22
12531: PUSH
12532: LD_INT 7
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 23
12541: PUSH
12542: LD_INT 3
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 4
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 21
12561: PUSH
12562: LD_INT 1
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 26
12571: PUSH
12572: LD_INT 1
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: PPUSH
12586: CALL_OW 69
12590: PUSH
12591: LD_EXP 18
12595: PUSH
12596: LD_EXP 17
12600: PUSH
12601: LD_EXP 49
12605: PUSH
12606: LD_EXP 37
12610: PUSH
12611: LD_EXP 47
12615: PUSH
12616: LD_EXP 46
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: LIST
12625: LIST
12626: LIST
12627: LIST
12628: DIFF
12629: ST_TO_ADDR
// if not speaker then
12630: LD_VAR 0 1
12634: NOT
12635: IFFALSE 12639
// exit ;
12637: GO 12706
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12639: LD_VAR 0 1
12643: PUSH
12644: LD_INT 1
12646: ARRAY
12647: PPUSH
12648: LD_STRING DArtefTechnologyRu-RSci1-1
12650: PPUSH
12651: CALL_OW 88
// if IsOk ( Burlak ) then
12655: LD_EXP 49
12659: PPUSH
12660: CALL_OW 302
12664: IFFALSE 12678
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12666: LD_EXP 49
12670: PPUSH
12671: LD_STRING DArtefTechnologyRu-Bur-1
12673: PPUSH
12674: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12678: LD_VAR 0 1
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_STRING DArtefTechnologyRu-RSci1-2
12689: PPUSH
12690: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12694: LD_EXP 17
12698: PPUSH
12699: LD_STRING DArtefTechnologyRu-JMM-1
12701: PPUSH
12702: CALL_OW 88
// end ;
12706: PPOPN 1
12708: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12709: LD_INT 24
12711: PPUSH
12712: LD_INT 7
12714: PPUSH
12715: CALL_OW 321
12719: PUSH
12720: LD_INT 2
12722: EQUAL
12723: PUSH
12724: LD_INT 1
12726: PPUSH
12727: CALL_OW 255
12731: PUSH
12732: LD_INT 7
12734: EQUAL
12735: AND
12736: IFFALSE 12896
12738: GO 12740
12740: DISABLE
12741: LD_INT 0
12743: PPUSH
// begin if Denis then
12744: LD_EXP 23
12748: IFFALSE 12765
// speaker := [ Denis ] else
12750: LD_ADDR_VAR 0 1
12754: PUSH
12755: LD_EXP 23
12759: PUSH
12760: EMPTY
12761: LIST
12762: ST_TO_ADDR
12763: GO 12871
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12765: LD_ADDR_VAR 0 1
12769: PUSH
12770: LD_INT 22
12772: PUSH
12773: LD_INT 7
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: LD_INT 23
12782: PUSH
12783: LD_INT 1
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 25
12792: PUSH
12793: LD_INT 4
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 21
12802: PUSH
12803: LD_INT 1
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 26
12812: PUSH
12813: LD_INT 1
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: PPUSH
12827: CALL_OW 69
12831: PUSH
12832: LD_EXP 18
12836: PUSH
12837: LD_EXP 17
12841: PUSH
12842: LD_EXP 49
12846: PUSH
12847: LD_EXP 37
12851: PUSH
12852: LD_EXP 47
12856: PUSH
12857: LD_EXP 46
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: LIST
12866: LIST
12867: LIST
12868: LIST
12869: DIFF
12870: ST_TO_ADDR
// if not speaker then
12871: LD_VAR 0 1
12875: NOT
12876: IFFALSE 12880
// exit ;
12878: GO 12896
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12880: LD_VAR 0 1
12884: PUSH
12885: LD_INT 1
12887: ARRAY
12888: PPUSH
12889: LD_STRING DArtefTechnologyArStart-Sci1-1
12891: PPUSH
12892: CALL_OW 88
// end ;
12896: PPOPN 1
12898: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12899: LD_EXP 14
12903: IFFALSE 13184
12905: GO 12907
12907: DISABLE
12908: LD_INT 0
12910: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12911: LD_ADDR_VAR 0 1
12915: PUSH
12916: LD_INT 22
12918: PUSH
12919: LD_INT 7
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 23
12928: PUSH
12929: LD_INT 3
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: PUSH
12936: LD_INT 25
12938: PUSH
12939: LD_INT 4
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 21
12948: PUSH
12949: LD_INT 1
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: LD_INT 26
12958: PUSH
12959: LD_INT 1
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: PPUSH
12973: CALL_OW 69
12977: PUSH
12978: LD_EXP 18
12982: PUSH
12983: LD_EXP 17
12987: PUSH
12988: LD_EXP 49
12992: PUSH
12993: LD_EXP 37
12997: PUSH
12998: LD_EXP 47
13002: PUSH
13003: LD_EXP 46
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: DIFF
13016: ST_TO_ADDR
// if not speaker then
13017: LD_VAR 0 1
13021: NOT
13022: IFFALSE 13026
// exit ;
13024: GO 13184
// DialogueOn ;
13026: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13030: LD_VAR 0 1
13034: PUSH
13035: LD_INT 1
13037: ARRAY
13038: PPUSH
13039: LD_STRING DArtefTechnologyAr-RSci1-1
13041: PPUSH
13042: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13046: LD_EXP 17
13050: PPUSH
13051: LD_STRING DArtefTechnologyAr-JMM-1
13053: PPUSH
13054: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13058: LD_VAR 0 1
13062: PUSH
13063: LD_INT 1
13065: ARRAY
13066: PPUSH
13067: LD_STRING DArtefTechnologyAr-RSci1-2
13069: PPUSH
13070: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13074: LD_EXP 17
13078: PPUSH
13079: LD_STRING DArtefTechnologyAr-JMM-2
13081: PPUSH
13082: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13086: LD_VAR 0 1
13090: PUSH
13091: LD_INT 1
13093: ARRAY
13094: PPUSH
13095: LD_STRING DArtefTechnologyAr-RSci1-3
13097: PPUSH
13098: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13102: LD_EXP 17
13106: PPUSH
13107: LD_STRING DArtefTechnologyAr-JMM-3
13109: PPUSH
13110: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13114: LD_VAR 0 1
13118: PUSH
13119: LD_INT 1
13121: ARRAY
13122: PPUSH
13123: LD_STRING DArtefTechnologyAr-RSci1-4
13125: PPUSH
13126: CALL_OW 88
// if IsOk ( Burlak ) then
13130: LD_EXP 49
13134: PPUSH
13135: CALL_OW 302
13139: IFFALSE 13153
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13141: LD_EXP 49
13145: PPUSH
13146: LD_STRING DArtefTechnologyAr-Bur-4
13148: PPUSH
13149: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13153: LD_EXP 17
13157: PPUSH
13158: LD_STRING DArtefTechnologyAr-JMM-4
13160: PPUSH
13161: CALL_OW 88
// DialogueOff ;
13165: CALL_OW 7
// wait ( 0 0$45 ) ;
13169: LD_INT 1575
13171: PPUSH
13172: CALL_OW 67
// spawnOmar := true ;
13176: LD_ADDR_EXP 11
13180: PUSH
13181: LD_INT 1
13183: ST_TO_ADDR
// end ;
13184: PPOPN 1
13186: END
// every 0 0$1 trigger spawnOmar do
13187: LD_EXP 11
13191: IFFALSE 13571
13193: GO 13195
13195: DISABLE
// begin PrepareOmarAli ;
13196: CALL 6705 0 0
// if not HasTask ( Omar ) then
13200: LD_EXP 53
13204: PPUSH
13205: CALL_OW 314
13209: NOT
13210: IFFALSE 13227
// ComMoveXY ( Omar , 252 , 220 ) ;
13212: LD_EXP 53
13216: PPUSH
13217: LD_INT 252
13219: PPUSH
13220: LD_INT 220
13222: PPUSH
13223: CALL_OW 111
// if not Omar then
13227: LD_EXP 53
13231: NOT
13232: IFFALSE 13236
// exit ;
13234: GO 13571
// repeat wait ( 0 0$1 ) ;
13236: LD_INT 35
13238: PPUSH
13239: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13243: LD_EXP 53
13247: PPUSH
13248: CALL_OW 314
13252: NOT
13253: PUSH
13254: LD_EXP 53
13258: PPUSH
13259: LD_INT 252
13261: PPUSH
13262: LD_INT 220
13264: PPUSH
13265: CALL_OW 297
13269: PUSH
13270: LD_INT 6
13272: GREATER
13273: AND
13274: IFFALSE 13291
// ComMoveXY ( Omar , 252 , 220 ) ;
13276: LD_EXP 53
13280: PPUSH
13281: LD_INT 252
13283: PPUSH
13284: LD_INT 220
13286: PPUSH
13287: CALL_OW 111
// until See ( 7 , Omar ) ;
13291: LD_INT 7
13293: PPUSH
13294: LD_EXP 53
13298: PPUSH
13299: CALL_OW 292
13303: IFFALSE 13236
// CenterNowOnUnits ( Omar ) ;
13305: LD_EXP 53
13309: PPUSH
13310: CALL_OW 87
// DialogueOn ;
13314: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13318: LD_EXP 53
13322: PPUSH
13323: LD_STRING DOmar-Omar-1
13325: PPUSH
13326: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13330: LD_EXP 17
13334: PPUSH
13335: LD_STRING DOmar-JMM-1
13337: PPUSH
13338: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13342: LD_EXP 53
13346: PPUSH
13347: LD_STRING DOmar-Omar-2
13349: PPUSH
13350: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13354: LD_EXP 17
13358: PPUSH
13359: LD_STRING DOmar-JMM-2
13361: PPUSH
13362: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13366: LD_EXP 53
13370: PPUSH
13371: LD_STRING DOmar-Omar-3
13373: PPUSH
13374: CALL_OW 88
// if IsOk ( Burlak ) then
13378: LD_EXP 49
13382: PPUSH
13383: CALL_OW 302
13387: IFFALSE 13403
// Say ( Burlak , DOmar-Bur-3 ) else
13389: LD_EXP 49
13393: PPUSH
13394: LD_STRING DOmar-Bur-3
13396: PPUSH
13397: CALL_OW 88
13401: GO 13415
// Say ( JMM , DOmar-JMM-3 ) ;
13403: LD_EXP 17
13407: PPUSH
13408: LD_STRING DOmar-JMM-3
13410: PPUSH
13411: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13415: LD_EXP 53
13419: PPUSH
13420: LD_STRING DOmar-Omar-4
13422: PPUSH
13423: CALL_OW 88
// case Query ( QAccept ) of 1 :
13427: LD_STRING QAccept
13429: PPUSH
13430: CALL_OW 97
13434: PUSH
13435: LD_INT 1
13437: DOUBLE
13438: EQUAL
13439: IFTRUE 13443
13441: GO 13479
13443: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13444: LD_EXP 17
13448: PPUSH
13449: LD_STRING DQrAccept#1-JMM-1
13451: PPUSH
13452: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13456: LD_EXP 53
13460: PPUSH
13461: LD_INT 7
13463: PPUSH
13464: CALL_OW 235
// ComStop ( Omar ) ;
13468: LD_EXP 53
13472: PPUSH
13473: CALL_OW 141
// end ; 2 :
13477: GO 13528
13479: LD_INT 2
13481: DOUBLE
13482: EQUAL
13483: IFTRUE 13487
13485: GO 13527
13487: POP
// begin if IsOk ( Burlak ) then
13488: LD_EXP 49
13492: PPUSH
13493: CALL_OW 302
13497: IFFALSE 13513
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13499: LD_EXP 49
13503: PPUSH
13504: LD_STRING DQrAccept#2-Bur-1
13506: PPUSH
13507: CALL_OW 88
13511: GO 13525
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13513: LD_EXP 17
13517: PPUSH
13518: LD_STRING DQrAccept#2-JMM-1
13520: PPUSH
13521: CALL_OW 88
// end ; end ;
13525: GO 13528
13527: POP
// DialogueOff ;
13528: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13532: LD_EXP 53
13536: PPUSH
13537: CALL_OW 255
13541: PUSH
13542: LD_INT 7
13544: EQUAL
13545: IFFALSE 13556
// begin SetAchievement ( ACH_OMAR ) ;
13547: LD_STRING ACH_OMAR
13549: PPUSH
13550: CALL_OW 543
// exit ;
13554: GO 13571
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13556: LD_EXP 53
13560: PPUSH
13561: LD_INT 202
13563: PPUSH
13564: LD_INT 115
13566: PPUSH
13567: CALL_OW 111
// end ;
13571: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13572: LD_EXP 53
13576: PPUSH
13577: LD_INT 200
13579: PPUSH
13580: LD_INT 98
13582: PPUSH
13583: CALL_OW 297
13587: PUSH
13588: LD_INT 40
13590: LESS
13591: PUSH
13592: LD_EXP 2
13596: AND
13597: IFFALSE 13815
13599: GO 13601
13601: DISABLE
// begin SetSide ( Omar , 5 ) ;
13602: LD_EXP 53
13606: PPUSH
13607: LD_INT 5
13609: PPUSH
13610: CALL_OW 235
// if IsInUnit ( Omar ) then
13614: LD_EXP 53
13618: PPUSH
13619: CALL_OW 310
13623: IFFALSE 13634
// ComExitVehicle ( Omar ) ;
13625: LD_EXP 53
13629: PPUSH
13630: CALL_OW 121
// if IsInUnit ( Omar ) then
13634: LD_EXP 53
13638: PPUSH
13639: CALL_OW 310
13643: IFFALSE 13654
// ComExitBuilding ( Omar ) ;
13645: LD_EXP 53
13649: PPUSH
13650: CALL_OW 122
// wait ( 0 0$1 ) ;
13654: LD_INT 35
13656: PPUSH
13657: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13661: LD_EXP 53
13665: PPUSH
13666: LD_INT 203
13668: PPUSH
13669: LD_INT 120
13671: PPUSH
13672: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13676: LD_INT 35
13678: PPUSH
13679: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13683: LD_EXP 53
13687: PPUSH
13688: CALL_OW 306
13692: PUSH
13693: LD_EXP 53
13697: PPUSH
13698: LD_INT 203
13700: PPUSH
13701: LD_INT 120
13703: PPUSH
13704: CALL_OW 297
13708: PUSH
13709: LD_INT 6
13711: LESS
13712: OR
13713: IFFALSE 13676
// CenterNowOnUnits ( Omar ) ;
13715: LD_EXP 53
13719: PPUSH
13720: CALL_OW 87
// DialogueOn ;
13724: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13728: LD_EXP 17
13732: PPUSH
13733: LD_STRING DOmarContam-JMM-1
13735: PPUSH
13736: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13740: LD_EXP 53
13744: PPUSH
13745: LD_STRING DOmarContam-Omar-1
13747: PPUSH
13748: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13752: LD_EXP 17
13756: PPUSH
13757: LD_STRING DOmarContam-JMM-2
13759: PPUSH
13760: CALL_OW 88
// DialogueOff ;
13764: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13768: LD_INT 5
13770: PPUSH
13771: LD_INT 7
13773: PPUSH
13774: LD_INT 2
13776: PPUSH
13777: LD_INT 1
13779: PPUSH
13780: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13784: LD_INT 105
13786: PPUSH
13787: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13791: LD_EXP 53
13795: PPUSH
13796: LD_INT 203
13798: PPUSH
13799: LD_INT 120
13801: PPUSH
13802: CALL_OW 307
13806: IFFALSE 13784
// YouLost ( MothContaminate ) ;
13808: LD_STRING MothContaminate
13810: PPUSH
13811: CALL_OW 104
// end ;
13815: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13816: LD_EXP 4
13820: NOT
13821: PUSH
13822: LD_INT 22
13824: PUSH
13825: LD_INT 1
13827: PUSH
13828: EMPTY
13829: LIST
13830: LIST
13831: PUSH
13832: LD_INT 34
13834: PUSH
13835: LD_INT 8
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: PPUSH
13846: CALL_OW 69
13850: AND
13851: IFFALSE 13932
13853: GO 13855
13855: DISABLE
// begin if not IsOk ( Powell ) then
13856: LD_EXP 52
13860: PPUSH
13861: CALL_OW 302
13865: NOT
13866: IFFALSE 13870
// exit ;
13868: GO 13932
// DialogueOn ;
13870: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13874: LD_EXP 52
13878: PPUSH
13879: LD_STRING DWinAmericans-Pow-1
13881: PPUSH
13882: CALL_OW 94
// if IsOk ( Burlak ) then
13886: LD_EXP 49
13890: PPUSH
13891: CALL_OW 302
13895: IFFALSE 13909
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13897: LD_EXP 49
13901: PPUSH
13902: LD_STRING DWinAmericans-Bur-1
13904: PPUSH
13905: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13909: LD_EXP 17
13913: PPUSH
13914: LD_STRING DWinAmericans-JMM-1
13916: PPUSH
13917: CALL_OW 88
// DialogueOff ;
13921: CALL_OW 7
// YouLost ( AmBomb ) ;
13925: LD_STRING AmBomb
13927: PPUSH
13928: CALL_OW 104
// end ;
13932: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13933: LD_EXP 2
13937: NOT
13938: PUSH
13939: LD_INT 22
13941: PUSH
13942: LD_INT 3
13944: PUSH
13945: EMPTY
13946: LIST
13947: LIST
13948: PUSH
13949: LD_INT 34
13951: PUSH
13952: LD_INT 48
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: EMPTY
13960: LIST
13961: LIST
13962: PPUSH
13963: CALL_OW 69
13967: AND
13968: IFFALSE 14049
13970: GO 13972
13972: DISABLE
// begin if not IsOk ( Platonov ) then
13973: LD_EXP 56
13977: PPUSH
13978: CALL_OW 302
13982: NOT
13983: IFFALSE 13987
// exit ;
13985: GO 14049
// DialogueOn ;
13987: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13991: LD_EXP 56
13995: PPUSH
13996: LD_STRING DWinRussians-Pla-1
13998: PPUSH
13999: CALL_OW 94
// if IsOk ( Burlak ) then
14003: LD_EXP 49
14007: PPUSH
14008: CALL_OW 302
14012: IFFALSE 14026
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14014: LD_EXP 49
14018: PPUSH
14019: LD_STRING DWinRussians-Bur-1
14021: PPUSH
14022: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14026: LD_EXP 17
14030: PPUSH
14031: LD_STRING DWinRussians-JMM-1
14033: PPUSH
14034: CALL_OW 88
// DialogueOff ;
14038: CALL_OW 7
// YouLost ( RuBomb ) ;
14042: LD_STRING RuBomb
14044: PPUSH
14045: CALL_OW 104
// end ;
14049: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14050: LD_INT 7
14052: PPUSH
14053: LD_INT 22
14055: PUSH
14056: LD_INT 7
14058: PUSH
14059: EMPTY
14060: LIST
14061: LIST
14062: PPUSH
14063: CALL_OW 70
14067: PUSH
14068: LD_EXP 4
14072: NOT
14073: AND
14074: IFFALSE 14103
14076: GO 14078
14078: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14079: LD_EXP 52
14083: PPUSH
14084: LD_STRING DSurrenderAmericans-Pow-1
14086: PPUSH
14087: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14091: LD_EXP 17
14095: PPUSH
14096: LD_STRING DSurrenderAmericans-JMM-1
14098: PPUSH
14099: CALL_OW 88
// end ;
14103: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14104: LD_INT 2
14106: PPUSH
14107: LD_INT 22
14109: PUSH
14110: LD_INT 7
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: PPUSH
14117: CALL_OW 70
14121: PUSH
14122: LD_EXP 2
14126: NOT
14127: AND
14128: PUSH
14129: LD_EXP 49
14133: AND
14134: IFFALSE 14163
14136: GO 14138
14138: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14139: LD_EXP 56
14143: PPUSH
14144: LD_STRING DSurrenderRussians-Pla-1
14146: PPUSH
14147: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14151: LD_EXP 49
14155: PPUSH
14156: LD_STRING DSurrenderRussians-Bur-1
14158: PPUSH
14159: CALL_OW 88
// end ;
14163: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14164: LD_EXP 4
14168: IFFALSE 14551
14170: GO 14172
14172: DISABLE
14173: LD_INT 0
14175: PPUSH
14176: PPUSH
14177: PPUSH
// begin MC_Kill ( 4 ) ;
14178: LD_INT 4
14180: PPUSH
14181: CALL 20875 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14185: LD_INT 1
14187: PPUSH
14188: LD_INT 7
14190: PPUSH
14191: LD_INT 1
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14201: LD_ADDR_VAR 0 3
14205: PUSH
14206: LD_INT 22
14208: PUSH
14209: LD_INT 1
14211: PUSH
14212: EMPTY
14213: LIST
14214: LIST
14215: PUSH
14216: LD_INT 26
14218: PUSH
14219: LD_INT 1
14221: PUSH
14222: EMPTY
14223: LIST
14224: LIST
14225: PUSH
14226: LD_INT 23
14228: PUSH
14229: LD_INT 1
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PUSH
14236: EMPTY
14237: LIST
14238: LIST
14239: LIST
14240: PPUSH
14241: CALL_OW 69
14245: PUSH
14246: LD_EXP 52
14250: PUSH
14251: LD_EXP 25
14255: PUSH
14256: LD_EXP 22
14260: PUSH
14261: LD_EXP 21
14265: PUSH
14266: LD_EXP 28
14270: PUSH
14271: LD_EXP 26
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: LIST
14280: LIST
14281: LIST
14282: LIST
14283: DIFF
14284: ST_TO_ADDR
// if speaker then
14285: LD_VAR 0 3
14289: IFFALSE 14315
// begin DialogueOn ;
14291: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14295: LD_VAR 0 3
14299: PUSH
14300: LD_INT 1
14302: ARRAY
14303: PPUSH
14304: LD_STRING DSurrenderAmericans-Sol1-1a
14306: PPUSH
14307: CALL_OW 94
// DialogueOff ;
14311: CALL_OW 7
// end ; americanCapitulated := true ;
14315: LD_ADDR_EXP 6
14319: PUSH
14320: LD_INT 1
14322: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14323: LD_ADDR_VAR 0 2
14327: PUSH
14328: LD_INT 22
14330: PUSH
14331: LD_INT 1
14333: PUSH
14334: EMPTY
14335: LIST
14336: LIST
14337: PUSH
14338: LD_INT 21
14340: PUSH
14341: LD_INT 1
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: PPUSH
14352: CALL_OW 69
14356: PUSH
14357: LD_INT 22
14359: PUSH
14360: LD_INT 1
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: PUSH
14367: LD_INT 21
14369: PUSH
14370: LD_INT 2
14372: PUSH
14373: EMPTY
14374: LIST
14375: LIST
14376: PUSH
14377: LD_INT 1
14379: PUSH
14380: EMPTY
14381: LIST
14382: PUSH
14383: EMPTY
14384: LIST
14385: LIST
14386: LIST
14387: PPUSH
14388: CALL_OW 69
14392: ADD
14393: ST_TO_ADDR
// if tmp then
14394: LD_VAR 0 2
14398: IFFALSE 14551
// repeat wait ( 0 0$1 ) ;
14400: LD_INT 35
14402: PPUSH
14403: CALL_OW 67
// for i in tmp do
14407: LD_ADDR_VAR 0 1
14411: PUSH
14412: LD_VAR 0 2
14416: PUSH
14417: FOR_IN
14418: IFFALSE 14500
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14420: LD_VAR 0 1
14424: PPUSH
14425: CALL_OW 310
14429: PUSH
14430: LD_VAR 0 1
14434: PPUSH
14435: CALL_OW 310
14439: PPUSH
14440: CALL_OW 247
14444: PUSH
14445: LD_INT 3
14447: EQUAL
14448: AND
14449: IFFALSE 14460
// ComExitBuilding ( i ) ;
14451: LD_VAR 0 1
14455: PPUSH
14456: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14460: LD_VAR 0 1
14464: PPUSH
14465: LD_INT 122
14467: PPUSH
14468: LD_INT 242
14470: PPUSH
14471: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14475: LD_VAR 0 1
14479: PPUSH
14480: LD_INT 35
14482: PPUSH
14483: CALL_OW 308
14487: IFFALSE 14498
// RemoveUnit ( i ) ;
14489: LD_VAR 0 1
14493: PPUSH
14494: CALL_OW 64
// end ;
14498: GO 14417
14500: POP
14501: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14502: LD_INT 22
14504: PUSH
14505: LD_INT 1
14507: PUSH
14508: EMPTY
14509: LIST
14510: LIST
14511: PUSH
14512: LD_INT 2
14514: PUSH
14515: LD_INT 21
14517: PUSH
14518: LD_INT 1
14520: PUSH
14521: EMPTY
14522: LIST
14523: LIST
14524: PUSH
14525: LD_INT 33
14527: PUSH
14528: LD_INT 1
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: PUSH
14535: EMPTY
14536: LIST
14537: LIST
14538: LIST
14539: PUSH
14540: EMPTY
14541: LIST
14542: LIST
14543: PPUSH
14544: CALL_OW 69
14548: NOT
14549: IFFALSE 14400
// end ;
14551: PPOPN 3
14553: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14554: LD_EXP 2
14558: IFFALSE 14959
14560: GO 14562
14562: DISABLE
14563: LD_INT 0
14565: PPUSH
14566: PPUSH
14567: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14568: LD_INT 35
14570: PPUSH
14571: CALL_OW 67
// until IsDead ( Yakotich ) ;
14575: LD_EXP 57
14579: PPUSH
14580: CALL_OW 301
14584: IFFALSE 14568
// MC_Kill ( 2 ) ;
14586: LD_INT 2
14588: PPUSH
14589: CALL 20875 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14593: LD_INT 3
14595: PPUSH
14596: LD_INT 7
14598: PPUSH
14599: LD_INT 1
14601: PPUSH
14602: LD_INT 1
14604: PPUSH
14605: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14609: LD_ADDR_VAR 0 3
14613: PUSH
14614: LD_INT 22
14616: PUSH
14617: LD_INT 3
14619: PUSH
14620: EMPTY
14621: LIST
14622: LIST
14623: PUSH
14624: LD_INT 26
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 23
14636: PUSH
14637: LD_INT 3
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: PUSH
14644: EMPTY
14645: LIST
14646: LIST
14647: LIST
14648: PPUSH
14649: CALL_OW 69
14653: PUSH
14654: LD_EXP 56
14658: PUSH
14659: LD_EXP 57
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: DIFF
14668: ST_TO_ADDR
// if speaker then
14669: LD_VAR 0 3
14673: IFFALSE 14723
// begin DialogueOn ;
14675: CALL_OW 6
// if Burlak then
14679: LD_EXP 49
14683: IFFALSE 14703
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14685: LD_VAR 0 3
14689: PUSH
14690: LD_INT 1
14692: ARRAY
14693: PPUSH
14694: LD_STRING DSurrenderRussians-RSol1-1
14696: PPUSH
14697: CALL_OW 94
14701: GO 14719
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14703: LD_VAR 0 3
14707: PUSH
14708: LD_INT 1
14710: ARRAY
14711: PPUSH
14712: LD_STRING DSurrenderRussians-RSol1-1a
14714: PPUSH
14715: CALL_OW 94
// DialogueOff ;
14719: CALL_OW 7
// end ; russianCapitulated := true ;
14723: LD_ADDR_EXP 7
14727: PUSH
14728: LD_INT 1
14730: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14731: LD_ADDR_VAR 0 2
14735: PUSH
14736: LD_INT 22
14738: PUSH
14739: LD_INT 3
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 21
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: EMPTY
14757: LIST
14758: LIST
14759: PPUSH
14760: CALL_OW 69
14764: PUSH
14765: LD_INT 22
14767: PUSH
14768: LD_INT 3
14770: PUSH
14771: EMPTY
14772: LIST
14773: LIST
14774: PUSH
14775: LD_INT 21
14777: PUSH
14778: LD_INT 2
14780: PUSH
14781: EMPTY
14782: LIST
14783: LIST
14784: PUSH
14785: LD_INT 1
14787: PUSH
14788: EMPTY
14789: LIST
14790: PUSH
14791: EMPTY
14792: LIST
14793: LIST
14794: LIST
14795: PPUSH
14796: CALL_OW 69
14800: ADD
14801: ST_TO_ADDR
// if tmp then
14802: LD_VAR 0 2
14806: IFFALSE 14959
// repeat wait ( 0 0$1 ) ;
14808: LD_INT 35
14810: PPUSH
14811: CALL_OW 67
// for i in tmp do
14815: LD_ADDR_VAR 0 1
14819: PUSH
14820: LD_VAR 0 2
14824: PUSH
14825: FOR_IN
14826: IFFALSE 14908
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14828: LD_VAR 0 1
14832: PPUSH
14833: CALL_OW 310
14837: PUSH
14838: LD_VAR 0 1
14842: PPUSH
14843: CALL_OW 310
14847: PPUSH
14848: CALL_OW 247
14852: PUSH
14853: LD_INT 3
14855: EQUAL
14856: AND
14857: IFFALSE 14868
// ComExitBuilding ( i ) ;
14859: LD_VAR 0 1
14863: PPUSH
14864: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14868: LD_VAR 0 1
14872: PPUSH
14873: LD_INT 154
14875: PPUSH
14876: LD_INT 1
14878: PPUSH
14879: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14883: LD_VAR 0 1
14887: PPUSH
14888: LD_INT 36
14890: PPUSH
14891: CALL_OW 308
14895: IFFALSE 14906
// RemoveUnit ( i ) ;
14897: LD_VAR 0 1
14901: PPUSH
14902: CALL_OW 64
// end ;
14906: GO 14825
14908: POP
14909: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14910: LD_INT 22
14912: PUSH
14913: LD_INT 3
14915: PUSH
14916: EMPTY
14917: LIST
14918: LIST
14919: PUSH
14920: LD_INT 2
14922: PUSH
14923: LD_INT 21
14925: PUSH
14926: LD_INT 1
14928: PUSH
14929: EMPTY
14930: LIST
14931: LIST
14932: PUSH
14933: LD_INT 33
14935: PUSH
14936: LD_INT 1
14938: PUSH
14939: EMPTY
14940: LIST
14941: LIST
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: LIST
14947: PUSH
14948: EMPTY
14949: LIST
14950: LIST
14951: PPUSH
14952: CALL_OW 69
14956: NOT
14957: IFFALSE 14808
// end ;
14959: PPOPN 3
14961: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14962: LD_INT 22
14964: PUSH
14965: LD_INT 8
14967: PUSH
14968: EMPTY
14969: LIST
14970: LIST
14971: PUSH
14972: LD_INT 21
14974: PUSH
14975: LD_INT 1
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: PUSH
14982: LD_INT 23
14984: PUSH
14985: LD_INT 2
14987: PUSH
14988: EMPTY
14989: LIST
14990: LIST
14991: PUSH
14992: EMPTY
14993: LIST
14994: LIST
14995: LIST
14996: PPUSH
14997: CALL_OW 69
15001: PUSH
15002: LD_INT 18
15004: LESS
15005: PUSH
15006: LD_EXP 55
15010: PPUSH
15011: CALL_OW 301
15015: OR
15016: PUSH
15017: LD_INT 324
15019: PPUSH
15020: CALL_OW 255
15024: PUSH
15025: LD_INT 7
15027: EQUAL
15028: OR
15029: IFFALSE 15042
15031: GO 15033
15033: DISABLE
// legionDestroyed := true ;
15034: LD_ADDR_EXP 3
15038: PUSH
15039: LD_INT 1
15041: ST_TO_ADDR
15042: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15043: LD_INT 22
15045: PUSH
15046: LD_INT 2
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: PUSH
15053: LD_INT 21
15055: PUSH
15056: LD_INT 1
15058: PUSH
15059: EMPTY
15060: LIST
15061: LIST
15062: PUSH
15063: LD_INT 23
15065: PUSH
15066: LD_INT 2
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: LIST
15077: PPUSH
15078: CALL_OW 69
15082: PUSH
15083: LD_INT 9
15085: LESS
15086: IFFALSE 15099
15088: GO 15090
15090: DISABLE
// arabianDestroyed := true ;
15091: LD_ADDR_EXP 5
15095: PUSH
15096: LD_INT 1
15098: ST_TO_ADDR
15099: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15100: LD_EXP 5
15104: IFFALSE 15348
15106: GO 15108
15108: DISABLE
15109: LD_INT 0
15111: PPUSH
15112: PPUSH
// begin MC_Kill ( 1 ) ;
15113: LD_INT 1
15115: PPUSH
15116: CALL 20875 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15120: LD_ADDR_VAR 0 2
15124: PUSH
15125: LD_INT 22
15127: PUSH
15128: LD_INT 2
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: LD_INT 21
15137: PUSH
15138: LD_INT 1
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PPUSH
15149: CALL_OW 69
15153: PUSH
15154: LD_INT 22
15156: PUSH
15157: LD_INT 8
15159: PUSH
15160: EMPTY
15161: LIST
15162: LIST
15163: PUSH
15164: LD_INT 21
15166: PUSH
15167: LD_INT 2
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: PUSH
15174: LD_INT 1
15176: PUSH
15177: EMPTY
15178: LIST
15179: PUSH
15180: EMPTY
15181: LIST
15182: LIST
15183: LIST
15184: PPUSH
15185: CALL_OW 69
15189: ADD
15190: ST_TO_ADDR
// if tmp then
15191: LD_VAR 0 2
15195: IFFALSE 15348
// repeat wait ( 0 0$1 ) ;
15197: LD_INT 35
15199: PPUSH
15200: CALL_OW 67
// for i in tmp do
15204: LD_ADDR_VAR 0 1
15208: PUSH
15209: LD_VAR 0 2
15213: PUSH
15214: FOR_IN
15215: IFFALSE 15297
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15217: LD_VAR 0 1
15221: PPUSH
15222: CALL_OW 310
15226: PUSH
15227: LD_VAR 0 1
15231: PPUSH
15232: CALL_OW 310
15236: PPUSH
15237: CALL_OW 247
15241: PUSH
15242: LD_INT 3
15244: EQUAL
15245: AND
15246: IFFALSE 15257
// ComExitBuilding ( i ) ;
15248: LD_VAR 0 1
15252: PPUSH
15253: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15257: LD_VAR 0 1
15261: PPUSH
15262: LD_INT 254
15264: PPUSH
15265: LD_INT 268
15267: PPUSH
15268: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15272: LD_VAR 0 1
15276: PPUSH
15277: LD_INT 34
15279: PPUSH
15280: CALL_OW 308
15284: IFFALSE 15295
// RemoveUnit ( i ) ;
15286: LD_VAR 0 1
15290: PPUSH
15291: CALL_OW 64
// end ;
15295: GO 15214
15297: POP
15298: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15299: LD_INT 22
15301: PUSH
15302: LD_INT 2
15304: PUSH
15305: EMPTY
15306: LIST
15307: LIST
15308: PUSH
15309: LD_INT 2
15311: PUSH
15312: LD_INT 21
15314: PUSH
15315: LD_INT 1
15317: PUSH
15318: EMPTY
15319: LIST
15320: LIST
15321: PUSH
15322: LD_INT 33
15324: PUSH
15325: LD_INT 1
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: LIST
15336: PUSH
15337: EMPTY
15338: LIST
15339: LIST
15340: PPUSH
15341: CALL_OW 69
15345: NOT
15346: IFFALSE 15197
// end ;
15348: PPOPN 2
15350: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15351: LD_EXP 3
15355: IFFALSE 15707
15357: GO 15359
15359: DISABLE
15360: LD_INT 0
15362: PPUSH
15363: PPUSH
// begin MC_Kill ( 3 ) ;
15364: LD_INT 3
15366: PPUSH
15367: CALL 20875 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15371: LD_INT 8
15373: PPUSH
15374: LD_INT 7
15376: PPUSH
15377: LD_INT 1
15379: PPUSH
15380: LD_INT 1
15382: PPUSH
15383: CALL_OW 80
// DialogueOn ;
15387: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15391: LD_EXP 54
15395: PPUSH
15396: LD_STRING D15-Szulc-1
15398: PPUSH
15399: CALL_OW 94
// DialogueOff ;
15403: CALL_OW 7
// legionCapitulated := true ;
15407: LD_ADDR_EXP 8
15411: PUSH
15412: LD_INT 1
15414: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15415: LD_ADDR_VAR 0 1
15419: PUSH
15420: LD_INT 22
15422: PUSH
15423: LD_INT 8
15425: PUSH
15426: EMPTY
15427: LIST
15428: LIST
15429: PUSH
15430: LD_INT 21
15432: PUSH
15433: LD_INT 3
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: PUSH
15440: LD_INT 23
15442: PUSH
15443: LD_INT 3
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: LIST
15454: PPUSH
15455: CALL_OW 69
15459: PUSH
15460: FOR_IN
15461: IFFALSE 15477
// SetLives ( i , 3 ) ;
15463: LD_VAR 0 1
15467: PPUSH
15468: LD_INT 3
15470: PPUSH
15471: CALL_OW 234
15475: GO 15460
15477: POP
15478: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15479: LD_ADDR_VAR 0 2
15483: PUSH
15484: LD_INT 22
15486: PUSH
15487: LD_INT 8
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: PUSH
15494: LD_INT 21
15496: PUSH
15497: LD_INT 1
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: PPUSH
15508: CALL_OW 69
15512: PUSH
15513: LD_INT 22
15515: PUSH
15516: LD_INT 8
15518: PUSH
15519: EMPTY
15520: LIST
15521: LIST
15522: PUSH
15523: LD_INT 21
15525: PUSH
15526: LD_INT 2
15528: PUSH
15529: EMPTY
15530: LIST
15531: LIST
15532: PUSH
15533: LD_INT 1
15535: PUSH
15536: EMPTY
15537: LIST
15538: PUSH
15539: EMPTY
15540: LIST
15541: LIST
15542: LIST
15543: PPUSH
15544: CALL_OW 69
15548: ADD
15549: ST_TO_ADDR
// if tmp then
15550: LD_VAR 0 2
15554: IFFALSE 15707
// repeat wait ( 0 0$1 ) ;
15556: LD_INT 35
15558: PPUSH
15559: CALL_OW 67
// for i in tmp do
15563: LD_ADDR_VAR 0 1
15567: PUSH
15568: LD_VAR 0 2
15572: PUSH
15573: FOR_IN
15574: IFFALSE 15656
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15576: LD_VAR 0 1
15580: PPUSH
15581: CALL_OW 310
15585: PUSH
15586: LD_VAR 0 1
15590: PPUSH
15591: CALL_OW 310
15595: PPUSH
15596: CALL_OW 247
15600: PUSH
15601: LD_INT 3
15603: EQUAL
15604: AND
15605: IFFALSE 15616
// ComExitBuilding ( i ) ;
15607: LD_VAR 0 1
15611: PPUSH
15612: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15616: LD_VAR 0 1
15620: PPUSH
15621: LD_INT 10
15623: PPUSH
15624: LD_INT 1
15626: PPUSH
15627: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15631: LD_VAR 0 1
15635: PPUSH
15636: LD_INT 32
15638: PPUSH
15639: CALL_OW 308
15643: IFFALSE 15654
// RemoveUnit ( i ) ;
15645: LD_VAR 0 1
15649: PPUSH
15650: CALL_OW 64
// end ;
15654: GO 15573
15656: POP
15657: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15658: LD_INT 22
15660: PUSH
15661: LD_INT 8
15663: PUSH
15664: EMPTY
15665: LIST
15666: LIST
15667: PUSH
15668: LD_INT 2
15670: PUSH
15671: LD_INT 21
15673: PUSH
15674: LD_INT 1
15676: PUSH
15677: EMPTY
15678: LIST
15679: LIST
15680: PUSH
15681: LD_INT 33
15683: PUSH
15684: LD_INT 1
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: PUSH
15691: EMPTY
15692: LIST
15693: LIST
15694: LIST
15695: PUSH
15696: EMPTY
15697: LIST
15698: LIST
15699: PPUSH
15700: CALL_OW 69
15704: NOT
15705: IFFALSE 15556
// end ;
15707: PPOPN 2
15709: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15710: LD_EXP 4
15714: PUSH
15715: LD_EXP 2
15719: AND
15720: PUSH
15721: LD_EXP 3
15725: AND
15726: PUSH
15727: LD_EXP 5
15731: AND
15732: PUSH
15733: LD_EXP 6
15737: AND
15738: PUSH
15739: LD_EXP 7
15743: AND
15744: PUSH
15745: LD_EXP 8
15749: AND
15750: PUSH
15751: LD_EXP 53
15755: PPUSH
15756: CALL_OW 255
15760: PUSH
15761: LD_INT 5
15763: NONEQUAL
15764: PUSH
15765: LD_EXP 53
15769: PPUSH
15770: CALL_OW 301
15774: OR
15775: PUSH
15776: LD_EXP 53
15780: PPUSH
15781: CALL_OW 305
15785: NOT
15786: OR
15787: AND
15788: IFFALSE 17179
15790: GO 15792
15792: DISABLE
15793: LD_INT 0
15795: PPUSH
15796: PPUSH
// begin wait ( 0 0$5 ) ;
15797: LD_INT 175
15799: PPUSH
15800: CALL_OW 67
// music_class := 5 ;
15804: LD_ADDR_OWVAR 72
15808: PUSH
15809: LD_INT 5
15811: ST_TO_ADDR
// music_nat := 5 ;
15812: LD_ADDR_OWVAR 71
15816: PUSH
15817: LD_INT 5
15819: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15820: LD_EXP 15
15824: PUSH
15825: LD_INT 3
15827: LESS
15828: IFFALSE 15837
// SetAchievement ( ACH_ECONOMY ) ;
15830: LD_STRING ACH_ECONOMY
15832: PPUSH
15833: CALL_OW 543
// if tick < 60 60$00 then
15837: LD_OWVAR 1
15841: PUSH
15842: LD_INT 126000
15844: LESS
15845: IFFALSE 15861
// begin wait ( 3 ) ;
15847: LD_INT 3
15849: PPUSH
15850: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15854: LD_STRING ACH_ASPEED_19
15856: PPUSH
15857: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15861: LD_EXP 17
15865: PPUSH
15866: CALL_OW 87
// InGameOn ;
15870: CALL_OW 8
// DialogueOn ;
15874: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15878: LD_EXP 17
15882: PPUSH
15883: LD_STRING DEnd-JMM-JMM-1
15885: PPUSH
15886: CALL_OW 88
// if Joan then
15890: LD_EXP 32
15894: IFFALSE 15910
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15896: LD_EXP 32
15900: PPUSH
15901: LD_STRING DEnd-JMM-Joan-1
15903: PPUSH
15904: CALL_OW 88
15908: GO 15954
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15910: LD_EXP 19
15914: PUSH
15915: LD_EXP 19
15919: PPUSH
15920: CALL_OW 255
15924: PUSH
15925: LD_INT 7
15927: EQUAL
15928: AND
15929: PUSH
15930: LD_EXP 19
15934: PPUSH
15935: CALL_OW 305
15939: AND
15940: IFFALSE 15954
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15942: LD_EXP 19
15946: PPUSH
15947: LD_STRING DEnd-JMM-Lisa-1
15949: PPUSH
15950: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15954: LD_EXP 29
15958: PUSH
15959: LD_EXP 29
15963: PPUSH
15964: CALL_OW 305
15968: AND
15969: IFFALSE 15983
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15971: LD_EXP 29
15975: PPUSH
15976: LD_STRING DEnd-JMM-Frank-1
15978: PPUSH
15979: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15983: LD_EXP 22
15987: PUSH
15988: LD_EXP 22
15992: PPUSH
15993: CALL_OW 255
15997: PUSH
15998: LD_INT 7
16000: EQUAL
16001: AND
16002: PUSH
16003: LD_EXP 22
16007: PPUSH
16008: CALL_OW 305
16012: AND
16013: IFFALSE 16027
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16015: LD_EXP 22
16019: PPUSH
16020: LD_STRING DEnd-JMM-Cyrus-1
16022: PPUSH
16023: CALL_OW 88
// if Burlak then
16027: LD_EXP 49
16031: IFFALSE 16045
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16033: LD_EXP 49
16037: PPUSH
16038: LD_STRING DEnd-JMM-Bur-1
16040: PPUSH
16041: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16045: LD_EXP 32
16049: PUSH
16050: LD_EXP 19
16054: AND
16055: PUSH
16056: LD_EXP 19
16060: PPUSH
16061: CALL_OW 255
16065: PUSH
16066: LD_INT 7
16068: EQUAL
16069: AND
16070: PUSH
16071: LD_EXP 19
16075: PPUSH
16076: CALL_OW 305
16080: AND
16081: IFFALSE 16095
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16083: LD_EXP 19
16087: PPUSH
16088: LD_STRING DEnd-Burlak-Lisa-1
16090: PPUSH
16091: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16095: LD_EXP 50
16099: PUSH
16100: LD_EXP 50
16104: PPUSH
16105: CALL_OW 305
16109: AND
16110: IFFALSE 16124
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16112: LD_EXP 50
16116: PPUSH
16117: LD_STRING DEnd-JMM-Bel-1
16119: PPUSH
16120: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16124: LD_EXP 51
16128: PUSH
16129: LD_EXP 51
16133: PPUSH
16134: CALL_OW 305
16138: AND
16139: IFFALSE 16153
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16141: LD_EXP 51
16145: PPUSH
16146: LD_STRING DEnd-JMM-Gny-1
16148: PPUSH
16149: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16153: LD_EXP 27
16157: PUSH
16158: LD_EXP 27
16162: PPUSH
16163: CALL_OW 255
16167: PUSH
16168: LD_INT 7
16170: EQUAL
16171: AND
16172: PUSH
16173: LD_EXP 27
16177: PPUSH
16178: CALL_OW 305
16182: AND
16183: IFFALSE 16197
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16185: LD_EXP 27
16189: PPUSH
16190: LD_STRING DEnd-JMM-Corn-1
16192: PPUSH
16193: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16197: LD_EXP 20
16201: PUSH
16202: LD_EXP 20
16206: PPUSH
16207: CALL_OW 255
16211: PUSH
16212: LD_INT 7
16214: EQUAL
16215: AND
16216: PUSH
16217: LD_EXP 20
16221: PPUSH
16222: CALL_OW 305
16226: AND
16227: IFFALSE 16241
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16229: LD_EXP 20
16233: PPUSH
16234: LD_STRING DEnd-JMM-Don-1
16236: PPUSH
16237: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16241: LD_EXP 21
16245: PUSH
16246: LD_EXP 21
16250: PPUSH
16251: CALL_OW 255
16255: PUSH
16256: LD_INT 7
16258: EQUAL
16259: AND
16260: PUSH
16261: LD_EXP 21
16265: PPUSH
16266: CALL_OW 305
16270: AND
16271: IFFALSE 16285
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16273: LD_EXP 21
16277: PPUSH
16278: LD_STRING DEnd-JMM-Bobby-1
16280: PPUSH
16281: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16285: LD_EXP 23
16289: PUSH
16290: LD_EXP 23
16294: PPUSH
16295: CALL_OW 255
16299: PUSH
16300: LD_INT 7
16302: EQUAL
16303: AND
16304: PUSH
16305: LD_EXP 23
16309: PPUSH
16310: CALL_OW 305
16314: AND
16315: IFFALSE 16329
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16317: LD_EXP 23
16321: PPUSH
16322: LD_STRING DEnd-JMM-Den-1
16324: PPUSH
16325: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16329: LD_EXP 25
16333: PUSH
16334: LD_EXP 25
16338: PPUSH
16339: CALL_OW 255
16343: PUSH
16344: LD_INT 7
16346: EQUAL
16347: AND
16348: PUSH
16349: LD_EXP 25
16353: PPUSH
16354: CALL_OW 305
16358: AND
16359: IFFALSE 16373
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16361: LD_EXP 25
16365: PPUSH
16366: LD_STRING DEnd-JMM-Glad-1
16368: PPUSH
16369: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16373: LD_EXP 30
16377: PUSH
16378: LD_EXP 30
16382: PPUSH
16383: CALL_OW 255
16387: PUSH
16388: LD_INT 7
16390: EQUAL
16391: AND
16392: PUSH
16393: LD_EXP 30
16397: PPUSH
16398: CALL_OW 305
16402: AND
16403: IFFALSE 16417
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16405: LD_EXP 30
16409: PPUSH
16410: LD_STRING DEnd-JMM-Yam-1
16412: PPUSH
16413: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16417: LD_EXP 24
16421: PUSH
16422: LD_EXP 24
16426: PPUSH
16427: CALL_OW 255
16431: PUSH
16432: LD_INT 7
16434: EQUAL
16435: AND
16436: PUSH
16437: LD_EXP 24
16441: PPUSH
16442: CALL_OW 305
16446: AND
16447: IFFALSE 16461
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16449: LD_EXP 24
16453: PPUSH
16454: LD_STRING DEnd-JMM-Brown-1
16456: PPUSH
16457: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16461: LD_EXP 34
16465: PUSH
16466: LD_EXP 34
16470: PPUSH
16471: CALL_OW 255
16475: PUSH
16476: LD_INT 7
16478: EQUAL
16479: AND
16480: PUSH
16481: LD_EXP 34
16485: PPUSH
16486: CALL_OW 305
16490: AND
16491: IFFALSE 16505
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16493: LD_EXP 34
16497: PPUSH
16498: LD_STRING DEnd-JMM-Con-1
16500: PPUSH
16501: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16505: LD_EXP 28
16509: PUSH
16510: LD_EXP 28
16514: PPUSH
16515: CALL_OW 255
16519: PUSH
16520: LD_INT 7
16522: EQUAL
16523: AND
16524: PUSH
16525: LD_EXP 28
16529: PPUSH
16530: CALL_OW 305
16534: AND
16535: IFFALSE 16549
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16537: LD_EXP 28
16541: PPUSH
16542: LD_STRING DEnd-JMM-Gary-1
16544: PPUSH
16545: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16549: LD_EXP 31
16553: PUSH
16554: LD_EXP 18
16558: AND
16559: PUSH
16560: LD_EXP 31
16564: PPUSH
16565: CALL_OW 305
16569: AND
16570: IFFALSE 16584
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16572: LD_EXP 31
16576: PPUSH
16577: LD_STRING DEnd-JMM-Sim-1
16579: PPUSH
16580: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16584: LD_EXP 26
16588: PUSH
16589: LD_EXP 26
16593: PPUSH
16594: CALL_OW 255
16598: PUSH
16599: LD_INT 7
16601: EQUAL
16602: AND
16603: PUSH
16604: LD_EXP 26
16608: PPUSH
16609: CALL_OW 305
16613: AND
16614: IFFALSE 16628
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16616: LD_EXP 26
16620: PPUSH
16621: LD_STRING DEnd-JMM-VanH-1
16623: PPUSH
16624: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16628: LD_EXP 39
16632: PUSH
16633: LD_EXP 39
16637: PPUSH
16638: CALL_OW 305
16642: AND
16643: IFFALSE 16657
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16645: LD_EXP 39
16649: PPUSH
16650: LD_STRING DEnd-JMM-Dol-1
16652: PPUSH
16653: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16657: LD_EXP 43
16661: PUSH
16662: LD_EXP 43
16666: PPUSH
16667: CALL_OW 305
16671: AND
16672: IFFALSE 16686
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16674: LD_EXP 43
16678: PPUSH
16679: LD_STRING DEnd-JMM-Kap-1
16681: PPUSH
16682: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16686: LD_EXP 46
16690: PUSH
16691: LD_EXP 46
16695: PPUSH
16696: CALL_OW 305
16700: AND
16701: IFFALSE 16715
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16703: LD_EXP 46
16707: PPUSH
16708: LD_STRING DEnd-JMM-Kov-1
16710: PPUSH
16711: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16715: LD_EXP 41
16719: PUSH
16720: LD_EXP 41
16724: PPUSH
16725: CALL_OW 305
16729: AND
16730: IFFALSE 16744
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16732: LD_EXP 41
16736: PPUSH
16737: LD_STRING DEnd-JMM-Sch-1
16739: PPUSH
16740: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16744: LD_EXP 37
16748: PUSH
16749: LD_EXP 37
16753: PPUSH
16754: CALL_OW 305
16758: AND
16759: IFFALSE 16773
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16761: LD_EXP 37
16765: PPUSH
16766: LD_STRING DEnd-JMM-Tit-1
16768: PPUSH
16769: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16773: LD_EXP 42
16777: PUSH
16778: LD_EXP 42
16782: PPUSH
16783: CALL_OW 305
16787: AND
16788: IFFALSE 16802
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16790: LD_EXP 42
16794: PPUSH
16795: LD_STRING DEnd-JMM-Obl-1
16797: PPUSH
16798: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16802: LD_EXP 44
16806: PUSH
16807: LD_EXP 44
16811: PPUSH
16812: CALL_OW 305
16816: AND
16817: IFFALSE 16831
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16819: LD_EXP 44
16823: PPUSH
16824: LD_STRING DEnd-JMM-Lip-1
16826: PPUSH
16827: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16831: LD_EXP 38
16835: PUSH
16836: LD_EXP 38
16840: PPUSH
16841: CALL_OW 305
16845: AND
16846: PUSH
16847: LD_EXP 49
16851: AND
16852: IFFALSE 16866
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16854: LD_EXP 38
16858: PPUSH
16859: LD_STRING DEnd-Burlak-Fad-1
16861: PPUSH
16862: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16866: LD_EXP 45
16870: PUSH
16871: LD_EXP 45
16875: PPUSH
16876: CALL_OW 305
16880: AND
16881: IFFALSE 16895
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16883: LD_EXP 45
16887: PPUSH
16888: LD_STRING DEnd-Burlak-Ptr-1
16890: PPUSH
16891: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16895: LD_EXP 47
16899: PUSH
16900: LD_EXP 47
16904: PPUSH
16905: CALL_OW 305
16909: AND
16910: IFFALSE 16924
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16912: LD_EXP 47
16916: PPUSH
16917: LD_STRING DEnd-Burlak-Kuz-1
16919: PPUSH
16920: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16924: LD_EXP 36
16928: PUSH
16929: LD_EXP 36
16933: PPUSH
16934: CALL_OW 305
16938: AND
16939: PUSH
16940: LD_EXP 49
16944: AND
16945: IFFALSE 16959
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16947: LD_EXP 36
16951: PPUSH
16952: LD_STRING DEnd-Burlak-Kir-1
16954: PPUSH
16955: CALL_OW 88
// if Burlak then
16959: LD_EXP 49
16963: IFFALSE 16977
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16965: LD_EXP 17
16969: PPUSH
16970: LD_STRING DEnd-Burlak-JMM-1
16972: PPUSH
16973: CALL_OW 88
// dwait ( 0 0$2 ) ;
16977: LD_INT 70
16979: PPUSH
16980: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16984: LD_EXP 54
16988: PPUSH
16989: LD_STRING DEnd-Szulc
16991: PPUSH
16992: CALL_OW 94
// dwait ( 0 0$1 ) ;
16996: LD_INT 35
16998: PPUSH
16999: CALL_OW 68
// if IsLive ( Burlak ) then
17003: LD_EXP 49
17007: PPUSH
17008: CALL_OW 300
17012: IFFALSE 17024
// med1 := 1 else
17014: LD_ADDR_VAR 0 1
17018: PUSH
17019: LD_INT 1
17021: ST_TO_ADDR
17022: GO 17033
// med1 := - 1 ;
17024: LD_ADDR_VAR 0 1
17028: PUSH
17029: LD_INT 1
17031: NEG
17032: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17033: LD_EXP 12
17037: PUSH
17038: LD_EXP 13
17042: AND
17043: PUSH
17044: LD_EXP 14
17048: AND
17049: IFFALSE 17061
// med2 := 1 else
17051: LD_ADDR_VAR 0 2
17055: PUSH
17056: LD_INT 1
17058: ST_TO_ADDR
17059: GO 17070
// med2 := - 1 ;
17061: LD_ADDR_VAR 0 2
17065: PUSH
17066: LD_INT 1
17068: NEG
17069: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17070: LD_STRING Hero
17072: PPUSH
17073: LD_INT 1
17075: PPUSH
17076: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17080: LD_STRING Artefact
17082: PPUSH
17083: LD_VAR 0 2
17087: PPUSH
17088: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17092: LD_STRING ReconcileBurlak
17094: PPUSH
17095: LD_VAR 0 1
17099: PPUSH
17100: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17104: LD_OWVAR 67
17108: PUSH
17109: LD_INT 3
17111: EQUAL
17112: PUSH
17113: LD_VAR 0 1
17117: PUSH
17118: LD_INT 1
17120: EQUAL
17121: AND
17122: PUSH
17123: LD_VAR 0 2
17127: PUSH
17128: LD_INT 1
17130: EQUAL
17131: AND
17132: IFFALSE 17144
// SetAchievementEX ( ACH_AMER , 19 ) ;
17134: LD_STRING ACH_AMER
17136: PPUSH
17137: LD_INT 19
17139: PPUSH
17140: CALL_OW 564
// GiveMedals ( MAIN ) ;
17144: LD_STRING MAIN
17146: PPUSH
17147: CALL_OW 102
// InGameOff ;
17151: CALL_OW 9
// DialogueOff ;
17155: CALL_OW 7
// music_nat := 1 ;
17159: LD_ADDR_OWVAR 71
17163: PUSH
17164: LD_INT 1
17166: ST_TO_ADDR
// music_class := 4 ;
17167: LD_ADDR_OWVAR 72
17171: PUSH
17172: LD_INT 4
17174: ST_TO_ADDR
// YouWin ;
17175: CALL_OW 103
// end ; end_of_file
17179: PPOPN 2
17181: END
// export function InitNature ; begin
17182: LD_INT 0
17184: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17185: LD_INT 3
17187: PPUSH
17188: LD_INT 3
17190: PPUSH
17191: LD_INT 2
17193: PPUSH
17194: LD_INT 1
17196: PPUSH
17197: LD_INT 1
17199: PPUSH
17200: LD_INT 0
17202: PPUSH
17203: LD_INT 0
17205: PPUSH
17206: LD_INT 17
17208: PPUSH
17209: LD_INT 0
17211: PPUSH
17212: CALL 83278 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17216: LD_INT 2
17218: PPUSH
17219: LD_INT 1
17221: PPUSH
17222: LD_INT 1
17224: PPUSH
17225: LD_INT 1
17227: PPUSH
17228: LD_INT 1
17230: PPUSH
17231: LD_INT 0
17233: PPUSH
17234: LD_INT 0
17236: PPUSH
17237: LD_INT 18
17239: PPUSH
17240: LD_INT 0
17242: PPUSH
17243: CALL 83278 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17247: LD_INT 4
17249: PPUSH
17250: LD_INT 1
17252: PPUSH
17253: LD_INT 2
17255: PPUSH
17256: LD_INT 4
17258: PPUSH
17259: LD_INT 2
17261: PPUSH
17262: LD_INT 1
17264: PPUSH
17265: LD_INT 0
17267: PPUSH
17268: LD_INT 19
17270: PPUSH
17271: LD_INT 0
17273: PPUSH
17274: CALL 83278 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17278: LD_INT 0
17280: PPUSH
17281: LD_INT 0
17283: PPUSH
17284: LD_INT 0
17286: PPUSH
17287: LD_INT 0
17289: PPUSH
17290: LD_INT 0
17292: PPUSH
17293: LD_INT 0
17295: PPUSH
17296: LD_INT 9
17298: PPUSH
17299: LD_INT 0
17301: PPUSH
17302: LD_INT 20
17304: PPUSH
17305: CALL 83278 0 9
// end ; end_of_file
17309: LD_VAR 0 1
17313: RET
// every 0 0$30 do var time ;
17314: GO 17316
17316: DISABLE
17317: LD_INT 0
17319: PPUSH
// begin time := 0 0$50 ;
17320: LD_ADDR_VAR 0 1
17324: PUSH
17325: LD_INT 1750
17327: ST_TO_ADDR
// repeat wait ( time ) ;
17328: LD_VAR 0 1
17332: PPUSH
17333: CALL_OW 67
// if Prob ( 50 ) then
17337: LD_INT 50
17339: PPUSH
17340: CALL_OW 13
17344: IFFALSE 17373
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17346: LD_INT 1
17348: PPUSH
17349: LD_INT 5
17351: PPUSH
17352: CALL_OW 12
17356: PPUSH
17357: LD_INT 106
17359: PPUSH
17360: LD_INT 89
17362: PPUSH
17363: LD_INT 45
17365: PPUSH
17366: LD_INT 1
17368: PPUSH
17369: CALL_OW 56
// time := time + 0 0$3 ;
17373: LD_ADDR_VAR 0 1
17377: PUSH
17378: LD_VAR 0 1
17382: PUSH
17383: LD_INT 105
17385: PLUS
17386: ST_TO_ADDR
// if Prob ( 30 ) then
17387: LD_INT 30
17389: PPUSH
17390: CALL_OW 13
17394: IFFALSE 17440
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17396: LD_INT 525
17398: PPUSH
17399: LD_INT 735
17401: PPUSH
17402: CALL_OW 12
17406: PPUSH
17407: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17411: LD_INT 1
17413: PPUSH
17414: LD_INT 5
17416: PPUSH
17417: CALL_OW 12
17421: PPUSH
17422: LD_INT 21
17424: PPUSH
17425: LD_INT 26
17427: PPUSH
17428: LD_INT 12
17430: PPUSH
17431: LD_INT 1
17433: PPUSH
17434: CALL_OW 56
// end else
17438: GO 17476
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17440: LD_INT 700
17442: PPUSH
17443: LD_INT 1225
17445: PPUSH
17446: CALL_OW 12
17450: PPUSH
17451: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17455: LD_INT 1
17457: PPUSH
17458: LD_INT 5
17460: PPUSH
17461: CALL_OW 12
17465: PPUSH
17466: LD_INT 14
17468: PPUSH
17469: LD_INT 1
17471: PPUSH
17472: CALL_OW 55
// end ; if Prob ( 50 ) then
17476: LD_INT 50
17478: PPUSH
17479: CALL_OW 13
17483: IFFALSE 17529
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17485: LD_INT 700
17487: PPUSH
17488: LD_INT 1050
17490: PPUSH
17491: CALL_OW 12
17495: PPUSH
17496: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17500: LD_INT 1
17502: PPUSH
17503: LD_INT 5
17505: PPUSH
17506: CALL_OW 12
17510: PPUSH
17511: LD_INT 181
17513: PPUSH
17514: LD_INT 218
17516: PPUSH
17517: LD_INT 16
17519: PPUSH
17520: LD_INT 1
17522: PPUSH
17523: CALL_OW 56
// end else
17527: GO 17601
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17529: LD_INT 350
17531: PPUSH
17532: LD_INT 525
17534: PPUSH
17535: CALL_OW 12
17539: PPUSH
17540: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17544: LD_INT 1
17546: PPUSH
17547: LD_INT 5
17549: PPUSH
17550: CALL_OW 12
17554: PPUSH
17555: LD_INT 13
17557: PPUSH
17558: LD_INT 1
17560: PPUSH
17561: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17565: LD_INT 350
17567: PPUSH
17568: LD_INT 700
17570: PPUSH
17571: CALL_OW 12
17575: PPUSH
17576: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17580: LD_INT 1
17582: PPUSH
17583: LD_INT 5
17585: PPUSH
17586: CALL_OW 12
17590: PPUSH
17591: LD_INT 33
17593: PPUSH
17594: LD_INT 1
17596: PPUSH
17597: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17601: LD_INT 65
17603: PUSH
17604: LD_INT 62
17606: PUSH
17607: LD_INT 55
17609: PUSH
17610: EMPTY
17611: LIST
17612: LIST
17613: LIST
17614: PUSH
17615: LD_OWVAR 67
17619: ARRAY
17620: PPUSH
17621: CALL_OW 13
17625: IFFALSE 17671
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17627: LD_INT 525
17629: PPUSH
17630: LD_INT 875
17632: PPUSH
17633: CALL_OW 12
17637: PPUSH
17638: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17642: LD_INT 1
17644: PPUSH
17645: LD_INT 5
17647: PPUSH
17648: CALL_OW 12
17652: PPUSH
17653: LD_INT 294
17655: PPUSH
17656: LD_INT 211
17658: PPUSH
17659: LD_INT 30
17661: PPUSH
17662: LD_INT 1
17664: PPUSH
17665: CALL_OW 56
// end else
17669: GO 17713
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17671: LD_INT 420
17673: PPUSH
17674: LD_INT 770
17676: PPUSH
17677: CALL_OW 12
17681: PPUSH
17682: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17686: LD_INT 1
17688: PPUSH
17689: LD_INT 5
17691: PPUSH
17692: CALL_OW 12
17696: PPUSH
17697: LD_INT 294
17699: PPUSH
17700: LD_INT 211
17702: PPUSH
17703: LD_INT 30
17705: PPUSH
17706: LD_INT 1
17708: PPUSH
17709: CALL_OW 56
// end ; if time > 2 2$20 then
17713: LD_VAR 0 1
17717: PUSH
17718: LD_INT 4900
17720: GREATER
17721: IFFALSE 17731
// time := 0 0$50 ;
17723: LD_ADDR_VAR 0 1
17727: PUSH
17728: LD_INT 1750
17730: ST_TO_ADDR
// until false ;
17731: LD_INT 0
17733: IFFALSE 17328
// end ;
17735: PPOPN 1
17737: END
// every 0 0$45 trigger tick < 10 10$00 do
17738: LD_OWVAR 1
17742: PUSH
17743: LD_INT 21000
17745: LESS
17746: IFFALSE 17794
17748: GO 17750
17750: DISABLE
// begin enable ;
17751: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17752: LD_INT 350
17754: PPUSH
17755: LD_INT 700
17757: PPUSH
17758: CALL_OW 12
17762: PPUSH
17763: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17767: LD_INT 3
17769: PPUSH
17770: LD_INT 5
17772: PPUSH
17773: CALL_OW 12
17777: PPUSH
17778: LD_INT 181
17780: PPUSH
17781: LD_INT 13
17783: PPUSH
17784: LD_INT 20
17786: PPUSH
17787: LD_INT 1
17789: PPUSH
17790: CALL_OW 56
// end ; end_of_file
17794: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17795: LD_INT 0
17797: PPUSH
// SetArtifactRes ( 7 , true ) ;
17798: LD_INT 7
17800: PPUSH
17801: LD_INT 1
17803: PPUSH
17804: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17808: LD_ADDR_EXP 62
17812: PUSH
17813: EMPTY
17814: PUSH
17815: EMPTY
17816: PUSH
17817: EMPTY
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: LIST
17823: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17824: LD_ADDR_EXP 63
17828: PUSH
17829: LD_INT 1050
17831: PUSH
17832: LD_OWVAR 67
17836: MUL
17837: PUSH
17838: LD_INT 2800
17840: PUSH
17841: LD_OWVAR 67
17845: MUL
17846: PUSH
17847: LD_INT 1
17849: NEG
17850: PUSH
17851: EMPTY
17852: LIST
17853: LIST
17854: LIST
17855: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17856: LD_ADDR_EXP 64
17860: PUSH
17861: LD_INT 10
17863: PUSH
17864: LD_INT 35
17866: PUSH
17867: LD_INT 100
17869: PUSH
17870: EMPTY
17871: LIST
17872: LIST
17873: LIST
17874: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17875: LD_ADDR_EXP 65
17879: PUSH
17880: LD_INT 0
17882: PUSH
17883: LD_INT 0
17885: PUSH
17886: LD_INT 0
17888: PUSH
17889: EMPTY
17890: LIST
17891: LIST
17892: LIST
17893: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17894: LD_ADDR_EXP 67
17898: PUSH
17899: LD_INT 300
17901: PUSH
17902: LD_INT 500
17904: PUSH
17905: LD_INT 800
17907: PUSH
17908: EMPTY
17909: LIST
17910: LIST
17911: LIST
17912: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17913: LD_ADDR_EXP 68
17917: PUSH
17918: LD_INT 0
17920: PUSH
17921: LD_INT 0
17923: PUSH
17924: LD_INT 0
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: LIST
17931: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17932: LD_ADDR_EXP 69
17936: PUSH
17937: LD_INT 0
17939: PUSH
17940: LD_INT 0
17942: PUSH
17943: LD_INT 0
17945: PUSH
17946: EMPTY
17947: LIST
17948: LIST
17949: LIST
17950: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17951: LD_ADDR_EXP 66
17955: PUSH
17956: LD_INT 0
17958: PUSH
17959: LD_INT 0
17961: PUSH
17962: LD_INT 0
17964: PUSH
17965: EMPTY
17966: LIST
17967: LIST
17968: LIST
17969: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17970: LD_ADDR_EXP 70
17974: PUSH
17975: LD_INT 4
17977: PUSH
17978: LD_INT 3
17980: PUSH
17981: LD_INT 1
17983: PUSH
17984: EMPTY
17985: LIST
17986: LIST
17987: LIST
17988: PUSH
17989: LD_INT 5
17991: PUSH
17992: LD_INT 4
17994: PUSH
17995: LD_INT 2
17997: PUSH
17998: EMPTY
17999: LIST
18000: LIST
18001: LIST
18002: PUSH
18003: LD_INT 6
18005: PUSH
18006: LD_INT 3
18008: PUSH
18009: LD_INT 3
18011: PUSH
18012: EMPTY
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18022: LD_ADDR_EXP 71
18026: PUSH
18027: LD_INT 0
18029: PUSH
18030: LD_INT 0
18032: PUSH
18033: LD_INT 0
18035: PUSH
18036: EMPTY
18037: LIST
18038: LIST
18039: LIST
18040: ST_TO_ADDR
// end ;
18041: LD_VAR 0 1
18045: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18046: LD_INT 24
18048: PPUSH
18049: LD_INT 7
18051: PPUSH
18052: CALL_OW 321
18056: PUSH
18057: LD_INT 2
18059: EQUAL
18060: IFFALSE 18986
18062: GO 18064
18064: DISABLE
18065: LD_INT 0
18067: PPUSH
18068: PPUSH
18069: PPUSH
18070: PPUSH
18071: PPUSH
// begin enable ;
18072: ENABLE
// for i = 1 to 3 do
18073: LD_ADDR_VAR 0 1
18077: PUSH
18078: DOUBLE
18079: LD_INT 1
18081: DEC
18082: ST_TO_ADDR
18083: LD_INT 3
18085: PUSH
18086: FOR_TO
18087: IFFALSE 18984
// begin pos := FindArtifact ( i + 2 ) ;
18089: LD_ADDR_VAR 0 2
18093: PUSH
18094: LD_VAR 0 1
18098: PUSH
18099: LD_INT 2
18101: PLUS
18102: PPUSH
18103: CALL_OW 469
18107: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18108: LD_ADDR_EXP 62
18112: PUSH
18113: LD_EXP 62
18117: PPUSH
18118: LD_VAR 0 1
18122: PPUSH
18123: LD_VAR 0 2
18127: PPUSH
18128: CALL_OW 1
18132: ST_TO_ADDR
// if pos then
18133: LD_VAR 0 2
18137: IFFALSE 18845
// begin case i of 1 :
18139: LD_VAR 0 1
18143: PUSH
18144: LD_INT 1
18146: DOUBLE
18147: EQUAL
18148: IFTRUE 18152
18150: GO 18229
18152: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18153: LD_ADDR_VAR 0 4
18157: PUSH
18158: LD_INT 22
18160: PUSH
18161: LD_INT 7
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: PUSH
18168: LD_INT 23
18170: PUSH
18171: LD_INT 1
18173: PUSH
18174: EMPTY
18175: LIST
18176: LIST
18177: PUSH
18178: LD_INT 2
18180: PUSH
18181: LD_INT 30
18183: PUSH
18184: LD_INT 8
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: PUSH
18191: LD_INT 30
18193: PUSH
18194: LD_INT 7
18196: PUSH
18197: EMPTY
18198: LIST
18199: LIST
18200: PUSH
18201: LD_INT 30
18203: PUSH
18204: LD_INT 11
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PUSH
18211: EMPTY
18212: LIST
18213: LIST
18214: LIST
18215: LIST
18216: PUSH
18217: EMPTY
18218: LIST
18219: LIST
18220: LIST
18221: PPUSH
18222: CALL_OW 69
18226: ST_TO_ADDR
18227: GO 18337
18229: LD_INT 2
18231: DOUBLE
18232: EQUAL
18233: IFTRUE 18237
18235: GO 18314
18237: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18238: LD_ADDR_VAR 0 4
18242: PUSH
18243: LD_INT 22
18245: PUSH
18246: LD_INT 7
18248: PUSH
18249: EMPTY
18250: LIST
18251: LIST
18252: PUSH
18253: LD_INT 23
18255: PUSH
18256: LD_INT 3
18258: PUSH
18259: EMPTY
18260: LIST
18261: LIST
18262: PUSH
18263: LD_INT 2
18265: PUSH
18266: LD_INT 30
18268: PUSH
18269: LD_INT 8
18271: PUSH
18272: EMPTY
18273: LIST
18274: LIST
18275: PUSH
18276: LD_INT 30
18278: PUSH
18279: LD_INT 7
18281: PUSH
18282: EMPTY
18283: LIST
18284: LIST
18285: PUSH
18286: LD_INT 30
18288: PUSH
18289: LD_INT 11
18291: PUSH
18292: EMPTY
18293: LIST
18294: LIST
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: LIST
18300: LIST
18301: PUSH
18302: EMPTY
18303: LIST
18304: LIST
18305: LIST
18306: PPUSH
18307: CALL_OW 69
18311: ST_TO_ADDR
18312: GO 18337
18314: LD_INT 3
18316: DOUBLE
18317: EQUAL
18318: IFTRUE 18322
18320: GO 18336
18322: POP
// labs := [ alien ] ; end ;
18323: LD_ADDR_VAR 0 4
18327: PUSH
18328: LD_INT 1
18330: PUSH
18331: EMPTY
18332: LIST
18333: ST_TO_ADDR
18334: GO 18337
18336: POP
// if not labs then
18337: LD_VAR 0 4
18341: NOT
18342: IFFALSE 18346
// continue ;
18344: GO 18086
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18346: LD_ADDR_VAR 0 5
18350: PUSH
18351: LD_VAR 0 4
18355: PPUSH
18356: LD_EXP 62
18360: PUSH
18361: LD_VAR 0 1
18365: ARRAY
18366: PUSH
18367: LD_INT 1
18369: ARRAY
18370: PPUSH
18371: LD_EXP 62
18375: PUSH
18376: LD_VAR 0 1
18380: ARRAY
18381: PUSH
18382: LD_INT 2
18384: ARRAY
18385: PPUSH
18386: CALL_OW 73
18390: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18391: LD_VAR 0 5
18395: NOT
18396: PUSH
18397: LD_VAR 0 5
18401: PUSH
18402: LD_EXP 69
18406: PUSH
18407: LD_VAR 0 1
18411: ARRAY
18412: NONEQUAL
18413: OR
18414: IFFALSE 18519
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18416: LD_INT 7
18418: PPUSH
18419: LD_EXP 70
18423: PUSH
18424: LD_VAR 0 1
18428: ARRAY
18429: PUSH
18430: LD_INT 3
18432: ARRAY
18433: PPUSH
18434: LD_INT 0
18436: PPUSH
18437: LD_EXP 69
18441: PUSH
18442: LD_VAR 0 1
18446: ARRAY
18447: PPUSH
18448: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18452: LD_INT 7
18454: PPUSH
18455: LD_EXP 70
18459: PUSH
18460: LD_VAR 0 1
18464: ARRAY
18465: PUSH
18466: LD_INT 1
18468: ARRAY
18469: PPUSH
18470: LD_INT 0
18472: PPUSH
18473: LD_EXP 69
18477: PUSH
18478: LD_VAR 0 1
18482: ARRAY
18483: PPUSH
18484: CALL_OW 468
// if nearestLab then
18488: LD_VAR 0 5
18492: IFFALSE 18519
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18494: LD_ADDR_EXP 69
18498: PUSH
18499: LD_EXP 69
18503: PPUSH
18504: LD_VAR 0 1
18508: PPUSH
18509: LD_VAR 0 5
18513: PPUSH
18514: CALL_OW 1
18518: ST_TO_ADDR
// end ; if not nearestLab then
18519: LD_VAR 0 5
18523: NOT
18524: IFFALSE 18528
// continue ;
18526: GO 18086
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18528: LD_VAR 0 5
18532: PPUSH
18533: LD_EXP 62
18537: PUSH
18538: LD_VAR 0 1
18542: ARRAY
18543: PUSH
18544: LD_INT 1
18546: ARRAY
18547: PPUSH
18548: LD_EXP 62
18552: PUSH
18553: LD_VAR 0 1
18557: ARRAY
18558: PUSH
18559: LD_INT 2
18561: ARRAY
18562: PPUSH
18563: CALL_OW 297
18567: PUSH
18568: LD_INT 8
18570: LESS
18571: IFFALSE 18768
// begin if not artifactsResearched [ i ] then
18573: LD_EXP 65
18577: PUSH
18578: LD_VAR 0 1
18582: ARRAY
18583: NOT
18584: IFFALSE 18665
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18586: LD_VAR 0 5
18590: PPUSH
18591: CALL_OW 461
18595: PUSH
18596: LD_INT 2
18598: EQUAL
18599: IFFALSE 18633
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18601: LD_INT 7
18603: PPUSH
18604: LD_EXP 70
18608: PUSH
18609: LD_VAR 0 1
18613: ARRAY
18614: PUSH
18615: LD_INT 3
18617: ARRAY
18618: PPUSH
18619: LD_INT 2
18621: PPUSH
18622: LD_VAR 0 5
18626: PPUSH
18627: CALL_OW 468
18631: GO 18663
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18633: LD_INT 7
18635: PPUSH
18636: LD_EXP 70
18640: PUSH
18641: LD_VAR 0 1
18645: ARRAY
18646: PUSH
18647: LD_INT 3
18649: ARRAY
18650: PPUSH
18651: LD_INT 1
18653: PPUSH
18654: LD_VAR 0 5
18658: PPUSH
18659: CALL_OW 468
// end else
18663: GO 18766
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18665: LD_VAR 0 5
18669: PPUSH
18670: CALL_OW 461
18674: PUSH
18675: LD_INT 2
18677: EQUAL
18678: PUSH
18679: LD_EXP 71
18683: PUSH
18684: LD_VAR 0 1
18688: ARRAY
18689: AND
18690: IFFALSE 18736
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18692: LD_INT 7
18694: PPUSH
18695: LD_EXP 70
18699: PUSH
18700: LD_VAR 0 1
18704: ARRAY
18705: PUSH
18706: LD_INT 1
18708: ARRAY
18709: PPUSH
18710: LD_EXP 70
18714: PUSH
18715: LD_VAR 0 1
18719: ARRAY
18720: PUSH
18721: LD_INT 2
18723: ARRAY
18724: PPUSH
18725: LD_VAR 0 5
18729: PPUSH
18730: CALL_OW 468
18734: GO 18766
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18736: LD_INT 7
18738: PPUSH
18739: LD_EXP 70
18743: PUSH
18744: LD_VAR 0 1
18748: ARRAY
18749: PUSH
18750: LD_INT 1
18752: ARRAY
18753: PPUSH
18754: LD_INT 1
18756: PPUSH
18757: LD_VAR 0 5
18761: PPUSH
18762: CALL_OW 468
// end else
18766: GO 18843
// begin if not artifactsResearched [ i ] then
18768: LD_EXP 65
18772: PUSH
18773: LD_VAR 0 1
18777: ARRAY
18778: NOT
18779: IFFALSE 18813
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18781: LD_INT 7
18783: PPUSH
18784: LD_EXP 70
18788: PUSH
18789: LD_VAR 0 1
18793: ARRAY
18794: PUSH
18795: LD_INT 3
18797: ARRAY
18798: PPUSH
18799: LD_INT 0
18801: PPUSH
18802: LD_VAR 0 5
18806: PPUSH
18807: CALL_OW 468
18811: GO 18843
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18813: LD_INT 7
18815: PPUSH
18816: LD_EXP 70
18820: PUSH
18821: LD_VAR 0 1
18825: ARRAY
18826: PUSH
18827: LD_INT 1
18829: ARRAY
18830: PPUSH
18831: LD_INT 0
18833: PPUSH
18834: LD_VAR 0 5
18838: PPUSH
18839: CALL_OW 468
// end ; end else
18843: GO 18982
// begin if not artifactsLabs [ i ] then
18845: LD_EXP 69
18849: PUSH
18850: LD_VAR 0 1
18854: ARRAY
18855: NOT
18856: IFFALSE 18860
// continue ;
18858: GO 18086
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18860: LD_INT 7
18862: PPUSH
18863: LD_EXP 70
18867: PUSH
18868: LD_VAR 0 1
18872: ARRAY
18873: PUSH
18874: LD_INT 3
18876: ARRAY
18877: PPUSH
18878: LD_INT 0
18880: PPUSH
18881: LD_EXP 69
18885: PUSH
18886: LD_VAR 0 1
18890: ARRAY
18891: PPUSH
18892: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18896: LD_INT 7
18898: PPUSH
18899: LD_EXP 70
18903: PUSH
18904: LD_VAR 0 1
18908: ARRAY
18909: PUSH
18910: LD_INT 1
18912: ARRAY
18913: PPUSH
18914: LD_INT 0
18916: PPUSH
18917: LD_EXP 69
18921: PUSH
18922: LD_VAR 0 1
18926: ARRAY
18927: PPUSH
18928: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18932: LD_EXP 66
18936: PUSH
18937: LD_VAR 0 1
18941: ARRAY
18942: IFFALSE 18982
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18944: LD_ADDR_EXP 66
18948: PUSH
18949: LD_EXP 66
18953: PPUSH
18954: LD_VAR 0 1
18958: PPUSH
18959: LD_INT 0
18961: PPUSH
18962: CALL_OW 1
18966: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18967: LD_EXP 69
18971: PUSH
18972: LD_VAR 0 1
18976: ARRAY
18977: PPUSH
18978: CALL_OW 127
// end ; end ; end ;
18982: GO 18086
18984: POP
18985: POP
// end ;
18986: PPOPN 5
18988: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18989: LD_INT 0
18991: PPUSH
18992: PPUSH
18993: PPUSH
18994: PPUSH
18995: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18996: LD_VAR 0 2
19000: PUSH
19001: LD_EXP 70
19005: PUSH
19006: LD_INT 1
19008: ARRAY
19009: PUSH
19010: LD_INT 3
19012: ARRAY
19013: EQUAL
19014: IFFALSE 19137
// begin lab := artifactsLabs [ 1 ] ;
19016: LD_ADDR_VAR 0 6
19020: PUSH
19021: LD_EXP 69
19025: PUSH
19026: LD_INT 1
19028: ARRAY
19029: ST_TO_ADDR
// if not lab then
19030: LD_VAR 0 6
19034: NOT
19035: IFFALSE 19039
// exit ;
19037: GO 20117
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19039: LD_VAR 0 6
19043: PPUSH
19044: LD_EXP 67
19048: PUSH
19049: LD_INT 1
19051: ARRAY
19052: PPUSH
19053: LD_INT 1
19055: PPUSH
19056: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19060: LD_EXP 68
19064: PUSH
19065: LD_INT 1
19067: ARRAY
19068: IFFALSE 19088
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19070: LD_VAR 0 6
19074: PPUSH
19075: LD_EXP 68
19079: PUSH
19080: LD_INT 1
19082: ARRAY
19083: PPUSH
19084: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19088: LD_ADDR_EXP 66
19092: PUSH
19093: LD_EXP 66
19097: PPUSH
19098: LD_INT 1
19100: PPUSH
19101: LD_INT 1
19103: PPUSH
19104: CALL_OW 1
19108: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19109: LD_INT 7
19111: PPUSH
19112: LD_EXP 70
19116: PUSH
19117: LD_INT 1
19119: ARRAY
19120: PUSH
19121: LD_INT 3
19123: ARRAY
19124: PPUSH
19125: LD_INT 0
19127: PPUSH
19128: LD_VAR 0 6
19132: PPUSH
19133: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19137: LD_VAR 0 2
19141: PUSH
19142: LD_EXP 70
19146: PUSH
19147: LD_INT 2
19149: ARRAY
19150: PUSH
19151: LD_INT 3
19153: ARRAY
19154: EQUAL
19155: IFFALSE 19278
// begin lab := artifactsLabs [ 2 ] ;
19157: LD_ADDR_VAR 0 6
19161: PUSH
19162: LD_EXP 69
19166: PUSH
19167: LD_INT 2
19169: ARRAY
19170: ST_TO_ADDR
// if not lab then
19171: LD_VAR 0 6
19175: NOT
19176: IFFALSE 19180
// exit ;
19178: GO 20117
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19180: LD_VAR 0 6
19184: PPUSH
19185: LD_EXP 67
19189: PUSH
19190: LD_INT 2
19192: ARRAY
19193: PPUSH
19194: LD_INT 1
19196: PPUSH
19197: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19201: LD_EXP 68
19205: PUSH
19206: LD_INT 2
19208: ARRAY
19209: IFFALSE 19229
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19211: LD_VAR 0 6
19215: PPUSH
19216: LD_EXP 68
19220: PUSH
19221: LD_INT 2
19223: ARRAY
19224: PPUSH
19225: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19229: LD_ADDR_EXP 66
19233: PUSH
19234: LD_EXP 66
19238: PPUSH
19239: LD_INT 2
19241: PPUSH
19242: LD_INT 1
19244: PPUSH
19245: CALL_OW 1
19249: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19250: LD_INT 7
19252: PPUSH
19253: LD_EXP 70
19257: PUSH
19258: LD_INT 2
19260: ARRAY
19261: PUSH
19262: LD_INT 3
19264: ARRAY
19265: PPUSH
19266: LD_INT 0
19268: PPUSH
19269: LD_VAR 0 6
19273: PPUSH
19274: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19278: LD_VAR 0 2
19282: PUSH
19283: LD_EXP 70
19287: PUSH
19288: LD_INT 3
19290: ARRAY
19291: PUSH
19292: LD_INT 3
19294: ARRAY
19295: EQUAL
19296: IFFALSE 19419
// begin lab := artifactsLabs [ 3 ] ;
19298: LD_ADDR_VAR 0 6
19302: PUSH
19303: LD_EXP 69
19307: PUSH
19308: LD_INT 3
19310: ARRAY
19311: ST_TO_ADDR
// if not lab then
19312: LD_VAR 0 6
19316: NOT
19317: IFFALSE 19321
// exit ;
19319: GO 20117
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19321: LD_VAR 0 6
19325: PPUSH
19326: LD_EXP 67
19330: PUSH
19331: LD_INT 3
19333: ARRAY
19334: PPUSH
19335: LD_INT 1
19337: PPUSH
19338: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19342: LD_EXP 68
19346: PUSH
19347: LD_INT 3
19349: ARRAY
19350: IFFALSE 19370
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19352: LD_VAR 0 6
19356: PPUSH
19357: LD_EXP 68
19361: PUSH
19362: LD_INT 3
19364: ARRAY
19365: PPUSH
19366: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19370: LD_ADDR_EXP 66
19374: PUSH
19375: LD_EXP 66
19379: PPUSH
19380: LD_INT 3
19382: PPUSH
19383: LD_INT 1
19385: PPUSH
19386: CALL_OW 1
19390: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19391: LD_INT 7
19393: PPUSH
19394: LD_EXP 70
19398: PUSH
19399: LD_INT 3
19401: ARRAY
19402: PUSH
19403: LD_INT 3
19405: ARRAY
19406: PPUSH
19407: LD_INT 0
19409: PPUSH
19410: LD_VAR 0 6
19414: PPUSH
19415: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19419: LD_VAR 0 2
19423: PUSH
19424: LD_EXP 70
19428: PUSH
19429: LD_INT 1
19431: ARRAY
19432: PUSH
19433: LD_INT 1
19435: ARRAY
19436: EQUAL
19437: IFFALSE 19595
// begin lab := artifactsLabs [ 1 ] ;
19439: LD_ADDR_VAR 0 6
19443: PUSH
19444: LD_EXP 69
19448: PUSH
19449: LD_INT 1
19451: ARRAY
19452: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19453: LD_VAR 0 6
19457: PPUSH
19458: CALL_OW 274
19462: PPUSH
19463: CALL 86763 0 1
19467: PUSH
19468: LD_INT 3
19470: ARRAY
19471: PUSH
19472: LD_EXP 64
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: LESS
19481: IFFALSE 19495
// begin HintSpec ( ArtifactCost , 2 ) ;
19483: LD_STRING ArtifactCost
19485: PPUSH
19486: LD_INT 2
19488: PPUSH
19489: CALL_OW 338
// exit ;
19493: GO 20117
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19495: LD_ADDR_EXP 71
19499: PUSH
19500: LD_EXP 71
19504: PPUSH
19505: LD_INT 1
19507: PPUSH
19508: LD_INT 0
19510: PPUSH
19511: CALL_OW 1
19515: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19516: LD_VAR 0 3
19520: PPUSH
19521: LD_VAR 0 4
19525: PPUSH
19526: LD_INT 7
19528: PPUSH
19529: LD_INT 12
19531: NEG
19532: PPUSH
19533: CALL_OW 330
// wait ( 0 0$30 ) ;
19537: LD_INT 1050
19539: PPUSH
19540: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19544: LD_VAR 0 3
19548: PPUSH
19549: LD_VAR 0 4
19553: PPUSH
19554: LD_INT 7
19556: PPUSH
19557: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19561: LD_EXP 63
19565: PUSH
19566: LD_INT 1
19568: ARRAY
19569: PPUSH
19570: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19574: LD_ADDR_EXP 71
19578: PUSH
19579: LD_EXP 71
19583: PPUSH
19584: LD_INT 1
19586: PPUSH
19587: LD_INT 1
19589: PPUSH
19590: CALL_OW 1
19594: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19595: LD_VAR 0 2
19599: PUSH
19600: LD_EXP 70
19604: PUSH
19605: LD_INT 2
19607: ARRAY
19608: PUSH
19609: LD_INT 1
19611: ARRAY
19612: EQUAL
19613: IFFALSE 19850
// begin lab := artifactsLabs [ 2 ] ;
19615: LD_ADDR_VAR 0 6
19619: PUSH
19620: LD_EXP 69
19624: PUSH
19625: LD_INT 2
19627: ARRAY
19628: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19629: LD_VAR 0 3
19633: PUSH
19634: LD_INT 81
19636: PUSH
19637: LD_INT 7
19639: PUSH
19640: EMPTY
19641: LIST
19642: LIST
19643: PUSH
19644: LD_INT 2
19646: PUSH
19647: LD_INT 32
19649: PUSH
19650: LD_INT 3
19652: PUSH
19653: EMPTY
19654: LIST
19655: LIST
19656: PUSH
19657: LD_INT 30
19659: PUSH
19660: LD_INT 28
19662: PUSH
19663: EMPTY
19664: LIST
19665: LIST
19666: PUSH
19667: LD_INT 30
19669: PUSH
19670: LD_INT 30
19672: PUSH
19673: EMPTY
19674: LIST
19675: LIST
19676: PUSH
19677: LD_INT 35
19679: PUSH
19680: LD_INT 49
19682: PUSH
19683: EMPTY
19684: LIST
19685: LIST
19686: PUSH
19687: LD_INT 34
19689: PUSH
19690: LD_INT 49
19692: PUSH
19693: EMPTY
19694: LIST
19695: LIST
19696: PUSH
19697: LD_INT 30
19699: PUSH
19700: LD_INT 21
19702: PUSH
19703: EMPTY
19704: LIST
19705: LIST
19706: PUSH
19707: EMPTY
19708: LIST
19709: LIST
19710: LIST
19711: LIST
19712: LIST
19713: LIST
19714: LIST
19715: PUSH
19716: EMPTY
19717: LIST
19718: LIST
19719: PPUSH
19720: CALL_OW 69
19724: IN
19725: NOT
19726: IFFALSE 19730
// exit ;
19728: GO 20117
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19730: LD_VAR 0 6
19734: PPUSH
19735: CALL_OW 274
19739: PPUSH
19740: CALL 86763 0 1
19744: PUSH
19745: LD_INT 3
19747: ARRAY
19748: PUSH
19749: LD_EXP 64
19753: PUSH
19754: LD_INT 2
19756: ARRAY
19757: LESS
19758: IFFALSE 19772
// begin HintSpec ( ArtifactCost , 2 ) ;
19760: LD_STRING ArtifactCost
19762: PPUSH
19763: LD_INT 2
19765: PPUSH
19766: CALL_OW 338
// exit ;
19770: GO 20117
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19772: LD_ADDR_EXP 71
19776: PUSH
19777: LD_EXP 71
19781: PPUSH
19782: LD_INT 2
19784: PPUSH
19785: LD_INT 0
19787: PPUSH
19788: CALL_OW 1
19792: ST_TO_ADDR
// KillUnit ( x ) ;
19793: LD_VAR 0 3
19797: PPUSH
19798: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19802: LD_ADDR_EXP 16
19806: PUSH
19807: LD_EXP 16
19811: PUSH
19812: LD_INT 1
19814: PLUS
19815: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19816: LD_EXP 63
19820: PUSH
19821: LD_INT 2
19823: ARRAY
19824: PPUSH
19825: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19829: LD_ADDR_EXP 71
19833: PUSH
19834: LD_EXP 71
19838: PPUSH
19839: LD_INT 2
19841: PPUSH
19842: LD_INT 1
19844: PPUSH
19845: CALL_OW 1
19849: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19850: LD_VAR 0 2
19854: PUSH
19855: LD_EXP 70
19859: PUSH
19860: LD_INT 3
19862: ARRAY
19863: PUSH
19864: LD_INT 1
19866: ARRAY
19867: EQUAL
19868: IFFALSE 20117
// begin lab := artifactsLabs [ 3 ] ;
19870: LD_ADDR_VAR 0 6
19874: PUSH
19875: LD_EXP 69
19879: PUSH
19880: LD_INT 3
19882: ARRAY
19883: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19884: LD_VAR 0 6
19888: PPUSH
19889: CALL_OW 274
19893: PPUSH
19894: CALL 86763 0 1
19898: PUSH
19899: LD_INT 3
19901: ARRAY
19902: PUSH
19903: LD_EXP 64
19907: PUSH
19908: LD_INT 3
19910: ARRAY
19911: LESS
19912: IFFALSE 19926
// begin HintSpec ( ArtifactCost , 2 ) ;
19914: LD_STRING ArtifactCost
19916: PPUSH
19917: LD_INT 2
19919: PPUSH
19920: CALL_OW 338
// exit ;
19924: GO 20117
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19926: LD_INT 37
19928: PPUSH
19929: LD_INT 1
19931: PPUSH
19932: CALL_OW 424
// time := 0 0$30 ;
19936: LD_ADDR_VAR 0 7
19940: PUSH
19941: LD_INT 1050
19943: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
19944: LD_ADDR_EXP 71
19948: PUSH
19949: LD_EXP 71
19953: PPUSH
19954: LD_INT 3
19956: PPUSH
19957: LD_INT 0
19959: PPUSH
19960: CALL_OW 1
19964: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
19965: LD_ADDR_OWVAR 47
19969: PUSH
19970: LD_STRING #Am15a-1
19972: PUSH
19973: LD_VAR 0 7
19977: PUSH
19978: EMPTY
19979: LIST
19980: LIST
19981: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19982: LD_INT 35
19984: PPUSH
19985: CALL_OW 67
// time := time - 0 0$1 ;
19989: LD_ADDR_VAR 0 7
19993: PUSH
19994: LD_VAR 0 7
19998: PUSH
19999: LD_INT 35
20001: MINUS
20002: ST_TO_ADDR
// until time = 0 0$00 ;
20003: LD_VAR 0 7
20007: PUSH
20008: LD_INT 0
20010: EQUAL
20011: IFFALSE 19965
// display_strings :=  ;
20013: LD_ADDR_OWVAR 47
20017: PUSH
20018: LD_STRING 
20020: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20021: LD_INT 37
20023: PPUSH
20024: LD_INT 0
20026: PPUSH
20027: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20031: LD_ADDR_VAR 0 8
20035: PUSH
20036: LD_INT 37
20038: PPUSH
20039: LD_INT 3
20041: PUSH
20042: LD_INT 21
20044: PUSH
20045: LD_INT 3
20047: PUSH
20048: EMPTY
20049: LIST
20050: LIST
20051: PUSH
20052: EMPTY
20053: LIST
20054: LIST
20055: PPUSH
20056: CALL_OW 70
20060: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20061: LD_VAR 0 3
20065: PPUSH
20066: LD_VAR 0 4
20070: PPUSH
20071: CALL_OW 84
// for un in list do
20075: LD_ADDR_VAR 0 9
20079: PUSH
20080: LD_VAR 0 8
20084: PUSH
20085: FOR_IN
20086: IFFALSE 20115
// TeleportUnit ( un , x , y , 12 , true ) ;
20088: LD_VAR 0 9
20092: PPUSH
20093: LD_VAR 0 3
20097: PPUSH
20098: LD_VAR 0 4
20102: PPUSH
20103: LD_INT 12
20105: PPUSH
20106: LD_INT 1
20108: PPUSH
20109: CALL_OW 483
20113: GO 20085
20115: POP
20116: POP
// end ; end ;
20117: PPOPN 9
20119: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20120: LD_INT 0
20122: PPUSH
20123: PPUSH
// begin labNum := 0 ;
20124: LD_ADDR_VAR 0 4
20128: PUSH
20129: LD_INT 0
20131: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20132: LD_ADDR_VAR 0 3
20136: PUSH
20137: DOUBLE
20138: LD_INT 1
20140: DEC
20141: ST_TO_ADDR
20142: LD_EXP 69
20146: PUSH
20147: FOR_TO
20148: IFFALSE 20182
// if artifactsLabs [ i ] = lab then
20150: LD_EXP 69
20154: PUSH
20155: LD_VAR 0 3
20159: ARRAY
20160: PUSH
20161: LD_VAR 0 1
20165: EQUAL
20166: IFFALSE 20180
// begin labNum := i ;
20168: LD_ADDR_VAR 0 4
20172: PUSH
20173: LD_VAR 0 3
20177: ST_TO_ADDR
// break ;
20178: GO 20182
// end ;
20180: GO 20147
20182: POP
20183: POP
// if not labNum then
20184: LD_VAR 0 4
20188: NOT
20189: IFFALSE 20193
// exit ;
20191: GO 20271
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20193: LD_INT 7
20195: PPUSH
20196: LD_EXP 70
20200: PUSH
20201: LD_VAR 0 4
20205: ARRAY
20206: PUSH
20207: LD_INT 3
20209: ARRAY
20210: PPUSH
20211: LD_INT 2
20213: PPUSH
20214: LD_VAR 0 1
20218: PPUSH
20219: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20223: LD_ADDR_EXP 68
20227: PUSH
20228: LD_EXP 68
20232: PPUSH
20233: LD_VAR 0 4
20237: PPUSH
20238: LD_VAR 0 2
20242: PPUSH
20243: CALL_OW 1
20247: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20248: LD_ADDR_EXP 66
20252: PUSH
20253: LD_EXP 66
20257: PPUSH
20258: LD_VAR 0 4
20262: PPUSH
20263: LD_INT 0
20265: PPUSH
20266: CALL_OW 1
20270: ST_TO_ADDR
// end ;
20271: PPOPN 4
20273: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20274: LD_INT 0
20276: PPUSH
20277: PPUSH
// begin labNum := 0 ;
20278: LD_ADDR_VAR 0 3
20282: PUSH
20283: LD_INT 0
20285: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20286: LD_ADDR_VAR 0 2
20290: PUSH
20291: DOUBLE
20292: LD_INT 1
20294: DEC
20295: ST_TO_ADDR
20296: LD_EXP 69
20300: PUSH
20301: FOR_TO
20302: IFFALSE 20336
// if artifactsLabs [ i ] = lab then
20304: LD_EXP 69
20308: PUSH
20309: LD_VAR 0 2
20313: ARRAY
20314: PUSH
20315: LD_VAR 0 1
20319: EQUAL
20320: IFFALSE 20334
// begin labNum := i ;
20322: LD_ADDR_VAR 0 3
20326: PUSH
20327: LD_VAR 0 2
20331: ST_TO_ADDR
// break ;
20332: GO 20336
// end ;
20334: GO 20301
20336: POP
20337: POP
// if not labNum then
20338: LD_VAR 0 3
20342: NOT
20343: IFFALSE 20347
// exit ;
20345: GO 20509
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20347: LD_INT 7
20349: PPUSH
20350: LD_EXP 70
20354: PUSH
20355: LD_VAR 0 3
20359: ARRAY
20360: PUSH
20361: LD_INT 3
20363: ARRAY
20364: PPUSH
20365: LD_INT 0
20367: PPUSH
20368: LD_VAR 0 1
20372: PPUSH
20373: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20377: LD_ADDR_EXP 65
20381: PUSH
20382: LD_EXP 65
20386: PPUSH
20387: LD_VAR 0 3
20391: PPUSH
20392: LD_INT 1
20394: PPUSH
20395: CALL_OW 1
20399: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20400: LD_ADDR_EXP 71
20404: PUSH
20405: LD_EXP 71
20409: PPUSH
20410: LD_VAR 0 3
20414: PPUSH
20415: LD_INT 1
20417: PPUSH
20418: CALL_OW 1
20422: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20423: LD_ADDR_EXP 66
20427: PUSH
20428: LD_EXP 66
20432: PPUSH
20433: LD_VAR 0 3
20437: PPUSH
20438: LD_INT 0
20440: PPUSH
20441: CALL_OW 1
20445: ST_TO_ADDR
// case labNum of 1 :
20446: LD_VAR 0 3
20450: PUSH
20451: LD_INT 1
20453: DOUBLE
20454: EQUAL
20455: IFTRUE 20459
20457: GO 20470
20459: POP
// artifactIResearched := true ; 2 :
20460: LD_ADDR_EXP 12
20464: PUSH
20465: LD_INT 1
20467: ST_TO_ADDR
20468: GO 20509
20470: LD_INT 2
20472: DOUBLE
20473: EQUAL
20474: IFTRUE 20478
20476: GO 20489
20478: POP
// artifactIIResearched := true ; 3 :
20479: LD_ADDR_EXP 13
20483: PUSH
20484: LD_INT 1
20486: ST_TO_ADDR
20487: GO 20509
20489: LD_INT 3
20491: DOUBLE
20492: EQUAL
20493: IFTRUE 20497
20495: GO 20508
20497: POP
// artifactIIIResearched := true ; end ;
20498: LD_ADDR_EXP 14
20502: PUSH
20503: LD_INT 1
20505: ST_TO_ADDR
20506: GO 20509
20508: POP
// end ; end_of_file
20509: PPOPN 3
20511: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
20512: LD_INT 0
20514: PPUSH
// ru_radar := 98 ;
20515: LD_ADDR_EXP 72
20519: PUSH
20520: LD_INT 98
20522: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20523: LD_ADDR_EXP 73
20527: PUSH
20528: LD_INT 89
20530: ST_TO_ADDR
// us_hack := 99 ;
20531: LD_ADDR_EXP 74
20535: PUSH
20536: LD_INT 99
20538: ST_TO_ADDR
// us_artillery := 97 ;
20539: LD_ADDR_EXP 75
20543: PUSH
20544: LD_INT 97
20546: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20547: LD_ADDR_EXP 76
20551: PUSH
20552: LD_INT 91
20554: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
20555: LD_ADDR_EXP 77
20559: PUSH
20560: LD_INT 92
20562: ST_TO_ADDR
// tech_Artillery := 80 ;
20563: LD_ADDR_EXP 78
20567: PUSH
20568: LD_INT 80
20570: ST_TO_ADDR
// tech_RadMat := 81 ;
20571: LD_ADDR_EXP 79
20575: PUSH
20576: LD_INT 81
20578: ST_TO_ADDR
// tech_BasicTools := 82 ;
20579: LD_ADDR_EXP 80
20583: PUSH
20584: LD_INT 82
20586: ST_TO_ADDR
// tech_Cargo := 83 ;
20587: LD_ADDR_EXP 81
20591: PUSH
20592: LD_INT 83
20594: ST_TO_ADDR
// tech_Track := 84 ;
20595: LD_ADDR_EXP 82
20599: PUSH
20600: LD_INT 84
20602: ST_TO_ADDR
// tech_Crane := 85 ;
20603: LD_ADDR_EXP 83
20607: PUSH
20608: LD_INT 85
20610: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20611: LD_ADDR_EXP 84
20615: PUSH
20616: LD_INT 86
20618: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20619: LD_ADDR_EXP 85
20623: PUSH
20624: LD_INT 87
20626: ST_TO_ADDR
// end ;
20627: LD_VAR 0 1
20631: RET
// every 1 do
20632: GO 20634
20634: DISABLE
// InitGlobalVariables ; end_of_file
20635: CALL 20512 0 0
20639: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20640: LD_INT 0
20642: PPUSH
20643: PPUSH
// skirmish := false ;
20644: LD_ADDR_EXP 86
20648: PUSH
20649: LD_INT 0
20651: ST_TO_ADDR
// debug_mc := false ;
20652: LD_ADDR_EXP 87
20656: PUSH
20657: LD_INT 0
20659: ST_TO_ADDR
// mc_bases := [ ] ;
20660: LD_ADDR_EXP 88
20664: PUSH
20665: EMPTY
20666: ST_TO_ADDR
// mc_sides := [ ] ;
20667: LD_ADDR_EXP 114
20671: PUSH
20672: EMPTY
20673: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20674: LD_ADDR_EXP 89
20678: PUSH
20679: EMPTY
20680: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20681: LD_ADDR_EXP 90
20685: PUSH
20686: EMPTY
20687: ST_TO_ADDR
// mc_need_heal := [ ] ;
20688: LD_ADDR_EXP 91
20692: PUSH
20693: EMPTY
20694: ST_TO_ADDR
// mc_healers := [ ] ;
20695: LD_ADDR_EXP 92
20699: PUSH
20700: EMPTY
20701: ST_TO_ADDR
// mc_build_list := [ ] ;
20702: LD_ADDR_EXP 93
20706: PUSH
20707: EMPTY
20708: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20709: LD_ADDR_EXP 120
20713: PUSH
20714: EMPTY
20715: ST_TO_ADDR
// mc_builders := [ ] ;
20716: LD_ADDR_EXP 94
20720: PUSH
20721: EMPTY
20722: ST_TO_ADDR
// mc_construct_list := [ ] ;
20723: LD_ADDR_EXP 95
20727: PUSH
20728: EMPTY
20729: ST_TO_ADDR
// mc_turret_list := [ ] ;
20730: LD_ADDR_EXP 96
20734: PUSH
20735: EMPTY
20736: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20737: LD_ADDR_EXP 97
20741: PUSH
20742: EMPTY
20743: ST_TO_ADDR
// mc_miners := [ ] ;
20744: LD_ADDR_EXP 102
20748: PUSH
20749: EMPTY
20750: ST_TO_ADDR
// mc_mines := [ ] ;
20751: LD_ADDR_EXP 101
20755: PUSH
20756: EMPTY
20757: ST_TO_ADDR
// mc_minefields := [ ] ;
20758: LD_ADDR_EXP 103
20762: PUSH
20763: EMPTY
20764: ST_TO_ADDR
// mc_crates := [ ] ;
20765: LD_ADDR_EXP 104
20769: PUSH
20770: EMPTY
20771: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20772: LD_ADDR_EXP 105
20776: PUSH
20777: EMPTY
20778: ST_TO_ADDR
// mc_crates_area := [ ] ;
20779: LD_ADDR_EXP 106
20783: PUSH
20784: EMPTY
20785: ST_TO_ADDR
// mc_vehicles := [ ] ;
20786: LD_ADDR_EXP 107
20790: PUSH
20791: EMPTY
20792: ST_TO_ADDR
// mc_attack := [ ] ;
20793: LD_ADDR_EXP 108
20797: PUSH
20798: EMPTY
20799: ST_TO_ADDR
// mc_produce := [ ] ;
20800: LD_ADDR_EXP 109
20804: PUSH
20805: EMPTY
20806: ST_TO_ADDR
// mc_defender := [ ] ;
20807: LD_ADDR_EXP 110
20811: PUSH
20812: EMPTY
20813: ST_TO_ADDR
// mc_parking := [ ] ;
20814: LD_ADDR_EXP 112
20818: PUSH
20819: EMPTY
20820: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20821: LD_ADDR_EXP 98
20825: PUSH
20826: EMPTY
20827: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20828: LD_ADDR_EXP 100
20832: PUSH
20833: EMPTY
20834: ST_TO_ADDR
// mc_scan := [ ] ;
20835: LD_ADDR_EXP 111
20839: PUSH
20840: EMPTY
20841: ST_TO_ADDR
// mc_scan_area := [ ] ;
20842: LD_ADDR_EXP 113
20846: PUSH
20847: EMPTY
20848: ST_TO_ADDR
// mc_tech := [ ] ;
20849: LD_ADDR_EXP 115
20853: PUSH
20854: EMPTY
20855: ST_TO_ADDR
// mc_class := [ ] ;
20856: LD_ADDR_EXP 129
20860: PUSH
20861: EMPTY
20862: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20863: LD_ADDR_EXP 130
20867: PUSH
20868: EMPTY
20869: ST_TO_ADDR
// end ;
20870: LD_VAR 0 1
20874: RET
// export function MC_Kill ( base ) ; begin
20875: LD_INT 0
20877: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20878: LD_ADDR_EXP 88
20882: PUSH
20883: LD_EXP 88
20887: PPUSH
20888: LD_VAR 0 1
20892: PPUSH
20893: EMPTY
20894: PPUSH
20895: CALL_OW 1
20899: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20900: LD_ADDR_EXP 89
20904: PUSH
20905: LD_EXP 89
20909: PPUSH
20910: LD_VAR 0 1
20914: PPUSH
20915: EMPTY
20916: PPUSH
20917: CALL_OW 1
20921: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20922: LD_ADDR_EXP 90
20926: PUSH
20927: LD_EXP 90
20931: PPUSH
20932: LD_VAR 0 1
20936: PPUSH
20937: EMPTY
20938: PPUSH
20939: CALL_OW 1
20943: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20944: LD_ADDR_EXP 91
20948: PUSH
20949: LD_EXP 91
20953: PPUSH
20954: LD_VAR 0 1
20958: PPUSH
20959: EMPTY
20960: PPUSH
20961: CALL_OW 1
20965: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20966: LD_ADDR_EXP 92
20970: PUSH
20971: LD_EXP 92
20975: PPUSH
20976: LD_VAR 0 1
20980: PPUSH
20981: EMPTY
20982: PPUSH
20983: CALL_OW 1
20987: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20988: LD_ADDR_EXP 93
20992: PUSH
20993: LD_EXP 93
20997: PPUSH
20998: LD_VAR 0 1
21002: PPUSH
21003: EMPTY
21004: PPUSH
21005: CALL_OW 1
21009: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21010: LD_ADDR_EXP 94
21014: PUSH
21015: LD_EXP 94
21019: PPUSH
21020: LD_VAR 0 1
21024: PPUSH
21025: EMPTY
21026: PPUSH
21027: CALL_OW 1
21031: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21032: LD_ADDR_EXP 95
21036: PUSH
21037: LD_EXP 95
21041: PPUSH
21042: LD_VAR 0 1
21046: PPUSH
21047: EMPTY
21048: PPUSH
21049: CALL_OW 1
21053: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21054: LD_ADDR_EXP 96
21058: PUSH
21059: LD_EXP 96
21063: PPUSH
21064: LD_VAR 0 1
21068: PPUSH
21069: EMPTY
21070: PPUSH
21071: CALL_OW 1
21075: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21076: LD_ADDR_EXP 97
21080: PUSH
21081: LD_EXP 97
21085: PPUSH
21086: LD_VAR 0 1
21090: PPUSH
21091: EMPTY
21092: PPUSH
21093: CALL_OW 1
21097: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21098: LD_ADDR_EXP 98
21102: PUSH
21103: LD_EXP 98
21107: PPUSH
21108: LD_VAR 0 1
21112: PPUSH
21113: EMPTY
21114: PPUSH
21115: CALL_OW 1
21119: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21120: LD_ADDR_EXP 99
21124: PUSH
21125: LD_EXP 99
21129: PPUSH
21130: LD_VAR 0 1
21134: PPUSH
21135: LD_INT 0
21137: PPUSH
21138: CALL_OW 1
21142: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21143: LD_ADDR_EXP 100
21147: PUSH
21148: LD_EXP 100
21152: PPUSH
21153: LD_VAR 0 1
21157: PPUSH
21158: EMPTY
21159: PPUSH
21160: CALL_OW 1
21164: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21165: LD_ADDR_EXP 101
21169: PUSH
21170: LD_EXP 101
21174: PPUSH
21175: LD_VAR 0 1
21179: PPUSH
21180: EMPTY
21181: PPUSH
21182: CALL_OW 1
21186: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21187: LD_ADDR_EXP 102
21191: PUSH
21192: LD_EXP 102
21196: PPUSH
21197: LD_VAR 0 1
21201: PPUSH
21202: EMPTY
21203: PPUSH
21204: CALL_OW 1
21208: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21209: LD_ADDR_EXP 103
21213: PUSH
21214: LD_EXP 103
21218: PPUSH
21219: LD_VAR 0 1
21223: PPUSH
21224: EMPTY
21225: PPUSH
21226: CALL_OW 1
21230: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21231: LD_ADDR_EXP 104
21235: PUSH
21236: LD_EXP 104
21240: PPUSH
21241: LD_VAR 0 1
21245: PPUSH
21246: EMPTY
21247: PPUSH
21248: CALL_OW 1
21252: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21253: LD_ADDR_EXP 105
21257: PUSH
21258: LD_EXP 105
21262: PPUSH
21263: LD_VAR 0 1
21267: PPUSH
21268: EMPTY
21269: PPUSH
21270: CALL_OW 1
21274: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21275: LD_ADDR_EXP 106
21279: PUSH
21280: LD_EXP 106
21284: PPUSH
21285: LD_VAR 0 1
21289: PPUSH
21290: EMPTY
21291: PPUSH
21292: CALL_OW 1
21296: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21297: LD_ADDR_EXP 107
21301: PUSH
21302: LD_EXP 107
21306: PPUSH
21307: LD_VAR 0 1
21311: PPUSH
21312: EMPTY
21313: PPUSH
21314: CALL_OW 1
21318: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21319: LD_ADDR_EXP 108
21323: PUSH
21324: LD_EXP 108
21328: PPUSH
21329: LD_VAR 0 1
21333: PPUSH
21334: EMPTY
21335: PPUSH
21336: CALL_OW 1
21340: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21341: LD_ADDR_EXP 109
21345: PUSH
21346: LD_EXP 109
21350: PPUSH
21351: LD_VAR 0 1
21355: PPUSH
21356: EMPTY
21357: PPUSH
21358: CALL_OW 1
21362: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21363: LD_ADDR_EXP 110
21367: PUSH
21368: LD_EXP 110
21372: PPUSH
21373: LD_VAR 0 1
21377: PPUSH
21378: EMPTY
21379: PPUSH
21380: CALL_OW 1
21384: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21385: LD_ADDR_EXP 111
21389: PUSH
21390: LD_EXP 111
21394: PPUSH
21395: LD_VAR 0 1
21399: PPUSH
21400: EMPTY
21401: PPUSH
21402: CALL_OW 1
21406: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21407: LD_ADDR_EXP 112
21411: PUSH
21412: LD_EXP 112
21416: PPUSH
21417: LD_VAR 0 1
21421: PPUSH
21422: EMPTY
21423: PPUSH
21424: CALL_OW 1
21428: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21429: LD_ADDR_EXP 113
21433: PUSH
21434: LD_EXP 113
21438: PPUSH
21439: LD_VAR 0 1
21443: PPUSH
21444: EMPTY
21445: PPUSH
21446: CALL_OW 1
21450: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21451: LD_ADDR_EXP 115
21455: PUSH
21456: LD_EXP 115
21460: PPUSH
21461: LD_VAR 0 1
21465: PPUSH
21466: EMPTY
21467: PPUSH
21468: CALL_OW 1
21472: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21473: LD_ADDR_EXP 117
21477: PUSH
21478: LD_EXP 117
21482: PPUSH
21483: LD_VAR 0 1
21487: PPUSH
21488: EMPTY
21489: PPUSH
21490: CALL_OW 1
21494: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21495: LD_ADDR_EXP 118
21499: PUSH
21500: LD_EXP 118
21504: PPUSH
21505: LD_VAR 0 1
21509: PPUSH
21510: EMPTY
21511: PPUSH
21512: CALL_OW 1
21516: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21517: LD_ADDR_EXP 119
21521: PUSH
21522: LD_EXP 119
21526: PPUSH
21527: LD_VAR 0 1
21531: PPUSH
21532: EMPTY
21533: PPUSH
21534: CALL_OW 1
21538: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21539: LD_ADDR_EXP 120
21543: PUSH
21544: LD_EXP 120
21548: PPUSH
21549: LD_VAR 0 1
21553: PPUSH
21554: EMPTY
21555: PPUSH
21556: CALL_OW 1
21560: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21561: LD_ADDR_EXP 121
21565: PUSH
21566: LD_EXP 121
21570: PPUSH
21571: LD_VAR 0 1
21575: PPUSH
21576: EMPTY
21577: PPUSH
21578: CALL_OW 1
21582: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21583: LD_ADDR_EXP 122
21587: PUSH
21588: LD_EXP 122
21592: PPUSH
21593: LD_VAR 0 1
21597: PPUSH
21598: EMPTY
21599: PPUSH
21600: CALL_OW 1
21604: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21605: LD_ADDR_EXP 123
21609: PUSH
21610: LD_EXP 123
21614: PPUSH
21615: LD_VAR 0 1
21619: PPUSH
21620: EMPTY
21621: PPUSH
21622: CALL_OW 1
21626: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21627: LD_ADDR_EXP 124
21631: PUSH
21632: LD_EXP 124
21636: PPUSH
21637: LD_VAR 0 1
21641: PPUSH
21642: EMPTY
21643: PPUSH
21644: CALL_OW 1
21648: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21649: LD_ADDR_EXP 125
21653: PUSH
21654: LD_EXP 125
21658: PPUSH
21659: LD_VAR 0 1
21663: PPUSH
21664: EMPTY
21665: PPUSH
21666: CALL_OW 1
21670: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21671: LD_ADDR_EXP 126
21675: PUSH
21676: LD_EXP 126
21680: PPUSH
21681: LD_VAR 0 1
21685: PPUSH
21686: EMPTY
21687: PPUSH
21688: CALL_OW 1
21692: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21693: LD_ADDR_EXP 127
21697: PUSH
21698: LD_EXP 127
21702: PPUSH
21703: LD_VAR 0 1
21707: PPUSH
21708: EMPTY
21709: PPUSH
21710: CALL_OW 1
21714: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21715: LD_ADDR_EXP 128
21719: PUSH
21720: LD_EXP 128
21724: PPUSH
21725: LD_VAR 0 1
21729: PPUSH
21730: EMPTY
21731: PPUSH
21732: CALL_OW 1
21736: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21737: LD_ADDR_EXP 129
21741: PUSH
21742: LD_EXP 129
21746: PPUSH
21747: LD_VAR 0 1
21751: PPUSH
21752: EMPTY
21753: PPUSH
21754: CALL_OW 1
21758: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21759: LD_ADDR_EXP 130
21763: PUSH
21764: LD_EXP 130
21768: PPUSH
21769: LD_VAR 0 1
21773: PPUSH
21774: LD_INT 0
21776: PPUSH
21777: CALL_OW 1
21781: ST_TO_ADDR
// end ;
21782: LD_VAR 0 2
21786: RET
// export function MC_Add ( side , units ) ; var base ; begin
21787: LD_INT 0
21789: PPUSH
21790: PPUSH
// base := mc_bases + 1 ;
21791: LD_ADDR_VAR 0 4
21795: PUSH
21796: LD_EXP 88
21800: PUSH
21801: LD_INT 1
21803: PLUS
21804: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21805: LD_ADDR_EXP 114
21809: PUSH
21810: LD_EXP 114
21814: PPUSH
21815: LD_VAR 0 4
21819: PPUSH
21820: LD_VAR 0 1
21824: PPUSH
21825: CALL_OW 1
21829: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21830: LD_ADDR_EXP 88
21834: PUSH
21835: LD_EXP 88
21839: PPUSH
21840: LD_VAR 0 4
21844: PPUSH
21845: LD_VAR 0 2
21849: PPUSH
21850: CALL_OW 1
21854: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21855: LD_ADDR_EXP 89
21859: PUSH
21860: LD_EXP 89
21864: PPUSH
21865: LD_VAR 0 4
21869: PPUSH
21870: EMPTY
21871: PPUSH
21872: CALL_OW 1
21876: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21877: LD_ADDR_EXP 90
21881: PUSH
21882: LD_EXP 90
21886: PPUSH
21887: LD_VAR 0 4
21891: PPUSH
21892: EMPTY
21893: PPUSH
21894: CALL_OW 1
21898: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21899: LD_ADDR_EXP 91
21903: PUSH
21904: LD_EXP 91
21908: PPUSH
21909: LD_VAR 0 4
21913: PPUSH
21914: EMPTY
21915: PPUSH
21916: CALL_OW 1
21920: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21921: LD_ADDR_EXP 92
21925: PUSH
21926: LD_EXP 92
21930: PPUSH
21931: LD_VAR 0 4
21935: PPUSH
21936: EMPTY
21937: PPUSH
21938: CALL_OW 1
21942: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21943: LD_ADDR_EXP 93
21947: PUSH
21948: LD_EXP 93
21952: PPUSH
21953: LD_VAR 0 4
21957: PPUSH
21958: EMPTY
21959: PPUSH
21960: CALL_OW 1
21964: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21965: LD_ADDR_EXP 94
21969: PUSH
21970: LD_EXP 94
21974: PPUSH
21975: LD_VAR 0 4
21979: PPUSH
21980: EMPTY
21981: PPUSH
21982: CALL_OW 1
21986: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21987: LD_ADDR_EXP 95
21991: PUSH
21992: LD_EXP 95
21996: PPUSH
21997: LD_VAR 0 4
22001: PPUSH
22002: EMPTY
22003: PPUSH
22004: CALL_OW 1
22008: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22009: LD_ADDR_EXP 96
22013: PUSH
22014: LD_EXP 96
22018: PPUSH
22019: LD_VAR 0 4
22023: PPUSH
22024: EMPTY
22025: PPUSH
22026: CALL_OW 1
22030: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22031: LD_ADDR_EXP 97
22035: PUSH
22036: LD_EXP 97
22040: PPUSH
22041: LD_VAR 0 4
22045: PPUSH
22046: EMPTY
22047: PPUSH
22048: CALL_OW 1
22052: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22053: LD_ADDR_EXP 98
22057: PUSH
22058: LD_EXP 98
22062: PPUSH
22063: LD_VAR 0 4
22067: PPUSH
22068: EMPTY
22069: PPUSH
22070: CALL_OW 1
22074: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22075: LD_ADDR_EXP 99
22079: PUSH
22080: LD_EXP 99
22084: PPUSH
22085: LD_VAR 0 4
22089: PPUSH
22090: LD_INT 0
22092: PPUSH
22093: CALL_OW 1
22097: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22098: LD_ADDR_EXP 100
22102: PUSH
22103: LD_EXP 100
22107: PPUSH
22108: LD_VAR 0 4
22112: PPUSH
22113: EMPTY
22114: PPUSH
22115: CALL_OW 1
22119: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22120: LD_ADDR_EXP 101
22124: PUSH
22125: LD_EXP 101
22129: PPUSH
22130: LD_VAR 0 4
22134: PPUSH
22135: EMPTY
22136: PPUSH
22137: CALL_OW 1
22141: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22142: LD_ADDR_EXP 102
22146: PUSH
22147: LD_EXP 102
22151: PPUSH
22152: LD_VAR 0 4
22156: PPUSH
22157: EMPTY
22158: PPUSH
22159: CALL_OW 1
22163: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22164: LD_ADDR_EXP 103
22168: PUSH
22169: LD_EXP 103
22173: PPUSH
22174: LD_VAR 0 4
22178: PPUSH
22179: EMPTY
22180: PPUSH
22181: CALL_OW 1
22185: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22186: LD_ADDR_EXP 104
22190: PUSH
22191: LD_EXP 104
22195: PPUSH
22196: LD_VAR 0 4
22200: PPUSH
22201: EMPTY
22202: PPUSH
22203: CALL_OW 1
22207: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22208: LD_ADDR_EXP 105
22212: PUSH
22213: LD_EXP 105
22217: PPUSH
22218: LD_VAR 0 4
22222: PPUSH
22223: EMPTY
22224: PPUSH
22225: CALL_OW 1
22229: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22230: LD_ADDR_EXP 106
22234: PUSH
22235: LD_EXP 106
22239: PPUSH
22240: LD_VAR 0 4
22244: PPUSH
22245: EMPTY
22246: PPUSH
22247: CALL_OW 1
22251: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22252: LD_ADDR_EXP 107
22256: PUSH
22257: LD_EXP 107
22261: PPUSH
22262: LD_VAR 0 4
22266: PPUSH
22267: EMPTY
22268: PPUSH
22269: CALL_OW 1
22273: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22274: LD_ADDR_EXP 108
22278: PUSH
22279: LD_EXP 108
22283: PPUSH
22284: LD_VAR 0 4
22288: PPUSH
22289: EMPTY
22290: PPUSH
22291: CALL_OW 1
22295: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22296: LD_ADDR_EXP 109
22300: PUSH
22301: LD_EXP 109
22305: PPUSH
22306: LD_VAR 0 4
22310: PPUSH
22311: EMPTY
22312: PPUSH
22313: CALL_OW 1
22317: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22318: LD_ADDR_EXP 110
22322: PUSH
22323: LD_EXP 110
22327: PPUSH
22328: LD_VAR 0 4
22332: PPUSH
22333: EMPTY
22334: PPUSH
22335: CALL_OW 1
22339: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22340: LD_ADDR_EXP 111
22344: PUSH
22345: LD_EXP 111
22349: PPUSH
22350: LD_VAR 0 4
22354: PPUSH
22355: EMPTY
22356: PPUSH
22357: CALL_OW 1
22361: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22362: LD_ADDR_EXP 112
22366: PUSH
22367: LD_EXP 112
22371: PPUSH
22372: LD_VAR 0 4
22376: PPUSH
22377: EMPTY
22378: PPUSH
22379: CALL_OW 1
22383: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22384: LD_ADDR_EXP 113
22388: PUSH
22389: LD_EXP 113
22393: PPUSH
22394: LD_VAR 0 4
22398: PPUSH
22399: EMPTY
22400: PPUSH
22401: CALL_OW 1
22405: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22406: LD_ADDR_EXP 115
22410: PUSH
22411: LD_EXP 115
22415: PPUSH
22416: LD_VAR 0 4
22420: PPUSH
22421: EMPTY
22422: PPUSH
22423: CALL_OW 1
22427: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22428: LD_ADDR_EXP 117
22432: PUSH
22433: LD_EXP 117
22437: PPUSH
22438: LD_VAR 0 4
22442: PPUSH
22443: EMPTY
22444: PPUSH
22445: CALL_OW 1
22449: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22450: LD_ADDR_EXP 118
22454: PUSH
22455: LD_EXP 118
22459: PPUSH
22460: LD_VAR 0 4
22464: PPUSH
22465: EMPTY
22466: PPUSH
22467: CALL_OW 1
22471: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22472: LD_ADDR_EXP 119
22476: PUSH
22477: LD_EXP 119
22481: PPUSH
22482: LD_VAR 0 4
22486: PPUSH
22487: EMPTY
22488: PPUSH
22489: CALL_OW 1
22493: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22494: LD_ADDR_EXP 120
22498: PUSH
22499: LD_EXP 120
22503: PPUSH
22504: LD_VAR 0 4
22508: PPUSH
22509: EMPTY
22510: PPUSH
22511: CALL_OW 1
22515: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22516: LD_ADDR_EXP 121
22520: PUSH
22521: LD_EXP 121
22525: PPUSH
22526: LD_VAR 0 4
22530: PPUSH
22531: EMPTY
22532: PPUSH
22533: CALL_OW 1
22537: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22538: LD_ADDR_EXP 122
22542: PUSH
22543: LD_EXP 122
22547: PPUSH
22548: LD_VAR 0 4
22552: PPUSH
22553: EMPTY
22554: PPUSH
22555: CALL_OW 1
22559: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22560: LD_ADDR_EXP 123
22564: PUSH
22565: LD_EXP 123
22569: PPUSH
22570: LD_VAR 0 4
22574: PPUSH
22575: EMPTY
22576: PPUSH
22577: CALL_OW 1
22581: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22582: LD_ADDR_EXP 124
22586: PUSH
22587: LD_EXP 124
22591: PPUSH
22592: LD_VAR 0 4
22596: PPUSH
22597: EMPTY
22598: PPUSH
22599: CALL_OW 1
22603: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22604: LD_ADDR_EXP 125
22608: PUSH
22609: LD_EXP 125
22613: PPUSH
22614: LD_VAR 0 4
22618: PPUSH
22619: EMPTY
22620: PPUSH
22621: CALL_OW 1
22625: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22626: LD_ADDR_EXP 126
22630: PUSH
22631: LD_EXP 126
22635: PPUSH
22636: LD_VAR 0 4
22640: PPUSH
22641: EMPTY
22642: PPUSH
22643: CALL_OW 1
22647: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22648: LD_ADDR_EXP 127
22652: PUSH
22653: LD_EXP 127
22657: PPUSH
22658: LD_VAR 0 4
22662: PPUSH
22663: EMPTY
22664: PPUSH
22665: CALL_OW 1
22669: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22670: LD_ADDR_EXP 128
22674: PUSH
22675: LD_EXP 128
22679: PPUSH
22680: LD_VAR 0 4
22684: PPUSH
22685: EMPTY
22686: PPUSH
22687: CALL_OW 1
22691: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22692: LD_ADDR_EXP 129
22696: PUSH
22697: LD_EXP 129
22701: PPUSH
22702: LD_VAR 0 4
22706: PPUSH
22707: EMPTY
22708: PPUSH
22709: CALL_OW 1
22713: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22714: LD_ADDR_EXP 130
22718: PUSH
22719: LD_EXP 130
22723: PPUSH
22724: LD_VAR 0 4
22728: PPUSH
22729: LD_INT 0
22731: PPUSH
22732: CALL_OW 1
22736: ST_TO_ADDR
// result := base ;
22737: LD_ADDR_VAR 0 3
22741: PUSH
22742: LD_VAR 0 4
22746: ST_TO_ADDR
// end ;
22747: LD_VAR 0 3
22751: RET
// export function MC_Start ( ) ; var i ; begin
22752: LD_INT 0
22754: PPUSH
22755: PPUSH
// for i = 1 to mc_bases do
22756: LD_ADDR_VAR 0 2
22760: PUSH
22761: DOUBLE
22762: LD_INT 1
22764: DEC
22765: ST_TO_ADDR
22766: LD_EXP 88
22770: PUSH
22771: FOR_TO
22772: IFFALSE 23849
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22774: LD_ADDR_EXP 88
22778: PUSH
22779: LD_EXP 88
22783: PPUSH
22784: LD_VAR 0 2
22788: PPUSH
22789: LD_EXP 88
22793: PUSH
22794: LD_VAR 0 2
22798: ARRAY
22799: PUSH
22800: LD_INT 0
22802: DIFF
22803: PPUSH
22804: CALL_OW 1
22808: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22809: LD_ADDR_EXP 89
22813: PUSH
22814: LD_EXP 89
22818: PPUSH
22819: LD_VAR 0 2
22823: PPUSH
22824: EMPTY
22825: PPUSH
22826: CALL_OW 1
22830: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22831: LD_ADDR_EXP 90
22835: PUSH
22836: LD_EXP 90
22840: PPUSH
22841: LD_VAR 0 2
22845: PPUSH
22846: EMPTY
22847: PPUSH
22848: CALL_OW 1
22852: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22853: LD_ADDR_EXP 91
22857: PUSH
22858: LD_EXP 91
22862: PPUSH
22863: LD_VAR 0 2
22867: PPUSH
22868: EMPTY
22869: PPUSH
22870: CALL_OW 1
22874: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22875: LD_ADDR_EXP 92
22879: PUSH
22880: LD_EXP 92
22884: PPUSH
22885: LD_VAR 0 2
22889: PPUSH
22890: EMPTY
22891: PUSH
22892: EMPTY
22893: PUSH
22894: EMPTY
22895: LIST
22896: LIST
22897: PPUSH
22898: CALL_OW 1
22902: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22903: LD_ADDR_EXP 93
22907: PUSH
22908: LD_EXP 93
22912: PPUSH
22913: LD_VAR 0 2
22917: PPUSH
22918: EMPTY
22919: PPUSH
22920: CALL_OW 1
22924: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22925: LD_ADDR_EXP 120
22929: PUSH
22930: LD_EXP 120
22934: PPUSH
22935: LD_VAR 0 2
22939: PPUSH
22940: EMPTY
22941: PPUSH
22942: CALL_OW 1
22946: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22947: LD_ADDR_EXP 94
22951: PUSH
22952: LD_EXP 94
22956: PPUSH
22957: LD_VAR 0 2
22961: PPUSH
22962: EMPTY
22963: PPUSH
22964: CALL_OW 1
22968: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22969: LD_ADDR_EXP 95
22973: PUSH
22974: LD_EXP 95
22978: PPUSH
22979: LD_VAR 0 2
22983: PPUSH
22984: EMPTY
22985: PPUSH
22986: CALL_OW 1
22990: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22991: LD_ADDR_EXP 96
22995: PUSH
22996: LD_EXP 96
23000: PPUSH
23001: LD_VAR 0 2
23005: PPUSH
23006: LD_EXP 88
23010: PUSH
23011: LD_VAR 0 2
23015: ARRAY
23016: PPUSH
23017: LD_INT 2
23019: PUSH
23020: LD_INT 30
23022: PUSH
23023: LD_INT 32
23025: PUSH
23026: EMPTY
23027: LIST
23028: LIST
23029: PUSH
23030: LD_INT 30
23032: PUSH
23033: LD_INT 33
23035: PUSH
23036: EMPTY
23037: LIST
23038: LIST
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: LIST
23044: PPUSH
23045: CALL_OW 72
23049: PPUSH
23050: CALL_OW 1
23054: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23055: LD_ADDR_EXP 97
23059: PUSH
23060: LD_EXP 97
23064: PPUSH
23065: LD_VAR 0 2
23069: PPUSH
23070: LD_EXP 88
23074: PUSH
23075: LD_VAR 0 2
23079: ARRAY
23080: PPUSH
23081: LD_INT 2
23083: PUSH
23084: LD_INT 30
23086: PUSH
23087: LD_INT 32
23089: PUSH
23090: EMPTY
23091: LIST
23092: LIST
23093: PUSH
23094: LD_INT 30
23096: PUSH
23097: LD_INT 31
23099: PUSH
23100: EMPTY
23101: LIST
23102: LIST
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: LIST
23108: PUSH
23109: LD_INT 58
23111: PUSH
23112: EMPTY
23113: LIST
23114: PUSH
23115: EMPTY
23116: LIST
23117: LIST
23118: PPUSH
23119: CALL_OW 72
23123: PPUSH
23124: CALL_OW 1
23128: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23129: LD_ADDR_EXP 98
23133: PUSH
23134: LD_EXP 98
23138: PPUSH
23139: LD_VAR 0 2
23143: PPUSH
23144: EMPTY
23145: PPUSH
23146: CALL_OW 1
23150: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23151: LD_ADDR_EXP 102
23155: PUSH
23156: LD_EXP 102
23160: PPUSH
23161: LD_VAR 0 2
23165: PPUSH
23166: EMPTY
23167: PPUSH
23168: CALL_OW 1
23172: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23173: LD_ADDR_EXP 101
23177: PUSH
23178: LD_EXP 101
23182: PPUSH
23183: LD_VAR 0 2
23187: PPUSH
23188: EMPTY
23189: PPUSH
23190: CALL_OW 1
23194: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23195: LD_ADDR_EXP 103
23199: PUSH
23200: LD_EXP 103
23204: PPUSH
23205: LD_VAR 0 2
23209: PPUSH
23210: EMPTY
23211: PPUSH
23212: CALL_OW 1
23216: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23217: LD_ADDR_EXP 104
23221: PUSH
23222: LD_EXP 104
23226: PPUSH
23227: LD_VAR 0 2
23231: PPUSH
23232: EMPTY
23233: PPUSH
23234: CALL_OW 1
23238: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23239: LD_ADDR_EXP 105
23243: PUSH
23244: LD_EXP 105
23248: PPUSH
23249: LD_VAR 0 2
23253: PPUSH
23254: EMPTY
23255: PPUSH
23256: CALL_OW 1
23260: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23261: LD_ADDR_EXP 106
23265: PUSH
23266: LD_EXP 106
23270: PPUSH
23271: LD_VAR 0 2
23275: PPUSH
23276: EMPTY
23277: PPUSH
23278: CALL_OW 1
23282: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23283: LD_ADDR_EXP 107
23287: PUSH
23288: LD_EXP 107
23292: PPUSH
23293: LD_VAR 0 2
23297: PPUSH
23298: EMPTY
23299: PPUSH
23300: CALL_OW 1
23304: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23305: LD_ADDR_EXP 108
23309: PUSH
23310: LD_EXP 108
23314: PPUSH
23315: LD_VAR 0 2
23319: PPUSH
23320: EMPTY
23321: PPUSH
23322: CALL_OW 1
23326: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23327: LD_ADDR_EXP 109
23331: PUSH
23332: LD_EXP 109
23336: PPUSH
23337: LD_VAR 0 2
23341: PPUSH
23342: EMPTY
23343: PPUSH
23344: CALL_OW 1
23348: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23349: LD_ADDR_EXP 110
23353: PUSH
23354: LD_EXP 110
23358: PPUSH
23359: LD_VAR 0 2
23363: PPUSH
23364: EMPTY
23365: PPUSH
23366: CALL_OW 1
23370: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23371: LD_ADDR_EXP 99
23375: PUSH
23376: LD_EXP 99
23380: PPUSH
23381: LD_VAR 0 2
23385: PPUSH
23386: LD_INT 0
23388: PPUSH
23389: CALL_OW 1
23393: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23394: LD_ADDR_EXP 112
23398: PUSH
23399: LD_EXP 112
23403: PPUSH
23404: LD_VAR 0 2
23408: PPUSH
23409: LD_INT 0
23411: PPUSH
23412: CALL_OW 1
23416: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23417: LD_ADDR_EXP 100
23421: PUSH
23422: LD_EXP 100
23426: PPUSH
23427: LD_VAR 0 2
23431: PPUSH
23432: EMPTY
23433: PPUSH
23434: CALL_OW 1
23438: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23439: LD_ADDR_EXP 111
23443: PUSH
23444: LD_EXP 111
23448: PPUSH
23449: LD_VAR 0 2
23453: PPUSH
23454: LD_INT 0
23456: PPUSH
23457: CALL_OW 1
23461: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23462: LD_ADDR_EXP 113
23466: PUSH
23467: LD_EXP 113
23471: PPUSH
23472: LD_VAR 0 2
23476: PPUSH
23477: EMPTY
23478: PPUSH
23479: CALL_OW 1
23483: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23484: LD_ADDR_EXP 116
23488: PUSH
23489: LD_EXP 116
23493: PPUSH
23494: LD_VAR 0 2
23498: PPUSH
23499: LD_INT 0
23501: PPUSH
23502: CALL_OW 1
23506: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23507: LD_ADDR_EXP 117
23511: PUSH
23512: LD_EXP 117
23516: PPUSH
23517: LD_VAR 0 2
23521: PPUSH
23522: EMPTY
23523: PPUSH
23524: CALL_OW 1
23528: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23529: LD_ADDR_EXP 118
23533: PUSH
23534: LD_EXP 118
23538: PPUSH
23539: LD_VAR 0 2
23543: PPUSH
23544: EMPTY
23545: PPUSH
23546: CALL_OW 1
23550: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23551: LD_ADDR_EXP 119
23555: PUSH
23556: LD_EXP 119
23560: PPUSH
23561: LD_VAR 0 2
23565: PPUSH
23566: EMPTY
23567: PPUSH
23568: CALL_OW 1
23572: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23573: LD_ADDR_EXP 121
23577: PUSH
23578: LD_EXP 121
23582: PPUSH
23583: LD_VAR 0 2
23587: PPUSH
23588: LD_EXP 88
23592: PUSH
23593: LD_VAR 0 2
23597: ARRAY
23598: PPUSH
23599: LD_INT 2
23601: PUSH
23602: LD_INT 30
23604: PUSH
23605: LD_INT 6
23607: PUSH
23608: EMPTY
23609: LIST
23610: LIST
23611: PUSH
23612: LD_INT 30
23614: PUSH
23615: LD_INT 7
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PUSH
23622: LD_INT 30
23624: PUSH
23625: LD_INT 8
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: LIST
23636: LIST
23637: PPUSH
23638: CALL_OW 72
23642: PPUSH
23643: CALL_OW 1
23647: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23648: LD_ADDR_EXP 122
23652: PUSH
23653: LD_EXP 122
23657: PPUSH
23658: LD_VAR 0 2
23662: PPUSH
23663: EMPTY
23664: PPUSH
23665: CALL_OW 1
23669: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23670: LD_ADDR_EXP 123
23674: PUSH
23675: LD_EXP 123
23679: PPUSH
23680: LD_VAR 0 2
23684: PPUSH
23685: EMPTY
23686: PPUSH
23687: CALL_OW 1
23691: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23692: LD_ADDR_EXP 124
23696: PUSH
23697: LD_EXP 124
23701: PPUSH
23702: LD_VAR 0 2
23706: PPUSH
23707: EMPTY
23708: PPUSH
23709: CALL_OW 1
23713: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23714: LD_ADDR_EXP 125
23718: PUSH
23719: LD_EXP 125
23723: PPUSH
23724: LD_VAR 0 2
23728: PPUSH
23729: EMPTY
23730: PPUSH
23731: CALL_OW 1
23735: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23736: LD_ADDR_EXP 126
23740: PUSH
23741: LD_EXP 126
23745: PPUSH
23746: LD_VAR 0 2
23750: PPUSH
23751: EMPTY
23752: PPUSH
23753: CALL_OW 1
23757: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23758: LD_ADDR_EXP 127
23762: PUSH
23763: LD_EXP 127
23767: PPUSH
23768: LD_VAR 0 2
23772: PPUSH
23773: EMPTY
23774: PPUSH
23775: CALL_OW 1
23779: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23780: LD_ADDR_EXP 128
23784: PUSH
23785: LD_EXP 128
23789: PPUSH
23790: LD_VAR 0 2
23794: PPUSH
23795: EMPTY
23796: PPUSH
23797: CALL_OW 1
23801: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23802: LD_ADDR_EXP 129
23806: PUSH
23807: LD_EXP 129
23811: PPUSH
23812: LD_VAR 0 2
23816: PPUSH
23817: EMPTY
23818: PPUSH
23819: CALL_OW 1
23823: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23824: LD_ADDR_EXP 130
23828: PUSH
23829: LD_EXP 130
23833: PPUSH
23834: LD_VAR 0 2
23838: PPUSH
23839: LD_INT 0
23841: PPUSH
23842: CALL_OW 1
23846: ST_TO_ADDR
// end ;
23847: GO 22771
23849: POP
23850: POP
// MC_InitSides ( ) ;
23851: CALL 24137 0 0
// MC_InitResearch ( ) ;
23855: CALL 23876 0 0
// CustomInitMacro ( ) ;
23859: CALL 213 0 0
// skirmish := true ;
23863: LD_ADDR_EXP 86
23867: PUSH
23868: LD_INT 1
23870: ST_TO_ADDR
// end ;
23871: LD_VAR 0 1
23875: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23876: LD_INT 0
23878: PPUSH
23879: PPUSH
23880: PPUSH
23881: PPUSH
23882: PPUSH
23883: PPUSH
// if not mc_bases then
23884: LD_EXP 88
23888: NOT
23889: IFFALSE 23893
// exit ;
23891: GO 24132
// for i = 1 to 8 do
23893: LD_ADDR_VAR 0 2
23897: PUSH
23898: DOUBLE
23899: LD_INT 1
23901: DEC
23902: ST_TO_ADDR
23903: LD_INT 8
23905: PUSH
23906: FOR_TO
23907: IFFALSE 23933
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23909: LD_ADDR_EXP 115
23913: PUSH
23914: LD_EXP 115
23918: PPUSH
23919: LD_VAR 0 2
23923: PPUSH
23924: EMPTY
23925: PPUSH
23926: CALL_OW 1
23930: ST_TO_ADDR
23931: GO 23906
23933: POP
23934: POP
// tmp := [ ] ;
23935: LD_ADDR_VAR 0 5
23939: PUSH
23940: EMPTY
23941: ST_TO_ADDR
// for i = 1 to mc_sides do
23942: LD_ADDR_VAR 0 2
23946: PUSH
23947: DOUBLE
23948: LD_INT 1
23950: DEC
23951: ST_TO_ADDR
23952: LD_EXP 114
23956: PUSH
23957: FOR_TO
23958: IFFALSE 24016
// if not mc_sides [ i ] in tmp then
23960: LD_EXP 114
23964: PUSH
23965: LD_VAR 0 2
23969: ARRAY
23970: PUSH
23971: LD_VAR 0 5
23975: IN
23976: NOT
23977: IFFALSE 24014
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23979: LD_ADDR_VAR 0 5
23983: PUSH
23984: LD_VAR 0 5
23988: PPUSH
23989: LD_VAR 0 5
23993: PUSH
23994: LD_INT 1
23996: PLUS
23997: PPUSH
23998: LD_EXP 114
24002: PUSH
24003: LD_VAR 0 2
24007: ARRAY
24008: PPUSH
24009: CALL_OW 2
24013: ST_TO_ADDR
24014: GO 23957
24016: POP
24017: POP
// if not tmp then
24018: LD_VAR 0 5
24022: NOT
24023: IFFALSE 24027
// exit ;
24025: GO 24132
// for j in tmp do
24027: LD_ADDR_VAR 0 3
24031: PUSH
24032: LD_VAR 0 5
24036: PUSH
24037: FOR_IN
24038: IFFALSE 24130
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24040: LD_ADDR_VAR 0 6
24044: PUSH
24045: LD_INT 22
24047: PUSH
24048: LD_VAR 0 3
24052: PUSH
24053: EMPTY
24054: LIST
24055: LIST
24056: PPUSH
24057: CALL_OW 69
24061: ST_TO_ADDR
// if not un then
24062: LD_VAR 0 6
24066: NOT
24067: IFFALSE 24071
// continue ;
24069: GO 24037
// nation := GetNation ( un [ 1 ] ) ;
24071: LD_ADDR_VAR 0 4
24075: PUSH
24076: LD_VAR 0 6
24080: PUSH
24081: LD_INT 1
24083: ARRAY
24084: PPUSH
24085: CALL_OW 248
24089: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24090: LD_ADDR_EXP 115
24094: PUSH
24095: LD_EXP 115
24099: PPUSH
24100: LD_VAR 0 3
24104: PPUSH
24105: LD_VAR 0 3
24109: PPUSH
24110: LD_VAR 0 4
24114: PPUSH
24115: LD_INT 1
24117: PPUSH
24118: CALL 50726 0 3
24122: PPUSH
24123: CALL_OW 1
24127: ST_TO_ADDR
// end ;
24128: GO 24037
24130: POP
24131: POP
// end ;
24132: LD_VAR 0 1
24136: RET
// export function MC_InitSides ( ) ; var i ; begin
24137: LD_INT 0
24139: PPUSH
24140: PPUSH
// if not mc_bases then
24141: LD_EXP 88
24145: NOT
24146: IFFALSE 24150
// exit ;
24148: GO 24224
// for i = 1 to mc_bases do
24150: LD_ADDR_VAR 0 2
24154: PUSH
24155: DOUBLE
24156: LD_INT 1
24158: DEC
24159: ST_TO_ADDR
24160: LD_EXP 88
24164: PUSH
24165: FOR_TO
24166: IFFALSE 24222
// if mc_bases [ i ] then
24168: LD_EXP 88
24172: PUSH
24173: LD_VAR 0 2
24177: ARRAY
24178: IFFALSE 24220
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24180: LD_ADDR_EXP 114
24184: PUSH
24185: LD_EXP 114
24189: PPUSH
24190: LD_VAR 0 2
24194: PPUSH
24195: LD_EXP 88
24199: PUSH
24200: LD_VAR 0 2
24204: ARRAY
24205: PUSH
24206: LD_INT 1
24208: ARRAY
24209: PPUSH
24210: CALL_OW 255
24214: PPUSH
24215: CALL_OW 1
24219: ST_TO_ADDR
24220: GO 24165
24222: POP
24223: POP
// end ;
24224: LD_VAR 0 1
24228: RET
// every 0 0$01 trigger skirmish do
24229: LD_EXP 86
24233: IFFALSE 24387
24235: GO 24237
24237: DISABLE
// begin enable ;
24238: ENABLE
// MC_CheckBuildings ( ) ;
24239: CALL 28885 0 0
// MC_CheckPeopleLife ( ) ;
24243: CALL 29010 0 0
// RaiseSailEvent ( 100 ) ;
24247: LD_INT 100
24249: PPUSH
24250: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24254: LD_INT 103
24256: PPUSH
24257: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24261: LD_INT 104
24263: PPUSH
24264: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24268: LD_INT 105
24270: PPUSH
24271: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24275: LD_INT 106
24277: PPUSH
24278: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24282: LD_INT 107
24284: PPUSH
24285: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24289: LD_INT 108
24291: PPUSH
24292: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24296: LD_INT 109
24298: PPUSH
24299: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24303: LD_INT 110
24305: PPUSH
24306: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24310: LD_INT 111
24312: PPUSH
24313: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24317: LD_INT 112
24319: PPUSH
24320: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24324: LD_INT 113
24326: PPUSH
24327: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24331: LD_INT 120
24333: PPUSH
24334: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24338: LD_INT 121
24340: PPUSH
24341: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24345: LD_INT 122
24347: PPUSH
24348: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24352: LD_INT 123
24354: PPUSH
24355: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24359: LD_INT 124
24361: PPUSH
24362: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24366: LD_INT 125
24368: PPUSH
24369: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24373: LD_INT 126
24375: PPUSH
24376: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24380: LD_INT 200
24382: PPUSH
24383: CALL_OW 427
// end ;
24387: END
// on SailEvent ( event ) do begin if event < 100 then
24388: LD_VAR 0 1
24392: PUSH
24393: LD_INT 100
24395: LESS
24396: IFFALSE 24407
// CustomEvent ( event ) ;
24398: LD_VAR 0 1
24402: PPUSH
24403: CALL 10371 0 1
// if event = 100 then
24407: LD_VAR 0 1
24411: PUSH
24412: LD_INT 100
24414: EQUAL
24415: IFFALSE 24421
// MC_ClassManager ( ) ;
24417: CALL 24813 0 0
// if event = 101 then
24421: LD_VAR 0 1
24425: PUSH
24426: LD_INT 101
24428: EQUAL
24429: IFFALSE 24435
// MC_RepairBuildings ( ) ;
24431: CALL 29595 0 0
// if event = 102 then
24435: LD_VAR 0 1
24439: PUSH
24440: LD_INT 102
24442: EQUAL
24443: IFFALSE 24449
// MC_Heal ( ) ;
24445: CALL 30454 0 0
// if event = 103 then
24449: LD_VAR 0 1
24453: PUSH
24454: LD_INT 103
24456: EQUAL
24457: IFFALSE 24463
// MC_Build ( ) ;
24459: CALL 30876 0 0
// if event = 104 then
24463: LD_VAR 0 1
24467: PUSH
24468: LD_INT 104
24470: EQUAL
24471: IFFALSE 24477
// MC_TurretWeapon ( ) ;
24473: CALL 32489 0 0
// if event = 105 then
24477: LD_VAR 0 1
24481: PUSH
24482: LD_INT 105
24484: EQUAL
24485: IFFALSE 24491
// MC_BuildUpgrade ( ) ;
24487: CALL 32040 0 0
// if event = 106 then
24491: LD_VAR 0 1
24495: PUSH
24496: LD_INT 106
24498: EQUAL
24499: IFFALSE 24505
// MC_PlantMines ( ) ;
24501: CALL 32919 0 0
// if event = 107 then
24505: LD_VAR 0 1
24509: PUSH
24510: LD_INT 107
24512: EQUAL
24513: IFFALSE 24519
// MC_CollectCrates ( ) ;
24515: CALL 33717 0 0
// if event = 108 then
24519: LD_VAR 0 1
24523: PUSH
24524: LD_INT 108
24526: EQUAL
24527: IFFALSE 24533
// MC_LinkRemoteControl ( ) ;
24529: CALL 35493 0 0
// if event = 109 then
24533: LD_VAR 0 1
24537: PUSH
24538: LD_INT 109
24540: EQUAL
24541: IFFALSE 24547
// MC_ProduceVehicle ( ) ;
24543: CALL 35674 0 0
// if event = 110 then
24547: LD_VAR 0 1
24551: PUSH
24552: LD_INT 110
24554: EQUAL
24555: IFFALSE 24561
// MC_SendAttack ( ) ;
24557: CALL 36140 0 0
// if event = 111 then
24561: LD_VAR 0 1
24565: PUSH
24566: LD_INT 111
24568: EQUAL
24569: IFFALSE 24575
// MC_Defend ( ) ;
24571: CALL 36248 0 0
// if event = 112 then
24575: LD_VAR 0 1
24579: PUSH
24580: LD_INT 112
24582: EQUAL
24583: IFFALSE 24589
// MC_Research ( ) ;
24585: CALL 36853 0 0
// if event = 113 then
24589: LD_VAR 0 1
24593: PUSH
24594: LD_INT 113
24596: EQUAL
24597: IFFALSE 24603
// MC_MinesTrigger ( ) ;
24599: CALL 37967 0 0
// if event = 120 then
24603: LD_VAR 0 1
24607: PUSH
24608: LD_INT 120
24610: EQUAL
24611: IFFALSE 24617
// MC_RepairVehicle ( ) ;
24613: CALL 38066 0 0
// if event = 121 then
24617: LD_VAR 0 1
24621: PUSH
24622: LD_INT 121
24624: EQUAL
24625: IFFALSE 24631
// MC_TameApe ( ) ;
24627: CALL 38796 0 0
// if event = 122 then
24631: LD_VAR 0 1
24635: PUSH
24636: LD_INT 122
24638: EQUAL
24639: IFFALSE 24645
// MC_ChangeApeClass ( ) ;
24641: CALL 39625 0 0
// if event = 123 then
24645: LD_VAR 0 1
24649: PUSH
24650: LD_INT 123
24652: EQUAL
24653: IFFALSE 24659
// MC_Bazooka ( ) ;
24655: CALL 40275 0 0
// if event = 124 then
24659: LD_VAR 0 1
24663: PUSH
24664: LD_INT 124
24666: EQUAL
24667: IFFALSE 24673
// MC_TeleportExit ( ) ;
24669: CALL 40473 0 0
// if event = 125 then
24673: LD_VAR 0 1
24677: PUSH
24678: LD_INT 125
24680: EQUAL
24681: IFFALSE 24687
// MC_Deposits ( ) ;
24683: CALL 41120 0 0
// if event = 126 then
24687: LD_VAR 0 1
24691: PUSH
24692: LD_INT 126
24694: EQUAL
24695: IFFALSE 24701
// MC_RemoteDriver ( ) ;
24697: CALL 41745 0 0
// if event = 200 then
24701: LD_VAR 0 1
24705: PUSH
24706: LD_INT 200
24708: EQUAL
24709: IFFALSE 24715
// MC_Idle ( ) ;
24711: CALL 43694 0 0
// end ;
24715: PPOPN 1
24717: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24718: LD_INT 0
24720: PPUSH
24721: PPUSH
// if not mc_bases [ base ] or not tag then
24722: LD_EXP 88
24726: PUSH
24727: LD_VAR 0 1
24731: ARRAY
24732: NOT
24733: PUSH
24734: LD_VAR 0 2
24738: NOT
24739: OR
24740: IFFALSE 24744
// exit ;
24742: GO 24808
// for i in mc_bases [ base ] union mc_ape [ base ] do
24744: LD_ADDR_VAR 0 4
24748: PUSH
24749: LD_EXP 88
24753: PUSH
24754: LD_VAR 0 1
24758: ARRAY
24759: PUSH
24760: LD_EXP 117
24764: PUSH
24765: LD_VAR 0 1
24769: ARRAY
24770: UNION
24771: PUSH
24772: FOR_IN
24773: IFFALSE 24806
// if GetTag ( i ) = tag then
24775: LD_VAR 0 4
24779: PPUSH
24780: CALL_OW 110
24784: PUSH
24785: LD_VAR 0 2
24789: EQUAL
24790: IFFALSE 24804
// SetTag ( i , 0 ) ;
24792: LD_VAR 0 4
24796: PPUSH
24797: LD_INT 0
24799: PPUSH
24800: CALL_OW 109
24804: GO 24772
24806: POP
24807: POP
// end ;
24808: LD_VAR 0 3
24812: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24813: LD_INT 0
24815: PPUSH
24816: PPUSH
24817: PPUSH
24818: PPUSH
24819: PPUSH
24820: PPUSH
24821: PPUSH
24822: PPUSH
// if not mc_bases then
24823: LD_EXP 88
24827: NOT
24828: IFFALSE 24832
// exit ;
24830: GO 25290
// for i = 1 to mc_bases do
24832: LD_ADDR_VAR 0 2
24836: PUSH
24837: DOUBLE
24838: LD_INT 1
24840: DEC
24841: ST_TO_ADDR
24842: LD_EXP 88
24846: PUSH
24847: FOR_TO
24848: IFFALSE 25288
// begin tmp := MC_ClassCheckReq ( i ) ;
24850: LD_ADDR_VAR 0 4
24854: PUSH
24855: LD_VAR 0 2
24859: PPUSH
24860: CALL 25295 0 1
24864: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24865: LD_ADDR_EXP 129
24869: PUSH
24870: LD_EXP 129
24874: PPUSH
24875: LD_VAR 0 2
24879: PPUSH
24880: LD_VAR 0 4
24884: PPUSH
24885: CALL_OW 1
24889: ST_TO_ADDR
// if not tmp then
24890: LD_VAR 0 4
24894: NOT
24895: IFFALSE 24899
// continue ;
24897: GO 24847
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24899: LD_ADDR_VAR 0 6
24903: PUSH
24904: LD_EXP 88
24908: PUSH
24909: LD_VAR 0 2
24913: ARRAY
24914: PPUSH
24915: LD_INT 2
24917: PUSH
24918: LD_INT 30
24920: PUSH
24921: LD_INT 4
24923: PUSH
24924: EMPTY
24925: LIST
24926: LIST
24927: PUSH
24928: LD_INT 30
24930: PUSH
24931: LD_INT 5
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: LIST
24942: PPUSH
24943: CALL_OW 72
24947: PUSH
24948: LD_EXP 88
24952: PUSH
24953: LD_VAR 0 2
24957: ARRAY
24958: PPUSH
24959: LD_INT 2
24961: PUSH
24962: LD_INT 30
24964: PUSH
24965: LD_INT 0
24967: PUSH
24968: EMPTY
24969: LIST
24970: LIST
24971: PUSH
24972: LD_INT 30
24974: PUSH
24975: LD_INT 1
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: PUSH
24982: EMPTY
24983: LIST
24984: LIST
24985: LIST
24986: PPUSH
24987: CALL_OW 72
24991: PUSH
24992: LD_EXP 88
24996: PUSH
24997: LD_VAR 0 2
25001: ARRAY
25002: PPUSH
25003: LD_INT 30
25005: PUSH
25006: LD_INT 3
25008: PUSH
25009: EMPTY
25010: LIST
25011: LIST
25012: PPUSH
25013: CALL_OW 72
25017: PUSH
25018: LD_EXP 88
25022: PUSH
25023: LD_VAR 0 2
25027: ARRAY
25028: PPUSH
25029: LD_INT 2
25031: PUSH
25032: LD_INT 30
25034: PUSH
25035: LD_INT 6
25037: PUSH
25038: EMPTY
25039: LIST
25040: LIST
25041: PUSH
25042: LD_INT 30
25044: PUSH
25045: LD_INT 7
25047: PUSH
25048: EMPTY
25049: LIST
25050: LIST
25051: PUSH
25052: LD_INT 30
25054: PUSH
25055: LD_INT 8
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: PUSH
25062: EMPTY
25063: LIST
25064: LIST
25065: LIST
25066: LIST
25067: PPUSH
25068: CALL_OW 72
25072: PUSH
25073: EMPTY
25074: LIST
25075: LIST
25076: LIST
25077: LIST
25078: ST_TO_ADDR
// for j = 1 to 4 do
25079: LD_ADDR_VAR 0 3
25083: PUSH
25084: DOUBLE
25085: LD_INT 1
25087: DEC
25088: ST_TO_ADDR
25089: LD_INT 4
25091: PUSH
25092: FOR_TO
25093: IFFALSE 25284
// begin if not tmp [ j ] then
25095: LD_VAR 0 4
25099: PUSH
25100: LD_VAR 0 3
25104: ARRAY
25105: NOT
25106: IFFALSE 25110
// continue ;
25108: GO 25092
// for p in tmp [ j ] do
25110: LD_ADDR_VAR 0 5
25114: PUSH
25115: LD_VAR 0 4
25119: PUSH
25120: LD_VAR 0 3
25124: ARRAY
25125: PUSH
25126: FOR_IN
25127: IFFALSE 25280
// begin if not b [ j ] then
25129: LD_VAR 0 6
25133: PUSH
25134: LD_VAR 0 3
25138: ARRAY
25139: NOT
25140: IFFALSE 25144
// break ;
25142: GO 25280
// e := 0 ;
25144: LD_ADDR_VAR 0 7
25148: PUSH
25149: LD_INT 0
25151: ST_TO_ADDR
// for k in b [ j ] do
25152: LD_ADDR_VAR 0 8
25156: PUSH
25157: LD_VAR 0 6
25161: PUSH
25162: LD_VAR 0 3
25166: ARRAY
25167: PUSH
25168: FOR_IN
25169: IFFALSE 25196
// if IsNotFull ( k ) then
25171: LD_VAR 0 8
25175: PPUSH
25176: CALL 52875 0 1
25180: IFFALSE 25194
// begin e := k ;
25182: LD_ADDR_VAR 0 7
25186: PUSH
25187: LD_VAR 0 8
25191: ST_TO_ADDR
// break ;
25192: GO 25196
// end ;
25194: GO 25168
25196: POP
25197: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25198: LD_VAR 0 7
25202: PUSH
25203: LD_VAR 0 5
25207: PPUSH
25208: LD_VAR 0 7
25212: PPUSH
25213: CALL 85295 0 2
25217: NOT
25218: AND
25219: IFFALSE 25278
// begin if IsInUnit ( p ) then
25221: LD_VAR 0 5
25225: PPUSH
25226: CALL_OW 310
25230: IFFALSE 25241
// ComExitBuilding ( p ) ;
25232: LD_VAR 0 5
25236: PPUSH
25237: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25241: LD_VAR 0 5
25245: PPUSH
25246: LD_VAR 0 7
25250: PPUSH
25251: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25255: LD_VAR 0 5
25259: PPUSH
25260: LD_VAR 0 3
25264: PPUSH
25265: CALL_OW 183
// AddComExitBuilding ( p ) ;
25269: LD_VAR 0 5
25273: PPUSH
25274: CALL_OW 182
// end ; end ;
25278: GO 25126
25280: POP
25281: POP
// end ;
25282: GO 25092
25284: POP
25285: POP
// end ;
25286: GO 24847
25288: POP
25289: POP
// end ;
25290: LD_VAR 0 1
25294: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25295: LD_INT 0
25297: PPUSH
25298: PPUSH
25299: PPUSH
25300: PPUSH
25301: PPUSH
25302: PPUSH
25303: PPUSH
25304: PPUSH
25305: PPUSH
25306: PPUSH
25307: PPUSH
25308: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25309: LD_VAR 0 1
25313: NOT
25314: PUSH
25315: LD_EXP 88
25319: PUSH
25320: LD_VAR 0 1
25324: ARRAY
25325: NOT
25326: OR
25327: PUSH
25328: LD_EXP 88
25332: PUSH
25333: LD_VAR 0 1
25337: ARRAY
25338: PPUSH
25339: LD_INT 2
25341: PUSH
25342: LD_INT 30
25344: PUSH
25345: LD_INT 0
25347: PUSH
25348: EMPTY
25349: LIST
25350: LIST
25351: PUSH
25352: LD_INT 30
25354: PUSH
25355: LD_INT 1
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PUSH
25362: EMPTY
25363: LIST
25364: LIST
25365: LIST
25366: PPUSH
25367: CALL_OW 72
25371: NOT
25372: OR
25373: IFFALSE 25377
// exit ;
25375: GO 28880
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25377: LD_ADDR_VAR 0 4
25381: PUSH
25382: LD_EXP 88
25386: PUSH
25387: LD_VAR 0 1
25391: ARRAY
25392: PPUSH
25393: LD_INT 2
25395: PUSH
25396: LD_INT 25
25398: PUSH
25399: LD_INT 1
25401: PUSH
25402: EMPTY
25403: LIST
25404: LIST
25405: PUSH
25406: LD_INT 25
25408: PUSH
25409: LD_INT 2
25411: PUSH
25412: EMPTY
25413: LIST
25414: LIST
25415: PUSH
25416: LD_INT 25
25418: PUSH
25419: LD_INT 3
25421: PUSH
25422: EMPTY
25423: LIST
25424: LIST
25425: PUSH
25426: LD_INT 25
25428: PUSH
25429: LD_INT 4
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: PUSH
25436: LD_INT 25
25438: PUSH
25439: LD_INT 5
25441: PUSH
25442: EMPTY
25443: LIST
25444: LIST
25445: PUSH
25446: LD_INT 25
25448: PUSH
25449: LD_INT 8
25451: PUSH
25452: EMPTY
25453: LIST
25454: LIST
25455: PUSH
25456: LD_INT 25
25458: PUSH
25459: LD_INT 9
25461: PUSH
25462: EMPTY
25463: LIST
25464: LIST
25465: PUSH
25466: EMPTY
25467: LIST
25468: LIST
25469: LIST
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: LIST
25475: PPUSH
25476: CALL_OW 72
25480: ST_TO_ADDR
// if not tmp then
25481: LD_VAR 0 4
25485: NOT
25486: IFFALSE 25490
// exit ;
25488: GO 28880
// for i in tmp do
25490: LD_ADDR_VAR 0 3
25494: PUSH
25495: LD_VAR 0 4
25499: PUSH
25500: FOR_IN
25501: IFFALSE 25532
// if GetTag ( i ) then
25503: LD_VAR 0 3
25507: PPUSH
25508: CALL_OW 110
25512: IFFALSE 25530
// tmp := tmp diff i ;
25514: LD_ADDR_VAR 0 4
25518: PUSH
25519: LD_VAR 0 4
25523: PUSH
25524: LD_VAR 0 3
25528: DIFF
25529: ST_TO_ADDR
25530: GO 25500
25532: POP
25533: POP
// if not tmp then
25534: LD_VAR 0 4
25538: NOT
25539: IFFALSE 25543
// exit ;
25541: GO 28880
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25543: LD_ADDR_VAR 0 5
25547: PUSH
25548: LD_EXP 88
25552: PUSH
25553: LD_VAR 0 1
25557: ARRAY
25558: PPUSH
25559: LD_INT 2
25561: PUSH
25562: LD_INT 25
25564: PUSH
25565: LD_INT 1
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: PUSH
25572: LD_INT 25
25574: PUSH
25575: LD_INT 5
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: PUSH
25582: LD_INT 25
25584: PUSH
25585: LD_INT 8
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: PUSH
25592: LD_INT 25
25594: PUSH
25595: LD_INT 9
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: PUSH
25602: EMPTY
25603: LIST
25604: LIST
25605: LIST
25606: LIST
25607: LIST
25608: PPUSH
25609: CALL_OW 72
25613: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25614: LD_ADDR_VAR 0 6
25618: PUSH
25619: LD_EXP 88
25623: PUSH
25624: LD_VAR 0 1
25628: ARRAY
25629: PPUSH
25630: LD_INT 25
25632: PUSH
25633: LD_INT 2
25635: PUSH
25636: EMPTY
25637: LIST
25638: LIST
25639: PPUSH
25640: CALL_OW 72
25644: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25645: LD_ADDR_VAR 0 7
25649: PUSH
25650: LD_EXP 88
25654: PUSH
25655: LD_VAR 0 1
25659: ARRAY
25660: PPUSH
25661: LD_INT 25
25663: PUSH
25664: LD_INT 3
25666: PUSH
25667: EMPTY
25668: LIST
25669: LIST
25670: PPUSH
25671: CALL_OW 72
25675: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25676: LD_ADDR_VAR 0 8
25680: PUSH
25681: LD_EXP 88
25685: PUSH
25686: LD_VAR 0 1
25690: ARRAY
25691: PPUSH
25692: LD_INT 25
25694: PUSH
25695: LD_INT 4
25697: PUSH
25698: EMPTY
25699: LIST
25700: LIST
25701: PUSH
25702: LD_INT 24
25704: PUSH
25705: LD_INT 251
25707: PUSH
25708: EMPTY
25709: LIST
25710: LIST
25711: PUSH
25712: EMPTY
25713: LIST
25714: LIST
25715: PPUSH
25716: CALL_OW 72
25720: ST_TO_ADDR
// if mc_scan [ base ] then
25721: LD_EXP 111
25725: PUSH
25726: LD_VAR 0 1
25730: ARRAY
25731: IFFALSE 26192
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25733: LD_ADDR_EXP 130
25737: PUSH
25738: LD_EXP 130
25742: PPUSH
25743: LD_VAR 0 1
25747: PPUSH
25748: LD_INT 4
25750: PPUSH
25751: CALL_OW 1
25755: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25756: LD_ADDR_VAR 0 12
25760: PUSH
25761: LD_EXP 88
25765: PUSH
25766: LD_VAR 0 1
25770: ARRAY
25771: PPUSH
25772: LD_INT 2
25774: PUSH
25775: LD_INT 30
25777: PUSH
25778: LD_INT 4
25780: PUSH
25781: EMPTY
25782: LIST
25783: LIST
25784: PUSH
25785: LD_INT 30
25787: PUSH
25788: LD_INT 5
25790: PUSH
25791: EMPTY
25792: LIST
25793: LIST
25794: PUSH
25795: EMPTY
25796: LIST
25797: LIST
25798: LIST
25799: PPUSH
25800: CALL_OW 72
25804: ST_TO_ADDR
// if not b then
25805: LD_VAR 0 12
25809: NOT
25810: IFFALSE 25814
// exit ;
25812: GO 28880
// p := [ ] ;
25814: LD_ADDR_VAR 0 11
25818: PUSH
25819: EMPTY
25820: ST_TO_ADDR
// if sci >= 2 then
25821: LD_VAR 0 8
25825: PUSH
25826: LD_INT 2
25828: GREATEREQUAL
25829: IFFALSE 25860
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25831: LD_ADDR_VAR 0 8
25835: PUSH
25836: LD_VAR 0 8
25840: PUSH
25841: LD_INT 1
25843: ARRAY
25844: PUSH
25845: LD_VAR 0 8
25849: PUSH
25850: LD_INT 2
25852: ARRAY
25853: PUSH
25854: EMPTY
25855: LIST
25856: LIST
25857: ST_TO_ADDR
25858: GO 25921
// if sci = 1 then
25860: LD_VAR 0 8
25864: PUSH
25865: LD_INT 1
25867: EQUAL
25868: IFFALSE 25889
// sci := [ sci [ 1 ] ] else
25870: LD_ADDR_VAR 0 8
25874: PUSH
25875: LD_VAR 0 8
25879: PUSH
25880: LD_INT 1
25882: ARRAY
25883: PUSH
25884: EMPTY
25885: LIST
25886: ST_TO_ADDR
25887: GO 25921
// if sci = 0 then
25889: LD_VAR 0 8
25893: PUSH
25894: LD_INT 0
25896: EQUAL
25897: IFFALSE 25921
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25899: LD_ADDR_VAR 0 11
25903: PUSH
25904: LD_VAR 0 4
25908: PPUSH
25909: LD_INT 4
25911: PPUSH
25912: CALL 85158 0 2
25916: PUSH
25917: LD_INT 1
25919: ARRAY
25920: ST_TO_ADDR
// if eng > 4 then
25921: LD_VAR 0 6
25925: PUSH
25926: LD_INT 4
25928: GREATER
25929: IFFALSE 25975
// for i = eng downto 4 do
25931: LD_ADDR_VAR 0 3
25935: PUSH
25936: DOUBLE
25937: LD_VAR 0 6
25941: INC
25942: ST_TO_ADDR
25943: LD_INT 4
25945: PUSH
25946: FOR_DOWNTO
25947: IFFALSE 25973
// eng := eng diff eng [ i ] ;
25949: LD_ADDR_VAR 0 6
25953: PUSH
25954: LD_VAR 0 6
25958: PUSH
25959: LD_VAR 0 6
25963: PUSH
25964: LD_VAR 0 3
25968: ARRAY
25969: DIFF
25970: ST_TO_ADDR
25971: GO 25946
25973: POP
25974: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25975: LD_ADDR_VAR 0 4
25979: PUSH
25980: LD_VAR 0 4
25984: PUSH
25985: LD_VAR 0 5
25989: PUSH
25990: LD_VAR 0 6
25994: UNION
25995: PUSH
25996: LD_VAR 0 7
26000: UNION
26001: PUSH
26002: LD_VAR 0 8
26006: UNION
26007: DIFF
26008: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26009: LD_ADDR_VAR 0 13
26013: PUSH
26014: LD_EXP 88
26018: PUSH
26019: LD_VAR 0 1
26023: ARRAY
26024: PPUSH
26025: LD_INT 2
26027: PUSH
26028: LD_INT 30
26030: PUSH
26031: LD_INT 32
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: PUSH
26038: LD_INT 30
26040: PUSH
26041: LD_INT 31
26043: PUSH
26044: EMPTY
26045: LIST
26046: LIST
26047: PUSH
26048: EMPTY
26049: LIST
26050: LIST
26051: LIST
26052: PPUSH
26053: CALL_OW 72
26057: PUSH
26058: LD_EXP 88
26062: PUSH
26063: LD_VAR 0 1
26067: ARRAY
26068: PPUSH
26069: LD_INT 2
26071: PUSH
26072: LD_INT 30
26074: PUSH
26075: LD_INT 4
26077: PUSH
26078: EMPTY
26079: LIST
26080: LIST
26081: PUSH
26082: LD_INT 30
26084: PUSH
26085: LD_INT 5
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: EMPTY
26093: LIST
26094: LIST
26095: LIST
26096: PPUSH
26097: CALL_OW 72
26101: PUSH
26102: LD_INT 6
26104: MUL
26105: PLUS
26106: ST_TO_ADDR
// if bcount < tmp then
26107: LD_VAR 0 13
26111: PUSH
26112: LD_VAR 0 4
26116: LESS
26117: IFFALSE 26163
// for i = tmp downto bcount do
26119: LD_ADDR_VAR 0 3
26123: PUSH
26124: DOUBLE
26125: LD_VAR 0 4
26129: INC
26130: ST_TO_ADDR
26131: LD_VAR 0 13
26135: PUSH
26136: FOR_DOWNTO
26137: IFFALSE 26161
// tmp := Delete ( tmp , tmp ) ;
26139: LD_ADDR_VAR 0 4
26143: PUSH
26144: LD_VAR 0 4
26148: PPUSH
26149: LD_VAR 0 4
26153: PPUSH
26154: CALL_OW 3
26158: ST_TO_ADDR
26159: GO 26136
26161: POP
26162: POP
// result := [ tmp , 0 , 0 , p ] ;
26163: LD_ADDR_VAR 0 2
26167: PUSH
26168: LD_VAR 0 4
26172: PUSH
26173: LD_INT 0
26175: PUSH
26176: LD_INT 0
26178: PUSH
26179: LD_VAR 0 11
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: LIST
26188: LIST
26189: ST_TO_ADDR
// exit ;
26190: GO 28880
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26192: LD_EXP 88
26196: PUSH
26197: LD_VAR 0 1
26201: ARRAY
26202: PPUSH
26203: LD_INT 2
26205: PUSH
26206: LD_INT 30
26208: PUSH
26209: LD_INT 6
26211: PUSH
26212: EMPTY
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 30
26218: PUSH
26219: LD_INT 7
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: PUSH
26226: LD_INT 30
26228: PUSH
26229: LD_INT 8
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: PUSH
26236: EMPTY
26237: LIST
26238: LIST
26239: LIST
26240: LIST
26241: PPUSH
26242: CALL_OW 72
26246: NOT
26247: PUSH
26248: LD_EXP 88
26252: PUSH
26253: LD_VAR 0 1
26257: ARRAY
26258: PPUSH
26259: LD_INT 30
26261: PUSH
26262: LD_INT 3
26264: PUSH
26265: EMPTY
26266: LIST
26267: LIST
26268: PPUSH
26269: CALL_OW 72
26273: NOT
26274: AND
26275: IFFALSE 26347
// begin if eng = tmp then
26277: LD_VAR 0 6
26281: PUSH
26282: LD_VAR 0 4
26286: EQUAL
26287: IFFALSE 26291
// exit ;
26289: GO 28880
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26291: LD_ADDR_EXP 130
26295: PUSH
26296: LD_EXP 130
26300: PPUSH
26301: LD_VAR 0 1
26305: PPUSH
26306: LD_INT 1
26308: PPUSH
26309: CALL_OW 1
26313: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26314: LD_ADDR_VAR 0 2
26318: PUSH
26319: LD_INT 0
26321: PUSH
26322: LD_VAR 0 4
26326: PUSH
26327: LD_VAR 0 6
26331: DIFF
26332: PUSH
26333: LD_INT 0
26335: PUSH
26336: LD_INT 0
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: LIST
26343: LIST
26344: ST_TO_ADDR
// exit ;
26345: GO 28880
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26347: LD_EXP 115
26351: PUSH
26352: LD_EXP 114
26356: PUSH
26357: LD_VAR 0 1
26361: ARRAY
26362: ARRAY
26363: PUSH
26364: LD_EXP 88
26368: PUSH
26369: LD_VAR 0 1
26373: ARRAY
26374: PPUSH
26375: LD_INT 2
26377: PUSH
26378: LD_INT 30
26380: PUSH
26381: LD_INT 6
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: PUSH
26388: LD_INT 30
26390: PUSH
26391: LD_INT 7
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: LD_INT 30
26400: PUSH
26401: LD_INT 8
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: PUSH
26408: EMPTY
26409: LIST
26410: LIST
26411: LIST
26412: LIST
26413: PPUSH
26414: CALL_OW 72
26418: AND
26419: PUSH
26420: LD_EXP 88
26424: PUSH
26425: LD_VAR 0 1
26429: ARRAY
26430: PPUSH
26431: LD_INT 30
26433: PUSH
26434: LD_INT 3
26436: PUSH
26437: EMPTY
26438: LIST
26439: LIST
26440: PPUSH
26441: CALL_OW 72
26445: NOT
26446: AND
26447: IFFALSE 26661
// begin if sci >= 6 then
26449: LD_VAR 0 8
26453: PUSH
26454: LD_INT 6
26456: GREATEREQUAL
26457: IFFALSE 26461
// exit ;
26459: GO 28880
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26461: LD_ADDR_EXP 130
26465: PUSH
26466: LD_EXP 130
26470: PPUSH
26471: LD_VAR 0 1
26475: PPUSH
26476: LD_INT 2
26478: PPUSH
26479: CALL_OW 1
26483: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26484: LD_ADDR_VAR 0 9
26488: PUSH
26489: LD_VAR 0 4
26493: PUSH
26494: LD_VAR 0 8
26498: DIFF
26499: PPUSH
26500: LD_INT 4
26502: PPUSH
26503: CALL 85158 0 2
26507: ST_TO_ADDR
// p := [ ] ;
26508: LD_ADDR_VAR 0 11
26512: PUSH
26513: EMPTY
26514: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26515: LD_VAR 0 8
26519: PUSH
26520: LD_INT 6
26522: LESS
26523: PUSH
26524: LD_VAR 0 9
26528: PUSH
26529: LD_INT 6
26531: GREATER
26532: AND
26533: IFFALSE 26614
// begin for i = 1 to 6 - sci do
26535: LD_ADDR_VAR 0 3
26539: PUSH
26540: DOUBLE
26541: LD_INT 1
26543: DEC
26544: ST_TO_ADDR
26545: LD_INT 6
26547: PUSH
26548: LD_VAR 0 8
26552: MINUS
26553: PUSH
26554: FOR_TO
26555: IFFALSE 26610
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26557: LD_ADDR_VAR 0 11
26561: PUSH
26562: LD_VAR 0 11
26566: PPUSH
26567: LD_VAR 0 11
26571: PUSH
26572: LD_INT 1
26574: PLUS
26575: PPUSH
26576: LD_VAR 0 9
26580: PUSH
26581: LD_INT 1
26583: ARRAY
26584: PPUSH
26585: CALL_OW 2
26589: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26590: LD_ADDR_VAR 0 9
26594: PUSH
26595: LD_VAR 0 9
26599: PPUSH
26600: LD_INT 1
26602: PPUSH
26603: CALL_OW 3
26607: ST_TO_ADDR
// end ;
26608: GO 26554
26610: POP
26611: POP
// end else
26612: GO 26634
// if sort then
26614: LD_VAR 0 9
26618: IFFALSE 26634
// p := sort [ 1 ] ;
26620: LD_ADDR_VAR 0 11
26624: PUSH
26625: LD_VAR 0 9
26629: PUSH
26630: LD_INT 1
26632: ARRAY
26633: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26634: LD_ADDR_VAR 0 2
26638: PUSH
26639: LD_INT 0
26641: PUSH
26642: LD_INT 0
26644: PUSH
26645: LD_INT 0
26647: PUSH
26648: LD_VAR 0 11
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: LIST
26657: LIST
26658: ST_TO_ADDR
// exit ;
26659: GO 28880
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26661: LD_EXP 115
26665: PUSH
26666: LD_EXP 114
26670: PUSH
26671: LD_VAR 0 1
26675: ARRAY
26676: ARRAY
26677: PUSH
26678: LD_EXP 88
26682: PUSH
26683: LD_VAR 0 1
26687: ARRAY
26688: PPUSH
26689: LD_INT 2
26691: PUSH
26692: LD_INT 30
26694: PUSH
26695: LD_INT 6
26697: PUSH
26698: EMPTY
26699: LIST
26700: LIST
26701: PUSH
26702: LD_INT 30
26704: PUSH
26705: LD_INT 7
26707: PUSH
26708: EMPTY
26709: LIST
26710: LIST
26711: PUSH
26712: LD_INT 30
26714: PUSH
26715: LD_INT 8
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: LIST
26726: LIST
26727: PPUSH
26728: CALL_OW 72
26732: AND
26733: PUSH
26734: LD_EXP 88
26738: PUSH
26739: LD_VAR 0 1
26743: ARRAY
26744: PPUSH
26745: LD_INT 30
26747: PUSH
26748: LD_INT 3
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PPUSH
26755: CALL_OW 72
26759: AND
26760: IFFALSE 27494
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26762: LD_ADDR_EXP 130
26766: PUSH
26767: LD_EXP 130
26771: PPUSH
26772: LD_VAR 0 1
26776: PPUSH
26777: LD_INT 3
26779: PPUSH
26780: CALL_OW 1
26784: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26785: LD_ADDR_VAR 0 2
26789: PUSH
26790: LD_INT 0
26792: PUSH
26793: LD_INT 0
26795: PUSH
26796: LD_INT 0
26798: PUSH
26799: LD_INT 0
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: LIST
26806: LIST
26807: ST_TO_ADDR
// if not eng then
26808: LD_VAR 0 6
26812: NOT
26813: IFFALSE 26876
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26815: LD_ADDR_VAR 0 11
26819: PUSH
26820: LD_VAR 0 4
26824: PPUSH
26825: LD_INT 2
26827: PPUSH
26828: CALL 85158 0 2
26832: PUSH
26833: LD_INT 1
26835: ARRAY
26836: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26837: LD_ADDR_VAR 0 2
26841: PUSH
26842: LD_VAR 0 2
26846: PPUSH
26847: LD_INT 2
26849: PPUSH
26850: LD_VAR 0 11
26854: PPUSH
26855: CALL_OW 1
26859: ST_TO_ADDR
// tmp := tmp diff p ;
26860: LD_ADDR_VAR 0 4
26864: PUSH
26865: LD_VAR 0 4
26869: PUSH
26870: LD_VAR 0 11
26874: DIFF
26875: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26876: LD_VAR 0 4
26880: PUSH
26881: LD_VAR 0 8
26885: PUSH
26886: LD_INT 6
26888: LESS
26889: AND
26890: IFFALSE 27078
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26892: LD_ADDR_VAR 0 9
26896: PUSH
26897: LD_VAR 0 4
26901: PUSH
26902: LD_VAR 0 8
26906: PUSH
26907: LD_VAR 0 7
26911: UNION
26912: DIFF
26913: PPUSH
26914: LD_INT 4
26916: PPUSH
26917: CALL 85158 0 2
26921: ST_TO_ADDR
// p := [ ] ;
26922: LD_ADDR_VAR 0 11
26926: PUSH
26927: EMPTY
26928: ST_TO_ADDR
// if sort then
26929: LD_VAR 0 9
26933: IFFALSE 27049
// for i = 1 to 6 - sci do
26935: LD_ADDR_VAR 0 3
26939: PUSH
26940: DOUBLE
26941: LD_INT 1
26943: DEC
26944: ST_TO_ADDR
26945: LD_INT 6
26947: PUSH
26948: LD_VAR 0 8
26952: MINUS
26953: PUSH
26954: FOR_TO
26955: IFFALSE 27047
// begin if i = sort then
26957: LD_VAR 0 3
26961: PUSH
26962: LD_VAR 0 9
26966: EQUAL
26967: IFFALSE 26971
// break ;
26969: GO 27047
// if GetClass ( i ) = 4 then
26971: LD_VAR 0 3
26975: PPUSH
26976: CALL_OW 257
26980: PUSH
26981: LD_INT 4
26983: EQUAL
26984: IFFALSE 26988
// continue ;
26986: GO 26954
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26988: LD_ADDR_VAR 0 11
26992: PUSH
26993: LD_VAR 0 11
26997: PPUSH
26998: LD_VAR 0 11
27002: PUSH
27003: LD_INT 1
27005: PLUS
27006: PPUSH
27007: LD_VAR 0 9
27011: PUSH
27012: LD_VAR 0 3
27016: ARRAY
27017: PPUSH
27018: CALL_OW 2
27022: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27023: LD_ADDR_VAR 0 4
27027: PUSH
27028: LD_VAR 0 4
27032: PUSH
27033: LD_VAR 0 9
27037: PUSH
27038: LD_VAR 0 3
27042: ARRAY
27043: DIFF
27044: ST_TO_ADDR
// end ;
27045: GO 26954
27047: POP
27048: POP
// if p then
27049: LD_VAR 0 11
27053: IFFALSE 27078
// result := Replace ( result , 4 , p ) ;
27055: LD_ADDR_VAR 0 2
27059: PUSH
27060: LD_VAR 0 2
27064: PPUSH
27065: LD_INT 4
27067: PPUSH
27068: LD_VAR 0 11
27072: PPUSH
27073: CALL_OW 1
27077: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27078: LD_VAR 0 4
27082: PUSH
27083: LD_VAR 0 7
27087: PUSH
27088: LD_INT 6
27090: LESS
27091: AND
27092: IFFALSE 27280
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27094: LD_ADDR_VAR 0 9
27098: PUSH
27099: LD_VAR 0 4
27103: PUSH
27104: LD_VAR 0 8
27108: PUSH
27109: LD_VAR 0 7
27113: UNION
27114: DIFF
27115: PPUSH
27116: LD_INT 3
27118: PPUSH
27119: CALL 85158 0 2
27123: ST_TO_ADDR
// p := [ ] ;
27124: LD_ADDR_VAR 0 11
27128: PUSH
27129: EMPTY
27130: ST_TO_ADDR
// if sort then
27131: LD_VAR 0 9
27135: IFFALSE 27251
// for i = 1 to 6 - mech do
27137: LD_ADDR_VAR 0 3
27141: PUSH
27142: DOUBLE
27143: LD_INT 1
27145: DEC
27146: ST_TO_ADDR
27147: LD_INT 6
27149: PUSH
27150: LD_VAR 0 7
27154: MINUS
27155: PUSH
27156: FOR_TO
27157: IFFALSE 27249
// begin if i = sort then
27159: LD_VAR 0 3
27163: PUSH
27164: LD_VAR 0 9
27168: EQUAL
27169: IFFALSE 27173
// break ;
27171: GO 27249
// if GetClass ( i ) = 3 then
27173: LD_VAR 0 3
27177: PPUSH
27178: CALL_OW 257
27182: PUSH
27183: LD_INT 3
27185: EQUAL
27186: IFFALSE 27190
// continue ;
27188: GO 27156
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27190: LD_ADDR_VAR 0 11
27194: PUSH
27195: LD_VAR 0 11
27199: PPUSH
27200: LD_VAR 0 11
27204: PUSH
27205: LD_INT 1
27207: PLUS
27208: PPUSH
27209: LD_VAR 0 9
27213: PUSH
27214: LD_VAR 0 3
27218: ARRAY
27219: PPUSH
27220: CALL_OW 2
27224: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27225: LD_ADDR_VAR 0 4
27229: PUSH
27230: LD_VAR 0 4
27234: PUSH
27235: LD_VAR 0 9
27239: PUSH
27240: LD_VAR 0 3
27244: ARRAY
27245: DIFF
27246: ST_TO_ADDR
// end ;
27247: GO 27156
27249: POP
27250: POP
// if p then
27251: LD_VAR 0 11
27255: IFFALSE 27280
// result := Replace ( result , 3 , p ) ;
27257: LD_ADDR_VAR 0 2
27261: PUSH
27262: LD_VAR 0 2
27266: PPUSH
27267: LD_INT 3
27269: PPUSH
27270: LD_VAR 0 11
27274: PPUSH
27275: CALL_OW 1
27279: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27280: LD_VAR 0 4
27284: PUSH
27285: LD_INT 6
27287: GREATER
27288: PUSH
27289: LD_VAR 0 6
27293: PUSH
27294: LD_INT 6
27296: LESS
27297: AND
27298: IFFALSE 27492
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27300: LD_ADDR_VAR 0 9
27304: PUSH
27305: LD_VAR 0 4
27309: PUSH
27310: LD_VAR 0 8
27314: PUSH
27315: LD_VAR 0 7
27319: UNION
27320: PUSH
27321: LD_VAR 0 6
27325: UNION
27326: DIFF
27327: PPUSH
27328: LD_INT 2
27330: PPUSH
27331: CALL 85158 0 2
27335: ST_TO_ADDR
// p := [ ] ;
27336: LD_ADDR_VAR 0 11
27340: PUSH
27341: EMPTY
27342: ST_TO_ADDR
// if sort then
27343: LD_VAR 0 9
27347: IFFALSE 27463
// for i = 1 to 6 - eng do
27349: LD_ADDR_VAR 0 3
27353: PUSH
27354: DOUBLE
27355: LD_INT 1
27357: DEC
27358: ST_TO_ADDR
27359: LD_INT 6
27361: PUSH
27362: LD_VAR 0 6
27366: MINUS
27367: PUSH
27368: FOR_TO
27369: IFFALSE 27461
// begin if i = sort then
27371: LD_VAR 0 3
27375: PUSH
27376: LD_VAR 0 9
27380: EQUAL
27381: IFFALSE 27385
// break ;
27383: GO 27461
// if GetClass ( i ) = 2 then
27385: LD_VAR 0 3
27389: PPUSH
27390: CALL_OW 257
27394: PUSH
27395: LD_INT 2
27397: EQUAL
27398: IFFALSE 27402
// continue ;
27400: GO 27368
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27402: LD_ADDR_VAR 0 11
27406: PUSH
27407: LD_VAR 0 11
27411: PPUSH
27412: LD_VAR 0 11
27416: PUSH
27417: LD_INT 1
27419: PLUS
27420: PPUSH
27421: LD_VAR 0 9
27425: PUSH
27426: LD_VAR 0 3
27430: ARRAY
27431: PPUSH
27432: CALL_OW 2
27436: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27437: LD_ADDR_VAR 0 4
27441: PUSH
27442: LD_VAR 0 4
27446: PUSH
27447: LD_VAR 0 9
27451: PUSH
27452: LD_VAR 0 3
27456: ARRAY
27457: DIFF
27458: ST_TO_ADDR
// end ;
27459: GO 27368
27461: POP
27462: POP
// if p then
27463: LD_VAR 0 11
27467: IFFALSE 27492
// result := Replace ( result , 2 , p ) ;
27469: LD_ADDR_VAR 0 2
27473: PUSH
27474: LD_VAR 0 2
27478: PPUSH
27479: LD_INT 2
27481: PPUSH
27482: LD_VAR 0 11
27486: PPUSH
27487: CALL_OW 1
27491: ST_TO_ADDR
// end ; exit ;
27492: GO 28880
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27494: LD_EXP 115
27498: PUSH
27499: LD_EXP 114
27503: PUSH
27504: LD_VAR 0 1
27508: ARRAY
27509: ARRAY
27510: NOT
27511: PUSH
27512: LD_EXP 88
27516: PUSH
27517: LD_VAR 0 1
27521: ARRAY
27522: PPUSH
27523: LD_INT 30
27525: PUSH
27526: LD_INT 3
27528: PUSH
27529: EMPTY
27530: LIST
27531: LIST
27532: PPUSH
27533: CALL_OW 72
27537: AND
27538: PUSH
27539: LD_EXP 93
27543: PUSH
27544: LD_VAR 0 1
27548: ARRAY
27549: AND
27550: IFFALSE 28158
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27552: LD_ADDR_EXP 130
27556: PUSH
27557: LD_EXP 130
27561: PPUSH
27562: LD_VAR 0 1
27566: PPUSH
27567: LD_INT 5
27569: PPUSH
27570: CALL_OW 1
27574: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27575: LD_ADDR_VAR 0 2
27579: PUSH
27580: LD_INT 0
27582: PUSH
27583: LD_INT 0
27585: PUSH
27586: LD_INT 0
27588: PUSH
27589: LD_INT 0
27591: PUSH
27592: EMPTY
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: ST_TO_ADDR
// if sci > 1 then
27598: LD_VAR 0 8
27602: PUSH
27603: LD_INT 1
27605: GREATER
27606: IFFALSE 27634
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27608: LD_ADDR_VAR 0 4
27612: PUSH
27613: LD_VAR 0 4
27617: PUSH
27618: LD_VAR 0 8
27622: PUSH
27623: LD_VAR 0 8
27627: PUSH
27628: LD_INT 1
27630: ARRAY
27631: DIFF
27632: DIFF
27633: ST_TO_ADDR
// if tmp and not sci then
27634: LD_VAR 0 4
27638: PUSH
27639: LD_VAR 0 8
27643: NOT
27644: AND
27645: IFFALSE 27714
// begin sort := SortBySkill ( tmp , 4 ) ;
27647: LD_ADDR_VAR 0 9
27651: PUSH
27652: LD_VAR 0 4
27656: PPUSH
27657: LD_INT 4
27659: PPUSH
27660: CALL 85158 0 2
27664: ST_TO_ADDR
// if sort then
27665: LD_VAR 0 9
27669: IFFALSE 27685
// p := sort [ 1 ] ;
27671: LD_ADDR_VAR 0 11
27675: PUSH
27676: LD_VAR 0 9
27680: PUSH
27681: LD_INT 1
27683: ARRAY
27684: ST_TO_ADDR
// if p then
27685: LD_VAR 0 11
27689: IFFALSE 27714
// result := Replace ( result , 4 , p ) ;
27691: LD_ADDR_VAR 0 2
27695: PUSH
27696: LD_VAR 0 2
27700: PPUSH
27701: LD_INT 4
27703: PPUSH
27704: LD_VAR 0 11
27708: PPUSH
27709: CALL_OW 1
27713: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27714: LD_ADDR_VAR 0 4
27718: PUSH
27719: LD_VAR 0 4
27723: PUSH
27724: LD_VAR 0 7
27728: DIFF
27729: ST_TO_ADDR
// if tmp and mech < 6 then
27730: LD_VAR 0 4
27734: PUSH
27735: LD_VAR 0 7
27739: PUSH
27740: LD_INT 6
27742: LESS
27743: AND
27744: IFFALSE 27932
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27746: LD_ADDR_VAR 0 9
27750: PUSH
27751: LD_VAR 0 4
27755: PUSH
27756: LD_VAR 0 8
27760: PUSH
27761: LD_VAR 0 7
27765: UNION
27766: DIFF
27767: PPUSH
27768: LD_INT 3
27770: PPUSH
27771: CALL 85158 0 2
27775: ST_TO_ADDR
// p := [ ] ;
27776: LD_ADDR_VAR 0 11
27780: PUSH
27781: EMPTY
27782: ST_TO_ADDR
// if sort then
27783: LD_VAR 0 9
27787: IFFALSE 27903
// for i = 1 to 6 - mech do
27789: LD_ADDR_VAR 0 3
27793: PUSH
27794: DOUBLE
27795: LD_INT 1
27797: DEC
27798: ST_TO_ADDR
27799: LD_INT 6
27801: PUSH
27802: LD_VAR 0 7
27806: MINUS
27807: PUSH
27808: FOR_TO
27809: IFFALSE 27901
// begin if i = sort then
27811: LD_VAR 0 3
27815: PUSH
27816: LD_VAR 0 9
27820: EQUAL
27821: IFFALSE 27825
// break ;
27823: GO 27901
// if GetClass ( i ) = 3 then
27825: LD_VAR 0 3
27829: PPUSH
27830: CALL_OW 257
27834: PUSH
27835: LD_INT 3
27837: EQUAL
27838: IFFALSE 27842
// continue ;
27840: GO 27808
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27842: LD_ADDR_VAR 0 11
27846: PUSH
27847: LD_VAR 0 11
27851: PPUSH
27852: LD_VAR 0 11
27856: PUSH
27857: LD_INT 1
27859: PLUS
27860: PPUSH
27861: LD_VAR 0 9
27865: PUSH
27866: LD_VAR 0 3
27870: ARRAY
27871: PPUSH
27872: CALL_OW 2
27876: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27877: LD_ADDR_VAR 0 4
27881: PUSH
27882: LD_VAR 0 4
27886: PUSH
27887: LD_VAR 0 9
27891: PUSH
27892: LD_VAR 0 3
27896: ARRAY
27897: DIFF
27898: ST_TO_ADDR
// end ;
27899: GO 27808
27901: POP
27902: POP
// if p then
27903: LD_VAR 0 11
27907: IFFALSE 27932
// result := Replace ( result , 3 , p ) ;
27909: LD_ADDR_VAR 0 2
27913: PUSH
27914: LD_VAR 0 2
27918: PPUSH
27919: LD_INT 3
27921: PPUSH
27922: LD_VAR 0 11
27926: PPUSH
27927: CALL_OW 1
27931: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27932: LD_ADDR_VAR 0 4
27936: PUSH
27937: LD_VAR 0 4
27941: PUSH
27942: LD_VAR 0 6
27946: DIFF
27947: ST_TO_ADDR
// if tmp and eng < 6 then
27948: LD_VAR 0 4
27952: PUSH
27953: LD_VAR 0 6
27957: PUSH
27958: LD_INT 6
27960: LESS
27961: AND
27962: IFFALSE 28156
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27964: LD_ADDR_VAR 0 9
27968: PUSH
27969: LD_VAR 0 4
27973: PUSH
27974: LD_VAR 0 8
27978: PUSH
27979: LD_VAR 0 7
27983: UNION
27984: PUSH
27985: LD_VAR 0 6
27989: UNION
27990: DIFF
27991: PPUSH
27992: LD_INT 2
27994: PPUSH
27995: CALL 85158 0 2
27999: ST_TO_ADDR
// p := [ ] ;
28000: LD_ADDR_VAR 0 11
28004: PUSH
28005: EMPTY
28006: ST_TO_ADDR
// if sort then
28007: LD_VAR 0 9
28011: IFFALSE 28127
// for i = 1 to 6 - eng do
28013: LD_ADDR_VAR 0 3
28017: PUSH
28018: DOUBLE
28019: LD_INT 1
28021: DEC
28022: ST_TO_ADDR
28023: LD_INT 6
28025: PUSH
28026: LD_VAR 0 6
28030: MINUS
28031: PUSH
28032: FOR_TO
28033: IFFALSE 28125
// begin if i = sort then
28035: LD_VAR 0 3
28039: PUSH
28040: LD_VAR 0 9
28044: EQUAL
28045: IFFALSE 28049
// break ;
28047: GO 28125
// if GetClass ( i ) = 2 then
28049: LD_VAR 0 3
28053: PPUSH
28054: CALL_OW 257
28058: PUSH
28059: LD_INT 2
28061: EQUAL
28062: IFFALSE 28066
// continue ;
28064: GO 28032
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28066: LD_ADDR_VAR 0 11
28070: PUSH
28071: LD_VAR 0 11
28075: PPUSH
28076: LD_VAR 0 11
28080: PUSH
28081: LD_INT 1
28083: PLUS
28084: PPUSH
28085: LD_VAR 0 9
28089: PUSH
28090: LD_VAR 0 3
28094: ARRAY
28095: PPUSH
28096: CALL_OW 2
28100: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28101: LD_ADDR_VAR 0 4
28105: PUSH
28106: LD_VAR 0 4
28110: PUSH
28111: LD_VAR 0 9
28115: PUSH
28116: LD_VAR 0 3
28120: ARRAY
28121: DIFF
28122: ST_TO_ADDR
// end ;
28123: GO 28032
28125: POP
28126: POP
// if p then
28127: LD_VAR 0 11
28131: IFFALSE 28156
// result := Replace ( result , 2 , p ) ;
28133: LD_ADDR_VAR 0 2
28137: PUSH
28138: LD_VAR 0 2
28142: PPUSH
28143: LD_INT 2
28145: PPUSH
28146: LD_VAR 0 11
28150: PPUSH
28151: CALL_OW 1
28155: ST_TO_ADDR
// end ; exit ;
28156: GO 28880
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28158: LD_EXP 115
28162: PUSH
28163: LD_EXP 114
28167: PUSH
28168: LD_VAR 0 1
28172: ARRAY
28173: ARRAY
28174: NOT
28175: PUSH
28176: LD_EXP 88
28180: PUSH
28181: LD_VAR 0 1
28185: ARRAY
28186: PPUSH
28187: LD_INT 30
28189: PUSH
28190: LD_INT 3
28192: PUSH
28193: EMPTY
28194: LIST
28195: LIST
28196: PPUSH
28197: CALL_OW 72
28201: AND
28202: PUSH
28203: LD_EXP 93
28207: PUSH
28208: LD_VAR 0 1
28212: ARRAY
28213: NOT
28214: AND
28215: IFFALSE 28880
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28217: LD_ADDR_EXP 130
28221: PUSH
28222: LD_EXP 130
28226: PPUSH
28227: LD_VAR 0 1
28231: PPUSH
28232: LD_INT 6
28234: PPUSH
28235: CALL_OW 1
28239: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28240: LD_ADDR_VAR 0 2
28244: PUSH
28245: LD_INT 0
28247: PUSH
28248: LD_INT 0
28250: PUSH
28251: LD_INT 0
28253: PUSH
28254: LD_INT 0
28256: PUSH
28257: EMPTY
28258: LIST
28259: LIST
28260: LIST
28261: LIST
28262: ST_TO_ADDR
// if sci >= 1 then
28263: LD_VAR 0 8
28267: PUSH
28268: LD_INT 1
28270: GREATEREQUAL
28271: IFFALSE 28293
// tmp := tmp diff sci [ 1 ] ;
28273: LD_ADDR_VAR 0 4
28277: PUSH
28278: LD_VAR 0 4
28282: PUSH
28283: LD_VAR 0 8
28287: PUSH
28288: LD_INT 1
28290: ARRAY
28291: DIFF
28292: ST_TO_ADDR
// if tmp and not sci then
28293: LD_VAR 0 4
28297: PUSH
28298: LD_VAR 0 8
28302: NOT
28303: AND
28304: IFFALSE 28373
// begin sort := SortBySkill ( tmp , 4 ) ;
28306: LD_ADDR_VAR 0 9
28310: PUSH
28311: LD_VAR 0 4
28315: PPUSH
28316: LD_INT 4
28318: PPUSH
28319: CALL 85158 0 2
28323: ST_TO_ADDR
// if sort then
28324: LD_VAR 0 9
28328: IFFALSE 28344
// p := sort [ 1 ] ;
28330: LD_ADDR_VAR 0 11
28334: PUSH
28335: LD_VAR 0 9
28339: PUSH
28340: LD_INT 1
28342: ARRAY
28343: ST_TO_ADDR
// if p then
28344: LD_VAR 0 11
28348: IFFALSE 28373
// result := Replace ( result , 4 , p ) ;
28350: LD_ADDR_VAR 0 2
28354: PUSH
28355: LD_VAR 0 2
28359: PPUSH
28360: LD_INT 4
28362: PPUSH
28363: LD_VAR 0 11
28367: PPUSH
28368: CALL_OW 1
28372: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28373: LD_ADDR_VAR 0 4
28377: PUSH
28378: LD_VAR 0 4
28382: PUSH
28383: LD_VAR 0 7
28387: DIFF
28388: ST_TO_ADDR
// if tmp and mech < 6 then
28389: LD_VAR 0 4
28393: PUSH
28394: LD_VAR 0 7
28398: PUSH
28399: LD_INT 6
28401: LESS
28402: AND
28403: IFFALSE 28585
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28405: LD_ADDR_VAR 0 9
28409: PUSH
28410: LD_VAR 0 4
28414: PUSH
28415: LD_VAR 0 7
28419: DIFF
28420: PPUSH
28421: LD_INT 3
28423: PPUSH
28424: CALL 85158 0 2
28428: ST_TO_ADDR
// p := [ ] ;
28429: LD_ADDR_VAR 0 11
28433: PUSH
28434: EMPTY
28435: ST_TO_ADDR
// if sort then
28436: LD_VAR 0 9
28440: IFFALSE 28556
// for i = 1 to 6 - mech do
28442: LD_ADDR_VAR 0 3
28446: PUSH
28447: DOUBLE
28448: LD_INT 1
28450: DEC
28451: ST_TO_ADDR
28452: LD_INT 6
28454: PUSH
28455: LD_VAR 0 7
28459: MINUS
28460: PUSH
28461: FOR_TO
28462: IFFALSE 28554
// begin if i = sort then
28464: LD_VAR 0 3
28468: PUSH
28469: LD_VAR 0 9
28473: EQUAL
28474: IFFALSE 28478
// break ;
28476: GO 28554
// if GetClass ( i ) = 3 then
28478: LD_VAR 0 3
28482: PPUSH
28483: CALL_OW 257
28487: PUSH
28488: LD_INT 3
28490: EQUAL
28491: IFFALSE 28495
// continue ;
28493: GO 28461
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28495: LD_ADDR_VAR 0 11
28499: PUSH
28500: LD_VAR 0 11
28504: PPUSH
28505: LD_VAR 0 11
28509: PUSH
28510: LD_INT 1
28512: PLUS
28513: PPUSH
28514: LD_VAR 0 9
28518: PUSH
28519: LD_VAR 0 3
28523: ARRAY
28524: PPUSH
28525: CALL_OW 2
28529: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28530: LD_ADDR_VAR 0 4
28534: PUSH
28535: LD_VAR 0 4
28539: PUSH
28540: LD_VAR 0 9
28544: PUSH
28545: LD_VAR 0 3
28549: ARRAY
28550: DIFF
28551: ST_TO_ADDR
// end ;
28552: GO 28461
28554: POP
28555: POP
// if p then
28556: LD_VAR 0 11
28560: IFFALSE 28585
// result := Replace ( result , 3 , p ) ;
28562: LD_ADDR_VAR 0 2
28566: PUSH
28567: LD_VAR 0 2
28571: PPUSH
28572: LD_INT 3
28574: PPUSH
28575: LD_VAR 0 11
28579: PPUSH
28580: CALL_OW 1
28584: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28585: LD_ADDR_VAR 0 4
28589: PUSH
28590: LD_VAR 0 4
28594: PUSH
28595: LD_VAR 0 6
28599: DIFF
28600: ST_TO_ADDR
// if tmp and eng < 4 then
28601: LD_VAR 0 4
28605: PUSH
28606: LD_VAR 0 6
28610: PUSH
28611: LD_INT 4
28613: LESS
28614: AND
28615: IFFALSE 28805
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28617: LD_ADDR_VAR 0 9
28621: PUSH
28622: LD_VAR 0 4
28626: PUSH
28627: LD_VAR 0 7
28631: PUSH
28632: LD_VAR 0 6
28636: UNION
28637: DIFF
28638: PPUSH
28639: LD_INT 2
28641: PPUSH
28642: CALL 85158 0 2
28646: ST_TO_ADDR
// p := [ ] ;
28647: LD_ADDR_VAR 0 11
28651: PUSH
28652: EMPTY
28653: ST_TO_ADDR
// if sort then
28654: LD_VAR 0 9
28658: IFFALSE 28774
// for i = 1 to 4 - eng do
28660: LD_ADDR_VAR 0 3
28664: PUSH
28665: DOUBLE
28666: LD_INT 1
28668: DEC
28669: ST_TO_ADDR
28670: LD_INT 4
28672: PUSH
28673: LD_VAR 0 6
28677: MINUS
28678: PUSH
28679: FOR_TO
28680: IFFALSE 28772
// begin if i = sort then
28682: LD_VAR 0 3
28686: PUSH
28687: LD_VAR 0 9
28691: EQUAL
28692: IFFALSE 28696
// break ;
28694: GO 28772
// if GetClass ( i ) = 2 then
28696: LD_VAR 0 3
28700: PPUSH
28701: CALL_OW 257
28705: PUSH
28706: LD_INT 2
28708: EQUAL
28709: IFFALSE 28713
// continue ;
28711: GO 28679
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28713: LD_ADDR_VAR 0 11
28717: PUSH
28718: LD_VAR 0 11
28722: PPUSH
28723: LD_VAR 0 11
28727: PUSH
28728: LD_INT 1
28730: PLUS
28731: PPUSH
28732: LD_VAR 0 9
28736: PUSH
28737: LD_VAR 0 3
28741: ARRAY
28742: PPUSH
28743: CALL_OW 2
28747: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28748: LD_ADDR_VAR 0 4
28752: PUSH
28753: LD_VAR 0 4
28757: PUSH
28758: LD_VAR 0 9
28762: PUSH
28763: LD_VAR 0 3
28767: ARRAY
28768: DIFF
28769: ST_TO_ADDR
// end ;
28770: GO 28679
28772: POP
28773: POP
// if p then
28774: LD_VAR 0 11
28778: IFFALSE 28803
// result := Replace ( result , 2 , p ) ;
28780: LD_ADDR_VAR 0 2
28784: PUSH
28785: LD_VAR 0 2
28789: PPUSH
28790: LD_INT 2
28792: PPUSH
28793: LD_VAR 0 11
28797: PPUSH
28798: CALL_OW 1
28802: ST_TO_ADDR
// end else
28803: GO 28849
// for i = eng downto 5 do
28805: LD_ADDR_VAR 0 3
28809: PUSH
28810: DOUBLE
28811: LD_VAR 0 6
28815: INC
28816: ST_TO_ADDR
28817: LD_INT 5
28819: PUSH
28820: FOR_DOWNTO
28821: IFFALSE 28847
// tmp := tmp union eng [ i ] ;
28823: LD_ADDR_VAR 0 4
28827: PUSH
28828: LD_VAR 0 4
28832: PUSH
28833: LD_VAR 0 6
28837: PUSH
28838: LD_VAR 0 3
28842: ARRAY
28843: UNION
28844: ST_TO_ADDR
28845: GO 28820
28847: POP
28848: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28849: LD_ADDR_VAR 0 2
28853: PUSH
28854: LD_VAR 0 2
28858: PPUSH
28859: LD_INT 1
28861: PPUSH
28862: LD_VAR 0 4
28866: PUSH
28867: LD_VAR 0 5
28871: DIFF
28872: PPUSH
28873: CALL_OW 1
28877: ST_TO_ADDR
// exit ;
28878: GO 28880
// end ; end ;
28880: LD_VAR 0 2
28884: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28885: LD_INT 0
28887: PPUSH
28888: PPUSH
28889: PPUSH
// if not mc_bases then
28890: LD_EXP 88
28894: NOT
28895: IFFALSE 28899
// exit ;
28897: GO 29005
// for i = 1 to mc_bases do
28899: LD_ADDR_VAR 0 2
28903: PUSH
28904: DOUBLE
28905: LD_INT 1
28907: DEC
28908: ST_TO_ADDR
28909: LD_EXP 88
28913: PUSH
28914: FOR_TO
28915: IFFALSE 28996
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28917: LD_ADDR_VAR 0 3
28921: PUSH
28922: LD_EXP 88
28926: PUSH
28927: LD_VAR 0 2
28931: ARRAY
28932: PPUSH
28933: LD_INT 21
28935: PUSH
28936: LD_INT 3
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: PUSH
28943: LD_INT 3
28945: PUSH
28946: LD_INT 24
28948: PUSH
28949: LD_INT 1000
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: EMPTY
28961: LIST
28962: LIST
28963: PPUSH
28964: CALL_OW 72
28968: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28969: LD_ADDR_EXP 89
28973: PUSH
28974: LD_EXP 89
28978: PPUSH
28979: LD_VAR 0 2
28983: PPUSH
28984: LD_VAR 0 3
28988: PPUSH
28989: CALL_OW 1
28993: ST_TO_ADDR
// end ;
28994: GO 28914
28996: POP
28997: POP
// RaiseSailEvent ( 101 ) ;
28998: LD_INT 101
29000: PPUSH
29001: CALL_OW 427
// end ;
29005: LD_VAR 0 1
29009: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29010: LD_INT 0
29012: PPUSH
29013: PPUSH
29014: PPUSH
29015: PPUSH
29016: PPUSH
29017: PPUSH
29018: PPUSH
// if not mc_bases then
29019: LD_EXP 88
29023: NOT
29024: IFFALSE 29028
// exit ;
29026: GO 29590
// for i = 1 to mc_bases do
29028: LD_ADDR_VAR 0 2
29032: PUSH
29033: DOUBLE
29034: LD_INT 1
29036: DEC
29037: ST_TO_ADDR
29038: LD_EXP 88
29042: PUSH
29043: FOR_TO
29044: IFFALSE 29581
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
29046: LD_ADDR_VAR 0 5
29050: PUSH
29051: LD_EXP 88
29055: PUSH
29056: LD_VAR 0 2
29060: ARRAY
29061: PUSH
29062: LD_EXP 117
29066: PUSH
29067: LD_VAR 0 2
29071: ARRAY
29072: UNION
29073: PPUSH
29074: LD_INT 21
29076: PUSH
29077: LD_INT 1
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: LD_INT 1
29086: PUSH
29087: LD_INT 3
29089: PUSH
29090: LD_INT 54
29092: PUSH
29093: EMPTY
29094: LIST
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: LD_INT 3
29102: PUSH
29103: LD_INT 24
29105: PUSH
29106: LD_INT 800
29108: PUSH
29109: EMPTY
29110: LIST
29111: LIST
29112: PUSH
29113: EMPTY
29114: LIST
29115: LIST
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: LIST
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PPUSH
29126: CALL_OW 72
29130: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29131: LD_ADDR_VAR 0 6
29135: PUSH
29136: LD_EXP 88
29140: PUSH
29141: LD_VAR 0 2
29145: ARRAY
29146: PPUSH
29147: LD_INT 21
29149: PUSH
29150: LD_INT 1
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PUSH
29157: LD_INT 1
29159: PUSH
29160: LD_INT 3
29162: PUSH
29163: LD_INT 54
29165: PUSH
29166: EMPTY
29167: LIST
29168: PUSH
29169: EMPTY
29170: LIST
29171: LIST
29172: PUSH
29173: LD_INT 3
29175: PUSH
29176: LD_INT 24
29178: PUSH
29179: LD_INT 250
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: LIST
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: PPUSH
29199: CALL_OW 72
29203: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29204: LD_ADDR_VAR 0 7
29208: PUSH
29209: LD_VAR 0 5
29213: PUSH
29214: LD_VAR 0 6
29218: DIFF
29219: ST_TO_ADDR
// if not need_heal_1 then
29220: LD_VAR 0 6
29224: NOT
29225: IFFALSE 29258
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29227: LD_ADDR_EXP 91
29231: PUSH
29232: LD_EXP 91
29236: PPUSH
29237: LD_VAR 0 2
29241: PUSH
29242: LD_INT 1
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PPUSH
29249: EMPTY
29250: PPUSH
29251: CALL 55609 0 3
29255: ST_TO_ADDR
29256: GO 29328
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29258: LD_ADDR_EXP 91
29262: PUSH
29263: LD_EXP 91
29267: PPUSH
29268: LD_VAR 0 2
29272: PUSH
29273: LD_INT 1
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PPUSH
29280: LD_EXP 91
29284: PUSH
29285: LD_VAR 0 2
29289: ARRAY
29290: PUSH
29291: LD_INT 1
29293: ARRAY
29294: PPUSH
29295: LD_INT 3
29297: PUSH
29298: LD_INT 24
29300: PUSH
29301: LD_INT 1000
29303: PUSH
29304: EMPTY
29305: LIST
29306: LIST
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PPUSH
29312: CALL_OW 72
29316: PUSH
29317: LD_VAR 0 6
29321: UNION
29322: PPUSH
29323: CALL 55609 0 3
29327: ST_TO_ADDR
// if not need_heal_2 then
29328: LD_VAR 0 7
29332: NOT
29333: IFFALSE 29366
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29335: LD_ADDR_EXP 91
29339: PUSH
29340: LD_EXP 91
29344: PPUSH
29345: LD_VAR 0 2
29349: PUSH
29350: LD_INT 2
29352: PUSH
29353: EMPTY
29354: LIST
29355: LIST
29356: PPUSH
29357: EMPTY
29358: PPUSH
29359: CALL 55609 0 3
29363: ST_TO_ADDR
29364: GO 29398
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29366: LD_ADDR_EXP 91
29370: PUSH
29371: LD_EXP 91
29375: PPUSH
29376: LD_VAR 0 2
29380: PUSH
29381: LD_INT 2
29383: PUSH
29384: EMPTY
29385: LIST
29386: LIST
29387: PPUSH
29388: LD_VAR 0 7
29392: PPUSH
29393: CALL 55609 0 3
29397: ST_TO_ADDR
// if need_heal_2 then
29398: LD_VAR 0 7
29402: IFFALSE 29563
// for j in need_heal_2 do
29404: LD_ADDR_VAR 0 3
29408: PUSH
29409: LD_VAR 0 7
29413: PUSH
29414: FOR_IN
29415: IFFALSE 29561
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29417: LD_ADDR_VAR 0 5
29421: PUSH
29422: LD_EXP 88
29426: PUSH
29427: LD_VAR 0 2
29431: ARRAY
29432: PPUSH
29433: LD_INT 2
29435: PUSH
29436: LD_INT 30
29438: PUSH
29439: LD_INT 6
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: LD_INT 30
29448: PUSH
29449: LD_INT 7
29451: PUSH
29452: EMPTY
29453: LIST
29454: LIST
29455: PUSH
29456: LD_INT 30
29458: PUSH
29459: LD_INT 8
29461: PUSH
29462: EMPTY
29463: LIST
29464: LIST
29465: PUSH
29466: LD_INT 30
29468: PUSH
29469: LD_INT 0
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 30
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: LIST
29490: LIST
29491: LIST
29492: LIST
29493: PPUSH
29494: CALL_OW 72
29498: ST_TO_ADDR
// if tmp then
29499: LD_VAR 0 5
29503: IFFALSE 29559
// begin k := NearestUnitToUnit ( tmp , j ) ;
29505: LD_ADDR_VAR 0 4
29509: PUSH
29510: LD_VAR 0 5
29514: PPUSH
29515: LD_VAR 0 3
29519: PPUSH
29520: CALL_OW 74
29524: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29525: LD_VAR 0 3
29529: PPUSH
29530: LD_VAR 0 4
29534: PPUSH
29535: CALL_OW 296
29539: PUSH
29540: LD_INT 5
29542: GREATER
29543: IFFALSE 29559
// ComMoveUnit ( j , k ) ;
29545: LD_VAR 0 3
29549: PPUSH
29550: LD_VAR 0 4
29554: PPUSH
29555: CALL_OW 112
// end ; end ;
29559: GO 29414
29561: POP
29562: POP
// if not need_heal_1 and not need_heal_2 then
29563: LD_VAR 0 6
29567: NOT
29568: PUSH
29569: LD_VAR 0 7
29573: NOT
29574: AND
29575: IFFALSE 29579
// continue ;
29577: GO 29043
// end ;
29579: GO 29043
29581: POP
29582: POP
// RaiseSailEvent ( 102 ) ;
29583: LD_INT 102
29585: PPUSH
29586: CALL_OW 427
// end ;
29590: LD_VAR 0 1
29594: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29595: LD_INT 0
29597: PPUSH
29598: PPUSH
29599: PPUSH
29600: PPUSH
29601: PPUSH
29602: PPUSH
29603: PPUSH
29604: PPUSH
// if not mc_bases then
29605: LD_EXP 88
29609: NOT
29610: IFFALSE 29614
// exit ;
29612: GO 30449
// for i = 1 to mc_bases do
29614: LD_ADDR_VAR 0 2
29618: PUSH
29619: DOUBLE
29620: LD_INT 1
29622: DEC
29623: ST_TO_ADDR
29624: LD_EXP 88
29628: PUSH
29629: FOR_TO
29630: IFFALSE 30447
// begin if not mc_building_need_repair [ i ] then
29632: LD_EXP 89
29636: PUSH
29637: LD_VAR 0 2
29641: ARRAY
29642: NOT
29643: IFFALSE 29817
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29645: LD_ADDR_VAR 0 6
29649: PUSH
29650: LD_EXP 107
29654: PUSH
29655: LD_VAR 0 2
29659: ARRAY
29660: PPUSH
29661: LD_INT 3
29663: PUSH
29664: LD_INT 24
29666: PUSH
29667: LD_INT 1000
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PUSH
29674: EMPTY
29675: LIST
29676: LIST
29677: PUSH
29678: LD_INT 2
29680: PUSH
29681: LD_INT 34
29683: PUSH
29684: LD_INT 13
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: PUSH
29691: LD_INT 34
29693: PUSH
29694: LD_INT 52
29696: PUSH
29697: EMPTY
29698: LIST
29699: LIST
29700: PUSH
29701: EMPTY
29702: LIST
29703: LIST
29704: LIST
29705: PUSH
29706: EMPTY
29707: LIST
29708: LIST
29709: PPUSH
29710: CALL_OW 72
29714: ST_TO_ADDR
// if cranes then
29715: LD_VAR 0 6
29719: IFFALSE 29781
// for j in cranes do
29721: LD_ADDR_VAR 0 3
29725: PUSH
29726: LD_VAR 0 6
29730: PUSH
29731: FOR_IN
29732: IFFALSE 29779
// if not IsInArea ( j , mc_parking [ i ] ) then
29734: LD_VAR 0 3
29738: PPUSH
29739: LD_EXP 112
29743: PUSH
29744: LD_VAR 0 2
29748: ARRAY
29749: PPUSH
29750: CALL_OW 308
29754: NOT
29755: IFFALSE 29777
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29757: LD_VAR 0 3
29761: PPUSH
29762: LD_EXP 112
29766: PUSH
29767: LD_VAR 0 2
29771: ARRAY
29772: PPUSH
29773: CALL_OW 113
29777: GO 29731
29779: POP
29780: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29781: LD_ADDR_EXP 90
29785: PUSH
29786: LD_EXP 90
29790: PPUSH
29791: LD_VAR 0 2
29795: PPUSH
29796: EMPTY
29797: PPUSH
29798: CALL_OW 1
29802: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29803: LD_VAR 0 2
29807: PPUSH
29808: LD_INT 101
29810: PPUSH
29811: CALL 24718 0 2
// continue ;
29815: GO 29629
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29817: LD_ADDR_EXP 94
29821: PUSH
29822: LD_EXP 94
29826: PPUSH
29827: LD_VAR 0 2
29831: PPUSH
29832: EMPTY
29833: PPUSH
29834: CALL_OW 1
29838: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29839: LD_VAR 0 2
29843: PPUSH
29844: LD_INT 103
29846: PPUSH
29847: CALL 24718 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
29851: LD_ADDR_VAR 0 5
29855: PUSH
29856: LD_EXP 88
29860: PUSH
29861: LD_VAR 0 2
29865: ARRAY
29866: PUSH
29867: LD_EXP 117
29871: PUSH
29872: LD_VAR 0 2
29876: ARRAY
29877: UNION
29878: PPUSH
29879: LD_INT 2
29881: PUSH
29882: LD_INT 25
29884: PUSH
29885: LD_INT 2
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 25
29894: PUSH
29895: LD_INT 16
29897: PUSH
29898: EMPTY
29899: LIST
29900: LIST
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: LIST
29906: PUSH
29907: EMPTY
29908: LIST
29909: PPUSH
29910: CALL_OW 72
29914: PUSH
29915: LD_EXP 91
29919: PUSH
29920: LD_VAR 0 2
29924: ARRAY
29925: PUSH
29926: LD_INT 1
29928: ARRAY
29929: PUSH
29930: LD_EXP 91
29934: PUSH
29935: LD_VAR 0 2
29939: ARRAY
29940: PUSH
29941: LD_INT 2
29943: ARRAY
29944: UNION
29945: DIFF
29946: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29947: LD_ADDR_VAR 0 6
29951: PUSH
29952: LD_EXP 107
29956: PUSH
29957: LD_VAR 0 2
29961: ARRAY
29962: PPUSH
29963: LD_INT 2
29965: PUSH
29966: LD_INT 34
29968: PUSH
29969: LD_INT 13
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 34
29978: PUSH
29979: LD_INT 52
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: LIST
29990: PPUSH
29991: CALL_OW 72
29995: ST_TO_ADDR
// if cranes then
29996: LD_VAR 0 6
30000: IFFALSE 30136
// begin for j in cranes do
30002: LD_ADDR_VAR 0 3
30006: PUSH
30007: LD_VAR 0 6
30011: PUSH
30012: FOR_IN
30013: IFFALSE 30134
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
30015: LD_VAR 0 3
30019: PPUSH
30020: CALL_OW 256
30024: PUSH
30025: LD_INT 500
30027: GREATEREQUAL
30028: PUSH
30029: LD_VAR 0 3
30033: PPUSH
30034: CALL_OW 314
30038: NOT
30039: AND
30040: IFFALSE 30074
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30042: LD_VAR 0 3
30046: PPUSH
30047: LD_EXP 89
30051: PUSH
30052: LD_VAR 0 2
30056: ARRAY
30057: PPUSH
30058: LD_VAR 0 3
30062: PPUSH
30063: CALL_OW 74
30067: PPUSH
30068: CALL_OW 130
30072: GO 30132
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30074: LD_VAR 0 3
30078: PPUSH
30079: CALL_OW 256
30083: PUSH
30084: LD_INT 500
30086: LESS
30087: PUSH
30088: LD_VAR 0 3
30092: PPUSH
30093: LD_EXP 112
30097: PUSH
30098: LD_VAR 0 2
30102: ARRAY
30103: PPUSH
30104: CALL_OW 308
30108: NOT
30109: AND
30110: IFFALSE 30132
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30112: LD_VAR 0 3
30116: PPUSH
30117: LD_EXP 112
30121: PUSH
30122: LD_VAR 0 2
30126: ARRAY
30127: PPUSH
30128: CALL_OW 113
30132: GO 30012
30134: POP
30135: POP
// end ; if tmp > 3 then
30136: LD_VAR 0 5
30140: PUSH
30141: LD_INT 3
30143: GREATER
30144: IFFALSE 30164
// tmp := ShrinkArray ( tmp , 4 ) ;
30146: LD_ADDR_VAR 0 5
30150: PUSH
30151: LD_VAR 0 5
30155: PPUSH
30156: LD_INT 4
30158: PPUSH
30159: CALL 86848 0 2
30163: ST_TO_ADDR
// if not tmp then
30164: LD_VAR 0 5
30168: NOT
30169: IFFALSE 30173
// continue ;
30171: GO 29629
// for j in tmp do
30173: LD_ADDR_VAR 0 3
30177: PUSH
30178: LD_VAR 0 5
30182: PUSH
30183: FOR_IN
30184: IFFALSE 30443
// begin if IsInUnit ( j ) then
30186: LD_VAR 0 3
30190: PPUSH
30191: CALL_OW 310
30195: IFFALSE 30206
// ComExitBuilding ( j ) ;
30197: LD_VAR 0 3
30201: PPUSH
30202: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30206: LD_VAR 0 3
30210: PUSH
30211: LD_EXP 90
30215: PUSH
30216: LD_VAR 0 2
30220: ARRAY
30221: IN
30222: NOT
30223: IFFALSE 30281
// begin SetTag ( j , 101 ) ;
30225: LD_VAR 0 3
30229: PPUSH
30230: LD_INT 101
30232: PPUSH
30233: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30237: LD_ADDR_EXP 90
30241: PUSH
30242: LD_EXP 90
30246: PPUSH
30247: LD_VAR 0 2
30251: PUSH
30252: LD_EXP 90
30256: PUSH
30257: LD_VAR 0 2
30261: ARRAY
30262: PUSH
30263: LD_INT 1
30265: PLUS
30266: PUSH
30267: EMPTY
30268: LIST
30269: LIST
30270: PPUSH
30271: LD_VAR 0 3
30275: PPUSH
30276: CALL 55609 0 3
30280: ST_TO_ADDR
// end ; wait ( 1 ) ;
30281: LD_INT 1
30283: PPUSH
30284: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30288: LD_ADDR_VAR 0 7
30292: PUSH
30293: LD_EXP 89
30297: PUSH
30298: LD_VAR 0 2
30302: ARRAY
30303: ST_TO_ADDR
// if mc_scan [ i ] then
30304: LD_EXP 111
30308: PUSH
30309: LD_VAR 0 2
30313: ARRAY
30314: IFFALSE 30376
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30316: LD_ADDR_VAR 0 7
30320: PUSH
30321: LD_EXP 89
30325: PUSH
30326: LD_VAR 0 2
30330: ARRAY
30331: PPUSH
30332: LD_INT 3
30334: PUSH
30335: LD_INT 30
30337: PUSH
30338: LD_INT 32
30340: PUSH
30341: EMPTY
30342: LIST
30343: LIST
30344: PUSH
30345: LD_INT 30
30347: PUSH
30348: LD_INT 33
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 30
30357: PUSH
30358: LD_INT 31
30360: PUSH
30361: EMPTY
30362: LIST
30363: LIST
30364: PUSH
30365: EMPTY
30366: LIST
30367: LIST
30368: LIST
30369: LIST
30370: PPUSH
30371: CALL_OW 72
30375: ST_TO_ADDR
// if not to_repair_tmp then
30376: LD_VAR 0 7
30380: NOT
30381: IFFALSE 30385
// continue ;
30383: GO 30183
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30385: LD_ADDR_VAR 0 8
30389: PUSH
30390: LD_VAR 0 7
30394: PPUSH
30395: LD_VAR 0 3
30399: PPUSH
30400: CALL_OW 74
30404: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
30405: LD_VAR 0 8
30409: PPUSH
30410: LD_INT 16
30412: PPUSH
30413: CALL 58202 0 2
30417: PUSH
30418: LD_INT 4
30420: ARRAY
30421: PUSH
30422: LD_INT 5
30424: LESS
30425: IFFALSE 30441
// ComRepairBuilding ( j , to_repair ) ;
30427: LD_VAR 0 3
30431: PPUSH
30432: LD_VAR 0 8
30436: PPUSH
30437: CALL_OW 130
// end ;
30441: GO 30183
30443: POP
30444: POP
// end ;
30445: GO 29629
30447: POP
30448: POP
// end ;
30449: LD_VAR 0 1
30453: RET
// export function MC_Heal ; var i , j , tmp ; begin
30454: LD_INT 0
30456: PPUSH
30457: PPUSH
30458: PPUSH
30459: PPUSH
// if not mc_bases then
30460: LD_EXP 88
30464: NOT
30465: IFFALSE 30469
// exit ;
30467: GO 30871
// for i = 1 to mc_bases do
30469: LD_ADDR_VAR 0 2
30473: PUSH
30474: DOUBLE
30475: LD_INT 1
30477: DEC
30478: ST_TO_ADDR
30479: LD_EXP 88
30483: PUSH
30484: FOR_TO
30485: IFFALSE 30869
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30487: LD_EXP 91
30491: PUSH
30492: LD_VAR 0 2
30496: ARRAY
30497: PUSH
30498: LD_INT 1
30500: ARRAY
30501: NOT
30502: PUSH
30503: LD_EXP 91
30507: PUSH
30508: LD_VAR 0 2
30512: ARRAY
30513: PUSH
30514: LD_INT 2
30516: ARRAY
30517: NOT
30518: AND
30519: IFFALSE 30557
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30521: LD_ADDR_EXP 92
30525: PUSH
30526: LD_EXP 92
30530: PPUSH
30531: LD_VAR 0 2
30535: PPUSH
30536: EMPTY
30537: PPUSH
30538: CALL_OW 1
30542: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30543: LD_VAR 0 2
30547: PPUSH
30548: LD_INT 102
30550: PPUSH
30551: CALL 24718 0 2
// continue ;
30555: GO 30484
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30557: LD_ADDR_VAR 0 4
30561: PUSH
30562: LD_EXP 88
30566: PUSH
30567: LD_VAR 0 2
30571: ARRAY
30572: PPUSH
30573: LD_INT 25
30575: PUSH
30576: LD_INT 4
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PPUSH
30583: CALL_OW 72
30587: ST_TO_ADDR
// if not tmp then
30588: LD_VAR 0 4
30592: NOT
30593: IFFALSE 30597
// continue ;
30595: GO 30484
// if mc_taming [ i ] then
30597: LD_EXP 119
30601: PUSH
30602: LD_VAR 0 2
30606: ARRAY
30607: IFFALSE 30631
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30609: LD_ADDR_EXP 119
30613: PUSH
30614: LD_EXP 119
30618: PPUSH
30619: LD_VAR 0 2
30623: PPUSH
30624: EMPTY
30625: PPUSH
30626: CALL_OW 1
30630: ST_TO_ADDR
// for j in tmp do
30631: LD_ADDR_VAR 0 3
30635: PUSH
30636: LD_VAR 0 4
30640: PUSH
30641: FOR_IN
30642: IFFALSE 30865
// begin if IsInUnit ( j ) then
30644: LD_VAR 0 3
30648: PPUSH
30649: CALL_OW 310
30653: IFFALSE 30664
// ComExitBuilding ( j ) ;
30655: LD_VAR 0 3
30659: PPUSH
30660: CALL_OW 122
// if not j in mc_healers [ i ] then
30664: LD_VAR 0 3
30668: PUSH
30669: LD_EXP 92
30673: PUSH
30674: LD_VAR 0 2
30678: ARRAY
30679: IN
30680: NOT
30681: IFFALSE 30727
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30683: LD_ADDR_EXP 92
30687: PUSH
30688: LD_EXP 92
30692: PPUSH
30693: LD_VAR 0 2
30697: PUSH
30698: LD_EXP 92
30702: PUSH
30703: LD_VAR 0 2
30707: ARRAY
30708: PUSH
30709: LD_INT 1
30711: PLUS
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PPUSH
30717: LD_VAR 0 3
30721: PPUSH
30722: CALL 55609 0 3
30726: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30727: LD_VAR 0 3
30731: PPUSH
30732: CALL_OW 110
30736: PUSH
30737: LD_INT 102
30739: NONEQUAL
30740: IFFALSE 30754
// SetTag ( j , 102 ) ;
30742: LD_VAR 0 3
30746: PPUSH
30747: LD_INT 102
30749: PPUSH
30750: CALL_OW 109
// Wait ( 3 ) ;
30754: LD_INT 3
30756: PPUSH
30757: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30761: LD_EXP 91
30765: PUSH
30766: LD_VAR 0 2
30770: ARRAY
30771: PUSH
30772: LD_INT 1
30774: ARRAY
30775: IFFALSE 30807
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30777: LD_VAR 0 3
30781: PPUSH
30782: LD_EXP 91
30786: PUSH
30787: LD_VAR 0 2
30791: ARRAY
30792: PUSH
30793: LD_INT 1
30795: ARRAY
30796: PUSH
30797: LD_INT 1
30799: ARRAY
30800: PPUSH
30801: CALL_OW 128
30805: GO 30863
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30807: LD_VAR 0 3
30811: PPUSH
30812: CALL_OW 314
30816: NOT
30817: PUSH
30818: LD_EXP 91
30822: PUSH
30823: LD_VAR 0 2
30827: ARRAY
30828: PUSH
30829: LD_INT 2
30831: ARRAY
30832: AND
30833: IFFALSE 30863
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30835: LD_VAR 0 3
30839: PPUSH
30840: LD_EXP 91
30844: PUSH
30845: LD_VAR 0 2
30849: ARRAY
30850: PUSH
30851: LD_INT 2
30853: ARRAY
30854: PUSH
30855: LD_INT 1
30857: ARRAY
30858: PPUSH
30859: CALL_OW 128
// end ;
30863: GO 30641
30865: POP
30866: POP
// end ;
30867: GO 30484
30869: POP
30870: POP
// end ;
30871: LD_VAR 0 1
30875: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30876: LD_INT 0
30878: PPUSH
30879: PPUSH
30880: PPUSH
30881: PPUSH
30882: PPUSH
// if not mc_bases then
30883: LD_EXP 88
30887: NOT
30888: IFFALSE 30892
// exit ;
30890: GO 32035
// for i = 1 to mc_bases do
30892: LD_ADDR_VAR 0 2
30896: PUSH
30897: DOUBLE
30898: LD_INT 1
30900: DEC
30901: ST_TO_ADDR
30902: LD_EXP 88
30906: PUSH
30907: FOR_TO
30908: IFFALSE 32033
// begin if mc_scan [ i ] then
30910: LD_EXP 111
30914: PUSH
30915: LD_VAR 0 2
30919: ARRAY
30920: IFFALSE 30924
// continue ;
30922: GO 30907
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30924: LD_EXP 93
30928: PUSH
30929: LD_VAR 0 2
30933: ARRAY
30934: NOT
30935: PUSH
30936: LD_EXP 95
30940: PUSH
30941: LD_VAR 0 2
30945: ARRAY
30946: NOT
30947: AND
30948: PUSH
30949: LD_EXP 94
30953: PUSH
30954: LD_VAR 0 2
30958: ARRAY
30959: AND
30960: IFFALSE 30998
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30962: LD_ADDR_EXP 94
30966: PUSH
30967: LD_EXP 94
30971: PPUSH
30972: LD_VAR 0 2
30976: PPUSH
30977: EMPTY
30978: PPUSH
30979: CALL_OW 1
30983: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30984: LD_VAR 0 2
30988: PPUSH
30989: LD_INT 103
30991: PPUSH
30992: CALL 24718 0 2
// continue ;
30996: GO 30907
// end ; if mc_construct_list [ i ] then
30998: LD_EXP 95
31002: PUSH
31003: LD_VAR 0 2
31007: ARRAY
31008: IFFALSE 31228
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31010: LD_ADDR_VAR 0 4
31014: PUSH
31015: LD_EXP 88
31019: PUSH
31020: LD_VAR 0 2
31024: ARRAY
31025: PPUSH
31026: LD_INT 25
31028: PUSH
31029: LD_INT 2
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PPUSH
31036: CALL_OW 72
31040: PUSH
31041: LD_EXP 90
31045: PUSH
31046: LD_VAR 0 2
31050: ARRAY
31051: DIFF
31052: ST_TO_ADDR
// if not tmp then
31053: LD_VAR 0 4
31057: NOT
31058: IFFALSE 31062
// continue ;
31060: GO 30907
// for j in tmp do
31062: LD_ADDR_VAR 0 3
31066: PUSH
31067: LD_VAR 0 4
31071: PUSH
31072: FOR_IN
31073: IFFALSE 31224
// begin if not mc_builders [ i ] then
31075: LD_EXP 94
31079: PUSH
31080: LD_VAR 0 2
31084: ARRAY
31085: NOT
31086: IFFALSE 31144
// begin SetTag ( j , 103 ) ;
31088: LD_VAR 0 3
31092: PPUSH
31093: LD_INT 103
31095: PPUSH
31096: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31100: LD_ADDR_EXP 94
31104: PUSH
31105: LD_EXP 94
31109: PPUSH
31110: LD_VAR 0 2
31114: PUSH
31115: LD_EXP 94
31119: PUSH
31120: LD_VAR 0 2
31124: ARRAY
31125: PUSH
31126: LD_INT 1
31128: PLUS
31129: PUSH
31130: EMPTY
31131: LIST
31132: LIST
31133: PPUSH
31134: LD_VAR 0 3
31138: PPUSH
31139: CALL 55609 0 3
31143: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31144: LD_VAR 0 3
31148: PPUSH
31149: CALL_OW 310
31153: IFFALSE 31164
// ComExitBuilding ( j ) ;
31155: LD_VAR 0 3
31159: PPUSH
31160: CALL_OW 122
// wait ( 3 ) ;
31164: LD_INT 3
31166: PPUSH
31167: CALL_OW 67
// if not mc_construct_list [ i ] then
31171: LD_EXP 95
31175: PUSH
31176: LD_VAR 0 2
31180: ARRAY
31181: NOT
31182: IFFALSE 31186
// break ;
31184: GO 31224
// if not HasTask ( j ) then
31186: LD_VAR 0 3
31190: PPUSH
31191: CALL_OW 314
31195: NOT
31196: IFFALSE 31222
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31198: LD_VAR 0 3
31202: PPUSH
31203: LD_EXP 95
31207: PUSH
31208: LD_VAR 0 2
31212: ARRAY
31213: PUSH
31214: LD_INT 1
31216: ARRAY
31217: PPUSH
31218: CALL 58460 0 2
// end ;
31222: GO 31072
31224: POP
31225: POP
// end else
31226: GO 32031
// if mc_build_list [ i ] then
31228: LD_EXP 93
31232: PUSH
31233: LD_VAR 0 2
31237: ARRAY
31238: IFFALSE 32031
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31240: LD_ADDR_VAR 0 5
31244: PUSH
31245: LD_EXP 88
31249: PUSH
31250: LD_VAR 0 2
31254: ARRAY
31255: PPUSH
31256: LD_INT 2
31258: PUSH
31259: LD_INT 30
31261: PUSH
31262: LD_INT 0
31264: PUSH
31265: EMPTY
31266: LIST
31267: LIST
31268: PUSH
31269: LD_INT 30
31271: PUSH
31272: LD_INT 1
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: EMPTY
31280: LIST
31281: LIST
31282: LIST
31283: PPUSH
31284: CALL_OW 72
31288: ST_TO_ADDR
// if depot then
31289: LD_VAR 0 5
31293: IFFALSE 31311
// depot := depot [ 1 ] else
31295: LD_ADDR_VAR 0 5
31299: PUSH
31300: LD_VAR 0 5
31304: PUSH
31305: LD_INT 1
31307: ARRAY
31308: ST_TO_ADDR
31309: GO 31319
// depot := 0 ;
31311: LD_ADDR_VAR 0 5
31315: PUSH
31316: LD_INT 0
31318: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31319: LD_EXP 93
31323: PUSH
31324: LD_VAR 0 2
31328: ARRAY
31329: PUSH
31330: LD_INT 1
31332: ARRAY
31333: PUSH
31334: LD_INT 1
31336: ARRAY
31337: PPUSH
31338: CALL 58290 0 1
31342: PUSH
31343: LD_EXP 88
31347: PUSH
31348: LD_VAR 0 2
31352: ARRAY
31353: PPUSH
31354: LD_INT 2
31356: PUSH
31357: LD_INT 30
31359: PUSH
31360: LD_INT 2
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PUSH
31367: LD_INT 30
31369: PUSH
31370: LD_INT 3
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: LIST
31381: PPUSH
31382: CALL_OW 72
31386: NOT
31387: AND
31388: IFFALSE 31493
// begin for j = 1 to mc_build_list [ i ] do
31390: LD_ADDR_VAR 0 3
31394: PUSH
31395: DOUBLE
31396: LD_INT 1
31398: DEC
31399: ST_TO_ADDR
31400: LD_EXP 93
31404: PUSH
31405: LD_VAR 0 2
31409: ARRAY
31410: PUSH
31411: FOR_TO
31412: IFFALSE 31491
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31414: LD_EXP 93
31418: PUSH
31419: LD_VAR 0 2
31423: ARRAY
31424: PUSH
31425: LD_VAR 0 3
31429: ARRAY
31430: PUSH
31431: LD_INT 1
31433: ARRAY
31434: PUSH
31435: LD_INT 2
31437: EQUAL
31438: IFFALSE 31489
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31440: LD_ADDR_EXP 93
31444: PUSH
31445: LD_EXP 93
31449: PPUSH
31450: LD_VAR 0 2
31454: PPUSH
31455: LD_EXP 93
31459: PUSH
31460: LD_VAR 0 2
31464: ARRAY
31465: PPUSH
31466: LD_VAR 0 3
31470: PPUSH
31471: LD_INT 1
31473: PPUSH
31474: LD_INT 0
31476: PPUSH
31477: CALL 55027 0 4
31481: PPUSH
31482: CALL_OW 1
31486: ST_TO_ADDR
// break ;
31487: GO 31491
// end ;
31489: GO 31411
31491: POP
31492: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31493: LD_EXP 93
31497: PUSH
31498: LD_VAR 0 2
31502: ARRAY
31503: PUSH
31504: LD_INT 1
31506: ARRAY
31507: PUSH
31508: LD_INT 1
31510: ARRAY
31511: PUSH
31512: LD_INT 0
31514: EQUAL
31515: PUSH
31516: LD_VAR 0 5
31520: PUSH
31521: LD_VAR 0 5
31525: PPUSH
31526: LD_EXP 93
31530: PUSH
31531: LD_VAR 0 2
31535: ARRAY
31536: PUSH
31537: LD_INT 1
31539: ARRAY
31540: PUSH
31541: LD_INT 1
31543: ARRAY
31544: PPUSH
31545: LD_EXP 93
31549: PUSH
31550: LD_VAR 0 2
31554: ARRAY
31555: PUSH
31556: LD_INT 1
31558: ARRAY
31559: PUSH
31560: LD_INT 2
31562: ARRAY
31563: PPUSH
31564: LD_EXP 93
31568: PUSH
31569: LD_VAR 0 2
31573: ARRAY
31574: PUSH
31575: LD_INT 1
31577: ARRAY
31578: PUSH
31579: LD_INT 3
31581: ARRAY
31582: PPUSH
31583: LD_EXP 93
31587: PUSH
31588: LD_VAR 0 2
31592: ARRAY
31593: PUSH
31594: LD_INT 1
31596: ARRAY
31597: PUSH
31598: LD_INT 4
31600: ARRAY
31601: PPUSH
31602: CALL 63024 0 5
31606: AND
31607: OR
31608: IFFALSE 31889
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31610: LD_ADDR_VAR 0 4
31614: PUSH
31615: LD_EXP 88
31619: PUSH
31620: LD_VAR 0 2
31624: ARRAY
31625: PPUSH
31626: LD_INT 25
31628: PUSH
31629: LD_INT 2
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PPUSH
31636: CALL_OW 72
31640: PUSH
31641: LD_EXP 90
31645: PUSH
31646: LD_VAR 0 2
31650: ARRAY
31651: DIFF
31652: ST_TO_ADDR
// if not tmp then
31653: LD_VAR 0 4
31657: NOT
31658: IFFALSE 31662
// continue ;
31660: GO 30907
// for j in tmp do
31662: LD_ADDR_VAR 0 3
31666: PUSH
31667: LD_VAR 0 4
31671: PUSH
31672: FOR_IN
31673: IFFALSE 31885
// begin if not mc_builders [ i ] then
31675: LD_EXP 94
31679: PUSH
31680: LD_VAR 0 2
31684: ARRAY
31685: NOT
31686: IFFALSE 31744
// begin SetTag ( j , 103 ) ;
31688: LD_VAR 0 3
31692: PPUSH
31693: LD_INT 103
31695: PPUSH
31696: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31700: LD_ADDR_EXP 94
31704: PUSH
31705: LD_EXP 94
31709: PPUSH
31710: LD_VAR 0 2
31714: PUSH
31715: LD_EXP 94
31719: PUSH
31720: LD_VAR 0 2
31724: ARRAY
31725: PUSH
31726: LD_INT 1
31728: PLUS
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PPUSH
31734: LD_VAR 0 3
31738: PPUSH
31739: CALL 55609 0 3
31743: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31744: LD_VAR 0 3
31748: PPUSH
31749: CALL_OW 310
31753: IFFALSE 31764
// ComExitBuilding ( j ) ;
31755: LD_VAR 0 3
31759: PPUSH
31760: CALL_OW 122
// wait ( 3 ) ;
31764: LD_INT 3
31766: PPUSH
31767: CALL_OW 67
// if not mc_build_list [ i ] then
31771: LD_EXP 93
31775: PUSH
31776: LD_VAR 0 2
31780: ARRAY
31781: NOT
31782: IFFALSE 31786
// break ;
31784: GO 31885
// if not HasTask ( j ) then
31786: LD_VAR 0 3
31790: PPUSH
31791: CALL_OW 314
31795: NOT
31796: IFFALSE 31883
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31798: LD_VAR 0 3
31802: PPUSH
31803: LD_EXP 93
31807: PUSH
31808: LD_VAR 0 2
31812: ARRAY
31813: PUSH
31814: LD_INT 1
31816: ARRAY
31817: PUSH
31818: LD_INT 1
31820: ARRAY
31821: PPUSH
31822: LD_EXP 93
31826: PUSH
31827: LD_VAR 0 2
31831: ARRAY
31832: PUSH
31833: LD_INT 1
31835: ARRAY
31836: PUSH
31837: LD_INT 2
31839: ARRAY
31840: PPUSH
31841: LD_EXP 93
31845: PUSH
31846: LD_VAR 0 2
31850: ARRAY
31851: PUSH
31852: LD_INT 1
31854: ARRAY
31855: PUSH
31856: LD_INT 3
31858: ARRAY
31859: PPUSH
31860: LD_EXP 93
31864: PUSH
31865: LD_VAR 0 2
31869: ARRAY
31870: PUSH
31871: LD_INT 1
31873: ARRAY
31874: PUSH
31875: LD_INT 4
31877: ARRAY
31878: PPUSH
31879: CALL_OW 145
// end ;
31883: GO 31672
31885: POP
31886: POP
// end else
31887: GO 32031
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31889: LD_EXP 88
31893: PUSH
31894: LD_VAR 0 2
31898: ARRAY
31899: PPUSH
31900: LD_EXP 93
31904: PUSH
31905: LD_VAR 0 2
31909: ARRAY
31910: PUSH
31911: LD_INT 1
31913: ARRAY
31914: PUSH
31915: LD_INT 1
31917: ARRAY
31918: PPUSH
31919: LD_EXP 93
31923: PUSH
31924: LD_VAR 0 2
31928: ARRAY
31929: PUSH
31930: LD_INT 1
31932: ARRAY
31933: PUSH
31934: LD_INT 2
31936: ARRAY
31937: PPUSH
31938: LD_EXP 93
31942: PUSH
31943: LD_VAR 0 2
31947: ARRAY
31948: PUSH
31949: LD_INT 1
31951: ARRAY
31952: PUSH
31953: LD_INT 3
31955: ARRAY
31956: PPUSH
31957: LD_EXP 93
31961: PUSH
31962: LD_VAR 0 2
31966: ARRAY
31967: PUSH
31968: LD_INT 1
31970: ARRAY
31971: PUSH
31972: LD_INT 4
31974: ARRAY
31975: PPUSH
31976: CALL 62360 0 5
31980: NOT
31981: IFFALSE 32031
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31983: LD_ADDR_EXP 93
31987: PUSH
31988: LD_EXP 93
31992: PPUSH
31993: LD_VAR 0 2
31997: PPUSH
31998: LD_EXP 93
32002: PUSH
32003: LD_VAR 0 2
32007: ARRAY
32008: PPUSH
32009: LD_INT 1
32011: PPUSH
32012: LD_INT 1
32014: NEG
32015: PPUSH
32016: LD_INT 0
32018: PPUSH
32019: CALL 55027 0 4
32023: PPUSH
32024: CALL_OW 1
32028: ST_TO_ADDR
// continue ;
32029: GO 30907
// end ; end ; end ;
32031: GO 30907
32033: POP
32034: POP
// end ;
32035: LD_VAR 0 1
32039: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32040: LD_INT 0
32042: PPUSH
32043: PPUSH
32044: PPUSH
32045: PPUSH
32046: PPUSH
32047: PPUSH
// if not mc_bases then
32048: LD_EXP 88
32052: NOT
32053: IFFALSE 32057
// exit ;
32055: GO 32484
// for i = 1 to mc_bases do
32057: LD_ADDR_VAR 0 2
32061: PUSH
32062: DOUBLE
32063: LD_INT 1
32065: DEC
32066: ST_TO_ADDR
32067: LD_EXP 88
32071: PUSH
32072: FOR_TO
32073: IFFALSE 32482
// begin tmp := mc_build_upgrade [ i ] ;
32075: LD_ADDR_VAR 0 4
32079: PUSH
32080: LD_EXP 120
32084: PUSH
32085: LD_VAR 0 2
32089: ARRAY
32090: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32091: LD_ADDR_VAR 0 6
32095: PUSH
32096: LD_EXP 121
32100: PUSH
32101: LD_VAR 0 2
32105: ARRAY
32106: PPUSH
32107: LD_INT 2
32109: PUSH
32110: LD_INT 30
32112: PUSH
32113: LD_INT 6
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 30
32122: PUSH
32123: LD_INT 7
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: LIST
32134: PPUSH
32135: CALL_OW 72
32139: ST_TO_ADDR
// if not tmp and not lab then
32140: LD_VAR 0 4
32144: NOT
32145: PUSH
32146: LD_VAR 0 6
32150: NOT
32151: AND
32152: IFFALSE 32156
// continue ;
32154: GO 32072
// if tmp then
32156: LD_VAR 0 4
32160: IFFALSE 32280
// for j in tmp do
32162: LD_ADDR_VAR 0 3
32166: PUSH
32167: LD_VAR 0 4
32171: PUSH
32172: FOR_IN
32173: IFFALSE 32278
// begin if UpgradeCost ( j ) then
32175: LD_VAR 0 3
32179: PPUSH
32180: CALL 62020 0 1
32184: IFFALSE 32276
// begin ComUpgrade ( j ) ;
32186: LD_VAR 0 3
32190: PPUSH
32191: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32195: LD_ADDR_EXP 120
32199: PUSH
32200: LD_EXP 120
32204: PPUSH
32205: LD_VAR 0 2
32209: PPUSH
32210: LD_EXP 120
32214: PUSH
32215: LD_VAR 0 2
32219: ARRAY
32220: PUSH
32221: LD_VAR 0 3
32225: DIFF
32226: PPUSH
32227: CALL_OW 1
32231: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32232: LD_ADDR_EXP 95
32236: PUSH
32237: LD_EXP 95
32241: PPUSH
32242: LD_VAR 0 2
32246: PUSH
32247: LD_EXP 95
32251: PUSH
32252: LD_VAR 0 2
32256: ARRAY
32257: PUSH
32258: LD_INT 1
32260: PLUS
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PPUSH
32266: LD_VAR 0 3
32270: PPUSH
32271: CALL 55609 0 3
32275: ST_TO_ADDR
// end ; end ;
32276: GO 32172
32278: POP
32279: POP
// if not lab or not mc_lab_upgrade [ i ] then
32280: LD_VAR 0 6
32284: NOT
32285: PUSH
32286: LD_EXP 122
32290: PUSH
32291: LD_VAR 0 2
32295: ARRAY
32296: NOT
32297: OR
32298: IFFALSE 32302
// continue ;
32300: GO 32072
// for j in lab do
32302: LD_ADDR_VAR 0 3
32306: PUSH
32307: LD_VAR 0 6
32311: PUSH
32312: FOR_IN
32313: IFFALSE 32478
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32315: LD_VAR 0 3
32319: PPUSH
32320: CALL_OW 266
32324: PUSH
32325: LD_INT 6
32327: PUSH
32328: LD_INT 7
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: IN
32335: PUSH
32336: LD_VAR 0 3
32340: PPUSH
32341: CALL_OW 461
32345: PUSH
32346: LD_INT 1
32348: NONEQUAL
32349: AND
32350: IFFALSE 32476
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32352: LD_VAR 0 3
32356: PPUSH
32357: LD_EXP 122
32361: PUSH
32362: LD_VAR 0 2
32366: ARRAY
32367: PUSH
32368: LD_INT 1
32370: ARRAY
32371: PPUSH
32372: CALL 62225 0 2
32376: IFFALSE 32476
// begin ComCancel ( j ) ;
32378: LD_VAR 0 3
32382: PPUSH
32383: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32387: LD_VAR 0 3
32391: PPUSH
32392: LD_EXP 122
32396: PUSH
32397: LD_VAR 0 2
32401: ARRAY
32402: PUSH
32403: LD_INT 1
32405: ARRAY
32406: PPUSH
32407: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32411: LD_VAR 0 3
32415: PUSH
32416: LD_EXP 95
32420: PUSH
32421: LD_VAR 0 2
32425: ARRAY
32426: IN
32427: NOT
32428: IFFALSE 32474
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32430: LD_ADDR_EXP 95
32434: PUSH
32435: LD_EXP 95
32439: PPUSH
32440: LD_VAR 0 2
32444: PUSH
32445: LD_EXP 95
32449: PUSH
32450: LD_VAR 0 2
32454: ARRAY
32455: PUSH
32456: LD_INT 1
32458: PLUS
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PPUSH
32464: LD_VAR 0 3
32468: PPUSH
32469: CALL 55609 0 3
32473: ST_TO_ADDR
// break ;
32474: GO 32478
// end ; end ; end ;
32476: GO 32312
32478: POP
32479: POP
// end ;
32480: GO 32072
32482: POP
32483: POP
// end ;
32484: LD_VAR 0 1
32488: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32489: LD_INT 0
32491: PPUSH
32492: PPUSH
32493: PPUSH
32494: PPUSH
32495: PPUSH
32496: PPUSH
32497: PPUSH
32498: PPUSH
32499: PPUSH
// if not mc_bases then
32500: LD_EXP 88
32504: NOT
32505: IFFALSE 32509
// exit ;
32507: GO 32914
// for i = 1 to mc_bases do
32509: LD_ADDR_VAR 0 2
32513: PUSH
32514: DOUBLE
32515: LD_INT 1
32517: DEC
32518: ST_TO_ADDR
32519: LD_EXP 88
32523: PUSH
32524: FOR_TO
32525: IFFALSE 32912
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32527: LD_EXP 96
32531: PUSH
32532: LD_VAR 0 2
32536: ARRAY
32537: NOT
32538: PUSH
32539: LD_EXP 88
32543: PUSH
32544: LD_VAR 0 2
32548: ARRAY
32549: PPUSH
32550: LD_INT 30
32552: PUSH
32553: LD_INT 3
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PPUSH
32560: CALL_OW 72
32564: NOT
32565: OR
32566: IFFALSE 32570
// continue ;
32568: GO 32524
// busy := false ;
32570: LD_ADDR_VAR 0 8
32574: PUSH
32575: LD_INT 0
32577: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32578: LD_ADDR_VAR 0 4
32582: PUSH
32583: LD_EXP 88
32587: PUSH
32588: LD_VAR 0 2
32592: ARRAY
32593: PPUSH
32594: LD_INT 30
32596: PUSH
32597: LD_INT 3
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PPUSH
32604: CALL_OW 72
32608: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32609: LD_ADDR_VAR 0 6
32613: PUSH
32614: LD_EXP 96
32618: PUSH
32619: LD_VAR 0 2
32623: ARRAY
32624: PPUSH
32625: LD_INT 2
32627: PUSH
32628: LD_INT 30
32630: PUSH
32631: LD_INT 32
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PUSH
32638: LD_INT 30
32640: PUSH
32641: LD_INT 33
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: LIST
32652: PPUSH
32653: CALL_OW 72
32657: ST_TO_ADDR
// if not t then
32658: LD_VAR 0 6
32662: NOT
32663: IFFALSE 32667
// continue ;
32665: GO 32524
// for j in tmp do
32667: LD_ADDR_VAR 0 3
32671: PUSH
32672: LD_VAR 0 4
32676: PUSH
32677: FOR_IN
32678: IFFALSE 32708
// if not BuildingStatus ( j ) = bs_idle then
32680: LD_VAR 0 3
32684: PPUSH
32685: CALL_OW 461
32689: PUSH
32690: LD_INT 2
32692: EQUAL
32693: NOT
32694: IFFALSE 32706
// begin busy := true ;
32696: LD_ADDR_VAR 0 8
32700: PUSH
32701: LD_INT 1
32703: ST_TO_ADDR
// break ;
32704: GO 32708
// end ;
32706: GO 32677
32708: POP
32709: POP
// if busy then
32710: LD_VAR 0 8
32714: IFFALSE 32718
// continue ;
32716: GO 32524
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32718: LD_ADDR_VAR 0 7
32722: PUSH
32723: LD_VAR 0 6
32727: PPUSH
32728: LD_INT 35
32730: PUSH
32731: LD_INT 0
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: PPUSH
32738: CALL_OW 72
32742: ST_TO_ADDR
// if tw then
32743: LD_VAR 0 7
32747: IFFALSE 32824
// begin tw := tw [ 1 ] ;
32749: LD_ADDR_VAR 0 7
32753: PUSH
32754: LD_VAR 0 7
32758: PUSH
32759: LD_INT 1
32761: ARRAY
32762: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32763: LD_ADDR_VAR 0 9
32767: PUSH
32768: LD_VAR 0 7
32772: PPUSH
32773: LD_EXP 113
32777: PUSH
32778: LD_VAR 0 2
32782: ARRAY
32783: PPUSH
32784: CALL 60579 0 2
32788: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32789: LD_EXP 127
32793: PUSH
32794: LD_VAR 0 2
32798: ARRAY
32799: IFFALSE 32822
// if not weapon in mc_allowed_tower_weapons [ i ] then
32801: LD_VAR 0 9
32805: PUSH
32806: LD_EXP 127
32810: PUSH
32811: LD_VAR 0 2
32815: ARRAY
32816: IN
32817: NOT
32818: IFFALSE 32822
// continue ;
32820: GO 32524
// end else
32822: GO 32887
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32824: LD_ADDR_VAR 0 5
32828: PUSH
32829: LD_EXP 96
32833: PUSH
32834: LD_VAR 0 2
32838: ARRAY
32839: PPUSH
32840: LD_VAR 0 4
32844: PPUSH
32845: CALL 86081 0 2
32849: ST_TO_ADDR
// if not tmp2 then
32850: LD_VAR 0 5
32854: NOT
32855: IFFALSE 32859
// continue ;
32857: GO 32524
// tw := tmp2 [ 1 ] ;
32859: LD_ADDR_VAR 0 7
32863: PUSH
32864: LD_VAR 0 5
32868: PUSH
32869: LD_INT 1
32871: ARRAY
32872: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32873: LD_ADDR_VAR 0 9
32877: PUSH
32878: LD_VAR 0 5
32882: PUSH
32883: LD_INT 2
32885: ARRAY
32886: ST_TO_ADDR
// end ; if not weapon then
32887: LD_VAR 0 9
32891: NOT
32892: IFFALSE 32896
// continue ;
32894: GO 32524
// ComPlaceWeapon ( tw , weapon ) ;
32896: LD_VAR 0 7
32900: PPUSH
32901: LD_VAR 0 9
32905: PPUSH
32906: CALL_OW 148
// end ;
32910: GO 32524
32912: POP
32913: POP
// end ;
32914: LD_VAR 0 1
32918: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32919: LD_INT 0
32921: PPUSH
32922: PPUSH
32923: PPUSH
32924: PPUSH
32925: PPUSH
32926: PPUSH
// if not mc_bases then
32927: LD_EXP 88
32931: NOT
32932: IFFALSE 32936
// exit ;
32934: GO 33712
// for i = 1 to mc_bases do
32936: LD_ADDR_VAR 0 2
32940: PUSH
32941: DOUBLE
32942: LD_INT 1
32944: DEC
32945: ST_TO_ADDR
32946: LD_EXP 88
32950: PUSH
32951: FOR_TO
32952: IFFALSE 33710
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
32954: LD_EXP 101
32958: PUSH
32959: LD_VAR 0 2
32963: ARRAY
32964: NOT
32965: PUSH
32966: LD_EXP 101
32970: PUSH
32971: LD_VAR 0 2
32975: ARRAY
32976: PUSH
32977: LD_EXP 102
32981: PUSH
32982: LD_VAR 0 2
32986: ARRAY
32987: EQUAL
32988: OR
32989: PUSH
32990: LD_EXP 111
32994: PUSH
32995: LD_VAR 0 2
32999: ARRAY
33000: OR
33001: IFFALSE 33005
// continue ;
33003: GO 32951
// if mc_miners [ i ] then
33005: LD_EXP 102
33009: PUSH
33010: LD_VAR 0 2
33014: ARRAY
33015: IFFALSE 33397
// begin for j = mc_miners [ i ] downto 1 do
33017: LD_ADDR_VAR 0 3
33021: PUSH
33022: DOUBLE
33023: LD_EXP 102
33027: PUSH
33028: LD_VAR 0 2
33032: ARRAY
33033: INC
33034: ST_TO_ADDR
33035: LD_INT 1
33037: PUSH
33038: FOR_DOWNTO
33039: IFFALSE 33395
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33041: LD_EXP 102
33045: PUSH
33046: LD_VAR 0 2
33050: ARRAY
33051: PUSH
33052: LD_VAR 0 3
33056: ARRAY
33057: PPUSH
33058: CALL_OW 301
33062: PUSH
33063: LD_EXP 102
33067: PUSH
33068: LD_VAR 0 2
33072: ARRAY
33073: PUSH
33074: LD_VAR 0 3
33078: ARRAY
33079: PPUSH
33080: CALL_OW 257
33084: PUSH
33085: LD_INT 1
33087: NONEQUAL
33088: OR
33089: IFFALSE 33152
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33091: LD_ADDR_VAR 0 5
33095: PUSH
33096: LD_EXP 102
33100: PUSH
33101: LD_VAR 0 2
33105: ARRAY
33106: PUSH
33107: LD_EXP 102
33111: PUSH
33112: LD_VAR 0 2
33116: ARRAY
33117: PUSH
33118: LD_VAR 0 3
33122: ARRAY
33123: DIFF
33124: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33125: LD_ADDR_EXP 102
33129: PUSH
33130: LD_EXP 102
33134: PPUSH
33135: LD_VAR 0 2
33139: PPUSH
33140: LD_VAR 0 5
33144: PPUSH
33145: CALL_OW 1
33149: ST_TO_ADDR
// continue ;
33150: GO 33038
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33152: LD_EXP 102
33156: PUSH
33157: LD_VAR 0 2
33161: ARRAY
33162: PUSH
33163: LD_VAR 0 3
33167: ARRAY
33168: PPUSH
33169: CALL_OW 257
33173: PUSH
33174: LD_INT 1
33176: EQUAL
33177: PUSH
33178: LD_EXP 102
33182: PUSH
33183: LD_VAR 0 2
33187: ARRAY
33188: PUSH
33189: LD_VAR 0 3
33193: ARRAY
33194: PPUSH
33195: CALL_OW 459
33199: NOT
33200: AND
33201: PUSH
33202: LD_EXP 102
33206: PUSH
33207: LD_VAR 0 2
33211: ARRAY
33212: PUSH
33213: LD_VAR 0 3
33217: ARRAY
33218: PPUSH
33219: CALL_OW 314
33223: NOT
33224: AND
33225: IFFALSE 33393
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33227: LD_EXP 102
33231: PUSH
33232: LD_VAR 0 2
33236: ARRAY
33237: PUSH
33238: LD_VAR 0 3
33242: ARRAY
33243: PPUSH
33244: CALL_OW 310
33248: IFFALSE 33271
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33250: LD_EXP 102
33254: PUSH
33255: LD_VAR 0 2
33259: ARRAY
33260: PUSH
33261: LD_VAR 0 3
33265: ARRAY
33266: PPUSH
33267: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33271: LD_EXP 102
33275: PUSH
33276: LD_VAR 0 2
33280: ARRAY
33281: PUSH
33282: LD_VAR 0 3
33286: ARRAY
33287: PPUSH
33288: CALL_OW 314
33292: NOT
33293: IFFALSE 33393
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33295: LD_EXP 102
33299: PUSH
33300: LD_VAR 0 2
33304: ARRAY
33305: PUSH
33306: LD_VAR 0 3
33310: ARRAY
33311: PPUSH
33312: LD_EXP 101
33316: PUSH
33317: LD_VAR 0 2
33321: ARRAY
33322: PUSH
33323: LD_VAR 0 3
33327: PUSH
33328: LD_EXP 101
33332: PUSH
33333: LD_VAR 0 2
33337: ARRAY
33338: MOD
33339: PUSH
33340: LD_INT 1
33342: PLUS
33343: ARRAY
33344: PUSH
33345: LD_INT 1
33347: ARRAY
33348: PPUSH
33349: LD_EXP 101
33353: PUSH
33354: LD_VAR 0 2
33358: ARRAY
33359: PUSH
33360: LD_VAR 0 3
33364: PUSH
33365: LD_EXP 101
33369: PUSH
33370: LD_VAR 0 2
33374: ARRAY
33375: MOD
33376: PUSH
33377: LD_INT 1
33379: PLUS
33380: ARRAY
33381: PUSH
33382: LD_INT 2
33384: ARRAY
33385: PPUSH
33386: LD_INT 0
33388: PPUSH
33389: CALL_OW 193
// end ; end ;
33393: GO 33038
33395: POP
33396: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33397: LD_ADDR_VAR 0 5
33401: PUSH
33402: LD_EXP 88
33406: PUSH
33407: LD_VAR 0 2
33411: ARRAY
33412: PPUSH
33413: LD_INT 2
33415: PUSH
33416: LD_INT 30
33418: PUSH
33419: LD_INT 4
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 30
33428: PUSH
33429: LD_INT 5
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 30
33438: PUSH
33439: LD_INT 32
33441: PUSH
33442: EMPTY
33443: LIST
33444: LIST
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: PPUSH
33452: CALL_OW 72
33456: ST_TO_ADDR
// if not tmp then
33457: LD_VAR 0 5
33461: NOT
33462: IFFALSE 33466
// continue ;
33464: GO 32951
// list := [ ] ;
33466: LD_ADDR_VAR 0 6
33470: PUSH
33471: EMPTY
33472: ST_TO_ADDR
// for j in tmp do
33473: LD_ADDR_VAR 0 3
33477: PUSH
33478: LD_VAR 0 5
33482: PUSH
33483: FOR_IN
33484: IFFALSE 33553
// begin for k in UnitsInside ( j ) do
33486: LD_ADDR_VAR 0 4
33490: PUSH
33491: LD_VAR 0 3
33495: PPUSH
33496: CALL_OW 313
33500: PUSH
33501: FOR_IN
33502: IFFALSE 33549
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33504: LD_VAR 0 4
33508: PPUSH
33509: CALL_OW 257
33513: PUSH
33514: LD_INT 1
33516: EQUAL
33517: PUSH
33518: LD_VAR 0 4
33522: PPUSH
33523: CALL_OW 459
33527: NOT
33528: AND
33529: IFFALSE 33547
// list := list ^ k ;
33531: LD_ADDR_VAR 0 6
33535: PUSH
33536: LD_VAR 0 6
33540: PUSH
33541: LD_VAR 0 4
33545: ADD
33546: ST_TO_ADDR
33547: GO 33501
33549: POP
33550: POP
// end ;
33551: GO 33483
33553: POP
33554: POP
// list := list diff mc_miners [ i ] ;
33555: LD_ADDR_VAR 0 6
33559: PUSH
33560: LD_VAR 0 6
33564: PUSH
33565: LD_EXP 102
33569: PUSH
33570: LD_VAR 0 2
33574: ARRAY
33575: DIFF
33576: ST_TO_ADDR
// if not list then
33577: LD_VAR 0 6
33581: NOT
33582: IFFALSE 33586
// continue ;
33584: GO 32951
// k := mc_mines [ i ] - mc_miners [ i ] ;
33586: LD_ADDR_VAR 0 4
33590: PUSH
33591: LD_EXP 101
33595: PUSH
33596: LD_VAR 0 2
33600: ARRAY
33601: PUSH
33602: LD_EXP 102
33606: PUSH
33607: LD_VAR 0 2
33611: ARRAY
33612: MINUS
33613: ST_TO_ADDR
// if k > list then
33614: LD_VAR 0 4
33618: PUSH
33619: LD_VAR 0 6
33623: GREATER
33624: IFFALSE 33636
// k := list ;
33626: LD_ADDR_VAR 0 4
33630: PUSH
33631: LD_VAR 0 6
33635: ST_TO_ADDR
// for j = 1 to k do
33636: LD_ADDR_VAR 0 3
33640: PUSH
33641: DOUBLE
33642: LD_INT 1
33644: DEC
33645: ST_TO_ADDR
33646: LD_VAR 0 4
33650: PUSH
33651: FOR_TO
33652: IFFALSE 33706
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33654: LD_ADDR_EXP 102
33658: PUSH
33659: LD_EXP 102
33663: PPUSH
33664: LD_VAR 0 2
33668: PUSH
33669: LD_EXP 102
33673: PUSH
33674: LD_VAR 0 2
33678: ARRAY
33679: PUSH
33680: LD_INT 1
33682: PLUS
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PPUSH
33688: LD_VAR 0 6
33692: PUSH
33693: LD_VAR 0 3
33697: ARRAY
33698: PPUSH
33699: CALL 55609 0 3
33703: ST_TO_ADDR
33704: GO 33651
33706: POP
33707: POP
// end ;
33708: GO 32951
33710: POP
33711: POP
// end ;
33712: LD_VAR 0 1
33716: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33717: LD_INT 0
33719: PPUSH
33720: PPUSH
33721: PPUSH
33722: PPUSH
33723: PPUSH
33724: PPUSH
33725: PPUSH
33726: PPUSH
33727: PPUSH
33728: PPUSH
// if not mc_bases then
33729: LD_EXP 88
33733: NOT
33734: IFFALSE 33738
// exit ;
33736: GO 35488
// for i = 1 to mc_bases do
33738: LD_ADDR_VAR 0 2
33742: PUSH
33743: DOUBLE
33744: LD_INT 1
33746: DEC
33747: ST_TO_ADDR
33748: LD_EXP 88
33752: PUSH
33753: FOR_TO
33754: IFFALSE 35486
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33756: LD_EXP 88
33760: PUSH
33761: LD_VAR 0 2
33765: ARRAY
33766: NOT
33767: PUSH
33768: LD_EXP 95
33772: PUSH
33773: LD_VAR 0 2
33777: ARRAY
33778: OR
33779: IFFALSE 33783
// continue ;
33781: GO 33753
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33783: LD_EXP 104
33787: PUSH
33788: LD_VAR 0 2
33792: ARRAY
33793: NOT
33794: PUSH
33795: LD_EXP 105
33799: PUSH
33800: LD_VAR 0 2
33804: ARRAY
33805: AND
33806: IFFALSE 33844
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33808: LD_ADDR_EXP 105
33812: PUSH
33813: LD_EXP 105
33817: PPUSH
33818: LD_VAR 0 2
33822: PPUSH
33823: EMPTY
33824: PPUSH
33825: CALL_OW 1
33829: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33830: LD_VAR 0 2
33834: PPUSH
33835: LD_INT 107
33837: PPUSH
33838: CALL 24718 0 2
// continue ;
33842: GO 33753
// end ; target := [ ] ;
33844: LD_ADDR_VAR 0 6
33848: PUSH
33849: EMPTY
33850: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33851: LD_ADDR_VAR 0 3
33855: PUSH
33856: DOUBLE
33857: LD_EXP 104
33861: PUSH
33862: LD_VAR 0 2
33866: ARRAY
33867: INC
33868: ST_TO_ADDR
33869: LD_INT 1
33871: PUSH
33872: FOR_DOWNTO
33873: IFFALSE 34133
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33875: LD_EXP 104
33879: PUSH
33880: LD_VAR 0 2
33884: ARRAY
33885: PUSH
33886: LD_VAR 0 3
33890: ARRAY
33891: PUSH
33892: LD_INT 2
33894: ARRAY
33895: PPUSH
33896: LD_EXP 104
33900: PUSH
33901: LD_VAR 0 2
33905: ARRAY
33906: PUSH
33907: LD_VAR 0 3
33911: ARRAY
33912: PUSH
33913: LD_INT 3
33915: ARRAY
33916: PPUSH
33917: CALL_OW 488
33921: PUSH
33922: LD_EXP 104
33926: PUSH
33927: LD_VAR 0 2
33931: ARRAY
33932: PUSH
33933: LD_VAR 0 3
33937: ARRAY
33938: PUSH
33939: LD_INT 2
33941: ARRAY
33942: PPUSH
33943: LD_EXP 104
33947: PUSH
33948: LD_VAR 0 2
33952: ARRAY
33953: PUSH
33954: LD_VAR 0 3
33958: ARRAY
33959: PUSH
33960: LD_INT 3
33962: ARRAY
33963: PPUSH
33964: CALL_OW 284
33968: PUSH
33969: LD_INT 0
33971: EQUAL
33972: AND
33973: IFFALSE 34028
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33975: LD_ADDR_VAR 0 5
33979: PUSH
33980: LD_EXP 104
33984: PUSH
33985: LD_VAR 0 2
33989: ARRAY
33990: PPUSH
33991: LD_VAR 0 3
33995: PPUSH
33996: CALL_OW 3
34000: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34001: LD_ADDR_EXP 104
34005: PUSH
34006: LD_EXP 104
34010: PPUSH
34011: LD_VAR 0 2
34015: PPUSH
34016: LD_VAR 0 5
34020: PPUSH
34021: CALL_OW 1
34025: ST_TO_ADDR
// continue ;
34026: GO 33872
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34028: LD_EXP 88
34032: PUSH
34033: LD_VAR 0 2
34037: ARRAY
34038: PUSH
34039: LD_INT 1
34041: ARRAY
34042: PPUSH
34043: CALL_OW 255
34047: PPUSH
34048: LD_EXP 104
34052: PUSH
34053: LD_VAR 0 2
34057: ARRAY
34058: PUSH
34059: LD_VAR 0 3
34063: ARRAY
34064: PUSH
34065: LD_INT 2
34067: ARRAY
34068: PPUSH
34069: LD_EXP 104
34073: PUSH
34074: LD_VAR 0 2
34078: ARRAY
34079: PUSH
34080: LD_VAR 0 3
34084: ARRAY
34085: PUSH
34086: LD_INT 3
34088: ARRAY
34089: PPUSH
34090: LD_INT 30
34092: PPUSH
34093: CALL 56505 0 4
34097: PUSH
34098: LD_INT 4
34100: ARRAY
34101: PUSH
34102: LD_INT 0
34104: EQUAL
34105: IFFALSE 34131
// begin target := mc_crates [ i ] [ j ] ;
34107: LD_ADDR_VAR 0 6
34111: PUSH
34112: LD_EXP 104
34116: PUSH
34117: LD_VAR 0 2
34121: ARRAY
34122: PUSH
34123: LD_VAR 0 3
34127: ARRAY
34128: ST_TO_ADDR
// break ;
34129: GO 34133
// end ; end ;
34131: GO 33872
34133: POP
34134: POP
// if not target then
34135: LD_VAR 0 6
34139: NOT
34140: IFFALSE 34144
// continue ;
34142: GO 33753
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34144: LD_ADDR_VAR 0 7
34148: PUSH
34149: LD_EXP 107
34153: PUSH
34154: LD_VAR 0 2
34158: ARRAY
34159: PPUSH
34160: LD_INT 2
34162: PUSH
34163: LD_INT 3
34165: PUSH
34166: LD_INT 58
34168: PUSH
34169: EMPTY
34170: LIST
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 61
34178: PUSH
34179: EMPTY
34180: LIST
34181: PUSH
34182: LD_INT 33
34184: PUSH
34185: LD_INT 5
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: LD_INT 33
34194: PUSH
34195: LD_INT 3
34197: PUSH
34198: EMPTY
34199: LIST
34200: LIST
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: LIST
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 2
34211: PUSH
34212: LD_INT 34
34214: PUSH
34215: LD_INT 32
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: PUSH
34222: LD_INT 34
34224: PUSH
34225: LD_INT 51
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: LD_INT 34
34234: PUSH
34235: LD_INT 12
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PPUSH
34252: CALL_OW 72
34256: ST_TO_ADDR
// if not cargo then
34257: LD_VAR 0 7
34261: NOT
34262: IFFALSE 34905
// begin if mc_crates_collector [ i ] < 5 then
34264: LD_EXP 105
34268: PUSH
34269: LD_VAR 0 2
34273: ARRAY
34274: PUSH
34275: LD_INT 5
34277: LESS
34278: IFFALSE 34644
// begin if mc_ape [ i ] then
34280: LD_EXP 117
34284: PUSH
34285: LD_VAR 0 2
34289: ARRAY
34290: IFFALSE 34337
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34292: LD_ADDR_VAR 0 5
34296: PUSH
34297: LD_EXP 117
34301: PUSH
34302: LD_VAR 0 2
34306: ARRAY
34307: PPUSH
34308: LD_INT 25
34310: PUSH
34311: LD_INT 16
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: LD_INT 24
34320: PUSH
34321: LD_INT 750
34323: PUSH
34324: EMPTY
34325: LIST
34326: LIST
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: PPUSH
34332: CALL_OW 72
34336: ST_TO_ADDR
// if not tmp then
34337: LD_VAR 0 5
34341: NOT
34342: IFFALSE 34389
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34344: LD_ADDR_VAR 0 5
34348: PUSH
34349: LD_EXP 88
34353: PUSH
34354: LD_VAR 0 2
34358: ARRAY
34359: PPUSH
34360: LD_INT 25
34362: PUSH
34363: LD_INT 2
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: LD_INT 24
34372: PUSH
34373: LD_INT 750
34375: PUSH
34376: EMPTY
34377: LIST
34378: LIST
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PPUSH
34384: CALL_OW 72
34388: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34389: LD_EXP 117
34393: PUSH
34394: LD_VAR 0 2
34398: ARRAY
34399: PUSH
34400: LD_EXP 88
34404: PUSH
34405: LD_VAR 0 2
34409: ARRAY
34410: PPUSH
34411: LD_INT 25
34413: PUSH
34414: LD_INT 2
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 24
34423: PUSH
34424: LD_INT 750
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PPUSH
34435: CALL_OW 72
34439: AND
34440: PUSH
34441: LD_VAR 0 5
34445: PUSH
34446: LD_INT 5
34448: LESS
34449: AND
34450: IFFALSE 34532
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34452: LD_ADDR_VAR 0 3
34456: PUSH
34457: LD_EXP 88
34461: PUSH
34462: LD_VAR 0 2
34466: ARRAY
34467: PPUSH
34468: LD_INT 25
34470: PUSH
34471: LD_INT 2
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 24
34480: PUSH
34481: LD_INT 750
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PPUSH
34492: CALL_OW 72
34496: PUSH
34497: FOR_IN
34498: IFFALSE 34530
// begin tmp := tmp union j ;
34500: LD_ADDR_VAR 0 5
34504: PUSH
34505: LD_VAR 0 5
34509: PUSH
34510: LD_VAR 0 3
34514: UNION
34515: ST_TO_ADDR
// if tmp >= 5 then
34516: LD_VAR 0 5
34520: PUSH
34521: LD_INT 5
34523: GREATEREQUAL
34524: IFFALSE 34528
// break ;
34526: GO 34530
// end ;
34528: GO 34497
34530: POP
34531: POP
// end ; if not tmp then
34532: LD_VAR 0 5
34536: NOT
34537: IFFALSE 34541
// continue ;
34539: GO 33753
// for j in tmp do
34541: LD_ADDR_VAR 0 3
34545: PUSH
34546: LD_VAR 0 5
34550: PUSH
34551: FOR_IN
34552: IFFALSE 34642
// if not GetTag ( j ) then
34554: LD_VAR 0 3
34558: PPUSH
34559: CALL_OW 110
34563: NOT
34564: IFFALSE 34640
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34566: LD_ADDR_EXP 105
34570: PUSH
34571: LD_EXP 105
34575: PPUSH
34576: LD_VAR 0 2
34580: PUSH
34581: LD_EXP 105
34585: PUSH
34586: LD_VAR 0 2
34590: ARRAY
34591: PUSH
34592: LD_INT 1
34594: PLUS
34595: PUSH
34596: EMPTY
34597: LIST
34598: LIST
34599: PPUSH
34600: LD_VAR 0 3
34604: PPUSH
34605: CALL 55609 0 3
34609: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34610: LD_VAR 0 3
34614: PPUSH
34615: LD_INT 107
34617: PPUSH
34618: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34622: LD_EXP 105
34626: PUSH
34627: LD_VAR 0 2
34631: ARRAY
34632: PUSH
34633: LD_INT 5
34635: GREATEREQUAL
34636: IFFALSE 34640
// break ;
34638: GO 34642
// end ;
34640: GO 34551
34642: POP
34643: POP
// end ; if mc_crates_collector [ i ] and target then
34644: LD_EXP 105
34648: PUSH
34649: LD_VAR 0 2
34653: ARRAY
34654: PUSH
34655: LD_VAR 0 6
34659: AND
34660: IFFALSE 34903
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34662: LD_EXP 105
34666: PUSH
34667: LD_VAR 0 2
34671: ARRAY
34672: PUSH
34673: LD_VAR 0 6
34677: PUSH
34678: LD_INT 1
34680: ARRAY
34681: LESS
34682: IFFALSE 34702
// tmp := mc_crates_collector [ i ] else
34684: LD_ADDR_VAR 0 5
34688: PUSH
34689: LD_EXP 105
34693: PUSH
34694: LD_VAR 0 2
34698: ARRAY
34699: ST_TO_ADDR
34700: GO 34716
// tmp := target [ 1 ] ;
34702: LD_ADDR_VAR 0 5
34706: PUSH
34707: LD_VAR 0 6
34711: PUSH
34712: LD_INT 1
34714: ARRAY
34715: ST_TO_ADDR
// k := 0 ;
34716: LD_ADDR_VAR 0 4
34720: PUSH
34721: LD_INT 0
34723: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34724: LD_ADDR_VAR 0 3
34728: PUSH
34729: LD_EXP 105
34733: PUSH
34734: LD_VAR 0 2
34738: ARRAY
34739: PUSH
34740: FOR_IN
34741: IFFALSE 34901
// begin k := k + 1 ;
34743: LD_ADDR_VAR 0 4
34747: PUSH
34748: LD_VAR 0 4
34752: PUSH
34753: LD_INT 1
34755: PLUS
34756: ST_TO_ADDR
// if k > tmp then
34757: LD_VAR 0 4
34761: PUSH
34762: LD_VAR 0 5
34766: GREATER
34767: IFFALSE 34771
// break ;
34769: GO 34901
// if not GetClass ( j ) in [ 2 , 16 ] then
34771: LD_VAR 0 3
34775: PPUSH
34776: CALL_OW 257
34780: PUSH
34781: LD_INT 2
34783: PUSH
34784: LD_INT 16
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: IN
34791: NOT
34792: IFFALSE 34845
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34794: LD_ADDR_EXP 105
34798: PUSH
34799: LD_EXP 105
34803: PPUSH
34804: LD_VAR 0 2
34808: PPUSH
34809: LD_EXP 105
34813: PUSH
34814: LD_VAR 0 2
34818: ARRAY
34819: PUSH
34820: LD_VAR 0 3
34824: DIFF
34825: PPUSH
34826: CALL_OW 1
34830: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34831: LD_VAR 0 3
34835: PPUSH
34836: LD_INT 0
34838: PPUSH
34839: CALL_OW 109
// continue ;
34843: GO 34740
// end ; if IsInUnit ( j ) then
34845: LD_VAR 0 3
34849: PPUSH
34850: CALL_OW 310
34854: IFFALSE 34865
// ComExitBuilding ( j ) ;
34856: LD_VAR 0 3
34860: PPUSH
34861: CALL_OW 122
// wait ( 3 ) ;
34865: LD_INT 3
34867: PPUSH
34868: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34872: LD_VAR 0 3
34876: PPUSH
34877: LD_VAR 0 6
34881: PUSH
34882: LD_INT 2
34884: ARRAY
34885: PPUSH
34886: LD_VAR 0 6
34890: PUSH
34891: LD_INT 3
34893: ARRAY
34894: PPUSH
34895: CALL_OW 117
// end ;
34899: GO 34740
34901: POP
34902: POP
// end ; end else
34903: GO 35484
// begin for j in cargo do
34905: LD_ADDR_VAR 0 3
34909: PUSH
34910: LD_VAR 0 7
34914: PUSH
34915: FOR_IN
34916: IFFALSE 35482
// begin if GetTag ( j ) <> 0 then
34918: LD_VAR 0 3
34922: PPUSH
34923: CALL_OW 110
34927: PUSH
34928: LD_INT 0
34930: NONEQUAL
34931: IFFALSE 34935
// continue ;
34933: GO 34915
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34935: LD_VAR 0 3
34939: PPUSH
34940: CALL_OW 256
34944: PUSH
34945: LD_INT 1000
34947: LESS
34948: PUSH
34949: LD_VAR 0 3
34953: PPUSH
34954: LD_EXP 112
34958: PUSH
34959: LD_VAR 0 2
34963: ARRAY
34964: PPUSH
34965: CALL_OW 308
34969: NOT
34970: AND
34971: IFFALSE 34993
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34973: LD_VAR 0 3
34977: PPUSH
34978: LD_EXP 112
34982: PUSH
34983: LD_VAR 0 2
34987: ARRAY
34988: PPUSH
34989: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34993: LD_VAR 0 3
34997: PPUSH
34998: CALL_OW 256
35002: PUSH
35003: LD_INT 1000
35005: LESS
35006: PUSH
35007: LD_VAR 0 3
35011: PPUSH
35012: LD_EXP 112
35016: PUSH
35017: LD_VAR 0 2
35021: ARRAY
35022: PPUSH
35023: CALL_OW 308
35027: AND
35028: IFFALSE 35032
// continue ;
35030: GO 34915
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35032: LD_VAR 0 3
35036: PPUSH
35037: CALL_OW 262
35041: PUSH
35042: LD_INT 2
35044: EQUAL
35045: PUSH
35046: LD_VAR 0 3
35050: PPUSH
35051: CALL_OW 261
35055: PUSH
35056: LD_INT 15
35058: LESS
35059: AND
35060: IFFALSE 35064
// continue ;
35062: GO 34915
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35064: LD_VAR 0 3
35068: PPUSH
35069: CALL_OW 262
35073: PUSH
35074: LD_INT 1
35076: EQUAL
35077: PUSH
35078: LD_VAR 0 3
35082: PPUSH
35083: CALL_OW 261
35087: PUSH
35088: LD_INT 10
35090: LESS
35091: AND
35092: IFFALSE 35421
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35094: LD_ADDR_VAR 0 8
35098: PUSH
35099: LD_EXP 88
35103: PUSH
35104: LD_VAR 0 2
35108: ARRAY
35109: PPUSH
35110: LD_INT 2
35112: PUSH
35113: LD_INT 30
35115: PUSH
35116: LD_INT 0
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: LD_INT 30
35125: PUSH
35126: LD_INT 1
35128: PUSH
35129: EMPTY
35130: LIST
35131: LIST
35132: PUSH
35133: EMPTY
35134: LIST
35135: LIST
35136: LIST
35137: PPUSH
35138: CALL_OW 72
35142: ST_TO_ADDR
// if not depot then
35143: LD_VAR 0 8
35147: NOT
35148: IFFALSE 35152
// continue ;
35150: GO 34915
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35152: LD_VAR 0 3
35156: PPUSH
35157: LD_VAR 0 8
35161: PPUSH
35162: LD_VAR 0 3
35166: PPUSH
35167: CALL_OW 74
35171: PPUSH
35172: CALL_OW 296
35176: PUSH
35177: LD_INT 6
35179: LESS
35180: IFFALSE 35196
// SetFuel ( j , 100 ) else
35182: LD_VAR 0 3
35186: PPUSH
35187: LD_INT 100
35189: PPUSH
35190: CALL_OW 240
35194: GO 35421
// if GetFuel ( j ) = 0 then
35196: LD_VAR 0 3
35200: PPUSH
35201: CALL_OW 261
35205: PUSH
35206: LD_INT 0
35208: EQUAL
35209: IFFALSE 35421
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35211: LD_ADDR_EXP 107
35215: PUSH
35216: LD_EXP 107
35220: PPUSH
35221: LD_VAR 0 2
35225: PPUSH
35226: LD_EXP 107
35230: PUSH
35231: LD_VAR 0 2
35235: ARRAY
35236: PUSH
35237: LD_VAR 0 3
35241: DIFF
35242: PPUSH
35243: CALL_OW 1
35247: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35248: LD_VAR 0 3
35252: PPUSH
35253: CALL_OW 263
35257: PUSH
35258: LD_INT 1
35260: EQUAL
35261: IFFALSE 35277
// ComExitVehicle ( IsInUnit ( j ) ) ;
35263: LD_VAR 0 3
35267: PPUSH
35268: CALL_OW 310
35272: PPUSH
35273: CALL_OW 121
// if GetControl ( j ) = control_remote then
35277: LD_VAR 0 3
35281: PPUSH
35282: CALL_OW 263
35286: PUSH
35287: LD_INT 2
35289: EQUAL
35290: IFFALSE 35301
// ComUnlink ( j ) ;
35292: LD_VAR 0 3
35296: PPUSH
35297: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35301: LD_ADDR_VAR 0 9
35305: PUSH
35306: LD_VAR 0 2
35310: PPUSH
35311: LD_INT 3
35313: PPUSH
35314: CALL 44774 0 2
35318: ST_TO_ADDR
// if fac then
35319: LD_VAR 0 9
35323: IFFALSE 35419
// begin for k in fac do
35325: LD_ADDR_VAR 0 4
35329: PUSH
35330: LD_VAR 0 9
35334: PUSH
35335: FOR_IN
35336: IFFALSE 35417
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35338: LD_ADDR_VAR 0 10
35342: PUSH
35343: LD_VAR 0 9
35347: PPUSH
35348: LD_VAR 0 3
35352: PPUSH
35353: CALL_OW 265
35357: PPUSH
35358: LD_VAR 0 3
35362: PPUSH
35363: CALL_OW 262
35367: PPUSH
35368: LD_VAR 0 3
35372: PPUSH
35373: CALL_OW 263
35377: PPUSH
35378: LD_VAR 0 3
35382: PPUSH
35383: CALL_OW 264
35387: PPUSH
35388: CALL 53141 0 5
35392: ST_TO_ADDR
// if components then
35393: LD_VAR 0 10
35397: IFFALSE 35415
// begin MC_InsertProduceList ( i , components ) ;
35399: LD_VAR 0 2
35403: PPUSH
35404: LD_VAR 0 10
35408: PPUSH
35409: CALL 44319 0 2
// break ;
35413: GO 35417
// end ; end ;
35415: GO 35335
35417: POP
35418: POP
// end ; continue ;
35419: GO 34915
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35421: LD_VAR 0 3
35425: PPUSH
35426: LD_INT 1
35428: PPUSH
35429: CALL_OW 289
35433: PUSH
35434: LD_INT 100
35436: LESS
35437: PUSH
35438: LD_VAR 0 3
35442: PPUSH
35443: CALL_OW 314
35447: NOT
35448: AND
35449: IFFALSE 35478
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35451: LD_VAR 0 3
35455: PPUSH
35456: LD_VAR 0 6
35460: PUSH
35461: LD_INT 2
35463: ARRAY
35464: PPUSH
35465: LD_VAR 0 6
35469: PUSH
35470: LD_INT 3
35472: ARRAY
35473: PPUSH
35474: CALL_OW 117
// break ;
35478: GO 35482
// end ;
35480: GO 34915
35482: POP
35483: POP
// end ; end ;
35484: GO 33753
35486: POP
35487: POP
// end ;
35488: LD_VAR 0 1
35492: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35493: LD_INT 0
35495: PPUSH
35496: PPUSH
35497: PPUSH
35498: PPUSH
// if not mc_bases then
35499: LD_EXP 88
35503: NOT
35504: IFFALSE 35508
// exit ;
35506: GO 35669
// for i = 1 to mc_bases do
35508: LD_ADDR_VAR 0 2
35512: PUSH
35513: DOUBLE
35514: LD_INT 1
35516: DEC
35517: ST_TO_ADDR
35518: LD_EXP 88
35522: PUSH
35523: FOR_TO
35524: IFFALSE 35667
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35526: LD_ADDR_VAR 0 4
35530: PUSH
35531: LD_EXP 107
35535: PUSH
35536: LD_VAR 0 2
35540: ARRAY
35541: PUSH
35542: LD_EXP 110
35546: PUSH
35547: LD_VAR 0 2
35551: ARRAY
35552: UNION
35553: PPUSH
35554: LD_INT 33
35556: PUSH
35557: LD_INT 2
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: PPUSH
35564: CALL_OW 72
35568: ST_TO_ADDR
// if tmp then
35569: LD_VAR 0 4
35573: IFFALSE 35665
// for j in tmp do
35575: LD_ADDR_VAR 0 3
35579: PUSH
35580: LD_VAR 0 4
35584: PUSH
35585: FOR_IN
35586: IFFALSE 35663
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35588: LD_VAR 0 3
35592: PPUSH
35593: CALL_OW 312
35597: NOT
35598: PUSH
35599: LD_VAR 0 3
35603: PPUSH
35604: CALL_OW 256
35608: PUSH
35609: LD_INT 250
35611: GREATEREQUAL
35612: AND
35613: IFFALSE 35626
// Connect ( j ) else
35615: LD_VAR 0 3
35619: PPUSH
35620: CALL 58542 0 1
35624: GO 35661
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35626: LD_VAR 0 3
35630: PPUSH
35631: CALL_OW 256
35635: PUSH
35636: LD_INT 250
35638: LESS
35639: PUSH
35640: LD_VAR 0 3
35644: PPUSH
35645: CALL_OW 312
35649: AND
35650: IFFALSE 35661
// ComUnlink ( j ) ;
35652: LD_VAR 0 3
35656: PPUSH
35657: CALL_OW 136
35661: GO 35585
35663: POP
35664: POP
// end ;
35665: GO 35523
35667: POP
35668: POP
// end ;
35669: LD_VAR 0 1
35673: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35674: LD_INT 0
35676: PPUSH
35677: PPUSH
35678: PPUSH
35679: PPUSH
35680: PPUSH
// if not mc_bases then
35681: LD_EXP 88
35685: NOT
35686: IFFALSE 35690
// exit ;
35688: GO 36135
// for i = 1 to mc_bases do
35690: LD_ADDR_VAR 0 2
35694: PUSH
35695: DOUBLE
35696: LD_INT 1
35698: DEC
35699: ST_TO_ADDR
35700: LD_EXP 88
35704: PUSH
35705: FOR_TO
35706: IFFALSE 36133
// begin if not mc_produce [ i ] then
35708: LD_EXP 109
35712: PUSH
35713: LD_VAR 0 2
35717: ARRAY
35718: NOT
35719: IFFALSE 35723
// continue ;
35721: GO 35705
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35723: LD_ADDR_VAR 0 5
35727: PUSH
35728: LD_EXP 88
35732: PUSH
35733: LD_VAR 0 2
35737: ARRAY
35738: PPUSH
35739: LD_INT 30
35741: PUSH
35742: LD_INT 3
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: PPUSH
35749: CALL_OW 72
35753: ST_TO_ADDR
// if not fac then
35754: LD_VAR 0 5
35758: NOT
35759: IFFALSE 35763
// continue ;
35761: GO 35705
// for j in fac do
35763: LD_ADDR_VAR 0 3
35767: PUSH
35768: LD_VAR 0 5
35772: PUSH
35773: FOR_IN
35774: IFFALSE 36129
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35776: LD_VAR 0 3
35780: PPUSH
35781: CALL_OW 461
35785: PUSH
35786: LD_INT 2
35788: NONEQUAL
35789: PUSH
35790: LD_VAR 0 3
35794: PPUSH
35795: LD_INT 15
35797: PPUSH
35798: CALL 58202 0 2
35802: PUSH
35803: LD_INT 4
35805: ARRAY
35806: OR
35807: IFFALSE 35811
// continue ;
35809: GO 35773
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35811: LD_VAR 0 3
35815: PPUSH
35816: LD_EXP 109
35820: PUSH
35821: LD_VAR 0 2
35825: ARRAY
35826: PUSH
35827: LD_INT 1
35829: ARRAY
35830: PUSH
35831: LD_INT 1
35833: ARRAY
35834: PPUSH
35835: LD_EXP 109
35839: PUSH
35840: LD_VAR 0 2
35844: ARRAY
35845: PUSH
35846: LD_INT 1
35848: ARRAY
35849: PUSH
35850: LD_INT 2
35852: ARRAY
35853: PPUSH
35854: LD_EXP 109
35858: PUSH
35859: LD_VAR 0 2
35863: ARRAY
35864: PUSH
35865: LD_INT 1
35867: ARRAY
35868: PUSH
35869: LD_INT 3
35871: ARRAY
35872: PPUSH
35873: LD_EXP 109
35877: PUSH
35878: LD_VAR 0 2
35882: ARRAY
35883: PUSH
35884: LD_INT 1
35886: ARRAY
35887: PUSH
35888: LD_INT 4
35890: ARRAY
35891: PPUSH
35892: CALL_OW 448
35896: PUSH
35897: LD_VAR 0 3
35901: PPUSH
35902: LD_EXP 109
35906: PUSH
35907: LD_VAR 0 2
35911: ARRAY
35912: PUSH
35913: LD_INT 1
35915: ARRAY
35916: PUSH
35917: LD_INT 1
35919: ARRAY
35920: PUSH
35921: LD_EXP 109
35925: PUSH
35926: LD_VAR 0 2
35930: ARRAY
35931: PUSH
35932: LD_INT 1
35934: ARRAY
35935: PUSH
35936: LD_INT 2
35938: ARRAY
35939: PUSH
35940: LD_EXP 109
35944: PUSH
35945: LD_VAR 0 2
35949: ARRAY
35950: PUSH
35951: LD_INT 1
35953: ARRAY
35954: PUSH
35955: LD_INT 3
35957: ARRAY
35958: PUSH
35959: LD_EXP 109
35963: PUSH
35964: LD_VAR 0 2
35968: ARRAY
35969: PUSH
35970: LD_INT 1
35972: ARRAY
35973: PUSH
35974: LD_INT 4
35976: ARRAY
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: PPUSH
35984: CALL 61873 0 2
35988: AND
35989: IFFALSE 36127
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35991: LD_VAR 0 3
35995: PPUSH
35996: LD_EXP 109
36000: PUSH
36001: LD_VAR 0 2
36005: ARRAY
36006: PUSH
36007: LD_INT 1
36009: ARRAY
36010: PUSH
36011: LD_INT 1
36013: ARRAY
36014: PPUSH
36015: LD_EXP 109
36019: PUSH
36020: LD_VAR 0 2
36024: ARRAY
36025: PUSH
36026: LD_INT 1
36028: ARRAY
36029: PUSH
36030: LD_INT 2
36032: ARRAY
36033: PPUSH
36034: LD_EXP 109
36038: PUSH
36039: LD_VAR 0 2
36043: ARRAY
36044: PUSH
36045: LD_INT 1
36047: ARRAY
36048: PUSH
36049: LD_INT 3
36051: ARRAY
36052: PPUSH
36053: LD_EXP 109
36057: PUSH
36058: LD_VAR 0 2
36062: ARRAY
36063: PUSH
36064: LD_INT 1
36066: ARRAY
36067: PUSH
36068: LD_INT 4
36070: ARRAY
36071: PPUSH
36072: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36076: LD_ADDR_VAR 0 4
36080: PUSH
36081: LD_EXP 109
36085: PUSH
36086: LD_VAR 0 2
36090: ARRAY
36091: PPUSH
36092: LD_INT 1
36094: PPUSH
36095: CALL_OW 3
36099: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36100: LD_ADDR_EXP 109
36104: PUSH
36105: LD_EXP 109
36109: PPUSH
36110: LD_VAR 0 2
36114: PPUSH
36115: LD_VAR 0 4
36119: PPUSH
36120: CALL_OW 1
36124: ST_TO_ADDR
// break ;
36125: GO 36129
// end ; end ;
36127: GO 35773
36129: POP
36130: POP
// end ;
36131: GO 35705
36133: POP
36134: POP
// end ;
36135: LD_VAR 0 1
36139: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36140: LD_INT 0
36142: PPUSH
36143: PPUSH
36144: PPUSH
// if not mc_bases then
36145: LD_EXP 88
36149: NOT
36150: IFFALSE 36154
// exit ;
36152: GO 36243
// for i = 1 to mc_bases do
36154: LD_ADDR_VAR 0 2
36158: PUSH
36159: DOUBLE
36160: LD_INT 1
36162: DEC
36163: ST_TO_ADDR
36164: LD_EXP 88
36168: PUSH
36169: FOR_TO
36170: IFFALSE 36241
// begin if mc_attack [ i ] then
36172: LD_EXP 108
36176: PUSH
36177: LD_VAR 0 2
36181: ARRAY
36182: IFFALSE 36239
// begin tmp := mc_attack [ i ] [ 1 ] ;
36184: LD_ADDR_VAR 0 3
36188: PUSH
36189: LD_EXP 108
36193: PUSH
36194: LD_VAR 0 2
36198: ARRAY
36199: PUSH
36200: LD_INT 1
36202: ARRAY
36203: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36204: LD_ADDR_EXP 108
36208: PUSH
36209: LD_EXP 108
36213: PPUSH
36214: LD_VAR 0 2
36218: PPUSH
36219: EMPTY
36220: PPUSH
36221: CALL_OW 1
36225: ST_TO_ADDR
// Attack ( tmp ) ;
36226: LD_VAR 0 3
36230: PPUSH
36231: CALL 99747 0 1
// exit ;
36235: POP
36236: POP
36237: GO 36243
// end ; end ;
36239: GO 36169
36241: POP
36242: POP
// end ;
36243: LD_VAR 0 1
36247: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36248: LD_INT 0
36250: PPUSH
36251: PPUSH
36252: PPUSH
36253: PPUSH
36254: PPUSH
36255: PPUSH
36256: PPUSH
// if not mc_bases then
36257: LD_EXP 88
36261: NOT
36262: IFFALSE 36266
// exit ;
36264: GO 36848
// for i = 1 to mc_bases do
36266: LD_ADDR_VAR 0 2
36270: PUSH
36271: DOUBLE
36272: LD_INT 1
36274: DEC
36275: ST_TO_ADDR
36276: LD_EXP 88
36280: PUSH
36281: FOR_TO
36282: IFFALSE 36846
// begin if not mc_bases [ i ] then
36284: LD_EXP 88
36288: PUSH
36289: LD_VAR 0 2
36293: ARRAY
36294: NOT
36295: IFFALSE 36299
// continue ;
36297: GO 36281
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36299: LD_ADDR_VAR 0 7
36303: PUSH
36304: LD_EXP 88
36308: PUSH
36309: LD_VAR 0 2
36313: ARRAY
36314: PUSH
36315: LD_INT 1
36317: ARRAY
36318: PPUSH
36319: CALL 52445 0 1
36323: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36324: LD_ADDR_EXP 111
36328: PUSH
36329: LD_EXP 111
36333: PPUSH
36334: LD_VAR 0 2
36338: PPUSH
36339: LD_EXP 88
36343: PUSH
36344: LD_VAR 0 2
36348: ARRAY
36349: PUSH
36350: LD_INT 1
36352: ARRAY
36353: PPUSH
36354: CALL_OW 255
36358: PPUSH
36359: LD_EXP 113
36363: PUSH
36364: LD_VAR 0 2
36368: ARRAY
36369: PPUSH
36370: CALL 52410 0 2
36374: PPUSH
36375: CALL_OW 1
36379: ST_TO_ADDR
// if not mc_scan [ i ] then
36380: LD_EXP 111
36384: PUSH
36385: LD_VAR 0 2
36389: ARRAY
36390: NOT
36391: IFFALSE 36546
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36393: LD_ADDR_VAR 0 4
36397: PUSH
36398: LD_EXP 88
36402: PUSH
36403: LD_VAR 0 2
36407: ARRAY
36408: PPUSH
36409: LD_INT 2
36411: PUSH
36412: LD_INT 25
36414: PUSH
36415: LD_INT 5
36417: PUSH
36418: EMPTY
36419: LIST
36420: LIST
36421: PUSH
36422: LD_INT 25
36424: PUSH
36425: LD_INT 8
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 25
36434: PUSH
36435: LD_INT 9
36437: PUSH
36438: EMPTY
36439: LIST
36440: LIST
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: LIST
36446: LIST
36447: PPUSH
36448: CALL_OW 72
36452: ST_TO_ADDR
// if not tmp then
36453: LD_VAR 0 4
36457: NOT
36458: IFFALSE 36462
// continue ;
36460: GO 36281
// for j in tmp do
36462: LD_ADDR_VAR 0 3
36466: PUSH
36467: LD_VAR 0 4
36471: PUSH
36472: FOR_IN
36473: IFFALSE 36544
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36475: LD_VAR 0 3
36479: PPUSH
36480: CALL_OW 310
36484: PPUSH
36485: CALL_OW 266
36489: PUSH
36490: LD_INT 5
36492: EQUAL
36493: PUSH
36494: LD_VAR 0 3
36498: PPUSH
36499: CALL_OW 257
36503: PUSH
36504: LD_INT 1
36506: EQUAL
36507: AND
36508: PUSH
36509: LD_VAR 0 3
36513: PPUSH
36514: CALL_OW 459
36518: NOT
36519: AND
36520: PUSH
36521: LD_VAR 0 7
36525: AND
36526: IFFALSE 36542
// ComChangeProfession ( j , class ) ;
36528: LD_VAR 0 3
36532: PPUSH
36533: LD_VAR 0 7
36537: PPUSH
36538: CALL_OW 123
36542: GO 36472
36544: POP
36545: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36546: LD_EXP 111
36550: PUSH
36551: LD_VAR 0 2
36555: ARRAY
36556: PUSH
36557: LD_EXP 110
36561: PUSH
36562: LD_VAR 0 2
36566: ARRAY
36567: NOT
36568: AND
36569: PUSH
36570: LD_EXP 88
36574: PUSH
36575: LD_VAR 0 2
36579: ARRAY
36580: PPUSH
36581: LD_INT 30
36583: PUSH
36584: LD_INT 32
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PPUSH
36591: CALL_OW 72
36595: NOT
36596: AND
36597: PUSH
36598: LD_EXP 88
36602: PUSH
36603: LD_VAR 0 2
36607: ARRAY
36608: PPUSH
36609: LD_INT 2
36611: PUSH
36612: LD_INT 30
36614: PUSH
36615: LD_INT 4
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: LD_INT 30
36624: PUSH
36625: LD_INT 5
36627: PUSH
36628: EMPTY
36629: LIST
36630: LIST
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: LIST
36636: PPUSH
36637: CALL_OW 72
36641: NOT
36642: AND
36643: IFFALSE 36775
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36645: LD_ADDR_VAR 0 4
36649: PUSH
36650: LD_EXP 88
36654: PUSH
36655: LD_VAR 0 2
36659: ARRAY
36660: PPUSH
36661: LD_INT 2
36663: PUSH
36664: LD_INT 25
36666: PUSH
36667: LD_INT 1
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: PUSH
36674: LD_INT 25
36676: PUSH
36677: LD_INT 5
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 25
36686: PUSH
36687: LD_INT 8
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: PUSH
36694: LD_INT 25
36696: PUSH
36697: LD_INT 9
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: LIST
36708: LIST
36709: LIST
36710: PPUSH
36711: CALL_OW 72
36715: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36716: LD_ADDR_VAR 0 4
36720: PUSH
36721: LD_VAR 0 4
36725: PUSH
36726: LD_VAR 0 4
36730: PPUSH
36731: LD_INT 18
36733: PPUSH
36734: CALL 84170 0 2
36738: DIFF
36739: ST_TO_ADDR
// if tmp then
36740: LD_VAR 0 4
36744: IFFALSE 36775
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36746: LD_VAR 0 2
36750: PPUSH
36751: LD_VAR 0 4
36755: PPUSH
36756: LD_EXP 113
36760: PUSH
36761: LD_VAR 0 2
36765: ARRAY
36766: PPUSH
36767: CALL 104456 0 3
// exit ;
36771: POP
36772: POP
36773: GO 36848
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36775: LD_EXP 111
36779: PUSH
36780: LD_VAR 0 2
36784: ARRAY
36785: PUSH
36786: LD_EXP 110
36790: PUSH
36791: LD_VAR 0 2
36795: ARRAY
36796: AND
36797: IFFALSE 36844
// begin tmp := mc_defender [ i ] ;
36799: LD_ADDR_VAR 0 4
36803: PUSH
36804: LD_EXP 110
36808: PUSH
36809: LD_VAR 0 2
36813: ARRAY
36814: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36815: LD_VAR 0 2
36819: PPUSH
36820: LD_VAR 0 4
36824: PPUSH
36825: LD_EXP 111
36829: PUSH
36830: LD_VAR 0 2
36834: ARRAY
36835: PPUSH
36836: CALL 105017 0 3
// exit ;
36840: POP
36841: POP
36842: GO 36848
// end ; end ;
36844: GO 36281
36846: POP
36847: POP
// end ;
36848: LD_VAR 0 1
36852: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36853: LD_INT 0
36855: PPUSH
36856: PPUSH
36857: PPUSH
36858: PPUSH
36859: PPUSH
36860: PPUSH
36861: PPUSH
36862: PPUSH
36863: PPUSH
36864: PPUSH
36865: PPUSH
// if not mc_bases then
36866: LD_EXP 88
36870: NOT
36871: IFFALSE 36875
// exit ;
36873: GO 37962
// for i = 1 to mc_bases do
36875: LD_ADDR_VAR 0 2
36879: PUSH
36880: DOUBLE
36881: LD_INT 1
36883: DEC
36884: ST_TO_ADDR
36885: LD_EXP 88
36889: PUSH
36890: FOR_TO
36891: IFFALSE 37960
// begin tmp := mc_lab [ i ] ;
36893: LD_ADDR_VAR 0 6
36897: PUSH
36898: LD_EXP 121
36902: PUSH
36903: LD_VAR 0 2
36907: ARRAY
36908: ST_TO_ADDR
// if not tmp then
36909: LD_VAR 0 6
36913: NOT
36914: IFFALSE 36918
// continue ;
36916: GO 36890
// idle_lab := 0 ;
36918: LD_ADDR_VAR 0 11
36922: PUSH
36923: LD_INT 0
36925: ST_TO_ADDR
// for j in tmp do
36926: LD_ADDR_VAR 0 3
36930: PUSH
36931: LD_VAR 0 6
36935: PUSH
36936: FOR_IN
36937: IFFALSE 37956
// begin researching := false ;
36939: LD_ADDR_VAR 0 10
36943: PUSH
36944: LD_INT 0
36946: ST_TO_ADDR
// side := GetSide ( j ) ;
36947: LD_ADDR_VAR 0 4
36951: PUSH
36952: LD_VAR 0 3
36956: PPUSH
36957: CALL_OW 255
36961: ST_TO_ADDR
// if not mc_tech [ side ] then
36962: LD_EXP 115
36966: PUSH
36967: LD_VAR 0 4
36971: ARRAY
36972: NOT
36973: IFFALSE 36977
// continue ;
36975: GO 36936
// if BuildingStatus ( j ) = bs_idle then
36977: LD_VAR 0 3
36981: PPUSH
36982: CALL_OW 461
36986: PUSH
36987: LD_INT 2
36989: EQUAL
36990: IFFALSE 37178
// begin if idle_lab and UnitsInside ( j ) < 6 then
36992: LD_VAR 0 11
36996: PUSH
36997: LD_VAR 0 3
37001: PPUSH
37002: CALL_OW 313
37006: PUSH
37007: LD_INT 6
37009: LESS
37010: AND
37011: IFFALSE 37082
// begin tmp2 := UnitsInside ( idle_lab ) ;
37013: LD_ADDR_VAR 0 9
37017: PUSH
37018: LD_VAR 0 11
37022: PPUSH
37023: CALL_OW 313
37027: ST_TO_ADDR
// if tmp2 then
37028: LD_VAR 0 9
37032: IFFALSE 37074
// for x in tmp2 do
37034: LD_ADDR_VAR 0 7
37038: PUSH
37039: LD_VAR 0 9
37043: PUSH
37044: FOR_IN
37045: IFFALSE 37072
// begin ComExitBuilding ( x ) ;
37047: LD_VAR 0 7
37051: PPUSH
37052: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37056: LD_VAR 0 7
37060: PPUSH
37061: LD_VAR 0 3
37065: PPUSH
37066: CALL_OW 180
// end ;
37070: GO 37044
37072: POP
37073: POP
// idle_lab := 0 ;
37074: LD_ADDR_VAR 0 11
37078: PUSH
37079: LD_INT 0
37081: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37082: LD_ADDR_VAR 0 5
37086: PUSH
37087: LD_EXP 115
37091: PUSH
37092: LD_VAR 0 4
37096: ARRAY
37097: PUSH
37098: FOR_IN
37099: IFFALSE 37159
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37101: LD_VAR 0 3
37105: PPUSH
37106: LD_VAR 0 5
37110: PPUSH
37111: CALL_OW 430
37115: PUSH
37116: LD_VAR 0 4
37120: PPUSH
37121: LD_VAR 0 5
37125: PPUSH
37126: CALL 51515 0 2
37130: AND
37131: IFFALSE 37157
// begin researching := true ;
37133: LD_ADDR_VAR 0 10
37137: PUSH
37138: LD_INT 1
37140: ST_TO_ADDR
// ComResearch ( j , t ) ;
37141: LD_VAR 0 3
37145: PPUSH
37146: LD_VAR 0 5
37150: PPUSH
37151: CALL_OW 124
// break ;
37155: GO 37159
// end ;
37157: GO 37098
37159: POP
37160: POP
// if not researching then
37161: LD_VAR 0 10
37165: NOT
37166: IFFALSE 37178
// idle_lab := j ;
37168: LD_ADDR_VAR 0 11
37172: PUSH
37173: LD_VAR 0 3
37177: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37178: LD_VAR 0 3
37182: PPUSH
37183: CALL_OW 461
37187: PUSH
37188: LD_INT 10
37190: EQUAL
37191: IFFALSE 37779
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37193: LD_EXP 117
37197: PUSH
37198: LD_VAR 0 2
37202: ARRAY
37203: NOT
37204: PUSH
37205: LD_EXP 118
37209: PUSH
37210: LD_VAR 0 2
37214: ARRAY
37215: NOT
37216: AND
37217: PUSH
37218: LD_EXP 115
37222: PUSH
37223: LD_VAR 0 4
37227: ARRAY
37228: PUSH
37229: LD_INT 1
37231: GREATER
37232: AND
37233: IFFALSE 37364
// begin ComCancel ( j ) ;
37235: LD_VAR 0 3
37239: PPUSH
37240: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37244: LD_ADDR_EXP 115
37248: PUSH
37249: LD_EXP 115
37253: PPUSH
37254: LD_VAR 0 4
37258: PPUSH
37259: LD_EXP 115
37263: PUSH
37264: LD_VAR 0 4
37268: ARRAY
37269: PPUSH
37270: LD_EXP 115
37274: PUSH
37275: LD_VAR 0 4
37279: ARRAY
37280: PUSH
37281: LD_INT 1
37283: MINUS
37284: PPUSH
37285: LD_EXP 115
37289: PUSH
37290: LD_VAR 0 4
37294: ARRAY
37295: PPUSH
37296: LD_INT 0
37298: PPUSH
37299: CALL 55027 0 4
37303: PPUSH
37304: CALL_OW 1
37308: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37309: LD_ADDR_EXP 115
37313: PUSH
37314: LD_EXP 115
37318: PPUSH
37319: LD_VAR 0 4
37323: PPUSH
37324: LD_EXP 115
37328: PUSH
37329: LD_VAR 0 4
37333: ARRAY
37334: PPUSH
37335: LD_EXP 115
37339: PUSH
37340: LD_VAR 0 4
37344: ARRAY
37345: PPUSH
37346: LD_INT 1
37348: PPUSH
37349: LD_INT 0
37351: PPUSH
37352: CALL 55027 0 4
37356: PPUSH
37357: CALL_OW 1
37361: ST_TO_ADDR
// continue ;
37362: GO 36936
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37364: LD_EXP 117
37368: PUSH
37369: LD_VAR 0 2
37373: ARRAY
37374: PUSH
37375: LD_EXP 118
37379: PUSH
37380: LD_VAR 0 2
37384: ARRAY
37385: NOT
37386: AND
37387: IFFALSE 37514
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37389: LD_ADDR_EXP 118
37393: PUSH
37394: LD_EXP 118
37398: PPUSH
37399: LD_VAR 0 2
37403: PUSH
37404: LD_EXP 118
37408: PUSH
37409: LD_VAR 0 2
37413: ARRAY
37414: PUSH
37415: LD_INT 1
37417: PLUS
37418: PUSH
37419: EMPTY
37420: LIST
37421: LIST
37422: PPUSH
37423: LD_EXP 117
37427: PUSH
37428: LD_VAR 0 2
37432: ARRAY
37433: PUSH
37434: LD_INT 1
37436: ARRAY
37437: PPUSH
37438: CALL 55609 0 3
37442: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37443: LD_EXP 117
37447: PUSH
37448: LD_VAR 0 2
37452: ARRAY
37453: PUSH
37454: LD_INT 1
37456: ARRAY
37457: PPUSH
37458: LD_INT 112
37460: PPUSH
37461: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37465: LD_ADDR_VAR 0 9
37469: PUSH
37470: LD_EXP 117
37474: PUSH
37475: LD_VAR 0 2
37479: ARRAY
37480: PPUSH
37481: LD_INT 1
37483: PPUSH
37484: CALL_OW 3
37488: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37489: LD_ADDR_EXP 117
37493: PUSH
37494: LD_EXP 117
37498: PPUSH
37499: LD_VAR 0 2
37503: PPUSH
37504: LD_VAR 0 9
37508: PPUSH
37509: CALL_OW 1
37513: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37514: LD_EXP 117
37518: PUSH
37519: LD_VAR 0 2
37523: ARRAY
37524: PUSH
37525: LD_EXP 118
37529: PUSH
37530: LD_VAR 0 2
37534: ARRAY
37535: AND
37536: PUSH
37537: LD_EXP 118
37541: PUSH
37542: LD_VAR 0 2
37546: ARRAY
37547: PUSH
37548: LD_INT 1
37550: ARRAY
37551: PPUSH
37552: CALL_OW 310
37556: NOT
37557: AND
37558: PUSH
37559: LD_VAR 0 3
37563: PPUSH
37564: CALL_OW 313
37568: PUSH
37569: LD_INT 6
37571: EQUAL
37572: AND
37573: IFFALSE 37629
// begin tmp2 := UnitsInside ( j ) ;
37575: LD_ADDR_VAR 0 9
37579: PUSH
37580: LD_VAR 0 3
37584: PPUSH
37585: CALL_OW 313
37589: ST_TO_ADDR
// if tmp2 = 6 then
37590: LD_VAR 0 9
37594: PUSH
37595: LD_INT 6
37597: EQUAL
37598: IFFALSE 37629
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37600: LD_VAR 0 9
37604: PUSH
37605: LD_INT 1
37607: ARRAY
37608: PPUSH
37609: LD_INT 112
37611: PPUSH
37612: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37616: LD_VAR 0 9
37620: PUSH
37621: LD_INT 1
37623: ARRAY
37624: PPUSH
37625: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37629: LD_EXP 118
37633: PUSH
37634: LD_VAR 0 2
37638: ARRAY
37639: PUSH
37640: LD_EXP 118
37644: PUSH
37645: LD_VAR 0 2
37649: ARRAY
37650: PUSH
37651: LD_INT 1
37653: ARRAY
37654: PPUSH
37655: CALL_OW 314
37659: NOT
37660: AND
37661: PUSH
37662: LD_EXP 118
37666: PUSH
37667: LD_VAR 0 2
37671: ARRAY
37672: PUSH
37673: LD_INT 1
37675: ARRAY
37676: PPUSH
37677: CALL_OW 310
37681: NOT
37682: AND
37683: IFFALSE 37709
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37685: LD_EXP 118
37689: PUSH
37690: LD_VAR 0 2
37694: ARRAY
37695: PUSH
37696: LD_INT 1
37698: ARRAY
37699: PPUSH
37700: LD_VAR 0 3
37704: PPUSH
37705: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37709: LD_EXP 118
37713: PUSH
37714: LD_VAR 0 2
37718: ARRAY
37719: PUSH
37720: LD_INT 1
37722: ARRAY
37723: PPUSH
37724: CALL_OW 310
37728: PUSH
37729: LD_EXP 118
37733: PUSH
37734: LD_VAR 0 2
37738: ARRAY
37739: PUSH
37740: LD_INT 1
37742: ARRAY
37743: PPUSH
37744: CALL_OW 310
37748: PPUSH
37749: CALL_OW 461
37753: PUSH
37754: LD_INT 3
37756: NONEQUAL
37757: AND
37758: IFFALSE 37779
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37760: LD_EXP 118
37764: PUSH
37765: LD_VAR 0 2
37769: ARRAY
37770: PUSH
37771: LD_INT 1
37773: ARRAY
37774: PPUSH
37775: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37779: LD_VAR 0 3
37783: PPUSH
37784: CALL_OW 461
37788: PUSH
37789: LD_INT 6
37791: EQUAL
37792: PUSH
37793: LD_VAR 0 6
37797: PUSH
37798: LD_INT 1
37800: GREATER
37801: AND
37802: IFFALSE 37954
// begin sci := [ ] ;
37804: LD_ADDR_VAR 0 8
37808: PUSH
37809: EMPTY
37810: ST_TO_ADDR
// for x in ( tmp diff j ) do
37811: LD_ADDR_VAR 0 7
37815: PUSH
37816: LD_VAR 0 6
37820: PUSH
37821: LD_VAR 0 3
37825: DIFF
37826: PUSH
37827: FOR_IN
37828: IFFALSE 37880
// begin if sci = 6 then
37830: LD_VAR 0 8
37834: PUSH
37835: LD_INT 6
37837: EQUAL
37838: IFFALSE 37842
// break ;
37840: GO 37880
// if BuildingStatus ( x ) = bs_idle then
37842: LD_VAR 0 7
37846: PPUSH
37847: CALL_OW 461
37851: PUSH
37852: LD_INT 2
37854: EQUAL
37855: IFFALSE 37878
// sci := sci ^ UnitsInside ( x ) ;
37857: LD_ADDR_VAR 0 8
37861: PUSH
37862: LD_VAR 0 8
37866: PUSH
37867: LD_VAR 0 7
37871: PPUSH
37872: CALL_OW 313
37876: ADD
37877: ST_TO_ADDR
// end ;
37878: GO 37827
37880: POP
37881: POP
// if not sci then
37882: LD_VAR 0 8
37886: NOT
37887: IFFALSE 37891
// continue ;
37889: GO 36936
// for x in sci do
37891: LD_ADDR_VAR 0 7
37895: PUSH
37896: LD_VAR 0 8
37900: PUSH
37901: FOR_IN
37902: IFFALSE 37952
// if IsInUnit ( x ) and not HasTask ( x ) then
37904: LD_VAR 0 7
37908: PPUSH
37909: CALL_OW 310
37913: PUSH
37914: LD_VAR 0 7
37918: PPUSH
37919: CALL_OW 314
37923: NOT
37924: AND
37925: IFFALSE 37950
// begin ComExitBuilding ( x ) ;
37927: LD_VAR 0 7
37931: PPUSH
37932: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37936: LD_VAR 0 7
37940: PPUSH
37941: LD_VAR 0 3
37945: PPUSH
37946: CALL_OW 180
// end ;
37950: GO 37901
37952: POP
37953: POP
// end ; end ;
37954: GO 36936
37956: POP
37957: POP
// end ;
37958: GO 36890
37960: POP
37961: POP
// end ;
37962: LD_VAR 0 1
37966: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37967: LD_INT 0
37969: PPUSH
37970: PPUSH
// if not mc_bases then
37971: LD_EXP 88
37975: NOT
37976: IFFALSE 37980
// exit ;
37978: GO 38061
// for i = 1 to mc_bases do
37980: LD_ADDR_VAR 0 2
37984: PUSH
37985: DOUBLE
37986: LD_INT 1
37988: DEC
37989: ST_TO_ADDR
37990: LD_EXP 88
37994: PUSH
37995: FOR_TO
37996: IFFALSE 38059
// if mc_mines [ i ] and mc_miners [ i ] then
37998: LD_EXP 101
38002: PUSH
38003: LD_VAR 0 2
38007: ARRAY
38008: PUSH
38009: LD_EXP 102
38013: PUSH
38014: LD_VAR 0 2
38018: ARRAY
38019: AND
38020: IFFALSE 38057
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38022: LD_EXP 102
38026: PUSH
38027: LD_VAR 0 2
38031: ARRAY
38032: PUSH
38033: LD_INT 1
38035: ARRAY
38036: PPUSH
38037: CALL_OW 255
38041: PPUSH
38042: LD_EXP 101
38046: PUSH
38047: LD_VAR 0 2
38051: ARRAY
38052: PPUSH
38053: CALL 52598 0 2
38057: GO 37995
38059: POP
38060: POP
// end ;
38061: LD_VAR 0 1
38065: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38066: LD_INT 0
38068: PPUSH
38069: PPUSH
38070: PPUSH
38071: PPUSH
38072: PPUSH
38073: PPUSH
38074: PPUSH
38075: PPUSH
// if not mc_bases or not mc_parking then
38076: LD_EXP 88
38080: NOT
38081: PUSH
38082: LD_EXP 112
38086: NOT
38087: OR
38088: IFFALSE 38092
// exit ;
38090: GO 38791
// for i = 1 to mc_bases do
38092: LD_ADDR_VAR 0 2
38096: PUSH
38097: DOUBLE
38098: LD_INT 1
38100: DEC
38101: ST_TO_ADDR
38102: LD_EXP 88
38106: PUSH
38107: FOR_TO
38108: IFFALSE 38789
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38110: LD_EXP 88
38114: PUSH
38115: LD_VAR 0 2
38119: ARRAY
38120: NOT
38121: PUSH
38122: LD_EXP 112
38126: PUSH
38127: LD_VAR 0 2
38131: ARRAY
38132: NOT
38133: OR
38134: IFFALSE 38138
// continue ;
38136: GO 38107
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38138: LD_ADDR_VAR 0 5
38142: PUSH
38143: LD_EXP 88
38147: PUSH
38148: LD_VAR 0 2
38152: ARRAY
38153: PUSH
38154: LD_INT 1
38156: ARRAY
38157: PPUSH
38158: CALL_OW 255
38162: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38163: LD_ADDR_VAR 0 6
38167: PUSH
38168: LD_EXP 88
38172: PUSH
38173: LD_VAR 0 2
38177: ARRAY
38178: PPUSH
38179: LD_INT 30
38181: PUSH
38182: LD_INT 3
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PPUSH
38189: CALL_OW 72
38193: ST_TO_ADDR
// if not fac then
38194: LD_VAR 0 6
38198: NOT
38199: IFFALSE 38250
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38201: LD_ADDR_VAR 0 6
38205: PUSH
38206: LD_EXP 88
38210: PUSH
38211: LD_VAR 0 2
38215: ARRAY
38216: PPUSH
38217: LD_INT 2
38219: PUSH
38220: LD_INT 30
38222: PUSH
38223: LD_INT 0
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 30
38232: PUSH
38233: LD_INT 1
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: LIST
38244: PPUSH
38245: CALL_OW 72
38249: ST_TO_ADDR
// if not fac then
38250: LD_VAR 0 6
38254: NOT
38255: IFFALSE 38259
// continue ;
38257: GO 38107
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38259: LD_ADDR_VAR 0 7
38263: PUSH
38264: LD_EXP 112
38268: PUSH
38269: LD_VAR 0 2
38273: ARRAY
38274: PPUSH
38275: LD_INT 22
38277: PUSH
38278: LD_VAR 0 5
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 21
38289: PUSH
38290: LD_INT 2
38292: PUSH
38293: EMPTY
38294: LIST
38295: LIST
38296: PUSH
38297: LD_INT 3
38299: PUSH
38300: LD_INT 24
38302: PUSH
38303: LD_INT 1000
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: LIST
38318: PPUSH
38319: CALL_OW 70
38323: ST_TO_ADDR
// for j in fac do
38324: LD_ADDR_VAR 0 3
38328: PUSH
38329: LD_VAR 0 6
38333: PUSH
38334: FOR_IN
38335: IFFALSE 38416
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38337: LD_ADDR_VAR 0 7
38341: PUSH
38342: LD_VAR 0 7
38346: PUSH
38347: LD_INT 22
38349: PUSH
38350: LD_VAR 0 5
38354: PUSH
38355: EMPTY
38356: LIST
38357: LIST
38358: PUSH
38359: LD_INT 91
38361: PUSH
38362: LD_VAR 0 3
38366: PUSH
38367: LD_INT 15
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 21
38377: PUSH
38378: LD_INT 2
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: LD_INT 3
38387: PUSH
38388: LD_INT 24
38390: PUSH
38391: LD_INT 1000
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: PPUSH
38408: CALL_OW 69
38412: UNION
38413: ST_TO_ADDR
38414: GO 38334
38416: POP
38417: POP
// if not vehs then
38418: LD_VAR 0 7
38422: NOT
38423: IFFALSE 38449
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38425: LD_ADDR_EXP 100
38429: PUSH
38430: LD_EXP 100
38434: PPUSH
38435: LD_VAR 0 2
38439: PPUSH
38440: EMPTY
38441: PPUSH
38442: CALL_OW 1
38446: ST_TO_ADDR
// continue ;
38447: GO 38107
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38449: LD_ADDR_VAR 0 8
38453: PUSH
38454: LD_EXP 88
38458: PUSH
38459: LD_VAR 0 2
38463: ARRAY
38464: PPUSH
38465: LD_INT 30
38467: PUSH
38468: LD_INT 3
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: PPUSH
38475: CALL_OW 72
38479: ST_TO_ADDR
// if tmp then
38480: LD_VAR 0 8
38484: IFFALSE 38587
// begin for j in tmp do
38486: LD_ADDR_VAR 0 3
38490: PUSH
38491: LD_VAR 0 8
38495: PUSH
38496: FOR_IN
38497: IFFALSE 38585
// for k in UnitsInside ( j ) do
38499: LD_ADDR_VAR 0 4
38503: PUSH
38504: LD_VAR 0 3
38508: PPUSH
38509: CALL_OW 313
38513: PUSH
38514: FOR_IN
38515: IFFALSE 38581
// if k then
38517: LD_VAR 0 4
38521: IFFALSE 38579
// if not k in mc_repair_vehicle [ i ] then
38523: LD_VAR 0 4
38527: PUSH
38528: LD_EXP 100
38532: PUSH
38533: LD_VAR 0 2
38537: ARRAY
38538: IN
38539: NOT
38540: IFFALSE 38579
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38542: LD_ADDR_EXP 100
38546: PUSH
38547: LD_EXP 100
38551: PPUSH
38552: LD_VAR 0 2
38556: PPUSH
38557: LD_EXP 100
38561: PUSH
38562: LD_VAR 0 2
38566: ARRAY
38567: PUSH
38568: LD_VAR 0 4
38572: UNION
38573: PPUSH
38574: CALL_OW 1
38578: ST_TO_ADDR
38579: GO 38514
38581: POP
38582: POP
38583: GO 38496
38585: POP
38586: POP
// end ; if not mc_repair_vehicle [ i ] then
38587: LD_EXP 100
38591: PUSH
38592: LD_VAR 0 2
38596: ARRAY
38597: NOT
38598: IFFALSE 38602
// continue ;
38600: GO 38107
// for j in mc_repair_vehicle [ i ] do
38602: LD_ADDR_VAR 0 3
38606: PUSH
38607: LD_EXP 100
38611: PUSH
38612: LD_VAR 0 2
38616: ARRAY
38617: PUSH
38618: FOR_IN
38619: IFFALSE 38785
// begin if GetClass ( j ) <> 3 then
38621: LD_VAR 0 3
38625: PPUSH
38626: CALL_OW 257
38630: PUSH
38631: LD_INT 3
38633: NONEQUAL
38634: IFFALSE 38675
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38636: LD_ADDR_EXP 100
38640: PUSH
38641: LD_EXP 100
38645: PPUSH
38646: LD_VAR 0 2
38650: PPUSH
38651: LD_EXP 100
38655: PUSH
38656: LD_VAR 0 2
38660: ARRAY
38661: PUSH
38662: LD_VAR 0 3
38666: DIFF
38667: PPUSH
38668: CALL_OW 1
38672: ST_TO_ADDR
// continue ;
38673: GO 38618
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38675: LD_VAR 0 3
38679: PPUSH
38680: CALL_OW 311
38684: NOT
38685: PUSH
38686: LD_VAR 0 3
38690: PUSH
38691: LD_EXP 91
38695: PUSH
38696: LD_VAR 0 2
38700: ARRAY
38701: PUSH
38702: LD_INT 1
38704: ARRAY
38705: IN
38706: NOT
38707: AND
38708: PUSH
38709: LD_VAR 0 3
38713: PUSH
38714: LD_EXP 91
38718: PUSH
38719: LD_VAR 0 2
38723: ARRAY
38724: PUSH
38725: LD_INT 2
38727: ARRAY
38728: IN
38729: NOT
38730: AND
38731: IFFALSE 38783
// begin if IsInUnit ( j ) then
38733: LD_VAR 0 3
38737: PPUSH
38738: CALL_OW 310
38742: IFFALSE 38753
// ComExitBuilding ( j ) ;
38744: LD_VAR 0 3
38748: PPUSH
38749: CALL_OW 122
// if not HasTask ( j ) then
38753: LD_VAR 0 3
38757: PPUSH
38758: CALL_OW 314
38762: NOT
38763: IFFALSE 38783
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38765: LD_VAR 0 3
38769: PPUSH
38770: LD_VAR 0 7
38774: PUSH
38775: LD_INT 1
38777: ARRAY
38778: PPUSH
38779: CALL_OW 189
// end ; end ;
38783: GO 38618
38785: POP
38786: POP
// end ;
38787: GO 38107
38789: POP
38790: POP
// end ;
38791: LD_VAR 0 1
38795: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38796: LD_INT 0
38798: PPUSH
38799: PPUSH
38800: PPUSH
38801: PPUSH
38802: PPUSH
38803: PPUSH
38804: PPUSH
38805: PPUSH
38806: PPUSH
38807: PPUSH
38808: PPUSH
// if not mc_bases then
38809: LD_EXP 88
38813: NOT
38814: IFFALSE 38818
// exit ;
38816: GO 39620
// for i = 1 to mc_bases do
38818: LD_ADDR_VAR 0 2
38822: PUSH
38823: DOUBLE
38824: LD_INT 1
38826: DEC
38827: ST_TO_ADDR
38828: LD_EXP 88
38832: PUSH
38833: FOR_TO
38834: IFFALSE 39618
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38836: LD_EXP 116
38840: PUSH
38841: LD_VAR 0 2
38845: ARRAY
38846: NOT
38847: PUSH
38848: LD_EXP 91
38852: PUSH
38853: LD_VAR 0 2
38857: ARRAY
38858: PUSH
38859: LD_INT 1
38861: ARRAY
38862: OR
38863: PUSH
38864: LD_EXP 91
38868: PUSH
38869: LD_VAR 0 2
38873: ARRAY
38874: PUSH
38875: LD_INT 2
38877: ARRAY
38878: OR
38879: PUSH
38880: LD_EXP 114
38884: PUSH
38885: LD_VAR 0 2
38889: ARRAY
38890: PPUSH
38891: LD_INT 1
38893: PPUSH
38894: CALL_OW 325
38898: NOT
38899: OR
38900: PUSH
38901: LD_EXP 111
38905: PUSH
38906: LD_VAR 0 2
38910: ARRAY
38911: OR
38912: IFFALSE 38916
// continue ;
38914: GO 38833
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38916: LD_ADDR_VAR 0 8
38920: PUSH
38921: LD_EXP 88
38925: PUSH
38926: LD_VAR 0 2
38930: ARRAY
38931: PPUSH
38932: LD_INT 25
38934: PUSH
38935: LD_INT 4
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 50
38944: PUSH
38945: EMPTY
38946: LIST
38947: PUSH
38948: LD_INT 3
38950: PUSH
38951: LD_INT 60
38953: PUSH
38954: EMPTY
38955: LIST
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: PUSH
38961: EMPTY
38962: LIST
38963: LIST
38964: LIST
38965: PPUSH
38966: CALL_OW 72
38970: PUSH
38971: LD_EXP 92
38975: PUSH
38976: LD_VAR 0 2
38980: ARRAY
38981: DIFF
38982: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38983: LD_ADDR_VAR 0 9
38987: PUSH
38988: LD_EXP 88
38992: PUSH
38993: LD_VAR 0 2
38997: ARRAY
38998: PPUSH
38999: LD_INT 2
39001: PUSH
39002: LD_INT 30
39004: PUSH
39005: LD_INT 0
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 30
39014: PUSH
39015: LD_INT 1
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: LIST
39026: PPUSH
39027: CALL_OW 72
39031: ST_TO_ADDR
// if not tmp or not dep then
39032: LD_VAR 0 8
39036: NOT
39037: PUSH
39038: LD_VAR 0 9
39042: NOT
39043: OR
39044: IFFALSE 39048
// continue ;
39046: GO 38833
// side := GetSide ( tmp [ 1 ] ) ;
39048: LD_ADDR_VAR 0 11
39052: PUSH
39053: LD_VAR 0 8
39057: PUSH
39058: LD_INT 1
39060: ARRAY
39061: PPUSH
39062: CALL_OW 255
39066: ST_TO_ADDR
// dep := dep [ 1 ] ;
39067: LD_ADDR_VAR 0 9
39071: PUSH
39072: LD_VAR 0 9
39076: PUSH
39077: LD_INT 1
39079: ARRAY
39080: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39081: LD_ADDR_VAR 0 7
39085: PUSH
39086: LD_EXP 116
39090: PUSH
39091: LD_VAR 0 2
39095: ARRAY
39096: PPUSH
39097: LD_INT 22
39099: PUSH
39100: LD_INT 0
39102: PUSH
39103: EMPTY
39104: LIST
39105: LIST
39106: PUSH
39107: LD_INT 25
39109: PUSH
39110: LD_INT 12
39112: PUSH
39113: EMPTY
39114: LIST
39115: LIST
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PPUSH
39121: CALL_OW 70
39125: PUSH
39126: LD_INT 22
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 25
39138: PUSH
39139: LD_INT 12
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 91
39148: PUSH
39149: LD_VAR 0 9
39153: PUSH
39154: LD_INT 20
39156: PUSH
39157: EMPTY
39158: LIST
39159: LIST
39160: LIST
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: LIST
39166: PPUSH
39167: CALL_OW 69
39171: UNION
39172: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39173: LD_ADDR_VAR 0 10
39177: PUSH
39178: LD_EXP 116
39182: PUSH
39183: LD_VAR 0 2
39187: ARRAY
39188: PPUSH
39189: LD_INT 81
39191: PUSH
39192: LD_VAR 0 11
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PPUSH
39201: CALL_OW 70
39205: ST_TO_ADDR
// if not apes or danger_at_area then
39206: LD_VAR 0 7
39210: NOT
39211: PUSH
39212: LD_VAR 0 10
39216: OR
39217: IFFALSE 39267
// begin if mc_taming [ i ] then
39219: LD_EXP 119
39223: PUSH
39224: LD_VAR 0 2
39228: ARRAY
39229: IFFALSE 39265
// begin MC_Reset ( i , 121 ) ;
39231: LD_VAR 0 2
39235: PPUSH
39236: LD_INT 121
39238: PPUSH
39239: CALL 24718 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39243: LD_ADDR_EXP 119
39247: PUSH
39248: LD_EXP 119
39252: PPUSH
39253: LD_VAR 0 2
39257: PPUSH
39258: EMPTY
39259: PPUSH
39260: CALL_OW 1
39264: ST_TO_ADDR
// end ; continue ;
39265: GO 38833
// end ; for j in tmp do
39267: LD_ADDR_VAR 0 3
39271: PUSH
39272: LD_VAR 0 8
39276: PUSH
39277: FOR_IN
39278: IFFALSE 39614
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39280: LD_VAR 0 3
39284: PUSH
39285: LD_EXP 119
39289: PUSH
39290: LD_VAR 0 2
39294: ARRAY
39295: IN
39296: NOT
39297: PUSH
39298: LD_EXP 119
39302: PUSH
39303: LD_VAR 0 2
39307: ARRAY
39308: PUSH
39309: LD_INT 3
39311: LESS
39312: AND
39313: IFFALSE 39371
// begin SetTag ( j , 121 ) ;
39315: LD_VAR 0 3
39319: PPUSH
39320: LD_INT 121
39322: PPUSH
39323: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39327: LD_ADDR_EXP 119
39331: PUSH
39332: LD_EXP 119
39336: PPUSH
39337: LD_VAR 0 2
39341: PUSH
39342: LD_EXP 119
39346: PUSH
39347: LD_VAR 0 2
39351: ARRAY
39352: PUSH
39353: LD_INT 1
39355: PLUS
39356: PUSH
39357: EMPTY
39358: LIST
39359: LIST
39360: PPUSH
39361: LD_VAR 0 3
39365: PPUSH
39366: CALL 55609 0 3
39370: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39371: LD_VAR 0 3
39375: PUSH
39376: LD_EXP 119
39380: PUSH
39381: LD_VAR 0 2
39385: ARRAY
39386: IN
39387: IFFALSE 39612
// begin if GetClass ( j ) <> 4 then
39389: LD_VAR 0 3
39393: PPUSH
39394: CALL_OW 257
39398: PUSH
39399: LD_INT 4
39401: NONEQUAL
39402: IFFALSE 39455
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39404: LD_ADDR_EXP 119
39408: PUSH
39409: LD_EXP 119
39413: PPUSH
39414: LD_VAR 0 2
39418: PPUSH
39419: LD_EXP 119
39423: PUSH
39424: LD_VAR 0 2
39428: ARRAY
39429: PUSH
39430: LD_VAR 0 3
39434: DIFF
39435: PPUSH
39436: CALL_OW 1
39440: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39441: LD_VAR 0 3
39445: PPUSH
39446: LD_INT 0
39448: PPUSH
39449: CALL_OW 109
// continue ;
39453: GO 39277
// end ; if IsInUnit ( j ) then
39455: LD_VAR 0 3
39459: PPUSH
39460: CALL_OW 310
39464: IFFALSE 39475
// ComExitBuilding ( j ) ;
39466: LD_VAR 0 3
39470: PPUSH
39471: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39475: LD_ADDR_VAR 0 6
39479: PUSH
39480: LD_VAR 0 7
39484: PPUSH
39485: LD_VAR 0 3
39489: PPUSH
39490: CALL_OW 74
39494: ST_TO_ADDR
// if not ape then
39495: LD_VAR 0 6
39499: NOT
39500: IFFALSE 39504
// break ;
39502: GO 39614
// x := GetX ( ape ) ;
39504: LD_ADDR_VAR 0 4
39508: PUSH
39509: LD_VAR 0 6
39513: PPUSH
39514: CALL_OW 250
39518: ST_TO_ADDR
// y := GetY ( ape ) ;
39519: LD_ADDR_VAR 0 5
39523: PUSH
39524: LD_VAR 0 6
39528: PPUSH
39529: CALL_OW 251
39533: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39534: LD_VAR 0 4
39538: PPUSH
39539: LD_VAR 0 5
39543: PPUSH
39544: CALL_OW 488
39548: NOT
39549: PUSH
39550: LD_VAR 0 11
39554: PPUSH
39555: LD_VAR 0 4
39559: PPUSH
39560: LD_VAR 0 5
39564: PPUSH
39565: LD_INT 20
39567: PPUSH
39568: CALL 56505 0 4
39572: PUSH
39573: LD_INT 4
39575: ARRAY
39576: OR
39577: IFFALSE 39581
// break ;
39579: GO 39614
// if not HasTask ( j ) then
39581: LD_VAR 0 3
39585: PPUSH
39586: CALL_OW 314
39590: NOT
39591: IFFALSE 39612
// ComTameXY ( j , x , y ) ;
39593: LD_VAR 0 3
39597: PPUSH
39598: LD_VAR 0 4
39602: PPUSH
39603: LD_VAR 0 5
39607: PPUSH
39608: CALL_OW 131
// end ; end ;
39612: GO 39277
39614: POP
39615: POP
// end ;
39616: GO 38833
39618: POP
39619: POP
// end ;
39620: LD_VAR 0 1
39624: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39625: LD_INT 0
39627: PPUSH
39628: PPUSH
39629: PPUSH
39630: PPUSH
39631: PPUSH
39632: PPUSH
39633: PPUSH
39634: PPUSH
// if not mc_bases then
39635: LD_EXP 88
39639: NOT
39640: IFFALSE 39644
// exit ;
39642: GO 40270
// for i = 1 to mc_bases do
39644: LD_ADDR_VAR 0 2
39648: PUSH
39649: DOUBLE
39650: LD_INT 1
39652: DEC
39653: ST_TO_ADDR
39654: LD_EXP 88
39658: PUSH
39659: FOR_TO
39660: IFFALSE 40268
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39662: LD_EXP 117
39666: PUSH
39667: LD_VAR 0 2
39671: ARRAY
39672: NOT
39673: PUSH
39674: LD_EXP 117
39678: PUSH
39679: LD_VAR 0 2
39683: ARRAY
39684: PPUSH
39685: LD_INT 25
39687: PUSH
39688: LD_INT 12
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PPUSH
39695: CALL_OW 72
39699: NOT
39700: OR
39701: IFFALSE 39705
// continue ;
39703: GO 39659
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39705: LD_ADDR_VAR 0 5
39709: PUSH
39710: LD_EXP 117
39714: PUSH
39715: LD_VAR 0 2
39719: ARRAY
39720: PUSH
39721: LD_INT 1
39723: ARRAY
39724: PPUSH
39725: CALL_OW 255
39729: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39730: LD_VAR 0 5
39734: PPUSH
39735: LD_INT 2
39737: PPUSH
39738: CALL_OW 325
39742: IFFALSE 39995
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39744: LD_ADDR_VAR 0 4
39748: PUSH
39749: LD_EXP 117
39753: PUSH
39754: LD_VAR 0 2
39758: ARRAY
39759: PPUSH
39760: LD_INT 25
39762: PUSH
39763: LD_INT 16
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PPUSH
39770: CALL_OW 72
39774: ST_TO_ADDR
// if tmp < 6 then
39775: LD_VAR 0 4
39779: PUSH
39780: LD_INT 6
39782: LESS
39783: IFFALSE 39995
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39785: LD_ADDR_VAR 0 6
39789: PUSH
39790: LD_EXP 88
39794: PUSH
39795: LD_VAR 0 2
39799: ARRAY
39800: PPUSH
39801: LD_INT 2
39803: PUSH
39804: LD_INT 30
39806: PUSH
39807: LD_INT 0
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 30
39816: PUSH
39817: LD_INT 1
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: EMPTY
39825: LIST
39826: LIST
39827: LIST
39828: PPUSH
39829: CALL_OW 72
39833: ST_TO_ADDR
// if depot then
39834: LD_VAR 0 6
39838: IFFALSE 39995
// begin selected := 0 ;
39840: LD_ADDR_VAR 0 7
39844: PUSH
39845: LD_INT 0
39847: ST_TO_ADDR
// for j in depot do
39848: LD_ADDR_VAR 0 3
39852: PUSH
39853: LD_VAR 0 6
39857: PUSH
39858: FOR_IN
39859: IFFALSE 39890
// begin if UnitsInside ( j ) < 6 then
39861: LD_VAR 0 3
39865: PPUSH
39866: CALL_OW 313
39870: PUSH
39871: LD_INT 6
39873: LESS
39874: IFFALSE 39888
// begin selected := j ;
39876: LD_ADDR_VAR 0 7
39880: PUSH
39881: LD_VAR 0 3
39885: ST_TO_ADDR
// break ;
39886: GO 39890
// end ; end ;
39888: GO 39858
39890: POP
39891: POP
// if selected then
39892: LD_VAR 0 7
39896: IFFALSE 39995
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39898: LD_ADDR_VAR 0 3
39902: PUSH
39903: LD_EXP 117
39907: PUSH
39908: LD_VAR 0 2
39912: ARRAY
39913: PPUSH
39914: LD_INT 25
39916: PUSH
39917: LD_INT 12
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PPUSH
39924: CALL_OW 72
39928: PUSH
39929: FOR_IN
39930: IFFALSE 39993
// if not HasTask ( j ) then
39932: LD_VAR 0 3
39936: PPUSH
39937: CALL_OW 314
39941: NOT
39942: IFFALSE 39991
// begin if not IsInUnit ( j ) then
39944: LD_VAR 0 3
39948: PPUSH
39949: CALL_OW 310
39953: NOT
39954: IFFALSE 39970
// ComEnterUnit ( j , selected ) ;
39956: LD_VAR 0 3
39960: PPUSH
39961: LD_VAR 0 7
39965: PPUSH
39966: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39970: LD_VAR 0 3
39974: PPUSH
39975: LD_INT 16
39977: PPUSH
39978: CALL_OW 183
// AddComExitBuilding ( j ) ;
39982: LD_VAR 0 3
39986: PPUSH
39987: CALL_OW 182
// end ;
39991: GO 39929
39993: POP
39994: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39995: LD_VAR 0 5
39999: PPUSH
40000: LD_INT 11
40002: PPUSH
40003: CALL_OW 325
40007: IFFALSE 40266
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40009: LD_ADDR_VAR 0 4
40013: PUSH
40014: LD_EXP 117
40018: PUSH
40019: LD_VAR 0 2
40023: ARRAY
40024: PPUSH
40025: LD_INT 25
40027: PUSH
40028: LD_INT 16
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PPUSH
40035: CALL_OW 72
40039: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40040: LD_VAR 0 4
40044: PUSH
40045: LD_INT 6
40047: GREATEREQUAL
40048: PUSH
40049: LD_VAR 0 5
40053: PPUSH
40054: LD_INT 2
40056: PPUSH
40057: CALL_OW 325
40061: NOT
40062: OR
40063: IFFALSE 40266
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40065: LD_ADDR_VAR 0 8
40069: PUSH
40070: LD_EXP 88
40074: PUSH
40075: LD_VAR 0 2
40079: ARRAY
40080: PPUSH
40081: LD_INT 2
40083: PUSH
40084: LD_INT 30
40086: PUSH
40087: LD_INT 4
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 30
40096: PUSH
40097: LD_INT 5
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: LIST
40108: PPUSH
40109: CALL_OW 72
40113: ST_TO_ADDR
// if barracks then
40114: LD_VAR 0 8
40118: IFFALSE 40266
// begin selected := 0 ;
40120: LD_ADDR_VAR 0 7
40124: PUSH
40125: LD_INT 0
40127: ST_TO_ADDR
// for j in barracks do
40128: LD_ADDR_VAR 0 3
40132: PUSH
40133: LD_VAR 0 8
40137: PUSH
40138: FOR_IN
40139: IFFALSE 40170
// begin if UnitsInside ( j ) < 6 then
40141: LD_VAR 0 3
40145: PPUSH
40146: CALL_OW 313
40150: PUSH
40151: LD_INT 6
40153: LESS
40154: IFFALSE 40168
// begin selected := j ;
40156: LD_ADDR_VAR 0 7
40160: PUSH
40161: LD_VAR 0 3
40165: ST_TO_ADDR
// break ;
40166: GO 40170
// end ; end ;
40168: GO 40138
40170: POP
40171: POP
// if selected then
40172: LD_VAR 0 7
40176: IFFALSE 40266
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40178: LD_ADDR_VAR 0 3
40182: PUSH
40183: LD_EXP 117
40187: PUSH
40188: LD_VAR 0 2
40192: ARRAY
40193: PPUSH
40194: LD_INT 25
40196: PUSH
40197: LD_INT 12
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PPUSH
40204: CALL_OW 72
40208: PUSH
40209: FOR_IN
40210: IFFALSE 40264
// if not IsInUnit ( j ) and not HasTask ( j ) then
40212: LD_VAR 0 3
40216: PPUSH
40217: CALL_OW 310
40221: NOT
40222: PUSH
40223: LD_VAR 0 3
40227: PPUSH
40228: CALL_OW 314
40232: NOT
40233: AND
40234: IFFALSE 40262
// begin ComEnterUnit ( j , selected ) ;
40236: LD_VAR 0 3
40240: PPUSH
40241: LD_VAR 0 7
40245: PPUSH
40246: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40250: LD_VAR 0 3
40254: PPUSH
40255: LD_INT 15
40257: PPUSH
40258: CALL_OW 183
// end ;
40262: GO 40209
40264: POP
40265: POP
// end ; end ; end ; end ; end ;
40266: GO 39659
40268: POP
40269: POP
// end ;
40270: LD_VAR 0 1
40274: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40275: LD_INT 0
40277: PPUSH
40278: PPUSH
40279: PPUSH
40280: PPUSH
// if not mc_bases then
40281: LD_EXP 88
40285: NOT
40286: IFFALSE 40290
// exit ;
40288: GO 40468
// for i = 1 to mc_bases do
40290: LD_ADDR_VAR 0 2
40294: PUSH
40295: DOUBLE
40296: LD_INT 1
40298: DEC
40299: ST_TO_ADDR
40300: LD_EXP 88
40304: PUSH
40305: FOR_TO
40306: IFFALSE 40466
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40308: LD_ADDR_VAR 0 4
40312: PUSH
40313: LD_EXP 88
40317: PUSH
40318: LD_VAR 0 2
40322: ARRAY
40323: PPUSH
40324: LD_INT 25
40326: PUSH
40327: LD_INT 9
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PPUSH
40334: CALL_OW 72
40338: ST_TO_ADDR
// if not tmp then
40339: LD_VAR 0 4
40343: NOT
40344: IFFALSE 40348
// continue ;
40346: GO 40305
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40348: LD_EXP 114
40352: PUSH
40353: LD_VAR 0 2
40357: ARRAY
40358: PPUSH
40359: LD_INT 29
40361: PPUSH
40362: CALL_OW 325
40366: NOT
40367: PUSH
40368: LD_EXP 114
40372: PUSH
40373: LD_VAR 0 2
40377: ARRAY
40378: PPUSH
40379: LD_INT 28
40381: PPUSH
40382: CALL_OW 325
40386: NOT
40387: AND
40388: IFFALSE 40392
// continue ;
40390: GO 40305
// for j in tmp do
40392: LD_ADDR_VAR 0 3
40396: PUSH
40397: LD_VAR 0 4
40401: PUSH
40402: FOR_IN
40403: IFFALSE 40462
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40405: LD_VAR 0 3
40409: PUSH
40410: LD_EXP 91
40414: PUSH
40415: LD_VAR 0 2
40419: ARRAY
40420: PUSH
40421: LD_INT 1
40423: ARRAY
40424: IN
40425: NOT
40426: PUSH
40427: LD_VAR 0 3
40431: PUSH
40432: LD_EXP 91
40436: PUSH
40437: LD_VAR 0 2
40441: ARRAY
40442: PUSH
40443: LD_INT 2
40445: ARRAY
40446: IN
40447: NOT
40448: AND
40449: IFFALSE 40460
// ComSpaceTimeShoot ( j ) ;
40451: LD_VAR 0 3
40455: PPUSH
40456: CALL 51606 0 1
40460: GO 40402
40462: POP
40463: POP
// end ;
40464: GO 40305
40466: POP
40467: POP
// end ;
40468: LD_VAR 0 1
40472: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40473: LD_INT 0
40475: PPUSH
40476: PPUSH
40477: PPUSH
40478: PPUSH
40479: PPUSH
40480: PPUSH
40481: PPUSH
40482: PPUSH
40483: PPUSH
// if not mc_bases then
40484: LD_EXP 88
40488: NOT
40489: IFFALSE 40493
// exit ;
40491: GO 41115
// for i = 1 to mc_bases do
40493: LD_ADDR_VAR 0 2
40497: PUSH
40498: DOUBLE
40499: LD_INT 1
40501: DEC
40502: ST_TO_ADDR
40503: LD_EXP 88
40507: PUSH
40508: FOR_TO
40509: IFFALSE 41113
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40511: LD_EXP 123
40515: PUSH
40516: LD_VAR 0 2
40520: ARRAY
40521: NOT
40522: PUSH
40523: LD_INT 38
40525: PPUSH
40526: LD_EXP 114
40530: PUSH
40531: LD_VAR 0 2
40535: ARRAY
40536: PPUSH
40537: CALL_OW 321
40541: PUSH
40542: LD_INT 2
40544: NONEQUAL
40545: OR
40546: IFFALSE 40550
// continue ;
40548: GO 40508
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40550: LD_ADDR_VAR 0 8
40554: PUSH
40555: LD_EXP 88
40559: PUSH
40560: LD_VAR 0 2
40564: ARRAY
40565: PPUSH
40566: LD_INT 30
40568: PUSH
40569: LD_INT 34
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PPUSH
40576: CALL_OW 72
40580: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40581: LD_ADDR_VAR 0 9
40585: PUSH
40586: LD_EXP 88
40590: PUSH
40591: LD_VAR 0 2
40595: ARRAY
40596: PPUSH
40597: LD_INT 25
40599: PUSH
40600: LD_INT 4
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PPUSH
40607: CALL_OW 72
40611: PPUSH
40612: LD_INT 0
40614: PPUSH
40615: CALL 84170 0 2
40619: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40620: LD_VAR 0 9
40624: NOT
40625: PUSH
40626: LD_VAR 0 8
40630: NOT
40631: OR
40632: PUSH
40633: LD_EXP 88
40637: PUSH
40638: LD_VAR 0 2
40642: ARRAY
40643: PPUSH
40644: LD_INT 124
40646: PPUSH
40647: CALL 84170 0 2
40651: OR
40652: IFFALSE 40656
// continue ;
40654: GO 40508
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40656: LD_EXP 124
40660: PUSH
40661: LD_VAR 0 2
40665: ARRAY
40666: PUSH
40667: LD_EXP 123
40671: PUSH
40672: LD_VAR 0 2
40676: ARRAY
40677: LESS
40678: PUSH
40679: LD_EXP 124
40683: PUSH
40684: LD_VAR 0 2
40688: ARRAY
40689: PUSH
40690: LD_VAR 0 8
40694: LESS
40695: AND
40696: IFFALSE 41111
// begin tmp := sci [ 1 ] ;
40698: LD_ADDR_VAR 0 7
40702: PUSH
40703: LD_VAR 0 9
40707: PUSH
40708: LD_INT 1
40710: ARRAY
40711: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40712: LD_VAR 0 7
40716: PPUSH
40717: LD_INT 124
40719: PPUSH
40720: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40724: LD_ADDR_VAR 0 3
40728: PUSH
40729: DOUBLE
40730: LD_EXP 123
40734: PUSH
40735: LD_VAR 0 2
40739: ARRAY
40740: INC
40741: ST_TO_ADDR
40742: LD_EXP 123
40746: PUSH
40747: LD_VAR 0 2
40751: ARRAY
40752: PUSH
40753: FOR_DOWNTO
40754: IFFALSE 41097
// begin if IsInUnit ( tmp ) then
40756: LD_VAR 0 7
40760: PPUSH
40761: CALL_OW 310
40765: IFFALSE 40776
// ComExitBuilding ( tmp ) ;
40767: LD_VAR 0 7
40771: PPUSH
40772: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40776: LD_INT 35
40778: PPUSH
40779: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40783: LD_VAR 0 7
40787: PPUSH
40788: CALL_OW 310
40792: NOT
40793: PUSH
40794: LD_VAR 0 7
40798: PPUSH
40799: CALL_OW 314
40803: NOT
40804: AND
40805: IFFALSE 40776
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40807: LD_ADDR_VAR 0 6
40811: PUSH
40812: LD_VAR 0 7
40816: PPUSH
40817: CALL_OW 250
40821: PUSH
40822: LD_VAR 0 7
40826: PPUSH
40827: CALL_OW 251
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40836: LD_INT 35
40838: PPUSH
40839: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40843: LD_ADDR_VAR 0 4
40847: PUSH
40848: LD_EXP 123
40852: PUSH
40853: LD_VAR 0 2
40857: ARRAY
40858: PUSH
40859: LD_VAR 0 3
40863: ARRAY
40864: PUSH
40865: LD_INT 1
40867: ARRAY
40868: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40869: LD_ADDR_VAR 0 5
40873: PUSH
40874: LD_EXP 123
40878: PUSH
40879: LD_VAR 0 2
40883: ARRAY
40884: PUSH
40885: LD_VAR 0 3
40889: ARRAY
40890: PUSH
40891: LD_INT 2
40893: ARRAY
40894: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40895: LD_VAR 0 7
40899: PPUSH
40900: LD_INT 10
40902: PPUSH
40903: CALL 58202 0 2
40907: PUSH
40908: LD_INT 4
40910: ARRAY
40911: IFFALSE 40949
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40913: LD_VAR 0 7
40917: PPUSH
40918: LD_VAR 0 6
40922: PUSH
40923: LD_INT 1
40925: ARRAY
40926: PPUSH
40927: LD_VAR 0 6
40931: PUSH
40932: LD_INT 2
40934: ARRAY
40935: PPUSH
40936: CALL_OW 111
// wait ( 0 0$10 ) ;
40940: LD_INT 350
40942: PPUSH
40943: CALL_OW 67
// end else
40947: GO 40975
// begin ComMoveXY ( tmp , x , y ) ;
40949: LD_VAR 0 7
40953: PPUSH
40954: LD_VAR 0 4
40958: PPUSH
40959: LD_VAR 0 5
40963: PPUSH
40964: CALL_OW 111
// wait ( 0 0$3 ) ;
40968: LD_INT 105
40970: PPUSH
40971: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40975: LD_VAR 0 7
40979: PPUSH
40980: LD_VAR 0 4
40984: PPUSH
40985: LD_VAR 0 5
40989: PPUSH
40990: CALL_OW 307
40994: IFFALSE 40836
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40996: LD_VAR 0 7
41000: PPUSH
41001: LD_VAR 0 4
41005: PPUSH
41006: LD_VAR 0 5
41010: PPUSH
41011: LD_VAR 0 8
41015: PUSH
41016: LD_VAR 0 3
41020: ARRAY
41021: PPUSH
41022: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41026: LD_INT 35
41028: PPUSH
41029: CALL_OW 67
// until not HasTask ( tmp ) ;
41033: LD_VAR 0 7
41037: PPUSH
41038: CALL_OW 314
41042: NOT
41043: IFFALSE 41026
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41045: LD_ADDR_EXP 124
41049: PUSH
41050: LD_EXP 124
41054: PPUSH
41055: LD_VAR 0 2
41059: PUSH
41060: LD_EXP 124
41064: PUSH
41065: LD_VAR 0 2
41069: ARRAY
41070: PUSH
41071: LD_INT 1
41073: PLUS
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: PPUSH
41079: LD_VAR 0 8
41083: PUSH
41084: LD_VAR 0 3
41088: ARRAY
41089: PPUSH
41090: CALL 55609 0 3
41094: ST_TO_ADDR
// end ;
41095: GO 40753
41097: POP
41098: POP
// MC_Reset ( i , 124 ) ;
41099: LD_VAR 0 2
41103: PPUSH
41104: LD_INT 124
41106: PPUSH
41107: CALL 24718 0 2
// end ; end ;
41111: GO 40508
41113: POP
41114: POP
// end ;
41115: LD_VAR 0 1
41119: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41120: LD_INT 0
41122: PPUSH
41123: PPUSH
41124: PPUSH
// if not mc_bases then
41125: LD_EXP 88
41129: NOT
41130: IFFALSE 41134
// exit ;
41132: GO 41740
// for i = 1 to mc_bases do
41134: LD_ADDR_VAR 0 2
41138: PUSH
41139: DOUBLE
41140: LD_INT 1
41142: DEC
41143: ST_TO_ADDR
41144: LD_EXP 88
41148: PUSH
41149: FOR_TO
41150: IFFALSE 41738
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41152: LD_ADDR_VAR 0 3
41156: PUSH
41157: LD_EXP 88
41161: PUSH
41162: LD_VAR 0 2
41166: ARRAY
41167: PPUSH
41168: LD_INT 25
41170: PUSH
41171: LD_INT 4
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: PPUSH
41178: CALL_OW 72
41182: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41183: LD_VAR 0 3
41187: NOT
41188: PUSH
41189: LD_EXP 125
41193: PUSH
41194: LD_VAR 0 2
41198: ARRAY
41199: NOT
41200: OR
41201: PUSH
41202: LD_EXP 88
41206: PUSH
41207: LD_VAR 0 2
41211: ARRAY
41212: PPUSH
41213: LD_INT 2
41215: PUSH
41216: LD_INT 30
41218: PUSH
41219: LD_INT 0
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: PUSH
41226: LD_INT 30
41228: PUSH
41229: LD_INT 1
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: LIST
41240: PPUSH
41241: CALL_OW 72
41245: NOT
41246: OR
41247: IFFALSE 41297
// begin if mc_deposits_finder [ i ] then
41249: LD_EXP 126
41253: PUSH
41254: LD_VAR 0 2
41258: ARRAY
41259: IFFALSE 41295
// begin MC_Reset ( i , 125 ) ;
41261: LD_VAR 0 2
41265: PPUSH
41266: LD_INT 125
41268: PPUSH
41269: CALL 24718 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41273: LD_ADDR_EXP 126
41277: PUSH
41278: LD_EXP 126
41282: PPUSH
41283: LD_VAR 0 2
41287: PPUSH
41288: EMPTY
41289: PPUSH
41290: CALL_OW 1
41294: ST_TO_ADDR
// end ; continue ;
41295: GO 41149
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41297: LD_EXP 125
41301: PUSH
41302: LD_VAR 0 2
41306: ARRAY
41307: PUSH
41308: LD_INT 1
41310: ARRAY
41311: PUSH
41312: LD_INT 3
41314: ARRAY
41315: PUSH
41316: LD_INT 1
41318: EQUAL
41319: PUSH
41320: LD_INT 20
41322: PPUSH
41323: LD_EXP 114
41327: PUSH
41328: LD_VAR 0 2
41332: ARRAY
41333: PPUSH
41334: CALL_OW 321
41338: PUSH
41339: LD_INT 2
41341: NONEQUAL
41342: AND
41343: IFFALSE 41393
// begin if mc_deposits_finder [ i ] then
41345: LD_EXP 126
41349: PUSH
41350: LD_VAR 0 2
41354: ARRAY
41355: IFFALSE 41391
// begin MC_Reset ( i , 125 ) ;
41357: LD_VAR 0 2
41361: PPUSH
41362: LD_INT 125
41364: PPUSH
41365: CALL 24718 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41369: LD_ADDR_EXP 126
41373: PUSH
41374: LD_EXP 126
41378: PPUSH
41379: LD_VAR 0 2
41383: PPUSH
41384: EMPTY
41385: PPUSH
41386: CALL_OW 1
41390: ST_TO_ADDR
// end ; continue ;
41391: GO 41149
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41393: LD_EXP 125
41397: PUSH
41398: LD_VAR 0 2
41402: ARRAY
41403: PUSH
41404: LD_INT 1
41406: ARRAY
41407: PUSH
41408: LD_INT 1
41410: ARRAY
41411: PPUSH
41412: LD_EXP 125
41416: PUSH
41417: LD_VAR 0 2
41421: ARRAY
41422: PUSH
41423: LD_INT 1
41425: ARRAY
41426: PUSH
41427: LD_INT 2
41429: ARRAY
41430: PPUSH
41431: LD_EXP 114
41435: PUSH
41436: LD_VAR 0 2
41440: ARRAY
41441: PPUSH
41442: CALL_OW 440
41446: IFFALSE 41489
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41448: LD_ADDR_EXP 125
41452: PUSH
41453: LD_EXP 125
41457: PPUSH
41458: LD_VAR 0 2
41462: PPUSH
41463: LD_EXP 125
41467: PUSH
41468: LD_VAR 0 2
41472: ARRAY
41473: PPUSH
41474: LD_INT 1
41476: PPUSH
41477: CALL_OW 3
41481: PPUSH
41482: CALL_OW 1
41486: ST_TO_ADDR
41487: GO 41736
// begin if not mc_deposits_finder [ i ] then
41489: LD_EXP 126
41493: PUSH
41494: LD_VAR 0 2
41498: ARRAY
41499: NOT
41500: IFFALSE 41552
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41502: LD_ADDR_EXP 126
41506: PUSH
41507: LD_EXP 126
41511: PPUSH
41512: LD_VAR 0 2
41516: PPUSH
41517: LD_VAR 0 3
41521: PUSH
41522: LD_INT 1
41524: ARRAY
41525: PUSH
41526: EMPTY
41527: LIST
41528: PPUSH
41529: CALL_OW 1
41533: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41534: LD_VAR 0 3
41538: PUSH
41539: LD_INT 1
41541: ARRAY
41542: PPUSH
41543: LD_INT 125
41545: PPUSH
41546: CALL_OW 109
// end else
41550: GO 41736
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41552: LD_EXP 126
41556: PUSH
41557: LD_VAR 0 2
41561: ARRAY
41562: PUSH
41563: LD_INT 1
41565: ARRAY
41566: PPUSH
41567: CALL_OW 310
41571: IFFALSE 41594
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41573: LD_EXP 126
41577: PUSH
41578: LD_VAR 0 2
41582: ARRAY
41583: PUSH
41584: LD_INT 1
41586: ARRAY
41587: PPUSH
41588: CALL_OW 122
41592: GO 41736
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41594: LD_EXP 126
41598: PUSH
41599: LD_VAR 0 2
41603: ARRAY
41604: PUSH
41605: LD_INT 1
41607: ARRAY
41608: PPUSH
41609: CALL_OW 314
41613: NOT
41614: PUSH
41615: LD_EXP 126
41619: PUSH
41620: LD_VAR 0 2
41624: ARRAY
41625: PUSH
41626: LD_INT 1
41628: ARRAY
41629: PPUSH
41630: LD_EXP 125
41634: PUSH
41635: LD_VAR 0 2
41639: ARRAY
41640: PUSH
41641: LD_INT 1
41643: ARRAY
41644: PUSH
41645: LD_INT 1
41647: ARRAY
41648: PPUSH
41649: LD_EXP 125
41653: PUSH
41654: LD_VAR 0 2
41658: ARRAY
41659: PUSH
41660: LD_INT 1
41662: ARRAY
41663: PUSH
41664: LD_INT 2
41666: ARRAY
41667: PPUSH
41668: CALL_OW 297
41672: PUSH
41673: LD_INT 6
41675: GREATER
41676: AND
41677: IFFALSE 41736
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41679: LD_EXP 126
41683: PUSH
41684: LD_VAR 0 2
41688: ARRAY
41689: PUSH
41690: LD_INT 1
41692: ARRAY
41693: PPUSH
41694: LD_EXP 125
41698: PUSH
41699: LD_VAR 0 2
41703: ARRAY
41704: PUSH
41705: LD_INT 1
41707: ARRAY
41708: PUSH
41709: LD_INT 1
41711: ARRAY
41712: PPUSH
41713: LD_EXP 125
41717: PUSH
41718: LD_VAR 0 2
41722: ARRAY
41723: PUSH
41724: LD_INT 1
41726: ARRAY
41727: PUSH
41728: LD_INT 2
41730: ARRAY
41731: PPUSH
41732: CALL_OW 111
// end ; end ; end ;
41736: GO 41149
41738: POP
41739: POP
// end ;
41740: LD_VAR 0 1
41744: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41745: LD_INT 0
41747: PPUSH
41748: PPUSH
41749: PPUSH
41750: PPUSH
41751: PPUSH
41752: PPUSH
41753: PPUSH
41754: PPUSH
41755: PPUSH
41756: PPUSH
41757: PPUSH
// if not mc_bases then
41758: LD_EXP 88
41762: NOT
41763: IFFALSE 41767
// exit ;
41765: GO 42707
// for i = 1 to mc_bases do
41767: LD_ADDR_VAR 0 2
41771: PUSH
41772: DOUBLE
41773: LD_INT 1
41775: DEC
41776: ST_TO_ADDR
41777: LD_EXP 88
41781: PUSH
41782: FOR_TO
41783: IFFALSE 42705
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41785: LD_EXP 88
41789: PUSH
41790: LD_VAR 0 2
41794: ARRAY
41795: NOT
41796: PUSH
41797: LD_EXP 111
41801: PUSH
41802: LD_VAR 0 2
41806: ARRAY
41807: OR
41808: IFFALSE 41812
// continue ;
41810: GO 41782
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41812: LD_ADDR_VAR 0 7
41816: PUSH
41817: LD_EXP 88
41821: PUSH
41822: LD_VAR 0 2
41826: ARRAY
41827: PUSH
41828: LD_INT 1
41830: ARRAY
41831: PPUSH
41832: CALL_OW 248
41836: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41837: LD_VAR 0 7
41841: PUSH
41842: LD_INT 3
41844: EQUAL
41845: PUSH
41846: LD_EXP 107
41850: PUSH
41851: LD_VAR 0 2
41855: ARRAY
41856: PUSH
41857: LD_EXP 110
41861: PUSH
41862: LD_VAR 0 2
41866: ARRAY
41867: UNION
41868: PPUSH
41869: LD_INT 33
41871: PUSH
41872: LD_INT 2
41874: PUSH
41875: EMPTY
41876: LIST
41877: LIST
41878: PPUSH
41879: CALL_OW 72
41883: NOT
41884: OR
41885: IFFALSE 41889
// continue ;
41887: GO 41782
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41889: LD_ADDR_VAR 0 9
41893: PUSH
41894: LD_EXP 88
41898: PUSH
41899: LD_VAR 0 2
41903: ARRAY
41904: PPUSH
41905: LD_INT 30
41907: PUSH
41908: LD_INT 36
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PPUSH
41915: CALL_OW 72
41919: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41920: LD_ADDR_VAR 0 10
41924: PUSH
41925: LD_EXP 107
41929: PUSH
41930: LD_VAR 0 2
41934: ARRAY
41935: PPUSH
41936: LD_INT 34
41938: PUSH
41939: LD_INT 31
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PPUSH
41946: CALL_OW 72
41950: ST_TO_ADDR
// if not cts and not mcts then
41951: LD_VAR 0 9
41955: NOT
41956: PUSH
41957: LD_VAR 0 10
41961: NOT
41962: AND
41963: IFFALSE 41967
// continue ;
41965: GO 41782
// x := cts ;
41967: LD_ADDR_VAR 0 11
41971: PUSH
41972: LD_VAR 0 9
41976: ST_TO_ADDR
// if not x then
41977: LD_VAR 0 11
41981: NOT
41982: IFFALSE 41994
// x := mcts ;
41984: LD_ADDR_VAR 0 11
41988: PUSH
41989: LD_VAR 0 10
41993: ST_TO_ADDR
// if not x then
41994: LD_VAR 0 11
41998: NOT
41999: IFFALSE 42003
// continue ;
42001: GO 41782
// if mc_remote_driver [ i ] then
42003: LD_EXP 128
42007: PUSH
42008: LD_VAR 0 2
42012: ARRAY
42013: IFFALSE 42400
// for j in mc_remote_driver [ i ] do
42015: LD_ADDR_VAR 0 3
42019: PUSH
42020: LD_EXP 128
42024: PUSH
42025: LD_VAR 0 2
42029: ARRAY
42030: PUSH
42031: FOR_IN
42032: IFFALSE 42398
// begin if GetClass ( j ) <> 3 then
42034: LD_VAR 0 3
42038: PPUSH
42039: CALL_OW 257
42043: PUSH
42044: LD_INT 3
42046: NONEQUAL
42047: IFFALSE 42100
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42049: LD_ADDR_EXP 128
42053: PUSH
42054: LD_EXP 128
42058: PPUSH
42059: LD_VAR 0 2
42063: PPUSH
42064: LD_EXP 128
42068: PUSH
42069: LD_VAR 0 2
42073: ARRAY
42074: PUSH
42075: LD_VAR 0 3
42079: DIFF
42080: PPUSH
42081: CALL_OW 1
42085: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42086: LD_VAR 0 3
42090: PPUSH
42091: LD_INT 0
42093: PPUSH
42094: CALL_OW 109
// continue ;
42098: GO 42031
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42100: LD_EXP 107
42104: PUSH
42105: LD_VAR 0 2
42109: ARRAY
42110: PPUSH
42111: LD_INT 34
42113: PUSH
42114: LD_INT 31
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 58
42123: PUSH
42124: EMPTY
42125: LIST
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PPUSH
42131: CALL_OW 72
42135: PUSH
42136: LD_VAR 0 3
42140: PPUSH
42141: CALL 84258 0 1
42145: NOT
42146: AND
42147: IFFALSE 42218
// begin if IsInUnit ( j ) then
42149: LD_VAR 0 3
42153: PPUSH
42154: CALL_OW 310
42158: IFFALSE 42169
// ComExitBuilding ( j ) ;
42160: LD_VAR 0 3
42164: PPUSH
42165: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42169: LD_VAR 0 3
42173: PPUSH
42174: LD_EXP 107
42178: PUSH
42179: LD_VAR 0 2
42183: ARRAY
42184: PPUSH
42185: LD_INT 34
42187: PUSH
42188: LD_INT 31
42190: PUSH
42191: EMPTY
42192: LIST
42193: LIST
42194: PUSH
42195: LD_INT 58
42197: PUSH
42198: EMPTY
42199: LIST
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PPUSH
42205: CALL_OW 72
42209: PUSH
42210: LD_INT 1
42212: ARRAY
42213: PPUSH
42214: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42218: LD_VAR 0 3
42222: PPUSH
42223: CALL_OW 310
42227: NOT
42228: PUSH
42229: LD_VAR 0 3
42233: PPUSH
42234: CALL_OW 310
42238: PPUSH
42239: CALL_OW 266
42243: PUSH
42244: LD_INT 36
42246: NONEQUAL
42247: PUSH
42248: LD_VAR 0 3
42252: PPUSH
42253: CALL 84258 0 1
42257: NOT
42258: AND
42259: OR
42260: IFFALSE 42396
// begin if IsInUnit ( j ) then
42262: LD_VAR 0 3
42266: PPUSH
42267: CALL_OW 310
42271: IFFALSE 42282
// ComExitBuilding ( j ) ;
42273: LD_VAR 0 3
42277: PPUSH
42278: CALL_OW 122
// ct := 0 ;
42282: LD_ADDR_VAR 0 8
42286: PUSH
42287: LD_INT 0
42289: ST_TO_ADDR
// for k in x do
42290: LD_ADDR_VAR 0 4
42294: PUSH
42295: LD_VAR 0 11
42299: PUSH
42300: FOR_IN
42301: IFFALSE 42374
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42303: LD_VAR 0 4
42307: PPUSH
42308: CALL_OW 264
42312: PUSH
42313: LD_INT 31
42315: EQUAL
42316: PUSH
42317: LD_VAR 0 4
42321: PPUSH
42322: CALL_OW 311
42326: NOT
42327: AND
42328: PUSH
42329: LD_VAR 0 4
42333: PPUSH
42334: CALL_OW 266
42338: PUSH
42339: LD_INT 36
42341: EQUAL
42342: PUSH
42343: LD_VAR 0 4
42347: PPUSH
42348: CALL_OW 313
42352: PUSH
42353: LD_INT 3
42355: LESS
42356: AND
42357: OR
42358: IFFALSE 42372
// begin ct := k ;
42360: LD_ADDR_VAR 0 8
42364: PUSH
42365: LD_VAR 0 4
42369: ST_TO_ADDR
// break ;
42370: GO 42374
// end ;
42372: GO 42300
42374: POP
42375: POP
// if ct then
42376: LD_VAR 0 8
42380: IFFALSE 42396
// ComEnterUnit ( j , ct ) ;
42382: LD_VAR 0 3
42386: PPUSH
42387: LD_VAR 0 8
42391: PPUSH
42392: CALL_OW 120
// end ; end ;
42396: GO 42031
42398: POP
42399: POP
// places := 0 ;
42400: LD_ADDR_VAR 0 5
42404: PUSH
42405: LD_INT 0
42407: ST_TO_ADDR
// for j = 1 to x do
42408: LD_ADDR_VAR 0 3
42412: PUSH
42413: DOUBLE
42414: LD_INT 1
42416: DEC
42417: ST_TO_ADDR
42418: LD_VAR 0 11
42422: PUSH
42423: FOR_TO
42424: IFFALSE 42500
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42426: LD_VAR 0 11
42430: PUSH
42431: LD_VAR 0 3
42435: ARRAY
42436: PPUSH
42437: CALL_OW 264
42441: PUSH
42442: LD_INT 31
42444: EQUAL
42445: IFFALSE 42463
// places := places + 1 else
42447: LD_ADDR_VAR 0 5
42451: PUSH
42452: LD_VAR 0 5
42456: PUSH
42457: LD_INT 1
42459: PLUS
42460: ST_TO_ADDR
42461: GO 42498
// if GetBType ( x [ j ] ) = b_control_tower then
42463: LD_VAR 0 11
42467: PUSH
42468: LD_VAR 0 3
42472: ARRAY
42473: PPUSH
42474: CALL_OW 266
42478: PUSH
42479: LD_INT 36
42481: EQUAL
42482: IFFALSE 42498
// places := places + 3 ;
42484: LD_ADDR_VAR 0 5
42488: PUSH
42489: LD_VAR 0 5
42493: PUSH
42494: LD_INT 3
42496: PLUS
42497: ST_TO_ADDR
42498: GO 42423
42500: POP
42501: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42502: LD_VAR 0 5
42506: PUSH
42507: LD_INT 0
42509: EQUAL
42510: PUSH
42511: LD_VAR 0 5
42515: PUSH
42516: LD_EXP 128
42520: PUSH
42521: LD_VAR 0 2
42525: ARRAY
42526: LESSEQUAL
42527: OR
42528: IFFALSE 42532
// continue ;
42530: GO 41782
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42532: LD_ADDR_VAR 0 6
42536: PUSH
42537: LD_EXP 88
42541: PUSH
42542: LD_VAR 0 2
42546: ARRAY
42547: PPUSH
42548: LD_INT 25
42550: PUSH
42551: LD_INT 3
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PPUSH
42558: CALL_OW 72
42562: PUSH
42563: LD_EXP 128
42567: PUSH
42568: LD_VAR 0 2
42572: ARRAY
42573: DIFF
42574: PPUSH
42575: LD_INT 3
42577: PPUSH
42578: CALL 85158 0 2
42582: ST_TO_ADDR
// for j in tmp do
42583: LD_ADDR_VAR 0 3
42587: PUSH
42588: LD_VAR 0 6
42592: PUSH
42593: FOR_IN
42594: IFFALSE 42629
// if GetTag ( j ) > 0 then
42596: LD_VAR 0 3
42600: PPUSH
42601: CALL_OW 110
42605: PUSH
42606: LD_INT 0
42608: GREATER
42609: IFFALSE 42627
// tmp := tmp diff j ;
42611: LD_ADDR_VAR 0 6
42615: PUSH
42616: LD_VAR 0 6
42620: PUSH
42621: LD_VAR 0 3
42625: DIFF
42626: ST_TO_ADDR
42627: GO 42593
42629: POP
42630: POP
// if not tmp then
42631: LD_VAR 0 6
42635: NOT
42636: IFFALSE 42640
// continue ;
42638: GO 41782
// if places then
42640: LD_VAR 0 5
42644: IFFALSE 42703
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42646: LD_ADDR_EXP 128
42650: PUSH
42651: LD_EXP 128
42655: PPUSH
42656: LD_VAR 0 2
42660: PPUSH
42661: LD_EXP 128
42665: PUSH
42666: LD_VAR 0 2
42670: ARRAY
42671: PUSH
42672: LD_VAR 0 6
42676: PUSH
42677: LD_INT 1
42679: ARRAY
42680: UNION
42681: PPUSH
42682: CALL_OW 1
42686: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42687: LD_VAR 0 6
42691: PUSH
42692: LD_INT 1
42694: ARRAY
42695: PPUSH
42696: LD_INT 126
42698: PPUSH
42699: CALL_OW 109
// end ; end ;
42703: GO 41782
42705: POP
42706: POP
// end ;
42707: LD_VAR 0 1
42711: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42712: LD_INT 0
42714: PPUSH
42715: PPUSH
42716: PPUSH
42717: PPUSH
42718: PPUSH
42719: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42720: LD_VAR 0 1
42724: NOT
42725: PUSH
42726: LD_VAR 0 2
42730: NOT
42731: OR
42732: PUSH
42733: LD_VAR 0 3
42737: NOT
42738: OR
42739: PUSH
42740: LD_VAR 0 4
42744: PUSH
42745: LD_INT 1
42747: PUSH
42748: LD_INT 2
42750: PUSH
42751: LD_INT 3
42753: PUSH
42754: LD_INT 4
42756: PUSH
42757: LD_INT 5
42759: PUSH
42760: LD_INT 8
42762: PUSH
42763: LD_INT 9
42765: PUSH
42766: LD_INT 15
42768: PUSH
42769: LD_INT 16
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: LIST
42782: IN
42783: NOT
42784: OR
42785: IFFALSE 42789
// exit ;
42787: GO 43689
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42789: LD_ADDR_VAR 0 2
42793: PUSH
42794: LD_VAR 0 2
42798: PPUSH
42799: LD_INT 21
42801: PUSH
42802: LD_INT 3
42804: PUSH
42805: EMPTY
42806: LIST
42807: LIST
42808: PUSH
42809: LD_INT 24
42811: PUSH
42812: LD_INT 250
42814: PUSH
42815: EMPTY
42816: LIST
42817: LIST
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PPUSH
42823: CALL_OW 72
42827: ST_TO_ADDR
// case class of 1 , 15 :
42828: LD_VAR 0 4
42832: PUSH
42833: LD_INT 1
42835: DOUBLE
42836: EQUAL
42837: IFTRUE 42847
42839: LD_INT 15
42841: DOUBLE
42842: EQUAL
42843: IFTRUE 42847
42845: GO 42932
42847: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42848: LD_ADDR_VAR 0 8
42852: PUSH
42853: LD_VAR 0 2
42857: PPUSH
42858: LD_INT 2
42860: PUSH
42861: LD_INT 30
42863: PUSH
42864: LD_INT 32
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: PUSH
42871: LD_INT 30
42873: PUSH
42874: LD_INT 31
42876: PUSH
42877: EMPTY
42878: LIST
42879: LIST
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: LIST
42885: PPUSH
42886: CALL_OW 72
42890: PUSH
42891: LD_VAR 0 2
42895: PPUSH
42896: LD_INT 2
42898: PUSH
42899: LD_INT 30
42901: PUSH
42902: LD_INT 4
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 30
42911: PUSH
42912: LD_INT 5
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: LIST
42923: PPUSH
42924: CALL_OW 72
42928: ADD
42929: ST_TO_ADDR
42930: GO 43178
42932: LD_INT 2
42934: DOUBLE
42935: EQUAL
42936: IFTRUE 42946
42938: LD_INT 16
42940: DOUBLE
42941: EQUAL
42942: IFTRUE 42946
42944: GO 42992
42946: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42947: LD_ADDR_VAR 0 8
42951: PUSH
42952: LD_VAR 0 2
42956: PPUSH
42957: LD_INT 2
42959: PUSH
42960: LD_INT 30
42962: PUSH
42963: LD_INT 0
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: PUSH
42970: LD_INT 30
42972: PUSH
42973: LD_INT 1
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: LIST
42984: PPUSH
42985: CALL_OW 72
42989: ST_TO_ADDR
42990: GO 43178
42992: LD_INT 3
42994: DOUBLE
42995: EQUAL
42996: IFTRUE 43000
42998: GO 43046
43000: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43001: LD_ADDR_VAR 0 8
43005: PUSH
43006: LD_VAR 0 2
43010: PPUSH
43011: LD_INT 2
43013: PUSH
43014: LD_INT 30
43016: PUSH
43017: LD_INT 2
43019: PUSH
43020: EMPTY
43021: LIST
43022: LIST
43023: PUSH
43024: LD_INT 30
43026: PUSH
43027: LD_INT 3
43029: PUSH
43030: EMPTY
43031: LIST
43032: LIST
43033: PUSH
43034: EMPTY
43035: LIST
43036: LIST
43037: LIST
43038: PPUSH
43039: CALL_OW 72
43043: ST_TO_ADDR
43044: GO 43178
43046: LD_INT 4
43048: DOUBLE
43049: EQUAL
43050: IFTRUE 43054
43052: GO 43111
43054: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43055: LD_ADDR_VAR 0 8
43059: PUSH
43060: LD_VAR 0 2
43064: PPUSH
43065: LD_INT 2
43067: PUSH
43068: LD_INT 30
43070: PUSH
43071: LD_INT 6
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: PUSH
43078: LD_INT 30
43080: PUSH
43081: LD_INT 7
43083: PUSH
43084: EMPTY
43085: LIST
43086: LIST
43087: PUSH
43088: LD_INT 30
43090: PUSH
43091: LD_INT 8
43093: PUSH
43094: EMPTY
43095: LIST
43096: LIST
43097: PUSH
43098: EMPTY
43099: LIST
43100: LIST
43101: LIST
43102: LIST
43103: PPUSH
43104: CALL_OW 72
43108: ST_TO_ADDR
43109: GO 43178
43111: LD_INT 5
43113: DOUBLE
43114: EQUAL
43115: IFTRUE 43131
43117: LD_INT 8
43119: DOUBLE
43120: EQUAL
43121: IFTRUE 43131
43123: LD_INT 9
43125: DOUBLE
43126: EQUAL
43127: IFTRUE 43131
43129: GO 43177
43131: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43132: LD_ADDR_VAR 0 8
43136: PUSH
43137: LD_VAR 0 2
43141: PPUSH
43142: LD_INT 2
43144: PUSH
43145: LD_INT 30
43147: PUSH
43148: LD_INT 4
43150: PUSH
43151: EMPTY
43152: LIST
43153: LIST
43154: PUSH
43155: LD_INT 30
43157: PUSH
43158: LD_INT 5
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: EMPTY
43166: LIST
43167: LIST
43168: LIST
43169: PPUSH
43170: CALL_OW 72
43174: ST_TO_ADDR
43175: GO 43178
43177: POP
// if not tmp then
43178: LD_VAR 0 8
43182: NOT
43183: IFFALSE 43187
// exit ;
43185: GO 43689
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43187: LD_VAR 0 4
43191: PUSH
43192: LD_INT 1
43194: PUSH
43195: LD_INT 15
43197: PUSH
43198: EMPTY
43199: LIST
43200: LIST
43201: IN
43202: PUSH
43203: LD_EXP 97
43207: PUSH
43208: LD_VAR 0 1
43212: ARRAY
43213: AND
43214: IFFALSE 43370
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43216: LD_ADDR_VAR 0 9
43220: PUSH
43221: LD_EXP 97
43225: PUSH
43226: LD_VAR 0 1
43230: ARRAY
43231: PUSH
43232: LD_INT 1
43234: ARRAY
43235: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43236: LD_VAR 0 9
43240: PUSH
43241: LD_EXP 98
43245: PUSH
43246: LD_VAR 0 1
43250: ARRAY
43251: IN
43252: NOT
43253: IFFALSE 43368
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43255: LD_ADDR_EXP 98
43259: PUSH
43260: LD_EXP 98
43264: PPUSH
43265: LD_VAR 0 1
43269: PUSH
43270: LD_EXP 98
43274: PUSH
43275: LD_VAR 0 1
43279: ARRAY
43280: PUSH
43281: LD_INT 1
43283: PLUS
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PPUSH
43289: LD_VAR 0 9
43293: PPUSH
43294: CALL 55609 0 3
43298: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43299: LD_ADDR_EXP 97
43303: PUSH
43304: LD_EXP 97
43308: PPUSH
43309: LD_VAR 0 1
43313: PPUSH
43314: LD_EXP 97
43318: PUSH
43319: LD_VAR 0 1
43323: ARRAY
43324: PUSH
43325: LD_VAR 0 9
43329: DIFF
43330: PPUSH
43331: CALL_OW 1
43335: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43336: LD_VAR 0 3
43340: PPUSH
43341: LD_EXP 98
43345: PUSH
43346: LD_VAR 0 1
43350: ARRAY
43351: PUSH
43352: LD_EXP 98
43356: PUSH
43357: LD_VAR 0 1
43361: ARRAY
43362: ARRAY
43363: PPUSH
43364: CALL_OW 120
// end ; exit ;
43368: GO 43689
// end ; if tmp > 1 then
43370: LD_VAR 0 8
43374: PUSH
43375: LD_INT 1
43377: GREATER
43378: IFFALSE 43482
// for i = 2 to tmp do
43380: LD_ADDR_VAR 0 6
43384: PUSH
43385: DOUBLE
43386: LD_INT 2
43388: DEC
43389: ST_TO_ADDR
43390: LD_VAR 0 8
43394: PUSH
43395: FOR_TO
43396: IFFALSE 43480
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43398: LD_VAR 0 8
43402: PUSH
43403: LD_VAR 0 6
43407: ARRAY
43408: PPUSH
43409: CALL_OW 461
43413: PUSH
43414: LD_INT 6
43416: EQUAL
43417: IFFALSE 43478
// begin x := tmp [ i ] ;
43419: LD_ADDR_VAR 0 9
43423: PUSH
43424: LD_VAR 0 8
43428: PUSH
43429: LD_VAR 0 6
43433: ARRAY
43434: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43435: LD_ADDR_VAR 0 8
43439: PUSH
43440: LD_VAR 0 8
43444: PPUSH
43445: LD_VAR 0 6
43449: PPUSH
43450: CALL_OW 3
43454: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43455: LD_ADDR_VAR 0 8
43459: PUSH
43460: LD_VAR 0 8
43464: PPUSH
43465: LD_INT 1
43467: PPUSH
43468: LD_VAR 0 9
43472: PPUSH
43473: CALL_OW 2
43477: ST_TO_ADDR
// end ;
43478: GO 43395
43480: POP
43481: POP
// for i in tmp do
43482: LD_ADDR_VAR 0 6
43486: PUSH
43487: LD_VAR 0 8
43491: PUSH
43492: FOR_IN
43493: IFFALSE 43562
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43495: LD_VAR 0 6
43499: PPUSH
43500: CALL_OW 313
43504: PUSH
43505: LD_INT 6
43507: LESS
43508: PUSH
43509: LD_VAR 0 6
43513: PPUSH
43514: CALL_OW 266
43518: PUSH
43519: LD_INT 31
43521: PUSH
43522: LD_INT 32
43524: PUSH
43525: EMPTY
43526: LIST
43527: LIST
43528: IN
43529: NOT
43530: AND
43531: PUSH
43532: LD_VAR 0 6
43536: PPUSH
43537: CALL_OW 313
43541: PUSH
43542: LD_INT 0
43544: EQUAL
43545: OR
43546: IFFALSE 43560
// begin j := i ;
43548: LD_ADDR_VAR 0 7
43552: PUSH
43553: LD_VAR 0 6
43557: ST_TO_ADDR
// break ;
43558: GO 43562
// end ; end ;
43560: GO 43492
43562: POP
43563: POP
// if j then
43564: LD_VAR 0 7
43568: IFFALSE 43586
// ComEnterUnit ( unit , j ) else
43570: LD_VAR 0 3
43574: PPUSH
43575: LD_VAR 0 7
43579: PPUSH
43580: CALL_OW 120
43584: GO 43689
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43586: LD_ADDR_VAR 0 10
43590: PUSH
43591: LD_VAR 0 2
43595: PPUSH
43596: LD_INT 2
43598: PUSH
43599: LD_INT 30
43601: PUSH
43602: LD_INT 0
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: PUSH
43609: LD_INT 30
43611: PUSH
43612: LD_INT 1
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: LIST
43623: PPUSH
43624: CALL_OW 72
43628: ST_TO_ADDR
// if depot then
43629: LD_VAR 0 10
43633: IFFALSE 43689
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43635: LD_ADDR_VAR 0 10
43639: PUSH
43640: LD_VAR 0 10
43644: PPUSH
43645: LD_VAR 0 3
43649: PPUSH
43650: CALL_OW 74
43654: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43655: LD_VAR 0 3
43659: PPUSH
43660: LD_VAR 0 10
43664: PPUSH
43665: CALL_OW 296
43669: PUSH
43670: LD_INT 10
43672: GREATER
43673: IFFALSE 43689
// ComStandNearbyBuilding ( unit , depot ) ;
43675: LD_VAR 0 3
43679: PPUSH
43680: LD_VAR 0 10
43684: PPUSH
43685: CALL 52223 0 2
// end ; end ; end ;
43689: LD_VAR 0 5
43693: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43694: LD_INT 0
43696: PPUSH
43697: PPUSH
43698: PPUSH
43699: PPUSH
// if not mc_bases then
43700: LD_EXP 88
43704: NOT
43705: IFFALSE 43709
// exit ;
43707: GO 43948
// for i = 1 to mc_bases do
43709: LD_ADDR_VAR 0 2
43713: PUSH
43714: DOUBLE
43715: LD_INT 1
43717: DEC
43718: ST_TO_ADDR
43719: LD_EXP 88
43723: PUSH
43724: FOR_TO
43725: IFFALSE 43946
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43727: LD_ADDR_VAR 0 4
43731: PUSH
43732: LD_EXP 88
43736: PUSH
43737: LD_VAR 0 2
43741: ARRAY
43742: PPUSH
43743: LD_INT 21
43745: PUSH
43746: LD_INT 1
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PPUSH
43753: CALL_OW 72
43757: PUSH
43758: LD_EXP 117
43762: PUSH
43763: LD_VAR 0 2
43767: ARRAY
43768: UNION
43769: ST_TO_ADDR
// if not tmp then
43770: LD_VAR 0 4
43774: NOT
43775: IFFALSE 43779
// continue ;
43777: GO 43724
// for j in tmp do
43779: LD_ADDR_VAR 0 3
43783: PUSH
43784: LD_VAR 0 4
43788: PUSH
43789: FOR_IN
43790: IFFALSE 43942
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43792: LD_VAR 0 3
43796: PPUSH
43797: CALL_OW 110
43801: NOT
43802: PUSH
43803: LD_VAR 0 3
43807: PPUSH
43808: CALL_OW 314
43812: NOT
43813: AND
43814: PUSH
43815: LD_VAR 0 3
43819: PPUSH
43820: CALL_OW 311
43824: NOT
43825: AND
43826: PUSH
43827: LD_VAR 0 3
43831: PPUSH
43832: CALL_OW 310
43836: NOT
43837: AND
43838: PUSH
43839: LD_VAR 0 3
43843: PUSH
43844: LD_EXP 91
43848: PUSH
43849: LD_VAR 0 2
43853: ARRAY
43854: PUSH
43855: LD_INT 1
43857: ARRAY
43858: IN
43859: NOT
43860: AND
43861: PUSH
43862: LD_VAR 0 3
43866: PUSH
43867: LD_EXP 91
43871: PUSH
43872: LD_VAR 0 2
43876: ARRAY
43877: PUSH
43878: LD_INT 2
43880: ARRAY
43881: IN
43882: NOT
43883: AND
43884: PUSH
43885: LD_VAR 0 3
43889: PUSH
43890: LD_EXP 100
43894: PUSH
43895: LD_VAR 0 2
43899: ARRAY
43900: IN
43901: NOT
43902: AND
43903: IFFALSE 43940
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43905: LD_VAR 0 2
43909: PPUSH
43910: LD_EXP 88
43914: PUSH
43915: LD_VAR 0 2
43919: ARRAY
43920: PPUSH
43921: LD_VAR 0 3
43925: PPUSH
43926: LD_VAR 0 3
43930: PPUSH
43931: CALL_OW 257
43935: PPUSH
43936: CALL 42712 0 4
// end ;
43940: GO 43789
43942: POP
43943: POP
// end ;
43944: GO 43724
43946: POP
43947: POP
// end ;
43948: LD_VAR 0 1
43952: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43953: LD_INT 0
43955: PPUSH
43956: PPUSH
43957: PPUSH
43958: PPUSH
43959: PPUSH
43960: PPUSH
// if not mc_bases [ base ] then
43961: LD_EXP 88
43965: PUSH
43966: LD_VAR 0 1
43970: ARRAY
43971: NOT
43972: IFFALSE 43976
// exit ;
43974: GO 44158
// tmp := [ ] ;
43976: LD_ADDR_VAR 0 6
43980: PUSH
43981: EMPTY
43982: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43983: LD_ADDR_VAR 0 7
43987: PUSH
43988: LD_VAR 0 3
43992: PPUSH
43993: LD_INT 0
43995: PPUSH
43996: CALL_OW 517
44000: ST_TO_ADDR
// if not list then
44001: LD_VAR 0 7
44005: NOT
44006: IFFALSE 44010
// exit ;
44008: GO 44158
// for i = 1 to amount do
44010: LD_ADDR_VAR 0 5
44014: PUSH
44015: DOUBLE
44016: LD_INT 1
44018: DEC
44019: ST_TO_ADDR
44020: LD_VAR 0 2
44024: PUSH
44025: FOR_TO
44026: IFFALSE 44106
// begin x := rand ( 1 , list [ 1 ] ) ;
44028: LD_ADDR_VAR 0 8
44032: PUSH
44033: LD_INT 1
44035: PPUSH
44036: LD_VAR 0 7
44040: PUSH
44041: LD_INT 1
44043: ARRAY
44044: PPUSH
44045: CALL_OW 12
44049: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44050: LD_ADDR_VAR 0 6
44054: PUSH
44055: LD_VAR 0 6
44059: PPUSH
44060: LD_VAR 0 5
44064: PPUSH
44065: LD_VAR 0 7
44069: PUSH
44070: LD_INT 1
44072: ARRAY
44073: PUSH
44074: LD_VAR 0 8
44078: ARRAY
44079: PUSH
44080: LD_VAR 0 7
44084: PUSH
44085: LD_INT 2
44087: ARRAY
44088: PUSH
44089: LD_VAR 0 8
44093: ARRAY
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PPUSH
44099: CALL_OW 1
44103: ST_TO_ADDR
// end ;
44104: GO 44025
44106: POP
44107: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44108: LD_ADDR_EXP 101
44112: PUSH
44113: LD_EXP 101
44117: PPUSH
44118: LD_VAR 0 1
44122: PPUSH
44123: LD_VAR 0 6
44127: PPUSH
44128: CALL_OW 1
44132: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44133: LD_ADDR_EXP 103
44137: PUSH
44138: LD_EXP 103
44142: PPUSH
44143: LD_VAR 0 1
44147: PPUSH
44148: LD_VAR 0 3
44152: PPUSH
44153: CALL_OW 1
44157: ST_TO_ADDR
// end ;
44158: LD_VAR 0 4
44162: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44163: LD_INT 0
44165: PPUSH
// if not mc_bases [ base ] then
44166: LD_EXP 88
44170: PUSH
44171: LD_VAR 0 1
44175: ARRAY
44176: NOT
44177: IFFALSE 44181
// exit ;
44179: GO 44206
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44181: LD_ADDR_EXP 93
44185: PUSH
44186: LD_EXP 93
44190: PPUSH
44191: LD_VAR 0 1
44195: PPUSH
44196: LD_VAR 0 2
44200: PPUSH
44201: CALL_OW 1
44205: ST_TO_ADDR
// end ;
44206: LD_VAR 0 3
44210: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44211: LD_INT 0
44213: PPUSH
// if not mc_bases [ base ] then
44214: LD_EXP 88
44218: PUSH
44219: LD_VAR 0 1
44223: ARRAY
44224: NOT
44225: IFFALSE 44229
// exit ;
44227: GO 44266
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44229: LD_ADDR_EXP 93
44233: PUSH
44234: LD_EXP 93
44238: PPUSH
44239: LD_VAR 0 1
44243: PPUSH
44244: LD_EXP 93
44248: PUSH
44249: LD_VAR 0 1
44253: ARRAY
44254: PUSH
44255: LD_VAR 0 2
44259: UNION
44260: PPUSH
44261: CALL_OW 1
44265: ST_TO_ADDR
// end ;
44266: LD_VAR 0 3
44270: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44271: LD_INT 0
44273: PPUSH
// if not mc_bases [ base ] then
44274: LD_EXP 88
44278: PUSH
44279: LD_VAR 0 1
44283: ARRAY
44284: NOT
44285: IFFALSE 44289
// exit ;
44287: GO 44314
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44289: LD_ADDR_EXP 109
44293: PUSH
44294: LD_EXP 109
44298: PPUSH
44299: LD_VAR 0 1
44303: PPUSH
44304: LD_VAR 0 2
44308: PPUSH
44309: CALL_OW 1
44313: ST_TO_ADDR
// end ;
44314: LD_VAR 0 3
44318: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44319: LD_INT 0
44321: PPUSH
// if not mc_bases [ base ] then
44322: LD_EXP 88
44326: PUSH
44327: LD_VAR 0 1
44331: ARRAY
44332: NOT
44333: IFFALSE 44337
// exit ;
44335: GO 44374
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44337: LD_ADDR_EXP 109
44341: PUSH
44342: LD_EXP 109
44346: PPUSH
44347: LD_VAR 0 1
44351: PPUSH
44352: LD_EXP 109
44356: PUSH
44357: LD_VAR 0 1
44361: ARRAY
44362: PUSH
44363: LD_VAR 0 2
44367: ADD
44368: PPUSH
44369: CALL_OW 1
44373: ST_TO_ADDR
// end ;
44374: LD_VAR 0 3
44378: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44379: LD_INT 0
44381: PPUSH
// if not mc_bases [ base ] then
44382: LD_EXP 88
44386: PUSH
44387: LD_VAR 0 1
44391: ARRAY
44392: NOT
44393: IFFALSE 44397
// exit ;
44395: GO 44451
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44397: LD_ADDR_EXP 110
44401: PUSH
44402: LD_EXP 110
44406: PPUSH
44407: LD_VAR 0 1
44411: PPUSH
44412: LD_VAR 0 2
44416: PPUSH
44417: CALL_OW 1
44421: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44422: LD_ADDR_EXP 99
44426: PUSH
44427: LD_EXP 99
44431: PPUSH
44432: LD_VAR 0 1
44436: PPUSH
44437: LD_VAR 0 2
44441: PUSH
44442: LD_INT 0
44444: PLUS
44445: PPUSH
44446: CALL_OW 1
44450: ST_TO_ADDR
// end ;
44451: LD_VAR 0 3
44455: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44456: LD_INT 0
44458: PPUSH
// if not mc_bases [ base ] then
44459: LD_EXP 88
44463: PUSH
44464: LD_VAR 0 1
44468: ARRAY
44469: NOT
44470: IFFALSE 44474
// exit ;
44472: GO 44499
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44474: LD_ADDR_EXP 99
44478: PUSH
44479: LD_EXP 99
44483: PPUSH
44484: LD_VAR 0 1
44488: PPUSH
44489: LD_VAR 0 2
44493: PPUSH
44494: CALL_OW 1
44498: ST_TO_ADDR
// end ;
44499: LD_VAR 0 3
44503: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44504: LD_INT 0
44506: PPUSH
44507: PPUSH
44508: PPUSH
44509: PPUSH
// if not mc_bases [ base ] then
44510: LD_EXP 88
44514: PUSH
44515: LD_VAR 0 1
44519: ARRAY
44520: NOT
44521: IFFALSE 44525
// exit ;
44523: GO 44590
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44525: LD_ADDR_EXP 108
44529: PUSH
44530: LD_EXP 108
44534: PPUSH
44535: LD_VAR 0 1
44539: PUSH
44540: LD_EXP 108
44544: PUSH
44545: LD_VAR 0 1
44549: ARRAY
44550: PUSH
44551: LD_INT 1
44553: PLUS
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PPUSH
44559: LD_VAR 0 1
44563: PUSH
44564: LD_VAR 0 2
44568: PUSH
44569: LD_VAR 0 3
44573: PUSH
44574: LD_VAR 0 4
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: LIST
44583: LIST
44584: PPUSH
44585: CALL 55609 0 3
44589: ST_TO_ADDR
// end ;
44590: LD_VAR 0 5
44594: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44595: LD_INT 0
44597: PPUSH
// if not mc_bases [ base ] then
44598: LD_EXP 88
44602: PUSH
44603: LD_VAR 0 1
44607: ARRAY
44608: NOT
44609: IFFALSE 44613
// exit ;
44611: GO 44638
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44613: LD_ADDR_EXP 125
44617: PUSH
44618: LD_EXP 125
44622: PPUSH
44623: LD_VAR 0 1
44627: PPUSH
44628: LD_VAR 0 2
44632: PPUSH
44633: CALL_OW 1
44637: ST_TO_ADDR
// end ;
44638: LD_VAR 0 3
44642: RET
// export function MC_GetMinesField ( base ) ; begin
44643: LD_INT 0
44645: PPUSH
// result := mc_mines [ base ] ;
44646: LD_ADDR_VAR 0 2
44650: PUSH
44651: LD_EXP 101
44655: PUSH
44656: LD_VAR 0 1
44660: ARRAY
44661: ST_TO_ADDR
// end ;
44662: LD_VAR 0 2
44666: RET
// export function MC_GetProduceList ( base ) ; begin
44667: LD_INT 0
44669: PPUSH
// result := mc_produce [ base ] ;
44670: LD_ADDR_VAR 0 2
44674: PUSH
44675: LD_EXP 109
44679: PUSH
44680: LD_VAR 0 1
44684: ARRAY
44685: ST_TO_ADDR
// end ;
44686: LD_VAR 0 2
44690: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44691: LD_INT 0
44693: PPUSH
44694: PPUSH
// if not mc_bases then
44695: LD_EXP 88
44699: NOT
44700: IFFALSE 44704
// exit ;
44702: GO 44769
// if mc_bases [ base ] then
44704: LD_EXP 88
44708: PUSH
44709: LD_VAR 0 1
44713: ARRAY
44714: IFFALSE 44769
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44716: LD_ADDR_VAR 0 3
44720: PUSH
44721: LD_EXP 88
44725: PUSH
44726: LD_VAR 0 1
44730: ARRAY
44731: PPUSH
44732: LD_INT 30
44734: PUSH
44735: LD_VAR 0 2
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: PPUSH
44744: CALL_OW 72
44748: ST_TO_ADDR
// if result then
44749: LD_VAR 0 3
44753: IFFALSE 44769
// result := result [ 1 ] ;
44755: LD_ADDR_VAR 0 3
44759: PUSH
44760: LD_VAR 0 3
44764: PUSH
44765: LD_INT 1
44767: ARRAY
44768: ST_TO_ADDR
// end ; end ;
44769: LD_VAR 0 3
44773: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44774: LD_INT 0
44776: PPUSH
44777: PPUSH
// if not mc_bases then
44778: LD_EXP 88
44782: NOT
44783: IFFALSE 44787
// exit ;
44785: GO 44832
// if mc_bases [ base ] then
44787: LD_EXP 88
44791: PUSH
44792: LD_VAR 0 1
44796: ARRAY
44797: IFFALSE 44832
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44799: LD_ADDR_VAR 0 3
44803: PUSH
44804: LD_EXP 88
44808: PUSH
44809: LD_VAR 0 1
44813: ARRAY
44814: PPUSH
44815: LD_INT 30
44817: PUSH
44818: LD_VAR 0 2
44822: PUSH
44823: EMPTY
44824: LIST
44825: LIST
44826: PPUSH
44827: CALL_OW 72
44831: ST_TO_ADDR
// end ;
44832: LD_VAR 0 3
44836: RET
// export function MC_SetTame ( base , area ) ; begin
44837: LD_INT 0
44839: PPUSH
// if not mc_bases or not base then
44840: LD_EXP 88
44844: NOT
44845: PUSH
44846: LD_VAR 0 1
44850: NOT
44851: OR
44852: IFFALSE 44856
// exit ;
44854: GO 44881
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44856: LD_ADDR_EXP 116
44860: PUSH
44861: LD_EXP 116
44865: PPUSH
44866: LD_VAR 0 1
44870: PPUSH
44871: LD_VAR 0 2
44875: PPUSH
44876: CALL_OW 1
44880: ST_TO_ADDR
// end ;
44881: LD_VAR 0 3
44885: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44886: LD_INT 0
44888: PPUSH
44889: PPUSH
// if not mc_bases or not base then
44890: LD_EXP 88
44894: NOT
44895: PUSH
44896: LD_VAR 0 1
44900: NOT
44901: OR
44902: IFFALSE 44906
// exit ;
44904: GO 45008
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44906: LD_ADDR_VAR 0 4
44910: PUSH
44911: LD_EXP 88
44915: PUSH
44916: LD_VAR 0 1
44920: ARRAY
44921: PPUSH
44922: LD_INT 30
44924: PUSH
44925: LD_VAR 0 2
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PPUSH
44934: CALL_OW 72
44938: ST_TO_ADDR
// if not tmp then
44939: LD_VAR 0 4
44943: NOT
44944: IFFALSE 44948
// exit ;
44946: GO 45008
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44948: LD_ADDR_EXP 120
44952: PUSH
44953: LD_EXP 120
44957: PPUSH
44958: LD_VAR 0 1
44962: PPUSH
44963: LD_EXP 120
44967: PUSH
44968: LD_VAR 0 1
44972: ARRAY
44973: PPUSH
44974: LD_EXP 120
44978: PUSH
44979: LD_VAR 0 1
44983: ARRAY
44984: PUSH
44985: LD_INT 1
44987: PLUS
44988: PPUSH
44989: LD_VAR 0 4
44993: PUSH
44994: LD_INT 1
44996: ARRAY
44997: PPUSH
44998: CALL_OW 2
45002: PPUSH
45003: CALL_OW 1
45007: ST_TO_ADDR
// end ;
45008: LD_VAR 0 3
45012: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45013: LD_INT 0
45015: PPUSH
45016: PPUSH
// if not mc_bases or not base or not kinds then
45017: LD_EXP 88
45021: NOT
45022: PUSH
45023: LD_VAR 0 1
45027: NOT
45028: OR
45029: PUSH
45030: LD_VAR 0 2
45034: NOT
45035: OR
45036: IFFALSE 45040
// exit ;
45038: GO 45101
// for i in kinds do
45040: LD_ADDR_VAR 0 4
45044: PUSH
45045: LD_VAR 0 2
45049: PUSH
45050: FOR_IN
45051: IFFALSE 45099
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45053: LD_ADDR_EXP 122
45057: PUSH
45058: LD_EXP 122
45062: PPUSH
45063: LD_VAR 0 1
45067: PUSH
45068: LD_EXP 122
45072: PUSH
45073: LD_VAR 0 1
45077: ARRAY
45078: PUSH
45079: LD_INT 1
45081: PLUS
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: PPUSH
45087: LD_VAR 0 4
45091: PPUSH
45092: CALL 55609 0 3
45096: ST_TO_ADDR
45097: GO 45050
45099: POP
45100: POP
// end ;
45101: LD_VAR 0 3
45105: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45106: LD_INT 0
45108: PPUSH
// if not mc_bases or not base or not areas then
45109: LD_EXP 88
45113: NOT
45114: PUSH
45115: LD_VAR 0 1
45119: NOT
45120: OR
45121: PUSH
45122: LD_VAR 0 2
45126: NOT
45127: OR
45128: IFFALSE 45132
// exit ;
45130: GO 45157
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45132: LD_ADDR_EXP 106
45136: PUSH
45137: LD_EXP 106
45141: PPUSH
45142: LD_VAR 0 1
45146: PPUSH
45147: LD_VAR 0 2
45151: PPUSH
45152: CALL_OW 1
45156: ST_TO_ADDR
// end ;
45157: LD_VAR 0 3
45161: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45162: LD_INT 0
45164: PPUSH
// if not mc_bases or not base or not teleports_exit then
45165: LD_EXP 88
45169: NOT
45170: PUSH
45171: LD_VAR 0 1
45175: NOT
45176: OR
45177: PUSH
45178: LD_VAR 0 2
45182: NOT
45183: OR
45184: IFFALSE 45188
// exit ;
45186: GO 45213
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45188: LD_ADDR_EXP 123
45192: PUSH
45193: LD_EXP 123
45197: PPUSH
45198: LD_VAR 0 1
45202: PPUSH
45203: LD_VAR 0 2
45207: PPUSH
45208: CALL_OW 1
45212: ST_TO_ADDR
// end ;
45213: LD_VAR 0 3
45217: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45218: LD_INT 0
45220: PPUSH
45221: PPUSH
45222: PPUSH
// if not mc_bases or not base or not ext_list then
45223: LD_EXP 88
45227: NOT
45228: PUSH
45229: LD_VAR 0 1
45233: NOT
45234: OR
45235: PUSH
45236: LD_VAR 0 5
45240: NOT
45241: OR
45242: IFFALSE 45246
// exit ;
45244: GO 45419
// tmp := GetFacExtXYD ( x , y , d ) ;
45246: LD_ADDR_VAR 0 8
45250: PUSH
45251: LD_VAR 0 2
45255: PPUSH
45256: LD_VAR 0 3
45260: PPUSH
45261: LD_VAR 0 4
45265: PPUSH
45266: CALL 84288 0 3
45270: ST_TO_ADDR
// if not tmp then
45271: LD_VAR 0 8
45275: NOT
45276: IFFALSE 45280
// exit ;
45278: GO 45419
// for i in tmp do
45280: LD_ADDR_VAR 0 7
45284: PUSH
45285: LD_VAR 0 8
45289: PUSH
45290: FOR_IN
45291: IFFALSE 45417
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45293: LD_ADDR_EXP 93
45297: PUSH
45298: LD_EXP 93
45302: PPUSH
45303: LD_VAR 0 1
45307: PPUSH
45308: LD_EXP 93
45312: PUSH
45313: LD_VAR 0 1
45317: ARRAY
45318: PPUSH
45319: LD_EXP 93
45323: PUSH
45324: LD_VAR 0 1
45328: ARRAY
45329: PUSH
45330: LD_INT 1
45332: PLUS
45333: PPUSH
45334: LD_VAR 0 5
45338: PUSH
45339: LD_INT 1
45341: ARRAY
45342: PUSH
45343: LD_VAR 0 7
45347: PUSH
45348: LD_INT 1
45350: ARRAY
45351: PUSH
45352: LD_VAR 0 7
45356: PUSH
45357: LD_INT 2
45359: ARRAY
45360: PUSH
45361: LD_VAR 0 7
45365: PUSH
45366: LD_INT 3
45368: ARRAY
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: PPUSH
45376: CALL_OW 2
45380: PPUSH
45381: CALL_OW 1
45385: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45386: LD_ADDR_VAR 0 5
45390: PUSH
45391: LD_VAR 0 5
45395: PPUSH
45396: LD_INT 1
45398: PPUSH
45399: CALL_OW 3
45403: ST_TO_ADDR
// if not ext_list then
45404: LD_VAR 0 5
45408: NOT
45409: IFFALSE 45415
// exit ;
45411: POP
45412: POP
45413: GO 45419
// end ;
45415: GO 45290
45417: POP
45418: POP
// end ;
45419: LD_VAR 0 6
45423: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45424: LD_INT 0
45426: PPUSH
// if not mc_bases or not base or not weapon_list then
45427: LD_EXP 88
45431: NOT
45432: PUSH
45433: LD_VAR 0 1
45437: NOT
45438: OR
45439: PUSH
45440: LD_VAR 0 2
45444: NOT
45445: OR
45446: IFFALSE 45450
// exit ;
45448: GO 45475
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45450: LD_ADDR_EXP 127
45454: PUSH
45455: LD_EXP 127
45459: PPUSH
45460: LD_VAR 0 1
45464: PPUSH
45465: LD_VAR 0 2
45469: PPUSH
45470: CALL_OW 1
45474: ST_TO_ADDR
// end ;
45475: LD_VAR 0 3
45479: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45480: LD_INT 0
45482: PPUSH
// if not mc_bases or not base or not tech_list then
45483: LD_EXP 88
45487: NOT
45488: PUSH
45489: LD_VAR 0 1
45493: NOT
45494: OR
45495: PUSH
45496: LD_VAR 0 2
45500: NOT
45501: OR
45502: IFFALSE 45506
// exit ;
45504: GO 45531
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45506: LD_ADDR_EXP 115
45510: PUSH
45511: LD_EXP 115
45515: PPUSH
45516: LD_VAR 0 1
45520: PPUSH
45521: LD_VAR 0 2
45525: PPUSH
45526: CALL_OW 1
45530: ST_TO_ADDR
// end ;
45531: LD_VAR 0 3
45535: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45536: LD_INT 0
45538: PPUSH
// if not mc_bases or not parking_area or not base then
45539: LD_EXP 88
45543: NOT
45544: PUSH
45545: LD_VAR 0 2
45549: NOT
45550: OR
45551: PUSH
45552: LD_VAR 0 1
45556: NOT
45557: OR
45558: IFFALSE 45562
// exit ;
45560: GO 45587
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45562: LD_ADDR_EXP 112
45566: PUSH
45567: LD_EXP 112
45571: PPUSH
45572: LD_VAR 0 1
45576: PPUSH
45577: LD_VAR 0 2
45581: PPUSH
45582: CALL_OW 1
45586: ST_TO_ADDR
// end ;
45587: LD_VAR 0 3
45591: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45592: LD_INT 0
45594: PPUSH
// if not mc_bases or not base or not scan_area then
45595: LD_EXP 88
45599: NOT
45600: PUSH
45601: LD_VAR 0 1
45605: NOT
45606: OR
45607: PUSH
45608: LD_VAR 0 2
45612: NOT
45613: OR
45614: IFFALSE 45618
// exit ;
45616: GO 45643
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45618: LD_ADDR_EXP 113
45622: PUSH
45623: LD_EXP 113
45627: PPUSH
45628: LD_VAR 0 1
45632: PPUSH
45633: LD_VAR 0 2
45637: PPUSH
45638: CALL_OW 1
45642: ST_TO_ADDR
// end ;
45643: LD_VAR 0 3
45647: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45648: LD_INT 0
45650: PPUSH
45651: PPUSH
// if not mc_bases or not base then
45652: LD_EXP 88
45656: NOT
45657: PUSH
45658: LD_VAR 0 1
45662: NOT
45663: OR
45664: IFFALSE 45668
// exit ;
45666: GO 45732
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45668: LD_ADDR_VAR 0 3
45672: PUSH
45673: LD_INT 1
45675: PUSH
45676: LD_INT 2
45678: PUSH
45679: LD_INT 3
45681: PUSH
45682: LD_INT 4
45684: PUSH
45685: LD_INT 11
45687: PUSH
45688: EMPTY
45689: LIST
45690: LIST
45691: LIST
45692: LIST
45693: LIST
45694: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45695: LD_ADDR_EXP 115
45699: PUSH
45700: LD_EXP 115
45704: PPUSH
45705: LD_VAR 0 1
45709: PPUSH
45710: LD_EXP 115
45714: PUSH
45715: LD_VAR 0 1
45719: ARRAY
45720: PUSH
45721: LD_VAR 0 3
45725: DIFF
45726: PPUSH
45727: CALL_OW 1
45731: ST_TO_ADDR
// end ;
45732: LD_VAR 0 2
45736: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45737: LD_INT 0
45739: PPUSH
// result := mc_vehicles [ base ] ;
45740: LD_ADDR_VAR 0 3
45744: PUSH
45745: LD_EXP 107
45749: PUSH
45750: LD_VAR 0 1
45754: ARRAY
45755: ST_TO_ADDR
// if onlyCombat then
45756: LD_VAR 0 2
45760: IFFALSE 45925
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45762: LD_ADDR_VAR 0 3
45766: PUSH
45767: LD_VAR 0 3
45771: PUSH
45772: LD_VAR 0 3
45776: PPUSH
45777: LD_INT 2
45779: PUSH
45780: LD_INT 34
45782: PUSH
45783: LD_INT 12
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: PUSH
45790: LD_INT 34
45792: PUSH
45793: LD_INT 51
45795: PUSH
45796: EMPTY
45797: LIST
45798: LIST
45799: PUSH
45800: LD_INT 34
45802: PUSH
45803: LD_EXP 73
45807: PUSH
45808: EMPTY
45809: LIST
45810: LIST
45811: PUSH
45812: LD_INT 34
45814: PUSH
45815: LD_INT 32
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: PUSH
45822: LD_INT 34
45824: PUSH
45825: LD_INT 13
45827: PUSH
45828: EMPTY
45829: LIST
45830: LIST
45831: PUSH
45832: LD_INT 34
45834: PUSH
45835: LD_INT 52
45837: PUSH
45838: EMPTY
45839: LIST
45840: LIST
45841: PUSH
45842: LD_INT 34
45844: PUSH
45845: LD_INT 14
45847: PUSH
45848: EMPTY
45849: LIST
45850: LIST
45851: PUSH
45852: LD_INT 34
45854: PUSH
45855: LD_INT 53
45857: PUSH
45858: EMPTY
45859: LIST
45860: LIST
45861: PUSH
45862: LD_INT 34
45864: PUSH
45865: LD_EXP 72
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 34
45876: PUSH
45877: LD_INT 31
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: LD_INT 34
45886: PUSH
45887: LD_INT 48
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 34
45896: PUSH
45897: LD_INT 8
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: EMPTY
45905: LIST
45906: LIST
45907: LIST
45908: LIST
45909: LIST
45910: LIST
45911: LIST
45912: LIST
45913: LIST
45914: LIST
45915: LIST
45916: LIST
45917: LIST
45918: PPUSH
45919: CALL_OW 72
45923: DIFF
45924: ST_TO_ADDR
// end ; end_of_file
45925: LD_VAR 0 3
45929: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45930: LD_INT 0
45932: PPUSH
45933: PPUSH
45934: PPUSH
// if not mc_bases or not skirmish then
45935: LD_EXP 88
45939: NOT
45940: PUSH
45941: LD_EXP 86
45945: NOT
45946: OR
45947: IFFALSE 45951
// exit ;
45949: GO 46116
// for i = 1 to mc_bases do
45951: LD_ADDR_VAR 0 4
45955: PUSH
45956: DOUBLE
45957: LD_INT 1
45959: DEC
45960: ST_TO_ADDR
45961: LD_EXP 88
45965: PUSH
45966: FOR_TO
45967: IFFALSE 46114
// begin if sci in mc_bases [ i ] then
45969: LD_VAR 0 2
45973: PUSH
45974: LD_EXP 88
45978: PUSH
45979: LD_VAR 0 4
45983: ARRAY
45984: IN
45985: IFFALSE 46112
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45987: LD_ADDR_EXP 117
45991: PUSH
45992: LD_EXP 117
45996: PPUSH
45997: LD_VAR 0 4
46001: PUSH
46002: LD_EXP 117
46006: PUSH
46007: LD_VAR 0 4
46011: ARRAY
46012: PUSH
46013: LD_INT 1
46015: PLUS
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: PPUSH
46021: LD_VAR 0 1
46025: PPUSH
46026: CALL 55609 0 3
46030: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46031: LD_ADDR_VAR 0 5
46035: PUSH
46036: LD_EXP 88
46040: PUSH
46041: LD_VAR 0 4
46045: ARRAY
46046: PPUSH
46047: LD_INT 2
46049: PUSH
46050: LD_INT 30
46052: PUSH
46053: LD_INT 0
46055: PUSH
46056: EMPTY
46057: LIST
46058: LIST
46059: PUSH
46060: LD_INT 30
46062: PUSH
46063: LD_INT 1
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: LIST
46074: PPUSH
46075: CALL_OW 72
46079: PPUSH
46080: LD_VAR 0 1
46084: PPUSH
46085: CALL_OW 74
46089: ST_TO_ADDR
// if tmp then
46090: LD_VAR 0 5
46094: IFFALSE 46110
// ComStandNearbyBuilding ( ape , tmp ) ;
46096: LD_VAR 0 1
46100: PPUSH
46101: LD_VAR 0 5
46105: PPUSH
46106: CALL 52223 0 2
// break ;
46110: GO 46114
// end ; end ;
46112: GO 45966
46114: POP
46115: POP
// end ;
46116: LD_VAR 0 3
46120: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46121: LD_INT 0
46123: PPUSH
46124: PPUSH
46125: PPUSH
// if not mc_bases or not skirmish then
46126: LD_EXP 88
46130: NOT
46131: PUSH
46132: LD_EXP 86
46136: NOT
46137: OR
46138: IFFALSE 46142
// exit ;
46140: GO 46231
// for i = 1 to mc_bases do
46142: LD_ADDR_VAR 0 4
46146: PUSH
46147: DOUBLE
46148: LD_INT 1
46150: DEC
46151: ST_TO_ADDR
46152: LD_EXP 88
46156: PUSH
46157: FOR_TO
46158: IFFALSE 46229
// begin if building in mc_busy_turret_list [ i ] then
46160: LD_VAR 0 1
46164: PUSH
46165: LD_EXP 98
46169: PUSH
46170: LD_VAR 0 4
46174: ARRAY
46175: IN
46176: IFFALSE 46227
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46178: LD_ADDR_VAR 0 5
46182: PUSH
46183: LD_EXP 98
46187: PUSH
46188: LD_VAR 0 4
46192: ARRAY
46193: PUSH
46194: LD_VAR 0 1
46198: DIFF
46199: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46200: LD_ADDR_EXP 98
46204: PUSH
46205: LD_EXP 98
46209: PPUSH
46210: LD_VAR 0 4
46214: PPUSH
46215: LD_VAR 0 5
46219: PPUSH
46220: CALL_OW 1
46224: ST_TO_ADDR
// break ;
46225: GO 46229
// end ; end ;
46227: GO 46157
46229: POP
46230: POP
// end ;
46231: LD_VAR 0 3
46235: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46236: LD_INT 0
46238: PPUSH
46239: PPUSH
46240: PPUSH
// if not mc_bases or not skirmish then
46241: LD_EXP 88
46245: NOT
46246: PUSH
46247: LD_EXP 86
46251: NOT
46252: OR
46253: IFFALSE 46257
// exit ;
46255: GO 46456
// for i = 1 to mc_bases do
46257: LD_ADDR_VAR 0 5
46261: PUSH
46262: DOUBLE
46263: LD_INT 1
46265: DEC
46266: ST_TO_ADDR
46267: LD_EXP 88
46271: PUSH
46272: FOR_TO
46273: IFFALSE 46454
// if building in mc_bases [ i ] then
46275: LD_VAR 0 1
46279: PUSH
46280: LD_EXP 88
46284: PUSH
46285: LD_VAR 0 5
46289: ARRAY
46290: IN
46291: IFFALSE 46452
// begin tmp := mc_bases [ i ] diff building ;
46293: LD_ADDR_VAR 0 6
46297: PUSH
46298: LD_EXP 88
46302: PUSH
46303: LD_VAR 0 5
46307: ARRAY
46308: PUSH
46309: LD_VAR 0 1
46313: DIFF
46314: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46315: LD_ADDR_EXP 88
46319: PUSH
46320: LD_EXP 88
46324: PPUSH
46325: LD_VAR 0 5
46329: PPUSH
46330: LD_VAR 0 6
46334: PPUSH
46335: CALL_OW 1
46339: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46340: LD_VAR 0 1
46344: PUSH
46345: LD_EXP 96
46349: PUSH
46350: LD_VAR 0 5
46354: ARRAY
46355: IN
46356: IFFALSE 46395
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46358: LD_ADDR_EXP 96
46362: PUSH
46363: LD_EXP 96
46367: PPUSH
46368: LD_VAR 0 5
46372: PPUSH
46373: LD_EXP 96
46377: PUSH
46378: LD_VAR 0 5
46382: ARRAY
46383: PUSH
46384: LD_VAR 0 1
46388: DIFF
46389: PPUSH
46390: CALL_OW 1
46394: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46395: LD_VAR 0 1
46399: PUSH
46400: LD_EXP 97
46404: PUSH
46405: LD_VAR 0 5
46409: ARRAY
46410: IN
46411: IFFALSE 46450
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46413: LD_ADDR_EXP 97
46417: PUSH
46418: LD_EXP 97
46422: PPUSH
46423: LD_VAR 0 5
46427: PPUSH
46428: LD_EXP 97
46432: PUSH
46433: LD_VAR 0 5
46437: ARRAY
46438: PUSH
46439: LD_VAR 0 1
46443: DIFF
46444: PPUSH
46445: CALL_OW 1
46449: ST_TO_ADDR
// break ;
46450: GO 46454
// end ;
46452: GO 46272
46454: POP
46455: POP
// end ;
46456: LD_VAR 0 4
46460: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46461: LD_INT 0
46463: PPUSH
46464: PPUSH
46465: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46466: LD_EXP 88
46470: NOT
46471: PUSH
46472: LD_EXP 86
46476: NOT
46477: OR
46478: PUSH
46479: LD_VAR 0 3
46483: PUSH
46484: LD_EXP 114
46488: IN
46489: NOT
46490: OR
46491: IFFALSE 46495
// exit ;
46493: GO 46618
// for i = 1 to mc_vehicles do
46495: LD_ADDR_VAR 0 6
46499: PUSH
46500: DOUBLE
46501: LD_INT 1
46503: DEC
46504: ST_TO_ADDR
46505: LD_EXP 107
46509: PUSH
46510: FOR_TO
46511: IFFALSE 46616
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46513: LD_VAR 0 2
46517: PUSH
46518: LD_EXP 107
46522: PUSH
46523: LD_VAR 0 6
46527: ARRAY
46528: IN
46529: PUSH
46530: LD_VAR 0 1
46534: PUSH
46535: LD_EXP 107
46539: PUSH
46540: LD_VAR 0 6
46544: ARRAY
46545: IN
46546: OR
46547: IFFALSE 46614
// begin tmp := mc_vehicles [ i ] diff old ;
46549: LD_ADDR_VAR 0 7
46553: PUSH
46554: LD_EXP 107
46558: PUSH
46559: LD_VAR 0 6
46563: ARRAY
46564: PUSH
46565: LD_VAR 0 2
46569: DIFF
46570: ST_TO_ADDR
// tmp := tmp diff new ;
46571: LD_ADDR_VAR 0 7
46575: PUSH
46576: LD_VAR 0 7
46580: PUSH
46581: LD_VAR 0 1
46585: DIFF
46586: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46587: LD_ADDR_EXP 107
46591: PUSH
46592: LD_EXP 107
46596: PPUSH
46597: LD_VAR 0 6
46601: PPUSH
46602: LD_VAR 0 7
46606: PPUSH
46607: CALL_OW 1
46611: ST_TO_ADDR
// break ;
46612: GO 46616
// end ;
46614: GO 46510
46616: POP
46617: POP
// end ;
46618: LD_VAR 0 5
46622: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46623: LD_INT 0
46625: PPUSH
46626: PPUSH
46627: PPUSH
46628: PPUSH
// if not mc_bases or not skirmish then
46629: LD_EXP 88
46633: NOT
46634: PUSH
46635: LD_EXP 86
46639: NOT
46640: OR
46641: IFFALSE 46645
// exit ;
46643: GO 47022
// side := GetSide ( vehicle ) ;
46645: LD_ADDR_VAR 0 5
46649: PUSH
46650: LD_VAR 0 1
46654: PPUSH
46655: CALL_OW 255
46659: ST_TO_ADDR
// for i = 1 to mc_bases do
46660: LD_ADDR_VAR 0 4
46664: PUSH
46665: DOUBLE
46666: LD_INT 1
46668: DEC
46669: ST_TO_ADDR
46670: LD_EXP 88
46674: PUSH
46675: FOR_TO
46676: IFFALSE 47020
// begin if factory in mc_bases [ i ] then
46678: LD_VAR 0 2
46682: PUSH
46683: LD_EXP 88
46687: PUSH
46688: LD_VAR 0 4
46692: ARRAY
46693: IN
46694: IFFALSE 47018
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46696: LD_EXP 110
46700: PUSH
46701: LD_VAR 0 4
46705: ARRAY
46706: PUSH
46707: LD_EXP 99
46711: PUSH
46712: LD_VAR 0 4
46716: ARRAY
46717: LESS
46718: PUSH
46719: LD_VAR 0 1
46723: PPUSH
46724: CALL_OW 264
46728: PUSH
46729: LD_INT 31
46731: PUSH
46732: LD_INT 32
46734: PUSH
46735: LD_INT 51
46737: PUSH
46738: LD_EXP 73
46742: PUSH
46743: LD_INT 12
46745: PUSH
46746: LD_INT 30
46748: PUSH
46749: LD_EXP 72
46753: PUSH
46754: LD_INT 11
46756: PUSH
46757: LD_INT 53
46759: PUSH
46760: LD_INT 14
46762: PUSH
46763: LD_EXP 76
46767: PUSH
46768: LD_INT 29
46770: PUSH
46771: LD_EXP 74
46775: PUSH
46776: LD_INT 13
46778: PUSH
46779: LD_INT 52
46781: PUSH
46782: LD_INT 48
46784: PUSH
46785: LD_INT 8
46787: PUSH
46788: EMPTY
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: IN
46807: NOT
46808: AND
46809: IFFALSE 46857
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46811: LD_ADDR_EXP 110
46815: PUSH
46816: LD_EXP 110
46820: PPUSH
46821: LD_VAR 0 4
46825: PUSH
46826: LD_EXP 110
46830: PUSH
46831: LD_VAR 0 4
46835: ARRAY
46836: PUSH
46837: LD_INT 1
46839: PLUS
46840: PUSH
46841: EMPTY
46842: LIST
46843: LIST
46844: PPUSH
46845: LD_VAR 0 1
46849: PPUSH
46850: CALL 55609 0 3
46854: ST_TO_ADDR
46855: GO 46901
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46857: LD_ADDR_EXP 107
46861: PUSH
46862: LD_EXP 107
46866: PPUSH
46867: LD_VAR 0 4
46871: PUSH
46872: LD_EXP 107
46876: PUSH
46877: LD_VAR 0 4
46881: ARRAY
46882: PUSH
46883: LD_INT 1
46885: PLUS
46886: PUSH
46887: EMPTY
46888: LIST
46889: LIST
46890: PPUSH
46891: LD_VAR 0 1
46895: PPUSH
46896: CALL 55609 0 3
46900: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46901: LD_VAR 0 1
46905: PPUSH
46906: CALL_OW 263
46910: PUSH
46911: LD_INT 2
46913: EQUAL
46914: IFFALSE 46934
// begin repeat wait ( 0 0$1 ) ;
46916: LD_INT 35
46918: PPUSH
46919: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46923: LD_VAR 0 1
46927: PPUSH
46928: CALL_OW 312
46932: IFFALSE 46916
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46934: LD_VAR 0 1
46938: PPUSH
46939: LD_EXP 112
46943: PUSH
46944: LD_VAR 0 4
46948: ARRAY
46949: PPUSH
46950: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46954: LD_VAR 0 1
46958: PPUSH
46959: CALL_OW 263
46963: PUSH
46964: LD_INT 1
46966: NONEQUAL
46967: IFFALSE 46971
// break ;
46969: GO 47020
// repeat wait ( 0 0$1 ) ;
46971: LD_INT 35
46973: PPUSH
46974: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46978: LD_VAR 0 1
46982: PPUSH
46983: LD_EXP 112
46987: PUSH
46988: LD_VAR 0 4
46992: ARRAY
46993: PPUSH
46994: CALL_OW 308
46998: IFFALSE 46971
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47000: LD_VAR 0 1
47004: PPUSH
47005: CALL_OW 311
47009: PPUSH
47010: CALL_OW 121
// exit ;
47014: POP
47015: POP
47016: GO 47022
// end ; end ;
47018: GO 46675
47020: POP
47021: POP
// end ;
47022: LD_VAR 0 3
47026: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47027: LD_INT 0
47029: PPUSH
47030: PPUSH
47031: PPUSH
47032: PPUSH
// if not mc_bases or not skirmish then
47033: LD_EXP 88
47037: NOT
47038: PUSH
47039: LD_EXP 86
47043: NOT
47044: OR
47045: IFFALSE 47049
// exit ;
47047: GO 47402
// repeat wait ( 0 0$1 ) ;
47049: LD_INT 35
47051: PPUSH
47052: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47056: LD_VAR 0 2
47060: PPUSH
47061: LD_VAR 0 3
47065: PPUSH
47066: CALL_OW 284
47070: IFFALSE 47049
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47072: LD_VAR 0 2
47076: PPUSH
47077: LD_VAR 0 3
47081: PPUSH
47082: CALL_OW 283
47086: PUSH
47087: LD_INT 4
47089: EQUAL
47090: IFFALSE 47094
// exit ;
47092: GO 47402
// for i = 1 to mc_bases do
47094: LD_ADDR_VAR 0 7
47098: PUSH
47099: DOUBLE
47100: LD_INT 1
47102: DEC
47103: ST_TO_ADDR
47104: LD_EXP 88
47108: PUSH
47109: FOR_TO
47110: IFFALSE 47400
// begin if mc_crates_area [ i ] then
47112: LD_EXP 106
47116: PUSH
47117: LD_VAR 0 7
47121: ARRAY
47122: IFFALSE 47233
// for j in mc_crates_area [ i ] do
47124: LD_ADDR_VAR 0 8
47128: PUSH
47129: LD_EXP 106
47133: PUSH
47134: LD_VAR 0 7
47138: ARRAY
47139: PUSH
47140: FOR_IN
47141: IFFALSE 47231
// if InArea ( x , y , j ) then
47143: LD_VAR 0 2
47147: PPUSH
47148: LD_VAR 0 3
47152: PPUSH
47153: LD_VAR 0 8
47157: PPUSH
47158: CALL_OW 309
47162: IFFALSE 47229
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47164: LD_ADDR_EXP 104
47168: PUSH
47169: LD_EXP 104
47173: PPUSH
47174: LD_VAR 0 7
47178: PUSH
47179: LD_EXP 104
47183: PUSH
47184: LD_VAR 0 7
47188: ARRAY
47189: PUSH
47190: LD_INT 1
47192: PLUS
47193: PUSH
47194: EMPTY
47195: LIST
47196: LIST
47197: PPUSH
47198: LD_VAR 0 4
47202: PUSH
47203: LD_VAR 0 2
47207: PUSH
47208: LD_VAR 0 3
47212: PUSH
47213: EMPTY
47214: LIST
47215: LIST
47216: LIST
47217: PPUSH
47218: CALL 55609 0 3
47222: ST_TO_ADDR
// exit ;
47223: POP
47224: POP
47225: POP
47226: POP
47227: GO 47402
// end ;
47229: GO 47140
47231: POP
47232: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47233: LD_ADDR_VAR 0 9
47237: PUSH
47238: LD_EXP 88
47242: PUSH
47243: LD_VAR 0 7
47247: ARRAY
47248: PPUSH
47249: LD_INT 2
47251: PUSH
47252: LD_INT 30
47254: PUSH
47255: LD_INT 0
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: PUSH
47262: LD_INT 30
47264: PUSH
47265: LD_INT 1
47267: PUSH
47268: EMPTY
47269: LIST
47270: LIST
47271: PUSH
47272: EMPTY
47273: LIST
47274: LIST
47275: LIST
47276: PPUSH
47277: CALL_OW 72
47281: ST_TO_ADDR
// if not depot then
47282: LD_VAR 0 9
47286: NOT
47287: IFFALSE 47291
// continue ;
47289: GO 47109
// for j in depot do
47291: LD_ADDR_VAR 0 8
47295: PUSH
47296: LD_VAR 0 9
47300: PUSH
47301: FOR_IN
47302: IFFALSE 47396
// if GetDistUnitXY ( j , x , y ) < 30 then
47304: LD_VAR 0 8
47308: PPUSH
47309: LD_VAR 0 2
47313: PPUSH
47314: LD_VAR 0 3
47318: PPUSH
47319: CALL_OW 297
47323: PUSH
47324: LD_INT 30
47326: LESS
47327: IFFALSE 47394
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47329: LD_ADDR_EXP 104
47333: PUSH
47334: LD_EXP 104
47338: PPUSH
47339: LD_VAR 0 7
47343: PUSH
47344: LD_EXP 104
47348: PUSH
47349: LD_VAR 0 7
47353: ARRAY
47354: PUSH
47355: LD_INT 1
47357: PLUS
47358: PUSH
47359: EMPTY
47360: LIST
47361: LIST
47362: PPUSH
47363: LD_VAR 0 4
47367: PUSH
47368: LD_VAR 0 2
47372: PUSH
47373: LD_VAR 0 3
47377: PUSH
47378: EMPTY
47379: LIST
47380: LIST
47381: LIST
47382: PPUSH
47383: CALL 55609 0 3
47387: ST_TO_ADDR
// exit ;
47388: POP
47389: POP
47390: POP
47391: POP
47392: GO 47402
// end ;
47394: GO 47301
47396: POP
47397: POP
// end ;
47398: GO 47109
47400: POP
47401: POP
// end ;
47402: LD_VAR 0 6
47406: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47407: LD_INT 0
47409: PPUSH
47410: PPUSH
47411: PPUSH
47412: PPUSH
// if not mc_bases or not skirmish then
47413: LD_EXP 88
47417: NOT
47418: PUSH
47419: LD_EXP 86
47423: NOT
47424: OR
47425: IFFALSE 47429
// exit ;
47427: GO 47706
// side := GetSide ( lab ) ;
47429: LD_ADDR_VAR 0 4
47433: PUSH
47434: LD_VAR 0 2
47438: PPUSH
47439: CALL_OW 255
47443: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47444: LD_VAR 0 4
47448: PUSH
47449: LD_EXP 114
47453: IN
47454: NOT
47455: PUSH
47456: LD_EXP 115
47460: NOT
47461: OR
47462: PUSH
47463: LD_EXP 88
47467: NOT
47468: OR
47469: IFFALSE 47473
// exit ;
47471: GO 47706
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47473: LD_ADDR_EXP 115
47477: PUSH
47478: LD_EXP 115
47482: PPUSH
47483: LD_VAR 0 4
47487: PPUSH
47488: LD_EXP 115
47492: PUSH
47493: LD_VAR 0 4
47497: ARRAY
47498: PUSH
47499: LD_VAR 0 1
47503: DIFF
47504: PPUSH
47505: CALL_OW 1
47509: ST_TO_ADDR
// for i = 1 to mc_bases do
47510: LD_ADDR_VAR 0 5
47514: PUSH
47515: DOUBLE
47516: LD_INT 1
47518: DEC
47519: ST_TO_ADDR
47520: LD_EXP 88
47524: PUSH
47525: FOR_TO
47526: IFFALSE 47704
// begin if lab in mc_bases [ i ] then
47528: LD_VAR 0 2
47532: PUSH
47533: LD_EXP 88
47537: PUSH
47538: LD_VAR 0 5
47542: ARRAY
47543: IN
47544: IFFALSE 47702
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47546: LD_VAR 0 1
47550: PUSH
47551: LD_INT 11
47553: PUSH
47554: LD_INT 4
47556: PUSH
47557: LD_INT 3
47559: PUSH
47560: LD_INT 2
47562: PUSH
47563: EMPTY
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: IN
47569: PUSH
47570: LD_EXP 118
47574: PUSH
47575: LD_VAR 0 5
47579: ARRAY
47580: AND
47581: IFFALSE 47702
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47583: LD_ADDR_VAR 0 6
47587: PUSH
47588: LD_EXP 118
47592: PUSH
47593: LD_VAR 0 5
47597: ARRAY
47598: PUSH
47599: LD_INT 1
47601: ARRAY
47602: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47603: LD_ADDR_EXP 118
47607: PUSH
47608: LD_EXP 118
47612: PPUSH
47613: LD_VAR 0 5
47617: PPUSH
47618: EMPTY
47619: PPUSH
47620: CALL_OW 1
47624: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47625: LD_VAR 0 6
47629: PPUSH
47630: LD_INT 0
47632: PPUSH
47633: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47637: LD_VAR 0 6
47641: PPUSH
47642: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47646: LD_ADDR_EXP 117
47650: PUSH
47651: LD_EXP 117
47655: PPUSH
47656: LD_VAR 0 5
47660: PPUSH
47661: LD_EXP 117
47665: PUSH
47666: LD_VAR 0 5
47670: ARRAY
47671: PPUSH
47672: LD_INT 1
47674: PPUSH
47675: LD_VAR 0 6
47679: PPUSH
47680: CALL_OW 2
47684: PPUSH
47685: CALL_OW 1
47689: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47690: LD_VAR 0 5
47694: PPUSH
47695: LD_INT 112
47697: PPUSH
47698: CALL 24718 0 2
// end ; end ; end ;
47702: GO 47525
47704: POP
47705: POP
// end ;
47706: LD_VAR 0 3
47710: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47711: LD_INT 0
47713: PPUSH
47714: PPUSH
47715: PPUSH
47716: PPUSH
47717: PPUSH
47718: PPUSH
47719: PPUSH
47720: PPUSH
// if not mc_bases or not skirmish then
47721: LD_EXP 88
47725: NOT
47726: PUSH
47727: LD_EXP 86
47731: NOT
47732: OR
47733: IFFALSE 47737
// exit ;
47735: GO 49108
// for i = 1 to mc_bases do
47737: LD_ADDR_VAR 0 3
47741: PUSH
47742: DOUBLE
47743: LD_INT 1
47745: DEC
47746: ST_TO_ADDR
47747: LD_EXP 88
47751: PUSH
47752: FOR_TO
47753: IFFALSE 49106
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47755: LD_VAR 0 1
47759: PUSH
47760: LD_EXP 88
47764: PUSH
47765: LD_VAR 0 3
47769: ARRAY
47770: IN
47771: PUSH
47772: LD_VAR 0 1
47776: PUSH
47777: LD_EXP 95
47781: PUSH
47782: LD_VAR 0 3
47786: ARRAY
47787: IN
47788: OR
47789: PUSH
47790: LD_VAR 0 1
47794: PUSH
47795: LD_EXP 110
47799: PUSH
47800: LD_VAR 0 3
47804: ARRAY
47805: IN
47806: OR
47807: PUSH
47808: LD_VAR 0 1
47812: PUSH
47813: LD_EXP 107
47817: PUSH
47818: LD_VAR 0 3
47822: ARRAY
47823: IN
47824: OR
47825: PUSH
47826: LD_VAR 0 1
47830: PUSH
47831: LD_EXP 117
47835: PUSH
47836: LD_VAR 0 3
47840: ARRAY
47841: IN
47842: OR
47843: PUSH
47844: LD_VAR 0 1
47848: PUSH
47849: LD_EXP 118
47853: PUSH
47854: LD_VAR 0 3
47858: ARRAY
47859: IN
47860: OR
47861: IFFALSE 49104
// begin if un in mc_ape [ i ] then
47863: LD_VAR 0 1
47867: PUSH
47868: LD_EXP 117
47872: PUSH
47873: LD_VAR 0 3
47877: ARRAY
47878: IN
47879: IFFALSE 47918
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47881: LD_ADDR_EXP 117
47885: PUSH
47886: LD_EXP 117
47890: PPUSH
47891: LD_VAR 0 3
47895: PPUSH
47896: LD_EXP 117
47900: PUSH
47901: LD_VAR 0 3
47905: ARRAY
47906: PUSH
47907: LD_VAR 0 1
47911: DIFF
47912: PPUSH
47913: CALL_OW 1
47917: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47918: LD_VAR 0 1
47922: PUSH
47923: LD_EXP 118
47927: PUSH
47928: LD_VAR 0 3
47932: ARRAY
47933: IN
47934: IFFALSE 47958
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47936: LD_ADDR_EXP 118
47940: PUSH
47941: LD_EXP 118
47945: PPUSH
47946: LD_VAR 0 3
47950: PPUSH
47951: EMPTY
47952: PPUSH
47953: CALL_OW 1
47957: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47958: LD_VAR 0 1
47962: PPUSH
47963: CALL_OW 247
47967: PUSH
47968: LD_INT 2
47970: EQUAL
47971: PUSH
47972: LD_VAR 0 1
47976: PPUSH
47977: CALL_OW 110
47981: PUSH
47982: LD_INT 20
47984: EQUAL
47985: PUSH
47986: LD_VAR 0 1
47990: PUSH
47991: LD_EXP 110
47995: PUSH
47996: LD_VAR 0 3
48000: ARRAY
48001: IN
48002: OR
48003: PUSH
48004: LD_VAR 0 1
48008: PPUSH
48009: CALL_OW 264
48013: PUSH
48014: LD_INT 12
48016: PUSH
48017: LD_INT 51
48019: PUSH
48020: LD_EXP 73
48024: PUSH
48025: LD_INT 32
48027: PUSH
48028: LD_INT 13
48030: PUSH
48031: LD_INT 52
48033: PUSH
48034: LD_INT 31
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: LIST
48041: LIST
48042: LIST
48043: LIST
48044: LIST
48045: IN
48046: OR
48047: AND
48048: IFFALSE 48356
// begin if un in mc_defender [ i ] then
48050: LD_VAR 0 1
48054: PUSH
48055: LD_EXP 110
48059: PUSH
48060: LD_VAR 0 3
48064: ARRAY
48065: IN
48066: IFFALSE 48105
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48068: LD_ADDR_EXP 110
48072: PUSH
48073: LD_EXP 110
48077: PPUSH
48078: LD_VAR 0 3
48082: PPUSH
48083: LD_EXP 110
48087: PUSH
48088: LD_VAR 0 3
48092: ARRAY
48093: PUSH
48094: LD_VAR 0 1
48098: DIFF
48099: PPUSH
48100: CALL_OW 1
48104: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48105: LD_ADDR_VAR 0 8
48109: PUSH
48110: LD_VAR 0 3
48114: PPUSH
48115: LD_INT 3
48117: PPUSH
48118: CALL 44774 0 2
48122: ST_TO_ADDR
// if fac then
48123: LD_VAR 0 8
48127: IFFALSE 48356
// begin for j in fac do
48129: LD_ADDR_VAR 0 4
48133: PUSH
48134: LD_VAR 0 8
48138: PUSH
48139: FOR_IN
48140: IFFALSE 48354
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48142: LD_ADDR_VAR 0 9
48146: PUSH
48147: LD_VAR 0 8
48151: PPUSH
48152: LD_VAR 0 1
48156: PPUSH
48157: CALL_OW 265
48161: PPUSH
48162: LD_VAR 0 1
48166: PPUSH
48167: CALL_OW 262
48171: PPUSH
48172: LD_VAR 0 1
48176: PPUSH
48177: CALL_OW 263
48181: PPUSH
48182: LD_VAR 0 1
48186: PPUSH
48187: CALL_OW 264
48191: PPUSH
48192: CALL 53141 0 5
48196: ST_TO_ADDR
// if components then
48197: LD_VAR 0 9
48201: IFFALSE 48352
// begin if GetWeapon ( un ) = ar_control_tower then
48203: LD_VAR 0 1
48207: PPUSH
48208: CALL_OW 264
48212: PUSH
48213: LD_INT 31
48215: EQUAL
48216: IFFALSE 48333
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48218: LD_VAR 0 1
48222: PPUSH
48223: CALL_OW 311
48227: PPUSH
48228: LD_INT 0
48230: PPUSH
48231: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48235: LD_ADDR_EXP 128
48239: PUSH
48240: LD_EXP 128
48244: PPUSH
48245: LD_VAR 0 3
48249: PPUSH
48250: LD_EXP 128
48254: PUSH
48255: LD_VAR 0 3
48259: ARRAY
48260: PUSH
48261: LD_VAR 0 1
48265: PPUSH
48266: CALL_OW 311
48270: DIFF
48271: PPUSH
48272: CALL_OW 1
48276: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48277: LD_ADDR_VAR 0 7
48281: PUSH
48282: LD_EXP 109
48286: PUSH
48287: LD_VAR 0 3
48291: ARRAY
48292: PPUSH
48293: LD_INT 1
48295: PPUSH
48296: LD_VAR 0 9
48300: PPUSH
48301: CALL_OW 2
48305: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48306: LD_ADDR_EXP 109
48310: PUSH
48311: LD_EXP 109
48315: PPUSH
48316: LD_VAR 0 3
48320: PPUSH
48321: LD_VAR 0 7
48325: PPUSH
48326: CALL_OW 1
48330: ST_TO_ADDR
// end else
48331: GO 48350
// MC_InsertProduceList ( i , [ components ] ) ;
48333: LD_VAR 0 3
48337: PPUSH
48338: LD_VAR 0 9
48342: PUSH
48343: EMPTY
48344: LIST
48345: PPUSH
48346: CALL 44319 0 2
// break ;
48350: GO 48354
// end ; end ;
48352: GO 48139
48354: POP
48355: POP
// end ; end ; if GetType ( un ) = unit_building then
48356: LD_VAR 0 1
48360: PPUSH
48361: CALL_OW 247
48365: PUSH
48366: LD_INT 3
48368: EQUAL
48369: IFFALSE 48772
// begin btype := GetBType ( un ) ;
48371: LD_ADDR_VAR 0 5
48375: PUSH
48376: LD_VAR 0 1
48380: PPUSH
48381: CALL_OW 266
48385: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48386: LD_VAR 0 5
48390: PUSH
48391: LD_INT 29
48393: PUSH
48394: LD_INT 30
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: IN
48401: IFFALSE 48474
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48403: LD_VAR 0 1
48407: PPUSH
48408: CALL_OW 250
48412: PPUSH
48413: LD_VAR 0 1
48417: PPUSH
48418: CALL_OW 251
48422: PPUSH
48423: LD_VAR 0 1
48427: PPUSH
48428: CALL_OW 255
48432: PPUSH
48433: CALL_OW 440
48437: NOT
48438: IFFALSE 48474
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48440: LD_VAR 0 1
48444: PPUSH
48445: CALL_OW 250
48449: PPUSH
48450: LD_VAR 0 1
48454: PPUSH
48455: CALL_OW 251
48459: PPUSH
48460: LD_VAR 0 1
48464: PPUSH
48465: CALL_OW 255
48469: PPUSH
48470: CALL_OW 441
// end ; if btype = b_warehouse then
48474: LD_VAR 0 5
48478: PUSH
48479: LD_INT 1
48481: EQUAL
48482: IFFALSE 48500
// begin btype := b_depot ;
48484: LD_ADDR_VAR 0 5
48488: PUSH
48489: LD_INT 0
48491: ST_TO_ADDR
// pos := 1 ;
48492: LD_ADDR_VAR 0 6
48496: PUSH
48497: LD_INT 1
48499: ST_TO_ADDR
// end ; if btype = b_factory then
48500: LD_VAR 0 5
48504: PUSH
48505: LD_INT 3
48507: EQUAL
48508: IFFALSE 48526
// begin btype := b_workshop ;
48510: LD_ADDR_VAR 0 5
48514: PUSH
48515: LD_INT 2
48517: ST_TO_ADDR
// pos := 1 ;
48518: LD_ADDR_VAR 0 6
48522: PUSH
48523: LD_INT 1
48525: ST_TO_ADDR
// end ; if btype = b_barracks then
48526: LD_VAR 0 5
48530: PUSH
48531: LD_INT 5
48533: EQUAL
48534: IFFALSE 48544
// btype := b_armoury ;
48536: LD_ADDR_VAR 0 5
48540: PUSH
48541: LD_INT 4
48543: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48544: LD_VAR 0 5
48548: PUSH
48549: LD_INT 7
48551: PUSH
48552: LD_INT 8
48554: PUSH
48555: EMPTY
48556: LIST
48557: LIST
48558: IN
48559: IFFALSE 48569
// btype := b_lab ;
48561: LD_ADDR_VAR 0 5
48565: PUSH
48566: LD_INT 6
48568: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48569: LD_ADDR_EXP 93
48573: PUSH
48574: LD_EXP 93
48578: PPUSH
48579: LD_VAR 0 3
48583: PUSH
48584: LD_EXP 93
48588: PUSH
48589: LD_VAR 0 3
48593: ARRAY
48594: PUSH
48595: LD_INT 1
48597: PLUS
48598: PUSH
48599: EMPTY
48600: LIST
48601: LIST
48602: PPUSH
48603: LD_VAR 0 5
48607: PUSH
48608: LD_VAR 0 1
48612: PPUSH
48613: CALL_OW 250
48617: PUSH
48618: LD_VAR 0 1
48622: PPUSH
48623: CALL_OW 251
48627: PUSH
48628: LD_VAR 0 1
48632: PPUSH
48633: CALL_OW 254
48637: PUSH
48638: EMPTY
48639: LIST
48640: LIST
48641: LIST
48642: LIST
48643: PPUSH
48644: CALL 55609 0 3
48648: ST_TO_ADDR
// if pos = 1 then
48649: LD_VAR 0 6
48653: PUSH
48654: LD_INT 1
48656: EQUAL
48657: IFFALSE 48772
// begin tmp := mc_build_list [ i ] ;
48659: LD_ADDR_VAR 0 7
48663: PUSH
48664: LD_EXP 93
48668: PUSH
48669: LD_VAR 0 3
48673: ARRAY
48674: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48675: LD_VAR 0 7
48679: PPUSH
48680: LD_INT 2
48682: PUSH
48683: LD_INT 30
48685: PUSH
48686: LD_INT 0
48688: PUSH
48689: EMPTY
48690: LIST
48691: LIST
48692: PUSH
48693: LD_INT 30
48695: PUSH
48696: LD_INT 1
48698: PUSH
48699: EMPTY
48700: LIST
48701: LIST
48702: PUSH
48703: EMPTY
48704: LIST
48705: LIST
48706: LIST
48707: PPUSH
48708: CALL_OW 72
48712: IFFALSE 48722
// pos := 2 ;
48714: LD_ADDR_VAR 0 6
48718: PUSH
48719: LD_INT 2
48721: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48722: LD_ADDR_VAR 0 7
48726: PUSH
48727: LD_VAR 0 7
48731: PPUSH
48732: LD_VAR 0 6
48736: PPUSH
48737: LD_VAR 0 7
48741: PPUSH
48742: CALL 55935 0 3
48746: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48747: LD_ADDR_EXP 93
48751: PUSH
48752: LD_EXP 93
48756: PPUSH
48757: LD_VAR 0 3
48761: PPUSH
48762: LD_VAR 0 7
48766: PPUSH
48767: CALL_OW 1
48771: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48772: LD_VAR 0 1
48776: PUSH
48777: LD_EXP 88
48781: PUSH
48782: LD_VAR 0 3
48786: ARRAY
48787: IN
48788: IFFALSE 48827
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48790: LD_ADDR_EXP 88
48794: PUSH
48795: LD_EXP 88
48799: PPUSH
48800: LD_VAR 0 3
48804: PPUSH
48805: LD_EXP 88
48809: PUSH
48810: LD_VAR 0 3
48814: ARRAY
48815: PUSH
48816: LD_VAR 0 1
48820: DIFF
48821: PPUSH
48822: CALL_OW 1
48826: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48827: LD_VAR 0 1
48831: PUSH
48832: LD_EXP 95
48836: PUSH
48837: LD_VAR 0 3
48841: ARRAY
48842: IN
48843: IFFALSE 48882
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48845: LD_ADDR_EXP 95
48849: PUSH
48850: LD_EXP 95
48854: PPUSH
48855: LD_VAR 0 3
48859: PPUSH
48860: LD_EXP 95
48864: PUSH
48865: LD_VAR 0 3
48869: ARRAY
48870: PUSH
48871: LD_VAR 0 1
48875: DIFF
48876: PPUSH
48877: CALL_OW 1
48881: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48882: LD_VAR 0 1
48886: PUSH
48887: LD_EXP 107
48891: PUSH
48892: LD_VAR 0 3
48896: ARRAY
48897: IN
48898: IFFALSE 48937
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48900: LD_ADDR_EXP 107
48904: PUSH
48905: LD_EXP 107
48909: PPUSH
48910: LD_VAR 0 3
48914: PPUSH
48915: LD_EXP 107
48919: PUSH
48920: LD_VAR 0 3
48924: ARRAY
48925: PUSH
48926: LD_VAR 0 1
48930: DIFF
48931: PPUSH
48932: CALL_OW 1
48936: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48937: LD_VAR 0 1
48941: PUSH
48942: LD_EXP 110
48946: PUSH
48947: LD_VAR 0 3
48951: ARRAY
48952: IN
48953: IFFALSE 48992
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48955: LD_ADDR_EXP 110
48959: PUSH
48960: LD_EXP 110
48964: PPUSH
48965: LD_VAR 0 3
48969: PPUSH
48970: LD_EXP 110
48974: PUSH
48975: LD_VAR 0 3
48979: ARRAY
48980: PUSH
48981: LD_VAR 0 1
48985: DIFF
48986: PPUSH
48987: CALL_OW 1
48991: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48992: LD_VAR 0 1
48996: PUSH
48997: LD_EXP 97
49001: PUSH
49002: LD_VAR 0 3
49006: ARRAY
49007: IN
49008: IFFALSE 49047
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49010: LD_ADDR_EXP 97
49014: PUSH
49015: LD_EXP 97
49019: PPUSH
49020: LD_VAR 0 3
49024: PPUSH
49025: LD_EXP 97
49029: PUSH
49030: LD_VAR 0 3
49034: ARRAY
49035: PUSH
49036: LD_VAR 0 1
49040: DIFF
49041: PPUSH
49042: CALL_OW 1
49046: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49047: LD_VAR 0 1
49051: PUSH
49052: LD_EXP 96
49056: PUSH
49057: LD_VAR 0 3
49061: ARRAY
49062: IN
49063: IFFALSE 49102
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49065: LD_ADDR_EXP 96
49069: PUSH
49070: LD_EXP 96
49074: PPUSH
49075: LD_VAR 0 3
49079: PPUSH
49080: LD_EXP 96
49084: PUSH
49085: LD_VAR 0 3
49089: ARRAY
49090: PUSH
49091: LD_VAR 0 1
49095: DIFF
49096: PPUSH
49097: CALL_OW 1
49101: ST_TO_ADDR
// end ; break ;
49102: GO 49106
// end ;
49104: GO 47752
49106: POP
49107: POP
// end ;
49108: LD_VAR 0 2
49112: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49113: LD_INT 0
49115: PPUSH
49116: PPUSH
49117: PPUSH
// if not mc_bases or not skirmish then
49118: LD_EXP 88
49122: NOT
49123: PUSH
49124: LD_EXP 86
49128: NOT
49129: OR
49130: IFFALSE 49134
// exit ;
49132: GO 49349
// for i = 1 to mc_bases do
49134: LD_ADDR_VAR 0 3
49138: PUSH
49139: DOUBLE
49140: LD_INT 1
49142: DEC
49143: ST_TO_ADDR
49144: LD_EXP 88
49148: PUSH
49149: FOR_TO
49150: IFFALSE 49347
// begin if building in mc_construct_list [ i ] then
49152: LD_VAR 0 1
49156: PUSH
49157: LD_EXP 95
49161: PUSH
49162: LD_VAR 0 3
49166: ARRAY
49167: IN
49168: IFFALSE 49345
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49170: LD_ADDR_EXP 95
49174: PUSH
49175: LD_EXP 95
49179: PPUSH
49180: LD_VAR 0 3
49184: PPUSH
49185: LD_EXP 95
49189: PUSH
49190: LD_VAR 0 3
49194: ARRAY
49195: PUSH
49196: LD_VAR 0 1
49200: DIFF
49201: PPUSH
49202: CALL_OW 1
49206: ST_TO_ADDR
// if building in mc_lab [ i ] then
49207: LD_VAR 0 1
49211: PUSH
49212: LD_EXP 121
49216: PUSH
49217: LD_VAR 0 3
49221: ARRAY
49222: IN
49223: IFFALSE 49278
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49225: LD_ADDR_EXP 122
49229: PUSH
49230: LD_EXP 122
49234: PPUSH
49235: LD_VAR 0 3
49239: PPUSH
49240: LD_EXP 122
49244: PUSH
49245: LD_VAR 0 3
49249: ARRAY
49250: PPUSH
49251: LD_INT 1
49253: PPUSH
49254: LD_EXP 122
49258: PUSH
49259: LD_VAR 0 3
49263: ARRAY
49264: PPUSH
49265: LD_INT 0
49267: PPUSH
49268: CALL 55027 0 4
49272: PPUSH
49273: CALL_OW 1
49277: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49278: LD_VAR 0 1
49282: PUSH
49283: LD_EXP 88
49287: PUSH
49288: LD_VAR 0 3
49292: ARRAY
49293: IN
49294: NOT
49295: IFFALSE 49341
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49297: LD_ADDR_EXP 88
49301: PUSH
49302: LD_EXP 88
49306: PPUSH
49307: LD_VAR 0 3
49311: PUSH
49312: LD_EXP 88
49316: PUSH
49317: LD_VAR 0 3
49321: ARRAY
49322: PUSH
49323: LD_INT 1
49325: PLUS
49326: PUSH
49327: EMPTY
49328: LIST
49329: LIST
49330: PPUSH
49331: LD_VAR 0 1
49335: PPUSH
49336: CALL 55609 0 3
49340: ST_TO_ADDR
// exit ;
49341: POP
49342: POP
49343: GO 49349
// end ; end ;
49345: GO 49149
49347: POP
49348: POP
// end ;
49349: LD_VAR 0 2
49353: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49354: LD_INT 0
49356: PPUSH
49357: PPUSH
49358: PPUSH
49359: PPUSH
49360: PPUSH
49361: PPUSH
49362: PPUSH
// if not mc_bases or not skirmish then
49363: LD_EXP 88
49367: NOT
49368: PUSH
49369: LD_EXP 86
49373: NOT
49374: OR
49375: IFFALSE 49379
// exit ;
49377: GO 50040
// for i = 1 to mc_bases do
49379: LD_ADDR_VAR 0 3
49383: PUSH
49384: DOUBLE
49385: LD_INT 1
49387: DEC
49388: ST_TO_ADDR
49389: LD_EXP 88
49393: PUSH
49394: FOR_TO
49395: IFFALSE 50038
// begin if building in mc_construct_list [ i ] then
49397: LD_VAR 0 1
49401: PUSH
49402: LD_EXP 95
49406: PUSH
49407: LD_VAR 0 3
49411: ARRAY
49412: IN
49413: IFFALSE 50036
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49415: LD_ADDR_EXP 95
49419: PUSH
49420: LD_EXP 95
49424: PPUSH
49425: LD_VAR 0 3
49429: PPUSH
49430: LD_EXP 95
49434: PUSH
49435: LD_VAR 0 3
49439: ARRAY
49440: PUSH
49441: LD_VAR 0 1
49445: DIFF
49446: PPUSH
49447: CALL_OW 1
49451: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49452: LD_ADDR_EXP 88
49456: PUSH
49457: LD_EXP 88
49461: PPUSH
49462: LD_VAR 0 3
49466: PUSH
49467: LD_EXP 88
49471: PUSH
49472: LD_VAR 0 3
49476: ARRAY
49477: PUSH
49478: LD_INT 1
49480: PLUS
49481: PUSH
49482: EMPTY
49483: LIST
49484: LIST
49485: PPUSH
49486: LD_VAR 0 1
49490: PPUSH
49491: CALL 55609 0 3
49495: ST_TO_ADDR
// btype := GetBType ( building ) ;
49496: LD_ADDR_VAR 0 5
49500: PUSH
49501: LD_VAR 0 1
49505: PPUSH
49506: CALL_OW 266
49510: ST_TO_ADDR
// side := GetSide ( building ) ;
49511: LD_ADDR_VAR 0 8
49515: PUSH
49516: LD_VAR 0 1
49520: PPUSH
49521: CALL_OW 255
49525: ST_TO_ADDR
// if btype = b_lab then
49526: LD_VAR 0 5
49530: PUSH
49531: LD_INT 6
49533: EQUAL
49534: IFFALSE 49584
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49536: LD_ADDR_EXP 121
49540: PUSH
49541: LD_EXP 121
49545: PPUSH
49546: LD_VAR 0 3
49550: PUSH
49551: LD_EXP 121
49555: PUSH
49556: LD_VAR 0 3
49560: ARRAY
49561: PUSH
49562: LD_INT 1
49564: PLUS
49565: PUSH
49566: EMPTY
49567: LIST
49568: LIST
49569: PPUSH
49570: LD_VAR 0 1
49574: PPUSH
49575: CALL 55609 0 3
49579: ST_TO_ADDR
// exit ;
49580: POP
49581: POP
49582: GO 50040
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49584: LD_VAR 0 5
49588: PUSH
49589: LD_INT 0
49591: PUSH
49592: LD_INT 2
49594: PUSH
49595: LD_INT 4
49597: PUSH
49598: EMPTY
49599: LIST
49600: LIST
49601: LIST
49602: IN
49603: IFFALSE 49727
// begin if btype = b_armoury then
49605: LD_VAR 0 5
49609: PUSH
49610: LD_INT 4
49612: EQUAL
49613: IFFALSE 49623
// btype := b_barracks ;
49615: LD_ADDR_VAR 0 5
49619: PUSH
49620: LD_INT 5
49622: ST_TO_ADDR
// if btype = b_depot then
49623: LD_VAR 0 5
49627: PUSH
49628: LD_INT 0
49630: EQUAL
49631: IFFALSE 49641
// btype := b_warehouse ;
49633: LD_ADDR_VAR 0 5
49637: PUSH
49638: LD_INT 1
49640: ST_TO_ADDR
// if btype = b_workshop then
49641: LD_VAR 0 5
49645: PUSH
49646: LD_INT 2
49648: EQUAL
49649: IFFALSE 49659
// btype := b_factory ;
49651: LD_ADDR_VAR 0 5
49655: PUSH
49656: LD_INT 3
49658: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49659: LD_VAR 0 5
49663: PPUSH
49664: LD_VAR 0 8
49668: PPUSH
49669: CALL_OW 323
49673: PUSH
49674: LD_INT 1
49676: EQUAL
49677: IFFALSE 49723
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49679: LD_ADDR_EXP 120
49683: PUSH
49684: LD_EXP 120
49688: PPUSH
49689: LD_VAR 0 3
49693: PUSH
49694: LD_EXP 120
49698: PUSH
49699: LD_VAR 0 3
49703: ARRAY
49704: PUSH
49705: LD_INT 1
49707: PLUS
49708: PUSH
49709: EMPTY
49710: LIST
49711: LIST
49712: PPUSH
49713: LD_VAR 0 1
49717: PPUSH
49718: CALL 55609 0 3
49722: ST_TO_ADDR
// exit ;
49723: POP
49724: POP
49725: GO 50040
// end ; if btype in [ b_bunker , b_turret ] then
49727: LD_VAR 0 5
49731: PUSH
49732: LD_INT 32
49734: PUSH
49735: LD_INT 33
49737: PUSH
49738: EMPTY
49739: LIST
49740: LIST
49741: IN
49742: IFFALSE 50032
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49744: LD_ADDR_EXP 96
49748: PUSH
49749: LD_EXP 96
49753: PPUSH
49754: LD_VAR 0 3
49758: PUSH
49759: LD_EXP 96
49763: PUSH
49764: LD_VAR 0 3
49768: ARRAY
49769: PUSH
49770: LD_INT 1
49772: PLUS
49773: PUSH
49774: EMPTY
49775: LIST
49776: LIST
49777: PPUSH
49778: LD_VAR 0 1
49782: PPUSH
49783: CALL 55609 0 3
49787: ST_TO_ADDR
// if btype = b_bunker then
49788: LD_VAR 0 5
49792: PUSH
49793: LD_INT 32
49795: EQUAL
49796: IFFALSE 50032
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49798: LD_ADDR_EXP 97
49802: PUSH
49803: LD_EXP 97
49807: PPUSH
49808: LD_VAR 0 3
49812: PUSH
49813: LD_EXP 97
49817: PUSH
49818: LD_VAR 0 3
49822: ARRAY
49823: PUSH
49824: LD_INT 1
49826: PLUS
49827: PUSH
49828: EMPTY
49829: LIST
49830: LIST
49831: PPUSH
49832: LD_VAR 0 1
49836: PPUSH
49837: CALL 55609 0 3
49841: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49842: LD_ADDR_VAR 0 6
49846: PUSH
49847: LD_EXP 88
49851: PUSH
49852: LD_VAR 0 3
49856: ARRAY
49857: PPUSH
49858: LD_INT 25
49860: PUSH
49861: LD_INT 1
49863: PUSH
49864: EMPTY
49865: LIST
49866: LIST
49867: PUSH
49868: LD_INT 3
49870: PUSH
49871: LD_INT 54
49873: PUSH
49874: EMPTY
49875: LIST
49876: PUSH
49877: EMPTY
49878: LIST
49879: LIST
49880: PUSH
49881: EMPTY
49882: LIST
49883: LIST
49884: PPUSH
49885: CALL_OW 72
49889: ST_TO_ADDR
// if tmp then
49890: LD_VAR 0 6
49894: IFFALSE 49900
// exit ;
49896: POP
49897: POP
49898: GO 50040
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49900: LD_ADDR_VAR 0 6
49904: PUSH
49905: LD_EXP 88
49909: PUSH
49910: LD_VAR 0 3
49914: ARRAY
49915: PPUSH
49916: LD_INT 2
49918: PUSH
49919: LD_INT 30
49921: PUSH
49922: LD_INT 4
49924: PUSH
49925: EMPTY
49926: LIST
49927: LIST
49928: PUSH
49929: LD_INT 30
49931: PUSH
49932: LD_INT 5
49934: PUSH
49935: EMPTY
49936: LIST
49937: LIST
49938: PUSH
49939: EMPTY
49940: LIST
49941: LIST
49942: LIST
49943: PPUSH
49944: CALL_OW 72
49948: ST_TO_ADDR
// if not tmp then
49949: LD_VAR 0 6
49953: NOT
49954: IFFALSE 49960
// exit ;
49956: POP
49957: POP
49958: GO 50040
// for j in tmp do
49960: LD_ADDR_VAR 0 4
49964: PUSH
49965: LD_VAR 0 6
49969: PUSH
49970: FOR_IN
49971: IFFALSE 50030
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49973: LD_ADDR_VAR 0 7
49977: PUSH
49978: LD_VAR 0 4
49982: PPUSH
49983: CALL_OW 313
49987: PPUSH
49988: LD_INT 25
49990: PUSH
49991: LD_INT 1
49993: PUSH
49994: EMPTY
49995: LIST
49996: LIST
49997: PPUSH
49998: CALL_OW 72
50002: ST_TO_ADDR
// if units then
50003: LD_VAR 0 7
50007: IFFALSE 50028
// begin ComExitBuilding ( units [ 1 ] ) ;
50009: LD_VAR 0 7
50013: PUSH
50014: LD_INT 1
50016: ARRAY
50017: PPUSH
50018: CALL_OW 122
// exit ;
50022: POP
50023: POP
50024: POP
50025: POP
50026: GO 50040
// end ; end ;
50028: GO 49970
50030: POP
50031: POP
// end ; end ; exit ;
50032: POP
50033: POP
50034: GO 50040
// end ; end ;
50036: GO 49394
50038: POP
50039: POP
// end ;
50040: LD_VAR 0 2
50044: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50045: LD_INT 0
50047: PPUSH
50048: PPUSH
50049: PPUSH
50050: PPUSH
50051: PPUSH
50052: PPUSH
50053: PPUSH
// if not mc_bases or not skirmish then
50054: LD_EXP 88
50058: NOT
50059: PUSH
50060: LD_EXP 86
50064: NOT
50065: OR
50066: IFFALSE 50070
// exit ;
50068: GO 50301
// btype := GetBType ( building ) ;
50070: LD_ADDR_VAR 0 6
50074: PUSH
50075: LD_VAR 0 1
50079: PPUSH
50080: CALL_OW 266
50084: ST_TO_ADDR
// x := GetX ( building ) ;
50085: LD_ADDR_VAR 0 7
50089: PUSH
50090: LD_VAR 0 1
50094: PPUSH
50095: CALL_OW 250
50099: ST_TO_ADDR
// y := GetY ( building ) ;
50100: LD_ADDR_VAR 0 8
50104: PUSH
50105: LD_VAR 0 1
50109: PPUSH
50110: CALL_OW 251
50114: ST_TO_ADDR
// d := GetDir ( building ) ;
50115: LD_ADDR_VAR 0 9
50119: PUSH
50120: LD_VAR 0 1
50124: PPUSH
50125: CALL_OW 254
50129: ST_TO_ADDR
// for i = 1 to mc_bases do
50130: LD_ADDR_VAR 0 4
50134: PUSH
50135: DOUBLE
50136: LD_INT 1
50138: DEC
50139: ST_TO_ADDR
50140: LD_EXP 88
50144: PUSH
50145: FOR_TO
50146: IFFALSE 50299
// begin if not mc_build_list [ i ] then
50148: LD_EXP 93
50152: PUSH
50153: LD_VAR 0 4
50157: ARRAY
50158: NOT
50159: IFFALSE 50163
// continue ;
50161: GO 50145
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50163: LD_VAR 0 6
50167: PUSH
50168: LD_VAR 0 7
50172: PUSH
50173: LD_VAR 0 8
50177: PUSH
50178: LD_VAR 0 9
50182: PUSH
50183: EMPTY
50184: LIST
50185: LIST
50186: LIST
50187: LIST
50188: PPUSH
50189: LD_EXP 93
50193: PUSH
50194: LD_VAR 0 4
50198: ARRAY
50199: PUSH
50200: LD_INT 1
50202: ARRAY
50203: PPUSH
50204: CALL 61778 0 2
50208: IFFALSE 50297
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50210: LD_ADDR_EXP 93
50214: PUSH
50215: LD_EXP 93
50219: PPUSH
50220: LD_VAR 0 4
50224: PPUSH
50225: LD_EXP 93
50229: PUSH
50230: LD_VAR 0 4
50234: ARRAY
50235: PPUSH
50236: LD_INT 1
50238: PPUSH
50239: CALL_OW 3
50243: PPUSH
50244: CALL_OW 1
50248: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50249: LD_ADDR_EXP 95
50253: PUSH
50254: LD_EXP 95
50258: PPUSH
50259: LD_VAR 0 4
50263: PUSH
50264: LD_EXP 95
50268: PUSH
50269: LD_VAR 0 4
50273: ARRAY
50274: PUSH
50275: LD_INT 1
50277: PLUS
50278: PUSH
50279: EMPTY
50280: LIST
50281: LIST
50282: PPUSH
50283: LD_VAR 0 1
50287: PPUSH
50288: CALL 55609 0 3
50292: ST_TO_ADDR
// exit ;
50293: POP
50294: POP
50295: GO 50301
// end ; end ;
50297: GO 50145
50299: POP
50300: POP
// end ;
50301: LD_VAR 0 3
50305: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50306: LD_INT 0
50308: PPUSH
50309: PPUSH
50310: PPUSH
// if not mc_bases or not skirmish then
50311: LD_EXP 88
50315: NOT
50316: PUSH
50317: LD_EXP 86
50321: NOT
50322: OR
50323: IFFALSE 50327
// exit ;
50325: GO 50517
// for i = 1 to mc_bases do
50327: LD_ADDR_VAR 0 4
50331: PUSH
50332: DOUBLE
50333: LD_INT 1
50335: DEC
50336: ST_TO_ADDR
50337: LD_EXP 88
50341: PUSH
50342: FOR_TO
50343: IFFALSE 50430
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50345: LD_VAR 0 1
50349: PUSH
50350: LD_EXP 96
50354: PUSH
50355: LD_VAR 0 4
50359: ARRAY
50360: IN
50361: PUSH
50362: LD_VAR 0 1
50366: PUSH
50367: LD_EXP 97
50371: PUSH
50372: LD_VAR 0 4
50376: ARRAY
50377: IN
50378: NOT
50379: AND
50380: IFFALSE 50428
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50382: LD_ADDR_EXP 97
50386: PUSH
50387: LD_EXP 97
50391: PPUSH
50392: LD_VAR 0 4
50396: PUSH
50397: LD_EXP 97
50401: PUSH
50402: LD_VAR 0 4
50406: ARRAY
50407: PUSH
50408: LD_INT 1
50410: PLUS
50411: PUSH
50412: EMPTY
50413: LIST
50414: LIST
50415: PPUSH
50416: LD_VAR 0 1
50420: PPUSH
50421: CALL 55609 0 3
50425: ST_TO_ADDR
// break ;
50426: GO 50430
// end ; end ;
50428: GO 50342
50430: POP
50431: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50432: LD_VAR 0 1
50436: PPUSH
50437: CALL_OW 257
50441: PUSH
50442: LD_EXP 114
50446: IN
50447: PUSH
50448: LD_VAR 0 1
50452: PPUSH
50453: CALL_OW 266
50457: PUSH
50458: LD_INT 5
50460: EQUAL
50461: AND
50462: PUSH
50463: LD_VAR 0 2
50467: PPUSH
50468: CALL_OW 110
50472: PUSH
50473: LD_INT 18
50475: NONEQUAL
50476: AND
50477: IFFALSE 50517
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50479: LD_VAR 0 2
50483: PPUSH
50484: CALL_OW 257
50488: PUSH
50489: LD_INT 5
50491: PUSH
50492: LD_INT 8
50494: PUSH
50495: LD_INT 9
50497: PUSH
50498: EMPTY
50499: LIST
50500: LIST
50501: LIST
50502: IN
50503: IFFALSE 50517
// SetClass ( unit , 1 ) ;
50505: LD_VAR 0 2
50509: PPUSH
50510: LD_INT 1
50512: PPUSH
50513: CALL_OW 336
// end ;
50517: LD_VAR 0 3
50521: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50522: LD_INT 0
50524: PPUSH
50525: PPUSH
// if not mc_bases or not skirmish then
50526: LD_EXP 88
50530: NOT
50531: PUSH
50532: LD_EXP 86
50536: NOT
50537: OR
50538: IFFALSE 50542
// exit ;
50540: GO 50658
// if GetLives ( abandoned_vehicle ) > 250 then
50542: LD_VAR 0 2
50546: PPUSH
50547: CALL_OW 256
50551: PUSH
50552: LD_INT 250
50554: GREATER
50555: IFFALSE 50559
// exit ;
50557: GO 50658
// for i = 1 to mc_bases do
50559: LD_ADDR_VAR 0 6
50563: PUSH
50564: DOUBLE
50565: LD_INT 1
50567: DEC
50568: ST_TO_ADDR
50569: LD_EXP 88
50573: PUSH
50574: FOR_TO
50575: IFFALSE 50656
// begin if driver in mc_bases [ i ] then
50577: LD_VAR 0 1
50581: PUSH
50582: LD_EXP 88
50586: PUSH
50587: LD_VAR 0 6
50591: ARRAY
50592: IN
50593: IFFALSE 50654
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50595: LD_VAR 0 1
50599: PPUSH
50600: LD_EXP 88
50604: PUSH
50605: LD_VAR 0 6
50609: ARRAY
50610: PPUSH
50611: LD_INT 2
50613: PUSH
50614: LD_INT 30
50616: PUSH
50617: LD_INT 0
50619: PUSH
50620: EMPTY
50621: LIST
50622: LIST
50623: PUSH
50624: LD_INT 30
50626: PUSH
50627: LD_INT 1
50629: PUSH
50630: EMPTY
50631: LIST
50632: LIST
50633: PUSH
50634: EMPTY
50635: LIST
50636: LIST
50637: LIST
50638: PPUSH
50639: CALL_OW 72
50643: PUSH
50644: LD_INT 1
50646: ARRAY
50647: PPUSH
50648: CALL_OW 112
// break ;
50652: GO 50656
// end ; end ;
50654: GO 50574
50656: POP
50657: POP
// end ; end_of_file
50658: LD_VAR 0 5
50662: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50663: LD_INT 0
50665: PPUSH
50666: PPUSH
// if exist_mode then
50667: LD_VAR 0 2
50671: IFFALSE 50696
// unit := CreateCharacter ( prefix & ident ) else
50673: LD_ADDR_VAR 0 5
50677: PUSH
50678: LD_VAR 0 3
50682: PUSH
50683: LD_VAR 0 1
50687: STR
50688: PPUSH
50689: CALL_OW 34
50693: ST_TO_ADDR
50694: GO 50711
// unit := NewCharacter ( ident ) ;
50696: LD_ADDR_VAR 0 5
50700: PUSH
50701: LD_VAR 0 1
50705: PPUSH
50706: CALL_OW 25
50710: ST_TO_ADDR
// result := unit ;
50711: LD_ADDR_VAR 0 4
50715: PUSH
50716: LD_VAR 0 5
50720: ST_TO_ADDR
// end ;
50721: LD_VAR 0 4
50725: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50726: LD_INT 0
50728: PPUSH
50729: PPUSH
// if not side or not nation then
50730: LD_VAR 0 1
50734: NOT
50735: PUSH
50736: LD_VAR 0 2
50740: NOT
50741: OR
50742: IFFALSE 50746
// exit ;
50744: GO 51510
// case nation of nation_american :
50746: LD_VAR 0 2
50750: PUSH
50751: LD_INT 1
50753: DOUBLE
50754: EQUAL
50755: IFTRUE 50759
50757: GO 50973
50759: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
50760: LD_ADDR_VAR 0 4
50764: PUSH
50765: LD_INT 35
50767: PUSH
50768: LD_INT 45
50770: PUSH
50771: LD_INT 46
50773: PUSH
50774: LD_INT 47
50776: PUSH
50777: LD_INT 82
50779: PUSH
50780: LD_INT 83
50782: PUSH
50783: LD_INT 84
50785: PUSH
50786: LD_INT 85
50788: PUSH
50789: LD_INT 86
50791: PUSH
50792: LD_INT 1
50794: PUSH
50795: LD_INT 2
50797: PUSH
50798: LD_INT 6
50800: PUSH
50801: LD_INT 15
50803: PUSH
50804: LD_INT 16
50806: PUSH
50807: LD_INT 7
50809: PUSH
50810: LD_INT 12
50812: PUSH
50813: LD_INT 13
50815: PUSH
50816: LD_INT 10
50818: PUSH
50819: LD_INT 14
50821: PUSH
50822: LD_INT 20
50824: PUSH
50825: LD_INT 21
50827: PUSH
50828: LD_INT 22
50830: PUSH
50831: LD_INT 25
50833: PUSH
50834: LD_INT 32
50836: PUSH
50837: LD_INT 27
50839: PUSH
50840: LD_INT 36
50842: PUSH
50843: LD_INT 69
50845: PUSH
50846: LD_INT 39
50848: PUSH
50849: LD_INT 34
50851: PUSH
50852: LD_INT 40
50854: PUSH
50855: LD_INT 48
50857: PUSH
50858: LD_INT 49
50860: PUSH
50861: LD_INT 50
50863: PUSH
50864: LD_INT 51
50866: PUSH
50867: LD_INT 52
50869: PUSH
50870: LD_INT 53
50872: PUSH
50873: LD_INT 54
50875: PUSH
50876: LD_INT 55
50878: PUSH
50879: LD_INT 56
50881: PUSH
50882: LD_INT 57
50884: PUSH
50885: LD_INT 58
50887: PUSH
50888: LD_INT 59
50890: PUSH
50891: LD_INT 60
50893: PUSH
50894: LD_INT 61
50896: PUSH
50897: LD_INT 62
50899: PUSH
50900: LD_INT 80
50902: PUSH
50903: LD_INT 82
50905: PUSH
50906: LD_INT 83
50908: PUSH
50909: LD_INT 84
50911: PUSH
50912: LD_INT 85
50914: PUSH
50915: LD_INT 86
50917: PUSH
50918: EMPTY
50919: LIST
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: LIST
50927: LIST
50928: LIST
50929: LIST
50930: LIST
50931: LIST
50932: LIST
50933: LIST
50934: LIST
50935: LIST
50936: LIST
50937: LIST
50938: LIST
50939: LIST
50940: LIST
50941: LIST
50942: LIST
50943: LIST
50944: LIST
50945: LIST
50946: LIST
50947: LIST
50948: LIST
50949: LIST
50950: LIST
50951: LIST
50952: LIST
50953: LIST
50954: LIST
50955: LIST
50956: LIST
50957: LIST
50958: LIST
50959: LIST
50960: LIST
50961: LIST
50962: LIST
50963: LIST
50964: LIST
50965: LIST
50966: LIST
50967: LIST
50968: LIST
50969: LIST
50970: ST_TO_ADDR
50971: GO 51434
50973: LD_INT 2
50975: DOUBLE
50976: EQUAL
50977: IFTRUE 50981
50979: GO 51203
50981: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
50982: LD_ADDR_VAR 0 4
50986: PUSH
50987: LD_INT 35
50989: PUSH
50990: LD_INT 45
50992: PUSH
50993: LD_INT 46
50995: PUSH
50996: LD_INT 47
50998: PUSH
50999: LD_INT 82
51001: PUSH
51002: LD_INT 83
51004: PUSH
51005: LD_INT 84
51007: PUSH
51008: LD_INT 85
51010: PUSH
51011: LD_INT 87
51013: PUSH
51014: LD_INT 70
51016: PUSH
51017: LD_INT 1
51019: PUSH
51020: LD_INT 11
51022: PUSH
51023: LD_INT 3
51025: PUSH
51026: LD_INT 4
51028: PUSH
51029: LD_INT 5
51031: PUSH
51032: LD_INT 6
51034: PUSH
51035: LD_INT 15
51037: PUSH
51038: LD_INT 18
51040: PUSH
51041: LD_INT 7
51043: PUSH
51044: LD_INT 17
51046: PUSH
51047: LD_INT 8
51049: PUSH
51050: LD_INT 20
51052: PUSH
51053: LD_INT 21
51055: PUSH
51056: LD_INT 22
51058: PUSH
51059: LD_INT 72
51061: PUSH
51062: LD_INT 26
51064: PUSH
51065: LD_INT 69
51067: PUSH
51068: LD_INT 39
51070: PUSH
51071: LD_INT 40
51073: PUSH
51074: LD_INT 41
51076: PUSH
51077: LD_INT 42
51079: PUSH
51080: LD_INT 43
51082: PUSH
51083: LD_INT 48
51085: PUSH
51086: LD_INT 49
51088: PUSH
51089: LD_INT 50
51091: PUSH
51092: LD_INT 51
51094: PUSH
51095: LD_INT 52
51097: PUSH
51098: LD_INT 53
51100: PUSH
51101: LD_INT 54
51103: PUSH
51104: LD_INT 55
51106: PUSH
51107: LD_INT 56
51109: PUSH
51110: LD_INT 60
51112: PUSH
51113: LD_INT 61
51115: PUSH
51116: LD_INT 62
51118: PUSH
51119: LD_INT 66
51121: PUSH
51122: LD_INT 67
51124: PUSH
51125: LD_INT 68
51127: PUSH
51128: LD_INT 81
51130: PUSH
51131: LD_INT 82
51133: PUSH
51134: LD_INT 83
51136: PUSH
51137: LD_INT 84
51139: PUSH
51140: LD_INT 85
51142: PUSH
51143: LD_INT 87
51145: PUSH
51146: EMPTY
51147: LIST
51148: LIST
51149: LIST
51150: LIST
51151: LIST
51152: LIST
51153: LIST
51154: LIST
51155: LIST
51156: LIST
51157: LIST
51158: LIST
51159: LIST
51160: LIST
51161: LIST
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: LIST
51172: LIST
51173: LIST
51174: LIST
51175: LIST
51176: LIST
51177: LIST
51178: LIST
51179: LIST
51180: LIST
51181: LIST
51182: LIST
51183: LIST
51184: LIST
51185: LIST
51186: LIST
51187: LIST
51188: LIST
51189: LIST
51190: LIST
51191: LIST
51192: LIST
51193: LIST
51194: LIST
51195: LIST
51196: LIST
51197: LIST
51198: LIST
51199: LIST
51200: ST_TO_ADDR
51201: GO 51434
51203: LD_INT 3
51205: DOUBLE
51206: EQUAL
51207: IFTRUE 51211
51209: GO 51433
51211: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51212: LD_ADDR_VAR 0 4
51216: PUSH
51217: LD_INT 46
51219: PUSH
51220: LD_INT 47
51222: PUSH
51223: LD_INT 1
51225: PUSH
51226: LD_INT 2
51228: PUSH
51229: LD_INT 82
51231: PUSH
51232: LD_INT 83
51234: PUSH
51235: LD_INT 84
51237: PUSH
51238: LD_INT 85
51240: PUSH
51241: LD_INT 86
51243: PUSH
51244: LD_INT 11
51246: PUSH
51247: LD_INT 9
51249: PUSH
51250: LD_INT 20
51252: PUSH
51253: LD_INT 19
51255: PUSH
51256: LD_INT 21
51258: PUSH
51259: LD_INT 24
51261: PUSH
51262: LD_INT 22
51264: PUSH
51265: LD_INT 25
51267: PUSH
51268: LD_INT 28
51270: PUSH
51271: LD_INT 29
51273: PUSH
51274: LD_INT 30
51276: PUSH
51277: LD_INT 31
51279: PUSH
51280: LD_INT 37
51282: PUSH
51283: LD_INT 38
51285: PUSH
51286: LD_INT 32
51288: PUSH
51289: LD_INT 27
51291: PUSH
51292: LD_INT 33
51294: PUSH
51295: LD_INT 69
51297: PUSH
51298: LD_INT 39
51300: PUSH
51301: LD_INT 34
51303: PUSH
51304: LD_INT 40
51306: PUSH
51307: LD_INT 71
51309: PUSH
51310: LD_INT 23
51312: PUSH
51313: LD_INT 44
51315: PUSH
51316: LD_INT 48
51318: PUSH
51319: LD_INT 49
51321: PUSH
51322: LD_INT 50
51324: PUSH
51325: LD_INT 51
51327: PUSH
51328: LD_INT 52
51330: PUSH
51331: LD_INT 53
51333: PUSH
51334: LD_INT 54
51336: PUSH
51337: LD_INT 55
51339: PUSH
51340: LD_INT 56
51342: PUSH
51343: LD_INT 57
51345: PUSH
51346: LD_INT 58
51348: PUSH
51349: LD_INT 59
51351: PUSH
51352: LD_INT 63
51354: PUSH
51355: LD_INT 64
51357: PUSH
51358: LD_INT 65
51360: PUSH
51361: LD_INT 82
51363: PUSH
51364: LD_INT 83
51366: PUSH
51367: LD_INT 84
51369: PUSH
51370: LD_INT 85
51372: PUSH
51373: LD_INT 86
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: LIST
51380: LIST
51381: LIST
51382: LIST
51383: LIST
51384: LIST
51385: LIST
51386: LIST
51387: LIST
51388: LIST
51389: LIST
51390: LIST
51391: LIST
51392: LIST
51393: LIST
51394: LIST
51395: LIST
51396: LIST
51397: LIST
51398: LIST
51399: LIST
51400: LIST
51401: LIST
51402: LIST
51403: LIST
51404: LIST
51405: LIST
51406: LIST
51407: LIST
51408: LIST
51409: LIST
51410: LIST
51411: LIST
51412: LIST
51413: LIST
51414: LIST
51415: LIST
51416: LIST
51417: LIST
51418: LIST
51419: LIST
51420: LIST
51421: LIST
51422: LIST
51423: LIST
51424: LIST
51425: LIST
51426: LIST
51427: LIST
51428: LIST
51429: LIST
51430: ST_TO_ADDR
51431: GO 51434
51433: POP
// if state > - 1 and state < 3 then
51434: LD_VAR 0 3
51438: PUSH
51439: LD_INT 1
51441: NEG
51442: GREATER
51443: PUSH
51444: LD_VAR 0 3
51448: PUSH
51449: LD_INT 3
51451: LESS
51452: AND
51453: IFFALSE 51510
// for i in result do
51455: LD_ADDR_VAR 0 5
51459: PUSH
51460: LD_VAR 0 4
51464: PUSH
51465: FOR_IN
51466: IFFALSE 51508
// if GetTech ( i , side ) <> state then
51468: LD_VAR 0 5
51472: PPUSH
51473: LD_VAR 0 1
51477: PPUSH
51478: CALL_OW 321
51482: PUSH
51483: LD_VAR 0 3
51487: NONEQUAL
51488: IFFALSE 51506
// result := result diff i ;
51490: LD_ADDR_VAR 0 4
51494: PUSH
51495: LD_VAR 0 4
51499: PUSH
51500: LD_VAR 0 5
51504: DIFF
51505: ST_TO_ADDR
51506: GO 51465
51508: POP
51509: POP
// end ;
51510: LD_VAR 0 4
51514: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51515: LD_INT 0
51517: PPUSH
51518: PPUSH
51519: PPUSH
// result := true ;
51520: LD_ADDR_VAR 0 3
51524: PUSH
51525: LD_INT 1
51527: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51528: LD_ADDR_VAR 0 5
51532: PUSH
51533: LD_VAR 0 2
51537: PPUSH
51538: CALL_OW 480
51542: ST_TO_ADDR
// if not tmp then
51543: LD_VAR 0 5
51547: NOT
51548: IFFALSE 51552
// exit ;
51550: GO 51601
// for i in tmp do
51552: LD_ADDR_VAR 0 4
51556: PUSH
51557: LD_VAR 0 5
51561: PUSH
51562: FOR_IN
51563: IFFALSE 51599
// if GetTech ( i , side ) <> state_researched then
51565: LD_VAR 0 4
51569: PPUSH
51570: LD_VAR 0 1
51574: PPUSH
51575: CALL_OW 321
51579: PUSH
51580: LD_INT 2
51582: NONEQUAL
51583: IFFALSE 51597
// begin result := false ;
51585: LD_ADDR_VAR 0 3
51589: PUSH
51590: LD_INT 0
51592: ST_TO_ADDR
// exit ;
51593: POP
51594: POP
51595: GO 51601
// end ;
51597: GO 51562
51599: POP
51600: POP
// end ;
51601: LD_VAR 0 3
51605: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51606: LD_INT 0
51608: PPUSH
51609: PPUSH
51610: PPUSH
51611: PPUSH
51612: PPUSH
51613: PPUSH
51614: PPUSH
51615: PPUSH
51616: PPUSH
51617: PPUSH
51618: PPUSH
51619: PPUSH
51620: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51621: LD_VAR 0 1
51625: NOT
51626: PUSH
51627: LD_VAR 0 1
51631: PPUSH
51632: CALL_OW 257
51636: PUSH
51637: LD_INT 9
51639: NONEQUAL
51640: OR
51641: IFFALSE 51645
// exit ;
51643: GO 52218
// side := GetSide ( unit ) ;
51645: LD_ADDR_VAR 0 9
51649: PUSH
51650: LD_VAR 0 1
51654: PPUSH
51655: CALL_OW 255
51659: ST_TO_ADDR
// tech_space := tech_spacanom ;
51660: LD_ADDR_VAR 0 12
51664: PUSH
51665: LD_INT 29
51667: ST_TO_ADDR
// tech_time := tech_taurad ;
51668: LD_ADDR_VAR 0 13
51672: PUSH
51673: LD_INT 28
51675: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51676: LD_ADDR_VAR 0 11
51680: PUSH
51681: LD_VAR 0 1
51685: PPUSH
51686: CALL_OW 310
51690: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51691: LD_VAR 0 11
51695: PPUSH
51696: CALL_OW 247
51700: PUSH
51701: LD_INT 2
51703: EQUAL
51704: IFFALSE 51708
// exit ;
51706: GO 52218
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51708: LD_ADDR_VAR 0 8
51712: PUSH
51713: LD_INT 81
51715: PUSH
51716: LD_VAR 0 9
51720: PUSH
51721: EMPTY
51722: LIST
51723: LIST
51724: PUSH
51725: LD_INT 3
51727: PUSH
51728: LD_INT 21
51730: PUSH
51731: LD_INT 3
51733: PUSH
51734: EMPTY
51735: LIST
51736: LIST
51737: PUSH
51738: EMPTY
51739: LIST
51740: LIST
51741: PUSH
51742: EMPTY
51743: LIST
51744: LIST
51745: PPUSH
51746: CALL_OW 69
51750: ST_TO_ADDR
// if not tmp then
51751: LD_VAR 0 8
51755: NOT
51756: IFFALSE 51760
// exit ;
51758: GO 52218
// if in_unit then
51760: LD_VAR 0 11
51764: IFFALSE 51788
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51766: LD_ADDR_VAR 0 10
51770: PUSH
51771: LD_VAR 0 8
51775: PPUSH
51776: LD_VAR 0 11
51780: PPUSH
51781: CALL_OW 74
51785: ST_TO_ADDR
51786: GO 51808
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51788: LD_ADDR_VAR 0 10
51792: PUSH
51793: LD_VAR 0 8
51797: PPUSH
51798: LD_VAR 0 1
51802: PPUSH
51803: CALL_OW 74
51807: ST_TO_ADDR
// if not enemy then
51808: LD_VAR 0 10
51812: NOT
51813: IFFALSE 51817
// exit ;
51815: GO 52218
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51817: LD_VAR 0 11
51821: PUSH
51822: LD_VAR 0 11
51826: PPUSH
51827: LD_VAR 0 10
51831: PPUSH
51832: CALL_OW 296
51836: PUSH
51837: LD_INT 13
51839: GREATER
51840: AND
51841: PUSH
51842: LD_VAR 0 1
51846: PPUSH
51847: LD_VAR 0 10
51851: PPUSH
51852: CALL_OW 296
51856: PUSH
51857: LD_INT 12
51859: GREATER
51860: OR
51861: IFFALSE 51865
// exit ;
51863: GO 52218
// missile := [ 1 ] ;
51865: LD_ADDR_VAR 0 14
51869: PUSH
51870: LD_INT 1
51872: PUSH
51873: EMPTY
51874: LIST
51875: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51876: LD_VAR 0 9
51880: PPUSH
51881: LD_VAR 0 12
51885: PPUSH
51886: CALL_OW 325
51890: IFFALSE 51919
// missile := Insert ( missile , missile + 1 , 2 ) ;
51892: LD_ADDR_VAR 0 14
51896: PUSH
51897: LD_VAR 0 14
51901: PPUSH
51902: LD_VAR 0 14
51906: PUSH
51907: LD_INT 1
51909: PLUS
51910: PPUSH
51911: LD_INT 2
51913: PPUSH
51914: CALL_OW 2
51918: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51919: LD_VAR 0 9
51923: PPUSH
51924: LD_VAR 0 13
51928: PPUSH
51929: CALL_OW 325
51933: PUSH
51934: LD_VAR 0 10
51938: PPUSH
51939: CALL_OW 255
51943: PPUSH
51944: LD_VAR 0 13
51948: PPUSH
51949: CALL_OW 325
51953: NOT
51954: AND
51955: IFFALSE 51984
// missile := Insert ( missile , missile + 1 , 3 ) ;
51957: LD_ADDR_VAR 0 14
51961: PUSH
51962: LD_VAR 0 14
51966: PPUSH
51967: LD_VAR 0 14
51971: PUSH
51972: LD_INT 1
51974: PLUS
51975: PPUSH
51976: LD_INT 3
51978: PPUSH
51979: CALL_OW 2
51983: ST_TO_ADDR
// if missile < 2 then
51984: LD_VAR 0 14
51988: PUSH
51989: LD_INT 2
51991: LESS
51992: IFFALSE 51996
// exit ;
51994: GO 52218
// x := GetX ( enemy ) ;
51996: LD_ADDR_VAR 0 4
52000: PUSH
52001: LD_VAR 0 10
52005: PPUSH
52006: CALL_OW 250
52010: ST_TO_ADDR
// y := GetY ( enemy ) ;
52011: LD_ADDR_VAR 0 5
52015: PUSH
52016: LD_VAR 0 10
52020: PPUSH
52021: CALL_OW 251
52025: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52026: LD_ADDR_VAR 0 6
52030: PUSH
52031: LD_VAR 0 4
52035: PUSH
52036: LD_INT 1
52038: NEG
52039: PPUSH
52040: LD_INT 1
52042: PPUSH
52043: CALL_OW 12
52047: PLUS
52048: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52049: LD_ADDR_VAR 0 7
52053: PUSH
52054: LD_VAR 0 5
52058: PUSH
52059: LD_INT 1
52061: NEG
52062: PPUSH
52063: LD_INT 1
52065: PPUSH
52066: CALL_OW 12
52070: PLUS
52071: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52072: LD_VAR 0 6
52076: PPUSH
52077: LD_VAR 0 7
52081: PPUSH
52082: CALL_OW 488
52086: NOT
52087: IFFALSE 52109
// begin _x := x ;
52089: LD_ADDR_VAR 0 6
52093: PUSH
52094: LD_VAR 0 4
52098: ST_TO_ADDR
// _y := y ;
52099: LD_ADDR_VAR 0 7
52103: PUSH
52104: LD_VAR 0 5
52108: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52109: LD_ADDR_VAR 0 3
52113: PUSH
52114: LD_INT 1
52116: PPUSH
52117: LD_VAR 0 14
52121: PPUSH
52122: CALL_OW 12
52126: ST_TO_ADDR
// case i of 1 :
52127: LD_VAR 0 3
52131: PUSH
52132: LD_INT 1
52134: DOUBLE
52135: EQUAL
52136: IFTRUE 52140
52138: GO 52157
52140: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52141: LD_VAR 0 1
52145: PPUSH
52146: LD_VAR 0 10
52150: PPUSH
52151: CALL_OW 115
52155: GO 52218
52157: LD_INT 2
52159: DOUBLE
52160: EQUAL
52161: IFTRUE 52165
52163: GO 52187
52165: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52166: LD_VAR 0 1
52170: PPUSH
52171: LD_VAR 0 6
52175: PPUSH
52176: LD_VAR 0 7
52180: PPUSH
52181: CALL_OW 153
52185: GO 52218
52187: LD_INT 3
52189: DOUBLE
52190: EQUAL
52191: IFTRUE 52195
52193: GO 52217
52195: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52196: LD_VAR 0 1
52200: PPUSH
52201: LD_VAR 0 6
52205: PPUSH
52206: LD_VAR 0 7
52210: PPUSH
52211: CALL_OW 154
52215: GO 52218
52217: POP
// end ;
52218: LD_VAR 0 2
52222: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52223: LD_INT 0
52225: PPUSH
52226: PPUSH
52227: PPUSH
52228: PPUSH
52229: PPUSH
52230: PPUSH
// if not unit or not building then
52231: LD_VAR 0 1
52235: NOT
52236: PUSH
52237: LD_VAR 0 2
52241: NOT
52242: OR
52243: IFFALSE 52247
// exit ;
52245: GO 52405
// x := GetX ( building ) ;
52247: LD_ADDR_VAR 0 5
52251: PUSH
52252: LD_VAR 0 2
52256: PPUSH
52257: CALL_OW 250
52261: ST_TO_ADDR
// y := GetY ( building ) ;
52262: LD_ADDR_VAR 0 6
52266: PUSH
52267: LD_VAR 0 2
52271: PPUSH
52272: CALL_OW 251
52276: ST_TO_ADDR
// for i = 0 to 5 do
52277: LD_ADDR_VAR 0 4
52281: PUSH
52282: DOUBLE
52283: LD_INT 0
52285: DEC
52286: ST_TO_ADDR
52287: LD_INT 5
52289: PUSH
52290: FOR_TO
52291: IFFALSE 52403
// begin _x := ShiftX ( x , i , 3 ) ;
52293: LD_ADDR_VAR 0 7
52297: PUSH
52298: LD_VAR 0 5
52302: PPUSH
52303: LD_VAR 0 4
52307: PPUSH
52308: LD_INT 3
52310: PPUSH
52311: CALL_OW 272
52315: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52316: LD_ADDR_VAR 0 8
52320: PUSH
52321: LD_VAR 0 6
52325: PPUSH
52326: LD_VAR 0 4
52330: PPUSH
52331: LD_INT 3
52333: PPUSH
52334: CALL_OW 273
52338: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52339: LD_VAR 0 7
52343: PPUSH
52344: LD_VAR 0 8
52348: PPUSH
52349: CALL_OW 488
52353: NOT
52354: IFFALSE 52358
// continue ;
52356: GO 52290
// if HexInfo ( _x , _y ) = 0 then
52358: LD_VAR 0 7
52362: PPUSH
52363: LD_VAR 0 8
52367: PPUSH
52368: CALL_OW 428
52372: PUSH
52373: LD_INT 0
52375: EQUAL
52376: IFFALSE 52401
// begin ComMoveXY ( unit , _x , _y ) ;
52378: LD_VAR 0 1
52382: PPUSH
52383: LD_VAR 0 7
52387: PPUSH
52388: LD_VAR 0 8
52392: PPUSH
52393: CALL_OW 111
// exit ;
52397: POP
52398: POP
52399: GO 52405
// end ; end ;
52401: GO 52290
52403: POP
52404: POP
// end ;
52405: LD_VAR 0 3
52409: RET
// export function ScanBase ( side , base_area ) ; begin
52410: LD_INT 0
52412: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52413: LD_ADDR_VAR 0 3
52417: PUSH
52418: LD_VAR 0 2
52422: PPUSH
52423: LD_INT 81
52425: PUSH
52426: LD_VAR 0 1
52430: PUSH
52431: EMPTY
52432: LIST
52433: LIST
52434: PPUSH
52435: CALL_OW 70
52439: ST_TO_ADDR
// end ;
52440: LD_VAR 0 3
52444: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
52445: LD_INT 0
52447: PPUSH
52448: PPUSH
52449: PPUSH
52450: PPUSH
// result := false ;
52451: LD_ADDR_VAR 0 2
52455: PUSH
52456: LD_INT 0
52458: ST_TO_ADDR
// side := GetSide ( unit ) ;
52459: LD_ADDR_VAR 0 3
52463: PUSH
52464: LD_VAR 0 1
52468: PPUSH
52469: CALL_OW 255
52473: ST_TO_ADDR
// nat := GetNation ( unit ) ;
52474: LD_ADDR_VAR 0 4
52478: PUSH
52479: LD_VAR 0 1
52483: PPUSH
52484: CALL_OW 248
52488: ST_TO_ADDR
// case nat of 1 :
52489: LD_VAR 0 4
52493: PUSH
52494: LD_INT 1
52496: DOUBLE
52497: EQUAL
52498: IFTRUE 52502
52500: GO 52513
52502: POP
// tech := tech_lassight ; 2 :
52503: LD_ADDR_VAR 0 5
52507: PUSH
52508: LD_INT 12
52510: ST_TO_ADDR
52511: GO 52552
52513: LD_INT 2
52515: DOUBLE
52516: EQUAL
52517: IFTRUE 52521
52519: GO 52532
52521: POP
// tech := tech_mortar ; 3 :
52522: LD_ADDR_VAR 0 5
52526: PUSH
52527: LD_INT 41
52529: ST_TO_ADDR
52530: GO 52552
52532: LD_INT 3
52534: DOUBLE
52535: EQUAL
52536: IFTRUE 52540
52538: GO 52551
52540: POP
// tech := tech_bazooka ; end ;
52541: LD_ADDR_VAR 0 5
52545: PUSH
52546: LD_INT 44
52548: ST_TO_ADDR
52549: GO 52552
52551: POP
// if Researched ( side , tech ) then
52552: LD_VAR 0 3
52556: PPUSH
52557: LD_VAR 0 5
52561: PPUSH
52562: CALL_OW 325
52566: IFFALSE 52593
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
52568: LD_ADDR_VAR 0 2
52572: PUSH
52573: LD_INT 5
52575: PUSH
52576: LD_INT 8
52578: PUSH
52579: LD_INT 9
52581: PUSH
52582: EMPTY
52583: LIST
52584: LIST
52585: LIST
52586: PUSH
52587: LD_VAR 0 4
52591: ARRAY
52592: ST_TO_ADDR
// end ;
52593: LD_VAR 0 2
52597: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
52598: LD_INT 0
52600: PPUSH
52601: PPUSH
52602: PPUSH
// if not mines then
52603: LD_VAR 0 2
52607: NOT
52608: IFFALSE 52612
// exit ;
52610: GO 52756
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52612: LD_ADDR_VAR 0 5
52616: PUSH
52617: LD_INT 81
52619: PUSH
52620: LD_VAR 0 1
52624: PUSH
52625: EMPTY
52626: LIST
52627: LIST
52628: PUSH
52629: LD_INT 3
52631: PUSH
52632: LD_INT 21
52634: PUSH
52635: LD_INT 3
52637: PUSH
52638: EMPTY
52639: LIST
52640: LIST
52641: PUSH
52642: EMPTY
52643: LIST
52644: LIST
52645: PUSH
52646: EMPTY
52647: LIST
52648: LIST
52649: PPUSH
52650: CALL_OW 69
52654: ST_TO_ADDR
// for i in mines do
52655: LD_ADDR_VAR 0 4
52659: PUSH
52660: LD_VAR 0 2
52664: PUSH
52665: FOR_IN
52666: IFFALSE 52754
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
52668: LD_VAR 0 4
52672: PUSH
52673: LD_INT 1
52675: ARRAY
52676: PPUSH
52677: LD_VAR 0 4
52681: PUSH
52682: LD_INT 2
52684: ARRAY
52685: PPUSH
52686: CALL_OW 458
52690: NOT
52691: IFFALSE 52695
// continue ;
52693: GO 52665
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
52695: LD_VAR 0 4
52699: PUSH
52700: LD_INT 1
52702: ARRAY
52703: PPUSH
52704: LD_VAR 0 4
52708: PUSH
52709: LD_INT 2
52711: ARRAY
52712: PPUSH
52713: CALL_OW 428
52717: PUSH
52718: LD_VAR 0 5
52722: IN
52723: IFFALSE 52752
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
52725: LD_VAR 0 4
52729: PUSH
52730: LD_INT 1
52732: ARRAY
52733: PPUSH
52734: LD_VAR 0 4
52738: PUSH
52739: LD_INT 2
52741: ARRAY
52742: PPUSH
52743: LD_VAR 0 1
52747: PPUSH
52748: CALL_OW 456
// end ;
52752: GO 52665
52754: POP
52755: POP
// end ;
52756: LD_VAR 0 3
52760: RET
// export function Count ( array ) ; var i ; begin
52761: LD_INT 0
52763: PPUSH
52764: PPUSH
// result := 0 ;
52765: LD_ADDR_VAR 0 2
52769: PUSH
52770: LD_INT 0
52772: ST_TO_ADDR
// for i in array do
52773: LD_ADDR_VAR 0 3
52777: PUSH
52778: LD_VAR 0 1
52782: PUSH
52783: FOR_IN
52784: IFFALSE 52808
// if i then
52786: LD_VAR 0 3
52790: IFFALSE 52806
// result := result + 1 ;
52792: LD_ADDR_VAR 0 2
52796: PUSH
52797: LD_VAR 0 2
52801: PUSH
52802: LD_INT 1
52804: PLUS
52805: ST_TO_ADDR
52806: GO 52783
52808: POP
52809: POP
// end ;
52810: LD_VAR 0 2
52814: RET
// export function IsEmpty ( building ) ; begin
52815: LD_INT 0
52817: PPUSH
// if not building then
52818: LD_VAR 0 1
52822: NOT
52823: IFFALSE 52827
// exit ;
52825: GO 52870
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
52827: LD_ADDR_VAR 0 2
52831: PUSH
52832: LD_VAR 0 1
52836: PUSH
52837: LD_INT 22
52839: PUSH
52840: LD_VAR 0 1
52844: PPUSH
52845: CALL_OW 255
52849: PUSH
52850: EMPTY
52851: LIST
52852: LIST
52853: PUSH
52854: LD_INT 58
52856: PUSH
52857: EMPTY
52858: LIST
52859: PUSH
52860: EMPTY
52861: LIST
52862: LIST
52863: PPUSH
52864: CALL_OW 69
52868: IN
52869: ST_TO_ADDR
// end ;
52870: LD_VAR 0 2
52874: RET
// export function IsNotFull ( building ) ; begin
52875: LD_INT 0
52877: PPUSH
// if not building then
52878: LD_VAR 0 1
52882: NOT
52883: IFFALSE 52887
// exit ;
52885: GO 52906
// result := UnitsInside ( building ) < 6 ;
52887: LD_ADDR_VAR 0 2
52891: PUSH
52892: LD_VAR 0 1
52896: PPUSH
52897: CALL_OW 313
52901: PUSH
52902: LD_INT 6
52904: LESS
52905: ST_TO_ADDR
// end ;
52906: LD_VAR 0 2
52910: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
52911: LD_INT 0
52913: PPUSH
52914: PPUSH
52915: PPUSH
52916: PPUSH
// tmp := [ ] ;
52917: LD_ADDR_VAR 0 3
52921: PUSH
52922: EMPTY
52923: ST_TO_ADDR
// list := [ ] ;
52924: LD_ADDR_VAR 0 5
52928: PUSH
52929: EMPTY
52930: ST_TO_ADDR
// for i = 16 to 25 do
52931: LD_ADDR_VAR 0 4
52935: PUSH
52936: DOUBLE
52937: LD_INT 16
52939: DEC
52940: ST_TO_ADDR
52941: LD_INT 25
52943: PUSH
52944: FOR_TO
52945: IFFALSE 53018
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
52947: LD_ADDR_VAR 0 3
52951: PUSH
52952: LD_VAR 0 3
52956: PUSH
52957: LD_INT 22
52959: PUSH
52960: LD_VAR 0 1
52964: PPUSH
52965: CALL_OW 255
52969: PUSH
52970: EMPTY
52971: LIST
52972: LIST
52973: PUSH
52974: LD_INT 91
52976: PUSH
52977: LD_VAR 0 1
52981: PUSH
52982: LD_INT 6
52984: PUSH
52985: EMPTY
52986: LIST
52987: LIST
52988: LIST
52989: PUSH
52990: LD_INT 30
52992: PUSH
52993: LD_VAR 0 4
52997: PUSH
52998: EMPTY
52999: LIST
53000: LIST
53001: PUSH
53002: EMPTY
53003: LIST
53004: LIST
53005: LIST
53006: PUSH
53007: EMPTY
53008: LIST
53009: PPUSH
53010: CALL_OW 69
53014: ADD
53015: ST_TO_ADDR
53016: GO 52944
53018: POP
53019: POP
// for i = 1 to tmp do
53020: LD_ADDR_VAR 0 4
53024: PUSH
53025: DOUBLE
53026: LD_INT 1
53028: DEC
53029: ST_TO_ADDR
53030: LD_VAR 0 3
53034: PUSH
53035: FOR_TO
53036: IFFALSE 53124
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53038: LD_ADDR_VAR 0 5
53042: PUSH
53043: LD_VAR 0 5
53047: PUSH
53048: LD_VAR 0 3
53052: PUSH
53053: LD_VAR 0 4
53057: ARRAY
53058: PPUSH
53059: CALL_OW 266
53063: PUSH
53064: LD_VAR 0 3
53068: PUSH
53069: LD_VAR 0 4
53073: ARRAY
53074: PPUSH
53075: CALL_OW 250
53079: PUSH
53080: LD_VAR 0 3
53084: PUSH
53085: LD_VAR 0 4
53089: ARRAY
53090: PPUSH
53091: CALL_OW 251
53095: PUSH
53096: LD_VAR 0 3
53100: PUSH
53101: LD_VAR 0 4
53105: ARRAY
53106: PPUSH
53107: CALL_OW 254
53111: PUSH
53112: EMPTY
53113: LIST
53114: LIST
53115: LIST
53116: LIST
53117: PUSH
53118: EMPTY
53119: LIST
53120: ADD
53121: ST_TO_ADDR
53122: GO 53035
53124: POP
53125: POP
// result := list ;
53126: LD_ADDR_VAR 0 2
53130: PUSH
53131: LD_VAR 0 5
53135: ST_TO_ADDR
// end ;
53136: LD_VAR 0 2
53140: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53141: LD_INT 0
53143: PPUSH
53144: PPUSH
53145: PPUSH
53146: PPUSH
53147: PPUSH
53148: PPUSH
53149: PPUSH
// if not factory then
53150: LD_VAR 0 1
53154: NOT
53155: IFFALSE 53159
// exit ;
53157: GO 53752
// if control = control_apeman then
53159: LD_VAR 0 4
53163: PUSH
53164: LD_INT 5
53166: EQUAL
53167: IFFALSE 53276
// begin tmp := UnitsInside ( factory ) ;
53169: LD_ADDR_VAR 0 8
53173: PUSH
53174: LD_VAR 0 1
53178: PPUSH
53179: CALL_OW 313
53183: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53184: LD_VAR 0 8
53188: PPUSH
53189: LD_INT 25
53191: PUSH
53192: LD_INT 12
53194: PUSH
53195: EMPTY
53196: LIST
53197: LIST
53198: PPUSH
53199: CALL_OW 72
53203: NOT
53204: IFFALSE 53214
// control := control_manual ;
53206: LD_ADDR_VAR 0 4
53210: PUSH
53211: LD_INT 1
53213: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53214: LD_ADDR_VAR 0 8
53218: PUSH
53219: LD_VAR 0 1
53223: PPUSH
53224: CALL 52911 0 1
53228: ST_TO_ADDR
// if tmp then
53229: LD_VAR 0 8
53233: IFFALSE 53276
// begin for i in tmp do
53235: LD_ADDR_VAR 0 7
53239: PUSH
53240: LD_VAR 0 8
53244: PUSH
53245: FOR_IN
53246: IFFALSE 53274
// if i [ 1 ] = b_ext_radio then
53248: LD_VAR 0 7
53252: PUSH
53253: LD_INT 1
53255: ARRAY
53256: PUSH
53257: LD_INT 22
53259: EQUAL
53260: IFFALSE 53272
// begin control := control_remote ;
53262: LD_ADDR_VAR 0 4
53266: PUSH
53267: LD_INT 2
53269: ST_TO_ADDR
// break ;
53270: GO 53274
// end ;
53272: GO 53245
53274: POP
53275: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53276: LD_VAR 0 1
53280: PPUSH
53281: LD_VAR 0 2
53285: PPUSH
53286: LD_VAR 0 3
53290: PPUSH
53291: LD_VAR 0 4
53295: PPUSH
53296: LD_VAR 0 5
53300: PPUSH
53301: CALL_OW 448
53305: IFFALSE 53340
// begin result := [ chassis , engine , control , weapon ] ;
53307: LD_ADDR_VAR 0 6
53311: PUSH
53312: LD_VAR 0 2
53316: PUSH
53317: LD_VAR 0 3
53321: PUSH
53322: LD_VAR 0 4
53326: PUSH
53327: LD_VAR 0 5
53331: PUSH
53332: EMPTY
53333: LIST
53334: LIST
53335: LIST
53336: LIST
53337: ST_TO_ADDR
// exit ;
53338: GO 53752
// end ; _chassis := AvailableChassisList ( factory ) ;
53340: LD_ADDR_VAR 0 9
53344: PUSH
53345: LD_VAR 0 1
53349: PPUSH
53350: CALL_OW 475
53354: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53355: LD_ADDR_VAR 0 11
53359: PUSH
53360: LD_VAR 0 1
53364: PPUSH
53365: CALL_OW 476
53369: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53370: LD_ADDR_VAR 0 12
53374: PUSH
53375: LD_VAR 0 1
53379: PPUSH
53380: CALL_OW 477
53384: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
53385: LD_ADDR_VAR 0 10
53389: PUSH
53390: LD_VAR 0 1
53394: PPUSH
53395: CALL_OW 478
53399: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
53400: LD_VAR 0 9
53404: NOT
53405: PUSH
53406: LD_VAR 0 11
53410: NOT
53411: OR
53412: PUSH
53413: LD_VAR 0 12
53417: NOT
53418: OR
53419: PUSH
53420: LD_VAR 0 10
53424: NOT
53425: OR
53426: IFFALSE 53461
// begin result := [ chassis , engine , control , weapon ] ;
53428: LD_ADDR_VAR 0 6
53432: PUSH
53433: LD_VAR 0 2
53437: PUSH
53438: LD_VAR 0 3
53442: PUSH
53443: LD_VAR 0 4
53447: PUSH
53448: LD_VAR 0 5
53452: PUSH
53453: EMPTY
53454: LIST
53455: LIST
53456: LIST
53457: LIST
53458: ST_TO_ADDR
// exit ;
53459: GO 53752
// end ; if not chassis in _chassis then
53461: LD_VAR 0 2
53465: PUSH
53466: LD_VAR 0 9
53470: IN
53471: NOT
53472: IFFALSE 53498
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
53474: LD_ADDR_VAR 0 2
53478: PUSH
53479: LD_VAR 0 9
53483: PUSH
53484: LD_INT 1
53486: PPUSH
53487: LD_VAR 0 9
53491: PPUSH
53492: CALL_OW 12
53496: ARRAY
53497: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
53498: LD_VAR 0 2
53502: PPUSH
53503: LD_VAR 0 3
53507: PPUSH
53508: CALL 53757 0 2
53512: NOT
53513: IFFALSE 53572
// repeat engine := _engine [ 1 ] ;
53515: LD_ADDR_VAR 0 3
53519: PUSH
53520: LD_VAR 0 11
53524: PUSH
53525: LD_INT 1
53527: ARRAY
53528: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
53529: LD_ADDR_VAR 0 11
53533: PUSH
53534: LD_VAR 0 11
53538: PPUSH
53539: LD_INT 1
53541: PPUSH
53542: CALL_OW 3
53546: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
53547: LD_VAR 0 2
53551: PPUSH
53552: LD_VAR 0 3
53556: PPUSH
53557: CALL 53757 0 2
53561: PUSH
53562: LD_VAR 0 11
53566: PUSH
53567: EMPTY
53568: EQUAL
53569: OR
53570: IFFALSE 53515
// if not control in _control then
53572: LD_VAR 0 4
53576: PUSH
53577: LD_VAR 0 12
53581: IN
53582: NOT
53583: IFFALSE 53609
// control := _control [ rand ( 1 , _control ) ] ;
53585: LD_ADDR_VAR 0 4
53589: PUSH
53590: LD_VAR 0 12
53594: PUSH
53595: LD_INT 1
53597: PPUSH
53598: LD_VAR 0 12
53602: PPUSH
53603: CALL_OW 12
53607: ARRAY
53608: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
53609: LD_VAR 0 2
53613: PPUSH
53614: LD_VAR 0 5
53618: PPUSH
53619: CALL 53977 0 2
53623: NOT
53624: IFFALSE 53683
// repeat weapon := _weapon [ 1 ] ;
53626: LD_ADDR_VAR 0 5
53630: PUSH
53631: LD_VAR 0 10
53635: PUSH
53636: LD_INT 1
53638: ARRAY
53639: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
53640: LD_ADDR_VAR 0 10
53644: PUSH
53645: LD_VAR 0 10
53649: PPUSH
53650: LD_INT 1
53652: PPUSH
53653: CALL_OW 3
53657: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
53658: LD_VAR 0 2
53662: PPUSH
53663: LD_VAR 0 5
53667: PPUSH
53668: CALL 53977 0 2
53672: PUSH
53673: LD_VAR 0 10
53677: PUSH
53678: EMPTY
53679: EQUAL
53680: OR
53681: IFFALSE 53626
// result := [ ] ;
53683: LD_ADDR_VAR 0 6
53687: PUSH
53688: EMPTY
53689: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53690: LD_VAR 0 1
53694: PPUSH
53695: LD_VAR 0 2
53699: PPUSH
53700: LD_VAR 0 3
53704: PPUSH
53705: LD_VAR 0 4
53709: PPUSH
53710: LD_VAR 0 5
53714: PPUSH
53715: CALL_OW 448
53719: IFFALSE 53752
// result := [ chassis , engine , control , weapon ] ;
53721: LD_ADDR_VAR 0 6
53725: PUSH
53726: LD_VAR 0 2
53730: PUSH
53731: LD_VAR 0 3
53735: PUSH
53736: LD_VAR 0 4
53740: PUSH
53741: LD_VAR 0 5
53745: PUSH
53746: EMPTY
53747: LIST
53748: LIST
53749: LIST
53750: LIST
53751: ST_TO_ADDR
// end ;
53752: LD_VAR 0 6
53756: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
53757: LD_INT 0
53759: PPUSH
// if not chassis or not engine then
53760: LD_VAR 0 1
53764: NOT
53765: PUSH
53766: LD_VAR 0 2
53770: NOT
53771: OR
53772: IFFALSE 53776
// exit ;
53774: GO 53972
// case engine of engine_solar :
53776: LD_VAR 0 2
53780: PUSH
53781: LD_INT 2
53783: DOUBLE
53784: EQUAL
53785: IFTRUE 53789
53787: GO 53827
53789: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
53790: LD_ADDR_VAR 0 3
53794: PUSH
53795: LD_INT 11
53797: PUSH
53798: LD_INT 12
53800: PUSH
53801: LD_INT 13
53803: PUSH
53804: LD_INT 14
53806: PUSH
53807: LD_INT 1
53809: PUSH
53810: LD_INT 2
53812: PUSH
53813: LD_INT 3
53815: PUSH
53816: EMPTY
53817: LIST
53818: LIST
53819: LIST
53820: LIST
53821: LIST
53822: LIST
53823: LIST
53824: ST_TO_ADDR
53825: GO 53956
53827: LD_INT 1
53829: DOUBLE
53830: EQUAL
53831: IFTRUE 53835
53833: GO 53897
53835: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
53836: LD_ADDR_VAR 0 3
53840: PUSH
53841: LD_INT 11
53843: PUSH
53844: LD_INT 12
53846: PUSH
53847: LD_INT 13
53849: PUSH
53850: LD_INT 14
53852: PUSH
53853: LD_INT 1
53855: PUSH
53856: LD_INT 2
53858: PUSH
53859: LD_INT 3
53861: PUSH
53862: LD_INT 4
53864: PUSH
53865: LD_INT 5
53867: PUSH
53868: LD_INT 21
53870: PUSH
53871: LD_INT 23
53873: PUSH
53874: LD_INT 22
53876: PUSH
53877: LD_INT 24
53879: PUSH
53880: EMPTY
53881: LIST
53882: LIST
53883: LIST
53884: LIST
53885: LIST
53886: LIST
53887: LIST
53888: LIST
53889: LIST
53890: LIST
53891: LIST
53892: LIST
53893: LIST
53894: ST_TO_ADDR
53895: GO 53956
53897: LD_INT 3
53899: DOUBLE
53900: EQUAL
53901: IFTRUE 53905
53903: GO 53955
53905: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53906: LD_ADDR_VAR 0 3
53910: PUSH
53911: LD_INT 13
53913: PUSH
53914: LD_INT 14
53916: PUSH
53917: LD_INT 2
53919: PUSH
53920: LD_INT 3
53922: PUSH
53923: LD_INT 4
53925: PUSH
53926: LD_INT 5
53928: PUSH
53929: LD_INT 21
53931: PUSH
53932: LD_INT 22
53934: PUSH
53935: LD_INT 23
53937: PUSH
53938: LD_INT 24
53940: PUSH
53941: EMPTY
53942: LIST
53943: LIST
53944: LIST
53945: LIST
53946: LIST
53947: LIST
53948: LIST
53949: LIST
53950: LIST
53951: LIST
53952: ST_TO_ADDR
53953: GO 53956
53955: POP
// result := ( chassis in result ) ;
53956: LD_ADDR_VAR 0 3
53960: PUSH
53961: LD_VAR 0 1
53965: PUSH
53966: LD_VAR 0 3
53970: IN
53971: ST_TO_ADDR
// end ;
53972: LD_VAR 0 3
53976: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
53977: LD_INT 0
53979: PPUSH
// if not chassis or not weapon then
53980: LD_VAR 0 1
53984: NOT
53985: PUSH
53986: LD_VAR 0 2
53990: NOT
53991: OR
53992: IFFALSE 53996
// exit ;
53994: GO 55022
// case weapon of us_machine_gun :
53996: LD_VAR 0 2
54000: PUSH
54001: LD_INT 2
54003: DOUBLE
54004: EQUAL
54005: IFTRUE 54009
54007: GO 54039
54009: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54010: LD_ADDR_VAR 0 3
54014: PUSH
54015: LD_INT 1
54017: PUSH
54018: LD_INT 2
54020: PUSH
54021: LD_INT 3
54023: PUSH
54024: LD_INT 4
54026: PUSH
54027: LD_INT 5
54029: PUSH
54030: EMPTY
54031: LIST
54032: LIST
54033: LIST
54034: LIST
54035: LIST
54036: ST_TO_ADDR
54037: GO 55006
54039: LD_INT 3
54041: DOUBLE
54042: EQUAL
54043: IFTRUE 54047
54045: GO 54077
54047: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54048: LD_ADDR_VAR 0 3
54052: PUSH
54053: LD_INT 1
54055: PUSH
54056: LD_INT 2
54058: PUSH
54059: LD_INT 3
54061: PUSH
54062: LD_INT 4
54064: PUSH
54065: LD_INT 5
54067: PUSH
54068: EMPTY
54069: LIST
54070: LIST
54071: LIST
54072: LIST
54073: LIST
54074: ST_TO_ADDR
54075: GO 55006
54077: LD_INT 11
54079: DOUBLE
54080: EQUAL
54081: IFTRUE 54085
54083: GO 54115
54085: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54086: LD_ADDR_VAR 0 3
54090: PUSH
54091: LD_INT 1
54093: PUSH
54094: LD_INT 2
54096: PUSH
54097: LD_INT 3
54099: PUSH
54100: LD_INT 4
54102: PUSH
54103: LD_INT 5
54105: PUSH
54106: EMPTY
54107: LIST
54108: LIST
54109: LIST
54110: LIST
54111: LIST
54112: ST_TO_ADDR
54113: GO 55006
54115: LD_INT 4
54117: DOUBLE
54118: EQUAL
54119: IFTRUE 54123
54121: GO 54149
54123: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54124: LD_ADDR_VAR 0 3
54128: PUSH
54129: LD_INT 2
54131: PUSH
54132: LD_INT 3
54134: PUSH
54135: LD_INT 4
54137: PUSH
54138: LD_INT 5
54140: PUSH
54141: EMPTY
54142: LIST
54143: LIST
54144: LIST
54145: LIST
54146: ST_TO_ADDR
54147: GO 55006
54149: LD_INT 5
54151: DOUBLE
54152: EQUAL
54153: IFTRUE 54157
54155: GO 54183
54157: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54158: LD_ADDR_VAR 0 3
54162: PUSH
54163: LD_INT 2
54165: PUSH
54166: LD_INT 3
54168: PUSH
54169: LD_INT 4
54171: PUSH
54172: LD_INT 5
54174: PUSH
54175: EMPTY
54176: LIST
54177: LIST
54178: LIST
54179: LIST
54180: ST_TO_ADDR
54181: GO 55006
54183: LD_INT 9
54185: DOUBLE
54186: EQUAL
54187: IFTRUE 54191
54189: GO 54217
54191: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54192: LD_ADDR_VAR 0 3
54196: PUSH
54197: LD_INT 2
54199: PUSH
54200: LD_INT 3
54202: PUSH
54203: LD_INT 4
54205: PUSH
54206: LD_INT 5
54208: PUSH
54209: EMPTY
54210: LIST
54211: LIST
54212: LIST
54213: LIST
54214: ST_TO_ADDR
54215: GO 55006
54217: LD_INT 7
54219: DOUBLE
54220: EQUAL
54221: IFTRUE 54225
54223: GO 54251
54225: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54226: LD_ADDR_VAR 0 3
54230: PUSH
54231: LD_INT 2
54233: PUSH
54234: LD_INT 3
54236: PUSH
54237: LD_INT 4
54239: PUSH
54240: LD_INT 5
54242: PUSH
54243: EMPTY
54244: LIST
54245: LIST
54246: LIST
54247: LIST
54248: ST_TO_ADDR
54249: GO 55006
54251: LD_INT 12
54253: DOUBLE
54254: EQUAL
54255: IFTRUE 54259
54257: GO 54285
54259: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54260: LD_ADDR_VAR 0 3
54264: PUSH
54265: LD_INT 2
54267: PUSH
54268: LD_INT 3
54270: PUSH
54271: LD_INT 4
54273: PUSH
54274: LD_INT 5
54276: PUSH
54277: EMPTY
54278: LIST
54279: LIST
54280: LIST
54281: LIST
54282: ST_TO_ADDR
54283: GO 55006
54285: LD_INT 13
54287: DOUBLE
54288: EQUAL
54289: IFTRUE 54293
54291: GO 54319
54293: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54294: LD_ADDR_VAR 0 3
54298: PUSH
54299: LD_INT 2
54301: PUSH
54302: LD_INT 3
54304: PUSH
54305: LD_INT 4
54307: PUSH
54308: LD_INT 5
54310: PUSH
54311: EMPTY
54312: LIST
54313: LIST
54314: LIST
54315: LIST
54316: ST_TO_ADDR
54317: GO 55006
54319: LD_INT 14
54321: DOUBLE
54322: EQUAL
54323: IFTRUE 54327
54325: GO 54345
54327: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54328: LD_ADDR_VAR 0 3
54332: PUSH
54333: LD_INT 4
54335: PUSH
54336: LD_INT 5
54338: PUSH
54339: EMPTY
54340: LIST
54341: LIST
54342: ST_TO_ADDR
54343: GO 55006
54345: LD_INT 6
54347: DOUBLE
54348: EQUAL
54349: IFTRUE 54353
54351: GO 54371
54353: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54354: LD_ADDR_VAR 0 3
54358: PUSH
54359: LD_INT 4
54361: PUSH
54362: LD_INT 5
54364: PUSH
54365: EMPTY
54366: LIST
54367: LIST
54368: ST_TO_ADDR
54369: GO 55006
54371: LD_INT 10
54373: DOUBLE
54374: EQUAL
54375: IFTRUE 54379
54377: GO 54397
54379: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
54380: LD_ADDR_VAR 0 3
54384: PUSH
54385: LD_INT 4
54387: PUSH
54388: LD_INT 5
54390: PUSH
54391: EMPTY
54392: LIST
54393: LIST
54394: ST_TO_ADDR
54395: GO 55006
54397: LD_INT 22
54399: DOUBLE
54400: EQUAL
54401: IFTRUE 54405
54403: GO 54431
54405: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
54406: LD_ADDR_VAR 0 3
54410: PUSH
54411: LD_INT 11
54413: PUSH
54414: LD_INT 12
54416: PUSH
54417: LD_INT 13
54419: PUSH
54420: LD_INT 14
54422: PUSH
54423: EMPTY
54424: LIST
54425: LIST
54426: LIST
54427: LIST
54428: ST_TO_ADDR
54429: GO 55006
54431: LD_INT 23
54433: DOUBLE
54434: EQUAL
54435: IFTRUE 54439
54437: GO 54465
54439: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
54440: LD_ADDR_VAR 0 3
54444: PUSH
54445: LD_INT 11
54447: PUSH
54448: LD_INT 12
54450: PUSH
54451: LD_INT 13
54453: PUSH
54454: LD_INT 14
54456: PUSH
54457: EMPTY
54458: LIST
54459: LIST
54460: LIST
54461: LIST
54462: ST_TO_ADDR
54463: GO 55006
54465: LD_INT 24
54467: DOUBLE
54468: EQUAL
54469: IFTRUE 54473
54471: GO 54499
54473: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
54474: LD_ADDR_VAR 0 3
54478: PUSH
54479: LD_INT 11
54481: PUSH
54482: LD_INT 12
54484: PUSH
54485: LD_INT 13
54487: PUSH
54488: LD_INT 14
54490: PUSH
54491: EMPTY
54492: LIST
54493: LIST
54494: LIST
54495: LIST
54496: ST_TO_ADDR
54497: GO 55006
54499: LD_INT 30
54501: DOUBLE
54502: EQUAL
54503: IFTRUE 54507
54505: GO 54533
54507: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
54508: LD_ADDR_VAR 0 3
54512: PUSH
54513: LD_INT 11
54515: PUSH
54516: LD_INT 12
54518: PUSH
54519: LD_INT 13
54521: PUSH
54522: LD_INT 14
54524: PUSH
54525: EMPTY
54526: LIST
54527: LIST
54528: LIST
54529: LIST
54530: ST_TO_ADDR
54531: GO 55006
54533: LD_INT 25
54535: DOUBLE
54536: EQUAL
54537: IFTRUE 54541
54539: GO 54559
54541: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
54542: LD_ADDR_VAR 0 3
54546: PUSH
54547: LD_INT 13
54549: PUSH
54550: LD_INT 14
54552: PUSH
54553: EMPTY
54554: LIST
54555: LIST
54556: ST_TO_ADDR
54557: GO 55006
54559: LD_INT 27
54561: DOUBLE
54562: EQUAL
54563: IFTRUE 54567
54565: GO 54585
54567: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
54568: LD_ADDR_VAR 0 3
54572: PUSH
54573: LD_INT 13
54575: PUSH
54576: LD_INT 14
54578: PUSH
54579: EMPTY
54580: LIST
54581: LIST
54582: ST_TO_ADDR
54583: GO 55006
54585: LD_INT 28
54587: DOUBLE
54588: EQUAL
54589: IFTRUE 54593
54591: GO 54611
54593: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
54594: LD_ADDR_VAR 0 3
54598: PUSH
54599: LD_INT 13
54601: PUSH
54602: LD_INT 14
54604: PUSH
54605: EMPTY
54606: LIST
54607: LIST
54608: ST_TO_ADDR
54609: GO 55006
54611: LD_INT 29
54613: DOUBLE
54614: EQUAL
54615: IFTRUE 54619
54617: GO 54637
54619: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
54620: LD_ADDR_VAR 0 3
54624: PUSH
54625: LD_INT 13
54627: PUSH
54628: LD_INT 14
54630: PUSH
54631: EMPTY
54632: LIST
54633: LIST
54634: ST_TO_ADDR
54635: GO 55006
54637: LD_INT 31
54639: DOUBLE
54640: EQUAL
54641: IFTRUE 54645
54643: GO 54663
54645: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
54646: LD_ADDR_VAR 0 3
54650: PUSH
54651: LD_INT 13
54653: PUSH
54654: LD_INT 14
54656: PUSH
54657: EMPTY
54658: LIST
54659: LIST
54660: ST_TO_ADDR
54661: GO 55006
54663: LD_INT 26
54665: DOUBLE
54666: EQUAL
54667: IFTRUE 54671
54669: GO 54689
54671: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
54672: LD_ADDR_VAR 0 3
54676: PUSH
54677: LD_INT 13
54679: PUSH
54680: LD_INT 14
54682: PUSH
54683: EMPTY
54684: LIST
54685: LIST
54686: ST_TO_ADDR
54687: GO 55006
54689: LD_INT 42
54691: DOUBLE
54692: EQUAL
54693: IFTRUE 54697
54695: GO 54723
54697: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
54698: LD_ADDR_VAR 0 3
54702: PUSH
54703: LD_INT 21
54705: PUSH
54706: LD_INT 22
54708: PUSH
54709: LD_INT 23
54711: PUSH
54712: LD_INT 24
54714: PUSH
54715: EMPTY
54716: LIST
54717: LIST
54718: LIST
54719: LIST
54720: ST_TO_ADDR
54721: GO 55006
54723: LD_INT 43
54725: DOUBLE
54726: EQUAL
54727: IFTRUE 54731
54729: GO 54757
54731: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
54732: LD_ADDR_VAR 0 3
54736: PUSH
54737: LD_INT 21
54739: PUSH
54740: LD_INT 22
54742: PUSH
54743: LD_INT 23
54745: PUSH
54746: LD_INT 24
54748: PUSH
54749: EMPTY
54750: LIST
54751: LIST
54752: LIST
54753: LIST
54754: ST_TO_ADDR
54755: GO 55006
54757: LD_INT 44
54759: DOUBLE
54760: EQUAL
54761: IFTRUE 54765
54763: GO 54791
54765: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
54766: LD_ADDR_VAR 0 3
54770: PUSH
54771: LD_INT 21
54773: PUSH
54774: LD_INT 22
54776: PUSH
54777: LD_INT 23
54779: PUSH
54780: LD_INT 24
54782: PUSH
54783: EMPTY
54784: LIST
54785: LIST
54786: LIST
54787: LIST
54788: ST_TO_ADDR
54789: GO 55006
54791: LD_INT 45
54793: DOUBLE
54794: EQUAL
54795: IFTRUE 54799
54797: GO 54825
54799: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
54800: LD_ADDR_VAR 0 3
54804: PUSH
54805: LD_INT 21
54807: PUSH
54808: LD_INT 22
54810: PUSH
54811: LD_INT 23
54813: PUSH
54814: LD_INT 24
54816: PUSH
54817: EMPTY
54818: LIST
54819: LIST
54820: LIST
54821: LIST
54822: ST_TO_ADDR
54823: GO 55006
54825: LD_INT 49
54827: DOUBLE
54828: EQUAL
54829: IFTRUE 54833
54831: GO 54859
54833: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
54834: LD_ADDR_VAR 0 3
54838: PUSH
54839: LD_INT 21
54841: PUSH
54842: LD_INT 22
54844: PUSH
54845: LD_INT 23
54847: PUSH
54848: LD_INT 24
54850: PUSH
54851: EMPTY
54852: LIST
54853: LIST
54854: LIST
54855: LIST
54856: ST_TO_ADDR
54857: GO 55006
54859: LD_INT 51
54861: DOUBLE
54862: EQUAL
54863: IFTRUE 54867
54865: GO 54893
54867: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
54868: LD_ADDR_VAR 0 3
54872: PUSH
54873: LD_INT 21
54875: PUSH
54876: LD_INT 22
54878: PUSH
54879: LD_INT 23
54881: PUSH
54882: LD_INT 24
54884: PUSH
54885: EMPTY
54886: LIST
54887: LIST
54888: LIST
54889: LIST
54890: ST_TO_ADDR
54891: GO 55006
54893: LD_INT 52
54895: DOUBLE
54896: EQUAL
54897: IFTRUE 54901
54899: GO 54927
54901: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
54902: LD_ADDR_VAR 0 3
54906: PUSH
54907: LD_INT 21
54909: PUSH
54910: LD_INT 22
54912: PUSH
54913: LD_INT 23
54915: PUSH
54916: LD_INT 24
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: LIST
54923: LIST
54924: ST_TO_ADDR
54925: GO 55006
54927: LD_INT 53
54929: DOUBLE
54930: EQUAL
54931: IFTRUE 54935
54933: GO 54953
54935: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
54936: LD_ADDR_VAR 0 3
54940: PUSH
54941: LD_INT 23
54943: PUSH
54944: LD_INT 24
54946: PUSH
54947: EMPTY
54948: LIST
54949: LIST
54950: ST_TO_ADDR
54951: GO 55006
54953: LD_INT 46
54955: DOUBLE
54956: EQUAL
54957: IFTRUE 54961
54959: GO 54979
54961: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
54962: LD_ADDR_VAR 0 3
54966: PUSH
54967: LD_INT 23
54969: PUSH
54970: LD_INT 24
54972: PUSH
54973: EMPTY
54974: LIST
54975: LIST
54976: ST_TO_ADDR
54977: GO 55006
54979: LD_INT 47
54981: DOUBLE
54982: EQUAL
54983: IFTRUE 54987
54985: GO 55005
54987: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54988: LD_ADDR_VAR 0 3
54992: PUSH
54993: LD_INT 23
54995: PUSH
54996: LD_INT 24
54998: PUSH
54999: EMPTY
55000: LIST
55001: LIST
55002: ST_TO_ADDR
55003: GO 55006
55005: POP
// result := ( chassis in result ) ;
55006: LD_ADDR_VAR 0 3
55010: PUSH
55011: LD_VAR 0 1
55015: PUSH
55016: LD_VAR 0 3
55020: IN
55021: ST_TO_ADDR
// end ;
55022: LD_VAR 0 3
55026: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55027: LD_INT 0
55029: PPUSH
55030: PPUSH
55031: PPUSH
55032: PPUSH
55033: PPUSH
55034: PPUSH
55035: PPUSH
// result := array ;
55036: LD_ADDR_VAR 0 5
55040: PUSH
55041: LD_VAR 0 1
55045: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55046: LD_VAR 0 1
55050: NOT
55051: PUSH
55052: LD_VAR 0 2
55056: NOT
55057: OR
55058: PUSH
55059: LD_VAR 0 3
55063: NOT
55064: OR
55065: PUSH
55066: LD_VAR 0 2
55070: PUSH
55071: LD_VAR 0 1
55075: GREATER
55076: OR
55077: PUSH
55078: LD_VAR 0 3
55082: PUSH
55083: LD_VAR 0 1
55087: GREATER
55088: OR
55089: IFFALSE 55093
// exit ;
55091: GO 55389
// if direction then
55093: LD_VAR 0 4
55097: IFFALSE 55161
// begin d := 1 ;
55099: LD_ADDR_VAR 0 9
55103: PUSH
55104: LD_INT 1
55106: ST_TO_ADDR
// if i_from > i_to then
55107: LD_VAR 0 2
55111: PUSH
55112: LD_VAR 0 3
55116: GREATER
55117: IFFALSE 55143
// length := ( array - i_from ) + i_to else
55119: LD_ADDR_VAR 0 11
55123: PUSH
55124: LD_VAR 0 1
55128: PUSH
55129: LD_VAR 0 2
55133: MINUS
55134: PUSH
55135: LD_VAR 0 3
55139: PLUS
55140: ST_TO_ADDR
55141: GO 55159
// length := i_to - i_from ;
55143: LD_ADDR_VAR 0 11
55147: PUSH
55148: LD_VAR 0 3
55152: PUSH
55153: LD_VAR 0 2
55157: MINUS
55158: ST_TO_ADDR
// end else
55159: GO 55222
// begin d := - 1 ;
55161: LD_ADDR_VAR 0 9
55165: PUSH
55166: LD_INT 1
55168: NEG
55169: ST_TO_ADDR
// if i_from > i_to then
55170: LD_VAR 0 2
55174: PUSH
55175: LD_VAR 0 3
55179: GREATER
55180: IFFALSE 55200
// length := i_from - i_to else
55182: LD_ADDR_VAR 0 11
55186: PUSH
55187: LD_VAR 0 2
55191: PUSH
55192: LD_VAR 0 3
55196: MINUS
55197: ST_TO_ADDR
55198: GO 55222
// length := ( array - i_to ) + i_from ;
55200: LD_ADDR_VAR 0 11
55204: PUSH
55205: LD_VAR 0 1
55209: PUSH
55210: LD_VAR 0 3
55214: MINUS
55215: PUSH
55216: LD_VAR 0 2
55220: PLUS
55221: ST_TO_ADDR
// end ; if not length then
55222: LD_VAR 0 11
55226: NOT
55227: IFFALSE 55231
// exit ;
55229: GO 55389
// tmp := array ;
55231: LD_ADDR_VAR 0 10
55235: PUSH
55236: LD_VAR 0 1
55240: ST_TO_ADDR
// for i = 1 to length do
55241: LD_ADDR_VAR 0 6
55245: PUSH
55246: DOUBLE
55247: LD_INT 1
55249: DEC
55250: ST_TO_ADDR
55251: LD_VAR 0 11
55255: PUSH
55256: FOR_TO
55257: IFFALSE 55377
// begin for j = 1 to array do
55259: LD_ADDR_VAR 0 7
55263: PUSH
55264: DOUBLE
55265: LD_INT 1
55267: DEC
55268: ST_TO_ADDR
55269: LD_VAR 0 1
55273: PUSH
55274: FOR_TO
55275: IFFALSE 55363
// begin k := j + d ;
55277: LD_ADDR_VAR 0 8
55281: PUSH
55282: LD_VAR 0 7
55286: PUSH
55287: LD_VAR 0 9
55291: PLUS
55292: ST_TO_ADDR
// if k > array then
55293: LD_VAR 0 8
55297: PUSH
55298: LD_VAR 0 1
55302: GREATER
55303: IFFALSE 55313
// k := 1 ;
55305: LD_ADDR_VAR 0 8
55309: PUSH
55310: LD_INT 1
55312: ST_TO_ADDR
// if not k then
55313: LD_VAR 0 8
55317: NOT
55318: IFFALSE 55330
// k := array ;
55320: LD_ADDR_VAR 0 8
55324: PUSH
55325: LD_VAR 0 1
55329: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55330: LD_ADDR_VAR 0 10
55334: PUSH
55335: LD_VAR 0 10
55339: PPUSH
55340: LD_VAR 0 8
55344: PPUSH
55345: LD_VAR 0 1
55349: PUSH
55350: LD_VAR 0 7
55354: ARRAY
55355: PPUSH
55356: CALL_OW 1
55360: ST_TO_ADDR
// end ;
55361: GO 55274
55363: POP
55364: POP
// array := tmp ;
55365: LD_ADDR_VAR 0 1
55369: PUSH
55370: LD_VAR 0 10
55374: ST_TO_ADDR
// end ;
55375: GO 55256
55377: POP
55378: POP
// result := array ;
55379: LD_ADDR_VAR 0 5
55383: PUSH
55384: LD_VAR 0 1
55388: ST_TO_ADDR
// end ;
55389: LD_VAR 0 5
55393: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
55394: LD_INT 0
55396: PPUSH
55397: PPUSH
// result := 0 ;
55398: LD_ADDR_VAR 0 3
55402: PUSH
55403: LD_INT 0
55405: ST_TO_ADDR
// if not array or not value in array then
55406: LD_VAR 0 1
55410: NOT
55411: PUSH
55412: LD_VAR 0 2
55416: PUSH
55417: LD_VAR 0 1
55421: IN
55422: NOT
55423: OR
55424: IFFALSE 55428
// exit ;
55426: GO 55482
// for i = 1 to array do
55428: LD_ADDR_VAR 0 4
55432: PUSH
55433: DOUBLE
55434: LD_INT 1
55436: DEC
55437: ST_TO_ADDR
55438: LD_VAR 0 1
55442: PUSH
55443: FOR_TO
55444: IFFALSE 55480
// if value = array [ i ] then
55446: LD_VAR 0 2
55450: PUSH
55451: LD_VAR 0 1
55455: PUSH
55456: LD_VAR 0 4
55460: ARRAY
55461: EQUAL
55462: IFFALSE 55478
// begin result := i ;
55464: LD_ADDR_VAR 0 3
55468: PUSH
55469: LD_VAR 0 4
55473: ST_TO_ADDR
// exit ;
55474: POP
55475: POP
55476: GO 55482
// end ;
55478: GO 55443
55480: POP
55481: POP
// end ;
55482: LD_VAR 0 3
55486: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
55487: LD_INT 0
55489: PPUSH
// vc_chassis := chassis ;
55490: LD_ADDR_OWVAR 37
55494: PUSH
55495: LD_VAR 0 1
55499: ST_TO_ADDR
// vc_engine := engine ;
55500: LD_ADDR_OWVAR 39
55504: PUSH
55505: LD_VAR 0 2
55509: ST_TO_ADDR
// vc_control := control ;
55510: LD_ADDR_OWVAR 38
55514: PUSH
55515: LD_VAR 0 3
55519: ST_TO_ADDR
// vc_weapon := weapon ;
55520: LD_ADDR_OWVAR 40
55524: PUSH
55525: LD_VAR 0 4
55529: ST_TO_ADDR
// vc_fuel_battery := fuel ;
55530: LD_ADDR_OWVAR 41
55534: PUSH
55535: LD_VAR 0 5
55539: ST_TO_ADDR
// end ;
55540: LD_VAR 0 6
55544: RET
// export function WantPlant ( unit ) ; var task ; begin
55545: LD_INT 0
55547: PPUSH
55548: PPUSH
// result := false ;
55549: LD_ADDR_VAR 0 2
55553: PUSH
55554: LD_INT 0
55556: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
55557: LD_ADDR_VAR 0 3
55561: PUSH
55562: LD_VAR 0 1
55566: PPUSH
55567: CALL_OW 437
55571: ST_TO_ADDR
// if task then
55572: LD_VAR 0 3
55576: IFFALSE 55604
// if task [ 1 ] [ 1 ] = p then
55578: LD_VAR 0 3
55582: PUSH
55583: LD_INT 1
55585: ARRAY
55586: PUSH
55587: LD_INT 1
55589: ARRAY
55590: PUSH
55591: LD_STRING p
55593: EQUAL
55594: IFFALSE 55604
// result := true ;
55596: LD_ADDR_VAR 0 2
55600: PUSH
55601: LD_INT 1
55603: ST_TO_ADDR
// end ;
55604: LD_VAR 0 2
55608: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
55609: LD_INT 0
55611: PPUSH
55612: PPUSH
55613: PPUSH
55614: PPUSH
// if pos < 1 then
55615: LD_VAR 0 2
55619: PUSH
55620: LD_INT 1
55622: LESS
55623: IFFALSE 55627
// exit ;
55625: GO 55930
// if pos = 1 then
55627: LD_VAR 0 2
55631: PUSH
55632: LD_INT 1
55634: EQUAL
55635: IFFALSE 55668
// result := Replace ( arr , pos [ 1 ] , value ) else
55637: LD_ADDR_VAR 0 4
55641: PUSH
55642: LD_VAR 0 1
55646: PPUSH
55647: LD_VAR 0 2
55651: PUSH
55652: LD_INT 1
55654: ARRAY
55655: PPUSH
55656: LD_VAR 0 3
55660: PPUSH
55661: CALL_OW 1
55665: ST_TO_ADDR
55666: GO 55930
// begin tmp := arr ;
55668: LD_ADDR_VAR 0 6
55672: PUSH
55673: LD_VAR 0 1
55677: ST_TO_ADDR
// s_arr := [ tmp ] ;
55678: LD_ADDR_VAR 0 7
55682: PUSH
55683: LD_VAR 0 6
55687: PUSH
55688: EMPTY
55689: LIST
55690: ST_TO_ADDR
// for i = 1 to pos - 1 do
55691: LD_ADDR_VAR 0 5
55695: PUSH
55696: DOUBLE
55697: LD_INT 1
55699: DEC
55700: ST_TO_ADDR
55701: LD_VAR 0 2
55705: PUSH
55706: LD_INT 1
55708: MINUS
55709: PUSH
55710: FOR_TO
55711: IFFALSE 55756
// begin tmp := tmp [ pos [ i ] ] ;
55713: LD_ADDR_VAR 0 6
55717: PUSH
55718: LD_VAR 0 6
55722: PUSH
55723: LD_VAR 0 2
55727: PUSH
55728: LD_VAR 0 5
55732: ARRAY
55733: ARRAY
55734: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
55735: LD_ADDR_VAR 0 7
55739: PUSH
55740: LD_VAR 0 7
55744: PUSH
55745: LD_VAR 0 6
55749: PUSH
55750: EMPTY
55751: LIST
55752: ADD
55753: ST_TO_ADDR
// end ;
55754: GO 55710
55756: POP
55757: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
55758: LD_ADDR_VAR 0 6
55762: PUSH
55763: LD_VAR 0 6
55767: PPUSH
55768: LD_VAR 0 2
55772: PUSH
55773: LD_VAR 0 2
55777: ARRAY
55778: PPUSH
55779: LD_VAR 0 3
55783: PPUSH
55784: CALL_OW 1
55788: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
55789: LD_ADDR_VAR 0 7
55793: PUSH
55794: LD_VAR 0 7
55798: PPUSH
55799: LD_VAR 0 7
55803: PPUSH
55804: LD_VAR 0 6
55808: PPUSH
55809: CALL_OW 1
55813: ST_TO_ADDR
// for i = s_arr downto 2 do
55814: LD_ADDR_VAR 0 5
55818: PUSH
55819: DOUBLE
55820: LD_VAR 0 7
55824: INC
55825: ST_TO_ADDR
55826: LD_INT 2
55828: PUSH
55829: FOR_DOWNTO
55830: IFFALSE 55914
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
55832: LD_ADDR_VAR 0 6
55836: PUSH
55837: LD_VAR 0 7
55841: PUSH
55842: LD_VAR 0 5
55846: PUSH
55847: LD_INT 1
55849: MINUS
55850: ARRAY
55851: PPUSH
55852: LD_VAR 0 2
55856: PUSH
55857: LD_VAR 0 5
55861: PUSH
55862: LD_INT 1
55864: MINUS
55865: ARRAY
55866: PPUSH
55867: LD_VAR 0 7
55871: PUSH
55872: LD_VAR 0 5
55876: ARRAY
55877: PPUSH
55878: CALL_OW 1
55882: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
55883: LD_ADDR_VAR 0 7
55887: PUSH
55888: LD_VAR 0 7
55892: PPUSH
55893: LD_VAR 0 5
55897: PUSH
55898: LD_INT 1
55900: MINUS
55901: PPUSH
55902: LD_VAR 0 6
55906: PPUSH
55907: CALL_OW 1
55911: ST_TO_ADDR
// end ;
55912: GO 55829
55914: POP
55915: POP
// result := s_arr [ 1 ] ;
55916: LD_ADDR_VAR 0 4
55920: PUSH
55921: LD_VAR 0 7
55925: PUSH
55926: LD_INT 1
55928: ARRAY
55929: ST_TO_ADDR
// end ; end ;
55930: LD_VAR 0 4
55934: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
55935: LD_INT 0
55937: PPUSH
55938: PPUSH
// if not list then
55939: LD_VAR 0 1
55943: NOT
55944: IFFALSE 55948
// exit ;
55946: GO 56039
// i := list [ pos1 ] ;
55948: LD_ADDR_VAR 0 5
55952: PUSH
55953: LD_VAR 0 1
55957: PUSH
55958: LD_VAR 0 2
55962: ARRAY
55963: ST_TO_ADDR
// if not i then
55964: LD_VAR 0 5
55968: NOT
55969: IFFALSE 55973
// exit ;
55971: GO 56039
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
55973: LD_ADDR_VAR 0 1
55977: PUSH
55978: LD_VAR 0 1
55982: PPUSH
55983: LD_VAR 0 2
55987: PPUSH
55988: LD_VAR 0 1
55992: PUSH
55993: LD_VAR 0 3
55997: ARRAY
55998: PPUSH
55999: CALL_OW 1
56003: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56004: LD_ADDR_VAR 0 1
56008: PUSH
56009: LD_VAR 0 1
56013: PPUSH
56014: LD_VAR 0 3
56018: PPUSH
56019: LD_VAR 0 5
56023: PPUSH
56024: CALL_OW 1
56028: ST_TO_ADDR
// result := list ;
56029: LD_ADDR_VAR 0 4
56033: PUSH
56034: LD_VAR 0 1
56038: ST_TO_ADDR
// end ;
56039: LD_VAR 0 4
56043: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56044: LD_INT 0
56046: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56047: LD_ADDR_VAR 0 5
56051: PUSH
56052: LD_VAR 0 1
56056: PPUSH
56057: CALL_OW 250
56061: PPUSH
56062: LD_VAR 0 1
56066: PPUSH
56067: CALL_OW 251
56071: PPUSH
56072: LD_VAR 0 2
56076: PPUSH
56077: LD_VAR 0 3
56081: PPUSH
56082: LD_VAR 0 4
56086: PPUSH
56087: CALL 56097 0 5
56091: ST_TO_ADDR
// end ;
56092: LD_VAR 0 5
56096: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56097: LD_INT 0
56099: PPUSH
56100: PPUSH
56101: PPUSH
56102: PPUSH
// if not list then
56103: LD_VAR 0 3
56107: NOT
56108: IFFALSE 56112
// exit ;
56110: GO 56500
// result := [ ] ;
56112: LD_ADDR_VAR 0 6
56116: PUSH
56117: EMPTY
56118: ST_TO_ADDR
// for i in list do
56119: LD_ADDR_VAR 0 7
56123: PUSH
56124: LD_VAR 0 3
56128: PUSH
56129: FOR_IN
56130: IFFALSE 56332
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56132: LD_ADDR_VAR 0 9
56136: PUSH
56137: LD_VAR 0 7
56141: PPUSH
56142: LD_VAR 0 1
56146: PPUSH
56147: LD_VAR 0 2
56151: PPUSH
56152: CALL_OW 297
56156: ST_TO_ADDR
// if not result then
56157: LD_VAR 0 6
56161: NOT
56162: IFFALSE 56188
// result := [ [ i , tmp ] ] else
56164: LD_ADDR_VAR 0 6
56168: PUSH
56169: LD_VAR 0 7
56173: PUSH
56174: LD_VAR 0 9
56178: PUSH
56179: EMPTY
56180: LIST
56181: LIST
56182: PUSH
56183: EMPTY
56184: LIST
56185: ST_TO_ADDR
56186: GO 56330
// begin if result [ result ] [ 2 ] < tmp then
56188: LD_VAR 0 6
56192: PUSH
56193: LD_VAR 0 6
56197: ARRAY
56198: PUSH
56199: LD_INT 2
56201: ARRAY
56202: PUSH
56203: LD_VAR 0 9
56207: LESS
56208: IFFALSE 56250
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56210: LD_ADDR_VAR 0 6
56214: PUSH
56215: LD_VAR 0 6
56219: PPUSH
56220: LD_VAR 0 6
56224: PUSH
56225: LD_INT 1
56227: PLUS
56228: PPUSH
56229: LD_VAR 0 7
56233: PUSH
56234: LD_VAR 0 9
56238: PUSH
56239: EMPTY
56240: LIST
56241: LIST
56242: PPUSH
56243: CALL_OW 2
56247: ST_TO_ADDR
56248: GO 56330
// for j = 1 to result do
56250: LD_ADDR_VAR 0 8
56254: PUSH
56255: DOUBLE
56256: LD_INT 1
56258: DEC
56259: ST_TO_ADDR
56260: LD_VAR 0 6
56264: PUSH
56265: FOR_TO
56266: IFFALSE 56328
// begin if tmp < result [ j ] [ 2 ] then
56268: LD_VAR 0 9
56272: PUSH
56273: LD_VAR 0 6
56277: PUSH
56278: LD_VAR 0 8
56282: ARRAY
56283: PUSH
56284: LD_INT 2
56286: ARRAY
56287: LESS
56288: IFFALSE 56326
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56290: LD_ADDR_VAR 0 6
56294: PUSH
56295: LD_VAR 0 6
56299: PPUSH
56300: LD_VAR 0 8
56304: PPUSH
56305: LD_VAR 0 7
56309: PUSH
56310: LD_VAR 0 9
56314: PUSH
56315: EMPTY
56316: LIST
56317: LIST
56318: PPUSH
56319: CALL_OW 2
56323: ST_TO_ADDR
// break ;
56324: GO 56328
// end ; end ;
56326: GO 56265
56328: POP
56329: POP
// end ; end ;
56330: GO 56129
56332: POP
56333: POP
// if result and not asc then
56334: LD_VAR 0 6
56338: PUSH
56339: LD_VAR 0 4
56343: NOT
56344: AND
56345: IFFALSE 56420
// begin tmp := result ;
56347: LD_ADDR_VAR 0 9
56351: PUSH
56352: LD_VAR 0 6
56356: ST_TO_ADDR
// for i = tmp downto 1 do
56357: LD_ADDR_VAR 0 7
56361: PUSH
56362: DOUBLE
56363: LD_VAR 0 9
56367: INC
56368: ST_TO_ADDR
56369: LD_INT 1
56371: PUSH
56372: FOR_DOWNTO
56373: IFFALSE 56418
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56375: LD_ADDR_VAR 0 6
56379: PUSH
56380: LD_VAR 0 6
56384: PPUSH
56385: LD_VAR 0 9
56389: PUSH
56390: LD_VAR 0 7
56394: MINUS
56395: PUSH
56396: LD_INT 1
56398: PLUS
56399: PPUSH
56400: LD_VAR 0 9
56404: PUSH
56405: LD_VAR 0 7
56409: ARRAY
56410: PPUSH
56411: CALL_OW 1
56415: ST_TO_ADDR
56416: GO 56372
56418: POP
56419: POP
// end ; tmp := [ ] ;
56420: LD_ADDR_VAR 0 9
56424: PUSH
56425: EMPTY
56426: ST_TO_ADDR
// if mode then
56427: LD_VAR 0 5
56431: IFFALSE 56500
// begin for i = 1 to result do
56433: LD_ADDR_VAR 0 7
56437: PUSH
56438: DOUBLE
56439: LD_INT 1
56441: DEC
56442: ST_TO_ADDR
56443: LD_VAR 0 6
56447: PUSH
56448: FOR_TO
56449: IFFALSE 56488
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
56451: LD_ADDR_VAR 0 9
56455: PUSH
56456: LD_VAR 0 9
56460: PPUSH
56461: LD_VAR 0 7
56465: PPUSH
56466: LD_VAR 0 6
56470: PUSH
56471: LD_VAR 0 7
56475: ARRAY
56476: PUSH
56477: LD_INT 1
56479: ARRAY
56480: PPUSH
56481: CALL_OW 1
56485: ST_TO_ADDR
56486: GO 56448
56488: POP
56489: POP
// result := tmp ;
56490: LD_ADDR_VAR 0 6
56494: PUSH
56495: LD_VAR 0 9
56499: ST_TO_ADDR
// end ; end ;
56500: LD_VAR 0 6
56504: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
56505: LD_INT 0
56507: PPUSH
56508: PPUSH
56509: PPUSH
56510: PPUSH
56511: PPUSH
56512: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
56513: LD_ADDR_VAR 0 5
56517: PUSH
56518: LD_INT 0
56520: PUSH
56521: LD_INT 0
56523: PUSH
56524: LD_INT 0
56526: PUSH
56527: EMPTY
56528: PUSH
56529: EMPTY
56530: LIST
56531: LIST
56532: LIST
56533: LIST
56534: ST_TO_ADDR
// if not x or not y then
56535: LD_VAR 0 2
56539: NOT
56540: PUSH
56541: LD_VAR 0 3
56545: NOT
56546: OR
56547: IFFALSE 56551
// exit ;
56549: GO 58197
// if not range then
56551: LD_VAR 0 4
56555: NOT
56556: IFFALSE 56566
// range := 10 ;
56558: LD_ADDR_VAR 0 4
56562: PUSH
56563: LD_INT 10
56565: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56566: LD_ADDR_VAR 0 8
56570: PUSH
56571: LD_INT 81
56573: PUSH
56574: LD_VAR 0 1
56578: PUSH
56579: EMPTY
56580: LIST
56581: LIST
56582: PUSH
56583: LD_INT 92
56585: PUSH
56586: LD_VAR 0 2
56590: PUSH
56591: LD_VAR 0 3
56595: PUSH
56596: LD_VAR 0 4
56600: PUSH
56601: EMPTY
56602: LIST
56603: LIST
56604: LIST
56605: LIST
56606: PUSH
56607: LD_INT 3
56609: PUSH
56610: LD_INT 21
56612: PUSH
56613: LD_INT 3
56615: PUSH
56616: EMPTY
56617: LIST
56618: LIST
56619: PUSH
56620: EMPTY
56621: LIST
56622: LIST
56623: PUSH
56624: EMPTY
56625: LIST
56626: LIST
56627: LIST
56628: PPUSH
56629: CALL_OW 69
56633: ST_TO_ADDR
// if not tmp then
56634: LD_VAR 0 8
56638: NOT
56639: IFFALSE 56643
// exit ;
56641: GO 58197
// for i in tmp do
56643: LD_ADDR_VAR 0 6
56647: PUSH
56648: LD_VAR 0 8
56652: PUSH
56653: FOR_IN
56654: IFFALSE 58172
// begin points := [ 0 , 0 , 0 ] ;
56656: LD_ADDR_VAR 0 9
56660: PUSH
56661: LD_INT 0
56663: PUSH
56664: LD_INT 0
56666: PUSH
56667: LD_INT 0
56669: PUSH
56670: EMPTY
56671: LIST
56672: LIST
56673: LIST
56674: ST_TO_ADDR
// bpoints := 1 ;
56675: LD_ADDR_VAR 0 10
56679: PUSH
56680: LD_INT 1
56682: ST_TO_ADDR
// case GetType ( i ) of unit_human :
56683: LD_VAR 0 6
56687: PPUSH
56688: CALL_OW 247
56692: PUSH
56693: LD_INT 1
56695: DOUBLE
56696: EQUAL
56697: IFTRUE 56701
56699: GO 57279
56701: POP
// begin if GetClass ( i ) = 1 then
56702: LD_VAR 0 6
56706: PPUSH
56707: CALL_OW 257
56711: PUSH
56712: LD_INT 1
56714: EQUAL
56715: IFFALSE 56736
// points := [ 10 , 5 , 3 ] ;
56717: LD_ADDR_VAR 0 9
56721: PUSH
56722: LD_INT 10
56724: PUSH
56725: LD_INT 5
56727: PUSH
56728: LD_INT 3
56730: PUSH
56731: EMPTY
56732: LIST
56733: LIST
56734: LIST
56735: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
56736: LD_VAR 0 6
56740: PPUSH
56741: CALL_OW 257
56745: PUSH
56746: LD_INT 2
56748: PUSH
56749: LD_INT 3
56751: PUSH
56752: LD_INT 4
56754: PUSH
56755: EMPTY
56756: LIST
56757: LIST
56758: LIST
56759: IN
56760: IFFALSE 56781
// points := [ 3 , 2 , 1 ] ;
56762: LD_ADDR_VAR 0 9
56766: PUSH
56767: LD_INT 3
56769: PUSH
56770: LD_INT 2
56772: PUSH
56773: LD_INT 1
56775: PUSH
56776: EMPTY
56777: LIST
56778: LIST
56779: LIST
56780: ST_TO_ADDR
// if GetClass ( i ) = 5 then
56781: LD_VAR 0 6
56785: PPUSH
56786: CALL_OW 257
56790: PUSH
56791: LD_INT 5
56793: EQUAL
56794: IFFALSE 56815
// points := [ 130 , 5 , 2 ] ;
56796: LD_ADDR_VAR 0 9
56800: PUSH
56801: LD_INT 130
56803: PUSH
56804: LD_INT 5
56806: PUSH
56807: LD_INT 2
56809: PUSH
56810: EMPTY
56811: LIST
56812: LIST
56813: LIST
56814: ST_TO_ADDR
// if GetClass ( i ) = 8 then
56815: LD_VAR 0 6
56819: PPUSH
56820: CALL_OW 257
56824: PUSH
56825: LD_INT 8
56827: EQUAL
56828: IFFALSE 56849
// points := [ 35 , 35 , 30 ] ;
56830: LD_ADDR_VAR 0 9
56834: PUSH
56835: LD_INT 35
56837: PUSH
56838: LD_INT 35
56840: PUSH
56841: LD_INT 30
56843: PUSH
56844: EMPTY
56845: LIST
56846: LIST
56847: LIST
56848: ST_TO_ADDR
// if GetClass ( i ) = 9 then
56849: LD_VAR 0 6
56853: PPUSH
56854: CALL_OW 257
56858: PUSH
56859: LD_INT 9
56861: EQUAL
56862: IFFALSE 56883
// points := [ 20 , 55 , 40 ] ;
56864: LD_ADDR_VAR 0 9
56868: PUSH
56869: LD_INT 20
56871: PUSH
56872: LD_INT 55
56874: PUSH
56875: LD_INT 40
56877: PUSH
56878: EMPTY
56879: LIST
56880: LIST
56881: LIST
56882: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
56883: LD_VAR 0 6
56887: PPUSH
56888: CALL_OW 257
56892: PUSH
56893: LD_INT 12
56895: PUSH
56896: LD_INT 16
56898: PUSH
56899: EMPTY
56900: LIST
56901: LIST
56902: IN
56903: IFFALSE 56924
// points := [ 5 , 3 , 2 ] ;
56905: LD_ADDR_VAR 0 9
56909: PUSH
56910: LD_INT 5
56912: PUSH
56913: LD_INT 3
56915: PUSH
56916: LD_INT 2
56918: PUSH
56919: EMPTY
56920: LIST
56921: LIST
56922: LIST
56923: ST_TO_ADDR
// if GetClass ( i ) = 17 then
56924: LD_VAR 0 6
56928: PPUSH
56929: CALL_OW 257
56933: PUSH
56934: LD_INT 17
56936: EQUAL
56937: IFFALSE 56958
// points := [ 100 , 50 , 75 ] ;
56939: LD_ADDR_VAR 0 9
56943: PUSH
56944: LD_INT 100
56946: PUSH
56947: LD_INT 50
56949: PUSH
56950: LD_INT 75
56952: PUSH
56953: EMPTY
56954: LIST
56955: LIST
56956: LIST
56957: ST_TO_ADDR
// if GetClass ( i ) = 15 then
56958: LD_VAR 0 6
56962: PPUSH
56963: CALL_OW 257
56967: PUSH
56968: LD_INT 15
56970: EQUAL
56971: IFFALSE 56992
// points := [ 10 , 5 , 3 ] ;
56973: LD_ADDR_VAR 0 9
56977: PUSH
56978: LD_INT 10
56980: PUSH
56981: LD_INT 5
56983: PUSH
56984: LD_INT 3
56986: PUSH
56987: EMPTY
56988: LIST
56989: LIST
56990: LIST
56991: ST_TO_ADDR
// if GetClass ( i ) = 14 then
56992: LD_VAR 0 6
56996: PPUSH
56997: CALL_OW 257
57001: PUSH
57002: LD_INT 14
57004: EQUAL
57005: IFFALSE 57026
// points := [ 10 , 0 , 0 ] ;
57007: LD_ADDR_VAR 0 9
57011: PUSH
57012: LD_INT 10
57014: PUSH
57015: LD_INT 0
57017: PUSH
57018: LD_INT 0
57020: PUSH
57021: EMPTY
57022: LIST
57023: LIST
57024: LIST
57025: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57026: LD_VAR 0 6
57030: PPUSH
57031: CALL_OW 257
57035: PUSH
57036: LD_INT 11
57038: EQUAL
57039: IFFALSE 57060
// points := [ 30 , 10 , 5 ] ;
57041: LD_ADDR_VAR 0 9
57045: PUSH
57046: LD_INT 30
57048: PUSH
57049: LD_INT 10
57051: PUSH
57052: LD_INT 5
57054: PUSH
57055: EMPTY
57056: LIST
57057: LIST
57058: LIST
57059: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57060: LD_VAR 0 1
57064: PPUSH
57065: LD_INT 5
57067: PPUSH
57068: CALL_OW 321
57072: PUSH
57073: LD_INT 2
57075: EQUAL
57076: IFFALSE 57093
// bpoints := bpoints * 1.8 ;
57078: LD_ADDR_VAR 0 10
57082: PUSH
57083: LD_VAR 0 10
57087: PUSH
57088: LD_REAL  1.80000000000000E+0000
57091: MUL
57092: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57093: LD_VAR 0 6
57097: PPUSH
57098: CALL_OW 257
57102: PUSH
57103: LD_INT 1
57105: PUSH
57106: LD_INT 2
57108: PUSH
57109: LD_INT 3
57111: PUSH
57112: LD_INT 4
57114: PUSH
57115: EMPTY
57116: LIST
57117: LIST
57118: LIST
57119: LIST
57120: IN
57121: PUSH
57122: LD_VAR 0 1
57126: PPUSH
57127: LD_INT 51
57129: PPUSH
57130: CALL_OW 321
57134: PUSH
57135: LD_INT 2
57137: EQUAL
57138: AND
57139: IFFALSE 57156
// bpoints := bpoints * 1.2 ;
57141: LD_ADDR_VAR 0 10
57145: PUSH
57146: LD_VAR 0 10
57150: PUSH
57151: LD_REAL  1.20000000000000E+0000
57154: MUL
57155: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57156: LD_VAR 0 6
57160: PPUSH
57161: CALL_OW 257
57165: PUSH
57166: LD_INT 5
57168: PUSH
57169: LD_INT 7
57171: PUSH
57172: LD_INT 9
57174: PUSH
57175: EMPTY
57176: LIST
57177: LIST
57178: LIST
57179: IN
57180: PUSH
57181: LD_VAR 0 1
57185: PPUSH
57186: LD_INT 52
57188: PPUSH
57189: CALL_OW 321
57193: PUSH
57194: LD_INT 2
57196: EQUAL
57197: AND
57198: IFFALSE 57215
// bpoints := bpoints * 1.5 ;
57200: LD_ADDR_VAR 0 10
57204: PUSH
57205: LD_VAR 0 10
57209: PUSH
57210: LD_REAL  1.50000000000000E+0000
57213: MUL
57214: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57215: LD_VAR 0 1
57219: PPUSH
57220: LD_INT 66
57222: PPUSH
57223: CALL_OW 321
57227: PUSH
57228: LD_INT 2
57230: EQUAL
57231: IFFALSE 57248
// bpoints := bpoints * 1.1 ;
57233: LD_ADDR_VAR 0 10
57237: PUSH
57238: LD_VAR 0 10
57242: PUSH
57243: LD_REAL  1.10000000000000E+0000
57246: MUL
57247: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57248: LD_ADDR_VAR 0 10
57252: PUSH
57253: LD_VAR 0 10
57257: PUSH
57258: LD_VAR 0 6
57262: PPUSH
57263: LD_INT 1
57265: PPUSH
57266: CALL_OW 259
57270: PUSH
57271: LD_REAL  1.15000000000000E+0000
57274: MUL
57275: MUL
57276: ST_TO_ADDR
// end ; unit_vehicle :
57277: GO 58101
57279: LD_INT 2
57281: DOUBLE
57282: EQUAL
57283: IFTRUE 57287
57285: GO 58089
57287: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57288: LD_VAR 0 6
57292: PPUSH
57293: CALL_OW 264
57297: PUSH
57298: LD_INT 2
57300: PUSH
57301: LD_INT 42
57303: PUSH
57304: LD_INT 24
57306: PUSH
57307: EMPTY
57308: LIST
57309: LIST
57310: LIST
57311: IN
57312: IFFALSE 57333
// points := [ 25 , 5 , 3 ] ;
57314: LD_ADDR_VAR 0 9
57318: PUSH
57319: LD_INT 25
57321: PUSH
57322: LD_INT 5
57324: PUSH
57325: LD_INT 3
57327: PUSH
57328: EMPTY
57329: LIST
57330: LIST
57331: LIST
57332: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57333: LD_VAR 0 6
57337: PPUSH
57338: CALL_OW 264
57342: PUSH
57343: LD_INT 4
57345: PUSH
57346: LD_INT 43
57348: PUSH
57349: LD_INT 25
57351: PUSH
57352: EMPTY
57353: LIST
57354: LIST
57355: LIST
57356: IN
57357: IFFALSE 57378
// points := [ 40 , 15 , 5 ] ;
57359: LD_ADDR_VAR 0 9
57363: PUSH
57364: LD_INT 40
57366: PUSH
57367: LD_INT 15
57369: PUSH
57370: LD_INT 5
57372: PUSH
57373: EMPTY
57374: LIST
57375: LIST
57376: LIST
57377: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57378: LD_VAR 0 6
57382: PPUSH
57383: CALL_OW 264
57387: PUSH
57388: LD_INT 3
57390: PUSH
57391: LD_INT 23
57393: PUSH
57394: EMPTY
57395: LIST
57396: LIST
57397: IN
57398: IFFALSE 57419
// points := [ 7 , 25 , 8 ] ;
57400: LD_ADDR_VAR 0 9
57404: PUSH
57405: LD_INT 7
57407: PUSH
57408: LD_INT 25
57410: PUSH
57411: LD_INT 8
57413: PUSH
57414: EMPTY
57415: LIST
57416: LIST
57417: LIST
57418: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
57419: LD_VAR 0 6
57423: PPUSH
57424: CALL_OW 264
57428: PUSH
57429: LD_INT 5
57431: PUSH
57432: LD_INT 27
57434: PUSH
57435: LD_INT 44
57437: PUSH
57438: EMPTY
57439: LIST
57440: LIST
57441: LIST
57442: IN
57443: IFFALSE 57464
// points := [ 14 , 50 , 16 ] ;
57445: LD_ADDR_VAR 0 9
57449: PUSH
57450: LD_INT 14
57452: PUSH
57453: LD_INT 50
57455: PUSH
57456: LD_INT 16
57458: PUSH
57459: EMPTY
57460: LIST
57461: LIST
57462: LIST
57463: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
57464: LD_VAR 0 6
57468: PPUSH
57469: CALL_OW 264
57473: PUSH
57474: LD_INT 6
57476: PUSH
57477: LD_INT 46
57479: PUSH
57480: EMPTY
57481: LIST
57482: LIST
57483: IN
57484: IFFALSE 57505
// points := [ 32 , 120 , 70 ] ;
57486: LD_ADDR_VAR 0 9
57490: PUSH
57491: LD_INT 32
57493: PUSH
57494: LD_INT 120
57496: PUSH
57497: LD_INT 70
57499: PUSH
57500: EMPTY
57501: LIST
57502: LIST
57503: LIST
57504: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
57505: LD_VAR 0 6
57509: PPUSH
57510: CALL_OW 264
57514: PUSH
57515: LD_INT 7
57517: PUSH
57518: LD_INT 28
57520: PUSH
57521: LD_INT 45
57523: PUSH
57524: EMPTY
57525: LIST
57526: LIST
57527: LIST
57528: IN
57529: IFFALSE 57550
// points := [ 35 , 20 , 45 ] ;
57531: LD_ADDR_VAR 0 9
57535: PUSH
57536: LD_INT 35
57538: PUSH
57539: LD_INT 20
57541: PUSH
57542: LD_INT 45
57544: PUSH
57545: EMPTY
57546: LIST
57547: LIST
57548: LIST
57549: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
57550: LD_VAR 0 6
57554: PPUSH
57555: CALL_OW 264
57559: PUSH
57560: LD_INT 47
57562: PUSH
57563: EMPTY
57564: LIST
57565: IN
57566: IFFALSE 57587
// points := [ 67 , 45 , 75 ] ;
57568: LD_ADDR_VAR 0 9
57572: PUSH
57573: LD_INT 67
57575: PUSH
57576: LD_INT 45
57578: PUSH
57579: LD_INT 75
57581: PUSH
57582: EMPTY
57583: LIST
57584: LIST
57585: LIST
57586: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
57587: LD_VAR 0 6
57591: PPUSH
57592: CALL_OW 264
57596: PUSH
57597: LD_INT 26
57599: PUSH
57600: EMPTY
57601: LIST
57602: IN
57603: IFFALSE 57624
// points := [ 120 , 30 , 80 ] ;
57605: LD_ADDR_VAR 0 9
57609: PUSH
57610: LD_INT 120
57612: PUSH
57613: LD_INT 30
57615: PUSH
57616: LD_INT 80
57618: PUSH
57619: EMPTY
57620: LIST
57621: LIST
57622: LIST
57623: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
57624: LD_VAR 0 6
57628: PPUSH
57629: CALL_OW 264
57633: PUSH
57634: LD_INT 22
57636: PUSH
57637: EMPTY
57638: LIST
57639: IN
57640: IFFALSE 57661
// points := [ 40 , 1 , 1 ] ;
57642: LD_ADDR_VAR 0 9
57646: PUSH
57647: LD_INT 40
57649: PUSH
57650: LD_INT 1
57652: PUSH
57653: LD_INT 1
57655: PUSH
57656: EMPTY
57657: LIST
57658: LIST
57659: LIST
57660: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
57661: LD_VAR 0 6
57665: PPUSH
57666: CALL_OW 264
57670: PUSH
57671: LD_INT 29
57673: PUSH
57674: EMPTY
57675: LIST
57676: IN
57677: IFFALSE 57698
// points := [ 70 , 200 , 400 ] ;
57679: LD_ADDR_VAR 0 9
57683: PUSH
57684: LD_INT 70
57686: PUSH
57687: LD_INT 200
57689: PUSH
57690: LD_INT 400
57692: PUSH
57693: EMPTY
57694: LIST
57695: LIST
57696: LIST
57697: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
57698: LD_VAR 0 6
57702: PPUSH
57703: CALL_OW 264
57707: PUSH
57708: LD_INT 14
57710: PUSH
57711: LD_INT 53
57713: PUSH
57714: EMPTY
57715: LIST
57716: LIST
57717: IN
57718: IFFALSE 57739
// points := [ 40 , 10 , 20 ] ;
57720: LD_ADDR_VAR 0 9
57724: PUSH
57725: LD_INT 40
57727: PUSH
57728: LD_INT 10
57730: PUSH
57731: LD_INT 20
57733: PUSH
57734: EMPTY
57735: LIST
57736: LIST
57737: LIST
57738: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
57739: LD_VAR 0 6
57743: PPUSH
57744: CALL_OW 264
57748: PUSH
57749: LD_INT 9
57751: PUSH
57752: EMPTY
57753: LIST
57754: IN
57755: IFFALSE 57776
// points := [ 5 , 70 , 20 ] ;
57757: LD_ADDR_VAR 0 9
57761: PUSH
57762: LD_INT 5
57764: PUSH
57765: LD_INT 70
57767: PUSH
57768: LD_INT 20
57770: PUSH
57771: EMPTY
57772: LIST
57773: LIST
57774: LIST
57775: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
57776: LD_VAR 0 6
57780: PPUSH
57781: CALL_OW 264
57785: PUSH
57786: LD_INT 10
57788: PUSH
57789: EMPTY
57790: LIST
57791: IN
57792: IFFALSE 57813
// points := [ 35 , 110 , 70 ] ;
57794: LD_ADDR_VAR 0 9
57798: PUSH
57799: LD_INT 35
57801: PUSH
57802: LD_INT 110
57804: PUSH
57805: LD_INT 70
57807: PUSH
57808: EMPTY
57809: LIST
57810: LIST
57811: LIST
57812: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
57813: LD_VAR 0 6
57817: PPUSH
57818: CALL_OW 265
57822: PUSH
57823: LD_INT 25
57825: EQUAL
57826: IFFALSE 57847
// points := [ 80 , 65 , 100 ] ;
57828: LD_ADDR_VAR 0 9
57832: PUSH
57833: LD_INT 80
57835: PUSH
57836: LD_INT 65
57838: PUSH
57839: LD_INT 100
57841: PUSH
57842: EMPTY
57843: LIST
57844: LIST
57845: LIST
57846: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
57847: LD_VAR 0 6
57851: PPUSH
57852: CALL_OW 263
57856: PUSH
57857: LD_INT 1
57859: EQUAL
57860: IFFALSE 57895
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
57862: LD_ADDR_VAR 0 10
57866: PUSH
57867: LD_VAR 0 10
57871: PUSH
57872: LD_VAR 0 6
57876: PPUSH
57877: CALL_OW 311
57881: PPUSH
57882: LD_INT 3
57884: PPUSH
57885: CALL_OW 259
57889: PUSH
57890: LD_INT 4
57892: MUL
57893: MUL
57894: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
57895: LD_VAR 0 6
57899: PPUSH
57900: CALL_OW 263
57904: PUSH
57905: LD_INT 2
57907: EQUAL
57908: IFFALSE 57959
// begin j := IsControledBy ( i ) ;
57910: LD_ADDR_VAR 0 7
57914: PUSH
57915: LD_VAR 0 6
57919: PPUSH
57920: CALL_OW 312
57924: ST_TO_ADDR
// if j then
57925: LD_VAR 0 7
57929: IFFALSE 57959
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
57931: LD_ADDR_VAR 0 10
57935: PUSH
57936: LD_VAR 0 10
57940: PUSH
57941: LD_VAR 0 7
57945: PPUSH
57946: LD_INT 3
57948: PPUSH
57949: CALL_OW 259
57953: PUSH
57954: LD_INT 3
57956: MUL
57957: MUL
57958: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
57959: LD_VAR 0 6
57963: PPUSH
57964: CALL_OW 264
57968: PUSH
57969: LD_INT 5
57971: PUSH
57972: LD_INT 6
57974: PUSH
57975: LD_INT 46
57977: PUSH
57978: LD_INT 44
57980: PUSH
57981: LD_INT 47
57983: PUSH
57984: LD_INT 45
57986: PUSH
57987: LD_INT 28
57989: PUSH
57990: LD_INT 7
57992: PUSH
57993: LD_INT 27
57995: PUSH
57996: LD_INT 29
57998: PUSH
57999: EMPTY
58000: LIST
58001: LIST
58002: LIST
58003: LIST
58004: LIST
58005: LIST
58006: LIST
58007: LIST
58008: LIST
58009: LIST
58010: IN
58011: PUSH
58012: LD_VAR 0 1
58016: PPUSH
58017: LD_INT 52
58019: PPUSH
58020: CALL_OW 321
58024: PUSH
58025: LD_INT 2
58027: EQUAL
58028: AND
58029: IFFALSE 58046
// bpoints := bpoints * 1.2 ;
58031: LD_ADDR_VAR 0 10
58035: PUSH
58036: LD_VAR 0 10
58040: PUSH
58041: LD_REAL  1.20000000000000E+0000
58044: MUL
58045: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58046: LD_VAR 0 6
58050: PPUSH
58051: CALL_OW 264
58055: PUSH
58056: LD_INT 6
58058: PUSH
58059: LD_INT 46
58061: PUSH
58062: LD_INT 47
58064: PUSH
58065: EMPTY
58066: LIST
58067: LIST
58068: LIST
58069: IN
58070: IFFALSE 58087
// bpoints := bpoints * 1.2 ;
58072: LD_ADDR_VAR 0 10
58076: PUSH
58077: LD_VAR 0 10
58081: PUSH
58082: LD_REAL  1.20000000000000E+0000
58085: MUL
58086: ST_TO_ADDR
// end ; unit_building :
58087: GO 58101
58089: LD_INT 3
58091: DOUBLE
58092: EQUAL
58093: IFTRUE 58097
58095: GO 58100
58097: POP
// ; end ;
58098: GO 58101
58100: POP
// for j = 1 to 3 do
58101: LD_ADDR_VAR 0 7
58105: PUSH
58106: DOUBLE
58107: LD_INT 1
58109: DEC
58110: ST_TO_ADDR
58111: LD_INT 3
58113: PUSH
58114: FOR_TO
58115: IFFALSE 58168
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58117: LD_ADDR_VAR 0 5
58121: PUSH
58122: LD_VAR 0 5
58126: PPUSH
58127: LD_VAR 0 7
58131: PPUSH
58132: LD_VAR 0 5
58136: PUSH
58137: LD_VAR 0 7
58141: ARRAY
58142: PUSH
58143: LD_VAR 0 9
58147: PUSH
58148: LD_VAR 0 7
58152: ARRAY
58153: PUSH
58154: LD_VAR 0 10
58158: MUL
58159: PLUS
58160: PPUSH
58161: CALL_OW 1
58165: ST_TO_ADDR
58166: GO 58114
58168: POP
58169: POP
// end ;
58170: GO 56653
58172: POP
58173: POP
// result := Replace ( result , 4 , tmp ) ;
58174: LD_ADDR_VAR 0 5
58178: PUSH
58179: LD_VAR 0 5
58183: PPUSH
58184: LD_INT 4
58186: PPUSH
58187: LD_VAR 0 8
58191: PPUSH
58192: CALL_OW 1
58196: ST_TO_ADDR
// end ;
58197: LD_VAR 0 5
58201: RET
// export function DangerAtRange ( unit , range ) ; begin
58202: LD_INT 0
58204: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58205: LD_ADDR_VAR 0 3
58209: PUSH
58210: LD_VAR 0 1
58214: PPUSH
58215: CALL_OW 255
58219: PPUSH
58220: LD_VAR 0 1
58224: PPUSH
58225: CALL_OW 250
58229: PPUSH
58230: LD_VAR 0 1
58234: PPUSH
58235: CALL_OW 251
58239: PPUSH
58240: LD_VAR 0 2
58244: PPUSH
58245: CALL 56505 0 4
58249: ST_TO_ADDR
// end ;
58250: LD_VAR 0 3
58254: RET
// export function DangerInArea ( side , area ) ; begin
58255: LD_INT 0
58257: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58258: LD_ADDR_VAR 0 3
58262: PUSH
58263: LD_VAR 0 2
58267: PPUSH
58268: LD_INT 81
58270: PUSH
58271: LD_VAR 0 1
58275: PUSH
58276: EMPTY
58277: LIST
58278: LIST
58279: PPUSH
58280: CALL_OW 70
58284: ST_TO_ADDR
// end ;
58285: LD_VAR 0 3
58289: RET
// export function IsExtension ( b ) ; begin
58290: LD_INT 0
58292: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58293: LD_ADDR_VAR 0 2
58297: PUSH
58298: LD_VAR 0 1
58302: PUSH
58303: LD_INT 23
58305: PUSH
58306: LD_INT 20
58308: PUSH
58309: LD_INT 22
58311: PUSH
58312: LD_INT 17
58314: PUSH
58315: LD_INT 24
58317: PUSH
58318: LD_INT 21
58320: PUSH
58321: LD_INT 19
58323: PUSH
58324: LD_INT 16
58326: PUSH
58327: LD_INT 25
58329: PUSH
58330: LD_INT 18
58332: PUSH
58333: EMPTY
58334: LIST
58335: LIST
58336: LIST
58337: LIST
58338: LIST
58339: LIST
58340: LIST
58341: LIST
58342: LIST
58343: LIST
58344: IN
58345: ST_TO_ADDR
// end ;
58346: LD_VAR 0 2
58350: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
58351: LD_INT 0
58353: PPUSH
58354: PPUSH
58355: PPUSH
// result := [ ] ;
58356: LD_ADDR_VAR 0 3
58360: PUSH
58361: EMPTY
58362: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58363: LD_ADDR_VAR 0 4
58367: PUSH
58368: LD_VAR 0 2
58372: PPUSH
58373: LD_INT 21
58375: PUSH
58376: LD_INT 3
58378: PUSH
58379: EMPTY
58380: LIST
58381: LIST
58382: PPUSH
58383: CALL_OW 70
58387: ST_TO_ADDR
// if not tmp then
58388: LD_VAR 0 4
58392: NOT
58393: IFFALSE 58397
// exit ;
58395: GO 58455
// for i in tmp do
58397: LD_ADDR_VAR 0 5
58401: PUSH
58402: LD_VAR 0 4
58406: PUSH
58407: FOR_IN
58408: IFFALSE 58443
// if GetBase ( i ) <> base then
58410: LD_VAR 0 5
58414: PPUSH
58415: CALL_OW 274
58419: PUSH
58420: LD_VAR 0 1
58424: NONEQUAL
58425: IFFALSE 58441
// ComLinkToBase ( base , i ) ;
58427: LD_VAR 0 1
58431: PPUSH
58432: LD_VAR 0 5
58436: PPUSH
58437: CALL_OW 169
58441: GO 58407
58443: POP
58444: POP
// result := tmp ;
58445: LD_ADDR_VAR 0 3
58449: PUSH
58450: LD_VAR 0 4
58454: ST_TO_ADDR
// end ;
58455: LD_VAR 0 3
58459: RET
// export function ComComplete ( unit , b ) ; var i ; begin
58460: LD_INT 0
58462: PPUSH
58463: PPUSH
// if BuildingStatus ( b ) = bs_build then
58464: LD_VAR 0 2
58468: PPUSH
58469: CALL_OW 461
58473: PUSH
58474: LD_INT 1
58476: EQUAL
58477: IFFALSE 58537
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
58479: LD_VAR 0 1
58483: PPUSH
58484: LD_STRING h
58486: PUSH
58487: LD_VAR 0 2
58491: PPUSH
58492: CALL_OW 250
58496: PUSH
58497: LD_VAR 0 2
58501: PPUSH
58502: CALL_OW 251
58506: PUSH
58507: LD_VAR 0 2
58511: PUSH
58512: LD_INT 0
58514: PUSH
58515: LD_INT 0
58517: PUSH
58518: LD_INT 0
58520: PUSH
58521: EMPTY
58522: LIST
58523: LIST
58524: LIST
58525: LIST
58526: LIST
58527: LIST
58528: LIST
58529: PUSH
58530: EMPTY
58531: LIST
58532: PPUSH
58533: CALL_OW 446
// end ;
58537: LD_VAR 0 3
58541: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
58542: LD_INT 0
58544: PPUSH
58545: PPUSH
58546: PPUSH
58547: PPUSH
58548: PPUSH
58549: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
58550: LD_VAR 0 1
58554: NOT
58555: PUSH
58556: LD_VAR 0 1
58560: PPUSH
58561: CALL_OW 263
58565: PUSH
58566: LD_INT 2
58568: EQUAL
58569: NOT
58570: OR
58571: IFFALSE 58575
// exit ;
58573: GO 58891
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
58575: LD_ADDR_VAR 0 6
58579: PUSH
58580: LD_INT 22
58582: PUSH
58583: LD_VAR 0 1
58587: PPUSH
58588: CALL_OW 255
58592: PUSH
58593: EMPTY
58594: LIST
58595: LIST
58596: PUSH
58597: LD_INT 2
58599: PUSH
58600: LD_INT 30
58602: PUSH
58603: LD_INT 36
58605: PUSH
58606: EMPTY
58607: LIST
58608: LIST
58609: PUSH
58610: LD_INT 34
58612: PUSH
58613: LD_INT 31
58615: PUSH
58616: EMPTY
58617: LIST
58618: LIST
58619: PUSH
58620: EMPTY
58621: LIST
58622: LIST
58623: LIST
58624: PUSH
58625: EMPTY
58626: LIST
58627: LIST
58628: PPUSH
58629: CALL_OW 69
58633: ST_TO_ADDR
// if not tmp then
58634: LD_VAR 0 6
58638: NOT
58639: IFFALSE 58643
// exit ;
58641: GO 58891
// result := [ ] ;
58643: LD_ADDR_VAR 0 2
58647: PUSH
58648: EMPTY
58649: ST_TO_ADDR
// for i in tmp do
58650: LD_ADDR_VAR 0 3
58654: PUSH
58655: LD_VAR 0 6
58659: PUSH
58660: FOR_IN
58661: IFFALSE 58732
// begin t := UnitsInside ( i ) ;
58663: LD_ADDR_VAR 0 4
58667: PUSH
58668: LD_VAR 0 3
58672: PPUSH
58673: CALL_OW 313
58677: ST_TO_ADDR
// if t then
58678: LD_VAR 0 4
58682: IFFALSE 58730
// for j in t do
58684: LD_ADDR_VAR 0 7
58688: PUSH
58689: LD_VAR 0 4
58693: PUSH
58694: FOR_IN
58695: IFFALSE 58728
// result := Insert ( result , result + 1 , j ) ;
58697: LD_ADDR_VAR 0 2
58701: PUSH
58702: LD_VAR 0 2
58706: PPUSH
58707: LD_VAR 0 2
58711: PUSH
58712: LD_INT 1
58714: PLUS
58715: PPUSH
58716: LD_VAR 0 7
58720: PPUSH
58721: CALL_OW 2
58725: ST_TO_ADDR
58726: GO 58694
58728: POP
58729: POP
// end ;
58730: GO 58660
58732: POP
58733: POP
// if not result then
58734: LD_VAR 0 2
58738: NOT
58739: IFFALSE 58743
// exit ;
58741: GO 58891
// mech := result [ 1 ] ;
58743: LD_ADDR_VAR 0 5
58747: PUSH
58748: LD_VAR 0 2
58752: PUSH
58753: LD_INT 1
58755: ARRAY
58756: ST_TO_ADDR
// if result > 1 then
58757: LD_VAR 0 2
58761: PUSH
58762: LD_INT 1
58764: GREATER
58765: IFFALSE 58877
// for i = 2 to result do
58767: LD_ADDR_VAR 0 3
58771: PUSH
58772: DOUBLE
58773: LD_INT 2
58775: DEC
58776: ST_TO_ADDR
58777: LD_VAR 0 2
58781: PUSH
58782: FOR_TO
58783: IFFALSE 58875
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
58785: LD_ADDR_VAR 0 4
58789: PUSH
58790: LD_VAR 0 2
58794: PUSH
58795: LD_VAR 0 3
58799: ARRAY
58800: PPUSH
58801: LD_INT 3
58803: PPUSH
58804: CALL_OW 259
58808: PUSH
58809: LD_VAR 0 2
58813: PUSH
58814: LD_VAR 0 3
58818: ARRAY
58819: PPUSH
58820: CALL_OW 432
58824: MINUS
58825: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
58826: LD_VAR 0 4
58830: PUSH
58831: LD_VAR 0 5
58835: PPUSH
58836: LD_INT 3
58838: PPUSH
58839: CALL_OW 259
58843: PUSH
58844: LD_VAR 0 5
58848: PPUSH
58849: CALL_OW 432
58853: MINUS
58854: GREATEREQUAL
58855: IFFALSE 58873
// mech := result [ i ] ;
58857: LD_ADDR_VAR 0 5
58861: PUSH
58862: LD_VAR 0 2
58866: PUSH
58867: LD_VAR 0 3
58871: ARRAY
58872: ST_TO_ADDR
// end ;
58873: GO 58782
58875: POP
58876: POP
// ComLinkTo ( vehicle , mech ) ;
58877: LD_VAR 0 1
58881: PPUSH
58882: LD_VAR 0 5
58886: PPUSH
58887: CALL_OW 135
// end ;
58891: LD_VAR 0 2
58895: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
58896: LD_INT 0
58898: PPUSH
58899: PPUSH
58900: PPUSH
58901: PPUSH
58902: PPUSH
58903: PPUSH
58904: PPUSH
58905: PPUSH
58906: PPUSH
58907: PPUSH
58908: PPUSH
58909: PPUSH
58910: PPUSH
// result := [ ] ;
58911: LD_ADDR_VAR 0 7
58915: PUSH
58916: EMPTY
58917: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
58918: LD_VAR 0 1
58922: PPUSH
58923: CALL_OW 266
58927: PUSH
58928: LD_INT 0
58930: PUSH
58931: LD_INT 1
58933: PUSH
58934: EMPTY
58935: LIST
58936: LIST
58937: IN
58938: NOT
58939: IFFALSE 58943
// exit ;
58941: GO 60574
// if name then
58943: LD_VAR 0 3
58947: IFFALSE 58963
// SetBName ( base_dep , name ) ;
58949: LD_VAR 0 1
58953: PPUSH
58954: LD_VAR 0 3
58958: PPUSH
58959: CALL_OW 500
// base := GetBase ( base_dep ) ;
58963: LD_ADDR_VAR 0 15
58967: PUSH
58968: LD_VAR 0 1
58972: PPUSH
58973: CALL_OW 274
58977: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
58978: LD_ADDR_VAR 0 16
58982: PUSH
58983: LD_VAR 0 1
58987: PPUSH
58988: CALL_OW 255
58992: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
58993: LD_ADDR_VAR 0 17
58997: PUSH
58998: LD_VAR 0 1
59002: PPUSH
59003: CALL_OW 248
59007: ST_TO_ADDR
// if sources then
59008: LD_VAR 0 5
59012: IFFALSE 59059
// for i = 1 to 3 do
59014: LD_ADDR_VAR 0 8
59018: PUSH
59019: DOUBLE
59020: LD_INT 1
59022: DEC
59023: ST_TO_ADDR
59024: LD_INT 3
59026: PUSH
59027: FOR_TO
59028: IFFALSE 59057
// AddResourceType ( base , i , sources [ i ] ) ;
59030: LD_VAR 0 15
59034: PPUSH
59035: LD_VAR 0 8
59039: PPUSH
59040: LD_VAR 0 5
59044: PUSH
59045: LD_VAR 0 8
59049: ARRAY
59050: PPUSH
59051: CALL_OW 276
59055: GO 59027
59057: POP
59058: POP
// buildings := GetBaseBuildings ( base , area ) ;
59059: LD_ADDR_VAR 0 18
59063: PUSH
59064: LD_VAR 0 15
59068: PPUSH
59069: LD_VAR 0 2
59073: PPUSH
59074: CALL 58351 0 2
59078: ST_TO_ADDR
// InitHc ;
59079: CALL_OW 19
// InitUc ;
59083: CALL_OW 18
// uc_side := side ;
59087: LD_ADDR_OWVAR 20
59091: PUSH
59092: LD_VAR 0 16
59096: ST_TO_ADDR
// uc_nation := nation ;
59097: LD_ADDR_OWVAR 21
59101: PUSH
59102: LD_VAR 0 17
59106: ST_TO_ADDR
// if buildings then
59107: LD_VAR 0 18
59111: IFFALSE 60433
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59113: LD_ADDR_VAR 0 19
59117: PUSH
59118: LD_VAR 0 18
59122: PPUSH
59123: LD_INT 2
59125: PUSH
59126: LD_INT 30
59128: PUSH
59129: LD_INT 29
59131: PUSH
59132: EMPTY
59133: LIST
59134: LIST
59135: PUSH
59136: LD_INT 30
59138: PUSH
59139: LD_INT 30
59141: PUSH
59142: EMPTY
59143: LIST
59144: LIST
59145: PUSH
59146: EMPTY
59147: LIST
59148: LIST
59149: LIST
59150: PPUSH
59151: CALL_OW 72
59155: ST_TO_ADDR
// if tmp then
59156: LD_VAR 0 19
59160: IFFALSE 59208
// for i in tmp do
59162: LD_ADDR_VAR 0 8
59166: PUSH
59167: LD_VAR 0 19
59171: PUSH
59172: FOR_IN
59173: IFFALSE 59206
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59175: LD_VAR 0 8
59179: PPUSH
59180: CALL_OW 250
59184: PPUSH
59185: LD_VAR 0 8
59189: PPUSH
59190: CALL_OW 251
59194: PPUSH
59195: LD_VAR 0 16
59199: PPUSH
59200: CALL_OW 441
59204: GO 59172
59206: POP
59207: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59208: LD_VAR 0 18
59212: PPUSH
59213: LD_INT 2
59215: PUSH
59216: LD_INT 30
59218: PUSH
59219: LD_INT 32
59221: PUSH
59222: EMPTY
59223: LIST
59224: LIST
59225: PUSH
59226: LD_INT 30
59228: PUSH
59229: LD_INT 33
59231: PUSH
59232: EMPTY
59233: LIST
59234: LIST
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: LIST
59240: PPUSH
59241: CALL_OW 72
59245: IFFALSE 59333
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59247: LD_ADDR_VAR 0 8
59251: PUSH
59252: LD_VAR 0 18
59256: PPUSH
59257: LD_INT 2
59259: PUSH
59260: LD_INT 30
59262: PUSH
59263: LD_INT 32
59265: PUSH
59266: EMPTY
59267: LIST
59268: LIST
59269: PUSH
59270: LD_INT 30
59272: PUSH
59273: LD_INT 33
59275: PUSH
59276: EMPTY
59277: LIST
59278: LIST
59279: PUSH
59280: EMPTY
59281: LIST
59282: LIST
59283: LIST
59284: PPUSH
59285: CALL_OW 72
59289: PUSH
59290: FOR_IN
59291: IFFALSE 59331
// begin if not GetBWeapon ( i ) then
59293: LD_VAR 0 8
59297: PPUSH
59298: CALL_OW 269
59302: NOT
59303: IFFALSE 59329
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59305: LD_VAR 0 8
59309: PPUSH
59310: LD_VAR 0 8
59314: PPUSH
59315: LD_VAR 0 2
59319: PPUSH
59320: CALL 60579 0 2
59324: PPUSH
59325: CALL_OW 431
// end ;
59329: GO 59290
59331: POP
59332: POP
// end ; for i = 1 to personel do
59333: LD_ADDR_VAR 0 8
59337: PUSH
59338: DOUBLE
59339: LD_INT 1
59341: DEC
59342: ST_TO_ADDR
59343: LD_VAR 0 6
59347: PUSH
59348: FOR_TO
59349: IFFALSE 60413
// begin if i > 4 then
59351: LD_VAR 0 8
59355: PUSH
59356: LD_INT 4
59358: GREATER
59359: IFFALSE 59363
// break ;
59361: GO 60413
// case i of 1 :
59363: LD_VAR 0 8
59367: PUSH
59368: LD_INT 1
59370: DOUBLE
59371: EQUAL
59372: IFTRUE 59376
59374: GO 59456
59376: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59377: LD_ADDR_VAR 0 12
59381: PUSH
59382: LD_VAR 0 18
59386: PPUSH
59387: LD_INT 22
59389: PUSH
59390: LD_VAR 0 16
59394: PUSH
59395: EMPTY
59396: LIST
59397: LIST
59398: PUSH
59399: LD_INT 58
59401: PUSH
59402: EMPTY
59403: LIST
59404: PUSH
59405: LD_INT 2
59407: PUSH
59408: LD_INT 30
59410: PUSH
59411: LD_INT 32
59413: PUSH
59414: EMPTY
59415: LIST
59416: LIST
59417: PUSH
59418: LD_INT 30
59420: PUSH
59421: LD_INT 4
59423: PUSH
59424: EMPTY
59425: LIST
59426: LIST
59427: PUSH
59428: LD_INT 30
59430: PUSH
59431: LD_INT 5
59433: PUSH
59434: EMPTY
59435: LIST
59436: LIST
59437: PUSH
59438: EMPTY
59439: LIST
59440: LIST
59441: LIST
59442: LIST
59443: PUSH
59444: EMPTY
59445: LIST
59446: LIST
59447: LIST
59448: PPUSH
59449: CALL_OW 72
59453: ST_TO_ADDR
59454: GO 59678
59456: LD_INT 2
59458: DOUBLE
59459: EQUAL
59460: IFTRUE 59464
59462: GO 59526
59464: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
59465: LD_ADDR_VAR 0 12
59469: PUSH
59470: LD_VAR 0 18
59474: PPUSH
59475: LD_INT 22
59477: PUSH
59478: LD_VAR 0 16
59482: PUSH
59483: EMPTY
59484: LIST
59485: LIST
59486: PUSH
59487: LD_INT 2
59489: PUSH
59490: LD_INT 30
59492: PUSH
59493: LD_INT 0
59495: PUSH
59496: EMPTY
59497: LIST
59498: LIST
59499: PUSH
59500: LD_INT 30
59502: PUSH
59503: LD_INT 1
59505: PUSH
59506: EMPTY
59507: LIST
59508: LIST
59509: PUSH
59510: EMPTY
59511: LIST
59512: LIST
59513: LIST
59514: PUSH
59515: EMPTY
59516: LIST
59517: LIST
59518: PPUSH
59519: CALL_OW 72
59523: ST_TO_ADDR
59524: GO 59678
59526: LD_INT 3
59528: DOUBLE
59529: EQUAL
59530: IFTRUE 59534
59532: GO 59596
59534: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
59535: LD_ADDR_VAR 0 12
59539: PUSH
59540: LD_VAR 0 18
59544: PPUSH
59545: LD_INT 22
59547: PUSH
59548: LD_VAR 0 16
59552: PUSH
59553: EMPTY
59554: LIST
59555: LIST
59556: PUSH
59557: LD_INT 2
59559: PUSH
59560: LD_INT 30
59562: PUSH
59563: LD_INT 2
59565: PUSH
59566: EMPTY
59567: LIST
59568: LIST
59569: PUSH
59570: LD_INT 30
59572: PUSH
59573: LD_INT 3
59575: PUSH
59576: EMPTY
59577: LIST
59578: LIST
59579: PUSH
59580: EMPTY
59581: LIST
59582: LIST
59583: LIST
59584: PUSH
59585: EMPTY
59586: LIST
59587: LIST
59588: PPUSH
59589: CALL_OW 72
59593: ST_TO_ADDR
59594: GO 59678
59596: LD_INT 4
59598: DOUBLE
59599: EQUAL
59600: IFTRUE 59604
59602: GO 59677
59604: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
59605: LD_ADDR_VAR 0 12
59609: PUSH
59610: LD_VAR 0 18
59614: PPUSH
59615: LD_INT 22
59617: PUSH
59618: LD_VAR 0 16
59622: PUSH
59623: EMPTY
59624: LIST
59625: LIST
59626: PUSH
59627: LD_INT 2
59629: PUSH
59630: LD_INT 30
59632: PUSH
59633: LD_INT 6
59635: PUSH
59636: EMPTY
59637: LIST
59638: LIST
59639: PUSH
59640: LD_INT 30
59642: PUSH
59643: LD_INT 7
59645: PUSH
59646: EMPTY
59647: LIST
59648: LIST
59649: PUSH
59650: LD_INT 30
59652: PUSH
59653: LD_INT 8
59655: PUSH
59656: EMPTY
59657: LIST
59658: LIST
59659: PUSH
59660: EMPTY
59661: LIST
59662: LIST
59663: LIST
59664: LIST
59665: PUSH
59666: EMPTY
59667: LIST
59668: LIST
59669: PPUSH
59670: CALL_OW 72
59674: ST_TO_ADDR
59675: GO 59678
59677: POP
// if i = 1 then
59678: LD_VAR 0 8
59682: PUSH
59683: LD_INT 1
59685: EQUAL
59686: IFFALSE 59797
// begin tmp := [ ] ;
59688: LD_ADDR_VAR 0 19
59692: PUSH
59693: EMPTY
59694: ST_TO_ADDR
// for j in f do
59695: LD_ADDR_VAR 0 9
59699: PUSH
59700: LD_VAR 0 12
59704: PUSH
59705: FOR_IN
59706: IFFALSE 59779
// if GetBType ( j ) = b_bunker then
59708: LD_VAR 0 9
59712: PPUSH
59713: CALL_OW 266
59717: PUSH
59718: LD_INT 32
59720: EQUAL
59721: IFFALSE 59748
// tmp := Insert ( tmp , 1 , j ) else
59723: LD_ADDR_VAR 0 19
59727: PUSH
59728: LD_VAR 0 19
59732: PPUSH
59733: LD_INT 1
59735: PPUSH
59736: LD_VAR 0 9
59740: PPUSH
59741: CALL_OW 2
59745: ST_TO_ADDR
59746: GO 59777
// tmp := Insert ( tmp , tmp + 1 , j ) ;
59748: LD_ADDR_VAR 0 19
59752: PUSH
59753: LD_VAR 0 19
59757: PPUSH
59758: LD_VAR 0 19
59762: PUSH
59763: LD_INT 1
59765: PLUS
59766: PPUSH
59767: LD_VAR 0 9
59771: PPUSH
59772: CALL_OW 2
59776: ST_TO_ADDR
59777: GO 59705
59779: POP
59780: POP
// if tmp then
59781: LD_VAR 0 19
59785: IFFALSE 59797
// f := tmp ;
59787: LD_ADDR_VAR 0 12
59791: PUSH
59792: LD_VAR 0 19
59796: ST_TO_ADDR
// end ; x := personel [ i ] ;
59797: LD_ADDR_VAR 0 13
59801: PUSH
59802: LD_VAR 0 6
59806: PUSH
59807: LD_VAR 0 8
59811: ARRAY
59812: ST_TO_ADDR
// if x = - 1 then
59813: LD_VAR 0 13
59817: PUSH
59818: LD_INT 1
59820: NEG
59821: EQUAL
59822: IFFALSE 60031
// begin for j in f do
59824: LD_ADDR_VAR 0 9
59828: PUSH
59829: LD_VAR 0 12
59833: PUSH
59834: FOR_IN
59835: IFFALSE 60027
// repeat InitHc ;
59837: CALL_OW 19
// if GetBType ( j ) = b_barracks then
59841: LD_VAR 0 9
59845: PPUSH
59846: CALL_OW 266
59850: PUSH
59851: LD_INT 5
59853: EQUAL
59854: IFFALSE 59924
// begin if UnitsInside ( j ) < 3 then
59856: LD_VAR 0 9
59860: PPUSH
59861: CALL_OW 313
59865: PUSH
59866: LD_INT 3
59868: LESS
59869: IFFALSE 59905
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59871: LD_INT 0
59873: PPUSH
59874: LD_INT 5
59876: PUSH
59877: LD_INT 8
59879: PUSH
59880: LD_INT 9
59882: PUSH
59883: EMPTY
59884: LIST
59885: LIST
59886: LIST
59887: PUSH
59888: LD_VAR 0 17
59892: ARRAY
59893: PPUSH
59894: LD_VAR 0 4
59898: PPUSH
59899: CALL_OW 380
59903: GO 59922
// PrepareHuman ( false , i , skill ) ;
59905: LD_INT 0
59907: PPUSH
59908: LD_VAR 0 8
59912: PPUSH
59913: LD_VAR 0 4
59917: PPUSH
59918: CALL_OW 380
// end else
59922: GO 59941
// PrepareHuman ( false , i , skill ) ;
59924: LD_INT 0
59926: PPUSH
59927: LD_VAR 0 8
59931: PPUSH
59932: LD_VAR 0 4
59936: PPUSH
59937: CALL_OW 380
// un := CreateHuman ;
59941: LD_ADDR_VAR 0 14
59945: PUSH
59946: CALL_OW 44
59950: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59951: LD_ADDR_VAR 0 7
59955: PUSH
59956: LD_VAR 0 7
59960: PPUSH
59961: LD_INT 1
59963: PPUSH
59964: LD_VAR 0 14
59968: PPUSH
59969: CALL_OW 2
59973: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
59974: LD_VAR 0 14
59978: PPUSH
59979: LD_VAR 0 9
59983: PPUSH
59984: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
59988: LD_VAR 0 9
59992: PPUSH
59993: CALL_OW 313
59997: PUSH
59998: LD_INT 6
60000: EQUAL
60001: PUSH
60002: LD_VAR 0 9
60006: PPUSH
60007: CALL_OW 266
60011: PUSH
60012: LD_INT 32
60014: PUSH
60015: LD_INT 31
60017: PUSH
60018: EMPTY
60019: LIST
60020: LIST
60021: IN
60022: OR
60023: IFFALSE 59837
60025: GO 59834
60027: POP
60028: POP
// end else
60029: GO 60411
// for j = 1 to x do
60031: LD_ADDR_VAR 0 9
60035: PUSH
60036: DOUBLE
60037: LD_INT 1
60039: DEC
60040: ST_TO_ADDR
60041: LD_VAR 0 13
60045: PUSH
60046: FOR_TO
60047: IFFALSE 60409
// begin InitHc ;
60049: CALL_OW 19
// if not f then
60053: LD_VAR 0 12
60057: NOT
60058: IFFALSE 60147
// begin PrepareHuman ( false , i , skill ) ;
60060: LD_INT 0
60062: PPUSH
60063: LD_VAR 0 8
60067: PPUSH
60068: LD_VAR 0 4
60072: PPUSH
60073: CALL_OW 380
// un := CreateHuman ;
60077: LD_ADDR_VAR 0 14
60081: PUSH
60082: CALL_OW 44
60086: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60087: LD_ADDR_VAR 0 7
60091: PUSH
60092: LD_VAR 0 7
60096: PPUSH
60097: LD_INT 1
60099: PPUSH
60100: LD_VAR 0 14
60104: PPUSH
60105: CALL_OW 2
60109: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60110: LD_VAR 0 14
60114: PPUSH
60115: LD_VAR 0 1
60119: PPUSH
60120: CALL_OW 250
60124: PPUSH
60125: LD_VAR 0 1
60129: PPUSH
60130: CALL_OW 251
60134: PPUSH
60135: LD_INT 10
60137: PPUSH
60138: LD_INT 0
60140: PPUSH
60141: CALL_OW 50
// continue ;
60145: GO 60046
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60147: LD_VAR 0 12
60151: PUSH
60152: LD_INT 1
60154: ARRAY
60155: PPUSH
60156: CALL_OW 313
60160: PUSH
60161: LD_VAR 0 12
60165: PUSH
60166: LD_INT 1
60168: ARRAY
60169: PPUSH
60170: CALL_OW 266
60174: PUSH
60175: LD_INT 32
60177: PUSH
60178: LD_INT 31
60180: PUSH
60181: EMPTY
60182: LIST
60183: LIST
60184: IN
60185: AND
60186: PUSH
60187: LD_VAR 0 12
60191: PUSH
60192: LD_INT 1
60194: ARRAY
60195: PPUSH
60196: CALL_OW 313
60200: PUSH
60201: LD_INT 6
60203: EQUAL
60204: OR
60205: IFFALSE 60225
// f := Delete ( f , 1 ) ;
60207: LD_ADDR_VAR 0 12
60211: PUSH
60212: LD_VAR 0 12
60216: PPUSH
60217: LD_INT 1
60219: PPUSH
60220: CALL_OW 3
60224: ST_TO_ADDR
// if not f then
60225: LD_VAR 0 12
60229: NOT
60230: IFFALSE 60248
// begin x := x + 2 ;
60232: LD_ADDR_VAR 0 13
60236: PUSH
60237: LD_VAR 0 13
60241: PUSH
60242: LD_INT 2
60244: PLUS
60245: ST_TO_ADDR
// continue ;
60246: GO 60046
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60248: LD_VAR 0 12
60252: PUSH
60253: LD_INT 1
60255: ARRAY
60256: PPUSH
60257: CALL_OW 266
60261: PUSH
60262: LD_INT 5
60264: EQUAL
60265: IFFALSE 60339
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60267: LD_VAR 0 12
60271: PUSH
60272: LD_INT 1
60274: ARRAY
60275: PPUSH
60276: CALL_OW 313
60280: PUSH
60281: LD_INT 3
60283: LESS
60284: IFFALSE 60320
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60286: LD_INT 0
60288: PPUSH
60289: LD_INT 5
60291: PUSH
60292: LD_INT 8
60294: PUSH
60295: LD_INT 9
60297: PUSH
60298: EMPTY
60299: LIST
60300: LIST
60301: LIST
60302: PUSH
60303: LD_VAR 0 17
60307: ARRAY
60308: PPUSH
60309: LD_VAR 0 4
60313: PPUSH
60314: CALL_OW 380
60318: GO 60337
// PrepareHuman ( false , i , skill ) ;
60320: LD_INT 0
60322: PPUSH
60323: LD_VAR 0 8
60327: PPUSH
60328: LD_VAR 0 4
60332: PPUSH
60333: CALL_OW 380
// end else
60337: GO 60356
// PrepareHuman ( false , i , skill ) ;
60339: LD_INT 0
60341: PPUSH
60342: LD_VAR 0 8
60346: PPUSH
60347: LD_VAR 0 4
60351: PPUSH
60352: CALL_OW 380
// un := CreateHuman ;
60356: LD_ADDR_VAR 0 14
60360: PUSH
60361: CALL_OW 44
60365: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60366: LD_ADDR_VAR 0 7
60370: PUSH
60371: LD_VAR 0 7
60375: PPUSH
60376: LD_INT 1
60378: PPUSH
60379: LD_VAR 0 14
60383: PPUSH
60384: CALL_OW 2
60388: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
60389: LD_VAR 0 14
60393: PPUSH
60394: LD_VAR 0 12
60398: PUSH
60399: LD_INT 1
60401: ARRAY
60402: PPUSH
60403: CALL_OW 52
// end ;
60407: GO 60046
60409: POP
60410: POP
// end ;
60411: GO 59348
60413: POP
60414: POP
// result := result ^ buildings ;
60415: LD_ADDR_VAR 0 7
60419: PUSH
60420: LD_VAR 0 7
60424: PUSH
60425: LD_VAR 0 18
60429: ADD
60430: ST_TO_ADDR
// end else
60431: GO 60574
// begin for i = 1 to personel do
60433: LD_ADDR_VAR 0 8
60437: PUSH
60438: DOUBLE
60439: LD_INT 1
60441: DEC
60442: ST_TO_ADDR
60443: LD_VAR 0 6
60447: PUSH
60448: FOR_TO
60449: IFFALSE 60572
// begin if i > 4 then
60451: LD_VAR 0 8
60455: PUSH
60456: LD_INT 4
60458: GREATER
60459: IFFALSE 60463
// break ;
60461: GO 60572
// x := personel [ i ] ;
60463: LD_ADDR_VAR 0 13
60467: PUSH
60468: LD_VAR 0 6
60472: PUSH
60473: LD_VAR 0 8
60477: ARRAY
60478: ST_TO_ADDR
// if x = - 1 then
60479: LD_VAR 0 13
60483: PUSH
60484: LD_INT 1
60486: NEG
60487: EQUAL
60488: IFFALSE 60492
// continue ;
60490: GO 60448
// PrepareHuman ( false , i , skill ) ;
60492: LD_INT 0
60494: PPUSH
60495: LD_VAR 0 8
60499: PPUSH
60500: LD_VAR 0 4
60504: PPUSH
60505: CALL_OW 380
// un := CreateHuman ;
60509: LD_ADDR_VAR 0 14
60513: PUSH
60514: CALL_OW 44
60518: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60519: LD_VAR 0 14
60523: PPUSH
60524: LD_VAR 0 1
60528: PPUSH
60529: CALL_OW 250
60533: PPUSH
60534: LD_VAR 0 1
60538: PPUSH
60539: CALL_OW 251
60543: PPUSH
60544: LD_INT 10
60546: PPUSH
60547: LD_INT 0
60549: PPUSH
60550: CALL_OW 50
// result := result ^ un ;
60554: LD_ADDR_VAR 0 7
60558: PUSH
60559: LD_VAR 0 7
60563: PUSH
60564: LD_VAR 0 14
60568: ADD
60569: ST_TO_ADDR
// end ;
60570: GO 60448
60572: POP
60573: POP
// end ; end ;
60574: LD_VAR 0 7
60578: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
60579: LD_INT 0
60581: PPUSH
60582: PPUSH
60583: PPUSH
60584: PPUSH
60585: PPUSH
60586: PPUSH
60587: PPUSH
60588: PPUSH
60589: PPUSH
60590: PPUSH
60591: PPUSH
60592: PPUSH
60593: PPUSH
60594: PPUSH
60595: PPUSH
60596: PPUSH
// result := false ;
60597: LD_ADDR_VAR 0 3
60601: PUSH
60602: LD_INT 0
60604: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
60605: LD_VAR 0 1
60609: NOT
60610: PUSH
60611: LD_VAR 0 1
60615: PPUSH
60616: CALL_OW 266
60620: PUSH
60621: LD_INT 32
60623: PUSH
60624: LD_INT 33
60626: PUSH
60627: EMPTY
60628: LIST
60629: LIST
60630: IN
60631: NOT
60632: OR
60633: IFFALSE 60637
// exit ;
60635: GO 61773
// nat := GetNation ( tower ) ;
60637: LD_ADDR_VAR 0 12
60641: PUSH
60642: LD_VAR 0 1
60646: PPUSH
60647: CALL_OW 248
60651: ST_TO_ADDR
// side := GetSide ( tower ) ;
60652: LD_ADDR_VAR 0 16
60656: PUSH
60657: LD_VAR 0 1
60661: PPUSH
60662: CALL_OW 255
60666: ST_TO_ADDR
// x := GetX ( tower ) ;
60667: LD_ADDR_VAR 0 10
60671: PUSH
60672: LD_VAR 0 1
60676: PPUSH
60677: CALL_OW 250
60681: ST_TO_ADDR
// y := GetY ( tower ) ;
60682: LD_ADDR_VAR 0 11
60686: PUSH
60687: LD_VAR 0 1
60691: PPUSH
60692: CALL_OW 251
60696: ST_TO_ADDR
// if not x or not y then
60697: LD_VAR 0 10
60701: NOT
60702: PUSH
60703: LD_VAR 0 11
60707: NOT
60708: OR
60709: IFFALSE 60713
// exit ;
60711: GO 61773
// weapon := 0 ;
60713: LD_ADDR_VAR 0 18
60717: PUSH
60718: LD_INT 0
60720: ST_TO_ADDR
// fac_list := [ ] ;
60721: LD_ADDR_VAR 0 17
60725: PUSH
60726: EMPTY
60727: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
60728: LD_ADDR_VAR 0 6
60732: PUSH
60733: LD_VAR 0 1
60737: PPUSH
60738: CALL_OW 274
60742: PPUSH
60743: LD_VAR 0 2
60747: PPUSH
60748: CALL 58351 0 2
60752: PPUSH
60753: LD_INT 30
60755: PUSH
60756: LD_INT 3
60758: PUSH
60759: EMPTY
60760: LIST
60761: LIST
60762: PPUSH
60763: CALL_OW 72
60767: ST_TO_ADDR
// if not factories then
60768: LD_VAR 0 6
60772: NOT
60773: IFFALSE 60777
// exit ;
60775: GO 61773
// for i in factories do
60777: LD_ADDR_VAR 0 8
60781: PUSH
60782: LD_VAR 0 6
60786: PUSH
60787: FOR_IN
60788: IFFALSE 60813
// fac_list := fac_list union AvailableWeaponList ( i ) ;
60790: LD_ADDR_VAR 0 17
60794: PUSH
60795: LD_VAR 0 17
60799: PUSH
60800: LD_VAR 0 8
60804: PPUSH
60805: CALL_OW 478
60809: UNION
60810: ST_TO_ADDR
60811: GO 60787
60813: POP
60814: POP
// if not fac_list then
60815: LD_VAR 0 17
60819: NOT
60820: IFFALSE 60824
// exit ;
60822: GO 61773
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
60824: LD_ADDR_VAR 0 5
60828: PUSH
60829: LD_INT 4
60831: PUSH
60832: LD_INT 5
60834: PUSH
60835: LD_INT 9
60837: PUSH
60838: LD_INT 10
60840: PUSH
60841: LD_INT 6
60843: PUSH
60844: LD_INT 7
60846: PUSH
60847: LD_INT 11
60849: PUSH
60850: EMPTY
60851: LIST
60852: LIST
60853: LIST
60854: LIST
60855: LIST
60856: LIST
60857: LIST
60858: PUSH
60859: LD_INT 27
60861: PUSH
60862: LD_INT 28
60864: PUSH
60865: LD_INT 26
60867: PUSH
60868: LD_INT 30
60870: PUSH
60871: EMPTY
60872: LIST
60873: LIST
60874: LIST
60875: LIST
60876: PUSH
60877: LD_INT 43
60879: PUSH
60880: LD_INT 44
60882: PUSH
60883: LD_INT 46
60885: PUSH
60886: LD_INT 45
60888: PUSH
60889: LD_INT 47
60891: PUSH
60892: LD_INT 49
60894: PUSH
60895: EMPTY
60896: LIST
60897: LIST
60898: LIST
60899: LIST
60900: LIST
60901: LIST
60902: PUSH
60903: EMPTY
60904: LIST
60905: LIST
60906: LIST
60907: PUSH
60908: LD_VAR 0 12
60912: ARRAY
60913: ST_TO_ADDR
// for i in list do
60914: LD_ADDR_VAR 0 8
60918: PUSH
60919: LD_VAR 0 5
60923: PUSH
60924: FOR_IN
60925: IFFALSE 60958
// if not i in fac_list then
60927: LD_VAR 0 8
60931: PUSH
60932: LD_VAR 0 17
60936: IN
60937: NOT
60938: IFFALSE 60956
// list := list diff i ;
60940: LD_ADDR_VAR 0 5
60944: PUSH
60945: LD_VAR 0 5
60949: PUSH
60950: LD_VAR 0 8
60954: DIFF
60955: ST_TO_ADDR
60956: GO 60924
60958: POP
60959: POP
// if not list then
60960: LD_VAR 0 5
60964: NOT
60965: IFFALSE 60969
// exit ;
60967: GO 61773
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
60969: LD_VAR 0 12
60973: PUSH
60974: LD_INT 3
60976: EQUAL
60977: PUSH
60978: LD_INT 49
60980: PUSH
60981: LD_VAR 0 5
60985: IN
60986: AND
60987: PUSH
60988: LD_INT 31
60990: PPUSH
60991: LD_VAR 0 16
60995: PPUSH
60996: CALL_OW 321
61000: PUSH
61001: LD_INT 2
61003: EQUAL
61004: AND
61005: IFFALSE 61065
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61007: LD_INT 22
61009: PUSH
61010: LD_VAR 0 16
61014: PUSH
61015: EMPTY
61016: LIST
61017: LIST
61018: PUSH
61019: LD_INT 35
61021: PUSH
61022: LD_INT 49
61024: PUSH
61025: EMPTY
61026: LIST
61027: LIST
61028: PUSH
61029: LD_INT 91
61031: PUSH
61032: LD_VAR 0 1
61036: PUSH
61037: LD_INT 10
61039: PUSH
61040: EMPTY
61041: LIST
61042: LIST
61043: LIST
61044: PUSH
61045: EMPTY
61046: LIST
61047: LIST
61048: LIST
61049: PPUSH
61050: CALL_OW 69
61054: NOT
61055: IFFALSE 61065
// weapon := ru_time_lapser ;
61057: LD_ADDR_VAR 0 18
61061: PUSH
61062: LD_INT 49
61064: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61065: LD_VAR 0 12
61069: PUSH
61070: LD_INT 1
61072: PUSH
61073: LD_INT 2
61075: PUSH
61076: EMPTY
61077: LIST
61078: LIST
61079: IN
61080: PUSH
61081: LD_INT 11
61083: PUSH
61084: LD_VAR 0 5
61088: IN
61089: PUSH
61090: LD_INT 30
61092: PUSH
61093: LD_VAR 0 5
61097: IN
61098: OR
61099: AND
61100: PUSH
61101: LD_INT 6
61103: PPUSH
61104: LD_VAR 0 16
61108: PPUSH
61109: CALL_OW 321
61113: PUSH
61114: LD_INT 2
61116: EQUAL
61117: AND
61118: IFFALSE 61283
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61120: LD_INT 22
61122: PUSH
61123: LD_VAR 0 16
61127: PUSH
61128: EMPTY
61129: LIST
61130: LIST
61131: PUSH
61132: LD_INT 2
61134: PUSH
61135: LD_INT 35
61137: PUSH
61138: LD_INT 11
61140: PUSH
61141: EMPTY
61142: LIST
61143: LIST
61144: PUSH
61145: LD_INT 35
61147: PUSH
61148: LD_INT 30
61150: PUSH
61151: EMPTY
61152: LIST
61153: LIST
61154: PUSH
61155: EMPTY
61156: LIST
61157: LIST
61158: LIST
61159: PUSH
61160: LD_INT 91
61162: PUSH
61163: LD_VAR 0 1
61167: PUSH
61168: LD_INT 18
61170: PUSH
61171: EMPTY
61172: LIST
61173: LIST
61174: LIST
61175: PUSH
61176: EMPTY
61177: LIST
61178: LIST
61179: LIST
61180: PPUSH
61181: CALL_OW 69
61185: NOT
61186: PUSH
61187: LD_INT 22
61189: PUSH
61190: LD_VAR 0 16
61194: PUSH
61195: EMPTY
61196: LIST
61197: LIST
61198: PUSH
61199: LD_INT 2
61201: PUSH
61202: LD_INT 30
61204: PUSH
61205: LD_INT 32
61207: PUSH
61208: EMPTY
61209: LIST
61210: LIST
61211: PUSH
61212: LD_INT 30
61214: PUSH
61215: LD_INT 33
61217: PUSH
61218: EMPTY
61219: LIST
61220: LIST
61221: PUSH
61222: EMPTY
61223: LIST
61224: LIST
61225: LIST
61226: PUSH
61227: LD_INT 91
61229: PUSH
61230: LD_VAR 0 1
61234: PUSH
61235: LD_INT 12
61237: PUSH
61238: EMPTY
61239: LIST
61240: LIST
61241: LIST
61242: PUSH
61243: EMPTY
61244: LIST
61245: LIST
61246: LIST
61247: PUSH
61248: EMPTY
61249: LIST
61250: PPUSH
61251: CALL_OW 69
61255: PUSH
61256: LD_INT 2
61258: GREATER
61259: AND
61260: IFFALSE 61283
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61262: LD_ADDR_VAR 0 18
61266: PUSH
61267: LD_INT 11
61269: PUSH
61270: LD_INT 30
61272: PUSH
61273: EMPTY
61274: LIST
61275: LIST
61276: PUSH
61277: LD_VAR 0 12
61281: ARRAY
61282: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61283: LD_VAR 0 18
61287: NOT
61288: PUSH
61289: LD_INT 40
61291: PPUSH
61292: LD_VAR 0 16
61296: PPUSH
61297: CALL_OW 321
61301: PUSH
61302: LD_INT 2
61304: EQUAL
61305: AND
61306: PUSH
61307: LD_INT 7
61309: PUSH
61310: LD_VAR 0 5
61314: IN
61315: PUSH
61316: LD_INT 28
61318: PUSH
61319: LD_VAR 0 5
61323: IN
61324: OR
61325: PUSH
61326: LD_INT 45
61328: PUSH
61329: LD_VAR 0 5
61333: IN
61334: OR
61335: AND
61336: IFFALSE 61590
// begin hex := GetHexInfo ( x , y ) ;
61338: LD_ADDR_VAR 0 4
61342: PUSH
61343: LD_VAR 0 10
61347: PPUSH
61348: LD_VAR 0 11
61352: PPUSH
61353: CALL_OW 546
61357: ST_TO_ADDR
// if hex [ 1 ] then
61358: LD_VAR 0 4
61362: PUSH
61363: LD_INT 1
61365: ARRAY
61366: IFFALSE 61370
// exit ;
61368: GO 61773
// height := hex [ 2 ] ;
61370: LD_ADDR_VAR 0 15
61374: PUSH
61375: LD_VAR 0 4
61379: PUSH
61380: LD_INT 2
61382: ARRAY
61383: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61384: LD_ADDR_VAR 0 14
61388: PUSH
61389: LD_INT 0
61391: PUSH
61392: LD_INT 2
61394: PUSH
61395: LD_INT 3
61397: PUSH
61398: LD_INT 5
61400: PUSH
61401: EMPTY
61402: LIST
61403: LIST
61404: LIST
61405: LIST
61406: ST_TO_ADDR
// for i in tmp do
61407: LD_ADDR_VAR 0 8
61411: PUSH
61412: LD_VAR 0 14
61416: PUSH
61417: FOR_IN
61418: IFFALSE 61588
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
61420: LD_ADDR_VAR 0 9
61424: PUSH
61425: LD_VAR 0 10
61429: PPUSH
61430: LD_VAR 0 8
61434: PPUSH
61435: LD_INT 5
61437: PPUSH
61438: CALL_OW 272
61442: PUSH
61443: LD_VAR 0 11
61447: PPUSH
61448: LD_VAR 0 8
61452: PPUSH
61453: LD_INT 5
61455: PPUSH
61456: CALL_OW 273
61460: PUSH
61461: EMPTY
61462: LIST
61463: LIST
61464: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
61465: LD_VAR 0 9
61469: PUSH
61470: LD_INT 1
61472: ARRAY
61473: PPUSH
61474: LD_VAR 0 9
61478: PUSH
61479: LD_INT 2
61481: ARRAY
61482: PPUSH
61483: CALL_OW 488
61487: IFFALSE 61586
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
61489: LD_ADDR_VAR 0 4
61493: PUSH
61494: LD_VAR 0 9
61498: PUSH
61499: LD_INT 1
61501: ARRAY
61502: PPUSH
61503: LD_VAR 0 9
61507: PUSH
61508: LD_INT 2
61510: ARRAY
61511: PPUSH
61512: CALL_OW 546
61516: ST_TO_ADDR
// if hex [ 1 ] then
61517: LD_VAR 0 4
61521: PUSH
61522: LD_INT 1
61524: ARRAY
61525: IFFALSE 61529
// continue ;
61527: GO 61417
// h := hex [ 2 ] ;
61529: LD_ADDR_VAR 0 13
61533: PUSH
61534: LD_VAR 0 4
61538: PUSH
61539: LD_INT 2
61541: ARRAY
61542: ST_TO_ADDR
// if h + 7 < height then
61543: LD_VAR 0 13
61547: PUSH
61548: LD_INT 7
61550: PLUS
61551: PUSH
61552: LD_VAR 0 15
61556: LESS
61557: IFFALSE 61586
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
61559: LD_ADDR_VAR 0 18
61563: PUSH
61564: LD_INT 7
61566: PUSH
61567: LD_INT 28
61569: PUSH
61570: LD_INT 45
61572: PUSH
61573: EMPTY
61574: LIST
61575: LIST
61576: LIST
61577: PUSH
61578: LD_VAR 0 12
61582: ARRAY
61583: ST_TO_ADDR
// break ;
61584: GO 61588
// end ; end ; end ;
61586: GO 61417
61588: POP
61589: POP
// end ; if not weapon then
61590: LD_VAR 0 18
61594: NOT
61595: IFFALSE 61655
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
61597: LD_ADDR_VAR 0 5
61601: PUSH
61602: LD_VAR 0 5
61606: PUSH
61607: LD_INT 11
61609: PUSH
61610: LD_INT 30
61612: PUSH
61613: LD_INT 49
61615: PUSH
61616: EMPTY
61617: LIST
61618: LIST
61619: LIST
61620: DIFF
61621: ST_TO_ADDR
// if not list then
61622: LD_VAR 0 5
61626: NOT
61627: IFFALSE 61631
// exit ;
61629: GO 61773
// weapon := list [ rand ( 1 , list ) ] ;
61631: LD_ADDR_VAR 0 18
61635: PUSH
61636: LD_VAR 0 5
61640: PUSH
61641: LD_INT 1
61643: PPUSH
61644: LD_VAR 0 5
61648: PPUSH
61649: CALL_OW 12
61653: ARRAY
61654: ST_TO_ADDR
// end ; if weapon then
61655: LD_VAR 0 18
61659: IFFALSE 61773
// begin tmp := CostOfWeapon ( weapon ) ;
61661: LD_ADDR_VAR 0 14
61665: PUSH
61666: LD_VAR 0 18
61670: PPUSH
61671: CALL_OW 451
61675: ST_TO_ADDR
// j := GetBase ( tower ) ;
61676: LD_ADDR_VAR 0 9
61680: PUSH
61681: LD_VAR 0 1
61685: PPUSH
61686: CALL_OW 274
61690: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
61691: LD_VAR 0 9
61695: PPUSH
61696: LD_INT 1
61698: PPUSH
61699: CALL_OW 275
61703: PUSH
61704: LD_VAR 0 14
61708: PUSH
61709: LD_INT 1
61711: ARRAY
61712: GREATEREQUAL
61713: PUSH
61714: LD_VAR 0 9
61718: PPUSH
61719: LD_INT 2
61721: PPUSH
61722: CALL_OW 275
61726: PUSH
61727: LD_VAR 0 14
61731: PUSH
61732: LD_INT 2
61734: ARRAY
61735: GREATEREQUAL
61736: AND
61737: PUSH
61738: LD_VAR 0 9
61742: PPUSH
61743: LD_INT 3
61745: PPUSH
61746: CALL_OW 275
61750: PUSH
61751: LD_VAR 0 14
61755: PUSH
61756: LD_INT 3
61758: ARRAY
61759: GREATEREQUAL
61760: AND
61761: IFFALSE 61773
// result := weapon ;
61763: LD_ADDR_VAR 0 3
61767: PUSH
61768: LD_VAR 0 18
61772: ST_TO_ADDR
// end ; end ;
61773: LD_VAR 0 3
61777: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
61778: LD_INT 0
61780: PPUSH
61781: PPUSH
// result := true ;
61782: LD_ADDR_VAR 0 3
61786: PUSH
61787: LD_INT 1
61789: ST_TO_ADDR
// if array1 = array2 then
61790: LD_VAR 0 1
61794: PUSH
61795: LD_VAR 0 2
61799: EQUAL
61800: IFFALSE 61860
// begin for i = 1 to array1 do
61802: LD_ADDR_VAR 0 4
61806: PUSH
61807: DOUBLE
61808: LD_INT 1
61810: DEC
61811: ST_TO_ADDR
61812: LD_VAR 0 1
61816: PUSH
61817: FOR_TO
61818: IFFALSE 61856
// if array1 [ i ] <> array2 [ i ] then
61820: LD_VAR 0 1
61824: PUSH
61825: LD_VAR 0 4
61829: ARRAY
61830: PUSH
61831: LD_VAR 0 2
61835: PUSH
61836: LD_VAR 0 4
61840: ARRAY
61841: NONEQUAL
61842: IFFALSE 61854
// begin result := false ;
61844: LD_ADDR_VAR 0 3
61848: PUSH
61849: LD_INT 0
61851: ST_TO_ADDR
// break ;
61852: GO 61856
// end ;
61854: GO 61817
61856: POP
61857: POP
// end else
61858: GO 61868
// result := false ;
61860: LD_ADDR_VAR 0 3
61864: PUSH
61865: LD_INT 0
61867: ST_TO_ADDR
// end ;
61868: LD_VAR 0 3
61872: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
61873: LD_INT 0
61875: PPUSH
61876: PPUSH
61877: PPUSH
// pom := GetBase ( fac ) ;
61878: LD_ADDR_VAR 0 5
61882: PUSH
61883: LD_VAR 0 1
61887: PPUSH
61888: CALL_OW 274
61892: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
61893: LD_ADDR_VAR 0 4
61897: PUSH
61898: LD_VAR 0 2
61902: PUSH
61903: LD_INT 1
61905: ARRAY
61906: PPUSH
61907: LD_VAR 0 2
61911: PUSH
61912: LD_INT 2
61914: ARRAY
61915: PPUSH
61916: LD_VAR 0 2
61920: PUSH
61921: LD_INT 3
61923: ARRAY
61924: PPUSH
61925: LD_VAR 0 2
61929: PUSH
61930: LD_INT 4
61932: ARRAY
61933: PPUSH
61934: CALL_OW 449
61938: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61939: LD_ADDR_VAR 0 3
61943: PUSH
61944: LD_VAR 0 5
61948: PPUSH
61949: LD_INT 1
61951: PPUSH
61952: CALL_OW 275
61956: PUSH
61957: LD_VAR 0 4
61961: PUSH
61962: LD_INT 1
61964: ARRAY
61965: GREATEREQUAL
61966: PUSH
61967: LD_VAR 0 5
61971: PPUSH
61972: LD_INT 2
61974: PPUSH
61975: CALL_OW 275
61979: PUSH
61980: LD_VAR 0 4
61984: PUSH
61985: LD_INT 2
61987: ARRAY
61988: GREATEREQUAL
61989: AND
61990: PUSH
61991: LD_VAR 0 5
61995: PPUSH
61996: LD_INT 3
61998: PPUSH
61999: CALL_OW 275
62003: PUSH
62004: LD_VAR 0 4
62008: PUSH
62009: LD_INT 3
62011: ARRAY
62012: GREATEREQUAL
62013: AND
62014: ST_TO_ADDR
// end ;
62015: LD_VAR 0 3
62019: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62020: LD_INT 0
62022: PPUSH
62023: PPUSH
62024: PPUSH
62025: PPUSH
// pom := GetBase ( building ) ;
62026: LD_ADDR_VAR 0 3
62030: PUSH
62031: LD_VAR 0 1
62035: PPUSH
62036: CALL_OW 274
62040: ST_TO_ADDR
// if not pom then
62041: LD_VAR 0 3
62045: NOT
62046: IFFALSE 62050
// exit ;
62048: GO 62220
// btype := GetBType ( building ) ;
62050: LD_ADDR_VAR 0 5
62054: PUSH
62055: LD_VAR 0 1
62059: PPUSH
62060: CALL_OW 266
62064: ST_TO_ADDR
// if btype = b_armoury then
62065: LD_VAR 0 5
62069: PUSH
62070: LD_INT 4
62072: EQUAL
62073: IFFALSE 62083
// btype := b_barracks ;
62075: LD_ADDR_VAR 0 5
62079: PUSH
62080: LD_INT 5
62082: ST_TO_ADDR
// if btype = b_depot then
62083: LD_VAR 0 5
62087: PUSH
62088: LD_INT 0
62090: EQUAL
62091: IFFALSE 62101
// btype := b_warehouse ;
62093: LD_ADDR_VAR 0 5
62097: PUSH
62098: LD_INT 1
62100: ST_TO_ADDR
// if btype = b_workshop then
62101: LD_VAR 0 5
62105: PUSH
62106: LD_INT 2
62108: EQUAL
62109: IFFALSE 62119
// btype := b_factory ;
62111: LD_ADDR_VAR 0 5
62115: PUSH
62116: LD_INT 3
62118: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62119: LD_ADDR_VAR 0 4
62123: PUSH
62124: LD_VAR 0 5
62128: PPUSH
62129: LD_VAR 0 1
62133: PPUSH
62134: CALL_OW 248
62138: PPUSH
62139: CALL_OW 450
62143: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62144: LD_ADDR_VAR 0 2
62148: PUSH
62149: LD_VAR 0 3
62153: PPUSH
62154: LD_INT 1
62156: PPUSH
62157: CALL_OW 275
62161: PUSH
62162: LD_VAR 0 4
62166: PUSH
62167: LD_INT 1
62169: ARRAY
62170: GREATEREQUAL
62171: PUSH
62172: LD_VAR 0 3
62176: PPUSH
62177: LD_INT 2
62179: PPUSH
62180: CALL_OW 275
62184: PUSH
62185: LD_VAR 0 4
62189: PUSH
62190: LD_INT 2
62192: ARRAY
62193: GREATEREQUAL
62194: AND
62195: PUSH
62196: LD_VAR 0 3
62200: PPUSH
62201: LD_INT 3
62203: PPUSH
62204: CALL_OW 275
62208: PUSH
62209: LD_VAR 0 4
62213: PUSH
62214: LD_INT 3
62216: ARRAY
62217: GREATEREQUAL
62218: AND
62219: ST_TO_ADDR
// end ;
62220: LD_VAR 0 2
62224: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62225: LD_INT 0
62227: PPUSH
62228: PPUSH
62229: PPUSH
// pom := GetBase ( building ) ;
62230: LD_ADDR_VAR 0 4
62234: PUSH
62235: LD_VAR 0 1
62239: PPUSH
62240: CALL_OW 274
62244: ST_TO_ADDR
// if not pom then
62245: LD_VAR 0 4
62249: NOT
62250: IFFALSE 62254
// exit ;
62252: GO 62355
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62254: LD_ADDR_VAR 0 5
62258: PUSH
62259: LD_VAR 0 2
62263: PPUSH
62264: LD_VAR 0 1
62268: PPUSH
62269: CALL_OW 248
62273: PPUSH
62274: CALL_OW 450
62278: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62279: LD_ADDR_VAR 0 3
62283: PUSH
62284: LD_VAR 0 4
62288: PPUSH
62289: LD_INT 1
62291: PPUSH
62292: CALL_OW 275
62296: PUSH
62297: LD_VAR 0 5
62301: PUSH
62302: LD_INT 1
62304: ARRAY
62305: GREATEREQUAL
62306: PUSH
62307: LD_VAR 0 4
62311: PPUSH
62312: LD_INT 2
62314: PPUSH
62315: CALL_OW 275
62319: PUSH
62320: LD_VAR 0 5
62324: PUSH
62325: LD_INT 2
62327: ARRAY
62328: GREATEREQUAL
62329: AND
62330: PUSH
62331: LD_VAR 0 4
62335: PPUSH
62336: LD_INT 3
62338: PPUSH
62339: CALL_OW 275
62343: PUSH
62344: LD_VAR 0 5
62348: PUSH
62349: LD_INT 3
62351: ARRAY
62352: GREATEREQUAL
62353: AND
62354: ST_TO_ADDR
// end ;
62355: LD_VAR 0 3
62359: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
62360: LD_INT 0
62362: PPUSH
62363: PPUSH
62364: PPUSH
62365: PPUSH
62366: PPUSH
62367: PPUSH
62368: PPUSH
62369: PPUSH
62370: PPUSH
62371: PPUSH
// result := false ;
62372: LD_ADDR_VAR 0 6
62376: PUSH
62377: LD_INT 0
62379: ST_TO_ADDR
// if not base or not btype or not x or not y then
62380: LD_VAR 0 1
62384: NOT
62385: PUSH
62386: LD_VAR 0 2
62390: NOT
62391: OR
62392: PUSH
62393: LD_VAR 0 3
62397: NOT
62398: OR
62399: PUSH
62400: LD_VAR 0 4
62404: NOT
62405: OR
62406: IFFALSE 62410
// exit ;
62408: GO 63019
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
62410: LD_ADDR_VAR 0 12
62414: PUSH
62415: LD_VAR 0 2
62419: PPUSH
62420: LD_VAR 0 3
62424: PPUSH
62425: LD_VAR 0 4
62429: PPUSH
62430: LD_VAR 0 5
62434: PPUSH
62435: LD_VAR 0 1
62439: PUSH
62440: LD_INT 1
62442: ARRAY
62443: PPUSH
62444: CALL_OW 248
62448: PPUSH
62449: LD_INT 0
62451: PPUSH
62452: CALL 63856 0 6
62456: ST_TO_ADDR
// if not hexes then
62457: LD_VAR 0 12
62461: NOT
62462: IFFALSE 62466
// exit ;
62464: GO 63019
// for i = 1 to hexes do
62466: LD_ADDR_VAR 0 7
62470: PUSH
62471: DOUBLE
62472: LD_INT 1
62474: DEC
62475: ST_TO_ADDR
62476: LD_VAR 0 12
62480: PUSH
62481: FOR_TO
62482: IFFALSE 63017
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62484: LD_ADDR_VAR 0 11
62488: PUSH
62489: LD_VAR 0 12
62493: PUSH
62494: LD_VAR 0 7
62498: ARRAY
62499: PUSH
62500: LD_INT 1
62502: ARRAY
62503: PPUSH
62504: LD_VAR 0 12
62508: PUSH
62509: LD_VAR 0 7
62513: ARRAY
62514: PUSH
62515: LD_INT 2
62517: ARRAY
62518: PPUSH
62519: CALL_OW 428
62523: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
62524: LD_VAR 0 12
62528: PUSH
62529: LD_VAR 0 7
62533: ARRAY
62534: PUSH
62535: LD_INT 1
62537: ARRAY
62538: PPUSH
62539: LD_VAR 0 12
62543: PUSH
62544: LD_VAR 0 7
62548: ARRAY
62549: PUSH
62550: LD_INT 2
62552: ARRAY
62553: PPUSH
62554: CALL_OW 351
62558: PUSH
62559: LD_VAR 0 12
62563: PUSH
62564: LD_VAR 0 7
62568: ARRAY
62569: PUSH
62570: LD_INT 1
62572: ARRAY
62573: PPUSH
62574: LD_VAR 0 12
62578: PUSH
62579: LD_VAR 0 7
62583: ARRAY
62584: PUSH
62585: LD_INT 2
62587: ARRAY
62588: PPUSH
62589: CALL_OW 488
62593: NOT
62594: OR
62595: PUSH
62596: LD_VAR 0 11
62600: PPUSH
62601: CALL_OW 247
62605: PUSH
62606: LD_INT 3
62608: EQUAL
62609: OR
62610: IFFALSE 62616
// exit ;
62612: POP
62613: POP
62614: GO 63019
// if not tmp or not tmp in base then
62616: LD_VAR 0 11
62620: NOT
62621: PUSH
62622: LD_VAR 0 11
62626: PUSH
62627: LD_VAR 0 1
62631: IN
62632: NOT
62633: OR
62634: IFFALSE 62638
// continue ;
62636: GO 62481
// result := true ;
62638: LD_ADDR_VAR 0 6
62642: PUSH
62643: LD_INT 1
62645: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
62646: LD_ADDR_VAR 0 15
62650: PUSH
62651: LD_VAR 0 1
62655: PPUSH
62656: LD_INT 22
62658: PUSH
62659: LD_VAR 0 11
62663: PPUSH
62664: CALL_OW 255
62668: PUSH
62669: EMPTY
62670: LIST
62671: LIST
62672: PUSH
62673: LD_INT 2
62675: PUSH
62676: LD_INT 30
62678: PUSH
62679: LD_INT 0
62681: PUSH
62682: EMPTY
62683: LIST
62684: LIST
62685: PUSH
62686: LD_INT 30
62688: PUSH
62689: LD_INT 1
62691: PUSH
62692: EMPTY
62693: LIST
62694: LIST
62695: PUSH
62696: EMPTY
62697: LIST
62698: LIST
62699: LIST
62700: PUSH
62701: EMPTY
62702: LIST
62703: LIST
62704: PPUSH
62705: CALL_OW 72
62709: ST_TO_ADDR
// if dep then
62710: LD_VAR 0 15
62714: IFFALSE 62850
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
62716: LD_ADDR_VAR 0 14
62720: PUSH
62721: LD_VAR 0 15
62725: PUSH
62726: LD_INT 1
62728: ARRAY
62729: PPUSH
62730: CALL_OW 250
62734: PPUSH
62735: LD_VAR 0 15
62739: PUSH
62740: LD_INT 1
62742: ARRAY
62743: PPUSH
62744: CALL_OW 254
62748: PPUSH
62749: LD_INT 5
62751: PPUSH
62752: CALL_OW 272
62756: PUSH
62757: LD_VAR 0 15
62761: PUSH
62762: LD_INT 1
62764: ARRAY
62765: PPUSH
62766: CALL_OW 251
62770: PPUSH
62771: LD_VAR 0 15
62775: PUSH
62776: LD_INT 1
62778: ARRAY
62779: PPUSH
62780: CALL_OW 254
62784: PPUSH
62785: LD_INT 5
62787: PPUSH
62788: CALL_OW 273
62792: PUSH
62793: EMPTY
62794: LIST
62795: LIST
62796: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
62797: LD_VAR 0 14
62801: PUSH
62802: LD_INT 1
62804: ARRAY
62805: PPUSH
62806: LD_VAR 0 14
62810: PUSH
62811: LD_INT 2
62813: ARRAY
62814: PPUSH
62815: CALL_OW 488
62819: IFFALSE 62850
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
62821: LD_VAR 0 11
62825: PPUSH
62826: LD_VAR 0 14
62830: PUSH
62831: LD_INT 1
62833: ARRAY
62834: PPUSH
62835: LD_VAR 0 14
62839: PUSH
62840: LD_INT 2
62842: ARRAY
62843: PPUSH
62844: CALL_OW 111
// continue ;
62848: GO 62481
// end ; end ; r := GetDir ( tmp ) ;
62850: LD_ADDR_VAR 0 13
62854: PUSH
62855: LD_VAR 0 11
62859: PPUSH
62860: CALL_OW 254
62864: ST_TO_ADDR
// if r = 5 then
62865: LD_VAR 0 13
62869: PUSH
62870: LD_INT 5
62872: EQUAL
62873: IFFALSE 62883
// r := 0 ;
62875: LD_ADDR_VAR 0 13
62879: PUSH
62880: LD_INT 0
62882: ST_TO_ADDR
// for j = r to 5 do
62883: LD_ADDR_VAR 0 8
62887: PUSH
62888: DOUBLE
62889: LD_VAR 0 13
62893: DEC
62894: ST_TO_ADDR
62895: LD_INT 5
62897: PUSH
62898: FOR_TO
62899: IFFALSE 63013
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62901: LD_ADDR_VAR 0 9
62905: PUSH
62906: LD_VAR 0 11
62910: PPUSH
62911: CALL_OW 250
62915: PPUSH
62916: LD_VAR 0 8
62920: PPUSH
62921: LD_INT 2
62923: PPUSH
62924: CALL_OW 272
62928: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
62929: LD_ADDR_VAR 0 10
62933: PUSH
62934: LD_VAR 0 11
62938: PPUSH
62939: CALL_OW 251
62943: PPUSH
62944: LD_VAR 0 8
62948: PPUSH
62949: LD_INT 2
62951: PPUSH
62952: CALL_OW 273
62956: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
62957: LD_VAR 0 9
62961: PPUSH
62962: LD_VAR 0 10
62966: PPUSH
62967: CALL_OW 488
62971: PUSH
62972: LD_VAR 0 9
62976: PPUSH
62977: LD_VAR 0 10
62981: PPUSH
62982: CALL_OW 428
62986: NOT
62987: AND
62988: IFFALSE 63011
// begin ComMoveXY ( tmp , _x , _y ) ;
62990: LD_VAR 0 11
62994: PPUSH
62995: LD_VAR 0 9
62999: PPUSH
63000: LD_VAR 0 10
63004: PPUSH
63005: CALL_OW 111
// break ;
63009: GO 63013
// end ; end ;
63011: GO 62898
63013: POP
63014: POP
// end ;
63015: GO 62481
63017: POP
63018: POP
// end ;
63019: LD_VAR 0 6
63023: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
63024: LD_INT 0
63026: PPUSH
63027: PPUSH
63028: PPUSH
63029: PPUSH
63030: PPUSH
63031: PPUSH
63032: PPUSH
63033: PPUSH
63034: PPUSH
63035: PPUSH
// result := false ;
63036: LD_ADDR_VAR 0 6
63040: PUSH
63041: LD_INT 0
63043: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
63044: LD_VAR 0 1
63048: NOT
63049: PUSH
63050: LD_VAR 0 1
63054: PPUSH
63055: CALL_OW 266
63059: PUSH
63060: LD_INT 0
63062: PUSH
63063: LD_INT 1
63065: PUSH
63066: EMPTY
63067: LIST
63068: LIST
63069: IN
63070: NOT
63071: OR
63072: PUSH
63073: LD_VAR 0 2
63077: NOT
63078: OR
63079: PUSH
63080: LD_VAR 0 5
63084: PUSH
63085: LD_INT 0
63087: PUSH
63088: LD_INT 1
63090: PUSH
63091: LD_INT 2
63093: PUSH
63094: LD_INT 3
63096: PUSH
63097: LD_INT 4
63099: PUSH
63100: LD_INT 5
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: LIST
63107: LIST
63108: LIST
63109: LIST
63110: IN
63111: NOT
63112: OR
63113: PUSH
63114: LD_VAR 0 3
63118: PPUSH
63119: LD_VAR 0 4
63123: PPUSH
63124: CALL_OW 488
63128: NOT
63129: OR
63130: IFFALSE 63134
// exit ;
63132: GO 63851
// pom := GetBase ( depot ) ;
63134: LD_ADDR_VAR 0 10
63138: PUSH
63139: LD_VAR 0 1
63143: PPUSH
63144: CALL_OW 274
63148: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63149: LD_ADDR_VAR 0 11
63153: PUSH
63154: LD_VAR 0 2
63158: PPUSH
63159: LD_VAR 0 1
63163: PPUSH
63164: CALL_OW 248
63168: PPUSH
63169: CALL_OW 450
63173: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63174: LD_VAR 0 10
63178: PPUSH
63179: LD_INT 1
63181: PPUSH
63182: CALL_OW 275
63186: PUSH
63187: LD_VAR 0 11
63191: PUSH
63192: LD_INT 1
63194: ARRAY
63195: GREATEREQUAL
63196: PUSH
63197: LD_VAR 0 10
63201: PPUSH
63202: LD_INT 2
63204: PPUSH
63205: CALL_OW 275
63209: PUSH
63210: LD_VAR 0 11
63214: PUSH
63215: LD_INT 2
63217: ARRAY
63218: GREATEREQUAL
63219: AND
63220: PUSH
63221: LD_VAR 0 10
63225: PPUSH
63226: LD_INT 3
63228: PPUSH
63229: CALL_OW 275
63233: PUSH
63234: LD_VAR 0 11
63238: PUSH
63239: LD_INT 3
63241: ARRAY
63242: GREATEREQUAL
63243: AND
63244: NOT
63245: IFFALSE 63249
// exit ;
63247: GO 63851
// if GetBType ( depot ) = b_depot then
63249: LD_VAR 0 1
63253: PPUSH
63254: CALL_OW 266
63258: PUSH
63259: LD_INT 0
63261: EQUAL
63262: IFFALSE 63274
// dist := 28 else
63264: LD_ADDR_VAR 0 14
63268: PUSH
63269: LD_INT 28
63271: ST_TO_ADDR
63272: GO 63282
// dist := 36 ;
63274: LD_ADDR_VAR 0 14
63278: PUSH
63279: LD_INT 36
63281: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
63282: LD_VAR 0 1
63286: PPUSH
63287: LD_VAR 0 3
63291: PPUSH
63292: LD_VAR 0 4
63296: PPUSH
63297: CALL_OW 297
63301: PUSH
63302: LD_VAR 0 14
63306: GREATER
63307: IFFALSE 63311
// exit ;
63309: GO 63851
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
63311: LD_ADDR_VAR 0 12
63315: PUSH
63316: LD_VAR 0 2
63320: PPUSH
63321: LD_VAR 0 3
63325: PPUSH
63326: LD_VAR 0 4
63330: PPUSH
63331: LD_VAR 0 5
63335: PPUSH
63336: LD_VAR 0 1
63340: PPUSH
63341: CALL_OW 248
63345: PPUSH
63346: LD_INT 0
63348: PPUSH
63349: CALL 63856 0 6
63353: ST_TO_ADDR
// if not hexes then
63354: LD_VAR 0 12
63358: NOT
63359: IFFALSE 63363
// exit ;
63361: GO 63851
// hex := GetHexInfo ( x , y ) ;
63363: LD_ADDR_VAR 0 15
63367: PUSH
63368: LD_VAR 0 3
63372: PPUSH
63373: LD_VAR 0 4
63377: PPUSH
63378: CALL_OW 546
63382: ST_TO_ADDR
// if hex [ 1 ] then
63383: LD_VAR 0 15
63387: PUSH
63388: LD_INT 1
63390: ARRAY
63391: IFFALSE 63395
// exit ;
63393: GO 63851
// height := hex [ 2 ] ;
63395: LD_ADDR_VAR 0 13
63399: PUSH
63400: LD_VAR 0 15
63404: PUSH
63405: LD_INT 2
63407: ARRAY
63408: ST_TO_ADDR
// for i = 1 to hexes do
63409: LD_ADDR_VAR 0 7
63413: PUSH
63414: DOUBLE
63415: LD_INT 1
63417: DEC
63418: ST_TO_ADDR
63419: LD_VAR 0 12
63423: PUSH
63424: FOR_TO
63425: IFFALSE 63755
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63427: LD_VAR 0 12
63431: PUSH
63432: LD_VAR 0 7
63436: ARRAY
63437: PUSH
63438: LD_INT 1
63440: ARRAY
63441: PPUSH
63442: LD_VAR 0 12
63446: PUSH
63447: LD_VAR 0 7
63451: ARRAY
63452: PUSH
63453: LD_INT 2
63455: ARRAY
63456: PPUSH
63457: CALL_OW 488
63461: NOT
63462: PUSH
63463: LD_VAR 0 12
63467: PUSH
63468: LD_VAR 0 7
63472: ARRAY
63473: PUSH
63474: LD_INT 1
63476: ARRAY
63477: PPUSH
63478: LD_VAR 0 12
63482: PUSH
63483: LD_VAR 0 7
63487: ARRAY
63488: PUSH
63489: LD_INT 2
63491: ARRAY
63492: PPUSH
63493: CALL_OW 428
63497: PUSH
63498: LD_INT 0
63500: GREATER
63501: OR
63502: PUSH
63503: LD_VAR 0 12
63507: PUSH
63508: LD_VAR 0 7
63512: ARRAY
63513: PUSH
63514: LD_INT 1
63516: ARRAY
63517: PPUSH
63518: LD_VAR 0 12
63522: PUSH
63523: LD_VAR 0 7
63527: ARRAY
63528: PUSH
63529: LD_INT 2
63531: ARRAY
63532: PPUSH
63533: CALL_OW 351
63537: OR
63538: IFFALSE 63544
// exit ;
63540: POP
63541: POP
63542: GO 63851
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63544: LD_ADDR_VAR 0 8
63548: PUSH
63549: LD_VAR 0 12
63553: PUSH
63554: LD_VAR 0 7
63558: ARRAY
63559: PUSH
63560: LD_INT 1
63562: ARRAY
63563: PPUSH
63564: LD_VAR 0 12
63568: PUSH
63569: LD_VAR 0 7
63573: ARRAY
63574: PUSH
63575: LD_INT 2
63577: ARRAY
63578: PPUSH
63579: CALL_OW 546
63583: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63584: LD_VAR 0 8
63588: PUSH
63589: LD_INT 1
63591: ARRAY
63592: PUSH
63593: LD_VAR 0 8
63597: PUSH
63598: LD_INT 2
63600: ARRAY
63601: PUSH
63602: LD_VAR 0 13
63606: PUSH
63607: LD_INT 2
63609: PLUS
63610: GREATER
63611: OR
63612: PUSH
63613: LD_VAR 0 8
63617: PUSH
63618: LD_INT 2
63620: ARRAY
63621: PUSH
63622: LD_VAR 0 13
63626: PUSH
63627: LD_INT 2
63629: MINUS
63630: LESS
63631: OR
63632: PUSH
63633: LD_VAR 0 8
63637: PUSH
63638: LD_INT 3
63640: ARRAY
63641: PUSH
63642: LD_INT 0
63644: PUSH
63645: LD_INT 8
63647: PUSH
63648: LD_INT 9
63650: PUSH
63651: LD_INT 10
63653: PUSH
63654: LD_INT 11
63656: PUSH
63657: LD_INT 12
63659: PUSH
63660: LD_INT 13
63662: PUSH
63663: LD_INT 16
63665: PUSH
63666: LD_INT 17
63668: PUSH
63669: LD_INT 18
63671: PUSH
63672: LD_INT 19
63674: PUSH
63675: LD_INT 20
63677: PUSH
63678: LD_INT 21
63680: PUSH
63681: EMPTY
63682: LIST
63683: LIST
63684: LIST
63685: LIST
63686: LIST
63687: LIST
63688: LIST
63689: LIST
63690: LIST
63691: LIST
63692: LIST
63693: LIST
63694: LIST
63695: IN
63696: NOT
63697: OR
63698: PUSH
63699: LD_VAR 0 8
63703: PUSH
63704: LD_INT 5
63706: ARRAY
63707: NOT
63708: OR
63709: PUSH
63710: LD_VAR 0 8
63714: PUSH
63715: LD_INT 6
63717: ARRAY
63718: PUSH
63719: LD_INT 1
63721: PUSH
63722: LD_INT 2
63724: PUSH
63725: LD_INT 7
63727: PUSH
63728: LD_INT 9
63730: PUSH
63731: LD_INT 10
63733: PUSH
63734: LD_INT 11
63736: PUSH
63737: EMPTY
63738: LIST
63739: LIST
63740: LIST
63741: LIST
63742: LIST
63743: LIST
63744: IN
63745: NOT
63746: OR
63747: IFFALSE 63753
// exit ;
63749: POP
63750: POP
63751: GO 63851
// end ;
63753: GO 63424
63755: POP
63756: POP
// side := GetSide ( depot ) ;
63757: LD_ADDR_VAR 0 9
63761: PUSH
63762: LD_VAR 0 1
63766: PPUSH
63767: CALL_OW 255
63771: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63772: LD_VAR 0 9
63776: PPUSH
63777: LD_VAR 0 3
63781: PPUSH
63782: LD_VAR 0 4
63786: PPUSH
63787: LD_INT 20
63789: PPUSH
63790: CALL 56505 0 4
63794: PUSH
63795: LD_INT 4
63797: ARRAY
63798: IFFALSE 63802
// exit ;
63800: GO 63851
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63802: LD_VAR 0 2
63806: PUSH
63807: LD_INT 29
63809: PUSH
63810: LD_INT 30
63812: PUSH
63813: EMPTY
63814: LIST
63815: LIST
63816: IN
63817: PUSH
63818: LD_VAR 0 3
63822: PPUSH
63823: LD_VAR 0 4
63827: PPUSH
63828: LD_VAR 0 9
63832: PPUSH
63833: CALL_OW 440
63837: NOT
63838: AND
63839: IFFALSE 63843
// exit ;
63841: GO 63851
// result := true ;
63843: LD_ADDR_VAR 0 6
63847: PUSH
63848: LD_INT 1
63850: ST_TO_ADDR
// end ;
63851: LD_VAR 0 6
63855: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
63856: LD_INT 0
63858: PPUSH
63859: PPUSH
63860: PPUSH
63861: PPUSH
63862: PPUSH
63863: PPUSH
63864: PPUSH
63865: PPUSH
63866: PPUSH
63867: PPUSH
63868: PPUSH
63869: PPUSH
63870: PPUSH
63871: PPUSH
63872: PPUSH
63873: PPUSH
63874: PPUSH
63875: PPUSH
63876: PPUSH
63877: PPUSH
63878: PPUSH
63879: PPUSH
63880: PPUSH
63881: PPUSH
63882: PPUSH
63883: PPUSH
63884: PPUSH
63885: PPUSH
63886: PPUSH
63887: PPUSH
63888: PPUSH
63889: PPUSH
63890: PPUSH
63891: PPUSH
63892: PPUSH
63893: PPUSH
63894: PPUSH
63895: PPUSH
63896: PPUSH
63897: PPUSH
63898: PPUSH
63899: PPUSH
63900: PPUSH
63901: PPUSH
63902: PPUSH
63903: PPUSH
63904: PPUSH
63905: PPUSH
63906: PPUSH
63907: PPUSH
63908: PPUSH
63909: PPUSH
63910: PPUSH
63911: PPUSH
63912: PPUSH
63913: PPUSH
63914: PPUSH
63915: PPUSH
// result = [ ] ;
63916: LD_ADDR_VAR 0 7
63920: PUSH
63921: EMPTY
63922: ST_TO_ADDR
// temp_list = [ ] ;
63923: LD_ADDR_VAR 0 9
63927: PUSH
63928: EMPTY
63929: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63930: LD_VAR 0 4
63934: PUSH
63935: LD_INT 0
63937: PUSH
63938: LD_INT 1
63940: PUSH
63941: LD_INT 2
63943: PUSH
63944: LD_INT 3
63946: PUSH
63947: LD_INT 4
63949: PUSH
63950: LD_INT 5
63952: PUSH
63953: EMPTY
63954: LIST
63955: LIST
63956: LIST
63957: LIST
63958: LIST
63959: LIST
63960: IN
63961: NOT
63962: PUSH
63963: LD_VAR 0 1
63967: PUSH
63968: LD_INT 0
63970: PUSH
63971: LD_INT 1
63973: PUSH
63974: EMPTY
63975: LIST
63976: LIST
63977: IN
63978: PUSH
63979: LD_VAR 0 5
63983: PUSH
63984: LD_INT 1
63986: PUSH
63987: LD_INT 2
63989: PUSH
63990: LD_INT 3
63992: PUSH
63993: EMPTY
63994: LIST
63995: LIST
63996: LIST
63997: IN
63998: NOT
63999: AND
64000: OR
64001: IFFALSE 64005
// exit ;
64003: GO 82396
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
64005: LD_VAR 0 1
64009: PUSH
64010: LD_INT 6
64012: PUSH
64013: LD_INT 7
64015: PUSH
64016: LD_INT 8
64018: PUSH
64019: LD_INT 13
64021: PUSH
64022: LD_INT 12
64024: PUSH
64025: LD_INT 15
64027: PUSH
64028: LD_INT 11
64030: PUSH
64031: LD_INT 14
64033: PUSH
64034: LD_INT 10
64036: PUSH
64037: EMPTY
64038: LIST
64039: LIST
64040: LIST
64041: LIST
64042: LIST
64043: LIST
64044: LIST
64045: LIST
64046: LIST
64047: IN
64048: IFFALSE 64058
// btype = b_lab ;
64050: LD_ADDR_VAR 0 1
64054: PUSH
64055: LD_INT 6
64057: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
64058: LD_VAR 0 6
64062: PUSH
64063: LD_INT 0
64065: PUSH
64066: LD_INT 1
64068: PUSH
64069: LD_INT 2
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: LIST
64076: IN
64077: NOT
64078: PUSH
64079: LD_VAR 0 1
64083: PUSH
64084: LD_INT 0
64086: PUSH
64087: LD_INT 1
64089: PUSH
64090: LD_INT 2
64092: PUSH
64093: LD_INT 3
64095: PUSH
64096: LD_INT 6
64098: PUSH
64099: LD_INT 36
64101: PUSH
64102: LD_INT 4
64104: PUSH
64105: LD_INT 5
64107: PUSH
64108: LD_INT 31
64110: PUSH
64111: LD_INT 32
64113: PUSH
64114: LD_INT 33
64116: PUSH
64117: EMPTY
64118: LIST
64119: LIST
64120: LIST
64121: LIST
64122: LIST
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: IN
64130: NOT
64131: PUSH
64132: LD_VAR 0 6
64136: PUSH
64137: LD_INT 1
64139: EQUAL
64140: AND
64141: OR
64142: PUSH
64143: LD_VAR 0 1
64147: PUSH
64148: LD_INT 2
64150: PUSH
64151: LD_INT 3
64153: PUSH
64154: EMPTY
64155: LIST
64156: LIST
64157: IN
64158: NOT
64159: PUSH
64160: LD_VAR 0 6
64164: PUSH
64165: LD_INT 2
64167: EQUAL
64168: AND
64169: OR
64170: IFFALSE 64180
// mode = 0 ;
64172: LD_ADDR_VAR 0 6
64176: PUSH
64177: LD_INT 0
64179: ST_TO_ADDR
// case mode of 0 :
64180: LD_VAR 0 6
64184: PUSH
64185: LD_INT 0
64187: DOUBLE
64188: EQUAL
64189: IFTRUE 64193
64191: GO 75646
64193: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64194: LD_ADDR_VAR 0 11
64198: PUSH
64199: LD_INT 0
64201: PUSH
64202: LD_INT 0
64204: PUSH
64205: EMPTY
64206: LIST
64207: LIST
64208: PUSH
64209: LD_INT 0
64211: PUSH
64212: LD_INT 1
64214: NEG
64215: PUSH
64216: EMPTY
64217: LIST
64218: LIST
64219: PUSH
64220: LD_INT 1
64222: PUSH
64223: LD_INT 0
64225: PUSH
64226: EMPTY
64227: LIST
64228: LIST
64229: PUSH
64230: LD_INT 1
64232: PUSH
64233: LD_INT 1
64235: PUSH
64236: EMPTY
64237: LIST
64238: LIST
64239: PUSH
64240: LD_INT 0
64242: PUSH
64243: LD_INT 1
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: PUSH
64250: LD_INT 1
64252: NEG
64253: PUSH
64254: LD_INT 0
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PUSH
64261: LD_INT 1
64263: NEG
64264: PUSH
64265: LD_INT 1
64267: NEG
64268: PUSH
64269: EMPTY
64270: LIST
64271: LIST
64272: PUSH
64273: LD_INT 1
64275: NEG
64276: PUSH
64277: LD_INT 2
64279: NEG
64280: PUSH
64281: EMPTY
64282: LIST
64283: LIST
64284: PUSH
64285: LD_INT 0
64287: PUSH
64288: LD_INT 2
64290: NEG
64291: PUSH
64292: EMPTY
64293: LIST
64294: LIST
64295: PUSH
64296: LD_INT 1
64298: PUSH
64299: LD_INT 1
64301: NEG
64302: PUSH
64303: EMPTY
64304: LIST
64305: LIST
64306: PUSH
64307: LD_INT 1
64309: PUSH
64310: LD_INT 2
64312: PUSH
64313: EMPTY
64314: LIST
64315: LIST
64316: PUSH
64317: LD_INT 0
64319: PUSH
64320: LD_INT 2
64322: PUSH
64323: EMPTY
64324: LIST
64325: LIST
64326: PUSH
64327: LD_INT 1
64329: NEG
64330: PUSH
64331: LD_INT 1
64333: PUSH
64334: EMPTY
64335: LIST
64336: LIST
64337: PUSH
64338: LD_INT 1
64340: PUSH
64341: LD_INT 3
64343: PUSH
64344: EMPTY
64345: LIST
64346: LIST
64347: PUSH
64348: LD_INT 0
64350: PUSH
64351: LD_INT 3
64353: PUSH
64354: EMPTY
64355: LIST
64356: LIST
64357: PUSH
64358: LD_INT 1
64360: NEG
64361: PUSH
64362: LD_INT 2
64364: PUSH
64365: EMPTY
64366: LIST
64367: LIST
64368: PUSH
64369: EMPTY
64370: LIST
64371: LIST
64372: LIST
64373: LIST
64374: LIST
64375: LIST
64376: LIST
64377: LIST
64378: LIST
64379: LIST
64380: LIST
64381: LIST
64382: LIST
64383: LIST
64384: LIST
64385: LIST
64386: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64387: LD_ADDR_VAR 0 12
64391: PUSH
64392: LD_INT 0
64394: PUSH
64395: LD_INT 0
64397: PUSH
64398: EMPTY
64399: LIST
64400: LIST
64401: PUSH
64402: LD_INT 0
64404: PUSH
64405: LD_INT 1
64407: NEG
64408: PUSH
64409: EMPTY
64410: LIST
64411: LIST
64412: PUSH
64413: LD_INT 1
64415: PUSH
64416: LD_INT 0
64418: PUSH
64419: EMPTY
64420: LIST
64421: LIST
64422: PUSH
64423: LD_INT 1
64425: PUSH
64426: LD_INT 1
64428: PUSH
64429: EMPTY
64430: LIST
64431: LIST
64432: PUSH
64433: LD_INT 0
64435: PUSH
64436: LD_INT 1
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: LD_INT 1
64445: NEG
64446: PUSH
64447: LD_INT 0
64449: PUSH
64450: EMPTY
64451: LIST
64452: LIST
64453: PUSH
64454: LD_INT 1
64456: NEG
64457: PUSH
64458: LD_INT 1
64460: NEG
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: PUSH
64466: LD_INT 1
64468: PUSH
64469: LD_INT 1
64471: NEG
64472: PUSH
64473: EMPTY
64474: LIST
64475: LIST
64476: PUSH
64477: LD_INT 2
64479: PUSH
64480: LD_INT 0
64482: PUSH
64483: EMPTY
64484: LIST
64485: LIST
64486: PUSH
64487: LD_INT 2
64489: PUSH
64490: LD_INT 1
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PUSH
64497: LD_INT 1
64499: NEG
64500: PUSH
64501: LD_INT 1
64503: PUSH
64504: EMPTY
64505: LIST
64506: LIST
64507: PUSH
64508: LD_INT 2
64510: NEG
64511: PUSH
64512: LD_INT 0
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PUSH
64519: LD_INT 2
64521: NEG
64522: PUSH
64523: LD_INT 1
64525: NEG
64526: PUSH
64527: EMPTY
64528: LIST
64529: LIST
64530: PUSH
64531: LD_INT 2
64533: NEG
64534: PUSH
64535: LD_INT 1
64537: PUSH
64538: EMPTY
64539: LIST
64540: LIST
64541: PUSH
64542: LD_INT 3
64544: NEG
64545: PUSH
64546: LD_INT 0
64548: PUSH
64549: EMPTY
64550: LIST
64551: LIST
64552: PUSH
64553: LD_INT 3
64555: NEG
64556: PUSH
64557: LD_INT 1
64559: NEG
64560: PUSH
64561: EMPTY
64562: LIST
64563: LIST
64564: PUSH
64565: EMPTY
64566: LIST
64567: LIST
64568: LIST
64569: LIST
64570: LIST
64571: LIST
64572: LIST
64573: LIST
64574: LIST
64575: LIST
64576: LIST
64577: LIST
64578: LIST
64579: LIST
64580: LIST
64581: LIST
64582: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64583: LD_ADDR_VAR 0 13
64587: PUSH
64588: LD_INT 0
64590: PUSH
64591: LD_INT 0
64593: PUSH
64594: EMPTY
64595: LIST
64596: LIST
64597: PUSH
64598: LD_INT 0
64600: PUSH
64601: LD_INT 1
64603: NEG
64604: PUSH
64605: EMPTY
64606: LIST
64607: LIST
64608: PUSH
64609: LD_INT 1
64611: PUSH
64612: LD_INT 0
64614: PUSH
64615: EMPTY
64616: LIST
64617: LIST
64618: PUSH
64619: LD_INT 1
64621: PUSH
64622: LD_INT 1
64624: PUSH
64625: EMPTY
64626: LIST
64627: LIST
64628: PUSH
64629: LD_INT 0
64631: PUSH
64632: LD_INT 1
64634: PUSH
64635: EMPTY
64636: LIST
64637: LIST
64638: PUSH
64639: LD_INT 1
64641: NEG
64642: PUSH
64643: LD_INT 0
64645: PUSH
64646: EMPTY
64647: LIST
64648: LIST
64649: PUSH
64650: LD_INT 1
64652: NEG
64653: PUSH
64654: LD_INT 1
64656: NEG
64657: PUSH
64658: EMPTY
64659: LIST
64660: LIST
64661: PUSH
64662: LD_INT 1
64664: NEG
64665: PUSH
64666: LD_INT 2
64668: NEG
64669: PUSH
64670: EMPTY
64671: LIST
64672: LIST
64673: PUSH
64674: LD_INT 2
64676: PUSH
64677: LD_INT 1
64679: PUSH
64680: EMPTY
64681: LIST
64682: LIST
64683: PUSH
64684: LD_INT 2
64686: PUSH
64687: LD_INT 2
64689: PUSH
64690: EMPTY
64691: LIST
64692: LIST
64693: PUSH
64694: LD_INT 1
64696: PUSH
64697: LD_INT 2
64699: PUSH
64700: EMPTY
64701: LIST
64702: LIST
64703: PUSH
64704: LD_INT 2
64706: NEG
64707: PUSH
64708: LD_INT 1
64710: NEG
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: PUSH
64716: LD_INT 2
64718: NEG
64719: PUSH
64720: LD_INT 2
64722: NEG
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: PUSH
64728: LD_INT 2
64730: NEG
64731: PUSH
64732: LD_INT 3
64734: NEG
64735: PUSH
64736: EMPTY
64737: LIST
64738: LIST
64739: PUSH
64740: LD_INT 3
64742: NEG
64743: PUSH
64744: LD_INT 2
64746: NEG
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: PUSH
64752: LD_INT 3
64754: NEG
64755: PUSH
64756: LD_INT 3
64758: NEG
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: EMPTY
64765: LIST
64766: LIST
64767: LIST
64768: LIST
64769: LIST
64770: LIST
64771: LIST
64772: LIST
64773: LIST
64774: LIST
64775: LIST
64776: LIST
64777: LIST
64778: LIST
64779: LIST
64780: LIST
64781: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64782: LD_ADDR_VAR 0 14
64786: PUSH
64787: LD_INT 0
64789: PUSH
64790: LD_INT 0
64792: PUSH
64793: EMPTY
64794: LIST
64795: LIST
64796: PUSH
64797: LD_INT 0
64799: PUSH
64800: LD_INT 1
64802: NEG
64803: PUSH
64804: EMPTY
64805: LIST
64806: LIST
64807: PUSH
64808: LD_INT 1
64810: PUSH
64811: LD_INT 0
64813: PUSH
64814: EMPTY
64815: LIST
64816: LIST
64817: PUSH
64818: LD_INT 1
64820: PUSH
64821: LD_INT 1
64823: PUSH
64824: EMPTY
64825: LIST
64826: LIST
64827: PUSH
64828: LD_INT 0
64830: PUSH
64831: LD_INT 1
64833: PUSH
64834: EMPTY
64835: LIST
64836: LIST
64837: PUSH
64838: LD_INT 1
64840: NEG
64841: PUSH
64842: LD_INT 0
64844: PUSH
64845: EMPTY
64846: LIST
64847: LIST
64848: PUSH
64849: LD_INT 1
64851: NEG
64852: PUSH
64853: LD_INT 1
64855: NEG
64856: PUSH
64857: EMPTY
64858: LIST
64859: LIST
64860: PUSH
64861: LD_INT 1
64863: NEG
64864: PUSH
64865: LD_INT 2
64867: NEG
64868: PUSH
64869: EMPTY
64870: LIST
64871: LIST
64872: PUSH
64873: LD_INT 0
64875: PUSH
64876: LD_INT 2
64878: NEG
64879: PUSH
64880: EMPTY
64881: LIST
64882: LIST
64883: PUSH
64884: LD_INT 1
64886: PUSH
64887: LD_INT 1
64889: NEG
64890: PUSH
64891: EMPTY
64892: LIST
64893: LIST
64894: PUSH
64895: LD_INT 1
64897: PUSH
64898: LD_INT 2
64900: PUSH
64901: EMPTY
64902: LIST
64903: LIST
64904: PUSH
64905: LD_INT 0
64907: PUSH
64908: LD_INT 2
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PUSH
64915: LD_INT 1
64917: NEG
64918: PUSH
64919: LD_INT 1
64921: PUSH
64922: EMPTY
64923: LIST
64924: LIST
64925: PUSH
64926: LD_INT 1
64928: NEG
64929: PUSH
64930: LD_INT 3
64932: NEG
64933: PUSH
64934: EMPTY
64935: LIST
64936: LIST
64937: PUSH
64938: LD_INT 0
64940: PUSH
64941: LD_INT 3
64943: NEG
64944: PUSH
64945: EMPTY
64946: LIST
64947: LIST
64948: PUSH
64949: LD_INT 1
64951: PUSH
64952: LD_INT 2
64954: NEG
64955: PUSH
64956: EMPTY
64957: LIST
64958: LIST
64959: PUSH
64960: EMPTY
64961: LIST
64962: LIST
64963: LIST
64964: LIST
64965: LIST
64966: LIST
64967: LIST
64968: LIST
64969: LIST
64970: LIST
64971: LIST
64972: LIST
64973: LIST
64974: LIST
64975: LIST
64976: LIST
64977: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64978: LD_ADDR_VAR 0 15
64982: PUSH
64983: LD_INT 0
64985: PUSH
64986: LD_INT 0
64988: PUSH
64989: EMPTY
64990: LIST
64991: LIST
64992: PUSH
64993: LD_INT 0
64995: PUSH
64996: LD_INT 1
64998: NEG
64999: PUSH
65000: EMPTY
65001: LIST
65002: LIST
65003: PUSH
65004: LD_INT 1
65006: PUSH
65007: LD_INT 0
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PUSH
65014: LD_INT 1
65016: PUSH
65017: LD_INT 1
65019: PUSH
65020: EMPTY
65021: LIST
65022: LIST
65023: PUSH
65024: LD_INT 0
65026: PUSH
65027: LD_INT 1
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: PUSH
65034: LD_INT 1
65036: NEG
65037: PUSH
65038: LD_INT 0
65040: PUSH
65041: EMPTY
65042: LIST
65043: LIST
65044: PUSH
65045: LD_INT 1
65047: NEG
65048: PUSH
65049: LD_INT 1
65051: NEG
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: PUSH
65057: LD_INT 1
65059: PUSH
65060: LD_INT 1
65062: NEG
65063: PUSH
65064: EMPTY
65065: LIST
65066: LIST
65067: PUSH
65068: LD_INT 2
65070: PUSH
65071: LD_INT 0
65073: PUSH
65074: EMPTY
65075: LIST
65076: LIST
65077: PUSH
65078: LD_INT 2
65080: PUSH
65081: LD_INT 1
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PUSH
65088: LD_INT 1
65090: NEG
65091: PUSH
65092: LD_INT 1
65094: PUSH
65095: EMPTY
65096: LIST
65097: LIST
65098: PUSH
65099: LD_INT 2
65101: NEG
65102: PUSH
65103: LD_INT 0
65105: PUSH
65106: EMPTY
65107: LIST
65108: LIST
65109: PUSH
65110: LD_INT 2
65112: NEG
65113: PUSH
65114: LD_INT 1
65116: NEG
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: PUSH
65122: LD_INT 2
65124: PUSH
65125: LD_INT 1
65127: NEG
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: LD_INT 3
65135: PUSH
65136: LD_INT 0
65138: PUSH
65139: EMPTY
65140: LIST
65141: LIST
65142: PUSH
65143: LD_INT 3
65145: PUSH
65146: LD_INT 1
65148: PUSH
65149: EMPTY
65150: LIST
65151: LIST
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65171: LD_ADDR_VAR 0 16
65175: PUSH
65176: LD_INT 0
65178: PUSH
65179: LD_INT 0
65181: PUSH
65182: EMPTY
65183: LIST
65184: LIST
65185: PUSH
65186: LD_INT 0
65188: PUSH
65189: LD_INT 1
65191: NEG
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: PUSH
65197: LD_INT 1
65199: PUSH
65200: LD_INT 0
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PUSH
65207: LD_INT 1
65209: PUSH
65210: LD_INT 1
65212: PUSH
65213: EMPTY
65214: LIST
65215: LIST
65216: PUSH
65217: LD_INT 0
65219: PUSH
65220: LD_INT 1
65222: PUSH
65223: EMPTY
65224: LIST
65225: LIST
65226: PUSH
65227: LD_INT 1
65229: NEG
65230: PUSH
65231: LD_INT 0
65233: PUSH
65234: EMPTY
65235: LIST
65236: LIST
65237: PUSH
65238: LD_INT 1
65240: NEG
65241: PUSH
65242: LD_INT 1
65244: NEG
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: PUSH
65250: LD_INT 1
65252: NEG
65253: PUSH
65254: LD_INT 2
65256: NEG
65257: PUSH
65258: EMPTY
65259: LIST
65260: LIST
65261: PUSH
65262: LD_INT 2
65264: PUSH
65265: LD_INT 1
65267: PUSH
65268: EMPTY
65269: LIST
65270: LIST
65271: PUSH
65272: LD_INT 2
65274: PUSH
65275: LD_INT 2
65277: PUSH
65278: EMPTY
65279: LIST
65280: LIST
65281: PUSH
65282: LD_INT 1
65284: PUSH
65285: LD_INT 2
65287: PUSH
65288: EMPTY
65289: LIST
65290: LIST
65291: PUSH
65292: LD_INT 2
65294: NEG
65295: PUSH
65296: LD_INT 1
65298: NEG
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: PUSH
65304: LD_INT 2
65306: NEG
65307: PUSH
65308: LD_INT 2
65310: NEG
65311: PUSH
65312: EMPTY
65313: LIST
65314: LIST
65315: PUSH
65316: LD_INT 3
65318: PUSH
65319: LD_INT 2
65321: PUSH
65322: EMPTY
65323: LIST
65324: LIST
65325: PUSH
65326: LD_INT 3
65328: PUSH
65329: LD_INT 3
65331: PUSH
65332: EMPTY
65333: LIST
65334: LIST
65335: PUSH
65336: LD_INT 2
65338: PUSH
65339: LD_INT 3
65341: PUSH
65342: EMPTY
65343: LIST
65344: LIST
65345: PUSH
65346: EMPTY
65347: LIST
65348: LIST
65349: LIST
65350: LIST
65351: LIST
65352: LIST
65353: LIST
65354: LIST
65355: LIST
65356: LIST
65357: LIST
65358: LIST
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65364: LD_ADDR_VAR 0 17
65368: PUSH
65369: LD_INT 0
65371: PUSH
65372: LD_INT 0
65374: PUSH
65375: EMPTY
65376: LIST
65377: LIST
65378: PUSH
65379: LD_INT 0
65381: PUSH
65382: LD_INT 1
65384: NEG
65385: PUSH
65386: EMPTY
65387: LIST
65388: LIST
65389: PUSH
65390: LD_INT 1
65392: PUSH
65393: LD_INT 0
65395: PUSH
65396: EMPTY
65397: LIST
65398: LIST
65399: PUSH
65400: LD_INT 1
65402: PUSH
65403: LD_INT 1
65405: PUSH
65406: EMPTY
65407: LIST
65408: LIST
65409: PUSH
65410: LD_INT 0
65412: PUSH
65413: LD_INT 1
65415: PUSH
65416: EMPTY
65417: LIST
65418: LIST
65419: PUSH
65420: LD_INT 1
65422: NEG
65423: PUSH
65424: LD_INT 0
65426: PUSH
65427: EMPTY
65428: LIST
65429: LIST
65430: PUSH
65431: LD_INT 1
65433: NEG
65434: PUSH
65435: LD_INT 1
65437: NEG
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: LD_INT 1
65445: NEG
65446: PUSH
65447: LD_INT 2
65449: NEG
65450: PUSH
65451: EMPTY
65452: LIST
65453: LIST
65454: PUSH
65455: LD_INT 0
65457: PUSH
65458: LD_INT 2
65460: NEG
65461: PUSH
65462: EMPTY
65463: LIST
65464: LIST
65465: PUSH
65466: LD_INT 1
65468: PUSH
65469: LD_INT 1
65471: NEG
65472: PUSH
65473: EMPTY
65474: LIST
65475: LIST
65476: PUSH
65477: LD_INT 2
65479: PUSH
65480: LD_INT 0
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 2
65489: PUSH
65490: LD_INT 1
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PUSH
65497: LD_INT 2
65499: PUSH
65500: LD_INT 2
65502: PUSH
65503: EMPTY
65504: LIST
65505: LIST
65506: PUSH
65507: LD_INT 1
65509: PUSH
65510: LD_INT 2
65512: PUSH
65513: EMPTY
65514: LIST
65515: LIST
65516: PUSH
65517: LD_INT 0
65519: PUSH
65520: LD_INT 2
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: PUSH
65527: LD_INT 1
65529: NEG
65530: PUSH
65531: LD_INT 1
65533: PUSH
65534: EMPTY
65535: LIST
65536: LIST
65537: PUSH
65538: LD_INT 2
65540: NEG
65541: PUSH
65542: LD_INT 0
65544: PUSH
65545: EMPTY
65546: LIST
65547: LIST
65548: PUSH
65549: LD_INT 2
65551: NEG
65552: PUSH
65553: LD_INT 1
65555: NEG
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PUSH
65561: LD_INT 2
65563: NEG
65564: PUSH
65565: LD_INT 2
65567: NEG
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: EMPTY
65574: LIST
65575: LIST
65576: LIST
65577: LIST
65578: LIST
65579: LIST
65580: LIST
65581: LIST
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65594: LD_ADDR_VAR 0 18
65598: PUSH
65599: LD_INT 0
65601: PUSH
65602: LD_INT 0
65604: PUSH
65605: EMPTY
65606: LIST
65607: LIST
65608: PUSH
65609: LD_INT 0
65611: PUSH
65612: LD_INT 1
65614: NEG
65615: PUSH
65616: EMPTY
65617: LIST
65618: LIST
65619: PUSH
65620: LD_INT 1
65622: PUSH
65623: LD_INT 0
65625: PUSH
65626: EMPTY
65627: LIST
65628: LIST
65629: PUSH
65630: LD_INT 1
65632: PUSH
65633: LD_INT 1
65635: PUSH
65636: EMPTY
65637: LIST
65638: LIST
65639: PUSH
65640: LD_INT 0
65642: PUSH
65643: LD_INT 1
65645: PUSH
65646: EMPTY
65647: LIST
65648: LIST
65649: PUSH
65650: LD_INT 1
65652: NEG
65653: PUSH
65654: LD_INT 0
65656: PUSH
65657: EMPTY
65658: LIST
65659: LIST
65660: PUSH
65661: LD_INT 1
65663: NEG
65664: PUSH
65665: LD_INT 1
65667: NEG
65668: PUSH
65669: EMPTY
65670: LIST
65671: LIST
65672: PUSH
65673: LD_INT 1
65675: NEG
65676: PUSH
65677: LD_INT 2
65679: NEG
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: PUSH
65685: LD_INT 0
65687: PUSH
65688: LD_INT 2
65690: NEG
65691: PUSH
65692: EMPTY
65693: LIST
65694: LIST
65695: PUSH
65696: LD_INT 1
65698: PUSH
65699: LD_INT 1
65701: NEG
65702: PUSH
65703: EMPTY
65704: LIST
65705: LIST
65706: PUSH
65707: LD_INT 2
65709: PUSH
65710: LD_INT 0
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: PUSH
65717: LD_INT 2
65719: PUSH
65720: LD_INT 1
65722: PUSH
65723: EMPTY
65724: LIST
65725: LIST
65726: PUSH
65727: LD_INT 2
65729: PUSH
65730: LD_INT 2
65732: PUSH
65733: EMPTY
65734: LIST
65735: LIST
65736: PUSH
65737: LD_INT 1
65739: PUSH
65740: LD_INT 2
65742: PUSH
65743: EMPTY
65744: LIST
65745: LIST
65746: PUSH
65747: LD_INT 0
65749: PUSH
65750: LD_INT 2
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: LD_INT 1
65759: NEG
65760: PUSH
65761: LD_INT 1
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: PUSH
65768: LD_INT 2
65770: NEG
65771: PUSH
65772: LD_INT 0
65774: PUSH
65775: EMPTY
65776: LIST
65777: LIST
65778: PUSH
65779: LD_INT 2
65781: NEG
65782: PUSH
65783: LD_INT 1
65785: NEG
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PUSH
65791: LD_INT 2
65793: NEG
65794: PUSH
65795: LD_INT 2
65797: NEG
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: EMPTY
65804: LIST
65805: LIST
65806: LIST
65807: LIST
65808: LIST
65809: LIST
65810: LIST
65811: LIST
65812: LIST
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65824: LD_ADDR_VAR 0 19
65828: PUSH
65829: LD_INT 0
65831: PUSH
65832: LD_INT 0
65834: PUSH
65835: EMPTY
65836: LIST
65837: LIST
65838: PUSH
65839: LD_INT 0
65841: PUSH
65842: LD_INT 1
65844: NEG
65845: PUSH
65846: EMPTY
65847: LIST
65848: LIST
65849: PUSH
65850: LD_INT 1
65852: PUSH
65853: LD_INT 0
65855: PUSH
65856: EMPTY
65857: LIST
65858: LIST
65859: PUSH
65860: LD_INT 1
65862: PUSH
65863: LD_INT 1
65865: PUSH
65866: EMPTY
65867: LIST
65868: LIST
65869: PUSH
65870: LD_INT 0
65872: PUSH
65873: LD_INT 1
65875: PUSH
65876: EMPTY
65877: LIST
65878: LIST
65879: PUSH
65880: LD_INT 1
65882: NEG
65883: PUSH
65884: LD_INT 0
65886: PUSH
65887: EMPTY
65888: LIST
65889: LIST
65890: PUSH
65891: LD_INT 1
65893: NEG
65894: PUSH
65895: LD_INT 1
65897: NEG
65898: PUSH
65899: EMPTY
65900: LIST
65901: LIST
65902: PUSH
65903: LD_INT 1
65905: NEG
65906: PUSH
65907: LD_INT 2
65909: NEG
65910: PUSH
65911: EMPTY
65912: LIST
65913: LIST
65914: PUSH
65915: LD_INT 0
65917: PUSH
65918: LD_INT 2
65920: NEG
65921: PUSH
65922: EMPTY
65923: LIST
65924: LIST
65925: PUSH
65926: LD_INT 1
65928: PUSH
65929: LD_INT 1
65931: NEG
65932: PUSH
65933: EMPTY
65934: LIST
65935: LIST
65936: PUSH
65937: LD_INT 2
65939: PUSH
65940: LD_INT 0
65942: PUSH
65943: EMPTY
65944: LIST
65945: LIST
65946: PUSH
65947: LD_INT 2
65949: PUSH
65950: LD_INT 1
65952: PUSH
65953: EMPTY
65954: LIST
65955: LIST
65956: PUSH
65957: LD_INT 2
65959: PUSH
65960: LD_INT 2
65962: PUSH
65963: EMPTY
65964: LIST
65965: LIST
65966: PUSH
65967: LD_INT 1
65969: PUSH
65970: LD_INT 2
65972: PUSH
65973: EMPTY
65974: LIST
65975: LIST
65976: PUSH
65977: LD_INT 0
65979: PUSH
65980: LD_INT 2
65982: PUSH
65983: EMPTY
65984: LIST
65985: LIST
65986: PUSH
65987: LD_INT 1
65989: NEG
65990: PUSH
65991: LD_INT 1
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: PUSH
65998: LD_INT 2
66000: NEG
66001: PUSH
66002: LD_INT 0
66004: PUSH
66005: EMPTY
66006: LIST
66007: LIST
66008: PUSH
66009: LD_INT 2
66011: NEG
66012: PUSH
66013: LD_INT 1
66015: NEG
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PUSH
66021: LD_INT 2
66023: NEG
66024: PUSH
66025: LD_INT 2
66027: NEG
66028: PUSH
66029: EMPTY
66030: LIST
66031: LIST
66032: PUSH
66033: EMPTY
66034: LIST
66035: LIST
66036: LIST
66037: LIST
66038: LIST
66039: LIST
66040: LIST
66041: LIST
66042: LIST
66043: LIST
66044: LIST
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66054: LD_ADDR_VAR 0 20
66058: PUSH
66059: LD_INT 0
66061: PUSH
66062: LD_INT 0
66064: PUSH
66065: EMPTY
66066: LIST
66067: LIST
66068: PUSH
66069: LD_INT 0
66071: PUSH
66072: LD_INT 1
66074: NEG
66075: PUSH
66076: EMPTY
66077: LIST
66078: LIST
66079: PUSH
66080: LD_INT 1
66082: PUSH
66083: LD_INT 0
66085: PUSH
66086: EMPTY
66087: LIST
66088: LIST
66089: PUSH
66090: LD_INT 1
66092: PUSH
66093: LD_INT 1
66095: PUSH
66096: EMPTY
66097: LIST
66098: LIST
66099: PUSH
66100: LD_INT 0
66102: PUSH
66103: LD_INT 1
66105: PUSH
66106: EMPTY
66107: LIST
66108: LIST
66109: PUSH
66110: LD_INT 1
66112: NEG
66113: PUSH
66114: LD_INT 0
66116: PUSH
66117: EMPTY
66118: LIST
66119: LIST
66120: PUSH
66121: LD_INT 1
66123: NEG
66124: PUSH
66125: LD_INT 1
66127: NEG
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PUSH
66133: LD_INT 1
66135: NEG
66136: PUSH
66137: LD_INT 2
66139: NEG
66140: PUSH
66141: EMPTY
66142: LIST
66143: LIST
66144: PUSH
66145: LD_INT 0
66147: PUSH
66148: LD_INT 2
66150: NEG
66151: PUSH
66152: EMPTY
66153: LIST
66154: LIST
66155: PUSH
66156: LD_INT 1
66158: PUSH
66159: LD_INT 1
66161: NEG
66162: PUSH
66163: EMPTY
66164: LIST
66165: LIST
66166: PUSH
66167: LD_INT 2
66169: PUSH
66170: LD_INT 0
66172: PUSH
66173: EMPTY
66174: LIST
66175: LIST
66176: PUSH
66177: LD_INT 2
66179: PUSH
66180: LD_INT 1
66182: PUSH
66183: EMPTY
66184: LIST
66185: LIST
66186: PUSH
66187: LD_INT 2
66189: PUSH
66190: LD_INT 2
66192: PUSH
66193: EMPTY
66194: LIST
66195: LIST
66196: PUSH
66197: LD_INT 1
66199: PUSH
66200: LD_INT 2
66202: PUSH
66203: EMPTY
66204: LIST
66205: LIST
66206: PUSH
66207: LD_INT 0
66209: PUSH
66210: LD_INT 2
66212: PUSH
66213: EMPTY
66214: LIST
66215: LIST
66216: PUSH
66217: LD_INT 1
66219: NEG
66220: PUSH
66221: LD_INT 1
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: LD_INT 2
66230: NEG
66231: PUSH
66232: LD_INT 0
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: PUSH
66239: LD_INT 2
66241: NEG
66242: PUSH
66243: LD_INT 1
66245: NEG
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: PUSH
66251: LD_INT 2
66253: NEG
66254: PUSH
66255: LD_INT 2
66257: NEG
66258: PUSH
66259: EMPTY
66260: LIST
66261: LIST
66262: PUSH
66263: EMPTY
66264: LIST
66265: LIST
66266: LIST
66267: LIST
66268: LIST
66269: LIST
66270: LIST
66271: LIST
66272: LIST
66273: LIST
66274: LIST
66275: LIST
66276: LIST
66277: LIST
66278: LIST
66279: LIST
66280: LIST
66281: LIST
66282: LIST
66283: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66284: LD_ADDR_VAR 0 21
66288: PUSH
66289: LD_INT 0
66291: PUSH
66292: LD_INT 0
66294: PUSH
66295: EMPTY
66296: LIST
66297: LIST
66298: PUSH
66299: LD_INT 0
66301: PUSH
66302: LD_INT 1
66304: NEG
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PUSH
66310: LD_INT 1
66312: PUSH
66313: LD_INT 0
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: LD_INT 1
66322: PUSH
66323: LD_INT 1
66325: PUSH
66326: EMPTY
66327: LIST
66328: LIST
66329: PUSH
66330: LD_INT 0
66332: PUSH
66333: LD_INT 1
66335: PUSH
66336: EMPTY
66337: LIST
66338: LIST
66339: PUSH
66340: LD_INT 1
66342: NEG
66343: PUSH
66344: LD_INT 0
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PUSH
66351: LD_INT 1
66353: NEG
66354: PUSH
66355: LD_INT 1
66357: NEG
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: PUSH
66363: LD_INT 1
66365: NEG
66366: PUSH
66367: LD_INT 2
66369: NEG
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: LD_INT 0
66377: PUSH
66378: LD_INT 2
66380: NEG
66381: PUSH
66382: EMPTY
66383: LIST
66384: LIST
66385: PUSH
66386: LD_INT 1
66388: PUSH
66389: LD_INT 1
66391: NEG
66392: PUSH
66393: EMPTY
66394: LIST
66395: LIST
66396: PUSH
66397: LD_INT 2
66399: PUSH
66400: LD_INT 0
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PUSH
66407: LD_INT 2
66409: PUSH
66410: LD_INT 1
66412: PUSH
66413: EMPTY
66414: LIST
66415: LIST
66416: PUSH
66417: LD_INT 2
66419: PUSH
66420: LD_INT 2
66422: PUSH
66423: EMPTY
66424: LIST
66425: LIST
66426: PUSH
66427: LD_INT 1
66429: PUSH
66430: LD_INT 2
66432: PUSH
66433: EMPTY
66434: LIST
66435: LIST
66436: PUSH
66437: LD_INT 0
66439: PUSH
66440: LD_INT 2
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: PUSH
66447: LD_INT 1
66449: NEG
66450: PUSH
66451: LD_INT 1
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PUSH
66458: LD_INT 2
66460: NEG
66461: PUSH
66462: LD_INT 0
66464: PUSH
66465: EMPTY
66466: LIST
66467: LIST
66468: PUSH
66469: LD_INT 2
66471: NEG
66472: PUSH
66473: LD_INT 1
66475: NEG
66476: PUSH
66477: EMPTY
66478: LIST
66479: LIST
66480: PUSH
66481: LD_INT 2
66483: NEG
66484: PUSH
66485: LD_INT 2
66487: NEG
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: EMPTY
66494: LIST
66495: LIST
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66514: LD_ADDR_VAR 0 22
66518: PUSH
66519: LD_INT 0
66521: PUSH
66522: LD_INT 0
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PUSH
66529: LD_INT 0
66531: PUSH
66532: LD_INT 1
66534: NEG
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 1
66542: PUSH
66543: LD_INT 0
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: LD_INT 1
66552: PUSH
66553: LD_INT 1
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: PUSH
66560: LD_INT 0
66562: PUSH
66563: LD_INT 1
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 1
66572: NEG
66573: PUSH
66574: LD_INT 0
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 1
66583: NEG
66584: PUSH
66585: LD_INT 1
66587: NEG
66588: PUSH
66589: EMPTY
66590: LIST
66591: LIST
66592: PUSH
66593: LD_INT 1
66595: NEG
66596: PUSH
66597: LD_INT 2
66599: NEG
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PUSH
66605: LD_INT 0
66607: PUSH
66608: LD_INT 2
66610: NEG
66611: PUSH
66612: EMPTY
66613: LIST
66614: LIST
66615: PUSH
66616: LD_INT 1
66618: PUSH
66619: LD_INT 1
66621: NEG
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 2
66629: PUSH
66630: LD_INT 0
66632: PUSH
66633: EMPTY
66634: LIST
66635: LIST
66636: PUSH
66637: LD_INT 2
66639: PUSH
66640: LD_INT 1
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: PUSH
66647: LD_INT 2
66649: PUSH
66650: LD_INT 2
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: PUSH
66657: LD_INT 1
66659: PUSH
66660: LD_INT 2
66662: PUSH
66663: EMPTY
66664: LIST
66665: LIST
66666: PUSH
66667: LD_INT 0
66669: PUSH
66670: LD_INT 2
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: LD_INT 1
66679: NEG
66680: PUSH
66681: LD_INT 1
66683: PUSH
66684: EMPTY
66685: LIST
66686: LIST
66687: PUSH
66688: LD_INT 2
66690: NEG
66691: PUSH
66692: LD_INT 0
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: LD_INT 2
66701: NEG
66702: PUSH
66703: LD_INT 1
66705: NEG
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: PUSH
66711: LD_INT 2
66713: NEG
66714: PUSH
66715: LD_INT 2
66717: NEG
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: LIST
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66744: LD_ADDR_VAR 0 23
66748: PUSH
66749: LD_INT 0
66751: PUSH
66752: LD_INT 0
66754: PUSH
66755: EMPTY
66756: LIST
66757: LIST
66758: PUSH
66759: LD_INT 0
66761: PUSH
66762: LD_INT 1
66764: NEG
66765: PUSH
66766: EMPTY
66767: LIST
66768: LIST
66769: PUSH
66770: LD_INT 1
66772: PUSH
66773: LD_INT 0
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 1
66782: PUSH
66783: LD_INT 1
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: LD_INT 0
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 1
66802: NEG
66803: PUSH
66804: LD_INT 0
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: LD_INT 1
66813: NEG
66814: PUSH
66815: LD_INT 1
66817: NEG
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 1
66825: NEG
66826: PUSH
66827: LD_INT 2
66829: NEG
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PUSH
66835: LD_INT 0
66837: PUSH
66838: LD_INT 2
66840: NEG
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: LD_INT 1
66848: PUSH
66849: LD_INT 1
66851: NEG
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: LD_INT 2
66859: PUSH
66860: LD_INT 0
66862: PUSH
66863: EMPTY
66864: LIST
66865: LIST
66866: PUSH
66867: LD_INT 2
66869: PUSH
66870: LD_INT 1
66872: PUSH
66873: EMPTY
66874: LIST
66875: LIST
66876: PUSH
66877: LD_INT 2
66879: PUSH
66880: LD_INT 2
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: PUSH
66887: LD_INT 1
66889: PUSH
66890: LD_INT 2
66892: PUSH
66893: EMPTY
66894: LIST
66895: LIST
66896: PUSH
66897: LD_INT 0
66899: PUSH
66900: LD_INT 2
66902: PUSH
66903: EMPTY
66904: LIST
66905: LIST
66906: PUSH
66907: LD_INT 1
66909: NEG
66910: PUSH
66911: LD_INT 1
66913: PUSH
66914: EMPTY
66915: LIST
66916: LIST
66917: PUSH
66918: LD_INT 2
66920: NEG
66921: PUSH
66922: LD_INT 0
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 2
66931: NEG
66932: PUSH
66933: LD_INT 1
66935: NEG
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PUSH
66941: LD_INT 2
66943: NEG
66944: PUSH
66945: LD_INT 2
66947: NEG
66948: PUSH
66949: EMPTY
66950: LIST
66951: LIST
66952: PUSH
66953: LD_INT 2
66955: NEG
66956: PUSH
66957: LD_INT 3
66959: NEG
66960: PUSH
66961: EMPTY
66962: LIST
66963: LIST
66964: PUSH
66965: LD_INT 1
66967: NEG
66968: PUSH
66969: LD_INT 3
66971: NEG
66972: PUSH
66973: EMPTY
66974: LIST
66975: LIST
66976: PUSH
66977: LD_INT 1
66979: PUSH
66980: LD_INT 2
66982: NEG
66983: PUSH
66984: EMPTY
66985: LIST
66986: LIST
66987: PUSH
66988: LD_INT 2
66990: PUSH
66991: LD_INT 1
66993: NEG
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: LIST
67022: LIST
67023: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
67024: LD_ADDR_VAR 0 24
67028: PUSH
67029: LD_INT 0
67031: PUSH
67032: LD_INT 0
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 0
67041: PUSH
67042: LD_INT 1
67044: NEG
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PUSH
67050: LD_INT 1
67052: PUSH
67053: LD_INT 0
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 1
67062: PUSH
67063: LD_INT 1
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: PUSH
67070: LD_INT 0
67072: PUSH
67073: LD_INT 1
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 1
67082: NEG
67083: PUSH
67084: LD_INT 0
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 1
67093: NEG
67094: PUSH
67095: LD_INT 1
67097: NEG
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: PUSH
67103: LD_INT 1
67105: NEG
67106: PUSH
67107: LD_INT 2
67109: NEG
67110: PUSH
67111: EMPTY
67112: LIST
67113: LIST
67114: PUSH
67115: LD_INT 0
67117: PUSH
67118: LD_INT 2
67120: NEG
67121: PUSH
67122: EMPTY
67123: LIST
67124: LIST
67125: PUSH
67126: LD_INT 1
67128: PUSH
67129: LD_INT 1
67131: NEG
67132: PUSH
67133: EMPTY
67134: LIST
67135: LIST
67136: PUSH
67137: LD_INT 2
67139: PUSH
67140: LD_INT 0
67142: PUSH
67143: EMPTY
67144: LIST
67145: LIST
67146: PUSH
67147: LD_INT 2
67149: PUSH
67150: LD_INT 1
67152: PUSH
67153: EMPTY
67154: LIST
67155: LIST
67156: PUSH
67157: LD_INT 2
67159: PUSH
67160: LD_INT 2
67162: PUSH
67163: EMPTY
67164: LIST
67165: LIST
67166: PUSH
67167: LD_INT 1
67169: PUSH
67170: LD_INT 2
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 0
67179: PUSH
67180: LD_INT 2
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: LD_INT 1
67189: NEG
67190: PUSH
67191: LD_INT 1
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 2
67200: NEG
67201: PUSH
67202: LD_INT 0
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: LD_INT 2
67211: NEG
67212: PUSH
67213: LD_INT 1
67215: NEG
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 2
67223: NEG
67224: PUSH
67225: LD_INT 2
67227: NEG
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: LD_INT 1
67235: PUSH
67236: LD_INT 2
67238: NEG
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 2
67246: PUSH
67247: LD_INT 1
67249: NEG
67250: PUSH
67251: EMPTY
67252: LIST
67253: LIST
67254: PUSH
67255: LD_INT 3
67257: PUSH
67258: LD_INT 1
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: PUSH
67265: LD_INT 3
67267: PUSH
67268: LD_INT 2
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: PUSH
67275: EMPTY
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
67300: LD_ADDR_VAR 0 25
67304: PUSH
67305: LD_INT 0
67307: PUSH
67308: LD_INT 0
67310: PUSH
67311: EMPTY
67312: LIST
67313: LIST
67314: PUSH
67315: LD_INT 0
67317: PUSH
67318: LD_INT 1
67320: NEG
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: LD_INT 1
67328: PUSH
67329: LD_INT 0
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: PUSH
67336: LD_INT 1
67338: PUSH
67339: LD_INT 1
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: PUSH
67346: LD_INT 0
67348: PUSH
67349: LD_INT 1
67351: PUSH
67352: EMPTY
67353: LIST
67354: LIST
67355: PUSH
67356: LD_INT 1
67358: NEG
67359: PUSH
67360: LD_INT 0
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: PUSH
67367: LD_INT 1
67369: NEG
67370: PUSH
67371: LD_INT 1
67373: NEG
67374: PUSH
67375: EMPTY
67376: LIST
67377: LIST
67378: PUSH
67379: LD_INT 1
67381: NEG
67382: PUSH
67383: LD_INT 2
67385: NEG
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: LD_INT 0
67393: PUSH
67394: LD_INT 2
67396: NEG
67397: PUSH
67398: EMPTY
67399: LIST
67400: LIST
67401: PUSH
67402: LD_INT 1
67404: PUSH
67405: LD_INT 1
67407: NEG
67408: PUSH
67409: EMPTY
67410: LIST
67411: LIST
67412: PUSH
67413: LD_INT 2
67415: PUSH
67416: LD_INT 0
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: PUSH
67423: LD_INT 2
67425: PUSH
67426: LD_INT 1
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: PUSH
67433: LD_INT 2
67435: PUSH
67436: LD_INT 2
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: LD_INT 1
67445: PUSH
67446: LD_INT 2
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PUSH
67453: LD_INT 0
67455: PUSH
67456: LD_INT 2
67458: PUSH
67459: EMPTY
67460: LIST
67461: LIST
67462: PUSH
67463: LD_INT 1
67465: NEG
67466: PUSH
67467: LD_INT 1
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 2
67476: NEG
67477: PUSH
67478: LD_INT 0
67480: PUSH
67481: EMPTY
67482: LIST
67483: LIST
67484: PUSH
67485: LD_INT 2
67487: NEG
67488: PUSH
67489: LD_INT 1
67491: NEG
67492: PUSH
67493: EMPTY
67494: LIST
67495: LIST
67496: PUSH
67497: LD_INT 2
67499: NEG
67500: PUSH
67501: LD_INT 2
67503: NEG
67504: PUSH
67505: EMPTY
67506: LIST
67507: LIST
67508: PUSH
67509: LD_INT 3
67511: PUSH
67512: LD_INT 1
67514: PUSH
67515: EMPTY
67516: LIST
67517: LIST
67518: PUSH
67519: LD_INT 3
67521: PUSH
67522: LD_INT 2
67524: PUSH
67525: EMPTY
67526: LIST
67527: LIST
67528: PUSH
67529: LD_INT 2
67531: PUSH
67532: LD_INT 3
67534: PUSH
67535: EMPTY
67536: LIST
67537: LIST
67538: PUSH
67539: LD_INT 1
67541: PUSH
67542: LD_INT 3
67544: PUSH
67545: EMPTY
67546: LIST
67547: LIST
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: LIST
67553: LIST
67554: LIST
67555: LIST
67556: LIST
67557: LIST
67558: LIST
67559: LIST
67560: LIST
67561: LIST
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: LIST
67573: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67574: LD_ADDR_VAR 0 26
67578: PUSH
67579: LD_INT 0
67581: PUSH
67582: LD_INT 0
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: LD_INT 0
67591: PUSH
67592: LD_INT 1
67594: NEG
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 1
67602: PUSH
67603: LD_INT 0
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: LD_INT 1
67612: PUSH
67613: LD_INT 1
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: PUSH
67620: LD_INT 0
67622: PUSH
67623: LD_INT 1
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 1
67632: NEG
67633: PUSH
67634: LD_INT 0
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 1
67643: NEG
67644: PUSH
67645: LD_INT 1
67647: NEG
67648: PUSH
67649: EMPTY
67650: LIST
67651: LIST
67652: PUSH
67653: LD_INT 1
67655: NEG
67656: PUSH
67657: LD_INT 2
67659: NEG
67660: PUSH
67661: EMPTY
67662: LIST
67663: LIST
67664: PUSH
67665: LD_INT 0
67667: PUSH
67668: LD_INT 2
67670: NEG
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: LD_INT 1
67678: PUSH
67679: LD_INT 1
67681: NEG
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: PUSH
67687: LD_INT 2
67689: PUSH
67690: LD_INT 0
67692: PUSH
67693: EMPTY
67694: LIST
67695: LIST
67696: PUSH
67697: LD_INT 2
67699: PUSH
67700: LD_INT 1
67702: PUSH
67703: EMPTY
67704: LIST
67705: LIST
67706: PUSH
67707: LD_INT 2
67709: PUSH
67710: LD_INT 2
67712: PUSH
67713: EMPTY
67714: LIST
67715: LIST
67716: PUSH
67717: LD_INT 1
67719: PUSH
67720: LD_INT 2
67722: PUSH
67723: EMPTY
67724: LIST
67725: LIST
67726: PUSH
67727: LD_INT 0
67729: PUSH
67730: LD_INT 2
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PUSH
67737: LD_INT 1
67739: NEG
67740: PUSH
67741: LD_INT 1
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PUSH
67748: LD_INT 2
67750: NEG
67751: PUSH
67752: LD_INT 0
67754: PUSH
67755: EMPTY
67756: LIST
67757: LIST
67758: PUSH
67759: LD_INT 2
67761: NEG
67762: PUSH
67763: LD_INT 1
67765: NEG
67766: PUSH
67767: EMPTY
67768: LIST
67769: LIST
67770: PUSH
67771: LD_INT 2
67773: NEG
67774: PUSH
67775: LD_INT 2
67777: NEG
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 2
67785: PUSH
67786: LD_INT 3
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 1
67795: PUSH
67796: LD_INT 3
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 1
67805: NEG
67806: PUSH
67807: LD_INT 2
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 2
67816: NEG
67817: PUSH
67818: LD_INT 1
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: EMPTY
67826: LIST
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67850: LD_ADDR_VAR 0 27
67854: PUSH
67855: LD_INT 0
67857: PUSH
67858: LD_INT 0
67860: PUSH
67861: EMPTY
67862: LIST
67863: LIST
67864: PUSH
67865: LD_INT 0
67867: PUSH
67868: LD_INT 1
67870: NEG
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PUSH
67876: LD_INT 1
67878: PUSH
67879: LD_INT 0
67881: PUSH
67882: EMPTY
67883: LIST
67884: LIST
67885: PUSH
67886: LD_INT 1
67888: PUSH
67889: LD_INT 1
67891: PUSH
67892: EMPTY
67893: LIST
67894: LIST
67895: PUSH
67896: LD_INT 0
67898: PUSH
67899: LD_INT 1
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 1
67908: NEG
67909: PUSH
67910: LD_INT 0
67912: PUSH
67913: EMPTY
67914: LIST
67915: LIST
67916: PUSH
67917: LD_INT 1
67919: NEG
67920: PUSH
67921: LD_INT 1
67923: NEG
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: PUSH
67929: LD_INT 1
67931: NEG
67932: PUSH
67933: LD_INT 2
67935: NEG
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: LD_INT 0
67943: PUSH
67944: LD_INT 2
67946: NEG
67947: PUSH
67948: EMPTY
67949: LIST
67950: LIST
67951: PUSH
67952: LD_INT 1
67954: PUSH
67955: LD_INT 1
67957: NEG
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PUSH
67963: LD_INT 2
67965: PUSH
67966: LD_INT 0
67968: PUSH
67969: EMPTY
67970: LIST
67971: LIST
67972: PUSH
67973: LD_INT 2
67975: PUSH
67976: LD_INT 1
67978: PUSH
67979: EMPTY
67980: LIST
67981: LIST
67982: PUSH
67983: LD_INT 2
67985: PUSH
67986: LD_INT 2
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 1
67995: PUSH
67996: LD_INT 2
67998: PUSH
67999: EMPTY
68000: LIST
68001: LIST
68002: PUSH
68003: LD_INT 0
68005: PUSH
68006: LD_INT 2
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 1
68015: NEG
68016: PUSH
68017: LD_INT 1
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: PUSH
68024: LD_INT 2
68026: NEG
68027: PUSH
68028: LD_INT 0
68030: PUSH
68031: EMPTY
68032: LIST
68033: LIST
68034: PUSH
68035: LD_INT 2
68037: NEG
68038: PUSH
68039: LD_INT 1
68041: NEG
68042: PUSH
68043: EMPTY
68044: LIST
68045: LIST
68046: PUSH
68047: LD_INT 2
68049: NEG
68050: PUSH
68051: LD_INT 2
68053: NEG
68054: PUSH
68055: EMPTY
68056: LIST
68057: LIST
68058: PUSH
68059: LD_INT 1
68061: NEG
68062: PUSH
68063: LD_INT 2
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: PUSH
68070: LD_INT 2
68072: NEG
68073: PUSH
68074: LD_INT 1
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: LD_INT 3
68083: NEG
68084: PUSH
68085: LD_INT 1
68087: NEG
68088: PUSH
68089: EMPTY
68090: LIST
68091: LIST
68092: PUSH
68093: LD_INT 3
68095: NEG
68096: PUSH
68097: LD_INT 2
68099: NEG
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PUSH
68105: EMPTY
68106: LIST
68107: LIST
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: LIST
68129: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68130: LD_ADDR_VAR 0 28
68134: PUSH
68135: LD_INT 0
68137: PUSH
68138: LD_INT 0
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 0
68147: PUSH
68148: LD_INT 1
68150: NEG
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 1
68158: PUSH
68159: LD_INT 0
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: LD_INT 1
68168: PUSH
68169: LD_INT 1
68171: PUSH
68172: EMPTY
68173: LIST
68174: LIST
68175: PUSH
68176: LD_INT 0
68178: PUSH
68179: LD_INT 1
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: PUSH
68186: LD_INT 1
68188: NEG
68189: PUSH
68190: LD_INT 0
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: PUSH
68197: LD_INT 1
68199: NEG
68200: PUSH
68201: LD_INT 1
68203: NEG
68204: PUSH
68205: EMPTY
68206: LIST
68207: LIST
68208: PUSH
68209: LD_INT 1
68211: NEG
68212: PUSH
68213: LD_INT 2
68215: NEG
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: PUSH
68221: LD_INT 0
68223: PUSH
68224: LD_INT 2
68226: NEG
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: LD_INT 1
68234: PUSH
68235: LD_INT 1
68237: NEG
68238: PUSH
68239: EMPTY
68240: LIST
68241: LIST
68242: PUSH
68243: LD_INT 2
68245: PUSH
68246: LD_INT 0
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 2
68255: PUSH
68256: LD_INT 1
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 2
68265: PUSH
68266: LD_INT 2
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: PUSH
68273: LD_INT 1
68275: PUSH
68276: LD_INT 2
68278: PUSH
68279: EMPTY
68280: LIST
68281: LIST
68282: PUSH
68283: LD_INT 0
68285: PUSH
68286: LD_INT 2
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: PUSH
68293: LD_INT 1
68295: NEG
68296: PUSH
68297: LD_INT 1
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: PUSH
68304: LD_INT 2
68306: NEG
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PUSH
68315: LD_INT 2
68317: NEG
68318: PUSH
68319: LD_INT 1
68321: NEG
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: PUSH
68327: LD_INT 2
68329: NEG
68330: PUSH
68331: LD_INT 2
68333: NEG
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 2
68341: NEG
68342: PUSH
68343: LD_INT 3
68345: NEG
68346: PUSH
68347: EMPTY
68348: LIST
68349: LIST
68350: PUSH
68351: LD_INT 1
68353: NEG
68354: PUSH
68355: LD_INT 3
68357: NEG
68358: PUSH
68359: EMPTY
68360: LIST
68361: LIST
68362: PUSH
68363: LD_INT 3
68365: NEG
68366: PUSH
68367: LD_INT 1
68369: NEG
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: PUSH
68375: LD_INT 3
68377: NEG
68378: PUSH
68379: LD_INT 2
68381: NEG
68382: PUSH
68383: EMPTY
68384: LIST
68385: LIST
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68412: LD_ADDR_VAR 0 29
68416: PUSH
68417: LD_INT 0
68419: PUSH
68420: LD_INT 0
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: PUSH
68427: LD_INT 0
68429: PUSH
68430: LD_INT 1
68432: NEG
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 1
68440: PUSH
68441: LD_INT 0
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 1
68450: PUSH
68451: LD_INT 1
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PUSH
68458: LD_INT 0
68460: PUSH
68461: LD_INT 1
68463: PUSH
68464: EMPTY
68465: LIST
68466: LIST
68467: PUSH
68468: LD_INT 1
68470: NEG
68471: PUSH
68472: LD_INT 0
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: PUSH
68479: LD_INT 1
68481: NEG
68482: PUSH
68483: LD_INT 1
68485: NEG
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: PUSH
68491: LD_INT 1
68493: NEG
68494: PUSH
68495: LD_INT 2
68497: NEG
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 0
68505: PUSH
68506: LD_INT 2
68508: NEG
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 1
68516: PUSH
68517: LD_INT 1
68519: NEG
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 2
68527: PUSH
68528: LD_INT 0
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 2
68537: PUSH
68538: LD_INT 1
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: PUSH
68545: LD_INT 1
68547: PUSH
68548: LD_INT 2
68550: PUSH
68551: EMPTY
68552: LIST
68553: LIST
68554: PUSH
68555: LD_INT 0
68557: PUSH
68558: LD_INT 2
68560: PUSH
68561: EMPTY
68562: LIST
68563: LIST
68564: PUSH
68565: LD_INT 1
68567: NEG
68568: PUSH
68569: LD_INT 1
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: LD_INT 2
68578: NEG
68579: PUSH
68580: LD_INT 1
68582: NEG
68583: PUSH
68584: EMPTY
68585: LIST
68586: LIST
68587: PUSH
68588: LD_INT 2
68590: NEG
68591: PUSH
68592: LD_INT 2
68594: NEG
68595: PUSH
68596: EMPTY
68597: LIST
68598: LIST
68599: PUSH
68600: LD_INT 2
68602: NEG
68603: PUSH
68604: LD_INT 3
68606: NEG
68607: PUSH
68608: EMPTY
68609: LIST
68610: LIST
68611: PUSH
68612: LD_INT 2
68614: PUSH
68615: LD_INT 1
68617: NEG
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: PUSH
68623: LD_INT 3
68625: PUSH
68626: LD_INT 1
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 1
68635: PUSH
68636: LD_INT 3
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: LD_INT 1
68645: NEG
68646: PUSH
68647: LD_INT 2
68649: PUSH
68650: EMPTY
68651: LIST
68652: LIST
68653: PUSH
68654: LD_INT 3
68656: NEG
68657: PUSH
68658: LD_INT 2
68660: NEG
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: EMPTY
68667: LIST
68668: LIST
68669: LIST
68670: LIST
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: LIST
68688: LIST
68689: LIST
68690: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68691: LD_ADDR_VAR 0 30
68695: PUSH
68696: LD_INT 0
68698: PUSH
68699: LD_INT 0
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: PUSH
68706: LD_INT 0
68708: PUSH
68709: LD_INT 1
68711: NEG
68712: PUSH
68713: EMPTY
68714: LIST
68715: LIST
68716: PUSH
68717: LD_INT 1
68719: PUSH
68720: LD_INT 0
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: PUSH
68727: LD_INT 1
68729: PUSH
68730: LD_INT 1
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: PUSH
68737: LD_INT 0
68739: PUSH
68740: LD_INT 1
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: LD_INT 1
68749: NEG
68750: PUSH
68751: LD_INT 0
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: LD_INT 1
68760: NEG
68761: PUSH
68762: LD_INT 1
68764: NEG
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: LD_INT 1
68772: NEG
68773: PUSH
68774: LD_INT 2
68776: NEG
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 0
68784: PUSH
68785: LD_INT 2
68787: NEG
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 1
68795: PUSH
68796: LD_INT 1
68798: NEG
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: LD_INT 2
68806: PUSH
68807: LD_INT 0
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 2
68816: PUSH
68817: LD_INT 1
68819: PUSH
68820: EMPTY
68821: LIST
68822: LIST
68823: PUSH
68824: LD_INT 2
68826: PUSH
68827: LD_INT 2
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: PUSH
68834: LD_INT 1
68836: PUSH
68837: LD_INT 2
68839: PUSH
68840: EMPTY
68841: LIST
68842: LIST
68843: PUSH
68844: LD_INT 1
68846: NEG
68847: PUSH
68848: LD_INT 1
68850: PUSH
68851: EMPTY
68852: LIST
68853: LIST
68854: PUSH
68855: LD_INT 2
68857: NEG
68858: PUSH
68859: LD_INT 0
68861: PUSH
68862: EMPTY
68863: LIST
68864: LIST
68865: PUSH
68866: LD_INT 2
68868: NEG
68869: PUSH
68870: LD_INT 1
68872: NEG
68873: PUSH
68874: EMPTY
68875: LIST
68876: LIST
68877: PUSH
68878: LD_INT 1
68880: NEG
68881: PUSH
68882: LD_INT 3
68884: NEG
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PUSH
68890: LD_INT 1
68892: PUSH
68893: LD_INT 2
68895: NEG
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 3
68903: PUSH
68904: LD_INT 2
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 2
68913: PUSH
68914: LD_INT 3
68916: PUSH
68917: EMPTY
68918: LIST
68919: LIST
68920: PUSH
68921: LD_INT 2
68923: NEG
68924: PUSH
68925: LD_INT 1
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: PUSH
68932: LD_INT 3
68934: NEG
68935: PUSH
68936: LD_INT 1
68938: NEG
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: EMPTY
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: LIST
68967: LIST
68968: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68969: LD_ADDR_VAR 0 31
68973: PUSH
68974: LD_INT 0
68976: PUSH
68977: LD_INT 0
68979: PUSH
68980: EMPTY
68981: LIST
68982: LIST
68983: PUSH
68984: LD_INT 0
68986: PUSH
68987: LD_INT 1
68989: NEG
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 1
68997: PUSH
68998: LD_INT 0
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: LD_INT 1
69007: PUSH
69008: LD_INT 1
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 0
69017: PUSH
69018: LD_INT 1
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 1
69027: NEG
69028: PUSH
69029: LD_INT 0
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: LD_INT 1
69038: NEG
69039: PUSH
69040: LD_INT 1
69042: NEG
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: PUSH
69048: LD_INT 1
69050: NEG
69051: PUSH
69052: LD_INT 2
69054: NEG
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PUSH
69060: LD_INT 1
69062: PUSH
69063: LD_INT 1
69065: NEG
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: LD_INT 2
69073: PUSH
69074: LD_INT 0
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: LD_INT 2
69083: PUSH
69084: LD_INT 1
69086: PUSH
69087: EMPTY
69088: LIST
69089: LIST
69090: PUSH
69091: LD_INT 2
69093: PUSH
69094: LD_INT 2
69096: PUSH
69097: EMPTY
69098: LIST
69099: LIST
69100: PUSH
69101: LD_INT 1
69103: PUSH
69104: LD_INT 2
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: PUSH
69111: LD_INT 0
69113: PUSH
69114: LD_INT 2
69116: PUSH
69117: EMPTY
69118: LIST
69119: LIST
69120: PUSH
69121: LD_INT 1
69123: NEG
69124: PUSH
69125: LD_INT 1
69127: PUSH
69128: EMPTY
69129: LIST
69130: LIST
69131: PUSH
69132: LD_INT 2
69134: NEG
69135: PUSH
69136: LD_INT 1
69138: NEG
69139: PUSH
69140: EMPTY
69141: LIST
69142: LIST
69143: PUSH
69144: LD_INT 2
69146: NEG
69147: PUSH
69148: LD_INT 2
69150: NEG
69151: PUSH
69152: EMPTY
69153: LIST
69154: LIST
69155: PUSH
69156: LD_INT 2
69158: NEG
69159: PUSH
69160: LD_INT 3
69162: NEG
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: PUSH
69168: LD_INT 2
69170: PUSH
69171: LD_INT 1
69173: NEG
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: PUSH
69179: LD_INT 3
69181: PUSH
69182: LD_INT 1
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: PUSH
69189: LD_INT 1
69191: PUSH
69192: LD_INT 3
69194: PUSH
69195: EMPTY
69196: LIST
69197: LIST
69198: PUSH
69199: LD_INT 1
69201: NEG
69202: PUSH
69203: LD_INT 2
69205: PUSH
69206: EMPTY
69207: LIST
69208: LIST
69209: PUSH
69210: LD_INT 3
69212: NEG
69213: PUSH
69214: LD_INT 2
69216: NEG
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: LIST
69226: LIST
69227: LIST
69228: LIST
69229: LIST
69230: LIST
69231: LIST
69232: LIST
69233: LIST
69234: LIST
69235: LIST
69236: LIST
69237: LIST
69238: LIST
69239: LIST
69240: LIST
69241: LIST
69242: LIST
69243: LIST
69244: LIST
69245: LIST
69246: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69247: LD_ADDR_VAR 0 32
69251: PUSH
69252: LD_INT 0
69254: PUSH
69255: LD_INT 0
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: PUSH
69262: LD_INT 0
69264: PUSH
69265: LD_INT 1
69267: NEG
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PUSH
69273: LD_INT 1
69275: PUSH
69276: LD_INT 0
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: LD_INT 1
69285: PUSH
69286: LD_INT 1
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: PUSH
69293: LD_INT 0
69295: PUSH
69296: LD_INT 1
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: PUSH
69303: LD_INT 1
69305: NEG
69306: PUSH
69307: LD_INT 0
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: PUSH
69314: LD_INT 1
69316: NEG
69317: PUSH
69318: LD_INT 1
69320: NEG
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: PUSH
69326: LD_INT 1
69328: NEG
69329: PUSH
69330: LD_INT 2
69332: NEG
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 0
69340: PUSH
69341: LD_INT 2
69343: NEG
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PUSH
69349: LD_INT 1
69351: PUSH
69352: LD_INT 1
69354: NEG
69355: PUSH
69356: EMPTY
69357: LIST
69358: LIST
69359: PUSH
69360: LD_INT 2
69362: PUSH
69363: LD_INT 1
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: PUSH
69370: LD_INT 2
69372: PUSH
69373: LD_INT 2
69375: PUSH
69376: EMPTY
69377: LIST
69378: LIST
69379: PUSH
69380: LD_INT 1
69382: PUSH
69383: LD_INT 2
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 0
69392: PUSH
69393: LD_INT 2
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: PUSH
69400: LD_INT 1
69402: NEG
69403: PUSH
69404: LD_INT 1
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: LD_INT 2
69413: NEG
69414: PUSH
69415: LD_INT 0
69417: PUSH
69418: EMPTY
69419: LIST
69420: LIST
69421: PUSH
69422: LD_INT 2
69424: NEG
69425: PUSH
69426: LD_INT 1
69428: NEG
69429: PUSH
69430: EMPTY
69431: LIST
69432: LIST
69433: PUSH
69434: LD_INT 1
69436: NEG
69437: PUSH
69438: LD_INT 3
69440: NEG
69441: PUSH
69442: EMPTY
69443: LIST
69444: LIST
69445: PUSH
69446: LD_INT 1
69448: PUSH
69449: LD_INT 2
69451: NEG
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PUSH
69457: LD_INT 3
69459: PUSH
69460: LD_INT 2
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 2
69469: PUSH
69470: LD_INT 3
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: PUSH
69477: LD_INT 2
69479: NEG
69480: PUSH
69481: LD_INT 1
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 3
69490: NEG
69491: PUSH
69492: LD_INT 1
69494: NEG
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: LIST
69504: LIST
69505: LIST
69506: LIST
69507: LIST
69508: LIST
69509: LIST
69510: LIST
69511: LIST
69512: LIST
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69525: LD_ADDR_VAR 0 33
69529: PUSH
69530: LD_INT 0
69532: PUSH
69533: LD_INT 0
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: PUSH
69540: LD_INT 0
69542: PUSH
69543: LD_INT 1
69545: NEG
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: LD_INT 1
69553: PUSH
69554: LD_INT 0
69556: PUSH
69557: EMPTY
69558: LIST
69559: LIST
69560: PUSH
69561: LD_INT 1
69563: PUSH
69564: LD_INT 1
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PUSH
69571: LD_INT 0
69573: PUSH
69574: LD_INT 1
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: PUSH
69581: LD_INT 1
69583: NEG
69584: PUSH
69585: LD_INT 0
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: PUSH
69592: LD_INT 1
69594: NEG
69595: PUSH
69596: LD_INT 1
69598: NEG
69599: PUSH
69600: EMPTY
69601: LIST
69602: LIST
69603: PUSH
69604: LD_INT 1
69606: NEG
69607: PUSH
69608: LD_INT 2
69610: NEG
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 1
69618: PUSH
69619: LD_INT 1
69621: NEG
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 2
69629: PUSH
69630: LD_INT 0
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 2
69639: PUSH
69640: LD_INT 1
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 1
69649: PUSH
69650: LD_INT 2
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 0
69659: PUSH
69660: LD_INT 2
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 1
69669: NEG
69670: PUSH
69671: LD_INT 1
69673: PUSH
69674: EMPTY
69675: LIST
69676: LIST
69677: PUSH
69678: LD_INT 2
69680: NEG
69681: PUSH
69682: LD_INT 0
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: PUSH
69689: LD_INT 2
69691: NEG
69692: PUSH
69693: LD_INT 1
69695: NEG
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: PUSH
69701: LD_INT 2
69703: NEG
69704: PUSH
69705: LD_INT 2
69707: NEG
69708: PUSH
69709: EMPTY
69710: LIST
69711: LIST
69712: PUSH
69713: LD_INT 2
69715: NEG
69716: PUSH
69717: LD_INT 3
69719: NEG
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: PUSH
69725: LD_INT 2
69727: PUSH
69728: LD_INT 1
69730: NEG
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 3
69738: PUSH
69739: LD_INT 1
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 1
69748: PUSH
69749: LD_INT 3
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: PUSH
69756: LD_INT 1
69758: NEG
69759: PUSH
69760: LD_INT 2
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: PUSH
69767: LD_INT 3
69769: NEG
69770: PUSH
69771: LD_INT 2
69773: NEG
69774: PUSH
69775: EMPTY
69776: LIST
69777: LIST
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: LIST
69783: LIST
69784: LIST
69785: LIST
69786: LIST
69787: LIST
69788: LIST
69789: LIST
69790: LIST
69791: LIST
69792: LIST
69793: LIST
69794: LIST
69795: LIST
69796: LIST
69797: LIST
69798: LIST
69799: LIST
69800: LIST
69801: LIST
69802: LIST
69803: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69804: LD_ADDR_VAR 0 34
69808: PUSH
69809: LD_INT 0
69811: PUSH
69812: LD_INT 0
69814: PUSH
69815: EMPTY
69816: LIST
69817: LIST
69818: PUSH
69819: LD_INT 0
69821: PUSH
69822: LD_INT 1
69824: NEG
69825: PUSH
69826: EMPTY
69827: LIST
69828: LIST
69829: PUSH
69830: LD_INT 1
69832: PUSH
69833: LD_INT 0
69835: PUSH
69836: EMPTY
69837: LIST
69838: LIST
69839: PUSH
69840: LD_INT 1
69842: PUSH
69843: LD_INT 1
69845: PUSH
69846: EMPTY
69847: LIST
69848: LIST
69849: PUSH
69850: LD_INT 0
69852: PUSH
69853: LD_INT 1
69855: PUSH
69856: EMPTY
69857: LIST
69858: LIST
69859: PUSH
69860: LD_INT 1
69862: NEG
69863: PUSH
69864: LD_INT 0
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 1
69873: NEG
69874: PUSH
69875: LD_INT 1
69877: NEG
69878: PUSH
69879: EMPTY
69880: LIST
69881: LIST
69882: PUSH
69883: LD_INT 1
69885: NEG
69886: PUSH
69887: LD_INT 2
69889: NEG
69890: PUSH
69891: EMPTY
69892: LIST
69893: LIST
69894: PUSH
69895: LD_INT 0
69897: PUSH
69898: LD_INT 2
69900: NEG
69901: PUSH
69902: EMPTY
69903: LIST
69904: LIST
69905: PUSH
69906: LD_INT 1
69908: PUSH
69909: LD_INT 1
69911: NEG
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 2
69919: PUSH
69920: LD_INT 1
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: PUSH
69927: LD_INT 2
69929: PUSH
69930: LD_INT 2
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: LD_INT 1
69939: PUSH
69940: LD_INT 2
69942: PUSH
69943: EMPTY
69944: LIST
69945: LIST
69946: PUSH
69947: LD_INT 1
69949: NEG
69950: PUSH
69951: LD_INT 1
69953: PUSH
69954: EMPTY
69955: LIST
69956: LIST
69957: PUSH
69958: LD_INT 2
69960: NEG
69961: PUSH
69962: LD_INT 0
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 2
69971: NEG
69972: PUSH
69973: LD_INT 1
69975: NEG
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 2
69983: NEG
69984: PUSH
69985: LD_INT 2
69987: NEG
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: LD_INT 1
69995: NEG
69996: PUSH
69997: LD_INT 3
69999: NEG
70000: PUSH
70001: EMPTY
70002: LIST
70003: LIST
70004: PUSH
70005: LD_INT 1
70007: PUSH
70008: LD_INT 2
70010: NEG
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: LD_INT 3
70018: PUSH
70019: LD_INT 2
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: PUSH
70026: LD_INT 2
70028: PUSH
70029: LD_INT 3
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: PUSH
70036: LD_INT 2
70038: NEG
70039: PUSH
70040: LD_INT 1
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 3
70049: NEG
70050: PUSH
70051: LD_INT 1
70053: NEG
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: PUSH
70059: EMPTY
70060: LIST
70061: LIST
70062: LIST
70063: LIST
70064: LIST
70065: LIST
70066: LIST
70067: LIST
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: LIST
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70084: LD_ADDR_VAR 0 35
70088: PUSH
70089: LD_INT 0
70091: PUSH
70092: LD_INT 0
70094: PUSH
70095: EMPTY
70096: LIST
70097: LIST
70098: PUSH
70099: LD_INT 0
70101: PUSH
70102: LD_INT 1
70104: NEG
70105: PUSH
70106: EMPTY
70107: LIST
70108: LIST
70109: PUSH
70110: LD_INT 1
70112: PUSH
70113: LD_INT 0
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: PUSH
70120: LD_INT 1
70122: PUSH
70123: LD_INT 1
70125: PUSH
70126: EMPTY
70127: LIST
70128: LIST
70129: PUSH
70130: LD_INT 0
70132: PUSH
70133: LD_INT 1
70135: PUSH
70136: EMPTY
70137: LIST
70138: LIST
70139: PUSH
70140: LD_INT 1
70142: NEG
70143: PUSH
70144: LD_INT 0
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: LD_INT 1
70153: NEG
70154: PUSH
70155: LD_INT 1
70157: NEG
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 2
70165: PUSH
70166: LD_INT 1
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PUSH
70173: LD_INT 2
70175: NEG
70176: PUSH
70177: LD_INT 1
70179: NEG
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: PUSH
70185: EMPTY
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70196: LD_ADDR_VAR 0 36
70200: PUSH
70201: LD_INT 0
70203: PUSH
70204: LD_INT 0
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 0
70213: PUSH
70214: LD_INT 1
70216: NEG
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 1
70224: PUSH
70225: LD_INT 0
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 1
70234: PUSH
70235: LD_INT 1
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: LD_INT 0
70244: PUSH
70245: LD_INT 1
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 1
70254: NEG
70255: PUSH
70256: LD_INT 0
70258: PUSH
70259: EMPTY
70260: LIST
70261: LIST
70262: PUSH
70263: LD_INT 1
70265: NEG
70266: PUSH
70267: LD_INT 1
70269: NEG
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 1
70277: NEG
70278: PUSH
70279: LD_INT 2
70281: NEG
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: LD_INT 1
70289: PUSH
70290: LD_INT 2
70292: PUSH
70293: EMPTY
70294: LIST
70295: LIST
70296: PUSH
70297: EMPTY
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70308: LD_ADDR_VAR 0 37
70312: PUSH
70313: LD_INT 0
70315: PUSH
70316: LD_INT 0
70318: PUSH
70319: EMPTY
70320: LIST
70321: LIST
70322: PUSH
70323: LD_INT 0
70325: PUSH
70326: LD_INT 1
70328: NEG
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: PUSH
70334: LD_INT 1
70336: PUSH
70337: LD_INT 0
70339: PUSH
70340: EMPTY
70341: LIST
70342: LIST
70343: PUSH
70344: LD_INT 1
70346: PUSH
70347: LD_INT 1
70349: PUSH
70350: EMPTY
70351: LIST
70352: LIST
70353: PUSH
70354: LD_INT 0
70356: PUSH
70357: LD_INT 1
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 1
70366: NEG
70367: PUSH
70368: LD_INT 0
70370: PUSH
70371: EMPTY
70372: LIST
70373: LIST
70374: PUSH
70375: LD_INT 1
70377: NEG
70378: PUSH
70379: LD_INT 1
70381: NEG
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: PUSH
70387: LD_INT 1
70389: PUSH
70390: LD_INT 1
70392: NEG
70393: PUSH
70394: EMPTY
70395: LIST
70396: LIST
70397: PUSH
70398: LD_INT 1
70400: NEG
70401: PUSH
70402: LD_INT 1
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: LIST
70413: LIST
70414: LIST
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70420: LD_ADDR_VAR 0 38
70424: PUSH
70425: LD_INT 0
70427: PUSH
70428: LD_INT 0
70430: PUSH
70431: EMPTY
70432: LIST
70433: LIST
70434: PUSH
70435: LD_INT 0
70437: PUSH
70438: LD_INT 1
70440: NEG
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PUSH
70446: LD_INT 1
70448: PUSH
70449: LD_INT 0
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PUSH
70456: LD_INT 1
70458: PUSH
70459: LD_INT 1
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 0
70468: PUSH
70469: LD_INT 1
70471: PUSH
70472: EMPTY
70473: LIST
70474: LIST
70475: PUSH
70476: LD_INT 1
70478: NEG
70479: PUSH
70480: LD_INT 0
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 1
70489: NEG
70490: PUSH
70491: LD_INT 1
70493: NEG
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: PUSH
70499: LD_INT 2
70501: PUSH
70502: LD_INT 1
70504: PUSH
70505: EMPTY
70506: LIST
70507: LIST
70508: PUSH
70509: LD_INT 2
70511: NEG
70512: PUSH
70513: LD_INT 1
70515: NEG
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: LIST
70525: LIST
70526: LIST
70527: LIST
70528: LIST
70529: LIST
70530: LIST
70531: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70532: LD_ADDR_VAR 0 39
70536: PUSH
70537: LD_INT 0
70539: PUSH
70540: LD_INT 0
70542: PUSH
70543: EMPTY
70544: LIST
70545: LIST
70546: PUSH
70547: LD_INT 0
70549: PUSH
70550: LD_INT 1
70552: NEG
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 1
70560: PUSH
70561: LD_INT 0
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: PUSH
70568: LD_INT 1
70570: PUSH
70571: LD_INT 1
70573: PUSH
70574: EMPTY
70575: LIST
70576: LIST
70577: PUSH
70578: LD_INT 0
70580: PUSH
70581: LD_INT 1
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: PUSH
70588: LD_INT 1
70590: NEG
70591: PUSH
70592: LD_INT 0
70594: PUSH
70595: EMPTY
70596: LIST
70597: LIST
70598: PUSH
70599: LD_INT 1
70601: NEG
70602: PUSH
70603: LD_INT 1
70605: NEG
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 1
70613: NEG
70614: PUSH
70615: LD_INT 2
70617: NEG
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: PUSH
70623: LD_INT 1
70625: PUSH
70626: LD_INT 2
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: EMPTY
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: LIST
70642: LIST
70643: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70644: LD_ADDR_VAR 0 40
70648: PUSH
70649: LD_INT 0
70651: PUSH
70652: LD_INT 0
70654: PUSH
70655: EMPTY
70656: LIST
70657: LIST
70658: PUSH
70659: LD_INT 0
70661: PUSH
70662: LD_INT 1
70664: NEG
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: LD_INT 1
70672: PUSH
70673: LD_INT 0
70675: PUSH
70676: EMPTY
70677: LIST
70678: LIST
70679: PUSH
70680: LD_INT 1
70682: PUSH
70683: LD_INT 1
70685: PUSH
70686: EMPTY
70687: LIST
70688: LIST
70689: PUSH
70690: LD_INT 0
70692: PUSH
70693: LD_INT 1
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 1
70702: NEG
70703: PUSH
70704: LD_INT 0
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PUSH
70711: LD_INT 1
70713: NEG
70714: PUSH
70715: LD_INT 1
70717: NEG
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: PUSH
70723: LD_INT 1
70725: PUSH
70726: LD_INT 1
70728: NEG
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 1
70736: NEG
70737: PUSH
70738: LD_INT 1
70740: PUSH
70741: EMPTY
70742: LIST
70743: LIST
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70756: LD_ADDR_VAR 0 41
70760: PUSH
70761: LD_INT 0
70763: PUSH
70764: LD_INT 0
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: PUSH
70771: LD_INT 0
70773: PUSH
70774: LD_INT 1
70776: NEG
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: PUSH
70782: LD_INT 1
70784: PUSH
70785: LD_INT 0
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: PUSH
70792: LD_INT 1
70794: PUSH
70795: LD_INT 1
70797: PUSH
70798: EMPTY
70799: LIST
70800: LIST
70801: PUSH
70802: LD_INT 0
70804: PUSH
70805: LD_INT 1
70807: PUSH
70808: EMPTY
70809: LIST
70810: LIST
70811: PUSH
70812: LD_INT 1
70814: NEG
70815: PUSH
70816: LD_INT 0
70818: PUSH
70819: EMPTY
70820: LIST
70821: LIST
70822: PUSH
70823: LD_INT 1
70825: NEG
70826: PUSH
70827: LD_INT 1
70829: NEG
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 1
70837: NEG
70838: PUSH
70839: LD_INT 2
70841: NEG
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 1
70849: PUSH
70850: LD_INT 1
70852: NEG
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 2
70860: PUSH
70861: LD_INT 0
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: LD_INT 2
70870: PUSH
70871: LD_INT 1
70873: PUSH
70874: EMPTY
70875: LIST
70876: LIST
70877: PUSH
70878: LD_INT 2
70880: PUSH
70881: LD_INT 2
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: PUSH
70888: LD_INT 1
70890: PUSH
70891: LD_INT 2
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: PUSH
70898: LD_INT 1
70900: NEG
70901: PUSH
70902: LD_INT 1
70904: PUSH
70905: EMPTY
70906: LIST
70907: LIST
70908: PUSH
70909: LD_INT 2
70911: NEG
70912: PUSH
70913: LD_INT 0
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: PUSH
70920: LD_INT 2
70922: NEG
70923: PUSH
70924: LD_INT 1
70926: NEG
70927: PUSH
70928: EMPTY
70929: LIST
70930: LIST
70931: PUSH
70932: LD_INT 2
70934: NEG
70935: PUSH
70936: LD_INT 2
70938: NEG
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: LD_INT 2
70946: NEG
70947: PUSH
70948: LD_INT 3
70950: NEG
70951: PUSH
70952: EMPTY
70953: LIST
70954: LIST
70955: PUSH
70956: LD_INT 2
70958: PUSH
70959: LD_INT 1
70961: NEG
70962: PUSH
70963: EMPTY
70964: LIST
70965: LIST
70966: PUSH
70967: LD_INT 3
70969: PUSH
70970: LD_INT 0
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 3
70979: PUSH
70980: LD_INT 1
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: LD_INT 3
70989: PUSH
70990: LD_INT 2
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: PUSH
70997: LD_INT 3
70999: PUSH
71000: LD_INT 3
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PUSH
71007: LD_INT 2
71009: PUSH
71010: LD_INT 3
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 2
71019: NEG
71020: PUSH
71021: LD_INT 1
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 3
71030: NEG
71031: PUSH
71032: LD_INT 0
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: LD_INT 3
71041: NEG
71042: PUSH
71043: LD_INT 1
71045: NEG
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 3
71053: NEG
71054: PUSH
71055: LD_INT 2
71057: NEG
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: PUSH
71063: LD_INT 3
71065: NEG
71066: PUSH
71067: LD_INT 3
71069: NEG
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: EMPTY
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: LIST
71098: LIST
71099: LIST
71100: LIST
71101: LIST
71102: LIST
71103: LIST
71104: LIST
71105: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71106: LD_ADDR_VAR 0 42
71110: PUSH
71111: LD_INT 0
71113: PUSH
71114: LD_INT 0
71116: PUSH
71117: EMPTY
71118: LIST
71119: LIST
71120: PUSH
71121: LD_INT 0
71123: PUSH
71124: LD_INT 1
71126: NEG
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: LD_INT 1
71134: PUSH
71135: LD_INT 0
71137: PUSH
71138: EMPTY
71139: LIST
71140: LIST
71141: PUSH
71142: LD_INT 1
71144: PUSH
71145: LD_INT 1
71147: PUSH
71148: EMPTY
71149: LIST
71150: LIST
71151: PUSH
71152: LD_INT 0
71154: PUSH
71155: LD_INT 1
71157: PUSH
71158: EMPTY
71159: LIST
71160: LIST
71161: PUSH
71162: LD_INT 1
71164: NEG
71165: PUSH
71166: LD_INT 0
71168: PUSH
71169: EMPTY
71170: LIST
71171: LIST
71172: PUSH
71173: LD_INT 1
71175: NEG
71176: PUSH
71177: LD_INT 1
71179: NEG
71180: PUSH
71181: EMPTY
71182: LIST
71183: LIST
71184: PUSH
71185: LD_INT 1
71187: NEG
71188: PUSH
71189: LD_INT 2
71191: NEG
71192: PUSH
71193: EMPTY
71194: LIST
71195: LIST
71196: PUSH
71197: LD_INT 0
71199: PUSH
71200: LD_INT 2
71202: NEG
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: PUSH
71208: LD_INT 1
71210: PUSH
71211: LD_INT 1
71213: NEG
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: PUSH
71219: LD_INT 2
71221: PUSH
71222: LD_INT 1
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: PUSH
71229: LD_INT 2
71231: PUSH
71232: LD_INT 2
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 1
71241: PUSH
71242: LD_INT 2
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: LD_INT 0
71251: PUSH
71252: LD_INT 2
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 1
71261: NEG
71262: PUSH
71263: LD_INT 1
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 2
71272: NEG
71273: PUSH
71274: LD_INT 1
71276: NEG
71277: PUSH
71278: EMPTY
71279: LIST
71280: LIST
71281: PUSH
71282: LD_INT 2
71284: NEG
71285: PUSH
71286: LD_INT 2
71288: NEG
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: PUSH
71294: LD_INT 2
71296: NEG
71297: PUSH
71298: LD_INT 3
71300: NEG
71301: PUSH
71302: EMPTY
71303: LIST
71304: LIST
71305: PUSH
71306: LD_INT 1
71308: NEG
71309: PUSH
71310: LD_INT 3
71312: NEG
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 0
71320: PUSH
71321: LD_INT 3
71323: NEG
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PUSH
71329: LD_INT 1
71331: PUSH
71332: LD_INT 2
71334: NEG
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PUSH
71340: LD_INT 3
71342: PUSH
71343: LD_INT 2
71345: PUSH
71346: EMPTY
71347: LIST
71348: LIST
71349: PUSH
71350: LD_INT 3
71352: PUSH
71353: LD_INT 3
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: PUSH
71360: LD_INT 2
71362: PUSH
71363: LD_INT 3
71365: PUSH
71366: EMPTY
71367: LIST
71368: LIST
71369: PUSH
71370: LD_INT 1
71372: PUSH
71373: LD_INT 3
71375: PUSH
71376: EMPTY
71377: LIST
71378: LIST
71379: PUSH
71380: LD_INT 0
71382: PUSH
71383: LD_INT 3
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PUSH
71390: LD_INT 1
71392: NEG
71393: PUSH
71394: LD_INT 2
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: PUSH
71401: LD_INT 3
71403: NEG
71404: PUSH
71405: LD_INT 2
71407: NEG
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: PUSH
71413: LD_INT 3
71415: NEG
71416: PUSH
71417: LD_INT 3
71419: NEG
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: LIST
71429: LIST
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: LIST
71444: LIST
71445: LIST
71446: LIST
71447: LIST
71448: LIST
71449: LIST
71450: LIST
71451: LIST
71452: LIST
71453: LIST
71454: LIST
71455: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71456: LD_ADDR_VAR 0 43
71460: PUSH
71461: LD_INT 0
71463: PUSH
71464: LD_INT 0
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: PUSH
71471: LD_INT 0
71473: PUSH
71474: LD_INT 1
71476: NEG
71477: PUSH
71478: EMPTY
71479: LIST
71480: LIST
71481: PUSH
71482: LD_INT 1
71484: PUSH
71485: LD_INT 0
71487: PUSH
71488: EMPTY
71489: LIST
71490: LIST
71491: PUSH
71492: LD_INT 1
71494: PUSH
71495: LD_INT 1
71497: PUSH
71498: EMPTY
71499: LIST
71500: LIST
71501: PUSH
71502: LD_INT 0
71504: PUSH
71505: LD_INT 1
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: PUSH
71512: LD_INT 1
71514: NEG
71515: PUSH
71516: LD_INT 0
71518: PUSH
71519: EMPTY
71520: LIST
71521: LIST
71522: PUSH
71523: LD_INT 1
71525: NEG
71526: PUSH
71527: LD_INT 1
71529: NEG
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 1
71537: NEG
71538: PUSH
71539: LD_INT 2
71541: NEG
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PUSH
71547: LD_INT 0
71549: PUSH
71550: LD_INT 2
71552: NEG
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: PUSH
71558: LD_INT 1
71560: PUSH
71561: LD_INT 1
71563: NEG
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: LD_INT 2
71571: PUSH
71572: LD_INT 0
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PUSH
71579: LD_INT 2
71581: PUSH
71582: LD_INT 1
71584: PUSH
71585: EMPTY
71586: LIST
71587: LIST
71588: PUSH
71589: LD_INT 1
71591: PUSH
71592: LD_INT 2
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: LD_INT 0
71601: PUSH
71602: LD_INT 2
71604: PUSH
71605: EMPTY
71606: LIST
71607: LIST
71608: PUSH
71609: LD_INT 1
71611: NEG
71612: PUSH
71613: LD_INT 1
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: PUSH
71620: LD_INT 2
71622: NEG
71623: PUSH
71624: LD_INT 0
71626: PUSH
71627: EMPTY
71628: LIST
71629: LIST
71630: PUSH
71631: LD_INT 2
71633: NEG
71634: PUSH
71635: LD_INT 1
71637: NEG
71638: PUSH
71639: EMPTY
71640: LIST
71641: LIST
71642: PUSH
71643: LD_INT 1
71645: NEG
71646: PUSH
71647: LD_INT 3
71649: NEG
71650: PUSH
71651: EMPTY
71652: LIST
71653: LIST
71654: PUSH
71655: LD_INT 0
71657: PUSH
71658: LD_INT 3
71660: NEG
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: PUSH
71666: LD_INT 1
71668: PUSH
71669: LD_INT 2
71671: NEG
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: PUSH
71677: LD_INT 2
71679: PUSH
71680: LD_INT 1
71682: NEG
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: PUSH
71688: LD_INT 3
71690: PUSH
71691: LD_INT 0
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: PUSH
71698: LD_INT 3
71700: PUSH
71701: LD_INT 1
71703: PUSH
71704: EMPTY
71705: LIST
71706: LIST
71707: PUSH
71708: LD_INT 1
71710: PUSH
71711: LD_INT 3
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: PUSH
71718: LD_INT 0
71720: PUSH
71721: LD_INT 3
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: LD_INT 1
71730: NEG
71731: PUSH
71732: LD_INT 2
71734: PUSH
71735: EMPTY
71736: LIST
71737: LIST
71738: PUSH
71739: LD_INT 2
71741: NEG
71742: PUSH
71743: LD_INT 1
71745: PUSH
71746: EMPTY
71747: LIST
71748: LIST
71749: PUSH
71750: LD_INT 3
71752: NEG
71753: PUSH
71754: LD_INT 0
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 3
71763: NEG
71764: PUSH
71765: LD_INT 1
71767: NEG
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: LIST
71792: LIST
71793: LIST
71794: LIST
71795: LIST
71796: LIST
71797: LIST
71798: LIST
71799: LIST
71800: LIST
71801: LIST
71802: LIST
71803: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71804: LD_ADDR_VAR 0 44
71808: PUSH
71809: LD_INT 0
71811: PUSH
71812: LD_INT 0
71814: PUSH
71815: EMPTY
71816: LIST
71817: LIST
71818: PUSH
71819: LD_INT 0
71821: PUSH
71822: LD_INT 1
71824: NEG
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: PUSH
71830: LD_INT 1
71832: PUSH
71833: LD_INT 0
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: PUSH
71840: LD_INT 1
71842: PUSH
71843: LD_INT 1
71845: PUSH
71846: EMPTY
71847: LIST
71848: LIST
71849: PUSH
71850: LD_INT 0
71852: PUSH
71853: LD_INT 1
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 1
71862: NEG
71863: PUSH
71864: LD_INT 0
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PUSH
71871: LD_INT 1
71873: NEG
71874: PUSH
71875: LD_INT 1
71877: NEG
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: PUSH
71883: LD_INT 1
71885: NEG
71886: PUSH
71887: LD_INT 2
71889: NEG
71890: PUSH
71891: EMPTY
71892: LIST
71893: LIST
71894: PUSH
71895: LD_INT 1
71897: PUSH
71898: LD_INT 1
71900: NEG
71901: PUSH
71902: EMPTY
71903: LIST
71904: LIST
71905: PUSH
71906: LD_INT 2
71908: PUSH
71909: LD_INT 0
71911: PUSH
71912: EMPTY
71913: LIST
71914: LIST
71915: PUSH
71916: LD_INT 2
71918: PUSH
71919: LD_INT 1
71921: PUSH
71922: EMPTY
71923: LIST
71924: LIST
71925: PUSH
71926: LD_INT 2
71928: PUSH
71929: LD_INT 2
71931: PUSH
71932: EMPTY
71933: LIST
71934: LIST
71935: PUSH
71936: LD_INT 1
71938: PUSH
71939: LD_INT 2
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: PUSH
71946: LD_INT 1
71948: NEG
71949: PUSH
71950: LD_INT 1
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: PUSH
71957: LD_INT 2
71959: NEG
71960: PUSH
71961: LD_INT 0
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PUSH
71968: LD_INT 2
71970: NEG
71971: PUSH
71972: LD_INT 1
71974: NEG
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: PUSH
71980: LD_INT 2
71982: NEG
71983: PUSH
71984: LD_INT 2
71986: NEG
71987: PUSH
71988: EMPTY
71989: LIST
71990: LIST
71991: PUSH
71992: LD_INT 2
71994: NEG
71995: PUSH
71996: LD_INT 3
71998: NEG
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: PUSH
72004: LD_INT 2
72006: PUSH
72007: LD_INT 1
72009: NEG
72010: PUSH
72011: EMPTY
72012: LIST
72013: LIST
72014: PUSH
72015: LD_INT 3
72017: PUSH
72018: LD_INT 0
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 3
72027: PUSH
72028: LD_INT 1
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 3
72037: PUSH
72038: LD_INT 2
72040: PUSH
72041: EMPTY
72042: LIST
72043: LIST
72044: PUSH
72045: LD_INT 3
72047: PUSH
72048: LD_INT 3
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: PUSH
72055: LD_INT 2
72057: PUSH
72058: LD_INT 3
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: PUSH
72065: LD_INT 2
72067: NEG
72068: PUSH
72069: LD_INT 1
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: PUSH
72076: LD_INT 3
72078: NEG
72079: PUSH
72080: LD_INT 0
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: PUSH
72087: LD_INT 3
72089: NEG
72090: PUSH
72091: LD_INT 1
72093: NEG
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: PUSH
72099: LD_INT 3
72101: NEG
72102: PUSH
72103: LD_INT 2
72105: NEG
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 3
72113: NEG
72114: PUSH
72115: LD_INT 3
72117: NEG
72118: PUSH
72119: EMPTY
72120: LIST
72121: LIST
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: LIST
72127: LIST
72128: LIST
72129: LIST
72130: LIST
72131: LIST
72132: LIST
72133: LIST
72134: LIST
72135: LIST
72136: LIST
72137: LIST
72138: LIST
72139: LIST
72140: LIST
72141: LIST
72142: LIST
72143: LIST
72144: LIST
72145: LIST
72146: LIST
72147: LIST
72148: LIST
72149: LIST
72150: LIST
72151: LIST
72152: LIST
72153: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72154: LD_ADDR_VAR 0 45
72158: PUSH
72159: LD_INT 0
72161: PUSH
72162: LD_INT 0
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 0
72171: PUSH
72172: LD_INT 1
72174: NEG
72175: PUSH
72176: EMPTY
72177: LIST
72178: LIST
72179: PUSH
72180: LD_INT 1
72182: PUSH
72183: LD_INT 0
72185: PUSH
72186: EMPTY
72187: LIST
72188: LIST
72189: PUSH
72190: LD_INT 1
72192: PUSH
72193: LD_INT 1
72195: PUSH
72196: EMPTY
72197: LIST
72198: LIST
72199: PUSH
72200: LD_INT 0
72202: PUSH
72203: LD_INT 1
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 1
72212: NEG
72213: PUSH
72214: LD_INT 0
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: PUSH
72221: LD_INT 1
72223: NEG
72224: PUSH
72225: LD_INT 1
72227: NEG
72228: PUSH
72229: EMPTY
72230: LIST
72231: LIST
72232: PUSH
72233: LD_INT 1
72235: NEG
72236: PUSH
72237: LD_INT 2
72239: NEG
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 0
72247: PUSH
72248: LD_INT 2
72250: NEG
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: PUSH
72256: LD_INT 1
72258: PUSH
72259: LD_INT 1
72261: NEG
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 2
72269: PUSH
72270: LD_INT 1
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 2
72279: PUSH
72280: LD_INT 2
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 1
72289: PUSH
72290: LD_INT 2
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 0
72299: PUSH
72300: LD_INT 2
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 1
72309: NEG
72310: PUSH
72311: LD_INT 1
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: PUSH
72318: LD_INT 2
72320: NEG
72321: PUSH
72322: LD_INT 1
72324: NEG
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: PUSH
72330: LD_INT 2
72332: NEG
72333: PUSH
72334: LD_INT 2
72336: NEG
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: PUSH
72342: LD_INT 2
72344: NEG
72345: PUSH
72346: LD_INT 3
72348: NEG
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 1
72356: NEG
72357: PUSH
72358: LD_INT 3
72360: NEG
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 0
72368: PUSH
72369: LD_INT 3
72371: NEG
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 1
72379: PUSH
72380: LD_INT 2
72382: NEG
72383: PUSH
72384: EMPTY
72385: LIST
72386: LIST
72387: PUSH
72388: LD_INT 3
72390: PUSH
72391: LD_INT 2
72393: PUSH
72394: EMPTY
72395: LIST
72396: LIST
72397: PUSH
72398: LD_INT 3
72400: PUSH
72401: LD_INT 3
72403: PUSH
72404: EMPTY
72405: LIST
72406: LIST
72407: PUSH
72408: LD_INT 2
72410: PUSH
72411: LD_INT 3
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PUSH
72418: LD_INT 1
72420: PUSH
72421: LD_INT 3
72423: PUSH
72424: EMPTY
72425: LIST
72426: LIST
72427: PUSH
72428: LD_INT 0
72430: PUSH
72431: LD_INT 3
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 1
72440: NEG
72441: PUSH
72442: LD_INT 2
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: LD_INT 3
72451: NEG
72452: PUSH
72453: LD_INT 2
72455: NEG
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 3
72463: NEG
72464: PUSH
72465: LD_INT 3
72467: NEG
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: LIST
72477: LIST
72478: LIST
72479: LIST
72480: LIST
72481: LIST
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: LIST
72488: LIST
72489: LIST
72490: LIST
72491: LIST
72492: LIST
72493: LIST
72494: LIST
72495: LIST
72496: LIST
72497: LIST
72498: LIST
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72504: LD_ADDR_VAR 0 46
72508: PUSH
72509: LD_INT 0
72511: PUSH
72512: LD_INT 0
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: LD_INT 0
72521: PUSH
72522: LD_INT 1
72524: NEG
72525: PUSH
72526: EMPTY
72527: LIST
72528: LIST
72529: PUSH
72530: LD_INT 1
72532: PUSH
72533: LD_INT 0
72535: PUSH
72536: EMPTY
72537: LIST
72538: LIST
72539: PUSH
72540: LD_INT 1
72542: PUSH
72543: LD_INT 1
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 0
72552: PUSH
72553: LD_INT 1
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 1
72562: NEG
72563: PUSH
72564: LD_INT 0
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: PUSH
72571: LD_INT 1
72573: NEG
72574: PUSH
72575: LD_INT 1
72577: NEG
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: LD_INT 1
72585: NEG
72586: PUSH
72587: LD_INT 2
72589: NEG
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 0
72597: PUSH
72598: LD_INT 2
72600: NEG
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 1
72608: PUSH
72609: LD_INT 1
72611: NEG
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: PUSH
72617: LD_INT 2
72619: PUSH
72620: LD_INT 0
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: PUSH
72627: LD_INT 2
72629: PUSH
72630: LD_INT 1
72632: PUSH
72633: EMPTY
72634: LIST
72635: LIST
72636: PUSH
72637: LD_INT 1
72639: PUSH
72640: LD_INT 2
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: PUSH
72647: LD_INT 0
72649: PUSH
72650: LD_INT 2
72652: PUSH
72653: EMPTY
72654: LIST
72655: LIST
72656: PUSH
72657: LD_INT 1
72659: NEG
72660: PUSH
72661: LD_INT 1
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: LD_INT 2
72670: NEG
72671: PUSH
72672: LD_INT 0
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PUSH
72679: LD_INT 2
72681: NEG
72682: PUSH
72683: LD_INT 1
72685: NEG
72686: PUSH
72687: EMPTY
72688: LIST
72689: LIST
72690: PUSH
72691: LD_INT 1
72693: NEG
72694: PUSH
72695: LD_INT 3
72697: NEG
72698: PUSH
72699: EMPTY
72700: LIST
72701: LIST
72702: PUSH
72703: LD_INT 0
72705: PUSH
72706: LD_INT 3
72708: NEG
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PUSH
72714: LD_INT 1
72716: PUSH
72717: LD_INT 2
72719: NEG
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 2
72727: PUSH
72728: LD_INT 1
72730: NEG
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 3
72738: PUSH
72739: LD_INT 0
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 3
72748: PUSH
72749: LD_INT 1
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: LD_INT 1
72758: PUSH
72759: LD_INT 3
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: PUSH
72766: LD_INT 0
72768: PUSH
72769: LD_INT 3
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: PUSH
72776: LD_INT 1
72778: NEG
72779: PUSH
72780: LD_INT 2
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 2
72789: NEG
72790: PUSH
72791: LD_INT 1
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: LD_INT 3
72800: NEG
72801: PUSH
72802: LD_INT 0
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: PUSH
72809: LD_INT 3
72811: NEG
72812: PUSH
72813: LD_INT 1
72815: NEG
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: LIST
72825: LIST
72826: LIST
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: LIST
72848: LIST
72849: LIST
72850: LIST
72851: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72852: LD_ADDR_VAR 0 47
72856: PUSH
72857: LD_INT 0
72859: PUSH
72860: LD_INT 0
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 0
72869: PUSH
72870: LD_INT 1
72872: NEG
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: PUSH
72878: LD_INT 1
72880: PUSH
72881: LD_INT 0
72883: PUSH
72884: EMPTY
72885: LIST
72886: LIST
72887: PUSH
72888: LD_INT 1
72890: PUSH
72891: LD_INT 1
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: PUSH
72898: LD_INT 0
72900: PUSH
72901: LD_INT 1
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 1
72910: NEG
72911: PUSH
72912: LD_INT 0
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: PUSH
72919: LD_INT 1
72921: NEG
72922: PUSH
72923: LD_INT 1
72925: NEG
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: PUSH
72931: LD_INT 1
72933: NEG
72934: PUSH
72935: LD_INT 2
72937: NEG
72938: PUSH
72939: EMPTY
72940: LIST
72941: LIST
72942: PUSH
72943: LD_INT 0
72945: PUSH
72946: LD_INT 2
72948: NEG
72949: PUSH
72950: EMPTY
72951: LIST
72952: LIST
72953: PUSH
72954: LD_INT 1
72956: PUSH
72957: LD_INT 1
72959: NEG
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 2
72967: NEG
72968: PUSH
72969: LD_INT 1
72971: NEG
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: PUSH
72977: LD_INT 2
72979: NEG
72980: PUSH
72981: LD_INT 2
72983: NEG
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: LIST
72993: LIST
72994: LIST
72995: LIST
72996: LIST
72997: LIST
72998: LIST
72999: LIST
73000: LIST
73001: LIST
73002: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73003: LD_ADDR_VAR 0 48
73007: PUSH
73008: LD_INT 0
73010: PUSH
73011: LD_INT 0
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: LD_INT 0
73020: PUSH
73021: LD_INT 1
73023: NEG
73024: PUSH
73025: EMPTY
73026: LIST
73027: LIST
73028: PUSH
73029: LD_INT 1
73031: PUSH
73032: LD_INT 0
73034: PUSH
73035: EMPTY
73036: LIST
73037: LIST
73038: PUSH
73039: LD_INT 1
73041: PUSH
73042: LD_INT 1
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PUSH
73049: LD_INT 0
73051: PUSH
73052: LD_INT 1
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 1
73061: NEG
73062: PUSH
73063: LD_INT 0
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PUSH
73070: LD_INT 1
73072: NEG
73073: PUSH
73074: LD_INT 1
73076: NEG
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: LD_INT 1
73084: NEG
73085: PUSH
73086: LD_INT 2
73088: NEG
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 0
73096: PUSH
73097: LD_INT 2
73099: NEG
73100: PUSH
73101: EMPTY
73102: LIST
73103: LIST
73104: PUSH
73105: LD_INT 1
73107: PUSH
73108: LD_INT 1
73110: NEG
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 2
73118: PUSH
73119: LD_INT 0
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PUSH
73126: LD_INT 2
73128: PUSH
73129: LD_INT 1
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: LIST
73142: LIST
73143: LIST
73144: LIST
73145: LIST
73146: LIST
73147: LIST
73148: LIST
73149: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73150: LD_ADDR_VAR 0 49
73154: PUSH
73155: LD_INT 0
73157: PUSH
73158: LD_INT 0
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 0
73167: PUSH
73168: LD_INT 1
73170: NEG
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: LD_INT 1
73178: PUSH
73179: LD_INT 0
73181: PUSH
73182: EMPTY
73183: LIST
73184: LIST
73185: PUSH
73186: LD_INT 1
73188: PUSH
73189: LD_INT 1
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: LD_INT 0
73198: PUSH
73199: LD_INT 1
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: PUSH
73206: LD_INT 1
73208: NEG
73209: PUSH
73210: LD_INT 0
73212: PUSH
73213: EMPTY
73214: LIST
73215: LIST
73216: PUSH
73217: LD_INT 1
73219: NEG
73220: PUSH
73221: LD_INT 1
73223: NEG
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: PUSH
73229: LD_INT 1
73231: PUSH
73232: LD_INT 1
73234: NEG
73235: PUSH
73236: EMPTY
73237: LIST
73238: LIST
73239: PUSH
73240: LD_INT 2
73242: PUSH
73243: LD_INT 0
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: PUSH
73250: LD_INT 2
73252: PUSH
73253: LD_INT 1
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: PUSH
73260: LD_INT 2
73262: PUSH
73263: LD_INT 2
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: PUSH
73270: LD_INT 1
73272: PUSH
73273: LD_INT 2
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: PUSH
73280: EMPTY
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73294: LD_ADDR_VAR 0 50
73298: PUSH
73299: LD_INT 0
73301: PUSH
73302: LD_INT 0
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: PUSH
73309: LD_INT 0
73311: PUSH
73312: LD_INT 1
73314: NEG
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: LD_INT 1
73322: PUSH
73323: LD_INT 0
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 1
73332: PUSH
73333: LD_INT 1
73335: PUSH
73336: EMPTY
73337: LIST
73338: LIST
73339: PUSH
73340: LD_INT 0
73342: PUSH
73343: LD_INT 1
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: PUSH
73350: LD_INT 1
73352: NEG
73353: PUSH
73354: LD_INT 0
73356: PUSH
73357: EMPTY
73358: LIST
73359: LIST
73360: PUSH
73361: LD_INT 1
73363: NEG
73364: PUSH
73365: LD_INT 1
73367: NEG
73368: PUSH
73369: EMPTY
73370: LIST
73371: LIST
73372: PUSH
73373: LD_INT 2
73375: PUSH
73376: LD_INT 1
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PUSH
73383: LD_INT 2
73385: PUSH
73386: LD_INT 2
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 1
73395: PUSH
73396: LD_INT 2
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 0
73405: PUSH
73406: LD_INT 2
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 1
73415: NEG
73416: PUSH
73417: LD_INT 1
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: LIST
73428: LIST
73429: LIST
73430: LIST
73431: LIST
73432: LIST
73433: LIST
73434: LIST
73435: LIST
73436: LIST
73437: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73438: LD_ADDR_VAR 0 51
73442: PUSH
73443: LD_INT 0
73445: PUSH
73446: LD_INT 0
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 0
73455: PUSH
73456: LD_INT 1
73458: NEG
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: PUSH
73464: LD_INT 1
73466: PUSH
73467: LD_INT 0
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 1
73476: PUSH
73477: LD_INT 1
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PUSH
73484: LD_INT 0
73486: PUSH
73487: LD_INT 1
73489: PUSH
73490: EMPTY
73491: LIST
73492: LIST
73493: PUSH
73494: LD_INT 1
73496: NEG
73497: PUSH
73498: LD_INT 0
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 1
73507: NEG
73508: PUSH
73509: LD_INT 1
73511: NEG
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 1
73519: PUSH
73520: LD_INT 2
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 0
73529: PUSH
73530: LD_INT 2
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: LD_INT 1
73539: NEG
73540: PUSH
73541: LD_INT 1
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 2
73550: NEG
73551: PUSH
73552: LD_INT 0
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: LD_INT 2
73561: NEG
73562: PUSH
73563: LD_INT 1
73565: NEG
73566: PUSH
73567: EMPTY
73568: LIST
73569: LIST
73570: PUSH
73571: EMPTY
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: LIST
73577: LIST
73578: LIST
73579: LIST
73580: LIST
73581: LIST
73582: LIST
73583: LIST
73584: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73585: LD_ADDR_VAR 0 52
73589: PUSH
73590: LD_INT 0
73592: PUSH
73593: LD_INT 0
73595: PUSH
73596: EMPTY
73597: LIST
73598: LIST
73599: PUSH
73600: LD_INT 0
73602: PUSH
73603: LD_INT 1
73605: NEG
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: PUSH
73611: LD_INT 1
73613: PUSH
73614: LD_INT 0
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: LD_INT 1
73623: PUSH
73624: LD_INT 1
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: PUSH
73631: LD_INT 0
73633: PUSH
73634: LD_INT 1
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 1
73643: NEG
73644: PUSH
73645: LD_INT 0
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 1
73654: NEG
73655: PUSH
73656: LD_INT 1
73658: NEG
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: PUSH
73664: LD_INT 1
73666: NEG
73667: PUSH
73668: LD_INT 2
73670: NEG
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: LD_INT 1
73678: NEG
73679: PUSH
73680: LD_INT 1
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: PUSH
73687: LD_INT 2
73689: NEG
73690: PUSH
73691: LD_INT 0
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: PUSH
73698: LD_INT 2
73700: NEG
73701: PUSH
73702: LD_INT 1
73704: NEG
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 2
73712: NEG
73713: PUSH
73714: LD_INT 2
73716: NEG
73717: PUSH
73718: EMPTY
73719: LIST
73720: LIST
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: LIST
73726: LIST
73727: LIST
73728: LIST
73729: LIST
73730: LIST
73731: LIST
73732: LIST
73733: LIST
73734: LIST
73735: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73736: LD_ADDR_VAR 0 53
73740: PUSH
73741: LD_INT 0
73743: PUSH
73744: LD_INT 0
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: PUSH
73751: LD_INT 0
73753: PUSH
73754: LD_INT 1
73756: NEG
73757: PUSH
73758: EMPTY
73759: LIST
73760: LIST
73761: PUSH
73762: LD_INT 1
73764: PUSH
73765: LD_INT 0
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PUSH
73772: LD_INT 1
73774: PUSH
73775: LD_INT 1
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: LD_INT 0
73784: PUSH
73785: LD_INT 1
73787: PUSH
73788: EMPTY
73789: LIST
73790: LIST
73791: PUSH
73792: LD_INT 1
73794: NEG
73795: PUSH
73796: LD_INT 0
73798: PUSH
73799: EMPTY
73800: LIST
73801: LIST
73802: PUSH
73803: LD_INT 1
73805: NEG
73806: PUSH
73807: LD_INT 1
73809: NEG
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 1
73817: NEG
73818: PUSH
73819: LD_INT 2
73821: NEG
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: LD_INT 0
73829: PUSH
73830: LD_INT 2
73832: NEG
73833: PUSH
73834: EMPTY
73835: LIST
73836: LIST
73837: PUSH
73838: LD_INT 1
73840: PUSH
73841: LD_INT 1
73843: NEG
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: LD_INT 2
73851: PUSH
73852: LD_INT 0
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 2
73861: PUSH
73862: LD_INT 1
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 2
73871: PUSH
73872: LD_INT 2
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: PUSH
73879: LD_INT 1
73881: PUSH
73882: LD_INT 2
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: LD_INT 0
73891: PUSH
73892: LD_INT 2
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 1
73901: NEG
73902: PUSH
73903: LD_INT 1
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 2
73912: NEG
73913: PUSH
73914: LD_INT 0
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 2
73923: NEG
73924: PUSH
73925: LD_INT 1
73927: NEG
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 2
73935: NEG
73936: PUSH
73937: LD_INT 2
73939: NEG
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: LIST
73949: LIST
73950: LIST
73951: LIST
73952: LIST
73953: LIST
73954: LIST
73955: LIST
73956: LIST
73957: LIST
73958: LIST
73959: LIST
73960: LIST
73961: LIST
73962: LIST
73963: LIST
73964: LIST
73965: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73966: LD_ADDR_VAR 0 54
73970: PUSH
73971: LD_INT 0
73973: PUSH
73974: LD_INT 0
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: PUSH
73981: LD_INT 0
73983: PUSH
73984: LD_INT 1
73986: NEG
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: PUSH
73992: LD_INT 1
73994: PUSH
73995: LD_INT 0
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: PUSH
74002: LD_INT 1
74004: PUSH
74005: LD_INT 1
74007: PUSH
74008: EMPTY
74009: LIST
74010: LIST
74011: PUSH
74012: LD_INT 0
74014: PUSH
74015: LD_INT 1
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: PUSH
74022: LD_INT 1
74024: NEG
74025: PUSH
74026: LD_INT 0
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: PUSH
74033: LD_INT 1
74035: NEG
74036: PUSH
74037: LD_INT 1
74039: NEG
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: PUSH
74045: LD_INT 1
74047: NEG
74048: PUSH
74049: LD_INT 2
74051: NEG
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: PUSH
74057: LD_INT 0
74059: PUSH
74060: LD_INT 2
74062: NEG
74063: PUSH
74064: EMPTY
74065: LIST
74066: LIST
74067: PUSH
74068: LD_INT 1
74070: PUSH
74071: LD_INT 1
74073: NEG
74074: PUSH
74075: EMPTY
74076: LIST
74077: LIST
74078: PUSH
74079: LD_INT 2
74081: PUSH
74082: LD_INT 0
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PUSH
74089: LD_INT 2
74091: PUSH
74092: LD_INT 1
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: LD_INT 2
74101: PUSH
74102: LD_INT 2
74104: PUSH
74105: EMPTY
74106: LIST
74107: LIST
74108: PUSH
74109: LD_INT 1
74111: PUSH
74112: LD_INT 2
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: LD_INT 0
74121: PUSH
74122: LD_INT 2
74124: PUSH
74125: EMPTY
74126: LIST
74127: LIST
74128: PUSH
74129: LD_INT 1
74131: NEG
74132: PUSH
74133: LD_INT 1
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PUSH
74140: LD_INT 2
74142: NEG
74143: PUSH
74144: LD_INT 0
74146: PUSH
74147: EMPTY
74148: LIST
74149: LIST
74150: PUSH
74151: LD_INT 2
74153: NEG
74154: PUSH
74155: LD_INT 1
74157: NEG
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: LD_INT 2
74165: NEG
74166: PUSH
74167: LD_INT 2
74169: NEG
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: LIST
74179: LIST
74180: LIST
74181: LIST
74182: LIST
74183: LIST
74184: LIST
74185: LIST
74186: LIST
74187: LIST
74188: LIST
74189: LIST
74190: LIST
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74196: LD_ADDR_VAR 0 55
74200: PUSH
74201: LD_INT 0
74203: PUSH
74204: LD_INT 0
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: LD_INT 0
74213: PUSH
74214: LD_INT 1
74216: NEG
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 1
74224: PUSH
74225: LD_INT 0
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 1
74234: PUSH
74235: LD_INT 1
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 0
74244: PUSH
74245: LD_INT 1
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 1
74254: NEG
74255: PUSH
74256: LD_INT 0
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 1
74265: NEG
74266: PUSH
74267: LD_INT 1
74269: NEG
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 1
74277: NEG
74278: PUSH
74279: LD_INT 2
74281: NEG
74282: PUSH
74283: EMPTY
74284: LIST
74285: LIST
74286: PUSH
74287: LD_INT 0
74289: PUSH
74290: LD_INT 2
74292: NEG
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PUSH
74298: LD_INT 1
74300: PUSH
74301: LD_INT 1
74303: NEG
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: LD_INT 2
74311: PUSH
74312: LD_INT 0
74314: PUSH
74315: EMPTY
74316: LIST
74317: LIST
74318: PUSH
74319: LD_INT 2
74321: PUSH
74322: LD_INT 1
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: PUSH
74329: LD_INT 2
74331: PUSH
74332: LD_INT 2
74334: PUSH
74335: EMPTY
74336: LIST
74337: LIST
74338: PUSH
74339: LD_INT 1
74341: PUSH
74342: LD_INT 2
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PUSH
74349: LD_INT 0
74351: PUSH
74352: LD_INT 2
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PUSH
74359: LD_INT 1
74361: NEG
74362: PUSH
74363: LD_INT 1
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: PUSH
74370: LD_INT 2
74372: NEG
74373: PUSH
74374: LD_INT 0
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: PUSH
74381: LD_INT 2
74383: NEG
74384: PUSH
74385: LD_INT 1
74387: NEG
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 2
74395: NEG
74396: PUSH
74397: LD_INT 2
74399: NEG
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: LIST
74409: LIST
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: LIST
74424: LIST
74425: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74426: LD_ADDR_VAR 0 56
74430: PUSH
74431: LD_INT 0
74433: PUSH
74434: LD_INT 0
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: PUSH
74441: LD_INT 0
74443: PUSH
74444: LD_INT 1
74446: NEG
74447: PUSH
74448: EMPTY
74449: LIST
74450: LIST
74451: PUSH
74452: LD_INT 1
74454: PUSH
74455: LD_INT 0
74457: PUSH
74458: EMPTY
74459: LIST
74460: LIST
74461: PUSH
74462: LD_INT 1
74464: PUSH
74465: LD_INT 1
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PUSH
74472: LD_INT 0
74474: PUSH
74475: LD_INT 1
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: PUSH
74482: LD_INT 1
74484: NEG
74485: PUSH
74486: LD_INT 0
74488: PUSH
74489: EMPTY
74490: LIST
74491: LIST
74492: PUSH
74493: LD_INT 1
74495: NEG
74496: PUSH
74497: LD_INT 1
74499: NEG
74500: PUSH
74501: EMPTY
74502: LIST
74503: LIST
74504: PUSH
74505: LD_INT 1
74507: NEG
74508: PUSH
74509: LD_INT 2
74511: NEG
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 0
74519: PUSH
74520: LD_INT 2
74522: NEG
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PUSH
74528: LD_INT 1
74530: PUSH
74531: LD_INT 1
74533: NEG
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: PUSH
74539: LD_INT 2
74541: PUSH
74542: LD_INT 0
74544: PUSH
74545: EMPTY
74546: LIST
74547: LIST
74548: PUSH
74549: LD_INT 2
74551: PUSH
74552: LD_INT 1
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PUSH
74559: LD_INT 2
74561: PUSH
74562: LD_INT 2
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: LD_INT 1
74571: PUSH
74572: LD_INT 2
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: PUSH
74579: LD_INT 0
74581: PUSH
74582: LD_INT 2
74584: PUSH
74585: EMPTY
74586: LIST
74587: LIST
74588: PUSH
74589: LD_INT 1
74591: NEG
74592: PUSH
74593: LD_INT 1
74595: PUSH
74596: EMPTY
74597: LIST
74598: LIST
74599: PUSH
74600: LD_INT 2
74602: NEG
74603: PUSH
74604: LD_INT 0
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: PUSH
74611: LD_INT 2
74613: NEG
74614: PUSH
74615: LD_INT 1
74617: NEG
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: PUSH
74623: LD_INT 2
74625: NEG
74626: PUSH
74627: LD_INT 2
74629: NEG
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: PUSH
74635: EMPTY
74636: LIST
74637: LIST
74638: LIST
74639: LIST
74640: LIST
74641: LIST
74642: LIST
74643: LIST
74644: LIST
74645: LIST
74646: LIST
74647: LIST
74648: LIST
74649: LIST
74650: LIST
74651: LIST
74652: LIST
74653: LIST
74654: LIST
74655: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74656: LD_ADDR_VAR 0 57
74660: PUSH
74661: LD_INT 0
74663: PUSH
74664: LD_INT 0
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: LD_INT 0
74673: PUSH
74674: LD_INT 1
74676: NEG
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: PUSH
74682: LD_INT 1
74684: PUSH
74685: LD_INT 0
74687: PUSH
74688: EMPTY
74689: LIST
74690: LIST
74691: PUSH
74692: LD_INT 1
74694: PUSH
74695: LD_INT 1
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: PUSH
74702: LD_INT 0
74704: PUSH
74705: LD_INT 1
74707: PUSH
74708: EMPTY
74709: LIST
74710: LIST
74711: PUSH
74712: LD_INT 1
74714: NEG
74715: PUSH
74716: LD_INT 0
74718: PUSH
74719: EMPTY
74720: LIST
74721: LIST
74722: PUSH
74723: LD_INT 1
74725: NEG
74726: PUSH
74727: LD_INT 1
74729: NEG
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: LD_INT 1
74737: NEG
74738: PUSH
74739: LD_INT 2
74741: NEG
74742: PUSH
74743: EMPTY
74744: LIST
74745: LIST
74746: PUSH
74747: LD_INT 0
74749: PUSH
74750: LD_INT 2
74752: NEG
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: PUSH
74758: LD_INT 1
74760: PUSH
74761: LD_INT 1
74763: NEG
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: LD_INT 2
74771: PUSH
74772: LD_INT 0
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: LD_INT 2
74781: PUSH
74782: LD_INT 1
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: PUSH
74789: LD_INT 2
74791: PUSH
74792: LD_INT 2
74794: PUSH
74795: EMPTY
74796: LIST
74797: LIST
74798: PUSH
74799: LD_INT 1
74801: PUSH
74802: LD_INT 2
74804: PUSH
74805: EMPTY
74806: LIST
74807: LIST
74808: PUSH
74809: LD_INT 0
74811: PUSH
74812: LD_INT 2
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: LD_INT 1
74821: NEG
74822: PUSH
74823: LD_INT 1
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: PUSH
74830: LD_INT 2
74832: NEG
74833: PUSH
74834: LD_INT 0
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: LD_INT 2
74843: NEG
74844: PUSH
74845: LD_INT 1
74847: NEG
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 2
74855: NEG
74856: PUSH
74857: LD_INT 2
74859: NEG
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: EMPTY
74866: LIST
74867: LIST
74868: LIST
74869: LIST
74870: LIST
74871: LIST
74872: LIST
74873: LIST
74874: LIST
74875: LIST
74876: LIST
74877: LIST
74878: LIST
74879: LIST
74880: LIST
74881: LIST
74882: LIST
74883: LIST
74884: LIST
74885: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74886: LD_ADDR_VAR 0 58
74890: PUSH
74891: LD_INT 0
74893: PUSH
74894: LD_INT 0
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: PUSH
74901: LD_INT 0
74903: PUSH
74904: LD_INT 1
74906: NEG
74907: PUSH
74908: EMPTY
74909: LIST
74910: LIST
74911: PUSH
74912: LD_INT 1
74914: PUSH
74915: LD_INT 0
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: PUSH
74922: LD_INT 1
74924: PUSH
74925: LD_INT 1
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: PUSH
74932: LD_INT 0
74934: PUSH
74935: LD_INT 1
74937: PUSH
74938: EMPTY
74939: LIST
74940: LIST
74941: PUSH
74942: LD_INT 1
74944: NEG
74945: PUSH
74946: LD_INT 0
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: PUSH
74953: LD_INT 1
74955: NEG
74956: PUSH
74957: LD_INT 1
74959: NEG
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PUSH
74965: LD_INT 1
74967: NEG
74968: PUSH
74969: LD_INT 2
74971: NEG
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: LD_INT 0
74979: PUSH
74980: LD_INT 2
74982: NEG
74983: PUSH
74984: EMPTY
74985: LIST
74986: LIST
74987: PUSH
74988: LD_INT 1
74990: PUSH
74991: LD_INT 1
74993: NEG
74994: PUSH
74995: EMPTY
74996: LIST
74997: LIST
74998: PUSH
74999: LD_INT 2
75001: PUSH
75002: LD_INT 0
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PUSH
75009: LD_INT 2
75011: PUSH
75012: LD_INT 1
75014: PUSH
75015: EMPTY
75016: LIST
75017: LIST
75018: PUSH
75019: LD_INT 2
75021: PUSH
75022: LD_INT 2
75024: PUSH
75025: EMPTY
75026: LIST
75027: LIST
75028: PUSH
75029: LD_INT 1
75031: PUSH
75032: LD_INT 2
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: PUSH
75039: LD_INT 0
75041: PUSH
75042: LD_INT 2
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: LD_INT 1
75051: NEG
75052: PUSH
75053: LD_INT 1
75055: PUSH
75056: EMPTY
75057: LIST
75058: LIST
75059: PUSH
75060: LD_INT 2
75062: NEG
75063: PUSH
75064: LD_INT 0
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: LD_INT 2
75073: NEG
75074: PUSH
75075: LD_INT 1
75077: NEG
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 2
75085: NEG
75086: PUSH
75087: LD_INT 2
75089: NEG
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: LIST
75099: LIST
75100: LIST
75101: LIST
75102: LIST
75103: LIST
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: LIST
75113: LIST
75114: LIST
75115: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75116: LD_ADDR_VAR 0 59
75120: PUSH
75121: LD_INT 0
75123: PUSH
75124: LD_INT 0
75126: PUSH
75127: EMPTY
75128: LIST
75129: LIST
75130: PUSH
75131: LD_INT 0
75133: PUSH
75134: LD_INT 1
75136: NEG
75137: PUSH
75138: EMPTY
75139: LIST
75140: LIST
75141: PUSH
75142: LD_INT 1
75144: PUSH
75145: LD_INT 0
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: LD_INT 1
75154: PUSH
75155: LD_INT 1
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: PUSH
75162: LD_INT 0
75164: PUSH
75165: LD_INT 1
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 1
75174: NEG
75175: PUSH
75176: LD_INT 0
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: LD_INT 1
75185: NEG
75186: PUSH
75187: LD_INT 1
75189: NEG
75190: PUSH
75191: EMPTY
75192: LIST
75193: LIST
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: LIST
75199: LIST
75200: LIST
75201: LIST
75202: LIST
75203: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75204: LD_ADDR_VAR 0 60
75208: PUSH
75209: LD_INT 0
75211: PUSH
75212: LD_INT 0
75214: PUSH
75215: EMPTY
75216: LIST
75217: LIST
75218: PUSH
75219: LD_INT 0
75221: PUSH
75222: LD_INT 1
75224: NEG
75225: PUSH
75226: EMPTY
75227: LIST
75228: LIST
75229: PUSH
75230: LD_INT 1
75232: PUSH
75233: LD_INT 0
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 1
75242: PUSH
75243: LD_INT 1
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 0
75252: PUSH
75253: LD_INT 1
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 1
75262: NEG
75263: PUSH
75264: LD_INT 0
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: PUSH
75271: LD_INT 1
75273: NEG
75274: PUSH
75275: LD_INT 1
75277: NEG
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: LIST
75287: LIST
75288: LIST
75289: LIST
75290: LIST
75291: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75292: LD_ADDR_VAR 0 61
75296: PUSH
75297: LD_INT 0
75299: PUSH
75300: LD_INT 0
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: PUSH
75307: LD_INT 0
75309: PUSH
75310: LD_INT 1
75312: NEG
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: LD_INT 1
75320: PUSH
75321: LD_INT 0
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PUSH
75328: LD_INT 1
75330: PUSH
75331: LD_INT 1
75333: PUSH
75334: EMPTY
75335: LIST
75336: LIST
75337: PUSH
75338: LD_INT 0
75340: PUSH
75341: LD_INT 1
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PUSH
75348: LD_INT 1
75350: NEG
75351: PUSH
75352: LD_INT 0
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: PUSH
75359: LD_INT 1
75361: NEG
75362: PUSH
75363: LD_INT 1
75365: NEG
75366: PUSH
75367: EMPTY
75368: LIST
75369: LIST
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: LIST
75375: LIST
75376: LIST
75377: LIST
75378: LIST
75379: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75380: LD_ADDR_VAR 0 62
75384: PUSH
75385: LD_INT 0
75387: PUSH
75388: LD_INT 0
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PUSH
75395: LD_INT 0
75397: PUSH
75398: LD_INT 1
75400: NEG
75401: PUSH
75402: EMPTY
75403: LIST
75404: LIST
75405: PUSH
75406: LD_INT 1
75408: PUSH
75409: LD_INT 0
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: PUSH
75416: LD_INT 1
75418: PUSH
75419: LD_INT 1
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 0
75428: PUSH
75429: LD_INT 1
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: PUSH
75436: LD_INT 1
75438: NEG
75439: PUSH
75440: LD_INT 0
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PUSH
75447: LD_INT 1
75449: NEG
75450: PUSH
75451: LD_INT 1
75453: NEG
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: LIST
75463: LIST
75464: LIST
75465: LIST
75466: LIST
75467: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75468: LD_ADDR_VAR 0 63
75472: PUSH
75473: LD_INT 0
75475: PUSH
75476: LD_INT 0
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 0
75485: PUSH
75486: LD_INT 1
75488: NEG
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: LD_INT 1
75496: PUSH
75497: LD_INT 0
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 1
75506: PUSH
75507: LD_INT 1
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 0
75516: PUSH
75517: LD_INT 1
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 1
75526: NEG
75527: PUSH
75528: LD_INT 0
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 1
75537: NEG
75538: PUSH
75539: LD_INT 1
75541: NEG
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: LIST
75551: LIST
75552: LIST
75553: LIST
75554: LIST
75555: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75556: LD_ADDR_VAR 0 64
75560: PUSH
75561: LD_INT 0
75563: PUSH
75564: LD_INT 0
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 0
75573: PUSH
75574: LD_INT 1
75576: NEG
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 1
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: LD_INT 1
75594: PUSH
75595: LD_INT 1
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 0
75604: PUSH
75605: LD_INT 1
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: LD_INT 1
75614: NEG
75615: PUSH
75616: LD_INT 0
75618: PUSH
75619: EMPTY
75620: LIST
75621: LIST
75622: PUSH
75623: LD_INT 1
75625: NEG
75626: PUSH
75627: LD_INT 1
75629: NEG
75630: PUSH
75631: EMPTY
75632: LIST
75633: LIST
75634: PUSH
75635: EMPTY
75636: LIST
75637: LIST
75638: LIST
75639: LIST
75640: LIST
75641: LIST
75642: LIST
75643: ST_TO_ADDR
// end ; 1 :
75644: GO 81541
75646: LD_INT 1
75648: DOUBLE
75649: EQUAL
75650: IFTRUE 75654
75652: GO 78277
75654: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75655: LD_ADDR_VAR 0 11
75659: PUSH
75660: LD_INT 1
75662: NEG
75663: PUSH
75664: LD_INT 3
75666: NEG
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: PUSH
75672: LD_INT 0
75674: PUSH
75675: LD_INT 3
75677: NEG
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: PUSH
75683: LD_INT 1
75685: PUSH
75686: LD_INT 2
75688: NEG
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: LIST
75698: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75699: LD_ADDR_VAR 0 12
75703: PUSH
75704: LD_INT 2
75706: PUSH
75707: LD_INT 1
75709: NEG
75710: PUSH
75711: EMPTY
75712: LIST
75713: LIST
75714: PUSH
75715: LD_INT 3
75717: PUSH
75718: LD_INT 0
75720: PUSH
75721: EMPTY
75722: LIST
75723: LIST
75724: PUSH
75725: LD_INT 3
75727: PUSH
75728: LD_INT 1
75730: PUSH
75731: EMPTY
75732: LIST
75733: LIST
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: LIST
75739: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75740: LD_ADDR_VAR 0 13
75744: PUSH
75745: LD_INT 3
75747: PUSH
75748: LD_INT 2
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: PUSH
75755: LD_INT 3
75757: PUSH
75758: LD_INT 3
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 2
75767: PUSH
75768: LD_INT 3
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: EMPTY
75776: LIST
75777: LIST
75778: LIST
75779: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75780: LD_ADDR_VAR 0 14
75784: PUSH
75785: LD_INT 1
75787: PUSH
75788: LD_INT 3
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 0
75797: PUSH
75798: LD_INT 3
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PUSH
75805: LD_INT 1
75807: NEG
75808: PUSH
75809: LD_INT 2
75811: PUSH
75812: EMPTY
75813: LIST
75814: LIST
75815: PUSH
75816: EMPTY
75817: LIST
75818: LIST
75819: LIST
75820: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75821: LD_ADDR_VAR 0 15
75825: PUSH
75826: LD_INT 2
75828: NEG
75829: PUSH
75830: LD_INT 1
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: PUSH
75837: LD_INT 3
75839: NEG
75840: PUSH
75841: LD_INT 0
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 3
75850: NEG
75851: PUSH
75852: LD_INT 1
75854: NEG
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: EMPTY
75861: LIST
75862: LIST
75863: LIST
75864: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75865: LD_ADDR_VAR 0 16
75869: PUSH
75870: LD_INT 2
75872: NEG
75873: PUSH
75874: LD_INT 3
75876: NEG
75877: PUSH
75878: EMPTY
75879: LIST
75880: LIST
75881: PUSH
75882: LD_INT 3
75884: NEG
75885: PUSH
75886: LD_INT 2
75888: NEG
75889: PUSH
75890: EMPTY
75891: LIST
75892: LIST
75893: PUSH
75894: LD_INT 3
75896: NEG
75897: PUSH
75898: LD_INT 3
75900: NEG
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: LIST
75910: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75911: LD_ADDR_VAR 0 17
75915: PUSH
75916: LD_INT 1
75918: NEG
75919: PUSH
75920: LD_INT 3
75922: NEG
75923: PUSH
75924: EMPTY
75925: LIST
75926: LIST
75927: PUSH
75928: LD_INT 0
75930: PUSH
75931: LD_INT 3
75933: NEG
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: PUSH
75939: LD_INT 1
75941: PUSH
75942: LD_INT 2
75944: NEG
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: LIST
75954: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75955: LD_ADDR_VAR 0 18
75959: PUSH
75960: LD_INT 2
75962: PUSH
75963: LD_INT 1
75965: NEG
75966: PUSH
75967: EMPTY
75968: LIST
75969: LIST
75970: PUSH
75971: LD_INT 3
75973: PUSH
75974: LD_INT 0
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PUSH
75981: LD_INT 3
75983: PUSH
75984: LD_INT 1
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: LIST
75995: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75996: LD_ADDR_VAR 0 19
76000: PUSH
76001: LD_INT 3
76003: PUSH
76004: LD_INT 2
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: PUSH
76011: LD_INT 3
76013: PUSH
76014: LD_INT 3
76016: PUSH
76017: EMPTY
76018: LIST
76019: LIST
76020: PUSH
76021: LD_INT 2
76023: PUSH
76024: LD_INT 3
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: LIST
76035: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76036: LD_ADDR_VAR 0 20
76040: PUSH
76041: LD_INT 1
76043: PUSH
76044: LD_INT 3
76046: PUSH
76047: EMPTY
76048: LIST
76049: LIST
76050: PUSH
76051: LD_INT 0
76053: PUSH
76054: LD_INT 3
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: PUSH
76061: LD_INT 1
76063: NEG
76064: PUSH
76065: LD_INT 2
76067: PUSH
76068: EMPTY
76069: LIST
76070: LIST
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: LIST
76076: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76077: LD_ADDR_VAR 0 21
76081: PUSH
76082: LD_INT 2
76084: NEG
76085: PUSH
76086: LD_INT 1
76088: PUSH
76089: EMPTY
76090: LIST
76091: LIST
76092: PUSH
76093: LD_INT 3
76095: NEG
76096: PUSH
76097: LD_INT 0
76099: PUSH
76100: EMPTY
76101: LIST
76102: LIST
76103: PUSH
76104: LD_INT 3
76106: NEG
76107: PUSH
76108: LD_INT 1
76110: NEG
76111: PUSH
76112: EMPTY
76113: LIST
76114: LIST
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: LIST
76120: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76121: LD_ADDR_VAR 0 22
76125: PUSH
76126: LD_INT 2
76128: NEG
76129: PUSH
76130: LD_INT 3
76132: NEG
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: PUSH
76138: LD_INT 3
76140: NEG
76141: PUSH
76142: LD_INT 2
76144: NEG
76145: PUSH
76146: EMPTY
76147: LIST
76148: LIST
76149: PUSH
76150: LD_INT 3
76152: NEG
76153: PUSH
76154: LD_INT 3
76156: NEG
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: LIST
76166: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76167: LD_ADDR_VAR 0 23
76171: PUSH
76172: LD_INT 0
76174: PUSH
76175: LD_INT 3
76177: NEG
76178: PUSH
76179: EMPTY
76180: LIST
76181: LIST
76182: PUSH
76183: LD_INT 1
76185: NEG
76186: PUSH
76187: LD_INT 4
76189: NEG
76190: PUSH
76191: EMPTY
76192: LIST
76193: LIST
76194: PUSH
76195: LD_INT 1
76197: PUSH
76198: LD_INT 3
76200: NEG
76201: PUSH
76202: EMPTY
76203: LIST
76204: LIST
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: LIST
76210: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76211: LD_ADDR_VAR 0 24
76215: PUSH
76216: LD_INT 3
76218: PUSH
76219: LD_INT 0
76221: PUSH
76222: EMPTY
76223: LIST
76224: LIST
76225: PUSH
76226: LD_INT 3
76228: PUSH
76229: LD_INT 1
76231: NEG
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 4
76239: PUSH
76240: LD_INT 1
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: LIST
76251: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76252: LD_ADDR_VAR 0 25
76256: PUSH
76257: LD_INT 3
76259: PUSH
76260: LD_INT 3
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PUSH
76267: LD_INT 4
76269: PUSH
76270: LD_INT 3
76272: PUSH
76273: EMPTY
76274: LIST
76275: LIST
76276: PUSH
76277: LD_INT 3
76279: PUSH
76280: LD_INT 4
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: LIST
76291: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
76292: LD_ADDR_VAR 0 26
76296: PUSH
76297: LD_INT 0
76299: PUSH
76300: LD_INT 3
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: PUSH
76307: LD_INT 1
76309: PUSH
76310: LD_INT 4
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PUSH
76317: LD_INT 1
76319: NEG
76320: PUSH
76321: LD_INT 3
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: LIST
76332: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
76333: LD_ADDR_VAR 0 27
76337: PUSH
76338: LD_INT 3
76340: NEG
76341: PUSH
76342: LD_INT 0
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: LD_INT 3
76351: NEG
76352: PUSH
76353: LD_INT 1
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: PUSH
76360: LD_INT 4
76362: NEG
76363: PUSH
76364: LD_INT 1
76366: NEG
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: LIST
76376: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76377: LD_ADDR_VAR 0 28
76381: PUSH
76382: LD_INT 3
76384: NEG
76385: PUSH
76386: LD_INT 3
76388: NEG
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: PUSH
76394: LD_INT 3
76396: NEG
76397: PUSH
76398: LD_INT 4
76400: NEG
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: PUSH
76406: LD_INT 4
76408: NEG
76409: PUSH
76410: LD_INT 3
76412: NEG
76413: PUSH
76414: EMPTY
76415: LIST
76416: LIST
76417: PUSH
76418: EMPTY
76419: LIST
76420: LIST
76421: LIST
76422: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76423: LD_ADDR_VAR 0 29
76427: PUSH
76428: LD_INT 1
76430: NEG
76431: PUSH
76432: LD_INT 3
76434: NEG
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: LD_INT 0
76442: PUSH
76443: LD_INT 3
76445: NEG
76446: PUSH
76447: EMPTY
76448: LIST
76449: LIST
76450: PUSH
76451: LD_INT 1
76453: PUSH
76454: LD_INT 2
76456: NEG
76457: PUSH
76458: EMPTY
76459: LIST
76460: LIST
76461: PUSH
76462: LD_INT 1
76464: NEG
76465: PUSH
76466: LD_INT 4
76468: NEG
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: PUSH
76474: LD_INT 0
76476: PUSH
76477: LD_INT 4
76479: NEG
76480: PUSH
76481: EMPTY
76482: LIST
76483: LIST
76484: PUSH
76485: LD_INT 1
76487: PUSH
76488: LD_INT 3
76490: NEG
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PUSH
76496: LD_INT 1
76498: NEG
76499: PUSH
76500: LD_INT 5
76502: NEG
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: PUSH
76508: LD_INT 0
76510: PUSH
76511: LD_INT 5
76513: NEG
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: PUSH
76519: LD_INT 1
76521: PUSH
76522: LD_INT 4
76524: NEG
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: LD_INT 1
76532: NEG
76533: PUSH
76534: LD_INT 6
76536: NEG
76537: PUSH
76538: EMPTY
76539: LIST
76540: LIST
76541: PUSH
76542: LD_INT 0
76544: PUSH
76545: LD_INT 6
76547: NEG
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: PUSH
76553: LD_INT 1
76555: PUSH
76556: LD_INT 5
76558: NEG
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: PUSH
76564: EMPTY
76565: LIST
76566: LIST
76567: LIST
76568: LIST
76569: LIST
76570: LIST
76571: LIST
76572: LIST
76573: LIST
76574: LIST
76575: LIST
76576: LIST
76577: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76578: LD_ADDR_VAR 0 30
76582: PUSH
76583: LD_INT 2
76585: PUSH
76586: LD_INT 1
76588: NEG
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PUSH
76594: LD_INT 3
76596: PUSH
76597: LD_INT 0
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: PUSH
76604: LD_INT 3
76606: PUSH
76607: LD_INT 1
76609: PUSH
76610: EMPTY
76611: LIST
76612: LIST
76613: PUSH
76614: LD_INT 3
76616: PUSH
76617: LD_INT 1
76619: NEG
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 4
76627: PUSH
76628: LD_INT 0
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 4
76637: PUSH
76638: LD_INT 1
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: LD_INT 4
76647: PUSH
76648: LD_INT 1
76650: NEG
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 5
76658: PUSH
76659: LD_INT 0
76661: PUSH
76662: EMPTY
76663: LIST
76664: LIST
76665: PUSH
76666: LD_INT 5
76668: PUSH
76669: LD_INT 1
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: LD_INT 5
76678: PUSH
76679: LD_INT 1
76681: NEG
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 6
76689: PUSH
76690: LD_INT 0
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 6
76699: PUSH
76700: LD_INT 1
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: PUSH
76707: EMPTY
76708: LIST
76709: LIST
76710: LIST
76711: LIST
76712: LIST
76713: LIST
76714: LIST
76715: LIST
76716: LIST
76717: LIST
76718: LIST
76719: LIST
76720: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76721: LD_ADDR_VAR 0 31
76725: PUSH
76726: LD_INT 3
76728: PUSH
76729: LD_INT 2
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: PUSH
76736: LD_INT 3
76738: PUSH
76739: LD_INT 3
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: PUSH
76746: LD_INT 2
76748: PUSH
76749: LD_INT 3
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PUSH
76756: LD_INT 4
76758: PUSH
76759: LD_INT 3
76761: PUSH
76762: EMPTY
76763: LIST
76764: LIST
76765: PUSH
76766: LD_INT 4
76768: PUSH
76769: LD_INT 4
76771: PUSH
76772: EMPTY
76773: LIST
76774: LIST
76775: PUSH
76776: LD_INT 3
76778: PUSH
76779: LD_INT 4
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 5
76788: PUSH
76789: LD_INT 4
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 5
76798: PUSH
76799: LD_INT 5
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: LD_INT 4
76808: PUSH
76809: LD_INT 5
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 6
76818: PUSH
76819: LD_INT 5
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 6
76828: PUSH
76829: LD_INT 6
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 5
76838: PUSH
76839: LD_INT 6
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: LIST
76850: LIST
76851: LIST
76852: LIST
76853: LIST
76854: LIST
76855: LIST
76856: LIST
76857: LIST
76858: LIST
76859: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76860: LD_ADDR_VAR 0 32
76864: PUSH
76865: LD_INT 1
76867: PUSH
76868: LD_INT 3
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PUSH
76875: LD_INT 0
76877: PUSH
76878: LD_INT 3
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: LD_INT 1
76887: NEG
76888: PUSH
76889: LD_INT 2
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 1
76898: PUSH
76899: LD_INT 4
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 0
76908: PUSH
76909: LD_INT 4
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: PUSH
76916: LD_INT 1
76918: NEG
76919: PUSH
76920: LD_INT 3
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 1
76929: PUSH
76930: LD_INT 5
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 0
76939: PUSH
76940: LD_INT 5
76942: PUSH
76943: EMPTY
76944: LIST
76945: LIST
76946: PUSH
76947: LD_INT 1
76949: NEG
76950: PUSH
76951: LD_INT 4
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: PUSH
76958: LD_INT 1
76960: PUSH
76961: LD_INT 6
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 0
76970: PUSH
76971: LD_INT 6
76973: PUSH
76974: EMPTY
76975: LIST
76976: LIST
76977: PUSH
76978: LD_INT 1
76980: NEG
76981: PUSH
76982: LD_INT 5
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: LIST
76993: LIST
76994: LIST
76995: LIST
76996: LIST
76997: LIST
76998: LIST
76999: LIST
77000: LIST
77001: LIST
77002: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
77003: LD_ADDR_VAR 0 33
77007: PUSH
77008: LD_INT 2
77010: NEG
77011: PUSH
77012: LD_INT 1
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 3
77021: NEG
77022: PUSH
77023: LD_INT 0
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 3
77032: NEG
77033: PUSH
77034: LD_INT 1
77036: NEG
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: PUSH
77042: LD_INT 3
77044: NEG
77045: PUSH
77046: LD_INT 1
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: LD_INT 4
77055: NEG
77056: PUSH
77057: LD_INT 0
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: PUSH
77064: LD_INT 4
77066: NEG
77067: PUSH
77068: LD_INT 1
77070: NEG
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: PUSH
77076: LD_INT 4
77078: NEG
77079: PUSH
77080: LD_INT 1
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PUSH
77087: LD_INT 5
77089: NEG
77090: PUSH
77091: LD_INT 0
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: PUSH
77098: LD_INT 5
77100: NEG
77101: PUSH
77102: LD_INT 1
77104: NEG
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 5
77112: NEG
77113: PUSH
77114: LD_INT 1
77116: PUSH
77117: EMPTY
77118: LIST
77119: LIST
77120: PUSH
77121: LD_INT 6
77123: NEG
77124: PUSH
77125: LD_INT 0
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: PUSH
77132: LD_INT 6
77134: NEG
77135: PUSH
77136: LD_INT 1
77138: NEG
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: LIST
77148: LIST
77149: LIST
77150: LIST
77151: LIST
77152: LIST
77153: LIST
77154: LIST
77155: LIST
77156: LIST
77157: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77158: LD_ADDR_VAR 0 34
77162: PUSH
77163: LD_INT 2
77165: NEG
77166: PUSH
77167: LD_INT 3
77169: NEG
77170: PUSH
77171: EMPTY
77172: LIST
77173: LIST
77174: PUSH
77175: LD_INT 3
77177: NEG
77178: PUSH
77179: LD_INT 2
77181: NEG
77182: PUSH
77183: EMPTY
77184: LIST
77185: LIST
77186: PUSH
77187: LD_INT 3
77189: NEG
77190: PUSH
77191: LD_INT 3
77193: NEG
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: PUSH
77199: LD_INT 3
77201: NEG
77202: PUSH
77203: LD_INT 4
77205: NEG
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PUSH
77211: LD_INT 4
77213: NEG
77214: PUSH
77215: LD_INT 3
77217: NEG
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: LD_INT 4
77225: NEG
77226: PUSH
77227: LD_INT 4
77229: NEG
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 4
77237: NEG
77238: PUSH
77239: LD_INT 5
77241: NEG
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 5
77249: NEG
77250: PUSH
77251: LD_INT 4
77253: NEG
77254: PUSH
77255: EMPTY
77256: LIST
77257: LIST
77258: PUSH
77259: LD_INT 5
77261: NEG
77262: PUSH
77263: LD_INT 5
77265: NEG
77266: PUSH
77267: EMPTY
77268: LIST
77269: LIST
77270: PUSH
77271: LD_INT 5
77273: NEG
77274: PUSH
77275: LD_INT 6
77277: NEG
77278: PUSH
77279: EMPTY
77280: LIST
77281: LIST
77282: PUSH
77283: LD_INT 6
77285: NEG
77286: PUSH
77287: LD_INT 5
77289: NEG
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 6
77297: NEG
77298: PUSH
77299: LD_INT 6
77301: NEG
77302: PUSH
77303: EMPTY
77304: LIST
77305: LIST
77306: PUSH
77307: EMPTY
77308: LIST
77309: LIST
77310: LIST
77311: LIST
77312: LIST
77313: LIST
77314: LIST
77315: LIST
77316: LIST
77317: LIST
77318: LIST
77319: LIST
77320: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
77321: LD_ADDR_VAR 0 41
77325: PUSH
77326: LD_INT 0
77328: PUSH
77329: LD_INT 2
77331: NEG
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: PUSH
77337: LD_INT 1
77339: NEG
77340: PUSH
77341: LD_INT 3
77343: NEG
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 1
77351: PUSH
77352: LD_INT 2
77354: NEG
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: LIST
77364: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77365: LD_ADDR_VAR 0 42
77369: PUSH
77370: LD_INT 2
77372: PUSH
77373: LD_INT 0
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 2
77382: PUSH
77383: LD_INT 1
77385: NEG
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: PUSH
77391: LD_INT 3
77393: PUSH
77394: LD_INT 1
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: LIST
77405: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77406: LD_ADDR_VAR 0 43
77410: PUSH
77411: LD_INT 2
77413: PUSH
77414: LD_INT 2
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 3
77423: PUSH
77424: LD_INT 2
77426: PUSH
77427: EMPTY
77428: LIST
77429: LIST
77430: PUSH
77431: LD_INT 2
77433: PUSH
77434: LD_INT 3
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: LIST
77445: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77446: LD_ADDR_VAR 0 44
77450: PUSH
77451: LD_INT 0
77453: PUSH
77454: LD_INT 2
77456: PUSH
77457: EMPTY
77458: LIST
77459: LIST
77460: PUSH
77461: LD_INT 1
77463: PUSH
77464: LD_INT 3
77466: PUSH
77467: EMPTY
77468: LIST
77469: LIST
77470: PUSH
77471: LD_INT 1
77473: NEG
77474: PUSH
77475: LD_INT 2
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: LIST
77486: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77487: LD_ADDR_VAR 0 45
77491: PUSH
77492: LD_INT 2
77494: NEG
77495: PUSH
77496: LD_INT 0
77498: PUSH
77499: EMPTY
77500: LIST
77501: LIST
77502: PUSH
77503: LD_INT 2
77505: NEG
77506: PUSH
77507: LD_INT 1
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 3
77516: NEG
77517: PUSH
77518: LD_INT 1
77520: NEG
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: PUSH
77526: EMPTY
77527: LIST
77528: LIST
77529: LIST
77530: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77531: LD_ADDR_VAR 0 46
77535: PUSH
77536: LD_INT 2
77538: NEG
77539: PUSH
77540: LD_INT 2
77542: NEG
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 2
77550: NEG
77551: PUSH
77552: LD_INT 3
77554: NEG
77555: PUSH
77556: EMPTY
77557: LIST
77558: LIST
77559: PUSH
77560: LD_INT 3
77562: NEG
77563: PUSH
77564: LD_INT 2
77566: NEG
77567: PUSH
77568: EMPTY
77569: LIST
77570: LIST
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: LIST
77576: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77577: LD_ADDR_VAR 0 47
77581: PUSH
77582: LD_INT 2
77584: NEG
77585: PUSH
77586: LD_INT 3
77588: NEG
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 1
77596: NEG
77597: PUSH
77598: LD_INT 3
77600: NEG
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77610: LD_ADDR_VAR 0 48
77614: PUSH
77615: LD_INT 1
77617: PUSH
77618: LD_INT 2
77620: NEG
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: LD_INT 2
77628: PUSH
77629: LD_INT 1
77631: NEG
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77641: LD_ADDR_VAR 0 49
77645: PUSH
77646: LD_INT 3
77648: PUSH
77649: LD_INT 1
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PUSH
77656: LD_INT 3
77658: PUSH
77659: LD_INT 2
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77670: LD_ADDR_VAR 0 50
77674: PUSH
77675: LD_INT 2
77677: PUSH
77678: LD_INT 3
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 1
77687: PUSH
77688: LD_INT 3
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77699: LD_ADDR_VAR 0 51
77703: PUSH
77704: LD_INT 1
77706: NEG
77707: PUSH
77708: LD_INT 2
77710: PUSH
77711: EMPTY
77712: LIST
77713: LIST
77714: PUSH
77715: LD_INT 2
77717: NEG
77718: PUSH
77719: LD_INT 1
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: EMPTY
77727: LIST
77728: LIST
77729: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77730: LD_ADDR_VAR 0 52
77734: PUSH
77735: LD_INT 3
77737: NEG
77738: PUSH
77739: LD_INT 1
77741: NEG
77742: PUSH
77743: EMPTY
77744: LIST
77745: LIST
77746: PUSH
77747: LD_INT 3
77749: NEG
77750: PUSH
77751: LD_INT 2
77753: NEG
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: PUSH
77759: EMPTY
77760: LIST
77761: LIST
77762: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77763: LD_ADDR_VAR 0 53
77767: PUSH
77768: LD_INT 1
77770: NEG
77771: PUSH
77772: LD_INT 3
77774: NEG
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: LD_INT 0
77782: PUSH
77783: LD_INT 3
77785: NEG
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: PUSH
77791: LD_INT 1
77793: PUSH
77794: LD_INT 2
77796: NEG
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: LIST
77806: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77807: LD_ADDR_VAR 0 54
77811: PUSH
77812: LD_INT 2
77814: PUSH
77815: LD_INT 1
77817: NEG
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 3
77825: PUSH
77826: LD_INT 0
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 3
77835: PUSH
77836: LD_INT 1
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: LIST
77847: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77848: LD_ADDR_VAR 0 55
77852: PUSH
77853: LD_INT 3
77855: PUSH
77856: LD_INT 2
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: PUSH
77863: LD_INT 3
77865: PUSH
77866: LD_INT 3
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 2
77875: PUSH
77876: LD_INT 3
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: EMPTY
77884: LIST
77885: LIST
77886: LIST
77887: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77888: LD_ADDR_VAR 0 56
77892: PUSH
77893: LD_INT 1
77895: PUSH
77896: LD_INT 3
77898: PUSH
77899: EMPTY
77900: LIST
77901: LIST
77902: PUSH
77903: LD_INT 0
77905: PUSH
77906: LD_INT 3
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: PUSH
77913: LD_INT 1
77915: NEG
77916: PUSH
77917: LD_INT 2
77919: PUSH
77920: EMPTY
77921: LIST
77922: LIST
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: LIST
77928: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77929: LD_ADDR_VAR 0 57
77933: PUSH
77934: LD_INT 2
77936: NEG
77937: PUSH
77938: LD_INT 1
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PUSH
77945: LD_INT 3
77947: NEG
77948: PUSH
77949: LD_INT 0
77951: PUSH
77952: EMPTY
77953: LIST
77954: LIST
77955: PUSH
77956: LD_INT 3
77958: NEG
77959: PUSH
77960: LD_INT 1
77962: NEG
77963: PUSH
77964: EMPTY
77965: LIST
77966: LIST
77967: PUSH
77968: EMPTY
77969: LIST
77970: LIST
77971: LIST
77972: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77973: LD_ADDR_VAR 0 58
77977: PUSH
77978: LD_INT 2
77980: NEG
77981: PUSH
77982: LD_INT 3
77984: NEG
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: LD_INT 3
77992: NEG
77993: PUSH
77994: LD_INT 2
77996: NEG
77997: PUSH
77998: EMPTY
77999: LIST
78000: LIST
78001: PUSH
78002: LD_INT 3
78004: NEG
78005: PUSH
78006: LD_INT 3
78008: NEG
78009: PUSH
78010: EMPTY
78011: LIST
78012: LIST
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: LIST
78018: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
78019: LD_ADDR_VAR 0 59
78023: PUSH
78024: LD_INT 1
78026: NEG
78027: PUSH
78028: LD_INT 2
78030: NEG
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: LD_INT 0
78038: PUSH
78039: LD_INT 2
78041: NEG
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 1
78049: PUSH
78050: LD_INT 1
78052: NEG
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: LIST
78062: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78063: LD_ADDR_VAR 0 60
78067: PUSH
78068: LD_INT 1
78070: PUSH
78071: LD_INT 1
78073: NEG
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 2
78081: PUSH
78082: LD_INT 0
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: PUSH
78089: LD_INT 2
78091: PUSH
78092: LD_INT 1
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: LIST
78103: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78104: LD_ADDR_VAR 0 61
78108: PUSH
78109: LD_INT 2
78111: PUSH
78112: LD_INT 1
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: PUSH
78119: LD_INT 2
78121: PUSH
78122: LD_INT 2
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 1
78131: PUSH
78132: LD_INT 2
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: LIST
78143: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78144: LD_ADDR_VAR 0 62
78148: PUSH
78149: LD_INT 1
78151: PUSH
78152: LD_INT 2
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: PUSH
78159: LD_INT 0
78161: PUSH
78162: LD_INT 2
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: LD_INT 1
78171: NEG
78172: PUSH
78173: LD_INT 1
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: LIST
78184: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78185: LD_ADDR_VAR 0 63
78189: PUSH
78190: LD_INT 1
78192: NEG
78193: PUSH
78194: LD_INT 1
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: LD_INT 2
78203: NEG
78204: PUSH
78205: LD_INT 0
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: LD_INT 2
78214: NEG
78215: PUSH
78216: LD_INT 1
78218: NEG
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: EMPTY
78225: LIST
78226: LIST
78227: LIST
78228: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78229: LD_ADDR_VAR 0 64
78233: PUSH
78234: LD_INT 1
78236: NEG
78237: PUSH
78238: LD_INT 2
78240: NEG
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: PUSH
78246: LD_INT 2
78248: NEG
78249: PUSH
78250: LD_INT 1
78252: NEG
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: LD_INT 2
78260: NEG
78261: PUSH
78262: LD_INT 2
78264: NEG
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: LIST
78274: ST_TO_ADDR
// end ; 2 :
78275: GO 81541
78277: LD_INT 2
78279: DOUBLE
78280: EQUAL
78281: IFTRUE 78285
78283: GO 81540
78285: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
78286: LD_ADDR_VAR 0 29
78290: PUSH
78291: LD_INT 4
78293: PUSH
78294: LD_INT 0
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 4
78303: PUSH
78304: LD_INT 1
78306: NEG
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 5
78314: PUSH
78315: LD_INT 0
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: LD_INT 5
78324: PUSH
78325: LD_INT 1
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 4
78334: PUSH
78335: LD_INT 1
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 3
78344: PUSH
78345: LD_INT 0
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 3
78354: PUSH
78355: LD_INT 1
78357: NEG
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 3
78365: PUSH
78366: LD_INT 2
78368: NEG
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 5
78376: PUSH
78377: LD_INT 2
78379: PUSH
78380: EMPTY
78381: LIST
78382: LIST
78383: PUSH
78384: LD_INT 3
78386: PUSH
78387: LD_INT 3
78389: PUSH
78390: EMPTY
78391: LIST
78392: LIST
78393: PUSH
78394: LD_INT 3
78396: PUSH
78397: LD_INT 2
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: LD_INT 4
78406: PUSH
78407: LD_INT 3
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 4
78416: PUSH
78417: LD_INT 4
78419: PUSH
78420: EMPTY
78421: LIST
78422: LIST
78423: PUSH
78424: LD_INT 3
78426: PUSH
78427: LD_INT 4
78429: PUSH
78430: EMPTY
78431: LIST
78432: LIST
78433: PUSH
78434: LD_INT 2
78436: PUSH
78437: LD_INT 3
78439: PUSH
78440: EMPTY
78441: LIST
78442: LIST
78443: PUSH
78444: LD_INT 2
78446: PUSH
78447: LD_INT 2
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: LD_INT 4
78456: PUSH
78457: LD_INT 2
78459: PUSH
78460: EMPTY
78461: LIST
78462: LIST
78463: PUSH
78464: LD_INT 2
78466: PUSH
78467: LD_INT 4
78469: PUSH
78470: EMPTY
78471: LIST
78472: LIST
78473: PUSH
78474: LD_INT 0
78476: PUSH
78477: LD_INT 4
78479: PUSH
78480: EMPTY
78481: LIST
78482: LIST
78483: PUSH
78484: LD_INT 0
78486: PUSH
78487: LD_INT 3
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 1
78496: PUSH
78497: LD_INT 4
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: PUSH
78504: LD_INT 1
78506: PUSH
78507: LD_INT 5
78509: PUSH
78510: EMPTY
78511: LIST
78512: LIST
78513: PUSH
78514: LD_INT 0
78516: PUSH
78517: LD_INT 5
78519: PUSH
78520: EMPTY
78521: LIST
78522: LIST
78523: PUSH
78524: LD_INT 1
78526: NEG
78527: PUSH
78528: LD_INT 4
78530: PUSH
78531: EMPTY
78532: LIST
78533: LIST
78534: PUSH
78535: LD_INT 1
78537: NEG
78538: PUSH
78539: LD_INT 3
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: LD_INT 2
78548: PUSH
78549: LD_INT 5
78551: PUSH
78552: EMPTY
78553: LIST
78554: LIST
78555: PUSH
78556: LD_INT 2
78558: NEG
78559: PUSH
78560: LD_INT 3
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: PUSH
78567: LD_INT 3
78569: NEG
78570: PUSH
78571: LD_INT 0
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 3
78580: NEG
78581: PUSH
78582: LD_INT 1
78584: NEG
78585: PUSH
78586: EMPTY
78587: LIST
78588: LIST
78589: PUSH
78590: LD_INT 2
78592: NEG
78593: PUSH
78594: LD_INT 0
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PUSH
78601: LD_INT 2
78603: NEG
78604: PUSH
78605: LD_INT 1
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: PUSH
78612: LD_INT 3
78614: NEG
78615: PUSH
78616: LD_INT 1
78618: PUSH
78619: EMPTY
78620: LIST
78621: LIST
78622: PUSH
78623: LD_INT 4
78625: NEG
78626: PUSH
78627: LD_INT 0
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 4
78636: NEG
78637: PUSH
78638: LD_INT 1
78640: NEG
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: PUSH
78646: LD_INT 4
78648: NEG
78649: PUSH
78650: LD_INT 2
78652: NEG
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 2
78660: NEG
78661: PUSH
78662: LD_INT 2
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 4
78671: NEG
78672: PUSH
78673: LD_INT 4
78675: NEG
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 4
78683: NEG
78684: PUSH
78685: LD_INT 5
78687: NEG
78688: PUSH
78689: EMPTY
78690: LIST
78691: LIST
78692: PUSH
78693: LD_INT 3
78695: NEG
78696: PUSH
78697: LD_INT 4
78699: NEG
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 3
78707: NEG
78708: PUSH
78709: LD_INT 3
78711: NEG
78712: PUSH
78713: EMPTY
78714: LIST
78715: LIST
78716: PUSH
78717: LD_INT 4
78719: NEG
78720: PUSH
78721: LD_INT 3
78723: NEG
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 5
78731: NEG
78732: PUSH
78733: LD_INT 4
78735: NEG
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: PUSH
78741: LD_INT 5
78743: NEG
78744: PUSH
78745: LD_INT 5
78747: NEG
78748: PUSH
78749: EMPTY
78750: LIST
78751: LIST
78752: PUSH
78753: LD_INT 3
78755: NEG
78756: PUSH
78757: LD_INT 5
78759: NEG
78760: PUSH
78761: EMPTY
78762: LIST
78763: LIST
78764: PUSH
78765: LD_INT 5
78767: NEG
78768: PUSH
78769: LD_INT 3
78771: NEG
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: EMPTY
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: LIST
78811: LIST
78812: LIST
78813: LIST
78814: LIST
78815: LIST
78816: LIST
78817: LIST
78818: LIST
78819: LIST
78820: LIST
78821: LIST
78822: LIST
78823: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78824: LD_ADDR_VAR 0 30
78828: PUSH
78829: LD_INT 4
78831: PUSH
78832: LD_INT 4
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 4
78841: PUSH
78842: LD_INT 3
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PUSH
78849: LD_INT 5
78851: PUSH
78852: LD_INT 4
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 5
78861: PUSH
78862: LD_INT 5
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 4
78871: PUSH
78872: LD_INT 5
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 3
78881: PUSH
78882: LD_INT 4
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 3
78891: PUSH
78892: LD_INT 3
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 5
78901: PUSH
78902: LD_INT 3
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: PUSH
78909: LD_INT 3
78911: PUSH
78912: LD_INT 5
78914: PUSH
78915: EMPTY
78916: LIST
78917: LIST
78918: PUSH
78919: LD_INT 0
78921: PUSH
78922: LD_INT 3
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 0
78931: PUSH
78932: LD_INT 2
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: LD_INT 1
78941: PUSH
78942: LD_INT 3
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: LD_INT 1
78951: PUSH
78952: LD_INT 4
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PUSH
78959: LD_INT 0
78961: PUSH
78962: LD_INT 4
78964: PUSH
78965: EMPTY
78966: LIST
78967: LIST
78968: PUSH
78969: LD_INT 1
78971: NEG
78972: PUSH
78973: LD_INT 3
78975: PUSH
78976: EMPTY
78977: LIST
78978: LIST
78979: PUSH
78980: LD_INT 1
78982: NEG
78983: PUSH
78984: LD_INT 2
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 2
78993: PUSH
78994: LD_INT 4
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: PUSH
79001: LD_INT 2
79003: NEG
79004: PUSH
79005: LD_INT 2
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: PUSH
79012: LD_INT 4
79014: NEG
79015: PUSH
79016: LD_INT 0
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: PUSH
79023: LD_INT 4
79025: NEG
79026: PUSH
79027: LD_INT 1
79029: NEG
79030: PUSH
79031: EMPTY
79032: LIST
79033: LIST
79034: PUSH
79035: LD_INT 3
79037: NEG
79038: PUSH
79039: LD_INT 0
79041: PUSH
79042: EMPTY
79043: LIST
79044: LIST
79045: PUSH
79046: LD_INT 3
79048: NEG
79049: PUSH
79050: LD_INT 1
79052: PUSH
79053: EMPTY
79054: LIST
79055: LIST
79056: PUSH
79057: LD_INT 4
79059: NEG
79060: PUSH
79061: LD_INT 1
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 5
79070: NEG
79071: PUSH
79072: LD_INT 0
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 5
79081: NEG
79082: PUSH
79083: LD_INT 1
79085: NEG
79086: PUSH
79087: EMPTY
79088: LIST
79089: LIST
79090: PUSH
79091: LD_INT 5
79093: NEG
79094: PUSH
79095: LD_INT 2
79097: NEG
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: PUSH
79103: LD_INT 3
79105: NEG
79106: PUSH
79107: LD_INT 2
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 3
79116: NEG
79117: PUSH
79118: LD_INT 3
79120: NEG
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 3
79128: NEG
79129: PUSH
79130: LD_INT 4
79132: NEG
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 2
79140: NEG
79141: PUSH
79142: LD_INT 3
79144: NEG
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: LD_INT 2
79152: NEG
79153: PUSH
79154: LD_INT 2
79156: NEG
79157: PUSH
79158: EMPTY
79159: LIST
79160: LIST
79161: PUSH
79162: LD_INT 3
79164: NEG
79165: PUSH
79166: LD_INT 2
79168: NEG
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: LD_INT 4
79176: NEG
79177: PUSH
79178: LD_INT 3
79180: NEG
79181: PUSH
79182: EMPTY
79183: LIST
79184: LIST
79185: PUSH
79186: LD_INT 4
79188: NEG
79189: PUSH
79190: LD_INT 4
79192: NEG
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 2
79200: NEG
79201: PUSH
79202: LD_INT 4
79204: NEG
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 4
79212: NEG
79213: PUSH
79214: LD_INT 2
79216: NEG
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PUSH
79222: LD_INT 0
79224: PUSH
79225: LD_INT 4
79227: NEG
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PUSH
79233: LD_INT 0
79235: PUSH
79236: LD_INT 5
79238: NEG
79239: PUSH
79240: EMPTY
79241: LIST
79242: LIST
79243: PUSH
79244: LD_INT 1
79246: PUSH
79247: LD_INT 4
79249: NEG
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 1
79257: PUSH
79258: LD_INT 3
79260: NEG
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 0
79268: PUSH
79269: LD_INT 3
79271: NEG
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 1
79279: NEG
79280: PUSH
79281: LD_INT 4
79283: NEG
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 1
79291: NEG
79292: PUSH
79293: LD_INT 5
79295: NEG
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: PUSH
79301: LD_INT 2
79303: PUSH
79304: LD_INT 3
79306: NEG
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: PUSH
79312: LD_INT 2
79314: NEG
79315: PUSH
79316: LD_INT 5
79318: NEG
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: EMPTY
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: LIST
79348: LIST
79349: LIST
79350: LIST
79351: LIST
79352: LIST
79353: LIST
79354: LIST
79355: LIST
79356: LIST
79357: LIST
79358: LIST
79359: LIST
79360: LIST
79361: LIST
79362: LIST
79363: LIST
79364: LIST
79365: LIST
79366: LIST
79367: LIST
79368: LIST
79369: LIST
79370: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79371: LD_ADDR_VAR 0 31
79375: PUSH
79376: LD_INT 0
79378: PUSH
79379: LD_INT 4
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 0
79388: PUSH
79389: LD_INT 3
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 1
79398: PUSH
79399: LD_INT 4
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 1
79408: PUSH
79409: LD_INT 5
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 0
79418: PUSH
79419: LD_INT 5
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 1
79428: NEG
79429: PUSH
79430: LD_INT 4
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: PUSH
79437: LD_INT 1
79439: NEG
79440: PUSH
79441: LD_INT 3
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 2
79450: PUSH
79451: LD_INT 5
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 2
79460: NEG
79461: PUSH
79462: LD_INT 3
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 3
79471: NEG
79472: PUSH
79473: LD_INT 0
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: PUSH
79480: LD_INT 3
79482: NEG
79483: PUSH
79484: LD_INT 1
79486: NEG
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PUSH
79492: LD_INT 2
79494: NEG
79495: PUSH
79496: LD_INT 0
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 2
79505: NEG
79506: PUSH
79507: LD_INT 1
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 3
79516: NEG
79517: PUSH
79518: LD_INT 1
79520: PUSH
79521: EMPTY
79522: LIST
79523: LIST
79524: PUSH
79525: LD_INT 4
79527: NEG
79528: PUSH
79529: LD_INT 0
79531: PUSH
79532: EMPTY
79533: LIST
79534: LIST
79535: PUSH
79536: LD_INT 4
79538: NEG
79539: PUSH
79540: LD_INT 1
79542: NEG
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: LD_INT 4
79550: NEG
79551: PUSH
79552: LD_INT 2
79554: NEG
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 2
79562: NEG
79563: PUSH
79564: LD_INT 2
79566: PUSH
79567: EMPTY
79568: LIST
79569: LIST
79570: PUSH
79571: LD_INT 4
79573: NEG
79574: PUSH
79575: LD_INT 4
79577: NEG
79578: PUSH
79579: EMPTY
79580: LIST
79581: LIST
79582: PUSH
79583: LD_INT 4
79585: NEG
79586: PUSH
79587: LD_INT 5
79589: NEG
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: LD_INT 3
79597: NEG
79598: PUSH
79599: LD_INT 4
79601: NEG
79602: PUSH
79603: EMPTY
79604: LIST
79605: LIST
79606: PUSH
79607: LD_INT 3
79609: NEG
79610: PUSH
79611: LD_INT 3
79613: NEG
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 4
79621: NEG
79622: PUSH
79623: LD_INT 3
79625: NEG
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: PUSH
79631: LD_INT 5
79633: NEG
79634: PUSH
79635: LD_INT 4
79637: NEG
79638: PUSH
79639: EMPTY
79640: LIST
79641: LIST
79642: PUSH
79643: LD_INT 5
79645: NEG
79646: PUSH
79647: LD_INT 5
79649: NEG
79650: PUSH
79651: EMPTY
79652: LIST
79653: LIST
79654: PUSH
79655: LD_INT 3
79657: NEG
79658: PUSH
79659: LD_INT 5
79661: NEG
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 5
79669: NEG
79670: PUSH
79671: LD_INT 3
79673: NEG
79674: PUSH
79675: EMPTY
79676: LIST
79677: LIST
79678: PUSH
79679: LD_INT 0
79681: PUSH
79682: LD_INT 3
79684: NEG
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 0
79692: PUSH
79693: LD_INT 4
79695: NEG
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 1
79703: PUSH
79704: LD_INT 3
79706: NEG
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: LD_INT 1
79714: PUSH
79715: LD_INT 2
79717: NEG
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: LD_INT 0
79725: PUSH
79726: LD_INT 2
79728: NEG
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 1
79736: NEG
79737: PUSH
79738: LD_INT 3
79740: NEG
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: LD_INT 1
79748: NEG
79749: PUSH
79750: LD_INT 4
79752: NEG
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 2
79760: PUSH
79761: LD_INT 2
79763: NEG
79764: PUSH
79765: EMPTY
79766: LIST
79767: LIST
79768: PUSH
79769: LD_INT 2
79771: NEG
79772: PUSH
79773: LD_INT 4
79775: NEG
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 4
79783: PUSH
79784: LD_INT 0
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PUSH
79791: LD_INT 4
79793: PUSH
79794: LD_INT 1
79796: NEG
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: LD_INT 5
79804: PUSH
79805: LD_INT 0
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 5
79814: PUSH
79815: LD_INT 1
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: LD_INT 4
79824: PUSH
79825: LD_INT 1
79827: PUSH
79828: EMPTY
79829: LIST
79830: LIST
79831: PUSH
79832: LD_INT 3
79834: PUSH
79835: LD_INT 0
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: LD_INT 3
79844: PUSH
79845: LD_INT 1
79847: NEG
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: PUSH
79853: LD_INT 3
79855: PUSH
79856: LD_INT 2
79858: NEG
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: LD_INT 5
79866: PUSH
79867: LD_INT 2
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: LIST
79880: LIST
79881: LIST
79882: LIST
79883: LIST
79884: LIST
79885: LIST
79886: LIST
79887: LIST
79888: LIST
79889: LIST
79890: LIST
79891: LIST
79892: LIST
79893: LIST
79894: LIST
79895: LIST
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: LIST
79902: LIST
79903: LIST
79904: LIST
79905: LIST
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: LIST
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79921: LD_ADDR_VAR 0 32
79925: PUSH
79926: LD_INT 4
79928: NEG
79929: PUSH
79930: LD_INT 0
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: PUSH
79937: LD_INT 4
79939: NEG
79940: PUSH
79941: LD_INT 1
79943: NEG
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 3
79951: NEG
79952: PUSH
79953: LD_INT 0
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: PUSH
79960: LD_INT 3
79962: NEG
79963: PUSH
79964: LD_INT 1
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: PUSH
79971: LD_INT 4
79973: NEG
79974: PUSH
79975: LD_INT 1
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: PUSH
79982: LD_INT 5
79984: NEG
79985: PUSH
79986: LD_INT 0
79988: PUSH
79989: EMPTY
79990: LIST
79991: LIST
79992: PUSH
79993: LD_INT 5
79995: NEG
79996: PUSH
79997: LD_INT 1
79999: NEG
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: LD_INT 5
80007: NEG
80008: PUSH
80009: LD_INT 2
80011: NEG
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 3
80019: NEG
80020: PUSH
80021: LD_INT 2
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: PUSH
80028: LD_INT 3
80030: NEG
80031: PUSH
80032: LD_INT 3
80034: NEG
80035: PUSH
80036: EMPTY
80037: LIST
80038: LIST
80039: PUSH
80040: LD_INT 3
80042: NEG
80043: PUSH
80044: LD_INT 4
80046: NEG
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 2
80054: NEG
80055: PUSH
80056: LD_INT 3
80058: NEG
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: LD_INT 2
80066: NEG
80067: PUSH
80068: LD_INT 2
80070: NEG
80071: PUSH
80072: EMPTY
80073: LIST
80074: LIST
80075: PUSH
80076: LD_INT 3
80078: NEG
80079: PUSH
80080: LD_INT 2
80082: NEG
80083: PUSH
80084: EMPTY
80085: LIST
80086: LIST
80087: PUSH
80088: LD_INT 4
80090: NEG
80091: PUSH
80092: LD_INT 3
80094: NEG
80095: PUSH
80096: EMPTY
80097: LIST
80098: LIST
80099: PUSH
80100: LD_INT 4
80102: NEG
80103: PUSH
80104: LD_INT 4
80106: NEG
80107: PUSH
80108: EMPTY
80109: LIST
80110: LIST
80111: PUSH
80112: LD_INT 2
80114: NEG
80115: PUSH
80116: LD_INT 4
80118: NEG
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: PUSH
80124: LD_INT 4
80126: NEG
80127: PUSH
80128: LD_INT 2
80130: NEG
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 0
80138: PUSH
80139: LD_INT 4
80141: NEG
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: LD_INT 0
80149: PUSH
80150: LD_INT 5
80152: NEG
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 1
80160: PUSH
80161: LD_INT 4
80163: NEG
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: LD_INT 1
80171: PUSH
80172: LD_INT 3
80174: NEG
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 0
80182: PUSH
80183: LD_INT 3
80185: NEG
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: LD_INT 1
80193: NEG
80194: PUSH
80195: LD_INT 4
80197: NEG
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 1
80205: NEG
80206: PUSH
80207: LD_INT 5
80209: NEG
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 2
80217: PUSH
80218: LD_INT 3
80220: NEG
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 2
80228: NEG
80229: PUSH
80230: LD_INT 5
80232: NEG
80233: PUSH
80234: EMPTY
80235: LIST
80236: LIST
80237: PUSH
80238: LD_INT 3
80240: PUSH
80241: LD_INT 0
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 3
80250: PUSH
80251: LD_INT 1
80253: NEG
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: LD_INT 4
80261: PUSH
80262: LD_INT 0
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: LD_INT 4
80271: PUSH
80272: LD_INT 1
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 3
80281: PUSH
80282: LD_INT 1
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 2
80291: PUSH
80292: LD_INT 0
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 2
80301: PUSH
80302: LD_INT 1
80304: NEG
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 2
80312: PUSH
80313: LD_INT 2
80315: NEG
80316: PUSH
80317: EMPTY
80318: LIST
80319: LIST
80320: PUSH
80321: LD_INT 4
80323: PUSH
80324: LD_INT 2
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: PUSH
80331: LD_INT 4
80333: PUSH
80334: LD_INT 4
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 4
80343: PUSH
80344: LD_INT 3
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: PUSH
80351: LD_INT 5
80353: PUSH
80354: LD_INT 4
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: PUSH
80361: LD_INT 5
80363: PUSH
80364: LD_INT 5
80366: PUSH
80367: EMPTY
80368: LIST
80369: LIST
80370: PUSH
80371: LD_INT 4
80373: PUSH
80374: LD_INT 5
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 3
80383: PUSH
80384: LD_INT 4
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 3
80393: PUSH
80394: LD_INT 3
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 5
80403: PUSH
80404: LD_INT 3
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 3
80413: PUSH
80414: LD_INT 5
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: LIST
80425: LIST
80426: LIST
80427: LIST
80428: LIST
80429: LIST
80430: LIST
80431: LIST
80432: LIST
80433: LIST
80434: LIST
80435: LIST
80436: LIST
80437: LIST
80438: LIST
80439: LIST
80440: LIST
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: LIST
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80468: LD_ADDR_VAR 0 33
80472: PUSH
80473: LD_INT 4
80475: NEG
80476: PUSH
80477: LD_INT 4
80479: NEG
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 4
80487: NEG
80488: PUSH
80489: LD_INT 5
80491: NEG
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 3
80499: NEG
80500: PUSH
80501: LD_INT 4
80503: NEG
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 3
80511: NEG
80512: PUSH
80513: LD_INT 3
80515: NEG
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: PUSH
80521: LD_INT 4
80523: NEG
80524: PUSH
80525: LD_INT 3
80527: NEG
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: PUSH
80533: LD_INT 5
80535: NEG
80536: PUSH
80537: LD_INT 4
80539: NEG
80540: PUSH
80541: EMPTY
80542: LIST
80543: LIST
80544: PUSH
80545: LD_INT 5
80547: NEG
80548: PUSH
80549: LD_INT 5
80551: NEG
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 3
80559: NEG
80560: PUSH
80561: LD_INT 5
80563: NEG
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 5
80571: NEG
80572: PUSH
80573: LD_INT 3
80575: NEG
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 0
80583: PUSH
80584: LD_INT 3
80586: NEG
80587: PUSH
80588: EMPTY
80589: LIST
80590: LIST
80591: PUSH
80592: LD_INT 0
80594: PUSH
80595: LD_INT 4
80597: NEG
80598: PUSH
80599: EMPTY
80600: LIST
80601: LIST
80602: PUSH
80603: LD_INT 1
80605: PUSH
80606: LD_INT 3
80608: NEG
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: LD_INT 1
80616: PUSH
80617: LD_INT 2
80619: NEG
80620: PUSH
80621: EMPTY
80622: LIST
80623: LIST
80624: PUSH
80625: LD_INT 0
80627: PUSH
80628: LD_INT 2
80630: NEG
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: PUSH
80636: LD_INT 1
80638: NEG
80639: PUSH
80640: LD_INT 3
80642: NEG
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 1
80650: NEG
80651: PUSH
80652: LD_INT 4
80654: NEG
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: PUSH
80660: LD_INT 2
80662: PUSH
80663: LD_INT 2
80665: NEG
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: PUSH
80671: LD_INT 2
80673: NEG
80674: PUSH
80675: LD_INT 4
80677: NEG
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 4
80685: PUSH
80686: LD_INT 0
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_INT 4
80695: PUSH
80696: LD_INT 1
80698: NEG
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 5
80706: PUSH
80707: LD_INT 0
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PUSH
80714: LD_INT 5
80716: PUSH
80717: LD_INT 1
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: LD_INT 4
80726: PUSH
80727: LD_INT 1
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: LD_INT 3
80736: PUSH
80737: LD_INT 0
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: PUSH
80744: LD_INT 3
80746: PUSH
80747: LD_INT 1
80749: NEG
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: LD_INT 3
80757: PUSH
80758: LD_INT 2
80760: NEG
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: LD_INT 5
80768: PUSH
80769: LD_INT 2
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 3
80778: PUSH
80779: LD_INT 3
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 3
80788: PUSH
80789: LD_INT 2
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 4
80798: PUSH
80799: LD_INT 3
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 4
80808: PUSH
80809: LD_INT 4
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 3
80818: PUSH
80819: LD_INT 4
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: PUSH
80826: LD_INT 2
80828: PUSH
80829: LD_INT 3
80831: PUSH
80832: EMPTY
80833: LIST
80834: LIST
80835: PUSH
80836: LD_INT 2
80838: PUSH
80839: LD_INT 2
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 4
80848: PUSH
80849: LD_INT 2
80851: PUSH
80852: EMPTY
80853: LIST
80854: LIST
80855: PUSH
80856: LD_INT 2
80858: PUSH
80859: LD_INT 4
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: PUSH
80866: LD_INT 0
80868: PUSH
80869: LD_INT 4
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 0
80878: PUSH
80879: LD_INT 3
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: LD_INT 1
80888: PUSH
80889: LD_INT 4
80891: PUSH
80892: EMPTY
80893: LIST
80894: LIST
80895: PUSH
80896: LD_INT 1
80898: PUSH
80899: LD_INT 5
80901: PUSH
80902: EMPTY
80903: LIST
80904: LIST
80905: PUSH
80906: LD_INT 0
80908: PUSH
80909: LD_INT 5
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 1
80918: NEG
80919: PUSH
80920: LD_INT 4
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 1
80929: NEG
80930: PUSH
80931: LD_INT 3
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 2
80940: PUSH
80941: LD_INT 5
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 2
80950: NEG
80951: PUSH
80952: LD_INT 3
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: LIST
80971: LIST
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: LIST
80977: LIST
80978: LIST
80979: LIST
80980: LIST
80981: LIST
80982: LIST
80983: LIST
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
81006: LD_ADDR_VAR 0 34
81010: PUSH
81011: LD_INT 0
81013: PUSH
81014: LD_INT 4
81016: NEG
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 0
81024: PUSH
81025: LD_INT 5
81027: NEG
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 1
81035: PUSH
81036: LD_INT 4
81038: NEG
81039: PUSH
81040: EMPTY
81041: LIST
81042: LIST
81043: PUSH
81044: LD_INT 1
81046: PUSH
81047: LD_INT 3
81049: NEG
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: PUSH
81055: LD_INT 0
81057: PUSH
81058: LD_INT 3
81060: NEG
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: PUSH
81066: LD_INT 1
81068: NEG
81069: PUSH
81070: LD_INT 4
81072: NEG
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 1
81080: NEG
81081: PUSH
81082: LD_INT 5
81084: NEG
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 2
81092: PUSH
81093: LD_INT 3
81095: NEG
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 2
81103: NEG
81104: PUSH
81105: LD_INT 5
81107: NEG
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 3
81115: PUSH
81116: LD_INT 0
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 3
81125: PUSH
81126: LD_INT 1
81128: NEG
81129: PUSH
81130: EMPTY
81131: LIST
81132: LIST
81133: PUSH
81134: LD_INT 4
81136: PUSH
81137: LD_INT 0
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PUSH
81144: LD_INT 4
81146: PUSH
81147: LD_INT 1
81149: PUSH
81150: EMPTY
81151: LIST
81152: LIST
81153: PUSH
81154: LD_INT 3
81156: PUSH
81157: LD_INT 1
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: PUSH
81164: LD_INT 2
81166: PUSH
81167: LD_INT 0
81169: PUSH
81170: EMPTY
81171: LIST
81172: LIST
81173: PUSH
81174: LD_INT 2
81176: PUSH
81177: LD_INT 1
81179: NEG
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 2
81187: PUSH
81188: LD_INT 2
81190: NEG
81191: PUSH
81192: EMPTY
81193: LIST
81194: LIST
81195: PUSH
81196: LD_INT 4
81198: PUSH
81199: LD_INT 2
81201: PUSH
81202: EMPTY
81203: LIST
81204: LIST
81205: PUSH
81206: LD_INT 4
81208: PUSH
81209: LD_INT 4
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: LD_INT 4
81218: PUSH
81219: LD_INT 3
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 5
81228: PUSH
81229: LD_INT 4
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: PUSH
81236: LD_INT 5
81238: PUSH
81239: LD_INT 5
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: PUSH
81246: LD_INT 4
81248: PUSH
81249: LD_INT 5
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 3
81258: PUSH
81259: LD_INT 4
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 3
81268: PUSH
81269: LD_INT 3
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: LD_INT 5
81278: PUSH
81279: LD_INT 3
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 3
81288: PUSH
81289: LD_INT 5
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 0
81298: PUSH
81299: LD_INT 3
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 0
81308: PUSH
81309: LD_INT 2
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 1
81318: PUSH
81319: LD_INT 3
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 1
81328: PUSH
81329: LD_INT 4
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 0
81338: PUSH
81339: LD_INT 4
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: PUSH
81346: LD_INT 1
81348: NEG
81349: PUSH
81350: LD_INT 3
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 1
81359: NEG
81360: PUSH
81361: LD_INT 2
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: LD_INT 2
81370: PUSH
81371: LD_INT 4
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 2
81380: NEG
81381: PUSH
81382: LD_INT 2
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: PUSH
81389: LD_INT 4
81391: NEG
81392: PUSH
81393: LD_INT 0
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: PUSH
81400: LD_INT 4
81402: NEG
81403: PUSH
81404: LD_INT 1
81406: NEG
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: LD_INT 3
81414: NEG
81415: PUSH
81416: LD_INT 0
81418: PUSH
81419: EMPTY
81420: LIST
81421: LIST
81422: PUSH
81423: LD_INT 3
81425: NEG
81426: PUSH
81427: LD_INT 1
81429: PUSH
81430: EMPTY
81431: LIST
81432: LIST
81433: PUSH
81434: LD_INT 4
81436: NEG
81437: PUSH
81438: LD_INT 1
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: PUSH
81445: LD_INT 5
81447: NEG
81448: PUSH
81449: LD_INT 0
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: PUSH
81456: LD_INT 5
81458: NEG
81459: PUSH
81460: LD_INT 1
81462: NEG
81463: PUSH
81464: EMPTY
81465: LIST
81466: LIST
81467: PUSH
81468: LD_INT 5
81470: NEG
81471: PUSH
81472: LD_INT 2
81474: NEG
81475: PUSH
81476: EMPTY
81477: LIST
81478: LIST
81479: PUSH
81480: LD_INT 3
81482: NEG
81483: PUSH
81484: LD_INT 2
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: EMPTY
81492: LIST
81493: LIST
81494: LIST
81495: LIST
81496: LIST
81497: LIST
81498: LIST
81499: LIST
81500: LIST
81501: LIST
81502: LIST
81503: LIST
81504: LIST
81505: LIST
81506: LIST
81507: LIST
81508: LIST
81509: LIST
81510: LIST
81511: LIST
81512: LIST
81513: LIST
81514: LIST
81515: LIST
81516: LIST
81517: LIST
81518: LIST
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: LIST
81528: LIST
81529: LIST
81530: LIST
81531: LIST
81532: LIST
81533: LIST
81534: LIST
81535: LIST
81536: LIST
81537: ST_TO_ADDR
// end ; end ;
81538: GO 81541
81540: POP
// case btype of b_depot , b_warehouse :
81541: LD_VAR 0 1
81545: PUSH
81546: LD_INT 0
81548: DOUBLE
81549: EQUAL
81550: IFTRUE 81560
81552: LD_INT 1
81554: DOUBLE
81555: EQUAL
81556: IFTRUE 81560
81558: GO 81761
81560: POP
// case nation of nation_american :
81561: LD_VAR 0 5
81565: PUSH
81566: LD_INT 1
81568: DOUBLE
81569: EQUAL
81570: IFTRUE 81574
81572: GO 81630
81574: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
81575: LD_ADDR_VAR 0 9
81579: PUSH
81580: LD_VAR 0 11
81584: PUSH
81585: LD_VAR 0 12
81589: PUSH
81590: LD_VAR 0 13
81594: PUSH
81595: LD_VAR 0 14
81599: PUSH
81600: LD_VAR 0 15
81604: PUSH
81605: LD_VAR 0 16
81609: PUSH
81610: EMPTY
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: PUSH
81618: LD_VAR 0 4
81622: PUSH
81623: LD_INT 1
81625: PLUS
81626: ARRAY
81627: ST_TO_ADDR
81628: GO 81759
81630: LD_INT 2
81632: DOUBLE
81633: EQUAL
81634: IFTRUE 81638
81636: GO 81694
81638: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
81639: LD_ADDR_VAR 0 9
81643: PUSH
81644: LD_VAR 0 17
81648: PUSH
81649: LD_VAR 0 18
81653: PUSH
81654: LD_VAR 0 19
81658: PUSH
81659: LD_VAR 0 20
81663: PUSH
81664: LD_VAR 0 21
81668: PUSH
81669: LD_VAR 0 22
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: PUSH
81682: LD_VAR 0 4
81686: PUSH
81687: LD_INT 1
81689: PLUS
81690: ARRAY
81691: ST_TO_ADDR
81692: GO 81759
81694: LD_INT 3
81696: DOUBLE
81697: EQUAL
81698: IFTRUE 81702
81700: GO 81758
81702: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81703: LD_ADDR_VAR 0 9
81707: PUSH
81708: LD_VAR 0 23
81712: PUSH
81713: LD_VAR 0 24
81717: PUSH
81718: LD_VAR 0 25
81722: PUSH
81723: LD_VAR 0 26
81727: PUSH
81728: LD_VAR 0 27
81732: PUSH
81733: LD_VAR 0 28
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: PUSH
81746: LD_VAR 0 4
81750: PUSH
81751: LD_INT 1
81753: PLUS
81754: ARRAY
81755: ST_TO_ADDR
81756: GO 81759
81758: POP
81759: GO 82314
81761: LD_INT 2
81763: DOUBLE
81764: EQUAL
81765: IFTRUE 81775
81767: LD_INT 3
81769: DOUBLE
81770: EQUAL
81771: IFTRUE 81775
81773: GO 81831
81775: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81776: LD_ADDR_VAR 0 9
81780: PUSH
81781: LD_VAR 0 29
81785: PUSH
81786: LD_VAR 0 30
81790: PUSH
81791: LD_VAR 0 31
81795: PUSH
81796: LD_VAR 0 32
81800: PUSH
81801: LD_VAR 0 33
81805: PUSH
81806: LD_VAR 0 34
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: PUSH
81819: LD_VAR 0 4
81823: PUSH
81824: LD_INT 1
81826: PLUS
81827: ARRAY
81828: ST_TO_ADDR
81829: GO 82314
81831: LD_INT 16
81833: DOUBLE
81834: EQUAL
81835: IFTRUE 81893
81837: LD_INT 17
81839: DOUBLE
81840: EQUAL
81841: IFTRUE 81893
81843: LD_INT 18
81845: DOUBLE
81846: EQUAL
81847: IFTRUE 81893
81849: LD_INT 19
81851: DOUBLE
81852: EQUAL
81853: IFTRUE 81893
81855: LD_INT 22
81857: DOUBLE
81858: EQUAL
81859: IFTRUE 81893
81861: LD_INT 20
81863: DOUBLE
81864: EQUAL
81865: IFTRUE 81893
81867: LD_INT 21
81869: DOUBLE
81870: EQUAL
81871: IFTRUE 81893
81873: LD_INT 23
81875: DOUBLE
81876: EQUAL
81877: IFTRUE 81893
81879: LD_INT 24
81881: DOUBLE
81882: EQUAL
81883: IFTRUE 81893
81885: LD_INT 25
81887: DOUBLE
81888: EQUAL
81889: IFTRUE 81893
81891: GO 81949
81893: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81894: LD_ADDR_VAR 0 9
81898: PUSH
81899: LD_VAR 0 35
81903: PUSH
81904: LD_VAR 0 36
81908: PUSH
81909: LD_VAR 0 37
81913: PUSH
81914: LD_VAR 0 38
81918: PUSH
81919: LD_VAR 0 39
81923: PUSH
81924: LD_VAR 0 40
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: PUSH
81937: LD_VAR 0 4
81941: PUSH
81942: LD_INT 1
81944: PLUS
81945: ARRAY
81946: ST_TO_ADDR
81947: GO 82314
81949: LD_INT 6
81951: DOUBLE
81952: EQUAL
81953: IFTRUE 82005
81955: LD_INT 7
81957: DOUBLE
81958: EQUAL
81959: IFTRUE 82005
81961: LD_INT 8
81963: DOUBLE
81964: EQUAL
81965: IFTRUE 82005
81967: LD_INT 13
81969: DOUBLE
81970: EQUAL
81971: IFTRUE 82005
81973: LD_INT 12
81975: DOUBLE
81976: EQUAL
81977: IFTRUE 82005
81979: LD_INT 15
81981: DOUBLE
81982: EQUAL
81983: IFTRUE 82005
81985: LD_INT 11
81987: DOUBLE
81988: EQUAL
81989: IFTRUE 82005
81991: LD_INT 14
81993: DOUBLE
81994: EQUAL
81995: IFTRUE 82005
81997: LD_INT 10
81999: DOUBLE
82000: EQUAL
82001: IFTRUE 82005
82003: GO 82061
82005: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
82006: LD_ADDR_VAR 0 9
82010: PUSH
82011: LD_VAR 0 41
82015: PUSH
82016: LD_VAR 0 42
82020: PUSH
82021: LD_VAR 0 43
82025: PUSH
82026: LD_VAR 0 44
82030: PUSH
82031: LD_VAR 0 45
82035: PUSH
82036: LD_VAR 0 46
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: LIST
82047: LIST
82048: PUSH
82049: LD_VAR 0 4
82053: PUSH
82054: LD_INT 1
82056: PLUS
82057: ARRAY
82058: ST_TO_ADDR
82059: GO 82314
82061: LD_INT 36
82063: DOUBLE
82064: EQUAL
82065: IFTRUE 82069
82067: GO 82125
82069: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82070: LD_ADDR_VAR 0 9
82074: PUSH
82075: LD_VAR 0 47
82079: PUSH
82080: LD_VAR 0 48
82084: PUSH
82085: LD_VAR 0 49
82089: PUSH
82090: LD_VAR 0 50
82094: PUSH
82095: LD_VAR 0 51
82099: PUSH
82100: LD_VAR 0 52
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: PUSH
82113: LD_VAR 0 4
82117: PUSH
82118: LD_INT 1
82120: PLUS
82121: ARRAY
82122: ST_TO_ADDR
82123: GO 82314
82125: LD_INT 4
82127: DOUBLE
82128: EQUAL
82129: IFTRUE 82151
82131: LD_INT 5
82133: DOUBLE
82134: EQUAL
82135: IFTRUE 82151
82137: LD_INT 34
82139: DOUBLE
82140: EQUAL
82141: IFTRUE 82151
82143: LD_INT 37
82145: DOUBLE
82146: EQUAL
82147: IFTRUE 82151
82149: GO 82207
82151: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82152: LD_ADDR_VAR 0 9
82156: PUSH
82157: LD_VAR 0 53
82161: PUSH
82162: LD_VAR 0 54
82166: PUSH
82167: LD_VAR 0 55
82171: PUSH
82172: LD_VAR 0 56
82176: PUSH
82177: LD_VAR 0 57
82181: PUSH
82182: LD_VAR 0 58
82186: PUSH
82187: EMPTY
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: PUSH
82195: LD_VAR 0 4
82199: PUSH
82200: LD_INT 1
82202: PLUS
82203: ARRAY
82204: ST_TO_ADDR
82205: GO 82314
82207: LD_INT 31
82209: DOUBLE
82210: EQUAL
82211: IFTRUE 82257
82213: LD_INT 32
82215: DOUBLE
82216: EQUAL
82217: IFTRUE 82257
82219: LD_INT 33
82221: DOUBLE
82222: EQUAL
82223: IFTRUE 82257
82225: LD_INT 27
82227: DOUBLE
82228: EQUAL
82229: IFTRUE 82257
82231: LD_INT 26
82233: DOUBLE
82234: EQUAL
82235: IFTRUE 82257
82237: LD_INT 28
82239: DOUBLE
82240: EQUAL
82241: IFTRUE 82257
82243: LD_INT 29
82245: DOUBLE
82246: EQUAL
82247: IFTRUE 82257
82249: LD_INT 30
82251: DOUBLE
82252: EQUAL
82253: IFTRUE 82257
82255: GO 82313
82257: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
82258: LD_ADDR_VAR 0 9
82262: PUSH
82263: LD_VAR 0 59
82267: PUSH
82268: LD_VAR 0 60
82272: PUSH
82273: LD_VAR 0 61
82277: PUSH
82278: LD_VAR 0 62
82282: PUSH
82283: LD_VAR 0 63
82287: PUSH
82288: LD_VAR 0 64
82292: PUSH
82293: EMPTY
82294: LIST
82295: LIST
82296: LIST
82297: LIST
82298: LIST
82299: LIST
82300: PUSH
82301: LD_VAR 0 4
82305: PUSH
82306: LD_INT 1
82308: PLUS
82309: ARRAY
82310: ST_TO_ADDR
82311: GO 82314
82313: POP
// temp_list2 = [ ] ;
82314: LD_ADDR_VAR 0 10
82318: PUSH
82319: EMPTY
82320: ST_TO_ADDR
// for i in temp_list do
82321: LD_ADDR_VAR 0 8
82325: PUSH
82326: LD_VAR 0 9
82330: PUSH
82331: FOR_IN
82332: IFFALSE 82384
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
82334: LD_ADDR_VAR 0 10
82338: PUSH
82339: LD_VAR 0 10
82343: PUSH
82344: LD_VAR 0 8
82348: PUSH
82349: LD_INT 1
82351: ARRAY
82352: PUSH
82353: LD_VAR 0 2
82357: PLUS
82358: PUSH
82359: LD_VAR 0 8
82363: PUSH
82364: LD_INT 2
82366: ARRAY
82367: PUSH
82368: LD_VAR 0 3
82372: PLUS
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: PUSH
82378: EMPTY
82379: LIST
82380: ADD
82381: ST_TO_ADDR
82382: GO 82331
82384: POP
82385: POP
// result = temp_list2 ;
82386: LD_ADDR_VAR 0 7
82390: PUSH
82391: LD_VAR 0 10
82395: ST_TO_ADDR
// end ;
82396: LD_VAR 0 7
82400: RET
// export function EnemyInRange ( unit , dist ) ; begin
82401: LD_INT 0
82403: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82404: LD_ADDR_VAR 0 3
82408: PUSH
82409: LD_VAR 0 1
82413: PPUSH
82414: CALL_OW 255
82418: PPUSH
82419: LD_VAR 0 1
82423: PPUSH
82424: CALL_OW 250
82428: PPUSH
82429: LD_VAR 0 1
82433: PPUSH
82434: CALL_OW 251
82438: PPUSH
82439: LD_VAR 0 2
82443: PPUSH
82444: CALL 56505 0 4
82448: PUSH
82449: LD_INT 4
82451: ARRAY
82452: ST_TO_ADDR
// end ;
82453: LD_VAR 0 3
82457: RET
// export function PlayerSeeMe ( unit ) ; begin
82458: LD_INT 0
82460: PPUSH
// result := See ( your_side , unit ) ;
82461: LD_ADDR_VAR 0 2
82465: PUSH
82466: LD_OWVAR 2
82470: PPUSH
82471: LD_VAR 0 1
82475: PPUSH
82476: CALL_OW 292
82480: ST_TO_ADDR
// end ;
82481: LD_VAR 0 2
82485: RET
// export function ReverseDir ( unit ) ; begin
82486: LD_INT 0
82488: PPUSH
// if not unit then
82489: LD_VAR 0 1
82493: NOT
82494: IFFALSE 82498
// exit ;
82496: GO 82521
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82498: LD_ADDR_VAR 0 2
82502: PUSH
82503: LD_VAR 0 1
82507: PPUSH
82508: CALL_OW 254
82512: PUSH
82513: LD_INT 3
82515: PLUS
82516: PUSH
82517: LD_INT 6
82519: MOD
82520: ST_TO_ADDR
// end ;
82521: LD_VAR 0 2
82525: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
82526: LD_INT 0
82528: PPUSH
82529: PPUSH
82530: PPUSH
82531: PPUSH
82532: PPUSH
// if not hexes then
82533: LD_VAR 0 2
82537: NOT
82538: IFFALSE 82542
// exit ;
82540: GO 82690
// dist := 9999 ;
82542: LD_ADDR_VAR 0 5
82546: PUSH
82547: LD_INT 9999
82549: ST_TO_ADDR
// for i = 1 to hexes do
82550: LD_ADDR_VAR 0 4
82554: PUSH
82555: DOUBLE
82556: LD_INT 1
82558: DEC
82559: ST_TO_ADDR
82560: LD_VAR 0 2
82564: PUSH
82565: FOR_TO
82566: IFFALSE 82678
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
82568: LD_VAR 0 1
82572: PPUSH
82573: LD_VAR 0 2
82577: PUSH
82578: LD_VAR 0 4
82582: ARRAY
82583: PUSH
82584: LD_INT 1
82586: ARRAY
82587: PPUSH
82588: LD_VAR 0 2
82592: PUSH
82593: LD_VAR 0 4
82597: ARRAY
82598: PUSH
82599: LD_INT 2
82601: ARRAY
82602: PPUSH
82603: CALL_OW 297
82607: PUSH
82608: LD_VAR 0 5
82612: LESS
82613: IFFALSE 82676
// begin hex := hexes [ i ] ;
82615: LD_ADDR_VAR 0 7
82619: PUSH
82620: LD_VAR 0 2
82624: PUSH
82625: LD_VAR 0 4
82629: ARRAY
82630: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82631: LD_ADDR_VAR 0 5
82635: PUSH
82636: LD_VAR 0 1
82640: PPUSH
82641: LD_VAR 0 2
82645: PUSH
82646: LD_VAR 0 4
82650: ARRAY
82651: PUSH
82652: LD_INT 1
82654: ARRAY
82655: PPUSH
82656: LD_VAR 0 2
82660: PUSH
82661: LD_VAR 0 4
82665: ARRAY
82666: PUSH
82667: LD_INT 2
82669: ARRAY
82670: PPUSH
82671: CALL_OW 297
82675: ST_TO_ADDR
// end ; end ;
82676: GO 82565
82678: POP
82679: POP
// result := hex ;
82680: LD_ADDR_VAR 0 3
82684: PUSH
82685: LD_VAR 0 7
82689: ST_TO_ADDR
// end ;
82690: LD_VAR 0 3
82694: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82695: LD_INT 0
82697: PPUSH
82698: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82699: LD_VAR 0 1
82703: NOT
82704: PUSH
82705: LD_VAR 0 1
82709: PUSH
82710: LD_INT 21
82712: PUSH
82713: LD_INT 2
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: LD_INT 23
82722: PUSH
82723: LD_INT 2
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PPUSH
82734: CALL_OW 69
82738: IN
82739: NOT
82740: OR
82741: IFFALSE 82745
// exit ;
82743: GO 82792
// for i = 1 to 3 do
82745: LD_ADDR_VAR 0 3
82749: PUSH
82750: DOUBLE
82751: LD_INT 1
82753: DEC
82754: ST_TO_ADDR
82755: LD_INT 3
82757: PUSH
82758: FOR_TO
82759: IFFALSE 82790
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82761: LD_VAR 0 1
82765: PPUSH
82766: CALL_OW 250
82770: PPUSH
82771: LD_VAR 0 1
82775: PPUSH
82776: CALL_OW 251
82780: PPUSH
82781: LD_INT 1
82783: PPUSH
82784: CALL_OW 453
82788: GO 82758
82790: POP
82791: POP
// end ;
82792: LD_VAR 0 2
82796: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82797: LD_INT 0
82799: PPUSH
82800: PPUSH
82801: PPUSH
82802: PPUSH
82803: PPUSH
82804: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82805: LD_VAR 0 1
82809: NOT
82810: PUSH
82811: LD_VAR 0 2
82815: NOT
82816: OR
82817: PUSH
82818: LD_VAR 0 1
82822: PPUSH
82823: CALL_OW 314
82827: OR
82828: IFFALSE 82832
// exit ;
82830: GO 83273
// x := GetX ( enemy_unit ) ;
82832: LD_ADDR_VAR 0 7
82836: PUSH
82837: LD_VAR 0 2
82841: PPUSH
82842: CALL_OW 250
82846: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82847: LD_ADDR_VAR 0 8
82851: PUSH
82852: LD_VAR 0 2
82856: PPUSH
82857: CALL_OW 251
82861: ST_TO_ADDR
// if not x or not y then
82862: LD_VAR 0 7
82866: NOT
82867: PUSH
82868: LD_VAR 0 8
82872: NOT
82873: OR
82874: IFFALSE 82878
// exit ;
82876: GO 83273
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82878: LD_ADDR_VAR 0 6
82882: PUSH
82883: LD_VAR 0 7
82887: PPUSH
82888: LD_INT 0
82890: PPUSH
82891: LD_INT 4
82893: PPUSH
82894: CALL_OW 272
82898: PUSH
82899: LD_VAR 0 8
82903: PPUSH
82904: LD_INT 0
82906: PPUSH
82907: LD_INT 4
82909: PPUSH
82910: CALL_OW 273
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: LD_VAR 0 7
82923: PPUSH
82924: LD_INT 1
82926: PPUSH
82927: LD_INT 4
82929: PPUSH
82930: CALL_OW 272
82934: PUSH
82935: LD_VAR 0 8
82939: PPUSH
82940: LD_INT 1
82942: PPUSH
82943: LD_INT 4
82945: PPUSH
82946: CALL_OW 273
82950: PUSH
82951: EMPTY
82952: LIST
82953: LIST
82954: PUSH
82955: LD_VAR 0 7
82959: PPUSH
82960: LD_INT 2
82962: PPUSH
82963: LD_INT 4
82965: PPUSH
82966: CALL_OW 272
82970: PUSH
82971: LD_VAR 0 8
82975: PPUSH
82976: LD_INT 2
82978: PPUSH
82979: LD_INT 4
82981: PPUSH
82982: CALL_OW 273
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_VAR 0 7
82995: PPUSH
82996: LD_INT 3
82998: PPUSH
82999: LD_INT 4
83001: PPUSH
83002: CALL_OW 272
83006: PUSH
83007: LD_VAR 0 8
83011: PPUSH
83012: LD_INT 3
83014: PPUSH
83015: LD_INT 4
83017: PPUSH
83018: CALL_OW 273
83022: PUSH
83023: EMPTY
83024: LIST
83025: LIST
83026: PUSH
83027: LD_VAR 0 7
83031: PPUSH
83032: LD_INT 4
83034: PPUSH
83035: LD_INT 4
83037: PPUSH
83038: CALL_OW 272
83042: PUSH
83043: LD_VAR 0 8
83047: PPUSH
83048: LD_INT 4
83050: PPUSH
83051: LD_INT 4
83053: PPUSH
83054: CALL_OW 273
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: PUSH
83063: LD_VAR 0 7
83067: PPUSH
83068: LD_INT 5
83070: PPUSH
83071: LD_INT 4
83073: PPUSH
83074: CALL_OW 272
83078: PUSH
83079: LD_VAR 0 8
83083: PPUSH
83084: LD_INT 5
83086: PPUSH
83087: LD_INT 4
83089: PPUSH
83090: CALL_OW 273
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: ST_TO_ADDR
// for i = tmp downto 1 do
83107: LD_ADDR_VAR 0 4
83111: PUSH
83112: DOUBLE
83113: LD_VAR 0 6
83117: INC
83118: ST_TO_ADDR
83119: LD_INT 1
83121: PUSH
83122: FOR_DOWNTO
83123: IFFALSE 83224
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83125: LD_VAR 0 6
83129: PUSH
83130: LD_VAR 0 4
83134: ARRAY
83135: PUSH
83136: LD_INT 1
83138: ARRAY
83139: PPUSH
83140: LD_VAR 0 6
83144: PUSH
83145: LD_VAR 0 4
83149: ARRAY
83150: PUSH
83151: LD_INT 2
83153: ARRAY
83154: PPUSH
83155: CALL_OW 488
83159: NOT
83160: PUSH
83161: LD_VAR 0 6
83165: PUSH
83166: LD_VAR 0 4
83170: ARRAY
83171: PUSH
83172: LD_INT 1
83174: ARRAY
83175: PPUSH
83176: LD_VAR 0 6
83180: PUSH
83181: LD_VAR 0 4
83185: ARRAY
83186: PUSH
83187: LD_INT 2
83189: ARRAY
83190: PPUSH
83191: CALL_OW 428
83195: PUSH
83196: LD_INT 0
83198: NONEQUAL
83199: OR
83200: IFFALSE 83222
// tmp := Delete ( tmp , i ) ;
83202: LD_ADDR_VAR 0 6
83206: PUSH
83207: LD_VAR 0 6
83211: PPUSH
83212: LD_VAR 0 4
83216: PPUSH
83217: CALL_OW 3
83221: ST_TO_ADDR
83222: GO 83122
83224: POP
83225: POP
// j := GetClosestHex ( unit , tmp ) ;
83226: LD_ADDR_VAR 0 5
83230: PUSH
83231: LD_VAR 0 1
83235: PPUSH
83236: LD_VAR 0 6
83240: PPUSH
83241: CALL 82526 0 2
83245: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83246: LD_VAR 0 1
83250: PPUSH
83251: LD_VAR 0 5
83255: PUSH
83256: LD_INT 1
83258: ARRAY
83259: PPUSH
83260: LD_VAR 0 5
83264: PUSH
83265: LD_INT 2
83267: ARRAY
83268: PPUSH
83269: CALL_OW 111
// end ;
83273: LD_VAR 0 3
83277: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83278: LD_INT 0
83280: PPUSH
83281: PPUSH
83282: PPUSH
// uc_side = 0 ;
83283: LD_ADDR_OWVAR 20
83287: PUSH
83288: LD_INT 0
83290: ST_TO_ADDR
// uc_nation = 0 ;
83291: LD_ADDR_OWVAR 21
83295: PUSH
83296: LD_INT 0
83298: ST_TO_ADDR
// InitHc ;
83299: CALL_OW 19
// InitVc ;
83303: CALL_OW 20
// if mastodonts then
83307: LD_VAR 0 6
83311: IFFALSE 83378
// for i = 1 to mastodonts do
83313: LD_ADDR_VAR 0 11
83317: PUSH
83318: DOUBLE
83319: LD_INT 1
83321: DEC
83322: ST_TO_ADDR
83323: LD_VAR 0 6
83327: PUSH
83328: FOR_TO
83329: IFFALSE 83376
// begin vc_chassis := 31 ;
83331: LD_ADDR_OWVAR 37
83335: PUSH
83336: LD_INT 31
83338: ST_TO_ADDR
// vc_control := control_rider ;
83339: LD_ADDR_OWVAR 38
83343: PUSH
83344: LD_INT 4
83346: ST_TO_ADDR
// animal := CreateVehicle ;
83347: LD_ADDR_VAR 0 12
83351: PUSH
83352: CALL_OW 45
83356: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83357: LD_VAR 0 12
83361: PPUSH
83362: LD_VAR 0 8
83366: PPUSH
83367: LD_INT 0
83369: PPUSH
83370: CALL 85447 0 3
// end ;
83374: GO 83328
83376: POP
83377: POP
// if horses then
83378: LD_VAR 0 5
83382: IFFALSE 83449
// for i = 1 to horses do
83384: LD_ADDR_VAR 0 11
83388: PUSH
83389: DOUBLE
83390: LD_INT 1
83392: DEC
83393: ST_TO_ADDR
83394: LD_VAR 0 5
83398: PUSH
83399: FOR_TO
83400: IFFALSE 83447
// begin hc_class := 21 ;
83402: LD_ADDR_OWVAR 28
83406: PUSH
83407: LD_INT 21
83409: ST_TO_ADDR
// hc_gallery :=  ;
83410: LD_ADDR_OWVAR 33
83414: PUSH
83415: LD_STRING 
83417: ST_TO_ADDR
// animal := CreateHuman ;
83418: LD_ADDR_VAR 0 12
83422: PUSH
83423: CALL_OW 44
83427: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83428: LD_VAR 0 12
83432: PPUSH
83433: LD_VAR 0 8
83437: PPUSH
83438: LD_INT 0
83440: PPUSH
83441: CALL 85447 0 3
// end ;
83445: GO 83399
83447: POP
83448: POP
// if birds then
83449: LD_VAR 0 1
83453: IFFALSE 83520
// for i = 1 to birds do
83455: LD_ADDR_VAR 0 11
83459: PUSH
83460: DOUBLE
83461: LD_INT 1
83463: DEC
83464: ST_TO_ADDR
83465: LD_VAR 0 1
83469: PUSH
83470: FOR_TO
83471: IFFALSE 83518
// begin hc_class = 18 ;
83473: LD_ADDR_OWVAR 28
83477: PUSH
83478: LD_INT 18
83480: ST_TO_ADDR
// hc_gallery =  ;
83481: LD_ADDR_OWVAR 33
83485: PUSH
83486: LD_STRING 
83488: ST_TO_ADDR
// animal := CreateHuman ;
83489: LD_ADDR_VAR 0 12
83493: PUSH
83494: CALL_OW 44
83498: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83499: LD_VAR 0 12
83503: PPUSH
83504: LD_VAR 0 8
83508: PPUSH
83509: LD_INT 0
83511: PPUSH
83512: CALL 85447 0 3
// end ;
83516: GO 83470
83518: POP
83519: POP
// if tigers then
83520: LD_VAR 0 2
83524: IFFALSE 83608
// for i = 1 to tigers do
83526: LD_ADDR_VAR 0 11
83530: PUSH
83531: DOUBLE
83532: LD_INT 1
83534: DEC
83535: ST_TO_ADDR
83536: LD_VAR 0 2
83540: PUSH
83541: FOR_TO
83542: IFFALSE 83606
// begin hc_class = class_tiger ;
83544: LD_ADDR_OWVAR 28
83548: PUSH
83549: LD_INT 14
83551: ST_TO_ADDR
// hc_gallery =  ;
83552: LD_ADDR_OWVAR 33
83556: PUSH
83557: LD_STRING 
83559: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83560: LD_ADDR_OWVAR 35
83564: PUSH
83565: LD_INT 7
83567: NEG
83568: PPUSH
83569: LD_INT 7
83571: PPUSH
83572: CALL_OW 12
83576: ST_TO_ADDR
// animal := CreateHuman ;
83577: LD_ADDR_VAR 0 12
83581: PUSH
83582: CALL_OW 44
83586: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83587: LD_VAR 0 12
83591: PPUSH
83592: LD_VAR 0 8
83596: PPUSH
83597: LD_INT 0
83599: PPUSH
83600: CALL 85447 0 3
// end ;
83604: GO 83541
83606: POP
83607: POP
// if apemans then
83608: LD_VAR 0 3
83612: IFFALSE 83735
// for i = 1 to apemans do
83614: LD_ADDR_VAR 0 11
83618: PUSH
83619: DOUBLE
83620: LD_INT 1
83622: DEC
83623: ST_TO_ADDR
83624: LD_VAR 0 3
83628: PUSH
83629: FOR_TO
83630: IFFALSE 83733
// begin hc_class = class_apeman ;
83632: LD_ADDR_OWVAR 28
83636: PUSH
83637: LD_INT 12
83639: ST_TO_ADDR
// hc_gallery =  ;
83640: LD_ADDR_OWVAR 33
83644: PUSH
83645: LD_STRING 
83647: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
83648: LD_ADDR_OWVAR 35
83652: PUSH
83653: LD_INT 5
83655: NEG
83656: PPUSH
83657: LD_INT 5
83659: PPUSH
83660: CALL_OW 12
83664: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83665: LD_ADDR_OWVAR 31
83669: PUSH
83670: LD_INT 1
83672: PPUSH
83673: LD_INT 3
83675: PPUSH
83676: CALL_OW 12
83680: PUSH
83681: LD_INT 1
83683: PPUSH
83684: LD_INT 3
83686: PPUSH
83687: CALL_OW 12
83691: PUSH
83692: LD_INT 0
83694: PUSH
83695: LD_INT 0
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: ST_TO_ADDR
// animal := CreateHuman ;
83704: LD_ADDR_VAR 0 12
83708: PUSH
83709: CALL_OW 44
83713: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83714: LD_VAR 0 12
83718: PPUSH
83719: LD_VAR 0 8
83723: PPUSH
83724: LD_INT 0
83726: PPUSH
83727: CALL 85447 0 3
// end ;
83731: GO 83629
83733: POP
83734: POP
// if enchidnas then
83735: LD_VAR 0 4
83739: IFFALSE 83806
// for i = 1 to enchidnas do
83741: LD_ADDR_VAR 0 11
83745: PUSH
83746: DOUBLE
83747: LD_INT 1
83749: DEC
83750: ST_TO_ADDR
83751: LD_VAR 0 4
83755: PUSH
83756: FOR_TO
83757: IFFALSE 83804
// begin hc_class = 13 ;
83759: LD_ADDR_OWVAR 28
83763: PUSH
83764: LD_INT 13
83766: ST_TO_ADDR
// hc_gallery =  ;
83767: LD_ADDR_OWVAR 33
83771: PUSH
83772: LD_STRING 
83774: ST_TO_ADDR
// animal := CreateHuman ;
83775: LD_ADDR_VAR 0 12
83779: PUSH
83780: CALL_OW 44
83784: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83785: LD_VAR 0 12
83789: PPUSH
83790: LD_VAR 0 8
83794: PPUSH
83795: LD_INT 0
83797: PPUSH
83798: CALL 85447 0 3
// end ;
83802: GO 83756
83804: POP
83805: POP
// if fishes then
83806: LD_VAR 0 7
83810: IFFALSE 83877
// for i = 1 to fishes do
83812: LD_ADDR_VAR 0 11
83816: PUSH
83817: DOUBLE
83818: LD_INT 1
83820: DEC
83821: ST_TO_ADDR
83822: LD_VAR 0 7
83826: PUSH
83827: FOR_TO
83828: IFFALSE 83875
// begin hc_class = 20 ;
83830: LD_ADDR_OWVAR 28
83834: PUSH
83835: LD_INT 20
83837: ST_TO_ADDR
// hc_gallery =  ;
83838: LD_ADDR_OWVAR 33
83842: PUSH
83843: LD_STRING 
83845: ST_TO_ADDR
// animal := CreateHuman ;
83846: LD_ADDR_VAR 0 12
83850: PUSH
83851: CALL_OW 44
83855: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83856: LD_VAR 0 12
83860: PPUSH
83861: LD_VAR 0 9
83865: PPUSH
83866: LD_INT 0
83868: PPUSH
83869: CALL 85447 0 3
// end ;
83873: GO 83827
83875: POP
83876: POP
// end ;
83877: LD_VAR 0 10
83881: RET
// export function WantHeal ( sci , unit ) ; begin
83882: LD_INT 0
83884: PPUSH
// if GetTaskList ( sci ) > 0 then
83885: LD_VAR 0 1
83889: PPUSH
83890: CALL_OW 437
83894: PUSH
83895: LD_INT 0
83897: GREATER
83898: IFFALSE 83968
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83900: LD_VAR 0 1
83904: PPUSH
83905: CALL_OW 437
83909: PUSH
83910: LD_INT 1
83912: ARRAY
83913: PUSH
83914: LD_INT 1
83916: ARRAY
83917: PUSH
83918: LD_STRING l
83920: EQUAL
83921: PUSH
83922: LD_VAR 0 1
83926: PPUSH
83927: CALL_OW 437
83931: PUSH
83932: LD_INT 1
83934: ARRAY
83935: PUSH
83936: LD_INT 4
83938: ARRAY
83939: PUSH
83940: LD_VAR 0 2
83944: EQUAL
83945: AND
83946: IFFALSE 83958
// result := true else
83948: LD_ADDR_VAR 0 3
83952: PUSH
83953: LD_INT 1
83955: ST_TO_ADDR
83956: GO 83966
// result := false ;
83958: LD_ADDR_VAR 0 3
83962: PUSH
83963: LD_INT 0
83965: ST_TO_ADDR
// end else
83966: GO 83976
// result := false ;
83968: LD_ADDR_VAR 0 3
83972: PUSH
83973: LD_INT 0
83975: ST_TO_ADDR
// end ;
83976: LD_VAR 0 3
83980: RET
// export function HealTarget ( sci ) ; begin
83981: LD_INT 0
83983: PPUSH
// if not sci then
83984: LD_VAR 0 1
83988: NOT
83989: IFFALSE 83993
// exit ;
83991: GO 84058
// result := 0 ;
83993: LD_ADDR_VAR 0 2
83997: PUSH
83998: LD_INT 0
84000: ST_TO_ADDR
// if GetTaskList ( sci ) then
84001: LD_VAR 0 1
84005: PPUSH
84006: CALL_OW 437
84010: IFFALSE 84058
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84012: LD_VAR 0 1
84016: PPUSH
84017: CALL_OW 437
84021: PUSH
84022: LD_INT 1
84024: ARRAY
84025: PUSH
84026: LD_INT 1
84028: ARRAY
84029: PUSH
84030: LD_STRING l
84032: EQUAL
84033: IFFALSE 84058
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84035: LD_ADDR_VAR 0 2
84039: PUSH
84040: LD_VAR 0 1
84044: PPUSH
84045: CALL_OW 437
84049: PUSH
84050: LD_INT 1
84052: ARRAY
84053: PUSH
84054: LD_INT 4
84056: ARRAY
84057: ST_TO_ADDR
// end ;
84058: LD_VAR 0 2
84062: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84063: LD_INT 0
84065: PPUSH
84066: PPUSH
84067: PPUSH
84068: PPUSH
// if not base_units then
84069: LD_VAR 0 1
84073: NOT
84074: IFFALSE 84078
// exit ;
84076: GO 84165
// result := false ;
84078: LD_ADDR_VAR 0 2
84082: PUSH
84083: LD_INT 0
84085: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84086: LD_ADDR_VAR 0 5
84090: PUSH
84091: LD_VAR 0 1
84095: PPUSH
84096: LD_INT 21
84098: PUSH
84099: LD_INT 3
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PPUSH
84106: CALL_OW 72
84110: ST_TO_ADDR
// if not tmp then
84111: LD_VAR 0 5
84115: NOT
84116: IFFALSE 84120
// exit ;
84118: GO 84165
// for i in tmp do
84120: LD_ADDR_VAR 0 3
84124: PUSH
84125: LD_VAR 0 5
84129: PUSH
84130: FOR_IN
84131: IFFALSE 84163
// begin result := EnemyInRange ( i , 22 ) ;
84133: LD_ADDR_VAR 0 2
84137: PUSH
84138: LD_VAR 0 3
84142: PPUSH
84143: LD_INT 22
84145: PPUSH
84146: CALL 82401 0 2
84150: ST_TO_ADDR
// if result then
84151: LD_VAR 0 2
84155: IFFALSE 84161
// exit ;
84157: POP
84158: POP
84159: GO 84165
// end ;
84161: GO 84130
84163: POP
84164: POP
// end ;
84165: LD_VAR 0 2
84169: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
84170: LD_INT 0
84172: PPUSH
84173: PPUSH
// if not units then
84174: LD_VAR 0 1
84178: NOT
84179: IFFALSE 84183
// exit ;
84181: GO 84253
// result := [ ] ;
84183: LD_ADDR_VAR 0 3
84187: PUSH
84188: EMPTY
84189: ST_TO_ADDR
// for i in units do
84190: LD_ADDR_VAR 0 4
84194: PUSH
84195: LD_VAR 0 1
84199: PUSH
84200: FOR_IN
84201: IFFALSE 84251
// if GetTag ( i ) = tag then
84203: LD_VAR 0 4
84207: PPUSH
84208: CALL_OW 110
84212: PUSH
84213: LD_VAR 0 2
84217: EQUAL
84218: IFFALSE 84249
// result := Insert ( result , result + 1 , i ) ;
84220: LD_ADDR_VAR 0 3
84224: PUSH
84225: LD_VAR 0 3
84229: PPUSH
84230: LD_VAR 0 3
84234: PUSH
84235: LD_INT 1
84237: PLUS
84238: PPUSH
84239: LD_VAR 0 4
84243: PPUSH
84244: CALL_OW 2
84248: ST_TO_ADDR
84249: GO 84200
84251: POP
84252: POP
// end ;
84253: LD_VAR 0 3
84257: RET
// export function IsDriver ( un ) ; begin
84258: LD_INT 0
84260: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84261: LD_ADDR_VAR 0 2
84265: PUSH
84266: LD_VAR 0 1
84270: PUSH
84271: LD_INT 55
84273: PUSH
84274: EMPTY
84275: LIST
84276: PPUSH
84277: CALL_OW 69
84281: IN
84282: ST_TO_ADDR
// end ;
84283: LD_VAR 0 2
84287: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84288: LD_INT 0
84290: PPUSH
84291: PPUSH
// list := [ ] ;
84292: LD_ADDR_VAR 0 5
84296: PUSH
84297: EMPTY
84298: ST_TO_ADDR
// case d of 0 :
84299: LD_VAR 0 3
84303: PUSH
84304: LD_INT 0
84306: DOUBLE
84307: EQUAL
84308: IFTRUE 84312
84310: GO 84445
84312: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84313: LD_ADDR_VAR 0 5
84317: PUSH
84318: LD_VAR 0 1
84322: PUSH
84323: LD_INT 4
84325: MINUS
84326: PUSH
84327: LD_VAR 0 2
84331: PUSH
84332: LD_INT 4
84334: MINUS
84335: PUSH
84336: LD_INT 2
84338: PUSH
84339: EMPTY
84340: LIST
84341: LIST
84342: LIST
84343: PUSH
84344: LD_VAR 0 1
84348: PUSH
84349: LD_INT 3
84351: MINUS
84352: PUSH
84353: LD_VAR 0 2
84357: PUSH
84358: LD_INT 1
84360: PUSH
84361: EMPTY
84362: LIST
84363: LIST
84364: LIST
84365: PUSH
84366: LD_VAR 0 1
84370: PUSH
84371: LD_INT 4
84373: PLUS
84374: PUSH
84375: LD_VAR 0 2
84379: PUSH
84380: LD_INT 4
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: LIST
84387: PUSH
84388: LD_VAR 0 1
84392: PUSH
84393: LD_INT 3
84395: PLUS
84396: PUSH
84397: LD_VAR 0 2
84401: PUSH
84402: LD_INT 3
84404: PLUS
84405: PUSH
84406: LD_INT 5
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: LIST
84413: PUSH
84414: LD_VAR 0 1
84418: PUSH
84419: LD_VAR 0 2
84423: PUSH
84424: LD_INT 4
84426: PLUS
84427: PUSH
84428: LD_INT 0
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: LIST
84435: PUSH
84436: EMPTY
84437: LIST
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: ST_TO_ADDR
// end ; 1 :
84443: GO 85143
84445: LD_INT 1
84447: DOUBLE
84448: EQUAL
84449: IFTRUE 84453
84451: GO 84586
84453: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84454: LD_ADDR_VAR 0 5
84458: PUSH
84459: LD_VAR 0 1
84463: PUSH
84464: LD_VAR 0 2
84468: PUSH
84469: LD_INT 4
84471: MINUS
84472: PUSH
84473: LD_INT 3
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: LIST
84480: PUSH
84481: LD_VAR 0 1
84485: PUSH
84486: LD_INT 3
84488: MINUS
84489: PUSH
84490: LD_VAR 0 2
84494: PUSH
84495: LD_INT 3
84497: MINUS
84498: PUSH
84499: LD_INT 2
84501: PUSH
84502: EMPTY
84503: LIST
84504: LIST
84505: LIST
84506: PUSH
84507: LD_VAR 0 1
84511: PUSH
84512: LD_INT 4
84514: MINUS
84515: PUSH
84516: LD_VAR 0 2
84520: PUSH
84521: LD_INT 1
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: LIST
84528: PUSH
84529: LD_VAR 0 1
84533: PUSH
84534: LD_VAR 0 2
84538: PUSH
84539: LD_INT 3
84541: PLUS
84542: PUSH
84543: LD_INT 0
84545: PUSH
84546: EMPTY
84547: LIST
84548: LIST
84549: LIST
84550: PUSH
84551: LD_VAR 0 1
84555: PUSH
84556: LD_INT 4
84558: PLUS
84559: PUSH
84560: LD_VAR 0 2
84564: PUSH
84565: LD_INT 4
84567: PLUS
84568: PUSH
84569: LD_INT 5
84571: PUSH
84572: EMPTY
84573: LIST
84574: LIST
84575: LIST
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: ST_TO_ADDR
// end ; 2 :
84584: GO 85143
84586: LD_INT 2
84588: DOUBLE
84589: EQUAL
84590: IFTRUE 84594
84592: GO 84723
84594: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84595: LD_ADDR_VAR 0 5
84599: PUSH
84600: LD_VAR 0 1
84604: PUSH
84605: LD_VAR 0 2
84609: PUSH
84610: LD_INT 3
84612: MINUS
84613: PUSH
84614: LD_INT 3
84616: PUSH
84617: EMPTY
84618: LIST
84619: LIST
84620: LIST
84621: PUSH
84622: LD_VAR 0 1
84626: PUSH
84627: LD_INT 4
84629: PLUS
84630: PUSH
84631: LD_VAR 0 2
84635: PUSH
84636: LD_INT 4
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: LIST
84643: PUSH
84644: LD_VAR 0 1
84648: PUSH
84649: LD_VAR 0 2
84653: PUSH
84654: LD_INT 4
84656: PLUS
84657: PUSH
84658: LD_INT 0
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: LIST
84665: PUSH
84666: LD_VAR 0 1
84670: PUSH
84671: LD_INT 3
84673: MINUS
84674: PUSH
84675: LD_VAR 0 2
84679: PUSH
84680: LD_INT 1
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: LIST
84687: PUSH
84688: LD_VAR 0 1
84692: PUSH
84693: LD_INT 4
84695: MINUS
84696: PUSH
84697: LD_VAR 0 2
84701: PUSH
84702: LD_INT 4
84704: MINUS
84705: PUSH
84706: LD_INT 2
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: LIST
84713: PUSH
84714: EMPTY
84715: LIST
84716: LIST
84717: LIST
84718: LIST
84719: LIST
84720: ST_TO_ADDR
// end ; 3 :
84721: GO 85143
84723: LD_INT 3
84725: DOUBLE
84726: EQUAL
84727: IFTRUE 84731
84729: GO 84864
84731: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84732: LD_ADDR_VAR 0 5
84736: PUSH
84737: LD_VAR 0 1
84741: PUSH
84742: LD_INT 3
84744: PLUS
84745: PUSH
84746: LD_VAR 0 2
84750: PUSH
84751: LD_INT 4
84753: PUSH
84754: EMPTY
84755: LIST
84756: LIST
84757: LIST
84758: PUSH
84759: LD_VAR 0 1
84763: PUSH
84764: LD_INT 4
84766: PLUS
84767: PUSH
84768: LD_VAR 0 2
84772: PUSH
84773: LD_INT 4
84775: PLUS
84776: PUSH
84777: LD_INT 5
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: LIST
84784: PUSH
84785: LD_VAR 0 1
84789: PUSH
84790: LD_INT 4
84792: MINUS
84793: PUSH
84794: LD_VAR 0 2
84798: PUSH
84799: LD_INT 1
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: LIST
84806: PUSH
84807: LD_VAR 0 1
84811: PUSH
84812: LD_VAR 0 2
84816: PUSH
84817: LD_INT 4
84819: MINUS
84820: PUSH
84821: LD_INT 3
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: LIST
84828: PUSH
84829: LD_VAR 0 1
84833: PUSH
84834: LD_INT 3
84836: MINUS
84837: PUSH
84838: LD_VAR 0 2
84842: PUSH
84843: LD_INT 3
84845: MINUS
84846: PUSH
84847: LD_INT 2
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: LIST
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: ST_TO_ADDR
// end ; 4 :
84862: GO 85143
84864: LD_INT 4
84866: DOUBLE
84867: EQUAL
84868: IFTRUE 84872
84870: GO 85005
84872: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84873: LD_ADDR_VAR 0 5
84877: PUSH
84878: LD_VAR 0 1
84882: PUSH
84883: LD_VAR 0 2
84887: PUSH
84888: LD_INT 4
84890: PLUS
84891: PUSH
84892: LD_INT 0
84894: PUSH
84895: EMPTY
84896: LIST
84897: LIST
84898: LIST
84899: PUSH
84900: LD_VAR 0 1
84904: PUSH
84905: LD_INT 3
84907: PLUS
84908: PUSH
84909: LD_VAR 0 2
84913: PUSH
84914: LD_INT 3
84916: PLUS
84917: PUSH
84918: LD_INT 5
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: LIST
84925: PUSH
84926: LD_VAR 0 1
84930: PUSH
84931: LD_INT 4
84933: PLUS
84934: PUSH
84935: LD_VAR 0 2
84939: PUSH
84940: LD_INT 4
84942: PUSH
84943: EMPTY
84944: LIST
84945: LIST
84946: LIST
84947: PUSH
84948: LD_VAR 0 1
84952: PUSH
84953: LD_VAR 0 2
84957: PUSH
84958: LD_INT 3
84960: MINUS
84961: PUSH
84962: LD_INT 3
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: LIST
84969: PUSH
84970: LD_VAR 0 1
84974: PUSH
84975: LD_INT 4
84977: MINUS
84978: PUSH
84979: LD_VAR 0 2
84983: PUSH
84984: LD_INT 4
84986: MINUS
84987: PUSH
84988: LD_INT 2
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: LIST
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: LIST
85000: LIST
85001: LIST
85002: ST_TO_ADDR
// end ; 5 :
85003: GO 85143
85005: LD_INT 5
85007: DOUBLE
85008: EQUAL
85009: IFTRUE 85013
85011: GO 85142
85013: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85014: LD_ADDR_VAR 0 5
85018: PUSH
85019: LD_VAR 0 1
85023: PUSH
85024: LD_INT 4
85026: MINUS
85027: PUSH
85028: LD_VAR 0 2
85032: PUSH
85033: LD_INT 1
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: LIST
85040: PUSH
85041: LD_VAR 0 1
85045: PUSH
85046: LD_VAR 0 2
85050: PUSH
85051: LD_INT 4
85053: MINUS
85054: PUSH
85055: LD_INT 3
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: LIST
85062: PUSH
85063: LD_VAR 0 1
85067: PUSH
85068: LD_INT 4
85070: PLUS
85071: PUSH
85072: LD_VAR 0 2
85076: PUSH
85077: LD_INT 4
85079: PLUS
85080: PUSH
85081: LD_INT 5
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: LIST
85088: PUSH
85089: LD_VAR 0 1
85093: PUSH
85094: LD_INT 3
85096: PLUS
85097: PUSH
85098: LD_VAR 0 2
85102: PUSH
85103: LD_INT 4
85105: PUSH
85106: EMPTY
85107: LIST
85108: LIST
85109: LIST
85110: PUSH
85111: LD_VAR 0 1
85115: PUSH
85116: LD_VAR 0 2
85120: PUSH
85121: LD_INT 3
85123: PLUS
85124: PUSH
85125: LD_INT 0
85127: PUSH
85128: EMPTY
85129: LIST
85130: LIST
85131: LIST
85132: PUSH
85133: EMPTY
85134: LIST
85135: LIST
85136: LIST
85137: LIST
85138: LIST
85139: ST_TO_ADDR
// end ; end ;
85140: GO 85143
85142: POP
// result := list ;
85143: LD_ADDR_VAR 0 4
85147: PUSH
85148: LD_VAR 0 5
85152: ST_TO_ADDR
// end ;
85153: LD_VAR 0 4
85157: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85158: LD_INT 0
85160: PPUSH
85161: PPUSH
85162: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85163: LD_VAR 0 1
85167: NOT
85168: PUSH
85169: LD_VAR 0 2
85173: PUSH
85174: LD_INT 1
85176: PUSH
85177: LD_INT 2
85179: PUSH
85180: LD_INT 3
85182: PUSH
85183: LD_INT 4
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: IN
85192: NOT
85193: OR
85194: IFFALSE 85198
// exit ;
85196: GO 85290
// tmp := [ ] ;
85198: LD_ADDR_VAR 0 5
85202: PUSH
85203: EMPTY
85204: ST_TO_ADDR
// for i in units do
85205: LD_ADDR_VAR 0 4
85209: PUSH
85210: LD_VAR 0 1
85214: PUSH
85215: FOR_IN
85216: IFFALSE 85259
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
85218: LD_ADDR_VAR 0 5
85222: PUSH
85223: LD_VAR 0 5
85227: PPUSH
85228: LD_VAR 0 5
85232: PUSH
85233: LD_INT 1
85235: PLUS
85236: PPUSH
85237: LD_VAR 0 4
85241: PPUSH
85242: LD_VAR 0 2
85246: PPUSH
85247: CALL_OW 259
85251: PPUSH
85252: CALL_OW 2
85256: ST_TO_ADDR
85257: GO 85215
85259: POP
85260: POP
// if not tmp then
85261: LD_VAR 0 5
85265: NOT
85266: IFFALSE 85270
// exit ;
85268: GO 85290
// result := SortListByListDesc ( units , tmp ) ;
85270: LD_ADDR_VAR 0 3
85274: PUSH
85275: LD_VAR 0 1
85279: PPUSH
85280: LD_VAR 0 5
85284: PPUSH
85285: CALL_OW 77
85289: ST_TO_ADDR
// end ;
85290: LD_VAR 0 3
85294: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85295: LD_INT 0
85297: PPUSH
85298: PPUSH
85299: PPUSH
// x := GetX ( building ) ;
85300: LD_ADDR_VAR 0 4
85304: PUSH
85305: LD_VAR 0 2
85309: PPUSH
85310: CALL_OW 250
85314: ST_TO_ADDR
// y := GetY ( building ) ;
85315: LD_ADDR_VAR 0 5
85319: PUSH
85320: LD_VAR 0 2
85324: PPUSH
85325: CALL_OW 251
85329: ST_TO_ADDR
// if GetTaskList ( unit ) then
85330: LD_VAR 0 1
85334: PPUSH
85335: CALL_OW 437
85339: IFFALSE 85434
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85341: LD_STRING e
85343: PUSH
85344: LD_VAR 0 1
85348: PPUSH
85349: CALL_OW 437
85353: PUSH
85354: LD_INT 1
85356: ARRAY
85357: PUSH
85358: LD_INT 1
85360: ARRAY
85361: EQUAL
85362: PUSH
85363: LD_VAR 0 4
85367: PUSH
85368: LD_VAR 0 1
85372: PPUSH
85373: CALL_OW 437
85377: PUSH
85378: LD_INT 1
85380: ARRAY
85381: PUSH
85382: LD_INT 2
85384: ARRAY
85385: EQUAL
85386: AND
85387: PUSH
85388: LD_VAR 0 5
85392: PUSH
85393: LD_VAR 0 1
85397: PPUSH
85398: CALL_OW 437
85402: PUSH
85403: LD_INT 1
85405: ARRAY
85406: PUSH
85407: LD_INT 3
85409: ARRAY
85410: EQUAL
85411: AND
85412: IFFALSE 85424
// result := true else
85414: LD_ADDR_VAR 0 3
85418: PUSH
85419: LD_INT 1
85421: ST_TO_ADDR
85422: GO 85432
// result := false ;
85424: LD_ADDR_VAR 0 3
85428: PUSH
85429: LD_INT 0
85431: ST_TO_ADDR
// end else
85432: GO 85442
// result := false ;
85434: LD_ADDR_VAR 0 3
85438: PUSH
85439: LD_INT 0
85441: ST_TO_ADDR
// end ;
85442: LD_VAR 0 3
85446: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85447: LD_INT 0
85449: PPUSH
85450: PPUSH
85451: PPUSH
85452: PPUSH
// if not unit or not area then
85453: LD_VAR 0 1
85457: NOT
85458: PUSH
85459: LD_VAR 0 2
85463: NOT
85464: OR
85465: IFFALSE 85469
// exit ;
85467: GO 85633
// tmp := AreaToList ( area , i ) ;
85469: LD_ADDR_VAR 0 6
85473: PUSH
85474: LD_VAR 0 2
85478: PPUSH
85479: LD_VAR 0 5
85483: PPUSH
85484: CALL_OW 517
85488: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85489: LD_ADDR_VAR 0 5
85493: PUSH
85494: DOUBLE
85495: LD_INT 1
85497: DEC
85498: ST_TO_ADDR
85499: LD_VAR 0 6
85503: PUSH
85504: LD_INT 1
85506: ARRAY
85507: PUSH
85508: FOR_TO
85509: IFFALSE 85631
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85511: LD_ADDR_VAR 0 7
85515: PUSH
85516: LD_VAR 0 6
85520: PUSH
85521: LD_INT 1
85523: ARRAY
85524: PUSH
85525: LD_VAR 0 5
85529: ARRAY
85530: PUSH
85531: LD_VAR 0 6
85535: PUSH
85536: LD_INT 2
85538: ARRAY
85539: PUSH
85540: LD_VAR 0 5
85544: ARRAY
85545: PUSH
85546: EMPTY
85547: LIST
85548: LIST
85549: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85550: LD_VAR 0 7
85554: PUSH
85555: LD_INT 1
85557: ARRAY
85558: PPUSH
85559: LD_VAR 0 7
85563: PUSH
85564: LD_INT 2
85566: ARRAY
85567: PPUSH
85568: CALL_OW 428
85572: PUSH
85573: LD_INT 0
85575: EQUAL
85576: IFFALSE 85629
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85578: LD_VAR 0 1
85582: PPUSH
85583: LD_VAR 0 7
85587: PUSH
85588: LD_INT 1
85590: ARRAY
85591: PPUSH
85592: LD_VAR 0 7
85596: PUSH
85597: LD_INT 2
85599: ARRAY
85600: PPUSH
85601: LD_VAR 0 3
85605: PPUSH
85606: CALL_OW 48
// result := IsPlaced ( unit ) ;
85610: LD_ADDR_VAR 0 4
85614: PUSH
85615: LD_VAR 0 1
85619: PPUSH
85620: CALL_OW 305
85624: ST_TO_ADDR
// exit ;
85625: POP
85626: POP
85627: GO 85633
// end ; end ;
85629: GO 85508
85631: POP
85632: POP
// end ;
85633: LD_VAR 0 4
85637: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85638: LD_INT 0
85640: PPUSH
85641: PPUSH
85642: PPUSH
// if not side or side > 8 then
85643: LD_VAR 0 1
85647: NOT
85648: PUSH
85649: LD_VAR 0 1
85653: PUSH
85654: LD_INT 8
85656: GREATER
85657: OR
85658: IFFALSE 85662
// exit ;
85660: GO 85849
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85662: LD_ADDR_VAR 0 4
85666: PUSH
85667: LD_INT 22
85669: PUSH
85670: LD_VAR 0 1
85674: PUSH
85675: EMPTY
85676: LIST
85677: LIST
85678: PUSH
85679: LD_INT 21
85681: PUSH
85682: LD_INT 3
85684: PUSH
85685: EMPTY
85686: LIST
85687: LIST
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PPUSH
85693: CALL_OW 69
85697: ST_TO_ADDR
// if not tmp then
85698: LD_VAR 0 4
85702: NOT
85703: IFFALSE 85707
// exit ;
85705: GO 85849
// enable_addtolog := true ;
85707: LD_ADDR_OWVAR 81
85711: PUSH
85712: LD_INT 1
85714: ST_TO_ADDR
// AddToLog ( [ ) ;
85715: LD_STRING [
85717: PPUSH
85718: CALL_OW 561
// for i in tmp do
85722: LD_ADDR_VAR 0 3
85726: PUSH
85727: LD_VAR 0 4
85731: PUSH
85732: FOR_IN
85733: IFFALSE 85840
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85735: LD_STRING [
85737: PUSH
85738: LD_VAR 0 3
85742: PPUSH
85743: CALL_OW 266
85747: STR
85748: PUSH
85749: LD_STRING , 
85751: STR
85752: PUSH
85753: LD_VAR 0 3
85757: PPUSH
85758: CALL_OW 250
85762: STR
85763: PUSH
85764: LD_STRING , 
85766: STR
85767: PUSH
85768: LD_VAR 0 3
85772: PPUSH
85773: CALL_OW 251
85777: STR
85778: PUSH
85779: LD_STRING , 
85781: STR
85782: PUSH
85783: LD_VAR 0 3
85787: PPUSH
85788: CALL_OW 254
85792: STR
85793: PUSH
85794: LD_STRING , 
85796: STR
85797: PUSH
85798: LD_VAR 0 3
85802: PPUSH
85803: LD_INT 1
85805: PPUSH
85806: CALL_OW 268
85810: STR
85811: PUSH
85812: LD_STRING , 
85814: STR
85815: PUSH
85816: LD_VAR 0 3
85820: PPUSH
85821: LD_INT 2
85823: PPUSH
85824: CALL_OW 268
85828: STR
85829: PUSH
85830: LD_STRING ],
85832: STR
85833: PPUSH
85834: CALL_OW 561
// end ;
85838: GO 85732
85840: POP
85841: POP
// AddToLog ( ]; ) ;
85842: LD_STRING ];
85844: PPUSH
85845: CALL_OW 561
// end ;
85849: LD_VAR 0 2
85853: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85854: LD_INT 0
85856: PPUSH
85857: PPUSH
85858: PPUSH
85859: PPUSH
85860: PPUSH
// if not area or not rate or not max then
85861: LD_VAR 0 1
85865: NOT
85866: PUSH
85867: LD_VAR 0 2
85871: NOT
85872: OR
85873: PUSH
85874: LD_VAR 0 4
85878: NOT
85879: OR
85880: IFFALSE 85884
// exit ;
85882: GO 86076
// while 1 do
85884: LD_INT 1
85886: IFFALSE 86076
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85888: LD_ADDR_VAR 0 9
85892: PUSH
85893: LD_VAR 0 1
85897: PPUSH
85898: LD_INT 1
85900: PPUSH
85901: CALL_OW 287
85905: PUSH
85906: LD_INT 10
85908: MUL
85909: ST_TO_ADDR
// r := rate / 10 ;
85910: LD_ADDR_VAR 0 7
85914: PUSH
85915: LD_VAR 0 2
85919: PUSH
85920: LD_INT 10
85922: DIVREAL
85923: ST_TO_ADDR
// time := 1 1$00 ;
85924: LD_ADDR_VAR 0 8
85928: PUSH
85929: LD_INT 2100
85931: ST_TO_ADDR
// if amount < min then
85932: LD_VAR 0 9
85936: PUSH
85937: LD_VAR 0 3
85941: LESS
85942: IFFALSE 85960
// r := r * 2 else
85944: LD_ADDR_VAR 0 7
85948: PUSH
85949: LD_VAR 0 7
85953: PUSH
85954: LD_INT 2
85956: MUL
85957: ST_TO_ADDR
85958: GO 85986
// if amount > max then
85960: LD_VAR 0 9
85964: PUSH
85965: LD_VAR 0 4
85969: GREATER
85970: IFFALSE 85986
// r := r / 2 ;
85972: LD_ADDR_VAR 0 7
85976: PUSH
85977: LD_VAR 0 7
85981: PUSH
85982: LD_INT 2
85984: DIVREAL
85985: ST_TO_ADDR
// time := time / r ;
85986: LD_ADDR_VAR 0 8
85990: PUSH
85991: LD_VAR 0 8
85995: PUSH
85996: LD_VAR 0 7
86000: DIVREAL
86001: ST_TO_ADDR
// if time < 0 then
86002: LD_VAR 0 8
86006: PUSH
86007: LD_INT 0
86009: LESS
86010: IFFALSE 86027
// time := time * - 1 ;
86012: LD_ADDR_VAR 0 8
86016: PUSH
86017: LD_VAR 0 8
86021: PUSH
86022: LD_INT 1
86024: NEG
86025: MUL
86026: ST_TO_ADDR
// wait ( time ) ;
86027: LD_VAR 0 8
86031: PPUSH
86032: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
86036: LD_INT 35
86038: PPUSH
86039: LD_INT 875
86041: PPUSH
86042: CALL_OW 12
86046: PPUSH
86047: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86051: LD_INT 1
86053: PPUSH
86054: LD_INT 5
86056: PPUSH
86057: CALL_OW 12
86061: PPUSH
86062: LD_VAR 0 1
86066: PPUSH
86067: LD_INT 1
86069: PPUSH
86070: CALL_OW 55
// end ;
86074: GO 85884
// end ;
86076: LD_VAR 0 5
86080: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86081: LD_INT 0
86083: PPUSH
86084: PPUSH
86085: PPUSH
86086: PPUSH
86087: PPUSH
86088: PPUSH
86089: PPUSH
86090: PPUSH
// if not turrets or not factories then
86091: LD_VAR 0 1
86095: NOT
86096: PUSH
86097: LD_VAR 0 2
86101: NOT
86102: OR
86103: IFFALSE 86107
// exit ;
86105: GO 86414
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86107: LD_ADDR_VAR 0 10
86111: PUSH
86112: LD_INT 5
86114: PUSH
86115: LD_INT 6
86117: PUSH
86118: EMPTY
86119: LIST
86120: LIST
86121: PUSH
86122: LD_INT 2
86124: PUSH
86125: LD_INT 4
86127: PUSH
86128: EMPTY
86129: LIST
86130: LIST
86131: PUSH
86132: LD_INT 3
86134: PUSH
86135: LD_INT 5
86137: PUSH
86138: EMPTY
86139: LIST
86140: LIST
86141: PUSH
86142: EMPTY
86143: LIST
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 24
86149: PUSH
86150: LD_INT 25
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 23
86159: PUSH
86160: LD_INT 27
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: PUSH
86167: EMPTY
86168: LIST
86169: LIST
86170: PUSH
86171: LD_INT 42
86173: PUSH
86174: LD_INT 43
86176: PUSH
86177: EMPTY
86178: LIST
86179: LIST
86180: PUSH
86181: LD_INT 44
86183: PUSH
86184: LD_INT 46
86186: PUSH
86187: EMPTY
86188: LIST
86189: LIST
86190: PUSH
86191: LD_INT 45
86193: PUSH
86194: LD_INT 47
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: EMPTY
86202: LIST
86203: LIST
86204: LIST
86205: PUSH
86206: EMPTY
86207: LIST
86208: LIST
86209: LIST
86210: ST_TO_ADDR
// result := [ ] ;
86211: LD_ADDR_VAR 0 3
86215: PUSH
86216: EMPTY
86217: ST_TO_ADDR
// for i in turrets do
86218: LD_ADDR_VAR 0 4
86222: PUSH
86223: LD_VAR 0 1
86227: PUSH
86228: FOR_IN
86229: IFFALSE 86412
// begin nat := GetNation ( i ) ;
86231: LD_ADDR_VAR 0 7
86235: PUSH
86236: LD_VAR 0 4
86240: PPUSH
86241: CALL_OW 248
86245: ST_TO_ADDR
// weapon := 0 ;
86246: LD_ADDR_VAR 0 8
86250: PUSH
86251: LD_INT 0
86253: ST_TO_ADDR
// if not nat then
86254: LD_VAR 0 7
86258: NOT
86259: IFFALSE 86263
// continue ;
86261: GO 86228
// for j in list [ nat ] do
86263: LD_ADDR_VAR 0 5
86267: PUSH
86268: LD_VAR 0 10
86272: PUSH
86273: LD_VAR 0 7
86277: ARRAY
86278: PUSH
86279: FOR_IN
86280: IFFALSE 86321
// if GetBWeapon ( i ) = j [ 1 ] then
86282: LD_VAR 0 4
86286: PPUSH
86287: CALL_OW 269
86291: PUSH
86292: LD_VAR 0 5
86296: PUSH
86297: LD_INT 1
86299: ARRAY
86300: EQUAL
86301: IFFALSE 86319
// begin weapon := j [ 2 ] ;
86303: LD_ADDR_VAR 0 8
86307: PUSH
86308: LD_VAR 0 5
86312: PUSH
86313: LD_INT 2
86315: ARRAY
86316: ST_TO_ADDR
// break ;
86317: GO 86321
// end ;
86319: GO 86279
86321: POP
86322: POP
// if not weapon then
86323: LD_VAR 0 8
86327: NOT
86328: IFFALSE 86332
// continue ;
86330: GO 86228
// for k in factories do
86332: LD_ADDR_VAR 0 6
86336: PUSH
86337: LD_VAR 0 2
86341: PUSH
86342: FOR_IN
86343: IFFALSE 86408
// begin weapons := AvailableWeaponList ( k ) ;
86345: LD_ADDR_VAR 0 9
86349: PUSH
86350: LD_VAR 0 6
86354: PPUSH
86355: CALL_OW 478
86359: ST_TO_ADDR
// if not weapons then
86360: LD_VAR 0 9
86364: NOT
86365: IFFALSE 86369
// continue ;
86367: GO 86342
// if weapon in weapons then
86369: LD_VAR 0 8
86373: PUSH
86374: LD_VAR 0 9
86378: IN
86379: IFFALSE 86406
// begin result := [ i , weapon ] ;
86381: LD_ADDR_VAR 0 3
86385: PUSH
86386: LD_VAR 0 4
86390: PUSH
86391: LD_VAR 0 8
86395: PUSH
86396: EMPTY
86397: LIST
86398: LIST
86399: ST_TO_ADDR
// exit ;
86400: POP
86401: POP
86402: POP
86403: POP
86404: GO 86414
// end ; end ;
86406: GO 86342
86408: POP
86409: POP
// end ;
86410: GO 86228
86412: POP
86413: POP
// end ;
86414: LD_VAR 0 3
86418: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86419: LD_INT 0
86421: PPUSH
// if not side or side > 8 then
86422: LD_VAR 0 3
86426: NOT
86427: PUSH
86428: LD_VAR 0 3
86432: PUSH
86433: LD_INT 8
86435: GREATER
86436: OR
86437: IFFALSE 86441
// exit ;
86439: GO 86500
// if not range then
86441: LD_VAR 0 4
86445: NOT
86446: IFFALSE 86457
// range := - 12 ;
86448: LD_ADDR_VAR 0 4
86452: PUSH
86453: LD_INT 12
86455: NEG
86456: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86457: LD_VAR 0 1
86461: PPUSH
86462: LD_VAR 0 2
86466: PPUSH
86467: LD_VAR 0 3
86471: PPUSH
86472: LD_VAR 0 4
86476: PPUSH
86477: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86481: LD_VAR 0 1
86485: PPUSH
86486: LD_VAR 0 2
86490: PPUSH
86491: LD_VAR 0 3
86495: PPUSH
86496: CALL_OW 331
// end ;
86500: LD_VAR 0 5
86504: RET
// export function Video ( mode ) ; begin
86505: LD_INT 0
86507: PPUSH
// ingame_video = mode ;
86508: LD_ADDR_OWVAR 52
86512: PUSH
86513: LD_VAR 0 1
86517: ST_TO_ADDR
// interface_hidden = mode ;
86518: LD_ADDR_OWVAR 54
86522: PUSH
86523: LD_VAR 0 1
86527: ST_TO_ADDR
// end ;
86528: LD_VAR 0 2
86532: RET
// export function Join ( array , element ) ; begin
86533: LD_INT 0
86535: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86536: LD_ADDR_VAR 0 3
86540: PUSH
86541: LD_VAR 0 1
86545: PPUSH
86546: LD_VAR 0 1
86550: PUSH
86551: LD_INT 1
86553: PLUS
86554: PPUSH
86555: LD_VAR 0 2
86559: PPUSH
86560: CALL_OW 1
86564: ST_TO_ADDR
// end ;
86565: LD_VAR 0 3
86569: RET
// export function JoinUnion ( array , element ) ; begin
86570: LD_INT 0
86572: PPUSH
// result := array union element ;
86573: LD_ADDR_VAR 0 3
86577: PUSH
86578: LD_VAR 0 1
86582: PUSH
86583: LD_VAR 0 2
86587: UNION
86588: ST_TO_ADDR
// end ;
86589: LD_VAR 0 3
86593: RET
// export function GetBehemoths ( side ) ; begin
86594: LD_INT 0
86596: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
86597: LD_ADDR_VAR 0 2
86601: PUSH
86602: LD_INT 22
86604: PUSH
86605: LD_VAR 0 1
86609: PUSH
86610: EMPTY
86611: LIST
86612: LIST
86613: PUSH
86614: LD_INT 31
86616: PUSH
86617: LD_INT 25
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: EMPTY
86625: LIST
86626: LIST
86627: PPUSH
86628: CALL_OW 69
86632: ST_TO_ADDR
// end ;
86633: LD_VAR 0 2
86637: RET
// export function Shuffle ( array ) ; var i , index ; begin
86638: LD_INT 0
86640: PPUSH
86641: PPUSH
86642: PPUSH
// result := [ ] ;
86643: LD_ADDR_VAR 0 2
86647: PUSH
86648: EMPTY
86649: ST_TO_ADDR
// if not array then
86650: LD_VAR 0 1
86654: NOT
86655: IFFALSE 86659
// exit ;
86657: GO 86758
// Randomize ;
86659: CALL_OW 10
// for i = array downto 1 do
86663: LD_ADDR_VAR 0 3
86667: PUSH
86668: DOUBLE
86669: LD_VAR 0 1
86673: INC
86674: ST_TO_ADDR
86675: LD_INT 1
86677: PUSH
86678: FOR_DOWNTO
86679: IFFALSE 86756
// begin index := rand ( 1 , array ) ;
86681: LD_ADDR_VAR 0 4
86685: PUSH
86686: LD_INT 1
86688: PPUSH
86689: LD_VAR 0 1
86693: PPUSH
86694: CALL_OW 12
86698: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86699: LD_ADDR_VAR 0 2
86703: PUSH
86704: LD_VAR 0 2
86708: PPUSH
86709: LD_VAR 0 2
86713: PUSH
86714: LD_INT 1
86716: PLUS
86717: PPUSH
86718: LD_VAR 0 1
86722: PUSH
86723: LD_VAR 0 4
86727: ARRAY
86728: PPUSH
86729: CALL_OW 2
86733: ST_TO_ADDR
// array := Delete ( array , index ) ;
86734: LD_ADDR_VAR 0 1
86738: PUSH
86739: LD_VAR 0 1
86743: PPUSH
86744: LD_VAR 0 4
86748: PPUSH
86749: CALL_OW 3
86753: ST_TO_ADDR
// end ;
86754: GO 86678
86756: POP
86757: POP
// end ;
86758: LD_VAR 0 2
86762: RET
// export function GetBaseMaterials ( base ) ; begin
86763: LD_INT 0
86765: PPUSH
// result := [ 0 , 0 , 0 ] ;
86766: LD_ADDR_VAR 0 2
86770: PUSH
86771: LD_INT 0
86773: PUSH
86774: LD_INT 0
86776: PUSH
86777: LD_INT 0
86779: PUSH
86780: EMPTY
86781: LIST
86782: LIST
86783: LIST
86784: ST_TO_ADDR
// if not base then
86785: LD_VAR 0 1
86789: NOT
86790: IFFALSE 86794
// exit ;
86792: GO 86843
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86794: LD_ADDR_VAR 0 2
86798: PUSH
86799: LD_VAR 0 1
86803: PPUSH
86804: LD_INT 1
86806: PPUSH
86807: CALL_OW 275
86811: PUSH
86812: LD_VAR 0 1
86816: PPUSH
86817: LD_INT 2
86819: PPUSH
86820: CALL_OW 275
86824: PUSH
86825: LD_VAR 0 1
86829: PPUSH
86830: LD_INT 3
86832: PPUSH
86833: CALL_OW 275
86837: PUSH
86838: EMPTY
86839: LIST
86840: LIST
86841: LIST
86842: ST_TO_ADDR
// end ;
86843: LD_VAR 0 2
86847: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86848: LD_INT 0
86850: PPUSH
86851: PPUSH
// result := array ;
86852: LD_ADDR_VAR 0 3
86856: PUSH
86857: LD_VAR 0 1
86861: ST_TO_ADDR
// if size > 0 then
86862: LD_VAR 0 2
86866: PUSH
86867: LD_INT 0
86869: GREATER
86870: IFFALSE 86916
// for i := array downto size do
86872: LD_ADDR_VAR 0 4
86876: PUSH
86877: DOUBLE
86878: LD_VAR 0 1
86882: INC
86883: ST_TO_ADDR
86884: LD_VAR 0 2
86888: PUSH
86889: FOR_DOWNTO
86890: IFFALSE 86914
// result := Delete ( result , result ) ;
86892: LD_ADDR_VAR 0 3
86896: PUSH
86897: LD_VAR 0 3
86901: PPUSH
86902: LD_VAR 0 3
86906: PPUSH
86907: CALL_OW 3
86911: ST_TO_ADDR
86912: GO 86889
86914: POP
86915: POP
// end ;
86916: LD_VAR 0 3
86920: RET
// export function ComExit ( unit ) ; var tmp ; begin
86921: LD_INT 0
86923: PPUSH
86924: PPUSH
// if not IsInUnit ( unit ) then
86925: LD_VAR 0 1
86929: PPUSH
86930: CALL_OW 310
86934: NOT
86935: IFFALSE 86939
// exit ;
86937: GO 86999
// tmp := IsInUnit ( unit ) ;
86939: LD_ADDR_VAR 0 3
86943: PUSH
86944: LD_VAR 0 1
86948: PPUSH
86949: CALL_OW 310
86953: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86954: LD_VAR 0 3
86958: PPUSH
86959: CALL_OW 247
86963: PUSH
86964: LD_INT 2
86966: EQUAL
86967: IFFALSE 86980
// ComExitVehicle ( unit ) else
86969: LD_VAR 0 1
86973: PPUSH
86974: CALL_OW 121
86978: GO 86989
// ComExitBuilding ( unit ) ;
86980: LD_VAR 0 1
86984: PPUSH
86985: CALL_OW 122
// result := tmp ;
86989: LD_ADDR_VAR 0 2
86993: PUSH
86994: LD_VAR 0 3
86998: ST_TO_ADDR
// end ;
86999: LD_VAR 0 2
87003: RET
// export function ResetHc ; begin
87004: LD_INT 0
87006: PPUSH
// InitHc ;
87007: CALL_OW 19
// hc_importance := 0 ;
87011: LD_ADDR_OWVAR 32
87015: PUSH
87016: LD_INT 0
87018: ST_TO_ADDR
// end ; end_of_file end_of_file
87019: LD_VAR 0 1
87023: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
87024: GO 87026
87026: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
87027: LD_STRING initStreamRollete();
87029: PPUSH
87030: CALL_OW 559
// InitStreamMode ;
87034: CALL 87043 0 0
// DefineStreamItems ( ) ;
87038: CALL 87483 0 0
// end ;
87042: END
// function InitStreamMode ; begin
87043: LD_INT 0
87045: PPUSH
// streamModeActive := false ;
87046: LD_ADDR_EXP 131
87050: PUSH
87051: LD_INT 0
87053: ST_TO_ADDR
// normalCounter := 36 ;
87054: LD_ADDR_EXP 132
87058: PUSH
87059: LD_INT 36
87061: ST_TO_ADDR
// hardcoreCounter := 16 ;
87062: LD_ADDR_EXP 133
87066: PUSH
87067: LD_INT 16
87069: ST_TO_ADDR
// sRocket := false ;
87070: LD_ADDR_EXP 136
87074: PUSH
87075: LD_INT 0
87077: ST_TO_ADDR
// sSpeed := false ;
87078: LD_ADDR_EXP 135
87082: PUSH
87083: LD_INT 0
87085: ST_TO_ADDR
// sEngine := false ;
87086: LD_ADDR_EXP 137
87090: PUSH
87091: LD_INT 0
87093: ST_TO_ADDR
// sSpec := false ;
87094: LD_ADDR_EXP 134
87098: PUSH
87099: LD_INT 0
87101: ST_TO_ADDR
// sLevel := false ;
87102: LD_ADDR_EXP 138
87106: PUSH
87107: LD_INT 0
87109: ST_TO_ADDR
// sArmoury := false ;
87110: LD_ADDR_EXP 139
87114: PUSH
87115: LD_INT 0
87117: ST_TO_ADDR
// sRadar := false ;
87118: LD_ADDR_EXP 140
87122: PUSH
87123: LD_INT 0
87125: ST_TO_ADDR
// sBunker := false ;
87126: LD_ADDR_EXP 141
87130: PUSH
87131: LD_INT 0
87133: ST_TO_ADDR
// sHack := false ;
87134: LD_ADDR_EXP 142
87138: PUSH
87139: LD_INT 0
87141: ST_TO_ADDR
// sFire := false ;
87142: LD_ADDR_EXP 143
87146: PUSH
87147: LD_INT 0
87149: ST_TO_ADDR
// sRefresh := false ;
87150: LD_ADDR_EXP 144
87154: PUSH
87155: LD_INT 0
87157: ST_TO_ADDR
// sExp := false ;
87158: LD_ADDR_EXP 145
87162: PUSH
87163: LD_INT 0
87165: ST_TO_ADDR
// sDepot := false ;
87166: LD_ADDR_EXP 146
87170: PUSH
87171: LD_INT 0
87173: ST_TO_ADDR
// sFlag := false ;
87174: LD_ADDR_EXP 147
87178: PUSH
87179: LD_INT 0
87181: ST_TO_ADDR
// sKamikadze := false ;
87182: LD_ADDR_EXP 155
87186: PUSH
87187: LD_INT 0
87189: ST_TO_ADDR
// sTroll := false ;
87190: LD_ADDR_EXP 156
87194: PUSH
87195: LD_INT 0
87197: ST_TO_ADDR
// sSlow := false ;
87198: LD_ADDR_EXP 157
87202: PUSH
87203: LD_INT 0
87205: ST_TO_ADDR
// sLack := false ;
87206: LD_ADDR_EXP 158
87210: PUSH
87211: LD_INT 0
87213: ST_TO_ADDR
// sTank := false ;
87214: LD_ADDR_EXP 160
87218: PUSH
87219: LD_INT 0
87221: ST_TO_ADDR
// sRemote := false ;
87222: LD_ADDR_EXP 161
87226: PUSH
87227: LD_INT 0
87229: ST_TO_ADDR
// sPowell := false ;
87230: LD_ADDR_EXP 162
87234: PUSH
87235: LD_INT 0
87237: ST_TO_ADDR
// sTeleport := false ;
87238: LD_ADDR_EXP 165
87242: PUSH
87243: LD_INT 0
87245: ST_TO_ADDR
// sOilTower := false ;
87246: LD_ADDR_EXP 167
87250: PUSH
87251: LD_INT 0
87253: ST_TO_ADDR
// sShovel := false ;
87254: LD_ADDR_EXP 168
87258: PUSH
87259: LD_INT 0
87261: ST_TO_ADDR
// sSheik := false ;
87262: LD_ADDR_EXP 169
87266: PUSH
87267: LD_INT 0
87269: ST_TO_ADDR
// sEarthquake := false ;
87270: LD_ADDR_EXP 171
87274: PUSH
87275: LD_INT 0
87277: ST_TO_ADDR
// sAI := false ;
87278: LD_ADDR_EXP 172
87282: PUSH
87283: LD_INT 0
87285: ST_TO_ADDR
// sCargo := false ;
87286: LD_ADDR_EXP 175
87290: PUSH
87291: LD_INT 0
87293: ST_TO_ADDR
// sDLaser := false ;
87294: LD_ADDR_EXP 176
87298: PUSH
87299: LD_INT 0
87301: ST_TO_ADDR
// sExchange := false ;
87302: LD_ADDR_EXP 177
87306: PUSH
87307: LD_INT 0
87309: ST_TO_ADDR
// sFac := false ;
87310: LD_ADDR_EXP 178
87314: PUSH
87315: LD_INT 0
87317: ST_TO_ADDR
// sPower := false ;
87318: LD_ADDR_EXP 179
87322: PUSH
87323: LD_INT 0
87325: ST_TO_ADDR
// sRandom := false ;
87326: LD_ADDR_EXP 180
87330: PUSH
87331: LD_INT 0
87333: ST_TO_ADDR
// sShield := false ;
87334: LD_ADDR_EXP 181
87338: PUSH
87339: LD_INT 0
87341: ST_TO_ADDR
// sTime := false ;
87342: LD_ADDR_EXP 182
87346: PUSH
87347: LD_INT 0
87349: ST_TO_ADDR
// sTools := false ;
87350: LD_ADDR_EXP 183
87354: PUSH
87355: LD_INT 0
87357: ST_TO_ADDR
// sSold := false ;
87358: LD_ADDR_EXP 148
87362: PUSH
87363: LD_INT 0
87365: ST_TO_ADDR
// sDiff := false ;
87366: LD_ADDR_EXP 149
87370: PUSH
87371: LD_INT 0
87373: ST_TO_ADDR
// sFog := false ;
87374: LD_ADDR_EXP 152
87378: PUSH
87379: LD_INT 0
87381: ST_TO_ADDR
// sReset := false ;
87382: LD_ADDR_EXP 153
87386: PUSH
87387: LD_INT 0
87389: ST_TO_ADDR
// sSun := false ;
87390: LD_ADDR_EXP 154
87394: PUSH
87395: LD_INT 0
87397: ST_TO_ADDR
// sTiger := false ;
87398: LD_ADDR_EXP 150
87402: PUSH
87403: LD_INT 0
87405: ST_TO_ADDR
// sBomb := false ;
87406: LD_ADDR_EXP 151
87410: PUSH
87411: LD_INT 0
87413: ST_TO_ADDR
// sWound := false ;
87414: LD_ADDR_EXP 159
87418: PUSH
87419: LD_INT 0
87421: ST_TO_ADDR
// sBetray := false ;
87422: LD_ADDR_EXP 163
87426: PUSH
87427: LD_INT 0
87429: ST_TO_ADDR
// sContamin := false ;
87430: LD_ADDR_EXP 164
87434: PUSH
87435: LD_INT 0
87437: ST_TO_ADDR
// sOil := false ;
87438: LD_ADDR_EXP 166
87442: PUSH
87443: LD_INT 0
87445: ST_TO_ADDR
// sStu := false ;
87446: LD_ADDR_EXP 170
87450: PUSH
87451: LD_INT 0
87453: ST_TO_ADDR
// sBazooka := false ;
87454: LD_ADDR_EXP 173
87458: PUSH
87459: LD_INT 0
87461: ST_TO_ADDR
// sMortar := false ;
87462: LD_ADDR_EXP 174
87466: PUSH
87467: LD_INT 0
87469: ST_TO_ADDR
// sRanger := false ;
87470: LD_ADDR_EXP 184
87474: PUSH
87475: LD_INT 0
87477: ST_TO_ADDR
// end ;
87478: LD_VAR 0 1
87482: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
87483: LD_INT 0
87485: PPUSH
87486: PPUSH
87487: PPUSH
87488: PPUSH
87489: PPUSH
// result := [ ] ;
87490: LD_ADDR_VAR 0 1
87494: PUSH
87495: EMPTY
87496: ST_TO_ADDR
// if campaign_id = 1 then
87497: LD_OWVAR 69
87501: PUSH
87502: LD_INT 1
87504: EQUAL
87505: IFFALSE 90443
// begin case mission_number of 1 :
87507: LD_OWVAR 70
87511: PUSH
87512: LD_INT 1
87514: DOUBLE
87515: EQUAL
87516: IFTRUE 87520
87518: GO 87584
87520: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
87521: LD_ADDR_VAR 0 1
87525: PUSH
87526: LD_INT 2
87528: PUSH
87529: LD_INT 4
87531: PUSH
87532: LD_INT 11
87534: PUSH
87535: LD_INT 12
87537: PUSH
87538: LD_INT 15
87540: PUSH
87541: LD_INT 16
87543: PUSH
87544: LD_INT 22
87546: PUSH
87547: LD_INT 23
87549: PUSH
87550: LD_INT 26
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: PUSH
87564: LD_INT 101
87566: PUSH
87567: LD_INT 102
87569: PUSH
87570: LD_INT 106
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: LIST
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: ST_TO_ADDR
87582: GO 90441
87584: LD_INT 2
87586: DOUBLE
87587: EQUAL
87588: IFTRUE 87592
87590: GO 87664
87592: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
87593: LD_ADDR_VAR 0 1
87597: PUSH
87598: LD_INT 2
87600: PUSH
87601: LD_INT 4
87603: PUSH
87604: LD_INT 11
87606: PUSH
87607: LD_INT 12
87609: PUSH
87610: LD_INT 15
87612: PUSH
87613: LD_INT 16
87615: PUSH
87616: LD_INT 22
87618: PUSH
87619: LD_INT 23
87621: PUSH
87622: LD_INT 26
87624: PUSH
87625: EMPTY
87626: LIST
87627: LIST
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: LIST
87634: LIST
87635: PUSH
87636: LD_INT 101
87638: PUSH
87639: LD_INT 102
87641: PUSH
87642: LD_INT 105
87644: PUSH
87645: LD_INT 106
87647: PUSH
87648: LD_INT 108
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: LIST
87655: LIST
87656: LIST
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: ST_TO_ADDR
87662: GO 90441
87664: LD_INT 3
87666: DOUBLE
87667: EQUAL
87668: IFTRUE 87672
87670: GO 87748
87672: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
87673: LD_ADDR_VAR 0 1
87677: PUSH
87678: LD_INT 2
87680: PUSH
87681: LD_INT 4
87683: PUSH
87684: LD_INT 5
87686: PUSH
87687: LD_INT 11
87689: PUSH
87690: LD_INT 12
87692: PUSH
87693: LD_INT 15
87695: PUSH
87696: LD_INT 16
87698: PUSH
87699: LD_INT 22
87701: PUSH
87702: LD_INT 26
87704: PUSH
87705: LD_INT 36
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: LIST
87712: LIST
87713: LIST
87714: LIST
87715: LIST
87716: LIST
87717: LIST
87718: LIST
87719: PUSH
87720: LD_INT 101
87722: PUSH
87723: LD_INT 102
87725: PUSH
87726: LD_INT 105
87728: PUSH
87729: LD_INT 106
87731: PUSH
87732: LD_INT 108
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: ST_TO_ADDR
87746: GO 90441
87748: LD_INT 4
87750: DOUBLE
87751: EQUAL
87752: IFTRUE 87756
87754: GO 87840
87756: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
87757: LD_ADDR_VAR 0 1
87761: PUSH
87762: LD_INT 2
87764: PUSH
87765: LD_INT 4
87767: PUSH
87768: LD_INT 5
87770: PUSH
87771: LD_INT 8
87773: PUSH
87774: LD_INT 11
87776: PUSH
87777: LD_INT 12
87779: PUSH
87780: LD_INT 15
87782: PUSH
87783: LD_INT 16
87785: PUSH
87786: LD_INT 22
87788: PUSH
87789: LD_INT 23
87791: PUSH
87792: LD_INT 26
87794: PUSH
87795: LD_INT 36
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: PUSH
87812: LD_INT 101
87814: PUSH
87815: LD_INT 102
87817: PUSH
87818: LD_INT 105
87820: PUSH
87821: LD_INT 106
87823: PUSH
87824: LD_INT 108
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: ST_TO_ADDR
87838: GO 90441
87840: LD_INT 5
87842: DOUBLE
87843: EQUAL
87844: IFTRUE 87848
87846: GO 87948
87848: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
87849: LD_ADDR_VAR 0 1
87853: PUSH
87854: LD_INT 2
87856: PUSH
87857: LD_INT 4
87859: PUSH
87860: LD_INT 5
87862: PUSH
87863: LD_INT 6
87865: PUSH
87866: LD_INT 8
87868: PUSH
87869: LD_INT 11
87871: PUSH
87872: LD_INT 12
87874: PUSH
87875: LD_INT 15
87877: PUSH
87878: LD_INT 16
87880: PUSH
87881: LD_INT 22
87883: PUSH
87884: LD_INT 23
87886: PUSH
87887: LD_INT 25
87889: PUSH
87890: LD_INT 26
87892: PUSH
87893: LD_INT 36
87895: PUSH
87896: EMPTY
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: LIST
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 101
87914: PUSH
87915: LD_INT 102
87917: PUSH
87918: LD_INT 105
87920: PUSH
87921: LD_INT 106
87923: PUSH
87924: LD_INT 108
87926: PUSH
87927: LD_INT 109
87929: PUSH
87930: LD_INT 112
87932: PUSH
87933: EMPTY
87934: LIST
87935: LIST
87936: LIST
87937: LIST
87938: LIST
87939: LIST
87940: LIST
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: ST_TO_ADDR
87946: GO 90441
87948: LD_INT 6
87950: DOUBLE
87951: EQUAL
87952: IFTRUE 87956
87954: GO 88076
87956: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
87957: LD_ADDR_VAR 0 1
87961: PUSH
87962: LD_INT 2
87964: PUSH
87965: LD_INT 4
87967: PUSH
87968: LD_INT 5
87970: PUSH
87971: LD_INT 6
87973: PUSH
87974: LD_INT 8
87976: PUSH
87977: LD_INT 11
87979: PUSH
87980: LD_INT 12
87982: PUSH
87983: LD_INT 15
87985: PUSH
87986: LD_INT 16
87988: PUSH
87989: LD_INT 20
87991: PUSH
87992: LD_INT 21
87994: PUSH
87995: LD_INT 22
87997: PUSH
87998: LD_INT 23
88000: PUSH
88001: LD_INT 25
88003: PUSH
88004: LD_INT 26
88006: PUSH
88007: LD_INT 30
88009: PUSH
88010: LD_INT 31
88012: PUSH
88013: LD_INT 32
88015: PUSH
88016: LD_INT 36
88018: PUSH
88019: EMPTY
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: PUSH
88040: LD_INT 101
88042: PUSH
88043: LD_INT 102
88045: PUSH
88046: LD_INT 105
88048: PUSH
88049: LD_INT 106
88051: PUSH
88052: LD_INT 108
88054: PUSH
88055: LD_INT 109
88057: PUSH
88058: LD_INT 112
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: LIST
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: ST_TO_ADDR
88074: GO 90441
88076: LD_INT 7
88078: DOUBLE
88079: EQUAL
88080: IFTRUE 88084
88082: GO 88184
88084: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
88085: LD_ADDR_VAR 0 1
88089: PUSH
88090: LD_INT 2
88092: PUSH
88093: LD_INT 4
88095: PUSH
88096: LD_INT 5
88098: PUSH
88099: LD_INT 7
88101: PUSH
88102: LD_INT 11
88104: PUSH
88105: LD_INT 12
88107: PUSH
88108: LD_INT 15
88110: PUSH
88111: LD_INT 16
88113: PUSH
88114: LD_INT 20
88116: PUSH
88117: LD_INT 21
88119: PUSH
88120: LD_INT 22
88122: PUSH
88123: LD_INT 23
88125: PUSH
88126: LD_INT 25
88128: PUSH
88129: LD_INT 26
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: PUSH
88148: LD_INT 101
88150: PUSH
88151: LD_INT 102
88153: PUSH
88154: LD_INT 103
88156: PUSH
88157: LD_INT 105
88159: PUSH
88160: LD_INT 106
88162: PUSH
88163: LD_INT 108
88165: PUSH
88166: LD_INT 112
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: PUSH
88178: EMPTY
88179: LIST
88180: LIST
88181: ST_TO_ADDR
88182: GO 90441
88184: LD_INT 8
88186: DOUBLE
88187: EQUAL
88188: IFTRUE 88192
88190: GO 88320
88192: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
88193: LD_ADDR_VAR 0 1
88197: PUSH
88198: LD_INT 2
88200: PUSH
88201: LD_INT 4
88203: PUSH
88204: LD_INT 5
88206: PUSH
88207: LD_INT 6
88209: PUSH
88210: LD_INT 7
88212: PUSH
88213: LD_INT 8
88215: PUSH
88216: LD_INT 11
88218: PUSH
88219: LD_INT 12
88221: PUSH
88222: LD_INT 15
88224: PUSH
88225: LD_INT 16
88227: PUSH
88228: LD_INT 20
88230: PUSH
88231: LD_INT 21
88233: PUSH
88234: LD_INT 22
88236: PUSH
88237: LD_INT 23
88239: PUSH
88240: LD_INT 25
88242: PUSH
88243: LD_INT 26
88245: PUSH
88246: LD_INT 30
88248: PUSH
88249: LD_INT 31
88251: PUSH
88252: LD_INT 32
88254: PUSH
88255: LD_INT 36
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: LIST
88262: LIST
88263: LIST
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 101
88282: PUSH
88283: LD_INT 102
88285: PUSH
88286: LD_INT 103
88288: PUSH
88289: LD_INT 105
88291: PUSH
88292: LD_INT 106
88294: PUSH
88295: LD_INT 108
88297: PUSH
88298: LD_INT 109
88300: PUSH
88301: LD_INT 112
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: PUSH
88314: EMPTY
88315: LIST
88316: LIST
88317: ST_TO_ADDR
88318: GO 90441
88320: LD_INT 9
88322: DOUBLE
88323: EQUAL
88324: IFTRUE 88328
88326: GO 88464
88328: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
88329: LD_ADDR_VAR 0 1
88333: PUSH
88334: LD_INT 2
88336: PUSH
88337: LD_INT 4
88339: PUSH
88340: LD_INT 5
88342: PUSH
88343: LD_INT 6
88345: PUSH
88346: LD_INT 7
88348: PUSH
88349: LD_INT 8
88351: PUSH
88352: LD_INT 11
88354: PUSH
88355: LD_INT 12
88357: PUSH
88358: LD_INT 15
88360: PUSH
88361: LD_INT 16
88363: PUSH
88364: LD_INT 20
88366: PUSH
88367: LD_INT 21
88369: PUSH
88370: LD_INT 22
88372: PUSH
88373: LD_INT 23
88375: PUSH
88376: LD_INT 25
88378: PUSH
88379: LD_INT 26
88381: PUSH
88382: LD_INT 28
88384: PUSH
88385: LD_INT 30
88387: PUSH
88388: LD_INT 31
88390: PUSH
88391: LD_INT 32
88393: PUSH
88394: LD_INT 36
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: LIST
88418: LIST
88419: PUSH
88420: LD_INT 101
88422: PUSH
88423: LD_INT 102
88425: PUSH
88426: LD_INT 103
88428: PUSH
88429: LD_INT 105
88431: PUSH
88432: LD_INT 106
88434: PUSH
88435: LD_INT 108
88437: PUSH
88438: LD_INT 109
88440: PUSH
88441: LD_INT 112
88443: PUSH
88444: LD_INT 114
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: ST_TO_ADDR
88462: GO 90441
88464: LD_INT 10
88466: DOUBLE
88467: EQUAL
88468: IFTRUE 88472
88470: GO 88656
88472: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
88473: LD_ADDR_VAR 0 1
88477: PUSH
88478: LD_INT 2
88480: PUSH
88481: LD_INT 4
88483: PUSH
88484: LD_INT 5
88486: PUSH
88487: LD_INT 6
88489: PUSH
88490: LD_INT 7
88492: PUSH
88493: LD_INT 8
88495: PUSH
88496: LD_INT 9
88498: PUSH
88499: LD_INT 10
88501: PUSH
88502: LD_INT 11
88504: PUSH
88505: LD_INT 12
88507: PUSH
88508: LD_INT 13
88510: PUSH
88511: LD_INT 14
88513: PUSH
88514: LD_INT 15
88516: PUSH
88517: LD_INT 16
88519: PUSH
88520: LD_INT 17
88522: PUSH
88523: LD_INT 18
88525: PUSH
88526: LD_INT 19
88528: PUSH
88529: LD_INT 20
88531: PUSH
88532: LD_INT 21
88534: PUSH
88535: LD_INT 22
88537: PUSH
88538: LD_INT 23
88540: PUSH
88541: LD_INT 24
88543: PUSH
88544: LD_INT 25
88546: PUSH
88547: LD_INT 26
88549: PUSH
88550: LD_INT 28
88552: PUSH
88553: LD_INT 30
88555: PUSH
88556: LD_INT 31
88558: PUSH
88559: LD_INT 32
88561: PUSH
88562: LD_INT 36
88564: PUSH
88565: EMPTY
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 101
88598: PUSH
88599: LD_INT 102
88601: PUSH
88602: LD_INT 103
88604: PUSH
88605: LD_INT 104
88607: PUSH
88608: LD_INT 105
88610: PUSH
88611: LD_INT 106
88613: PUSH
88614: LD_INT 107
88616: PUSH
88617: LD_INT 108
88619: PUSH
88620: LD_INT 109
88622: PUSH
88623: LD_INT 110
88625: PUSH
88626: LD_INT 111
88628: PUSH
88629: LD_INT 112
88631: PUSH
88632: LD_INT 114
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: ST_TO_ADDR
88654: GO 90441
88656: LD_INT 11
88658: DOUBLE
88659: EQUAL
88660: IFTRUE 88664
88662: GO 88856
88664: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
88665: LD_ADDR_VAR 0 1
88669: PUSH
88670: LD_INT 2
88672: PUSH
88673: LD_INT 3
88675: PUSH
88676: LD_INT 4
88678: PUSH
88679: LD_INT 5
88681: PUSH
88682: LD_INT 6
88684: PUSH
88685: LD_INT 7
88687: PUSH
88688: LD_INT 8
88690: PUSH
88691: LD_INT 9
88693: PUSH
88694: LD_INT 10
88696: PUSH
88697: LD_INT 11
88699: PUSH
88700: LD_INT 12
88702: PUSH
88703: LD_INT 13
88705: PUSH
88706: LD_INT 14
88708: PUSH
88709: LD_INT 15
88711: PUSH
88712: LD_INT 16
88714: PUSH
88715: LD_INT 17
88717: PUSH
88718: LD_INT 18
88720: PUSH
88721: LD_INT 19
88723: PUSH
88724: LD_INT 20
88726: PUSH
88727: LD_INT 21
88729: PUSH
88730: LD_INT 22
88732: PUSH
88733: LD_INT 23
88735: PUSH
88736: LD_INT 24
88738: PUSH
88739: LD_INT 25
88741: PUSH
88742: LD_INT 26
88744: PUSH
88745: LD_INT 28
88747: PUSH
88748: LD_INT 30
88750: PUSH
88751: LD_INT 31
88753: PUSH
88754: LD_INT 32
88756: PUSH
88757: LD_INT 34
88759: PUSH
88760: LD_INT 36
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: LIST
88767: LIST
88768: LIST
88769: LIST
88770: LIST
88771: LIST
88772: LIST
88773: LIST
88774: LIST
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 101
88798: PUSH
88799: LD_INT 102
88801: PUSH
88802: LD_INT 103
88804: PUSH
88805: LD_INT 104
88807: PUSH
88808: LD_INT 105
88810: PUSH
88811: LD_INT 106
88813: PUSH
88814: LD_INT 107
88816: PUSH
88817: LD_INT 108
88819: PUSH
88820: LD_INT 109
88822: PUSH
88823: LD_INT 110
88825: PUSH
88826: LD_INT 111
88828: PUSH
88829: LD_INT 112
88831: PUSH
88832: LD_INT 114
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: ST_TO_ADDR
88854: GO 90441
88856: LD_INT 12
88858: DOUBLE
88859: EQUAL
88860: IFTRUE 88864
88862: GO 89072
88864: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
88865: LD_ADDR_VAR 0 1
88869: PUSH
88870: LD_INT 1
88872: PUSH
88873: LD_INT 2
88875: PUSH
88876: LD_INT 3
88878: PUSH
88879: LD_INT 4
88881: PUSH
88882: LD_INT 5
88884: PUSH
88885: LD_INT 6
88887: PUSH
88888: LD_INT 7
88890: PUSH
88891: LD_INT 8
88893: PUSH
88894: LD_INT 9
88896: PUSH
88897: LD_INT 10
88899: PUSH
88900: LD_INT 11
88902: PUSH
88903: LD_INT 12
88905: PUSH
88906: LD_INT 13
88908: PUSH
88909: LD_INT 14
88911: PUSH
88912: LD_INT 15
88914: PUSH
88915: LD_INT 16
88917: PUSH
88918: LD_INT 17
88920: PUSH
88921: LD_INT 18
88923: PUSH
88924: LD_INT 19
88926: PUSH
88927: LD_INT 20
88929: PUSH
88930: LD_INT 21
88932: PUSH
88933: LD_INT 22
88935: PUSH
88936: LD_INT 23
88938: PUSH
88939: LD_INT 24
88941: PUSH
88942: LD_INT 25
88944: PUSH
88945: LD_INT 26
88947: PUSH
88948: LD_INT 27
88950: PUSH
88951: LD_INT 28
88953: PUSH
88954: LD_INT 30
88956: PUSH
88957: LD_INT 31
88959: PUSH
88960: LD_INT 32
88962: PUSH
88963: LD_INT 33
88965: PUSH
88966: LD_INT 34
88968: PUSH
88969: LD_INT 36
88971: PUSH
88972: EMPTY
88973: LIST
88974: LIST
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: PUSH
89008: LD_INT 101
89010: PUSH
89011: LD_INT 102
89013: PUSH
89014: LD_INT 103
89016: PUSH
89017: LD_INT 104
89019: PUSH
89020: LD_INT 105
89022: PUSH
89023: LD_INT 106
89025: PUSH
89026: LD_INT 107
89028: PUSH
89029: LD_INT 108
89031: PUSH
89032: LD_INT 109
89034: PUSH
89035: LD_INT 110
89037: PUSH
89038: LD_INT 111
89040: PUSH
89041: LD_INT 112
89043: PUSH
89044: LD_INT 113
89046: PUSH
89047: LD_INT 114
89049: PUSH
89050: EMPTY
89051: LIST
89052: LIST
89053: LIST
89054: LIST
89055: LIST
89056: LIST
89057: LIST
89058: LIST
89059: LIST
89060: LIST
89061: LIST
89062: LIST
89063: LIST
89064: LIST
89065: PUSH
89066: EMPTY
89067: LIST
89068: LIST
89069: ST_TO_ADDR
89070: GO 90441
89072: LD_INT 13
89074: DOUBLE
89075: EQUAL
89076: IFTRUE 89080
89078: GO 89276
89080: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
89081: LD_ADDR_VAR 0 1
89085: PUSH
89086: LD_INT 1
89088: PUSH
89089: LD_INT 2
89091: PUSH
89092: LD_INT 3
89094: PUSH
89095: LD_INT 4
89097: PUSH
89098: LD_INT 5
89100: PUSH
89101: LD_INT 8
89103: PUSH
89104: LD_INT 9
89106: PUSH
89107: LD_INT 10
89109: PUSH
89110: LD_INT 11
89112: PUSH
89113: LD_INT 12
89115: PUSH
89116: LD_INT 14
89118: PUSH
89119: LD_INT 15
89121: PUSH
89122: LD_INT 16
89124: PUSH
89125: LD_INT 17
89127: PUSH
89128: LD_INT 18
89130: PUSH
89131: LD_INT 19
89133: PUSH
89134: LD_INT 20
89136: PUSH
89137: LD_INT 21
89139: PUSH
89140: LD_INT 22
89142: PUSH
89143: LD_INT 23
89145: PUSH
89146: LD_INT 24
89148: PUSH
89149: LD_INT 25
89151: PUSH
89152: LD_INT 26
89154: PUSH
89155: LD_INT 27
89157: PUSH
89158: LD_INT 28
89160: PUSH
89161: LD_INT 30
89163: PUSH
89164: LD_INT 31
89166: PUSH
89167: LD_INT 32
89169: PUSH
89170: LD_INT 33
89172: PUSH
89173: LD_INT 34
89175: PUSH
89176: LD_INT 36
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: LIST
89183: LIST
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 101
89214: PUSH
89215: LD_INT 102
89217: PUSH
89218: LD_INT 103
89220: PUSH
89221: LD_INT 104
89223: PUSH
89224: LD_INT 105
89226: PUSH
89227: LD_INT 106
89229: PUSH
89230: LD_INT 107
89232: PUSH
89233: LD_INT 108
89235: PUSH
89236: LD_INT 109
89238: PUSH
89239: LD_INT 110
89241: PUSH
89242: LD_INT 111
89244: PUSH
89245: LD_INT 112
89247: PUSH
89248: LD_INT 113
89250: PUSH
89251: LD_INT 114
89253: PUSH
89254: EMPTY
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: LIST
89265: LIST
89266: LIST
89267: LIST
89268: LIST
89269: PUSH
89270: EMPTY
89271: LIST
89272: LIST
89273: ST_TO_ADDR
89274: GO 90441
89276: LD_INT 14
89278: DOUBLE
89279: EQUAL
89280: IFTRUE 89284
89282: GO 89496
89284: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
89285: LD_ADDR_VAR 0 1
89289: PUSH
89290: LD_INT 1
89292: PUSH
89293: LD_INT 2
89295: PUSH
89296: LD_INT 3
89298: PUSH
89299: LD_INT 4
89301: PUSH
89302: LD_INT 5
89304: PUSH
89305: LD_INT 6
89307: PUSH
89308: LD_INT 7
89310: PUSH
89311: LD_INT 8
89313: PUSH
89314: LD_INT 9
89316: PUSH
89317: LD_INT 10
89319: PUSH
89320: LD_INT 11
89322: PUSH
89323: LD_INT 12
89325: PUSH
89326: LD_INT 13
89328: PUSH
89329: LD_INT 14
89331: PUSH
89332: LD_INT 15
89334: PUSH
89335: LD_INT 16
89337: PUSH
89338: LD_INT 17
89340: PUSH
89341: LD_INT 18
89343: PUSH
89344: LD_INT 19
89346: PUSH
89347: LD_INT 20
89349: PUSH
89350: LD_INT 21
89352: PUSH
89353: LD_INT 22
89355: PUSH
89356: LD_INT 23
89358: PUSH
89359: LD_INT 24
89361: PUSH
89362: LD_INT 25
89364: PUSH
89365: LD_INT 26
89367: PUSH
89368: LD_INT 27
89370: PUSH
89371: LD_INT 28
89373: PUSH
89374: LD_INT 29
89376: PUSH
89377: LD_INT 30
89379: PUSH
89380: LD_INT 31
89382: PUSH
89383: LD_INT 32
89385: PUSH
89386: LD_INT 33
89388: PUSH
89389: LD_INT 34
89391: PUSH
89392: LD_INT 36
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: PUSH
89432: LD_INT 101
89434: PUSH
89435: LD_INT 102
89437: PUSH
89438: LD_INT 103
89440: PUSH
89441: LD_INT 104
89443: PUSH
89444: LD_INT 105
89446: PUSH
89447: LD_INT 106
89449: PUSH
89450: LD_INT 107
89452: PUSH
89453: LD_INT 108
89455: PUSH
89456: LD_INT 109
89458: PUSH
89459: LD_INT 110
89461: PUSH
89462: LD_INT 111
89464: PUSH
89465: LD_INT 112
89467: PUSH
89468: LD_INT 113
89470: PUSH
89471: LD_INT 114
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: PUSH
89490: EMPTY
89491: LIST
89492: LIST
89493: ST_TO_ADDR
89494: GO 90441
89496: LD_INT 15
89498: DOUBLE
89499: EQUAL
89500: IFTRUE 89504
89502: GO 89716
89504: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
89505: LD_ADDR_VAR 0 1
89509: PUSH
89510: LD_INT 1
89512: PUSH
89513: LD_INT 2
89515: PUSH
89516: LD_INT 3
89518: PUSH
89519: LD_INT 4
89521: PUSH
89522: LD_INT 5
89524: PUSH
89525: LD_INT 6
89527: PUSH
89528: LD_INT 7
89530: PUSH
89531: LD_INT 8
89533: PUSH
89534: LD_INT 9
89536: PUSH
89537: LD_INT 10
89539: PUSH
89540: LD_INT 11
89542: PUSH
89543: LD_INT 12
89545: PUSH
89546: LD_INT 13
89548: PUSH
89549: LD_INT 14
89551: PUSH
89552: LD_INT 15
89554: PUSH
89555: LD_INT 16
89557: PUSH
89558: LD_INT 17
89560: PUSH
89561: LD_INT 18
89563: PUSH
89564: LD_INT 19
89566: PUSH
89567: LD_INT 20
89569: PUSH
89570: LD_INT 21
89572: PUSH
89573: LD_INT 22
89575: PUSH
89576: LD_INT 23
89578: PUSH
89579: LD_INT 24
89581: PUSH
89582: LD_INT 25
89584: PUSH
89585: LD_INT 26
89587: PUSH
89588: LD_INT 27
89590: PUSH
89591: LD_INT 28
89593: PUSH
89594: LD_INT 29
89596: PUSH
89597: LD_INT 30
89599: PUSH
89600: LD_INT 31
89602: PUSH
89603: LD_INT 32
89605: PUSH
89606: LD_INT 33
89608: PUSH
89609: LD_INT 34
89611: PUSH
89612: LD_INT 36
89614: PUSH
89615: EMPTY
89616: LIST
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 101
89654: PUSH
89655: LD_INT 102
89657: PUSH
89658: LD_INT 103
89660: PUSH
89661: LD_INT 104
89663: PUSH
89664: LD_INT 105
89666: PUSH
89667: LD_INT 106
89669: PUSH
89670: LD_INT 107
89672: PUSH
89673: LD_INT 108
89675: PUSH
89676: LD_INT 109
89678: PUSH
89679: LD_INT 110
89681: PUSH
89682: LD_INT 111
89684: PUSH
89685: LD_INT 112
89687: PUSH
89688: LD_INT 113
89690: PUSH
89691: LD_INT 114
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: PUSH
89710: EMPTY
89711: LIST
89712: LIST
89713: ST_TO_ADDR
89714: GO 90441
89716: LD_INT 16
89718: DOUBLE
89719: EQUAL
89720: IFTRUE 89724
89722: GO 89848
89724: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
89725: LD_ADDR_VAR 0 1
89729: PUSH
89730: LD_INT 2
89732: PUSH
89733: LD_INT 4
89735: PUSH
89736: LD_INT 5
89738: PUSH
89739: LD_INT 7
89741: PUSH
89742: LD_INT 11
89744: PUSH
89745: LD_INT 12
89747: PUSH
89748: LD_INT 15
89750: PUSH
89751: LD_INT 16
89753: PUSH
89754: LD_INT 20
89756: PUSH
89757: LD_INT 21
89759: PUSH
89760: LD_INT 22
89762: PUSH
89763: LD_INT 23
89765: PUSH
89766: LD_INT 25
89768: PUSH
89769: LD_INT 26
89771: PUSH
89772: LD_INT 30
89774: PUSH
89775: LD_INT 31
89777: PUSH
89778: LD_INT 32
89780: PUSH
89781: LD_INT 33
89783: PUSH
89784: LD_INT 34
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: PUSH
89808: LD_INT 101
89810: PUSH
89811: LD_INT 102
89813: PUSH
89814: LD_INT 103
89816: PUSH
89817: LD_INT 106
89819: PUSH
89820: LD_INT 108
89822: PUSH
89823: LD_INT 112
89825: PUSH
89826: LD_INT 113
89828: PUSH
89829: LD_INT 114
89831: PUSH
89832: EMPTY
89833: LIST
89834: LIST
89835: LIST
89836: LIST
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: ST_TO_ADDR
89846: GO 90441
89848: LD_INT 17
89850: DOUBLE
89851: EQUAL
89852: IFTRUE 89856
89854: GO 90068
89856: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
89857: LD_ADDR_VAR 0 1
89861: PUSH
89862: LD_INT 1
89864: PUSH
89865: LD_INT 2
89867: PUSH
89868: LD_INT 3
89870: PUSH
89871: LD_INT 4
89873: PUSH
89874: LD_INT 5
89876: PUSH
89877: LD_INT 6
89879: PUSH
89880: LD_INT 7
89882: PUSH
89883: LD_INT 8
89885: PUSH
89886: LD_INT 9
89888: PUSH
89889: LD_INT 10
89891: PUSH
89892: LD_INT 11
89894: PUSH
89895: LD_INT 12
89897: PUSH
89898: LD_INT 13
89900: PUSH
89901: LD_INT 14
89903: PUSH
89904: LD_INT 15
89906: PUSH
89907: LD_INT 16
89909: PUSH
89910: LD_INT 17
89912: PUSH
89913: LD_INT 18
89915: PUSH
89916: LD_INT 19
89918: PUSH
89919: LD_INT 20
89921: PUSH
89922: LD_INT 21
89924: PUSH
89925: LD_INT 22
89927: PUSH
89928: LD_INT 23
89930: PUSH
89931: LD_INT 24
89933: PUSH
89934: LD_INT 25
89936: PUSH
89937: LD_INT 26
89939: PUSH
89940: LD_INT 27
89942: PUSH
89943: LD_INT 28
89945: PUSH
89946: LD_INT 29
89948: PUSH
89949: LD_INT 30
89951: PUSH
89952: LD_INT 31
89954: PUSH
89955: LD_INT 32
89957: PUSH
89958: LD_INT 33
89960: PUSH
89961: LD_INT 34
89963: PUSH
89964: LD_INT 36
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: LIST
89993: LIST
89994: LIST
89995: LIST
89996: LIST
89997: LIST
89998: LIST
89999: LIST
90000: LIST
90001: LIST
90002: LIST
90003: PUSH
90004: LD_INT 101
90006: PUSH
90007: LD_INT 102
90009: PUSH
90010: LD_INT 103
90012: PUSH
90013: LD_INT 104
90015: PUSH
90016: LD_INT 105
90018: PUSH
90019: LD_INT 106
90021: PUSH
90022: LD_INT 107
90024: PUSH
90025: LD_INT 108
90027: PUSH
90028: LD_INT 109
90030: PUSH
90031: LD_INT 110
90033: PUSH
90034: LD_INT 111
90036: PUSH
90037: LD_INT 112
90039: PUSH
90040: LD_INT 113
90042: PUSH
90043: LD_INT 114
90045: PUSH
90046: EMPTY
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: PUSH
90062: EMPTY
90063: LIST
90064: LIST
90065: ST_TO_ADDR
90066: GO 90441
90068: LD_INT 18
90070: DOUBLE
90071: EQUAL
90072: IFTRUE 90076
90074: GO 90212
90076: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
90077: LD_ADDR_VAR 0 1
90081: PUSH
90082: LD_INT 2
90084: PUSH
90085: LD_INT 4
90087: PUSH
90088: LD_INT 5
90090: PUSH
90091: LD_INT 7
90093: PUSH
90094: LD_INT 11
90096: PUSH
90097: LD_INT 12
90099: PUSH
90100: LD_INT 15
90102: PUSH
90103: LD_INT 16
90105: PUSH
90106: LD_INT 20
90108: PUSH
90109: LD_INT 21
90111: PUSH
90112: LD_INT 22
90114: PUSH
90115: LD_INT 23
90117: PUSH
90118: LD_INT 25
90120: PUSH
90121: LD_INT 26
90123: PUSH
90124: LD_INT 30
90126: PUSH
90127: LD_INT 31
90129: PUSH
90130: LD_INT 32
90132: PUSH
90133: LD_INT 33
90135: PUSH
90136: LD_INT 34
90138: PUSH
90139: LD_INT 35
90141: PUSH
90142: LD_INT 36
90144: PUSH
90145: EMPTY
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: PUSH
90168: LD_INT 101
90170: PUSH
90171: LD_INT 102
90173: PUSH
90174: LD_INT 103
90176: PUSH
90177: LD_INT 106
90179: PUSH
90180: LD_INT 108
90182: PUSH
90183: LD_INT 112
90185: PUSH
90186: LD_INT 113
90188: PUSH
90189: LD_INT 114
90191: PUSH
90192: LD_INT 115
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: PUSH
90206: EMPTY
90207: LIST
90208: LIST
90209: ST_TO_ADDR
90210: GO 90441
90212: LD_INT 19
90214: DOUBLE
90215: EQUAL
90216: IFTRUE 90220
90218: GO 90440
90220: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
90221: LD_ADDR_VAR 0 1
90225: PUSH
90226: LD_INT 1
90228: PUSH
90229: LD_INT 2
90231: PUSH
90232: LD_INT 3
90234: PUSH
90235: LD_INT 4
90237: PUSH
90238: LD_INT 5
90240: PUSH
90241: LD_INT 6
90243: PUSH
90244: LD_INT 7
90246: PUSH
90247: LD_INT 8
90249: PUSH
90250: LD_INT 9
90252: PUSH
90253: LD_INT 10
90255: PUSH
90256: LD_INT 11
90258: PUSH
90259: LD_INT 12
90261: PUSH
90262: LD_INT 13
90264: PUSH
90265: LD_INT 14
90267: PUSH
90268: LD_INT 15
90270: PUSH
90271: LD_INT 16
90273: PUSH
90274: LD_INT 17
90276: PUSH
90277: LD_INT 18
90279: PUSH
90280: LD_INT 19
90282: PUSH
90283: LD_INT 20
90285: PUSH
90286: LD_INT 21
90288: PUSH
90289: LD_INT 22
90291: PUSH
90292: LD_INT 23
90294: PUSH
90295: LD_INT 24
90297: PUSH
90298: LD_INT 25
90300: PUSH
90301: LD_INT 26
90303: PUSH
90304: LD_INT 27
90306: PUSH
90307: LD_INT 28
90309: PUSH
90310: LD_INT 29
90312: PUSH
90313: LD_INT 30
90315: PUSH
90316: LD_INT 31
90318: PUSH
90319: LD_INT 32
90321: PUSH
90322: LD_INT 33
90324: PUSH
90325: LD_INT 34
90327: PUSH
90328: LD_INT 35
90330: PUSH
90331: LD_INT 36
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: LIST
90357: LIST
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 101
90374: PUSH
90375: LD_INT 102
90377: PUSH
90378: LD_INT 103
90380: PUSH
90381: LD_INT 104
90383: PUSH
90384: LD_INT 105
90386: PUSH
90387: LD_INT 106
90389: PUSH
90390: LD_INT 107
90392: PUSH
90393: LD_INT 108
90395: PUSH
90396: LD_INT 109
90398: PUSH
90399: LD_INT 110
90401: PUSH
90402: LD_INT 111
90404: PUSH
90405: LD_INT 112
90407: PUSH
90408: LD_INT 113
90410: PUSH
90411: LD_INT 114
90413: PUSH
90414: LD_INT 115
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: PUSH
90434: EMPTY
90435: LIST
90436: LIST
90437: ST_TO_ADDR
90438: GO 90441
90440: POP
// end else
90441: GO 90660
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
90443: LD_ADDR_VAR 0 1
90447: PUSH
90448: LD_INT 1
90450: PUSH
90451: LD_INT 2
90453: PUSH
90454: LD_INT 3
90456: PUSH
90457: LD_INT 4
90459: PUSH
90460: LD_INT 5
90462: PUSH
90463: LD_INT 6
90465: PUSH
90466: LD_INT 7
90468: PUSH
90469: LD_INT 8
90471: PUSH
90472: LD_INT 9
90474: PUSH
90475: LD_INT 10
90477: PUSH
90478: LD_INT 11
90480: PUSH
90481: LD_INT 12
90483: PUSH
90484: LD_INT 13
90486: PUSH
90487: LD_INT 14
90489: PUSH
90490: LD_INT 15
90492: PUSH
90493: LD_INT 16
90495: PUSH
90496: LD_INT 17
90498: PUSH
90499: LD_INT 18
90501: PUSH
90502: LD_INT 19
90504: PUSH
90505: LD_INT 20
90507: PUSH
90508: LD_INT 21
90510: PUSH
90511: LD_INT 22
90513: PUSH
90514: LD_INT 23
90516: PUSH
90517: LD_INT 24
90519: PUSH
90520: LD_INT 25
90522: PUSH
90523: LD_INT 26
90525: PUSH
90526: LD_INT 27
90528: PUSH
90529: LD_INT 28
90531: PUSH
90532: LD_INT 29
90534: PUSH
90535: LD_INT 30
90537: PUSH
90538: LD_INT 31
90540: PUSH
90541: LD_INT 32
90543: PUSH
90544: LD_INT 33
90546: PUSH
90547: LD_INT 34
90549: PUSH
90550: LD_INT 35
90552: PUSH
90553: LD_INT 36
90555: PUSH
90556: EMPTY
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: PUSH
90594: LD_INT 101
90596: PUSH
90597: LD_INT 102
90599: PUSH
90600: LD_INT 103
90602: PUSH
90603: LD_INT 104
90605: PUSH
90606: LD_INT 105
90608: PUSH
90609: LD_INT 106
90611: PUSH
90612: LD_INT 107
90614: PUSH
90615: LD_INT 108
90617: PUSH
90618: LD_INT 109
90620: PUSH
90621: LD_INT 110
90623: PUSH
90624: LD_INT 111
90626: PUSH
90627: LD_INT 112
90629: PUSH
90630: LD_INT 113
90632: PUSH
90633: LD_INT 114
90635: PUSH
90636: LD_INT 115
90638: PUSH
90639: EMPTY
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: ST_TO_ADDR
// if result then
90660: LD_VAR 0 1
90664: IFFALSE 90953
// begin normal :=  ;
90666: LD_ADDR_VAR 0 3
90670: PUSH
90671: LD_STRING 
90673: ST_TO_ADDR
// hardcore :=  ;
90674: LD_ADDR_VAR 0 4
90678: PUSH
90679: LD_STRING 
90681: ST_TO_ADDR
// for i = 1 to normalCounter do
90682: LD_ADDR_VAR 0 5
90686: PUSH
90687: DOUBLE
90688: LD_INT 1
90690: DEC
90691: ST_TO_ADDR
90692: LD_EXP 132
90696: PUSH
90697: FOR_TO
90698: IFFALSE 90799
// begin tmp := 0 ;
90700: LD_ADDR_VAR 0 2
90704: PUSH
90705: LD_STRING 0
90707: ST_TO_ADDR
// if result [ 1 ] then
90708: LD_VAR 0 1
90712: PUSH
90713: LD_INT 1
90715: ARRAY
90716: IFFALSE 90781
// if result [ 1 ] [ 1 ] = i then
90718: LD_VAR 0 1
90722: PUSH
90723: LD_INT 1
90725: ARRAY
90726: PUSH
90727: LD_INT 1
90729: ARRAY
90730: PUSH
90731: LD_VAR 0 5
90735: EQUAL
90736: IFFALSE 90781
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
90738: LD_ADDR_VAR 0 1
90742: PUSH
90743: LD_VAR 0 1
90747: PPUSH
90748: LD_INT 1
90750: PPUSH
90751: LD_VAR 0 1
90755: PUSH
90756: LD_INT 1
90758: ARRAY
90759: PPUSH
90760: LD_INT 1
90762: PPUSH
90763: CALL_OW 3
90767: PPUSH
90768: CALL_OW 1
90772: ST_TO_ADDR
// tmp := 1 ;
90773: LD_ADDR_VAR 0 2
90777: PUSH
90778: LD_STRING 1
90780: ST_TO_ADDR
// end ; normal := normal & tmp ;
90781: LD_ADDR_VAR 0 3
90785: PUSH
90786: LD_VAR 0 3
90790: PUSH
90791: LD_VAR 0 2
90795: STR
90796: ST_TO_ADDR
// end ;
90797: GO 90697
90799: POP
90800: POP
// for i = 1 to hardcoreCounter do
90801: LD_ADDR_VAR 0 5
90805: PUSH
90806: DOUBLE
90807: LD_INT 1
90809: DEC
90810: ST_TO_ADDR
90811: LD_EXP 133
90815: PUSH
90816: FOR_TO
90817: IFFALSE 90922
// begin tmp := 0 ;
90819: LD_ADDR_VAR 0 2
90823: PUSH
90824: LD_STRING 0
90826: ST_TO_ADDR
// if result [ 2 ] then
90827: LD_VAR 0 1
90831: PUSH
90832: LD_INT 2
90834: ARRAY
90835: IFFALSE 90904
// if result [ 2 ] [ 1 ] = 100 + i then
90837: LD_VAR 0 1
90841: PUSH
90842: LD_INT 2
90844: ARRAY
90845: PUSH
90846: LD_INT 1
90848: ARRAY
90849: PUSH
90850: LD_INT 100
90852: PUSH
90853: LD_VAR 0 5
90857: PLUS
90858: EQUAL
90859: IFFALSE 90904
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
90861: LD_ADDR_VAR 0 1
90865: PUSH
90866: LD_VAR 0 1
90870: PPUSH
90871: LD_INT 2
90873: PPUSH
90874: LD_VAR 0 1
90878: PUSH
90879: LD_INT 2
90881: ARRAY
90882: PPUSH
90883: LD_INT 1
90885: PPUSH
90886: CALL_OW 3
90890: PPUSH
90891: CALL_OW 1
90895: ST_TO_ADDR
// tmp := 1 ;
90896: LD_ADDR_VAR 0 2
90900: PUSH
90901: LD_STRING 1
90903: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
90904: LD_ADDR_VAR 0 4
90908: PUSH
90909: LD_VAR 0 4
90913: PUSH
90914: LD_VAR 0 2
90918: STR
90919: ST_TO_ADDR
// end ;
90920: GO 90816
90922: POP
90923: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
90924: LD_STRING getStreamItemsFromMission("
90926: PUSH
90927: LD_VAR 0 3
90931: STR
90932: PUSH
90933: LD_STRING ","
90935: STR
90936: PUSH
90937: LD_VAR 0 4
90941: STR
90942: PUSH
90943: LD_STRING ")
90945: STR
90946: PPUSH
90947: CALL_OW 559
// end else
90951: GO 90960
// ToLua ( getStreamItemsFromMission("","") ) ;
90953: LD_STRING getStreamItemsFromMission("","")
90955: PPUSH
90956: CALL_OW 559
// end ;
90960: LD_VAR 0 1
90964: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
90965: LD_VAR 0 2
90969: PUSH
90970: LD_INT 100
90972: EQUAL
90973: IFFALSE 91922
// begin if not StreamModeActive then
90975: LD_EXP 131
90979: NOT
90980: IFFALSE 90990
// StreamModeActive := true ;
90982: LD_ADDR_EXP 131
90986: PUSH
90987: LD_INT 1
90989: ST_TO_ADDR
// if p3 = 0 then
90990: LD_VAR 0 3
90994: PUSH
90995: LD_INT 0
90997: EQUAL
90998: IFFALSE 91004
// InitStreamMode ;
91000: CALL 87043 0 0
// if p3 = 1 then
91004: LD_VAR 0 3
91008: PUSH
91009: LD_INT 1
91011: EQUAL
91012: IFFALSE 91022
// sRocket := true ;
91014: LD_ADDR_EXP 136
91018: PUSH
91019: LD_INT 1
91021: ST_TO_ADDR
// if p3 = 2 then
91022: LD_VAR 0 3
91026: PUSH
91027: LD_INT 2
91029: EQUAL
91030: IFFALSE 91040
// sSpeed := true ;
91032: LD_ADDR_EXP 135
91036: PUSH
91037: LD_INT 1
91039: ST_TO_ADDR
// if p3 = 3 then
91040: LD_VAR 0 3
91044: PUSH
91045: LD_INT 3
91047: EQUAL
91048: IFFALSE 91058
// sEngine := true ;
91050: LD_ADDR_EXP 137
91054: PUSH
91055: LD_INT 1
91057: ST_TO_ADDR
// if p3 = 4 then
91058: LD_VAR 0 3
91062: PUSH
91063: LD_INT 4
91065: EQUAL
91066: IFFALSE 91076
// sSpec := true ;
91068: LD_ADDR_EXP 134
91072: PUSH
91073: LD_INT 1
91075: ST_TO_ADDR
// if p3 = 5 then
91076: LD_VAR 0 3
91080: PUSH
91081: LD_INT 5
91083: EQUAL
91084: IFFALSE 91094
// sLevel := true ;
91086: LD_ADDR_EXP 138
91090: PUSH
91091: LD_INT 1
91093: ST_TO_ADDR
// if p3 = 6 then
91094: LD_VAR 0 3
91098: PUSH
91099: LD_INT 6
91101: EQUAL
91102: IFFALSE 91112
// sArmoury := true ;
91104: LD_ADDR_EXP 139
91108: PUSH
91109: LD_INT 1
91111: ST_TO_ADDR
// if p3 = 7 then
91112: LD_VAR 0 3
91116: PUSH
91117: LD_INT 7
91119: EQUAL
91120: IFFALSE 91130
// sRadar := true ;
91122: LD_ADDR_EXP 140
91126: PUSH
91127: LD_INT 1
91129: ST_TO_ADDR
// if p3 = 8 then
91130: LD_VAR 0 3
91134: PUSH
91135: LD_INT 8
91137: EQUAL
91138: IFFALSE 91148
// sBunker := true ;
91140: LD_ADDR_EXP 141
91144: PUSH
91145: LD_INT 1
91147: ST_TO_ADDR
// if p3 = 9 then
91148: LD_VAR 0 3
91152: PUSH
91153: LD_INT 9
91155: EQUAL
91156: IFFALSE 91166
// sHack := true ;
91158: LD_ADDR_EXP 142
91162: PUSH
91163: LD_INT 1
91165: ST_TO_ADDR
// if p3 = 10 then
91166: LD_VAR 0 3
91170: PUSH
91171: LD_INT 10
91173: EQUAL
91174: IFFALSE 91184
// sFire := true ;
91176: LD_ADDR_EXP 143
91180: PUSH
91181: LD_INT 1
91183: ST_TO_ADDR
// if p3 = 11 then
91184: LD_VAR 0 3
91188: PUSH
91189: LD_INT 11
91191: EQUAL
91192: IFFALSE 91202
// sRefresh := true ;
91194: LD_ADDR_EXP 144
91198: PUSH
91199: LD_INT 1
91201: ST_TO_ADDR
// if p3 = 12 then
91202: LD_VAR 0 3
91206: PUSH
91207: LD_INT 12
91209: EQUAL
91210: IFFALSE 91220
// sExp := true ;
91212: LD_ADDR_EXP 145
91216: PUSH
91217: LD_INT 1
91219: ST_TO_ADDR
// if p3 = 13 then
91220: LD_VAR 0 3
91224: PUSH
91225: LD_INT 13
91227: EQUAL
91228: IFFALSE 91238
// sDepot := true ;
91230: LD_ADDR_EXP 146
91234: PUSH
91235: LD_INT 1
91237: ST_TO_ADDR
// if p3 = 14 then
91238: LD_VAR 0 3
91242: PUSH
91243: LD_INT 14
91245: EQUAL
91246: IFFALSE 91256
// sFlag := true ;
91248: LD_ADDR_EXP 147
91252: PUSH
91253: LD_INT 1
91255: ST_TO_ADDR
// if p3 = 15 then
91256: LD_VAR 0 3
91260: PUSH
91261: LD_INT 15
91263: EQUAL
91264: IFFALSE 91274
// sKamikadze := true ;
91266: LD_ADDR_EXP 155
91270: PUSH
91271: LD_INT 1
91273: ST_TO_ADDR
// if p3 = 16 then
91274: LD_VAR 0 3
91278: PUSH
91279: LD_INT 16
91281: EQUAL
91282: IFFALSE 91292
// sTroll := true ;
91284: LD_ADDR_EXP 156
91288: PUSH
91289: LD_INT 1
91291: ST_TO_ADDR
// if p3 = 17 then
91292: LD_VAR 0 3
91296: PUSH
91297: LD_INT 17
91299: EQUAL
91300: IFFALSE 91310
// sSlow := true ;
91302: LD_ADDR_EXP 157
91306: PUSH
91307: LD_INT 1
91309: ST_TO_ADDR
// if p3 = 18 then
91310: LD_VAR 0 3
91314: PUSH
91315: LD_INT 18
91317: EQUAL
91318: IFFALSE 91328
// sLack := true ;
91320: LD_ADDR_EXP 158
91324: PUSH
91325: LD_INT 1
91327: ST_TO_ADDR
// if p3 = 19 then
91328: LD_VAR 0 3
91332: PUSH
91333: LD_INT 19
91335: EQUAL
91336: IFFALSE 91346
// sTank := true ;
91338: LD_ADDR_EXP 160
91342: PUSH
91343: LD_INT 1
91345: ST_TO_ADDR
// if p3 = 20 then
91346: LD_VAR 0 3
91350: PUSH
91351: LD_INT 20
91353: EQUAL
91354: IFFALSE 91364
// sRemote := true ;
91356: LD_ADDR_EXP 161
91360: PUSH
91361: LD_INT 1
91363: ST_TO_ADDR
// if p3 = 21 then
91364: LD_VAR 0 3
91368: PUSH
91369: LD_INT 21
91371: EQUAL
91372: IFFALSE 91382
// sPowell := true ;
91374: LD_ADDR_EXP 162
91378: PUSH
91379: LD_INT 1
91381: ST_TO_ADDR
// if p3 = 22 then
91382: LD_VAR 0 3
91386: PUSH
91387: LD_INT 22
91389: EQUAL
91390: IFFALSE 91400
// sTeleport := true ;
91392: LD_ADDR_EXP 165
91396: PUSH
91397: LD_INT 1
91399: ST_TO_ADDR
// if p3 = 23 then
91400: LD_VAR 0 3
91404: PUSH
91405: LD_INT 23
91407: EQUAL
91408: IFFALSE 91418
// sOilTower := true ;
91410: LD_ADDR_EXP 167
91414: PUSH
91415: LD_INT 1
91417: ST_TO_ADDR
// if p3 = 24 then
91418: LD_VAR 0 3
91422: PUSH
91423: LD_INT 24
91425: EQUAL
91426: IFFALSE 91436
// sShovel := true ;
91428: LD_ADDR_EXP 168
91432: PUSH
91433: LD_INT 1
91435: ST_TO_ADDR
// if p3 = 25 then
91436: LD_VAR 0 3
91440: PUSH
91441: LD_INT 25
91443: EQUAL
91444: IFFALSE 91454
// sSheik := true ;
91446: LD_ADDR_EXP 169
91450: PUSH
91451: LD_INT 1
91453: ST_TO_ADDR
// if p3 = 26 then
91454: LD_VAR 0 3
91458: PUSH
91459: LD_INT 26
91461: EQUAL
91462: IFFALSE 91472
// sEarthquake := true ;
91464: LD_ADDR_EXP 171
91468: PUSH
91469: LD_INT 1
91471: ST_TO_ADDR
// if p3 = 27 then
91472: LD_VAR 0 3
91476: PUSH
91477: LD_INT 27
91479: EQUAL
91480: IFFALSE 91490
// sAI := true ;
91482: LD_ADDR_EXP 172
91486: PUSH
91487: LD_INT 1
91489: ST_TO_ADDR
// if p3 = 28 then
91490: LD_VAR 0 3
91494: PUSH
91495: LD_INT 28
91497: EQUAL
91498: IFFALSE 91508
// sCargo := true ;
91500: LD_ADDR_EXP 175
91504: PUSH
91505: LD_INT 1
91507: ST_TO_ADDR
// if p3 = 29 then
91508: LD_VAR 0 3
91512: PUSH
91513: LD_INT 29
91515: EQUAL
91516: IFFALSE 91526
// sDLaser := true ;
91518: LD_ADDR_EXP 176
91522: PUSH
91523: LD_INT 1
91525: ST_TO_ADDR
// if p3 = 30 then
91526: LD_VAR 0 3
91530: PUSH
91531: LD_INT 30
91533: EQUAL
91534: IFFALSE 91544
// sExchange := true ;
91536: LD_ADDR_EXP 177
91540: PUSH
91541: LD_INT 1
91543: ST_TO_ADDR
// if p3 = 31 then
91544: LD_VAR 0 3
91548: PUSH
91549: LD_INT 31
91551: EQUAL
91552: IFFALSE 91562
// sFac := true ;
91554: LD_ADDR_EXP 178
91558: PUSH
91559: LD_INT 1
91561: ST_TO_ADDR
// if p3 = 32 then
91562: LD_VAR 0 3
91566: PUSH
91567: LD_INT 32
91569: EQUAL
91570: IFFALSE 91580
// sPower := true ;
91572: LD_ADDR_EXP 179
91576: PUSH
91577: LD_INT 1
91579: ST_TO_ADDR
// if p3 = 33 then
91580: LD_VAR 0 3
91584: PUSH
91585: LD_INT 33
91587: EQUAL
91588: IFFALSE 91598
// sRandom := true ;
91590: LD_ADDR_EXP 180
91594: PUSH
91595: LD_INT 1
91597: ST_TO_ADDR
// if p3 = 34 then
91598: LD_VAR 0 3
91602: PUSH
91603: LD_INT 34
91605: EQUAL
91606: IFFALSE 91616
// sShield := true ;
91608: LD_ADDR_EXP 181
91612: PUSH
91613: LD_INT 1
91615: ST_TO_ADDR
// if p3 = 35 then
91616: LD_VAR 0 3
91620: PUSH
91621: LD_INT 35
91623: EQUAL
91624: IFFALSE 91634
// sTime := true ;
91626: LD_ADDR_EXP 182
91630: PUSH
91631: LD_INT 1
91633: ST_TO_ADDR
// if p3 = 36 then
91634: LD_VAR 0 3
91638: PUSH
91639: LD_INT 36
91641: EQUAL
91642: IFFALSE 91652
// sTools := true ;
91644: LD_ADDR_EXP 183
91648: PUSH
91649: LD_INT 1
91651: ST_TO_ADDR
// if p3 = 101 then
91652: LD_VAR 0 3
91656: PUSH
91657: LD_INT 101
91659: EQUAL
91660: IFFALSE 91670
// sSold := true ;
91662: LD_ADDR_EXP 148
91666: PUSH
91667: LD_INT 1
91669: ST_TO_ADDR
// if p3 = 102 then
91670: LD_VAR 0 3
91674: PUSH
91675: LD_INT 102
91677: EQUAL
91678: IFFALSE 91688
// sDiff := true ;
91680: LD_ADDR_EXP 149
91684: PUSH
91685: LD_INT 1
91687: ST_TO_ADDR
// if p3 = 103 then
91688: LD_VAR 0 3
91692: PUSH
91693: LD_INT 103
91695: EQUAL
91696: IFFALSE 91706
// sFog := true ;
91698: LD_ADDR_EXP 152
91702: PUSH
91703: LD_INT 1
91705: ST_TO_ADDR
// if p3 = 104 then
91706: LD_VAR 0 3
91710: PUSH
91711: LD_INT 104
91713: EQUAL
91714: IFFALSE 91724
// sReset := true ;
91716: LD_ADDR_EXP 153
91720: PUSH
91721: LD_INT 1
91723: ST_TO_ADDR
// if p3 = 105 then
91724: LD_VAR 0 3
91728: PUSH
91729: LD_INT 105
91731: EQUAL
91732: IFFALSE 91742
// sSun := true ;
91734: LD_ADDR_EXP 154
91738: PUSH
91739: LD_INT 1
91741: ST_TO_ADDR
// if p3 = 106 then
91742: LD_VAR 0 3
91746: PUSH
91747: LD_INT 106
91749: EQUAL
91750: IFFALSE 91760
// sTiger := true ;
91752: LD_ADDR_EXP 150
91756: PUSH
91757: LD_INT 1
91759: ST_TO_ADDR
// if p3 = 107 then
91760: LD_VAR 0 3
91764: PUSH
91765: LD_INT 107
91767: EQUAL
91768: IFFALSE 91778
// sBomb := true ;
91770: LD_ADDR_EXP 151
91774: PUSH
91775: LD_INT 1
91777: ST_TO_ADDR
// if p3 = 108 then
91778: LD_VAR 0 3
91782: PUSH
91783: LD_INT 108
91785: EQUAL
91786: IFFALSE 91796
// sWound := true ;
91788: LD_ADDR_EXP 159
91792: PUSH
91793: LD_INT 1
91795: ST_TO_ADDR
// if p3 = 109 then
91796: LD_VAR 0 3
91800: PUSH
91801: LD_INT 109
91803: EQUAL
91804: IFFALSE 91814
// sBetray := true ;
91806: LD_ADDR_EXP 163
91810: PUSH
91811: LD_INT 1
91813: ST_TO_ADDR
// if p3 = 110 then
91814: LD_VAR 0 3
91818: PUSH
91819: LD_INT 110
91821: EQUAL
91822: IFFALSE 91832
// sContamin := true ;
91824: LD_ADDR_EXP 164
91828: PUSH
91829: LD_INT 1
91831: ST_TO_ADDR
// if p3 = 111 then
91832: LD_VAR 0 3
91836: PUSH
91837: LD_INT 111
91839: EQUAL
91840: IFFALSE 91850
// sOil := true ;
91842: LD_ADDR_EXP 166
91846: PUSH
91847: LD_INT 1
91849: ST_TO_ADDR
// if p3 = 112 then
91850: LD_VAR 0 3
91854: PUSH
91855: LD_INT 112
91857: EQUAL
91858: IFFALSE 91868
// sStu := true ;
91860: LD_ADDR_EXP 170
91864: PUSH
91865: LD_INT 1
91867: ST_TO_ADDR
// if p3 = 113 then
91868: LD_VAR 0 3
91872: PUSH
91873: LD_INT 113
91875: EQUAL
91876: IFFALSE 91886
// sBazooka := true ;
91878: LD_ADDR_EXP 173
91882: PUSH
91883: LD_INT 1
91885: ST_TO_ADDR
// if p3 = 114 then
91886: LD_VAR 0 3
91890: PUSH
91891: LD_INT 114
91893: EQUAL
91894: IFFALSE 91904
// sMortar := true ;
91896: LD_ADDR_EXP 174
91900: PUSH
91901: LD_INT 1
91903: ST_TO_ADDR
// if p3 = 115 then
91904: LD_VAR 0 3
91908: PUSH
91909: LD_INT 115
91911: EQUAL
91912: IFFALSE 91922
// sRanger := true ;
91914: LD_ADDR_EXP 184
91918: PUSH
91919: LD_INT 1
91921: ST_TO_ADDR
// end ; end ;
91922: PPOPN 6
91924: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
91925: LD_EXP 131
91929: PUSH
91930: LD_EXP 136
91934: AND
91935: IFFALSE 92059
91937: GO 91939
91939: DISABLE
91940: LD_INT 0
91942: PPUSH
91943: PPUSH
// begin enable ;
91944: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
91945: LD_ADDR_VAR 0 2
91949: PUSH
91950: LD_INT 22
91952: PUSH
91953: LD_OWVAR 2
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 2
91964: PUSH
91965: LD_INT 34
91967: PUSH
91968: LD_INT 7
91970: PUSH
91971: EMPTY
91972: LIST
91973: LIST
91974: PUSH
91975: LD_INT 34
91977: PUSH
91978: LD_INT 45
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: PUSH
91985: LD_INT 34
91987: PUSH
91988: LD_INT 28
91990: PUSH
91991: EMPTY
91992: LIST
91993: LIST
91994: PUSH
91995: LD_INT 34
91997: PUSH
91998: LD_INT 47
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: EMPTY
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PPUSH
92016: CALL_OW 69
92020: ST_TO_ADDR
// if not tmp then
92021: LD_VAR 0 2
92025: NOT
92026: IFFALSE 92030
// exit ;
92028: GO 92059
// for i in tmp do
92030: LD_ADDR_VAR 0 1
92034: PUSH
92035: LD_VAR 0 2
92039: PUSH
92040: FOR_IN
92041: IFFALSE 92057
// begin SetLives ( i , 0 ) ;
92043: LD_VAR 0 1
92047: PPUSH
92048: LD_INT 0
92050: PPUSH
92051: CALL_OW 234
// end ;
92055: GO 92040
92057: POP
92058: POP
// end ;
92059: PPOPN 2
92061: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92062: LD_EXP 131
92066: PUSH
92067: LD_EXP 137
92071: AND
92072: IFFALSE 92156
92074: GO 92076
92076: DISABLE
92077: LD_INT 0
92079: PPUSH
92080: PPUSH
// begin enable ;
92081: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92082: LD_ADDR_VAR 0 2
92086: PUSH
92087: LD_INT 22
92089: PUSH
92090: LD_OWVAR 2
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: PUSH
92099: LD_INT 32
92101: PUSH
92102: LD_INT 3
92104: PUSH
92105: EMPTY
92106: LIST
92107: LIST
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PPUSH
92113: CALL_OW 69
92117: ST_TO_ADDR
// if not tmp then
92118: LD_VAR 0 2
92122: NOT
92123: IFFALSE 92127
// exit ;
92125: GO 92156
// for i in tmp do
92127: LD_ADDR_VAR 0 1
92131: PUSH
92132: LD_VAR 0 2
92136: PUSH
92137: FOR_IN
92138: IFFALSE 92154
// begin SetLives ( i , 0 ) ;
92140: LD_VAR 0 1
92144: PPUSH
92145: LD_INT 0
92147: PPUSH
92148: CALL_OW 234
// end ;
92152: GO 92137
92154: POP
92155: POP
// end ;
92156: PPOPN 2
92158: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92159: LD_EXP 131
92163: PUSH
92164: LD_EXP 134
92168: AND
92169: IFFALSE 92262
92171: GO 92173
92173: DISABLE
92174: LD_INT 0
92176: PPUSH
// begin enable ;
92177: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92178: LD_ADDR_VAR 0 1
92182: PUSH
92183: LD_INT 22
92185: PUSH
92186: LD_OWVAR 2
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: PUSH
92195: LD_INT 2
92197: PUSH
92198: LD_INT 25
92200: PUSH
92201: LD_INT 5
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: PUSH
92208: LD_INT 25
92210: PUSH
92211: LD_INT 9
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: PUSH
92218: LD_INT 25
92220: PUSH
92221: LD_INT 8
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: PUSH
92228: EMPTY
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: PPUSH
92238: CALL_OW 69
92242: PUSH
92243: FOR_IN
92244: IFFALSE 92260
// begin SetClass ( i , 1 ) ;
92246: LD_VAR 0 1
92250: PPUSH
92251: LD_INT 1
92253: PPUSH
92254: CALL_OW 336
// end ;
92258: GO 92243
92260: POP
92261: POP
// end ;
92262: PPOPN 1
92264: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92265: LD_EXP 131
92269: PUSH
92270: LD_EXP 135
92274: AND
92275: PUSH
92276: LD_OWVAR 65
92280: PUSH
92281: LD_INT 7
92283: LESS
92284: AND
92285: IFFALSE 92299
92287: GO 92289
92289: DISABLE
// begin enable ;
92290: ENABLE
// game_speed := 7 ;
92291: LD_ADDR_OWVAR 65
92295: PUSH
92296: LD_INT 7
92298: ST_TO_ADDR
// end ;
92299: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92300: LD_EXP 131
92304: PUSH
92305: LD_EXP 138
92309: AND
92310: IFFALSE 92512
92312: GO 92314
92314: DISABLE
92315: LD_INT 0
92317: PPUSH
92318: PPUSH
92319: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92320: LD_ADDR_VAR 0 3
92324: PUSH
92325: LD_INT 81
92327: PUSH
92328: LD_OWVAR 2
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: PUSH
92337: LD_INT 21
92339: PUSH
92340: LD_INT 1
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: PUSH
92347: EMPTY
92348: LIST
92349: LIST
92350: PPUSH
92351: CALL_OW 69
92355: ST_TO_ADDR
// if not tmp then
92356: LD_VAR 0 3
92360: NOT
92361: IFFALSE 92365
// exit ;
92363: GO 92512
// if tmp > 5 then
92365: LD_VAR 0 3
92369: PUSH
92370: LD_INT 5
92372: GREATER
92373: IFFALSE 92385
// k := 5 else
92375: LD_ADDR_VAR 0 2
92379: PUSH
92380: LD_INT 5
92382: ST_TO_ADDR
92383: GO 92395
// k := tmp ;
92385: LD_ADDR_VAR 0 2
92389: PUSH
92390: LD_VAR 0 3
92394: ST_TO_ADDR
// for i := 1 to k do
92395: LD_ADDR_VAR 0 1
92399: PUSH
92400: DOUBLE
92401: LD_INT 1
92403: DEC
92404: ST_TO_ADDR
92405: LD_VAR 0 2
92409: PUSH
92410: FOR_TO
92411: IFFALSE 92510
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92413: LD_VAR 0 3
92417: PUSH
92418: LD_VAR 0 1
92422: ARRAY
92423: PPUSH
92424: LD_VAR 0 1
92428: PUSH
92429: LD_INT 4
92431: MOD
92432: PUSH
92433: LD_INT 1
92435: PLUS
92436: PPUSH
92437: CALL_OW 259
92441: PUSH
92442: LD_INT 10
92444: LESS
92445: IFFALSE 92508
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92447: LD_VAR 0 3
92451: PUSH
92452: LD_VAR 0 1
92456: ARRAY
92457: PPUSH
92458: LD_VAR 0 1
92462: PUSH
92463: LD_INT 4
92465: MOD
92466: PUSH
92467: LD_INT 1
92469: PLUS
92470: PPUSH
92471: LD_VAR 0 3
92475: PUSH
92476: LD_VAR 0 1
92480: ARRAY
92481: PPUSH
92482: LD_VAR 0 1
92486: PUSH
92487: LD_INT 4
92489: MOD
92490: PUSH
92491: LD_INT 1
92493: PLUS
92494: PPUSH
92495: CALL_OW 259
92499: PUSH
92500: LD_INT 1
92502: PLUS
92503: PPUSH
92504: CALL_OW 237
92508: GO 92410
92510: POP
92511: POP
// end ;
92512: PPOPN 3
92514: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92515: LD_EXP 131
92519: PUSH
92520: LD_EXP 139
92524: AND
92525: IFFALSE 92545
92527: GO 92529
92529: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92530: LD_INT 4
92532: PPUSH
92533: LD_OWVAR 2
92537: PPUSH
92538: LD_INT 0
92540: PPUSH
92541: CALL_OW 324
92545: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92546: LD_EXP 131
92550: PUSH
92551: LD_EXP 168
92555: AND
92556: IFFALSE 92576
92558: GO 92560
92560: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92561: LD_INT 19
92563: PPUSH
92564: LD_OWVAR 2
92568: PPUSH
92569: LD_INT 0
92571: PPUSH
92572: CALL_OW 324
92576: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92577: LD_EXP 131
92581: PUSH
92582: LD_EXP 140
92586: AND
92587: IFFALSE 92689
92589: GO 92591
92591: DISABLE
92592: LD_INT 0
92594: PPUSH
92595: PPUSH
// begin enable ;
92596: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92597: LD_ADDR_VAR 0 2
92601: PUSH
92602: LD_INT 22
92604: PUSH
92605: LD_OWVAR 2
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: PUSH
92614: LD_INT 2
92616: PUSH
92617: LD_INT 34
92619: PUSH
92620: LD_INT 11
92622: PUSH
92623: EMPTY
92624: LIST
92625: LIST
92626: PUSH
92627: LD_INT 34
92629: PUSH
92630: LD_INT 30
92632: PUSH
92633: EMPTY
92634: LIST
92635: LIST
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: LIST
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: PPUSH
92646: CALL_OW 69
92650: ST_TO_ADDR
// if not tmp then
92651: LD_VAR 0 2
92655: NOT
92656: IFFALSE 92660
// exit ;
92658: GO 92689
// for i in tmp do
92660: LD_ADDR_VAR 0 1
92664: PUSH
92665: LD_VAR 0 2
92669: PUSH
92670: FOR_IN
92671: IFFALSE 92687
// begin SetLives ( i , 0 ) ;
92673: LD_VAR 0 1
92677: PPUSH
92678: LD_INT 0
92680: PPUSH
92681: CALL_OW 234
// end ;
92685: GO 92670
92687: POP
92688: POP
// end ;
92689: PPOPN 2
92691: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92692: LD_EXP 131
92696: PUSH
92697: LD_EXP 141
92701: AND
92702: IFFALSE 92722
92704: GO 92706
92706: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
92707: LD_INT 32
92709: PPUSH
92710: LD_OWVAR 2
92714: PPUSH
92715: LD_INT 0
92717: PPUSH
92718: CALL_OW 324
92722: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
92723: LD_EXP 131
92727: PUSH
92728: LD_EXP 142
92732: AND
92733: IFFALSE 92914
92735: GO 92737
92737: DISABLE
92738: LD_INT 0
92740: PPUSH
92741: PPUSH
92742: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
92743: LD_ADDR_VAR 0 2
92747: PUSH
92748: LD_INT 22
92750: PUSH
92751: LD_OWVAR 2
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: LD_INT 33
92762: PUSH
92763: LD_INT 3
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: PUSH
92770: EMPTY
92771: LIST
92772: LIST
92773: PPUSH
92774: CALL_OW 69
92778: ST_TO_ADDR
// if not tmp then
92779: LD_VAR 0 2
92783: NOT
92784: IFFALSE 92788
// exit ;
92786: GO 92914
// side := 0 ;
92788: LD_ADDR_VAR 0 3
92792: PUSH
92793: LD_INT 0
92795: ST_TO_ADDR
// for i := 1 to 8 do
92796: LD_ADDR_VAR 0 1
92800: PUSH
92801: DOUBLE
92802: LD_INT 1
92804: DEC
92805: ST_TO_ADDR
92806: LD_INT 8
92808: PUSH
92809: FOR_TO
92810: IFFALSE 92858
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
92812: LD_OWVAR 2
92816: PUSH
92817: LD_VAR 0 1
92821: NONEQUAL
92822: PUSH
92823: LD_OWVAR 2
92827: PPUSH
92828: LD_VAR 0 1
92832: PPUSH
92833: CALL_OW 81
92837: PUSH
92838: LD_INT 2
92840: EQUAL
92841: AND
92842: IFFALSE 92856
// begin side := i ;
92844: LD_ADDR_VAR 0 3
92848: PUSH
92849: LD_VAR 0 1
92853: ST_TO_ADDR
// break ;
92854: GO 92858
// end ;
92856: GO 92809
92858: POP
92859: POP
// if not side then
92860: LD_VAR 0 3
92864: NOT
92865: IFFALSE 92869
// exit ;
92867: GO 92914
// for i := 1 to tmp do
92869: LD_ADDR_VAR 0 1
92873: PUSH
92874: DOUBLE
92875: LD_INT 1
92877: DEC
92878: ST_TO_ADDR
92879: LD_VAR 0 2
92883: PUSH
92884: FOR_TO
92885: IFFALSE 92912
// if Prob ( 60 ) then
92887: LD_INT 60
92889: PPUSH
92890: CALL_OW 13
92894: IFFALSE 92910
// SetSide ( i , side ) ;
92896: LD_VAR 0 1
92900: PPUSH
92901: LD_VAR 0 3
92905: PPUSH
92906: CALL_OW 235
92910: GO 92884
92912: POP
92913: POP
// end ;
92914: PPOPN 3
92916: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
92917: LD_EXP 131
92921: PUSH
92922: LD_EXP 144
92926: AND
92927: IFFALSE 93046
92929: GO 92931
92931: DISABLE
92932: LD_INT 0
92934: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
92935: LD_ADDR_VAR 0 1
92939: PUSH
92940: LD_INT 22
92942: PUSH
92943: LD_OWVAR 2
92947: PUSH
92948: EMPTY
92949: LIST
92950: LIST
92951: PUSH
92952: LD_INT 21
92954: PUSH
92955: LD_INT 1
92957: PUSH
92958: EMPTY
92959: LIST
92960: LIST
92961: PUSH
92962: LD_INT 3
92964: PUSH
92965: LD_INT 23
92967: PUSH
92968: LD_INT 0
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: PUSH
92979: EMPTY
92980: LIST
92981: LIST
92982: LIST
92983: PPUSH
92984: CALL_OW 69
92988: PUSH
92989: FOR_IN
92990: IFFALSE 93044
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
92992: LD_VAR 0 1
92996: PPUSH
92997: CALL_OW 257
93001: PUSH
93002: LD_INT 1
93004: PUSH
93005: LD_INT 2
93007: PUSH
93008: LD_INT 3
93010: PUSH
93011: LD_INT 4
93013: PUSH
93014: EMPTY
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: IN
93020: IFFALSE 93042
// SetClass ( un , rand ( 1 , 4 ) ) ;
93022: LD_VAR 0 1
93026: PPUSH
93027: LD_INT 1
93029: PPUSH
93030: LD_INT 4
93032: PPUSH
93033: CALL_OW 12
93037: PPUSH
93038: CALL_OW 336
93042: GO 92989
93044: POP
93045: POP
// end ;
93046: PPOPN 1
93048: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93049: LD_EXP 131
93053: PUSH
93054: LD_EXP 143
93058: AND
93059: IFFALSE 93138
93061: GO 93063
93063: DISABLE
93064: LD_INT 0
93066: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93067: LD_ADDR_VAR 0 1
93071: PUSH
93072: LD_INT 22
93074: PUSH
93075: LD_OWVAR 2
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: PUSH
93084: LD_INT 21
93086: PUSH
93087: LD_INT 3
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: EMPTY
93095: LIST
93096: LIST
93097: PPUSH
93098: CALL_OW 69
93102: ST_TO_ADDR
// if not tmp then
93103: LD_VAR 0 1
93107: NOT
93108: IFFALSE 93112
// exit ;
93110: GO 93138
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93112: LD_VAR 0 1
93116: PUSH
93117: LD_INT 1
93119: PPUSH
93120: LD_VAR 0 1
93124: PPUSH
93125: CALL_OW 12
93129: ARRAY
93130: PPUSH
93131: LD_INT 100
93133: PPUSH
93134: CALL_OW 234
// end ;
93138: PPOPN 1
93140: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93141: LD_EXP 131
93145: PUSH
93146: LD_EXP 145
93150: AND
93151: IFFALSE 93249
93153: GO 93155
93155: DISABLE
93156: LD_INT 0
93158: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93159: LD_ADDR_VAR 0 1
93163: PUSH
93164: LD_INT 22
93166: PUSH
93167: LD_OWVAR 2
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: LD_INT 21
93178: PUSH
93179: LD_INT 1
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PPUSH
93190: CALL_OW 69
93194: ST_TO_ADDR
// if not tmp then
93195: LD_VAR 0 1
93199: NOT
93200: IFFALSE 93204
// exit ;
93202: GO 93249
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93204: LD_VAR 0 1
93208: PUSH
93209: LD_INT 1
93211: PPUSH
93212: LD_VAR 0 1
93216: PPUSH
93217: CALL_OW 12
93221: ARRAY
93222: PPUSH
93223: LD_INT 1
93225: PPUSH
93226: LD_INT 4
93228: PPUSH
93229: CALL_OW 12
93233: PPUSH
93234: LD_INT 3000
93236: PPUSH
93237: LD_INT 9000
93239: PPUSH
93240: CALL_OW 12
93244: PPUSH
93245: CALL_OW 492
// end ;
93249: PPOPN 1
93251: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93252: LD_EXP 131
93256: PUSH
93257: LD_EXP 146
93261: AND
93262: IFFALSE 93282
93264: GO 93266
93266: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93267: LD_INT 1
93269: PPUSH
93270: LD_OWVAR 2
93274: PPUSH
93275: LD_INT 0
93277: PPUSH
93278: CALL_OW 324
93282: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93283: LD_EXP 131
93287: PUSH
93288: LD_EXP 147
93292: AND
93293: IFFALSE 93376
93295: GO 93297
93297: DISABLE
93298: LD_INT 0
93300: PPUSH
93301: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93302: LD_ADDR_VAR 0 2
93306: PUSH
93307: LD_INT 22
93309: PUSH
93310: LD_OWVAR 2
93314: PUSH
93315: EMPTY
93316: LIST
93317: LIST
93318: PUSH
93319: LD_INT 21
93321: PUSH
93322: LD_INT 3
93324: PUSH
93325: EMPTY
93326: LIST
93327: LIST
93328: PUSH
93329: EMPTY
93330: LIST
93331: LIST
93332: PPUSH
93333: CALL_OW 69
93337: ST_TO_ADDR
// if not tmp then
93338: LD_VAR 0 2
93342: NOT
93343: IFFALSE 93347
// exit ;
93345: GO 93376
// for i in tmp do
93347: LD_ADDR_VAR 0 1
93351: PUSH
93352: LD_VAR 0 2
93356: PUSH
93357: FOR_IN
93358: IFFALSE 93374
// SetBLevel ( i , 10 ) ;
93360: LD_VAR 0 1
93364: PPUSH
93365: LD_INT 10
93367: PPUSH
93368: CALL_OW 241
93372: GO 93357
93374: POP
93375: POP
// end ;
93376: PPOPN 2
93378: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93379: LD_EXP 131
93383: PUSH
93384: LD_EXP 148
93388: AND
93389: IFFALSE 93500
93391: GO 93393
93393: DISABLE
93394: LD_INT 0
93396: PPUSH
93397: PPUSH
93398: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93399: LD_ADDR_VAR 0 3
93403: PUSH
93404: LD_INT 22
93406: PUSH
93407: LD_OWVAR 2
93411: PUSH
93412: EMPTY
93413: LIST
93414: LIST
93415: PUSH
93416: LD_INT 25
93418: PUSH
93419: LD_INT 1
93421: PUSH
93422: EMPTY
93423: LIST
93424: LIST
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PPUSH
93430: CALL_OW 69
93434: ST_TO_ADDR
// if not tmp then
93435: LD_VAR 0 3
93439: NOT
93440: IFFALSE 93444
// exit ;
93442: GO 93500
// un := tmp [ rand ( 1 , tmp ) ] ;
93444: LD_ADDR_VAR 0 2
93448: PUSH
93449: LD_VAR 0 3
93453: PUSH
93454: LD_INT 1
93456: PPUSH
93457: LD_VAR 0 3
93461: PPUSH
93462: CALL_OW 12
93466: ARRAY
93467: ST_TO_ADDR
// if Crawls ( un ) then
93468: LD_VAR 0 2
93472: PPUSH
93473: CALL_OW 318
93477: IFFALSE 93488
// ComWalk ( un ) ;
93479: LD_VAR 0 2
93483: PPUSH
93484: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93488: LD_VAR 0 2
93492: PPUSH
93493: LD_INT 5
93495: PPUSH
93496: CALL_OW 336
// end ;
93500: PPOPN 3
93502: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
93503: LD_EXP 131
93507: PUSH
93508: LD_EXP 149
93512: AND
93513: PUSH
93514: LD_OWVAR 67
93518: PUSH
93519: LD_INT 3
93521: LESS
93522: AND
93523: IFFALSE 93542
93525: GO 93527
93527: DISABLE
// Difficulty := Difficulty + 1 ;
93528: LD_ADDR_OWVAR 67
93532: PUSH
93533: LD_OWVAR 67
93537: PUSH
93538: LD_INT 1
93540: PLUS
93541: ST_TO_ADDR
93542: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93543: LD_EXP 131
93547: PUSH
93548: LD_EXP 150
93552: AND
93553: IFFALSE 93656
93555: GO 93557
93557: DISABLE
93558: LD_INT 0
93560: PPUSH
// begin for i := 1 to 5 do
93561: LD_ADDR_VAR 0 1
93565: PUSH
93566: DOUBLE
93567: LD_INT 1
93569: DEC
93570: ST_TO_ADDR
93571: LD_INT 5
93573: PUSH
93574: FOR_TO
93575: IFFALSE 93654
// begin uc_nation := nation_nature ;
93577: LD_ADDR_OWVAR 21
93581: PUSH
93582: LD_INT 0
93584: ST_TO_ADDR
// uc_side := 0 ;
93585: LD_ADDR_OWVAR 20
93589: PUSH
93590: LD_INT 0
93592: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93593: LD_ADDR_OWVAR 29
93597: PUSH
93598: LD_INT 12
93600: PUSH
93601: LD_INT 12
93603: PUSH
93604: EMPTY
93605: LIST
93606: LIST
93607: ST_TO_ADDR
// hc_agressivity := 20 ;
93608: LD_ADDR_OWVAR 35
93612: PUSH
93613: LD_INT 20
93615: ST_TO_ADDR
// hc_class := class_tiger ;
93616: LD_ADDR_OWVAR 28
93620: PUSH
93621: LD_INT 14
93623: ST_TO_ADDR
// hc_gallery :=  ;
93624: LD_ADDR_OWVAR 33
93628: PUSH
93629: LD_STRING 
93631: ST_TO_ADDR
// hc_name :=  ;
93632: LD_ADDR_OWVAR 26
93636: PUSH
93637: LD_STRING 
93639: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93640: CALL_OW 44
93644: PPUSH
93645: LD_INT 0
93647: PPUSH
93648: CALL_OW 51
// end ;
93652: GO 93574
93654: POP
93655: POP
// end ;
93656: PPOPN 1
93658: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93659: LD_EXP 131
93663: PUSH
93664: LD_EXP 151
93668: AND
93669: IFFALSE 93678
93671: GO 93673
93673: DISABLE
// StreamSibBomb ;
93674: CALL 93679 0 0
93678: END
// export function StreamSibBomb ; var i , x , y ; begin
93679: LD_INT 0
93681: PPUSH
93682: PPUSH
93683: PPUSH
93684: PPUSH
// result := false ;
93685: LD_ADDR_VAR 0 1
93689: PUSH
93690: LD_INT 0
93692: ST_TO_ADDR
// for i := 1 to 16 do
93693: LD_ADDR_VAR 0 2
93697: PUSH
93698: DOUBLE
93699: LD_INT 1
93701: DEC
93702: ST_TO_ADDR
93703: LD_INT 16
93705: PUSH
93706: FOR_TO
93707: IFFALSE 93906
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93709: LD_ADDR_VAR 0 3
93713: PUSH
93714: LD_INT 10
93716: PUSH
93717: LD_INT 20
93719: PUSH
93720: LD_INT 30
93722: PUSH
93723: LD_INT 40
93725: PUSH
93726: LD_INT 50
93728: PUSH
93729: LD_INT 60
93731: PUSH
93732: LD_INT 70
93734: PUSH
93735: LD_INT 80
93737: PUSH
93738: LD_INT 90
93740: PUSH
93741: LD_INT 100
93743: PUSH
93744: LD_INT 110
93746: PUSH
93747: LD_INT 120
93749: PUSH
93750: LD_INT 130
93752: PUSH
93753: LD_INT 140
93755: PUSH
93756: LD_INT 150
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: PUSH
93776: LD_INT 1
93778: PPUSH
93779: LD_INT 15
93781: PPUSH
93782: CALL_OW 12
93786: ARRAY
93787: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93788: LD_ADDR_VAR 0 4
93792: PUSH
93793: LD_INT 10
93795: PUSH
93796: LD_INT 20
93798: PUSH
93799: LD_INT 30
93801: PUSH
93802: LD_INT 40
93804: PUSH
93805: LD_INT 50
93807: PUSH
93808: LD_INT 60
93810: PUSH
93811: LD_INT 70
93813: PUSH
93814: LD_INT 80
93816: PUSH
93817: LD_INT 90
93819: PUSH
93820: LD_INT 100
93822: PUSH
93823: LD_INT 110
93825: PUSH
93826: LD_INT 120
93828: PUSH
93829: LD_INT 130
93831: PUSH
93832: LD_INT 140
93834: PUSH
93835: LD_INT 150
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: LIST
93842: LIST
93843: LIST
93844: LIST
93845: LIST
93846: LIST
93847: LIST
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: PUSH
93855: LD_INT 1
93857: PPUSH
93858: LD_INT 15
93860: PPUSH
93861: CALL_OW 12
93865: ARRAY
93866: ST_TO_ADDR
// if ValidHex ( x , y ) then
93867: LD_VAR 0 3
93871: PPUSH
93872: LD_VAR 0 4
93876: PPUSH
93877: CALL_OW 488
93881: IFFALSE 93904
// begin result := [ x , y ] ;
93883: LD_ADDR_VAR 0 1
93887: PUSH
93888: LD_VAR 0 3
93892: PUSH
93893: LD_VAR 0 4
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: ST_TO_ADDR
// break ;
93902: GO 93906
// end ; end ;
93904: GO 93706
93906: POP
93907: POP
// if result then
93908: LD_VAR 0 1
93912: IFFALSE 93972
// begin ToLua ( playSibBomb() ) ;
93914: LD_STRING playSibBomb()
93916: PPUSH
93917: CALL_OW 559
// wait ( 0 0$14 ) ;
93921: LD_INT 490
93923: PPUSH
93924: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
93928: LD_VAR 0 1
93932: PUSH
93933: LD_INT 1
93935: ARRAY
93936: PPUSH
93937: LD_VAR 0 1
93941: PUSH
93942: LD_INT 2
93944: ARRAY
93945: PPUSH
93946: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
93950: LD_VAR 0 1
93954: PUSH
93955: LD_INT 1
93957: ARRAY
93958: PPUSH
93959: LD_VAR 0 1
93963: PUSH
93964: LD_INT 2
93966: ARRAY
93967: PPUSH
93968: CALL_OW 429
// end ; end ;
93972: LD_VAR 0 1
93976: RET
// every 0 0$1 trigger StreamModeActive and sReset do
93977: LD_EXP 131
93981: PUSH
93982: LD_EXP 153
93986: AND
93987: IFFALSE 93999
93989: GO 93991
93991: DISABLE
// YouLost (  ) ;
93992: LD_STRING 
93994: PPUSH
93995: CALL_OW 104
93999: END
// every 0 0$1 trigger StreamModeActive and sFog do
94000: LD_EXP 131
94004: PUSH
94005: LD_EXP 152
94009: AND
94010: IFFALSE 94024
94012: GO 94014
94014: DISABLE
// FogOff ( your_side ) ;
94015: LD_OWVAR 2
94019: PPUSH
94020: CALL_OW 344
94024: END
// every 0 0$1 trigger StreamModeActive and sSun do
94025: LD_EXP 131
94029: PUSH
94030: LD_EXP 154
94034: AND
94035: IFFALSE 94063
94037: GO 94039
94039: DISABLE
// begin solar_recharge_percent := 0 ;
94040: LD_ADDR_OWVAR 79
94044: PUSH
94045: LD_INT 0
94047: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94048: LD_INT 10500
94050: PPUSH
94051: CALL_OW 67
// solar_recharge_percent := 100 ;
94055: LD_ADDR_OWVAR 79
94059: PUSH
94060: LD_INT 100
94062: ST_TO_ADDR
// end ;
94063: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94064: LD_EXP 131
94068: PUSH
94069: LD_EXP 155
94073: AND
94074: IFFALSE 94313
94076: GO 94078
94078: DISABLE
94079: LD_INT 0
94081: PPUSH
94082: PPUSH
94083: PPUSH
// begin tmp := [ ] ;
94084: LD_ADDR_VAR 0 3
94088: PUSH
94089: EMPTY
94090: ST_TO_ADDR
// for i := 1 to 6 do
94091: LD_ADDR_VAR 0 1
94095: PUSH
94096: DOUBLE
94097: LD_INT 1
94099: DEC
94100: ST_TO_ADDR
94101: LD_INT 6
94103: PUSH
94104: FOR_TO
94105: IFFALSE 94210
// begin uc_nation := nation_nature ;
94107: LD_ADDR_OWVAR 21
94111: PUSH
94112: LD_INT 0
94114: ST_TO_ADDR
// uc_side := 0 ;
94115: LD_ADDR_OWVAR 20
94119: PUSH
94120: LD_INT 0
94122: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94123: LD_ADDR_OWVAR 29
94127: PUSH
94128: LD_INT 12
94130: PUSH
94131: LD_INT 12
94133: PUSH
94134: EMPTY
94135: LIST
94136: LIST
94137: ST_TO_ADDR
// hc_agressivity := 20 ;
94138: LD_ADDR_OWVAR 35
94142: PUSH
94143: LD_INT 20
94145: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94146: LD_ADDR_OWVAR 28
94150: PUSH
94151: LD_INT 17
94153: ST_TO_ADDR
// hc_gallery :=  ;
94154: LD_ADDR_OWVAR 33
94158: PUSH
94159: LD_STRING 
94161: ST_TO_ADDR
// hc_name :=  ;
94162: LD_ADDR_OWVAR 26
94166: PUSH
94167: LD_STRING 
94169: ST_TO_ADDR
// un := CreateHuman ;
94170: LD_ADDR_VAR 0 2
94174: PUSH
94175: CALL_OW 44
94179: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94180: LD_VAR 0 2
94184: PPUSH
94185: LD_INT 1
94187: PPUSH
94188: CALL_OW 51
// tmp := tmp ^ un ;
94192: LD_ADDR_VAR 0 3
94196: PUSH
94197: LD_VAR 0 3
94201: PUSH
94202: LD_VAR 0 2
94206: ADD
94207: ST_TO_ADDR
// end ;
94208: GO 94104
94210: POP
94211: POP
// repeat wait ( 0 0$1 ) ;
94212: LD_INT 35
94214: PPUSH
94215: CALL_OW 67
// for un in tmp do
94219: LD_ADDR_VAR 0 2
94223: PUSH
94224: LD_VAR 0 3
94228: PUSH
94229: FOR_IN
94230: IFFALSE 94304
// begin if IsDead ( un ) then
94232: LD_VAR 0 2
94236: PPUSH
94237: CALL_OW 301
94241: IFFALSE 94261
// begin tmp := tmp diff un ;
94243: LD_ADDR_VAR 0 3
94247: PUSH
94248: LD_VAR 0 3
94252: PUSH
94253: LD_VAR 0 2
94257: DIFF
94258: ST_TO_ADDR
// continue ;
94259: GO 94229
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94261: LD_VAR 0 2
94265: PPUSH
94266: LD_INT 3
94268: PUSH
94269: LD_INT 22
94271: PUSH
94272: LD_INT 0
94274: PUSH
94275: EMPTY
94276: LIST
94277: LIST
94278: PUSH
94279: EMPTY
94280: LIST
94281: LIST
94282: PPUSH
94283: CALL_OW 69
94287: PPUSH
94288: LD_VAR 0 2
94292: PPUSH
94293: CALL_OW 74
94297: PPUSH
94298: CALL_OW 115
// end ;
94302: GO 94229
94304: POP
94305: POP
// until not tmp ;
94306: LD_VAR 0 3
94310: NOT
94311: IFFALSE 94212
// end ;
94313: PPOPN 3
94315: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94316: LD_EXP 131
94320: PUSH
94321: LD_EXP 156
94325: AND
94326: IFFALSE 94380
94328: GO 94330
94330: DISABLE
// begin ToLua ( displayTroll(); ) ;
94331: LD_STRING displayTroll();
94333: PPUSH
94334: CALL_OW 559
// wait ( 3 3$00 ) ;
94338: LD_INT 6300
94340: PPUSH
94341: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94345: LD_STRING hideTroll();
94347: PPUSH
94348: CALL_OW 559
// wait ( 1 1$00 ) ;
94352: LD_INT 2100
94354: PPUSH
94355: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94359: LD_STRING displayTroll();
94361: PPUSH
94362: CALL_OW 559
// wait ( 1 1$00 ) ;
94366: LD_INT 2100
94368: PPUSH
94369: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94373: LD_STRING hideTroll();
94375: PPUSH
94376: CALL_OW 559
// end ;
94380: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94381: LD_EXP 131
94385: PUSH
94386: LD_EXP 157
94390: AND
94391: IFFALSE 94454
94393: GO 94395
94395: DISABLE
94396: LD_INT 0
94398: PPUSH
// begin p := 0 ;
94399: LD_ADDR_VAR 0 1
94403: PUSH
94404: LD_INT 0
94406: ST_TO_ADDR
// repeat game_speed := 1 ;
94407: LD_ADDR_OWVAR 65
94411: PUSH
94412: LD_INT 1
94414: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94415: LD_INT 35
94417: PPUSH
94418: CALL_OW 67
// p := p + 1 ;
94422: LD_ADDR_VAR 0 1
94426: PUSH
94427: LD_VAR 0 1
94431: PUSH
94432: LD_INT 1
94434: PLUS
94435: ST_TO_ADDR
// until p >= 60 ;
94436: LD_VAR 0 1
94440: PUSH
94441: LD_INT 60
94443: GREATEREQUAL
94444: IFFALSE 94407
// game_speed := 4 ;
94446: LD_ADDR_OWVAR 65
94450: PUSH
94451: LD_INT 4
94453: ST_TO_ADDR
// end ;
94454: PPOPN 1
94456: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94457: LD_EXP 131
94461: PUSH
94462: LD_EXP 158
94466: AND
94467: IFFALSE 94613
94469: GO 94471
94471: DISABLE
94472: LD_INT 0
94474: PPUSH
94475: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94476: LD_ADDR_VAR 0 1
94480: PUSH
94481: LD_INT 22
94483: PUSH
94484: LD_OWVAR 2
94488: PUSH
94489: EMPTY
94490: LIST
94491: LIST
94492: PUSH
94493: LD_INT 2
94495: PUSH
94496: LD_INT 30
94498: PUSH
94499: LD_INT 0
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: PUSH
94506: LD_INT 30
94508: PUSH
94509: LD_INT 1
94511: PUSH
94512: EMPTY
94513: LIST
94514: LIST
94515: PUSH
94516: EMPTY
94517: LIST
94518: LIST
94519: LIST
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PPUSH
94525: CALL_OW 69
94529: ST_TO_ADDR
// if not depot then
94530: LD_VAR 0 1
94534: NOT
94535: IFFALSE 94539
// exit ;
94537: GO 94613
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94539: LD_ADDR_VAR 0 2
94543: PUSH
94544: LD_VAR 0 1
94548: PUSH
94549: LD_INT 1
94551: PPUSH
94552: LD_VAR 0 1
94556: PPUSH
94557: CALL_OW 12
94561: ARRAY
94562: PPUSH
94563: CALL_OW 274
94567: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94568: LD_VAR 0 2
94572: PPUSH
94573: LD_INT 1
94575: PPUSH
94576: LD_INT 0
94578: PPUSH
94579: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94583: LD_VAR 0 2
94587: PPUSH
94588: LD_INT 2
94590: PPUSH
94591: LD_INT 0
94593: PPUSH
94594: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94598: LD_VAR 0 2
94602: PPUSH
94603: LD_INT 3
94605: PPUSH
94606: LD_INT 0
94608: PPUSH
94609: CALL_OW 277
// end ;
94613: PPOPN 2
94615: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94616: LD_EXP 131
94620: PUSH
94621: LD_EXP 159
94625: AND
94626: IFFALSE 94723
94628: GO 94630
94630: DISABLE
94631: LD_INT 0
94633: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94634: LD_ADDR_VAR 0 1
94638: PUSH
94639: LD_INT 22
94641: PUSH
94642: LD_OWVAR 2
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 21
94653: PUSH
94654: LD_INT 1
94656: PUSH
94657: EMPTY
94658: LIST
94659: LIST
94660: PUSH
94661: LD_INT 3
94663: PUSH
94664: LD_INT 23
94666: PUSH
94667: LD_INT 0
94669: PUSH
94670: EMPTY
94671: LIST
94672: LIST
94673: PUSH
94674: EMPTY
94675: LIST
94676: LIST
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: LIST
94682: PPUSH
94683: CALL_OW 69
94687: ST_TO_ADDR
// if not tmp then
94688: LD_VAR 0 1
94692: NOT
94693: IFFALSE 94697
// exit ;
94695: GO 94723
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
94697: LD_VAR 0 1
94701: PUSH
94702: LD_INT 1
94704: PPUSH
94705: LD_VAR 0 1
94709: PPUSH
94710: CALL_OW 12
94714: ARRAY
94715: PPUSH
94716: LD_INT 200
94718: PPUSH
94719: CALL_OW 234
// end ;
94723: PPOPN 1
94725: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
94726: LD_EXP 131
94730: PUSH
94731: LD_EXP 160
94735: AND
94736: IFFALSE 94815
94738: GO 94740
94740: DISABLE
94741: LD_INT 0
94743: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
94744: LD_ADDR_VAR 0 1
94748: PUSH
94749: LD_INT 22
94751: PUSH
94752: LD_OWVAR 2
94756: PUSH
94757: EMPTY
94758: LIST
94759: LIST
94760: PUSH
94761: LD_INT 21
94763: PUSH
94764: LD_INT 2
94766: PUSH
94767: EMPTY
94768: LIST
94769: LIST
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: PPUSH
94775: CALL_OW 69
94779: ST_TO_ADDR
// if not tmp then
94780: LD_VAR 0 1
94784: NOT
94785: IFFALSE 94789
// exit ;
94787: GO 94815
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
94789: LD_VAR 0 1
94793: PUSH
94794: LD_INT 1
94796: PPUSH
94797: LD_VAR 0 1
94801: PPUSH
94802: CALL_OW 12
94806: ARRAY
94807: PPUSH
94808: LD_INT 60
94810: PPUSH
94811: CALL_OW 234
// end ;
94815: PPOPN 1
94817: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
94818: LD_EXP 131
94822: PUSH
94823: LD_EXP 161
94827: AND
94828: IFFALSE 94927
94830: GO 94832
94832: DISABLE
94833: LD_INT 0
94835: PPUSH
94836: PPUSH
// begin enable ;
94837: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
94838: LD_ADDR_VAR 0 1
94842: PUSH
94843: LD_INT 22
94845: PUSH
94846: LD_OWVAR 2
94850: PUSH
94851: EMPTY
94852: LIST
94853: LIST
94854: PUSH
94855: LD_INT 61
94857: PUSH
94858: EMPTY
94859: LIST
94860: PUSH
94861: LD_INT 33
94863: PUSH
94864: LD_INT 2
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: PUSH
94871: EMPTY
94872: LIST
94873: LIST
94874: LIST
94875: PPUSH
94876: CALL_OW 69
94880: ST_TO_ADDR
// if not tmp then
94881: LD_VAR 0 1
94885: NOT
94886: IFFALSE 94890
// exit ;
94888: GO 94927
// for i in tmp do
94890: LD_ADDR_VAR 0 2
94894: PUSH
94895: LD_VAR 0 1
94899: PUSH
94900: FOR_IN
94901: IFFALSE 94925
// if IsControledBy ( i ) then
94903: LD_VAR 0 2
94907: PPUSH
94908: CALL_OW 312
94912: IFFALSE 94923
// ComUnlink ( i ) ;
94914: LD_VAR 0 2
94918: PPUSH
94919: CALL_OW 136
94923: GO 94900
94925: POP
94926: POP
// end ;
94927: PPOPN 2
94929: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
94930: LD_EXP 131
94934: PUSH
94935: LD_EXP 162
94939: AND
94940: IFFALSE 95080
94942: GO 94944
94944: DISABLE
94945: LD_INT 0
94947: PPUSH
94948: PPUSH
// begin ToLua ( displayPowell(); ) ;
94949: LD_STRING displayPowell();
94951: PPUSH
94952: CALL_OW 559
// uc_side := 0 ;
94956: LD_ADDR_OWVAR 20
94960: PUSH
94961: LD_INT 0
94963: ST_TO_ADDR
// uc_nation := 2 ;
94964: LD_ADDR_OWVAR 21
94968: PUSH
94969: LD_INT 2
94971: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
94972: LD_ADDR_OWVAR 37
94976: PUSH
94977: LD_INT 14
94979: ST_TO_ADDR
// vc_engine := engine_siberite ;
94980: LD_ADDR_OWVAR 39
94984: PUSH
94985: LD_INT 3
94987: ST_TO_ADDR
// vc_control := control_apeman ;
94988: LD_ADDR_OWVAR 38
94992: PUSH
94993: LD_INT 5
94995: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
94996: LD_ADDR_OWVAR 40
95000: PUSH
95001: LD_INT 29
95003: ST_TO_ADDR
// un := CreateVehicle ;
95004: LD_ADDR_VAR 0 2
95008: PUSH
95009: CALL_OW 45
95013: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95014: LD_VAR 0 2
95018: PPUSH
95019: LD_INT 1
95021: PPUSH
95022: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95026: LD_INT 35
95028: PPUSH
95029: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95033: LD_VAR 0 2
95037: PPUSH
95038: LD_INT 22
95040: PUSH
95041: LD_OWVAR 2
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PPUSH
95050: CALL_OW 69
95054: PPUSH
95055: LD_VAR 0 2
95059: PPUSH
95060: CALL_OW 74
95064: PPUSH
95065: CALL_OW 115
// until IsDead ( un ) ;
95069: LD_VAR 0 2
95073: PPUSH
95074: CALL_OW 301
95078: IFFALSE 95026
// end ;
95080: PPOPN 2
95082: END
// every 0 0$1 trigger StreamModeActive and sStu do
95083: LD_EXP 131
95087: PUSH
95088: LD_EXP 170
95092: AND
95093: IFFALSE 95109
95095: GO 95097
95097: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95098: LD_STRING displayStucuk();
95100: PPUSH
95101: CALL_OW 559
// ResetFog ;
95105: CALL_OW 335
// end ;
95109: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95110: LD_EXP 131
95114: PUSH
95115: LD_EXP 163
95119: AND
95120: IFFALSE 95261
95122: GO 95124
95124: DISABLE
95125: LD_INT 0
95127: PPUSH
95128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95129: LD_ADDR_VAR 0 2
95133: PUSH
95134: LD_INT 22
95136: PUSH
95137: LD_OWVAR 2
95141: PUSH
95142: EMPTY
95143: LIST
95144: LIST
95145: PUSH
95146: LD_INT 21
95148: PUSH
95149: LD_INT 1
95151: PUSH
95152: EMPTY
95153: LIST
95154: LIST
95155: PUSH
95156: EMPTY
95157: LIST
95158: LIST
95159: PPUSH
95160: CALL_OW 69
95164: ST_TO_ADDR
// if not tmp then
95165: LD_VAR 0 2
95169: NOT
95170: IFFALSE 95174
// exit ;
95172: GO 95261
// un := tmp [ rand ( 1 , tmp ) ] ;
95174: LD_ADDR_VAR 0 1
95178: PUSH
95179: LD_VAR 0 2
95183: PUSH
95184: LD_INT 1
95186: PPUSH
95187: LD_VAR 0 2
95191: PPUSH
95192: CALL_OW 12
95196: ARRAY
95197: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95198: LD_VAR 0 1
95202: PPUSH
95203: LD_INT 0
95205: PPUSH
95206: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95210: LD_VAR 0 1
95214: PPUSH
95215: LD_OWVAR 3
95219: PUSH
95220: LD_VAR 0 1
95224: DIFF
95225: PPUSH
95226: LD_VAR 0 1
95230: PPUSH
95231: CALL_OW 74
95235: PPUSH
95236: CALL_OW 115
// wait ( 0 0$20 ) ;
95240: LD_INT 700
95242: PPUSH
95243: CALL_OW 67
// SetSide ( un , your_side ) ;
95247: LD_VAR 0 1
95251: PPUSH
95252: LD_OWVAR 2
95256: PPUSH
95257: CALL_OW 235
// end ;
95261: PPOPN 2
95263: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95264: LD_EXP 131
95268: PUSH
95269: LD_EXP 164
95273: AND
95274: IFFALSE 95380
95276: GO 95278
95278: DISABLE
95279: LD_INT 0
95281: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95282: LD_ADDR_VAR 0 1
95286: PUSH
95287: LD_INT 22
95289: PUSH
95290: LD_OWVAR 2
95294: PUSH
95295: EMPTY
95296: LIST
95297: LIST
95298: PUSH
95299: LD_INT 2
95301: PUSH
95302: LD_INT 30
95304: PUSH
95305: LD_INT 0
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: PUSH
95312: LD_INT 30
95314: PUSH
95315: LD_INT 1
95317: PUSH
95318: EMPTY
95319: LIST
95320: LIST
95321: PUSH
95322: EMPTY
95323: LIST
95324: LIST
95325: LIST
95326: PUSH
95327: EMPTY
95328: LIST
95329: LIST
95330: PPUSH
95331: CALL_OW 69
95335: ST_TO_ADDR
// if not depot then
95336: LD_VAR 0 1
95340: NOT
95341: IFFALSE 95345
// exit ;
95343: GO 95380
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95345: LD_VAR 0 1
95349: PUSH
95350: LD_INT 1
95352: ARRAY
95353: PPUSH
95354: CALL_OW 250
95358: PPUSH
95359: LD_VAR 0 1
95363: PUSH
95364: LD_INT 1
95366: ARRAY
95367: PPUSH
95368: CALL_OW 251
95372: PPUSH
95373: LD_INT 70
95375: PPUSH
95376: CALL_OW 495
// end ;
95380: PPOPN 1
95382: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95383: LD_EXP 131
95387: PUSH
95388: LD_EXP 165
95392: AND
95393: IFFALSE 95604
95395: GO 95397
95397: DISABLE
95398: LD_INT 0
95400: PPUSH
95401: PPUSH
95402: PPUSH
95403: PPUSH
95404: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95405: LD_ADDR_VAR 0 5
95409: PUSH
95410: LD_INT 22
95412: PUSH
95413: LD_OWVAR 2
95417: PUSH
95418: EMPTY
95419: LIST
95420: LIST
95421: PUSH
95422: LD_INT 21
95424: PUSH
95425: LD_INT 1
95427: PUSH
95428: EMPTY
95429: LIST
95430: LIST
95431: PUSH
95432: EMPTY
95433: LIST
95434: LIST
95435: PPUSH
95436: CALL_OW 69
95440: ST_TO_ADDR
// if not tmp then
95441: LD_VAR 0 5
95445: NOT
95446: IFFALSE 95450
// exit ;
95448: GO 95604
// for i in tmp do
95450: LD_ADDR_VAR 0 1
95454: PUSH
95455: LD_VAR 0 5
95459: PUSH
95460: FOR_IN
95461: IFFALSE 95602
// begin d := rand ( 0 , 5 ) ;
95463: LD_ADDR_VAR 0 4
95467: PUSH
95468: LD_INT 0
95470: PPUSH
95471: LD_INT 5
95473: PPUSH
95474: CALL_OW 12
95478: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95479: LD_ADDR_VAR 0 2
95483: PUSH
95484: LD_VAR 0 1
95488: PPUSH
95489: CALL_OW 250
95493: PPUSH
95494: LD_VAR 0 4
95498: PPUSH
95499: LD_INT 3
95501: PPUSH
95502: LD_INT 12
95504: PPUSH
95505: CALL_OW 12
95509: PPUSH
95510: CALL_OW 272
95514: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95515: LD_ADDR_VAR 0 3
95519: PUSH
95520: LD_VAR 0 1
95524: PPUSH
95525: CALL_OW 251
95529: PPUSH
95530: LD_VAR 0 4
95534: PPUSH
95535: LD_INT 3
95537: PPUSH
95538: LD_INT 12
95540: PPUSH
95541: CALL_OW 12
95545: PPUSH
95546: CALL_OW 273
95550: ST_TO_ADDR
// if ValidHex ( x , y ) then
95551: LD_VAR 0 2
95555: PPUSH
95556: LD_VAR 0 3
95560: PPUSH
95561: CALL_OW 488
95565: IFFALSE 95600
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95567: LD_VAR 0 1
95571: PPUSH
95572: LD_VAR 0 2
95576: PPUSH
95577: LD_VAR 0 3
95581: PPUSH
95582: LD_INT 3
95584: PPUSH
95585: LD_INT 6
95587: PPUSH
95588: CALL_OW 12
95592: PPUSH
95593: LD_INT 1
95595: PPUSH
95596: CALL_OW 483
// end ;
95600: GO 95460
95602: POP
95603: POP
// end ;
95604: PPOPN 5
95606: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95607: LD_EXP 131
95611: PUSH
95612: LD_EXP 166
95616: AND
95617: IFFALSE 95711
95619: GO 95621
95621: DISABLE
95622: LD_INT 0
95624: PPUSH
95625: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95626: LD_ADDR_VAR 0 2
95630: PUSH
95631: LD_INT 22
95633: PUSH
95634: LD_OWVAR 2
95638: PUSH
95639: EMPTY
95640: LIST
95641: LIST
95642: PUSH
95643: LD_INT 32
95645: PUSH
95646: LD_INT 1
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: PUSH
95653: LD_INT 21
95655: PUSH
95656: LD_INT 2
95658: PUSH
95659: EMPTY
95660: LIST
95661: LIST
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: LIST
95667: PPUSH
95668: CALL_OW 69
95672: ST_TO_ADDR
// if not tmp then
95673: LD_VAR 0 2
95677: NOT
95678: IFFALSE 95682
// exit ;
95680: GO 95711
// for i in tmp do
95682: LD_ADDR_VAR 0 1
95686: PUSH
95687: LD_VAR 0 2
95691: PUSH
95692: FOR_IN
95693: IFFALSE 95709
// SetFuel ( i , 0 ) ;
95695: LD_VAR 0 1
95699: PPUSH
95700: LD_INT 0
95702: PPUSH
95703: CALL_OW 240
95707: GO 95692
95709: POP
95710: POP
// end ;
95711: PPOPN 2
95713: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
95714: LD_EXP 131
95718: PUSH
95719: LD_EXP 167
95723: AND
95724: IFFALSE 95790
95726: GO 95728
95728: DISABLE
95729: LD_INT 0
95731: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95732: LD_ADDR_VAR 0 1
95736: PUSH
95737: LD_INT 22
95739: PUSH
95740: LD_OWVAR 2
95744: PUSH
95745: EMPTY
95746: LIST
95747: LIST
95748: PUSH
95749: LD_INT 30
95751: PUSH
95752: LD_INT 29
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: PUSH
95759: EMPTY
95760: LIST
95761: LIST
95762: PPUSH
95763: CALL_OW 69
95767: ST_TO_ADDR
// if not tmp then
95768: LD_VAR 0 1
95772: NOT
95773: IFFALSE 95777
// exit ;
95775: GO 95790
// DestroyUnit ( tmp [ 1 ] ) ;
95777: LD_VAR 0 1
95781: PUSH
95782: LD_INT 1
95784: ARRAY
95785: PPUSH
95786: CALL_OW 65
// end ;
95790: PPOPN 1
95792: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
95793: LD_EXP 131
95797: PUSH
95798: LD_EXP 169
95802: AND
95803: IFFALSE 95932
95805: GO 95807
95807: DISABLE
95808: LD_INT 0
95810: PPUSH
// begin uc_side := 0 ;
95811: LD_ADDR_OWVAR 20
95815: PUSH
95816: LD_INT 0
95818: ST_TO_ADDR
// uc_nation := nation_arabian ;
95819: LD_ADDR_OWVAR 21
95823: PUSH
95824: LD_INT 2
95826: ST_TO_ADDR
// hc_gallery :=  ;
95827: LD_ADDR_OWVAR 33
95831: PUSH
95832: LD_STRING 
95834: ST_TO_ADDR
// hc_name :=  ;
95835: LD_ADDR_OWVAR 26
95839: PUSH
95840: LD_STRING 
95842: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
95843: LD_INT 1
95845: PPUSH
95846: LD_INT 11
95848: PPUSH
95849: LD_INT 10
95851: PPUSH
95852: CALL_OW 380
// un := CreateHuman ;
95856: LD_ADDR_VAR 0 1
95860: PUSH
95861: CALL_OW 44
95865: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95866: LD_VAR 0 1
95870: PPUSH
95871: LD_INT 1
95873: PPUSH
95874: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95878: LD_INT 35
95880: PPUSH
95881: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95885: LD_VAR 0 1
95889: PPUSH
95890: LD_INT 22
95892: PUSH
95893: LD_OWVAR 2
95897: PUSH
95898: EMPTY
95899: LIST
95900: LIST
95901: PPUSH
95902: CALL_OW 69
95906: PPUSH
95907: LD_VAR 0 1
95911: PPUSH
95912: CALL_OW 74
95916: PPUSH
95917: CALL_OW 115
// until IsDead ( un ) ;
95921: LD_VAR 0 1
95925: PPUSH
95926: CALL_OW 301
95930: IFFALSE 95878
// end ;
95932: PPOPN 1
95934: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
95935: LD_EXP 131
95939: PUSH
95940: LD_EXP 171
95944: AND
95945: IFFALSE 95957
95947: GO 95949
95949: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
95950: LD_STRING earthquake(getX(game), 0, 32)
95952: PPUSH
95953: CALL_OW 559
95957: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
95958: LD_EXP 131
95962: PUSH
95963: LD_EXP 172
95967: AND
95968: IFFALSE 96059
95970: GO 95972
95972: DISABLE
95973: LD_INT 0
95975: PPUSH
// begin enable ;
95976: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
95977: LD_ADDR_VAR 0 1
95981: PUSH
95982: LD_INT 22
95984: PUSH
95985: LD_OWVAR 2
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: PUSH
95994: LD_INT 21
95996: PUSH
95997: LD_INT 2
95999: PUSH
96000: EMPTY
96001: LIST
96002: LIST
96003: PUSH
96004: LD_INT 33
96006: PUSH
96007: LD_INT 3
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: LIST
96018: PPUSH
96019: CALL_OW 69
96023: ST_TO_ADDR
// if not tmp then
96024: LD_VAR 0 1
96028: NOT
96029: IFFALSE 96033
// exit ;
96031: GO 96059
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96033: LD_VAR 0 1
96037: PUSH
96038: LD_INT 1
96040: PPUSH
96041: LD_VAR 0 1
96045: PPUSH
96046: CALL_OW 12
96050: ARRAY
96051: PPUSH
96052: LD_INT 1
96054: PPUSH
96055: CALL_OW 234
// end ;
96059: PPOPN 1
96061: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96062: LD_EXP 131
96066: PUSH
96067: LD_EXP 173
96071: AND
96072: IFFALSE 96213
96074: GO 96076
96076: DISABLE
96077: LD_INT 0
96079: PPUSH
96080: PPUSH
96081: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96082: LD_ADDR_VAR 0 3
96086: PUSH
96087: LD_INT 22
96089: PUSH
96090: LD_OWVAR 2
96094: PUSH
96095: EMPTY
96096: LIST
96097: LIST
96098: PUSH
96099: LD_INT 25
96101: PUSH
96102: LD_INT 1
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PUSH
96109: EMPTY
96110: LIST
96111: LIST
96112: PPUSH
96113: CALL_OW 69
96117: ST_TO_ADDR
// if not tmp then
96118: LD_VAR 0 3
96122: NOT
96123: IFFALSE 96127
// exit ;
96125: GO 96213
// un := tmp [ rand ( 1 , tmp ) ] ;
96127: LD_ADDR_VAR 0 2
96131: PUSH
96132: LD_VAR 0 3
96136: PUSH
96137: LD_INT 1
96139: PPUSH
96140: LD_VAR 0 3
96144: PPUSH
96145: CALL_OW 12
96149: ARRAY
96150: ST_TO_ADDR
// if Crawls ( un ) then
96151: LD_VAR 0 2
96155: PPUSH
96156: CALL_OW 318
96160: IFFALSE 96171
// ComWalk ( un ) ;
96162: LD_VAR 0 2
96166: PPUSH
96167: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96171: LD_VAR 0 2
96175: PPUSH
96176: LD_INT 9
96178: PPUSH
96179: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96183: LD_INT 28
96185: PPUSH
96186: LD_OWVAR 2
96190: PPUSH
96191: LD_INT 2
96193: PPUSH
96194: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96198: LD_INT 29
96200: PPUSH
96201: LD_OWVAR 2
96205: PPUSH
96206: LD_INT 2
96208: PPUSH
96209: CALL_OW 322
// end ;
96213: PPOPN 3
96215: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96216: LD_EXP 131
96220: PUSH
96221: LD_EXP 174
96225: AND
96226: IFFALSE 96337
96228: GO 96230
96230: DISABLE
96231: LD_INT 0
96233: PPUSH
96234: PPUSH
96235: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96236: LD_ADDR_VAR 0 3
96240: PUSH
96241: LD_INT 22
96243: PUSH
96244: LD_OWVAR 2
96248: PUSH
96249: EMPTY
96250: LIST
96251: LIST
96252: PUSH
96253: LD_INT 25
96255: PUSH
96256: LD_INT 1
96258: PUSH
96259: EMPTY
96260: LIST
96261: LIST
96262: PUSH
96263: EMPTY
96264: LIST
96265: LIST
96266: PPUSH
96267: CALL_OW 69
96271: ST_TO_ADDR
// if not tmp then
96272: LD_VAR 0 3
96276: NOT
96277: IFFALSE 96281
// exit ;
96279: GO 96337
// un := tmp [ rand ( 1 , tmp ) ] ;
96281: LD_ADDR_VAR 0 2
96285: PUSH
96286: LD_VAR 0 3
96290: PUSH
96291: LD_INT 1
96293: PPUSH
96294: LD_VAR 0 3
96298: PPUSH
96299: CALL_OW 12
96303: ARRAY
96304: ST_TO_ADDR
// if Crawls ( un ) then
96305: LD_VAR 0 2
96309: PPUSH
96310: CALL_OW 318
96314: IFFALSE 96325
// ComWalk ( un ) ;
96316: LD_VAR 0 2
96320: PPUSH
96321: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96325: LD_VAR 0 2
96329: PPUSH
96330: LD_INT 8
96332: PPUSH
96333: CALL_OW 336
// end ;
96337: PPOPN 3
96339: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96340: LD_EXP 131
96344: PUSH
96345: LD_EXP 175
96349: AND
96350: IFFALSE 96494
96352: GO 96354
96354: DISABLE
96355: LD_INT 0
96357: PPUSH
96358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96359: LD_ADDR_VAR 0 2
96363: PUSH
96364: LD_INT 22
96366: PUSH
96367: LD_OWVAR 2
96371: PUSH
96372: EMPTY
96373: LIST
96374: LIST
96375: PUSH
96376: LD_INT 21
96378: PUSH
96379: LD_INT 2
96381: PUSH
96382: EMPTY
96383: LIST
96384: LIST
96385: PUSH
96386: LD_INT 2
96388: PUSH
96389: LD_INT 34
96391: PUSH
96392: LD_INT 12
96394: PUSH
96395: EMPTY
96396: LIST
96397: LIST
96398: PUSH
96399: LD_INT 34
96401: PUSH
96402: LD_INT 51
96404: PUSH
96405: EMPTY
96406: LIST
96407: LIST
96408: PUSH
96409: LD_INT 34
96411: PUSH
96412: LD_INT 32
96414: PUSH
96415: EMPTY
96416: LIST
96417: LIST
96418: PUSH
96419: EMPTY
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: PUSH
96425: EMPTY
96426: LIST
96427: LIST
96428: LIST
96429: PPUSH
96430: CALL_OW 69
96434: ST_TO_ADDR
// if not tmp then
96435: LD_VAR 0 2
96439: NOT
96440: IFFALSE 96444
// exit ;
96442: GO 96494
// for i in tmp do
96444: LD_ADDR_VAR 0 1
96448: PUSH
96449: LD_VAR 0 2
96453: PUSH
96454: FOR_IN
96455: IFFALSE 96492
// if GetCargo ( i , mat_artifact ) = 0 then
96457: LD_VAR 0 1
96461: PPUSH
96462: LD_INT 4
96464: PPUSH
96465: CALL_OW 289
96469: PUSH
96470: LD_INT 0
96472: EQUAL
96473: IFFALSE 96490
// SetCargo ( i , mat_siberit , 100 ) ;
96475: LD_VAR 0 1
96479: PPUSH
96480: LD_INT 3
96482: PPUSH
96483: LD_INT 100
96485: PPUSH
96486: CALL_OW 290
96490: GO 96454
96492: POP
96493: POP
// end ;
96494: PPOPN 2
96496: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96497: LD_EXP 131
96501: PUSH
96502: LD_EXP 176
96506: AND
96507: IFFALSE 96690
96509: GO 96511
96511: DISABLE
96512: LD_INT 0
96514: PPUSH
96515: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96516: LD_ADDR_VAR 0 2
96520: PUSH
96521: LD_INT 22
96523: PUSH
96524: LD_OWVAR 2
96528: PUSH
96529: EMPTY
96530: LIST
96531: LIST
96532: PPUSH
96533: CALL_OW 69
96537: ST_TO_ADDR
// if not tmp then
96538: LD_VAR 0 2
96542: NOT
96543: IFFALSE 96547
// exit ;
96545: GO 96690
// for i := 1 to 2 do
96547: LD_ADDR_VAR 0 1
96551: PUSH
96552: DOUBLE
96553: LD_INT 1
96555: DEC
96556: ST_TO_ADDR
96557: LD_INT 2
96559: PUSH
96560: FOR_TO
96561: IFFALSE 96688
// begin uc_side := your_side ;
96563: LD_ADDR_OWVAR 20
96567: PUSH
96568: LD_OWVAR 2
96572: ST_TO_ADDR
// uc_nation := nation_american ;
96573: LD_ADDR_OWVAR 21
96577: PUSH
96578: LD_INT 1
96580: ST_TO_ADDR
// vc_chassis := us_morphling ;
96581: LD_ADDR_OWVAR 37
96585: PUSH
96586: LD_INT 5
96588: ST_TO_ADDR
// vc_engine := engine_siberite ;
96589: LD_ADDR_OWVAR 39
96593: PUSH
96594: LD_INT 3
96596: ST_TO_ADDR
// vc_control := control_computer ;
96597: LD_ADDR_OWVAR 38
96601: PUSH
96602: LD_INT 3
96604: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96605: LD_ADDR_OWVAR 40
96609: PUSH
96610: LD_INT 10
96612: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
96613: LD_VAR 0 2
96617: PUSH
96618: LD_INT 1
96620: ARRAY
96621: PPUSH
96622: CALL_OW 310
96626: NOT
96627: IFFALSE 96674
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
96629: CALL_OW 45
96633: PPUSH
96634: LD_VAR 0 2
96638: PUSH
96639: LD_INT 1
96641: ARRAY
96642: PPUSH
96643: CALL_OW 250
96647: PPUSH
96648: LD_VAR 0 2
96652: PUSH
96653: LD_INT 1
96655: ARRAY
96656: PPUSH
96657: CALL_OW 251
96661: PPUSH
96662: LD_INT 12
96664: PPUSH
96665: LD_INT 1
96667: PPUSH
96668: CALL_OW 50
96672: GO 96686
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
96674: CALL_OW 45
96678: PPUSH
96679: LD_INT 1
96681: PPUSH
96682: CALL_OW 51
// end ;
96686: GO 96560
96688: POP
96689: POP
// end ;
96690: PPOPN 2
96692: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96693: LD_EXP 131
96697: PUSH
96698: LD_EXP 177
96702: AND
96703: IFFALSE 96925
96705: GO 96707
96707: DISABLE
96708: LD_INT 0
96710: PPUSH
96711: PPUSH
96712: PPUSH
96713: PPUSH
96714: PPUSH
96715: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96716: LD_ADDR_VAR 0 6
96720: PUSH
96721: LD_INT 22
96723: PUSH
96724: LD_OWVAR 2
96728: PUSH
96729: EMPTY
96730: LIST
96731: LIST
96732: PUSH
96733: LD_INT 21
96735: PUSH
96736: LD_INT 1
96738: PUSH
96739: EMPTY
96740: LIST
96741: LIST
96742: PUSH
96743: LD_INT 3
96745: PUSH
96746: LD_INT 23
96748: PUSH
96749: LD_INT 0
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: PUSH
96760: EMPTY
96761: LIST
96762: LIST
96763: LIST
96764: PPUSH
96765: CALL_OW 69
96769: ST_TO_ADDR
// if not tmp then
96770: LD_VAR 0 6
96774: NOT
96775: IFFALSE 96779
// exit ;
96777: GO 96925
// s1 := rand ( 1 , 4 ) ;
96779: LD_ADDR_VAR 0 2
96783: PUSH
96784: LD_INT 1
96786: PPUSH
96787: LD_INT 4
96789: PPUSH
96790: CALL_OW 12
96794: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
96795: LD_ADDR_VAR 0 4
96799: PUSH
96800: LD_VAR 0 6
96804: PUSH
96805: LD_INT 1
96807: ARRAY
96808: PPUSH
96809: LD_VAR 0 2
96813: PPUSH
96814: CALL_OW 259
96818: ST_TO_ADDR
// if s1 = 1 then
96819: LD_VAR 0 2
96823: PUSH
96824: LD_INT 1
96826: EQUAL
96827: IFFALSE 96847
// s2 := rand ( 2 , 4 ) else
96829: LD_ADDR_VAR 0 3
96833: PUSH
96834: LD_INT 2
96836: PPUSH
96837: LD_INT 4
96839: PPUSH
96840: CALL_OW 12
96844: ST_TO_ADDR
96845: GO 96855
// s2 := 1 ;
96847: LD_ADDR_VAR 0 3
96851: PUSH
96852: LD_INT 1
96854: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
96855: LD_ADDR_VAR 0 5
96859: PUSH
96860: LD_VAR 0 6
96864: PUSH
96865: LD_INT 1
96867: ARRAY
96868: PPUSH
96869: LD_VAR 0 3
96873: PPUSH
96874: CALL_OW 259
96878: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
96879: LD_VAR 0 6
96883: PUSH
96884: LD_INT 1
96886: ARRAY
96887: PPUSH
96888: LD_VAR 0 2
96892: PPUSH
96893: LD_VAR 0 5
96897: PPUSH
96898: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
96902: LD_VAR 0 6
96906: PUSH
96907: LD_INT 1
96909: ARRAY
96910: PPUSH
96911: LD_VAR 0 3
96915: PPUSH
96916: LD_VAR 0 4
96920: PPUSH
96921: CALL_OW 237
// end ;
96925: PPOPN 6
96927: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
96928: LD_EXP 131
96932: PUSH
96933: LD_EXP 178
96937: AND
96938: IFFALSE 97017
96940: GO 96942
96942: DISABLE
96943: LD_INT 0
96945: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
96946: LD_ADDR_VAR 0 1
96950: PUSH
96951: LD_INT 22
96953: PUSH
96954: LD_OWVAR 2
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: PUSH
96963: LD_INT 30
96965: PUSH
96966: LD_INT 3
96968: PUSH
96969: EMPTY
96970: LIST
96971: LIST
96972: PUSH
96973: EMPTY
96974: LIST
96975: LIST
96976: PPUSH
96977: CALL_OW 69
96981: ST_TO_ADDR
// if not tmp then
96982: LD_VAR 0 1
96986: NOT
96987: IFFALSE 96991
// exit ;
96989: GO 97017
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96991: LD_VAR 0 1
96995: PUSH
96996: LD_INT 1
96998: PPUSH
96999: LD_VAR 0 1
97003: PPUSH
97004: CALL_OW 12
97008: ARRAY
97009: PPUSH
97010: LD_INT 1
97012: PPUSH
97013: CALL_OW 234
// end ;
97017: PPOPN 1
97019: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97020: LD_EXP 131
97024: PUSH
97025: LD_EXP 179
97029: AND
97030: IFFALSE 97142
97032: GO 97034
97034: DISABLE
97035: LD_INT 0
97037: PPUSH
97038: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97039: LD_ADDR_VAR 0 2
97043: PUSH
97044: LD_INT 22
97046: PUSH
97047: LD_OWVAR 2
97051: PUSH
97052: EMPTY
97053: LIST
97054: LIST
97055: PUSH
97056: LD_INT 2
97058: PUSH
97059: LD_INT 30
97061: PUSH
97062: LD_INT 27
97064: PUSH
97065: EMPTY
97066: LIST
97067: LIST
97068: PUSH
97069: LD_INT 30
97071: PUSH
97072: LD_INT 26
97074: PUSH
97075: EMPTY
97076: LIST
97077: LIST
97078: PUSH
97079: LD_INT 30
97081: PUSH
97082: LD_INT 28
97084: PUSH
97085: EMPTY
97086: LIST
97087: LIST
97088: PUSH
97089: EMPTY
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: PUSH
97095: EMPTY
97096: LIST
97097: LIST
97098: PPUSH
97099: CALL_OW 69
97103: ST_TO_ADDR
// if not tmp then
97104: LD_VAR 0 2
97108: NOT
97109: IFFALSE 97113
// exit ;
97111: GO 97142
// for i in tmp do
97113: LD_ADDR_VAR 0 1
97117: PUSH
97118: LD_VAR 0 2
97122: PUSH
97123: FOR_IN
97124: IFFALSE 97140
// SetLives ( i , 1 ) ;
97126: LD_VAR 0 1
97130: PPUSH
97131: LD_INT 1
97133: PPUSH
97134: CALL_OW 234
97138: GO 97123
97140: POP
97141: POP
// end ;
97142: PPOPN 2
97144: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97145: LD_EXP 131
97149: PUSH
97150: LD_EXP 180
97154: AND
97155: IFFALSE 97429
97157: GO 97159
97159: DISABLE
97160: LD_INT 0
97162: PPUSH
97163: PPUSH
97164: PPUSH
// begin i := rand ( 1 , 7 ) ;
97165: LD_ADDR_VAR 0 1
97169: PUSH
97170: LD_INT 1
97172: PPUSH
97173: LD_INT 7
97175: PPUSH
97176: CALL_OW 12
97180: ST_TO_ADDR
// case i of 1 :
97181: LD_VAR 0 1
97185: PUSH
97186: LD_INT 1
97188: DOUBLE
97189: EQUAL
97190: IFTRUE 97194
97192: GO 97204
97194: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97195: LD_STRING earthquake(getX(game), 0, 32)
97197: PPUSH
97198: CALL_OW 559
97202: GO 97429
97204: LD_INT 2
97206: DOUBLE
97207: EQUAL
97208: IFTRUE 97212
97210: GO 97226
97212: POP
// begin ToLua ( displayStucuk(); ) ;
97213: LD_STRING displayStucuk();
97215: PPUSH
97216: CALL_OW 559
// ResetFog ;
97220: CALL_OW 335
// end ; 3 :
97224: GO 97429
97226: LD_INT 3
97228: DOUBLE
97229: EQUAL
97230: IFTRUE 97234
97232: GO 97338
97234: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97235: LD_ADDR_VAR 0 2
97239: PUSH
97240: LD_INT 22
97242: PUSH
97243: LD_OWVAR 2
97247: PUSH
97248: EMPTY
97249: LIST
97250: LIST
97251: PUSH
97252: LD_INT 25
97254: PUSH
97255: LD_INT 1
97257: PUSH
97258: EMPTY
97259: LIST
97260: LIST
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PPUSH
97266: CALL_OW 69
97270: ST_TO_ADDR
// if not tmp then
97271: LD_VAR 0 2
97275: NOT
97276: IFFALSE 97280
// exit ;
97278: GO 97429
// un := tmp [ rand ( 1 , tmp ) ] ;
97280: LD_ADDR_VAR 0 3
97284: PUSH
97285: LD_VAR 0 2
97289: PUSH
97290: LD_INT 1
97292: PPUSH
97293: LD_VAR 0 2
97297: PPUSH
97298: CALL_OW 12
97302: ARRAY
97303: ST_TO_ADDR
// if Crawls ( un ) then
97304: LD_VAR 0 3
97308: PPUSH
97309: CALL_OW 318
97313: IFFALSE 97324
// ComWalk ( un ) ;
97315: LD_VAR 0 3
97319: PPUSH
97320: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97324: LD_VAR 0 3
97328: PPUSH
97329: LD_INT 8
97331: PPUSH
97332: CALL_OW 336
// end ; 4 :
97336: GO 97429
97338: LD_INT 4
97340: DOUBLE
97341: EQUAL
97342: IFTRUE 97346
97344: GO 97407
97346: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97347: LD_ADDR_VAR 0 2
97351: PUSH
97352: LD_INT 22
97354: PUSH
97355: LD_OWVAR 2
97359: PUSH
97360: EMPTY
97361: LIST
97362: LIST
97363: PUSH
97364: LD_INT 30
97366: PUSH
97367: LD_INT 29
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: PUSH
97374: EMPTY
97375: LIST
97376: LIST
97377: PPUSH
97378: CALL_OW 69
97382: ST_TO_ADDR
// if not tmp then
97383: LD_VAR 0 2
97387: NOT
97388: IFFALSE 97392
// exit ;
97390: GO 97429
// DestroyUnit ( tmp [ 1 ] ) ;
97392: LD_VAR 0 2
97396: PUSH
97397: LD_INT 1
97399: ARRAY
97400: PPUSH
97401: CALL_OW 65
// end ; 5 .. 7 :
97405: GO 97429
97407: LD_INT 5
97409: DOUBLE
97410: GREATEREQUAL
97411: IFFALSE 97419
97413: LD_INT 7
97415: DOUBLE
97416: LESSEQUAL
97417: IFTRUE 97421
97419: GO 97428
97421: POP
// StreamSibBomb ; end ;
97422: CALL 93679 0 0
97426: GO 97429
97428: POP
// end ;
97429: PPOPN 3
97431: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97432: LD_EXP 131
97436: PUSH
97437: LD_EXP 181
97441: AND
97442: IFFALSE 97598
97444: GO 97446
97446: DISABLE
97447: LD_INT 0
97449: PPUSH
97450: PPUSH
97451: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97452: LD_ADDR_VAR 0 2
97456: PUSH
97457: LD_INT 81
97459: PUSH
97460: LD_OWVAR 2
97464: PUSH
97465: EMPTY
97466: LIST
97467: LIST
97468: PUSH
97469: LD_INT 2
97471: PUSH
97472: LD_INT 21
97474: PUSH
97475: LD_INT 1
97477: PUSH
97478: EMPTY
97479: LIST
97480: LIST
97481: PUSH
97482: LD_INT 21
97484: PUSH
97485: LD_INT 2
97487: PUSH
97488: EMPTY
97489: LIST
97490: LIST
97491: PUSH
97492: EMPTY
97493: LIST
97494: LIST
97495: LIST
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: PPUSH
97501: CALL_OW 69
97505: ST_TO_ADDR
// if not tmp then
97506: LD_VAR 0 2
97510: NOT
97511: IFFALSE 97515
// exit ;
97513: GO 97598
// p := 0 ;
97515: LD_ADDR_VAR 0 3
97519: PUSH
97520: LD_INT 0
97522: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97523: LD_INT 35
97525: PPUSH
97526: CALL_OW 67
// p := p + 1 ;
97530: LD_ADDR_VAR 0 3
97534: PUSH
97535: LD_VAR 0 3
97539: PUSH
97540: LD_INT 1
97542: PLUS
97543: ST_TO_ADDR
// for i in tmp do
97544: LD_ADDR_VAR 0 1
97548: PUSH
97549: LD_VAR 0 2
97553: PUSH
97554: FOR_IN
97555: IFFALSE 97586
// if GetLives ( i ) < 1000 then
97557: LD_VAR 0 1
97561: PPUSH
97562: CALL_OW 256
97566: PUSH
97567: LD_INT 1000
97569: LESS
97570: IFFALSE 97584
// SetLives ( i , 1000 ) ;
97572: LD_VAR 0 1
97576: PPUSH
97577: LD_INT 1000
97579: PPUSH
97580: CALL_OW 234
97584: GO 97554
97586: POP
97587: POP
// until p > 20 ;
97588: LD_VAR 0 3
97592: PUSH
97593: LD_INT 20
97595: GREATER
97596: IFFALSE 97523
// end ;
97598: PPOPN 3
97600: END
// every 0 0$1 trigger StreamModeActive and sTime do
97601: LD_EXP 131
97605: PUSH
97606: LD_EXP 182
97610: AND
97611: IFFALSE 97646
97613: GO 97615
97615: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97616: LD_INT 28
97618: PPUSH
97619: LD_OWVAR 2
97623: PPUSH
97624: LD_INT 2
97626: PPUSH
97627: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97631: LD_INT 30
97633: PPUSH
97634: LD_OWVAR 2
97638: PPUSH
97639: LD_INT 2
97641: PPUSH
97642: CALL_OW 322
// end ;
97646: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97647: LD_EXP 131
97651: PUSH
97652: LD_EXP 183
97656: AND
97657: IFFALSE 97778
97659: GO 97661
97661: DISABLE
97662: LD_INT 0
97664: PPUSH
97665: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97666: LD_ADDR_VAR 0 2
97670: PUSH
97671: LD_INT 22
97673: PUSH
97674: LD_OWVAR 2
97678: PUSH
97679: EMPTY
97680: LIST
97681: LIST
97682: PUSH
97683: LD_INT 21
97685: PUSH
97686: LD_INT 1
97688: PUSH
97689: EMPTY
97690: LIST
97691: LIST
97692: PUSH
97693: LD_INT 3
97695: PUSH
97696: LD_INT 23
97698: PUSH
97699: LD_INT 0
97701: PUSH
97702: EMPTY
97703: LIST
97704: LIST
97705: PUSH
97706: EMPTY
97707: LIST
97708: LIST
97709: PUSH
97710: EMPTY
97711: LIST
97712: LIST
97713: LIST
97714: PPUSH
97715: CALL_OW 69
97719: ST_TO_ADDR
// if not tmp then
97720: LD_VAR 0 2
97724: NOT
97725: IFFALSE 97729
// exit ;
97727: GO 97778
// for i in tmp do
97729: LD_ADDR_VAR 0 1
97733: PUSH
97734: LD_VAR 0 2
97738: PUSH
97739: FOR_IN
97740: IFFALSE 97776
// begin if Crawls ( i ) then
97742: LD_VAR 0 1
97746: PPUSH
97747: CALL_OW 318
97751: IFFALSE 97762
// ComWalk ( i ) ;
97753: LD_VAR 0 1
97757: PPUSH
97758: CALL_OW 138
// SetClass ( i , 2 ) ;
97762: LD_VAR 0 1
97766: PPUSH
97767: LD_INT 2
97769: PPUSH
97770: CALL_OW 336
// end ;
97774: GO 97739
97776: POP
97777: POP
// end ;
97778: PPOPN 2
97780: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
97781: LD_EXP 131
97785: PUSH
97786: LD_EXP 184
97790: AND
97791: IFFALSE 98072
97793: GO 97795
97795: DISABLE
97796: LD_INT 0
97798: PPUSH
97799: PPUSH
97800: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
97801: LD_OWVAR 2
97805: PPUSH
97806: LD_INT 9
97808: PPUSH
97809: LD_INT 1
97811: PPUSH
97812: LD_INT 1
97814: PPUSH
97815: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
97819: LD_INT 9
97821: PPUSH
97822: LD_OWVAR 2
97826: PPUSH
97827: CALL_OW 343
// uc_side := 9 ;
97831: LD_ADDR_OWVAR 20
97835: PUSH
97836: LD_INT 9
97838: ST_TO_ADDR
// uc_nation := 2 ;
97839: LD_ADDR_OWVAR 21
97843: PUSH
97844: LD_INT 2
97846: ST_TO_ADDR
// hc_name := Dark Warrior ;
97847: LD_ADDR_OWVAR 26
97851: PUSH
97852: LD_STRING Dark Warrior
97854: ST_TO_ADDR
// hc_gallery :=  ;
97855: LD_ADDR_OWVAR 33
97859: PUSH
97860: LD_STRING 
97862: ST_TO_ADDR
// hc_noskilllimit := true ;
97863: LD_ADDR_OWVAR 76
97867: PUSH
97868: LD_INT 1
97870: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
97871: LD_ADDR_OWVAR 31
97875: PUSH
97876: LD_INT 30
97878: PUSH
97879: LD_INT 30
97881: PUSH
97882: LD_INT 30
97884: PUSH
97885: LD_INT 30
97887: PUSH
97888: EMPTY
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: ST_TO_ADDR
// un := CreateHuman ;
97894: LD_ADDR_VAR 0 3
97898: PUSH
97899: CALL_OW 44
97903: ST_TO_ADDR
// hc_noskilllimit := false ;
97904: LD_ADDR_OWVAR 76
97908: PUSH
97909: LD_INT 0
97911: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97912: LD_VAR 0 3
97916: PPUSH
97917: LD_INT 1
97919: PPUSH
97920: CALL_OW 51
// p := 0 ;
97924: LD_ADDR_VAR 0 2
97928: PUSH
97929: LD_INT 0
97931: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97932: LD_INT 35
97934: PPUSH
97935: CALL_OW 67
// p := p + 1 ;
97939: LD_ADDR_VAR 0 2
97943: PUSH
97944: LD_VAR 0 2
97948: PUSH
97949: LD_INT 1
97951: PLUS
97952: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
97953: LD_VAR 0 3
97957: PPUSH
97958: CALL_OW 256
97962: PUSH
97963: LD_INT 1000
97965: LESS
97966: IFFALSE 97980
// SetLives ( un , 1000 ) ;
97968: LD_VAR 0 3
97972: PPUSH
97973: LD_INT 1000
97975: PPUSH
97976: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
97980: LD_VAR 0 3
97984: PPUSH
97985: LD_INT 81
97987: PUSH
97988: LD_OWVAR 2
97992: PUSH
97993: EMPTY
97994: LIST
97995: LIST
97996: PUSH
97997: LD_INT 91
97999: PUSH
98000: LD_VAR 0 3
98004: PUSH
98005: LD_INT 30
98007: PUSH
98008: EMPTY
98009: LIST
98010: LIST
98011: LIST
98012: PUSH
98013: EMPTY
98014: LIST
98015: LIST
98016: PPUSH
98017: CALL_OW 69
98021: PPUSH
98022: LD_VAR 0 3
98026: PPUSH
98027: CALL_OW 74
98031: PPUSH
98032: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
98036: LD_VAR 0 2
98040: PUSH
98041: LD_INT 60
98043: GREATER
98044: PUSH
98045: LD_VAR 0 3
98049: PPUSH
98050: CALL_OW 301
98054: OR
98055: IFFALSE 97932
// if un then
98057: LD_VAR 0 3
98061: IFFALSE 98072
// RemoveUnit ( un ) ;
98063: LD_VAR 0 3
98067: PPUSH
98068: CALL_OW 64
// end ; end_of_file
98072: PPOPN 3
98074: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
98075: LD_INT 0
98077: PPUSH
98078: PPUSH
98079: PPUSH
98080: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98081: LD_VAR 0 1
98085: PPUSH
98086: CALL_OW 264
98090: PUSH
98091: LD_EXP 76
98095: EQUAL
98096: IFFALSE 98168
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98098: LD_INT 68
98100: PPUSH
98101: LD_VAR 0 1
98105: PPUSH
98106: CALL_OW 255
98110: PPUSH
98111: CALL_OW 321
98115: PUSH
98116: LD_INT 2
98118: EQUAL
98119: IFFALSE 98131
// eff := 70 else
98121: LD_ADDR_VAR 0 4
98125: PUSH
98126: LD_INT 70
98128: ST_TO_ADDR
98129: GO 98139
// eff := 30 ;
98131: LD_ADDR_VAR 0 4
98135: PUSH
98136: LD_INT 30
98138: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
98139: LD_VAR 0 1
98143: PPUSH
98144: CALL_OW 250
98148: PPUSH
98149: LD_VAR 0 1
98153: PPUSH
98154: CALL_OW 251
98158: PPUSH
98159: LD_VAR 0 4
98163: PPUSH
98164: CALL_OW 495
// end ; end ;
98168: LD_VAR 0 2
98172: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
98173: LD_INT 0
98175: PPUSH
// end ;
98176: LD_VAR 0 4
98180: RET
// export function SOS_Command ( cmd ) ; begin
98181: LD_INT 0
98183: PPUSH
// end ;
98184: LD_VAR 0 2
98188: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y ) do begin if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
98189: LD_VAR 0 1
98193: PUSH
98194: LD_INT 254
98196: EQUAL
98197: PUSH
98198: LD_VAR 0 2
98202: PPUSH
98203: CALL_OW 264
98207: PUSH
98208: LD_EXP 74
98212: EQUAL
98213: AND
98214: PUSH
98215: LD_VAR 0 3
98219: PPUSH
98220: CALL_OW 263
98224: PUSH
98225: LD_INT 3
98227: EQUAL
98228: AND
98229: IFFALSE 98240
// DestroyUnit ( selectedUnit ) ;
98231: LD_VAR 0 3
98235: PPUSH
98236: CALL_OW 65
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
98240: LD_VAR 0 1
98244: PUSH
98245: LD_INT 255
98247: EQUAL
98248: PUSH
98249: LD_VAR 0 2
98253: PPUSH
98254: CALL_OW 264
98258: PUSH
98259: LD_INT 14
98261: PUSH
98262: LD_INT 53
98264: PUSH
98265: EMPTY
98266: LIST
98267: LIST
98268: IN
98269: AND
98270: PUSH
98271: LD_VAR 0 4
98275: PPUSH
98276: LD_VAR 0 5
98280: PPUSH
98281: CALL_OW 488
98285: AND
98286: IFFALSE 98310
// CutTreeXYR ( unit , x , y , 12 ) ;
98288: LD_VAR 0 2
98292: PPUSH
98293: LD_VAR 0 4
98297: PPUSH
98298: LD_VAR 0 5
98302: PPUSH
98303: LD_INT 12
98305: PPUSH
98306: CALL 98313 0 4
// end ;
98310: PPOPN 5
98312: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
98313: LD_INT 0
98315: PPUSH
98316: PPUSH
98317: PPUSH
98318: PPUSH
98319: PPUSH
98320: PPUSH
98321: PPUSH
98322: PPUSH
98323: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
98324: LD_VAR 0 1
98328: NOT
98329: PUSH
98330: LD_VAR 0 2
98334: PPUSH
98335: LD_VAR 0 3
98339: PPUSH
98340: CALL_OW 488
98344: NOT
98345: OR
98346: PUSH
98347: LD_VAR 0 4
98351: NOT
98352: OR
98353: IFFALSE 98357
// exit ;
98355: GO 98697
// list := [ ] ;
98357: LD_ADDR_VAR 0 13
98361: PUSH
98362: EMPTY
98363: ST_TO_ADDR
// if x - r < 0 then
98364: LD_VAR 0 2
98368: PUSH
98369: LD_VAR 0 4
98373: MINUS
98374: PUSH
98375: LD_INT 0
98377: LESS
98378: IFFALSE 98390
// min_x := 0 else
98380: LD_ADDR_VAR 0 7
98384: PUSH
98385: LD_INT 0
98387: ST_TO_ADDR
98388: GO 98406
// min_x := x - r ;
98390: LD_ADDR_VAR 0 7
98394: PUSH
98395: LD_VAR 0 2
98399: PUSH
98400: LD_VAR 0 4
98404: MINUS
98405: ST_TO_ADDR
// if y - r < 0 then
98406: LD_VAR 0 3
98410: PUSH
98411: LD_VAR 0 4
98415: MINUS
98416: PUSH
98417: LD_INT 0
98419: LESS
98420: IFFALSE 98432
// min_y := 0 else
98422: LD_ADDR_VAR 0 8
98426: PUSH
98427: LD_INT 0
98429: ST_TO_ADDR
98430: GO 98448
// min_y := y - r ;
98432: LD_ADDR_VAR 0 8
98436: PUSH
98437: LD_VAR 0 3
98441: PUSH
98442: LD_VAR 0 4
98446: MINUS
98447: ST_TO_ADDR
// max_x := x + r ;
98448: LD_ADDR_VAR 0 9
98452: PUSH
98453: LD_VAR 0 2
98457: PUSH
98458: LD_VAR 0 4
98462: PLUS
98463: ST_TO_ADDR
// max_y := y + r ;
98464: LD_ADDR_VAR 0 10
98468: PUSH
98469: LD_VAR 0 3
98473: PUSH
98474: LD_VAR 0 4
98478: PLUS
98479: ST_TO_ADDR
// for _x = min_x to max_x do
98480: LD_ADDR_VAR 0 11
98484: PUSH
98485: DOUBLE
98486: LD_VAR 0 7
98490: DEC
98491: ST_TO_ADDR
98492: LD_VAR 0 9
98496: PUSH
98497: FOR_TO
98498: IFFALSE 98615
// for _y = min_y to max_y do
98500: LD_ADDR_VAR 0 12
98504: PUSH
98505: DOUBLE
98506: LD_VAR 0 8
98510: DEC
98511: ST_TO_ADDR
98512: LD_VAR 0 10
98516: PUSH
98517: FOR_TO
98518: IFFALSE 98611
// begin if not ValidHex ( _x , _y ) then
98520: LD_VAR 0 11
98524: PPUSH
98525: LD_VAR 0 12
98529: PPUSH
98530: CALL_OW 488
98534: NOT
98535: IFFALSE 98539
// continue ;
98537: GO 98517
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98539: LD_VAR 0 11
98543: PPUSH
98544: LD_VAR 0 12
98548: PPUSH
98549: CALL_OW 351
98553: PUSH
98554: LD_VAR 0 11
98558: PPUSH
98559: LD_VAR 0 12
98563: PPUSH
98564: CALL_OW 554
98568: AND
98569: IFFALSE 98609
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
98571: LD_ADDR_VAR 0 13
98575: PUSH
98576: LD_VAR 0 13
98580: PPUSH
98581: LD_VAR 0 13
98585: PUSH
98586: LD_INT 1
98588: PLUS
98589: PPUSH
98590: LD_VAR 0 11
98594: PUSH
98595: LD_VAR 0 12
98599: PUSH
98600: EMPTY
98601: LIST
98602: LIST
98603: PPUSH
98604: CALL_OW 2
98608: ST_TO_ADDR
// end ;
98609: GO 98517
98611: POP
98612: POP
98613: GO 98497
98615: POP
98616: POP
// if not list then
98617: LD_VAR 0 13
98621: NOT
98622: IFFALSE 98626
// exit ;
98624: GO 98697
// for i in list do
98626: LD_ADDR_VAR 0 6
98630: PUSH
98631: LD_VAR 0 13
98635: PUSH
98636: FOR_IN
98637: IFFALSE 98695
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
98639: LD_VAR 0 1
98643: PPUSH
98644: LD_STRING M
98646: PUSH
98647: LD_VAR 0 6
98651: PUSH
98652: LD_INT 1
98654: ARRAY
98655: PUSH
98656: LD_VAR 0 6
98660: PUSH
98661: LD_INT 2
98663: ARRAY
98664: PUSH
98665: LD_INT 0
98667: PUSH
98668: LD_INT 0
98670: PUSH
98671: LD_INT 0
98673: PUSH
98674: LD_INT 0
98676: PUSH
98677: EMPTY
98678: LIST
98679: LIST
98680: LIST
98681: LIST
98682: LIST
98683: LIST
98684: LIST
98685: PUSH
98686: EMPTY
98687: LIST
98688: PPUSH
98689: CALL_OW 447
98693: GO 98636
98695: POP
98696: POP
// end ;
98697: LD_VAR 0 5
98701: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
98702: LD_EXP 185
98706: NOT
98707: IFFALSE 98757
98709: GO 98711
98711: DISABLE
// begin initHack := true ;
98712: LD_ADDR_EXP 185
98716: PUSH
98717: LD_INT 1
98719: ST_TO_ADDR
// hackTanks := [ ] ;
98720: LD_ADDR_EXP 186
98724: PUSH
98725: EMPTY
98726: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
98727: LD_ADDR_EXP 187
98731: PUSH
98732: EMPTY
98733: ST_TO_ADDR
// hackLimit := 3 ;
98734: LD_ADDR_EXP 188
98738: PUSH
98739: LD_INT 3
98741: ST_TO_ADDR
// hackDist := 12 ;
98742: LD_ADDR_EXP 189
98746: PUSH
98747: LD_INT 12
98749: ST_TO_ADDR
// hackCounter := [ ] ;
98750: LD_ADDR_EXP 190
98754: PUSH
98755: EMPTY
98756: ST_TO_ADDR
// end ;
98757: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
98758: LD_EXP 185
98762: PUSH
98763: LD_INT 34
98765: PUSH
98766: LD_EXP 74
98770: PUSH
98771: EMPTY
98772: LIST
98773: LIST
98774: PPUSH
98775: CALL_OW 69
98779: AND
98780: IFFALSE 99035
98782: GO 98784
98784: DISABLE
98785: LD_INT 0
98787: PPUSH
98788: PPUSH
// begin enable ;
98789: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
98790: LD_ADDR_VAR 0 1
98794: PUSH
98795: LD_INT 34
98797: PUSH
98798: LD_EXP 74
98802: PUSH
98803: EMPTY
98804: LIST
98805: LIST
98806: PPUSH
98807: CALL_OW 69
98811: PUSH
98812: FOR_IN
98813: IFFALSE 99033
// begin if not i in hackTanks then
98815: LD_VAR 0 1
98819: PUSH
98820: LD_EXP 186
98824: IN
98825: NOT
98826: IFFALSE 98909
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
98828: LD_ADDR_EXP 186
98832: PUSH
98833: LD_EXP 186
98837: PPUSH
98838: LD_EXP 186
98842: PUSH
98843: LD_INT 1
98845: PLUS
98846: PPUSH
98847: LD_VAR 0 1
98851: PPUSH
98852: CALL_OW 1
98856: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
98857: LD_ADDR_EXP 187
98861: PUSH
98862: LD_EXP 187
98866: PPUSH
98867: LD_EXP 187
98871: PUSH
98872: LD_INT 1
98874: PLUS
98875: PPUSH
98876: EMPTY
98877: PPUSH
98878: CALL_OW 1
98882: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
98883: LD_ADDR_EXP 190
98887: PUSH
98888: LD_EXP 190
98892: PPUSH
98893: LD_EXP 190
98897: PUSH
98898: LD_INT 1
98900: PLUS
98901: PPUSH
98902: EMPTY
98903: PPUSH
98904: CALL_OW 1
98908: ST_TO_ADDR
// end ; if not IsOk ( i ) then
98909: LD_VAR 0 1
98913: PPUSH
98914: CALL_OW 302
98918: NOT
98919: IFFALSE 98932
// begin HackUnlinkAll ( i ) ;
98921: LD_VAR 0 1
98925: PPUSH
98926: CALL 99038 0 1
// continue ;
98930: GO 98812
// end ; HackCheckCapturedStatus ( i ) ;
98932: LD_VAR 0 1
98936: PPUSH
98937: CALL 99481 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
98941: LD_ADDR_VAR 0 2
98945: PUSH
98946: LD_INT 81
98948: PUSH
98949: LD_VAR 0 1
98953: PPUSH
98954: CALL_OW 255
98958: PUSH
98959: EMPTY
98960: LIST
98961: LIST
98962: PUSH
98963: LD_INT 33
98965: PUSH
98966: LD_INT 3
98968: PUSH
98969: EMPTY
98970: LIST
98971: LIST
98972: PUSH
98973: LD_INT 91
98975: PUSH
98976: LD_VAR 0 1
98980: PUSH
98981: LD_EXP 189
98985: PUSH
98986: EMPTY
98987: LIST
98988: LIST
98989: LIST
98990: PUSH
98991: LD_INT 50
98993: PUSH
98994: EMPTY
98995: LIST
98996: PUSH
98997: EMPTY
98998: LIST
98999: LIST
99000: LIST
99001: LIST
99002: PPUSH
99003: CALL_OW 69
99007: ST_TO_ADDR
// if not tmp then
99008: LD_VAR 0 2
99012: NOT
99013: IFFALSE 99017
// continue ;
99015: GO 98812
// HackLink ( i , tmp ) ;
99017: LD_VAR 0 1
99021: PPUSH
99022: LD_VAR 0 2
99026: PPUSH
99027: CALL 99174 0 2
// end ;
99031: GO 98812
99033: POP
99034: POP
// end ;
99035: PPOPN 2
99037: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
99038: LD_INT 0
99040: PPUSH
99041: PPUSH
99042: PPUSH
// if not hack in hackTanks then
99043: LD_VAR 0 1
99047: PUSH
99048: LD_EXP 186
99052: IN
99053: NOT
99054: IFFALSE 99058
// exit ;
99056: GO 99169
// index := GetElementIndex ( hackTanks , hack ) ;
99058: LD_ADDR_VAR 0 4
99062: PUSH
99063: LD_EXP 186
99067: PPUSH
99068: LD_VAR 0 1
99072: PPUSH
99073: CALL 55394 0 2
99077: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
99078: LD_EXP 187
99082: PUSH
99083: LD_VAR 0 4
99087: ARRAY
99088: IFFALSE 99169
// begin for i in hackTanksCaptured [ index ] do
99090: LD_ADDR_VAR 0 3
99094: PUSH
99095: LD_EXP 187
99099: PUSH
99100: LD_VAR 0 4
99104: ARRAY
99105: PUSH
99106: FOR_IN
99107: IFFALSE 99133
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
99109: LD_VAR 0 3
99113: PUSH
99114: LD_INT 1
99116: ARRAY
99117: PPUSH
99118: LD_VAR 0 3
99122: PUSH
99123: LD_INT 2
99125: ARRAY
99126: PPUSH
99127: CALL_OW 235
99131: GO 99106
99133: POP
99134: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
99135: LD_ADDR_EXP 187
99139: PUSH
99140: LD_EXP 187
99144: PPUSH
99145: LD_VAR 0 4
99149: PPUSH
99150: EMPTY
99151: PPUSH
99152: CALL_OW 1
99156: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
99157: LD_VAR 0 1
99161: PPUSH
99162: LD_INT 0
99164: PPUSH
99165: CALL_OW 505
// end ; end ;
99169: LD_VAR 0 2
99173: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
99174: LD_INT 0
99176: PPUSH
99177: PPUSH
99178: PPUSH
// if not hack in hackTanks or not vehicles then
99179: LD_VAR 0 1
99183: PUSH
99184: LD_EXP 186
99188: IN
99189: NOT
99190: PUSH
99191: LD_VAR 0 2
99195: NOT
99196: OR
99197: IFFALSE 99201
// exit ;
99199: GO 99476
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
99201: LD_ADDR_VAR 0 2
99205: PUSH
99206: LD_VAR 0 1
99210: PPUSH
99211: LD_VAR 0 2
99215: PPUSH
99216: LD_INT 1
99218: PPUSH
99219: LD_INT 1
99221: PPUSH
99222: CALL 56044 0 4
99226: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
99227: LD_ADDR_VAR 0 5
99231: PUSH
99232: LD_EXP 186
99236: PPUSH
99237: LD_VAR 0 1
99241: PPUSH
99242: CALL 55394 0 2
99246: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
99247: LD_EXP 187
99251: PUSH
99252: LD_VAR 0 5
99256: ARRAY
99257: PUSH
99258: LD_EXP 188
99262: LESS
99263: IFFALSE 99452
// begin for i := 1 to vehicles do
99265: LD_ADDR_VAR 0 4
99269: PUSH
99270: DOUBLE
99271: LD_INT 1
99273: DEC
99274: ST_TO_ADDR
99275: LD_VAR 0 2
99279: PUSH
99280: FOR_TO
99281: IFFALSE 99450
// begin if hackTanksCaptured [ index ] = hackLimit then
99283: LD_EXP 187
99287: PUSH
99288: LD_VAR 0 5
99292: ARRAY
99293: PUSH
99294: LD_EXP 188
99298: EQUAL
99299: IFFALSE 99303
// break ;
99301: GO 99450
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
99303: LD_ADDR_EXP 190
99307: PUSH
99308: LD_EXP 190
99312: PPUSH
99313: LD_VAR 0 5
99317: PPUSH
99318: LD_EXP 190
99322: PUSH
99323: LD_VAR 0 5
99327: ARRAY
99328: PUSH
99329: LD_INT 1
99331: PLUS
99332: PPUSH
99333: CALL_OW 1
99337: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
99338: LD_ADDR_EXP 187
99342: PUSH
99343: LD_EXP 187
99347: PPUSH
99348: LD_VAR 0 5
99352: PUSH
99353: LD_EXP 187
99357: PUSH
99358: LD_VAR 0 5
99362: ARRAY
99363: PUSH
99364: LD_INT 1
99366: PLUS
99367: PUSH
99368: EMPTY
99369: LIST
99370: LIST
99371: PPUSH
99372: LD_VAR 0 2
99376: PUSH
99377: LD_VAR 0 4
99381: ARRAY
99382: PUSH
99383: LD_VAR 0 2
99387: PUSH
99388: LD_VAR 0 4
99392: ARRAY
99393: PPUSH
99394: CALL_OW 255
99398: PUSH
99399: EMPTY
99400: LIST
99401: LIST
99402: PPUSH
99403: CALL 55609 0 3
99407: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
99408: LD_VAR 0 2
99412: PUSH
99413: LD_VAR 0 4
99417: ARRAY
99418: PPUSH
99419: LD_VAR 0 1
99423: PPUSH
99424: CALL_OW 255
99428: PPUSH
99429: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
99433: LD_VAR 0 2
99437: PUSH
99438: LD_VAR 0 4
99442: ARRAY
99443: PPUSH
99444: CALL_OW 141
// end ;
99448: GO 99280
99450: POP
99451: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99452: LD_VAR 0 1
99456: PPUSH
99457: LD_EXP 187
99461: PUSH
99462: LD_VAR 0 5
99466: ARRAY
99467: PUSH
99468: LD_INT 0
99470: PLUS
99471: PPUSH
99472: CALL_OW 505
// end ;
99476: LD_VAR 0 3
99480: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
99481: LD_INT 0
99483: PPUSH
99484: PPUSH
99485: PPUSH
99486: PPUSH
// if not hack in hackTanks then
99487: LD_VAR 0 1
99491: PUSH
99492: LD_EXP 186
99496: IN
99497: NOT
99498: IFFALSE 99502
// exit ;
99500: GO 99742
// index := GetElementIndex ( hackTanks , hack ) ;
99502: LD_ADDR_VAR 0 4
99506: PUSH
99507: LD_EXP 186
99511: PPUSH
99512: LD_VAR 0 1
99516: PPUSH
99517: CALL 55394 0 2
99521: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
99522: LD_ADDR_VAR 0 3
99526: PUSH
99527: DOUBLE
99528: LD_EXP 187
99532: PUSH
99533: LD_VAR 0 4
99537: ARRAY
99538: INC
99539: ST_TO_ADDR
99540: LD_INT 1
99542: PUSH
99543: FOR_DOWNTO
99544: IFFALSE 99716
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
99546: LD_ADDR_VAR 0 5
99550: PUSH
99551: LD_EXP 187
99555: PUSH
99556: LD_VAR 0 4
99560: ARRAY
99561: PUSH
99562: LD_VAR 0 3
99566: ARRAY
99567: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
99568: LD_VAR 0 5
99572: PUSH
99573: LD_INT 1
99575: ARRAY
99576: PPUSH
99577: CALL_OW 302
99581: NOT
99582: PUSH
99583: LD_VAR 0 5
99587: PUSH
99588: LD_INT 1
99590: ARRAY
99591: PPUSH
99592: CALL_OW 255
99596: PUSH
99597: LD_VAR 0 1
99601: PPUSH
99602: CALL_OW 255
99606: NONEQUAL
99607: OR
99608: IFFALSE 99714
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
99610: LD_VAR 0 5
99614: PUSH
99615: LD_INT 1
99617: ARRAY
99618: PPUSH
99619: CALL_OW 305
99623: PUSH
99624: LD_VAR 0 5
99628: PUSH
99629: LD_INT 1
99631: ARRAY
99632: PPUSH
99633: CALL_OW 255
99637: PUSH
99638: LD_VAR 0 1
99642: PPUSH
99643: CALL_OW 255
99647: EQUAL
99648: AND
99649: IFFALSE 99673
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
99651: LD_VAR 0 5
99655: PUSH
99656: LD_INT 1
99658: ARRAY
99659: PPUSH
99660: LD_VAR 0 5
99664: PUSH
99665: LD_INT 2
99667: ARRAY
99668: PPUSH
99669: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
99673: LD_ADDR_EXP 187
99677: PUSH
99678: LD_EXP 187
99682: PPUSH
99683: LD_VAR 0 4
99687: PPUSH
99688: LD_EXP 187
99692: PUSH
99693: LD_VAR 0 4
99697: ARRAY
99698: PPUSH
99699: LD_VAR 0 3
99703: PPUSH
99704: CALL_OW 3
99708: PPUSH
99709: CALL_OW 1
99713: ST_TO_ADDR
// end ; end ;
99714: GO 99543
99716: POP
99717: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99718: LD_VAR 0 1
99722: PPUSH
99723: LD_EXP 187
99727: PUSH
99728: LD_VAR 0 4
99732: ARRAY
99733: PUSH
99734: LD_INT 0
99736: PLUS
99737: PPUSH
99738: CALL_OW 505
// end ; end_of_file
99742: LD_VAR 0 2
99746: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99747: LD_INT 0
99749: PPUSH
99750: PPUSH
99751: PPUSH
99752: PPUSH
99753: PPUSH
99754: PPUSH
99755: PPUSH
99756: PPUSH
99757: PPUSH
99758: PPUSH
99759: PPUSH
99760: PPUSH
99761: PPUSH
99762: PPUSH
99763: PPUSH
99764: PPUSH
99765: PPUSH
99766: PPUSH
99767: PPUSH
99768: PPUSH
99769: PPUSH
99770: PPUSH
99771: PPUSH
99772: PPUSH
99773: PPUSH
99774: PPUSH
99775: PPUSH
99776: PPUSH
99777: PPUSH
99778: PPUSH
99779: PPUSH
99780: PPUSH
99781: PPUSH
99782: PPUSH
// if not list then
99783: LD_VAR 0 1
99787: NOT
99788: IFFALSE 99792
// exit ;
99790: GO 104451
// base := list [ 1 ] ;
99792: LD_ADDR_VAR 0 3
99796: PUSH
99797: LD_VAR 0 1
99801: PUSH
99802: LD_INT 1
99804: ARRAY
99805: ST_TO_ADDR
// group := list [ 2 ] ;
99806: LD_ADDR_VAR 0 4
99810: PUSH
99811: LD_VAR 0 1
99815: PUSH
99816: LD_INT 2
99818: ARRAY
99819: ST_TO_ADDR
// path := list [ 3 ] ;
99820: LD_ADDR_VAR 0 5
99824: PUSH
99825: LD_VAR 0 1
99829: PUSH
99830: LD_INT 3
99832: ARRAY
99833: ST_TO_ADDR
// flags := list [ 4 ] ;
99834: LD_ADDR_VAR 0 6
99838: PUSH
99839: LD_VAR 0 1
99843: PUSH
99844: LD_INT 4
99846: ARRAY
99847: ST_TO_ADDR
// mined := [ ] ;
99848: LD_ADDR_VAR 0 27
99852: PUSH
99853: EMPTY
99854: ST_TO_ADDR
// bombed := [ ] ;
99855: LD_ADDR_VAR 0 28
99859: PUSH
99860: EMPTY
99861: ST_TO_ADDR
// healers := [ ] ;
99862: LD_ADDR_VAR 0 31
99866: PUSH
99867: EMPTY
99868: ST_TO_ADDR
// to_heal := [ ] ;
99869: LD_ADDR_VAR 0 30
99873: PUSH
99874: EMPTY
99875: ST_TO_ADDR
// repairs := [ ] ;
99876: LD_ADDR_VAR 0 33
99880: PUSH
99881: EMPTY
99882: ST_TO_ADDR
// to_repair := [ ] ;
99883: LD_ADDR_VAR 0 32
99887: PUSH
99888: EMPTY
99889: ST_TO_ADDR
// if not group or not path then
99890: LD_VAR 0 4
99894: NOT
99895: PUSH
99896: LD_VAR 0 5
99900: NOT
99901: OR
99902: IFFALSE 99906
// exit ;
99904: GO 104451
// side := GetSide ( group [ 1 ] ) ;
99906: LD_ADDR_VAR 0 35
99910: PUSH
99911: LD_VAR 0 4
99915: PUSH
99916: LD_INT 1
99918: ARRAY
99919: PPUSH
99920: CALL_OW 255
99924: ST_TO_ADDR
// if flags then
99925: LD_VAR 0 6
99929: IFFALSE 100073
// begin f_ignore_area := flags [ 1 ] ;
99931: LD_ADDR_VAR 0 17
99935: PUSH
99936: LD_VAR 0 6
99940: PUSH
99941: LD_INT 1
99943: ARRAY
99944: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
99945: LD_ADDR_VAR 0 18
99949: PUSH
99950: LD_VAR 0 6
99954: PUSH
99955: LD_INT 2
99957: ARRAY
99958: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
99959: LD_ADDR_VAR 0 19
99963: PUSH
99964: LD_VAR 0 6
99968: PUSH
99969: LD_INT 3
99971: ARRAY
99972: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
99973: LD_ADDR_VAR 0 20
99977: PUSH
99978: LD_VAR 0 6
99982: PUSH
99983: LD_INT 4
99985: ARRAY
99986: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
99987: LD_ADDR_VAR 0 21
99991: PUSH
99992: LD_VAR 0 6
99996: PUSH
99997: LD_INT 5
99999: ARRAY
100000: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100001: LD_ADDR_VAR 0 22
100005: PUSH
100006: LD_VAR 0 6
100010: PUSH
100011: LD_INT 6
100013: ARRAY
100014: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100015: LD_ADDR_VAR 0 23
100019: PUSH
100020: LD_VAR 0 6
100024: PUSH
100025: LD_INT 7
100027: ARRAY
100028: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100029: LD_ADDR_VAR 0 24
100033: PUSH
100034: LD_VAR 0 6
100038: PUSH
100039: LD_INT 8
100041: ARRAY
100042: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100043: LD_ADDR_VAR 0 25
100047: PUSH
100048: LD_VAR 0 6
100052: PUSH
100053: LD_INT 9
100055: ARRAY
100056: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100057: LD_ADDR_VAR 0 26
100061: PUSH
100062: LD_VAR 0 6
100066: PUSH
100067: LD_INT 10
100069: ARRAY
100070: ST_TO_ADDR
// end else
100071: GO 100153
// begin f_ignore_area := false ;
100073: LD_ADDR_VAR 0 17
100077: PUSH
100078: LD_INT 0
100080: ST_TO_ADDR
// f_capture := false ;
100081: LD_ADDR_VAR 0 18
100085: PUSH
100086: LD_INT 0
100088: ST_TO_ADDR
// f_ignore_civ := false ;
100089: LD_ADDR_VAR 0 19
100093: PUSH
100094: LD_INT 0
100096: ST_TO_ADDR
// f_murder := false ;
100097: LD_ADDR_VAR 0 20
100101: PUSH
100102: LD_INT 0
100104: ST_TO_ADDR
// f_mines := false ;
100105: LD_ADDR_VAR 0 21
100109: PUSH
100110: LD_INT 0
100112: ST_TO_ADDR
// f_repair := false ;
100113: LD_ADDR_VAR 0 22
100117: PUSH
100118: LD_INT 0
100120: ST_TO_ADDR
// f_heal := false ;
100121: LD_ADDR_VAR 0 23
100125: PUSH
100126: LD_INT 0
100128: ST_TO_ADDR
// f_spacetime := false ;
100129: LD_ADDR_VAR 0 24
100133: PUSH
100134: LD_INT 0
100136: ST_TO_ADDR
// f_attack_depot := false ;
100137: LD_ADDR_VAR 0 25
100141: PUSH
100142: LD_INT 0
100144: ST_TO_ADDR
// f_crawl := false ;
100145: LD_ADDR_VAR 0 26
100149: PUSH
100150: LD_INT 0
100152: ST_TO_ADDR
// end ; if f_heal then
100153: LD_VAR 0 23
100157: IFFALSE 100184
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100159: LD_ADDR_VAR 0 31
100163: PUSH
100164: LD_VAR 0 4
100168: PPUSH
100169: LD_INT 25
100171: PUSH
100172: LD_INT 4
100174: PUSH
100175: EMPTY
100176: LIST
100177: LIST
100178: PPUSH
100179: CALL_OW 72
100183: ST_TO_ADDR
// if f_repair then
100184: LD_VAR 0 22
100188: IFFALSE 100215
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100190: LD_ADDR_VAR 0 33
100194: PUSH
100195: LD_VAR 0 4
100199: PPUSH
100200: LD_INT 25
100202: PUSH
100203: LD_INT 3
100205: PUSH
100206: EMPTY
100207: LIST
100208: LIST
100209: PPUSH
100210: CALL_OW 72
100214: ST_TO_ADDR
// units_path := [ ] ;
100215: LD_ADDR_VAR 0 16
100219: PUSH
100220: EMPTY
100221: ST_TO_ADDR
// for i = 1 to group do
100222: LD_ADDR_VAR 0 7
100226: PUSH
100227: DOUBLE
100228: LD_INT 1
100230: DEC
100231: ST_TO_ADDR
100232: LD_VAR 0 4
100236: PUSH
100237: FOR_TO
100238: IFFALSE 100267
// units_path := Replace ( units_path , i , path ) ;
100240: LD_ADDR_VAR 0 16
100244: PUSH
100245: LD_VAR 0 16
100249: PPUSH
100250: LD_VAR 0 7
100254: PPUSH
100255: LD_VAR 0 5
100259: PPUSH
100260: CALL_OW 1
100264: ST_TO_ADDR
100265: GO 100237
100267: POP
100268: POP
// repeat for i = group downto 1 do
100269: LD_ADDR_VAR 0 7
100273: PUSH
100274: DOUBLE
100275: LD_VAR 0 4
100279: INC
100280: ST_TO_ADDR
100281: LD_INT 1
100283: PUSH
100284: FOR_DOWNTO
100285: IFFALSE 104407
// begin wait ( 5 ) ;
100287: LD_INT 5
100289: PPUSH
100290: CALL_OW 67
// tmp := [ ] ;
100294: LD_ADDR_VAR 0 14
100298: PUSH
100299: EMPTY
100300: ST_TO_ADDR
// attacking := false ;
100301: LD_ADDR_VAR 0 29
100305: PUSH
100306: LD_INT 0
100308: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100309: LD_VAR 0 4
100313: PUSH
100314: LD_VAR 0 7
100318: ARRAY
100319: PPUSH
100320: CALL_OW 301
100324: PUSH
100325: LD_VAR 0 4
100329: PUSH
100330: LD_VAR 0 7
100334: ARRAY
100335: NOT
100336: OR
100337: IFFALSE 100446
// begin if GetType ( group [ i ] ) = unit_human then
100339: LD_VAR 0 4
100343: PUSH
100344: LD_VAR 0 7
100348: ARRAY
100349: PPUSH
100350: CALL_OW 247
100354: PUSH
100355: LD_INT 1
100357: EQUAL
100358: IFFALSE 100404
// begin to_heal := to_heal diff group [ i ] ;
100360: LD_ADDR_VAR 0 30
100364: PUSH
100365: LD_VAR 0 30
100369: PUSH
100370: LD_VAR 0 4
100374: PUSH
100375: LD_VAR 0 7
100379: ARRAY
100380: DIFF
100381: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100382: LD_ADDR_VAR 0 31
100386: PUSH
100387: LD_VAR 0 31
100391: PUSH
100392: LD_VAR 0 4
100396: PUSH
100397: LD_VAR 0 7
100401: ARRAY
100402: DIFF
100403: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100404: LD_ADDR_VAR 0 4
100408: PUSH
100409: LD_VAR 0 4
100413: PPUSH
100414: LD_VAR 0 7
100418: PPUSH
100419: CALL_OW 3
100423: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100424: LD_ADDR_VAR 0 16
100428: PUSH
100429: LD_VAR 0 16
100433: PPUSH
100434: LD_VAR 0 7
100438: PPUSH
100439: CALL_OW 3
100443: ST_TO_ADDR
// continue ;
100444: GO 100284
// end ; if f_repair then
100446: LD_VAR 0 22
100450: IFFALSE 100939
// begin if GetType ( group [ i ] ) = unit_vehicle then
100452: LD_VAR 0 4
100456: PUSH
100457: LD_VAR 0 7
100461: ARRAY
100462: PPUSH
100463: CALL_OW 247
100467: PUSH
100468: LD_INT 2
100470: EQUAL
100471: IFFALSE 100661
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100473: LD_VAR 0 4
100477: PUSH
100478: LD_VAR 0 7
100482: ARRAY
100483: PPUSH
100484: CALL_OW 256
100488: PUSH
100489: LD_INT 700
100491: LESS
100492: PUSH
100493: LD_VAR 0 4
100497: PUSH
100498: LD_VAR 0 7
100502: ARRAY
100503: PUSH
100504: LD_VAR 0 32
100508: IN
100509: NOT
100510: AND
100511: IFFALSE 100535
// to_repair := to_repair union group [ i ] ;
100513: LD_ADDR_VAR 0 32
100517: PUSH
100518: LD_VAR 0 32
100522: PUSH
100523: LD_VAR 0 4
100527: PUSH
100528: LD_VAR 0 7
100532: ARRAY
100533: UNION
100534: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100535: LD_VAR 0 4
100539: PUSH
100540: LD_VAR 0 7
100544: ARRAY
100545: PPUSH
100546: CALL_OW 256
100550: PUSH
100551: LD_INT 1000
100553: EQUAL
100554: PUSH
100555: LD_VAR 0 4
100559: PUSH
100560: LD_VAR 0 7
100564: ARRAY
100565: PUSH
100566: LD_VAR 0 32
100570: IN
100571: AND
100572: IFFALSE 100596
// to_repair := to_repair diff group [ i ] ;
100574: LD_ADDR_VAR 0 32
100578: PUSH
100579: LD_VAR 0 32
100583: PUSH
100584: LD_VAR 0 4
100588: PUSH
100589: LD_VAR 0 7
100593: ARRAY
100594: DIFF
100595: ST_TO_ADDR
// if group [ i ] in to_repair then
100596: LD_VAR 0 4
100600: PUSH
100601: LD_VAR 0 7
100605: ARRAY
100606: PUSH
100607: LD_VAR 0 32
100611: IN
100612: IFFALSE 100659
// begin if not IsInArea ( group [ i ] , f_repair ) then
100614: LD_VAR 0 4
100618: PUSH
100619: LD_VAR 0 7
100623: ARRAY
100624: PPUSH
100625: LD_VAR 0 22
100629: PPUSH
100630: CALL_OW 308
100634: NOT
100635: IFFALSE 100657
// ComMoveToArea ( group [ i ] , f_repair ) ;
100637: LD_VAR 0 4
100641: PUSH
100642: LD_VAR 0 7
100646: ARRAY
100647: PPUSH
100648: LD_VAR 0 22
100652: PPUSH
100653: CALL_OW 113
// continue ;
100657: GO 100284
// end ; end else
100659: GO 100939
// if group [ i ] in repairs then
100661: LD_VAR 0 4
100665: PUSH
100666: LD_VAR 0 7
100670: ARRAY
100671: PUSH
100672: LD_VAR 0 33
100676: IN
100677: IFFALSE 100939
// begin if IsInUnit ( group [ i ] ) then
100679: LD_VAR 0 4
100683: PUSH
100684: LD_VAR 0 7
100688: ARRAY
100689: PPUSH
100690: CALL_OW 310
100694: IFFALSE 100762
// begin z := IsInUnit ( group [ i ] ) ;
100696: LD_ADDR_VAR 0 13
100700: PUSH
100701: LD_VAR 0 4
100705: PUSH
100706: LD_VAR 0 7
100710: ARRAY
100711: PPUSH
100712: CALL_OW 310
100716: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100717: LD_VAR 0 13
100721: PUSH
100722: LD_VAR 0 32
100726: IN
100727: PUSH
100728: LD_VAR 0 13
100732: PPUSH
100733: LD_VAR 0 22
100737: PPUSH
100738: CALL_OW 308
100742: AND
100743: IFFALSE 100760
// ComExitVehicle ( group [ i ] ) ;
100745: LD_VAR 0 4
100749: PUSH
100750: LD_VAR 0 7
100754: ARRAY
100755: PPUSH
100756: CALL_OW 121
// end else
100760: GO 100939
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100762: LD_ADDR_VAR 0 13
100766: PUSH
100767: LD_VAR 0 4
100771: PPUSH
100772: LD_INT 95
100774: PUSH
100775: LD_VAR 0 22
100779: PUSH
100780: EMPTY
100781: LIST
100782: LIST
100783: PUSH
100784: LD_INT 58
100786: PUSH
100787: EMPTY
100788: LIST
100789: PUSH
100790: EMPTY
100791: LIST
100792: LIST
100793: PPUSH
100794: CALL_OW 72
100798: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
100799: LD_VAR 0 4
100803: PUSH
100804: LD_VAR 0 7
100808: ARRAY
100809: PPUSH
100810: CALL_OW 314
100814: NOT
100815: IFFALSE 100937
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
100817: LD_ADDR_VAR 0 10
100821: PUSH
100822: LD_VAR 0 13
100826: PPUSH
100827: LD_VAR 0 4
100831: PUSH
100832: LD_VAR 0 7
100836: ARRAY
100837: PPUSH
100838: CALL_OW 74
100842: ST_TO_ADDR
// if not x then
100843: LD_VAR 0 10
100847: NOT
100848: IFFALSE 100852
// continue ;
100850: GO 100284
// if GetLives ( x ) < 1000 then
100852: LD_VAR 0 10
100856: PPUSH
100857: CALL_OW 256
100861: PUSH
100862: LD_INT 1000
100864: LESS
100865: IFFALSE 100889
// ComRepairVehicle ( group [ i ] , x ) else
100867: LD_VAR 0 4
100871: PUSH
100872: LD_VAR 0 7
100876: ARRAY
100877: PPUSH
100878: LD_VAR 0 10
100882: PPUSH
100883: CALL_OW 129
100887: GO 100937
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
100889: LD_VAR 0 23
100893: PUSH
100894: LD_VAR 0 4
100898: PUSH
100899: LD_VAR 0 7
100903: ARRAY
100904: PPUSH
100905: CALL_OW 256
100909: PUSH
100910: LD_INT 1000
100912: LESS
100913: AND
100914: NOT
100915: IFFALSE 100937
// ComEnterUnit ( group [ i ] , x ) ;
100917: LD_VAR 0 4
100921: PUSH
100922: LD_VAR 0 7
100926: ARRAY
100927: PPUSH
100928: LD_VAR 0 10
100932: PPUSH
100933: CALL_OW 120
// end ; continue ;
100937: GO 100284
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
100939: LD_VAR 0 23
100943: PUSH
100944: LD_VAR 0 4
100948: PUSH
100949: LD_VAR 0 7
100953: ARRAY
100954: PPUSH
100955: CALL_OW 247
100959: PUSH
100960: LD_INT 1
100962: EQUAL
100963: AND
100964: IFFALSE 101442
// begin if group [ i ] in healers then
100966: LD_VAR 0 4
100970: PUSH
100971: LD_VAR 0 7
100975: ARRAY
100976: PUSH
100977: LD_VAR 0 31
100981: IN
100982: IFFALSE 101255
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
100984: LD_VAR 0 4
100988: PUSH
100989: LD_VAR 0 7
100993: ARRAY
100994: PPUSH
100995: LD_VAR 0 23
100999: PPUSH
101000: CALL_OW 308
101004: NOT
101005: PUSH
101006: LD_VAR 0 4
101010: PUSH
101011: LD_VAR 0 7
101015: ARRAY
101016: PPUSH
101017: CALL_OW 314
101021: NOT
101022: AND
101023: IFFALSE 101047
// ComMoveToArea ( group [ i ] , f_heal ) else
101025: LD_VAR 0 4
101029: PUSH
101030: LD_VAR 0 7
101034: ARRAY
101035: PPUSH
101036: LD_VAR 0 23
101040: PPUSH
101041: CALL_OW 113
101045: GO 101253
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101047: LD_VAR 0 4
101051: PUSH
101052: LD_VAR 0 7
101056: ARRAY
101057: PPUSH
101058: CALL 83981 0 1
101062: PPUSH
101063: CALL_OW 256
101067: PUSH
101068: LD_INT 1000
101070: EQUAL
101071: IFFALSE 101090
// ComStop ( group [ i ] ) else
101073: LD_VAR 0 4
101077: PUSH
101078: LD_VAR 0 7
101082: ARRAY
101083: PPUSH
101084: CALL_OW 141
101088: GO 101253
// if not HasTask ( group [ i ] ) and to_heal then
101090: LD_VAR 0 4
101094: PUSH
101095: LD_VAR 0 7
101099: ARRAY
101100: PPUSH
101101: CALL_OW 314
101105: NOT
101106: PUSH
101107: LD_VAR 0 30
101111: AND
101112: IFFALSE 101253
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101114: LD_ADDR_VAR 0 13
101118: PUSH
101119: LD_VAR 0 30
101123: PPUSH
101124: LD_INT 3
101126: PUSH
101127: LD_INT 54
101129: PUSH
101130: EMPTY
101131: LIST
101132: PUSH
101133: EMPTY
101134: LIST
101135: LIST
101136: PPUSH
101137: CALL_OW 72
101141: PPUSH
101142: LD_VAR 0 4
101146: PUSH
101147: LD_VAR 0 7
101151: ARRAY
101152: PPUSH
101153: CALL_OW 74
101157: ST_TO_ADDR
// if z then
101158: LD_VAR 0 13
101162: IFFALSE 101253
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101164: LD_INT 91
101166: PUSH
101167: LD_VAR 0 13
101171: PUSH
101172: LD_INT 10
101174: PUSH
101175: EMPTY
101176: LIST
101177: LIST
101178: LIST
101179: PUSH
101180: LD_INT 81
101182: PUSH
101183: LD_VAR 0 13
101187: PPUSH
101188: CALL_OW 255
101192: PUSH
101193: EMPTY
101194: LIST
101195: LIST
101196: PUSH
101197: EMPTY
101198: LIST
101199: LIST
101200: PPUSH
101201: CALL_OW 69
101205: PUSH
101206: LD_INT 0
101208: EQUAL
101209: IFFALSE 101233
// ComHeal ( group [ i ] , z ) else
101211: LD_VAR 0 4
101215: PUSH
101216: LD_VAR 0 7
101220: ARRAY
101221: PPUSH
101222: LD_VAR 0 13
101226: PPUSH
101227: CALL_OW 128
101231: GO 101253
// ComMoveToArea ( group [ i ] , f_heal ) ;
101233: LD_VAR 0 4
101237: PUSH
101238: LD_VAR 0 7
101242: ARRAY
101243: PPUSH
101244: LD_VAR 0 23
101248: PPUSH
101249: CALL_OW 113
// end ; continue ;
101253: GO 100284
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101255: LD_VAR 0 4
101259: PUSH
101260: LD_VAR 0 7
101264: ARRAY
101265: PPUSH
101266: CALL_OW 256
101270: PUSH
101271: LD_INT 700
101273: LESS
101274: PUSH
101275: LD_VAR 0 4
101279: PUSH
101280: LD_VAR 0 7
101284: ARRAY
101285: PUSH
101286: LD_VAR 0 30
101290: IN
101291: NOT
101292: AND
101293: IFFALSE 101317
// to_heal := to_heal union group [ i ] ;
101295: LD_ADDR_VAR 0 30
101299: PUSH
101300: LD_VAR 0 30
101304: PUSH
101305: LD_VAR 0 4
101309: PUSH
101310: LD_VAR 0 7
101314: ARRAY
101315: UNION
101316: ST_TO_ADDR
// if group [ i ] in to_heal then
101317: LD_VAR 0 4
101321: PUSH
101322: LD_VAR 0 7
101326: ARRAY
101327: PUSH
101328: LD_VAR 0 30
101332: IN
101333: IFFALSE 101442
// begin if GetLives ( group [ i ] ) = 1000 then
101335: LD_VAR 0 4
101339: PUSH
101340: LD_VAR 0 7
101344: ARRAY
101345: PPUSH
101346: CALL_OW 256
101350: PUSH
101351: LD_INT 1000
101353: EQUAL
101354: IFFALSE 101380
// to_heal := to_heal diff group [ i ] else
101356: LD_ADDR_VAR 0 30
101360: PUSH
101361: LD_VAR 0 30
101365: PUSH
101366: LD_VAR 0 4
101370: PUSH
101371: LD_VAR 0 7
101375: ARRAY
101376: DIFF
101377: ST_TO_ADDR
101378: GO 101442
// begin if not IsInArea ( group [ i ] , to_heal ) then
101380: LD_VAR 0 4
101384: PUSH
101385: LD_VAR 0 7
101389: ARRAY
101390: PPUSH
101391: LD_VAR 0 30
101395: PPUSH
101396: CALL_OW 308
101400: NOT
101401: IFFALSE 101425
// ComMoveToArea ( group [ i ] , f_heal ) else
101403: LD_VAR 0 4
101407: PUSH
101408: LD_VAR 0 7
101412: ARRAY
101413: PPUSH
101414: LD_VAR 0 23
101418: PPUSH
101419: CALL_OW 113
101423: GO 101440
// ComHold ( group [ i ] ) ;
101425: LD_VAR 0 4
101429: PUSH
101430: LD_VAR 0 7
101434: ARRAY
101435: PPUSH
101436: CALL_OW 140
// continue ;
101440: GO 100284
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101442: LD_VAR 0 4
101446: PUSH
101447: LD_VAR 0 7
101451: ARRAY
101452: PPUSH
101453: LD_INT 10
101455: PPUSH
101456: CALL 82401 0 2
101460: NOT
101461: PUSH
101462: LD_VAR 0 16
101466: PUSH
101467: LD_VAR 0 7
101471: ARRAY
101472: PUSH
101473: EMPTY
101474: EQUAL
101475: NOT
101476: AND
101477: IFFALSE 101743
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101479: LD_VAR 0 4
101483: PUSH
101484: LD_VAR 0 7
101488: ARRAY
101489: PPUSH
101490: CALL_OW 262
101494: PUSH
101495: LD_INT 1
101497: PUSH
101498: LD_INT 2
101500: PUSH
101501: EMPTY
101502: LIST
101503: LIST
101504: IN
101505: IFFALSE 101546
// if GetFuel ( group [ i ] ) < 10 then
101507: LD_VAR 0 4
101511: PUSH
101512: LD_VAR 0 7
101516: ARRAY
101517: PPUSH
101518: CALL_OW 261
101522: PUSH
101523: LD_INT 10
101525: LESS
101526: IFFALSE 101546
// SetFuel ( group [ i ] , 12 ) ;
101528: LD_VAR 0 4
101532: PUSH
101533: LD_VAR 0 7
101537: ARRAY
101538: PPUSH
101539: LD_INT 12
101541: PPUSH
101542: CALL_OW 240
// if units_path [ i ] then
101546: LD_VAR 0 16
101550: PUSH
101551: LD_VAR 0 7
101555: ARRAY
101556: IFFALSE 101741
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101558: LD_VAR 0 4
101562: PUSH
101563: LD_VAR 0 7
101567: ARRAY
101568: PPUSH
101569: LD_VAR 0 16
101573: PUSH
101574: LD_VAR 0 7
101578: ARRAY
101579: PUSH
101580: LD_INT 1
101582: ARRAY
101583: PUSH
101584: LD_INT 1
101586: ARRAY
101587: PPUSH
101588: LD_VAR 0 16
101592: PUSH
101593: LD_VAR 0 7
101597: ARRAY
101598: PUSH
101599: LD_INT 1
101601: ARRAY
101602: PUSH
101603: LD_INT 2
101605: ARRAY
101606: PPUSH
101607: CALL_OW 297
101611: PUSH
101612: LD_INT 6
101614: GREATER
101615: IFFALSE 101690
// begin if not HasTask ( group [ i ] ) then
101617: LD_VAR 0 4
101621: PUSH
101622: LD_VAR 0 7
101626: ARRAY
101627: PPUSH
101628: CALL_OW 314
101632: NOT
101633: IFFALSE 101688
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101635: LD_VAR 0 4
101639: PUSH
101640: LD_VAR 0 7
101644: ARRAY
101645: PPUSH
101646: LD_VAR 0 16
101650: PUSH
101651: LD_VAR 0 7
101655: ARRAY
101656: PUSH
101657: LD_INT 1
101659: ARRAY
101660: PUSH
101661: LD_INT 1
101663: ARRAY
101664: PPUSH
101665: LD_VAR 0 16
101669: PUSH
101670: LD_VAR 0 7
101674: ARRAY
101675: PUSH
101676: LD_INT 1
101678: ARRAY
101679: PUSH
101680: LD_INT 2
101682: ARRAY
101683: PPUSH
101684: CALL_OW 114
// end else
101688: GO 101741
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101690: LD_ADDR_VAR 0 15
101694: PUSH
101695: LD_VAR 0 16
101699: PUSH
101700: LD_VAR 0 7
101704: ARRAY
101705: PPUSH
101706: LD_INT 1
101708: PPUSH
101709: CALL_OW 3
101713: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101714: LD_ADDR_VAR 0 16
101718: PUSH
101719: LD_VAR 0 16
101723: PPUSH
101724: LD_VAR 0 7
101728: PPUSH
101729: LD_VAR 0 15
101733: PPUSH
101734: CALL_OW 1
101738: ST_TO_ADDR
// continue ;
101739: GO 100284
// end ; end ; end else
101741: GO 104405
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101743: LD_ADDR_VAR 0 14
101747: PUSH
101748: LD_INT 81
101750: PUSH
101751: LD_VAR 0 4
101755: PUSH
101756: LD_VAR 0 7
101760: ARRAY
101761: PPUSH
101762: CALL_OW 255
101766: PUSH
101767: EMPTY
101768: LIST
101769: LIST
101770: PPUSH
101771: CALL_OW 69
101775: ST_TO_ADDR
// if not tmp then
101776: LD_VAR 0 14
101780: NOT
101781: IFFALSE 101785
// continue ;
101783: GO 100284
// if f_ignore_area then
101785: LD_VAR 0 17
101789: IFFALSE 101877
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
101791: LD_ADDR_VAR 0 15
101795: PUSH
101796: LD_VAR 0 14
101800: PPUSH
101801: LD_INT 3
101803: PUSH
101804: LD_INT 92
101806: PUSH
101807: LD_VAR 0 17
101811: PUSH
101812: LD_INT 1
101814: ARRAY
101815: PUSH
101816: LD_VAR 0 17
101820: PUSH
101821: LD_INT 2
101823: ARRAY
101824: PUSH
101825: LD_VAR 0 17
101829: PUSH
101830: LD_INT 3
101832: ARRAY
101833: PUSH
101834: EMPTY
101835: LIST
101836: LIST
101837: LIST
101838: LIST
101839: PUSH
101840: EMPTY
101841: LIST
101842: LIST
101843: PPUSH
101844: CALL_OW 72
101848: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101849: LD_VAR 0 14
101853: PUSH
101854: LD_VAR 0 15
101858: DIFF
101859: IFFALSE 101877
// tmp := tmp diff tmp2 ;
101861: LD_ADDR_VAR 0 14
101865: PUSH
101866: LD_VAR 0 14
101870: PUSH
101871: LD_VAR 0 15
101875: DIFF
101876: ST_TO_ADDR
// end ; if not f_murder then
101877: LD_VAR 0 20
101881: NOT
101882: IFFALSE 101940
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
101884: LD_ADDR_VAR 0 15
101888: PUSH
101889: LD_VAR 0 14
101893: PPUSH
101894: LD_INT 3
101896: PUSH
101897: LD_INT 50
101899: PUSH
101900: EMPTY
101901: LIST
101902: PUSH
101903: EMPTY
101904: LIST
101905: LIST
101906: PPUSH
101907: CALL_OW 72
101911: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101912: LD_VAR 0 14
101916: PUSH
101917: LD_VAR 0 15
101921: DIFF
101922: IFFALSE 101940
// tmp := tmp diff tmp2 ;
101924: LD_ADDR_VAR 0 14
101928: PUSH
101929: LD_VAR 0 14
101933: PUSH
101934: LD_VAR 0 15
101938: DIFF
101939: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
101940: LD_ADDR_VAR 0 14
101944: PUSH
101945: LD_VAR 0 4
101949: PUSH
101950: LD_VAR 0 7
101954: ARRAY
101955: PPUSH
101956: LD_VAR 0 14
101960: PPUSH
101961: LD_INT 1
101963: PPUSH
101964: LD_INT 1
101966: PPUSH
101967: CALL 56044 0 4
101971: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
101972: LD_VAR 0 4
101976: PUSH
101977: LD_VAR 0 7
101981: ARRAY
101982: PPUSH
101983: CALL_OW 257
101987: PUSH
101988: LD_INT 1
101990: EQUAL
101991: IFFALSE 102439
// begin if WantPlant ( group [ i ] ) then
101993: LD_VAR 0 4
101997: PUSH
101998: LD_VAR 0 7
102002: ARRAY
102003: PPUSH
102004: CALL 55545 0 1
102008: IFFALSE 102012
// continue ;
102010: GO 100284
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102012: LD_VAR 0 18
102016: PUSH
102017: LD_VAR 0 4
102021: PUSH
102022: LD_VAR 0 7
102026: ARRAY
102027: PPUSH
102028: CALL_OW 310
102032: NOT
102033: AND
102034: PUSH
102035: LD_VAR 0 14
102039: PUSH
102040: LD_INT 1
102042: ARRAY
102043: PUSH
102044: LD_VAR 0 14
102048: PPUSH
102049: LD_INT 21
102051: PUSH
102052: LD_INT 2
102054: PUSH
102055: EMPTY
102056: LIST
102057: LIST
102058: PUSH
102059: LD_INT 58
102061: PUSH
102062: EMPTY
102063: LIST
102064: PUSH
102065: EMPTY
102066: LIST
102067: LIST
102068: PPUSH
102069: CALL_OW 72
102073: IN
102074: AND
102075: IFFALSE 102111
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102077: LD_VAR 0 4
102081: PUSH
102082: LD_VAR 0 7
102086: ARRAY
102087: PPUSH
102088: LD_VAR 0 14
102092: PUSH
102093: LD_INT 1
102095: ARRAY
102096: PPUSH
102097: CALL_OW 120
// attacking := true ;
102101: LD_ADDR_VAR 0 29
102105: PUSH
102106: LD_INT 1
102108: ST_TO_ADDR
// continue ;
102109: GO 100284
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102111: LD_VAR 0 26
102115: PUSH
102116: LD_VAR 0 4
102120: PUSH
102121: LD_VAR 0 7
102125: ARRAY
102126: PPUSH
102127: CALL_OW 257
102131: PUSH
102132: LD_INT 1
102134: EQUAL
102135: AND
102136: PUSH
102137: LD_VAR 0 4
102141: PUSH
102142: LD_VAR 0 7
102146: ARRAY
102147: PPUSH
102148: CALL_OW 256
102152: PUSH
102153: LD_INT 800
102155: LESS
102156: AND
102157: PUSH
102158: LD_VAR 0 4
102162: PUSH
102163: LD_VAR 0 7
102167: ARRAY
102168: PPUSH
102169: CALL_OW 318
102173: NOT
102174: AND
102175: IFFALSE 102192
// ComCrawl ( group [ i ] ) ;
102177: LD_VAR 0 4
102181: PUSH
102182: LD_VAR 0 7
102186: ARRAY
102187: PPUSH
102188: CALL_OW 137
// if f_mines then
102192: LD_VAR 0 21
102196: IFFALSE 102439
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102198: LD_VAR 0 14
102202: PUSH
102203: LD_INT 1
102205: ARRAY
102206: PPUSH
102207: CALL_OW 247
102211: PUSH
102212: LD_INT 3
102214: EQUAL
102215: PUSH
102216: LD_VAR 0 14
102220: PUSH
102221: LD_INT 1
102223: ARRAY
102224: PUSH
102225: LD_VAR 0 27
102229: IN
102230: NOT
102231: AND
102232: IFFALSE 102439
// begin x := GetX ( tmp [ 1 ] ) ;
102234: LD_ADDR_VAR 0 10
102238: PUSH
102239: LD_VAR 0 14
102243: PUSH
102244: LD_INT 1
102246: ARRAY
102247: PPUSH
102248: CALL_OW 250
102252: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102253: LD_ADDR_VAR 0 11
102257: PUSH
102258: LD_VAR 0 14
102262: PUSH
102263: LD_INT 1
102265: ARRAY
102266: PPUSH
102267: CALL_OW 251
102271: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102272: LD_ADDR_VAR 0 12
102276: PUSH
102277: LD_VAR 0 4
102281: PUSH
102282: LD_VAR 0 7
102286: ARRAY
102287: PPUSH
102288: CALL 82486 0 1
102292: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102293: LD_VAR 0 4
102297: PUSH
102298: LD_VAR 0 7
102302: ARRAY
102303: PPUSH
102304: LD_VAR 0 10
102308: PPUSH
102309: LD_VAR 0 11
102313: PPUSH
102314: LD_VAR 0 14
102318: PUSH
102319: LD_INT 1
102321: ARRAY
102322: PPUSH
102323: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102327: LD_VAR 0 4
102331: PUSH
102332: LD_VAR 0 7
102336: ARRAY
102337: PPUSH
102338: LD_VAR 0 10
102342: PPUSH
102343: LD_VAR 0 12
102347: PPUSH
102348: LD_INT 7
102350: PPUSH
102351: CALL_OW 272
102355: PPUSH
102356: LD_VAR 0 11
102360: PPUSH
102361: LD_VAR 0 12
102365: PPUSH
102366: LD_INT 7
102368: PPUSH
102369: CALL_OW 273
102373: PPUSH
102374: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102378: LD_VAR 0 4
102382: PUSH
102383: LD_VAR 0 7
102387: ARRAY
102388: PPUSH
102389: LD_INT 71
102391: PPUSH
102392: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102396: LD_ADDR_VAR 0 27
102400: PUSH
102401: LD_VAR 0 27
102405: PPUSH
102406: LD_VAR 0 27
102410: PUSH
102411: LD_INT 1
102413: PLUS
102414: PPUSH
102415: LD_VAR 0 14
102419: PUSH
102420: LD_INT 1
102422: ARRAY
102423: PPUSH
102424: CALL_OW 1
102428: ST_TO_ADDR
// attacking := true ;
102429: LD_ADDR_VAR 0 29
102433: PUSH
102434: LD_INT 1
102436: ST_TO_ADDR
// continue ;
102437: GO 100284
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102439: LD_VAR 0 4
102443: PUSH
102444: LD_VAR 0 7
102448: ARRAY
102449: PPUSH
102450: CALL_OW 257
102454: PUSH
102455: LD_INT 17
102457: EQUAL
102458: PUSH
102459: LD_VAR 0 4
102463: PUSH
102464: LD_VAR 0 7
102468: ARRAY
102469: PPUSH
102470: CALL_OW 110
102474: PUSH
102475: LD_INT 71
102477: EQUAL
102478: NOT
102479: AND
102480: IFFALSE 102626
// begin attacking := false ;
102482: LD_ADDR_VAR 0 29
102486: PUSH
102487: LD_INT 0
102489: ST_TO_ADDR
// k := 5 ;
102490: LD_ADDR_VAR 0 9
102494: PUSH
102495: LD_INT 5
102497: ST_TO_ADDR
// if tmp < k then
102498: LD_VAR 0 14
102502: PUSH
102503: LD_VAR 0 9
102507: LESS
102508: IFFALSE 102520
// k := tmp ;
102510: LD_ADDR_VAR 0 9
102514: PUSH
102515: LD_VAR 0 14
102519: ST_TO_ADDR
// for j = 1 to k do
102520: LD_ADDR_VAR 0 8
102524: PUSH
102525: DOUBLE
102526: LD_INT 1
102528: DEC
102529: ST_TO_ADDR
102530: LD_VAR 0 9
102534: PUSH
102535: FOR_TO
102536: IFFALSE 102624
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102538: LD_VAR 0 14
102542: PUSH
102543: LD_VAR 0 8
102547: ARRAY
102548: PUSH
102549: LD_VAR 0 14
102553: PPUSH
102554: LD_INT 58
102556: PUSH
102557: EMPTY
102558: LIST
102559: PPUSH
102560: CALL_OW 72
102564: IN
102565: NOT
102566: IFFALSE 102622
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102568: LD_VAR 0 4
102572: PUSH
102573: LD_VAR 0 7
102577: ARRAY
102578: PPUSH
102579: LD_VAR 0 14
102583: PUSH
102584: LD_VAR 0 8
102588: ARRAY
102589: PPUSH
102590: CALL_OW 115
// attacking := true ;
102594: LD_ADDR_VAR 0 29
102598: PUSH
102599: LD_INT 1
102601: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102602: LD_VAR 0 4
102606: PUSH
102607: LD_VAR 0 7
102611: ARRAY
102612: PPUSH
102613: LD_INT 71
102615: PPUSH
102616: CALL_OW 109
// continue ;
102620: GO 102535
// end ; end ;
102622: GO 102535
102624: POP
102625: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102626: LD_VAR 0 4
102630: PUSH
102631: LD_VAR 0 7
102635: ARRAY
102636: PPUSH
102637: CALL_OW 257
102641: PUSH
102642: LD_INT 8
102644: EQUAL
102645: PUSH
102646: LD_VAR 0 4
102650: PUSH
102651: LD_VAR 0 7
102655: ARRAY
102656: PPUSH
102657: CALL_OW 264
102661: PUSH
102662: LD_INT 28
102664: PUSH
102665: LD_INT 45
102667: PUSH
102668: LD_INT 7
102670: PUSH
102671: LD_INT 47
102673: PUSH
102674: EMPTY
102675: LIST
102676: LIST
102677: LIST
102678: LIST
102679: IN
102680: OR
102681: IFFALSE 102937
// begin attacking := false ;
102683: LD_ADDR_VAR 0 29
102687: PUSH
102688: LD_INT 0
102690: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102691: LD_VAR 0 14
102695: PUSH
102696: LD_INT 1
102698: ARRAY
102699: PPUSH
102700: CALL_OW 266
102704: PUSH
102705: LD_INT 32
102707: PUSH
102708: LD_INT 31
102710: PUSH
102711: LD_INT 33
102713: PUSH
102714: LD_INT 4
102716: PUSH
102717: LD_INT 5
102719: PUSH
102720: EMPTY
102721: LIST
102722: LIST
102723: LIST
102724: LIST
102725: LIST
102726: IN
102727: IFFALSE 102913
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102729: LD_ADDR_VAR 0 9
102733: PUSH
102734: LD_VAR 0 14
102738: PUSH
102739: LD_INT 1
102741: ARRAY
102742: PPUSH
102743: CALL_OW 266
102747: PPUSH
102748: LD_VAR 0 14
102752: PUSH
102753: LD_INT 1
102755: ARRAY
102756: PPUSH
102757: CALL_OW 250
102761: PPUSH
102762: LD_VAR 0 14
102766: PUSH
102767: LD_INT 1
102769: ARRAY
102770: PPUSH
102771: CALL_OW 251
102775: PPUSH
102776: LD_VAR 0 14
102780: PUSH
102781: LD_INT 1
102783: ARRAY
102784: PPUSH
102785: CALL_OW 254
102789: PPUSH
102790: LD_VAR 0 14
102794: PUSH
102795: LD_INT 1
102797: ARRAY
102798: PPUSH
102799: CALL_OW 248
102803: PPUSH
102804: LD_INT 0
102806: PPUSH
102807: CALL 63856 0 6
102811: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
102812: LD_ADDR_VAR 0 8
102816: PUSH
102817: LD_VAR 0 4
102821: PUSH
102822: LD_VAR 0 7
102826: ARRAY
102827: PPUSH
102828: LD_VAR 0 9
102832: PPUSH
102833: CALL 82526 0 2
102837: ST_TO_ADDR
// if j then
102838: LD_VAR 0 8
102842: IFFALSE 102911
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
102844: LD_VAR 0 8
102848: PUSH
102849: LD_INT 1
102851: ARRAY
102852: PPUSH
102853: LD_VAR 0 8
102857: PUSH
102858: LD_INT 2
102860: ARRAY
102861: PPUSH
102862: CALL_OW 488
102866: IFFALSE 102911
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
102868: LD_VAR 0 4
102872: PUSH
102873: LD_VAR 0 7
102877: ARRAY
102878: PPUSH
102879: LD_VAR 0 8
102883: PUSH
102884: LD_INT 1
102886: ARRAY
102887: PPUSH
102888: LD_VAR 0 8
102892: PUSH
102893: LD_INT 2
102895: ARRAY
102896: PPUSH
102897: CALL_OW 116
// attacking := true ;
102901: LD_ADDR_VAR 0 29
102905: PUSH
102906: LD_INT 1
102908: ST_TO_ADDR
// continue ;
102909: GO 100284
// end ; end else
102911: GO 102937
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102913: LD_VAR 0 4
102917: PUSH
102918: LD_VAR 0 7
102922: ARRAY
102923: PPUSH
102924: LD_VAR 0 14
102928: PUSH
102929: LD_INT 1
102931: ARRAY
102932: PPUSH
102933: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
102937: LD_VAR 0 4
102941: PUSH
102942: LD_VAR 0 7
102946: ARRAY
102947: PPUSH
102948: CALL_OW 265
102952: PUSH
102953: LD_INT 11
102955: EQUAL
102956: IFFALSE 103234
// begin k := 10 ;
102958: LD_ADDR_VAR 0 9
102962: PUSH
102963: LD_INT 10
102965: ST_TO_ADDR
// x := 0 ;
102966: LD_ADDR_VAR 0 10
102970: PUSH
102971: LD_INT 0
102973: ST_TO_ADDR
// if tmp < k then
102974: LD_VAR 0 14
102978: PUSH
102979: LD_VAR 0 9
102983: LESS
102984: IFFALSE 102996
// k := tmp ;
102986: LD_ADDR_VAR 0 9
102990: PUSH
102991: LD_VAR 0 14
102995: ST_TO_ADDR
// for j = k downto 1 do
102996: LD_ADDR_VAR 0 8
103000: PUSH
103001: DOUBLE
103002: LD_VAR 0 9
103006: INC
103007: ST_TO_ADDR
103008: LD_INT 1
103010: PUSH
103011: FOR_DOWNTO
103012: IFFALSE 103087
// begin if GetType ( tmp [ j ] ) = unit_human then
103014: LD_VAR 0 14
103018: PUSH
103019: LD_VAR 0 8
103023: ARRAY
103024: PPUSH
103025: CALL_OW 247
103029: PUSH
103030: LD_INT 1
103032: EQUAL
103033: IFFALSE 103085
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103035: LD_VAR 0 4
103039: PUSH
103040: LD_VAR 0 7
103044: ARRAY
103045: PPUSH
103046: LD_VAR 0 14
103050: PUSH
103051: LD_VAR 0 8
103055: ARRAY
103056: PPUSH
103057: CALL 82797 0 2
// x := tmp [ j ] ;
103061: LD_ADDR_VAR 0 10
103065: PUSH
103066: LD_VAR 0 14
103070: PUSH
103071: LD_VAR 0 8
103075: ARRAY
103076: ST_TO_ADDR
// attacking := true ;
103077: LD_ADDR_VAR 0 29
103081: PUSH
103082: LD_INT 1
103084: ST_TO_ADDR
// end ; end ;
103085: GO 103011
103087: POP
103088: POP
// if not x then
103089: LD_VAR 0 10
103093: NOT
103094: IFFALSE 103234
// begin attacking := true ;
103096: LD_ADDR_VAR 0 29
103100: PUSH
103101: LD_INT 1
103103: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103104: LD_VAR 0 4
103108: PUSH
103109: LD_VAR 0 7
103113: ARRAY
103114: PPUSH
103115: CALL_OW 250
103119: PPUSH
103120: LD_VAR 0 4
103124: PUSH
103125: LD_VAR 0 7
103129: ARRAY
103130: PPUSH
103131: CALL_OW 251
103135: PPUSH
103136: CALL_OW 546
103140: PUSH
103141: LD_INT 2
103143: ARRAY
103144: PUSH
103145: LD_VAR 0 14
103149: PUSH
103150: LD_INT 1
103152: ARRAY
103153: PPUSH
103154: CALL_OW 250
103158: PPUSH
103159: LD_VAR 0 14
103163: PUSH
103164: LD_INT 1
103166: ARRAY
103167: PPUSH
103168: CALL_OW 251
103172: PPUSH
103173: CALL_OW 546
103177: PUSH
103178: LD_INT 2
103180: ARRAY
103181: EQUAL
103182: IFFALSE 103210
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103184: LD_VAR 0 4
103188: PUSH
103189: LD_VAR 0 7
103193: ARRAY
103194: PPUSH
103195: LD_VAR 0 14
103199: PUSH
103200: LD_INT 1
103202: ARRAY
103203: PPUSH
103204: CALL 82797 0 2
103208: GO 103234
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103210: LD_VAR 0 4
103214: PUSH
103215: LD_VAR 0 7
103219: ARRAY
103220: PPUSH
103221: LD_VAR 0 14
103225: PUSH
103226: LD_INT 1
103228: ARRAY
103229: PPUSH
103230: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103234: LD_VAR 0 4
103238: PUSH
103239: LD_VAR 0 7
103243: ARRAY
103244: PPUSH
103245: CALL_OW 264
103249: PUSH
103250: LD_INT 29
103252: EQUAL
103253: IFFALSE 103619
// begin if WantsToAttack ( group [ i ] ) in bombed then
103255: LD_VAR 0 4
103259: PUSH
103260: LD_VAR 0 7
103264: ARRAY
103265: PPUSH
103266: CALL_OW 319
103270: PUSH
103271: LD_VAR 0 28
103275: IN
103276: IFFALSE 103280
// continue ;
103278: GO 100284
// k := 8 ;
103280: LD_ADDR_VAR 0 9
103284: PUSH
103285: LD_INT 8
103287: ST_TO_ADDR
// x := 0 ;
103288: LD_ADDR_VAR 0 10
103292: PUSH
103293: LD_INT 0
103295: ST_TO_ADDR
// if tmp < k then
103296: LD_VAR 0 14
103300: PUSH
103301: LD_VAR 0 9
103305: LESS
103306: IFFALSE 103318
// k := tmp ;
103308: LD_ADDR_VAR 0 9
103312: PUSH
103313: LD_VAR 0 14
103317: ST_TO_ADDR
// for j = 1 to k do
103318: LD_ADDR_VAR 0 8
103322: PUSH
103323: DOUBLE
103324: LD_INT 1
103326: DEC
103327: ST_TO_ADDR
103328: LD_VAR 0 9
103332: PUSH
103333: FOR_TO
103334: IFFALSE 103466
// begin if GetType ( tmp [ j ] ) = unit_building then
103336: LD_VAR 0 14
103340: PUSH
103341: LD_VAR 0 8
103345: ARRAY
103346: PPUSH
103347: CALL_OW 247
103351: PUSH
103352: LD_INT 3
103354: EQUAL
103355: IFFALSE 103464
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103357: LD_VAR 0 14
103361: PUSH
103362: LD_VAR 0 8
103366: ARRAY
103367: PUSH
103368: LD_VAR 0 28
103372: IN
103373: NOT
103374: PUSH
103375: LD_VAR 0 14
103379: PUSH
103380: LD_VAR 0 8
103384: ARRAY
103385: PPUSH
103386: CALL_OW 313
103390: AND
103391: IFFALSE 103464
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103393: LD_VAR 0 4
103397: PUSH
103398: LD_VAR 0 7
103402: ARRAY
103403: PPUSH
103404: LD_VAR 0 14
103408: PUSH
103409: LD_VAR 0 8
103413: ARRAY
103414: PPUSH
103415: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103419: LD_ADDR_VAR 0 28
103423: PUSH
103424: LD_VAR 0 28
103428: PPUSH
103429: LD_VAR 0 28
103433: PUSH
103434: LD_INT 1
103436: PLUS
103437: PPUSH
103438: LD_VAR 0 14
103442: PUSH
103443: LD_VAR 0 8
103447: ARRAY
103448: PPUSH
103449: CALL_OW 1
103453: ST_TO_ADDR
// attacking := true ;
103454: LD_ADDR_VAR 0 29
103458: PUSH
103459: LD_INT 1
103461: ST_TO_ADDR
// break ;
103462: GO 103466
// end ; end ;
103464: GO 103333
103466: POP
103467: POP
// if not attacking and f_attack_depot then
103468: LD_VAR 0 29
103472: NOT
103473: PUSH
103474: LD_VAR 0 25
103478: AND
103479: IFFALSE 103574
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103481: LD_ADDR_VAR 0 13
103485: PUSH
103486: LD_VAR 0 14
103490: PPUSH
103491: LD_INT 2
103493: PUSH
103494: LD_INT 30
103496: PUSH
103497: LD_INT 0
103499: PUSH
103500: EMPTY
103501: LIST
103502: LIST
103503: PUSH
103504: LD_INT 30
103506: PUSH
103507: LD_INT 1
103509: PUSH
103510: EMPTY
103511: LIST
103512: LIST
103513: PUSH
103514: EMPTY
103515: LIST
103516: LIST
103517: LIST
103518: PPUSH
103519: CALL_OW 72
103523: ST_TO_ADDR
// if z then
103524: LD_VAR 0 13
103528: IFFALSE 103574
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103530: LD_VAR 0 4
103534: PUSH
103535: LD_VAR 0 7
103539: ARRAY
103540: PPUSH
103541: LD_VAR 0 13
103545: PPUSH
103546: LD_VAR 0 4
103550: PUSH
103551: LD_VAR 0 7
103555: ARRAY
103556: PPUSH
103557: CALL_OW 74
103561: PPUSH
103562: CALL_OW 115
// attacking := true ;
103566: LD_ADDR_VAR 0 29
103570: PUSH
103571: LD_INT 1
103573: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103574: LD_VAR 0 4
103578: PUSH
103579: LD_VAR 0 7
103583: ARRAY
103584: PPUSH
103585: CALL_OW 256
103589: PUSH
103590: LD_INT 500
103592: LESS
103593: IFFALSE 103619
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103595: LD_VAR 0 4
103599: PUSH
103600: LD_VAR 0 7
103604: ARRAY
103605: PPUSH
103606: LD_VAR 0 14
103610: PUSH
103611: LD_INT 1
103613: ARRAY
103614: PPUSH
103615: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103619: LD_VAR 0 4
103623: PUSH
103624: LD_VAR 0 7
103628: ARRAY
103629: PPUSH
103630: CALL_OW 264
103634: PUSH
103635: LD_INT 49
103637: EQUAL
103638: IFFALSE 103759
// begin if not HasTask ( group [ i ] ) then
103640: LD_VAR 0 4
103644: PUSH
103645: LD_VAR 0 7
103649: ARRAY
103650: PPUSH
103651: CALL_OW 314
103655: NOT
103656: IFFALSE 103759
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103658: LD_ADDR_VAR 0 9
103662: PUSH
103663: LD_INT 81
103665: PUSH
103666: LD_VAR 0 4
103670: PUSH
103671: LD_VAR 0 7
103675: ARRAY
103676: PPUSH
103677: CALL_OW 255
103681: PUSH
103682: EMPTY
103683: LIST
103684: LIST
103685: PPUSH
103686: CALL_OW 69
103690: PPUSH
103691: LD_VAR 0 4
103695: PUSH
103696: LD_VAR 0 7
103700: ARRAY
103701: PPUSH
103702: CALL_OW 74
103706: ST_TO_ADDR
// if k then
103707: LD_VAR 0 9
103711: IFFALSE 103759
// if GetDistUnits ( group [ i ] , k ) > 10 then
103713: LD_VAR 0 4
103717: PUSH
103718: LD_VAR 0 7
103722: ARRAY
103723: PPUSH
103724: LD_VAR 0 9
103728: PPUSH
103729: CALL_OW 296
103733: PUSH
103734: LD_INT 10
103736: GREATER
103737: IFFALSE 103759
// ComMoveUnit ( group [ i ] , k ) ;
103739: LD_VAR 0 4
103743: PUSH
103744: LD_VAR 0 7
103748: ARRAY
103749: PPUSH
103750: LD_VAR 0 9
103754: PPUSH
103755: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103759: LD_VAR 0 4
103763: PUSH
103764: LD_VAR 0 7
103768: ARRAY
103769: PPUSH
103770: CALL_OW 256
103774: PUSH
103775: LD_INT 250
103777: LESS
103778: PUSH
103779: LD_VAR 0 4
103783: PUSH
103784: LD_VAR 0 7
103788: ARRAY
103789: PUSH
103790: LD_INT 21
103792: PUSH
103793: LD_INT 2
103795: PUSH
103796: EMPTY
103797: LIST
103798: LIST
103799: PUSH
103800: LD_INT 23
103802: PUSH
103803: LD_INT 2
103805: PUSH
103806: EMPTY
103807: LIST
103808: LIST
103809: PUSH
103810: EMPTY
103811: LIST
103812: LIST
103813: PPUSH
103814: CALL_OW 69
103818: IN
103819: AND
103820: IFFALSE 103945
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
103822: LD_ADDR_VAR 0 9
103826: PUSH
103827: LD_OWVAR 3
103831: PUSH
103832: LD_VAR 0 4
103836: PUSH
103837: LD_VAR 0 7
103841: ARRAY
103842: DIFF
103843: PPUSH
103844: LD_VAR 0 4
103848: PUSH
103849: LD_VAR 0 7
103853: ARRAY
103854: PPUSH
103855: CALL_OW 74
103859: ST_TO_ADDR
// if not k then
103860: LD_VAR 0 9
103864: NOT
103865: IFFALSE 103869
// continue ;
103867: GO 100284
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
103869: LD_VAR 0 9
103873: PUSH
103874: LD_INT 81
103876: PUSH
103877: LD_VAR 0 4
103881: PUSH
103882: LD_VAR 0 7
103886: ARRAY
103887: PPUSH
103888: CALL_OW 255
103892: PUSH
103893: EMPTY
103894: LIST
103895: LIST
103896: PPUSH
103897: CALL_OW 69
103901: IN
103902: PUSH
103903: LD_VAR 0 9
103907: PPUSH
103908: LD_VAR 0 4
103912: PUSH
103913: LD_VAR 0 7
103917: ARRAY
103918: PPUSH
103919: CALL_OW 296
103923: PUSH
103924: LD_INT 5
103926: LESS
103927: AND
103928: IFFALSE 103945
// ComAutodestruct ( group [ i ] ) ;
103930: LD_VAR 0 4
103934: PUSH
103935: LD_VAR 0 7
103939: ARRAY
103940: PPUSH
103941: CALL 82695 0 1
// end ; if f_attack_depot then
103945: LD_VAR 0 25
103949: IFFALSE 104061
// begin k := 6 ;
103951: LD_ADDR_VAR 0 9
103955: PUSH
103956: LD_INT 6
103958: ST_TO_ADDR
// if tmp < k then
103959: LD_VAR 0 14
103963: PUSH
103964: LD_VAR 0 9
103968: LESS
103969: IFFALSE 103981
// k := tmp ;
103971: LD_ADDR_VAR 0 9
103975: PUSH
103976: LD_VAR 0 14
103980: ST_TO_ADDR
// for j = 1 to k do
103981: LD_ADDR_VAR 0 8
103985: PUSH
103986: DOUBLE
103987: LD_INT 1
103989: DEC
103990: ST_TO_ADDR
103991: LD_VAR 0 9
103995: PUSH
103996: FOR_TO
103997: IFFALSE 104059
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103999: LD_VAR 0 8
104003: PPUSH
104004: CALL_OW 266
104008: PUSH
104009: LD_INT 0
104011: PUSH
104012: LD_INT 1
104014: PUSH
104015: EMPTY
104016: LIST
104017: LIST
104018: IN
104019: IFFALSE 104057
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104021: LD_VAR 0 4
104025: PUSH
104026: LD_VAR 0 7
104030: ARRAY
104031: PPUSH
104032: LD_VAR 0 14
104036: PUSH
104037: LD_VAR 0 8
104041: ARRAY
104042: PPUSH
104043: CALL_OW 115
// attacking := true ;
104047: LD_ADDR_VAR 0 29
104051: PUSH
104052: LD_INT 1
104054: ST_TO_ADDR
// break ;
104055: GO 104059
// end ;
104057: GO 103996
104059: POP
104060: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104061: LD_VAR 0 4
104065: PUSH
104066: LD_VAR 0 7
104070: ARRAY
104071: PPUSH
104072: CALL_OW 302
104076: PUSH
104077: LD_VAR 0 29
104081: NOT
104082: AND
104083: IFFALSE 104405
// begin if GetTag ( group [ i ] ) = 71 then
104085: LD_VAR 0 4
104089: PUSH
104090: LD_VAR 0 7
104094: ARRAY
104095: PPUSH
104096: CALL_OW 110
104100: PUSH
104101: LD_INT 71
104103: EQUAL
104104: IFFALSE 104145
// begin if HasTask ( group [ i ] ) then
104106: LD_VAR 0 4
104110: PUSH
104111: LD_VAR 0 7
104115: ARRAY
104116: PPUSH
104117: CALL_OW 314
104121: IFFALSE 104127
// continue else
104123: GO 100284
104125: GO 104145
// SetTag ( group [ i ] , 0 ) ;
104127: LD_VAR 0 4
104131: PUSH
104132: LD_VAR 0 7
104136: ARRAY
104137: PPUSH
104138: LD_INT 0
104140: PPUSH
104141: CALL_OW 109
// end ; k := 8 ;
104145: LD_ADDR_VAR 0 9
104149: PUSH
104150: LD_INT 8
104152: ST_TO_ADDR
// x := 0 ;
104153: LD_ADDR_VAR 0 10
104157: PUSH
104158: LD_INT 0
104160: ST_TO_ADDR
// if tmp < k then
104161: LD_VAR 0 14
104165: PUSH
104166: LD_VAR 0 9
104170: LESS
104171: IFFALSE 104183
// k := tmp ;
104173: LD_ADDR_VAR 0 9
104177: PUSH
104178: LD_VAR 0 14
104182: ST_TO_ADDR
// for j = 1 to k do
104183: LD_ADDR_VAR 0 8
104187: PUSH
104188: DOUBLE
104189: LD_INT 1
104191: DEC
104192: ST_TO_ADDR
104193: LD_VAR 0 9
104197: PUSH
104198: FOR_TO
104199: IFFALSE 104297
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104201: LD_VAR 0 14
104205: PUSH
104206: LD_VAR 0 8
104210: ARRAY
104211: PPUSH
104212: CALL_OW 247
104216: PUSH
104217: LD_INT 1
104219: EQUAL
104220: PUSH
104221: LD_VAR 0 14
104225: PUSH
104226: LD_VAR 0 8
104230: ARRAY
104231: PPUSH
104232: CALL_OW 256
104236: PUSH
104237: LD_INT 250
104239: LESS
104240: PUSH
104241: LD_VAR 0 20
104245: AND
104246: PUSH
104247: LD_VAR 0 20
104251: NOT
104252: PUSH
104253: LD_VAR 0 14
104257: PUSH
104258: LD_VAR 0 8
104262: ARRAY
104263: PPUSH
104264: CALL_OW 256
104268: PUSH
104269: LD_INT 250
104271: GREATEREQUAL
104272: AND
104273: OR
104274: AND
104275: IFFALSE 104295
// begin x := tmp [ j ] ;
104277: LD_ADDR_VAR 0 10
104281: PUSH
104282: LD_VAR 0 14
104286: PUSH
104287: LD_VAR 0 8
104291: ARRAY
104292: ST_TO_ADDR
// break ;
104293: GO 104297
// end ;
104295: GO 104198
104297: POP
104298: POP
// if x then
104299: LD_VAR 0 10
104303: IFFALSE 104327
// ComAttackUnit ( group [ i ] , x ) else
104305: LD_VAR 0 4
104309: PUSH
104310: LD_VAR 0 7
104314: ARRAY
104315: PPUSH
104316: LD_VAR 0 10
104320: PPUSH
104321: CALL_OW 115
104325: GO 104351
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104327: LD_VAR 0 4
104331: PUSH
104332: LD_VAR 0 7
104336: ARRAY
104337: PPUSH
104338: LD_VAR 0 14
104342: PUSH
104343: LD_INT 1
104345: ARRAY
104346: PPUSH
104347: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104351: LD_VAR 0 4
104355: PUSH
104356: LD_VAR 0 7
104360: ARRAY
104361: PPUSH
104362: CALL_OW 314
104366: NOT
104367: IFFALSE 104405
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104369: LD_VAR 0 4
104373: PUSH
104374: LD_VAR 0 7
104378: ARRAY
104379: PPUSH
104380: LD_VAR 0 14
104384: PPUSH
104385: LD_VAR 0 4
104389: PUSH
104390: LD_VAR 0 7
104394: ARRAY
104395: PPUSH
104396: CALL_OW 74
104400: PPUSH
104401: CALL_OW 115
// end ; end ; end ;
104405: GO 100284
104407: POP
104408: POP
// wait ( 0 0$2 ) ;
104409: LD_INT 70
104411: PPUSH
104412: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104416: LD_VAR 0 4
104420: NOT
104421: PUSH
104422: LD_VAR 0 4
104426: PUSH
104427: EMPTY
104428: EQUAL
104429: OR
104430: PUSH
104431: LD_INT 81
104433: PUSH
104434: LD_VAR 0 35
104438: PUSH
104439: EMPTY
104440: LIST
104441: LIST
104442: PPUSH
104443: CALL_OW 69
104447: NOT
104448: OR
104449: IFFALSE 100269
// end ;
104451: LD_VAR 0 2
104455: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
104456: LD_INT 0
104458: PPUSH
104459: PPUSH
104460: PPUSH
104461: PPUSH
104462: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
104463: LD_VAR 0 1
104467: NOT
104468: PUSH
104469: LD_EXP 88
104473: PUSH
104474: LD_VAR 0 1
104478: ARRAY
104479: NOT
104480: OR
104481: PUSH
104482: LD_VAR 0 2
104486: NOT
104487: OR
104488: PUSH
104489: LD_VAR 0 3
104493: NOT
104494: OR
104495: IFFALSE 104499
// exit ;
104497: GO 105012
// side := mc_sides [ base ] ;
104499: LD_ADDR_VAR 0 6
104503: PUSH
104504: LD_EXP 114
104508: PUSH
104509: LD_VAR 0 1
104513: ARRAY
104514: ST_TO_ADDR
// if not side then
104515: LD_VAR 0 6
104519: NOT
104520: IFFALSE 104524
// exit ;
104522: GO 105012
// for i in solds do
104524: LD_ADDR_VAR 0 7
104528: PUSH
104529: LD_VAR 0 2
104533: PUSH
104534: FOR_IN
104535: IFFALSE 104596
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
104537: LD_VAR 0 7
104541: PPUSH
104542: CALL_OW 310
104546: PPUSH
104547: CALL_OW 266
104551: PUSH
104552: LD_INT 32
104554: PUSH
104555: LD_INT 31
104557: PUSH
104558: EMPTY
104559: LIST
104560: LIST
104561: IN
104562: IFFALSE 104582
// solds := solds diff i else
104564: LD_ADDR_VAR 0 2
104568: PUSH
104569: LD_VAR 0 2
104573: PUSH
104574: LD_VAR 0 7
104578: DIFF
104579: ST_TO_ADDR
104580: GO 104594
// SetTag ( i , 18 ) ;
104582: LD_VAR 0 7
104586: PPUSH
104587: LD_INT 18
104589: PPUSH
104590: CALL_OW 109
104594: GO 104534
104596: POP
104597: POP
// if not solds then
104598: LD_VAR 0 2
104602: NOT
104603: IFFALSE 104607
// exit ;
104605: GO 105012
// repeat wait ( 0 0$1 ) ;
104607: LD_INT 35
104609: PPUSH
104610: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
104614: LD_ADDR_VAR 0 5
104618: PUSH
104619: LD_VAR 0 6
104623: PPUSH
104624: LD_VAR 0 3
104628: PPUSH
104629: CALL 52410 0 2
104633: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104634: LD_EXP 88
104638: PUSH
104639: LD_VAR 0 1
104643: ARRAY
104644: NOT
104645: PUSH
104646: LD_EXP 88
104650: PUSH
104651: LD_VAR 0 1
104655: ARRAY
104656: PUSH
104657: EMPTY
104658: EQUAL
104659: OR
104660: IFFALSE 104697
// begin for i in solds do
104662: LD_ADDR_VAR 0 7
104666: PUSH
104667: LD_VAR 0 2
104671: PUSH
104672: FOR_IN
104673: IFFALSE 104686
// ComStop ( i ) ;
104675: LD_VAR 0 7
104679: PPUSH
104680: CALL_OW 141
104684: GO 104672
104686: POP
104687: POP
// solds := [ ] ;
104688: LD_ADDR_VAR 0 2
104692: PUSH
104693: EMPTY
104694: ST_TO_ADDR
// exit ;
104695: GO 105012
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
104697: LD_VAR 0 5
104701: NOT
104702: PUSH
104703: LD_VAR 0 5
104707: PUSH
104708: LD_INT 3
104710: GREATER
104711: OR
104712: PUSH
104713: LD_EXP 110
104717: PUSH
104718: LD_VAR 0 1
104722: ARRAY
104723: OR
104724: IFFALSE 104765
// begin for i in solds do
104726: LD_ADDR_VAR 0 7
104730: PUSH
104731: LD_VAR 0 2
104735: PUSH
104736: FOR_IN
104737: IFFALSE 104761
// if HasTask ( i ) then
104739: LD_VAR 0 7
104743: PPUSH
104744: CALL_OW 314
104748: IFFALSE 104759
// ComStop ( i ) ;
104750: LD_VAR 0 7
104754: PPUSH
104755: CALL_OW 141
104759: GO 104736
104761: POP
104762: POP
// break ;
104763: GO 105000
// end ; for i in solds do
104765: LD_ADDR_VAR 0 7
104769: PUSH
104770: LD_VAR 0 2
104774: PUSH
104775: FOR_IN
104776: IFFALSE 104992
// begin if IsInUnit ( i ) then
104778: LD_VAR 0 7
104782: PPUSH
104783: CALL_OW 310
104787: IFFALSE 104798
// ComExitBuilding ( i ) ;
104789: LD_VAR 0 7
104793: PPUSH
104794: CALL_OW 122
// if GetLives ( i ) > 333 then
104798: LD_VAR 0 7
104802: PPUSH
104803: CALL_OW 256
104807: PUSH
104808: LD_INT 333
104810: GREATER
104811: IFFALSE 104839
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
104813: LD_VAR 0 7
104817: PPUSH
104818: LD_VAR 0 5
104822: PPUSH
104823: LD_VAR 0 7
104827: PPUSH
104828: CALL_OW 74
104832: PPUSH
104833: CALL_OW 115
104837: GO 104990
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
104839: LD_ADDR_VAR 0 8
104843: PUSH
104844: LD_EXP 88
104848: PUSH
104849: LD_VAR 0 1
104853: ARRAY
104854: PPUSH
104855: LD_INT 2
104857: PUSH
104858: LD_INT 30
104860: PUSH
104861: LD_INT 0
104863: PUSH
104864: EMPTY
104865: LIST
104866: LIST
104867: PUSH
104868: LD_INT 30
104870: PUSH
104871: LD_INT 1
104873: PUSH
104874: EMPTY
104875: LIST
104876: LIST
104877: PUSH
104878: LD_INT 30
104880: PUSH
104881: LD_INT 6
104883: PUSH
104884: EMPTY
104885: LIST
104886: LIST
104887: PUSH
104888: EMPTY
104889: LIST
104890: LIST
104891: LIST
104892: LIST
104893: PPUSH
104894: CALL_OW 72
104898: PPUSH
104899: LD_VAR 0 7
104903: PPUSH
104904: CALL_OW 74
104908: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
104909: LD_VAR 0 7
104913: PPUSH
104914: LD_VAR 0 8
104918: PPUSH
104919: CALL_OW 250
104923: PPUSH
104924: LD_INT 3
104926: PPUSH
104927: LD_INT 5
104929: PPUSH
104930: CALL_OW 272
104934: PPUSH
104935: LD_VAR 0 8
104939: PPUSH
104940: CALL_OW 251
104944: PPUSH
104945: LD_INT 3
104947: PPUSH
104948: LD_INT 5
104950: PPUSH
104951: CALL_OW 273
104955: PPUSH
104956: CALL_OW 111
// SetTag ( i , 0 ) ;
104960: LD_VAR 0 7
104964: PPUSH
104965: LD_INT 0
104967: PPUSH
104968: CALL_OW 109
// solds := solds diff i ;
104972: LD_ADDR_VAR 0 2
104976: PUSH
104977: LD_VAR 0 2
104981: PUSH
104982: LD_VAR 0 7
104986: DIFF
104987: ST_TO_ADDR
// continue ;
104988: GO 104775
// end ; end ;
104990: GO 104775
104992: POP
104993: POP
// until solds ;
104994: LD_VAR 0 2
104998: IFFALSE 104607
// MC_Reset ( base , 18 ) ;
105000: LD_VAR 0 1
105004: PPUSH
105005: LD_INT 18
105007: PPUSH
105008: CALL 24718 0 2
// end ;
105012: LD_VAR 0 4
105016: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
105017: LD_INT 0
105019: PPUSH
105020: PPUSH
105021: PPUSH
105022: PPUSH
105023: PPUSH
105024: PPUSH
105025: PPUSH
105026: PPUSH
105027: PPUSH
105028: PPUSH
105029: PPUSH
105030: PPUSH
105031: PPUSH
105032: PPUSH
105033: PPUSH
105034: PPUSH
105035: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
105036: LD_ADDR_VAR 0 13
105040: PUSH
105041: LD_EXP 88
105045: PUSH
105046: LD_VAR 0 1
105050: ARRAY
105051: PPUSH
105052: LD_INT 25
105054: PUSH
105055: LD_INT 3
105057: PUSH
105058: EMPTY
105059: LIST
105060: LIST
105061: PPUSH
105062: CALL_OW 72
105066: ST_TO_ADDR
// if mc_remote_driver [ base ] then
105067: LD_EXP 128
105071: PUSH
105072: LD_VAR 0 1
105076: ARRAY
105077: IFFALSE 105101
// mechs := mechs diff mc_remote_driver [ base ] ;
105079: LD_ADDR_VAR 0 13
105083: PUSH
105084: LD_VAR 0 13
105088: PUSH
105089: LD_EXP 128
105093: PUSH
105094: LD_VAR 0 1
105098: ARRAY
105099: DIFF
105100: ST_TO_ADDR
// for i in mechs do
105101: LD_ADDR_VAR 0 5
105105: PUSH
105106: LD_VAR 0 13
105110: PUSH
105111: FOR_IN
105112: IFFALSE 105147
// if GetTag ( i ) > 0 then
105114: LD_VAR 0 5
105118: PPUSH
105119: CALL_OW 110
105123: PUSH
105124: LD_INT 0
105126: GREATER
105127: IFFALSE 105145
// mechs := mechs diff i ;
105129: LD_ADDR_VAR 0 13
105133: PUSH
105134: LD_VAR 0 13
105138: PUSH
105139: LD_VAR 0 5
105143: DIFF
105144: ST_TO_ADDR
105145: GO 105111
105147: POP
105148: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
105149: LD_ADDR_VAR 0 9
105153: PUSH
105154: LD_EXP 88
105158: PUSH
105159: LD_VAR 0 1
105163: ARRAY
105164: PPUSH
105165: LD_INT 2
105167: PUSH
105168: LD_INT 25
105170: PUSH
105171: LD_INT 1
105173: PUSH
105174: EMPTY
105175: LIST
105176: LIST
105177: PUSH
105178: LD_INT 25
105180: PUSH
105181: LD_INT 5
105183: PUSH
105184: EMPTY
105185: LIST
105186: LIST
105187: PUSH
105188: LD_INT 25
105190: PUSH
105191: LD_INT 8
105193: PUSH
105194: EMPTY
105195: LIST
105196: LIST
105197: PUSH
105198: LD_INT 25
105200: PUSH
105201: LD_INT 9
105203: PUSH
105204: EMPTY
105205: LIST
105206: LIST
105207: PUSH
105208: EMPTY
105209: LIST
105210: LIST
105211: LIST
105212: LIST
105213: LIST
105214: PPUSH
105215: CALL_OW 72
105219: ST_TO_ADDR
// if not defenders and not solds then
105220: LD_VAR 0 2
105224: NOT
105225: PUSH
105226: LD_VAR 0 9
105230: NOT
105231: AND
105232: IFFALSE 105236
// exit ;
105234: GO 106862
// depot_under_attack := false ;
105236: LD_ADDR_VAR 0 17
105240: PUSH
105241: LD_INT 0
105243: ST_TO_ADDR
// sold_defenders := [ ] ;
105244: LD_ADDR_VAR 0 18
105248: PUSH
105249: EMPTY
105250: ST_TO_ADDR
// if mechs then
105251: LD_VAR 0 13
105255: IFFALSE 105384
// for i in defenders do
105257: LD_ADDR_VAR 0 5
105261: PUSH
105262: LD_VAR 0 2
105266: PUSH
105267: FOR_IN
105268: IFFALSE 105382
// begin SetTag ( i , 20 ) ;
105270: LD_VAR 0 5
105274: PPUSH
105275: LD_INT 20
105277: PPUSH
105278: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
105282: LD_VAR 0 5
105286: PPUSH
105287: CALL_OW 263
105291: PUSH
105292: LD_INT 1
105294: EQUAL
105295: PUSH
105296: LD_VAR 0 5
105300: PPUSH
105301: CALL_OW 311
105305: NOT
105306: AND
105307: PUSH
105308: LD_VAR 0 13
105312: AND
105313: IFFALSE 105380
// begin un := mechs [ 1 ] ;
105315: LD_ADDR_VAR 0 11
105319: PUSH
105320: LD_VAR 0 13
105324: PUSH
105325: LD_INT 1
105327: ARRAY
105328: ST_TO_ADDR
// ComExitBuilding ( un ) ;
105329: LD_VAR 0 11
105333: PPUSH
105334: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
105338: LD_VAR 0 11
105342: PPUSH
105343: LD_VAR 0 5
105347: PPUSH
105348: CALL_OW 180
// SetTag ( un , 19 ) ;
105352: LD_VAR 0 11
105356: PPUSH
105357: LD_INT 19
105359: PPUSH
105360: CALL_OW 109
// mechs := mechs diff un ;
105364: LD_ADDR_VAR 0 13
105368: PUSH
105369: LD_VAR 0 13
105373: PUSH
105374: LD_VAR 0 11
105378: DIFF
105379: ST_TO_ADDR
// end ; end ;
105380: GO 105267
105382: POP
105383: POP
// if solds then
105384: LD_VAR 0 9
105388: IFFALSE 105447
// for i in solds do
105390: LD_ADDR_VAR 0 5
105394: PUSH
105395: LD_VAR 0 9
105399: PUSH
105400: FOR_IN
105401: IFFALSE 105445
// if not GetTag ( i ) then
105403: LD_VAR 0 5
105407: PPUSH
105408: CALL_OW 110
105412: NOT
105413: IFFALSE 105443
// begin defenders := defenders union i ;
105415: LD_ADDR_VAR 0 2
105419: PUSH
105420: LD_VAR 0 2
105424: PUSH
105425: LD_VAR 0 5
105429: UNION
105430: ST_TO_ADDR
// SetTag ( i , 18 ) ;
105431: LD_VAR 0 5
105435: PPUSH
105436: LD_INT 18
105438: PPUSH
105439: CALL_OW 109
// end ;
105443: GO 105400
105445: POP
105446: POP
// repeat wait ( 0 0$1 ) ;
105447: LD_INT 35
105449: PPUSH
105450: CALL_OW 67
// enemy := mc_scan [ base ] ;
105454: LD_ADDR_VAR 0 3
105458: PUSH
105459: LD_EXP 111
105463: PUSH
105464: LD_VAR 0 1
105468: ARRAY
105469: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105470: LD_EXP 88
105474: PUSH
105475: LD_VAR 0 1
105479: ARRAY
105480: NOT
105481: PUSH
105482: LD_EXP 88
105486: PUSH
105487: LD_VAR 0 1
105491: ARRAY
105492: PUSH
105493: EMPTY
105494: EQUAL
105495: OR
105496: IFFALSE 105533
// begin for i in defenders do
105498: LD_ADDR_VAR 0 5
105502: PUSH
105503: LD_VAR 0 2
105507: PUSH
105508: FOR_IN
105509: IFFALSE 105522
// ComStop ( i ) ;
105511: LD_VAR 0 5
105515: PPUSH
105516: CALL_OW 141
105520: GO 105508
105522: POP
105523: POP
// defenders := [ ] ;
105524: LD_ADDR_VAR 0 2
105528: PUSH
105529: EMPTY
105530: ST_TO_ADDR
// exit ;
105531: GO 106862
// end ; for i in defenders do
105533: LD_ADDR_VAR 0 5
105537: PUSH
105538: LD_VAR 0 2
105542: PUSH
105543: FOR_IN
105544: IFFALSE 106362
// begin e := NearestUnitToUnit ( enemy , i ) ;
105546: LD_ADDR_VAR 0 14
105550: PUSH
105551: LD_VAR 0 3
105555: PPUSH
105556: LD_VAR 0 5
105560: PPUSH
105561: CALL_OW 74
105565: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105566: LD_ADDR_VAR 0 8
105570: PUSH
105571: LD_EXP 88
105575: PUSH
105576: LD_VAR 0 1
105580: ARRAY
105581: PPUSH
105582: LD_INT 2
105584: PUSH
105585: LD_INT 30
105587: PUSH
105588: LD_INT 0
105590: PUSH
105591: EMPTY
105592: LIST
105593: LIST
105594: PUSH
105595: LD_INT 30
105597: PUSH
105598: LD_INT 1
105600: PUSH
105601: EMPTY
105602: LIST
105603: LIST
105604: PUSH
105605: EMPTY
105606: LIST
105607: LIST
105608: LIST
105609: PPUSH
105610: CALL_OW 72
105614: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
105615: LD_ADDR_VAR 0 17
105619: PUSH
105620: LD_VAR 0 8
105624: NOT
105625: PUSH
105626: LD_VAR 0 8
105630: PPUSH
105631: LD_INT 3
105633: PUSH
105634: LD_INT 24
105636: PUSH
105637: LD_INT 600
105639: PUSH
105640: EMPTY
105641: LIST
105642: LIST
105643: PUSH
105644: EMPTY
105645: LIST
105646: LIST
105647: PPUSH
105648: CALL_OW 72
105652: OR
105653: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
105654: LD_VAR 0 5
105658: PPUSH
105659: CALL_OW 247
105663: PUSH
105664: LD_INT 2
105666: DOUBLE
105667: EQUAL
105668: IFTRUE 105672
105670: GO 106068
105672: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
105673: LD_VAR 0 5
105677: PPUSH
105678: CALL_OW 256
105682: PUSH
105683: LD_INT 650
105685: GREATER
105686: PUSH
105687: LD_VAR 0 5
105691: PPUSH
105692: LD_VAR 0 14
105696: PPUSH
105697: CALL_OW 296
105701: PUSH
105702: LD_INT 40
105704: LESS
105705: PUSH
105706: LD_VAR 0 14
105710: PPUSH
105711: LD_EXP 113
105715: PUSH
105716: LD_VAR 0 1
105720: ARRAY
105721: PPUSH
105722: CALL_OW 308
105726: OR
105727: AND
105728: IFFALSE 105850
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
105730: LD_VAR 0 5
105734: PPUSH
105735: CALL_OW 262
105739: PUSH
105740: LD_INT 1
105742: EQUAL
105743: PUSH
105744: LD_VAR 0 5
105748: PPUSH
105749: CALL_OW 261
105753: PUSH
105754: LD_INT 30
105756: LESS
105757: AND
105758: PUSH
105759: LD_VAR 0 8
105763: AND
105764: IFFALSE 105834
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
105766: LD_VAR 0 5
105770: PPUSH
105771: LD_VAR 0 8
105775: PPUSH
105776: LD_VAR 0 5
105780: PPUSH
105781: CALL_OW 74
105785: PPUSH
105786: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
105790: LD_VAR 0 5
105794: PPUSH
105795: LD_VAR 0 8
105799: PPUSH
105800: LD_VAR 0 5
105804: PPUSH
105805: CALL_OW 74
105809: PPUSH
105810: CALL_OW 296
105814: PUSH
105815: LD_INT 6
105817: LESS
105818: IFFALSE 105832
// SetFuel ( i , 100 ) ;
105820: LD_VAR 0 5
105824: PPUSH
105825: LD_INT 100
105827: PPUSH
105828: CALL_OW 240
// end else
105832: GO 105848
// ComAttackUnit ( i , e ) ;
105834: LD_VAR 0 5
105838: PPUSH
105839: LD_VAR 0 14
105843: PPUSH
105844: CALL_OW 115
// end else
105848: GO 105951
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
105850: LD_VAR 0 14
105854: PPUSH
105855: LD_EXP 113
105859: PUSH
105860: LD_VAR 0 1
105864: ARRAY
105865: PPUSH
105866: CALL_OW 308
105870: NOT
105871: PUSH
105872: LD_VAR 0 5
105876: PPUSH
105877: LD_VAR 0 14
105881: PPUSH
105882: CALL_OW 296
105886: PUSH
105887: LD_INT 40
105889: GREATEREQUAL
105890: AND
105891: PUSH
105892: LD_VAR 0 5
105896: PPUSH
105897: CALL_OW 256
105901: PUSH
105902: LD_INT 650
105904: LESSEQUAL
105905: OR
105906: PUSH
105907: LD_VAR 0 5
105911: PPUSH
105912: LD_EXP 112
105916: PUSH
105917: LD_VAR 0 1
105921: ARRAY
105922: PPUSH
105923: CALL_OW 308
105927: NOT
105928: AND
105929: IFFALSE 105951
// ComMoveToArea ( i , mc_parking [ base ] ) ;
105931: LD_VAR 0 5
105935: PPUSH
105936: LD_EXP 112
105940: PUSH
105941: LD_VAR 0 1
105945: ARRAY
105946: PPUSH
105947: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
105951: LD_VAR 0 5
105955: PPUSH
105956: CALL_OW 256
105960: PUSH
105961: LD_INT 998
105963: LESS
105964: PUSH
105965: LD_VAR 0 5
105969: PPUSH
105970: CALL_OW 263
105974: PUSH
105975: LD_INT 1
105977: EQUAL
105978: AND
105979: PUSH
105980: LD_VAR 0 5
105984: PPUSH
105985: CALL_OW 311
105989: AND
105990: PUSH
105991: LD_VAR 0 5
105995: PPUSH
105996: LD_EXP 112
106000: PUSH
106001: LD_VAR 0 1
106005: ARRAY
106006: PPUSH
106007: CALL_OW 308
106011: AND
106012: IFFALSE 106066
// begin mech := IsDrivenBy ( i ) ;
106014: LD_ADDR_VAR 0 10
106018: PUSH
106019: LD_VAR 0 5
106023: PPUSH
106024: CALL_OW 311
106028: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
106029: LD_VAR 0 10
106033: PPUSH
106034: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
106038: LD_VAR 0 10
106042: PPUSH
106043: LD_VAR 0 5
106047: PPUSH
106048: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
106052: LD_VAR 0 10
106056: PPUSH
106057: LD_VAR 0 5
106061: PPUSH
106062: CALL_OW 180
// end ; end ; unit_human :
106066: GO 106333
106068: LD_INT 1
106070: DOUBLE
106071: EQUAL
106072: IFTRUE 106076
106074: GO 106332
106076: POP
// begin b := IsInUnit ( i ) ;
106077: LD_ADDR_VAR 0 19
106081: PUSH
106082: LD_VAR 0 5
106086: PPUSH
106087: CALL_OW 310
106091: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
106092: LD_ADDR_VAR 0 20
106096: PUSH
106097: LD_VAR 0 19
106101: NOT
106102: PUSH
106103: LD_VAR 0 19
106107: PPUSH
106108: CALL_OW 266
106112: PUSH
106113: LD_INT 32
106115: PUSH
106116: LD_INT 31
106118: PUSH
106119: EMPTY
106120: LIST
106121: LIST
106122: IN
106123: OR
106124: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
106125: LD_VAR 0 17
106129: PUSH
106130: LD_VAR 0 2
106134: PPUSH
106135: LD_INT 21
106137: PUSH
106138: LD_INT 2
106140: PUSH
106141: EMPTY
106142: LIST
106143: LIST
106144: PPUSH
106145: CALL_OW 72
106149: PUSH
106150: LD_INT 1
106152: LESSEQUAL
106153: OR
106154: PUSH
106155: LD_VAR 0 20
106159: AND
106160: PUSH
106161: LD_VAR 0 5
106165: PUSH
106166: LD_VAR 0 18
106170: IN
106171: NOT
106172: AND
106173: IFFALSE 106266
// begin if b then
106175: LD_VAR 0 19
106179: IFFALSE 106228
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
106181: LD_VAR 0 19
106185: PPUSH
106186: LD_VAR 0 3
106190: PPUSH
106191: LD_VAR 0 19
106195: PPUSH
106196: CALL_OW 74
106200: PPUSH
106201: CALL_OW 296
106205: PUSH
106206: LD_INT 10
106208: LESS
106209: PUSH
106210: LD_VAR 0 19
106214: PPUSH
106215: CALL_OW 461
106219: PUSH
106220: LD_INT 7
106222: NONEQUAL
106223: AND
106224: IFFALSE 106228
// continue ;
106226: GO 105543
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
106228: LD_ADDR_VAR 0 18
106232: PUSH
106233: LD_VAR 0 18
106237: PPUSH
106238: LD_VAR 0 18
106242: PUSH
106243: LD_INT 1
106245: PLUS
106246: PPUSH
106247: LD_VAR 0 5
106251: PPUSH
106252: CALL_OW 1
106256: ST_TO_ADDR
// ComExitBuilding ( i ) ;
106257: LD_VAR 0 5
106261: PPUSH
106262: CALL_OW 122
// end ; if sold_defenders then
106266: LD_VAR 0 18
106270: IFFALSE 106330
// if i in sold_defenders then
106272: LD_VAR 0 5
106276: PUSH
106277: LD_VAR 0 18
106281: IN
106282: IFFALSE 106330
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
106284: LD_VAR 0 5
106288: PPUSH
106289: CALL_OW 314
106293: NOT
106294: PUSH
106295: LD_VAR 0 5
106299: PPUSH
106300: LD_VAR 0 14
106304: PPUSH
106305: CALL_OW 296
106309: PUSH
106310: LD_INT 30
106312: LESS
106313: AND
106314: IFFALSE 106330
// ComAttackUnit ( i , e ) ;
106316: LD_VAR 0 5
106320: PPUSH
106321: LD_VAR 0 14
106325: PPUSH
106326: CALL_OW 115
// end ; end ; end ;
106330: GO 106333
106332: POP
// if IsDead ( i ) then
106333: LD_VAR 0 5
106337: PPUSH
106338: CALL_OW 301
106342: IFFALSE 106360
// defenders := defenders diff i ;
106344: LD_ADDR_VAR 0 2
106348: PUSH
106349: LD_VAR 0 2
106353: PUSH
106354: LD_VAR 0 5
106358: DIFF
106359: ST_TO_ADDR
// end ;
106360: GO 105543
106362: POP
106363: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
106364: LD_VAR 0 3
106368: NOT
106369: PUSH
106370: LD_VAR 0 2
106374: NOT
106375: OR
106376: PUSH
106377: LD_EXP 88
106381: PUSH
106382: LD_VAR 0 1
106386: ARRAY
106387: NOT
106388: OR
106389: IFFALSE 105447
// MC_Reset ( base , 18 ) ;
106391: LD_VAR 0 1
106395: PPUSH
106396: LD_INT 18
106398: PPUSH
106399: CALL 24718 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
106403: LD_ADDR_VAR 0 2
106407: PUSH
106408: LD_VAR 0 2
106412: PUSH
106413: LD_VAR 0 2
106417: PPUSH
106418: LD_INT 2
106420: PUSH
106421: LD_INT 25
106423: PUSH
106424: LD_INT 1
106426: PUSH
106427: EMPTY
106428: LIST
106429: LIST
106430: PUSH
106431: LD_INT 25
106433: PUSH
106434: LD_INT 5
106436: PUSH
106437: EMPTY
106438: LIST
106439: LIST
106440: PUSH
106441: LD_INT 25
106443: PUSH
106444: LD_INT 8
106446: PUSH
106447: EMPTY
106448: LIST
106449: LIST
106450: PUSH
106451: LD_INT 25
106453: PUSH
106454: LD_INT 9
106456: PUSH
106457: EMPTY
106458: LIST
106459: LIST
106460: PUSH
106461: EMPTY
106462: LIST
106463: LIST
106464: LIST
106465: LIST
106466: LIST
106467: PPUSH
106468: CALL_OW 72
106472: DIFF
106473: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
106474: LD_VAR 0 3
106478: NOT
106479: PUSH
106480: LD_VAR 0 2
106484: PPUSH
106485: LD_INT 21
106487: PUSH
106488: LD_INT 2
106490: PUSH
106491: EMPTY
106492: LIST
106493: LIST
106494: PPUSH
106495: CALL_OW 72
106499: AND
106500: IFFALSE 106838
// begin tmp := FilterByTag ( defenders , 19 ) ;
106502: LD_ADDR_VAR 0 12
106506: PUSH
106507: LD_VAR 0 2
106511: PPUSH
106512: LD_INT 19
106514: PPUSH
106515: CALL 84170 0 2
106519: ST_TO_ADDR
// if tmp then
106520: LD_VAR 0 12
106524: IFFALSE 106594
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
106526: LD_ADDR_VAR 0 12
106530: PUSH
106531: LD_VAR 0 12
106535: PPUSH
106536: LD_INT 25
106538: PUSH
106539: LD_INT 3
106541: PUSH
106542: EMPTY
106543: LIST
106544: LIST
106545: PPUSH
106546: CALL_OW 72
106550: ST_TO_ADDR
// if tmp then
106551: LD_VAR 0 12
106555: IFFALSE 106594
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
106557: LD_ADDR_EXP 100
106561: PUSH
106562: LD_EXP 100
106566: PPUSH
106567: LD_VAR 0 1
106571: PPUSH
106572: LD_EXP 100
106576: PUSH
106577: LD_VAR 0 1
106581: ARRAY
106582: PUSH
106583: LD_VAR 0 12
106587: UNION
106588: PPUSH
106589: CALL_OW 1
106593: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
106594: LD_VAR 0 1
106598: PPUSH
106599: LD_INT 19
106601: PPUSH
106602: CALL 24718 0 2
// repeat wait ( 0 0$1 ) ;
106606: LD_INT 35
106608: PPUSH
106609: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106613: LD_EXP 88
106617: PUSH
106618: LD_VAR 0 1
106622: ARRAY
106623: NOT
106624: PUSH
106625: LD_EXP 88
106629: PUSH
106630: LD_VAR 0 1
106634: ARRAY
106635: PUSH
106636: EMPTY
106637: EQUAL
106638: OR
106639: IFFALSE 106676
// begin for i in defenders do
106641: LD_ADDR_VAR 0 5
106645: PUSH
106646: LD_VAR 0 2
106650: PUSH
106651: FOR_IN
106652: IFFALSE 106665
// ComStop ( i ) ;
106654: LD_VAR 0 5
106658: PPUSH
106659: CALL_OW 141
106663: GO 106651
106665: POP
106666: POP
// defenders := [ ] ;
106667: LD_ADDR_VAR 0 2
106671: PUSH
106672: EMPTY
106673: ST_TO_ADDR
// exit ;
106674: GO 106862
// end ; for i in defenders do
106676: LD_ADDR_VAR 0 5
106680: PUSH
106681: LD_VAR 0 2
106685: PUSH
106686: FOR_IN
106687: IFFALSE 106776
// begin if not IsInArea ( i , mc_parking [ base ] ) then
106689: LD_VAR 0 5
106693: PPUSH
106694: LD_EXP 112
106698: PUSH
106699: LD_VAR 0 1
106703: ARRAY
106704: PPUSH
106705: CALL_OW 308
106709: NOT
106710: IFFALSE 106734
// ComMoveToArea ( i , mc_parking [ base ] ) else
106712: LD_VAR 0 5
106716: PPUSH
106717: LD_EXP 112
106721: PUSH
106722: LD_VAR 0 1
106726: ARRAY
106727: PPUSH
106728: CALL_OW 113
106732: GO 106774
// if GetControl ( i ) = control_manual then
106734: LD_VAR 0 5
106738: PPUSH
106739: CALL_OW 263
106743: PUSH
106744: LD_INT 1
106746: EQUAL
106747: IFFALSE 106774
// if IsDrivenBy ( i ) then
106749: LD_VAR 0 5
106753: PPUSH
106754: CALL_OW 311
106758: IFFALSE 106774
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
106760: LD_VAR 0 5
106764: PPUSH
106765: CALL_OW 311
106769: PPUSH
106770: CALL_OW 121
// end ;
106774: GO 106686
106776: POP
106777: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
106778: LD_VAR 0 2
106782: PPUSH
106783: LD_INT 95
106785: PUSH
106786: LD_EXP 112
106790: PUSH
106791: LD_VAR 0 1
106795: ARRAY
106796: PUSH
106797: EMPTY
106798: LIST
106799: LIST
106800: PPUSH
106801: CALL_OW 72
106805: PUSH
106806: LD_VAR 0 2
106810: EQUAL
106811: PUSH
106812: LD_EXP 111
106816: PUSH
106817: LD_VAR 0 1
106821: ARRAY
106822: OR
106823: PUSH
106824: LD_EXP 88
106828: PUSH
106829: LD_VAR 0 1
106833: ARRAY
106834: NOT
106835: OR
106836: IFFALSE 106606
// end ; MC_Reset ( base , 19 ) ;
106838: LD_VAR 0 1
106842: PPUSH
106843: LD_INT 19
106845: PPUSH
106846: CALL 24718 0 2
// MC_Reset ( base , 20 ) ;
106850: LD_VAR 0 1
106854: PPUSH
106855: LD_INT 20
106857: PPUSH
106858: CALL 24718 0 2
// end ;
106862: LD_VAR 0 4
106866: RET
